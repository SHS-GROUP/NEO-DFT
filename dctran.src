C 15 APR 11 - MWS - SKIP FCODDI ENTIRELY IF -DOCORE- SAYS TO SKIP
C 15 APR 11 - MK  - COMBINE ONETRFDC AND ONETFD
C 11 AUG 10 - DGF - SYNCH COMMON BLOCK ENRGYS
C 22 MAY 09 - MWS - PAD ARGUMENTS FOR FCODDI CALL
C 12 JAN 09 - TA,MK - IMPLEMENTATION OF DIVIDE-AND-CONQUER
C
C*MODULE DCTRAN  *DECK TRFMCXDC
C        MODIFIED FROM TRFMCX
      SUBROUTINE TRFMCXDC(NPRINT,ICORBS,IORBS,IORB,DOFOCK,DOEXCH,
     *                    DDITRF,DOOOOO,DOVOOO,DOVVOO,DOVOVO,
     *                    DOVVVO,DOVVVV,DOCORE,LVEC,QMAT,SMAT,ISUB)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXGSH=30, MXG2=MXGSH*MXGSH,
     *           MXATM=2000, MXRT=100, NMO=500, MXAO=8192)
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      LOGICAL DOFOCK,DOEXCH,SOME,DEBUG,DEBG1,PACK2E,
     *        MASWRK,DSKWRK,GOPARR,DLB,DIRTRF,
     *        ABEL,ABELPT,MOIDON,EDCOMP,DIPDCM,
     *        DEPRNT,QADDCM,ZDO,POLDCM,POLANG,POLAPP,KMIDPT,POLDYN,
     *        NOTRF,DDITRF,DOOOOO,DOVOOO,DOVVOO,DOVOVO,DOVVVO,DOVVVV,
     &        DOCORE
C
      COMMON /CIFILS/ NFT11,NFT12,NFT13,NFT14,NFT15,NFT16,IDAF20,NEMEMX
      COMMON /DIRMEM/ IPQKL,IVEC,IDEN,IFCK,NBF,NOC,NDIM,MNPQ,MXPQ
      COMMON /EDCMP / ZIJ(NMO),ZMO(5,NMO),OCCUP(NMO),DPFREQ(50),
     *                MOIDNO(5,NMO),IJMO(2,NMO),MOIJ(NMO),NMOIJ(NMO),
     *                NMOAT(NMO),NDPFREQ,IPROT(5),NPROT,
     *                MOIDON,EDCOMP,DIPDCM,DEPRNT,QADDCM,ZDO,POLDCM,
     *                POLANG,POLAPP,KMIDPT,POLDYN
      COMMON /ENRGYS/ EN,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FMCOM / X(1)
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /INT2IC/ NINTIC,ININTIC,NXXIC,LBUFPIC,LIXIC,LABSIX,NINTIX
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /MCPAR / NFZC,NCORBS,NVAL,NORBS,NORB,NUM1
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /NTNOPT/ ENERGY,ENERG0,DEMAX,SQCDF,ITER,MICRO,NOTRF
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCKLAB/ LABSIZ
      COMMON /PSILVL/ IPSI,ISKPRP
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SYMMOL/ GROUP,COMPLX,IGROUP,NAXIS,ILABMO,ABEL
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                TSYM(432),INVT(48),NT
      COMMON /TRFOPT/ CUTTRF,NWDTRF,MPTRAN,ITRFAO,NOSYMT,IPURTF,DIRTRF
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      INTEGER         D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB
      LOGICAL         NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
      COMMON /TRFDMS/ D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB,
     *                NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
C
      COMMON /DCQMT / NLQMT(MXATM)
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
      COMMON /DCMEM2/ IPQRJI,IDCMOD
C
      DIMENSION QMAT(*),SMAT(*)
C
      PARAMETER (ZERO=0.0D+00)
C
      DATA RMC/8HMCSCF   /, CHECK/8HCHECK   /
      DATA DBUG/8HDEBUG   /, DBUGME/8HTRNSF   /
      DATA PROP/8HPROP    /
      DATA RNONE/8HNONE    /
C
C           ----- PARTIAL INTEGRAL TRANSFORMATION PROGRAM -----
C     -- TRANSFORM INTEGRALS AND OPTIONALLY FORM CORE FOCK OPERATOR --
C     ALL INTEGRALS WITH 0,1,2 VIRTUAL ORBITAL INDEXES ARE PRODUCED.
C
C     -NPRINT- SHOULD BE 1,2 FOR DEBUG OUTPUT OF 1,2 E- TRANSFORM.
C     -ICORBS- IS NUMBER OF CORE ORBS.  IF NEGATIVE, SKIP FROZEN CORE E
C     -IORBS- IS NUMBER OF OCCUPIED ORBS INCLUDED IN THE TRANSFORM,
C        INCLUDING ANY CORE ORBITALS.
C     -IORB- IS THE TOTAL NUMBER OF ORBS TO INCLUDE IN THE TRANSFORM.
C     -DOFOCK- IS A FLAG TO CONTROL GENERATION OF CORE FOCK MATRIX:
C            SUPPOSE THERE ARE 3 CORES, 5 TOTAL OCCUPIED.
C        IF FALSE, NO CORE FOCK MATRIX IS MADE, AND THE INDEX LABELS
C            PACKED UP FOR THE OCCUPIED ORBS ARE 1 AND 2.  NO CORE
C            ORBITAL INTEGRALS ARE PRODUCED IN SERIAL TRANSFORMS.
C        IF TRUE, THE CORE FOCK MATRIX IS MADE, AND THE INDEX LABELS
C            PACKED UP FOR THE OCCUPIED ORBS ARE 4 AND 5.  ALL
C            INTEGRALS INVOLVING THE CORE ORBITALS ARE PRODUCED
C            AND INCLUDED IN THE OUTPUT FILES, LABELED 1,2,3.  NOTE:
C            THIS OPTION IS NOT TESTED, AND THUS MAY NOT BE WORKING.
C       NOTE THAT -DOFOCK- DOES NOT CONTROL MODIFYING THE 1E-
C       INTEGRALS FOR THE ABSENCE OF FROZEN CORE ORBITALS.
C     -DOEXCH- INDICATES EXCHANGE INTEGRALS ARE NOT AVAILABLE ON THE
C              DAF FILE, AND THEREFORE MUST BE COMPUTED.
C     -DDITRF- CONTROL SELECTION OF A DISTRIBUTED MEMORY PARALLEL
C              INTEGRAL TRANSFORMATION.  IT REQUIRES EXTRA OPTIONS TO
C              SELECT THE DESIRED INTEGRAL CLASSES: -DOOOOO-, -DOVOOO-,
C              -DOVOVO-, -DOVVOO-, -DOVVVO-, -DOVVVV- ARE IGNORED
C              UNLESS -DDITRF- IS TURNED ON.   NOTE THAT -DOVVVV- IS
C              PRESENTLY AN INACTIVE PLACEHOLDER ARGUMENT.
C     -DOCORE- PERTAINS ONLY TO THE DISTRIBUTED MEMORY TRANSFORMATION.
C              IT CAUSES ALL CORE ORBITALS TO BE INCLUDED INTO THE
C              INTEGRAL TRANSFORMATION.  IF .FALSE., THERE IS NOT
C              ENOUGH INFORMATION FOR -DOFOCK- TO BE REQUESTED!
C     THERE ARE CIRCUMSTANCES THE OTHER WAY AROUND, HOWEVER,
C     WHERE -DOFOCK- IS OFF AND -DOCORE- IS ON.  THIS IS MURKY.
C
C     IN JUNE 2010, MWS DECIDED THAT THE CALLING ROUTINES SHOULD
C     ALL BE LEFT ALONE, JUST AS THEY WERE, BUT TO AVOID -FCODDI-
C     IF -DOCORE- IS OFF.  THIS CURES OUT-OF-BOUNDS DDI ACCESSES.
C     THE FOLLOWING KINDS OF PARALLEL RUNS CALLING THIS ROUTINE
C     WERE VERIFIED TO WORK, PRINTING THEIR TWO ARGS:
C                            DOFOCK DOCORE
C                  GUGA CI      F      T
C                 ALDET CI      F      T
C                 ORMAS CI      F      T
C              DETERMINANT PT   F      T  (T&T IN ITS MCSCF ITERS)
C               MCSCF HESSIAN   F      T
C              CCSD(T) ENERGY   F      F
C            RUEDENBERG LOCAL   F      F
C
      L0 = NLQMT(ISUB)
      L1 = LNUM
      L2 = (L1*L1+L1)/2
      L3 =  L1*L1
C
      IDCMOD=1
C
C        LABSIZ IS NORMALLY SET BY -DEBUT- BUT THAT MIGHT NOT BE CALLED
C
      IF(RUNTYP.EQ.PROP) THEN
         MAXAO=255
         LABSIZ = 1
         IF(NUM.GT.MAXAO) LABSIZ = 2
      END IF
C
C         DECIDE ON THE LEVEL OF PRINTING
C
      SOME  = NPRINT.NE.-5 .AND. MASWRK
      DEBG1 = NPRINT.EQ. 1 .AND. MASWRK
      DEBUG = NPRINT.EQ. 2 .AND. MASWRK
      IF (EXETYP.EQ.DBUG   .OR.   EXETYP.EQ.DBUGME) THEN
         SOME = .TRUE. .AND. MASWRK
         DEBUG= .TRUE. .AND. MASWRK
      END IF
C
      IF(SOME) WRITE(IW,9000)
C
      NREC=0
      NINT=0
C
      MINTMX=NINTMX
      IF(NINTIC.NE.0) MINTMX=0
C     MEMORY IS ALLOCATED ELSEWHERE
C
      CALL SEQOPN(IJKT,'MOINTS','UNKNOWN',.FALSE.,'UNFORMATTED')
C
C     ----- PROVIDE DEFAULT VALUES FOR NCORBS,NORB -----
C     THESE MAY HAVE BEEN PASSED IN THE CALLING ARGUMENTS.
C     NCORBS IS THE NUMBER OF -FZC- OR -MCC- GIVEN IN $DRTINP
C     NORBS  IS THE NUMBER OF OCCUPIED ORBITALS FOR MCSCF,
C            AND IS THE NUMBER OF OCCUPIED, NON-FZC FOR CI.
C     NORB IS THE TOTAL NUMBER TO BE INCLUDED (I.E. INCLUDING VIRTUALS)
C
      CALL DERCHK(NDER)
      JCORBS = IABS(ICORBS)
      NCORBS = JCORBS
      NORBS  = IORBS
      NORB   = IORB
C
      NVAL = NORBS - NCORBS
      IF (SOME) WRITE (IW,9010) NCORBS,NORBS,NORB,L1,CUTTRF
C
C     ----- DISTRIBUTED MEMORY PARALLEL INTEGRAL TRANSFORMATION -----
C              IMPLEMENTED BY GRAHAM FLETCHER, FEB 14, 2002
C
C     DO NOT SKIP CORE INDICES IN TRANSFORMATION FOR MCSCF
C
      IF (DDITRF) THEN
        WRITE(IW,*) "##ERROR! NOT FINISHED TO IMPLEMENT"
        CALL ABRT
C
C  ENSURE THE PAIR-INDEX IS INITIALIZED (AGAIN!)
C
        II = 0
        DO I = 1, MXAO
          IA(I) = II
          II = II + I
        END DO
C
C  DISTINCT NAMES
C
        NBF  = LNUM
        NMOS = NORB
        NOCC = NORBS
        NCOR = NCORBS
C
C  DRIVER FOR PARALLEL DIRECT 4-INDEX TRANSFORMATION
C
        CALL TRANDDI(NMOS,NOCC,NCOR,SOME,DOOOOO,DOVOOO,DOVVOO,DOVOVO,
     &               DOVVVO,DOVVVV,DOCORE)
C
C  DEPENDENT PARAMETERS
C
        NBSQ = NBF*NBF
        NBTR = (NBF*NBF+NBF)/2
        NMTR = (NMOS*NMOS+NMOS)/2
C
C  DATA STRUCTURE LENGTHS
C
        LVECT = NBSQ
        LONEL = NBTR
        LHAMO = NMTR
        LWORK = NBF
C
C  ALLOCATE MEMORY: COMPUTE ADDRESSES AND CHECK TOTAL
C
        CALL VALFM(LOADFM)
        IVECT = LOADFM + 1            !  MO COEFFICIENTS
        IONEL = IVECT  + LVECT        !  1-EL INTEGRALS OVER AOS
        IHAMO = IONEL  + LONEL        !  1-EL INTEGRALS OVER MOS
        IWORK = IHAMO  + LHAMO        !  WORKSPACE
        LAST  = IWORK  + LWORK
        NEED  = LAST   - LOADFM
        CALL GETFM(NEED)
        IF (EXETYP.NE.CHECK) THEN
C
C  READ MO COEFFICIENTS
C
          CALL DAREAD(IDAF,IODA,X(IVECT),LVECT,15,0)
C
C  READ 1-EL (CORE-HAMILTONIAN) INTEGRALS, TRANSFORM TO MO BASIS
C
          CALL DAREAD(IDAF,IODA,X(IONEL),LONEL,11,0)
          CALL TFTRI(X(IHAMO),X(IONEL),X(IVECT),X(IWORK),NMOS,NBF,NBF)
C
C  SAVE 1-EL INTEGRALS OVER MOS FOR USE IN NEWTON
C  THIS IS NOT DONE IF THIS ROUTINE COMPUTES ONLY OOOO CASE.
C
          IF(DOVOOO .OR. DOVVOO .OR. DOVOVO)
     *       CALL DAWRIT(IDAF,IODA,X(IHAMO),LHAMO,355,0)
C
C  FORM 2-EL CORE FOCK OPERATOR IN PARALLEL
C
          IFCOR = IONEL   !  RE-USE 1-EL INT BUFFER FOR CORE FOCK
          IBUFF = IVECT   !  RE-USE VECTORS BUFFER FOR MESSAGES
C
          IF(DOCORE) THEN
             CALL FCODDI(NMOS,NOCC,NCOR,X(IFCOR),X(IBUFF),
     *                   DOOOOO, DOVOOO, DOVVOO, DOVOVO)
C
C  SUM 1-EL AND 2-EL TERMS OF CORE FOCK MATRIX, SAVE CORE FOCK MATRIX
C
             CALL DAXPY(LHAMO,1.0D+00,X(IHAMO),1,X(IFCOR),1)
             CALL DAWRIT(IDAF,IODA,X(IFCOR),NBTR,35,0)
C
C  COMPUTE FROZEN CORE ENERGY
C
             ECORE = ZERO
             IHII = IHAMO - 1
             IFII = IFCOR - 1
             DO I = 1, NCOR
               IHII = IHII + I
               IFII = IFII + I
               ECORE = ECORE + X(IHII) + X(IFII)
             END DO
             IF(SOME.AND.NCORBS.GT.0) WRITE(IW,9040) ECORE
          ELSE
             ECORE = ZERO
             CALL DCOPY(LHAMO,X(IHAMO),1,X(IFCOR),1)
          ENDIF
C
C  COPY FOCK ELEMENTS OVER ACTIVE MOS TO SEPARATE BUFFER
C      SAVE MATRIX OVER ALL ORBITALS, THAT IS
C      I LOOP RUNS TO NMOS RATHER THAN NACT,
C      AND THE WRITE IS NMTR RATHER THAN NATR
C
          IJ = IHAMO
          DO I = 1, NMOS
            IN = I + NCOR
            DO J = 1, I
              JN = J + NCOR
              IJN = IA(IN) + JN
              IJH = (IFCOR-1) + IJN
              X(IJ) = X(IJH)
              IJ = IJ + 1
            END DO
          END DO
C
C  SAVE ACTIVE MO CORE FOCK ELEMENTS FOR CI (RDCI12)
C
          CALL SEQREW(IJKT)
          IF (MASWRK) CALL SQWRIT(IJKT,X(IHAMO),NMTR)
C
C  FREE DISTRIBUTED WORKSPACE IF JUST NEED OOOO AND/OR VOOO
C
          IF (.NOT.NDVVOO) CALL DDI_DESTROY(D_VVOO)
        END IF   ! CHECK RUN
C
        CALL RETFM(NEED)
        IF(SOME) WRITE(IW,*) '... END OF INTEGRAL TRANSFORMATION ...'
        IF(SOME) CALL TIMIT(1)
        RETURN
      END IF
C
C     THIS IS THE  END OF THE DISTRIBUTED MEMORY INTEGRAL TRANSFORMATION
C
C     ----- REPLICATED MEMORY PARALLEL INTEGRAL TRANSFORMATION -----
C
      IF (DIRTRF) THEN
        IF (SOME) WRITE(IW,9020)
      ELSE
        IF (SOME) WRITE(IW,9030)
      END IF
C
      NDIM=L2
C
      CALL GOTFM(NGOTMX)
      IF(NWDTRF.LE.0) NWDTRF=NGOTMX
      NWORD=MIN(NWDTRF,NGOTMX)
C
C     ----- SET POINTERS TO MEMORY FOR DIRECT RUNS -----
C     XBUF AND IXBUF ARE OUTPUT MO INTEGRAL BUFFERS
C
      CALL BASCHK(LMAX)
                    NANGM =  4
      IF(LMAX.EQ.2) NANGM =  6
      IF(LMAX.EQ.3) NANGM = 10
      IF(LMAX.EQ.4) NANGM = 15
      IF(LMAX.EQ.5) NANGM = 21
      IF(LMAX.EQ.6) NANGM = 28
      MAXG = NANGM**4
      NSH2   = (NSHELL*NSHELL+NSHELL)/2
      NCPU   = NPROC
C
      CALL VALFM(LOADFM)
      LXBUF  = LOADFM + 1
      LIXBUF = LXBUF  + NINTMX
      LJFLG  = LIXBUF + NINTMX
      LAST   = LJFLG  + NPROC
      IF (DIRTRF) THEN
         LGHND  = LAST
         LXINTS = LGHND  + MAXG
         LDDIJ  = LXINTS + NSH2
         LDSH   = LDDIJ  + 49*MXG2
         LAST   = LDSH   + NSH2
      ELSE
         LGHND  = LAST
         LXINTS = LAST
         LDDIJ  = LAST
         LDSH   = LAST
      END IF
      NEEDD = LAST - LOADFM - 1
      CALL GETFM(NEEDD)
C
C        ---- GENERATE EXCHANGE INTEGRALS FOR SCHWARZ SCREENING ----
C
      IF(DIRTRF) THEN
         IF(EXETYP.EQ.CHECK) THEN
            CALL VCLR(X(LXINTS),1,NSH2)
         ELSE
            IF(DOEXCH) THEN
               CALL DEBUT(.FALSE.,DUM,DUM,IDUM,NINTMX,0,DIRTRF)
               CALL EXCHNG(X(LXINTS),X(LGHND),X(LDDIJ),NSH2,MAXG,INTTYP)
            ELSE
               CALL DAREAD(IDAF,IODA,X(LXINTS),NSH2,54,0)
            END IF
         END IF
      END IF
C
C        ---- OPTION TO DEFEAT SYMMETRY USAGE ----
C
      ABEL=ABELPT()
      IF(NOSYMT.EQ.1) CALL SYMOFF
C
C        ---- MEMORY TO STORE VECTORS AND SYMMETRY DATA ----
C
      CALL VALFM(LOADFM)
      LMOLAB = LOADFM + 1
      LMOIRP = LMOLAB + L1
      LAST   = LMOIRP + L1
      NEEDV = LAST - LMOLAB
      CALL GETFM(NEEDV)
C
C        ---- CLEAN UP AND ORTHONORMALIZE ORBITALS ----
C        BRANCH IF YOU DO NOT WANT TO ORTHOGONALIZE THE MO'S
C
      IF (ZDO)            GO TO 10
      IF (VBTYP.NE.RNONE) GO TO 10
C
      LTMP  = LAST  + 1
      LLABS = LTMP  + L1
      LWRK  = LLABS + L1
      LWRK2 = LWRK  + L3
      LAST  = LWRK2 + L3
      NEEDO = LAST - LTMP
      CALL GETFM(NEEDO)
C
C          TRADITIONAL VALUES ARE 1D-8 AND 1D-6 RESPECTIVELY
      IF(NT.GT.1) THEN
         IF(ABEL) THEN
            TOLZ=1.0D-09
            TOLE=1.0D-07
         ELSE
            TOLZ=1.0D-11
            TOLE=1.0D-10
         END IF
         IF(SCFTYP.EQ.RMC  .AND.  IPSI.EQ.0) THEN
            IF(ITER.EQ.1  .OR.  SQCDF.GT.1.0D-04) THEN
               TOLZ=TOLZ*10.0D+00
               TOLE=TOLE*10.0D+00
            END IF
         END IF
         CALL CLENMO(X(LVEC),L1,L0,TOLZ,TOLE,IW,.FALSE.)
      END IF
C
C            OPTION TO PURIFY ORBITALS
C
      IF(IPURTF.EQ.2) THEN
        CALL DCOPY(L3,QMAT,1,X(LWRK2),1)
        CALL SYMMOS(X(LLABS),QMAT,SMAT,X(LVEC),X(LWRK),L0,L1,NORB,L1)
        CALL ORBPUR(SMAT,X(LVEC),L1,L0,.TRUE.)
        CALL DCOPY(L3,X(LWRK2),1,QMAT,1)
      END IF
C
      CALL ORTHO(QMAT,SMAT,X(LVEC),X(LTMP),L0,L0,L1,L2,L1)
      CALL TFSQB(X(LVEC),QMAT,X(LTMP),L0,L1,L1)
C
      CALL RETFM(NEEDO)
C
   10 CONTINUE
      IF(DOFOCK) GO TO 50
C
C        ----- ONE ELECTRON TRANSFORMATION/FROZEN CORE ENERGY -----
C
      CALL VALFM(LOADFM)
      LD    = LOADFM + 1
      LF    = LD     + L2
      LXX   = LF     + L2
      LIX   = LXX    + MINTMX
      LWRK  = LIX    + MINTMX
      LAST  = LWRK   + L2
      NEED1 = LAST - LOADFM - 1
      IF(NINTIC.NE.0) THEN
         LXX= LBUFPIC
         LIX= LIXIC
      ENDIF
      CALL GETFM(NEED1)
C
C ##### 1-E INTEGRALS ARE NOT IMPLEMENTED #####
C
C        ---- DROP ANY FROZEN CORES FROM THE TRANSFORMATION ----
C
      LVEC   = LVEC + L1*NCORBS
      NORB   = NORB   - NCORBS
      NORBS  = NORBS  - NCORBS
      NCORBS = NCORBS - NCORBS
C
      IF (DEBG1  .OR.  DEBUG) THEN
         WRITE (IW,*) 'TRANSFORMATION VECTORS'
         CALL PRSQ(X(LVEC),NORB,L1,L1)
      END IF
C
C  ONE RECORD SHOULD BE BEFORE 2-E INTEGRALS IN MASWRK
C
      M2 = (NORB*NORB+NORB)/2
      CALL SEQREW(IJKT)
      IF(MASWRK) CALL SQWRIT(IJKT,X(LF),M2)
      CALL RETFM(NEED1)
C
C        ---- ASSIGN IRREP SYMMETRY TO THE TRANSFORMATION MO'S ----
C        LATER, WE USE SYMMETRY TYPE TO ELIMINATE FULLNR ROTATIONS
C
   50 CONTINUE
      CALL VALFM(LOADFM)
      LWRK   = LOADFM + 1
      LMODEG = LWRK   + L1
      LAST   = LMODEG + L1
      NEEDS = LAST - LOADFM - 1
      CALL GETFM(NEEDS)
C
C         MCSCF JOBS NEED TO KNOW ORBITAL SYMMETRY TO PROPERLY
C         ESTIMATE THE NUMBER OF NON-REDUNDANT ROTATIONS IN ORDER
C         TO PROPERLY SIZE FULLNR MEMORY NEEDS.  INPUT ORBITALS
C         SHOULD BE THE TRUE MOREAD, SO WE CAN TRUST THE SYMMETRY
C         LABELS THAT WE GENERATE IN THIS CASE.
C
      IF(EXETYP.NE.CHECK  .OR.  SCFTYP.EQ.RMC) THEN
         CALL TRFSYM(X(LMOLAB),X(LMOIRP),X(LMODEG),QMAT,SMAT,X(LVEC),
     *               X(LWRK),IA,L0,L1,NORB,L1)
      END IF
C
      CALL RETFM(NEEDS)
C
      NTSAVE = NT
      IF(DIRTRF  .AND.  .NOT.ABEL) NT=1
C
C     -------- TRANSFORM TWO ELECTRON INTEGRALS ------
C     --- MEMORY FOR DIRECT OR CONVENTIONAL PARTIAL TRANSFORMATION ---
C     THIS DIVIDES INTO AN IN MEMORY, AND A SEGMENTED OPTION
C
      NMUL = L1*L2*NORBS
      FMUL = L1
      FMUL = FMUL*L2
      FMUL = FMUL*NORBS
C
      CALL VALFM(LOADFM)
      LFCK  = LOADFM + 1
      LDEN  = LFCK   + MAX(L2,L3)
      LXX   = LDEN   + MAX(L2,L3)
      LIX   = LXX    + MINTMX
      LWRK  = LIX    + MINTMX
      LIWRK = LWRK   + L3
      LPQRJ = LIWRK  + L3/NWDVAR + 1
      LAST  = LPQRJ  + NMUL
      NEED2 = LAST - LOADFM - 1
      NEEDX = LPQRJ - LOADFM - 1
      NDBASE = NEEDV + NEEDD + NEEDX
      NTOT = NDBASE + NMUL
      IF(NINTIC.NE.0) THEN
         LXX= LBUFPIC
         LIX= LIXIC
      ENDIF
      IF(SOME) WRITE(IW,9100) NWORD,NTOT
C
C        DIRECT TRANSFORMATIONS PASS SOME MEMORY POINTERS IN COMMON
C
      IVEC = LVEC
      IFCK = LFCK
      IDEN = LDEN
      IPQKL= LPQRJ
      NBF  = L1
      NOC  = NORBS
C
C        MAKE SURE IN MEMORY NEED DOESN'T EXCEED 32 BIT INTEGER
C
      IF(NWDVAR.EQ.2  .AND.  FMUL.GT.2.14D+09) GO TO 100
      IF(NTOT.GT.NWORD) GO TO 100
      IF(MPTRAN.GT.0) GO TO 100
      IF (GOPARR) THEN
         NWORD = NTOT
         IF (SOME) WRITE(IW,9110)
         GO TO 100
      END IF
C
C     ----- FULLY IN MEMORY TRANSFORMATION -----
C
      CALL GETFM(NEED2)
      IF(SOME) WRITE(IW,9120)
      IF(EXETYP.EQ.CHECK) GO TO 700
      CALL MCXTR1DC(X(LPQRJ),X(LVEC),X(LFCK),X(LDEN),X(LXX),X(LIX),
     *              X(LJFLG),NCPU,
     *              X(LMOLAB),X(LMOIRP),X(LWRK),X(LIWRK),
     *              IJKO,IJKT,CUTTRF,NPRINT,NINT,ECORE,DOFOCK,
     *              X(LXBUF),X(LIXBUF),X(LGHND),X(LXINTS),X(LDDIJ),
     *              MAXG,NSH2,L1)
      GO TO 700
C
C     ----- SEGMENTED TRANSFORMATION, BY BATCHES OF J -----
C     ----- MEMORY REQUIRED IS (MIN)=L2*L1   (MAX)=L2*L1*NORBS
C
  100 CONTINUE
      NMIN = L2*L1
      NORBSMX = (NORBS-1)/NPROC+1
      NDMIN  = NDBASE + NMIN*1
      NDMAX  = NDBASE + NMIN*NORBSMX
      IF(SOME) WRITE(IW,9200) NDMIN,NDMAX,NMIN
C
      LEFT = NWORD-NDBASE
      IF(LEFT.LT.NMIN) THEN
        IF (GOPARR) THEN
          IF (SOME) WRITE(IW,9210) NMIN-LEFT+1
          CALL ABRT
          STOP
        ELSE
          GO TO 200
        END IF
      END IF
C
      LPASS = MIN(NORBSMX,LEFT/NMIN)
      NPASS = (NORBS-1)/LPASS+1
      LPASS = (NORBS-1)/NPASS+1
      LAST  = LPQRJ + NMIN*LPASS
      NEED2 = LAST - LOADFM - 1
      NTOT = NEED2+NEEDV+NEEDD
      IF(SOME) WRITE(IW,9220) NTOT,NPASS,LPASS,NPROC
      IF(MPTRAN.GT.1) GO TO 200
C
      IF(SOME) WRITE(IW,9230)
      CALL GETFM(NEED2)
      IF(EXETYP.EQ.CHECK) GO TO 700
C
      IF(DEBUG) CALL TR2OUT(0,0,0,0,0,ZERO,-1)
      NUMX = 0
      NREC = 0
C
      IF (GOPARR) THEN
        DLB = IBTYP.EQ.1  .AND.  ITRFAO.EQ.1  .AND.  NPASS.GE.NPROC
        IPCOUNT = ME - 1
        NEXT = -1
        MINE = -1
      END IF
C
C        ----- BEGIN LOOP OVER PASSES (SEGMENTS) -----
C        THERE ARE -NPASS- TRUE PASSES, AND -MXPASS- TOTAL PASSES,
C        WHERE -MXPASS- IS THE NEXT EVEN MULTIPLE OF -NPROC-.
C        THE PURPOSE OF THE EXTRA MXPASS-NPASS PASSES IS TO HAVE
C        THOSE NODES BROADCAST THEIR PORTION OF A DISTRIBUTED AO
C        INTEGRAL FILE TO THOSE NODES ASSIGNED A GENUINE PASS.
C
      MXPASS = ((NPASS-1+NPROC)/NPROC)*NPROC
C
      CALL TSECND(TIM1)
      MINJ = 1
      IPASS=0
      MYPASS=0
C
  110 CONTINUE
      IPASS = IPASS+1
      MAXJ = MIN(NORBS,MINJ-1+LPASS)
      NOC  = MAXJ-MINJ+1
      IF (GOPARR) THEN
        IF (DLB) THEN
          MINE = MINE + 1
          IF(MINJ.EQ.1) THEN
             IF(MASWRK) THEN
                NEXT = 0
             ELSE
                IF(MINE.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
                IF(NEXT.EQ.0) CALL DDI_DLBNEXT(NEXT)
             END IF
          ELSE
             IF(MINE.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
             IF(NEXT.EQ.0) CALL DDI_DLBNEXT(NEXT)
          END IF
          IF (NEXT.NE.MINE) THEN
             IF(IPASS.LE.NPASS  .AND.  SOME) WRITE(IW,9400) IPASS
             GO TO 115
          END IF
        ELSE
          IPCOUNT = IPCOUNT + 1
          IF (MOD(IPCOUNT,NPROC).NE.0) THEN
             IF(IPASS.LE.NPASS  .AND.  SOME) WRITE(IW,9400) IPASS
             GO TO 115
          END IF
        END IF
      END IF
C
      IF(IPASS.LE.NPASS) THEN
         CALL MCXTR2DC(X(LPQRJ),X(LVEC),X(LFCK),X(LDEN),X(LXX),X(LIX),
     *                 X(LJFLG),NCPU,
     *                 X(LFCK),X(LDEN),X(LMOLAB),X(LMOIRP),X(LWRK),
     *                 X(LIWRK),IJKO,IJKT,CUTTRF,NPRINT,ECORE,DOFOCK,
     *                 NOC,L2,MINJ,MAXJ,X(LXBUF),X(LIXBUF),NUMX,NREC,
     *                 X(LGHND),X(LXINTS),X(LDDIJ),MAXG,NSH2,MYPASS,L1)
         IF(SOME) THEN
            CALL TSECND(TIM2)
            TIME = TIM2 - TIM1
            TIM1 = TIM2
            WRITE(IW,9410) IPASS,TIME
            CALL FLSHBF(IW)
         END IF
      ELSE
         CALL FCKBRD(1,X(LFCK),X(LVEC),X(LDEN),X(LWRK),
     *               NCORBS,ECORE,DOFOCK,L1,L2,MYPASS)
         CALL TRFBRD(IJKO,X(LXX),X(LIX),NINTMX,X(LJFLG),NCPU)
         CALL FCKBRD(2,X(LFCK),X(LVEC),X(LDEN),X(LWRK),
     *               NCORBS,ECORE,DOFOCK,L1,L2,MYPASS)
      END IF
C
  115 CONTINUE
      IVEC = IVEC+NOC*L1
      MINJ=MAXJ+1
      IF(IPASS.LT.MXPASS) GO TO 110
C
      IF (DEBUG) CALL TR2OUT(0,0,0,0,0,ZERO,1)
      NINT = NREC*NINTMX+NUMX
      NREC = NREC+1
      NUMX = -NUMX
      CALL PWRIT(IJKT,X(LXBUF),X(LIXBUF),NUMX,NINTMX)
      IF (GOPARR) THEN
         CALL DDI_GSUMI(1700,NINT,1)
         IF (DLB) CALL DDI_DLBRESET
      END IF
      GO TO 700
C
C     ----- OUT-OF-MEMORY CONVENTIONAL OR DIRECT TRANSFORMATION -----
C     ----- MINUMUM MEMORY REQUIRED : L1*NORBS
C     ----- DISK REQUIRED           : L1*(L1+1)*NDAR20/2
C
  200 CONTINUE
      IF(GOPARR) THEN
         WRITE(IW,9320)
         CALL ABRT
      END IF
      NORBS2 = (NORBS*NORBS+NORBS)/2
      NDAR20 = NORBS2+NORBS*(L1-NORBS)
C
C        MOST MEMORY POINTERS ARE SAME AS FOR SEGMENTED,
C        BUT WE HAVE TO SQUEEZE IN A CHAINING ARRAY
C
      LIODA = LPQRJ
      LPQRJ = LIODA + NDAR20
C
      IPQKL = LPQRJ
C
      NMIN = L1*NORBS
      LEFT = NWORD - NEEDD - NEEDV - (LPQRJ-LOADFM-1)
      IF(LEFT.LT.NMIN) THEN
         IF (MASWRK) WRITE(IW,9310) NMIN-LEFT
         CALL ABRT
         STOP
      END IF
      LPASS = LEFT/NMIN
      NPASS = (L2-1)/LPASS+1
      LPASS = (L2-1)/NPASS+1
C
      LAST  = LPQRJ + NMIN*LPASS
      NEED2 = LAST - LOADFM - 1
      CALL GETFM(NEED2)
C
      NTOT = NEEDV+NEED2+NEEDD
      IF(SOME) WRITE(IW,9300) NPASS,NTOT
      IF (EXETYP.EQ.CHECK) GO TO 700
C
      CALL RAOPEN(IDAF20,X(LIODA),0,NDAR20,L2,NPRINT)
      MINPQ=1
  210 CONTINUE
      MAXPQ=MIN(L2,MINPQ+LPASS-1)
      NUMPQ=MAXPQ-MINPQ+1
      CALL MCXTR3DC(X(LPQRJ),X(LVEC),X(LFCK),X(LDEN),X(LXX),X(LIX),
     *              X(LFCK),X(LMOLAB),X(LWRK),
     *              IJKO,IJKT,NPRINT,ECORE,DOFOCK,
     *              NUMPQ,MINPQ,MAXPQ,IDAF20,X(LIODA),
     *              X(LGHND),X(LXINTS),X(LDDIJ),MAXG,NSH2,L1)
      MINPQ=MAXPQ+1
      IF(MINPQ.LE.L2) GO TO 210
      DEBUG=NPRINT.GE.2
      CALL TR6MC(X(LVEC),IDAF20,X(LIODA),X(LFCK),X(LDEN),
     *           X(LWRK),X(LIWRK),L1,X(LMOIRP),IJKT,L2,DEBUG,
     *           CUTTRF,NINT,X(LXBUF),X(LIXBUF))
      CALL RACLOS(IDAF20,'DELETE')
C
C     ----- ALL IS DONE -----
C
  700 CONTINUE
      CALL RETFM(NEED2)
      CALL RETFM(NEEDV)
      CALL RETFM(NEEDD)
C
      IF(.NOT.DIRTRF) CALL SEQREW(IJKO)
      CALL SEQREW(IJKT)
C
      IF(SOME) THEN
         WRITE(IW,9050) NINT
         IF(DOFOCK  .AND.  NCORBS.GT.0) WRITE(IW,9040) ECORE
         WRITE(IW,*) '... END OF INTEGRAL TRANSFORMATION ...'
         CALL TEXIT(2,2)
      END IF
C
      NT = NTSAVE
      IF(NOSYMT.EQ.1) CALL SYMON
      RETURN
C
 9000 FORMAT(/5X,44('-')/
     *        5X,'PARTIAL TWO ELECTRON INTEGRAL TRANSFORMATION'/
     *        5X,44('-'))
 9010 FORMAT(/1X,'NUMBER OF CORE MOLECULAR ORBITALS     =',I5/
     *        1X,'NUMBER OF OCCUPIED MOLECULAR ORBITALS =',I5/
     *        1X,'TOTAL NUMBER OF MOLECULAR ORBITALS    =',I5/
     *        1X,'TOTAL NUMBER OF ATOMIC ORBITALS       =',I5/
     * 1X,'THRESHOLD FOR KEEPING TRANSFORMED 2E- INTEGRALS =',1P,E10.3)
 9020 FORMAT(1X,'AO INTEGRALS WILL BE CALCULATED IN DIRECT MODE...')
 9030 FORMAT(1X,'AO INTEGRALS WILL BE READ IN FROM DISK...')
 9040 FORMAT(1X,'----- FROZEN CORE ENERGY = ',F20.10)
 9050 FORMAT(1X,'TOTAL NUMBER OF TRANSFORMED 2E- INTEGRALS KEPT =',I13)
C
 9100 FORMAT(1X,'# OF WORDS AVAILABLE = ',I13/
     *       1X,'# OF WORDS NEEDED    = ',I13,
     *          ' FOR IN MEMORY TRANSFORMATION')
 9110 FORMAT(/' PARALLEL ONLY WORKS WITH THE SEGMENTED ALGORITHM.',
     *       /' ADJUSTING MEMORY TO USE SEGMENTED ALGORITHM.'/)
 9120 FORMAT(/1X,'CHOOSING IN MEMORY PARTIAL TRANSFORMATION...')
C
 9200 FORMAT(1X,'FOR THE SEGMENTED TRANSFORMATION:'/
     *       1X,'MINIMUM=',I13,
     *           ' WORDS FOR 1 MOLECULAR ORBITAL PER PASS'/
     *       1X,'MAXIMUM=',I13,
     *           ' WORDS FOR ALL MOLECULAR ORBITALS IN 1 PASS'/
     *       8X,'(',I13,
     *           ' EXTRA WORDS WOULD INCLUDE AN EXTRA ORBITAL/PASS)')
 9210 FORMAT(/' THERE IS NOT ENOUGH MEMORY TO RUN THE TRANSFORMATION',
     *       /' IN PARALLEL.  INCREASE MEMORY BY AT LEAST',I13,' WORDS')
 9220 FORMAT(1X,'SEGMENTED PARTIAL TRANSFORMATION WILL USE',
     *          I13,' WORDS,'/
     *       1X,'DISTRIBUTING',I4,' PASSES EACH CONTAINING',I4,
     *          ' ORBITALS OVER',I4,' PROCESSORS.')
 9230 FORMAT(/1X,'CHOOSING SEGMENTED PARTIAL TRANSFORMATION...')
C
 9300 FORMAT(/' CHOOSING OUT-OF-MEMORY BIN-SORT TRANSFORMATION...'
     *       /' # PASSES     =',I5
     *       /' # WORDS USED =',I13)
 9310 FORMAT(/' NOT ENOUGH MEMORY TO TRANSFORM THE 2E-INTEGRALS'
     *       /' INCREASE MEMORY BY AT LEAST',I13,' WORDS')
 9320 FORMAT(1X,'THE BIN SORT TRANSFORMATION DOES NOT RUN IN PARALLEL')
 9400 FORMAT(1X,'ASSIGNING PASS #',I4,' TO A DIFFERENT PROCESSOR.')
 9410 FORMAT(1X,'PASS #',I4,' TOOK',F12.2,' SECONDS.')
      END
C
C*MODULE DCTRAN  *DECK MCXTR1DC
C        MODIFIED FROM MCXTR1
      SUBROUTINE MCXTR1DC(XPQRJ,C,F,D,XX,IX,JFLG,NCPU,
     *                    MOSLAB,MOSIRP,WRK,IWRK,IJK,NFT,
     *                    TOL,NPFLG,NINT,ECORE,DOFOCK,XBUF,IXBUF,
     *                    GHONDO,XINTS,DDIJ,MAXG,NSH2,NUM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL DBUG,DOFOCK
C
      COMMON /MCPAR / NFZC,NCORB,NCI,NOC,NORB,NUM1
      COMMON /INT2IC/ NINTIC,ININTIC,NXXIC,LBUFPIC,LIXIC,LABSIX,NINTIX
C
      DIMENSION XPQRJ(NOC,*),C(NUM,*),F(*),D(*),XX(*),IX(*),MOSLAB(*),
     *          MOSIRP(*),XBUF(*),IXBUF(*),
     *          GHONDO(MAXG),XINTS(NSH2),DDIJ(*),
     *          JFLG(0:NCPU-1),WRK(*),IWRK(*)
C
      NUM2 = (NUM*(NUM+1))/2
      CALL TR1MCDC(XPQRJ,F,WRK,C,C,D,XX,IX,JFLG,NCPU,
     *             NUM2,NUM,NCORB,NOC,IJK,
     *             ECORE,DOFOCK,GHONDO,XINTS,DDIJ,MAXG,NSH2)
      DBUG = NPFLG.GE.1
      IF(DOFOCK)
     *    CALL TR1E(D,F,C(1,NCORB+1),WRK,NUM,NCI,NCORB,NFT,DBUG,MOSLAB)
      DBUG = NPFLG.GE.2
C     NINTIC POINTS TO THE BUFFER FOR THE MO-BASED INTEGRALS
      CALL TR2MC(XPQRJ,C,XX(1+NINTIC),NUM,NUM2,NORB,NOC)
      CALL TR3MC(XPQRJ,C,WRK,IWRK,D,F,NUM,MOSIRP,NFT,NOC,NUM2,DBUG,
     *           TOL,NINT,XBUF,IXBUF)
      RETURN
      END
C
C*MODULE DCTRAN  *DECK MCXTR2DC
C        MODIFIED FROM MCXTR2
      SUBROUTINE MCXTR2DC(XPQRJ,C,F,D,XX,IX,JFLG,NCPU,
     *                    X,Y,MOSLAB,MOSIRP,WRK,IWRK,
     *                    IJK,NFT,TOL,NPFLG,ECORE,DOFOCK,NDIM,NUM2,
     *                    MINJ,MAXJ,XBUF,IXBUF,NUX,NREC,
     *                    GHONDO,XINTS,DDIJ,MAXG,NSH2,MYPASS,NUM)
C
C        NOTE THAT -F- AND -X- ARE EQUIVALENT BY CALL
C        NOTE THAT -D- AND -Y- ARE EQUIVALENT BY CALL
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
      LOGICAL DBUG,DOFOCK,SYM2EI
C
      PARAMETER (MXATM=2000, MXSH=5000, MXAO=8192)
C
      DIMENSION XPQRJ(NDIM,NUM2,*),C(NUM,*),F(*),D(*),XX(*),IX(*),
     *          X(NUM,*),Y(NUM,*),MOSLAB(*),MOSIRP(*),WRK(*),IWRK(*),
     *          XBUF(*), IXBUF(*),GHONDO(MAXG),XINTS(NSH2),DDIJ(*),
     *          JFLG(0:NCPU-1)
C
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /MCPAR / NFZC,NCORBS,NCI,NORBS,NORB,NUM1
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                TSYM(432),INVT(48),NT
C
C     ----- DRIVER FOR SEGMENTED INTEGRAL TRANSFORMATION -----
C
C     ----- TRANSFORM  (PQ|RS) -> (PQ|RJ)  JMIN <= J <= JMAX
C     ----- IF JMIN=1 AND NCORBS<>0 ALSO FOCK CORE OPERATOR IS COMPUTED
C
      MYPASS = MYPASS + 1
      IF(MYPASS.EQ.1) THEN
         NCORB = NCORBS
      ELSE
         NCORB = 0
      END IF
      CALL TR1MCDC(XPQRJ,F,WRK,C,C(1,MINJ),D,XX,IX,JFLG,NCPU,
     *             NUM2,NUM,NCORB,NDIM,IJK,
     *             ECORE,DOFOCK,GHONDO,XINTS,DDIJ,MAXG,NSH2)
      DBUG = NPFLG.GE.1
      IF(DOFOCK  .AND.  MYPASS.EQ.1)
     *    CALL TR1E(D,F,C(1,NCORB+1),WRK,NUM,NCI,NCORB,NFT,DBUG,MOSLAB)
      DBUG = NPFLG.GE.2
C
C     ----- TRANSFORM (PQ|RJ) TO (PQ|YJ) FOR ALL PQ,
C     ----- Y .LE. J IF Y .LE. NORBS
C     ----- Y NORBS+1 ... NORB
C
      DO 220 MPQ=1,NUM2
         DO 210 MJ=MINJ,MAXJ
            NJ=MJ-MINJ+1
            DO 200 MR=1,NUM
               X(MR,NJ) = XPQRJ(NJ,MPQ,MR)
  200       CONTINUE
            CALL DGEMV('T',NUM,MJ        ,ONE,C(1,1)      ,NUM,
     *                 X(1,NJ),1,ZERO,XPQRJ(NJ,MPQ,1)   ,NUM2*NDIM)
            CALL DGEMV('T',NUM,NORB-NORBS,ONE,C(1,NORBS+1),NUM,
     *                 X(1,NJ),1,ZERO,XPQRJ(NJ,MPQ,MJ+1),NUM2*NDIM)
  210    CONTINUE
  220 CONTINUE
C
      DO 600 MJ=MINJ,MAXJ
      NJ=MJ-MINJ+1
      NY=0
      DO 600 MY=1,NORB
      IF(MY.GT.MJ.AND.MY.LE.NORBS) GO TO 600
         NY=NY+1
         MPQ=0
         DO 310 MP=1,NUM
         DO 310 MQ=1,MP
            MPQ=MPQ+1
            X(MP,MQ) = XPQRJ(NJ,MPQ,NY)
            X(MQ,MP) = X(MP,MQ)
  310    CONTINUE
C
         IF(MY.LE.NCORBS.AND.MJ.LE.NCORBS) THEN
C
C     ----- (PQ|YJ) IS (PQ|{CORE}{CORE}); WILL BE TRANSFORMED TO
C     ----- ({VAL+VIRT}{VAL+VIRT}|{CORE}{CORE})
C
            CALL MRARBR(X,NUM,NUM,NUM,C(1,NCORBS+1),
     *                  NUM,NORB-NCORBS,Y,NUM)
            M1 = IA(NCORBS+1)+1
            MPQ = 0
            DO 340 MA=1,NORB-NCORBS
               DO 320 MX=1,NCORBS
                  WRK(MPQ+MX) = ZERO
  320          CONTINUE
               MPQ = MPQ+NCORBS
               IF(NT.EQ.1) THEN
                  CALL DGEMV('T',NUM,MA,ONE,C(1,1+NCORBS),NUM,
     *                       Y(1,MA),1,ZERO,WRK(MPQ+1),1)
                  MPQ = MPQ+MA
               ELSE
                  DO 330 MX=1,MA
                     MPQ=MPQ+1
                     IF(SYM2EI(MOSIRP(MA+NCORBS),MOSIRP(MX+NCORBS),
     *                         MOSIRP(MY),MOSIRP(MJ))) THEN
                        DUM = DDOT(NUM,Y(1,MA),1,C(1,MX+NCORBS),1)
                     ELSE
                        DUM = ZERO
                     END IF
                     WRK(MPQ) = DUM
  330             CONTINUE
               END IF
  340       CONTINUE
C
         ELSE IF(MY.LE.NORBS) THEN
C
C     ----- (PQ|YJ) IS (PQ|{VAL}{CORE+VAL}); WILL BE TRANSFORMED TO
C     ----- ({VAL+VIRT}{ALL}|{VAL}{CORE+VAL})
C
            CALL MRARBR(X,NUM,NUM,NUM,C(1,MJ),NUM,NORB-MJ+1,Y,NUM)
            M1 = IA(MJ)+1
            MPQ = 0
            DO 430 MA=MJ,NORB
               DO 420 MX=1,MA
                  MPQ = MPQ+1
                  IF(MA.EQ.MJ .AND. MX.LT.MY) THEN
                     DUM = ZERO
                  ELSE IF(SYM2EI(MOSIRP(MA),MOSIRP(MX),MOSIRP(MY),
     *                    MOSIRP(MJ))) THEN
                     DUM = DDOT(NUM,Y(1,MA-MJ+1),1,C(1,MX),1)
                  ELSE
                     DUM = ZERO
                  END IF
                  WRK(MPQ) = DUM
  420          CONTINUE
  430       CONTINUE
C
         ELSE
C
C     ----- (PQ|YJ) IS (PQ|{VIRT}{CORE+VAL}); WILL BE TRANSFORMED TO
C     ----- ({VIRT}{CORE+VAL}|{VIRT}{CORE+VAL})
C
            CALL MRARBR(X,NUM,NUM,NUM,C(1,MY),
     *                  NUM,NORB-MY+1,Y,NUM)
            M1 = IA(MY)+1
            MPQ = 0
            DO 540 MA=MY,NORB
               DO 520 MX=1,NORBS
                  MPQ = MPQ+1
                  IF(MA.EQ.MY .AND. MX.LT.MJ) THEN
                     DUM = ZERO
                  ELSE IF(SYM2EI(MOSIRP(MA),MOSIRP(MX),MOSIRP(MY),
     *                    MOSIRP(MJ))) THEN
                     DUM = DDOT(NUM,Y(1,MA-MY+1),1,C(1,MX),1)
                  ELSE
                     DUM = ZERO
                  END IF
                  WRK(MPQ) = DUM
  520          CONTINUE
               DO 530 MX=NORBS+1,MA
                  MPQ=MPQ+1
                  WRK(MPQ) = ZERO
  530          CONTINUE
  540       CONTINUE
C
         END IF
C
         MYTEMP = MY
         MJTEMP = MJ
         IF (MY.GE.MJ) THEN
            CALL TRFWT(NFT,WRK,NUX,IWRK,XBUF,MPQ,M1,TOL,NREC,DBUG,
     *                 MYTEMP,MJTEMP,IXBUF)
         ELSE
            CALL TRFWT(NFT,WRK,NUX,IWRK,XBUF,MPQ,M1,TOL,NREC,DBUG,
     *                 MJTEMP,MYTEMP,IXBUF)
         END IF
C
  600 CONTINUE
      RETURN
      END
C
C*MODULE DCTRAN  *DECK MCXTR3DC
C        MODIFIED FROM MCXTR3
      SUBROUTINE MCXTR3DC(XPQRJ,C,F,D,XX,IX,
     *                    X,MOSLAB,WRK,IJK,NFT,
     *                    NPFLG,ECORE,DOFOCK,NDIM,MINPQ,MAXPQ,
     *                    IDAF20,IODA20,GHONDO,XINTS,DDIJ,MAXG,NSH2,NUM)
C
C           NOTE THAT -F- AND -X- ARE EQUIVALENT BY CALL
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION XPQRJ(NORBS,NDIM,*),D(*),F(*),C(NUM,*),XX(*),IX(*),
     *          X(NUM,*),IODA20(*),GHONDO(MAXG),XINTS(NSH2),DDIJ(*),
     *          WRK(*)
C
      LOGICAL DBUG,DOFOCK
C
      COMMON /MCPAR / NFZC,NCORBS,NCI,NORBS,NORB,NUM1
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
      NUM2 = (NUM*(NUM+1))/2
      IF(MINPQ.EQ.1) THEN
         NCORB=NCORBS
      ELSE
         NCORB=0
      END IF
      CALL TR5MCDC(XPQRJ,F,WRK,C,C,D,XX,IX,
     *             NDIM,NUM,NCORB,NORBS,MINPQ,MAXPQ,
     *             IJK,DOFOCK,ECORE,GHONDO,XINTS,DDIJ,MAXG,NSH2)
      DBUG=NPFLG.GE.1
      IF(DOFOCK  .AND.  MINPQ.EQ.1)
     *    CALL TR1E(D,F,C(1,NCORB+1),WRK,NUM,NCI,NCORB,NFT,DBUG,MOSLAB)
C
C     ----- (PQ|YJ) = SUM OVER S OF (PQ|RJ)*C(R,Y)      -----
C     ----- FOR Y = 1...NORB; MINPQ .LE. PQ .LE. MAXPQ  -----
C
      DO 170 MPQ=1,NDIM
         DO 160 MJ=1,NORBS
         DO 160 MR=1,NUM
            X(MR,MJ) = XPQRJ(MJ,MPQ,MR)
  160    CONTINUE
C
         DO 170 MY=1,NORB
            CALL DGEMV('T',NUM,MIN(MY,NORBS),ONE,X(1,1),
     *                 NUM,C(1,MY),1,ZERO,XPQRJ(1,MPQ,MY),1)
  170    CONTINUE
C
C     ----- SAVE IN DAFILE -----
C
      MYJ=0
      DO 200 MY=1,NORB
      DO 200 MJ=1,MIN(MY,NORBS)
         MYJ=MYJ+1
         IF(MINPQ.EQ.1) THEN
            CALL VCLR(WRK,1,NUM2)
         ELSE
            CALL RAREAD(IDAF20,IODA20,WRK,NUM2,MYJ,0)
         END IF
         DO 190 MPQ=1,NDIM
            WRK(MPQ+MINPQ-1)=XPQRJ(MJ,MPQ,MY)
  190    CONTINUE
         CALL RAWRIT(IDAF20,IODA20,WRK,NUM2,MYJ,0)
  200 CONTINUE
      RETURN
      END
C
C*MODULE DCTRAN  *DECK TR1MCDC
C        MODIFIED FROM TR1MC
      SUBROUTINE TR1MCDC(XPQRJ,F,WRK,C,CO,D,XX,IX,JFLG,NCPU,
     *                   NDIM,NUM,NCORB,NOC,IJK,
     *                   ECORE,DOFOCK,GHONDO,XINTS,DDIJ,MAXG,NSH2)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXAO=8192)
C
      LOGICAL PACK2E,GOPARR,DSKWRK,MASWRK,DOFOCK,DIRTRF
C
      DIMENSION XPQRJ(NOC,NDIM,*),F(*),C(NUM,*),CO(NUM,*),D(*),WRK(*),
     *          XX(*),IX(*),JFLG(0:NCPU-1),
     *          GHONDO(MAXG),XINTS(NSH2),DDIJ(*)
C
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /DIRCAS/ I2CASE
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /TRFOPT/ CUTTRF,NWDTRF,MPTRAN,ITRFAO,NOSYMT,IPURTF,DIRTRF
      COMMON /INT2IC/ NINTIC,ININTIC,NXXIC,LBUFPIC,LIXIC,LABSIX,NINTIX
C
      PARAMETER (ZERO=0.0D+00, PT5=0.5D+00)
C
C     ----- PARAMETERS:
C           XPQRJ       ON EXIT ONE-INDEX TRANSFORMED INTEGRALS
C           F           ON EXIT FOCK CORE OPERATOR
C           D           CORE DENSITY MATRIX
C           XX,IX       2E-INTEGRALS BUFFERS
C           C           ON ENTRY CORE ORBITALS
C           CO          ON ENTRY ORBITALS TO TRANSFORM THE 2E-INTEGRALS
C
      NUM2 = (NUM*NUM+NUM)/2
      CALL VCLR(XPQRJ,1,NDIM*NUM*NOC)
C
C     ----- GET 1E-CONTRIBUTION TO FROZEN CORE ENERGY -----
C
      IF(DOFOCK  .AND.  NCORB.GT.0) THEN
C        --- NOT IMPLEMENTED ---
         CALL ABRT
C        -----------------------
         ECORE = ZERO
         CALL GETDEN(D,C,NUM,NCORB)
         CALL DAREAD(IDAF,IODA,F,NUM2,11,0)
         ECORE = TRACEP(D,F,NUM)
         CALL VCLR(F,1,NUM2)
      END IF
C
C     ----- PROCESS 2E-INTEGRALS -----
C
      IF(.NOT.DIRTRF) THEN
C
         DO 100 KAP=0,NPROC-1
            JFLG(KAP)=1
  100    CONTINUE
         KAP = -1
         IFLG=  1
C
         CALL SEQREW(IJK)
C     FIRST, PROCESS IN CORE INTEGRALS
      NPACKIC=0
  200    CONTINUE
C
C              READ NEXT INTEGRAL RECORD FROM A DUPLICATED OR
C              DISTRIBUTED AO INTEGRAL FILE
C
      IF(NPACKIC.EQ.0.AND.NINTIC.NE.0) THEN
        NXX=NXXIC
        NINT=NXX
      ELSE
C       IF ALL IN CORE BAIL OUT
        IF(NINTIC.NE.0.AND.NXXIC.LT.NINTIC) GO TO 700
         IF(ITRFAO.EQ.1) THEN
            CALL PREAD(IJK,XX(NINTIC+1),IX(ININTIC+1),NXX,NINTMX)
         ELSE
            CALL PREADP(IJK,XX(NINTIC+1),IX(ININTIC+1),NXX,NINTMX,
     *                  KAP,IFLG,JFLG,NPROC)
            IF(IFLG.EQ.0) THEN
               CALL SEQREW(IJK)
               GO TO 700
            END IF
         END IF
C
         IF(NXX.EQ.0) GO TO 250
         NINT=ABS(NXX)
         IF(NINT.GT.NINTMX) CALL ABRT
      ENDIF
C
C                PERFORM FIRST INDEX TRANSFORMATION
C
         IF(DOFOCK  .AND.  NCORB.GT.0  .AND.  MASWRK) THEN
C           --- NOT IMPLEMENTED ---
            CALL ABRT
C           -----------------------
            CALL ONETFF(XPQRJ,CO,F,D,NDIM,NUM,NOC,XX,IX,NXX,NPACKIC)
         ELSE
            DUMMY=ZERO
            CALL ONETFD(XPQRJ,DUMMY,CO,NDIM,NUM,NOC,XX,IX,NXX,NPACKIC,1)
         END IF
C
  250    CONTINUE
         IF(NPACKIC.EQ.0) NPACKIC=NINTIC
         IF(ITRFAO.EQ.1  .AND.  NXX.LE.0) THEN
            CALL SEQREW(IJK)
            GO TO 700
         END IF
         GO TO 200
      END IF
C
C     ----- DIRECT CASSCF -----
C
      IF(DIRTRF) THEN
         IF(DOFOCK  .AND.  NCORB.GT.0  .AND.  MASWRK) THEN
            I2CASE=1
         ELSE
            I2CASE=3
         END IF
         CALL DIRJKDC(GHONDO,XINTS,DDIJ,XX,IX,MAXG,NSH2)
      END IF
C
C     ----- POST-PROCESSING OF FOCK MATRIX -----
C     ----- 2E-CONTRIBUTION TO FROZEN CORE ENERGY -----
C
  700 CONTINUE
      IF(DOFOCK  .AND.  NCORB.GT.0) THEN
         IF(GOPARR) CALL DDI_BCAST(1720,'F',F,NUM2,MASTER)
         CALL DSCAL(NUM2,PT5,F,1)
         II = 0
         DO 750 I=1,NUM
            II = II+I
            F(II) = F(II)+F(II)
  750    CONTINUE
         CALL SYMH(F,WRK,IA)
         ECORE = ECORE+TRACEP(D,F,NUM)
         ECORE = ECORE+ECORE
      END IF
      RETURN
C
      END
C
C*MODULE TRANS   *DECK TR5MCDC
C        MODIFIED FROM TR5MC
      SUBROUTINE TR5MCDC(XPQRJ,F,WRK,C,CO,D,XX,IX,
     *                   NDIM,NUM,NCORB,NOC,
     *                   MINPQ,MAXPQ,IJK,DOFOCK,ECORE,
     *                   GHONDO,XINTS,DDIJ,MAXG,NSH2)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXAO=8192)
C
      DIMENSION XPQRJ(NOC,NDIM,*),F(*),C(NUM,*),CO(NUM,*),D(*),
     *          XX(*),IX(*),GHONDO(MAXG),XINTS(NSH2),DDIJ(*),WRK(*)
C
      LOGICAL PACK2E,DOFOCK,DIRTRF
C
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /IOFILE/ IR,IW,IP,IJ,IPK,IDAF,NAV,IODA(950)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /DIRMEM/ IDUM(6),MDIM,MNPQ,MXPQ
      COMMON /DIRCAS/ I2CASE
      COMMON /TRFOPT/ CUTTRF,NWDTRF,MPTRAN,ITRFAO,NOSYMT,IPURTF,DIRTRF
      COMMON /INT2IC/ NINTIC,ININTIC,NXXIC,LBUFPIC,LIXIC,LABSIX,NINTIX
C
      PARAMETER (ZERO=0.0D+00,PT5=0.5D+00)
C
      NUM2 = (NUM*NUM+NUM)/2
C
C     ----- GET 1E-CONTRIBUTION TO FROZEN CORE -----
C
      IF(DOFOCK  .AND.  NCORB.NE.0) THEN
C        --- NOT IMPLEMENTED ---
         CALL ABRT
C        -----------------------
C
         ECORE=ZERO
         CALL GETDEN(D,C,NUM,NCORB)
         CALL DAREAD(IDAF,IODA,F,NUM2,11,0)
         ECORE = TRACEP(D,F,NUM)
         CALL VCLR(F,1,NUM2)
      END IF
C
      CALL VCLR(XPQRJ,1,NUM*NOC*NDIM)
C
C     ----- PROCESS 2E-INTEGRALS -----
C
      IF(.NOT.DIRTRF) THEN
C
         CALL SEQREW(IJK)
C     FIRST, PROCESS IN CORE INTEGRALS
      NPACKIC=0
  200    CONTINUE
C
C              READ AO INTEGRAL LIST
C
      IF(NPACKIC.EQ.0.AND.NINTIC.NE.0) THEN
        NXX=NXXIC
        NINT=NXX
      ELSE
C       IF ALL IN CORE BAIL OUT
        IF(NINTIC.NE.0.AND.NXXIC.LT.NINTIC) GO TO 700
         CALL PREAD(IJK,XX(NINTIC+1),IX(ININTIC+1),NXX,NINTMX)
         IF(NXX.EQ.0) GO TO 250
         NINT=ABS(NXX)
         IF(NINT.GT.NINTMX) CALL ABRT
      ENDIF
C
C              CARRY OUT FIRST INDEX TRANSFORMATION
C
         IF(DOFOCK  .AND.  NCORB.NE.0  .AND.  MINPQ.EQ.1) THEN
C           --- NOT IMPLEMENTED ---
            CALL ABRT
C           -----------------------
C
            CALL ONEPFF(XPQRJ,CO,F,D,NDIM,MINPQ,MAXPQ,
     *                  NUM,NOC,XX,IX,NXX,NPACKIC)
         ELSE
            CALL ONEPRFDC(XPQRJ,CO,NDIM,MINPQ,MAXPQ,
     *                  NUM,NOC,XX,IX,NXX,NPACKIC)
         END IF
C
  250    CONTINUE
         IF(NPACKIC.EQ.0) NPACKIC=NINTIC
         IF(NXX.LE.0) THEN
            CALL SEQREW(IJK)
            GO TO 700
         END IF
         GO TO 200
      END IF
C
C     ----- 2E- INTEGRALS FROM DIRECT COMPUTATION  -----
C
      IF(DIRTRF) THEN
         IF(NCORB.NE.0) THEN
            I2CASE=4
         ELSE
            I2CASE=5
         END IF
         MDIM=NDIM
         MNPQ=MINPQ
         MXPQ=MAXPQ
         CALL DIRJKDC(GHONDO,XINTS,DDIJ,XX,IX,MAXG,NSH2)
      END IF
C
C     ----- POST-PROCESSING OF FOCK MATRIX -----
C     ----- 2E-CONTRIBUTION TO FROZEN CORE ENERGY -----
C
  700 CONTINUE
      IF(DOFOCK  .AND.  NCORB.NE.0  .AND.  MINPQ.EQ.1) THEN
         CALL DSCAL(NUM2,PT5,F,1)
         II = 0
         DO 750 I=1,NUM
            II = II+I
            F(II) = F(II)+F(II)
  750    CONTINUE
         CALL SYMH(F,WRK,IA)
         ECORE = ECORE+TRACEP(D,F,NUM)
         ECORE = ECORE+ECORE
      END IF
      RETURN
C
      END
C
C*MODULE DCTRAN  *DECK ONEPRFDC
C        MODIFIED FROM ONEPRF
      SUBROUTINE ONEPRFDC(XPQRJ,CO,NDIM,MINPQ,MAXPQ,NUM,NOC,XX,IX,NXX,
     *                    NPACKIC)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXAO=8192)
C
      DIMENSION XPQRJ(NOC,NDIM,*),CO(NUM,*),XX(*),IX(*)
C
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /PCKLAB/ LABSIZ
C
      COMMON /TO2LC / IT2LOC(MXAO)
C
      NINT = ABS(NXX)
C
      IF(LABSIZ.GE.2) THEN
C
C     ----- TWO BYTES PER LABEL -----
C
         DO 20 M=1,NINT
                       NPACK = NPACKIC+M
            VAL1 = XX(NPACK)
            VAL3 = VAL1
C
*I32                     LABEL = IX( 2*NPACK - 1 )
*I32                     IPACK = ISHFT( LABEL, -16 )
*I32                     JPACK = IAND(  LABEL, 65535 )
*I32                     LABEL = IX( 2*NPACK     )
*I32                     KPACK = ISHFT( LABEL, -16 )
*I32                     LPACK = IAND(  LABEL, 65535 )
*I64                     LABEL = IX(NPACK)
*I64                     IPACK = ISHFT( LABEL, -48 )
*I64                     JPACK = IAND( ISHFT( LABEL, -32 ), 65535 )
*I64                     KPACK = IAND( ISHFT( LABEL, -16 ), 65535 )
*I64                     LPACK = IAND( LABEL, 65535 )
                       MPT = IPACK
                       MQT = JPACK
                       MRT = KPACK
                       MST = LPACK
C
            MP=IT2LOC(MPT)
            MQ=IT2LOC(MQT)
            MR=IT2LOC(MRT)
            MS=IT2LOC(MST)
            ITEST=MP*MQ*MR*MS
            IF(ITEST.EQ.0) GO TO 20
C
            IF(MP.LT.MQ) THEN
               ITP=MP
               MP=MQ
               MQ=ITP
            END IF
            IF(MR.LT.MS) THEN
               ITP=MR
               MR=MS
               MS=ITP
            END IF
            IF(MP.LT.MR .OR. (MP.EQ.MR .AND. MQ.LT.MS)) THEN
               ITP=MP
               MP=MR
               MR=ITP
               ITP=MQ
               MQ=MS
               MS=ITP
            END IF
C
            MPQ= IA(MP)+MQ
            MRS= IA(MR)+MS
            IF(MP.EQ.MQ) VAL1 = VAL1+VAL1
            IF(MR.EQ.MS) VAL3 = VAL3+VAL3
            IF(MPQ.GE.MINPQ.AND.MPQ.LE.MAXPQ) THEN
            MPQ=MPQ-MINPQ+1
            DO 10 MJ=1,NOC
               XPQRJ(MJ,MPQ,MR) = XPQRJ(MJ,MPQ,MR) + VAL1*CO(MS,MJ)
               XPQRJ(MJ,MPQ,MS) = XPQRJ(MJ,MPQ,MS) + VAL1*CO(MR,MJ)
   10       CONTINUE
            END IF
            IF(MRS.GE.MINPQ.AND.MRS.LE.MAXPQ) THEN
            MRS=MRS-MINPQ+1
            DO 15 MJ=1,NOC
               XPQRJ(MJ,MRS,MP) = XPQRJ(MJ,MRS,MP) + VAL3*CO(MQ,MJ)
               XPQRJ(MJ,MRS,MQ) = XPQRJ(MJ,MRS,MQ) + VAL3*CO(MP,MJ)
   15       CONTINUE
            END IF
   20    CONTINUE
C
      ELSE
C
C     ----- ONE BYTE PER LABEL -----
C
         DO 40 M=1,NINT
                       NPACK = NPACKIC+M
            VAL1 = XX(NPACK)
            VAL3 = VAL1
C
*I32                     LABEL = IX(NPACK)
*I32                     IPACK = ISHFT( LABEL, -24 )
*I32                     JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
*I32                     KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
*I32                     LPACK = IAND( LABEL, 255 )
*I64                     IF ( MOD(NPACK,2) .EQ. 0 ) THEN
*I64                       LABEL = IX( NPACK/2 )
*I64                       IPACK = IAND( ISHFT( LABEL, -24 ), 255 )
*I64                       JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
*I64                       KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
*I64                       LPACK = IAND( LABEL, 255 )
*I64                     ELSE
*I64                       LABEL = IX( (NPACK/2)+1 )
*I64                       IPACK = ISHFT( LABEL, -56 )
*I64                       JPACK = IAND( ISHFT( LABEL, -48 ), 255 )
*I64                       KPACK = IAND( ISHFT( LABEL, -40 ), 255 )
*I64                       LPACK = IAND( ISHFT( LABEL, -32 ), 255 )
*I64                     END IF
                       MPT = IPACK
                       MQT = JPACK
                       MRT = KPACK
                       MST = LPACK
C
            MP=IT2LOC(MPT)
            MQ=IT2LOC(MQT)
            MR=IT2LOC(MRT)
            MS=IT2LOC(MST)
            ITEST=MP*MQ*MR*MS
            IF(ITEST.EQ.0) GO TO 40
C
            IF(MP.LT.MQ) THEN
               ITP=MP
               MP=MQ
               MQ=ITP
            END IF
            IF(MR.LT.MS) THEN
               ITP=MR
               MR=MS
               MS=ITP
            END IF
            IF(MP.LT.MR .OR. (MP.EQ.MR .AND. MQ.LT.MS)) THEN
               ITP=MP
               MP=MR
               MR=ITP
               ITP=MQ
               MQ=MS
               MS=ITP
            END IF
C
            MPQ= IA(MP)+MQ
            MRS= IA(MR)+MS
            IF(MP.EQ.MQ) VAL1 = VAL1+VAL1
            IF(MR.EQ.MS) VAL3 = VAL3+VAL3
            IF(MPQ.GE.MINPQ.AND.MPQ.LE.MAXPQ) THEN
            MPQ=MPQ-MINPQ+1
            DO 30 MJ=1,NOC
               XPQRJ(MJ,MPQ,MR) = XPQRJ(MJ,MPQ,MR) + VAL1*CO(MS,MJ)
               XPQRJ(MJ,MPQ,MS) = XPQRJ(MJ,MPQ,MS) + VAL1*CO(MR,MJ)
   30       CONTINUE
            END IF
            IF(MRS.GE.MINPQ.AND.MRS.LE.MAXPQ) THEN
            MRS=MRS-MINPQ+1
            DO 35 MJ=1,NOC
               XPQRJ(MJ,MRS,MP) = XPQRJ(MJ,MRS,MP) + VAL3*CO(MQ,MJ)
               XPQRJ(MJ,MRS,MQ) = XPQRJ(MJ,MRS,MQ) + VAL3*CO(MP,MJ)
   35       CONTINUE
            END IF
   40    CONTINUE
C
      END IF
      RETURN
C
      END
C
C*MODULE DCTRAN  *DECK ONETFD
C        MODIFIED FROM ONETRF
      SUBROUTINE ONETFD(XPQRJ,XPQRJI,CO,NDIM,NUM,NOC,XX,IX,NXX,NPACKIC,
     *                  IDCMOD)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXAO=8192, MXLATM=200, MXLSHL=700)
C
      DIMENSION XPQRJ(NOC,NDIM,*),XPQRJI(NOC,NDIM,*),CO(NUM,*),
     *          XX(*),IX(*)
C
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /PCKLAB/ LABSIZ
C
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
      COMMON /TO2LC / IT2LOC(MXAO)
C
      NINT = ABS(NXX)
C
      IF(LABSIZ.GE.2) THEN
C
C     ----- TWO BYTES PER LABEL -----
C
         DO 20 M=1,NINT
                       NPACK = NPACKIC+M
            VAL1 = XX(NPACK)
            VAL3 = VAL1
C
*I32                     LABEL = IX( 2*NPACK - 1 )
*I32                     IPACK = ISHFT( LABEL, -16 )
*I32                     JPACK = IAND(  LABEL, 65535 )
*I32                     LABEL = IX( 2*NPACK     )
*I32                     KPACK = ISHFT( LABEL, -16 )
*I32                     LPACK = IAND(  LABEL, 65535 )
*I64                     LABEL = IX(NPACK)
*I64                     IPACK = ISHFT( LABEL, -48 )
*I64                     JPACK = IAND( ISHFT( LABEL, -32 ), 65535 )
*I64                     KPACK = IAND( ISHFT( LABEL, -16 ), 65535 )
*I64                     LPACK = IAND( LABEL, 65535 )
                       MPT = IPACK
                       MQT = JPACK
                       MRT = KPACK
                       MST = LPACK
C
            MP=IT2LOC(MPT)
            MQ=IT2LOC(MQT)
            MR=IT2LOC(MRT)
            MS=IT2LOC(MST)
            ITEST=MP*MQ*MR*MS
            IF(ITEST.EQ.0) GO TO 20
C
            IF(MP.LT.MQ) THEN
               ITP=MP
               MP=MQ
               MQ=ITP
            END IF
            IF(MR.LT.MS) THEN
               ITP=MR
               MR=MS
               MS=ITP
            END IF
            IF(MP.LT.MR .OR. (MP.EQ.MR .AND. MQ.LT.MS)) THEN
               ITP=MP
               MP=MR
               MR=ITP
               ITP=MQ
               MQ=MS
               MS=ITP
            END IF
C
            MPQ= IA(MP)+MQ
            MRS= IA(MR)+MS
            IF(MP.EQ.MQ) VAL1 = VAL1+VAL1
            IF(MR.EQ.MS) VAL3 = VAL3+VAL3
            DO 10 MJ=1,NOC
               VAL1S=VAL1*CO(MS,MJ)
               VAL1R=VAL1*CO(MR,MJ)
               VAL3Q=VAL3*CO(MQ,MJ)
               VAL3P=VAL3*CO(MP,MJ)
               IF(IDCMOD.GE.2) THEN
                  IF(MS.LE.LNUMC) XPQRJI(MJ,MPQ,MR) = XPQRJI(MJ,MPQ,MR)
     *                                              + VAL1S
                  IF(MR.LE.LNUMC) XPQRJI(MJ,MPQ,MS) = XPQRJI(MJ,MPQ,MS) 
     *                                              + VAL1R
                  IF(MQ.LE.LNUMC) XPQRJI(MJ,MRS,MP) = XPQRJI(MJ,MRS,MP)
     *                                              + VAL3Q
                  IF(MP.LE.LNUMC) XPQRJI(MJ,MRS,MQ) = XPQRJI(MJ,MRS,MQ)
     *                                              + VAL3P
               ENDIF
               IF(IDCMOD.EQ.1 .OR. IDCMOD.EQ.3) THEN
                  XPQRJ(MJ,MPQ,MR) = XPQRJ(MJ,MPQ,MR) + VAL1S
                  XPQRJ(MJ,MPQ,MS) = XPQRJ(MJ,MPQ,MS) + VAL1R
                  XPQRJ(MJ,MRS,MP) = XPQRJ(MJ,MRS,MP) + VAL3Q
                  XPQRJ(MJ,MRS,MQ) = XPQRJ(MJ,MRS,MQ) + VAL3P
               ENDIF
   10       CONTINUE
C
   20    CONTINUE
C
      ELSE
C
C     ----- ONE BYTE PER LABEL -----
C
*VDIR NODIVLOOP
         DO 40 M=1,NINT
                       NPACK = NPACKIC+M
            VAL1 = XX(NPACK)
            VAL3 = VAL1
C
*I32                     LABEL = IX(NPACK)
*I32                     IPACK = ISHFT( LABEL, -24 )
*I32                     JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
*I32                     KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
*I32                     LPACK = IAND( LABEL, 255 )
*I64                     IF ( MOD(NPACK,2) .EQ. 0 ) THEN
*I64                       LABEL = IX( NPACK/2 )
*I64                       IPACK = IAND( ISHFT( LABEL, -24 ), 255 )
*I64                       JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
*I64                       KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
*I64                       LPACK = IAND( LABEL, 255 )
*I64                     ELSE
*I64                       LABEL = IX( (NPACK/2)+1 )
*I64                       IPACK = ISHFT( LABEL, -56 )
*I64                       JPACK = IAND( ISHFT( LABEL, -48 ), 255 )
*I64                       KPACK = IAND( ISHFT( LABEL, -40 ), 255 )
*I64                       LPACK = IAND( ISHFT( LABEL, -32 ), 255 )
*I64                     END IF
                       MPT = IPACK
                       MQT = JPACK
                       MRT = KPACK
                       MST = LPACK
C
            MP=IT2LOC(MPT)
            MQ=IT2LOC(MQT)
            MR=IT2LOC(MRT)
            MS=IT2LOC(MST)
            ITEST=MP*MQ*MR*MS
            IF(ITEST.EQ.0) GO TO 40
C
            IF(MP.LT.MQ) THEN
               ITP=MP
               MP=MQ
               MQ=ITP
            END IF
            IF(MR.LT.MS) THEN
               ITP=MR
               MR=MS
               MS=ITP
            END IF
            IF(MP.LT.MR .OR. (MP.EQ.MR .AND. MQ.LT.MS)) THEN
               ITP=MP
               MP=MR
               MR=ITP
               ITP=MQ
               MQ=MS
               MS=ITP
            END IF
C
            MPQ= IA(MP)+MQ
            MRS= IA(MR)+MS
            IF(MP.EQ.MQ) VAL1 = VAL1+VAL1
            IF(MR.EQ.MS) VAL3 = VAL3+VAL3
            DO 30 MJ=1,NOC
               VAL1S=VAL1*CO(MS,MJ)
               VAL1R=VAL1*CO(MR,MJ)
               VAL3Q=VAL3*CO(MQ,MJ)
               VAL3P=VAL3*CO(MP,MJ)
               IF(IDCMOD.GE.2)THEN
                  IF(MS.LE.LNUMC) XPQRJI(MJ,MPQ,MR) = XPQRJI(MJ,MPQ,MR)
     *                                              + VAL1S
                  IF(MR.LE.LNUMC) XPQRJI(MJ,MPQ,MS) = XPQRJI(MJ,MPQ,MS) 
     *                                              + VAL1R
                  IF(MQ.LE.LNUMC) XPQRJI(MJ,MRS,MP) = XPQRJI(MJ,MRS,MP)
     *                                              + VAL3Q
                  IF(MP.LE.LNUMC) XPQRJI(MJ,MRS,MQ) = XPQRJI(MJ,MRS,MQ)
     *                                              + VAL3P
               ENDIF
               IF(IDCMOD.EQ.1 .OR. IDCMOD.EQ.3)THEN
                  XPQRJ(MJ,MPQ,MR) = XPQRJ(MJ,MPQ,MR) + VAL1S
                  XPQRJ(MJ,MPQ,MS) = XPQRJ(MJ,MPQ,MS) + VAL1R
                  XPQRJ(MJ,MRS,MP) = XPQRJ(MJ,MRS,MP) + VAL3Q
                  XPQRJ(MJ,MRS,MQ) = XPQRJ(MJ,MRS,MQ) + VAL3P
               ENDIF
   30       CONTINUE
C
   40    CONTINUE
C
      END IF
C
      RETURN
      END
C
