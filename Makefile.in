#BASH allows the pipeline to return a fail if any command fails
#Since the $(COMP) command below outputs "module.f" in warnings and errors
#replacing this string with the path to the real source file will make special
#features of VIM and EMACS work.
SHELL=bash -o pipefail

#All MODULES will be added by config

#These objects are not always necessary but it may be a good idea to compile them anyway
#LINK will determine if they are necessary
AUX = blaswrap vector blas

COMP       = $(GMS_PATH)/comp
COMPALL    = $(GMS_PATH)/compall
LINK       = $(GMS_PATH)/lked
OBJ_DIR    = $(GMS_BUILD_PATH)/object
OBJ        = $(patsubst %,$(OBJ_DIR)/%.o,$(MODULES))
LIS        = $(patsubst %,$(OBJ_DIR)/%.lis,$(MODULES))
ACT        = $(patsubst %,$(OBJ_DIR)/%.f,$(MODULES))
OBJ_AUX    = $(patsubst %,$(OBJ_DIR)/%.o,$(AUX))
SRC_DIR    = $(GMS_PATH)/source
DDI_DIR    = $(GMS_BUILD_PATH)/ddi
DDI_LIB    = $(DDI_DIR)/libddi.a
DDIKICK    = $(GMS_BUILD_PATH)/ddikick.x
DDITEST    = $(GMS_BUILD_PATH)/ddi_test.x
DATASERVER = $(GMS_BUILD_PATH)/data_server.x
ACTVTE     = $(GMS_BUILD_PATH)/tools/actvte.x
EXE        = gamess
GAMESS     = $(GMS_BUILD_PATH)/$(EXE).$(GMS_VERSION).x
CTAGS      = ctagsf
FTNCHEK    = ftnchek
FTNCHEK_OPT= -noextern -common=2 -arguments=1 -array=0 -calltree=0 -nocrossref -portability=tab -f77=automatic-array,relops,cycle-exit,case-construct -nonovice
FTNCHEK_OPT2= -noextern -common=2 -arguments=1 -array=0 -calltree=0 -nocrossref -resources=yes -f77=automatic-array,relops -portability=tab -nonovice

SEDSRC     = 's%\([a-z0-9]*\)\.f%$(SRC_DIR)\/\1\.src%'
SEDSRC2    = 's%$(OBJ_DIR)/\([a-z0-9]*\)\.f%$(SRC_DIR)/\1\.src%'

#GAMESS executable
gamess : $(GAMESS)
$(GAMESS) : $(DDI_LIB) $(OBJ) $(OBJ_AUX) $(OBJ_DIR)/zunix.o
	@$(LINK) $(EXE) $(GMS_VERSION) >/dev/null

#Compile any module (I can't quite do "make $(module)" yet)
$(OBJ_DIR)/%.o :$(ACTVTE) $(SRC_DIR)/%.src 
	@if [ -e $(OBJ_DIR)/$(notdir $(basename $@)).f ]; then rm $(OBJ_DIR)/$(notdir $(basename $@)).f;fi
	@$(COMP) $(notdir $(basename $@)) 2>&1 1>/dev/null | sed -e $(SEDSRC)
modules : $(OBJ)

#I like to keep the activated source in the OBJ_DIR for use with FTNCHEK
$(OBJ_DIR)/%.f :$(ACTVTE) $(SRC_DIR)/%.src
	@if [ -e $(OBJ_DIR)/$(notdir $(basename $@)).f ]; then rm $(OBJ_DIR)/$(notdir $(basename $@)).f;fi
	@$(COMP) $(notdir $(basename $@)) true
$(OBJ_DIR)/%.lis :$(ACTVTE) $(SRC_DIR)/%.src $(OBJ_DIR)/%.f
	$(FTNCHEK) $(FTNCHEK_OPT) $(OBJ_DIR)/$(notdir $(basename $@)).f 2>&1 | sed -e $(SEDSRC2) > $@
$(ACTVTE) :
	 Compilation of $(ACTVTE) requires running $(GMS_PATH)/config

#zunix is always required
$(OBJ_DIR)/zunix.o : $(SRC_DIR)/zunix.c
	@$(COMPALL) 1 2>&1 1>/dev/null

#compall is parsed to determine which MODULES are to be compiled.
#These extra files may be necessary and LKED will determine that so
#I think it is best just to make sure they are compiled anyway.
$(OBJ_DIR)/blaswrap.o : $(GMS_PATH)/misc/blaswrap.src
	@if [ -e $(OBJ_DIR)/blaswrap.f ]; then rm $(OBJ_DIR)/blaswrap.f;fi
	@$(COMP) blaswrap 2>&1 1>/dev/null | sed -e $(SEDSRC)
$(OBJ_DIR)/blas.o : $(SRC_DIR)/blas.src
	@if [ -e $(OBJ_DIR)/blas.f ]; then rm $(OBJ_DIR)/blas.f;fi
	@$(COMP) blas 2>&1 1>/dev/null | sed -e $(SEDSRC)
$(OBJ_DIR)/vector.o : $(SRC_DIR)/vector.src
	@if [ -e $(OBJ_DIR)/vector.f ]; then rm $(OBJ_DIR)/vector.f;fi
	@$(COMP) vector 2>&1 1>/dev/null | sed -e $(SEDSRC)


#I don't yet try to micro manage DDI compilation.
#Compilation is very quick anyway.
ddi : $(DDI_LIB) $(DDIKICK)
$(DDI_LIB) $(DDIKICK) :
	$(GMS_PATH)/ddi/compddi
	@if [ -e $(GMS_PATH)/ddi/ddikick.x ]; then mv $(GMS_PATH)/ddi/ddikick.x $(DDIKICK);fi
	@if [ -e $(GMS_PATH)/ddi/ddi_test.x ]; then mv $(GMS_PATH)/ddi/ddi_test.x $(DDITEST);fi
	@if [ -e $(GMS_PATH)/ddi/data_server.x ]; then mv $(GMS_PATH)/ddi/data_server.x $(DATASERVER);fi
	@if [ -e $(GMS_PATH)/ddi/libddi.a ] && [ "$(GMS_PATH)/ddi/libddi.a" != "$(DDI_LIB)" ]; then mv $(GMS_PATH)/ddi/libddi.a  $(DDI_LIB);fi


#### Auxillary targets ####

#at runtime, extra flags can be added (like -e to make emacs compitable tags)
tags : $(SRC_DIR)/*.src
	$(CTAGS) $(CTAGS_FLAGS) --langmap=fortran:.src $(SRC_DIR)/* $(GMS_PATH)/ddi/src/*

#FTNCHEK: a summary is printed to STDOUT along with the gamess.lis and individual lis files in OBJ_DIR
gamess.lis : $(ACT) $(LIS)
	$(FTNCHEK) $(FTNCHEK_OPT2) $(ACT) 2>&1 | sed -e $(SEDSRC2) > gamess.lis
check : gamess.lis
	@awk '{if($$0 ~ "[1-9]+ syntax errors") print "------\n",$$0,"\n------"}' gamess.lis
	@awk '{if($$0 ~ "[1-9]+ warning[s]* issued") print $$0}' gamess.lis

#Build a tarball based on a git commit or tag
COMMIT=HEAD
TAR_VERSION=$(GMS_VERSION)
dist :
	@echo "Creating $(GMS_BUILD_PATH)/gamess-$(TAR_VERSION).tar.gz for commit $(COMMIT) in branch `git name-rev --name-only $(COMMIT)`"
	@cd $(GMS_PATH) && git archive --format=tar --prefix=gamess-$(TAR_VERSION)/ $(COMMIT) | gzip >$(GMS_BUILD_PATH)/gamess-$(TAR_VERSION).tar.gz

clean :
	rm -rf $(OBJ)
	rm -rf $(ACT)
	rm -rf $(LIS)
	rm -rf $(GAMESS)
	rm -rf gamess.lis

clean_ddi :
	rm -rf $(DDI_LIB)
	rm -rf $(DDIKICK)
	rm -rf $(DDITEST)
	rm -rf $(DATASERVER)




############ The new CHECKTEST ##################
# The target checktest will run the exam inputs and perform the error checking.
# If an examXX.log file exists, it will not be rerun and only checked.  If the
# user wishes to only a few of the exams:
#
# make checktest EXAMS=exam05
# make checktest EXAMS="exam05 exam30"
# 
# To add new exam, two files are required
#
# The input
#    $(GMS_PATH)/tests/mytest.inp
# The script (use already present examXX scripts as templates)
#    $(GMS_PATH)/tests/scripts/mytest
#
# The new exam can be run and tested by itself
#    make checktest EXAMS=mytest
#
#

RUNGMS=$(GMS_PATH)/rungms

GMS_EXT = log

EXAMS = exam01 exam02 exam03 exam04 exam05 exam06 exam07 exam08 exam09 exam10 exam11 exam12 exam13 exam14 exam15 exam16 exam17 exam18 exam19 exam20 exam21 exam22 exam23 exam24 exam25 exam26 exam27 exam28 exam29 exam30 exam31 exam32 exam33 exam34 exam35 exam36 exam37 exam38 exam39 exam40 exam41 exam42 exam43 exam44

EXAM_INPUTS = $(patsubst %,$(GMS_PATH)/tests/%.inp,$(EXAMS))

EXAM_OUTPUT_DIR = $(GMS_BUILD_PATH)/tests
EXAM_LOG = $(patsubst %,$(EXAM_OUTPUT_DIR)/%.$(GMS_EXT),$(EXAMS))
EXAM_RST = $(patsubst %,$(EXAM_OUTPUT_DIR)/%.rst,$(EXAMS))
EXAM_DAT = $(patsubst %,$(EXAM_OUTPUT_DIR)/%.dat,$(EXAMS))
EXAM_TRJ = $(patsubst %,$(EXAM_OUTPUT_DIR)/%.trj,$(EXAMS))
#this is a dummy that is never actually created but helps make the checktest target
EXAM_CHK = $(patsubst %,$(EXAM_OUTPUT_DIR)/%.chk,$(EXAMS))

$(EXAM_OUTPUT_DIR)/%.$(GMS_EXT) : $(GAMESS) $(GMS_PATH)/tests/%.inp
	@cd $(EXAM_OUTPUT_DIR) && if [ -e $(EXAM_OUTPUT_DIR)/$(notdir $(basename $@)).dat ]; then rm $(EXAM_OUTPUT_DIR)/$(notdir $(basename $@)).dat;fi
	@cd $(EXAM_OUTPUT_DIR) && if [ -e $(EXAM_OUTPUT_DIR)/$(notdir $(basename $@)).rst ]; then rm $(EXAM_OUTPUT_DIR)/$(notdir $(basename $@)).rst;fi
	@cd $(EXAM_OUTPUT_DIR) && if [ -e $(EXAM_OUTPUT_DIR)/$(notdir $(basename $@)).trj ]; then rm $(EXAM_OUTPUT_DIR)/$(notdir $(basename $@)).trj;fi
	@cd $(EXAM_OUTPUT_DIR) && if [ -e $(EXAM_OUTPUT_DIR)/$(notdir $(basename $@)).$(GMS_EXT) ]; then rm $(EXAM_OUTPUT_DIR)/$(notdir $(basename $@)).$(GMS_EXT);fi
	cd $(EXAM_OUTPUT_DIR) && $(RUNGMS) $(notdir $(basename $@)) $(GMS_VERSION) > $(notdir $(basename $@)).$(GMS_EXT) 2>&1

exams : $(EXAM_LOG)


#These environment variables are required to run the 
# the checking scripts in $(GMS_PATH)/tests/scripts
#Tolerances can be changed on the command line
#  make checktest tolE=6e-5
export tolC=0.3
export tolD=0.0001
export tolE=0.00000001
export tolG=0.00001
export tolH=0.0001
export tolI=0.0001
export tolL=0.1
export tolO=0.0001
export tolP=0.0001
export tolR=0.0001
export tolS=0.01
export tolT=0.000001
export tolV=0.00000001
export tolW=0.1
export tolX=0.00001
export chkabs=$(GMS_PATH)/tests/scripts/chkabs

CHK_PATH=$(GMS_PATH)/tests/scripts

#print the restuls of the examXX script
CHK_AWK = -v exam=$(notdir $(basename $@)) '{ printf "%-10s %-63s",exam,$$0 }';if [ $$? != 0 ]; then echo "!!Failed";else echo Passed;fi 
#determine that the exam finished
GREP_TERM = grep -q "TERMINATED NORMALLY" $(EXAM_OUTPUT_DIR)/$(notdir $(basename $@)).$(GMS_EXT);if [ $$? != 0 ]; then echo "$(notdir $(basename $@))     !!! TERMINATED ABNORMALLY !!!";exit;fi

#check in single exam
$(EXAM_OUTPUT_DIR)/%.chk : $(EXAM_OUTPUT_DIR)/%.$(GMS_EXT)
	@cd $(EXAM_OUTPUT_DIR) && $(GREP_TERM) && $(CHK_PATH)/$(notdir $(basename $@)) $(notdir $(basename $@)).$(GMS_EXT) | awk $(CHK_AWK)
	
#since .chk files are never created make will always check all entries in EXAMS.
checktest : $(EXAM_LOG) $(EXAM_CHK)

clean_exams :
	rm -rf $(EXAM_RST) $(EXAM_DAT) $(EXAM_LOG) $(EXAM_TRJ)
