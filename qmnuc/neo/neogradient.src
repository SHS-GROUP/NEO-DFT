C*MODULE NEODFTGRD  *DECK NEODFTDER
C>    @brief Analytical NEO-DFT gradient. Clone of DFTGRD
C>
C
      SUBROUTINE NEODFTDER
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000,ZERO=0.0D+00,ONE=1.0D+00,TWO=2.0D+00)
      PARAMETER (MXSH=5000, MXGTOT=20000, MXGSH=30, MXG2=MXGSH*MXGSH)
      PARAMETER (MXAO=8192, MXNEO=30)
C
      LOGICAL UROHF,OUT,GOPARR,DSKWRK,MASWRK
C
      COMMON /FMCOM / X(1)
      COMMON /FUNCT / E,EG(3*MXATM)
      COMMON /GRDNEO/ DERNEO(3,MXATM)
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      COMMON /NUCMOI/ NUNIQN,IUNIQN(MXNEO),IUNIQT(MXNEO),NQMNUC,
     *                IQMNUC(MXNEO),IQNTYP(MXNEO),NUMNB,NUCST,NAUXNB,
     *                IAUXNB(MXNEO),NUMULT,NNA,NNB,NTAUXB
      COMMON /SYMNEO/ QMTOLN,SYMNUC

C
      COMMON /DNSAO / IDENAO
C
      DATA UHF,ROHF/8HUHF     ,8HROHF    /
      DATA DEBUG/8HDEBUG   /, DFTGRD/8HDERDFT  /,GRD1/8HGRD1    /
      DATA CHECK/8HCHECK   /
      LOGICAL SYMNUC
C
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3=L1*L1
      N0 = NUMNB
      IF(SYMNUC) N0 = NNQMT
      N1 = NUMNB
      N2 = (N1*N1+N1)/2
      N3 = N1*N1

C
      UROHF = SCFTYP.EQ.UHF  .OR.  SCFTYP.EQ.ROHF
      OUT=(EXETYP.EQ.DFTGRD.OR.EXETYP.EQ.DEBUG.OR.EXETYP.EQ.GRD1).AND.
     *     MASWRK
C
      CALL GRDDFT(L2,NDFTEN)
C
      CALL VALFM(LOADFM)
C
      IDFTEN  = LOADFM  + 1
      IG2AXX  = IDFTEN  + NDFTEN
      IG2AYY  = IG2AXX  + NUM
      IG2AZZ  = IG2AYY  + NUM
      IG2AXY  = IG2AZZ  + NUM
      IG2AYZ  = IG2AXY  + NUM
      IG2AXZ  = IG2AYZ  + NUM
      ICOEFFA = IG2AXZ  + NUM
      ICOEFFB = ICOEFFA + NUM*NUM
      LDA     = ICOEFFB + NUM*NUM
      LDB     = LDA     + L2
      LDDA    = LDB     + L2
      LDDB    = LDDA    + L3
      LDEDFT  = LDDB    + L3
      IUVEC   = LDEDFT  + NAT*3
      IDWTINT = IUVEC   + NAT*3
      IDWTTOT = IDWTINT + 3*NAT*NAT
      IDTOTWT = IDWTTOT + 3*NAT
      LNVA    = IDTOTWT + 3*NAT
      LNDA    = LNVA    + N3
      LNDDA   = LNDA    + N2
      LAST    = LNDDA   + N3 
C
      NEED = LAST - LOADFM - 1
C
C     ---- GET MEMORY ----
C
      CALL GETFM(NEED)
C     WRITE(6,*) 'WWWAHAHAA',NDFTEN,NUM,L2,L3,NAT
      IF(MASWRK) WRITE(IW,9000) NEED
      IF(EXETYP.EQ.CHECK) GO TO 800
C
C     READ OR GENERATE DFT GRID. NOTE THAT THIS CAN BE A DIFFERENT GRID
C     COMPARED TO THE DFT ENERGY, BECAUSE THE SYMMETRY OF THE GRADIENT
C     COMPONENTS IS NOT THE SAME AS OF THE ENERGY, SO WE IN FACT TURN
C     OFF USING OCTANT SYMMETRY, BUT KEEP ATOMIC CENTRE SYMMETRY.
C     IN CASE OF C1 AND NON-ABELIAN GROUPS, OCTANT SYMMETRY IS NOT USED
C     SO THE GRID INFORMATIONS CAN BE READ.
C
      CALL DFTSET(X(IDFTEN),0,.TRUE.)
C
C      Open(unit=9898, file='compare.dat')
C SET UP ELECTRON PART
      CALL DAREAD(IDAF,IODA,X(ICOEFFA),NUM*NUM,15,0)
C     ----- TRANSPOSE X(ICOEFFA) FOR EFFICIENCY -----
C     ----- USE X(LDDA) FOR TEMPORARY STORAGE   -----    
      CALL TRPOSE(X(ICOEFFA),X(LDDA),L1,L1,1)
      CALL DAREAD(IDAF,IODA,X(LDA),L2,16,0) 
      CALL EXPND(X(LDA),X(LDDA),L1,0)
      IF(IDENAO.EQ.1) THEN
         CALL DCOPY(L2,X(LDA),1,X(ICOEFFA),1)
      ENDIF
C-@ZCT
      IF (UROHF) THEN
        CALL DAREAD(IDAF,IODA,X(ICOEFFB),NUM*NUM,19,0)
C      write(9898,*) "coraline-ICOEFFB"
C      do I=1, NUM*NUM
C        write(9898,*) X(ICOEFFB+I-1)
C      end do
C     ----- TRANSPOSE X(ICOEFFB) FOR EFFICIENCY -----
C     ----- USE X(LDDB) FOR TEMPORARY STORAGE   -----
        CALL TRPOSE(X(ICOEFFB),X(LDDB),L1,L1,1)
        CALL DAREAD(IDAF,IODA,X(LDB),L2,20,0)
C      write(9898,*) "coraline-LDB"
C       do I = 1, L2
C         write(9898,*) X(LDB+I-1)
C       end do 
        CALL EXPND(X(LDB),X(LDDB),L1,0)
        IF(IDENAO.EQ.1) THEN
         CALL DCOPY(L2,X(LDB),1,X(ICOEFFB),1)
        ENDIF
      ENDIF
C      flush(9898)
C      close(9898)
C      call ABRT
C SET UP PROTON PART
      CALL DAREAD(IDAF,IODA,X(LNVA),N3,444,0)
C     ----- TRANSPOSE X(LNVA) FOR EFFICIENCY -----
C     ----- USE X(LNDDA) FOR TEMPORARY STORAGE   -----
      CALL TRPOSE(X(LNVA),X(LNDDA),N1,N1,1)
      CALL DAREAD(IDAF,IODA,X(LNDA),N2,445,0)
      CALL EXPND(X(LNDA),X(LNDDA),N1,0)  
      CALL VCLR(X(LDEDFT),1,NAT*3)
      CALL NEODFTGRAD(X(IDFTEN),X(IG2AXX),X(IG2AYY),X(IG2AZZ),
     *             X(IG2AXY),X(IG2AYZ),X(IG2AXZ),X(ICOEFFA),
     *             X(ICOEFFB),X(LDDA),X(LDDB),
     *             X(LDEDFT),X(IUVEC),X(IDWTINT),X(IDWTTOT),
     *             X(IDTOTWT),L1,N1,TOTELE,TOTNUC,OUT,
     *             X(LNVA),X(LNDDA))
C
      WRITE(IW,9100)
      CALL EGOUT(X(LDEDFT),NAT)

      CALL VADD(DE,1,X(LDEDFT),1,EG,1,3*NAT)
c
C
  800 CONTINUE
      CALL RETFM(NEED)
      CALL TIMIT(1)
      RETURN
C
 9000 FORMAT(1X,'MEMORY FOR GRID POINT CONTRIBUTIONS TO THE',
     *          ' DFT GRADIENT=',I10,' WORDS.')
 9100 FORMAT(/1X,'TOTAL NEO-DFT GRADIENT TERMS')
      END
C
C
C*MODULE NEODFTGRD  *DECK NEODEREXC
C>    @brief Clone of DEREXC which is a clone of DMATD
C>
C>    @details SEE ADDITIONAL REFERENCES THERE.
C>     HERE A CONTRIBUTION TO THE ENERGY GRADIENT DUE TO INTEGRATION OVER
C>     GRID POINTS SURROUNDING ATOM NCNTR IS COMPUTED.
C>
C>
C>    @date : December 21, 2012 - Joe Ivanic
C>            Modify IJX,IJY,IJZ to have dimension 84 for h,i cartesians
C
      SUBROUTINE NEODEREXC(TOTWT,NAPTS,COEFFA,COEFFB,DA,DB,
     *                IANGN,IFACTR,
     *                INC0,VMOA,DVMOXA,DVMOYA,DVMOZA,VMOB,DVMOXB,
     *                DVMOYB,DVMOZB,
     *                WGHT,RI,RIJ,WTINTR,AIJ,WTRAD,
     *                NCNTR,L1,N1,TOTELE,TOTNUC,NANG,PTRAD,
     *                XDAT,YDAT,ZDAT,
     *                ATMXVEC,ATMYVEC,ATMZVEC,ANGXVL,ANGYVL,ANGZVL,
     *                RSQRD,PCOEFF,EXPS,PCOEFFNUC,EXPSNUC,
     *                AOX,GAOX,GAOY,GAOZ,
     *                G2AOXX,G2AOYY,G2AOZZ,G2AOXY,G2AOYZ,G2AOXZ,NLCT,
     *                NELM,IJX,IJY,IJZ,NEEDGR,DEDFT,UVEC,
     *                DWTINT,DWTTOT,DTOTWT,OUT,COEFFANUC,
     *                DANUC,
     *                AOXNUC,GAOXNUC,GAOYNUC,GNOZNUC,VMOANUC,
     *                VMOBNUC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL UROHF,OUT,NEEDGR,GOPARR,DSKWRK,MASWRK,DLB,NEEDTAU,
     *        PRTTAU,SG1,FUNCL,FUNFL
C
      PARAMETER (MXATM=2000,ZERO=0.0D+00,ONE=1.0D+00,TWO=2.0D+00)
      PARAMETER (MXGRID=10,MXGRIDTYP=10)
      PARAMETER (MXSH=5000, MXGTOT=20000, MXGSH=30, MXG2=MXGSH*MXGSH)
      PARAMETER (MXAO=8192, MXNEO=30)

C
      COMMON /DFGRID/ DFTTHR,DFTGTHR,SWOFF,SW0,BSLRD(137),NDFTFG,
     *                NRAD,NTHE,NPHI,NRAD0,NTHE0,NPHI0,
     *                NANGPT(MXGRID),NANGPT0(MXGRID),SG1,JANS
      COMMON /DFPRUN/ PRUNERADS(MXGRID,MXGRIDTYP),
     *                PRUNEATOMS(2,MXGRIDTYP),
     *                IPRUNECUTS(MXATM),NTOTGRIDPOINTS(MXATM),
     *                NGRIDS,MAXANG,NGRIDTYPS
      COMMON /FUNLIB/ FUNCL,FUNFL
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /METGGA/ NEEDTAU,PRTTAU
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      COMMON /NUCMOI/ NUNIQN,IUNIQN(MXNEO),IUNIQT(MXNEO),NQMNUC,
     *                IQMNUC(MXNEO),IQNTYP(MXNEO),NUMNB,NUCST,NAUXNB,
     *                IAUXNB(MXNEO),NUMULT,NNA,NNB,NTAUXB
C
      COMMON /DNSAO / IDENAO
      PARAMETER (HALF=0.5D+00)
C
      DIMENSION TOTWT(NAT,*),COEFFA(L1,*),COEFFB(L1,*),
     >          VMOA(NUM),DVMOXA(NUM),DVMOYA(NUM),DVMOZA(NUM),
     >          VMOB(NUM),DVMOXB(NUM),DVMOYB(NUM),DVMOZB(NUM),
     *          DA(NUM,NUM),DB(NUM,NUM)
      DIMENSION NAPTS(NAT),IANGN(NAT,2,MXGRID),IFACTR(NAT)
      DIMENSION AOX(NUM),GAOX(NUM),GAOY(NUM),GAOZ(NUM),
     *          G2AOXX(NUM),G2AOYY(NUM),G2AOZZ(NUM),
     *          G2AOXY(NUM),G2AOYZ(NUM),G2AOXZ(NUM),
     *          DEDFT(3,NAT),EXPS(*),EXPSNUC(*),PTRAD(*),
     *          XDAT(NAT,MAXANG,MXGRID),YDAT(NAT,MAXANG,MXGRID),
     *          ZDAT(NAT,MAXANG,MXGRID),RSQRD(*),PCOEFF(*),PCOEFFNUC(*),
     *          ATMXVEC(NAT,NAT),ATMYVEC(NAT,NAT),ATMZVEC(NAT,NAT),
     *          ANGXVL(NAT,*),ANGYVL(NAT,*),ANGZVL(NAT,*),
     *          WGHT(NAT,MAXANG,MXGRID),RI(NAT),RIJ(NAT,NAT),
     *          WTINTR(NAT),AIJ(NAT,NAT),WTRAD(*),UVEC(3,NAT),
     *          DWTINT(3,NAT,NAT),DWTTOT(3,NAT),DTOTWT(3,NAT)
      DIMENSION IJX(84),IJY(84),IJZ(84)
      DIMENSION NLCT(*),NELM(*)
      DIMENSION AOXNUC(NUMNB)
      DIMENSION GAOXNUC(NUMNB),GAOYNUC(NUMNB),GAOZNUC(NUMNB)
      DIMENSION COEFFANUC(NUMNB,*),VMOANUC(NUMNB),VMOBNUC(NUMNB)
      DIMENSION DANUC(NUMNB,NUMNB)
C
      DATA DEBUG/8HDEBUG   /, DFTDER/8HDFTDER  /
      DATA UHF,ROHF/8HUHF     ,8HROHF    /
C
      UROHF = SCFTYP.EQ.UHF  .OR.  SCFTYP.EQ.ROHF
      OUT = EXETYP.EQ.DFTDER  .OR.  EXETYP.EQ.DEBUG
C
C
      RAD = BRAGGRAD(NCNTR)
      NOA = NA
      NOB = NB
      NPT=NRAD*MAXANG
      EEPC1 = ZERO
      ETOTAL= ZERO
C
C     SET CUT-OFFS FOR DFT GRADIENT:
C     WCUTOFF - CELL VOLUME (WEIGHT)
C     RCUTOFF - ELECTRON DENSITY
C     CCUTOFF - LCAO COEFFICIENTS (AS USED FOR AO -> MO TRANSFORMATION)
C     FCUTOFF - FUNCTIONAL DERIVATIVE
C     AT PRESENT WEIGHT DERIVATIVE CUTOFF IS FOUND UNUSEFUL.
C
C     DFTTHR IS NOT USED IN THE GRADIENT.
C     INSTEAD, DFTGTHR IS USED AS FOLLOWS:
C     DFTGTHR=1 USE DEFAULT THRESHOLDS
C     DFTGTHR<1 SET ALL THRESHOLDS TO DFTGTHR
C     DFTGTHR>1 DIVIDE DEFAULT THRESHOLDS BY DFTGTHR (MAKE TIGHTER).
C     DFTTHR SET TO 1E-15 AS BEFORE SETS ALL GRAD THRESHOLDS TO 1E-15.
C
C     IF HIGHER ACCURACY IN GRADIENT DUE TO THRESHOLDS IS THOUGHT THE
C     RECOMMENDED WAY IS TO SET DFTGTHR=10 (WHICH MEANS ADD ABOUT
C     1 DIGIT OF ACCURACY, RELATIVE TO NO THRESHOLDS; DFT GRID
C     INTEGRATION HAS ITS OWN ERRORS, FINALLY, 2E INTEGRALS ALSO HAVE
C     CERTAIN ERROR BARS ON THEM).
C
      THRV1=ZERO
      THRV2=1.0D+00
      IF(DFTGTHR.GT.1.01D+00) THEN
        THRV2=DFTGTHR
      ELSE IF(DFTGTHR.LT.0.99D+00) THEN
        THRV1=DFTGTHR
      ENDIF
      IF(DFTTHR.LT.1.1D-15.AND.DFTTHR.NE.ZERO) THRV1=1.0D-15
C     THRV2=1.0D+00
      WCUTOFF=3.0D-05/NPT/THRV2
      RCUTOFF=1.0D-02/NPT/THRV2
      CCUTOFF=1.0D-01/NPT/THRV2
      FCUTOFF=3.0D-04/NPT/THRV2
C     WDCUTOFF=1.0D+01*WCUTOFF
C     IF(DFTTHR.LT.1.1D-15.AND.DFTTHR.NE.ZERO) THEN
      IF(THRV1.NE.ZERO) THEN
C        THRV1=1.0D-15
         WCUTOFF=THRV1
         RCUTOFF=THRV1
         CCUTOFF=THRV1
         FCUTOFF=THRV1
C        WCUTOFF=WCUTOFF*1D-1
C        RCUTOFF=RCUTOFF*1D-1
C        CCUTOFF=CCUTOFF*1D-1
C        FCUTOFF=FCUTOFF*1D-1
C        WDCUTOFF=WDCUTOFF*1D-1
      ENDIF
C     WRITE(6,*) 'WWWG',WCUTOFF,RCUTOFF,CCUTOFF,FCUTOFF,DFTGTHR
C
C     ANGXVL=X**I, ANGYVL=Y**J, ANGZVL=Z**K, FOR ALL VALUES OF I,J,K
C     WHERE (X,Y,Z) IS THE CENTRE OF A DFT GRID POINT RI
C     MINUS AN ATOMIC CENTRE RA: XYZ= (RI - RA)
C
      CALL VCLR(ANGXVL(1,1),1,NAT)
      CALL VCLR(ANGYVL(1,1),1,NAT)
      CALL VCLR(ANGZVL(1,1),1,NAT)
      CALL DACOPY(NAT,ONE,ANGXVL(1,2),1)
      CALL DACOPY(NAT,ONE,ANGYVL(1,2),1)
      CALL DACOPY(NAT,ONE,ANGZVL(1,2),1)
C     ---- SYMMETRY MULTIPLICATION FACTOR ----
C
C      FACT = IIFACT(NCNTR)*IFACTR(INC0)
      FACT=IFACTR(INC0)
C      FACT=1
C
C     DYNAMIC LOAD BALANCING: DIVIDE ALL POINTS INTO NGRAN*NPROC CHUNKS.
C     NGRAN CANNOT BE SET IN THE INPUT FILE. THEN EACH NODE GETS A CHUNK
C     AND TOILS IT OVER UNTIL READY TO ASK FOR MORE.
C
      LOOP=0
      NGRAN=20
      IGRID = 1
      IF(NGRIDS.EQ.1) THEN
         NLOOP=NRAD*(IANGN(NCNTR,2,1)-IANGN(NCNTR,1,1)+1)
      ELSE
         NLOOP=NTOTGRIDPOINTS(NCNTR)
      ENDIF
      MCHUNK=(NLOOP-1)/(NGRAN*NPROC)+1
      NEXT  = -1
      DLB = IBTYP.EQ.1
C***********************************************************************
C     LOOP OVER RADIAL GRIDS
C     LOOP OVER ANGULAR GRIDS
C***********************************************************************
      DO 20 IRADPT = 1, NRAD
C
        RADWT=RAD*RAD*RAD*WTRAD(IRADPT)
        R1= RAD*PTRAD(IRADPT)
        IF(R1.GE.PRUNERADS(IGRID,IPRUNECUTS(NCNTR))*RAD) THEN
           IGRID = IGRID + 1
        ENDIF
C     WRITE(IW,'(A,I5,2F20.10,I5)')'RAD,PT,IGRID = ',IRADPT,RAD,
C     *       PTRAD(IRADPT),IGRID
        DO 10 IANGPT = IANGN(NCNTR,1,IGRID), IANGN(NCNTR,2,IGRID)
           IPT=(IRADPT-1)*NAPTS(NCNTR)+IANGPT
C
          IF(GOPARR) THEN
            IF(DLB) THEN
              LOOP=LOOP+1
              ICHUNK=(LOOP-1)/MCHUNK
              IF(ICHUNK.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
              IF(NEXT.NE.ICHUNK) GOTO 10
            ELSE
              IF(MOD(IPT,NPROC).NE.ME) GOTO 10
            ENDIF
          ENDIF
          IPTME=(IPT-1)/NPROC+1
          IF(DLB) IPTME=IPT
C
          FTOTWT = TOTWT(NCNTR,IPTME)*FACT
          FTOTWT0=FTOTWT/FACT
          IF(FTOTWT0.LT.WCUTOFF) THEN
             GOTO 10
          ENDIF
C
          XD=R1*XDAT(NCNTR,IANGPT,IGRID)
          YD=R1*YDAT(NCNTR,IANGPT,IGRID)
          ZD=R1*ZDAT(NCNTR,IANGPT,IGRID)
          DO 610 IATM=1,NAT
            XCDNT=ATMXVEC(NCNTR,IATM)+XD
            YCDNT=ATMYVEC(NCNTR,IATM)+YD
            ZCDNT=ATMZVEC(NCNTR,IATM)+ZD
            RSQRD(IATM)=XCDNT**2+YCDNT**2+ZCDNT**2
C
C           NORMALISE THE R(A) VECTOR, = R(I)-R(A)
C
            RI(IATM)=SQRT(RSQRD(IATM))
            UVEC(1,IATM) = XCDNT / RI(IATM)
            UVEC(2,IATM) = YCDNT / RI(IATM)
            UVEC(3,IATM) = ZCDNT / RI(IATM)
C
            ANGXVL(IATM,3)=XCDNT
            ANGYVL(IATM,3)=YCDNT
            ANGZVL(IATM,3)=ZCDNT
            DO 35 IANG=3,NANG
               ANGXVL(IATM,IANG+1)=ANGXVL(IATM,IANG)*XCDNT
               ANGYVL(IATM,IANG+1)=ANGYVL(IATM,IANG)*YCDNT
               ANGZVL(IATM,IANG+1)=ANGZVL(IATM,IANG)*ZCDNT
 35         CONTINUE
  610     CONTINUE
C
C**************************************
C     FIND AO AND GRADIENT AO VALUES AT THIS POINT
C***************************************

          CALL DFTAO(IJX,IJY,IJZ,AOX,ANGXVL,ANGYVL,ANGZVL,PCOEFF,EXPS,
     *               RSQRD,NAT,L1)
          CALL DFTGAO(IJX,IJY,IJZ,GAOX,GAOY,GAOZ,ANGXVL,ANGYVL,
     *                  ANGZVL,PCOEFF,EXPS,RSQRD,NAT,L1)
          CALL DFTNUCAO(IJX,IJY,IJZ,AOXNUC,ANGXVL,ANGYVL,ANGZVL,
     *               PCOEFFNUC,EXPSNUC,RSQRD,NAT,N1)
          CALL DFTNUCGAO(IJX,IJY,IJZ,GAOXNUC,GAOYNUC,GAOZNUC,ANGXVL,
     *                ANGYVL,ANGZVL,PCOEFFNUC,EXPSNUC,RSQRD,NAT,N1,
     *                 .TRUE.)

C***********************************************************************
C     FORM DENSITY AT THIS POINT
C***********************************************************************

c     ----- ELECTRONIC DENSITY ------
          CALL DFTTRFA(UROHF,L1,NOA,COEFFA,COEFFB,AOX,VMOA,VMOB,
     *                    CCUTOFF)
          ROA=DDOT(NOA,VMOA,1,VMOA,1)
          IF(UROHF) THEN
            ROB=DDOT(NOB,VMOB,1,VMOB,1)
          ELSE
            ROB=ROA
          ENDIF
          IF(ROA+ROB.LT.RCUTOFF) THEN
             GOTO 10
          ENDIF

C     ----- PROTON DENSITY -----
          CALL DFTTRFA(FALSE,N1,NNA,COEFFANUC,COEFFANUC,AOXNUC,
     *                 VMOANUC,VMOBNUC,CCUTOFF)
          ROANUC=DDOT(NNA,VMOANUC,1,VMOANUC,1)


C*********************************************
C         COMPUTE THE WEIGHT DERIVATIVE.
C*********************************************

          WGHTNOW=WGHT(NCNTR,IANGPT,IGRID)
          NITR=4
          CALL GRDOCT(NAT,NITR,NCNTR,ATMXVEC,ATMYVEC,ATMZVEC,RI,RIJ,AIJ,
     *          WGHTNOW,RADWT,WTINTR,UVEC,DWTINT,DWTTOT,DTOTWT)

C***********************************************
C     ----- PROTON-ELECTRON CORRELATION -----
C*********************************************

          VCORRAELEBYNUC=ZERO
          VCORRBELEBYNUC=ZERO
          VCORRANUCBYELE=ZERO
          VCORRBNUCBYELE=ZERO
          EEPCATPOINT=ZERO
          CALL CALCNECORR(EEPCATPOINT,ROA,ROB,ROANUC,ROBNUC,FTOTWT,
     *                 VCORRAELEBYNUC,VCORRBELEBYNUC,VCORRANUCBYELE,
     *                 VCORRBNUCBYELE)
          EEPC1=EEPC1+EEPCATPOINT


          VXCA1=ZERO
          VXCB1=ZERO
          DUMAX=ZERO
          DUMAY=ZERO
          DUMAZ=ZERO
          DUMBX=ZERO
          DUMBY=ZERO
          DUMBZ=ZERO
          DMGGA=ZERO
          DMGA =ZERO
          DMGGB=ZERO
          DMGB =ZERO
          GRDAA = ZERO
          GRDBB = ZERO
          GRDAB = ZERO
          G2AOXX=ZERO
          G2AOXY=ZERO
          G2AOXZ=ZERO
          G2AOYY=ZERO
          G2AOYZ=ZERO
          G2AOZZ=ZERO
          ECF=ZERO
          XGRD=ZERO
          XALPHA=ZERO
          EPART=ZERO
c            CALL CALCEXC(ROA,ROB,FTOTWT,GRDAA,GRDBB,GRDAB,
c     >                   GRADXA,GRADYA,GRADZA,GRADXB,GRADYB,GRADZB,
c     >                   XALPHA,XGRD,VXCA1,DUMAX,DUMAY,DUMAZ,
c     >                   VXCB1,DUMBX,DUMBY,DUMBZ,ECF,
c     >                   TAUXA,TAUYA,TAUZA,DMGGA,
c     >                   TAUXB,TAUYB,TAUZB,DMGGB)



C***********************************************************************
C      COMPUTE NEO-DFT GRADIENT ELECTRONIC PART
C***********************************************************************

          DUMA = VCORRAELEBYNUC
          DUMB = VCORRBELEBYNUC
c          DUMA=VXCA1
c          DUMB=VXCB1
c          EPART=XALPHA+XGRD+ECF
c          ETOTAL= ETOTAL + EPART

          UPBOW=ABS(DUMA)*TWO
C-@ZCT
          IF(UROHF) UPBOW=ABS(DUMA)+ABS(DUMB) 
          UPBOW=UPBOW*TWO*FTOTWT0
          IF(UPBOW.GT.FCUTOFF) THEN
C-@ZCT
             CALL DFTGDV(NCNTR,DEDFT,FTOTWT,NUM,DUMA,DUMAX,DUMAY,DUMAZ,
     >            DUMB,DUMBX,DUMBY,DUMBZ,AOX,GAOX,GAOY,GAOZ,
     >            G2AOXX,G2AOYY,G2AOZZ,G2AOXY,G2AOYZ,G2AOXZ,
     >            DA,DB,.FALSE.,UROHF,DMGA,DMGB,.FALSE.)
C     >            DA,DB,.FALSE.,.FALSE.,DMGA,DMGB,.FALSE.)
         
c             CALL NEODFTGDV(NCNTR,DEDFT,FTOTWT,NUM,DUMA,AOX,
c     *                     GAOX,GAOY,GAOZ,DA,NAT,.FALSE.)
          ENDIF
C***********************************************************************
C      COMPUTE NEO-DFT GRADIENT NUCLEAR PART
C***********************************************************************

          DUMA = VCORRANUCBYELE
          DUMB = VCORRBNUCBYELE

          CALL NEODFTGDV(NCNTR,DEDFT,FTOTWT,NUMNB,DUMA,AOXNUC,
     *                  GAOXNUC,GAOYNUC,GAOZNUC,DANUC,NAT,.TRUE.)

C***********************************************************************
C         ADD THE WEIGHT DERIVATIVE CONTRIBUTION
C         (WEIGHT DERIVATIVE ITSELF TIMES THE FUNCTIONAL VALUE).
C***********************************************************************

          EXEC2=EEPCATPOINT/FTOTWT*FACT
          CALL DAXPY(3*NAT,EXEC2,DTOTWT,1,DEDFT,1)

C**********************************************
C     ----- THE TOTAL ELECTRON AND NUCLEAR DENSITY -----
C**********************************************

          TOTELE=TOTELE+FTOTWT*(ROA+ROB)
          TOTNUC=TOTNUC+FTOTWT*ROANUC

C
C    ----- NEXT ANGULAR POINT ______
C

   10   CONTINUE
C
C     ----- NEXT RADIAL POINT -----

C
   20 CONTINUE
C


C
      IF(GOPARR.AND.DLB) CALL DDI_DLBRESET
      IF (OUT) THEN
         WRITE(IW,9999)NCNTR,TOTEXC,TOTELE
         DO INAT=1,NAT
            WRITE(IW,9998) DEDFT(1,INAT),DEDFT(2,INAT),DEDFT(3,INAT)
         ENDDO
      ENDIF
      RETURN
 9998 FORMAT(/F20.10,F20.10,F20.10)
 9999 FORMAT(/5X,'ATM',I8,'EXC=',F20.10,5X,'TOTELE=',F20.10)
      END
C*MODULE NEODFTGRD  *DECK NEODFTGDV
C>    @brief Clone of DFTGDV
C>     Compute NEO-DFT energy gradient (functional part only)
C>
C>    @details FOR A FUNCTIONAL FXC[RO,DELTA_RO] WHERE DELTA_RO IS GRADIENT OF
C>     DENSITY TOTAL EXCHANGE-CORRELATION ENERGY E=INTEGRAL FXC DR
C>     BY TAKING DERIVATIVE OVER SOME NUCLEAR COORDINATE R,
C>     DE/DR =
C>       INTEGRAL DF/D(RO)*D(RO)/DR   DF/D(DELTA_RO)*D(DELTA_RO)/DR DR
C>     D(RO)/DR = - D(RO)/DR AND D(DELTA_RO)/DR = - D(DELTA_RO)/DR
C>     (WHERE R IS ELECTRON COORDINATE)
C>     DF/D(RO) AND DF/D(DELTA_RO) ARE STORED IN DUMA,DUMAX,DUMAY,DUMAZ
C>     FOR ALPHA DENSITY AND IN DUMB, DUMBX, DUMBY, DUMBZ FOR BETA.
C>     ALPHA + BETA DENSITY FORM ADDITIVE CONTRIBUTIONS TO THE GRADIENT.
C>     NEXT,   D(RO)/DR(L) = 2 * SUM(I,J) D(I,J) DF(I)/DR(L) * F(J)
C>     D(DELTA(K)_RO)/DR(L)= 2 * SUM(I,J) D(I,J)(DG[K](I)/DR[L]*F(J)
C>                             +G[K](I)*G[L](J))
C>     WHERE F(I) IS AO NUMBER I AND G[K](I) IS DF(I)/DR[K],
C>     AND D(I,J) IS DENSITY, STORED IN DA AND DB, FOR ALPHA AND BETA.
C>     F(I) IS STORED IN AOX, G[K](I) IN GAOX, GAOY, GAOZ,
C>     DG[K](I)/DR[L] IN G2AOXX,G2AOYY,G2AOZZ,G2AOXY,G2AOYZ,G2AOXZ.
C
      SUBROUTINE NEODFTGDV(NCNTR,DEDFT,FTOTWT,NUM,DUMA,
     *                  AOX,GAOX,GAOY,GAOZ,
     *                  DA,NAT,NEO)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION AOX(NUM),GAOX(NUM),GAOY(NUM),GAOZ(NUM)
      DIMENSION DEDFT(3,NAT),DA(NUM,NUM)
C
      LOGICAL NEEDGR,UROHF,NEO
C
      PARAMETER(TWO=2.0D+00,ZERO=0.0D+00)
      PARAMETER (MXSH=5000, MXGTOT=20000)
      PARAMETER (MXGSH=30, MXG2=MXGSH*MXGSH, MXATM=2000)
      PARAMETER (MXAO=8192, MXNEO=30)
C
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /NEOSHL/ NGAUSS,NGAUSE,NGAUSN,NTSHEL,NNUCSH
C
C
C
      IF(NEO) THEN
        ISTART  = NSHELL+1
        IFINISH = NTSHEL
      ELSE
        ISTART  = 1
        IFINISH = NSHELL
      ENDIF
        DO ISHELL=ISTART,IFINISH
         IAT =KATOM(ISHELL)
         IF(IAT.NE.NCNTR) THEN
          MINI=KMIN (ISHELL)
          MAXI=KMAX (ISHELL)
          LOCI=KLOC (ISHELL)-MINI
          GRADX=ZERO
          GRADY=ZERO
          GRADZ=ZERO
          DO IBFN=MINI,MAXI
            ICHI=LOCI+IBFN
            DRA=ZERO
            DO JCHI=1,NUM

              DIJA=DA(JCHI,ICHI)
C
C             COMPUTE SUM(J) D(I,J) F(J)
C
              DRA= DRA+ DIJA*AOX(JCHI)
            ENDDO
            GAOXI=GAOX(ICHI)
            GAOYI=GAOY(ICHI)
            GAOZI=GAOZ(ICHI)
C
C           COMPUTE -1/2*DF/D(RO)*D(RO)/DR
C                   = DF/D(RO)*SUM(I,J)D(I,J)DF(I)/DR*F(J)
C
            GRADX=GRADX+GAOXI*DRA*DUMA
            GRADY=GRADY+GAOYI*DRA*DUMA
            GRADZ=GRADZ+GAOZI*DRA*DUMA
          ENDDO
C
C     AT THIS POINT WE HAVE COMPLETED THE NUCLEAR GRADIENT CONTRIBUTIONS
C     FOR LDA TYPE FUNCTIONALS
C
          DEDFTGRADX = TWO*FTOTWT*GRADX
          DEDFTGRADY = TWO*FTOTWT*GRADY
          DEDFTGRADZ = TWO*FTOTWT*GRADZ
C
          DEDFT(1,IAT)=DEDFT(1,IAT)-DEDFTGRADX
          DEDFT(2,IAT)=DEDFT(2,IAT)-DEDFTGRADY
          DEDFT(3,IAT)=DEDFT(3,IAT)-DEDFTGRADZ
C
C         USING TRANSLATIONAL INVARIANCE SUM(B) GRAD(B) EXC = 0
C         TO GET GRAD(A) E = - SUM(B.NE.A) GRAD(B) EXC
C         FOR A=NCNTR, SINCE THE ABOVE CODE IS NOT CORRECT IN THIS CASE.
C
          DEDFT(1,NCNTR)=DEDFT(1,NCNTR)+DEDFTGRADX
          DEDFT(2,NCNTR)=DEDFT(2,NCNTR)+DEDFTGRADY
          DEDFT(3,NCNTR)=DEDFT(3,NCNTR)+DEDFTGRADZ
         ENDIF
        ENDDO
C
      RETURN
      END
C*MODULE NEODFTGRD  *DECK DFTNUCGAO
C>    @brief Clone of DFTGAO 
C>         Computes values of nuclear gradient at grid point
C>
C>    @details THIS ROUTINE COMPUTES VALUES OF GRADIENT (DERIVATIVE BY THE
C>    ELECTRON COORDINATE) OF ALL AOS FOR A GRID POINT.
C>
C>    @date : December 21, 2012 - Joe Ivanic
C>            Modify IJX,IJY,IJZ to have dimension 84 for h,i cartesians
C
      SUBROUTINE DFTNUCGAO(IJX,IJY,IJZ,GVALAX,GVALAY,GVALAZ,ANGXVL,
     *                  ANGYVL,ANGZVL,CL,EXPS,RSQRD,NAT,L1,NEO)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL NEO
      PARAMETER (MXSH=5000, MXGTOT=20000, TWO=2.0D+00,RLN10=2.30258D+00)
      PARAMETER (MXGSH=30, MXG2=MXGSH*MXGSH, MXATM=2000)
      PARAMETER (MXAO=8192, MXNEO=30)
C
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /SHLNRM/ PNRM(84)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /NEOSHL/ NGAUSS,NGAUSE,NGAUSN,NTSHEL,NNUCSH
C
      DIMENSION GVALAX(L1),GVALAY(L1),GVALAZ(L1),ANGXVL(NAT,*)
      DIMENSION ANGYVL(NAT,*),ANGZVL(NAT,*)
      DIMENSION CL(*),RSQRD(*),EXPS(*)
      DIMENSION IJX(84),IJY(84),IJZ(84)

C
      TOL = RLN10*ITOL/TWO
C     THE SAME AS IN DFTAO.
C
      IFCT=0
      CALL VCLR(GVALAX,1,L1)
      CALL VCLR(GVALAY,1,L1)
      CALL VCLR(GVALAZ,1,L1)

      IF(NEO) THEN
        ISTART  = NSHELL+1
        IFINISH = NTSHEL
      ELSE
        ISTART  = 1
        IFINISH = NSHELL
      ENDIF


      DO 40 ISHELL = ISTART,IFINISH 
         IATM = KATOM(ISHELL)
C***********************************************************************
C     ANGULAR INTERMEDIATES FOR THE DENSITY AND GRADIENT
C***********************************************************************
         K1 = KSTART(ISHELL)
         K2 = K1 + KNG(ISHELL) - 1
         MINI=KMIN(ISHELL)
         MAXI=KMAX(ISHELL)
         LOCI = KLOC(ISHELL)-MINI
         LOCI0= KLOC(ISHELL)
         DO 60 IMOMFCT = K1, K2
            IFCT=IFCT+1
            TWOALP = EX(IMOMFCT)*TWO
            DUM=EX(IMOMFCT)*RSQRD(IATM)
            IF(DUM.GT.TOL) GOTO 60
            VEXP=EXPS(IFCT)
            CC=CL(IMOMFCT)
            LOCI1=LOCI0
            IF(MINI.EQ.1) THEN
C
C           SPECIAL FAST CODE FOR S FUNCTIONS (INCLUDING L SHELLS)
C
              DUM=CC*VEXP*TWOALP
              GVALAX(LOCI1)=GVALAX(LOCI1)-DUM*ANGXVL(IATM,3)
              GVALAY(LOCI1)=GVALAY(LOCI1)-DUM*ANGYVL(IATM,3)
              GVALAZ(LOCI1)=GVALAZ(LOCI1)-DUM*ANGZVL(IATM,3)
C             FOR L-SHELLS
              LOCI1=LOCI1+1
              CC=CP(IMOMFCT)
            ENDIF
            IF(MAXI.EQ.4) THEN
C
C           SPECIAL FAST CODE FOR P FUNCTIONS (INCLUDING L SHELLS)
C
               DUM=CC*TWOALP*VEXP
               DUM1=CC*VEXP
               XY=DUM*ANGXVL(IATM,3)*ANGYVL(IATM,3)
               XZ=DUM*ANGXVL(IATM,3)*ANGZVL(IATM,3)
               YZ=DUM*ANGYVL(IATM,3)*ANGZVL(IATM,3)
               GVALAX(LOCI1)=GVALAX(LOCI1)+DUM1-DUM*ANGXVL(IATM,4)
               GVALAY(LOCI1)=GVALAY(LOCI1)-XY
               GVALAZ(LOCI1)=GVALAZ(LOCI1)-XZ
               LOCI1=LOCI1+1
               GVALAX(LOCI1)=GVALAX(LOCI1)-XY
               GVALAY(LOCI1)=GVALAY(LOCI1)+DUM1-DUM*ANGYVL(IATM,4)
               GVALAZ(LOCI1)=GVALAZ(LOCI1)-YZ
               LOCI1=LOCI1+1
               GVALAX(LOCI1)=GVALAX(LOCI1)-XZ
               GVALAY(LOCI1)=GVALAY(LOCI1)-YZ
               GVALAZ(LOCI1)=GVALAZ(LOCI1)+DUM1-DUM*ANGZVL(IATM,4)
               LOCI1=LOCI1+1
            ENDIF
            IF(LOCI1.NE.LOCI0) GOTO 60
C
C           GENERAL CODE (WORKS FOR S,P,L FUNCTIONS AS WELL)
C           TO USE FOR L-FUNCTIONS, UNCOMMENT THE "C     L-SHELL" LINE
C
            DO 50 ITYP = MINI,MAXI
               IX=IJX(ITYP)-1
               IY=IJY(ITYP)-1
               IZ=IJZ(ITYP)-1
               DUM=CC*PNRM(ITYP)*VEXP
C
C              COMPUTE GRADIENT AO VALUE AT A GRID POINT
C              GRADIENT IS BY THE ELECTRON (NOT NUCLEAR) COORDINATES
C
               ANGYZVL=ANGYVL(IATM,IY+2)*ANGZVL(IATM,IZ+2)
               ANGZXVL=ANGZVL(IATM,IZ+2)*ANGXVL(IATM,IX+2)
               ANGXYVL=ANGXVL(IATM,IX+2)*ANGYVL(IATM,IY+2)
C***********************************************************************
C     GRADIENT MINUS ONE COMPONENT
C***********************************************************************
               ANGXM= IX*ANGXVL(IATM,IX+1)*ANGYZVL
               ANGYM= IY*ANGYVL(IATM,IY+1)*ANGZXVL
               ANGZM= IZ*ANGZVL(IATM,IZ+1)*ANGXYVL
C***********************************************************************
C     GRADIENT PLUS ONE COMPONENT
C***********************************************************************
               ANGXP= ANGXVL(IATM,IX+3)*ANGYZVL
               ANGYP= ANGYVL(IATM,IY+3)*ANGZXVL
               ANGZP= ANGZVL(IATM,IZ+3)*ANGXYVL
C
               LOCI0=LOCI+ITYP
               GVALAX(LOCI0) = GVALAX(LOCI0)+DUM*(ANGXM-TWOALP*ANGXP)
               GVALAY(LOCI0) = GVALAY(LOCI0)+DUM*(ANGYM-TWOALP*ANGYP)
               GVALAZ(LOCI0) = GVALAZ(LOCI0)+DUM*(ANGZM-TWOALP*ANGZP)
 50         CONTINUE
 60      CONTINUE
 40   CONTINUE
C
      RETURN
      END

