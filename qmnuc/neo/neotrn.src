C  7 MAR 12 - MWS - PAD DETWFN COMMON
C  8 Jul 11 - PEA - added mxneo parameter
C 30 SEP 06 - SPW - NEW MODULE FOR NEO AO TO MO INTEGRAL TRANSFORMATIONS
C
C*MODULE NEOTRN   *DECK NEOTRN
      SUBROUTINE NEOTRN(NPASS)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION METHOD
C
      PARAMETER (MXATM=2000)
      PARAMETER (MXNORO=250, MXRT=100, MXAO=8192, MXNEO=20)
C
      LOGICAL SOME,GOPARR,DSKWRK,MASWRK,DIRTRF,PACK2E
      LOGICAL DBUG
      LOGICAL CANONC,FCORE,FORS,NOCI,EKT,LINSER
      LOGICAL TRFSAV
C
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,S,SZ,
     *                GRPDET,STSYM,GLIST,DWPARM,
     *                NFLGDM(MXRT),IWTS(MXRT),NCORSV,NCOR,NACT,NORB,
     *                NA,NB,K,KST,IROOT,IPURES,MAXW1,NITER,MAXP,NCI,
     *                IGPDET,KSTSYM,NFTGCI,IDWEIGH
      COMMON /DETNEO/ WSTATE_NEO(MXRT),SPINS_NU(MXRT),CRIT_NU,
     *                PRTTOL_NEO,S_NU,SZ_NU,GRPDET_NU,STSYM_NU,
     *                NFLGDM_NEO(MXRT),IWTS_NU(MXRT),NCORSV_NU,
     *                NCOR_NU,NACT_NU,NORB_NU,NA_NU,NB_NU,
     *                K_NEO,KST_NEO,IROOT_NEO,IPURES_NEO,MAXW1_NEO,
     *                NITER_NEO,MAXP_NEO,NCI_NU,IGPDET_NU,KSTSYM_NU
      COMMON /FMCOM / X(1)
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NAINF,NBINF,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /MCINP / METHOD,CISTEP,ACURCY,ENGTOL,DAMP,MICIT,NWORD,
     *                NORBMC,NOROT(2,MXNORO),MOFRZ(15),NPFLG(10),
     *                NOFO,MCFMO,CANONC,FCORE,FORS,NOCI,EKT,LINSER
      COMMON /NEOSHL/ NGAUSS,NGAUSE,NGAUSN,NTSHEL,NNUCSH
CSPW  COMMON /NSHEL2/ NGAUSS,NGAUSE,NGAUSN,NTSHEL,NNUCSH
      COMMON /NUCMOI/ NUNIQN,IUNIQN(MXNEO),IUNIQT(MXNEO),NQMNUC,
     *                IQMNUC(MXNEO),IQNTYP(MXNEO),NUMNB,NUCST,NAUXNB,
     *                IAUXNB(MXNEO),NUMULT,NNA,NNB,NTAUXB
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCKLAB/ LABSIZ
      COMMON /TRFOPT/ CUTTRF,NWDTRF,MPTRAN,ITRFAO,NOSYMT,IPURTF,DIRTRF
C
      DATA ALDET/8HALDET   /
C
C     --- DRIVER TO DO NUCLEAR-NUCLEAR AND ELECTRON-NUCLEAR INTEGRAL 
C         TRANSFORMATIONS TO THEIR RESPECTIVE MO BASIS ---
C
      CISTEP = ALDET
C
      SOME = NPRINT.NE.-5 .AND. MASWRK .AND. NPASS.EQ.0
      DBUG = NPRINT.EQ. 4 .AND. MASWRK
C
C     --- MAY WANT TO DO DIRECT ELECTRONIC TRANSORMATION, BUT THIS
C         CODE NOT READY FOR NUC-NUC AND NUC-ELEC DIRECT TRANSFORMATIONS ---
C
      TRFSAV = DIRTRF
      DIRTRF = .FALSE.
C
C     --- INITIALIZE ELECTRONIC CI VARIABLES ---
C
C     - ELECTRONIC BASIS FUNCTIONS
CSPW  L0 = NQMT
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
C
      NFZC = 0
C
      NACT2 = (NACT*NACT+NACT)/2
C
C     --- NOW INITIALIZE NUCLEAR CI VARIABLES ---
C
C     - NUCLEAR BASIS FUNCTIONS
      N1 = NUMNB
      N2 = (N1*N1+N1)/2
      N3 = N1*N1
C
      NACT2_NU = (NACT_NU*NACT_NU+NACT_NU)/2
C
C     --- PREPARE FOR TRANSFORMATIONS INVOLVING QM NUCLEI ---
C
      NNAOS  = 68   ! NUC-NUC AO INTEGRALS
      NNIJKT = 69   ! NUC-NUC MO INTEGRALS
      NNPTF  = 70   ! NUC-NUC PARTIALY TRANFORMED INTEGRALS
      NEAOS  = 67   ! NUC-ELEC AO INTEGRALS
      NEIJKT = 71   ! NUC-ELEC MO INTEGRALS
      NEPTF  = 72   ! NUC-ELEC PARTIALLY TRANSFORMED INTEGRALS
C
      IF (NPASS.EQ.0) THEN
         CALL SEQOPN(NNIJKT,'NUMOIN','UNKNOWN',.FALSE.,'UNFORMATTED')
         CALL SEQOPN(NNPTF,'NUMOCAS','UNKNOWN',.FALSE.,'UNFORMATTED')
         CALL SEQOPN(NEIJKT,'NUELMO','UNKNOWN',.FALSE.,'UNFORMATTED')
         CALL SEQOPN(NEPTF,'NUELCAS','UNKNOWN',.FALSE.,'UNFORMATTED')
      END IF
C
C     --- PREPARE FOR TRANSFORMATIONS ---
C     --- ORTHONORMALIZE NUCLEAR MOS AND ASSIGN SYMMETRY ---
C
      CALL TRPREP(NOSYMT,N1,N1,N2,N3,IA,NORB_NU)
C
      CALL VALFM(LOADFM)
      LHNMO = LOADFM + 1
      LAST  = LHNMO  + N2
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      IF(NA_NU.EQ.1 .AND. NB_NU.EQ.0) THEN
C
C        --- FOR SINGLE NUCLEUS ONLY NEED TO TRANSFORM ONE-NUC HAM ---
C
         IF(SOME) WRITE(IW,9988)
         IF (SOME) WRITE(IW,9010)
C
         CALL VALFM(LOADFM)
         LH1N  = LOADFM + 1
         LH1NMO= LH1N   + N2
         LNVEC = LH1NMO + N2
         LWRK  = LNVEC  + N3
         LAST  = LWRK   + N3
         NEED2 = LAST - LOADFM - 1
         CALL GETFM(NEED2)
C
         CALL DAREAD(IDAF,IODA,X(LH1N),N2,440,0)
         CALL DAREAD(IDAF,IODA,X(LNVEC),N3,444,0)
         CALL TFTRI(X(LH1NMO),X(LH1N),X(LNVEC),X(LWRK),NORB_NU,N1,N1)
         CALL DAWRIT(IDAF,IODA,X(LH1NMO),N2,459,0)
C
         CALL RETFM(NEED2)
C
      ELSE
C
C        --- TRANSFORMATION OF 1- AND 2-NUCLEUS INTEGRALS TO MO BASIS ---
C
         IF(SOME) WRITE(IW,9988)
         IF (DIRTRF) THEN
            IF (SOME) WRITE(IW,9020)
         ELSE
            IF (SOME) WRITE(IW,9030)
         END IF
C
         CALL TSECND(T0)
         CALL NN_CASTRF(.FALSE.,SOME,DBUG,IA,
     *        NFZC,NACT_NU,NCORSV_NU,N1,N2,N3,NOSYMT,
     *        NNAOS,NNIJKT,NNPTF,DIRTRF,NINTMX,LABSIZ,
     *        NACT_NU,NACT2_NU,NNUCSH,NCORSV_NU,MPTRAN,CUTTRF,T0,
     *        L1)
C
      END IF
C
C     --- TRANSFORMATION OF ELECTRON-NUCLEAR INTEGRALS TO MO BASIS ---
C
      IF(SOME) WRITE(IW,9999)
      IF (DIRTRF) THEN
         IF (SOME) WRITE(IW,9040)
      ELSE
         IF (SOME) WRITE(IW,9050)
      END IF
C
      CALL TSECND(T0)
      CALL NE_CASTRF(.FALSE.,SOME,DBUG,IA,
     *               NFZC,N1,N2,N3,NOSYMT,
     *               NEAOS,NEIJKT,NEPTF,DIRTRF,NINTMX,LABSIZ,
     *               NACT_NU,NACT2_NU,NNUCSH,NCORSV,
     *               MPTRAN,CUTTRF,T0,L1,L2,L3,
     *               NACT,NACT2,NACT_NU,X(LHNMO))
C
C     --- WRITE MODIFICATION OF 1-NUC MO INTS DUE TO FROZEN
C         CORE ELECTRONS TO DAF
C
      IF(NCORSV.GT.0) CALL DAWRIT(IDAF,IODA,X(LHNMO),N2,460,0)
C
C     --- RESTORE ORIGINAL DIRTRF ---
C
      DIRTRF = TRFSAV 
C
      CALL RETFM(NEED)
C
      RETURN
C
 9010 FORMAT(/,1X,'ONLY TRANSFORMATION OF 1-NUCLEUS HAMILTONIAN', 
     &       ' REQUIRED ...')
 9020 FORMAT(1X,'NUC AO INTEGRALS WILL BE CALCULATED IN DIRECT MODE...')
 9030 FORMAT(/,1X,'NUC AO INTEGRALS WILL BE READ IN FROM DISK...')
 9040 FORMAT(1X,'NUC-ELEC AO INTEGRALS WILL BE CALCULATED IN',
     &       ' DIRECT MODE...')
 9050 FORMAT(/,1X,'NUC-ELEC AO INTEGRALS WILL BE READ IN FROM DISK...')
 9988 FORMAT(/,5X,39('-'),
     1       /,5X,'NUCLEAR-NUCLEAR INTEGRAL TRANSFORMATION',
     2       /,5X,39('-'))
 9999 FORMAT(/,5X,40('-'),
     1       /,5X,'ELECTRON-NUCLEAR INTEGRAL TRANSFORMATION',
     2       /,5X,40('-'))
      END
C*MODULE NEOTRN  *DECK NN_CASTRF
      SUBROUTINE NN_CASTRF(DOEXCH,
     *                     SOME,DBUG,IA,NFZC,NACT,
     *                     NCORSV,L1,L2,L3,NOSYMT,IJKO,IJKT,NFT13,
     *                     DIRTRF,NINTMX,LABSIZ,NCI,NCI2,NSHELL,MCORBS,
     *                     MPTRAN,CUTTRF,T0,L1EL)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL DOFOCK,DOEXCH,TWOSTP,ABEL,ABELPT,pack2e
      LOGICAL MASWRK,DSKWRK,GOPARR,DIRTRF
      LOGICAL SOME,DBUG
C
      PARAMETER (MXAO=8192)
      PARAMETER (MXSH=5000, MXGSH=30, MXG2=MXGSH*MXGSH,
     *           MXATM=2000)
C
      COMMON /FMCOM / X(1)
      COMMON /INTFIL/ NINTMXx,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /IOFILE/ IR,IW,IP,IJKX,IJKY,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                TSYM(432),INVT(48),NT
      COMMON /INT2IC/ NINTIC,ININTIC,NXXIC,LBUFPIC,LIXIC,LABSIX,NINTIX
C
      DIMENSION IA(MXAO)
      DIMENSION IX(1)
      EQUIVALENCE (IX(1),X(1))
C
      PARAMETER (ZERO=0.0D+00)
C
      DATA DOFOCK/.TRUE./
      DATA CHECK/8HCHECK   /
C
C     --- SPECIAL INTEGRAL TRANSFORMATION FOR FIRST-ORDER CASSCF PROGRAM ---
C
      DO 10 I=1,MXAO
   10 IA(I) = (I*I-I)/2
C
C     --- SET ORBITAL SPACE PARAMETERS SHOULD BE PASSED IN ---
C     MORB = TOTAL VARIATION SPACE, USUALLY THE FULL BASIS SET
C     MORBS = TOTAL OCCUPIED, INCLUDING CORE
C     MCORBS = NUMBER OF CORE ORBITALS
C     NQMT = NUMBER OF LINEARLY INDEPENDENT ORBITALS
C     NCI = NUMBER OF ACTIVE ORBITALS
C
      NFZC = 0
C
C     --- NO NUCLEAR FROZEN CORES ARE ALLOWED - JUST SET TO ZERO HERE
C            AND LEAVE CODE INTACT IN CASE THEY ARE ADDED IN THE FUTURE--
C
      ECORE = ZERO
C
      CALL GOTFM(NGOTMX)
C
C     ---- OPTION TO DEFEAT SYMMETRY USAGE ----
C
      ABEL=ABELPT()
      IF(NOSYMT.EQ.1) CALL SYMOFF
C
CSPW NO SYMMETRY YET
      NT = 1
C
      NTSAVE = NT
      IF(DIRTRF .AND. .NOT.ABEL) NT=1
C
      CALL VALFM(LOADFM)
      LVEC   = LOADFM + 1
      LMOIRP = LVEC   + L3
      LMOLAB = LMOIRP + L1
C
C     ----- TRANSFORM 2-NUC INTEGRALS AND FORM FOCK CORE OPERATOR -----
C
      LEN = L2*NCI2
C
      LWRK  = LMOLAB
      LXBUF = LWRK   + L2
      LIXBUF= LXBUF  + NINTMX
      LJFLG = LIXBUF + NINTMX
      I03   = LJFLG  + NPROC
      LDEN  = I03    + LEN
      LFCK  = LDEN   + L2
      I06   = LFCK   + L2
C  THE NEXT TWO ARE USED AS INTEGRAL BUFFERS
      I07   = I06    + MAX(L2,NINTMX)
      LAST  = I07    + MAX(L2,NINTMX*LABSIZ)
      I06A=I06
      I07A=I07
      IF(NINTIC.NE.0) THEN
         I06A=LBUFPIC
         I07A=LIXIC
      ENDIF
C     IN THE ABOVE MEMORY ALLOCATION NINTMX SHOULD BE USE (NOT MINTMX).

C
C     ----- MEMORY FOR DIRECT CASSCF -----
C
CSPW  IVEC = LVEC+MCORBS*L1
CSPW  IDEN = LDEN
CSPW  IFCK = LFCK
C
      IF (DIRTRF) THEN
         CALL BASCHK(LMAX)
                       NANGM =  4
         IF(LMAX.EQ.2) NANGM =  6
         IF(LMAX.EQ.3) NANGM = 10
         IF(LMAX.EQ.4) NANGM = 15
         MAXG = NANGM**4
         NSH2   = (NSHELL*NSHELL+NSHELL)/2
         LGHND  = LAST
         LXINTS = LGHND  + MAXG
         LDDIJ  = LXINTS + NSH2
         LAST   = LDDIJ  + 16*MXG2
      ELSE
         MAXG   = 1
         NSH2   = 1
         LGHND  = LAST
         LXINTS = LAST
         LDDIJ  = LAST
      END IF
      I08  = LAST
C
      NEEDS1= LWRK - LOADFM
      NEED1 = LDEN - LWRK
      NEED2 = LAST - LDEN
      NEED  = NEEDS1+NEED1+NEED2
C
      IF(NEED.GT.NGOTMX) THEN
         IF (MASWRK) WRITE(IW,9998) NEED-NGOTMX
         CALL ABRT
      END IF
C
      CALL GETFM(NEEDS1)
      CALL GETFM(NEED1)
      CALL GETFM(NEED2)
C
      IF(SOME) CALL TSECND(T1)
C
      CALL DAREAD(IDAF,IODA,X(LVEC),L3,444,0)
C
C     ---- GENERATE EXCHANGE INTEGRALS FOR SCHWARZ SCREENING ----
C
      IF(DIRTRF) THEN
         IF(EXETYP.EQ.CHECK) THEN
            CALL VCLR(X(LXINTS),1,NSH2)
         ELSE
            IF(DOEXCH) THEN
               CALL EXCHNG(X(LXINTS),X(LGHND),X(LDDIJ),NSH2,MAXG,INTTYP)
            ELSE
               CALL DAREAD(IDAF,IODA,X(LXINTS),NSH2,54,0)
            END IF
        END IF
      END IF
C
      CALL VCLR(X(I03),1,LEN)
C
      LEFT=NGOTMX-NEED
      NMIN=L1*NCI
      IF(LEFT.LT.NMIN) THEN
         NEED3 = 0
         GO TO 100
      END IF
C
C     ----- THREE STEP TRANSFORMATION ( -L- , -K- , AND -IJ- ) -----
C
      LPASS=MIN(LEFT/NMIN,L2)
      IF(LPASS.LT.L2) THEN
         LEFT = LEFT - LPASS*NCI2
         LPASS = LEFT/NMIN
      END IF
      NPASS=(L2-1)/LPASS+1
      IF (GOPARR) NPASS = ((NPASS-1+NPROC)/NPROC)*NPROC
      LPASS=(L2-1)/NPASS+1
      NEED3=NMIN*LPASS
      IF (SOME  .AND.  LPASS.LT.L2) THEN
        WRITE(IW,9991) NEED+L2*NMIN
      ENDIF
C
C     ----- ONE PASS ONLY NEEDED ----
C
      IF(LPASS.EQ.L2.AND.MPTRAN.EQ.0) THEN
         NEED=NEED+NEED3
         CALL GETFM(NEED3)
         IF(SOME) WRITE(IW,9995) NEED,NGOTMX,NPASS
C
         IF (EXETYP.EQ.CHECK) THEN
            CALL RETFM(NEED3)
            GO TO 250
         END IF
         CALL CASTR3(X(I03),X(I08),X(LFCK),X(LWRK),X(LVEC),X(LDEN),
     *               X(I06),X(I07),X(I06A),X(I07A),L2,L1,MCORBS,NCI,
     *               IJKO,NFT13,CUTTRF,NPQKL,ECORE,DOFOCK,
     *               X(LJFLG),X(LGHND),X(LXINTS),X(LDDIJ),MAXG,NSH2)
         CALL RETFM(NEED3)
C
C     -----             SEVERAL PASSES NEEDED                    -----
C     ----- IT MAY BE BETTER TO SWITCH TO THE TWO-STEP ALGORITHM -----
C     PARALLEL RUNS MUST EXECUTE THE THREE STEPS ALGORITHM, ALWAYS.
C     SEQUENTIAL RUNS MIGHT BE BETTER OFF DOING THE TWO STEPS
C     ALGORITHM IF THERE ARE MANY PASSES (MUCH DISK I/O) OR IF THE
C     AO INTEGRALS ARE DIRECT (MUCH COMPUTATION ON EACH PASS).
C
      ELSE
         TWOSTP = MPTRAN.EQ.2  .OR.  DIRTRF  .OR.  NPASS.GT.MAX(NCI,10)
         IF(TWOSTP  .AND.  .NOT.GOPARR) GO TO 100
         NEED=NEED+NEED3
         CALL GETFM(NEED3)
         LDIM = I08 + NEED3
         NEED4 = LPASS*NCI2
         NEED = NEED + NEED4
         CALL GETFM(NEED4)
         IF(SOME) WRITE(IW,9995) NEED,NGOTMX,NPASS
         IF (EXETYP.EQ.CHECK) THEN
            CALL RETFM(NEED4)
            CALL RETFM(NEED3)
            GO TO 250
         END IF
         CALL CASTR4(X(I03),X(I08),X(LFCK),X(LWRK),X(LVEC),X(LDEN),
     *               X(I06),X(I07),X(I06A),X(I07A),
     *               X(LDIM),X(LJFLG),L2,L1,MCORBS,NCI,
     *               LPASS,NPASS,IJKO,NFT13,CUTTRF,NPQKL,ECORE,
     *               X(LGHND),X(LXINTS),X(LDDIJ),MAXG,NSH2,SOME)
         CALL RETFM(NEED4)
         CALL RETFM(NEED3)
      END IF
      GO TO 200
C
C     --- TWO STEP TRANSFORMATION ( COMBINED -KL- , AND -IJ- LATER ) ---
C
  100   CONTINUE
        IF(SOME) WRITE(IW,9993) NEED,NGOTMX
        IF (EXETYP.EQ.CHECK) GO TO 250
        CALL CASTR1(X(I03),X(LFCK),X(LWRK),X(LVEC),X(LDEN),X(I06),
     *              X(I07),X(I06A),X(I07A),L2,L1,MCORBS,NCI,IJKO,NFT13,
     *              CUTTRF,NPQKL,ECORE,X(LJFLG),
     *              X(LGHND),X(LXINTS),X(LDDIJ),MAXG,NSH2)
C
C     ----- TRANSFORM ONE NUCLEUS INTEGRALS -----
C     --- LDEN STORES 1-NUCLEUS HAM FOR NOW
C
  200 CONTINUE
C
      DO 50 I=0,L1*NCI-1
         X(LVEC+I)=X((LVEC+MCORBS*L1)+I)
   50 CONTINUE 
C
      CALL DAREAD(IDAF,IODA,X(LDEN),L2,440,0)
      CALL TR1N(X(LDEN),X(LFCK),X(LVEC),X(I06),L1,NCI,IJKT,
     *          DBUG,L1EL)
C
  250 CONTINUE
      CALL RETFM(NEED2)
      IF(SOME) THEN
         CALL TSECND(T2)
CSPW     WRITE(IW,8000) ENUCR,ECORE,T1-T0,T2-T1
         WRITE(IW,8000) T1-T0,T2-T1
      END IF
C
C     ----- FINISH 2-NUCLEAR INTEGRALS TRANSFORMATION -----
C
      SOME=DBUG.OR.SOME
C
C     ----- TRANSFORM (PQ|KL) -> (IJ|KL) -----
C
      LFCK=LDEN+L1*NCI
      I06=LFCK+L3
      I07=I06+L3
      I08=I07+L2
      LAST2 = I08+L2
      NEED2 = LAST2- LDEN
      CALL GETFM(NEED2)
      IF(DBUG) WRITE(IW,9996)
      IF (EXETYP.EQ.CHECK) GO TO 400
C
      CALL DAREAD(IDAF,IODA,X(LMOIRP),L1,453,1)
      CALL NN_CASTR2(X(I03),X(LFCK),X(I06),X(I07),
     *     X(I08),X(LVEC),X(LDEN),
     *     L2,L1,IJKT,CUTTRF,DBUG,NO,X(LXBUF),X(LIXBUF),.TRUE.,
     *     NCORSV,NACT,NACT,L1)
C
C     ----- ALL IS DONE -----
C
  400 CONTINUE
      CALL RETFM(NEED2)
      CALL RETFM(NEED1)
      CALL RETFM(NEEDS1)
      CALL SEQREW(IJKT)
      IF (.NOT. DIRTRF) CALL SEQREW(IJKO)
      IF(SOME) THEN
         IF(EXETYP.NE.CHECK) THEN
            CALL TSECND(T3)
            WRITE(IW,8020) T3-T2
            WRITE(IW,9992) NPQKL,NO
         END IF
         WRITE(IW,*) '.... END OF 2-NUC INTEGRAL TRANSFORMATION ....'
         CALL TIMIT(1)
      END IF
C
      NT = NTSAVE
      IF(NOSYMT.EQ.1) CALL SYMON
      RETURN
C
 9996 FORMAT(/' TRANSFORMED 2-NUC INTEGRALS')
 9998 FORMAT(/' NOT ENOUGH CORE TO TRANSFORM THE 2E- INTEGRALS'/
     *        ' INCREASE CORE BY AT LEAST ',I10,' WORDS')
 9991 FORMAT(1X,'MEMORY WHICH WOULD BE NEEDED FOR SINGLE PASS',
     *          ' TRANSFORMATION = ',I10)
 9995 FORMAT(/1X,'----- CHOOSING THREE STEPS TRANSFORMATION -----'/
     1        1X,'NUMBER OF WORDS USED      = ',I10/
     2        1X,'NUMBER OF WORDS AVAILABLE = ',I10/
     *        1X,'NUMBER OF PASSES          = ',I10)
 9993 FORMAT(/1X,'----- CHOOSING TWO STEPS TRANSFORMATION -----'/
     1        1X,'NUMBER OF WORDS USED      = ',I10/
     2        1X,'NUMBER OF WORDS AVAILABLE = ',I10)
 9992 FORMAT(/1X,'NUMBER OF (PQ|KL) INTEGRALS WRITTEN ',I10/
     1        1X,'NUMBER OF (IJ|KL) INTEGRALS WRITTEN ',I10)
C8000 FORMAT(/1X,'----- NUCLEAR REPULSION ENERGY = ',F15.8/
C    1        1X,'----- FROZEN CORE ENERGY       = ',F15.8//
C    2        1X,'... SYMMETRY ...           CPU =',F8.2/
C    3        1X,'... (PQ|RS) -> (PQ|KL) ... CPU =',F8.2)
 8000 FORMAT(/1X,'... SYMMETRY ...           CPU =',F8.2/
     2        1X,'... (PQ|RS) -> (PQ|KL) ... CPU =',F8.2)
 8020 FORMAT(1X,'... (PQ|KL) -> (IJ|KL) ... CPU =',F8.2)
      END
C
C*MODULE NEOTRN  *DECK PUTINT
      SUBROUTINE PUTINT(IARRAY,LL)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION IARRAY(LL)
C
      DO I=1,LL
         IARRAY(I) = 1
      END DO
C
      RETURN
      END
C
C*MODULE NEOTRN  *DECK NE_CASTRF
      SUBROUTINE NE_CASTRF(DOEXCH,
     *                     SOME,DBUG,IA,NFZC,
     *                     N1,N2,N3,NOSYMT,IJKO,IJKT,NFT13,
     *                     DIRTRF,NINTMX,LABSIZ,NCI,NCI2,NSHELL,MCORBS,
     *                     MPTRAN,CUTTRF,T0,L1,L2,L3,
     *                     NCIEL,NCIEL2,NACT_NU,HNMO)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL DOFOCK,DOEXCH,ABEL,ABELPT,pack2e
      LOGICAL MASWRK,DSKWRK,GOPARR,DIRTRF
      LOGICAL SOME,DBUG
C
      PARAMETER (MXAO=8192)
      PARAMETER (MXGSH=30, MXG2=MXGSH*MXGSH)
C
      COMMON /FMCOM / X(1)
      COMMON /INTFIL/ NINTMXx,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /IOFILE/ IR,IW,IP,IJKX,IJKY,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      DIMENSION IA(MXAO),HNMO(*)
      DIMENSION IX(1)
      EQUIVALENCE (IX(1),X(1))
C
CSPW  PARAMETER (ZERO=0.0D+00)
C
      DATA DOFOCK/.TRUE./
      DATA CHECK/8HCHECK   /
C
C     --- SPECIAL INTEGRAL TRANSFORMATION FOR FIRST-ORDER CASSCF PROGRAM ---
C     ----- TRANSFORM 2E-INTEGRALS AND FORM FOCK CORE OPERATOR -----
C
      DO 10 I=1,MXAO
   10 IA(I) = (I*I-I)/2
C
C     --- SET ORBITAL SPACE PARAMETERS SHOULD BE PASSED IN ---
C     MORB = TOTAL VARIATION SPACE, USUALLY THE FULL BASIS SET
C     MORBS = TOTAL OCCUPIED, INCLUDING CORE
C     MCORBS = NUMBER OF CORE ORBITALS
C     NQMT = NUMBER OF LINEARLY INDEPENDENT ORBITALS
C     NCI = NUMBER OF ACTIVE ORBITALS
C
      NFZC = 0
C
      MX2 = MAX(L2,N2)
      LEN = MAX(L2,N2)*MAX(NCIEL2,NCI2)
C
      CALL GOTFM(NGOTMX)
C
C        ---- OPTION TO DEFEAT SYMMETRY USAGE ----
C
      ABEL=ABELPT()
      IF(NOSYMT.EQ.1) CALL SYMOFF
C
CSPW NO SYMMETRY YET
      NT = 1
C
      NTSAVE = NT
      IF(DIRTRF .AND. .NOT.ABEL) NT=1
C

      CALL VALFM(LOADFM)
      LVECE  = LOADFM + 1
      LVECN  = LVECE  + L3
      LMOIRP = LVECN  + N3
      LMOLAB = LMOIRP + MAX(L1,N1)
      LAST   = LMOLAB + MAX(L1,N1)
      NEEDS1 = LAST - LOADFM
C
      LWRK  = LAST 
      LXBUF = LWRK   + MAX(L2,N2)
      LIXBUF= LXBUF  + NINTMX
      LJFLG = LIXBUF + NINTMX
      I03   = LJFLG  + NPROC
      LAST  = I03    + LEN
      NEED1 = LAST - LWRK
C
      LDEN  = LAST
      LFCK  = LDEN   + MAX(L2,N2)
      LFN   = LFCK   + MAX(L2,N2)
      I06   = LFN    + MAX(L2,N2)
C  THE NEXT TWO ARE USED AS INTEGRAL BUFFERS
      I07   = I06    + MAX(MX2,NINTMX)
      LAST  = I07    + MAX(MX2,NINTMX*LABSIZ)
C
C     ----- MEMORY FOR DIRECT CASSCF -----
C
      IF (DIRTRF) THEN
         CALL ABRT
         CALL BASCHK(LMAX)
                       NANGM =  4
         IF(LMAX.EQ.2) NANGM =  6
         IF(LMAX.EQ.3) NANGM = 10
         IF(LMAX.EQ.4) NANGM = 15
         MAXG = NANGM**4
         NSH2   = (NSHELL*NSHELL+NSHELL)/2
         LGHND  = LAST
         LXINTS = LGHND  + MAXG
         LDDIJ  = LXINTS + NSH2
         LAST   = LDDIJ  + 16*MXG2
      ELSE
         MAXG   = 1
         NSH2   = 1
         LGHND  = LAST
         LXINTS = LAST
         LDDIJ  = LAST
      END IF
      I08  = LAST
      NEED2  = LAST - LDEN
C
      NEED   = NEEDS1 + NEED1 + NEED2
C
      IF(NEED.GT.NGOTMX) THEN
         IF (MASWRK) WRITE(IW,9998) NEED - NGOTMX
         CALL ABRT
      END IF
C
      CALL GETFM(NEEDS1)
      CALL GETFM(NEED1)
      CALL GETFM(NEED2)
C
      IF(SOME) CALL TSECND(T1)
C
C     ---- GET ELECTRONIC AND NUCLEAR MOLECULAR ORBITALS ----
C
      CALL DAREAD(IDAF,IODA,X(LVECE),L3,15,0)
      CALL DAREAD(IDAF,IODA,X(LVECN),N3,444,0)
C
C     ---- GENERATE EXCHANGE INTEGRALS FOR SCHWARZ SCREENING ----
C
      IF(DIRTRF) THEN
         IF(EXETYP.EQ.CHECK) THEN
            CALL VCLR(X(LXINTS),1,NSH2)
         ELSE
            IF(DOEXCH) THEN
               CALL EXCHNG(X(LXINTS),X(LGHND),X(LDDIJ),NSH2,MAXG,INTTYP)
            ELSE
               CALL DAREAD(IDAF,IODA,X(LXINTS),NSH2,54,0)
            END IF
        END IF
      END IF
C
      CALL VCLR(X(I03),1,LEN)
C
      LEFT = NGOTMX - NEED
      NMIN = MAX(L1,N1)*MAX(NCI,NCIEL)
      IF(LEFT.LT.NMIN) THEN
         NEED3 = 0
         WRITE(6,*) 'TWO STEP TRANS NOT IMPLEMENTED'
         CALL ABRT
C        GO TO 100
      END IF
C
C     ----- THREE STEP TRANSFORMATION ( -L- , -K- , AND -IJ- ) -----
C
      NNM = MAX(L2,N2)
      LPASS = MIN(LEFT/NMIN,NNM)
      IF(LPASS.LT.NNM) THEN
         LEFT = LEFT - LPASS*MAX(NCI2,NCIEL2)
         LPASS = LEFT/NMIN
      END IF
      NPASS = (NNM-1)/LPASS+1
      IF (GOPARR) NPASS = ((NPASS-1+NPROC)/NPROC)*NPROC
      LPASS = (NNM-1)/NPASS+1
      NEED3 = NMIN*LPASS
      IF (SOME  .AND.  LPASS.LT.NNM) THEN
        WRITE(IW,9991) NEED+NNM*NMIN
      ENDIF
C
C     ----- ONE PASS ONLY NEEDED ----
C
      IF(LPASS.EQ.NNM.AND.MPTRAN.EQ.0) THEN
         NEED = NEED + NEED3
         CALL GETFM(NEED3)
         IF(SOME) WRITE(IW,9995) NEED,NGOTMX,NPASS
         IF (EXETYP.EQ.CHECK) THEN
            CALL RETFM(NEED3)
            GO TO 250
         END IF
C
C        --- TRANSFROM ELECTRONIC PART --- 
C
         CALL NE_CASTR3(X(I03),X(I08),X(LFCK),X(LWRK),X(LVECE),
     *               X(LDEN),X(I06),X(I07),N2,L1,MCORBS,NCIEL,IJKO,
     *               NFT13,CUTTRF,NPQKL,DOFOCK,
     *               X(LJFLG),X(LGHND),X(LXINTS),X(LDDIJ),MAXG,NSH2,
     *               X(LFN),X(LVECN),HNMO,N1,NACT_NU)
         CALL RETFM(NEED3)
C
C     -----             SEVERAL PASSES NEEDED                    -----
C
      ELSE
C
         WRITE(6,*)'MULTIPLE PASS NUC-ELEC TRANS NOT IMPLEMENTED'
         CALL ABRT
C
      END IF
C
  250 CONTINUE
C
      CALL RETFM(NEED2)
C
      IF(SOME) THEN
         CALL TSECND(T2)
         WRITE(IW,8000) T1-T0,T2-T1
      END IF
C
C     ----- FINISH 2E-INTEGRALS TRANSFORMATION -----
C
      SOME=DBUG.OR.SOME
C
C     ----- TRANSFORM (PQ|KL) -> (IJ|KL) -----
C
      CALL VALFM(LOADFM)
      LDEN  = LOADFM + 1
      LFCK  = LDEN + MAX(L1,N1)*MAX(NCI,NCIEL)
      I06   = LFCK + MAX(L3,N3)
      I07   = I06  + MAX(L3,N3)
      I08   = I07  + MAX(L2,N2)
      LAST2 = I08  + MAX(L2,N2)
C
      NEED2 = LAST2- LOADFM
      CALL GETFM(NEED2)
C
      IF(DBUG) WRITE(IW,9996)
      IF (EXETYP.EQ.CHECK) GO TO 400
C
      CALL DAREAD(IDAF,IODA,X(LMOIRP),N1,453,1)
      CALL NE_CASTR2(X(I03),X(LFCK),X(I06),X(I07),
     *     X(I08),X(LVECN),X(LDEN),
     *     N2,N1,IJKT,CUTTRF,DBUG,NO,X(LXBUF),X(LIXBUF),
     *     0,NACT_NU,NACT_NU,N1,NCIEL)
C
C     ----- ALL IS DONE -----
C
  400 CONTINUE
      CALL RETFM(NEED2)
      CALL RETFM(NEED1)
      CALL RETFM(NEEDS1)
      CALL SEQREW(IJKT)
      IF (.NOT. DIRTRF) CALL SEQREW(IJKO)
      IF(SOME) THEN
         IF(EXETYP.NE.CHECK) THEN
            CALL TSECND(T3)
            WRITE(IW,8020) T3-T2
            WRITE(IW,9992) NPQKL,NO
         END IF
         WRITE(IW,*) '.... END OF NUC-ELEC INTEGRAL TRANSFORMATION ....'
         CALL TIMIT(1)
      END IF
C
      NT = NTSAVE
      IF(NOSYMT.EQ.1) CALL SYMON
      RETURN
C
 9998 FORMAT(/' NOT ENOUGH CORE TO TRANSFORM THE 2E- INTEGRALS'/
     *        ' INCREASE CORE BY AT LEAST ',I10,' WORDS')
 9996 FORMAT(/' TRANSFORMED EL-NUC INTEGRALS (I(EL)J(EL)|K(NUC)L(NUC))')
 9991 FORMAT(1X,'MEMORY WHICH WOULD BE NEEDED FOR SINGLE PASS',
     *          ' TRANSFORMATION = ',I10)
 9995 FORMAT(/1X,'----- CHOOSING THREE STEPS TRANSFORMATION -----'/
     1        1X,'NUMBER OF WORDS USED      = ',I10/
     2        1X,'NUMBER OF WORDS AVAILABLE = ',I10/
     *        1X,'NUMBER OF PASSES          = ',I10)
 9992 FORMAT(/1X,'NUMBER OF (PQ|KL) INTEGRALS WRITTEN ',I10/
     1        1X,'NUMBER OF (IJ|KL) INTEGRALS WRITTEN ',I10)
 8000 FORMAT(/1X,'... SYMMETRY ...           CPU =',F8.2/
     2        1X,'... (PQ|RS) -> (PQ|KL) ... CPU =',F8.2)
 8020 FORMAT(1X,'... (PQ|KL) -> (IJ|KL) ... CPU =',F8.2)
      END
C
C*MODULE NEOTRN  *DECK NE_CASTR3
      SUBROUTINE NE_CASTR3(XPQKL,XPQRJ,F,WRK,C,D,XX,IX,NUM2,NUM,NCORB,
     *                     NCI,IJK,NFT,TOL,NPQKL,DOFOCK,
     *                     JFLG,GHONDO,XINTS,DDIJ,MAXG,NSH2,FN,CN,
     *                     HNMO,N1,NACT_NU)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL DOFOCK,MASWRK,DSKWRK,GOPARR
C
      DIMENSION XPQKL(NUM2,*),XPQRJ(NCI,NUM2,*)
      DIMENSION C(NUM,*),F(*),WRK(*),D(*),XX(*),IX(*),
     *          JFLG(0:NPROC-1),GHONDO(MAXG),XINTS(NSH2),DDIJ(*)
      DIMENSION FN(*),CN(*),HNMO(*)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ZERO=0.0D+00)
C
      CALL NE_TR1MC(XPQRJ,F,WRK,C,C(1,NCORB+1),D,XX,IX,JFLG,NPROC,
     *           NUM2,NUM,NCORB,NCI,IJK,DOFOCK,
     *           GHONDO,XINTS,DDIJ,MAXG,NSH2,FN,CN,HNMO,N1,NACT_NU)
C
C     ----- TRANSFORM SECOND INDEX: (PQ|RL) -> (PQ|KL) -----
C
      DO 120 MPQ=1,NUM2
         MKL=0
         DO 120 MK=1,NCI
            DO 100 MR=1,NUM
  100          XX(MR)=XPQRJ(MK,MPQ,MR)
            DO 120 ML=1,MK
               MKL=MKL+1
               DUM=ZERO
               DO 110 MR=1,NUM
  110             DUM=DUM+C(MR,NCORB+ML)*XX(MR)
  120          XPQKL(MPQ,MKL)=DUM
C
C     ----- SAVE (PQ|KL) INTEGRALS FOR MICROITERATIONS -----
C
      NCI2=(NCI*(NCI+1))/2
      NPQKL=0
      CALL SEQREW(NFT)
      DO 140 MKL=1,NCI2
         CALL DCOPY(NUM2,XPQKL(1,MKL),1,XX,1)
         CALL TRFWTM(NFT,XX,NUMX,IX,IXNUM,NUM2,1,TOL)
  140    NPQKL=NPQKL+NUMX
C
      RETURN
      END
C*MODULE NEOTRN  *DECK NE_TR1MC
      SUBROUTINE NE_TR1MC(XPQRJ,F,WRK,C,CO,D,XX,IX,JFLG,NCPU,
     *                 NDIM,NUM,NCORB,NOC,IJK,
     *                 DOFOCK,GHONDO,XINTS,DDIJ,MAXG,NSH2,
     *                 FN,CN,HNMO,N1,NACT_NU)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL PACK2E,GOPARR,DSKWRK,MASWRK,DOFOCK,DIRTRF
C
      DIMENSION XPQRJ(NOC,NDIM,*),F(*),C(NUM,*),CO(NUM,*),D(*),WRK(*),
     *          XX(*),IX(*),JFLG(0:NCPU-1),
     *          GHONDO(MAXG),XINTS(NSH2),DDIJ(*),CN(*),FN(*)
      DIMENSION HNMO(*)
C
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /DIRCAS/ I2CASE
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /TRFOPT/ CUTTRF,NWDTRF,MPTRAN,ITRFAO,NOSYMT,IPURTF,DIRTRF
C
C     ----- PARAMETERS:
C           XPQRJ       ON EXIT ONE-INDEX TRANSFORMED INTEGRALS
C           F           ON EXIT FOCK CORE OPERATOR
C           D           CORE DENSITY MATRIX
C           XX,IX       2E-INTEGRALS BUFFERS
C           C           ON ENTRY CORE ORBITALS
C           CO          ON ENTRY ORBITALS TO TRANSFORM THE 2E-INTEGRALS
C
      NUM2 = (NUM*NUM+NUM)/2
      N2 = (N1*N1+N1)/2
      CALL VCLR(XPQRJ,1,NDIM*NUM*NOC)
      CALL VCLR(FN,1,N2)
C
C     ----- GET FROZEN CORE 1E- DENSITY -----
C
      IF(NCORB.GT.0) CALL GETDEN(D,C,NUM,NCORB)
C
C     ----- PROCESS NUCLEAR-ELECTRON INTEGRALS -----
C
      IF(.NOT.DIRTRF) THEN
C
         DO 100 KAP=0,NPROC-1
            JFLG(KAP)=1
  100    CONTINUE
         KAP = -1
         IFLG=  1
C
         CALL SEQREW(IJK)
  200    CONTINUE
C
C              READ NEXT INTEGRAL RECORD FROM A DUPLICATED OR
C              DISTRIBUTED AO INTEGRAL FILE
C
         IF(ITRFAO.EQ.1) THEN
            CALL PREAD(IJK,XX,IX,NXX,NINTMX)
         ELSE
            CALL PREADP(IJK,XX,IX,NXX,NINTMX,
     *                  KAP,IFLG,JFLG,NPROC)
            IF(IFLG.EQ.0) THEN
               CALL SEQREW(IJK)
               GO TO 700
            END IF
         END IF
C
         IF(NXX.EQ.0) GO TO 250
         NINT=ABS(NXX)
         IF(NINT.GT.NINTMX) CALL ABRT
C
C                PERFORM FIRST INDEX TRANSFORMATION
C
         IF(DOFOCK  .AND.  NCORB.GT.0  .AND.  MASWRK) THEN
            CALL NE_ONETFF(XPQRJ,CO,F,D,NDIM,NUM,NOC,XX,IX,NXX,
     *                     FN)
         ELSE
            CALL NE_ONETRF(XPQRJ,CO,    NDIM,NUM,NOC,XX,IX,NXX)
         END IF
C
  250    CONTINUE
         IF(ITRFAO.EQ.1  .AND.  NXX.LE.0) THEN
            CALL SEQREW(IJK)
            GO TO 700
         END IF
         GO TO 200
      END IF
C
C     ----- DIRECT CASSCF -----
C
      IF(DIRTRF) THEN
         IF(DOFOCK  .AND.  NCORB.GT.0  .AND.  MASWRK) THEN
            I2CASE=1
         ELSE
            I2CASE=3
         END IF
         CALL DIRJK(GHONDO,XINTS,DDIJ,XX,IX,MAXG,NSH2)
      END IF
C
C     ----- 2E-CONTRIBUTION TO FROZEN CORE MODIFICATION OF
C              1-NUC MO INTEGRALS -----
C
  700 CONTINUE
      IF(DOFOCK  .AND.  NCORB.GT.0) THEN
         IF(GOPARR) CALL DDI_BCAST(1720,'F',F,NUM2,MASTER)
         CALL TFTRI(HNMO,FN,CN,WRK,NACT_NU,N1,N1)
      END IF
      RETURN
C
      END
C*MODULE NEOTRN  *DECK NE_ONETRF
      SUBROUTINE NE_ONETRF(XPQRJ,CO,NDIM,NUM,NOC,XX,IX,NXX)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXAO=8192)
C
      DIMENSION XPQRJ(NOC,NDIM,*),CO(NUM,*),XX(*),IX(*)
C
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /PCKLAB/ LABSIZ
C
      NINT = ABS(NXX)
C
      IF(LABSIZ.GE.2) THEN
C
C     ----- TWO BYTES PER LABEL -----
C
         DO 20 M=1,NINT
            VAL1 = XX(M)
            VAL3 = VAL1
C
                       NPACK = M
*I32                     LABEL = IX( 2*NPACK - 1 )
*I32                     IPACK = ISHFT( LABEL, -16 )
*I32                     JPACK = IAND(  LABEL, 65535 )
*I32                     LABEL = IX( 2*NPACK     )
*I32                     KPACK = ISHFT( LABEL, -16 )
*I32                     LPACK = IAND(  LABEL, 65535 )
*I64                     LABEL = IX(NPACK)
*I64                     IPACK = ISHFT( LABEL, -48 )
*I64                     JPACK = IAND( ISHFT( LABEL, -32 ), 65535 )
*I64                     KPACK = IAND( ISHFT( LABEL, -16 ), 65535 )
*I64                     LPACK = IAND( LABEL, 65535 )
                       MP = IPACK
                       MQ = JPACK
                       MR = KPACK
                       MS = LPACK
C
            MPQ= IA(MP)+MQ
            MRS= IA(MR)+MS
            IF(MP.EQ.MQ) VAL1 = VAL1+VAL1
            IF(MR.EQ.MS) VAL3 = VAL3+VAL3
            DO 10 MJ=1,NOC
               XPQRJ(MJ,MPQ,MR) = XPQRJ(MJ,MPQ,MR) + VAL1*CO(MS,MJ)
               XPQRJ(MJ,MPQ,MS) = XPQRJ(MJ,MPQ,MS) + VAL1*CO(MR,MJ)
               XPQRJ(MJ,MRS,MP) = XPQRJ(MJ,MRS,MP) + VAL3*CO(MQ,MJ)
               XPQRJ(MJ,MRS,MQ) = XPQRJ(MJ,MRS,MQ) + VAL3*CO(MP,MJ)
   10       CONTINUE
   20    CONTINUE
C
      ELSE
C
C     ----- ONE BYTE PER LABEL -----
C
*VDIR NODIVLOOP
         DO 40 M=1,NINT
            VAL1 = XX(M)
            VAL3 = VAL1
C
                       NPACK = M
*I32                     LABEL = IX(NPACK)
*I32                     IPACK = ISHFT( LABEL, -24 )
*I32                     JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
*I32                     KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
*I32                     LPACK = IAND( LABEL, 255 )
*I64                     IF ( MOD(NPACK,2) .EQ. 0 ) THEN
*I64                       LABEL = IX( NPACK/2 )
*I64                       IPACK = IAND( ISHFT( LABEL, -24 ), 255 )
*I64                       JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
*I64                       KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
*I64                       LPACK = IAND( LABEL, 255 )
*I64                     ELSE
*I64                       LABEL = IX( (NPACK/2)+1 )
*I64                       IPACK = ISHFT( LABEL, -56 )
*I64                       JPACK = IAND( ISHFT( LABEL, -48 ), 255 )
*I64                       KPACK = IAND( ISHFT( LABEL, -40 ), 255 )
*I64                       LPACK = IAND( ISHFT( LABEL, -32 ), 255 )
*I64                     END IF
                       MP = IPACK
                       MQ = JPACK
                       MR = KPACK
                       MS = LPACK
C           WRITE(6,*)'P Q R S',MP,MQ,MR,MS
C
            MPQ= IA(MP)+MQ
            MRS= IA(MR)+MS
            IF(MR.EQ.MS) VAL1 = VAL1*0.5D+00
            DO 30 MJ=1,NOC
               XPQRJ(MJ,MPQ,MR) = XPQRJ(MJ,MPQ,MR) + VAL1*CO(MS,MJ)
               XPQRJ(MJ,MPQ,MS) = XPQRJ(MJ,MPQ,MS) + VAL1*CO(MR,MJ)
   30       CONTINUE
   40    CONTINUE
C
      END IF
C
      RETURN
      END
C*MODULE NEOTRN  *DECK NE_ONETFF
      SUBROUTINE NE_ONETFF(XPQRJ,CO,FCE,DCE,NDIM,NUM,NOC,XX,IX,NXX,
     *                     FCN)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXAO=8192)
C
      DIMENSION XPQRJ(NOC,NDIM,*),CO(NUM,*),FCE(*),DCE(*),XX(*),IX(*)
      DIMENSION FCN(*)
C
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /PCKLAB/ LABSIZ
C
      NINT = ABS(NXX)
C
      IF(LABSIZ.GE.2) THEN
C
C     ----- TWO BYTES PER LABEL -----
C
         DO 20 M=1,NINT
            VAL1 = XX(M)
            VAL3 = VAL1
            VAL4 = (VAL1+VAL1)+(VAL1+VAL1)
C
                       NPACK = M
*I32                     LABEL = IX( 2*NPACK - 1 )
*I32                     IPACK = ISHFT( LABEL, -16 )
*I32                     JPACK = IAND(  LABEL, 65535 )
*I32                     LABEL = IX( 2*NPACK     )
*I32                     KPACK = ISHFT( LABEL, -16 )
*I32                     LPACK = IAND(  LABEL, 65535 )
*I64                     LABEL = IX(NPACK)
*I64                     IPACK = ISHFT( LABEL, -48 )
*I64                     JPACK = IAND( ISHFT( LABEL, -32 ), 65535 )
*I64                     KPACK = IAND( ISHFT( LABEL, -16 ), 65535 )
*I64                     LPACK = IAND( LABEL, 65535 )
                       MP = IPACK
                       MQ = JPACK
                       MR = KPACK
                       MS = LPACK
C
            MPQ= IA(MP)+MQ
            MRS= IA(MR)+MS
            MPR= IA(MP)+MR
            MPS= IA(MP)+MS
            MQR= IA(MAX(MQ,MR))+MIN(MQ,MR)
            MQS= IA(MAX(MQ,MS))+MIN(MQ,MS)
C
            FCE(MPQ) = FCE(MPQ)+VAL4*DCE(MRS)
            FCE(MRS) = FCE(MRS)+VAL4*DCE(MPQ)
            FCE(MPR) = FCE(MPR)-VAL1*DCE(MQS)
            FCE(MPS) = FCE(MPS)-VAL1*DCE(MQR)
            FCE(MQR) = FCE(MQR)-VAL1*DCE(MPS)
            FCE(MQS) = FCE(MQS)-VAL1*DCE(MPR)
C
            IF(MP.EQ.MQ) VAL1 = VAL1+VAL1
            IF(MR.EQ.MS) VAL3 = VAL3+VAL3
            DO 10 MJ=1,NOC
               XPQRJ(MJ,MPQ,MR) = XPQRJ(MJ,MPQ,MR) + VAL1*CO(MS,MJ)
               XPQRJ(MJ,MPQ,MS) = XPQRJ(MJ,MPQ,MS) + VAL1*CO(MR,MJ)
   10       CONTINUE
   20    CONTINUE
C
      ELSE
C
C     ----- ONE BYTE PER LABEL -----
C
         DO 40 M=1,NINT
            VAL1 = XX(M)
            VAL2 = VAL1 * 4.0D+00 
C
                       NPACK = M
*I32                     LABEL = IX(NPACK)
*I32                     IPACK = ISHFT( LABEL, -24 )
*I32                     JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
*I32                     KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
*I32                     LPACK = IAND( LABEL, 255 )
*I64                     IF ( MOD(NPACK,2) .EQ. 0 ) THEN
*I64                       LABEL = IX( NPACK/2 )
*I64                       IPACK = IAND( ISHFT( LABEL, -24 ), 255 )
*I64                       JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
*I64                       KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
*I64                       LPACK = IAND( LABEL, 255 )
*I64                     ELSE
*I64                       LABEL = IX( (NPACK/2)+1 )
*I64                       IPACK = ISHFT( LABEL, -56 )
*I64                       JPACK = IAND( ISHFT( LABEL, -48 ), 255 )
*I64                       KPACK = IAND( ISHFT( LABEL, -40 ), 255 )
*I64                       LPACK = IAND( ISHFT( LABEL, -32 ), 255 )
*I64                     END IF
                       MP = IPACK
                       MQ = JPACK
                       MR = KPACK
                       MS = LPACK
C
            MPQ= IA(MP)+MQ
            MRS= IA(MR)+MS
            MPR= IA(MP)+MR
            MPS= IA(MP)+MS
            MQR= IA(MAX(MQ,MR))+MIN(MQ,MR)
            MQS= IA(MAX(MQ,MS))+MIN(MQ,MS)
C
            IF(MR.EQ.MS) VAL1 = VAL1*0.5D+00 
            IF(MR.EQ.MS) VAL2 = VAL2*0.5D+00 
C
            FCN(MPQ) = FCN(MPQ)-VAL2*DCE(MRS)
C
            DO 30 MJ=1,NOC
               XPQRJ(MJ,MPQ,MR) = XPQRJ(MJ,MPQ,MR) + VAL1*CO(MS,MJ)
               XPQRJ(MJ,MPQ,MS) = XPQRJ(MJ,MPQ,MS) + VAL1*CO(MR,MJ)
   30       CONTINUE
   40    CONTINUE
      END IF
      RETURN
      END
C*MODULE NEOTRN  *DECK TR1N
      SUBROUTINE TR1N(H0,FC,C,T,NUM,NORB,IJKT,DBUG,L1)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (ZERO=0.0D+00)
C
      LOGICAL DBUG
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION H0(*),FC(*),C(NUM,*),T(*)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      NUM2 = (NUM*(NUM+1))/2
C
CSPW  CALL DAREAD(IDAF,IODA,H0,NUM2,11,0)
C
C     --- MODIFY ONE PARTICLE OPERATOR BY ADDING CORE CONTRIBUTIONS
C
CSPW  IF(NCORB.NE.0) THEN
CSPW     DO 10 I=1,NUM2
CSPW        H0(I) = H0(I) + TWO*FC(I)
CSP10    CONTINUE
CSPW  END IF
CSPW  CALL DAWRIT(IDAF,IODA,H0,NUM2,35,0)
C
C     ---  TRANSFORM THE ONE PARTICLE OPERATOR TO THE MO BASIS,   ---
C     ---  WRITE THIS AS THE FIRST RECORD OF THE TRANSFORMED      ---
C     ---  INTEGRAL FILE (NOTE THAT ONLY NODE 0 OWNS THIS MATRIX) ---
C
      CALL TFTRI(FC,H0,C,T,NORB,NUM,NUM)
      CALL SEQREW(IJKT)
      IF (MASWRK) CALL SQWRIT(IJKT,FC,NUM2)
C
      IF(DBUG) THEN
         DO 20 I=1,NORB
            T(I) = ZERO
   20    CONTINUE
         WRITE(IW,9999)
         CALL PREVNU(C,T,NORB,NUM,L1+1,L1+NUM)
         WRITE(IW,9998)
         CALL PRTRI(FC,NORB)
      END IF
      RETURN
C
 9999 FORMAT(/' TRANSFORMATION VECTORS')
 9998 FORMAT(/' TRANSFORMED 1-PARTICLE INTEGRALS')
      END
C*MODULE NEOTRN  *DECK NE_CASTR2
      SUBROUTINE NE_CASTR2(XPQKL,X,Y,XX,IX,CO,CT,
     *                  NBF2,NBF,NFTO,TOL,DBUG,NO,XBUF,IXBUF,
     *                  NCORBS,NCI,NORBS,NORB,NORBSE)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL DBUG,PACK2E,MASWRK,DSKWRK,GOPARR,NXT,DIRTRF
C
      DIMENSION XBUF(*),IXBUF(*),XPQKL(NBF2,*),X(NBF,*),Y(NBF,*)
      DIMENSION CO(NBF,*),CT(NCI,*),XX(*),IX(*)
C
C     COMMON /MCPAR / NFZC,NCORBS,NCI,NORBS,NORB,NUM1
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C-MWS COMMON /SYMMUL/ NIJREP(14,14),IJREP(2,14,14,14)
      COMMON /TRFOPT/ CUTTRF,NWDTRF,MPTRAN,ITRFAO,NOSYMT,IPURTF,DIRTRF
C
      PARAMETER (ZERO=0.0D+00)
C
C     ----- TRANSFORM (PQ|KL) TO (IJ|KL) -----
C
      DO 10 MK=1,NCI
      DO 10 MP=1,NBF
   10    CT(MK,MP)=CO(MP,MK)
C
      IF (GOPARR) THEN
         NXT = IBTYP.EQ.1  .AND.  ITRFAO.EQ.1
         IPCOUNT = ME - 1
         NEXT = -1
         MINE = -1
      END IF
C
C-MWS-     GO TO 100
C     THE OTHER CODE AT THE BOTTOM (STARTING AT 100) IS ALSO A
C     WORKING CODE.  TO USE IT IN PARALLEL MODE, DON'T CALL GLOBAL
C     SUM IN GUGSRT, AND MAKE ALL NODES WRITE 1E INTEGRALS IN TR1E
C     AND READ THEM IN GUGSRT.
C
      NUMX=0
      NREC=0
      NINT=0
      NO=0
      MKL=0
      NKL=0
      MK=1
C
   60 CONTINUE
      IF (GOPARR) THEN
        IF (NXT) THEN
          MINE = MINE + 1
          IF (MINE.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
          IF (NEXT.NE.MINE) THEN
             NKL = NKL + MK
             IF(MK.GT.NCORBS) MKL = MKL + MK - NCORBS
             GO TO 55
          END IF
        ELSE
          IPCOUNT = IPCOUNT + 1
          IF (MOD(IPCOUNT,NPROC).NE.0) THEN
             NKL = NKL + MK
             IF(MK.GT.NCORBS) MKL = MKL + MK - NCORBS
             GO TO 55
          END IF
        END IF
      END IF
C
      DO 50 ML=1,MK
         NKL=NKL+1
         MAJ=0
         IDXML = ML
         IF(MK.LE.NCORBS .OR. ML.LE.NCORBS) GO TO 40
         MKL=MKL+1
         MPQ=0
         DO 20 MP=1,NBF
         DO 20 MQ=1,MP
            MPQ=MPQ+1
            X(MP,MQ)=XPQKL(MPQ,MKL)
   20       X(MQ,MP)=X(MP,MQ)
C
         CALL MRARBR(X,NBF,NBF,NBF,CO,NBF,NCI,Y,NBF)
         CALL MRARBR(CT,NCI,NCI,NBF,Y,NBF,NCI,X,NBF)
C
C-MWS    KLREP=IJREP(2,1,MOSIRP(MK),MOSIRP(ML))
         DO 30 MA=1,NORBS
         DO 30 MJ=1,MA
            MAJ=MAJ+1
            DUM=ZERO
            IF(MA.LE.NCORBS .OR. MJ.LE.NCORBS) GO TO 30
C           IF(MAJ.LT.NKL .AND.SKIP) GO TO 30
C-MWS       IF(KLREP.NE.IJREP(2,1,MOSIRP(MA),MOSIRP(MJ))) GO TO 30
C           IF(.NOT.SYM2EI(MOSIRP(MA),MOSIRP(MJ),
C    *                     MOSIRP(MK),MOSIRP(ML))) GO TO 30
            DUM=X(MA-NCORBS,MJ-NCORBS)
            XX(MAJ)=DUM
   30    CONTINUE 
C
   40    CALL GEN_TRFWT(NFTO,XX,NUMX,IX,XBUF,MAJ,1,TOL,NREC,DBUG,MK,
     *            IDXML,IXBUF,NORB)
         IF(DBUG.AND.NUMX.GT.0)
     *      CALL TRFOUT(XX,NUMX,IX,NUMX,NORB,MK,ML)
         CALL VCLR(XX,1,NBF2)
   50 CONTINUE
C
   55 CONTINUE
      MK=MK+1
      IF(MK.LE.NORBSE) GO TO 60
C
      IF (DBUG) CALL TR2OUT(0,0,0,0,0,ZERO,1)
      NINT = NREC*NINTMX+NUMX
      NREC = NREC+1
      NUMX = -NUMX
      CALL PWRIT(NFTO,XBUF,IXBUF,NUMX,NINTMX)
C
      IF (GOPARR) THEN
         CALL DDI_GSUMI(2204,NINT,1)
         IF (NXT) CALL DDI_DLBRESET
      END IF
C
      IF (MASWRK.AND.DBUG) WRITE (IW,9008) NINT,NREC,NINTMX
      NO=NINT
      RETURN
C
C
 9008 FORMAT(49H TOTAL NUMBER OF TRANSFORMED 2E-INTEGRALS KEPT = ,I10,
     +     4H IN ,I10,14H RECORD(S) OF ,I5,11H INTEGRALS.)
      END
C*MODULE NEOTRN  *DECK NN_CASTR2
      SUBROUTINE NN_CASTR2(XPQKL,X,Y,XX,IX,CO,CT,
     *                  NBF2,NBF,NFTO,TOL,DBUG,NO,XBUF,IXBUF,SKIP,
     *                  NCORBS,NCI,NORBS,NORB)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL DBUG,PACK2E,MASWRK,DSKWRK,GOPARR,NXT,DIRTRF
      LOGICAL SKIP 
C
      DIMENSION XBUF(*),IXBUF(*),XPQKL(NBF2,*),X(NBF,*),Y(NBF,*)
      DIMENSION CO(NBF,*),CT(NCI,*),XX(*),IX(*)
C
C     COMMON /MCPAR / NFZC,NCORBS,NCI,NORBS,NORB,NUM1
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C-MWS COMMON /SYMMUL/ NIJREP(14,14),IJREP(2,14,14,14)
      COMMON /TRFOPT/ CUTTRF,NWDTRF,MPTRAN,ITRFAO,NOSYMT,IPURTF,DIRTRF
C
      PARAMETER (ZERO=0.0D+00)
C
C     ----- TRANSFORM (PQ|KL) TO (IJ|KL) -----
C
      DO 10 MK=1,NCI
      DO 10 MP=1,NBF
   10    CT(MK,MP)=CO(MP,MK)
C
      IF (GOPARR) THEN
         NXT = IBTYP.EQ.1  .AND.  ITRFAO.EQ.1
         IPCOUNT = ME - 1
         NEXT = -1
         MINE = -1
      END IF
C
C-MWS-     GO TO 100
C     THE OTHER CODE AT THE BOTTOM (STARTING AT 100) IS ALSO A
C     WORKING CODE.  TO USE IT IN PARALLEL MODE, DON'T CALL GLOBAL
C     SUM IN GUGSRT, AND MAKE ALL NODES WRITE 1E INTEGRALS IN TR1E
C     AND READ THEM IN GUGSRT.
C
      NUMX=0
      NREC=0
      NINT=0
      NO=0
      MKL=0
      NKL=0
      MK=1
C
   60 CONTINUE
      CALL FLSHBF(6)
      IF (GOPARR) THEN
        IF (NXT) THEN
          MINE = MINE + 1
          IF (MINE.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
          IF (NEXT.NE.MINE) THEN
             NKL = NKL + MK
             IF(MK.GT.NCORBS) MKL = MKL + MK - NCORBS
             GO TO 55
          END IF
        ELSE
          IPCOUNT = IPCOUNT + 1
          IF (MOD(IPCOUNT,NPROC).NE.0) THEN
             NKL = NKL + MK
             IF(MK.GT.NCORBS) MKL = MKL + MK - NCORBS
             GO TO 55
          END IF
        END IF
      END IF
C
      DO 50 ML=1,MK
         NKL=NKL+1
         MAJ=0
         IDXML = ML
         IF(MK.LE.NCORBS .OR. ML.LE.NCORBS) GO TO 40
         MKL=MKL+1
         MPQ=0
         DO 20 MP=1,NBF
         DO 20 MQ=1,MP
            MPQ=MPQ+1
            X(MP,MQ)=XPQKL(MPQ,MKL)
   20       X(MQ,MP)=X(MP,MQ)
C
         CALL MRARBR(X,NBF,NBF,NBF,CO,NBF,NCI,Y,NBF)
         CALL MRARBR(CT,NCI,NCI,NBF,Y,NBF,NCI,X,NBF)
C-MWS    KLREP=IJREP(2,1,MOSIRP(MK),MOSIRP(ML))
         DO 30 MA=1,NORBS
         DO 30 MJ=1,MA
            MAJ=MAJ+1
            DUM=ZERO
            IF(MA.LE.NCORBS .OR. MJ.LE.NCORBS) GO TO 30
            IF(MAJ.LT.NKL .AND.SKIP) GO TO 30
C-MWS       IF(KLREP.NE.IJREP(2,1,MOSIRP(MA),MOSIRP(MJ))) GO TO 30
C           IF(.NOT.SYM2EI(MOSIRP(MA),MOSIRP(MJ),
C    *                     MOSIRP(MK),MOSIRP(ML))) GO TO 30
C           WRITE(6,*)'MA=',MA
C           WRITE(6,*)'MJ=',MJ
C           WRITE(6,*)'MAJ=',MAJ
            DUM=X(MA-NCORBS,MJ-NCORBS)
C           WRITE(6,*)'DUM=',DUM
   30       XX(MAJ)=DUM
C
   40    CALL GEN_TRFWT(NFTO,XX,NUMX,IX,XBUF,MAJ,1,TOL,NREC,DBUG,MK,
     *             IDXML,IXBUF,NORB)
         IF(DBUG.AND.NUMX.GT.0)
     *      CALL TRFOUT(XX,NUMX,IX,NUMX,NORB,MK,ML)
         CALL VCLR(XX,1,NBF2)
   50 CONTINUE
C
   55 CONTINUE
      MK=MK+1
      IF(MK.LE.NORBS) GO TO 60
C
      IF (DBUG) CALL TR2OUT(0,0,0,0,0,ZERO,1)
      NINT = NREC*NINTMX+NUMX
      NREC = NREC+1
      NUMX = -NUMX
      CALL PWRIT(NFTO,XBUF,IXBUF,NUMX,NINTMX)
C
      IF (GOPARR) THEN
         CALL DDI_GSUMI(2204,NINT,1)
         IF (NXT) CALL DDI_DLBRESET
      END IF
C
      IF (MASWRK.AND.DBUG) WRITE (IW,9008) NINT,NREC,NINTMX
      NO=NINT
      RETURN
C
 9008 FORMAT(49H TOTAL NUMBER OF TRANSFORMED 2E-INTEGRALS KEPT = ,I10,
     +     4H IN ,I10,14H RECORD(S) OF ,I5,11H INTEGRALS.)
      END
C*MODULE NEOTRN  *DECK GEN_TRFWT
      SUBROUTINE GEN_TRFWT(NFT,X,NX,IX,XBUF,NN,I0,TOL,NREC,OUT,MI,MJ,
     *                 IXBUF,NORB)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL PACK2E,OUT
C
      DIMENSION X(*),IX(*),XBUF(*),IXBUF(*)
C
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /PCKLAB/ LABSIZ
C
C     ----- SIFT THE INTEGRALS FOR NON-SMALL ENTRIES -----
C
      ICOUNT = 0
      DO 10 I=1,NN
        IF( ABS(X(I)).LT.TOL) GO TO 10
        ICOUNT=ICOUNT+1
        X(ICOUNT) = X(I)
        IX(ICOUNT)=I+I0-1
   10 CONTINUE
C
      MO = 1
      KL = 0
      DO 30 K = 1,NORB
        DO 20 L = 1, K
          KL = KL + 1
          IF (MO.GT.ICOUNT) GO TO 40
          IF (KL.NE.IX(MO)) GO TO 20
          MK = K
          ML = L
          NX = NX + 1
C
               NPACK = NX
               IPACK = MI
               JPACK = MJ
               KPACK = MK
               LPACK = ML
               IF (LABSIZ .EQ. 2) THEN
*I32             IXBUF( 2*NPACK-1 ) = ISHFT( IPACK, 16 ) + JPACK
*I32             IXBUF( 2*NPACK   ) = ISHFT( KPACK, 16 ) + LPACK
*I64             LABEL = ISHFT( IPACK, 48 ) + ISHFT( JPACK, 32 ) +
*I64 *                   ISHFT( KPACK, 16 ) + LPACK
*I64             IXBUF(NPACK) = LABEL
               ELSE IF (LABSIZ .EQ. 1) THEN
*I32             LABEL = ISHFT( IPACK, 24 ) + ISHFT( JPACK, 16 ) +
*I32 *                   ISHFT( KPACK,  8 ) + LPACK
*I32             IXBUF(NPACK) = LABEL
*I64             IF ( MOD(NPACK,2) .EQ. 0 ) THEN
*I64               LABEL = ISHFT( IPACK, 24 ) + ISHFT( JPACK, 16 ) +
*I64 *                     ISHFT( KPACK,  8 ) + LPACK
*I64               IXBUF( NPACK/2 ) = IXBUF( NPACK/2 ) + LABEL
*I64             ELSE
*I64               LABEL = ISHFT( IPACK, 56 ) + ISHFT( JPACK, 48 ) +
*I64 *                     ISHFT( KPACK, 40 ) + ISHFT( LPACK, 32 )
*I64               IXBUF( (NPACK/2)+1 ) = LABEL
*I64             END IF
               END IF
C
          XBUF(NX)  = X(MO)
          MO = MO + 1
          IF (OUT) CALL TR2OUT(MI,MJ,MK,ML,NX,XBUF(NX),0)
          IF (NX .EQ. NINTMX) THEN
             CALL PWRIT(NFT,XBUF,IXBUF,NINTMX,NINTMX)
             NREC = NREC+1
             NX = 0
          END IF
   20   CONTINUE
   30 CONTINUE
   40 CONTINUE
      RETURN
      END
C*MODULE NEOTRN   *DECK TRPREP
      SUBROUTINE TRPREP(NOSYMT,L0,L1,L2,L3,IA,MORB)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
C
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
C
      DIMENSION IA(*)
C
C     ---- OPTION TO DEFEAT SYMMETRY USAGE ----
C
      IF(NOSYMT.EQ.1) CALL SYMOFF
C
C     ---- CLEAN UP AND ORTHONORMALIZE ORBITALS ----
C
      CALL VALFM(LOADFM)
      LVEC = LOADFM  + 1
      LQ   = LVEC  + L3
      LS   = LQ    + L3
      LTMP = LS    + L2
      LEA  = LTMP  + L1
      LWRK = LEA   + L1
      LAST = LWRK  + 8*L1
      NEED = LAST - LOADFM -1
      CALL GETFM(NEED)
C
      CALL DAREAD(IDAF,IODA,X(LS),L2,441,0)
      CALL QMATRX(X(LS),X(LQ),X(LEA),X(LWRK),X(LTMP),L0,L1,L1,.FALSE.)
      CALL DAWRIT(IDAF,IODA,X(LQ),L3,443,0)
C
      CALL DAREAD(IDAF,IODA,X(LVEC),L3,444,0)
      CALL DAREAD(IDAF,IODA,X(LS),L2,441,0)
      CALL DAREAD(IDAF,IODA,X(LQ),L3,443,0)
C
C     --- TRADITIONAL SETTINGS ARE 1D-8 AND 1D-6, RESPECTIVELY ---
C
      NT = 1
      IF(NT.GT.1) THEN
         TOLZ=1.0D-09
         TOLE=1.0D-07
         CALL CLENMO(X(LVEC),L1,L0,TOLZ,TOLE,IW,.FALSE.)
      END IF
C
      CALL ORTHO(X(LQ),X(LS),X(LVEC),X(LTMP),L0,L0,L1,L2,L1)
      CALL TFSQB(X(LVEC),X(LQ),X(LTMP),L0,L1,L1)
C
      CALL DAWRIT(IDAF,IODA,X(LVEC),L3,444,0)
      CALL RETFM(NEED)
C
C     --- ASSIGN IRREP TO MO'S ---
C
      LVEC   = LOADFM + 1
      LMOIRP = LVEC   + L3
      LMOLAB = LMOIRP + L1
      LMODEG = LMOLAB + L1
      LWRK   = LMODEG + L1
      LS     = LWRK   + L1
      LQ     = LS     + L2
      LAST   = LQ     + L3
      NEED   = LAST - LVEC
      CALL GETFM(NEED)
C
      CALL DAREAD(IDAF,IODA,X(LVEC),L3,444,0)
      CALL DAREAD(IDAF,IODA,X(LS),L2,441,0)
      CALL DAREAD(IDAF,IODA,X(LQ),L3,443,0)
      CALL TRFSYM(X(LMOLAB),X(LMOIRP),X(LMODEG),X(LQ),X(LS),X(LVEC),
     *            X(LWRK),IA,L0,L1,MORB,L1)
C
CSPW  CALL GAJASW(X(LMOIRP),NUM,GRPDET)
C
      CALL DAWRIT(IDAF,IODA,X(LMOIRP),L1,453,1)
C
      CALL RETFM(NEED)
C
      RETURN
      END
C
