C 18 Feb 13 - MWS - comment out unused SORT2, which conflicts w/TINKER.
C  6 Feb 13 - MWS - CIMCALC,MEMGMS: attend to Cray, HP-UX, AXP warnings
C
* -----------------------------------------------------
* SEE HELP FOR CIMI BY USING "cimi -h" or "cimi --help"
* -----------------------------------------------------
*     Aug 15, 2010 cimi-0.04 fixed MPI processors and restrained LMO CIM for CCSD only
*     Aug 14, 2010 cimi-0.03 updated the memory for RHF/ROHF CCSD and CR-CCL and RHF CCSD(T)
*     Aug 11, 2010 cimi-0.02 cimlib.o compiled from cimlib.src is required
*     Aug 10, 2010 cimi-0.01 based on cimi_2010.07.02.for
*
* --- Since Aug 10, 2010 x.xx as version number and cimi linked to cimi-x.xx ---
*
* --- LIST OF FILE UNITS [formatted] ---
*     inp [inname]:   GAUSSIAN input file exam.gjf (needed as input file)
*     io [outname]:   LSCIM general output file exam.out
*     igms [gmsname]: GAMESS general output file exam.gms
*
* --- LIST OF FILE UNITS [unformatted] ---
*     cim [cimname]:  GAMESS output file for informations and one-elec integrals exam.cim
*     itmp [tmpname]: LSCIM Temporirary file for integrals transformation exam.tmp
*
* --- LIST OF VARIABLES FOR TOTAL MOLECULE  [integer] ---
*     NATOM:  Number of atoms
*     NW:     Number of basis functions
*     Nmo:    Number of all MOs (e.g. Number of independant functions, Nmo.le.NW)
*     NUW:    Number of occupied MOs
*     icha:   Number of charges
*     mult:   Multiplicity
*     nel:    Number of electrons
*     k_alph: Number of alpha electrons
*     k_beta: Number of beta electrons
*     nsh:    Number of contracted shells',nsh,k)
*     npr:    Number of primitive shells',npr,k)
*     tbs(NW):       Atomic label for basis
*
* --- LIST OF VARIABLES FOR TOTAL MOLECULE  [double precision] ---
*     NN:     Nuclear Repulsion Energy',NN,k)
*     ETOT:   Total MP2 correlation energy
*     nuchar(NATOM): Nuclear charges
*     coor(3,NATOM): Cartesian coordinates
*     EIGEN(Nmo):    Alpha MOs eigenvalues
*     SMO(Nmo,Nmo):  Alpha MOs coefficients
*     SOVER(NW,NW):  AO overlap matrix
*     HCORE(NW,NW):  AO core-Hamiltonian matrix
*     FK(Nmo,Nmo):   AO Fock matrix
*     FIJ(NUW,NUW):  MO Fock matrix  ! 2008.07.25 Nmo --> NUW
*     admx(NW,NW):   AO dipole moment integrals in X-direct
*     admy(NW,NW):   AO dipole moment integrals in Y-direct
*     admz(NW,NW):   AO dipole moment integrals in Z-direct
*     mdmx(Nmo,Nmo): MO dipole moment integrals in X-direct
*     mdmy(Nmo,Nmo): MO dipole moment integrals in Y-direct
*     mdmz(Nmo,Nmo): MO dipole moment integrals in Z-direct
*
* --- LIST OF LSCIM PARAMETERS FOR CALCULATION [integer] ---
*     nfocc:  Number of frozen occupied MOs (default: nfocc=0)
*     nfvir:  Number of frozen virtual MOs (default: nfvir=0, nfvir must be 0 for CIM)
*     np:     Number of threads of OpenMP parellel (not available now)
*     kmem:   Maximum memory for integrals transformation (unit: Words, e.g. 8 Bytes)
*     nprint: Level of printing in localization
*             nprint=0 ~ Print information at each ten of cycles without final LMOs
*             nprint=1 ~ Print final LMOs other than nprint=0
*     maxcyc: Maximum cycles of localization (default: maxcyc=10000)
*     conv:   Convergence threshold of iterative MP2 (default: conv=6)   ! 2007.10.17.conv=6 --> =7
*     eps:    Threshold of the convergance in localization (default: eps=1d-7)
*     epst:   Threshold of the selected rotation in localization (default: eps=1d-13)
*     
      subroutine CIMI(nsubsystems)
      implicit none

      integer MXSH,MXGTOT,MXATM,MAXSH,MXRT,MXAO
      double precision ONE,TWO,zero,UNITS
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000, MAXSH=84,
     *           ONE = 1.0D0,MXRT=100,MXAO=8192,zero=0.0d0,
     *           UNITS = ONE/0.52917724924D+00,
     *           TWO=2.D0)
      COMMON /IOFILE/ IR2,Io,IP2,IS2,IPK2,IDAF2,NAV2,IODA2(950)
      COMMON /CIMINF/ ICIM2,inp,MOTYP2,NCA2,NCB2  !-CIM-
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      integer icim2,ir2,ip2,is2,ipk2,idaf2,nav2,ioda2,nca2,ncb2
      integer motyp2
      integer nsubsystems
      integer NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,IAN
      double precision ZAN,C
C
      integer inp,io,igms,itmp,isys,job
C     parameter (inp=12,io=11,igms=14)
      parameter (igms=14)
      parameter (itmp=18,isys=24,job=25)
C
      integer i,j,k,l,m,n,i1,i2,i3,i4,j1,j2,j3,j4,k1,k2,k3,k4,ii,jj,kk
      integer NW,NUW,NATOM,nsh,npr,L2,nprint,maxcyc,kerr,nprtcyc
      integer Nmo,k_alph,k_beta,ierr,nfocc,nfvir,np,jerr
      integer ini,ifi,icha,mult,kmem,level,nel,imethd,icore
      integer mplevl,istop,k5,k6,k7,k8
      character*8 scftyp,cctyp
      logical dirscf
C
      integer,dimension(:),allocatable::tbs,atmlevl,atmgrp
      integer,dimension(:,:),allocatable::link
C
      double precision,dimension(:),allocatable::EIGEN
      double precision,dimension(:),allocatable::nuchar,dtmp
      double precision,dimension(:,:),allocatable::SOVER,HCORE,DM,PS
      double precision,dimension(:,:),allocatable::SMO,FIJ,FK,coor,FKB
      double precision,dimension(:,:),allocatable::mdmx,mdmy,mdmz,runit
      double precision,dimension(:,:),allocatable::admx,admy,admz,dis

      double precision ETOT,NN,eps,epst,EHF
C
      integer IWORK(100)
      double precision RWORK(100)
      character(len=8) CWORK(100)
      logical LWORK(100)
C
      character addi*100,mem*20,mthd*20,basis*30,nproc*4,runtyp*20
      character command*256,line*100,line2*256,lsqcln*1024,gver*3
      character key18*18,sls,suffix*10,line3*256,line4*256
      character(len=100) inname,outname,gmsname,tmpname
      character(len=100) logname
      character(len=100) sysname,jobname,snfname,pfxname
      character(len=100) cimname
      character(len=200) path
      character(len=50)  user
      integer system
      integer (kind=4) Wall0,Wall,TIME
      double precision trace,dtrace2   !,coor(3,NATOM),nuchar(NATOM)
      real*8 Tim0,CPUTim
      external dtrace2,CPUTim !,system,TIME   ! Add TIME in external 2006.02.06
      integer numcor
      external numcor
      logical exst
C
      integer marg
      parameter (marg=20)
      integer narg,typarg(0:marg)
      character*100 arg(0:marg)
C
      integer NOA,NOB,NCMO
C --- 18 AUG 10
      integer,dimension(:),allocatable::NCBS
      character(len=100),dimension(:,:),allocatable::CBAS
      character(len=8),dimension(:),allocatable::CIMATM
C
C --- Tim0: Initial CPU time; Wall0: Initial WALL time
      nsubsystems=0
      Tim0=CPUTim(0)
C     Wall0=TIME()
      sls=char(47)   ! sls='/'
C
C --- Read strings after command "ecmfc.x" and online help
C     call NJ_cmdline(narg,arg,typarg)
C     call NJ_help(narg,arg,typarg,ierr)
C     if (ierr.ge.0) call cimi_help(0)
C
C --- Define used file name based on input file
C     call LS_infile(narg,arg,typarg,inname,suffix)
C     if (suffix.ne.'cim       ') inname=trim(inname)//'.cim'
C     call NJ_trim(inname,k1,k2)
C     pfxname=inname(k1:k2-4)
C     call NJ_outfile(narg,arg,typarg,inname,'o','out',outname)
C     call NJ_outfile(narg,arg,typarg,inname,' ','inp',gmsname)
C     call NJ_outfile(narg,arg,typarg,inname,' ','tmp',tmpname)
C     call NJ_outfile(narg,arg,typarg,inname,' ','log',logname)
C     call NJ_outfile(narg,arg,typarg,inname,' ','sys',sysname)
C     call NJ_outfile(narg,arg,typarg,inname,' ','job',jobname)
C     call NJ_outfile(narg,arg,typarg,inname,' ','snf',snfname)
      CALL GMS_GETENV('CIMFILE',gmsname)
C
C --- Read parameter from command line (e.g. cimi exam.gjf -level 3)
C     call NJ_argfind(narg,arg,typarg,'core',icore)
C     call NJ_argvalu(narg,arg,typarg,'stop',istop)
C     if (istop.eq.0) istop=9
C
C --- Open needed file: Gaussian input file, LSCIM output file, GAMESS input file
C     open(inp,file=inname,status='old')
C     open(io,file=outname)
C
C --- Print title, time, hostname, directory
      call cimi_help(io)
C     call NJ_date(io,'Task begin from:')
C     call NJ_sysinfo2(io,snfname,path,user)
C     write(io,'(a)') ' CIM_PATH='//trim(path)
C
C     write(io,*) 'Only add enviromental MOs once by using Zeta_1'
C     write(io,*) 'Zeta_2,Zeta_3 is useless now'
C
C     write(io,*) 'This is a cluster-in-molecule (CIM) job'
C     write(io,*) 'NOTE: get more info by '//trim(logname)//' after >&'
C     write(io,*)
      call flshbf(io)
C
C --- Old array IWK, WRK for CIM parameters were deleted

      do i=1,100
         IWORK(i) = 0
         RWORK(i) = 0.0D0
         CWORK(i) = '        '
         LWORK(i) = .false.
      enddo
      call seqrew(inp)
      call CIMREAD(io,inp,'CIMINP  ',IWORK,RWORK,CWORK,LWORK)
      call CIMREAD(io,inp,'INFO    ',IWORK,RWORK,CWORK,LWORK)
      call CIMREAD(io,inp,'INFO    ',IWORK,RWORK,CWORK,LWORK)
      call CIMREAD(io,inp,'ENERGY  ',IWORK,RWORK,CWORK,LWORK)
C
C     write(*,'(5f16.10)') (RWORK(i),i=1,7)
C     write(*,*)           (LWORK(i),i=1,5)
C     write(*,'(10a8)')    (CWORK(i),i=1,4)
C     write(*,'(10i8)')    (IWORK(i),i=51,60)
C     write(*,'(5f16.10)') (RWORK(i),i=51,52)
C     write(*,'(10a8)')    (CWORK(i),i=51,51)
C
C---  7 Apr 2009: Read infomation from .cim file
      NATOM  = IWORK(51)  ! NATOM
      icha   = IWORK(52)  ! icha
      mult   = IWORK(53)  ! mult
      nel    = IWORK(54)  ! nel
      k_alph = IWORK(55)  ! k_alph
      k_beta = IWORK(56)  ! k_beta
      NW     = IWORK(57)  ! NW
      Nmo    = IWORK(58)  ! Nmo
      nsh    = IWORK(59)  ! nsh
      npr    = IWORK(60)  ! npr   
      NN     = RWORK(51)  ! NN
      EHF    = RWORK(52)  ! EHF   
      scftyp = CWORK(51)  ! scftyp
      call PRTINF(io,NATOM,icha,mult,nel,k_alph,k_beta,NW,Nmo,
     &     nsh,npr,NN,scftyp,EHF)
C
      NUW=IWORK(55)  ! k_alph
      if (k_alph.ne.k_beta) then
         write(io,*) 'Open shell systems'
      else
         write(io,*) 'Closed shell systems'
      endif
      call flshbf(io)
C
C --- Read atoms info: coordinates and nuclear charges
      allocate(coor(3,NATOM),nuchar(NATOM),NCBS(NATOM),CBAS(100,NATOM))
      allocate(CIMATM(NATOM))
      do i=1,NATOM
         do j=1,3
            coor(j,i)=C(j,i)/UNITS
         enddo
         nuchar(i)=ZAN(i)
      enddo
      call DATAREAD(0,inp,NATOM,IAN,coor,NCBS,CBAS,0)
C     call CIMATOMS(io,inp,NATOM,CWORK(2),CIMATM)  ! SET CWORK(2)=SUBMTD AS DEFAULT, THEN READ $CIMATM
      DO i=1,NATOM
         CIMATM(i)=CWORK(2)
      ENDDO
      call cread(inp, '$CIMATM', NATOM, CIMATM)
C     call cwrit(io,  '$CIMATM', NATOM, CIMATM)

      if (LWORK(6)) then
         icore = 0
         write(io,*) 'Core orbitals will be frozen'
      else
         icore = 1
         write(io,*) 'Core orbitals will not be frozen'
      endif

C AAD To correctly count occupied orbitals when using ECP,
C     numcor() is the correct function to use
C     call FRZORB(io,NATOM,nuchar,nfocc,nfvir,icore)
      nfvir=0
      nfocc = numcor()
C
      call GMSPAR2(0,kmem,scftyp,mplevl,cctyp,
     &     IWORK,RWORK,CWORK,LWORK)
      allocate(atmlevl(NATOM),dis(NATOM,NATOM),link(NATOM,NATOM))
      allocate(atmgrp(NATOM))
      call NJ_dislink(0,NATOM,nuchar,coor,dis,link)
      call ATOMLEVL(0,NATOM,link,nuchar,CIMATM,atmlevl)
      deallocate(dis,link)
C
      call flshbf(io)
C
C --- Read Overlap, core Hamiltonian, Fock matrix from exam.dat
      L2=NW*(NW+1)/2
      allocate(dtmp(L2),tbs(NW))
      allocate(SOVER(NW,NW),HCORE(NW,NW),FK(NW,NW))
      allocate(SMO(NW,NW),EIGEN(Nmo),FKB(NW,NW))
C
* --- Read .cim for array information
      k=-1
      call seqrew(inp)
      call iread(inp, '$BASIS-ATOMS', NW, tbs)
      call rread(inp, '$HCORE', L2, dtmp)
      k=0
      do i=1,NW; do j=1,i
         k=k+1;  HCORE(j,i)=dtmp(k);  HCORE(i,j)=dtmp(k)
      enddo; enddo
C     write(io,*)'+++ HCORE +++'
C     call NJ_prtsym(io,NW,HCORE,'d14.6')
C
      call rread(inp, '$OVERLAP', L2, dtmp) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! LIWEI
      k=0
      do i=1,NW; do j=1,i
         k=k+1;  SOVER(j,i)=dtmp(k);  SOVER(i,j)=dtmp(k)
      enddo; enddo
C     write(io,*)'+++ SOVER +++'
C     call NJ_prtsym(io,NW,SOVER,'d14.6')
C
      if (scftyp.eq.'RHF     ') then
         call rread(inp, '$AO-FOCK', L2, dtmp)
         k=0
         do i=1,NW; do j=1,i
            k=k+1;  FK(j,i)=dtmp(k);  FK(i,j)=dtmp(k)
         enddo; enddo
         FKB=FK
C
      else
         call rread(inp, '$AO-FOCK-A', L2, dtmp)
         k=0
         do i=1,NW; do j=1,i
            k=k+1;  FK(j,i)=dtmp(k);  FK(i,j)=dtmp(k)
         enddo; enddo
C
         call rread(inp, '$AO-FOCK-B', L2, dtmp)
         k=0
         do i=1,NW; do j=1,i
            k=k+1;  FKB(j,i)=dtmp(k);  FKB(i,j)=dtmp(k)
         enddo; enddo
      endif
C
      call rread(inp, '$EIGVAL', Nmo, EIGEN)
      call rread(inp, '$VEC', NW*Nmo, SMO)
C     write(io,*)'+++ CMO +++'
C     call NJ_prtcol2(io,NW,Nmo,SMO,1,Nmo,'f11.6')
C     write(io,*)'+++ EIGEN +++'
C     write(io,'(5f11.6)') (EIGEN(i),i=1,Nmo)
C
C --- 2006.02.25 Add for Boys Localization ---
C --- Read AO Dipole Integrals and Trans them into MO Dipole Integrals
      allocate(admx(NW,NW),admy(NW,NW),admz(NW,NW))
      allocate(mdmx(Nmo,Nmo),mdmy(Nmo,Nmo),mdmz(Nmo,Nmo))
      call DipInt2(inp,NW,admx,admy,admz)
C
CC    if (IWORK(11).eq.0) call rread(inp, '$LMO-OCC', NW*NUW, SMO(1,1))
C
C     write(io,*)'+++ LMO +++'
C     call NJ_prtcol2(io,NW,Nmo,SMO,1,NUW,'f11.6')
C
C-WL- 26 AUG 2009 ADD DENSITY MATRIX AND PPS
*     allocate(DM(NW,NW),PS(NW,NW))
*     call NJ_denmat(0,NW,Nmo,NUW,SMO,DM)
*     call NJ_matpro(0,NW,NW,NW,DM,SOVER,PS)
*     trace=dtrace2(NW,PS)
*     write(io,'('' Trace of PS ='',f16.6)') trace
*     deallocate(DM,PS)
      write(io,*)
C
C --- Boys Localization ---
      if (IWORK(11).eq.1) then  !- IWORK(11)=1 for localization by CIM
         call NJ_tfock(0,NW,Nmo,admx,SMO,mdmx) ! mdmx=smo^T*adm*smo
         call NJ_tfock(0,NW,Nmo,admy,SMO,mdmy)
         call NJ_tfock(0,NW,Nmo,admz,SMO,mdmz)

         eps=1d-7; epst=1d-13; maxcyc=10000  ! 2006.06.05 eps,espt
C
C        Core orbitals
         if (nfocc.gt.1)then
            ini=1; ifi=nfocc; nprint=0
            nprtcyc=20  ! 2008.02.10 ADD
            call NJ_boyloc(io,NATOM,NW,Nmo,ini,ifi,SMO,mdmx,mdmy,mdmz,
     &           eps,epst,maxcyc,nprint,1,nprtcyc,ierr)
         endif
C
C        Occupied orbitals except core orbitals
         ini=nfocc+1; ifi=IWORK(56); nprint=0  ! NUW replaced by IWORK(56): Num of beta electrons
         nprtcyc=20  ! 2008.02.10 ADD
         call NJ_boyloc(io,NATOM,NW,Nmo,ini,ifi,SMO,mdmx,mdmy,mdmz,
     &        eps,epst,maxcyc,nprint,1,nprtcyc,ierr)
C
C        write(io,*) '+++ Localized Molecular Orbitals +++'
C        call NJ_prtcol2(io,NW,Nmo,SMO,1,NUW,'f11.6')
         write(io,*)
      endif

C --- Calc MO Fock Matrix
C     allocate(FIJ(k_beta,k_beta))  ! 2008.07.25 Nmo --> NUW
C     write(io,*) '--- Beta MO Fock Matrix ---'
C     call NJ_tfock(io,NW,k_beta,FKB,SMO,FIJ)
C     deallocate(FIJ)
      allocate(FIJ(NUW,NUW))  ! 2008.07.25 Nmo --> NUW
C     write(io,*) '--- Alpha MO Fock Matrix ---'
C     call NJ_tfock(io,NW,NUW,FK,SMO,FIJ)
C
C-WL- Here we give CIMMP2 as the name of subroutine, but it includes CIM-CCD calculations
C     sysname='w10.sys'
C     open(isys,file=sysname)
C     open(job, file=jobname)
      if(iwork(7).ne.0) then
         call seqopn(isys,'CIMDMN','OLD',.false.,'FORMATTED')
      else
         call seqopn(isys,'CIMDMN','NEW',.false.,'FORMATTED')
      endif
      CALL CIMMP2(io,inp,isys,NATOM,NW,NUW,Nmo,nfocc,nfvir,SMO,FIJ,
     &     FK,SOVER,admx,admy,admz,tbs,nuchar,coor,basis,gmsname,
     &     kmem,ETOT,scftyp,mplevl,cctyp,istop,
     &     job,k_beta,FKB,
     &     atmlevl,atmgrp,path,user,NCBS,CBAS,nsubsystems,
     &     IWORK,RWORK,CWORK,LWORK)    !-WL- 2009.09.09
C     call flshbf(job)
      call flshbf(isys)
C     close(job)
C     close(isys,status='delete')
      call seqclo(isys,'keep')
C
C     write(io,*) 'Normal Termination of CIMI Program!'
      write(io,*) "... FINISHED CONSTRUCTING CIM SUBSYSTEMS ..."
      call timit(1)
C     call NJ_date(io,'Task over on:')
C     call NJ_cputim(io,Tim0)
C     call NJ_walltim(io,Wall0)
C     call timit(1)
      call flshbf(io)
C
C --- Deallocate All Global Array
      deallocate(admx,admy,admz,mdmx,mdmy,mdmz)
      deallocate(coor,nuchar,SMO,atmlevl,atmgrp)
      deallocate(EIGEN,SOVER,HCORE,FK,FIJ,FKB)
C
      END
C
c     ##############################################################
c     ##  subroutine Calc_para - initialization of calc program   ##
c     ##  2005.10.17 by Wei Li; Update 2005.12.26 by Wei Li       ##
c     ##############################################################
c
      subroutine Calc_para(io,inp,mem,kmem,mthd,basis,nproc,addi,runtyp)
      implicit none
      character addi*100,mem*20,mthd*20,basis*30,nproc*4,runtyp*20
C
      integer inp,io,lth,i,j,k,k1,k2,k3,yes,nrw,ini,ifi,tmp,n,kmem
      character sls,line*200,ctmp*100,key3*3,key5*5,ch
C
      sls=char(47)
C     ----- From gjf -----
      key3='mem'
      call NJ_seekkey(inp,'%',key3,yes)
      if (yes.ne.0) then
         read(inp,'(a)') line
         call NJ_trim(line,k1,k2); k=index(line,'=')
         mem=line(k+1:k2)
      else
         mem='20MW'
      endif
      k=index(mem,'mw')+index(mem,'MW')
      read(mem(1:k-1),*) kmem
      kmem=kmem*1024*1024
C
      key5='nproc'
      call NJ_seekkey(inp,'%',key5,yes)
      if (yes.ne.0) then
         read(inp,'(a)') line
         call NJ_trim(line,k1,k2); k=index(line,'=')
         nproc=line(k+1:k2)
      else
         nproc='1'
      endif
C
****** read parameter after '#' ******
      ch=' '
      call NJ_seekkey(inp,'#',ch,yes); read(inp,'(a)') line
      call NJ_lower(line)
      i=index(line,'#'); line(i:i)=' '
      if (line(i+1:i+1).ne.' '.and.line(i+2:i+2)==' ') line(i+1:i+1)=' ' ! 2005.05.11 add
      call NJ_trim(line,k1,k2)
      k2=index(line(k1:200),' ')+k1-2
      k3=index(line(1:k2),sls)
      if (k3==0) then
         mthd=line(k1:k2); basis=' '
      else
         mthd=line(k1:k3-1); basis=line(k3+1:k2)
      endif
C
      addi='nosymm scf=(tight,conventional) gfinput noraff'
     &    //' extralink=l316'
C
      if (index(line,'opt').ne.0) then
         if (index(line,'opt=ts')+index(line,'opt(ts').ne.0) then
            runtyp='sadpoint'
         else
            runtyp='optimize'
         endif
      elseif (index(line,'freq').ne.0) then
         runtyp='raman'
      else
         runtyp='energy'
      endif
C
C
      if (io>0) then
         call NJ_trim(mthd,k1,k2)
         write(io,*) 'Method : '//mthd(k1:k2)
         call NJ_trim(basis,k1,k2)
         write(io,*) 'Basis  : '//basis(k1:k2)
         call NJ_trim(runtyp,k1,k2)
         write(io,*) 'Runtype: '//runtyp(k1:k2)
      endif
C
      end
C
C
C --- 2006.05.29 Read AO dipole integrals from exam.dat ---
      subroutine DipInt2(inp,NW,admx,admy,admz)
      implicit none
      integer NW,Nmo,i,j,k,L,inp,L2
      double precision admx(NW,NW),admy(NW,NW),admz(NW,NW)
      double precision,allocatable:: dtmp(:)
C
      L2=NW*(NW+1)/2
      allocate(dtmp(L2))
      call rread(inp, '$AO-DIPOLE-X', L2, dtmp)
      k=0
      do i=1,NW; do j=1,i
         k=k+1;  admx(j,i)=dtmp(k);  admx(i,j)=dtmp(k)
      enddo; enddo
C
      call rread(inp, '$AO-DIPOLE-Y', L2, dtmp)
      k=0
      do i=1,NW; do j=1,i
         k=k+1;  admy(j,i)=dtmp(k);  admy(i,j)=dtmp(k)
      enddo; enddo
C
      call rread(inp, '$AO-DIPOLE-Z', L2, dtmp)
      k=0
      do i=1,NW; do j=1,i
         k=k+1;  admz(j,i)=dtmp(k);  admz(i,j)=dtmp(k)
      enddo; enddo
      deallocate(dtmp)
C
      end
C

c     ##############################################################
c     ##  subroutine NJ_cputim -- Print out total job CPU Time    ##
c     ##  2004.12.24 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################
c     in parent program def. "real*8 Tim0,CPUTim"; "Tim0=CPUTim(0)" for initial time

      subroutine NJ_cputim(IOut,RefTim)
      Implicit Real*8(A-H,O-Z)

 1000  Format(' CPU time: ',I3,' days ',I2,' hours ',I2,' minutes ',
     $    F4.1,' seconds.')

      Time = CPUTim(0) - RefTim
      NDays = (Time / (3600.0d0*24.0d0))
      Time = Time - (NDays*(3600.0d0*24.0d0))
      NHours = (Time / 3600.0d0)
      Time = Time - (NHours*3600.0d0)
      NMin = (Time / 60.0d0)
      Time = Time - (NMin*60.0d0)
      Write(IOut,1000) NDays, NHours, NMin, Time
      Return
      End

      function CPUTim(Junk)
      Implicit Real*8(a-h,o-z)
      Real TimArray(2), ETime
C     CPUTim = ETime(TimArray)
      call tsecnd(tim)
      CPUTim = tim
      Return
      End
C
c     ##############################################################
c     ##  subroutine NJ_cmdline  --  get command line arguments   ##
c     ##  2005.10.15 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################
c
c     arguments are stored at arg(1:narg)
c     arg(0)= initial command; typarg(0)=0
C     default typarg=1
C     For -x (x=A~Z or a-z) typarg=2
C     For -x (x=0~9) typarg=3
C     For -x (x=-) typarg=4
C     For -x (if x is not in "a-z,A-Z,0-9,-" then typarg=-1
c
      subroutine NJ_cmdline(narg,arg,typarg)
      implicit none
      integer marg
      parameter (marg=20)
      integer narg,typarg(0:marg)
      character*100 arg(0:marg)


      integer i,iargc,k
      character ch1,ch2

      arg=' '
      narg=iargc()
      if (narg.gt.marg) narg=marg
      do i=0,narg
         call getarg (i,arg(i))
      end do

      typarg=1
      typarg(0)=0

      do i=1,narg
         ch1=arg(i)(1:1)
         ch2=arg(i)(2:2)
         if (ch1.eq.'-') then
            k=ichar(ch2)
            if (k.ge.65.and.k.le.90.or.k.ge.97.and.k.le.122) then
               typarg(i)=2    ! -"a-z,A-Z"
            elseif (k.ge.48.and.k.le.57) then
               typarg(i)=3    ! -"0-9"
            elseif (k.eq.45) then
               typarg(i)=4      ! -"-"
            else
               typarg(i)=-1
            endif
         endif
      enddo

      end
C
c     ##############################################################
c     ##  subroutine NJ_help  --  Print help if '-h' or '--h'     ##
c     ##  Recently update on Oct 15, 2005 by Wei Li               ##
c     ##############################################################
c
      subroutine NJ_help(narg,arg,typarg,hlp)
      implicit none
      integer marg
      parameter (marg=20)
      integer narg,typarg(0:marg)
      character*100 arg(0:marg)

      integer i,j,k,hlp

      if (narg.eq.0) then
         write(*,*) 'No any string after command!'
         stop
      endif

      i=typarg(1)
      if (i.eq.2.and.arg(1)(2:2).eq.'h') then
         hlp=0
      elseif (i.eq.4) then
         hlp=1
      else
         hlp=-1
      endif

      end
C
C
c     ##############################################################
c     ##  subroutine NJ_infile  --  get input file name from cmd  ##
c     ##  2005.10.15 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################
c
      subroutine LS_infile(narg,arg,typarg,inname,suffix)
      implicit none
      integer marg
      parameter (marg=20)
      integer narg,typarg(0:marg)
      character*100 arg(0:marg)
      character suffix*10


      character inname*(*)
      integer i,j0,j1,j,k,k1,k2 

      do i=1,narg
         j0=typarg(i-1)
         j1=typarg(i)
         if (j1.eq.1.and.(j0.eq.0.or.j0.eq.1)) then
            do j=len(arg(i)),1,-1
               if (arg(i)(j:j).ne.' ') exit
            enddo
            k=len(inname)
            j=min(j,k)
            inname=arg(i)(1:j)
C
            suffix='          '
            call NJ_trim(inname,k1,k2)
            do k=k2,max(k1,k2-10),-1
               if (inname(k:k)=='.') exit
            enddo
            suffix=inname(k+1:k2)
C
            return
         endif
      enddo

      write(*,*) 'Wrong command for running input file!'
      stop
      end
C
c     ##############################################################
c     ##  subroutine NJ_infile  --  get input file name from cmd  ##
c     ##  2005.10.15 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################
c
      subroutine NJ_infile(narg,arg,typarg,inname)
      implicit none
      integer marg
      parameter (marg=20)
      integer narg,typarg(0:marg)
      character*100 arg(0:marg)


      character inname*(*)
      integer i,j0,j1,j,k

      do i=1,narg
         j0=typarg(i-1)
         j1=typarg(i)
         if (j1.eq.1.and.(j0.eq.0.or.j0.eq.1)) then
            do j=len(arg(i)),1,-1
               if (arg(i)(j:j).ne.' ') exit
            enddo
            k=len(inname)
            j=min(j,k)
            inname=arg(i)(1:j)
            return
         endif
      enddo

      write(*,*) 'Wrong command for running input file!'
      stop
      end
C
c     ##############################################################
c     ##  subroutine NJ_outfile -- get output file name from cmd  ##
c     ##  2005.10.15 by Wei Li; Update 2005.10.17 by Wei Li       ##
c     ##############################################################
c
      subroutine NJ_outfile(narg,arg,typarg,inname,ch,ch2,outname)
      implicit none
      integer marg
      parameter (marg=20)
      integer narg,typarg(0:marg)
      character*100 arg(0:marg)

      character inname*(*),outname*(*),ch,ch2*(*)
      integer i,j0,j1,j,k,l

      if (ch==' ') goto 100
      do i=1,narg
         j0=typarg(i-1)
         j1=typarg(i)
         if (j1.eq.1.and.j0.eq.2.and.arg(i-1)(2:2).eq.ch) then
            do j=len(arg(i)),1,-1
               if (arg(i)(j:j).ne.' ') exit
            enddo
            k=len(outname)
            j=min(j,k)
            outname=arg(i)(1:j)
            return
         endif
      enddo

 100  j=len(inname)
      do i=j,1,-1
         if(inname(i:i).eq.'.') exit
      enddo

      k=len(outname)
      l=len(ch2)
      i=min(i,k-l)
      outname=inname(1:i-1)//'.'//ch2

      end
C
c     ##############################################################
c     ##  subroutine NJ_help  --  Print help if '-h' or '--h'     ##
c     ##  Recently update on Oct 15, 2005 by Wei Li               ##
c     ##############################################################
c
      subroutine NJ_argvalu(narg,arg,typarg,ch,np)
      implicit none
C
      integer marg
      parameter (marg=20)
      integer narg,typarg(0:marg),lth,ith
      character*100 arg(0:marg)
      character ch*(*)
      integer i,j,k,np,j0,j1
C
      np=0
      lth=len(ch)
C
      do i=1,narg
         j0=typarg(i-1)
         j1=typarg(i)
         if (j1.eq.1.and.j0.eq.2.and.arg(i-1)(2:lth+1).eq.ch) then
            ith=len(arg(i))
            read(arg(i)(1:ith),*) np
            return
         endif
      enddo
C
      end

c
C --- 2006.12.13 Add
      subroutine NJ_argfind(narg,arg,typarg,ch,yes)
      implicit none
C
      integer marg
      parameter (marg=20)
      integer narg,typarg(0:marg),lth,ith
      character*100 arg(0:marg)
      character ch*(*)
      integer i,j,k,np,j0,j1,yes
C
      yes=0
      lth=len(ch)
C
      do i=1,narg
         j0=typarg(i)
         if (j0.eq.2.and.arg(i)(2:lth+1).eq.ch) then
            yes=1
            return
         endif
      enddo
C
      end
C
c     ##############################################################
c     ##  subroutine NJ_openf  -- open an file, and backup old    ##
c     ##  2004.12.22 by Wei Li; Update 2005.10.17 by Wei Li       ##
c     ##############################################################
c
      subroutine NJ_openf(io,fname,forms)
      implicit none
      integer io,i,k1,k2,k3,system
      character fname*(*),ch,run*256,forms*(*)
      parameter (ch='~')
      logical logi
C     external system

      call NJ_trim(fname,k1,k2)
      k3=len(forms)
      inquire(file=fname(k1:k2),exist=logi)

      run='mv '//fname(k1:k2)//' '//fname(k1:k2)//ch
      if (logi) i=system(run)
      open(io,file=fname(k1:k2),form=forms(1:k3))

      end
C

c     ##############################################################
c     ##  subroutine NJ_trim  --  move blank of two sides         ##
c     ##  2005.01.07 by Wei Li; Update 2005.11.01 by Wei Li       ##
c     ##############################################################
c
      subroutine NJ_trim(line,k1,k2)
      implicit none
      integer k1,k2,i,j
      character line*(*)

      j=len(line)
      do i=1,j
         if (line(i:i).ne.' ') then
            k1=i; exit
         endif
         if (i==j) then
            k1=1; k2=1
            return
         endif
      enddo

      do i=j,1,-1
         if (line(i:i).ne.' ') then
            k2=i; exit
         endif
      enddo

      end
C
c     ##############################################################
c     ##  subroutine NJ_date -- Print current time for system     ##
c     ##  2004.12.24 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################

      subroutine NJ_date(io,note)
      implicit none
      integer io,i
      character datim*26,note*(*)

      i=len(note)
      call GDate(datim)
      write (io,*) note(1:i)//' '//datim(1:24)
      end

      Subroutine GDate(Date1)
      Implicit Integer(A-Z)
      Character*(*) Date1
C     Call FDate(Date1)
      call tmdate(Date1)
      If(Len(Date1).gt.24) Date1(25:) = ' '
      Return
      end
C
c     ##############################################################
c     ##  subroutine NJ_sysinfo  --  show host os & directory     ##
c     ##  2005.12.26 by Wei Li; Update 2008.03.17 by Wei Li       ##
c     ##############################################################
c
      subroutine NJ_sysinfo2(io,snfname,path,user)
      implicit none
      integer io,system,i,j,k,L,itmp
      character sls,line*200,line2*200,line3*200,snfname*100,path*200
      character user*50
C     external system
C
      itmp=55
      call NJ_tmpunit(itmp)
C
C --- 00. USER name
      i=system('echo $USER > '//trim(snfname))
      open(itmp,file=trim(snfname))
      read(itmp,'(a)') line
      user = line(1:50)
      close(itmp)
C
C --- 01. Hostname
      i=system('hostname > '//trim(snfname))
      open(itmp,file=trim(snfname))
      read(itmp,'(a)') line
      do i=100,1,-1
         if (line(i:i).ne.' ') exit
      enddo
      close(itmp)
C --- 02. Operation system
      j=system('uname -m > '//trim(snfname))
      open(itmp,file=trim(snfname))
      read(itmp,'(a)') line2
      do j=100,1,-1
         if (line2(j:j).ne.' ') exit
      enddo
      close(itmp)
C --- 03. Directory
      k=system('pwd > '//trim(snfname))
      open(itmp,file=trim(snfname))
      read(itmp,'(a)') line3
      do k=100,1,-1
         if (line3(k:k).ne.' ') exit
      enddo
      close(itmp,status='delete')
C --- Output
      write(io,*) line(1:i)//':'//line3(1:k)//' ('//line2(1:j)//')'
C
C-WL,PP FOR GET GAMESS-CIM PATH
      sls=char(47)   ! sls='/'
      path=line3
      L=index(path,sls//'tests')
      if (L.ne.0) then
         path(L:200)=' '
      endif
C
      end
C
C
c     ##############################################################
c     ##  subroutine NJ_prtcol -- print column(c1:c2) of mat(n,n) ##
c     ##  2005.12.22 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################
c
c     format: f(x.y) x>7 sugg 12.5,12.7,14.9
c
      subroutine NJ_prtcol(io,n,mat,c1,c2,fm)
      implicit none
      integer i,j,jj,n,io,c1,c2,n5,nf,nc,x,y,k
      real*8 mat(n,n)
      character fm*(*),ch,fm2*10
      character*40 fmt1,fmt2,fmt3,fmt4

      nc=c2-c1+1; n5=nc/5; nf=mod(nc,5)
      fm2=fm; ch=fm2(1:1); k=index(fm2,'.')
      read(fm2(2:k-1),*) x; read(fm2(k+1:10),*) y

      write(fmt1,101) ch,x,y; write(fmt2,102) nf,ch,x,y
 101  format('(i7,5',a1,i2,'.',i2,')')
 102  format('(i7,',i2,a1,i2,'.',i2,')')
      write(fmt3,103) x-7; write(fmt4,104) nf,x-7
 103  format('(3x,5(',i2,'x,i7))')
 104  format('(3x,',i2,'(',i2,'x,i7))')

      do jj=1,n5
         write(io,fmt3) (j,j=c1+(jj-1)*5,c1+jj*5-1)
         write(io,fmt1) (i,(mat(i,j),j=c1+(jj-1)*5,c1+jj*5-1),i=1,n)
C         if (jj.ne.n5.or.nf.ne.0) write(io,*)
      enddo

      if (nf.ne.0) then
         write(io,fmt4)(j,j=c1+n5*5,c2)
         write(io,fmt2) (i,(mat(i,j),j=c1+n5*5,c2),i=1,n)
      endif
      call flshbf(io)

      end
C
C
c     ##############################################################
c     ##  subroutine NJ_prtcol -- print column(c1:c2) of mat(m,n) ##
c     ##  2005.12.22 by Wei Li; Update 2005.12.25 by Wei Li       ##
c     ##############################################################
c
c     format: f(x.y) x>7 sugg 12.5,12.7,14.9
c
      subroutine NJ_prtcol2(io,m,n,mat,c1,c2,fm)
      implicit none
      integer i,j,jj,m,n,io,c1,c2,n5,nf,nc,x,y,k
      double precision mat(m,n)
      character fm*(*),ch,fm2*10
      character*40 fmt1,fmt2,fmt3,fmt4
C
      nc=c2-c1+1; n5=nc/5; nf=mod(nc,5)
      fm2=fm; ch=fm2(1:1); k=index(fm2,'.')
      read(fm2(2:k-1),*) x; read(fm2(k+1:10),*) y
C
      write(fmt1,101) ch,x,y; write(fmt2,102) nf,ch,x,y
 101  format('(i7,5',a1,i2,'.',i2,')')
 102  format('(i7,',i2,a1,i2,'.',i2,')')
      write(fmt3,103) x-7; write(fmt4,104) nf,x-7
 103  format('(3x,5(',i2,'x,i7))')
 104  format('(3x,',i2,'(',i2,'x,i7))')
C
      do jj=1,n5
         write(io,fmt3) (j,j=c1+(jj-1)*5,c1+jj*5-1)
         write(io,fmt1) (i,(mat(i,j),j=c1+(jj-1)*5,c1+jj*5-1),i=1,m)
      enddo
C
      if (nf.ne.0) then
         write(io,fmt4)(j,j=c1+n5*5,c2)
         write(io,fmt2) (i,(mat(i,j),j=c1+n5*5,c2),i=1,m)
      endif
      call flshbf(io)
C
      end
C
C
c     ##############################################################
c     ##  subroutine NJ_prtcol -- print column(c1:c2) of mat(m,n) ##
c     ##  2005.12.22 by Wei Li; Update 2005.12.25 by Wei Li       ##
c     ##############################################################
c
c     format: f(x.y) x>7 sugg 12.5,12.7,14.9
c
      subroutine NJ_prtcol3(io,m,n,mat0,mat,c1,c2,fm)
      implicit none
      integer i,j,jj,m,n,io,c1,c2,n5,nf,nc,x,y,k,mat0(n,m)
      double precision mat(m,n)
      character fm*(*),ch,fm2*10
      character*40 fmt1,fmt2,fmt3,fmt4
C
      nc=c2-c1+1; n5=nc/5; nf=mod(nc,5)
      fm2=fm; ch=fm2(1:1); k=index(fm2,'.')
      read(fm2(2:k-1),*) x; read(fm2(k+1:10),*) y
C
      write(fmt1,101) ch,x,y; write(fmt2,102) nf,nf,ch,x,y
 101  format('(i4,1x,5i4,5',a1,i2,'.',i2,')')
 102  format('(i4,1x,',i2,'i4,',i2,a1,i2,'.',i2,')')
      write(fmt3,103) x-7; write(fmt4,104) nf,nf,x-7
 103  format('(5x,5i4,5(',i2,'x,i7))')
 104  format('(5x,',i2,'i4,',i2,'(',i2,'x,i7))')
C
      do jj=1,n5
         write(io,fmt3) (j,j=c1+(jj-1)*5,c1+jj*5-1),
     &                  (j,j=c1+(jj-1)*5,c1+jj*5-1)
         write(io,fmt1)
     &  (i,(mat0(j,i),j=c1+(jj-1)*5,c1+jj*5-1),
     &      (mat(i,j),j=c1+(jj-1)*5,c1+jj*5-1),i=1,m)
         if (jj.ne.n5.or.nf.ne.0) write(io,'(1x,74(''-''))')
      enddo
C
      if (nf.ne.0) then
         write(io,fmt4)(j,j=c1+n5*5,c2),(j,j=c1+n5*5,c2)
         write(io,fmt2) (i,(mat0(j,i),j=c1+n5*5,c2),
     &                  (mat(i,j),j=c1+n5*5,c2),i=1,m)
      endif
      call flshbf(io)
C
      end
C
C
c     ##############################################################
c     ##  subroutine NJ_prtcol -- print column(c1:c2) of mat(m,n) ##
c     ##  2005.12.22 by Wei Li; Update 2008.08.06 by Wei Li       ##
c     ##############################################################
c
c     format: f(x.y) x>7 sugg 12.5,12.7,14.9
c
      subroutine NJ_prtcol4(io,m,n,mat0,mat,r1,r2,c1,c2,fm)
      implicit none
      integer i,j,jj,m,n,io,c1,c2,n5,nf,nc,x,y,k,mat0(m,n),r1,r2
      double precision mat(m,n)
      character fm*(*),ch,fm2*10
      character*40 fmt1,fmt2,fmt3,fmt4
C
      if (r1.lt.1.or.r2.gt.m) then
         write(*,*) 'Wrong range for r1-r2'
         write(*,*) 'switch to full row output'
         r1=1
         r2=m
      endif
C
      nc=c2-c1+1; n5=nc/5; nf=mod(nc,5)
      fm2=fm; ch=fm2(1:1); k=index(fm2,'.')
      read(fm2(2:k-1),*) x; read(fm2(k+1:10),*) y
C
      write(fmt1,101) ch,x,y; write(fmt2,102) nf,nf,ch,x,y
 101  format('(i4,1x,5i4,5',a1,i2,'.',i2,')')
 102  format('(i4,1x,',i2,'i4,',i2,a1,i2,'.',i2,')')
      write(fmt3,103) x-7; write(fmt4,104) nf,nf,x-7
 103  format('(5x,5i4,5(',i2,'x,i7))')
 104  format('(5x,',i2,'i4,',i2,'(',i2,'x,i7))')
C
      do jj=1,n5
         write(io,fmt3) (j,j=c1+(jj-1)*5,c1+jj*5-1),
     &                  (j,j=c1+(jj-1)*5,c1+jj*5-1)
         write(io,fmt1)
     &  (i,(mat0(i,j),j=c1+(jj-1)*5,c1+jj*5-1),
     &      (mat(i,j),j=c1+(jj-1)*5,c1+jj*5-1),i=r1,r2)
         if (jj.ne.n5.or.nf.ne.0) write(io,'(1x,74(''-''))')
      enddo
C
      if (nf.ne.0) then
         write(io,fmt4)(j,j=c1+n5*5,c2),(j,j=c1+n5*5,c2)
         write(io,fmt2) (i,(mat0(i,j),j=c1+n5*5,c2),
     &                  (mat(i,j),j=c1+n5*5,c2),i=r1,r2)
      endif
      call flshbf(io)
C
      end
C

C --- (Mat2)mm = (X(T))mn (Mat)nn (X)nm
C --- 2006.02.24 Modified 
C --- 2006.03.14 Modified 
C --- 2009.09.22 Modified allocate(Y)
      subroutine NJ_tfock1(io,n,m,Mat,X,Mat2)
      implicit none
      integer io,i,j,k,l,m,n
      real*8 Mat(n,n),X(n,m),Mat2(m,m),PP
      double precision,dimension(:,:),allocatable::Y
      allocate(Y(n,m))
C
      Y=0d0
      do j=1,m; do i=1,n
         PP=0d0
         do k=1,n
            PP=PP+Mat(i,k)*X(k,j)
         enddo
         Y(i,j)=PP
      enddo; enddo
C
      Mat2=0d0
      do j=1,m; do i=1,m
         PP=0d0
         do k=1,n
            PP=PP+X(k,i)*Y(k,j)
         enddo
         Mat2(i,j)=PP
         if (dabs(Mat2(i,j))<1d-10) Mat2(i,j)=0d0    ! 2008.02.14 1d-11 --> 1d-10
      enddo; enddo
C
      if (io>0) then
         write(io,*) '+++ Transformed matrix B=X^{T}AX '
     &             //'(keep value >1E-10) +++'
         call NJ_prtsym(io,m,Mat2,'d14.6')
         write(io,*)
      endif
      deallocate(Y)
C
      end
C
C
C --- (Mat2)mm = (X^T)mn (Mat)nn (X)nm
C --- 2006.02.24 Modified 
C --- 2006.03.14 Modified 
C --- 2008.02.21 Modified 
C --- 2009.09.22 Modified allocate(Y)
      subroutine NJ_tfock2(io,n,m,Mat,X,Mat2)
      implicit none
      integer io,i,j,k,l,m,n
      real*8 Mat(n,n),X(n,m),Mat2(m,m),PP
      double precision,dimension(:,:),allocatable::Y
      allocate(Y(n,m))
C
C --- Y=MX: Y_{ij}=\sum_k M_{ik}*X_{kj}
      Y=0d0
      do j=1,m; do i=1,n
         PP=0d0
         do k=1,n
            PP=PP+Mat(i,k)*X(k,j)
         enddo
         Y(i,j)=PP
      enddo; enddo
C
C --- M2=X^{T}Y: M2_{ij}=\sum_k X_{ki}*Y_{kj}
      Mat2=0d0
      do j=1,m; do i=1,m
         PP=0d0
         do k=1,n
            PP=PP+X(k,i)*Y(k,j)
         enddo
         Mat2(i,j)=PP
      enddo; enddo
C
      if (io>0) then
         write(io,*) '+++ Transformed matrix B=X^{T}AX +++'
         call NJ_prtsym(io,m,Mat2,'d14.6')
         write(io,*)
      endif
      deallocate(Y)
C
      end
C
C --- (Mat2)mm = (X^T)mn (Mat)nn (X)nm
C --- 2006.02.24 Modified 
C --- 2006.03.14 Modified 
C --- 2008.02.21 Modified 
C --- 2009.09.22 Modified allocate(Y)
      subroutine NJ_tfock(io,n,m,Mat,X,Mat2)
      implicit none
      integer io,i,j,k,l,m,n
      real*8 Mat(n,n),X(n,m),Mat2(m,m),PP
      double precision,dimension(:,:),allocatable::Y
      allocate(Y(m,n))
C
C --- Y=X^{T}M: Y_{ij}=\sum_k X_{ki}*M_{kj}
      Y=0d0
      do j=1,n; do i=1,m
         PP=0d0
         do k=1,n
            PP=PP+X(k,i)*Mat(k,j)
         enddo
         Y(i,j)=PP
      enddo; enddo
C
C --- M2=YX: M2_{ij}=\sum_k Y_{ik}*X_{kj}
      Mat2=0d0
      do j=1,m; do i=1,m
         PP=0d0
         do k=1,n
            PP=PP+Y(i,k)*X(k,j)
         enddo
         Mat2(i,j)=PP
         if (dabs(Mat2(i,j))<1d-14) Mat2(i,j)=0d0    ! 2008.02.21 1d-10 --> 1d-12
      enddo; enddo
C
      if (io>0) then
         write(io,*) '+++ Transformed matrix B=X^{T}AX (kept>1E-14) +++'
         call NJ_prtsym(io,m,Mat2,'d14.6')
         write(io,*)
      endif
      deallocate(Y)
C
      end
C
C --- 2009.09.22 Modified allocate(Y)
C --- (Mat2)mm = (X(T))mn (Mat)nn (X)nm
      subroutine NJ_tfock0(io,n,m,Mat,X,Mat2)
      implicit none
      integer io,i,j,k,l,m,n
      real*8 Mat(n,n),X(n,m),Mat2(m,m),PP
      double precision,dimension(:,:),allocatable::Y
      allocate(Y(n,m))
C
      Mat2=0d0
      do j=1,m; do i=1,m
         do k=1,n; do l=1,n
            Mat2(i,j)=Mat2(i,j)+X(l,i)*Mat(l,k)*X(k,j)
         enddo; enddo
         if (dabs(Mat2(i,j))<1d-11) Mat2(i,j)=0d0
      enddo; enddo
C
      if (io>0) then
         write(io,*) '+++ Transformed fock matrix +++'
         call NJ_prtsym(io,m,Mat2,'d14.6')
         write(io,*)
      endif
      deallocate(Y)
C
      end
C
C
c     ##############################################################
c     ##  subroutine NJ_tmpunit -- Auto find an unused file unit  ##
c     ##  2005.10.18 by Wei Li; Update 2005.10.18 by Wei Li       ##
c     ##############################################################
c
      subroutine NJ_tmpunit(tmp2)
      implicit none
      integer tmp2
      logical lg

      if (tmp2<=0 .or. tmp2> 10000) tmp2=50
100   inquire(unit=tmp2,opened=lg)
      if (lg) then
         tmp2=tmp2+1
         goto 100
      endif

      end

c     ##############################################################
c     ##  subroutine NJ_prtsym  --  print symmetric mat(n,n)      ##
c     ##  2005.12.22 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################
c
c     format: f(x.y) x>7 sugg 12.5,12.7,14.9
c
      subroutine NJ_prtsym(io,n,mat,fm)
      implicit none
      integer i,j,jj,n,io,n5,nf,nc,x,y,ini,ifi,k
      real*8 mat(n,n)
      character fm*(*),ch,fm2*10
      character*40 fmt1,fmt2,fmt3,fmt4

      n5=n/5; nf=mod(n,5)
      fm2=fm; ch=fm2(1:1); k=index(fm2,'.')
      read(fm2(2:k-1),*) x; read(fm2(k+1:10),*) y

      write(fmt1,101) ch,x,y; write(fmt2,102) nf,ch,x,y
 101  format('(i7,5',a1,i2,'.',i2,')')
 102  format('(i7,',i2,a1,i2,'.',i2,')')
      write(fmt3,103) x-7; write(fmt4,104) nf,x-7
 103  format('(3x,5(',i2,'x,i7))')
 104  format('(3x,',i2,'(',i2,'x,i7))')

      do jj=1,n5
         ini=1+(jj-1)*5
         write(io,fmt3) (j,j=ini,jj*5)
         do k=1+(jj-1)*5,n
            ifi=min(jj*5,k)
            write(io,fmt1) k,(mat(k,j),j=ini,ifi)
         enddo
      enddo

      if (nf.ne.0) then
         ini=n-nf+1
         write(io,fmt4)(j,j=ini,n)
         do k=ini,n
            write(io,fmt2) k,(mat(k,j),j=ini,k)
         enddo
      endif
      call flshbf(io)

      end
C
c     ##############################################################
c     ##  subroutine NJ_prtsym  --  print symmetric mat(n,n)      ##
c     ##  2005.12.22 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################
c
c     format: f(x.y) x>7 sugg 12.5,12.7,14.9
c
      subroutine NJ_prtsym2(io,n,m,mat,fm)
      implicit none
      integer i,j,jj,m,n,io,n5,nf,nc,x,y,ini,ifi,k
      double precision mat(m,m)
      character fm*(*),ch,fm2*10
      character*40 fmt1,fmt2,fmt3,fmt4
C
      n5=n/5; nf=mod(n,5)
      fm2=fm; ch=fm2(1:1); k=index(fm2,'.')
      read(fm2(2:k-1),*) x; read(fm2(k+1:10),*) y
C
      write(fmt1,101) ch,x,y; write(fmt2,102) nf,ch,x,y
 101  format('(i7,5',a1,i2,'.',i2,')')
 102  format('(i7,',i2,a1,i2,'.',i2,')')
      write(fmt3,103) x-7; write(fmt4,104) nf,x-7
 103  format('(3x,5(',i2,'x,i7))')
 104  format('(3x,',i2,'(',i2,'x,i7))')
C
      do jj=1,n5
         ini=1+(jj-1)*5
         write(io,fmt3) (j,j=ini,jj*5)
         do k=1+(jj-1)*5,n
            ifi=min(jj*5,k)
            write(io,fmt1) k,(mat(k,j),j=ini,ifi)
         enddo
      enddo
C
      if (nf.ne.0) then
         ini=n-nf+1
         write(io,fmt4)(j,j=ini,n)
         do k=ini,n
            write(io,fmt2) k,(mat(k,j),j=ini,k)
         enddo
      endif
      call flshbf(io)
C
      end
C
C     ##############################################################
C     ##  subroutine NJ_walltim -- Print total job wall Time      ##
C     ##  2004.12.24 by Wei Li; Update 2006.03.06 by Wei Li       ##
C     ##############################################################
C           this routine gives errors for TIME() on some systems.
C           it is never called, so rather than remedy, comment it out.
C
C     argument 'wall0' would be set by somewhere at start of run,
C        "integer(kind=4) Wall0,TIME"
C        "Wall0=TIME()"
C     for initial time
C---  subroutine NJ_walltim(io,Wall0)
C---  Implicit double precision (A-H,O-Z)
C---  integer(kind=4) TIME,Wall,Wall0
C---  external TIME
C
C---1 Format(' WALL time:',I3,' days ',I2,' hours ',I2,' minutes ',
C--- $    I4,' seconds.')

C---  Wall = TIME()-Wall0
C---  NDays= Wall/(3600*24)
C---  Wall = Wall-NDays*(3600*24)
C---  NHours= Wall/3600
C---  Wall = Wall-NHours*3600
C---  NMin = Wall/60
C---  Wall = Wall-NMin*60
C---  Write(io,1) NDays, NHours, NMin, Wall
C---  Return
C---  End
C
C
C --- Boys Localization Since  2006.02.24 Ver 0.01 by liwei ---
C     Update 2006.02.25 Ver 0.03
C --- 2006.02.27 update  epst 12->13
C --- 2008.02.10 update  ADD nprtcyc
      subroutine NJ_boyloc(io,nat,nbs,nmo,ini,ifi,smo,mdmx,mdmy,mdmz,
     &     eps,epst,maxcyc,nprint,np,nprtcyc,ierr)
      implicit none
      integer io,nat,nbs,nmo,ini,ifi,maxcyc,nprint,np,ierr
      integer i,j,k,l,m,n,maxcycle,nprtcyc,NMin
      double precision smo(nbs,nmo),eps,epst,PP,QQ,P1,P2,P3,P4,P5,P6
      double precision Tim,Tim1,CPUTim,Sec,Delta,Aij,Bij,piik,pijk,pjjk
      double precision SINA,COSA,SIN2A,COS2A,SIN4A,COS4A,TT,SumD
      double precision riix,riiy,riiz,rjjx,rjjy,rjjz,rijx,rijy,rijz
      double precision px,py,pz
      double precision mdmx(nmo,nmo),mdmy(nmo,nmo),mdmz(nmo,nmo),fac
      parameter(fac=2.541766d0)
      external CPUTim
C
      Tim=CPUTim(0)
C
      if (eps<=1d-16) eps=1d-7
      if (epst<=1d-16) epst=1d-13
      maxcycle=maxcyc
      if (maxcyc<=0) maxcycle=10000
      write(io,'('' Boys Localization of MOs:'',i4,'' -->'',i4)')
     &      ini,ifi
      write(io,'('' Maxcycle ='',i8)') maxcycle
      write(io,'('' Threshold (Converg,Rotation) ='',2d11.2)') eps,epst
C
      SumD=0d0
      do i=ini,ifi
         SumD=SumD+mdmx(i,i)*mdmx(i,i)
         SumD=SumD+mdmy(i,i)*mdmy(i,i)
         SumD=SumD+mdmz(i,i)*mdmz(i,i)
      enddo
      SumD=SumD*fac*fac
C
      write(io,'('' Initial Localization Sum (Debye^2) ='',f16.6)') SumD
      write(io,707)
      write(io,700)
      write(io,707)
      call flshbf(io)
C
      do 200 m=1,maxcycle
         if (mod(m,nprtcyc)==1) Tim1=CPUTim(0)
         Delta=0d0
         do i=ini,ifi-1
            do j=i+1,ifi
               riix=mdmx(i,i); riiy=mdmy(i,i); riiz=mdmz(i,i)
               rjjx=mdmx(j,j); rjjy=mdmy(j,j); rjjz=mdmz(j,j)
               rijx=mdmx(j,i); rijy=mdmy(j,i); rijz=mdmz(j,i)
               px=riix-rjjx;   py=riiy-rjjy;   pz=riiz-rjjz
C
               Aij=rijx*rijx+rijy*rijy+rijz*rijz-(px*px+py*py+pz*pz)/4d0
               Bij=rijx*px+rijy*py+rijz*pz
C
               if (dabs(Aij)<1d-10.and.dabs(Bij)<1d-10) cycle
C
               P1=dsqrt(Aij*Aij+Bij*Bij)
               COS4A=-Aij/P1
               SIN4A=Bij/P1
C
               COS2A=dsqrt((1d0+COS4A)/2d0)
               SIN2A=dsqrt((1d0-COS4A)/2d0)
               COSA=dsqrt((1d0+COS2A)/2d0)
               SINA=dsqrt((1d0-COS2A)/2d0)
               if (SIN4A<0d0) then
                  COS2A=-COS2A
                  TT=COSA
                  COSA=SINA
                  SINA=TT
               endif
C
               if (dabs(COSA-1d0).lt.epst) cycle
               if (dabs(SINA-1d0).lt.epst) cycle
C
               PP=P1*(1d0-COS4A)
               Delta=Delta+PP
      
               do k=1,nbs
                  TT=smo(k,i)
                  smo(k,i)=COSA*TT+SINA*smo(k,j)
                  smo(k,j)=COSA*smo(k,j)-SINA*TT
               enddo
!              TT=eigen(i)
!              eigen(i)=COSA*TT+SINA*eigen(j)
!              eigen(j)=COSA*eigen(j)-SINA*TT
C     
C ---          Transform Dipole Integrals over MOs
               P2=SIN2A
               P1=P2/2d0
               P3=(1d0+COS2A)/2d0
               P4=(1d0-COS2A)/2d0
               P5=COS2A
C --- X Direct
               P6=rijx*P2
               mdmx(i,i)=riix*P3+rjjx*P4+P6
               mdmx(j,j)=riix*P4+rjjx*P3-P6
               mdmx(j,i)=(rjjx-riix)*P1+rijx*P5
               mdmx(i,j)=mdmx(j,i)
               do n=ini,ifi
                  if (n==i.or.n==j) cycle
                  PP=mdmx(i,n)
                  mdmx(i,n)=PP*COSA+mdmx(j,n)*SINA
                  mdmx(j,n)=mdmx(j,n)*COSA-PP*SINA
                  mdmx(n,i)=mdmx(i,n)
                  mdmx(n,j)=mdmx(j,n)
               enddo
C --- X Direct
               P6=rijy*P2
               mdmy(i,i)=riiy*P3+rjjy*P4+P6
               mdmy(j,j)=riiy*P4+rjjy*P3-P6
               mdmy(j,i)=(rjjy-riiy)*P1+rijy*P5
               mdmy(i,j)=mdmy(j,i)
               do n=ini,ifi
                  if (n==i.or.n==j) cycle
                  PP=mdmy(i,n)
                  mdmy(i,n)=PP*COSA+mdmy(j,n)*SINA
                  mdmy(j,n)=mdmy(j,n)*COSA-PP*SINA
                  mdmy(n,i)=mdmy(i,n)
                  mdmy(n,j)=mdmy(j,n)
               enddo
C --- X Direct
               P6=rijz*P2
               mdmz(i,i)=riiz*P3+rjjz*P4+P6
               mdmz(j,j)=riiz*P4+rjjz*P3-P6
               mdmz(j,i)=(rjjz-riiz)*P1+rijz*P5
               mdmz(i,j)=mdmz(j,i)
               do n=ini,ifi
                  if (n==i.or.n==j) cycle
                  PP=mdmz(i,n)
                  mdmz(i,n)=PP*COSA+mdmz(j,n)*SINA
                  mdmz(j,n)=mdmz(j,n)*COSA-PP*SINA
                  mdmz(n,i)=mdmz(i,n)
                  mdmz(n,j)=mdmz(j,n)
               enddo
 
            enddo
         enddo
C
         k=ifi-ini+1
         SumD=SumD+Delta*fac*fac
         QQ=dsqrt(2d0*Delta/(k*(k-1)))
C
         if (mod(m,nprtcyc)==0) then
            Sec=CPUTim(0)-Tim1
            write(io,702)m,SumD,Delta,QQ,Sec
            call flshbf(io)
         endif
C
         if (dabs(QQ)<eps) then
            write(io,707)
            write(io,701) m
            ierr=0
            exit
         endif
C 
         if (m==maxcyc) then
            ierr=1
            write(io,707)
            write(io,703) m
         endif
200   enddo
C
      write(io,'('' Final Localization Sum (Debye^2) ='',f16.6)') SumD
      Sec=CPUTim(0)-Tim
      NMin=Sec/60
      Sec=Sec-NMin*60
      write(io,704) NMin,Sec
C
      write(io,*)
C
      if (nprint==1) then
         write(io,*) '+++ Localized MOs by Boys Localization +++'
!        write(io,'('' Eigenvalues:'',5f11.6)') (eigen(i),i=ini,ifi)
         call NJ_prtcol2(io,nbs,nmo,smo,ini,ifi,'f11.6')
         write(io,*)
      endif
      call flshbf(io)
C
 700  format(
     & '  Iter        Loc-Sum     Delta-Sum     Orb-Change    Time')
 701  format(' Boys Localization Completed After',i11,' Cycle')
 702  format(i5,f17.7,2d14.5,f7.1,'s')
 703  format(' Boys Localization Failed After',i14,' Cycle')
 704  format(' Localization CPU Time: ',i6,' minutes',f5.1,' seconds')
 707  format(1x,58('-'))
C
      end
C
C --- Boys Localization Since  2006.02.24 Ver 0.01 by liwei ---
C     Update 2006.02.25 Ver 0.03
C --- 2006.02.27 update  epst 12->13
      subroutine NJ_boyloc2(io,nat,nbs,nmo,ini,ifi,smo,mdmx,mdmy,mdmz,
     &     eps,epst,maxcyc,nprint,np,ierr)
      implicit none
      integer io,nat,nbs,nmo,ini,ifi,maxcyc,nprint,np,ierr
      integer i,j,k,l,m,n,maxcycle,nprtcyc,NMin
      double precision smo(nbs,nmo),eps,epst,PP,QQ,P1,P2,P3,P4,P5,P6
      double precision Tim,Tim1,CPUTim,Sec,Delta,Aij,Bij,piik,pijk,pjjk
      double precision SINA,COSA,SIN2A,COS2A,SIN4A,COS4A,TT,SumD
      double precision riix,riiy,riiz,rjjx,rjjy,rjjz,rijx,rijy,rijz
      double precision px,py,pz
      double precision mdmx(nmo,nmo),mdmy(nmo,nmo),mdmz(nmo,nmo),fac
      parameter(fac=2.541766d0)
      external CPUTim
C
      Tim=CPUTim(0)
C
      nprtcyc=10
      if (eps<=1d-16) eps=1d-7
      if (epst<=1d-16) epst=1d-13
      maxcycle=maxcyc
      if (maxcyc<=0) maxcycle=10000
      write(io,*) 'Localization Program by W. Li and S. Li '
     &          //'in Nanjing University on May 2007'
      write(io,'('' Boys Localization of MOs:'',i4,'' -->'',i4)')
     &      ini,ifi
      write(io,'('' Maxcycle ='',i8)') maxcycle
      write(io,'('' Threshold (Converg,Rotation) ='',2d11.2)') eps,epst
C
      SumD=0d0
      do i=ini,ifi
         SumD=SumD+mdmx(i,i)*mdmx(i,i)
         SumD=SumD+mdmy(i,i)*mdmy(i,i)
         SumD=SumD+mdmz(i,i)*mdmz(i,i)
      enddo
      SumD=SumD*fac*fac
C
      write(io,'('' Initial Localization Sum (Debye^2) ='',f16.6)') SumD
      write(io,707)
      write(io,700)
      write(io,707)
      call flshbf(io)
C
      do 200 m=1,maxcycle
         if (mod(m,nprtcyc)==1) Tim1=CPUTim(0)
         Delta=0d0
         do i=ini,ifi-1
            do j=i+1,ifi
               riix=mdmx(i,i); riiy=mdmy(i,i); riiz=mdmz(i,i)
               rjjx=mdmx(j,j); rjjy=mdmy(j,j); rjjz=mdmz(j,j)
               rijx=mdmx(j,i); rijy=mdmy(j,i); rijz=mdmz(j,i)
               px=riix-rjjx;   py=riiy-rjjy;   pz=riiz-rjjz
C
               Aij=rijx*rijx+rijy*rijy+rijz*rijz-(px*px+py*py+pz*pz)/4d0
               Bij=rijx*px+rijy*py+rijz*pz
C
               if (dabs(Aij)<1d-10.and.dabs(Bij)<1d-10) cycle
C
               P1=dsqrt(Aij*Aij+Bij*Bij)
               COS4A=-Aij/P1
               SIN4A=Bij/P1
C
               COS2A=dsqrt((1d0+COS4A)/2d0)
               SIN2A=dsqrt((1d0-COS4A)/2d0)
               COSA=dsqrt((1d0+COS2A)/2d0)
               SINA=dsqrt((1d0-COS2A)/2d0)
               if (SIN4A<0d0) then
                  COS2A=-COS2A
                  TT=COSA
                  COSA=SINA
                  SINA=TT
               endif
C
               if (dabs(COSA-1d0).lt.epst) cycle
               if (dabs(SINA-1d0).lt.epst) cycle
C
               PP=P1*(1d0-COS4A)
               Delta=Delta+PP
      
               do k=1,nbs
                  TT=smo(k,i)
                  smo(k,i)=COSA*TT+SINA*smo(k,j)
                  smo(k,j)=COSA*smo(k,j)-SINA*TT
               enddo
C
C ---          Transform Dipole Integrals over MOs
               P2=SIN2A
               P1=P2/2d0
               P3=(1d0+COS2A)/2d0
               P4=(1d0-COS2A)/2d0
               P5=COS2A
C --- X Direct
               P6=rijx*P2
               mdmx(i,i)=riix*P3+rjjx*P4+P6
               mdmx(j,j)=riix*P4+rjjx*P3-P6
               mdmx(j,i)=(rjjx-riix)*P1+rijx*P5
               mdmx(i,j)=mdmx(j,i)
               do n=ini,ifi
                  if (n==i.or.n==j) cycle
                  PP=mdmx(i,n)
                  mdmx(i,n)=PP*COSA+mdmx(j,n)*SINA
                  mdmx(j,n)=mdmx(j,n)*COSA-PP*SINA
                  mdmx(n,i)=mdmx(i,n)
                  mdmx(n,j)=mdmx(j,n)
               enddo
C --- Y Direct
               P6=rijy*P2
               mdmy(i,i)=riiy*P3+rjjy*P4+P6
               mdmy(j,j)=riiy*P4+rjjy*P3-P6
               mdmy(j,i)=(rjjy-riiy)*P1+rijy*P5
               mdmy(i,j)=mdmy(j,i)
               do n=ini,ifi
                  if (n==i.or.n==j) cycle
                  PP=mdmy(i,n)
                  mdmy(i,n)=PP*COSA+mdmy(j,n)*SINA
                  mdmy(j,n)=mdmy(j,n)*COSA-PP*SINA
                  mdmy(n,i)=mdmy(i,n)
                  mdmy(n,j)=mdmy(j,n)
               enddo
C --- Z Direct
               P6=rijz*P2
               mdmz(i,i)=riiz*P3+rjjz*P4+P6
               mdmz(j,j)=riiz*P4+rjjz*P3-P6
               mdmz(j,i)=(rjjz-riiz)*P1+rijz*P5
               mdmz(i,j)=mdmz(j,i)
               do n=ini,ifi
                  if (n==i.or.n==j) cycle
                  PP=mdmz(i,n)
                  mdmz(i,n)=PP*COSA+mdmz(j,n)*SINA
                  mdmz(j,n)=mdmz(j,n)*COSA-PP*SINA
                  mdmz(n,i)=mdmz(i,n)
                  mdmz(n,j)=mdmz(j,n)
               enddo
 
            enddo
         enddo
C
         k=ifi-ini+1
         SumD=SumD+Delta*fac*fac
         QQ=dsqrt(2d0*Delta/(k*(k-1)))
C
         if (mod(m,nprtcyc)==0) then
            Sec=CPUTim(0)-Tim1
            write(io,702)m,SumD,Delta,QQ,Sec
            call flshbf(io)
         endif
C
         if (dabs(QQ)<eps) then
            write(io,707)
            write(io,701) m
            ierr=0
            exit
         endif
C 
         if (m==maxcyc) then
            ierr=1
            write(io,707)
            write(io,703) m
         endif
200   enddo
C
      write(io,'('' Final Localization Sum (Debye^2) ='',f16.6)') SumD
      Sec=CPUTim(0)-Tim
      NMin=Sec/60
      Sec=Sec-NMin*60
      write(io,704) NMin,Sec
C
      if (nprint==1) then
         write(io,*) '+++ Localized MOs by Boys Localization +++'
         call NJ_prtcol2(io,nbs,nmo,smo,ini,ifi,'f11.6')
      endif
      call flshbf(io)
C
 700  format(
     & '  Iter        Loc-Sum     Delta-Sum     Orb-Change    Time')
 701  format(' Boys Localization Completed After',i11,' Cycle')
 702  format(i5,f17.7,2d14.5,f7.1,'s')
 703  format(' Boys Localization Failed After',i14,' Cycle')
 704  format(' Localization CPU Time: ',i6,' minutes',f5.1,' seconds')
 707  format(1x,58('-'))
C
      end
C
C
C --- Begin Pipek-Mezey Localization
C --- 2006.02.18 update
C --- 2006.02.25 update 
C --- 2006.02.27 update   epst 12->13
      subroutine NJ_poploc(io,nat,nbs,nmo,ini,ifi,smo,sov,tbs,
     &     eps,epst,maxcyc,nprint,np,ierr)
      implicit none
      integer io,nat,nbs,nmo,ini,ifi,tbs(nbs),maxcyc,nprint,np,ierr
      integer i,j,k,l,m,n,maxcycle,nprtcyc,NMin
      double precision smo(nbs,nmo),sov(nbs,nbs),eps,PP,QQ,P1,P2,P3
      double precision P4,P5,P6
      double precision Tim,Tim1,CPUTim,Sec,Delta,Aij,Bij,piik,pijk
      double precision pjjk,epst
      double precision SINA,COSA,SIN2A,COS2A,SIN4A,COS4A,TT,SumD
      external CPUTim
      real*8,dimension(:,:,:),allocatable::POP
C
      Tim=CPUTim(0)
      nprtcyc=10
      if (eps<=1d-16) eps=1d-7
      if (epst<=1d-16) epst=1d-13
C
      maxcycle=maxcyc
      if (maxcyc<=0) maxcycle=10000
      write(io,*) 'Localization Program by W. Li and S. Li '
     &          //'in Nanjing University on May 2007'
      write(io,'('' Pipek-Mezey Localization of MOs:'',i4,'' -->'',i4)')
     &      ini,ifi
      write(io,'('' Maxcycle ='',i8)') maxcycle
      write(io,'('' Threshold (Converg,Rotation) ='',2d11.2)') eps,epst
C
C --- Calc population ---
      allocate(POP(ini:ifi,ini:ifi,nat))
      call NJ_calpop(io,nat,nbs,nmo,ini,ifi,smo,sov,tbs,POP,np,ierr)
C
      SumD=0d0
      do i=ini,ifi
         do k=1,nat
            SumD=SumD+POP(i,i,k)*POP(i,i,k)
         enddo
      enddo
C
      write(io,'('' Initial Localization Sum ='',f16.6)') SumD
      write(io,707)
      write(io,700)
      write(io,707)
      call flshbf(io)
C
      do 200 m=1,maxcycle
         if (mod(m,nprtcyc)==1) Tim1=CPUTim(0)
         Delta=0d0
         do i=ini,ifi-1
            do j=i+1,ifi
               Aij=0d0; Bij=0d0
               do k=1,nat
                  piik=POP(i,i,k)
                  pjjk=POP(j,j,k)
                  pijk=POP(j,i,k)
C     
                  P1=piik-pjjk
                  Aij=Aij+pijk*pijk-P1*P1/4d0
                  Bij=Bij+pijk*P1
               enddo
               if (dabs(Aij)<1d-10.and.dabs(Bij)<1d-10) cycle
C     
               P1=dsqrt(Aij*Aij+Bij*Bij)
               COS4A=-Aij/P1
               SIN4A=Bij/P1
C     
               COS2A=dsqrt((1d0+COS4A)/2d0)
               SIN2A=dsqrt((1d0-COS4A)/2d0)
               COSA=dsqrt((1d0+COS2A)/2d0)
               SINA=dsqrt((1d0-COS2A)/2d0)
               if (SIN4A<0d0) then
                  COS2A=-COS2A
                  TT=COSA
                  COSA=SINA
                  SINA=TT
               endif
C     
               if (dabs(COSA-1d0).lt.epst) cycle
               if (dabs(SINA-1d0).lt.epst) cycle
C     
               PP=P1*(1d0-COS4A)
               Delta=Delta+PP
C     
               do k=1,nbs
                  TT=smo(k,i)
                  smo(k,i)=COSA*TT+SINA*smo(k,j)
                  smo(k,j)=COSA*smo(k,j)-SINA*TT
               enddo
C     
               P2=SIN2A
               P1=P2/2d0
               P3=(1d0+COS2A)/2d0
               P4=(1d0-COS2A)/2d0
               P5=COS2A
               do k=1,nat
                  piik=POP(i,i,k)
                  pjjk=POP(j,j,k)
                  pijk=POP(j,i,k)
                  P6=pijk*P2
                  POP(i,i,k)=piik*P3+pjjk*P4+P6
                  POP(j,j,k)=piik*P4+pjjk*P3-P6
                  POP(j,i,k)=(pjjk-piik)*P1+pijk*P5
                  POP(i,j,k)=POP(j,i,k)
C     
                  do n=ini,ifi
                     if (n==i.or.n==j) cycle
                     PP=POP(i,n,k)
                     POP(i,n,k)=PP*COSA+POP(j,n,k)*SINA
                     POP(j,n,k)=POP(j,n,k)*COSA-PP*SINA
                     POP(n,i,k)=POP(i,n,k)
                     POP(n,j,k)=POP(j,n,k)
                  enddo
               enddo
            enddo
         enddo
C     
         k=ifi-ini+1
         SumD=SumD+Delta
         QQ=dsqrt(2d0*Delta/(k*(k-1)))
C     
         Sec=CPUTim(0)-Tim1
C     
         if (mod(m,nprtcyc)==0) then
            Sec=CPUTim(0)-Tim1
            write(io,702)m,SumD,Delta,QQ,Sec
            call flshbf(io)
         endif
C
         if (dabs(QQ)<eps) then
            write(io,707)
            write(io,701) m
            ierr=0
            exit
         endif
C
         if (m==maxcyc) then
            ierr=1
            write(io,707)
            write(io,703) m
         endif
200   enddo
C
      write(io,'('' Final Localization Sum ='',f16.6)') SumD
      Sec=CPUTim(0)-Tim
      NMin=Sec/60
      Sec=Sec-NMin*60
      write(io,704) NMin,Sec
C
      deallocate(POP)
C
      if (nprint==1) then
         write(io,*) '+++ Localized MOs by Pipke-Mezey Localization +++'
         call NJ_prtcol2(io,nbs,nmo,smo,ini,ifi,'f11.6')
         write(io,*)
      endif
C
 700  format(
     & '  Iter        Loc-Sum     Delta-Sum     Orb-Change    Time')
 701  format(' PM Localization Completed After',i5,' Cycle')
 702  format(i5,f17.7,2d14.5,f7.1,'s')
 703  format(' PM Localization Failed After',i8,' Cycle')
 704  format(' Localization CPU Time: ',i6,' minutes',f5.1,' seconds')
 707  format(1x,58('-'))
C
      end
C
C
C --- 2006.02.18 update
      subroutine NJ_calpop(io,nat,nbs,nmo,ini,ifi,smo,sov,tbs,POP,
     &    np,ierr)
      implicit none
      integer io,nat,nbs,nmo,ini,ifi,i,j,k,l,m,n,ij,tbs(nbs),np,ierr
      double precision smo(nbs,nmo),sov(nbs,nbs)
      double precision POP(ini:ifi,ini:ifi,nat),PP,P1
C
      POP=0d0
      do i=ini,ifi
         do j=i,ifi
            do k=1,nbs
               m=tbs(k)
               do l=1,nbs
                  n=tbs(l)
                  PP=smo(k,i)*smo(l,j)*sov(k,l)/2d0
                  POP(j,i,m)=POP(j,i,m)+PP
                  POP(j,i,n)=POP(j,i,n)+PP
               enddo
            enddo
         enddo
      enddo
C
      do i=ini,ifi-1
         do j=i+1,ifi
            do k=1,nbs
               m=tbs(k)
               POP(i,j,m)=POP(j,i,m)
            enddo
         enddo
      enddo
C
      end
C

c     ##############################################################
c     ##  subroutine NJ_xyznum  --  count the num of atoms        ##
c     ##  2005.03.16 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################
c
c     Need 'function elemord(aa)' in element.f
C     2006.06.08-09 Modified

      subroutine GMSNAT(io,xyz,i)
      implicit none
      integer io,xyz,nat,i,j,k,elemord
      real*8 x,y,z,zz
      character aa*2,line*100
      external elemord

      rewind(xyz)
      i=0
      do
         read(xyz,'(a)',end=999) line
         read(line,*,err=100,end=100) aa,zz,x,y,z
         k=ichar(aa(1:1))
         if (k<65.or.(k>90.and.k<97).or.k>122) goto 110
         k=ichar(aa(2:2))
         if (k.ne.32.and.(k<65.or.(k>90.and.k<97).or.k>122)) goto 110
         j=elemord(aa)
         if (j.ne.0) i=i+1
         cycle
 110     if (i>0) exit
 100  enddo

 999  if (io>0) then
          write(io,*) 'Number of atoms:',i
          write(io,*)
      endif

      end

c     ##############################################################
c     ##  subroutine NJ_xyzgeom  --  read xyz cooedinates         ##
c     ##  2005.03.16 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################
c
c     if iau=0 in angstrom; else in a.u.
c
      subroutine GMSXYZ2(io,xyz,nat,nuchar,coor,iau)
      implicit none
      integer io,xyz,nat,i,j,k,elemord,iau,nh
      real*8 coor(3,nat),nuchar(nat),x,y,z,zz
      character aa*2,elemsyl*2,line*100
      external elemord,elemsyl

      coor=0d0; nuchar=0d0
      rewind(xyz)
      i=0; nh=0
      do
         read(xyz,'(a)',end=999) line
         read(line,*,err=100,end=100) aa,zz,x,y,z
         k=ichar(aa(1:1))
         if (k<65.or.(k>90.and.k<97).or.k>122) cycle
         k=ichar(aa(2:2))
         if (k.ne.32.and.(k<65.or.(k>90.and.k<97).or.k>122)) cycle
         if (elemord(aa).eq.0) cycle
!        write(77,'(a)') line(1:70)
         if (aa=='H'.or.aa=='h') nh=nh+1
         i=i+1
C        nuchar(i)=elemord(aa)
         nuchar(i)=zz
         coor(1,i)=x
         coor(2,i)=y
         coor(3,i)=z
         if (i>=nat) exit
 100  enddo


 500  if (io>0) then
         if (iau==0) then
            write(io,*) 'Table: Cartesian Coordinates in angstrom'
         else
            write(io,*) 'Table: Cartesian Coordinates in a.u.'
         endif
         write(io,'(1x,54(''=''))')
         write(io,*) ' Atom           X               Y               Z'
         write(io,'(1x,54(''-''))')
         write(io,'(2x,a2,2x,3f16.8)') (elemsyl(nint(nuchar(i))),
     &        (coor(j,i),j=1,3),i=1,nat)
         write(io,'(1x,54(''=''))')
         write(io,'(''  N<atoms> (all, non-H and H) are'',3i6)') 
     &        nat,nat-nh,nh
         write(io,*)
      endif
!     write(77,*)
      return

 999  stop 'GMSXYZ(): Not enough coordinates in files'
      end
C
C-WL- 09 SEP 2009 FOR SELECTING THE LEVEL OF CALCULATIONS FOR ATOMS
      subroutine ATOMLEVL(io,nat,link,nuchar,CIMATM,atmlevl)
      implicit none
      integer io,nat,i,j,ii,jj
      integer atmlevl(nat),link(nat,nat)
      real*8 nuchar(nat)
      character aa*2,line*100,cctyp*8
      character*8 mthd,CIMATM(nat)
C
      do i=1,nat
         mthd=CIMATM(i)
         if (mthd.eq.'MP2     ') then
            atmlevl(i)=1
         elseif (mthd.eq.'CCD     ') then
            atmlevl(i)=2
         elseif (mthd.eq.'CCSD    ') then
            atmlevl(i)=3
         elseif (mthd.eq.'CCSD(T) ') then
            atmlevl(i)=4
         elseif (mthd.eq.'CR-CCL  ') then
            atmlevl(i)=5
         else
            atmlevl(i)=0
         endif
      enddo

      do i=1,nat
         ii=nint(nuchar(i))
         if (ii.ne.1) cycle
         do j=1,nat
            jj=nint(nuchar(j))
            if (jj.eq.1) cycle
            if (link(j,i).ne.0) then
               atmlevl(i)=atmlevl(j)
            endif
         enddo
      enddo

      if (io>0) then
          write(io,*) '+++ The level of calculations for atoms +++'
          write(io,'(4(3x,5i3))') (atmlevl(i),i=1,nat)
          write(io,*)
      endif

      end

c     ##############################################################
c     ##  subroutine NJ_lower  --  make a string lowercase        ##
c     ##  2004.04.16 by Wei Li; Update 2005.10.17 by Wei Li       ##
c     ##############################################################
c
      subroutine NJ_lower(line)
      implicit none
      integer i,k,ich
      character line*(*)

      k=len(line)
      do i=1,k
         ich=ichar(line(i:i))
         if (ich.ge.65.and.ich.le.90) line(i:i)=char(ich+32)
      enddo

      end

c     ##############################################################
c     ##  subroutine NJ_upper  --  make a string uppercase        ##
c     ##  2004.04.16 by Wei Li; Update 2005.10.17 by Wei Li       ##
c     ##############################################################
c
      subroutine NJ_upper(line)
      implicit none
      integer i,k,ich
      character line*(*),ch

      k=len(line)
      do i=1,k
         ich=ichar(line(i:i))
         if (ich.ge.97.and.ich.le.122)  then
            line(i:i)=char(ich-32)
         endif
      enddo

      end
C*MODULE CIMI    *DECK ELEMSYL
C>
C>   @brief   define periodic table
C>
C>   @details this routine should not be used! SETLAB does this.
C>
c     ##############################################################
c     ##  function elemsyl  --  element: order --> symbol         ##
c     ##  2004.12.22 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################
C
      character*2 function elemsyl(n)
      implicit none
      integer n
      character*2 elem(109)

      data elem/'H ','He','Li','Be','B ',  'C ','N ','O ','F ','Ne',
     &          'Na','Mg','Al','Si','P ',  'S ','Cl','Ar','K ','Ca',
     &          'Sc','Ti','V ','Cr','Mn',  'Fe','Co','Ni','Cu','Zn',
     &          'Ga','Ge','As','Se','Br',  'Kr','Rb','Sr','Y ','Zr',
     &          'Nb','Mo','Tc','Ru','Rh',  'Pd','Ag','Cd','In','Sn',
     &          'Sb','Te','I ','Xe','Cs',  'Ba','La','Ce','Pr','Nd',
     &          'Pm','Sm','Eu','Gd','Tb',  'Dy','Ho','Er','Tm','Yb',
     &          'Lu','Hf','Ta','W ','Re',  'Os','Ir','Pt','Au','Hg',
     &          'Tl','Pb','Bi','Po','At',  'Rn','Fr','Ra','Ac','Th',
     &          'Pa','U ','Np','Pu','Am',  'Cm','Bk','Cf','Es','Fm',
     &          'Md','No','Lr','Rf','Db',  'Sg','Bh','Hs','Mt'/

      if (n>0.and.n<110) then
         elemsyl=elem(n); return
      else
         write(*,*) 'Wrong nuclear charges for',n
         call abrt
         stop
      endif

      end

****** 2004.12.22 element: symbol --> order ******
c     ##############################################################
c     ##  function elemord  --  element: symbol --> order         ##
c     ##  2004.12.22 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################
C
      function elemord(a)
      implicit none
      integer elemord,i,j,k,l,ich
      character a*(*),aa*2,elem(109)*2

      data elem/'H ','He','Li','Be','B ',  'C ','N ','O ','F ','Ne',
     &          'Na','Mg','Al','Si','P ',  'S ','Cl','Ar','K ','Ca',
     &          'Sc','Ti','V ','Cr','Mn',  'Fe','Co','Ni','Cu','Zn',
     &          'Ga','Ge','As','Se','Br',  'Kr','Rb','Sr','Y ','Zr',
     &          'Nb','Mo','Tc','Ru','Rh',  'Pd','Ag','Cd','In','Sn',
     &          'Sb','Te','I ','Xe','Cs',  'Ba','La','Ce','Pr','Nd',
     &          'Pm','Sm','Eu','Gd','Tb',  'Dy','Ho','Er','Tm','Yb',
     &          'Lu','Hf','Ta','W ','Re',  'Os','Ir','Pt','Au','Hg',
     &          'Tl','Pb','Bi','Po','At',  'Rn','Fr','Ra','Ac','Th',
     &          'Pa','U ','Np','Pu','Am',  'Cm','Bk','Cf','Es','Fm',
     &          'Md','No','Lr','Rf','Db',  'Sg','Bh','Hs','Mt'/

      elemord=0
      aa=a
      ich=ichar(aa(1:1))
      if (ich.ge.97.and.ich.le.122) aa(1:1)=char(ich-32)
      ich=ichar(aa(2:2))
      if (ich.ge.65.and.ich.le.90) aa(2:2)=char(ich+32)

      do i=1,109
         if (aa==elem(i)) then
            elemord=i; return
         endif
      enddo

C      write(*,*) 'Wrong element symbols for ',aa; stop
      end

c     ##############################################################
c     ##  subroutine NJ_blank -- find the n-th blank, LN=0 if no  ##
c     ##  2005.04.12 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################
c
****** 2005.4.12 if no LN=0
      subroutine  NJ_blank(Inp,n,LN)
      character line*100
      external Nchar

      rewind(Inp); Nct=0; LN=0

      do 100 k=1,100000
         read(Inp,'(a)',err=110,end=110) line
         LN=LN+1
         i=Nchar(line,1,100)
         if (i.eq.0) Nct=Nct+1
         if (Nct.eq.n) return
 100  enddo

 110  LN=0
      end

C     2004.04.16 find number of no-blank char in line(ini:ifi)(length<=100) #liwei@itcc
      function Nchar(line,ini,ifi)
      character line*(*)
      Nchar=0
      do i=ini,ifi
         if (line(i:i).ne.' ') Nchar=Nchar+1
      enddo

      end

c     ##############################################################
c     ##  subroutine NJ_seekkey  --  Seek key line with ch first  ##
c     ##  2004.12.24 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################
c
      subroutine NJ_seekkey(inp,kch,key,yes)
      implicit none
      integer inp,i,j,k,back,yes,ith,kth
      character key*(*),line*256,kch*(*)

      yes=0
      back=0
      ith=len(key)
      kth=len(kch)
      call NJ_upper(key)
      call NJ_upper(kch)
 200  do
         read(inp,'(a)',err=800,end=800) line
         call NJ_upper(line)
         do j=1,256
            if(line(j:j).ne.' ') exit
         enddo
         if (j>256) cycle
         k=index(line(j:256),key(1:ith))
         if (line(j:j+kth-1)==kch(1:kth).and.k.ne.0) then
            backspace(inp); yes=1; return
         endif
      enddo

 800  if (back==0) then
         rewind(inp); back=1; goto 200
      endif
      end
C     
C ----------------------------------------------------------------------
C --- BASED ON ccdN4.for. FROM 2001.4.1 TO 2001.4.6.
C --- 2007.06.02 CIM-MP2 program ---
*
* --- LIST OF INPUT DATA ---
*     io:     Unit of output file
*     NATOM:  Number of atoms
*     NW:     Number of basis functions
*     NUW:    Number of occupied MOs
*     Nmo:    The number of MOs
*     nfocc:  The number of frozen occ MOs
*     nfvir:  The number of frozen vir MOs
*     conv:   Convergence threshold of iterative MP2 (default: conv=6)
*     basis:  Basis set
*     gmsname:File name for creating files
*     kmem:   Maximum memory for integrals transformation (unit: Words, e.g. 8 Bytes)
*     EIGEN(Nmo):    Alpha MOs eigenvalues
*     SMO(Nmo,Nmo):  Alpha MOs coefficients
*     admx(NW,NW):   AO dipole moment integrals in X-direct
*     admy(NW,NW):   AO dipole moment integrals in Y-direct
*     admz(NW,NW):   AO dipole moment integrals in Z-direct
*     tbs(NW):       Atomic label for basis
*     nuchar(NATOM): Nuclear charges
*     coor(3,NATOM): Cartesian coordinates
*     SOVER(NW,NW):  AO overlap matrix
*     FK(Nmo,Nmo):   AO Fock matrix
*     FIJ(NUW,NUW):  MO Fock matrix    ! 2008.07.25 Nmo --> NUW
*
* --- LIST OF INPUT DATA ---
*     EE: calculated correlation energy
*
* --- LIST OF LOCAL VARIABLES ---
*     NU:     The number of occ MOs
*     NV:     The number of vir MOs
*     NCORE:  The same as nfocc
*     maxbs:  The number of basis functions of the largest clusters
*     NAB:    The same as NUW
*     KG:     The number of reduced central domains
*     KGG:    The number of reduced full domains
*     numc:   The number of non-hydrogen atoms
*     numh:   The number of hydrogrn atoms
*     WRK(1)=ZT1:  The threshold of selecting MOs for a central MO (default: 0.003)
*     WRK(2)=ZT2:  The threshold of selecting environmental domain (default: 1.0)
*     WRK(3)=ZT3:  The threshold of determining the atoms of LMOs  (default: 0.99)
*     WRK(4)=ZT4:  The threshold of constructing virtual LMOs (default: 0.2)
*     WRK(5)=RE0:  The threshold of adding buffer atoms (default: 4/AA)
*     WRK(6)=eps:  The threshold of MP2 iteration (not available now)  
*     
*     ED(NUW):           The correlation energy of each occupied LMO
*     NCLU(NUW):         The calculated times of each occupied LMO
*     SR(NATOM,Nmo):     Sorted Mulliken population of basis in atoms
*     SR1(NATOM,Nmo):    Unsorted Mulliken population of basis in atoms
*     dis(NATOM,NATOM):  Distance matrix of atoms
*     link(NATOM,NATOM): Link matrix of atoms (0 or 1)
*     link2(NATOM,NATOM):Bond distance matrix of atoms (the minimum bonds between two atoms) 
*                        e.g. for C(1)-C(2)-C(3) link2(1,3)=2 (two bonds)
*     SNB(NUW):          The number of atoms for the occupied LMOs
*     SOB(NATOM,NUW):    The labels of atoms for the occupied LMOs
*     ISUB(NUW):         The number of MOs in the central domain
*     ISUB2(NUW):        The number of central MOs in the central domain
*     ISUB3(NUW):        The number of central MOs in the full domain
*     ISUB4(NUW):        The number of MOs in the full domain
*     NB(NATOM):         The first basis function of each atom
*     natc(NATOM):       The labels of all non-hydrogen atoms
*     nath(NATOM):       The labels of all hydrogen atoms
*     NAsub(NUW):        The number of atoms in the full atomic domain
*     NWsub(NUW):        The number of basis function in the full atomic domain
*     INF(NUW,NUW):      The labels of MOs in the central domain
*     INF2(NUW,NUW):     The labels of MOs in the full domain
*     BA(NATOM,NUW):     The labels of atoms in the full domain
*     ZA(NATOM,NUW):     The labels of basis functions in the full domain
*
      SUBROUTINE CIMMP2(io,inp,isys,NATOM,NW,NUW,Nmo,nfocc,nfvir,
     &           SMO,FIJ,FK,SOVER,admx,admy,admz,tbs,nuchar,coor,basis,
     &           gmsname,kmem,EE,scftyp,mplevl,cctyp,istop,
     &           job,
     &           NOB,FKB,atmlevl,atmgrp,path,user,NCBS,CBAS,
     *           nsubsystems,IWORK,RWORK,CWORK,LWORK) !-WL- 2009.09.09
      implicit none
      integer nsubsystems
      double precision ZERO,ONE,TWO
      parameter (ZERO=0.0D+00,ONE=1.0D+00,TWO=2.0D+00)
      integer io,inp,NATOM,NW,NUW,Nmo,nfocc,nfvir,i,j,k,L,m,n,NCORE
      integer k1,k2,k3,k4,k5,maxbs,istop,itmp,KCA,KCB,KOA,KOB,isys,job
      parameter(itmp=115)
      integer tbs(NW),NAB,KG,KGG,numc,numh,kmem,imethd
      character basis*30,gmsname*100,mthd*20,line*100,path*200,user*50
      character scftyp*8,cctyp*8,key8*8,key6*6
      character(len=8),dimension(:),allocatable:: scftyps
      integer mplevl,ngroup,nfg2
      integer NUTT,NVTT,namp,NAMPT,NAMPTT
      integer namps,NAMPTs,NAMPTTs
      integer nampd,NAMPTd,NAMPTTd
      integer iyes,NCBS(NATOM)
      character(len=100) CBAS(100,NATOM)
C
      integer IWORK(100)
      double precision RWORK(100)
      character(len=8) CWORK(100),METHDS(0:5),METHOD
      logical(kind=8) LWORK(100)
C
      double precision PP,EE,eps,ECC,ETC
      double precision ETC1,ETC2
      double precision FIJ(NUW,NUW),SOVER(NW,NW),SMO(NW,Nmo)
      double precision nuchar(NATOM),coor(3,NATOM),FK(NW,NW),FKB(NW,NW)
      double precision admx(NW,NW),admy(NW,NW),admz(NW,NW)
C     double precision HCORE(NW,NW)  !-WL- 2007.10.16 add; 2007.10.23 delete
C
!     double precision,dimension(:),allocatable::TC,TT
      double precision,dimension(:),allocatable::ED,EMO
      double precision,dimension(:),allocatable::ECCA,ECCB,ETCA,ETCB
      double precision,dimension(:,:),allocatable::SR,SR1,dis,FF,EF,FXY
      integer,dimension(:),allocatable::SNB,ISUB,ISUB2,ISUB3,ISUB4,ISUB5
      integer,dimension(:),allocatable::NB,NASUB,NWSUB,natc,nath,NCLU
      integer,dimension(:,:),allocatable::SOB,INF,INF2,BA,ZA,link,link2
      integer,dimension(:),allocatable::NCLA,NCLB,KSymm,NF0,NF1,used
      integer,dimension(:,:),allocatable::group,FRG,CenMO
C
      integer nc,no,nu,nbs,no2u4,no3u4,no2,no3,nu4,memtot
      double precision time1,time2,timex,timet1,timet2,timet3
      double precision timett1,timett2,timett3,ratio2,ratiot,timtot
      double precision,dimension(:),allocatable:: xtime
      integer,dimension(:),allocatable::JOBX,molevl,mtdsys,mxno,mbrams
      double precision,dimension(:),allocatable::zt
      integer KGG2,idx,jdx,NSYGEN,NSYTOT
C
      integer (kind=4) Wall0,Wall,TIME,ieof
      real*8 Tim0,CPUTim
      external dtrace2,CPUTim !,TIME
C
      integer NOA,NOB  !-WL- NOA/NOB is the number of alpha/beta electrons
      integer atmlevl(NATOM),atmgrp(NATOM)
      double precision xo2u4,xo3u4,xo1w4
      double precision yo2u4,yo3u4,yo1w4,ytime(5)
      integer memgms,MBRAM(5),NERR
      external memgms
C
      METHDS(0) = 'NONE    '
      METHDS(1) = 'MP2     '
      METHDS(2) = 'CCD     '
      METHDS(3) = 'CCSD    '
      METHDS(4) = 'CCSD(T) '
      METHDS(5) = 'CR-CCL  '
C
      NCORE=nfocc
      NAB=NUW
      NOA=NUW

      NUTT=NUW-NCORE
      NVTT=Nmo-NUW
C
      if (nfvir.ne.0) then
         write(io,*) 'Freezing virtual MOs not available in CIM'
         call abrt
      endif
C
      Tim0=CPUTim(0)
C     Wall0=TIME()
C
C     if (io>0) then
C        call NJ_date(io,'CIM calculation begin from:')
C        WRITE(io,'('' The number of frozen occ.&vir MOs ='',2i4)') 
C    &                 nfocc,nfvir
C        write(io,'('' Threshold for conv ='',d12.5)') RWORK(6)  ! CCONV (default: 1E-6)
C        write(io,*)
C        call flshbf(io)
C     endif
C ----------------------------------------------------------------------
      allocate(SR(NATOM,Nmo),SR1(NATOM,Nmo),SNB(NUW),SOB(Nmo,NATOM))
      allocate(INF(NUW,NUW),INF2(NUW,NUW),ISUB(NUW),ISUB2(NUW))
      allocate(ISUB3(NUW),ISUB4(NUW),BA(NATOM,NUW),ZA(NW,NUW),NB(NATOM))
      allocate(NASUB(NUW),NWSUB(NUW),natc(NATOM),nath(NATOM),ED(NUW))
      allocate(dis(NATOM,NATOM),link(NATOM,NATOM),link2(NATOM,NATOM))
      allocate(NCLU(NUW),KSymm(NUW),group(NATOM,NATOM))
      SR=0d0; SR1=0d0; SNB=0; SOB=0; INF=0; INF2=0; ISUB=0; ISUB2=0
      ISUB3=0; ISUB4=0; BA=0; ZA=0; NB=0; NASUB=0; NWSUB=0
      natc=0; nath=0; dis=0d0; link=0; link2=0; ED=0d0; NCLU=0
      group=0
      allocate(mxno(NATOM),zt(NATOM))
      mxno=IWORK(4)  ! max number of occ MOs in a subsystems (default: 1000)
      zt=RWORK(3)
      allocate(ECCA(NUW),ECCB(NUW),ETCA(NUW),ETCB(NUW))
      allocate(NCLA(NUW),NCLB(NUW))
      ECCA=0.0D+00
      ECCB=0.0D+00
      ETCA=0.0D+00
      ETCB=0.0D+00
      NCLA=0
      NCLB=0
      allocate(molevl(NUW))
C
C --- 1st basis of each atoms by sj
      do i=1,NW
         do j=1,NATOM
            if (tbs(i).eq.j.and.nb(j).eq.0) nb(j)=i
         enddo
      enddo
C     write(io,*) 'The first basis of each atom'
C     write(io,'(5i6,2x,5i6)') nb(1:NATOM)
C     write(io,*)
C --- natc(numc): non-hydrogen atoms; nath(numh): hydrogen atoms
      numc=0;numh=0
      do i=1,NATOM
         if (nint(nuchar(i)).ne.1) then
            numc=numc+1;natc(numc)=i
         else
            numh=numh+1;nath(numh)=i
         endif
      enddo
C --- the distance and linkage between atoms
      call NJ_dislink(0,NATOM,nuchar,coor,dis,link)
      call NJ_idis(NATOM,link,link2)
      link=link2
      deallocate(link2)
C
      key6='CIMFRG'
C     rewind(inp)
      call seqrew(inp)
      call NJ_seekkey(inp,'$',key6,iyes)

      write(io,*) 'ASSIGNING HYDROGEN ATOMS TO GROUPS'
      if (iyes.ne.0) then
         write(io,*) 'ATOM GROUPS WILL BE BUILT FROM $CIMFRG'
         call rdgroup(io,inp,NATOM,numc,numh,natc,nath,link,
     &        group,ngroup,atmlevl,mxno,zt,IWORK,methds,cwork(2))
      else
         write(io,*) 'CORRELATION METHOD SET BY SUBMTD AND $CIMATM'
         atmgrp=0
         call mkgroup(io,NATOM,numc,numh,natc,nath,link,group,ngroup,
     &        atmgrp,methds,atmlevl)
      endif
C
C --- Calculate Mulliken Population and The Atomic Labels for LMOs ---
      call CalMPop(io,NATOM,NW,NUW,NCORE,Nmo,SOVER,SMO,tbs,
     &     SR,SR1,SNB,SOB,nuchar,NOB,atmlevl,molevl,
     &     IWORK,RWORK,CWORK,LWORK) ! SNB=NMOAT SOB=MOIDNO in GAMESS (common EDCMP)
C
      if (IWORK(9).eq.0) then
C        call LS_toend(inp,0) ! 20 AUG 10 ADDED: goto the end of .cim file
         call ifind2(inp,'$MO-LEVEL')  ! 23 AUG 10
         call iwrit(inp,'$MO-LEVEL', NUW,   molevl(1))
      else
         call ifind2(inp,'$MO-LEVEL')
         call iread(inp,'$MO-LEVEL', NUW,   molevl(1))
      endif
C     write(io,*) '+++ The level of the calculations for LMOs +++'
C     write(io,'(4(3x,5i3))') (molevl(I),I=1,NUW)
C     write(io,*)
C     call flshbf(io)
C
      call NJ_tfock(0,NW,NUW,FK,SMO,FIJ)  ! 2008.02.29 add because the LMOs are sorted
C     write(io,*) '+++ Occ. Fock matrix of sorted LMOs +++'
C     call NJ_prtsym(io,NUW,FIJ,'f12.5')
C
      call SymmOrb2(io,Nmo,NCORE,NUW,FIJ,IWORK,RWORK,KSymm)
C
      allocate(FXY(NUW,NUW))
      if (IWORK(12).eq.1) then
         call FIJ2XY(io,NUW,FIJ,FXY)
      elseif (IWORK(12).eq.2) then
         call FIJ2XY2(io,NUW,FIJ,FXY)
      else
         call CopyFIJ(io,NUW,FIJ,FXY)
      endif
C
      allocate(FRG(NUW,ngroup),NF0(ngroup),FF(ngroup,ngroup))
      allocate(EF(NUW,ngroup))
      allocate(mtdsys(NUW))
      mtdsys=0
C
      if (IWORK(7).eq.0) then
       write(io,*) '--- CONSTRUCTING CENTRAL DOMAINS: ',cwork(1),' --- '
C        if (dabs(WRK(2)).ge.0.9999) then   !-WL- NEW SECIM
         if (CWORK(1).EQ.'SECIM   ' .or. CWORK(1).EQ.'GSECIM  ') then
            call mogroup(0,NATOM,NCORE,NUW,group,SR1,ngroup,Nmo,
     &           FRG,NF0,atmlevl,mtdsys(1),RWORK) ! 2008.08.11 WL mogroup->mogroup2; but changed to old 2008.08.12
            call envfock(io,Nmo,NUW,NCORE,FXY,ngroup,FRG,NF0,EF)
C
C ---       Build the central domains for each Occ spatial orbital ---
            call CentDomn(io,Nmo,NUW,NCORE,RWORK,FXY,INF,ISUB,ISUB2,
     &           KSymm,ngroup,FRG,NF0,EF,mxno(1),zt(1))  ! 2008.03.04 add KSymm
C           call ending
C           stop
C           call SYSLEVEL(io,NUW,ngroup,ISUB2,INF,molevl,mtdsys(1))
C ---       Compare the sizes of domains and eliminate small domains which are embedded in larger ones
            if (IWORK(13).eq.0) then
               call ReduDomn(io,NUW,NCORE,INF,ISUB,ISUB2,KG,ngroup,
     &                    mtdsys(1),IWORK)
            else
               KG=ngroup
            endif
C        else                              !-WL- OLD DECIM
         elseif (CWORK(1).EQ.'DECIM   ') then                         !-WL- DECIM
           call CentDomn1(io,Nmo,NUW,NCORE,RWORK,FXY,INF,ISUB,ISUB2,
     &                    KSymm) ! 2008.03.04 add KSymm
            mtdsys=0
            call SYSLEVEL(0,NUW,NUW,ISUB2,INF,molevl,mtdsys(1))
            call ReduDomn1(io,NUW,NCORE,INF,ISUB,ISUB2,KG,mtdsys(1),
     &                     IWORK)
         endif
C        write(io,'(1x,58(''-''))')
C        write(io,*) ' Domain No.   NOcc    Natom   Basis'
C        do i=1,nuw
C           if(mtdsys(i).eq.0) sysmtd='NONE    '
C           if(mtdsys(i).eq.1) sysmtd='MP2     '
C           if(mtdsys(i).eq.2) sysmtd='CCD     '
C           if(mtdsys(i).eq.3) sysmtd='CCSD    '
C           if(mtdsys(i).eq.4) sysmtd='CCSD(T) '
C           if(mtdsys(i).eq.5) sysmtd='CR-CCL  '
C           write(io,'(i6,4x,3i8,a8)')
C    *      i,ISUB4(i),NAsub(i),NWsub(i),sysmtd
C        enddo
C        write(io,*)

C ---    Build the environmental domain of the same spin for each retained Central Domain. 
C        Reduce the nubmer of full domains after comparison.
         call FullDomn(io,isys,NATOM,NW,NMO,NUW,NCORE,SOB,SNB,BA,ZA,NB,
     &        NASUB,NWSUB,INF,INF2,ISUB,ISUB2,ISUB3,ISUB4,FXY,KG,
     &        KGG,mtdsys(1),IWORK,RWORK,CWORK,LWORK)
C
         call iwrit(isys,'$MO-LEVEL', NUW, molevl(1))
         call iwrit(isys,'$SYS-LEVEL', KGG, mtdsys(1))
      else
       write(io,*) '--- CENTRAL DOMAINS READ FROM CIMDMN ---'
         call ReadClu(0,isys,NUW,KGG,ISUB3,ISUB4,INF2)
         call iread(isys,'$MO-LEVEL', NUW, molevl(1))
         call iread(isys,'$SYS-LEVEL', KGG, mtdsys(1))
C
C        write(io,'(1x,58(''-''))')
C        write(io,*) ' Domain No.   NOcc    Natom   Basis'
         do I=1,KGG
            call COA(NATOM,NW,NMO,NUW,NB,SOB,SNB,INF2(1,I),ISUB4(I),
     &           NAsub(I),BA(1,I),NWsub(I),ZA(1,I))
C           write(io,'(i6,4x,3i8)') i,ISUB4(i),NAsub(i),NWsub(i)
         enddo
C        write(io,*)
      endif
C
      write(io,*)
      write(io,'(15x,18(''-''))')
      write(io,'(15x,"CIM DOMAIN SUMMARY")')
      write(io,'(15x,18(''-''))')
      write(io,*) ' Domain No.   NOcc    Natom   Basis   Method'
      do i=1,kgg
         write(io,'(i6,4x,3i8,5x,a8)') i,ISUB4(i),NAsub(i),NWsub(i),
     *      methds(mtdsys(i))
      enddo
      write(io,*)
      nsubsystems=kgg
      call flshbf(io)
C     write(io,*) '+++ The level of the calculations for subsys +++'
C     write(io,'(4(3x,5i3))') (mtdsys(i),i=1,KGG)
C     write(io,'(i2,'' - '',a8)') (i,METHDS(i),i=0,5)
C     WRITE(io,*)
      call iwrit(inp,'$SYS-LEVEL', KGG, mtdsys(1))
      call flshbf(io)
      call flshbf(inp)

C --- 2009.04.21 -WL- Sorting the orbitals by the index
      allocate(CenMO(NUW,KGG))
      call SortOcc(0,NUW,NOB,KGG,ISUB3,ISUB4,INF2,CenMO)
C
C --- 2009.10.28 -WL- Checking the missing atoms in BA ---
      allocate(used(NATOM))
      do i=1,NATOM
         used(i)=0
      enddo
      do i=1,KGG
         do j=1,NATOM
            k=BA(j,i)
            if (k.ne.0) used(k)=1
         enddo
      enddo
      k=0
      do i=1,NATOM
         if (used(i).ne.0) cycle
         write(io,*) 'Find missing atom:',i
         k=k+1
      enddo
      if (k.ne.0) then
         write(io,*) 'ERROR: The number of missing atoms is',k
         write(io,*) 'You may need to use small x in MLK=x'
         stop
      endif
      deallocate(used)
C
C --- 2005-11-20.
C     call NJ_date(io,'Constructing full domains over on:')
C     call NJ_cputim(io,Tim0)
C     call NJ_walltim(io,Wall0)
      write(io,*) '... FINISHED CONSTRUCTING CIM DOMAINS ...'
      call timit(1)
C     write(io,'(1x,58(''-''))')
      write(io,*)
      call flshbf(io)
C     if (istop.eq.1) stop
C     return
C
      if (IWORK(7).eq.1) IWORK(7)=0  !-WL- 2009.10.27 ADD for read occ MO only
C
      allocate(ISUB5(NUW),JOBX(KGG))
      allocate(mbrams(KGG),xtime(KGG))
      allocate(scftyps(KGG))
      call VICLR(ISUB5, 1, NUW)
      call VICLR(JOBX,  1, KGG)
      call VICLR(mbrams,1, KGG)
      call VCLR(xtime, 1, KGG)
      call VCCLR(scftyps, 1, KGG)
C
C --- Calculations of each subsystems (1 - KGG) ---
      write(io,*) '--- GENERATING SUBSYSTEMS FROM CIM DOMAINS ---'
      maxbs  = 0
      do I=1,KGG  ! should be KGG
         CALL CIMCalc(I,io,isys,NATOM,NW,NUW,Nmo,NCORE,IWORK,RWORK,numc,
     &     numh,natc,nath,nuchar,coor,dis,link,SMO,FK,SOVER,admx,
     &     admy,admz,NB,BA,ZA,SOB,SNB,NASUB,NWSUB,SR1,INF2,ISUB3,ISUB4,
     &     KGG,basis,gmsname,kmem,ED,NCLU,scftyps(I),mtdsys(I),
     &     job,istop,mbrams(I),ISUB5,NOB,FKB,
     &     CenMO,path,user,NCBS,CBAS)
         if (istop.eq.2) stop
      enddo
C
      KGG2=0
      do I=1,KGG
         if (mtdsys(I).ge.1) KGG2=KGG2+1
      enddo
C
      write(io,200)
      NSYGEN = 0
      memtot = 0
      timtot = 0.0D+00
      NERR = 0
      do I=1,KGG
         L=mtdsys(I)  ! 0: NONE; >0: MP/CC; <0 MP/CC with existed input
C        if (L.le.0) cycle ! Skip NONE and existed subsystems
         METHOD = METHDS(abs(L))
         if (L.gt.0) then
            NSYGEN = NSYGEN + 1
            JOBX(NSYGEN) = I
         elseif (L.eq.0) then
            cycle
         endif
C
         if (scftyps(I).eq.'ROHF    ') then
            if (METHOD.ne.'CCSD    '.and.METHOD.ne.'CR-CCL') NERR=NERR+1
         endif
C
         memtot=memtot+mbrams(I)
C
         nc  = ISUB3(I)
         no  = ISUB4(I)
         nu  = ISUB5(I)
         nbs = NWSUB(I)
         nu4 = nu**4
C
         xo1w4=1.0D-08*dble(nbs*nbs)
         xo1w4=xo1w4*nbs*nbs*no*1.0D-03
         xo2u4=1.0D-08*dble(nu4)
         xo2u4=xo2u4*no*no*1.0D-03
         xo3u4=xo2u4*no*0.5D+00
C
         if (METHOD.eq.'MP2     ') then
            xtime(I) = xo1w4
         elseif (METHOD.eq.'CCD     ') then
            xtime(I) = xo2u4*15+xo1w4
         elseif (METHOD.eq.'CCSD    ') then
            xtime(I) = xo2u4*30+xo1w4
         elseif (METHOD.eq.'CCSD(T) ') then
            xtime(I) = xo3u4*10+xo2u4*30+xo1w4
         elseif (METHOD.eq.'CR-CCL  ') then
            xtime(I) = xo3u4*30+xo2u4*60+xo1w4
         endif
C
         if (scftyps(I).eq.'ROHF    ') xtime(I)=xtime(I)*3.0D+00
         timtot = timtot + xtime(I)
C
         if (L.gt.0) then
            write(io,201) I,scftyps(I),METHOD,nc,no,nu,nbs,
     &                 mbrams(I),xtime(I)
         else
            write(io,202) I,METHOD,nc,no,nbs
         endif
      enddo
      write(io,205) memtot,timtot
C
C --- Get required memory and estimated CPU time for total system
      yo1w4 = 1.0D-08*dble(NW*NW)
      yo1w4 = yo1w4*NW*NW*NUTT*1.0D-03
      yo2u4 = 1.0D-08*dble(NVTT*NVTT*NVTT*NVTT)
      yo2u4 = yo2u4*NUTT*NUTT*1.0D-03
      yo3u4 = yo2u4*NUTT*0.5D+00/3.0D+00
C
      if (scftyp.eq.'RHF     ') then
         k1 = memgms(scftyp,2,'NONE    ',NW,NUTT,NVTT,0)
         k2 = memgms(scftyp,0,'CCD     ',NW,NUTT,NVTT,0)
         k3 = memgms(scftyp,0,'CCSD    ',NW,NUTT,NVTT,0)
         k4 = memgms(scftyp,0,'CCSD(T) ',NW,NUTT,NVTT,0)
         k5 = memgms(scftyp,0,'CR-CCL  ',NW,NUTT,NVTT,0)
         k4 = max(k3,k4)
         k5 = max(k3,k5)
         MBRAM(1) = int(k1/125.d0/1000d0) + 1
         MBRAM(2) = int(k2/125.d0/1000d0) + 1
         MBRAM(3) = int(k3/125.d0/1000d0) + 1
         MBRAM(4) = int(k4/125.d0/1000d0) + 1
         MBRAM(5) = int(k5/125.d0/1000d0) + 1
         ytime(1) = yo1w4
         ytime(2) = yo2u4*15+yo1w4
         ytime(3) = yo2u4*30+yo1w4
         ytime(4) = yo3u4*10+yo2u4*30+yo1w4
         ytime(5) = yo3u4*30+yo2u4*60+yo1w4
         write(io,212) (scftyp,METHDS(k),NUTT,NVTT,NW,
     &                 MBRAM(k),ytime(k),k=1,5)
      elseif (scftyp.eq.'ROHF    ') then
         k3 = memgms(scftyp,0,'CCSD    ',NW,NUTT,NVTT,0)
         k5 = memgms(scftyp,0,'CR-CCL  ',NW,NUTT,NVTT,0)
         k5 = max(k3,k5)
         MBRAM(3) = int(k3/125.d0/1000d0) + 1
         MBRAM(5) = int(k5/125.d0/1000d0) + 1
         ytime(3) = (yo2u4*30+yo1w4)*3.0D+00
         ytime(5) = (yo3u4*30+yo2u4*60+yo1w4)*3.0D+00
         write(io,212) scftyp,METHDS(3),NUTT,NVTT,NW,MBRAM(3),ytime(3)
         write(io,212) scftyp,METHDS(5),NUTT,NVTT,NW,MBRAM(5),ytime(5)
C     else
      endif
      write(io,215)
      write(io,*)
C
C --- Sorting by the estimated CPU timing ---
      do idx=1,NSYGEN-1
         i = JOBX(idx)
         do jdx=idx+1,NSYGEN
            j = JOBX(jdx)
C
            time1=xtime(i)
            time2=xtime(j)
            if (time1.ge.time2) cycle
C
            k=JOBX(i)
            JOBX(i)=JOBX(j)
            JOBX(j)=k
C
            timex=xtime(i)
            xtime(i)=xtime(j)
            xtime(j)=timex
         enddo
      enddo
C
      write(io,*) 'Sorted subsystems by decreasing CPU time:'
      write(io,224) (JOBX(I),I=1,NSYGEN)
      write(io,*)
C
      if (NERR.NE.0) then
         write(io,226) NERR
         call abrt
      endif
C
C     call sortjob(job,KGG2,LJOBX(1))
C
 200  format(1x,'=== Required memory (MB) and ',
     &      'estimated CPU time (Relative) ==='/
     &       1x,'SYS   SCFTYP  METHOD     NC   NO   NU  NBS  ',
     &      'MEMORY    CPU TIME')
 201  format(i4,3x,2a8,4i5,i8,f12.4)
 202  format(i4,3x,'--',6x,a8,2i5,3x,'--',i5,6x,'--',6x,'SKIPED')
 205  format(' Tot',3x,8x,8x,5x,15x,i8,f12.4)
 212  format(' Can.  ',a8,a8,5x,3i5,i8,f12.4)
C
 215  format(1x,'Notes: The estimated CPU times are based on the',
     &       ' following scalings:'/
     &       1x,'MP2: O(NO*NBS^4)'/
     &       1x,'CCD or CCSD: O(NO^2*NU^4)'/
     &       1x,'CCSD(T) or CR-CC(2,3): O(NO^3*NU^4)'/
     &       1x,'t(ROHF-CC)/t(RHF-CC) = 3'/
     &       1x,'The CPU times between different methods are',
     &       ' estimated empirically.'/
     &       1x,'They may be inaccurate especially for small systems/',
     &       'subsystems.')
 224  format(1x,5i5,2x,5i5)
 226  format(1x,'ERROR(S) IN',i4,' SUBSYSTEMS,',
     *     ' ROHF CAN ONLY BE USED FOR CIM CCSD AND CR-CCL'/)
C204  format(1x,'Tot',16x,f7.2,' (100.%)',f8.2,' (100.%)',i8)
C
C-WL- 2009.05.05 move this part from bottom
C     if (io>0) then
C        call NJ_date(io,'Constructing subsystem over on:')
C        call NJ_cputim(io,Tim0)
C        call NJ_walltim(io,Wall0)
C        write(io,*) 'Constructing subsystem over'
C        call timit(1)
C        call flshbf(io)
C     endif
C
C
C     write(io,*) '=== SOME INFOMATION FOR DOMAIN ==='
C     write(io,'(''NUMSYS = '',I8)') KGG
C     write(io,'(6i7)') NATOM,NW,Nmo,NCORE,NUW,IWORK(6)
C     write(io,*) 'KSymm()'
C     write(io,'(15i6)') (KSymm(i),i=1,NUW)
C     write(io,*)
C
      write(inp,*) '=== SOME INFOMATION FOR DOMAIN ==='
      write(inp,'(''NUMSYS = '',I8)') KGG
      write(inp,'(6i7)') NATOM,NW,Nmo,NCORE,NUW,IWORK(6)
      write(inp,*) 'KSymm()'
      write(inp,'(15i6)') (KSymm(i),i=1,NUW)
      write(inp,*)
C
      deallocate(SR,SR1,SNB,SOB)
      deallocate(INF,INF2,ISUB,ISUB2)
      deallocate(ISUB3,ISUB4,BA,ZA,NB)
      deallocate(NASUB,NWSUB,natc,nath,ED,dis,link,NCLU)
      deallocate(ECCA,ECCB,ETCA,ETCB,NCLA,NCLB,KSymm,group,FRG,NF0,FF)
      deallocate(EF)
      deallocate(mbrams,ISUB5,JOBX)
      deallocate(xtime)
      deallocate(CenMO,molevl,mtdsys)
      deallocate(FXY,scftyps)
C
      END
C
C
C --- 2009.12.04 ---
      subroutine rdgroup(io,inp,nat,numc,numh,natc,nath,link,
     &           group,ngroup,atmlevl,mxno,zt,IWORK,methds,submtd)
      implicit none
      integer io,inp,nat,numc,numh,i,j,k,L,m,n,ic,jh,kh,ngroup,ngroup0
      integer k0,k1,k2,k3,k4,k5,k6,k7,k8,k9,k10,kk,jc,j1,j2
      integer natc(nat),nath(nat),link(nat,nat),group(nat,nat)
      integer atmlevl(nat),mxno(nat)
      integer,allocatable::used(:),ngrp(:),ntmp(:),levl(:)
      character(len=256) line,line1,line2,line3,string
      character(len=8) methds(0:5),mtdtmp,submtd
      double precision z1,z2,zt(nat)
      integer IWORK(100)
C
      allocate(used(nat),ngrp(nat),ntmp(nat),levl(nat))
C
      levl=0
C
      used=0
      ngroup=0
      ngroup0=0
C
      ngrp=0
      group=0
      read(inp,*)
      do i=1,nat
         read(inp,'(a)') line
C        if (io.gt.0) write(io,'(1x,a)') trim(line)
         call NJ_upper(line)
         if (index(line,'$END').ne.0) exit
         ngroup=ngroup+1
C
         k0=index(line,'HF')+index(line,'NONE')
         k1=index(line,'MP2')
         k2=index(line,'CCD')
         k3=index(line,'CCSD')-index(line,'CCSD(')-index(line,'CCSD[')
         k4=index(line,'CCSD(T)')
         k5=index(line,'CR-CCL')+index(line,'CR-CC(2,3)')
         if (k0.ne.0) then
            levl(i)=0  ! 0 - NONE/HF
            k=index(line(k0:256),' ')+k0-1
            line(k0:k)=' '
         endif
         if (k1.ne.0) then
            levl(i)=1  ! 1 - MP2
            k=index(line(k1:256),' ')+k1-1
            line(k1:k)=' '
         endif
         if (k2.ne.0) then
            levl(i)=2  ! 2 - CCD
            k=index(line(k2:256),' ')+k2-1
            line(k2:k)=' '
         endif
         if (k3.ne.0) then
            levl(i)=3  ! 3 - CCSD
            k=index(line(k3:256),' ')+k3-1
            line(k3:k)=' '
         endif
         if (k4.ne.0) then
            levl(i)=4  ! 4 - CCSD(T)
            k=index(line(k4:256),' ')+k4-1
            line(k4:k)=' '
         endif
         if (k5.ne.0) then
            levl(i)=5  ! 5 - CR-CC(2,3)
            k=index(line(k5:256),' ')+k5-1
            line(k5:k)=' '
         endif
C
         if(IWORK(8).ne.0 .and. k1+k2+k4+k5.ne.0) then
            write(io,*)
            write(io,*) 'SUBTYP=LMO CAN ONLY BE USED WITH CCSD METHOD'
            write(io,*) 'PLEASE CHECK THE METHODS IN $CIMFRG GROUP'
            write(io,*)
            call flshbf(io)
            call abrt
         endif

         k1=index(line,'('); k2=index(line,')')
         if (k1.ne.0.and.k2.ne.0) then
            line(1:k1)=' '
            line(k2:k)=' '
         elseif ((k1.eq.0.and.k2.ne.0).or.(k1.ne.0.and.k2.eq.0)) then
            write(io,*) 'ERROR: Missing ''('' or '')'' in $CIMFRG group'
            write(io,*) 'Also you can use ''atom-labels method'' format'
            call flshbf(io)
            call abrt
         endif
         write(string,'(a)') line(1:k)
C        write(string,'(a)') line(k1+1:k2-1)
         call NJ_readlab(string,group(1,ngroup),nat)
C
C we do not wish to read separate zeta parameters for fragments
C at this time
C        write(string,'(a)') line(k+1:256)
C        z1=0d0
C        z2=0d0
C        read(string,*,end=100) z1,z2
C        if (z1.gt.1d0) then
C           mxno(ngroup) = nint(z1)
C           if (z2.gt.1d0) then
C              write(io,*) 'ERROR: confused parameters of group',ngroup
C              stop
C           else if (z2.gt.0d0.and.z2.le.1d0) then
C              zt(ngroup) = z2
C           endif
C        else if (z1.gt.0d0.and.z1.le.1d0) then
C           zt(ngroup) = z1
C           if (z2.gt.1d0) then
C              mxno(ngroup) = nint(z2)
C           else if (z2.gt.0d0.and.z2.le.1d0) then
C              write(io,*) 'ERROR: confused parameters of group',ngroup
C              stop
C           endif
C        endif
C
 100     continue
C
         do j=1,nat
            ic=group(j,ngroup)
            if (ic.eq.0) then
               ngrp(i)=j-1
               exit
            endif
            used(ic)=1
         enddo
      enddo
C
      do i=1,numc
         ic=natc(i)
         if (used(ic).ne.0) cycle
         ngroup=ngroup+1
         group(1,ngroup)=ic
         used(ic)=1
         ngrp(ngroup)=1
      enddo
C
      ngroup0=ngroup
      do i=1,ngroup0
         L=ngrp(i)
         do j=1,ngrp(i)
            ic=group(j,i)
            do k=1,numh
               kh=nath(k)
               if (link(kh,ic).eq.1) then
                  L=L+1
                  group(L,i)=kh
                  used(kh)=1
               endif
            enddo
         enddo
         ngrp(i)=L
      enddo
C
      k=0
      do i=1,nat
         if (used(i).ne.0) cycle
         write(io,*) 'Find isolated atom:',i
         k=k+1
      enddo
      if (k.ne.0) then
         write(io,*) 'ERROR: The number of isolated atoms is',k
         stop
      endif
C
C --- Sorting the atoms in group
      do i=1,ngroup
         L=ngrp(i)
         do j1=1,L-1
            do j2=j1+1,L
               k1=group(j1,i)
               k2=group(j2,i)
               if (k1.gt.k2) then
                  group(j1,i)=k2
                  group(j2,i)=k1
               endif
            enddo
         enddo
      enddo
C
C --- New atom levels here (old ones are kept)
      do i=1,ngroup
         L=levl(i)
         if (L.eq.0) cycle
         do j=1,ngrp(i)
            k=group(j,i)
            atmlevl(k)=L
         enddo
      enddo
C
      if (io.gt.0) then
C        write(io,*)
         write(io,*) '+++ The initial groups of atoms +++'
         do i=1,ngroup
            write(line1,*) i
            call NJ_trim(line1,k1,k2)
            kk=ngrp(i)
            do j=1,nat
               ntmp(j)=group(j,i)
            enddo
            call NJ_prtlab(line2,kk,ntmp)
            call NJ_trim(line2,k3,k4)
            line2='('//line2(k3:k4)//')'
C
C           write(line3,'(i6,f9.6)') mxno(i),zt(i)
            mtdtmp=methds(levl(i))
            if(levl(i).eq.0) mtdtmp=submtd
C           write(line3,'(2x,a8)') mtdtmp
C           call NJ_trim(line3,k5,k6)
C           write(io,*) line1(k1:k2)//' ('//line2(k3:k4)//') '
C    &                //line3(k5:k6)
            write(io,"(i3,2x,a55,2x,a8)") i,line2,mtdtmp
         enddo
C        write(io,*)
C        write(io,*) '+++ The updated level of calc for atoms +++'
C        write(io,'(4(3x,5i3))') (atmlevl(i),i=1,nat)
         write(io,*)
      endif
C
      deallocate(used,ngrp,ntmp)
      end
C
C
C --- 2008.03.04 ---
      subroutine mkgroup(io,nat,numc,numh,natc,nath,link,group,ngroup,
     &           atmgrp,methds,atmlevl)
      implicit none
      integer io,nat,numc,numh,i,j,k,L,m,n,ic,jh,kh,ngroup,ngroup0
      integer k1,k2,k3,k4,kk,jc,level
      integer natc(nat),nath(nat),link(nat,nat),group(nat,nat)
      integer atmgrp(nat),atmlevl(nat)
      integer,allocatable::used(:),ngrp(:),ntmp(:)
      character(len=256) line1,line2
      character(len=8) methds(0:5),mtdtmp
C
      allocate(used(nat),ngrp(nat),ntmp(nat))
      used=0
      ngrp=0
      group=0
C
      k = 0
      do i=1,numc
         ic=natc(i)

         if (atmgrp(ic).eq.0) then
            used(ic)=1
            k=k+1
            L=1
            group(L,k)=ic
            n=k
         else
            do m=1,k
               jc=group(1,m)
               if (atmgrp(jc).eq.atmgrp(ic)) then
                  used(ic)=1
                  L=ngrp(m)+1
                  group(L,m)=ic
                  n=m
                  exit
               endif
            enddo
            if (used(ic).eq.0) then
               used(ic)=1
               k=k+1
               L=1
               group(L,k)=ic
               n=k
            endif
         endif

         do j=1,numh
            jh=nath(j)
            if (link(jh,ic).eq.1) then
               L=L+1
               group(L,n)=jh
               used(jh)=1
            endif
         enddo
         ngrp(n)=L
      enddo
C
      ngroup  = k
      ngroup0 = k
C
!!!!  do k=1,numh
!!!!     kh=nath(k)
!!!!     if (used(kh).ne.0) cycle
!!!!     do i=1,ngroup0
!!!!        ic=group(1,i)
!!!!        if (link(ic,kh).eq.2) then
!!!!           ngrp(i)=ngrp(i)+1
!!!!           group(ngrp(i),i)=kh
!!!!           used(kh)=1
!!!!        endif
!!!!     enddo
C
****     if (used(kh).eq.0) then
****        ngroup=ngroup+1
****        group(1,ngroup)=kh
****        ngrp(ngroup)=1
****        used(kh)=1
****        L=1
****        do j=1,numh
****           jh=nath(j)
****           if (used(jh).ne.0) cycle
****           if (link(jh,kh).eq.1) then
****              L=L+1
****              group(L,ngroup)=jh
****              used(jh)=1
****           endif
****        enddo
****     endif
****  enddo
C
      k=0
      do i=1,nat
         if (used(i).ne.0) cycle
         write(io,*) 'Find isolated atom:',i
         k=k+1
      enddo
      if (k.ne.0) then
         write(io,*) 'ERROR: The number of isolated atoms is',k
         stop
      endif
C
      write(io,*) '+++ The initial groups of atoms +++'
      do i=1,ngroup
         write(line1,*) i
         call NJ_trim(line1,k1,k2)
         kk=ngrp(i)
         do j=1,nat
            ntmp(j)=group(j,i)
            if(ntmp(j).ne.0) mtdtmp=methds(atmlevl(j))
         enddo
         call NJ_prtlab(line2,kk,ntmp)
         call NJ_trim(line2,k3,k4)
         line2='('//line2(k3:k4)//')'
C        write(io,*) line1(k1:k2)//' ('//line2(k3:k4)//')'
         write(io,"(i3,2x,a55,2x,a8)") i,line2,mtdtmp
      enddo
      write(io,*)
C
      deallocate(used,ngrp,ntmp)
      end
C
C --- Construct MO fragments --- liwei
      subroutine mogroup(io,nat,ncor,no,group,SR1,ngroup,nmo,
     &           FRG,NF0,atmlevl,mtdsys,RWORK)
      implicit none
      integer io,nat,ncor,no,ngroup,nmo,i,j,k,L,m,n,k1,k2,k3,k4,k5,k6,kk
      integer group(nat,nat),FRG(no,ngroup),NF0(ngroup)
      double precision SR1(nat,nmo),RWORK(100)
      character(len=256) line,line1,line2
      integer,allocatable::ntmp(:)
      integer atmlevl(nat),mtdsys(ngroup)
C
      FRG=0
      NF0=0
C
      do i=1,ngroup
         L=0
         do j=ncor+1,no
            do k=1,nat
               m=group(k,i)
               if (m.eq.0) exit
               if (SR1(m,j).gt.RWORK(7)) then
                  L=L+1
                  FRG(L,i)=j
                  exit
               endif
            enddo
         enddo
         NF0(i)=L
      enddo
C
      do i=1,ngroup
         do k=1,nat
            m=group(k,i)
            if (m.eq.0) cycle
            k1=atmlevl(m)
            k2=mtdsys(i)
            if (k1.gt.k2) mtdsys(i)=k1
         enddo
      enddo
C
      allocate(ntmp(no))
      do i=1,no
         ntmp(i)=0
      enddo
      do i=1,ngroup
         do j=1,no
            k=FRG(j,i)
            if (k.ne.0) ntmp(k)=1
         enddo
      enddo
      k=0
      do i=ncor+1,no
         if (ntmp(i).ne.0) cycle
         k=k+1
         write(io,*) 'Find isolated LMO:',i
      enddo
      if (k.ne.0) then
         write(io,*) 'ERROR: The number of isolated LMOs is',k
         write(io,*) 'You may need to use small x in MLK=x'
         stop
      endif
      do i=ncor+1,no
         ntmp(i)=0
      enddo

      if (io.gt.0) then
      write(io,*)'=== The group of occ MOs by using Mulliken >',RWORK(7)
      do i=1,ngroup
         write(line1,*) i
         call NJ_trim(line1,k1,k2)
         kk=NF0(i)
         do j=1,no
            ntmp(j)=FRG(j,i)
         enddo
         call NJ_prtlab(line2,kk,ntmp)
         call NJ_trim(line2,k3,k4)
         write(io,*) line1(k1:k2)//' ('//line2(k3:k4)//')'
      enddo
      write(io,*)
C
         write(io,*) '+++ The level of the calculations for groups +++'
         write(io,'(4(3x,5i3))') (mtdsys(i),i=1,ngroup)
         write(io,*) '0 - NONE'
         write(io,*) '1 - MP2'
         write(io,*) '2 - CCD'
         write(io,*) '3 - CCSD'
         write(io,*) '4 - CCSD(T)'
         write(io,*) '5 - CR-CCL'
         WRITE(io,*)
      endif
C
      deallocate(ntmp)
      end
C
C --- Construct MO fragments --- liwei
      subroutine mogroup2(io,nat,ncor,no,group,SR1,ngroup,nmo,FRG,NF0)
      implicit none
      integer io,nat,ncor,no,ngroup,nmo,i,j,k,L,m,n,k1,k2,k3,k4,k5,k6,kk
      integer group(nat,nat),FRG(no,ngroup),NF0(ngroup)
      double precision SR1(nat,nmo),SRmax
      character(len=256) line,line1,line2
      integer,allocatable::ntmp(:)
C
      FRG=0
      NF0=0
C
CC    do i=1,ngroup
CC       L=0
CC       do j=ncor+1,no
CC          do k=1,nat
CC             m=group(k,i)
CC             if (m.eq.0) exit
CC             if (SR1(m,j).gt.0.15d0) then
CC                L=L+1
CC                FRG(L,i)=j
CC                exit
CC             endif
CC          enddo
CC       enddo
CC       NF0(i)=L
CC    enddo
C
      do j=ncor+1,no
         SRmax=0d0
         kk=0
         do i=1,ngroup
            m=group(1,i)
            if (SR1(m,j).gt.SRmax) then
               kk=i
               SRmax=SR1(m,j)
            endif
         enddo
         NF0(kk)=NF0(kk)+1
         FRG(NF0(kk),kk)=j
      enddo
C
      allocate(ntmp(no))
      write(io,*) '=== The group of occ MOs (Using max Mulliken) ==='
      do i=1,ngroup
         write(line1,*) i
         call NJ_trim(line1,k1,k2)
         kk=NF0(i)
         do j=1,no
            ntmp(j)=FRG(j,i)
         enddo
         call NJ_prtlab(line2,kk,ntmp)
         call NJ_trim(line2,k3,k4)
         write(io,*) line1(k1:k2)//' ('//line2(k3:k4)//')'
      enddo
      write(io,*)
C
      deallocate(ntmp)
      end
C
C --- 2008.03.10 Calculate the maximum Fock matrix value between two mo group
C     subroutine grpfock(io,nmo,no,FIJ,ngroup,FRG,NF0,FF)
C     implicit none
C     integer io,nmo,no,ngroup,i,j,k,L,m,n,ii,jj,mi,mj
C     integer FRG(no,ngroup),NF0(ngroup)
C     double precision FIJ(no,no),FF(ngroup,ngroup),P1,PP
C
C     FF=0d0
C     do i=1,ngroup-1
C        do j=i+1,ngroup
C           P1=0d0
C           do ii=1,NF0(i)
C              mi=FRG(ii,i)
C              do jj=1,NF0(j)
C                 mj=FRG(jj,j)
C                 PP=dabs(FIJ(mj,mi))
C                 if (PP.gt.P1) P1=PP
C              enddo
C           enddo
C           FF(j,i)=P1
C           FF(i,j)=P1
C        enddo
C     enddo
C
C     write(io,*) 'The maximum Fock values between mo groups'
C     call NJ_prtsym(io,ngroup,FF,'f11.6')
C     write(io,*)
C
C     end
C
C --- 2008.03.10 Calculate the maximum Fock matrix value between two mo group
      subroutine envfock(io,nmo,no,ncor,FIJ,ngroup,FRG,NF0,EF)
      implicit none
      integer io,nmo,no,ncor,ngroup,i,j,k,L,m,n,ii,jj,mi,mj,k1,k2,LL
      integer FRG(no,ngroup),NF0(ngroup)
      double precision FIJ(no,no),EF(no,ngroup),P1,P2,PP
C
      EF=0d0
      do i=1,ngroup
         L=NF0(i)
         do j=ncor+1,no
            LL=0
            do ii=1,NF0(i)
               mi=FRG(ii,i)
               if (mi.eq.j) then
                  LL=1
                  exit
               endif
            enddo
            if (LL.eq.1) cycle
C
            L=L+1
            P1=0d0
            do ii=1,NF0(i)
               mi=FRG(ii,i)
               PP=dabs(FIJ(mi,j))
               if (PP.gt.P1) P1=PP
            enddo
            EF(L,i)=P1
            FRG(L,i)=j
         enddo
      enddo
C
C --- Sorting Env MOs decreasely
      do i=1,ngroup
         L=NF0(i)
         do k1=L+1,no-1
            do k2=k1+1,no
               if (EF(k1,i).lt.EF(k2,i)) then
                  P1=EF(k1,i)
                  EF(k1,i)=EF(k2,i)
                  EF(k2,i)=P1
                  LL=FRG(k1,i)
                  FRG(k1,i)=FRG(k2,i)
                  FRG(k2,i)=LL
               endif
            enddo
         enddo
      enddo
C
C     write(io,*) 'The maximum Fock values between envir MOs and groups'
C     call NJ_prtcol2(io,no,ngroup,EF,1,ngroup,'f10.5')
C     call NJ_prtcol4(io,no,ngroup,FRG,EF,1,no-ncor,1,ngroup,'f10.5')
C     write(io,*)
C
      end
C
c     ##############################################################
c     ##  subroutine NJ_compare -- compare if an array in another ##
c     ##  2005.04.04 by Wei Li; Update 2005.10.17 by Wei Li       ##
c     ##############################################################
c
c     if tmp1 in tmp2 ch='<'
c     if tmp2 in tmp1 ch='>'
c     if tmp1 eq tmp2 ch='='
c
      subroutine NJ_compare(n,tmp1,tmp2,ch)
      implicit none
      integer n,tmp1(n),tmp2(n),i,j,k,l,m,n1,n2,ii,jj
      character ch

      ch=' '
      n1=0; n2=0
      do i=1,n
         if (tmp1(i).ne.0) n1=n1+1
         if (tmp2(i).ne.0) n2=n2+1
      enddo

      k=0
      do i=1,n
         ii=tmp1(i)
         if (ii==0) cycle
         do j=1,n
            jj=tmp2(j)
            if (jj==0) cycle
            if (jj==ii) then
               k=k+1; exit
            endif
         enddo
      enddo

      if (k==n1) then
         if (n1==n2) then
            ch='='
         else
            ch='<'
         endif
         return
      endif

      k=0
      do i=1,n
         ii=tmp2(i)
         if (ii==0) cycle
         do j=1,n
            jj=tmp1(j)
            if (jj==0) cycle
            if (jj==ii) then
               k=k+1; exit
            endif
         enddo
      enddo

      if (k==n2) then
         if (n1==n2) then
            ch='='
         else
            ch='>'
         endif
         return
      endif

      end

C
C ======================================================================
C --- Calc Mulliken Population and The Atomic Labels for LMOs ---
      subroutine CalMPop(io,NATOM,NW,NUW,NCORE,Nmo,SOVER,SMO,tbs,
     &           SR,SR1,SNB,SOB,nuchar,NOB,atmlevl,molevl,
     &           IWORK,RWORK,CWORK,LWORK)
      implicit none
      integer io,NATOM,NW,NUW,Nmo,i,j,k,L,m,n,J2,J4,I2,kk,k1,k2,k3,k4
      integer tbs(NW),SNB(NUW),SOB(Nmo,NATOM),NCORE,n1,n2,NOB
      double precision SMO(NW,Nmo),SR(NATOM,Nmo),SR1(NATOM,Nmo)
      double precision SOVER(NW,NW)  ! 2008.02.29 SMO(Nmo,Nmo) --> SMO(NW,Nmo)
      double precision P1,P2,PP,NPP,nuchar(NATOM)
      integer,allocatable::NAT(:),BATOM(:,:),ntmp(:)
      character(len=256) line,line1,line2,line3
      integer atmlevl(NATOM),molevl(NUW),IWORK(100)
      double precision RWORK(100)
      character(len=8) CWORK(100)
      logical LWORK(100)
C
      allocate(NAT(NATOM),BATOM(NW,NATOM),ntmp(NATOM))
      BATOM=0; NAT=0
C
      do i=1,NW
         j=tbs(i)
         NAT(j)=NAT(j)+1
         BATOM(NAT(j),j)=i
      enddo
C
!     if (io>0) then
!        write(io,*) '+++ Number of basis for atoms and labels +++'
!        do i=1,NATOM
!           write(io,'(2i4,2x,20i4)') i,NAT(i),(BATOM(j,i),j=1,NAT(i))
!        enddo
!        write(io,*)
!     endif
C
C---------------------------------------------------------------------
C     Calc Mulliken population (2001.04.21)
C     SR(j,i)=\sum_{k}^{NW}\sum_{l\in{j}}^{NW}C_{ki}S_{kl}C_{li}  (j=1,natom; i=1,Nmo)
C---------------------------------------------------------------------
      DO 420 I=1,Nmo
         DO 440 J=1,NATOM
            SOB(I,J)=J
            P1=0.0d0
            DO 445 J2=1,NAT(J)
               J4=BATOM(J2,J)
               P2=0.0d0
               DO 450 K=1,NW
                  P2=P2+SMO(K,I)*SOVER(K,J4)
450            CONTINUE
               P1=P1+SMO(J4,I)*P2
445         CONTINUE
            SR(J,I)=P1
440      CONTINUE
420   CONTINUE
C
C --- SR1: unsorted SR: Mulliken population of basis in atoms
      SR1=SR
C
!     if (io>0) WRITE(io,*) '+++ Mulliken gross population +++'
      P2=0d0
      DO 451 I=1,NATOM
         P1=0.0d0
         DO 453 J=1,NUW
             P1=P1+SR(I,J)*2.0d0
453      CONTINUE
!        if (io>0) WRITE(io,'(i7,f12.7)') I,P1
         P2=P2+P1
451   CONTINUE
!     if (io>0) write(io,'('' Total:'',f12.7)') P2
C
C---------------------------------------------------------------------
C     (SR(J,I), J=1,NATOM) are reordered from large to small for the ith Occ MO
C---------------------------------------------------------------------
      DO 460 I=1,Nmo
         DO 465 J=1,NATOM-1
            P1=SR(J,I)
            DO 470 K=J+1,NATOM
               IF (SR(K,I).GT.P1) THEN
                  P1=SR(K,I)
                  SR(K,I)=SR(J,I)
                  SR(J,I)=P1
                  NPP=SOB(I,K)
                  SOB(I,K)=SOB(I,J)
                  SOB(I,J)=NPP
               ENDIF
470         CONTINUE
465      CONTINUE
C
         if (I>NUW) cycle
         P1=0.0d0
         DO 475 J=1,NATOM
            P1=P1+SR(J,I)
C           if (dabs(RWORK(2)).ge.0.9999) then   !-WL- NEW SECIM
            if (CWORK(1).EQ.'SECIM   '.OR.CWORK(1).EQ.'GSECIM  ') then
C ---          This is new trial method for selecting the atoms for a LMO
               IF (SR(J,I).lt.RWORK(7)) THEN
                  SNB(I)=J-1
                  exit
               ENDIF
            elseif (CWORK(1).EQ.'DECIM   ') then  !-WL- OLD DECIM
C ---          This is origin method for selecting the atoms for a LMO
               IF (P1.ge.RWORK(8)) THEN
                  SNB(I)=J
                  exit
               ENDIF
            endif
475      CONTINUE
460   CONTINUE
C
C --- 2008.02.28 Add for sorting LMOs according to the labels of atoms
      if (IWORK(5).eq.0) then
C         -WL- Add NOB for unsorting single-occ MOs
         call SortLMO(0,NATOM,NW,NUW,NOB,NCORE,Nmo,SMO,SR,SR1,SNB,SOB,
     &        nuchar)
      endif
C
      molevl=0
      do I=1,NUW
         do j=1,SNB(I)
            k=SOB(I,J)
            k1=molevl(I)
            k2=atmlevl(k)
            if (k2.gt.k1) then
               molevl(I)=k2
            endif
         enddo
      enddo
C
      if (io>0) then
C        WRITE(io,*) 'Sorted Mulliken population of basis in atoms'
C        call NJ_prtcol3(io,NATOM,NMO,SOB,SR,1,NUW,'f10.5')
C        WRITE(io,*) '+++ Atomic Labels for LMOs +++'
         write(io,*)"Atoms are assigned to LMOs by Mulliken population:"
         write(io,'(1x,"ATMMLK >= ",1p,e8.1,0p)') rwork(7)
         write(io,'(1x,"The first ",i3," are core orbitals")') ncore
         m=4
         line=' '
         do I=1,NUW
            write(line1,*) I
            call NJ_trim(line1,k1,k2)
            kk=SNB(I)
            do j=1,NATOM
               ntmp(j)=SOB(I,J)
            enddo
            call NJ_prtlab(line2,kk,ntmp)
            call NJ_trim(line2,k3,k4)
C
            n=mod(I,m)
            if (n.eq.0) n=m
            n1=(n-1)*20+1
            n2=n1+19
C           if (I.le.NCORE) then
C              line(n1:n2)=line1(k1:k2)//' ('//line2(k3:k4)//')*'
C           else
               line(n1:n2)=line1(k1:k2)//' ('//line2(k3:k4)//')'
C           endif
            if (n.eq.m .or. I.eq.NUW) then
               write(io,'(a)') trim(line)
               line=' '
            endif
         enddo
C        write(io,*) '* Assignment of core orbitals'
         WRITE(io,*)
         write(io,"(/1X,'ORDERED LOCALIZED ORBITALS')")
         call prsql(smo,nuw,nw,nw)
         write(io,"('... END OF LOCALIZED ORBITALS ...')")
         write(io,*)

      endif
      deallocate(NAT,BATOM,ntmp)
      end
C
C
C --- 2008.02.28 Add for sorting LMOs according to the labels of atoms
      subroutine SortLMO(io,nat,nbs,no,nob,ncor,nmo,smo,SR,SR1,SNB,SOB,
     &           nuchar)
      implicit none
      integer io,nat,nbs,no,ncor,nmo,i,j,k,L,k1,k2,k3,k4,i1,j1,i2,j2,nob
      integer SNB(no),SOB(nmo,nat)
      double precision smo(nbs,nmo),SR(nat,nmo),SR1(nat,nmo),P
      double precision nuchar(nat)
      logical LSort
C
      if (io.gt.0) write(io,*)
     &   'Sort the occupied LMOs according to the labels of atoms'
C
      do i=1,ncor-1
         do j=i+1,ncor
            i1=SOB(i,1)
            j1=SOB(j,1)
            if (i1.gt.j1) then
               call swapmo(i,j,nat,nbs,no,nmo,smo,SR,SR1,SNB,SOB)
            endif
         enddo
      enddo
C
      do i=ncor+1,nob-1
         do j=i+1,nob
            LSort=.false.
            if (SNB(i).eq.1 .and. SNB(j).eq.1) then
               i1=SOB(i,1)
               j1=SOB(j,1)
               if (i1.gt.j1) LSort=.true.
            elseif (SNB(i).eq.1 .and. SNB(j).gt.1) then
               i1=SOB(i,1)
               j1=SOB(j,1)
               j2=SOB(j,2)
               if (j1.gt.j2) call swap(j1,j2)
C
               k1=nint(nuchar(j1))
               k2=nint(nuchar(j2))
               if (k1.eq.1.and.k2.ne.1) call swap(j1,j2)
C
               if (i1.gt.j1) LSort=.true.
            elseif (SNB(i).gt.1 .and. SNB(j).eq.1) then
               i1=SOB(i,1)
               i2=SOB(i,2)
               j1=SOB(j,1)
               if (i1.gt.i2) call swap(i1,i2)
C
               k1=nint(nuchar(i1))
               k2=nint(nuchar(i2))
               if (k1.eq.1.and.k2.ne.1) call swap(i1,i2)
C
               if (i1.ge.j1) LSort=.true.
            else
               i1=SOB(i,1)
               i2=SOB(i,2)
               j1=SOB(j,1)
               j2=SOB(j,2)
               if (i1.gt.i2) call swap(i1,i2)
               if (j1.gt.j2) call swap(j1,j2)
C
               k1=nint(nuchar(i1))
               k2=nint(nuchar(i2))
               if (k1.eq.1.and.k2.ne.1) call swap(i1,i2)
               k1=nint(nuchar(j1))
               k2=nint(nuchar(j2))
               if (k1.eq.1.and.k2.ne.1) call swap(j1,j2)
C
               if (i1.gt.j1) LSort=.true.
C-WL- 2010.02.10 comment the line and replace it with the following lines
C              if (i1.eq.j1 .and. i2.gt.j2) LSort=.true.
               if (i1.eq.j1) then
                  k1=nint(nuchar(i2))
                  k2=nint(nuchar(j2))
                  if (k1.eq.1.and.k2.eq.1) then
                     if (i2.gt.j2) LSort=.true.
                  elseif (k1.ne.1.and.k2.ne.1) then
                     if (i2.gt.j2) LSort=.true.
                  elseif (k1.ne.1.and.k2.eq.1) then
                     LSort=.true.
                  endif
               endif
            endif
            if(LSort) call swapmo(i,j,nat,nbs,no,nmo,smo,SR,SR1,SNB,SOB)
         enddo
      enddo
C
      end
C
C --- Swap i and j
      subroutine swap(i,j)
      implicit none
      integer i,j,L
      L=i
      i=j
      j=L
      end
C
C --- Swap MO i and j and other info. ---
      subroutine swapmo(i,j,nat,nbs,no,nmo,smo,SR,SR1,SNB,SOB)
      implicit none
      integer nat,nbs,no,nmo,i,j,k,L
      integer SNB(no),SOB(nmo,nat)
      double precision smo(nbs,nmo),SR(nat,nmo),SR1(nat,nmo),P
C
      L=SNB(i)
      SNB(i)=SNB(j)
      SNB(j)=L
      do k=1,nat
         L=SOB(i,k)
         SOB(i,k)=SOB(j,k)
         SOB(j,k)=L
         P=SR(k,i)
         SR(k,i)=SR(k,j)
         SR(k,j)=P
         P=SR1(k,i)
         SR1(k,i)=SR1(k,j)
         SR1(k,j)=P
      enddo
      do k=1,nbs
         P=smo(k,i)
         smo(k,i)=smo(k,j)
         smo(k,j)=P
      enddo
C
      end
C
C---------------------------------------------------------------------
C     Build the central domains for each Occ spatial orbital
C---------------------------------------------------------------------
C     INF(): orbitals in each domain
C     ISUB(): number of orbitals in each domain
C     ISUB2():number of central orbitals in each domain
      subroutine CentDomn(io,Nmo,NUW,NCORE,RWORK,FIJ,INF,ISUB,ISUB2,
     &           KSymm,ngroup,FRG,NF0,EF,mxno,zt)
      implicit none
      integer io,Nmo,NUW,NCORE,I,J,K,L,M,N,K1,K2,kk,ngroup,maxno
      integer INF(NUW,NUW),ISUB(NUW),ISUB2(NUW),KSymm(NUW)
      integer FRG(NUW,ngroup),NF0(ngroup),k3,k4,k5,k6,k7,k8
      integer kkc,kke
      integer mxno(ngroup)
      double precision RWORK(100),FIJ(NUW,NUW),SA,EF(NUW,ngroup)
      double precision zt(ngroup)
      character*500 line,line1,line2,line3,line4  !-WL,PP- 200 --> 500
      integer,allocatable::Ktmp(:)
C
      INF=0
      ISUB=0
      ISUB2=0
C ----------------
      do 2300 i=1,ngroup
         kk=NF0(i)
         if (kk.gt.mxno(i)) then
            write(io,*) 'Warn: No. of central MOs is larger than maxno '
     &                //'in group',i
         endif
C
         ISUB2(i)=kk
         ISUB(i)=kk
         do j=1,kk
            INF(j,i)=FRG(j,i)
         enddo
         do j=kk+1,mxno(i)
            SA=EF(j,i)
            if (SA.lt.zt(i)) exit  ! 23 ARP 10 WRK(1) --> zt(i)
            INF(j,i)=FRG(j,i)
            ISUB(i)=ISUB(i)+1
         enddo
 2300 enddo
C
      if (io>0) then
         write(io,*)'+++ Central orbitals and their domains +++'
         write(io,'(1x,"+++ Domains chosen ",
     *              "by Fij >= ",f7.4," (ZETA) +++")') zt(1)
C        write(io,*) '  No. Num   Cent       LMOs'
         do i=1,ngroup
            if(ISUB2(i).eq.0)cycle
C           kkc=ISUB2(i)         !central limit
C           kke=ISUB(i)-ISUB2(i) !env limit
C           write(io,'(1x,"Domain ",i4)') i
C           write(io,'(4x,"Cent:",i4)') kkc
C           write(io,'(4x,19i4)') inf(1:kkc,i)
C           write(io,'(4x,"Env :",i4)') kke
C           write(io,'(4x,19i4)') inf(kkc+1:kkc+kke,i)

            kk=ISUB2(i)
            write(line1,*) kk; call NJ_trim(line1,k1,k2)
            allocate(Ktmp(kk)); Ktmp(1:kk)=INF(1:kk,i)
            call NJ_prtlab(line3,kk,Ktmp);  deallocate(Ktmp)
            call NJ_trim(line3,k5,k6)
            kk=ISUB(i)-ISUB2(i)
            write(line2,*) kk; call NJ_trim(line2,k3,k4)
            allocate(Ktmp(kk)); Ktmp(1:kk)=INF(ISUB2(i)+1:ISUB2(i)+kk,i)
            call NJ_prtlab(line4,kk,Ktmp);  deallocate(Ktmp)
            call NJ_trim(line4,k7,k8)
            write(io,'(i5,a)')i,' ['//line1(k1:k2)//'+'//line2(k3:k4)
     &           //']: ('//line3(k5:k6)//') '//line4(k7:k8)
         enddo
         WRITE(io,*)
         call flshbf(io)
      endif
C
      end
C
C --- Compare the sizes of domains and eliminate small domains which are embedded in larger ones
      subroutine ReduDomn(io,NUW,NCORE,INF,ISUB,ISUB2,KG,ngroup,mtdsys,
     &           IWORK)
      implicit none
      integer io,NUW,NCORE,KG,I,J,K,L,NAB,ngroup
      integer INF(NUW,NUW),ISUB(NUW),ISUB2(NUW),mtdsys(NUW)
      character*500 line,line1,line2,line3,line4
      integer k1,k2,k3,k4,k5,k6,k7,k8,kk,IWORK(100)
      integer,allocatable::Ktmp(:)
C
      NAB=NUW
CC    call COMPARE(NAB,NCORE+1,NUW,INF,ISUB,ISUB2)
      call COMPARE(NAB,1,ngroup,INF,ISUB,ISUB2,mtdsys(1),IWORK(10))
C
C   KG: Number of central domains
      KG=0
CC    DO 5590 I=NCORE+1,NAB
      DO 5590 I=1,ngroup
         if(ISUB2(I).eq.0)cycle
         KG=KG+1
         mtdsys(KG)=mtdsys(I)
         ISUB(KG)=ISUB(I)
         ISUB2(KG)=ISUB2(I)
         do j=1,ISUB(KG)
            INF(j,KG)=INF(j,I)
         enddo
5590  CONTINUE

      do i=KG+1,NAB
         mtdsys(i)=0
      enddo

      if (io>0) then
         write(io,*)'+++ Reduced central orbitals and their domains +++'
         write(io,*) '  No. Num   Cent       LMOs'
         do i=1,KG
            if(ISUB2(i).eq.0)cycle
            kk=ISUB2(i)
            write(line1,*) kk; call NJ_trim(line1,k1,k2)
            allocate(Ktmp(kk)); Ktmp(1:kk)=INF(1:kk,i)
            call NJ_prtlab(line3,kk,Ktmp);  deallocate(Ktmp)
            call NJ_trim(line3,k5,k6)
            kk=ISUB(i)-ISUB2(i)
            write(line2,*) kk; call NJ_trim(line2,k3,k4)
            allocate(Ktmp(kk)); Ktmp(1:kk)=INF(ISUB2(i)+1:ISUB2(i)+kk,i)
            call NJ_prtlab(line4,kk,Ktmp);  deallocate(Ktmp)
            call NJ_trim(line4,k7,k8)
            write(io,'(i5,a)')i,' ['//line1(k1:k2)//'+'//line2(k3:k4)
     &           //']: ('//line3(k5:k6)//') '//line4(k7:k8)
         enddo
         WRITE(io,*)
         call flshbf(io)
      endif
C
      end
C
C---------------------------------------------------------------------
C     Build the central domains for each Occ spatial orbital
C---------------------------------------------------------------------
C     INF(): orbitals in each domain
C     ISUB(): number of orbitals in each domain
C     ISUB2():number of central orbitals in each domain
      subroutine CentDomn1(io,Nmo,NUW,NCORE,RWORK,FIJ,INF,ISUB,ISUB2,
     &           KSymm)
      implicit none
      integer io,Nmo,NUW,NCORE,I,J,K,L,M,N,K1,K2,kk
      integer INF(NUW,NUW),ISUB(NUW),ISUB2(NUW),KSymm(NUW)
      double precision RWORK(100),FIJ(NUW,NUW),SA
      character*500 line,line1,line2  !-WL,PP- 200 --> 500
      integer,allocatable::Ktmp(:)
C
      INF=0
      ISUB=0
      ISUB2=0
      DO 2300 I=NCORE+1,NUW
         if (KSymm(I).ne.0) cycle  ! 2008.03.04
         INF(1,I)=I
         ISUB(I)=1
         ISUB2(I)=1
2300  CONTINUE
C
      DO 2400 I=NCORE+1,NUW
        if(ISUB2(I).eq.0)cycle
        DO 2450 J=NCORE+1,NUW   !-WL- 5 OCT 2009: 1 --> NCORE+1
          IF (J.EQ.I)cycle
          SA=DABS(FIJ(I,J))
          IF (SA.LT.RWORK(1)) cycle
          K1=ISUB(I)+1
          INF(K1,I)=J
          ISUB(I)=K1
2450    CONTINUE
2400  CONTINUE
C
      if (io>0) then
         write(io,*)'+++ Central orbitals and their',
     *              ' primary environments +++'
         write(io,'(1x,"+++ Primary environment chosen ",
     *              "by Fij >= ",f7.4," (ZETA1) +++")') rwork(1)
         write(io,*) ' No. Num   LMOs'
         do i=NCORE+1,NUW
            if(ISUB2(i).eq.0)cycle
C           write(io,'(i4,2x,20i4)') i,(INF(j,i),j=1,ISUB(i))
C
            kk=ISUB(i)
            write(line1,*) kk; call NJ_trim(line1,k1,k2)
            allocate(Ktmp(kk)); Ktmp(1:kk)=INF(1:kk,i)
            call NJ_prtlab(line2,kk,Ktmp);  deallocate(Ktmp)
            write(io,'(i5,a)')i,' ['//line1(k1:k2)//']: '//trim(line2)
         enddo
         WRITE(io,*)
         call flshbf(io)
      endif
C
      end
C
C --- Compare the sizes of domains and eliminate small domains which are embedded in larger ones
      subroutine ReduDomn1(io,NUW,NCORE,INF,ISUB,ISUB2,KG,mtdsys,
     &                     IWORK)
      implicit none
      integer io,NUW,NCORE,KG,I,J,K,L,NAB,IWORK(100)
      integer INF(NUW,NUW),ISUB(NUW),ISUB2(NUW),mtdsys(NUW)
      character*500 line,line1,line2,line3,line4
      integer k1,k2,k3,k4,k5,k6,k7,k8,kk
      integer,allocatable::Ktmp(:)
C
      NAB=NUW
      call COMPARE(NAB,NCORE+1,NUW,INF,ISUB,ISUB2,mtdsys(1),IWORK(10))
C
C   KG: Number of central domains
      KG=0
      DO 5590 I=NCORE+1,NAB
         if(ISUB2(I).eq.0)cycle
         KG=KG+1
         mtdsys(KG)=mtdsys(I)
         ISUB(KG)=ISUB(I)
         ISUB2(KG)=ISUB2(I)
         do j=1,ISUB(KG)
            INF(j,KG)=INF(j,I)
         enddo
5590  CONTINUE

      do i=KG+1,NAB
         mtdsys(i)=0
      enddo

      if (io>0) then
         write(io,*)'+++ Reduced central orbitals and their domains +++'
         write(io,*) '  No. Num   Cent       LMOs'
         do i=1,KG
            if(ISUB2(i).eq.0)cycle
            kk=ISUB2(i)
            write(line1,*) kk; call NJ_trim(line1,k1,k2)
            allocate(Ktmp(kk)); Ktmp(1:kk)=INF(1:kk,i)
            call NJ_prtlab(line3,kk,Ktmp);  deallocate(Ktmp)
            call NJ_trim(line3,k5,k6)
            kk=ISUB(i)-ISUB2(i)
            write(line2,*) kk; call NJ_trim(line2,k3,k4)
            allocate(Ktmp(kk)); Ktmp(1:kk)=INF(ISUB2(i)+1:ISUB2(i)+kk,i)
            call NJ_prtlab(line4,kk,Ktmp);  deallocate(Ktmp)
            call NJ_trim(line4,k7,k8)
            write(io,'(i5,a)')i,' ['//line1(k1:k2)//'+'//line2(k3:k4)
     &           //']: ('//line3(k5:k6)//') '//line4(k7:k8)
         enddo
         WRITE(io,*)
         call flshbf(io)
      endif
C
      end
C
C
C --- COMPARISON AND ENLARGEMENT OF THE CLUSTER. CORRECT. 2007.4.27.
      subroutine COMPARE(NAB,KG1,KG2,INF,ISUB,ISUB2,mtdsys,mlmerg)
      integer INF(NAB,NAB),ISUB(NAB),ISUB2(NAB),mtdsys(NAB)
      integer,allocatable::Nmin(:)
C
C     mlmerg.ne.0 for merging small high level subsys into a large low level subsys
C              then the large subsys should be run in high level
C              so, mlmerg=0 (default) is a cheap choice
C
      allocate(Nmin(NAB))
      Nmin=1
      DO 5200 I=KG1,KG2
         DO 5250 J=I+1,KG2
            IF (ISUB2(I).EQ.0) GOTO 5200
            IF (ISUB2(J).EQ.0) GOTO 5250
            if (mtdsys(I).eq.0) goto 5200
            if (mtdsys(J).eq.0) goto 5250
C           if (mtdsys(J).ne.mtdsys(I)) goto 5250
            KF=0
            DO 5300 K=1,ISUB(I)
               DO 5350 L=1,ISUB(J)
                  IF (INF(K,I).EQ.INF(L,J)) THEN
                     KF=KF+1
                     GOTO 5300
                  ENDIF
5350           CONTINUE
5300        CONTINUE
C
            I2=KF-ISUB(I)
            J2=KF-ISUB(J)
            IF (I2*J2.NE.0) GOTO 5250
C --- I2==0
C     ENLARGE THE CLUSTER J,  ELIMINATE THE CLUSTER I.
            IF (I2.EQ.0) THEN
               if (mtdsys(J).lt.mtdsys(I)) then
                  if (mlmerg.eq.0) then
                     goto 5250
                  else
                     mtdsys(J)=mtdsys(I)
                  endif
               endif
               mtdsys(I)=0
C
               Nmin(I)=0
c
               DO 5450 K=1,ISUB2(I)
                  IF (INF(K,I).EQ.0) GO TO 5450
                  KF=INF(K,I)
                  DO 5460 L=ISUB2(J)+1,ISUB(J)
                     IF (KF.EQ.INF(L,J)) THEN
                        KK=INF(ISUB2(J)+1,J)
                        INF(ISUB2(J)+1,J)=INF(L,J)
                        INF(L,J)=KK
                        ISUB2(J)=ISUB2(J)+1
                        GO TO 5450
                     ENDIF
5460              CONTINUE
5450           CONTINUE
               goto 5250
            ENDIF
C --- J2==0
C     ENLARGE THE CLUSTER I,  ELIMINATE THE CLUSTER J.
            IF (J2.EQ.0) THEN
               if (mtdsys(J).gt.mtdsys(I)) then
                  if (mlmerg.eq.0) then
                     goto 5250
                  else
                     mtdsys(I)=mtdsys(J)
                  endif
               endif
               mtdsys(J)=0
C
               Nmin(J)=0
C
               DO 5550 K=1,ISUB2(J)
                  IF (INF(K,J).EQ.0) GO TO 5550
                  KF=INF(K,J)
                  DO 5560 L=ISUB2(I)+1,ISUB(I)
                     IF (KF.EQ.INF(L,I)) THEN
                        KK=INF(ISUB2(I)+1,I)
                        INF(ISUB2(I)+1,I)=INF(L,I)
                        INF(L,I)=KK
                        ISUB2(I)=ISUB2(I)+1
                        GO TO 5550
                     ENDIF
5560              CONTINUE
5550           CONTINUE
            ENDIF
5250     CONTINUE
5200  CONTINUE

      do I=KG1,KG2
       if(Nmin(I).eq.0)ISUB2(I)=0
      enddo
C
      deallocate(Nmin)
      return
      end
C
C---------------------------------------------------------------------
C    Build the environmental domain of the same spin for each retained Central Domain. 
C    Reduce the nubmer of full domains after comparison.
C---------------------------------------------------------------------
      subroutine FullDomn(io,isys,NATOM,NW,NMO,NUW,NCORE,SOB,SNB,BA,ZA,
     &           NB,NASUB,NWSUB,INF,INF2,ISUB,ISUB2,ISUB3,ISUB4,FIJ,
     &           KG,KGG,mtdsys,IWORK,RWORK,CWORK,LWORK)
      implicit none
      integer io,NATOM,NW,NMO,NUW,NCORE,KG,I,J,K,L,NAB,KGG,K1,K2,L1,L2
      integer INF(NUW,NUW),INF2(NUW,NUW),ISUB(NUW),ISUB2(NUW),ISUB3(NUW)
      integer ISUB4(NUW),SNB(NUW),SOB(Nmo,NATOM),BA(NATOM,NUW)
      integer ZA(NW,NUW),NASUB(NUW),NWSUB(NUW),NB(NATOM),kk,isys
      integer mtdsys(NUW),IWORK(100)
      double precision FIJ(NUW,NUW),RWORK(100),SA
      character(len=8) CWORK(100)
      logical LWORK(100)
      character*500 line,line1,line2,line3,line4
      integer k3,k4,k5,k6,k7,k8,k2ini
      integer,allocatable::ISUB0(:),Ktmp(:)
C
      allocate(ISUB0(NUW))
      NAB=NUW
C
      do i=1,KG
         ISUB0(I)=ISUB(I)
      enddo
      DO 4690 L1=NCORE+1,NAB
         DO 4600 I=1,KG
            DO  L2=1,ISUB0(I)
               IF (L1.EQ.INF(L2,I))goto 4600
            enddo
C           if (dabs(WRK(2)).ge.0.9999) then   !-WL- NEW SECIM
            if (CWORK(1).EQ.'SECIM   '.OR.CWORK(1).EQ.'GSECIM  ') then
               k2ini=1
            elseif (CWORK(1).EQ.'DECIM   ') then
               k2ini=ISUB2(I)+1
            endif
! IMPORTANT ---------- 2008.07.25 -WL- ISUB2(I)+1 --> 1
C           DO K2=ISUB2(I)+1,ISUB0(I)   ! OLD
C           DO K2=1,ISUB0(I)
! So the Fock values of one MO with all MOs in domain are considered
            DO K2=k2ini,ISUB0(I)
               SA=DABS(FIJ(INF(K2,I),L1))
               IF (SA.ge.RWORK(2).and.CWORK(1).EQ.'DECIM   ') then
                  ISUB(I)=ISUB(I)+1;INF(ISUB(I),I)=L1
                  goto 4600
               endif
            enddo
4600     CONTINUE
4690  CONTINUE
C
      if (io>0) then
         WRITE(io,*) '+++ Full MO domains +++'
         if(cwork(1).eq.'DECIM   ') then
            write(io,'(1x,"+++ Secondary environment chosen by ",
     *             "Fij >= ",f7.4, " (ZETA2) +++")') rwork(2)
         endif
         write(io,*) '  No. Num   Cent         LMOs'
         do i=1,KG
            if(ISUB2(i).eq.0)cycle
            kk=ISUB2(i)
            write(line1,*) kk; call NJ_trim(line1,k1,k2)
            allocate(Ktmp(kk)); Ktmp(1:kk)=INF(1:kk,i)
            call NJ_prtlab(line3,kk,Ktmp);  deallocate(Ktmp)
            call NJ_trim(line3,k5,k6)
            kk=ISUB(i)-ISUB2(i)
            write(line2,*) kk; call NJ_trim(line2,k3,k4)
            allocate(Ktmp(kk))
            Ktmp(1:kk)=INF(ISUB2(i)+1:ISUB2(i)+kk,i)
            call NJ_prtlab(line4,kk,Ktmp);  deallocate(Ktmp)
            call NJ_trim(line4,k7,k8)
            write(io,'(i5,a)')i,' ['//line1(k1:k2)//'+'//line2(k3:k4)
     &           //']: ('//line3(k5:k6)//') '//line4(k7:k8)
         enddo
      endif 

C  Compair the alpha domains
      if (IWORK(13).eq.0) then
         call COMPARE(NAB,1,KG,INF,ISUB,ISUB2,mtdsys(1),IWORK(10))
C     else
C        do i=1,NUW
C           ISUB2(i)=ISUB(i)
C        enddo
      endif

      KGG=0
      do I=1,KG
         if(ISUB2(I).eq.0)cycle
         KGG=KGG+1
C        Construct the atomic domain for each cluster
C        NAsub: number of atoms in the atomic domain
C        NWsub: number of basis in the atomic domain
         call COA(NATOM,NW,NMO,NUW,NB,SOB,SNB,INF(1,I),ISUB(I),
     &        NAsub(KGG),BA(1,KGG),NWsub(KGG),ZA(1,KGG))
C
         if(NAsub(KGG).eq.NATOM)then
            write(io,*)'The whole system will be treated'
c           write(io,*)'Please turn to full calculation'
c           stop
         endif 
C
         mtdsys(KGG)=mtdsys(I)
         DO J=1,ISUB(I)
            INF2(J,KGG)=INF(J,I)
         enddo
         ISUB3(KGG)=ISUB2(I)
         ISUB4(KGG)=ISUB(I) 
      enddo

      do i=1,KGG
         k1=ISUB3(i)
         k2=ISUB4(i)
         call isort(k1,INF2(1,i))
         call isort(k2-k1,INF2(k1+1,i))
      enddo

      do i=KGG+1,NUW
         mtdsys(i)=0
      enddo

      if (io>0) then
         write(io,*)
         WRITE(io,*) '+++ Reduced full MO domains +++'
C        WRITE(io,'('' The number of retained domains ='',i5)')KGG
         write(io,*) '  No. Num   Cent         LMOs'
         write(line1,*) KGG; call NJ_trim(line1,k1,k2)
         rewind(isys)
         write(isys,'(a)') line1(k1:k2)
         do i=1,KGG
            if(ISUB3(i).eq.0)cycle
            kk=ISUB3(i)
            write(line1,*) kk; call NJ_trim(line1,k1,k2)
            allocate(Ktmp(kk)); Ktmp(1:kk)=INF2(1:kk,i)
            call NJ_prtlab(line3,kk,Ktmp);  deallocate(Ktmp)
            call NJ_trim(line3,k5,k6)
            kk=ISUB4(i)-ISUB3(i)
            write(line2,*) kk; call NJ_trim(line2,k3,k4)
            allocate(Ktmp(kk))
            Ktmp(1:kk)=INF2(ISUB3(i)+1:ISUB3(i)+kk,i)
            call NJ_prtlab(line4,kk,Ktmp);  deallocate(Ktmp)
            call NJ_trim(line4,k7,k8)
            write(io,'(i5,a)')i,' ['//line1(k1:k2)//'+'//line2(k3:k4)
     &           //']: ('//line3(k5:k6)//') '//line4(k7:k8)
            write(line1,*) i; call NJ_trim(line1,k1,k2)
            write(isys,'(a)') line1(k1:k2)//' ('//line3(k5:k6)//') '
     &           //line4(k7:k8)
         enddo
C        write(io,'(1x,58(''-''))')
C        write(io,*) ' Domain No.   NOcc    Natom   Basis'
C        do i=1,KGG
C           write(io,'(i6,4x,3i8)') i,ISUB4(i),NAsub(i),NWsub(i)
C        enddo
C        write(io,*)
C        call flshbf(io)
      endif
C
      deallocate(ISUB0)
      end
C
C --- 2008.03.03 Read clusters from .dmn file
      subroutine ReadClu(io,isys,no,nsy,nc_sub,no_sub,occ_sub)
      implicit none
      integer io,isys,no,nsy,i,j,k,L,m,n,k1,k2,k3,k4,k5,k6,k7,k8,kk
      integer nc_sub(no),no_sub(no),occ_sub(no,no)
      character*256 line,line1,line2,line3,line4,string
      integer,allocatable::ntmp(:)
C
      write(io,*) '=== Read the cluster from the .dmn file ==='
      rewind(isys)
      read(isys,*) nsy
      write(io,*) 'The number of subsystems is',nsy
      allocate(ntmp(no))
C
      do i=1,nsy
         read(isys,'(a)',err=100,end=100) line
         k1=index(line,'('); k2=index(line,')')
         write(string,'(a)') line(k1+1:k2-1)
         call NJ_readlab(string,ntmp,no)
         do j=1,no
            occ_sub(j,i)=ntmp(j)
         enddo
         nc_sub(i)=no
         do j=1,no
            if (occ_sub(j,i).eq.0) then
               nc_sub(i)=j-1
               exit
            endif
         enddo
C
         write(string,'(a)') line(k2+1:256)
         ntmp=0
         call NJ_readlab(string,ntmp,no)
         L=nc_sub(i)
         do j=1,no
            k=ntmp(j)
            if (k.ne.0) then
               L=L+1
               if (L.gt.no) then
                  write(io,*) 'To many MOs in subsystem:',i
                  stop
               endif
               occ_sub(L,i)=k
            endif
         enddo
         no_sub(i)=L
      enddo
C
 100  deallocate(ntmp)
      if (io>0) then
         WRITE(io,*) '+++ Full MO domains by reading +++'
         WRITE(io,'('' The number of final domains ='',i5)') nsy
         write(io,*) '  No. Num   Cent         LMOs'
         write(line1,*) nsy; call NJ_trim(line1,k1,k2)
         do i=1,nsy
            if(nc_sub(i).eq.0)cycle
            kk=nc_sub(i)
            write(line1,*) kk; call NJ_trim(line1,k1,k2)
            allocate(ntmp(kk)); ntmp(1:kk)=occ_sub(1:kk,i)
            call NJ_prtlab(line3,kk,ntmp);  deallocate(ntmp)
            call NJ_trim(line3,k5,k6)
            kk=no_sub(i)-nc_sub(i)
            write(line2,*) kk; call NJ_trim(line2,k3,k4)
            allocate(ntmp(kk))
            ntmp(1:kk)=occ_sub(nc_sub(i)+1:nc_sub(i)+kk,i)
            call NJ_prtlab(line4,kk,ntmp);  deallocate(ntmp)
            call NJ_trim(line4,k7,k8)
            write(io,'(i5,a)')i,' ['//line1(k1:k2)//'+'//line2(k3:k4)
     &           //']: ('//line3(k5:k6)//') '//line4(k7:k8)
         enddo
      endif
C
      end
C
C --- 2008.03.07 Read extended subsystems from .dmn file
      subroutine ReadExt(io,isys,nat,nbs,J0,JF,J01,JF1,BA,ZA)
      implicit none
      integer io,isys,nat,nbs,J0,JF,J01,JF1
      integer i,j,k,L,m,n,k1,k2,k3,k4,k5,k6,kk
      integer BA(nat),ZA(nbs)
      character*512 line,line1,line2,line3,line4,string
      integer,allocatable::ntmp(:)
C
      write(io,*) '=== Read the extended subsystem from .dmn file ==='
      read(isys,'(a)',err=100,end=100) line
      k1=index(line,'['); k2=index(line,']')
      write(string,'(a)') line(k1+1:k2-1)
      read(string,*) J01
      write(io,*) 'The number of added atoms is',J01-J0
      kk=nat-J0
      allocate(ntmp(kk))
      ntmp=0
      write(string,'(a)') line(k2+1:256)
      call NJ_readlab(string,ntmp,kk)
      do i=1,kk
         BA(i+J0)=ntmp(i)
      enddo
      deallocate(ntmp)
C
      read(isys,'(a)',err=100,end=100) line
      k1=index(line,'['); k2=index(line,']')
      write(string,'(a)') line(k1+1:k2-1)
      read(string,*) JF1
      write(io,*) 'The number of added basis is',JF1-JF
      kk=nbs-JF
      allocate(ntmp(kk))
      ntmp=0
      write(string,'(a)') line(k2+1:256)
      call NJ_readlab(string,ntmp,kk)
      do i=1,kk
         ZA(i+JF)=ntmp(i)
      enddo
      deallocate(ntmp)
C
      return
C
 100  write(io,*) 'Error for reading the extended subsystems'
      stop
      end
C
C --- 2008.03.07 write extended subsystems from .dmn file
      subroutine WritExt(io,isys,nat,nbs,J0,JF,J01,JF1,BA,ZA)
      implicit none
      integer io,isys,nat,nbs,J0,JF,J01,JF1
      integer i,j,k,L,m,n,k1,k2,k3,k4,k5,k6,kk
      integer BA(nat),ZA(nbs)
      character*512 line,line1,line2,line3,line4,string
      integer,allocatable::ntmp(:)
C
      kk=nat-J0
      write(line1,*) J01
      call NJ_trim(line1,k1,k2)
      allocate(ntmp(kk))
      do i=1,kk
         ntmp(i)=BA(i+J0)
      enddo
      call NJ_prtlab(line2,kk,ntmp)
      deallocate(ntmp)
      call NJ_trim(line2,k3,k4)
      write(isys,'(a)') '['//line1(k1:k2)//'] '//line2(k3:k4)
C
      kk=nbs-JF
      write(line1,*) JF1
      call NJ_trim(line1,k1,k2)
      allocate(ntmp(kk))
      do i=1,kk
         ntmp(i)=ZA(i+JF)
      enddo
      call NJ_prtlab(line2,kk,ntmp)
      deallocate(ntmp)
      call NJ_trim(line2,k3,k4)
      write(isys,'(a)') '['//line1(k1:k2)//'] '//line2(k3:k4)
C
      end
C
C
C --- 2008.03.03 Decide the symmetry of occupied orbitals ---
      subroutine SymmOrb2(io,nmo,ncor,no,FIJ,IWORK,RWORK,KSymm)
      implicit none
      integer io,nmo,ncor,no,i,j,k,L,m,n,LLL,kk,k1,k2,k3,k4,k5,k6
      integer KSymm(no),IWORK(100)  ! ,IrMO(no)
      double precision FIJ(no,no),eps,pii,pjj,pij,p1,p2,RWORK(100)
      character(len=256) line,line1,line2,line3
      integer,allocatable::symo(:,:),nsymo(:),ntmp(:),IrMO(:)
C
      allocate(IrMO(no))
C
      do i=1,no
         KSymm(i)=i
         IrMO(i)=0
      enddo
C
      do i=2,no
         pii=FIJ(i,i)
         do j=1,i-1
            pjj=FIJ(j,j)
            if (dabs(pjj-pii).lt.RWORK(9)) then
               KSymm(i)=KSymm(j)
               exit
            endif
         enddo
      enddo
C
      do i=1,no
         if (KSymm(i).eq.i) KSymm(i)=0
      enddo
C
      LLL=0
      do i=ncor+1,no
         if (KSymm(i).eq.0) then
            LLL=LLL+1
            IrMO(LLL)=i
         endif
      enddo
C
      if (LLL.eq.no-ncor) then
C        write(io,*) 'No symmetric LMOs for this system'
         return
      endif
C
      allocate(symo(no,LLL),nsymo(LLL))
      symo=0
      nsymo=0
      do i=1,LLL
         symo(1,i)=IrMO(i)
         m=IrMO(i)
         L=1
         do j=ncor+1,no
            if (j.eq.m) cycle
            if (KSymm(j).eq.m) then
               L=L+1
               symo(L,i)=j
            endif
         enddo
         nsymo(i)=L
      enddo
C
C     write(io,*) '=== Checking the symmetry of occupied LMOs ==='
C     write(io,100) RWORK(9)
C     write(io,*) 'NO LMOs'
C     do i=1,LLL
C        write(line1,*) i
C        call NJ_trim(line1,k1,k2)
C        kk=nsymo(i)
C        call NJ_prtlab(line2,kk,symo(1,i))
C        call NJ_trim(line2,k3,k4)
C        write(io,*) line1(k1:k2)//' ('//line2(k3:k4)//')'
C     enddo
C
      if (IWORK(6).ne.0) then
         IWORK(6)=LLL
         write(io,*) 'The symmetry of occupied LMOs are used'
      else
         do i=1,no
            KSymm(i)=0
         enddo
C        write(io,*) 'The symmetry of occupied LMOs are not used'
      endif
      write(io,*)
C
 100  format(1x,'The threshold of Fock matrix =',d12.4)
      deallocate(symo,nsymo,IrMO)
C
      end      
C
C --- Sort integer array ---
      subroutine isort(n,A)
      integer n,A(n),i,j,k1,k2,L
C
      do i=1,n-1
         do j=i+1,n
            if (A(i).gt.A(j)) then
               L=A(i)
               A(i)=A(j)
               A(j)=L
            endif
         enddo
      enddo
C
      end
C
C --- Sort integer array ---
      subroutine absisort(n,A)
      integer n,A(n),i,j,k1,k2,L
C
      do i=1,n-1
         do j=i+1,n
            if (abs(A(i)).gt.abs(A(j))) then
               L=A(i)
               A(i)=A(j)
               A(j)=L
            endif
         enddo
      enddo
C
      end
C
C---------------------------------------------------------------------
C     CONSTRUCT THE ATOMIC DOMAIN OF EACH MO DOMAIN --07.01.26
!        call COA(NATOM,NW,NMO,NUW,NB,SOB,SNB,INF(1,I),ISUB(I),
!    &        NAsub(KGG),BA(1,KGG),NWsub(KGG),ZA(1,KGG))
C---------------------------------------------------------------------
      subroutine COA(NATOM,NW,NMO,NUW,nb,SOB,SNB,INF,ISUB,J0,BA,JF,ZA)
      integer SOB(NMO,NATOM),SNB(NUW),INF(NUW),BA(NATOM),ZA(NW)
      integer nb(NATOM)
C
      ii=INF(1)
      J0=SNB(ii)
C
      DO J=1,J0
         BA(J)=SOB(ii,J)
      enddo
C
      J2=J0
      DO J=2,ISUB
         J1=INF(J)
         DO 3689 K=1,SNB(J1)
            DO  L=1,J0
               IF (SOB(J1,K).EQ.BA(L))GO TO 3689
            enddo
            J2=J2+1
            BA(J2)=SOB(J1,K)
3689     CONTINUE
         J0=J2
      enddo
C
        ZA=0;JF=0
        DO 3695 J=1,J0
           K1=nb(BA(J))
           if(BA(j).ne.NATOM)then
            K2=nb(BA(J)+1)-1
           else
            K2=NW
           endif
           DO 3697 K=K1,K2
              JF=JF+1
              ZA(JF)=K
3697       CONTINUE
3695    CONTINUE
      return
      end
C
c     ##############################################################
c     ##  subroutine NJ_dislink  --  atoms distance&link matrix   ##
c     ##  2005.01.09 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################
c
c     2005.04.12 modify ad from 0.2 to 0.1
c     2005.05.07 modify ad from 0.1 to 0.15
c
      subroutine NJ_dislink(io,nat,nuchar,coor,dis,link)
      implicit none
      integer io,nat,link(nat,nat),i,j,k,l,lk(10)
      real*8 nuchar(nat),coor(3,nat),dis(nat,nat),x,y,z,dis0,radius,ad
      real*4 bdtp(10)
      parameter (ad=0.168d0) ! 2005.05.22 0.16 --> 0.168
      external radius

      dis=0d0; link=0
      do i=1,nat-1; do j=i+1,nat
         x=coor(1,i)-coor(1,j)
         y=coor(2,i)-coor(2,j)
         z=coor(3,i)-coor(3,j)
         dis(i,j)=dsqrt(x*x+y*y+z*z); dis(j,i)=dis(i,j)
         k=nint(nuchar(i)); l=nint(nuchar(j))
         dis0=radius(k)+radius(l)+ad
         if (dis(i,j)<dis0) then
            link(i,j)=1; link(j,i)=1
         endif
      enddo; enddo

      if (io>0) then
         write(io,*) '*** Distance matrix (angstroms) ***'
         call NJ_prtsym(io,nat,dis,'f11.6')
         write(io,*)
         write(io,*) '*** Geometry links ***'
         do i=1,nat
            lk=0; bdtp=0.0; k=0
            do j=i+1,nat
               if (link(i,j).ne.0) then
                  k=k+1; lk(k)=j; bdtp(k)=real(link(i,j))
               endif
            enddo
            write(io,'(i6,2x,10(i6,f4.1))') i,(lk(j),bdtp(j),j=1,k)
         enddo
         write(io,*)
      endif

      end
C
C 2006.12.16 modify to van de Walls radii
      subroutine NJ_dislink1(io,nat,nuchar,coor,dis,link,link_vdw)
      implicit none
      integer io,nat,link(nat,nat),i,j,k,l,lk(10),link_vdw(nat,nat)
      real*8 nuchar(nat),coor(3,nat),dis(nat,nat),x,y,z,dis0,radius,ad
      real*8 radius_vdw,dis_vdw,dis1
      real*4 bdtp(10)
      parameter (ad=0.168d0) ! 2005.05.22 0.16 --> 0.168
      external radius,radius_vdw

      dis=0d0; link=0
      do i=1,nat-1; do j=i+1,nat
         x=coor(1,i)-coor(1,j)
         y=coor(2,i)-coor(2,j)
         z=coor(3,i)-coor(3,j)
         dis(i,j)=dsqrt(x*x+y*y+z*z); dis(j,i)=dis(i,j)
         k=nint(nuchar(i)); l=nint(nuchar(j))
         dis0=radius(k)+radius(l)+ad
         dis1=radius_vdw(k)+radius_vdw(l)
         if (dis(i,j)<dis0) then
            link(i,j)=1; link(j,i)=1
         endif
         if (dis(i,j)<dis1) then
            link_vdw(i,j)=1; link_vdw(j,i)=1
         endif
      enddo; enddo

      if (io>0) then
         write(io,*) '*** Distance matrix (angstroms) ***'
         call NJ_prtsym(io,nat,dis,'f11.6')
         write(io,*)
         write(io,*) '*** Geometry links ***'
         do i=1,nat
            lk=0; bdtp=0.0; k=0
            do j=i+1,nat
               if (link(i,j).ne.0) then
                  k=k+1; lk(k)=j; bdtp(k)=real(link(i,j))
               endif
            enddo
            write(io,'(i6,2x,10(i6,f4.1))') i,(lk(j),bdtp(j),j=1,k)
         enddo
         write(io,*)
      endif

      end
C
C --- 2006.05.21 IDis Calc.
      subroutine NJ_idis(nat,link,IDis)
      implicit none
      integer nat,link(nat,nat),IDis(nat,nat),i,j,k,L,m,n
C
      IDis=100000
C
      do i=1,nat-1
         do j=i+1,nat
            if (link(i,j)==1) then
               IDis(i,j)=1
               IDis(j,i)=1
            endif
         enddo
      enddo
C
      do m=1,10
         do i=1,nat-1
            do j=i+1,nat
               do k=1,nat
                  if (k==i.or.k==j) cycle
                  L=IDis(i,k)+IDis(j,k)
                  if (L.ne.m) cycle
                  if (L<IDis(i,j)) then
                     IDis(i,j)=L
                     IDis(j,i)=L
                  endif
               enddo
            enddo
         enddo
      enddo
C
      do i=1,nat
         IDis(i,i)=0
      enddo
C
      end
C
c     ##############################################################
c     ##  function radius  --  radius for an atom on order        ##
c     ##  2005.01.09 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################
c
c     2005.05.07 modify r(S) from 1.01 to 1.11
c
      function radius(n)
      implicit none
      integer n
      real*8 radius,Radi(109)

      data Radi/0.30d0,1.16d0,1.23d0,0.89d0,0.88d0,
     &     0.77d0,0.70d0,0.66d0,0.58d0,0.55d0,
     &     1.40d0,1.36d0,1.25d0,1.17d0,1.10d0,
     &     1.11d0,0.99d0,1.58d0,2.03d0,1.74d0,
     &     1.44d0,1.32d0,1.20d0,1.13d0,1.17d0,
     &     1.16d0,1.16d0,1.15d0,1.17d0,1.25d0,
     &     1.25d0,1.22d0,1.21d0,1.17d0,1.14d0,
     &     1.89d0,2.25d0,1.92d0,1.62d0,1.45d0,
     &     1.34d0,1.29d0,1.23d0,1.24d0,1.25d0,
     &     1.28d0,1.34d0,1.41d0,1.50d0,1.40d0,
     &     1.41d0,1.37d0,1.33d0,2.09d0,2.35d0,
     &     1.98d0,1.69d0,1.65d0,1.65d0,1.64d0,
     &     1.64d0,1.66d0,1.85d0,1.61d0,1.59d0,
     &     1.59d0,1.58d0,1.57d0,1.56d0,1.70d0,
     &     1.56d0,1.44d0,1.34d0,1.30d0,1.28d0,
     &     1.26d0,1.26d0,1.29d0,1.34d0,1.44d0,
     &     1.55d0,1.54d0,1.52d0,1.53d0,1.52d0,
     &     1.53d0,2.45d0,2.02d0,1.70d0,1.63d0,
     &     1.46d0,1.40d0,1.36d0,1.25d0,1.57d0,
     &     1.58d0,1.54d0,1.53d0,1.84d0,1.61d0,
     &     1.50d0,1.49d0,1.38d0,1.36d0,1.26d0,
     &     1.20d0,1.16d0,1.14d0,1.06d0/

      if (n>109) stop 'Nuclear charge >109'
      radius=Radi(n)

      end


c     ##############################################################
c     ##  function radius  --  radius for an atom on symbol       ##
c     ##  2005.01.09 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################
c
      function radich(a)
      implicit none
      integer n,elemord
      character a*2
      real*8 radich,radius
      external elemord,radius

      n=elemord(a)
      radich=radius(n)

      end
c     ##############################################################
C     2006.12.16 modified by sj
C     van der Waals radii/from Bondi:H--K,witout Be
c     ##############################################################
      function radius_vdw(n)
      implicit none
      integer n
      real*8 radius_vdw,Radi(109)

      data Radi/1.20d0,1.40d0,1.82d0,0.89d0,2.13d0,
     &     1.70d0,1.55d0,1.52d0,1.47d0,1.54d0,
     &     2.27d0,1.73d0,2.51d0,2.10d0,1.80d0,
     &     1.75d0,1.88d0,2.75d0,2.03d0,1.74d0,
     &     1.44d0,1.32d0,1.20d0,1.13d0,1.17d0,
     &     1.16d0,1.16d0,1.15d0,1.17d0,1.25d0,
     &     1.25d0,1.22d0,1.21d0,1.17d0,1.14d0,
     &     1.89d0,2.25d0,1.92d0,1.62d0,1.45d0,
     &     1.34d0,1.29d0,1.23d0,1.24d0,1.25d0,
     &     1.28d0,1.34d0,1.41d0,1.50d0,1.40d0,
     &     1.41d0,1.37d0,1.33d0,2.09d0,2.35d0,
     &     1.98d0,1.69d0,1.65d0,1.65d0,1.64d0,
     &     1.64d0,1.66d0,1.85d0,1.61d0,1.59d0,
     &     1.59d0,1.58d0,1.57d0,1.56d0,1.70d0,
     &     1.56d0,1.44d0,1.34d0,1.30d0,1.28d0,
     &     1.26d0,1.26d0,1.29d0,1.34d0,1.44d0,
     &     1.55d0,1.54d0,1.52d0,1.53d0,1.52d0,
     &     1.53d0,2.45d0,2.02d0,1.70d0,1.63d0,
     &     1.46d0,1.40d0,1.36d0,1.25d0,1.57d0,
     &     1.58d0,1.54d0,1.53d0,1.84d0,1.61d0,
     &     1.50d0,1.49d0,1.38d0,1.36d0,1.26d0,
     &     1.20d0,1.16d0,1.14d0,1.06d0/
      if (n>109) stop 'Nuclear charge >109'
      radius_vdw=Radi(n)
      end
C
      function radich_vdw(a)
      implicit none
      integer n,elemord
      character a*2
      real*8 radich_vdw,radius_vdw
      external elemord,radius_vdw

      n=elemord(a)
      radich_vdw=radius_vdw(n)

      end
C
c     ##############################################################
c     ##  subroutine NJ_readfrg - read integer Ftmp() from a line ##
c     ##  2004.04.29 by Wei Li; Update 2008.03.03 by Wei Li       ##
c     ##############################################################
c
c     2004.04.29 read integer Ftmp() from a line*lst with format (i,j,k-m,n)
c
      subroutine NJ_readlab(string,Ftmp,IFrg)
      character string*(*),string2*1024,string3*1024
      integer Ftmp(IFrg)

      Ftmp=0; lst=len(string)
      if (lst>1024) stop 'Too long string (>1024) for ReadLab()'

      Nlink=index(string,'-')
      lll=1
      if (Nlink.eq.0) then
         read(string,*,err=2990,end=2990) (Ftmp(j),j=1,IFrg),kk
         if (kk.ne.0) then
            write(*,*) 'Error: Too more atoms in a fragment'
            stop '1'
         endif
      else
         Ncomma=index(string,',')
         if (Ncomma.eq.0) then
            write(string2,'(A)') string(1:Nlink-1)
          read(string2,*) ini
            write(string2,'(A)') string(Nlink+1:lst)
          read(string2,*) ifi
            if (ifi-ini+1.gt.IFrg) then
               write(*,*) 'Error: Too more atoms in ',
     &       'fragment or too small size of fragment'
               stop '2'
            endif
            do 2500 kkk=ini,ifi
               Ftmp(lll)=kkk
               lll=lll+1
2500        continue
         else
            write(string2,'(A)') string(1:Ncomma-1)
            Nlink=index(string2,'-')
            if (Nlink.eq.0) then
               read(string2,*) Ftmp(lll)
               lll=lll+1
            else
               write(string3,'(A)') string2(1:Nlink-1)
               read(string3,*) ini
               write(string3,'(A)') string2(Nlink+1:lst)
               read(string3,*) ifi

               if (ifi-ini+1.gt.IFrg) then
                  write(*,*) 'Error: Too more atoms in ',
     &          'fragment or too small size of fragment'
                  stop '3'
               endif
               do 2510 kkk=ini,ifi
                  Ftmp(lll)=kkk
                  lll=lll+1
2510           continue
            endif

            do 2520 jjj=1,IFrg
               string2=string(Ncomma+1:lst)
               write(string,'(A)') trim(string2)   !-WL- 2008.03.03 string2 --> trim(string2)
               Ncomma=index(string,',')
               if (Ncomma.ne.0) then
                  write(string2,'(A)') string(1:Ncomma-1)
               else
                  write(string2,'(A)') string
               endif

               Nlink=index(string2,'-')

               if (Nlink.eq.0) then
                  read(string2,*) Ftmp(lll)
                  lll=lll+1
               else
                  write(string3,'(A)') string2(1:Nlink-1)
                  read(string3,*) ini
                  write(string3,'(A)') string2(Nlink+1:lst)
                  read(string3,*) ifi

                  if (ifi-ini+1.gt.IFrg) then
                     write(*,*) 'Error: Too more atoms in ',
     &             'fragment or too small size of fragment'
                     stop '4'
                  endif
                  do 2530 kkk=ini,ifi
                     Ftmp(lll)=kkk
                     lll=lll+1
2530              continue
               endif

               if (Ncomma.eq.0) goto 2990
2520        continue
         endif
      endif

2990  if (lll.gt.IFrg+1) then
         write(*,*) 'Error: Too more atoms in ',
     & 'fragment or too small size of fragment'
         stop '5'
      endif

      return
      end
C
c     ##############################################################
c     ##  subroutine NJ_prtlab  --  write Ktmp(kk) into line      ##
c     ##  2005.01.09 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################
c
c     Format: "1,3,5-8,2*0,9"
c
      subroutine NJ_prtlab(line,kk,Ktmp)
      integer Ktmp(kk),kkk
      parameter (linemax=80)
      character ch,ch2,line*(*),line1*100,line2*100
      parameter (ch=',',ch2='-')

      line=' '; ini=1; fc=1
      if (kk==0) return

      write(line1,*) Ktmp(1)
      call NJ_trim(line1,k1,k2)
      line(ini:ini+k2-k1)=line1(k1:k2)
      ini=ini+k2-k1+1
      nz=0
C
      kkk=min(2,kk)
C
      if (Ktmp(1)==0.and.Ktmp(kkk)==0) then
         fc=0; nz=1; ini=1
      endif

      do 110 i=2,kk
         write(line1,*) Ktmp(i)
         call NJ_trim(line1,k1,k2)
         if (Ktmp(i)-Ktmp(i-1)==1) then
            if (i<kk) kkk=Ktmp(i+1)-Ktmp(i)
            if (i==kk.or.kkk.ne.1) then
               line(ini:ini+k2-k1+1)=ch2//line1(k1:k2)
               ini=ini+k2-k1+2
            endif
         elseif (Ktmp(i)==0) then
            nz=nz+1
            if (i==kk) then
               if (nz==1) then
                  line(ini:ini+1)=ch//'0'; ini=ini+2
               else
                  write(line2,*) nz; call NJ_trim(line2,k3,k4)
                  if (fc==1) then  ! 2005.01.09 add
                     line(ini:ini+k4-k3+3)=ch//line2(k3:k4)//'*0'
                     ini=ini+k4-k3+4; exit
                  else
                     line(ini:ini+k4-k3+2)=line2(k3:k4)//'*0'
                     ini=ini+k4-k3+3; fc=1; exit
                  endif
               endif
            else
               if (Ktmp(i+1).ne.0.and.nz==1) then
                  line(ini:ini+1)=ch//'0'; ini=ini+2; nz=0
               elseif (Ktmp(i+1).ne.0.and.nz.ne.1) then
                  write(line2,*) nz; call NJ_trim(line2,k3,k4)
                  if (fc==1) then  ! 2005.01.09 add
                     line(ini:ini+k4-k3+3)=ch//line2(k3:k4)//'*0'
                     ini=ini+k4-k3+4; nz=0
                  else
                     line(ini:ini+k4-k3+2)=line2(k3:k4)//'*0'
                     ini=ini+k4-k3+3; nz=0; fc=1
                  endif
               endif
            endif
         else
            line(ini:ini+k2-k1+1)=ch//line1(k1:k2)
            ini=ini+k2-k1+2
         endif
 110  enddo

      end
C*MODULE CIMI    *DECK CIMCALC
C>
C> @brief   Calculations of I-th subsystem
C>
C> @details Calculations of I-th subsystem
C>
C> @author  probably Wei Li
C>
C
      subroutine CIMCalc(I,io,isys,NATOM,NW,NUW,Nmo,NCORE,
     &     IWORK,RWORK, numc
     &     ,numh,natc,nath,nuchar,coor,dis,link,SMO,FK,SOVER,admx,admy,
     &     admz,NB,BAA,ZAA,SOB,SNB,NASUB,NWSUB,SR1,INF2,ISUB3,ISUB4,KGG,
C-WL-&     basis,gmsname,kmem,imethd,ED,NCLU)
C-WL-&     basis,gmsname,kmem,imethd,ED,NCLU,HCORE,mthd0)  !-WL- 2007.10.18 add mthd0
     &     basis,gmsname,kmem,ED,NCLU,scftyp,levlsys,
     &     job,istop,mbytes,ISUB5,NOB,FKB,  !-WL- 2007.10.18 add mthd
     &     CenMO,path,user,NCBS,CBAS)
      implicit none

C     COMMON /IOFILE/ IR2,Io,IP2,IS2,IPK2,IDAF2,NAV2,IODA2(950)
C     COMMON /CIMINF/ ICIM2,inp,MOTYP2,NCA2,NCB2  !-CIM-
C     integer icim2,ir2,ip2,is2,ipk2,idaf2,nav2,ioda2,nca2,ncb2
C     character*8 motyp2

      integer thissystem
      integer inp,itmp,itmp1,icim,isys,job,istop
      parameter(inp=111,itmp=115,itmp1=116)  ! liwei
      parameter(icim=117)
      integer io,NATOM,NW,NUW,Nmo,I,j,k,L,m,n,NCORE,LLL,ierr,NOA,NOB
      integer k1,k2,k3,k4,kmem,NV,I8,imethd
      integer KGG,numc,numh,KU,KB,J0,JF,NF,J01,JF1,NA,KB1,local
      integer KV,KVA,KCC,JF_sub,J0_sub
      character line*500,line1*500,line2*500,command*500
      character*100 gmsname,subname,inpname
      character*100 outname,tmpname,cimname
      character mem*20,mthd*20,basis*30,runtyp*20,mthd0*20
      character*8 scftyp,cctyp
      character path*200,user*50
      integer mplevl,IWORK(100)
      integer I_rd,KU_rd,KB_rd,J0_rd,JF_rd
      integer KBB,KUB,CenMO(NUW,KGG),mult,nucl,icharg
C
      double precision PP,EE,RWORK(100)
      double precision SOVER(NW,NW),SMO(NW,Nmo)
      double precision nuchar(NATOM),coor(3,NATOM),FK(NW,NW),FKB(NW,NW)
      double precision admx(NW,NW),admy(NW,NW),admz(NW,NW)
C
      double precision SR1(NATOM,Nmo),dis(NATOM,NATOM),ED(NUW),ps
      integer SNB(NUW),SOB(Nmo,NATOM),INF2(NUW,NUW),NCLU(NUW)
      integer ISUB3(NUW),ISUB4(NUW),BAA(NATOM,NUW),ZAA(NW,NUW),NB(NATOM)
      integer NASUB(NUW),NWSUB(NUW),natc(NATOM),nath(NATOM)
      integer link(NATOM,NATOM),link2(NATOM,NATOM)
      integer ISUB5(NUW)    !-WL- 2009.03.18 For NU
C
      integer,dimension(:),allocatable::ML,Ktmp,BA,ZA
      double precision,dimension(:,:),allocatable::MOS,MOS2,F2,F2B,FH
      double precision,dimension(:,:),allocatable::MOS1
      double precision,dimension(:,:),allocatable::VECT,MAT,AVECT,OVS3
      double precision,dimension(:,:),allocatable::AVECTB
      double precision,dimension(:),allocatable::VALU,VC,FHH
      double precision,dimension(:),allocatable::dtmp,RCent
      double precision,dimension(:,:),allocatable::DM,PPS
      double precision trace,dtrace2
      external dtrace2
C
      integer LF2,nelec,nwords,mwords,memgms,levlsys,mbytes
      external memgms
      integer NCBS(NATOM)
      character(len=100) CBAS(100,NATOM)
C
      logical exst
      integer (kind=4) Wall0,Wall,TIME
      real*8 Tim0,CPUTim
      external CPUTim !,TIME
      integer,external::system
C
      if (levlsys.eq.0) return
C
      Tim0=CPUTim(0)
C     Wall0=TIME()
C
      write(io,'(1x,16(''-''))')
      write(io,'(''  SUBSYSTEM'',i5)') I
      write(io,'(1x,16(''-''))')
C
      call NJ_trim(gmsname,k1,k2)
      write(line,*) I
      call NJ_trim(line,k3,k4)
      subname=gmsname(k1:k2-3)//'Sys-'//line(k3:k4)
      inpname=trim(subname(1:96))//'.inp'
      outname=trim(subname(1:96))//'.log'
      tmpname=trim(subname(1:96))//'.tmp'
      cimname=trim(subname(1:96))//'.cim'
      inquire(file=inpname,exist=exst)
      if(exst) then
         levlsys = -1
         write(io,"('Subsystem input exists.'/)")
         write(io,"('Continuing to the next'/)")
         return
      endif
C
      L=levlsys
      if (L.eq.1) then
         mplevl = 2
         cctyp  = 'NONE    '
      elseif (L.eq.2) then
         mplevl = 0
         cctyp  = 'CCD     '
      elseif (L.eq.3) then
         mplevl = 0
         cctyp  = 'CCSD    '
      elseif (L.eq.4) then
         mplevl = 0
         cctyp  = 'CCSD(T) '
      elseif (L.eq.5) then
         mplevl = 0
         cctyp  = 'CR-CCL  '
      else
         write(io,'('' Unknown level'',i3,'' for subsys:'',i5)') L,I
         call abrt
      endif
C
      KU=ISUB3(I)   ! Number of occupied orbitals in the cluster
      KB=ISUB4(I)   ! Number of occupied orbitals in the subsystem
      J0=NAsub(I)   ! Number of atoms in the subunit
      JF=NWsub(I)   ! Number of basis functions in the subunit
C
C---------------------------------------------------------------------
      allocate(ML(NUW),BA(NATOM),ZA(NW))
      ML(1:NUW)=INF2(1:NUW,I)
      BA(1:NATOM)=BAA(1:NATOM,I)
      ZA(1:NW)=ZAA(1:NW,I)
C
C--- liwei 10 Feb 2009 --- Decide the spin and mult here
      mult=1
      do J=1,KB
         if (ML(J).gt.NOB) mult=mult+1
      enddo
      KBB=KB+1-mult
C
C --- 2 JUL 10 -WL,PP- KUB = KU if single-occ MO is environment MO
C     KUB=KU+1-mult
      KUB=0
      do k=1,KB
         if (CenMO(k,I).eq.2) KUB=KUB+1
      enddo
C
      if (mult.eq.1) then
         if (IWORK(14).eq.0) then
            write(io,*) 'Closed shell subsystem: SCFTYP=RHF'
            scftyp='RHF     '
         else
            write(io,*) 'Closed shell subsystem: SCFTYP=ROHF'
            scftyp='ROHF    '
         endif
      else
         write(io,*) 'Open shell subsystem  : SCFTYP=ROHF'
         write(io,'(1x,"MULT = ",i3)') mult
         scftyp='ROHF    '
      endif
C--- liwei 10 Feb 2009 --- END
C
C---------------------------------------------------------------------
C     REORDER ML(I),I=1,KU, FROM SMALL TO LARGE. 2001.4.17.
C---------------------------------------------------------------------
      if (KU.gt.1)then
         DO 3660 J=1,KU-1
            NF=ML(J)
            DO 3670 K=J+1,KU
               IF (ML(K).LT.NF) THEN
                  NF=ML(K)
                  ML(K)=ML(J)
                  ML(J)=NF
               ENDIF
3670        CONTINUE
3660     CONTINUE
      endif
C
C---------------------------------------------------------------------
C     TO CONSTRUCT SUBSYSTEM DOMAINS. 2001.4.24.
C---------------------------------------------------------------------
      write(line1,*) KU;   call NJ_trim(line1,k1,k2)
      allocate(Ktmp(KU));  Ktmp(1:KU)=ML(1:KU)
      call NJ_prtlab(line2,KU,Ktmp);  deallocate(Ktmp)
      write(io,'(a)') ' Central Orbitals ('
     &               //line1(k1:k2)//'): '//trim(line2)
C 
      write(line1,*) KB-KU;   call NJ_trim(line1,k1,k2)
      allocate(Ktmp(KB-KU));  Ktmp(1:KB-KU)=ML(KU+1:KB)
      call NJ_prtlab(line2,KB-KU,Ktmp);  deallocate(Ktmp)
      write(io,'(a)') ' Environment orbitals ('
     *   //line1(k1:k2)//'): '//trim(line2)
C 
      write(line1,*) J0;   call NJ_trim(line1,k1,k2)
      allocate(Ktmp(J0));  Ktmp(1:J0)=BA(1:J0)
      call NJ_prtlab(line2,J0,Ktmp);  deallocate(Ktmp)
      write(io,'(a)') ' Atoms ('//line1(k1:k2)//'): '//trim(line2)
      write(io,'(" Basis Functions: ",i5)') jf
C 
C     write(line1,*) JF;   call NJ_trim(line1,k1,k2)
C     allocate(Ktmp(JF));  Ktmp(1:JF)=ZA(1:JF)
C     call NJ_prtlab(line2,JF,Ktmp);  deallocate(Ktmp)
C     write(io,'(a)') ' Basis ('//line1(k1:k2)//'): '//trim(line2)
C 
      if (IWORK(7).eq.0) then
         write(isys,*)
         write(isys,'(i5)') I
         write(isys,'(4i5)') KU,KB,J0,JF
      else
         read(isys,*,end=251)
         read(isys,*,end=252) I_rd
         read(isys,*,end=253) KU_rd,KB_rd,J0_rd,JF_rd
         ierr=0
         if (I_rd.ne.I) ierr=ierr+1
         if (KU_rd.ne.KU) ierr=ierr+1
         if (KB_rd.ne.KB) ierr=ierr+1
         if (ierr.ne.0) then
           write(io,*)'The number of ERRORS is',ierr
           write(io,*)'Calc I,KU,KB =',I,KU,KB
           write(io,*)'Read I,KU,KB =',I_rd,KU_rd,KB_rd
           STOP
         endif
         ierr=0
         if (J0_rd.ne.J0) ierr=ierr+1
         if (JF_rd.ne.JF) ierr=ierr+1
         if (ierr.ne.0) then
           write(io,*)'The number of WARNINGS is',ierr
           write(io,*)'Calc J0,JF =',J0,JF
           write(io,*)'Read J0,JF =',J0_rd,JF_rd
           IWORK(7)=0
           write(io,*) 'WARNING: Only occ MOs can be read ...'
         endif
C
         goto 300
 251     write(isys,*)
 252     write(isys,'(i5)') I
 253     write(isys,'(4i5)') KU,KB,J0,JF
         IWORK(7)=0
         write(io,*) 'Warn: Only occ MOs can be read ...'
      endif
C
C---------------------------------------------------------------------
C     Add buffer atoms in order to construct virtual orbitals
C---------------------------------------------------------------------
 300  continue
      write(io,*)
      write(io,*) '--- GENERATING EXTENDED SUBSYSTEM AND ORBITALS ---'
      if (IWORK(7).eq.0) then
         if (J0.lt.NATOM)then   ! .and. dabs(WRK(5)).gt.1d-5  2008.05.09 Add dabs(WRK(5)) for no expanded subsys for dis=0
            call AddAtom(NATOM,NW,Nmo,NUW,nb,numc,numh,natc,nath,
     &           J0,JF,J01,JF1,ML,BA,ZA,link,dis,RWORK)
         else 
            J01=J0
            JF1=JF
         endif
         call WritExt(io,isys,NATOM,NW,J0,JF,J01,JF1,BA,ZA)
      else
         call ReadExt(io,isys,NATOM,NW,J0,JF,J01,JF1,BA,ZA)
      endif
C
      if (J01.eq.NATOM)then
         write(io,*)'*** The extended subsystem includes',
     *       ' the whole molecule ***'
      endif
C
      write(line1,*) J01-J0;   call NJ_trim(line1,k1,k2)
      allocate(Ktmp(J01-J0));  Ktmp(1:J01-J0)=BA(J0+1:J01)
      call NJ_prtlab(line2,J01-J0,Ktmp);  deallocate(Ktmp)
C     write(io,'(a)') ' Added Atoms ('//line1(k1:k2)//'): '//trim(line2)
      write(io,'(a)') ' Added Atoms: '//line1(k1:k2)
C 
      write(line1,*) JF1-JF;   call NJ_trim(line1,k1,k2)
      allocate(Ktmp(JF1-JF));  Ktmp(1:JF1-JF)=ZA(JF+1:JF1)
      call NJ_prtlab(line2,JF1-JF,Ktmp);  deallocate(Ktmp)
C     write(io,'(a)') ' Added Basis ('//line1(k1:k2)//'): '//trim(line2)
      write(io,'(a)') ' Added Basis Functions: '//line1(k1:k2)
C 
C --- Add Occ MOs KB --> KB1-- ML(KB+1:KB1) -------------------------------
         KB1=KB
         do j=1,NUW
          do k=1,KB
           if(j.eq.ML(k))goto 240
          enddo
          ps=0.0d0
          do k=1,J01
           ps=ps+SR1(BA(k),j)
          enddo
          if(ps.gt.RWORK(8))then
            KB1=KB1+1;ML(KB1)=j
            goto 240
           endif
240      enddo
C
      write(line1,*) KB1-KB;   call NJ_trim(line1,k1,k2)
      allocate(Ktmp(KB1-KB));  Ktmp(1:KB1-KB)=ML(KB+1:KB1)
      call NJ_prtlab(line,KB1-KB,Ktmp);  deallocate(Ktmp)
      write(io,'(a)')' Added Occ Orb ('//line1(k1:k2)//'): '//trim(line)
C --------------------------------------------------------------------------

      call flshbf(io)
C
C-WL- ADD; This is important   !-WL- 11/16 moved here
      INF2(1:NUW,I)=ML(1:NUW)
C       
C---------------------------------------------------------------------
C     TO ASSIGN VIRTUAL ORBITALS TO THIS SUBSYSTEM. 2006.5.24.
C---------------------------------------------------------------------
      allocate(MOS1(JF1,JF1),MOS2(JF,JF),OVS3(JF,JF))  !-WL- ADD MOS1 2008.02.25
C --- liwei here
      local=1  ! 1~ Boys  3~ Pop ! -----------------
      call COV(io,isys,NATOM,NW,Nmo,NUW,nb,
     &J0,JF,J01,JF1,NA,KB,KB1,ML,BA,ZA,SR1,admx,admy,admz,
     &SOVER,SMO,MOS1,MOS2,local,OVS3,IWORK,RWORK)
C
      WRITE(io,705) NA-KB
      WRITE(io,706) NA
C
      if (NA==KB) then
        write(io,*) 'Error: Number of virtual orbitals is zero'
        stop
      endif
C
C ----------------------- WL 2008.02.26 ------------------------
C     IWORK(2)=1~4                 ! Use LMOs projected on subsystems
C     IWORK(2)=11                  ! Use LMOs projected on extended subsystems
C     You can use motyp=k as keyword after '#' in input file (default IWOORRK(2)=2)
      JF_sub=JF                  ! Save the number of AOs on subsystem as JF_sub
      J0_sub=J0                  ! Save the number of atoms on subsystem as J0_sub
C
      if (IWORK(2).ge.1.and.IWORK(2).le.10) then      ! MOS2(JF,JF) --> MOS(JF,NA): LMOs of cluster
         allocate(MOS(JF,NA))
         do j=1,NA
            do k=1,JF
               MOS(k,j)=MOS2(k,j)
            enddo
         enddo
      elseif (IWORK(2).ge.11) then  ! MOS1(JF1,JF1) --> MOS(JF1,NA): LMOs of cluster (JF1=JF)
         write(io,*) 'The MOs on AOs in extended subsystems are used'
         JF= JF1                 ! Replace JF with that in extend subsystem
         J0= J01                 ! Replace J0 with that in extend subsystem
         allocate(MOS(JF,NA))
         do j=1,NA
            do k=1,JF
               MOS(k,j)=MOS1(k,j)
            enddo
         enddo
      else
         write(io,*) 'ERROR: Only 1-10,11 for motyp are accepted'
      endif
      deallocate(MOS2,MOS1)
C --------------------------------------------------------------
C
C --- Print informations of this cluster ---
C     write(io,'(1x,58(''-''))')
C     write(io,*) '  Subsys  Occclu  Occ-MO  Vir-MO  Tot-MO'
C    &          //'    Atom   Basis'
C     write(io,'(7i8)') I,KU,KB,NA-KB,NA,J0_sub,JF_sub
C     write(io,'(7i8)') I,KU,KB,NA-KBB,NA,J0_sub,JF_sub
C     write(io,*) '  ADDED     Occ-MO  Atom   Basis'
C     write(io,'(d8.2,3i8)') RWORK(5),KB1,J01,JF1
C     write(io,'(1x,58(''-''))')
C
C     ISUB5(I)=NA-KB
      ISUB5(I)=NA-KBB  !-WL,PP- 14 AUG 2010
      call flshbf(io) 
C
C---------------------------------------------------------------------
C     Construct molecular Fock matrix of cluster
C---------------------------------------------------------------------
      allocate(FH(NA,NA),F2(JF,JF),F2B(JF,JF),FHH(JF))
      do j=1,JF;do k=1,JF
         F2(j,k)=FK(ZA(j),ZA(k))
         F2B(j,k)=FKB(ZA(j),ZA(k))
      enddo;enddo
      FHH=0d0
C
C-WL- 2007.10.15 Add for CIM- int-tran and cc
C
      allocate(AVECT(KB,KB),AVECTB(KBB,KBB))
      AVECT=0d0
      do j=1,KB
         AVECT(j,j)=1.0d0
      enddo
      AVECTB=0d0
      do j=1,KBB
         AVECTB(j,j)=1.0d0
      enddo
C
C-WL- 2007.11.20 ADD FOR FOCK MATRIX DIAGONALIZATION --- liwei -----
      write(io,*)
      if (IWORK(8).eq.0) then
         write(io,'(1x,"Diagonalization of Fock matrix of the ",
     *   "subsystem to generate quasi-canonical MOs.")')
         allocate(MOS2(JF,NA))
C        write(io,*) '+++ The initial alpha MO F(i,i) of subsystem +++'
         call NJ_tfock(0,JF,NA,F2,MOS,FH)  !-WL- 2007.10.23
C        write(io,'(5d14.6)') (FH(j,j),j=1,KB)
C
C------------------
         MOS2=MOS
C --- 1. OCC MOs
         KCC=0
C
         DO j=1,KCC
            do k=1,JF
               MOS2(k,j)=MOS(k,j)
            end do
         enddo
C
C-WL- 2009.04.15 KB --> KBB for diag double occupied MOs first
         KV=KBB-KCC
         allocate(MAT(KV,KV),VECT(KV,KV),VALU(KV),VC(KV))
         do j=1,KV
            do k=1,KV
               MAT(j,k)=FH(j+KCC,k+KCC)
            enddo
         enddo
         write(io,*) '+++ Diagonalized Occupied Fock Matrix +++'
         call NJ_qr(io,MAT,KV,VECT,VALU,VC,k,1)
         do j=1,KV
            FHH(KCC+j)=VALU(j)
         enddo
C
         do j=1,KV
         do k=1,JF
            MOS2(k,j+KCC)=0d0
            do L=1,KV
               MOS2(k,j+KCC)=MOS2(k,j+KCC)+MOS(k,L+KCC)*VECT(L,j)   !-WL- Remove for transforming VMO only
            enddo
C           MOS2(k,j)=MOS(k,j)
         enddo
         enddo
C
C        write(io,*) '+++ The Occ LMOs of subsystem +++'
C        call NJ_prtcol2(io,JF,NA,MOS,1,KB,'f11.6')
C
C        write(io,*) '+++ The Occ QCMOs of subsystem +++'
C        call NJ_prtcol2(io,JF,NA,MOS2,1,KB,'f11.6')
C
C        write(io,*) '+++ The transform matrix +++'
C        call NJ_prtcol2(io,KV,KV,VECT,1,KV,'f11.6')
C
         do j=1,KV
            do k=1,KV
               AVECT(k,j)=VECT(j,k)
            enddo
         enddo
C        write(io,*) '+++ The inverse of transform matrix +++'
C        call NJ_prtcol2(io,KV,KV,AVECT,1,KV,'f11.6')
C
!        call NJ_matpro(io,JF,KB,KB,MOS2,AVECT,MOS)
!        write(io,*) '+++ Product of matrices +++'
!        call NJ_prtcol2(io,JF,NA,MOS,1,KB,'f11.6')
C
C        write(190) KV
C        write(190) ((VECT(k,j),k=1,KV),j=1,KV)
         deallocate(MAT,VECT,VALU,VC)
C
C --- 2. UNOCC MOs
         KV=NA-KB
         allocate(MAT(KV,KV),VECT(KV,KV),VALU(KV),VC(KV))
         do j=1,KV
            do k=1,KV
               MAT(j,k)=FH(j+KB,k+KB)
            enddo
         enddo
         write(io,*) '+++ Diagonalized Virtual Fock Matrix +++'
         call NJ_qr(io,MAT,KV,VECT,VALU,VC,k,1)
         do j=1,KV
            FHH(KB+j)=VALU(j)
         enddo
C
         do j=1,KV
         do k=1,JF
            MOS2(k,j+KB)=0d0
            do L=1,KV
               MOS2(k,j+KB)=MOS2(k,j+KB)+MOS(k,L+kB)*VECT(L,j)
            enddo
         enddo
         enddo
         deallocate(MAT,VECT,VALU,VC)
C
         MOS=MOS2
C        write(io,*) '+++ The SEMI-CMOs of subsystem +++'
C        call NJ_prtcol2(io,JF,NA,MOS,1,NA,'f11.6')
C
C        write(io,*) 'Trace(Fock LMO)=',dtrace2(NA,FH)
         write(io,"(1x,'Trace(Fock LMO)=',f30.16)") dtrace2(NA,FH)
C        write(io,*) '+++ The transformed MO Fock Matrix of subsys +++'
C        call NJ_tfock(io,JF,NA,F2,MOS,FH)  !-WL- 2007.10.23
C        write(io,*) 'Trace(Fock CMO)=',dtrace2(NA,FH)
C
         deallocate(MOS2)
       endif
C
C
C-WL- 10 FEB 2010 MOVE THE BLOCK FROM THE PLACE ABOVE SUBINP
C-WL- 27 AUG 2009 ADD DENSITY MATRIX AND PPS
      allocate(DM(JF,JF),PPS(JF,JF))
      call NJ_denmat(0,JF,NA,KB,MOS,DM)
      call NJ_matpro(0,JF,JF,JF,DM,OVS3,PPS)
      trace=dtrace2(JF,PPS)
      deallocate(DM,PPS)
      nelec=nint(trace)
C-WL- 10 FEB 2010 ADD FOR OPEN SHELL
      nelec=nelec-mult+1
      write(io,'('' Number of electrons in the subsystem ='',i8)') nelec

      nucl=0
      do k=1,J0
         j=BA(k)
         nucl=nucl+nint(nuchar(j))
      enddo
      write(io,'('' Number of nuclear charges = '',i5)') nucl
C
      icharg=nucl-nelec
      icharg=mod(icharg,2)  !-WL- 27 Aug 2009 4:03PM
      write(io,'('' Number of effective net charges = '',i5)') icharg
C
C---------------------------------------------------------------------
C     Creat GAMESS input file of subsystems
C--------------------------------------------------------------------- 
      call NJ_trim(inpname,k1,k2)
      open(inp,file=inpname)
      nwords = memgms(scftyp,mplevl,cctyp,JF_sub,KB,NA-KBB,KU)
      if (cctyp.eq.'CCSD(T) '.or.cctyp.eq.'CR-CCL  ') then
         k = memgms(scftyp,mplevl,'CCSD    ',JF_sub,KB,NA-KBB,KU)
         nwords = max(nwords,k)
      endif
      mwords = int(nwords/1000d0/1000d0) + 1
      mbytes = int(nwords/125.d0/1000d0) + 1
C     write(io,190)scftyp,mplevl,cctyp,JF_sub,KB,NA-KBB,KU,nwords,mwords
C190  format(1x,a8,i4,2x,a8,4i6,i12,' words',i6,' mwords')
      thissystem=I
      call SUBINP(io,inp,NATOM,nuchar,coor,J0,BA,
     &     scftyp,mplevl,cctyp,IWORK,mwords,icharg,mult,NCBS,CBAS,
     &     thissystem)  
      call flshbf(io)
C
C---------------------------------------------------------------------
C-WL- 2009.05.05 .cim unformatted --> formatted
         LF2=JF*(JF+1)/2
         allocate(RCent(KB),dtmp(LF2))
         do k=1,KB
            RCent(k)=dble(CenMO(k,I))
         enddo
C
C        open(icim,file=cimname,form='formatted')
C        write(io,'(7i8)') J0,JF,NA,KB,KU,KBB,KUB   !-WL- Add KB-1, KU-1 temporarily for testing whole systems
C
         write(inp,*) '$INFO'
         write(inp,'(a8,a,i8)') 'NSYS    ', '=', KGG
         write(inp,'(a8,a,a8)') 'SCFTYP  ', '=', scftyp
         write(inp,'(a8,a,i8)') 'MPLEVL  ', '=', mplevl
         write(inp,'(a8,a,a8)') 'CCTYP   ', '=', cctyp
         write(inp,'(a8,a,i8)') 'ICONV   ', '=', IWORK(1)
         if (IWORK(8).eq.0) then
            write(inp,'(a8,a,a8)') 'MOTYP   ', '=', 'QCMO    ' 
         else
            write(inp,'(a8,a,a8)') 'MOTYP   ', '=', 'LMO     ' 
         endif
         write(inp,'(a8,a,i8)') 'SYS     ', '=', I
         write(inp,'(a8,a,i8)') 'NAT     ', '=', J0
         write(inp,'(a8,a,i8)') 'ICH     ', '=', icharg
         write(inp,'(a8,a,i8)') 'MUL     ', '=', mult
         write(inp,'(a8,a,i8)') 'NE      ', '=', KB+KBB
         write(inp,'(a8,a,i8)') 'NA      ', '=', KB
         write(inp,'(a8,a,i8)') 'NB      ', '=', KBB
         write(inp,'(a8,a,i8)') 'NUM     ', '=', JF
         write(inp,'(a8,a,i8)') 'NMO     ', '=', NA
         write(inp,'(a8,a,i8)') 'NCA     ', '=', KU
         write(inp,'(a8,a,i8)') 'NCB     ', '=', KUB
         write(inp,*) '$END' 
C
C        call iwrit8(inp,'$ATOMS',      J0, BA(1))
C        call iwrit8(inp,'$BASIS',      JF, ZA(1))
         call iwrit8(inp,'$MO-OCC',     KB, ML(1))
         call iwrit8(inp,'$MO-CEN',     KB, CenMO(1,I))   ! (CenMO(k,I)),k=1,KB)
         call rwrit8(inp,'$EIGVAL',     JF, FHH(1))       ! (FHH(j),j=1,JF) USEFUL IN RHF-CRCCL
         call rwrit8(inp,'$VEC',     JF*NA, MOS(1,1))     ! ((MOS(k,j),k=1,JF),j=1,NA)
C
         L=0
         do j=1,JF
            do k=1,j
               L=L+1
               dtmp(L)=F2(k,j)
            enddo
         enddo
         call rwrit8(inp,'$AO-FOCK-A', LF2, dtmp(1))      ! ((F2(k,j),k=1,j),j=1,JF)
         call rwrit8(inp,'$TRMX-A',  KB*KB, AVECT(1,1))   ! ((AVECT(k,j),k=1,KB),j=1,KB)
C
         if (scftyp.eq.'ROHF    '.or.scftyp.eq.'UHF     ') then
            L=0
            do j=1,JF
               do k=1,j
                  L=L+1
                  dtmp(L)=F2b(k,j)
               enddo
            enddo
            call rwrit8(inp,'$AO-FOCK-B', LF2, dtmp(1))     ! ((F2b(k,j),k=1,j),j=1,JF)

            do j=1,KBB
               do k=1,KBB
                  AVECTB(k,j)=AVECT(k,j)
               enddo
            enddo
            call rwrit8(inp,'$TRMX-B',KBB*KBB, AVECTB(1,1))   ! ((AVECT(k,j),k=1,KBB),j=1,KBB)
         endif
         deallocate(RCent,dtmp)
C
         deallocate(AVECT,AVECTB)
C     endif
      close(inp)
C

      deallocate (F2,F2B,OVS3)
C
C
C---------------------------------------------------------------------
C     Run GAMESS program and transform AO integrals to MO integrals
C---------------------------------------------------------------------
C     if (mplevl.ne.0.or.cctyp.ne.'NONE    ') then
C        write(job,*) trim(inpname)
C        write(job,*) 'bash '//trim(shname)
C        write(job,*) trim(outname)
C        write(job,*)
C     endif
C
      call flshbf(io)
C
C---------------------------------------------------------------------
C        20.9 SOLVE THE CCD EQUATIONS FOR RETAINED SUBSYSTEMS.  2001.4.2
C---------------------------------------------------------------------
1000  NV=NA-KB
C
C     write(io,'(1x,58(''-''))')
C
      deallocate(MOS,FH,FHH)
C
C-WL- Read Energy of orbitals from file
 990  continue 

      deallocate(ML,BA,ZA)
C --------------------------------------------------
C     call NJ_date(io,'Iterative Calculation of cluster over on:')
C     call NJ_cputim(io,Tim0)
C     call NJ_walltim(io,Wall0)
C     write(io,*) 'Iterative Calculation of cluster over'
      write(io,'(1x,".... END OF SUBSYSTEM ",I4,
     *   " INPUT GENERATION ....")') i
      call timit(1)
      write(io,*)
      call flshbf(io)
C
705   format(' Number of virtual orbitals in the subsys   =',i5)
706   format(' Total number of orbitals in the subsys (NA)=',i5)
C
      end
C
C
C --- Enlarge domain with non-hydrogen atoms within 4A 
C --- then add hydrogen atoms
C --- 2006.05.30 --- sj lw
C   io: output file; 
C   NATOM, NW: the number of all atoms and basis functions
C   Nmo, NUW: the number of all MOs and OCC MOs
C   numc, numh: the number of all non-hydrogen atoms and hydrogen atoms
C   J0, JF: the number of atoms and basis functions within the subsystem
C   NA: the number of MOs within the subsystem
      subroutine AddAtom(NATOM,NW,Nmo,NUW,nb,numc,numh,natc,nath,
     &   J0,JF,J01,JF1,ML,BA,ZA,link,dis,RWORK)
      integer NATOM,NW,Nmo,NUW,numc,numh,J0,JF,KB
      integer ML(NUW),BA(NATOM),ZA(NW),link(NATOM,NATOM)
      integer natc(NATOM),nath(NATOM),nb(NATOM)
      double precision dis(NATOM,NATOM),RWORK(100)
C
      if (dabs(RWORK(5)).lt.1d-5) then
         J01=J0
         goto 230
      endif
      write(6,'(1x,"Adding buffer atoms within",
     * " BUFFDST=",f6.2," angstroms.")') rwork(5)
C
      J0C=J0
C
C --- Add non-hydrogen atoms  Dis<RWORK(5) -- BA(J0+1:J0C)
        do j=1,numc
         jj=natc(j)
         do k=1,J0
          if(jj.eq.BA(k))goto 110
         enddo
         do k=1,J0
          kk=BA(k)
          L=link(jj,kk)
C     Default: RWORK(5)=4.0 a.u.
          if(dis(jj,kk).le.RWORK(5))then 
           J0C=J0C+1;BA(J0C)=jj
           exit
          endif
         enddo
110     enddo

C ---   Add Hydrogen Atoms-- BA(J0+1:J01)
        J01=J0C
        do j=1,numh
           jj=nath(j)
           do k=1,J0
              if (jj==BA(k)) goto 217
           enddo
           do k=1,J0C
              kk=BA(k)
              if (link(jj,kk)==1) then
                 J01=J01+1
                 BA(J01)=jj
              endif
           enddo
 217    enddo
C
 230    continue
C --- Re-order atoms
        J02=J01
        do j=1,NATOM
         do k=1,J01
          if(j.eq.BA(k))goto 120
         enddo
         J02=J02+1;BA(J02)=j
120     enddo
C
C --- Re-order basis-- ZA(1:JF:JF1:JF2)
         JF2=JF;JF1=JF
         do j=J0+1,NATOM
          if(BA(j).ne.NATOM)then
           nl=nb(BA(j)+1)-1
          else
           nl=NW
          endif
          do l=nb(BA(j)),nl
           JF2=JF2+1;ZA(JF2)=l
          enddo
          if(j.eq.J01)JF1=JF2
         enddo
        return
        end
C

C     input informations:
C     io: index of output file
C     NATOM,NW: numbers of atoms and basis functions in the whole system 
C     J0,JF: numbers of atoms and basis functions in the unexpanded domain
C     J01,JF1: numbers of atoms and basis functions in the expanded domain
C     KB: number of occupied LMOs in the unexpanded domain
C     KB1: number of occupied LMOs in the expanded domain
C
C     S: Overlap of total system
C
      subroutine COV(io,isys,NATOM,NW,Nmo,NUW,nb,
     &   J0,JF,J01,JF1,NA,KB,KB1,ML,BA,ZA,SR1,admx,admy,admz,
     &   S,SMO,MOS1,MOS2,local,S3,IWORK,RWORK)
      integer io,NATOM,NW,Nmo,NUW,J0,JF,NA,KB,J01,JF1,nvext,NAext
      integer ML(NUW),BA(NATOM),ZA(NW),nb(NATOM),local,nv_cim06
      integer nv_cim06_rd
      integer nv_max,isys,IWORK(100)
      double precision SR1(NATOM,NMO),RWORK(100)
      double precision admx(NW,NW),admy(NW,NW),admz(NW,NW)
      double precision S(NW,NW),S3(JF,JF),SMO(NW,Nmo)
      double precision ps,P1
      double precision MOS1(JF1,JF1),MOS2(JF,JF)
C
      double precision,dimension(:,:),allocatable::co,co1,oco,MOS3
      double precision,dimension(:),allocatable::AC1
C
      double precision zeps,smin,smax,epsa,epst
      double precision,dimension(:),allocatable::ovlp,e,d
      double precision,dimension(:,:),allocatable::mdmx,mdmy,mdmz
      double precision,dimension(:,:),allocatable::tr,cvs,cvs2,SS,Q,c
C
      integer,dimension(:),allocatable::nb1
      double precision,dimension(:,:),allocatable::S1,S2,admx2,admy2
      double precision,dimension(:,:),allocatable::admz2

      allocate(nb1(J01),S1(NW,NW),S2(JF1,JF1))
      allocate(admx2(JF1,JF1),admy2(JF1,JF1),admz2(JF1,JF1))

C Threshold of zero-eigenvalue
      zeps = 1.0d-5

      write(io,*)
C     write(io,*) '--- CONSTRUCTING EXTENDED ',
C    *   'SUBSYSTEM ORBITALS ---'
C
C --- Obtain overlap integrals, Occ. LMOs and AO dipole integrals in the expanded domain
C     S1: over-lap matrix of the whole system (after sorting)
C     S2: over-lap matrix of the expanded domain
C     S3: over-lap matrix of the domain
C     co1: OCC MOs of the expanded domain
C     nb1: the first basis of each atom
340   allocate(co1(NW,KB1))
      do j=1,NW
         do k=1,NW
            S1(j,k)=S(ZA(j),ZA(k))  
         enddo
      enddo
C
      do j=1,JF1
         do k=1,JF1
            S2(j,k)=S1(j,k)   
            admx2(j,k)=admx(ZA(j),ZA(k)) 
            admy2(j,k)=admy(ZA(j),ZA(k))
            admz2(j,k)=admz(ZA(j),ZA(k))
         enddo
      enddo
C
      do j=1,JF
         do k=1,JF
            S3(j,k)=S1(j,k)   
         enddo
      enddo
C
      co1=0.0d0
      do k=1,KB1
         do j=1,NW
           co1(j,k)=SMO(ZA(j),ML(k))   
        enddo
      enddo
C
      do k=1,J01
         do j=1,NW
            if(ZA(j).eq.nb(BA(k)))nb1(k)=j 
         enddo
      enddo
C
* =========================================================================================
*     Get the orthonormal occ. LMOs in extended subsystems from occ. LMOs of total systems
* -----------------------------------------------------------------------------------------
      allocate(co(JF1,KB1),oco(JF1,KB1))        ! oco is only used for store old co for comparison
      write(io,*) 'Project occ. LMOs from total system ',
     *   'onto extended subsystem and normalize'
      call projorb(io,NW,JF1,KB1,KB1,co1,co,S1) ! Project occ. LMOs from total system onto extended subsystems
      call normorb2(io,JF1,KB1,co,S2)            ! Normalize occ. LMOs of extended subsystems
      oco=co
      if (IWORK(2).ne.1) then    ! IWORK(2)=1,12 do not orthogonalize occ MOs in extended subsystems.
         call orthorb(io,JF1,KB1,co,S2,1)       ! Orthogonalize occ. LMOs of extended subsystems (1 means symmetric orth.)
         call normorb2(io,JF1,KB1,co,S2)         ! Normalize occ. LMOs of extended subsystems
      endif
C     call ovlporb2(io,JF1,KB1,oco,KB1,co,S2)   ! [Optional] Check the overlap between non-orth & orth occ. LMOs of extended subsystems
C     call ovlporb(io,JF1,KB1,co,S2)            ! [Optional] Check the overlap for occ. LMOs of extended subsystems
      deallocate(oco)
* =========================================================================================
* (a) co(JF1,KB1) is the orthonormal occ. LMOs in extended subsystems if IWORK(2).ne.1
C
C
* ===========================================================================
*     Create the orthonormal vir. LMOs in extended subsystems from occ. parts
* ---------------------------------------------------------------------------
      allocate(SS(JF1,JF1),c(JF1,JF1),Q(JF1,JF1),e(JF1),d(JF1))
C
C Set c(JF1,JF1) as an unitary matrix for construct virtual MOs
      call dunit(JF1,c)
C Project out the occ. part of vir. MOs in extended subsystems
      write(io,*) 'Project occ. part of virtual MOs'
      call pjotorb(io,JF1,KB1,JF1,co,c,S2)
C     write(io,*) 'There should now be no overlap between occ. LMOs'
C     write(io,*) 'and between the occ. LMOs and virtual MOs of',
C    * ' the extended subsystem.'

C Overlap on MOs: SS=C^T*S*C
C QR diag. of SS, increase the eigenvalues e and exchange corresponding eigenvectors Q.
      call NJ_tfock(0,JF1,JF1,S2,c,SS)
      call NJ_qr(0,SS,JF1,Q,e,d,L,1)
C Count the number of values \in [-zeps,zeps] ("zero" eigenvalues)
C nzero: zero eigenvalues;  nonzero: non-zero eigenvalues
C KB1: the num of occ. MOs in extended subsys. So nvexpct is expected num of vir. ones
C nvext: selected number of vir. MOs in subsystems
C ncut: =JF1-nvext is the number of eigenvectors needed to be cut 
      call numpoint(JF1,e,-zeps,zeps,nzero)
      nonzero = JF1 - nzero
      nvexpct = JF1 - KB1
      nvext   = min(nonzero,nvexpct)
      ncut    = max(nzero,KB1)
      write(io,'(1x,"Diagonalization of the extended subsystem ",
     *  "overlap leads to:")')
      write(io,'(3x,i5," zero     and ",i5," non-zero eigenvalues",
     *  2x,"(threshold:",1p,d8.2,0p,")")')
     *  nzero,nonzero,zeps
      write(io,'(3x,i5," occupied and ",i5," virtual orbitals",
     *  " were expected")') kb1,nvexpct

C     write(io,*) '-- Diagonalize overlap in extended subsystem --'
C     write(io,110) nzero,nonzero
C     write(io,120) KB1,nvexpct
      write(io,130) ncut-KB1,nvext

C Set MOS1(JF1,JF1) as a zero matrix
      call dzero(JF1*JF1,MOS1)
C Transform matrix for generating orthogonal vir. MOs
C Get canonical transform matrix tr(JF1,nvext)
C MOS1(JF1,nvext)=c(JF1,JF1)*tr(JF1,nvext)
      write(io,"(1x,'Canonical orthogonalization and localization of ',
     *   i4,' virtual orbitals')") nvext
      allocate(tr(JF1,nvext))
      call NJ_canorth(0,JF1,nvext,e(ncut+1),q(1,ncut+1),tr)
      call NJ_matpro(io,JF1,JF1,nvext,c,tr,MOS1(1,1))
      deallocate(tr)
      deallocate(SS,c,Q,e,d)
* ===========================================================================
* (a) MOS1(JF1,nvext) within MOS1(JF1,JF1) are the orthonormal vir. MOs in extended subsystems
C
C if subsystem and extended subsystem basis set is the same, do no localize
      if (JF1.eq.JF) goto 360  ! 2008.05.12 Add
C
* ==========================================================
*     Boys localization of vir. LMOs in extended subsystems
* ----------------------------------------------------------
! Thereshold of local index converg (default 1d-7 if set as zero)
      epsa   = 1d-7
! Thereshold of rotation of orbital (default 1d-13 if set as zero)
      epst   = 1d-13
! Maximum localization cycle (default 10000 if set as zero)
      maxcyc = 10000
! Print the localized MOs if nprint=1
      nprint = 0
! The number of parallel threads (currently useless, please set as 1)
      np     = 1
! Print the local results once every <nprtcyc> cycles (2008.02.10 ADD)
! Usually local=1 (Boys localization)
      nprtcyc= 100
      if (local.eq.1) then
         allocate(mdmx(nvext,nvext),mdmy(nvext,nvext),mdmz(nvext,nvext))
         call NJ_tfock(0,JF1,nvext,admx2,MOS1,mdmx)
         call NJ_tfock(0,JF1,nvext,admy2,MOS1,mdmy)
         call NJ_tfock(0,JF1,nvext,admz2,MOS1,mdmz)
         call NJ_boyloc(io,J01,JF1,nvext,1,nvext,MOS1,mdmx,mdmy,mdmz,
     &        epsa,epst,maxcyc,nprint,np,nprtcyc,ierr)
         deallocate(mdmx,mdmy,mdmz)
      elseif(local.eq.3) then
! Pipek-Mezey localization if local=3
         call Pop_sj(io,J01,JF1,nvext,1,nvext,MOS1,S2,nb1,maxcyc,epsa)
!!       call NJ_poploc(io,J01,JF1,nvext,1,nvext,MOS1,S2,tbs,
!!   &           eps,epst,maxcyc,nprint,np,ierr)
      endif
* ==========================================================
* (a) MOS1(JF1,nvext) within MOS1(JF1,JF1) are the orthonormal vir. LMOs in extended subsystems
C
 360  continue
C
* ========================================================================
*     Project orthogonal vir. LMOs from extended subsystems to subsystems
* ------------------------------------------------------------------------
! Threshold of self-overlap for selecting virtual LMOs (down bound)
      smin = 1.0d0-RWORK(4)
! Threshold of self-overlap for selecting virtual LMOs (up bound) (1.0 is ok)
      smax = 2.0d0
! ovlp: self-overlaps of cvs
      allocate(cvs(JF,nvext),ovlp(nvext))
! Project vir. LMOs from extended subsystem onto subsystems cvs(JF,nvext)
      write(io,*) '--- Project extended subsystem virtual orbitals ',
     * 'back on the the original subsystem ---'
      call projorb(io,JF1,JF,nvext,nvext,MOS1,cvs,S2)
! Calc & sort (decrease) the self-overlap of cvs before orthonormalization
C     call ovlpslf(io,JF,nvext,cvs,S3,ovlp,-1)
! Calc & sort (decrease) the self-overlap of cvs before orthonormalization
      call ovlpslf2(0,JF,nvext,cvs,JF1,MOS1,S3,ovlp,-1)
! nv_cim06: the num of values of ovlp in [smin,smax] (used in CIM JCP2006)
      call numpoint(nvext,ovlp,smin,smax,nv_cim06)
      write(io,90)  rwork(4)
! nv_cim06: the num of vir. MOs of subsystems defined in CIM paper JCP2006
      write(io,100) nv_cim06
      if (IWORK(7).eq.0) then
         write(isys,'(i5)') nv_cim06
      else
         read(isys,*) nv_cim06
         write(io,201) nv_cim06
      endif
      nv_max=JF-KB
      if (nv_cim06.gt.nv_max) then
         write(io,105) nv_max
         write(io,106) nv_max
         nv_cim06=nv_max
      endif
  90  format(1x,'By selecting orbitals with self-overlap',
     *  ' ETA<=',f7.3,',')
 100  format(1x,'The numbers of chosen vir. LMOs in the subsystem are:'
     *  ,i4)
 105  format(1x,'Number of vir MOs is larger than possible number:',i4)
 106  format(1x,'Re-define the number of vir MOs as the new value:',i4)
 201  format(1x,'Read the number of virtual MOs as the new value: ',i4)
C201  format(1x,'DO NOT read the number of virtual MOs as follow: ',i4)
      deallocate(ovlp)
! Now cvs is virtual LMOs in extended subsystem but projected to AO domains
      call normorb2(io,JF,nvext,cvs,S3)
C
      write(io,150)
* ========================================================================
* (a) cvs(JF,nvext) are the normalized vir. LMOs in extended subsystems but projected onto AO domains
* (b) nv_cim06 is the num of vir. MOs in subsystems defined by CIM paper "JCP 125, 074109 (2006)"
C
C
* =============================================================================
*     Get the MOs projected on extended subsystems MOS1 and on subsystems MOS2
* -----------------------------------------------------------------------------
      if (IWORK(2).ge.11 .or. IWORK(2).eq.1 .or. IWORK(2).eq.2) then
         nv=nv_cim06
         NA=KB+nv
         do i=NA,KB+1,-1
            do j=1,JF1
               MOS1(j,i)=MOS1(j,i-KB)
            enddo
         enddo
         do i=1,KB
            do j=1,JF1
               MOS1(j,i)=co(j,i)
            enddo
         enddo
C
      write(io,*) '--- Project extended subsystem occupied orbitals ',
     * 'back on the the original subsystem ---'
C        call NJ_prtcol2(io,JF1,NA,MOS1,1,JF1,'f14.6')
C        call ovlporb(io,JF1,NA,MOS1(1,1),S2)            ! [Optional] Check the overlap for occ LMOs of subsystems
C
C ---    Continue to get the LMOs in subsystems and projected on subsystems AOs
         call projorb(io,JF1,JF,KB1,KB,co,MOS2(1,1),S2)  ! Project occ. LMOs from extended subsystems onto subsystems (KB of KB1)
         call normorb2(io,JF,KB,MOS2(1,1),S3)             ! Normalize occ. LMOs of subsystems
         do i=KB+1,NA
            do j=1,JF
               MOS2(j,i)=cvs(j,i-KB)
            enddo
         enddo
         deallocate(co,cvs)
         return       ! Back to the parent program only with the MOS1 ands MOS2
      endif
* =============================================================================
C
C
C ======================================================================================
C     Get the orthonormal occ. LMOs in subsystems from occ. LMOs in extended subsystems
C --------------------------------------------------------------------------------------
      call projorb(io,JF1,JF,KB1,KB,co,MOS2(1,1),S2)   ! Project occ. LMOs from extended subsystems onto subsystems (KB of KB1)
      deallocate(co)
      call normorb2(io,JF,KB,MOS2(1,1),S3)              ! Normalize occ. LMOs of subsystems
      call orthorb(io,JF,KB,MOS2(1,1),S3,1)            ! Orthogonalize occ. LMOs of subsystems
      call normorb2(io,JF,KB,MOS2(1,1),S3)              ! Normalize occ. LMOs of subsystems
*     call ovlporb(io,JF,KB,MOS2(1,1),S3)              ! [Optional] Check the overlap for occ LMOs of subsystems
C ======================================================================================
* (a) MOS2(JF,KB) within MOS2(JF,JF) are the orthonormal occ. LMOs in subsystems
C
C
C ===========================================================================================================
C     Orthonormalize vir. LMOs in subsystems from those in extended subsystems but projected onto subsystems
C -----------------------------------------------------------------------------------------------------------
      if (IWORK(2).eq.3) then
         iselct_A=  3
         iselct_B=  0
         iselct_C=  2
      elseif (IWORK(2).eq.4) then
         iselct_A=  3
         iselct_B=  2
         iselct_C=  2
      elseif (IWORK(2).eq.5) then
         iselct_A=  1
         iselct_B=  1
         iselct_C=  1
      elseif (IWORK(2).eq.6) then
         iselct_A=  1
         iselct_B=  1
         iselct_C=  2
      endif
      write(io,*)'-----------------------------------------------------'
      write(io,*)'Three steps for the orthonormal vir MOs in subsystems'
      write(io,*)'-----------------------------------------------------'
      write(io,*) 'Step A: Project out the occ. part from the vir. LMOs'
      write(io,*) '        Possible numbers of used vir. LMOs include:'
      write(io,5110) nvext
      write(io,5120) JF-KB
      write(io,5130) nv_cim06
      iselect=iselct_A
      write(io,5550) iselect
      if (iselect.eq.1) then
         nvpjot = nvext
      elseif (iselect.eq.2) then
         nvpjot = JF-KB
      elseif (iselect.eq.3) then
         nvpjot = nv_cim06
      elseif (iselect.eq.0) then
         nv_indep= nv_cim06
         goto 520
      else
         stop 'ERROR in step 1 of the orthonormalization of vir. MOs'
      endif
C
      call pjotorb(io,JF,KB,nvpjot,MOS2(1,1),cvs,S3)   ! Project out the occ. part of vir. LMOs cvs(JF,nvpjot)
      call normorb2(io,JF,nvpjot,cvs,S3)                ! Normalized cvs(JF,nvpjot)

      allocate(SS(nvpjot,nvpjot),Q(nvpjot,nvpjot),e(nvpjot),d(nvpjot))
      call NJ_tfock(0,JF,nvpjot,S3,cvs,SS)             ! Overlap on MOs: SS=C^T*S*C
      call NJ_qr(io,SS,nvpjot,Q,e,d,L,1)               ! QR diagonalization of SS
      write(io,*) 'Eigenvalues of C^+SC of extended vir MOs in subsys'
      write(io,'(5f14.6)') (e(i),i=1,nvpjot)
      call numpoint(nvpjot,e,-zeps,zeps,nzero)         ! Count the number of values \in [-zeps,zeps] ("zero" eigenvalues)
      nv_indep=nvpjot-nzero
C
C -----------------------------------------------------------------------------------------------------------
 520  write(io,*) 'Step B: Orthonormalize the vir. LMOs'
      write(io,*) '        Possible numbers of used vir. LMOs include:'
      write(io,5210) nv_indep
      write(io,5220) nv_cim06
      iselect=abs(iselct_B)
      jselect=iselct_B
      write(io,5550) iselect
      if (iselect.eq.1) then
         nvorth = nv_indep
      elseif (iselect.eq.2) then
         nvorth = nv_cim06
      elseif (iselect.eq.0) then
         nvorth = nv_indep
         goto 530
      else
         stop 'ERROR in step 2 of the orthonormalization of vir. MOs'
      endif
C
      if (jselect.gt.0) then
         call orthorb(io,JF,nvorth,cvs(1,1),S3,1)               ! Symmetry orthogonalize vir. LMOs of subsystems cvs(JF,nvorth)
      else
         write(io,*)'Canonical Orthogonalization for vir. MOs in subsys'
         allocate(tr(nvpjot,nvorth),cvs2(JF,nvorth))            ! Transform matrix for generating orthogonal vir. MOs
         nstt=nzero+1
         call NJ_canorth(0,nvpjot,nvorth,e(nstt),Q(1,nstt),tr)  ! Get canonical transform matrix tr(nvpjot,nvorth)
         call NJ_matpro(io,JF,nvpjot,nvorth,cvs,tr,cvs2)        ! cvs2(JF,nvorth)=cvs(JF,nvpjot)*tr(nvpjot,nvorth)
         do i=1,nvorth
            cvs(1:JF,i)=cvs2(1:JF,i)
         enddo
         deallocate(tr,cvs2)
      endif
      call normorb2(io,JF,nvorth,cvs(1,1),S3)                    ! Normalize vir. LMOs of subsystems cvs(JF,nvorth)
*     call ovlporb(io,JF,nvorth,cvs(1,1),S3)                    ! Check the overlap for "nv" vir LMOs of subsystems
      deallocate(SS,Q,e,d)
C
C -----------------------------------------------------------------------------------------------------------
 530  write(io,*) 'Step C: Pick up the needed LMOs in subsystems'
      write(io,*) '        Possible numbers of used vir. LMOs include:'
      write(io,5210) nv_indep
      write(io,5220) nv_cim06
      iselect=iselct_C
      write(io,5550) iselect
      if (iselect.eq.1) then
         nv = nv_indep
      elseif (iselect.eq.2) then
         nv = nv_cim06
      else
         stop 'ERROR in step 2 of the orthonormalization of vir. MOs'
      endif
      if (nv.gt.nvorth) then
         write(io,*)'nv in step 3 can not be larger than nvorth'
         STOP
      endif
C
C -----------------------------------------------------------------------------------------------------------
 5110 format(6x,'1. Tot number of vir. LMOs in extended subsystems:',i4)
 5120 format(6x,'2. Expected max number of vir. LMOs in subsystems:',i4)
 5130 format(6x,'3. Number of vir. LMOs in subsystems from JCP2006:',i4)
 5210 format(6x,'1. Number of independ. vir. LMOs after projection:',i4)
 5220 format(6x,'2. Number of vir. LMOs in subsystems from JCP2006:',i4)
 5550 format(3x,'Your choice is:',i4)
C ===========================================================================================================
* (a) cvs(JF,nvpjot) are the vir. LMOs orthogonal to occ. LMOs in subsystems
* (b) cvs(JF,nvorth) are the orthonormal vir. LMOs in subsystems
* (c) cvs(JF,nv) are the selected orthonormal vir. LMOs in subsystems
C
C
      NA=KB+nv
      do j=KB+1,NA
         do k=1,JF
            MOS2(k,j)=cvs(k,j-KB)
         enddo
      enddo
C     call ovlporb(io,JF,NA,MOS2,S3)              ! Check the overlap for all LMOs of subsystems
C
      deallocate(cvs)
      deallocate(nb1,S1,S2,admx2,admy2,admz2)
      return
C
 110  format(1x,'The numbers of zero and non-zero eigenvalues are:',2i4)
 120  format(1x,'The numbers of occ. and expected virtual MOs are:',2i4)
 130  format(1x,'The numbers of redundunt and chosen vir. MOs are:',2i4)
 140  format(1x,'The numbers of chosen vir. LMOs in subsystem are:',i4)
 150  format(1x,57('-'))
      end

****** 2004.12.21 trace for a matrix [real*8]******
      function dtrace2(n,mat)
      implicit none
      integer n,i
      real*8 mat(n,n),dtrace2
      dtrace2=0d0
      do i=1,n
         dtrace2=dtrace2+mat(i,i)
      enddo
      end
C
C-WL- 2009.09.22 updated by Wei Li for allocatable A
      SUBROUTINE MINA1(N,NVV,NW,NMO,SMO,SOVER,AC)
      double precision SMO(NW,NMO),SOVER(NW,NW),AC(N),P
      double precision,dimension(:,:),allocatable::A

      allocate(A(N,N+1))
      DO 100 IU=1,N
         DO 110 IV=1,N
            A(IU,IV)=SOVER(IU,IV)
110      CONTINUE
100   CONTINUE
C
      DO 120 I=1,N
         P=0.0d0
         DO 130 K=1,NW
            P=P+SMO(K,NVV)*SOVER(I,K)
130      CONTINUE
         A(I,N+1)=P
120   CONTINUE
C
      CALL GAUSS2(N,A)
C
      DO 150 I=1,N
         AC(I)=A(I,N+1)
150   CONTINUE
C
C      WRITE(*,*) 'N=',N
C      WRITE(*,20) (AC(I),I=1,N)
C20    FORMAT(1X,5F12.5)
C
      deallocate(A)
      RETURN
      END
C
      subroutine izero(n,a)
      integer a(n)
      do i=1,n
         a(i)=0
      enddo
      end

      subroutine dzero(n,a)
      double precision a(n)
      do i=1,n
         a(i)=0d0
      enddo
      end

      subroutine iunit(n,a)
      integer a(n,n)
      do i=1,n
         do j=1,n
            if (j.eq.i) then
               a(j,i)=1
            else
               a(j,i)=0
            endif
         enddo
      enddo
      end

      subroutine dunit(n,a)
      double precision a(n,n)
      do i=1,n
         do j=1,n
            if (j.eq.i) then
               a(j,i)=1d0
            else
               a(j,i)=0d0
            endif
         enddo
      enddo
      end
C
C --- Count the number of values \in [z1,z2] of A(n)
      subroutine numpoint(n,A,z1,z2,num)
      implicit none
      integer n,num,i,j
      double precision A(n),z1,z2,zzz
C
      num=0
      do i=1,n
         zzz=A(i)
         if (zzz.lt.z1) cycle
         if (zzz.gt.z2) cycle
         num=num+1
      end do
C
      end
C
C --------------------------------------------------------
C       CORRECT.
C       FOR DIAGONALIZATION. 2003.5.25.
        SUBROUTINE NJ_qr(io,A,N,Q,B,C,L,sort)
        implicit none
        INTEGER N,L,io,sort,i,j,k
        real*8 A(N,N),Q(N,N),B(N),C(N),valu,vect,eps
        eps=1d-16
        CALL CSTRQ(A,N,Q,B,C,eps)
        CALL CSSTQ(N,B,C,Q,L,eps)
        if (L.eq.0) then
           write(io,*) 'QR Diagonalization failure!'
           call abrt
        endif
C --- Sort for eigenvalues ---
        if (sort>0) then   ! order eigenvalues from small to large
           do i=1,N-1
              valu=B(i)
              do j=i+1,N
                 if (B(j).lt.valu) then
                    valu=B(j)
                    B(j)=B(i)
                    B(i)=valu
                    do k=1,N
                       vect=Q(k,i)
                       Q(k,i)=Q(k,j)
                       Q(k,j)=vect
                    enddo
                 endif
              enddo
           enddo
           if (io.gt.0) write(io,110) N
        elseif (sort<0) then
           do i=1,N-1
              valu=B(i)
              do j=i+1,N
                 if (B(j).gt.valu) then ! order eigenvalues from large to small
                    valu=B(j)
                    B(j)=B(i)
                    B(i)=valu
                    do k=1,N
                       vect=Q(k,i)
                       Q(k,i)=Q(k,j)
                       Q(k,j)=vect
                    enddo
                 endif
              enddo
           enddo
           if (io.gt.0) write(io,120) N
        else
           if (io.gt.0) write(io,130) N
        endif
        if (io.gt.0) write(io,140) (B(i),i=1,N)
 110  format(1x,'QR diagonalization with',i4,' ascending eigenvalues')
 120  format(1x,'QR diagonalization with',i4,' descending eigenvalues')
 130  format(1x,'QR diagonalization with',i4,' unsorted eigenvalues')
 140  format(5d14.6)
      END
C
        SUBROUTINE CSSTQ(N,B,C,Q,L,EPS)
        real*8 Q(N,N),B(N),C(N)
        real*8 EPS,D,H,P,R,F,E,S,G
        INTEGER L
        C(N)=0.0d0
        D=0.0d0
        F=0.0d0
        DO 50 J=1,N
          IT=0
          H=EPS*(DABS(B(J))+DABS(C(J)))
          IF (H.GT.D) THEN
           D=H
          END IF
          M=J-1
10        M=M+1
          IF (M.LE.N) THEN
            IF (DABS(C(M)).GT.D) GOTO 10
          END IF
          IF (M.NE.J) THEN
15          IF (IT.EQ.60) THEN
              L=0
              WRITE(*,18)
18            FORMAT(1X,'  FAIL')
                WRITE(11,*) 'FAIL IN QR'
              RETURN
            END IF
            IT=IT+1
            G=B(J)
            P=(B(J+1)-G)/(2.0d0*C(J))
            R=DSQRT(P*P+1.0d0)
            IF (P.GE.0.0d0) THEN
              B(J)=C(J)/(P+R)
            ELSE
              B(J)=C(J)/(P-R)
            END IF
            H=G-B(J)
            DO 20 I=J+1,N
20          B(I)=B(I)-H
            F=F+H
            P=B(M)
            E=1.0d0
            S=0.0d0
            DO 40 I=M-1,J,-1
              G=E*C(I)
              H=E*P
              IF (DABS(P).GE.DABS(C(I))) THEN
                E=C(I)/P
                R=DSQRT(E*E+1.0d0)
                C(I+1)=S*P*R
                S=E/R
                E=1.0d0/R
              ELSE
                E=P/C(I)
                R=DSQRT(E*E+1.0d0)
                C(I+1)=S*C(I)*R
                S=1.0d0/R
                E=E/R
              END IF
              P=E*B(I)-S*G
              B(I+1)=H+S*(E*G+S*B(I))
              DO 30 K=1,N
                H=Q(K,I+1)
                Q(K,I+1)=S*Q(K,I)+E*H
                Q(K,I)=E*Q(K,I)-S*H
30            CONTINUE
40          CONTINUE
            C(J)=S*P
            B(J)=E*P
            IF (DABS(C(J)).GT.D) GOTO 15
          END IF
          B(J)=B(J)+F
50      CONTINUE
        DO 80 I=1,N
          K=I
          P=B(I)
          IF (I+1.LE.N) THEN
            J=I
60          J=J+1
            IF (J.LE.N) THEN
              IF (B(J).LE.P) THEN
                K=J
                P=B(J)
                GOTO 60
              END IF
            END IF
          END IF
          IF (K.NE.I) THEN
            B(K)=B(I)
            B(I)=P
            DO 70 J=1,N
              P=Q(J,I)
              Q(J,I)=Q(J,K)
              Q(J,K)=P
70          CONTINUE
          END IF
80      CONTINUE
        L=1
        RETURN
        END

        SUBROUTINE CSTRQ(A,N,Q,B,C,eps)
        real*8 A(N,N),Q(N,N),B(N),C(N)
        real*8 F,H,G,H2,eps
        DO 10 I=1,N
        DO 10 J=1,N
10      Q(I,J)=A(I,J)
        DO 80 I=N,2,-1
          H=0.0d0
          IF (I.GT.2) THEN
            DO 20 K=1,I-1
20          H=H+Q(I,K)*Q(I,K)
          END IF
          IF (dabs(H).le.eps) THEN
            C(I)=0.0d0
            IF (I.EQ.2) C(I)=Q(I,I-1)
            B(I)=0.0d0
          ELSE
            C(I)=DSQRT(H)
            IF (Q(I,I-1).GT.0.0d0) C(I)=-C(I)
            H=H-Q(I,I-1)*C(I)
            Q(I,I-1)=Q(I,I-1)-C(I)
            F=0.0d0
            DO 50 J=1,I-1
              Q(J,I)=Q(I,J)/H
              G=0.0d0
              DO 30 K=1,J
30            G=G+Q(J,K)*Q(I,K)
              IF (J+1.LE.I-1) THEN
                DO 40 K=J+1,I-1
40              G=G+Q(K,J)*Q(I,K)
              END IF
              C(J)=G/H
              F=F+G*Q(J,I)
50          CONTINUE
            H2=F/(H+H)
            DO 70 J=1,I-1
              F=Q(I,J)
              G=C(J)-H2*F
              C(J)=G
              DO 60 K=1,J
60            Q(J,K)=Q(J,K)-F*C(K)-G*Q(I,K)
70          CONTINUE
            B(I)=H
          END IF
80      CONTINUE
        DO 85 I=1,N-1
85      C(I)=C(I+1)
        C(N)=0.0d0
        B(1)=0.0d0
        DO 130 I=1,N
          IF ((dabs(B(I)).gt.eps).AND.(I-1.GE.1)) THEN
            DO 110 J=1,I-1
              G=0.0d0
              DO 90 K=1,I-1
90            G=G+Q(I,K)*Q(K,J)
              DO 100 K=1,I-1
100           Q(K,J)=Q(K,J)-G*Q(K,I)
110         CONTINUE
          END IF
          B(I)=Q(I,I)
          Q(I,I)=1.0d0
          IF (I-1.GE.1) THEN
            DO 120 J=1,I-1
              Q(I,J)=0.0d0
              Q(J,I)=0.0d0
120         CONTINUE
          END IF
130     CONTINUE
        RETURN
        END


C********************************************************************
C CSSTQ method to diagonalize
C********************************************************************
        SUBROUTINE CSSTQ_0(N,B,C,Q,EPS,L)
        DIMENSION B(N),C(N),Q(N,N)
        DOUBLE PRECISION B,C,Q,D,H,P,R,F,E,S,G,eps
        C(N)=0.0d0
        D=0.0d0
        F=0.0d0
        EPS=0.0d0
        DO 50 J=1,N
          IT=0
          H=EPS*(ABS(B(J))+ABS(C(J)))
          IF (H.GT.D) D=H
          M=J-1
10        M=M+1
          IF (M.LE.N) THEN
            IF (ABS(C(M)).GT.D) GOTO 10
          END IF
          IF (M.NE.J) THEN
15          IF (IT.EQ.60) THEN
              L=0
              WRITE(*,18)
18            FORMAT(1X,'  FAIL')
              RETURN
            END IF
            IT=IT+1
            G=B(J)
            P=(B(J+1)-G)/(2.0*C(J))
            R=SQRT(P*P+1.0)
            IF (P.GE.0.0) THEN
              B(J)=C(J)/(P+R)
            ELSE
              B(J)=C(J)/(P-R)
            END IF
            H=G-B(J)
            DO 20 I=J+1,N
20          B(I)=B(I)-H
            F=F+H
            P=B(M)
            E=1.0
            S=0.0
            DO 40 I=M-1,J,-1
              G=E*C(I)
              H=E*P
              IF (ABS(P).GE.ABS(C(I))) THEN
                E=C(I)/P
                R=SQRT(E*E+1.0)
                C(I+1)=S*P*R
                S=E/R
                E=1.0/R
              ELSE
                E=P/C(I)
                R=SQRT(E*E+1.0)
                C(I+1)=S*C(I)*R
                S=1.0/R
                E=E/R
              END IF
              P=E*B(I)-S*G
              B(I+1)=H+S*(E*G+S*B(I))
              DO 30 K=1,N
                H=Q(K,I+1)
                Q(K,I+1)=S*Q(K,I)+E*H
                Q(K,I)=E*Q(K,I)-S*H
30            CONTINUE
40          CONTINUE
            C(J)=S*P
            B(J)=E*P
            IF (ABS(C(J)).GT.D) GOTO 15
          END IF
          B(J)=B(J)+F
50      CONTINUE
        DO 80 I=1,N
          K=I
          P=B(I)
          IF (I+1.LE.N) THEN
            J=I
60          J=J+1
            IF (J.LE.N) THEN
              IF (B(J).LE.P) THEN
                K=J
                P=B(J)
                GOTO 60
              END IF
            END IF
          END IF
          IF (K.NE.I) THEN
            B(K)=B(I)
            B(I)=P
            DO 70 J=1,N
              P=Q(J,I)
              Q(J,I)=Q(J,K)
              Q(J,K)=P
70          CONTINUE
          END IF
80      CONTINUE
        L=1
        RETURN
        END

        SUBROUTINE CSTRQ_0(A,N,Q,B,C)
        DIMENSION A(N,N),Q(N,N),B(N),C(N)
        DOUBLE PRECISION A,Q,B,C,F,H,G,H2
        DO 10 I=1,N
        DO 10 J=1,N
10      Q(I,J)=A(I,J)
        DO 80 I=N,2,-1
          H=0.0
          IF (I.GT.2) THEN
            DO 20 K=1,I-1
20          H=H+Q(I,K)*Q(I,K)
          END IF
          IF (H+1.0.EQ.1.0) THEN
            C(I)=0.0d0
            IF (I.EQ.2) C(I)=Q(I,I-1)
            B(I)=0.0d0
          ELSE
            C(I)=SQRT(H)
            IF (Q(I,I-1).GT.0.0d0) C(I)=-C(I)
            H=H-Q(I,I-1)*C(I)
            Q(I,I-1)=Q(I,I-1)-C(I)
            F=0.0d0
            DO 50 J=1,I-1
              Q(J,I)=Q(I,J)/H
              G=0.0d0
              DO 30 K=1,J
30            G=G+Q(J,K)*Q(I,K)
              IF (J+1.LE.I-1) THEN
                DO 40 K=J+1,I-1
40              G=G+Q(K,J)*Q(I,K)
              END IF
              C(J)=G/H
              F=F+G*Q(J,I)
50          CONTINUE
            H2=F/(H+H)
            DO 70 J=1,I-1
              F=Q(I,J)
              G=C(J)-H2*F
              C(J)=G
              DO 60 K=1,J
60            Q(J,K)=Q(J,K)-F*C(K)-G*Q(I,K)
70          CONTINUE
            B(I)=H
          END IF
80      CONTINUE
        DO 85 I=1,N-1
85      C(I)=C(I+1)
        C(N)=0.0d0
        B(1)=0.0d0
        DO 130 I=1,N
          IF ((B(I).NE.0.0).AND.(I-1.GE.1)) THEN
            DO 110 J=1,I-1
              G=0.0d0
              DO 90 K=1,I-1
90            G=G+Q(I,K)*Q(K,J)
              DO 100 K=1,I-1
100           Q(K,J)=Q(K,J)-G*Q(K,I)
110         CONTINUE
          END IF
          B(I)=Q(I,I)
          Q(I,I)=1.0d0
          IF (I-1.GE.1) THEN
            DO 120 J=1,I-1
              Q(I,J)=0.0d0
              Q(J,I)=0.0d0
120         CONTINUE
          END IF
130     CONTINUE
        RETURN
        END

C********************************************************************
C Sort   (nobody is using this routine)
C********************************************************************
c---    subroutine sort2(n,ra,rb)
c---    double precision ra(n),rra
c---    integer rb(n),rrb
c---    l=n/2+1;ir=n
c---    do
c---     if(l.gt.1)then
c---      l=l-1;rra=ra(l);rrb=rb(l)
c---     else
c---      rra=ra(ir);rrb=rb(ir);ra(ir)=ra(1);rb(ir)=rb(1);ir=ir-1
c---      if(ir.eq.1)then
c---       ra(1)=rra;rb(1)=rrb
c---       return
c---      endif
c---     endif
c---     i=l;j=l+l
c---     do while(j.le.ir)
c---      if(j.lt.ir)then
c---       if(ra(j).lt.ra(j+1))j=j+1
c---      endif
c---      if(rra.lt.ra(j))then
c---       ra(i)=ra(j);rb(i)=rb(j);i=j;j=j+j
c---      else
c---       j=ir+1
c---      endif
c---     enddo
c---     ra(i)=rra;rb(i)=rrb
c---    enddo
c---    return
c---    end
C
C
C     2001.4.22. correct.
C     Purpose: solve a system of linear equation by using the method of
C     Gaussian elimination with partial pivoting.
C
      SUBROUTINE GAUSS2(N,A)
C
      double precision A(N,N+1),AV,T
C
      DO 30 K=1,N-1
         AV=0.0d0
         DO 10 I=K,N
            IF (ABS(A(I,K)).LE.ABS(AV)) GOTO 10
            AV=A(I,K)
            L=I
10       CONTINUE
         IF (ABS(AV).LT.1.0E-8) THEN
             WRITE(99,*) 'SINGULAR COEFFICIENT MATRIX'
             STOP
         ENDIF
         IF (L.NE.K) THEN
            DO 15 J=K,N+1
               T=A(K,J)
               A(K,J)=A(L,J)
               A(L,J)=T
15          CONTINUE
         ENDIF
         AV=1.0d0/AV
         DO 25 J=K+1,N+1
            A(K,J)=A(K,J)*AV
            DO 20 I=K+1,N
               A(I,J)=A(I,J)-A(I,K)*A(K,J)
20          CONTINUE
25       CONTINUE
C
30    CONTINUE
      A(N,N+1)=A(N,N+1)/A(N,N)
      DO 40 K=1,N-1
         I=N-K
         AV=0.0d0
         DO 35 J=I+1,N
            AV=AV+A(I,J)*A(J,N+1)
35       CONTINUE
         A(I,N+1)=A(I,N+1)-AV
40    CONTINUE
      RETURN
      END
C
        subroutine Pop_sj(io,natom,nbasis,nv,n1,n2,cv,s,nb,maxcyc,tol)
        double precision s(nbasis,nbasis),cv(nbasis,nv),p(natom,nv,nv)
        double precision a(nv,nv),b(nv,nv),delta(nv,nv),su(nv,nv),pi,tol
        double precision f0,p1,p2,pp,alfa,a0,b0,delta0,sum0,ca,cb,cosa
        double precision sina
        integer nb(natom)
        pi=atan(1.0d0)*4.0d0
        if(maxcyc.le.0)maxcyc=1000000
        if(tol.lt.1.0d-16)tol=1.0d-7
C
        do 1000 iter=1,maxcyc
         ni=iter
C
         if(iter.eq.1)then
          call inte(natom,nbasis,nv,nb,cv,s,p)
          f0=0.0d0
          do i=1,natom
           do j=n1,n2
            f0=f0+p(i,j,j)*p(i,j,j)
           enddo
          enddo
         else
          do i=n1,n2
           if(i.ne.i0.and.i.ne.j0)then
            do k=1,natom
             imin=min(i,i0);imax=max(i,i0)
             jmin=min(i,j0);jmax=max(i,j0)
             p1=cosa*p(k,imin,imax)+sina*p(k,jmin,jmax)
             p(k,jmin,jmax)=-sina*p(k,imin,imax)+cosa*p(k,jmin,jmax)
             p(k,imin,imax)=p1
            enddo
           endif
          enddo
          do k=1,natom
            p1=cosa*cosa*p(k,i0,i0)+sina*sina*p(k,j0,j0)+
     +2*cosa*sina*p(k,i0,j0)
            p2=sina*sina*p(k,i0,i0)+cosa*cosa*p(k,j0,j0)-
     +2*cosa*sina*p(k,i0,j0)
            p(k,i0,j0)=cosa*sina*(-p(k,i0,i0)+p(k,j0,j0))+
     +(cosa*cosa-sina*sina)*p(k,i0,j0)
            p(k,i0,i0)=p1;p(k,j0,j0)=p2
          enddo
         endif
C
         do i=n1,n2-1;do j=i+1,n2
           if(iter.eq.1.or.i.eq.i0.or.i.eq.j0.or.j.eq.i0
     +.or.j.eq.j0)then
            a(i,j)=0.0d0;b(i,j)=0.0d0
            do k=1,natom
             pp=p(k,i,i)-p(k,j,j)
             a(i,j)=a(i,j)+p(k,i,j)*p(k,i,j)-pp*pp/4.0d0
             b(i,j)=b(i,j)+p(k,i,j)*pp
            enddo
            su(i,j)=sqrt(a(i,j)*a(i,j)+b(i,j)*b(i,j))
            delta(i,j)=a(i,j)+su(i,j)
           endif
           if(j.eq.n1+1.or.delta0.lt.delta(i,j))then
            delta0=delta(i,j);i1=i;j1=j;a0=a(i,j);b0=b(i,j)
            sum0=su(i,j)
           endif
         enddo;enddo
C
         i0=i1;j0=j1
         if(sum0.lt.1.0d-6)then
          ni=ni-1
          write(io,*)'Angle error'
          write(io,*)a0,b0,sum0
          write(io,*)'Not convergenced'
          write(io,*)'But iteration should be stopped at',ni
          goto 200
         endif
         sdelta=sdelta+delta0
         alfa=acos(-a0/sum0)
         if(b0.lt.0.0d0)alfa=2*pi-alfa
         alfa=alfa/4.0d0        
C        write(io,*),a0,b0,sum0
C        write(io,*)'cycle:',ni
!         write(io,*)'Rotate',i0,'and',j0,'orbital, angle =',alfa/pi*180
         cosa=cos(alfa);sina=sin(alfa)
         do k=1,nbasis
          ca=cosa*cv(k,i0)+sina*cv(k,j0)
          cb=-sina*cv(k,i0)+cosa*cv(k,j0)
          cv(k,i0)=ca;cv(k,j0)=cb
         enddo  
!         write(io,*)'The greatest increase=',delta0
         if(delta0.lt.tol)goto 200
1000    continue

        stop 'out of iterative cycles'

200     f=0.0d0
        do i=1,natom
         do j=n1,n2
          f=f+p(i,j,j)*p(i,j,j)
         enddo
        enddo
        write(io,*)'Initial Localization Sum  =',f0
        write(io,*)'Localization done after',ni,'iterations'
        write(io,*)'Final Localization Sum  =',f
        write(io,*)'Increase =',f-f0
        return

        end
C
C
        subroutine inte(natom,nbasis,nv,nb,c,s,p)
        double precision c(nbasis,nv),s(nbasis,nbasis),
     +p(natom,nv,nv)
        integer nb(natom)
        p=0.0d0
        do i=1,natom
         nk=nbasis
         if(i.ne.natom)nk=nb(i+1)-1
         do m=1,nv
          do n=m,nv
           do j=1,nbasis
            do k=nb(i),nk
             p(i,m,n)=p(i,m,n)+c(j,m)*s(j,k)*c(k,n)+c(k,m)*s(j,k)*c(j,n)
            enddo
           enddo
          enddo
         enddo
        enddo
        p=p/2
        return
        end

C
C --- Count the number of frozen core orbitals automatically
      subroutine FRZORB(io,NATOM,ZAN,nfocc,nfvir,icore)
      implicit double precision(A-H,O-Z)
      dimension ZAN(NATOM)
C
      nfocc=0
      nfvir=0
      if (icore.ne.0) goto 999
      do i=1,NATOM
         if (ZAN(i).gt.86) then
            nfocc=nfocc+43
         elseif (ZAN(i).gt.54) then
            nfocc=nfocc+27
         elseif (ZAN(i).gt.36) then
            nfocc=nfocc+18
         elseif (ZAN(i).gt.18) then
            nfocc=nfocc+9
         elseif (ZAN(i).gt.10) then
            nfocc=nfocc+5
         elseif (ZAN(i).gt.2) then
            nfocc=nfocc+1
         endif
      enddo
C
 999  if (io.gt.0) write(io,100) nfocc,nfvir
C
 100  format(1x,'The number of frozen MOs (occupied, virtual) =',2i6)
      end
C
****** 2005.03.29 get value after vari= in a line******
*      2005.09.10 updated
      subroutine GetIValu(line,vari,ch,k,nvalu)
      implicit none
      integer nvalu,l1,l2,i1,i2,i3,k,l
      character line*(*),vari*(*),ch
                                                                                   
      call NJ_upper(line)
      call NJ_upper(vari)
      l1=len(line); l2=len(vari)
      k=index(line,vari)
      if (k==0) then
         nvalu=0; return
      endif
      i2=index(line(k:l1),ch)+k-1
      if (i2.eq.k-1) then
         nvalu=0; return
      endif
      i3=index(line(k:l1),' ')+k-1
      if (i3==i2+1) then
         do l=i3,l1
            if (line(l:l).ne.' ') then
               i3=l; exit
            endif
         enddo
         do l=i3,l1
            if (line(l:l).eq.' ') then
               i3=l; exit
            endif
         enddo
      endif
      read(line(i2+1:i3-1),*) nvalu
C
      end
C
****** real*8 value
      subroutine GetRValu(line,vari,k,rvalu)
      implicit none
      integer l1,l2,i1,i2,i3,k
      double precision rvalu
      character line*(*),vari*(*)
C                                                                                   
      call NJ_upper(line)
      call NJ_upper(vari)
      l1=len(line); l2=len(vari)
      k=index(line,vari)
      if (k==0) then
         rvalu=0d0; return
      endif
      i2=index(line(k:l1),'=')+k-1
      i3=index(line(k:l1),' ')+k-1
      read(line(i2+1:i3-1),*) rvalu
C
      end
C
****** real*8 value
      subroutine GetCValu(line,vari,k,cvalu)
      implicit none
      integer l1,l2,i1,i2,i3,k
      character line*(*),vari*(*),cvalu*8
C                                                                                   
      call NJ_upper(line)
      call NJ_upper(vari)
      cvalu='        '
      l1=len(line); l2=len(vari)
      k=index(line,vari)
      if (k.eq.0) return
      i2=index(line(k:l1),'=')+k-1
      i3=index(line(k:l1),' ')+k-1
      cvalu(1:i3-1-i2)=line(i2+1:i3-1)
C
      end
C
C
C-WL- Calc the spatial distance of MOs
      subroutine DODISMO(io,NW,Nmo,NUW,SMO,mdmx,mdmy,mdmz,DISMO)
      implicit none
      integer i,j,k,L,k1,k2,k3,k4,m,n,io,NW,Nmo,NUW
      double precision SMO(NW,Nmo),mdmx(Nmo,Nmo),mdmy(Nmo,Nmo)
      double precision mdmz(Nmo,Nmo)
      double precision DISMO(NUW,NUW),R,X,Y,Z
C
      DISMO=0
      DO 100 I=1,NUW-1
         DO 200 J=I+1,NUW
            X=mdmx(I,I)-mdmx(J,J)
            Y=mdmy(I,I)-mdmy(J,J)
            Z=mdmz(I,I)-mdmz(J,J)
            R=DSQRT(X*X+Y*Y+Z*Z)
            DISMO(I,J)=R
            DISMO(J,I)=R
 200     END DO
 100  END DO
C
      IF (io.gt.0) THEN
         write(io,*) '+++ The spatial distances of LMOs +++'
         call NJ_prtsym(io,NUW,DISMO,'d14.6')
      END IF
C
      END
C
C --- 2005.11.16 Cnp = Anm Bmp
      subroutine NJ_matpro(io,n,m,p,A,B,C)
      implicit none
      integer io,m,n,p,i,j,k,l
      real*8 A(n,m),B(m,p),C(n,p)
      C=0d0
      do j=1,p; do i=1,n
         do k=1,m
            C(i,j)=C(i,j)+A(i,k)*B(k,j)
         enddo
      enddo; enddo
C
      end
C
C --- 2005.11.16 --- Transformation matrix for overlap by Symmetric Orthogonalization  ---
      subroutine NJ_symorth(io,nbs,Evalu,Evect,Tmatr)
      implicit none
      integer io,nbs,i,j,k
      real*8 Evalu(nbs),Evect(nbs,nbs),Tmatr(nbs,nbs),PP

      Tmatr=0d0
      do j=1,nbs; do i=1,nbs
         do k=1,nbs
            PP=Evect(i,k)*Evect(j,k)/dsqrt(Evalu(k))
            Tmatr(i,j)=Tmatr(i,j)+PP
         enddo
      enddo; enddo

      if (io>0) then
         write(io,*) 'Transformation Matrix by Symmetric',
     &               ' Orthogonalization'
         call NJ_prtsym(io,nbs,Tmatr,'d14.6')
         write(io,*)
      endif

      end
C
C --- 2005.11.19 --- Transformation matrix for overlap by Canonical Orthogonalization  ---
      subroutine NJ_canorth(io,nbs,nif,Evalu,Evect,Tmatr)
      implicit none
      integer io,nbs,i,j,k,nif
      real*8 Evalu(nif),Evect(nbs,nif),Tmatr(nbs,nif),PP

      Tmatr=0d0
      do j=1,nif; do i=1,nbs
            PP=Evect(i,j)/dsqrt(Evalu(j))
            Tmatr(i,j)=Tmatr(i,j)+PP
      enddo; enddo

      if (io>0) then
         write(io,*) 'Transformation Matrix by Canonical',
     &               ' Orthogonalization'
         call NJ_prtcol2(io,nbs,nif,Tmatr,1,nif,'f14.6')
         write(io,*)
      endif

      end
C
C --- 2008.02.13 Add for the orthogonalization of MOs
      subroutine OrthMO(io,nbs,nmo,mo,s,omo,norm,itype)  ! liweiii
      implicit none
      integer io,nbs,nmo,i,j,k,L,m,n,k1,k2,k3,k4,j1,j2,ii,mu,nu,norm
      integer itype
      double precision mo(nbs,nmo),s(nbs,nbs),P1,PP,P2,omo(nbs,nmo)
      double precision,allocatable::ss(:,:),q(:,:),e(:),vc(:),t(:,:)
C
      allocate(ss(nmo,nmo),q(nmo,nmo),e(nmo),vc(nmo),t(nmo,nmo))
C
C     write(io,*) 'Occupied LMOs in expanded subsystems'
C     call NJ_prtcol2(io,nbs,nmo,mo,1,nmo,'f11.6')
C
      call NJ_tfock(0,nbs,nmo,s,mo,ss) ! s'=mo^T*s*mo
C
C     write(io,*) 'Occupied LMOs in expanded subsystems'
C     do j1=1,nmo-1
C        do j2=j1+1,nmo
C           P1=ss(j2,j1)
C           if (dabs(P1)>1d-6) write(io,'(2i4,f12.8)') j1,j2,P1
C        enddo
C     enddo
C
      call NJ_qr(io,ss,nmo,q,e,vc,k,0)
      write(io,*) 'Eigenvalues:'
      write(io,'(5f11.6)') e
      if (itype.eq.1) then
         write(io,*) 'Symmetric Orthogonalization is used'
         call NJ_symorth(0,nmo,e,q,t)
      else if (itype.eq.2) then
         write(io,*) 'Canonical Orthogonalization is used'
         call NJ_canorth(0,nmo,nmo,e,q,t)
      else
         write(io,*) 'Wrong type for orthogonalization'
         write(io,*) 'itype in OrthMO() should be 1 or 2'
         write(io,*) '1. Symmetric Orthogonalization'
         write(io,*) '2. Canonical Orthogonalization'
      endif
      call NJ_matpro(io,nbs,nmo,nmo,mo,t,omo)
      if (norm.ne.0) call normorb2(io,nbs,nmo,omo,s)
C
C     write(io,*) 'Orthogonal occupied LMOs in expanded subsystems'
C     call NJ_prtcol2(io,nbs,nmo,omo,1,nmo,'f11.6')
      write(io,*) 'C^+SC='
      call NJ_tfock(0,nbs,nmo,s,omo,ss) ! s'=mo^T*s*mo
C
      write(io,*) 'New --> Old     Overlap (> 0.1)'
      do j=1,nmo
         do i=1,nmo
            P1=0d0
            do mu=1,nbs
               do nu=1,nbs
                  P1=P1+mo(mu,i)*omo(nu,j)*s(nu,mu)
               enddo
            enddo
            if (dabs(P1).gt.0.1d0) 
     &         write(io,'(i4,'' -->'',i4,5x,''S='',f12.8)') j,i,P1
         enddo
      enddo
C
      deallocate(ss,q,e,vc,t)
      end
C
C --- Project nmo2 of nmo occ. LMOs from total system onto extended subsystems
      subroutine projorb(io,nbs,nbs2,nmo,nmo2,mo,mo2,s)
      integer io,nbs,nbs2,nmo,i,j,k,L
      double precision mo(nbs,nmo),mo2(nbs2,nmo2),s(nbs,nbs)
C
      if (nmo.eq.nmo2) then
         write(io,100) nmo,nbs,nbs2
      else
         write(io,105) nmo,nmo2,nbs,nbs2
      endif
C
      if (nbs2.gt.nbs) then
         write(io,110) nbs2,nbs
         call abrt
      end if
C
      if (nmo2.gt.nmo) then
         write(io,120) nmo2,nmo
         call abrt
      end if
C
      if (nbs2.eq.nbs) then
         do j=1,nmo2
            do i=1,nbs2
               mo2(i,j)=mo(i,j)
            enddo
         enddo
      else
         do j=1,nmo2
            CALL MINA1(nbs2,j,nbs,nmo,mo,s,mo2(1,j))
         enddo
      endif
     
C
 100  format(3x,'[Project MOs]    MO=',i4,' AO:',i4,' -->',i4)
 105  format(3x,'[Project MOs]    MO:',i4,' -->',i4,' AO:',i4,' -->',i4)
 110  format(1x,'It is impossible to project orbitals on more AOs',2i5)
 120  format(1x,'It is impossible to project more MOs than olds',2i5)
      end
C
C --- 2008.02.21 --- Project out the mo1(nbs,nmo1) from mo2(nbs,nmo2)
      subroutine pjotorb(io,nbs,nmo1,nmo2,mo1,mo2,s)
      implicit none
      integer io,nbs,nmo1,nmo2,i,j,k,L,m,n,k1,k2,k3,k4
      double precision mo1(nbs,nmo1),mo2(nbs,nmo2),s(nbs,nbs),P1
      double precision,allocatable::p(:,:),ps(:,:),mo3(:,:)
C
      write(io,100) nmo1,nmo2,nbs
      allocate(p(nbs,nbs),ps(nbs,nbs),mo3(nbs,nmo2))
C
      do i=1,nbs
         do j=1,nbs
            P1=0d0
            do m=1,nmo1
               P1=P1+mo1(i,m)*mo1(j,m)
            end do
            p(j,i)=P1
            p(i,j)=P1
         end do
      end do
C
      call NJ_matpro(io,nbs,nbs,nbs,p,s,ps)
      call NJ_matpro(io,nbs,nbs,nmo2,ps,mo2,mo3)
C
      do i=1,nmo2
         do j=1,nbs
            mo2(j,i)=mo2(j,i)-mo3(j,i)
         end do
      end do
C
      deallocate(p,ps,mo3)
C
 100  format(3x,'[Project out]    MO:',i4,' <-|',i4,' AO=',i4)
      end
C
C --- 2008.02.13 Add for the orthogonalization of MOs
      subroutine orthorb(io,nbs,nmo,mo,s,itype)  ! liweiii
      implicit none
      integer io,nbs,nmo,i,j,k,L,m,n,k1,k2,k3,k4,j1,j2,ii,mu,nu,norm
      integer itype,nzero
      double precision mo(nbs,nmo),s(nbs,nbs),P1,PP,P2,zeps
      double precision,allocatable::ss(:,:),q(:,:),e(:),vc(:),t(:,:)
      double precision,allocatable::omo(:,:)
C
      zeps=1d-5
C
      allocate(ss(nmo,nmo),q(nmo,nmo),e(nmo),vc(nmo),t(nmo,nmo))
      allocate(omo(nbs,nmo))
      call NJ_tfock(0,nbs,nmo,s,mo,ss) ! s'=mo^T*s*mo  overlap over MO
      call NJ_qr(0,ss,nmo,q,e,vc,k,0) ! QR diagonalization of ss
      call numpoint(nmo,e,-zeps,zeps,nzero)  ! Count the number of values \in [-zeps,zeps] ("zero" eigenvalues)
      if (nzero.ne.0) then
         write(io,200) nzero
         write(io,210) (e(i),i=1,nmo)
      end if
C
      if (itype.eq.1) then
         write(io,100) nmo,nbs
         call NJ_symorth(0,nmo,e,q,t)
      else if (itype.eq.2) then
         write(io,110) nmo,nbs
         call NJ_canorth(0,nmo,nmo,e,q,t)
      else
         write(io,*) 'Wrong type for orthogonalization'
         write(io,*) 'itype in OrthMO() should be 1 or 2'
         write(io,*) '1. Symmetric Orthogonalization'
         write(io,*) '2. Canonical Orthogonalization'
         stop
      endif
      call NJ_matpro(io,nbs,nmo,nmo,mo,t,omo)
C
      do i=1,nmo
         do j=1,nbs
            mo(j,i)=omo(j,i)
         end do
      end do
C
      deallocate(ss,q,e,vc,t,omo)
C
 100  format(3x,'[Symmetric orth] MO=',i4,' AO=',i4)
 110  format(3x,'[Canonical orth] MO=',i4,' AO=',i4)
 200  format(1x,'Warning: number of zero eigenvalues=',i4)
 210  format(1x,5f14.6)
      end
C
C --- Normalization of a set of orbital mo(nbs,nmo)
      subroutine normorb2(io,nbs,nmo,mo,s)
      implicit none
      integer io,nbs,nmo,i,j,k,L,m,n,k1,k2,k3,k4
      double precision mo(nbs,nmo),s(nbs,nbs),P1,PP
C
C     write(io,100) nmo,nbs
      do i=1,nmo
         call normfact(nbs,mo(1,i),s,P1)
         do j=1,nbs
            mo(j,i)=mo(j,i)/P1
         enddo
      enddo
C
 100  format(1x,'[Normalize]      MO=',i4,' AO=',i4)
      end
C
C --- Determine the normalization factor of one orbital c(nbs), vv returned
C     For normalization use c=c/p
      subroutine normfact(nbs,ac,s,p)
      implicit none
      integer nbs,k1,k2
      double precision ac(nbs),s(nbs,nbs),p
C
      p=0d0
      do k1=1,nbs
         do k2=1,nbs
            p=p+ac(k1)*ac(k2)*s(k2,k1)
         end do
      end do
      if (p.le.0d0) stop 'Error in normvalu(): negotive module'
      p=dsqrt(p)
      end
C
C --- Overlap of each MO with itself of mo(nbs,nmo)
C     sort>0 increased sorting
C     sort<0 decreased sorting
C     sort=0 unsorting
      subroutine ovlpslf(io,nbs,nmo,mo,s,ovlp,sort)
      implicit none
      integer io,nbs,nmo,i,j,k,L,i1,i2,j1,j2,k1,k2,sort
      double precision mo(nbs,nmo),s(nbs,nbs),p1,pp,ovlp(nmo)
C
      do i=1,nmo
         p1=0d0
         do j2=1,nbs
            do j1=1,nbs
               p1=p1+mo(j1,i)*mo(j2,i)*s(j1,j2)
            end do
         end do
         ovlp(i)=p1
      end do
C
      if (sort.gt.0) then
         do i=1,nmo-1
            do j=i+1,nmo
               if (ovlp(i).lt.ovlp(j)) cycle
               p1=ovlp(i)
               ovlp(i)=ovlp(j)
               ovlp(j)=p1
               do k=1,nbs
                  pp=mo(k,i)
                  mo(k,i)=mo(k,j)
                  mo(k,j)=pp
               end do
            end do
         end do
         if (io.gt.0) write(io,110) nmo,nbs
      else if (sort.lt.0) then
         do i=1,nmo-1
            do j=i+1,nmo
               if (ovlp(i).gt.ovlp(j)) cycle
               p1=ovlp(i)
               ovlp(i)=ovlp(j)
               ovlp(j)=p1
               do k=1,nbs
                  pp=mo(k,i)
                  mo(k,i)=mo(k,j)
                  mo(k,j)=pp
               end do
            end do
         end do
         if (io.gt.0) write(io,120) nmo,nbs
      else
         if (io.gt.0) write(io,130) nmo,nbs
      end if
C
      if (io.gt.0) write(io,140) (ovlp(i),i=1,nmo)
C
 110  format(1x,'Self overlap of',i4,' MOs with',i5,' AOs (increased)')
 120  format(1x,'Self overlap of',i4,' MOs with',i5,' AOs (decreased)')
 130  format(1x,'Self overlap of',i4,' MOs with',i5,' AOs (unsorted)')
 140  format(8f8.5)
      end
C
C --- Overlap of each MO with itself of mo(nbs,nmo); sort mo and corresponding mo0
C     sort>0 increased sorting
C     sort<0 decreased sorting
C     sort=0 unsorting
      subroutine ovlpslf2(io,nbs,nmo,mo,nbs0,mo0,s,ovlp,sort)
      implicit none
      integer io,nbs,nbs0,nmo,i,j,k,L,i1,i2,j1,j2,k1,k2,sort
      double precision mo(nbs,nmo),s(nbs,nbs),p1,pp,ovlp(nmo)
      double precision mo0(nbs0,nmo)
C
      do i=1,nmo
         p1=0d0
         do j2=1,nbs
            do j1=1,nbs
               p1=p1+mo(j1,i)*mo(j2,i)*s(j1,j2)
            end do
         end do
         ovlp(i)=p1
      end do
C
      if (sort.gt.0) then
         do i=1,nmo-1
            do j=i+1,nmo
               if (ovlp(i).lt.ovlp(j)) cycle
               p1=ovlp(i)
               ovlp(i)=ovlp(j)
               ovlp(j)=p1
C
               do k=1,nbs
                  pp=mo(k,i)
                  mo(k,i)=mo(k,j)
                  mo(k,j)=pp
               end do
C
               do k=1,nbs0
                  pp=mo0(k,i)
                  mo0(k,i)=mo0(k,j)
                  mo0(k,j)=pp
               end do
            end do
         end do
         if (io.gt.0) write(io,110) nmo,nbs
      else if (sort.lt.0) then
         do i=1,nmo-1
            do j=i+1,nmo
               if (ovlp(i).gt.ovlp(j)) cycle
               p1=ovlp(i)
               ovlp(i)=ovlp(j)
               ovlp(j)=p1
C
               do k=1,nbs
                  pp=mo(k,i)
                  mo(k,i)=mo(k,j)
                  mo(k,j)=pp
               end do
C
               do k=1,nbs0
                  pp=mo0(k,i)
                  mo0(k,i)=mo0(k,j)
                  mo0(k,j)=pp
               end do
            end do
         end do
         if (io.gt.0) write(io,120) nmo,nbs
      else
         if (io.gt.0) write(io,130) nmo,nbs
      end if
C
      if (io.gt.0) write(io,140) (ovlp(i),i=1,nmo)
C
 110  format(1x,'Self overlap of',i4,' MOs with',i5,' AOs (increased)')
 120  format(1x,'Self overlap of',i4,' MOs with',i5,' AOs (decreased)')
 130  format(1x,'Self overlap of',i4,' MOs with',i5,' AOs (unsorted)')
 140  format(8f8.5)
      end
C
C --- Overlap between MOs of mo(nbs,nmo)
      subroutine ovlporb(io,nbs,nmo,mo,s)
      implicit none
      integer io,nbs,nmo,i,j,k,L,i1,i2,j1,j2,k1,k2
      double precision mo(nbs,nmo),s(nbs,nbs),p1,pp
      double precision,allocatable::ovlp(:,:)
C
      allocate(ovlp(nmo,nmo))
      do i2=1,nmo
         do i1=1,nmo
            p1=0d0
            do j2=1,nbs
               do j1=1,nbs
                  p1=p1+mo(j1,i1)*mo(j2,i2)*s(j1,j2)
               end do
            end do
            ovlp(i1,i2)=p1
         end do
      end do
C
      if (io.gt.0) then
         write(io,100) nmo,nbs
         call NJ_prtsym(io,nmo,ovlp,'f12.8')
      end if
C
      deallocate(ovlp)
 100  format(1x,'Overlap between',i4,' MOs with',i5,' AOs')
      end
C
C --- Overlap between two set of MOs mo1(nbs,nmo1),mo2(nbs,nmo2)
      subroutine ovlporb2(io,nbs,nmo1,mo1,nmo2,mo2,s)
      implicit none
      integer io,nbs,nmo1,nmo2,i,j,k,L,i1,i2,j1,j2,k1,k2
      double precision mo1(nbs,nmo1),mo2(nbs,nmo2),s(nbs,nbs),p1,pp,over
      double precision,allocatable::ovlp(:,:)
      parameter(over=0.2d0)
C
      allocate(ovlp(nmo1,nmo2))
      do i2=1,nmo2
         do i1=1,nmo1
            p1=0d0
            do j2=1,nbs
               do j1=1,nbs
                  p1=p1+mo1(j1,i1)*mo2(j2,i2)*s(j1,j2)
               end do
            end do
            ovlp(i1,i2)=p1
         end do
      end do
C
      if (io.gt.0) then
         write(io,100) nbs
         write(io,110) over
         write(io,120) nmo2,nmo1
C        call NJ_prtcol2(io,nmo1,nmo2,ovlp,1,nmo2,'f12.8')
         do i2=1,nmo2
            do i1=1,nmo1
               if (dabs(ovlp(i1,i2)).gt.0.1d0) write(io,150) i2,i1
            end do
         end do
      end if
C
      deallocate(ovlp)
 100  format(1x,'Overlap between two sets of MOs with',i5,' AOs')
 110  format(1x,'Only print those items with value larger than',f7.4)
 120  format(1x,'Second (new) set (',i4,' MOs) --> First (old) set (',
     &       i4,' MOs)') 
 150  format(i5,' -->',i5)
      end
C
C
C --- WL Sort jobs in .jobs file from the most expensive to cheapest one
      subroutine sortjob(job,njobs,kord)
      implicit none
      integer i,j,k,L,k1,k2,k3,k4,job,njobs,kord(njobs)
      character(len=256),dimension(:),allocatable::cjob
C
      allocate(cjob(4*njobs))
      cjob=' '
C
      rewind(job)
      read(job,*)
      do j=1,4*njobs
         read(job,'(a)') cjob(j)
      enddo
C
      rewind(job)
      read(job,*)
      do i=1,njobs
         k=kord(i)
         k1=4*k-3
         k2=4*k-2
         k3=4*k-1
         k4=4*k
         write(job,'(a)') trim(cjob(k1))
         write(job,'(a)') trim(cjob(k2))
         write(job,'(a)') trim(cjob(k3))
         write(job,'(a)') trim(cjob(k4))
      enddo
C
      deallocate(cjob)
      end
C
      subroutine NJ_denmat(io,nbs,nif,noc,cmo,dm)
      implicit none
      integer io,nbs,nif,noc,i,j,k
      real*8 cmo(nbs,nif),dm(nbs,nbs),PP
      dm=0d0
      do i=1,nbs; do j=1,nbs
         PP=0d0
         do k=1,noc
            PP=PP+cmo(i,k)*cmo(j,k)
         enddo
         dm(i,j)=2d0*PP
      enddo; enddo

      if (io>0) then
         write(io,*) '*** Density matrix ***'
         call NJ_prtsym(io,nbs,dm,'d14.6')
         write(io,*)
      endif
      return
      end
C
C-WL- 7 Apr 2009: print infomation to io
      subroutine PRTINF(io,NAT,ICH,MUL,NE,NA,NB,NBS,NMO,
     &           NSHELL,NGAUSS,ENU,SCFTYP,EHF)
      implicit none
      integer io,NAT,ICH,MUL,NE,NA,NB,NBS,NMO,NSHELL,NGAUSS
      character(len=8) SCFTYP
      double precision ENU,EHF
      integer i,j,k,L,m,n,k1,k2,k3,k4,k5,k6
      character(len=200) line
C
      write(io,*) '+++ Read information from CIMFILE file +++'
      write(io,'(1x,44(''-''))')
      write(io,*) 'Number of atoms                ',NAT
      write(io,*) 'Charge                         ',ICH
      write(io,*) 'Multiplicity                   ',MUL
      write(io,*) 'Number of electrons            ',NE
      write(io,*) 'Number of alpha electrons      ',NA
      write(io,*) 'Number of beta electrons       ',NB
      write(io,*) 'Number of basis functions      ',NBS
      write(io,*) 'Number of independant functions',NMO
      write(io,*) 'Number of contracted shells    ',NSHELL
      write(io,*) 'Number of primitive shells     ',NGAUSS
      write(io,'('' Nuclear Repulsion Energy'',f20.9)') ENU
      write(io,'('' SCF type = '',a8)') scftyp
      write(io,'('' SCF energy='',f20.9)') EHF
      write(io,'(1x,44(''-''))')
      write(io,*)
C
      end
C
c     ##############################################################
c     ##  subroutine GMSINP --  Make GAMESS input of subsystem    ##
c     ##  2004.12.26 by Wei Li; Update 2005.12.26 by Wei Li       ##
c     ##############################################################
      subroutine SUBINP(io,inp,nat,nuchar,coor,snat,BA,
     &           scftyp,mplevl,cctyp,IWORK,mwords,icharg,mult,NCBS,CBAS,
     &           thissystem)
      implicit none
      integer thissystem
      integer io,inp,nat,snat,BA(snat),i,j,k,l,m,n,m1,m2
      double precision nuchar(nat),coor(3,nat)
      integer k1,k2,k3,k4,k5,k6,kccinp,mplevl,IWORK(100)
      character line*256,line2*256,sls,elemsyl*2,atom*2,cconv*80
      character*8 scftyp,cctyp
      integer memnew,icharg,L1,L2,mult,L3,L4,mwords
      character charg*100,mulp*100,bk,ch
      character ispher*100
      integer L5,L6
      external elemsyl
      integer NCBS(nat)
      character(len=100) CBAS(100,nat)
C
      rewind(inp)
      sls=char(47)
      bk=' '
      kccinp=0
      write(cconv,*) IWORK(1)
      call NJ_trim(cconv,k5,k6)
C
      write(charg,*) icharg
      call NJ_trim(charg,L1,L2)
      write(mulp,*) mult
      call NJ_trim(mulp,L3,L4)
C
      write(ch,'(i1)') mplevl
C     write(ispher,'(i1)') iwork(61)
      write(ispher,*) iwork(61)
      call NJ_trim(ispher,L5,L6)
C
C --- $CONTRL
      line = '$CONTRL RUNTYP=CIMSUB SCFTYP='//trim(scftyp)
     &     //' MPLEVL='//ch//' CCTYP='//trim(cctyp)
      write(inp,99) trim(line)
      line = 'ISPHER='//ispher(L5:L6)//' ICHARG='//charg(L1:L2)
     & //' MULT='//mulp(L3:L4)
     &     //' NORMP=1 NPRINT=-5 $END'
      write(inp,99) trim(line)
      if(mplevl.eq.2) then
         line = '$MP2 CODE=SERIAL $END'
         write(inp,99) trim(line)
      endif
C
C --- $SYSTEM
      write(line,*) mwords
      call NJ_trim(line,k1,k2)
      line = '$SYSTEM MWORDS='//line(k1:k2)//' $END'
      write(inp,99) trim(line)
C
C --- $CCINP
      if (cctyp.ne.'NONE    ') then
         if (scftyp.eq.'RHF     ') then
            line = '$CCINP NCORE=0 MAXCC=200 MAXCCL=200 ICONV='
     &           //cconv(k5:k6)//' $END'
         else
            line = '$CCINP NCORE=0 MAXCC=200 IOPMET=1 ICONV='
     &           //cconv(k5:k6)//' MULT='//mulp(L3:L4)//' $END'
         endif
         write(inp,99) trim(line)
      endif
C
C --- $DATA
      write(inp,99) '$DATA'
C     write(inp,110) snat
      write(inp,111) thissystem
      write(inp,100) 'C1'
      do k=1,snat
         L=BA(k)
         atom=elemsyl(nint(nuchar(L)))
         write(inp,120) atom,nuchar(L),(coor(j,L),j=1,3)
         do j=1,NCBS(L)
            write(inp,'(a)') trim(CBAS(j,L))
         enddo
         write(inp,'(a8)') '        '
      enddo
      write(inp,99) '$END'
C
C
  99  format(1x,a)
 100  format(a)
 110  format('NAtoms=',i4)
 111  format('Subsystem ',i4)
 120  format(a3,f5.1,3f16.8)
C
      end
C
C
      subroutine ifind2(iunit, key)
      implicit none
      character key*(*),line*200
      integer iunit,n,L,k,iyes,itry
C
      iyes=0
      itry=0
      L=len(key)
 50   do
         read(iunit,'(a)',end=100,err=100) line
         if (index(line,key(1:L)).ne.0) then
            iyes=1
            backspace(iunit)
            return
         endif
      end do
C
 100  itry=itry+1
      if (itry.eq.1) then
         rewind(iunit)
         goto 50
      endif
C sometimes fortran has problems if the 
C position is set to EOF
      backspace(iunit)

      end
C
C-WL- 09 SEP 2009 for determining the level of calculations of subsystems
      subroutine SYSLEVEL(io,NUW,KGG,ISUB3,INF2,molevl,mtdsys)
      implicit none
      integer io,NUW,KGG,i,j,k,L,k1,k2
      integer ISUB3(NUW),INF2(NUW,NUW),molevl(NUW),mtdsys(KGG)
      mtdsys=0
      do i=1,KGG
         if (ISUB3(i).eq.0) cycle
         do j=1,ISUB3(i)
            k=INF2(j,i)
            k1=mtdsys(i)
            k2=molevl(k)
            if (k2.gt.k1) then
               mtdsys(i)=k2
            endif
         enddo
      enddo

      if (io.gt.0) then
         write(io,*) '+++ The level of the calculations for subsys +++'
         write(io,'(4(3x,5i3))') (mtdsys(i),i=1,KGG)
         write(io,*) '0 - NONE'
         write(io,*) '1 - MP2'
         write(io,*) '2 - CCD'
         write(io,*) '3 - CCSD'
         write(io,*) '4 - CCSD(T)'
         write(io,*) '5 - CR-CCL'
         WRITE(io,*)
      endif
      end

C --- 2009.04.21 -WL- Sorting the orbitals by the index
      subroutine SortOcc(io,noa,nob,nsys,mcen,mocc,LOCC,CenMO)
      implicit none
C
      integer io,noa,nob,nsys,i,j,k,L,m,n,k1,k2,k3,k4,L1,L2
      integer mcen(noa),mocc(noa),LOCC(noa,noa),CenMO(noa,nsys)
C
      CenMO=0
C
      do i=1,nsys
         do j=1,mcen(i)
            if (LOCC(j,i).gt.nob) then
               CenMO(j,i)=1
            else
               CenMO(j,i)=2
            endif
         enddo
      enddo
C
      if (io.gt.0) then
         write(io,*) '+++ Occ. MOs before sorting +++'
         do i=1,nsys
            write(io,'(3(5i4,2x),5i4)') (LOCC(j,i),j=1,mocc(i))
         enddo
         write(io,*) '+++ Cen. MOs before sorting +++'
         do i=1,nsys
            write(io,'(7(5i2,1x),5i2)') (CenMO(j,i),j=1,mocc(i))
         enddo
         write(io,*)
      endif
C
C
      do i=1,nsys
         do k1=1,mocc(i)-1
            do k2=k1+1,mocc(i)
               L1=LOCC(k1,i)
               L2=LOCC(k2,i)
               if (L1.le.L2) cycle
               LOCC(k1,i)=L2
               LOCC(k2,i)=L1
               k=CenMO(k1,i)
               CenMO(k1,i)=CenMO(k2,i)
               CenMO(k2,i)=k
            enddo
         enddo
      enddo
C
      if (io.gt.0) then
         write(io,*) '+++ Occ. MOs after sorting +++'
         do i=1,nsys
            write(io,'(3(5i4,2x),5i4)') (LOCC(j,i),j=1,mocc(i))
         enddo
         write(io,*) '+++ Cen. MOs after sorting +++'
         do i=1,nsys
            write(io,'(7(5i2,1x),5i2)') (CenMO(j,i),j=1,mocc(i))
         enddo
         write(io,*)
      endif
C
      end
C
C --- goto the end of a file
      subroutine LS_toend(io,iform)
      implicit none
      integer i,j,io,iform

      do
        if (iform==0) then
           read(io,*,end=200,err=200)
        elseif (iform==1) then
           read(io,end=200,err=200)
        endif
      enddo

 200  return
      end
C
C --- 2009.11.03 copy FXY from FIJ
      subroutine CopyFIJ(io,NUW,FIJ,FXY)
      implicit none
      integer io,NUW,i,j,k,L
      double precision FIJ(NUW,NUW),FXY(NUW,NUW)
C
      do i=1,NUW
         do j=1,NUW
            FXY(j,i)=FIJ(j,i)
         enddo
      enddo
C
      end
C
C --- 2009.10.28 Calculate FXY from FIJ
      subroutine FIJ2XY(io,NUW,FIJ,FXY)
      implicit none
      integer io,NUW,i,j,k,L,m,n,k1,k2,k3,k4
      double precision FIJ(NUW,NUW),FXY(NUW,NUW)
      double precision f11,f22,f12,fav,delt,sqdlt,fd,e1,e2,de
C
      do i=1,NUW
         do j=1,NUW
            FXY(j,i)=0d0
         enddo
      enddo
C
      do i=1,NUW-1
         do j=i+1,NUW
C           write(io,*) 'FIJ for i,j=',i,j
C           write(io,*) 'F(i,i)=',FIJ(i,i)
C           write(io,*) 'F(j,j)=',FIJ(j,j)
C           write(io,*) 'F(i,j)=',FIJ(i,j)
C           write(io,*) 'F(j,i)=',FIJ(j,i)
            f11=FIJ(i,i)
            f22=FIJ(j,j)
            f12=FIJ(i,j)
            fav= 0.5d0*(f11+f22)
            fd = f11-f22
            delt = fd*fd+4.0d0*f12*f12
            sqdlt =dsqrt(delt)
            e1 = (f11+f22-sqdlt)*0.5d0
            e2 = (f11+f22+sqdlt)*0.5d0
            if (f11.le.f22) then
               de = f11-e1
            else
               de = f22-e1
            endif
            de = dabs(de/fav)
C           write(io,*) e1,e2,de
            FXY(i,j) = de
            FXY(j,i) = de
C           write(io,*)
         enddo
      enddo
C
      if (io.gt.0) then
         write(io,*) '=== New FXY for the LMOs selection ==='
         call NJ_prtsym(io,NUW,FXY,'f12.5')
      endif
C
      end
C
C --- 2009.11.03 Calculate FXY from FIJ without divided by average Fock
      subroutine FIJ2XY2(io,NUW,FIJ,FXY)
      implicit none
      integer io,NUW,i,j,k,L,m,n,k1,k2,k3,k4
      double precision FIJ(NUW,NUW),FXY(NUW,NUW)
      double precision f11,f22,f12,fav,delt,sqdlt,fd,e1,e2,de
C
      do i=1,NUW
         do j=1,NUW
            FXY(j,i)=0d0
         enddo
      enddo
C
      do i=1,NUW-1
         do j=i+1,NUW
            f11=FIJ(i,i)
            f22=FIJ(j,j)
            f12=FIJ(i,j)
            fav= 0.5d0*(f11+f22)
            fd = f11-f22
            delt = fd*fd+4.0d0*f12*f12
            sqdlt =dsqrt(delt)
            e1 = (f11+f22-sqdlt)*0.5d0
            e2 = (f11+f22+sqdlt)*0.5d0
            if (f11.le.f22) then
               de = f11-e1
            else
               de = f22-e1
            endif
C
            FXY(i,j) = de
            FXY(j,i) = de
C           write(io,*)
         enddo
      enddo
C
      if (io.gt.0) then
         write(io,*) '=== New FXY2 for the LMOs selection ==='
         call NJ_prtsym(io,NUW,FXY,'f12.5')
      endif
C
      end
C
C*MODULE CIMI   *DECK MEMGMS
C>
C>  @brief   memory requirements
C>
C>  @details memory for closed shell MP2,CCSD,CCSD(T),CR-CCL
C>           OR open shell CCSD,CR-CC
C>
C>  @author  Wei Li?
C>
C --- Updated on 25 AUG 10 for MP2 memory
C     a new variable nbf (number of AOs) added
C --- Calculating required memory in words
C     RHF MP2,CCSD,CCSD(T),CR-CCL OR ROHF CCSD,CR-CCL
C
      integer function memgms(scftyp,mplevl,cctyp,nbf,no,nu,nc)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      integer ityp,no,nu,nc,nbf
      character scftyp*8,cctyp*8
      logical DIRSCF
      parameter (MXSH=5000, MXGTOT=20000, MXGSH=30, MXG2=MXGSH*MXGSH)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
C
      if (nc.eq.0) then
         ICIM=0
      else
         ICIM=2
      endif
      no2   = no*no
      nou   = no*nu
      nu2   = nu*nu
      no3   = no2*no
      no2u  = no2*nu
      nou2  = no*nu2
      nu3   = nu2*nu
      no4   = no3*no
      no3u  = no3*nu
      no2u2 = no2*nu2
      nou3  = no*nu3
      nu4   = nu3*nu
C
      NBF2 = (NBF*NBF+NBF)/2
      NBF3  = NBF*NBF
      NOC   = no
      NVIR  = nu
      NINTMX= 15000
      DIRSCF=.FALSE.
      NINTIC= 0
      NDIM  = MAX(NBF2,NVIR*NOC)
      LPASS = MIN(NOC,1000000/NBF2+1)
C
      if (scftyp.eq.'RHF     ') then
         NU3s  = NU*(NU+1)*(NU+2)/6  !-CIM-
      else if (scftyp.eq.'ROHF    ') then
         NU3s  = NU*NU*(NU+1)/2  !-CIM-
      end if
      NCU3s = NC*NU3s  !-CIM-
      KMICRO= 6
C
      LOADFM = 0
      if (scftyp.eq.'RHF     ' .and. mplevl.eq.2) then  ! RHF MP2
         IVEC   = 1    + LOADFM
         IPTR1  = IVEC + NBF*NBF
         IPTR2  = IPTR1+ NOC*NBF
         IENG   = IPTR2+ NVIR*NBF
         ILAB   = IENG + NBF
         IIRP   = ILAB + NBF
         IDEG   = IIRP + NBF
         LAST   = IDEG + NBF
         NEEDA  = LAST - LOADFM - 1
      
         MINTMX=NINTMX
         IF(NINTIC.NE.0) MINTMX=0
C
         CALL BASCHK(LMAX)
                       NANGM =  4
         IF(LMAX.EQ.2) NANGM =  6
         IF(LMAX.EQ.3) NANGM = 10
         IF(LMAX.EQ.4) NANGM = 15
         IF(LMAX.EQ.5) NANGM = 21
         IF(LMAX.EQ.6) NANGM = 28
         MAXG = NANGM**4
         NSH2 = (NSHELL*NSHELL+NSHELL)/2
C
         IF(DIRSCF) THEN
            LGHND  = 1      + LOADFM
            LXINTS = LGHND  + MAXG
            LDDIJ  = LXINTS + NSH2
            LXX    = LDDIJ  + 49*MXG2
            LIX    = LXX    + NINTMX
            LAST   = LIX    + NINTMX
         ELSE
            LGHND  = 1      + LOADFM
            LXINTS = LGHND
            LDDIJ  = LXINTS
            LXX    = LDDIJ
            LIX    = LXX    + MINTMX
            LAST   = LIX    + MINTMX
            IF(NINTIC.NE.0) THEN
               LXX  = LBUFPIC
               LIX  = LIXIC
            ENDIF
         END IF
         NEEDD = LAST - LOADFM - 1
      
         NEED  = 2*NBF3
         NMIN  = NDIM*NBF
         MNMEM = NEEDA + NEEDD + NEED + NMIN*1
         MXMEM = NEEDA + NEEDD + NEED + NMIN*NOC
C
C -------------------------
         LOADFM=0
         LWRK1 = 1     + LOADFM
         LWRK2 = LWRK1 + NBF3
         LPQRJ = LWRK2 + NBF3
         IF (ICIM.EQ.2) THEN
            LNOA  = LPQRJ + NDIM*NBF*LPASS  !-CIM- 25 FEB 10
            LNOB  = LNOA  + NOC             !-CIM- 25 FEB 10
            LTX   = LNOB  + NOC             !-CIM- 25 FEB 10
            LYO2  = LTX   + NOC*NOC         !-CIM- 25 FEB 10
            LYT2T = LYO2  + NOC             !-CIM- 25 FEB 10
            LYT2S = LYT2T + NOC             !-CIM- 25 FEB 10
            LAST  = LYT2S + NOC             !-CIM- 25 FEB 10
         ELSE
            LAST  = LPQRJ + NDIM*NBF*LPASS  !-CIM- 25 FEB 10
         ENDIF
         NEEDE = LAST - LOADFM - 1
         MEM   = NEEDA + NEEDD + NEEDE      ! ~= NBF*NBF2*LPASS
C
C -------------------------
C
         NEED = MEM
      elseif (scftyp.eq.'RHF     ' .and.
     &       (cctyp.eq.'CCSD    '.or.cctyp.eq.'CCD     ')) then  ! RHF CCSD/CCD
         LO1  = LOADFM + 1
         LT1  = LO1    + NOU
         LFH  = LT1    + NOU
         LFPH = LFH    + NO2
         LFP  = LFPH   + NOU
         LVHH = LFP    + NU2
         LVM  = LVHH   + NO4
         LTI  = LVM    + NO3U
         LO2  = LTI    + NU3
         LT2  = LO2    + NO2U2
         LVL  = LT2    + NO2U2
         LVR  = LVL    + NO2U2
         LVPP = LVR    + NO2U2
         IF (ICIM.EQ.2) THEN  !-CIM-
            LNO  = LVPP   + NOU3
            LK   = LNO    + NO   !-CIM-   ECIM(NO)
            LTX  = LK     + NO2  !-CIM-   EK(NO,NO)
            LYO2 = LTX    + NO2  !-CIM-   TX(NO,NO)  2009.08.06
            LYT2 = LYO2   + NO   !-CIM-   YO2(NO)    2009.08.06
            LAST = LYT2   + NO   !-CIM-   YT2(NO)    2009.08.06
         ELSE
            LAST = LVPP   + NOU3
         END IF
         NEED = LAST - LOADFM - 1
      else if (scftyp.eq.'RHF     ' .and. cctyp.eq.'CCSD(T) ') then  ! RHF CCSD(T)
         I1   = LOADFM + 1
         I2   = I1     + NOU
         I3   = I2     + NO2U2
         I4   = I3     + NO3U
         I5   = I4     + NOU3
         I6   = I5     + NU3
         I7   = I6     + NU3
         I8   = I7     + NO2U2
         LAST = I8     + NOU
         IF (ICIM.EQ.2) THEN  !-CIM-
            I9   = I8     + NOU
            I10  = I9     + NO      ! ECIM(NO)  -CIM-
            I11  = I10    + NO2     ! TX(NO,NO) -CIM-
            I12  = I11    + NU3*NC  ! XF3       -CIM-
            I13  = I12    + NU3*NC  ! XT3       -CIM-
            I14  = I13    + NU*NC   ! XO1       -CIM-
            LAST = I14    + NU*NC   ! XT1       -CIM-
         ELSE
            LAST = I8     + NOU
         END IF
         NEED = LAST - LOADFM - 1
      else if (scftyp.eq.'RHF     ' .and. cctyp.eq.'CR-CCL  ') then  ! RHF CR-CC(2,3)
C        memgms = (no+nu) + (2*no2+2*nu2+6*nou)+3*nu3+2*nou2+2*no2u
C        memgms =  memgms + 3*no3u+5*no2u2+3*nou3
C        if (nc.ne.0) memgms = memgms + no+no2+11*nu3*nc
         I1   = LOADFM + 1
         I2   = I1     + NOU
         I3   = I2     + NO2U2
         I4   = I3     + NO3U
         I5   = I4     + NOU3
         I7   = I5     + NU3
         I8   = I7     + NOU
         I9   = I8     + NO2U2
         I10  = I9     + NOU3
         I11  = I10    + NO3U
         I12  = I11    + NO2U2
         I13  = I12    + NU3
         I14  = I13    + NO
         I15  = I14    + NU
         I16  = I15    + 2*NU2
         I17  = I16    + 2*NO2
         I18  = I17    + 2*NOU
         I19  = I18    + 2*NOU2
         I20  = I19    + 2*NO2U
         I21  = I20    + NOU
         I22  = I21    + NO2U2
         I23  = I22    + NU3
         I24  = I23    + NOU3
         I26  = I24    + NO3U
         I27  = I26    + NOU
         IF (ICIM.EQ.2) THEN
            I29  = I27    + NO2U2    !-CIM-
            I30  = I29    + NO*2     !-CIM- ECIM  09 MAR 10 NO --> NO*2
            I31  = I30    + NO2      !-CIM- TX
            I32  = I31    + NU3*NC   !-CIM- XV3
            I33  = I32    + NCU3s*20 !-CIM- XBL
            LAST = I33    + NC       !-CIM- TXs
         ELSE
            LAST = I27    + NO2U2
         END IF
         NEED = LAST - LOADFM - 1
      else if (scftyp.eq.'ROHF    ' .and. cctyp.eq.'CCSD    ') then ! ROHF CCSD
C        memgms = 1*no4+1*no3u+9*no2u2+3*nou3 + 4*nou+2*no2+2*nu2+nu3
         I1   = LOADFM + 1
         I2   = I1     + NOU       ! O1AA
         I3   = I2     + NOU       ! T1
         I4   = I3     + NOU       ! O1BB
         I5   = I4     + NO4       ! VHHAA
         I6   = I5     + NO2U2     ! VHPLAA
         I7   = I6     + NO2U2     ! VHPLBB
         I8   = I7     + NO2U2     ! O2AA
         I9   = I8     + NO2U2     ! O2BB
         I10  = I9     + NO2U2     ! O2AB
         I11  = I10    + NOU3      ! VEAB
         I12  = I11    + NOU3      ! VEBA
         I13  = I12    + NO2U2     ! VHPRBB
         I14  = I13    + NO2U2     ! VHPRAA
         I15  = I14    + NO2U2     ! VHPRAB
         I16  = I15    + NOU3      ! TI
         I17  = I16    + NO3U      ! VMAA
         I18  = I17    + NOU       ! FHP
         I19  = I18    + NO2       ! FHHAA
         I20  = I19    + NO2       ! FHHBB
         I21  = I20    + NU2       ! FPPAA
         I22  = I21    + NU2       ! FPPBB
         I23  = I22    + NO2U2     ! T2
         I24  = I23    + NU3       ! VPP
         I25  = I24    + (KMICRO+1)**2  ! XMAT
         I26  = I25    + (KMICRO+1)     ! BVEC
         IF (ICIM.EQ.2) THEN
            I27  = I26    + (KMICRO+1)     ! IPVT
            I28  = I27    + NO       !-CIM- ECIMA
            I29  = I28    + NO       !-CIM- ECIMB
            I30  = I29    + NO2      !-CIM- TXA(NOA,NOA)
            I31  = I30    + NO2      !-CIM- TXB(NOB,NOB)
            I32  = I31    + NO2      !-CIM- EKA(NOA,NOA)
            LAST = I32    + NO2      !-CIM- EKB(NOB,NOB)
         ELSE
            LAST = I26    + (KMICRO+1)     ! IPVT
         END IF
         NEED=LAST-LOADFM-1
      else if (scftyp.eq.'ROHF    ' .and. cctyp.eq.'CR-CCL  ') then ! ROHF CR-CC(2,3)
C        memgms = 6*no3u+10*no2u2+6*nou3 
C        memgms = memgms + 8*nou+3*nu3+5*no2+5*nu2+4*nou2+4*no2u+no4
C        if (nc.ne.0) memgms = memgms + no4+2*no+2*no2+2*nu3*nc
C        NEED = memgms
         I1  = LOADFM + 1
         I2   = I1     + NOU       ! O1AA
         I3   = I2     + NOU       ! O1BB
         I4   = I3     + NO2U2     ! L2AA
         I5   = I4     + NO2U2     ! L2BB
         I6   = I5     + NO2U2     ! L2AB
         I7   = I6     + NO2U2     ! O2
         I8   = I7     + NO2U2     ! O2AA
         I9   = I8     + NO2U2     ! O2BB
         I10  = I9     + NO2U2     ! O2AB
         I11  = I10    + NOU3      ! VEAA
         I12  = I11    + NOU3      ! VEBB
         I13  = I12    + NOU3      ! VEAB
         I14  = I13    + NOU3      ! VEBA
         I15  = I14    + NOU3      ! VEAB21
         I16  = I15    + NOU3      ! VEBA21
         I17  = I16    + NOU       ! FHPAA
         I18  = I17    + NOU       ! FHPBB
         I19  = I18    + NO2U2     ! VHPRAA
         I20  = I19    + NO2U2     ! VHPRBB
         I21  = I20    + NU3       ! M3
         I22  = I21    + NU3       ! L3
         I23  = I22    + NO2U2     ! VHPRAB
         I24  = I23    + NU3       ! TI
         I25  = I24    + NO3U      ! VMAB
         I26  = I25    + NO3U      ! VMBA
         I27  = I26    + NO3U      ! VMAA
         I28  = I27    + NO3U      ! VMBB
         I29  = I28    + NO3U      ! VMAB21
         I30  = I29    + NO3U      ! VMBA21
         I31  = I30    + NO2       ! FHHA
         I32  = I31    + NO2       ! FHHB
         I33  = I32    + NU2       ! FPPA
         I34  = I33    + NU2       ! FPPB
         I35  = I34    + NO2       ! X1AA
         I36  = I35    + NO2       ! X1BB
         I37  = I36    + NO2       ! X1AB
         I38  = I37    + NU2       ! X2AA
         I39  = I38    + NU2       ! X2BB
         I40  = I39    + NU2       ! X2AB
         I41  = I40    + NOU       ! X3AA
         I42  = I41    + NOU       ! X3BB
         I43  = I42    + NOU       ! X3AB
         I44  = I43    + NOU       ! X3BA
         I45  = I44    + NOU2      ! X4AAA
         I46  = I45    + NOU2      ! X4AAB
         I47  = I46    + NOU2      ! X4BBA
         I48  = I47    + NOU2      ! X4BBB
         I49  = I48    + NO2U      ! X5AAA
         I50  = I49    + NO2U      ! X5AAB
         I51  = I50    + NO2U      ! X5BBA
         I52  = I51    + NO2U      ! X5BBB
         IF (ICIM.EQ.2) THEN
            I53  = I52    + NO4       !-CIM- VHHHH
            I54  = I53    + NOC       !-CIM- ECIMA
            I55  = I54    + NOC       !-CIM- ECIMB
            I56  = I55    + NOC*NOC   !-CIM- TXA
            I57  = I56    + NOC*NOC   !-CIM- TXB
            I58  = I57    + NCU3s     !-CIM- XXM3
            I59  = I58    + NCU3s     !-CIM- XXL3
            LAST = I59    + NC        !-CIM- TXs
         ELSE
            LAST = I52    + NO4       ! VHHHH
         END IF
         NEED=LAST-LOADFM-1
      end if
C
      memgms = NEED
      return
C
      end
C
C
C --- Print help infomation of this MP2 program ---
      subroutine cimi_help(io)
      implicit none
      integer io,i,j

      write(io,9000)
      write(io,9011)
 9000 FORMAT(/3X,27(1H-)/
     *        3X,'CLUSTER-IN-MOLECULE PROGRAM'/3X,27(1H-)//
     *        3X,31(1H-)/
     *        3X,'W.LI, P.PIECUCH, J.R.GOUR, S.LI'/
     *        3X,31(1H-))
 9011 FORMAT(/1X,65(1H*)/
     *        1X,'THE FOLLOWING PAPERS SHOULD BE CITED WHEN USING'/
     *        1X,'CLUSTER-IN-MOLECULE OPTIONS:'//
     *        1X,'DUAL-ENVIRONMENT CIM (CIMTYP=DECIM)'/
     *        1X,'W. LI, P. PIECUCH, J.R. GOUR, AND S. LI,'/
     *        1X,'  J. CHEM. PHYS. 131, 114109-1 - 114109-30 (2009).'/
     *        1X,'[SEE, ALSO, S. LI, J. SHEN, W. LI, AND  Y. JIANG, J.'/
     *        1X,'  CHEM. PHYS. 125,  074109-1 - 074109-10 (2006)]'//
     *        1X,'SINGLE-ENVIRONMENT CIM (CIMTYP=SECIM,GSECIM)'/
     *        1X,'W. LI, P. PIECUCH, J.R. GOUR, AND S. LI,'/
     *        1X,'  J. CHEM. PHYS. 131, 114109-1 - 114109-30 (2009);'/
     *        1X,'W. LI AND P. PIECUCH, J. PHYS. CHEM. A',
     *        1X,'114, 8644-8657 (2010).'//
     *        1X,'IN ADDITION, THE USE OF MULTI-LEVEL CIM SHOULD',
     *        1X,'REFERENCE'/
     *        1X,'W. LI AND P. PIECUCH, J. PHYS. CHEM. A',
     *        1X,'114, 6721-6727 (2010).'/
     *        1X,65(1H*)/)
C
      if (io>0) return
C
      write(io,66)'-- USAGE --'
      write(io,66)' cimi [arguments] file'
C     write(io,66)'   file is GAMESS input file with addition inputs:'
C     write(io,66)'   1. Add ''ICIM=1'' in the $CONTRL group'
C     write(io,66)'   2. Define parameters (see PARAMETERS for details)'
C    &          //' in the line next to $DATA'
      write(io,66)
      write(io,66)'-- ARGUMENTS --'
      write(io,66)' -h or --help: Print Help (this message) and exit'
C     write(io,66)' -core: Include core obitals correlation energy'
C     write(io,66)
C     write(io,66)'-- PARAMETERS --:'
C     write(io,66)' Format: # [PARA=<value> ...]'
C     write(io,66)' Default: Zeta=(0.003,1.0) dis=4.0 iconv=6'
C    &         // ' motyp=1 mlk=0.15'
C     write(io,'(2x,62("-"))')
C     write(io,66)' Zeta=(z1,z2) --'
C     write(io,66)'  z1: Fock value for selecting environmental LMOs'
C     write(io,66)'     (For DECIM, z1 is for 1st environmental LMOs)'
C     write(io,66)'  z2: Fock value for 2nd environmental LMOs of DECIM'
C     write(io,66)'     (For SECIM, set z2>=1 or use Zeta=(z1) only)'
C     write(io,66)' dis: Distance for buffer atoms in extend subsystems'
C     write(io,66)' iconv: convergence for CC in subsystems(10^{-conv})'
C     write(io,66)' motyp=1 ext.MO: non-orth; subsys.MO: non-orth'
C     write(io,66)' motyp=2 ext.MO: orth; subsys.MO: non-orth'
C     write(io,66)' motyp=3 ext.MO: orth; subsys.MO: non-orth for unocc'
C     write(io,66)' motyp=4 ext.MO: orth; subsys.MO: orth'
C     write(io,66)' motyp=11 use orth ext.MOs within subsystems'
C     write(io,66)' mlk: Mulliken pop for ATOMs <--> MOs assignments'
C     write(io,66)' lmo: use LMOs for subsys calc. (Default: QCMO)'
C     write(io,66)' local: Boys localization in CIM (default in GAMESS)'
C     write(io,66)' domain=keep: no merge for small subsystems'
C     write(io,66)' maxno=k: limit the max Occ LMOs as k in subsystems'
C     write(io,66)' unsort: do not sort the LMOs (Default: sort)'
C     write(io,66)' rohf: use rohf for closed shell subsystems'
C     write(io,66)'   Default: use rhf for closed shell subsystems'
C     write(io,66)' molev: read MO levels from test.dat'
C     write(io,66)'   Default: def.ATOM levels in test.inp: X Y Z TYPE'
C     write(io,66)'   Available TYPE: mp2, ccsd, cr-ccl or cr-cc(2,3)'
C     write(io,66)' mlmerg: merge small High-L-sys into large Low-L-sys'
C     write(io,66)'   Default: keep small High-L-sys for saving time'
C     write(io,66)' readclu: read domain from .dmn file'
C     write(io,66)' readclu=2: read Occ domain from .dmn file'
C     write(io,66)' efock: use relative effective fock for environment'
C     write(io,66)' efock=2: use effective fock for environment'
C     write(io,'(2x,62("-"))')
      write(io,66)
      if (io==0) stop 
 66   format(1x,a)
      end
C
c     if iau=0 in angstrom; else in a.u.
c
      subroutine DATAREAD(io,inp,NAT,IAN,C,NCBS,CBAS,iau)
      implicit none
      double precision ZERO
      parameter (ZERO=0.0D+00)
      integer io,inp,NAT,i,j,k,elemord,iau,nh
      double precision C(3,NAT),x,y,z,zz
      character aa*2,elemsyl*2,line*100,aaa*10
      integer NCBS(NAT),IAN(NAT)
      character(len=100) CBAS(100,NAT)
      external elemord,elemsyl

      do i=1,NAT
C        do j=1,3
C        C(1,j) = ZERO
C        enddo
C        ZAN = ZERO
         do j=1,100
            CBAS=' '
         enddo
      enddo
         
      rewind(inp)
      i=0; nh=0
      do
         read(inp,'(a)',end=999) line
         read(line,*,err=100,end=100) aaa,zz,x,y,z
c        k=ichar(aa(1:1))
c        if (k<65.or.(k>90.and.k<97).or.k>122) cycle
c        k=ichar(aa(2:2))
c        if (k.ne.32.and.(k<65.or.(k>90.and.k<97).or.k>122)) cycle
c        if (elemord(aa).eq.0) cycle
c        if (aa=='H'.or.aa=='h') nh=nh+1
         i=i+1
         if (IAN(i).eq.1) nh=nh+1
c        ZAN(i)=zz
c        C(1,i)=x
c        C(2,i)=y
c        C(3,i)=z
C
C ---    FOR READING BASIS FOR EACH ATOMS
         j=0
         do
            read(inp,'(a)',end=999) line
            if (line.eq.'        ') goto 99
            j=j+1
            CBAS(j,i)=line
         enddo
C
  99     NCBS(i)=j
         if (i>=NAT) exit
 100     continue
      enddo


 500  if (io>0) then
         if (iau==0) then
            write(io,*) 'Table: Cartesian Coordinates in angstrom'
         else
            write(io,*) 'Table: Cartesian Coordinates in a.u.'
         endif
         write(io,'(1x,54(''=''))')
         write(io,*) ' Atom           X               Y               Z'
         write(io,'(1x,54(''-''))')
         do i=1,NAT
            write(io,'(2x,a2,2x,3f16.8)') elemsyl(IAN(i)),
     &        (C(j,i),j=1,3)
C           do j=1,NCBS(i)
C              write(io,'(a)') trim(CBAS(j,i))
C           enddo
C           write(io,'(a8)') '        '
         enddo
         write(io,'(1x,54(''=''))')
         write(io,'(''  N<atoms> (all, non-H and H) are'',3i6)') 
     &        NAT,NAT-nh,nh
         write(io,*)
      endif
!     write(77,*)
      return

 999  stop 'GMSXYZ2(): Not enough coordinates in files'
      end
C
C --- Read integer value from name = value in line ---
      subroutine IVALU(line,name,value)
      implicit none
      character line*(*),name*(*),ch
      integer value
      integer i,j,k,L,k1,k2,L1,L2
C
      L=index(line,name)
      L1=len(line)
      L2=len(name)
      if (L.eq.0) return
      ch=line(L-1:L-1)
      if (L.gt.1 .and. ch.ne.' ') return
      ch=line(L+L2:L+L2)
      if (ch.ne.' ' .and. ch.ne.'=') return
C
      k=index(line(L:L1),'=')+L
      do i=k,L1
         if (line(i:i).ne.' ') then
            k1=i
            exit
         endif
      enddo
C
      do i=k1,L1
         if (line(i:i).eq.' ') then
            k2=i-1
            exit
         endif
      enddo
C
      read(line(k1:k2),*) value
      end

C --- Read read(kind=8) value from name = value in line ---
      subroutine RVALU(line,name,value)
      implicit none
      character line*(*),name*(*),ch
      double precision value
      integer i,j,k,L,k1,k2,L1,L2
C
      L=index(line,name)
      L1=len(line)
      L2=len(name)
      if (L.eq.0) return
      ch=line(L-1:L-1)
      if (L.gt.1 .and. ch.ne.' ') return
      ch=line(L+L2:L+L2)
      if (ch.ne.' ' .and. ch.ne.'=') return
C
      k=index(line(L:L1),'=')+L
      do i=k,L1
         if (line(i:i).ne.' ') then
            k1=i
            exit
         endif
      enddo
C
      do i=k1,L1
         if (line(i:i).eq.' ') then
            k2=i-1
            exit
         endif
      enddo
C
      read(line(k1:k2),*) value
      end

C --- Read character(len=8) value from name = value in line ---
      subroutine CVALU(line,name,value)
      implicit none
      character line*(*),name*(*),ch
      character(len=8) value
      integer i,j,k,L,k1,k2,L1,L2
C
      L=index(line,name)
      L1=len(line)
      L2=len(name)
      if (L.eq.0) return
      ch=line(L-1:L-1)
      if (L.gt.1 .and. ch.ne.' ') return
      ch=line(L+L2:L+L2)
      if (ch.ne.' ' .and. ch.ne.'=') return
C
      k=index(line(L:L1),'=')+L
      do i=k,L1
         if (line(i:i).ne.' ') then
            k1=i
            exit
         endif
      enddo
C
      do i=k1,L1
         if (line(i:i).eq.' ') then
            k2=i-1
            exit
         endif
      enddo
C
      read(line(k1:k2),*) value
      end

C --- Read logical value from name = value in line ---
      subroutine LVALU(line,name,value)
      implicit none
      character line*(*),name*(*),ch
      logical value
      integer i,j,k,L,k1,k2,L1,L2
C
      L=index(line,name)
      L1=len(line)
      L2=len(name)
      if (L.eq.0) return
      ch=line(L-1:L-1)
      if (L.gt.1 .and. ch.ne.' ') return
      ch=line(L+L2:L+L2)
      if (ch.ne.' ' .and. ch.ne.'=') return
C
      k=index(line(L:L1),'=')+L
      do i=k,L1
         if (line(i:i).ne.' ') then
            k1=i
            exit
         endif
      enddo
C
      do i=k1,L1
         if (line(i:i).eq.' ') then
            k2=i-1
            exit
         endif
      enddo
C
      read(line(k1:k2),*) value
      end
C
C --- 19 AUG 10 --- READING INFORMATION FROM .CIM FILE
      SUBROUTINE CIMREAD(io,inp,GROUP,IWORK,RWORK,CWORK,LWORK)
      implicit none
      integer io,inp,i,j,k,L,m,n
      integer IWORK(100)
      double precision RWORK(100)
      character(len=8) CWORK(100),GROUP
      logical(kind=8) LWORK(100)
      character(len=200) line
C
      do
         read(inp,'(a)',end=100,err=100) line
         call NJ_upper(line)
         L=index(line,'$'//trim(GROUP))
         if (L.ne.0) goto 100
      enddo
 100  continue
      do
         read(inp,'(a)',end=200,err=200) line
         call NJ_upper(line)
         L=index(line,'$END')
         if (L.ne.0) goto 200
C
         if (GROUP.EQ.'CIMINP  ') then
            call RVALU(line, 'ZETA1',   RWORK(1))
            call RVALU(line, 'ZETA2',   RWORK(2))
            call RVALU(line, 'ZETA',    RWORK(3))
            call RVALU(line, 'ETA',     RWORK(4))
            call RVALU(line, 'BUFDST',  RWORK(5))
            call RVALU(line, 'CCONV',   RWORK(6))
            call RVALU(line, 'ATMMLK',  RWORK(7))
C
            call IVALU(line, 'MOFIX',  IWORK(7))
            call IVALU(line, 'MRGSUB',  IWORK(15))
            if (IWORK(15).eq.0) then
               LWORK(1) = .false.
               LWORK(2) = .false.
            elseif (IWORK(15).eq.1) then
               LWORK(1) = .true.
               LWORK(2) = .false.
            elseif (IWORK(15).eq.2) then
               LWORK(1) = .true.
               LWORK(2) = .true.
            endif
C           call LVALU(line, 'SUBMRG',  LWORK(1))
C           call LVALU(line, 'MERGML',  LWORK(2))
            call LVALU(line, 'MOSORT',  LWORK(3))
            call LVALU(line, 'ORTHO',   LWORK(4))
            call LVALU(line, 'SUBRHF',  LWORK(5))
            call LVALU(line, 'FCORE ',  LWORK(6))
C
            call CVALU(line, 'CIMTYP',  CWORK(1))
            call CVALU(line, 'SUBMTD',  CWORK(2))
            call CVALU(line, 'SUBTYP',  CWORK(3))
            call CVALU(line, 'ENRGML',  CWORK(4))
         else if (GROUP.EQ.'INFO    ') then
            call IVALU(line, 'NAT',     IWORK(51))
            call IVALU(line, 'ICH',     IWORK(52))
            call IVALU(line, 'MUL',     IWORK(53))
            call IVALU(line, 'NE',      IWORK(54))
            call IVALU(line, 'NA',      IWORK(55))
            call IVALU(line, 'NB',      IWORK(56))
            call IVALU(line, 'NUM',     IWORK(57))
            call IVALU(line, 'NMO',     IWORK(58))
            call IVALU(line, 'NSHELL',  IWORK(59))
            call IVALU(line, 'NGAUSS',  IWORK(60))
C
            call RVALU(line, 'ENUCR',   RWORK(51))
            call IVALU(line, 'ISPHER',  IWORK(61))
         else if (GROUP.EQ.'ENERGY  ') then
            call RVALU(line, 'E(RHF)',  RWORK(52))
            call RVALU(line, 'E(UHF)',  RWORK(52))
            call RVALU(line, 'E(ROHF)', RWORK(52))
            if (index(line,'RHF') .ne.0) CWORK(51)='RHF     '
            if (index(line,'UHF') .ne.0) CWORK(51)='UHF     '
            if (index(line,'ROHF').ne.0) CWORK(51)='ROHF    '
         endif
C
      enddo
 200  continue
C
      return
      end

C
C-WL- 2007.10.23 define parameters from XWORK (X=I,R,C,L)
      subroutine GMSPAR2(io,nwords,scftyp,mplevl,cctyp,
     &           IWORK,RWORK,CWORK,LWORK)
      implicit double precision(A-H,O-Z)
      character line*200,scftyp*8,cctyp*8,dirtyp*8,ch
      logical dirscf
      character kgms*4,key3*3,key4*4,key5*5,key6*6
C
      integer IWORK(100)
      double precision RWORK(100)
      character(len=8) CWORK(100)
      logical(kind=8) LWORK(100)
C
      ch='='
C
C-WL- define default Memory
      mwords=50
      nwords=mwords*1024*1024   ! 2010.06.07 1000*1000 --> 1024*1024 by Wei Li
C
      if (CWORK(2).eq.'NONE    ') then
         mplevl = 0
         cctyp  = 'NONE    '
      elseif (CWORK(2).eq.'MP2     ') then
         mplevl = 2
         cctyp  = 'NONE    '
      else
         mplevl = 0
         cctyp  = CWORK(2)
      endif

C
C-WL- Read Zeta and dis
C     if (CWORK(1).eq.'DECIM  ') then
C        WRK(1) = RWORK(1)  ! ZETA1
C        WRK(2) = RWORK(2)  ! ZETA2
C     else
C        WRK(1) = RWORK(3)  ! ZETA
C        WRK(2) = 2.00d0
C     endif
      RWORK(8) = 0.99D+00 ! Only available for DECIM; former as WRK(3), not used now
C     WRK(4) = RWORK(4)  ! ETA
C     WRK(5) = RWORK(5)  ! BUFDST
C

      IWORK(1)=-LOG10(RWORK(6))  ! RWORK(6): cconv in $ciminp; IWORK(1): iconv in $ccinp
C

      if (LWORK(4)) then ! LWORK(4)=ORTHO
         IWORK(2) = 4  ! We lose IWORK(2)=2,3,11, which we do not use usually. So that is fine
      else
         IWORK(2) = 1
      endif
      IWORK(3) = 5    ! useless
      IWORK(4) = 1000 ! maxno
      if (LWORK(3)) then  ! MOSORT
         IWORK(5) = 0 ! sort
      else
         IWORK(5) = 1 ! unsort
      endif
      IWORK(6) = 0 ! ISymm 1 for symmetry
C     WRK(7) = RWORK(7) ! ATMMLK
      RWORK(9) = 1.0d-6   ! symm 2008.03.03 for threshold of symmetry WRK(9)
C     IWORK(7) = 0  ! 1 for reading clusters; 2 for reading occ MOs in clusters only
      if (CWORK(3).eq.'QCMO    ') then ! SUBTYP
         IWORK(8) = 0
      else
         IWORK(8) = 1  ! LMO
      endif
      IWORK(9) = 0  ! MOLEV 1 for reading MO Level from .cim (former .dat)
C     SUBMRG=LWORK(1); MERGML=LWORK(2)
      if (IWORK(15).eq.1) then ! (LWORK(1) .and. .not.LWORK(2)) then
         IWORK(10) = 0 ! MLMERG=F
         IWORK(13) = 0 ! DOMAIN NOT KEPT
      elseif (IWORK(15).eq.2) then ! (LWORK(1) .and. LWORK(2)) then
         IWORK(10) = 1 ! MLMERG
         IWORK(13) = 0 ! DOMAIN NOT KEPT
      elseif (IWORK(15).eq.0) then ! (.not.LWORK(1) .and. .not.LWORK(2)) then
         IWORK(10) = 0 ! MLMERG=F
         IWORK(13) = 1 ! DOMAIN=KEEP
      endif
      IWORK(11)=1  ! LOCAL: always use boys localization in cimi
      IWORK(12)=0  ! EFOCK: 1 or 2 for  using effective Fock to select LMOs
      if (LWORK(5)) then  ! SUBRHF
         IWORK(14) = 0
      else
         IWORK(14) = 1  ! ROHF for closed subsystems in ROHF calculations
      endif
C
C-WL- Output
      if (io.gt.0) then
         write(io,110) mwords
         write(io,120) scftyp,mplevl,cctyp,dirscf
         write(io,130) (RWORK(k),k=1,4)
         write(io,140) RWORK(5),IWORK(1),IWORK(2),RWORK(9)
         write(io,160) IWORK(4)
         if (IWORK(2).eq.1) then
            write(io,*) 'EXT. MO: non-orth; SUBSYS. MO: non-orth'
         else if (IWORK(2).eq.2) then
            write(io,*) 'EXT. MO: orth; SUBSYS. MO: non-orth'
         else if (IWORK(2).eq.3) then
            write(io,*)'EXT. MO: orth; SUBSYS. MO: non-orth unocc (302)'
         else if (IWORK(2).eq.4) then
            write(io,*) 'EXT. MO: orth; SUBSYS. MO: orth (322)'
         else if (IWORK(2).eq.5) then
            write(io,*) 'EXT. MO: orth; SUBSYS. MO: orth (111)'
         else if (IWORK(2).eq.6) then
            write(io,*) 'EXT. MO: orth; SUBSYS. MO: orth (112)'
         else if (IWORK(2).eq.11) then
            write(io,*) 'Use orth EXT. MOs within subsystems'
         else if (IWORK(2).eq.12) then
            write(io,*) 'Use un-orth EXT. MOs within subsystems'
         else
            write(io,*) 'ERR: motyp=1-6,11 are available!'
            stop
         endif
         if (IWORK(7).ne.0) then
            write(io,*)'Using fix domain method:'
     &               //' read occupied LMOs from .dmn file'
            if (IWORK(7).eq.1) then
               write(io,*)'Recalculate the number of unoccupied LMOs'
            else
               write(io,*)'Read the number of unoccupied LMOs from .dmn'
            endif
         endif
         if (IWORK(5).eq.0) write(io,*)'--- Sort LMOs ---'
         if (IWORK(6).ne.0) write(io,*)'--- Use MO symmetry ---'
         if (IWORK(8).eq.0) then
            write(io,*) '--- Use QCMO in subsystems ---'
         else
            write(io,*) '--- Use LMO in subsystems ---'
C           if (cctyp.ne.'CCSD    ') then
C              write(io,*) 'LMO based CIM is only available for CCSD'
C              stop
C           endif
         endif
         if (IWORK(9).ne.0) then
            write(io,*) '--- Read MO-LEVEL from .dat ---'
         endif
         if (IWORK(10).ne.0) then
            write(io,'(1x,a)') '--- Merge small High-L-sys into'
     &                //' large Low-L-sys ---'
         endif
         if (IWORK(11).ne.0) then
            write(io,'(1x,a)') '--- Use localization in CIM program ---'
         endif
         if (IWORK(12).ne.0) then
           write(io,'(1x,a)')'--- Use effective Fock to select LMOs ---'
         endif
C        write(io,*) 'The Mulliken population threshold:',RWORK(7)
         write(io,*) 'Group the MOs near each atoms as central MOs '
     &             //'by Mulliken pop >',RWORK(7)
         write(io,*) RWORK(7),' is used for selecting atoms for LMOs'
      endif
C
 110  format(1x,'Defined memory =',i6,' Mega words')
 120  format(1x,'SCFTYP,MPLEVL,CCTYP,DIRSCF = ',A8,i2,3x,A8,3x,L8)
 130  format(1x,'ZT1,ZT2,ZT3,ZT4=',4f10.5)
 140  format(1x,'DIS=',f10.5,6x,'CC Conv=',i4,6x,'MOTYP=',i2,6x,
     &      'SYMM=',d12.4)
 150  format(1x,'MAXFRG=',i5)
 160  format(1x,'The max number of correlated occ MOs are set as',i5)
      end
c
C*MODULE CIMI  *DECK VCCLR
      SUBROUTINE VCCLR(CA,INCA,N)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      CHARACTER*8 CA(*)
C
C     ----- ZERO OUT AN INTEGER VECTOR -A-, USING INCREMENT -INCA- -----
C
      IF (INCA .NE. 1) GO TO 200
      DO 110 L=1,N
         CA(L) = '        '
  110 CONTINUE
      RETURN
C
  200 CONTINUE
      LA=1-INCA
      DO 210 L=1,N
         LA=LA+INCA
         CA(LA) = '        '
  210 CONTINUE
      RETURN
      END
C
C*MODULE CIMI  *DECK VCASGN
      SUBROUTINE VCASGN(CA,INCA,N,VALU)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      CHARACTER*8 CA(*),VALU
C
C     ----- ZERO OUT AN INTEGER VECTOR -A-, USING INCREMENT -INCA- -----
C
      IF (INCA .NE. 1) GO TO 200
      DO 110 L=1,N
         CA(L) = VALU
  110 CONTINUE
      RETURN
C
  200 CONTINUE
      LA=1-INCA
      DO 210 L=1,N
         LA=LA+INCA
         CA(LA) = VALU
  210 CONTINUE
      RETURN
      END
C*MODULE CIMI  *DECK TIMSTP
      SUBROUTINE TIMSTP(METHOD)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      CHARACTER*8 METHOD
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /TMVALS/ TI,TX,TIM
C     COMMON /TIMING/ CPU,WALL
      COMMON /CIMINF/ ICIM,ICIF,MOTYP,NCA,NCB  !-CIM-
C
      TXMIN = TX !/60.0D+00
      IF(MASWRK) THEN
         IF(GOPARR) THEN
            WRITE(ICIF,9010) ME,METHOD,TXMIN
         ELSE
            WRITE(ICIF,9000) METHOD,TXMIN
         END IF
      END IF
      CALL FLSHBF(ICIF)
      RETURN
C
 9000 FORMAT(1X,'STEP CPU TIME FOR ',A8,' =',F9.2,' SEC')
 9010 FORMAT(1X,'CPU',I6,': STEP CPU TIME FOR ',A8,' =',F9.2,' SEC')
      END
C*MODULE CIMI  *DECK TIMCIM
      SUBROUTINE TIMCIM(T0,NOTES)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      CHARACTER*12 NOTES
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /CIMINF/ ICIM,ICIF,MOTYP,NCA,NCB  !-CIM-
C
      CALL TSECND(TT)
      TY = TT - T0
      TYMIN = TY !/60.0D+00
      IF(MASWRK) THEN
         IF(GOPARR) THEN
            WRITE(ICIF,9010) ME,NOTES,TYMIN
         ELSE
            WRITE(ICIF,9000) NOTES,TYMIN
         END IF
      END IF
      CALL FLSHBF(ICIF)
      RETURN
C
 9000 FORMAT(1X,'TOTAL CPU TIME FOR ',A12,' =',F9.2,' SEC')
 9010 FORMAT(1X,'CPU',I6,': TOTAL CPU TIME FOR ',A12,' =',F9.2,' SEC')
      END
