C 27 Jan 14 - MWS - deal with ***'s in timing fields when totalling up.
C 18 Feb 13 - MWS - comment out unused SORT2, which conflicts w/TINKER.
C  6 Feb 13 - MWS - CIMCALC,MEMGMS: attend to Cray, HP-UX, AXP warnings
C
* -----------------------------------------------------
* SEE HELP FOR CIMI BY USING "cimi -h" or "cimi --help"
* -----------------------------------------------------
*     Aug 15, 2010 cimi-0.04 fixed MPI processors and restrained LMO CIM for CCSD only
*     Aug 14, 2010 cimi-0.03 updated the memory for RHF/ROHF CCSD and CR-CCL and RHF CCSD(T)
*     Aug 11, 2010 cimi-0.02 cimlib.o compiled from cimlib.src is required
*     Aug 10, 2010 cimi-0.01 based on cimi_2010.07.02.for
*
* --- Since Aug 10, 2010 x.xx as version number and cimi linked to cimi-x.xx ---
*
* --- LIST OF FILE UNITS [formatted] ---
*     inp [inname]:   GAUSSIAN input file exam.gjf (needed as input file)
*     io [outname]:   LSCIM general output file exam.out
*     igms [gmsname]: GAMESS general output file exam.gms
*
* --- LIST OF FILE UNITS [unformatted] ---
*     cim [cimname]:  GAMESS output file for informations and one-elec integrals exam.cim
*     itmp [tmpname]: LSCIM Temporirary file for integrals transformation exam.tmp
*
* --- LIST OF VARIABLES FOR TOTAL MOLECULE  [integer] ---
*     NATOM:  Number of atoms
*     NW:     Number of basis functions
*     Nmo:    Number of all MOs (e.g. Number of independant functions, Nmo.le.NW)
*     NUW:    Number of occupied MOs
*     icha:   Number of charges
*     mult:   Multiplicity
*     nel:    Number of electrons
*     k_alph: Number of alpha electrons
*     k_beta: Number of beta electrons
*     nsh:    Number of contracted shells',nsh,k)
*     npr:    Number of primitive shells',npr,k)
*     tbs(NW):       Atomic label for basis
*
* --- LIST OF VARIABLES FOR TOTAL MOLECULE  [double precision] ---
*     NN:     Nuclear Repulsion Energy',NN,k)
*     ETOT:   Total MP2 correlation energy
*     nuchar(NATOM): Nuclear charges
*     coor(3,NATOM): Cartesian coordinates
*     EIGEN(Nmo):    Alpha MOs eigenvalues
*     SMO(Nmo,Nmo):  Alpha MOs coefficients
*     SOVER(NW,NW):  AO overlap matrix
*     HCORE(NW,NW):  AO core-Hamiltonian matrix
*     FK(Nmo,Nmo):   AO Fock matrix
*     FIJ(NUW,NUW):  MO Fock matrix  ! 2008.07.25 Nmo --> NUW
*     admx(NW,NW):   AO dipole moment integrals in X-direct
*     admy(NW,NW):   AO dipole moment integrals in Y-direct
*     admz(NW,NW):   AO dipole moment integrals in Z-direct
*     mdmx(Nmo,Nmo): MO dipole moment integrals in X-direct
*     mdmy(Nmo,Nmo): MO dipole moment integrals in Y-direct
*     mdmz(Nmo,Nmo): MO dipole moment integrals in Z-direct
*
* --- LIST OF LSCIM PARAMETERS FOR CALCULATION [integer] ---
*     nfocc:  Number of frozen occupied MOs (default: nfocc=0)
*     nfvir:  Number of frozen virtual MOs (default: nfvir=0, nfvir must be 0 for CIM)
*     np:     Number of threads of OpenMP parellel (not available now)
*     kmem:   Maximum memory for integrals transformation (unit: Words, e.g. 8 Bytes)
*     nprint: Level of printing in localization
*             nprint=0 ~ Print information at each ten of cycles without final LMOs
*             nprint=1 ~ Print final LMOs other than nprint=0
*     maxcyc: Maximum cycles of localization (default: maxcyc=10000)
*     conv:   Convergence threshold of iterative MP2 (default: conv=6)   ! 2007.10.17.conv=6 --> =7
*     eps:    Threshold of the convergance in localization (default: eps=1d-7)
*     epst:   Threshold of the selected rotation in localization (default: eps=1d-13)
*
      subroutine CIMI(nsubsystems)
      implicit none

      integer MXSH,MXGTOT,MXATM,MAXSH,MXRT,MXAO
      double precision ONE,TWO,zero,UNITS
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000, MAXSH=84,
     *           ONE = 1.0D0,MXRT=100,MXAO=8192,zero=0.0d0,
     *           UNITS = ONE/0.52917724924D+00,
     *           TWO=2.D0)
      COMMON /IOFILE/ IR2,Io,IP2,IS2,IPK2,IDAF2,NAV2,IODA2(950)
      COMMON /CIMINF/ ICIM2,inp,MOTYP2,NCA2,NCB2  !-CIM-
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      integer icim2,ir2,ip2,is2,ipk2,idaf2,nav2,ioda2,nca2,ncb2
      integer motyp2
      integer nsubsystems
      integer NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,IAN
      double precision ZAN,C
C
      integer inp,io,igms,itmp,isys,job
C     parameter (inp=12,io=11,igms=14)
      parameter (igms=14)
      parameter (itmp=18,isys=24,job=25)
C
      integer i,j,k,l,m,n,i1,i2,i3,i4,j1,j2,j3,j4,k1,k2,k3,k4,ii,jj,kk
      integer NW,NUW,NATOM,nsh,npr,L2,nprint,maxcyc,kerr,nprtcyc
      integer Nmo,k_alph,k_beta,ierr,nfocc,nfvir,np,jerr
      integer ini,ifi,icha,mult,kmem,level,nel,imethd,icore
      integer mplevl,istop,k5,k6,k7,k8
      character*8 scftyp,cctyp
      logical dirscf
C
      integer,dimension(:),allocatable::tbs,atmlevl,atmgrp
      integer,dimension(:,:),allocatable::link
C
      double precision,dimension(:),allocatable::EIGEN
      double precision,dimension(:),allocatable::nuchar,dtmp
      double precision,dimension(:,:),allocatable::SOVER,HCORE,DM,PS
      double precision,dimension(:,:),allocatable::SMO,FIJ,FK,coor,FKB
      double precision,dimension(:,:),allocatable::mdmx,mdmy,mdmz,runit
      double precision,dimension(:,:),allocatable::admx,admy,admz,dis

      double precision ETOT,NN,eps,epst,EHF
C
      integer IWORK(100)
      double precision RWORK(100)
      character(len=8) CWORK(100)
      logical LWORK(100)
C
      character addi*100,mem*20,mthd*20,basis*30,nproc*4,runtyp*20
      character command*256,line*100,line2*256,lsqcln*1024,gver*3
      character key18*18,sls,suffix*10,line3*256,line4*256
      character(len=100) inname,outname,gmsname,tmpname
      character(len=100) logname
      character(len=100) sysname,jobname,snfname,pfxname
      character(len=100) cimname
      character(len=200) path
      character(len=50)  user
      integer system
      integer (kind=4) Wall0,Wall,TIME
      double precision trace,dtrace2   !,coor(3,NATOM),nuchar(NATOM)
      real*8 Tim0,CPUTim
      external dtrace2,CPUTim !,system,TIME   ! Add TIME in external 2006.02.06
      integer numcor
      external numcor
      logical exst
C
      integer marg
      parameter (marg=20)
      integer narg,typarg(0:marg)
      character*100 arg(0:marg)
C
      integer NOA,NOB,NCMO
C --- 18 AUG 10
      integer,dimension(:),allocatable::NCBS
      character(len=100),dimension(:,:),allocatable::CBAS
      character(len=8),dimension(:),allocatable::CIMATM
C
C --- Tim0: Initial CPU time; Wall0: Initial WALL time
      nsubsystems=0
      Tim0=CPUTim(0)
C     Wall0=TIME()
      sls=char(47)   ! sls='/'
C
C --- Read strings after command "ecmfc.x" and online help
C     call NJ_cmdline(narg,arg,typarg)
C     call NJ_help(narg,arg,typarg,ierr)
C     if (ierr.ge.0) call cimi_help(0)
C
C --- Define used file name based on input file
C     call LS_infile(narg,arg,typarg,inname,suffix)
C     if (suffix.ne.'cim       ') inname=trim(inname)//'.cim'
C     call NJ_trim(inname,k1,k2)
C     pfxname=inname(k1:k2-4)
C     call NJ_outfile(narg,arg,typarg,inname,'o','out',outname)
C     call NJ_outfile(narg,arg,typarg,inname,' ','inp',gmsname)
C     call NJ_outfile(narg,arg,typarg,inname,' ','tmp',tmpname)
C     call NJ_outfile(narg,arg,typarg,inname,' ','log',logname)
C     call NJ_outfile(narg,arg,typarg,inname,' ','sys',sysname)
C     call NJ_outfile(narg,arg,typarg,inname,' ','job',jobname)
C     call NJ_outfile(narg,arg,typarg,inname,' ','snf',snfname)
      CALL GMS_GETENV('CIMFILE',gmsname)
C
C --- Read parameter from command line (e.g. cimi exam.gjf -level 3)
C     call NJ_argfind(narg,arg,typarg,'core',icore)
C     call NJ_argvalu(narg,arg,typarg,'stop',istop)
C     if (istop.eq.0) istop=9
C
C --- Open needed file: Gaussian input file, LSCIM output file, GAMESS input file
C     open(inp,file=inname,status='old')
C     open(io,file=outname)
C
C --- Print title, time, hostname, directory
      call cimi_help(io)
C     call NJ_date(io,'Task begin from:')
C     call NJ_sysinfo2(io,snfname,path,user)
C     write(io,'(a)') ' CIM_PATH='//trim(path)
C
C     write(io,*) 'Only add enviromental MOs once by using Zeta_1'
C     write(io,*) 'Zeta_2,Zeta_3 is useless now'
C
C     write(io,*) 'This is a cluster-in-molecule (CIM) job'
C     write(io,*) 'NOTE: get more info by '//trim(logname)//' after >&'
C     write(io,*)
      call flshbf(io)
C
C --- Old array IWK, WRK for CIM parameters were deleted

      do i=1,100
         IWORK(i) = 0
         RWORK(i) = 0.0D0
         CWORK(i) = '        '
         LWORK(i) = .false.
      enddo
      call seqrew(inp)
      call CIMREAD(io,inp,'CIMINP  ',IWORK,RWORK,CWORK,LWORK)
      call CIMREAD(io,inp,'INFO    ',IWORK,RWORK,CWORK,LWORK)
      call CIMREAD(io,inp,'INFO    ',IWORK,RWORK,CWORK,LWORK)
      call CIMREAD(io,inp,'ENERGY  ',IWORK,RWORK,CWORK,LWORK)
C
C     write(*,'(5f16.10)') (RWORK(i),i=1,7)
C     write(*,*)           (LWORK(i),i=1,5)
C     write(*,'(10a8)')    (CWORK(i),i=1,4)
C     write(*,'(10i8)')    (IWORK(i),i=51,60)
C     write(*,'(5f16.10)') (RWORK(i),i=51,52)
C     write(*,'(10a8)')    (CWORK(i),i=51,51)
C
C---  7 Apr 2009: Read infomation from .cim file
      NATOM  = IWORK(51)  ! NATOM
      icha   = IWORK(52)  ! icha
      mult   = IWORK(53)  ! mult
      nel    = IWORK(54)  ! nel
      k_alph = IWORK(55)  ! k_alph
      k_beta = IWORK(56)  ! k_beta
      NW     = IWORK(57)  ! NW
      Nmo    = IWORK(58)  ! Nmo
      nsh    = IWORK(59)  ! nsh
      npr    = IWORK(60)  ! npr
      NN     = RWORK(51)  ! NN
      EHF    = RWORK(52)  ! EHF
      scftyp = CWORK(51)  ! scftyp
      call PRTINF(io,NATOM,icha,mult,nel,k_alph,k_beta,NW,Nmo,
     &     nsh,npr,NN,scftyp,EHF)
C
      NUW=IWORK(55)  ! k_alph
      if (k_alph.ne.k_beta) then
         write(io,*) 'Open shell systems'
      else
         write(io,*) 'Closed shell systems'
      endif
      call flshbf(io)
C
C --- Read atoms info: coordinates and nuclear charges
      allocate(coor(3,NATOM),nuchar(NATOM),NCBS(NATOM),CBAS(100,NATOM))
      allocate(CIMATM(NATOM))
      do i=1,NATOM
         do j=1,3
            coor(j,i)=C(j,i)/UNITS
         enddo
         nuchar(i)=ZAN(i)
      enddo
      call DATAREAD(0,inp,NATOM,IAN,coor,NCBS,CBAS,0)
C     call CIMATOMS(io,inp,NATOM,CWORK(2),CIMATM)  ! SET CWORK(2)=SUBMTD AS DEFAULT, THEN READ $CIMATM
      DO i=1,NATOM
         CIMATM(i)=CWORK(2)
      ENDDO
      call cread(inp, '$CIMATM', NATOM, CIMATM)
C     call cwrit(io,  '$CIMATM', NATOM, CIMATM)

      if (LWORK(6)) then
         icore = 0
         write(io,*) 'Core orbitals will be frozen'
      else
         icore = 1
         write(io,*) 'Core orbitals will not be frozen'
      endif

C AAD To correctly count occupied orbitals when using ECP,
C     numcor() is the correct function to use
C     call FRZORB(io,NATOM,nuchar,nfocc,nfvir,icore)
      nfvir=0
      nfocc = numcor()
C
      call GMSPAR2(0,kmem,scftyp,mplevl,cctyp,
     &     IWORK,RWORK,CWORK,LWORK)
      allocate(atmlevl(NATOM),dis(NATOM,NATOM),link(NATOM,NATOM))
      allocate(atmgrp(NATOM))
      call NJ_dislink(0,NATOM,nuchar,coor,dis,link)
      call ATOMLEVL(0,NATOM,link,nuchar,CIMATM,atmlevl)
      deallocate(dis,link)
C
      call flshbf(io)
C
C --- Read Overlap, core Hamiltonian, Fock matrix from exam.dat
      L2=NW*(NW+1)/2
      allocate(dtmp(L2),tbs(NW))
      allocate(SOVER(NW,NW),HCORE(NW,NW),FK(NW,NW))
      allocate(SMO(NW,NW),EIGEN(Nmo),FKB(NW,NW))
C
* --- Read .cim for array information
      k=-1
      call seqrew(inp)
      call iread(inp, '$BASIS-ATOMS', NW, tbs)
      call rread(inp, '$HCORE', L2, dtmp)
      k=0
      do i=1,NW; do j=1,i
         k=k+1;  HCORE(j,i)=dtmp(k);  HCORE(i,j)=dtmp(k)
      enddo; enddo
C     write(io,*)'+++ HCORE +++'
C     call NJ_prtsym(io,NW,HCORE,'d14.6')
C
      call rread(inp, '$OVERLAP', L2, dtmp) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! LIWEI
      k=0
      do i=1,NW; do j=1,i
         k=k+1;  SOVER(j,i)=dtmp(k);  SOVER(i,j)=dtmp(k)
      enddo; enddo
C     write(io,*)'+++ SOVER +++'
C     call NJ_prtsym(io,NW,SOVER,'d14.6')
C
      if (scftyp.eq.'RHF     ') then
         call rread(inp, '$AO-FOCK', L2, dtmp)
         k=0
         do i=1,NW; do j=1,i
            k=k+1;  FK(j,i)=dtmp(k);  FK(i,j)=dtmp(k)
         enddo; enddo
         FKB=FK
C
      else
         call rread(inp, '$AO-FOCK-A', L2, dtmp)
         k=0
         do i=1,NW; do j=1,i
            k=k+1;  FK(j,i)=dtmp(k);  FK(i,j)=dtmp(k)
         enddo; enddo
C
         call rread(inp, '$AO-FOCK-B', L2, dtmp)
         k=0
         do i=1,NW; do j=1,i
            k=k+1;  FKB(j,i)=dtmp(k);  FKB(i,j)=dtmp(k)
         enddo; enddo
      endif
C
      call rread(inp, '$EIGVAL', Nmo, EIGEN)
      call rread(inp, '$VEC', NW*Nmo, SMO)
C     write(io,*)'+++ CMO +++'
C     call NJ_prtcol2(io,NW,Nmo,SMO,1,Nmo,'f11.6')
C     write(io,*)'+++ EIGEN +++'
C     write(io,'(5f11.6)') (EIGEN(i),i=1,Nmo)
C
C --- 2006.02.25 Add for Boys Localization ---
C --- Read AO Dipole Integrals and Trans them into MO Dipole Integrals
      allocate(admx(NW,NW),admy(NW,NW),admz(NW,NW))
      allocate(mdmx(Nmo,Nmo),mdmy(Nmo,Nmo),mdmz(Nmo,Nmo))
      call DipInt2(inp,NW,admx,admy,admz)
C
CC    if (IWORK(11).eq.0) call rread(inp, '$LMO-OCC', NW*NUW, SMO(1,1))
C
C     write(io,*)'+++ LMO +++'
C     call NJ_prtcol2(io,NW,Nmo,SMO,1,NUW,'f11.6')
C
C-WL- 26 AUG 2009 ADD DENSITY MATRIX AND PPS
*     allocate(DM(NW,NW),PS(NW,NW))
*     call NJ_denmat(0,NW,Nmo,NUW,SMO,DM)
*     call NJ_matpro(0,NW,NW,NW,DM,SOVER,PS)
*     trace=dtrace2(NW,PS)
*     write(io,'('' Trace of PS ='',f16.6)') trace
*     deallocate(DM,PS)
      write(io,*)
C
C --- Boys Localization ---
      if (IWORK(11).eq.1) then  !- IWORK(11)=1 for localization by CIM
         call NJ_tfock(0,NW,Nmo,admx,SMO,mdmx) ! mdmx=smo^T*adm*smo
         call NJ_tfock(0,NW,Nmo,admy,SMO,mdmy)
         call NJ_tfock(0,NW,Nmo,admz,SMO,mdmz)

         eps=1d-7; epst=1d-13; maxcyc=10000  ! 2006.06.05 eps,espt
C
C        Core orbitals
         if (nfocc.gt.1)then
            ini=1; ifi=nfocc; nprint=0
            nprtcyc=20  ! 2008.02.10 ADD
            call NJ_boyloc(io,NATOM,NW,Nmo,ini,ifi,SMO,mdmx,mdmy,mdmz,
     &           eps,epst,maxcyc,nprint,1,nprtcyc,ierr)
         endif
C
C        Occupied orbitals except core orbitals
         ini=nfocc+1; ifi=IWORK(56); nprint=0  ! NUW replaced by IWORK(56): Num of beta electrons
         nprtcyc=20  ! 2008.02.10 ADD
         call NJ_boyloc(io,NATOM,NW,Nmo,ini,ifi,SMO,mdmx,mdmy,mdmz,
     &        eps,epst,maxcyc,nprint,1,nprtcyc,ierr)
C
C        write(io,*) '+++ Localized Molecular Orbitals +++'
C        call NJ_prtcol2(io,NW,Nmo,SMO,1,NUW,'f11.6')
         write(io,*)
      endif

C --- Calc MO Fock Matrix
C     allocate(FIJ(k_beta,k_beta))  ! 2008.07.25 Nmo --> NUW
C     write(io,*) '--- Beta MO Fock Matrix ---'
C     call NJ_tfock(io,NW,k_beta,FKB,SMO,FIJ)
C     deallocate(FIJ)
      allocate(FIJ(NUW,NUW))  ! 2008.07.25 Nmo --> NUW
C     write(io,*) '--- Alpha MO Fock Matrix ---'
C     call NJ_tfock(io,NW,NUW,FK,SMO,FIJ)
C
C-WL- Here we give CIMMP2 as the name of subroutine, but it includes CIM-CCD calculations
C     sysname='w10.sys'
C     open(isys,file=sysname)
C     open(job, file=jobname)
      if(iwork(7).ne.0) then
         call seqopn(isys,'CIMDMN','OLD',.false.,'FORMATTED')
      else
         call seqopn(isys,'CIMDMN','NEW',.false.,'FORMATTED')
      endif
      CALL CIMMP2(io,inp,isys,NATOM,NW,NUW,Nmo,nfocc,nfvir,SMO,FIJ,
     &     FK,SOVER,admx,admy,admz,tbs,nuchar,coor,basis,gmsname,
     &     kmem,ETOT,scftyp,mplevl,cctyp,istop,
     &     job,k_beta,FKB,
     &     atmlevl,atmgrp,path,user,NCBS,CBAS,nsubsystems,
     &     IWORK,RWORK,CWORK,LWORK)    !-WL- 2009.09.09
C     call flshbf(job)
      call flshbf(isys)
C     close(job)
C     close(isys,status='delete')
      call seqclo(isys,'keep')
C
C     write(io,*) 'Normal Termination of CIMI Program!'
      write(io,*) "... FINISHED CONSTRUCTING CIM SUBSYSTEMS ..."
      call timit(1)
C     call NJ_date(io,'Task over on:')
C     call NJ_cputim(io,Tim0)
C     call NJ_walltim(io,Wall0)
C     call timit(1)
      call flshbf(io)
C
C --- Deallocate All Global Array
      deallocate(admx,admy,admz,mdmx,mdmy,mdmz)
      deallocate(coor,nuchar,SMO,atmlevl,atmgrp)
      deallocate(EIGEN,SOVER,HCORE,FK,FIJ,FKB)
C
      END
CMWSC
CMWSc     ##############################################################
CMWSc     ##  subroutine Calc_para - initialization of calc program   ##
CMWSc     ##  2005.10.17 by Wei Li; Update 2005.12.26 by Wei Li       ##
CMWSc     ##############################################################
CMWSc
CMWS      subroutine Calc_para(io,inp,mem,kmem,mthd,basis,nproc,addi,runtyp)
CMWS      implicit none
CMWS      character addi*100,mem*20,mthd*20,basis*30,nproc*4,runtyp*20
CMWSC
CMWS      integer inp,io,lth,i,j,k,k1,k2,k3,yes,nrw,ini,ifi,tmp,n,kmem
CMWS      character sls,line*200,ctmp*100,key3*3,key5*5,ch
CMWSC
CMWS      sls=char(47)
CMWSC     ----- From gjf -----
CMWS      key3='mem'
CMWS      call NJ_seekkey(inp,'%',key3,yes)
CMWS      if (yes.ne.0) then
CMWS         read(inp,'(a)') line
CMWS         call NJ_trim(line,k1,k2); k=index(line,'=')
CMWS         mem=line(k+1:k2)
CMWS      else
CMWS         mem='20MW'
CMWS      endif
CMWS      k=index(mem,'mw')+index(mem,'MW')
CMWS      read(mem(1:k-1),*) kmem
CMWS      kmem=kmem*1024*1024
CMWSC
CMWS      key5='nproc'
CMWS      call NJ_seekkey(inp,'%',key5,yes)
CMWS      if (yes.ne.0) then
CMWS         read(inp,'(a)') line
CMWS         call NJ_trim(line,k1,k2); k=index(line,'=')
CMWS         nproc=line(k+1:k2)
CMWS      else
CMWS         nproc='1'
CMWS      endif
CMWSC
CMWS****** read parameter after '#' ******
CMWS      ch=' '
CMWS      call NJ_seekkey(inp,'#',ch,yes); read(inp,'(a)') line
CMWS      call NJ_lower(line)
CMWS      i=index(line,'#'); line(i:i)=' '
CMWS      if (line(i+1:i+1).ne.' '.and.line(i+2:i+2)==' ') line(i+1:i+1)=' ' ! 2005.05.11 add
CMWS      call NJ_trim(line,k1,k2)
CMWS      k2=index(line(k1:200),' ')+k1-2
CMWS      k3=index(line(1:k2),sls)
CMWS      if (k3==0) then
CMWS         mthd=line(k1:k2); basis=' '
CMWS      else
CMWS         mthd=line(k1:k3-1); basis=line(k3+1:k2)
CMWS      endif
CMWSC
CMWS      addi='nosymm scf=(tight,conventional) gfinput noraff'
CMWS     &    //' extralink=l316'
CMWSC
CMWS      if (index(line,'opt').ne.0) then
CMWS         if (index(line,'opt=ts')+index(line,'opt(ts').ne.0) then
CMWS            runtyp='sadpoint'
CMWS         else
CMWS            runtyp='optimize'
CMWS         endif
CMWS      elseif (index(line,'freq').ne.0) then
CMWS         runtyp='raman'
CMWS      else
CMWS         runtyp='energy'
CMWS      endif
CMWSC
CMWSC
CMWS      if (io>0) then
CMWS         call NJ_trim(mthd,k1,k2)
CMWS         write(io,*) 'Method : '//mthd(k1:k2)
CMWS         call NJ_trim(basis,k1,k2)
CMWS         write(io,*) 'Basis  : '//basis(k1:k2)
CMWS         call NJ_trim(runtyp,k1,k2)
CMWS         write(io,*) 'Runtype: '//runtyp(k1:k2)
CMWS      endif
CMWSC
CMWS      end
C
C
C --- 2006.05.29 Read AO dipole integrals from exam.dat ---
      subroutine DipInt2(inp,NW,admx,admy,admz)
      implicit none
      integer NW,Nmo,i,j,k,L,inp,L2
      double precision admx(NW,NW),admy(NW,NW),admz(NW,NW)
      double precision,allocatable:: dtmp(:)
C
      L2=NW*(NW+1)/2
      allocate(dtmp(L2))
      call rread(inp, '$AO-DIPOLE-X', L2, dtmp)
      k=0
      do i=1,NW; do j=1,i
         k=k+1;  admx(j,i)=dtmp(k);  admx(i,j)=dtmp(k)
      enddo; enddo
C
      call rread(inp, '$AO-DIPOLE-Y', L2, dtmp)
      k=0
      do i=1,NW; do j=1,i
         k=k+1;  admy(j,i)=dtmp(k);  admy(i,j)=dtmp(k)
      enddo; enddo
C
      call rread(inp, '$AO-DIPOLE-Z', L2, dtmp)
      k=0
      do i=1,NW; do j=1,i
         k=k+1;  admz(j,i)=dtmp(k);  admz(i,j)=dtmp(k)
      enddo; enddo
      deallocate(dtmp)
C
      end
C

CMWSc     ##############################################################
CMWSc     ##  subroutine NJ_cputim -- Print out total job CPU Time    ##
CMWSc     ##  2004.12.24 by Wei Li; Update 2005.10.16 by Wei Li       ##
CMWSc     ##############################################################
CMWSc     in parent program def. "real*8 Tim0,CPUTim"; "Tim0=CPUTim(0)" for initial time
CMWS
CMWS      subroutine NJ_cputim(IOut,RefTim)
CMWS      Implicit Real*8(A-H,O-Z)
CMWS
CMWS 1000  Format(' CPU time: ',I3,' days ',I2,' hours ',I2,' minutes ',
CMWS     $    F4.1,' seconds.')
CMWS
CMWS      Time = CPUTim(0) - RefTim
CMWS      NDays = (Time / (3600.0d0*24.0d0))
CMWS      Time = Time - (NDays*(3600.0d0*24.0d0))
CMWS      NHours = (Time / 3600.0d0)
CMWS      Time = Time - (NHours*3600.0d0)
CMWS      NMin = (Time / 60.0d0)
CMWS      Time = Time - (NMin*60.0d0)
CMWS      Write(IOut,1000) NDays, NHours, NMin, Time
CMWS      Return
CMWS      End

      function CPUTim(Junk)
      Implicit Real*8(a-h,o-z)
      Real TimArray(2), ETime
C     CPUTim = ETime(TimArray)
      call tsecnd(tim)
      CPUTim = tim
      Return
      End
CMWSC
CMWSc     ##############################################################
CMWSc     ##  subroutine NJ_cmdline  --  get command line arguments   ##
CMWSc     ##  2005.10.15 by Wei Li; Update 2005.10.16 by Wei Li       ##
CMWSc     ##############################################################
CMWSc
CMWSc     arguments are stored at arg(1:narg)
CMWSc     arg(0)= initial command; typarg(0)=0
CMWSC     default typarg=1
CMWSC     For -x (x=A~Z or a-z) typarg=2
CMWSC     For -x (x=0~9) typarg=3
CMWSC     For -x (x=-) typarg=4
CMWSC     For -x (if x is not in "a-z,A-Z,0-9,-" then typarg=-1
CMWSc
CMWS      subroutine NJ_cmdline(narg,arg,typarg)
CMWS      implicit none
CMWS      integer marg
CMWS      parameter (marg=20)
CMWS      integer narg,typarg(0:marg)
CMWS      character*100 arg(0:marg)
CMWS
CMWS
CMWS      integer i,iargc,k
CMWS      character ch1,ch2
CMWS
CMWS      arg=' '
CMWS      narg=iargc()
CMWS      if (narg.gt.marg) narg=marg
CMWS      do i=0,narg
CMWS         call getarg (i,arg(i))
CMWS      end do
CMWS
CMWS      typarg=1
CMWS      typarg(0)=0
CMWS
CMWS      do i=1,narg
CMWS         ch1=arg(i)(1:1)
CMWS         ch2=arg(i)(2:2)
CMWS         if (ch1.eq.'-') then
CMWS            k=ichar(ch2)
CMWS            if (k.ge.65.and.k.le.90.or.k.ge.97.and.k.le.122) then
CMWS               typarg(i)=2    ! -"a-z,A-Z"
CMWS            elseif (k.ge.48.and.k.le.57) then
CMWS               typarg(i)=3    ! -"0-9"
CMWS            elseif (k.eq.45) then
CMWS               typarg(i)=4      ! -"-"
CMWS            else
CMWS               typarg(i)=-1
CMWS            endif
CMWS         endif
CMWS      enddo
CMWS
CMWS      end
C
CMWSc     ##############################################################
CMWSc     ##  subroutine NJ_help  --  Print help if '-h' or '--h'     ##
CMWSc     ##  Recently update on Oct 15, 2005 by Wei Li               ##
CMWSc     ##############################################################
CMWSc
CMWS      subroutine NJ_help(narg,arg,typarg,hlp)
CMWS      implicit none
CMWS      integer marg
CMWS      parameter (marg=20)
CMWS      integer narg,typarg(0:marg)
CMWS      character*100 arg(0:marg)
CMWS
CMWS      integer i,j,k,hlp
CMWS
CMWS      if (narg.eq.0) then
CMWS         write(*,*) 'No any string after command!'
CMWS         stop
CMWS      endif
CMWS
CMWS      i=typarg(1)
CMWS      if (i.eq.2.and.arg(1)(2:2).eq.'h') then
CMWS         hlp=0
CMWS      elseif (i.eq.4) then
CMWS         hlp=1
CMWS      else
CMWS         hlp=-1
CMWS      endif
CMWS
CMWS      end
C
C
CMWSc     ##############################################################
CMWSc     ##  subroutine LS_infile  --  get input file name from cmd  ##
CMWSc     ##  2005.10.15 by Wei Li; Update 2005.10.16 by Wei Li       ##
CMWSc     ##############################################################
CMWSc
CMWS      subroutine LS_infile(narg,arg,typarg,inname,suffix)
CMWS      implicit none
CMWS      integer marg
CMWS      parameter (marg=20)
CMWS      integer narg,typarg(0:marg)
CMWS      character*100 arg(0:marg)
CMWS      character suffix*10
CMWS
CMWS
CMWS      character inname*(*)
CMWS      integer i,j0,j1,j,k,k1,k2
CMWS
CMWS      do i=1,narg
CMWS         j0=typarg(i-1)
CMWS         j1=typarg(i)
CMWS         if (j1.eq.1.and.(j0.eq.0.or.j0.eq.1)) then
CMWS            do j=len(arg(i)),1,-1
CMWS               if (arg(i)(j:j).ne.' ') exit
CMWS            enddo
CMWS            k=len(inname)
CMWS            j=min(j,k)
CMWS            inname=arg(i)(1:j)
CMWSC
CMWS            suffix='          '
CMWS            call NJ_trim(inname,k1,k2)
CMWS            do k=k2,max(k1,k2-10),-1
CMWS               if (inname(k:k)=='.') exit
CMWS            enddo
CMWS            suffix=inname(k+1:k2)
CMWSC
CMWS            return
CMWS         endif
CMWS      enddo
CMWS
CMWS      write(*,*) 'Wrong command for running input file!'
CMWS      stop
CMWS      end
C
CMWSc     ##############################################################
CMWSc     ##  subroutine NJ_infile  --  get input file name from cmd  ##
CMWSc     ##  2005.10.15 by Wei Li; Update 2005.10.16 by Wei Li       ##
CMWSc     ##############################################################
CMWSc
CMWS      subroutine NJ_infile(narg,arg,typarg,inname)
CMWS      implicit none
CMWS      integer marg
CMWS      parameter (marg=20)
CMWS      integer narg,typarg(0:marg)
CMWS      character*100 arg(0:marg)
CMWS
CMWS
CMWS      character inname*(*)
CMWS      integer i,j0,j1,j,k
CMWS
CMWS      do i=1,narg
CMWS         j0=typarg(i-1)
CMWS         j1=typarg(i)
CMWS         if (j1.eq.1.and.(j0.eq.0.or.j0.eq.1)) then
CMWS            do j=len(arg(i)),1,-1
CMWS               if (arg(i)(j:j).ne.' ') exit
CMWS            enddo
CMWS            k=len(inname)
CMWS            j=min(j,k)
CMWS            inname=arg(i)(1:j)
CMWS            return
CMWS         endif
CMWS      enddo
CMWS
CMWS      write(*,*) 'Wrong command for running input file!'
CMWS      stop
CMWS      end
C
CMWSc     ##############################################################
CMWSc     ##  subroutine NJ_outfile -- get output file name from cmd  ##
CMWSc     ##  2005.10.15 by Wei Li; Update 2005.10.17 by Wei Li       ##
CMWSc     ##############################################################
CMWSc
CMWS      subroutine NJ_outfile(narg,arg,typarg,inname,ch,ch2,outname)
CMWS      implicit none
CMWS      integer marg
CMWS      parameter (marg=20)
CMWS      integer narg,typarg(0:marg)
CMWS      character*100 arg(0:marg)
CMWS
CMWS      character inname*(*),outname*(*),ch,ch2*(*)
CMWS      integer i,j0,j1,j,k,l
CMWS
CMWS      if (ch==' ') goto 100
CMWS      do i=1,narg
CMWS         j0=typarg(i-1)
CMWS         j1=typarg(i)
CMWS         if (j1.eq.1.and.j0.eq.2.and.arg(i-1)(2:2).eq.ch) then
CMWS            do j=len(arg(i)),1,-1
CMWS               if (arg(i)(j:j).ne.' ') exit
CMWS            enddo
CMWS            k=len(outname)
CMWS            j=min(j,k)
CMWS            outname=arg(i)(1:j)
CMWS            return
CMWS         endif
CMWS      enddo
CMWS
CMWS 100  j=len(inname)
CMWS      do i=j,1,-1
CMWS         if(inname(i:i).eq.'.') exit
CMWS      enddo
CMWS
CMWS      k=len(outname)
CMWS      l=len(ch2)
CMWS      i=min(i,k-l)
CMWS      outname=inname(1:i-1)//'.'//ch2
CMWS
CMWS      end
C
CMWSc     ##############################################################
CMWSc     ##  subroutine NJ_argvalue  --  Print help if '-h' or '--h' ##
CMWSc     ##  Recently update on Oct 15, 2005 by Wei Li               ##
CMWSc     ##############################################################
CMWSc
CMWS      subroutine NJ_argvalu(narg,arg,typarg,ch,np)
CMWS      implicit none
CMWSC
CMWS      integer marg
CMWS      parameter (marg=20)
CMWS      integer narg,typarg(0:marg),lth,ith
CMWS      character*100 arg(0:marg)
CMWS      character ch*(*)
CMWS      integer i,j,k,np,j0,j1
CMWSC
CMWS      np=0
CMWS      lth=len(ch)
CMWSC
CMWS      do i=1,narg
CMWS         j0=typarg(i-1)
CMWS         j1=typarg(i)
CMWS         if (j1.eq.1.and.j0.eq.2.and.arg(i-1)(2:lth+1).eq.ch) then
CMWS            ith=len(arg(i))
CMWS            read(arg(i)(1:ith),*) np
CMWS            return
CMWS         endif
CMWS      enddo
CMWSC
CMWS      end

c
CMWSC --- 2006.12.13 Add
CMWS      subroutine NJ_argfind(narg,arg,typarg,ch,yes)
CMWS      implicit none
CMWSC
CMWS      integer marg
CMWS      parameter (marg=20)
CMWS      integer narg,typarg(0:marg),lth,ith
CMWS      character*100 arg(0:marg)
CMWS      character ch*(*)
CMWS      integer i,j,k,np,j0,j1,yes
CMWSC
CMWS      yes=0
CMWS      lth=len(ch)
CMWSC
CMWS      do i=1,narg
CMWS         j0=typarg(i)
CMWS         if (j0.eq.2.and.arg(i)(2:lth+1).eq.ch) then
CMWS            yes=1
CMWS            return
CMWS         endif
CMWS      enddo
CMWSC
CMWS      end
C
CMWSc     ##############################################################
CMWSc     ##  subroutine NJ_openf  -- open an file, and backup old    ##
CMWSc     ##  2004.12.22 by Wei Li; Update 2005.10.17 by Wei Li       ##
CMWSc     ##############################################################
CMWSc
CMWS      subroutine NJ_openf(io,fname,forms)
CMWS      implicit none
CMWS      integer io,i,k1,k2,k3,system
CMWS      character fname*(*),ch,run*256,forms*(*)
CMWS      parameter (ch='~')
CMWS      logical logi
CMWSC     external system
CMWS
CMWS      call NJ_trim(fname,k1,k2)
CMWS      k3=len(forms)
CMWS      inquire(file=fname(k1:k2),exist=logi)
CMWS
CMWS      run='mv '//fname(k1:k2)//' '//fname(k1:k2)//ch
CMWS      if (logi) i=system(run)
CMWS      open(io,file=fname(k1:k2),form=forms(1:k3))
CMWS
CMWS      end
C

c     ##############################################################
c     ##  subroutine NJ_trim  --  move blank of two sides         ##
c     ##  2005.01.07 by Wei Li; Update 2005.11.01 by Wei Li       ##
c     ##############################################################
c
      subroutine NJ_trim(line,k1,k2)
      implicit none
      integer k1,k2,i,j
      character line*(*)

      j=len(line)
      do i=1,j
         if (line(i:i).ne.' ') then
            k1=i; exit
         endif
         if (i==j) then
            k1=1; k2=1
            return
         endif
      enddo

      do i=j,1,-1
         if (line(i:i).ne.' ') then
            k2=i; exit
         endif
      enddo

      end
C
CMWSc     ##############################################################
CMWSc     ##  subroutine NJ_date -- Print current time for system     ##
CMWSc     ##  2004.12.24 by Wei Li; Update 2005.10.16 by Wei Li       ##
CMWSc     ##############################################################
CMWS
CMWS      subroutine NJ_date(io,note)
CMWS      implicit none
CMWS      integer io,i
CMWS      character datim*26,note*(*)
CMWS
CMWS      i=len(note)
CMWS      call GDate(datim)
CMWS      write (io,*) note(1:i)//' '//datim(1:24)
CMWS      end
CMWS
CMWS      Subroutine GDate(Date1)
CMWS      Implicit Integer(A-Z)
CMWS      Character*(*) Date1
CMWSC     Call FDate(Date1)
CMWS      call tmdate(Date1)
CMWS      If(Len(Date1).gt.24) Date1(25:) = ' '
CMWS      Return
CMWS      end
C
CMWSc     ##############################################################
CMWSc     ##  subroutine NJ_sysinfo2 --  show host os & directory     ##
CMWSc     ##  2005.12.26 by Wei Li; Update 2008.03.17 by Wei Li       ##
CMWSc     ##############################################################
CMWSc
CMWS      subroutine NJ_sysinfo2(io,snfname,path,user)
CMWS      implicit none
CMWS      integer io,system,i,j,k,L,itmp
CMWS      character sls,line*200,line2*200,line3*200,snfname*100,path*200
CMWS      character user*50
CMWSC     external system
CMWSC
CMWS      itmp=55
CMWS      call NJ_tmpunit(itmp)
CMWSC
CMWSC --- 00. USER name
CMWS      i=system('echo $USER > '//trim(snfname))
CMWS      open(itmp,file=trim(snfname))
CMWS      read(itmp,'(a)') line
CMWS      user = line(1:50)
CMWS      close(itmp)
CMWSC
CMWSC --- 01. Hostname
CMWS      i=system('hostname > '//trim(snfname))
CMWS      open(itmp,file=trim(snfname))
CMWS      read(itmp,'(a)') line
CMWS      do i=100,1,-1
CMWS         if (line(i:i).ne.' ') exit
CMWS      enddo
CMWS      close(itmp)
CMWSC --- 02. Operation system
CMWS      j=system('uname -m > '//trim(snfname))
CMWS      open(itmp,file=trim(snfname))
CMWS      read(itmp,'(a)') line2
CMWS      do j=100,1,-1
CMWS         if (line2(j:j).ne.' ') exit
CMWS      enddo
CMWS      close(itmp)
CMWSC --- 03. Directory
CMWS      k=system('pwd > '//trim(snfname))
CMWS      open(itmp,file=trim(snfname))
CMWS      read(itmp,'(a)') line3
CMWS      do k=100,1,-1
CMWS         if (line3(k:k).ne.' ') exit
CMWS      enddo
CMWS      close(itmp,status='delete')
CMWSC --- Output
CMWS      write(io,*) line(1:i)//':'//line3(1:k)//' ('//line2(1:j)//')'
CMWSC
CMWSC-WL,PP FOR GET GAMESS-CIM PATH
CMWS      sls=char(47)   ! sls='/'
CMWS      path=line3
CMWS      L=index(path,sls//'tests')
CMWS      if (L.ne.0) then
CMWS         path(L:200)=' '
CMWS      endif
CMWSC
CMWS      end
C
C
CMWSc     ##############################################################
CMWSc     ##  subroutine NJ_prtcol -- print column(c1:c2) of mat(n,n) ##
CMWSc     ##  2005.12.22 by Wei Li; Update 2005.10.16 by Wei Li       ##
CMWSc     ##############################################################
CMWSc
CMWSc     format: f(x.y) x>7 sugg 12.5,12.7,14.9
CMWSc
CMWS      subroutine NJ_prtcol(io,n,mat,c1,c2,fm)
CMWS      implicit none
CMWS      integer i,j,jj,n,io,c1,c2,n5,nf,nc,x,y,k
CMWS      real*8 mat(n,n)
CMWS      character fm*(*),ch,fm2*10
CMWS      character*40 fmt1,fmt2,fmt3,fmt4
CMWS
CMWS      nc=c2-c1+1; n5=nc/5; nf=mod(nc,5)
CMWS      fm2=fm; ch=fm2(1:1); k=index(fm2,'.')
CMWS      read(fm2(2:k-1),*) x; read(fm2(k+1:10),*) y
CMWS
CMWS      write(fmt1,101) ch,x,y; write(fmt2,102) nf,ch,x,y
CMWS 101  format('(i7,5',a1,i2,'.',i2,')')
CMWS 102  format('(i7,',i2,a1,i2,'.',i2,')')
CMWS      write(fmt3,103) x-7; write(fmt4,104) nf,x-7
CMWS 103  format('(3x,5(',i2,'x,i7))')
CMWS 104  format('(3x,',i2,'(',i2,'x,i7))')
CMWS
CMWS      do jj=1,n5
CMWS         write(io,fmt3) (j,j=c1+(jj-1)*5,c1+jj*5-1)
CMWS         write(io,fmt1) (i,(mat(i,j),j=c1+(jj-1)*5,c1+jj*5-1),i=1,n)
CMWSC         if (jj.ne.n5.or.nf.ne.0) write(io,*)
CMWS      enddo
CMWS
CMWS      if (nf.ne.0) then
CMWS         write(io,fmt4)(j,j=c1+n5*5,c2)
CMWS         write(io,fmt2) (i,(mat(i,j),j=c1+n5*5,c2),i=1,n)
CMWS      endif
CMWS      call flshbf(io)
CMWS
CMWS      end
C
C
c     ##############################################################
c     ##  subroutine NJ_prtcol -- print column(c1:c2) of mat(m,n) ##
c     ##  2005.12.22 by Wei Li; Update 2005.12.25 by Wei Li       ##
c     ##############################################################
c
c     format: f(x.y) x>7 sugg 12.5,12.7,14.9
c
      subroutine NJ_prtcol2(io,m,n,mat,c1,c2,fm)
      implicit none
      integer i,j,jj,m,n,io,c1,c2,n5,nf,nc,x,y,k
      double precision mat(m,n)
      character fm*(*),ch,fm2*10
      character*40 fmt1,fmt2,fmt3,fmt4
C
      nc=c2-c1+1; n5=nc/5; nf=mod(nc,5)
      fm2=fm; ch=fm2(1:1); k=index(fm2,'.')
      read(fm2(2:k-1),*) x; read(fm2(k+1:10),*) y
C
      write(fmt1,101) ch,x,y; write(fmt2,102) nf,ch,x,y
 101  format('(i7,5',a1,i2,'.',i2,')')
 102  format('(i7,',i2,a1,i2,'.',i2,')')
      write(fmt3,103) x-7; write(fmt4,104) nf,x-7
 103  format('(3x,5(',i2,'x,i7))')
 104  format('(3x,',i2,'(',i2,'x,i7))')
C
      do jj=1,n5
         write(io,fmt3) (j,j=c1+(jj-1)*5,c1+jj*5-1)
         write(io,fmt1) (i,(mat(i,j),j=c1+(jj-1)*5,c1+jj*5-1),i=1,m)
      enddo
C
      if (nf.ne.0) then
         write(io,fmt4)(j,j=c1+n5*5,c2)
         write(io,fmt2) (i,(mat(i,j),j=c1+n5*5,c2),i=1,m)
      endif
      call flshbf(io)
C
      end
C
CMWSc     ##############################################################
CMWSc     ##  subroutine NJ_prtcol3 - print column(c1:c2) of mat(m,n) ##
CMWSc     ##  2005.12.22 by Wei Li; Update 2005.12.25 by Wei Li       ##
CMWSc     ##############################################################
CMWSc
CMWSc     format: f(x.y) x>7 sugg 12.5,12.7,14.9
CMWSc
CMWS      subroutine NJ_prtcol3(io,m,n,mat0,mat,c1,c2,fm)
CMWS      implicit none
CMWS      integer i,j,jj,m,n,io,c1,c2,n5,nf,nc,x,y,k,mat0(n,m)
CMWS      double precision mat(m,n)
CMWS      character fm*(*),ch,fm2*10
CMWS      character*40 fmt1,fmt2,fmt3,fmt4
CMWSC
CMWS      nc=c2-c1+1; n5=nc/5; nf=mod(nc,5)
CMWS      fm2=fm; ch=fm2(1:1); k=index(fm2,'.')
CMWS      read(fm2(2:k-1),*) x; read(fm2(k+1:10),*) y
CMWSC
CMWS      write(fmt1,101) ch,x,y; write(fmt2,102) nf,nf,ch,x,y
CMWS 101  format('(i4,1x,5i4,5',a1,i2,'.',i2,')')
CMWS 102  format('(i4,1x,',i2,'i4,',i2,a1,i2,'.',i2,')')
CMWS      write(fmt3,103) x-7; write(fmt4,104) nf,nf,x-7
CMWS 103  format('(5x,5i4,5(',i2,'x,i7))')
CMWS 104  format('(5x,',i2,'i4,',i2,'(',i2,'x,i7))')
CMWSC
CMWS      do jj=1,n5
CMWS         write(io,fmt3) (j,j=c1+(jj-1)*5,c1+jj*5-1),
CMWS     &                  (j,j=c1+(jj-1)*5,c1+jj*5-1)
CMWS         write(io,fmt1)
CMWS     &  (i,(mat0(j,i),j=c1+(jj-1)*5,c1+jj*5-1),
CMWS     &      (mat(i,j),j=c1+(jj-1)*5,c1+jj*5-1),i=1,m)
CMWS         if (jj.ne.n5.or.nf.ne.0) write(io,'(1x,74(''-''))')
CMWS      enddo
CMWSC
CMWS      if (nf.ne.0) then
CMWS         write(io,fmt4)(j,j=c1+n5*5,c2),(j,j=c1+n5*5,c2)
CMWS         write(io,fmt2) (i,(mat0(j,i),j=c1+n5*5,c2),
CMWS     &                  (mat(i,j),j=c1+n5*5,c2),i=1,m)
CMWS      endif
CMWS      call flshbf(io)
CMWSC
CMWS      end
C
CMWSc     ##############################################################
CMWSc     ##  subroutine NJ_prtcol4 - print column(c1:c2) of mat(m,n) ##
CMWSc     ##  2005.12.22 by Wei Li; Update 2008.08.06 by Wei Li       ##
CMWSc     ##############################################################
CMWSc
CMWSc     format: f(x.y) x>7 sugg 12.5,12.7,14.9
CMWSc
CMWS      subroutine NJ_prtcol4(io,m,n,mat0,mat,r1,r2,c1,c2,fm)
CMWS      implicit none
CMWS      integer i,j,jj,m,n,io,c1,c2,n5,nf,nc,x,y,k,mat0(m,n),r1,r2
CMWS      double precision mat(m,n)
CMWS      character fm*(*),ch,fm2*10
CMWS      character*40 fmt1,fmt2,fmt3,fmt4
CMWSC
CMWS      if (r1.lt.1.or.r2.gt.m) then
CMWS         write(*,*) 'Wrong range for r1-r2'
CMWS         write(*,*) 'switch to full row output'
CMWS         r1=1
CMWS         r2=m
CMWS      endif
CMWSC
CMWS      nc=c2-c1+1; n5=nc/5; nf=mod(nc,5)
CMWS      fm2=fm; ch=fm2(1:1); k=index(fm2,'.')
CMWS      read(fm2(2:k-1),*) x; read(fm2(k+1:10),*) y
CMWSC
CMWS      write(fmt1,101) ch,x,y; write(fmt2,102) nf,nf,ch,x,y
CMWS 101  format('(i4,1x,5i4,5',a1,i2,'.',i2,')')
CMWS 102  format('(i4,1x,',i2,'i4,',i2,a1,i2,'.',i2,')')
CMWS      write(fmt3,103) x-7; write(fmt4,104) nf,nf,x-7
CMWS 103  format('(5x,5i4,5(',i2,'x,i7))')
CMWS 104  format('(5x,',i2,'i4,',i2,'(',i2,'x,i7))')
CMWSC
CMWS      do jj=1,n5
CMWS         write(io,fmt3) (j,j=c1+(jj-1)*5,c1+jj*5-1),
CMWS     &                  (j,j=c1+(jj-1)*5,c1+jj*5-1)
CMWS         write(io,fmt1)
CMWS     &  (i,(mat0(i,j),j=c1+(jj-1)*5,c1+jj*5-1),
CMWS     &      (mat(i,j),j=c1+(jj-1)*5,c1+jj*5-1),i=r1,r2)
CMWS         if (jj.ne.n5.or.nf.ne.0) write(io,'(1x,74(''-''))')
CMWS      enddo
CMWSC
CMWS      if (nf.ne.0) then
CMWS         write(io,fmt4)(j,j=c1+n5*5,c2),(j,j=c1+n5*5,c2)
CMWS         write(io,fmt2) (i,(mat0(i,j),j=c1+n5*5,c2),
CMWS     &                  (mat(i,j),j=c1+n5*5,c2),i=r1,r2)
CMWS      endif
CMWS      call flshbf(io)
CMWSC
CMWS      end
C

CMWSC --- (Mat2)mm = (X(T))mn (Mat)nn (X)nm
CMWSC --- 2006.02.24 Modified
CMWSC --- 2006.03.14 Modified
CMWSC --- 2009.09.22 Modified allocate(Y)
CMWS      subroutine NJ_tfock1(io,n,m,Mat,X,Mat2)
CMWS      implicit none
CMWS      integer io,i,j,k,l,m,n
CMWS      real*8 Mat(n,n),X(n,m),Mat2(m,m),PP
CMWS      double precision,dimension(:,:),allocatable::Y
CMWS      allocate(Y(n,m))
CMWSC
CMWS      Y=0d0
CMWS      do j=1,m; do i=1,n
CMWS         PP=0d0
CMWS         do k=1,n
CMWS            PP=PP+Mat(i,k)*X(k,j)
CMWS         enddo
CMWS         Y(i,j)=PP
CMWS      enddo; enddo
CMWSC
CMWS      Mat2=0d0
CMWS      do j=1,m; do i=1,m
CMWS         PP=0d0
CMWS         do k=1,n
CMWS            PP=PP+X(k,i)*Y(k,j)
CMWS         enddo
CMWS         Mat2(i,j)=PP
CMWS         if (dabs(Mat2(i,j))<1d-10) Mat2(i,j)=0d0    ! 2008.02.14 1d-11 --> 1d-10
CMWS      enddo; enddo
CMWSC
CMWS      if (io>0) then
CMWS         write(io,*) '+++ Transformed matrix B=X^{T}AX '
CMWS     &             //'(keep value >1E-10) +++'
CMWS         call NJ_prtsym(io,m,Mat2,'d14.6')
CMWS         write(io,*)
CMWS      endif
CMWS      deallocate(Y)
CMWSC
CMWS      end
C
CMWSC --- (Mat2)mm = (X^T)mn (Mat)nn (X)nm
CMWSC --- 2006.02.24 Modified
CMWSC --- 2006.03.14 Modified
CMWSC --- 2008.02.21 Modified
CMWSC --- 2009.09.22 Modified allocate(Y)
CMWS      subroutine NJ_tfock2(io,n,m,Mat,X,Mat2)
CMWS      implicit none
CMWS      integer io,i,j,k,l,m,n
CMWS      real*8 Mat(n,n),X(n,m),Mat2(m,m),PP
CMWS      double precision,dimension(:,:),allocatable::Y
CMWS      allocate(Y(n,m))
CMWSC
CMWSC --- Y=MX: Y_{ij}=\sum_k M_{ik}*X_{kj}
CMWS      Y=0d0
CMWS      do j=1,m; do i=1,n
CMWS         PP=0d0
CMWS         do k=1,n
CMWS            PP=PP+Mat(i,k)*X(k,j)
CMWS         enddo
CMWS         Y(i,j)=PP
CMWS      enddo; enddo
CMWSC
CMWSC --- M2=X^{T}Y: M2_{ij}=\sum_k X_{ki}*Y_{kj}
CMWS      Mat2=0d0
CMWS      do j=1,m; do i=1,m
CMWS         PP=0d0
CMWS         do k=1,n
CMWS            PP=PP+X(k,i)*Y(k,j)
CMWS         enddo
CMWS         Mat2(i,j)=PP
CMWS      enddo; enddo
CMWSC
CMWS      if (io>0) then
CMWS         write(io,*) '+++ Transformed matrix B=X^{T}AX +++'
CMWS         call NJ_prtsym(io,m,Mat2,'d14.6')
CMWS         write(io,*)
CMWS      endif
CMWS      deallocate(Y)
CMWSC
CMWS      end
C
C --- (Mat2)mm = (X^T)mn (Mat)nn (X)nm
C --- 2006.02.24 Modified
C --- 2006.03.14 Modified
C --- 2008.02.21 Modified
C --- 2009.09.22 Modified allocate(Y)
      subroutine NJ_tfock(io,n,m,Mat,X,Mat2)
      implicit none
      integer io,i,j,k,l,m,n
      real*8 Mat(n,n),X(n,m),Mat2(m,m),PP
      double precision,dimension(:,:),allocatable::Y
      allocate(Y(m,n))
C
C --- Y=X^{T}M: Y_{ij}=\sum_k X_{ki}*M_{kj}
      Y=0d0
      do j=1,n; do i=1,m
         PP=0d0
         do k=1,n
            PP=PP+X(k,i)*Mat(k,j)
         enddo
         Y(i,j)=PP
      enddo; enddo
C
C --- M2=YX: M2_{ij}=\sum_k Y_{ik}*X_{kj}
      Mat2=0d0
      do j=1,m; do i=1,m
         PP=0d0
         do k=1,n
            PP=PP+Y(i,k)*X(k,j)
         enddo
         Mat2(i,j)=PP
         if (dabs(Mat2(i,j))<1d-14) Mat2(i,j)=0d0    ! 2008.02.21 1d-10 --> 1d-12
      enddo; enddo
C
      if (io>0) then
         write(io,*) '+++ Transformed matrix B=X^{T}AX (kept>1E-14) +++'
         call NJ_prtsym(io,m,Mat2,'d14.6')
         write(io,*)
      endif
      deallocate(Y)
C
      end
C
CMWSC --- 2009.09.22 Modified allocate(Y)
CMWSC --- (Mat2)mm = (X(T))mn (Mat)nn (X)nm
CMWS      subroutine NJ_tfock0(io,n,m,Mat,X,Mat2)
CMWS      implicit none
CMWS      integer io,i,j,k,l,m,n
CMWS      real*8 Mat(n,n),X(n,m),Mat2(m,m),PP
CMWS      double precision,dimension(:,:),allocatable::Y
CMWS      allocate(Y(n,m))
CMWSC
CMWS      Mat2=0d0
CMWS      do j=1,m; do i=1,m
CMWS         do k=1,n; do l=1,n
CMWS            Mat2(i,j)=Mat2(i,j)+X(l,i)*Mat(l,k)*X(k,j)
CMWS         enddo; enddo
CMWS         if (dabs(Mat2(i,j))<1d-11) Mat2(i,j)=0d0
CMWS      enddo; enddo
CMWSC
CMWS      if (io>0) then
CMWS         write(io,*) '+++ Transformed fock matrix +++'
CMWS         call NJ_prtsym(io,m,Mat2,'d14.6')
CMWS         write(io,*)
CMWS      endif
CMWS      deallocate(Y)
CMWSC
CMWS      end
C
CMWSc     ##############################################################
CMWSc     ##  subroutine NJ_tmpunit -- Auto find an unused file unit  ##
CMWSc     ##  2005.10.18 by Wei Li; Update 2005.10.18 by Wei Li       ##
CMWSc     ##############################################################
CMWSc
CMWS      subroutine NJ_tmpunit(tmp2)
CMWS      implicit none
CMWS      integer tmp2
CMWS      logical lg
CMWS
CMWS      if (tmp2<=0 .or. tmp2> 10000) tmp2=50
CMWS100   inquire(unit=tmp2,opened=lg)
CMWS      if (lg) then
CMWS         tmp2=tmp2+1
CMWS         goto 100
CMWS      endif
CMWS
CMWS      end

c     ##############################################################
c     ##  subroutine NJ_prtsym  --  print symmetric mat(n,n)      ##
c     ##  2005.12.22 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################
c
c     format: f(x.y) x>7 sugg 12.5,12.7,14.9
c
      subroutine NJ_prtsym(io,n,mat,fm)
      implicit none
      integer i,j,jj,n,io,n5,nf,nc,x,y,ini,ifi,k
      real*8 mat(n,n)
      character fm*(*),ch,fm2*10
      character*40 fmt1,fmt2,fmt3,fmt4

      n5=n/5; nf=mod(n,5)
      fm2=fm; ch=fm2(1:1); k=index(fm2,'.')
      read(fm2(2:k-1),*) x; read(fm2(k+1:10),*) y

      write(fmt1,101) ch,x,y; write(fmt2,102) nf,ch,x,y
 101  format('(i7,5',a1,i2,'.',i2,')')
 102  format('(i7,',i2,a1,i2,'.',i2,')')
      write(fmt3,103) x-7; write(fmt4,104) nf,x-7
 103  format('(3x,5(',i2,'x,i7))')
 104  format('(3x,',i2,'(',i2,'x,i7))')

      do jj=1,n5
         ini=1+(jj-1)*5
         write(io,fmt3) (j,j=ini,jj*5)
         do k=1+(jj-1)*5,n
            ifi=min(jj*5,k)
            write(io,fmt1) k,(mat(k,j),j=ini,ifi)
         enddo
      enddo

      if (nf.ne.0) then
         ini=n-nf+1
         write(io,fmt4)(j,j=ini,n)
         do k=ini,n
            write(io,fmt2) k,(mat(k,j),j=ini,k)
         enddo
      endif
      call flshbf(io)

      end
CMWSC
CMWSc     ##############################################################
CMWSc     ##  subroutine NJ_prtsym2 --  print symmetric mat(n,n)      ##
CMWSc     ##  2005.12.22 by Wei Li; Update 2005.10.16 by Wei Li       ##
CMWSc     ##############################################################
CMWSc
CMWSc     format: f(x.y) x>7 sugg 12.5,12.7,14.9
CMWSc
CMWS      subroutine NJ_prtsym2(io,n,m,mat,fm)
CMWS      implicit none
CMWS      integer i,j,jj,m,n,io,n5,nf,nc,x,y,ini,ifi,k
CMWS      double precision mat(m,m)
CMWS      character fm*(*),ch,fm2*10
CMWS      character*40 fmt1,fmt2,fmt3,fmt4
CMWSC
CMWS      n5=n/5; nf=mod(n,5)
CMWS      fm2=fm; ch=fm2(1:1); k=index(fm2,'.')
CMWS      read(fm2(2:k-1),*) x; read(fm2(k+1:10),*) y
CMWSC
CMWS      write(fmt1,101) ch,x,y; write(fmt2,102) nf,ch,x,y
CMWS 101  format('(i7,5',a1,i2,'.',i2,')')
CMWS 102  format('(i7,',i2,a1,i2,'.',i2,')')
CMWS      write(fmt3,103) x-7; write(fmt4,104) nf,x-7
CMWS 103  format('(3x,5(',i2,'x,i7))')
CMWS 104  format('(3x,',i2,'(',i2,'x,i7))')
CMWSC
CMWS      do jj=1,n5
CMWS         ini=1+(jj-1)*5
CMWS         write(io,fmt3) (j,j=ini,jj*5)
CMWS         do k=1+(jj-1)*5,n
CMWS            ifi=min(jj*5,k)
CMWS            write(io,fmt1) k,(mat(k,j),j=ini,ifi)
CMWS         enddo
CMWS      enddo
CMWSC
CMWS      if (nf.ne.0) then
CMWS         ini=n-nf+1
CMWS         write(io,fmt4)(j,j=ini,n)
CMWS         do k=ini,n
CMWS            write(io,fmt2) k,(mat(k,j),j=ini,k)
CMWS         enddo
CMWS      endif
CMWS      call flshbf(io)
CMWSC
CMWS      end
C
C     ##############################################################
C     ##  subroutine NJ_walltim -- Print total job wall Time      ##
C     ##  2004.12.24 by Wei Li; Update 2006.03.06 by Wei Li       ##
C     ##############################################################
C           this routine gives errors for TIME() on some systems.
C           it is never called, so rather than remedy, comment it out.
C
C     argument 'wall0' would be set by somewhere at start of run,
C        "integer(kind=4) Wall0,TIME"
C        "Wall0=TIME()"
C     for initial time
C---  subroutine NJ_walltim(io,Wall0)
C---  Implicit double precision (A-H,O-Z)
C---  integer(kind=4) TIME,Wall,Wall0
C---  external TIME
C
C---1 Format(' WALL time:',I3,' days ',I2,' hours ',I2,' minutes ',
C--- $    I4,' seconds.')

C---  Wall = TIME()-Wall0
C---  NDays= Wall/(3600*24)
C---  Wall = Wall-NDays*(3600*24)
C---  NHours= Wall/3600
C---  Wall = Wall-NHours*3600
C---  NMin = Wall/60
C---  Wall = Wall-NMin*60
C---  Write(io,1) NDays, NHours, NMin, Wall
C---  Return
C---  End
C
C
C --- Boys Localization Since  2006.02.24 Ver 0.01 by liwei ---
C     Update 2006.02.25 Ver 0.03
C --- 2006.02.27 update  epst 12->13
C --- 2008.02.10 update  ADD nprtcyc
      subroutine NJ_boyloc(io,nat,nbs,nmo,ini,ifi,smo,mdmx,mdmy,mdmz,
     &     eps,epst,maxcyc,nprint,np,nprtcyc,ierr)
      implicit none
      integer io,nat,nbs,nmo,ini,ifi,maxcyc,nprint,np,ierr
      integer i,j,k,l,m,n,maxcycle,nprtcyc,NMin
      double precision smo(nbs,nmo),eps,epst,PP,QQ,P1,P2,P3,P4,P5,P6
      double precision Tim,Tim1,CPUTim,Sec,Delta,Aij,Bij,piik,pijk,pjjk
      double precision SINA,COSA,SIN2A,COS2A,SIN4A,COS4A,TT,SumD
      double precision riix,riiy,riiz,rjjx,rjjy,rjjz,rijx,rijy,rijz
      double precision px,py,pz
      double precision mdmx(nmo,nmo),mdmy(nmo,nmo),mdmz(nmo,nmo),fac
      parameter(fac=2.541766d0)
      external CPUTim
C
      Tim=CPUTim(0)
C
      if (eps<=1d-16) eps=1d-7
      if (epst<=1d-16) epst=1d-13
      maxcycle=maxcyc
      if (maxcyc<=0) maxcycle=10000
      write(io,'('' Boys Localization of MOs:'',i4,'' -->'',i4)')
     &      ini,ifi
      write(io,'('' Maxcycle ='',i8)') maxcycle
      write(io,'('' Threshold (Converg,Rotation) ='',2d11.2)') eps,epst
C
      SumD=0d0
      do i=ini,ifi
         SumD=SumD+mdmx(i,i)*mdmx(i,i)
         SumD=SumD+mdmy(i,i)*mdmy(i,i)
         SumD=SumD+mdmz(i,i)*mdmz(i,i)
      enddo
      SumD=SumD*fac*fac
C
      write(io,'('' Initial Localization Sum (Debye^2) ='',f16.6)') SumD
      write(io,707)
      write(io,700)
      write(io,707)
      call flshbf(io)
C
      do 200 m=1,maxcycle
         if (mod(m,nprtcyc)==1) Tim1=CPUTim(0)
         Delta=0d0
         do i=ini,ifi-1
            do j=i+1,ifi
               riix=mdmx(i,i); riiy=mdmy(i,i); riiz=mdmz(i,i)
               rjjx=mdmx(j,j); rjjy=mdmy(j,j); rjjz=mdmz(j,j)
               rijx=mdmx(j,i); rijy=mdmy(j,i); rijz=mdmz(j,i)
               px=riix-rjjx;   py=riiy-rjjy;   pz=riiz-rjjz
C
               Aij=rijx*rijx+rijy*rijy+rijz*rijz-(px*px+py*py+pz*pz)/4d0
               Bij=rijx*px+rijy*py+rijz*pz
C
               if (dabs(Aij)<1d-10.and.dabs(Bij)<1d-10) cycle
C
               P1=dsqrt(Aij*Aij+Bij*Bij)
               COS4A=-Aij/P1
               SIN4A=Bij/P1
C
               COS2A=dsqrt((1d0+COS4A)/2d0)
               SIN2A=dsqrt((1d0-COS4A)/2d0)
               COSA=dsqrt((1d0+COS2A)/2d0)
               SINA=dsqrt((1d0-COS2A)/2d0)
               if (SIN4A<0d0) then
                  COS2A=-COS2A
                  TT=COSA
                  COSA=SINA
                  SINA=TT
               endif
C
               if (dabs(COSA-1d0).lt.epst) cycle
               if (dabs(SINA-1d0).lt.epst) cycle
C
               PP=P1*(1d0-COS4A)
               Delta=Delta+PP

               do k=1,nbs
                  TT=smo(k,i)
                  smo(k,i)=COSA*TT+SINA*smo(k,j)
                  smo(k,j)=COSA*smo(k,j)-SINA*TT
               enddo
!              TT=eigen(i)
!              eigen(i)=COSA*TT+SINA*eigen(j)
!              eigen(j)=COSA*eigen(j)-SINA*TT
C
C ---          Transform Dipole Integrals over MOs
               P2=SIN2A
               P1=P2/2d0
               P3=(1d0+COS2A)/2d0
               P4=(1d0-COS2A)/2d0
               P5=COS2A
C --- X Direct
               P6=rijx*P2
               mdmx(i,i)=riix*P3+rjjx*P4+P6
               mdmx(j,j)=riix*P4+rjjx*P3-P6
               mdmx(j,i)=(rjjx-riix)*P1+rijx*P5
               mdmx(i,j)=mdmx(j,i)
               do n=ini,ifi
                  if (n==i.or.n==j) cycle
                  PP=mdmx(i,n)
                  mdmx(i,n)=PP*COSA+mdmx(j,n)*SINA
                  mdmx(j,n)=mdmx(j,n)*COSA-PP*SINA
                  mdmx(n,i)=mdmx(i,n)
                  mdmx(n,j)=mdmx(j,n)
               enddo
C --- X Direct
               P6=rijy*P2
               mdmy(i,i)=riiy*P3+rjjy*P4+P6
               mdmy(j,j)=riiy*P4+rjjy*P3-P6
               mdmy(j,i)=(rjjy-riiy)*P1+rijy*P5
               mdmy(i,j)=mdmy(j,i)
               do n=ini,ifi
                  if (n==i.or.n==j) cycle
                  PP=mdmy(i,n)
                  mdmy(i,n)=PP*COSA+mdmy(j,n)*SINA
                  mdmy(j,n)=mdmy(j,n)*COSA-PP*SINA
                  mdmy(n,i)=mdmy(i,n)
                  mdmy(n,j)=mdmy(j,n)
               enddo
C --- X Direct
               P6=rijz*P2
               mdmz(i,i)=riiz*P3+rjjz*P4+P6
               mdmz(j,j)=riiz*P4+rjjz*P3-P6
               mdmz(j,i)=(rjjz-riiz)*P1+rijz*P5
               mdmz(i,j)=mdmz(j,i)
               do n=ini,ifi
                  if (n==i.or.n==j) cycle
                  PP=mdmz(i,n)
                  mdmz(i,n)=PP*COSA+mdmz(j,n)*SINA
                  mdmz(j,n)=mdmz(j,n)*COSA-PP*SINA
                  mdmz(n,i)=mdmz(i,n)
                  mdmz(n,j)=mdmz(j,n)
               enddo

            enddo
         enddo
C
         k=ifi-ini+1
         SumD=SumD+Delta*fac*fac
         QQ=dsqrt(2d0*Delta/(k*(k-1)))
C
         if (mod(m,nprtcyc)==0) then
            Sec=CPUTim(0)-Tim1
            write(io,702)m,SumD,Delta,QQ,Sec
            call flshbf(io)
         endif
C
         if (dabs(QQ)<eps) then
            write(io,707)
            write(io,701) m
            ierr=0
            exit
         endif
C
         if (m==maxcyc) then
            ierr=1
            write(io,707)
            write(io,703) m
         endif
200   enddo
C
      write(io,'('' Final Localization Sum (Debye^2) ='',f16.6)') SumD
      Sec=CPUTim(0)-Tim
      NMin=Sec/60
      Sec=Sec-NMin*60
      write(io,704) NMin,Sec
C
      write(io,*)
C
      if (nprint==1) then
         write(io,*) '+++ Localized MOs by Boys Localization +++'
!        write(io,'('' Eigenvalues:'',5f11.6)') (eigen(i),i=ini,ifi)
         call NJ_prtcol2(io,nbs,nmo,smo,ini,ifi,'f11.6')
         write(io,*)
      endif
      call flshbf(io)
C
 700  format(
     & '  Iter        Loc-Sum     Delta-Sum     Orb-Change    Time')
 701  format(' Boys Localization Completed After',i11,' Cycle')
 702  format(i5,f17.7,2d14.5,f7.1,'s')
 703  format(' Boys Localization Failed After',i14,' Cycle')
 704  format(' Localization CPU Time: ',i6,' minutes',f5.1,' seconds')
 707  format(1x,58('-'))
C
      end
C
CMWSC --- Boys Localization Since  2006.02.24 Ver 0.01 by liwei ---
CMWSC     Update 2006.02.25 Ver 0.03
CMWSC --- 2006.02.27 update  epst 12->13
CMWS      subroutine NJ_boyloc2(io,nat,nbs,nmo,ini,ifi,smo,mdmx,mdmy,mdmz,
CMWS     &     eps,epst,maxcyc,nprint,np,ierr)
CMWS      implicit none
CMWS      integer io,nat,nbs,nmo,ini,ifi,maxcyc,nprint,np,ierr
CMWS      integer i,j,k,l,m,n,maxcycle,nprtcyc,NMin
CMWS      double precision smo(nbs,nmo),eps,epst,PP,QQ,P1,P2,P3,P4,P5,P6
CMWS      double precision Tim,Tim1,CPUTim,Sec,Delta,Aij,Bij,piik,pijk,pjjk
CMWS      double precision SINA,COSA,SIN2A,COS2A,SIN4A,COS4A,TT,SumD
CMWS      double precision riix,riiy,riiz,rjjx,rjjy,rjjz,rijx,rijy,rijz
CMWS      double precision px,py,pz
CMWS      double precision mdmx(nmo,nmo),mdmy(nmo,nmo),mdmz(nmo,nmo),fac
CMWS      parameter(fac=2.541766d0)
CMWS      external CPUTim
CMWSC
CMWS      Tim=CPUTim(0)
CMWSC
CMWS      nprtcyc=10
CMWS      if (eps<=1d-16) eps=1d-7
CMWS      if (epst<=1d-16) epst=1d-13
CMWS      maxcycle=maxcyc
CMWS      if (maxcyc<=0) maxcycle=10000
CMWS      write(io,*) 'Localization Program by W. Li and S. Li '
CMWS     &          //'in Nanjing University on May 2007'
CMWS      write(io,'('' Boys Localization of MOs:'',i4,'' -->'',i4)')
CMWS     &      ini,ifi
CMWS      write(io,'('' Maxcycle ='',i8)') maxcycle
CMWS      write(io,'('' Threshold (Converg,Rotation) ='',2d11.2)') eps,epst
CMWSC
CMWS      SumD=0d0
CMWS      do i=ini,ifi
CMWS         SumD=SumD+mdmx(i,i)*mdmx(i,i)
CMWS         SumD=SumD+mdmy(i,i)*mdmy(i,i)
CMWS         SumD=SumD+mdmz(i,i)*mdmz(i,i)
CMWS      enddo
CMWS      SumD=SumD*fac*fac
CMWSC
CMWS      write(io,'('' Initial Localization Sum (Debye^2) ='',f16.6)') SumD
CMWS      write(io,707)
CMWS      write(io,700)
CMWS      write(io,707)
CMWS      call flshbf(io)
CMWSC
CMWS      do 200 m=1,maxcycle
CMWS         if (mod(m,nprtcyc)==1) Tim1=CPUTim(0)
CMWS         Delta=0d0
CMWS         do i=ini,ifi-1
CMWS            do j=i+1,ifi
CMWS               riix=mdmx(i,i); riiy=mdmy(i,i); riiz=mdmz(i,i)
CMWS               rjjx=mdmx(j,j); rjjy=mdmy(j,j); rjjz=mdmz(j,j)
CMWS               rijx=mdmx(j,i); rijy=mdmy(j,i); rijz=mdmz(j,i)
CMWS               px=riix-rjjx;   py=riiy-rjjy;   pz=riiz-rjjz
CMWSC
CMWS               Aij=rijx*rijx+rijy*rijy+rijz*rijz-(px*px+py*py+pz*pz)/4d0
CMWS               Bij=rijx*px+rijy*py+rijz*pz
CMWSC
CMWS               if (dabs(Aij)<1d-10.and.dabs(Bij)<1d-10) cycle
CMWSC
CMWS               P1=dsqrt(Aij*Aij+Bij*Bij)
CMWS               COS4A=-Aij/P1
CMWS               SIN4A=Bij/P1
CMWSC
CMWS               COS2A=dsqrt((1d0+COS4A)/2d0)
CMWS               SIN2A=dsqrt((1d0-COS4A)/2d0)
CMWS               COSA=dsqrt((1d0+COS2A)/2d0)
CMWS               SINA=dsqrt((1d0-COS2A)/2d0)
CMWS               if (SIN4A<0d0) then
CMWS                  COS2A=-COS2A
CMWS                  TT=COSA
CMWS                  COSA=SINA
CMWS                  SINA=TT
CMWS               endif
CMWSC
CMWS               if (dabs(COSA-1d0).lt.epst) cycle
CMWS               if (dabs(SINA-1d0).lt.epst) cycle
CMWSC
CMWS               PP=P1*(1d0-COS4A)
CMWS               Delta=Delta+PP
CMWS
CMWS               do k=1,nbs
CMWS                  TT=smo(k,i)
CMWS                  smo(k,i)=COSA*TT+SINA*smo(k,j)
CMWS                  smo(k,j)=COSA*smo(k,j)-SINA*TT
CMWS               enddo
CMWSC
CMWSC ---          Transform Dipole Integrals over MOs
CMWS               P2=SIN2A
CMWS               P1=P2/2d0
CMWS               P3=(1d0+COS2A)/2d0
CMWS               P4=(1d0-COS2A)/2d0
CMWS               P5=COS2A
CMWSC --- X Direct
CMWS               P6=rijx*P2
CMWS               mdmx(i,i)=riix*P3+rjjx*P4+P6
CMWS               mdmx(j,j)=riix*P4+rjjx*P3-P6
CMWS               mdmx(j,i)=(rjjx-riix)*P1+rijx*P5
CMWS               mdmx(i,j)=mdmx(j,i)
CMWS               do n=ini,ifi
CMWS                  if (n==i.or.n==j) cycle
CMWS                  PP=mdmx(i,n)
CMWS                  mdmx(i,n)=PP*COSA+mdmx(j,n)*SINA
CMWS                  mdmx(j,n)=mdmx(j,n)*COSA-PP*SINA
CMWS                  mdmx(n,i)=mdmx(i,n)
CMWS                  mdmx(n,j)=mdmx(j,n)
CMWS               enddo
CMWSC --- Y Direct
CMWS               P6=rijy*P2
CMWS               mdmy(i,i)=riiy*P3+rjjy*P4+P6
CMWS               mdmy(j,j)=riiy*P4+rjjy*P3-P6
CMWS               mdmy(j,i)=(rjjy-riiy)*P1+rijy*P5
CMWS               mdmy(i,j)=mdmy(j,i)
CMWS               do n=ini,ifi
CMWS                  if (n==i.or.n==j) cycle
CMWS                  PP=mdmy(i,n)
CMWS                  mdmy(i,n)=PP*COSA+mdmy(j,n)*SINA
CMWS                  mdmy(j,n)=mdmy(j,n)*COSA-PP*SINA
CMWS                  mdmy(n,i)=mdmy(i,n)
CMWS                  mdmy(n,j)=mdmy(j,n)
CMWS               enddo
CMWSC --- Z Direct
CMWS               P6=rijz*P2
CMWS               mdmz(i,i)=riiz*P3+rjjz*P4+P6
CMWS               mdmz(j,j)=riiz*P4+rjjz*P3-P6
CMWS               mdmz(j,i)=(rjjz-riiz)*P1+rijz*P5
CMWS               mdmz(i,j)=mdmz(j,i)
CMWS               do n=ini,ifi
CMWS                  if (n==i.or.n==j) cycle
CMWS                  PP=mdmz(i,n)
CMWS                  mdmz(i,n)=PP*COSA+mdmz(j,n)*SINA
CMWS                  mdmz(j,n)=mdmz(j,n)*COSA-PP*SINA
CMWS                  mdmz(n,i)=mdmz(i,n)
CMWS                  mdmz(n,j)=mdmz(j,n)
CMWS               enddo
CMWS
CMWS            enddo
CMWS         enddo
CMWSC
CMWS         k=ifi-ini+1
CMWS         SumD=SumD+Delta*fac*fac
CMWS         QQ=dsqrt(2d0*Delta/(k*(k-1)))
CMWSC
CMWS         if (mod(m,nprtcyc)==0) then
CMWS            Sec=CPUTim(0)-Tim1
CMWS            write(io,702)m,SumD,Delta,QQ,Sec
CMWS            call flshbf(io)
CMWS         endif
CMWSC
CMWS         if (dabs(QQ)<eps) then
CMWS            write(io,707)
CMWS            write(io,701) m
CMWS            ierr=0
CMWS            exit
CMWS         endif
CMWSC
CMWS         if (m==maxcyc) then
CMWS            ierr=1
CMWS            write(io,707)
CMWS            write(io,703) m
CMWS         endif
CMWS200   enddo
CMWSC
CMWS      write(io,'('' Final Localization Sum (Debye^2) ='',f16.6)') SumD
CMWS      Sec=CPUTim(0)-Tim
CMWS      NMin=Sec/60
CMWS      Sec=Sec-NMin*60
CMWS      write(io,704) NMin,Sec
CMWSC
CMWS      if (nprint==1) then
CMWS         write(io,*) '+++ Localized MOs by Boys Localization +++'
CMWS         call NJ_prtcol2(io,nbs,nmo,smo,ini,ifi,'f11.6')
CMWS      endif
CMWS      call flshbf(io)
CMWSC
CMWS 700  format(
CMWS     & '  Iter        Loc-Sum     Delta-Sum     Orb-Change    Time')
CMWS 701  format(' Boys Localization Completed After',i11,' Cycle')
CMWS 702  format(i5,f17.7,2d14.5,f7.1,'s')
CMWS 703  format(' Boys Localization Failed After',i14,' Cycle')
CMWS 704  format(' Localization CPU Time: ',i6,' minutes',f5.1,' seconds')
CMWS 707  format(1x,58('-'))
CMWSC
CMWS      end
C
CMWSC
CMWSC --- Begin Pipek-Mezey Localization
CMWSC --- 2006.02.18 update
CMWSC --- 2006.02.25 update
CMWSC --- 2006.02.27 update   epst 12->13
CMWS      subroutine NJ_poploc(io,nat,nbs,nmo,ini,ifi,smo,sov,tbs,
CMWS     &     eps,epst,maxcyc,nprint,np,ierr)
CMWS      implicit none
CMWS      integer io,nat,nbs,nmo,ini,ifi,tbs(nbs),maxcyc,nprint,np,ierr
CMWS      integer i,j,k,l,m,n,maxcycle,nprtcyc,NMin
CMWS      double precision smo(nbs,nmo),sov(nbs,nbs),eps,PP,QQ,P1,P2,P3
CMWS      double precision P4,P5,P6
CMWS      double precision Tim,Tim1,CPUTim,Sec,Delta,Aij,Bij,piik,pijk
CMWS      double precision pjjk,epst
CMWS      double precision SINA,COSA,SIN2A,COS2A,SIN4A,COS4A,TT,SumD
CMWS      external CPUTim
CMWS      real*8,dimension(:,:,:),allocatable::POP
CMWSC
CMWS      Tim=CPUTim(0)
CMWS      nprtcyc=10
CMWS      if (eps<=1d-16) eps=1d-7
CMWS      if (epst<=1d-16) epst=1d-13
CMWSC
CMWS      maxcycle=maxcyc
CMWS      if (maxcyc<=0) maxcycle=10000
CMWS      write(io,*) 'Localization Program by W. Li and S. Li '
CMWS     &          //'in Nanjing University on May 2007'
CMWS      write(io,'('' Pipek-Mezey Localization of MOs:'',i4,'' -->'',i4)')
CMWS     &      ini,ifi
CMWS      write(io,'('' Maxcycle ='',i8)') maxcycle
CMWS      write(io,'('' Threshold (Converg,Rotation) ='',2d11.2)') eps,epst
CMWSC
CMWSC --- Calc population ---
CMWS      allocate(POP(ini:ifi,ini:ifi,nat))
CMWS      call NJ_calpop(io,nat,nbs,nmo,ini,ifi,smo,sov,tbs,POP,np,ierr)
CMWSC
CMWS      SumD=0d0
CMWS      do i=ini,ifi
CMWS         do k=1,nat
CMWS            SumD=SumD+POP(i,i,k)*POP(i,i,k)
CMWS         enddo
CMWS      enddo
CMWSC
CMWS      write(io,'('' Initial Localization Sum ='',f16.6)') SumD
CMWS      write(io,707)
CMWS      write(io,700)
CMWS      write(io,707)
CMWS      call flshbf(io)
CMWSC
CMWS      do 200 m=1,maxcycle
CMWS         if (mod(m,nprtcyc)==1) Tim1=CPUTim(0)
CMWS         Delta=0d0
CMWS         do i=ini,ifi-1
CMWS            do j=i+1,ifi
CMWS               Aij=0d0; Bij=0d0
CMWS               do k=1,nat
CMWS                  piik=POP(i,i,k)
CMWS                  pjjk=POP(j,j,k)
CMWS                  pijk=POP(j,i,k)
CMWSC
CMWS                  P1=piik-pjjk
CMWS                  Aij=Aij+pijk*pijk-P1*P1/4d0
CMWS                  Bij=Bij+pijk*P1
CMWS               enddo
CMWS               if (dabs(Aij)<1d-10.and.dabs(Bij)<1d-10) cycle
CMWSC
CMWS               P1=dsqrt(Aij*Aij+Bij*Bij)
CMWS               COS4A=-Aij/P1
CMWS               SIN4A=Bij/P1
CMWSC
CMWS               COS2A=dsqrt((1d0+COS4A)/2d0)
CMWS               SIN2A=dsqrt((1d0-COS4A)/2d0)
CMWS               COSA=dsqrt((1d0+COS2A)/2d0)
CMWS               SINA=dsqrt((1d0-COS2A)/2d0)
CMWS               if (SIN4A<0d0) then
CMWS                  COS2A=-COS2A
CMWS                  TT=COSA
CMWS                  COSA=SINA
CMWS                  SINA=TT
CMWS               endif
CMWSC
CMWS               if (dabs(COSA-1d0).lt.epst) cycle
CMWS               if (dabs(SINA-1d0).lt.epst) cycle
CMWSC
CMWS               PP=P1*(1d0-COS4A)
CMWS               Delta=Delta+PP
CMWSC
CMWS               do k=1,nbs
CMWS                  TT=smo(k,i)
CMWS                  smo(k,i)=COSA*TT+SINA*smo(k,j)
CMWS                  smo(k,j)=COSA*smo(k,j)-SINA*TT
CMWS               enddo
CMWSC
CMWS               P2=SIN2A
CMWS               P1=P2/2d0
CMWS               P3=(1d0+COS2A)/2d0
CMWS               P4=(1d0-COS2A)/2d0
CMWS               P5=COS2A
CMWS               do k=1,nat
CMWS                  piik=POP(i,i,k)
CMWS                  pjjk=POP(j,j,k)
CMWS                  pijk=POP(j,i,k)
CMWS                  P6=pijk*P2
CMWS                  POP(i,i,k)=piik*P3+pjjk*P4+P6
CMWS                  POP(j,j,k)=piik*P4+pjjk*P3-P6
CMWS                  POP(j,i,k)=(pjjk-piik)*P1+pijk*P5
CMWS                  POP(i,j,k)=POP(j,i,k)
CMWSC
CMWS                  do n=ini,ifi
CMWS                     if (n==i.or.n==j) cycle
CMWS                     PP=POP(i,n,k)
CMWS                     POP(i,n,k)=PP*COSA+POP(j,n,k)*SINA
CMWS                     POP(j,n,k)=POP(j,n,k)*COSA-PP*SINA
CMWS                     POP(n,i,k)=POP(i,n,k)
CMWS                     POP(n,j,k)=POP(j,n,k)
CMWS                  enddo
CMWS               enddo
CMWS            enddo
CMWS         enddo
CMWSC
CMWS         k=ifi-ini+1
CMWS         SumD=SumD+Delta
CMWS         QQ=dsqrt(2d0*Delta/(k*(k-1)))
CMWSC
CMWS         Sec=CPUTim(0)-Tim1
CMWSC
CMWS         if (mod(m,nprtcyc)==0) then
CMWS            Sec=CPUTim(0)-Tim1
CMWS            write(io,702)m,SumD,Delta,QQ,Sec
CMWS            call flshbf(io)
CMWS         endif
CMWSC
CMWS         if (dabs(QQ)<eps) then
CMWS            write(io,707)
CMWS            write(io,701) m
CMWS            ierr=0
CMWS            exit
CMWS         endif
CMWSC
CMWS         if (m==maxcyc) then
CMWS            ierr=1
CMWS            write(io,707)
CMWS            write(io,703) m
CMWS         endif
CMWS200   enddo
CMWSC
CMWS      write(io,'('' Final Localization Sum ='',f16.6)') SumD
CMWS      Sec=CPUTim(0)-Tim
CMWS      NMin=Sec/60
CMWS      Sec=Sec-NMin*60
CMWS      write(io,704) NMin,Sec
CMWSC
CMWS      deallocate(POP)
CMWSC
CMWS      if (nprint==1) then
CMWS         write(io,*) '+++ Localized MOs by Pipke-Mezey Localization +++'
CMWS         call NJ_prtcol2(io,nbs,nmo,smo,ini,ifi,'f11.6')
CMWS         write(io,*)
CMWS      endif
CMWSC
CMWS 700  format(
CMWS     & '  Iter        Loc-Sum     Delta-Sum     Orb-Change    Time')
CMWS 701  format(' PM Localization Completed After',i5,' Cycle')
CMWS 702  format(i5,f17.7,2d14.5,f7.1,'s')
CMWS 703  format(' PM Localization Failed After',i8,' Cycle')
CMWS 704  format(' Localization CPU Time: ',i6,' minutes',f5.1,' seconds')
CMWS 707  format(1x,58('-'))
CMWSC
CMWS      end
C
CMWSC --- 2006.02.18 update
CMWS      subroutine NJ_calpop(io,nat,nbs,nmo,ini,ifi,smo,sov,tbs,POP,
CMWS     &    np,ierr)
CMWS      implicit none
CMWS      integer io,nat,nbs,nmo,ini,ifi,i,j,k,l,m,n,ij,tbs(nbs),np,ierr
CMWS      double precision smo(nbs,nmo),sov(nbs,nbs)
CMWS      double precision POP(ini:ifi,ini:ifi,nat),PP,P1
CMWSC
CMWS      POP=0d0
CMWS      do i=ini,ifi
CMWS         do j=i,ifi
CMWS            do k=1,nbs
CMWS               m=tbs(k)
CMWS               do l=1,nbs
CMWS                  n=tbs(l)
CMWS                  PP=smo(k,i)*smo(l,j)*sov(k,l)/2d0
CMWS                  POP(j,i,m)=POP(j,i,m)+PP
CMWS                  POP(j,i,n)=POP(j,i,n)+PP
CMWS               enddo
CMWS            enddo
CMWS         enddo
CMWS      enddo
CMWSC
CMWS      do i=ini,ifi-1
CMWS         do j=i+1,ifi
CMWS            do k=1,nbs
CMWS               m=tbs(k)
CMWS               POP(i,j,m)=POP(j,i,m)
CMWS            enddo
CMWS         enddo
CMWS      enddo
CMWSC
CMWS      end
C

CMWSc     ##############################################################
CMWSc     ##  subroutine NJ_xyznum  --  count the num of atoms        ##
CMWSc     ##  2005.03.16 by Wei Li; Update 2005.10.16 by Wei Li       ##
CMWSc     ##############################################################
CMWSc
CMWSc     Need 'function elemord(aa)' in element.f
CMWSC     2006.06.08-09 Modified
CMWS
CMWS      subroutine GMSNAT(io,xyz,i)
CMWS      implicit none
CMWS      integer io,xyz,nat,i,j,k,elemord
CMWS      real*8 x,y,z,zz
CMWS      character aa*2,line*100
CMWS      external elemord
CMWS
CMWS      rewind(xyz)
CMWS      i=0
CMWS      do
CMWS         read(xyz,'(a)',end=999) line
CMWS         read(line,*,err=100,end=100) aa,zz,x,y,z
CMWS         k=ichar(aa(1:1))
CMWS         if (k<65.or.(k>90.and.k<97).or.k>122) goto 110
CMWS         k=ichar(aa(2:2))
CMWS         if (k.ne.32.and.(k<65.or.(k>90.and.k<97).or.k>122)) goto 110
CMWS         j=elemord(aa)
CMWS         if (j.ne.0) i=i+1
CMWS         cycle
CMWS 110     if (i>0) exit
CMWS 100  enddo
CMWS
CMWS 999  if (io>0) then
CMWS          write(io,*) 'Number of atoms:',i
CMWS          write(io,*)
CMWS      endif
CMWS
CMWS      end

CMWSc     ##############################################################
CMWSc     ##  subroutine NJ_xyzgeom  --  read xyz cooedinates         ##
CMWSc     ##  2005.03.16 by Wei Li; Update 2005.10.16 by Wei Li       ##
CMWSc     ##############################################################
CMWSc
CMWSc     if iau=0 in angstrom; else in a.u.
CMWSc
CMWS      subroutine GMSXYZ2(io,xyz,nat,nuchar,coor,iau)
CMWS      implicit none
CMWS      integer io,xyz,nat,i,j,k,elemord,iau,nh
CMWS      real*8 coor(3,nat),nuchar(nat),x,y,z,zz
CMWS      character aa*2,elemsyl*2,line*100
CMWS      external elemord,elemsyl
CMWS
CMWS      coor=0d0; nuchar=0d0
CMWS      rewind(xyz)
CMWS      i=0; nh=0
CMWS      do
CMWS         read(xyz,'(a)',end=999) line
CMWS         read(line,*,err=100,end=100) aa,zz,x,y,z
CMWS         k=ichar(aa(1:1))
CMWS         if (k<65.or.(k>90.and.k<97).or.k>122) cycle
CMWS         k=ichar(aa(2:2))
CMWS         if (k.ne.32.and.(k<65.or.(k>90.and.k<97).or.k>122)) cycle
CMWS         if (elemord(aa).eq.0) cycle
CMWS!        write(77,'(a)') line(1:70)
CMWS         if (aa=='H'.or.aa=='h') nh=nh+1
CMWS         i=i+1
CMWSC        nuchar(i)=elemord(aa)
CMWS         nuchar(i)=zz
CMWS         coor(1,i)=x
CMWS         coor(2,i)=y
CMWS         coor(3,i)=z
CMWS         if (i>=nat) exit
CMWS 100  enddo
CMWS
CMWS
CMWS 500  if (io>0) then
CMWS         if (iau==0) then
CMWS            write(io,*) 'Table: Cartesian Coordinates in angstrom'
CMWS         else
CMWS            write(io,*) 'Table: Cartesian Coordinates in a.u.'
CMWS         endif
CMWS         write(io,'(1x,54(''=''))')
CMWS         write(io,*) ' Atom           X               Y               Z'
CMWS         write(io,'(1x,54(''-''))')
CMWS         write(io,'(2x,a2,2x,3f16.8)') (elemsyl(nint(nuchar(i))),
CMWS     &        (coor(j,i),j=1,3),i=1,nat)
CMWS         write(io,'(1x,54(''=''))')
CMWS         write(io,'(''  N<atoms> (all, non-H and H) are'',3i6)')
CMWS     &        nat,nat-nh,nh
CMWS         write(io,*)
CMWS      endif
CMWS!     write(77,*)
CMWS      return
CMWS
CMWS 999  stop 'GMSXYZ(): Not enough coordinates in files'
CMWS      end
C
C-WL- 09 SEP 2009 FOR SELECTING THE LEVEL OF CALCULATIONS FOR ATOMS
      subroutine ATOMLEVL(io,nat,link,nuchar,CIMATM,atmlevl)
      implicit none
      integer io,nat,i,j,ii,jj
      integer atmlevl(nat),link(nat,nat)
      real*8 nuchar(nat)
      character aa*2,line*100,cctyp*8
      character*8 mthd,CIMATM(nat)
C
      do i=1,nat
         mthd=CIMATM(i)
         if (mthd.eq.'MP2     ') then
            atmlevl(i)=1
         elseif (mthd.eq.'CCD     ') then
            atmlevl(i)=2
         elseif (mthd.eq.'CCSD    ') then
            atmlevl(i)=3
         elseif (mthd.eq.'CCSD(T) ') then
            atmlevl(i)=4
         elseif (mthd.eq.'CR-CCL  ') then
            atmlevl(i)=5
         else
            atmlevl(i)=0
         endif
      enddo

      do i=1,nat
         ii=nint(nuchar(i))
         if (ii.ne.1) cycle
         do j=1,nat
            jj=nint(nuchar(j))
            if (jj.eq.1) cycle
            if (link(j,i).ne.0) then
               atmlevl(i)=atmlevl(j)
            endif
         enddo
      enddo

      if (io>0) then
          write(io,*) '+++ The level of calculations for atoms +++'
          write(io,'(4(3x,5i3))') (atmlevl(i),i=1,nat)
          write(io,*)
      endif

      end

CMWSc     ##############################################################
CMWSc     ##  subroutine NJ_lower  --  make a string lowercase        ##
CMWSc     ##  2004.04.16 by Wei Li; Update 2005.10.17 by Wei Li       ##
CMWSc     ##############################################################
CMWSc
CMWS      subroutine NJ_lower(line)
CMWS      implicit none
CMWS      integer i,k,ich
CMWS      character line*(*)
CMWS
CMWS      k=len(line)
CMWS      do i=1,k
CMWS         ich=ichar(line(i:i))
CMWS         if (ich.ge.65.and.ich.le.90) line(i:i)=char(ich+32)
CMWS      enddo
CMWS
CMWS      end

c     ##############################################################
c     ##  subroutine NJ_upper  --  make a string uppercase        ##
c     ##  2004.04.16 by Wei Li; Update 2005.10.17 by Wei Li       ##
c     ##############################################################
c
      subroutine NJ_upper(line)
      implicit none
      integer i,k,ich
      character line*(*),ch

      k=len(line)
      do i=1,k
         ich=ichar(line(i:i))
         if (ich.ge.97.and.ich.le.122)  then
            line(i:i)=char(ich-32)
         endif
      enddo

      end
C*MODULE CIMI    *DECK ELEMSYL
C>
C>   @brief   define periodic table
C>
C>   @details this routine should not be used! SETLAB does this.
C>
c     ##############################################################
c     ##  function elemsyl  --  element: order --> symbol         ##
c     ##  2004.12.22 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################
C
      character*2 function elemsyl(n)
      implicit none
      integer n
      character*2 elem(109)

      data elem/'H ','He','Li','Be','B ',  'C ','N ','O ','F ','Ne',
     &          'Na','Mg','Al','Si','P ',  'S ','Cl','Ar','K ','Ca',
     &          'Sc','Ti','V ','Cr','Mn',  'Fe','Co','Ni','Cu','Zn',
     &          'Ga','Ge','As','Se','Br',  'Kr','Rb','Sr','Y ','Zr',
     &          'Nb','Mo','Tc','Ru','Rh',  'Pd','Ag','Cd','In','Sn',
     &          'Sb','Te','I ','Xe','Cs',  'Ba','La','Ce','Pr','Nd',
     &          'Pm','Sm','Eu','Gd','Tb',  'Dy','Ho','Er','Tm','Yb',
     &          'Lu','Hf','Ta','W ','Re',  'Os','Ir','Pt','Au','Hg',
     &          'Tl','Pb','Bi','Po','At',  'Rn','Fr','Ra','Ac','Th',
     &          'Pa','U ','Np','Pu','Am',  'Cm','Bk','Cf','Es','Fm',
     &          'Md','No','Lr','Rf','Db',  'Sg','Bh','Hs','Mt'/

      if (n>0.and.n<110) then
         elemsyl=elem(n); return
      else
         write(*,*) 'Wrong nuclear charges for',n
         call abrt
         stop
      endif

      end

CMWS****** 2004.12.22 element: symbol --> order ******
CMWSc     ##############################################################
CMWSc     ##  function elemord  --  element: symbol --> order         ##
CMWSc     ##  2004.12.22 by Wei Li; Update 2005.10.16 by Wei Li       ##
CMWSc     ##############################################################
CMWSC
CMWS      function elemord(a)
CMWS      implicit none
CMWS      integer elemord,i,j,k,l,ich
CMWS      character a*(*),aa*2,elem(109)*2
CMWS
CMWS      data elem/'H ','He','Li','Be','B ',  'C ','N ','O ','F ','Ne',
CMWS     &          'Na','Mg','Al','Si','P ',  'S ','Cl','Ar','K ','Ca',
CMWS     &          'Sc','Ti','V ','Cr','Mn',  'Fe','Co','Ni','Cu','Zn',
CMWS     &          'Ga','Ge','As','Se','Br',  'Kr','Rb','Sr','Y ','Zr',
CMWS     &          'Nb','Mo','Tc','Ru','Rh',  'Pd','Ag','Cd','In','Sn',
CMWS     &          'Sb','Te','I ','Xe','Cs',  'Ba','La','Ce','Pr','Nd',
CMWS     &          'Pm','Sm','Eu','Gd','Tb',  'Dy','Ho','Er','Tm','Yb',
CMWS     &          'Lu','Hf','Ta','W ','Re',  'Os','Ir','Pt','Au','Hg',
CMWS     &          'Tl','Pb','Bi','Po','At',  'Rn','Fr','Ra','Ac','Th',
CMWS     &          'Pa','U ','Np','Pu','Am',  'Cm','Bk','Cf','Es','Fm',
CMWS     &          'Md','No','Lr','Rf','Db',  'Sg','Bh','Hs','Mt'/
CMWS
CMWS      elemord=0
CMWS      aa=a
CMWS      ich=ichar(aa(1:1))
CMWS      if (ich.ge.97.and.ich.le.122) aa(1:1)=char(ich-32)
CMWS      ich=ichar(aa(2:2))
CMWS      if (ich.ge.65.and.ich.le.90) aa(2:2)=char(ich+32)
CMWS
CMWS      do i=1,109
CMWS         if (aa==elem(i)) then
CMWS            elemord=i; return
CMWS         endif
CMWS      enddo
CMWS
CMWSC      write(*,*) 'Wrong element symbols for ',aa; stop
CMWS      end

CMWSc     ##############################################################
CMWSc     ##  subroutine NJ_blank -- find the n-th blank, LN=0 if no  ##
CMWSc     ##  2005.04.12 by Wei Li; Update 2005.10.16 by Wei Li       ##
CMWSc     ##############################################################
CMWSc
CMWS****** 2005.4.12 if no LN=0
CMWS      subroutine  NJ_blank(Inp,n,LN)
CMWS      character line*100
CMWS      external Nchar
CMWS
CMWS      rewind(Inp); Nct=0; LN=0
CMWS
CMWS      do 100 k=1,100000
CMWS         read(Inp,'(a)',err=110,end=110) line
CMWS         LN=LN+1
CMWS         i=Nchar(line,1,100)
CMWS         if (i.eq.0) Nct=Nct+1
CMWS         if (Nct.eq.n) return
CMWS 100  enddo
CMWS
CMWS 110  LN=0
CMWS      end

CMWSC     2004.04.16 find number of no-blank char in line(ini:ifi)(length<=100) #liwei@itcc
CMWS      function Nchar(line,ini,ifi)
CMWS      character line*(*)
CMWS      Nchar=0
CMWS      do i=ini,ifi
CMWS         if (line(i:i).ne.' ') Nchar=Nchar+1
CMWS      enddo
CMWS
CMWS      end

c     ##############################################################
c     ##  subroutine NJ_seekkey  --  Seek key line with ch first  ##
c     ##  2004.12.24 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################
c
      subroutine NJ_seekkey(inp,kch,key,yes)
      implicit none
      integer inp,i,j,k,back,yes,ith,kth
      character key*(*),line*256,kch*(*)

      yes=0
      back=0
      ith=len(key)
      kth=len(kch)
      call NJ_upper(key)
      call NJ_upper(kch)
 200  do
         read(inp,'(a)',err=800,end=800) line
         call NJ_upper(line)
         do j=1,256
            if(line(j:j).ne.' ') exit
         enddo
         if (j>256) cycle
         k=index(line(j:256),key(1:ith))
         if (line(j:j+kth-1)==kch(1:kth).and.k.ne.0) then
            backspace(inp); yes=1; return
         endif
      enddo

 800  if (back==0) then
         rewind(inp); back=1; goto 200
      endif
      end
C
C ----------------------------------------------------------------------
C --- BASED ON ccdN4.for. FROM 2001.4.1 TO 2001.4.6.
C --- 2007.06.02 CIM-MP2 program ---
*
* --- LIST OF INPUT DATA ---
*     io:     Unit of output file
*     NATOM:  Number of atoms
*     NW:     Number of basis functions
*     NUW:    Number of occupied MOs
*     Nmo:    The number of MOs
*     nfocc:  The number of frozen occ MOs
*     nfvir:  The number of frozen vir MOs
*     conv:   Convergence threshold of iterative MP2 (default: conv=6)
*     basis:  Basis set
*     gmsname:File name for creating files
*     kmem:   Maximum memory for integrals transformation (unit: Words, e.g. 8 Bytes)
*     EIGEN(Nmo):    Alpha MOs eigenvalues
*     SMO(Nmo,Nmo):  Alpha MOs coefficients
*     admx(NW,NW):   AO dipole moment integrals in X-direct
*     admy(NW,NW):   AO dipole moment integrals in Y-direct
*     admz(NW,NW):   AO dipole moment integrals in Z-direct
*     tbs(NW):       Atomic label for basis
*     nuchar(NATOM): Nuclear charges
*     coor(3,NATOM): Cartesian coordinates
*     SOVER(NW,NW):  AO overlap matrix
*     FK(Nmo,Nmo):   AO Fock matrix
*     FIJ(NUW,NUW):  MO Fock matrix    ! 2008.07.25 Nmo --> NUW
*
* --- LIST OF INPUT DATA ---
*     EE: calculated correlation energy
*
* --- LIST OF LOCAL VARIABLES ---
*     NU:     The number of occ MOs
*     NV:     The number of vir MOs
*     NCORE:  The same as nfocc
*     maxbs:  The number of basis functions of the largest clusters
*     NAB:    The same as NUW
*     KG:     The number of reduced central domains
*     KGG:    The number of reduced full domains
*     numc:   The number of non-hydrogen atoms
*     numh:   The number of hydrogrn atoms
*     WRK(1)=ZT1:  The threshold of selecting MOs for a central MO (default: 0.003)
*     WRK(2)=ZT2:  The threshold of selecting environmental domain (default: 1.0)
*     WRK(3)=ZT3:  The threshold of determining the atoms of LMOs  (default: 0.99)
*     WRK(4)=ZT4:  The threshold of constructing virtual LMOs (default: 0.2)
*     WRK(5)=RE0:  The threshold of adding buffer atoms (default: 4/AA)
*     WRK(6)=eps:  The threshold of MP2 iteration (not available now)
*
*     ED(NUW):           The correlation energy of each occupied LMO
*     NCLU(NUW):         The calculated times of each occupied LMO
*     SR(NATOM,Nmo):     Sorted Mulliken population of basis in atoms
*     SR1(NATOM,Nmo):    Unsorted Mulliken population of basis in atoms
*     dis(NATOM,NATOM):  Distance matrix of atoms
*     link(NATOM,NATOM): Link matrix of atoms (0 or 1)
*     link2(NATOM,NATOM):Bond distance matrix of atoms (the minimum bonds between two atoms)
*                        e.g. for C(1)-C(2)-C(3) link2(1,3)=2 (two bonds)
*     SNB(NUW):          The number of atoms for the occupied LMOs
*     SOB(NATOM,NUW):    The labels of atoms for the occupied LMOs
*     ISUB(NUW):         The number of MOs in the central domain
*     ISUB2(NUW):        The number of central MOs in the central domain
*     ISUB3(NUW):        The number of central MOs in the full domain
*     ISUB4(NUW):        The number of MOs in the full domain
*     NB(NATOM):         The first basis function of each atom
*     natc(NATOM):       The labels of all non-hydrogen atoms
*     nath(NATOM):       The labels of all hydrogen atoms
*     NAsub(NUW):        The number of atoms in the full atomic domain
*     NWsub(NUW):        The number of basis function in the full atomic domain
*     INF(NUW,NUW):      The labels of MOs in the central domain
*     INF2(NUW,NUW):     The labels of MOs in the full domain
*     BA(NATOM,NUW):     The labels of atoms in the full domain
*     ZA(NATOM,NUW):     The labels of basis functions in the full domain
*
      SUBROUTINE CIMMP2(io,inp,isys,NATOM,NW,NUW,Nmo,nfocc,nfvir,
     &           SMO,FIJ,FK,SOVER,admx,admy,admz,tbs,nuchar,coor,basis,
     &           gmsname,kmem,EE,scftyp,mplevl,cctyp,istop,
     &           job,
     &           NOB,FKB,atmlevl,atmgrp,path,user,NCBS,CBAS,
     *           nsubsystems,IWORK,RWORK,CWORK,LWORK) !-WL- 2009.09.09
      implicit none
      integer nsubsystems
      double precision ZERO,ONE,TWO
      parameter (ZERO=0.0D+00,ONE=1.0D+00,TWO=2.0D+00)
      integer io,inp,NATOM,NW,NUW,Nmo,nfocc,nfvir,i,j,k,L,m,n,NCORE
      integer k1,k2,k3,k4,k5,maxbs,istop,itmp,KCA,KCB,KOA,KOB,isys,job
      parameter(itmp=115)
      integer tbs(NW),NAB,KG,KGG,numc,numh,kmem,imethd
      character basis*30,gmsname*100,mthd*20,line*100,path*200,user*50
      character scftyp*8,cctyp*8,key8*8,key6*6
      character(len=8),dimension(:),allocatable:: scftyps
      integer mplevl,ngroup,nfg2
      integer NUTT,NVTT,namp,NAMPT,NAMPTT
      integer namps,NAMPTs,NAMPTTs
      integer nampd,NAMPTd,NAMPTTd
      integer iyes,NCBS(NATOM)
      character(len=100) CBAS(100,NATOM)
C
      integer IWORK(100)
      double precision RWORK(100)
      character(len=8) CWORK(100),METHDS(0:5),METHOD
      logical(kind=8) LWORK(100)
C
      double precision PP,EE,eps,ECC,ETC
      double precision ETC1,ETC2
      double precision FIJ(NUW,NUW),SOVER(NW,NW),SMO(NW,Nmo)
      double precision nuchar(NATOM),coor(3,NATOM),FK(NW,NW),FKB(NW,NW)
      double precision admx(NW,NW),admy(NW,NW),admz(NW,NW)
C     double precision HCORE(NW,NW)  !-WL- 2007.10.16 add; 2007.10.23 delete
C
!     double precision,dimension(:),allocatable::TC,TT
      double precision,dimension(:),allocatable::ED,EMO
      double precision,dimension(:),allocatable::ECCA,ECCB,ETCA,ETCB
      double precision,dimension(:,:),allocatable::SR,SR1,dis,FF,EF,FXY
      integer,dimension(:),allocatable::SNB,ISUB,ISUB2,ISUB3,ISUB4,ISUB5
      integer,dimension(:),allocatable::NB,NASUB,NWSUB,natc,nath,NCLU
      integer,dimension(:,:),allocatable::SOB,INF,INF2,BA,ZA,link,link2
      integer,dimension(:),allocatable::NCLA,NCLB,KSymm,NF0,NF1,used
      integer,dimension(:,:),allocatable::group,FRG,CenMO
C
      integer nc,no,nu,nbs,no2u4,no3u4,no2,no3,nu4,memtot
      double precision time1,time2,timex,timet1,timet2,timet3
      double precision timett1,timett2,timett3,ratio2,ratiot,timtot
      double precision,dimension(:),allocatable:: xtime
      integer,dimension(:),allocatable::JOBX,molevl,mtdsys,mxno,mbrams
      double precision,dimension(:),allocatable::zt
      integer KGG2,idx,jdx,NSYGEN,NSYTOT
C
      integer (kind=4) Wall0,Wall,TIME,ieof
      real*8 Tim0,CPUTim
      external dtrace2,CPUTim !,TIME
C
      integer NOA,NOB  !-WL- NOA/NOB is the number of alpha/beta electrons
      integer atmlevl(NATOM),atmgrp(NATOM)
      double precision xo2u4,xo3u4,xo1w4
      double precision yo2u4,yo3u4,yo1w4,ytime(5)
      integer memgms,MBRAM(5),NERR
      external memgms
C
      METHDS(0) = 'NONE    '
      METHDS(1) = 'MP2     '
      METHDS(2) = 'CCD     '
      METHDS(3) = 'CCSD    '
      METHDS(4) = 'CCSD(T) '
      METHDS(5) = 'CR-CCL  '
C
      NCORE=nfocc
      NAB=NUW
      NOA=NUW

      NUTT=NUW-NCORE
      NVTT=Nmo-NUW
C
      if (nfvir.ne.0) then
         write(io,*) 'Freezing virtual MOs not available in CIM'
         call abrt
      endif
C
      Tim0=CPUTim(0)
C     Wall0=TIME()
C
C     if (io>0) then
C        call NJ_date(io,'CIM calculation begin from:')
C        WRITE(io,'('' The number of frozen occ.&vir MOs ='',2i4)')
C    &                 nfocc,nfvir
C        write(io,'('' Threshold for conv ='',d12.5)') RWORK(6)  ! CCONV (default: 1E-6)
C        write(io,*)
C        call flshbf(io)
C     endif
C ----------------------------------------------------------------------
      allocate(SR(NATOM,Nmo),SR1(NATOM,Nmo),SNB(NUW),SOB(Nmo,NATOM))
      allocate(INF(NUW,NUW),INF2(NUW,NUW),ISUB(NUW),ISUB2(NUW))
      allocate(ISUB3(NUW),ISUB4(NUW),BA(NATOM,NUW),ZA(NW,NUW),NB(NATOM))
      allocate(NASUB(NUW),NWSUB(NUW),natc(NATOM),nath(NATOM),ED(NUW))
      allocate(dis(NATOM,NATOM),link(NATOM,NATOM),link2(NATOM,NATOM))
      allocate(NCLU(NUW),KSymm(NUW),group(NATOM,NATOM))
      SR=0d0; SR1=0d0; SNB=0; SOB=0; INF=0; INF2=0; ISUB=0; ISUB2=0
      ISUB3=0; ISUB4=0; BA=0; ZA=0; NB=0; NASUB=0; NWSUB=0
      natc=0; nath=0; dis=0d0; link=0; link2=0; ED=0d0; NCLU=0
      group=0
      allocate(mxno(NATOM),zt(NATOM))
      mxno=IWORK(4)  ! max number of occ MOs in a subsystems (default: 1000)
      zt=RWORK(3)
      allocate(ECCA(NUW),ECCB(NUW),ETCA(NUW),ETCB(NUW))
      allocate(NCLA(NUW),NCLB(NUW))
      ECCA=0.0D+00
      ECCB=0.0D+00
      ETCA=0.0D+00
      ETCB=0.0D+00
      NCLA=0
      NCLB=0
      allocate(molevl(NUW))
C
C --- 1st basis of each atoms by sj
      do i=1,NW
         do j=1,NATOM
            if (tbs(i).eq.j.and.nb(j).eq.0) nb(j)=i
         enddo
      enddo
C     write(io,*) 'The first basis of each atom'
C     write(io,'(5i6,2x,5i6)') nb(1:NATOM)
C     write(io,*)
C --- natc(numc): non-hydrogen atoms; nath(numh): hydrogen atoms
      numc=0;numh=0
      do i=1,NATOM
         if (nint(nuchar(i)).ne.1) then
            numc=numc+1;natc(numc)=i
         else
            numh=numh+1;nath(numh)=i
         endif
      enddo
C --- the distance and linkage between atoms
      call NJ_dislink(0,NATOM,nuchar,coor,dis,link)
      call NJ_idis(NATOM,link,link2)
      link=link2
      deallocate(link2)
C
      key6='CIMFRG'
C     rewind(inp)
      call seqrew(inp)
      call NJ_seekkey(inp,'$',key6,iyes)

      write(io,*) 'ASSIGNING HYDROGEN ATOMS TO GROUPS'
      if (iyes.ne.0) then
         write(io,*) 'ATOM GROUPS WILL BE BUILT FROM $CIMFRG'
         call rdgroup(io,inp,NATOM,numc,numh,natc,nath,link,
     &        group,ngroup,atmlevl,mxno,zt,IWORK,methds,cwork(2))
      else
         write(io,*) 'CORRELATION METHOD SET BY SUBMTD AND $CIMATM'
         atmgrp=0
         call mkgroup(io,NATOM,numc,numh,natc,nath,link,group,ngroup,
     &        atmgrp,methds,atmlevl)
      endif
C
C --- Calculate Mulliken Population and The Atomic Labels for LMOs ---
      call CalMPop(io,NATOM,NW,NUW,NCORE,Nmo,SOVER,SMO,tbs,
     &     SR,SR1,SNB,SOB,nuchar,NOB,atmlevl,molevl,
     &     IWORK,RWORK,CWORK,LWORK) ! SNB=NMOAT SOB=MOIDNO in GAMESS (common EDCMP)
C
      if (IWORK(9).eq.0) then
C        call LS_toend(inp,0) ! 20 AUG 10 ADDED: goto the end of .cim file
         call ifind2(inp,'$MO-LEVEL')  ! 23 AUG 10
         call iwrit(inp,'$MO-LEVEL', NUW,   molevl(1))
      else
         call ifind2(inp,'$MO-LEVEL')
         call iread(inp,'$MO-LEVEL', NUW,   molevl(1))
      endif
C     write(io,*) '+++ The level of the calculations for LMOs +++'
C     write(io,'(4(3x,5i3))') (molevl(I),I=1,NUW)
C     write(io,*)
C     call flshbf(io)
C
      call NJ_tfock(0,NW,NUW,FK,SMO,FIJ)  ! 2008.02.29 add because the LMOs are sorted
C     write(io,*) '+++ Occ. Fock matrix of sorted LMOs +++'
C     call NJ_prtsym(io,NUW,FIJ,'f12.5')
C
      call SymmOrb2(io,Nmo,NCORE,NUW,FIJ,IWORK,RWORK,KSymm)
C
      allocate(FXY(NUW,NUW))
      if (IWORK(12).eq.1) then
         call FIJ2XY(io,NUW,FIJ,FXY)
      elseif (IWORK(12).eq.2) then
         call FIJ2XY2(io,NUW,FIJ,FXY)
      else
         call CopyFIJ(io,NUW,FIJ,FXY)
      endif
C
      allocate(FRG(NUW,ngroup),NF0(ngroup),FF(ngroup,ngroup))
      allocate(EF(NUW,ngroup))
      allocate(mtdsys(NUW))
      mtdsys=0
C
      if (IWORK(7).eq.0) then
       write(io,*) '--- CONSTRUCTING CENTRAL DOMAINS: ',cwork(1),' --- '
C        if (dabs(WRK(2)).ge.0.9999) then   !-WL- NEW SECIM
         if (CWORK(1).EQ.'SECIM   ' .or. CWORK(1).EQ.'GSECIM  ') then
            call mogroup(0,NATOM,NCORE,NUW,group,SR1,ngroup,Nmo,
     &           FRG,NF0,atmlevl,mtdsys(1),RWORK) ! 2008.08.11 WL mogroup->mogroup2; but changed to old 2008.08.12
            call envfock(io,Nmo,NUW,NCORE,FXY,ngroup,FRG,NF0,EF)
C
C ---       Build the central domains for each Occ spatial orbital ---
            call CentDomn(io,Nmo,NUW,NCORE,RWORK,FXY,INF,ISUB,ISUB2,
     &           KSymm,ngroup,FRG,NF0,EF,mxno(1),zt(1))  ! 2008.03.04 add KSymm
C           call ending
C           stop
C           call SYSLEVEL(io,NUW,ngroup,ISUB2,INF,molevl,mtdsys(1))
C ---       Compare the sizes of domains and eliminate small domains which are embedded in larger ones
            if (IWORK(13).eq.0) then
               call ReduDomn(io,NUW,NCORE,INF,ISUB,ISUB2,KG,ngroup,
     &                    mtdsys(1),IWORK)
            else
               KG=ngroup
            endif
C        else                              !-WL- OLD DECIM
         elseif (CWORK(1).EQ.'DECIM   ') then                         !-WL- DECIM
           call CentDomn1(io,Nmo,NUW,NCORE,RWORK,FXY,INF,ISUB,ISUB2,
     &                    KSymm) ! 2008.03.04 add KSymm
            mtdsys=0
            call SYSLEVEL(0,NUW,NUW,ISUB2,INF,molevl,mtdsys(1))
            call ReduDomn1(io,NUW,NCORE,INF,ISUB,ISUB2,KG,mtdsys(1),
     &                     IWORK)
         endif
C        write(io,'(1x,58(''-''))')
C        write(io,*) ' Domain No.   NOcc    Natom   Basis'
C        do i=1,nuw
C           if(mtdsys(i).eq.0) sysmtd='NONE    '
C           if(mtdsys(i).eq.1) sysmtd='MP2     '
C           if(mtdsys(i).eq.2) sysmtd='CCD     '
C           if(mtdsys(i).eq.3) sysmtd='CCSD    '
C           if(mtdsys(i).eq.4) sysmtd='CCSD(T) '
C           if(mtdsys(i).eq.5) sysmtd='CR-CCL  '
C           write(io,'(i6,4x,3i8,a8)')
C    *      i,ISUB4(i),NAsub(i),NWsub(i),sysmtd
C        enddo
C        write(io,*)

C ---    Build the environmental domain of the same spin for each retained Central Domain.
C        Reduce the nubmer of full domains after comparison.
         call FullDomn(io,isys,NATOM,NW,NMO,NUW,NCORE,SOB,SNB,BA,ZA,NB,
     &        NASUB,NWSUB,INF,INF2,ISUB,ISUB2,ISUB3,ISUB4,FXY,KG,
     &        KGG,mtdsys(1),IWORK,RWORK,CWORK,LWORK)
C
         call iwrit(isys,'$MO-LEVEL', NUW, molevl(1))
         call iwrit(isys,'$SYS-LEVEL', KGG, mtdsys(1))
      else
       write(io,*) '--- CENTRAL DOMAINS READ FROM CIMDMN ---'
         call ReadClu(0,isys,NUW,KGG,ISUB3,ISUB4,INF2)
         call iread(isys,'$MO-LEVEL', NUW, molevl(1))
         call iread(isys,'$SYS-LEVEL', KGG, mtdsys(1))
C
C        write(io,'(1x,58(''-''))')
C        write(io,*) ' Domain No.   NOcc    Natom   Basis'
         do I=1,KGG
            call COA(NATOM,NW,NMO,NUW,NB,SOB,SNB,INF2(1,I),ISUB4(I),
     &           NAsub(I),BA(1,I),NWsub(I),ZA(1,I))
C           write(io,'(i6,4x,3i8)') i,ISUB4(i),NAsub(i),NWsub(i)
         enddo
C        write(io,*)
      endif
C
      write(io,*)
      write(io,'(15x,18(''-''))')
      write(io,'(15x,"CIM DOMAIN SUMMARY")')
      write(io,'(15x,18(''-''))')
      write(io,*) ' Domain No.   NOcc    Natom   Basis   Method'
      do i=1,kgg
         write(io,'(i6,4x,3i8,5x,a8)') i,ISUB4(i),NAsub(i),NWsub(i),
     *      methds(mtdsys(i))
      enddo
      write(io,*)
      nsubsystems=kgg
      call flshbf(io)
C     write(io,*) '+++ The level of the calculations for subsys +++'
C     write(io,'(4(3x,5i3))') (mtdsys(i),i=1,KGG)
C     write(io,'(i2,'' - '',a8)') (i,METHDS(i),i=0,5)
C     WRITE(io,*)
      call iwrit(inp,'$SYS-LEVEL', KGG, mtdsys(1))
      call flshbf(io)
      call flshbf(inp)

C --- 2009.04.21 -WL- Sorting the orbitals by the index
      allocate(CenMO(NUW,KGG))
      call SortOcc(0,NUW,NOB,KGG,ISUB3,ISUB4,INF2,CenMO)
C
C --- 2009.10.28 -WL- Checking the missing atoms in BA ---
      allocate(used(NATOM))
      do i=1,NATOM
         used(i)=0
      enddo
      do i=1,KGG
         do j=1,NATOM
            k=BA(j,i)
            if (k.ne.0) used(k)=1
         enddo
      enddo
      k=0
      do i=1,NATOM
         if (used(i).ne.0) cycle
         write(io,*) 'Find missing atom:',i
         k=k+1
      enddo
      if (k.ne.0) then
         write(io,*) 'ERROR: The number of missing atoms is',k
         write(io,*) 'You may need to use small x in MLK=x'
         stop
      endif
      deallocate(used)
C
C --- 2005-11-20.
C     call NJ_date(io,'Constructing full domains over on:')
C     call NJ_cputim(io,Tim0)
C     call NJ_walltim(io,Wall0)
      write(io,*) '... FINISHED CONSTRUCTING CIM DOMAINS ...'
      call timit(1)
C     write(io,'(1x,58(''-''))')
      write(io,*)
      call flshbf(io)
C     if (istop.eq.1) stop
C     return
C
      if (IWORK(7).eq.1) IWORK(7)=0  !-WL- 2009.10.27 ADD for read occ MO only
C
      allocate(ISUB5(NUW),JOBX(KGG))
      allocate(mbrams(KGG),xtime(KGG))
      allocate(scftyps(KGG))
      call VICLR(ISUB5, 1, NUW)
      call VICLR(JOBX,  1, KGG)
      call VICLR(mbrams,1, KGG)
      call VCLR(xtime, 1, KGG)
      call VCCLR(scftyps, 1, KGG)
C
C --- Calculations of each subsystems (1 - KGG) ---
      write(io,*) '--- GENERATING SUBSYSTEMS FROM CIM DOMAINS ---'
      maxbs  = 0
      do I=1,KGG  ! should be KGG
         CALL CIMCalc(I,io,isys,NATOM,NW,NUW,Nmo,NCORE,IWORK,RWORK,numc,
     &     numh,natc,nath,nuchar,coor,dis,link,SMO,FK,SOVER,admx,
     &     admy,admz,NB,BA,ZA,SOB,SNB,NASUB,NWSUB,SR1,INF2,ISUB3,ISUB4,
     &     KGG,basis,gmsname,kmem,ED,NCLU,scftyps(I),mtdsys(I),
     &     job,istop,mbrams(I),ISUB5,NOB,FKB,
     &     CenMO,path,user,NCBS,CBAS)
         if (istop.eq.2) stop
      enddo
C
      KGG2=0
      do I=1,KGG
         if (mtdsys(I).ge.1) KGG2=KGG2+1
      enddo
C
      write(io,200)
      NSYGEN = 0
      memtot = 0
      timtot = 0.0D+00
      NERR = 0
      do I=1,KGG
         L=mtdsys(I)  ! 0: NONE; >0: MP/CC; <0 MP/CC with existed input
C        if (L.le.0) cycle ! Skip NONE and existed subsystems
         METHOD = METHDS(abs(L))
         if (L.gt.0) then
            NSYGEN = NSYGEN + 1
            JOBX(NSYGEN) = I
         elseif (L.eq.0) then
            cycle
         endif
C
         if (scftyps(I).eq.'ROHF    ') then
            if (METHOD.ne.'CCSD    '.and.METHOD.ne.'CR-CCL') NERR=NERR+1
         endif
C
         memtot=memtot+mbrams(I)
C
         nc  = ISUB3(I)
         no  = ISUB4(I)
         nu  = ISUB5(I)
         nbs = NWSUB(I)
         nu4 = nu**4
C
         xo1w4=1.0D-08*dble(nbs*nbs)
         xo1w4=xo1w4*nbs*nbs*no*1.0D-03
         xo2u4=1.0D-08*dble(nu4)
         xo2u4=xo2u4*no*no*1.0D-03
         xo3u4=xo2u4*no*0.5D+00
C
         if (METHOD.eq.'MP2     ') then
            xtime(I) = xo1w4
         elseif (METHOD.eq.'CCD     ') then
            xtime(I) = xo2u4*15+xo1w4
         elseif (METHOD.eq.'CCSD    ') then
            xtime(I) = xo2u4*30+xo1w4
         elseif (METHOD.eq.'CCSD(T) ') then
            xtime(I) = xo3u4*10+xo2u4*30+xo1w4
         elseif (METHOD.eq.'CR-CCL  ') then
            xtime(I) = xo3u4*30+xo2u4*60+xo1w4
         endif
C
         if (scftyps(I).eq.'ROHF    ') xtime(I)=xtime(I)*3.0D+00
         timtot = timtot + xtime(I)
C
         if (L.gt.0) then
            write(io,201) I,scftyps(I),METHOD,nc,no,nu,nbs,
     &                 mbrams(I),xtime(I)
         else
            write(io,202) I,METHOD,nc,no,nbs
         endif
      enddo
      write(io,205) memtot,timtot
C
C --- Get required memory and estimated CPU time for total system
      yo1w4 = 1.0D-08*dble(NW*NW)
      yo1w4 = yo1w4*NW*NW*NUTT*1.0D-03
      yo2u4 = 1.0D-08*dble(NVTT*NVTT*NVTT*NVTT)
      yo2u4 = yo2u4*NUTT*NUTT*1.0D-03
      yo3u4 = yo2u4*NUTT*0.5D+00/3.0D+00
C
      if (scftyp.eq.'RHF     ') then
         k1 = memgms(scftyp,2,'NONE    ',NW,NUTT,NVTT,0)
         k2 = memgms(scftyp,0,'CCD     ',NW,NUTT,NVTT,0)
         k3 = memgms(scftyp,0,'CCSD    ',NW,NUTT,NVTT,0)
         k4 = memgms(scftyp,0,'CCSD(T) ',NW,NUTT,NVTT,0)
         k5 = memgms(scftyp,0,'CR-CCL  ',NW,NUTT,NVTT,0)
         k4 = max(k3,k4)
         k5 = max(k3,k5)
         MBRAM(1) = int(k1/125.d0/1000d0) + 1
         MBRAM(2) = int(k2/125.d0/1000d0) + 1
         MBRAM(3) = int(k3/125.d0/1000d0) + 1
         MBRAM(4) = int(k4/125.d0/1000d0) + 1
         MBRAM(5) = int(k5/125.d0/1000d0) + 1
         ytime(1) = yo1w4
         ytime(2) = yo2u4*15+yo1w4
         ytime(3) = yo2u4*30+yo1w4
         ytime(4) = yo3u4*10+yo2u4*30+yo1w4
         ytime(5) = yo3u4*30+yo2u4*60+yo1w4
         write(io,212) (scftyp,METHDS(k),NUTT,NVTT,NW,
     &                 MBRAM(k),ytime(k),k=1,5)
      elseif (scftyp.eq.'ROHF    ') then
         k3 = memgms(scftyp,0,'CCSD    ',NW,NUTT,NVTT,0)
         k5 = memgms(scftyp,0,'CR-CCL  ',NW,NUTT,NVTT,0)
         k5 = max(k3,k5)
         MBRAM(3) = int(k3/125.d0/1000d0) + 1
         MBRAM(5) = int(k5/125.d0/1000d0) + 1
         ytime(3) = (yo2u4*30+yo1w4)*3.0D+00
         ytime(5) = (yo3u4*30+yo2u4*60+yo1w4)*3.0D+00
         write(io,212) scftyp,METHDS(3),NUTT,NVTT,NW,MBRAM(3),ytime(3)
         write(io,212) scftyp,METHDS(5),NUTT,NVTT,NW,MBRAM(5),ytime(5)
C     else
      endif
      write(io,215)
      write(io,*)
C
C --- Sorting by the estimated CPU timing ---
      do idx=1,NSYGEN-1
         i = JOBX(idx)
         do jdx=idx+1,NSYGEN
            j = JOBX(jdx)
C
            time1=xtime(i)
            time2=xtime(j)
            if (time1.ge.time2) cycle
C
            k=JOBX(i)
            JOBX(i)=JOBX(j)
            JOBX(j)=k
C
            timex=xtime(i)
            xtime(i)=xtime(j)
            xtime(j)=timex
         enddo
      enddo
C
      write(io,*) 'Sorted subsystems by decreasing CPU time:'
      write(io,224) (JOBX(I),I=1,NSYGEN)
      write(io,*)
C
      if (NERR.NE.0) then
         write(io,226) NERR
         call abrt
      endif
C
C     call sortjob(job,KGG2,LJOBX(1))
C
 200  format(1x,'=== Required memory (MB) and ',
     &      'estimated CPU time (Relative) ==='/
     &       1x,'SYS   SCFTYP  METHOD     NC   NO   NU  NBS  ',
     &      'MEMORY    CPU TIME')
 201  format(i4,3x,2a8,4i5,i8,f12.4)
 202  format(i4,3x,'--',6x,a8,2i5,3x,'--',i5,6x,'--',6x,'SKIPED')
 205  format(' Tot',3x,8x,8x,5x,15x,i8,f12.4)
 212  format(' Can.  ',a8,a8,5x,3i5,i8,f12.4)
C
 215  format(1x,'Notes: The estimated CPU times are based on the',
     &       ' following scalings:'/
     &       1x,'MP2: O(NO*NBS^4)'/
     &       1x,'CCD or CCSD: O(NO^2*NU^4)'/
     &       1x,'CCSD(T) or CR-CC(2,3): O(NO^3*NU^4)'/
     &       1x,'t(ROHF-CC)/t(RHF-CC) = 3'/
     &       1x,'The CPU times between different methods are',
     &       ' estimated empirically.'/
     &       1x,'They may be inaccurate especially for small systems/',
     &       'subsystems.')
 224  format(1x,5i5,2x,5i5)
 226  format(1x,'ERROR(S) IN',i4,' SUBSYSTEMS,',
     *     ' ROHF CAN ONLY BE USED FOR CIM CCSD AND CR-CCL'/)
C204  format(1x,'Tot',16x,f7.2,' (100.%)',f8.2,' (100.%)',i8)
C
C-WL- 2009.05.05 move this part from bottom
C     if (io>0) then
C        call NJ_date(io,'Constructing subsystem over on:')
C        call NJ_cputim(io,Tim0)
C        call NJ_walltim(io,Wall0)
C        write(io,*) 'Constructing subsystem over'
C        call timit(1)
C        call flshbf(io)
C     endif
C
C
C     write(io,*) '=== SOME INFOMATION FOR DOMAIN ==='
C     write(io,'(''NUMSYS = '',I8)') KGG
C     write(io,'(6i7)') NATOM,NW,Nmo,NCORE,NUW,IWORK(6)
C     write(io,*) 'KSymm()'
C     write(io,'(15i6)') (KSymm(i),i=1,NUW)
C     write(io,*)
C
      write(inp,*) '=== SOME INFOMATION FOR DOMAIN ==='
      write(inp,'(''NUMSYS = '',I8)') KGG
      write(inp,'(6i7)') NATOM,NW,Nmo,NCORE,NUW,IWORK(6)
      write(inp,*) 'KSymm()'
      write(inp,'(15i6)') (KSymm(i),i=1,NUW)
      write(inp,*)
C
      deallocate(SR,SR1,SNB,SOB)
      deallocate(INF,INF2,ISUB,ISUB2)
      deallocate(ISUB3,ISUB4,BA,ZA,NB)
      deallocate(NASUB,NWSUB,natc,nath,ED,dis,link,NCLU)
      deallocate(ECCA,ECCB,ETCA,ETCB,NCLA,NCLB,KSymm,group,FRG,NF0,FF)
      deallocate(EF)
      deallocate(mbrams,ISUB5,JOBX)
      deallocate(xtime)
      deallocate(CenMO,molevl,mtdsys)
      deallocate(FXY,scftyps)
C
      END
C
C
C --- 2009.12.04 ---
      subroutine rdgroup(io,inp,nat,numc,numh,natc,nath,link,
     &           group,ngroup,atmlevl,mxno,zt,IWORK,methds,submtd)
      implicit none
      integer io,inp,nat,numc,numh,i,j,k,L,m,n,ic,jh,kh,ngroup,ngroup0
      integer k0,k1,k2,k3,k4,k5,k6,k7,k8,k9,k10,kk,jc,j1,j2
      integer natc(nat),nath(nat),link(nat,nat),group(nat,nat)
      integer atmlevl(nat),mxno(nat)
      integer,allocatable::used(:),ngrp(:),ntmp(:),levl(:)
      character(len=256) line,line1,line2,line3,string
      character(len=8) methds(0:5),mtdtmp,submtd
      double precision z1,z2,zt(nat)
      integer IWORK(100)
C
      allocate(used(nat),ngrp(nat),ntmp(nat),levl(nat))
C
      levl=0
C
      used=0
      ngroup=0
      ngroup0=0
C
      ngrp=0
      group=0
      read(inp,*)
      do i=1,nat
         read(inp,'(a)') line
C        if (io.gt.0) write(io,'(1x,a)') trim(line)
         call NJ_upper(line)
         if (index(line,'$END').ne.0) exit
         ngroup=ngroup+1
C
         k0=index(line,'HF')+index(line,'NONE')
         k1=index(line,'MP2')
         k2=index(line,'CCD')
         k3=index(line,'CCSD')-index(line,'CCSD(')-index(line,'CCSD[')
         k4=index(line,'CCSD(T)')
         k5=index(line,'CR-CCL')+index(line,'CR-CC(2,3)')
         if (k0.ne.0) then
            levl(i)=0  ! 0 - NONE/HF
            k=index(line(k0:256),' ')+k0-1
            line(k0:k)=' '
         endif
         if (k1.ne.0) then
            levl(i)=1  ! 1 - MP2
            k=index(line(k1:256),' ')+k1-1
            line(k1:k)=' '
         endif
         if (k2.ne.0) then
            levl(i)=2  ! 2 - CCD
            k=index(line(k2:256),' ')+k2-1
            line(k2:k)=' '
         endif
         if (k3.ne.0) then
            levl(i)=3  ! 3 - CCSD
            k=index(line(k3:256),' ')+k3-1
            line(k3:k)=' '
         endif
         if (k4.ne.0) then
            levl(i)=4  ! 4 - CCSD(T)
            k=index(line(k4:256),' ')+k4-1
            line(k4:k)=' '
         endif
         if (k5.ne.0) then
            levl(i)=5  ! 5 - CR-CC(2,3)
            k=index(line(k5:256),' ')+k5-1
            line(k5:k)=' '
         endif
C
         if(IWORK(8).ne.0 .and. k1+k2+k4+k5.ne.0) then
            write(io,*)
            write(io,*) 'SUBTYP=LMO CAN ONLY BE USED WITH CCSD METHOD'
            write(io,*) 'PLEASE CHECK THE METHODS IN $CIMFRG GROUP'
            write(io,*)
            call flshbf(io)
            call abrt
         endif

         k1=index(line,'('); k2=index(line,')')
         if (k1.ne.0.and.k2.ne.0) then
            line(1:k1)=' '
            line(k2:k)=' '
         elseif ((k1.eq.0.and.k2.ne.0).or.(k1.ne.0.and.k2.eq.0)) then
            write(io,*) 'ERROR: Missing ''('' or '')'' in $CIMFRG group'
            write(io,*) 'Also you can use ''atom-labels method'' format'
            call flshbf(io)
            call abrt
         endif
         write(string,'(a)') line(1:k)
C        write(string,'(a)') line(k1+1:k2-1)
         call NJ_readlab(string,group(1,ngroup),nat)
C
C we do not wish to read separate zeta parameters for fragments
C at this time
C        write(string,'(a)') line(k+1:256)
C        z1=0d0
C        z2=0d0
C        read(string,*,end=100) z1,z2
C        if (z1.gt.1d0) then
C           mxno(ngroup) = nint(z1)
C           if (z2.gt.1d0) then
C              write(io,*) 'ERROR: confused parameters of group',ngroup
C              stop
C           else if (z2.gt.0d0.and.z2.le.1d0) then
C              zt(ngroup) = z2
C           endif
C        else if (z1.gt.0d0.and.z1.le.1d0) then
C           zt(ngroup) = z1
C           if (z2.gt.1d0) then
C              mxno(ngroup) = nint(z2)
C           else if (z2.gt.0d0.and.z2.le.1d0) then
C              write(io,*) 'ERROR: confused parameters of group',ngroup
C              stop
C           endif
C        endif
C
 100     continue
C
         do j=1,nat
            ic=group(j,ngroup)
            if (ic.eq.0) then
               ngrp(i)=j-1
               exit
            endif
            used(ic)=1
         enddo
      enddo
C
      do i=1,numc
         ic=natc(i)
         if (used(ic).ne.0) cycle
         ngroup=ngroup+1
         group(1,ngroup)=ic
         used(ic)=1
         ngrp(ngroup)=1
      enddo
C
      ngroup0=ngroup
      do i=1,ngroup0
         L=ngrp(i)
         do j=1,ngrp(i)
            ic=group(j,i)
            do k=1,numh
               kh=nath(k)
               if (link(kh,ic).eq.1) then
                  L=L+1
                  group(L,i)=kh
                  used(kh)=1
               endif
            enddo
         enddo
         ngrp(i)=L
      enddo
C
      k=0
      do i=1,nat
         if (used(i).ne.0) cycle
         write(io,*) 'Find isolated atom:',i
         k=k+1
      enddo
      if (k.ne.0) then
         write(io,*) 'ERROR: The number of isolated atoms is',k
         stop
      endif
C
C --- Sorting the atoms in group
      do i=1,ngroup
         L=ngrp(i)
         do j1=1,L-1
            do j2=j1+1,L
               k1=group(j1,i)
               k2=group(j2,i)
               if (k1.gt.k2) then
                  group(j1,i)=k2
                  group(j2,i)=k1
               endif
            enddo
         enddo
      enddo
C
C --- New atom levels here (old ones are kept)
      do i=1,ngroup
         L=levl(i)
         if (L.eq.0) cycle
         do j=1,ngrp(i)
            k=group(j,i)
            atmlevl(k)=L
         enddo
      enddo
C
      if (io.gt.0) then
C        write(io,*)
         write(io,*) '+++ The initial groups of atoms +++'
         do i=1,ngroup
            write(line1,*) i
            call NJ_trim(line1,k1,k2)
            kk=ngrp(i)
            do j=1,nat
               ntmp(j)=group(j,i)
            enddo
            call NJ_prtlab(line2,kk,ntmp)
            call NJ_trim(line2,k3,k4)
            line2='('//line2(k3:k4)//')'
C
C           write(line3,'(i6,f9.6)') mxno(i),zt(i)
            mtdtmp=methds(levl(i))
            if(levl(i).eq.0) mtdtmp=submtd
C           write(line3,'(2x,a8)') mtdtmp
C           call NJ_trim(line3,k5,k6)
C           write(io,*) line1(k1:k2)//' ('//line2(k3:k4)//') '
C    &                //line3(k5:k6)
            write(io,"(i3,2x,a55,2x,a8)") i,line2,mtdtmp
         enddo
C        write(io,*)
C        write(io,*) '+++ The updated level of calc for atoms +++'
C        write(io,'(4(3x,5i3))') (atmlevl(i),i=1,nat)
         write(io,*)
      endif
C
      deallocate(used,ngrp,ntmp)
      end
C
C
C --- 2008.03.04 ---
      subroutine mkgroup(io,nat,numc,numh,natc,nath,link,group,ngroup,
     &           atmgrp,methds,atmlevl)
      implicit none
      integer io,nat,numc,numh,i,j,k,L,m,n,ic,jh,kh,ngroup,ngroup0
      integer k1,k2,k3,k4,kk,jc,level
      integer natc(nat),nath(nat),link(nat,nat),group(nat,nat)
      integer atmgrp(nat),atmlevl(nat)
      integer,allocatable::used(:),ngrp(:),ntmp(:)
      character(len=256) line1,line2
      character(len=8) methds(0:5),mtdtmp
C
      allocate(used(nat),ngrp(nat),ntmp(nat))
      used=0
      ngrp=0
      group=0
C
      k = 0
      do i=1,numc
         ic=natc(i)

         if (atmgrp(ic).eq.0) then
            used(ic)=1
            k=k+1
            L=1
            group(L,k)=ic
            n=k
         else
            do m=1,k
               jc=group(1,m)
               if (atmgrp(jc).eq.atmgrp(ic)) then
                  used(ic)=1
                  L=ngrp(m)+1
                  group(L,m)=ic
                  n=m
                  exit
               endif
            enddo
            if (used(ic).eq.0) then
               used(ic)=1
               k=k+1
               L=1
               group(L,k)=ic
               n=k
            endif
         endif

         do j=1,numh
            jh=nath(j)
            if (link(jh,ic).eq.1) then
               L=L+1
               group(L,n)=jh
               used(jh)=1
            endif
         enddo
         ngrp(n)=L
      enddo
C
      ngroup  = k
      ngroup0 = k
C
!!!!  do k=1,numh
!!!!     kh=nath(k)
!!!!     if (used(kh).ne.0) cycle
!!!!     do i=1,ngroup0
!!!!        ic=group(1,i)
!!!!        if (link(ic,kh).eq.2) then
!!!!           ngrp(i)=ngrp(i)+1
!!!!           group(ngrp(i),i)=kh
!!!!           used(kh)=1
!!!!        endif
!!!!     enddo
C
****     if (used(kh).eq.0) then
****        ngroup=ngroup+1
****        group(1,ngroup)=kh
****        ngrp(ngroup)=1
****        used(kh)=1
****        L=1
****        do j=1,numh
****           jh=nath(j)
****           if (used(jh).ne.0) cycle
****           if (link(jh,kh).eq.1) then
****              L=L+1
****              group(L,ngroup)=jh
****              used(jh)=1
****           endif
****        enddo
****     endif
****  enddo
C
      k=0
      do i=1,nat
         if (used(i).ne.0) cycle
         write(io,*) 'Find isolated atom:',i
         k=k+1
      enddo
      if (k.ne.0) then
         write(io,*) 'ERROR: The number of isolated atoms is',k
         stop
      endif
C
      write(io,*) '+++ The initial groups of atoms +++'
      do i=1,ngroup
         write(line1,*) i
         call NJ_trim(line1,k1,k2)
         kk=ngrp(i)
         do j=1,nat
            ntmp(j)=group(j,i)
            if(ntmp(j).ne.0) mtdtmp=methds(atmlevl(j))
         enddo
         call NJ_prtlab(line2,kk,ntmp)
         call NJ_trim(line2,k3,k4)
         line2='('//line2(k3:k4)//')'
C        write(io,*) line1(k1:k2)//' ('//line2(k3:k4)//')'
         write(io,"(i3,2x,a55,2x,a8)") i,line2,mtdtmp
      enddo
      write(io,*)
C
      deallocate(used,ngrp,ntmp)
      end
C
C --- Construct MO fragments --- liwei
      subroutine mogroup(io,nat,ncor,no,group,SR1,ngroup,nmo,
     &           FRG,NF0,atmlevl,mtdsys,RWORK)
      implicit none
      integer io,nat,ncor,no,ngroup,nmo,i,j,k,L,m,n,k1,k2,k3,k4,k5,k6,kk
      integer group(nat,nat),FRG(no,ngroup),NF0(ngroup)
      double precision SR1(nat,nmo),RWORK(100)
      character(len=256) line,line1,line2
      integer,allocatable::ntmp(:)
      integer atmlevl(nat),mtdsys(ngroup)
C
      FRG=0
      NF0=0
C
      do i=1,ngroup
         L=0
         do j=ncor+1,no
            do k=1,nat
               m=group(k,i)
               if (m.eq.0) exit
               if (SR1(m,j).gt.RWORK(7)) then
                  L=L+1
                  FRG(L,i)=j
                  exit
               endif
            enddo
         enddo
         NF0(i)=L
      enddo
C
      do i=1,ngroup
         do k=1,nat
            m=group(k,i)
            if (m.eq.0) cycle
            k1=atmlevl(m)
            k2=mtdsys(i)
            if (k1.gt.k2) mtdsys(i)=k1
         enddo
      enddo
C
      allocate(ntmp(no))
      do i=1,no
         ntmp(i)=0
      enddo
      do i=1,ngroup
         do j=1,no
            k=FRG(j,i)
            if (k.ne.0) ntmp(k)=1
         enddo
      enddo
      k=0
      do i=ncor+1,no
         if (ntmp(i).ne.0) cycle
         k=k+1
         write(io,*) 'Find isolated LMO:',i
      enddo
      if (k.ne.0) then
         write(io,*) 'ERROR: The number of isolated LMOs is',k
         write(io,*) 'You may need to use small x in MLK=x'
         stop
      endif
      do i=ncor+1,no
         ntmp(i)=0
      enddo

      if (io.gt.0) then
      write(io,*)'=== The group of occ MOs by using Mulliken >',RWORK(7)
      do i=1,ngroup
         write(line1,*) i
         call NJ_trim(line1,k1,k2)
         kk=NF0(i)
         do j=1,no
            ntmp(j)=FRG(j,i)
         enddo
         call NJ_prtlab(line2,kk,ntmp)
         call NJ_trim(line2,k3,k4)
         write(io,*) line1(k1:k2)//' ('//line2(k3:k4)//')'
      enddo
      write(io,*)
C
         write(io,*) '+++ The level of the calculations for groups +++'
         write(io,'(4(3x,5i3))') (mtdsys(i),i=1,ngroup)
         write(io,*) '0 - NONE'
         write(io,*) '1 - MP2'
         write(io,*) '2 - CCD'
         write(io,*) '3 - CCSD'
         write(io,*) '4 - CCSD(T)'
         write(io,*) '5 - CR-CCL'
         WRITE(io,*)
      endif
C
      deallocate(ntmp)
      end
CMWSC
CMWSC --- Construct MO fragments --- liwei
CMWS      subroutine mogroup2(io,nat,ncor,no,group,SR1,ngroup,nmo,FRG,NF0)
CMWS      implicit none
CMWS      integer io,nat,ncor,no,ngroup,nmo,i,j,k,L,m,n,k1,k2,k3,k4,k5,k6,kk
CMWS      integer group(nat,nat),FRG(no,ngroup),NF0(ngroup)
CMWS      double precision SR1(nat,nmo),SRmax
CMWS      character(len=256) line,line1,line2
CMWS      integer,allocatable::ntmp(:)
CMWSC
CMWS      FRG=0
CMWS      NF0=0
CMWSC
CMWSCC    do i=1,ngroup
CMWSCC       L=0
CMWSCC       do j=ncor+1,no
CMWSCC          do k=1,nat
CMWSCC             m=group(k,i)
CMWSCC             if (m.eq.0) exit
CMWSCC             if (SR1(m,j).gt.0.15d0) then
CMWSCC                L=L+1
CMWSCC                FRG(L,i)=j
CMWSCC                exit
CMWSCC             endif
CMWSCC          enddo
CMWSCC       enddo
CMWSCC       NF0(i)=L
CMWSCC    enddo
CMWSC
CMWS      do j=ncor+1,no
CMWS         SRmax=0d0
CMWS         kk=0
CMWS         do i=1,ngroup
CMWS            m=group(1,i)
CMWS            if (SR1(m,j).gt.SRmax) then
CMWS               kk=i
CMWS               SRmax=SR1(m,j)
CMWS            endif
CMWS         enddo
CMWS         NF0(kk)=NF0(kk)+1
CMWS         FRG(NF0(kk),kk)=j
CMWS      enddo
CMWSC
CMWS      allocate(ntmp(no))
CMWS      write(io,*) '=== The group of occ MOs (Using max Mulliken) ==='
CMWS      do i=1,ngroup
CMWS         write(line1,*) i
CMWS         call NJ_trim(line1,k1,k2)
CMWS         kk=NF0(i)
CMWS         do j=1,no
CMWS            ntmp(j)=FRG(j,i)
CMWS         enddo
CMWS         call NJ_prtlab(line2,kk,ntmp)
CMWS         call NJ_trim(line2,k3,k4)
CMWS         write(io,*) line1(k1:k2)//' ('//line2(k3:k4)//')'
CMWS      enddo
CMWS      write(io,*)
CMWSC
CMWS      deallocate(ntmp)
CMWS      end
C
C --- 2008.03.10 Calculate the maximum Fock matrix value between two mo group
C     subroutine grpfock(io,nmo,no,FIJ,ngroup,FRG,NF0,FF)
C     implicit none
C     integer io,nmo,no,ngroup,i,j,k,L,m,n,ii,jj,mi,mj
C     integer FRG(no,ngroup),NF0(ngroup)
C     double precision FIJ(no,no),FF(ngroup,ngroup),P1,PP
C
C     FF=0d0
C     do i=1,ngroup-1
C        do j=i+1,ngroup
C           P1=0d0
C           do ii=1,NF0(i)
C              mi=FRG(ii,i)
C              do jj=1,NF0(j)
C                 mj=FRG(jj,j)
C                 PP=dabs(FIJ(mj,mi))
C                 if (PP.gt.P1) P1=PP
C              enddo
C           enddo
C           FF(j,i)=P1
C           FF(i,j)=P1
C        enddo
C     enddo
C
C     write(io,*) 'The maximum Fock values between mo groups'
C     call NJ_prtsym(io,ngroup,FF,'f11.6')
C     write(io,*)
C
C     end
C
C --- 2008.03.10 Calculate the maximum Fock matrix value between two mo group
      subroutine envfock(io,nmo,no,ncor,FIJ,ngroup,FRG,NF0,EF)
      implicit none
      integer io,nmo,no,ncor,ngroup,i,j,k,L,m,n,ii,jj,mi,mj,k1,k2,LL
      integer FRG(no,ngroup),NF0(ngroup)
      double precision FIJ(no,no),EF(no,ngroup),P1,P2,PP
C
      EF=0d0
      do i=1,ngroup
         L=NF0(i)
         do j=ncor+1,no
            LL=0
            do ii=1,NF0(i)
               mi=FRG(ii,i)
               if (mi.eq.j) then
                  LL=1
                  exit
               endif
            enddo
            if (LL.eq.1) cycle
C
            L=L+1
            P1=0d0
            do ii=1,NF0(i)
               mi=FRG(ii,i)
               PP=dabs(FIJ(mi,j))
               if (PP.gt.P1) P1=PP
            enddo
            EF(L,i)=P1
            FRG(L,i)=j
         enddo
      enddo
C
C --- Sorting Env MOs decreasely
      do i=1,ngroup
         L=NF0(i)
         do k1=L+1,no-1
            do k2=k1+1,no
               if (EF(k1,i).lt.EF(k2,i)) then
                  P1=EF(k1,i)
                  EF(k1,i)=EF(k2,i)
                  EF(k2,i)=P1
                  LL=FRG(k1,i)
                  FRG(k1,i)=FRG(k2,i)
                  FRG(k2,i)=LL
               endif
            enddo
         enddo
      enddo
C
C     write(io,*) 'The maximum Fock values between envir MOs and groups'
C     call NJ_prtcol2(io,no,ngroup,EF,1,ngroup,'f10.5')
C     call NJ_prtcol4(io,no,ngroup,FRG,EF,1,no-ncor,1,ngroup,'f10.5')
C     write(io,*)
C
      end
CMWSC
CMWSc     ##############################################################
CMWSc     ##  subroutine NJ_compare -- compare if an array in another ##
CMWSc     ##  2005.04.04 by Wei Li; Update 2005.10.17 by Wei Li       ##
CMWSc     ##############################################################
CMWSc
CMWSc     if tmp1 in tmp2 ch='<'
CMWSc     if tmp2 in tmp1 ch='>'
CMWSc     if tmp1 eq tmp2 ch='='
CMWSc
CMWS      subroutine NJ_compare(n,tmp1,tmp2,ch)
CMWS      implicit none
CMWS      integer n,tmp1(n),tmp2(n),i,j,k,l,m,n1,n2,ii,jj
CMWS      character ch
CMWS
CMWS      ch=' '
CMWS      n1=0; n2=0
CMWS      do i=1,n
CMWS         if (tmp1(i).ne.0) n1=n1+1
CMWS         if (tmp2(i).ne.0) n2=n2+1
CMWS      enddo
CMWS
CMWS      k=0
CMWS      do i=1,n
CMWS         ii=tmp1(i)
CMWS         if (ii==0) cycle
CMWS         do j=1,n
CMWS            jj=tmp2(j)
CMWS            if (jj==0) cycle
CMWS            if (jj==ii) then
CMWS               k=k+1; exit
CMWS            endif
CMWS         enddo
CMWS      enddo
CMWS
CMWS      if (k==n1) then
CMWS         if (n1==n2) then
CMWS            ch='='
CMWS         else
CMWS            ch='<'
CMWS         endif
CMWS         return
CMWS      endif
CMWS
CMWS      k=0
CMWS      do i=1,n
CMWS         ii=tmp2(i)
CMWS         if (ii==0) cycle
CMWS         do j=1,n
CMWS            jj=tmp1(j)
CMWS            if (jj==0) cycle
CMWS            if (jj==ii) then
CMWS               k=k+1; exit
CMWS            endif
CMWS         enddo
CMWS      enddo
CMWS
CMWS      if (k==n2) then
CMWS         if (n1==n2) then
CMWS            ch='='
CMWS         else
CMWS            ch='>'
CMWS         endif
CMWS         return
CMWS      endif
CMWS
CMWS      end

C
C ======================================================================
C --- Calc Mulliken Population and The Atomic Labels for LMOs ---
      subroutine CalMPop(io,NATOM,NW,NUW,NCORE,Nmo,SOVER,SMO,tbs,
     &           SR,SR1,SNB,SOB,nuchar,NOB,atmlevl,molevl,
     &           IWORK,RWORK,CWORK,LWORK)
      implicit none
      integer io,NATOM,NW,NUW,Nmo,i,j,k,L,m,n,J2,J4,I2,kk,k1,k2,k3,k4
      integer tbs(NW),SNB(NUW),SOB(Nmo,NATOM),NCORE,n1,n2,NOB
      double precision SMO(NW,Nmo),SR(NATOM,Nmo),SR1(NATOM,Nmo)
      double precision SOVER(NW,NW)  ! 2008.02.29 SMO(Nmo,Nmo) --> SMO(NW,Nmo)
      double precision P1,P2,PP,NPP,nuchar(NATOM)
      integer,allocatable::NAT(:),BATOM(:,:),ntmp(:)
      character(len=256) line,line1,line2,line3
      integer atmlevl(NATOM),molevl(NUW),IWORK(100)
      double precision RWORK(100)
      character(len=8) CWORK(100)
      logical LWORK(100)
C
      allocate(NAT(NATOM),BATOM(NW,NATOM),ntmp(NATOM))
      BATOM=0; NAT=0
C
      do i=1,NW
         j=tbs(i)
         NAT(j)=NAT(j)+1
         BATOM(NAT(j),j)=i
      enddo
C
!     if (io>0) then
!        write(io,*) '+++ Number of basis for atoms and labels +++'
!        do i=1,NATOM
!           write(io,'(2i4,2x,20i4)') i,NAT(i),(BATOM(j,i),j=1,NAT(i))
!        enddo
!        write(io,*)
!     endif
C
C---------------------------------------------------------------------
C     Calc Mulliken population (2001.04.21)
C     SR(j,i)=\sum_{k}^{NW}\sum_{l\in{j}}^{NW}C_{ki}S_{kl}C_{li}  (j=1,natom; i=1,Nmo)
C---------------------------------------------------------------------
      DO 420 I=1,Nmo
         DO 440 J=1,NATOM
            SOB(I,J)=J
            P1=0.0d0
            DO 445 J2=1,NAT(J)
               J4=BATOM(J2,J)
               P2=0.0d0
               DO 450 K=1,NW
                  P2=P2+SMO(K,I)*SOVER(K,J4)
450            CONTINUE
               P1=P1+SMO(J4,I)*P2
445         CONTINUE
            SR(J,I)=P1
440      CONTINUE
420   CONTINUE
C
C --- SR1: unsorted SR: Mulliken population of basis in atoms
      SR1=SR
C
!     if (io>0) WRITE(io,*) '+++ Mulliken gross population +++'
      P2=0d0
      DO 451 I=1,NATOM
         P1=0.0d0
         DO 453 J=1,NUW
             P1=P1+SR(I,J)*2.0d0
453      CONTINUE
!        if (io>0) WRITE(io,'(i7,f12.7)') I,P1
         P2=P2+P1
451   CONTINUE
!     if (io>0) write(io,'('' Total:'',f12.7)') P2
C
C---------------------------------------------------------------------
C     (SR(J,I), J=1,NATOM) are reordered from large to small for the ith Occ MO
C---------------------------------------------------------------------
      DO 460 I=1,Nmo
         DO 465 J=1,NATOM-1
            P1=SR(J,I)
            DO 470 K=J+1,NATOM
               IF (SR(K,I).GT.P1) THEN
                  P1=SR(K,I)
                  SR(K,I)=SR(J,I)
                  SR(J,I)=P1
                  NPP=SOB(I,K)
                  SOB(I,K)=SOB(I,J)
                  SOB(I,J)=NPP
               ENDIF
470         CONTINUE
465      CONTINUE
C
         if (I>NUW) cycle
         P1=0.0d0
         DO 475 J=1,NATOM
            P1=P1+SR(J,I)
C           if (dabs(RWORK(2)).ge.0.9999) then   !-WL- NEW SECIM
            if (CWORK(1).EQ.'SECIM   '.OR.CWORK(1).EQ.'GSECIM  ') then
C ---          This is new trial method for selecting the atoms for a LMO
               IF (SR(J,I).lt.RWORK(7)) THEN
                  SNB(I)=J-1
                  exit
               ENDIF
            elseif (CWORK(1).EQ.'DECIM   ') then  !-WL- OLD DECIM
C ---          This is origin method for selecting the atoms for a LMO
               IF (P1.ge.RWORK(8)) THEN
                  SNB(I)=J
                  exit
               ENDIF
            endif
475      CONTINUE
460   CONTINUE
C
C --- 2008.02.28 Add for sorting LMOs according to the labels of atoms
      if (IWORK(5).eq.0) then
C         -WL- Add NOB for unsorting single-occ MOs
         call SortLMO(0,NATOM,NW,NUW,NOB,NCORE,Nmo,SMO,SR,SR1,SNB,SOB,
     &        nuchar)
      endif
C
      molevl=0
      do I=1,NUW
         do j=1,SNB(I)
            k=SOB(I,J)
            k1=molevl(I)
            k2=atmlevl(k)
            if (k2.gt.k1) then
               molevl(I)=k2
            endif
         enddo
      enddo
C
      if (io>0) then
C        WRITE(io,*) 'Sorted Mulliken population of basis in atoms'
C        call NJ_prtcol3(io,NATOM,NMO,SOB,SR,1,NUW,'f10.5')
C        WRITE(io,*) '+++ Atomic Labels for LMOs +++'
         write(io,*)"Atoms are assigned to LMOs by Mulliken population:"
         write(io,'(1x,"ATMMLK >= ",1p,e8.1,0p)') rwork(7)
         write(io,'(1x,"The first ",i3," are core orbitals")') ncore
         m=4
         line=' '
         do I=1,NUW
            write(line1,*) I
            call NJ_trim(line1,k1,k2)
            kk=SNB(I)
            do j=1,NATOM
               ntmp(j)=SOB(I,J)
            enddo
            call NJ_prtlab(line2,kk,ntmp)
            call NJ_trim(line2,k3,k4)
C
            n=mod(I,m)
            if (n.eq.0) n=m
            n1=(n-1)*20+1
            n2=n1+19
C           if (I.le.NCORE) then
C              line(n1:n2)=line1(k1:k2)//' ('//line2(k3:k4)//')*'
C           else
               line(n1:n2)=line1(k1:k2)//' ('//line2(k3:k4)//')'
C           endif
            if (n.eq.m .or. I.eq.NUW) then
               write(io,'(a)') trim(line)
               line=' '
            endif
         enddo
C        write(io,*) '* Assignment of core orbitals'
         WRITE(io,*)
         write(io,"(/1X,'ORDERED LOCALIZED ORBITALS')")
         call prsql(smo,nuw,nw,nw)
         write(io,"('... END OF LOCALIZED ORBITALS ...')")
         write(io,*)

      endif
      deallocate(NAT,BATOM,ntmp)
      end
C
C
C --- 2008.02.28 Add for sorting LMOs according to the labels of atoms
      subroutine SortLMO(io,nat,nbs,no,nob,ncor,nmo,smo,SR,SR1,SNB,SOB,
     &           nuchar)
      implicit none
      integer io,nat,nbs,no,ncor,nmo,i,j,k,L,k1,k2,k3,k4,i1,j1,i2,j2,nob
      integer SNB(no),SOB(nmo,nat)
      double precision smo(nbs,nmo),SR(nat,nmo),SR1(nat,nmo),P
      double precision nuchar(nat)
      logical LSort
C
      if (io.gt.0) write(io,*)
     &   'Sort the occupied LMOs according to the labels of atoms'
C
      do i=1,ncor-1
         do j=i+1,ncor
            i1=SOB(i,1)
            j1=SOB(j,1)
            if (i1.gt.j1) then
               call swapmo(i,j,nat,nbs,no,nmo,smo,SR,SR1,SNB,SOB)
            endif
         enddo
      enddo
C
      do i=ncor+1,nob-1
         do j=i+1,nob
            LSort=.false.
            if (SNB(i).eq.1 .and. SNB(j).eq.1) then
               i1=SOB(i,1)
               j1=SOB(j,1)
               if (i1.gt.j1) LSort=.true.
            elseif (SNB(i).eq.1 .and. SNB(j).gt.1) then
               i1=SOB(i,1)
               j1=SOB(j,1)
               j2=SOB(j,2)
               if (j1.gt.j2) call swap(j1,j2)
C
               k1=nint(nuchar(j1))
               k2=nint(nuchar(j2))
               if (k1.eq.1.and.k2.ne.1) call swap(j1,j2)
C
               if (i1.gt.j1) LSort=.true.
            elseif (SNB(i).gt.1 .and. SNB(j).eq.1) then
               i1=SOB(i,1)
               i2=SOB(i,2)
               j1=SOB(j,1)
               if (i1.gt.i2) call swap(i1,i2)
C
               k1=nint(nuchar(i1))
               k2=nint(nuchar(i2))
               if (k1.eq.1.and.k2.ne.1) call swap(i1,i2)
C
               if (i1.ge.j1) LSort=.true.
            else
               i1=SOB(i,1)
               i2=SOB(i,2)
               j1=SOB(j,1)
               j2=SOB(j,2)
               if (i1.gt.i2) call swap(i1,i2)
               if (j1.gt.j2) call swap(j1,j2)
C
               k1=nint(nuchar(i1))
               k2=nint(nuchar(i2))
               if (k1.eq.1.and.k2.ne.1) call swap(i1,i2)
               k1=nint(nuchar(j1))
               k2=nint(nuchar(j2))
               if (k1.eq.1.and.k2.ne.1) call swap(j1,j2)
C
               if (i1.gt.j1) LSort=.true.
C-WL- 2010.02.10 comment the line and replace it with the following lines
C              if (i1.eq.j1 .and. i2.gt.j2) LSort=.true.
               if (i1.eq.j1) then
                  k1=nint(nuchar(i2))
                  k2=nint(nuchar(j2))
                  if (k1.eq.1.and.k2.eq.1) then
                     if (i2.gt.j2) LSort=.true.
                  elseif (k1.ne.1.and.k2.ne.1) then
                     if (i2.gt.j2) LSort=.true.
                  elseif (k1.ne.1.and.k2.eq.1) then
                     LSort=.true.
                  endif
               endif
            endif
            if(LSort) call swapmo(i,j,nat,nbs,no,nmo,smo,SR,SR1,SNB,SOB)
         enddo
      enddo
C
      end
C
C --- Swap i and j
      subroutine swap(i,j)
      implicit none
      integer i,j,L
      L=i
      i=j
      j=L
      end
C
C --- Swap MO i and j and other info. ---
      subroutine swapmo(i,j,nat,nbs,no,nmo,smo,SR,SR1,SNB,SOB)
      implicit none
      integer nat,nbs,no,nmo,i,j,k,L
      integer SNB(no),SOB(nmo,nat)
      double precision smo(nbs,nmo),SR(nat,nmo),SR1(nat,nmo),P
C
      L=SNB(i)
      SNB(i)=SNB(j)
      SNB(j)=L
      do k=1,nat
         L=SOB(i,k)
         SOB(i,k)=SOB(j,k)
         SOB(j,k)=L
         P=SR(k,i)
         SR(k,i)=SR(k,j)
         SR(k,j)=P
         P=SR1(k,i)
         SR1(k,i)=SR1(k,j)
         SR1(k,j)=P
      enddo
      do k=1,nbs
         P=smo(k,i)
         smo(k,i)=smo(k,j)
         smo(k,j)=P
      enddo
C
      end
C
C---------------------------------------------------------------------
C     Build the central domains for each Occ spatial orbital
C---------------------------------------------------------------------
C     INF(): orbitals in each domain
C     ISUB(): number of orbitals in each domain
C     ISUB2():number of central orbitals in each domain
      subroutine CentDomn(io,Nmo,NUW,NCORE,RWORK,FIJ,INF,ISUB,ISUB2,
     &           KSymm,ngroup,FRG,NF0,EF,mxno,zt)
      implicit none
      integer io,Nmo,NUW,NCORE,I,J,K,L,M,N,K1,K2,kk,ngroup,maxno
      integer INF(NUW,NUW),ISUB(NUW),ISUB2(NUW),KSymm(NUW)
      integer FRG(NUW,ngroup),NF0(ngroup),k3,k4,k5,k6,k7,k8
      integer kkc,kke,kkk
      integer mxno(ngroup)
      double precision RWORK(100),FIJ(NUW,NUW),SA,EF(NUW,ngroup)
      double precision zt(ngroup)
      character*500 line,line1,line2,line3,line4  !-WL,PP- 200 --> 500
      integer,allocatable::Ktmp(:)
C
      INF=0
      ISUB=0
      ISUB2=0
C ----------------
      do 2300 i=1,ngroup
         kk=NF0(i)
         if (kk.gt.mxno(i)) then
            write(io,*) 'Warn: No. of central MOs is larger than maxno '
     &                //'in group',i
         endif
C
         ISUB2(i)=kk
         ISUB(i)=kk
         do j=1,kk
            INF(j,i)=FRG(j,i)
         enddo
         do j=kk+1,mxno(i)
            SA=EF(j,i)
            if (SA.lt.zt(i)) exit  ! 23 ARP 10 WRK(1) --> zt(i)
            INF(j,i)=FRG(j,i)
            ISUB(i)=ISUB(i)+1
         enddo
 2300 enddo
C
      if (io>0) then
         write(io,*)'+++ Central orbitals and their domains +++'
         write(io,'(1x,"+++ Domains chosen ",
     *              "by Fij >= ",f7.4," (ZETA) +++")') zt(1)
C        write(io,*) '  No. Num   Cent       LMOs'
         do i=1,ngroup
            if(ISUB2(i).eq.0)cycle
C           kkc=ISUB2(i)         !central limit
C           kke=ISUB(i)-ISUB2(i) !env limit
C           write(io,'(1x,"Domain ",i4)') i
C           write(io,'(4x,"Cent:",i4)') kkc
C           write(io,'(4x,19i4)') inf(1:kkc,i)
C           write(io,'(4x,"Env :",i4)') kke
C           write(io,'(4x,19i4)') inf(kkc+1:kkc+kke,i)

            kk=ISUB2(i)
            write(line1,*) kk; call NJ_trim(line1,k1,k2)
            allocate(Ktmp(kk))
            do kkk=1,kk
               Ktmp(kkk) = INF(kkk,i)
            enddo
            call NJ_prtlab(line3,kk,Ktmp)
            deallocate(Ktmp)
            call NJ_trim(line3,k5,k6)
            kk=ISUB(i)-ISUB2(i)
            write(line2,*) kk; call NJ_trim(line2,k3,k4)
            allocate(Ktmp(kk)); Ktmp(1:kk)=INF(ISUB2(i)+1:ISUB2(i)+kk,i)
            call NJ_prtlab(line4,kk,Ktmp);  deallocate(Ktmp)
            call NJ_trim(line4,k7,k8)
            write(io,'(i5,a)')i,' ['//line1(k1:k2)//'+'//line2(k3:k4)
     &           //']: ('//line3(k5:k6)//') '//line4(k7:k8)
         enddo
         WRITE(io,*)
         call flshbf(io)
      endif
C
      end
C
C --- Compare the sizes of domains and eliminate small domains which are embedded in larger ones
      subroutine ReduDomn(io,NUW,NCORE,INF,ISUB,ISUB2,KG,ngroup,mtdsys,
     &           IWORK)
      implicit none
      integer io,NUW,NCORE,KG,I,J,K,L,NAB,ngroup
      integer INF(NUW,NUW),ISUB(NUW),ISUB2(NUW),mtdsys(NUW)
      character*500 line,line1,line2,line3,line4
      integer k1,k2,k3,k4,k5,k6,k7,k8,kk,kkk,IWORK(100)
      integer,allocatable::Ktmp(:)
C
      NAB=NUW
CC    call COMPARE(NAB,NCORE+1,NUW,INF,ISUB,ISUB2)
      call COMPARE(NAB,1,ngroup,INF,ISUB,ISUB2,mtdsys(1),IWORK(10))
C
C   KG: Number of central domains
      KG=0
CC    DO 5590 I=NCORE+1,NAB
      DO 5590 I=1,ngroup
         if(ISUB2(I).eq.0)cycle
         KG=KG+1
         mtdsys(KG)=mtdsys(I)
         ISUB(KG)=ISUB(I)
         ISUB2(KG)=ISUB2(I)
         do j=1,ISUB(KG)
            INF(j,KG)=INF(j,I)
         enddo
5590  CONTINUE

      do i=KG+1,NAB
         mtdsys(i)=0
      enddo

      if (io>0) then
         write(io,*)'+++ Reduced central orbitals and their domains +++'
         write(io,*) '  No. Num   Cent       LMOs'
         do i=1,KG
            if(ISUB2(i).eq.0)cycle
            kk=ISUB2(i)
            write(line1,*) kk; call NJ_trim(line1,k1,k2)
            allocate(Ktmp(kk))
            do kkk=1,kk
               Ktmp(kkk) = INF(kkk,i)
            enddo
            call NJ_prtlab(line3,kk,Ktmp)
            deallocate(Ktmp)
            call NJ_trim(line3,k5,k6)
            kk=ISUB(i)-ISUB2(i)
            write(line2,*) kk; call NJ_trim(line2,k3,k4)
            allocate(Ktmp(kk)); Ktmp(1:kk)=INF(ISUB2(i)+1:ISUB2(i)+kk,i)
            call NJ_prtlab(line4,kk,Ktmp);  deallocate(Ktmp)
            call NJ_trim(line4,k7,k8)
            write(io,'(i5,a)')i,' ['//line1(k1:k2)//'+'//line2(k3:k4)
     &           //']: ('//line3(k5:k6)//') '//line4(k7:k8)
         enddo
         WRITE(io,*)
         call flshbf(io)
      endif
C
      end
C
C---------------------------------------------------------------------
C     Build the central domains for each Occ spatial orbital
C---------------------------------------------------------------------
C     INF(): orbitals in each domain
C     ISUB(): number of orbitals in each domain
C     ISUB2():number of central orbitals in each domain
      subroutine CentDomn1(io,Nmo,NUW,NCORE,RWORK,FIJ,INF,ISUB,ISUB2,
     &           KSymm)
      implicit none
      integer io,Nmo,NUW,NCORE,I,J,K,L,M,N,K1,K2,kk,kkk
      integer INF(NUW,NUW),ISUB(NUW),ISUB2(NUW),KSymm(NUW)
      double precision RWORK(100),FIJ(NUW,NUW),SA
      character*500 line,line1,line2  !-WL,PP- 200 --> 500
      integer,allocatable::Ktmp(:)
C
      INF=0
      ISUB=0
      ISUB2=0
      DO 2300 I=NCORE+1,NUW
         if (KSymm(I).ne.0) cycle  ! 2008.03.04
         INF(1,I)=I
         ISUB(I)=1
         ISUB2(I)=1
2300  CONTINUE
C
      DO 2400 I=NCORE+1,NUW
        if(ISUB2(I).eq.0)cycle
        DO 2450 J=NCORE+1,NUW   !-WL- 5 OCT 2009: 1 --> NCORE+1
          IF (J.EQ.I)cycle
          SA=DABS(FIJ(I,J))
          IF (SA.LT.RWORK(1)) cycle
          K1=ISUB(I)+1
          INF(K1,I)=J
          ISUB(I)=K1
2450    CONTINUE
2400  CONTINUE
C
      if (io>0) then
         write(io,*)'+++ Central orbitals and their',
     *              ' primary environments +++'
         write(io,'(1x,"+++ Primary environment chosen ",
     *              "by Fij >= ",f7.4," (ZETA1) +++")') rwork(1)
         write(io,*) ' No. Num   LMOs'
         do i=NCORE+1,NUW
            if(ISUB2(i).eq.0)cycle
C           write(io,'(i4,2x,20i4)') i,(INF(j,i),j=1,ISUB(i))
C
            kk=ISUB(i)
            write(line1,*) kk; call NJ_trim(line1,k1,k2)
            allocate(Ktmp(kk))
            do kkk=1,kk
               Ktmp(kkk) = INF(kkk,i)
            enddo
            call NJ_prtlab(line2,kk,Ktmp)
            deallocate(Ktmp)
            write(io,'(i5,a)')i,' ['//line1(k1:k2)//']: '//trim(line2)
         enddo
         WRITE(io,*)
         call flshbf(io)
      endif
C
      end
C
C --- Compare the sizes of domains and eliminate small domains which are embedded in larger ones
      subroutine ReduDomn1(io,NUW,NCORE,INF,ISUB,ISUB2,KG,mtdsys,
     &                     IWORK)
      implicit none
      integer io,NUW,NCORE,KG,I,J,K,L,NAB,IWORK(100)
      integer INF(NUW,NUW),ISUB(NUW),ISUB2(NUW),mtdsys(NUW)
      character*500 line,line1,line2,line3,line4
      integer k1,k2,k3,k4,k5,k6,k7,k8,kk,kkk
      integer,allocatable::Ktmp(:)
C
      NAB=NUW
      call COMPARE(NAB,NCORE+1,NUW,INF,ISUB,ISUB2,mtdsys(1),IWORK(10))
C
C   KG: Number of central domains
      KG=0
      DO 5590 I=NCORE+1,NAB
         if(ISUB2(I).eq.0)cycle
         KG=KG+1
         mtdsys(KG)=mtdsys(I)
         ISUB(KG)=ISUB(I)
         ISUB2(KG)=ISUB2(I)
         do j=1,ISUB(KG)
            INF(j,KG)=INF(j,I)
         enddo
5590  CONTINUE

      do i=KG+1,NAB
         mtdsys(i)=0
      enddo

      if (io>0) then
         write(io,*)'+++ Reduced central orbitals and their domains +++'
         write(io,*) '  No. Num   Cent       LMOs'
         do i=1,KG
            if(ISUB2(i).eq.0)cycle
            kk=ISUB2(i)
            write(line1,*) kk; call NJ_trim(line1,k1,k2)
            allocate(Ktmp(kk))
            do kkk=1,kk
               Ktmp(kkk) = INF(kkk,i)
            enddo
            call NJ_prtlab(line3,kk,Ktmp)
            deallocate(Ktmp)
            call NJ_trim(line3,k5,k6)
            kk=ISUB(i)-ISUB2(i)
            write(line2,*) kk; call NJ_trim(line2,k3,k4)
            allocate(Ktmp(kk)); Ktmp(1:kk)=INF(ISUB2(i)+1:ISUB2(i)+kk,i)
            call NJ_prtlab(line4,kk,Ktmp);  deallocate(Ktmp)
            call NJ_trim(line4,k7,k8)
            write(io,'(i5,a)')i,' ['//line1(k1:k2)//'+'//line2(k3:k4)
     &           //']: ('//line3(k5:k6)//') '//line4(k7:k8)
         enddo
         WRITE(io,*)
         call flshbf(io)
      endif
C
      end
C
C
C --- COMPARISON AND ENLARGEMENT OF THE CLUSTER. CORRECT. 2007.4.27.
      subroutine COMPARE(NAB,KG1,KG2,INF,ISUB,ISUB2,mtdsys,mlmerg)
      integer INF(NAB,NAB),ISUB(NAB),ISUB2(NAB),mtdsys(NAB)
      integer,allocatable::Nmin(:)
C
C     mlmerg.ne.0 for merging small high level subsys into a large low level subsys
C              then the large subsys should be run in high level
C              so, mlmerg=0 (default) is a cheap choice
C
      allocate(Nmin(NAB))
      Nmin=1
      DO 5200 I=KG1,KG2
         DO 5250 J=I+1,KG2
            IF (ISUB2(I).EQ.0) GOTO 5200
            IF (ISUB2(J).EQ.0) GOTO 5250
            if (mtdsys(I).eq.0) goto 5200
            if (mtdsys(J).eq.0) goto 5250
C           if (mtdsys(J).ne.mtdsys(I)) goto 5250
            KF=0
            DO 5300 K=1,ISUB(I)
               DO 5350 L=1,ISUB(J)
                  IF (INF(K,I).EQ.INF(L,J)) THEN
                     KF=KF+1
                     GOTO 5300
                  ENDIF
5350           CONTINUE
5300        CONTINUE
C
            I2=KF-ISUB(I)
            J2=KF-ISUB(J)
            IF (I2*J2.NE.0) GOTO 5250
C --- I2==0
C     ENLARGE THE CLUSTER J,  ELIMINATE THE CLUSTER I.
            IF (I2.EQ.0) THEN
               if (mtdsys(J).lt.mtdsys(I)) then
                  if (mlmerg.eq.0) then
                     goto 5250
                  else
                     mtdsys(J)=mtdsys(I)
                  endif
               endif
               mtdsys(I)=0
C
               Nmin(I)=0
c
               DO 5450 K=1,ISUB2(I)
                  IF (INF(K,I).EQ.0) GO TO 5450
                  KF=INF(K,I)
                  DO 5460 L=ISUB2(J)+1,ISUB(J)
                     IF (KF.EQ.INF(L,J)) THEN
                        KK=INF(ISUB2(J)+1,J)
                        INF(ISUB2(J)+1,J)=INF(L,J)
                        INF(L,J)=KK
                        ISUB2(J)=ISUB2(J)+1
                        GO TO 5450
                     ENDIF
5460              CONTINUE
5450           CONTINUE
               goto 5250
            ENDIF
C --- J2==0
C     ENLARGE THE CLUSTER I,  ELIMINATE THE CLUSTER J.
            IF (J2.EQ.0) THEN
               if (mtdsys(J).gt.mtdsys(I)) then
                  if (mlmerg.eq.0) then
                     goto 5250
                  else
                     mtdsys(I)=mtdsys(J)
                  endif
               endif
               mtdsys(J)=0
C
               Nmin(J)=0
C
               DO 5550 K=1,ISUB2(J)
                  IF (INF(K,J).EQ.0) GO TO 5550
                  KF=INF(K,J)
                  DO 5560 L=ISUB2(I)+1,ISUB(I)
                     IF (KF.EQ.INF(L,I)) THEN
                        KK=INF(ISUB2(I)+1,I)
                        INF(ISUB2(I)+1,I)=INF(L,I)
                        INF(L,I)=KK
                        ISUB2(I)=ISUB2(I)+1
                        GO TO 5550
                     ENDIF
5560              CONTINUE
5550           CONTINUE
            ENDIF
5250     CONTINUE
5200  CONTINUE

      do I=KG1,KG2
       if(Nmin(I).eq.0)ISUB2(I)=0
      enddo
C
      deallocate(Nmin)
      return
      end
C
C---------------------------------------------------------------------
C    Build the environmental domain of the same spin for each retained Central Domain.
C    Reduce the nubmer of full domains after comparison.
C---------------------------------------------------------------------
      subroutine FullDomn(io,isys,NATOM,NW,NMO,NUW,NCORE,SOB,SNB,BA,ZA,
     &           NB,NASUB,NWSUB,INF,INF2,ISUB,ISUB2,ISUB3,ISUB4,FIJ,
     &           KG,KGG,mtdsys,IWORK,RWORK,CWORK,LWORK)
      implicit none
      integer io,NATOM,NW,NMO,NUW,NCORE,KG,I,J,K,L,NAB,KGG,K1,K2,L1,L2
      integer INF(NUW,NUW),INF2(NUW,NUW),ISUB(NUW),ISUB2(NUW),ISUB3(NUW)
      integer ISUB4(NUW),SNB(NUW),SOB(Nmo,NATOM),BA(NATOM,NUW)
      integer ZA(NW,NUW),NASUB(NUW),NWSUB(NUW),NB(NATOM),kk,isys
      integer mtdsys(NUW),IWORK(100)
      integer kkk
      double precision FIJ(NUW,NUW),RWORK(100),SA
      character(len=8) CWORK(100)
      logical LWORK(100)
      character*500 line,line1,line2,line3,line4
      integer k3,k4,k5,k6,k7,k8,k2ini
      integer,allocatable::ISUB0(:),Ktmp(:)
C
      allocate(ISUB0(NUW))
      NAB=NUW
C
      do i=1,KG
         ISUB0(I)=ISUB(I)
      enddo
      DO 4690 L1=NCORE+1,NAB
         DO 4600 I=1,KG
            DO  L2=1,ISUB0(I)
               IF (L1.EQ.INF(L2,I))goto 4600
            enddo
C           if (dabs(WRK(2)).ge.0.9999) then   !-WL- NEW SECIM
            if (CWORK(1).EQ.'SECIM   '.OR.CWORK(1).EQ.'GSECIM  ') then
               k2ini=1
            elseif (CWORK(1).EQ.'DECIM   ') then
               k2ini=ISUB2(I)+1
            endif
! IMPORTANT ---------- 2008.07.25 -WL- ISUB2(I)+1 --> 1
C           DO K2=ISUB2(I)+1,ISUB0(I)   ! OLD
C           DO K2=1,ISUB0(I)
! So the Fock values of one MO with all MOs in domain are considered
            DO K2=k2ini,ISUB0(I)
               SA=DABS(FIJ(INF(K2,I),L1))
               IF (SA.ge.RWORK(2).and.CWORK(1).EQ.'DECIM   ') then
                  ISUB(I)=ISUB(I)+1;INF(ISUB(I),I)=L1
                  goto 4600
               endif
            enddo
4600     CONTINUE
4690  CONTINUE
C
      if (io>0) then
         WRITE(io,*) '+++ Full MO domains +++'
         if(cwork(1).eq.'DECIM   ') then
            write(io,'(1x,"+++ Secondary environment chosen by ",
     *             "Fij >= ",f7.4, " (ZETA2) +++")') rwork(2)
         endif
         write(io,*) '  No. Num   Cent         LMOs'
         do i=1,KG
            if(ISUB2(i).eq.0)cycle
            kk=ISUB2(i)
            write(line1,*) kk; call NJ_trim(line1,k1,k2)
            allocate(Ktmp(kk))
            do kkk=1,kk
               Ktmp(kkk) = INF(kkk,i)
            enddo
            call NJ_prtlab(line3,kk,Ktmp)
            deallocate(Ktmp)
            call NJ_trim(line3,k5,k6)
            kk=ISUB(i)-ISUB2(i)
            write(line2,*) kk; call NJ_trim(line2,k3,k4)
            allocate(Ktmp(kk))
            Ktmp(1:kk)=INF(ISUB2(i)+1:ISUB2(i)+kk,i)
            call NJ_prtlab(line4,kk,Ktmp);  deallocate(Ktmp)
            call NJ_trim(line4,k7,k8)
            write(io,'(i5,a)')i,' ['//line1(k1:k2)//'+'//line2(k3:k4)
     &           //']: ('//line3(k5:k6)//') '//line4(k7:k8)
         enddo
      endif

C  Compair the alpha domains
      if (IWORK(13).eq.0) then
         call COMPARE(NAB,1,KG,INF,ISUB,ISUB2,mtdsys(1),IWORK(10))
C     else
C        do i=1,NUW
C           ISUB2(i)=ISUB(i)
C        enddo
      endif

      KGG=0
      do I=1,KG
         if(ISUB2(I).eq.0)cycle
         KGG=KGG+1
C        Construct the atomic domain for each cluster
C        NAsub: number of atoms in the atomic domain
C        NWsub: number of basis in the atomic domain
         call COA(NATOM,NW,NMO,NUW,NB,SOB,SNB,INF(1,I),ISUB(I),
     &        NAsub(KGG),BA(1,KGG),NWsub(KGG),ZA(1,KGG))
C
         if(NAsub(KGG).eq.NATOM)then
            write(io,*)'The whole system will be treated'
c           write(io,*)'Please turn to full calculation'
c           stop
         endif
C
         mtdsys(KGG)=mtdsys(I)
         DO J=1,ISUB(I)
            INF2(J,KGG)=INF(J,I)
         enddo
         ISUB3(KGG)=ISUB2(I)
         ISUB4(KGG)=ISUB(I)
      enddo

      do i=1,KGG
         k1=ISUB3(i)
         k2=ISUB4(i)
         call isort(k1,INF2(1,i))
         call isort(k2-k1,INF2(k1+1,i))
      enddo

      do i=KGG+1,NUW
         mtdsys(i)=0
      enddo

      if (io>0) then
         write(io,*)
         WRITE(io,*) '+++ Reduced full MO domains +++'
C        WRITE(io,'('' The number of retained domains ='',i5)')KGG
         write(io,*) '  No. Num   Cent         LMOs'
         write(line1,*) KGG; call NJ_trim(line1,k1,k2)
         rewind(isys)
         write(isys,'(a)') line1(k1:k2)
         do i=1,KGG
            if(ISUB3(i).eq.0)cycle
            kk=ISUB3(i)
            write(line1,*) kk; call NJ_trim(line1,k1,k2)
            allocate(Ktmp(kk)); Ktmp(1:kk)=INF2(1:kk,i)
            call NJ_prtlab(line3,kk,Ktmp);  deallocate(Ktmp)
            call NJ_trim(line3,k5,k6)
            kk=ISUB4(i)-ISUB3(i)
            write(line2,*) kk; call NJ_trim(line2,k3,k4)
            allocate(Ktmp(kk))
            Ktmp(1:kk)=INF2(ISUB3(i)+1:ISUB3(i)+kk,i)
            call NJ_prtlab(line4,kk,Ktmp);  deallocate(Ktmp)
            call NJ_trim(line4,k7,k8)
            write(io,'(i5,a)')i,' ['//line1(k1:k2)//'+'//line2(k3:k4)
     &           //']: ('//line3(k5:k6)//') '//line4(k7:k8)
            write(line1,*) i; call NJ_trim(line1,k1,k2)
            write(isys,'(a)') line1(k1:k2)//' ('//line3(k5:k6)//') '
     &           //line4(k7:k8)
         enddo
C        write(io,'(1x,58(''-''))')
C        write(io,*) ' Domain No.   NOcc    Natom   Basis'
C        do i=1,KGG
C           write(io,'(i6,4x,3i8)') i,ISUB4(i),NAsub(i),NWsub(i)
C        enddo
C        write(io,*)
C        call flshbf(io)
      endif
C
      deallocate(ISUB0)
      end
C
C --- 2008.03.03 Read clusters from .dmn file
      subroutine ReadClu(io,isys,no,nsy,nc_sub,no_sub,occ_sub)
      implicit none
      integer io,isys,no,nsy,i,j,k,L,m,n,k1,k2,k3,k4,k5,k6,k7,k8,kk
      integer nc_sub(no),no_sub(no),occ_sub(no,no)
      character*256 line,line1,line2,line3,line4,string
      integer,allocatable::ntmp(:)
C
      write(io,*) '=== Read the cluster from the .dmn file ==='
      rewind(isys)
      read(isys,*) nsy
      write(io,*) 'The number of subsystems is',nsy
      allocate(ntmp(no))
C
      do i=1,nsy
         read(isys,'(a)',err=100,end=100) line
         k1=index(line,'('); k2=index(line,')')
         write(string,'(a)') line(k1+1:k2-1)
         call NJ_readlab(string,ntmp,no)
         do j=1,no
            occ_sub(j,i)=ntmp(j)
         enddo
         nc_sub(i)=no
         do j=1,no
            if (occ_sub(j,i).eq.0) then
               nc_sub(i)=j-1
               exit
            endif
         enddo
C
         write(string,'(a)') line(k2+1:256)
         ntmp=0
         call NJ_readlab(string,ntmp,no)
         L=nc_sub(i)
         do j=1,no
            k=ntmp(j)
            if (k.ne.0) then
               L=L+1
               if (L.gt.no) then
                  write(io,*) 'To many MOs in subsystem:',i
                  stop
               endif
               occ_sub(L,i)=k
            endif
         enddo
         no_sub(i)=L
      enddo
C
 100  deallocate(ntmp)
      if (io>0) then
         WRITE(io,*) '+++ Full MO domains by reading +++'
         WRITE(io,'('' The number of final domains ='',i5)') nsy
         write(io,*) '  No. Num   Cent         LMOs'
         write(line1,*) nsy; call NJ_trim(line1,k1,k2)
         do i=1,nsy
            if(nc_sub(i).eq.0)cycle
            kk=nc_sub(i)
            write(line1,*) kk; call NJ_trim(line1,k1,k2)
            allocate(ntmp(kk)); ntmp(1:kk)=occ_sub(1:kk,i)
            call NJ_prtlab(line3,kk,ntmp);  deallocate(ntmp)
            call NJ_trim(line3,k5,k6)
            kk=no_sub(i)-nc_sub(i)
            write(line2,*) kk; call NJ_trim(line2,k3,k4)
            allocate(ntmp(kk))
            ntmp(1:kk)=occ_sub(nc_sub(i)+1:nc_sub(i)+kk,i)
            call NJ_prtlab(line4,kk,ntmp);  deallocate(ntmp)
            call NJ_trim(line4,k7,k8)
            write(io,'(i5,a)')i,' ['//line1(k1:k2)//'+'//line2(k3:k4)
     &           //']: ('//line3(k5:k6)//') '//line4(k7:k8)
         enddo
      endif
C
      end
C
C --- 2008.03.07 Read extended subsystems from .dmn file
      subroutine ReadExt(io,isys,nat,nbs,J0,JF,J01,JF1,BA,ZA)
      implicit none
      integer io,isys,nat,nbs,J0,JF,J01,JF1
      integer i,j,k,L,m,n,k1,k2,k3,k4,k5,k6,kk
      integer BA(nat),ZA(nbs)
      character*512 line,line1,line2,line3,line4,string
      integer,allocatable::ntmp(:)
C
      write(io,*) '=== Read the extended subsystem from .dmn file ==='
      read(isys,'(a)',err=100,end=100) line
      k1=index(line,'['); k2=index(line,']')
      write(string,'(a)') line(k1+1:k2-1)
      read(string,*) J01
      write(io,*) 'The number of added atoms is',J01-J0
      kk=nat-J0
      allocate(ntmp(kk))
      ntmp=0
      write(string,'(a)') line(k2+1:256)
      call NJ_readlab(string,ntmp,kk)
      do i=1,kk
         BA(i+J0)=ntmp(i)
      enddo
      deallocate(ntmp)
C
      read(isys,'(a)',err=100,end=100) line
      k1=index(line,'['); k2=index(line,']')
      write(string,'(a)') line(k1+1:k2-1)
      read(string,*) JF1
      write(io,*) 'The number of added basis is',JF1-JF
      kk=nbs-JF
      allocate(ntmp(kk))
      ntmp=0
      write(string,'(a)') line(k2+1:256)
      call NJ_readlab(string,ntmp,kk)
      do i=1,kk
         ZA(i+JF)=ntmp(i)
      enddo
      deallocate(ntmp)
C
      return
C
 100  write(io,*) 'Error for reading the extended subsystems'
      stop
      end
C
C --- 2008.03.07 write extended subsystems from .dmn file
      subroutine WritExt(io,isys,nat,nbs,J0,JF,J01,JF1,BA,ZA)
      implicit none
      integer io,isys,nat,nbs,J0,JF,J01,JF1
      integer i,j,k,L,m,n,k1,k2,k3,k4,k5,k6,kk
      integer BA(nat),ZA(nbs)
      character*512 line,line1,line2,line3,line4,string
      integer,allocatable::ntmp(:)
C
      kk=nat-J0
      write(line1,*) J01
      call NJ_trim(line1,k1,k2)
      allocate(ntmp(kk))
      do i=1,kk
         ntmp(i)=BA(i+J0)
      enddo
      call NJ_prtlab(line2,kk,ntmp)
      deallocate(ntmp)
      call NJ_trim(line2,k3,k4)
      write(isys,'(a)') '['//line1(k1:k2)//'] '//line2(k3:k4)
C
      kk=nbs-JF
      write(line1,*) JF1
      call NJ_trim(line1,k1,k2)
      allocate(ntmp(kk))
      do i=1,kk
         ntmp(i)=ZA(i+JF)
      enddo
      call NJ_prtlab(line2,kk,ntmp)
      deallocate(ntmp)
      call NJ_trim(line2,k3,k4)
      write(isys,'(a)') '['//line1(k1:k2)//'] '//line2(k3:k4)
C
      end
C
C
C --- 2008.03.03 Decide the symmetry of occupied orbitals ---
      subroutine SymmOrb2(io,nmo,ncor,no,FIJ,IWORK,RWORK,KSymm)
      implicit none
      integer io,nmo,ncor,no,i,j,k,L,m,n,LLL,kk,k1,k2,k3,k4,k5,k6
      integer KSymm(no),IWORK(100)  ! ,IrMO(no)
      double precision FIJ(no,no),eps,pii,pjj,pij,p1,p2,RWORK(100)
      character(len=256) line,line1,line2,line3
      integer,allocatable::symo(:,:),nsymo(:),ntmp(:),IrMO(:)
C
      allocate(IrMO(no))
C
      do i=1,no
         KSymm(i)=i
         IrMO(i)=0
      enddo
C
      do i=2,no
         pii=FIJ(i,i)
         do j=1,i-1
            pjj=FIJ(j,j)
            if (dabs(pjj-pii).lt.RWORK(9)) then
               KSymm(i)=KSymm(j)
               exit
            endif
         enddo
      enddo
C
      do i=1,no
         if (KSymm(i).eq.i) KSymm(i)=0
      enddo
C
      LLL=0
      do i=ncor+1,no
         if (KSymm(i).eq.0) then
            LLL=LLL+1
            IrMO(LLL)=i
         endif
      enddo
C
      if (LLL.eq.no-ncor) then
C        write(io,*) 'No symmetric LMOs for this system'
         return
      endif
C
      allocate(symo(no,LLL),nsymo(LLL))
      symo=0
      nsymo=0
      do i=1,LLL
         symo(1,i)=IrMO(i)
         m=IrMO(i)
         L=1
         do j=ncor+1,no
            if (j.eq.m) cycle
            if (KSymm(j).eq.m) then
               L=L+1
               symo(L,i)=j
            endif
         enddo
         nsymo(i)=L
      enddo
C
C     write(io,*) '=== Checking the symmetry of occupied LMOs ==='
C     write(io,100) RWORK(9)
C     write(io,*) 'NO LMOs'
C     do i=1,LLL
C        write(line1,*) i
C        call NJ_trim(line1,k1,k2)
C        kk=nsymo(i)
C        call NJ_prtlab(line2,kk,symo(1,i))
C        call NJ_trim(line2,k3,k4)
C        write(io,*) line1(k1:k2)//' ('//line2(k3:k4)//')'
C     enddo
C
      if (IWORK(6).ne.0) then
         IWORK(6)=LLL
         write(io,*) 'The symmetry of occupied LMOs are used'
      else
         do i=1,no
            KSymm(i)=0
         enddo
C        write(io,*) 'The symmetry of occupied LMOs are not used'
      endif
      write(io,*)
C
 100  format(1x,'The threshold of Fock matrix =',d12.4)
      deallocate(symo,nsymo,IrMO)
C
      end
C
C --- Sort integer array ---
      subroutine isort(n,A)
      integer n,A(n),i,j,k1,k2,L
C
      do i=1,n-1
         do j=i+1,n
            if (A(i).gt.A(j)) then
               L=A(i)
               A(i)=A(j)
               A(j)=L
            endif
         enddo
      enddo
C
      end
C
CMWSC --- Sort integer array ---
CMWS      subroutine absisort(n,A)
CMWS      integer n,A(n),i,j,k1,k2,L
CMWSC
CMWS      do i=1,n-1
CMWS         do j=i+1,n
CMWS            if (abs(A(i)).gt.abs(A(j))) then
CMWS               L=A(i)
CMWS               A(i)=A(j)
CMWS               A(j)=L
CMWS            endif
CMWS         enddo
CMWS      enddo
CMWSC
CMWS      end
C
C---------------------------------------------------------------------
C     CONSTRUCT THE ATOMIC DOMAIN OF EACH MO DOMAIN --07.01.26
!        call COA(NATOM,NW,NMO,NUW,NB,SOB,SNB,INF(1,I),ISUB(I),
!    &        NAsub(KGG),BA(1,KGG),NWsub(KGG),ZA(1,KGG))
C---------------------------------------------------------------------
      subroutine COA(NATOM,NW,NMO,NUW,nb,SOB,SNB,INF,ISUB,J0,BA,JF,ZA)
      integer SOB(NMO,NATOM),SNB(NUW),INF(NUW),BA(NATOM),ZA(NW)
      integer nb(NATOM)
C
      ii=INF(1)
      J0=SNB(ii)
C
      DO J=1,J0
         BA(J)=SOB(ii,J)
      enddo
C
      J2=J0
      DO J=2,ISUB
         J1=INF(J)
         DO 3689 K=1,SNB(J1)
            DO  L=1,J0
               IF (SOB(J1,K).EQ.BA(L))GO TO 3689
            enddo
            J2=J2+1
            BA(J2)=SOB(J1,K)
3689     CONTINUE
         J0=J2
      enddo
C
        ZA=0;JF=0
        DO 3695 J=1,J0
           K1=nb(BA(J))
           if(BA(j).ne.NATOM)then
            K2=nb(BA(J)+1)-1
           else
            K2=NW
           endif
           DO 3697 K=K1,K2
              JF=JF+1
              ZA(JF)=K
3697       CONTINUE
3695    CONTINUE
      return
      end
C
c     ##############################################################
c     ##  subroutine NJ_dislink  --  atoms distance&link matrix   ##
c     ##  2005.01.09 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################
c
c     2005.04.12 modify ad from 0.2 to 0.1
c     2005.05.07 modify ad from 0.1 to 0.15
c
      subroutine NJ_dislink(io,nat,nuchar,coor,dis,link)
      implicit none
      integer io,nat,link(nat,nat),i,j,k,l,lk(10)
      real*8 nuchar(nat),coor(3,nat),dis(nat,nat),x,y,z,dis0,radius,ad
      real*4 bdtp(10)
      parameter (ad=0.168d0) ! 2005.05.22 0.16 --> 0.168
      external radius

      dis=0d0; link=0
      do i=1,nat-1; do j=i+1,nat
         x=coor(1,i)-coor(1,j)
         y=coor(2,i)-coor(2,j)
         z=coor(3,i)-coor(3,j)
         dis(i,j)=dsqrt(x*x+y*y+z*z); dis(j,i)=dis(i,j)
         k=nint(nuchar(i)); l=nint(nuchar(j))
         dis0=radius(k)+radius(l)+ad
         if (dis(i,j)<dis0) then
            link(i,j)=1; link(j,i)=1
         endif
      enddo; enddo

      if (io>0) then
         write(io,*) '*** Distance matrix (angstroms) ***'
         call NJ_prtsym(io,nat,dis,'f11.6')
         write(io,*)
         write(io,*) '*** Geometry links ***'
         do i=1,nat
            lk=0; bdtp=0.0; k=0
            do j=i+1,nat
               if (link(i,j).ne.0) then
                  k=k+1; lk(k)=j; bdtp(k)=real(link(i,j))
               endif
            enddo
            write(io,'(i6,2x,10(i6,f4.1))') i,(lk(j),bdtp(j),j=1,k)
         enddo
         write(io,*)
      endif

      end
CMWSC
CMWSC 2006.12.16 modify to van de Walls radii
CMWS      subroutine NJ_dislink1(io,nat,nuchar,coor,dis,link,link_vdw)
CMWS      implicit none
CMWS      integer io,nat,link(nat,nat),i,j,k,l,lk(10),link_vdw(nat,nat)
CMWS      real*8 nuchar(nat),coor(3,nat),dis(nat,nat),x,y,z,dis0,radius,ad
CMWS      real*8 radius_vdw,dis_vdw,dis1
CMWS      real*4 bdtp(10)
CMWS      parameter (ad=0.168d0) ! 2005.05.22 0.16 --> 0.168
CMWS      external radius,radius_vdw
CMWS
CMWS      dis=0d0; link=0
CMWS      do i=1,nat-1; do j=i+1,nat
CMWS         x=coor(1,i)-coor(1,j)
CMWS         y=coor(2,i)-coor(2,j)
CMWS         z=coor(3,i)-coor(3,j)
CMWS         dis(i,j)=dsqrt(x*x+y*y+z*z); dis(j,i)=dis(i,j)
CMWS         k=nint(nuchar(i)); l=nint(nuchar(j))
CMWS         dis0=radius(k)+radius(l)+ad
CMWS         dis1=radius_vdw(k)+radius_vdw(l)
CMWS         if (dis(i,j)<dis0) then
CMWS            link(i,j)=1; link(j,i)=1
CMWS         endif
CMWS         if (dis(i,j)<dis1) then
CMWS            link_vdw(i,j)=1; link_vdw(j,i)=1
CMWS         endif
CMWS      enddo; enddo
CMWS
CMWS      if (io>0) then
CMWS         write(io,*) '*** Distance matrix (angstroms) ***'
CMWS         call NJ_prtsym(io,nat,dis,'f11.6')
CMWS         write(io,*)
CMWS         write(io,*) '*** Geometry links ***'
CMWS         do i=1,nat
CMWS            lk=0; bdtp=0.0; k=0
CMWS            do j=i+1,nat
CMWS               if (link(i,j).ne.0) then
CMWS                  k=k+1; lk(k)=j; bdtp(k)=real(link(i,j))
CMWS               endif
CMWS            enddo
CMWS            write(io,'(i6,2x,10(i6,f4.1))') i,(lk(j),bdtp(j),j=1,k)
CMWS         enddo
CMWS         write(io,*)
CMWS      endif
CMWS
CMWS      end
C
C --- 2006.05.21 IDis Calc.
      subroutine NJ_idis(nat,link,IDis)
      implicit none
      integer nat,link(nat,nat),IDis(nat,nat),i,j,k,L,m,n
C
      IDis=100000
C
      do i=1,nat-1
         do j=i+1,nat
            if (link(i,j)==1) then
               IDis(i,j)=1
               IDis(j,i)=1
            endif
         enddo
      enddo
C
      do m=1,10
         do i=1,nat-1
            do j=i+1,nat
               do k=1,nat
                  if (k==i.or.k==j) cycle
                  L=IDis(i,k)+IDis(j,k)
                  if (L.ne.m) cycle
                  if (L<IDis(i,j)) then
                     IDis(i,j)=L
                     IDis(j,i)=L
                  endif
               enddo
            enddo
         enddo
      enddo
C
      do i=1,nat
         IDis(i,i)=0
      enddo
C
      end
C
c     ##############################################################
c     ##  function radius  --  radius for an atom on order        ##
c     ##  2005.01.09 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################
c
c     2005.05.07 modify r(S) from 1.01 to 1.11
c
      function radius(n)
      implicit none
      integer n
      real*8 radius,Radi(109)

      data Radi/0.30d0,1.16d0,1.23d0,0.89d0,0.88d0,
     &     0.77d0,0.70d0,0.66d0,0.58d0,0.55d0,
     &     1.40d0,1.36d0,1.25d0,1.17d0,1.10d0,
     &     1.11d0,0.99d0,1.58d0,2.03d0,1.74d0,
     &     1.44d0,1.32d0,1.20d0,1.13d0,1.17d0,
     &     1.16d0,1.16d0,1.15d0,1.17d0,1.25d0,
     &     1.25d0,1.22d0,1.21d0,1.17d0,1.14d0,
     &     1.89d0,2.25d0,1.92d0,1.62d0,1.45d0,
     &     1.34d0,1.29d0,1.23d0,1.24d0,1.25d0,
     &     1.28d0,1.34d0,1.41d0,1.50d0,1.40d0,
     &     1.41d0,1.37d0,1.33d0,2.09d0,2.35d0,
     &     1.98d0,1.69d0,1.65d0,1.65d0,1.64d0,
     &     1.64d0,1.66d0,1.85d0,1.61d0,1.59d0,
     &     1.59d0,1.58d0,1.57d0,1.56d0,1.70d0,
     &     1.56d0,1.44d0,1.34d0,1.30d0,1.28d0,
     &     1.26d0,1.26d0,1.29d0,1.34d0,1.44d0,
     &     1.55d0,1.54d0,1.52d0,1.53d0,1.52d0,
     &     1.53d0,2.45d0,2.02d0,1.70d0,1.63d0,
     &     1.46d0,1.40d0,1.36d0,1.25d0,1.57d0,
     &     1.58d0,1.54d0,1.53d0,1.84d0,1.61d0,
     &     1.50d0,1.49d0,1.38d0,1.36d0,1.26d0,
     &     1.20d0,1.16d0,1.14d0,1.06d0/

      if (n>109) stop 'Nuclear charge >109'
      radius=Radi(n)

      end


CMWSc     ##############################################################
CMWSc     ##  function radius  --  radius for an atom on symbol       ##
CMWSc     ##  2005.01.09 by Wei Li; Update 2005.10.16 by Wei Li       ##
CMWSc     ##############################################################
CMWSc
CMWS      function radich(a)
CMWS      implicit none
CMWS      integer n,elemord
CMWS      character a*2
CMWS      real*8 radich,radius
CMWS      external elemord,radius
CMWS
CMWS      n=elemord(a)
CMWS      radich=radius(n)
CMWS
CMWS      end
C
CMWSc     ##############################################################
CMWSC     2006.12.16 modified by sj
CMWSC     van der Waals radii/from Bondi:H--K,witout Be
CMWSc     ##############################################################
CMWS      double precision function radius_vdw(n)
CMWS      implicit none
CMWS      integer n
CMWS      real*8 radius_vdw,Radi(109)
CMWS
CMWS      data Radi/1.20d0,1.40d0,1.82d0,0.89d0,2.13d0,
CMWS     &     1.70d0,1.55d0,1.52d0,1.47d0,1.54d0,
CMWS     &     2.27d0,1.73d0,2.51d0,2.10d0,1.80d0,
CMWS     &     1.75d0,1.88d0,2.75d0,2.03d0,1.74d0,
CMWS     &     1.44d0,1.32d0,1.20d0,1.13d0,1.17d0,
CMWS     &     1.16d0,1.16d0,1.15d0,1.17d0,1.25d0,
CMWS     &     1.25d0,1.22d0,1.21d0,1.17d0,1.14d0,
CMWS     &     1.89d0,2.25d0,1.92d0,1.62d0,1.45d0,
CMWS     &     1.34d0,1.29d0,1.23d0,1.24d0,1.25d0,
CMWS     &     1.28d0,1.34d0,1.41d0,1.50d0,1.40d0,
CMWS     &     1.41d0,1.37d0,1.33d0,2.09d0,2.35d0,
CMWS     &     1.98d0,1.69d0,1.65d0,1.65d0,1.64d0,
CMWS     &     1.64d0,1.66d0,1.85d0,1.61d0,1.59d0,
CMWS     &     1.59d0,1.58d0,1.57d0,1.56d0,1.70d0,
CMWS     &     1.56d0,1.44d0,1.34d0,1.30d0,1.28d0,
CMWS     &     1.26d0,1.26d0,1.29d0,1.34d0,1.44d0,
CMWS     &     1.55d0,1.54d0,1.52d0,1.53d0,1.52d0,
CMWS     &     1.53d0,2.45d0,2.02d0,1.70d0,1.63d0,
CMWS     &     1.46d0,1.40d0,1.36d0,1.25d0,1.57d0,
CMWS     &     1.58d0,1.54d0,1.53d0,1.84d0,1.61d0,
CMWS     &     1.50d0,1.49d0,1.38d0,1.36d0,1.26d0,
CMWS     &     1.20d0,1.16d0,1.14d0,1.06d0/
CMWS      if (n>109) stop 'Nuclear charge >109'
CMWS      radius_vdw=Radi(n)
CMWS      end
C
CMWS      double precision function radich_vdw(a)
CMWS      implicit none
CMWS      integer n,elemord
CMWS      character a*2
CMWS      real*8 radich_vdw,radius_vdw
CMWS      external elemord,radius_vdw
CMWS
CMWS      n=elemord(a)
CMWS      radich_vdw=radius_vdw(n)
CMWS
CMWS      end
C
c     ##############################################################
c     ##  subroutine NJ_readfrg - read integer Ftmp() from a line ##
c     ##  2004.04.29 by Wei Li; Update 2008.03.03 by Wei Li       ##
c     ##############################################################
c
c     2004.04.29 read integer Ftmp() from a line*lst with format (i,j,k-m,n)
c
      subroutine NJ_readlab(string,Ftmp,IFrg)
      character string*(*),string2*1024,string3*1024
      integer Ftmp(IFrg)

      Ftmp=0; lst=len(string)
      if (lst>1024) stop 'Too long string (>1024) for ReadLab()'

      Nlink=index(string,'-')
      lll=1
      if (Nlink.eq.0) then
         read(string,*,err=2990,end=2990) (Ftmp(j),j=1,IFrg),kk
         if (kk.ne.0) then
            write(*,*) 'Error: Too more atoms in a fragment'
            stop '1'
         endif
      else
         Ncomma=index(string,',')
         if (Ncomma.eq.0) then
            write(string2,'(A)') string(1:Nlink-1)
          read(string2,*) ini
            write(string2,'(A)') string(Nlink+1:lst)
          read(string2,*) ifi
            if (ifi-ini+1.gt.IFrg) then
               write(*,*) 'Error: Too more atoms in ',
     &       'fragment or too small size of fragment'
               stop '2'
            endif
            do 2500 kkk=ini,ifi
               Ftmp(lll)=kkk
               lll=lll+1
2500        continue
         else
            write(string2,'(A)') string(1:Ncomma-1)
            Nlink=index(string2,'-')
            if (Nlink.eq.0) then
               read(string2,*) Ftmp(lll)
               lll=lll+1
            else
               write(string3,'(A)') string2(1:Nlink-1)
               read(string3,*) ini
               write(string3,'(A)') string2(Nlink+1:lst)
               read(string3,*) ifi

               if (ifi-ini+1.gt.IFrg) then
                  write(*,*) 'Error: Too more atoms in ',
     &          'fragment or too small size of fragment'
                  stop '3'
               endif
               do 2510 kkk=ini,ifi
                  Ftmp(lll)=kkk
                  lll=lll+1
2510           continue
            endif

            do 2520 jjj=1,IFrg
               string2=string(Ncomma+1:lst)
               write(string,'(A)') trim(string2)   !-WL- 2008.03.03 string2 --> trim(string2)
               Ncomma=index(string,',')
               if (Ncomma.ne.0) then
                  write(string2,'(A)') string(1:Ncomma-1)
               else
                  write(string2,'(A)') string
               endif

               Nlink=index(string2,'-')

               if (Nlink.eq.0) then
                  read(string2,*) Ftmp(lll)
                  lll=lll+1
               else
                  write(string3,'(A)') string2(1:Nlink-1)
                  read(string3,*) ini
                  write(string3,'(A)') string2(Nlink+1:lst)
                  read(string3,*) ifi

                  if (ifi-ini+1.gt.IFrg) then
                     write(*,*) 'Error: Too more atoms in ',
     &             'fragment or too small size of fragment'
                     stop '4'
                  endif
                  do 2530 kkk=ini,ifi
                     Ftmp(lll)=kkk
                     lll=lll+1
2530              continue
               endif

               if (Ncomma.eq.0) goto 2990
2520        continue
         endif
      endif

2990  if (lll.gt.IFrg+1) then
         write(*,*) 'Error: Too more atoms in ',
     & 'fragment or too small size of fragment'
         stop '5'
      endif

      return
      end
C
c     ##############################################################
c     ##  subroutine NJ_prtlab  --  write Ktmp(kk) into line      ##
c     ##  2005.01.09 by Wei Li; Update 2005.10.16 by Wei Li       ##
c     ##############################################################
c
c     Format: "1,3,5-8,2*0,9"
c
      subroutine NJ_prtlab(line,kk,Ktmp)
      integer Ktmp(kk),kkk
      parameter (linemax=80)
      character ch,ch2,line*(*),line1*100,line2*100
      parameter (ch=',',ch2='-')

      line=' '; ini=1; fc=1
      if (kk==0) return

      write(line1,*) Ktmp(1)
      call NJ_trim(line1,k1,k2)
      line(ini:ini+k2-k1)=line1(k1:k2)
      ini=ini+k2-k1+1
      nz=0
C
      kkk=min(2,kk)
C
      if (Ktmp(1)==0.and.Ktmp(kkk)==0) then
         fc=0; nz=1; ini=1
      endif

      do 110 i=2,kk
         write(line1,*) Ktmp(i)
         call NJ_trim(line1,k1,k2)
         if (Ktmp(i)-Ktmp(i-1)==1) then
            if (i<kk) kkk=Ktmp(i+1)-Ktmp(i)
            if (i==kk.or.kkk.ne.1) then
               line(ini:ini+k2-k1+1)=ch2//line1(k1:k2)
               ini=ini+k2-k1+2
            endif
         elseif (Ktmp(i)==0) then
            nz=nz+1
            if (i==kk) then
               if (nz==1) then
                  line(ini:ini+1)=ch//'0'; ini=ini+2
               else
                  write(line2,*) nz; call NJ_trim(line2,k3,k4)
                  if (fc==1) then  ! 2005.01.09 add
                     line(ini:ini+k4-k3+3)=ch//line2(k3:k4)//'*0'
                     ini=ini+k4-k3+4; exit
                  else
                     line(ini:ini+k4-k3+2)=line2(k3:k4)//'*0'
                     ini=ini+k4-k3+3; fc=1; exit
                  endif
               endif
            else
               if (Ktmp(i+1).ne.0.and.nz==1) then
                  line(ini:ini+1)=ch//'0'; ini=ini+2; nz=0
               elseif (Ktmp(i+1).ne.0.and.nz.ne.1) then
                  write(line2,*) nz; call NJ_trim(line2,k3,k4)
                  if (fc==1) then  ! 2005.01.09 add
                     line(ini:ini+k4-k3+3)=ch//line2(k3:k4)//'*0'
                     ini=ini+k4-k3+4; nz=0
                  else
                     line(ini:ini+k4-k3+2)=line2(k3:k4)//'*0'
                     ini=ini+k4-k3+3; nz=0; fc=1
                  endif
               endif
            endif
         else
            line(ini:ini+k2-k1+1)=ch//line1(k1:k2)
            ini=ini+k2-k1+2
         endif
 110  enddo

      end
C*MODULE CIMI    *DECK CIMCALC
C>
C> @brief   Calculations of I-th subsystem
C>
C> @details Calculations of I-th subsystem
C>
C> @author  probably Wei Li
C>
C
      subroutine CIMCalc(I,io,isys,NATOM,NW,NUW,Nmo,NCORE,
     &     IWORK,RWORK, numc
     &     ,numh,natc,nath,nuchar,coor,dis,link,SMO,FK,SOVER,admx,admy,
     &     admz,NB,BAA,ZAA,SOB,SNB,NASUB,NWSUB,SR1,INF2,ISUB3,ISUB4,KGG,
C-WL-&     basis,gmsname,kmem,imethd,ED,NCLU)
C-WL-&     basis,gmsname,kmem,imethd,ED,NCLU,HCORE,mthd0)  !-WL- 2007.10.18 add mthd0
     &     basis,gmsname,kmem,ED,NCLU,scftyp,levlsys,
     &     job,istop,mbytes,ISUB5,NOB,FKB,  !-WL- 2007.10.18 add mthd
     &     CenMO,path,user,NCBS,CBAS)
      implicit none

C     COMMON /IOFILE/ IR2,Io,IP2,IS2,IPK2,IDAF2,NAV2,IODA2(950)
C     COMMON /CIMINF/ ICIM2,inp,MOTYP2,NCA2,NCB2  !-CIM-
C     integer icim2,ir2,ip2,is2,ipk2,idaf2,nav2,ioda2,nca2,ncb2
C     character*8 motyp2

      integer kkk
      integer thissystem
      integer inp,itmp,itmp1,icim,isys,job,istop
      parameter(inp=111,itmp=115,itmp1=116)  ! liwei
      parameter(icim=117)
      integer io,NATOM,NW,NUW,Nmo,I,j,k,L,m,n,NCORE,LLL,ierr,NOA,NOB
      integer k1,k2,k3,k4,kmem,NV,I8,imethd
      integer KGG,numc,numh,KU,KB,J0,JF,NF,J01,JF1,NA,KB1,local
      integer KV,KVA,KCC,JF_sub,J0_sub
      character line*500,line1*500,line2*500,command*500
      character*100 gmsname,subname,inpname
      character*100 outname,tmpname,cimname
      character mem*20,mthd*20,basis*30,runtyp*20,mthd0*20
      character*8 scftyp,cctyp
      character path*200,user*50
      integer mplevl,IWORK(100)
      integer I_rd,KU_rd,KB_rd,J0_rd,JF_rd
      integer KBB,KUB,CenMO(NUW,KGG),mult,nucl,icharg
C
      double precision PP,EE,RWORK(100)
      double precision SOVER(NW,NW),SMO(NW,Nmo)
      double precision nuchar(NATOM),coor(3,NATOM),FK(NW,NW),FKB(NW,NW)
      double precision admx(NW,NW),admy(NW,NW),admz(NW,NW)
C
      double precision SR1(NATOM,Nmo),dis(NATOM,NATOM),ED(NUW),ps
      integer SNB(NUW),SOB(Nmo,NATOM),INF2(NUW,NUW),NCLU(NUW)
      integer ISUB3(NUW),ISUB4(NUW),BAA(NATOM,NUW),ZAA(NW,NUW),NB(NATOM)
      integer NASUB(NUW),NWSUB(NUW),natc(NATOM),nath(NATOM)
      integer link(NATOM,NATOM),link2(NATOM,NATOM)
      integer ISUB5(NUW)    !-WL- 2009.03.18 For NU
C
      integer,dimension(:),allocatable::ML,Ktmp,BA,ZA
      double precision,dimension(:,:),allocatable::MOS,MOS2,F2,F2B,FH
      double precision,dimension(:,:),allocatable::MOS1
      double precision,dimension(:,:),allocatable::VECT,MAT,AVECT,OVS3
      double precision,dimension(:,:),allocatable::AVECTB
      double precision,dimension(:),allocatable::VALU,VC,FHH
      double precision,dimension(:),allocatable::dtmp,RCent
      double precision,dimension(:,:),allocatable::DM,PPS
      double precision trace,dtrace2
      external dtrace2
C
      integer LF2,nelec,nwords,mwords,memgms,levlsys,mbytes
      external memgms
      integer NCBS(NATOM)
      character(len=100) CBAS(100,NATOM)
C
      logical exst
      integer (kind=4) Wall0,Wall,TIME
      real*8 Tim0,CPUTim
      external CPUTim !,TIME
CMWS      integer,external::system
C
      if (levlsys.eq.0) return
C
      Tim0=CPUTim(0)
C     Wall0=TIME()
C
      write(io,'(1x,16(''-''))')
      write(io,'(''  SUBSYSTEM'',i5)') I
      write(io,'(1x,16(''-''))')
C
      call NJ_trim(gmsname,k1,k2)
      write(line,*) I
      call NJ_trim(line,k3,k4)
      subname=gmsname(k1:k2-3)//'Sys-'//line(k3:k4)
      inpname=trim(subname(1:96))//'.inp'
      outname=trim(subname(1:96))//'.log'
      tmpname=trim(subname(1:96))//'.tmp'
      cimname=trim(subname(1:96))//'.cim'
      inquire(file=inpname,exist=exst)
      if(exst) then
         levlsys = -1
         write(io,"('Subsystem input exists.'/)")
         write(io,"('Continuing to the next'/)")
         return
      endif
C
      L=levlsys
      if (L.eq.1) then
         mplevl = 2
         cctyp  = 'NONE    '
      elseif (L.eq.2) then
         mplevl = 0
         cctyp  = 'CCD     '
      elseif (L.eq.3) then
         mplevl = 0
         cctyp  = 'CCSD    '
      elseif (L.eq.4) then
         mplevl = 0
         cctyp  = 'CCSD(T) '
      elseif (L.eq.5) then
         mplevl = 0
         cctyp  = 'CR-CCL  '
      else
         write(io,'('' Unknown level'',i3,'' for subsys:'',i5)') L,I
         call abrt
      endif
C
      KU=ISUB3(I)   ! Number of occupied orbitals in the cluster
      KB=ISUB4(I)   ! Number of occupied orbitals in the subsystem
      J0=NAsub(I)   ! Number of atoms in the subunit
      JF=NWsub(I)   ! Number of basis functions in the subunit
C
C---------------------------------------------------------------------
      allocate(ML(NUW),BA(NATOM),ZA(NW))
      ML(1:NUW)=INF2(1:NUW,I)
      do kkk=1,natom
         BA(kkk) = BAA(kkk,I)
      enddo
      ZA(1:NW)=ZAA(1:NW,I)
C
C--- liwei 10 Feb 2009 --- Decide the spin and mult here
      mult=1
      do J=1,KB
         if (ML(J).gt.NOB) mult=mult+1
      enddo
      KBB=KB+1-mult
C
C --- 2 JUL 10 -WL,PP- KUB = KU if single-occ MO is environment MO
C     KUB=KU+1-mult
      KUB=0
      do k=1,KB
         if (CenMO(k,I).eq.2) KUB=KUB+1
      enddo
C
      if (mult.eq.1) then
         if (IWORK(14).eq.0) then
            write(io,*) 'Closed shell subsystem: SCFTYP=RHF'
            scftyp='RHF     '
         else
            write(io,*) 'Closed shell subsystem: SCFTYP=ROHF'
            scftyp='ROHF    '
         endif
      else
         write(io,*) 'Open shell subsystem  : SCFTYP=ROHF'
         write(io,'(1x,"MULT = ",i3)') mult
         scftyp='ROHF    '
      endif
C--- liwei 10 Feb 2009 --- END
C
C---------------------------------------------------------------------
C     REORDER ML(I),I=1,KU, FROM SMALL TO LARGE. 2001.4.17.
C---------------------------------------------------------------------
      if (KU.gt.1)then
         DO 3660 J=1,KU-1
            NF=ML(J)
            DO 3670 K=J+1,KU
               IF (ML(K).LT.NF) THEN
                  NF=ML(K)
                  ML(K)=ML(J)
                  ML(J)=NF
               ENDIF
3670        CONTINUE
3660     CONTINUE
      endif
C
C---------------------------------------------------------------------
C     TO CONSTRUCT SUBSYSTEM DOMAINS. 2001.4.24.
C---------------------------------------------------------------------
      write(line1,*) KU;   call NJ_trim(line1,k1,k2)
      allocate(Ktmp(KU))
      do kkk=1,ku
         Ktmp(kkk) = ML(kkk)
      enddo
      call NJ_prtlab(line2,KU,Ktmp)
      deallocate(Ktmp)
      write(io,'(a)') ' Central Orbitals ('
     &               //line1(k1:k2)//'): '//trim(line2)
C
      write(line1,*) KB-KU;   call NJ_trim(line1,k1,k2)
      allocate(Ktmp(KB-KU));  Ktmp(1:KB-KU)=ML(KU+1:KB)
      call NJ_prtlab(line2,KB-KU,Ktmp);  deallocate(Ktmp)
      write(io,'(a)') ' Environment orbitals ('
     *   //line1(k1:k2)//'): '//trim(line2)
C
      write(line1,*) J0;   call NJ_trim(line1,k1,k2)
      allocate(Ktmp(J0));  Ktmp(1:J0)=BA(1:J0)
      call NJ_prtlab(line2,J0,Ktmp);  deallocate(Ktmp)
      write(io,'(a)') ' Atoms ('//line1(k1:k2)//'): '//trim(line2)
      write(io,'(" Basis Functions: ",i5)') jf
C
C     write(line1,*) JF;   call NJ_trim(line1,k1,k2)
C     allocate(Ktmp(JF));  Ktmp(1:JF)=ZA(1:JF)
C     call NJ_prtlab(line2,JF,Ktmp);  deallocate(Ktmp)
C     write(io,'(a)') ' Basis ('//line1(k1:k2)//'): '//trim(line2)
C
      if (IWORK(7).eq.0) then
         write(isys,*)
         write(isys,'(i5)') I
         write(isys,'(4i5)') KU,KB,J0,JF
      else
         read(isys,*,end=251)
         read(isys,*,end=252) I_rd
         read(isys,*,end=253) KU_rd,KB_rd,J0_rd,JF_rd
         ierr=0
         if (I_rd.ne.I) ierr=ierr+1
         if (KU_rd.ne.KU) ierr=ierr+1
         if (KB_rd.ne.KB) ierr=ierr+1
         if (ierr.ne.0) then
           write(io,*)'The number of ERRORS is',ierr
           write(io,*)'Calc I,KU,KB =',I,KU,KB
           write(io,*)'Read I,KU,KB =',I_rd,KU_rd,KB_rd
           STOP
         endif
         ierr=0
         if (J0_rd.ne.J0) ierr=ierr+1
         if (JF_rd.ne.JF) ierr=ierr+1
         if (ierr.ne.0) then
           write(io,*)'The number of WARNINGS is',ierr
           write(io,*)'Calc J0,JF =',J0,JF
           write(io,*)'Read J0,JF =',J0_rd,JF_rd
           IWORK(7)=0
           write(io,*) 'WARNING: Only occ MOs can be read ...'
         endif
C
         goto 300
 251     write(isys,*)
 252     write(isys,'(i5)') I
 253     write(isys,'(4i5)') KU,KB,J0,JF
         IWORK(7)=0
         write(io,*) 'Warn: Only occ MOs can be read ...'
      endif
C
C---------------------------------------------------------------------
C     Add buffer atoms in order to construct virtual orbitals
C---------------------------------------------------------------------
 300  continue
      write(io,*)
      write(io,*) '--- GENERATING EXTENDED SUBSYSTEM AND ORBITALS ---'
      if (IWORK(7).eq.0) then
         if (J0.lt.NATOM)then   ! .and. dabs(WRK(5)).gt.1d-5  2008.05.09 Add dabs(WRK(5)) for no expanded subsys for dis=0
            call AddAtom(NATOM,NW,Nmo,NUW,nb,numc,numh,natc,nath,
     &           J0,JF,J01,JF1,ML,BA,ZA,link,dis,RWORK)
         else
            J01=J0
            JF1=JF
         endif
         call WritExt(io,isys,NATOM,NW,J0,JF,J01,JF1,BA,ZA)
      else
         call ReadExt(io,isys,NATOM,NW,J0,JF,J01,JF1,BA,ZA)
      endif
C
      if (J01.eq.NATOM)then
         write(io,*)'*** The extended subsystem includes',
     *       ' the whole molecule ***'
      endif
C
      write(line1,*) J01-J0;   call NJ_trim(line1,k1,k2)
      allocate(Ktmp(J01-J0));  Ktmp(1:J01-J0)=BA(J0+1:J01)
      call NJ_prtlab(line2,J01-J0,Ktmp);  deallocate(Ktmp)
C     write(io,'(a)') ' Added Atoms ('//line1(k1:k2)//'): '//trim(line2)
      write(io,'(a)') ' Added Atoms: '//line1(k1:k2)
C
      write(line1,*) JF1-JF;   call NJ_trim(line1,k1,k2)
      allocate(Ktmp(JF1-JF));  Ktmp(1:JF1-JF)=ZA(JF+1:JF1)
      call NJ_prtlab(line2,JF1-JF,Ktmp);  deallocate(Ktmp)
C     write(io,'(a)') ' Added Basis ('//line1(k1:k2)//'): '//trim(line2)
      write(io,'(a)') ' Added Basis Functions: '//line1(k1:k2)
C
C --- Add Occ MOs KB --> KB1-- ML(KB+1:KB1) -------------------------------
         KB1=KB
         do j=1,NUW
          do k=1,KB
           if(j.eq.ML(k))goto 240
          enddo
          ps=0.0d0
          do k=1,J01
           ps=ps+SR1(BA(k),j)
          enddo
          if(ps.gt.RWORK(8))then
            KB1=KB1+1;ML(KB1)=j
            goto 240
           endif
240      enddo
C
      write(line1,*) KB1-KB;   call NJ_trim(line1,k1,k2)
      allocate(Ktmp(KB1-KB));  Ktmp(1:KB1-KB)=ML(KB+1:KB1)
      call NJ_prtlab(line,KB1-KB,Ktmp);  deallocate(Ktmp)
      write(io,'(a)')' Added Occ Orb ('//line1(k1:k2)//'): '//trim(line)
C --------------------------------------------------------------------------

      call flshbf(io)
C
C-WL- ADD; This is important   !-WL- 11/16 moved here
      INF2(1:NUW,I)=ML(1:NUW)
C
C---------------------------------------------------------------------
C     TO ASSIGN VIRTUAL ORBITALS TO THIS SUBSYSTEM. 2006.5.24.
C---------------------------------------------------------------------
      allocate(MOS1(JF1,JF1),MOS2(JF,JF),OVS3(JF,JF))  !-WL- ADD MOS1 2008.02.25
C --- liwei here
      local=1  ! 1~ Boys  3~ Pop ! -----------------
      call COV(io,isys,NATOM,NW,Nmo,NUW,nb,
     &J0,JF,J01,JF1,NA,KB,KB1,ML,BA,ZA,SR1,admx,admy,admz,
     &SOVER,SMO,MOS1,MOS2,local,OVS3,IWORK,RWORK)
C
      WRITE(io,705) NA-KB
      WRITE(io,706) NA
C
      if (NA==KB) then
        write(io,*) 'Error: Number of virtual orbitals is zero'
        stop
      endif
C
C ----------------------- WL 2008.02.26 ------------------------
C     IWORK(2)=1~4                 ! Use LMOs projected on subsystems
C     IWORK(2)=11                  ! Use LMOs projected on extended subsystems
C     You can use motyp=k as keyword after '#' in input file (default IWOORRK(2)=2)
      JF_sub=JF                  ! Save the number of AOs on subsystem as JF_sub
      J0_sub=J0                  ! Save the number of atoms on subsystem as J0_sub
C
      if (IWORK(2).ge.1.and.IWORK(2).le.10) then      ! MOS2(JF,JF) --> MOS(JF,NA): LMOs of cluster
         allocate(MOS(JF,NA))
         do j=1,NA
            do k=1,JF
               MOS(k,j)=MOS2(k,j)
            enddo
         enddo
      elseif (IWORK(2).ge.11) then  ! MOS1(JF1,JF1) --> MOS(JF1,NA): LMOs of cluster (JF1=JF)
         write(io,*) 'The MOs on AOs in extended subsystems are used'
         JF= JF1                 ! Replace JF with that in extend subsystem
         J0= J01                 ! Replace J0 with that in extend subsystem
         allocate(MOS(JF,NA))
         do j=1,NA
            do k=1,JF
               MOS(k,j)=MOS1(k,j)
            enddo
         enddo
      else
         write(io,*) 'ERROR: Only 1-10,11 for motyp are accepted'
      endif
      deallocate(MOS2,MOS1)
C --------------------------------------------------------------
C
C --- Print informations of this cluster ---
C     write(io,'(1x,58(''-''))')
C     write(io,*) '  Subsys  Occclu  Occ-MO  Vir-MO  Tot-MO'
C    &          //'    Atom   Basis'
C     write(io,'(7i8)') I,KU,KB,NA-KB,NA,J0_sub,JF_sub
C     write(io,'(7i8)') I,KU,KB,NA-KBB,NA,J0_sub,JF_sub
C     write(io,*) '  ADDED     Occ-MO  Atom   Basis'
C     write(io,'(d8.2,3i8)') RWORK(5),KB1,J01,JF1
C     write(io,'(1x,58(''-''))')
C
C     ISUB5(I)=NA-KB
      ISUB5(I)=NA-KBB  !-WL,PP- 14 AUG 2010
      call flshbf(io)
C
C---------------------------------------------------------------------
C     Construct molecular Fock matrix of cluster
C---------------------------------------------------------------------
      allocate(FH(NA,NA),F2(JF,JF),F2B(JF,JF),FHH(JF))
      do j=1,JF;do k=1,JF
         F2(j,k)=FK(ZA(j),ZA(k))
         F2B(j,k)=FKB(ZA(j),ZA(k))
      enddo;enddo
      FHH=0d0
C
C-WL- 2007.10.15 Add for CIM- int-tran and cc
C
      allocate(AVECT(KB,KB),AVECTB(KBB,KBB))
      AVECT=0d0
      do j=1,KB
         AVECT(j,j)=1.0d0
      enddo
      AVECTB=0d0
      do j=1,KBB
         AVECTB(j,j)=1.0d0
      enddo
C
C-WL- 2007.11.20 ADD FOR FOCK MATRIX DIAGONALIZATION --- liwei -----
      write(io,*)
      if (IWORK(8).eq.0) then
         write(io,'(1x,"Diagonalization of Fock matrix of the ",
     *   "subsystem to generate quasi-canonical MOs.")')
         allocate(MOS2(JF,NA))
C        write(io,*) '+++ The initial alpha MO F(i,i) of subsystem +++'
         call NJ_tfock(0,JF,NA,F2,MOS,FH)  !-WL- 2007.10.23
C        write(io,'(5d14.6)') (FH(j,j),j=1,KB)
C
C------------------
         MOS2=MOS
C --- 1. OCC MOs
         KCC=0
C
         DO j=1,KCC
            do k=1,JF
               MOS2(k,j)=MOS(k,j)
            end do
         enddo
C
C-WL- 2009.04.15 KB --> KBB for diag double occupied MOs first
         KV=KBB-KCC
         allocate(MAT(KV,KV),VECT(KV,KV),VALU(KV),VC(KV))
         do j=1,KV
            do k=1,KV
               MAT(j,k)=FH(j+KCC,k+KCC)
            enddo
         enddo
         write(io,*) '+++ Diagonalized Occupied Fock Matrix +++'
         call NJ_qr(io,MAT,KV,VECT,VALU,VC,k,1)
         do j=1,KV
            FHH(KCC+j)=VALU(j)
         enddo
C
         do j=1,KV
         do k=1,JF
            MOS2(k,j+KCC)=0d0
            do L=1,KV
               MOS2(k,j+KCC)=MOS2(k,j+KCC)+MOS(k,L+KCC)*VECT(L,j)   !-WL- Remove for transforming VMO only
            enddo
C           MOS2(k,j)=MOS(k,j)
         enddo
         enddo
C
C        write(io,*) '+++ The Occ LMOs of subsystem +++'
C        call NJ_prtcol2(io,JF,NA,MOS,1,KB,'f11.6')
C
C        write(io,*) '+++ The Occ QCMOs of subsystem +++'
C        call NJ_prtcol2(io,JF,NA,MOS2,1,KB,'f11.6')
C
C        write(io,*) '+++ The transform matrix +++'
C        call NJ_prtcol2(io,KV,KV,VECT,1,KV,'f11.6')
C
         do j=1,KV
            do k=1,KV
               AVECT(k,j)=VECT(j,k)
            enddo
         enddo
C        write(io,*) '+++ The inverse of transform matrix +++'
C        call NJ_prtcol2(io,KV,KV,AVECT,1,KV,'f11.6')
C
!        call NJ_matpro(io,JF,KB,KB,MOS2,AVECT,MOS)
!        write(io,*) '+++ Product of matrices +++'
!        call NJ_prtcol2(io,JF,NA,MOS,1,KB,'f11.6')
C
C        write(190) KV
C        write(190) ((VECT(k,j),k=1,KV),j=1,KV)
         deallocate(MAT,VECT,VALU,VC)
C
C --- 2. UNOCC MOs
         KV=NA-KB
         allocate(MAT(KV,KV),VECT(KV,KV),VALU(KV),VC(KV))
         do j=1,KV
            do k=1,KV
               MAT(j,k)=FH(j+KB,k+KB)
            enddo
         enddo
         write(io,*) '+++ Diagonalized Virtual Fock Matrix +++'
         call NJ_qr(io,MAT,KV,VECT,VALU,VC,k,1)
         do j=1,KV
            FHH(KB+j)=VALU(j)
         enddo
C
         do j=1,KV
         do k=1,JF
            MOS2(k,j+KB)=0d0
            do L=1,KV
               MOS2(k,j+KB)=MOS2(k,j+KB)+MOS(k,L+kB)*VECT(L,j)
            enddo
         enddo
         enddo
         deallocate(MAT,VECT,VALU,VC)
C
         MOS=MOS2
C        write(io,*) '+++ The SEMI-CMOs of subsystem +++'
C        call NJ_prtcol2(io,JF,NA,MOS,1,NA,'f11.6')
C
C        write(io,*) 'Trace(Fock LMO)=',dtrace2(NA,FH)
         write(io,"(1x,'Trace(Fock LMO)=',f30.16)") dtrace2(NA,FH)
C        write(io,*) '+++ The transformed MO Fock Matrix of subsys +++'
C        call NJ_tfock(io,JF,NA,F2,MOS,FH)  !-WL- 2007.10.23
C        write(io,*) 'Trace(Fock CMO)=',dtrace2(NA,FH)
C
         deallocate(MOS2)
       endif
C
C
C-WL- 10 FEB 2010 MOVE THE BLOCK FROM THE PLACE ABOVE SUBINP
C-WL- 27 AUG 2009 ADD DENSITY MATRIX AND PPS
      allocate(DM(JF,JF),PPS(JF,JF))
      call NJ_denmat(0,JF,NA,KB,MOS,DM)
      call NJ_matpro(0,JF,JF,JF,DM,OVS3,PPS)
      trace=dtrace2(JF,PPS)
      deallocate(DM,PPS)
      nelec=nint(trace)
C-WL- 10 FEB 2010 ADD FOR OPEN SHELL
      nelec=nelec-mult+1
      write(io,'('' Number of electrons in the subsystem ='',i8)') nelec

      nucl=0
      do k=1,J0
         j=BA(k)
         nucl=nucl+nint(nuchar(j))
      enddo
      write(io,'('' Number of nuclear charges = '',i5)') nucl
C
      icharg=nucl-nelec
      icharg=mod(icharg,2)  !-WL- 27 Aug 2009 4:03PM
      write(io,'('' Number of effective net charges = '',i5)') icharg
C
C---------------------------------------------------------------------
C     Creat GAMESS input file of subsystems
C---------------------------------------------------------------------
      call NJ_trim(inpname,k1,k2)
      open(inp,file=inpname)
      nwords = memgms(scftyp,mplevl,cctyp,JF_sub,KB,NA-KBB,KU)
      if (cctyp.eq.'CCSD(T) '.or.cctyp.eq.'CR-CCL  ') then
         k = memgms(scftyp,mplevl,'CCSD    ',JF_sub,KB,NA-KBB,KU)
         nwords = max(nwords,k)
      endif
      mwords = int(nwords/1000d0/1000d0) + 1
      mbytes = int(nwords/125.d0/1000d0) + 1
C     write(io,190)scftyp,mplevl,cctyp,JF_sub,KB,NA-KBB,KU,nwords,mwords
C190  format(1x,a8,i4,2x,a8,4i6,i12,' words',i6,' mwords')
      thissystem=I
      call SUBINP(io,inp,NATOM,nuchar,coor,J0,BA,
     &     scftyp,mplevl,cctyp,IWORK,mwords,icharg,mult,NCBS,CBAS,
     &     thissystem)
      call flshbf(io)
C
C---------------------------------------------------------------------
C-WL- 2009.05.05 .cim unformatted --> formatted
         LF2=JF*(JF+1)/2
         allocate(RCent(KB),dtmp(LF2))
         do k=1,KB
            RCent(k)=dble(CenMO(k,I))
         enddo
C
C        open(icim,file=cimname,form='formatted')
C        write(io,'(7i8)') J0,JF,NA,KB,KU,KBB,KUB   !-WL- Add KB-1, KU-1 temporarily for testing whole systems
C
         write(inp,*) '$INFO'
         write(inp,'(a8,a,i8)') 'NSYS    ', '=', KGG
         write(inp,'(a8,a,a8)') 'SCFTYP  ', '=', scftyp
         write(inp,'(a8,a,i8)') 'MPLEVL  ', '=', mplevl
         write(inp,'(a8,a,a8)') 'CCTYP   ', '=', cctyp
         write(inp,'(a8,a,i8)') 'ICONV   ', '=', IWORK(1)
         if (IWORK(8).eq.0) then
            write(inp,'(a8,a,a8)') 'MOTYP   ', '=', 'QCMO    '
         else
            write(inp,'(a8,a,a8)') 'MOTYP   ', '=', 'LMO     '
         endif
         write(inp,'(a8,a,i8)') 'SYS     ', '=', I
         write(inp,'(a8,a,i8)') 'NAT     ', '=', J0
         write(inp,'(a8,a,i8)') 'ICH     ', '=', icharg
         write(inp,'(a8,a,i8)') 'MUL     ', '=', mult
         write(inp,'(a8,a,i8)') 'NE      ', '=', KB+KBB
         write(inp,'(a8,a,i8)') 'NA      ', '=', KB
         write(inp,'(a8,a,i8)') 'NB      ', '=', KBB
         write(inp,'(a8,a,i8)') 'NUM     ', '=', JF
         write(inp,'(a8,a,i8)') 'NMO     ', '=', NA
         write(inp,'(a8,a,i8)') 'NCA     ', '=', KU
         write(inp,'(a8,a,i8)') 'NCB     ', '=', KUB
         write(inp,*) '$END'
C
C        call iwrit8(inp,'$ATOMS',      J0, BA(1))
C        call iwrit8(inp,'$BASIS',      JF, ZA(1))
         call iwrit8(inp,'$MO-OCC',     KB, ML(1))
         call iwrit8(inp,'$MO-CEN',     KB, CenMO(1,I))   ! (CenMO(k,I)),k=1,KB)
         call rwrit8(inp,'$EIGVAL',     JF, FHH(1))       ! (FHH(j),j=1,JF) USEFUL IN RHF-CRCCL
         call rwrit8(inp,'$VEC',     JF*NA, MOS(1,1))     ! ((MOS(k,j),k=1,JF),j=1,NA)
C
         L=0
         do j=1,JF
            do k=1,j
               L=L+1
               dtmp(L)=F2(k,j)
            enddo
         enddo
         call rwrit8(inp,'$AO-FOCK-A', LF2, dtmp(1))      ! ((F2(k,j),k=1,j),j=1,JF)
         call rwrit8(inp,'$TRMX-A',  KB*KB, AVECT(1,1))   ! ((AVECT(k,j),k=1,KB),j=1,KB)
C
         if (scftyp.eq.'ROHF    '.or.scftyp.eq.'UHF     ') then
            L=0
            do j=1,JF
               do k=1,j
                  L=L+1
                  dtmp(L)=F2b(k,j)
               enddo
            enddo
            call rwrit8(inp,'$AO-FOCK-B', LF2, dtmp(1))     ! ((F2b(k,j),k=1,j),j=1,JF)

            do j=1,KBB
               do k=1,KBB
                  AVECTB(k,j)=AVECT(k,j)
               enddo
            enddo
            call rwrit8(inp,'$TRMX-B',KBB*KBB, AVECTB(1,1))   ! ((AVECT(k,j),k=1,KBB),j=1,KBB)
         endif
         deallocate(RCent,dtmp)
C
         deallocate(AVECT,AVECTB)
C     endif
      close(inp)
C

      deallocate (F2,F2B,OVS3)
C
C
C---------------------------------------------------------------------
C     Run GAMESS program and transform AO integrals to MO integrals
C---------------------------------------------------------------------
C     if (mplevl.ne.0.or.cctyp.ne.'NONE    ') then
C        write(job,*) trim(inpname)
C        write(job,*) 'bash '//trim(shname)
C        write(job,*) trim(outname)
C        write(job,*)
C     endif
C
      call flshbf(io)
C
C---------------------------------------------------------------------
C        20.9 SOLVE THE CCD EQUATIONS FOR RETAINED SUBSYSTEMS.  2001.4.2
C---------------------------------------------------------------------
1000  NV=NA-KB
C
C     write(io,'(1x,58(''-''))')
C
      deallocate(MOS,FH,FHH)
C
C-WL- Read Energy of orbitals from file
 990  continue

      deallocate(ML,BA,ZA)
C --------------------------------------------------
C     call NJ_date(io,'Iterative Calculation of cluster over on:')
C     call NJ_cputim(io,Tim0)
C     call NJ_walltim(io,Wall0)
C     write(io,*) 'Iterative Calculation of cluster over'
      write(io,'(1x,".... END OF SUBSYSTEM ",I4,
     *   " INPUT GENERATION ....")') i
      call timit(1)
      write(io,*)
      call flshbf(io)
C
705   format(' Number of virtual orbitals in the subsys   =',i5)
706   format(' Total number of orbitals in the subsys (NA)=',i5)
C
      end
C
C
C --- Enlarge domain with non-hydrogen atoms within 4A
C --- then add hydrogen atoms
C --- 2006.05.30 --- sj lw
C   io: output file;
C   NATOM, NW: the number of all atoms and basis functions
C   Nmo, NUW: the number of all MOs and OCC MOs
C   numc, numh: the number of all non-hydrogen atoms and hydrogen atoms
C   J0, JF: the number of atoms and basis functions within the subsystem
C   NA: the number of MOs within the subsystem
      subroutine AddAtom(NATOM,NW,Nmo,NUW,nb,numc,numh,natc,nath,
     &   J0,JF,J01,JF1,ML,BA,ZA,link,dis,RWORK)
      integer NATOM,NW,Nmo,NUW,numc,numh,J0,JF,KB
      integer ML(NUW),BA(NATOM),ZA(NW),link(NATOM,NATOM)
      integer natc(NATOM),nath(NATOM),nb(NATOM)
      double precision dis(NATOM,NATOM),RWORK(100)
C
      if (dabs(RWORK(5)).lt.1d-5) then
         J01=J0
         goto 230
      endif
      write(6,'(1x,"Adding buffer atoms within",
     * " BUFFDST=",f6.2," angstroms.")') rwork(5)
C
      J0C=J0
C
C --- Add non-hydrogen atoms  Dis<RWORK(5) -- BA(J0+1:J0C)
        do j=1,numc
         jj=natc(j)
         do k=1,J0
          if(jj.eq.BA(k))goto 110
         enddo
         do k=1,J0
          kk=BA(k)
          L=link(jj,kk)
C     Default: RWORK(5)=4.0 a.u.
          if(dis(jj,kk).le.RWORK(5))then
           J0C=J0C+1;BA(J0C)=jj
           exit
          endif
         enddo
110     enddo

C ---   Add Hydrogen Atoms-- BA(J0+1:J01)
        J01=J0C
        do j=1,numh
           jj=nath(j)
           do k=1,J0
              if (jj==BA(k)) goto 217
           enddo
           do k=1,J0C
              kk=BA(k)
              if (link(jj,kk)==1) then
                 J01=J01+1
                 BA(J01)=jj
              endif
           enddo
 217    enddo
C
 230    continue
C --- Re-order atoms
        J02=J01
        do j=1,NATOM
         do k=1,J01
          if(j.eq.BA(k))goto 120
         enddo
         J02=J02+1;BA(J02)=j
120     enddo
C
C --- Re-order basis-- ZA(1:JF:JF1:JF2)
         JF2=JF;JF1=JF
         do j=J0+1,NATOM
          if(BA(j).ne.NATOM)then
           nl=nb(BA(j)+1)-1
          else
           nl=NW
          endif
          do l=nb(BA(j)),nl
           JF2=JF2+1;ZA(JF2)=l
          enddo
          if(j.eq.J01)JF1=JF2
         enddo
        return
        end
C

C     input informations:
C     io: index of output file
C     NATOM,NW: numbers of atoms and basis functions in the whole system
C     J0,JF: numbers of atoms and basis functions in the unexpanded domain
C     J01,JF1: numbers of atoms and basis functions in the expanded domain
C     KB: number of occupied LMOs in the unexpanded domain
C     KB1: number of occupied LMOs in the expanded domain
C
C     S: Overlap of total system
C
      subroutine COV(io,isys,NATOM,NW,Nmo,NUW,nb,
     &   J0,JF,J01,JF1,NA,KB,KB1,ML,BA,ZA,SR1,admx,admy,admz,
     &   S,SMO,MOS1,MOS2,local,S3,IWORK,RWORK)
      integer io,NATOM,NW,Nmo,NUW,J0,JF,NA,KB,J01,JF1,nvext,NAext
      integer ML(NUW),BA(NATOM),ZA(NW),nb(NATOM),local,nv_cim06
      integer nv_cim06_rd
      integer nv_max,isys,IWORK(100)
      double precision SR1(NATOM,NMO),RWORK(100)
      double precision admx(NW,NW),admy(NW,NW),admz(NW,NW)
      double precision S(NW,NW),S3(JF,JF),SMO(NW,Nmo)
      double precision ps,P1
      double precision MOS1(JF1,JF1),MOS2(JF,JF)
C
      double precision,dimension(:,:),allocatable::co,co1,oco,MOS3
      double precision,dimension(:),allocatable::AC1
C
      double precision zeps,smin,smax,epsa,epst
      double precision,dimension(:),allocatable::ovlp,e,d
      double precision,dimension(:,:),allocatable::mdmx,mdmy,mdmz
      double precision,dimension(:,:),allocatable::tr,cvs,cvs2,SS,Q,c
C
      integer,dimension(:),allocatable::nb1
      double precision,dimension(:,:),allocatable::S1,S2,admx2,admy2
      double precision,dimension(:,:),allocatable::admz2

      allocate(nb1(J01),S1(NW,NW),S2(JF1,JF1))
      allocate(admx2(JF1,JF1),admy2(JF1,JF1),admz2(JF1,JF1))

C Threshold of zero-eigenvalue
      zeps = 1.0d-5

      write(io,*)
C     write(io,*) '--- CONSTRUCTING EXTENDED ',
C    *   'SUBSYSTEM ORBITALS ---'
C
C --- Obtain overlap integrals, Occ. LMOs and AO dipole integrals in the expanded domain
C     S1: over-lap matrix of the whole system (after sorting)
C     S2: over-lap matrix of the expanded domain
C     S3: over-lap matrix of the domain
C     co1: OCC MOs of the expanded domain
C     nb1: the first basis of each atom
340   allocate(co1(NW,KB1))
      do j=1,NW
         do k=1,NW
            S1(j,k)=S(ZA(j),ZA(k))
         enddo
      enddo
C
      do j=1,JF1
         do k=1,JF1
            S2(j,k)=S1(j,k)
            admx2(j,k)=admx(ZA(j),ZA(k))
            admy2(j,k)=admy(ZA(j),ZA(k))
            admz2(j,k)=admz(ZA(j),ZA(k))
         enddo
      enddo
C
      do j=1,JF
         do k=1,JF
            S3(j,k)=S1(j,k)
         enddo
      enddo
C
      co1=0.0d0
      do k=1,KB1
         do j=1,NW
           co1(j,k)=SMO(ZA(j),ML(k))
        enddo
      enddo
C
      do k=1,J01
         do j=1,NW
            if(ZA(j).eq.nb(BA(k)))nb1(k)=j
         enddo
      enddo
C
* =========================================================================================
*     Get the orthonormal occ. LMOs in extended subsystems from occ. LMOs of total systems
* -----------------------------------------------------------------------------------------
      allocate(co(JF1,KB1),oco(JF1,KB1))        ! oco is only used for store old co for comparison
      write(io,*) 'Project occ. LMOs from total system ',
     *   'onto extended subsystem and normalize'
      call projorb(io,NW,JF1,KB1,KB1,co1,co,S1) ! Project occ. LMOs from total system onto extended subsystems
      call normorb2(io,JF1,KB1,co,S2)            ! Normalize occ. LMOs of extended subsystems
      oco=co
      if (IWORK(2).ne.1) then    ! IWORK(2)=1,12 do not orthogonalize occ MOs in extended subsystems.
         call orthorb(io,JF1,KB1,co,S2,1)       ! Orthogonalize occ. LMOs of extended subsystems (1 means symmetric orth.)
         call normorb2(io,JF1,KB1,co,S2)         ! Normalize occ. LMOs of extended subsystems
      endif
C     call ovlporb2(io,JF1,KB1,oco,KB1,co,S2)   ! [Optional] Check the overlap between non-orth & orth occ. LMOs of extended subsystems
C     call ovlporb(io,JF1,KB1,co,S2)            ! [Optional] Check the overlap for occ. LMOs of extended subsystems
      deallocate(oco)
* =========================================================================================
* (a) co(JF1,KB1) is the orthonormal occ. LMOs in extended subsystems if IWORK(2).ne.1
C
C
* ===========================================================================
*     Create the orthonormal vir. LMOs in extended subsystems from occ. parts
* ---------------------------------------------------------------------------
      allocate(SS(JF1,JF1),c(JF1,JF1),Q(JF1,JF1),e(JF1),d(JF1))
C
C Set c(JF1,JF1) as an unitary matrix for construct virtual MOs
      call dunit(JF1,c)
C Project out the occ. part of vir. MOs in extended subsystems
      write(io,*) 'Project occ. part of virtual MOs'
      call pjotorb(io,JF1,KB1,JF1,co,c,S2)
C     write(io,*) 'There should now be no overlap between occ. LMOs'
C     write(io,*) 'and between the occ. LMOs and virtual MOs of',
C    * ' the extended subsystem.'

C Overlap on MOs: SS=C^T*S*C
C QR diag. of SS, increase the eigenvalues e and exchange corresponding eigenvectors Q.
      call NJ_tfock(0,JF1,JF1,S2,c,SS)
      call NJ_qr(0,SS,JF1,Q,e,d,L,1)
C Count the number of values \in [-zeps,zeps] ("zero" eigenvalues)
C nzero: zero eigenvalues;  nonzero: non-zero eigenvalues
C KB1: the num of occ. MOs in extended subsys. So nvexpct is expected num of vir. ones
C nvext: selected number of vir. MOs in subsystems
C ncut: =JF1-nvext is the number of eigenvectors needed to be cut
      call numpoint(JF1,e,-zeps,zeps,nzero)
      nonzero = JF1 - nzero
      nvexpct = JF1 - KB1
      nvext   = min(nonzero,nvexpct)
      ncut    = max(nzero,KB1)
      write(io,'(1x,"Diagonalization of the extended subsystem ",
     *  "overlap leads to:")')
      write(io,'(3x,i5," zero     and ",i5," non-zero eigenvalues",
     *  2x,"(threshold:",1p,d8.2,0p,")")')
     *  nzero,nonzero,zeps
      write(io,'(3x,i5," occupied and ",i5," virtual orbitals",
     *  " were expected")') kb1,nvexpct

C     write(io,*) '-- Diagonalize overlap in extended subsystem --'
C     write(io,110) nzero,nonzero
C     write(io,120) KB1,nvexpct
      write(io,130) ncut-KB1,nvext

C Set MOS1(JF1,JF1) as a zero matrix
      call dzero(JF1*JF1,MOS1)
C Transform matrix for generating orthogonal vir. MOs
C Get canonical transform matrix tr(JF1,nvext)
C MOS1(JF1,nvext)=c(JF1,JF1)*tr(JF1,nvext)
      write(io,"(1x,'Canonical orthogonalization and localization of ',
     *   i4,' virtual orbitals')") nvext
      allocate(tr(JF1,nvext))
      call NJ_canorth(0,JF1,nvext,e(ncut+1),q(1,ncut+1),tr)
      call NJ_matpro(io,JF1,JF1,nvext,c,tr,MOS1(1,1))
      deallocate(tr)
      deallocate(SS,c,Q,e,d)
* ===========================================================================
* (a) MOS1(JF1,nvext) within MOS1(JF1,JF1) are the orthonormal vir. MOs in extended subsystems
C
C if subsystem and extended subsystem basis set is the same, do no localize
      if (JF1.eq.JF) goto 360  ! 2008.05.12 Add
C
* ==========================================================
*     Boys localization of vir. LMOs in extended subsystems
* ----------------------------------------------------------
! Thereshold of local index converg (default 1d-7 if set as zero)
      epsa   = 1d-7
! Thereshold of rotation of orbital (default 1d-13 if set as zero)
      epst   = 1d-13
! Maximum localization cycle (default 10000 if set as zero)
      maxcyc = 10000
! Print the localized MOs if nprint=1
      nprint = 0
! The number of parallel threads (currently useless, please set as 1)
      np     = 1
! Print the local results once every <nprtcyc> cycles (2008.02.10 ADD)
! Usually local=1 (Boys localization)
      nprtcyc= 100
      if (local.eq.1) then
         allocate(mdmx(nvext,nvext),mdmy(nvext,nvext),mdmz(nvext,nvext))
         call NJ_tfock(0,JF1,nvext,admx2,MOS1,mdmx)
         call NJ_tfock(0,JF1,nvext,admy2,MOS1,mdmy)
         call NJ_tfock(0,JF1,nvext,admz2,MOS1,mdmz)
         call NJ_boyloc(io,J01,JF1,nvext,1,nvext,MOS1,mdmx,mdmy,mdmz,
     &        epsa,epst,maxcyc,nprint,np,nprtcyc,ierr)
         deallocate(mdmx,mdmy,mdmz)
      elseif(local.eq.3) then
! Pipek-Mezey localization if local=3
         call Pop_sj(io,J01,JF1,nvext,1,nvext,MOS1,S2,nb1,maxcyc,epsa)
!!       call NJ_poploc(io,J01,JF1,nvext,1,nvext,MOS1,S2,tbs,
!!   &           eps,epst,maxcyc,nprint,np,ierr)
      endif
* ==========================================================
* (a) MOS1(JF1,nvext) within MOS1(JF1,JF1) are the orthonormal vir. LMOs in extended subsystems
C
 360  continue
C
* ========================================================================
*     Project orthogonal vir. LMOs from extended subsystems to subsystems
* ------------------------------------------------------------------------
! Threshold of self-overlap for selecting virtual LMOs (down bound)
      smin = 1.0d0-RWORK(4)
! Threshold of self-overlap for selecting virtual LMOs (up bound) (1.0 is ok)
      smax = 2.0d0
! ovlp: self-overlaps of cvs
      allocate(cvs(JF,nvext),ovlp(nvext))
! Project vir. LMOs from extended subsystem onto subsystems cvs(JF,nvext)
      write(io,*) '--- Project extended subsystem virtual orbitals ',
     * 'back on the the original subsystem ---'
      call projorb(io,JF1,JF,nvext,nvext,MOS1,cvs,S2)
! Calc & sort (decrease) the self-overlap of cvs before orthonormalization
C     call ovlpslf(io,JF,nvext,cvs,S3,ovlp,-1)
! Calc & sort (decrease) the self-overlap of cvs before orthonormalization
      call ovlpslf2(0,JF,nvext,cvs,JF1,MOS1,S3,ovlp,-1)
! nv_cim06: the num of values of ovlp in [smin,smax] (used in CIM JCP2006)
      call numpoint(nvext,ovlp,smin,smax,nv_cim06)
      write(io,90)  rwork(4)
! nv_cim06: the num of vir. MOs of subsystems defined in CIM paper JCP2006
      write(io,100) nv_cim06
      if (IWORK(7).eq.0) then
         write(isys,'(i5)') nv_cim06
      else
         read(isys,*) nv_cim06
         write(io,201) nv_cim06
      endif
      nv_max=JF-KB
      if (nv_cim06.gt.nv_max) then
         write(io,105) nv_max
         write(io,106) nv_max
         nv_cim06=nv_max
      endif
  90  format(1x,'By selecting orbitals with self-overlap',
     *  ' ETA<=',f7.3,',')
 100  format(1x,'The numbers of chosen vir. LMOs in the subsystem are:'
     *  ,i4)
 105  format(1x,'Number of vir MOs is larger than possible number:',i4)
 106  format(1x,'Re-define the number of vir MOs as the new value:',i4)
 201  format(1x,'Read the number of virtual MOs as the new value: ',i4)
C201  format(1x,'DO NOT read the number of virtual MOs as follow: ',i4)
      deallocate(ovlp)
! Now cvs is virtual LMOs in extended subsystem but projected to AO domains
      call normorb2(io,JF,nvext,cvs,S3)
C
      write(io,150)
* ========================================================================
* (a) cvs(JF,nvext) are the normalized vir. LMOs in extended subsystems but projected onto AO domains
* (b) nv_cim06 is the num of vir. MOs in subsystems defined by CIM paper "JCP 125, 074109 (2006)"
C
C
* =============================================================================
*     Get the MOs projected on extended subsystems MOS1 and on subsystems MOS2
* -----------------------------------------------------------------------------
      if (IWORK(2).ge.11 .or. IWORK(2).eq.1 .or. IWORK(2).eq.2) then
         nv=nv_cim06
         NA=KB+nv
         do i=NA,KB+1,-1
            do j=1,JF1
               MOS1(j,i)=MOS1(j,i-KB)
            enddo
         enddo
         do i=1,KB
            do j=1,JF1
               MOS1(j,i)=co(j,i)
            enddo
         enddo
C
      write(io,*) '--- Project extended subsystem occupied orbitals ',
     * 'back on the the original subsystem ---'
C        call NJ_prtcol2(io,JF1,NA,MOS1,1,JF1,'f14.6')
C        call ovlporb(io,JF1,NA,MOS1(1,1),S2)            ! [Optional] Check the overlap for occ LMOs of subsystems
C
C ---    Continue to get the LMOs in subsystems and projected on subsystems AOs
         call projorb(io,JF1,JF,KB1,KB,co,MOS2(1,1),S2)  ! Project occ. LMOs from extended subsystems onto subsystems (KB of KB1)
         call normorb2(io,JF,KB,MOS2(1,1),S3)             ! Normalize occ. LMOs of subsystems
         do i=KB+1,NA
            do j=1,JF
               MOS2(j,i)=cvs(j,i-KB)
            enddo
         enddo
         deallocate(co,cvs)
         return       ! Back to the parent program only with the MOS1 ands MOS2
      endif
* =============================================================================
C
C
C ======================================================================================
C     Get the orthonormal occ. LMOs in subsystems from occ. LMOs in extended subsystems
C --------------------------------------------------------------------------------------
      call projorb(io,JF1,JF,KB1,KB,co,MOS2(1,1),S2)   ! Project occ. LMOs from extended subsystems onto subsystems (KB of KB1)
      deallocate(co)
      call normorb2(io,JF,KB,MOS2(1,1),S3)              ! Normalize occ. LMOs of subsystems
      call orthorb(io,JF,KB,MOS2(1,1),S3,1)            ! Orthogonalize occ. LMOs of subsystems
      call normorb2(io,JF,KB,MOS2(1,1),S3)              ! Normalize occ. LMOs of subsystems
*     call ovlporb(io,JF,KB,MOS2(1,1),S3)              ! [Optional] Check the overlap for occ LMOs of subsystems
C ======================================================================================
* (a) MOS2(JF,KB) within MOS2(JF,JF) are the orthonormal occ. LMOs in subsystems
C
C
C ===========================================================================================================
C     Orthonormalize vir. LMOs in subsystems from those in extended subsystems but projected onto subsystems
C -----------------------------------------------------------------------------------------------------------
      if (IWORK(2).eq.3) then
         iselct_A=  3
         iselct_B=  0
         iselct_C=  2
      elseif (IWORK(2).eq.4) then
         iselct_A=  3
         iselct_B=  2
         iselct_C=  2
      elseif (IWORK(2).eq.5) then
         iselct_A=  1
         iselct_B=  1
         iselct_C=  1
      elseif (IWORK(2).eq.6) then
         iselct_A=  1
         iselct_B=  1
         iselct_C=  2
      endif
      write(io,*)'-----------------------------------------------------'
      write(io,*)'Three steps for the orthonormal vir MOs in subsystems'
      write(io,*)'-----------------------------------------------------'
      write(io,*) 'Step A: Project out the occ. part from the vir. LMOs'
      write(io,*) '        Possible numbers of used vir. LMOs include:'
      write(io,5110) nvext
      write(io,5120) JF-KB
      write(io,5130) nv_cim06
      iselect=iselct_A
      write(io,5550) iselect
      if (iselect.eq.1) then
         nvpjot = nvext
      elseif (iselect.eq.2) then
         nvpjot = JF-KB
      elseif (iselect.eq.3) then
         nvpjot = nv_cim06
      elseif (iselect.eq.0) then
         nv_indep= nv_cim06
         goto 520
      else
         stop 'ERROR in step 1 of the orthonormalization of vir. MOs'
      endif
C
      call pjotorb(io,JF,KB,nvpjot,MOS2(1,1),cvs,S3)   ! Project out the occ. part of vir. LMOs cvs(JF,nvpjot)
      call normorb2(io,JF,nvpjot,cvs,S3)                ! Normalized cvs(JF,nvpjot)

      allocate(SS(nvpjot,nvpjot),Q(nvpjot,nvpjot),e(nvpjot),d(nvpjot))
      call NJ_tfock(0,JF,nvpjot,S3,cvs,SS)             ! Overlap on MOs: SS=C^T*S*C
      call NJ_qr(io,SS,nvpjot,Q,e,d,L,1)               ! QR diagonalization of SS
      write(io,*) 'Eigenvalues of C^+SC of extended vir MOs in subsys'
      write(io,'(5f14.6)') (e(i),i=1,nvpjot)
      call numpoint(nvpjot,e,-zeps,zeps,nzero)         ! Count the number of values \in [-zeps,zeps] ("zero" eigenvalues)
      nv_indep=nvpjot-nzero
C
C -----------------------------------------------------------------------------------------------------------
 520  write(io,*) 'Step B: Orthonormalize the vir. LMOs'
      write(io,*) '        Possible numbers of used vir. LMOs include:'
      write(io,5210) nv_indep
      write(io,5220) nv_cim06
      iselect=abs(iselct_B)
      jselect=iselct_B
      write(io,5550) iselect
      if (iselect.eq.1) then
         nvorth = nv_indep
      elseif (iselect.eq.2) then
         nvorth = nv_cim06
      elseif (iselect.eq.0) then
         nvorth = nv_indep
         goto 530
      else
         stop 'ERROR in step 2 of the orthonormalization of vir. MOs'
      endif
C
      if (jselect.gt.0) then
         call orthorb(io,JF,nvorth,cvs(1,1),S3,1)               ! Symmetry orthogonalize vir. LMOs of subsystems cvs(JF,nvorth)
      else
         write(io,*)'Canonical Orthogonalization for vir. MOs in subsys'
         allocate(tr(nvpjot,nvorth),cvs2(JF,nvorth))            ! Transform matrix for generating orthogonal vir. MOs
         nstt=nzero+1
         call NJ_canorth(0,nvpjot,nvorth,e(nstt),Q(1,nstt),tr)  ! Get canonical transform matrix tr(nvpjot,nvorth)
         call NJ_matpro(io,JF,nvpjot,nvorth,cvs,tr,cvs2)        ! cvs2(JF,nvorth)=cvs(JF,nvpjot)*tr(nvpjot,nvorth)
         do i=1,nvorth
            cvs(1:JF,i)=cvs2(1:JF,i)
         enddo
         deallocate(tr,cvs2)
      endif
      call normorb2(io,JF,nvorth,cvs(1,1),S3)                    ! Normalize vir. LMOs of subsystems cvs(JF,nvorth)
*     call ovlporb(io,JF,nvorth,cvs(1,1),S3)                    ! Check the overlap for "nv" vir LMOs of subsystems
      deallocate(SS,Q,e,d)
C
C -----------------------------------------------------------------------------------------------------------
 530  write(io,*) 'Step C: Pick up the needed LMOs in subsystems'
      write(io,*) '        Possible numbers of used vir. LMOs include:'
      write(io,5210) nv_indep
      write(io,5220) nv_cim06
      iselect=iselct_C
      write(io,5550) iselect
      if (iselect.eq.1) then
         nv = nv_indep
      elseif (iselect.eq.2) then
         nv = nv_cim06
      else
         stop 'ERROR in step 2 of the orthonormalization of vir. MOs'
      endif
      if (nv.gt.nvorth) then
         write(io,*)'nv in step 3 can not be larger than nvorth'
         STOP
      endif
C
C -----------------------------------------------------------------------------------------------------------
 5110 format(6x,'1. Tot number of vir. LMOs in extended subsystems:',i4)
 5120 format(6x,'2. Expected max number of vir. LMOs in subsystems:',i4)
 5130 format(6x,'3. Number of vir. LMOs in subsystems from JCP2006:',i4)
 5210 format(6x,'1. Number of independ. vir. LMOs after projection:',i4)
 5220 format(6x,'2. Number of vir. LMOs in subsystems from JCP2006:',i4)
 5550 format(3x,'Your choice is:',i4)
C ===========================================================================================================
* (a) cvs(JF,nvpjot) are the vir. LMOs orthogonal to occ. LMOs in subsystems
* (b) cvs(JF,nvorth) are the orthonormal vir. LMOs in subsystems
* (c) cvs(JF,nv) are the selected orthonormal vir. LMOs in subsystems
C
C
      NA=KB+nv
      do j=KB+1,NA
         do k=1,JF
            MOS2(k,j)=cvs(k,j-KB)
         enddo
      enddo
C     call ovlporb(io,JF,NA,MOS2,S3)              ! Check the overlap for all LMOs of subsystems
C
      deallocate(cvs)
      deallocate(nb1,S1,S2,admx2,admy2,admz2)
      return
C
 110  format(1x,'The numbers of zero and non-zero eigenvalues are:',2i4)
 120  format(1x,'The numbers of occ. and expected virtual MOs are:',2i4)
 130  format(1x,'The numbers of redundunt and chosen vir. MOs are:',2i4)
 140  format(1x,'The numbers of chosen vir. LMOs in subsystem are:',i4)
 150  format(1x,57('-'))
      end

****** 2004.12.21 trace for a matrix [real*8]******
      function dtrace2(n,mat)
      implicit none
      integer n,i
      real*8 mat(n,n),dtrace2
      dtrace2=0d0
      do i=1,n
         dtrace2=dtrace2+mat(i,i)
      enddo
      end
C
C-WL- 2009.09.22 updated by Wei Li for allocatable A
      SUBROUTINE MINA1(N,NVV,NW,NMO,SMO,SOVER,AC)
      double precision SMO(NW,NMO),SOVER(NW,NW),AC(N),P
      double precision,dimension(:,:),allocatable::A

      allocate(A(N,N+1))
      DO 100 IU=1,N
         DO 110 IV=1,N
            A(IU,IV)=SOVER(IU,IV)
110      CONTINUE
100   CONTINUE
C
      DO 120 I=1,N
         P=0.0d0
         DO 130 K=1,NW
            P=P+SMO(K,NVV)*SOVER(I,K)
130      CONTINUE
         A(I,N+1)=P
120   CONTINUE
C
      CALL GAUSS2(N,A)
C
      DO 150 I=1,N
         AC(I)=A(I,N+1)
150   CONTINUE
C
C      WRITE(*,*) 'N=',N
C      WRITE(*,20) (AC(I),I=1,N)
C20    FORMAT(1X,5F12.5)
C
      deallocate(A)
      RETURN
      END
C
CMWS      subroutine izero(n,a)
CMWS      integer a(n)
CMWS      do i=1,n
CMWS         a(i)=0
CMWS      enddo
CMWS      end

      subroutine dzero(n,a)
      double precision a(n)
      do i=1,n
         a(i)=0d0
      enddo
      end

CMWS      subroutine iunit(n,a)
CMWS      integer a(n,n)
CMWS      do i=1,n
CMWS         do j=1,n
CMWS            if (j.eq.i) then
CMWS               a(j,i)=1
CMWS            else
CMWS               a(j,i)=0
CMWS            endif
CMWS         enddo
CMWS      enddo
CMWS      end

      subroutine dunit(n,a)
      double precision a(n,n)
      do i=1,n
         do j=1,n
            if (j.eq.i) then
               a(j,i)=1d0
            else
               a(j,i)=0d0
            endif
         enddo
      enddo
      end
C
C --- Count the number of values \in [z1,z2] of A(n)
      subroutine numpoint(n,A,z1,z2,num)
      implicit none
      integer n,num,i,j
      double precision A(n),z1,z2,zzz
C
      num=0
      do i=1,n
         zzz=A(i)
         if (zzz.lt.z1) cycle
         if (zzz.gt.z2) cycle
         num=num+1
      end do
C
      end
C
C --------------------------------------------------------
C       CORRECT.
C       FOR DIAGONALIZATION. 2003.5.25.
        SUBROUTINE NJ_qr(io,A,N,Q,B,C,L,sort)
        implicit none
        INTEGER N,L,io,sort,i,j,k
        real*8 A(N,N),Q(N,N),B(N),C(N),valu,vect,eps
        eps=1d-16
        CALL CSTRQ(A,N,Q,B,C,eps)
        CALL CSSTQ(N,B,C,Q,L,eps)
        if (L.eq.0) then
           write(io,*) 'QR Diagonalization failure!'
           call abrt
        endif
C --- Sort for eigenvalues ---
        if (sort>0) then   ! order eigenvalues from small to large
           do i=1,N-1
              valu=B(i)
              do j=i+1,N
                 if (B(j).lt.valu) then
                    valu=B(j)
                    B(j)=B(i)
                    B(i)=valu
                    do k=1,N
                       vect=Q(k,i)
                       Q(k,i)=Q(k,j)
                       Q(k,j)=vect
                    enddo
                 endif
              enddo
           enddo
           if (io.gt.0) write(io,110) N
        elseif (sort<0) then
           do i=1,N-1
              valu=B(i)
              do j=i+1,N
                 if (B(j).gt.valu) then ! order eigenvalues from large to small
                    valu=B(j)
                    B(j)=B(i)
                    B(i)=valu
                    do k=1,N
                       vect=Q(k,i)
                       Q(k,i)=Q(k,j)
                       Q(k,j)=vect
                    enddo
                 endif
              enddo
           enddo
           if (io.gt.0) write(io,120) N
        else
           if (io.gt.0) write(io,130) N
        endif
        if (io.gt.0) write(io,140) (B(i),i=1,N)
 110  format(1x,'QR diagonalization with',i4,' ascending eigenvalues')
 120  format(1x,'QR diagonalization with',i4,' descending eigenvalues')
 130  format(1x,'QR diagonalization with',i4,' unsorted eigenvalues')
 140  format(5d14.6)
      END
C
        SUBROUTINE CSSTQ(N,B,C,Q,L,EPS)
        real*8 Q(N,N),B(N),C(N)
        real*8 EPS,D,H,P,R,F,E,S,G
        INTEGER L
        C(N)=0.0d0
        D=0.0d0
        F=0.0d0
        DO 50 J=1,N
          IT=0
          H=EPS*(DABS(B(J))+DABS(C(J)))
          IF (H.GT.D) THEN
           D=H
          END IF
          M=J-1
10        M=M+1
          IF (M.LE.N) THEN
            IF (DABS(C(M)).GT.D) GOTO 10
          END IF
          IF (M.NE.J) THEN
15          IF (IT.EQ.60) THEN
              L=0
              WRITE(*,18)
18            FORMAT(1X,'  FAIL')
                WRITE(11,*) 'FAIL IN QR'
              RETURN
            END IF
            IT=IT+1
            G=B(J)
            P=(B(J+1)-G)/(2.0d0*C(J))
            R=DSQRT(P*P+1.0d0)
            IF (P.GE.0.0d0) THEN
              B(J)=C(J)/(P+R)
            ELSE
              B(J)=C(J)/(P-R)
            END IF
            H=G-B(J)
            DO 20 I=J+1,N
20          B(I)=B(I)-H
            F=F+H
            P=B(M)
            E=1.0d0
            S=0.0d0
            DO 40 I=M-1,J,-1
              G=E*C(I)
              H=E*P
              IF (DABS(P).GE.DABS(C(I))) THEN
                E=C(I)/P
                R=DSQRT(E*E+1.0d0)
                C(I+1)=S*P*R
                S=E/R
                E=1.0d0/R
              ELSE
                E=P/C(I)
                R=DSQRT(E*E+1.0d0)
                C(I+1)=S*C(I)*R
                S=1.0d0/R
                E=E/R
              END IF
              P=E*B(I)-S*G
              B(I+1)=H+S*(E*G+S*B(I))
              DO 30 K=1,N
                H=Q(K,I+1)
                Q(K,I+1)=S*Q(K,I)+E*H
                Q(K,I)=E*Q(K,I)-S*H
30            CONTINUE
40          CONTINUE
            C(J)=S*P
            B(J)=E*P
            IF (DABS(C(J)).GT.D) GOTO 15
          END IF
          B(J)=B(J)+F
50      CONTINUE
        DO 80 I=1,N
          K=I
          P=B(I)
          IF (I+1.LE.N) THEN
            J=I
60          J=J+1
            IF (J.LE.N) THEN
              IF (B(J).LE.P) THEN
                K=J
                P=B(J)
                GOTO 60
              END IF
            END IF
          END IF
          IF (K.NE.I) THEN
            B(K)=B(I)
            B(I)=P
            DO 70 J=1,N
              P=Q(J,I)
              Q(J,I)=Q(J,K)
              Q(J,K)=P
70          CONTINUE
          END IF
80      CONTINUE
        L=1
        RETURN
        END

        SUBROUTINE CSTRQ(A,N,Q,B,C,eps)
        real*8 A(N,N),Q(N,N),B(N),C(N)
        real*8 F,H,G,H2,eps
        DO 10 I=1,N
        DO 10 J=1,N
10      Q(I,J)=A(I,J)
        DO 80 I=N,2,-1
          H=0.0d0
          IF (I.GT.2) THEN
            DO 20 K=1,I-1
20          H=H+Q(I,K)*Q(I,K)
          END IF
          IF (dabs(H).le.eps) THEN
            C(I)=0.0d0
            IF (I.EQ.2) C(I)=Q(I,I-1)
            B(I)=0.0d0
          ELSE
            C(I)=DSQRT(H)
            IF (Q(I,I-1).GT.0.0d0) C(I)=-C(I)
            H=H-Q(I,I-1)*C(I)
            Q(I,I-1)=Q(I,I-1)-C(I)
            F=0.0d0
            DO 50 J=1,I-1
              Q(J,I)=Q(I,J)/H
              G=0.0d0
              DO 30 K=1,J
30            G=G+Q(J,K)*Q(I,K)
              IF (J+1.LE.I-1) THEN
                DO 40 K=J+1,I-1
40              G=G+Q(K,J)*Q(I,K)
              END IF
              C(J)=G/H
              F=F+G*Q(J,I)
50          CONTINUE
            H2=F/(H+H)
            DO 70 J=1,I-1
              F=Q(I,J)
              G=C(J)-H2*F
              C(J)=G
              DO 60 K=1,J
60            Q(J,K)=Q(J,K)-F*C(K)-G*Q(I,K)
70          CONTINUE
            B(I)=H
          END IF
80      CONTINUE
        DO 85 I=1,N-1
85      C(I)=C(I+1)
        C(N)=0.0d0
        B(1)=0.0d0
        DO 130 I=1,N
          IF ((dabs(B(I)).gt.eps).AND.(I-1.GE.1)) THEN
            DO 110 J=1,I-1
              G=0.0d0
              DO 90 K=1,I-1
90            G=G+Q(I,K)*Q(K,J)
              DO 100 K=1,I-1
100           Q(K,J)=Q(K,J)-G*Q(K,I)
110         CONTINUE
          END IF
          B(I)=Q(I,I)
          Q(I,I)=1.0d0
          IF (I-1.GE.1) THEN
            DO 120 J=1,I-1
              Q(I,J)=0.0d0
              Q(J,I)=0.0d0
120         CONTINUE
          END IF
130     CONTINUE
        RETURN
        END


CMWSC********************************************************************
CMWSC CSSTQ method to diagonalize
CMWSC********************************************************************
CMWS        SUBROUTINE CSSTQ_0(N,B,C,Q,EPS,L)
CMWS        DIMENSION B(N),C(N),Q(N,N)
CMWS        DOUBLE PRECISION B,C,Q,D,H,P,R,F,E,S,G,eps
CMWS        C(N)=0.0d0
CMWS        D=0.0d0
CMWS        F=0.0d0
CMWS        EPS=0.0d0
CMWS        DO 50 J=1,N
CMWS          IT=0
CMWS          H=EPS*(ABS(B(J))+ABS(C(J)))
CMWS          IF (H.GT.D) D=H
CMWS          M=J-1
CMWS10        M=M+1
CMWS          IF (M.LE.N) THEN
CMWS            IF (ABS(C(M)).GT.D) GOTO 10
CMWS          END IF
CMWS          IF (M.NE.J) THEN
CMWS15          IF (IT.EQ.60) THEN
CMWS              L=0
CMWS              WRITE(*,18)
CMWS18            FORMAT(1X,'  FAIL')
CMWS              RETURN
CMWS            END IF
CMWS            IT=IT+1
CMWS            G=B(J)
CMWS            P=(B(J+1)-G)/(2.0*C(J))
CMWS            R=SQRT(P*P+1.0)
CMWS            IF (P.GE.0.0) THEN
CMWS              B(J)=C(J)/(P+R)
CMWS            ELSE
CMWS              B(J)=C(J)/(P-R)
CMWS            END IF
CMWS            H=G-B(J)
CMWS            DO 20 I=J+1,N
CMWS20          B(I)=B(I)-H
CMWS            F=F+H
CMWS            P=B(M)
CMWS            E=1.0
CMWS            S=0.0
CMWS            DO 40 I=M-1,J,-1
CMWS              G=E*C(I)
CMWS              H=E*P
CMWS              IF (ABS(P).GE.ABS(C(I))) THEN
CMWS                E=C(I)/P
CMWS                R=SQRT(E*E+1.0)
CMWS                C(I+1)=S*P*R
CMWS                S=E/R
CMWS                E=1.0/R
CMWS              ELSE
CMWS                E=P/C(I)
CMWS                R=SQRT(E*E+1.0)
CMWS                C(I+1)=S*C(I)*R
CMWS                S=1.0/R
CMWS                E=E/R
CMWS              END IF
CMWS              P=E*B(I)-S*G
CMWS              B(I+1)=H+S*(E*G+S*B(I))
CMWS              DO 30 K=1,N
CMWS                H=Q(K,I+1)
CMWS                Q(K,I+1)=S*Q(K,I)+E*H
CMWS                Q(K,I)=E*Q(K,I)-S*H
CMWS30            CONTINUE
CMWS40          CONTINUE
CMWS            C(J)=S*P
CMWS            B(J)=E*P
CMWS            IF (ABS(C(J)).GT.D) GOTO 15
CMWS          END IF
CMWS          B(J)=B(J)+F
CMWS50      CONTINUE
CMWS        DO 80 I=1,N
CMWS          K=I
CMWS          P=B(I)
CMWS          IF (I+1.LE.N) THEN
CMWS            J=I
CMWS60          J=J+1
CMWS            IF (J.LE.N) THEN
CMWS              IF (B(J).LE.P) THEN
CMWS                K=J
CMWS                P=B(J)
CMWS                GOTO 60
CMWS              END IF
CMWS            END IF
CMWS          END IF
CMWS          IF (K.NE.I) THEN
CMWS            B(K)=B(I)
CMWS            B(I)=P
CMWS            DO 70 J=1,N
CMWS              P=Q(J,I)
CMWS              Q(J,I)=Q(J,K)
CMWS              Q(J,K)=P
CMWS70          CONTINUE
CMWS          END IF
CMWS80      CONTINUE
CMWS        L=1
CMWS        RETURN
CMWS        END

CMWS        SUBROUTINE CSTRQ_0(A,N,Q,B,C)
CMWS        DIMENSION A(N,N),Q(N,N),B(N),C(N)
CMWS        DOUBLE PRECISION A,Q,B,C,F,H,G,H2
CMWS        DO 10 I=1,N
CMWS        DO 10 J=1,N
CMWS10      Q(I,J)=A(I,J)
CMWS        DO 80 I=N,2,-1
CMWS          H=0.0
CMWS          IF (I.GT.2) THEN
CMWS            DO 20 K=1,I-1
CMWS20          H=H+Q(I,K)*Q(I,K)
CMWS          END IF
CMWS          IF (H+1.0.EQ.1.0) THEN
CMWS            C(I)=0.0d0
CMWS            IF (I.EQ.2) C(I)=Q(I,I-1)
CMWS            B(I)=0.0d0
CMWS          ELSE
CMWS            C(I)=SQRT(H)
CMWS            IF (Q(I,I-1).GT.0.0d0) C(I)=-C(I)
CMWS            H=H-Q(I,I-1)*C(I)
CMWS            Q(I,I-1)=Q(I,I-1)-C(I)
CMWS            F=0.0d0
CMWS            DO 50 J=1,I-1
CMWS              Q(J,I)=Q(I,J)/H
CMWS              G=0.0d0
CMWS              DO 30 K=1,J
CMWS30            G=G+Q(J,K)*Q(I,K)
CMWS              IF (J+1.LE.I-1) THEN
CMWS                DO 40 K=J+1,I-1
CMWS40              G=G+Q(K,J)*Q(I,K)
CMWS              END IF
CMWS              C(J)=G/H
CMWS              F=F+G*Q(J,I)
CMWS50          CONTINUE
CMWS            H2=F/(H+H)
CMWS            DO 70 J=1,I-1
CMWS              F=Q(I,J)
CMWS              G=C(J)-H2*F
CMWS              C(J)=G
CMWS              DO 60 K=1,J
CMWS60            Q(J,K)=Q(J,K)-F*C(K)-G*Q(I,K)
CMWS70          CONTINUE
CMWS            B(I)=H
CMWS          END IF
CMWS80      CONTINUE
CMWS        DO 85 I=1,N-1
CMWS85      C(I)=C(I+1)
CMWS        C(N)=0.0d0
CMWS        B(1)=0.0d0
CMWS        DO 130 I=1,N
CMWS          IF ((B(I).NE.0.0).AND.(I-1.GE.1)) THEN
CMWS            DO 110 J=1,I-1
CMWS              G=0.0d0
CMWS              DO 90 K=1,I-1
CMWS90            G=G+Q(I,K)*Q(K,J)
CMWS              DO 100 K=1,I-1
CMWS100           Q(K,J)=Q(K,J)-G*Q(K,I)
CMWS110         CONTINUE
CMWS          END IF
CMWS          B(I)=Q(I,I)
CMWS          Q(I,I)=1.0d0
CMWS          IF (I-1.GE.1) THEN
CMWS            DO 120 J=1,I-1
CMWS              Q(I,J)=0.0d0
CMWS              Q(J,I)=0.0d0
CMWS120         CONTINUE
CMWS          END IF
CMWS130     CONTINUE
CMWS        RETURN
CMWS        END

C********************************************************************
C Sort   (nobody is using this routine)
C********************************************************************
c---    subroutine sort2(n,ra,rb)
c---    double precision ra(n),rra
c---    integer rb(n),rrb
c---    l=n/2+1;ir=n
c---    do
c---     if(l.gt.1)then
c---      l=l-1;rra=ra(l);rrb=rb(l)
c---     else
c---      rra=ra(ir);rrb=rb(ir);ra(ir)=ra(1);rb(ir)=rb(1);ir=ir-1
c---      if(ir.eq.1)then
c---       ra(1)=rra;rb(1)=rrb
c---       return
c---      endif
c---     endif
c---     i=l;j=l+l
c---     do while(j.le.ir)
c---      if(j.lt.ir)then
c---       if(ra(j).lt.ra(j+1))j=j+1
c---      endif
c---      if(rra.lt.ra(j))then
c---       ra(i)=ra(j);rb(i)=rb(j);i=j;j=j+j
c---      else
c---       j=ir+1
c---      endif
c---     enddo
c---     ra(i)=rra;rb(i)=rrb
c---    enddo
c---    return
c---    end
C
C
C     2001.4.22. correct.
C     Purpose: solve a system of linear equation by using the method of
C     Gaussian elimination with partial pivoting.
C
      SUBROUTINE GAUSS2(N,A)
C
      double precision A(N,N+1),AV,T
C
      DO 30 K=1,N-1
         AV=0.0d0
         DO 10 I=K,N
            IF (ABS(A(I,K)).LE.ABS(AV)) GOTO 10
            AV=A(I,K)
            L=I
10       CONTINUE
         IF (ABS(AV).LT.1.0E-8) THEN
             WRITE(99,*) 'SINGULAR COEFFICIENT MATRIX'
             STOP
         ENDIF
         IF (L.NE.K) THEN
            DO 15 J=K,N+1
               T=A(K,J)
               A(K,J)=A(L,J)
               A(L,J)=T
15          CONTINUE
         ENDIF
         AV=1.0d0/AV
         DO 25 J=K+1,N+1
            A(K,J)=A(K,J)*AV
            DO 20 I=K+1,N
               A(I,J)=A(I,J)-A(I,K)*A(K,J)
20          CONTINUE
25       CONTINUE
C
30    CONTINUE
      A(N,N+1)=A(N,N+1)/A(N,N)
      DO 40 K=1,N-1
         I=N-K
         AV=0.0d0
         DO 35 J=I+1,N
            AV=AV+A(I,J)*A(J,N+1)
35       CONTINUE
         A(I,N+1)=A(I,N+1)-AV
40    CONTINUE
      RETURN
      END
C
        subroutine Pop_sj(io,natom,nbasis,nv,n1,n2,cv,s,nb,maxcyc,tol)
        double precision s(nbasis,nbasis),cv(nbasis,nv),p(natom,nv,nv)
        double precision a(nv,nv),b(nv,nv),delta(nv,nv),su(nv,nv),pi,tol
        double precision f0,p1,p2,pp,alfa,a0,b0,delta0,sum0,ca,cb,cosa
        double precision sina
        integer nb(natom)
        pi=atan(1.0d0)*4.0d0
        if(maxcyc.le.0)maxcyc=1000000
        if(tol.lt.1.0d-16)tol=1.0d-7
C
        do 1000 iter=1,maxcyc
         ni=iter
C
         if(iter.eq.1)then
          call inte(natom,nbasis,nv,nb,cv,s,p)
          f0=0.0d0
          do i=1,natom
           do j=n1,n2
            f0=f0+p(i,j,j)*p(i,j,j)
           enddo
          enddo
         else
          do i=n1,n2
           if(i.ne.i0.and.i.ne.j0)then
            do k=1,natom
             imin=min(i,i0);imax=max(i,i0)
             jmin=min(i,j0);jmax=max(i,j0)
             p1=cosa*p(k,imin,imax)+sina*p(k,jmin,jmax)
             p(k,jmin,jmax)=-sina*p(k,imin,imax)+cosa*p(k,jmin,jmax)
             p(k,imin,imax)=p1
            enddo
           endif
          enddo
          do k=1,natom
            p1=cosa*cosa*p(k,i0,i0)+sina*sina*p(k,j0,j0)+
     +2*cosa*sina*p(k,i0,j0)
            p2=sina*sina*p(k,i0,i0)+cosa*cosa*p(k,j0,j0)-
     +2*cosa*sina*p(k,i0,j0)
            p(k,i0,j0)=cosa*sina*(-p(k,i0,i0)+p(k,j0,j0))+
     +(cosa*cosa-sina*sina)*p(k,i0,j0)
            p(k,i0,i0)=p1;p(k,j0,j0)=p2
          enddo
         endif
C
         do i=n1,n2-1;do j=i+1,n2
           if(iter.eq.1.or.i.eq.i0.or.i.eq.j0.or.j.eq.i0
     +.or.j.eq.j0)then
            a(i,j)=0.0d0;b(i,j)=0.0d0
            do k=1,natom
             pp=p(k,i,i)-p(k,j,j)
             a(i,j)=a(i,j)+p(k,i,j)*p(k,i,j)-pp*pp/4.0d0
             b(i,j)=b(i,j)+p(k,i,j)*pp
            enddo
            su(i,j)=sqrt(a(i,j)*a(i,j)+b(i,j)*b(i,j))
            delta(i,j)=a(i,j)+su(i,j)
           endif
           if(j.eq.n1+1.or.delta0.lt.delta(i,j))then
            delta0=delta(i,j);i1=i;j1=j;a0=a(i,j);b0=b(i,j)
            sum0=su(i,j)
           endif
         enddo;enddo
C
         i0=i1;j0=j1
         if(sum0.lt.1.0d-6)then
          ni=ni-1
          write(io,*)'Angle error'
          write(io,*)a0,b0,sum0
          write(io,*)'Not convergenced'
          write(io,*)'But iteration should be stopped at',ni
          goto 200
         endif
         sdelta=sdelta+delta0
         alfa=acos(-a0/sum0)
         if(b0.lt.0.0d0)alfa=2*pi-alfa
         alfa=alfa/4.0d0
C        write(io,*),a0,b0,sum0
C        write(io,*)'cycle:',ni
!         write(io,*)'Rotate',i0,'and',j0,'orbital, angle =',alfa/pi*180
         cosa=cos(alfa);sina=sin(alfa)
         do k=1,nbasis
          ca=cosa*cv(k,i0)+sina*cv(k,j0)
          cb=-sina*cv(k,i0)+cosa*cv(k,j0)
          cv(k,i0)=ca;cv(k,j0)=cb
         enddo
!         write(io,*)'The greatest increase=',delta0
         if(delta0.lt.tol)goto 200
1000    continue

        stop 'out of iterative cycles'

200     f=0.0d0
        do i=1,natom
         do j=n1,n2
          f=f+p(i,j,j)*p(i,j,j)
         enddo
        enddo
        write(io,*)'Initial Localization Sum  =',f0
        write(io,*)'Localization done after',ni,'iterations'
        write(io,*)'Final Localization Sum  =',f
        write(io,*)'Increase =',f-f0
        return

        end
C
C
        subroutine inte(natom,nbasis,nv,nb,c,s,p)
        double precision c(nbasis,nv),s(nbasis,nbasis),
     +p(natom,nv,nv)
        integer nb(natom)
        p=0.0d0
        do i=1,natom
         nk=nbasis
         if(i.ne.natom)nk=nb(i+1)-1
         do m=1,nv
          do n=m,nv
           do j=1,nbasis
            do k=nb(i),nk
             p(i,m,n)=p(i,m,n)+c(j,m)*s(j,k)*c(k,n)+c(k,m)*s(j,k)*c(j,n)
            enddo
           enddo
          enddo
         enddo
        enddo
        p=p/2
        return
        end

CMWSC
CMWSC --- Count the number of frozen core orbitals automatically
CMWS      subroutine FRZORB(io,NATOM,ZAN,nfocc,nfvir,icore)
CMWS      implicit double precision(A-H,O-Z)
CMWS      dimension ZAN(NATOM)
CMWSC
CMWS      nfocc=0
CMWS      nfvir=0
CMWS      if (icore.ne.0) goto 999
CMWS      do i=1,NATOM
CMWS         if (ZAN(i).gt.86) then
CMWS            nfocc=nfocc+43
CMWS         elseif (ZAN(i).gt.54) then
CMWS            nfocc=nfocc+27
CMWS         elseif (ZAN(i).gt.36) then
CMWS            nfocc=nfocc+18
CMWS         elseif (ZAN(i).gt.18) then
CMWS            nfocc=nfocc+9
CMWS         elseif (ZAN(i).gt.10) then
CMWS            nfocc=nfocc+5
CMWS         elseif (ZAN(i).gt.2) then
CMWS            nfocc=nfocc+1
CMWS         endif
CMWS      enddo
CMWSC
CMWS 999  if (io.gt.0) write(io,100) nfocc,nfvir
CMWSC
CMWS 100  format(1x,'The number of frozen MOs (occupied, virtual) =',2i6)
CMWS      end
C
CMWS****** 2005.03.29 get value after vari= in a line******
CMWS*      2005.09.10 updated
CMWS      subroutine GetIValu(line,vari,ch,k,nvalu)
CMWS      implicit none
CMWS      integer nvalu,l1,l2,i1,i2,i3,k,l
CMWS      character line*(*),vari*(*),ch
CMWS
CMWS      call NJ_upper(line)
CMWS      call NJ_upper(vari)
CMWS      l1=len(line); l2=len(vari)
CMWS      k=index(line,vari)
CMWS      if (k==0) then
CMWS         nvalu=0; return
CMWS      endif
CMWS      i2=index(line(k:l1),ch)+k-1
CMWS      if (i2.eq.k-1) then
CMWS         nvalu=0; return
CMWS      endif
CMWS      i3=index(line(k:l1),' ')+k-1
CMWS      if (i3==i2+1) then
CMWS         do l=i3,l1
CMWS            if (line(l:l).ne.' ') then
CMWS               i3=l; exit
CMWS            endif
CMWS         enddo
CMWS         do l=i3,l1
CMWS            if (line(l:l).eq.' ') then
CMWS               i3=l; exit
CMWS            endif
CMWS         enddo
CMWS      endif
CMWS      read(line(i2+1:i3-1),*) nvalu
CMWSC
CMWS      end
CMWSC
CMWS****** real*8 value
CMWS      subroutine GetRValu(line,vari,k,rvalu)
CMWS      implicit none
CMWS      integer l1,l2,i1,i2,i3,k
CMWS      double precision rvalu
CMWS      character line*(*),vari*(*)
CMWSC
CMWS      call NJ_upper(line)
CMWS      call NJ_upper(vari)
CMWS      l1=len(line); l2=len(vari)
CMWS      k=index(line,vari)
CMWS      if (k==0) then
CMWS         rvalu=0d0; return
CMWS      endif
CMWS      i2=index(line(k:l1),'=')+k-1
CMWS      i3=index(line(k:l1),' ')+k-1
CMWS      read(line(i2+1:i3-1),*) rvalu
CMWSC
CMWS      end
CMWSC
CMWS****** real*8 value
CMWS      subroutine GetCValu(line,vari,k,cvalu)
CMWS      implicit none
CMWS      integer l1,l2,i1,i2,i3,k
CMWS      character line*(*),vari*(*),cvalu*8
CMWSC
CMWS      call NJ_upper(line)
CMWS      call NJ_upper(vari)
CMWS      cvalu='        '
CMWS      l1=len(line); l2=len(vari)
CMWS      k=index(line,vari)
CMWS      if (k.eq.0) return
CMWS      i2=index(line(k:l1),'=')+k-1
CMWS      i3=index(line(k:l1),' ')+k-1
CMWS      cvalu(1:i3-1-i2)=line(i2+1:i3-1)
CMWSC
CMWS      end
C
CMWSC-WL- Calc the spatial distance of MOs
CMWS      subroutine DODISMO(io,NW,Nmo,NUW,SMO,mdmx,mdmy,mdmz,DISMO)
CMWS      implicit none
CMWS      integer i,j,k,L,k1,k2,k3,k4,m,n,io,NW,Nmo,NUW
CMWS      double precision SMO(NW,Nmo),mdmx(Nmo,Nmo),mdmy(Nmo,Nmo)
CMWS      double precision mdmz(Nmo,Nmo)
CMWS      double precision DISMO(NUW,NUW),R,X,Y,Z
CMWSC
CMWS      DISMO=0
CMWS      DO 100 I=1,NUW-1
CMWS         DO 200 J=I+1,NUW
CMWS            X=mdmx(I,I)-mdmx(J,J)
CMWS            Y=mdmy(I,I)-mdmy(J,J)
CMWS            Z=mdmz(I,I)-mdmz(J,J)
CMWS            R=DSQRT(X*X+Y*Y+Z*Z)
CMWS            DISMO(I,J)=R
CMWS            DISMO(J,I)=R
CMWS 200     END DO
CMWS 100  END DO
CMWSC
CMWS      IF (io.gt.0) THEN
CMWS         write(io,*) '+++ The spatial distances of LMOs +++'
CMWS         call NJ_prtsym(io,NUW,DISMO,'d14.6')
CMWS      END IF
CMWSC
CMWS      END
C
C --- 2005.11.16 Cnp = Anm Bmp
      subroutine NJ_matpro(io,n,m,p,A,B,C)
      implicit none
      integer io,m,n,p,i,j,k,l
      real*8 A(n,m),B(m,p),C(n,p)
      C=0d0
      do j=1,p; do i=1,n
         do k=1,m
            C(i,j)=C(i,j)+A(i,k)*B(k,j)
         enddo
      enddo; enddo
C
      end
C
C --- 2005.11.16 --- Transformation matrix for overlap by Symmetric Orthogonalization  ---
      subroutine NJ_symorth(io,nbs,Evalu,Evect,Tmatr)
      implicit none
      integer io,nbs,i,j,k
      real*8 Evalu(nbs),Evect(nbs,nbs),Tmatr(nbs,nbs),PP

      Tmatr=0d0
      do j=1,nbs; do i=1,nbs
         do k=1,nbs
            PP=Evect(i,k)*Evect(j,k)/dsqrt(Evalu(k))
            Tmatr(i,j)=Tmatr(i,j)+PP
         enddo
      enddo; enddo

      if (io>0) then
         write(io,*) 'Transformation Matrix by Symmetric',
     &               ' Orthogonalization'
         call NJ_prtsym(io,nbs,Tmatr,'d14.6')
         write(io,*)
      endif

      end
C
C --- 2005.11.19 --- Transformation matrix for overlap by Canonical Orthogonalization  ---
      subroutine NJ_canorth(io,nbs,nif,Evalu,Evect,Tmatr)
      implicit none
      integer io,nbs,i,j,k,nif
      real*8 Evalu(nif),Evect(nbs,nif),Tmatr(nbs,nif),PP

      Tmatr=0d0
      do j=1,nif; do i=1,nbs
            PP=Evect(i,j)/dsqrt(Evalu(j))
            Tmatr(i,j)=Tmatr(i,j)+PP
      enddo; enddo

      if (io>0) then
         write(io,*) 'Transformation Matrix by Canonical',
     &               ' Orthogonalization'
         call NJ_prtcol2(io,nbs,nif,Tmatr,1,nif,'f14.6')
         write(io,*)
      endif

      end
C
CMWSC --- 2008.02.13 Add for the orthogonalization of MOs
CMWS      subroutine OrthMO(io,nbs,nmo,mo,s,omo,norm,itype)  ! liweiii
CMWS      implicit none
CMWS      integer io,nbs,nmo,i,j,k,L,m,n,k1,k2,k3,k4,j1,j2,ii,mu,nu,norm
CMWS      integer itype
CMWS      double precision mo(nbs,nmo),s(nbs,nbs),P1,PP,P2,omo(nbs,nmo)
CMWS      double precision,allocatable::ss(:,:),q(:,:),e(:),vc(:),t(:,:)
CMWSC
CMWS      allocate(ss(nmo,nmo),q(nmo,nmo),e(nmo),vc(nmo),t(nmo,nmo))
CMWSC
CMWSC     write(io,*) 'Occupied LMOs in expanded subsystems'
CMWSC     call NJ_prtcol2(io,nbs,nmo,mo,1,nmo,'f11.6')
CMWSC
CMWS      call NJ_tfock(0,nbs,nmo,s,mo,ss) ! s'=mo^T*s*mo
CMWSC
CMWSC     write(io,*) 'Occupied LMOs in expanded subsystems'
CMWSC     do j1=1,nmo-1
CMWSC        do j2=j1+1,nmo
CMWSC           P1=ss(j2,j1)
CMWSC           if (dabs(P1)>1d-6) write(io,'(2i4,f12.8)') j1,j2,P1
CMWSC        enddo
CMWSC     enddo
CMWSC
CMWS      call NJ_qr(io,ss,nmo,q,e,vc,k,0)
CMWS      write(io,*) 'Eigenvalues:'
CMWS      write(io,'(5f11.6)') e
CMWS      if (itype.eq.1) then
CMWS         write(io,*) 'Symmetric Orthogonalization is used'
CMWS         call NJ_symorth(0,nmo,e,q,t)
CMWS      else if (itype.eq.2) then
CMWS         write(io,*) 'Canonical Orthogonalization is used'
CMWS         call NJ_canorth(0,nmo,nmo,e,q,t)
CMWS      else
CMWS         write(io,*) 'Wrong type for orthogonalization'
CMWS         write(io,*) 'itype in OrthMO() should be 1 or 2'
CMWS         write(io,*) '1. Symmetric Orthogonalization'
CMWS         write(io,*) '2. Canonical Orthogonalization'
CMWS      endif
CMWS      call NJ_matpro(io,nbs,nmo,nmo,mo,t,omo)
CMWS      if (norm.ne.0) call normorb2(io,nbs,nmo,omo,s)
CMWSC
CMWSC     write(io,*) 'Orthogonal occupied LMOs in expanded subsystems'
CMWSC     call NJ_prtcol2(io,nbs,nmo,omo,1,nmo,'f11.6')
CMWS      write(io,*) 'C^+SC='
CMWS      call NJ_tfock(0,nbs,nmo,s,omo,ss) ! s'=mo^T*s*mo
CMWSC
CMWS      write(io,*) 'New --> Old     Overlap (> 0.1)'
CMWS      do j=1,nmo
CMWS         do i=1,nmo
CMWS            P1=0d0
CMWS            do mu=1,nbs
CMWS               do nu=1,nbs
CMWS                  P1=P1+mo(mu,i)*omo(nu,j)*s(nu,mu)
CMWS               enddo
CMWS            enddo
CMWS            if (dabs(P1).gt.0.1d0)
CMWS     &         write(io,'(i4,'' -->'',i4,5x,''S='',f12.8)') j,i,P1
CMWS         enddo
CMWS      enddo
CMWSC
CMWS      deallocate(ss,q,e,vc,t)
CMWS      end
C
C --- Project nmo2 of nmo occ. LMOs from total system onto extended subsystems
      subroutine projorb(io,nbs,nbs2,nmo,nmo2,mo,mo2,s)
      integer io,nbs,nbs2,nmo,i,j,k,L
      double precision mo(nbs,nmo),mo2(nbs2,nmo2),s(nbs,nbs)
C
      if (nmo.eq.nmo2) then
         write(io,100) nmo,nbs,nbs2
      else
         write(io,105) nmo,nmo2,nbs,nbs2
      endif
C
      if (nbs2.gt.nbs) then
         write(io,110) nbs2,nbs
         call abrt
      end if
C
      if (nmo2.gt.nmo) then
         write(io,120) nmo2,nmo
         call abrt
      end if
C
      if (nbs2.eq.nbs) then
         do j=1,nmo2
            do i=1,nbs2
               mo2(i,j)=mo(i,j)
            enddo
         enddo
      else
         do j=1,nmo2
            CALL MINA1(nbs2,j,nbs,nmo,mo,s,mo2(1,j))
         enddo
      endif

C
 100  format(3x,'[Project MOs]    MO=',i4,' AO:',i4,' -->',i4)
 105  format(3x,'[Project MOs]    MO:',i4,' -->',i4,' AO:',i4,' -->',i4)
 110  format(1x,'It is impossible to project orbitals on more AOs',2i5)
 120  format(1x,'It is impossible to project more MOs than olds',2i5)
      end
C
C --- 2008.02.21 --- Project out the mo1(nbs,nmo1) from mo2(nbs,nmo2)
      subroutine pjotorb(io,nbs,nmo1,nmo2,mo1,mo2,s)
      implicit none
      integer io,nbs,nmo1,nmo2,i,j,k,L,m,n,k1,k2,k3,k4
      double precision mo1(nbs,nmo1),mo2(nbs,nmo2),s(nbs,nbs),P1
      double precision,allocatable::p(:,:),ps(:,:),mo3(:,:)
C
      write(io,100) nmo1,nmo2,nbs
      allocate(p(nbs,nbs),ps(nbs,nbs),mo3(nbs,nmo2))
C
      do i=1,nbs
         do j=1,nbs
            P1=0d0
            do m=1,nmo1
               P1=P1+mo1(i,m)*mo1(j,m)
            end do
            p(j,i)=P1
            p(i,j)=P1
         end do
      end do
C
      call NJ_matpro(io,nbs,nbs,nbs,p,s,ps)
      call NJ_matpro(io,nbs,nbs,nmo2,ps,mo2,mo3)
C
      do i=1,nmo2
         do j=1,nbs
            mo2(j,i)=mo2(j,i)-mo3(j,i)
         end do
      end do
C
      deallocate(p,ps,mo3)
C
 100  format(3x,'[Project out]    MO:',i4,' <-|',i4,' AO=',i4)
      end
C
C --- 2008.02.13 Add for the orthogonalization of MOs
      subroutine orthorb(io,nbs,nmo,mo,s,itype)  ! liweiii
      implicit none
      integer io,nbs,nmo,i,j,k,L,m,n,k1,k2,k3,k4,j1,j2,ii,mu,nu,norm
      integer itype,nzero
      double precision mo(nbs,nmo),s(nbs,nbs),P1,PP,P2,zeps
      double precision,allocatable::ss(:,:),q(:,:),e(:),vc(:),t(:,:)
      double precision,allocatable::omo(:,:)
C
      zeps=1d-5
C
      allocate(ss(nmo,nmo),q(nmo,nmo),e(nmo),vc(nmo),t(nmo,nmo))
      allocate(omo(nbs,nmo))
      call NJ_tfock(0,nbs,nmo,s,mo,ss) ! s'=mo^T*s*mo  overlap over MO
      call NJ_qr(0,ss,nmo,q,e,vc,k,0) ! QR diagonalization of ss
      call numpoint(nmo,e,-zeps,zeps,nzero)  ! Count the number of values \in [-zeps,zeps] ("zero" eigenvalues)
      if (nzero.ne.0) then
         write(io,200) nzero
         write(io,210) (e(i),i=1,nmo)
      end if
C
      if (itype.eq.1) then
         write(io,100) nmo,nbs
         call NJ_symorth(0,nmo,e,q,t)
      else if (itype.eq.2) then
         write(io,110) nmo,nbs
         call NJ_canorth(0,nmo,nmo,e,q,t)
      else
         write(io,*) 'Wrong type for orthogonalization'
         write(io,*) 'itype in OrthMO() should be 1 or 2'
         write(io,*) '1. Symmetric Orthogonalization'
         write(io,*) '2. Canonical Orthogonalization'
         stop
      endif
      call NJ_matpro(io,nbs,nmo,nmo,mo,t,omo)
C
      do i=1,nmo
         do j=1,nbs
            mo(j,i)=omo(j,i)
         end do
      end do
C
      deallocate(ss,q,e,vc,t,omo)
C
 100  format(3x,'[Symmetric orth] MO=',i4,' AO=',i4)
 110  format(3x,'[Canonical orth] MO=',i4,' AO=',i4)
 200  format(1x,'Warning: number of zero eigenvalues=',i4)
 210  format(1x,5f14.6)
      end
C
C --- Normalization of a set of orbital mo(nbs,nmo)
      subroutine normorb2(io,nbs,nmo,mo,s)
      implicit none
      integer io,nbs,nmo,i,j,k,L,m,n,k1,k2,k3,k4
      double precision mo(nbs,nmo),s(nbs,nbs),P1,PP
C
C     write(io,100) nmo,nbs
      do i=1,nmo
         call normfact(nbs,mo(1,i),s,P1)
         do j=1,nbs
            mo(j,i)=mo(j,i)/P1
         enddo
      enddo
C
 100  format(1x,'[Normalize]      MO=',i4,' AO=',i4)
      end
C
C --- Determine the normalization factor of one orbital c(nbs), vv returned
C     For normalization use c=c/p
      subroutine normfact(nbs,ac,s,p)
      implicit none
      integer nbs,k1,k2
      double precision ac(nbs),s(nbs,nbs),p
C
      p=0d0
      do k1=1,nbs
         do k2=1,nbs
            p=p+ac(k1)*ac(k2)*s(k2,k1)
         end do
      end do
      if (p.le.0d0) stop 'Error in normvalu(): negotive module'
      p=dsqrt(p)
      end
C
CMWSC --- Overlap of each MO with itself of mo(nbs,nmo)
CMWSC     sort>0 increased sorting
CMWSC     sort<0 decreased sorting
CMWSC     sort=0 unsorting
CMWS      subroutine ovlpslf(io,nbs,nmo,mo,s,ovlp,sort)
CMWS      implicit none
CMWS      integer io,nbs,nmo,i,j,k,L,i1,i2,j1,j2,k1,k2,sort
CMWS      double precision mo(nbs,nmo),s(nbs,nbs),p1,pp,ovlp(nmo)
CMWSC
CMWS      do i=1,nmo
CMWS         p1=0d0
CMWS         do j2=1,nbs
CMWS            do j1=1,nbs
CMWS               p1=p1+mo(j1,i)*mo(j2,i)*s(j1,j2)
CMWS            end do
CMWS         end do
CMWS         ovlp(i)=p1
CMWS      end do
CMWSC
CMWS      if (sort.gt.0) then
CMWS         do i=1,nmo-1
CMWS            do j=i+1,nmo
CMWS               if (ovlp(i).lt.ovlp(j)) cycle
CMWS               p1=ovlp(i)
CMWS               ovlp(i)=ovlp(j)
CMWS               ovlp(j)=p1
CMWS               do k=1,nbs
CMWS                  pp=mo(k,i)
CMWS                  mo(k,i)=mo(k,j)
CMWS                  mo(k,j)=pp
CMWS               end do
CMWS            end do
CMWS         end do
CMWS         if (io.gt.0) write(io,110) nmo,nbs
CMWS      else if (sort.lt.0) then
CMWS         do i=1,nmo-1
CMWS            do j=i+1,nmo
CMWS               if (ovlp(i).gt.ovlp(j)) cycle
CMWS               p1=ovlp(i)
CMWS               ovlp(i)=ovlp(j)
CMWS               ovlp(j)=p1
CMWS               do k=1,nbs
CMWS                  pp=mo(k,i)
CMWS                  mo(k,i)=mo(k,j)
CMWS                  mo(k,j)=pp
CMWS               end do
CMWS            end do
CMWS         end do
CMWS         if (io.gt.0) write(io,120) nmo,nbs
CMWS      else
CMWS         if (io.gt.0) write(io,130) nmo,nbs
CMWS      end if
CMWSC
CMWS      if (io.gt.0) write(io,140) (ovlp(i),i=1,nmo)
CMWSC
CMWS 110  format(1x,'Self overlap of',i4,' MOs with',i5,' AOs (increased)')
CMWS 120  format(1x,'Self overlap of',i4,' MOs with',i5,' AOs (decreased)')
CMWS 130  format(1x,'Self overlap of',i4,' MOs with',i5,' AOs (unsorted)')
CMWS 140  format(8f8.5)
CMWS      end
C
C --- Overlap of each MO with itself of mo(nbs,nmo); sort mo and corresponding mo0
C     sort>0 increased sorting
C     sort<0 decreased sorting
C     sort=0 unsorting
      subroutine ovlpslf2(io,nbs,nmo,mo,nbs0,mo0,s,ovlp,sort)
      implicit none
      integer io,nbs,nbs0,nmo,i,j,k,L,i1,i2,j1,j2,k1,k2,sort
      double precision mo(nbs,nmo),s(nbs,nbs),p1,pp,ovlp(nmo)
      double precision mo0(nbs0,nmo)
C
      do i=1,nmo
         p1=0d0
         do j2=1,nbs
            do j1=1,nbs
               p1=p1+mo(j1,i)*mo(j2,i)*s(j1,j2)
            end do
         end do
         ovlp(i)=p1
      end do
C
      if (sort.gt.0) then
         do i=1,nmo-1
            do j=i+1,nmo
               if (ovlp(i).lt.ovlp(j)) cycle
               p1=ovlp(i)
               ovlp(i)=ovlp(j)
               ovlp(j)=p1
C
               do k=1,nbs
                  pp=mo(k,i)
                  mo(k,i)=mo(k,j)
                  mo(k,j)=pp
               end do
C
               do k=1,nbs0
                  pp=mo0(k,i)
                  mo0(k,i)=mo0(k,j)
                  mo0(k,j)=pp
               end do
            end do
         end do
         if (io.gt.0) write(io,110) nmo,nbs
      else if (sort.lt.0) then
         do i=1,nmo-1
            do j=i+1,nmo
               if (ovlp(i).gt.ovlp(j)) cycle
               p1=ovlp(i)
               ovlp(i)=ovlp(j)
               ovlp(j)=p1
C
               do k=1,nbs
                  pp=mo(k,i)
                  mo(k,i)=mo(k,j)
                  mo(k,j)=pp
               end do
C
               do k=1,nbs0
                  pp=mo0(k,i)
                  mo0(k,i)=mo0(k,j)
                  mo0(k,j)=pp
               end do
            end do
         end do
         if (io.gt.0) write(io,120) nmo,nbs
      else
         if (io.gt.0) write(io,130) nmo,nbs
      end if
C
      if (io.gt.0) write(io,140) (ovlp(i),i=1,nmo)
C
 110  format(1x,'Self overlap of',i4,' MOs with',i5,' AOs (increased)')
 120  format(1x,'Self overlap of',i4,' MOs with',i5,' AOs (decreased)')
 130  format(1x,'Self overlap of',i4,' MOs with',i5,' AOs (unsorted)')
 140  format(8f8.5)
      end
C
CMWSC --- Overlap between MOs of mo(nbs,nmo)
CMWS      subroutine ovlporb(io,nbs,nmo,mo,s)
CMWS      implicit none
CMWS      integer io,nbs,nmo,i,j,k,L,i1,i2,j1,j2,k1,k2
CMWS      double precision mo(nbs,nmo),s(nbs,nbs),p1,pp
CMWS      double precision,allocatable::ovlp(:,:)
CMWSC
CMWS      allocate(ovlp(nmo,nmo))
CMWS      do i2=1,nmo
CMWS         do i1=1,nmo
CMWS            p1=0d0
CMWS            do j2=1,nbs
CMWS               do j1=1,nbs
CMWS                  p1=p1+mo(j1,i1)*mo(j2,i2)*s(j1,j2)
CMWS               end do
CMWS            end do
CMWS            ovlp(i1,i2)=p1
CMWS         end do
CMWS      end do
CMWSC
CMWS      if (io.gt.0) then
CMWS         write(io,100) nmo,nbs
CMWS         call NJ_prtsym(io,nmo,ovlp,'f12.8')
CMWS      end if
CMWSC
CMWS      deallocate(ovlp)
CMWS 100  format(1x,'Overlap between',i4,' MOs with',i5,' AOs')
CMWS      end
C
CMWSC --- Overlap between two set of MOs mo1(nbs,nmo1),mo2(nbs,nmo2)
CMWS      subroutine ovlporb2(io,nbs,nmo1,mo1,nmo2,mo2,s)
CMWS      implicit none
CMWS      integer io,nbs,nmo1,nmo2,i,j,k,L,i1,i2,j1,j2,k1,k2
CMWS      double precision mo1(nbs,nmo1),mo2(nbs,nmo2),s(nbs,nbs),p1,pp,over
CMWS      double precision,allocatable::ovlp(:,:)
CMWS      parameter(over=0.2d0)
CMWSC
CMWS      allocate(ovlp(nmo1,nmo2))
CMWS      do i2=1,nmo2
CMWS         do i1=1,nmo1
CMWS            p1=0d0
CMWS            do j2=1,nbs
CMWS               do j1=1,nbs
CMWS                  p1=p1+mo1(j1,i1)*mo2(j2,i2)*s(j1,j2)
CMWS               end do
CMWS            end do
CMWS            ovlp(i1,i2)=p1
CMWS         end do
CMWS      end do
CMWSC
CMWS      if (io.gt.0) then
CMWS         write(io,100) nbs
CMWS         write(io,110) over
CMWS         write(io,120) nmo2,nmo1
CMWSC        call NJ_prtcol2(io,nmo1,nmo2,ovlp,1,nmo2,'f12.8')
CMWS         do i2=1,nmo2
CMWS            do i1=1,nmo1
CMWS               if (dabs(ovlp(i1,i2)).gt.0.1d0) write(io,150) i2,i1
CMWS            end do
CMWS         end do
CMWS      end if
CMWSC
CMWS      deallocate(ovlp)
CMWS 100  format(1x,'Overlap between two sets of MOs with',i5,' AOs')
CMWS 110  format(1x,'Only print those items with value larger than',f7.4)
CMWS 120  format(1x,'Second (new) set (',i4,' MOs) --> First (old) set (',
CMWS     &       i4,' MOs)')
CMWS 150  format(i5,' -->',i5)
CMWS      end
C
CMWSC --- WL Sort jobs in .jobs file from the most expensive to cheapest one
CMWS      subroutine sortjob(job,njobs,kord)
CMWS      implicit none
CMWS      integer i,j,k,L,k1,k2,k3,k4,job,njobs,kord(njobs)
CMWS      character(len=256),dimension(:),allocatable::cjob
CMWSC
CMWS      allocate(cjob(4*njobs))
CMWS      cjob=' '
CMWSC
CMWS      rewind(job)
CMWS      read(job,*)
CMWS      do j=1,4*njobs
CMWS         read(job,'(a)') cjob(j)
CMWS      enddo
CMWSC
CMWS      rewind(job)
CMWS      read(job,*)
CMWS      do i=1,njobs
CMWS         k=kord(i)
CMWS         k1=4*k-3
CMWS         k2=4*k-2
CMWS         k3=4*k-1
CMWS         k4=4*k
CMWS         write(job,'(a)') trim(cjob(k1))
CMWS         write(job,'(a)') trim(cjob(k2))
CMWS         write(job,'(a)') trim(cjob(k3))
CMWS         write(job,'(a)') trim(cjob(k4))
CMWS      enddo
CMWSC
CMWS      deallocate(cjob)
CMWS      end
C
      subroutine NJ_denmat(io,nbs,nif,noc,cmo,dm)
      implicit none
      integer io,nbs,nif,noc,i,j,k
      real*8 cmo(nbs,nif),dm(nbs,nbs),PP
      dm=0d0
      do i=1,nbs; do j=1,nbs
         PP=0d0
         do k=1,noc
            PP=PP+cmo(i,k)*cmo(j,k)
         enddo
         dm(i,j)=2d0*PP
      enddo; enddo

      if (io>0) then
         write(io,*) '*** Density matrix ***'
         call NJ_prtsym(io,nbs,dm,'d14.6')
         write(io,*)
      endif
      return
      end
C
C-WL- 7 Apr 2009: print infomation to io
      subroutine PRTINF(io,NAT,ICH,MUL,NE,NA,NB,NBS,NMO,
     &           NSHELL,NGAUSS,ENU,SCFTYP,EHF)
      implicit none
      integer io,NAT,ICH,MUL,NE,NA,NB,NBS,NMO,NSHELL,NGAUSS
      character(len=8) SCFTYP
      double precision ENU,EHF
      integer i,j,k,L,m,n,k1,k2,k3,k4,k5,k6
      character(len=200) line
C
      write(io,*) '+++ Read information from CIMFILE file +++'
      write(io,'(1x,44(''-''))')
      write(io,*) 'Number of atoms                ',NAT
      write(io,*) 'Charge                         ',ICH
      write(io,*) 'Multiplicity                   ',MUL
      write(io,*) 'Number of electrons            ',NE
      write(io,*) 'Number of alpha electrons      ',NA
      write(io,*) 'Number of beta electrons       ',NB
      write(io,*) 'Number of basis functions      ',NBS
      write(io,*) 'Number of independant functions',NMO
      write(io,*) 'Number of contracted shells    ',NSHELL
      write(io,*) 'Number of primitive shells     ',NGAUSS
      write(io,'('' Nuclear Repulsion Energy'',f20.9)') ENU
      write(io,'('' SCF type = '',a8)') scftyp
      write(io,'('' SCF energy='',f20.9)') EHF
      write(io,'(1x,44(''-''))')
      write(io,*)
C
      end
C
c     ##############################################################
c     ##  subroutine GMSINP --  Make GAMESS input of subsystem    ##
c     ##  2004.12.26 by Wei Li; Update 2005.12.26 by Wei Li       ##
c     ##############################################################
      subroutine SUBINP(io,inp,nat,nuchar,coor,snat,BA,
     &           scftyp,mplevl,cctyp,IWORK,mwords,icharg,mult,NCBS,CBAS,
     &           thissystem)
      implicit none
      integer thissystem
      integer io,inp,nat,snat,BA(snat),i,j,k,l,m,n,m1,m2
      double precision nuchar(nat),coor(3,nat)
      integer k1,k2,k3,k4,k5,k6,kccinp,mplevl,IWORK(100)
      character line*256,line2*256,sls,elemsyl*2,atom*2,cconv*80
      character*8 scftyp,cctyp
      integer memnew,icharg,L1,L2,mult,L3,L4,mwords
      character charg*100,mulp*100,bk,ch
      character ispher*100
      integer L5,L6
      external elemsyl
      integer NCBS(nat)
      character(len=100) CBAS(100,nat)
C
      rewind(inp)
      sls=char(47)
      bk=' '
      kccinp=0
      write(cconv,*) IWORK(1)
      call NJ_trim(cconv,k5,k6)
C
      write(charg,*) icharg
      call NJ_trim(charg,L1,L2)
      write(mulp,*) mult
      call NJ_trim(mulp,L3,L4)
C
      write(ch,'(i1)') mplevl
C     write(ispher,'(i1)') iwork(61)
      write(ispher,*) iwork(61)
      call NJ_trim(ispher,L5,L6)
C
C --- $CONTRL
      line = '$CONTRL RUNTYP=CIMSUB SCFTYP='//trim(scftyp)
     &     //' MPLEVL='//ch//' CCTYP='//trim(cctyp)
      write(inp,99) trim(line)
      line = 'ISPHER='//ispher(L5:L6)//' ICHARG='//charg(L1:L2)
     & //' MULT='//mulp(L3:L4)
     &     //' NORMP=1 NPRINT=-5 $END'
      write(inp,99) trim(line)
      if(mplevl.eq.2) then
         line = '$MP2 CODE=SERIAL $END'
         write(inp,99) trim(line)
      endif
C
C --- $SYSTEM
      write(line,*) mwords
      call NJ_trim(line,k1,k2)
      line = '$SYSTEM MWORDS='//line(k1:k2)//' $END'
      write(inp,99) trim(line)
C
C --- $CCINP
      if (cctyp.ne.'NONE    ') then
         if (scftyp.eq.'RHF     ') then
            line = '$CCINP NCORE=0 MAXCC=200 MAXCCL=200 ICONV='
     &           //cconv(k5:k6)//' $END'
         else
            line = '$CCINP NCORE=0 MAXCC=200 IOPMET=1 ICONV='
     &           //cconv(k5:k6)//' MULT='//mulp(L3:L4)//' $END'
         endif
         write(inp,99) trim(line)
      endif
C
C --- $DATA
      write(inp,99) '$DATA'
C     write(inp,110) snat
      write(inp,111) thissystem
      write(inp,100) 'C1'
      do k=1,snat
         L=BA(k)
         atom=elemsyl(nint(nuchar(L)))
         write(inp,120) atom,nuchar(L),(coor(j,L),j=1,3)
         do j=1,NCBS(L)
            write(inp,'(a)') trim(CBAS(j,L))
         enddo
         write(inp,'(a8)') '        '
      enddo
      write(inp,99) '$END'
C
C
  99  format(1x,a)
 100  format(a)
 110  format('NAtoms=',i4)
 111  format('Subsystem ',i4)
 120  format(a3,f5.1,3f16.8)
C
      end
C
C
      subroutine ifind2(iunit, key)
      implicit none
      character key*(*),line*200
      integer iunit,n,L,k,iyes,itry
C
      iyes=0
      itry=0
      L=len(key)
 50   do
         read(iunit,'(a)',end=100,err=100) line
         if (index(line,key(1:L)).ne.0) then
            iyes=1
            backspace(iunit)
            return
         endif
      end do
C
 100  itry=itry+1
      if (itry.eq.1) then
         rewind(iunit)
         goto 50
      endif
C sometimes fortran has problems if the
C position is set to EOF
      backspace(iunit)

      end
C
C-WL- 09 SEP 2009 for determining the level of calculations of subsystems
      subroutine SYSLEVEL(io,NUW,KGG,ISUB3,INF2,molevl,mtdsys)
      implicit none
      integer io,NUW,KGG,i,j,k,L,k1,k2
      integer ISUB3(NUW),INF2(NUW,NUW),molevl(NUW),mtdsys(KGG)
      mtdsys=0
      do i=1,KGG
         if (ISUB3(i).eq.0) cycle
         do j=1,ISUB3(i)
            k=INF2(j,i)
            k1=mtdsys(i)
            k2=molevl(k)
            if (k2.gt.k1) then
               mtdsys(i)=k2
            endif
         enddo
      enddo

      if (io.gt.0) then
         write(io,*) '+++ The level of the calculations for subsys +++'
         write(io,'(4(3x,5i3))') (mtdsys(i),i=1,KGG)
         write(io,*) '0 - NONE'
         write(io,*) '1 - MP2'
         write(io,*) '2 - CCD'
         write(io,*) '3 - CCSD'
         write(io,*) '4 - CCSD(T)'
         write(io,*) '5 - CR-CCL'
         WRITE(io,*)
      endif
      end

C --- 2009.04.21 -WL- Sorting the orbitals by the index
      subroutine SortOcc(io,noa,nob,nsys,mcen,mocc,LOCC,CenMO)
      implicit none
C
      integer io,noa,nob,nsys,i,j,k,L,m,n,k1,k2,k3,k4,L1,L2
      integer mcen(noa),mocc(noa),LOCC(noa,noa),CenMO(noa,nsys)
C
      CenMO=0
C
      do i=1,nsys
         do j=1,mcen(i)
            if (LOCC(j,i).gt.nob) then
               CenMO(j,i)=1
            else
               CenMO(j,i)=2
            endif
         enddo
      enddo
C
      if (io.gt.0) then
         write(io,*) '+++ Occ. MOs before sorting +++'
         do i=1,nsys
            write(io,'(3(5i4,2x),5i4)') (LOCC(j,i),j=1,mocc(i))
         enddo
         write(io,*) '+++ Cen. MOs before sorting +++'
         do i=1,nsys
            write(io,'(7(5i2,1x),5i2)') (CenMO(j,i),j=1,mocc(i))
         enddo
         write(io,*)
      endif
C
C
      do i=1,nsys
         do k1=1,mocc(i)-1
            do k2=k1+1,mocc(i)
               L1=LOCC(k1,i)
               L2=LOCC(k2,i)
               if (L1.le.L2) cycle
               LOCC(k1,i)=L2
               LOCC(k2,i)=L1
               k=CenMO(k1,i)
               CenMO(k1,i)=CenMO(k2,i)
               CenMO(k2,i)=k
            enddo
         enddo
      enddo
C
      if (io.gt.0) then
         write(io,*) '+++ Occ. MOs after sorting +++'
         do i=1,nsys
            write(io,'(3(5i4,2x),5i4)') (LOCC(j,i),j=1,mocc(i))
         enddo
         write(io,*) '+++ Cen. MOs after sorting +++'
         do i=1,nsys
            write(io,'(7(5i2,1x),5i2)') (CenMO(j,i),j=1,mocc(i))
         enddo
         write(io,*)
      endif
C
      end
C
CMWSC --- goto the end of a file
CMWS      subroutine LS_toend(io,iform)
CMWS      implicit none
CMWS      integer i,j,io,iform
CMWS
CMWS      do
CMWS        if (iform==0) then
CMWS           read(io,*,end=200,err=200)
CMWS        elseif (iform==1) then
CMWS           read(io,end=200,err=200)
CMWS        endif
CMWS      enddo
CMWS
CMWS 200  return
CMWS      end
C
C --- 2009.11.03 copy FXY from FIJ
      subroutine CopyFIJ(io,NUW,FIJ,FXY)
      implicit none
      integer io,NUW,i,j,k,L
      double precision FIJ(NUW,NUW),FXY(NUW,NUW)
C
      do i=1,NUW
         do j=1,NUW
            FXY(j,i)=FIJ(j,i)
         enddo
      enddo
C
      end
C
C --- 2009.10.28 Calculate FXY from FIJ
      subroutine FIJ2XY(io,NUW,FIJ,FXY)
      implicit none
      integer io,NUW,i,j,k,L,m,n,k1,k2,k3,k4
      double precision FIJ(NUW,NUW),FXY(NUW,NUW)
      double precision f11,f22,f12,fav,delt,sqdlt,fd,e1,e2,de
C
      do i=1,NUW
         do j=1,NUW
            FXY(j,i)=0d0
         enddo
      enddo
C
      do i=1,NUW-1
         do j=i+1,NUW
C           write(io,*) 'FIJ for i,j=',i,j
C           write(io,*) 'F(i,i)=',FIJ(i,i)
C           write(io,*) 'F(j,j)=',FIJ(j,j)
C           write(io,*) 'F(i,j)=',FIJ(i,j)
C           write(io,*) 'F(j,i)=',FIJ(j,i)
            f11=FIJ(i,i)
            f22=FIJ(j,j)
            f12=FIJ(i,j)
            fav= 0.5d0*(f11+f22)
            fd = f11-f22
            delt = fd*fd+4.0d0*f12*f12
            sqdlt =dsqrt(delt)
            e1 = (f11+f22-sqdlt)*0.5d0
            e2 = (f11+f22+sqdlt)*0.5d0
            if (f11.le.f22) then
               de = f11-e1
            else
               de = f22-e1
            endif
            de = dabs(de/fav)
C           write(io,*) e1,e2,de
            FXY(i,j) = de
            FXY(j,i) = de
C           write(io,*)
         enddo
      enddo
C
      if (io.gt.0) then
         write(io,*) '=== New FXY for the LMOs selection ==='
         call NJ_prtsym(io,NUW,FXY,'f12.5')
      endif
C
      end
C
C --- 2009.11.03 Calculate FXY from FIJ without divided by average Fock
      subroutine FIJ2XY2(io,NUW,FIJ,FXY)
      implicit none
      integer io,NUW,i,j,k,L,m,n,k1,k2,k3,k4
      double precision FIJ(NUW,NUW),FXY(NUW,NUW)
      double precision f11,f22,f12,fav,delt,sqdlt,fd,e1,e2,de
C
      do i=1,NUW
         do j=1,NUW
            FXY(j,i)=0d0
         enddo
      enddo
C
      do i=1,NUW-1
         do j=i+1,NUW
            f11=FIJ(i,i)
            f22=FIJ(j,j)
            f12=FIJ(i,j)
            fav= 0.5d0*(f11+f22)
            fd = f11-f22
            delt = fd*fd+4.0d0*f12*f12
            sqdlt =dsqrt(delt)
            e1 = (f11+f22-sqdlt)*0.5d0
            e2 = (f11+f22+sqdlt)*0.5d0
            if (f11.le.f22) then
               de = f11-e1
            else
               de = f22-e1
            endif
C
            FXY(i,j) = de
            FXY(j,i) = de
C           write(io,*)
         enddo
      enddo
C
      if (io.gt.0) then
         write(io,*) '=== New FXY2 for the LMOs selection ==='
         call NJ_prtsym(io,NUW,FXY,'f12.5')
      endif
C
      end
C
C*MODULE CIMI   *DECK MEMGMS
C>
C>  @brief   memory requirements
C>
C>  @details memory for closed shell MP2,CCSD,CCSD(T),CR-CCL
C>           OR open shell CCSD,CR-CC
C>
C>  @author  Wei Li?
C>
C --- Updated on 25 AUG 10 for MP2 memory
C     a new variable nbf (number of AOs) added
C --- Calculating required memory in words
C     RHF MP2,CCSD,CCSD(T),CR-CCL OR ROHF CCSD,CR-CCL
C
      integer function memgms(scftyp,mplevl,cctyp,nbf,no,nu,nc)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      integer ityp,no,nu,nc,nbf
      character scftyp*8,cctyp*8
      logical DIRSCF
      parameter (MXSH=5000, MXGTOT=20000, MXGSH=30, MXG2=MXGSH*MXGSH)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
C
      if (nc.eq.0) then
         ICIM=0
      else
         ICIM=2
      endif
      no2   = no*no
      nou   = no*nu
      nu2   = nu*nu
      no3   = no2*no
      no2u  = no2*nu
      nou2  = no*nu2
      nu3   = nu2*nu
      no4   = no3*no
      no3u  = no3*nu
      no2u2 = no2*nu2
      nou3  = no*nu3
      nu4   = nu3*nu
C
      NBF2 = (NBF*NBF+NBF)/2
      NBF3  = NBF*NBF
      NOC   = no
      NVIR  = nu
      NINTMX= 15000
      DIRSCF=.FALSE.
      NINTIC= 0
      NDIM  = MAX(NBF2,NVIR*NOC)
      LPASS = MIN(NOC,1000000/NBF2+1)
C
      if (scftyp.eq.'RHF     ') then
         NU3s  = NU*(NU+1)*(NU+2)/6  !-CIM-
      else if (scftyp.eq.'ROHF    ') then
         NU3s  = NU*NU*(NU+1)/2  !-CIM-
      end if
      NCU3s = NC*NU3s  !-CIM-
      KMICRO= 6
C
      LOADFM = 0
      if (scftyp.eq.'RHF     ' .and. mplevl.eq.2) then  ! RHF MP2
         IVEC   = 1    + LOADFM
         IPTR1  = IVEC + NBF*NBF
         IPTR2  = IPTR1+ NOC*NBF
         IENG   = IPTR2+ NVIR*NBF
         ILAB   = IENG + NBF
         IIRP   = ILAB + NBF
         IDEG   = IIRP + NBF
         LAST   = IDEG + NBF
         NEEDA  = LAST - LOADFM - 1

         MINTMX=NINTMX
         IF(NINTIC.NE.0) MINTMX=0
C
         CALL BASCHK(LMAX)
                       NANGM =  4
         IF(LMAX.EQ.2) NANGM =  6
         IF(LMAX.EQ.3) NANGM = 10
         IF(LMAX.EQ.4) NANGM = 15
         IF(LMAX.EQ.5) NANGM = 21
         IF(LMAX.EQ.6) NANGM = 28
         MAXG = NANGM**4
         NSH2 = (NSHELL*NSHELL+NSHELL)/2
C
         IF(DIRSCF) THEN
            LGHND  = 1      + LOADFM
            LXINTS = LGHND  + MAXG
            LDDIJ  = LXINTS + NSH2
            LXX    = LDDIJ  + 49*MXG2
            LIX    = LXX    + NINTMX
            LAST   = LIX    + NINTMX
         ELSE
            LGHND  = 1      + LOADFM
            LXINTS = LGHND
            LDDIJ  = LXINTS
            LXX    = LDDIJ
            LIX    = LXX    + MINTMX
            LAST   = LIX    + MINTMX
            IF(NINTIC.NE.0) THEN
               LXX  = LBUFPIC
               LIX  = LIXIC
            ENDIF
         END IF
         NEEDD = LAST - LOADFM - 1

         NEED  = 2*NBF3
         NMIN  = NDIM*NBF
         MNMEM = NEEDA + NEEDD + NEED + NMIN*1
         MXMEM = NEEDA + NEEDD + NEED + NMIN*NOC
C
C -------------------------
         LOADFM=0
         LWRK1 = 1     + LOADFM
         LWRK2 = LWRK1 + NBF3
         LPQRJ = LWRK2 + NBF3
         IF (ICIM.EQ.2) THEN
            LNOA  = LPQRJ + NDIM*NBF*LPASS  !-CIM- 25 FEB 10
            LNOB  = LNOA  + NOC             !-CIM- 25 FEB 10
            LTX   = LNOB  + NOC             !-CIM- 25 FEB 10
            LYO2  = LTX   + NOC*NOC         !-CIM- 25 FEB 10
            LYT2T = LYO2  + NOC             !-CIM- 25 FEB 10
            LYT2S = LYT2T + NOC             !-CIM- 25 FEB 10
            LAST  = LYT2S + NOC             !-CIM- 25 FEB 10
         ELSE
            LAST  = LPQRJ + NDIM*NBF*LPASS  !-CIM- 25 FEB 10
         ENDIF
         NEEDE = LAST - LOADFM - 1
         MEM   = NEEDA + NEEDD + NEEDE      ! ~= NBF*NBF2*LPASS
C
C -------------------------
C
         NEED = MEM
      elseif (scftyp.eq.'RHF     ' .and.
     &       (cctyp.eq.'CCSD    '.or.cctyp.eq.'CCD     ')) then  ! RHF CCSD/CCD
         LO1  = LOADFM + 1
         LT1  = LO1    + NOU
         LFH  = LT1    + NOU
         LFPH = LFH    + NO2
         LFP  = LFPH   + NOU
         LVHH = LFP    + NU2
         LVM  = LVHH   + NO4
         LTI  = LVM    + NO3U
         LO2  = LTI    + NU3
         LT2  = LO2    + NO2U2
         LVL  = LT2    + NO2U2
         LVR  = LVL    + NO2U2
         LVPP = LVR    + NO2U2
         IF (ICIM.EQ.2) THEN  !-CIM-
            LNO  = LVPP   + NOU3
            LK   = LNO    + NO   !-CIM-   ECIM(NO)
            LTX  = LK     + NO2  !-CIM-   EK(NO,NO)
            LYO2 = LTX    + NO2  !-CIM-   TX(NO,NO)  2009.08.06
            LYT2 = LYO2   + NO   !-CIM-   YO2(NO)    2009.08.06
            LAST = LYT2   + NO   !-CIM-   YT2(NO)    2009.08.06
         ELSE
            LAST = LVPP   + NOU3
         END IF
         NEED = LAST - LOADFM - 1
      else if (scftyp.eq.'RHF     ' .and. cctyp.eq.'CCSD(T) ') then  ! RHF CCSD(T)
         I1   = LOADFM + 1
         I2   = I1     + NOU
         I3   = I2     + NO2U2
         I4   = I3     + NO3U
         I5   = I4     + NOU3
         I6   = I5     + NU3
         I7   = I6     + NU3
         I8   = I7     + NO2U2
         LAST = I8     + NOU
         IF (ICIM.EQ.2) THEN  !-CIM-
            I9   = I8     + NOU
            I10  = I9     + NO      ! ECIM(NO)  -CIM-
            I11  = I10    + NO2     ! TX(NO,NO) -CIM-
            I12  = I11    + NU3*NC  ! XF3       -CIM-
            I13  = I12    + NU3*NC  ! XT3       -CIM-
            I14  = I13    + NU*NC   ! XO1       -CIM-
            LAST = I14    + NU*NC   ! XT1       -CIM-
         ELSE
            LAST = I8     + NOU
         END IF
         NEED = LAST - LOADFM - 1
      else if (scftyp.eq.'RHF     ' .and. cctyp.eq.'CR-CCL  ') then  ! RHF CR-CC(2,3)
C        memgms = (no+nu) + (2*no2+2*nu2+6*nou)+3*nu3+2*nou2+2*no2u
C        memgms =  memgms + 3*no3u+5*no2u2+3*nou3
C        if (nc.ne.0) memgms = memgms + no+no2+11*nu3*nc
         I1   = LOADFM + 1
         I2   = I1     + NOU
         I3   = I2     + NO2U2
         I4   = I3     + NO3U
         I5   = I4     + NOU3
         I7   = I5     + NU3
         I8   = I7     + NOU
         I9   = I8     + NO2U2
         I10  = I9     + NOU3
         I11  = I10    + NO3U
         I12  = I11    + NO2U2
         I13  = I12    + NU3
         I14  = I13    + NO
         I15  = I14    + NU
         I16  = I15    + 2*NU2
         I17  = I16    + 2*NO2
         I18  = I17    + 2*NOU
         I19  = I18    + 2*NOU2
         I20  = I19    + 2*NO2U
         I21  = I20    + NOU
         I22  = I21    + NO2U2
         I23  = I22    + NU3
         I24  = I23    + NOU3
         I26  = I24    + NO3U
         I27  = I26    + NOU
         IF (ICIM.EQ.2) THEN
            I29  = I27    + NO2U2    !-CIM-
            I30  = I29    + NO*2     !-CIM- ECIM  09 MAR 10 NO --> NO*2
            I31  = I30    + NO2      !-CIM- TX
            I32  = I31    + NU3*NC   !-CIM- XV3
            I33  = I32    + NCU3s*20 !-CIM- XBL
            LAST = I33    + NC       !-CIM- TXs
         ELSE
            LAST = I27    + NO2U2
         END IF
         NEED = LAST - LOADFM - 1
      else if (scftyp.eq.'ROHF    ' .and. cctyp.eq.'CCSD    ') then ! ROHF CCSD
C        memgms = 1*no4+1*no3u+9*no2u2+3*nou3 + 4*nou+2*no2+2*nu2+nu3
         I1   = LOADFM + 1
         I2   = I1     + NOU       ! O1AA
         I3   = I2     + NOU       ! T1
         I4   = I3     + NOU       ! O1BB
         I5   = I4     + NO4       ! VHHAA
         I6   = I5     + NO2U2     ! VHPLAA
         I7   = I6     + NO2U2     ! VHPLBB
         I8   = I7     + NO2U2     ! O2AA
         I9   = I8     + NO2U2     ! O2BB
         I10  = I9     + NO2U2     ! O2AB
         I11  = I10    + NOU3      ! VEAB
         I12  = I11    + NOU3      ! VEBA
         I13  = I12    + NO2U2     ! VHPRBB
         I14  = I13    + NO2U2     ! VHPRAA
         I15  = I14    + NO2U2     ! VHPRAB
         I16  = I15    + NOU3      ! TI
         I17  = I16    + NO3U      ! VMAA
         I18  = I17    + NOU       ! FHP
         I19  = I18    + NO2       ! FHHAA
         I20  = I19    + NO2       ! FHHBB
         I21  = I20    + NU2       ! FPPAA
         I22  = I21    + NU2       ! FPPBB
         I23  = I22    + NO2U2     ! T2
         I24  = I23    + NU3       ! VPP
         I25  = I24    + (KMICRO+1)**2  ! XMAT
         I26  = I25    + (KMICRO+1)     ! BVEC
         IF (ICIM.EQ.2) THEN
            I27  = I26    + (KMICRO+1)     ! IPVT
            I28  = I27    + NO       !-CIM- ECIMA
            I29  = I28    + NO       !-CIM- ECIMB
            I30  = I29    + NO2      !-CIM- TXA(NOA,NOA)
            I31  = I30    + NO2      !-CIM- TXB(NOB,NOB)
            I32  = I31    + NO2      !-CIM- EKA(NOA,NOA)
            LAST = I32    + NO2      !-CIM- EKB(NOB,NOB)
         ELSE
            LAST = I26    + (KMICRO+1)     ! IPVT
         END IF
         NEED=LAST-LOADFM-1
      else if (scftyp.eq.'ROHF    ' .and. cctyp.eq.'CR-CCL  ') then ! ROHF CR-CC(2,3)
C        memgms = 6*no3u+10*no2u2+6*nou3
C        memgms = memgms + 8*nou+3*nu3+5*no2+5*nu2+4*nou2+4*no2u+no4
C        if (nc.ne.0) memgms = memgms + no4+2*no+2*no2+2*nu3*nc
C        NEED = memgms
         I1  = LOADFM + 1
         I2   = I1     + NOU       ! O1AA
         I3   = I2     + NOU       ! O1BB
         I4   = I3     + NO2U2     ! L2AA
         I5   = I4     + NO2U2     ! L2BB
         I6   = I5     + NO2U2     ! L2AB
         I7   = I6     + NO2U2     ! O2
         I8   = I7     + NO2U2     ! O2AA
         I9   = I8     + NO2U2     ! O2BB
         I10  = I9     + NO2U2     ! O2AB
         I11  = I10    + NOU3      ! VEAA
         I12  = I11    + NOU3      ! VEBB
         I13  = I12    + NOU3      ! VEAB
         I14  = I13    + NOU3      ! VEBA
         I15  = I14    + NOU3      ! VEAB21
         I16  = I15    + NOU3      ! VEBA21
         I17  = I16    + NOU       ! FHPAA
         I18  = I17    + NOU       ! FHPBB
         I19  = I18    + NO2U2     ! VHPRAA
         I20  = I19    + NO2U2     ! VHPRBB
         I21  = I20    + NU3       ! M3
         I22  = I21    + NU3       ! L3
         I23  = I22    + NO2U2     ! VHPRAB
         I24  = I23    + NU3       ! TI
         I25  = I24    + NO3U      ! VMAB
         I26  = I25    + NO3U      ! VMBA
         I27  = I26    + NO3U      ! VMAA
         I28  = I27    + NO3U      ! VMBB
         I29  = I28    + NO3U      ! VMAB21
         I30  = I29    + NO3U      ! VMBA21
         I31  = I30    + NO2       ! FHHA
         I32  = I31    + NO2       ! FHHB
         I33  = I32    + NU2       ! FPPA
         I34  = I33    + NU2       ! FPPB
         I35  = I34    + NO2       ! X1AA
         I36  = I35    + NO2       ! X1BB
         I37  = I36    + NO2       ! X1AB
         I38  = I37    + NU2       ! X2AA
         I39  = I38    + NU2       ! X2BB
         I40  = I39    + NU2       ! X2AB
         I41  = I40    + NOU       ! X3AA
         I42  = I41    + NOU       ! X3BB
         I43  = I42    + NOU       ! X3AB
         I44  = I43    + NOU       ! X3BA
         I45  = I44    + NOU2      ! X4AAA
         I46  = I45    + NOU2      ! X4AAB
         I47  = I46    + NOU2      ! X4BBA
         I48  = I47    + NOU2      ! X4BBB
         I49  = I48    + NO2U      ! X5AAA
         I50  = I49    + NO2U      ! X5AAB
         I51  = I50    + NO2U      ! X5BBA
         I52  = I51    + NO2U      ! X5BBB
         IF (ICIM.EQ.2) THEN
            I53  = I52    + NO4       !-CIM- VHHHH
            I54  = I53    + NOC       !-CIM- ECIMA
            I55  = I54    + NOC       !-CIM- ECIMB
            I56  = I55    + NOC*NOC   !-CIM- TXA
            I57  = I56    + NOC*NOC   !-CIM- TXB
            I58  = I57    + NCU3s     !-CIM- XXM3
            I59  = I58    + NCU3s     !-CIM- XXL3
            LAST = I59    + NC        !-CIM- TXs
         ELSE
            LAST = I52    + NO4       ! VHHHH
         END IF
         NEED=LAST-LOADFM-1
      end if
C
      memgms = NEED
      return
C
      end
C
C
C --- Print help infomation of this MP2 program ---
      subroutine cimi_help(io)
      implicit none
      integer io,i,j

      write(io,9000)
      write(io,9011)
 9000 FORMAT(/3X,27(1H-)/
     *        3X,'CLUSTER-IN-MOLECULE PROGRAM'/3X,27(1H-)//
     *        3X,31(1H-)/
     *        3X,'W.LI, P.PIECUCH, J.R.GOUR, S.LI'/
     *        3X,31(1H-))
 9011 FORMAT(/1X,65(1H*)/
     *        1X,'THE FOLLOWING PAPERS SHOULD BE CITED WHEN USING'/
     *        1X,'CLUSTER-IN-MOLECULE OPTIONS:'//
     *        1X,'DUAL-ENVIRONMENT CIM (CIMTYP=DECIM)'/
     *        1X,'W. LI, P. PIECUCH, J.R. GOUR, AND S. LI,'/
     *        1X,'  J. CHEM. PHYS. 131, 114109-1 - 114109-30 (2009).'/
     *        1X,'[SEE, ALSO, S. LI, J. SHEN, W. LI, AND  Y. JIANG, J.'/
     *        1X,'  CHEM. PHYS. 125,  074109-1 - 074109-10 (2006)]'//
     *        1X,'SINGLE-ENVIRONMENT CIM (CIMTYP=SECIM,GSECIM)'/
     *        1X,'W. LI, P. PIECUCH, J.R. GOUR, AND S. LI,'/
     *        1X,'  J. CHEM. PHYS. 131, 114109-1 - 114109-30 (2009);'/
     *        1X,'W. LI AND P. PIECUCH, J. PHYS. CHEM. A',
     *        1X,'114, 8644-8657 (2010).'//
     *        1X,'IN ADDITION, THE USE OF MULTI-LEVEL CIM SHOULD',
     *        1X,'REFERENCE'/
     *        1X,'W. LI AND P. PIECUCH, J. PHYS. CHEM. A',
     *        1X,'114, 6721-6727 (2010).'/
     *        1X,65(1H*)/)
C
      if (io>0) return
C
      write(io,66)'-- USAGE --'
      write(io,66)' cimi [arguments] file'
C     write(io,66)'   file is GAMESS input file with addition inputs:'
C     write(io,66)'   1. Add ''ICIM=1'' in the $CONTRL group'
C     write(io,66)'   2. Define parameters (see PARAMETERS for details)'
C    &          //' in the line next to $DATA'
      write(io,66)
      write(io,66)'-- ARGUMENTS --'
      write(io,66)' -h or --help: Print Help (this message) and exit'
C     write(io,66)' -core: Include core obitals correlation energy'
C     write(io,66)
C     write(io,66)'-- PARAMETERS --:'
C     write(io,66)' Format: # [PARA=<value> ...]'
C     write(io,66)' Default: Zeta=(0.003,1.0) dis=4.0 iconv=6'
C    &         // ' motyp=1 mlk=0.15'
C     write(io,'(2x,62("-"))')
C     write(io,66)' Zeta=(z1,z2) --'
C     write(io,66)'  z1: Fock value for selecting environmental LMOs'
C     write(io,66)'     (For DECIM, z1 is for 1st environmental LMOs)'
C     write(io,66)'  z2: Fock value for 2nd environmental LMOs of DECIM'
C     write(io,66)'     (For SECIM, set z2>=1 or use Zeta=(z1) only)'
C     write(io,66)' dis: Distance for buffer atoms in extend subsystems'
C     write(io,66)' iconv: convergence for CC in subsystems(10^{-conv})'
C     write(io,66)' motyp=1 ext.MO: non-orth; subsys.MO: non-orth'
C     write(io,66)' motyp=2 ext.MO: orth; subsys.MO: non-orth'
C     write(io,66)' motyp=3 ext.MO: orth; subsys.MO: non-orth for unocc'
C     write(io,66)' motyp=4 ext.MO: orth; subsys.MO: orth'
C     write(io,66)' motyp=11 use orth ext.MOs within subsystems'
C     write(io,66)' mlk: Mulliken pop for ATOMs <--> MOs assignments'
C     write(io,66)' lmo: use LMOs for subsys calc. (Default: QCMO)'
C     write(io,66)' local: Boys localization in CIM (default in GAMESS)'
C     write(io,66)' domain=keep: no merge for small subsystems'
C     write(io,66)' maxno=k: limit the max Occ LMOs as k in subsystems'
C     write(io,66)' unsort: do not sort the LMOs (Default: sort)'
C     write(io,66)' rohf: use rohf for closed shell subsystems'
C     write(io,66)'   Default: use rhf for closed shell subsystems'
C     write(io,66)' molev: read MO levels from test.dat'
C     write(io,66)'   Default: def.ATOM levels in test.inp: X Y Z TYPE'
C     write(io,66)'   Available TYPE: mp2, ccsd, cr-ccl or cr-cc(2,3)'
C     write(io,66)' mlmerg: merge small High-L-sys into large Low-L-sys'
C     write(io,66)'   Default: keep small High-L-sys for saving time'
C     write(io,66)' readclu: read domain from .dmn file'
C     write(io,66)' readclu=2: read Occ domain from .dmn file'
C     write(io,66)' efock: use relative effective fock for environment'
C     write(io,66)' efock=2: use effective fock for environment'
C     write(io,'(2x,62("-"))')
      write(io,66)
      if (io==0) stop
 66   format(1x,a)
      end
C
c     if iau=0 in angstrom; else in a.u.
c
      subroutine DATAREAD(io,inp,NAT,IAN,C,NCBS,CBAS,iau)
      implicit none
      double precision ZERO
      parameter (ZERO=0.0D+00)
      integer io,inp,NAT,i,j,k,iau,nh
CMWS  integer elemord
      double precision C(3,NAT),x,y,z,zz
      character aa*2,elemsyl*2,line*100,aaa*10
      integer NCBS(NAT),IAN(NAT)
      character(len=100) CBAS(100,NAT)
      external elemsyl

      do i=1,NAT
C        do j=1,3
C        C(1,j) = ZERO
C        enddo
C        ZAN = ZERO
         do j=1,100
            CBAS=' '
         enddo
      enddo

      rewind(inp)
      i=0; nh=0
      do
         read(inp,'(a)',end=999) line
         read(line,*,err=100,end=100) aaa,zz,x,y,z
c        k=ichar(aa(1:1))
c        if (k<65.or.(k>90.and.k<97).or.k>122) cycle
c        k=ichar(aa(2:2))
c        if (k.ne.32.and.(k<65.or.(k>90.and.k<97).or.k>122)) cycle
c        if (elemord(aa).eq.0) cycle
c        if (aa=='H'.or.aa=='h') nh=nh+1
         i=i+1
         if (IAN(i).eq.1) nh=nh+1
c        ZAN(i)=zz
c        C(1,i)=x
c        C(2,i)=y
c        C(3,i)=z
C
C ---    FOR READING BASIS FOR EACH ATOMS
         j=0
         do
            read(inp,'(a)',end=999) line
            if (line.eq.'        ') goto 99
            j=j+1
            CBAS(j,i)=line
         enddo
C
  99     NCBS(i)=j
         if (i>=NAT) exit
 100     continue
      enddo


 500  if (io>0) then
         if (iau==0) then
            write(io,*) 'Table: Cartesian Coordinates in angstrom'
         else
            write(io,*) 'Table: Cartesian Coordinates in a.u.'
         endif
         write(io,'(1x,54(''=''))')
         write(io,*) ' Atom           X               Y               Z'
         write(io,'(1x,54(''-''))')
         do i=1,NAT
            write(io,'(2x,a2,2x,3f16.8)') elemsyl(IAN(i)),
     &        (C(j,i),j=1,3)
C           do j=1,NCBS(i)
C              write(io,'(a)') trim(CBAS(j,i))
C           enddo
C           write(io,'(a8)') '        '
         enddo
         write(io,'(1x,54(''=''))')
         write(io,'(''  N<atoms> (all, non-H and H) are'',3i6)')
     &        NAT,NAT-nh,nh
         write(io,*)
      endif
!     write(77,*)
      return

 999  stop 'GMSXYZ2(): Not enough coordinates in files'
      end
C
C --- Read integer value from name = value in line ---
      subroutine IVALU(line,name,value)
      implicit none
      character line*(*),name*(*),ch
      integer value
      integer i,k,L,k1,k2,L1,L2
C
      L=index(line,name)
      L1=len(line)
      L2=len(name)
      if (L.eq.0) return
      ch=line(L-1:L-1)
      if (L.gt.1 .and. ch.ne.' ') return
      ch=line(L+L2:L+L2)
      if (ch.ne.' ' .and. ch.ne.'=') return
C
      k=index(line(L:L1),'=')+L
      do i=k,L1
         if (line(i:i).ne.' ') then
            k1=i
            exit
         endif
      enddo
C
      do i=k1,L1
         if (line(i:i).eq.' ') then
            k2=i-1
            exit
         endif
      enddo
C
      read(line(k1:k2),*) value
      end
C*MODULE CIMI    *DECK RVALU
c>
C>    @brief   scan floating point value
C>
C>    @details scan floating point value,
C>             used during CIM grand totalling process.
C>
C>    @param LINE     a line from CIM log file (input)
C>    @param NAME     string labeling the value (input)
c>    @param VALUE    fl. point value after the string (output)
C>
      subroutine RVALU(line,name,value)
      implicit none
      character line*(*),name*(*),ch
      double precision value
      integer i,k,L,k1,k2,L1,L2
      logical ok
C
C --- Read read(kind=8) value from name = value in line ---
C
      L=index(line,name)
      L1=len(line)
      L2=len(name)
      if (L.eq.0) return
      ch=line(L-1:L-1)
      if (L.gt.1 .and. ch.ne.' ') return
      ch=line(L+L2:L+L2)
      if (ch.ne.' ' .and. ch.ne.'=') return
C
      k=index(line(L:L1),'=')+L
      do i=k,L1
         if (line(i:i).ne.' ') then
            k1=i
            exit
         endif
      enddo
C
      do i=k1,L1
         if (line(i:i).eq.' ') then
            k2=i-1
            exit
         endif
      enddo
C
      read(line(k1:k2),*,err=800) value
      return
c
c         In case the time field is full of ****'s,
c         we can just return a very large time.
c         Any other instance of an error should still crash.
c
  800 continue
      ok=.false.
      if(name(1:21).eq.'STEP CPU TIME FOR MP2')        ok=.true.
      if(name(1:26).eq.'STEP CPU TIME FOR EOM-CCSD')   ok=.true.
      if(name(1:21).eq.'STEP CPU TIME FOR CCD')        ok=.true.
      if(name(1:22).eq.'STEP CPU TIME FOR CCSD')       ok=.true.
      if(name(1:25).eq.'STEP CPU TIME FOR CCSD(T)')    ok=.true.
      if(name(1:28).eq.'TOTAL CPU TIME FOR SUBSYSTEM') ok=.true.
      if(ok) then
         value=99999.9d+00
         return
      else
         write(6,8000) line,name
         call abrt
         stop
      end if
 8000 format(1x,'Unable to extract value from CIM log file.'/
     *       1x,'Trouble reading line containing:'/
     *       5x,'"',a,'"'/
     *       1x,'while looking for value after this string:'/
     *       5x,'"',a,'"')
      end

C --- Read character(len=8) value from name = value in line ---
      subroutine CVALU(line,name,value)
      implicit none
      character line*(*),name*(*),ch
      character(len=8) value
      integer i,k,L,k1,k2,L1,L2
C
      L=index(line,name)
      L1=len(line)
      L2=len(name)
      if (L.eq.0) return
      ch=line(L-1:L-1)
      if (L.gt.1 .and. ch.ne.' ') return
      ch=line(L+L2:L+L2)
      if (ch.ne.' ' .and. ch.ne.'=') return
C
      k=index(line(L:L1),'=')+L
      do i=k,L1
         if (line(i:i).ne.' ') then
            k1=i
            exit
         endif
      enddo
C
      do i=k1,L1
         if (line(i:i).eq.' ') then
            k2=i-1
            exit
         endif
      enddo
C
      read(line(k1:k2),*) value
      end

C --- Read logical value from name = value in line ---
      subroutine LVALU(line,name,value)
      implicit none
      character line*(*),name*(*),ch
      logical value
      integer i,k,L,k1,k2,L1,L2
C
      L=index(line,name)
      L1=len(line)
      L2=len(name)
      if (L.eq.0) return
      ch=line(L-1:L-1)
      if (L.gt.1 .and. ch.ne.' ') return
      ch=line(L+L2:L+L2)
      if (ch.ne.' ' .and. ch.ne.'=') return
C
      k=index(line(L:L1),'=')+L
      do i=k,L1
         if (line(i:i).ne.' ') then
            k1=i
            exit
         endif
      enddo
C
      do i=k1,L1
         if (line(i:i).eq.' ') then
            k2=i-1
            exit
         endif
      enddo
C
      read(line(k1:k2),*) value
      end
C
C --- 19 AUG 10 --- READING INFORMATION FROM .CIM FILE
      SUBROUTINE CIMREAD(io,inp,GROUP,IWORK,RWORK,CWORK,LWORK)
      implicit none
      integer io,inp,i,j,k,L,m,n
      integer IWORK(100)
      double precision RWORK(100)
      character(len=8) CWORK(100),GROUP
      logical(kind=8) LWORK(100)
      character(len=200) line
C
      do
         read(inp,'(a)',end=100,err=100) line
         call NJ_upper(line)
         L=index(line,'$'//trim(GROUP))
         if (L.ne.0) goto 100
      enddo
 100  continue
      do
         read(inp,'(a)',end=200,err=200) line
         call NJ_upper(line)
         L=index(line,'$END')
         if (L.ne.0) goto 200
C
         if (GROUP.EQ.'CIMINP  ') then
            call RVALU(line, 'ZETA1',   RWORK(1))
            call RVALU(line, 'ZETA2',   RWORK(2))
            call RVALU(line, 'ZETA',    RWORK(3))
            call RVALU(line, 'ETA',     RWORK(4))
            call RVALU(line, 'BUFDST',  RWORK(5))
            call RVALU(line, 'CCONV',   RWORK(6))
            call RVALU(line, 'ATMMLK',  RWORK(7))
C
            call IVALU(line, 'MOFIX',  IWORK(7))
            call IVALU(line, 'MRGSUB',  IWORK(15))
            if (IWORK(15).eq.0) then
               LWORK(1) = .false.
               LWORK(2) = .false.
            elseif (IWORK(15).eq.1) then
               LWORK(1) = .true.
               LWORK(2) = .false.
            elseif (IWORK(15).eq.2) then
               LWORK(1) = .true.
               LWORK(2) = .true.
            endif
C           call LVALU(line, 'SUBMRG',  LWORK(1))
C           call LVALU(line, 'MERGML',  LWORK(2))
            call LVALU(line, 'MOSORT',  LWORK(3))
            call LVALU(line, 'ORTHO',   LWORK(4))
            call LVALU(line, 'SUBRHF',  LWORK(5))
            call LVALU(line, 'FCORE ',  LWORK(6))
C
            call CVALU(line, 'CIMTYP',  CWORK(1))
            call CVALU(line, 'SUBMTD',  CWORK(2))
            call CVALU(line, 'SUBTYP',  CWORK(3))
            call CVALU(line, 'ENRGML',  CWORK(4))
         else if (GROUP.EQ.'INFO    ') then
            call IVALU(line, 'NAT',     IWORK(51))
            call IVALU(line, 'ICH',     IWORK(52))
            call IVALU(line, 'MUL',     IWORK(53))
            call IVALU(line, 'NE',      IWORK(54))
            call IVALU(line, 'NA',      IWORK(55))
            call IVALU(line, 'NB',      IWORK(56))
            call IVALU(line, 'NUM',     IWORK(57))
            call IVALU(line, 'NMO',     IWORK(58))
            call IVALU(line, 'NSHELL',  IWORK(59))
            call IVALU(line, 'NGAUSS',  IWORK(60))
C
            call RVALU(line, 'ENUCR',   RWORK(51))
            call IVALU(line, 'ISPHER',  IWORK(61))
         else if (GROUP.EQ.'ENERGY  ') then
            call RVALU(line, 'E(RHF)',  RWORK(52))
            call RVALU(line, 'E(UHF)',  RWORK(52))
            call RVALU(line, 'E(ROHF)', RWORK(52))
            if (index(line,'RHF') .ne.0) CWORK(51)='RHF     '
            if (index(line,'UHF') .ne.0) CWORK(51)='UHF     '
            if (index(line,'ROHF').ne.0) CWORK(51)='ROHF    '
         endif
C
      enddo
 200  continue
C
      return
      end

C
C-WL- 2007.10.23 define parameters from XWORK (X=I,R,C,L)
      subroutine GMSPAR2(io,nwords,scftyp,mplevl,cctyp,
     &           IWORK,RWORK,CWORK,LWORK)
      implicit double precision(A-H,O-Z)
      character line*200,scftyp*8,cctyp*8,dirtyp*8
      logical dirscf
      character kgms*4,key3*3,key4*4,key5*5,key6*6
C
      integer IWORK(100)
      double precision RWORK(100)
      character(len=8) CWORK(100)
      logical(kind=8) LWORK(100)
C
C-WL- define default Memory
      mwords=50
      nwords=mwords*1024*1024   ! 2010.06.07 1000*1000 --> 1024*1024 by Wei Li
C
      if (CWORK(2).eq.'NONE    ') then
         mplevl = 0
         cctyp  = 'NONE    '
      elseif (CWORK(2).eq.'MP2     ') then
         mplevl = 2
         cctyp  = 'NONE    '
      else
         mplevl = 0
         cctyp  = CWORK(2)
      endif

C
C-WL- Read Zeta and dis
C     if (CWORK(1).eq.'DECIM  ') then
C        WRK(1) = RWORK(1)  ! ZETA1
C        WRK(2) = RWORK(2)  ! ZETA2
C     else
C        WRK(1) = RWORK(3)  ! ZETA
C        WRK(2) = 2.00d0
C     endif
      RWORK(8) = 0.99D+00 ! Only available for DECIM; former as WRK(3), not used now
C     WRK(4) = RWORK(4)  ! ETA
C     WRK(5) = RWORK(5)  ! BUFDST
C

      IWORK(1)=-LOG10(RWORK(6))  ! RWORK(6): cconv in $ciminp; IWORK(1): iconv in $ccinp
C

      if (LWORK(4)) then ! LWORK(4)=ORTHO
         IWORK(2) = 4  ! We lose IWORK(2)=2,3,11, which we do not use usually. So that is fine
      else
         IWORK(2) = 1
      endif
      IWORK(3) = 5    ! useless
      IWORK(4) = 1000 ! maxno
      if (LWORK(3)) then  ! MOSORT
         IWORK(5) = 0 ! sort
      else
         IWORK(5) = 1 ! unsort
      endif
      IWORK(6) = 0 ! ISymm 1 for symmetry
C     WRK(7) = RWORK(7) ! ATMMLK
      RWORK(9) = 1.0d-6   ! symm 2008.03.03 for threshold of symmetry WRK(9)
C     IWORK(7) = 0  ! 1 for reading clusters; 2 for reading occ MOs in clusters only
      if (CWORK(3).eq.'QCMO    ') then ! SUBTYP
         IWORK(8) = 0
      else
         IWORK(8) = 1  ! LMO
      endif
      IWORK(9) = 0  ! MOLEV 1 for reading MO Level from .cim (former .dat)
C     SUBMRG=LWORK(1); MERGML=LWORK(2)
      if (IWORK(15).eq.1) then ! (LWORK(1) .and. .not.LWORK(2)) then
         IWORK(10) = 0 ! MLMERG=F
         IWORK(13) = 0 ! DOMAIN NOT KEPT
      elseif (IWORK(15).eq.2) then ! (LWORK(1) .and. LWORK(2)) then
         IWORK(10) = 1 ! MLMERG
         IWORK(13) = 0 ! DOMAIN NOT KEPT
      elseif (IWORK(15).eq.0) then ! (.not.LWORK(1) .and. .not.LWORK(2)) then
         IWORK(10) = 0 ! MLMERG=F
         IWORK(13) = 1 ! DOMAIN=KEEP
      endif
      IWORK(11)=1  ! LOCAL: always use boys localization in cimi
      IWORK(12)=0  ! EFOCK: 1 or 2 for  using effective Fock to select LMOs
      if (LWORK(5)) then  ! SUBRHF
         IWORK(14) = 0
      else
         IWORK(14) = 1  ! ROHF for closed subsystems in ROHF calculations
      endif
C
C-WL- Output
      if (io.gt.0) then
         write(io,110) mwords
         write(io,120) scftyp,mplevl,cctyp,dirscf
         write(io,130) (RWORK(k),k=1,4)
         write(io,140) RWORK(5),IWORK(1),IWORK(2),RWORK(9)
         write(io,160) IWORK(4)
         if (IWORK(2).eq.1) then
            write(io,*) 'EXT. MO: non-orth; SUBSYS. MO: non-orth'
         else if (IWORK(2).eq.2) then
            write(io,*) 'EXT. MO: orth; SUBSYS. MO: non-orth'
         else if (IWORK(2).eq.3) then
            write(io,*)'EXT. MO: orth; SUBSYS. MO: non-orth unocc (302)'
         else if (IWORK(2).eq.4) then
            write(io,*) 'EXT. MO: orth; SUBSYS. MO: orth (322)'
         else if (IWORK(2).eq.5) then
            write(io,*) 'EXT. MO: orth; SUBSYS. MO: orth (111)'
         else if (IWORK(2).eq.6) then
            write(io,*) 'EXT. MO: orth; SUBSYS. MO: orth (112)'
         else if (IWORK(2).eq.11) then
            write(io,*) 'Use orth EXT. MOs within subsystems'
         else if (IWORK(2).eq.12) then
            write(io,*) 'Use un-orth EXT. MOs within subsystems'
         else
            write(io,*) 'ERR: motyp=1-6,11 are available!'
            stop
         endif
         if (IWORK(7).ne.0) then
            write(io,*)'Using fix domain method:'
     &               //' read occupied LMOs from .dmn file'
            if (IWORK(7).eq.1) then
               write(io,*)'Recalculate the number of unoccupied LMOs'
            else
               write(io,*)'Read the number of unoccupied LMOs from .dmn'
            endif
         endif
         if (IWORK(5).eq.0) write(io,*)'--- Sort LMOs ---'
         if (IWORK(6).ne.0) write(io,*)'--- Use MO symmetry ---'
         if (IWORK(8).eq.0) then
            write(io,*) '--- Use QCMO in subsystems ---'
         else
            write(io,*) '--- Use LMO in subsystems ---'
C           if (cctyp.ne.'CCSD    ') then
C              write(io,*) 'LMO based CIM is only available for CCSD'
C              stop
C           endif
         endif
         if (IWORK(9).ne.0) then
            write(io,*) '--- Read MO-LEVEL from .dat ---'
         endif
         if (IWORK(10).ne.0) then
            write(io,'(1x,a)') '--- Merge small High-L-sys into'
     &                //' large Low-L-sys ---'
         endif
         if (IWORK(11).ne.0) then
            write(io,'(1x,a)') '--- Use localization in CIM program ---'
         endif
         if (IWORK(12).ne.0) then
           write(io,'(1x,a)')'--- Use effective Fock to select LMOs ---'
         endif
C        write(io,*) 'The Mulliken population threshold:',RWORK(7)
         write(io,*) 'Group the MOs near each atoms as central MOs '
     &             //'by Mulliken pop >',RWORK(7)
         write(io,*) RWORK(7),' is used for selecting atoms for LMOs'
      endif
C
 110  format(1x,'Defined memory =',i6,' Mega words')
 120  format(1x,'SCFTYP,MPLEVL,CCTYP,DIRSCF = ',A8,i2,3x,A8,3x,L8)
 130  format(1x,'ZT1,ZT2,ZT3,ZT4=',4f10.5)
 140  format(1x,'DIS=',f10.5,6x,'CC Conv=',i4,6x,'MOTYP=',i2,6x,
     &      'SYMM=',d12.4)
 150  format(1x,'MAXFRG=',i5)
 160  format(1x,'The max number of correlated occ MOs are set as',i5)
      end
c
C*MODULE CIMI  *DECK VCCLR
      SUBROUTINE VCCLR(CA,INCA,N)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      CHARACTER*8 CA(*)
C
C     ----- ZERO OUT AN INTEGER VECTOR -A-, USING INCREMENT -INCA- -----
C
      IF (INCA .NE. 1) GO TO 200
      DO 110 L=1,N
         CA(L) = '        '
  110 CONTINUE
      RETURN
C
  200 CONTINUE
      LA=1-INCA
      DO 210 L=1,N
         LA=LA+INCA
         CA(LA) = '        '
  210 CONTINUE
      RETURN
      END
C
CMWSC*MODULE CIMI  *DECK VCASGN
CMWS      SUBROUTINE VCASGN(CA,INCA,N,VALU)
CMWS      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
CMWSC
CMWS      CHARACTER*8 CA(*),VALU
CMWSC
CMWSC     ----- ZERO OUT AN INTEGER VECTOR -A-, USING INCREMENT -INCA- -----
CMWSC
CMWS      IF (INCA .NE. 1) GO TO 200
CMWS      DO 110 L=1,N
CMWS         CA(L) = VALU
CMWS  110 CONTINUE
CMWS      RETURN
CMWSC
CMWS  200 CONTINUE
CMWS      LA=1-INCA
CMWS      DO 210 L=1,N
CMWS         LA=LA+INCA
CMWS         CA(LA) = VALU
CMWS  210 CONTINUE
CMWS      RETURN
CMWS      END
C*MODULE CIMI  *DECK TIMSTP
      SUBROUTINE TIMSTP(METHOD)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      CHARACTER*8 METHOD
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /TMVALS/ TI,TX,TIM
C     COMMON /TIMING/ CPU,WALL
      COMMON /CIMINF/ ICIM,ICIF,MOTYP,NCA,NCB  !-CIM-
C
      TXMIN = TX !/60.0D+00
      IF(MASWRK) THEN
         IF(GOPARR) THEN
            WRITE(ICIF,9010) ME,METHOD,TXMIN
         ELSE
            WRITE(ICIF,9000) METHOD,TXMIN
         END IF
      END IF
      CALL FLSHBF(ICIF)
      RETURN
C
 9000 FORMAT(1X,'STEP CPU TIME FOR ',A8,' =',F9.2,' SEC')
 9010 FORMAT(1X,'CPU',I6,': STEP CPU TIME FOR ',A8,' =',F9.2,' SEC')
      END
C*MODULE CIMI  *DECK TIMCIM
      SUBROUTINE TIMCIM(T0,NOTES)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      CHARACTER*12 NOTES
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /CIMINF/ ICIM,ICIF,MOTYP,NCA,NCB  !-CIM-
C
      CALL TSECND(TT)
      TY = TT - T0
      TYMIN = TY !/60.0D+00
      IF(MASWRK) THEN
         IF(GOPARR) THEN
            WRITE(ICIF,9010) ME,NOTES,TYMIN
         ELSE
            WRITE(ICIF,9000) NOTES,TYMIN
         END IF
      END IF
      CALL FLSHBF(ICIF)
      RETURN
C
 9000 FORMAT(1X,'TOTAL CPU TIME FOR ',A12,' =',F9.2,' SEC')
 9010 FORMAT(1X,'CPU',I6,': TOTAL CPU TIME FOR ',A12,' =',F9.2,' SEC')
      END
