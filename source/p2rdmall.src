!> @brief This module contains the data structures used in the optimization of the T1/T2 parameters
      Module TypeMod
      Implicit None

!> @brief two dimensional array of reals, used by type (sym)
      type :: inner
           real(8), allocatable, dimension(:,:) :: n
      end type inner

!> @brief two dimensional array of type (inner)
      type :: sym
           type(inner), allocatable, dimension(:,:) :: nsym
      end type sym

!> @brief two dimensional array of type (sym)
      type :: outer
           type(sym), allocatable, dimension(:,:) :: m
      end type outer

!> @brief two Data storage for T2 parameters
      type :: T2
           type(outer) :: aa
           type(outer) :: ab
           type(outer) :: bb
      end type T2

!> @brief 1 dimensional array of type real
      type :: virtorb
           real(8), allocatable, dimension(:) :: v
      end type virtorb

!> @brief one dimensional array of type (virtorb)
      type :: symsingles
           type(virtorb), allocatable, dimension(:) :: vsym
      end type symsingles

!> @brief one dimensional array of type (symsingles)
      type :: occorb
           type(symsingles), allocatable, dimension(:) :: o
      end type occorb

!> @brief Data storage for T1 parameters
      type :: T1
           type(occorb) :: a
           type(occorb) :: b
      end type T1

!> @brief two dimensional array of type real
       type :: blocks
            real(8), allocatable, dimension(:,:) :: block
       end type

!> @brief one dimensional array of type blocks
        type :: irreps
             type(blocks), allocatable, dimension(:) :: irrep
        end type

!> @brief Data storage for K2 matrix
        type :: spin
             type(irreps) :: aa
             type(irreps) :: ab
             type(irreps) :: bb
        end type spin


!> @brief two dimensional array for holding reshaped matrices
       type :: ReshapedMat
            real(8), allocatable, dimension(:,:) :: ReshapedMatrix
       end type

!> @brief row and column index (integer) for storage of reshaped matrices
       type dim
             integer :: row
             integer :: col
       end type dim

!> @brief Data storage for dimensions of reshapes matrices
       type ReshapedDim
            type(dim), allocatable, dimension(:) :: ijaa
            type(dim), allocatable, dimension(:) :: ijab
            type(dim), allocatable, dimension(:) :: ajaa
            type(dim), allocatable, dimension(:) :: ajab
            type(dim), allocatable, dimension(:) :: ajba
            type(dim), allocatable, dimension(:) :: abij_aaaa
            type(dim), allocatable, dimension(:) :: abij_abab
            type(dim), allocatable, dimension(:) :: a
            type(dim), allocatable, dimension(:) :: i
            type(dim), allocatable, dimension(:) :: ajaa_only
            type(dim), allocatable, dimension(:) :: ajab_only
            type(dim), allocatable, dimension(:) :: jka_aaa
            type(dim), allocatable, dimension(:) :: bci_aaa
            type(dim), allocatable, dimension(:) :: jka_abb
            type(dim), allocatable, dimension(:) :: jka_aba
            type(dim), allocatable, dimension(:) :: bci_aba
            type(dim), allocatable, dimension(:) :: bci_abb
            type(dim), allocatable, dimension(:) :: ajaa_t1
            type(dim), allocatable, dimension(:) :: ijbb
            type(dim), allocatable, dimension(:) :: ajbb
            type(dim), allocatable, dimension(:) :: a_alpha
            type(dim), allocatable, dimension(:) :: a_beta
            type(dim), allocatable, dimension(:) :: i_alpha
            type(dim), allocatable, dimension(:) :: i_beta
            type(dim), allocatable, dimension(:) :: jka_bbb
            type(dim), allocatable, dimension(:) :: bci_bbb
            type(dim), allocatable, dimension(:) :: ajbb_t1
            type(dim), allocatable, dimension(:) :: ajbb_only
       end type

!> @brief Stores the pairs of irreducible representations that multiply to a given product
      type symmetry
         integer, allocatable, dimension(:) :: upper
         integer, allocatable, dimension(:) :: lower
      end type symmetry

!> @brief Stores the inverse basis for D1 or D2
      type InverseBasis
        integer, allocatable, dimension(:,:) :: basis
      end type

!> @brief Data storage structure for the D1 matrix
      type D1
        double precision, allocatable, dimension(:,:) :: D1block
      end type


!> @brief Data storage structure for the D2 matrix
       type D2
         type(irreps) :: aa
         type(irreps) :: ab
         type(irreps) :: bb
       end type


!> @brief one dimensional array of type (dim)
        type blockdimension
          type(dim), allocatable, dimension(:) :: block
        end type

!> @brief one dimensional array of type (blockdimension)
        type symgparray
          type(blockdimension), allocatable, dimension(:) :: symgp
        end type

!> @brief stores block dimensions for K2 matrix block multiplication
        type BlockMatMulDims
          type(symgparray) :: aa
          type(symgparray) :: ab
          type(symgparray) :: bb
          type(symgparray) :: ba
       end type

!> @brief Data structure for mapping two indices to a row/col in matrix
       type BasisMap2
         integer, allocatable, dimension(:,:) :: basis
       end type

!> @brief Data structure for mapping three indices to a row/col in matrix
       type BasisMap3
         integer, allocatable, dimension(:,:) :: basis
       end type

!> @brief Data structure for mapping one index to a row/col in matrix
       type BasisMap1
         integer, allocatable, dimension(:,:) :: basis
       end type

!> @brief index to row/col for two indices
       type InverseBasis2
         integer, allocatable, dimension(:,:) :: ib
       end type

!> @brief index to row/col for one index
       type InverseBasis1
         integer, allocatable, dimension(:) :: ib
       end type

      end Module


       Module TimeMod
!> @brief This module contains the variables that store timing data for selected subroutines.
       Implicit None
       real :: time_ijaa,time_ijaa_inverse,time_ajaa, time_ajaa_inverse
       real :: time_ijab,time_ijab_inverse,time_ajab, time_ajab_inverse
       real :: time_ajba, time_ajba_inverse, time_i,time_i_inverse
       real :: time_a, time_a_inverse
       real :: time_ajaa_transpose, time_ajaa_transpose_inverse
       real :: time_ajbb, time_ajbb_inverse
       real :: time_t1_i, time_t1_ibrow, time_jka_aaa, time_bci_aaa, time_jka_abb
       real :: time_jka_aba, time_bci_aba, time_bci_abb, time_t1_b
       real :: time_jka_aaa_inverse, time_t1_b_inverse, time_bci_aaa_inverse
       real :: time_t1_i_inverse, time_jka_abb_inverse, time_jka_aba_inverse
       real :: time_bci_aba_inverse, time_bci_abb_inverse, time_t1t1_i, time_t1t1_i_inverse
       real :: time_t1t1_b, time_t1t1_b_inverse, time_ajaa_t1, time_ajaa_t1_inverse
       real :: time_t1_ibcol_alphaonly, time_t1_ibcol_alphaonly_inverse
       real :: time_t1_ibrow_alphaonly,time_t1_ibrow_alphaonly_inverse
       real :: time_t1_ibrow_inverse

       real :: ij_aa_mm, ab_aa_mm, aj_aa_mm, ij_ab_mm, ab_ab_mm, aj_ab_mm
       real :: aj_ba_mm, i_mm, a_mm, abij_aaaa_mm, abij_abab_mm, aijb_ab_mm
       real :: a_twobody_mm, i_twobody_mm, aj_bb_mm, aj_aa_transpose_mm
       real :: time_mm
       real :: time_transpose

       real :: time_readgamess, time_calcparameters, time_irreptoint, time_makeproducttable
       real :: time_datastructure, time_calcreshapedim, time_buildk2k1, time_avederiv, time_calcenergy
       real :: time_calcderiv, time_calcparametersinverse
       real :: time_topfactor
       real :: time_readinput, time_writegamess, time_singlepoint, time_buildd1
       real :: time_bfgs, time_powell, time_mydsymm, time_calchess
       double precision :: time_total
       real :: time_mydsymm_col, time_mydsymm_matmul, time_matmul3
       contains
           subroutine Time_initialize()
              time_ijaa = 0.0
              time_ijaa_inverse = 0.0
              time_ajaa = 0.0
              time_ajaa_inverse = 0.0
              time_ijab = 0.0
              time_ijab_inverse = 0.0
              time_ajab = 0.0
              time_ajab_inverse = 0.0
              time_ajba = 0.0
              time_ajba_inverse = 0.0
              time_a = 0.0
              time_a_inverse = 0.0
              time_i = 0.0
              time_i_inverse = 0.0
              time_ajaa_transpose = 0.0
              time_ajaa_transpose_inverse = 0.0
              time_ajbb = 0.0
              time_ajbb_inverse = 0.0
              time_t1_ibrow = 0.0
              time_jka_aaa = 0.0
              time_bci_aaa = 0.0
              time_jka_abb = 0.0
              time_jka_aba = 0.0
              time_bci_aba = 0.0
              time_bci_abb = 0.0
              time_t1_b    = 0.0
              time_jka_aaa_inverse = 0.0
              time_t1_b_inverse = 0.0
              time_bci_aaa_inverse = 0.0
              time_t1_i = 0.0
              time_t1_i_inverse = 0.0
              time_jka_abb_inverse = 0.0
              time_jka_aba_inverse = 0.0
              time_bci_aba_inverse = 0.0
              time_bci_abb_inverse = 0.0
              time_t1t1_i = 0.0
              time_t1t1_i_inverse = 0.0
              time_t1t1_b = 0.0
              time_t1t1_b_inverse = 0.0
              time_ajaa_t1 = 0.0
              time_ajaa_t1_inverse = 0.0
              time_t1_ibcol_alphaonly = 0.0
              time_t1_ibcol_alphaonly_inverse = 0.0
              time_t1_ibrow_alphaonly = 0.0
              time_t1_ibrow_alphaonly_inverse = 0.0
              time_t1_ibrow_inverse = 0.0

              ij_aa_mm = 0.0
              ab_aa_mm = 0.0
              aj_aa_mm = 0.0
              ij_ab_mm = 0.0
              ab_ab_mm = 0.0
              aj_ab_mm = 0.0
              aj_ba_mm = 0.0
              i_mm = 0.0
              a_mm = 0.0
              abij_aaaa_mm = 0.0
              abij_abab_mm = 0.0
              aijb_ab_mm = 0.0
              a_twobody_mm = 0.0
              i_twobody_mm = 0.0
              aj_bb_mm = 0.0
              aj_aa_transpose_mm = 0.0

              time_readgamess          = 0.0
              time_calcparameters    = 0.0
              time_irreptoint        = 0.0
              time_makeproducttable  = 0.0
              time_datastructure    = 0.0
              time_calcreshapedim  = 0.0
              time_buildk2k1       = 0.0
              time_avederiv       = 0.0
              time_calcenergy     = 0.0
              time_calcderiv      = 0.0
              time_mm = 0.0
              time_calcparametersinverse = 0.0
              time_topfactor = 0.0
              time_readinput = 0.0
              time_writegamess = 0.0
              time_singlepoint = 0.0
              time_buildd1 = 0.0
              time_bfgs = 0.0
              time_powell = 0.0
              time_mydsymm = 0.0
              time_calchess = 0.0
              time_matmul3 = 0.0
              time_transpose = 0.0

              time_mydsymm_col = 0.0
              time_mydsymm_matmul = 0.0
           end subroutine

         subroutine PrintTime()
            real :: total_reshape_time
            real :: total_mm_time




            total_reshape_time = time_ijaa + time_ijaa_inverse + time_ajaa
            total_reshape_time = total_reshape_time + time_ajaa_inverse + time_ijab + time_ijab_inverse
            total_reshape_time = total_reshape_time + time_ajab + time_ajab_inverse + time_ajba + time_ajba_inverse
            total_reshape_time = total_reshape_time + time_a + time_a_inverse + time_i +time_i_inverse + time_ajaa_transpose
            total_reshape_time = total_reshape_time + time_ajaa_transpose_inverse + time_ajbb + time_ajbb_inverse
            total_reshape_time = total_reshape_time +time_ajbb_inverse +time_t1_ibrow + time_jka_aaa + time_bci_aaa
            total_reshape_time = total_reshape_time + time_jka_abb +time_jka_aba +time_bci_aba +time_bci_abb +time_t1_b
            total_reshape_time = total_reshape_time + time_jka_aaa_inverse +time_t1_b_inverse +time_bci_aaa_inverse + time_t1_i
            total_reshape_time = total_reshape_time + time_t1_i_inverse +time_jka_abb_inverse +time_jka_aba_inverse +time_bci_aba_inverse
            total_reshape_time = total_reshape_time + time_bci_abb_inverse +time_t1t1_i +time_t1t1_i_inverse +time_t1t1_b + time_t1t1_b_inverse
            total_reshape_time = total_reshape_time + time_ajaa_t1 +time_ajaa_t1_inverse +time_t1_ibcol_alphaonly +time_t1_ibcol_alphaonly_inverse +time_t1_ibrow_alphaonly
            write(*,*) '***********************************************'
            write(*,*) '*****************Timing Data*******************'

            write(*,*) 'Total reshape time: ', total_reshape_time

            total_mm_time = ij_aa_mm +ab_aa_mm +aj_aa_mm + ij_ab_mm + ab_ab_mm + aj_ab_mm + aj_ba_mm +i_mm+ a_mm
            total_mm_time = total_mm_time + abij_aaaa_mm +abij_abab_mm +aijb_ab_mm +a_twobody_mm +i_twobody_mm +aj_bb_mm +aj_aa_transpose_mm
            write(*,*) 'Time in subroutines (s)'
            write(*,*) 'CalcParameters', time_calcparameters
            write(*,*) 'BuildK2K1', time_buildk2k1
            write(*,*) 'CalcDeriv', time_calcderiv
            write(*,*) 'CalcEnergy (hf)', time_calcenergy
            write(*,*) 'DataStructure', time_datastructure
            write(*,*) 'TopFactor', time_topfactor
            write(*,*) 'BuildD1', time_buildd1



          end subroutine

      end module


!> @brief This module contains subroutines and their input variables.  Many of them use derived data types which
!> can be found in TypeMod.  Information about specific function of subroutines is described later (at the subroutine definition).
!> 
       Module InterfaceMod
         Interface
       subroutine reshape_ijaa_test(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine reshape_ijaa_test

       subroutine reshape_ijab_test(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine reshape_ijab_test

       subroutine reshape_ajaa(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine reshape_ajaa

       subroutine reshape_ajab(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine reshape_ajab



       subroutine reshape_ajba(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine reshape_ajba



       subroutine reshape_a(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Use TypeMod
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat), intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine reshape_a

       subroutine reshape_i(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Use TypeMod
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat), intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine reshape_i

       subroutine reshape_ajbb(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine reshape_ajbb

       subroutine reshape_ajaa_transpose(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine reshape_ajaa_transpose

       subroutine reshape_ajbb_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine reshape_ajbb_inverse

       subroutine reshape_ajaa_transpose_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine reshape_ajaa_transpose_inverse

!> @brief Builds the product table for Abelian point groups
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine MakeProductTable(PointGroup,ProductTable,InvPdt,numSG)
       Use TypeMod
       Implicit None
       character(len=3), intent(IN) :: PointGroup
       integer, intent(OUT), allocatable, dimension(:,:) :: ProductTable
       type(symmetry), allocatable, dimension(:) :: InvPdt
       integer, intent(inout) :: numSG
       end subroutine MakeProductTable

!> @brief Converts orbital symmetry labels from characters to integers
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine IrreptoInt(PointGroup,Convert_char,numSG)
       Use TypeMod
       Implicit None
       character(len=3), intent(OUT), allocatable, dimension(:) :: Convert_char
       character(len=3), intent(IN) :: PointGroup
       integer, intent(OUT) :: numSG
       end subroutine

!> @brief Builds and stores the K2 and K1 matrices
!> @author Christine Schwerdtfeger and David Mazziotti
      subroutine BuildK2K1(occ,virt,numSG,InvPdt,TwoIntsCompact,OneInts,ReshapedMatrixDim,K2,K1,ProductTable,K1TwoInts,numocc,numvirt,TwoInts)
      Use TypeMod
      Implicit None

      integer, intent(IN), allocatable, dimension(:,:) :: occ, virt
      integer, intent(IN) :: numSG
      type(symmetry), allocatable, dimension(:) :: InvPdt
      real(8), intent(IN), allocatable, dimension(:,:) :: OneInts
      real(8), allocatable, dimension(:) :: TwoIntsCompact
      type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
      type(spin) :: K2(1:2,1:2,1:2,1:2)
      type(spin) :: K1(1:2,1:2)
      type(spin) :: K1TwoInts(1:2,1:2)
      integer, dimension(1:numSG,1:numSG) :: ProductTable
      integer :: numocc,numvirt
      real(8), allocatable, dimension(:,:,:,:) :: TwoInts
      end subroutine

!> @brief Calculates the matrix dimensions needed by CalcDeriv for open shell calculations
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine CalcReshapeDim(ReshapedMatrixDim,SG,virt,occ,ProductTable,InvPdt)
       Use TypeMod
       Implicit NONE
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       integer :: SG
       integer, intent(IN), dimension(1:2,1:SG) :: occ,virt
       integer, intent(IN), dimension(1:SG,1:SG) :: ProductTable
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine


!> @brief Builds the storage arrays for optimized parameters
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine DataStructure(T2data,numOcc,numVirt,InvPdt,numSG,occ,virt,ProductTable,SymO,SymV,T2deriv,flag,numElements,T1data,T1deriv,Newc,DerivNewc,inputfile)
       USE TypeMod
       Implicit NONE

       integer :: numOcc,numVirt,numSG
       integer, intent(IN), allocatable, dimension(:) :: SymV,SymO
       type(symmetry), allocatable, dimension(:) :: InvPdt
       type(T2) :: T2data, T2deriv, Newc, DerivNewc
       type(T1) :: T1data, T1deriv
       integer, intent(IN), allocatable, dimension(:,:) :: occ,virt
       integer, intent(IN), allocatable, dimension(:,:) :: ProductTable
       integer :: flag
       integer :: numElements
       character(len=100) :: inputfile
       end subroutine


!> @brief Calculates the derivative with respect to T1/T2 parameters
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine CalcDeriv(T2data,K2,K1,numSG,ProductTable,numOcc,numVirt,occ,virt,ReshapedMatrixDim,InvPdt,T2deriv,energy,K1TwoInts,T1data,T1deriv,Newc,DerivNewc,topfac,TwoInts,topsingles)
       Use TypeMod
       Implicit None

       type(T2) :: T2data, T2deriv,Newc,DerivNewc
       type(T1) :: T1data, T1deriv
       type(spin) :: K2(1:2,1:2,1:2,1:2)
       type(spin) :: K1(1:2,1:2),K1TwoInts(1:2,1:2)
       integer :: numSG,numOcc,numVirt
       integer, intent(IN), dimension(1:numSG,1:numSG) :: ProductTable
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN) :: InvPdt(1:numSG)
       integer, intent(IN), dimension(1:2,1:numSG) :: occ,virt
       double precision :: energy
       real(8), dimension(0:2,0:2) :: topfac
       real(8), dimension(0:1,0:1) :: topsingles
       real(8), intent(IN), allocatable, dimension(:,:,:,:) :: TwoInts

       end subroutine


       subroutine reshape_ijaa_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_ajaa_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_ijab_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_ajab_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_ajba_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_i_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       Use TypeMod
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat), intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_a_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       Use TypeMod
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat), intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

!> @brief Converts parameters into format needed for LBFGS calling
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine CalcParameters(SG,occ,virt,T2data,InvPdt,T2deriv,DerivVector,Tvector,T1data,T1deriv)
       USE TypeMod
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       type(T2), intent(IN) :: T2data, T2deriv
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       double precision, allocatable, dimension(:)  :: DerivVector, Tvector
       type(T1), intent(IN) :: T1data, T1deriv
       end subroutine

!> @brief Calculates the Hartree Fock energy
!> @author Christine Schwerdtfeger and David Mazziotti
        subroutine CalcEnergy(T2data,numSG,T2deriv,energy,K2,InvPdt,ReshapedMatrixDim,occ,virt,K1occ)
        Use TypeMod
        Implicit None

        type(T2), intent(IN) :: T2data
        type(T2), intent(IN) :: T2deriv
        integer :: numSG
        double precision :: energy
        type(spin) :: K2(1:2,1:2,1:2,1:2)
        type(symmetry), intent(IN) :: InvPdt(1:numSG)
        type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
        integer, allocatable, dimension(:,:) :: occ,virt
        type(spin) :: K1occ(1:2,1:2)
        end subroutine

!> @brief Takes parameters from LBFGS and sends them to storage arrays
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine CalcParametersInverse(SG,occ,virt,T2data,InvPdt,Tvector,T1data)
       USE TypeMod;
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       type(T2), intent(INOUT) :: T2data
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       double precision, allocatable, dimension(:)  :: Tvector
       type(T1), intent(INOUT) :: T1data
       end subroutine

!> @brief Symmetrizes derivative for equivalent T2 parameters
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine AveDeriv(numOcc,numVirt,InvPdt,numSG,occ,virt,ProductTable,SymO,SymV,T2deriv)
       USE TypeMod
       Implicit NONE

       integer :: numOcc,numVirt,numSG
       integer, intent(IN), allocatable, dimension(:) :: SymV,SymO
       type(symmetry), allocatable, dimension(:) :: InvPdt
       type(T2) :: T2deriv
       integer, intent(IN), allocatable, dimension(:,:) :: occ,virt
       integer, allocatable, dimension(:,:) :: ProductTable
       end subroutine

!> @brief This is a matrix multiplcation routine (DGEMM wrapper)
!> @author Christine Schwerdtfeger and David Mazziotti
      function matmul4(leftmatrix,rightmatrix)
      Implicit NONE
      double precision, allocatable, dimension(:,:) :: leftmatrix,rightmatrix
      double precision, allocatable, dimension(:,:) :: matmul4
      end function

!> @brief Takes two orbital indices and converts them to a composite index
!> @author Christine Schwerdtfeger and David Mazziotti
      function FirstIndex(i,k)
      Implicit None
      integer :: i,k
      integer*8 :: FirstIndex
      end function

!> @brief Takes output from FirstIndex and forms composite index
!> @author Christine Schwerdtfeger and David Mazziotti
      function CompositeIndex(ik,jl)
      Implicit NONE
      integer*8 :: ik, jl
      integer*8 :: CompositeIndex
      end function

       subroutine reshape_t1_b(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshape)
       USE TypeMod
       Use TimeMod, only : time_t1_b
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshape(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_t1_ibrow(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Use TimeMod, only : time_t1_ibrow
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_t1t1_i_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod
       Use TimeMod, only : time_t1t1_i_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_jka_aaa(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Use TimeMod, only : time_jka_aaa
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_jka_aaa_inverse(SG,ProductTable,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Use TimeMod, only : time_jka_aaa_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_bci_aaa(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Use TimeMod, only : time_bci_aaa
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_bci_aaa_inverse(SG,ProductTable,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Use TimeMod, only : time_bci_aaa_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_jka_aba(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Use TimeMod, only : time_jka_aba
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_jka_aba_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod
       Use TimeMod, only : time_jka_aba_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_jka_abb(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Use TimeMod, only : time_jka_abb
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_jka_abb_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod
       Use TimeMod, only : time_jka_abb_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_bci_abb(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Use TimeMod, only : time_bci_abb
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_bci_abb_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod
       Use TimeMod, only : time_bci_abb_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_bci_aba(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Use TimeMod, only : time_bci_aba
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_bci_aba_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod
       Use TimeMod, only : time_bci_aba_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_t1_b_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod
       Use TimeMod, only : time_t1_b_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_t1_i(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Use TimeMod, only : time_t1_i
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_t1_i_inverse(SG,ProductTable,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Use TimeMod, only : time_t1_i_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_t1t1_i(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Use TimeMod, only : time_t1t1_i
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_t1_ibrow_alphaonly(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Use TimeMod, only : time_t1_ibrow_alphaonly
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_t1_ibrow_alphaonly_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod
       Use TimeMod, only : time_t1_ibrow_alphaonly_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine


       subroutine reshape_t1_ibrow_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod
       Use TimeMod, only : time_t1_ibrow_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_ajaa_t1(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Use TimeMod, only : time_ajaa_t1
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_ajaa_t1_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod
       Use TimeMod, only : time_ajaa_t1_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_t1_ibcol_alphaonly(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Use TimeMod, only : time_t1_ibcol_alphaonly
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_t1_ibcol_alphaonly_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod
       Use TimeMod, only : time_t1_ibcol_alphaonly_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

!> @brief Calculates the topological factor value for user chosen parameterization
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine TopFactor(TwoInts,T2data,occ,virt,numSG,topfac,Newc,InvPdt,ProductTable,DerivNewc,numocc,numvirt,T1data,T1deriv,topsingles)

       Use TypeMod
       Use TimeMod
       IMPLICIT None
       type(T2) :: T2data, Newc, DerivNewc
       type(T1) :: T1data,T1deriv
       integer, intent(IN) :: numSG
       integer, intent(IN), dimension(1:2,1:numSG) :: occ,virt
       real(8), intent(IN), dimension(0:2,0:2) :: topfac(0:2,0:2)
       type(symmetry), dimension(:) :: InvPdt(1:numSG)
       integer, dimension(1:numSG,1:numSG) :: ProductTable
       integer :: numocc,numvirt
       real(8), allocatable, dimension(:,:,:,:) :: TwoInts
       real(8), dimension(0:1,0:1) :: topsingles(0:1,0:1)
       end subroutine


!> @brief Runs the energy optimization calculation for a closed shell calculation
!> @author Christine Schwerdtfeger and David Mazziotti
      subroutine SinglePoint(N,h,SG,ProductTable,occ,virt,T2data,T2deriv,Newc,DerivNewc,T1data,T1deriv,ReshapedMatrixDim,InvPdt,OneInts,TwoIntsCompact,SymV,SymO,energy,topfac,topsingles,numElements,inputfile,numrowblocks,EPS)
      USE TypeMod
      Implicit NONE
      integer :: h
      integer :: N
      integer :: SG
      integer, allocatable, dimension(:,:) :: ProductTable
      integer, allocatable, dimension(:,:) :: occ,virt
      type(T2) :: T2data,T2deriv
      type(T2) :: Newc, DerivNewc
      type(T1) :: T1data,T1deriv
      type(ReshapedDim) :: ReshapedMatrixDim
      integer :: numrowblocks
      type(symmetry), allocatable, dimension(:) :: InvPdt
      real(8), allocatable, dimension(:,:) :: OneInts
      real(8), allocatable, dimension(:) :: TwoIntsCompact
      integer, allocatable, dimension(:) :: SymV, SymO
      double precision :: energy
      real(8), dimension(0:2,0:2) :: topfac
      real(8), dimension(0:1,0:1) :: topsingles
      integer :: numElements
      character(len=100) :: inputfile
      double precision :: EPS
      end subroutine





!> @brief Multiplies matrices when using the UpDiag feature (only part of matrix is stored)
!> @author Christine Schwerdtfeger and David Mazziotti
      function Mydsymm(side,A,B)
      Implicit NONE
      character(len=1) :: side
      double precision, allocatable, dimension(:,:) :: A
      double precision, allocatable, dimension(:,:) :: B
      double precision, allocatable, dimension(:,:) :: Mydsymm
      end function Mydsymm

!> @brief Builds K1 and K2 for the upper diagonal storage of K2.  This feature
!> accessible only by setting the diagK2option to TRUE
!> @author Christine Schwerdtfeger and David Mazziotti
      subroutine BuildK2K1_UpDiag(occ,virt,numSG,InvPdt,TwoIntsCompact,OneInts,ReshapedMatrixDim,K2,K1,ProductTable,K1TwoInts,numocc,numvirt,TwoInts)
      Use TypeMod
      Implicit None

      integer, intent(IN), allocatable, dimension(:,:) :: occ, virt
      integer, intent(IN) :: numSG
      type(symmetry), allocatable, dimension(:) :: InvPdt
      real(8), intent(IN), allocatable, dimension(:,:) :: OneInts
      real(8), allocatable, dimension(:) :: TwoIntsCompact
      type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
      type(spin) :: K2(1:2,1:2,1:2,1:2)
      type(spin) :: K1(1:2,1:2)
      type(spin) :: K1TwoInts(1:2,1:2)
      integer, dimension(1:numSG,1:numSG) :: ProductTable
      integer :: numocc,numvirt
      real(8), allocatable, dimension(:,:,:,:) :: TwoInts
      end subroutine

!> @brief Calculates the derivative is diagK2option is TRUE
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine CalcDeriv_UpDiag(T2data,K2,K1,numSG,ProductTable,numOcc,numVirt,occ,virt,ReshapedMatrixDim,InvPdt,T2deriv,energy,K1TwoInts,T1data,T1deriv,Newc,DerivNewc,topfac,TwoInts,topsingles)
       Use TypeMod
       Implicit None

       type(T2) :: T2data, T2deriv,Newc,DerivNewc
       type(T1) :: T1data, T1deriv
       type(spin) :: K2(1:2,1:2,1:2,1:2)
       type(spin) :: K1(1:2,1:2),K1TwoInts(1:2,1:2)
       integer :: numSG,numOcc,numVirt
       integer, intent(IN), dimension(1:numSG,1:numSG) :: ProductTable
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN) :: InvPdt(1:numSG)
       integer, intent(IN), dimension(1:2,1:numSG) :: occ,virt
       double precision :: energy
       real(8), dimension(0:2,0:2) :: topfac
       real(8), dimension(0:1,0:1) :: topsingles
       real(8), intent(IN), allocatable, dimension(:,:,:,:) :: TwoInts
       end subroutine

!> @brief Calculate HF energy when diagK2option is TRUE
!> @author Christine Schwerdtfeger and David Mazziotti
        subroutine CalcEnergy_UpDiag(T2data,numSG,T2deriv,energy,K2,InvPdt,ReshapedMatrixDim,occ,virt,K1occ)
        Use TypeMod
        Implicit None

        type(T2), intent(IN) :: T2data
        type(T2), intent(IN) :: T2deriv
        integer :: numSG
        double precision :: energy
        type(spin) :: K2(1:2,1:2,1:2,1:2)
        type(symmetry), intent(IN) :: InvPdt(1:numSG)
        type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
        integer, allocatable, dimension(:,:) :: occ,virt
        type(spin) :: K1occ(1:2,1:2)
        end subroutine

!> @brief Runs the energy optimization calculation when diagK2option is TRUE
!> @author Christine Schwerdtfeger and David Mazziotti
      subroutine SinglePoint_UpDiag(N,h,SG,ProductTable,occ,virt,T2data,T2deriv,Newc,DerivNewc,T1data,T1deriv,ReshapedMatrixDim,InvPdt,OneInts,TwoIntsCompact,SymV,SymO,energy,topfac,topsingles,numElements,inputfile,EPS)
      USE TypeMod
      Implicit NONE
      integer :: h
      integer :: N
      integer :: SG
      integer, allocatable, dimension(:,:) :: ProductTable
      integer, allocatable, dimension(:,:) :: occ,virt
      type(T2) :: T2data,T2deriv
      type(T2) :: Newc, DerivNewc
      type(T1) :: T1data,T1deriv
      type(ReshapedDim) :: ReshapedMatrixDim
      type(symmetry), allocatable, dimension(:) :: InvPdt
      real(8), allocatable, dimension(:,:) :: OneInts
      real(8), allocatable, dimension(:) :: TwoIntsCompact
      integer, allocatable, dimension(:) :: SymV, SymO
      double precision :: energy
      real(8), dimension(0:2,0:2) :: topfac
      real(8), dimension(0:1,0:1) :: topsingles
      integer :: numElements
      characteR(len=100) :: inputfile
      double precision :: EPS
      end subroutine

!> @brief Builds the D1 matrix after parameters are optimized
!> @author Christine Schwerdtfeger and David Mazziotti
      subroutine BuildD1(T2data,T1data,numSG,ProductTable,occ,virt,ReshapedMatrixDim,InvPdt,filename,topsingles)

      Use TypeMod
      Implicit NONE

      type(T2) :: T2data
      type(T1) :: T1data
      integer :: numSG,numOcc,numVirt
      integer, intent(IN), dimension(1:2,1:numSG) :: occ,virt
      type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
      integer, dimension(1:numSG,1:numSG) :: ProductTable
      type(symmetry), intent(IN), dimension(:) :: InvPdt(1:numSG)
      character(len=35) :: filename
      real(8), dimension(:,:) :: topsingles(0:1,0:1)
      end subroutine

!> @brief Prints T1 and T2 parameters to file
!> @author Christine Schwerdtfeger
       subroutine PrintT2Coefficients(T2data,numOcc,numVirt,InvPdt,numSG,occ,virt,ProductTable,SymO,SymV,T1data,inputfile,numElements)
       USE TypeMod
       Implicit NONE
       integer :: numOcc,numVirt,numSG
       integer, intent(IN), allocatable, dimension(:) :: SymV,SymO
       type(symmetry), allocatable, dimension(:) :: InvPdt
       type(T2) :: T2data
       type(T1) :: T1data
       integer, intent(IN), allocatable, dimension(:,:) :: occ,virt
       integer, allocatable, dimension(:,:) :: ProductTable
       character(len=100) :: inputfile
       integer :: numElements
       end subroutine

!> @brief Prints the T1 and T2 parameters for open shell calculations
!> @author Christine Schwerdteger and David Mazziotti
       subroutine PrintT2CoefficientsOS(T2data,numocc_alpha,numocc_beta,numvirt_alpha,numvirt_beta,InvPdt,numSG,occ_alpha,occ_beta,virt_alpha,virt_beta,ProductTable,Sym_alpha,Sym_beta,T1data,inputfile,numElements)
       USE TypeMod
       Use TimeMod, only : time_datastructure
       Implicit NONE

       integer ::numocc_alpha,numocc_beta,numvirt_alpha,numvirt_beta,numSG
       integer, intent(IN), allocatable, dimension(:) :: Sym_alpha,Sym_beta
       type(symmetry), allocatable, dimension(:) :: InvPdt
       type(T2) :: T2data
       type(T1) :: T1data
       integer, intent(IN), allocatable, dimension(:,:) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, allocatable, dimension(:,:) :: ProductTable
       character(len=100) :: inputfile
       integer :: numElements
       end subroutine


!> @brief Performs matrix multiplication when K2 is written to disk (BlockK2) (only use with intel compiler)
!> @author Christine Schwerdtfeger and David Mazziotti
       function matmul3(rightmatrix,BlockDim,spinblock,currentSGnum,leftmatrixfile,numrowblocks)
       Use TypeMod
       Implicit NONE
       double precision, allocatable, dimension(:,:) :: rightmatrix
       type(BlockMatMulDims) :: BlockDim
       character(len=2) :: spinblock
       integer :: currentSGnum
       integer :: numrowblocks
       character(len=100) :: leftmatrixfile
       double precision, allocatable, dimension(:,:) :: matmul3
       end function

!> @brief Builds K2 and K1 matrices for disk writing feature.  Only works for the intel compiler.
!> @author Christine Schwerdtfeger and David Mazziotti
      subroutine BuildK2K1BlockK2(occ,virt,numSG,InvPdt,TwoIntsCompact,OneInts,ReshapedMatrixDim,K2,K1,ProductTable,K1TwoInts,numocc,numvirt,TwoInts,numrowblocks,BlockDim,inputfile)
      Use TypeMod
      Use TimeMod, only : time_buildk2k1
      Implicit None
      integer, intent(IN), allocatable, dimension(:,:) :: occ, virt
      integer, intent(IN) :: numSG
      type(symmetry), allocatable, dimension(:) :: InvPdt
      real(8), allocatable, dimension(:,:,:,:) :: TwoInts
      real(8), intent(IN), allocatable, dimension(:,:) :: OneInts
      real(8), allocatable, dimension(:) :: TwoIntsCompact
      type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
      type(spin) :: K2(1:2,1:2,1:2,1:2)
      type(spin) :: K1(1:2,1:2)
      integer, dimension(1:numSG,1:numSG) :: ProductTable
      type(spin) :: K1TwoInts(1:2,1:2)
      integer :: numrowblocks
      type(BlockMatMulDims) :: BlockDim
      character(len=100) :: inputfile
      integer :: numocc, numvirt
      end subroutine

!> @brief Calculates the derivative when K2 is written to disk
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine CalcDerivBlockK2(T2data,K2,K1,numSG,ProductTable,numOcc,numVirt,occ,virt,ReshapedMatrixDim,InvPdt,T2deriv, energy,K1TwoInts,T1data,T1deriv,Newc,DerivNewc,topfac,TwoInts,topsingles,numrowblocks,inputfile,BlockDim)
       Use TypeMod
       Use TimeMod
       Implicit None
       type(T2) :: T2data
       type(T1) :: T1data,T1deriv
       type(T2) :: Newc,DerivNewc
       type(spin) :: K2(1:2,1:2,1:2,1:2)
       type(spin) :: K1(1:2,1:2),K1TwoInts(1:2,1:2)
       integer :: numSG,numOcc,numVirt
       integer, intent(IN), dimension(1:numSG,1:numSG) :: ProductTable
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN) :: InvPdt(1:numSG)
       integer, intent(IN), dimension(1:2,1:numSG) :: occ,virt
       integer :: p, i_begin,i_end,j_begin,j_end,k_begin,k_end, l_begin,l_end,i,j,k,l,q,r,s,t,v,row,col,symgp
       integer :: c_begin,c_end,a_begin,a_end,c,a
       integer :: numrowblocks
       type(BlockMatMulDims) :: BlockDim
       character(len=100) :: inputfile
       type(ReshapedMat), allocatable, dimension(:)  :: DerivReshapes, Reshapes, TopReshape,DerivTopReshape
       type(T2) :: T2deriv
       real(8) :: energy
       real(8) :: tempenergy=0.0D0
       integer :: temprow, tempcol
       real(8), dimension(0:2,0:2) :: topfac
       real(8), intent(IN), allocatable, dimension(:,:,:,:) :: TwoInts
       real(8), dimension(0:1,0:1) :: topsingles(0:1,0:1)
       end subroutine


!> @brief Builds the D2 matrix after T1/T2 parameters are optimized
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine BuildD2(T2data,T1data,ReshapedMatrixDim,numSG,occ,virt,ProductTable,InvPdt,numOcc,numVirt,TwoInts,topfac,Newc,DerivNewc,T1deriv,topsingles,filename)

       Use TypeMod
       Implicit NONE
       type(T2) :: T2data
       type(T1) :: T1data,T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       integer :: numSG,numOcc,numVirt
       integer, intent(IN), dimension(1:2,1:numSG) :: occ,virt
       integer, dimension(1:numSG,1:numSG) :: ProductTable
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:numSG)
       real(8), intent(IN), allocatable, dimension(:,:,:,:) :: TwoInts
       real(8), dimension(0:2,0:2) :: topfac
       type(T2) :: Newc, DerivNewc
       real(8), dimension(0:1,0:1) :: topsingles(0:1,0:1)
       character(len=35) :: filename
       end subroutine

!> @brief Helper routine for BuildD2 (to determine position of a given matrix element)
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine MapD2(numSG,occ,virt,ReshapedMatrixDim,IbD2aa,IbD2ab, Basis_ajaa, Basis_ajab, Basis_jaab,Basis_jka_aaa, Basis_bci_aaa,Basis_jka_aba, Basis_jka_abb, Basis_bci_aba, Basis_bci_abb,Basis_i,Basis_a,Sym_Basis_jka_aaa, Sym_Basis_bci_aaa,Sym_Basis_jka_aba, Sym_Basis_jka_abb, Sym_Basis_bci_aba,Sym_Basis_bci_abb,Sym_Basis_i, Sym_Basis_a,InvPdt,Sym_Basis_ajaa, Sym_Basis_ajab, Sym_Basis_jaab)
       Use TypeMod
       Implicit NONE
       integer :: numSG
       integer, intent(IN), dimension(1:2,1:numSG) :: occ,virt
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim

       type(BasisMap2), allocatable, dimension(:) :: D2aabasis, D2abbasis
       type(InverseBasis2), allocatable, dimension(:) :: IbD2aa
       type(InverseBasis2), allocatable, dimension(:) :: IbD2ab
       type(BasisMap2), allocatable, dimension(:) :: Basis_ajaa, Basis_ajab, Basis_jaab
       type(BasisMap3), allocatable, dimension(:) :: Basis_jka_aaa, Basis_bci_aaa
       type(BasisMap3), allocatable, dimension(:) :: Basis_jka_aba, Basis_jka_abb, Basis_bci_aba, Basis_bci_abb
       type(BasisMap1), allocatable, dimension(:) :: Basis_i,Basis_a
       type(BasisMap2), allocatable, dimension(:) :: Sym_Basis_ajaa, Sym_Basis_ajab, Sym_Basis_jaab
       type(BasisMap3), allocatable, dimension(:) :: Sym_Basis_jka_aaa, Sym_Basis_bci_aaa
       type(BasisMap3), allocatable, dimension(:) :: Sym_Basis_jka_aba, Sym_Basis_jka_abb, Sym_Basis_bci_aba, Sym_Basis_bci_abb
       type(BasisMap1), allocatable, dimension(:) :: Sym_Basis_i, Sym_Basis_a
       type(symmetry), intent(IN) :: InvPdt(1:numSG)
       end subroutine

!> @brief Manages the parameter arrays for open shell calculations
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine DataStructureOS(T2data,numocc_alpha, numocc_beta,numvirt_alpha,numvirt_beta,InvPdt,numSG,occ_alpha, occ_beta,virt_alpha,virt_beta,ProductTable,Sym_alpha,Sym_beta,T2deriv,flag,numElements,T1data,T1deriv,Newc,DerivNewc,inputfile,T2derivT1topfac,Newc_singles,DerivNewc_singles)
       USE TypeMod
       Use TimeMod, only : time_datastructure
       Implicit NONE

       integer :: numocc_alpha,numocc_beta,numvirt_alpha,numvirt_beta,numSG
       integer, intent(IN), allocatable, dimension(:) :: Sym_alpha, Sym_beta
       type(symmetry), allocatable, dimension(:) :: InvPdt
       type(T2) :: T2data, T2deriv, Newc,DerivNewc, T2derivT1topfac
       type(T1) :: T1data, T1deriv, Newc_singles, DerivNewc_singles
       integer, intent(IN), allocatable, dimension(:,:) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, allocatable, dimension(:,:) :: ProductTable
       integer :: flag
       integer :: numElements
       character(len=100) :: inputfile
       end subroutine

!> @brief Calculates the matrix dimensions needed by CalcDeriv for open shell calculations
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine CalcReshapeDimOS(ReshapedMatrixDim,SG,virt_alpha, virt_beta,occ_alpha, occ_beta,ProductTable,InvPdt)
       Use TypeMod
       Use TimeMod, only : time_calcreshapedim
       Implicit NONE

       type(ReshapedDim) :: ReshapedMatrixDim
       integer :: SG
       integer, intent(IN), dimension(1:2,1:SG) :: occ_alpha, occ_beta,virt_alpha,virt_beta
       integer, intent(IN), dimension(1:SG,1:SG) :: ProductTable
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

!> @brief Builds the K1 and K2 matrices for open shell calculations
!> @author Christine Schwerdtfeger and David Mazziotti
      subroutine BuildK2K1OS(occ_alpha,occ_beta,virt_alpha,virt_beta,numSG,InvPdt,TwoIntsCompact,OneInts,ReshapedMatrixDim,K2,K1,ProductTable,K1TwoInts,TwoInts,OldIndex_alpha,OldIndex_beta)
      Use TypeMod
      Use TimeMod, only : time_buildk2k1
      Implicit None

      integer, intent(IN), allocatable, dimension(:,:) :: occ_alpha,occ_beta, virt_alpha,virt_beta
      integer, intent(IN) :: numSG
      type(symmetry), allocatable, dimension(:) :: InvPdt
      real(8), allocatable, dimension(:,:,:,:) :: TwoInts
      real(8), intent(IN), allocatable, dimension(:,:) :: OneInts
      real(8), allocatable, dimension(:) :: TwoIntsCompact
      type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
      type(spin) :: K2(1:2,1:2,1:2,1:2)
      type(spin) :: K1(1:2,1:2)
      integer, dimension(1:numSG,1:numSG) :: ProductTable
      type(spin) :: K1TwoInts(1:2,1:2)
      integer, allocatable, dimension(:) :: OldIndex_alpha, OldIndex_beta
      end subroutine

!> @brief Controls the single point calculation for open shell molecules
!> @author Christine Schwerdtfeger and David Mazziotti
      subroutine SinglePointOS(numocc_alpha,numocc_beta,numvirt_alpha,numvirt_beta,SG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,T2deriv,Newc,DerivNewc,T1data,T1deriv,ReshapedMatrixDim,InvPdt,OneInts,TwoIntsCompact,Sym_alpha,Sym_beta,energy,topfac,topsingles,numElements,inputfile,numrowblocks,EPS,OldIndex_alpha,OldIndex_beta,T2derivT1topfac,Newc_singles,DerivNewc_singles)
      USE TypeMod
      Use TimeMod, only : time_singlepoint
      Implicit NONE
      integer :: numvirt_alpha,numvirt_beta
      integer :: numocc_alpha,numocc_beta
      integer :: SG
      integer, allocatable, dimension(:,:) :: ProductTable
      integer, allocatable, dimension(:,:) :: occ_alpha, occ_beta, virt_alpha, virt_beta
      type(T2) :: T2data,T2deriv
      type(T2) :: Newc, DerivNewc
      type(T2) :: T2derivT1topfac
      type(T1) :: T1data,T1deriv
      type(T1) :: Newc_singles, DerivNewc_singles
      integer :: numrowblocks
      type(ReshapedDim) :: ReshapedMatrixDim
      type(symmetry), allocatable, dimension(:) :: InvPdt
      real(8), allocatable, dimension(:,:) :: OneInts
      real(8), allocatable, dimension(:) :: TwoIntsCompact
      integer, allocatable, dimension(:) :: Sym_alpha, Sym_beta
      double precision :: energy
      real(8), dimension(0:2,0:2) :: topfac
      real(8), dimension(0:1,0:1) :: topsingles
      integer :: numElements
      character(len=100) :: inputfile
      double precision :: EPS
      integer, allocatable, dimension(:) :: OldIndex_alpha, OldIndex_beta
      end subroutine

!> @brief Calculates the hartree fock energy for open shell calculations
!> @author Christine Schwerdtfeger and David Mazziotti
        subroutine CalcEnergyOS(T2data,numSG,T2deriv,energyconstants,K2,InvPdt,ReshapedMatrixDim,occ_alpha, occ_beta,virt_alpha,virt_beta,K1)
        Use TypeMod
        Use TimeMod, only : time_calcenergy
        Implicit None

        type(T2), intent(IN) :: T2data
        type(T2), intent(IN) :: T2deriv
        integer :: numSG
        real(8) :: energyconstants
        type(spin) :: K2(1:2,1:2,1:2,1:2)
        type(symmetry), intent(IN) :: InvPdt(1:numSG)
        type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
        integer, allocatable, dimension(:,:) :: occ_alpha,occ_beta,virt_alpha, virt_beta
        type(spin) :: K1(1:2,1:2)
        end subroutine

!> @brief Builds the K1 and K2 matrices for the disk writing feature (open shell)(intel compilers only)
!> @author Christine Schwerdtfeger and David Mazziotti
      subroutine BuildK2K1BlockK2OS(occ_alpha,occ_beta,virt_alpha,virt_beta,numSG,InvPdt,TwoIntsCompact,OneInts,ReshapedMatrixDim,K2,K1,ProductTable,K1TwoInts,TwoInts,numrowblocks,BlockDim,inputfile,OldIndex_alpha,OldIndex_beta)
      Use TypeMod
      Use TimeMod, only : time_buildk2k1
      Implicit None
      integer, intent(IN), allocatable, dimension(:,:) :: occ_alpha,occ_beta, virt_alpha,virt_beta
      integer, intent(IN) :: numSG
      type(symmetry), allocatable, dimension(:) :: InvPdt
      real(8), allocatable, dimension(:,:,:,:) :: TwoInts
      real(8), intent(IN), allocatable, dimension(:,:) :: OneInts
      real(8), allocatable, dimension(:) :: TwoIntsCompact
      type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
      type(spin) :: K2(1:2,1:2,1:2,1:2)
      type(spin) :: K1(1:2,1:2)
      integer, dimension(1:numSG,1:numSG) :: ProductTable
      type(spin) :: K1TwoInts(1:2,1:2)
      integer :: numrowblocks
      type(BlockMatMulDims) :: BlockDim
      character(len=100) :: inputfile
      integer, allocatable, dimension(:) :: OldIndex_alpha, OldIndex_beta
      end subroutine

!> @brief Puts T1/T2 parameters in the format for reading by lbfgs
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine CalcParametersOS(SG,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,InvPdt,T2deriv,DerivVector,Tvector,T1data,T1deriv)
       USE TypeMod
       Use TimeMod, only : time_calcparameters
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       type(T2), intent(IN) :: T2data, T2deriv
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       double precision, allocatable, dimension(:)  :: DerivVector, Tvector
       type(T1), intent(IN) :: T1data, T1deriv
       end subroutine

!> @brief Takes parameters from lbfgs and returns them to storage arrays
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine CalcParametersInverseOS(SG,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,InvPdt,Tvector,T1data)
       USE TypeMod
       Use TimeMod, only : time_calcparametersinverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       type(T2), intent(INOUT) :: T2data
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       double precision, allocatable, dimension(:)  :: Tvector
       type(T1), intent(INOUT) :: T1data
       end subroutine

!> @brief Symmetrizes derivatives for equivalent parameters for open shell calculations
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine AveDerivOS(InvPdt,numSG,occ_alpha,occ_beta,virt_alpha,virt_beta,ProductTable,Sym_alpha,Sym_beta,T2deriv)
       USE TypeMod
       Use TimeMod, only : time_avederiv
       Implicit NONE
       integer :: numSG
       integer, intent(IN), allocatable, dimension(:) :: Sym_alpha,Sym_beta
       type(symmetry), allocatable, dimension(:) :: InvPdt
       type(T2) :: T2deriv
       integer, intent(IN), allocatable, dimension(:,:) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, allocatable, dimension(:,:) :: ProductTable
       end subroutine

       subroutine reshape_ajaa_inverseOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Use TimeMod, only : time_ajaa
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

!> @brief Calculates the T1/T2 parameter derivatives for open shell calculations
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine CalcDerivOS(T2data,K2,K1,numSG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,ReshapedMatrixDim,InvPdt,T2deriv, energy,K1TwoInts,T1data,T1deriv,Newc,DerivNewc,topfac,TwoInts,topsingles,OldIndex_alpha,OldIndex_beta,T2derivT1topfac,Newc_singles,DerivNewc_singles)
       Use TypeMod
       Use TimeMod
       Implicit None

       type(T2) :: T2data, T2derivT1topfac
       type(T1) :: T1data,T1deriv,Newc_singles, DerivNewc_singles
       type(T2) :: Newc,DerivNewc
       type(spin) :: K2(1:2,1:2,1:2,1:2)
       type(spin) :: K1(1:2,1:2),K1TwoInts(1:2,1:2)
       integer :: numSG
       integer, intent(IN), dimension(1:numSG,1:numSG) :: ProductTable
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN) :: InvPdt(1:numSG)
       integer, intent(IN), dimension(1:2,1:numSG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       type(T2) :: T2deriv
       real(8) :: energy
       real(8), dimension(0:2,0:2) :: topfac
       real(8), intent(IN), allocatable, dimension(:,:,:,:) :: TwoInts
       real(8), dimension(0:1,0:1) :: topsingles(0:1,0:1)
       integer, allocatable, dimension(:) :: OldIndex_alpha, OldIndex_beta
       end subroutine

! >@brief Calculates the topological factor for open shell calculations
! >@author Christine Schwerdtfeger and David Mazziotti
       subroutine TopFactorOS(TwoInts,T2data,occ_alpha,occ_beta,virt_alpha,virt_beta,numSG,topfac,Newc,InvPdt,ProductTable,DerivNewc,T1data,T1deriv,topsingles,OldIndex_alpha,OldIndex_beta,T2derivT1topfac,Newc_singles,DerivNewc_singles,K1,K1TwoInts)
       Use TypeMod
       Use TimeMod, only : time_topfactor
       IMPLICIT None
       type(T2) :: T2data, Newc, DerivNewc, T2derivT1topfac
       type(T1) :: T1data,T1deriv, Newc_singles, DerivNewc_singles
       integer, intent(IN) :: numSG
       integer, intent(IN), dimension(1:2,1:numSG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       real(8), intent(IN), dimension(0:2,0:2) :: topfac(0:2,0:2)
       type(symmetry), dimension(:) :: InvPdt(1:numSG)
       integer, dimension(1:numSG,1:numSG) :: ProductTable
       real(8) :: total
       integer :: i,j,a,b,c,d,k,l,p,q,r,s,symgp,v,t,u
       integer :: i_begin,i_end,j_begin,j_end,a_begin,a_end,b_begin,b_end
       integer :: c_begin,c_end, d_begin,d_end, k_begin,k_end, l_begin,l_end
       integer :: cisym, aksym,kisym
       real(8), dimension(:,:) :: topsingles(0:1,0:1)
       real(8), allocatable, dimension(:,:,:,:) :: TwoInts(:,:,:,:)
       integer, allocatable, dimension(:) :: OldIndex_alpha, OldIndex_beta
      type(spin) :: K1(1:2,1:2), K1TwoInts(1:2,1:2)
       end subroutine

!> @brief Builds the topological factor the T1 coefficients
!> @author Christine Schwerdtfeger and David Mazziotti
      subroutine BuildNewc_singles(Newc_singles,T2data,T1data,topsingles,numSG,occ,virt,InvPdt,ProductTable)

      Use TypeMod
      IMPLICIT None
      type(T1) :: Newc_singles
      type(T2) :: T2data
      type(T1) :: T1data
      real(8), dimension(0:1,0:1) :: topsingles(0:1,0:1)
      integer :: numSG
      integer, intent(IN), dimension(1:2,1:numSG) :: occ,virt
      type(symmetry), intent(IN), dimension(:) :: InvPdt(1:numSG)
      integer, dimension(1:numSG,1:numSG) :: ProductTable
      end subroutine

!> @brief Builds the D2 matrix for open shell calculations
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine BuildD2OS(T2data,T1data,ReshapedMatrixDim,numSG,occ_alpha,occ_beta,virt_alpha,virt_beta,ProductTable,InvPdt,TwoInts,topfac,Newc,DerivNewc,T1deriv,topsingles,filename,Newc_singles)
       Use TypeMod
       Implicit NONE
       type(T2) :: T2data
       type(T1) :: T1data,T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       integer :: numSG
       integer, intent(IN), dimension(1:2,1:numSG) :: occ_alpha, occ_beta,virt_alpha,virt_beta
       integer, dimension(1:numSG,1:numSG) :: ProductTable
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:numSG)
       real(8), intent(IN), allocatable, dimension(:,:,:,:) :: TwoInts
       real(8), dimension(0:2,0:2) :: topfac
       type(T2) :: Newc, DerivNewc
       real(8), dimension(0:1,0:1) :: topsingles(0:1,0:1)
       character(len=35) :: filename
       type(T1) :: Newc_singles
       end subroutine


!> @brief Helper routine for BuildD2OS.  Maps D2 matrix elements to proper place in matrix.
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine MapD2OS(numSG,occ_alpha,occ_beta,virt_alpha,virt_beta,ReshapedMatrixDim,IbD2aa,IbD2ab,IbD2bb, Basis_ajaa, Basis_ajbb,Basis_ajab,Basis_jaab,Basis_jka_aaa,Basis_jka_bbb,Basis_bci_aaa,Basis_bci_bbb,Basis_jka_aba, Basis_jka_abb, Basis_bci_aba, Basis_bci_abb,Basis_i_alpha,Basis_i_beta,Basis_a_alpha,Basis_a_beta,Sym_Basis_jka_aaa,Sym_Basis_jka_bbb,Sym_Basis_bci_aaa,Sym_Basis_bci_bbb,Sym_Basis_jka_aba, Sym_Basis_jka_abb, Sym_Basis_bci_aba,Sym_Basis_bci_abb,Sym_Basis_i_alpha, Sym_Basis_i_beta, Sym_Basis_a_alpha, Sym_Basis_a_beta,InvPdt,Sym_Basis_ajaa,Sym_Basis_ajbb,Sym_Basis_ajab,Sym_Basis_jaab)
       Use TypeMod
       Implicit NONE
       integer :: numSG
       integer, intent(IN), dimension(1:2,1:numSG) :: occ_alpha, occ_beta,virt_alpha, virt_beta
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(BasisMap2), allocatable, dimension(:) :: D2aabasis, D2abbasis, D2bbbasis
       type(InverseBasis2), allocatable, dimension(:) :: IbD2aa, IbD2bb
       type(InverseBasis2), allocatable, dimension(:) :: IbD2ab
       type(BasisMap2), allocatable, dimension(:) :: Basis_ajaa, Basis_ajab, Basis_jaab, Basis_ajbb
       type(BasisMap3), allocatable, dimension(:) :: Basis_jka_aaa, Basis_bci_aaa, Basis_jka_bbb, Basis_bci_bbb
       type(BasisMap3), allocatable, dimension(:) :: Basis_jka_aba, Basis_jka_abb, Basis_bci_aba, Basis_bci_abb
       type(BasisMap1), allocatable, dimension(:) :: Basis_i_alpha, Basis_i_beta,Basis_a_alpha, Basis_a_beta
       type(BasisMap2), allocatable, dimension(:) :: Sym_Basis_ajaa, Sym_Basis_ajab, Sym_Basis_jaab, Sym_Basis_ajbb
       type(BasisMap3), allocatable, dimension(:) :: Sym_Basis_jka_aaa, Sym_Basis_bci_aaa, Sym_Basis_jka_bbb, Sym_Basis_bci_bbb
       type(BasisMap3), allocatable, dimension(:) :: Sym_Basis_jka_aba, Sym_Basis_jka_abb, Sym_Basis_bci_aba, Sym_Basis_bci_abb
       type(BasisMap1), allocatable, dimension(:) :: Sym_Basis_i_alpha, Sym_Basis_i_beta, Sym_Basis_a_alpha, Sym_Basis_a_beta
       type(symmetry), intent(IN) :: InvPdt(1:numSG)
       end subroutine



!> @brief Builds Q2 and G2 matrices for open shell calculations
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine BuildQ2G2OS(D2matrix,D1alpha_cum,D1beta_cum,IbD2aa,IbD2bb,IbD2ab,occ_alpha,occ_beta,virt_alpha,virt_beta,InvPdt,ProductTable,numSG,ReshapedMatrixDim,filename)
       Use TypeMod
       Implicit NONE
       integer :: numSG
       type(D2) :: D2matrix
       type(D1) :: D1alpha_cum(1:numSG), D1beta_cum(1:numSG)
       type(InverseBasis2), allocatable, dimension(:) :: IbD2aa,IbD2bb,IbD2ab
       integer, intent(IN), dimension(1:2,1:numSG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:numSG)
       integer, dimension(1:numSG,1:numSG) :: ProductTable
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       character(len=35) :: filename
       end subroutine

!> @brief Builds the Q2 and G2 matrices for closed shell species
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine BuildQ2G2CS(D2matrix,D1cum,IbD2aa,IbD2ab,occ,virt,InvPdt,ProductTable,numSG,ReshapedMatrixDim,filename)
       Use TypeMod
       Implicit NONE
       integer :: numSG
       type(D2) :: D2matrix
       type(D1) :: D1cum(1:numSG)
       type(InverseBasis2), allocatable, dimension(:) :: IbD2aa, IbD2ab
       integer, intent(IN), dimension(1:2,1:numSG) :: occ,virt
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:numSG)
       integer, dimension(1:numSG,1:numSG) :: ProductTable
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       character(len=35) :: filename
       end subroutine

!> @brief Calculates derivative for disk writing feature (open shell calculations) (intel compiler only)
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine CalcDerivBlockK2OS(T2data,K2,K1,numSG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,ReshapedMatrixDim,InvPdt,T2deriv, energy,K1TwoInts,T1data,T1deriv,Newc,DerivNewc,topfac,TwoInts,topsingles,OldIndex_alpha,OldIndex_beta,T2derivT1topfac,Newc_singles,DerivNewc_singles,numrowblocks,inputfile,BlockDim)
       Use TypeMod
       Use TimeMod
       Implicit None

       type(T2) :: T2data
       type(T1) :: T1data,T1deriv, Newc_singles, DerivNewc_singles
       type(T2) :: Newc,DerivNewc, T2derivT1topfac
       type(spin) :: K2(1:2,1:2,1:2,1:2)
       type(spin) :: K1(1:2,1:2),K1TwoInts(1:2,1:2)
       integer :: numSG
       integer, intent(IN), dimension(1:numSG,1:numSG) :: ProductTable
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN) :: InvPdt(1:numSG)
       integer, intent(IN), dimension(1:2,1:numSG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       type(T2) :: T2deriv
       real(8) :: energy
       real(8), dimension(0:2,0:2) :: topfac
       real(8), intent(IN), allocatable, dimension(:,:,:,:) :: TwoInts
       real(8), dimension(0:1,0:1) :: topsingles(0:1,0:1)
       integer, allocatable, dimension(:) :: OldIndex_alpha, OldIndex_beta
       integer :: numrowblocks
       character(len=100) :: inputfile
       type(BlockMatMulDims) :: BlockDim
       end subroutine





       subroutine reshape_ajaa_transposederiv_inverseOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Use TimeMod, only : time_ajaa
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG),DerivReshapes(1:SG)
       type(T2) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine

       subroutine reshape_ajbb_transposederiv_inverseOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod
       Use TimeMod, only : time_ajaa
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG),DerivReshapes(1:SG)
       type(T2) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       end subroutine


!> @brief Read the integrals from binary files for open shell calculations
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine ReadGamess_BinaryGAMESSFMTOS(PointGroup,Convert_char,numSG,occ_alpha,occ_beta,virt_alpha,virt_beta,OneInts,TwoIntsCompact,Sym_alpha,Sym_beta,numocc_alpha,numocc_beta,numvirt_alpha, numvirt_beta,frozencore,nuclearrep,NewIndex_alpha, NewIndex_beta,scrpath,OldIndex_alpha, OldIndex_beta,SymChar,labsiz,nwdvar)
       Use TimeMod, only : time_readgamess
       Implicit NONE
       character(len=50) :: gamessoutput
       character(len=100) :: inputfile
       character(len=3) :: PointGroup
       integer :: numSG
       character(len=3), dimension(:) :: Convert_char(1:numSG)
       real(8) :: frozencore,nuclearrep
       integer, allocatable, dimension(:,:) :: occ_alpha, occ_beta
       integer, allocatable, dimension(:,:) :: virt_alpha, virt_beta
       real(8), intent(OUT), allocatable, dimension(:,:) :: OneInts
       real(8), allocatable, dimension(:) :: TwoIntsCompact
       integer, intent(OUT), allocatable, dimension(:) :: Sym_alpha,Sym_beta
       integer :: numocc_alpha, numvirt_alpha, numocc_beta, numvirt_beta
       real(8) :: integralOne
       character(len=100) :: scrpath,binaryfile
       integer, allocatable, dimension(:) :: OldIndex_alpha, OldIndex_beta,NewIndex_alpha, NewIndex_beta
       character(len=3) :: SymChar(1:numocc_alpha+numvirt_alpha)
       integer :: labsiz, nwdvar
       end subroutine

!> @brief Reads the one and two electrons integrals from binary files
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine ReadGamess_BinaryGAMESSFMT(inputfile,PointGroup,Convert_char,numSG,occ,virt,OneInts,TwoIntsCompact,SymO,SymV,numocc,numvirt,frozencore,nuclearrep,NewIndex,scrpath,SymChar,labsiz,nwdvar)
       Use TimeMod, only : time_readgamess
       Implicit NONE
       character(len=50) :: gamessoutput
       character(len=100) :: inputfile
       character(len=3) :: PointGroup
       integer :: numSG
       character(len=3), dimension(:) :: Convert_char(1:numSG)
       real(8) :: frozencore,nuclearrep
       integer, allocatable, dimension(:,:) :: occ
       integer, allocatable, dimension(:,:) :: virt
       real(8), intent(OUT), allocatable, dimension(:,:) :: OneInts
       real(8), allocatable, dimension(:) :: TwoIntsCompact
       integer, intent(OUT), allocatable, dimension(:) :: SymV,SymO
       integer :: numocc, numvirt
       real(8) :: integralOne
       character(len=100) :: scrpath,binaryfile
       character(len=3) :: SymChar(1:numocc+numvirt)
       integer, allocatable, dimension(:) :: OldIndex,NewIndex
       integer :: labsiz, nwdvar
       end subroutine

          end Interface
       end Module

!> @brief This is a matrix multiplcation routine (DGEMM wrapper)
!> @author Christine Schwerdtfeger and David Mazziotti
      function matmul4(leftmatrix,rightmatrix)

      Use TimeMod, only : time_mm
      Implicit NONE
      double precision, allocatable, dimension(:,:) :: leftmatrix,rightmatrix
      double precision, allocatable, dimension(:,:) :: matmul4
      integer :: lmr, lmc
      integer :: rmr, rmc
      real :: time_begin, time_end

      Call cpu_time(time_begin)
      lmr = size(leftmatrix,1)
      lmc = size(leftmatrix,2)
      rmr = size(rightmatrix,1)
      rmc = size(rightmatrix,2)

      allocate(matmul4(1:lmr,1:rmc))
      matmul4(1:lmr,1:rmc) = 0.0
      if(lmr.ne.0.and.lmc.ne.0.and.rmr.ne.0.and.rmc.ne.0)  then
         Call DGEMM('N','N',lmr,rmc,lmc,1.d0,leftmatrix,lmr,rightmatrix,rmr,0.d0,matmul4,lmr)
      end if
      Call cpu_time(time_end)
      time_mm = time_end - time_begin + time_mm
      end function matmul4

!> @brief Takes two orbital indices and converts them to a composite index
!> @author Christine Schwerdtfeger and David Mazziotti
       function FirstIndex(i,k)

       Implicit None
       integer :: i,k
       integer*8 :: FirstIndex
       integer*8 :: itemp, ktemp

       itemp = i
       ktemp = k
       if(itemp.lt.ktemp) then
         FirstIndex = (ktemp-1)*ktemp/2 + itemp
       else
         FirstIndex = (itemp-1)*itemp/2 + ktemp
       end if

       end function FirstIndex

!> @brief Takes output from FirstIndex and forms composite index
!> @author Christine Schwerdtfeger and David Mazziotti
      function CompositeIndex(ik,jl)

      Implicit NONE

      integer*8 :: ik, jl
      integer*8 :: CompositeIndex

       CompositeIndex = 0

      if(ik.lt.jl) then
        CompositeIndex =  (jl-1)*jl/2 +ik
      else
        CompositeIndex =  (ik-1)*ik/2 + jl
      end if

      end function CompositeIndex

!> @brief Calculates the dimensions of the matrices needed in CalcDeriv
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine CalcReshapeDim(ReshapedMatrixDim,SG,virt,occ,ProductTable,InvPdt)

       Use TypeMod
       Use TimeMod, only : time_calcreshapedim
       Implicit NONE

       type(ReshapedDim) :: ReshapedMatrixDim
       integer :: SG
       integer, intent(IN), dimension(1:2,1:SG) :: occ,virt
       integer, intent(IN), dimension(1:SG,1:SG) :: ProductTable
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: p,q,r,i_begin,i_end,j_begin,j_end,numi,numj,numa,numb,a_begin,a_end,b_begin,b_end
       integer :: k_begin,k_end,numk, symgp, numc, c_begin,c_end,t,u,s,total
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)


       allocate(ReshapedMatrixDim%ijaa(1:SG))
       allocate(ReshapedMatrixDim%ijab(1:SG))
       allocate(ReshapedMatrixDim%ajaa(1:SG))
       allocate(ReshapedMatrixDim%ajab(1:SG))
       allocate(ReshapedMatrixDim%ajba(1:SG))
       allocate(ReshapedMatrixDim%abij_aaaa(1:SG))
       allocate(ReshapedMatrixDim%abij_abab(1:SG))
       allocate(ReshapedMatrixDim%a(1:SG))
       allocate(ReshapedMatrixDim%i(1:SG))
       allocate(ReshapedMatrixDim%ajaa_only(1:SG))
       allocate(ReshapedMatrixDim%ajab_only(1:SG))
       allocate(ReshapedMatrixDim%jka_aaa(1:SG))
       allocate(ReshapedMatrixDim%bci_aaa(1:SG))
       allocate(ReshapedMatrixDim%jka_abb(1:SG))
       allocate(ReshapedMatrixDim%jka_aba(1:SG))
       allocate(ReshapedMatrixDim%bci_aba(1:SG))
       allocate(ReshapedMatrixDim%bci_abb(1:SG))
       allocate(ReshapedMatrixDim%ajaa_t1(1:SG))

       do p=1,SG
          ReshapedMatrixDim%ijaa(p)%row = 0
          ReshapedMatrixDim%ijaa(p)%col = 0
          ReshapedMatrixDim%ijab(p)%row = 0
          ReshapedMatrixDim%ijab(p)%col = 0
          ReshapedMatrixDim%ajaa(p)%row = 0
          ReshapedMatrixDim%ajaa(p)%col = 0
          ReshapedMatrixDim%ajab(p)%row = 0
          ReshapedMatrixDim%ajab(p)%col = 0
          ReshapedMatrixDim%ajba(p)%row = 0
          ReshapedMatrixDim%ajba(p)%col = 0
          ReshapedMatrixDim%abij_aaaa(p)%row = 0
          ReshapedMatrixDim%abij_aaaa(p)%col = 0
          ReshapedMatrixDim%abij_abab(p)%row = 0
          ReshapedMatrixDim%abij_abab(p)%col = 0
          ReshapedMatrixDim%a(p)%row = 0
          ReshapedMatrixDim%a(p)%col = 0
          ReshapedMatrixDim%i(p)%row = 0
          ReshapedMatrixDim%i(p)%col = 0
          ReshapedMatrixDim%ajaa_only(p)%row = 0
          ReshapedMatrixDim%ajaa_only(p)%col = 0
          ReshapedMatrixDim%ajab_only(p)%row = 0
          ReshapedMatrixDim%ajab_only(p)%col = 0
          ReshapedMatrixDim%jka_aaa(p)%row = 0
          ReshapedMatrixDim%jka_aaa(p)%col = 0
          ReshapedMatrixDim%bci_aaa(p)%row = 0
          ReshapedMatrixDim%bci_aaa(p)%col = 0
          ReshapedMatrixDim%jka_abb(p)%row = 0
          ReshapedMatrixdim%jka_abb(p)%col = 0
          ReshapedMatrixDim%jka_aba(p)%row = 0
          ReshapedMatrixdim%jka_aba(p)%col = 0
          ReshapedMatrixDim%bci_aba(p)%row = 0
          ReshapedMatrixdim%bci_aba(p)%col = 0
          ReshapedMatrixDim%bci_abb(p)%row = 0
          ReshapedMatrixDim%bci_abb(p)%col = 0
          ReshapedMatrixDim%ajaa_t1(p)%row = 0
          ReshapedMatrixDim%ajaa_t1(p)%col = 0
       end do

       do symgp = 1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
            i_begin = occ(1,p)
            i_end   = occ(2,p)
            j_begin = occ(1,q)
            j_end   = occ(2,q)
            if(p>q) cycle
            if(i_begin.EQ.j_begin) then
              numj = (j_end-j_begin + 1)
              numi = ((i_end - i_begin + 1) -1)
              ReshapedMatrixDim%ijaa(symgp)%col  = ReshapedMatrixDim%ijaa(symgp)%col + numi*numj/2
            else if(i_begin.LT.j_begin) then
              numi = i_end - i_begin + 1
              numj = j_end - j_begin + 1
              ReshapedMatrixDim%ijaa(symgp)%col  = ReshapedMatrixDim%ijaa(symgp)%col + numi*numj
            else
             continue
            end if
         end do
       end do


       do symgp=1,SG
        do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
             if(p>q) cycle
               a_begin = virt(1,p)
               a_end   = virt(2,p)
               b_begin = virt(1,q)
               b_end   = virt(2,q)
               if(a_begin.EQ.b_begin) then
                 numa = a_end - a_begin + 1
                 numb = (b_end - b_begin + 1) - 1
                 ReshapedMatrixDim%ijaa(symgp)%row = ReshapedMatrixDim%ijaa(symgp)%row + numa*numb/2
               else if(a_begin.LT.b_begin) then
                 numa = a_end - a_begin + 1
                 numb = b_end - b_begin + 1
                 ReshapedMatrixDim%ijaa(symgp)%row = ReshapedMatrixDim%ijaa(symgp)%row + numa*numb
               else
                 continue
               end if
         end do
       end do

       do symgp=1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           numi = i_end - i_begin + 1
           numj = j_end - j_begin + 1
           ReshapedMatrixDim%ijab(symgp)%col = ReshapedMatrixDim%ijab(symgp)%col + numi*numj
         end do
       end do

       do symgp=1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           b_begin = virt(1,q)
           b_end   = virt(2,q)
           numa = a_end - a_begin + 1
           numb = b_end - b_begin + 1
           ReshapedMatrixDim%ijab(symgp)%row = ReshapedMatrixDim%ijab(symgp)%row + numa*numb
         end do
       end do

       do symgp=1,SG
         do p=1,SG
           do q=1,SG
             if(ProductTable(p,q).EQ.symgp)  then
               a_begin = virt(1,p)
               a_end   = virt(2,p)
               j_begin = occ(1,q)
               j_end   = occ(2,q)
               numa = a_end - a_begin + 1
               numj = j_end - j_begin + 1
               ReshapedMatrixDim%ajaa(symgp)%col = ReshapedMatrixDim%ajaa(symgp)%col +  numa*numj
               ReshapedMatrixDim%ajaa(symgp)%row = ReshapedMatrixDim%ajaa(symgp)%row + numa*numj + numa*numj
             end if
           end do
         end do
       end do

       do symgp=1,SG
         do p=1,SG
           do q=1,SG
             if(ProductTable(p,q).EQ.symgp)  then
               a_begin = virt(1,p)
               a_end   = virt(2,p)
               j_begin = occ(1,q)
               j_end   = occ(2,q)
               numa = a_end - a_begin + 1
               numj = j_end - j_begin + 1
               ReshapedMatrixDim%ajaa_only(symgp)%col = ReshapedMatrixDim%ajaa_only(symgp)%col +  numa*numj
               ReshapedMatrixDim%ajaa_only(symgp)%row = ReshapedMatrixDim%ajaa_only(symgp)%row + numa*numj
             end if
           end do
         end do
       end do

       do symgp=1,SG
         do p=1,SG
           do q=1,SG
             if(ProductTable(p,q).EQ.symgp)  then
               a_begin = virt(1,p)
               a_end   = virt(2,p)
               j_begin = occ(1,q)
               j_end   = occ(2,q)
               numa = a_end - a_begin + 1
               numj = j_end - j_begin + 1
               ReshapedMatrixDim%ajab_only(symgp)%col = ReshapedMatrixDim%ajab_only(symgp)%col +  numa*numj
               ReshapedMatrixDim%ajab_only(symgp)%row = ReshapedMatrixDim%ajab_only(symgp)%row + numa*numj
             end if
           end do
         end do
       end do

       do symgp=1,SG
         do p=1,SG
           do q=1,SG
             if(ProductTable(p,q).EQ.symgp)  then
               a_begin = virt(1,p)
               a_end   = virt(2,p)
               j_begin = occ(1,q)
               j_end   = occ(2,q)
               numa = a_end - a_begin + 1
               numj = j_end - j_begin + 1
               ReshapedMatrixDim%ajab(symgp)%row = ReshapedMatrixDim%ajab(symgp)%row +  numa*numj
               ReshapedMatrixDim%ajab(symgp)%col = ReshapedMatrixDim%ajab(symgp)%col +  numa*numj

             end if
           end do
         end do
       end do

       do symgp=1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           numa = a_end - a_begin + 1
           numj = j_end - j_begin + 1
           ReshapedMatrixDim%ajba(symgp)%col = ReshapedMatrixDim%ajba(symgp)%col +  numa*numj
           ReshapedMatrixDim%ajba(symgp)%row = ReshapedMatrixDim%ajba(symgp)%row + numa*numj
         end do
       end do



        do symgp=1,SG
          do t=1,SG
            p = InvPdt(symgp)%upper(t)
            q = InvPdt(symgp)%lower(t)
            a_begin = virt(1,p)
            a_end   = virt(2,p)
            b_begin = virt(1,q)
            b_end   = virt(2,q)
            numa = a_end - a_begin + 1
            numb = b_end - b_begin + 1
            if(b_begin.EQ.a_begin) then
              ReshapedMatrixDim%abij_aaaa(symgp)%row = ReshapedMatrixDim%abij_aaaa(symgp)%row + numa*(numb-1)/2
            else if(a_begin.LT.b_begin) then
              ReshapedMatrixDim%abij_aaaa(symgp)%row = ReshapedMatrixdim%abij_aaaa(symgp)%row + numa*numb
            else
              cycle
            end if
          end do
        end do

       do symgp=1,SG
         do t=1,SG
            p = InvPdt(symgp)%upper(t)
            q = InvPdt(symgp)%lower(t)
            i_begin = occ(1,p)
            i_end   = occ(2,p)
            j_begin = occ(1,q)
            j_end   = occ(2,q)
            numi = i_end - i_begin + 1
            numj = j_end - j_begin + 1
            if(i_begin.EQ.j_begin) then
              ReshapedMatrixDim%abij_aaaa(symgp)%col = ReshapedMatrixDim%abij_aaaa(symgp)%col + numi*(numj-1)/2
            else if(i_begin.LT.j_begin) then
              ReshapedMatrixDim%abij_aaaa(symgp)%col = ReshapedMatrixDim%abij_aaaa(symgp)%col + numi*numj
            else
              continue
            end if
         end do
       end do


        do symgp=1,SG
          do t=1,SG
            p = InvPdt(symgp)%upper(t)
            q = InvPdt(symgp)%lower(t)
            a_begin = virt(1,p)
            a_end   = virt(2,p)
            b_begin = virt(1,q)
            b_end   = virt(2,q)
            numa = a_end - a_begin + 1
            numb = b_end - b_begin + 1
              ReshapedMatrixDim%abij_abab(symgp)%col = ReshapedMatrixdim%abij_abab(symgp)%col + numa*numb
          end do
        end do


       do symgp=1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           numi = i_end - i_begin + 1
           numj = j_end - j_begin + 1
           ReshapedMatrixDim%abij_abab(symgp)%row = ReshapedMatrixDim%abij_abab(symgp)%row + numi*numj
         end do
       end do


       do symgp=1,SG
         a_begin = virt(1,symgp)
         a_end   = virt(2,symgp)
         numa = a_end - a_begin + 1
         ReshapedMatrixDim%a(symgp)%col  = numa
       end do

       do symgp=1,SG
         do p=1,SG
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           do t=1,SG
             q = InvPdt(ProductTable(symgp,p))%upper(t)
             r = InvPdt(ProductTable(symgp,p))%lower(t)
             j_begin = occ(1,q)
             j_end   = occ(2,q)
             c_begin = virt(1,r)
             c_end   = virt(2,r)
             if(j_begin.EQ.i_begin) then
               numj = j_end - j_begin + 1
               numc = c_end - c_begin + 1
               numi = i_end - i_begin + 1
               ReshapedMatrixDim%a(symgp)%row = ReshapedMatrixDim%a(symgp)%row + numc*(numi*(numj-1))/2
             else if(i_begin.LT.j_begin) then
                 numj = j_end - j_begin + 1
                 numc = c_end - c_begin + 1
                 numi = i_end - i_begin + 1
                 ReshapedMatrixDim%a(symgp)%row  = ReshapedMatrixDim%a(symgp)%row  + numc*(numi*numj)
             else
               continue
             end if
           end do
         end do
       end do

      do symgp=1,SG
         do p=1,SG
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           do t=1,SG
             q = InvPdt(ProductTable(symgp,p))%upper(t)
             r = InvPdt(ProductTable(symgp,p))%lower(t)
             j_begin = occ(1,q)
             j_end   = occ(2,q)
             c_begin = virt(1,r)
             c_end   = virt(2,r)
             numj = j_end - j_begin + 1
             numc = c_end - c_begin + 1
             numi = i_end - i_begin + 1
             ReshapedMatrixdim%a(symgp)%row = ReshapedMatrixDim%a(symgp)%row + numc*(numi*numj)
           end do
         end do
       end do

       do symgp=1,SG
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         numi = i_end - i_begin + 1
         ReshapedMatrixDim%i(symgp)%col = numi
       end do


       do symgp=1,SG
         do p=1,SG
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           do t=1,SG
             q = InvPdt(ProductTable(symgp,p))%upper(t)
             r = InvPdt(ProductTable(symgp,p))%lower(t)
             b_begin = virt(1,q)
             b_end   = virt(2,q)
             k_begin = occ(1,r)
             k_end   = occ(2,r)
             if(a_begin.EQ.b_begin) then
               numb = b_end - b_begin + 1
               numk = k_end - k_begin + 1
               numa = a_end - a_begin + 1
               ReshapedMatrixDim%i(symgp)%row = ReshapedMatrixDim%i(symgp)%row  + numk*(numa*(numb-1))/2
             else if(a_begin.LT.b_begin) then
               numb = b_end - b_begin + 1
               numk = k_end - k_begin + 1
               numa = a_end - a_begin + 1
               ReshapedMatrixDim%i(symgp)%row = ReshapedMatrixDim%i(symgp)%row + numk*numa*numb
             else
              continue
             end if
           end do
         end do
       end do

       do symgp=1,SG
         do p=1,SG
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           do t=1,SG
             q = InvPdt(ProductTable(symgp,p))%upper(t)
             r = InvPdt(ProductTable(symgp,p))%lower(t)
             b_begin = virt(1,q)
             b_end   = virt(2,q)
             k_begin = occ(1,r)
             k_end   = occ(2,r)
             numb = b_end - b_begin + 1
             numk = k_end - k_begin + 1
             numa = a_end - a_begin + 1
             ReshapedMatrixDim%i(symgp)%row = ReshapedMatrixDim%i(symgp)%row + numk*numa*numb
           end do
         end do
       end do

       do symgp=1,SG
         b_begin = virt(1,symgp)
         b_end   = virt(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             numa = a_end - a_begin + 1
             numj = j_end - j_begin + 1
             numk = k_end - k_begin + 1
             numb = b_end - b_begin + 1
             if(k_begin.gt.j_begin)  then
               ReshapedMatrixDim%jka_aaa(symgp)%col = ReshapedMatrixDim%jka_aaa(symgp)%col + numa*(numj)*(numk)
             else if(k_begin.eq.j_begin) then
               ReshapedMatrixDim%jka_aaa(symgp)%col = ReshapedMatrixDim%jka_aaa(symgp)%col + numa*(numj)*(numk-1)*0.5
             else
               cycle
             end if
             ReshapedMatrixDim%jka_aaa(symgp)%row = numb
           end do
         end do
       end do


       do symgp=1,SG
         j_begin = occ(1,symgp)
         j_end   = occ(2,symgp)
         numj = j_end - j_begin + 1
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           numc = c_end - c_begin + 1
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             numi = i_end - i_begin + 1
             numb = b_end - b_begin + 1
             ReshapedMatrixDim%bci_aaa(symgp)%row = numj
             if(b_begin.eq.c_begin) then
               ReshapedMatrixDim%bci_aaa(symgp)%col = numi*numb*(numc-1)*0.5 + ReshapedMatrixDim%bci_aaa(symgp)%col
             else if(b_begin.lt.c_begin) then
               ReshapedMatrixDim%bci_aaa(symgp)%col = numi*numb*(numc) + ReshapedMatrixDim%bci_aaa(symgp)%col
             else
               cycle
             end if
           end do
         end do
       end do

       do symgp=1,SG
         b_begin = virt(1,symgp)
         b_end   = virt(2,symgp)
         numb = (b_end - b_begin) + 1
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           numk = (k_end - k_begin) + 1
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             numa = (a_end - a_begin) + 1
             numj = (j_end - j_begin) + 1
             ReshapedMatrixDim%jka_abb(symgp)%col = numj*numk*numa + ReshapedMatrixDim%jka_abb(symgp)%col
             ReshapedMatrixDim%jka_abb(symgp)%row = numb
           end do
         end do
       end do

       do symgp=1,SG
         b_begin = virt(1,symgp)
         b_end   = virt(2,symgp)
         numb = (b_end - b_begin) + 1
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           numk = (k_end - k_begin) + 1
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             numa = (a_end - a_begin) + 1
             numj = (j_end - j_begin) + 1
             ReshapedMatrixDim%jka_aba(symgp)%row = numb
             ReshapedMatrixDim%jka_aba(symgp)%col = numj*numk*numa + ReshapedMatrixDim%jka_aba(symgp)%col
           end do
         end do
       end do

       do symgp=1,SG
         j_begin = occ(1,symgp)
         j_end   = occ(2,symgp)
         numj = (j_end - j_begin) + 1
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           numc = (c_end - c_begin) + 1
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             numb = (b_end - b_begin) + 1
             numi = (i_end - i_begin) + 1
             ReshapedMatrixDim%bci_aba(symgp)%row = numj
             ReshapedMatrixDim%bci_aba(symgp)%col = numb*numc*numi + ReshapedMatrixDim%bci_aba(symgp)%col
           end do
         end do
       end do

       do symgp=1,SG
         j_begin = occ(1,symgp)
         j_end   = occ(2,symgp)
         numj = (j_end - j_begin) + 1
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           numc = (c_end - c_begin) + 1
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             numb = (b_end - b_begin) + 1
             numi = (i_end - i_begin) + 1
             ReshapedMatrixDim%bci_abb(symgp)%row = numj
             ReshapedMatrixDim%bci_abb(symgp)%col = numb*numc*numi + ReshapedMatrixDim%bci_abb(symgp)%col
           end do
         end do
       end do

       do symgp=1,SG
           total = 0
           a_begin = virt(1,symgp)
           a_end   = virt(2,symgp)
           i_begin = occ(1,symgp)
           i_end   = occ(2,symgp)
           numi = i_end - i_begin + 1
           numa = a_end - a_begin + 1
           do p=1,SG
             b_begin = virt(1,p)
             b_end   = virt(2,p)
             j_begin = occ(1,p)
             j_end   = occ(2,p)
             numb = b_end - b_begin + 1
             numj = j_end - j_begin + 1
             total = total + numj*numb*2
             ReshapedMatrixDim%ajaa_t1(symgp)%col = numa*numi
             ReshapedMatrixDim%ajaa_t1(symgp)%row = total
          end do
        end do
        Call CPU_TIME(time_end)
        time_calcreshapedim = time_calcreshapedim + time_end - time_begin
       end subroutine

       subroutine reshape_a(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Use TypeMod;
       Use TimeMod, only : time_a
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat), intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)

       integer :: a,c,i,j,symgp
       integer :: a_begin,a_end,c_begin,c_end,i_begin,i_end,j_begin,j_end
       integer :: p,q,r,s,numa,numc,numi,numj,row,col,t
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)


       do p=1,SG
         allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%a(p)%row,1:ReshapedMatrixDim%a(p)%col))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%a(p)%row,1:ReshapedMatrixDim%a(p)%col))
       end do

      row = 1
       do symgp=1,SG
         maxrow_SG(symgp) = 0
         a_begin = virt(1,symgp)
         a_end   = virt(2,symgp)
         col = 0
         do a=a_begin,a_end
           col = col + 1
           row = 1
           do p=1,SG
             i_begin = occ(1,p)
             i_end   = occ(2,p)
             do i=i_begin,i_end
               do t=1,SG
                 q = InvPdt(ProductTable(symgp,p))%upper(t)
                 r = InvPdt(ProductTable(symgp,p))%lower(t)
                 if(p>q) cycle
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 j_begin = occ(1,q)
                 j_end   = occ(2,q)
                 do j=max(i+1,j_begin),j_end
                   do c=c_begin,c_end
                     Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%aa%m(a,i)%nsym(r,q)%n(c,j)
                     maxrow_SG(symgp) = row
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

      do symgp=1,SG
        a_begin = virt(1,symgp)
        a_end   = virt(2,symgp)
        col = 0
        do a=a_begin,a_end
          col = col + 1
          row = maxrow_SG(symgp)  + 1
          do p=1,SG
            i_begin = occ(1,p)
            i_end   = occ(2,p)
            do i=i_begin,i_end
              do t=1,SG
               q = InvPdt(ProductTable(symgp,p))%upper(t)
               r = InvPdt(ProductTable(symgp,p))%lower(t)
                   c_begin = virt(1,r)
                   c_end   = virt(2,r)
                   j_begin = occ(1,q)
                   j_end   = occ(2,q)
                     do j=j_begin,j_end
                       do c=c_begin,c_end
                         Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%ab%m(a,i)%nsym(r,q)%n(c,j)
                         row = row + 1
                       end do
                     end do
                 end do
               end do
             end do
           end do
         end do

        Call CPU_TIME(time_end)
         time_a = time_end - time_begin + time_a

       end subroutine reshape_a

       subroutine reshape_i(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Use TypeMod;
       Use TimeMod, only : time_i
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat), intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN) :: InvPdt(1:SG)

       integer, dimension(1:SG) :: total_SG_row, total_SG_col
       integer :: i,a,b,k,symgp
       integer :: i_begin,i_end,a_begin,a_end,b_begin,b_end,k_begin,k_end
       integer :: p,q,r,s,numi,numa,numb,numk,row,col,t
       integer, dimension(1:SG) :: maxrow_SG
       integer :: aisym
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)

       do i=1,SG
          maxrow_SG(i) = 0
       end do


       do p=1,SG
          allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%i(p)%row,1:ReshapedMatrixDim%i(p)%col))
          allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%i(p)%row,1:ReshapedMatrixDim%i(p)%col))
       end do

       row = 1
       do symgp=1,SG
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         col = 0
         do i=i_begin,i_end
           col = col + 1
           row = 1
           do p=1,SG
             a_begin = virt(1,p)
             a_end   = virt(2,p)
             aisym = ProductTable(symgp,p)
             do a=a_begin,a_end
               do t=1,SG
                 q = InvPdt(aisym)%upper(t)
                 r = InvPdt(aisym)%lower(t)
                 if(p>r) cycle
                 b_begin = virt(1,r)
                 b_end   = virt(2,r)
                 k_begin = occ(1,q)
                 k_end   = occ(2,q)
                 do k=k_begin,k_end
                   do b=max(a+1,b_begin),b_end
                     Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%aa%m(a,i)%nsym(r,q)%n(b,k)
                     maxrow_SG(symgp) = row
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,SG
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         col = 0
         do i=i_begin,i_end
           col = col + 1
           row = maxrow_SG(symgp) + 1
           do p=1,SG
             a_begin = virt(1,p)
             a_end   = virt(2,p)
             aisym = ProductTable(symgp,p)
             do a=a_begin,a_end
               do t=1,SG
                 q = InvPdt(aisym)%upper(t)
                 r = InvPdt(aisym)%lower(t)
                 b_begin = virt(1,r)
                 b_end   = virt(2,r)
                 k_begin = occ(1,q)
                 k_end   = occ(2,q)
                 do k=k_begin,k_end
                   do b=b_begin,b_end
                     Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%ab%m(a,i)%nsym(r,q)%n(b,k)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       Call CPU_TIME(time_end)
       time_i = time_end - time_begin - time_i
       end subroutine reshape_i

       subroutine reshape_ajaa(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_ajaa
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: a,j,c,k
       integer :: row,col,c_begin,c_end,k_begin,k_end,t,v
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
         allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajaa(p)%row,1:ReshapedMatrixDim%ajaa(p)%col))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajaa(p)%row,1:ReshapedMatrixDim%ajaa(p)%col))
       end do

     row = 1
       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               col = col + 1
               row = 1
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 k_begin = occ(1,s)
                 k_end   = occ(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end

                    Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%aa%m(a,j)%nsym(r,s)%n(c,k)
                    row = row + 1
                    maxrow_SG(symgp) = row
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 col = col + 1
                 row = maxrow_SG(symgp)
                 do v=1,SG
                   r = InvPdt(symgp)%upper(v)
                   s = InvPdt(symgp)%lower(v)
                   c_begin = virt(1,r)
                   c_end   = virt(2,r)
                   k_begin = occ(1,s)
                   k_end   = occ(2,s)
                   do k=k_begin,k_end
                     do c=c_begin,c_end
                       Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%ab%m(a,j)%nsym(r,s)%n(c,k)
                       row = row + 1
                      end do
                    end do
                  end do
                end do
              end do
            end do
          end do

          Call CPU_TIME(time_end)
          time_ajaa = time_end - time_begin + time_ajaa

      end subroutine reshape_ajaa

       subroutine reshape_ajab(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_ajab
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end
       integer, dimension(1:SG) :: total_SG
       integer :: a,j,c,k,t,v
       integer :: row,col,c_begin,c_end,k_begin,k_end
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
         allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajab(p)%row,1:ReshapedMatrixDim%ajab(p)%col))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajab(p)%row,1:ReshapedMatrixDim%ajab(p)%col))
       end do

       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
            do a=a_begin,a_end
              do j=j_begin,j_end
                row = 1
                col = col + 1
                do v=1,SG
                  r = InvPdt(symgp)%upper(v)
                  s = InvPdt(symgp)%lower(v)
                  c_begin = virt(1,r)
                  c_end   = virt(2,r)
                  k_begin = occ(1,s)
                  k_end   = occ(2,s)
                  do k=k_begin,k_end
                    do c=c_begin,c_end
                       Reshapes(symgp)%ReshapedMatrix(row,col) = -1*T2data%ab%m(c,j)%nsym(p,s)%n(a,k)
                      row = row + 1
                      end do
                    end do
                  end do
                end do
              end do
            end do
          end do


         Call CPU_TIME(time_end)
         time_ajab = time_end - time_begin + time_ajab
      end subroutine reshape_ajab

       subroutine reshape_ajba(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_ajba
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end,t,v
       integer, dimension(1:SG) :: total_SG
       integer :: a,j,c,k
       integer :: row,col,c_begin,c_end,k_begin,k_end
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
         allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajba(p)%row,1:ReshapedMatrixDim%ajba(p)%col))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajba(p)%row,1:ReshapedMatrixDim%ajba(p)%col))
       end do

       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
             do a=a_begin,a_end
              do j=j_begin,j_end
                 row = 1
                 col = col + 1
                 do v=1,SG
                   r = InvPdt(symgp)%upper(v)
                   s = InvPdt(symgp)%lower(v)
                   c_begin = virt(1,r)
                   c_end   = virt(2,r)
                   k_begin = occ(1,s)
                   k_end   = occ(2,s)
                    do k=k_begin,k_end
                      do c=c_begin,c_end
                      Reshapes(symgp)%ReshapedMatrix(row,col) = -1*T2data%ab%m(c,j)%nsym(p,s)%n(a,k)
                       row = row + 1
                       end do
                     end do
                   end do
                 end do
               end do
             end do
           end do


         Call CPU_TIME(time_end)
         time_ajba = time_end - time_begin + time_ajba
      end subroutine


       subroutine reshape_ijaa_test(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE InterfaceMod
       USE TypeMod
       USE TimeMod, only : time_ijaa
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), dimension(:) :: InvPdt(1:SG)

       integer :: symgp,p,q,r,s
       integer, dimension(1:SG) :: total_SG_row, total_SG_col
       integer, target :: a,b,i,j
       integer, target :: row,col,i_begin,i_end,j_begin,j_end,a_begin,a_end,b_begin,b_end
       integer :: numa,numb,numi,numj
       integer, pointer :: jptr, bptr
       integer :: t,v
       integer, target :: temp
       integer :: time_initial(8),time_final(8)
       real :: time_begin, time_end

      Call CPU_TIME(time_begin)
       do p=1,SG
          allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ijaa(p)%row,1:ReshapedMatrixDim%ijaa(p)%col))
          allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ijaa(p)%row,1:ReshapedMatrixDim%ijaa(p)%col))
       end do

      do symgp=1,SG
         col = 0
         do t=1,SG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             if(p.GT.q) then
               cycle
             end if
             i_begin = occ(1,p)
             i_end   = occ(2,p)
             j_begin = occ(1,q)
             j_end   = occ(2,q)
             do i=i_begin,i_end
               do j=max(i+1,j_begin),j_end
                 col = col + 1
                 row = 1
                 do v=1,SG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   if(r.GT.s) then
                     cycle
                   end if
                   a_begin = virt(1,r)
                   a_end   = virt(2,r)
                   b_begin = virt(1,s)
                   b_end   = virt(2,s)
                   do a=a_begin,a_end
                     do b=max(a+1,b_begin),b_end
                       Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%aa%m(a,i)%nsym(s,q)%n(b,j)
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do

        Call CPU_TIME(time_end)
        time_ijaa = time_end - time_begin  + time_ijaa

      end subroutine reshape_ijaa_test

       subroutine reshape_ijab_test(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_ijab
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), dimension(:) :: InvPdt(1:SG)

       integer :: symgp,p,q,r,s
       integer, dimension(1:SG) :: total_SG_row, total_SG_col
       integer, target :: a,b,i,j
       integer, target :: row,col,i_begin,i_end,j_begin,j_end,a_begin,a_end,b_begin,b_end
       integer :: numa,numb,numi,numj
       integer, pointer :: jptr, bptr
       integer :: t,v
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
          allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ijab(p)%row,1:ReshapedMatrixDim%ijab(p)%col))
          allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ijab(p)%row,1:ReshapedMatrixDim%ijab(p)%col))
       end do
      do symgp=1,SG
         col = 0
         do t=1,SG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             i_begin = occ(1,p)
             i_end   = occ(2,p)
             j_begin = occ(1,q)
             j_end   = occ(2,q)
             do i=i_begin,i_end
               do j=j_begin,j_end
                 col = col + 1
                 row = 1
                 do v=1,SG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   a_begin = virt(1,r)
                   a_end   = virt(2,r)
                   b_begin = virt(1,s)
                   b_end   = virt(2,s)
                   do a=a_begin,a_end
                     do b=b_begin,b_end
                       Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%ab%m(a,i)%nsym(s,q)%n(b,j)
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do


        Call CPU_TIME(time_end)
         time_ijab = time_end - time_begin + time_ijab
      end subroutine reshape_ijab_test

       subroutine reshape_ajbb(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_ajbb
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: a,j,c,k
       integer :: row,col,c_begin,c_end,k_begin,k_end,t,v
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
         allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajaa(p)%row,1:ReshapedMatrixDim%ajaa(p)%col))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajaa(p)%row,1:ReshapedMatrixDim%ajaa(p)%col))
         maxrow_SG(p) = 0
       end do

       row = 1
       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 col = col + 1
                 row = 1
                 do v=1,SG
                   r = InvPdt(symgp)%upper(v)
                   s = InvPdt(symgp)%lower(v)
                   c_begin = virt(1,r)
                   c_end   = virt(2,r)
                   k_begin = occ(1,s)
                   k_end   = occ(2,s)
                   do k=k_begin,k_end
                     do c=c_begin,c_end
                       Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%ab%m(a,j)%nsym(r,s)%n(c,k)
                       row = row + 1
                       maxrow_SG(symgp) = row
                      end do
                    end do
                  end do
                end do
              end do
            end do
          end do


       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               col = col + 1
               row = maxrow_SG(symgp)
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 k_begin = occ(1,s)
                 k_end   = occ(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                    Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%aa%m(a,j)%nsym(r,s)%n(c,k)
                    row = row + 1
                  end do
                end do
              end do
            end do
          end do
        end do
      end do


        Call CPU_TIME(time_end)
        time_ajbb = time_end - time_begin + time_ajbb

      end subroutine reshape_ajbb

       subroutine reshape_ajaa_transpose(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_ajaa_transpose
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: a,j,c,k
       integer :: row,col,c_begin,c_end,k_begin,k_end,t,v
       integer, dimension(1:SG) :: maxcol_SG
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
         allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajaa(p)%col,1:ReshapedMatrixDim%ajaa(p)%row))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajaa(p)%col,1:ReshapedMatrixDim%ajaa(p)%row))
         maxcol_SG(p) = 0
       end do
       do symgp=1,SG
         row = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               col = 1
               row = row + 1
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 k_begin = occ(1,s)
                 k_end   = occ(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                    Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%aa%m(a,j)%nsym(r,s)%n(c,k)
                     col  = col + 1
                     maxcol_SG(symgp) = col
                  end do
                end do
              end do
            end do
          end do
        end do
      end do



       do symgp=1,SG
         row = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 row = row + 1
                 col = maxcol_SG(symgp)
                 do v=1,SG
                   r = InvPdt(symgp)%upper(v)
                   s = InvPdt(symgp)%lower(v)
                   c_begin = virt(1,r)
                   c_end   = virt(2,r)
                   k_begin = occ(1,s)
                   k_end   = occ(2,s)
                   do k=k_begin,k_end
                    do c=c_begin,c_end
                       Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%ab%m(a,j)%nsym(r,s)%n(c,k)
                       col = col + 1
                      end do
                    end do
                  end do
                end do
              end do
            end do
          end do


          Call CPU_TIME(time_end)
          time_ajaa_transpose = time_end - time_begin + time_ajaa_transpose

      end subroutine reshape_ajaa_transpose

       subroutine reshape_ajbb_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_ajbb_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: a,j,c,k
       integer :: row,col,c_begin,c_end,k_begin,k_end,t,v
       integer, dimension(1:SG) :: maxcol_SG
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)
       do p=1,SG
         maxcol_SG(p) = 0
       end do


       do symgp=1,SG
         row = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 row = row + 1
                 col = 1
                 do v=1,SG
                   r = InvPdt(symgp)%upper(v)
                   s = InvPdt(symgp)%lower(v)
                   c_begin = virt(1,r)
                   c_end   = virt(2,r)
                   k_begin = occ(1,s)
                   k_end   = occ(2,s)
                   do k=k_begin,k_end
                     do c=c_begin,c_end
                       T2deriv%ab%m(a,j)%nsym(r,s)%n(c,k) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(a,j)%nsym(r,s)%n(c,k)
                       col = col + 1
                       maxcol_SG(symgp) = col
                      end do
                    end do
                  end do
                end do
              end do
            end do
          end do


       do symgp=1,SG
         row = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               row = row + 1
               col = maxcol_SG(symgp)
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 k_begin = occ(1,s)
                 k_end   = occ(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                        T2deriv%aa%m(a,j)%nsym(r,s)%n(c,k) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%aa%m(a,j)%nsym(r,s)%n(c,k)
                    col = col + 1
                  end do
                end do
              end do
            end do
          end do
        end do
      end do


       Call CPU_TIME(time_end)
       time_ajbb_inverse = time_end - time_begin + time_ajbb_inverse

      end subroutine reshape_ajbb_inverse

       subroutine reshape_ajaa_transpose_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_ajaa_transpose_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: a,j,c,k
       integer :: row,col,c_begin,c_end,k_begin,k_end,t,v
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)




       do p=1,SG
         maxrow_SG(p) = 0
       end do

       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               col = col + 1
               row = 1
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 k_begin = occ(1,s)
                 k_end   = occ(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                    T2deriv%aa%m(a,j)%nsym(r,s)%n(c,k) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%aa%m(a,j)%nsym(r,s)%n(c,k)
                     row  = row + 1
                     maxrow_SG(symgp) = row
                  end do
                end do
              end do
            end do
          end do
        end do
      end do



       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 col = col + 1
                 row = maxrow_SG(symgp)
                 do v=1,SG
                   r = InvPdt(symgp)%upper(v)
                   s = InvPdt(symgp)%lower(v)
                   c_begin = virt(1,r)
                   c_end   = virt(2,r)
                   k_begin = occ(1,s)
                   k_end   = occ(2,s)
                   do k=k_begin,k_end
                    do c=c_begin,c_end
                        T2deriv%ab%m(a,j)%nsym(r,s)%n(c,k) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(a,j)%nsym(r,s)%n(c,k)
                       row = row + 1
                      end do
                    end do
                  end do
                end do
              end do
            end do
          end do


       Call CPU_TIME(time_end)

      end subroutine reshape_ajaa_transpose_inverse

!> @brief Builds the product table for Abelian point groups
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine MakeProductTable(PointGroup,ProductTable,InvPdt,numSG)
       Use TypeMod
       Use TimeMod, only : time_makeproducttable
       Implicit None

       character(len=3), intent(IN) :: PointGroup
       integer, intent(OUT), allocatable, dimension(:,:) :: ProductTable
       type(symmetry), allocatable, dimension(:) :: InvPdt
       integer, intent(inout) :: numSG

       integer :: counter,i,j,k
       integer, dimension(1:8,1:8) :: MasterProductTable
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)

       MasterProductTable(1,:) = [1,2,3,4,5,6,7,8]
       MasterProductTable(2,:) = [2,1,4,3,6,5,8,7]
       MasterProductTable(3,:) = [3,4,1,2,7,8,5,6]
       MasterProductTable(4,:) = [4,3,2,1,8,7,6,5]
       MasterProductTable(5,:) = [5,6,7,8,1,2,3,4]
       MasterProductTable(6,:) = [6,5,8,7,2,1,4,3]
       MasterProductTable(7,:) = [7,8,5,6,3,4,1,2]
       MasterProductTable(8,:) = [8,7,6,5,4,3,2,1]


       select case (PointGroup)
       case ("C1")
         numSG = 1
         allocate(ProductTable(1:numSG,1:numSG))
         allocate(InvPdt(1))
         allocate(InvPdt(1)%upper(1))
         allocate(InvPdt(1)%lower(1))
         InvPdt(1)%upper = 1
         InvPdt(1)%lower = 1
         ProductTable(1:numSG, 1:numSG) = MasterProductTable(1:numSG,1:numSG)
       case ("CI")
         numSG = 2
         allocate(ProductTable(1:numSG,1:numSG))
         allocate(InvPdt(1:numSG))
         do counter=1,numSG
            allocate(InvPdt(counter)%upper(1:numSG))
            allocate(InvPdt(counter)%lower(1:numSG))
         end do
         ProductTable(1:numSG,1:numSG) = MasterProductTable(1:numSG,1:numSG)
         do counter=1,numSG
           k=1
           do i=1,numSG
             do j=1,numSG
               if(ProductTable(i,j).EQ.counter) then
                  InvPdt(counter)%upper(k)=i
                  InvPdt(counter)%lower(k)=j
                  k=k+1
               end if
             end do
           end do
         end do

       case ("CS")
         numSG = 2
         allocate(ProductTable(1:numSG,1:numSG))
         allocate(InvPdt(1:numSG))
         do counter=1,numSG
            allocate(InvPdt(counter)%upper(1:numSG))
            allocate(InvPdt(counter)%lower(1:numSG))
         end do
         ProductTable(1:numSG,1:numSG) = MasterProductTable(1:numSG,1:numSG)
         do counter=1,numSG
           k=1
           do i=1,numSG
             do j=1,numSG
               if(ProductTable(i,j).EQ.counter) then
                  InvPdt(counter)%upper(k)=i
                  InvPdt(counter)%lower(k)=j
                  k=k+1
               end if
             end do
          end do
        end do

       case ("C2")
         numSG = 2
         allocate(ProductTable(1:numSG,1:numSG))
         allocate(InvPdt(1:numSG))
         do counter=1,numSG
            allocate(InvPdt(counter)%upper(1:numSG))
            allocate(InvPdt(counter)%lower(1:numSG))
         end do
         ProductTable(1:numSG,1:numSG) = MasterProductTable(1:numSG,1:numSG)
         do counter=1,numSG
           k=1
           do i=1,numSG
             do j=1,numSG
               if(ProductTable(i,j).EQ.counter) then
                  InvPdt(counter)%upper(k)=i
                  InvPdt(counter)%lower(k)=j
                  k=k+1
               end if
             end do
          end do
        end do

       case ("C2V")
          numSG = 4
          allocate(ProductTable(1:numSG,1:numSG))
          allocate(InvPdt(1:numSG))
          do counter = 1,numSG
            allocate(InvPdt(counter)%upper(1:numSG))
            allocate(InvPdt(counter)%lower(1:numSG))
         end do
         ProductTable(1:numSG,1:numSG) = MasterProductTable(1:numSG,1:numSG)
         do counter=1,numSG
           k=1
           do i=1,numSG
             do j=1,numSG
               if(ProductTable(i,j).EQ.counter) then
                  InvPdt(counter)%upper(k)=i
                  InvPdt(counter)%lower(k)=j
                  k=k+1
               end if
             end do
          end do
        end do

      case ("D2")
          numSG = 4
          allocate(ProductTable(1:numSG,1:numSG))
          allocate(InvPdt(1:numSG))
          do counter = 1,numSG
            allocate(InvPdt(counter)%upper(1:numSG))
            allocate(InvPdt(counter)%lower(1:numSG))
         end do
         ProductTable(1:numSG,1:numSG) = MasterProductTable(1:numSG,1:numSG)
         do counter=1,numSG
           k=1
           do i=1,numSG
             do j=1,numSG
               if(ProductTable(i,j).EQ.counter) then
                  InvPdt(counter)%upper(k)=i
                  InvPdt(counter)%lower(k)=j
                  k=k+1
               end if
             end do
          end do
        end do

      case("C2H")
          numSG = 4
          allocate(ProductTable(1:numSG,1:numSG))
          allocate(InvPdt(1:numSG))
          do counter = 1,numSG
            allocate(InvPdt(counter)%upper(1:numSG))
            allocate(InvPdt(counter)%lower(1:numSG))
         end do
         ProductTable(1:numSG,1:numSG) = MasterProductTable(1:numSG,1:numSG)
         do counter=1,numSG
           k=1
           do i=1,numSG
             do j=1,numSG
               if(ProductTable(i,j).EQ.counter) then
                  InvPdt(counter)%upper(k)=i
                  InvPdt(counter)%lower(k)=j
                  k=k+1
               end if
             end do
          end do
        end do

        case("D2H")
          numSG = 8
          allocate(ProductTable(1:numSG,1:numSG))
          allocate(InvPdt(1:numSG))
          do counter = 1,numSG
            allocate(InvPdt(counter)%upper(1:numSG))
            allocate(InvPdt(counter)%lower(1:numSG))
         end do
         ProductTable(1:numSG,1:numSG) = MasterProductTable(1:numSG,1:numSG)
         do counter=1,numSG
           k=1
           do i=1,numSG
             do j=1,numSG
               if(ProductTable(i,j).EQ.counter) then
                  InvPdt(counter)%upper(k)=i
                  InvPdt(counter)%lower(k)=j
                  k=k+1
               end if
             end do
          end do
        end do

      case default
          write(*,*) ' '
          write(*,*) 'ERROR.'
          write(*,*) ' '
          write(*,*) 'This is not an abelian symmetry group'
          write(*,*) 'Abelian symmetry groups supported are:'
          write(*,*) 'C1  Ci  Cs  C2  C2v  C2h  D2h D2'
          stop
      end select


       Call CPU_TIME(time_end)
       time_makeproducttable = time_makeproducttable + time_end - time_begin

       end subroutine MakeProductTable

!> @brief Converts orbital symmetry labels from characters to integers
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine IrreptoInt(PointGroup,Convert_char,numSG)
       Use TypeMod
       Use TimeMod, only : time_irreptoint
       Implicit None

       character(len=3), intent(OUT), allocatable, dimension(:) :: Convert_char
       character(len=3), intent(IN) :: PointGroup
       integer, intent(OUT) :: numSG
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)


       select case (PointGroup)
       case ("C1")
         numSG = 1
         allocate(Convert_char(1:numSG))
         Convert_char(1) = 'A'
       case ("CI")
         numSG = 2
         allocate(Convert_char(1:numSG))
         Convert_char(1) = 'AG'
         Convert_char(2) = 'AU'
       case ("CS")
         numSG = 2
         allocate(Convert_char(1:numSG))
         Convert_char(1) = "A'"
         Convert_char(2) = "A''"
       case ("C2")
         numSG = 2
         allocate(Convert_char(1:numSG))
         Convert_char(1) = 'A'
         Convert_char(2) = 'B'
       case ("C2V")
          numSG = 4
          allocate(Convert_char(1:numSG))
          Convert_char(1) = 'A1'
          Convert_char(2) = 'A2'
          Convert_char(3) = 'B1'
          Convert_char(4) = 'B2'
      case ("D2")
          numSG = 4
          allocate(Convert_char(1:numSG))
          Convert_char(1) = 'A'
          Convert_char(2) = 'B1'
          Convert_char(3) = 'B2'
          Convert_char(4) = 'B3'
      case("C2H")
          numSG = 4
          allocate(Convert_char(1:numSG))
          Convert_char(1) = 'AG'
          Convert_char(2) = 'BG'
          Convert_char(3) = 'AU'
          Convert_char(4) = 'BU'
        case("D2H")
          numSG = 8
          allocate(Convert_char(1:numSG))
          Convert_char(1) = 'AG'
          Convert_char(2) = 'B1G'
          Convert_char(3) = 'B2G'
          Convert_char(4) = 'B3G'
          Convert_char(5) = 'AU'
          Convert_char(6) = 'B1U'
          Convert_char(7) = 'B2U'
          Convert_char(8) = 'B3U'
      case default
          write(*,*) 'This is not an abelian symmetry group'
      end select



       Call CPU_TIME(time_end)
       time_irreptoint = time_irreptoint + time_end - time_begin

       end subroutine IrreptoInt

!> @brief Builds and stores the K2 and K1 matrices
!> @author Christine Schwerdtfeger and David Mazziotti
      subroutine BuildK2K1(occ,virt,numSG,InvPdt,TwoIntsCompact,OneInts,ReshapedMatrixDim,K2,K1,ProductTable,K1TwoInts,numocc,numvirt,TwoInts)
      Use TypeMod
      Use TimeMod, only : time_buildk2k1
      Use InterfaceMod
      Implicit None

      integer, intent(IN), allocatable, dimension(:,:) :: occ, virt
      integer, intent(IN) :: numSG
      type(symmetry), allocatable, dimension(:) :: InvPdt
      real(8), allocatable, dimension(:,:,:,:) :: TwoInts
      real(8), intent(IN), allocatable, dimension(:,:) :: OneInts
      real(8), allocatable, dimension(:) :: TwoIntsCompact
      type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
      type(spin) :: K2(1:2,1:2,1:2,1:2)
      type(spin) :: K1(1:2,1:2)
      integer, dimension(1:numSG,1:numSG) :: ProductTable
      type(spin) :: K1TwoInts(1:2,1:2)

      integer :: i,j,k,l,i_begin,i_end,j_begin,j_end,k_begin,k_end,l_begin,l_end
      integer :: symgp, t,v,p,q,r,s
      integer :: row, col,numi,numa,numk
      integer :: a,b,c,d,a_begin,a_end,b_begin,b_end,c_begin,c_end,d_begin,d_end
      integer :: u
      integer :: begindim,enddim,enddim_occ
      real(8) :: test(1:2,1:2)
      real :: time_begin, time_end
      integer :: numocc,numvirt
      type(InverseBasis), allocatable, dimension(:) :: InverseBasisK1
      integer :: counter
      real(8) :: integral
      integer*8 :: index1,index2,compindex1,compindex2
      Call cpu_time(time_begin)
      allocate(K2(1,1,1,1)%aa%irrep(1:numSG))
      allocate(K2(2,2,2,2)%aa%irrep(1:numSG))
      allocate(K2(1,2,1,2)%aa%irrep(1:numSG))
      allocate(K2(1,1,2,2)%aa%irrep(1:numSG))
      allocate(K2(1,1,1,1)%ab%irrep(1:numSG))
      allocate(K2(2,2,2,2)%ab%irrep(1:numSG))
      allocate(K2(1,2,1,2)%ab%irrep(1:numSG))
      allocate(K2(1,1,2,2)%ab%irrep(1:numSG))
      allocate(K2(1,2,2,1)%ab%irrep(1:numSG))
      allocate(K2(1,1,1,2)%aa%irrep(1:numSG))
      allocate(K2(2,2,1,2)%aa%irrep(1:numSG))
      allocate(K2(1,1,1,2)%ab%irrep(1:numSG))
      allocate(K2(1,1,2,1)%ab%irrep(1:numSG))
      allocate(K2(2,2,1,2)%ab%irrep(1:numSG))
      allocate(K2(2,2,2,1)%ab%irrep(1:numSG))
      allocate(K1(1,1)%aa%irrep(1:numSG))
      allocate(K1(2,2)%aa%irrep(1:numSG))
      allocate(K1(1,2)%aa%irrep(1:numSG))
      allocate(K1TwoInts(1,1)%aa%irrep(1:numSG))
      allocate(K1TwoInts(2,2)%aa%irrep(1:numSG))
      allocate(K1TwoInts(1,2)%aa%irrep(1:numSG))
      do i=1,numSG
        allocate(K2(1,1,1,1)%aa%irrep(i)%block(1:ReshapedMatrixDim%ijaa(i)%col,1:ReshapedMatrixDim%ijaa(i)%col))
        allocate(K2(2,2,2,2)%aa%irrep(i)%block(1:ReshapedMatrixDim%ijaa(i)%row,1:ReshapedMatrixDim%ijaa(i)%row))
        allocate(K2(1,2,1,2)%aa%irrep(i)%block(1:ReshapedMatrixDim%ajaa(i)%col,1:ReshapedMatrixDim%ajaa(i)%col))
        allocate(K2(1,1,2,2)%aa%irrep(i)%block(1:ReshapedMatrixDim%ijaa(i)%row,1:ReshapedMatrixDim%ijaa(i)%col))
      end do
       do i=1,numSG
        allocate(K2(1,1,1,1)%ab%irrep(i)%block(1:ReshapedMatrixDim%ijab(i)%col,1:ReshapedMatrixDim%ijab(i)%col))
        allocate(K2(2,2,2,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%ijab(i)%row,1:ReshapedMatrixDim%ijab(i)%row))
        allocate(K2(1,2,1,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%ajab(i)%col,1:ReshapedMatrixDim%ajab(i)%col))
        allocate(K2(1,1,2,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%ijab(i)%row,1:ReshapedMatrixDim%ijab(i)%col))
        allocate(K2(1,2,2,1)%ab%irrep(i)%block(1:ReshapedMatrixDim%ajaa_only(i)%row,1:ReshapedMatrixDim%ajaa_only(i)%col))
        numi = (occ(2,i) - occ(1,i)) + 1
        numa = (virt(2,i) - virt(1,i)) + 1
        allocate(K2(1,1,1,2)%aa%irrep(i)%block(1:ReshapedMatrixDim%jka_aaa(i)%col,1:numi))
        allocate(K2(2,2,1,2)%aa%irrep(i)%block(1:ReshapedMatrixDim%bci_aaa(i)%col,1:numa))
        allocate(K2(1,1,1,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%jka_abb(i)%col,1:numi))
        allocate(K2(1,1,2,1)%ab%irrep(i)%block(1:ReshapedMatrixDim%jka_aba(i)%col,1:numi))
        allocate(K2(2,2,1,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%bci_aba(i)%col,1:numa))
        allocate(K2(2,2,2,1)%ab%irrep(i)%block(1:ReshapedMatrixDim%bci_abb(i)%col,1:numa))
      end do

       do t=1,numSG
         i_begin = occ(1,t)
         i_end   = occ(2,t)
         a_begin = virt(1,t)
         a_end   = virt(2,t)
         numa = a_end - a_begin + 1
         numi = i_end - i_begin + 1
         allocate(K1(1,1)%aa%irrep(t)%block(i_begin:i_end,i_begin:i_end))
         allocate(K1(2,2)%aa%irrep(t)%block(a_begin:a_end,a_begin:a_end))
         allocate(K1(1,2)%aa%irrep(t)%block(1:numi*numa,1:1))
         allocate(K1TwoInts(1,1)%aa%irrep(t)%block(i_begin:i_end,i_begin:i_end))
         allocate(K1TwoInts(2,2)%aa%irrep(t)%block(a_begin:a_end,a_begin:a_end))
         allocate(K1TwoInts(1,2)%aa%irrep(t)%block(1:numa*numi,1:1))
         K1(1,1)%aa%irrep(t)%block(i_begin:i_end,i_begin:i_end) = 0.0D0
         K1(2,2)%aa%irrep(t)%block(a_begin:a_end,a_begin:a_end) = 0.0D0
         K1(1,2)%aa%irrep(t)%block(1:numa*numi,1:1) = 0.0D0
         K1TwoInts(1,1)%aa%irrep(t)%block(i_begin:i_end,i_begin:i_end) = 0.0D0
         K1TwoInts(2,2)%aa%irrep(t)%block(a_begin:a_end,a_begin:a_end) = 0.0D0
         K1TwoInts(1,2)%aa%irrep(t)%block(1:numa*numi,1:1) = 0.0D0
      end do

       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) cycle
                 k_begin = occ(1,r)
                 k_end   = occ(2,r)
                 l_begin = occ(1,s)
                 l_end   = occ(2,s)
                 do k=k_begin,k_end
                   do l=max(k+1,l_begin),l_end
                     index1 = FirstIndex(i,k)
                     index2 = FirstIndex(j,l)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(i,l)
                     index2 = FirstIndex(j,k)
                     compindex2 = CompositeIndex(index1,index2)
                     K2(1,1,1,1)%aa%irrep(symgp)%block(row,col) = (TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2))
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           b_begin = virt(1,q)
           b_end   = virt(2,q)
           do a=a_begin,a_end
             do b=max(a+1,b_begin),b_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) cycle
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 d_begin = virt(1,s)
                 d_end   = virt(2,s)
                 do c=c_begin,c_end
                   do d=max(c+1,d_begin),d_end
                     index1 = FirstIndex(a,c)
                     index2 = FirstIndex(b,d)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(a,d)
                     index2 = FirstIndex(b,c)
                     compindex2 = CompositeIndex(index1,index2)
                      K2(2,2,2,2)%aa%irrep(symgp)%block(row,col) = (TwoIntsCompact(compindex1)- TwoIntsCompact(compindex2))
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp = 1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) cycle
                 a_begin = virt(1,r)
                 a_end   = virt(2,r)
                 b_begin = virt(1,s)
                 b_end   = virt(2,s)
                 do a=a_begin,a_end
                   do b=max(a+1,b_begin),b_end
                     index1 = FirstIndex(i,a)
                     index2 = FirstIndex(j,b)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(i,b)
                     index2 = FirstIndex(j,a)
                     compindex2 = CompositeIndex(index1,index2)
                      K2(1,1,2,2)%aa%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)- TwoIntsCompact(compindex2)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt(1,r)
                 b_end   = virt(2,r)
                 i_begin = occ(1,s)
                 i_end   = occ(2,s)
                 do i=i_begin,i_end
                   do b=b_begin,b_end
                      index1 = FirstIndex(i,j)
                      index2 = FirstIndex(a,b)
                      compindex1 = CompositeIndex(index1,index2)
                      index1 = FirstIndex(i,b)
                      index2 = FirstIndex(a,j)
                      compindex2 = CompositeIndex(index1,index2)
                      K2(1,2,1,2)%aa%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)-TwoIntsCompact(compindex2)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 k_begin = occ(1,r)
                 k_end   = occ(2,r)
                 l_begin = occ(1,s)
                 l_end   = occ(2,s)
                 do k=k_begin,k_end
                   do l=l_begin,l_end
                     index1 = FirstIndex(i,k)
                     index2 = FirstIndex(j,l)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(1,1,1,1)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           b_begin = virt(1,q)
           b_end   = virt(2,q)
           do a=a_begin,a_end
             do b=b_begin,b_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 d_begin = virt(1,s)
                 d_end   = virt(2,s)
                 do c=c_begin,c_end
                   do d=d_begin,d_end
                     index1 = FirstIndex(a,c)
                     index2 = FirstIndex(b,d)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(2,2,2,2)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp = 1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 a_begin = virt(1,r)
                 a_end   = virt(2,r)
                 b_begin = virt(1,s)
                 b_end   = virt(2,s)
                 do a=a_begin,a_end
                   do b=b_begin,b_end
                     index1 = FirstIndex(i,a)
                     index2 = FirstIndex(j,b)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(1,1,2,2)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do a=a_begin,a_end
             do j=j_begin,j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt(1,r)
                 b_end   = virt(2,r)
                 i_begin = occ(1,s)
                 i_end   = occ(2,s)
                 do b=b_begin,b_end
                   do i=i_begin,i_end
                     index1 = FirstIndex(i,j)
                     index2 = FirstIndex(a,b)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(1,2,1,2)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = 0
           do t=1,numSG
              p = InvPdt(symgp)%upper(t)
              q = InvPdt(symgp)%lower(t)
              a_begin = virt(1,p)
              a_end   = virt(2,p)
              j_begin = occ(1,q)
              j_end   = occ(2,q)
              do j=j_begin,j_end
                do a=a_begin,a_end
                  col = col + 1
                  row = 1
                  do v=1,numSG
                     r = InvPdt(symgp)%upper(v)
                     s = InvPdt(symgp)%lower(v)
                     b_begin = virt(1,r)
                     b_end   = virt(2,r)
                     i_begin = occ(1,s)
                     i_end   = occ(2,s)
                     do i=i_begin,i_end
                       do b=b_begin,b_end
                         index1 = FirstIndex(a,j)
                         index2 = FirstIndex(i,b)
                         compindex1 = CompositeIndex(index1,index2)
                          K2(1,2,2,1)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                         row = row + 1
                       end do
                    end do
                  end do
                end do
              end do
           end do
        end do
       do symgp=1,numSG
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         j_begin = occ(1,symgp)
         j_end   = occ(2,symgp)
         do i=i_begin,i_end
           do j=j_begin,j_end
             K1(1,1)%aa%irrep(symgp)%block(i,j) = OneInts(i,j)
             K1(1,1)%aa%irrep(symgp)%block(j,i) = OneInts(j,i)
           end do
         end do
       end do

       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) continue
                 k_begin = occ(1,r)
                 k_end   = occ(2,r)
                 l_begin = occ(1,s)
                 l_end   = occ(2,s)
                 do k=k_begin,k_end
                   do l=max(k+1,l_begin),l_end
                       index1 = FirstIndex(i,k)
                       index2 = FirstIndex(j,l)
                       compindex1 = CompositeIndex(index1,index2)
                       index1 = FirstIndex(i,l)
                       index2 = FirstIndex(j,k)
                       compindex2 = CompositeIndex(index1,index2)
                     if(j==l.and.ProductTable(p,r)==1) then
                        K1TwoInts(1,1)%aa%irrep(p)%block(i,k) = 2*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%aa%irrep(p)%block(i,k)
                       if(i.ne.k) then
                       end if
                     end if
                     if(i==l.and.ProductTable(q,r)==1) then
                        K1TwoInts(1,1)%aa%irrep(q)%block(j,k) = 2*(-1*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2))) + K1TwoInts(1,1)%aa%irrep(q)%block(j,k)

                       if(k.ne.j) then
                       end if
                     end if
                     if(j==k.and.ProductTable(p,s)==1) then
                       K1TwoInts(1,1)%aa%irrep(p)%block(i,l) = 2*(-1*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2))) + K1TwoInts(1,1)%aa%irrep(p)%block(i,l)

                       if(l.ne.i) then
                       end if
                     end if
                     if(i==k.and.ProductTable(q,s)==1) then
                        K1TwoInts(1,1)%aa%irrep(q)%block(j,l) = 2*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%aa%irrep(q)%block(j,l)
                      if(l.ne.j) then
                      end if
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 k_begin = occ(1,r)
                 k_end   = occ(2,r)
                 l_begin = occ(1,s)
                 l_end   = occ(2,s)
                 do k=k_begin,k_end
                   do l=l_begin,l_end
                     index1 = FirstIndex(i,k)
                     index2 = FirstIndex(j,l)
                     compindex1 = CompositeIndex(index1,index2)
                     if(j==l.and.ProductTable(p,r)==1) then
                        K1TwoInts(1,1)%aa%irrep(p)%block(i,k) = TwoIntsCompact(compindex1) + K1TwoInts(1,1)%aa%irrep(p)%block(i,k)

                       if(k.ne.i) then
                       end if
                     end if
                     if(i==k.and.ProductTable(q,s)==1) then
                       K1TwoInts(1,1)%aa%irrep(q)%block(j,l) = TwoIntsCompact(compindex1) + K1TwoInts(1,1)%aa%irrep(q)%block(j,l)
                       if(l.ne.j) then
                       end if
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do



       do symgp=1,numSG
         a_begin = virt(1,symgp)
         a_end   = virt(2,symgp)
         b_begin = virt(1,symgp)
         b_end   = virt(2,symgp)
         do a=a_begin,a_end
           do b=b_begin,b_end
             K1(2,2)%aa%irrep(symgp)%block(a,b) = OneInts(a,b)
             K1(2,2)%aa%irrep(symgp)%block(b,a) = OneInts(b,a)
           end do
         end do
       end do

      do symgp=1,numSG
        a_begin = virt(1,symgp)
        a_end   = virt(2,symgp)
        i_begin = occ(1,symgp)
        i_end   = occ(2,symgp)
        row = 1
        col = 1
        do i=i_begin,i_end
          do a=a_begin,a_end
            K1(1,2)%aa%irrep(symgp)%block(row,col) = OneInts(i,a)
            row = row + 1
          end do
        end do
      end do


       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do a=a_begin,a_end
             do j=j_begin,j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt(1,r)
                 b_end   = virt(2,r)
                 i_begin = occ(1,s)
                 i_end   = occ(2,s)
                 do b=b_begin,b_end
                   do i=i_begin,i_end
                     if(i==j.and.ProductTable(p,r)==1) then
                       index1 = FirstIndex(i,j)
                       index2 = FirstIndex(a,b)
                       compindex1 = CompositeIndex(index1,index2)
                       index1 = FirstIndex(i,b)
                       index2 = FirstIndex(a,j)
                       compindex2 = CompositeIndex(index1,index2)
                        K1TwoInts(2,2)%aa%irrep(p)%block(a,b) = 2*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(2,2)%aa%irrep(p)%block(a,b)
                       K1TwoInts(2,2)%aa%irrep(p)%block(a,b) = 2*TwoIntsCompact(compindex1) + K1TwoInts(2,2)%aa%irrep(p)%block(a,b)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
          col = 1
          row = 0
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                    row = row + 1
                    col = 1
                   do i=i_begin,i_end
                     index1 = FirstIndex(j,i)
                     index2 = FirstIndex(k,a)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(j,a)
                     index2 = FirstIndex(k,i)
                     compindex2 = CompositeIndex(index1,index2)
                     K2(1,1,1,2)%aa%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
          col = 1
          row = 0
         a_begin = virt(1,symgp)
         a_end   = virt(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=max(c_begin,b+1),c_end
                    row = row + 1
                    col = 1
                   do a=a_begin,a_end
                     index1 = FirstIndex(b,i)
                     index2 = FirstIndex(c,a)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(b,a)
                     index2 = FirstIndex(c,i)
                     compindex2 = CompositeIndex(index1,index2)
                     K2(2,2,1,2)%aa%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)
                    col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
          row = 0
          col = 1
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do k=k_begin,k_end
                 do a=a_begin,a_end
                   col = 1
                   row = row + 1
                   do i=i_begin,i_end
                     index1 = FirstIndex(j,i)
                     index2 = FirstIndex(k,a)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(1,1,1,2)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)

                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
          row = 0
          col = 1
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=k_begin,k_end
                    row = row + 1
                    col = 1
                   do i=i_begin,i_end
                     index1 = FirstIndex(j,a)
                     index2 = FirstIndex(k,i)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(1,1,2,1)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                     col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
          row = 0
          col = 1
         a_begin = virt(1,symgp)
         a_end   = virt(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=c_begin,c_end
                    col = 1
                    row = row + 1
                   do a=a_begin,a_end
                     index1 = FirstIndex(b,i)
                     index2 = FirstIndex(c,a)
                     compindex1 = CompositeIndex(index1,index2)
                     K2(2,2,1,2)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
          row = 0
          col = 1
         a_begin = virt(1,symgp)
         a_end   = virt(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             do b=b_begin,b_end
               do i=i_begin,i_end
                 do c=c_begin,c_end
                    col = 1
                    row = row + 1
                   do a=a_begin,a_end
                     index1 = FirstIndex(b,a)
                     index2 = FirstIndex(c,i)
                     compindex1 = CompositeIndex(index1,index2)
                     K2(2,2,2,1)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
allocate(InverseBasisK1(1:numSG))
do symgp=1,numSG
  counter = 1
  i_begin = occ(1,symgp)
  i_end   = occ(2,symgp)
  a_begin = virt(1,symgp)
  a_end   = virt(2,symgp)
  allocate(InverseBasisK1(symgp)%basis(i_begin:i_end,a_begin:a_end))
  do i=i_begin,i_end
    do a=a_begin,a_end
      InverseBasisK1(symgp)%basis(i,a) = counter
      counter = counter + 1
    end do
  end do
end do



       do symgp=1,numSG
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         numi = i_end - i_begin + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           numk = k_end - k_begin + 1
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                   do i=i_begin,i_end
                     index1 = FirstIndex(i,j)
                     index2 = FirstIndex(a,k)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(i,k)
                     index2 = FirstIndex(a,j)
                     compindex2 = CompositeIndex(index1,index2)
                     if(i.eq.j.and.ProductTable(r,q).eq.1) then
                        K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(k,a),1) = 2*2*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(k,a),1)

                     end if
                     if(i.eq.k.and.ProductTable(s,r).eq.1) then
                       K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(j,a),1) =-2*2*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(j,a),1)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do


       do symgp=1,numSG
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do k=k_begin,k_end
                 do a=a_begin,a_end
                   do i=i_begin,i_end
                     if(i.eq.j.and.ProductTable(q,r).eq.1) then
                       index1 = FirstIndex(j,i)
                       index2 = FirstIndex(k,a)
                       compindex1 = CompositeIndex(index1,index2)
                        K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(k,a),1) =2*TwoIntsCompact(compindex1) + K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(k,a),1)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=k_begin,k_end
                   do i=i_begin,i_end
                     if(i.eq.k.and.ProductTable(r,s).eq.1) then
                       index1 = FirstIndex(j,a)
                       index2 = FirstIndex(k,i)
                       compindex1 = CompositeIndex(index1,index2)
                       K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(j,a),1) = 2*TwoIntsCompact(compindex1) + K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(j,a),1)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
         allocate(TwoInts(1:numocc,1:numocc,numocc+1:numvirt+numocc,numocc+1:numvirt+numocc))
         TwoInts(1:numocc,1:numocc,numocc+1:numocc+numvirt,numocc+1:numocc+numvirt) = 0.0
         do i=1,numocc
           do j=1,numocc
             do a=numocc+1,numocc+numvirt
               do b=numocc+1,numocc+numvirt
                 index1 = FirstIndex(i,a)
                 index2 = FirstIndex(j,b)
                 compindex1 = CompositeIndex(index1,index2)
                 integral = TwoIntsCompact(compindex1)
                 TwoInts(i,j,a,b) = integral
                 TwoInts(j,i,b,a) = integral
               end do
             end do
           end do
        end do
        deallocate(TwoIntsCompact)

Call cpu_time(time_end)
   time_buildk2k1 = time_buildk2k1 + time_end - time_begin

       end subroutine BuildK2K1

!> @brief Builds the storage arrays for optimized parameters
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine DataStructure(T2data,numOcc,numVirt,InvPdt,numSG,occ,virt,ProductTable,SymO,SymV,T2deriv,flag,numElements,T1data,T1deriv,Newc,DerivNewc,inputfile)
       USE TypeMod
       USE InterfaceMod
       Use TimeMod, only : time_datastructure
       Implicit NONE

       integer :: numOcc,numVirt,numSG
       integer, intent(IN), allocatable, dimension(:) :: SymV,SymO
       type(symmetry), allocatable, dimension(:) :: InvPdt
       type(T2) :: T2data, T2deriv, Newc,DerivNewc
       type(T1) :: T1data, T1deriv
       integer, intent(IN), allocatable, dimension(:,:) :: occ,virt
       integer, allocatable, dimension(:,:) :: ProductTable
       integer :: flag
       integer :: numElements
       character(len=100) :: inputfile

       integer :: t, tempNumElements
       integer :: a,j,i,b,i_begin,i_end,b_begin,b_end,isym,bsym,symtop
       integer :: a_begin, j_begin, a_end, j_end
       real :: time_begin, time_end
       integer :: ioerror
       character(len=100) :: T2file
       logical :: lexist
      Call CPU_TIME(time_begin)
     if(flag==0)  then

       allocate(T2data%aa%m(numOcc+1:numOcc+numVirt,1:numOcc))
       allocate(T2data%ab%m(numOcc+1:numOcc+numVirt,1:numOcc))
       allocate(T2data%bb%m(numOcc+1:numOcc+numVirt,1:numOcc))
       allocate(T2deriv%aa%m(numOcc+1:numOcc+numVirt,1:numOcc))
       allocate(T2deriv%ab%m(numOcc+1:numOcc+numVirt,1:numOcc))
       allocate(T2deriv%bb%m(numOcc+1:numOcc+numVirt,1:numOcc))
       allocate(T1data%a%o(1:numOcc))
       allocate(T1data%b%o(1:numOcc))
       allocate(T1deriv%a%o(1:numOcc))
       allocate(T1deriv%b%o(1:numOcc))
       allocate(Newc%aa%m(numOcc+1:numOcc+numVirt,1:numOcc))
       allocate(Newc%ab%m(numOcc+1:numOcc+numVirt,1:numOcc))
       allocate(Newc%bb%m(numOcc+1:numOcc+numVirt,1:numOcc))
       allocate(DerivNewc%aa%m(numOcc+1:numOcc+numVirt,1:numOcc))
       allocate(DerivNewc%ab%m(numOcc+1:numOcc+numVirt,1:numOcc))
       allocate(DerivNewc%bb%m(numOcc+1:numOcc+numVirt,1:numOcc))

       do j=1, numOcc
          do a = numOcc+1, numOcc+numVirt
             allocate(T2data%aa%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(T2data%ab%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(T2data%bb%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(T2deriv%aa%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(T2deriv%ab%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(T2deriv%bb%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(Newc%aa%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(Newc%ab%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(Newc%bb%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(DerivNewc%aa%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(DerivNewc%ab%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(DerivNewc%bb%m(a,j)%nsym(1:numSG,1:numSG))
          end do
       end do
       do j=1,numOcc
           allocate(T1data%a%o(j)%vsym(1:numSG))
           allocate(T1data%b%o(j)%vsym(1:numSG))
           allocate(T1deriv%a%o(j)%vsym(1:numSG))
           allocate(T1deriv%b%o(j)%vsym(1:numSG))
       end do

       do j=1,numOcc
         do a=numOcc+1,numOcc+numVirt
           symtop = ProductTable(SymV(a),SymO(j))
           do t=1,numSG
             bsym = InvPdt(symtop)%upper(t)
             isym = InvPdt(symtop)%lower(t)
             i_begin = occ(1,isym)
             i_end   = occ(2,isym)
             b_begin = virt(1,bsym)
             b_end   = virt(2,bsym)
             allocate(T2data%aa%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             allocate(T2data%ab%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             allocate(T2data%bb%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             allocate(T2deriv%aa%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             allocate(T2deriv%ab%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             allocate(T2deriv%bb%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             allocate(Newc%aa%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             allocate(Newc%ab%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             allocate(Newc%bb%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             allocate(DerivNewc%aa%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             allocate(DerivNewc%ab%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             allocate(DerivNewc%bb%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
           end do
         end do
       end do
      numElements = 0
      do j=1,numOcc
        do a=numOcc+1,numOcc+numVirt
          symtop = ProductTable(SymV(a),SymO(j))
          do t=1,numSG
            bsym = InvPdt(symtop)%upper(t)
            isym = InvPdt(symtop)%lower(t)
            b_begin = virt(1,bsym)
            b_end   = virt(2,bsym)
            i_begin = occ(1,isym)
            i_end   = occ(2,isym)
            do i=i_begin,i_end
              do b=b_begin,b_end
                T2data%aa%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                T2data%ab%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                T2data%bb%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                T2deriv%aa%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                T2deriv%ab%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                T2deriv%bb%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                Newc%aa%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                Newc%ab%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                Newc%bb%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                DerivNewc%aa%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                DerivNewc%ab%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                DerivNewc%bb%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                numElements = numElements + 1
              end do
            end do
          end do
        end do
      end do

      numElements = 2*numElements
       do j=1,numOcc
         symtop = SymO(j)
         a_begin = virt(1,symtop)
         a_end   = virt(2,symtop)
         numElements = numElements + a_end - a_begin + 1
         allocate(T1data%a%o(j)%vsym(symtop)%v(a_begin:a_end))
         T1data%a%o(j)%vsym(symtop)%v(a_begin:a_end) = 0.0D0
         allocate(T1data%b%o(j)%vsym(symtop)%v(a_begin:a_end))
         T1data%b%o(j)%vsym(symtop)%v(a_begin:a_end) = 0.0D0
         allocate(T1deriv%a%o(j)%vsym(symtop)%v(a_begin:a_end))
         T1deriv%a%o(j)%vsym(symtop)%v(a_begin:a_end) = 0.0D0
         allocate(T1deriv%b%o(j)%vsym(symtop)%v(a_begin:a_end))
         T1deriv%b%o(j)%vsym(symtop)%v(a_begin:a_end) = 0.0D0
      end do

       T2file = trim(inputfile) // 'T2'
       inquire(file=T2file,exist=lexist)
       if(lexist.eqv..TRUE.) then
         open(unit=25,file=T2file,action='read',iostat=ioerror)
         read(25,*) tempNumElements
         if(tempNumElements.eq.numElements) then
           do j=1,numOcc
             do a=numOcc+1,numOcc+numVirt
               symtop = ProductTable(SymV(a),SymO(j))
               do t=1,numSG
               bsym = InvPdt(symtop)%upper(t)
               isym = InvPdt(symtop)%lower(t)
               b_begin = virt(1,bsym)
               b_end   = virt(2,bsym)
               i_begin = occ(1,isym)
               i_end   = occ(2,isym)
               do i=i_begin,i_end
                 do b=b_begin,b_end
                   read(25,*)  T2data%aa%m(a,j)%nsym(bsym,isym)%n(b,i)
                 end do
               end do
             end do
           end do
         end do

        do j=1,numOcc
          do a=numOcc+1,numOcc+numVirt
            symtop = ProductTable(SymV(a),SymO(j))
            do t=1,numSG
              bsym = InvPdt(symtop)%upper(t)
              isym = InvPdt(symtop)%lower(t)
              b_begin = virt(1,bsym)
              b_end   = virt(2,bsym)
              i_begin = occ(1,isym)
              i_end   = occ(2,isym)
              do i=i_begin,i_end
                do b=b_begin,b_end
                  read(25,*)  T2data%ab%m(a,j)%nsym(bsym,isym)%n(b,i)
                end do
              end do
            end do
          end do
        end do

            do j=1,numOcc
             do a=numOcc+1,numOcc+numVirt
               symtop = ProductTable(SymV(a),SymO(j))
               do t=1,numSG
                 bsym = InvPdt(symtop)%upper(t)
                 isym = InvPdt(symtop)%lower(t)
                 b_begin = virt(1,bsym)
                 b_end   = virt(2,bsym)
                 i_begin = occ(1,isym)
                 i_end   = occ(2,isym)
                 do i=i_begin,i_end
                   do b=b_begin,b_end
                     read(25,*)  T2data%bb%m(a,j)%nsym(bsym,isym)%n(b,i)
                   end do
                 end do
               end do
             end do
           end do

       do j=1,numOcc
         symtop = SymO(j)
         a_begin = virt(1,symtop)
         a_end   = virt(2,symtop)
         do a=a_begin,a_end
           read(25,*)  T1data%a%o(j)%vsym(symtop)%v(a)
         end do
      end do

       do j=1,numOcc
         symtop = SymO(j)
         a_begin = virt(1,symtop)
         a_end   = virt(2,symtop)
         do a=a_begin,a_end
           read(25,*)  T1data%b%o(j)%vsym(symtop)%v(a)
         end do
      end do
      close(25)
   else
     write(*,*) 'The number of elements in the coefficient file was not correct.'
     write(*,*) 'Please restart after deleting ',trim(T2file)
     stop
  end if
 end if

end if




  if(flag==1) then
      do j=1,numOcc
        do a=numOcc+1,numOcc+numVirt
          symtop = ProductTable(SymV(a),SymO(j))
          do t=1,numSG
            bsym = InvPdt(symtop)%upper(t)
            isym = InvPdt(symtop)%lower(t)
            b_begin = virt(1,bsym)
            b_end   = virt(2,bsym)
            i_begin = occ(1,isym)
            i_end   = occ(2,isym)
            do i=i_begin,i_end
              do b=b_begin,b_end
                T2deriv%aa%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                T2deriv%ab%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                T2deriv%bb%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                Newc%aa%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                Newc%ab%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                Newc%bb%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                DerivNewc%aa%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                DerivNewc%ab%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                DerivNewc%bb%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
              end do
            end do
          end do
        end do
      end do
       do j=1,numOcc
         symtop = SymO(j)
         a_begin = virt(1,symtop)
         a_end   = virt(2,symtop)
         T1deriv%a%o(j)%vsym(symtop)%v(a_begin:a_end) = 0.0
         T1deriv%b%o(j)%vsym(symtop)%v(a_begin:a_end) = 0.0
       end do
   end if

Call CPU_TIME(time_end)
        time_datastructure = time_datastructure + time_end - time_begin
       end subroutine DataStructure

!> @brief Calculates the derivative with respect to T1/T2 parameters
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine CalcDeriv(T2data,K2,K1,numSG,ProductTable,numOcc,numVirt,occ,virt,ReshapedMatrixDim,InvPdt,T2deriv, energy,K1TwoInts,T1data,T1deriv,Newc,DerivNewc,topfac,TwoInts,topsingles)
       Use InterfaceMod
       Use TypeMod
       Use TimeMod
       Implicit None

       type(T2) :: T2data
       type(T1) :: T1data,T1deriv
       type(T2) :: Newc,DerivNewc
       type(spin) :: K2(1:2,1:2,1:2,1:2)
       type(spin) :: K1(1:2,1:2),K1TwoInts(1:2,1:2)
       integer :: numSG,numOcc,numVirt
       integer, intent(IN), dimension(1:numSG,1:numSG) :: ProductTable
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN) :: InvPdt(1:numSG)
       integer, intent(IN), dimension(1:2,1:numSG) :: occ,virt
       integer :: p, i_begin,i_end,j_begin,j_end,k_begin,k_end, l_begin,l_end,i,j,k,l,q,r,s,t,v,row,col,symgp
       integer :: c_begin,c_end,a_begin,a_end,c,a
       type(ReshapedMat), allocatable, dimension(:)  :: DerivReshapes, Reshapes, TopReshape,DerivTopReshape
       type(T2) :: T2deriv
       real(8) :: energy
       real(8) :: tempenergy=0.0D0
       integer :: temprow, tempcol
       real(8), dimension(0:2,0:2) :: topfac
       real(8), intent(IN), allocatable, dimension(:,:,:,:) :: TwoInts
       real(8), dimension(0:1,0:1) :: topsingles(0:1,0:1)


       type(ReshapedMat), allocatable, dimension(:) :: TempReshape,TempDerivReshape
       real(8), allocatable, dimension(:,:) :: temp
       integer :: time_initial(8),time_final(8)
       real :: time_begin, time_end
       real :: time_total_begin, time_total_end
       integer :: numa,numi
       Call cpu_time(time_total_begin)


       energy = 0.0D0
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ijaa_test(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,1,1)%aa%irrep(p)%block)
       end do

         do p=1,numSG
           DerivReshapes(p)%ReshapedMatrix = 2*2*matmul4(K2(2,2,2,2)%aa%irrep(p)%block,Reshapes(p)%ReshapedMatrix) + DerivReshapes(p)%ReshapedMatrix
        end do
       Call reshape_ijaa_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       deallocate(DerivReshapes)

       allocate(DerivReshapes(1:numSG))
       allocate(TopReshape(1:numSG))


       Call TopFactor(TwoInts,T2data,occ,virt,numSG,topfac,Newc,InvPdt,ProductTable,DerivNewc,numOcc,numVirt,T1data,T1deriv,topsingles)
       Call reshape_ijaa_test(numSG,ProductTable,TopReshape,numOcc,numVirt,occ,virt,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)

       do p=1,numSG
         do s=1,ReshapedMatrixDim%ijaa(p)%col
           do q=1,ReshapedMatrixDim%ijaa(p)%row
             energy = energy + Reshapes(p)%ReshapedMatrix(q,s)*2*2*K2(1,1,2,2)%aa%irrep(p)%block(q,s)*TopReshape(p)%ReshapedMatrix(q,s)
           end do
         end do
       end do
       deallocate(TopReshape)
       deallocate(Reshapes)
       deallocate(DerivReshapes)
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ajaa(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,2,1,2)%aa%irrep(p)%block)
       end do
       Call reshape_ajaa_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       deallocate(Reshapes)
       deallocate(DerivReshapes)
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ijab_test(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,1,1)%ab%irrep(p)%block)
       end do

       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K2(2,2,2,2)%ab%irrep(p)%block,Reshapes(p)%ReshapedMatrix) + DerivReshapes(p)%ReshapedMatrix
       end do
       Call reshape_ijab_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)

       deallocate(DerivReshapes)
       allocate(TopReshape(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ijab_test(numSG,ProductTable,TopReshape,numOcc,numVirt,occ,virt,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)

       do p=1,numSG
         do q=1,ReshapedMatrixDim%ijab(p)%col
           do s=1,ReshapedMatrixDim%ijab(p)%row
             energy = energy + Reshapes(p)%ReshapedMatrix(s,q)*2*K2(1,1,2,2)%ab%irrep(p)%block(s,q)*TopReshape(p)%ReshapedMatrix(s,q)
           end do
         end do
      end do
       deallocate(TopReshape)
       deallocate(Reshapes)
       deallocate(DerivReshapes)

       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ajab(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,2,1,2)%ab%irrep(p)%block)
      end do
       Call reshape_ajab_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)

       deallocate(Reshapes)
       deallocate(DerivReshapes)
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ajba(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,2,1,2)%ab%irrep(p)%block)
       end do
       Call reshape_ajba_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       deallocate(Reshapes)
       deallocate(DerivReshapes)
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_i(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*2*matmul4(Reshapes(p)%ReshapedMatrix,K1(1,1)%aa%irrep(p)%block)
       end do
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix =-1*2*matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(1,1)%aa%irrep(p)%block) + DerivReshapes(p)%ReshapedMatrix
      end do
      Call reshape_i_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
      deallocate(Reshapes)
      deallocate(DerivReshapes)

      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
      Call reshape_a(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*2*matmul4(Reshapes(p)%ReshapedMatrix,K1(2,2)%aa%irrep(p)%block)
      end do
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(2,2)%aa%irrep(p)%block) + DerivReshapes(p)%ReshapedMatrix
      end do
      Call reshape_a_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
      deallocate(Reshapes)
      deallocate(DerivReshapes)

       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           a_begin = virt(1,p);
           a_end   = virt(2,p);
           j_begin = occ(1,q);
           j_end   = occ(2,q);
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 k_begin = occ(1,s)
                 k_end   = occ(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     energy = energy + 0.5*T2data%aa%m(a,j)%nsym(r,s)%n(c,k)*T2deriv%aa%m(a,j)%nsym(r,s)%n(c,k)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           a_begin = virt(1,p);
           a_end   = virt(2,p);
           j_begin = occ(1,q);
           j_end   = occ(2,q);
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 k_begin = occ(1,s)
                 k_end   = occ(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     energy = energy + 0.5*T2data%ab%m(a,j)%nsym(r,s)%n(c,k)*T2deriv%ab%m(a,j)%nsym(r,s)%n(c,k)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

      allocate(DerivReshapes(1:numSG))
      allocate(TopReshape(1:numSG))
      allocate(DerivTopReshape(1:numSG))
      Call reshape_ijaa_test(numSG,ProductTable,TopReshape,numOcc,numVirt,occ,virt,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)
      deallocate(DerivReshapes)
      allocate(DerivReshapes(1:numSG))
      Call reshape_ijaa_test(numSG,ProductTable,DerivTopReshape,numOcc,numVirt,occ,virt,DerivNewc,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         do q=1,ReshapedMatrixDim%ijaa(p)%col
           do s=1,ReshapedMatrixDim%ijaa(p)%row
             DerivReshapes(p)%ReshapedMatrix(s,q) = 2*2*(K2(1,1,2,2)%aa%irrep(p)%block(s,q)*TopReshape(p)%ReshapedMatrix(s,q) + DerivTopReshape(p)%ReshapedMatrix(s,q))
            end do
         end do
       end do
       Call reshape_ijaa_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       deallocate(DerivReshapes)
       deallocate(TopReshape)
       deallocate(DerivTopReshape)

       allocate(DerivReshapes(1:numSG))
       allocate(TopReshape(1:numSG))
       allocate(DerivTopReshape(1:numSG))
       Call reshape_ijab_test(numSG,ProductTable,TopReshape,numOcc,numVirt,occ,virt,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)
       deallocate(DerivReshapes)
       allocate(DerivReshapes(1:numSG))
       Call reshape_ijab_test(numSG,ProductTable,DerivTopReshape,numOcc,numVirt,occ,virt,DerivNewc,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        do q=1,ReshapedMatrixDim%ijab(p)%col
          do s=1,ReshapedMatrixDim%ijab(p)%row
            DerivReshapes(p)%ReshapedMatrix(s,q) = 2*(K2(1,1,2,2)%ab%irrep(p)%block(s,q)*TopReshape(p)%ReshapedMatrix(s,q) + DerivTopReshape(p)%ReshapedMatrix(s,q))
          end do
        end do
      end do
      Call reshape_ijab_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
      deallocate(DerivReshapes)
      deallocate(TopReshape)
      deallocate(DerivTopReshape)

      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
      allocate(TempReshape(1:numSG))
      allocate(TempDerivReshape(1:numSG))

      Call reshape_ajaa_transpose(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_ajbb(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
       do p=1,numSG
          DerivReshapes(p)%ReshapedMatrix = 2*-1*-1*matmul4(K2(1,2,2,1)%ab%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
       end do
       do p=1,numSG
           TempDerivReshape(p)%ReshapedMatrix = 2*-1*-1*matmul4(TempReshape(p)%ReshapedMatrix,K2(1,2,2,1)%ab%irrep(p)%block)
       end do
       do p=1,numSG
         do q=1,ReshapedMatrixDim%ajaa(p)%row
           do s=1,ReshapedMatrixDim%ajaa(p)%col
               energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*TempReshape(p)%ReshapedMatrix(q,s)
           end do
         end do
      end do
         Call reshape_ajaa_transpose_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
         Call reshape_ajbb_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
         deallocate(DerivReshapes)
         deallocate(TempDerivReshape)
         deallocate(Reshapes)
         deallocate(TempReshape)
      allocate(DerivReshapes(1:numSG))
      allocate(TempDerivReshape(1:numSG))
      allocate(Reshapes(1:numSG))
      allocate(TempReshape(1:numSG))
      Call reshape_jka_aaa(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_b(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      do p=1,numSG
        TempDerivReshape(p)%ReshapedMatrix = 2*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,1,2)%aa%irrep(p)%block)
        DerivReshapes(p)%ReshapedMatrix = 2*2*matmul4(K2(1,1,1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
      end do
      do p=1,numSG
       do q=1,ReshapedMatrixDim%jka_aaa(p)%row
         do s=1,ReshapedMatrixDim%jka_aaa(p)%col
          energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
         end do
       end do
      end do
      Call reshape_jka_aaa_inverse(numSG,ProductTable,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_b_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
      deallocate(Reshapes)
      deallocate(TempReshape)
      deallocate(TempDerivReshape)
      deallocate(DerivReshapes)

      allocate(DerivReshapes(1:numSG))
      allocate(TempDerivReshape(1:numSG))
      allocate(Reshapes(1:numSG))
      allocate(TempReshape(1:numSG))
      Call reshape_bci_aaa(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_i(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*2*matmul4(K2(2,2,1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
         TempDerivReshape(p)%ReshapedMatrix = 2*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(2,2,1,2)%aa%irrep(p)%block)
       end do

      do p=1,numSG
        do q=1,ReshapedMatrixDim%bci_aaa(p)%row
          do s=1,ReshapedMatrixdim%bci_aaa(p)%col
            energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
          end do
        end do
       end do
       Call reshape_bci_aaa_inverse(numSG,ProductTable,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Call reshape_t1_i_inverse(numSG,ProductTable,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt,TempDerivReshape)
       deallocate(Reshapes)
       deallocate(TempReshape)
       deallocate(TempDerivReshape)
       deallocate(DerivReshapes)

       allocate(DerivReshapes(1:numSG))
       allocate(TempDerivReshape(1:numSG))
       allocate(Reshapes(1:numSG))
       allocate(TempReshape(1:numSG))
       Call reshape_jka_abb(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Call reshape_t1_b(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(K2(1,1,1,2)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
        TempDerivReshape(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,1,2)%ab%irrep(p)%block)
      end do
      do p=1,numSG
        do q=1,ReshapedMatrixDim%jka_abb(p)%row
          do s=1,ReshapedMatrixDim%jka_abb(p)%col
            energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
          end do
        end do
      end do
       Call reshape_t1_b_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       Call reshape_jka_abb_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       deallocate(Reshapes)
       deallocate(TempReshape)
       deallocate(TempDerivReshape)
       deallocate(DerivReshapes)

       allocate(DerivReshapes(1:numSG))
       allocate(TempDerivReshape(1:numSG))
       allocate(Reshapes(1:numSG))
       allocate(TempReshape(1:numSG))
       Call reshape_jka_aba(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Call reshape_t1_b(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(K2(1,1,2,1)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
        TempDerivReshape(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,2,1)%ab%irrep(p)%block)
      end do
      do p=1,numSG
        do q=1,ReshapedMatrixDim%jka_aba(p)%row
          do s=1,ReshapedMatrixDim%jka_aba(p)%col
            energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q) * Reshapes(p)%ReshapedMatrix(q,s)
          end do
        end do
      end do
       Call reshape_t1_b_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       Call reshape_jka_aba_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
      deallocate(Reshapes)
      deallocate(TempReshape)
      deallocate(TempDerivReshape)
      deallocate(DerivReshapes)

      allocate(DerivReshapes(1:numSG))
      allocate(TempDerivReshape(1:numSG))
      allocate(Reshapes(1:numSG))
      allocate(TempReshape(1:numSG))
      Call reshape_bci_aba(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_i(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K2(2,2,1,2)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
        TempDerivReshape(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(2,2,1,2)%ab%irrep(p)%block)
      end do
      do p=1,numSG
        do q=1,ReshapedMatrixDim%bci_aba(p)%row
          do s=1,ReshapedMatrixDim%bci_aba(p)%col
            energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
          end do
        end do
      end do
       Call reshape_t1_i_inverse(numSG,ProductTable,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt,TempDerivReshape)
       Call reshape_bci_aba_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
      deallocate(Reshapes)
      deallocate(TempReshape)
      deallocate(TempDerivReshape)
      deallocate(DerivReshapes)


     allocate(DerivReshapes(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempReshape(1:numSG))
     Call reshape_bci_abb(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_i(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix =1*2*matmul4(K2(2,2,2,1)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
         TempDerivReshape(p)%ReshapedMatrix = 1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(2,2,2,1)%ab%irrep(p)%block)
       end do
      do p=1,numSG
        do q=1,ReshapedMatrixDim%bci_abb(p)%row
          do s=1,ReshapedMatrixDim%bci_abb(p)%col
            energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q) * Reshapes(p)%ReshapedMatrix(q,s)
          end do
        end do
      end do
       Call reshape_t1_i_inverse(numSG,ProductTable,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt,TempDerivReshape)
       Call reshape_bci_abb_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       deallocate(Reshapes)
       deallocate(TempReshape)
       deallocate(TempDerivReshape)
       deallocate(DerivReshapes)


       allocate(DerivReshapes(1:numSG))
       allocate(Reshapes(1:numSG))
       Call reshape_t1t1_i(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*-1*2*matmul4(Reshapes(p)%ReshapedMatrix,K1(1,1)%aa%irrep(p)%block)
       end do
       do p=1,numSG
         numa = virt(2,p) - virt(1,p) + 1
         numi = occ(2,p) - occ(1,p) + 1
         do q=1,numi
           do s=1,numa
             energy = energy + 0.5*Reshapes(p)%ReshapedMatrix(s,q)* DerivReshapes(p)%ReshapedMatrix(s,q)
           end do
         end do
       end do
       Call reshape_t1t1_i_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*-1*matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(1,1)%aa%irrep(p)%block)
       end do
       do p=1,numSG
         numa = virt(2,p) - virt(1,p) + 1
         numi = occ(2,p) - occ(1,p) + 1
         do q=1,numi
           do s=1,numa
             energy = energy + 0.5*Reshapes(p)%ReshapedMatrix(s,q)* DerivReshapes(p)%ReshapedMatrix(s,q)
           end do
         end do
       end do
       Call reshape_t1t1_i_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)

      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*2*matmul4(K1(2,2)%aa%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
      end do
      do p=1,numSG
         numa = virt(2,p) - virt(1,p) + 1
         numi = occ(2,p) - occ(1,p) + 1
          do q=1,numi
           do s=1,numa
             energy = energy + 0.5*DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(s,q)
            end do
         end do
      end do
        Call reshape_t1t1_i_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K1TwoInts(2,2)%aa%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
      end do
      do p=1,numSG
         numa = virt(2,p) - virt(1,p) + 1
         numi = occ(2,p) - occ(1,p) + 1
          do q=1,numi
           do s=1,numa
             energy = energy + 0.5*DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(s,q)
            end do
         end do
      end do
      Call reshape_t1t1_i_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
      deallocate(DerivReshapes)
      deallocate(Reshapes)


      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
      Call reshape_t1_ibrow_alphaonly_symi(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
       DerivReshapes(p)%ReshapedMatrix = 2*2*K1(1,2)%aa%irrep(p)%block  + K1TwoInts(1,2)%aa%irrep(p)%block
       allocate(temp(1:1,1:1))
       temp =  matmul4(Reshapes(p)%ReshapedMatrix,DerivReshapes(p)%ReshapedMatrix)
       energy = energy + temp(1,1)
       deallocate(temp)
      end do
      Call reshape_t1_ibrow_alphaonly_symi_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
     deallocate(DerivReshapes)
     deallocate(Reshapes)


     allocate(DerivReshapes(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempReshape(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     Call reshape_ajaa_t1(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibrow(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
     allocate(temp(1:1,1:1))
      do p=1,numSG
       DerivReshapes(p)%ReshapedMatrix = 2*2*matmul4(K1(1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
       TempDerivReshape(p)%ReshapedMatrix = 2*2*matmul4(Reshapes(p)%ReshapedMatrix,K1(1,2)%aa%irrep(p)%block)
      end do
      do p=1,numSG
        temp = matmul4(TempReshape(p)%ReshapedMatrix,TempDerivReshape(p)%ReshapedMatrix)
        energy = energy + temp(1,1)
      end do
      Call reshape_ajaa_t1_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
      Call reshape_t1_ibrow_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)

      deallocate(DerivReshapes)
      deallocate(Reshapes)
      deallocate(TempDerivReshape)
      deallocate(TempReshape)
      allocate(DerivReshapes(1:numSG))
      allocate(Reshapes(1:numSG))
      allocate(TempDerivReshape(1:numSG))
      allocate(TempReshape(1:numSG))
     Call reshape_ajaa_t1(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibrow(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = matmul4(K1TwoInts(1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
        TempDerivReshape(p)%ReshapedMatrix = matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(1,2)%aa%irrep(p)%block)
      end do
      do p=1,numSG
        temp = matmul4(TempReshape(p)%ReshapedMatrix,TempDerivReshape(p)%ReshapedMatrix)
        energy = energy + temp(1,1)
      end do
      Call reshape_ajaa_t1_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
      Call reshape_t1_ibrow_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)

      deallocate(DerivReshapes)
      deallocate(Reshapes)
      deallocate(TempDerivReshape)
      deallocate(TempReshape)

     allocate(DerivReshapes(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     allocate(TempReshape(1:numSG))
     Call reshape_t1_ibrow_alphaonly(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibcol_alphaonly(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
         p=1
         TempDerivReshape(p)%ReshapedMatrix = -2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,2,1,2)%aa%irrep(p)%block)
         DerivReshapes(p)%ReshapedMatrix = -2*matmul4(K2(1,2,1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
         do q=1,ReshapedMatrixDim%ajaa(1)%col
             energy = energy + DerivReshapes(1)%ReshapedMatrix(q,1)*Reshapes(1)%ReshapedMatrix(1,q)
         end do
       Call reshape_t1_ibrow_alphaonly_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       Call reshape_t1_ibcol_alphaonly_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
      deallocate(DerivReshapes)
      deallocate(Reshapes)
      deallocate(TempDerivReshape)
      deallocate(TempReshape)

     allocate(DerivReshapes(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     allocate(TempReshape(1:numSG))
     Call reshape_t1_ibrow_alphaonly(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibcol_alphaonly(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
         p = 1
         TempDerivReshape(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,2,2,1)%ab%irrep(p)%block)
         DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K2(1,2,2,1)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
         do q=1,ReshapedMatrixDim%ajab(1)%col
             energy = energy + DerivReshapes(1)%ReshapedMatrix(q,1)*Reshapes(1)%ReshapedMatrix(1,q)
         end do
       Call reshape_t1_ibrow_alphaonly_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       Call reshape_t1_ibcol_alphaonly_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)

       deallocate(Reshapes)
       deallocate(DerivReshapes)



      call cpu_time(time_total_end)
      time_calcderiv = time_calcderiv + time_total_end - time_total_begin
       end subroutine CalcDeriv

       subroutine reshape_ijaa_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       Use InterfaceMod
       USE TypeMod;
       Use TimeMod, only :time_ijaa_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s
       integer, dimension(1:SG) :: total_SG_row, total_SG_col
       integer, target :: a,b,i,j
       integer, target :: row,col,i_begin,i_end,j_begin,j_end,a_begin,a_end,b_begin,b_end
       integer :: numa,numb,numi,numj
       integer, pointer :: jptr, bptr
       integer :: t,v
       integer, target :: temp
       integer :: time_initial(8),time_final(8)
       real :: time_begin,time_end
     Call CPU_TIME(time_begin)
      do symgp=1,SG
         col = 0
         do t=1,SG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             if(p.GT.q) then
               cycle
             end if
             i_begin = occ(1,p)
             i_end   = occ(2,p)
             j_begin = occ(1,q)
             j_end   = occ(2,q)
             do i=i_begin,i_end
               do j=max(i+1,j_begin),j_end
                 col = col + 1
                 row = 1
                 do v=1,SG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   if(r.GT.s) then
                     cycle
                   end if
                   a_begin = virt(1,r)
                   a_end   = virt(2,r)
                   b_begin = virt(1,s)
                   b_end   = virt(2,s)
                   do a=a_begin,a_end
                     do b=max(a+1,b_begin),b_end
                       T2deriv%aa%m(a,i)%nsym(s,q)%n(b,j) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%aa%m(a,i)%nsym(s,q)%n(b,j)
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do

        Call CPU_TIME(time_end)
        time_ijaa_inverse = time_end - time_begin + time_ijaa_inverse

      end subroutine reshape_ijaa_inverse

       subroutine reshape_ajaa_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_ajaa_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: a,j,c,k
       integer :: row,col,c_begin,c_end,k_begin,k_end,t,v
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)

     row = 1
       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               col = col + 1
               row = 1
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 k_begin = occ(1,s)
                 k_end   = occ(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                    T2deriv%aa%m(a,j)%nsym(r,s)%n(c,k) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%aa%m(a,j)%nsym(r,s)%n(c,k)
                    row = row + 1
                    maxrow_SG(symgp) = row
                  end do
                end do
              end do
            end do
          end do
        end do
      end do



       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 col = col + 1
                 row = maxrow_SG(symgp)
                 do v=1,SG
                   r = InvPdt(symgp)%upper(v)
                   s = InvPdt(symgp)%lower(v)
                   c_begin = virt(1,r)
                   c_end   = virt(2,r)
                   k_begin = occ(1,s)
                   k_end   = occ(2,s)
                   do k=k_begin,k_end
                     do c=c_begin,c_end
                       T2deriv%ab%m(a,j)%nsym(r,s)%n(c,k) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(a,j)%nsym(r,s)%n(c,k)
                       row = row + 1
                      end do
                    end do
                  end do
                end do
              end do
            end do
          end do

          Call CPU_TIME(time_end)
          time_ajaa_inverse = time_end - time_begin + time_ajaa_inverse

      end subroutine reshape_ajaa_inverse


       subroutine reshape_ijab_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_ijab_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), dimension(:) :: InvPdt(1:SG)

       integer :: symgp,p,q,r,s
       integer, dimension(1:SG) :: total_SG_row, total_SG_col
       integer, target :: a,b,i,j
       integer, target :: row,col,i_begin,i_end,j_begin,j_end,a_begin,a_end,b_begin,b_end
       integer :: numa,numb,numi,numj
       integer, pointer :: jptr, bptr
       integer :: t,v
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)
      do symgp=1,SG
         col = 0
         do t=1,SG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             i_begin = occ(1,p)
             i_end   = occ(2,p)
             j_begin = occ(1,q)
             j_end   = occ(2,q)
             do i=i_begin,i_end
               do j=j_begin,j_end
                 col = col + 1
                 row = 1
                 do v=1,SG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   a_begin = virt(1,r)
                   a_end   = virt(2,r)
                   b_begin = virt(1,s)
                   b_end   = virt(2,s)
                   do a=a_begin,a_end
                     do b=b_begin,b_end
                       T2deriv%ab%m(a,i)%nsym(s,q)%n(b,j) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(a,i)%nsym(s,q)%n(b,j)
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do

       Call CPU_TIME(time_end)
         time_ijab_inverse = time_end - time_begin + time_ijab_inverse
      end subroutine reshape_ijab_inverse


       subroutine reshape_ajab_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_ajab_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end
       integer, dimension(1:SG) :: total_SG
       integer :: a,j,c,k,t,v
       integer :: row,col,c_begin,c_end,k_begin,k_end
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)

       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
            do a=a_begin,a_end
              do j=j_begin,j_end
                row = 1
                col = col + 1
                do v=1,SG
                  r = InvPdt(symgp)%upper(v)
                  s = InvPdt(symgp)%lower(v)
                  c_begin = virt(1,r)
                  c_end   = virt(2,r)
                  k_begin = occ(1,s)
                  k_end   = occ(2,s)
                  do k=k_begin,k_end
                    do c=c_begin,c_end
                     T2deriv%ab%m(c,j)%nsym(p,s)%n(a,k) =  -1*DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(c,j)%nsym(p,s)%n(a,k)
                      row = row + 1
                      end do
                    end do
                  end do
                end do
              end do
            end do
          end do

          Call CPU_TIME(time_end)
          time_ajab_inverse = time_end - time_begin + time_ajab_inverse

      end subroutine reshape_ajab_inverse


       subroutine reshape_ajba_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_ajba_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end,t,v
       integer, dimension(1:SG) :: total_SG
       integer :: a,j,c,k
       integer :: row,col,c_begin,c_end,k_begin,k_end
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)


       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
             do a=a_begin,a_end
              do j=j_begin,j_end
                 row = 1
                 col = col + 1
                 do v=1,SG
                   r = InvPdt(symgp)%upper(v)
                   s = InvPdt(symgp)%lower(v)
                   c_begin = virt(1,r)
                   c_end   = virt(2,r)
                   k_begin = occ(1,s)
                   k_end   = occ(2,s)
                    do k=k_begin,k_end
                      do c=c_begin,c_end
                      T2deriv%ab%m(c,j)%nsym(p,s)%n(a,k) = -1*DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(c,j)%nsym(p,s)%n(a,k)
                       row = row + 1
                       end do
                     end do
                   end do
                 end do
               end do
             end do
           end do

         Call CPU_TIME(time_end)
         time_ajba_inverse = time_end - time_begin + time_ajba_inverse

      end subroutine reshape_ajba_inverse


       subroutine reshape_i_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       Use TypeMod;
       Use TimeMod, only : time_i_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat), intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN) :: InvPdt(1:SG)

       integer, dimension(1:SG) :: total_SG_row, total_SG_col
       integer :: i,a,b,k,symgp
       integer :: i_begin,i_end,a_begin,a_end,b_begin,b_end,k_begin,k_end
       integer :: p,q,r,s,numi,numa,numb,numk,row,col,t
       integer, dimension(1:SG) :: maxrow_SG
       integer :: aisym
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)

       do i=1,SG
          maxrow_SG(i) = 0
       end do

       row = 1
       do symgp=1,SG
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         col = 0
         do i=i_begin,i_end
           col = col + 1
           row = 1
           do p=1,SG
             a_begin = virt(1,p)
             a_end   = virt(2,p)
             aisym = ProductTable(symgp,p)
             do a=a_begin,a_end
               do t=1,SG
                 q = InvPdt(aisym)%upper(t)
                 r = InvPdt(aisym)%lower(t)
                 if(p>r) cycle
                 b_begin = virt(1,r)
                 b_end   = virt(2,r)
                 k_begin = occ(1,q)
                 k_end   = occ(2,q)
                 do k=k_begin,k_end
                   do b=max(a+1,b_begin),b_end
                     T2deriv%aa%m(a,i)%nsym(r,q)%n(b,k) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%aa%m(a,i)%nsym(r,q)%n(b,k)
                     maxrow_SG(symgp) = row
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,SG
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         col = 0
         do i=i_begin,i_end
           col = col + 1
           row = maxrow_SG(symgp) + 1
           do p=1,SG
             a_begin = virt(1,p)
             a_end   = virt(2,p)
             aisym = ProductTable(symgp,p)
             do a=a_begin,a_end
               do t=1,SG
                 q = InvPdt(aisym)%upper(t)
                 r = InvPdt(aisym)%lower(t)
                 b_begin = virt(1,r)
                 b_end   = virt(2,r)
                 k_begin = occ(1,q)
                 k_end   = occ(2,q)
                 do k=k_begin,k_end
                   do b=b_begin,b_end
                     T2deriv%ab%m(a,i)%nsym(r,q)%n(b,k) = DerivReshapes(symgp)%ReshapedMatrix(row,col) +  T2deriv%ab%m(a,i)%nsym(r,q)%n(b,k)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       Call CPU_TIME(time_end)
       time_i_inverse = time_end - time_begin + time_i_inverse
end subroutine reshape_i_inverse

       subroutine reshape_a_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       Use TypeMod;
       Use TimeMod, only : time_a_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat), intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)

       integer :: a,c,i,j,symgp
       integer :: a_begin,a_end,c_begin,c_end,i_begin,i_end,j_begin,j_end
       integer :: p,q,r,s,numa,numc,numi,numj,row,col,t
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)




       do i=1,SG
          maxrow_SG(i) = 0
       end do


      row = 1
       do symgp=1,SG
         maxrow_SG(symgp) = 0
         a_begin = virt(1,symgp)
         a_end   = virt(2,symgp)
         col = 0
         do a=a_begin,a_end
           col = col + 1
           row = 1
           do p=1,SG
             i_begin = occ(1,p)
             i_end   = occ(2,p)
             do i=i_begin,i_end
               do t=1,SG
                 q = InvPdt(ProductTable(symgp,p))%upper(t)
                 r = InvPdt(ProductTable(symgp,p))%lower(t)
                 if(p>q) cycle
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 j_begin = occ(1,q)
                 j_end   = occ(2,q)
                 do j=max(i+1,j_begin),j_end
                   do c=c_begin,c_end
                     T2deriv%aa%m(a,i)%nsym(r,q)%n(c,j) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%aa%m(a,i)%nsym(r,q)%n(c,j)
                     maxrow_SG(symgp) = row
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
      do symgp=1,SG
        a_begin = virt(1,symgp)
        a_end   = virt(2,symgp)
        col = 0
        do a=a_begin,a_end
          col = col + 1
          row = maxrow_SG(symgp)  + 1
          do p=1,SG
            i_begin = occ(1,p)
            i_end   = occ(2,p)
            do i=i_begin,i_end
              do t=1,SG
               q = InvPdt(ProductTable(symgp,p))%upper(t)
               r = InvPdt(ProductTable(symgp,p))%lower(t)
                   c_begin = virt(1,r)
                   c_end   = virt(2,r)
                   j_begin = occ(1,q)
                   j_end   = occ(2,q)
                     do j=j_begin,j_end
                       do c=c_begin,c_end
                         T2deriv%ab%m(a,i)%nsym(r,q)%n(c,j) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(a,i)%nsym(r,q)%n(c,j)
                         row = row + 1
                       end do
                     end do
                 end do
               end do
             end do
           end do
         end do

        Call CPU_TIME(time_end)
        time_a_inverse = time_end - time_begin + time_a_inverse
       end subroutine reshape_a_inverse

!> @brief Converts parameters into format needed for LBFGS calling
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine CalcParameters(SG,occ,virt,T2data,InvPdt,T2deriv,DerivVector,Tvector,T1data,T1deriv)
       USE TypeMod;
       Use TimeMod, only : time_calcparameters
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       type(T2), intent(IN) :: T2data, T2deriv
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       double precision, allocatable, dimension(:)  :: DerivVector, Tvector
       type(T1), intent(IN) :: T1data, T1deriv


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end
       integer :: a,j,c,k
       integer :: row,col,c_begin,c_end,k_begin,k_end,t,v
       integer :: counter
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)

       counter = 1
       do symgp=1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 k_begin = occ(1,s)
                 k_end   = occ(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     Tvector(counter) = T2data%aa%m(a,j)%nsym(r,s)%n(c,k)
                     counter = counter + 1
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
       do symgp=1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 k_begin = occ(1,s)
                 k_end   = occ(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                      Tvector(counter) = T2data%ab%m(a,j)%nsym(r,s)%n(c,k)
                     counter = counter + 1
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

     do symgp=1,SG
        j_begin = occ(1,symgp)
        j_end   = occ(2,symgp)
        a_begin = virt(1,symgp)
        a_end   = virt(2,symgp)
        do j=j_begin,j_end
         do a=a_begin,a_end
           Tvector(counter) = T1data%a%o(j)%vsym(symgp)%v(a)
           counter = counter + 1
         end do
      end do
    end do


       counter = 1
       do symgp=1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 k_begin = occ(1,s)
                 k_end   = occ(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     DerivVector(counter) = T2deriv%aa%m(a,j)%nsym(r,s)%n(c,k)
                     counter = counter + 1
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

       do symgp=1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 k_begin = occ(1,s)
                 k_end   = occ(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     DerivVector(counter) = T2deriv%ab%m(a,j)%nsym(r,s)%n(c,k)
                     counter = counter + 1
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

     do symgp=1,SG
        j_begin = occ(1,symgp)
        j_end   = occ(2,symgp)
        a_begin = virt(1,symgp)
        a_end   = virt(2,symgp)
        do j=j_begin,j_end
         do a=a_begin,a_end
           DerivVector(counter) = T1deriv%a%o(j)%vsym(symgp)%v(a)
           counter = counter + 1
         end do
      end do
     end do

      Call CPU_TIME(time_end)
      time_calcparameters = time_calcparameters + time_end - time_begin

      end subroutine CalcParameters

!> @brief Calculates the Hartree Fock energy
!> @author Christine Schwerdtfeger and David Mazziotti
        subroutine CalcEnergy(T2data,numSG,T2deriv,energyconstants,K2,InvPdt,ReshapedMatrixDim,occ,virt,K1)
        Use InterfaceMod
        Use TypeMod
        Use TimeMod, only : time_calcenergy
        Implicit None

        type(T2), intent(IN) :: T2data
        type(T2), intent(IN) :: T2deriv
        integer :: numSG
        real(8) :: energyconstants
        type(spin) :: K2(1:2,1:2,1:2,1:2)
        type(symmetry), intent(IN) :: InvPdt(1:numSG)
        type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
        integer, allocatable, dimension(:,:) :: occ,virt
        type(spin) :: K1(1:2,1:2)

        integer :: symgp,t,v,p,q,r,s,row,col,i,j,k,l,c,a,b
        integer :: i_begin,i_end,j_begin,j_end,k_begin,k_end,l_begin,l_end,c_begin,c_end
        integer :: a_begin,a_end
        real(8), allocatable, dimension(:,:) :: temp
        type(ReshapedMat), allocatable, dimension(:)  :: Reshapes
        real :: time_begin, time_end

        call cpu_time(time_begin)


        energyconstants = 0

       allocate(Reshapes(1:numSG))
       do p=1,numSG
          allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ijaa(p)%col,1:ReshapedMatrixDim%ijaa(p)%col))
       end do

      do symgp=1,numSG
         col = 0
         do t=1,numSG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             if(p.GT.q) then
               cycle
             end if
             i_begin = occ(1,p)
             i_end   = occ(2,p)
             j_begin = occ(1,q)
             j_end   = occ(2,q)
             do i=i_begin,i_end
               do j=max(i+1,j_begin),j_end
                 col = col + 1
                 row = 1
                 do v=1,numSG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   if(r.GT.s) then
                     cycle
                   end if
                   k_begin = occ(1,r)
                   k_end   = occ(2,r)
                   l_begin = occ(1,s)
                   l_end   = occ(2,s)
                   do k=k_begin,k_end
                     do l=max(k+1,l_begin),l_end
                       if(i==k.and.j==l.and.k.ne.j) then
                         Reshapes(symgp)%ReshapedMatrix(row,col) = 1
                       else
                         Reshapes(symgp)%ReshapedMatrix(row,col) = 0
                       end if
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do


       do p=1,numSG
           allocate(temp(1:ReshapedMatrixDim%ijaa(p)%col,1:ReshapedMatrixDim%ijaa(p)%col))
           temp = matmul4(K2(1,1,1,1)%aa%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
           do q=1,ReshapedMatrixDim%ijaa(p)%col
             energyconstants = energyconstants + 2*temp(q,q)
           end do
           deallocate(temp)
         end do

      deallocate(Reshapes)
      allocate(Reshapes(1:numSG))
       do p=1,numSG
          allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ijab(p)%col,1:ReshapedMatrixDim%ijab(p)%col))
       end do

      do symgp=1,numSG
         col =0
         do t=1,numSG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             i_begin = occ(1,p)
             i_end   = occ(2,p)
             j_begin = occ(1,q)
             j_end   = occ(2,q)
             do i=i_begin,i_end
               do j=j_begin,j_end
                 col = col + 1
                 row = 1
                 do v=1,numSG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   k_begin = occ(1,r)
                   k_end   = occ(2,r)
                   l_begin = occ(1,s)
                   l_end   = occ(2,s)
                   do k=k_begin,k_end
                     do l=l_begin,l_end
                       if(i==k.and.j==l) then
                         Reshapes(symgp)%ReshapedMatrix(row,col) = 2*0.5
                       else
                         Reshapes(symgp)%ReshapedMatrix(row,col) = 0
                       end if
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do
       do p=1,numSG
         allocate(temp(1:ReshapedMatrixDim%ijab(p)%col,1:ReshapedMatrixDim%ijab(p)%col))
         temp = matmul4(K2(1,1,1,1)%ab%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
         do q=1,ReshapedMatrixDim%ijab(p)%col
           energyconstants = energyconstants + temp(q,q)
         end do
         deallocate(temp)
       end do
       deallocate(Reshapes)

       allocate(Reshapes(1:numSG))
       do p=1,numSG
         i_begin = occ(1,p)
         i_end   = occ(2,p)
         allocate(Reshapes(p)%ReshapedMatrix(i_begin:i_end,i_begin:i_end))
         Reshapes(p)%ReshapedMatrix(i_begin:i_end,i_begin:i_end) = 0.D0
      end do
       do p=1,numSG
         i_begin=occ(1,p)
         i_end  =occ(2,p)
         do i=i_begin,i_end
           Reshapes(p)%ReshapedMatrix(i,i) = 1
         end do
       end do


       do p=1,numSG
         i_begin = occ(1,p)
         i_end   = occ(2,p)
         allocate(temp(1:(i_end-i_begin+1),1:(i_end-i_begin +1)))
         temp = matmul(Reshapes(p)%ReshapedMatrix,K1(1,1)%aa%irrep(p)%block)
         do t=1,(i_end-i_begin+1)
           energyconstants = 2*temp(t,t) + energyconstants
         end do
         deallocate(temp)
       end do
       1600 format(1X,'Hartree Fock Electronic Energy:',8X,F30.14)
       write(*,1600) energyconstants

       call cpu_time(time_end)
        time_calcenergy = time_calcenergy + time_end - time_begin
      end subroutine CalcEnergy

!> @brief Takes parameters from LBFGS and sends them to storage arrays
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine CalcParametersInverse(SG,occ,virt,T2data,InvPdt,Tvector,T1data)
       USE TypeMod;
       Use TimeMod, only : time_calcparametersinverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       type(T2), intent(INOUT) :: T2data
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       double precision, allocatable, dimension(:)  :: Tvector
       type(T1), intent(INOUT) :: T1data

       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end
       integer :: a,j,c,k
       integer :: row,col,c_begin,c_end,k_begin,k_end,t,v
       integer :: counter
       real :: time_begin, time_end
       Call CPU_Time(time_begin)

       counter = 1
       do symgp=1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 k_begin = occ(1,s)
                 k_end   = occ(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     T2data%aa%m(a,j)%nsym(r,s)%n(c,k) = Tvector(counter)
                     counter = counter + 1
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
       do symgp=1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 k_begin = occ(1,s)
                 k_end   = occ(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     T2data%ab%m(a,j)%nsym(r,s)%n(c,k) = Tvector(counter)
                     counter = counter + 1
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

      do symgp=1,SG
        j_begin = occ(1,symgp)
        j_end   = occ(2,symgp)
        a_begin = virt(1,symgp)
        a_end   = virt(2,symgp)
        do j=j_begin,j_end
          do a=a_begin,a_end
            T1data%a%o(j)%vsym(symgp)%v(a) = Tvector(counter)
            counter = counter + 1
          end do
        end do
      end do


    Call CPU_Time(time_end)
      time_calcparametersinverse = time_end - time_begin + time_calcparametersinverse
      end subroutine CalcParametersInverse

!> @brief Symmetrizes derivative for equivalent T2 parameters
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine AveDeriv(numOcc,numVirt,InvPdt,numSG,occ,virt,ProductTable,SymO,SymV,T2deriv)
       USE TypeMod
       USE InterfaceMod
       Use TimeMod, only : time_avederiv
       Implicit NONE

       integer :: numOcc,numVirt,numSG
       integer, intent(IN), allocatable, dimension(:) :: SymV,SymO
       type(symmetry), allocatable, dimension(:) :: InvPdt
       type(T2) :: T2deriv
       integer, intent(IN), allocatable, dimension(:,:) :: occ,virt
       integer, allocatable, dimension(:,:) :: ProductTable
       integer :: flag

       integer :: t
       integer :: a,j,i,b,i_begin,i_end,b_begin,b_end,isym,bsym,symtop,j_begin,j_end,jsym
       double precision :: average, total
       real :: time_begin, time_end

       call cpu_time(time_begin)


      do j=1,numOcc
        do a=numOcc+1,numOcc+numVirt
          symtop = ProductTable(SymV(a),SymO(j))
          do t=1,numSG
            bsym = InvPdt(symtop)%upper(t)
            isym = InvPdt(symtop)%lower(t)
            b_begin = virt(1,bsym)
            b_end   = virt(2,bsym)
            i_begin = occ(1,isym)
            i_end   = occ(2,isym)
            do i=i_begin,i_end
              do b=b_begin,b_end
                average = T2deriv%ab%m(a,j)%nsym(bsym,isym)%n(b,i) + T2deriv%ab%m(b,i)%nsym(SymV(a),SymO(j))%n(a,j)
                T2deriv%ab%m(b,i)%nsym(SymV(a),SymO(j))%n(a,j) = average*0.50000000000000000000
                T2deriv%ab%m(a,j)%nsym(bsym,isym)%n(b,i) = average*0.500000000000000000000
              end do
            end do
          end do
        end do
      end do


     do i=1,numOcc
       do a=numOcc+1,numOcc+numVirt
         symtop = ProductTable(SymV(a),SymO(i))
         do t=1,numSG
            bsym = InvPdt(symtop)%upper(t)
            jsym = InvPdt(symtop)%lower(t)
            b_begin = virt(1,bsym)
            b_end   = virt(2,bsym)
            j_begin = occ(1,jsym)
            j_end   = occ(2,jsym)
            do j=j_begin,j_end
              do b=b_begin,b_end
                 if(i.eq.j.or.a.eq.b) then
                    T2deriv%aa%m(a,i)%nsym(bsym,jsym)%n(b,j) = 0
                    T2deriv%aa%m(b,j)%nsym(SymV(a),SymO(i))%n(a,i) = 0
                  end if
                 if(i.lt.j.and.a.lt.b) then
                    total = T2deriv%aa%m(a,i)%nsym(bsym,jsym)%n(b,j) - T2deriv%aa%m(a,j)%nsym(bsym,SymO(i))%n(b,i) -  T2deriv%aa%m(b,i)%nsym(SymV(a),jsym)%n(a,j) + T2deriv%aa%m(b,j)%nsym(SymV(a),SymO(i))%n(a,i)
                    T2deriv%aa%m(a,i)%nsym(bsym,jsym)%n(b,j) = total*.25000000000000000
                    T2deriv%aa%m(a,j)%nsym(bsym,SymO(i))%n(b,i) = total*.25000000000000000000000*-1
                    T2deriv%aa%m(b,i)%nsym(SymV(a),jsym)%n(a,j) = total*.25000000000000000000000*-1
                    T2deriv%aa%m(b,j)%nsym(SymV(a),SymO(i))%n(a,i) = total*.250000000000000000000000
                 end if
              end do
           end do
         end do
      end do
    end do

call cpu_time(time_end)
   time_avederiv = time_avederiv + time_end - time_begin

       end subroutine AveDeriv

       subroutine reshape_t1_ibrow(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_t1_ibrow
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,i,b,i_begin,i_end, b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: row,col, numa, numi
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end
       integer :: total

       Call CPU_TIME(time_begin)

       total = 0
       do p=1,SG
         numa = virt(2,p) - virt(1,p) + 1
         numi = occ(2,p) - occ(1,p) + 1
         total = total + numa*numi
       end do
       do p=1,SG
         allocate(Reshapes(p)%ReshapedMatrix(1:1,1:2*total))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:2*total,1:1))
       end do

       do symgp=1,SG
         col = 1
         row = 1
         do p=1,SG
         i_begin = occ(1,p)
         i_end   = occ(2,p)
         b_begin = virt(1,p)
         b_end   = virt(2,p)
         do i=i_begin,i_end
           do b=b_begin,b_end
             Reshapes(symgp)%ReshapedMatrix(row,col) = T1data%a%o(i)%vsym(p)%v(b)
             col = col + 1
             maxrow_SG(symgp) = col
           end do
         end do
       end do
     end do


       do symgp=1,SG
         col = maxrow_SG(symgp)
          row = 1
         do p=1,SG
         i_begin = occ(1,p)
         i_end   = occ(2,p)
         b_begin = virt(1,p)
         b_end   = virt(2,p)
         do i=i_begin,i_end
           do b=b_begin,b_end
             Reshapes(symgp)%ReshapedMatrix(row,col) = T1data%a%o(i)%vsym(p)%v(b)
              col = col + 1
           end do
         end do
       end do
     end do

          Call CPU_TIME(time_end)
          time_t1_ibrow = time_end - time_begin + time_t1_ibrow



      end subroutine reshape_t1_ibrow


       subroutine reshape_jka_aaa(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_jka_aaa
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,a_begin,a_end,j_begin,j_end,k_begin,k_end,b_begin,b_end
       integer :: a,j,b,k
       integer :: row,col,t,p,q,u,r,s
       real :: time_begin,time_end
       integer :: numb

       Call CPU_TIME(time_begin)

       do p=1,SG
        numb = virt(2,p) - virt(1,p) + 1
        allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%jka_aaa(p)%row,1:ReshapedMatrixDim%jka_aaa(p)%col))
        allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%jka_aaa(p)%col,1:ReshapedMatrixDim%jka_aaa(p)%row))
        DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%jka_aaa(p)%col,1:ReshapedMatrixDim%jka_aaa(p)%row) = 0.D0
       end do
       do symgp=1,SG
         row = 1
         col = 0
         b_begin = virt(1,symgp)
         b_end   = virt(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                   col = col + 1
                   row = 1
                   do b=b_begin,b_end
                     Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%aa%m(a,j)%nsym(symgp,q)%n(b,k)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_jka_aaa = time_end - time_begin + time_jka_aaa


      end subroutine reshape_jka_aaa


       subroutine reshape_bci_aaa(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_bci_aaa
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,j_begin,j_end,i_begin,i_end,b_begin,b_end, c_end, c_begin
       integer :: b,c,i,j
       integer :: row,col,t,p,q,u,r,s, numj
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
        numj = occ(2,p) - occ(1,p) + 1
        allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%bci_aaa(p)%row,1:ReshapedMatrixDim%bci_aaa(p)%col))
        allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%bci_aaa(p)%col,1:ReshapedMatrixDim%bci_aaa(p)%row))
       end do

       do symgp=1,SG
         row = 1
         col = 0
         j_begin = occ(1,symgp)
         j_end   = occ(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=max(c_begin,b+1),c_end
                   col = col + 1
                   row = 1
                   do j=j_begin,j_end
                     Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%aa%m(b,i)%nsym(q,symgp)%n(c,j)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_bci_aaa = time_end - time_begin + time_bci_aaa

      end subroutine reshape_bci_aaa


       subroutine reshape_jka_abb(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_jka_abb
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,a_begin,a_end,j_begin,j_end,k_begin,k_end,b_begin,b_end
       integer :: a,j,b,k
       integer :: row,col,t,p,q,u,r,s
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
        allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%jka_abb(p)%row,1:ReshapedMatrixDim%jka_abb(p)%col))
        allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%jka_abb(p)%col,1:ReshapedMatrixDim%jka_abb(p)%row))
       end do

       do symgp=1,SG
         row = 1
         col = 0
         b_begin = virt(1,symgp)
         b_end   = virt(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do k=k_begin,k_end
                 do a=a_begin,a_end
                   col = col + 1
                   row = 1
                   do b=b_begin,b_end
                     Reshapes(symgp)%ReshapedMatrix(row,col) = 1*T2data%ab%m(b,j)%nsym(r,q)%n(a,k)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_jka_abb = time_end - time_begin + time_jka_abb


      end subroutine reshape_jka_abb


       subroutine reshape_jka_aba(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_jka_aba
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,a_begin,a_end,j_begin,j_end,k_begin,k_end,b_begin,b_end
       integer :: a,j,b,k
       integer :: row,col,t,p,q,u,r,s
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
        allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%jka_aba(p)%row,1:ReshapedMatrixDim%jka_aba(p)%col))
        allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%jka_aba(p)%col,1:ReshapedMatrixDim%jka_aba(p)%row))
       end do

       do symgp=1,SG
         row = 1
         col = 0
         b_begin = virt(1,symgp)
         b_end   = virt(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=k_begin,k_end
                   col = col + 1
                   row = 1
                   do b=b_begin,b_end
                     Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%ab%m(a,j)%nsym(symgp,q)%n(b,k)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_jka_aba = time_end - time_begin + time_jka_aba



      end subroutine reshape_jka_aba


       subroutine reshape_bci_aba(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_bci_aba
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,j_begin,j_end,i_begin,i_end,b_begin,b_end, c_end, c_begin
       integer :: b,c,i,j
       integer :: row,col,t,p,q,u,r,s
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
        allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%bci_aba(p)%row,1:ReshapedMatrixDim%bci_aba(p)%col))
        allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%bci_aba(p)%col,1:ReshapedMatrixDim%bci_aba(p)%row))
       end do

       do symgp=1,SG
         row = 1
         col = 0
         j_begin = occ(1,symgp)
         j_end   = occ(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=c_begin,c_end
                   col = col + 1
                   row = 1
                   do j=j_begin,j_end
                     Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%ab%m(b,i)%nsym(q,symgp)%n(c,j)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_bci_aba = time_end - time_begin + time_bci_aba



      end subroutine reshape_bci_aba


       subroutine reshape_bci_abb(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_bci_abb
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,j_begin,j_end,i_begin,i_end,b_begin,b_end, c_end, c_begin
       integer :: b,c,i,j
       integer :: row,col,t,p,q,u,r,s
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
        allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%bci_abb(p)%row,1:ReshapedMatrixDim%bci_abb(p)%col))
        allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%bci_abb(p)%col,1:ReshapedMatrixDim%bci_abb(p)%row))
       end do

       do symgp=1,SG
         row = 1
         col = 0
         j_begin = occ(1,symgp)
         j_end   = occ(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             do b=b_begin,b_end
               do i=i_begin,i_end
                 do c=c_begin,c_end
                   col = col + 1
                   row = 1
                   do j=j_begin,j_end
                     Reshapes(symgp)%ReshapedMatrix(row,col) = 1*T2data%ab%m(b,j)%nsym(q,s)%n(c,i)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_bci_abb = time_end - time_begin + time_bci_abb



      end subroutine reshape_bci_abb


       subroutine reshape_t1_b(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_t1_b
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,i_begin,i_end,b_begin,b_end,p
       integer :: i,b
       integer :: row,col, numi,numb
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
         numb = virt(2,p) - virt(1,p) + 1
         numi = occ(2,p) - occ(1,p)   + 1
         allocate(Reshapes(p)%ReshapedMatrix(1:numi,1:numb))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:numb,1:numi))
       end do

       do symgp=1,SG
         col = 0
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         b_begin = virt(1,symgp)
         b_end   = virt(2,symgp)
         do b=b_begin,b_end
           col = col + 1
           row = 1
           do i=i_begin,i_end
             Reshapes(symgp)%ReshapedMatrix(row,col) = T1data%a%o(i)%vsym(symgp)%v(b)
             row = row + 1
           end do
         end do
       end do

       Call CPU_TIME(time_end)
       time_t1_b = time_end - time_begin + time_t1_b



      end subroutine reshape_t1_b


       subroutine reshape_jka_aaa_inverse(SG,ProductTable,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_jka_aaa_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,a_begin,a_end,j_begin,j_end,k_begin,k_end,b_begin,b_end
       integer :: a,j,b,k
       integer :: row,col,t,p,q,u,r,s
       real :: time_begin,time_end
       integer :: numb

       Call CPU_TIME(time_begin)

       do symgp=1,SG
          row = 0
          col = 1
         b_begin = virt(1,symgp)
         b_end   = virt(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                    row = row + 1
                    col = 1
                   do b=b_begin,b_end
                     T2deriv%aa%m(a,j)%nsym(symgp,q)%n(b,k) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%aa%m(a,j)%nsym(symgp,q)%n(b,k)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
          Call CPU_TIME(time_end)
          time_jka_aaa_inverse = time_end - time_begin + time_jka_aaa_inverse



      end subroutine reshape_jka_aaa_inverse


       subroutine reshape_t1_b_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_t1_b_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,i_begin,i_end,b_begin,b_end,p
       integer :: i,b
       integer :: row,col
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)


       do symgp=1,SG
          row = 0
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         b_begin = virt(1,symgp)
         b_end   = virt(2,symgp)
         do b=b_begin,b_end
            row = row + 1
            col = 1
           do i=i_begin,i_end
             T1deriv%a%o(i)%vsym(symgp)%v(b) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T1deriv%a%o(i)%vsym(symgp)%v(b)
             col = col + 1
           end do
         end do
       end do

       Call CPU_TIME(time_end)
       time_t1_b_inverse = time_end - time_begin + time_t1_b_inverse



      end subroutine reshape_t1_b_inverse


       subroutine reshape_bci_aaa_inverse(SG,ProductTable,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_bci_aaa_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,j_begin,j_end,i_begin,i_end,b_begin,b_end, c_end, c_begin
       integer :: b,c,i,j
       integer :: row,col,t,p,q,u,r,s, numj
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do symgp=1,SG
          row = 0
          col = 1
         j_begin = occ(1,symgp)
         j_end   = occ(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=max(c_begin,b+1),c_end
                    row = row + 1
                    col = 1
                   do j=j_begin,j_end
                      T2deriv%aa%m(b,i)%nsym(q,symgp)%n(c,j) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%aa%m(b,i)%nsym(q,symgp)%n(c,j)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_bci_aaa_inverse = time_end - time_begin + time_bci_aaa_inverse



      end subroutine reshape_bci_aaa_inverse


       subroutine reshape_t1_i(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_t1_i
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,i_begin,i_end,b_begin,b_end,p
       integer :: i,b
       integer :: row,col, numi,numb
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
         numi = occ(2,p) - occ(1,p) + 1
         numb = virt(2,p) - virt(1,p) + 1
         allocate(Reshapes(p)%ReshapedMatrix(1:numb,1:numi))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:numi,1:numb))
       end do

       do symgp=1,SG
         col = 0
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         b_begin = virt(1,symgp)
         b_end   = virt(2,symgp)
         do i=i_begin,i_end
           col = col + 1
           row = 1
           do b=b_begin,b_end
             Reshapes(symgp)%ReshapedMatrix(row,col) = T1data%a%o(i)%vsym(symgp)%v(b)
             row = row + 1
           end do
         end do
       end do
       Call CPU_TIME(time_end)
       time_t1_i = time_end - time_begin + time_t1_i



      end subroutine reshape_t1_i


       subroutine reshape_t1_i_inverse(SG,ProductTable,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_t1_i_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,i_begin,i_end,b_begin,b_end,p
       integer :: i,b
       integer :: row,col, numi,numb
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)


       do symgp=1,SG
          row = 0
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         b_begin = virt(1,symgp)
         b_end   = virt(2,symgp)
         do i=i_begin,i_end
            row = row + 1
            col = 1
           do b=b_begin,b_end
             T1deriv%a%o(i)%vsym(symgp)%v(b) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T1deriv%a%o(i)%vsym(symgp)%v(b)
              col = col + 1
           end do
         end do
       end do

       Call CPU_TIME(time_end)
       time_t1_i_inverse = time_end - time_begin + time_t1_i_inverse



      end subroutine reshape_t1_i_inverse


       subroutine reshape_jka_abb_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_jka_abb_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,a_begin,a_end,j_begin,j_end,k_begin,k_end,b_begin,b_end
       integer :: a,j,b,k
       integer :: row,col,t,p,q,u,r,s
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do symgp=1,SG
          row = 0
          col = 1
         b_begin = virt(1,symgp)
         b_end   = virt(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do k=k_begin,k_end
                 do a=a_begin,a_end
                    row = row + 1
                    col = 1
                   do b=b_begin,b_end
                      T2deriv%ab%m(b,j)%nsym(r,q)%n(a,k) =  1*DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(b,j)%nsym(r,q)%n(a,k)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_jka_abb_inverse = time_end - time_begin + time_jka_abb_inverse



      end subroutine reshape_jka_abb_inverse


       subroutine reshape_jka_aba_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_jka_aba_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,a_begin,a_end,j_begin,j_end,k_begin,k_end,b_begin,b_end
       integer :: a,j,b,k
       integer :: row,col,t,p,q,u,r,s
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do symgp=1,SG
          col = 1
          row = 0
         b_begin = virt(1,symgp)
         b_end   = virt(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=k_begin,k_end
                    col = 1
                    row = row + 1
                   do b=b_begin,b_end
                     T2deriv%ab%m(a,j)%nsym(symgp,q)%n(b,k) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(a,j)%nsym(symgp,q)%n(b,k)
                   col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_jka_aba_inverse = time_end - time_begin + time_jka_aba_inverse



      end subroutine reshape_jka_aba_inverse


       subroutine reshape_bci_aba_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_bci_aba_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,j_begin,j_end,i_begin,i_end,b_begin,b_end, c_end, c_begin
       integer :: b,c,i,j
       integer :: row,col,t,p,q,u,r,s
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)


       do symgp=1,SG
          col = 1
          row = 0
         j_begin = occ(1,symgp)
         j_end   = occ(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=c_begin,c_end
                    row = row + 1
                    col = 1
                   do j=j_begin,j_end
                    T2deriv%ab%m(b,i)%nsym(q,symgp)%n(c,j) =  DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(b,i)%nsym(q,symgp)%n(c,j)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_bci_aba_inverse = time_end - time_begin + time_bci_aba_inverse



      end subroutine reshape_bci_aba_inverse


       subroutine reshape_bci_abb_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_bci_abb_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,j_begin,j_end,i_begin,i_end,b_begin,b_end, c_end, c_begin
       integer :: b,c,i,j
       integer :: row,col,t,p,q,u,r,s
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do symgp=1,SG
          col = 1
          row = 0
         j_begin = occ(1,symgp)
         j_end   = occ(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             do b=b_begin,b_end
               do i=i_begin,i_end
                 do c=c_begin,c_end
                    row = row + 1
                    col = 1
                   do j=j_begin,j_end
                     T2deriv%ab%m(b,j)%nsym(q,s)%n(c,i) = 1*DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(b,j)%nsym(q,s)%n(c,i)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_bci_abb_inverse = time_end - time_begin + time_bci_abb_inverse



      end subroutine reshape_bci_abb_inverse


       subroutine reshape_t1t1_i(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_t1t1_i
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,i_begin,i_end,b_begin,b_end,p
       integer :: i,b
       integer :: row,col, numi,numb
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
         numi = occ(2,p) - occ(1,p) + 1
         numb = virt(2,p) - virt(1,p) + 1
         allocate(Reshapes(p)%ReshapedMatrix(1:numb,1:numi))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:numb,1:numi))
       end do

       do symgp=1,SG
         col = 0
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         b_begin = virt(1,symgp)
         b_end   = virt(2,symgp)
         do i=i_begin,i_end
           col = col + 1
           row = 1
           do b=b_begin,b_end
             Reshapes(symgp)%ReshapedMatrix(row,col) = T1data%a%o(i)%vsym(symgp)%v(b)
             row = row + 1
           end do
         end do
       end do

       Call CPU_TIME(time_end)
       time_t1t1_i = time_end - time_begin + time_t1t1_i


      end subroutine reshape_t1t1_i


       subroutine reshape_t1t1_i_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_t1t1_i_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,i_begin,i_end,b_begin,b_end,p
       integer :: i,b
       integer :: row,col, numi,numb
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do symgp=1,SG
         col = 0
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         b_begin = virt(1,symgp)
         b_end   = virt(2,symgp)
         do i=i_begin,i_end
           col = col + 1
           row = 1
           do b=b_begin,b_end
           T1deriv%a%o(i)%vsym(symgp)%v(b) =  DerivReshapes(symgp)%ReshapedMatrix(row,col) + T1deriv%a%o(i)%vsym(symgp)%v(b)
             row = row + 1
           end do
         end do
       end do

       Call CPU_TIME(time_end)
       time_t1t1_i_inverse = time_end - time_begin + time_t1t1_i_inverse



      end subroutine reshape_t1t1_i_inverse


       subroutine reshape_ajaa_t1(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_ajaa_t1
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end,i_begin,i_end,b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: a,j,c,k,b,i
       integer :: row,col,c_begin,c_end,k_begin,k_end,t,v
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
         allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajaa_t1(p)%row,1:ReshapedMatrixDim%ajaa_t1(p)%col))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajaa_t1(p)%col,1:ReshapedMatrixDim%ajaa_t1(p)%row))
       end do

     row = 1
       do symgp=1,SG
         col = 0
           a_begin = virt(1,symgp)
           a_end   = virt(2,symgp)
           i_begin = occ(1,symgp)
           i_end   = occ(2,symgp)
           do i=i_begin,i_end
             do a=a_begin,a_end
               col = col + 1
               row = 1
               do p=1,SG
                 b_begin = virt(1,p)
                 b_end   = virt(2,p)
                 j_begin = occ(1,p)
                 j_end   = occ(2,p)
                 do j=j_begin,j_end
                   do b=b_begin,b_end
                    Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%aa%m(a,i)%nsym(p,p)%n(b,j)
                    row = row + 1
               maxrow_SG(symgp) = row
                  end do
                end do
              end do
            end do
          end do
        end do



       do symgp=1,SG
         col = 0
         a_begin = virt(1,symgp)
         a_end   = virt(2,symgp)
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         do i=i_begin,i_end
           do a=a_begin,a_end
             col = col + 1
             row = maxrow_SG(symgp)
             do p=1,SG
               b_begin = virt(1,p)
               b_end   = virt(2,p)
               j_begin = occ(1,p)
               j_end   = occ(2,p)
               do j=j_begin,j_end
                 do b=b_begin,b_end
                   Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%ab%m(a,i)%nsym(p,p)%n(b,j)
                       row = row + 1
                      end do
                    end do
                  end do
                end do
              end do
            end do

          Call CPU_TIME(time_end)
          time_ajaa_t1 = time_end - time_begin + time_ajaa_t1



      end subroutine reshape_ajaa_t1


       subroutine reshape_ajaa_t1_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_ajaa_t1_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end,b_begin,b_end,i_begin,i_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: a,j,c,k,b,i
       integer :: row,col,c_begin,c_end,k_begin,k_end,t,v
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

      col = 1
       do symgp=1,SG
          row = 0
           a_begin = virt(1,symgp)
           a_end   = virt(2,symgp)
           i_begin = occ(1,symgp)
           i_end   = occ(2,symgp)
           do i=i_begin,i_end
             do a=a_begin,a_end
                row = row + 1
                col = 1
               do p=1,SG
                 b_begin = virt(1,p)
                 b_end   = virt(2,p)
                 j_begin = occ(1,p)
                 j_end   = occ(2,p)
                 do j=j_begin,j_end
                   do b=b_begin,b_end
                    T2deriv%aa%m(a,i)%nsym(p,p)%n(b,j) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%aa%m(a,i)%nsym(p,p)%n(b,j)
                     col = col + 1
                maxrow_SG(symgp) = col
                  end do
                end do
              end do
            end do
          end do
        end do


       do symgp=1,SG
          row = 0
         a_begin = virt(1,symgp)
         a_end   = virt(2,symgp)
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         do i=i_begin,i_end
           do a=a_begin,a_end
              row = row + 1
              col = maxrow_SG(symgp)
             do p=1,SG
               b_begin = virt(1,p)
               b_end   = virt(2,p)
               j_begin = occ(1,p)
               j_end   = occ(2,p)
               do j=j_begin,j_end
                 do b=b_begin,b_end
                   T2deriv%ab%m(a,i)%nsym(p,p)%n(b,j) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(a,i)%nsym(p,p)%n(b,j)
                      col = col + 1
                      end do
                    end do
                  end do
                end do
              end do
            end do

          Call CPU_TIME(time_end)
          time_ajaa_t1_inverse = time_end - time_begin + time_ajaa_t1_inverse



      end subroutine reshape_ajaa_t1_inverse


       subroutine reshape_t1_ibrow_alphaonly(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_t1_ibrow_alphaonly
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,i,b,i_begin,i_end, b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: row,col, numa, numi
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end
       integer :: total

       Call CPU_TIME(time_begin)

       total = 0
       do p=1,SG
         numa = virt(2,p) - virt(1,p) + 1
         numi = occ(2,p) - occ(1,p) + 1
         total = total + numa*numi
       end do
       do p=1,SG
         allocate(Reshapes(p)%ReshapedMatrix(1:1,1:total))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:total,1:1))
         DerivReshapes(p)%ReshapedMatrix(1:total,1:1) = 0.0
         Reshapes(p)%ReshapedMatrix(1:1,1:total) = 0.0
       end do

       do symgp=1,SG
         col = 1
         row = 1
         do p=1,SG
         i_begin = occ(1,p)
         i_end   = occ(2,p)
         b_begin = virt(1,p)
         b_end   = virt(2,p)
         do i=i_begin,i_end
           do b=b_begin,b_end
             Reshapes(symgp)%ReshapedMatrix(row,col) = T1data%a%o(i)%vsym(p)%v(b)
             col = col + 1
             maxrow_SG(symgp) = col
           end do
         end do
        end do
       end do


          Call CPU_TIME(time_end)
          time_t1_ibrow_alphaonly = time_end - time_begin + time_t1_ibrow_alphaonly


      end subroutine reshape_t1_ibrow_alphaonly

       subroutine reshape_t1_ibrow_alphaonly_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_t1_ibrow_alphaonly_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,i,b,i_begin,i_end, b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: row,col, numa, numi
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do symgp=1,SG
         col = 1
         row = 1
         do p=1,SG
         i_begin = occ(1,p)
         i_end   = occ(2,p)
         b_begin = virt(1,p)
         b_end   = virt(2,p)
         do i=i_begin,i_end
           do b=b_begin,b_end
             T1deriv%a%o(i)%vsym(p)%v(b) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T1deriv%a%o(i)%vsym(p)%v(b)
             row = row + 1
             maxrow_SG(symgp) = row
           end do
         end do
        end do
       end do



          Call CPU_TIME(time_end)
          time_t1_ibrow_alphaonly_inverse = time_end - time_begin + time_t1_ibrow_alphaonly_inverse


      end subroutine reshape_t1_ibrow_alphaonly_inverse

       subroutine reshape_t1_ibrow_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_t1_ibrow_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,i,b,i_begin,i_end, b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: row,col, numa, numi
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)


       do symgp=1,SG
         col = 1
         row = 1
         do p=1,SG
         i_begin = occ(1,p)
         i_end   = occ(2,p)
         b_begin = virt(1,p)
         b_end   = virt(2,p)
         do i=i_begin,i_end
           do b=b_begin,b_end
             T1deriv%a%o(i)%vsym(p)%v(b) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T1deriv%a%o(i)%vsym(p)%v(b)
             row = row + 1
             maxrow_SG(symgp) = row
           end do
         end do
       end do
     end do


       do symgp=1,SG
         row = maxrow_SG(symgp)
          col = 1
         do p=1,SG
         i_begin = occ(1,p)
         i_end   = occ(2,p)
         b_begin = virt(1,p)
         b_end   = virt(2,p)
         do i=i_begin,i_end
           do b=b_begin,b_end
             T1deriv%a%o(i)%vsym(p)%v(b) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T1deriv%a%o(i)%vsym(p)%v(b)
             row = row + 1
           end do
         end do
       end do
     end do

          Call CPU_TIME(time_end)
          time_t1_ibrow_inverse = time_end - time_begin + time_t1_ibrow_inverse


      end subroutine reshape_t1_ibrow_inverse

       subroutine reshape_t1_ibcol_alphaonly(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_t1_ibcol_alphaonly
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,i,b,i_begin,i_end, b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: row,col, numa, numi
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end
       integer :: total
       Call CPU_TIME(time_begin)

       total = 0
       do p=1,SG
         numa = virt(2,p) - virt(1,p) + 1
         numi = occ(2,p) - occ(1,p) + 1
         total = total + numa*numi
       end do
       do p=1,SG
         allocate(Reshapes(p)%ReshapedMatrix(1:total,1:1))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:1,1:total))
         Reshapes(p)%ReshapedMatrix = 0.0
         DerivReshapes(p)%ReshapedMatrix = 0.0
       end do

       do symgp=1,SG
         col = 1
         row = 1
         do p=1,SG
         i_begin = occ(1,p)
         i_end   = occ(2,p)
         b_begin = virt(1,p)
         b_end   = virt(2,p)
         do i=i_begin,i_end
           do b=b_begin,b_end
             Reshapes(symgp)%ReshapedMatrix(row,col) = T1data%a%o(i)%vsym(p)%v(b)
             row = row + 1
             maxrow_SG(symgp) = row
           end do
         end do
        end do
       end do



          Call CPU_TIME(time_end)
          time_t1_ibcol_alphaonly = time_end - time_begin + time_t1_ibcol_alphaonly


      end subroutine reshape_t1_ibcol_alphaonly

       subroutine reshape_t1_ibcol_alphaonly_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_t1_ibcol_alphaonly_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,i,b,i_begin,i_end, b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: row,col, numa, numi
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do symgp=1,SG
         col = 1
         row = 1
         do p=1,SG
         i_begin = occ(1,p)
         i_end   = occ(2,p)
         b_begin = virt(1,p)
         b_end   = virt(2,p)
         do i=i_begin,i_end
           do b=b_begin,b_end
             T1deriv%a%o(i)%vsym(p)%v(b) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T1deriv%a%o(i)%vsym(p)%v(b)
             col = col + 1
             maxrow_SG(symgp) = col
           end do
         end do
        end do
       end do



          Call CPU_TIME(time_end)
          time_t1_ibcol_alphaonly_inverse = time_end - time_begin + time_t1_ibcol_alphaonly_inverse


      end subroutine reshape_t1_ibcol_alphaonly_inverse

       subroutine reshape_t1_ibrow_alphaonly_symi(SG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_t1_ibrow_alphaonly
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,i,b,i_begin,i_end, b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: row,col, numa, numi
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end
       integer :: total

       Call CPU_TIME(time_begin)

       total = 0
       do p=1,SG
         numa = virt(2,p) - virt(1,p) + 1
         numi = occ(2,p) - occ(1,p) + 1
         allocate(Reshapes(p)%ReshapedMatrix(1:1,1:numa*numi))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:numa*numi,1:1))
       end do

       do symgp=1,SG
         col = 1
         row = 1
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         b_begin = virt(1,symgp)
         b_end   = virt(2,symgp)
         do i=i_begin,i_end
           do b=b_begin,b_end
             Reshapes(symgp)%ReshapedMatrix(row,col) = T1data%a%o(i)%vsym(symgp)%v(b)
             col = col + 1
             maxrow_SG(symgp) = col
           end do
         end do
       end do


          Call CPU_TIME(time_end)
          time_t1_ibrow_alphaonly = time_end - time_begin + time_t1_ibrow_alphaonly


      end subroutine  reshape_t1_ibrow_alphaonly_symi

       subroutine reshape_t1_ibrow_alphaonly_symi_inverse(SG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_t1_ibrow_alphaonly_inverse
       Implicit None
       integer, intent(IN) :: SG,numOcc,numVirt
       integer, intent(IN),  dimension(1:2,1:SG) :: occ,virt
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,i,b,i_begin,i_end, b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: row,col, numa, numi
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do symgp=1,SG
         col = 1
         row = 1
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         b_begin = virt(1,symgp)
         b_end   = virt(2,symgp)
         do i=i_begin,i_end
           do b=b_begin,b_end
             T1deriv%a%o(i)%vsym(symgp)%v(b) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T1deriv%a%o(i)%vsym(symgp)%v(b)
             row = row + 1
             maxrow_SG(symgp) = row
           end do
         end do
       end do



          Call CPU_TIME(time_end)
          time_t1_ibrow_alphaonly_inverse = time_end - time_begin + time_t1_ibrow_alphaonly_inverse


      end subroutine reshape_t1_ibrow_alphaonly_symi_inverse

!> @brief Calculates the topological factor value for user chosen parameterization
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine TopFactor(TwoInts,T2data,occ,virt,numSG,topfac,Newc,InvPdt,ProductTable,DerivNewc,numocc,numvirt,T1data,T1deriv,topsingles)

       Use InterfaceMod
       Use TypeMod
       Use TimeMod, only : time_topfactor
       IMPLICIT None

       type(T2) :: T2data, Newc, DerivNewc
       type(T1) :: T1data,T1deriv
       integer, intent(IN) :: numSG
       integer, intent(IN), dimension(1:2,1:numSG) :: occ,virt
       real(8), intent(IN), dimension(0:2,0:2) :: topfac(0:2,0:2)
       type(symmetry), dimension(:) :: InvPdt(1:numSG)
       integer, dimension(1:numSG,1:numSG) :: ProductTable
       real(8) :: total
       integer :: i,j,a,b,c,d,k,l,p,q,r,s,symgp,v,t,u
       integer :: i_begin,i_end,j_begin,j_end,a_begin,a_end,b_begin,b_end
       integer :: c_begin,c_end, d_begin,d_end, k_begin,k_end, l_begin,l_end
       integer :: cisym, aksym
       integer :: numocc,numvirt
       real(8), dimension(:,:) :: topsingles(0:1,0:1)
       real(8), dimension(:) :: singles_cumi(1:numocc)
       real(8), dimension(:) :: singles_cuma(numocc+1:numocc+numvirt)
       real(8), allocatable, dimension(:,:,:,:) :: TwoInts(:,:,:,:)



       real(8) :: pizero,singles_pizero
       real(8), allocatable, dimension(:) :: cumocc, cumvirt
       real(8), allocatable, dimension(:,:) :: cumaj_aa, cumaj_ab,cumaj_ba,cumaj_bb
       real(8), allocatable, dimension(:,:) :: cumij_aa, cumij_ab
       real(8), allocatable, dimension(:,:) :: cumab_aa, cumab_ab
       real(8), allocatable, dimension(:,:,:) :: pi_ija_aaa, pi_ija_aba,pi_ijb_abb
       real(8), allocatable, dimension(:,:,:) :: pi_iab_aaa, pi_iab_aab, pi_jab_bab

       real(8) :: pizero_deriv
       real(8), allocatable, dimension(:) :: cumocc_deriv, cumvirt_deriv
       real(8), allocatable, dimension(:,:) :: cumaj_aa_deriv,cumaj_ab_deriv,cumaj_ba_deriv, cumaj_bb_deriv
       real(8), allocatable, dimension(:,:) :: cumij_aa_deriv, cumij_ab_deriv
       real(8), allocatable, dimension(:,:) :: cumab_aa_deriv, cumab_ab_deriv
       real(8), allocatable, dimension(:,:,:) :: pi_ija_aaa_deriv, pi_ija_aba_deriv,pi_ijb_abb_deriv
       real(8), allocatable, dimension(:,:,:) :: pi_iab_aaa_deriv, pi_iab_aab_deriv, pi_jab_bab_deriv
       real(8), allocatable, dimension(:,:) :: singles_cumaj_aa_deriv,singles_cumaj_ab_deriv
       real(8), allocatable, dimension(:) :: singles_cumocc_deriv, singles_cumvirt_deriv

       real :: time_begin,time_end
       real :: timemebegin,timemeend
       real(8) :: topfacme
       topfacme = 1

       Call CPU_TIME(time_begin)
       allocate(cumocc(1:numocc))
       allocate(cumvirt(numocc+1:numocc+numvirt))
       allocate(cumaj_aa(1:numocc,numocc+1:numvirt+numocc))
       allocate(cumaj_ab(1:numocc,numocc+1:numvirt+numocc))
       allocate(cumaj_ba(1:numocc,numocc+1:numvirt+numocc))
       allocate(cumaj_bb(1:numocc,numocc+1:numvirt+numocc))
       allocate(cumij_aa(1:numocc,1:numocc))
       allocate(cumij_ab(1:numocc,1:numocc))
       allocate(cumab_aa(numocc+1:numocc+numvirt,numocc+1:numocc+numvirt))
       allocate(cumab_ab(numocc+1:numocc+numvirt,numocc+1:numocc+numvirt))
       allocate(pi_ija_aaa(1:numocc,1:numocc,numocc+1:numocc+numvirt))
       allocate(pi_ija_aba(1:numocc,1:numocc,numocc+1:numocc+numvirt))
       allocate(pi_ijb_abb(1:numocc,1:numocc,numocc+1:numocc+numvirt))
       allocate(pi_iab_aaa(1:numocc,numocc+1:numocc+numvirt,1+numocc:numocc+numvirt))
       allocate(pi_iab_aab(1:numocc,numocc+1:numocc+numvirt,1+numocc:numocc+numvirt))
       allocate(pi_jab_bab(1:numocc,numocc+1:numocc+numvirt,1+numocc:numocc+numvirt))
       allocate(cumocc_deriv(1:numocc))
       allocate(cumvirt_deriv(numocc+1:numocc+numvirt))
       allocate(cumaj_aa_deriv(1:numocc,numocc+1:numvirt+numocc))
       allocate(cumaj_ab_deriv(1:numocc,numocc+1:numvirt+numocc))
       allocate(cumaj_ba_deriv(1:numocc,numocc+1:numocc+numvirt))
       allocate(cumaj_bb_deriv(1:numocc,numocc+1:numocc+numvirt))
       allocate(cumij_aa_deriv(1:numocc,1:numocc))
       allocate(cumij_ab_deriv(1:numocc,1:numocc))
       allocate(cumab_aa_deriv(numocc+1:numocc+numvirt,numocc+1:numocc+numvirt))
       allocate(cumab_ab_deriv(numocc+1:numocc+numvirt,numocc+1:numocc+numvirt))
       allocate(pi_ija_aaa_deriv(1:numocc,1:numocc,numocc+1:numocc+numvirt))
       allocate(pi_ija_aba_deriv(1:numocc,1:numocc,numocc+1:numocc+numvirt))
       allocate(pi_ijb_abb_deriv(1:numocc,1:numocc,numocc+1:numocc+numvirt))
       allocate(pi_iab_aaa_deriv(1:numocc,numocc+1:numocc+numvirt,1+numocc:numocc+numvirt))
       allocate(pi_iab_aab_deriv(1:numocc,numocc+1:numocc+numvirt,1+numocc:numocc+numvirt))
       allocate(pi_jab_bab_deriv(1:numocc,numocc+1:numocc+numvirt,1+numocc:numocc+numvirt))
       allocate(singles_cumaj_aa_deriv(1:numocc,numocc+1:numocc+numvirt))
       allocate(singles_cumaj_ab_deriv(1:numocc,numocc+1:numocc+numvirt))
       allocate(singles_cumocc_deriv(1:numocc))
       allocate(singles_cumvirt_deriv(numocc+1:numocc+numvirt))

       cumocc(1:numocc) = 0.0
       cumvirt(numocc+1:numocc+numvirt) = 0.0
       cumaj_aa(1:numocc,numocc+1:numocc+numvirt) = 0.0
       cumaj_ab(1:numocc,numocc+1:numocc+numvirt) = 0.0
       cumaj_ba(1:numocc,numocc+1:numocc+numvirt) = 0.0
       cumaj_bb(1:numocc,numocc+1:numocc+numvirt) = 0.0
       cumij_aa(1:numocc,1:numocc) = 0.0
       cumij_ab(1:numocc,1:numocc) = 0.0
       cumab_aa(numocc+1:numocc+numvirt,numocc+1:numocc+numvirt)=0.0
       cumab_ab(numocc+1:numocc+numvirt,numocc+1:numocc+numvirt)=0.0
       pi_ija_aaa(1:numocc,1:numocc,numocc+1:numocc+numvirt)=0.0
       pi_ija_aba(1:numocc,1:numocc,numocc+1:numocc+numvirt)=0.0
       pi_ijb_abb(1:numocc,1:numocc,numocc+1:numocc+numvirt) = 0.0
       pi_iab_aaa(1:numocc,numocc+1:numocc+numvirt,1+numocc:numocc+numvirt)=0.0
       pi_iab_aab(1:numocc,numocc+1:numocc+numvirt,1+numocc:numocc+numvirt)=0.0
       pi_jab_bab(1:numocc,numocc+1:numocc+numvirt,1+numocc:numocc+numvirt)= 0.0
       cumocc_deriv(1:numocc) = 0.0
       cumvirt_deriv(numocc+1:numocc+numvirt) = 0.0
       cumaj_aa_deriv(1:numocc,numocc+1:numocc+numvirt) = 0.0
       cumaj_ab_deriv(1:numocc,numocc+1:numocc+numvirt) = 0.0
       cumaj_ba_deriv(1:numocc,numocc+1:numocc+numvirt) = 0.0
       cumaj_bb_deriv(1:numocc,numocc+1:numocc+numvirt) = 0.0
       cumij_aa_deriv(1:numocc,1:numocc) = 0.0
       cumij_ab_deriv(1:numocc,1:numocc) = 0.0
       cumab_aa_deriv(numocc+1:numocc+numvirt,numocc+1:numocc+numvirt)=0.0
       cumab_ab_deriv(numocc+1:numocc+numvirt,numocc+1:numocc+numvirt)=0.0
       pi_ija_aaa_deriv(1:numocc,1:numocc,numocc+1:numocc+numvirt)=0.0
       pi_ija_aba_deriv(1:numocc,1:numocc,numocc+1:numocc+numvirt)=0.0
       pi_ijb_abb_deriv(1:numocc,1:numocc,numocc+1:numocc+numvirt) = 0.0
       pi_iab_aaa_deriv(1:numocc,numocc+1:numocc+numvirt,1+numocc:numocc+numvirt)=0.0
       pi_iab_aab_deriv(1:numocc,numocc+1:numocc+numvirt,1+numocc:numocc+numvirt)=0.0
       pi_jab_bab_deriv(1:numocc,numocc+1:numocc+numvirt,1+numocc:numocc+numvirt)=0.0
       singles_cumi(1:numocc) = 0.0
       singles_cuma(numocc+1:numocc+numvirt) = 0.0
       singles_cumaj_aa_deriv(1:numocc,numocc+1:numocc+numvirt) = 0.0
       singles_cumaj_ab_deriv(1:numocc,numocc+1:numocc+numvirt) = 0.0
       singles_cumocc_deriv(1:numocc) = 0.0
       singles_cumvirt_deriv(numocc+1:numvirt+numocc) = 0.0



      pizero = 0.0
      pizero_deriv = 0.0
      if(topfac(0,0).ne.0) then
       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           k_begin = occ(1,p)
           k_end   = occ(2,p)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           do k=k_begin,k_end
             do c=c_begin,c_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 l_begin = occ(1,r)
                 l_end   = occ(2,r)
                 d_begin = virt(1,s)
                 d_end   = virt(2,s)
                 do l=l_begin,l_end
                   do d=d_begin,d_end
                     pizero = pizero +T2data%ab%m(c,k)%nsym(s,r)%n(d,l)**2
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           k_begin = occ(1,p)
           k_end   = occ(2,p)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           do k=k_begin,k_end
             do c=c_begin,c_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 l_begin = occ(1,r)
                 l_end   = occ(2,r)
                 d_begin = virt(1,s)
                 d_end   = virt(2,s)
                 do l=max(k+1,l_begin),l_end
                   do d=max(c+1,d_begin),d_end
                     pizero = pizero + 2*T2data%aa%m(c,k)%nsym(s,r)%n(d,l)**2
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
    end if
if(topfac(1,0).ne.0) then
      do symgp=1,numSG
        i_begin = occ(1,symgp)
        i_end   = occ(2,symgp)
        do i=i_begin,i_end
          do p=1,numSG
            c_begin = virt(1,p)
            c_end   = virt(2,p)
            cisym = ProductTable(symgp,p)
            do c=c_begin,c_end
              do t=1,numSG
                q = InvPdt(cisym)%upper(t)
                r = InvPdt(cisym)%lower(t)
                if(p>r) cycle
                k_begin = occ(1,q)
                k_end   = occ(2,q)
                d_begin = virt(1,r)
                d_end   = virt(2,r)
                do k=k_begin,k_end
                  do d=max(c+1,d_begin),d_end
                    cumocc(i) = cumocc(i) + T2data%aa%m(c,i)%nsym(r,q)%n(d,k)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
      do symgp=1,numSG
        i_begin = occ(1,symgp)
        i_end   = occ(2,symgp)
        do i=i_begin,i_end
          do p=1,numSG
            c_begin = virt(1,p)
            c_end   = virt(2,p)
            cisym = ProductTable(symgp,p)
            do c=c_begin,c_end
              do t=1,numSG
                q = InvPdt(cisym)%upper(t)
                r = InvPdt(cisym)%lower(t)
                k_begin = occ(1,q)
                k_end   = occ(2,q)
                d_begin = virt(1,r)
                d_end   = virt(2,r)
                do k=k_begin,k_end
                  do d=d_begin,d_end
                    cumocc(i) = cumocc(i) + T2data%ab%m(c,i)%nsym(r,q)%n(d,k)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(0,1).ne.0) then
      do symgp=1,numSG
        a_begin = virt(1,symgp)
        a_end   = virt(2,symgp)
        do a=a_begin,a_end
          do p=1,numSG
            k_begin = occ(1,p)
            k_end   = occ(2,p)
            aksym = ProductTable(symgp,p)
            do k=k_begin,k_end
              do t=1,numSG
                q = InvPdt(aksym)%upper(t)
                r = InvPdt(aksym)%lower(t)
                if(p>q) cycle
                l_begin = occ(1,q)
                l_end   = occ(2,q)
                c_begin = virt(1,r)
                c_end   = virt(2,r)
                do l=max(k+1,l_begin),l_end
                  do c=c_begin,c_end
                    cumvirt(a) = cumvirt(a) + T2data%aa%m(a,k)%nsym(r,q)%n(c,l)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

      do symgp=1,numSG
        a_begin = virt(1,symgp)
        a_end   = virt(2,symgp)
        do a=a_begin,a_end
          do p=1,numSG
            k_begin = occ(1,p)
            k_end   = occ(2,p)
            aksym = ProductTable(symgp,p)
            do k=k_begin,k_end
              do t=1,numSG
                q = InvPdt(aksym)%upper(t)
                r = InvPdt(aksym)%lower(t)
                l_begin = occ(1,q)
                l_end   = occ(2,q)
                c_begin = virt(1,r)
                c_end   = virt(2,r)
                do l=l_begin,l_end
                  do c=c_begin,c_end
                    cumvirt(a) = cumvirt(a) + T2data%ab%m(a,k)%nsym(r,q)%n(c,l)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(1,1).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          a_begin = virt(1,p)
          a_end   = virt(2,p)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do j=j_begin,j_end
            do a=a_begin,a_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                c_begin = virt(1,r)
                c_end   = virt(2,r)
                k_begin = occ(1,s)
                k_end   = occ(2,s)
                do k=k_begin,k_end
                  do c=c_begin,c_end
                    cumaj_aa(j,a) = cumaj_aa(j,a) + T2data%aa%m(a,j)%nsym(r,s)%n(c,k)**2
                    cumaj_bb(j,a) = cumaj_bb(j,a) + T2data%aa%m(a,j)%nsym(r,s)%n(c,k)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
      do symgp=1,numSG
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          a_begin = virt(1,p)
          a_end   = virt(2,p)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do j=j_begin,j_end
            do a=a_begin,a_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                c_begin = virt(1,r)
                c_end   = virt(2,r)
                k_begin = occ(1,s)
                k_end   = occ(2,s)
                do k=k_begin,k_end
                  do c=c_begin,c_end
                    cumaj_aa(j,a) = cumaj_aa(j,a) + T2data%ab%m(a,j)%nsym(r,s)%n(c,k)**2
                    cumaj_bb(j,a) = cumaj_bb(j,a) + T2data%ab%m(a,j)%nsym(r,s)%n(c,k)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(1,1).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          a_begin = virt(1,p)
          a_end   = virt(2,p)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do j=j_begin,j_end
            do a=a_begin,a_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                c_begin = virt(1,r)
                c_end   = virt(2,r)
                k_begin = occ(1,s)
                k_end   = occ(2,s)
                do c=c_begin,c_end
                  do k=k_begin,k_end
                    cumaj_ab(j,a) = cumaj_ab(j,a) + T2data%ab%m(c,j)%nsym(p,s)%n(a,k)**2
                    cumaj_ba(k,c) = cumaj_ba(k,c) + T2data%ab%m(c,j)%nsym(p,s)%n(a,k)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(2,0).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          if(p.gt.q) cycle
          i_begin = occ(1,p)
          i_end   = occ(2,p)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do i=i_begin,i_end
            do j=max(i+1,j_begin),j_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                if(r.gt.s) cycle
                a_begin = virt(1,r)
                a_end   = virt(2,r)
                b_begin = virt(1,s)
                b_end   = virt(2,s)
                do a=a_begin,a_end
                  do b=max(a+1,b_begin),b_end
                    cumij_aa(i,j) = cumij_aa(i,j) + T2data%aa%m(a,i)%nsym(s,q)%n(b,j)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(2,0).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          i_begin = occ(1,p)
          i_end   = occ(2,p)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                a_begin = virt(1,r)
                a_end   = virt(2,r)
                b_begin = virt(1,s)
                b_end   = virt(2,s)
                do a=a_begin,a_end
                  do b=b_begin,b_end
                    cumij_ab(i,j) = cumij_ab(i,j) + T2data%ab%m(a,i)%nsym(s,q)%n(b,j)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(0,2).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          if(p.gt.q) cycle
          a_begin = virt(1,p)
          a_end   = virt(2,p)
          b_begin = virt(1,q)
          b_end   = virt(2,q)
          do a=a_begin,a_end
            do b=max(a+1,b_begin),b_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                if(r.gt.s) cycle
                i_begin = occ(1,r)
                i_end   = occ(2,r)
                j_begin = occ(1,s)
                j_end   = occ(2,s)
                do i=i_begin,i_end
                  do j=max(i+1,j_begin),j_end
                    cumab_aa(a,b) = cumab_aa(a,b) + T2data%aa%m(a,i)%nsym(q,s)%n(b,j)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(0,2).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          a_begin = virt(1,p)
          a_end   = virt(2,p)
          b_begin = virt(1,q)
          b_end   = virt(2,q)
          do a=a_begin,a_end
            do b=b_begin,b_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                i_begin = occ(1,r)
                i_end   = occ(2,r)
                j_begin = occ(1,s)
                j_end   = occ(2,s)
                do i=i_begin,i_end
                  do j=j_begin,j_end
                    cumab_ab(a,b) = cumab_ab(a,b) + T2data%ab%m(a,i)%nsym(q,s)%n(b,j)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(2,1).ne.0) then
      do symgp=1,numSG
        c_begin = virt(1,symgp)
        c_end   = virt(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt(1,r)
            a_end   = virt(2,r)
            i_begin = occ(1,s)
            i_end   = occ(2,s)
            do i=i_begin,i_end
              do a=a_begin,a_end
                do j=max(i+1,j_begin),j_end
                  do c=c_begin,c_end
                    pi_ija_aaa(i,j,a) = pi_ija_aaa(i,j,a) + T2data%aa%m(a,i)%nsym(symgp,q)%n(c,j)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(2,1).ne.0) then
      do symgp=1,numSG
        c_begin = virt(1,symgp)
        c_end   = virt(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt(1,r)
            a_end   = virt(2,r)
            i_begin = occ(1,s)
            i_end   = occ(2,s)
            do i=i_begin,i_end
              do a=a_begin,a_end
                do j=j_begin,j_end
                  do c=c_begin,c_end
                    pi_ija_aba(i,j,a) = pi_ija_aba(i,j,a) + T2data%ab%m(a,i)%nsym(symgp,q)%n(c,j)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(2,1).ne.0) then
      do symgp=1,numSG
        c_begin = virt(1,symgp)
        c_end   = virt(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            b_begin = virt(1,r)
            b_end   = virt(2,r)
            i_begin = occ(1,s)
            i_end   = occ(2,s)
            do i=i_begin,i_end
              do b=b_begin,b_end
                do j=j_begin,j_end
                  do c=c_begin,c_end
                    pi_ijb_abb(i,j,b) = pi_ijb_abb(i,j,b) + T2data%ab%m(c,i)%nsym(r,q)%n(b,j)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if

if(topfac(1,2).ne.0) then
      do symgp=1,numSG
        k_begin = occ(1,symgp)
        k_end   = occ(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          b_begin = virt(1,q)
          b_end   = virt(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt(1,r)
            a_end   = virt(2,r)
            i_begin = occ(1,s)
            i_end   = occ(2,s)
            do i=i_begin,i_end
              do a=a_begin,a_end
                do b=max(a+1,b_begin),b_end
                  do k=k_begin,k_end
                    pi_iab_aaa(i,a,b) = pi_iab_aaa(i,a,b) + T2data%aa%m(a,i)%nsym(q,symgp)%n(b,k)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(1,2).ne.0) then
      do symgp=1,numSG
        k_begin = occ(1,symgp)
        k_end   = occ(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          b_begin = virt(1,q)
          b_end   = virt(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt(1,r)
            a_end   = virt(2,r)
            i_begin = occ(1,s)
            i_end   = occ(2,s)
            do i=i_begin,i_end
              do a=a_begin,a_end
                do b=b_begin,b_end
                  do k=k_begin,k_end
                    pi_iab_aab(i,a,b) = pi_iab_aab(i,a,b) + T2data%ab%m(a,i)%nsym(q,symgp)%n(b,k)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(1,2).ne.0) then
      do symgp=1,numSG
        k_begin = occ(1,symgp)
        k_end   = occ(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          b_begin = virt(1,q)
          b_end   = virt(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt(1,r)
            a_end   = virt(2,r)
            j_begin = occ(1,s)
            j_end   = occ(2,s)
            do j=j_begin,j_end
              do a=a_begin,a_end
                do b=b_begin,b_end
                  do k=k_begin,k_end
                    pi_jab_bab(j,a,b) = pi_jab_bab(j,a,b) + T2data%ab%m(a,k)%nsym(q,s)%n(b,j)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if

singles_pizero = 0.0
if(topsingles(0,0).ne.0) then
       do symgp=1,numSG
         k_begin = occ(1,symgp)
         k_end   = occ(2,symgp)
         c_begin = virt(1,symgp)
         c_end   = virt(2,symgp)
         do k=k_begin,k_end
           do c=c_begin,c_end
             singles_pizero= singles_pizero + 2*T1data%a%o(k)%vsym(symgp)%v(c)**2
           end do
         end do
       end do
end if
if(topsingles(1,0).ne.0) then
       do symgp=1,numSG
         k_begin = occ(1,symgp)
         k_end   = occ(2,symgp)
         c_begin = virt(1,symgp)
         c_end   = virt(2,symgp)
         do k=k_begin,k_end
           do c=c_begin,c_end
             singles_cumi(k) = singles_cumi(k) + T1data%a%o(k)%vsym(symgp)%v(c)**2
           end do
         end do
      end do
end if

if(topsingles(0,1).ne.0) then
      do symgp=1,numSG
        c_begin = virt(1,symgp)
        c_end   = virt(2,symgp)
        k_begin = occ(1,symgp)
        k_end   = occ(2,symgp)
        do c=c_begin,c_end
          do k=k_begin,k_end
            singles_cuma(c) = singles_cuma(c) + T1data%a%o(k)%vsym(symgp)%v(c)**2
          end do
        end do
      end do
end if


       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           a_begin = virt(1,q)
           a_end   = virt(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 j_begin = occ(1,r)
                 j_end   = occ(2,r)
                 b_begin = virt(1,s)
                 b_end   = virt(2,s)
                 do j=j_begin,j_end
                   do b=b_begin,b_end
                     Newc%ab%m(a,i)%nsym(s,r)%n(b,j) = topfac(0,0)*pizero +topfac(1,0)*(cumocc(i)+cumocc(j)) + topfac(0,1)*(cumvirt(a) + cumvirt(b)) + topfac(1,1)*(cumaj_bb(j,b)+cumaj_ab(i,b) + cumaj_ba(j,a)+cumaj_aa(i,a)) +topfac(2,0)*cumij_ab(i,j) + topfac(0,2)*cumab_ab(a,b) + topfac(2,1)*(pi_ija_aba(i,j,a) + pi_ijb_abb(i,j,b))  + topfac(1,2)*(pi_iab_aab(i,a,b) + pi_jab_bab(j,a,b)) + topfac(2,2)*T2data%ab%m(a,i)%nsym(s,r)%n(b,j)**2 + topsingles(0,0)*singles_pizero  + topsingles(1,0)*(singles_cumi(i) + singles_cumi(j)) + topsingles(0,1)*(singles_cuma(a) + singles_cuma(b))
                     if(r.eq.s) then
                       Newc%ab%m(a,i)%nsym(s,r)%n(b,j) =  Newc%ab%m(a,i)%nsym(s,r)%n(b,j) + topsingles(1,1)*T1data%a%o(j)%vsym(s)%v(b)**2
                     end if
                     if(p.eq.q) then
                       Newc%ab%m(a,i)%nsym(s,r)%n(b,j) =  Newc%ab%m(a,i)%nsym(s,r)%n(b,j) + topsingles(1,1)*T1data%a%o(i)%vsym(q)%v(a)**2
                     end if
                        Newc%ab%m(a,i)%nsym(s,r)%n(b,j) = sqrt(abs(1.0-Newc%ab%m(a,i)%nsym(s,r)%n(b,j)))
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           a_begin = virt(1,q)
           a_end   = virt(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 j_begin = occ(1,r)
                 j_end   = occ(2,r)
                 b_begin = virt(1,s)
                 b_end   = virt(2,s)
                 do j=max(i+1,j_begin),j_end
                   do b=max(a+1,b_begin),b_end
                     Newc%aa%m(a,i)%nsym(s,r)%n(b,j) = topfac(0,0)*pizero +topfac(1,0)*(cumocc(i)+cumocc(j)) + topfac(0,1)*(cumvirt(a) + cumvirt(b)) + topfac(1,1)*(cumaj_aa(j,b) + cumaj_aa(j,a) + cumaj_aa(i,b) + cumaj_aa(i,a)) + topfac(2,0)*cumij_aa(i,j) + topfac(0,2)*cumab_aa(a,b) + topfac(2,1)*(pi_ija_aaa(i,j,a) + pi_ija_aaa(i,j,b))  + topfac(1,2)*(pi_iab_aaa(i,a,b) + pi_iab_aaa(j,a,b)) + topfac(2,2)*T2data%aa%m(a,i)%nsym(s,r)%n(b,j)**2 +topsingles(0,0)*singles_pizero + topsingles(1,0)*(singles_cumi(i) + singles_cumi(j)) + topsingles(0,1)*(singles_cuma(a) + singles_cuma(b))
                     if(q.eq.p) then
                       Newc%aa%m(a,i)%nsym(s,r)%n(b,j) = Newc%aa%m(a,i)%nsym(s,r)%n(b,j) + topsingles(1,1)*T1data%a%o(i)%vsym(q)%v(a)**2
                     end if
                     if(q.eq.r) then
                       Newc%aa%m(a,i)%nsym(s,r)%n(b,j) = Newc%aa%m(a,i)%nsym(s,r)%n(b,j) + topsingles(1,1)*T1data%a%o(j)%vsym(q)%v(a)**2
                     end if
                     if(s.eq.p) then
                       Newc%aa%m(a,i)%nsym(s,r)%n(b,j) = Newc%aa%m(a,i)%nsym(s,r)%n(b,j) + topsingles(1,1)*T1data%a%o(i)%vsym(s)%v(b)**2
                     end if
                    if(s.eq.r) then
                       Newc%aa%m(a,i)%nsym(s,r)%n(b,j) = Newc%aa%m(a,i)%nsym(s,r)%n(b,j) + topsingles(1,1)*T1data%a%o(j)%vsym(s)%v(b)**2
                    end if
                     Newc%aa%m(a,i)%nsym(s,r)%n(b,j) = sqrt(abs((1.0-Newc%aa%m(a,i)%nsym(s,r)%n(b,j))))
                     Newc%aa%m(b,j)%nsym(q,p)%n(a,i) = Newc%aa%m(a,i)%nsym(s,r)%n(b,j)
                     Newc%aa%m(a,j)%nsym(s,p)%n(b,i) = Newc%aa%m(a,i)%nsym(s,r)%n(b,j)
                     Newc%aa%m(b,i)%nsym(q,r)%n(a,j) = Newc%aa%m(a,i)%nsym(s,r)%n(b,j)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
pizero_deriv = 0.0
      if(topfac(0,0).ne.0) then
       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           k_begin = occ(1,p)
           k_end   = occ(2,p)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           do k=k_begin,k_end
             do c=c_begin,c_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 l_begin = occ(1,r)
                 l_end   = occ(2,r)
                 d_begin = virt(1,s)
                 d_end   = virt(2,s)
                 do l=l_begin,l_end
                   do d=d_begin,d_end
                     pizero_deriv = pizero_deriv +T2data%ab%m(c,k)%nsym(s,r)%n(d,l)*(TwoInts(k,l,c,d))/Newc%ab%m(c,k)%nsym(s,r)%n(d,l)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           k_begin = occ(1,p)
           k_end   = occ(2,p)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           do k=k_begin,k_end
             do c=c_begin,c_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 l_begin = occ(1,r)
                 l_end   = occ(2,r)
                 d_begin = virt(1,s)
                 d_end   = virt(2,s)
                 do l=max(k+1,l_begin),l_end
                   do d=max(c+1,d_begin),d_end
                     pizero_deriv = pizero_deriv + 2*T2data%aa%m(c,k)%nsym(s,r)%n(d,l)*(TwoInts(k,l,c,d)-TwoInts(k,l,d,c))/Newc%aa%m(c,k)%nsym(s,r)%n(d,l)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
    end if
if(topfac(1,0).ne.0) then
      do symgp=1,numSG
        i_begin = occ(1,symgp)
        i_end   = occ(2,symgp)
        do i=i_begin,i_end
          do p=1,numSG
            c_begin = virt(1,p)
            c_end   = virt(2,p)
            cisym = ProductTable(symgp,p)
            do c=c_begin,c_end
              do t=1,numSG
                q = InvPdt(cisym)%upper(t)
                r = InvPdt(cisym)%lower(t)
                if(p>r) cycle
                k_begin = occ(1,q)
                k_end   = occ(2,q)
                d_begin = virt(1,r)
                d_end   = virt(2,r)
                do k=k_begin,k_end
                  do d=max(c+1,d_begin),d_end
                    if(k.eq.i) cycle
                    cumocc_deriv(i) = cumocc_deriv(i) + T2data%aa%m(c,i)%nsym(r,q)%n(d,k)*(TwoInts(i,k,c,d)-TwoInts(i,k,d,c))/Newc%aa%m(c,i)%nsym(r,q)%n(d,k)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
      do symgp=1,numSG
        i_begin = occ(1,symgp)
        i_end   = occ(2,symgp)
        do i=i_begin,i_end
          do p=1,numSG
            c_begin = virt(1,p)
            c_end   = virt(2,p)
            cisym = ProductTable(symgp,p)
            do c=c_begin,c_end
              do t=1,numSG
                q = InvPdt(cisym)%upper(t)
                r = InvPdt(cisym)%lower(t)
                k_begin = occ(1,q)
                k_end   = occ(2,q)
                d_begin = virt(1,r)
                d_end   = virt(2,r)
                do k=k_begin,k_end
                  do d=d_begin,d_end
                    cumocc_deriv(i) = cumocc_deriv(i) + T2data%ab%m(c,i)%nsym(r,q)%n(d,k)*TwoInts(i,k,c,d)/Newc%ab%m(c,i)%nsym(r,q)%n(d,k)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(0,1).ne.0) then
      do symgp=1,numSG
        a_begin = virt(1,symgp)
        a_end   = virt(2,symgp)
        do a=a_begin,a_end
          do p=1,numSG
            k_begin = occ(1,p)
            k_end   = occ(2,p)
            aksym = ProductTable(symgp,p)
            do k=k_begin,k_end
              do t=1,numSG
                q = InvPdt(aksym)%upper(t)
                r = InvPdt(aksym)%lower(t)
                if(p>q) cycle
                l_begin = occ(1,q)
                l_end   = occ(2,q)
                c_begin = virt(1,r)
                c_end   = virt(2,r)
                do l=max(k+1,l_begin),l_end
                  do c=c_begin,c_end
                    if(c.eq.a) cycle
                    cumvirt_deriv(a) = cumvirt_deriv(a) + T2data%aa%m(a,k)%nsym(r,q)%n(c,l)*(TwoInts(k,l,a,c)-TwoInts(k,l,c,a))/Newc%aa%m(a,k)%nsym(r,q)%n(c,l)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
      do symgp=1,numSG
        a_begin = virt(1,symgp)
        a_end   = virt(2,symgp)
        do a=a_begin,a_end
          do p=1,numSG
            k_begin = occ(1,p)
            k_end   = occ(2,p)
            aksym = ProductTable(symgp,p)
            do k=k_begin,k_end
              do t=1,numSG
                q = InvPdt(aksym)%upper(t)
                r = InvPdt(aksym)%lower(t)
                l_begin = occ(1,q)
                l_end   = occ(2,q)
                c_begin = virt(1,r)
                c_end   = virt(2,r)
                do l=l_begin,l_end
                  do c=c_begin,c_end
                    cumvirt_deriv(a) = cumvirt_deriv(a) + T2data%ab%m(a,k)%nsym(r,q)%n(c,l)*TwoInts(k,l,a,c)/Newc%ab%m(a,k)%nsym(r,q)%n(c,l)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(1,1).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          a_begin = virt(1,p)
          a_end   = virt(2,p)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do j=j_begin,j_end
            do a=a_begin,a_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                c_begin = virt(1,r)
                c_end   = virt(2,r)
                k_begin = occ(1,s)
                k_end   = occ(2,s)
                do k=max(j+1,k_begin),k_end
                  do c=max(a+1,c_begin),c_end
                    cumaj_aa_deriv(j,a) = cumaj_aa_deriv(j,a) + T2data%aa%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j,k,a,c)-TwoInts(j,k,c,a))/Newc%aa%m(a,j)%nsym(r,s)%n(c,k)
                    cumaj_aa_deriv(j,c) = cumaj_aa_deriv(j,c) + T2data%aa%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j,k,a,c)-TwoInts(j,k,c,a))/Newc%aa%m(a,j)%nsym(r,s)%n(c,k)
                    cumaj_aa_deriv(k,a) = cumaj_aa_deriv(k,a) + T2data%aa%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j,k,a,c)-TwoInts(j,k,c,a))/Newc%aa%m(a,j)%nsym(r,s)%n(c,k)
                    cumaj_aa_deriv(k,c) = cumaj_aa_deriv(k,c) + T2data%aa%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j,k,a,c)-TwoInts(j,k,c,a))/Newc%aa%m(a,j)%nsym(r,s)%n(c,k)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(1,1).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          a_begin = virt(1,p)
          a_end   = virt(2,p)
          i_begin = occ(1,q)
          i_end   = occ(2,q)
          do i=i_begin,i_end
            do a=a_begin,a_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                b_begin = virt(1,r)
                b_end   = virt(2,r)
                j_begin = occ(1,s)
                j_end   = occ(2,s)
                do b=b_begin,b_end
                  do j=j_begin,j_end
                    cumaj_ba_deriv(j,a) = cumaj_ba_deriv(j,a) + TwoInts(i,j,a,b)*T2data%ab%m(a,i)%nsym(r,s)%n(b,j)/Newc%ab%m(a,i)%nsym(r,s)%n(b,j)
                    cumaj_ab_deriv(i,b) = cumaj_ab_deriv(i,b) + TwoInts(i,j,a,b)*T2data%ab%m(a,i)%nsym(r,s)%n(b,j)/Newc%ab%m(a,i)%nsym(r,s)%n(b,j)
                    cumaj_aa_deriv(i,a) = cumaj_aa_deriv(i,a) + TwoInts(i,j,a,b)*T2data%ab%m(a,i)%nsym(r,s)%n(b,j)/Newc%ab%m(a,i)%nsym(r,s)%n(b,j)

                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(2,0).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          if(p.gt.q) cycle
          i_begin = occ(1,p)
          i_end   = occ(2,p)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do i=i_begin,i_end
            do j=max(i+1,j_begin),j_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                if(r.gt.s) cycle
                a_begin = virt(1,r)
                a_end   = virt(2,r)
                b_begin = virt(1,s)
                b_end   = virt(2,s)
                do a=a_begin,a_end
                  do b=max(a+1,b_begin),b_end
                    cumij_aa_deriv(i,j) = cumij_aa_deriv(i,j) + T2data%aa%m(a,i)%nsym(s,q)%n(b,j)*(TwoInts(i,j,a,b)-TwoInts(i,j,b,a))/Newc%aa%m(a,i)%nsym(s,q)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(2,0).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          i_begin = occ(1,p)
          i_end   = occ(2,p)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                a_begin = virt(1,r)
                a_end   = virt(2,r)
                b_begin = virt(1,s)
                b_end   = virt(2,s)
                do a=a_begin,a_end
                  do b=b_begin,b_end
                    cumij_ab_deriv(i,j) = cumij_ab_deriv(i,j) + T2data%ab%m(a,i)%nsym(s,q)%n(b,j)*TwoInts(i,j,a,b)/Newc%ab%m(a,i)%nsym(s,q)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(0,2).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          if(p.gt.q) cycle
          a_begin = virt(1,p)
          a_end   = virt(2,p)
          b_begin = virt(1,q)
          b_end   = virt(2,q)
          do a=a_begin,a_end
            do b=max(a+1,b_begin),b_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                if(r.gt.s) cycle
                i_begin = occ(1,r)
                i_end   = occ(2,r)
                j_begin = occ(1,s)
                j_end   = occ(2,s)
                do i=i_begin,i_end
                  do j=max(i+1,j_begin),j_end
                    cumab_aa_deriv(a,b) = cumab_aa_deriv(a,b) + T2data%aa%m(a,i)%nsym(q,s)%n(b,j)*(TwoInts(i,j,a,b)-TwoInts(i,j,b,a))/Newc%aa%m(a,i)%nsym(q,s)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(0,2).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          a_begin = virt(1,p)
          a_end   = virt(2,p)
          b_begin = virt(1,q)
          b_end   = virt(2,q)
          do a=a_begin,a_end
            do b=b_begin,b_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                i_begin = occ(1,r)
                i_end   = occ(2,r)
                j_begin = occ(1,s)
                j_end   = occ(2,s)
                do i=i_begin,i_end
                  do j=j_begin,j_end
                    cumab_ab_deriv(a,b) = cumab_ab_deriv(a,b) + T2data%ab%m(a,i)%nsym(q,s)%n(b,j)*TwoInts(i,j,a,b)/Newc%ab%m(a,i)%nsym(q,s)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(2,1).ne.0) then
      do symgp=1,numSG
        c_begin = virt(1,symgp)
        c_end   = virt(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt(1,r)
            a_end   = virt(2,r)
            i_begin = occ(1,s)
            i_end   = occ(2,s)
            do i=i_begin,i_end
              do a=a_begin,a_end
                do j=max(i+1,j_begin),j_end
                  do c=c_begin,c_end
                    if(c.eq.a) cycle
                    pi_ija_aaa_deriv(i,j,a) = pi_ija_aaa_deriv(i,j,a) + T2data%aa%m(a,i)%nsym(symgp,q)%n(c,j)*(TwoInts(i,j,a,c)-TwoInts(i,j,c,a))/Newc%aa%m(a,i)%nsym(symgp,q)%n(c,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(2,1).ne.0) then
      do symgp=1,numSG
        c_begin = virt(1,symgp)
        c_end   = virt(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt(1,r)
            a_end   = virt(2,r)
            i_begin = occ(1,s)
            i_end   = occ(2,s)
            do i=i_begin,i_end
              do a=a_begin,a_end
                do j=j_begin,j_end
                  do c=c_begin,c_end
                    pi_ija_aba_deriv(i,j,a) = pi_ija_aba_deriv(i,j,a)  + T2data%ab%m(a,i)%nsym(symgp,q)%n(c,j)*TwoInts(i,j,a,c)/Newc%ab%m(a,i)%nsym(symgp,q)%n(c,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(2,1).ne.0) then
      do symgp=1,numSG
        c_begin = virt(1,symgp)
        c_end   = virt(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            b_begin = virt(1,r)
            b_end   = virt(2,r)
            i_begin = occ(1,s)
            i_end   = occ(2,s)
            do i=i_begin,i_end
              do b=b_begin,b_end
                do j=j_begin,j_end
                  do c=c_begin,c_end
                    pi_ijb_abb_deriv(i,j,b) = pi_ijb_abb_deriv(i,j,b)  + T2data%ab%m(c,i)%nsym(r,q)%n(b,j)*TwoInts(i,j,c,b)/Newc%ab%m(c,i)%nsym(r,q)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if

if(topfac(1,2).ne.0) then
      do symgp=1,numSG
        k_begin = occ(1,symgp)
        k_end   = occ(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          b_begin = virt(1,q)
          b_end   = virt(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt(1,r)
            a_end   = virt(2,r)
            i_begin = occ(1,s)
            i_end   = occ(2,s)
            do i=i_begin,i_end
              do a=a_begin,a_end
                do b=max(a+1,b_begin),b_end
                  do k=k_begin,k_end
                    if(i.eq.k) cycle
                    pi_iab_aaa_deriv(i,a,b) = pi_iab_aaa_deriv(i,a,b) + T2data%aa%m(a,i)%nsym(q,symgp)%n(b,k)*(TwoInts(i,k,a,b)-TwoInts(i,k,b,a))/Newc%aa%m(a,i)%nsym(q,symgp)%n(b,k)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(1,2).ne.0) then
      do symgp=1,numSG
        k_begin = occ(1,symgp)
        k_end   = occ(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          b_begin = virt(1,q)
          b_end   = virt(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt(1,r)
            a_end   = virt(2,r)
            i_begin = occ(1,s)
            i_end   = occ(2,s)
            do i=i_begin,i_end
              do a=a_begin,a_end
                do b=b_begin,b_end
                  do k=k_begin,k_end
                    pi_iab_aab_deriv(i,a,b) = pi_iab_aab_deriv(i,a,b) + T2data%ab%m(a,i)%nsym(q,symgp)%n(b,k)*TwoInts(i,k,a,b)/Newc%ab%m(a,i)%nsym(q,symgp)%n(b,k)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(1,2).ne.0) then
      do symgp=1,numSG
        k_begin = occ(1,symgp)
        k_end   = occ(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          b_begin = virt(1,q)
          b_end   = virt(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt(1,r)
            a_end   = virt(2,r)
            j_begin = occ(1,s)
            j_end   = occ(2,s)
            do j=j_begin,j_end
              do a=a_begin,a_end
                do b=b_begin,b_end
                  do k=k_begin,k_end
                    pi_jab_bab_deriv(j,a,b) = pi_jab_bab_deriv(j,a,b) + T2data%ab%m(a,k)%nsym(q,s)%n(b,j)*TwoInts(k,j,a,b)/Newc%ab%m(a,k)%nsym(q,s)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if














       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           a_begin = virt(1,q)
           a_end   = virt(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 j_begin = occ(1,r)
                 j_end   = occ(2,r)
                 b_begin = virt(1,s)
                 b_end   = virt(2,s)
                 do j=j_begin,j_end
                   do b=b_begin,b_end
                     DerivNewc%ab%m(a,i)%nsym(s,r)%n(b,j) = -2*(topfac(0,0)*pizero_deriv +&
                        &topfac(1,0)*(cumocc_deriv(i)+cumocc_deriv(j)) + topfac(0,1)*(cumvirt_deriv(a) + cumvirt_deriv(b)) +&
                        topfac(1,1)*(cumaj_aa_deriv(j,b) + cumaj_ba_deriv(j,a) + cumaj_ab_deriv(i,b) + cumaj_aa_deriv(i,a)) &
                        &+ topfac(2,0)*cumij_ab_deriv(i,j) + topfac(0,2)*cumab_ab_deriv(a,b) +&
                        & topfac(2,1)*(pi_ija_aba_deriv(i,j,a) + pi_ijb_abb_deriv(i,j,b))  &
                        &+ topfac(1,2)*(pi_iab_aab_deriv(i,a,b) + pi_jab_bab_deriv(j,a,b)) + topfac(2,2)*T2data%ab%m(a,i)%nsym(s,r)%n(b,j)*TwoInts(i,j,a,b)/Newc%ab%m(a,i)%nsym(s,r)%n(b,j))
                     DerivNewc%ab%m(a,i)%nsym(s,r)%n(b,j) = 0.5*DerivNewc%ab%m(a,i)%nsym(s,r)%n(b,j)*T2data%ab%m(a,i)%nsym(s,r)%n(b,j)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           a_begin = virt(1,q)
           a_end   = virt(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 j_begin = occ(1,r)
                 j_end   = occ(2,r)
                 b_begin = virt(1,s)
                 b_end   = virt(2,s)
                 do j=j_begin,j_end
                   do b=b_begin,b_end
                     DerivNewc%aa%m(a,i)%nsym(s,r)%n(b,j) = -2*(topfac(0,0)*pizero_deriv +&
                        &topfac(1,0)*(cumocc_deriv(i)+cumocc_deriv(j)) + topfac(0,1)*(cumvirt_deriv(a) + cumvirt_deriv(b)) +&
                        topfac(1,1)*(cumaj_aa_deriv(j,b) + cumaj_aa_deriv(j,a) + cumaj_aa_deriv(i,b) + cumaj_aa_deriv(i,a)) &
                        &+ topfac(2,0)*cumij_aa_deriv(i,j) + topfac(0,2)*cumab_aa_deriv(a,b) +&
                        & topfac(2,1)*(pi_ija_aaa_deriv(i,j,a) + pi_ija_aaa_deriv(i,j,b))  &
                        &+ topfac(1,2)*(pi_iab_aaa_deriv(i,a,b) + pi_iab_aaa_deriv(j,a,b)) + topfac(2,2)*T2data%aa%m(a,i)%nsym(s,r)%n(b,j)*(TwoInts(i,j,a,b)-TwoInts(i,j,b,a))/Newc%aa%m(a,i)%nsym(s,r)%n(b,j))
                     DerivNewc%aa%m(a,i)%nsym(s,r)%n(b,j) = 0.5*DerivNewc%aa%m(a,i)%nsym(s,r)%n(b,j)*T2data%aa%m(a,i)%nsym(s,r)%n(b,j)

                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

if(topsingles(1,1).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          a_begin = virt(1,p)
          a_end   = virt(2,p)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do j=j_begin,j_end
            do a=a_begin,a_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                c_begin = virt(1,r)
                c_end   = virt(2,r)
                k_begin = occ(1,s)
                k_end   = occ(2,s)
                do k=max(j+1,k_begin),k_end
                  do c=max(a+1,c_begin),c_end
                     singles_cumaj_aa_deriv(j,a) = singles_cumaj_aa_deriv(j,a) + T2data%aa%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j,k,a,c)-TwoInts(j,k,c,a))/Newc%aa%m(a,j)%nsym(r,s)%n(c,k)
                     singles_cumaj_aa_deriv(j,c) = singles_cumaj_aa_deriv(j,c) + T2data%aa%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j,k,a,c)-TwoInts(j,k,c,a))/Newc%aa%m(a,j)%nsym(r,s)%n(c,k)
                     singles_cumaj_aa_deriv(k,a) = singles_cumaj_aa_deriv(k,a) + T2data%aa%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j,k,a,c)-TwoInts(j,k,c,a))/Newc%aa%m(a,j)%nsym(r,s)%n(c,k)
                     singles_cumaj_aa_deriv(k,c) = singles_cumaj_aa_deriv(k,c) + T2data%aa%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j,k,a,c)-TwoInts(j,k,c,a))/Newc%aa%m(a,j)%nsym(r,s)%n(c,k)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if

if(topsingles(1,1).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          a_begin = virt(1,p)
          a_end   = virt(2,p)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do j=j_begin,j_end
            do a=a_begin,a_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                c_begin = virt(1,r)
                c_end   = virt(2,r)
                k_begin = occ(1,s)
                k_end   = occ(2,s)
                do k=k_begin,k_end
                  do c=c_begin,c_end
                     singles_cumaj_ab_deriv(j,a) = singles_cumaj_ab_deriv(j,a) + T2data%ab%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j,k,a,c))/Newc%ab%m(a,j)%nsym(r,s)%n(c,k)
                  end do
                end do
              end do
            end do
          end do
        end do
     end do
end if

if(topsingles(1,0).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          if(p.gt.q) cycle
          i_begin = occ(1,p)
          i_end   = occ(2,p)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do i=i_begin,i_end
            do j=max(i+1,j_begin),j_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                if(r.gt.s) cycle
                a_begin = virt(1,r)
                a_end   = virt(2,r)
                b_begin = virt(1,s)
                b_end   = virt(2,s)
                do a=a_begin,a_end
                  do b=max(a+1,b_begin),b_end
                    singles_cumocc_deriv(i) = singles_cumocc_deriv(i) + T2data%aa%m(a,i)%nsym(s,q)%n(b,j)*(TwoInts(i,j,a,b)-TwoInts(i,j,b,a))/Newc%aa%m(a,i)%nsym(s,q)%n(b,j)
                    singles_cumocc_deriv(j) = singles_cumocc_deriv(j) + T2data%aa%m(a,i)%nsym(s,q)%n(b,j)*(TwoInts(i,j,a,b)-TwoInts(i,j,b,a))/Newc%aa%m(a,i)%nsym(s,q)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          i_begin = occ(1,p)
          i_end   = occ(2,p)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                a_begin = virt(1,r)
                a_end   = virt(2,r)
                b_begin = virt(1,s)
                b_end   = virt(2,s)
                do a=a_begin,a_end
                  do b=b_begin,b_end
                    singles_cumocc_deriv(i) = singles_cumocc_deriv(i) + T2data%ab%m(a,i)%nsym(s,q)%n(b,j)*TwoInts(i,j,a,b)/Newc%ab%m(a,i)%nsym(s,q)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topsingles(0,1).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          if(p.gt.q) cycle
          i_begin = occ(1,p)
          i_end   = occ(2,p)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do i=i_begin,i_end
            do j=max(i+1,j_begin),j_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                if(r.gt.s) cycle
                a_begin = virt(1,r)
                a_end   = virt(2,r)
                b_begin = virt(1,s)
                b_end   = virt(2,s)
                do a=a_begin,a_end
                  do b=max(a+1,b_begin),b_end
                    singles_cumvirt_deriv(a) = singles_cumvirt_deriv(a) + T2data%aa%m(a,i)%nsym(s,q)%n(b,j)*(TwoInts(i,j,a,b)-TwoInts(i,j,b,a))/Newc%aa%m(a,i)%nsym(s,q)%n(b,j)
                    singles_cumvirt_deriv(b) = singles_cumvirt_deriv(b) + T2data%aa%m(a,i)%nsym(s,q)%n(b,j)*(TwoInts(i,j,a,b)-TwoInts(i,j,b,a))/Newc%aa%m(a,i)%nsym(s,q)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          i_begin = occ(1,p)
          i_end   = occ(2,p)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                a_begin = virt(1,r)
                a_end   = virt(2,r)
                b_begin = virt(1,s)
                b_end   = virt(2,s)
                do a=a_begin,a_end
                  do b=b_begin,b_end
                    singles_cumvirt_deriv(a) = singles_cumvirt_deriv(a) + T2data%ab%m(a,i)%nsym(s,q)%n(b,j)*TwoInts(i,j,a,b)/Newc%ab%m(a,i)%nsym(s,q)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if







       do symgp=1,numSG
         k_begin = occ(1,symgp)
         k_end   = occ(2,symgp)
         c_begin = virt(1,symgp)
         c_end   = virt(2,symgp)
         do k=k_begin,k_end
           do c=c_begin,c_end
             T1deriv%a%o(k)%vsym(symgp)%v(c) = T1deriv%a%o(k)%vsym(symgp)%v(c) +-1*T1data%a%o(k)%vsym(symgp)%v(c)*2*2*(topsingles(0,0)*pizero_deriv + topsingles(1,0)*singles_cumocc_deriv(k) + topsingles(0,1)*singles_cumvirt_deriv(c) + topsingles(1,1)*(singles_cumaj_ab_deriv(k,c)+ singles_cumaj_aa_deriv(k,c)))
           end do
         end do
       end do
     Call CPU_TIME(time_end)
     time_topfactor = time_topfactor + (time_end - time_begin)
      end subroutine TopFactor

!> @brief Multiplies matrices when using the UpDiag feature (only part of matrix is stored)
!> @author Christine Schwerdtfeger and David Mazziotti
      function Mydsymm(side,Avec,B)

      Use TimeMod, only : time_mydsymm
      Implicit NONE
      character(len=1) :: side
      double precision, allocatable, dimension(:,:) :: B
      double precision, allocatable, dimension(:,:) :: Avec
      double precision, allocatable, dimension(:,:) :: Mydsymm
      double precision, allocatable, dimension(:,:) :: temp,tempout
      integer*8 :: Brow, Bcol
      integer*8 :: Arow, Acol
      integer*8 :: i,k,j,m,offset,col,temprow,row,tempcol
      integer :: numparts = 3

      double precision :: time_begin,time_end, time_sort, time_dgemm, time_destination
      time_sort = 0.0
      time_dgemm = 0.0
      time_destination = 0.0

      Call cpu_time(time_begin)
      Brow = size(B,1)
      Bcol = size(B,2)

      if(side.eq.'L') then
        Arow = Brow
        Acol = Brow
        allocate(Mydsymm(1:Arow,1:Bcol))
        Mydsymm = 0.D0
        temprow = Arow/numparts
        offset = 0
        do m=1,numparts
          if(m.eq.numparts) then
            temprow = Arow - offset
          end if
          if(temprow.eq.0.or.Bcol.eq.0.or.Acol.eq.0) cycle
          allocate(temp(1:temprow,1:Acol))
          temp = 0.d0
          do col=1,Acol
            row = offset + 1
            if(row.le.col.and.(offset+temprow).le.col) then
              do row=offset+1,offset+temprow
                temp(row-offset,col) = Avec(row+(col*(col-1))/2,1)
              end do
            else if(row.gt.col) then
              do row=offset+1,temprow+offset
                temp(row-offset,col) = Avec(col+((row)*(row-1))/2,1)
              end do
            else if(row.le.col.and.(offset+temprow).gt.col) then
              do row=offset+1,col
                temp(row-offset,col) = Avec(row+(col*(col-1)/2),1)
              end do
              do row=col+1,offset+temprow
                temp(row-offset,col) = Avec(col+(row*(row-1))/2,1)
              end do
            else
              write(*,*) 'did not fall into other categories'
            end if
          end do
          Call DGEMM('N','N',temprow,Bcol,Acol,1.d0,temp,temprow,B,Brow,0.d0,Mydsymm(offset+1:offset+temprow,1:Bcol),temprow)
          offset = offset + temprow
          deallocate(temp)
        end do
      end if





      if(side.eq.'R') then
        Arow = Bcol
        Acol = Bcol
        allocate(Mydsymm(1:Brow,1:Acol))
        Mydsymm = 0.D0
        tempcol = Acol/numparts
        offset = 0
        do m=1,numparts
          if(m.eq.numparts) then
            tempcol = Acol - offset
          end if
          if(Brow.eq.0.or.tempcol.eq.0.or.Bcol.eq.0) cycle
          allocate(temp(1:Arow,1:tempcol))
          temp = 0.d0
          do col=offset+1,tempcol+offset
            do row=1,col
              temp(row,col-offset) = Avec(row + (col*(col-1))/2,1)
            end do
            do row=col+1,Arow
              temp(row,col-offset) = Avec(col + (row*(row-1))/2,1)
            end do
          end do
          Call DGEMM('N','N',Brow,tempcol,Bcol,1.d0,B,Brow,temp,Arow,0.d0,Mydsymm(1:Brow,offset+1:offset+tempcol),Brow)
          offset = offset + tempcol
          deallocate(temp)
        end do
      end if

      Call cpu_time(time_end)
      time_mydsymm = time_end - time_begin + time_mydsymm


      end function Mydsymm

!> @brief Builds K1 and K2 for the upper diagonal storage of K2.  This feature 
!> accessible only by setting the diagK2option to TRUE
!> @author Christine Schwerdtfeger and David Mazziotti
      subroutine BuildK2K1_UpDiag(occ,virt,numSG,InvPdt,TwoIntsCompact,OneInts,ReshapedMatrixDim,K2,K1,ProductTable,K1TwoInts,numocc,numvirt,TwoInts)
      Use TypeMod
      Use TimeMod, only : time_buildk2k1
      Use InterfaceMod
      Implicit None

      integer, intent(IN), allocatable, dimension(:,:) :: occ, virt
      integer, intent(IN) :: numSG
      type(symmetry), allocatable, dimension(:) :: InvPdt
      real(8), allocatable, dimension(:,:,:,:) :: TwoInts
      real(8), intent(IN), allocatable, dimension(:,:) :: OneInts
      real(8), allocatable, dimension(:) :: TwoIntsCompact
      type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
      type(spin) :: K2(1:2,1:2,1:2,1:2)
      type(spin) :: K1(1:2,1:2)
      integer, dimension(1:numSG,1:numSG) :: ProductTable
      type(spin) :: K1TwoInts(1:2,1:2)

      integer :: i,j,k,l,i_begin,i_end,j_begin,j_end,k_begin,k_end,l_begin,l_end
      integer :: symgp, t,v,p,q,r,s
      integer :: numi,numa,numk
      integer*8 :: row,col
      integer :: a,b,c,d,a_begin,a_end,b_begin,b_end,c_begin,c_end,d_begin,d_end
      integer :: u
      integer :: begindim,enddim,enddim_occ
      real(8) :: test(1:2,1:2)
      real :: time_begin, time_end
      integer :: numocc,numvirt
      type(InverseBasis), allocatable, dimension(:) :: InverseBasisK1
      integer :: counter
      real(8) :: integral
      integer*8 :: index1,index2,compindex1,compindex2
      integer*8 :: upindex,tempallocate
      Call cpu_time(time_begin)
      allocate(K2(1,1,1,1)%aa%irrep(1:numSG))
      allocate(K2(2,2,2,2)%aa%irrep(1:numSG))
      allocate(K2(1,2,1,2)%aa%irrep(1:numSG))
      allocate(K2(1,1,2,2)%aa%irrep(1:numSG))
      allocate(K2(1,1,1,1)%ab%irrep(1:numSG))
      allocate(K2(2,2,2,2)%ab%irrep(1:numSG))
      allocate(K2(1,2,1,2)%ab%irrep(1:numSG))
      allocate(K2(1,1,2,2)%ab%irrep(1:numSG))
      allocate(K2(1,2,2,1)%ab%irrep(1:numSG))
      allocate(K2(1,1,1,2)%aa%irrep(1:numSG))
      allocate(K2(2,2,1,2)%aa%irrep(1:numSG))
      allocate(K2(1,1,1,2)%ab%irrep(1:numSG))
      allocate(K2(1,1,2,1)%ab%irrep(1:numSG))
      allocate(K2(2,2,1,2)%ab%irrep(1:numSG))
      allocate(K2(2,2,2,1)%ab%irrep(1:numSG))
      allocate(K1(1,1)%aa%irrep(1:numSG))
      allocate(K1(2,2)%aa%irrep(1:numSG))
      allocate(K1(1,2)%aa%irrep(1:numSG))
      allocate(K1TwoInts(1,1)%aa%irrep(1:numSG))
      allocate(K1TwoInts(2,2)%aa%irrep(1:numSG))
      allocate(K1TwoInts(1,2)%aa%irrep(1:numSG))
      do i=1,numSG
        allocate(K2(1,1,1,1)%aa%irrep(i)%block(1:ReshapedMatrixDim%ijaa(i)%col*(ReshapedMatrixDim%ijaa(i)%col+1)/2,1))
        allocate(K2(2,2,2,2)%aa%irrep(i)%block(1:ReshapedMatrixDim%ijaa(i)%row*(ReshapedMatrixDim%ijaa(i)%row+1)/2,1))
        allocate(K2(1,2,1,2)%aa%irrep(i)%block(1:ReshapedMatrixDim%ajaa(i)%col*(ReshapedMatrixDim%ajaa(i)%col+1)/2,1))
        allocate(K2(1,1,2,2)%aa%irrep(i)%block(1:ReshapedMatrixDim%ijaa(i)%row,1:ReshapedMatrixDim%ijaa(i)%col))
      end do
       do i=1,numSG
        allocate(K2(1,1,1,1)%ab%irrep(i)%block(1:ReshapedMatrixDim%ijab(i)%col*(ReshapedMatrixDim%ijab(i)%col+1)/2,1))
        tempallocate =  ReshapedMatrixDim%ijab(1)%row
        tempallocate = tempallocate*(tempallocate+1)/2
        allocate(K2(2,2,2,2)%ab%irrep(i)%block(1:tempallocate,1))
        allocate(K2(1,2,1,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%ajab(i)%col*(ReshapedMatrixDim%ajab(i)%col+1)/2,1))
        allocate(K2(1,1,2,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%ijab(i)%row,1:ReshapedMatrixDim%ijab(i)%col))
        allocate(K2(1,2,2,1)%ab%irrep(i)%block(1:ReshapedMatrixDim%ajaa_only(i)%row,1:ReshapedMatrixDim%ajaa_only(i)%col))
        tempallocate = size(K2(2,2,2,2)%ab%irrep(1)%block,1)

        numi = (occ(2,i) - occ(1,i)) + 1
        numa = (virt(2,i) - virt(1,i)) + 1
        allocate(K2(1,1,1,2)%aa%irrep(i)%block(1:ReshapedMatrixDim%jka_aaa(i)%col,1:numi))
        allocate(K2(2,2,1,2)%aa%irrep(i)%block(1:ReshapedMatrixDim%bci_aaa(i)%col,1:numa))
        allocate(K2(1,1,1,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%jka_abb(i)%col,1:numi))
        allocate(K2(1,1,2,1)%ab%irrep(i)%block(1:ReshapedMatrixDim%jka_aba(i)%col,1:numi))
        allocate(K2(2,2,1,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%bci_aba(i)%col,1:numa))
        allocate(K2(2,2,2,1)%ab%irrep(i)%block(1:ReshapedMatrixDim%bci_abb(i)%col,1:numa))
      end do

       do t=1,numSG
         i_begin = occ(1,t)
         i_end   = occ(2,t)
         a_begin = virt(1,t)
         a_end   = virt(2,t)
         numa = a_end - a_begin + 1
         numi = i_end - i_begin + 1
         allocate(K1(1,1)%aa%irrep(t)%block(i_begin:i_end,i_begin:i_end))
         allocate(K1(2,2)%aa%irrep(t)%block(a_begin:a_end,a_begin:a_end))
         allocate(K1(1,2)%aa%irrep(t)%block(1:numi*numa,1:1))
         allocate(K1TwoInts(1,1)%aa%irrep(t)%block(i_begin:i_end,i_begin:i_end))
         allocate(K1TwoInts(2,2)%aa%irrep(t)%block(a_begin:a_end,a_begin:a_end))
         allocate(K1TwoInts(1,2)%aa%irrep(t)%block(1:numa*numi,1:1))
         K1(1,1)%aa%irrep(t)%block(i_begin:i_end,i_begin:i_end) = 0.0D0
         K1(2,2)%aa%irrep(t)%block(a_begin:a_end,a_begin:a_end) = 0.0D0
         K1(1,2)%aa%irrep(t)%block(1:numa*numi,1:1) = 0.0D0
         K1TwoInts(1,1)%aa%irrep(t)%block(i_begin:i_end,i_begin:i_end) = 0.0D0
         K1TwoInts(2,2)%aa%irrep(t)%block(a_begin:a_end,a_begin:a_end) = 0.0D0
         K1TwoInts(1,2)%aa%irrep(t)%block(1:numa*numi,1:1) = 0.0D0
      end do
       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) cycle
                 k_begin = occ(1,r)
                 k_end   = occ(2,r)
                 l_begin = occ(1,s)
                 l_end   = occ(2,s)
                 do k=k_begin,k_end
                   do l=max(k+1,l_begin),l_end
                   if(row.le.col) then
                     index1 = FirstIndex(i,k)
                     index2 = FirstIndex(j,l)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(i,l)
                     index2 = FirstIndex(j,k)
                     compindex2 = CompositeIndex(index1,index2)
                     upindex = row + (col*(col-1))/2
                     K2(1,1,1,1)%aa%irrep(symgp)%block(upindex,1) = (TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2))
                   end if
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           b_begin = virt(1,q)
           b_end   = virt(2,q)
           do a=a_begin,a_end
             do b=max(a+1,b_begin),b_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) cycle
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 d_begin = virt(1,s)
                 d_end   = virt(2,s)
                 do c=c_begin,c_end
                   do d=max(c+1,d_begin),d_end
                   if(row.le.col) then
                     index1 = FirstIndex(a,c)
                     index2 = FirstIndex(b,d)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(a,d)
                     index2 = FirstIndex(b,c)
                     compindex2 = CompositeIndex(index1,index2)
                      upindex = row + (col*(col-1))/2
                      K2(2,2,2,2)%aa%irrep(symgp)%block(upindex,1) = (TwoIntsCompact(compindex1)- TwoIntsCompact(compindex2))
                    end if
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp = 1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) cycle
                 a_begin = virt(1,r)
                 a_end   = virt(2,r)
                 b_begin = virt(1,s)
                 b_end   = virt(2,s)
                 do a=a_begin,a_end
                   do b=max(a+1,b_begin),b_end
                     index1 = FirstIndex(i,a)
                     index2 = FirstIndex(j,b)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(i,b)
                     index2 = FirstIndex(j,a)
                     compindex2 = CompositeIndex(index1,index2)
                     K2(1,1,2,2)%aa%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)- TwoIntsCompact(compindex2)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt(1,r)
                 b_end   = virt(2,r)
                 i_begin = occ(1,s)
                 i_end   = occ(2,s)
                 do i=i_begin,i_end
                   do b=b_begin,b_end
                   if(row.le.col) then
                      index1 = FirstIndex(i,j)
                      index2 = FirstIndex(a,b)
                      compindex1 = CompositeIndex(index1,index2)
                      index1 = FirstIndex(i,b)
                      index2 = FirstIndex(a,j)
                      compindex2 = CompositeIndex(index1,index2)
                      upindex = row + (col*(col-1))/2
                      K2(1,2,1,2)%aa%irrep(symgp)%block(upindex,1) = TwoIntsCompact(compindex1)-TwoIntsCompact(compindex2)
                   end if
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 k_begin = occ(1,r)
                 k_end   = occ(2,r)
                 l_begin = occ(1,s)
                 l_end   = occ(2,s)
                 do k=k_begin,k_end
                   do l=l_begin,l_end
                     if(row.le.col) then
                     index1 = FirstIndex(i,k)
                     index2 = FirstIndex(j,l)
                     compindex1 = CompositeIndex(index1,index2)
                      upindex = row + (col*(col-1))/2
                      K2(1,1,1,1)%ab%irrep(symgp)%block(upindex,1) = TwoIntsCompact(compindex1)
                     end if
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do


       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           b_begin = virt(1,q)
           b_end   = virt(2,q)
           do a=a_begin,a_end
             do b=b_begin,b_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 d_begin = virt(1,s)
                 d_end   = virt(2,s)
                 do c=c_begin,c_end
                   do d=d_begin,d_end
                     if(row.le.col) then
                     index1 = FirstIndex(a,c)
                     index2 = FirstIndex(b,d)
                     compindex1 = CompositeIndex(index1,index2)
                      upindex = row + (col*(col-1))/2
                      K2(2,2,2,2)%ab%irrep(symgp)%block(upindex,1) = TwoIntsCompact(compindex1)
                     end if
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp = 1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 a_begin = virt(1,r)
                 a_end   = virt(2,r)
                 b_begin = virt(1,s)
                 b_end   = virt(2,s)
                 do a=a_begin,a_end
                   do b=b_begin,b_end
                     index1 = FirstIndex(i,a)
                     index2 = FirstIndex(j,b)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(1,1,2,2)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do a=a_begin,a_end
             do j=j_begin,j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt(1,r)
                 b_end   = virt(2,r)
                 i_begin = occ(1,s)
                 i_end   = occ(2,s)
                 do b=b_begin,b_end
                   do i=i_begin,i_end
                     if(row.le.col) then
                     index1 = FirstIndex(i,j)
                     index2 = FirstIndex(a,b)
                     compindex1 = CompositeIndex(index1,index2)
                      upindex = row + (col*(col-1))/2
                      K2(1,2,1,2)%ab%irrep(symgp)%block(upindex,1) = TwoIntsCompact(compindex1)
                    end if
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = 0
           do t=1,numSG
              p = InvPdt(symgp)%upper(t)
              q = InvPdt(symgp)%lower(t)
              a_begin = virt(1,p)
              a_end   = virt(2,p)
              j_begin = occ(1,q)
              j_end   = occ(2,q)
              do j=j_begin,j_end
                do a=a_begin,a_end
                  col = col + 1
                  row = 1
                  do v=1,numSG
                     r = InvPdt(symgp)%upper(v)
                     s = InvPdt(symgp)%lower(v)
                     b_begin = virt(1,r)
                     b_end   = virt(2,r)
                     i_begin = occ(1,s)
                     i_end   = occ(2,s)
                     do i=i_begin,i_end
                       do b=b_begin,b_end
                         index1 = FirstIndex(a,j)
                         index2 = FirstIndex(i,b)
                         compindex1 = CompositeIndex(index1,index2)
                          K2(1,2,2,1)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                         row = row + 1
                       end do
                    end do
                  end do
                end do
              end do
           end do
        end do
       do symgp=1,numSG
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         j_begin = occ(1,symgp)
         j_end   = occ(2,symgp)
         do i=i_begin,i_end
           do j=j_begin,j_end
             K1(1,1)%aa%irrep(symgp)%block(i,j) = OneInts(i,j)
             K1(1,1)%aa%irrep(symgp)%block(j,i) = OneInts(j,i)
           end do
         end do
       end do

       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) continue
                 k_begin = occ(1,r)
                 k_end   = occ(2,r)
                 l_begin = occ(1,s)
                 l_end   = occ(2,s)
                 do k=k_begin,k_end
                   do l=max(k+1,l_begin),l_end
                       index1 = FirstIndex(i,k)
                       index2 = FirstIndex(j,l)
                       compindex1 = CompositeIndex(index1,index2)
                       index1 = FirstIndex(i,l)
                       index2 = FirstIndex(j,k)
                       compindex2 = CompositeIndex(index1,index2)
                     if(j==l.and.ProductTable(p,r)==1) then
                        K1TwoInts(1,1)%aa%irrep(p)%block(i,k) = 2*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%aa%irrep(p)%block(i,k)
                       if(i.ne.k) then
                       end if
                     end if
                     if(i==l.and.ProductTable(q,r)==1) then
                        K1TwoInts(1,1)%aa%irrep(q)%block(j,k) = 2*-1*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%aa%irrep(q)%block(j,k)

                       if(k.ne.j) then
                       end if
                     end if
                     if(j==k.and.ProductTable(p,s)==1) then
                       K1TwoInts(1,1)%aa%irrep(p)%block(i,l) = 2*-1*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%aa%irrep(p)%block(i,l)

                       if(l.ne.i) then
                       end if
                     end if
                     if(i==k.and.ProductTable(q,s)==1) then
                        K1TwoInts(1,1)%aa%irrep(q)%block(j,l) = 2*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%aa%irrep(q)%block(j,l)
                      if(l.ne.j) then
                      end if
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 k_begin = occ(1,r)
                 k_end   = occ(2,r)
                 l_begin = occ(1,s)
                 l_end   = occ(2,s)
                 do k=k_begin,k_end
                   do l=l_begin,l_end
                     index1 = FirstIndex(i,k)
                     index2 = FirstIndex(j,l)
                     compindex1 = CompositeIndex(index1,index2)
                     if(j==l.and.ProductTable(p,r)==1) then
                        K1TwoInts(1,1)%aa%irrep(p)%block(i,k) = TwoIntsCompact(compindex1) + K1TwoInts(1,1)%aa%irrep(p)%block(i,k)

                       if(k.ne.i) then
                       end if
                     end if
                     if(i==k.and.ProductTable(q,s)==1) then
                       K1TwoInts(1,1)%aa%irrep(q)%block(j,l) = TwoIntsCompact(compindex1) + K1TwoInts(1,1)%aa%irrep(q)%block(j,l)
                       if(l.ne.j) then
                       end if
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do



       do symgp=1,numSG
         a_begin = virt(1,symgp)
         a_end   = virt(2,symgp)
         b_begin = virt(1,symgp)
         b_end   = virt(2,symgp)
         do a=a_begin,a_end
           do b=b_begin,b_end
             K1(2,2)%aa%irrep(symgp)%block(a,b) = OneInts(a,b)
             K1(2,2)%aa%irrep(symgp)%block(b,a) = OneInts(b,a)
           end do
         end do
       end do

      do symgp=1,numSG
        a_begin = virt(1,symgp)
        a_end   = virt(2,symgp)
        i_begin = occ(1,symgp)
        i_end   = occ(2,symgp)
        row = 1
        col = 1
        do i=i_begin,i_end
          do a=a_begin,a_end
            K1(1,2)%aa%irrep(symgp)%block(row,col) = OneInts(i,a)
            row = row + 1
          end do
        end do
      end do


       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do a=a_begin,a_end
             do j=j_begin,j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt(1,r)
                 b_end   = virt(2,r)
                 i_begin = occ(1,s)
                 i_end   = occ(2,s)
                 do b=b_begin,b_end
                   do i=i_begin,i_end
                     if(i==j.and.ProductTable(p,r)==1) then
                       index1 = FirstIndex(i,j)
                       index2 = FirstIndex(a,b)
                       compindex1 = CompositeIndex(index1,index2)
                       index1 = FirstIndex(i,b)
                       index2 = FirstIndex(a,j)
                       compindex2 = CompositeIndex(index1,index2)
                        K1TwoInts(2,2)%aa%irrep(p)%block(a,b) = 2*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(2,2)%aa%irrep(p)%block(a,b)
                       K1TwoInts(2,2)%aa%irrep(p)%block(a,b) = 2*TwoIntsCompact(compindex1) + K1TwoInts(2,2)%aa%irrep(p)%block(a,b)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
          col = 1
          row = 0
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                    row = row + 1
                    col = 1
                   do i=i_begin,i_end
                     index1 = FirstIndex(j,i)
                     index2 = FirstIndex(k,a)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(j,a)
                     index2 = FirstIndex(k,i)
                     compindex2 = CompositeIndex(index1,index2)
                     K2(1,1,1,2)%aa%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
          col = 1
          row = 0
         a_begin = virt(1,symgp)
         a_end   = virt(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=max(c_begin,b+1),c_end
                    row = row + 1
                    col = 1
                   do a=a_begin,a_end
                     index1 = FirstIndex(b,i)
                     index2 = FirstIndex(c,a)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(b,a)
                     index2 = FirstIndex(c,i)
                     compindex2 = CompositeIndex(index1,index2)
                     K2(2,2,1,2)%aa%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)
                    col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
          row = 0
          col = 1
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do k=k_begin,k_end
                 do a=a_begin,a_end
                   col = 1
                   row = row + 1
                   do i=i_begin,i_end
                     index1 = FirstIndex(j,i)
                     index2 = FirstIndex(k,a)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(1,1,1,2)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
          row = 0
          col = 1
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=k_begin,k_end
                    row = row + 1
                    col = 1
                   do i=i_begin,i_end
                     index1 = FirstIndex(j,a)
                     index2 = FirstIndex(k,i)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(1,1,2,1)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                     col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
          row = 0
          col = 1
         a_begin = virt(1,symgp)
         a_end   = virt(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=c_begin,c_end
                    col = 1
                    row = row + 1
                   do a=a_begin,a_end
                     index1 = FirstIndex(b,i)
                     index2 = FirstIndex(c,a)
                     compindex1 = CompositeIndex(index1,index2)
                     K2(2,2,1,2)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
          row = 0
          col = 1
         a_begin = virt(1,symgp)
         a_end   = virt(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             do b=b_begin,b_end
               do i=i_begin,i_end
                 do c=c_begin,c_end
                    col = 1
                    row = row + 1
                   do a=a_begin,a_end
                     index1 = FirstIndex(b,a)
                     index2 = FirstIndex(c,i)
                     compindex1 = CompositeIndex(index1,index2)
                     K2(2,2,2,1)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
allocate(InverseBasisK1(1:numSG))
do symgp=1,numSG
  counter = 1
  i_begin = occ(1,symgp)
  i_end   = occ(2,symgp)
  a_begin = virt(1,symgp)
  a_end   = virt(2,symgp)
  allocate(InverseBasisK1(symgp)%basis(i_begin:i_end,a_begin:a_end))
  do i=i_begin,i_end
    do a=a_begin,a_end
      InverseBasisK1(symgp)%basis(i,a) = counter
      counter = counter + 1
    end do
  end do
end do



       do symgp=1,numSG
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         numi = i_end - i_begin + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           numk = k_end - k_begin + 1
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                   do i=i_begin,i_end
                     index1 = FirstIndex(i,j)
                     index2 = FirstIndex(a,k)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(i,k)
                     index2 = FirstIndex(a,j)
                     compindex2 = CompositeIndex(index1,index2)
                     if(i.eq.j.and.ProductTable(r,q).eq.1) then
                        K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(k,a),1) = 2*2*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(k,a),1)

                     end if
                     if(i.eq.k.and.ProductTable(s,r).eq.1) then
                       K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(j,a),1) =-2*2*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(j,a),1)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do


       do symgp=1,numSG
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do k=k_begin,k_end
                 do a=a_begin,a_end
                   do i=i_begin,i_end
                     if(i.eq.j.and.ProductTable(q,r).eq.1) then
                       index1 = FirstIndex(j,i)
                       index2 = FirstIndex(k,a)
                       compindex1 = CompositeIndex(index1,index2)
                        K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(k,a),1) =2*TwoIntsCompact(compindex1) + K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(k,a),1)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=k_begin,k_end
                   do i=i_begin,i_end
                     if(i.eq.k.and.ProductTable(r,s).eq.1) then
                       index1 = FirstIndex(j,a)
                       index2 = FirstIndex(k,i)
                       compindex1 = CompositeIndex(index1,index2)
                       K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(j,a),1) = 2*TwoIntsCompact(compindex1) + K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(j,a),1)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
         allocate(TwoInts(1:numocc,1:numocc,numocc+1:numvirt+numocc,numocc+1:numvirt+numocc))
         TwoInts(1:numocc,1:numocc,numocc+1:numocc+numvirt,numocc+1:numocc+numvirt) = 0.0
         do i=1,numocc
           do j=1,numocc
             do a=numocc+1,numocc+numvirt
               do b=numocc+1,numocc+numvirt
                 index1 = FirstIndex(i,a)
                 index2 = FirstIndex(j,b)
                 compindex1 = CompositeIndex(index1,index2)
                 integral = TwoIntsCompact(compindex1)
                 TwoInts(i,j,a,b) = integral
                 TwoInts(j,i,b,a) = integral
               end do
             end do
           end do
        end do
        deallocate(TwoIntsCompact)


Call cpu_time(time_end)
   time_buildk2k1 = time_buildk2k1 + time_end - time_begin

       end subroutine BuildK2K1_UpDiag

!> @brief Calculates the derivative is diagK2option is TRUE
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine CalcDeriv_UpDiag(T2data,K2,K1,numSG,ProductTable,numOcc,numVirt,occ,virt,ReshapedMatrixDim,InvPdt,T2deriv, energy,K1TwoInts,T1data,T1deriv,Newc,DerivNewc,topfac,TwoInts,topsingles)
       Use InterfaceMod
       Use TypeMod
       Use TimeMod
       Implicit None

       type(T2) :: T2data
       type(T1) :: T1data,T1deriv
       type(T2) :: Newc,DerivNewc
       type(spin) :: K2(1:2,1:2,1:2,1:2)
       type(spin) :: K1(1:2,1:2),K1TwoInts(1:2,1:2)
       integer :: numSG,numOcc,numVirt
       integer, intent(IN), dimension(1:numSG,1:numSG) :: ProductTable
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN) :: InvPdt(1:numSG)
       integer, intent(IN), dimension(1:2,1:numSG) :: occ,virt
       integer :: p, i_begin,i_end,j_begin,j_end,k_begin,k_end, l_begin,l_end,i,j,k,l,q,r,s,t,v,row,col,symgp
       integer :: c_begin,c_end,a_begin,a_end,c,a
       type(ReshapedMat), allocatable, dimension(:)  :: DerivReshapes, Reshapes, TopReshape,DerivTopReshape
       type(T2) :: T2deriv
       real(8) :: energy
       real(8) :: tempenergy=0.0D0
       integer :: temprow, tempcol
       real(8), dimension(0:2,0:2) :: topfac
       real(8), intent(IN), allocatable, dimension(:,:,:,:) :: TwoInts
       real(8), dimension(0:1,0:1) :: topsingles(0:1,0:1)


       type(ReshapedMat), allocatable, dimension(:) :: TempReshape,TempDerivReshape
       real(8), allocatable, dimension(:,:) :: temp
       integer :: test = 0
       integer :: flag
       integer :: time_initial(8),time_final(8)
       real :: time_begin, time_end
       real :: time_total_begin, time_total_end
       integer :: testdim
       integer :: numa,numi
       Call cpu_time(time_total_begin)


        energy = 0.0D0
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ijaa_test(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*2*Mydsymm('R',K2(1,1,1,1)%aa%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
       end do
         do p=1,numSG
           DerivReshapes(p)%ReshapedMatrix = 2*2*Mydsymm('L',K2(2,2,2,2)%aa%irrep(p)%block,Reshapes(p)%ReshapedMatrix) + DerivReshapes(p)%ReshapedMatrix
        end do
       Call reshape_ijaa_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
deallocate(DerivReshapes)
allocate(DerivReshapes(1:numSG))
allocate(TopReshape(1:numSG))
       Call TopFactor(TwoInts,T2data,occ,virt,numSG,topfac,Newc,InvPdt,ProductTable,DerivNewc,numOcc,numVirt,T1data,T1deriv,topsingles)
       Call reshape_ijaa_test(numSG,ProductTable,TopReshape,numOcc,numVirt,occ,virt,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         do s=1,ReshapedMatrixDim%ijaa(p)%col
           do q=1,ReshapedMatrixDim%ijaa(p)%row
             energy = energy + Reshapes(p)%ReshapedMatrix(q,s)*2*2*K2(1,1,2,2)%aa%irrep(p)%block(q,s)*TopReshape(p)%ReshapedMatrix(q,s)
             tempenergy = tempenergy + Reshapes(p)%ReshapedMatrix(q,s)*2*2*K2(1,1,2,2)%aa%irrep(p)%block(q,s)*TopReshape(p)%ReshapedMatrix(q,s)
           end do
         end do
       end do
       deallocate(TopReshape)
       deallocate(Reshapes)
       deallocate(DerivReshapes)
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ajaa(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*2*Mydsymm('R',K2(1,2,1,2)%aa%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
       end do
       Call reshape_ajaa_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)

        deallocate(Reshapes)
        deallocate(DerivReshapes)
        allocate(Reshapes(1:numSG))
        allocate(DerivReshapes(1:numSG))
       Call reshape_ijab_test(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       tempenergy = 0
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*Mydsymm('R',K2(1,1,1,1)%ab%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
       end do

       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*Mydsymm('L',K2(2,2,2,2)%ab%irrep(p)%block,Reshapes(p)%ReshapedMatrix) + DerivReshapes(p)%ReshapedMatrix
       end do
       Call reshape_ijab_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
deallocate(DerivReshapes)
allocate(TopReshape(1:numSG))
allocate(DerivReshapes(1:numSG))
       Call reshape_ijab_test(numSG,ProductTable,TopReshape,numOcc,numVirt,occ,virt,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         do q=1,ReshapedMatrixDim%ijab(p)%col
           do s=1,ReshapedMatrixDim%ijab(p)%row
             energy = energy + Reshapes(p)%ReshapedMatrix(s,q)*2*K2(1,1,2,2)%ab%irrep(p)%block(s,q)*TopReshape(p)%ReshapedMatrix(s,q)
             tempenergy = tempenergy + Reshapes(p)%ReshapedMatrix(s,q)*2*K2(1,1,2,2)%ab%irrep(p)%block(s,q)*TopReshape(p)%ReshapedMatrix(s,q)
           end do
         end do
      end do
       deallocate(TopReshape)
       deallocate(Reshapes)
       deallocate(DerivReshapes)
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ajab(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*Mydsymm('R',K2(1,2,1,2)%ab%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
      end do
       Call reshape_ajab_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)

       deallocate(Reshapes)
       deallocate(DerivReshapes)
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ajba(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*Mydsymm('R',K2(1,2,1,2)%ab%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
       end do
       Call reshape_ajba_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       deallocate(Reshapes)
       deallocate(DerivReshapes)
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_i(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*2*matmul4(Reshapes(p)%ReshapedMatrix,K1(1,1)%aa%irrep(p)%block)
       end do

       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix =-1*2*matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(1,1)%aa%irrep(p)%block) + DerivReshapes(p)%ReshapedMatrix
      end do
      Call reshape_i_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
      deallocate(Reshapes)
      deallocate(DerivReshapes)
      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
      Call reshape_a(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*2*matmul4(Reshapes(p)%ReshapedMatrix,K1(2,2)%aa%irrep(p)%block)
      end do
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(2,2)%aa%irrep(p)%block) + DerivReshapes(p)%ReshapedMatrix
     end do
      Call reshape_a_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)

      deallocate(Reshapes)
      deallocate(DerivReshapes)

       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           a_begin = virt(1,p);
           a_end   = virt(2,p);
           j_begin = occ(1,q);
           j_end   = occ(2,q);
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 k_begin = occ(1,s)
                 k_end   = occ(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     energy = energy + 0.5*T2data%aa%m(a,j)%nsym(r,s)%n(c,k)*T2deriv%aa%m(a,j)%nsym(r,s)%n(c,k)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           a_begin = virt(1,p);
           a_end   = virt(2,p);
           j_begin = occ(1,q);
           j_end   = occ(2,q);
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 k_begin = occ(1,s)
                 k_end   = occ(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     energy = energy + 0.5*T2data%ab%m(a,j)%nsym(r,s)%n(c,k)*T2deriv%ab%m(a,j)%nsym(r,s)%n(c,k)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       allocate(DerivReshapes(1:numSG))
       allocate(TopReshape(1:numSG))
       allocate(DerivTopReshape(1:numSG))
       Call reshape_ijaa_test(numSG,ProductTable,TopReshape,numOcc,numVirt,occ,virt,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)
       deallocate(DerivReshapes)
       allocate(DerivReshapes(1:numSG))
       Call reshape_ijaa_test(numSG,ProductTable,DerivTopReshape,numOcc,numVirt,occ,virt,DerivNewc,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         do q=1,ReshapedMatrixDim%ijaa(p)%col
           do s=1,ReshapedMatrixDim%ijaa(p)%row
             DerivReshapes(p)%ReshapedMatrix(s,q) = 2*2*(K2(1,1,2,2)%aa%irrep(p)%block(s,q)*TopReshape(p)%ReshapedMatrix(s,q) + DerivTopReshape(p)%ReshapedMatrix(s,q))
            end do
         end do
       end do

       Call reshape_ijaa_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
      deallocate(DerivReshapes)
      deallocate(TopReshape)
      deallocate(DerivTopReshape)
      allocate(DerivReshapes(1:numSG))
      allocate(TopReshape(1:numSG))
      allocate(DerivTopReshape(1:numSG))
       Call reshape_ijab_test(numSG,ProductTable,TopReshape,numOcc,numVirt,occ,virt,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)
       deallocate(DerivReshapes)
       allocate(DerivReshapes(1:numSG))
       Call reshape_ijab_test(numSG,ProductTable,DerivTopReshape,numOcc,numVirt,occ,virt,DerivNewc,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        do q=1,ReshapedMatrixDim%ijab(p)%col
          do s=1,ReshapedMatrixDim%ijab(p)%row
         DerivReshapes(p)%ReshapedMatrix(s,q) = 2*(K2(1,1,2,2)%ab%irrep(p)%block(s,q)*TopReshape(p)%ReshapedMatrix(s,q) + DerivTopReshape(p)%ReshapedMatrix(s,q))
          end do
      end do
      end do
      Call reshape_ijab_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
      deallocate(DerivReshapes)
      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
      allocate(TempReshape(1:numSG))
      allocate(TempDerivReshape(1:numSG))

      Call reshape_ajaa_transpose(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_ajbb(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
       do p=1,numSG
          DerivReshapes(p)%ReshapedMatrix = 2*-1*-1*matmul4(K2(1,2,2,1)%ab%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
       end do
       do p=1,numSG
           TempDerivReshape(p)%ReshapedMatrix = 2*-1*-1*matmul4(TempReshape(p)%ReshapedMatrix,K2(1,2,2,1)%ab%irrep(p)%block)
       end do
       do p=1,numSG
         do q=1,ReshapedMatrixDim%ajaa(p)%row
           do s=1,ReshapedMatrixDim%ajaa(p)%col
               energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*TempReshape(p)%ReshapedMatrix(q,s)
           end do
         end do
      end do
         Call reshape_ajaa_transpose_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
         Call reshape_ajbb_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)

deallocate(DerivReshapes)
deallocate(TempDerivReshape)
deallocate(Reshapes)
deallocate(TempReshape)
allocate(DerivReshapes(1:numSG))
allocate(TempDerivReshape(1:numSG))
allocate(Reshapes(1:numSG))
allocate(TempReshape(1:numSG))
Call reshape_jka_aaa(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
Call reshape_t1_b(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
     tempenergy = energy
     do p=1,numSG
       TempDerivReshape(p)%ReshapedMatrix = 2*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,1,2)%aa%irrep(p)%block)
       DerivReshapes(p)%ReshapedMatrix = 2*2*matmul4(K2(1,1,1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
     end do
     do p=1,numSG
       do q=1,ReshapedMatrixDim%jka_aaa(p)%row
         do s=1,ReshapedMatrixDim%jka_aaa(p)%col
          energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
         end do
       end do
    end do
     tempenergy = energy- tempenergy
      Call reshape_jka_aaa_inverse(numSG,ProductTable,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_b_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
deallocate(Reshapes)
deallocate(TempReshape)
deallocate(TempDerivReshape)
deallocate(DerivReshapes)
allocate(DerivReshapes(1:numSG))
allocate(TempDerivReshape(1:numSG))
allocate(Reshapes(1:numSG))
allocate(TempReshape(1:numSG))
       Call reshape_bci_aaa(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Call reshape_t1_i(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
tempenergy= energy
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*2*matmul4(K2(2,2,1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
         TempDerivReshape(p)%ReshapedMatrix = 2*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(2,2,1,2)%aa%irrep(p)%block)
       end do

      do p=1,numSG
        do q=1,ReshapedMatrixDim%bci_aaa(p)%row
          do s=1,ReshapedMatrixdim%bci_aaa(p)%col
            energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
          end do
        end do
       end do
tempenergy = energy - tempenergy
       Call reshape_bci_aaa_inverse(numSG,ProductTable,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Call reshape_t1_i_inverse(numSG,ProductTable,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt,TempDerivReshape)


deallocate(Reshapes)
deallocate(TempReshape)
deallocate(TempDerivReshape)
deallocate(DerivReshapes)
allocate(DerivReshapes(1:numSG))
allocate(TempDerivReshape(1:numSG))
allocate(Reshapes(1:numSG))
allocate(TempReshape(1:numSG))

       Call reshape_jka_abb(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Call reshape_t1_b(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
tempenergy = energy
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(K2(1,1,1,2)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
        TempDerivReshape(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,1,2)%ab%irrep(p)%block)
      end do

      do p=1,numSG
        do q=1,ReshapedMatrixDim%jka_abb(p)%row
          do s=1,ReshapedMatrixDim%jka_abb(p)%col
            energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
          end do
        end do
      end do
tempenergy = energy - tempenergy
       Call reshape_t1_b_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       Call reshape_jka_abb_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)

deallocate(Reshapes)
deallocate(TempReshape)
deallocate(TempDerivReshape)
deallocate(DerivReshapes)
allocate(DerivReshapes(1:numSG))
allocate(TempDerivReshape(1:numSG))
allocate(Reshapes(1:numSG))
allocate(TempReshape(1:numSG))
       Call reshape_jka_aba(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Call reshape_t1_b(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)

tempenergy = energy
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(K2(1,1,2,1)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
        TempDerivReshape(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,2,1)%ab%irrep(p)%block)
      end do

      do p=1,numSG
        do q=1,ReshapedMatrixDim%jka_aba(p)%row
          do s=1,ReshapedMatrixDim%jka_aba(p)%col
            energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q) * Reshapes(p)%ReshapedMatrix(q,s)
          end do
        end do
      end do
tempenergy = energy - tempenergy
       Call reshape_t1_b_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       Call reshape_jka_aba_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)

deallocate(Reshapes)
deallocate(TempReshape)
deallocate(TempDerivReshape)
deallocate(DerivReshapes)
allocate(DerivReshapes(1:numSG))
allocate(TempDerivReshape(1:numSG))
allocate(Reshapes(1:numSG))
allocate(TempReshape(1:numSG))
       Call reshape_bci_aba(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Call reshape_t1_i(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
tempenergy = energy

      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K2(2,2,1,2)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
        TempDerivReshape(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(2,2,1,2)%ab%irrep(p)%block)
      end do

      do p=1,numSG
        do q=1,ReshapedMatrixDim%bci_aba(p)%row
          do s=1,ReshapedMatrixDim%bci_aba(p)%col
            energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
          end do
        end do
      end do
tempenergy = energy - tempenergy
       Call reshape_t1_i_inverse(numSG,ProductTable,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt,TempDerivReshape)
       Call reshape_bci_aba_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)

deallocate(Reshapes)
deallocate(TempReshape)
deallocate(TempDerivReshape)
deallocate(DerivReshapes)
allocate(DerivReshapes(1:numSG))
allocate(TempDerivReshape(1:numSG))
allocate(Reshapes(1:numSG))
allocate(TempReshape(1:numSG))
       Call reshape_bci_abb(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Call reshape_t1_i(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
tempenergy = energy
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix =1*2*matmul4(K2(2,2,2,1)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
         TempDerivReshape(p)%ReshapedMatrix = 1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(2,2,2,1)%ab%irrep(p)%block)
       end do

      do p=1,numSG
        do q=1,ReshapedMatrixDim%bci_abb(p)%row
          do s=1,ReshapedMatrixDim%bci_abb(p)%col
            energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q) * Reshapes(p)%ReshapedMatrix(q,s)
          end do
        end do
      end do
tempenergy = energy - tempenergy
       Call reshape_t1_i_inverse(numSG,ProductTable,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt,TempDerivReshape)
       Call reshape_bci_abb_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)

deallocate(Reshapes)
deallocate(TempReshape)
deallocate(TempDerivReshape)
deallocate(DerivReshapes)
allocate(DerivReshapes(1:numSG))
allocate(Reshapes(1:numSG))

       Call reshape_t1t1_i(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
tempenergy = energy
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*-1*2*matmul4(Reshapes(p)%ReshapedMatrix,K1(1,1)%aa%irrep(p)%block)
       end do
       do p=1,numSG
         numa = virt(2,p) - virt(1,p) + 1
         numi = occ(2,p) - occ(1,p) + 1
         do q=1,numi
           do s=1,numa
             energy = energy + 0.5*Reshapes(p)%ReshapedMatrix(s,q)* DerivReshapes(p)%ReshapedMatrix(s,q)
           end do
         end do
       end do
tempenergy = energy - tempenergy
       Call reshape_t1t1_i_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)

tempenergy = energy
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*-1*matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(1,1)%aa%irrep(p)%block)
       end do

       do p=1,numSG
         numa = virt(2,p) - virt(1,p) + 1
         numi = occ(2,p) - occ(1,p) + 1
         do q=1,numi
           do s=1,numa
             energy = energy + 0.5*Reshapes(p)%ReshapedMatrix(s,q)* DerivReshapes(p)%ReshapedMatrix(s,q)
           end do
         end do
       end do
tempenergy = energy - tempenergy
       Call reshape_t1t1_i_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)



tempenergy = energy
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*2*matmul4(K1(2,2)%aa%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
      end do

      do p=1,numSG
         numa = virt(2,p) - virt(1,p) + 1
         numi = occ(2,p) - occ(1,p) + 1
          do q=1,numi
           do s=1,numa
             energy = energy + 0.5*DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(s,q)
            end do
         end do
      end do
tempenergy = energy - tempenergy
        Call reshape_t1t1_i_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
tempenergy = energy
       do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K1TwoInts(2,2)%aa%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
      end do

      do p=1,numSG
         numa = virt(2,p) - virt(1,p) + 1
         numi = occ(2,p) - occ(1,p) + 1
          do q=1,numi
           do s=1,numa
             energy = energy + 0.5*DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(s,q)
            end do
         end do
      end do
tempenergy = energy - tempenergy
        Call reshape_t1t1_i_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
      deallocate(DerivReshapes)
      deallocate(Reshapes)
      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
       Call reshape_t1_ibrow_alphaonly_symi(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
tempenergy = energy
     do p=1,numSG
       DerivReshapes(p)%ReshapedMatrix = 2*2*K1(1,2)%aa%irrep(p)%block  +K1TwoInts(1,2)%aa%irrep(p)%block
       allocate(temp(1:1,1:1))
       temp =  matmul4(Reshapes(p)%ReshapedMatrix,DerivReshapes(p)%ReshapedMatrix)
       energy = energy + temp(1,1)
       deallocate(temp)
     end do
tempenergy = energy - tempenergy
      Call reshape_t1_ibrow_alphaonly_symi_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)

     deallocate(DerivReshapes)
     deallocate(Reshapes)
     allocate(DerivReshapes(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempReshape(1:numSG))
     allocate(TempDerivReshape(1:numSG))

     Call reshape_ajaa_t1(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibrow(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
tempenergy = energy
allocate(temp(1:1,1:1))
     do p=1,numSG
       DerivReshapes(p)%ReshapedMatrix = 2*2*matmul4(K1(1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
       TempDerivReshape(p)%ReshapedMatrix = 2*2*matmul4(Reshapes(p)%ReshapedMatrix,K1(1,2)%aa%irrep(p)%block)
     end do
     do p=1,numSG
        temp = matmul4(TempReshape(p)%ReshapedMatrix,TempDerivReshape(p)%ReshapedMatrix)
        energy = energy + temp(1,1)
     end do
tempenergy = energy - tempenergy
      Call reshape_ajaa_t1_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       Call reshape_t1_ibrow_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)

deallocate(DerivReshapes)
deallocate(Reshapes)
deallocate(TempDerivReshape)
deallocate(TempReshape)
allocate(DerivReshapes(1:numSG))
allocate(Reshapes(1:numSG))
allocate(TempDerivReshape(1:numSG))
allocate(TempReshape(1:numSG))
     Call reshape_ajaa_t1(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibrow(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
tempenergy = energy
     do p=1,numSG
       DerivReshapes(p)%ReshapedMatrix = matmul4(K1TwoInts(1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
       TempDerivReshape(p)%ReshapedMatrix = matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(1,2)%aa%irrep(p)%block)
     end do
     do p=1,numSG
        temp = matmul4(TempReshape(p)%ReshapedMatrix,TempDerivReshape(p)%ReshapedMatrix)
        energy = energy + temp(1,1)
     end do
tempenergy = energy - tempenergy
      Call reshape_ajaa_t1_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       Call reshape_t1_ibrow_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)

deallocate(DerivReshapes)
deallocate(Reshapes)
deallocate(TempDerivReshape)
deallocate(TempReshape)
allocate(DerivReshapes(1:numSG))
allocate(Reshapes(1:numSG))
allocate(TempDerivReshape(1:numSG))
allocate(TempReshape(1:numSG))


       Call reshape_t1_ibrow_alphaonly(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Call reshape_t1_ibcol_alphaonly(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
tempenergy = energy
         p=1
         TempDerivReshape(p)%ReshapedMatrix = -2*Mydsymm('R',K2(1,2,1,2)%aa%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
         DerivReshapes(p)%ReshapedMatrix = -2*Mydsymm('L',K2(1,2,1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
         do q=1,ReshapedMatrixDim%ajaa(1)%col
             energy = energy + DerivReshapes(1)%ReshapedMatrix(q,1)*Reshapes(1)%ReshapedMatrix(1,q)
         end do
tempenergy = energy - tempenergy
       Call reshape_t1_ibrow_alphaonly_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       Call reshape_t1_ibcol_alphaonly_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)


deallocate(DerivReshapes)
deallocate(Reshapes)
deallocate(TempDerivReshape)
deallocate(TempReshape)
allocate(DerivReshapes(1:numSG))
allocate(Reshapes(1:numSG))
allocate(TempDerivReshape(1:numSG))
allocate(TempReshape(1:numSG))
       Call reshape_t1_ibrow_alphaonly(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Call reshape_t1_ibcol_alphaonly(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
tempenergy = energy
         p = 1
         TempDerivReshape(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,2,2,1)%ab%irrep(p)%block)
         DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K2(1,2,2,1)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)

         do q=1,ReshapedMatrixDim%ajab(1)%col
             energy = energy + DerivReshapes(1)%ReshapedMatrix(q,1)*Reshapes(1)%ReshapedMatrix(1,q)
         end do
tempenergy = energy - tempenergy
       Call reshape_t1_ibrow_alphaonly_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       Call reshape_t1_ibcol_alphaonly_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)

        deallocate(Reshapes)
        deallocate(DerivReshapes)

    call cpu_time(time_total_end)
      time_calcderiv = time_calcderiv + time_total_end - time_total_begin
       end subroutine CalcDeriv_UpDiag

!> @brief Calculate HF energy when diagK2option is TRUE
!> @author Christine Schwerdtfeger and David Mazziotti
        subroutine CalcEnergy_UpDiag(T2data,numSG,T2deriv,energyconstants,K2,InvPdt,ReshapedMatrixDim,occ,virt,K1)
        Use InterfaceMod
        Use TypeMod
        Use TimeMod, only : time_calcenergy
        Implicit None

        type(T2), intent(IN) :: T2data
        type(T2), intent(IN) :: T2deriv
        integer :: numSG
        real(8) :: energyconstants
        type(spin) :: K2(1:2,1:2,1:2,1:2)
        type(symmetry), intent(IN) :: InvPdt(1:numSG)
        type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
        integer, allocatable, dimension(:,:) :: occ,virt
        type(spin) :: K1(1:2,1:2)

        integer :: symgp,t,v,p,q,r,s,row,col,i,j,k,l,c,a,b
        integer :: i_begin,i_end,j_begin,j_end,k_begin,k_end,l_begin,l_end,c_begin,c_end
        integer :: a_begin,a_end
        real(8), allocatable, dimension(:,:) :: temp
        type(ReshapedMat), allocatable, dimension(:)  :: Reshapes
        real :: time_begin, time_end

        call cpu_time(time_begin)


        energyconstants = 0

       allocate(Reshapes(1:numSG))
       do p=1,numSG
          allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ijaa(p)%col,1:ReshapedMatrixDim%ijaa(p)%col))
       end do

      do symgp=1,numSG
         col = 0
         do t=1,numSG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             if(p.GT.q) then
               cycle
             end if
             i_begin = occ(1,p)
             i_end   = occ(2,p)
             j_begin = occ(1,q)
             j_end   = occ(2,q)
             do i=i_begin,i_end
               do j=max(i+1,j_begin),j_end
                 col = col + 1
                 row = 1
                 do v=1,numSG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   if(r.GT.s) then
                     cycle
                   end if
                   k_begin = occ(1,r)
                   k_end   = occ(2,r)
                   l_begin = occ(1,s)
                   l_end   = occ(2,s)
                   do k=k_begin,k_end
                     do l=max(k+1,l_begin),l_end
                       if(i==k.and.j==l.and.k.ne.j) then
                         Reshapes(symgp)%ReshapedMatrix(row,col) = 1
                       else
                         Reshapes(symgp)%ReshapedMatrix(row,col) = 0
                       end if
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do


       do p=1,numSG
           allocate(temp(1:ReshapedMatrixDim%ijaa(p)%col,1:ReshapedMatrixDim%ijaa(p)%col))
           temp = Mydsymm('L',K2(1,1,1,1)%aa%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
           do q=1,ReshapedMatrixDim%ijaa(p)%col
             energyconstants = energyconstants + 2*temp(q,q)
           end do
           deallocate(temp)
         end do

      deallocate(Reshapes)
      allocate(Reshapes(1:numSG))
       do p=1,numSG
          allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ijab(p)%col,1:ReshapedMatrixDim%ijab(p)%col))
       end do

      do symgp=1,numSG
         col =0
         do t=1,numSG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             i_begin = occ(1,p)
             i_end   = occ(2,p)
             j_begin = occ(1,q)
             j_end   = occ(2,q)
             do i=i_begin,i_end
               do j=j_begin,j_end
                 col = col + 1
                 row = 1
                 do v=1,numSG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   k_begin = occ(1,r)
                   k_end   = occ(2,r)
                   l_begin = occ(1,s)
                   l_end   = occ(2,s)
                   do k=k_begin,k_end
                     do l=l_begin,l_end
                       if(i==k.and.j==l) then
                         Reshapes(symgp)%ReshapedMatrix(row,col) = 2*0.5
                       else
                         Reshapes(symgp)%ReshapedMatrix(row,col) = 0
                       end if
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do
       do p=1,numSG
         allocate(temp(1:ReshapedMatrixDim%ijab(p)%col,1:ReshapedMatrixDim%ijab(p)%col))
         temp = Mydsymm('L',K2(1,1,1,1)%ab%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
         do q=1,ReshapedMatrixDim%ijab(p)%col
           energyconstants = energyconstants + temp(q,q)
         end do
         deallocate(temp)
       end do
       deallocate(Reshapes)

       allocate(Reshapes(1:numSG))
       do p=1,numSG
         i_begin = occ(1,p)
         i_end   = occ(2,p)
         allocate(Reshapes(p)%ReshapedMatrix(i_begin:i_end,i_begin:i_end))
         Reshapes(p)%ReshapedMatrix(i_begin:i_end,i_begin:i_end) = 0.D0
      end do
       do p=1,numSG
         i_begin=occ(1,p)
         i_end  =occ(2,p)
         do i=i_begin,i_end
           Reshapes(p)%ReshapedMatrix(i,i) = 1
         end do
       end do


       do p=1,numSG
         i_begin = occ(1,p)
         i_end   = occ(2,p)
         allocate(temp(1:(i_end-i_begin+1),1:(i_end-i_begin +1)))
         temp = matmul(Reshapes(p)%ReshapedMatrix,K1(1,1)%aa%irrep(p)%block)
         do t=1,(i_end-i_begin+1)
           energyconstants = 2*temp(t,t) + energyconstants
         end do
         deallocate(temp)
       end do
write(*,*) 'Hartree Fock Energy:    ', energyconstants

       call cpu_time(time_end)
        time_calcenergy = time_calcenergy + time_end - time_begin
      end subroutine CalcEnergy_UpDiag

!> @brief Runs the energy optimization calculation when diagK2option  is TRUE
!> @author Christine Schwerdtfeger and David Mazziotti
      subroutine SinglePoint_UpDiag(N,h,SG,ProductTable,occ,virt,T2data,T2deriv,Newc,DerivNewc,T1data,T1deriv,ReshapedMatrixDim,InvPdt,OneInts,TwoIntsCompact,SymV,SymO,energy,topfac,topsingles,numElements,inputfile,EPS)

      Use InterfaceMod
      USE TypeMod
      Use TimeMod, only : time_singlepoint
      Implicit NONE
      integer :: h
      integer :: N
      integer :: SG
      integer, allocatable, dimension(:,:) :: ProductTable
      integer, allocatable, dimension(:,:) :: occ,virt
      type(T2) :: T2data,T2deriv
      type(T2) :: Newc, DerivNewc
      type(T1) :: T1data,T1deriv
      type(ReshapedDim) :: ReshapedMatrixDim
      type(symmetry), allocatable, dimension(:) :: InvPdt
      real(8), allocatable, dimension(:,:) :: OneInts
      real(8), allocatable, dimension(:) :: TwoIntsCompact
      integer, allocatable, dimension(:) :: SymV, SymO
      double precision :: energy
      real(8), dimension(0:2,0:2) :: topfac
      real(8), dimension(0:1,0:1) :: topsingles
      integer :: numElements
      character(len=100) :: inputfile
      double precision :: EPS

      type(spin) :: K2(1:2,1:2,1:2,1:2)
      type(spin) :: K1(1:2,1:2)
      type(spin) :: K1TwoInts(1:2,1:2)
      real(8), allocatable, dimension(:,:,:,:) :: TwoInts
      real(8), allocatable, dimension(:) :: DerivVector, Tvector
      double precision :: energyconstants
      integer :: iter,p,M
      integer :: IPRINT(1:2), SPFLAG
      double precision, allocatable, dimension(:) :: W
      double precision :: XTOL
      double precision, allocatable, dimension(:) :: DIAG
      real :: time_begin, time_end, begin_loop,end_loop
      integer :: begin_wall, end_wall, interval
      logical :: DIAGCO = .false.

      Call cpu_time(time_begin)
      Call BuildK2K1_UpDiag(occ,virt,SG,InvPdt,TwoIntsCompact,OneInts,ReshapedMatrixDim,K2,K1,ProductTable,K1TwoInts,N,h,TwoInts)
        IPRINT(1) = 0
        IPRINT(2) = 0
        SPFLAG=0
        XTOL = epsilon(1.0D0)
        M = 5
        allocate(DIAG(1:numElements))
        allocate(W(numElements*(2*M+1)+2*M))
        allocate(Tvector(1:numElements))
        allocate(DerivVector(1:numElements))
        Tvector(1:numElements) = 0.0D0
        DerivVector(1:numElements) = 0.0D0
        DIAG(1:numElements) = 1.0D0
        energy = 0.0D0
        energyconstants = 0.0D0
        Call DataStructure(T2data,N,h,InvPdt,SG,occ,virt,ProductTable,SymO,SymV,T2deriv,1,numElements,T1data,T1deriv,Newc,DerivNewc,inputfile)
        Call CalcDeriv_UpDiag(T2data,K2,K1,SG,ProductTable,N,h,occ,virt,ReshapedMatrixDim,InvPdt,T2deriv,energy,K1TwoInts,T1data,T1deriv,Newc,DerivNewc,topfac,TwoInts,topsingles)
        Call AveDeriv(N,h,InvPdt,SG,occ,virt,ProductTable,SymO,SymV,T2deriv)
        Call CalcEnergy_UpDiag(T2data,SG,T2deriv,energyconstants,K2,InvPdt,ReshapedMatrixDim,occ,virt,K1)
        energy = energy + energyconstants
        write(*,*) 'Energy (initial guess): ', energy
        Call CalcParameters(SG,occ,virt,T2data,InvPdt,T2deriv,DerivVector,Tvector,T1data,T1deriv)

        iter = 0
        do
          iter = iter + 1
          Call LBFGS(numElements,M,Tvector,energy,DerivVector,DIAGCO,DIAG,IPRINT,EPS,XTOL,W,SPFLAG)
          Call CalcParametersInverse(SG,occ,virt,T2data,InvPdt,Tvector,T1data)
          if(SPFLAG==1) then
           energy = 0.0D0
           Call DataStructure(T2data,N,h,InvPdt,SG,occ,virt,ProductTable,SymO,SymV,T2deriv,1,numElements,T1data,T1deriv,Newc,DerivNewc,inputfile)
           Call CalcDeriv_UpDiag(T2data,K2,K1,SG,ProductTable,N,h,occ,virt,ReshapedMatrixDim,InvPdt,T2deriv,energy,K1TwoInts,T1data,T1deriv,Newc,DerivNewc,topfac,TwoInts,topsingles)
           Call AveDeriv(N,h,InvPdt,SG,occ,virt,ProductTable,SymO,SymV,T2deriv)
           energy = energy + energyconstants
           write(*,*) 'Iteration and Total energy:',iter, energy
           Call CalcParameters(SG,occ,virt,T2data,InvPdt,T2deriv,DerivVector,Tvector,T1data,T1deriv)
          end if
          if(SPFLAG==-1) then
            write(*,*) 'SPFLAG = -1...exiting'
            stop
          end if
          if(SPFLAG==0) then
           energy = energy - energyconstants
          deallocate(OneInts)
          deallocate(TwoInts)
          deallocate(DIAG)
          deallocate(W)
          deallocate(Tvector)
          deallocate(DerivVector)
         deallocate(K2(1,1,1,1)%aa%irrep)
         deallocate(K2(2,2,2,2)%aa%irrep)
         deallocate(K2(1,2,1,2)%aa%irrep)
         deallocate(K2(1,1,2,2)%aa%irrep)
         deallocate(K2(1,1,1,1)%ab%irrep)
         deallocate(K2(2,2,2,2)%ab%irrep)
         deallocate(K2(1,2,1,2)%ab%irrep)
         deallocate(K2(1,1,2,2)%ab%irrep)
         deallocate(K2(1,2,2,1)%ab%irrep)
         deallocate(K2(1,1,1,2)%aa%irrep)
         deallocate(K2(2,2,1,2)%aa%irrep)
         deallocate(K2(1,1,1,2)%ab%irrep)
         deallocate(K2(1,1,2,1)%ab%irrep)
         deallocate(K2(2,2,1,2)%ab%irrep)
         deallocate(K2(2,2,2,1)%ab%irrep)
         deallocate(K1(1,1)%aa%irrep)
         deallocate(K1(2,2)%aa%irrep)
         deallocate(K1(1,2)%aa%irrep)
         deallocate(K1TwoInts(1,1)%aa%irrep)
         deallocate(K1TwoInts(2,2)%aa%irrep)
         deallocate(K1TwoInts(1,2)%aa%irrep)
          Call cpu_time(time_end)
          time_singlepoint = time_end - time_begin + time_singlepoint
          return
          end if
        end do

       end subroutine SinglePoint_UpDiag

!> @brief Builds the D1 matrix after parameters are optimized
!> @author Christine Schwerdtfeger and David Mazziotti
      subroutine BuildD1(T2data,T1data,numSG,ProductTable,occ,virt,ReshapedMatrixDim,InvPdt,filename,topsingles)

      Use TypeMod
      Use InterfaceMod
      Use TimeMod, only : time_buildd1
      Implicit NONE

      type(T2) :: T2data
      type(T1) :: T1data
      integer :: numSG,numOcc,numVirt
      integer, intent(IN), dimension(1:2,1:numSG) :: occ,virt
      type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
      type(ReshapedMat), allocatable, dimension(:)  :: DerivReshapes, Reshapes, TempReshape, TempDerivReshape
      integer, dimension(1:numSG,1:numSG) :: ProductTable
      type(symmetry), intent(IN), dimension(:) :: InvPdt(1:numSG)
      character(len=35) :: filename
      character(len=100) :: D1file
      real(8), dimension(:,:) :: topsingles(0:1,0:1)

      integer :: i,p,a,pos,j, q, counter
      type(D1) :: D1matrix(1:numSG)
      integer, allocatable, dimension(:) :: numocc_sg, numvirt_sg
      integer :: i_begin,i_end, a_begin,a_end,row,col
      double precision, allocatable, dimension(:,:) :: TempMat
      real :: time_begin, time_end
      type(T1) :: Newc_singles
      integer :: filenumber = 25

      double precision, allocatable, dimension(:) :: UpperDiag
      double precision, allocatable, dimension(:) :: EigVal
      double precision, allocatable, dimension(:,:) :: EigVec
      double precision, allocatable, dimension(:) :: WORK
      integer, allocatable, dimension(:) :: IWORK
      integer :: dimD1block, INFO

      double precision, allocatable, dimension(:) :: NatOrbOccNums
      integer :: NumOccNums, nval
      double precision :: temp

      Call cpu_time(time_begin)

      allocate(numocc_sg(1:numSG))
      allocate(numvirt_sg(1:numSG))
      numOcc = 0
      numVirt = 0
      do p=1,numSG
        i_begin = occ(1,p)
        i_end   = occ(2,p)
        a_begin = virt(1,p)
        a_end   = virt(2,p)
        numocc_sg(p) = i_end - i_begin + 1
        numvirt_sg(p) = a_end - a_begin + 1
        numOcc = numOcc + i_end - i_begin + 1
        numVirt = numVirt + a_end - a_begin + 1
      end do

      allocate(Newc_singles%a%o(1:numOcc))
      do p=1,numOcc
        allocate(Newc_singles%a%o(p)%vsym(1:numSG))
      end do
      do p=1,numSG
        i_begin = occ(1,p)
        i_end   = occ(2,p)
        a_begin = virt(1,p)
        a_end   = virt(2,p)
        do i=i_begin,i_end
          allocate(Newc_singles%a%o(i)%vsym(p)%v(a_begin:a_end))
          Newc_singles%a%o(i)%vsym(p)%v(a_begin:a_end) = 0.0
        end do
      end do

       Call BuildNewc_singles(Newc_singles,T2data,T1data,topsingles,numSG,occ,virt,InvPdt,ProductTable)

      do p=1,numSG
        allocate(D1matrix(p)%D1block(1:(numocc_sg(p)+numvirt_sg(p)),1:(numocc_sg(p)+numvirt_sg(p))))
        D1matrix(p)%D1block = 0.0
      end do

      do p=1,numSG
        do i=1,numocc_sg(p)
          D1matrix(p)%D1block(i,i) = 1.0
        end do
      end do
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_i(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         if(numocc_sg(p).ne.0) then
           D1matrix(p)%D1block(1:numocc_sg(p),1:numocc_sg(p)) = -1*matmul(transpose(Reshapes(p)%ReshapedMatrix),Reshapes(p)%ReshapedMatrix) + D1matrix(p)%D1block(1:numocc_sg(p),1:numocc_sg(p))
         end if
       end do
      deallocate(Reshapes,DerivReshapes)
      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
      Call reshape_t1t1_i(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        if(numocc_sg(p).ne.0) then
          D1matrix(p)%D1block(1:numocc_sg(p),1:numocc_sg(p)) = -1*matmul(transpose(Reshapes(p)%ReshapedMatrix),Reshapes(p)%ReshapedMatrix) + D1matrix(p)%D1block(1:numocc_sg(p),1:numocc_sg(p))
        end if
      end do

      do p=1,numSG
        if(numvirt_sg(p).ne.0) then
          D1matrix(p)%D1block(numocc_sg(p)+1:numocc_sg(p)+numvirt_sg(p),numocc_sg(p)+1:numocc_sg(p)+numvirt_sg(p)) = matmul(Reshapes(p)%ReshapedMatrix,transpose(Reshapes(p)%ReshapedMatrix)) + D1matrix(p)%D1block(numocc_sg(p)+1:numocc_sg(p)+numvirt_sg(p),numocc_sg(p)+1:numocc_sg(p)+numvirt_sg(p))
        end if
      end do
      deallocate(Reshapes,DerivReshapes)
      allocate(Reshapes(1:numSG),DerivReshapes(1:numSG))
      Call reshape_a(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        if(numvirt_sg(p).ne.0) then
          D1matrix(p)%D1block(numocc_sg(p)+1:numocc_sg(p)+numvirt_sg(p),numocc_sg(p)+1:numocc_sg(p)+numvirt_sg(p)) = matmul(transpose(Reshapes(p)%ReshapedMatrix),Reshapes(p)%ReshapedMatrix) + D1matrix(p)%D1block(numocc_sg(p)+1:numocc_sg(p)+numvirt_sg(p),numocc_sg(p)+1:numocc_sg(p)+numvirt_sg(p))
        end if
      end do
      deallocate(Reshapes,DerivReshapes)
      do p=1,numSG
        i_begin = occ(1,p)
        i_end   = occ(2,p)
        a_begin = virt(1,p)
        a_end   = virt(2,p)
        do i=i_begin,i_end
          do a=a_begin,a_end
          row = a - a_begin + 1 + numocc_sg(p)
          col = i - i_begin + 1
            D1matrix(p)%D1block(row,col) = D1matrix(p)%D1block(row,col) + T1data%a%o(i)%vsym(p)%v(a)*Newc_singles%a%o(i)%vsym(p)%v(a)
            D1matrix(p)%D1block(col,row) = D1matrix(p)%D1block(col,row) + T1data%a%o(i)%vsym(p)%v(a)*Newc_singles%a%o(i)%vsym(p)%v(a)
          end do
        end do
      end do


      allocate(Reshapes(1:numSG),DerivReshapes(1:numSG))
      allocate(TempReshape(1:numSG),TempDerivReshape(1:numSG))
      Call reshape_ajaa_t1(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_ibrow(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      do p=1,numSG
        allocate(TempMat(1,1:numocc_sg(p)*numvirt_sg(p)))
        i_begin = occ(1,p)
        i_end   = occ(2,p)
        a_begin = virt(1,p)
        a_end   = virt(2,p)
        TempMat = matmul4(TempReshape(p)%ReshapedMatrix,Reshapes(p)%ReshapedMatrix)
        pos = 1
        do i=i_begin,i_end
          do a=a_begin,a_end
            row = a - a_begin + 1 + numocc_sg(p)
            col = i - i_begin + 1
            D1matrix(p)%D1block(row,col) = TempMat(1,pos) + D1matrix(p)%D1block(row,col)
            D1matrix(p)%D1block(col,row) = TempMat(1,pos) + D1matrix(p)%D1block(col,row)
            pos = pos + 1
          end do
        end do
        deallocate(TempMat)
      end do

      deallocate(Reshapes,DerivReshapes,TempReshape,TempDerivReshape)
      Call getenv("D1WRT",D1file)
      open(unit=filenumber,file=D1file,action='write')
      NumOccNums = 0
      do p=1,numSG
        write(filenumber,*) numocc_sg(p)+numvirt_sg(p)
        NumOccNums = NumOccNums + numocc_sg(p) + numvirt_sg(p)
      end do
      do p=1,numSG
        do i=1,numocc_sg(p)+numvirt_sg(p)
          do j=1,numocc_sg(p)+numvirt_sg(p)
            write(filenumber,*) D1matrix(p)%D1block(i,j)
          end do
        end do
      end do

       write(*,*) 'BUILDING AND DIAGONALIZING THE 1-RDM...'
       allocate(NatOrbOccNums(1:NumOccNums))
       nval = 1
       NatOrbOccNums(1:NumOccNums) = 0.d0
      do i=1,numSG
        dimD1block = size(D1matrix(i)%D1block,1)
        if(dimD1block.eq.0) then
          cycle
        else
          allocate(UpperDiag(1:dimD1block*(dimD1block+1)/2))
          allocate(EigVal(1:dimD1block))
          allocate(WORK(1:3*dimD1block))
          allocate(EigVec(1:1,1:1))
          allocate(IWORK(1:1))
          UpperDiag(1:dimD1block*(dimD1block+1)/2) = 0.D0
          EigVal(1:dimD1block) = 0.d0
          WORK(1:3*dimD1block) = 0.d0
          IWORK(1:1) = 0
          counter = 1
          do p=1,dimD1block
            do q=1,p
              UpperDiag(counter) = D1matrix(i)%D1block(q,p)
              counter = counter + 1
            end do
          end do
          Call DSPEVD('N','U',dimD1block,UpperDiag,EigVal,EigVec,dimD1block,WORK,3*dimD1block,IWORK,1,INFO)
          do q=1,dimD1block
            NatOrbOccNums(nval) = EigVal(q)
            nval = nval + 1
          end do
          deallocate(UpperDiag,EigVal,WORK,EigVec,IWORK)
        end if
      end do

      do i=1,size(NatOrbOccNums,1)
        do j=i+1,size(NatOrbOccNums,1)
          if(NatOrbOccNums(i).lt.NatOrbOccNums(j)) then
            temp = NatOrbOccNums(j)
            NatOrbOccNums(j) = NatOrbOccNums(i)
            NatOrbOccNums(i) = temp
          end if
        end do
      end do

      write(*,*) 'NATURAL ORBITAL OCCUPATION NUMBERS:'
      write(*,*) '(THE EIGENVALUES OF THE 1-RDM IN THE MO BASIS, EXCLUDING THE CORE ORBITALS)'
      write(*,*) 'ORBITAL #    OCCUPATION #'
      write(*,*) '--------------------------'
      do i=1,size(NatOrbOccNums,1)
        write(*,27) i,NatOrbOccNums(i)
      end do
      write(*,*) '  '
      27 FORMAT(I5,9X,F10.6,1X)
      Call cpu_time(time_end)
      time_buildd1 = time_end - time_begin + time_buildd1
      end subroutine BuildD1

!> @brief Prints T1 and T2 parameters to file
!> @author Christine Schwerdtfeger
       subroutine PrintT2Coefficients(T2data,numOcc,numVirt,InvPdt,numSG,occ,virt,ProductTable,SymO,SymV,T1data,inputfile,numElements)
       USE TypeMod
       USE InterfaceMod
       Use TimeMod, only : time_datastructure
       Implicit NONE

       integer :: numOcc,numVirt,numSG
       integer, intent(IN), allocatable, dimension(:) :: SymV,SymO
       type(symmetry), allocatable, dimension(:) :: InvPdt
       type(T2) :: T2data
       type(T1) :: T1data
       integer, intent(IN), allocatable, dimension(:,:) :: occ,virt
       integer, allocatable, dimension(:,:) :: ProductTable
       character(len=100) :: inputfile
       integer :: numElements

       character(len=100) :: CoeffFile
       integer :: t
       integer :: a,j,i,b,i_begin,i_end,b_begin,b_end,isym,bsym,symtop
       integer :: a_begin, j_begin, a_end, j_end
       integer :: ioerror
       real :: time_begin, time_end
       Call CPU_TIME(time_begin)

       CoeffFile = trim(inputfile) // 'T2'
       open(unit=25,file=CoeffFile,action='write',iostat = ioerror)
       10 format(F20.13)
       write(25,*) numElements
       do j=1,numOcc
         do a=numOcc+1,numOcc+numVirt
           symtop = ProductTable(SymV(a),SymO(j))
            do t=1,numSG
              bsym = InvPdt(symtop)%upper(t)
              isym = InvPdt(symtop)%lower(t)
              b_begin = virt(1,bsym)
              b_end   = virt(2,bsym)
              i_begin = occ(1,isym)
              i_end   = occ(2,isym)
              do i=i_begin,i_end
                do b=b_begin,b_end
                  write(25,10) T2data%aa%m(a,j)%nsym(bsym,isym)%n(b,i)
                end do
              end do
            end do
          end do
        end do
        do j=1,numOcc
          do a=numOcc+1,numOcc+numVirt
            symtop = ProductTable(SymV(a),SymO(j))
             do t=1,numSG
               bsym = InvPdt(symtop)%upper(t)
               isym = InvPdt(symtop)%lower(t)
               b_begin = virt(1,bsym)
               b_end   = virt(2,bsym)
               i_begin = occ(1,isym)
               i_end   = occ(2,isym)
               do i=i_begin,i_end
                 do b=b_begin,b_end
                  write(25,10) T2data%ab%m(a,j)%nsym(bsym,isym)%n(b,i)
                end do
              end do
            end do
          end do
        end do

       do j=1,numOcc
         do a=numOcc+1,numOcc+numVirt
           symtop = ProductTable(SymV(a),SymO(j))
            do t=1,numSG
              bsym = InvPdt(symtop)%upper(t)
              isym = InvPdt(symtop)%lower(t)
              b_begin = virt(1,bsym)
              b_end   = virt(2,bsym)
              i_begin = occ(1,isym)
              i_end   = occ(2,isym)
              do i=i_begin,i_end
                do b=b_begin,b_end
                  write(25,10) T2data%bb%m(a,j)%nsym(bsym,isym)%n(b,i)
                end do
              end do
            end do
          end do
        end do


       do j=1,numOcc
         symtop = SymO(j)
         a_begin = virt(1,symtop)
         a_end   = virt(2,symtop)
         do a=a_begin,a_end
           write(25,10) T1data%a%o(j)%vsym(symtop)%v(a)
         end do
       end do

       do j=1,numOcc
         symtop = SymO(j)
         a_begin = virt(1,symtop)
         a_end   = virt(2,symtop)
         do a=a_begin,a_end
           write(25,10) T1data%b%o(j)%vsym(symtop)%v(a)
         end do
       end do

       close(25)

       Call CPU_TIME(time_end)
       end subroutine PrintT2Coefficients

!> @brief Prints the T1 and T2 parameters for open shell calculations
!> @author Christine Schwerdteger and David Mazziotti
       subroutine PrintT2CoefficientsOS(T2data,numocc_alpha, numocc_beta,numvirt_alpha,numvirt_beta,InvPdt,numSG,occ_alpha, occ_beta,virt_alpha,virt_beta,ProductTable,Sym_alpha,Sym_beta,T1data,inputfile,numElements)
       USE TypeMod
       USE InterfaceMod
       Use TimeMod, only : time_datastructure
       Implicit NONE

       integer :: numocc_alpha,numocc_beta,numvirt_alpha,numvirt_beta,numSG
       integer, intent(IN), allocatable, dimension(:) :: Sym_alpha, Sym_beta
       type(symmetry), allocatable, dimension(:) :: InvPdt
       type(T2) :: T2data
       type(T1) :: T1data
       integer, intent(IN), allocatable, dimension(:,:) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, allocatable, dimension(:,:) :: ProductTable
       character(len=100) :: inputfile
       integer :: numElements

       integer :: t
       integer :: a,j,i,b,i_begin,i_end,b_begin,b_end,isym,bsym,symtop
       integer :: a_begin, j_begin, a_end, j_end
       real :: time_begin, time_end
       integer :: ioerror
       character(len=100) :: CoeffFile
       Call CPU_TIME(time_begin)

       CoeffFile = trim(inputfile) // 'T2'
       open(unit=25,file=CoeffFile,action='write',iostat=ioerror)
       10 format(F20.13)
       write(25,*) numElements
       if(ioerror.eq.0) then
       do j=1,numocc_alpha
        do a=numocc_alpha+1,numocc_alpha+numvirt_alpha
          symtop = ProductTable(Sym_alpha(a),Sym_alpha(j))
          do t=1,numSG
            bsym = InvPdt(symtop)%upper(t)
            isym = InvPdt(symtop)%lower(t)
            b_begin = virt_alpha(1,bsym)
            b_end   = virt_alpha(2,bsym)
            i_begin = occ_alpha(1,isym)
            i_end   = occ_alpha(2,isym)
            do i=i_begin,i_end
              do b=b_begin,b_end
                write(25,10)  T2data%aa%m(a,j)%nsym(bsym,isym)%n(b,i)
              end do
            end do
          end do
        end do
      end do

      do j=1,numocc_alpha
        do a=numocc_alpha+1,numocc_alpha+numvirt_alpha
          symtop = ProductTable(Sym_alpha(a),Sym_alpha(j))
          do t=1,numSG
            bsym = InvPdt(symtop)%upper(t)
            isym = InvPdt(symtop)%lower(t)
            b_begin = virt_beta(1,bsym)
            b_end   = virt_beta(2,bsym)
            i_begin = occ_beta(1,isym)
            i_end   = occ_beta(2,isym)
            do i=i_begin,i_end
              do b=b_begin,b_end
                write(25,10)  T2data%ab%m(a,j)%nsym(bsym,isym)%n(b,i)
              end do
            end do
          end do
        end do
      end do


      do j=1,numocc_beta
        do a=numocc_beta+1,numocc_beta+numvirt_beta
          symtop = ProductTable(Sym_beta(a),Sym_beta(j))
          do t=1,numSG
            bsym = InvPdt(symtop)%upper(t)
            isym = InvPdt(symtop)%lower(t)
            b_begin = virt_beta(1,bsym)
            b_end   = virt_beta(2,bsym)
            i_begin = occ_beta(1,isym)
            i_end   = occ_beta(2,isym)
            do i=i_begin,i_end
              do b=b_begin,b_end
                write(25,10)  T2data%bb%m(a,j)%nsym(bsym,isym)%n(b,i)
              end do
            end do
          end do
        end do
      end do



       do j=1,numocc_alpha
         symtop = Sym_alpha(j)
         a_begin = virt_alpha(1,symtop)
         a_end   = virt_alpha(2,symtop)
         do a=a_begin,a_end
           write(25,10)  T1data%a%o(j)%vsym(symtop)%v(a)
         end do
      end do

       do j=1,numocc_beta
         symtop = Sym_beta(j)
         a_begin = virt_beta(1,symtop)
         a_end   = virt_beta(2,symtop)
         do a=a_begin,a_end
           write(25,10)  T1data%b%o(j)%vsym(symtop)%v(a)
         end do
      end do
     close(25)
      end if



        Call CPU_TIME(time_end)
       end subroutine PrintT2CoefficientsOS

!> @brief Performs matrix multiplication when K2 is written to disk (BlockK2) (only use with intel compiler)
!> @author Christine Schwerdtfeger and David Mazziotti
       function matmul3(rightmatrix,BlockDim,spinblock,currentSGnum,leftmatrixfile,numrowblocks)

       Use TimeMod, only : time_matmul3
       Use TypeMod
       Implicit NONE
       double precision, allocatable, dimension(:,:) :: rightmatrix
       type(BlockMatMulDims) :: BlockDim
       character(len=2) :: spinblock
       integer :: currentSGnum
       integer :: numrowblocks
       character(len=100) :: leftmatrixfile
       double precision, allocatable, dimension(:,:) :: matmul3

       integer :: ioerror
       integer :: i,j,counter
       integer :: numblocks,numcolrightmatrix,lmc,lmr
       integer :: rmr,rmc,m,k,offsetrightmatrix,productoffsetmatrix

       character(len=6) :: tempchar
       character(len=100) :: tempfile
       double precision, allocatable, dimension(:) :: templeft
       real :: time_begin, time_end
       Call cpu_time(time_begin)

        rmc = size(rightmatrix,2)
        rmr = size(rightmatrix,1)
        allocate(matmul3(1:rmr,1:rmc))
        matmul3(1:rmr,1:rmc) = 0.D0

       if(spinblock.eq.'aa') then
         numblocks = size(BlockDim%aa%symgp(currentSGnum)%block,1)
         numcolrightmatrix = size(rightmatrix,2)
         offsetrightmatrix = 1
         productoffsetmatrix = 1
         do m=1,numblocks
           lmr = BlockDim%aa%symgp(currentSGnum)%block(m)%row
           lmc = BlockDim%aa%symgp(currentSGnum)%block(m)%col
           write(tempchar,'(I4)') m
           tempfile = trim(leftmatrixfile) // 'block' // trim(tempchar)
           allocate(templeft(1:lmr*lmc))
           open(unit=m,file=trim(tempfile),form='binary',access='direct',iostat=ioerror,recl=8*lmr*lmc)
           read(m,rec=1) templeft
           close(m)
           if(lmr.ne.0.and.numcolrightmatrix.ne.0.and.lmc.ne.0) then
           Call DGEMM('N','N',lmr,numcolrightmatrix,lmc,1.d0,templeft,lmr,rightmatrix(offsetrightmatrix:offsetrightmatrix-1+lmc,1:numcolrightmatrix),lmc,1.d0,matmul3(productoffsetmatrix:productoffsetmatrix-1+lmr,1:numcolrightmatrix),lmr)
           end if
           if(mod(m,numrowblocks).eq.0) then
             offsetrightmatrix = offsetrightmatrix + lmc
             productoffsetmatrix = 1
           else
             productoffsetmatrix = productoffsetmatrix + lmr
           end if
            deallocate(templeft)
         end do

       else if(spinblock.eq.'ab') then
         numblocks = size(BlockDim%ab%symgp(currentSGnum)%block,1)
         numcolrightmatrix = size(rightmatrix,2)
         offsetrightmatrix = 1
         productoffsetmatrix = 1
         do m=1,numblocks
           lmr = BlockDim%ab%symgp(currentSGnum)%block(m)%row
           lmc = BlockDim%ab%symgp(currentSGnum)%block(m)%col
           write(tempchar,'(I4)') m
           tempfile = trim(leftmatrixfile) // 'block' // trim(tempchar)
           open(unit=m,file=trim(tempfile),form='binary',access='direct',iostat=ioerror,recl=8*lmr*lmc)
           allocate(templeft(1:lmr*lmc))
           read(m,rec=1) templeft
           close(m)
           if(lmr.ne.0.and.numcolrightmatrix.ne.0.and.lmc.ne.0) then
           Call DGEMM('N','N',lmr,numcolrightmatrix,lmc,1.d0,templeft,lmr,rightmatrix(offsetrightmatrix:offsetrightmatrix-1+lmc,1:numcolrightmatrix),lmc,1.d0,matmul3(productoffsetmatrix:productoffsetmatrix-1+lmr,1:numcolrightmatrix),lmr)
           end if
           if(mod(m,numrowblocks).eq.0) then
             offsetrightmatrix = offsetrightmatrix + lmc
             productoffsetmatrix = 1
           else
             productoffsetmatrix = productoffsetmatrix + lmr
           end if
            deallocate(templeft)
         end do



       else if(spinblock.eq.'bb') then
         numblocks = size(BlockDim%bb%symgp(currentSGnum)%block,1)
         numcolrightmatrix = size(rightmatrix,2)
         offsetrightmatrix = 1
         productoffsetmatrix = 1
         do m=1,numblocks
           lmr = BlockDim%bb%symgp(currentSGnum)%block(m)%row
           lmc = BlockDim%bb%symgp(currentSGnum)%block(m)%col
           write(tempchar,'(I4)') m
           tempfile = trim(leftmatrixfile) // 'block' // trim(tempchar)
           allocate(templeft(1:lmr*lmc))
           open(unit=m,file=trim(tempfile),form='binary',access='direct',iostat=ioerror,recl=8*lmr*lmc)
           read(m,rec=1) templeft
           close(m)
           Call DGEMM('N','N',lmr,numcolrightmatrix,lmc,1.d0,templeft,lmr,rightmatrix(offsetrightmatrix:offsetrightmatrix-1+lmc,1:numcolrightmatrix),lmc,1.d0,matmul3(productoffsetmatrix:productoffsetmatrix-1+lmr,1:numcolrightmatrix),lmr)
           if(mod(m,numrowblocks).eq.0) then
             offsetrightmatrix = offsetrightmatrix + lmc
             productoffsetmatrix = 1
           else
             productoffsetmatrix = productoffsetmatrix + lmr
           end if
            deallocate(templeft)
         end do

         else
           write(*,*) 'You did not choose aa  ab   or bb for your spin block'
           stop
         end if

        Call cpu_time(time_end)
        time_matmul3 = time_matmul3 + time_end - time_begin
       end function matmul3



!> @brief Builds K2 and K1 matrices for disk writing feature.  Only works for the intel compiler. 
!> @author Christine Schwerdtfeger and David Mazziotti
      subroutine BuildK2K1BlockK2(occ,virt,numSG,InvPdt,TwoIntsCompact,OneInts,ReshapedMatrixDim,K2,K1,ProductTable,K1TwoInts,numocc,numvirt,TwoInts,numrowblocks,BlockDim,inputfile)
      Use TypeMod
      Use TimeMod, only : time_buildk2k1
      Use InterfaceMod
      Implicit None

      integer, intent(IN), allocatable, dimension(:,:) :: occ, virt
      integer, intent(IN) :: numSG
      type(symmetry), allocatable, dimension(:) :: InvPdt
      real(8), allocatable, dimension(:,:,:,:) :: TwoInts
      real(8), intent(IN), allocatable, dimension(:,:) :: OneInts
      real(8), allocatable, dimension(:) :: TwoIntsCompact
      type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
      type(spin) :: K2(1:2,1:2,1:2,1:2)
      type(spin) :: K1(1:2,1:2)
      integer, dimension(1:numSG,1:numSG) :: ProductTable
      type(spin) :: K1TwoInts(1:2,1:2)
      integer :: numrowblocks
      type(BlockMatMulDims) :: BlockDim
      character(len=100) :: inputfile

      integer :: i,j,k,l,i_begin,i_end,j_begin,j_end,k_begin,k_end,l_begin,l_end
      integer :: symgp, t,v,p,q,r,s
      integer :: row, col,numi,numa,numk
      integer :: a,b,c,d,a_begin,a_end,b_begin,b_end,c_begin,c_end,d_begin,d_end
      integer :: u
      integer :: begindim,enddim,enddim_occ
      real(8) :: test(1:2,1:2)
      real :: time_begin, time_end
      integer :: numocc,numvirt
      type(InverseBasis), allocatable, dimension(:) :: InverseBasisK1
      integer :: counter
      real(8) :: integral
      integer*8 :: index1,index2,compindex1,compindex2
      double precision, allocatable, dimension(:,:) :: K2vvvv
      character(len=100) :: K2vvvvfile
      integer :: totalrows,totalcols,rowsperblock,remainder,m,colsperblock
      integer :: rowoffset,coloffset,counter1,counter2
      integer :: z,iostat
      character(len=4)  :: tempchar
      character(len=100) :: tempfile
      integer*8 :: recordlength, temprow, tempcol,sizeK2r,sizeK2c

      Call cpu_time(time_begin)
      allocate(K2(1,1,1,1)%aa%irrep(1:numSG))
      allocate(K2(1,2,1,2)%aa%irrep(1:numSG))
      allocate(K2(1,1,2,2)%aa%irrep(1:numSG))
      allocate(K2(1,1,1,1)%ab%irrep(1:numSG))
      allocate(K2(1,2,1,2)%ab%irrep(1:numSG))
      allocate(K2(1,1,2,2)%ab%irrep(1:numSG))
      allocate(K2(1,2,2,1)%ab%irrep(1:numSG))
      allocate(K2(1,1,1,2)%aa%irrep(1:numSG))
      allocate(K2(2,2,1,2)%aa%irrep(1:numSG))
      allocate(K2(1,1,1,2)%ab%irrep(1:numSG))
      allocate(K2(1,1,2,1)%ab%irrep(1:numSG))
      allocate(K2(2,2,1,2)%ab%irrep(1:numSG))
      allocate(K2(2,2,2,1)%ab%irrep(1:numSG))
      allocate(K1(1,1)%aa%irrep(1:numSG))
      allocate(K1(2,2)%aa%irrep(1:numSG))
      allocate(K1(1,2)%aa%irrep(1:numSG))
      allocate(K1TwoInts(1,1)%aa%irrep(1:numSG))
      allocate(K1TwoInts(2,2)%aa%irrep(1:numSG))
      allocate(K1TwoInts(1,2)%aa%irrep(1:numSG))
      do i=1,numSG
        allocate(K2(1,1,1,1)%aa%irrep(i)%block(1:ReshapedMatrixDim%ijaa(i)%col,1:ReshapedMatrixDim%ijaa(i)%col))
        allocate(K2(1,2,1,2)%aa%irrep(i)%block(1:ReshapedMatrixDim%ajaa(i)%col,1:ReshapedMatrixDim%ajaa(i)%col))
        allocate(K2(1,1,2,2)%aa%irrep(i)%block(1:ReshapedMatrixDim%ijaa(i)%row,1:ReshapedMatrixDim%ijaa(i)%col))
      end do
       do i=1,numSG
        allocate(K2(1,1,1,1)%ab%irrep(i)%block(1:ReshapedMatrixDim%ijab(i)%col,1:ReshapedMatrixDim%ijab(i)%col))
        allocate(K2(1,2,1,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%ajab(i)%col,1:ReshapedMatrixDim%ajab(i)%col))
        allocate(K2(1,1,2,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%ijab(i)%row,1:ReshapedMatrixDim%ijab(i)%col))
        allocate(K2(1,2,2,1)%ab%irrep(i)%block(1:ReshapedMatrixDim%ajaa_only(i)%row,1:ReshapedMatrixDim%ajaa_only(i)%col))
        numi = (occ(2,i) - occ(1,i)) + 1
        numa = (virt(2,i) - virt(1,i)) + 1
        allocate(K2(1,1,1,2)%aa%irrep(i)%block(1:ReshapedMatrixDim%jka_aaa(i)%col,1:numi))
        allocate(K2(2,2,1,2)%aa%irrep(i)%block(1:ReshapedMatrixDim%bci_aaa(i)%col,1:numa))
        allocate(K2(1,1,1,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%jka_abb(i)%col,1:numi))
        allocate(K2(1,1,2,1)%ab%irrep(i)%block(1:ReshapedMatrixDim%jka_aba(i)%col,1:numi))
        allocate(K2(2,2,1,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%bci_aba(i)%col,1:numa))
        allocate(K2(2,2,2,1)%ab%irrep(i)%block(1:ReshapedMatrixDim%bci_abb(i)%col,1:numa))
      end do

       do t=1,numSG
         i_begin = occ(1,t)
         i_end   = occ(2,t)
         a_begin = virt(1,t)
         a_end   = virt(2,t)
         numa = a_end - a_begin + 1
         numi = i_end - i_begin + 1
         allocate(K1(1,1)%aa%irrep(t)%block(i_begin:i_end,i_begin:i_end))
         allocate(K1(2,2)%aa%irrep(t)%block(a_begin:a_end,a_begin:a_end))
         allocate(K1(1,2)%aa%irrep(t)%block(1:numi*numa,1:1))
         allocate(K1TwoInts(1,1)%aa%irrep(t)%block(i_begin:i_end,i_begin:i_end))
         allocate(K1TwoInts(2,2)%aa%irrep(t)%block(a_begin:a_end,a_begin:a_end))
         allocate(K1TwoInts(1,2)%aa%irrep(t)%block(1:numa*numi,1:1))
         K1(1,1)%aa%irrep(t)%block(i_begin:i_end,i_begin:i_end) = 0.0D0
         K1(2,2)%aa%irrep(t)%block(a_begin:a_end,a_begin:a_end) = 0.0D0
         K1(1,2)%aa%irrep(t)%block(1:numa*numi,1:1) = 0.0D0
         K1TwoInts(1,1)%aa%irrep(t)%block(i_begin:i_end,i_begin:i_end) = 0.0D0
         K1TwoInts(2,2)%aa%irrep(t)%block(a_begin:a_end,a_begin:a_end) = 0.0D0
         K1TwoInts(1,2)%aa%irrep(t)%block(1:numa*numi,1:1) = 0.0D0
      end do

       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) cycle
                 k_begin = occ(1,r)
                 k_end   = occ(2,r)
                 l_begin = occ(1,s)
                 l_end   = occ(2,s)
                 do k=k_begin,k_end
                   do l=max(k+1,l_begin),l_end
                     index1 = FirstIndex(i,k)
                     index2 = FirstIndex(j,l)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(i,l)
                     index2 = FirstIndex(j,k)
                     compindex2 = CompositeIndex(index1,index2)
                     K2(1,1,1,1)%aa%irrep(symgp)%block(row,col) = (TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2))
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do


       allocate(BlockDim%aa%symgp(1:numSG))
       do symgp=1,numSG
         allocate(BlockDim%aa%symgp(symgp)%block(1:numrowblocks*numrowblocks))
         do counter1=1,numrowblocks*numrowblocks
           BlockDim%aa%symgp(symgp)%block(counter1)%row = 0
           BlockDim%aa%symgp(symgp)%block(counter1)%col = 0
         end do
       end do





       do symgp=1,numSG
         totalrows = ReshapedMatrixDim%ijaa(symgp)%row
         totalcols = ReshapedMatrixDim%ijaa(symgp)%row
         if(totalrows.eq.0) cycle
         rowsperblock = totalrows/numrowblocks
         colsperblock = totalcols/numrowblocks
         remainder = totalrows - rowsperblock*numrowblocks
         do p=1,numrowblocks
           do q=1,numrowblocks
             if(p.ne.numrowblocks.and.q.ne.numrowblocks) then
               BlockDim%aa%symgp(symgp)%block(q+(p-1)*numrowblocks)%row = rowsperblock
               BlockDim%aa%symgp(symgp)%block(q+(p-1)*numrowblocks)%col = colsperblock
             else if(p.eq.numrowblocks.and.q.ne.numrowblocks) then
               BlockDim%aa%symgp(symgp)%block(q+(p-1)*numrowblocks)%row = rowsperblock
               BlockDim%aa%symgp(symgp)%block(q+(p-1)*numrowblocks)%col = colsperblock + remainder
             else if(p.ne.numrowblocks.and.q.eq.numrowblocks) then
               BlockDim%aa%symgp(symgp)%block(q+(p-1)*numrowblocks)%row = rowsperblock + remainder
               BlockDim%aa%symgp(symgp)%block(q+(p-1)*numrowblocks)%col = colsperblock
             else
               BlockDim%aa%symgp(symgp)%block(q+(p-1)*numrowblocks)%row = rowsperblock + remainder
               BlockDim%aa%symgp(symgp)%block(q+(p-1)*numrowblocks)%col = colsperblock + remainder
             end if
           end do
         end do
       end do





       do symgp=1,numSG
         write(tempchar,'(I1)') symgp
         K2vvvvfile = trim(inputfile) // 'aaSG' // trim(tempchar)
         do z=1,numrowblocks*numrowblocks
           write(tempchar,'(I4)') z
           tempfile = trim(K2vvvvfile) // 'block' // trim(tempchar)
           temprow = BlockDim%aa%symgp(symgp)%block(z)%row
           tempcol = BlockDim%aa%symgp(symgp)%block(z)%col
           recordlength = temprow*tempcol
           recordlength = 8*recordlength
           open(unit=z,file=tempfile,form='binary',action='write',access='direct',IOSTAT = iostat,recl=recordlength)
         end do
         rowoffset = 1
         coloffset = 1
         do m=1,numrowblocks*numrowblocks
           if(m.gt.1) then
             if(mod(m-1,numrowblocks).eq.0) then
               rowoffset = 1
               coloffset = coloffset + BlockDim%aa%symgp(symgp)%block(m-1)%col
             else
               rowoffset = rowoffset + BlockDim%aa%symgp(symgp)%block(m-1)%row
             end if
           end if
           if(BlockDim%aa%symgp(symgp)%block(m)%row.eq.0.or.BlockDim%aa%symgp(symgp)%block(m)%col.eq.0) cycle
           allocate(K2vvvv(1:BlockDim%aa%symgp(symgp)%block(m)%row,1:BlockDim%aa%symgp(symgp)%block(m)%col))

         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           b_begin = virt(1,q)
           b_end   = virt(2,q)
           do a=a_begin,a_end
             do b=max(a+1,b_begin),b_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) cycle
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 d_begin = virt(1,s)
                 d_end   = virt(2,s)
                 do c=c_begin,c_end
                   do d=max(c+1,d_begin),d_end
                     if(row.ge.rowoffset.and.row.le.rowoffset-1+BlockDim%aa%symgp(symgp)%block(m)%row.and.col.ge.coloffset.and.col.le.coloffset-1+BlockDim%aa%symgp(symgp)%block(m)%col) then
                       index1 = FirstIndex(a,c)
                       index2 = FirstIndex(b,d)
                       compindex1 = CompositeIndex(index1,index2)
                       index1 = FirstIndex(a,d)
                       index2 = FirstIndex(b,c)
                       compindex2 = CompositeIndex(index1,index2)
                        K2vvvv(row-rowoffset+1,col-coloffset+1) = (TwoIntsCompact(compindex1)- TwoIntsCompact(compindex2))
                     end if
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
         write(m,rec=1) K2vvvv
         close(m)
         deallocate(K2vvvv)
        end do
       end do

       do symgp = 1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) cycle
                 a_begin = virt(1,r)
                 a_end   = virt(2,r)
                 b_begin = virt(1,s)
                 b_end   = virt(2,s)
                 do a=a_begin,a_end
                   do b=max(a+1,b_begin),b_end
                     index1 = FirstIndex(i,a)
                     index2 = FirstIndex(j,b)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(i,b)
                     index2 = FirstIndex(j,a)
                     compindex2 = CompositeIndex(index1,index2)
                      K2(1,1,2,2)%aa%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)- TwoIntsCompact(compindex2)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt(1,r)
                 b_end   = virt(2,r)
                 i_begin = occ(1,s)
                 i_end   = occ(2,s)
                 do i=i_begin,i_end
                   do b=b_begin,b_end
                      index1 = FirstIndex(i,j)
                      index2 = FirstIndex(a,b)
                      compindex1 = CompositeIndex(index1,index2)
                      index1 = FirstIndex(i,b)
                      index2 = FirstIndex(a,j)
                      compindex2 = CompositeIndex(index1,index2)
                      K2(1,2,1,2)%aa%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)-TwoIntsCompact(compindex2)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 k_begin = occ(1,r)
                 k_end   = occ(2,r)
                 l_begin = occ(1,s)
                 l_end   = occ(2,s)
                 do k=k_begin,k_end
                   do l=l_begin,l_end
                     index1 = FirstIndex(i,k)
                     index2 = FirstIndex(j,l)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(1,1,1,1)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do



       allocate(BlockDim%ab%symgp(1:numSG))
       do symgp=1,numSG
         allocate(BlockDim%ab%symgp(symgp)%block(1:numrowblocks*numrowblocks))
         do counter1=1,numrowblocks*numrowblocks
           BlockDim%ab%symgp(symgp)%block(counter1)%row = 0
           BlockDim%ab%symgp(symgp)%block(counter1)%col = 0
         end do
       end do

       do symgp=1,numSG
         totalrows = ReshapedMatrixDim%ijab(symgp)%row
         totalcols = ReshapedMatrixDim%ijab(symgp)%row
         if(totalrows.eq.0) cycle
         rowsperblock = totalrows/numrowblocks
         colsperblock = totalcols/numrowblocks
         remainder = totalrows - rowsperblock*numrowblocks
         do p=1,numrowblocks
           do q=1,numrowblocks
             if(p.ne.numrowblocks.and.q.ne.numrowblocks) then
               BlockDim%ab%symgp(symgp)%block(q+(p-1)*numrowblocks)%row = rowsperblock
               BlockDim%ab%symgp(symgp)%block(q+(p-1)*numrowblocks)%col = colsperblock
             else if(p.eq.numrowblocks.and.q.ne.numrowblocks) then
               BlockDim%ab%symgp(symgp)%block(q+(p-1)*numrowblocks)%row = rowsperblock
               BlockDim%ab%symgp(symgp)%block(q+(p-1)*numrowblocks)%col = colsperblock + remainder
             else if(p.ne.numrowblocks.and.q.eq.numrowblocks) then
               BlockDim%ab%symgp(symgp)%block(q+(p-1)*numrowblocks)%row = rowsperblock + remainder
               BlockDim%ab%symgp(symgp)%block(q+(p-1)*numrowblocks)%col = colsperblock
             else
               BlockDim%ab%symgp(symgp)%block(q+(p-1)*numrowblocks)%row = rowsperblock + remainder
               BlockDim%ab%symgp(symgp)%block(q+(p-1)*numrowblocks)%col = colsperblock + remainder
             end if
           end do
         end do
       end do

       do symgp=1,numSG
         write(tempchar,'(I1)') symgp
         K2vvvvfile = trim(inputfile) // 'abSG' // trim(tempchar)
         rowoffset = 1
         coloffset = 1
         do m=1,numrowblocks*numrowblocks
           write(tempchar,'(I4)') m
           tempfile = trim(K2vvvvfile) // 'block' // trim(tempchar)
           temprow = BlockDim%ab%symgp(symgp)%block(m)%row
           tempcol = BlockDim%ab%symgp(symgp)%block(m)%col
           recordlength = 8*temprow*tempcol
           open(unit=m,file=tempfile,form='binary',action='write',access='direct',IOSTAT= iostat,recl=recordlength)
           if(m.gt.1) then
             if(mod(m-1,numrowblocks).eq.0) then
               rowoffset = 1
               coloffset = coloffset + BlockDim%ab%symgp(symgp)%block(m-1)%col
             else
               rowoffset = rowoffset + BlockDim%ab%symgp(symgp)%block(m-1)%row
             end if
           end if
           if(BlockDim%ab%symgp(symgp)%block(m)%row.eq.0.or.BlockDim%ab%symgp(symgp)%block(m)%col.eq.0) cycle
           allocate(K2vvvv(1:BlockDim%ab%symgp(symgp)%block(m)%row,1:BlockDim%ab%symgp(symgp)%block(m)%col))
           col = 0
           do t=1,numSG
             p = InvPdt(symgp)%upper(t)
             q = InvPdt(symgp)%lower(t)
             a_begin = virt(1,p)
             a_end   = virt(2,p)
             b_begin = virt(1,q)
             b_end   = virt(2,q)
             do a=a_begin,a_end
               do b=b_begin,b_end
                 col = col + 1
                 row = 1
                 do v=1,numSG
                   r = InvPdt(symgp)%upper(v)
                   s = InvPdt(symgp)%lower(v)
                   c_begin = virt(1,r)
                   c_end   = virt(2,r)
                   d_begin = virt(1,s)
                   d_end   = virt(2,s)
                   do c=c_begin,c_end
                     do d=d_begin,d_end
                      if(row.ge.rowoffset.and.row.le.rowoffset-1+BlockDim%ab%symgp(symgp)%block(m)%row.and.col.ge.coloffset.and.col.le.coloffset-1+BlockDim%ab%symgp(symgp)%block(m)%col) then
                        index1 = FirstIndex(a,c)
                        index2 = FirstIndex(b,d)
                        compindex1 = CompositeIndex(index1,index2)
                        K2vvvv(row-rowoffset+1,col-coloffset+1) = TwoIntsCompact(compindex1)
                      end if
                      row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
          write(m,rec=1) K2vvvv
          close(m)
          deallocate(K2vvvv)
        end do
      end do

       do symgp = 1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 a_begin = virt(1,r)
                 a_end   = virt(2,r)
                 b_begin = virt(1,s)
                 b_end   = virt(2,s)
                 do a=a_begin,a_end
                   do b=b_begin,b_end
                     index1 = FirstIndex(i,a)
                     index2 = FirstIndex(j,b)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(1,1,2,2)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do a=a_begin,a_end
             do j=j_begin,j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt(1,r)
                 b_end   = virt(2,r)
                 i_begin = occ(1,s)
                 i_end   = occ(2,s)
                 do b=b_begin,b_end
                   do i=i_begin,i_end
                     index1 = FirstIndex(i,j)
                     index2 = FirstIndex(a,b)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(1,2,1,2)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = 0
           do t=1,numSG
              p = InvPdt(symgp)%upper(t)
              q = InvPdt(symgp)%lower(t)
              a_begin = virt(1,p)
              a_end   = virt(2,p)
              j_begin = occ(1,q)
              j_end   = occ(2,q)
              do j=j_begin,j_end
                do a=a_begin,a_end
                  col = col + 1
                  row = 1
                  do v=1,numSG
                     r = InvPdt(symgp)%upper(v)
                     s = InvPdt(symgp)%lower(v)
                     b_begin = virt(1,r)
                     b_end   = virt(2,r)
                     i_begin = occ(1,s)
                     i_end   = occ(2,s)
                     do i=i_begin,i_end
                       do b=b_begin,b_end
                         index1 = FirstIndex(a,j)
                         index2 = FirstIndex(i,b)
                         compindex1 = CompositeIndex(index1,index2)
                          K2(1,2,2,1)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)

                         row = row + 1
                       end do
                    end do
                  end do
                end do
              end do
           end do
        end do
       do symgp=1,numSG
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         j_begin = occ(1,symgp)
         j_end   = occ(2,symgp)
         do i=i_begin,i_end
           do j=j_begin,j_end
             K1(1,1)%aa%irrep(symgp)%block(i,j) = OneInts(i,j)
             K1(1,1)%aa%irrep(symgp)%block(j,i) = OneInts(j,i)
           end do
         end do
       end do

       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) continue
                 k_begin = occ(1,r)
                 k_end   = occ(2,r)
                 l_begin = occ(1,s)
                 l_end   = occ(2,s)
                 do k=k_begin,k_end
                   do l=max(k+1,l_begin),l_end
                       index1 = FirstIndex(i,k)
                       index2 = FirstIndex(j,l)
                       compindex1 = CompositeIndex(index1,index2)
                       index1 = FirstIndex(i,l)
                       index2 = FirstIndex(j,k)
                       compindex2 = CompositeIndex(index1,index2)
                     if(j==l.and.ProductTable(p,r)==1) then
                        K1TwoInts(1,1)%aa%irrep(p)%block(i,k) = 2*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%aa%irrep(p)%block(i,k)
                       if(i.ne.k) then
                       end if
                     end if
                     if(i==l.and.ProductTable(q,r)==1) then
                        K1TwoInts(1,1)%aa%irrep(q)%block(j,k) = 2*-1*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%aa%irrep(q)%block(j,k)

                       if(k.ne.j) then
                       end if
                     end if
                     if(j==k.and.ProductTable(p,s)==1) then
                       K1TwoInts(1,1)%aa%irrep(p)%block(i,l) = 2*-1*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%aa%irrep(p)%block(i,l)

                       if(l.ne.i) then
                       end if
                     end if
                     if(i==k.and.ProductTable(q,s)==1) then
                        K1TwoInts(1,1)%aa%irrep(q)%block(j,l) = 2*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%aa%irrep(q)%block(j,l)
                      if(l.ne.j) then
                      end if
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 k_begin = occ(1,r)
                 k_end   = occ(2,r)
                 l_begin = occ(1,s)
                 l_end   = occ(2,s)
                 do k=k_begin,k_end
                   do l=l_begin,l_end
                     index1 = FirstIndex(i,k)
                     index2 = FirstIndex(j,l)
                     compindex1 = CompositeIndex(index1,index2)
                     if(j==l.and.ProductTable(p,r)==1) then
                        K1TwoInts(1,1)%aa%irrep(p)%block(i,k) = TwoIntsCompact(compindex1) + K1TwoInts(1,1)%aa%irrep(p)%block(i,k)

                       if(k.ne.i) then
                       end if
                     end if
                     if(i==k.and.ProductTable(q,s)==1) then
                       K1TwoInts(1,1)%aa%irrep(q)%block(j,l) = TwoIntsCompact(compindex1) + K1TwoInts(1,1)%aa%irrep(q)%block(j,l)
                       if(l.ne.j) then
                       end if
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do



       do symgp=1,numSG
         a_begin = virt(1,symgp)
         a_end   = virt(2,symgp)
         b_begin = virt(1,symgp)
         b_end   = virt(2,symgp)
         do a=a_begin,a_end
           do b=b_begin,b_end
             K1(2,2)%aa%irrep(symgp)%block(a,b) = OneInts(a,b)
             K1(2,2)%aa%irrep(symgp)%block(b,a) = OneInts(b,a)
           end do
         end do
       end do

      do symgp=1,numSG
        a_begin = virt(1,symgp)
        a_end   = virt(2,symgp)
        i_begin = occ(1,symgp)
        i_end   = occ(2,symgp)
        row = 1
        col = 1
        do i=i_begin,i_end
          do a=a_begin,a_end
            K1(1,2)%aa%irrep(symgp)%block(row,col) = OneInts(i,a)
            row = row + 1
          end do
        end do
      end do


       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do a=a_begin,a_end
             do j=j_begin,j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt(1,r)
                 b_end   = virt(2,r)
                 i_begin = occ(1,s)
                 i_end   = occ(2,s)
                 do b=b_begin,b_end
                   do i=i_begin,i_end
                     if(i==j.and.ProductTable(p,r)==1) then
                       index1 = FirstIndex(i,j)
                       index2 = FirstIndex(a,b)
                       compindex1 = CompositeIndex(index1,index2)
                       index1 = FirstIndex(i,b)
                       index2 = FirstIndex(a,j)
                       compindex2 = CompositeIndex(index1,index2)
                        K1TwoInts(2,2)%aa%irrep(p)%block(a,b) = 2*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(2,2)%aa%irrep(p)%block(a,b)
                       K1TwoInts(2,2)%aa%irrep(p)%block(a,b) = 2*TwoIntsCompact(compindex1) + K1TwoInts(2,2)%aa%irrep(p)%block(a,b)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
          col = 1
          row = 0
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                    row = row + 1
                    col = 1
                   do i=i_begin,i_end
                     index1 = FirstIndex(j,i)
                     index2 = FirstIndex(k,a)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(j,a)
                     index2 = FirstIndex(k,i)
                     compindex2 = CompositeIndex(index1,index2)
                     K2(1,1,1,2)%aa%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
          col = 1
          row = 0
         a_begin = virt(1,symgp)
         a_end   = virt(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=max(c_begin,b+1),c_end
                    row = row + 1
                    col = 1
                   do a=a_begin,a_end
                     index1 = FirstIndex(b,i)
                     index2 = FirstIndex(c,a)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(b,a)
                     index2 = FirstIndex(c,i)
                     compindex2 = CompositeIndex(index1,index2)
                     K2(2,2,1,2)%aa%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)
                    col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
          row = 0
          col = 1
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do k=k_begin,k_end
                 do a=a_begin,a_end
                   col = 1
                   row = row + 1
                   do i=i_begin,i_end
                     index1 = FirstIndex(j,i)
                     index2 = FirstIndex(k,a)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(1,1,1,2)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)

                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
          row = 0
          col = 1
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=k_begin,k_end
                    row = row + 1
                    col = 1
                   do i=i_begin,i_end
                     index1 = FirstIndex(j,a)
                     index2 = FirstIndex(k,i)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(1,1,2,1)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                     col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
          row = 0
          col = 1
         a_begin = virt(1,symgp)
         a_end   = virt(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=c_begin,c_end
                    col = 1
                    row = row + 1
                   do a=a_begin,a_end
                     index1 = FirstIndex(b,i)
                     index2 = FirstIndex(c,a)
                     compindex1 = CompositeIndex(index1,index2)
                     K2(2,2,1,2)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
          row = 0
          col = 1
         a_begin = virt(1,symgp)
         a_end   = virt(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             do b=b_begin,b_end
               do i=i_begin,i_end
                 do c=c_begin,c_end
                    col = 1
                    row = row + 1
                   do a=a_begin,a_end
                     index1 = FirstIndex(b,a)
                     index2 = FirstIndex(c,i)
                     compindex1 = CompositeIndex(index1,index2)
                     K2(2,2,2,1)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
allocate(InverseBasisK1(1:numSG))
do symgp=1,numSG
  counter = 1
  i_begin = occ(1,symgp)
  i_end   = occ(2,symgp)
  a_begin = virt(1,symgp)
  a_end   = virt(2,symgp)
  allocate(InverseBasisK1(symgp)%basis(i_begin:i_end,a_begin:a_end))
  do i=i_begin,i_end
    do a=a_begin,a_end
      InverseBasisK1(symgp)%basis(i,a) = counter
      counter = counter + 1
    end do
  end do
end do



       do symgp=1,numSG
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         numi = i_end - i_begin + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           numk = k_end - k_begin + 1
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                   do i=i_begin,i_end
                     index1 = FirstIndex(i,j)
                     index2 = FirstIndex(a,k)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(i,k)
                     index2 = FirstIndex(a,j)
                     compindex2 = CompositeIndex(index1,index2)
                     if(i.eq.j.and.ProductTable(r,q).eq.1) then
                        K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(k,a),1) = 2*2*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(k,a),1)

                     end if
                     if(i.eq.k.and.ProductTable(s,r).eq.1) then
                       K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(j,a),1) =-2*2*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(j,a),1)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do


       do symgp=1,numSG
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do k=k_begin,k_end
                 do a=a_begin,a_end
                   do i=i_begin,i_end
                     if(i.eq.j.and.ProductTable(q,r).eq.1) then
                       index1 = FirstIndex(j,i)
                       index2 = FirstIndex(k,a)
                       compindex1 = CompositeIndex(index1,index2)
                        K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(k,a),1) =2*TwoIntsCompact(compindex1) + K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(k,a),1)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=k_begin,k_end
                   do i=i_begin,i_end
                     if(i.eq.k.and.ProductTable(r,s).eq.1) then
                       index1 = FirstIndex(j,a)
                       index2 = FirstIndex(k,i)
                       compindex1 = CompositeIndex(index1,index2)
                       K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(j,a),1) = 2*TwoIntsCompact(compindex1) + K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1(r)%basis(j,a),1)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
         allocate(TwoInts(1:numocc,1:numocc,numocc+1:numvirt+numocc,numocc+1:numvirt+numocc))
         TwoInts(1:numocc,1:numocc,numocc+1:numocc+numvirt,numocc+1:numocc+numvirt) = 0.0
         do i=1,numocc
           do j=1,numocc
             do a=numocc+1,numocc+numvirt
               do b=numocc+1,numocc+numvirt
                 index1 = FirstIndex(i,a)
                 index2 = FirstIndex(j,b)
                 compindex1 = CompositeIndex(index1,index2)
                 integral = TwoIntsCompact(compindex1)
                 TwoInts(i,j,a,b) = integral
                 TwoInts(j,i,b,a) = integral
               end do
             end do
           end do
        end do
        deallocate(TwoIntsCompact)

Call cpu_time(time_end)
   time_buildk2k1 = time_buildk2k1 + time_end - time_begin

       end subroutine BuildK2K1BlockK2

!> @brief Calculates the derivative when K2 is written to disk
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine CalcDerivBlockK2(T2data,K2,K1,numSG,ProductTable,numOcc,numVirt,occ,virt,ReshapedMatrixDim,InvPdt,T2deriv, energy,K1TwoInts,T1data,T1deriv,Newc,DerivNewc,topfac,TwoInts,topsingles,numrowblocks,inputfile,BlockDim)
       Use InterfaceMod
       Use TypeMod
       Use TimeMod
       Implicit None

       type(T2) :: T2data
       type(T1) :: T1data,T1deriv
       type(T2) :: Newc,DerivNewc
       type(spin) :: K2(1:2,1:2,1:2,1:2)
       type(spin) :: K1(1:2,1:2),K1TwoInts(1:2,1:2)
       integer :: numSG,numOcc,numVirt
       integer, intent(IN), dimension(1:numSG,1:numSG) :: ProductTable
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN) :: InvPdt(1:numSG)
       integer, intent(IN), dimension(1:2,1:numSG) :: occ,virt
       integer :: p, i_begin,i_end,j_begin,j_end,k_begin,k_end, l_begin,l_end,i,j,k,l,q,r,s,t,v,row,col,symgp
       integer :: c_begin,c_end,a_begin,a_end,c,a
       integer :: numrowblocks
       type(BlockMatMulDims) :: BlockDim
       character(len=35) :: inputfile
       type(ReshapedMat), allocatable, dimension(:)  :: DerivReshapes, Reshapes, TopReshape,DerivTopReshape
       type(T2) :: T2deriv
       real(8) :: energy
       real(8) :: tempenergy=0.0D0
       integer :: temprow, tempcol
       real(8), dimension(0:2,0:2) :: topfac
       real(8), intent(IN), allocatable, dimension(:,:,:,:) :: TwoInts
       real(8), dimension(0:1,0:1) :: topsingles(0:1,0:1)


       type(ReshapedMat), allocatable, dimension(:) :: TempReshape,TempDerivReshape
       real(8), allocatable, dimension(:,:) :: temp
       integer :: test = 0
       integer :: flag
       integer :: time_initial(8),time_final(8)
       real :: time_begin, time_end
       real :: time_total_begin, time_total_end
       integer :: testdim
       integer :: numa,numi
       character(len=100) :: K2filename
       character(len=1) :: tempchar

       Call cpu_time(time_total_begin)

        energy = 0.0D0
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ijaa_test(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,1,1)%aa%irrep(p)%block)
       end do


         do p=1,numSG
           write(tempchar,'(I1)') p
           K2filename = trim(inputfile) // 'aaSG' // trim(tempchar)
           DerivReshapes(p)%ReshapedMatrix = 2*2*matmul3(Reshapes(p)%ReshapedMatrix,BlockDim,'aa',p,K2filename,numrowblocks) + DerivReshapes(p)%ReshapedMatrix
        end do
       Call reshape_ijaa_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
deallocate(DerivReshapes)
allocate(DerivReshapes(1:numSG))
allocate(TopReshape(1:numSG))
       Call TopFactor(TwoInts,T2data,occ,virt,numSG,topfac,Newc,InvPdt,ProductTable,DerivNewc,numOcc,numVirt,T1data,T1deriv,topsingles)
       Call reshape_ijaa_test(numSG,ProductTable,TopReshape,numOcc,numVirt,occ,virt,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         do s=1,ReshapedMatrixDim%ijaa(p)%col
           do q=1,ReshapedMatrixDim%ijaa(p)%row
             energy = energy + Reshapes(p)%ReshapedMatrix(q,s)*2*2*K2(1,1,2,2)%aa%irrep(p)%block(q,s)*TopReshape(p)%ReshapedMatrix(q,s)
             tempenergy = tempenergy + Reshapes(p)%ReshapedMatrix(q,s)*2*2*K2(1,1,2,2)%aa%irrep(p)%block(q,s)*TopReshape(p)%ReshapedMatrix(q,s)
           end do
         end do
       end do
       deallocate(TopReshape)
       deallocate(Reshapes)
       deallocate(DerivReshapes)
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ajaa(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,2,1,2)%aa%irrep(p)%block)
       end do
       Call reshape_ajaa_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)

        deallocate(Reshapes)
        deallocate(DerivReshapes)
        allocate(Reshapes(1:numSG))
        allocate(DerivReshapes(1:numSG))
       Call reshape_ijab_test(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       tempenergy = 0
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,1,1)%ab%irrep(p)%block)
       end do


       do p=1,numSG
         write(tempchar,'(I1)') p
         K2filename = trim(inputfile) // 'abSG' // trim(tempchar)

         DerivReshapes(p)%ReshapedMatrix = 2*matmul3(Reshapes(p)%ReshapedMatrix,BlockDim,'ab',p,K2filename,numrowblocks) + DerivReshapes(p)%ReshapedMatrix
       end do

       Call reshape_ijab_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
deallocate(DerivReshapes)
allocate(TopReshape(1:numSG))
allocate(DerivReshapes(1:numSG))
       Call reshape_ijab_test(numSG,ProductTable,TopReshape,numOcc,numVirt,occ,virt,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         do q=1,ReshapedMatrixDim%ijab(p)%col
           do s=1,ReshapedMatrixDim%ijab(p)%row
             energy = energy + Reshapes(p)%ReshapedMatrix(s,q)*2*K2(1,1,2,2)%ab%irrep(p)%block(s,q)*TopReshape(p)%ReshapedMatrix(s,q)
             tempenergy = tempenergy + Reshapes(p)%ReshapedMatrix(s,q)*2*K2(1,1,2,2)%ab%irrep(p)%block(s,q)*TopReshape(p)%ReshapedMatrix(s,q)
           end do
         end do
      end do
       deallocate(TopReshape)
       deallocate(Reshapes)
       deallocate(DerivReshapes)
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ajab(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,2,1,2)%ab%irrep(p)%block)
      end do
       Call reshape_ajab_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)

       deallocate(Reshapes)
       deallocate(DerivReshapes)
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ajba(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,2,1,2)%ab%irrep(p)%block)
       end do
       Call reshape_ajba_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       deallocate(Reshapes)
       deallocate(DerivReshapes)
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_i(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*2*matmul4(Reshapes(p)%ReshapedMatrix,K1(1,1)%aa%irrep(p)%block)
       end do

       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix =-1*2*matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(1,1)%aa%irrep(p)%block) + DerivReshapes(p)%ReshapedMatrix
      end do
      Call reshape_i_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
      deallocate(Reshapes)
      deallocate(DerivReshapes)
      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
      Call reshape_a(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*2*matmul4(Reshapes(p)%ReshapedMatrix,K1(2,2)%aa%irrep(p)%block)
      end do
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(2,2)%aa%irrep(p)%block) + DerivReshapes(p)%ReshapedMatrix
     end do
      Call reshape_a_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)

      deallocate(Reshapes)
      deallocate(DerivReshapes)

       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           a_begin = virt(1,p);
           a_end   = virt(2,p);
           j_begin = occ(1,q);
           j_end   = occ(2,q);
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 k_begin = occ(1,s)
                 k_end   = occ(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     energy = energy + 0.5*T2data%aa%m(a,j)%nsym(r,s)%n(c,k)*T2deriv%aa%m(a,j)%nsym(r,s)%n(c,k)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           a_begin = virt(1,p);
           a_end   = virt(2,p);
           j_begin = occ(1,q);
           j_end   = occ(2,q);
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt(1,r)
                 c_end   = virt(2,r)
                 k_begin = occ(1,s)
                 k_end   = occ(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     energy = energy + 0.5*T2data%ab%m(a,j)%nsym(r,s)%n(c,k)*T2deriv%ab%m(a,j)%nsym(r,s)%n(c,k)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       allocate(DerivReshapes(1:numSG))
       allocate(TopReshape(1:numSG))
       allocate(DerivTopReshape(1:numSG))
       Call reshape_ijaa_test(numSG,ProductTable,TopReshape,numOcc,numVirt,occ,virt,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)
       deallocate(DerivReshapes)
       allocate(DerivReshapes(1:numSG))
       Call reshape_ijaa_test(numSG,ProductTable,DerivTopReshape,numOcc,numVirt,occ,virt,DerivNewc,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         do q=1,ReshapedMatrixDim%ijaa(p)%col
           do s=1,ReshapedMatrixDim%ijaa(p)%row
             DerivReshapes(p)%ReshapedMatrix(s,q) = 2*2*(K2(1,1,2,2)%aa%irrep(p)%block(s,q)*TopReshape(p)%ReshapedMatrix(s,q) + DerivTopReshape(p)%ReshapedMatrix(s,q))
            end do
         end do
       end do

       Call reshape_ijaa_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
      deallocate(DerivReshapes)
      deallocate(TopReshape)
      deallocate(DerivTopReshape)
      allocate(DerivReshapes(1:numSG))
      allocate(TopReshape(1:numSG))
      allocate(DerivTopReshape(1:numSG))
       Call reshape_ijab_test(numSG,ProductTable,TopReshape,numOcc,numVirt,occ,virt,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)
       deallocate(DerivReshapes)
       allocate(DerivReshapes(1:numSG))
       Call reshape_ijab_test(numSG,ProductTable,DerivTopReshape,numOcc,numVirt,occ,virt,DerivNewc,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        do q=1,ReshapedMatrixDim%ijab(p)%col
          do s=1,ReshapedMatrixDim%ijab(p)%row
         DerivReshapes(p)%ReshapedMatrix(s,q) = 2*(K2(1,1,2,2)%ab%irrep(p)%block(s,q)*TopReshape(p)%ReshapedMatrix(s,q) + DerivTopReshape(p)%ReshapedMatrix(s,q))
          end do
      end do
      end do
      Call reshape_ijab_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
      deallocate(DerivReshapes)
      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
      allocate(TempReshape(1:numSG))
      allocate(TempDerivReshape(1:numSG))

      Call reshape_ajaa_transpose(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_ajbb(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
       do p=1,numSG
          DerivReshapes(p)%ReshapedMatrix = 2*-1*-1*matmul4(K2(1,2,2,1)%ab%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
       end do
       do p=1,numSG
           TempDerivReshape(p)%ReshapedMatrix = 2*-1*-1*matmul4(TempReshape(p)%ReshapedMatrix,K2(1,2,2,1)%ab%irrep(p)%block)
       end do
       do p=1,numSG
         do q=1,ReshapedMatrixDim%ajaa(p)%row
           do s=1,ReshapedMatrixDim%ajaa(p)%col
               energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*TempReshape(p)%ReshapedMatrix(q,s)
           end do
         end do
      end do
         Call reshape_ajaa_transpose_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
         Call reshape_ajbb_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)

deallocate(DerivReshapes)
deallocate(TempDerivReshape)
deallocate(Reshapes)
deallocate(TempReshape)
allocate(DerivReshapes(1:numSG))
allocate(TempDerivReshape(1:numSG))
allocate(Reshapes(1:numSG))
allocate(TempReshape(1:numSG))
Call reshape_jka_aaa(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
Call reshape_t1_b(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
     tempenergy = energy
     do p=1,numSG
       TempDerivReshape(p)%ReshapedMatrix = 2*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,1,2)%aa%irrep(p)%block)
       DerivReshapes(p)%ReshapedMatrix = 2*2*matmul4(K2(1,1,1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
     end do
     do p=1,numSG
       do q=1,ReshapedMatrixDim%jka_aaa(p)%row
         do s=1,ReshapedMatrixDim%jka_aaa(p)%col
          energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
         end do
       end do
    end do
     tempenergy = energy- tempenergy
      Call reshape_jka_aaa_inverse(numSG,ProductTable,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_b_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
deallocate(Reshapes)
deallocate(TempReshape)
deallocate(TempDerivReshape)
deallocate(DerivReshapes)
allocate(DerivReshapes(1:numSG))
allocate(TempDerivReshape(1:numSG))
allocate(Reshapes(1:numSG))
allocate(TempReshape(1:numSG))
       Call reshape_bci_aaa(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Call reshape_t1_i(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
tempenergy= energy
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*2*matmul4(K2(2,2,1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
         TempDerivReshape(p)%ReshapedMatrix = 2*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(2,2,1,2)%aa%irrep(p)%block)
       end do

      do p=1,numSG
        do q=1,ReshapedMatrixDim%bci_aaa(p)%row
          do s=1,ReshapedMatrixdim%bci_aaa(p)%col
            energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
          end do
        end do
       end do
tempenergy = energy - tempenergy
       Call reshape_bci_aaa_inverse(numSG,ProductTable,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Call reshape_t1_i_inverse(numSG,ProductTable,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt,TempDerivReshape)


deallocate(Reshapes)
deallocate(TempReshape)
deallocate(TempDerivReshape)
deallocate(DerivReshapes)
allocate(DerivReshapes(1:numSG))
allocate(TempDerivReshape(1:numSG))
allocate(Reshapes(1:numSG))
allocate(TempReshape(1:numSG))

       Call reshape_jka_abb(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Call reshape_t1_b(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
tempenergy = energy
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(K2(1,1,1,2)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
        TempDerivReshape(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,1,2)%ab%irrep(p)%block)
      end do

      do p=1,numSG
        do q=1,ReshapedMatrixDim%jka_abb(p)%row
          do s=1,ReshapedMatrixDim%jka_abb(p)%col
            energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
          end do
        end do
      end do
tempenergy = energy - tempenergy
       Call reshape_t1_b_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       Call reshape_jka_abb_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)

deallocate(Reshapes)
deallocate(TempReshape)
deallocate(TempDerivReshape)
deallocate(DerivReshapes)
allocate(DerivReshapes(1:numSG))
allocate(TempDerivReshape(1:numSG))
allocate(Reshapes(1:numSG))
allocate(TempReshape(1:numSG))
       Call reshape_jka_aba(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Call reshape_t1_b(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)

tempenergy = energy
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(K2(1,1,2,1)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
        TempDerivReshape(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,2,1)%ab%irrep(p)%block)
      end do

      do p=1,numSG
        do q=1,ReshapedMatrixDim%jka_aba(p)%row
          do s=1,ReshapedMatrixDim%jka_aba(p)%col
            energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q) * Reshapes(p)%ReshapedMatrix(q,s)
          end do
        end do
      end do
tempenergy = energy - tempenergy
       Call reshape_t1_b_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       Call reshape_jka_aba_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)

deallocate(Reshapes)
deallocate(TempReshape)
deallocate(TempDerivReshape)
deallocate(DerivReshapes)
allocate(DerivReshapes(1:numSG))
allocate(TempDerivReshape(1:numSG))
allocate(Reshapes(1:numSG))
allocate(TempReshape(1:numSG))
       Call reshape_bci_aba(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Call reshape_t1_i(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
tempenergy = energy

      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K2(2,2,1,2)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
        TempDerivReshape(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(2,2,1,2)%ab%irrep(p)%block)
      end do

      do p=1,numSG
        do q=1,ReshapedMatrixDim%bci_aba(p)%row
          do s=1,ReshapedMatrixDim%bci_aba(p)%col
            energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
          end do
        end do
      end do
tempenergy = energy - tempenergy
       Call reshape_t1_i_inverse(numSG,ProductTable,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt,TempDerivReshape)
       Call reshape_bci_aba_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)

deallocate(Reshapes)
deallocate(TempReshape)
deallocate(TempDerivReshape)
deallocate(DerivReshapes)
allocate(DerivReshapes(1:numSG))
allocate(TempDerivReshape(1:numSG))
allocate(Reshapes(1:numSG))
allocate(TempReshape(1:numSG))
       Call reshape_bci_abb(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Call reshape_t1_i(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
tempenergy = energy
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix =1*2*matmul4(K2(2,2,2,1)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
         TempDerivReshape(p)%ReshapedMatrix = 1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(2,2,2,1)%ab%irrep(p)%block)
       end do

      do p=1,numSG
        do q=1,ReshapedMatrixDim%bci_abb(p)%row
          do s=1,ReshapedMatrixDim%bci_abb(p)%col
            energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q) * Reshapes(p)%ReshapedMatrix(q,s)
          end do
        end do
      end do
tempenergy = energy - tempenergy
       Call reshape_t1_i_inverse(numSG,ProductTable,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt,TempDerivReshape)
       Call reshape_bci_abb_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)

deallocate(Reshapes)
deallocate(TempReshape)
deallocate(TempDerivReshape)
deallocate(DerivReshapes)
allocate(DerivReshapes(1:numSG))
allocate(Reshapes(1:numSG))

       Call reshape_t1t1_i(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
tempenergy = energy
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*-1*2*matmul4(Reshapes(p)%ReshapedMatrix,K1(1,1)%aa%irrep(p)%block)
       end do
       do p=1,numSG
         numa = virt(2,p) - virt(1,p) + 1
         numi = occ(2,p) - occ(1,p) + 1
         do q=1,numi
           do s=1,numa
             energy = energy + 0.5*Reshapes(p)%ReshapedMatrix(s,q)* DerivReshapes(p)%ReshapedMatrix(s,q)
           end do
         end do
       end do
tempenergy = energy - tempenergy
       Call reshape_t1t1_i_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)

tempenergy = energy
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*-1*matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(1,1)%aa%irrep(p)%block)
       end do

       do p=1,numSG
         numa = virt(2,p) - virt(1,p) + 1
         numi = occ(2,p) - occ(1,p) + 1
         do q=1,numi
           do s=1,numa
             energy = energy + 0.5*Reshapes(p)%ReshapedMatrix(s,q)* DerivReshapes(p)%ReshapedMatrix(s,q)
           end do
         end do
       end do
tempenergy = energy - tempenergy
       Call reshape_t1t1_i_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)



tempenergy = energy
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*2*matmul4(K1(2,2)%aa%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
      end do

      do p=1,numSG
         numa = virt(2,p) - virt(1,p) + 1
         numi = occ(2,p) - occ(1,p) + 1
          do q=1,numi
           do s=1,numa
             energy = energy + 0.5*DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(s,q)
            end do
         end do
      end do
tempenergy = energy - tempenergy
        Call reshape_t1t1_i_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
tempenergy = energy
       do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K1TwoInts(2,2)%aa%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
      end do

      do p=1,numSG
         numa = virt(2,p) - virt(1,p) + 1
         numi = occ(2,p) - occ(1,p) + 1
          do q=1,numi
           do s=1,numa
             energy = energy + 0.5*DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(s,q)
            end do
         end do
      end do
tempenergy = energy - tempenergy
        Call reshape_t1t1_i_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
      deallocate(DerivReshapes)
      deallocate(Reshapes)
      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
       Call reshape_t1_ibrow_alphaonly_symi(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
tempenergy = energy
     do p=1,numSG
       DerivReshapes(p)%ReshapedMatrix = 2*2*K1(1,2)%aa%irrep(p)%block  +K1TwoInts(1,2)%aa%irrep(p)%block
       allocate(temp(1:1,1:1))
       temp =  matmul4(Reshapes(p)%ReshapedMatrix,DerivReshapes(p)%ReshapedMatrix)
       energy = energy + temp(1,1)
       deallocate(temp)
     end do
tempenergy = energy - tempenergy
      Call reshape_t1_ibrow_alphaonly_symi_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)

     deallocate(DerivReshapes)
     deallocate(Reshapes)
     allocate(DerivReshapes(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempReshape(1:numSG))
     allocate(TempDerivReshape(1:numSG))

     Call reshape_ajaa_t1(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibrow(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
tempenergy = energy
allocate(temp(1:1,1:1))
     do p=1,numSG
       DerivReshapes(p)%ReshapedMatrix = 2*2*matmul4(K1(1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
       TempDerivReshape(p)%ReshapedMatrix = 2*2*matmul4(Reshapes(p)%ReshapedMatrix,K1(1,2)%aa%irrep(p)%block)

     end do
     do p=1,numSG
        temp = matmul4(TempReshape(p)%ReshapedMatrix,TempDerivReshape(p)%ReshapedMatrix)
        energy = energy + temp(1,1)
     end do
tempenergy = energy - tempenergy
      Call reshape_ajaa_t1_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       Call reshape_t1_ibrow_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)

deallocate(DerivReshapes)
deallocate(Reshapes)
deallocate(TempDerivReshape)
deallocate(TempReshape)
allocate(DerivReshapes(1:numSG))
allocate(Reshapes(1:numSG))
allocate(TempDerivReshape(1:numSG))
allocate(TempReshape(1:numSG))
     Call reshape_ajaa_t1(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibrow(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
tempenergy = energy
     do p=1,numSG
       DerivReshapes(p)%ReshapedMatrix = matmul4(K1TwoInts(1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
       TempDerivReshape(p)%ReshapedMatrix = matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(1,2)%aa%irrep(p)%block)
     end do
     do p=1,numSG
        temp = matmul4(TempReshape(p)%ReshapedMatrix,TempDerivReshape(p)%ReshapedMatrix)
        energy = energy + temp(1,1)
     end do
tempenergy = energy - tempenergy
      Call reshape_ajaa_t1_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T2deriv,ReshapedMatrixDim,InvPdt)
       Call reshape_t1_ibrow_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)

deallocate(DerivReshapes)
deallocate(Reshapes)
deallocate(TempDerivReshape)
deallocate(TempReshape)
allocate(DerivReshapes(1:numSG))
allocate(Reshapes(1:numSG))
allocate(TempDerivReshape(1:numSG))
allocate(TempReshape(1:numSG))


       Call reshape_t1_ibrow_alphaonly(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Call reshape_t1_ibcol_alphaonly(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
tempenergy = energy
         p=1
         TempDerivReshape(p)%ReshapedMatrix = -2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,2,1,2)%aa%irrep(p)%block)
         DerivReshapes(p)%ReshapedMatrix = -2*matmul4(K2(1,2,1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
         do q=1,ReshapedMatrixDim%ajaa(1)%col
             energy = energy + DerivReshapes(1)%ReshapedMatrix(q,1)*Reshapes(1)%ReshapedMatrix(1,q)
         end do
tempenergy = energy - tempenergy
       Call reshape_t1_ibrow_alphaonly_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       Call reshape_t1_ibcol_alphaonly_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)


deallocate(DerivReshapes)
deallocate(Reshapes)
deallocate(TempDerivReshape)
deallocate(TempReshape)
allocate(DerivReshapes(1:numSG))
allocate(Reshapes(1:numSG))
allocate(TempDerivReshape(1:numSG))
allocate(TempReshape(1:numSG))
       Call reshape_t1_ibrow_alphaonly(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Call reshape_t1_ibcol_alphaonly(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
tempenergy = energy
         p = 1
         TempDerivReshape(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,2,2,1)%ab%irrep(p)%block)
         DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K2(1,2,2,1)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)

         do q=1,ReshapedMatrixDim%ajab(1)%col
             energy = energy + DerivReshapes(1)%ReshapedMatrix(q,1)*Reshapes(1)%ReshapedMatrix(1,q)
         end do
tempenergy = energy - tempenergy
       Call reshape_t1_ibrow_alphaonly_inverse(numSG,ProductTable,DerivReshapes,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)
       Call reshape_t1_ibcol_alphaonly_inverse(numSG,ProductTable,TempDerivReshape,numOcc,numVirt,occ,virt,T1deriv,ReshapedMatrixDim,InvPdt)

        deallocate(Reshapes)
        deallocate(DerivReshapes)

    call cpu_time(time_total_end)
      time_calcderiv = time_calcderiv + time_total_end - time_total_begin
       end subroutine CalcDerivBlockK2

!> @brief Builds the D2 matrix after T1/T2 parameters are optimized
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine BuildD2(T2data,T1data,ReshapedMatrixDim,numSG,occ,virt,ProductTable,InvPdt,numOcc,numVirt,TwoInts,topfac,Newc,DerivNewc,T1deriv,topsingles,filename)

       Use InterfaceMod
       Use TypeMod
       Implicit NONE
       type(T2) :: T2data
       type(T1) :: T1data,T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       integer :: numSG,numOcc,numVirt
       integer, intent(IN), dimension(1:2,1:numSG) :: occ,virt
       integer, dimension(1:numSG,1:numSG) :: ProductTable
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:numSG)
       real(8), intent(IN), allocatable, dimension(:,:,:,:) :: TwoInts
       real(8), dimension(0:2,0:2) :: topfac
       type(T2) :: Newc, DerivNewc
       real(8), dimension(0:1,0:1) :: topsingles(0:1,0:1)
       character(len=35) :: filename



       type(D2) :: D2matrix
       integer :: i,j,rowdim
       integer :: k,l,symgp,i_begin,i_end, j_begin,j_end,k_begin,k_end,l_begin,l_end
       integer :: row,col,p,q,v,pos,offset,offset1,offset2,u,c
       integer :: t,r,s,a_begin,a_end,b_begin,b_end,a,b,numrows,numcols,rowoffset,coloffset
       type(ReshapedMat), allocatable, dimension(:)  :: DerivReshapes, Reshapes, TempReshape, TempDerivReshape,TopReshape
       type(D1) :: D1cum(1:numSG)
       integer :: reshaperows, reshapecols
       integer, allocatable, dimension(:) :: numocc_sg, numvirt_sg
       double precision, allocatable, dimension(:,:) :: TempMat, TempProductMat
       integer :: D1row,D1col,d2symgp,D2row,D2col, symi,symj,syma,symb,symk,symc
       character(len=100) :: D2outputfile
       type(T1) :: Newc_singles

       type(InverseBasis2), allocatable, dimension(:) :: IbD2aa
       type(InverseBasis2), allocatable, dimension(:) :: IbD2ab
       type(BasisMap2), allocatable, dimension(:) :: Basis_ajaa, Basis_ajab, Basis_jaab
       type(BasisMap3), allocatable, dimension(:) :: Basis_jka_aaa, Basis_bci_aaa
       type(BasisMap3), allocatable, dimension(:) :: Basis_jka_aba, Basis_jka_abb, Basis_bci_aba, Basis_bci_abb
       type(BasisMap1), allocatable, dimension(:) :: Basis_i,Basis_a
       type(BasisMap2), allocatable, dimension(:) :: Sym_Basis_ajaa, Sym_Basis_ajab, Sym_Basis_jaab
       type(BasisMap3), allocatable, dimension(:) :: Sym_Basis_jka_aaa, Sym_Basis_bci_aaa
       type(BasisMap3), allocatable, dimension(:) :: Sym_Basis_jka_aba, Sym_Basis_jka_abb, Sym_Basis_bci_aba, Sym_Basis_bci_abb
       type(BasisMap1), allocatable, dimension(:) :: Sym_Basis_i, Sym_Basis_a


       Call MapD2(numSG,occ,virt,ReshapedMatrixDim,IbD2aa,IbD2ab, Basis_ajaa, Basis_ajab, Basis_jaab,Basis_jka_aaa, Basis_bci_aaa,Basis_jka_aba, Basis_jka_abb, Basis_bci_aba, Basis_bci_abb,Basis_i,Basis_a,Sym_Basis_jka_aaa, Sym_Basis_bci_aaa,Sym_Basis_jka_aba, Sym_Basis_jka_abb, Sym_Basis_bci_aba,Sym_Basis_bci_abb,Sym_Basis_i, Sym_Basis_a,InvPdt,Sym_Basis_ajaa,Sym_Basis_ajab,Sym_Basis_jaab)
       allocate(D2matrix%aa%irrep(1:numSG))
       allocate(D2matrix%ab%irrep(1:numSG))
       do i=1,numSG
         rowdim = 0
         rowdim = ReshapedMatrixDim%ijaa(i)%col + ReshapedMatrixDim%ajaa(i)%col + ReshapedMatrixDim%ijaa(i)%row
         allocate(D2matrix%aa%irrep(i)%block(1:rowdim,1:rowdim))
         D2matrix%aa%irrep(i)%block(1:rowdim,1:rowdim) = 0.D0
      end do

      do i=1,numSG
        rowdim = 0
        rowdim = ReshapedMatrixDim%ijab(i)%row + ReshapedMatrixDim%ijab(i)%col + 2*ReshapedMatrixDim%ajab(i)%col
        allocate(D2matrix%ab%irrep(i)%block(1:rowdim,1:rowdim))
        D2matrix%ab%irrep(i)%block(1:rowdim,1:rowdim) = 0.D0
      end do

      do symgp=1,numSG
         col = 0
         do t=1,numSG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             if(p.GT.q) then
               cycle
             end if
             i_begin = occ(1,p)
             i_end   = occ(2,p)
             j_begin = occ(1,q)
             j_end   = occ(2,q)
             do i=i_begin,i_end
               do j=max(i+1,j_begin),j_end
                 col = col + 1
                 row = 1
                 do v=1,numSG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   if(r.GT.s) then
                     cycle
                   end if
                   k_begin = occ(1,r)
                   k_end   = occ(2,r)
                   l_begin = occ(1,s)
                   l_end   = occ(2,s)
                   do k=k_begin,k_end
                     do l=max(k+1,l_begin),l_end
                       if(i==k.and.j==l.and.k.ne.j) then
                         D2matrix%aa%irrep(symgp)%block(row,col) = 1
                       else
                         D2matrix%aa%irrep(symgp)%block(row,col) = 0
                       end if
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do


      do symgp=1,numSG
         col =0
         do t=1,numSG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             i_begin = occ(1,p)
             i_end   = occ(2,p)
             j_begin = occ(1,q)
             j_end   = occ(2,q)
             do i=i_begin,i_end
               do j=j_begin,j_end
                 col = col + 1
                 row = 1
                 do v=1,numSG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   k_begin = occ(1,r)
                   k_end   = occ(2,r)
                   l_begin = occ(1,s)
                   l_end   = occ(2,s)
                   do k=k_begin,k_end
                     do l=l_begin,l_end
                       if(i==k.and.j==l) then
                         D2matrix%ab%irrep(symgp)%block(row,col) = 2*0.5
                       else
                         D2matrix%ab%irrep(symgp)%block(row,col) = 0
                       end if
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do


      allocate(numocc_sg(1:numSG))
      allocate(numvirt_sg(1:numSG))
      do p=1,numSG
        i_begin = occ(1,p)
        i_end   = occ(2,p)
        a_begin = virt(1,p)
        a_end   = virt(2,p)
        numocc_sg(p) = i_end - i_begin + 1
        numvirt_sg(p) = a_end - a_begin + 1
      end do

      allocate(Newc_singles%a%o(1:numOcc))
      do p=1,numOcc
        allocate(Newc_singles%a%o(p)%vsym(1:numSG))
      end do

      do p=1,numSG
        i_begin = occ(1,p)
        i_end   = occ(2,p)
        a_begin = virt(1,p)
        a_end   = virt(2,p)
        do i=i_begin,i_end
          allocate(Newc_singles%a%o(i)%vsym(p)%v(a_begin:a_end))
          Newc_singles%a%o(i)%vsym(p)%v(a_begin:a_end) = 0.0
        end do
      end do

       Call BuildNewc_singles(Newc_singles,T2data,T1data,topsingles,numSG,occ,virt,InvPdt,ProductTable)


      do p=1,numSG
        allocate(D1cum(p)%D1block(1:(numocc_sg(p)+numvirt_sg(p)),1:(numocc_sg(p)+numvirt_sg(p))))
        D1cum(p)%D1block = 0.0
      end do

      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
      Call reshape_i(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        if(numocc_sg(p).ne.0) then
          D1cum(p)%D1block(1:numocc_sg(p),1:numocc_sg(p)) = -1*matmul(transpose(Reshapes(p)%ReshapedMatrix),Reshapes(p)%ReshapedMatrix) + D1cum(p)%D1block(1:numocc_sg(p),1:numocc_sg(p))
        end if
      end do
      deallocate(Reshapes,DerivReshapes)

      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
      Call reshape_t1t1_i(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        if(numocc_sg(p).ne.0) then
          D1cum(p)%D1block(1:numocc_sg(p),1:numocc_sg(p)) = -1*matmul(transpose(Reshapes(p)%ReshapedMatrix),Reshapes(p)%ReshapedMatrix) + D1cum(p)%D1block(1:numocc_sg(p),1:numocc_sg(p))
        end if
      end do

      do p=1,numSG
        if(numvirt_sg(p).ne.0) then
          D1cum(p)%D1block(numocc_sg(p)+1:numocc_sg(p)+numvirt_sg(p),numocc_sg(p)+1:numocc_sg(p)+numvirt_sg(p)) = matmul(Reshapes(p)%ReshapedMatrix,transpose(Reshapes(p)%ReshapedMatrix)) + D1cum(p)%D1block(numocc_sg(p)+1:numocc_sg(p)+numvirt_sg(p),numocc_sg(p)+1:numocc_sg(p)+numvirt_sg(p))
        end if
      end do
      deallocate(Reshapes,DerivReshapes)
      allocate(Reshapes(1:numSG),DerivReshapes(1:numSG))
      Call reshape_a(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        if(numvirt_sg(p).ne.0) then
          D1cum(p)%D1block(numocc_sg(p)+1:numocc_sg(p)+numvirt_sg(p),numocc_sg(p)+1:numocc_sg(p)+numvirt_sg(p)) = matmul(transpose(Reshapes(p)%ReshapedMatrix),Reshapes(p)%ReshapedMatrix) + D1cum(p)%D1block(numocc_sg(p)+1:numocc_sg(p)+numvirt_sg(p),numocc_sg(p)+1:numocc_sg(p)+numvirt_sg(p))
        end if
      end do
      deallocate(Reshapes,DerivReshapes)


      do p=1,numSG
        i_begin = occ(1,p)
        i_end   = occ(2,p)
        a_begin = virt(1,p)
        a_end   = virt(2,p)
        do i=i_begin,i_end
          do a=a_begin,a_end
          row = a - a_begin + 1 + numocc_sg(p)
          col = i - i_begin + 1
            D1cum(p)%D1block(row,col) = D1cum(p)%D1block(row,col) + T1data%a%o(i)%vsym(p)%v(a)*Newc_singles%a%o(i)%vsym(p)%v(a)
            D1cum(p)%D1block(col,row) = D1cum(p)%D1block(col,row) + T1data%a%o(i)%vsym(p)%v(a)*Newc_singles%a%o(i)%vsym(p)%v(a)
          end do
        end do
      end do


      allocate(Reshapes(1:numSG),DerivReshapes(1:numSG))
      allocate(TempReshape(1:numSG),TempDerivReshape(1:numSG))
      Call reshape_ajaa_t1(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_ibrow(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      do p=1,numSG
        allocate(TempMat(1,1:numocc_sg(p)*numvirt_sg(p)))
        i_begin = occ(1,p)
        i_end   = occ(2,p)
        a_begin = virt(1,p)
        a_end   = virt(2,p)
        TempMat = matmul4(TempReshape(p)%ReshapedMatrix,Reshapes(p)%ReshapedMatrix)
        pos = 1
        do i=i_begin,i_end
          do a=a_begin,a_end
            row = a - a_begin + 1 + numocc_sg(p)
            col = i - i_begin + 1
              D1cum(p)%D1block(row,col) = TempMat(1,pos) + D1cum(p)%D1block(row,col)
              D1cum(p)%D1block(col,row) = TempMat(1,pos) + D1cum(p)%D1block(col,row)
            pos = pos + 1
          end do
        end do
        deallocate(TempMat)
      end do
      deallocate(Reshapes,DerivReshapes,TempReshape,TempDerivReshape)

      do symgp=1,numSG
         col = 0
         do t=1,numSG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             if(p.GT.q) then
               cycle
             end if
             i_begin = occ(1,p)
             i_end   = occ(2,p)
             j_begin = occ(1,q)
             j_end   = occ(2,q)
             do i=i_begin,i_end
               do j=max(i+1,j_begin),j_end
                 col = col + 1
                 row = 1
                 do v=1,numSG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   if(r.GT.s) then
                     cycle
                   end if
                   k_begin = occ(1,r)
                   k_end   = occ(2,r)
                   l_begin = occ(1,s)
                   l_end   = occ(2,s)
                   do k=k_begin,k_end
                     do l=max(k+1,l_begin),l_end
                       if(j==l.and.p.eq.r) then
                         D1row = i - i_begin + 1
                         D1col = k - k_begin + 1
                         D2matrix%aa%irrep(symgp)%block(row,col) = D1cum(p)%D1block(D1row,D1col) + D2matrix%aa%irrep(symgp)%block(row,col)
                       end if
                       if(j==k.and.p.eq.s) then
                         D1row = i - i_begin + 1
                         D1col = l - l_begin + 1
                         D2matrix%aa%irrep(symgp)%block(row,col) = -1*D1cum(p)%D1block(D1row,D1col) + D2matrix%aa%irrep(symgp)%block(row,col)
                       end if
                       if(i.eq.l.and.q.eq.r) then
                         D1row = j - j_begin + 1
                         D1col = k - k_begin + 1
                         D2matrix%aa%irrep(symgp)%block(row,col) = -1*D1cum(q)%D1block(D1row,D1col) + D2matrix%aa%irrep(symgp)%block(row,col)
                       end if
                       if(i.eq.k.and.q.eq.s) then
                         D1row = j - j_begin + 1
                         D1col = l - l_begin + 1
                         D2matrix%aa%irrep(symgp)%block(row,col) = D1cum(q)%D1block(D1row,D1col) + D2matrix%aa%irrep(symgp)%block(row,col)
                       end if
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do

      do symgp=1,numSG
         col =0
         do t=1,numSG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             i_begin = occ(1,p)
             i_end   = occ(2,p)
             j_begin = occ(1,q)
             j_end   = occ(2,q)
             do i=i_begin,i_end
               do j=j_begin,j_end
                 col = col + 1
                 row = 1
                 do v=1,numSG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   k_begin = occ(1,r)
                   k_end   = occ(2,r)
                   l_begin = occ(1,s)
                   l_end   = occ(2,s)
                   do k=k_begin,k_end
                     do l=l_begin,l_end
                       if(j==l.and.p.eq.r) then
                         D1row = i - i_begin + 1
                         D1col = k - k_begin + 1
                         D2matrix%ab%irrep(symgp)%block(row,col) = D1cum(p)%D1block(D1row,D1col) + D2matrix%ab%irrep(symgp)%block(row,col)
                       end if
                       if(i==k.and.q.eq.s) then
                         D1row = j - j_begin + 1
                         D1col = l - l_begin + 1
                         D2matrix%ab%irrep(symgp)%block(row,col) = D1cum(q)%D1block(D1row,D1col) + D2matrix%ab%irrep(symgp)%block(row,col)
                       end if
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do
       do symgp=1,numSG
         offset = ReshapedMatrixDim%ijaa(symgp)%col
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt(1,r)
                 b_end   = virt(2,r)
                 i_begin = occ(1,s)
                 i_end   = occ(2,s)
                 do i=i_begin,i_end
                   do b=b_begin,b_end
                     if(i.eq.j.and.p.eq.r) then
                      d2symgp = ProductTable(s,p)
                      d2symgp = ProductTable(q,r)
                      d2row = IbD2aa(d2symgp)%ib(i,a)
                      d2col = IbD2aa(d2symgp)%ib(j,b)
                      D1row = a - a_begin + 1 + numocc_sg(p)
                      D1col = b - b_begin + 1 + numocc_sg(p)
                      D2matrix%aa%irrep(d2symgp)%block(d2row,d2col) = D1cum(p)%D1block(D1row,D1col) + D2matrix%aa%irrep(symgp)%block(d2row,d2col)
                      end if
                      row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         offset1 = ReshapedMatrixDim%ijab(symgp)%col
         offset2 = ReshapedMatrixDim%ijab(symgp)%col + ReshapedMatrixDim%ajab(symgp)%row
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do a=a_begin,a_end
             do j=j_begin,j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt(1,r)
                 b_end   = virt(2,r)
                 i_begin = occ(1,s)
                 i_end   = occ(2,s)
                 do b=b_begin,b_end
                   do i=i_begin,i_end
                      if(i.eq.j.and.p.eq.r)  then
                        d2symgp = ProductTable(s,p)
                        d2symgp = ProductTable(q,r)
                        d2row = IbD2ab(d2symgp)%ib(i,a)
                        d2col = IbD2ab(d2symgp)%ib(j,b)
                        D1row = a - a_begin + 1 + numocc_sg(p)
                        D1col = b - b_begin + 1 + numocc_sg(p)
                        D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = D1cum(p)%D1block(D1row,D1col) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
                        d2row = IbD2ab(d2symgp)%ib(a,i)
                        d2col = IbD2ab(d2symgp)%ib(b,j)
                        D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = D1cum(p)%D1block(D1row,D1col) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
                      end if
                      row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ijaa_test(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       deallocate(DerivReshapes)
       do p=1,numSG
         numrows = ReshapedMatrixDim%ijaa(p)%col
         numcols = numrows
         reshaperows = size(Reshapes(p)%ReshapedMatrix,1)
         reshapecols = size(Reshapes(p)%ReshapedMatrix,2)
         allocate(TempMat(1:reshapecols,1:reshaperows))
         TempMat = transpose(Reshapes(p)%ReshapedMatrix)
         D2matrix%aa%irrep(p)%block(1:numrows,1:numcols) = matmul4(TempMat,Reshapes(p)%ReshapedMatrix) +  D2matrix%aa%irrep(p)%block(1:numrows,1:numcols)
         deallocate(TempMat)
       end do
      do p=1,numSG
        numrows = ReshapedMatrixDim%ijaa(p)%row
        numcols = ReshapedMatrixDim%ijaa(p)%row
        offset =  ReshapedMatrixDim%ijaa(p)%col + ReshapedMatrixDim%ajaa(p)%col
        reshaperows = size(Reshapes(p)%ReshapedMatrix,1)
        reshapecols = size(Reshapes(p)%ReshapedMatrix,2)
        allocate(TempMat(1:reshapecols,1:reshaperows))
        TempMat = transpose(Reshapes(p)%ReshapedMatrix)
        D2matrix%aa%irrep(p)%block(offset+1:offset+numrows,offset+1:offset+numcols) = matmul4(Reshapes(p)%ReshapedMatrix,TempMat) + D2matrix%aa%irrep(p)%block(offset+1:offset+numrows,offset+1:offset+numcols)
        deallocate(TempMat)
      end do
      allocate(DerivReshapes(1:numSG))
      allocate(TopReshape(1:numSG))
      Call reshape_ijaa_test(numSG,ProductTable,TopReshape,numOcc,numVirt,occ,virt,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        numrows = ReshapedMatrixdim%ijaa(p)%row
        numcols = ReshapedMatrixDim%ijaa(p)%col
        allocate(TempMat(1:numrows,1:numcols))
        rowoffset = ReshapedMatrixDim%ijaa(p)%col + ReshapedMatrixDim%ajaa(p)%col
        coloffset = 0
        do q=1,ReshapedMatrixDim%ijaa(p)%col
          do s=1,ReshapedMatrixDim%ijaa(p)%row
            TempMat(s,q) = Reshapes(p)%ReshapedMatrix(s,q)*TopReshape(p)%ReshapedMatrix(s,q)
           end do
        end do
        D2matrix%aa%irrep(p)%block(rowoffset+1:rowoffset+numrows,coloffset+1:coloffset+numcols) = TempMat + D2matrix%aa%irrep(p)%block(rowoffset+1:rowoffset+numrows,coloffset+1:coloffset+numcols)
        D2matrix%aa%irrep(p)%block(coloffset+1:coloffset+numcols,rowoffset+1:rowoffset+numrows) = transpose(TempMat) + D2matrix%aa%irrep(p)%block(coloffset+1:coloffset+numcols,rowoffset+1:rowoffset+numrows)
        deallocate(TempMat)
      end do
      deallocate(DerivReshapes)
      deallocate(Reshapes)
      deallocate(TopReshape)


       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ijab_test(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       deallocate(DerivReshapes)
       do p=1,numSG
         numrows = ReshapedMatrixDim%ijab(p)%col
         numcols = numrows
         reshaperows = size(Reshapes(p)%ReshapedMatrix,1)
         reshapecols = size(Reshapes(p)%ReshapedMatrix,2)
         allocate(TempMat(1:reshapecols,1:reshaperows))
         TempMat = transpose(Reshapes(p)%ReshapedMatrix)
         D2matrix%ab%irrep(p)%block(1:numrows,1:numcols) = matmul4(TempMat,Reshapes(p)%ReshapedMatrix) +  D2matrix%ab%irrep(p)%block(1:numrows,1:numcols)
         deallocate(TempMat)
       end do
      do p=1,numSG
        numrows = ReshapedMatrixDim%ijab(p)%row
        numcols = ReshapedMatrixDim%ijab(p)%row
        offset = ReshapedMatrixDim%ijab(p)%col + 2*ReshapedMatrixDim%ajab(p)%col
        reshaperows = size(Reshapes(p)%ReshapedMatrix,1)
        reshapecols = size(Reshapes(p)%ReshapedMatrix,2)
        allocate(TempMat(1:reshapecols,1:reshaperows))
        TempMat = transpose(Reshapes(p)%ReshapedMatrix)
        D2matrix%ab%irrep(p)%block(offset+1:offset+numrows,offset+1:offset+numcols) = matmul4(Reshapes(p)%ReshapedMatrix,TempMat) + D2matrix%ab%irrep(p)%block(offset+1:offset+numrows,offset+1:offset+numcols)
        deallocate(TempMat)
      end do
      allocate(DerivReshapes(1:numSG))
      allocate(TopReshape(1:numSG))

      Call reshape_ijab_test(numSG,ProductTable,TopReshape,numOcc,numVirt,occ,virt,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        numrows = ReshapedMatrixDim%ijab(p)%row
        numcols = ReshapedMatrixDim%ijab(p)%col
        allocate(TempMat(1:numrows,1:numcols))
        rowoffset = ReshapedMatrixDim%ijab(p)%col + 2*ReshapedMatrixDim%ajab(p)%col
        coloffset = 0
        do q=1,ReshapedMatrixDim%ijab(p)%col
          do s=1,ReshapedMatrixDim%ijab(p)%row
            TempMat(s,q) = Reshapes(p)%ReshapedMatrix(s,q)*TopReshape(p)%ReshapedMatrix(s,q)
           end do
        end do
        D2matrix%ab%irrep(p)%block(rowoffset+1:rowoffset+numrows,coloffset+1:coloffset+numcols) = TempMat + D2matrix%ab%irrep(p)%block(rowoffset+1:rowoffset+numrows,coloffset+1:coloffset+numcols)
        D2matrix%ab%irrep(p)%block(coloffset+1:coloffset+numcols,rowoffset+1:rowoffset+numrows) = transpose(TempMat) + D2matrix%ab%irrep(p)%block(coloffset+1:coloffset+numcols,rowoffset+1:rowoffset+numrows)
        deallocate(TempMat)
      end do
      deallocate(DerivReshapes)
      deallocate(Reshapes)
      deallocate(TopReshape)

       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ajaa(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       deallocate(DerivReshapes)
       do p=1,numSG
         numrows = ReshapedMatrixDim%ajaa(p)%col
         reshaperows = size(Reshapes(p)%ReshapedMatrix,1)
         reshapecols = size(Reshapes(p)%ReshapedMatrix,2)
         allocate(TempMat(1:reshapecols,1:reshaperows))
         TempMat = transpose(Reshapes(p)%ReshapedMatrix)
         allocate(TempProductMat(1:numrows,1:numrows))
         TempProductMat(1:numrows,1:numrows) = 0.D0
         TempProductMat = -1*matmul4(TempMat,Reshapes(p)%ReshapedMatrix)
         do q=1,numrows
           do s=1,numrows
            j = Basis_ajaa(p)%basis(1,s)
            a = Basis_ajaa(p)%basis(2,s)
            i = Basis_ajaa(p)%basis(1,q)
            b = Basis_ajaa(p)%basis(2,q)
            symj = Sym_Basis_ajaa(p)%basis(1,s)
            syma = Sym_Basis_ajaa(p)%basis(2,s)
            symi = Sym_Basis_ajaa(p)%basis(1,q)
            symb = Sym_Basis_ajaa(p)%basis(2,q)
            d2symgp = ProductTable(symi,syma)
            d2symgp = ProductTable(symj,symb)
            d2col = IbD2aa(d2symgp)%ib(i,a)
            d2row = IbD2aa(d2symgp)%ib(j,b)
            D2matrix%aa%irrep(d2symgp)%block(d2row,d2col) = TempProductMat(s,q) + D2matrix%aa%irrep(d2symgp)%block(d2row,d2col)
           end do
         end do
         deallocate(TempMat)
         deallocate(TempProductMat)
       end do
       deallocate(Reshapes)

       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ajab(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       deallocate(DerivReshapes)
       do p=1,numSG
         numrows = ReshapedMatrixDim%ajab(p)%col
         reshaperows = size(Reshapes(p)%ReshapedMatrix,1)
         reshapecols = size(Reshapes(p)%ReshapedMatrix,2)
         allocate(TempMat(1:reshapecols,1:reshaperows))
         TempMat = transpose(Reshapes(p)%ReshapedMatrix)
         allocate(TempProductMat(1:numrows,1:numrows))
         TempProductMat(1:numrows,1:numrows) = 0.D0
         TempProductMat= -1*matmul4(TempMat,Reshapes(p)%ReshapedMatrix)
         do q=1,numrows
           do s=1,numrows
            a = Basis_ajab(p)%basis(1,s)
            j = Basis_ajab(p)%basis(2,s)
            b = Basis_ajab(p)%basis(1,q)
            i = Basis_ajab(p)%basis(2,q)
            syma = Sym_Basis_ajab(p)%basis(1,s)
            symj = Sym_Basis_ajab(p)%basis(2,s)
            symb = Sym_Basis_ajab(p)%basis(1,q)
            symi = Sym_Basis_ajab(p)%basis(2,q)
            d2symgp = ProductTable(symi,syma)
            d2symgp = ProductTable(symj,symb)
            d2col = IbD2ab(d2symgp)%ib(a,i)
            d2row = IbD2ab(d2symgp)%ib(b,j)
            D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = TempProductMat(s,q) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
            j = Basis_jaab(p)%basis(1,s)
            a = Basis_jaab(p)%basis(2,s)
            i = Basis_jaab(p)%basis(1,q)
            b = Basis_jaab(p)%basis(2,q)
            symj = Sym_Basis_jaab(p)%basis(1,s)
            syma = Sym_Basis_jaab(p)%basis(2,s)
            symi = Sym_Basis_jaab(p)%basis(1,q)
            symb = Sym_Basis_jaab(p)%basis(2,q)
            d2symgp = ProductTable(symi,syma)
            d2symgp = ProductTable(symj,symb)
            d2row = IbD2ab(d2symgp)%ib(i,a)
            d2col = IbD2ab(d2symgp)%ib(j,b)
            D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = TempProductMat(s,q) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
           end do
         end do
         deallocate(TempMat)
         deallocate(TempProductMat)
      end do
      deallocate(Reshapes)

      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
      allocate(TempReshape(1:numSG))
      allocate(TempDerivReshape(1:numSG))
      Call reshape_ajaa_transpose(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_ajbb(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      deallocate(DerivReshapes)
      deallocate(TempDerivReshape)
       do p=1,numSG
          numrows = ReshapedMatrixDim%ajab(p)%col
          numcols = numrows
          allocate(TempProductMat(1:numrows,1:numcols))
          TempProductMat(1:numrows,1:numcols) = 0.D0
          TempProductMat = 1*matmul4(Reshapes(p)%ReshapedMatrix,TempReshape(p)%ReshapedMatrix)
         do q=1,numrows
           do s=1,numrows
            a = Basis_ajaa(p)%basis(1,s)
            j = Basis_ajaa(p)%basis(2,s)
            b = Basis_ajaa(p)%basis(1,q)
            i = Basis_ajaa(p)%basis(2,q)
            symj = Sym_Basis_ajaa(p)%basis(1,s)
            syma = Sym_Basis_ajaa(p)%basis(2,s)
            symi = Sym_Basis_ajaa(p)%basis(1,q)
            symb = Sym_Basis_ajaa(p)%basis(2,q)
            d2symgp = ProductTable(symi,syma)
            d2symgp = ProductTable(symj,symb)
            d2col = IbD2ab(d2symgp)%ib(i,a)
            d2row = IbD2ab(d2symgp)%ib(b,j)
            D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = TempProductMat(s,q) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
            d2col = IbD2ab(d2symgp)%ib(a,i)
            d2row = IbD2ab(d2symgp)%ib(j,b)
            D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = TempProductMat(s,q) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
           end do
         end do
         deallocate(TempProductMat)
       end do
       deallocate(Reshapes)
       deallocate(TempReshape)

      allocate(DerivReshapes(1:numSG))
      allocate(TempDerivReshape(1:numSG))
      allocate(Reshapes(1:numSG))
      allocate(TempReshape(1:numSG))
      Call reshape_jka_aaa(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_b(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      deallocate(DerivReshapes,TempDerivReshape)
      do p=1,numSG
        numcols = ReshapedMatrixDim%jka_aaa(p)%col
        numrows = ReshapedMatrixDim%i(p)%col
        allocate(TempMat(1:numrows,1:numcols))
        TempMat =  matmul4(TempReshape(p)%ReshapedMatrix,Reshapes(p)%ReshapedMatrix)
        do q=1,numcols
          do s=1,numrows
            i = Basis_i(p)%basis(1,s)
            j = Basis_jka_aaa(p)%basis(1,q)
            k = Basis_jka_aaa(p)%basis(2,q)
            a = Basis_jka_aaa(p)%basis(3,q)
            symi = Sym_Basis_i(p)%basis(1,s)
            symj = Sym_Basis_jka_aaa(p)%basis(1,q)
            symk = Sym_Basis_jka_aaa(p)%basis(2,q)
            syma = Sym_Basis_jka_aaa(p)%basis(3,q)
            d2symgp = ProductTable(symj,symk)
            d2symgp = ProductTable(symi,syma)
            d2col = IbD2aa(d2symgp)%ib(j,k)
            d2row = IbD2aa(d2symgp)%ib(i,a)
            D2matrix%aa%irrep(d2symgp)%block(d2row,d2col) = TempMat(s,q) + D2matrix%aa%irrep(d2symgp)%block(d2row,d2col)
            D2matrix%aa%irrep(d2symgp)%block(d2col,d2row) = TempMat(s,q) + D2matrix%aa%irrep(d2symgp)%block(d2col,d2row)
          end do
        end do
        deallocate(TempMat)
      end do
      deallocate(Reshapes)
      deallocate(TempReshape)
      allocate(DerivReshapes(1:numSG))
      allocate(TempDerivReshape(1:numSG))
      allocate(Reshapes(1:numSG))
      allocate(TempReshape(1:numSG))
      Call reshape_bci_aaa(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_i(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
       do p=1,numSG
         numcols= ReshapedMatrixDim%bci_aaa(p)%col
         numrows = ReshapedMatrixDim%a(p)%col
         allocate(TempMat(1:numrows,1:numcols))
         TempMat = matmul4(TempReshape(p)%ReshapedMatrix,Reshapes(p)%ReshapedMatrix)
         do q=1,numcols
           do s=1,numrows
             a = Basis_a(p)%basis(1,s)
             b = Basis_bci_aaa(p)%basis(1,q)
             c = Basis_bci_aaa(p)%basis(2,q)
             i = Basis_bci_aaa(p)%basis(3,q)
             syma = Sym_Basis_a(p)%basis(1,s)
             symb = Sym_Basis_bci_aaa(p)%basis(1,q)
             symc = Sym_Basis_bci_aaa(p)%basis(2,q)
             symi = Sym_Basis_bci_aaa(p)%basis(3,q)
             d2symgp = ProductTable(symi,syma)
             d2symgp = ProductTable(symb,symc)
             d2row =  IbD2aa(d2symgp)%ib(i,a)
             d2col = IbD2aa(d2symgp)%ib(b,c)
             D2matrix%aa%irrep(d2symgp)%block(d2row,d2col) = TempMat(s,q) + D2matrix%aa%irrep(d2symgp)%block(d2row,d2col)
             D2matrix%aa%irrep(d2symgp)%block(d2col,d2row) = TempMat(s,q) + D2matrix%aa%irrep(d2symgp)%block(d2col,d2row)
           end do
         end do
         deallocate(TempMat)
       end do
       deallocate(TempReshape,Reshapes)
       deallocate(TempDerivReshape,DerivReshapes)

       allocate(DerivReshapes(1:numSG))
       allocate(TempDerivReshape(1:numSG))
       allocate(Reshapes(1:numSG))
       allocate(TempReshape(1:numSG))
       Call reshape_jka_abb(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Call reshape_t1_b(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
       deallocate(DerivReshapes,TempDerivReshape)
      do p=1,numSG
        numrows = ReshapedMatrixDim%i(p)%col
        numcols = ReshapedMatrixDim%jka_abb(p)%col
        allocate(TempMat(1:numrows,1:numcols))
        TempMat(1:numrows,1:numcols) = 0.D0
        TempMat =  -1*matmul4(TempReshape(p)%ReshapedMatrix,Reshapes(p)%ReshapedMatrix)
         do q=1,numcols
           do s=1,numrows
             i = Basis_i(p)%basis(1,s)
             j = Basis_jka_abb(p)%basis(1,q)
             k = Basis_jka_abb(p)%basis(2,q)
             a = Basis_jka_abb(p)%basis(3,q)
             symi = Sym_Basis_i(p)%basis(1,s)
             symj = Sym_Basis_jka_abb(p)%basis(1,q)
             symk = Sym_Basis_jka_abb(p)%basis(2,q)
             syma = Sym_Basis_jka_abb(p)%basis(3,q)
             d2symgp = ProductTable(symi,syma)
             d2symgp = ProductTable(symj,symk)
             d2row =  IbD2ab(d2symgp)%ib(i,a)
             d2col = IbD2ab(d2symgp)%ib(j,k)
             D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = TempMat(s,q) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
             D2matrix%ab%irrep(d2symgp)%block(d2col,d2row) = TempMat(s,q) + D2matrix%ab%irrep(d2symgp)%block(d2col,d2row)
           end do
         end do
         deallocate(TempMat)
      end do
      deallocate(TempReshape)
      deallocate(Reshapes)
       allocate(DerivReshapes(1:numSG))
       allocate(TempDerivReshape(1:numSG))
       allocate(Reshapes(1:numSG))
       allocate(TempReshape(1:numSG))
       Call reshape_jka_aba(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Call reshape_t1_b(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      do p=1,numSG
        numrows = ReshapedMatrixDim%i(p)%col
        numcols = ReshapedMatrixDim%jka_aba(p)%col
        allocate(TempMat(1:numrows,1:numcols))
        TempMat  = -1*matmul4(TempReshape(p)%ReshapedMatrix,Reshapes(p)%ReshapedMatrix)
         do q=1,numcols
           do s=1,numrows
             i = Basis_i(p)%basis(1,s)
             j = Basis_jka_aba(p)%basis(1,q)
             k = Basis_jka_aba(p)%basis(2,q)
             a = Basis_jka_aba(p)%basis(3,q)
             symi = Sym_Basis_i(p)%basis(1,s)
             symj = Sym_Basis_jka_aba(p)%basis(1,q)
             symk = Sym_Basis_jka_aba(p)%basis(2,q)
             syma = Sym_Basis_jka_aba(p)%basis(3,q)
             d2symgp = ProductTable(syma,symi)
             d2symgp = ProductTable(symj,symk)
             d2row =  IbD2ab(d2symgp)%ib(a,i)
             d2col = IbD2ab(d2symgp)%ib(j,k)
             D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = TempMat(s,q) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
             D2matrix%ab%irrep(d2symgp)%block(d2col,d2row) = TempMat(s,q) + D2matrix%ab%irrep(d2symgp)%block(d2col,d2row)
           end do
         end do
         deallocate(TempMat)
      end do
      deallocate(Reshapes,TempReshape)
      deallocate(DerivReshapes,TempDerivReshape)
      allocate(DerivReshapes(1:numSG))
      allocate(TempDerivReshape(1:numSG))
      allocate(Reshapes(1:numSG))
      allocate(TempReshape(1:numSG))
      Call reshape_bci_aba(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_i(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      deallocate(DerivReshapes,TempDerivReshape)
      do p=1,numSG
        numrows = ReshapedMatrixDim%a(p)%col
        numcols = ReshapedMatrixDim%bci_aba(p)%col
        allocate(TempMat(1:numrows,1:numcols))
        TempMat = matmul4(TempReshape(p)%ReshapedMatrix,Reshapes(p)%ReshapedMatrix)
         do q=1,numcols
           do s=1,numrows
             a = Basis_a(p)%basis(1,s)
             b = Basis_bci_aba(p)%basis(1,q)
             c = Basis_bci_aba(p)%basis(2,q)
             i = Basis_bci_aba(p)%basis(3,q)
             syma = Sym_Basis_a(p)%basis(1,s)
             symb = Sym_Basis_bci_aba(p)%basis(1,q)
             symc = Sym_Basis_bci_aba(p)%basis(2,q)
             symi = Sym_Basis_bci_aba(p)%basis(3,q)
             d2symgp = ProductTable(symi,syma)
             d2symgp = ProductTable(symb,symc)
             d2row =  IbD2ab(d2symgp)%ib(i,a)
             d2col = IbD2ab(d2symgp)%ib(b,c)
             D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = TempMat(s,q) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
             D2matrix%ab%irrep(d2symgp)%block(d2col,d2row) = TempMat(s,q) + D2matrix%ab%irrep(d2symgp)%block(d2col,d2row)
           end do
         end do
         deallocate(TempMat)
      end do
      deallocate(Reshapes,TempReshape)
     allocate(DerivReshapes(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempReshape(1:numSG))
     Call reshape_bci_abb(numSG,ProductTable,Reshapes,numOcc,numVirt,occ,virt,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_i(numSG,ProductTable,TempReshape,numOcc,numVirt,occ,virt,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
     deallocate(DerivReshapes,TempDerivReshape)
       do p=1,numSG
         numrows = ReshapedMatrixDim%a(p)%col
         numcols = ReshapedMatrixDim%bci_abb(p)%col
         allocate(TempMat(1:numrows,1:numcols))
         TempMat = matmul4(TempReshape(p)%ReshapedMatrix,Reshapes(p)%ReshapedMatrix)
         do q=1,numcols
           do s=1,numrows
             a = Basis_a(p)%basis(1,s)
             b = Basis_bci_abb(p)%basis(1,q)
             c = Basis_bci_abb(p)%basis(2,q)
             i = Basis_bci_abb(p)%basis(3,q)
             syma = Sym_Basis_a(p)%basis(1,s)
             symb = Sym_Basis_bci_abb(p)%basis(1,q)
             symc = Sym_Basis_bci_abb(p)%basis(2,q)
             symi = Sym_Basis_bci_abb(p)%basis(3,q)
             d2symgp = ProductTable(syma,symi)
             d2symgp = ProductTable(symb,symc)
             d2row = IbD2ab(d2symgp)%ib(a,i)
             d2col = IbD2ab(d2symgp)%ib(b,c)
             D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = TempMat(s,q) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
             D2matrix%ab%irrep(d2symgp)%block(d2col,d2row) = TempMat(s,q) + D2matrix%ab%irrep(d2symgp)%block(d2col,d2row)
           end do
         end do
         deallocate(TempMat)
       end do
       deallocate(TempReshape,Reshapes)






     allocate(DerivReshapes(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     allocate(TempReshape(1:numSG))
     do symgp=1,numSG
       do t=1,numSG
         p = InvPdt(symgp)%upper(t)
         q = InvPdt(symgp)%lower(t)
         a_begin = virt(1,p)
         a_end   = virt(2,p)
         i_begin = occ(1,q)
         i_end   = occ(2,q)
         j_begin = occ(1,p)
         j_end   = occ(2,p)
         b_begin = virt(1,q)
         b_end   = virt(2,q)
         do a=a_begin,a_end
           do j=j_begin,j_end
             do b=b_begin,b_end
               do i=i_begin,i_end
                 d2symgp = ProductTable(q,p)
                 d2row = IbD2aa(d2symgp)%ib(i,a)
                 d2col = IbD2aa(d2symgp)%ib(j,b)
                 D2matrix%aa%irrep(d2symgp)%block(d2row,d2col) = -1*T1data%a%o(j)%vsym(p)%v(a)*T1data%a%o(i)%vsym(q)%v(b) + D2matrix%aa%irrep(d2symgp)%block(d2row,d2col)
               end do
             end do
           end do
         end do
       end do
     end do


     do symgp=1,numSG
       do t=1,numSG
         p = InvPdt(symgp)%upper(t)
         q = InvPdt(symgp)%lower(t)
         a_begin = virt(1,p)
         a_end   = virt(2,p)
         i_begin = occ(1,q)
         i_end   = occ(2,q)
         j_begin = occ(1,p)
         j_end   = occ(2,p)
         b_begin = virt(1,q)
         b_end   = virt(2,q)
         do a=a_begin,a_end
           do j=j_begin,j_end
             do b=b_begin,b_end
               do i=i_begin,i_end
                 d2symgp = ProductTable(q,p)
                 d2row = IbD2ab(d2symgp)%ib(i,a)
                 d2col = IbD2ab(d2symgp)%ib(b,j)
                 D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = 1*T1data%a%o(j)%vsym(p)%v(a)*T1data%a%o(i)%vsym(q)%v(b) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
                 D2matrix%ab%irrep(d2symgp)%block(d2col,d2row) = 1*T1data%a%o(j)%vsym(p)%v(a)*T1data%a%o(i)%vsym(q)%v(b) + D2matrix%ab%irrep(d2symgp)%block(d2col,d2row)
               end do
             end do
           end do
         end do
       end do
     end do



       do symgp=1,numSG
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                    row = row + 1
                    col = 1
                   do i=i_begin,i_end
                     if(i.eq.j.and.r.eq.q) then
                       d2row = IbD2aa(ProductTable(symgp,r))%ib(i,a)
                       d2col = IbD2aa(ProductTable(q,s))%ib(j,k)
                       d2symgp = ProductTable(symgp,r)
                       d1row = a - a_begin + 1 + numocc_sg(r)
                       d1col = k - k_begin + 1

                       D2matrix%aa%irrep(d2symgp)%block(d2row,d2col) = D1cum(r)%D1block(d1row,d1col) +  D2matrix%aa%irrep(d2symgp)%block(d2row,d2col)
                       D2matrix%aa%irrep(d2symgp)%block(d2col,d2row) = D1cum(r)%D1block(d1row,d1col) +  D2matrix%aa%irrep(d2symgp)%block(d2col,d2row)
                     end if
                     if(i.eq.k.and.r.eq.s) then
                       d2row = IbD2aa(ProductTable(symgp,r))%ib(i,a)
                       d2col = IbD2aa(ProductTable(q,s))%ib(j,k)
                       d2symgp = ProductTable(symgp,r)
                       d1row = a - a_begin + 1 + numocc_sg(r)
                       d1col = j - j_begin + 1
                       D2matrix%aa%irrep(d2symgp)%block(d2row,d2col) = -1*D1cum(r)%D1block(d1row,d1col) +  D2matrix%aa%irrep(d2symgp)%block(d2row,d2col)
                       D2matrix%aa%irrep(d2symgp)%block(d2col,d2row) = -1*D1cum(r)%D1block(d1row,d1col) +  D2matrix%aa%irrep(d2symgp)%block(d2col,d2row)

                    end if
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do



       do symgp=1,numSG
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do k=k_begin,k_end
                 do a=a_begin,a_end
                   do i=i_begin,i_end
                     if(i.eq.j.and.r.eq.q) then
                       d2symgp = ProductTable(symgp,r)
                       d2symgp = ProductTable(s,q)
                       d2row = IbD2ab(d2symgp)%ib(i,a)
                       d2col = IbD2ab(d2symgp)%ib(j,k)
                       D1row = a - a_begin + 1 + numocc_sg(r)
                       D1col = k - k_begin + 1
                       D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = D1cum(r)%D1block(D1row,D1col) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
                       D2matrix%ab%irrep(d2symgp)%block(d2col,d2row) = D1cum(r)%D1block(D1row,D1col) + D2matrix%ab%irrep(d2symgp)%block(d2col,d2row)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         i_begin = occ(1,symgp)
         i_end   = occ(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=k_begin,k_end
                   do i=i_begin,i_end
                      if(i.eq.k.and.r.eq.s) then
                       d2row = IbD2ab(ProductTable(symgp,r))%ib(a,i)
                       d2col = IbD2ab(ProductTable(q,s))%ib(j,k)
                       d2symgp = ProductTable(symgp,r)
                       d1row = a - a_begin + 1 + numocc_sg(r)
                       d1col = j - j_begin + 1
                       D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = 1*D1cum(r)%D1block(d1row,d1col) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
                       D2matrix%ab%irrep(d2symgp)%block(d2col,d2row) = 1*D1cum(r)%D1block(d1row,d1col) + D2matrix%ab%irrep(d2symgp)%block(d2col,d2row)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

D2outputfile = trim(filename) // 'D2aa'
open(unit=1,file=D2outputfile,action='write')
do i=1,numSG
  rowdim = ReshapedMatrixDim%ijaa(i)%col + ReshapedMatrixDim%ajaa(i)%col + ReshapedMatrixDim%ijaa(i)%row
  write(1,*) rowdim
end do

do p=1,numSG
  rowdim = ReshapedMatrixDim%ijaa(p)%col + ReshapedMatrixDim%ajaa(p)%col + ReshapedMatrixDim%ijaa(p)%row
  do i=1,rowdim
    do j=1,rowdim
      write(1,*) D2matrix%aa%irrep(p)%block(j,i)
    end do
  end do
end do
close(1)
D2outputfile = trim(filename) // 'D2ab'
open(unit=1,file=D2outputfile,action='write')
do i=1,numSG
  rowdim = ReshapedMatrixDim%ijab(i)%row + ReshapedMatrixDim%ijab(i)%col + 2*ReshapedMatrixDim%ajab(i)%col
  write(1,*) rowdim
end do
do p=1,numSG
  rowdim = ReshapedMatrixDim%ijab(p)%row + ReshapedMatrixDim%ijab(p)%col + 2*ReshapedMatrixDim%ajab(p)%col
  do i=1,rowdim
    do j=1,rowdim
      write(1,*) D2matrix%ab%irrep(p)%block(j,i)
    end do
  end do
end do
close(1)
           write(*,*) 'D2outputfile name ', D2outputfile
       Call BuildQ2G2CS(D2matrix,D1cum,IbD2aa,IbD2ab,occ,virt,InvPdt,ProductTable,numSG,ReshapedMatrixDim,filename)


       end subroutine BuildD2

!> @brief Helper routine for BuildD2 (to determine position of a given matrix element)
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine MapD2(numSG,occ,virt,ReshapedMatrixDim,IbD2aa,IbD2ab, Basis_ajaa, Basis_ajab, Basis_jaab,Basis_jka_aaa, Basis_bci_aaa,Basis_jka_aba, Basis_jka_abb, Basis_bci_aba, Basis_bci_abb,Basis_i,Basis_a,Sym_Basis_jka_aaa, Sym_Basis_bci_aaa,Sym_Basis_jka_aba, Sym_Basis_jka_abb, Sym_Basis_bci_aba,Sym_Basis_bci_abb,Sym_Basis_i, Sym_Basis_a,InvPdt,Sym_Basis_ajaa, Sym_Basis_ajab, Sym_Basis_jaab)


       Use InterfaceMod
       Use TypeMod
       Implicit NONE
       integer :: numSG
       integer, intent(IN), dimension(1:2,1:numSG) :: occ,virt
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim

       type(BasisMap2), allocatable, dimension(:) :: D2aabasis, D2abbasis
       type(InverseBasis2), allocatable, dimension(:) :: IbD2aa
       type(InverseBasis2), allocatable, dimension(:) :: IbD2ab
       type(BasisMap2), allocatable, dimension(:) :: Basis_ajaa, Basis_ajab, Basis_jaab
       type(BasisMap3), allocatable, dimension(:) :: Basis_jka_aaa, Basis_bci_aaa
       type(BasisMap3), allocatable, dimension(:) :: Basis_jka_aba, Basis_jka_abb, Basis_bci_aba, Basis_bci_abb
       type(BasisMap1), allocatable, dimension(:) :: Basis_i,Basis_a
       type(BasisMap2), allocatable, dimension(:) :: Sym_Basis_ajaa, Sym_Basis_ajab, Sym_Basis_jaab
       type(BasisMap3), allocatable, dimension(:) :: Sym_Basis_jka_aaa, Sym_Basis_bci_aaa
       type(BasisMap3), allocatable, dimension(:) :: Sym_Basis_jka_aba, Sym_Basis_jka_abb, Sym_Basis_bci_aba, Sym_Basis_bci_abb
       type(BasisMap1), allocatable, dimension(:) :: Sym_Basis_i, Sym_Basis_a
       type(symmetry), intent(IN) :: InvPdt(1:numSG)


       integer :: i,j,a,b,i_begin,i_end,j_begin,j_end,a_begin,a_end,b_begin,b_end,numj
       integer :: symgp,numocc,numvirt
       integer :: t,u,col,q,p,r,s, k_begin,k_end,numk,numa,k,numi,c_begin,c_end,numc,numb,c
       integer :: numrow,numcol
       integer, allocatable, dimension(:) :: coloffset

       allocate(coloffset(1:numSG))
       coloffset(1:numSG) = 0.D0

       numocc = 0
       numvirt = 0
       do p=1,numSG
         i_begin = occ(1,p)
         i_end   = occ(2,p)
         a_begin = virt(1,p)
         a_end   = virt(2,p)
         numocc = numocc + i_end - i_begin + 1
         numvirt = numvirt + a_end - a_begin + 1
       end do



       allocate(D2aabasis(1:numSG))
       allocate(IbD2aa(1:numSG))
       do symgp=1,numSG
         numrow = ReshapedMatrixDim%ijaa(symgp)%col + ReshapedMatrixDim%ajaa(symgp)%col + ReshapedMatrixDim%ijaa(symgp)%row
         allocate(D2aabasis(symgp)%basis(1:2,1:numrow))
         D2aabasis(symgp)%basis(1:2,1:numrow) = 0
         allocate(IbD2aa(symgp)%ib(1:numocc+numvirt,1:numocc+numvirt))
         IbD2aa(symgp)%ib(1:numocc+numvirt,1:numocc+numvirt) = 0
       end do
       allocate(D2abbasis(1:numSG))
       allocate(IbD2ab(1:numSG))
       do symgp=1,numSG
         numrow = ReshapedmatrixDim%ijab(symgp)%col + 2*ReshapedMatrixDim%ajab(symgp)%col + ReshapedMatrixdim%ijab(symgp)%row
         allocate(D2abbasis(symgp)%basis(1:2,1:numrow))
         D2abbasis(symgp)%basis(1:2,1:numrow) = 0
         allocate(IbD2ab(symgp)%ib(1:numocc+numvirt,1:numocc+numvirt))
         IbD2ab(symgp)%ib(1:numocc+numvirt,1:numocc+numvirt) = 0
       end do
       do symgp=1,numSG
         col = 1
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           if(p.gt.q) then
             cycle
           end if
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               D2aabasis(symgp)%basis(1,col) = i
               D2aabasis(symgp)%basis(2,col) = j
               IbD2aa(symgp)%ib(i,j) = col
               IbD2aa(symgp)%ib(j,i) = col
               coloffset(symgp) = col
               col = col + 1
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = coloffset(symgp) + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           i_begin = occ(1,q)
           i_end   = occ(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               D2aabasis(symgp)%basis(1,col) = i
               D2aabasis(symgp)%basis(2,col) = a
               IbD2aa(symgp)%ib(i,a) = col
               IbD2aa(symgp)%ib(a,i) = col
               coloffset(symgp) = col
               col = col + 1
             end do
           end do
         end do
       end do
      do symgp=1,numSG
        col = coloffset(symgp) + 1
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          if(p.gt.q) then
            cycle
          end if
          a_begin = virt(1,p)
          a_end   = virt(2,p)
          b_begin = virt(1,q)
          b_end   = virt(2,q)
          do a=a_begin,a_end
            do b=max(a+1,b_begin),b_end
              D2aabasis(symgp)%basis(1,col) = a
              D2aabasis(symgp)%basis(2,col) = b
              IbD2aa(symgp)%ib(a,b) = col
              IbD2aa(symgp)%ib(b,a) = col
              col = col + 1
             end do
           end do
         end do
       end do
        coloffset(1:numSG) = 0
        do symgp=1,numSG
         col = 1
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               D2abbasis(symgp)%basis(1,col) = i
               D2abbasis(symgp)%basis(2,col) = j
               IbD2ab(symgp)%ib(i,j) = col
               coloffset(symgp) = col
               col = col + 1
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = coloffset(symgp) + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           i_begin = occ(1,q)
           i_end   = occ(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               D2abbasis(symgp)%basis(1,col) = i
               D2abbasis(symgp)%basis(2,col) = a
               coloffset(symgp) = col
               IbD2ab(symgp)%ib(i,a) = col
               col = col + 1
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = coloffset(symgp) + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           i_begin = occ(1,q)
           i_end   = occ(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               D2abbasis(symgp)%basis(1,col) = a
               D2abbasis(symgp)%basis(2,col) = i
               coloffset(symgp) = col
               IbD2ab(symgp)%ib(a,i) = col
               col = col + 1
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = coloffset(symgp) + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           b_begin = virt(1,q)
           b_end   = virt(2,q)
           do a=a_begin,a_end
             do b=b_begin,b_end
               D2abbasis(symgp)%basis(1,col) = a
               D2abbasis(symgp)%basis(2,col) = b
               IbD2ab(symgp)%ib(a,b) = col
               col = col + 1
              end do
            end do
          end do
        end do



       allocate(Basis_ajaa(1:numSG))
       allocate(Sym_Basis_ajaa(1:numSG))
       do symgp=1,numSG
         numrow = ReshapedMatrixDim%ajaa(symgp)%col
         allocate(Basis_ajaa(symgp)%basis(1:2,1:numrow))
         Basis_ajaa(symgp)%basis(1:2,1:numrow) = 0
         allocate(Sym_Basis_ajaa(symgp)%basis(1:2,1:numrow))
         Sym_Basis_ajaa(symgp)%basis(1:2,1:numrow) = 0
       end do

       do symgp=1,numSG
         col = 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               Basis_ajaa(symgp)%basis(1,col) = j
               Basis_ajaa(symgp)%basis(2,col) = a
               Sym_Basis_ajaa(symgp)%basis(1,col) = q
               Sym_Basis_ajaa(symgp)%basis(2,col) = p
               col = col + 1
             end do
           end do
         end do
       end do

       allocate(Basis_ajab(1:numSG))
       allocate(Sym_Basis_ajab(1:numSG))
       do symgp=1,numSG
         numrow = ReshapedMatrixDim%ajab(symgp)%col
         allocate(Basis_ajab(symgp)%basis(1:2,1:numrow))
         Basis_ajab(symgp)%basis(1:2,1:numrow) = 0
         allocate(Sym_Basis_ajab(symgp)%basis(1:2,1:numrow))
         Sym_Basis_ajab(symgp)%basis(1:2,1:numrow) = 0
      end do

       do symgp=1,numSG
         col = 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do a=a_begin,a_end
             do j=j_begin,j_end
               Basis_ajab(symgp)%basis(1,col) = a
               Basis_ajab(symgp)%basis(2,col) = j
               Sym_Basis_ajab(symgp)%basis(1,col) = p
               Sym_Basis_ajab(symgp)%basis(2,col) = q
               coloffset(symgp) = col
               col = col + 1
             end do
           end do
         end do
       end do

      allocate(Basis_jaab(1:numSG))
      allocate(Sym_Basis_jaab(1:numSG))
      do symgp=1,numSG
        numrow = ReshapedMatrixDim%ajba(symgp)%col
        allocate(Basis_jaab(symgp)%basis(1:2,1:numrow))
        Basis_jaab(symgp)%basis(1:2,1:numrow) = 0
        allocate(Sym_Basis_jaab(symgp)%basis(1:2,1:numrow))
        Sym_Basis_jaab(symgp)%basis(1:2,1:numrow) = 0
      end do

       do symgp=1,numSG
         col =  1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do a=a_begin,a_end
             do j=j_begin,j_end
               Basis_jaab(symgp)%basis(1,col) = j
               Basis_jaab(symgp)%basis(2,col) = a
               Sym_Basis_jaab(symgp)%basis(1,col) = q
               Sym_Basis_jaab(symgp)%basis(2,col) = p
               coloffset(symgp) = col
               col = col + 1
             end do
           end do
         end do
       end do


       allocate(Basis_jka_aaa(1:numSG))
       allocate(Sym_Basis_jka_aaa(1:numSG))
       do symgp=1,numSG
         numrow = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           numk = k_end - k_begin + 1
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             numa = a_end - a_begin + 1
             numj = j_end - j_begin + 1
             if(j_begin.eq.k_begin) then
               numrow = numrow + numj*(numk-1)*numa/2
             else
               numrow = numrow + numj*numk*numa
             end if
           end do
         end do
         allocate(Basis_jka_aaa(symgp)%basis(1:3,1:numrow))
         Basis_jka_aaa(symgp)%basis(1:3,1:numrow) = 0
         allocate(Sym_Basis_jka_aaa(symgp)%basis(1:3,1:numrow))
         Sym_Basis_jka_aaa(symgp)%basis(1:3,1:numrow) = 0
       end do

       do symgp=1,numSG
         col = 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                   Basis_jka_aaa(symgp)%basis(1,col) = j
                   Basis_jka_aaa(symgp)%basis(2,col) = k
                   Basis_jka_aaa(symgp)%basis(3,col) = a
                   Sym_Basis_jka_aaa(symgp)%basis(1,col) = s
                   Sym_Basis_jka_aaa(symgp)%basis(2,col) = q
                   Sym_Basis_jka_aaa(symgp)%basis(3,col) = r
                   col = col + 1
                 end do
               end do
             end do
           end do
         end do
       end do
      allocate(Basis_i(1:numSG))
      allocate(Sym_Basis_i(1:numSG))
      do symgp=1,numSG
        col = 1
        i_begin = occ(1,symgp)
        i_end   = occ(2,symgp)
        numi = i_end - i_begin + 1
        allocate(Basis_i(symgp)%basis(1:1,1:numi))
        Basis_i(symgp)%basis(1,1:numi) = 0
        allocate(Sym_Basis_i(symgp)%basis(1,1:numi))
        Sym_Basis_i(symgp)%basis(1,1:numi) = 0
        do i=i_begin,i_end
          Basis_i(symgp)%basis(1,col) = i
          Sym_Basis_i(symgp)%basis(1,col) = symgp
          col = col + 1
        end do
      end do

       allocate(Basis_bci_aaa(1:numSG))
       allocate(Sym_Basis_bci_aaa(1:numSG))
       do symgp=1,numSG
         numcol = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           numc = c_end - c_begin + 1
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             numb = b_end - b_begin + 1
             numi = i_end - i_begin + 1
             if(c_begin.eq.b_begin) then
               numcol = numcol + numi*numb*(numc-1)/2
             else
               numcol = numcol + numi*numb*numc
             end if
          end do
         end do
        allocate(Basis_bci_aaa(symgp)%basis(1:3,1:numcol))
        Basis_bci_aaa(symgp)%basis(1:3,1:numcol) = 0
        allocate(Sym_Basis_bci_aaa(symgp)%basis(1:3,1:numcol))
        Sym_Basis_bci_aaa(symgp)%basis(1:3,1:numcol) = 0
      end do

       do symgp=1,numSG
         col = 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=max(c_begin,b+1),c_end
                   Basis_bci_aaa(symgp)%basis(1,col) = b
                   Basis_bci_aaa(symgp)%basis(2,col) = c
                   Basis_bci_aaa(symgp)%basis(3,col) = i
                   Sym_Basis_bci_aaa(symgp)%basis(1,col) = r
                   Sym_Basis_bci_aaa(symgp)%basis(2,col) = q
                   Sym_Basis_bci_aaa(symgp)%basis(3,col) = s
                   col = col + 1
                 end do
              end do
            end do
          end do
         end do
      end do
      allocate(Basis_a(1:numSG))
      allocate(Sym_Basis_a(1:numSG))
      do symgp=1,numSG
        col = 1
        a_begin = virt(1,symgp)
        a_end   = virt(2,symgp)
        numa = a_end - a_begin + 1
        allocate(Basis_a(symgp)%basis(1:1,1:numa))
        Basis_a(symgp)%basis(1,1:numa) = 0
        allocate(Sym_Basis_a(symgp)%basis(1:1,1:numa))
        Sym_Basis_a(symgp)%basis(1:1,1:numa) = 0
        do a=a_begin,a_end
          Basis_a(symgp)%basis(1,col) = a
          Sym_Basis_a(symgp)%basis(1,col) = symgp
          col = col + 1
        end do
      end do
     allocate(Basis_jka_aba(1:numSG))
     allocate(Sym_Basis_jka_aba(1:numSG))
       do symgp=1,numSG
         numcol = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           numk = k_end - k_begin + 1
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             numa = a_end - a_begin + 1
             numj = j_end - j_begin + 1
             numcol = numcol + numa*numj*numk
           end do
         end do

         allocate(Basis_jka_aba(symgp)%basis(1:3,1:numcol))
         Basis_jka_aba(symgp)%basis(1:3,1:numcol) = 0
         allocate(Sym_Basis_jka_aba(symgp)%basis(1:3,1:numcol))
         Sym_Basis_jka_aba(symgp)%basis(1:3,1:numcol) = 0
       end do
       do symgp=1,numSG
         col = 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=k_begin,k_end
                   Basis_jka_aba(symgp)%basis(1,col) = j
                   Basis_jka_aba(symgp)%basis(2,col) = k
                   Basis_jka_aba(symgp)%basis(3,col) = a
                   Sym_Basis_jka_aba(symgp)%basis(1,col) = s
                   Sym_Basis_jka_aba(symgp)%basis(2,col) = q
                   Sym_Basis_jka_aba(symgp)%basis(3,col) = r
                   col = col + 1
                 end do
               end do
             end do
          end do
        end do
      end do
      allocate(Basis_jka_abb(1:numSG))
      allocate(Sym_Basis_jka_abb(1:numSG))
       do symgp=1,numSG
         numcol = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           numk = k_end - k_begin + 1
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             numa = a_end - a_begin + 1
             numj = j_end - j_begin + 1
             numcol = numcol + numk*numj*numa
           end do
         end do
       allocate(Basis_jka_abb(symgp)%basis(1:3,1:numcol))
       Basis_jka_abb(symgp)%basis(1:3,1:numcol) = 0
       allocate(Sym_Basis_jka_abb(symgp)%basis(1:3,1:numcol))
       Sym_Basis_jka_abb(symgp)%basis(1:3,1:numcol) = 0
      end do

       do symgp=1,numSG
         col = 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ(1,q)
           k_end   = occ(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt(1,r)
             a_end   = virt(2,r)
             j_begin = occ(1,s)
             j_end   = occ(2,s)
             do j=j_begin,j_end
               do k=k_begin,k_end
                 do a=a_begin,a_end
                   Basis_jka_abb(symgp)%basis(1,col) = j
                   Basis_jka_abb(symgp)%basis(2,col) = k
                   Basis_jka_abb(symgp)%basis(3,col) = a
                   Sym_Basis_jka_abb(symgp)%basis(1,col) = s
                   Sym_Basis_jka_abb(symgp)%basis(2,col) = q
                   Sym_Basis_jka_abb(symgp)%basis(3,col) = r
                   col = col + 1
                 end do
               end do
             end do
           end do
         end do
       end do

       allocate(Basis_bci_aba(1:numSG))
       allocate(Sym_Basis_bci_aba(1:numSG))
       do symgp=1,numSG
         numcol = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           numc = c_end - c_begin + 1
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             numb = b_end - b_begin + 1
             numi = i_end - i_begin + 1
             numcol = numcol + numc*numb*numi
           end do
         end do
       allocate(Basis_bci_aba(symgp)%basis(1:3,1:numcol))
       Basis_bci_aba(symgp)%basis(1:3,1:numcol) = 0
       allocate(Sym_Basis_bci_aba(symgp)%basis(1:3,1:numcol))
       Sym_Basis_bci_aba(symgp)%basis(1:3,1:numcol) = 0
      end do

       do symgp=1,numSG
         col = 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=c_begin,c_end
                   Basis_bci_aba(symgp)%basis(1,col) = b
                   Basis_bci_aba(symgp)%basis(2,col) = c
                   Basis_bci_aba(symgp)%basis(3,col) = i
                   Sym_Basis_bci_aba(symgp)%basis(1,col) = r
                   Sym_Basis_bci_aba(symgp)%basis(2,col) = q
                   Sym_Basis_bci_aba(symgp)%basis(3,col) = s
                   col = col + 1
                 end do
               end do
             end do
           end do
         end do
       end do

      allocate(Basis_bci_abb(1:numSG))
      allocate(Sym_Basis_bci_abb(1:numSG))
       do symgp=1,numSG
         numcol = 0
         j_begin = occ(1,symgp)
         j_end   = occ(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           numc = c_end - c_begin + 1
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             numb = b_end - b_begin + 1
             numi = i_end - i_begin + 1
             numcol = numcol + numc*numb*numi
           end do
         end do
         allocate(Basis_bci_abb(symgp)%basis(1:3,1:numcol))
         Basis_bci_abb(symgp)%basis(1:3,1:numcol) = 0
         allocate(Sym_Basis_bci_abb(symgp)%basis(1:3,1:numcol))
         Sym_Basis_bci_abb(symgp)%basis(1:3,1:numcol) = 0
       end do
       do symgp=1,numSG
         col = 1
         j_begin = occ(1,symgp)
         j_end   = occ(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt(1,r)
             b_end   = virt(2,r)
             i_begin = occ(1,s)
             i_end   = occ(2,s)
             do b=b_begin,b_end
               do i=i_begin,i_end
                 do c=c_begin,c_end
                   Basis_bci_abb(symgp)%basis(1,col) = b
                   Basis_bci_abb(symgp)%basis(2,col) = c
                   Basis_bci_abb(symgp)%basis(3,col) = i
                   Sym_Basis_bci_abb(symgp)%basis(1,col) = r
                   Sym_Basis_bci_abb(symgp)%basis(2,col) = q
                   Sym_Basis_bci_abb(symgp)%basis(3,col) = s
                   col = col + 1
                 end do
               end do
             end do
           end do
         end do
       end do
      end subroutine MapD2

!> @brief Manages the parameter arrays for open shell calculations
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine DataStructureOS(T2data,numocc_alpha, numocc_beta,numvirt_alpha,numvirt_beta,InvPdt,numSG,occ_alpha, occ_beta,virt_alpha,virt_beta,ProductTable,Sym_alpha,Sym_beta,T2deriv,flag,numElements,T1data,T1deriv,Newc,DerivNewc,inputfile,T2derivT1topfac,Newc_singles,DerivNewc_singles)
       USE TypeMod
       USE InterfaceMod
       Use TimeMod, only : time_datastructure
       Implicit NONE

       integer :: numocc_alpha,numocc_beta,numvirt_alpha,numvirt_beta,numSG
       integer, intent(IN), allocatable, dimension(:) :: Sym_alpha, Sym_beta
       type(symmetry), allocatable, dimension(:) :: InvPdt
       type(T2) :: T2data, T2deriv, Newc,DerivNewc,T2derivT1topfac
       type(T1) :: T1data, T1deriv, Newc_singles, DerivNewc_singles
       integer, intent(IN), allocatable, dimension(:,:) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, allocatable, dimension(:,:) :: ProductTable
       integer :: flag
       integer :: numElements
       character(len=100) :: inputfile

       integer :: t,tempNumElements
       integer :: a,j,i,b,i_begin,i_end,b_begin,b_end,isym,bsym,symtop
       integer :: a_begin, j_begin, a_end, j_end
       real :: time_begin, time_end
       integer :: ioerror
       character(len=100) :: T2file
       logical :: lexist
      Call CPU_TIME(time_begin)
     if(flag==0)  then

       allocate(T2data%aa%m(numocc_alpha+1:numocc_alpha+numvirt_alpha,1:numocc_alpha))
       allocate(T2data%ab%m(numocc_alpha+1:numocc_alpha+numvirt_alpha,1:numocc_alpha))
       allocate(T2data%bb%m(numocc_beta+1:numocc_beta+numvirt_beta,1:numocc_beta))
       allocate(T2deriv%aa%m(numocc_alpha+1:numocc_alpha+numvirt_alpha,1:numocc_alpha))
       allocate(T2deriv%ab%m(numocc_alpha+1:numocc_alpha+numvirt_alpha,1:numocc_alpha))
       allocate(T2deriv%bb%m(numocc_beta+1:numocc_beta+numvirt_beta,1:numocc_beta))
       allocate(T1data%a%o(1:numocc_alpha))
       allocate(T1data%b%o(1:numocc_beta))
       allocate(T1deriv%a%o(1:numocc_alpha))
       allocate(T1deriv%b%o(1:numocc_beta))
       allocate(Newc_singles%a%o(1:numocc_alpha))
       allocate(Newc_singles%b%o(1:numocc_beta))
       allocate(DerivNewc_singles%a%o(1:numocc_alpha))
       allocate(DerivNewc_singles%b%o(1:numocc_beta))

       allocate(Newc%aa%m(numocc_alpha+1:numocc_alpha+numvirt_alpha,1:numocc_alpha))
       allocate(Newc%ab%m(numocc_alpha+1:numocc_alpha+numvirt_alpha,1:numocc_alpha))
       allocate(Newc%bb%m(numocc_beta+1:numocc_beta+numvirt_beta,1:numocc_beta))
       allocate(DerivNewc%aa%m(numocc_alpha+1:numocc_alpha+numvirt_alpha,1:numocc_alpha))
       allocate(DerivNewc%ab%m(numocc_alpha+1:numocc_alpha+numvirt_alpha,1:numocc_alpha))
       allocate(DerivNewc%bb%m(numocc_beta+1:numocc_beta+numvirt_beta,1:numocc_beta))
       allocate(T2derivT1topfac%aa%m(numocc_alpha+1:numocc_alpha+numvirt_alpha,1:numocc_alpha))
       allocate(T2derivT1topfac%ab%m(numocc_alpha+1:numocc_alpha+numvirt_alpha,1:numocc_alpha))
       allocate(T2derivT1topfac%bb%m(numocc_beta+1:numocc_beta+numvirt_beta,1:numocc_beta))


       do j=1,numocc_alpha
          do a = numocc_alpha+1, numocc_alpha+numvirt_alpha
             allocate(T2data%aa%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(T2data%ab%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(T2deriv%aa%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(T2deriv%ab%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(Newc%aa%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(Newc%ab%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(DerivNewc%aa%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(DerivNewc%ab%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(T2derivT1topfac%aa%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(T2derivT1topfac%ab%m(a,j)%nsym(1:numSG,1:numSG))
          end do
       end do
       do j=1,numocc_beta
          do a = numocc_beta+1, numocc_beta+numvirt_beta
             allocate(T2data%bb%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(T2deriv%bb%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(Newc%bb%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(DerivNewc%bb%m(a,j)%nsym(1:numSG,1:numSG))
             allocate(T2derivT1topfac%bb%m(a,j)%nsym(1:numSG,1:numSG))
          end do
       end do
       do j=1,numocc_alpha
           allocate(T1data%a%o(j)%vsym(1:numSG))
           allocate(T1deriv%a%o(j)%vsym(1:numSG))
           allocate(Newc_singles%a%o(j)%vsym(1:numSG))
           allocate(DerivNewc_singles%a%o(j)%vsym(1:numSG))
       end do

        do j=1,numocc_beta
           allocate(T1data%b%o(j)%vsym(1:numSG))
           allocate(T1deriv%b%o(j)%vsym(1:numSG))
           allocate(Newc_singles%b%o(j)%vsym(1:numSG))
           allocate(DerivNewc_singles%b%o(j)%vsym(1:numSG))
       end do


       numElements = 0
       do j=1,numocc_alpha
         do a=numocc_alpha+1,numocc_alpha+numvirt_alpha
           symtop = ProductTable(Sym_alpha(a),Sym_alpha(j))
           do t=1,numSG
             bsym = InvPdt(symtop)%upper(t)
             isym = InvPdt(symtop)%lower(t)
             i_begin = occ_alpha(1,isym)
             i_end   = occ_alpha(2,isym)
             b_begin = virt_alpha(1,bsym)
             b_end   = virt_alpha(2,bsym)
             allocate(T2data%aa%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             allocate(T2deriv%aa%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             allocate(Newc%aa%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             allocate(DerivNewc%aa%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             allocate(T2derivT1topfac%aa%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             T2data%aa%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end) = 0.D0
             T2deriv%aa%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end) = 0.D0
             Newc%aa%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end) = 0.D0
             DerivNewc%aa%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end) = 0.D0
             T2derivT1topfac%aa%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end) = 0.D0
             numElements = numElements + (b_end - b_begin + 1) * (i_end - i_begin + 1)
           end do
         end do
       end do

       do j=1,numocc_alpha
         do a=numocc_alpha+1,numocc_alpha+numvirt_alpha
           symtop = ProductTable(Sym_alpha(a),Sym_alpha(j))
           do t=1,numSG
             bsym = InvPdt(symtop)%upper(t)
             isym = InvPdt(symtop)%lower(t)
             i_begin = occ_beta(1,isym)
             i_end   = occ_beta(2,isym)
             b_begin = virt_beta(1,bsym)
             b_end   = virt_beta(2,bsym)
             allocate(T2data%ab%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             allocate(T2deriv%ab%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             allocate(Newc%ab%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             allocate(DerivNewc%ab%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             allocate(T2derivT1topfac%ab%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             T2data%ab%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end) = 0.D0
             T2deriv%ab%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end) = 0.D0
             Newc%ab%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end) = 0.D0
             DerivNewc%ab%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end) = 0.D0
             T2derivT1topfac%ab%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end) = 0.D0
             numElements = numElements + (b_end - b_begin + 1) * (i_end - i_begin + 1)
           end do
         end do
       end do

       do j=1,numocc_beta
         do a=numocc_beta+1,numocc_beta+numvirt_beta
           symtop = ProductTable(Sym_beta(a),Sym_beta(j))
           do t=1,numSG
             bsym = InvPdt(symtop)%upper(t)
             isym = InvPdt(symtop)%lower(t)
             i_begin = occ_beta(1,isym)
             i_end   = occ_beta(2,isym)
             b_begin = virt_beta(1,bsym)
             b_end   = virt_beta(2,bsym)
             allocate(T2data%bb%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             allocate(T2deriv%bb%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             allocate(Newc%bb%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             allocate(DerivNewc%bb%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             allocate(T2derivT1topfac%bb%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end))
             T2data%bb%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end) = 0.D0
             T2deriv%bb%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end) = 0.D0
             Newc%bb%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end) = 0.D0
             DerivNewc%bb%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end) = 0.D0
             T2derivT1topfac%bb%m(a,j)%nsym(bsym,isym)%n(b_begin:b_end,i_begin:i_end) = 0.D0
             numElements = numElements + (b_end - b_begin + 1) * (i_end - i_begin + 1)

           end do

         end do
       end do

       do j=1,numocc_alpha
         symtop = Sym_alpha(j)
         a_begin = virt_alpha(1,symtop)
         a_end   = virt_alpha(2,symtop)
         numElements = numElements + a_end - a_begin + 1
         allocate(T1data%a%o(j)%vsym(symtop)%v(a_begin:a_end))
         T1data%a%o(j)%vsym(symtop)%v(a_begin:a_end) = 0.0D0
         allocate(T1deriv%a%o(j)%vsym(symtop)%v(a_begin:a_end))
         T1deriv%a%o(j)%vsym(symtop)%v(a_begin:a_end) = 0.0D0
         allocate(Newc_singles%a%o(j)%vsym(symtop)%v(a_begin:a_end))
         Newc_singles%a%o(j)%vsym(symtop)%v(a_begin:a_end) = 0.D0
         allocate(DerivNewc_singles%a%o(j)%vsym(symtop)%v(a_begin:a_end))
         DerivNewc_singles%a%o(j)%vsym(symtop)%v(a_begin:a_end) = 0.D0
      end do


       do j=1,numocc_beta
         symtop = Sym_beta(j)
         a_begin = virt_beta(1,symtop)
         a_end   = virt_beta(2,symtop)
         numElements = numElements + a_end - a_begin + 1
         allocate(T1data%b%o(j)%vsym(symtop)%v(a_begin:a_end))
         T1data%b%o(j)%vsym(symtop)%v(a_begin:a_end) = 0.0D0
         allocate(T1deriv%b%o(j)%vsym(symtop)%v(a_begin:a_end))
         T1deriv%b%o(j)%vsym(symtop)%v(a_begin:a_end) = 0.0D0
         allocate(Newc_singles%b%o(j)%vsym(symtop)%v(a_begin:a_end))
         Newc_singles%b%o(j)%vsym(symtop)%v(a_begin:a_end) = 0.0D0
         allocate(DerivNewc_singles%b%o(j)%vsym(symtop)%v(a_begin:a_end))
         DerivNewc_singles%b%o(j)%vsym(symtop)%v(a_begin:a_end) = 0.0D0
      end do




       T2file = trim(inputfile) // 'T2'
       inquire(file=T2file,exist=lexist)
       if(lexist.eqv..TRUE.) then
         open(unit=25,file=T2file,action='read',iostat=ioerror)
         read(25,*) tempNumElements
         if(tempNumElements.eq.numElements) then
          do j=1,numocc_alpha
            do a=numocc_alpha+1,numocc_alpha+numvirt_alpha
             symtop = ProductTable(Sym_alpha(a),Sym_alpha(j))
            do t=1,numSG
            bsym = InvPdt(symtop)%upper(t)
            isym = InvPdt(symtop)%lower(t)
            b_begin = virt_alpha(1,bsym)
            b_end   = virt_alpha(2,bsym)
            i_begin = occ_alpha(1,isym)
            i_end   = occ_alpha(2,isym)
            do i=i_begin,i_end
              do b=b_begin,b_end
                read(25,*)  T2data%aa%m(a,j)%nsym(bsym,isym)%n(b,i)
              end do
            end do
          end do
        end do
      end do

      do j=1,numocc_alpha
        do a=numocc_alpha+1,numocc_alpha+numvirt_alpha
          symtop = ProductTable(Sym_alpha(a),Sym_alpha(j))
          do t=1,numSG
            bsym = InvPdt(symtop)%upper(t)
            isym = InvPdt(symtop)%lower(t)
            b_begin = virt_beta(1,bsym)
            b_end   = virt_beta(2,bsym)
            i_begin = occ_beta(1,isym)
            i_end   = occ_beta(2,isym)
            do i=i_begin,i_end
              do b=b_begin,b_end
                read(25,*)  T2data%ab%m(a,j)%nsym(bsym,isym)%n(b,i)
              end do
            end do
          end do
        end do
      end do


      do j=1,numocc_beta
        do a=numocc_beta+1,numocc_beta+numvirt_beta
          symtop = ProductTable(Sym_beta(a),Sym_beta(j))
          do t=1,numSG
            bsym = InvPdt(symtop)%upper(t)
            isym = InvPdt(symtop)%lower(t)
            b_begin = virt_beta(1,bsym)
            b_end   = virt_beta(2,bsym)
            i_begin = occ_beta(1,isym)
            i_end   = occ_beta(2,isym)
            do i=i_begin,i_end
              do b=b_begin,b_end
                read(25,*)  T2data%bb%m(a,j)%nsym(bsym,isym)%n(b,i)
              end do
            end do
          end do
        end do
      end do



       do j=1,numocc_alpha
         symtop = Sym_alpha(j)
         a_begin = virt_alpha(1,symtop)
         a_end   = virt_alpha(2,symtop)
         do a=a_begin,a_end
           read(25,*)  T1data%a%o(j)%vsym(symtop)%v(a)
         end do
      end do

       do j=1,numocc_beta
         symtop = Sym_beta(j)
         a_begin = virt_beta(1,symtop)
         a_end   = virt_beta(2,symtop)
         do a=a_begin,a_end
           read(25,*)  T1data%b%o(j)%vsym(symtop)%v(a)
         end do
      end do
     close(25)
     else
       write(*,*) 'The number of elements in the coefficient file was not correct.'
       write(*,*) 'Please restart after deleting ', trim(T2file)
       stop
     end if
   end if

 end if




      if(flag==1) then
      do j=1,numocc_alpha
        do a=numocc_alpha+1,numocc_alpha+numvirt_alpha
          symtop = ProductTable(Sym_alpha(a),Sym_alpha(j))
          do t=1,numSG
            bsym = InvPdt(symtop)%upper(t)
            isym = InvPdt(symtop)%lower(t)
            b_begin = virt_alpha(1,bsym)
            b_end   = virt_alpha(2,bsym)
            i_begin = occ_alpha(1,isym)
            i_end   = occ_alpha(2,isym)
            do i=i_begin,i_end
              do b=b_begin,b_end
                T2deriv%aa%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                Newc%aa%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                DerivNewc%aa%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
              end do
            end do
          end do
        end do
      end do

      do j=1,numocc_alpha
        do a=numocc_alpha+1,numocc_alpha+numvirt_alpha
          symtop = ProductTable(Sym_alpha(a),Sym_alpha(j))
          do t=1,numSG
            bsym = InvPdt(symtop)%upper(t)
            isym = InvPdt(symtop)%lower(t)
            b_begin = virt_beta(1,bsym)
            b_end   = virt_beta(2,bsym)
            i_begin = occ_beta(1,isym)
            i_end   = occ_beta(2,isym)
            do i=i_begin,i_end
              do b=b_begin,b_end
                T2deriv%ab%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                Newc%ab%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                DerivNewc%ab%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
              end do
            end do
          end do
        end do
      end do

      do j=1,numocc_beta
        do a=numocc_beta+1,numocc_beta+numvirt_beta
          symtop = ProductTable(Sym_beta(a),Sym_beta(j))
          do t=1,numSG
            bsym = InvPdt(symtop)%upper(t)
            isym = InvPdt(symtop)%lower(t)
            b_begin = virt_beta(1,bsym)
            b_end   = virt_beta(2,bsym)
            i_begin = occ_beta(1,isym)
            i_end   = occ_beta(2,isym)
            do i=i_begin,i_end
              do b=b_begin,b_end
                T2deriv%bb%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                Newc%bb%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                DerivNewc%bb%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
              end do
            end do
          end do
        end do
      end do


       do j=1,numocc_alpha
         symtop = Sym_alpha(j)
         a_begin = virt_alpha(1,symtop)
         a_end   = virt_alpha(2,symtop)
         T1deriv%a%o(j)%vsym(symtop)%v(a_begin:a_end) = 0.0
       end do

       do j=1,numocc_beta
         symtop = Sym_beta(j)
         a_begin = virt_beta(1,symtop)
         a_end   = virt_beta(2,symtop)
         T1deriv%b%o(j)%vsym(symtop)%v(a_begin:a_end) = 0.0
       end do

      end if



      if(flag.eq.2) then
      do j=1,numocc_alpha
        do a=numocc_alpha+1,numocc_alpha+numvirt_alpha
          symtop = ProductTable(Sym_alpha(a),Sym_alpha(j))
          do t=1,numSG
            bsym = InvPdt(symtop)%upper(t)
            isym = InvPdt(symtop)%lower(t)
            b_begin = virt_alpha(1,bsym)
            b_end   = virt_alpha(2,bsym)
            i_begin = occ_alpha(1,isym)
            i_end   = occ_alpha(2,isym)
            do i=i_begin,i_end
              do b=b_begin,b_end
                T2data%aa%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                T2deriv%aa%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                Newc%aa%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                DerivNewc%aa%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
              end do
            end do
          end do
        end do
      end do

      do j=1,numocc_alpha
        do a=numocc_alpha+1,numocc_alpha+numvirt_alpha
          symtop = ProductTable(Sym_alpha(a),Sym_alpha(j))
          do t=1,numSG
            bsym = InvPdt(symtop)%upper(t)
            isym = InvPdt(symtop)%lower(t)
            b_begin = virt_beta(1,bsym)
            b_end   = virt_beta(2,bsym)
            i_begin = occ_beta(1,isym)
            i_end   = occ_beta(2,isym)
            do i=i_begin,i_end
              do b=b_begin,b_end
                T2data%ab%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                T2deriv%ab%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                Newc%ab%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                DerivNewc%ab%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
              end do
            end do
          end do
        end do
      end do

      do j=1,numocc_beta
        do a=numocc_beta+1,numocc_beta+numvirt_beta
          symtop = ProductTable(Sym_beta(a),Sym_beta(j))
          do t=1,numSG
            bsym = InvPdt(symtop)%upper(t)
            isym = InvPdt(symtop)%lower(t)
            b_begin = virt_beta(1,bsym)
            b_end   = virt_beta(2,bsym)
            i_begin = occ_beta(1,isym)
            i_end   = occ_beta(2,isym)
            do i=i_begin,i_end
              do b=b_begin,b_end
                T2data%bb%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                T2deriv%bb%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                Newc%bb%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
                DerivNewc%bb%m(a,j)%nsym(bsym,isym)%n(b,i) = 0.0D0
              end do
            end do
          end do
        end do
      end do


       do j=1,numocc_alpha
         symtop = Sym_alpha(j)
         a_begin = virt_alpha(1,symtop)
         a_end   = virt_alpha(2,symtop)
         T1data%a%o(j)%vsym(symtop)%v(a_begin:a_end) = 0.0
         T1deriv%a%o(j)%vsym(symtop)%v(a_begin:a_end) = 0.0
       end do

       do j=1,numocc_beta
         symtop = Sym_beta(j)
         a_begin = virt_beta(1,symtop)
         a_end   = virt_beta(2,symtop)
         T1data%b%o(j)%vsym(symtop)%v(a_begin:a_end) = 0.0
         T1deriv%b%o(j)%vsym(symtop)%v(a_begin:a_end) = 0.0
       end do
      end if


Call CPU_TIME(time_end)
        time_datastructure = time_datastructure + time_end - time_begin
       end subroutine DataStructureOS

!> @brief Calculates the matrix dimensions needed by CalcDeriv for open shell calculations
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine CalcReshapeDimOS(ReshapedMatrixDim,SG,virt_alpha, virt_beta,occ_alpha, occ_beta,ProductTable,InvPdt)

       Use TypeMod
       Use TimeMod, only : time_calcreshapedim
       Implicit NONE

       type(ReshapedDim) :: ReshapedMatrixDim
       integer :: SG
       integer, intent(IN), dimension(1:2,1:SG) :: occ_alpha, occ_beta,virt_alpha,virt_beta
       integer, intent(IN), dimension(1:SG,1:SG) :: ProductTable
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: p,q,r,i_begin,i_end,j_begin,j_end,numi,numj,numa,numb,a_begin,a_end,b_begin,b_end
       integer :: k_begin,k_end,numk, symgp, numc, c_begin,c_end,t,u,s,total
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)


       allocate(ReshapedMatrixDim%ijaa(1:SG))
       allocate(ReshapedMatrixDim%ijab(1:SG))
       allocate(ReshapedMatrixDim%ajaa(1:SG))
       allocate(ReshapedMatrixDim%ajab(1:SG))
       allocate(ReshapedMatrixDim%ajba(1:SG))
       allocate(ReshapedMatrixDim%abij_aaaa(1:SG))
       allocate(ReshapedMatrixDim%abij_abab(1:SG))
       allocate(ReshapedMatrixDim%a(1:SG))
       allocate(ReshapedMatrixDim%i(1:SG))
       allocate(ReshapedMatrixDim%ajaa_only(1:SG))
       allocate(ReshapedMatrixDim%ajab_only(1:SG))
       allocate(ReshapedMatrixDim%jka_aaa(1:SG))
       allocate(ReshapedMatrixDim%bci_aaa(1:SG))
       allocate(ReshapedMatrixDim%jka_abb(1:SG))
       allocate(ReshapedMatrixDim%jka_aba(1:SG))
       allocate(ReshapedMatrixDim%bci_aba(1:SG))
       allocate(ReshapedMatrixDim%bci_abb(1:SG))
       allocate(ReshapedMatrixDim%ajaa_t1(1:SG))
       allocate(ReshapedMatrixDim%ijbb(1:SG))
       allocate(ReshapedMatrixdim%ajbb(1:SG))
       allocate(ReshapedMatrixdim%a_alpha(1:SG))
       allocate(ReshapedMatrixDim%a_beta(1:SG))
       allocate(ReshapedMatrixDim%i_alpha(1:SG))
       allocate(ReshapedMatrixDim%i_beta(1:SG))
       allocate(ReshapedMatrixDim%jka_bbb(1:SG))
       allocate(ReshapedMatrixDim%bci_bbb(1:SG))
       allocate(ReshapedMatrixDim%ajbb_t1(1:SG))
       allocate(ReshapedMatrixDim%ajbb_only(1:SG))

       do p=1,SG
          ReshapedMatrixDim%ijaa(p)%row = 0
          ReshapedMatrixDim%ijaa(p)%col = 0
          ReshapedMatrixDim%ijab(p)%row = 0
          ReshapedMatrixDim%ijab(p)%col = 0
          ReshapedMatrixDim%ajaa(p)%row = 0
          ReshapedMatrixDim%ajaa(p)%col = 0
          ReshapedMatrixDim%ajab(p)%row = 0
          ReshapedMatrixDim%ajab(p)%col = 0
          ReshapedMatrixDim%ajba(p)%row = 0
          ReshapedMatrixDim%ajba(p)%col = 0
          ReshapedMatrixDim%abij_aaaa(p)%row = 0
          ReshapedMatrixDim%abij_aaaa(p)%col = 0
          ReshapedMatrixDim%abij_abab(p)%row = 0
          ReshapedMatrixDim%abij_abab(p)%col = 0
          ReshapedMatrixDim%a(p)%row = 0
          ReshapedMatrixDim%a(p)%col = 0
          ReshapedMatrixDim%i(p)%row = 0
          ReshapedMatrixDim%i(p)%col = 0
          ReshapedMatrixDim%ajaa_only(p)%row = 0
          ReshapedMatrixDim%ajaa_only(p)%col = 0
          ReshapedMatrixDim%ajab_only(p)%row = 0
          ReshapedMatrixDim%ajab_only(p)%col = 0
          ReshapedMatrixDim%jka_aaa(p)%row = 0
          ReshapedMatrixDim%jka_aaa(p)%col = 0
          ReshapedMatrixDim%bci_aaa(p)%row = 0
          ReshapedMatrixDim%bci_aaa(p)%col = 0
          ReshapedMatrixDim%jka_abb(p)%row = 0
          ReshapedMatrixdim%jka_abb(p)%col = 0
          ReshapedMatrixDim%jka_aba(p)%row = 0
          ReshapedMatrixdim%jka_aba(p)%col = 0
          ReshapedMatrixDim%bci_aba(p)%row = 0
          ReshapedMatrixdim%bci_aba(p)%col = 0
          ReshapedMatrixDim%bci_abb(p)%row = 0
          ReshapedMatrixDim%bci_abb(p)%col = 0
          ReshapedMatrixDim%ajaa_t1(p)%row = 0
          ReshapedMatrixDim%ajaa_t1(p)%col = 0
          ReshapedMatrixDim%ijbb(p)%row = 0
          ReshapedMatrixDim%ijbb(p)%col = 0
          ReshapedMatrixdim%ajbb(p)%row = 0
          ReshapedMatrixDim%ajbb(p)%col = 0
          ReshapedMatrixDim%a_alpha(p)%row = 0
          ReshapedMatrixDim%a_alpha(p)%col = 0
          ReshapedMatrixDim%a_beta(p)%row = 0
          ReshapedMatrixDim%a_beta(p)%col = 0
          ReshapedMatrixDim%i_alpha(p)%row = 0
          ReshapedMatrixDim%i_alpha(p)%col = 0
          ReshapedMatrixDim%i_beta(p)%row = 0
          ReshapedMatrixDim%i_beta(p)%col = 0
          ReshapedMatrixDim%jka_bbb(p)%row = 0
          ReshapedMatrixDim%jka_bbb(p)%col = 0
          ReshapedMatrixDim%bci_bbb(p)%row = 0
          ReshapedMatrixDim%bci_bbb(p)%col = 0
          ReshapedMatrixDim%ajbb_t1(p)%row = 0
          ReshapedMatrixDim%ajbb_t1(p)%col = 0
          ReshapedMatrixDim%ajbb_only(p)%row = 0
          ReshapedMatrixDim%ajbb_only(p)%col = 0
       end do
       do symgp = 1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
            i_begin = occ_alpha(1,p)
            i_end   = occ_alpha(2,p)
            j_begin = occ_alpha(1,q)
            j_end   = occ_alpha(2,q)
            if(p>q) cycle
            if(i_begin.EQ.j_begin) then
              numj = (j_end-j_begin + 1)
              numi = ((i_end - i_begin + 1) -1)
              ReshapedMatrixDim%ijaa(symgp)%col  = ReshapedMatrixDim%ijaa(symgp)%col + numi*numj/2
            else if(i_begin.LT.j_begin) then
              numi = i_end - i_begin + 1
              numj = j_end - j_begin + 1
              ReshapedMatrixDim%ijaa(symgp)%col  = ReshapedMatrixDim%ijaa(symgp)%col + numi*numj
            else
             continue
            end if
         end do
       end do


       do symgp=1,SG
        do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
             if(p>q) cycle
               a_begin = virt_alpha(1,p)
               a_end   = virt_alpha(2,p)
               b_begin = virt_alpha(1,q)
               b_end   = virt_alpha(2,q)
               if(a_begin.EQ.b_begin) then
                 numa = a_end - a_begin + 1
                 numb = (b_end - b_begin + 1) - 1
                 ReshapedMatrixDim%ijaa(symgp)%row = ReshapedMatrixDim%ijaa(symgp)%row + numa*numb/2
               else if(a_begin.LT.b_begin) then
                 numa = a_end - a_begin + 1
                 numb = b_end - b_begin + 1
                 ReshapedMatrixDim%ijaa(symgp)%row = ReshapedMatrixDim%ijaa(symgp)%row + numa*numb
               else
                 continue
               end if
         end do
       end do


       do symgp = 1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
            i_begin = occ_beta(1,p)
            i_end   = occ_beta(2,p)
            j_begin = occ_beta(1,q)
            j_end   = occ_beta(2,q)
            if(p>q) cycle
            if(i_begin.EQ.j_begin) then
              numj = (j_end-j_begin + 1)
              numi = ((i_end - i_begin + 1) -1)
              ReshapedMatrixDim%ijbb(symgp)%col  = ReshapedMatrixDim%ijbb(symgp)%col + numi*numj/2
            else if(i_begin.LT.j_begin) then
              numi = i_end - i_begin + 1
              numj = j_end - j_begin + 1
              ReshapedMatrixDim%ijbb(symgp)%col  = ReshapedMatrixDim%ijbb(symgp)%col + numi*numj
            else
             continue
            end if
         end do
       end do

       do symgp=1,SG
        do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
             if(p>q) cycle
               a_begin = virt_beta(1,p)
               a_end   = virt_beta(2,p)
               b_begin = virt_beta(1,q)
               b_end   = virt_beta(2,q)
               if(a_begin.EQ.b_begin) then
                 numa = a_end - a_begin + 1
                 numb = (b_end - b_begin + 1) - 1
                 ReshapedMatrixDim%ijbb(symgp)%row = ReshapedMatrixDim%ijbb(symgp)%row + numa*numb/2
               else if(a_begin.LT.b_begin) then
                 numa = a_end - a_begin + 1
                 numb = b_end - b_begin + 1
                 ReshapedMatrixDim%ijbb(symgp)%row = ReshapedMatrixDim%ijbb(symgp)%row + numa*numb
               else
                 continue
               end if
         end do
       end do

       do symgp=1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           numi = i_end - i_begin + 1
           numj = j_end - j_begin + 1
           ReshapedMatrixDim%ijab(symgp)%col = ReshapedMatrixDim%ijab(symgp)%col + numi*numj
         end do
       end do

       do symgp=1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           b_begin = virt_beta(1,q)
           b_end   = virt_beta(2,q)
           numa = a_end - a_begin + 1
           numb = b_end - b_begin + 1
           ReshapedMatrixDim%ijab(symgp)%row = ReshapedMatrixDim%ijab(symgp)%row + numa*numb
         end do
       end do
       do symgp=1,SG
         do p=1,SG
           do q=1,SG
             if(ProductTable(p,q).EQ.symgp)  then
               a_begin = virt_alpha(1,p)
               a_end   = virt_alpha(2,p)
               j_begin = occ_alpha(1,q)
               j_end   = occ_alpha(2,q)
               numa = a_end - a_begin + 1
               numj = j_end - j_begin + 1
               c_begin = virt_beta(1,p)
               c_end   = virt_beta(2,p)
               k_begin = occ_beta(1,q)
               k_end   = occ_beta(2,q)
               numc = c_end - c_begin + 1
               numk = k_end - k_begin + 1
               ReshapedMatrixDim%ajaa(symgp)%col = ReshapedMatrixDim%ajaa(symgp)%col +  numa*numj
               ReshapedMatrixDim%ajaa(symgp)%row = ReshapedMatrixDim%ajaa(symgp)%row + numa*numj + numc*numk
             end if
           end do
         end do
       end do
       do symgp=1,SG
         do p=1,SG
           do q=1,SG
             if(ProductTable(p,q).EQ.symgp)  then
               a_begin = virt_beta(1,p)
               a_end   = virt_beta(2,p)
               j_begin = occ_beta(1,q)
               j_end   = occ_beta(2,q)
               numa = a_end - a_begin + 1
               numj = j_end - j_begin + 1
               c_begin = virt_alpha(1,p)
               c_end   = virt_alpha(2,p)
               k_begin = occ_alpha(1,q)
               k_end   = occ_alpha(2,q)
               numc = c_end - c_begin + 1
               numk = k_end - k_begin + 1
               ReshapedMatrixDim%ajbb(symgp)%col = ReshapedMatrixDim%ajbb(symgp)%col +  numa*numj
               ReshapedMatrixDim%ajbb(symgp)%row = ReshapedMatrixDim%ajbb(symgp)%row + numa*numj + numc*numk
             end if
           end do
         end do
       end do

       do symgp=1,SG
         do p=1,SG
           do q=1,SG
             if(ProductTable(p,q).EQ.symgp)  then
               a_begin = virt_alpha(1,p)
               a_end   = virt_alpha(2,p)
               j_begin = occ_alpha(1,q)
               j_end   = occ_alpha(2,q)
               numa = a_end - a_begin + 1
               numj = j_end - j_begin + 1
               c_begin = virt_beta(1,p)
               c_end   = virt_beta(2,p)
               k_begin = occ_beta(1,q)
               k_end   = occ_beta(2,q)
               numc = c_end - c_begin + 1
               numk = k_end - k_begin + 1
               ReshapedMatrixDim%ajaa_only(symgp)%col = ReshapedMatrixDim%ajaa_only(symgp)%col +  numa*numj
               ReshapedMatrixDim%ajaa_only(symgp)%row = ReshapedMatrixDim%ajaa_only(symgp)%row + numa*numj + numc*numk
             end if
           end do
         end do
       end do


       do symgp=1,SG
         do p=1,SG
           do q=1,SG
             if(ProductTable(p,q).EQ.symgp)  then
               a_begin = virt_beta(1,p)
               a_end   = virt_beta(2,p)
               j_begin = occ_beta(1,q)
               j_end   = occ_beta(2,q)
               numa = a_end - a_begin + 1
               numj = j_end - j_begin + 1
               c_begin = virt_alpha(1,p)
               c_end   = virt_alpha(2,p)
               k_begin = occ_alpha(1,q)
               k_end   = occ_alpha(2,q)
               numc = c_end - c_begin + 1
               numk = k_end - k_begin + 1
               ReshapedMatrixDim%ajbb_only(symgp)%col = ReshapedMatrixDim%ajbb_only(symgp)%col +  numa*numj
               ReshapedMatrixDim%ajbb_only(symgp)%row = ReshapedMatrixDim%ajbb_only(symgp)%row + numa*numj + numc*numk
             end if
           end do
         end do
       end do

       do symgp=1,SG
         do p=1,SG
           do q=1,SG
             if(ProductTable(p,q).EQ.symgp)  then
               a_begin = virt_alpha(1,p)
               a_end   = virt_alpha(2,p)
               j_begin = occ_beta(1,q)
               j_end   = occ_beta(2,q)
               numa = a_end - a_begin + 1
               numj = j_end - j_begin + 1
               ReshapedMatrixDim%ajab_only(symgp)%col = ReshapedMatrixDim%ajab_only(symgp)%col +  numa*numj
               ReshapedMatrixDim%ajab_only(symgp)%row = ReshapedMatrixDim%ajab_only(symgp)%row + numa*numj
             end if
           end do
         end do
      end do

       do symgp=1,SG
         do p=1,SG
           do q=1,SG
             if(ProductTable(p,q).EQ.symgp)  then
               a_begin = virt_alpha(1,p)
               a_end   = virt_alpha(2,p)
               j_begin = occ_beta(1,q)
               j_end   = occ_beta(2,q)
               numa = a_end - a_begin + 1
               numj = j_end - j_begin + 1
               c_begin = virt_beta(1,p)
               c_end   = virt_beta(2,p)
               k_begin = occ_alpha(1,q)
               k_end   = occ_alpha(2,q)
               numc = c_end - c_begin + 1
               numk = k_end - k_begin   + 1
               ReshapedMatrixDim%ajab(symgp)%row = ReshapedMatrixDim%ajab(symgp)%row +  numa*numj
               ReshapedMatrixDim%ajab(symgp)%col = ReshapedMatrixDim%ajab(symgp)%col +  numc*numk
             end if
           end do
         end do
       end do
       do symgp=1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           numa = a_end - a_begin + 1
           numj = j_end - j_begin + 1
           c_begin = virt_alpha(1,p)
           c_end   = virt_alpha(2,p)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           numc = c_end - c_begin + 1
           numk = k_end - k_begin + 1
           ReshapedMatrixDim%ajba(symgp)%row = ReshapedMatrixDim%ajba(symgp)%row +  numa*numj
           ReshapedMatrixDim%ajba(symgp)%col = ReshapedMatrixDim%ajba(symgp)%col +  numc*numk
         end do
       end do












       do symgp=1,SG
         a_begin = virt_alpha(1,symgp)
         a_end   = virt_alpha(2,symgp)
         numa = a_end - a_begin + 1
         ReshapedMatrixDim%a_alpha(symgp)%col  = numa
       end do

       do symgp=1,SG
         do p=1,SG
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           do t=1,SG
             q = InvPdt(ProductTable(symgp,p))%upper(t)
             r = InvPdt(ProductTable(symgp,p))%lower(t)
             j_begin = occ_alpha(1,q)
             j_end   = occ_alpha(2,q)
             c_begin = virt_alpha(1,r)
             c_end   = virt_alpha(2,r)
             if(j_begin.EQ.i_begin) then
               numj = j_end - j_begin + 1
               numc = c_end - c_begin + 1
               numi = i_end - i_begin + 1
               ReshapedMatrixDim%a_alpha(symgp)%row = ReshapedMatrixDim%a_alpha(symgp)%row + numc*(numi*(numj-1))/2
             else if(i_begin.LT.j_begin) then
                 numj = j_end - j_begin + 1
                 numc = c_end - c_begin + 1
                 numi = i_end - i_begin + 1
                 ReshapedMatrixDim%a_alpha(symgp)%row  = ReshapedMatrixDim%a_alpha(symgp)%row  + numc*(numi*numj)
             else
               continue
             end if
           end do
         end do
       end do

      do symgp=1,SG
         do p=1,SG
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           do t=1,SG
             q = InvPdt(ProductTable(symgp,p))%upper(t)
             r = InvPdt(ProductTable(symgp,p))%lower(t)
             j_begin = occ_beta(1,q)
             j_end   = occ_beta(2,q)
             c_begin = virt_beta(1,r)
             c_end   = virt_beta(2,r)
             numj = j_end - j_begin + 1
             numc = c_end - c_begin + 1
             numi = i_end - i_begin + 1
             ReshapedMatrixdim%a_alpha(symgp)%row = ReshapedMatrixDim%a_alpha(symgp)%row + numc*(numi*numj)
           end do
         end do
       end do


       do symgp=1,SG
         a_begin = virt_beta(1,symgp)
         a_end   = virt_beta(2,symgp)
         numa = a_end - a_begin + 1
         ReshapedMatrixDim%a_beta(symgp)%col  = numa
       end do

       do symgp=1,SG
         do p=1,SG
           i_begin = occ_beta(1,p)
           i_end   = occ_beta(2,p)
           do t=1,SG
             q = InvPdt(ProductTable(symgp,p))%upper(t)
             r = InvPdt(ProductTable(symgp,p))%lower(t)
             j_begin = occ_beta(1,q)
             j_end   = occ_beta(2,q)
             c_begin = virt_beta(1,r)
             c_end   = virt_beta(2,r)
             if(j_begin.EQ.i_begin) then
               numj = j_end - j_begin + 1
               numc = c_end - c_begin + 1
               numi = i_end - i_begin + 1
               ReshapedMatrixDim%a_beta(symgp)%row = ReshapedMatrixDim%a_beta(symgp)%row + numc*(numi*(numj-1))/2
             else if(i_begin.LT.j_begin) then
                 numj = j_end - j_begin + 1
                 numc = c_end - c_begin + 1
                 numi = i_end - i_begin + 1
                 ReshapedMatrixDim%a_beta(symgp)%row  = ReshapedMatrixDim%a_beta(symgp)%row  + numc*(numi*numj)
             else
               continue
             end if
           end do
         end do
       end do

      do symgp=1,SG
         do p=1,SG
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           do t=1,SG
             q = InvPdt(ProductTable(symgp,p))%upper(t)
             r = InvPdt(ProductTable(symgp,p))%lower(t)
             j_begin = occ_beta(1,q)
             j_end   = occ_beta(2,q)
             c_begin = virt_alpha(1,r)
             c_end   = virt_alpha(2,r)
             numj = j_end - j_begin + 1
             numc = c_end - c_begin + 1
             numi = i_end - i_begin + 1
             ReshapedMatrixdim%a_beta(symgp)%row = ReshapedMatrixDim%a_beta(symgp)%row + numc*(numi*numj)
           end do
         end do
       end do



       do symgp=1,SG
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         numi = i_end - i_begin + 1
         ReshapedMatrixDim%i_alpha(symgp)%col = numi
       end do


       do symgp=1,SG
         do p=1,SG
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           do t=1,SG
             q = InvPdt(ProductTable(symgp,p))%upper(t)
             r = InvPdt(ProductTable(symgp,p))%lower(t)
             b_begin = virt_alpha(1,q)
             b_end   = virt_alpha(2,q)
             k_begin = occ_alpha(1,r)
             k_end   = occ_alpha(2,r)
             if(a_begin.EQ.b_begin) then
               numb = b_end - b_begin + 1
               numk = k_end - k_begin + 1
               numa = a_end - a_begin + 1
               ReshapedMatrixDim%i_alpha(symgp)%row = ReshapedMatrixDim%i_alpha(symgp)%row  + numk*(numa*(numb-1))/2
             else if(a_begin.LT.b_begin) then
               numb = b_end - b_begin + 1
               numk = k_end - k_begin + 1
               numa = a_end - a_begin + 1
               ReshapedMatrixDim%i_alpha(symgp)%row = ReshapedMatrixDim%i_alpha(symgp)%row + numk*numa*numb
             else
              continue
             end if
           end do
         end do
       end do

       do symgp=1,SG
         do p=1,SG
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           do t=1,SG
             q = InvPdt(ProductTable(symgp,p))%upper(t)
             r = InvPdt(ProductTable(symgp,p))%lower(t)
             b_begin = virt_beta(1,q)
             b_end   = virt_beta(2,q)
             k_begin = occ_beta(1,r)
             k_end   = occ_beta(2,r)
             numb = b_end - b_begin + 1
             numk = k_end - k_begin + 1
             numa = a_end - a_begin + 1
             ReshapedMatrixDim%i_alpha(symgp)%row = ReshapedMatrixDim%i_alpha(symgp)%row + numk*numa*numb
           end do
         end do
       end do
       do symgp=1,SG
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         numi = i_end - i_begin + 1
         ReshapedMatrixDim%i_beta(symgp)%col = numi
       end do

       do symgp=1,SG
         do p=1,SG
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           do t=1,SG
             q = InvPdt(ProductTable(symgp,p))%upper(t)
             r = InvPdt(ProductTable(symgp,p))%lower(t)
             b_begin = virt_beta(1,q)
             b_end   = virt_beta(2,q)
             k_begin = occ_beta(1,r)
             k_end   = occ_beta(2,r)
             if(a_begin.EQ.b_begin) then
               numb = b_end - b_begin + 1
               numk = k_end - k_begin + 1
               numa = a_end - a_begin + 1
               ReshapedMatrixDim%i_beta(symgp)%row = ReshapedMatrixDim%i_beta(symgp)%row  + numk*(numa*(numb-1))/2
             else if(a_begin.LT.b_begin) then
               numb = b_end - b_begin + 1
               numk = k_end - k_begin + 1
               numa = a_end - a_begin + 1
               ReshapedMatrixDim%i_beta(symgp)%row = ReshapedMatrixDim%i_beta(symgp)%row + numk*numa*numb
             else
              continue
             end if
           end do
         end do
       end do


       do symgp=1,SG
         do p=1,SG
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           do t=1,SG
             q = InvPdt(ProductTable(symgp,p))%upper(t)
             r = InvPdt(ProductTable(symgp,p))%lower(t)
             b_begin = virt_alpha(1,q)
             b_end   = virt_alpha(2,q)
             k_begin = occ_alpha(1,r)
             k_end   = occ_alpha(2,r)
             numb = b_end - b_begin + 1
             numk = k_end - k_begin + 1
             numa = a_end - a_begin + 1
             ReshapedMatrixDim%i_beta(symgp)%row = ReshapedMatrixDim%i_beta(symgp)%row + numk*numa*numb
           end do
         end do
       end do


       do symgp=1,SG
         b_begin = virt_alpha(1,symgp)
         b_end   = virt_alpha(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_alpha(1,q)
           k_end   = occ_alpha(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_alpha(1,r)
             a_end   = virt_alpha(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             numa = a_end - a_begin + 1
             numj = j_end - j_begin + 1
             numk = k_end - k_begin + 1
             numb = b_end - b_begin + 1
             if(k_begin.gt.j_begin)  then
               ReshapedMatrixDim%jka_aaa(symgp)%col = ReshapedMatrixDim%jka_aaa(symgp)%col + numa*(numj)*(numk)
             else if(k_begin.eq.j_begin) then
               ReshapedMatrixDim%jka_aaa(symgp)%col = ReshapedMatrixDim%jka_aaa(symgp)%col + numa*(numj)*(numk-1)*0.5
             else
               cycle
             end if
             ReshapedMatrixDim%jka_aaa(symgp)%row = numb
           end do
         end do
       end do

       do symgp=1,SG
         b_begin = virt_beta(1,symgp)
         b_end   = virt_beta(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_beta(1,r)
             a_end   = virt_beta(2,r)
             j_begin = occ_beta(1,s)
             j_end   = occ_beta(2,s)
             numa = a_end - a_begin + 1
             numj = j_end - j_begin + 1
             numk = k_end - k_begin + 1
             numb = b_end - b_begin + 1
             if(k_begin.gt.j_begin)  then
               ReshapedMatrixDim%jka_bbb(symgp)%col = ReshapedMatrixDim%jka_bbb(symgp)%col + numa*(numj)*(numk)
             else if(k_begin.eq.j_begin) then
               ReshapedMatrixDim%jka_bbb(symgp)%col = ReshapedMatrixDim%jka_bbb(symgp)%col + numa*(numj)*(numk-1)*0.5
             else
               cycle
             end if
             ReshapedMatrixDim%jka_bbb(symgp)%row = numb
           end do
         end do
       end do



       do symgp=1,SG
         j_begin = occ_alpha(1,symgp)
         j_end   = occ_alpha(2,symgp)
         numj = j_end - j_begin + 1
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_alpha(1,q)
           c_end   = virt_alpha(2,q)
           numc = c_end - c_begin + 1
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_alpha(1,r)
             b_end   = virt_alpha(2,r)
             i_begin = occ_alpha(1,s)
             i_end   = occ_alpha(2,s)
             numi = i_end - i_begin + 1
             numb = b_end - b_begin + 1
             ReshapedMatrixDim%bci_aaa(symgp)%row = numj
             if(b_begin.eq.c_begin) then
               ReshapedMatrixDim%bci_aaa(symgp)%col = numi*numb*(numc-1)*0.5 + ReshapedMatrixDim%bci_aaa(symgp)%col
             else if(b_begin.lt.c_begin) then
               ReshapedMatrixDim%bci_aaa(symgp)%col = numi*numb*(numc) + ReshapedMatrixDim%bci_aaa(symgp)%col
             else
               cycle
             end if
           end do
         end do
       end do
       do symgp=1,SG
         j_begin = occ_beta(1,symgp)
         j_end   = occ_beta(2,symgp)
         numj = j_end - j_begin + 1
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_beta(1,q)
           c_end   = virt_beta(2,q)
           numc = c_end - c_begin + 1
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_beta(1,r)
             b_end   = virt_beta(2,r)
             i_begin = occ_beta(1,s)
             i_end   = occ_beta(2,s)
             numi = i_end - i_begin + 1
             numb = b_end - b_begin + 1
             ReshapedMatrixDim%bci_bbb(symgp)%row = numj
             if(b_begin.eq.c_begin) then
               ReshapedMatrixDim%bci_bbb(symgp)%col = numi*numb*(numc-1)*0.5 + ReshapedMatrixDim%bci_bbb(symgp)%col
             else if(b_begin.lt.c_begin) then
               ReshapedMatrixDim%bci_bbb(symgp)%col = numi*numb*(numc) + ReshapedMatrixDim%bci_bbb(symgp)%col
             else
               cycle
             end if
           end do
         end do
       end do

       do symgp=1,SG
         b_begin = virt_alpha(1,symgp)
         b_end   = virt_alpha(2,symgp)
         numb = (b_end - b_begin) + 1
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           numk = (k_end - k_begin) + 1
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_beta(1,r)
             a_end   = virt_beta(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             numa = (a_end - a_begin) + 1
             numj = (j_end - j_begin) + 1
             ReshapedMatrixDim%jka_abb(symgp)%col = numj*numk*numa + ReshapedMatrixDim%jka_abb(symgp)%col
             ReshapedMatrixDim%jka_abb(symgp)%row = numb
           end do
         end do
       end do
       do symgp=1,SG
         b_begin = virt_beta(1,symgp)
         b_end   = virt_beta(2,symgp)
         numb = (b_end - b_begin) + 1
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           numk = (k_end - k_begin) + 1
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_alpha(1,r)
             a_end   = virt_alpha(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             numa = (a_end - a_begin) + 1
             numj = (j_end - j_begin) + 1
             ReshapedMatrixDim%jka_aba(symgp)%row = numb
             ReshapedMatrixDim%jka_aba(symgp)%col = numj*numk*numa + ReshapedMatrixDim%jka_aba(symgp)%col
           end do
         end do
       end do
       do symgp=1,SG
         j_begin = occ_beta(1,symgp)
         j_end   = occ_beta(2,symgp)
         numj = (j_end - j_begin) + 1
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_beta(1,q)
           c_end   = virt_beta(2,q)
           numc = (c_end - c_begin) + 1
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_alpha(1,r)
             b_end   = virt_alpha(2,r)
             i_begin = occ_alpha(1,s)
             i_end   = occ_alpha(2,s)
             numb = (b_end - b_begin) + 1
             numi = (i_end - i_begin) + 1
             ReshapedMatrixDim%bci_aba(symgp)%row = numj
             ReshapedMatrixDim%bci_aba(symgp)%col = numb*numc*numi + ReshapedMatrixDim%bci_aba(symgp)%col
           end do
         end do
       end do

       do symgp=1,SG
         j_begin = occ_alpha(1,symgp)
         j_end   = occ_alpha(2,symgp)
         numj = (j_end - j_begin) + 1
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_beta(1,q)
           c_end   = virt_beta(2,q)
           numc = (c_end - c_begin) + 1
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_alpha(1,r)
             b_end   = virt_alpha(2,r)
             i_begin = occ_beta(1,s)
             i_end   = occ_beta(2,s)
             numb = (b_end - b_begin) + 1
             numi = (i_end - i_begin) + 1
             ReshapedMatrixDim%bci_abb(symgp)%row = numj
             ReshapedMatrixDim%bci_abb(symgp)%col = numb*numc*numi + ReshapedMatrixDim%bci_abb(symgp)%col
           end do
         end do
       end do

       do symgp=1,SG
           total = 0
           a_begin = virt_alpha(1,symgp)
           a_end   = virt_alpha(2,symgp)
           i_begin = occ_alpha(1,symgp)
           i_end   = occ_alpha(2,symgp)
           numi = i_end - i_begin + 1
           numa = a_end - a_begin + 1
           do p=1,SG
             b_begin = virt_alpha(1,p)
             b_end   = virt_alpha(2,p)
             j_begin = occ_alpha(1,p)
             j_end   = occ_alpha(2,p)
             numb = b_end - b_begin + 1
             numj = j_end - j_begin + 1
             total = total + numj*numb
             b_begin = virt_beta(1,p)
             b_end   = virt_beta(2,p)
             j_begin = occ_beta(1,p)
             j_end   = occ_beta(2,p)
             numb = b_end - b_begin + 1
             numj = j_end - j_begin + 1
             total = total + numj*numb
             ReshapedMatrixDim%ajaa_t1(symgp)%col = numa*numi
             ReshapedMatrixDim%ajaa_t1(symgp)%row = total
          end do
        end do


       do symgp=1,SG
           total = 0
           a_begin = virt_beta(1,symgp)
           a_end   = virt_beta(2,symgp)
           i_begin = occ_beta(1,symgp)
           i_end   = occ_beta(2,symgp)
           numi = i_end - i_begin + 1
           numa = a_end - a_begin + 1
           do p=1,SG
             b_begin = virt_alpha(1,p)
             b_end   = virt_alpha(2,p)
             j_begin = occ_alpha(1,p)
             j_end   = occ_alpha(2,p)
             numb = b_end - b_begin + 1
             numj = j_end - j_begin + 1
             total = total + numj*numb
             b_begin = virt_beta(1,p)
             b_end   = virt_beta(2,p)
             j_begin = occ_beta(1,p)
             j_end   = occ_beta(2,p)
             numb = b_end - b_begin + 1
             numj = j_end - j_begin + 1
             total = total + numj*numb
             ReshapedMatrixDim%ajbb_t1(symgp)%col = numa*numi
             ReshapedMatrixDim%ajbb_t1(symgp)%row = total
          end do
        end do



        Call CPU_TIME(time_end)
        time_calcreshapedim = time_calcreshapedim + time_end - time_begin
       end subroutine CalcReshapeDimOS

!> @brief Builds the K1 and K2 matrices for open shell calculations
!> @author Christine Schwerdtfeger and David Mazziotti
      subroutine BuildK2K1OS(occ_alpha,occ_beta,virt_alpha,virt_beta,numSG,InvPdt,TwoIntsCompact,OneInts,ReshapedMatrixDim,K2,K1,ProductTable,K1TwoInts,TwoInts,OldIndex_alpha,OldIndex_beta)
      Use TypeMod
      Use TimeMod, only : time_buildk2k1
      Use InterfaceMod
      Implicit None

      integer, intent(IN), allocatable, dimension(:,:) :: occ_alpha,occ_beta, virt_alpha,virt_beta
      integer, intent(IN) :: numSG
      type(symmetry), allocatable, dimension(:) :: InvPdt
      real(8), allocatable, dimension(:,:,:,:) :: TwoInts
      real(8), intent(IN), allocatable, dimension(:,:) :: OneInts
      real(8), allocatable, dimension(:) :: TwoIntsCompact
      type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
      type(spin) :: K2(1:2,1:2,1:2,1:2)
      type(spin) :: K1(1:2,1:2)
      integer, dimension(1:numSG,1:numSG) :: ProductTable
      type(spin) :: K1TwoInts(1:2,1:2)
      integer, allocatable, dimension(:) :: OldIndex_alpha, OldIndex_beta


      integer :: i,j,k,l,i_begin,i_end,j_begin,j_end,k_begin,k_end,l_begin,l_end
      integer :: i_gamess,j_gamess,k_gamess,l_gamess,a_gamess,b_gamess,c_gamess,d_gamess
      integer :: symgp, t,v,p,q,r,s
      integer :: row, col,numi,numa,numk
      integer :: a,b,c,d,a_begin,a_end,b_begin,b_end,c_begin,c_end,d_begin,d_end
      integer :: u
      integer :: begindim,enddim,enddim_occ
      real(8) :: test(1:2,1:2)
      real :: time_begin, time_end
      integer :: numocc,numtotal,numocc_alpha,numocc_beta,numvirt_alpha,numvirt_beta,begin_virt,begin_virt_alpha,begin_virt_beta
      type(InverseBasis), allocatable, dimension(:) :: InverseBasisK1_alpha, InverseBasisK1_beta
      integer :: counter
      real(8) :: integral
      integer*8 :: index1,index2,compindex1,compindex2
      Call cpu_time(time_begin)

      allocate(K2(1,1,1,1)%aa%irrep(1:numSG))
      allocate(K2(2,2,2,2)%aa%irrep(1:numSG))
      allocate(K2(1,2,1,2)%aa%irrep(1:numSG))
      allocate(K2(1,1,2,2)%aa%irrep(1:numSG))
      allocate(K2(1,1,1,1)%bb%irrep(1:numSG))
      allocate(K2(2,2,2,2)%bb%irrep(1:numSG))
      allocate(K2(1,2,1,2)%bb%irrep(1:numSG))
      allocate(K2(1,1,2,2)%bb%irrep(1:numSG))
      allocate(K2(1,1,1,1)%ab%irrep(1:numSG))
      allocate(K2(2,2,2,2)%ab%irrep(1:numSG))
      allocate(K2(1,2,1,2)%ab%irrep(1:numSG))
      allocate(K2(2,1,2,1)%ab%irrep(1:numSG))
      allocate(K2(1,1,2,2)%ab%irrep(1:numSG))
      allocate(K2(1,2,2,1)%ab%irrep(1:numSG))
      allocate(K2(2,1,1,2)%ab%irrep(1:numSG))
      allocate(K2(1,1,1,2)%aa%irrep(1:numSG))
      allocate(K2(2,2,1,2)%aa%irrep(1:numSG))
      allocate(K2(1,1,1,2)%bb%irrep(1:numSG))
      allocate(K2(2,2,1,2)%bb%irrep(1:numSG))
      allocate(K2(1,1,1,2)%ab%irrep(1:numSG))
      allocate(K2(1,1,2,1)%ab%irrep(1:numSG))
      allocate(K2(2,2,1,2)%ab%irrep(1:numSG))
      allocate(K2(2,2,2,1)%ab%irrep(1:numSG))
      allocate(K1(1,1)%aa%irrep(1:numSG))
      allocate(K1(2,2)%aa%irrep(1:numSG))
      allocate(K1(1,2)%aa%irrep(1:numSG))
      allocate(K1(1,1)%bb%irrep(1:numSG))
      allocate(K1(2,2)%bb%irrep(1:numSG))
      allocate(K1(1,2)%bb%irrep(1:numSG))
      allocate(K1TwoInts(1,1)%aa%irrep(1:numSG))
      allocate(K1TwoInts(2,2)%aa%irrep(1:numSG))
      allocate(K1TwoInts(1,2)%aa%irrep(1:numSG))
      allocate(K1TwoInts(1,1)%bb%irrep(1:numSG))
      allocate(K1TwoInts(2,2)%bb%irrep(1:numSG))
      allocate(K1TwoInts(1,2)%bb%irrep(1:numSG))

      do i=1,numSG
        allocate(K2(1,1,1,1)%aa%irrep(i)%block(1:ReshapedMatrixDim%ijaa(i)%col,1:ReshapedMatrixDim%ijaa(i)%col))
        allocate(K2(2,2,2,2)%aa%irrep(i)%block(1:ReshapedMatrixDim%ijaa(i)%row,1:ReshapedMatrixDim%ijaa(i)%row))
        allocate(K2(1,2,1,2)%aa%irrep(i)%block(1:ReshapedMatrixDim%ajaa(i)%col,1:ReshapedMatrixDim%ajaa(i)%col))
        allocate(K2(1,1,2,2)%aa%irrep(i)%block(1:ReshapedMatrixDim%ijaa(i)%row,1:ReshapedMatrixDim%ijaa(i)%col))
        allocate(K2(1,1,1,1)%bb%irrep(i)%block(1:ReshapedMatrixDim%ijbb(i)%col,1:ReshapedMatrixDim%ijbb(i)%col))
        allocate(K2(2,2,2,2)%bb%irrep(i)%block(1:ReshapedMatrixDim%ijbb(i)%row,1:ReshapedMatrixDim%ijbb(i)%row))
        allocate(K2(1,2,1,2)%bb%irrep(i)%block(1:ReshapedMatrixDim%ajbb(i)%col,1:ReshapedMatrixDim%ajbb(i)%col))
        allocate(K2(1,1,2,2)%bb%irrep(i)%block(1:ReshapedMatrixDim%ijbb(i)%row,1:ReshapedMatrixDim%ijbb(i)%col))
      end do
       do i=1,numSG
        allocate(K2(1,1,1,1)%ab%irrep(i)%block(1:ReshapedMatrixDim%ijab(i)%col,1:ReshapedMatrixDim%ijab(i)%col))
        allocate(K2(2,2,2,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%ijab(i)%row,1:ReshapedMatrixDim%ijab(i)%row))
        allocate(K2(1,2,1,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%ajab(i)%col,1:ReshapedMatrixDim%ajab(i)%col))
        allocate(K2(2,1,2,1)%ab%irrep(i)%block(1:ReshapedMatrixDim%ajba(i)%col,1:ReshapedMatrixDim%ajba(i)%col))
        allocate(K2(1,1,2,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%ijab(i)%row,1:ReshapedMatrixDim%ijab(i)%col))
        allocate(K2(1,2,2,1)%ab%irrep(i)%block(1:ReshapedMatrixDim%ajbb_only(i)%col,1:ReshapedMatrixDim%ajaa_only(i)%col))
        allocate(K2(2,1,1,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%ajaa_only(i)%col,1:ReshapedMatrixDim%ajbb_only(i)%col))
        numi = (occ_alpha(2,i) - occ_alpha(1,i)) + 1
        numa = (virt_alpha(2,i) - virt_alpha(1,i)) + 1
        allocate(K2(1,1,1,2)%aa%irrep(i)%block(1:ReshapedMatrixDim%jka_aaa(i)%col,1:numi))
        allocate(K2(2,2,1,2)%aa%irrep(i)%block(1:ReshapedMatrixDim%bci_aaa(i)%col,1:numa))
        allocate(K2(1,1,1,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%jka_abb(i)%col,1:numi))
        allocate(K2(2,2,2,1)%ab%irrep(i)%block(1:ReshapedMatrixDim%bci_abb(i)%col,1:numa))
        numi = (occ_beta(2,i) - occ_beta(1,i)) + 1
        numa = (virt_beta(2,i) - virt_beta(1,i)) + 1
        allocate(K2(1,1,1,2)%bb%irrep(i)%block(1:ReshapedMatrixDim%jka_bbb(i)%col,1:numi))
        allocate(K2(2,2,1,2)%bb%irrep(i)%block(1:ReshapedMatrixDim%bci_bbb(i)%col,1:numa))
        allocate(K2(1,1,2,1)%ab%irrep(i)%block(1:ReshapedMatrixDim%jka_aba(i)%col,1:numi))
        allocate(K2(2,2,1,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%bci_aba(i)%col,1:numa))
      end do

       do t=1,numSG
         i_begin = occ_alpha(1,t)
         i_end   = occ_alpha(2,t)
         a_begin = virt_alpha(1,t)
         a_end   = virt_alpha(2,t)
         numa = a_end - a_begin + 1
         numi = i_end - i_begin + 1
         allocate(K1(1,1)%aa%irrep(t)%block(i_begin:i_end,i_begin:i_end))
         allocate(K1(2,2)%aa%irrep(t)%block(a_begin:a_end,a_begin:a_end))
         allocate(K1(1,2)%aa%irrep(t)%block(1:numi*numa,1:1))
         allocate(K1TwoInts(1,1)%aa%irrep(t)%block(i_begin:i_end,i_begin:i_end))
         allocate(K1TwoInts(2,2)%aa%irrep(t)%block(a_begin:a_end,a_begin:a_end))
         allocate(K1TwoInts(1,2)%aa%irrep(t)%block(1:numa*numi,1:1))
         K1(1,1)%aa%irrep(t)%block(i_begin:i_end,i_begin:i_end) = 0.0D0
         K1(2,2)%aa%irrep(t)%block(a_begin:a_end,a_begin:a_end) = 0.0D0
         K1(1,2)%aa%irrep(t)%block(1:numa*numi,1:1) = 0.0D0
         K1TwoInts(1,1)%aa%irrep(t)%block(i_begin:i_end,i_begin:i_end) = 0.0D0
         K1TwoInts(2,2)%aa%irrep(t)%block(a_begin:a_end,a_begin:a_end) = 0.0D0
         K1TwoInts(1,2)%aa%irrep(t)%block(1:numa*numi,1:1) = 0.0D0
      end do

       do t=1,numSG
         i_begin = occ_beta(1,t)
         i_end   = occ_beta(2,t)
         a_begin = virt_beta(1,t)
         a_end   = virt_beta(2,t)
         numa = a_end - a_begin + 1
         numi = i_end - i_begin + 1
         allocate(K1(1,1)%bb%irrep(t)%block(i_begin:i_end,i_begin:i_end))
         allocate(K1(2,2)%bb%irrep(t)%block(a_begin:a_end,a_begin:a_end))
         allocate(K1(1,2)%bb%irrep(t)%block(1:numi*numa,1:1))
         allocate(K1TwoInts(1,1)%bb%irrep(t)%block(i_begin:i_end,i_begin:i_end))
         allocate(K1TwoInts(2,2)%bb%irrep(t)%block(a_begin:a_end,a_begin:a_end))
         allocate(K1TwoInts(1,2)%bb%irrep(t)%block(1:numa*numi,1:1))
         K1(1,1)%bb%irrep(t)%block(i_begin:i_end,i_begin:i_end) = 0.0D0
         K1(2,2)%bb%irrep(t)%block(a_begin:a_end,a_begin:a_end) = 0.0D0
         K1(1,2)%bb%irrep(t)%block(1:numa*numi,1:1) = 0.0D0
         K1TwoInts(1,1)%bb%irrep(t)%block(i_begin:i_end,i_begin:i_end) = 0.0D0
         K1TwoInts(2,2)%bb%irrep(t)%block(a_begin:a_end,a_begin:a_end) = 0.0D0
         K1TwoInts(1,2)%bb%irrep(t)%block(1:numa*numi,1:1) = 0.0D0
      end do


       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) cycle
                 k_begin = occ_alpha(1,r)
                 k_end   = occ_alpha(2,r)
                 l_begin = occ_alpha(1,s)
                 l_end   = occ_alpha(2,s)
                 do k=k_begin,k_end
                   do l=max(k+1,l_begin),l_end
                     i_gamess = OldIndex_alpha(i)
                     j_gamess = OldIndex_alpha(j)
                     k_gamess = OldIndex_alpha(k)
                     l_gamess = OldIndex_alpha(l)
                     index1 = FirstIndex(i_gamess,k_gamess)
                     index2 = FirstIndex(j_gamess,l_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(i_gamess,l_gamess)
                     index2 = FirstIndex(j_gamess,k_gamess)
                     compindex2 = CompositeIndex(index1,index2)
                     K2(1,1,1,1)%aa%irrep(symgp)%block(row,col) = (TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2))
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           i_begin = occ_beta(1,p)
           i_end   = occ_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) cycle
                 k_begin = occ_beta(1,r)
                 k_end   = occ_beta(2,r)
                 l_begin = occ_beta(1,s)
                 l_end   = occ_beta(2,s)
                 do k=k_begin,k_end
                   do l=max(k+1,l_begin),l_end
                     i_gamess = OldIndex_beta(i)
                     j_gamess = OldIndex_beta(j)
                     k_gamess = OldIndex_beta(k)
                     l_gamess = OldIndex_beta(l)
                     index1 = FirstIndex(i_gamess,k_gamess)
                     index2 = FirstIndex(j_gamess,l_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(i_gamess,l_gamess)
                     index2 = FirstIndex(j_gamess,k_gamess)
                     compindex2 = CompositeIndex(index1,index2)
                     K2(1,1,1,1)%bb%irrep(symgp)%block(row,col) = (TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2))
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           b_begin = virt_alpha(1,q)
           b_end   = virt_alpha(2,q)
           do a=a_begin,a_end
             do b=max(a+1,b_begin),b_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) cycle
                 c_begin = virt_alpha(1,r)
                 c_end   = virt_alpha(2,r)
                 d_begin = virt_alpha(1,s)
                 d_end   = virt_alpha(2,s)
                 do c=c_begin,c_end
                   do d=max(c+1,d_begin),d_end
                     a_gamess = OldIndex_alpha(a)
                     b_gamess = OldIndex_alpha(b)
                     c_gamess = OldIndex_alpha(c)
                     d_gamess = OldIndex_alpha(d)
                     index1 = FirstIndex(a_gamess,c_gamess)
                     index2 = FirstIndex(b_gamess,d_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(a_gamess,d_gamess)
                     index2 = FirstIndex(b_gamess,c_gamess)
                     compindex2 = CompositeIndex(index1,index2)
                     K2(2,2,2,2)%aa%irrep(symgp)%block(row,col) = (TwoIntsCompact(compindex1)- TwoIntsCompact(compindex2))
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           b_begin = virt_beta(1,q)
           b_end   = virt_beta(2,q)
           do a=a_begin,a_end
             do b=max(a+1,b_begin),b_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) cycle
                 c_begin = virt_beta(1,r)
                 c_end   = virt_beta(2,r)
                 d_begin = virt_beta(1,s)
                 d_end   = virt_beta(2,s)
                 do c=c_begin,c_end
                   do d=max(c+1,d_begin),d_end
                     a_gamess = OldIndex_beta(a)
                     b_gamess = OldIndex_beta(b)
                     c_gamess = OldIndex_beta(c)
                     d_gamess = OldIndex_beta(d)
                     index1 = FirstIndex(a_gamess,c_gamess)
                     index2 = FirstIndex(b_gamess,d_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(a_gamess,d_gamess)
                     index2 = FirstIndex(b_gamess,c_gamess)
                     compindex2 = CompositeIndex(index1,index2)
                     K2(2,2,2,2)%bb%irrep(symgp)%block(row,col) = (TwoIntsCompact(compindex1)- TwoIntsCompact(compindex2))
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp = 1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) cycle
                 a_begin = virt_alpha(1,r)
                 a_end   = virt_alpha(2,r)
                 b_begin = virt_alpha(1,s)
                 b_end   = virt_alpha(2,s)
                 do a=a_begin,a_end
                   do b=max(a+1,b_begin),b_end
                     i_gamess = OldIndex_alpha(i)
                     j_gamess = OldIndex_alpha(j)
                     a_gamess = OldIndex_alpha(a)
                     b_gamess = OldIndex_alpha(b)
                     index1 = FirstIndex(i_gamess,a_gamess)
                     index2 = FirstIndex(j_gamess,b_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(i_gamess,b_gamess)
                     index2 = FirstIndex(j_gamess,a_gamess)
                     compindex2 = CompositeIndex(index1,index2)
                      K2(1,1,2,2)%aa%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)- TwoIntsCompact(compindex2)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp = 1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           i_begin = occ_beta(1,p)
           i_end   = occ_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) cycle
                 a_begin = virt_beta(1,r)
                 a_end   = virt_beta(2,r)
                 b_begin = virt_beta(1,s)
                 b_end   = virt_beta(2,s)
                 do a=a_begin,a_end
                   do b=max(a+1,b_begin),b_end
                     i_gamess = OldIndex_beta(i)
                     j_gamess = OldIndex_beta(j)
                     a_gamess = OldIndex_beta(a)
                     b_gamess = OldIndex_beta(b)
                     index1 = FirstIndex(i_gamess,a_gamess)
                     index2 = FirstIndex(j_gamess,b_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(i_gamess,b_gamess)
                     index2 = FirstIndex(j_gamess,a_gamess)
                     compindex2 = CompositeIndex(index1,index2)
                      K2(1,1,2,2)%bb%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)- TwoIntsCompact(compindex2)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do


       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt_alpha(1,r)
                 b_end   = virt_alpha(2,r)
                 i_begin = occ_alpha(1,s)
                 i_end   = occ_alpha(2,s)
                 do i=i_begin,i_end
                   do b=b_begin,b_end
                      i_gamess = OldIndex_alpha(i)
                      j_gamess = OldIndex_alpha(j)
                      a_gamess = OldIndex_alpha(a)
                      b_gamess = OldIndex_alpha(b)
                      index1 = FirstIndex(i_gamess,j_gamess)
                      index2 = FirstIndex(a_gamess,b_gamess)
                      compindex1 = CompositeIndex(index1,index2)
                      index1 = FirstIndex(i_gamess,b_gamess)
                      index2 = FirstIndex(a_gamess,j_gamess)
                      compindex2 = CompositeIndex(index1,index2)
                      K2(1,2,1,2)%aa%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)-TwoIntsCompact(compindex2)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt_beta(1,r)
                 b_end   = virt_beta(2,r)
                 i_begin = occ_beta(1,s)
                 i_end   = occ_beta(2,s)
                 do i=i_begin,i_end
                   do b=b_begin,b_end
                      i_gamess = OldIndex_beta(i)
                      j_gamess = OldIndex_beta(j)
                      a_gamess = OldIndex_beta(a)
                      b_gamess = OldIndex_beta(b)
                      index1 = FirstIndex(i_gamess,j_gamess)
                      index2 = FirstIndex(a_gamess,b_gamess)
                      compindex1 = CompositeIndex(index1,index2)
                      index1 = FirstIndex(i_gamess,b_gamess)
                      index2 = FirstIndex(a_gamess,j_gamess)
                      compindex2 = CompositeIndex(index1,index2)
                      K2(1,2,1,2)%bb%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)-TwoIntsCompact(compindex2)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 k_begin = occ_alpha(1,r)
                 k_end   = occ_alpha(2,r)
                 l_begin = occ_beta(1,s)
                 l_end   = occ_beta(2,s)
                 do k=k_begin,k_end
                   do l=l_begin,l_end
                     i_gamess = OldIndex_alpha(i)
                     j_gamess = OldIndex_beta(j)
                     k_gamess = OldIndex_alpha(k)
                     l_gamess = OldIndex_beta(l)
                     index1 = FirstIndex(i_gamess,k_gamess)
                     index2 = FirstIndex(j_gamess,l_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(1,1,1,1)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           b_begin = virt_beta(1,q)
           b_end   = virt_beta(2,q)
           do a=a_begin,a_end
             do b=b_begin,b_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_alpha(1,r)
                 c_end   = virt_alpha(2,r)
                 d_begin = virt_beta(1,s)
                 d_end   = virt_beta(2,s)
                 do c=c_begin,c_end
                   do d=d_begin,d_end
                     a_gamess = OldIndex_alpha(a)
                     b_gamess = OldIndex_beta(b)
                     c_gamess = OldIndex_alpha(c)
                     d_gamess = OldIndex_beta(d)
                     index1 = FirstIndex(a_gamess,c_gamess)
                     index2 = FirstIndex(b_gamess,d_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(2,2,2,2)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp = 1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 a_begin = virt_alpha(1,r)
                 a_end   = virt_alpha(2,r)
                 b_begin = virt_beta(1,s)
                 b_end   = virt_beta(2,s)
                 do a=a_begin,a_end
                   do b=b_begin,b_end
                     i_gamess = OldIndex_alpha(i)
                     j_gamess = OldIndex_beta(j)
                     a_gamess = OldIndex_alpha(a)
                     b_gamess = OldIndex_beta(b)
                     index1 = FirstIndex(i_gamess,a_gamess)
                     index2 = FirstIndex(j_gamess,b_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(1,1,2,2)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do a=a_begin,a_end
             do j=j_begin,j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt_alpha(1,r)
                 b_end   = virt_alpha(2,r)
                 i_begin = occ_beta(1,s)
                 i_end   = occ_beta(2,s)
                 do b=b_begin,b_end
                   do i=i_begin,i_end
                     i_gamess = OldIndex_beta(i)
                     j_gamess = OldIndex_beta(j)
                     a_gamess = OldIndex_alpha(a)
                     b_gamess = OldIndex_alpha(b)
                     index1 = FirstIndex(i_gamess,j_gamess)
                     index2 = FirstIndex(a_gamess,b_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(2,1,2,1)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt_beta(1,r)
                 b_end   = virt_beta(2,r)
                 i_begin = occ_alpha(1,s)
                 i_end   = occ_alpha(2,s)
                 do i=i_begin,i_end
                   do b=b_begin,b_end
                     i_gamess = OldIndex_alpha(i)
                     j_gamess = OldIndex_alpha(j)
                     a_gamess = OldIndex_beta(a)
                     b_gamess = OldIndex_beta(b)
                     index1 = FirstIndex(i_gamess,j_gamess)
                     index2 = FirstIndex(a_gamess,b_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(1,2,1,2)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do


       do symgp=1,numSG
         col = 0
           do t=1,numSG
              p = InvPdt(symgp)%upper(t)
              q = InvPdt(symgp)%lower(t)
              a_begin = virt_alpha(1,p)
              a_end   = virt_alpha(2,p)
              j_begin = occ_alpha(1,q)
              j_end   = occ_alpha(2,q)
              do j=j_begin,j_end
                do a=a_begin,a_end
                  col = col + 1
                  row = 1
                  do v=1,numSG
                     r = InvPdt(symgp)%upper(v)
                     s = InvPdt(symgp)%lower(v)
                     b_begin = virt_beta(1,r)
                     b_end   = virt_beta(2,r)
                     i_begin = occ_beta(1,s)
                     i_end   = occ_beta(2,s)
                     do i=i_begin,i_end
                       do b=b_begin,b_end
                         a_gamess = OldIndex_alpha(a)
                         j_gamess = OldIndex_alpha(j)
                         b_gamess = OldIndex_beta(b)
                         i_gamess = OldIndex_beta(i)
                         index1 = FirstIndex(a_gamess,j_gamess)
                         index2 = FirstIndex(i_gamess,b_gamess)
                         compindex1 = CompositeIndex(index1,index2)
                          K2(1,2,2,1)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                         row = row + 1
                       end do
                    end do
                  end do
                end do
              end do
           end do
        end do

       do symgp=1,numSG
         col = 0
           do t=1,numSG
              p = InvPdt(symgp)%upper(t)
              q = InvPdt(symgp)%lower(t)
              a_begin = virt_beta(1,p)
              a_end   = virt_beta(2,p)
              j_begin = occ_beta(1,q)
              j_end   = occ_beta(2,q)
              do j=j_begin,j_end
                do a=a_begin,a_end
                  col = col + 1
                  row = 1
                  do v=1,numSG
                     r = InvPdt(symgp)%upper(v)
                     s = InvPdt(symgp)%lower(v)
                     b_begin = virt_alpha(1,r)
                     b_end   = virt_alpha(2,r)
                     i_begin = occ_alpha(1,s)
                     i_end   = occ_alpha(2,s)
                     do i=i_begin,i_end
                       do b=b_begin,b_end
                         a_gamess = OldIndex_beta(a)
                         j_gamess = OldIndex_beta(j)
                         b_gamess = OldIndex_alpha(b)
                         i_gamess = OldIndex_alpha(i)
                         index1 = FirstIndex(a_gamess,j_gamess)
                         index2 = FirstIndex(i_gamess,b_gamess)
                         compindex1 = CompositeIndex(index1,index2)
                          K2(2,1,1,2)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                         row = row + 1
                       end do
                    end do
                  end do
                end do
              end do
           end do
        end do




       do symgp=1,numSG
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         j_begin = occ_alpha(1,symgp)
         j_end   = occ_alpha(2,symgp)
         do i=i_begin,i_end
           do j=j_begin,j_end
             i_gamess = OldIndex_alpha(i)
             j_gamess = OldIndex_alpha(j)
             K1(1,1)%aa%irrep(symgp)%block(i,j) = OneInts(i_gamess,j_gamess)
             K1(1,1)%aa%irrep(symgp)%block(j,i) = OneInts(j_gamess,i_gamess)
           end do
         end do
       end do
       do symgp=1,numSG
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         j_begin = occ_beta(1,symgp)
         j_end   = occ_beta(2,symgp)
         do i=i_begin,i_end
           do j=j_begin,j_end
             i_gamess = OldIndex_beta(i)
             j_gamess = OldIndex_beta(j)
             K1(1,1)%bb%irrep(symgp)%block(i,j) = OneInts(i_gamess,j_gamess)
             K1(1,1)%bb%irrep(symgp)%block(j,i) = OneInts(j_gamess,i_gamess)
           end do
         end do
       end do


       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) continue
                 k_begin = occ_alpha(1,r)
                 k_end   = occ_alpha(2,r)
                 l_begin = occ_alpha(1,s)
                 l_end   = occ_alpha(2,s)
                 do k=k_begin,k_end
                   do l=max(k+1,l_begin),l_end
                       i_gamess = OldIndex_alpha(i)
                       j_gamess = OldIndex_alpha(j)
                       k_gamess = OldIndex_alpha(k)
                       l_gamess = OldIndex_alpha(l)
                       index1 = FirstIndex(i_gamess,k_gamess)
                       index2 = FirstIndex(j_gamess,l_gamess)
                       compindex1 = CompositeIndex(index1,index2)
                       index1 = FirstIndex(i_gamess,l_gamess)
                       index2 = FirstIndex(j_gamess,k_gamess)
                       compindex2 = CompositeIndex(index1,index2)
                     if(j==l.and.ProductTable(p,r)==1) then
                        K1TwoInts(1,1)%aa%irrep(p)%block(i,k) = (TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%aa%irrep(p)%block(i,k)
                     end if
                     if(i==l.and.ProductTable(q,r)==1) then
                        K1TwoInts(1,1)%aa%irrep(q)%block(j,k) = -1*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%aa%irrep(q)%block(j,k)
                     end if
                     if(j==k.and.ProductTable(p,s)==1) then
                       K1TwoInts(1,1)%aa%irrep(p)%block(i,l) = -1*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%aa%irrep(p)%block(i,l)
                     end if
                     if(i==k.and.ProductTable(q,s)==1) then
                        K1TwoInts(1,1)%aa%irrep(q)%block(j,l) = (TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%aa%irrep(q)%block(j,l)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           i_begin = occ_beta(1,p)
           i_end   = occ_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) continue
                 k_begin = occ_beta(1,r)
                 k_end   = occ_beta(2,r)
                 l_begin = occ_beta(1,s)
                 l_end   = occ_beta(2,s)
                 do k=k_begin,k_end
                   do l=max(k+1,l_begin),l_end
                       i_gamess = OldIndex_beta(i)
                       j_gamess = OldIndex_beta(j)
                       k_gamess = OldIndex_beta(k)
                       l_gamess = OldIndex_beta(l)
                       index1 = FirstIndex(i_gamess,k_gamess)
                       index2 = FirstIndex(j_gamess,l_gamess)
                       compindex1 = CompositeIndex(index1,index2)
                       index1 = FirstIndex(i_gamess,l_gamess)
                       index2 = FirstIndex(j_gamess,k_gamess)
                       compindex2 = CompositeIndex(index1,index2)
                     if(j==l.and.ProductTable(p,r)==1) then
                        K1TwoInts(1,1)%bb%irrep(p)%block(i,k) = (TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%bb%irrep(p)%block(i,k)
                     end if
                     if(i==l.and.ProductTable(q,r)==1) then
                        K1TwoInts(1,1)%bb%irrep(q)%block(j,k) = -1*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%bb%irrep(q)%block(j,k)
                     end if
                     if(j==k.and.ProductTable(p,s)==1) then
                       K1TwoInts(1,1)%bb%irrep(p)%block(i,l) = -1*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%bb%irrep(p)%block(i,l)
                     end if
                     if(i==k.and.ProductTable(q,s)==1) then
                        K1TwoInts(1,1)%bb%irrep(q)%block(j,l) = (TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%bb%irrep(q)%block(j,l)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do







       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 k_begin = occ_alpha(1,r)
                 k_end   = occ_alpha(2,r)
                 l_begin = occ_beta(1,s)
                 l_end   = occ_beta(2,s)
                 do k=k_begin,k_end
                   do l=l_begin,l_end
                     i_gamess = OldIndex_alpha(i)
                     j_gamess = OldIndex_beta(j)
                     k_gamess = OldIndex_alpha(k)
                     l_gamess = OldIndex_beta(l)
                     index1 = FirstIndex(i_gamess,k_gamess)
                     index2 = FirstIndex(j_gamess,l_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     if(j==l.and.ProductTable(p,r)==1) then
                        K1TwoInts(1,1)%aa%irrep(p)%block(i,k) = TwoIntsCompact(compindex1) + K1TwoInts(1,1)%aa%irrep(p)%block(i,k)
                     end if
                     if(i==k.and.ProductTable(q,s)==1) then
                       K1TwoInts(1,1)%bb%irrep(q)%block(j,l) = TwoIntsCompact(compindex1) + K1TwoInts(1,1)%bb%irrep(q)%block(j,l)
                      end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do



       do symgp=1,numSG
         a_begin = virt_alpha(1,symgp)
         a_end   = virt_alpha(2,symgp)
         b_begin = virt_alpha(1,symgp)
         b_end   = virt_alpha(2,symgp)
         do a=a_begin,a_end
           do b=b_begin,b_end
             a_gamess = OldIndex_alpha(a)
             b_gamess = OldIndex_alpha(b)
             K1(2,2)%aa%irrep(symgp)%block(a,b) = OneInts(a_gamess,b_gamess)
             K1(2,2)%aa%irrep(symgp)%block(b,a) = OneInts(b_gamess,a_gamess)
           end do
         end do
       end do

       do symgp=1,numSG
         a_begin = virt_beta(1,symgp)
         a_end   = virt_beta(2,symgp)
         b_begin = virt_beta(1,symgp)
         b_end   = virt_beta(2,symgp)
         do a=a_begin,a_end
           do b=b_begin,b_end
             a_gamess = OldIndex_beta(a)
             b_gamess = OldIndex_beta(b)
             K1(2,2)%bb%irrep(symgp)%block(a,b) = OneInts(a_gamess,b_gamess)
             K1(2,2)%bb%irrep(symgp)%block(b,a) = OneInts(b_gamess,a_gamess)
           end do
         end do
       end do



      do symgp=1,numSG
        a_begin = virt_alpha(1,symgp)
        a_end   = virt_alpha(2,symgp)
        i_begin = occ_alpha(1,symgp)
        i_end   = occ_alpha(2,symgp)
        row = 1
        col = 1
        do i=i_begin,i_end
          do a=a_begin,a_end
            i_gamess = OldIndex_alpha(i)
            a_gamess = OldIndex_alpha(a)
            K1(1,2)%aa%irrep(symgp)%block(row,col) = OneInts(i_gamess,a_gamess)
            row = row + 1
          end do
        end do
      end do

      do symgp=1,numSG
        a_begin = virt_beta(1,symgp)
        a_end   = virt_beta(2,symgp)
        i_begin = occ_beta(1,symgp)
        i_end   = occ_beta(2,symgp)
        row = 1
        col = 1
        do i=i_begin,i_end
          do a=a_begin,a_end
            i_gamess = OldIndex_beta(i)
            a_gamess = OldIndex_beta(a)
            K1(1,2)%bb%irrep(symgp)%block(row,col) = OneInts(i_gamess,a_gamess)
            row = row + 1
          end do
        end do
      end do




       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do a=a_begin,a_end
             do j=j_begin,j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt_alpha(1,r)
                 b_end   = virt_alpha(2,r)
                 i_begin = occ_alpha(1,s)
                 i_end   = occ_alpha(2,s)
                 do b=b_begin,b_end
                   do i=i_begin,i_end
                     if(i==j.and.ProductTable(p,r)==1) then
                       i_gamess = OldIndex_alpha(i)
                       j_gamess = OldIndex_alpha(j)
                       a_gamess = OldIndex_alpha(a)
                       b_gamess = OldIndex_alpha(b)
                       index1 = FirstIndex(i_gamess,j_gamess)
                       index2 = FirstIndex(a_gamess,b_gamess)
                       compindex1 = CompositeIndex(index1,index2)
                       index1 = FirstIndex(i_gamess,b_gamess)
                       index2 = FirstIndex(a_gamess,j_gamess)
                       compindex2 = CompositeIndex(index1,index2)
                        K1TwoInts(2,2)%aa%irrep(p)%block(a,b) = (TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(2,2)%aa%irrep(p)%block(a,b)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do a=a_begin,a_end
             do j=j_begin,j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt_beta(1,r)
                 b_end   = virt_beta(2,r)
                 i_begin = occ_beta(1,s)
                 i_end   = occ_beta(2,s)
                 do b=b_begin,b_end
                   do i=i_begin,i_end
                     if(i==j.and.ProductTable(p,r)==1) then
                       i_gamess = OldIndex_beta(i)
                       j_gamess = OldIndex_beta(j)
                       a_gamess = OldIndex_beta(a)
                       b_gamess = OldIndex_beta(b)
                       index1 = FirstIndex(i_gamess,j_gamess)
                       index2 = FirstIndex(a_gamess,b_gamess)
                       compindex1 = CompositeIndex(index1,index2)
                       index1 = FirstIndex(i_gamess,b_gamess)
                       index2 = FirstIndex(a_gamess,j_gamess)
                       compindex2 = CompositeIndex(index1,index2)
                        K1TwoInts(2,2)%bb%irrep(p)%block(a,b) = (TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(2,2)%bb%irrep(p)%block(a,b)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do


       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do a=a_begin,a_end
             do j=j_begin,j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt_beta(1,r)
                 b_end   = virt_beta(2,r)
                 i_begin = occ_alpha(1,s)
                 i_end   = occ_alpha(2,s)
                 do b=b_begin,b_end
                   do i=i_begin,i_end
                     if(i==j.and.ProductTable(p,r)==1) then
                       i_gamess = OldIndex_alpha(i)
                       j_gamess = OldIndex_alpha(j)
                       a_gamess = OldIndex_beta(a)
                       b_gamess = OldIndex_beta(b)
                       index1 = FirstIndex(i_gamess,j_gamess)
                       index2 = FirstIndex(a_gamess,b_gamess)
                       compindex1 = CompositeIndex(index1,index2)
                       index1 = FirstIndex(i_gamess,b_gamess)
                       index2 = FirstIndex(a_gamess,j_gamess)
                       compindex2 = CompositeIndex(index1,index2)
                       K1TwoInts(2,2)%bb%irrep(p)%block(a,b) = TwoIntsCompact(compindex1) + K1TwoInts(2,2)%bb%irrep(p)%block(a,b)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do a=a_begin,a_end
             do j=j_begin,j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt_alpha(1,r)
                 b_end   = virt_alpha(2,r)
                 i_begin = occ_beta(1,s)
                 i_end   = occ_beta(2,s)
                 do b=b_begin,b_end
                   do i=i_begin,i_end
                     if(i==j.and.ProductTable(p,r)==1) then
                       i_gamess = OldIndex_beta(i)
                       j_gamess = OldIndex_beta(j)
                       a_gamess = OldIndex_alpha(a)
                       b_gamess = OldIndex_alpha(b)
                       index1 = FirstIndex(i_gamess,j_gamess)
                       index2 = FirstIndex(a_gamess,b_gamess)
                       compindex1 = CompositeIndex(index1,index2)
                       index1 = FirstIndex(i_gamess,b_gamess)
                       index2 = FirstIndex(a_gamess,j_gamess)
                       compindex2 = CompositeIndex(index1,index2)
                       K1TwoInts(2,2)%aa%irrep(p)%block(a,b) = TwoIntsCompact(compindex1) + K1TwoInts(2,2)%aa%irrep(p)%block(a,b)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do




       do symgp=1,numSG
          col = 1
          row = 0
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_alpha(1,q)
           k_end   = occ_alpha(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_alpha(1,r)
             a_end   = virt_alpha(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                    row = row + 1
                    col = 1
                   do i=i_begin,i_end
                     i_gamess = OldIndex_alpha(i)
                     j_gamess = OldIndex_alpha(j)
                     a_gamess = OldIndex_alpha(a)
                     k_gamess = OldIndex_alpha(k)
                     index1 = FirstIndex(j_gamess,i_gamess)
                     index2 = FirstIndex(k_gamess,a_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(j_gamess,a_gamess)
                     index2 = FirstIndex(k_gamess,i_gamess)
                     compindex2 = CompositeIndex(index1,index2)
                     K2(1,1,1,2)%aa%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do



       do symgp=1,numSG
          col = 1
          row = 0
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_beta(1,r)
             a_end   = virt_beta(2,r)
             j_begin = occ_beta(1,s)
             j_end   = occ_beta(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                    row = row + 1
                    col = 1
                   do i=i_begin,i_end
                     i_gamess = OldIndex_beta(i)
                     j_gamess = OldIndex_beta(j)
                     a_gamess = OldIndex_beta(a)
                     k_gamess = OldIndex_beta(k)
                     index1 = FirstIndex(j_gamess,i_gamess)
                     index2 = FirstIndex(k_gamess,a_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(j_gamess,a_gamess)
                     index2 = FirstIndex(k_gamess,i_gamess)
                     compindex2 = CompositeIndex(index1,index2)
                     K2(1,1,1,2)%bb%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)
                     col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do


       do symgp=1,numSG
          col = 1
          row = 0
         a_begin = virt_alpha(1,symgp)
         a_end   = virt_alpha(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_alpha(1,q)
           c_end   = virt_alpha(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_alpha(1,r)
             b_end   = virt_alpha(2,r)
             i_begin = occ_alpha(1,s)
             i_end   = occ_alpha(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=max(c_begin,b+1),c_end
                    row = row + 1
                    col = 1
                   do a=a_begin,a_end
                     b_gamess = OldIndex_alpha(b)
                     i_gamess = OldIndex_alpha(i)
                     c_gamess = OldIndex_alpha(c)
                     a_gamess = OldIndex_alpha(a)
                     index1 = FirstIndex(b_gamess,i_gamess)
                     index2 = FirstIndex(c_gamess,a_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(b_gamess,a_gamess)
                     index2 = FirstIndex(c_gamess,i_gamess)
                     compindex2 = CompositeIndex(index1,index2)
                     K2(2,2,1,2)%aa%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)
                    col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do



       do symgp=1,numSG
          col = 1
          row = 0
         a_begin = virt_beta(1,symgp)
         a_end   = virt_beta(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_beta(1,q)
           c_end   = virt_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_beta(1,r)
             b_end   = virt_beta(2,r)
             i_begin = occ_beta(1,s)
             i_end   = occ_beta(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=max(c_begin,b+1),c_end
                    row = row + 1
                    col = 1
                   do a=a_begin,a_end
                     b_gamess = OldIndex_beta(b)
                     i_gamess = OldIndex_beta(i)
                     c_gamess = OldIndex_beta(c)
                     a_gamess = OldIndex_beta(a)
                     index1 = FirstIndex(b_gamess,i_gamess)
                     index2 = FirstIndex(c_gamess,a_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(b_gamess,a_gamess)
                     index2 = FirstIndex(c_gamess,i_gamess)
                     compindex2 = CompositeIndex(index1,index2)
                     K2(2,2,1,2)%bb%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)
                    col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do




       do symgp=1,numSG
          row = 0
          col = 1
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_beta(1,r)
             a_end   = virt_beta(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do k=k_begin,k_end
                 do a=a_begin,a_end
                   col = 1
                   row = row + 1
                   do i=i_begin,i_end
                     i_gamess = OldIndex_alpha(i)
                     a_gamess = OldIndex_beta(a)
                     j_gamess = OldIndex_alpha(j)
                     k_gamess = OldIndex_beta(k)
                     index1 = FirstIndex(j_gamess,i_gamess)
                     index2 = FirstIndex(k_gamess,a_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(1,1,1,2)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
          row = 0
          col = 1
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_alpha(1,r)
             a_end   = virt_alpha(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=k_begin,k_end
                    row = row + 1
                    col = 1
                   do i=i_begin,i_end
                     j_gamess = OldIndex_alpha(j)
                     a_gamess = OldIndex_alpha(a)
                     k_gamess = OldIndex_beta(k)
                     i_gamess = OldIndex_beta(i)
                     index1 = FirstIndex(j_gamess,a_gamess)
                     index2 = FirstIndex(k_gamess,i_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(1,1,2,1)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                     col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
          row = 0
          col = 1
         a_begin = virt_beta(1,symgp)
         a_end   = virt_beta(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_beta(1,q)
           c_end   = virt_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_alpha(1,r)
             b_end   = virt_alpha(2,r)
             i_begin = occ_alpha(1,s)
             i_end   = occ_alpha(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=c_begin,c_end
                    col = 1
                    row = row + 1
                   do a=a_begin,a_end
                     b_gamess = OldIndex_alpha(b)
                     i_gamess = OldIndex_alpha(i)
                     c_gamess = OldIndex_beta(c)
                     a_gamess = OldIndex_beta(a)
                     index1 = FirstIndex(b_gamess,i_gamess)
                     index2 = FirstIndex(c_gamess,a_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     K2(2,2,1,2)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
          row = 0
          col = 1
         a_begin = virt_alpha(1,symgp)
         a_end   = virt_alpha(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_beta(1,q)
           c_end   = virt_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_alpha(1,r)
             b_end   = virt_alpha(2,r)
             i_begin = occ_beta(1,s)
             i_end   = occ_beta(2,s)
             do b=b_begin,b_end
               do i=i_begin,i_end
                 do c=c_begin,c_end
                    col = 1
                    row = row + 1
                   do a=a_begin,a_end
                     b_gamess = OldIndex_alpha(b)
                     a_gamess = OldIndex_alpha(a)
                     c_gamess = OldIndex_beta(c)
                     i_gamess = OldIndex_beta(i)
                     index1 = FirstIndex(b_gamess,a_gamess)
                     index2 = FirstIndex(c_gamess,i_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     K2(2,2,2,1)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
allocate(InverseBasisK1_alpha(1:numSG))
      do symgp=1,numSG
        counter = 1
        i_begin = occ_alpha(1,symgp)
        i_end   = occ_alpha(2,symgp)
        a_begin = virt_alpha(1,symgp)
        a_end   = virt_alpha(2,symgp)
        allocate(InverseBasisK1_alpha(symgp)%basis(i_begin:i_end,a_begin:a_end))
        do i=i_begin,i_end
          do a=a_begin,a_end
            InverseBasisK1_alpha(symgp)%basis(i,a) = counter
            counter = counter + 1
          end do
        end do
      end do



allocate(InverseBasisK1_beta(1:numSG))
      do symgp=1,numSG
        counter = 1
        i_begin = occ_beta(1,symgp)
        i_end   = occ_beta(2,symgp)
        a_begin = virt_beta(1,symgp)
        a_end   = virt_beta(2,symgp)
        allocate(InverseBasisK1_beta(symgp)%basis(i_begin:i_end,a_begin:a_end))
        do i=i_begin,i_end
          do a=a_begin,a_end
            InverseBasisK1_beta(symgp)%basis(i,a) = counter
            counter = counter + 1
          end do
        end do
      end do





       do symgp=1,numSG
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         numi = i_end - i_begin + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_alpha(1,q)
           k_end   = occ_alpha(2,q)
           numk = k_end - k_begin + 1
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_alpha(1,r)
             a_end   = virt_alpha(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                   do i=i_begin,i_end
                     i_gamess = OldIndex_alpha(i)
                     j_gamess = OldIndex_alpha(j)
                     k_gamess = OldIndex_alpha(k)
                     a_gamess = OldIndex_alpha(a)
                     index1 = FirstIndex(i_gamess,j_gamess)
                     index2 = FirstIndex(a_gamess,k_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(i_gamess,k_gamess)
                     index2 = FirstIndex(a_gamess,j_gamess)
                     compindex2 = CompositeIndex(index1,index2)
                     if(i.eq.j.and.ProductTable(r,q).eq.1) then
                        K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1_alpha(r)%basis(k,a),1) = 2*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1_alpha(r)%basis(k,a),1)
                     end if
                     if(i.eq.k.and.ProductTable(s,r).eq.1) then
                       K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1_alpha(r)%basis(j,a),1) =-2*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1_alpha(r)%basis(j,a),1)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do


       do symgp=1,numSG
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         numi = i_end - i_begin + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           numk = k_end - k_begin + 1
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_beta(1,r)
             a_end   = virt_beta(2,r)
             j_begin = occ_beta(1,s)
             j_end   = occ_beta(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                   do i=i_begin,i_end
                     i_gamess = OldIndex_beta(i)
                     j_gamess = OldIndex_beta(j)
                     k_gamess = OldIndex_beta(k)
                     a_gamess = OldIndex_beta(a)
                     index1 = FirstIndex(i_gamess,j_gamess)
                     index2 = FirstIndex(a_gamess,k_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(i_gamess,k_gamess)
                     index2 = FirstIndex(a_gamess,j_gamess)
                     compindex2 = CompositeIndex(index1,index2)
                     if(i.eq.j.and.ProductTable(r,q).eq.1) then
                       K1TwoInts(1,2)%bb%irrep(r)%block(InverseBasisK1_beta(r)%basis(k,a),1) = 2*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,2)%bb%irrep(r)%block(InverseBasisK1_beta(r)%basis(k,a),1)
                     end if
                     if(i.eq.k.and.ProductTable(s,r).eq.1) then
                       K1TwoInts(1,2)%bb%irrep(r)%block(InverseBasisK1_beta(r)%basis(j,a),1) =-2*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,2)%bb%irrep(r)%block(InverseBasisK1_beta(r)%basis(j,a),1)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do




       do symgp=1,numSG
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_beta(1,r)
             a_end   = virt_beta(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do k=k_begin,k_end
                 do a=a_begin,a_end
                   do i=i_begin,i_end
                     if(i.eq.j.and.ProductTable(q,r).eq.1) then
                       i_gamess = OldIndex_alpha(i)
                       j_gamess = OldIndex_alpha(j)
                       a_gamess = OldIndex_beta(a)
                       k_gamess = OldIndex_beta(k)
                       index1 = FirstIndex(j_gamess,i_gamess)
                       index2 = FirstIndex(k_gamess,a_gamess)
                       compindex1 = CompositeIndex(index1,index2)
                       K1TwoInts(1,2)%bb%irrep(r)%block(InverseBasisK1_beta(r)%basis(k,a),1) =2*TwoIntsCompact(compindex1) + K1TwoInts(1,2)%bb%irrep(r)%block(InverseBasisK1_beta(r)%basis(k,a),1)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_alpha(1,r)
             a_end   = virt_alpha(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=k_begin,k_end
                   do i=i_begin,i_end
                     if(i.eq.k.and.ProductTable(r,s).eq.1) then
                       i_gamess = OldIndex_beta(i)
                       k_gamess = OldIndex_beta(k)
                       a_gamess = OldIndex_alpha(a)
                       j_gamess = OldIndex_alpha(j)
                       index1 = FirstIndex(j_gamess,a_gamess)
                       index2 = FirstIndex(k_gamess,i_gamess)
                       compindex1 = CompositeIndex(index1,index2)
                       K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1_alpha(r)%basis(j,a),1) = 2*TwoIntsCompact(compindex1) + K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1_alpha(r)%basis(j,a),1)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

      numocc_alpha = 0
      numvirt_alpha = 0
      numocc_beta = 0
      numvirt_beta = 0
      do i=1,numSG
        numocc_alpha = occ_alpha(2,i) - occ_alpha(1,i) + 1 + numocc_alpha
        numvirt_alpha = virt_alpha(2,i) - virt_alpha(1,i) + 1 + numvirt_alpha
        numocc_beta = occ_beta(2,i) - occ_beta(1,i) + 1 + numocc_beta
        numvirt_beta = virt_beta(2,i) - virt_beta(1,i) + 1 + numvirt_beta
      end do
      numocc = max(numocc_alpha,numocc_beta)
      numtotal = numocc_alpha + numvirt_alpha
      begin_virt = min(numocc_alpha,numocc_beta)
      begin_virt = begin_virt + 1
      if(begin_virt.eq.0) then
        write(*,*) 'You do not have any virtual orbitals...Exiting...'
        stop
      end if
      allocate(TwoInts(1:numocc,1:numocc,begin_virt:numtotal,begin_virt:numtotal))
      TwoInts(1:numocc,1:numocc,begin_virt:numtotal,begin_virt:numtotal) = 0.0
      do i=1,numocc
        do j=1,numocc
          do a=begin_virt,numtotal
             do b=begin_virt,numtotal
               index1 = FirstIndex(i,a)
               index2 = FirstIndex(j,b)
               compindex1 = CompositeIndex(index1,index2)
               integral = TwoIntsCompact(compindex1)
               TwoInts(i,j,a,b) = integral
               TwoInts(j,i,b,a) = integral
             end do
           end do
         end do
      end do
        deallocate(TwoIntsCompact)



Call cpu_time(time_end)
      time_buildk2k1 = time_buildk2k1 + time_end - time_begin

       end subroutine BuildK2K1OS

!> @brief Controls the single point calculation for open shell molecules
!> @author Christine Schwerdtfeger and David Mazziotti
      subroutine SinglePointOS(numocc_alpha,numocc_beta,numvirt_alpha,numvirt_beta,SG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,T2deriv,Newc,DerivNewc,T1data,T1deriv,ReshapedMatrixDim,InvPdt,OneInts,TwoIntsCompact,Sym_alpha,Sym_beta,energy,topfac,topsingles,numElements,inputfile,numrowblocks,EPS,OldIndex_alpha,OldIndex_beta,T2derivT1topfac,Newc_singles,DerivNewc_singles)

      Use InterfaceMod
      USE TypeMod
      Use TimeMod, only : time_singlepoint
      Implicit NONE
      integer :: numvirt_alpha,numvirt_beta
      integer :: numocc_alpha,numocc_beta
      integer :: SG
      integer, allocatable, dimension(:,:) :: ProductTable
      integer, allocatable, dimension(:,:) :: occ_alpha, occ_beta, virt_alpha, virt_beta
      type(T2) :: T2data,T2deriv
      type(T2) :: Newc, DerivNewc
      type(T2) :: T2derivT1topfac
      type(T1) :: T1data,T1deriv
      type(T1) :: Newc_singles, DerivNewc_singles
      integer :: numrowblocks
      type(ReshapedDim) :: ReshapedMatrixDim
      type(symmetry), allocatable, dimension(:) :: InvPdt
      real(8), allocatable, dimension(:,:) :: OneInts
      real(8), allocatable, dimension(:) :: TwoIntsCompact
      integer, allocatable, dimension(:) :: Sym_alpha, Sym_beta
      double precision :: energy
      real(8), dimension(0:2,0:2) :: topfac
      real(8), dimension(0:1,0:1) :: topsingles
      integer :: numElements
      character(len=100) :: inputfile
      double precision :: EPS
      integer, allocatable, dimension(:) :: OldIndex_alpha, OldIndex_beta
      integer :: counter


      type(spin) :: K2(1:2,1:2,1:2,1:2)
      type(spin) :: K1(1:2,1:2)
      type(spin) :: K1TwoInts(1:2,1:2)
      real(8), allocatable, dimension(:,:,:,:) :: TwoInts
      real(8), allocatable, dimension(:) :: DerivVector, Tvector
      double precision :: energyconstants
      integer :: iter,p,M
      integer :: IPRINT(1:2), SPFLAG
      double precision, allocatable, dimension(:) :: W
      double precision ::  XTOL
      double precision, allocatable, dimension(:) :: DIAG
      real :: time_begin, time_end, begin_loop,end_loop
      integer :: begin_wall, end_wall, interval
      logical :: DIAGCO = .false.
      character(len=100) :: K2files
      integer :: j_begin,j_end, a_begin,a_end, i,b
      type(BlockMatMulDims) :: BlockDim
      integer :: i_begin,i_end, b_begin,b_end,iindex,bindex,a,symtop,bsym,isym,t,j

       if(numrowblocks.eq.1) then
         Call BuildK2K1OS(occ_alpha,occ_beta,virt_alpha,virt_beta,SG,InvPdt,TwoIntsCompact,OneInts,ReshapedMatrixDim,K2,K1,ProductTable,K1TwoInts,TwoInts,OldIndex_alpha,OldIndex_beta)
       else
         Call BuildK2K1BlockK2OS(occ_alpha,occ_beta,virt_alpha,virt_beta,SG,InvPdt,TwoIntsCompact,OneInts,ReshapedMatrixDim,K2,K1,ProductTable,K1TwoInts,TwoInts,numrowblocks,BlockDim,inputfile,OldIndex_alpha,OldIndex_beta)
       end if

      Call cpu_time(time_begin)

        IPRINT(1) = -1
        IPRINT(2) = 0
        SPFLAG=0
        XTOL = epsilon(1.0D0)
        M = 2




        allocate(DIAG(1:numElements))
        allocate(W(numElements*(2*M+1)+2*M))
        allocate(Tvector(1:numElements))
        allocate(DerivVector(1:numElements))
        Tvector(1:numElements) = 0.0D0
        DerivVector(1:numElements) = 0.0D0
        DIAG(1:numElements) = 1.0D0
        energy = 0.0D0
        energyconstants = 0.0D0
        Call DataStructureOS(T2data,numocc_alpha, numocc_beta,numvirt_alpha,numvirt_beta,InvPdt,SG,occ_alpha, occ_beta,virt_alpha,virt_beta,ProductTable,Sym_alpha,Sym_beta,T2deriv,1,numElements,T1data,T1deriv,Newc,DerivNewc,inputfile,T2derivT1topfac,Newc_singles,DerivNewc_singles)
        Call CalcEnergyOS(T2data,SG,T2deriv,energyconstants,K2,InvPdt,ReshapedMatrixDim,occ_alpha,occ_beta,virt_alpha,virt_beta,K1)
        if(numrowblocks.eq.1) then
          Call CalcDerivOS(T2data,K2,K1,SG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,ReshapedMatrixDim,InvPdt,T2deriv, energy,K1TwoInts,T1data,T1deriv,Newc,DerivNewc,topfac,TwoInts,topsingles,OldIndex_alpha,OldIndex_beta,T2derivT1topfac,Newc_singles,DerivNewc_singles)
        else
          Call CalcDerivBlockK2OS(T2data,K2,K1,SG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,ReshapedMatrixDim,InvPdt,T2deriv, energy,K1TwoInts,T1data,T1deriv,Newc,DerivNewc,topfac,TwoInts,topsingles,OldIndex_alpha,OldIndex_beta,T2derivT1topfac,Newc_singles,DerivNewc_singles,numrowblocks,inputfile,BlockDim)
        end if
       Call AveDerivOS(InvPdt,SG,occ_alpha,occ_beta,virt_alpha,virt_beta,ProductTable,Sym_alpha,Sym_beta,T2deriv)
        energy = energy + energyconstants
       Call CalcParametersOS(SG,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,InvPdt,T2deriv,DerivVector,Tvector,T1data,T1deriv)
        iter = 0
        do
          iter = iter + 1
        Call LBFGS(numElements,M,Tvector,energy,DerivVector,DIAGCO,DIAG,IPRINT,EPS,XTOL,W,SPFLAG)
          Call CalcParametersInverseOS(SG,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,InvPdt,Tvector,T1data)







          if(SPFLAG==1) then
           energy = 0.0D0
           Call DataStructureOS(T2data,numocc_alpha, numocc_beta,numvirt_alpha,numvirt_beta,InvPdt,SG,occ_alpha, occ_beta,virt_alpha,virt_beta,ProductTable,Sym_alpha,Sym_beta,T2deriv,1,numElements,T1data,T1deriv,Newc,DerivNewc,inputfile,T2derivT1topfac,Newc_singles,DerivNewc_singles)

           if(numrowblocks.eq.1) then
             Call CalcDerivOS(T2data,K2,K1,SG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,ReshapedMatrixDim,InvPdt,T2deriv, energy,K1TwoInts,T1data,T1deriv,Newc,DerivNewc,topfac,TwoInts,topsingles,OldIndex_alpha,OldIndex_beta,T2derivT1topfac,Newc_singles,DerivNewc_singles)
           else
            Call CalcDerivBlockK2OS(T2data,K2,K1,SG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,ReshapedMatrixDim,InvPdt,T2deriv, energy,K1TwoInts,T1data,T1deriv,Newc,DerivNewc,topfac,TwoInts,topsingles,OldIndex_alpha,OldIndex_beta,T2derivT1topfac,Newc_singles,DerivNewc_singles,numrowblocks,inputfile,BlockDim)
           end if
            Call AveDerivOS(InvPdt,SG,occ_alpha,occ_beta,virt_alpha,virt_beta,ProductTable,Sym_alpha,Sym_beta,T2deriv)
            energy = energy + energyconstants
           1500 format(1X,'Iteration and Electronic Energy:',1X,I5,1X,F30.14)
            write(*,1500) iter,energy

            Call CalcParametersOS(SG,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,InvPdt,T2deriv,DerivVector,Tvector,T1data,T1deriv)
          end if
          if(SPFLAG==-1) then
            write(*,*) '***********  ERROR   **********'
            write(*,*) 'P2RDM CALCULATION DID NOT CONVERGE.'
            write(*,*) 'EXITING . . . '
            stop
          end if
          if(SPFLAG==0) then
          energy = energy - energyconstants
          write(*,*) '  '
          write(*,*) 'P2RDM ELECTRONIC ENERGY CONVERGED.'



          deallocate(OneInts)
          deallocate(TwoInts)
          deallocate(DIAG)
          deallocate(W)
          deallocate(Tvector)
          deallocate(DerivVector)
         deallocate(K2(1,1,1,1)%aa%irrep)
         if(numrowblocks.eq.1) then
           deallocate(K2(2,2,2,2)%aa%irrep)
           deallocate(K2(2,2,2,2)%ab%irrep)
         end if
         deallocate(K2(1,2,1,2)%aa%irrep)
         deallocate(K2(1,1,2,2)%aa%irrep)
         deallocate(K2(1,1,1,1)%ab%irrep)
         deallocate(K2(1,2,1,2)%ab%irrep)
         deallocate(K2(1,1,2,2)%ab%irrep)
         deallocate(K2(1,2,2,1)%ab%irrep)
         deallocate(K2(1,1,1,2)%aa%irrep)
         deallocate(K2(2,2,1,2)%aa%irrep)
         deallocate(K2(1,1,1,2)%ab%irrep)
         deallocate(K2(1,1,2,1)%ab%irrep)
         deallocate(K2(2,2,1,2)%ab%irrep)
         deallocate(K2(2,2,2,1)%ab%irrep)
         deallocate(K1(1,1)%aa%irrep)
         deallocate(K1(2,2)%aa%irrep)
         deallocate(K1(1,2)%aa%irrep)
         deallocate(K1TwoInts(1,1)%aa%irrep)
         deallocate(K1TwoInts(2,2)%aa%irrep)
         deallocate(K1TwoInts(1,2)%aa%irrep)
         if(numrowblocks.gt.1) then
           K2files = 'rm ' // trim(inputfile) // 'aa*'
           Call system(K2files)
           K2files = 'rm ' // trim(inputfile) // 'ab*'
           Call system(K2files)
           K2files = 'rm ' // trim(inputfile) // 'bb*'
           Call system(K2files)
           deallocate(BlockDim%aa%symgp)
           deallocate(BlockDim%ab%symgp)
           deallocate(BlockDim%bb%symgp)
         end if
          Call cpu_time(time_end)
          time_singlepoint = time_end - time_begin + time_singlepoint
          return
          end if
        end do

      end subroutine SinglePointOS

!> @brief Calculates the hartree fock energy for open shell calculations
!> @author Christine Schwerdtfeger and David Mazziotti
        subroutine CalcEnergyOS(T2data,numSG,T2deriv,energyconstants,K2,InvPdt,ReshapedMatrixDim,occ_alpha, occ_beta,virt_alpha,virt_beta,K1)
        Use InterfaceMod
        Use TypeMod
        Use TimeMod, only : time_calcenergy
        Implicit None

        type(T2), intent(IN) :: T2data
        type(T2), intent(IN) :: T2deriv
        integer :: numSG
        real(8) :: energyconstants
        type(spin) :: K2(1:2,1:2,1:2,1:2)
        type(symmetry), intent(IN) :: InvPdt(1:numSG)
        type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
        integer, allocatable, dimension(:,:) :: occ_alpha, occ_beta, virt_alpha, virt_beta
        type(spin) :: K1(1:2,1:2)

        integer :: symgp,t,v,p,q,r,s,row,col,i,j,k,l,c,a,b
        integer :: i_begin,i_end,j_begin,j_end,k_begin,k_end,l_begin,l_end,c_begin,c_end
        integer :: a_begin,a_end
        real(8), allocatable, dimension(:,:) :: temp
        type(ReshapedMat), allocatable, dimension(:)  :: Reshapes
        real :: time_begin, time_end

        call cpu_time(time_begin)

        energyconstants = 0
       allocate(Reshapes(1:numSG))
       do p=1,numSG
          allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ijaa(p)%col,1:ReshapedMatrixDim%ijaa(p)%col))
       end do

      do symgp=1,numSG
         col = 0
         do t=1,numSG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             if(p.GT.q) then
               cycle
             end if
             i_begin = occ_alpha(1,p)
             i_end   = occ_alpha(2,p)
             j_begin = occ_alpha(1,q)
             j_end   = occ_alpha(2,q)
             do i=i_begin,i_end
               do j=max(i+1,j_begin),j_end
                 col = col + 1
                 row = 1
                 do v=1,numSG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   if(r.GT.s) then
                     cycle
                   end if
                   k_begin = occ_alpha(1,r)
                   k_end   = occ_alpha(2,r)
                   l_begin = occ_alpha(1,s)
                   l_end   = occ_alpha(2,s)
                   do k=k_begin,k_end
                     do l=max(k+1,l_begin),l_end
                       if(i==k.and.j==l.and.k.ne.j) then
                         Reshapes(symgp)%ReshapedMatrix(row,col) = 1
                       else
                         Reshapes(symgp)%ReshapedMatrix(row,col) = 0
                       end if
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do


       do p=1,numSG
           allocate(temp(1:ReshapedMatrixDim%ijaa(p)%col,1:ReshapedMatrixDim%ijaa(p)%col))
           temp = matmul4(K2(1,1,1,1)%aa%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
           do q=1,ReshapedMatrixDim%ijaa(p)%col
             energyconstants = energyconstants + temp(q,q)
           end do
           deallocate(temp)
         end do

      deallocate(Reshapes)
       allocate(Reshapes(1:numSG))
       do p=1,numSG
          allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ijbb(p)%col,1:ReshapedMatrixDim%ijbb(p)%col))
       end do

      do symgp=1,numSG
         col = 0
         do t=1,numSG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             if(p.GT.q) then
               cycle
             end if
             i_begin = occ_beta(1,p)
             i_end   = occ_beta(2,p)
             j_begin = occ_beta(1,q)
             j_end   = occ_beta(2,q)
             do i=i_begin,i_end
               do j=max(i+1,j_begin),j_end
                 col = col + 1
                 row = 1
                 do v=1,numSG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   if(r.GT.s) then
                     cycle
                   end if
                   k_begin = occ_beta(1,r)
                   k_end   = occ_beta(2,r)
                   l_begin = occ_beta(1,s)
                   l_end   = occ_beta(2,s)
                   do k=k_begin,k_end
                     do l=max(k+1,l_begin),l_end
                       if(i==k.and.j==l.and.k.ne.j) then
                         Reshapes(symgp)%ReshapedMatrix(row,col) = 1
                       else
                         Reshapes(symgp)%ReshapedMatrix(row,col) = 0
                       end if
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do


       do p=1,numSG
           allocate(temp(1:ReshapedMatrixDim%ijbb(p)%col,1:ReshapedMatrixDim%ijbb(p)%col))
           temp = matmul4(K2(1,1,1,1)%bb%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
           do q=1,ReshapedMatrixDim%ijbb(p)%col
             energyconstants = energyconstants + temp(q,q)
           end do
           deallocate(temp)
         end do

      deallocate(Reshapes)




      allocate(Reshapes(1:numSG))
       do p=1,numSG
          allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ijab(p)%col,1:ReshapedMatrixDim%ijab(p)%col))
       end do

      do symgp=1,numSG
         col =0
         do t=1,numSG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             i_begin = occ_alpha(1,p)
             i_end   = occ_alpha(2,p)
             j_begin = occ_beta(1,q)
             j_end   = occ_beta(2,q)
             do i=i_begin,i_end
               do j=j_begin,j_end
                 col = col + 1
                 row = 1
                 do v=1,numSG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   k_begin = occ_alpha(1,r)
                   k_end   = occ_alpha(2,r)
                   l_begin = occ_beta(1,s)
                   l_end   = occ_beta(2,s)
                   do k=k_begin,k_end
                     do l=l_begin,l_end
                       if(i==k.and.j==l) then
                         Reshapes(symgp)%ReshapedMatrix(row,col) = 2*0.5
                       else
                         Reshapes(symgp)%ReshapedMatrix(row,col) = 0
                       end if
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do
       do p=1,numSG
         allocate(temp(1:ReshapedMatrixDim%ijab(p)%col,1:ReshapedMatrixDim%ijab(p)%col))
         temp = matmul4(K2(1,1,1,1)%ab%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
         do q=1,ReshapedMatrixDim%ijab(p)%col
           energyconstants = energyconstants + temp(q,q)
         end do
         deallocate(temp)
       end do
       deallocate(Reshapes)

       allocate(Reshapes(1:numSG))
       do p=1,numSG
         i_begin = occ_alpha(1,p)
         i_end   = occ_alpha(2,p)
         allocate(Reshapes(p)%ReshapedMatrix(i_begin:i_end,i_begin:i_end))
         Reshapes(p)%ReshapedMatrix(i_begin:i_end,i_begin:i_end) = 0.D0
      end do
       do p=1,numSG
         i_begin=occ_alpha(1,p)
         i_end  =occ_alpha(2,p)
         do i=i_begin,i_end
           Reshapes(p)%ReshapedMatrix(i,i) = 1
         end do
       end do


       do p=1,numSG
         i_begin = occ_alpha(1,p)
         i_end   = occ_alpha(2,p)
         allocate(temp(1:(i_end-i_begin+1),1:(i_end-i_begin +1)))
         temp = matmul(Reshapes(p)%ReshapedMatrix,K1(1,1)%aa%irrep(p)%block)
         do t=1,(i_end-i_begin+1)
           energyconstants = temp(t,t) + energyconstants
         end do
         deallocate(temp)
       end do
      deallocate(Reshapes)

       allocate(Reshapes(1:numSG))
       do p=1,numSG
         i_begin = occ_beta(1,p)
         i_end   = occ_beta(2,p)
         allocate(Reshapes(p)%ReshapedMatrix(i_begin:i_end,i_begin:i_end))
         Reshapes(p)%ReshapedMatrix(i_begin:i_end,i_begin:i_end) = 0.D0
      end do
       do p=1,numSG
         i_begin=occ_beta(1,p)
         i_end  =occ_beta(2,p)
         do i=i_begin,i_end
           Reshapes(p)%ReshapedMatrix(i,i) = 1
         end do
       end do


       do p=1,numSG
         i_begin = occ_beta(1,p)
         i_end   = occ_beta(2,p)
         allocate(temp(1:(i_end-i_begin+1),1:(i_end-i_begin +1)))
         temp = matmul(Reshapes(p)%ReshapedMatrix,K1(1,1)%bb%irrep(p)%block)
         do t=1,(i_end-i_begin+1)
           energyconstants = temp(t,t) + energyconstants
         end do
         deallocate(temp)
       end do


       1600 format(1X,'Hartree Fock Electronic Energy:',8X,F30.14)
       write(*,1600) energyconstants

       call cpu_time(time_end)
        time_calcenergy = time_calcenergy + time_end - time_begin
      end subroutine CalcEnergyOS

!> @brief Builds the K1 and K2 matrices for the disk writing feature (open shell)(intel compilers only)
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine BuildK2K1BlockK2OS(occ_alpha,occ_beta,virt_alpha,virt_beta,numSG,InvPdt,TwoIntsCompact,OneInts,ReshapedMatrixDim,K2,K1,ProductTable,K1TwoInts,TwoInts,numrowblocks,BlockDim,inputfile,OldIndex_alpha,OldIndex_beta)
      Use TypeMod
      Use TimeMod, only : time_buildk2k1
      Use InterfaceMod
      Implicit None

      integer, intent(IN), allocatable, dimension(:,:) :: occ_alpha,occ_beta, virt_alpha,virt_beta
      integer, intent(IN) :: numSG
      type(symmetry), allocatable, dimension(:) :: InvPdt
      real(8), allocatable, dimension(:,:,:,:) :: TwoInts
      real(8), intent(IN), allocatable, dimension(:,:) :: OneInts
      real(8), allocatable, dimension(:) :: TwoIntsCompact
      type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
      type(spin) :: K2(1:2,1:2,1:2,1:2)
      type(spin) :: K1(1:2,1:2)
      integer, dimension(1:numSG,1:numSG) :: ProductTable
      type(spin) :: K1TwoInts(1:2,1:2)
      integer :: numrowblocks
      type(BlockMatMulDims) :: BlockDim
      character(len=100) :: inputfile
      integer, allocatable, dimension(:) :: OldIndex_alpha, OldIndex_beta

      integer :: i,j,k,l,i_begin,i_end,j_begin,j_end,k_begin,k_end,l_begin,l_end
      integer :: symgp, t,v,p,q,r,s
      integer :: row, col,numi,numa,numk
      integer :: a,b,c,d,a_begin,a_end,b_begin,b_end,c_begin,c_end,d_begin,d_end
      integer :: i_gamess,j_gamess,k_gamess,l_gamess,a_gamess,b_gamess,c_gamess,d_gamess
      integer :: u
      integer :: begindim,enddim,enddim_occ
      real(8) :: test(1:2,1:2)
      real :: time_begin, time_end
      integer :: numocc,numvirt,begin_virt,numocc_alpha, numocc_beta,numvirt_beta,numvirt_alpha,begin_virt_alpha,begin_virt_beta, numtotal
      type(InverseBasis), allocatable, dimension(:) :: InverseBasisK1_alpha, InverseBasisK1_beta
      integer :: counter
      real(8) :: integral
      integer*8 :: index1,index2,compindex1,compindex2
      double precision, allocatable, dimension(:,:) :: K2vvvv
      character(len=100) :: K2vvvvfile
      integer :: totalrows,totalcols,rowsperblock,remainder,m,colsperblock
      integer :: rowoffset,coloffset,counter1,counter2
      integer :: z,iostat
      character(len=4)  :: tempchar
      character(len=100) :: tempfile
      integer*8 :: recordlength, temprow, tempcol


      Call cpu_time(time_begin)
      allocate(K2(1,1,1,1)%aa%irrep(1:numSG))
      allocate(K2(1,2,1,2)%aa%irrep(1:numSG))
      allocate(K2(1,1,2,2)%aa%irrep(1:numSG))
      allocate(K2(1,1,1,1)%bb%irrep(1:numSG))
      allocate(K2(1,2,1,2)%bb%irrep(1:numSG))
      allocate(K2(1,1,2,2)%bb%irrep(1:numSG))
      allocate(K2(1,1,1,1)%ab%irrep(1:numSG))
      allocate(K2(1,2,1,2)%ab%irrep(1:numSG))
      allocate(K2(2,1,2,1)%ab%irrep(1:numSG))
      allocate(K2(1,1,2,2)%ab%irrep(1:numSG))
      allocate(K2(1,2,2,1)%ab%irrep(1:numSG))
      allocate(K2(2,1,1,2)%ab%irrep(1:numSG))
      allocate(K2(1,1,1,2)%aa%irrep(1:numSG))
      allocate(K2(2,2,1,2)%aa%irrep(1:numSG))
      allocate(K2(1,1,1,2)%bb%irrep(1:numSG))
      allocate(K2(2,2,1,2)%bb%irrep(1:numSG))
      allocate(K2(1,1,1,2)%ab%irrep(1:numSG))
      allocate(K2(1,1,2,1)%ab%irrep(1:numSG))
      allocate(K2(2,2,1,2)%ab%irrep(1:numSG))
      allocate(K2(2,2,2,1)%ab%irrep(1:numSG))
      allocate(K1(1,1)%aa%irrep(1:numSG))
      allocate(K1(2,2)%aa%irrep(1:numSG))
      allocate(K1(1,2)%aa%irrep(1:numSG))
      allocate(K1(1,1)%bb%irrep(1:numSG))
      allocate(K1(2,2)%bb%irrep(1:numSG))
      allocate(K1(1,2)%bb%irrep(1:numSG))

      allocate(K1TwoInts(1,1)%aa%irrep(1:numSG))
      allocate(K1TwoInts(2,2)%aa%irrep(1:numSG))
      allocate(K1TwoInts(1,2)%aa%irrep(1:numSG))
      allocate(K1TwoInts(1,1)%bb%irrep(1:numSG))
      allocate(K1TwoInts(2,2)%bb%irrep(1:numSG))
      allocate(K1TwoInts(1,2)%bb%irrep(1:numSG))
      do i=1,numSG
        allocate(K2(1,1,1,1)%aa%irrep(i)%block(1:ReshapedMatrixDim%ijaa(i)%col,1:ReshapedMatrixDim%ijaa(i)%col))
        allocate(K2(1,2,1,2)%aa%irrep(i)%block(1:ReshapedMatrixDim%ajaa(i)%col,1:ReshapedMatrixDim%ajaa(i)%col))
        allocate(K2(1,1,2,2)%aa%irrep(i)%block(1:ReshapedMatrixDim%ijaa(i)%row,1:ReshapedMatrixDim%ijaa(i)%col))
        allocate(K2(1,1,1,1)%bb%irrep(i)%block(1:ReshapedMatrixDim%ijbb(i)%col,1:ReshapedMatrixDim%ijbb(i)%col))
        allocate(K2(1,2,1,2)%bb%irrep(i)%block(1:ReshapedMatrixDim%ajbb(i)%col,1:ReshapedMatrixDim%ajbb(i)%col))
        allocate(K2(1,1,2,2)%bb%irrep(i)%block(1:ReshapedMatrixDim%ijbb(i)%row,1:ReshapedMatrixDim%ijbb(i)%col))

      end do
       do i=1,numSG
        allocate(K2(1,1,1,1)%ab%irrep(i)%block(1:ReshapedMatrixDim%ijab(i)%col,1:ReshapedMatrixDim%ijab(i)%col))
        allocate(K2(1,2,1,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%ajab(i)%col,1:ReshapedMatrixDim%ajab(i)%col))
        allocate(K2(2,1,2,1)%ab%irrep(i)%block(1:ReshapedMatrixDim%ajba(i)%col,1:ReshapedMatrixDim%ajba(i)%col))
        allocate(K2(1,1,2,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%ijab(i)%row,1:ReshapedMatrixDim%ijab(i)%col))
        allocate(K2(1,2,2,1)%ab%irrep(i)%block(1:ReshapedMatrixDim%ajbb_only(i)%col,1:ReshapedMatrixDim%ajaa_only(i)%col))
        allocate(K2(2,1,1,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%ajaa_only(i)%col,1:ReshapedMatrixDim%ajbb_only(i)%col))

        numi = (occ_alpha(2,i) - occ_alpha(1,i)) + 1
        numa = (virt_alpha(2,i) - virt_alpha(1,i)) + 1
        allocate(K2(1,1,1,2)%aa%irrep(i)%block(1:ReshapedMatrixDim%jka_aaa(i)%col,1:numi))
        allocate(K2(2,2,1,2)%aa%irrep(i)%block(1:ReshapedMatrixDim%bci_aaa(i)%col,1:numa))
        allocate(K2(1,1,1,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%jka_abb(i)%col,1:numi))
        allocate(K2(2,2,2,1)%ab%irrep(i)%block(1:ReshapedMatrixDim%bci_abb(i)%col,1:numa))
        numi = (occ_beta(2,i) - occ_beta(1,i)) + 1
        numa = (virt_beta(2,i) - virt_beta(1,i)) + 1
        allocate(K2(1,1,1,2)%bb%irrep(i)%block(1:ReshapedMatrixDim%jka_bbb(i)%col,1:numi))
        allocate(K2(2,2,1,2)%bb%irrep(i)%block(1:ReshapedMatrixDim%bci_bbb(i)%col,1:numa))
        allocate(K2(1,1,2,1)%ab%irrep(i)%block(1:ReshapedMatrixDim%jka_aba(i)%col,1:numi))
        allocate(K2(2,2,1,2)%ab%irrep(i)%block(1:ReshapedMatrixDim%bci_aba(i)%col,1:numa))
      end do

     do t=1,numSG
         i_begin = occ_alpha(1,t)
         i_end   = occ_alpha(2,t)
         a_begin = virt_alpha(1,t)
         a_end   = virt_alpha(2,t)
         numa = a_end - a_begin + 1
         numi = i_end - i_begin + 1
         allocate(K1(1,1)%aa%irrep(t)%block(i_begin:i_end,i_begin:i_end))
         allocate(K1(2,2)%aa%irrep(t)%block(a_begin:a_end,a_begin:a_end))
         allocate(K1(1,2)%aa%irrep(t)%block(1:numi*numa,1:1))
         allocate(K1TwoInts(1,1)%aa%irrep(t)%block(i_begin:i_end,i_begin:i_end))
         allocate(K1TwoInts(2,2)%aa%irrep(t)%block(a_begin:a_end,a_begin:a_end))
         allocate(K1TwoInts(1,2)%aa%irrep(t)%block(1:numa*numi,1:1))
         K1(1,1)%aa%irrep(t)%block(i_begin:i_end,i_begin:i_end) = 0.0D0
         K1(2,2)%aa%irrep(t)%block(a_begin:a_end,a_begin:a_end) = 0.0D0
         K1(1,2)%aa%irrep(t)%block(1:numa*numi,1:1) = 0.0D0
         K1TwoInts(1,1)%aa%irrep(t)%block(i_begin:i_end,i_begin:i_end) = 0.0D0
         K1TwoInts(2,2)%aa%irrep(t)%block(a_begin:a_end,a_begin:a_end) = 0.0D0
         K1TwoInts(1,2)%aa%irrep(t)%block(1:numa*numi,1:1) = 0.0D0
      end do


    do t=1,numSG
         i_begin = occ_beta(1,t)
         i_end   = occ_beta(2,t)
         a_begin = virt_beta(1,t)
         a_end   = virt_beta(2,t)
         numa = a_end - a_begin + 1
         numi = i_end - i_begin + 1
         allocate(K1(1,1)%bb%irrep(t)%block(i_begin:i_end,i_begin:i_end))
         allocate(K1(2,2)%bb%irrep(t)%block(a_begin:a_end,a_begin:a_end))
         allocate(K1(1,2)%bb%irrep(t)%block(1:numi*numa,1:1))
         allocate(K1TwoInts(1,1)%bb%irrep(t)%block(i_begin:i_end,i_begin:i_end))
         allocate(K1TwoInts(2,2)%bb%irrep(t)%block(a_begin:a_end,a_begin:a_end))
         allocate(K1TwoInts(1,2)%bb%irrep(t)%block(1:numa*numi,1:1))
         K1(1,1)%bb%irrep(t)%block(i_begin:i_end,i_begin:i_end) = 0.0D0
         K1(2,2)%bb%irrep(t)%block(a_begin:a_end,a_begin:a_end) = 0.0D0
         K1(1,2)%bb%irrep(t)%block(1:numa*numi,1:1) = 0.0D0
         K1TwoInts(1,1)%bb%irrep(t)%block(i_begin:i_end,i_begin:i_end) = 0.0D0
         K1TwoInts(2,2)%bb%irrep(t)%block(a_begin:a_end,a_begin:a_end) = 0.0D0
         K1TwoInts(1,2)%bb%irrep(t)%block(1:numa*numi,1:1) = 0.0D0
      end do


       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) cycle
                 k_begin = occ_alpha(1,r)
                 k_end   = occ_alpha(2,r)
                 l_begin = occ_alpha(1,s)
                 l_end   = occ_alpha(2,s)
                 do k=k_begin,k_end
                   do l=max(k+1,l_begin),l_end
                     i_gamess = OldIndex_alpha(i)
                     j_gamess = OldIndex_alpha(j)
                     k_gamess = OldIndex_alpha(k)
                     l_gamess = OldIndex_alpha(l)
                     index1 = FirstIndex(i_gamess,k_gamess)
                     index2 = FirstIndex(j_gamess,l_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(i_gamess,l_gamess)
                     index2 = FirstIndex(j_gamess,k_gamess)
                     compindex2 = CompositeIndex(index1,index2)
                     K2(1,1,1,1)%aa%irrep(symgp)%block(row,col) = (TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2))
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           i_begin = occ_beta(1,p)
           i_end   = occ_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) cycle
                 k_begin = occ_beta(1,r)
                 k_end   = occ_beta(2,r)
                 l_begin = occ_beta(1,s)
                 l_end   = occ_beta(2,s)
                 do k=k_begin,k_end
                   do l=max(k+1,l_begin),l_end
                     i_gamess = OldIndex_beta(i)
                     j_gamess = OldIndex_beta(j)
                     k_gamess = OldIndex_beta(k)
                     l_gamess = OldIndex_beta(l)
                     index1 = FirstIndex(i_gamess,k_gamess)
                     index2 = FirstIndex(j_gamess,l_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(i_gamess,l_gamess)
                     index2 = FirstIndex(j_gamess,k_gamess)
                     compindex2 = CompositeIndex(index1,index2)
                     K2(1,1,1,1)%bb%irrep(symgp)%block(row,col) = (TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2))
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do







       allocate(BlockDim%aa%symgp(1:numSG))
       do symgp=1,numSG
         allocate(BlockDim%aa%symgp(symgp)%block(1:numrowblocks*numrowblocks))
         do counter1=1,numrowblocks*numrowblocks
           BlockDim%aa%symgp(symgp)%block(counter1)%row = 0
           BlockDim%aa%symgp(symgp)%block(counter1)%col = 0
         end do
       end do





       do symgp=1,numSG
         totalrows = ReshapedMatrixDim%ijaa(symgp)%row
         totalcols = ReshapedMatrixDim%ijaa(symgp)%row
         if(totalrows.eq.0) cycle
         rowsperblock = totalrows/numrowblocks
         colsperblock = totalcols/numrowblocks
         if(rowsperblock.eq.0.or.colsperblock.eq.0) then
           write(*,*) 'There is a block with zero as a row or column dimension in your matrix multiplication breakup.'
           write(*,*) 'Please choose a smaller number of blocks or choose NUMBLOCKS = 1 to not use this option'
           write(*,*) 'Exiting.'
           stop
         end if
         remainder = totalrows - rowsperblock*numrowblocks
         do p=1,numrowblocks
           do q=1,numrowblocks
             if(p.ne.numrowblocks.and.q.ne.numrowblocks) then
               BlockDim%aa%symgp(symgp)%block(q+(p-1)*numrowblocks)%row = rowsperblock
               BlockDim%aa%symgp(symgp)%block(q+(p-1)*numrowblocks)%col = colsperblock
             else if(p.eq.numrowblocks.and.q.ne.numrowblocks) then
               BlockDim%aa%symgp(symgp)%block(q+(p-1)*numrowblocks)%row = rowsperblock
               BlockDim%aa%symgp(symgp)%block(q+(p-1)*numrowblocks)%col = colsperblock + remainder
             else if(p.ne.numrowblocks.and.q.eq.numrowblocks) then
               BlockDim%aa%symgp(symgp)%block(q+(p-1)*numrowblocks)%row = rowsperblock + remainder
               BlockDim%aa%symgp(symgp)%block(q+(p-1)*numrowblocks)%col = colsperblock
             else
               BlockDim%aa%symgp(symgp)%block(q+(p-1)*numrowblocks)%row = rowsperblock + remainder
               BlockDim%aa%symgp(symgp)%block(q+(p-1)*numrowblocks)%col = colsperblock + remainder
             end if
           end do
         end do
       end do





       do symgp=1,numSG
         write(tempchar,'(I1)') symgp
         K2vvvvfile = trim(inputfile) // 'aaSG' // trim(tempchar)
         do z=1,numrowblocks*numrowblocks
           write(tempchar,'(I4)') z
           tempfile = trim(K2vvvvfile) // 'block' // trim(tempchar)
           temprow = BlockDim%aa%symgp(symgp)%block(z)%row
           tempcol = BlockDim%aa%symgp(symgp)%block(z)%col
           recordlength = 8*temprow*tempcol
           open(unit=z,file=tempfile,form='binary',action='write',access='direct',IOSTAT = iostat,recl=recordlength)
         end do
         rowoffset = 1
         coloffset = 1
         do m=1,numrowblocks*numrowblocks
           if(m.gt.1) then
             if(mod(m-1,numrowblocks).eq.0) then
               rowoffset = 1
               coloffset = coloffset + BlockDim%aa%symgp(symgp)%block(m-1)%col
             else
               rowoffset = rowoffset + BlockDim%aa%symgp(symgp)%block(m-1)%row
             end if
           end if
           if(BlockDim%aa%symgp(symgp)%block(m)%row.eq.0.or.BlockDim%aa%symgp(symgp)%block(m)%col.eq.0) cycle
           allocate(K2vvvv(1:BlockDim%aa%symgp(symgp)%block(m)%row,1:BlockDim%aa%symgp(symgp)%block(m)%col))
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           b_begin = virt_alpha(1,q)
           b_end   = virt_alpha(2,q)
           do a=a_begin,a_end
             do b=max(a+1,b_begin),b_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) cycle
                 c_begin = virt_alpha(1,r)
                 c_end   = virt_alpha(2,r)
                 d_begin = virt_alpha(1,s)
                 d_end   = virt_alpha(2,s)
                 do c=c_begin,c_end
                   do d=max(c+1,d_begin),d_end
                     if(row.ge.rowoffset.and.row.le.rowoffset-1+BlockDim%aa%symgp(symgp)%block(m)%row.and.col.ge.coloffset.and.col.le.coloffset-1+BlockDim%aa%symgp(symgp)%block(m)%col) then
                       a_gamess = OldIndex_alpha(a)
                       b_gamess = OldIndex_alpha(b)
                       c_gamess = OldIndex_alpha(c)
                       d_gamess = OldIndex_alpha(d)
                       index1 = FirstIndex(a_gamess,c_gamess)
                       index2 = FirstIndex(b_gamess,d_gamess)
                       compindex1 = CompositeIndex(index1,index2)
                       index1 = FirstIndex(a_gamess,d_gamess)
                       index2 = FirstIndex(b_gamess,c_gamess)
                       compindex2 = CompositeIndex(index1,index2)
                        K2vvvv(row-rowoffset+1,col-coloffset+1) = (TwoIntsCompact(compindex1)- TwoIntsCompact(compindex2))
                     end if
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
         write(m,rec=1) K2vvvv
         close(m)
         deallocate(K2vvvv)
        end do
       end do

       allocate(BlockDim%bb%symgp(1:numSG))
       do symgp=1,numSG
         allocate(BlockDim%bb%symgp(symgp)%block(1:numrowblocks*numrowblocks))
         do counter1=1,numrowblocks*numrowblocks
           BlockDim%bb%symgp(symgp)%block(counter1)%row = 0
           BlockDim%bb%symgp(symgp)%block(counter1)%col = 0
         end do
       end do

       do symgp=1,numSG
         totalrows = ReshapedMatrixDim%ijbb(symgp)%row
         totalcols = ReshapedMatrixDim%ijbb(symgp)%row
         if(totalrows.eq.0) cycle
         rowsperblock = totalrows/numrowblocks
         colsperblock = totalcols/numrowblocks
         if(rowsperblock.eq.0.or.colsperblock.eq.0) then
           write(*,*) 'There is a block with zero as a row or column dimension in your matrix multiplication breakup.'
           write(*,*) 'Please choose a smaller number of blocks or choose NUMBLOCKS = 1 to not use this option'
           write(*,*) 'Exiting.'
           stop
         end if
         remainder = totalrows - rowsperblock*numrowblocks
         do p=1,numrowblocks
           do q=1,numrowblocks
             if(p.ne.numrowblocks.and.q.ne.numrowblocks) then
               BlockDim%bb%symgp(symgp)%block(q+(p-1)*numrowblocks)%row = rowsperblock
               BlockDim%bb%symgp(symgp)%block(q+(p-1)*numrowblocks)%col = colsperblock
             else if(p.eq.numrowblocks.and.q.ne.numrowblocks) then
               BlockDim%bb%symgp(symgp)%block(q+(p-1)*numrowblocks)%row = rowsperblock
               BlockDim%bb%symgp(symgp)%block(q+(p-1)*numrowblocks)%col = colsperblock + remainder
             else if(p.ne.numrowblocks.and.q.eq.numrowblocks) then
               BlockDim%bb%symgp(symgp)%block(q+(p-1)*numrowblocks)%row = rowsperblock + remainder
               BlockDim%bb%symgp(symgp)%block(q+(p-1)*numrowblocks)%col = colsperblock
             else
               BlockDim%bb%symgp(symgp)%block(q+(p-1)*numrowblocks)%row = rowsperblock + remainder
               BlockDim%bb%symgp(symgp)%block(q+(p-1)*numrowblocks)%col = colsperblock + remainder
             end if
           end do
         end do
       end do


       do symgp=1,numSG
         write(tempchar,'(I1)') symgp
         K2vvvvfile = trim(inputfile) // 'bbSG' // trim(tempchar)
         do z=1,numrowblocks*numrowblocks
           write(tempchar,'(I4)') z
           tempfile = trim(K2vvvvfile) // 'block' // trim(tempchar)
           temprow = BlockDim%bb%symgp(symgp)%block(z)%row
           tempcol = BlockDim%bb%symgp(symgp)%block(z)%col
           recordlength = 8*temprow*tempcol
           open(unit=z,file=tempfile,form='binary',action='write',access='direct',IOSTAT = iostat,recl=recordlength)
         end do
         rowoffset = 1
         coloffset = 1
         do m=1,numrowblocks*numrowblocks
           if(m.gt.1) then
             if(mod(m-1,numrowblocks).eq.0) then
               rowoffset = 1
               coloffset = coloffset + BlockDim%bb%symgp(symgp)%block(m-1)%col
             else
               rowoffset = rowoffset + BlockDim%bb%symgp(symgp)%block(m-1)%row
             end if
           end if
           if(BlockDim%bb%symgp(symgp)%block(m)%row.eq.0.or.BlockDim%bb%symgp(symgp)%block(m)%col.eq.0) cycle
           allocate(K2vvvv(1:BlockDim%bb%symgp(symgp)%block(m)%row,1:BlockDim%bb%symgp(symgp)%block(m)%col))
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           b_begin = virt_beta(1,q)
           b_end   = virt_beta(2,q)
           do a=a_begin,a_end
             do b=max(a+1,b_begin),b_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) cycle
                 c_begin = virt_beta(1,r)
                 c_end   = virt_beta(2,r)
                 d_begin = virt_beta(1,s)
                 d_end   = virt_beta(2,s)
                 do c=c_begin,c_end
                   do d=max(c+1,d_begin),d_end
                     if(row.ge.rowoffset.and.row.le.rowoffset-1+BlockDim%bb%symgp(symgp)%block(m)%row.and.col.ge.coloffset.and.col.le.coloffset-1+BlockDim%bb%symgp(symgp)%block(m)%col) then
                       a_gamess = OldIndex_beta(a)
                       b_gamess = OldIndex_beta(b)
                       c_gamess = OldIndex_beta(c)
                       d_gamess = OldIndex_beta(d)
                       index1 = FirstIndex(a_gamess,c_gamess)
                       index2 = FirstIndex(b_gamess,d_gamess)
                       compindex1 = CompositeIndex(index1,index2)
                       index1 = FirstIndex(a_gamess,d_gamess)
                       index2 = FirstIndex(b_gamess,c_gamess)
                       compindex2 = CompositeIndex(index1,index2)
                        K2vvvv(row-rowoffset+1,col-coloffset+1) = (TwoIntsCompact(compindex1)- TwoIntsCompact(compindex2))
                     end if
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
         write(m,rec=1) K2vvvv
         close(m)
         deallocate(K2vvvv)
        end do
       end do






       do symgp = 1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) cycle
                 a_begin = virt_alpha(1,r)
                 a_end   = virt_alpha(2,r)
                 b_begin = virt_alpha(1,s)
                 b_end   = virt_alpha(2,s)
                 do a=a_begin,a_end
                   do b=max(a+1,b_begin),b_end
                     i_gamess = OldIndex_alpha(i)
                     a_gamess = OldIndex_alpha(a)
                     j_gamess = OldIndex_alpha(j)
                     b_gamess = OldIndex_alpha(b)
                     index1 = FirstIndex(i_gamess,a_gamess)
                     index2 = FirstIndex(j_gamess,b_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(i_gamess,b_gamess)
                     index2 = FirstIndex(j_gamess,a_gamess)
                     compindex2 = CompositeIndex(index1,index2)
                      K2(1,1,2,2)%aa%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)- TwoIntsCompact(compindex2)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do



       do symgp = 1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           i_begin = occ_beta(1,p)
           i_end   = occ_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) cycle
                 a_begin = virt_beta(1,r)
                 a_end   = virt_beta(2,r)
                 b_begin = virt_beta(1,s)
                 b_end   = virt_beta(2,s)
                 do a=a_begin,a_end
                   do b=max(a+1,b_begin),b_end
                     i_gamess = OldIndex_beta(i)
                     a_gamess = OldIndex_beta(a)
                     j_gamess = OldIndex_beta(j)
                     b_gamess = OldIndex_beta(b)
                     index1 = FirstIndex(i_gamess,a_gamess)
                     index2 = FirstIndex(j_gamess,b_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(i_gamess,b_gamess)
                     index2 = FirstIndex(j_gamess,a_gamess)
                     compindex2 = CompositeIndex(index1,index2)
                      K2(1,1,2,2)%bb%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)- TwoIntsCompact(compindex2)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do







       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt_alpha(1,r)
                 b_end   = virt_alpha(2,r)
                 i_begin = occ_alpha(1,s)
                 i_end   = occ_alpha(2,s)
                 do i=i_begin,i_end
                   do b=b_begin,b_end
                      i_gamess = OldIndex_alpha(i)
                      j_gamess = OldIndex_alpha(j)
                      a_gamess = OldIndex_alpha(a)
                      b_gamess = OldIndex_alpha(b)
                      index1 = FirstIndex(i_gamess,j_gamess)
                      index2 = FirstIndex(a_gamess,b_gamess)
                      compindex1 = CompositeIndex(index1,index2)
                      index1 = FirstIndex(i_gamess,b_gamess)
                      index2 = FirstIndex(a_gamess,j_gamess)
                      compindex2 = CompositeIndex(index1,index2)
                      K2(1,2,1,2)%aa%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)-TwoIntsCompact(compindex2)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do




       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt_beta(1,r)
                 b_end   = virt_beta(2,r)
                 i_begin = occ_beta(1,s)
                 i_end   = occ_beta(2,s)
                 do i=i_begin,i_end
                   do b=b_begin,b_end
                      i_gamess = OldIndex_beta(i)
                      j_gamess = OldIndex_beta(j)
                      a_gamess = OldIndex_beta(a)
                      b_gamess = OldIndex_beta(b)
                      index1 = FirstIndex(i_gamess,j_gamess)
                      index2 = FirstIndex(a_gamess,b_gamess)
                      compindex1 = CompositeIndex(index1,index2)
                      index1 = FirstIndex(i_gamess,b_gamess)
                      index2 = FirstIndex(a_gamess,j_gamess)
                      compindex2 = CompositeIndex(index1,index2)
                      K2(1,2,1,2)%bb%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)-TwoIntsCompact(compindex2)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do








       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 k_begin = occ_alpha(1,r)
                 k_end   = occ_alpha(2,r)
                 l_begin = occ_beta(1,s)
                 l_end   = occ_beta(2,s)
                 do k=k_begin,k_end
                   do l=l_begin,l_end
                     i_gamess = OldIndex_alpha(i)
                     j_gamess = OldIndex_beta(j)
                     k_gamess = OldIndex_alpha(k)
                     l_gamess = OldIndex_beta(l)
                     index1 = FirstIndex(i_gamess,k_gamess)
                     index2 = FirstIndex(j_gamess,l_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(1,1,1,1)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do



       allocate(BlockDim%ab%symgp(1:numSG))
       do symgp=1,numSG
         allocate(BlockDim%ab%symgp(symgp)%block(1:numrowblocks*numrowblocks))
         do counter1=1,numrowblocks*numrowblocks
           BlockDim%ab%symgp(symgp)%block(counter1)%row = 0
           BlockDim%ab%symgp(symgp)%block(counter1)%col = 0
         end do
       end do

       do symgp=1,numSG
         totalrows = ReshapedMatrixDim%ijab(symgp)%row
         totalcols = ReshapedMatrixDim%ijab(symgp)%row
         if(totalrows.eq.0) cycle
         rowsperblock = totalrows/numrowblocks
         colsperblock = totalcols/numrowblocks
         if(rowsperblock.eq.0.or.colsperblock.eq.0) then
           write(*,*) 'There is a block with zero as a row or column dimension in your matrix multiplication breakup.'
           write(*,*) 'Please choose a smaller number of blocks or choose NUMBLOCKS = 1 to not use this option'
           write(*,*) 'Exiting.'
           stop
         end if
         remainder = totalrows - rowsperblock*numrowblocks
         do p=1,numrowblocks
           do q=1,numrowblocks
             if(p.ne.numrowblocks.and.q.ne.numrowblocks) then
               BlockDim%ab%symgp(symgp)%block(q+(p-1)*numrowblocks)%row = rowsperblock
               BlockDim%ab%symgp(symgp)%block(q+(p-1)*numrowblocks)%col = colsperblock
             else if(p.eq.numrowblocks.and.q.ne.numrowblocks) then
               BlockDim%ab%symgp(symgp)%block(q+(p-1)*numrowblocks)%row = rowsperblock
               BlockDim%ab%symgp(symgp)%block(q+(p-1)*numrowblocks)%col = colsperblock + remainder
             else if(p.ne.numrowblocks.and.q.eq.numrowblocks) then
               BlockDim%ab%symgp(symgp)%block(q+(p-1)*numrowblocks)%row = rowsperblock + remainder
               BlockDim%ab%symgp(symgp)%block(q+(p-1)*numrowblocks)%col = colsperblock
             else
               BlockDim%ab%symgp(symgp)%block(q+(p-1)*numrowblocks)%row = rowsperblock + remainder
               BlockDim%ab%symgp(symgp)%block(q+(p-1)*numrowblocks)%col = colsperblock + remainder
             end if
           end do
         end do
       end do


       do symgp=1,numSG
         write(tempchar,'(I1)') symgp
         K2vvvvfile = trim(inputfile) // 'abSG' // trim(tempchar)
         do z=1,numrowblocks*numrowblocks
           write(tempchar,'(I4)') z
           tempfile = trim(K2vvvvfile) // 'block' // trim(tempchar)
           temprow = BlockDim%ab%symgp(symgp)%block(z)%row
           tempcol = BlockDim%ab%symgp(symgp)%block(z)%col
           recordlength = 8*temprow*tempcol
           open(unit=z,file=tempfile,form='binary',action='write',access='direct',IOSTAT = iostat,recl=recordlength)
         end do
         rowoffset = 1
         coloffset = 1
         do m=1,numrowblocks*numrowblocks
           if(m.gt.1) then
             if(mod(m-1,numrowblocks).eq.0) then
               rowoffset = 1
               coloffset = coloffset + BlockDim%ab%symgp(symgp)%block(m-1)%col
             else
               rowoffset = rowoffset + BlockDim%ab%symgp(symgp)%block(m-1)%row
             end if
           end if
           if(BlockDim%ab%symgp(symgp)%block(m)%row.eq.0.or.BlockDim%ab%symgp(symgp)%block(m)%col.eq.0) cycle
           allocate(K2vvvv(1:BlockDim%ab%symgp(symgp)%block(m)%row,1:BlockDim%ab%symgp(symgp)%block(m)%col))
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           b_begin = virt_beta(1,q)
           b_end   = virt_beta(2,q)
           do a=a_begin,a_end
             do b=b_begin,b_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_alpha(1,r)
                 c_end   = virt_alpha(2,r)
                 d_begin = virt_beta(1,s)
                 d_end   = virt_beta(2,s)
                 do c=c_begin,c_end
                   do d=d_begin,d_end
                   if(row.ge.rowoffset.and.row.le.rowoffset-1+BlockDim%ab%symgp(symgp)%block(m)%row.and.col.ge.coloffset.and.col.le.coloffset-1+BlockDim%ab%symgp(symgp)%block(m)%col) then
                     a_gamess = OldIndex_alpha(a)
                     b_gamess = OldIndex_beta(b)
                     c_gamess = OldIndex_alpha(c)
                     d_gamess = OldIndex_beta(d)
                     index1 = FirstIndex(a_gamess,c_gamess)
                     index2 = FirstIndex(b_gamess,d_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                      K2vvvv(row-rowoffset+1,col-coloffset+1) = TwoIntsCompact(compindex1)
                     end if
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
         write(m,rec=1) K2vvvv
         deallocate(K2vvvv)
        end do
       end do


       do symgp = 1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 a_begin = virt_alpha(1,r)
                 a_end   = virt_alpha(2,r)
                 b_begin = virt_beta(1,s)
                 b_end   = virt_beta(2,s)
                 do a=a_begin,a_end
                   do b=b_begin,b_end
                     i_gamess = OldIndex_alpha(i)
                     j_gamess = OldIndex_beta(j)
                     a_gamess = OldIndex_alpha(a)
                     b_gamess = OldIndex_beta(b)
                     index1 = FirstIndex(i_gamess,a_gamess)
                     index2 = FirstIndex(j_gamess,b_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(1,1,2,2)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt_beta(1,r)
                 b_end   = virt_beta(2,r)
                 i_begin = occ_alpha(1,s)
                 i_end   = occ_alpha(2,s)
                 do i=i_begin,i_end
                   do b=b_begin,b_end
                     i_gamess = OldIndex_alpha(i)
                     j_gamess = OldIndex_alpha(j)
                     a_gamess = OldIndex_beta(a)
                     b_gamess = OldIndex_beta(b)
                     index1 = FirstIndex(i_gamess,j_gamess)
                     index2 = FirstIndex(a_gamess,b_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(1,2,1,2)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do


       do symgp=1,numSG
         col = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do a=a_begin,a_end
             do j=j_begin,j_end
               col = col + 1
               row = 1
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt_alpha(1,r)
                 b_end   = virt_alpha(2,r)
                 i_begin = occ_beta(1,s)
                 i_end   = occ_beta(2,s)
                 do b=b_begin,b_end
                   do i=i_begin,i_end
                     i_gamess = OldIndex_beta(i)
                     j_gamess = OldIndex_beta(j)
                     a_gamess = OldIndex_alpha(a)
                     b_gamess = OldIndex_alpha(b)
                     index1 = FirstIndex(i_gamess,j_gamess)
                     index2 = FirstIndex(a_gamess,b_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(2,1,2,1)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do




       do symgp=1,numSG
         col = 0
           do t=1,numSG
              p = InvPdt(symgp)%upper(t)
              q = InvPdt(symgp)%lower(t)
              a_begin = virt_alpha(1,p)
              a_end   = virt_alpha(2,p)
              j_begin = occ_alpha(1,q)
              j_end   = occ_alpha(2,q)
              do j=j_begin,j_end
                do a=a_begin,a_end
                  col = col + 1
                  row = 1
                  do v=1,numSG
                     r = InvPdt(symgp)%upper(v)
                     s = InvPdt(symgp)%lower(v)
                     b_begin = virt_beta(1,r)
                     b_end   = virt_beta(2,r)
                     i_begin = occ_beta(1,s)
                     i_end   = occ_beta(2,s)
                     do i=i_begin,i_end
                       do b=b_begin,b_end
                         a_gamess = OldIndex_alpha(a)
                         j_gamess = OldIndex_alpha(j)
                         b_gamess = OldIndex_beta(b)
                         i_gamess = OldIndex_beta(i)
                         index1 = FirstIndex(a_gamess,j_gamess)
                         index2 = FirstIndex(i_gamess,b_gamess)
                         compindex1 = CompositeIndex(index1,index2)
                          K2(1,2,2,1)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                         row = row + 1
                       end do
                    end do
                  end do
                end do
              end do
           end do
        end do

       do symgp=1,numSG
         col = 0
           do t=1,numSG
              p = InvPdt(symgp)%upper(t)
              q = InvPdt(symgp)%lower(t)
              a_begin = virt_beta(1,p)
              a_end   = virt_beta(2,p)
              j_begin = occ_beta(1,q)
              j_end   = occ_beta(2,q)
              do j=j_begin,j_end
                do a=a_begin,a_end
                  col = col + 1
                  row = 1
                  do v=1,numSG
                     r = InvPdt(symgp)%upper(v)
                     s = InvPdt(symgp)%lower(v)
                     b_begin = virt_alpha(1,r)
                     b_end   = virt_alpha(2,r)
                     i_begin = occ_alpha(1,s)
                     i_end   = occ_alpha(2,s)
                     do i=i_begin,i_end
                       do b=b_begin,b_end
                         a_gamess = OldIndex_beta(a)
                         j_gamess = OldIndex_beta(j)
                         b_gamess = OldIndex_alpha(b)
                         i_gamess = OldIndex_alpha(i)
                         index1 = FirstIndex(a_gamess,j_gamess)
                         index2 = FirstIndex(i_gamess,b_gamess)
                         compindex1 = CompositeIndex(index1,index2)
                          K2(2,1,1,2)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                         row = row + 1
                       end do
                    end do
                  end do
                end do
              end do
           end do
        end do




       do symgp=1,numSG
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         j_begin = occ_alpha(1,symgp)
         j_end   = occ_alpha(2,symgp)
         do i=i_begin,i_end
           do j=j_begin,j_end
             i_gamess = OldIndex_alpha(i)
             j_gamess = OldIndex_alpha(j)
             K1(1,1)%aa%irrep(symgp)%block(i,j) = OneInts(i_gamess,j_gamess)
             K1(1,1)%aa%irrep(symgp)%block(j,i) = OneInts(j_gamess,i_gamess)
           end do
         end do
       end do


       do symgp=1,numSG
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         j_begin = occ_beta(1,symgp)
         j_end   = occ_beta(2,symgp)
         do i=i_begin,i_end
           do j=j_begin,j_end
             i_gamess = OldIndex_beta(i)
             j_gamess = OldIndex_beta(j)
             K1(1,1)%bb%irrep(symgp)%block(i,j) = OneInts(i_gamess,j_gamess)
             K1(1,1)%bb%irrep(symgp)%block(j,i) = OneInts(j_gamess,i_gamess)
           end do
         end do
       end do




       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) continue
                 k_begin = occ_alpha(1,r)
                 k_end   = occ_alpha(2,r)
                 l_begin = occ_alpha(1,s)
                 l_end   = occ_alpha(2,s)
                 do k=k_begin,k_end
                   do l=max(k+1,l_begin),l_end
                       i_gamess = OldIndex_alpha(i)
                       j_gamess = OldIndex_alpha(j)
                       k_gamess = OldIndex_alpha(k)
                       l_gamess = OldIndex_alpha(l)
                       index1 = FirstIndex(i_gamess,k_gamess)
                       index2 = FirstIndex(j_gamess,l_gamess)
                       compindex1 = CompositeIndex(index1,index2)
                       index1 = FirstIndex(i_gamess,l_gamess)
                       index2 = FirstIndex(j_gamess,k_gamess)
                       compindex2 = CompositeIndex(index1,index2)
                     if(j==l.and.ProductTable(p,r)==1) then
                        K1TwoInts(1,1)%aa%irrep(p)%block(i,k) = (TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%aa%irrep(p)%block(i,k)
                     end if
                     if(i==l.and.ProductTable(q,r)==1) then
                        K1TwoInts(1,1)%aa%irrep(q)%block(j,k) = -1*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%aa%irrep(q)%block(j,k)
                     end if
                     if(j==k.and.ProductTable(p,s)==1) then
                       K1TwoInts(1,1)%aa%irrep(p)%block(i,l) = -1*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%aa%irrep(p)%block(i,l)
                     end if
                     if(i==k.and.ProductTable(q,s)==1) then
                      K1TwoInts(1,1)%aa%irrep(q)%block(j,l) = (TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%aa%irrep(q)%block(j,l)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           if(p>q) cycle
           i_begin = occ_beta(1,p)
           i_end   = occ_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 if(r>s) continue
                 k_begin = occ_beta(1,r)
                 k_end   = occ_beta(2,r)
                 l_begin = occ_beta(1,s)
                 l_end   = occ_beta(2,s)
                 do k=k_begin,k_end
                   do l=max(k+1,l_begin),l_end
                       i_gamess = OldIndex_beta(i)
                       j_gamess = OldIndex_beta(j)
                       k_gamess = OldIndex_beta(k)
                       l_gamess = OldIndex_beta(l)
                       index1 = FirstIndex(i_gamess,k_gamess)
                       index2 = FirstIndex(j_gamess,l_gamess)
                       compindex1 = CompositeIndex(index1,index2)
                       index1 = FirstIndex(i_gamess,l_gamess)
                       index2 = FirstIndex(j_gamess,k_gamess)
                       compindex2 = CompositeIndex(index1,index2)
                     if(j==l.and.ProductTable(p,r)==1) then
                        K1TwoInts(1,1)%bb%irrep(p)%block(i,k) = (TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%bb%irrep(p)%block(i,k)
                     end if
                     if(i==l.and.ProductTable(q,r)==1) then
                        K1TwoInts(1,1)%bb%irrep(q)%block(j,k) = -1*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%bb%irrep(q)%block(j,k)
                     end if
                     if(j==k.and.ProductTable(p,s)==1) then
                       K1TwoInts(1,1)%bb%irrep(p)%block(i,l) = -1*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%bb%irrep(p)%block(i,l)
                     end if
                     if(i==k.and.ProductTable(q,s)==1) then
                      K1TwoInts(1,1)%bb%irrep(q)%block(j,l) = (TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,1)%bb%irrep(q)%block(j,l)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do










       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 k_begin = occ_alpha(1,r)
                 k_end   = occ_alpha(2,r)
                 l_begin = occ_beta(1,s)
                 l_end   = occ_beta(2,s)
                 do k=k_begin,k_end
                   do l=l_begin,l_end
                     i_gamess = OldIndex_alpha(i)
                     j_gamess = OldIndex_beta(j)
                     k_gamess = OldIndex_alpha(k)
                     l_gamess = OldIndex_beta(l)
                     index1 = FirstIndex(i_gamess,k_gamess)
                     index2 = FirstIndex(j_gamess,l_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     if(j==l.and.ProductTable(p,r)==1) then
                        K1TwoInts(1,1)%aa%irrep(p)%block(i,k) = TwoIntsCompact(compindex1) + K1TwoInts(1,1)%aa%irrep(p)%block(i,k)
                     end if
                     if(i==k.and.ProductTable(q,s)==1) then
                       K1TwoInts(1,1)%bb%irrep(q)%block(j,l) = TwoIntsCompact(compindex1) + K1TwoInts(1,1)%bb%irrep(q)%block(j,l)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do



       do symgp=1,numSG
         a_begin = virt_alpha(1,symgp)
         a_end   = virt_alpha(2,symgp)
         b_begin = virt_alpha(1,symgp)
         b_end   = virt_alpha(2,symgp)
         do a=a_begin,a_end
           do b=b_begin,b_end
             a_gamess = OldIndex_alpha(a)
             b_gamess = OldIndex_alpha(b)
             K1(2,2)%aa%irrep(symgp)%block(a,b) = OneInts(a_gamess,b_gamess)
             K1(2,2)%aa%irrep(symgp)%block(b,a) = OneInts(b_gamess,a_gamess)
           end do
         end do
       end do

       do symgp=1,numSG
         a_begin = virt_beta(1,symgp)
         a_end   = virt_beta(2,symgp)
         b_begin = virt_beta(1,symgp)
         b_end   = virt_beta(2,symgp)
         do a=a_begin,a_end
           do b=b_begin,b_end
             a_gamess = OldIndex_beta(a)
             b_gamess = OldIndex_beta(b)
             K1(2,2)%bb%irrep(symgp)%block(a,b) = OneInts(a_gamess,b_gamess)
             K1(2,2)%bb%irrep(symgp)%block(b,a) = OneInts(b_gamess,a_gamess)
           end do
         end do
       end do



      do symgp=1,numSG
        a_begin = virt_alpha(1,symgp)
        a_end   = virt_alpha(2,symgp)
        i_begin = occ_alpha(1,symgp)
        i_end   = occ_alpha(2,symgp)
        row = 1
        col = 1
        do i=i_begin,i_end
          do a=a_begin,a_end
            i_gamess = OldIndex_alpha(i)
            a_gamess = OldIndex_alpha(a)
            K1(1,2)%aa%irrep(symgp)%block(row,col) = OneInts(i_gamess,a_gamess)
            row = row + 1
          end do
        end do
      end do


      do symgp=1,numSG
        a_begin = virt_beta(1,symgp)
        a_end   = virt_beta(2,symgp)
        i_begin = occ_beta(1,symgp)
        i_end   = occ_beta(2,symgp)
        row = 1
        col = 1
        do i=i_begin,i_end
          do a=a_begin,a_end
            i_gamess = OldIndex_beta(i)
            a_gamess = OldIndex_beta(a)
            K1(1,2)%bb%irrep(symgp)%block(row,col) = OneInts(i_gamess,a_gamess)
            row = row + 1
          end do
        end do
      end do




       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do a=a_begin,a_end
             do j=j_begin,j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt_alpha(1,r)
                 b_end   = virt_alpha(2,r)
                 i_begin = occ_alpha(1,s)
                 i_end   = occ_alpha(2,s)
                 do b=b_begin,b_end
                   do i=i_begin,i_end
                     if(i==j.and.ProductTable(p,r)==1) then
                       i_gamess = OldIndex_alpha(i)
                       j_gamess = OldIndex_alpha(j)
                       a_gamess = OldIndex_alpha(a)
                       b_gamess = OldIndex_alpha(b)
                       index1 = FirstIndex(i_gamess,j_gamess)
                       index2 = FirstIndex(a_gamess,b_gamess)
                       compindex1 = CompositeIndex(index1,index2)
                       index1 = FirstIndex(i_gamess,b_gamess)
                       index2 = FirstIndex(a_gamess,j_gamess)
                       compindex2 = CompositeIndex(index1,index2)
                        K1TwoInts(2,2)%aa%irrep(p)%block(a,b) = (TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(2,2)%aa%irrep(p)%block(a,b)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do a=a_begin,a_end
             do j=j_begin,j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt_beta(1,r)
                 b_end   = virt_beta(2,r)
                 i_begin = occ_beta(1,s)
                 i_end   = occ_beta(2,s)
                 do b=b_begin,b_end
                   do i=i_begin,i_end
                     if(i==j.and.ProductTable(p,r)==1) then
                       i_gamess = OldIndex_beta(i)
                       j_gamess = OldIndex_beta(j)
                       a_gamess = OldIndex_beta(a)
                       b_gamess = OldIndex_beta(b)
                       index1 = FirstIndex(i_gamess,j_gamess)
                       index2 = FirstIndex(a_gamess,b_gamess)
                       compindex1 = CompositeIndex(index1,index2)
                       index1 = FirstIndex(i_gamess,b_gamess)
                       index2 = FirstIndex(a_gamess,j_gamess)
                       compindex2 = CompositeIndex(index1,index2)
                        K1TwoInts(2,2)%bb%irrep(p)%block(a,b) = (TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(2,2)%bb%irrep(p)%block(a,b)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do a=a_begin,a_end
             do j=j_begin,j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt_beta(1,r)
                 b_end   = virt_beta(2,r)
                 i_begin = occ_alpha(1,s)
                 i_end   = occ_alpha(2,s)
                 do b=b_begin,b_end
                   do i=i_begin,i_end
                     if(i==j.and.ProductTable(p,r)==1) then
                       i_gamess = OldIndex_alpha(i)
                       j_gamess = OldIndex_alpha(j)
                       a_gamess = OldIndex_beta(a)
                       b_gamess = OldIndex_beta(b)
                       index1 = FirstIndex(i_gamess,j_gamess)
                       index2 = FirstIndex(a_gamess,b_gamess)
                       compindex1 = CompositeIndex(index1,index2)
                       K1TwoInts(2,2)%bb%irrep(p)%block(a,b) = TwoIntsCompact(compindex1) + K1TwoInts(2,2)%bb%irrep(p)%block(a,b)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do



       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do a=a_begin,a_end
             do j=j_begin,j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt_alpha(1,r)
                 b_end   = virt_alpha(2,r)
                 i_begin = occ_beta(1,s)
                 i_end   = occ_beta(2,s)
                 do b=b_begin,b_end
                   do i=i_begin,i_end
                     if(i==j.and.ProductTable(p,r)==1) then
                       i_gamess = OldIndex_beta(i)
                       j_gamess = OldIndex_beta(j)
                       a_gamess = OldIndex_alpha(a)
                       b_gamess = OldIndex_alpha(b)
                       index1 = FirstIndex(i_gamess,j_gamess)
                       index2 = FirstIndex(a_gamess,b_gamess)
                       compindex1 = CompositeIndex(index1,index2)
                       K1TwoInts(2,2)%aa%irrep(p)%block(a,b) = TwoIntsCompact(compindex1) + K1TwoInts(2,2)%aa%irrep(p)%block(a,b)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do











       do symgp=1,numSG
          col = 1
          row = 0
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_alpha(1,q)
           k_end   = occ_alpha(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_alpha(1,r)
             a_end   = virt_alpha(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                    row = row + 1
                    col = 1
                   do i=i_begin,i_end
                     i_gamess = OldIndex_alpha(i)
                     j_gamess = OldIndex_alpha(j)
                     k_gamess = OldIndex_alpha(k)
                     a_gamess = OldIndex_alpha(a)
                     index1 = FirstIndex(j_gamess,i_gamess)
                     index2 = FirstIndex(k_gamess,a_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(j_gamess,a_gamess)
                     index2 = FirstIndex(k_gamess,i_gamess)
                     compindex2 = CompositeIndex(index1,index2)
                     K2(1,1,1,2)%aa%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
          col = 1
          row = 0
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_beta(1,r)
             a_end   = virt_beta(2,r)
             j_begin = occ_beta(1,s)
             j_end   = occ_beta(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                    row = row + 1
                    col = 1
                   do i=i_begin,i_end
                     i_gamess = OldIndex_beta(i)
                     j_gamess = OldIndex_beta(j)
                     k_gamess = OldIndex_beta(k)
                     a_gamess = OldIndex_beta(a)
                     index1 = FirstIndex(j_gamess,i_gamess)
                     index2 = FirstIndex(k_gamess,a_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(j_gamess,a_gamess)
                     index2 = FirstIndex(k_gamess,i_gamess)
                     compindex2 = CompositeIndex(index1,index2)
                     K2(1,1,1,2)%bb%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do




       do symgp=1,numSG
          col = 1
          row = 0
         a_begin = virt_alpha(1,symgp)
         a_end   = virt_alpha(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_alpha(1,q)
           c_end   = virt_alpha(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_alpha(1,r)
             b_end   = virt_alpha(2,r)
             i_begin = occ_alpha(1,s)
             i_end   = occ_alpha(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=max(c_begin,b+1),c_end
                    row = row + 1
                    col = 1
                   do a=a_begin,a_end
                     b_gamess = OldIndex_alpha(b)
                     i_gamess = OldIndex_alpha(i)
                     c_gamess = OldIndex_alpha(c)
                     a_gamess = OldIndex_alpha(a)
                     index1 = FirstIndex(b_gamess,i_gamess)
                     index2 = FirstIndex(c_gamess,a_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(b_gamess,a_gamess)
                     index2 = FirstIndex(c_gamess,i_gamess)
                     compindex2 = CompositeIndex(index1,index2)
                     K2(2,2,1,2)%aa%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)
                    col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
          col = 1
          row = 0
         a_begin = virt_beta(1,symgp)
         a_end   = virt_beta(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_beta(1,q)
           c_end   = virt_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_beta(1,r)
             b_end   = virt_beta(2,r)
             i_begin = occ_beta(1,s)
             i_end   = occ_beta(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=max(c_begin,b+1),c_end
                    row = row + 1
                    col = 1
                   do a=a_begin,a_end
                     b_gamess = OldIndex_beta(b)
                     i_gamess = OldIndex_beta(i)
                     c_gamess = OldIndex_beta(c)
                     a_gamess = OldIndex_beta(a)
                     index1 = FirstIndex(b_gamess,i_gamess)
                     index2 = FirstIndex(c_gamess,a_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(b_gamess,a_gamess)
                     index2 = FirstIndex(c_gamess,i_gamess)
                     compindex2 = CompositeIndex(index1,index2)
                     K2(2,2,1,2)%bb%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)
                    col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do




       do symgp=1,numSG
          row = 0
          col = 1
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_beta(1,r)
             a_end   = virt_beta(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do k=k_begin,k_end
                 do a=a_begin,a_end
                   col = 1
                   row = row + 1
                   do i=i_begin,i_end
                     i_gamess = OldIndex_alpha(i)
                     j_gamess = OldIndex_alpha(j)
                     a_gamess = OldIndex_beta(a)
                     k_gamess = OldIndex_beta(k)
                     index1 = FirstIndex(j_gamess,i_gamess)
                     index2 = FirstIndex(k_gamess,a_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(1,1,1,2)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
          row = 0
          col = 1
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_alpha(1,r)
             a_end   = virt_alpha(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=k_begin,k_end
                    row = row + 1
                    col = 1
                   do i=i_begin,i_end
                     a_gamess = OldIndex_alpha(a)
                     j_gamess = OldIndex_alpha(j)
                     k_gamess = OldIndex_beta(k)
                     i_gamess = OldIndex_beta(i)
                     index1 = FirstIndex(j_gamess,a_gamess)
                     index2 = FirstIndex(k_gamess,i_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                      K2(1,1,2,1)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                     col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
          row = 0
          col = 1
         a_begin = virt_beta(1,symgp)
         a_end   = virt_beta(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_beta(1,q)
           c_end   = virt_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_alpha(1,r)
             b_end   = virt_alpha(2,r)
             i_begin = occ_alpha(1,s)
             i_end   = occ_alpha(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=c_begin,c_end
                    col = 1
                    row = row + 1
                   do a=a_begin,a_end
                     b_gamess = OldIndex_alpha(b)
                     i_gamess = OldIndex_alpha(i)
                     c_gamess = OldIndex_beta(c)
                     a_gamess = OldIndex_beta(a)
                     index1 = FirstIndex(b_gamess,i_gamess)
                     index2 = FirstIndex(c_gamess,a_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     K2(2,2,1,2)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
          row = 0
          col = 1
         a_begin = virt_alpha(1,symgp)
         a_end   = virt_alpha(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_beta(1,q)
           c_end   = virt_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_alpha(1,r)
             b_end   = virt_alpha(2,r)
             i_begin = occ_beta(1,s)
             i_end   = occ_beta(2,s)
             do b=b_begin,b_end
               do i=i_begin,i_end
                 do c=c_begin,c_end
                    col = 1
                    row = row + 1
                   do a=a_begin,a_end
                     b_gamess = OldIndex_alpha(b)
                     a_gamess = OldIndex_alpha(a)
                     i_gamess = OldIndex_beta(i)
                     c_gamess = OldIndex_beta(c)
                     index1 = FirstIndex(b_gamess,a_gamess)
                     index2 = FirstIndex(c_gamess,i_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     K2(2,2,2,1)%ab%irrep(symgp)%block(row,col) = TwoIntsCompact(compindex1)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
allocate(InverseBasisK1_alpha(1:numSG))
do symgp=1,numSG
  counter = 1
  i_begin = occ_alpha(1,symgp)
  i_end   = occ_alpha(2,symgp)
  a_begin = virt_alpha(1,symgp)
  a_end   = virt_alpha(2,symgp)
  allocate(InverseBasisK1_alpha(symgp)%basis(i_begin:i_end,a_begin:a_end))
  do i=i_begin,i_end
    do a=a_begin,a_end
      InverseBasisK1_alpha(symgp)%basis(i,a) = counter
      counter = counter + 1
    end do
  end do
end do


allocate(InverseBasisK1_beta(1:numSG))
do symgp=1,numSG
  counter = 1
  i_begin = occ_beta(1,symgp)
  i_end   = occ_beta(2,symgp)
  a_begin = virt_beta(1,symgp)
  a_end   = virt_beta(2,symgp)
  allocate(InverseBasisK1_beta(symgp)%basis(i_begin:i_end,a_begin:a_end))
  do i=i_begin,i_end
    do a=a_begin,a_end
      InverseBasisK1_beta(symgp)%basis(i,a) = counter
      counter = counter + 1
    end do
  end do
end do



       do symgp=1,numSG
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         numi = i_end - i_begin + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_alpha(1,q)
           k_end   = occ_alpha(2,q)
           numk = k_end - k_begin + 1
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_alpha(1,r)
             a_end   = virt_alpha(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                   do i=i_begin,i_end
                     i_gamess = OldIndex_alpha(i)
                     j_gamess = OldIndex_alpha(j)
                     a_gamess = OldIndex_alpha(a)
                     k_gamess = OldIndex_alpha(k)
                     index1 = FirstIndex(i_gamess,j_gamess)
                     index2 = FirstIndex(a_gamess,k_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(i_gamess,k_gamess)
                     index2 = FirstIndex(a_gamess,j_gamess)
                     compindex2 = CompositeIndex(index1,index2)
                     if(i.eq.j.and.ProductTable(r,q).eq.1) then
                        K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1_alpha(r)%basis(k,a),1) = 2*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1_alpha(r)%basis(k,a),1)
                     end if
                     if(i.eq.k.and.ProductTable(s,r).eq.1) then
                       K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1_alpha(r)%basis(j,a),1) =-2*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1_alpha(r)%basis(j,a),1)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do


       do symgp=1,numSG
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         numi = i_end - i_begin + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           numk = k_end - k_begin + 1
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_beta(1,r)
             a_end   = virt_beta(2,r)
             j_begin = occ_beta(1,s)
             j_end   = occ_beta(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                   do i=i_begin,i_end
                     i_gamess = OldIndex_beta(i)
                     j_gamess = OldIndex_beta(j)
                     a_gamess = OldIndex_beta(a)
                     k_gamess = OldIndex_beta(k)
                     index1 = FirstIndex(i_gamess,j_gamess)
                     index2 = FirstIndex(a_gamess,k_gamess)
                     compindex1 = CompositeIndex(index1,index2)
                     index1 = FirstIndex(i_gamess,k_gamess)
                     index2 = FirstIndex(a_gamess,j_gamess)
                     compindex2 = CompositeIndex(index1,index2)
                     if(i.eq.j.and.ProductTable(r,q).eq.1) then
                        K1TwoInts(1,2)%bb%irrep(r)%block(InverseBasisK1_beta(r)%basis(k,a),1) = 2*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,2)%bb%irrep(r)%block(InverseBasisK1_beta(r)%basis(k,a),1)
                     end if
                     if(i.eq.k.and.ProductTable(s,r).eq.1) then
                       K1TwoInts(1,2)%bb%irrep(r)%block(InverseBasisK1_beta(r)%basis(j,a),1) =-2*(TwoIntsCompact(compindex1) - TwoIntsCompact(compindex2)) + K1TwoInts(1,2)%bb%irrep(r)%block(InverseBasisK1_beta(r)%basis(j,a),1)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do






       do symgp=1,numSG
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_Beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_beta(1,r)
             a_end   = virt_beta(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do k=k_begin,k_end
                 do a=a_begin,a_end
                   do i=i_begin,i_end
                     if(i.eq.j.and.ProductTable(q,r).eq.1) then
                       j_gamess = OldIndex_alpha(j)
                       i_gamess = OldIndex_alpha(i)
                       k_gamess = OldIndex_beta(k)
                       a_gamess = OldIndex_beta(a)
                       index1 = FirstIndex(j_gamess,i_gamess)
                       index2 = FirstIndex(k_gamess,a_gamess)
                       compindex1 = CompositeIndex(index1,index2)
                        K1TwoInts(1,2)%bb%irrep(r)%block(InverseBasisK1_beta(r)%basis(k,a),1) =2*TwoIntsCompact(compindex1) + K1TwoInts(1,2)%bb%irrep(r)%block(InverseBasisK1_beta(r)%basis(k,a),1)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_alpha(1,r)
             a_end   = virt_alpha(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=k_begin,k_end
                   do i=i_begin,i_end
                     if(i.eq.k.and.ProductTable(r,s).eq.1) then
                       j_gamess = OldIndex_alpha(j)
                       a_gamess = OldIndex_alpha(a)
                       i_gamess = OldIndex_beta(i)
                       k_gamess = OldIndex_beta(k)
                       index1 = FirstIndex(j_gamess,a_gamess)
                       index2 = FirstIndex(k_gamess,i_gamess)
                       compindex1 = CompositeIndex(index1,index2)
                       K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1_alpha(r)%basis(j,a),1) = 2*TwoIntsCompact(compindex1) + K1TwoInts(1,2)%aa%irrep(r)%block(InverseBasisK1_alpha(r)%basis(j,a),1)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do


      numocc_alpha = 0
      numvirt_alpha = 0
      numocc_beta = 0
      numvirt_beta = 0
      do i=1,numSG
        numocc_alpha = occ_alpha(2,i) - occ_alpha(1,i) + 1 + numocc_alpha
        numvirt_alpha = virt_alpha(2,i) - virt_alpha(1,i) + 1 + numvirt_alpha
        numocc_beta = occ_beta(2,i) - occ_beta(1,i) + 1 + numocc_beta
        numvirt_beta = virt_beta(2,i) - virt_beta(1,i) + 1 + numvirt_beta
      end do
      numocc = max(numocc_alpha,numocc_beta)
      numvirt = max(numvirt_alpha,numvirt_beta)
      begin_virt = min(numocc_alpha,numocc_beta)
      begin_virt = begin_virt + 1
      numtotal = numocc_alpha + numvirt_alpha
         if(begin_virt.eq.0) then
           write(*,*) 'You do not have any virtual orbitals...Exiting...'
           stop
         end if

         allocate(TwoInts(1:numocc,1:numocc,begin_virt:numtotal,begin_virt:numtotal))
         TwoInts(1:numocc,1:numocc,begin_virt:numtotal,begin_virt:numtotal) = 0.0
         do i=1,numocc
           do j=1,numocc
             do a=begin_virt,numtotal
               do b=begin_virt,numtotal
                 index1 = FirstIndex(i,a)
                 index2 = FirstIndex(j,b)
                 compindex1 = CompositeIndex(index1,index2)
                 integral = TwoIntsCompact(compindex1)
                 TwoInts(i,j,a,b) = integral
                 TwoInts(j,i,b,a) = integral
               end do
             end do
           end do
        end do
        deallocate(TwoIntsCompact)



Call cpu_time(time_end)
   time_buildk2k1 = time_buildk2k1 + time_end - time_begin

       end subroutine BuildK2K1BlockK2OS

       subroutine reshape_ijaa_testOS(SG,ProductTable,Reshapes,occ_alpha,virt_alpha,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE InterfaceMod
       USE TypeMod
       USE TimeMod, only : time_ijaa
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,virt_alpha
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), dimension(:) :: InvPdt(1:SG)

       integer :: symgp,p,q,r,s
       integer, dimension(1:SG) :: total_SG_row, total_SG_col
       integer, target :: a,b,i,j
       integer, target :: row,col,i_begin,i_end,j_begin,j_end,a_begin,a_end,b_begin,b_end
       integer :: numa,numb,numi,numj
       integer, pointer :: jptr, bptr
       integer :: t,v
       integer, target :: temp
       integer :: time_initial(8),time_final(8)
       real :: time_begin, time_end

      Call CPU_TIME(time_begin)
       do p=1,SG
          allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ijaa(p)%row,1:ReshapedMatrixDim%ijaa(p)%col))
          allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ijaa(p)%row,1:ReshapedMatrixDim%ijaa(p)%col))
       end do

      do symgp=1,SG
         col = 0
         do t=1,SG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             if(p.GT.q) then
               cycle
             end if
             i_begin = occ_alpha(1,p)
             i_end   = occ_alpha(2,p)
             j_begin = occ_alpha(1,q)
             j_end   = occ_alpha(2,q)
             do i=i_begin,i_end
               do j=max(i+1,j_begin),j_end
                 col = col + 1
                 row = 1
                 do v=1,SG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   if(r.GT.s) then
                     cycle
                   end if
                   a_begin = virt_alpha(1,r)
                   a_end   = virt_alpha(2,r)
                   b_begin = virt_alpha(1,s)
                   b_end   = virt_alpha(2,s)
                   do a=a_begin,a_end
                     do b=max(a+1,b_begin),b_end
                       Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%aa%m(a,i)%nsym(s,q)%n(b,j)
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do

        Call CPU_TIME(time_end)
        time_ijaa = time_end - time_begin  + time_ijaa

      end subroutine reshape_ijaa_testOS

       subroutine reshape_ijaa_inverseOS(SG,ProductTable,DerivReshapes,occ_alpha,virt_alpha,T2deriv,ReshapedMatrixDim,InvPdt)
       Use InterfaceMod
       USE TypeMod;
       Use TimeMod, only :time_ijaa_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,virt_alpha
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s
       integer, dimension(1:SG) :: total_SG_row, total_SG_col
       integer, target :: a,b,i,j
       integer, target :: row,col,i_begin,i_end,j_begin,j_end,a_begin,a_end,b_begin,b_end
       integer :: numa,numb,numi,numj
       integer, pointer :: jptr, bptr
       integer :: t,v
       integer, target :: temp
       integer :: time_initial(8),time_final(8)
       real :: time_begin,time_end
     Call CPU_TIME(time_begin)
      do symgp=1,SG
         col = 0
         do t=1,SG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             if(p.GT.q) then
               cycle
             end if
             i_begin = occ_alpha(1,p)
             i_end   = occ_alpha(2,p)
             j_begin = occ_alpha(1,q)
             j_end   = occ_alpha(2,q)
             do i=i_begin,i_end
               do j=max(i+1,j_begin),j_end
                 col = col + 1
                 row = 1
                 do v=1,SG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   if(r.GT.s) then
                     cycle
                   end if
                   a_begin = virt_alpha(1,r)
                   a_end   = virt_alpha(2,r)
                   b_begin = virt_alpha(1,s)
                   b_end   = virt_alpha(2,s)
                   do a=a_begin,a_end
                     do b=max(a+1,b_begin),b_end
                       T2deriv%aa%m(a,i)%nsym(s,q)%n(b,j) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%aa%m(a,i)%nsym(s,q)%n(b,j)
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do

        Call CPU_TIME(time_end)
        time_ijaa_inverse = time_end - time_begin + time_ijaa_inverse

      end subroutine reshape_ijaa_inverseOS

       subroutine reshape_ajaaOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_ajaa
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: a,j,c,k
       integer :: row,col,c_begin,c_end,k_begin,k_end,t,v
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
         allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajaa(p)%row,1:ReshapedMatrixDim%ajaa(p)%col))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajaa(p)%row,1:ReshapedMatrixDim%ajaa(p)%col))
       end do

      do p=1,SG
        maxrow_SG(p) = 0
      end do


     row = 1
       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               col = col + 1
               row = 1
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_alpha(1,r)
                 c_end   = virt_alpha(2,r)
                 k_begin = occ_alpha(1,s)
                 k_end   = occ_alpha(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                    Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%aa%m(a,j)%nsym(r,s)%n(c,k)
                    row = row + 1
                    maxrow_SG(symgp) = row
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 col = col + 1
                 row = maxrow_SG(symgp)
                 do v=1,SG
                   r = InvPdt(symgp)%upper(v)
                   s = InvPdt(symgp)%lower(v)
                   c_begin = virt_beta(1,r)
                   c_end   = virt_beta(2,r)
                   k_begin = occ_beta(1,s)
                   k_end   = occ_beta(2,s)
                   do k=k_begin,k_end
                     do c=c_begin,c_end
                       Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%ab%m(a,j)%nsym(r,s)%n(c,k)
                       row = row + 1
                      end do
                    end do
                  end do
                end do
              end do
            end do
          end do

          Call CPU_TIME(time_end)
          time_ajaa = time_end - time_begin + time_ajaa



      end subroutine reshape_ajaaOS


       subroutine reshape_ajaa_inverseOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_ajaa
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: a,j,c,k
       integer :: row,col,c_begin,c_end,k_begin,k_end,t,v
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
         maxrow_SG(p) = 0
       end do

     row = 1
       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               col = col + 1
               row = 1
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_alpha(1,r)
                 c_end   = virt_alpha(2,r)
                 k_begin = occ_alpha(1,s)
                 k_end   = occ_alpha(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                    T2deriv%aa%m(a,j)%nsym(r,s)%n(c,k) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%aa%m(a,j)%nsym(r,s)%n(c,k)
                    row = row + 1
                    maxrow_SG(symgp) = row
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 col = col + 1
                 row = maxrow_SG(symgp)
                 do v=1,SG
                   r = InvPdt(symgp)%upper(v)
                   s = InvPdt(symgp)%lower(v)
                   c_begin = virt_beta(1,r)
                   c_end   = virt_beta(2,r)
                   k_begin = occ_beta(1,s)
                   k_end   = occ_beta(2,s)
                   do k=k_begin,k_end
                     do c=c_begin,c_end
                       T2deriv%ab%m(a,j)%nsym(r,s)%n(c,k) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(a,j)%nsym(r,s)%n(c,k)
                       row = row + 1
                      end do
                    end do
                  end do
                end do
              end do
            end do
          end do
          Call CPU_TIME(time_end)
          time_ajaa = time_end - time_begin + time_ajaa



      end subroutine reshape_ajaa_inverseOS


       subroutine reshape_ijbb_testOS(SG,ProductTable,Reshapes,occ_beta,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE InterfaceMod
       USE TypeMod
       USE TimeMod, only : time_ijaa
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_beta,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), dimension(:) :: InvPdt(1:SG)

       integer :: symgp,p,q,r,s
       integer, dimension(1:SG) :: total_SG_row, total_SG_col
       integer, target :: a,b,i,j
       integer, target :: row,col,i_begin,i_end,j_begin,j_end,a_begin,a_end,b_begin,b_end
       integer :: numa,numb,numi,numj
       integer, pointer :: jptr, bptr
       integer :: t,v
       integer :: time_initial(8),time_final(8)
       real :: time_begin, time_end

      Call CPU_TIME(time_begin)
       do p=1,SG
          allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ijbb(p)%row,1:ReshapedMatrixDim%ijbb(p)%col))
          allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ijbb(p)%row,1:ReshapedMatrixDim%ijbb(p)%col))
       end do

      do symgp=1,SG
         col = 0
         do t=1,SG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             if(p.GT.q) then
               cycle
             end if
             i_begin = occ_beta(1,p)
             i_end   = occ_beta(2,p)
             j_begin = occ_beta(1,q)
             j_end   = occ_beta(2,q)
             do i=i_begin,i_end
               do j=max(i+1,j_begin),j_end
                 col = col + 1
                 row = 1
                 do v=1,SG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   if(r.GT.s) then
                     cycle
                   end if
                   a_begin = virt_beta(1,r)
                   a_end   = virt_beta(2,r)
                   b_begin = virt_beta(1,s)
                   b_end   = virt_beta(2,s)
                   do a=a_begin,a_end
                     do b=max(a+1,b_begin),b_end
                       Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%bb%m(a,i)%nsym(s,q)%n(b,j)
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do

        Call CPU_TIME(time_end)
        time_ijaa = time_end - time_begin  + time_ijaa

      end subroutine reshape_ijbb_testOS

       subroutine reshape_ijbb_inverseOS(SG,ProductTable,DerivReshapes,occ_beta,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
       Use InterfaceMod
       USE TypeMod;
       Use TimeMod, only :time_ijaa_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_beta,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s
       integer, dimension(1:SG) :: total_SG_row, total_SG_col
       integer, target :: a,b,i,j
       integer, target :: row,col,i_begin,i_end,j_begin,j_end,a_begin,a_end,b_begin,b_end
       integer :: numa,numb,numi,numj
       integer, pointer :: jptr, bptr
       integer :: t,v
       integer, target :: temp
       integer :: time_initial(8),time_final(8)
       real :: time_begin,time_end
     Call CPU_TIME(time_begin)
      do symgp=1,SG
         col = 0
         do t=1,SG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             if(p.GT.q) then
               cycle
             end if
             i_begin = occ_beta(1,p)
             i_end   = occ_beta(2,p)
             j_begin = occ_beta(1,q)
             j_end   = occ_beta(2,q)
             do i=i_begin,i_end
               do j=max(i+1,j_begin),j_end
                 col = col + 1
                 row = 1
                 do v=1,SG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   if(r.GT.s) then
                     cycle
                   end if
                   a_begin = virt_beta(1,r)
                   a_end   = virt_beta(2,r)
                   b_begin = virt_beta(1,s)
                   b_end   = virt_beta(2,s)
                   do a=a_begin,a_end
                     do b=max(a+1,b_begin),b_end
                       T2deriv%bb%m(a,i)%nsym(s,q)%n(b,j) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%bb%m(a,i)%nsym(s,q)%n(b,j)
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do
        Call CPU_TIME(time_end)
        time_ijaa_inverse = time_end - time_begin + time_ijaa_inverse

      end subroutine reshape_ijbb_inverseOS

       subroutine reshape_ajbbOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_ajaa
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: a,j,c,k
       integer :: row,col,c_begin,c_end,k_begin,k_end,t,v
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
         allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajbb(p)%col,1:ReshapedMatrixDim%ajbb(p)%row))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajbb(p)%col,1:ReshapedMatrixDim%ajbb(p)%row))
       end do
      do p=1,SG
        maxrow_SG(p) = 0
      end do


     row = 1
       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_alpha(1,p)
           c_end   = virt_alpha(2,p)
           k_begin = occ_alpha(1,q)
           k_end   = occ_alpha(2,q)
           do k=k_begin,k_end
             do c=c_begin,c_end
               col = col + 1
               row = 1
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 a_begin = virt_beta(1,r)
                 a_end   = virt_beta(2,r)
                 j_begin = occ_beta(1,s)
                 j_end   = occ_beta(2,s)
                 do j=j_begin,j_end
                   do a=a_begin,a_end
                    Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%ab%m(c,k)%nsym(r,s)%n(a,j)
                    row = row + 1
                    maxrow_SG(symgp) = col
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

       do symgp=1,SG
         col = maxrow_SG(symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_beta(1,p)
           c_end   = virt_beta(2,p)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
             do k=k_begin,k_end
               do c=c_begin,c_end
                 col = col + 1
                  row = 1
                 do v=1,SG
                   r = InvPdt(symgp)%upper(v)
                   s = InvPdt(symgp)%lower(v)
                   a_begin = virt_beta(1,r)
                   a_end   = virt_beta(2,r)
                   j_begin = occ_beta(1,s)
                   j_end   = occ_beta(2,s)
                   do j=j_begin,j_end
                     do a=a_begin,a_end
                       Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%bb%m(c,k)%nsym(r,s)%n(a,j)
                       row = row + 1
                      end do
                    end do
                  end do
                end do
              end do
            end do
          end do
          Call CPU_TIME(time_end)
          time_ajaa = time_end - time_begin + time_ajaa



      end subroutine reshape_ajbbOS


       subroutine reshape_ajbb_inverseOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_ajaa
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: a,j,c,k
       integer :: row,col,c_begin,c_end,k_begin,k_end,t,v
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

      do p=1,SG
        maxrow_SG(p) = 0
      end do


     row = 1
       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_alpha(1,p)
           c_end   = virt_alpha(2,p)
           k_begin = occ_alpha(1,q)
           k_end   = occ_alpha(2,q)
           do k=k_begin,k_end
             do c=c_begin,c_end
               col = col + 1
               row = 1
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 a_begin = virt_beta(1,r)
                 a_end   = virt_beta(2,r)
                 j_begin = occ_beta(1,s)
                 j_end   = occ_beta(2,s)
                 do j=j_begin,j_end
                   do a=a_begin,a_end
                     T2deriv%ab%m(c,k)%nsym(r,s)%n(a,j) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(c,k)%nsym(r,s)%n(a,j)
                    row = row + 1
                    maxrow_SG(symgp) = col
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

       do symgp=1,SG
         col = maxrow_SG(symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_beta(1,p)
           c_end   = virt_beta(2,p)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
             do k=k_begin,k_end
               do c=c_begin,c_end
                 col = col + 1
                  row = 1
                 do v=1,SG
                   r = InvPdt(symgp)%upper(v)
                   s = InvPdt(symgp)%lower(v)
                   a_begin = virt_beta(1,r)
                   a_end   = virt_beta(2,r)
                   j_begin = occ_beta(1,s)
                   j_end   = occ_beta(2,s)
                   do j=j_begin,j_end
                     do a=a_begin,a_end
                      T2deriv%bb%m(c,k)%nsym(r,s)%n(a,j) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%bb%m(c,k)%nsym(r,s)%n(a,j)
                       row = row + 1
                      end do
                    end do
                  end do
                end do
              end do
            end do
          end do

          Call CPU_TIME(time_end)
          time_ajaa = time_end - time_begin + time_ajaa



      end subroutine reshape_ajbb_inverseOS


       subroutine reshape_ijab_testOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_ijab
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), dimension(:) :: InvPdt(1:SG)

       integer :: symgp,p,q,r,s
       integer, dimension(1:SG) :: total_SG_row, total_SG_col
       integer, target :: a,b,i,j
       integer, target :: row,col,i_begin,i_end,j_begin,j_end,a_begin,a_end,b_begin,b_end
       integer :: numa,numb,numi,numj
       integer, pointer :: jptr, bptr
       integer :: t,v
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
          allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ijab(p)%row,1:ReshapedMatrixDim%ijab(p)%col))
          allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ijab(p)%row,1:ReshapedMatrixDim%ijab(p)%col))
       end do
      do symgp=1,SG
         col = 0
         do t=1,SG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             i_begin = occ_alpha(1,p)
             i_end   = occ_alpha(2,p)
             j_begin = occ_beta(1,q)
             j_end   = occ_beta(2,q)
             do i=i_begin,i_end
               do j=j_begin,j_end
                 col = col + 1
                 row = 1
                 do v=1,SG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   a_begin = virt_alpha(1,r)
                   a_end   = virt_alpha(2,r)
                   b_begin = virt_beta(1,s)
                   b_end   = virt_beta(2,s)
                   do a=a_begin,a_end
                     do b=b_begin,b_end
                       Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%ab%m(a,i)%nsym(s,q)%n(b,j)
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do


        Call CPU_TIME(time_end)
         time_ijab = time_end - time_begin + time_ijab
      end subroutine reshape_ijab_testOS

       subroutine reshape_ijab_inverseOS(SG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_ijab_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), dimension(:) :: InvPdt(1:SG)

       integer :: symgp,p,q,r,s
       integer, dimension(1:SG) :: total_SG_row, total_SG_col
       integer, target :: a,b,i,j
       integer, target :: row,col,i_begin,i_end,j_begin,j_end,a_begin,a_end,b_begin,b_end
       integer :: numa,numb,numi,numj
       integer, pointer :: jptr, bptr
       integer :: t,v
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)
      do symgp=1,SG
         col = 0
         do t=1,SG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             i_begin = occ_alpha(1,p)
             i_end   = occ_alpha(2,p)
             j_begin = occ_beta(1,q)
             j_end   = occ_beta(2,q)
             do i=i_begin,i_end
               do j=j_begin,j_end
                 col = col + 1
                 row = 1
                 do v=1,SG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   a_begin = virt_alpha(1,r)
                   a_end   = virt_alpha(2,r)
                   b_begin = virt_beta(1,s)
                   b_end   = virt_beta(2,s)
                   do a=a_begin,a_end
                     do b=b_begin,b_end
                       T2deriv%ab%m(a,i)%nsym(s,q)%n(b,j) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(a,i)%nsym(s,q)%n(b,j)
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do

       Call CPU_TIME(time_end)
         time_ijab_inverse = time_end - time_begin + time_ijab_inverse
      end subroutine reshape_ijab_inverseOS

       subroutine reshape_ajabOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_ajab
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end
       integer, dimension(1:SG) :: total_SG
       integer :: a,j,c,k,t,v
       integer :: row,col,c_begin,c_end,k_begin,k_end
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
         allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajab(p)%col,1:ReshapedMatrixDim%ajab(p)%row))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajab(p)%col,1:ReshapedMatrixDim%ajab(p)%row))
       end do

       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
            do a=a_begin,a_end
              do j=j_begin,j_end
                row = 1
                col = col + 1
                do v=1,SG
                  r = InvPdt(symgp)%upper(v)
                  s = InvPdt(symgp)%lower(v)
                  c_begin = virt_beta(1,r)
                  c_end   = virt_beta(2,r)
                  k_begin = occ_alpha(1,s)
                  k_end   = occ_alpha(2,s)
                  do k=k_begin,k_end
                    do c=c_begin,c_end
                       Reshapes(symgp)%ReshapedMatrix(row,col) = -1*T2data%ab%m(a,k)%nsym(r,q)%n(c,j)
                      row = row + 1
                      end do
                    end do
                  end do
                end do
              end do
            end do
          end do


         Call CPU_TIME(time_end)
         time_ajab = time_end - time_begin + time_ajab
      end subroutine reshape_ajabOS



       subroutine reshape_ajab_inverseOS(SG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_ajab_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end
       integer, dimension(1:SG) :: total_SG
       integer :: a,j,c,k,t,v
       integer :: row,col,c_begin,c_end,k_begin,k_end
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)

       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
            do a=a_begin,a_end
              do j=j_begin,j_end
                row = 1
                col = col + 1
                do v=1,SG
                  r = InvPdt(symgp)%upper(v)
                  s = InvPdt(symgp)%lower(v)
                  c_begin = virt_beta(1,r)
                  c_end   = virt_beta(2,r)
                  k_begin = occ_alpha(1,s)
                  k_end   = occ_alpha(2,s)
                  do k=k_begin,k_end
                    do c=c_begin,c_end
                     T2deriv%ab%m(a,k)%nsym(r,q)%n(c,j) =  -1*DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(a,k)%nsym(r,q)%n(c,j)
                      row = row + 1
                      end do
                    end do
                  end do
                end do
              end do
            end do
          end do

          Call CPU_TIME(time_end)
          time_ajab_inverse = time_end - time_begin + time_ajab_inverse

      end subroutine  reshape_ajab_inverseOS



       subroutine reshape_ajbaOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_ajab
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end
       integer, dimension(1:SG) :: total_SG
       integer :: a,j,c,k,t,v
       integer :: row,col,c_begin,c_end,k_begin,k_end
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
         allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajba(p)%col,1:ReshapedMatrixDim%ajba(p)%row))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajba(p)%col,1:ReshapedMatrixDim%ajba(p)%row))
       end do

       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
            do j=j_begin,j_end
              do a=a_begin,a_end
                row = 1
                col = col + 1
                do v=1,SG
                  r = InvPdt(symgp)%upper(v)
                  s = InvPdt(symgp)%lower(v)
                  c_begin = virt_alpha(1,r)
                  c_end   = virt_alpha(2,r)
                  k_begin = occ_beta(1,s)
                  k_end   = occ_beta(2,s)
                  do c=c_begin,c_end
                    do k=k_begin,k_end
                       Reshapes(symgp)%ReshapedMatrix(row,col) = -1*T2data%ab%m(c,j)%nsym(p,s)%n(a,k)
                      row = row + 1
                      end do
                    end do
                  end do
                end do
              end do
            end do
          end do


         Call CPU_TIME(time_end)
         time_ajab = time_end - time_begin + time_ajab
      end subroutine reshape_ajbaOS



       subroutine reshape_ajba_inverseOS(SG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_ajba_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end,t,v
       integer, dimension(1:SG) :: total_SG
       integer :: a,j,c,k
       integer :: row,col,c_begin,c_end,k_begin,k_end
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)


       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
             do j=j_begin,j_end
              do a=a_begin,a_end
                 row = 1
                 col = col + 1
                 do v=1,SG
                   r = InvPdt(symgp)%upper(v)
                   s = InvPdt(symgp)%lower(v)
                   c_begin = virt_alpha(1,r)
                   c_end   = virt_alpha(2,r)
                   k_begin = occ_beta(1,s)
                   k_end   = occ_beta(2,s)
                    do c=c_begin,c_end
                      do k=k_begin,k_end
                      T2deriv%ab%m(c,j)%nsym(p,s)%n(a,k) = -1*DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(c,j)%nsym(p,s)%n(a,k)
                       row = row + 1
                       end do
                     end do
                   end do
                 end do
               end do
             end do
           end do

         Call CPU_TIME(time_end)
         time_ajba_inverse = time_end - time_begin + time_ajba_inverse

      end subroutine reshape_ajba_inverseOS


       subroutine reshape_ialphaOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Use TypeMod;
       Use TimeMod, only : time_i
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat), intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN) :: InvPdt(1:SG)

       integer, dimension(1:SG) :: total_SG_row, total_SG_col
       integer :: i,a,b,k,symgp
       integer :: i_begin,i_end,a_begin,a_end,b_begin,b_end,k_begin,k_end
       integer :: p,q,r,s,numi,numa,numb,numk,row,col,t
       integer, dimension(1:SG) :: maxrow_SG
       integer :: aisym
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)

       do i=1,SG
          maxrow_SG(i) = 0
       end do


       do p=1,SG
          allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%i_alpha(p)%row,1:ReshapedMatrixDim%i_alpha(p)%col))
          allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%i_alpha(p)%row,1:ReshapedMatrixDim%i_alpha(p)%col))
       end do

       row = 1
       do symgp=1,SG
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         col = 0
         do i=i_begin,i_end
           col = col + 1
           row = 1
           do p=1,SG
             a_begin = virt_alpha(1,p)
             a_end   = virt_alpha(2,p)
             aisym = ProductTable(symgp,p)
             do a=a_begin,a_end
               do t=1,SG
                 q = InvPdt(aisym)%upper(t)
                 r = InvPdt(aisym)%lower(t)
                 if(p>r) cycle
                 b_begin = virt_alpha(1,r)
                 b_end   = virt_alpha(2,r)
                 k_begin = occ_alpha(1,q)
                 k_end   = occ_alpha(2,q)
                 do k=k_begin,k_end
                   do b=max(a+1,b_begin),b_end
                     Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%aa%m(a,i)%nsym(r,q)%n(b,k)
                     maxrow_SG(symgp) = row
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,SG
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         col = 0
         do i=i_begin,i_end
           col = col + 1
           row = maxrow_SG(symgp) + 1
           do p=1,SG
             a_begin = virt_alpha(1,p)
             a_end   = virt_alpha(2,p)
             aisym = ProductTable(symgp,p)
             do a=a_begin,a_end
               do t=1,SG
                 q = InvPdt(aisym)%upper(t)
                 r = InvPdt(aisym)%lower(t)
                 b_begin = virt_beta(1,r)
                 b_end   = virt_beta(2,r)
                 k_begin = occ_beta(1,q)
                 k_end   = occ_beta(2,q)
                 do k=k_begin,k_end
                   do b=b_begin,b_end
                     Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%ab%m(a,i)%nsym(r,q)%n(b,k)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       Call CPU_TIME(time_end)
       time_i = time_end - time_begin - time_i
end subroutine reshape_ialphaOS

       subroutine reshape_ialpha_inverseOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Use TypeMod;
       Use TimeMod, only : time_i
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat), intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN) :: InvPdt(1:SG)

       integer, dimension(1:SG) :: total_SG_row, total_SG_col
       integer :: i,a,b,k,symgp
       integer :: i_begin,i_end,a_begin,a_end,b_begin,b_end,k_begin,k_end
       integer :: p,q,r,s,numi,numa,numb,numk,row,col,t
       integer, dimension(1:SG) :: maxrow_SG
       integer :: aisym
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)

       do i=1,SG
          maxrow_SG(i) = 0
       end do



       row = 1
       do symgp=1,SG
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         col = 0
         do i=i_begin,i_end
           col = col + 1
           row = 1
           do p=1,SG
             a_begin = virt_alpha(1,p)
             a_end   = virt_alpha(2,p)
             aisym = ProductTable(symgp,p)
             do a=a_begin,a_end
               do t=1,SG
                 q = InvPdt(aisym)%upper(t)
                 r = InvPdt(aisym)%lower(t)
                 if(p>r) cycle
                 b_begin = virt_alpha(1,r)
                 b_end   = virt_alpha(2,r)
                 k_begin = occ_alpha(1,q)
                 k_end   = occ_alpha(2,q)
                 do k=k_begin,k_end
                   do b=max(a+1,b_begin),b_end
                     T2deriv%aa%m(a,i)%nsym(r,q)%n(b,k) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%aa%m(a,i)%nsym(r,q)%n(b,k)
                     maxrow_SG(symgp) = row
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,SG
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         col = 0
         do i=i_begin,i_end
           col = col + 1
           row = maxrow_SG(symgp) + 1
           do p=1,SG
             a_begin = virt_alpha(1,p)
             a_end   = virt_alpha(2,p)
             aisym = ProductTable(symgp,p)
             do a=a_begin,a_end
               do t=1,SG
                 q = InvPdt(aisym)%upper(t)
                 r = InvPdt(aisym)%lower(t)
                 b_begin = virt_beta(1,r)
                 b_end   = virt_beta(2,r)
                 k_begin = occ_beta(1,q)
                 k_end   = occ_beta(2,q)
                 do k=k_begin,k_end
                   do b=b_begin,b_end
                     T2deriv%ab%m(a,i)%nsym(r,q)%n(b,k) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(a,i)%nsym(r,q)%n(b,k)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       Call CPU_TIME(time_end)
       time_i = time_end - time_begin - time_i
end subroutine reshape_ialpha_inverseOS

       subroutine reshape_aalphaOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Use TypeMod;
       Use TimeMod, only : time_a
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat), intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)

       integer :: a,c,i,j,symgp
       integer :: a_begin,a_end,c_begin,c_end,i_begin,i_end,j_begin,j_end
       integer :: p,q,r,s,numa,numc,numi,numj,row,col,t
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)




       do p=1,SG
         allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%a_alpha(p)%row,1:ReshapedMatrixDim%a_alpha(p)%col))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%a_alpha(p)%row,1:ReshapedMatrixDim%a_alpha(p)%col))
       end do

      row = 1
       do symgp=1,SG
         maxrow_SG(symgp) = 0
         a_begin = virt_alpha(1,symgp)
         a_end   = virt_alpha(2,symgp)
         col = 0
         do a=a_begin,a_end
           col = col + 1
           row = 1
           do p=1,SG
             i_begin = occ_alpha(1,p)
             i_end   = occ_alpha(2,p)
             do i=i_begin,i_end
               do t=1,SG
                 q = InvPdt(ProductTable(symgp,p))%upper(t)
                 r = InvPdt(ProductTable(symgp,p))%lower(t)
                 if(p>q) cycle
                 c_begin = virt_alpha(1,r)
                 c_end   = virt_alpha(2,r)
                 j_begin = occ_alpha(1,q)
                 j_end   = occ_alpha(2,q)
                 do j=max(i+1,j_begin),j_end
                   do c=c_begin,c_end
                     Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%aa%m(a,i)%nsym(r,q)%n(c,j)
                     maxrow_SG(symgp) = row
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

      do symgp=1,SG
        a_begin = virt_alpha(1,symgp)
        a_end   = virt_alpha(2,symgp)
        col = 0
        do a=a_begin,a_end
          col = col + 1
          row = maxrow_SG(symgp)  + 1
          do p=1,SG
            i_begin = occ_alpha(1,p)
            i_end   = occ_alpha(2,p)
            do i=i_begin,i_end
              do t=1,SG
               q = InvPdt(ProductTable(symgp,p))%upper(t)
               r = InvPdt(ProductTable(symgp,p))%lower(t)
                   c_begin = virt_beta(1,r)
                   c_end   = virt_beta(2,r)
                   j_begin = occ_beta(1,q)
                   j_end   = occ_beta(2,q)
                     do j=j_begin,j_end
                       do c=c_begin,c_end
                         Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%ab%m(a,i)%nsym(r,q)%n(c,j)
                         row = row + 1
                       end do
                     end do
                 end do
               end do
             end do
           end do
         end do

        Call CPU_TIME(time_end)
         time_a = time_end - time_begin + time_a

       end subroutine reshape_aalphaOS

       subroutine reshape_aalpha_inverseOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Use TypeMod;
       Use TimeMod, only : time_a
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat), intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)

       integer :: a,c,i,j,symgp
       integer :: a_begin,a_end,c_begin,c_end,i_begin,i_end,j_begin,j_end
       integer :: p,q,r,s,numa,numc,numi,numj,row,col,t
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)

      row = 1
       do symgp=1,SG
         maxrow_SG(symgp) = 0
         a_begin = virt_alpha(1,symgp)
         a_end   = virt_alpha(2,symgp)
         col = 0
         do a=a_begin,a_end
           col = col + 1
           row = 1
           do p=1,SG
             i_begin = occ_alpha(1,p)
             i_end   = occ_alpha(2,p)
             do i=i_begin,i_end
               do t=1,SG
                 q = InvPdt(ProductTable(symgp,p))%upper(t)
                 r = InvPdt(ProductTable(symgp,p))%lower(t)
                 if(p>q) cycle
                 c_begin = virt_alpha(1,r)
                 c_end   = virt_alpha(2,r)
                 j_begin = occ_alpha(1,q)
                 j_end   = occ_alpha(2,q)
                 do j=max(i+1,j_begin),j_end
                   do c=c_begin,c_end
                     T2deriv%aa%m(a,i)%nsym(r,q)%n(c,j) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%aa%m(a,i)%nsym(r,q)%n(c,j)
                     maxrow_SG(symgp) = row
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

      do symgp=1,SG
        a_begin = virt_alpha(1,symgp)
        a_end   = virt_alpha(2,symgp)
        col = 0
        do a=a_begin,a_end
          col = col + 1
          row = maxrow_SG(symgp)  + 1
          do p=1,SG
            i_begin = occ_alpha(1,p)
            i_end   = occ_alpha(2,p)
            do i=i_begin,i_end
              do t=1,SG
               q = InvPdt(ProductTable(symgp,p))%upper(t)
               r = InvPdt(ProductTable(symgp,p))%lower(t)
                   c_begin = virt_beta(1,r)
                   c_end   = virt_beta(2,r)
                   j_begin = occ_beta(1,q)
                   j_end   = occ_beta(2,q)
                     do j=j_begin,j_end
                       do c=c_begin,c_end
                        T2deriv%ab%m(a,i)%nsym(r,q)%n(c,j) =  DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(a,i)%nsym(r,q)%n(c,j)
                         row = row + 1
                       end do
                     end do
                 end do
               end do
             end do
           end do
         end do

        Call CPU_TIME(time_end)
         time_a = time_end - time_begin + time_a

       end subroutine reshape_aalpha_inverseOS

       subroutine reshape_ibetaOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Use TypeMod;
       Use TimeMod, only : time_i
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat), intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN) :: InvPdt(1:SG)

       integer, dimension(1:SG) :: total_SG_row, total_SG_col
       integer :: i,a,b,k,symgp
       integer :: i_begin,i_end,a_begin,a_end,b_begin,b_end,k_begin,k_end
       integer :: p,q,r,s,numi,numa,numb,numk,row,col,t
       integer, dimension(1:SG) :: maxcol_SG
       integer :: kisym
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)

       do i=1,SG
          maxcol_SG(i) = 0
       end do


       do p=1,SG
          allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%i_beta(p)%col,1:ReshapedMatrixDim%i_beta(p)%row))
          allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%i_beta(p)%col,1:ReshapedMatrixDim%i_beta(p)%row))
       end do

       do symgp=1,SG
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         col = 0
         do p=1,SG
           k_begin = occ_alpha(1,p)
           k_end   = occ_alpha(2,p)
           kisym = ProductTable(symgp,p)
           do k=k_begin,k_end
             do t=1,SG
               q = InvPdt(kisym)%upper(t)
               r = InvPdt(kisym)%lower(t)
               b_begin = virt_beta(1,r)
               b_end   = virt_beta(2,r)
               a_begin = virt_alpha(1,q)
               a_end   = virt_alpha(2,q)
               do a=a_begin,a_end
                 do b=b_begin,b_end
                   col = col + 1
                    maxcol_SG(symgp) = col
                   row = 1
                   do i=i_begin,i_end
                     Reshapes(symgp)%ReshapedMatrix(row,col) = 1*T2data%ab%m(a,k)%nsym(r,symgp)%n(b,i)
                    row = row + 1
                 end do
               end do
             end do
           end do
         end do
       end do
     end do
       do symgp=1,SG
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         col = maxcol_SG(symgp)
         do p=1,SG
           k_begin = occ_beta(1,p)
           k_end   = occ_beta(2,p)
           kisym = ProductTable(symgp,p)
           do k=k_begin,k_end
             do t=1,SG
               q = InvPdt(kisym)%upper(t)
               r = InvPdt(kisym)%lower(t)
               if(q>r) cycle
               b_begin = virt_beta(1,r)
               b_end   = virt_beta(2,r)
               a_begin = virt_beta(1,q)
               a_end   = virt_beta(2,q)
               do a=a_begin,a_end
                 do b=max(a+1,b_begin),b_end
                   col = col + 1
                   row = 1
                   do i=i_begin,i_end
                   Reshapes(symgp)%ReshapedMatrix(row,col) = 1*T2data%bb%m(a,k)%nsym(r,symgp)%n(b,i)
                   row = row + 1
                 end do
               end do
             end do
           end do
         end do
       end do
     end do

       Call CPU_TIME(time_end)
       time_i = time_end - time_begin - time_i
end subroutine reshape_ibetaOS

       subroutine reshape_ibeta_inverseOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Use TypeMod;
       Use TimeMod, only : time_i
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat), intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN) :: InvPdt(1:SG)

       integer, dimension(1:SG) :: total_SG_row, total_SG_col
       integer :: i,a,b,k,symgp
       integer :: i_begin,i_end,a_begin,a_end,b_begin,b_end,k_begin,k_end
       integer :: p,q,r,s,numi,numa,numb,numk,row,col,t
       integer, dimension(1:SG) :: maxcol_SG
       integer :: kisym
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)

       do i=1,SG
          maxcol_SG(i) = 0
       end do



       do symgp=1,SG
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         col = 0
         do p=1,SG
           k_begin = occ_alpha(1,p)
           k_end   = occ_alpha(2,p)
           kisym = ProductTable(symgp,p)
           do k=k_begin,k_end
             do t=1,SG
               q = InvPdt(kisym)%upper(t)
               r = InvPdt(kisym)%lower(t)
               b_begin = virt_beta(1,r)
               b_end   = virt_beta(2,r)
               a_begin = virt_alpha(1,q)
               a_end   = virt_alpha(2,q)
               do a=a_begin,a_end
                 do b=b_begin,b_end
                   col = col + 1
                    maxcol_SG(symgp) = col
                   row = 1
                   do i=i_begin,i_end
                     T2deriv%ab%m(a,k)%nsym(r,symgp)%n(b,i) =  1*DerivReshapes(symgp)%ReshapedMatrix(row,col)  +T2deriv%ab%m(a,k)%nsym(r,symgp)%n(b,i)
                    row = row + 1
                 end do
               end do
             end do
           end do
         end do
       end do
     end do
       do symgp=1,SG
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         col = maxcol_SG(symgp)
         do p=1,SG
           k_begin = occ_beta(1,p)
           k_end   = occ_beta(2,p)
           kisym = ProductTable(symgp,p)
           do k=k_begin,k_end
             do t=1,SG
               q = InvPdt(kisym)%upper(t)
               r = InvPdt(kisym)%lower(t)
               if(q>r) cycle
               b_begin = virt_beta(1,r)
               b_end   = virt_beta(2,r)
               a_begin = virt_beta(1,q)
               a_end   = virt_beta(2,q)
               do a=a_begin,a_end
                 do b=max(a+1,b_begin),b_end
                   col = col + 1
                   row = 1
                   do i=i_begin,i_end
                     T2deriv%bb%m(a,k)%nsym(r,symgp)%n(b,i) = 1*DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%bb%m(a,k)%nsym(r,symgp)%n(b,i)
                   row = row + 1
                 end do
               end do
             end do
           end do
         end do
       end do
     end do

       Call CPU_TIME(time_end)
       time_i = time_end - time_begin - time_i
end subroutine reshape_ibeta_inverseOS

       subroutine reshape_abetaOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Use TypeMod;
       Use TimeMod, only : time_i
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat), intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN) :: InvPdt(1:SG)

       integer, dimension(1:SG) :: total_SG_row, total_SG_col
       integer :: i,a,b,k,symgp
       integer :: i_begin,i_end,a_begin,a_end,b_begin,b_end,k_begin,k_end
       integer :: p,q,r,s,numi,numa,numb,numk,row,col,t
       integer, dimension(1:SG) :: maxcol_SG
       integer :: aisym
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)

       do i=1,SG
          maxcol_SG(i) = 0
       end do


       do p=1,SG
          allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%a_beta(p)%col,1:ReshapedMatrixDim%a_beta(p)%row))
          allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%a_beta(p)%col,1:ReshapedMatrixDim%a_beta(p)%row))
       end do

       do symgp=1,SG
         a_begin = virt_beta(1,symgp)
         a_end   = virt_beta(2,symgp)
         col = 0
         do p=1,SG
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           aisym = ProductTable(symgp,p)
           do i=i_begin,i_end
             do t=1,SG
               q = InvPdt(aisym)%upper(t)
               r = InvPdt(aisym)%lower(t)
               b_begin = virt_alpha(1,r)
               b_end   = virt_alpha(2,r)
               k_begin = occ_beta(1,q)
               k_end   = occ_beta(2,q)
               do k=k_begin,k_end
                 do b=b_begin,b_end
                   col = col + 1
                   maxcol_SG(symgp) = col
                   row = 1
                   do a=a_begin,a_end
                     Reshapes(symgp)%ReshapedMatrix(row,col) = 1*T2data%ab%m(b,i)%nsym(symgp,q)%n(a,k)
                     row = row + 1
                 end do
               end do
             end do
           end do
         end do
       end do
     end do
       do symgp=1,SG
         a_begin = virt_beta(1,symgp)
         a_end   = virt_beta(2,symgp)
         col = maxcol_SG(symgp)
         do p=1,SG
           i_begin = occ_beta(1,p)
           i_end   = occ_beta(2,p)
           aisym = ProductTable(symgp,p)
           do i=i_begin,i_end
             do t=1,SG
               q = InvPdt(aisym)%upper(t)
               r = InvPdt(aisym)%lower(t)
               if(p>q) cycle
               b_begin = virt_beta(1,r)
               b_end   = virt_beta(2,r)
               k_begin = occ_beta(1,q)
               k_end   = occ_beta(2,q)
               do b=b_begin,b_end
                 do k=max(i+1,k_begin),k_end
                   col = col + 1
                   row = 1
                   do a=a_begin,a_end
                   Reshapes(symgp)%ReshapedMatrix(row,col) = 1*T2data%bb%m(b,i)%nsym(symgp,q)%n(a,k)
                   row = row + 1
                 end do
               end do
             end do
           end do
         end do
       end do
     end do
       Call CPU_TIME(time_end)
       time_i = time_end - time_begin - time_i
end subroutine reshape_abetaOS

       subroutine reshape_abeta_inverseOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Use TypeMod;
       Use TimeMod, only : time_i
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat), intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN) :: InvPdt(1:SG)

       integer, dimension(1:SG) :: total_SG_row, total_SG_col
       integer :: i,a,b,k,symgp
       integer :: i_begin,i_end,a_begin,a_end,b_begin,b_end,k_begin,k_end
       integer :: p,q,r,s,numi,numa,numb,numk,row,col,t
       integer, dimension(1:SG) :: maxcol_SG
       integer :: aisym
       real :: time_begin, time_end

       Call CPU_TIME(time_begin)

       do i=1,SG
          maxcol_SG(i) = 0
       end do



       do symgp=1,SG
         a_begin = virt_beta(1,symgp)
         a_end   = virt_beta(2,symgp)
         col = 0
         do p=1,SG
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           aisym = ProductTable(symgp,p)
           do i=i_begin,i_end
             do t=1,SG
               q = InvPdt(aisym)%upper(t)
               r = InvPdt(aisym)%lower(t)
               b_begin = virt_alpha(1,r)
               b_end   = virt_alpha(2,r)
               k_begin = occ_beta(1,q)
               k_end   = occ_beta(2,q)
               do k=k_begin,k_end
                 do b=b_begin,b_end
                   col = col + 1
                   maxcol_SG(symgp) = col
                   row = 1
                   do a=a_begin,a_end
                     T2deriv%ab%m(b,i)%nsym(symgp,q)%n(a,k) = 1*DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(b,i)%nsym(symgp,q)%n(a,k)
                     row = row + 1
                 end do
               end do
             end do
           end do
         end do
       end do
     end do
       do symgp=1,SG
         a_begin = virt_beta(1,symgp)
         a_end   = virt_beta(2,symgp)
         col = maxcol_SG(symgp)
         do p=1,SG
           i_begin = occ_beta(1,p)
           i_end   = occ_beta(2,p)
           aisym = ProductTable(symgp,p)
           do i=i_begin,i_end
             do t=1,SG
               q = InvPdt(aisym)%upper(t)
               r = InvPdt(aisym)%lower(t)
               if(p>q) cycle
               b_begin = virt_beta(1,r)
               b_end   = virt_beta(2,r)
               k_begin = occ_beta(1,q)
               k_end   = occ_beta(2,q)
               do b=b_begin,b_end
                 do k=max(i+1,k_begin),k_end
                   col = col + 1
                   row = 1
                   do a=a_begin,a_end
                  T2deriv%bb%m(b,i)%nsym(symgp,q)%n(a,k) = 1*DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%bb%m(b,i)%nsym(symgp,q)%n(a,k)
                   row = row + 1
                 end do
               end do
             end do
           end do
         end do
       end do
     end do

       Call CPU_TIME(time_end)
       time_i = time_end - time_begin - time_i
end subroutine reshape_abeta_inverseOS

!> @brief Calculates the T1/T2 parameter derivatives for open shell calculations
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine CalcDerivOS(T2data,K2,K1,numSG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,ReshapedMatrixDim,InvPdt,T2deriv, energy,K1TwoInts,T1data,T1deriv,Newc,DerivNewc,topfac,TwoInts,topsingles,OldIndex_alpha,OldIndex_beta,T2derivT1topfac,Newc_singles,DerivNewc_singles)
       Use InterfaceMod
       Use TypeMod
       Use TimeMod
       Implicit None

       type(T2) :: T2data
       type(T1) :: T1data,T1deriv, Newc_singles, DerivNewc_singles
       type(T2) :: Newc,DerivNewc, T2derivT1topfac
       type(spin) :: K2(1:2,1:2,1:2,1:2)
       type(spin) :: K1(1:2,1:2),K1TwoInts(1:2,1:2)
       integer :: numSG
       integer, intent(IN), dimension(1:numSG,1:numSG) :: ProductTable
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN) :: InvPdt(1:numSG)
       integer, intent(IN), dimension(1:2,1:numSG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       type(T2) :: T2deriv
       real(8) :: energy
       real(8), dimension(0:2,0:2) :: topfac
       real(8), intent(IN), allocatable, dimension(:,:,:,:) :: TwoInts
       real(8), dimension(0:1,0:1) :: topsingles(0:1,0:1)
       integer, allocatable, dimension(:) :: OldIndex_alpha, OldIndex_beta

       integer :: p, i_begin,i_end,j_begin,j_end,k_begin,k_end, l_begin,l_end,i,j,k,l,q,r,s,t,v,row,col,symgp
       integer :: c_begin,c_end,a_begin,a_end,c,a

       type(ReshapedMat), allocatable, dimension(:)  :: DerivReshapes, Reshapes, TopReshape,DerivTopReshape
       real(8) :: tempenergy=0.0D0
       type(ReshapedMat), allocatable, dimension(:) :: TempReshape,TempDerivReshape,TempMat1,TempMat2
       real(8), allocatable, dimension(:,:) :: temp
       integer :: time_initial(8),time_final(8)
       real :: time_total_begin, time_total_end
       integer :: numa,numi
       integer :: numocc_alpha, numvirt_alpha,numocc_beta,numvirt_beta
       double precision :: T1energy

       real :: time_begin_transpose, time_end_transpose
       Call cpu_time(time_total_begin)



       energy = 0.0D0

       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ijaa_testOS(numSG,ProductTable,Reshapes,occ_alpha,virt_alpha,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,1,1)%aa%irrep(p)%block)
       end do
         do p=1,numSG
           DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K2(2,2,2,2)%aa%irrep(p)%block,Reshapes(p)%ReshapedMatrix) + DerivReshapes(p)%ReshapedMatrix
        end do
       Call reshape_ijaa_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,virt_alpha,T2deriv,ReshapedMatrixDim,InvPdt)
       deallocate(DerivReshapes)
       allocate(DerivReshapes(1:numSG))
       allocate(TopReshape(1:numSG))

       Call TopFactorOS(TwoInts,T2data,occ_alpha,occ_beta,virt_alpha,virt_beta,numSG,topfac,Newc,InvPdt,ProductTable,DerivNewc,T1data,T1deriv,topsingles,OldIndex_alpha,OldIndex_beta,T2derivT1topfac,Newc_singles,DerivNewc_singles,K1,K1TwoInts)
       Call reshape_ijaa_testOS(numSG,ProductTable,TopReshape,occ_alpha,virt_alpha,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)

       do p=1,numSG
         do s=1,ReshapedMatrixDim%ijaa(p)%col
           do q=1,ReshapedMatrixDim%ijaa(p)%row
             energy = energy + Reshapes(p)%ReshapedMatrix(q,s)*2*K2(1,1,2,2)%aa%irrep(p)%block(q,s)*TopReshape(p)%ReshapedMatrix(q,s)
             tempenergy = tempenergy + Reshapes(p)%ReshapedMatrix(q,s)*2*K2(1,1,2,2)%aa%irrep(p)%block(q,s)*TopReshape(p)%ReshapedMatrix(q,s)
           end do
         end do
       end do

       deallocate(TopReshape)
       deallocate(Reshapes)
       deallocate(DerivReshapes)

       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ajaaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)

       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,2,1,2)%aa%irrep(p)%block)
       end do
       Call reshape_ajaa_inverseOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)

       deallocate(Reshapes)
       deallocate(DerivReshapes)



       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ijbb_testOS(numSG,ProductTable,Reshapes,occ_beta,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,1,1)%bb%irrep(p)%block)
       end do
         do p=1,numSG
           DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K2(2,2,2,2)%bb%irrep(p)%block,Reshapes(p)%ReshapedMatrix) + DerivReshapes(p)%ReshapedMatrix
        end do
       Call reshape_ijbb_inverseOS(numSG,ProductTable,DerivReshapes,occ_beta,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
       deallocate(DerivReshapes)
       allocate(DerivReshapes(1:numSG))
       allocate(TopReshape(1:numSG))

       Call reshape_ijbb_testOS(numSG,ProductTable,TopReshape,occ_beta,virt_beta,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)

       do p=1,numSG
         do s=1,ReshapedMatrixDim%ijbb(p)%col
           do q=1,ReshapedMatrixDim%ijbb(p)%row
             energy = energy + Reshapes(p)%ReshapedMatrix(q,s)*2*K2(1,1,2,2)%bb%irrep(p)%block(q,s)*TopReshape(p)%ReshapedMatrix(q,s)
             tempenergy = tempenergy + Reshapes(p)%ReshapedMatrix(q,s)*2*K2(1,1,2,2)%bb%irrep(p)%block(q,s)*TopReshape(p)%ReshapedMatrix(q,s)

           end do
         end do
       end do
       deallocate(TopReshape)
       deallocate(Reshapes)
       deallocate(DerivReshapes)
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ajbbOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(K2(1,2,1,2)%bb%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
       end do
       Call reshape_ajbb_inverseOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       deallocate(Reshapes)
       deallocate(DerivReshapes)




       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ijab_testOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,1,1)%ab%irrep(p)%block)
       end do
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K2(2,2,2,2)%ab%irrep(p)%block,Reshapes(p)%ReshapedMatrix) + DerivReshapes(p)%ReshapedMatrix
       end do
       Call reshape_ijab_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)


       deallocate(DerivReshapes)
       allocate(TopReshape(1:numSG))
       allocate(DerivReshapes(1:numSG))

       Call reshape_ijab_testOS(numSG,ProductTable,TopReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)
       deallocate(DerivReshapes)
       do p=1,numSG
         do q=1,ReshapedMatrixDim%ijab(p)%col
           do s=1,ReshapedMatrixDim%ijab(p)%row
             energy = energy + Reshapes(p)%ReshapedMatrix(s,q)*2*K2(1,1,2,2)%ab%irrep(p)%block(s,q)*TopReshape(p)%ReshapedMatrix(s,q)
             tempenergy = tempenergy + Reshapes(p)%ReshapedMatrix(s,q)*2*K2(1,1,2,2)%ab%irrep(p)%block(s,q)*TopReshape(p)%ReshapedMatrix(s,q)

           end do
         end do
      end do
       deallocate(TopReshape)

       deallocate(Reshapes)
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ajabOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(2,1,2,1)%ab%irrep(p)%block)
      end do
       Call reshape_ajab_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)

       deallocate(Reshapes)
       deallocate(DerivReshapes)
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ajbaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,2,1,2)%ab%irrep(p)%block)
       end do
       Call reshape_ajba_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
       deallocate(Reshapes)
       deallocate(DerivReshapes)

       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ialphaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K1(1,1)%aa%irrep(p)%block)
       end do
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix =-1*2*matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(1,1)%aa%irrep(p)%block) + DerivReshapes(p)%ReshapedMatrix
      end do

      Call reshape_ialpha_inverseOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
      deallocate(Reshapes)
      deallocate(DerivReshapes)
      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))

      Call reshape_aalphaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K1(2,2)%aa%irrep(p)%block)
      end do
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(2,2)%aa%irrep(p)%block) + DerivReshapes(p)%ReshapedMatrix
      end do

      Call reshape_aalpha_inverseOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
      deallocate(Reshapes)
      deallocate(DerivReshapes)
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ibetaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
          DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(K1(1,1)%bb%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
       end do
       do p=1,numSG
          DerivReshapes(p)%ReshapedMatrix =-1*2*matmul4(K1TwoInts(1,1)%bb%irrep(p)%block,Reshapes(p)%ReshapedMatrix) + DerivReshapes(p)%ReshapedMatrix
      end do
      Call reshape_ibeta_inverseOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
      deallocate(Reshapes)
      deallocate(DerivReshapes)

      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
      Call reshape_abetaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K1(2,2)%bb%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
      end do

      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K1TwoInts(2,2)%bb%irrep(p)%block,Reshapes(p)%ReshapedMatrix) + DerivReshapes(p)%ReshapedMatrix
      end do
      Call reshape_abeta_inverseOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
      deallocate(Reshapes)
      deallocate(DerivReshapes)


       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_alpha(1,r)
                 c_end   = virt_alpha(2,r)
                 k_begin = occ_alpha(1,s)
                 k_end   = occ_alpha(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     energy = energy + 0.5*T2data%aa%m(a,j)%nsym(r,s)%n(c,k)*T2deriv%aa%m(a,j)%nsym(r,s)%n(c,k)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_beta(1,r)
                 c_end   = virt_beta(2,r)
                 k_begin = occ_beta(1,s)
                 k_end   = occ_beta(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     energy = energy + 0.5*T2data%bb%m(a,j)%nsym(r,s)%n(c,k)*T2deriv%bb%m(a,j)%nsym(r,s)%n(c,k)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do



       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p);
           a_end   = virt_alpha(2,p);
           j_begin = occ_alpha(1,q);
           j_end   = occ_alpha(2,q);
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_beta(1,r)
                 c_end   = virt_beta(2,r)
                 k_begin = occ_beta(1,s)
                 k_end   = occ_beta(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     energy = energy + 0.5*T2data%ab%m(a,j)%nsym(r,s)%n(c,k)*T2deriv%ab%m(a,j)%nsym(r,s)%n(c,k)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

      allocate(DerivReshapes(1:numSG))
      allocate(TopReshape(1:numSG))
      allocate(DerivTopReshape(1:numSG))

      Call reshape_ijaa_testOS(numSG,ProductTable,TopReshape,occ_alpha,virt_alpha,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)
      deallocate(DerivReshapes)
      allocate(DerivReshapes(1:numSG))
      Call reshape_ijaa_testOS(numSG,ProductTable,DerivTopReshape,occ_alpha,virt_alpha,DerivNewc,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         do q=1,ReshapedMatrixDim%ijaa(p)%col
           do s=1,ReshapedMatrixDim%ijaa(p)%row
             DerivReshapes(p)%ReshapedMatrix(s,q) = 2*(K2(1,1,2,2)%aa%irrep(p)%block(s,q)*TopReshape(p)%ReshapedMatrix(s,q) + DerivTopReshape(p)%ReshapedMatrix(s,q))
            end do
         end do
       end do

       Call reshape_ijaa_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,virt_alpha,T2deriv,ReshapedMatrixDim,InvPdt)

       deallocate(DerivReshapes)
       deallocate(TopReshape)
       deallocate(DerivTopReshape)

      allocate(DerivReshapes(1:numSG))
      allocate(TopReshape(1:numSG))
      allocate(DerivTopReshape(1:numSG))

      Call reshape_ijbb_testOS(numSG,ProductTable,TopReshape,occ_beta,virt_beta,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)
      deallocate(DerivReshapes)
      allocate(DerivReshapes(1:numSG))
      Call reshape_ijbb_testOS(numSG,ProductTable,DerivTopReshape,occ_beta,virt_beta,DerivNewc,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         do q=1,ReshapedMatrixDim%ijbb(p)%col
           do s=1,ReshapedMatrixDim%ijbb(p)%row
             DerivReshapes(p)%ReshapedMatrix(s,q) = 2*(K2(1,1,2,2)%bb%irrep(p)%block(s,q)*TopReshape(p)%ReshapedMatrix(s,q) + DerivTopReshape(p)%ReshapedMatrix(s,q))
            end do
         end do
       end do

       Call reshape_ijbb_inverseOS(numSG,ProductTable,DerivReshapes,occ_beta,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)

       deallocate(DerivReshapes)
       deallocate(TopReshape)
       deallocate(DerivTopReshape)
        allocate(DerivReshapes(1:numSG))
        allocate(TopReshape(1:numSG))
        allocate(DerivTopReshape(1:numSG))
        Call reshape_ijab_testOS(numSG,ProductTable,TopReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)
       deallocate(DerivReshapes)
       allocate(DerivReshapes(1:numSG))
       Call reshape_ijab_testOS(numSG,ProductTable,DerivTopReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,DerivNewc,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        do q=1,ReshapedMatrixDim%ijab(p)%col
          do s=1,ReshapedMatrixDim%ijab(p)%row
            DerivReshapes(p)%ReshapedMatrix(s,q) = 2*(K2(1,1,2,2)%ab%irrep(p)%block(s,q)*TopReshape(p)%ReshapedMatrix(s,q) + DerivTopReshape(p)%ReshapedMatrix(s,q))
          end do
        end do
      end do

      Call reshape_ijab_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
      deallocate(DerivReshapes)
      deallocate(TopReshape)
      deallocate(DerivTopReshape)
      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
      allocate(TempReshape(1:numSG))
      allocate(TempDerivReshape(1:numSG))





      Call cpu_time(time_begin_transpose)
      Call reshape_ajaaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_ajbbOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      allocate(TempMat1(1:numSG))
      allocate(TempMat2(1:numSG))
      deallocate(DerivReshapes,TempDerivReshape)

      do p=1,numSG
        allocate(TempMat1(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajaa(p)%col,1:ReshapedMatrixDim%ajaa(p)%row))
        allocate(TempMat2(p)%ReshapedMatrix(1:ReshapedMatrixdim%ajbb(p)%row,1:ReshapedMatrixDim%ajbb(p)%col))
      end do

       do p=1,numSG
          TempMat1(p)%ReshapedMatrix = 2*-1*-1*matmul4(K2(2,1,1,2)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
       end do
       do p=1,numSG
          TempMat2(p)%ReshapedMatrix = 2*-1*-1*matmul4(Reshapes(p)%ReshapedMatrix,K2(2,1,1,2)%ab%irrep(p)%block)
       end do

       do p=1,numSG
         do q=1,ReshapedMatrixDim%ajaa(p)%row
           do s=1,ReshapedMatrixDim%ajaa(p)%col
               energy = energy + TempMat1(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
           end do
         end do
       end do


         Call reshape_ajaa_transposederiv_inverseOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,TempMat1)
         Call reshape_ajbb_transposederiv_inverseOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,TempMat2)




         deallocate(Reshapes)
         deallocate(TempReshape)
         Call cpu_time(time_end_transpose)
         time_transpose = time_end_transpose - time_begin_transpose + time_transpose

     allocate(DerivReshapes(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempReshape(1:numSG))
     Call reshape_jka_aaaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_balphaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
     do p=1,numSG
       TempDerivReshape(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,1,2)%aa%irrep(p)%block)
       DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K2(1,1,1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
     end do
     do p=1,numSG
      do q=1,ReshapedMatrixDim%jka_aaa(p)%row
        do s=1,ReshapedMatrixDim%jka_aaa(p)%col
         energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
        end do
      end do
     end do
     Call reshape_jka_aaa_inverseOS(numSG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_balpha_inverseOS(numSG,ProductTable,TempDerivReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
     deallocate(Reshapes)
     deallocate(TempReshape)
     deallocate(TempDerivReshape)
     deallocate(DerivReshapes)


     allocate(DerivReshapes(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempReshape(1:numSG))
     Call reshape_jka_bbbOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_bbetaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
     do p=1,numSG
       TempDerivReshape(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,1,2)%bb%irrep(p)%block)
       DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K2(1,1,1,2)%bb%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
     end do
     do p=1,numSG
      do q=1,ReshapedMatrixDim%jka_bbb(p)%row
        do s=1,ReshapedMatrixDim%jka_bbb(p)%col
         energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
        end do
      end do
     end do
     Call reshape_jka_bbb_inverseOS(numSG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_bbeta_inverseOS(numSG,ProductTable,TempDerivReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
     deallocate(Reshapes)
     deallocate(TempReshape)
     deallocate(TempDerivReshape)
     deallocate(DerivReshapes)





     allocate(DerivReshapes(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempReshape(1:numSG))
     Call reshape_bci_aaaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ialphaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K2(2,2,1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
        TempDerivReshape(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(2,2,1,2)%aa%irrep(p)%block)
      end do
     do p=1,numSG
       do q=1,ReshapedMatrixDim%bci_aaa(p)%row
         do s=1,ReshapedMatrixdim%bci_aaa(p)%col
           energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
         end do
       end do
      end do
      Call reshape_bci_aaa_inverseOS(numSG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_ialpha_inverseOS(numSG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      deallocate(Reshapes)
      deallocate(TempReshape)
      deallocate(TempDerivReshape)
      deallocate(DerivReshapes)


     allocate(DerivReshapes(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempReshape(1:numSG))
     Call reshape_bci_bbbOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibetaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K2(2,2,1,2)%bb%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
        TempDerivReshape(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(2,2,1,2)%bb%irrep(p)%block)
      end do
     do p=1,numSG
       do q=1,ReshapedMatrixDim%bci_bbb(p)%row
         do s=1,ReshapedMatrixdim%bci_bbb(p)%col
           energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
         end do
       end do
      end do
      Call reshape_bci_bbb_inverseOS(numSG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_ibeta_inverseOS(numSG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      deallocate(Reshapes)
      deallocate(TempReshape)
      deallocate(TempDerivReshape)
      deallocate(DerivReshapes)



      allocate(DerivReshapes(1:numSG))
      allocate(TempDerivReshape(1:numSG))
      allocate(Reshapes(1:numSG))
      allocate(TempReshape(1:numSG))
      Call reshape_jka_abbOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_balphaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
     do p=1,numSG
       DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(K2(1,1,1,2)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
       TempDerivReshape(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,1,2)%ab%irrep(p)%block)
     end do
     do p=1,numSG
       do q=1,ReshapedMatrixDim%jka_abb(p)%row
         do s=1,ReshapedMatrixDim%jka_abb(p)%col
           energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
         end do
       end do
     end do
      Call reshape_t1_balpha_inverseOS(numSG,ProductTable,TempDerivReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
      Call reshape_jka_abb_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
      deallocate(Reshapes)
      deallocate(TempReshape)
      deallocate(TempDerivReshape)
      deallocate(DerivReshapes)

      allocate(DerivReshapes(1:numSG))
      allocate(TempDerivReshape(1:numSG))
      allocate(Reshapes(1:numSG))
      allocate(TempReshape(1:numSG))
      Call reshape_jka_abaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_bbetaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
     do p=1,numSG
       DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(K2(1,1,2,1)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
       TempDerivReshape(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,2,1)%ab%irrep(p)%block)
     end do
     do p=1,numSG
       do q=1,ReshapedMatrixDim%jka_aba(p)%row
         do s=1,ReshapedMatrixDim%jka_aba(p)%col
           energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q) * Reshapes(p)%ReshapedMatrix(q,s)
         end do
       end do
     end do
      Call reshape_t1_bbeta_inverseOS(numSG,ProductTable,TempDerivReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
      Call reshape_jka_aba_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
     deallocate(Reshapes)
     deallocate(TempReshape)
     deallocate(TempDerivReshape)
     deallocate(DerivReshapes)


    allocate(DerivReshapes(1:numSG))
    allocate(TempDerivReshape(1:numSG))
    allocate(Reshapes(1:numSG))
    allocate(TempReshape(1:numSG))
    Call reshape_bci_abaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
    Call reshape_t1_ibetaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
    do p=1,numSG
      DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K2(2,2,1,2)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
      TempDerivReshape(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(2,2,1,2)%ab%irrep(p)%block)
    end do
    do p=1,numSG
      do q=1,ReshapedMatrixDim%bci_aba(p)%row
        do s=1,ReshapedMatrixDim%bci_aba(p)%col
          energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
        end do
      end do
    end do
     Call reshape_t1_ibeta_inverseOS(numSG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt,TempDerivReshape)
     Call reshape_bci_aba_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
    deallocate(Reshapes)
    deallocate(TempReshape)
    deallocate(TempDerivReshape)
    deallocate(DerivReshapes)

    allocate(DerivReshapes(1:numSG))
    allocate(TempDerivReshape(1:numSG))
    allocate(Reshapes(1:numSG))
    allocate(TempReshape(1:numSG))
    Call reshape_bci_abbOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
    Call reshape_t1_ialphaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix =1*2*matmul4(K2(2,2,2,1)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
        TempDerivReshape(p)%ReshapedMatrix = 1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(2,2,2,1)%ab%irrep(p)%block)
      end do
     do p=1,numSG
       do q=1,ReshapedMatrixDim%bci_abb(p)%row
         do s=1,ReshapedMatrixDim%bci_abb(p)%col
           energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q) * Reshapes(p)%ReshapedMatrix(q,s)
         end do
       end do
     end do
      Call reshape_t1_ialpha_inverseOS(numSG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      Call reshape_bci_abb_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
      deallocate(Reshapes)
      deallocate(TempReshape)
      deallocate(TempDerivReshape)
      deallocate(DerivReshapes)




       allocate(DerivReshapes(1:numSG))
       allocate(Reshapes(1:numSG))
       Call reshape_t1t1_ialphaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K1(1,1)%aa%irrep(p)%block)
       end do
       do p=1,numSG
         numa = virt_alpha(2,p) - virt_alpha(1,p) + 1
         numi = occ_alpha(2,p) - occ_alpha(1,p) + 1
         do q=1,numi
           do s=1,numa
             energy = energy + 0.5*Reshapes(p)%ReshapedMatrix(s,q)* DerivReshapes(p)%ReshapedMatrix(s,q)
           end do
         end do
       end do
       Call reshape_t1t1_ialpha_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)

       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*-1*matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(1,1)%aa%irrep(p)%block)
       end do
       do p=1,numSG
         numa = virt_alpha(2,p) - virt_alpha(1,p) + 1
         numi = occ_alpha(2,p) - occ_alpha(1,p) + 1
         do q=1,numi
           do s=1,numa
             energy = energy + 0.5*Reshapes(p)%ReshapedMatrix(s,q)* DerivReshapes(p)%ReshapedMatrix(s,q)
           end do
         end do
       end do
       Call reshape_t1t1_ialpha_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)

      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K1(2,2)%aa%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
      end do
      do p=1,numSG
         numa = virt_alpha(2,p) - virt_alpha(1,p) + 1
         numi = occ_alpha(2,p) - occ_alpha(1,p) + 1
          do q=1,numi
           do s=1,numa
             energy = energy + 0.5*DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(s,q)
            end do
         end do
      end do
        Call reshape_t1t1_ialpha_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
       do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K1TwoInts(2,2)%aa%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
      end do
      do p=1,numSG
         numa = virt_alpha(2,p) - virt_alpha(1,p) + 1
         numi = occ_alpha(2,p) - occ_alpha(1,p) + 1
          do q=1,numi
           do s=1,numa
             energy = energy + 0.5*DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(s,q)
            end do
         end do
      end do
      Call reshape_t1t1_ialpha_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)

      deallocate(DerivReshapes)
      deallocate(Reshapes)

       allocate(DerivReshapes(1:numSG))
       allocate(Reshapes(1:numSG))
       Call reshape_t1t1_ibetaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K1(1,1)%bb%irrep(p)%block)
       end do
       do p=1,numSG
         numa = virt_beta(2,p) - virt_beta(1,p) + 1
         numi = occ_beta(2,p) - occ_beta(1,p) + 1
         do q=1,numi
           do s=1,numa
             energy = energy + 0.5*Reshapes(p)%ReshapedMatrix(s,q)*DerivReshapes(p)%ReshapedMatrix(s,q)
           end do
         end do
       end do
       Call reshape_t1t1_ibeta_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*-1*matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(1,1)%bb%irrep(p)%block)
       end do
       do p=1,numSG
         numa = virt_beta(2,p) - virt_beta(1,p) + 1
         numi = occ_beta(2,p) - occ_beta(1,p) + 1
         do q=1,numi
           do s=1,numa
             energy = energy + 0.5*Reshapes(p)%ReshapedMatrix(s,q)* DerivReshapes(p)%ReshapedMatrix(s,q)
           end do
         end do
       end do
       Call reshape_t1t1_ibeta_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K1(2,2)%bb%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
      end do
      do p=1,numSG
         numa = virt_beta(2,p) - virt_beta(1,p) + 1
         numi = occ_beta(2,p) - occ_beta(1,p) + 1
          do q=1,numi
           do s=1,numa
             energy = energy + 0.5*DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(s,q)
            end do
         end do
      end do
        Call reshape_t1t1_ibeta_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
       do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K1TwoInts(2,2)%bb%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
      end do
      do p=1,numSG
         numa = virt_beta(2,p) - virt_beta(1,p) + 1
         numi = occ_beta(2,p) - occ_beta(1,p) + 1
          do q=1,numi
           do s=1,numa
             energy = energy + 0.5*DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(s,q)
            end do
         end do
      end do
      Call reshape_t1t1_ibeta_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
      deallocate(Reshapes)
      deallocate(DerivReshapes)


      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
      T1energy = 0.0
      Call reshape_t1_ibrow_alphaonly_symiOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      deallocate(DerivReshapes)
      allocate(DerivReshapes(1:numsG))
      allocate(TopReshape(1:numSG))
      Call reshape_t1_ibrow_alphaonly_symiOS(numSG,ProductTable,TopReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,Newc_singles,ReshapedMatrixDim,InvPdt,DerivReshapes)
      deallocate(DerivReshapes)
      allocate(DerivReshapes(1:numSG))
      allocate(DerivTopReshape(1:numSG))
      Call reshape_t1_ibrow_alphaonly_symiOS(numSG,ProductTable,DerivTopReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,DerivNewc_singles,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         numa = virt_alpha(2,p) - virt_alpha(1,p) + 1
         numi = occ_alpha(2,p) - occ_alpha(1,p) + 1
         do q=1,numa*numi
           DerivReshapes(p)%ReshapedMatrix(q,1) = (2*K1(1,2)%aa%irrep(p)%block(q,1) + K1TwoInts(1,2)%aa%irrep(p)%block(q,1)) * TopReshape(p)%ReshapedMatrix(1,q) + DerivTopReshape(p)%ReshapedMatrix(1,q)
           T1energy = (2*K1(1,2)%aa%irrep(p)%block(q,1)+K1TwoInts(1,2)%aa%irrep(p)%block(q,1))*Reshapes(p)%ReshapedMatrix(1,q)*TopReshape(p)%ReshapedMatrix(1,q) + T1energy

           energy = energy + (2*K1(1,2)%aa%irrep(p)%block(q,1)+K1TwoInts(1,2)%aa%irrep(p)%block(q,1))*Reshapes(p)%ReshapedMatrix(1,q)*TopReshape(p)%ReshapedMatrix(1,q)
         end do
      end do
      Call reshape_t1_ibrow_alphaonly_symi_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
     deallocate(DerivReshapes)
     deallocate(Reshapes)
     deallocate(TopReshape)
     deallocate(DerivTopReshape)


      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
      Call reshape_t1_ibrow_betaonly_symiOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      deallocate(DerivReshapes)
      allocate(DerivReshapes(1:numSG))
      allocate(TopReshape(1:numSG))
      Call reshape_t1_ibrow_betaonly_symiOS(numSG,ProductTable,TopReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,Newc_singles,ReshapedMatrixDim,InvPdt,DerivReshapes)
      deallocate(DerivReshapes)
      allocate(DerivReshapes(1:numSG))
      allocate(DerivTopReshape(1:numSG))
      Call reshape_t1_ibrow_betaonly_symiOS(numSG,ProductTable,DerivTopReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,DerivNewc_singles,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         numa = virt_beta(2,p) - virt_beta(1,p) + 1
         numi = occ_beta(2,p) - occ_beta(1,p) + 1
         do q=1,numa*numi
           DerivReshapes(p)%ReshapedMatrix(q,1) = (2*K1(1,2)%bb%irrep(p)%block(q,1) + K1TwoInts(1,2)%bb%irrep(p)%block(q,1)) * TopReshape(p)%ReshapedMatrix(1,q) + DerivTopReshape(p)%ReshapedMatrix(1,q)
           T1energy = T1energy + (2*K1(1,2)%bb%irrep(p)%block(q,1)+K1TwoInts(1,2)%bb%irrep(p)%block(q,1))*Reshapes(p)%ReshapedMatrix(1,q)*TopReshape(p)%ReshapedMatrix(1,q)
           energy = energy + (2*K1(1,2)%bb%irrep(p)%block(q,1)+K1TwoInts(1,2)%bb%irrep(p)%block(q,1))*Reshapes(p)%ReshapedMatrix(1,q)*TopReshape(p)%ReshapedMatrix(1,q)
         end do
      end do
      Call reshape_t1_ibrow_betaonly_symi_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
     deallocate(DerivReshapes)
     deallocate(Reshapes)
     deallocate(TopReshape)
     deallocate(DerivTopReshape)


       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_alpha(1,r)
                 c_end   = virt_alpha(2,r)
                 k_begin = occ_alpha(1,s)
                 k_end   = occ_alpha(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     T2deriv%aa%m(a,j)%nsym(r,s)%n(c,k) = T2deriv%aa%m(a,j)%nsym(r,s)%n(c,k) + T2derivT1topfac%aa%m(a,j)%nsym(r,s)%n(c,k)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_beta(1,r)
                 c_end   = virt_beta(2,r)
                 k_begin = occ_beta(1,s)
                 k_end   = occ_beta(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     T2deriv%bb%m(a,j)%nsym(r,s)%n(c,k) =  T2deriv%bb%m(a,j)%nsym(r,s)%n(c,k) + T2derivT1topfac%bb%m(a,j)%nsym(r,s)%n(c,k)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do



       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p);
           a_end   = virt_alpha(2,p);
           j_begin = occ_alpha(1,q);
           j_end   = occ_alpha(2,q);
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_beta(1,r)
                 c_end   = virt_beta(2,r)
                 k_begin = occ_beta(1,s)
                 k_end   = occ_beta(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     T2deriv%ab%m(a,j)%nsym(r,s)%n(c,k) =  T2deriv%ab%m(a,j)%nsym(r,s)%n(c,k) + T2derivT1topfac%ab%m(a,j)%nsym(r,s)%n(c,k)

                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

     allocate(DerivReshapes(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempReshape(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     Call reshape_ajaa_t1OS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibrowOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
     allocate(temp(1:1,1:1))
      do p=1,numSG
       DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K1(1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
       TempDerivReshape(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K1(1,2)%aa%irrep(p)%block)
      end do
      do p=1,numSG
        temp = matmul4(TempReshape(p)%ReshapedMatrix,TempDerivReshape(p)%ReshapedMatrix)
        energy = energy + temp(1,1)
      end do
      Call reshape_ajaa_t1_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
      Call reshape_t1_ibrow_inverseOS(numSG,ProductTable,TempDerivReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)

      deallocate(DerivReshapes)
      deallocate(Reshapes)
      deallocate(TempDerivReshape)
      deallocate(TempReshape)

     allocate(DerivReshapes(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempReshape(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     Call reshape_ajbb_t1OS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibrowOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      do p=1,numSG
       DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K1(1,2)%bb%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
       TempDerivReshape(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K1(1,2)%bb%irrep(p)%block)
      end do
      do p=1,numSG
        temp = matmul4(TempReshape(p)%ReshapedMatrix,TempDerivReshape(p)%ReshapedMatrix)
        energy = energy + temp(1,1)
      end do
      Call reshape_ajbb_t1_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
      Call reshape_t1_ibrow_inverseOS(numSG,ProductTable,TempDerivReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)

      deallocate(DerivReshapes)
      deallocate(Reshapes)
      deallocate(TempDerivReshape)
      deallocate(TempReshape)



      allocate(DerivReshapes(1:numSG))
      allocate(Reshapes(1:numSG))
      allocate(TempDerivReshape(1:numSG))
      allocate(TempReshape(1:numSG))
     Call reshape_ajaa_t1OS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibrowOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = matmul4(K1TwoInts(1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
        TempDerivReshape(p)%ReshapedMatrix = matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(1,2)%aa%irrep(p)%block)
      end do
      do p=1,numSG
        temp = matmul4(TempReshape(p)%ReshapedMatrix,TempDerivReshape(p)%ReshapedMatrix)
        energy = energy + temp(1,1)
      end do
      Call reshape_ajaa_t1_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
      Call reshape_t1_ibrow_inverseOS(numSG,ProductTable,TempDerivReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)

      deallocate(DerivReshapes)
      deallocate(Reshapes)
      deallocate(TempDerivReshape)
      deallocate(TempReshape)

      allocate(DerivReshapes(1:numSG))
      allocate(Reshapes(1:numSG))
      allocate(TempDerivReshape(1:numSG))
      allocate(TempReshape(1:numSG))
     Call reshape_ajbb_t1OS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibrowOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = matmul4(K1TwoInts(1,2)%bb%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
        TempDerivReshape(p)%ReshapedMatrix = matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(1,2)%bb%irrep(p)%block)
      end do
      do p=1,numSG
        temp = matmul4(TempReshape(p)%ReshapedMatrix,TempDerivReshape(p)%ReshapedMatrix)
        energy = energy + temp(1,1)
      end do
      Call reshape_ajbb_t1_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
      Call reshape_t1_ibrow_inverseOS(numSG,ProductTable,TempDerivReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)

      deallocate(DerivReshapes)
      deallocate(Reshapes)
      deallocate(TempDerivReshape)
      deallocate(TempReshape)




     allocate(DerivReshapes(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     allocate(TempReshape(1:numSG))
     Call reshape_t1_ibrow_alphaonlyOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibcol_alphaonlyOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
         p=1
         TempDerivReshape(p)%ReshapedMatrix = -1*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,2,1,2)%aa%irrep(p)%block)
         DerivReshapes(p)%ReshapedMatrix = -1*matmul4(K2(1,2,1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
         do q=1,ReshapedMatrixDim%ajaa(1)%col
             energy = energy + DerivReshapes(1)%ReshapedMatrix(q,1)*Reshapes(1)%ReshapedMatrix(1,q)
         end do
       Call reshape_t1_ibrow_alphaonly_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
       Call reshape_t1_ibcol_alphaonly_inverseOS(numSG,ProductTable,TempDerivReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
      deallocate(DerivReshapes)
      deallocate(Reshapes)
      deallocate(TempDerivReshape)
      deallocate(TempReshape)

     allocate(DerivReshapes(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     allocate(TempReshape(1:numSG))
     Call reshape_t1_ibrow_betaonlyOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibcol_betaonlyOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
         p=1
         TempDerivReshape(p)%ReshapedMatrix = -1*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,2,1,2)%bb%irrep(p)%block)
         DerivReshapes(p)%ReshapedMatrix = -1*matmul4(K2(1,2,1,2)%bb%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
         do q=1,ReshapedMatrixDim%ajbb(1)%col
             energy = energy + DerivReshapes(1)%ReshapedMatrix(q,1)*Reshapes(1)%ReshapedMatrix(1,q)
         end do
       Call reshape_t1_ibrow_betaonly_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
       Call reshape_t1_ibcol_betaonly_inverseOS(numSG,ProductTable,TempDerivReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
      deallocate(DerivReshapes)
      deallocate(Reshapes)
      deallocate(TempDerivReshape)
      deallocate(TempReshape)

     allocate(DerivReshapes(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     allocate(TempReshape(1:numSG))
     Call reshape_t1_ibrow_alphaonlyOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibcol_betaonlyOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
         p = 1
         TempDerivReshape(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(2,1,1,2)%ab%irrep(p)%block)
         DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K2(2,1,1,2)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
         do q=1,ReshapedMatrixDim%ajaa(1)%col
             energy = energy + DerivReshapes(1)%ReshapedMatrix(q,1)*Reshapes(1)%ReshapedMatrix(1,q)
         end do

       Call reshape_t1_ibrow_alphaonly_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
       Call reshape_t1_ibcol_betaonly_inverseOS(numSG,ProductTable,TempDerivReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)

       deallocate(Reshapes)
       deallocate(DerivReshapes)



     call cpu_time(time_total_end)
     time_calcderiv = time_calcderiv + time_total_end - time_total_begin
      end subroutine CalcDerivOS

!> @brief Puts T1/T2 parameters in the format for reading by lbfgs
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine CalcParametersOS(SG,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,InvPdt,T2deriv,DerivVector,Tvector,T1data,T1deriv)
       USE TypeMod;
       Use TimeMod, only : time_calcparameters
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       type(T2), intent(IN) :: T2data, T2deriv
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       double precision, allocatable, dimension(:)  :: DerivVector, Tvector
       type(T1), intent(IN) :: T1data, T1deriv




       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end
       integer :: a,j,c,k
       integer :: row,col,c_begin,c_end,k_begin,k_end,t,v
       integer :: counter
       real :: time_begin, time_end
       real :: temptime_begin,temptime_end

       Call CPU_TIME(time_begin)

       Call CPU_TIME(temptime_begin)
       counter = 1
       do symgp=1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_alpha(1,r)
                 c_end   = virt_alpha(2,r)
                 k_begin = occ_alpha(1,s)
                 k_end   = occ_alpha(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     Tvector(counter) = T2data%aa%m(a,j)%nsym(r,s)%n(c,k)
                     counter = counter + 1
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

       do symgp=1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_beta(1,r)
                 c_end   = virt_beta(2,r)
                 k_begin = occ_beta(1,s)
                 k_end   = occ_beta(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     Tvector(counter) = T2data%bb%m(a,j)%nsym(r,s)%n(c,k)
                     counter = counter + 1
                  end do
                end do
              end do
            end do
          end do
        end do
      end do



       do symgp=1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_beta(1,r)
                 c_end   = virt_beta(2,r)
                 k_begin = occ_beta(1,s)
                 k_end   = occ_beta(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                      Tvector(counter) = T2data%ab%m(a,j)%nsym(r,s)%n(c,k)
                     counter = counter + 1
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

     do symgp=1,SG
        j_begin = occ_alpha(1,symgp)
        j_end   = occ_alpha(2,symgp)
        a_begin = virt_alpha(1,symgp)
        a_end   = virt_alpha(2,symgp)
        do j=j_begin,j_end
         do a=a_begin,a_end
           Tvector(counter) = T1data%a%o(j)%vsym(symgp)%v(a)
           counter = counter + 1
         end do
      end do
    end do

     do symgp=1,SG
        j_begin = occ_beta(1,symgp)
        j_end   = occ_beta(2,symgp)
        a_begin = virt_beta(1,symgp)
        a_end   = virt_beta(2,symgp)
        do j=j_begin,j_end
         do a=a_begin,a_end
           Tvector(counter) = T1data%b%o(j)%vsym(symgp)%v(a)
           counter = counter + 1
         end do
      end do
    end do


Call CPU_TIME(temptime_end)

Call CPU_TIME(temptime_begin)

       counter = 1
       do symgp=1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_alpha(1,r)
                 c_end   = virt_alpha(2,r)
                 k_begin = occ_alpha(1,s)
                 k_end   = occ_alpha(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     DerivVector(counter) = T2deriv%aa%m(a,j)%nsym(r,s)%n(c,k)
                     if(j.lt.k.and.a.lt.c) then
                     end if
                     counter = counter + 1
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

       do symgp=1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_beta(1,r)
                 c_end   = virt_beta(2,r)
                 k_begin = occ_beta(1,s)
                 k_end   = occ_beta(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     DerivVector(counter) = T2deriv%bb%m(a,j)%nsym(r,s)%n(c,k)
                     if(j.lt.k.and.a.lt.c) then
                     end if
                     counter = counter + 1
                  end do
                end do
              end do
            end do
          end do
        end do
      end do



       do symgp=1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_beta(1,r)
                 c_end   = virt_beta(2,r)
                 k_begin = occ_beta(1,s)
                 k_end   = occ_beta(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     DerivVector(counter) = T2deriv%ab%m(a,j)%nsym(r,s)%n(c,k)
                     counter = counter + 1
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

     do symgp=1,SG
        j_begin = occ_alpha(1,symgp)
        j_end   = occ_alpha(2,symgp)
        a_begin = virt_alpha(1,symgp)
        a_end   = virt_alpha(2,symgp)
        do j=j_begin,j_end
         do a=a_begin,a_end
           DerivVector(counter) = T1deriv%a%o(j)%vsym(symgp)%v(a)
           counter = counter + 1
         end do
      end do
     end do

     do symgp=1,SG
        j_begin = occ_beta(1,symgp)
        j_end   = occ_beta(2,symgp)
        a_begin = virt_beta(1,symgp)
        a_end   = virt_beta(2,symgp)
        do j=j_begin,j_end
         do a=a_begin,a_end
           DerivVector(counter) = T1deriv%b%o(j)%vsym(symgp)%v(a)
           counter = counter + 1
         end do
      end do
     end do

Call CPU_TIME(temptime_end)

      Call CPU_TIME(time_end)
      time_calcparameters = time_calcparameters + time_end - time_begin

      end subroutine CalcParametersOS

!> @brief Takes parameters from lbfgs and returns them to storage arrays
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine CalcParametersInverseOS(SG,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,InvPdt,Tvector,T1data)
       USE TypeMod;
       Use TimeMod, only : time_calcparametersinverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       type(T2), intent(INOUT) :: T2data
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)
       double precision, allocatable, dimension(:)  :: Tvector
       type(T1), intent(INOUT) :: T1data

       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end
       integer :: a,j,c,k
       integer :: row,col,c_begin,c_end,k_begin,k_end,t,v
       integer :: counter
       real :: time_begin, time_end
       Call CPU_Time(time_begin)
       counter = 1
       do symgp=1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_alpha(1,r)
                 c_end   = virt_alpha(2,r)
                 k_begin = occ_alpha(1,s)
                 k_end   = occ_alpha(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     T2data%aa%m(a,j)%nsym(r,s)%n(c,k) = Tvector(counter)
                     counter = counter + 1
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

       do symgp=1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_beta(1,r)
                 c_end   = virt_beta(2,r)
                 k_begin = occ_beta(1,s)
                 k_end   = occ_beta(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     T2data%bb%m(a,j)%nsym(r,s)%n(c,k) = Tvector(counter)
                     counter = counter + 1
                  end do
                end do
              end do
            end do
          end do
        end do
      end do



       do symgp=1,SG
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_beta(1,r)
                 c_end   = virt_beta(2,r)
                 k_begin = occ_beta(1,s)
                 k_end   = occ_beta(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     T2data%ab%m(a,j)%nsym(r,s)%n(c,k) = Tvector(counter)
                     counter = counter + 1
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

      do symgp=1,SG
        j_begin = occ_alpha(1,symgp)
        j_end   = occ_alpha(2,symgp)
        a_begin = virt_alpha(1,symgp)
        a_end   = virt_alpha(2,symgp)
        do j=j_begin,j_end
          do a=a_begin,a_end
            T1data%a%o(j)%vsym(symgp)%v(a) = Tvector(counter)
            counter = counter + 1
          end do
        end do
      end do

      do symgp=1,SG
        j_begin = occ_beta(1,symgp)
        j_end   = occ_beta(2,symgp)
        a_begin = virt_beta(1,symgp)
        a_end   = virt_beta(2,symgp)
        do j=j_begin,j_end
          do a=a_begin,a_end
            T1data%b%o(j)%vsym(symgp)%v(a) = Tvector(counter)
            counter = counter + 1
          end do
        end do
      end do




    Call CPU_Time(time_end)
      time_calcparametersinverse = time_end - time_begin + time_calcparametersinverse
      end subroutine CalcParametersInverseOS

!> @brief Symmetrizes derivatives for equivalent parameters for open shell calculations
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine AveDerivOS(InvPdt,numSG,occ_alpha,occ_beta,virt_alpha,virt_beta,ProductTable,Sym_alpha,Sym_beta,T2deriv)
       USE TypeMod
       USE InterfaceMod
       Use TimeMod, only : time_avederiv
       Implicit NONE

       integer :: numSG
       integer, intent(IN), allocatable, dimension(:) :: Sym_alpha,Sym_beta
       type(symmetry), allocatable, dimension(:) :: InvPdt
       type(T2) :: T2deriv
       integer, intent(IN), allocatable, dimension(:,:) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, allocatable, dimension(:,:) :: ProductTable

       integer :: t
       integer :: a,j,i,b,i_begin,i_end,b_begin,b_end,isym,bsym,symtop,j_begin,j_end,jsym
       double precision :: average, total
       real :: time_begin, time_end
       integer :: numocc_alpha,numocc_beta,numvirt_alpha,numvirt_beta

       call cpu_time(time_begin)
      numocc_alpha = 0
      numvirt_alpha = 0
      numocc_beta = 0
      numvirt_beta = 0
      do i=1,numSG
        numocc_alpha = occ_alpha(2,i) - occ_alpha(1,i) + 1 + numocc_alpha
        numvirt_alpha = virt_alpha(2,i) - virt_alpha(1,i) + 1 + numvirt_alpha
        numocc_beta = occ_beta(2,i) - occ_beta(1,i) + 1 + numocc_beta
        numvirt_beta = virt_beta(2,i) - virt_beta(1,i) + 1 + numvirt_beta
      end do

       numvirt_beta = numocc_beta + numvirt_beta
       numvirt_alpha = numocc_alpha + numvirt_alpha


     do i=1,numocc_alpha
       do a=numocc_alpha+1,numvirt_alpha
         symtop = ProductTable(Sym_alpha(a),Sym_alpha(i))
         do t=1,numSG
            bsym = InvPdt(symtop)%upper(t)
            jsym = InvPdt(symtop)%lower(t)
            b_begin = virt_alpha(1,bsym)
            b_end   = virt_alpha(2,bsym)
            j_begin = occ_alpha(1,jsym)
            j_end   = occ_alpha(2,jsym)
            do j=j_begin,j_end
              do b=b_begin,b_end
                 if(i.eq.j.or.a.eq.b) then
                    T2deriv%aa%m(a,i)%nsym(bsym,jsym)%n(b,j) = 0
                    T2deriv%aa%m(b,j)%nsym(Sym_alpha(a),Sym_alpha(i))%n(a,i) = 0
                  end if
                 if(i.lt.j.and.a.lt.b) then
                    total = T2deriv%aa%m(a,i)%nsym(bsym,jsym)%n(b,j) - T2deriv%aa%m(a,j)%nsym(bsym,Sym_alpha(i))%n(b,i) -  T2deriv%aa%m(b,i)%nsym(Sym_alpha(a),jsym)%n(a,j) + T2deriv%aa%m(b,j)%nsym(Sym_alpha(a),Sym_alpha(i))%n(a,i)
                    T2deriv%aa%m(a,i)%nsym(bsym,jsym)%n(b,j) = total*.25000000000000000
                    T2deriv%aa%m(a,j)%nsym(bsym,Sym_alpha(i))%n(b,i) = total*.25000000000000000000000*-1
                    T2deriv%aa%m(b,i)%nsym(Sym_alpha(a),jsym)%n(a,j) = total*.25000000000000000000000*-1
                    T2deriv%aa%m(b,j)%nsym(Sym_alpha(a),Sym_alpha(i))%n(a,i) = total*.250000000000000000000000
                 end if
              end do
           end do
         end do
      end do
    end do



     do i=1,numocc_beta
       do a=numocc_beta+1,numvirt_beta
         symtop = ProductTable(Sym_beta(a),Sym_beta(i))
         do t=1,numSG
            bsym = InvPdt(symtop)%upper(t)
            jsym = InvPdt(symtop)%lower(t)
            b_begin = virt_beta(1,bsym)
            b_end   = virt_beta(2,bsym)
            j_begin = occ_beta(1,jsym)
            j_end   = occ_beta(2,jsym)
            do j=j_begin,j_end
              do b=b_begin,b_end
                 if(i.eq.j.or.a.eq.b) then
                    T2deriv%bb%m(a,i)%nsym(bsym,jsym)%n(b,j) = 0
                    T2deriv%bb%m(b,j)%nsym(Sym_beta(a),Sym_beta(i))%n(a,i) = 0
                  end if
                 if(i.lt.j.and.a.lt.b) then
                    total = T2deriv%bb%m(a,i)%nsym(bsym,jsym)%n(b,j) - T2deriv%bb%m(a,j)%nsym(bsym,Sym_beta(i))%n(b,i) -  T2deriv%bb%m(b,i)%nsym(Sym_beta(a),jsym)%n(a,j) + T2deriv%bb%m(b,j)%nsym(Sym_beta(a),Sym_beta(i))%n(a,i)
                    T2deriv%bb%m(a,i)%nsym(bsym,jsym)%n(b,j) = total*.25000000000000000
                    T2deriv%bb%m(a,j)%nsym(bsym,Sym_beta(i))%n(b,i) = total*.25000000000000000000000*-1
                    T2deriv%bb%m(b,i)%nsym(Sym_beta(a),jsym)%n(a,j) = total*.25000000000000000000000*-1
                    T2deriv%bb%m(b,j)%nsym(Sym_beta(a),Sym_beta(i))%n(a,i) = total*.250000000000000000000000
                 end if
              end do
           end do
         end do
      end do
    end do


call cpu_time(time_end)
   time_avederiv = time_avederiv + time_end - time_begin

       end subroutine AveDerivOS

       subroutine reshape_jka_aaaOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_jka_aaa
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,a_begin,a_end,j_begin,j_end,k_begin,k_end,b_begin,b_end
       integer :: a,j,b,k
       integer :: row,col,t,p,q,u,r,s
       real :: time_begin,time_end
       integer :: numb

       Call CPU_TIME(time_begin)

       do p=1,SG
        numb = virt_alpha(2,p) - virt_alpha(1,p) + 1
        allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%jka_aaa(p)%row,1:ReshapedMatrixDim%jka_aaa(p)%col))
        allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%jka_aaa(p)%col,1:ReshapedMatrixDim%jka_aaa(p)%row))
        DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%jka_aaa(p)%col,1:ReshapedMatrixDim%jka_aaa(p)%row) = 0.D0
       end do
       do symgp=1,SG
         row = 1
         col = 0
         b_begin = virt_alpha(1,symgp)
         b_end   = virt_alpha(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_alpha(1,q)
           k_end   = occ_alpha(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_alpha(1,r)
             a_end   = virt_alpha(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                   col = col + 1
                   row = 1
                   do b=b_begin,b_end
                     Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%aa%m(a,j)%nsym(symgp,q)%n(b,k)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_jka_aaa = time_end - time_begin + time_jka_aaa



      end subroutine reshape_jka_aaaOS


       subroutine reshape_jka_aaa_inverseOS(SG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_jka_aaa_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,a_begin,a_end,j_begin,j_end,k_begin,k_end,b_begin,b_end
       integer :: a,j,b,k
       integer :: row,col,t,p,q,u,r,s
       real :: time_begin,time_end
       integer :: numb

       Call CPU_TIME(time_begin)

       do symgp=1,SG
          row = 0
          col = 1
         b_begin = virt_alpha(1,symgp)
         b_end   = virt_alpha(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_alpha(1,q)
           k_end   = occ_alpha(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_alpha(1,r)
             a_end   = virt_alpha(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                    row = row + 1
                    col = 1
                   do b=b_begin,b_end
                     T2deriv%aa%m(a,j)%nsym(symgp,q)%n(b,k) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%aa%m(a,j)%nsym(symgp,q)%n(b,k)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
          Call CPU_TIME(time_end)
          time_jka_aaa_inverse = time_end - time_begin + time_jka_aaa_inverse



      end subroutine reshape_jka_aaa_inverseOS


       subroutine reshape_t1_balphaOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_t1_b
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,i_begin,i_end,b_begin,b_end,p
       integer :: i,b
       integer :: row,col, numi,numb
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
         numb = virt_alpha(2,p) - virt_alpha(1,p) + 1
         numi = occ_alpha(2,p) - occ_alpha(1,p)   + 1
         allocate(Reshapes(p)%ReshapedMatrix(1:numi,1:numb))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:numb,1:numi))
       end do

       do symgp=1,SG
         col = 0
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         b_begin = virt_alpha(1,symgp)
         b_end   = virt_alpha(2,symgp)
         do b=b_begin,b_end
           col = col + 1
           row = 1
           do i=i_begin,i_end
             Reshapes(symgp)%ReshapedMatrix(row,col) = T1data%a%o(i)%vsym(symgp)%v(b)
             row = row + 1
           end do
         end do
       end do

       Call CPU_TIME(time_end)
       time_t1_b = time_end - time_begin + time_t1_b



      end subroutine reshape_t1_balphaOS


       subroutine reshape_t1_balpha_inverseOS(SG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_t1_b_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,i_begin,i_end,b_begin,b_end,p
       integer :: i,b
       integer :: row,col
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)


       do symgp=1,SG
          row = 0
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         b_begin = virt_alpha(1,symgp)
         b_end   = virt_alpha(2,symgp)
         do b=b_begin,b_end
            row = row + 1
            col = 1
           do i=i_begin,i_end
             T1deriv%a%o(i)%vsym(symgp)%v(b) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T1deriv%a%o(i)%vsym(symgp)%v(b)
             col = col + 1
           end do
         end do
       end do

       Call CPU_TIME(time_end)
       time_t1_b_inverse = time_end - time_begin + time_t1_b_inverse



      end subroutine  reshape_t1_balpha_inverseOS


       subroutine reshape_jka_bbbOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_jka_aaa
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,a_begin,a_end,j_begin,j_end,k_begin,k_end,b_begin,b_end
       integer :: a,j,b,k
       integer :: row,col,t,p,q,u,r,s
       real :: time_begin,time_end
       integer :: numb

       Call CPU_TIME(time_begin)

       do p=1,SG
        numb = virt_alpha(2,p) - virt_alpha(1,p) + 1
        allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%jka_bbb(p)%row,1:ReshapedMatrixDim%jka_bbb(p)%col))
        allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%jka_bbb(p)%col,1:ReshapedMatrixDim%jka_bbb(p)%row))
        DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%jka_bbb(p)%col,1:ReshapedMatrixDim%jka_bbb(p)%row) = 0.D0
       end do
       do symgp=1,SG
         row = 1
         col = 0
         b_begin = virt_beta(1,symgp)
         b_end   = virt_beta(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_beta(1,r)
             a_end   = virt_beta(2,r)
             j_begin = occ_beta(1,s)
             j_end   = occ_beta(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                   col = col + 1
                   row = 1
                   do b=b_begin,b_end
                     Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%bb%m(a,j)%nsym(symgp,q)%n(b,k)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_jka_aaa = time_end - time_begin + time_jka_aaa



      end subroutine reshape_jka_bbbOS


       subroutine reshape_jka_bbb_inverseOS(SG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_jka_aaa_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,a_begin,a_end,j_begin,j_end,k_begin,k_end,b_begin,b_end
       integer :: a,j,b,k
       integer :: row,col,t,p,q,u,r,s
       real :: time_begin,time_end
       integer :: numb

       Call CPU_TIME(time_begin)

       do symgp=1,SG
          row = 0
          col = 1
         b_begin = virt_beta(1,symgp)
         b_end   = virt_beta(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_beta(1,r)
             a_end   = virt_beta(2,r)
             j_begin = occ_beta(1,s)
             j_end   = occ_beta(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                    row = row + 1
                    col = 1
                   do b=b_begin,b_end
                     T2deriv%bb%m(a,j)%nsym(symgp,q)%n(b,k) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%bb%m(a,j)%nsym(symgp,q)%n(b,k)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
          Call CPU_TIME(time_end)
          time_jka_aaa_inverse = time_end - time_begin + time_jka_aaa_inverse



      end subroutine reshape_jka_bbb_inverseOS


       subroutine reshape_t1_bbetaOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_t1_b
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,i_begin,i_end,b_begin,b_end,p
       integer :: i,b
       integer :: row,col, numi,numb
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
         numb = virt_beta(2,p) - virt_beta(1,p) + 1
         numi = occ_beta(2,p) - occ_beta(1,p)   + 1
         allocate(Reshapes(p)%ReshapedMatrix(1:numi,1:numb))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:numb,1:numi))
       end do

       do symgp=1,SG
         col = 0
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         b_begin = virt_beta(1,symgp)
         b_end   = virt_beta(2,symgp)
         do b=b_begin,b_end
           col = col + 1
           row = 1
           do i=i_begin,i_end
             Reshapes(symgp)%ReshapedMatrix(row,col) = T1data%b%o(i)%vsym(symgp)%v(b)
             row = row + 1
           end do
         end do
       end do

       Call CPU_TIME(time_end)
       time_t1_b = time_end - time_begin + time_t1_b



      end subroutine  reshape_t1_bbetaOS


       subroutine reshape_t1_bbeta_inverseOS(SG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_t1_b_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,i_begin,i_end,b_begin,b_end,p
       integer :: i,b
       integer :: row,col
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)


       do symgp=1,SG
          row = 0
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         b_begin = virt_beta(1,symgp)
         b_end   = virt_beta(2,symgp)
         do b=b_begin,b_end
            row = row + 1
            col = 1
           do i=i_begin,i_end
             T1deriv%b%o(i)%vsym(symgp)%v(b) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T1deriv%b%o(i)%vsym(symgp)%v(b)
             col = col + 1
           end do
         end do
       end do

       Call CPU_TIME(time_end)
       time_t1_b_inverse = time_end - time_begin + time_t1_b_inverse



      end subroutine  reshape_t1_bbeta_inverseOS


       subroutine reshape_bci_aaaOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_bci_aaa
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,j_begin,j_end,i_begin,i_end,b_begin,b_end, c_end, c_begin
       integer :: b,c,i,j
       integer :: row,col,t,p,q,u,r,s, numj
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
        numj = occ_alpha(2,p) - occ_alpha(1,p) + 1
        allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%bci_aaa(p)%row,1:ReshapedMatrixDim%bci_aaa(p)%col))
        allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%bci_aaa(p)%col,1:ReshapedMatrixDim%bci_aaa(p)%row))
       end do

       do symgp=1,SG
         row = 1
         col = 0
         j_begin = occ_alpha(1,symgp)
         j_end   = occ_alpha(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_alpha(1,q)
           c_end   = virt_alpha(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_alpha(1,r)
             b_end   = virt_alpha(2,r)
             i_begin = occ_alpha(1,s)
             i_end   = occ_alpha(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=max(c_begin,b+1),c_end
                   col = col + 1
                   row = 1
                   do j=j_begin,j_end
                     Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%aa%m(b,i)%nsym(q,symgp)%n(c,j)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_bci_aaa = time_end - time_begin + time_bci_aaa



      end subroutine  reshape_bci_aaaOS


       subroutine reshape_bci_aaa_inverseOS(SG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_bci_aaa_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,j_begin,j_end,i_begin,i_end,b_begin,b_end, c_end, c_begin
       integer :: b,c,i,j
       integer :: row,col,t,p,q,u,r,s, numj
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do symgp=1,SG
          row = 0
          col = 1
         j_begin = occ_alpha(1,symgp)
         j_end   = occ_alpha(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_alpha(1,q)
           c_end   = virt_alpha(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_alpha(1,r)
             b_end   = virt_alpha(2,r)
             i_begin = occ_alpha(1,s)
             i_end   = occ_alpha(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=max(c_begin,b+1),c_end
                    row = row + 1
                    col = 1
                   do j=j_begin,j_end
                      T2deriv%aa%m(b,i)%nsym(q,symgp)%n(c,j) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%aa%m(b,i)%nsym(q,symgp)%n(c,j)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_bci_aaa_inverse = time_end - time_begin + time_bci_aaa_inverse


      end subroutine reshape_bci_aaa_inverseOS


       subroutine reshape_t1_ialphaOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_t1_i
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,i_begin,i_end,b_begin,b_end,p
       integer :: i,b
       integer :: row,col, numi,numb
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
         numi = occ_alpha(2,p) - occ_alpha(1,p) + 1
         numb = virt_alpha(2,p) - virt_alpha(1,p) + 1
         allocate(Reshapes(p)%ReshapedMatrix(1:numb,1:numi))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:numi,1:numb))
       end do

       do symgp=1,SG
         col = 0
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         b_begin = virt_alpha(1,symgp)
         b_end   = virt_alpha(2,symgp)
         do i=i_begin,i_end
           col = col + 1
           row = 1
           do b=b_begin,b_end
             Reshapes(symgp)%ReshapedMatrix(row,col) = T1data%a%o(i)%vsym(symgp)%v(b)
             row = row + 1
           end do
         end do
       end do
       Call CPU_TIME(time_end)
       time_t1_i = time_end - time_begin + time_t1_i

      end subroutine reshape_t1_ialphaOS


       subroutine reshape_t1_ialpha_inverseOS(SG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_t1_i_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_Beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,i_begin,i_end,b_begin,b_end,p
       integer :: i,b
       integer :: row,col, numi,numb
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)


       do symgp=1,SG
          row = 0
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         b_begin = virt_alpha(1,symgp)
         b_end   = virt_alpha(2,symgp)
         do i=i_begin,i_end
            row = row + 1
            col = 1
           do b=b_begin,b_end
             T1deriv%a%o(i)%vsym(symgp)%v(b) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T1deriv%a%o(i)%vsym(symgp)%v(b)
              col = col + 1
           end do
         end do
       end do

       Call CPU_TIME(time_end)
       time_t1_i_inverse = time_end - time_begin + time_t1_i_inverse



      end subroutine reshape_t1_ialpha_inverseOS


       subroutine reshape_bci_bbbOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_bci_aaa
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,j_begin,j_end,i_begin,i_end,b_begin,b_end, c_end, c_begin
       integer :: b,c,i,j
       integer :: row,col,t,p,q,u,r,s, numj
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
        numj = occ_beta(2,p) - occ_beta(1,p) + 1
        allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%bci_bbb(p)%row,1:ReshapedMatrixDim%bci_bbb(p)%col))
        allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%bci_bbb(p)%col,1:ReshapedMatrixDim%bci_bbb(p)%row))
       end do

       do symgp=1,SG
         row = 1
         col = 0
         j_begin = occ_beta(1,symgp)
         j_end   = occ_beta(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_beta(1,q)
           c_end   = virt_beta(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_beta(1,r)
             b_end   = virt_beta(2,r)
             i_begin = occ_beta(1,s)
             i_end   = occ_beta(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=max(c_begin,b+1),c_end
                   col = col + 1
                   row = 1
                   do j=j_begin,j_end
                     Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%bb%m(b,i)%nsym(q,symgp)%n(c,j)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_bci_aaa = time_end - time_begin + time_bci_aaa



      end subroutine reshape_bci_bbbOS


       subroutine reshape_bci_bbb_inverseOS(SG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_bci_aaa_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,j_begin,j_end,i_begin,i_end,b_begin,b_end, c_end, c_begin
       integer :: b,c,i,j
       integer :: row,col,t,p,q,u,r,s, numj
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do symgp=1,SG
          row = 0
          col = 1
         j_begin = occ_beta(1,symgp)
         j_end   = occ_beta(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_beta(1,q)
           c_end   = virt_beta(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_beta(1,r)
             b_end   = virt_beta(2,r)
             i_begin = occ_beta(1,s)
             i_end   = occ_beta(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=max(c_begin,b+1),c_end
                    row = row + 1
                    col = 1
                   do j=j_begin,j_end
                      T2deriv%bb%m(b,i)%nsym(q,symgp)%n(c,j) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%bb%m(b,i)%nsym(q,symgp)%n(c,j)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_bci_aaa_inverse = time_end - time_begin + time_bci_aaa_inverse



      end subroutine reshape_bci_bbb_inverseOS


       subroutine reshape_t1_ibetaOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_t1_i
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,i_begin,i_end,b_begin,b_end,p
       integer :: i,b
       integer :: row,col, numi,numb
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
         numi = occ_beta(2,p) - occ_beta(1,p) + 1
         numb = virt_beta(2,p) - virt_beta(1,p) + 1
         allocate(Reshapes(p)%ReshapedMatrix(1:numb,1:numi))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:numi,1:numb))
       end do

       do symgp=1,SG
         col = 0
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         b_begin = virt_beta(1,symgp)
         b_end   = virt_beta(2,symgp)
         do i=i_begin,i_end
           col = col + 1
           row = 1
           do b=b_begin,b_end
             Reshapes(symgp)%ReshapedMatrix(row,col) = T1data%b%o(i)%vsym(symgp)%v(b)
             row = row + 1
           end do
         end do
       end do
       Call CPU_TIME(time_end)
       time_t1_i = time_end - time_begin + time_t1_i


      end subroutine reshape_t1_ibetaOS


       subroutine reshape_t1_ibeta_inverseOS(SG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_t1_i_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,i_begin,i_end,b_begin,b_end,p
       integer :: i,b
       integer :: row,col, numi,numb
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)


       do symgp=1,SG
          row = 0
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         b_begin = virt_beta(1,symgp)
         b_end   = virt_beta(2,symgp)
         do i=i_begin,i_end
            row = row + 1
            col = 1
           do b=b_begin,b_end
             T1deriv%b%o(i)%vsym(symgp)%v(b) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T1deriv%b%o(i)%vsym(symgp)%v(b)
              col = col + 1
           end do
         end do
       end do

       Call CPU_TIME(time_end)
       time_t1_i_inverse = time_end - time_begin + time_t1_i_inverse


      end subroutine reshape_t1_ibeta_inverseOS


       subroutine reshape_jka_abbOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_jka_abb
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,a_begin,a_end,j_begin,j_end,k_begin,k_end,b_begin,b_end
       integer :: a,j,b,k
       integer :: row,col,t,p,q,u,r,s
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
        allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%jka_abb(p)%row,1:ReshapedMatrixDim%jka_abb(p)%col))
        allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%jka_abb(p)%col,1:ReshapedMatrixDim%jka_abb(p)%row))
       end do

       do symgp=1,SG
         row = 1
         col = 0
         b_begin = virt_alpha(1,symgp)
         b_end   = virt_alpha(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_beta(1,r)
             a_end   = virt_beta(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do k=k_begin,k_end
                 do a=a_begin,a_end
                   col = col + 1
                   row = 1
                   do b=b_begin,b_end
                     Reshapes(symgp)%ReshapedMatrix(row,col) = 1*T2data%ab%m(b,j)%nsym(r,q)%n(a,k)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_jka_abb = time_end - time_begin + time_jka_abb


      end subroutine reshape_jka_abbOS


       subroutine reshape_jka_abb_inverseOS(SG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_jka_abb_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,a_begin,a_end,j_begin,j_end,k_begin,k_end,b_begin,b_end
       integer :: a,j,b,k
       integer :: row,col,t,p,q,u,r,s
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do symgp=1,SG
          row = 0
          col = 1
         b_begin = virt_alpha(1,symgp)
         b_end   = virt_alpha(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_beta(1,r)
             a_end   = virt_beta(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do k=k_begin,k_end
                 do a=a_begin,a_end
                    row = row + 1
                    col = 1
                   do b=b_begin,b_end
                      T2deriv%ab%m(b,j)%nsym(r,q)%n(a,k) =  1*DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(b,j)%nsym(r,q)%n(a,k)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_jka_abb_inverse = time_end - time_begin + time_jka_abb_inverse



      end subroutine  reshape_jka_abb_inverseOS


       subroutine reshape_jka_abaOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_jka_aba
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,a_begin,a_end,j_begin,j_end,k_begin,k_end,b_begin,b_end
       integer :: a,j,b,k
       integer :: row,col,t,p,q,u,r,s
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
        allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%jka_aba(p)%row,1:ReshapedMatrixDim%jka_aba(p)%col))
        allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%jka_aba(p)%col,1:ReshapedMatrixDim%jka_aba(p)%row))
       end do

       do symgp=1,SG
         row = 1
         col = 0
         b_begin = virt_beta(1,symgp)
         b_end   = virt_beta(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_alpha(1,r)
             a_end   = virt_alpha(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=k_begin,k_end
                   col = col + 1
                   row = 1
                   do b=b_begin,b_end
                     Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%ab%m(a,j)%nsym(symgp,q)%n(b,k)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_jka_aba = time_end - time_begin + time_jka_aba


      end subroutine  reshape_jka_abaOS


       subroutine reshape_jka_aba_inverseOS(SG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_jka_aba_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,a_begin,a_end,j_begin,j_end,k_begin,k_end,b_begin,b_end
       integer :: a,j,b,k
       integer :: row,col,t,p,q,u,r,s
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do symgp=1,SG
          col = 1
          row = 0
         b_begin = virt_beta(1,symgp)
         b_end   = virt_beta(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_alpha(1,r)
             a_end   = virt_alpha(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=k_begin,k_end
                    col = 1
                    row = row + 1
                   do b=b_begin,b_end
                     T2deriv%ab%m(a,j)%nsym(symgp,q)%n(b,k) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(a,j)%nsym(symgp,q)%n(b,k)
                   col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_jka_aba_inverse = time_end - time_begin + time_jka_aba_inverse



      end subroutine  reshape_jka_aba_inverseOS


       subroutine reshape_bci_abaOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_bci_aba
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,j_begin,j_end,i_begin,i_end,b_begin,b_end, c_end, c_begin
       integer :: b,c,i,j
       integer :: row,col,t,p,q,u,r,s
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
        allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%bci_aba(p)%row,1:ReshapedMatrixDim%bci_aba(p)%col))
        allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%bci_aba(p)%col,1:ReshapedMatrixDim%bci_aba(p)%row))
       end do

       do symgp=1,SG
         row = 1
         col = 0
         j_begin = occ_beta(1,symgp)
         j_end   = occ_Beta(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_beta(1,q)
           c_end   = virt_beta(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_alpha(1,r)
             b_end   = virt_alpha(2,r)
             i_begin = occ_alpha(1,s)
             i_end   = occ_alpha(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=c_begin,c_end
                   col = col + 1
                   row = 1
                   do j=j_begin,j_end
                     Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%ab%m(b,i)%nsym(q,symgp)%n(c,j)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_bci_aba = time_end - time_begin + time_bci_aba



      end subroutine reshape_bci_abaOS


       subroutine reshape_bci_aba_inverseOS(SG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_bci_aba_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha, occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,j_begin,j_end,i_begin,i_end,b_begin,b_end, c_end, c_begin
       integer :: b,c,i,j
       integer :: row,col,t,p,q,u,r,s
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)


       do symgp=1,SG
          col = 1
          row = 0
         j_begin = occ_beta(1,symgp)
         j_end   = occ_beta(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_beta(1,q)
           c_end   = virt_beta(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_alpha(1,r)
             b_end   = virt_alpha(2,r)
             i_begin = occ_alpha(1,s)
             i_end   = occ_alpha(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=c_begin,c_end
                    row = row + 1
                    col = 1
                   do j=j_begin,j_end
                    T2deriv%ab%m(b,i)%nsym(q,symgp)%n(c,j) =  DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(b,i)%nsym(q,symgp)%n(c,j)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_bci_aba_inverse = time_end - time_begin + time_bci_aba_inverse



      end subroutine  reshape_bci_aba_inverseOS


       subroutine reshape_bci_abbOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_bci_abb
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,j_begin,j_end,i_begin,i_end,b_begin,b_end, c_end, c_begin
       integer :: b,c,i,j
       integer :: row,col,t,p,q,u,r,s
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
        allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%bci_abb(p)%row,1:ReshapedMatrixDim%bci_abb(p)%col))
        allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%bci_abb(p)%col,1:ReshapedMatrixDim%bci_abb(p)%row))
       end do

       do symgp=1,SG
         row = 1
         col = 0
         j_begin = occ_alpha(1,symgp)
         j_end   = occ_alpha(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_beta(1,q)
           c_end   = virt_beta(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_alpha(1,r)
             b_end   = virt_alpha(2,r)
             i_begin = occ_beta(1,s)
             i_end   = occ_beta(2,s)
             do b=b_begin,b_end
               do i=i_begin,i_end
                 do c=c_begin,c_end
                   col = col + 1
                   row = 1
                   do j=j_begin,j_end
                     Reshapes(symgp)%ReshapedMatrix(row,col) = 1*T2data%ab%m(b,j)%nsym(q,s)%n(c,i)
                     row = row + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_bci_abb = time_end - time_begin + time_bci_abb



      end subroutine reshape_bci_abbOS


       subroutine reshape_bci_abb_inverseOS(SG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_bci_abb_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,j_begin,j_end,i_begin,i_end,b_begin,b_end, c_end, c_begin
       integer :: b,c,i,j
       integer :: row,col,t,p,q,u,r,s
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do symgp=1,SG
          col = 1
          row = 0
         j_begin = occ_alpha(1,symgp)
         j_end   = occ_alpha(2,symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_beta(1,q)
           c_end   = virt_beta(2,q)
           do u=1,SG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_alpha(1,r)
             b_end   = virt_alpha(2,r)
             i_begin = occ_beta(1,s)
             i_end   = occ_beta(2,s)
             do b=b_begin,b_end
               do i=i_begin,i_end
                 do c=c_begin,c_end
                    row = row + 1
                    col = 1
                   do j=j_begin,j_end
                     T2deriv%ab%m(b,j)%nsym(q,s)%n(c,i) = 1*DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(b,j)%nsym(q,s)%n(c,i)
                      col = col + 1
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

          Call CPU_TIME(time_end)
          time_bci_abb_inverse = time_end - time_begin + time_bci_abb_inverse



      end subroutine  reshape_bci_abb_inverseOS


       subroutine reshape_t1t1_ialphaOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_t1t1_i
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,i_begin,i_end,b_begin,b_end,p
       integer :: i,b
       integer :: row,col, numi,numb
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
         numi = occ_alpha(2,p) - occ_alpha(1,p) + 1
         numb = virt_alpha(2,p) - virt_alpha(1,p) + 1
         allocate(Reshapes(p)%ReshapedMatrix(1:numb,1:numi))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:numb,1:numi))
       end do

       do symgp=1,SG
         col = 0
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         b_begin = virt_alpha(1,symgp)
         b_end   = virt_alpha(2,symgp)
         do i=i_begin,i_end
           col = col + 1
           row = 1
           do b=b_begin,b_end
             Reshapes(symgp)%ReshapedMatrix(row,col) = T1data%a%o(i)%vsym(symgp)%v(b)
             row = row + 1
           end do
         end do
       end do

       Call CPU_TIME(time_end)
       time_t1t1_i = time_end - time_begin + time_t1t1_i


      end subroutine  reshape_t1t1_ialphaOS


       subroutine reshape_t1t1_ialpha_inverseOS(SG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_t1t1_i_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,i_begin,i_end,b_begin,b_end,p
       integer :: i,b
       integer :: row,col, numi,numb
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do symgp=1,SG
         col = 0
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         b_begin = virt_alpha(1,symgp)
         b_end   = virt_alpha(2,symgp)
         do i=i_begin,i_end
           col = col + 1
           row = 1
           do b=b_begin,b_end
           T1deriv%a%o(i)%vsym(symgp)%v(b) =  DerivReshapes(symgp)%ReshapedMatrix(row,col) + T1deriv%a%o(i)%vsym(symgp)%v(b)
             row = row + 1
           end do
         end do
       end do

       Call CPU_TIME(time_end)
       time_t1t1_i_inverse = time_end - time_begin + time_t1t1_i_inverse



      end subroutine  reshape_t1t1_ialpha_inverseOS


       subroutine reshape_t1t1_ibetaOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_t1t1_i
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,i_begin,i_end,b_begin,b_end,p
       integer :: i,b
       integer :: row,col, numi,numb
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
         numi = occ_beta(2,p) - occ_beta(1,p) + 1
         numb = virt_beta(2,p) - virt_beta(1,p) + 1
         allocate(Reshapes(p)%ReshapedMatrix(1:numb,1:numi))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:numb,1:numi))
       end do

       do symgp=1,SG
         col = 0
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         b_begin = virt_beta(1,symgp)
         b_end   = virt_beta(2,symgp)
         do i=i_begin,i_end
           col = col + 1
           row = 1
           do b=b_begin,b_end
             Reshapes(symgp)%ReshapedMatrix(row,col) = T1data%b%o(i)%vsym(symgp)%v(b)
             row = row + 1
           end do
         end do
       end do

       Call CPU_TIME(time_end)
       time_t1t1_i = time_end - time_begin + time_t1t1_i


      end subroutine  reshape_t1t1_ibetaOS


       subroutine reshape_t1t1_ibeta_inverseOS(SG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_t1t1_i_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,i_begin,i_end,b_begin,b_end,p
       integer :: i,b
       integer :: row,col, numi,numb
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do symgp=1,SG
         col = 0
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         b_begin = virt_beta(1,symgp)
         b_end   = virt_beta(2,symgp)
         do i=i_begin,i_end
           col = col + 1
           row = 1
           do b=b_begin,b_end
           T1deriv%b%o(i)%vsym(symgp)%v(b) =  DerivReshapes(symgp)%ReshapedMatrix(row,col) + T1deriv%b%o(i)%vsym(symgp)%v(b)
             row = row + 1
           end do
         end do
       end do

       Call CPU_TIME(time_end)
       time_t1t1_i_inverse = time_end - time_begin + time_t1t1_i_inverse



      end subroutine  reshape_t1t1_ibeta_inverseOS


       subroutine reshape_t1_ibrow_alphaonly_symiOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_t1_ibrow_alphaonly
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,i,b,i_begin,i_end, b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: row,col, numa, numi
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end
       integer :: total

       Call CPU_TIME(time_begin)

       total = 0
       do p=1,SG
         numa = virt_alpha(2,p) - virt_alpha(1,p) + 1
         numi = occ_alpha(2,p) - occ_alpha(1,p) + 1
         allocate(Reshapes(p)%ReshapedMatrix(1:1,1:numa*numi))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:numa*numi,1:1))
       end do

       do symgp=1,SG
         col = 1
         row = 1
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         b_begin = virt_alpha(1,symgp)
         b_end   = virt_alpha(2,symgp)
         do i=i_begin,i_end
           do b=b_begin,b_end
             Reshapes(symgp)%ReshapedMatrix(row,col) = T1data%a%o(i)%vsym(symgp)%v(b)
             col = col + 1
             maxrow_SG(symgp) = col
           end do
         end do
       end do


          Call CPU_TIME(time_end)
          time_t1_ibrow_alphaonly = time_end - time_begin + time_t1_ibrow_alphaonly


      end subroutine  reshape_t1_ibrow_alphaonly_symiOS


       subroutine reshape_t1_ibrow_alphaonly_symi_inverseOS(SG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_t1_ibrow_alphaonly_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,i,b,i_begin,i_end, b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: row,col, numa, numi
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do symgp=1,SG
         col = 1
         row = 1
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         b_begin = virt_alpha(1,symgp)
         b_end   = virt_alpha(2,symgp)
         do i=i_begin,i_end
           do b=b_begin,b_end
             T1deriv%a%o(i)%vsym(symgp)%v(b) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T1deriv%a%o(i)%vsym(symgp)%v(b)
             row = row + 1
             maxrow_SG(symgp) = row
           end do
         end do
       end do



          Call CPU_TIME(time_end)
          time_t1_ibrow_alphaonly_inverse = time_end - time_begin + time_t1_ibrow_alphaonly_inverse



      end subroutine  reshape_t1_ibrow_alphaonly_symi_inverseOS


       subroutine reshape_t1_ibrow_betaonly_symiOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_t1_ibrow_alphaonly
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,i,b,i_begin,i_end, b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: row,col, numa, numi
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end
       integer :: total

       Call CPU_TIME(time_begin)

       total = 0
       do p=1,SG
         numa = virt_beta(2,p) - virt_beta(1,p) + 1
         numi = occ_beta(2,p) - occ_beta(1,p) + 1
         allocate(Reshapes(p)%ReshapedMatrix(1:1,1:numa*numi))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:numa*numi,1:1))
       end do

       do symgp=1,SG
         col = 1
         row = 1
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         b_begin = virt_beta(1,symgp)
         b_end   = virt_beta(2,symgp)
         do i=i_begin,i_end
           do b=b_begin,b_end
             Reshapes(symgp)%ReshapedMatrix(row,col) = T1data%b%o(i)%vsym(symgp)%v(b)
             col = col + 1
             maxrow_SG(symgp) = col
           end do
         end do
       end do


          Call CPU_TIME(time_end)
          time_t1_ibrow_alphaonly = time_end - time_begin + time_t1_ibrow_alphaonly



      end subroutine reshape_t1_ibrow_betaonly_symiOS


       subroutine reshape_t1_ibrow_betaonly_symi_inverseOS(SG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_t1_ibrow_alphaonly_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,i,b,i_begin,i_end, b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: row,col, numa, numi
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do symgp=1,SG
         col = 1
         row = 1
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         b_begin = virt_beta(1,symgp)
         b_end   = virt_beta(2,symgp)
         do i=i_begin,i_end
           do b=b_begin,b_end
             T1deriv%b%o(i)%vsym(symgp)%v(b) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T1deriv%b%o(i)%vsym(symgp)%v(b)
             row = row + 1
             maxrow_SG(symgp) = row
           end do
         end do
       end do



          Call CPU_TIME(time_end)
          time_t1_ibrow_alphaonly_inverse = time_end - time_begin + time_t1_ibrow_alphaonly_inverse



      end subroutine  reshape_t1_ibrow_betaonly_symi_inverseOS


       subroutine reshape_ajaa_t1OS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_ajaa_t1
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end,i_begin,i_end,b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: a,j,c,k,b,i
       integer :: row,col,c_begin,c_end,k_begin,k_end,t,v
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
         allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajaa_t1(p)%row,1:ReshapedMatrixDim%ajaa_t1(p)%col))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajaa_t1(p)%col,1:ReshapedMatrixDim%ajaa_t1(p)%row))
       end do

     row = 1
       do symgp=1,SG
         col = 0
           a_begin = virt_alpha(1,symgp)
           a_end   = virt_alpha(2,symgp)
           i_begin = occ_alpha(1,symgp)
           i_end   = occ_alpha(2,symgp)
           do i=i_begin,i_end
             do a=a_begin,a_end
               col = col + 1
               row = 1
               do p=1,SG
                 b_begin = virt_alpha(1,p)
                 b_end   = virt_alpha(2,p)
                 j_begin = occ_alpha(1,p)
                 j_end   = occ_alpha(2,p)
                 do j=j_begin,j_end
                   do b=b_begin,b_end
                    Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%aa%m(a,i)%nsym(p,p)%n(b,j)
                    row = row + 1
               maxrow_SG(symgp) = row
                  end do
                end do
              end do
            end do
          end do
        end do



       do symgp=1,SG
         col = 0
         a_begin = virt_alpha(1,symgp)
         a_end   = virt_alpha(2,symgp)
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         do i=i_begin,i_end
           do a=a_begin,a_end
             col = col + 1
             row = maxrow_SG(symgp)
             do p=1,SG
               b_begin = virt_beta(1,p)
               b_end   = virt_beta(2,p)
               j_begin = occ_beta(1,p)
               j_end   = occ_beta(2,p)
               do j=j_begin,j_end
                 do b=b_begin,b_end
                   Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%ab%m(a,i)%nsym(p,p)%n(b,j)
                       row = row + 1
                      end do
                    end do
                  end do
                end do
              end do
            end do

          Call CPU_TIME(time_end)
          time_ajaa_t1 = time_end - time_begin + time_ajaa_t1



      end subroutine reshape_ajaa_t1OS


       subroutine reshape_ajaa_t1_inverseOS(SG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_ajaa_t1_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end,b_begin,b_end,i_begin,i_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: a,j,c,k,b,i
       integer :: row,col,c_begin,c_end,k_begin,k_end,t,v
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

      col = 1
       do symgp=1,SG
          row = 0
           a_begin = virt_alpha(1,symgp)
           a_end   = virt_alpha(2,symgp)
           i_begin = occ_alpha(1,symgp)
           i_end   = occ_alpha(2,symgp)
           do i=i_begin,i_end
             do a=a_begin,a_end
                row = row + 1
                col = 1
               do p=1,SG
                 b_begin = virt_alpha(1,p)
                 b_end   = virt_alpha(2,p)
                 j_begin = occ_alpha(1,p)
                 j_end   = occ_alpha(2,p)
                 do j=j_begin,j_end
                   do b=b_begin,b_end
                    T2deriv%aa%m(a,i)%nsym(p,p)%n(b,j) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%aa%m(a,i)%nsym(p,p)%n(b,j)
                     col = col + 1
                maxrow_SG(symgp) = col
                  end do
                end do
              end do
            end do
          end do
        end do


       do symgp=1,SG
          row = 0
         a_begin = virt_alpha(1,symgp)
         a_end   = virt_alpha(2,symgp)
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         do i=i_begin,i_end
           do a=a_begin,a_end
              row = row + 1
              col = maxrow_SG(symgp)
             do p=1,SG
               b_begin = virt_beta(1,p)
               b_end   = virt_beta(2,p)
               j_begin = occ_beta(1,p)
               j_end   = occ_beta(2,p)
               do j=j_begin,j_end
                 do b=b_begin,b_end
                   T2deriv%ab%m(a,i)%nsym(p,p)%n(b,j) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(a,i)%nsym(p,p)%n(b,j)
                      col = col + 1
                      end do
                    end do
                  end do
                end do
              end do
            end do

          Call CPU_TIME(time_end)
          time_ajaa_t1_inverse = time_end - time_begin + time_ajaa_t1_inverse



      end subroutine  reshape_ajaa_t1_inverseOS


       subroutine reshape_t1_ibrowOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_t1_ibrow
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,i,b,i_begin,i_end, b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: row,col, numa, numi
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end
       integer :: total

       Call CPU_TIME(time_begin)

       total = 0
       do p=1,SG
         numa = virt_alpha(2,p) - virt_alpha(1,p) + 1
         numi = occ_alpha(2,p) - occ_alpha(1,p) + 1
         total = total + numa*numi
         numa = virt_beta(2,p) - virt_beta(1,p) + 1
         numi = occ_beta(2,p) - occ_beta(1,p) + 1
         total = total + numa*numi
       end do
       do p=1,SG
         allocate(Reshapes(p)%ReshapedMatrix(1:1,1:total))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:total,1:1))
       end do

       do symgp=1,SG
         col = 1
         row = 1
         do p=1,SG
         i_begin = occ_alpha(1,p)
         i_end   = occ_alpha(2,p)
         b_begin = virt_alpha(1,p)
         b_end   = virt_alpha(2,p)
         do i=i_begin,i_end
           do b=b_begin,b_end
             Reshapes(symgp)%ReshapedMatrix(row,col) = T1data%a%o(i)%vsym(p)%v(b)
             col = col + 1
             maxrow_SG(symgp) = col
           end do
         end do
       end do
     end do


       do symgp=1,SG
         col = maxrow_SG(symgp)
          row = 1
         do p=1,SG
         i_begin = occ_beta(1,p)
         i_end   = occ_beta(2,p)
         b_begin = virt_beta(1,p)
         b_end   = virt_beta(2,p)
         do i=i_begin,i_end
           do b=b_begin,b_end
             Reshapes(symgp)%ReshapedMatrix(row,col) = T1data%b%o(i)%vsym(p)%v(b)
              col = col + 1
           end do
         end do
       end do
     end do

          Call CPU_TIME(time_end)
          time_t1_ibrow = time_end - time_begin + time_t1_ibrow



      end subroutine reshape_t1_ibrowOS


       subroutine reshape_t1_ibrow_inverseOS(SG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_t1_ibrow_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,i,b,i_begin,i_end, b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: row,col, numa, numi
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)


       do symgp=1,SG
         col = 1
         row = 1
         do p=1,SG
         i_begin = occ_alpha(1,p)
         i_end   = occ_alpha(2,p)
         b_begin = virt_alpha(1,p)
         b_end   = virt_alpha(2,p)
         do i=i_begin,i_end
           do b=b_begin,b_end
             T1deriv%a%o(i)%vsym(p)%v(b) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T1deriv%a%o(i)%vsym(p)%v(b)
             row = row + 1
             maxrow_SG(symgp) = row
           end do
         end do
       end do
     end do


       do symgp=1,SG
         row = maxrow_SG(symgp)
          col = 1
         do p=1,SG
         i_begin = occ_beta(1,p)
         i_end   = occ_beta(2,p)
         b_begin = virt_beta(1,p)
         b_end   = virt_beta(2,p)
         do i=i_begin,i_end
           do b=b_begin,b_end
             T1deriv%b%o(i)%vsym(p)%v(b) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T1deriv%b%o(i)%vsym(p)%v(b)
             row = row + 1
           end do
         end do
       end do
     end do

          Call CPU_TIME(time_end)
          time_t1_ibrow_inverse = time_end - time_begin + time_t1_ibrow_inverse



      end subroutine reshape_t1_ibrow_inverseOS


       subroutine reshape_ajbb_t1OS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_ajaa_t1
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2), intent(IN) :: T2data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end,i_begin,i_end,b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: a,j,c,k,b,i
       integer :: row,col,c_begin,c_end,k_begin,k_end,t,v
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do p=1,SG
         allocate(Reshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajbb_t1(p)%row,1:ReshapedMatrixDim%ajbb_t1(p)%col))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajbb_t1(p)%col,1:ReshapedMatrixDim%ajbb_t1(p)%row))
       end do

     row = 1
       do symgp=1,SG
         col = 0
           a_begin = virt_beta(1,symgp)
           a_end   = virt_beta(2,symgp)
           i_begin = occ_beta(1,symgp)
           i_end   = occ_beta(2,symgp)
           do i=i_begin,i_end
             do a=a_begin,a_end
               col = col + 1
               row = 1
               do p=1,SG
                 b_begin = virt_alpha(1,p)
                 b_end   = virt_alpha(2,p)
                 j_begin = occ_alpha(1,p)
                 j_end   = occ_alpha(2,p)
                 do j=j_begin,j_end
                   do b=b_begin,b_end
                    Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%ab%m(b,j)%nsym(symgp,symgp)%n(a,i)
                    row = row + 1
               maxrow_SG(symgp) = row
                  end do
                end do
              end do
            end do
          end do
        end do



       do symgp=1,SG
         col = 0
         a_begin = virt_beta(1,symgp)
         a_end   = virt_beta(2,symgp)
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         do i=i_begin,i_end
           do a=a_begin,a_end
             col = col + 1
             row = maxrow_SG(symgp)
             do p=1,SG
               b_begin = virt_beta(1,p)
               b_end   = virt_beta(2,p)
               j_begin = occ_beta(1,p)
               j_end   = occ_beta(2,p)
               do j=j_begin,j_end
                 do b=b_begin,b_end
                   Reshapes(symgp)%ReshapedMatrix(row,col) = T2data%bb%m(a,i)%nsym(p,p)%n(b,j)
                       row = row + 1
                      end do
                    end do
                  end do
                end do
              end do
            end do

          Call CPU_TIME(time_end)
          time_ajaa_t1 = time_end - time_begin + time_ajaa_t1



      end subroutine reshape_ajbb_t1OS


       subroutine reshape_ajbb_t1_inverseOS(SG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_ajaa_t1_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T2), intent(INOUT) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end,b_begin,b_end,i_begin,i_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: a,j,c,k,b,i
       integer :: row,col,c_begin,c_end,k_begin,k_end,t,v
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

      col = 1
       do symgp=1,SG
          row = 0
           a_begin = virt_beta(1,symgp)
           a_end   = virt_beta(2,symgp)
           i_begin = occ_beta(1,symgp)
           i_end   = occ_beta(2,symgp)
           do i=i_begin,i_end
             do a=a_begin,a_end
                row = row + 1
                col = 1
               do p=1,SG
                 b_begin = virt_alpha(1,p)
                 b_end   = virt_alpha(2,p)
                 j_begin = occ_alpha(1,p)
                 j_end   = occ_alpha(2,p)
                 do j=j_begin,j_end
                   do b=b_begin,b_end
                    T2deriv%ab%m(b,j)%nsym(symgp,symgp)%n(a,i) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(b,j)%nsym(symgp,symgp)%n(a,i)
                     col = col + 1
                maxrow_SG(symgp) = col
                  end do
                end do
              end do
            end do
          end do
        end do


       do symgp=1,SG
          row = 0
         a_begin = virt_beta(1,symgp)
         a_end   = virt_beta(2,symgp)
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         do i=i_begin,i_end
           do a=a_begin,a_end
              row = row + 1
              col = maxrow_SG(symgp)
             do p=1,SG
               b_begin = virt_beta(1,p)
               b_end   = virt_beta(2,p)
               j_begin = occ_beta(1,p)
               j_end   = occ_beta(2,p)
               do j=j_begin,j_end
                 do b=b_begin,b_end
                   T2deriv%bb%m(a,i)%nsym(p,p)%n(b,j) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%bb%m(a,i)%nsym(p,p)%n(b,j)
                      col = col + 1
                      end do
                    end do
                  end do
                end do
              end do
            end do

          Call CPU_TIME(time_end)
          time_ajaa_t1_inverse = time_end - time_begin + time_ajaa_t1_inverse



      end subroutine reshape_ajbb_t1_inverseOS


       subroutine reshape_t1_ibcol_alphaonlyOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_t1_ibcol_alphaonly
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,i,b,i_begin,i_end, b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: row,col, numa, numi
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end
       integer :: total
       Call CPU_TIME(time_begin)

       total = 0
       do p=1,SG
         numa = virt_alpha(2,p) - virt_alpha(1,p) + 1
         numi = occ_alpha(2,p) - occ_alpha(1,p) + 1
         total = total + numa*numi
       end do
       do p=1,SG
         allocate(Reshapes(p)%ReshapedMatrix(1:total,1:1))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:1,1:total))
         Reshapes(p)%ReshapedMatrix = 0.0
         DerivReshapes(p)%ReshapedMatrix = 0.0
       end do

       do symgp=1,SG
         col = 1
         row = 1
         do p=1,SG
         i_begin = occ_alpha(1,p)
         i_end   = occ_alpha(2,p)
         b_begin = virt_alpha(1,p)
         b_end   = virt_alpha(2,p)
         do i=i_begin,i_end
           do b=b_begin,b_end
             Reshapes(symgp)%ReshapedMatrix(row,col) = T1data%a%o(i)%vsym(p)%v(b)
             row = row + 1
             maxrow_SG(symgp) = row
           end do
         end do
        end do
       end do



          Call CPU_TIME(time_end)
          time_t1_ibcol_alphaonly = time_end - time_begin + time_t1_ibcol_alphaonly


      end subroutine reshape_t1_ibcol_alphaonlyOS


       subroutine reshape_t1_ibrow_alphaonlyOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_t1_ibrow_alphaonly
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,i,b,i_begin,i_end, b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: row,col, numa, numi
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end
       integer :: total

       Call CPU_TIME(time_begin)

       total = 0
       do p=1,SG
         numa = virt_alpha(2,p) - virt_alpha(1,p) + 1
         numi = occ_alpha(2,p) - occ_alpha(1,p) + 1
         total = total + numa*numi
       end do
       do p=1,SG
         allocate(Reshapes(p)%ReshapedMatrix(1:1,1:total))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:total,1:1))
         DerivReshapes(p)%ReshapedMatrix(1:total,1:1) = 0.0
         Reshapes(p)%ReshapedMatrix(1:1,1:total) = 0.0
       end do

       do symgp=1,SG
         col = 1
         row = 1
         do p=1,SG
         i_begin = occ_alpha(1,p)
         i_end   = occ_alpha(2,p)
         b_begin = virt_alpha(1,p)
         b_end   = virt_alpha(2,p)
         do i=i_begin,i_end
           do b=b_begin,b_end
             Reshapes(symgp)%ReshapedMatrix(row,col) = T1data%a%o(i)%vsym(p)%v(b)
             col = col + 1
             maxrow_SG(symgp) = col
           end do
         end do
        end do
       end do


          Call CPU_TIME(time_end)
          time_t1_ibrow_alphaonly = time_end - time_begin + time_t1_ibrow_alphaonly



      end subroutine  reshape_t1_ibrow_alphaonlyOS


       subroutine reshape_t1_ibcol_alphaonly_inverseOS(SG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_t1_ibcol_alphaonly_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,i,b,i_begin,i_end, b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: row,col, numa, numi
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do symgp=1,SG
         col = 1
         row = 1
         do p=1,SG
         i_begin = occ_alpha(1,p)
         i_end   = occ_alpha(2,p)
         b_begin = virt_alpha(1,p)
         b_end   = virt_alpha(2,p)
         do i=i_begin,i_end
           do b=b_begin,b_end
             T1deriv%a%o(i)%vsym(p)%v(b) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T1deriv%a%o(i)%vsym(p)%v(b)
             col = col + 1
             maxrow_SG(symgp) = col
           end do
         end do
        end do
       end do



          Call CPU_TIME(time_end)
          time_t1_ibcol_alphaonly_inverse = time_end - time_begin + time_t1_ibcol_alphaonly_inverse


      end subroutine  reshape_t1_ibcol_alphaonly_inverseOS


       subroutine reshape_t1_ibrow_alphaonly_inverseOS(SG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_t1_ibrow_alphaonly_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,i,b,i_begin,i_end, b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: row,col, numa, numi
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do symgp=1,SG
         col = 1
         row = 1
         do p=1,SG
         i_begin = occ_alpha(1,p)
         i_end   = occ_alpha(2,p)
         b_begin = virt_alpha(1,p)
         b_end   = virt_alpha(2,p)
         do i=i_begin,i_end
           do b=b_begin,b_end
             T1deriv%a%o(i)%vsym(p)%v(b) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T1deriv%a%o(i)%vsym(p)%v(b)
             row = row + 1
             maxrow_SG(symgp) = row
           end do
         end do
        end do
       end do



          Call CPU_TIME(time_end)
          time_t1_ibrow_alphaonly_inverse = time_end - time_begin + time_t1_ibrow_alphaonly_inverse



      end subroutine reshape_t1_ibrow_alphaonly_inverseOS


       subroutine reshape_t1_ibcol_betaonlyOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_t1_ibcol_alphaonly
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,i,b,i_begin,i_end, b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: row,col, numa, numi
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end
       integer :: total
       Call CPU_TIME(time_begin)

       total = 0
       do p=1,SG
         numa = virt_beta(2,p) - virt_beta(1,p) + 1
         numi = occ_beta(2,p) - occ_beta(1,p) + 1
         total = total + numa*numi
       end do
       do p=1,SG
         allocate(Reshapes(p)%ReshapedMatrix(1:total,1:1))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:1,1:total))
         Reshapes(p)%ReshapedMatrix = 0.0
         DerivReshapes(p)%ReshapedMatrix = 0.0
       end do

       do symgp=1,SG
         col = 1
         row = 1
         do p=1,SG
         i_begin = occ_beta(1,p)
         i_end   = occ_beta(2,p)
         b_begin = virt_beta(1,p)
         b_end   = virt_beta(2,p)
         do i=i_begin,i_end
           do b=b_begin,b_end
             Reshapes(symgp)%ReshapedMatrix(row,col) = T1data%b%o(i)%vsym(p)%v(b)
             row = row + 1
             maxrow_SG(symgp) = row
           end do
         end do
        end do
       end do



          Call CPU_TIME(time_end)
          time_t1_ibcol_alphaonly = time_end - time_begin + time_t1_ibcol_alphaonly



      end subroutine reshape_t1_ibcol_betaonlyOS


       subroutine reshape_t1_ibrow_betaonlyOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_t1_ibrow_alphaonly
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T1), intent(IN) :: T1data
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,i,b,i_begin,i_end, b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: row,col, numa, numi
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end
       integer :: total

       Call CPU_TIME(time_begin)

       total = 0
       do p=1,SG
         numa = virt_beta(2,p) - virt_beta(1,p) + 1
         numi = occ_beta(2,p) - occ_beta(1,p) + 1
         total = total + numa*numi
       end do
       do p=1,SG
         allocate(Reshapes(p)%ReshapedMatrix(1:1,1:total))
         allocate(DerivReshapes(p)%ReshapedMatrix(1:total,1:1))
         DerivReshapes(p)%ReshapedMatrix(1:total,1:1) = 0.0
         Reshapes(p)%ReshapedMatrix(1:1,1:total) = 0.0
       end do

       do symgp=1,SG
         col = 1
         row = 1
         do p=1,SG
         i_begin = occ_beta(1,p)
         i_end   = occ_beta(2,p)
         b_begin = virt_beta(1,p)
         b_end   = virt_beta(2,p)
         do i=i_begin,i_end
           do b=b_begin,b_end
             Reshapes(symgp)%ReshapedMatrix(row,col) = T1data%b%o(i)%vsym(p)%v(b)
             col = col + 1
             maxrow_SG(symgp) = col
           end do
         end do
        end do
       end do


          Call CPU_TIME(time_end)
          time_t1_ibrow_alphaonly = time_end - time_begin + time_t1_ibrow_alphaonly



      end subroutine reshape_t1_ibrow_betaonlyOS


       subroutine reshape_t1_ibcol_betaonly_inverseOS(SG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_t1_ibcol_alphaonly_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,i,b,i_begin,i_end, b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: row,col, numa, numi
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do symgp=1,SG
         col = 1
         row = 1
         do p=1,SG
         i_begin = occ_beta(1,p)
         i_end   = occ_beta(2,p)
         b_begin = virt_beta(1,p)
         b_end   = virt_beta(2,p)
         do i=i_begin,i_end
           do b=b_begin,b_end
             T1deriv%b%o(i)%vsym(p)%v(b) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T1deriv%b%o(i)%vsym(p)%v(b)
             col = col + 1
             maxrow_SG(symgp) = col
           end do
         end do
        end do
       end do



          Call CPU_TIME(time_end)
          time_t1_ibcol_alphaonly_inverse = time_end - time_begin + time_t1_ibcol_alphaonly_inverse



      end subroutine reshape_t1_ibcol_betaonly_inverseOS


       subroutine reshape_t1_ibrow_betaonly_inverseOS(SG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
       USE TypeMod;
       Use TimeMod, only : time_t1_ibrow_alphaonly_inverse
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: DerivReshapes(1:SG)
       type(T1), intent(INOUT) :: T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,i,b,i_begin,i_end, b_begin,b_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: row,col, numa, numi
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)

       do symgp=1,SG
         col = 1
         row = 1
         do p=1,SG
         i_begin = occ_beta(1,p)
         i_end   = occ_beta(2,p)
         b_begin = virt_beta(1,p)
         b_end   = virt_beta(2,p)
         do i=i_begin,i_end
           do b=b_begin,b_end
             T1deriv%b%o(i)%vsym(p)%v(b) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T1deriv%b%o(i)%vsym(p)%v(b)
             row = row + 1
             maxrow_SG(symgp) = row
           end do
         end do
        end do
       end do



          Call CPU_TIME(time_end)
          time_t1_ibrow_alphaonly_inverse = time_end - time_begin + time_t1_ibrow_alphaonly_inverse



      end subroutine  reshape_t1_ibrow_betaonly_inverseOS

! >@brief Calculates the topological factor for open shell calculations
! >@author Christine Schwerdtfeger and David Mazziotti
       subroutine TopFactorOS(TwoInts,T2data,occ_alpha,occ_beta,virt_alpha,virt_beta,numSG,topfac,Newc,InvPdt,ProductTable,DerivNewc,T1data,T1deriv,topsingles,OldIndex_alpha,OldIndex_beta,T2derivT1topfac,Newc_singles,DerivNewc_singles,K1,K1TwoInts)

       Use InterfaceMod
       Use TypeMod
       Use TimeMod, only : time_topfactor
       IMPLICIT None

       type(T2) :: T2data, Newc, DerivNewc,T2derivT1topfac
       type(T1) :: T1data,T1deriv, Newc_singles,DerivNewc_singles
       integer, intent(IN) :: numSG
       integer, intent(IN), dimension(1:2,1:numSG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       real(8), intent(IN), dimension(0:2,0:2) :: topfac(0:2,0:2)
       type(symmetry), dimension(:) :: InvPdt(1:numSG)
       integer, dimension(1:numSG,1:numSG) :: ProductTable
       real(8) :: total
       integer :: i,j,a,b,c,d,k,l,p,q,r,s,symgp,v,t,u
       integer :: i_begin,i_end,j_begin,j_end,a_begin,a_end,b_begin,b_end
       integer :: c_begin,c_end, d_begin,d_end, k_begin,k_end, l_begin,l_end
       integer :: cisym, aksym,kisym
       real(8), dimension(:,:) :: topsingles(0:1,0:1)
       real(8), allocatable, dimension(:,:,:,:) :: TwoInts(:,:,:,:)
       integer, allocatable, dimension(:) :: OldIndex_alpha, OldIndex_beta
       type(spin) :: K1(1:2,1:2), K1TwoInts(1:2,1:2)


       integer :: numocc_alpha,numocc_beta,numvirt_alpha,numvirt_beta
       real(8), allocatable, dimension(:) :: singles_cumi_alpha, singles_cumi_beta
       real(8), allocatable, dimension(:) :: singles_cuma_alpha, singles_cuma_beta
       real(8) :: pizero,singles_pizero, singles_pizero_deriv
       real(8), allocatable, dimension(:) :: cumocc_alpha,cumocc_beta, cumvirt_alpha,cumvirt_beta
       real(8), allocatable, dimension(:,:) :: cumaj_aa, cumaj_ab,cumaj_ba,cumaj_bb
       real(8), allocatable, dimension(:,:) :: cumij_aa, cumij_ab, cumij_bb
       real(8), allocatable, dimension(:,:) :: cumab_aa, cumab_ab, cumab_bb
       real(8), allocatable, dimension(:,:,:) :: pi_ija_aaa, pi_ija_aba,pi_ijb_abb, pi_ija_bbb
       real(8), allocatable, dimension(:,:,:) :: pi_iab_aaa, pi_iab_aab, pi_jab_bab, pi_iab_bbb

       real(8) :: pizero_deriv
       real(8), allocatable, dimension(:) :: cumocc_alpha_deriv, cumvirt_alpha_deriv
       real(8), allocatable, dimension(:) :: cumocc_beta_deriv, cumvirt_beta_deriv
       real(8), allocatable, dimension(:,:) :: cumaj_aa_deriv,cumaj_ab_deriv,cumaj_ba_deriv, cumaj_bb_deriv
       real(8), allocatable, dimension(:,:) :: cumij_aa_deriv, cumij_ab_deriv, cumij_bb_deriv
       real(8), allocatable, dimension(:,:) :: cumab_aa_deriv, cumab_ab_deriv, cumab_bb_deriv
       real(8), allocatable, dimension(:,:,:) :: pi_ija_aaa_deriv, pi_ija_aba_deriv,pi_ijb_abb_deriv, pi_ija_bbb_deriv
       real(8), allocatable, dimension(:,:,:) :: pi_iab_aaa_deriv, pi_iab_aab_deriv, pi_jab_bab_deriv, pi_iab_bbb_deriv
       real(8), allocatable, dimension(:,:) :: singles_cumaj_aa_deriv,singles_cumaj_ab_deriv, singles_cumaj_bb_deriv
       real(8), allocatable, dimension(:) :: singles_cumocc_alpha_deriv, singles_cumocc_beta_deriv, singles_cumvirt_alpha_deriv, singles_cumvirt_beta_deriv

       real(8), allocatable, dimension(:) :: singles_cumi_alpha_deriv, singles_cumi_beta_deriv
       real(8), allocatable, dimension(:) :: singles_cuma_alpha_deriv, singles_cuma_beta_deriv
       real(8), allocatable, dimension(:,:) :: singles_ai_alpha_deriv, singles_ai_beta_deriv

       real :: time_begin,time_end
       real :: timemebegin,timemeend
       real(8) :: topfacme
       integer :: i_gamess,j_gamess,k_gamess,l_gamess,a_gamess,b_gamess,c_gamess,d_gamess
       type(InverseBasis), allocatable, dimension(:) :: InverseBasisK1_alpha,InverseBasisK1_beta
       integer :: counter, ckmap
       double precision :: singlescisd = 1.0
       double precision, dimension(:,:) :: singlesb0_topfac(0:1,0:1)



       singlesb0_topfac(0,0) = topsingles(0,0)
       singlesb0_topfac(1,0) = topsingles(1,0)
       singlesb0_topfac(0,1) = topsingles(0,1)
       singlesb0_topfac(1,1) = topsingles(1,1)

       topfacme = 1

       numocc_alpha = 0
       numocc_beta = 0
       numvirt_alpha = 0
       numvirt_beta = 0

       do p=1,numSG
         numocc_alpha = numocc_alpha + occ_alpha(2,p) - occ_alpha(1,p) + 1
         numocc_beta  = numocc_beta  + occ_beta(2,p) - occ_beta(1,p) + 1
         numvirt_alpha = numvirt_alpha + virt_alpha(2,p) - virt_alpha(1,p) + 1
         numvirt_beta  = numvirt_beta  + virt_beta(2,p) - virt_beta(1,p) + 1
       end do

       Call CPU_TIME(time_begin)
       allocate(cumocc_alpha(1:numocc_alpha))
       allocate(cumvirt_alpha(numocc_alpha+1:numocc_alpha+numvirt_alpha))
       allocate(cumocc_beta(1:numocc_beta))
       allocate(cumvirt_beta(numocc_beta+1:numocc_beta+numvirt_beta))

       allocate(cumaj_aa(1:numocc_alpha,numocc_alpha+1:numvirt_alpha+numocc_alpha))
       allocate(cumaj_ab(1:numocc_beta,numocc_alpha+1:numvirt_alpha+numocc_alpha))
       allocate(cumaj_ba(1:numocc_alpha,numocc_beta+1:numvirt_beta+numocc_beta))
       allocate(cumaj_bb(1:numocc_beta,numocc_beta+1:numvirt_beta+numocc_beta))

       allocate(cumij_aa(1:numocc_alpha,1:numocc_alpha))
       allocate(cumij_ab(1:numocc_alpha,1:numocc_beta))
       allocate(cumij_bb(1:numocc_beta,1:numocc_beta))

       allocate(cumab_aa(numocc_alpha+1:numocc_alpha+numvirt_alpha,numocc_alpha+1:numocc_alpha+numvirt_alpha))
       allocate(cumab_ab(numocc_alpha+1:numocc_alpha+numvirt_alpha,numocc_beta+1:numocc_beta+numvirt_beta))
       allocate(cumab_bb(numocc_beta+1:numocc_beta+numvirt_beta,numocc_beta+1:numocc_beta+numvirt_beta))

       allocate(pi_ija_aaa(1:numocc_alpha,1:numocc_alpha,numocc_alpha+1:numocc_alpha+numvirt_alpha))
       allocate(pi_ija_aba(1:numocc_alpha,1:numocc_beta,numocc_alpha+1:numocc_alpha+numvirt_alpha))
       allocate(pi_ijb_abb(1:numocc_alpha,1:numocc_beta,numocc_beta+1:numocc_beta+numvirt_beta))
       allocate(pi_ija_bbb(1:numocc_beta,1:numocc_beta,numocc_beta+1:numocc_beta+numvirt_beta))

       allocate(pi_iab_aaa(1:numocc_alpha,numocc_alpha+1:numocc_alpha+numvirt_alpha,1+numocc_alpha:numocc_alpha+numvirt_alpha))
       allocate(pi_iab_aab(1:numocc_alpha,numocc_alpha+1:numocc_alpha+numvirt_alpha,1+numocc_beta:numocc_beta+numvirt_beta))
       allocate(pi_jab_bab(1:numocc_beta,numocc_alpha+1:numocc_alpha+numvirt_alpha,1+numocc_beta:numocc_beta+numvirt_beta))
       allocate(pi_iab_bbb(1:numocc_beta,numocc_beta+1:numocc_beta+numvirt_beta,numocc_beta+1:numocc_beta+numvirt_beta))

       allocate(singles_cuma_alpha(numocc_alpha+1:numocc_alpha+numvirt_alpha))
       allocate(singles_cuma_beta(numocc_beta+1:numocc_beta+numvirt_beta))
       allocate(singles_cumi_alpha(1:numocc_alpha))
       allocate(singles_cumi_beta(1:numocc_beta))

       allocate(cumocc_alpha_deriv(1:numocc_alpha))
       allocate(cumocc_beta_deriv(1:numocc_beta))
       allocate(cumvirt_alpha_deriv(numocc_alpha+1:numocc_alpha+numvirt_alpha))
       allocate(cumvirt_beta_deriv(numocc_beta+1:numocc_beta+numvirt_beta))

       allocate(cumaj_aa_deriv(1:numocc_alpha,numocc_alpha+1:numvirt_alpha+numocc_alpha))
       allocate(cumaj_ab_deriv(1:numocc_beta,numocc_alpha+1:numvirt_alpha+numocc_alpha))
       allocate(cumaj_ba_deriv(1:numocc_alpha,numocc_beta+1:numocc_beta+numvirt_beta))
       allocate(cumaj_bb_deriv(1:numocc_beta,numocc_beta+1:numocc_beta+numvirt_beta))

       allocate(cumij_aa_deriv(1:numocc_alpha,1:numocc_alpha))
       allocate(cumij_ab_deriv(1:numocc_alpha,1:numocc_beta))
       allocate(cumij_bb_deriv(1:numocc_beta,1:numocc_beta))

       allocate(cumab_aa_deriv(numocc_alpha+1:numocc_alpha+numvirt_alpha,numocc_alpha+1:numocc_alpha+numvirt_alpha))
       allocate(cumab_ab_deriv(numocc_alpha+1:numocc_alpha+numvirt_alpha,numocc_beta+1:numocc_beta+numvirt_beta))
       allocate(cumab_bb_deriv(numocc_beta+1:numocc_beta+numvirt_beta,numocc_beta+1:numocc_beta+numvirt_beta))

       allocate(pi_ija_aaa_deriv(1:numocc_alpha,1:numocc_alpha,numocc_alpha+1:numocc_alpha+numvirt_alpha))
       allocate(pi_ija_aba_deriv(1:numocc_alpha,1:numocc_beta,numocc_alpha+1:numocc_alpha+numvirt_alpha))
       allocate(pi_ijb_abb_deriv(1:numocc_alpha,1:numocc_beta,numocc_beta+1:numocc_beta+numvirt_beta))
       allocate(pi_ija_bbb_deriv(1:numocc_beta,1:numocc_beta,numocc_beta+1:numocc_beta+numvirt_beta))

       allocate(pi_iab_aaa_deriv(1:numocc_alpha,numocc_alpha+1:numocc_alpha+numvirt_alpha,1+numocc_alpha:numocc_alpha+numvirt_alpha))
       allocate(pi_iab_aab_deriv(1:numocc_alpha,numocc_alpha+1:numocc_alpha+numvirt_alpha,1+numocc_beta:numocc_beta+numvirt_beta))
       allocate(pi_jab_bab_deriv(1:numocc_beta,numocc_alpha+1:numocc_alpha+numvirt_alpha,1+numocc_beta:numocc_beta+numvirt_beta))
       allocate(pi_iab_bbb_deriv(1:numocc_beta,numocc_beta+1:numocc_beta+numvirt_beta,numocc_beta+1:numocc_beta+numvirt_beta))

       allocate(singles_cumaj_aa_deriv(1:numocc_alpha,numocc_alpha+1:numocc_alpha+numvirt_alpha))
       allocate(singles_cumaj_ab_deriv(1:numocc_beta,numocc_alpha+1:numocc_alpha+numvirt_alpha))
       allocate(singles_cumaj_bb_deriv(1:numocc_beta,numocc_beta+1:numocc_beta+numvirt_beta))

       allocate(singles_cumocc_alpha_deriv(1:numocc_alpha))
       allocate(singles_cumocc_beta_deriv(1:numocc_beta))

       allocate(singles_cumvirt_alpha_deriv(numocc_alpha+1:numocc_alpha+numvirt_alpha))
       allocate(singles_cumvirt_beta_deriv(numocc_beta+1:numocc_beta+numvirt_beta))

       allocate(singles_cumi_alpha_deriv(1:numocc_alpha))
       allocate(singles_cumi_beta_deriv(1:numocc_beta))
       allocate(singles_cuma_alpha_deriv(numocc_alpha+1:numocc_alpha+numvirt_alpha))
       allocate(singles_cuma_beta_deriv(numocc_beta+1:numocc_beta+numvirt_beta))
       allocate(singles_ai_alpha_deriv(numocc_alpha+1:numocc_alpha+numvirt_alpha,1:numocc_alpha))
       allocate(singles_ai_beta_deriv(numocc_beta+1:numocc_beta+numvirt_beta,1:numocc_beta))

       cumocc_alpha(1:numocc_alpha) = 0.0
       cumvirt_alpha(numocc_alpha+1:numocc_alpha+numvirt_alpha) = 0.0
       cumocc_beta(1:numocc_beta) = 0.0
       cumvirt_beta(numocc_beta+1:numocc_beta+numvirt_beta) = 0.0
       cumaj_aa(1:numocc_alpha,numocc_alpha+1:numvirt_alpha+numocc_alpha) = 0.0
       cumaj_ab(1:numocc_beta,numocc_alpha+1:numvirt_alpha+numocc_alpha) = 0.0
       cumaj_ba(1:numocc_alpha,numocc_beta+1:numvirt_beta+numocc_beta) = 0.0
       cumaj_bb(1:numocc_beta,numocc_beta+1:numvirt_beta+numocc_beta) = 0.0

       cumij_aa(1:numocc_alpha,1:numocc_alpha) = 0.0
       cumij_ab(1:numocc_alpha,1:numocc_beta) = 0.0
       cumij_bb(1:numocc_beta,1:numocc_beta) = 0.0

       cumab_aa(numocc_alpha+1:numocc_alpha+numvirt_alpha,numocc_alpha+1:numocc_alpha+numvirt_alpha) = 0.0
       cumab_ab(numocc_alpha+1:numocc_alpha+numvirt_alpha,numocc_beta+1:numocc_beta+numvirt_beta) = 0.0
       cumab_bb(numocc_beta+1:numocc_beta+numvirt_beta,numocc_beta+1:numocc_beta+numvirt_beta) = 0.0

       pi_ija_aaa(1:numocc_alpha,1:numocc_alpha,numocc_alpha+1:numocc_alpha+numvirt_alpha) = 0.0
       pi_ija_aba(1:numocc_alpha,1:numocc_beta,numocc_alpha+1:numocc_alpha+numvirt_alpha) = 0.0
       pi_ijb_abb(1:numocc_alpha,1:numocc_beta,numocc_beta+1:numocc_beta+numvirt_beta) = 0.0
       pi_ija_bbb(1:numocc_beta,1:numocc_beta,numocc_beta+1:numocc_beta+numvirt_beta) = 0.0

       pi_iab_aaa(1:numocc_alpha,numocc_alpha+1:numocc_alpha+numvirt_alpha,1+numocc_alpha:numocc_alpha+numvirt_alpha) = 0.0
       pi_iab_aab(1:numocc_alpha,numocc_alpha+1:numocc_alpha+numvirt_alpha,1+numocc_beta:numocc_beta+numvirt_beta) = 0.0
       pi_jab_bab(1:numocc_beta,numocc_alpha+1:numocc_alpha+numvirt_alpha,1+numocc_beta:numocc_beta+numvirt_beta) = 0.0
       pi_iab_bbb(1:numocc_beta,numocc_beta+1:numocc_beta+numvirt_beta,numocc_beta+1:numocc_beta+numvirt_beta) = 0.0

       cumocc_alpha_deriv(1:numocc_alpha) = 0.0
       cumocc_beta_deriv(1:numocc_beta) = 0.0
       cumvirt_alpha_deriv(numocc_alpha+1:numocc_alpha+numvirt_alpha) = 0.0
       cumvirt_beta_deriv(numocc_beta+1:numocc_beta+numvirt_beta) = 0.0

       cumaj_aa_deriv(1:numocc_alpha,numocc_alpha+1:numvirt_alpha+numocc_alpha) = 0.0
       cumaj_ab_deriv(1:numocc_beta,numocc_alpha+1:numvirt_alpha+numocc_alpha) = 0.0
       cumaj_ba_deriv(1:numocc_alpha,numocc_beta+1:numocc_beta+numvirt_beta) = 0.0
       cumaj_bb_deriv(1:numocc_beta,numocc_beta+1:numocc_beta+numvirt_beta) = 0.0

       cumij_aa_deriv(1:numocc_alpha,1:numocc_alpha) = 0.0
       cumij_ab_deriv(1:numocc_alpha,1:numocc_beta) =0.0
       cumij_bb_deriv(1:numocc_beta,1:numocc_beta) = 0.0

       cumab_aa_deriv(numocc_alpha+1:numocc_alpha+numvirt_alpha,numocc_alpha+1:numocc_alpha+numvirt_alpha) = 0.0
       cumab_ab_deriv(numocc_alpha+1:numocc_alpha+numvirt_alpha,numocc_beta+1:numocc_beta+numvirt_beta) = 0.0
       cumab_bb_deriv(numocc_beta+1:numocc_beta+numvirt_beta,numocc_beta+1:numocc_beta+numvirt_beta) = 0.0

       pi_ija_aaa_deriv(1:numocc_alpha,1:numocc_alpha,numocc_alpha+1:numocc_alpha+numvirt_alpha) = 0.0
       pi_ija_aba_deriv(1:numocc_alpha,1:numocc_beta,numocc_alpha+1:numocc_alpha+numvirt_alpha) = 0.0
       pi_ijb_abb_deriv(1:numocc_alpha,1:numocc_beta,numocc_beta+1:numocc_beta+numvirt_beta) = 0.0
       pi_ija_bbb_deriv(1:numocc_beta,1:numocc_beta,numocc_beta+1:numocc_beta+numvirt_beta) = 0.0

       pi_iab_aaa_deriv(1:numocc_alpha,numocc_alpha+1:numocc_alpha+numvirt_alpha,1+numocc_alpha:numocc_alpha+numvirt_alpha) = 0.0
       pi_iab_aab_deriv(1:numocc_alpha,numocc_alpha+1:numocc_alpha+numvirt_alpha,1+numocc_beta:numocc_beta+numvirt_beta) = 0.0
       pi_jab_bab_deriv(1:numocc_beta,numocc_alpha+1:numocc_alpha+numvirt_alpha,1+numocc_beta:numocc_beta+numvirt_beta) = 0.0
       pi_iab_bbb_deriv(1:numocc_beta,numocc_beta+1:numocc_beta+numvirt_beta,numocc_beta+1:numocc_beta+numvirt_beta) = 0.0

       singles_cumaj_aa_deriv(1:numocc_alpha,numocc_alpha+1:numocc_alpha+numvirt_alpha) = 0.0
       singles_cumaj_ab_deriv(1:numocc_beta,numocc_alpha+1:numocc_alpha+numvirt_alpha) = 0.0
       singles_cumaj_bb_deriv(1:numocc_beta,numocc_beta+1:numocc_beta+numvirt_beta) = 0.0

       singles_cumocc_alpha_deriv(1:numocc_alpha) = 0.0
       singles_cumocc_beta_deriv(1:numocc_beta) = 0.0

       singles_cuma_alpha(numocc_alpha+1:numocc_alpha+numvirt_alpha) = 0.0
       singles_cuma_beta(numocc_beta+1:numocc_beta+numvirt_beta) = 0.0
       singles_cumi_alpha(1:numocc_alpha) = 0.0
       singles_cumi_beta(1:numocc_beta) = 0.0



       singles_cumvirt_alpha_deriv(numocc_alpha+1:numocc_alpha+numvirt_alpha) = 0.0
       singles_cumvirt_beta_deriv(numocc_beta+1:numocc_beta+numvirt_beta) = 0.0

       singles_cumi_alpha_deriv(1:numocc_alpha) = 0.0
       singles_cumi_beta_deriv(1:numocc_beta) = 0.0
       singles_cuma_alpha_deriv(numocc_alpha+1:numocc_alpha+numvirt_alpha) = 0.0
       singles_cuma_beta_deriv(numocc_beta+1:numocc_beta+numvirt_beta) = 0.0
       singles_ai_alpha_deriv(numocc_alpha+1:numocc_alpha+numvirt_alpha,1:numocc_alpha) = 0.0
       singles_ai_beta_deriv(numocc_beta+1:numocc_beta+numvirt_beta,1:numocc_beta) = 0.0






      pizero = 0.0
      pizero_deriv = 0.0
      if(topfac(0,0).ne.0.or.singlesb0_topfac(0,0).ne.0) then
       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           k_begin = occ_alpha(1,p)
           k_end   = occ_alpha(2,p)
           c_begin = virt_alpha(1,q)
           c_end   = virt_alpha(2,q)
           do k=k_begin,k_end
             do c=c_begin,c_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 l_begin = occ_beta(1,r)
                 l_end   = occ_beta(2,r)
                 d_begin = virt_beta(1,s)
                 d_end   = virt_beta(2,s)
                 do l=l_begin,l_end
                   do d=d_begin,d_end
                     pizero = pizero +T2data%ab%m(c,k)%nsym(s,r)%n(d,l)**2
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           k_begin = occ_alpha(1,p)
           k_end   = occ_alpha(2,p)
           c_begin = virt_alpha(1,q)
           c_end   = virt_alpha(2,q)
           do k=k_begin,k_end
             do c=c_begin,c_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 l_begin = occ_alpha(1,r)
                 l_end   = occ_alpha(2,r)
                 d_begin = virt_alpha(1,s)
                 d_end   = virt_alpha(2,s)
                 do l=max(k+1,l_begin),l_end
                   do d=max(c+1,d_begin),d_end
                     pizero = pizero + T2data%aa%m(c,k)%nsym(s,r)%n(d,l)**2
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do


       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,p)
           k_end   = occ_beta(2,p)
           c_begin = virt_beta(1,q)
           c_end   = virt_beta(2,q)
           do k=k_begin,k_end
             do c=c_begin,c_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 l_begin = occ_beta(1,r)
                 l_end   = occ_beta(2,r)
                 d_begin = virt_beta(1,s)
                 d_end   = virt_beta(2,s)
                 do l=max(k+1,l_begin),l_end
                   do d=max(c+1,d_begin),d_end
                     pizero = pizero + T2data%bb%m(c,k)%nsym(s,r)%n(d,l)**2
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do


      end if

if(topfac(1,0).ne.0.or.singlesb0_topfac(1,0).ne.0) then
      do symgp=1,numSG
        i_begin = occ_alpha(1,symgp)
        i_end   = occ_alpha(2,symgp)
        do i=i_begin,i_end
          do p=1,numSG
            c_begin = virt_alpha(1,p)
            c_end   = virt_alpha(2,p)
            cisym = ProductTable(symgp,p)
            do c=c_begin,c_end
              do t=1,numSG
                q = InvPdt(cisym)%upper(t)
                r = InvPdt(cisym)%lower(t)
                if(p>r) cycle
                k_begin = occ_alpha(1,q)
                k_end   = occ_alpha(2,q)
                d_begin = virt_alpha(1,r)
                d_end   = virt_alpha(2,r)
                do k=k_begin,k_end
                  do d=max(c+1,d_begin),d_end
                    cumocc_alpha(i) = cumocc_alpha(i) + T2data%aa%m(c,i)%nsym(r,q)%n(d,k)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
      do symgp=1,numSG
        i_begin = occ_alpha(1,symgp)
        i_end   = occ_alpha(2,symgp)
        do i=i_begin,i_end
          do p=1,numSG
            c_begin = virt_alpha(1,p)
            c_end   = virt_alpha(2,p)
            cisym = ProductTable(symgp,p)
            do c=c_begin,c_end
              do t=1,numSG
                q = InvPdt(cisym)%upper(t)
                r = InvPdt(cisym)%lower(t)
                k_begin = occ_beta(1,q)
                k_end   = occ_beta(2,q)
                d_begin = virt_beta(1,r)
                d_end   = virt_beta(2,r)
                do k=k_begin,k_end
                  do d=d_begin,d_end
                    cumocc_alpha(i) = cumocc_alpha(i) + T2data%ab%m(c,i)%nsym(r,q)%n(d,k)**2
                    cumocc_beta(k)  = cumocc_beta(k)  + T2data%ab%m(c,i)%nsym(r,q)%n(d,k)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

      do symgp=1,numSG
        i_begin = occ_beta(1,symgp)
        i_end   = occ_beta(2,symgp)
        do i=i_begin,i_end
          do p=1,numSG
            c_begin = virt_beta(1,p)
            c_end   = virt_beta(2,p)
            cisym = ProductTable(symgp,p)
            do c=c_begin,c_end
              do t=1,numSG
                q = InvPdt(cisym)%upper(t)
                r = InvPdt(cisym)%lower(t)
                if(p>r) cycle
                k_begin = occ_beta(1,q)
                k_end   = occ_beta(2,q)
                d_begin = virt_beta(1,r)
                d_end   = virt_beta(2,r)
                do k=k_begin,k_end
                  do d=max(c+1,d_begin),d_end
                    cumocc_beta(i) = cumocc_beta(i) + T2data%bb%m(c,i)%nsym(r,q)%n(d,k)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do


end if
if(topfac(0,1).ne.0.or.singlesb0_topfac(0,1).ne.0) then
      do symgp=1,numSG
        a_begin = virt_alpha(1,symgp)
        a_end   = virt_alpha(2,symgp)
        do a=a_begin,a_end
          do p=1,numSG
            k_begin = occ_alpha(1,p)
            k_end   = occ_alpha(2,p)
            aksym = ProductTable(symgp,p)
            do k=k_begin,k_end
              do t=1,numSG
                q = InvPdt(aksym)%upper(t)
                r = InvPdt(aksym)%lower(t)
                if(p>q) cycle
                l_begin = occ_alpha(1,q)
                l_end   = occ_alpha(2,q)
                c_begin = virt_alpha(1,r)
                c_end   = virt_alpha(2,r)
                do l=max(k+1,l_begin),l_end
                  do c=c_begin,c_end
                    cumvirt_alpha(a) = cumvirt_alpha(a) + T2data%aa%m(a,k)%nsym(r,q)%n(c,l)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
      do symgp=1,numSG
        a_begin = virt_alpha(1,symgp)
        a_end   = virt_alpha(2,symgp)
        do a=a_begin,a_end
          do p=1,numSG
            k_begin = occ_alpha(1,p)
            k_end   = occ_alpha(2,p)
            aksym = ProductTable(symgp,p)
            do k=k_begin,k_end
              do t=1,numSG
                q = InvPdt(aksym)%upper(t)
                r = InvPdt(aksym)%lower(t)
                l_begin = occ_beta(1,q)
                l_end   = occ_beta(2,q)
                c_begin = virt_beta(1,r)
                c_end   = virt_beta(2,r)
                do l=l_begin,l_end
                  do c=c_begin,c_end
                    cumvirt_alpha(a) = cumvirt_alpha(a) + T2data%ab%m(a,k)%nsym(r,q)%n(c,l)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

      do symgp=1,numSG
        a_begin = virt_beta(1,symgp)
        a_end   = virt_beta(2,symgp)
        do a=a_begin,a_end
          do p=1,numSG
            k_begin = occ_beta(1,p)
            k_end   = occ_beta(2,p)
            aksym = ProductTable(symgp,p)
            do k=k_begin,k_end
              do t=1,numSG
                q = InvPdt(aksym)%upper(t)
                r = InvPdt(aksym)%lower(t)
                if(p>q) cycle
                l_begin = occ_beta(1,q)
                l_end   = occ_beta(2,q)
                c_begin = virt_beta(1,r)
                c_end   = virt_beta(2,r)
                do l=max(k+1,l_begin),l_end
                  do c=c_begin,c_end
                    cumvirt_beta(a) = cumvirt_beta(a) + T2data%bb%m(a,k)%nsym(r,q)%n(c,l)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

      do symgp=1,numSG
        a_begin = virt_beta(1,symgp)
        a_end   = virt_beta(2,symgp)
        do a=a_begin,a_end
          do p=1,numSG
            k_begin = occ_alpha(1,p)
            k_end   = occ_alpha(2,p)
            aksym = ProductTable(symgp,p)
            do k=k_begin,k_end
              do t=1,numSG
                q = InvPdt(aksym)%upper(t)
                r = InvPdt(aksym)%lower(t)
                l_begin = occ_beta(1,q)
                l_end   = occ_beta(2,q)
                c_begin = virt_alpha(1,r)
                c_end   = virt_alpha(2,r)
                do c=c_begin,c_end
                  do l=l_begin,l_end
                    cumvirt_beta(a) = cumvirt_beta(a) + T2data%ab%m(c,k)%nsym(symgp,q)%n(a,l)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

end if
if(topfac(1,1).ne.0.or.singlesb0_topfac(1,1).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          a_begin = virt_alpha(1,p)
          a_end   = virt_alpha(2,p)
          j_begin = occ_alpha(1,q)
          j_end   = occ_alpha(2,q)
          do j=j_begin,j_end
            do a=a_begin,a_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                c_begin = virt_alpha(1,r)
                c_end   = virt_alpha(2,r)
                k_begin = occ_alpha(1,s)
                k_end   = occ_alpha(2,s)
                do k=k_begin,k_end
                  do c=c_begin,c_end
                    cumaj_aa(j,a) = cumaj_aa(j,a) + T2data%aa%m(a,j)%nsym(r,s)%n(c,k)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
      do symgp=1,numSG
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          a_begin = virt_alpha(1,p)
          a_end   = virt_alpha(2,p)
          j_begin = occ_alpha(1,q)
          j_end   = occ_alpha(2,q)
          do j=j_begin,j_end
            do a=a_begin,a_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                c_begin = virt_beta(1,r)
                c_end   = virt_beta(2,r)
                k_begin = occ_beta(1,s)
                k_end   = occ_beta(2,s)
                do k=k_begin,k_end
                  do c=c_begin,c_end
                    cumaj_aa(j,a) = cumaj_aa(j,a) + T2data%ab%m(a,j)%nsym(r,s)%n(c,k)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do


      do symgp=1,numSG
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          a_begin = virt_beta(1,p)
          a_end   = virt_beta(2,p)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          do j=j_begin,j_end
            do a=a_begin,a_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                c_begin = virt_beta(1,r)
                c_end   = virt_beta(2,r)
                k_begin = occ_beta(1,s)
                k_end   = occ_beta(2,s)
                do k=k_begin,k_end
                  do c=c_begin,c_end
                    cumaj_bb(j,a) = cumaj_bb(j,a) + T2data%bb%m(a,j)%nsym(r,s)%n(c,k)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

      do symgp=1,numSG
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          c_begin = virt_alpha(1,p)
          c_end   = virt_alpha(2,p)
          k_begin = occ_alpha(1,q)
          k_end   = occ_alpha(2,q)
          do k=k_begin,k_end
            do c=c_begin,c_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                a_begin = virt_beta(1,r)
                a_end   = virt_beta(2,r)
                j_begin = occ_beta(1,s)
                j_end   = occ_beta(2,s)
                do j=j_begin,j_end
                  do a=a_begin,a_end
                    cumaj_bb(j,a) = cumaj_bb(j,a) + T2data%ab%m(c,k)%nsym(r,s)%n(a,j)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do


end if
if(topfac(1,1).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          a_begin = virt_beta(1,p)
          a_end   = virt_beta(2,p)
          j_begin = occ_alpha(1,q)
          j_end   = occ_alpha(2,q)
          do j=j_begin,j_end
            do a=a_begin,a_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                c_begin = virt_alpha(1,r)
                c_end   = virt_alpha(2,r)
                k_begin = occ_beta(1,s)
                k_end   = occ_beta(2,s)
                do c=c_begin,c_end
                  do k=k_begin,k_end
                    cumaj_ba(j,a) = cumaj_ba(j,a) + T2data%ab%m(c,j)%nsym(p,s)%n(a,k)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

      do symgp=1,numSG
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          a_begin = virt_alpha(1,p)
          a_end   = virt_alpha(2,p)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          do a=a_begin,a_end
            do j=j_begin,j_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                c_begin = virt_beta(1,r)
                c_end   = virt_beta(2,r)
                k_begin = occ_alpha(1,s)
                k_end   = occ_alpha(2,s)
                do k=k_begin,k_end
                  do c=c_begin,c_end
                    cumaj_ab(j,a) = cumaj_ab(j,a) + T2data%ab%m(a,k)%nsym(r,q)%n(c,j)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do


end if
if(topfac(2,0).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          if(p.gt.q) cycle
          i_begin = occ_alpha(1,p)
          i_end   = occ_alpha(2,p)
          j_begin = occ_alpha(1,q)
          j_end   = occ_alpha(2,q)
          do i=i_begin,i_end
            do j=max(i+1,j_begin),j_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                if(r.gt.s) cycle
                a_begin = virt_alpha(1,r)
                a_end   = virt_alpha(2,r)
                b_begin = virt_alpha(1,s)
                b_end   = virt_alpha(2,s)
                do a=a_begin,a_end
                  do b=max(a+1,b_begin),b_end
                    cumij_aa(i,j) = cumij_aa(i,j) + T2data%aa%m(a,i)%nsym(s,q)%n(b,j)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          if(p.gt.q) cycle
          i_begin = occ_beta(1,p)
          i_end   = occ_beta(2,p)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          do i=i_begin,i_end
            do j=max(i+1,j_begin),j_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                if(r.gt.s) cycle
                a_begin = virt_beta(1,r)
                a_end   = virt_beta(2,r)
                b_begin = virt_beta(1,s)
                b_end   = virt_beta(2,s)
                do a=a_begin,a_end
                  do b=max(a+1,b_begin),b_end
                    cumij_bb(i,j) = cumij_bb(i,j) + T2data%bb%m(a,i)%nsym(s,q)%n(b,j)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do



end if
if(topfac(2,0).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          i_begin = occ_alpha(1,p)
          i_end   = occ_alpha(2,p)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                a_begin = virt_alpha(1,r)
                a_end   = virt_alpha(2,r)
                b_begin = virt_beta(1,s)
                b_end   = virt_beta(2,s)
                do a=a_begin,a_end
                  do b=b_begin,b_end
                    cumij_ab(i,j) = cumij_ab(i,j) + T2data%ab%m(a,i)%nsym(s,q)%n(b,j)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(0,2).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          if(p.gt.q) cycle
          a_begin = virt_alpha(1,p)
          a_end   = virt_alpha(2,p)
          b_begin = virt_alpha(1,q)
          b_end   = virt_alpha(2,q)
          do a=a_begin,a_end
            do b=max(a+1,b_begin),b_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                if(r.gt.s) cycle
                i_begin = occ_alpha(1,r)
                i_end   = occ_alpha(2,r)
                j_begin = occ_alpha(1,s)
                j_end   = occ_alpha(2,s)
                do i=i_begin,i_end
                  do j=max(i+1,j_begin),j_end
                    cumab_aa(a,b) = cumab_aa(a,b) + T2data%aa%m(a,i)%nsym(q,s)%n(b,j)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          if(p.gt.q) cycle
          a_begin = virt_beta(1,p)
          a_end   = virt_beta(2,p)
          b_begin = virt_beta(1,q)
          b_end   = virt_beta(2,q)
          do a=a_begin,a_end
            do b=max(a+1,b_begin),b_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                if(r.gt.s) cycle
                i_begin = occ_beta(1,r)
                i_end   = occ_beta(2,r)
                j_begin = occ_beta(1,s)
                j_end   = occ_beta(2,s)
                do i=i_begin,i_end
                  do j=max(i+1,j_begin),j_end
                    cumab_bb(a,b) = cumab_bb(a,b) + T2data%bb%m(a,i)%nsym(q,s)%n(b,j)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(0,2).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          a_begin = virt_alpha(1,p)
          a_end   = virt_alpha(2,p)
          b_begin = virt_beta(1,q)
          b_end   = virt_beta(2,q)
          do a=a_begin,a_end
            do b=b_begin,b_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                i_begin = occ_alpha(1,r)
                i_end   = occ_alpha(2,r)
                j_begin = occ_beta(1,s)
                j_end   = occ_beta(2,s)
                do i=i_begin,i_end
                  do j=j_begin,j_end
                    cumab_ab(a,b) = cumab_ab(a,b) + T2data%ab%m(a,i)%nsym(q,s)%n(b,j)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(2,1).ne.0) then
      do symgp=1,numSG
        c_begin = virt_alpha(1,symgp)
        c_end   = virt_alpha(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          j_begin = occ_alpha(1,q)
          j_end   = occ_alpha(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt_alpha(1,r)
            a_end   = virt_alpha(2,r)
            i_begin = occ_alpha(1,s)
            i_end   = occ_alpha(2,s)
            do i=i_begin,i_end
              do a=a_begin,a_end
                do j=max(i+1,j_begin),j_end
                  do c=c_begin,c_end
                    pi_ija_aaa(i,j,a) = pi_ija_aaa(i,j,a) + T2data%aa%m(a,i)%nsym(symgp,q)%n(c,j)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

      do symgp=1,numSG
        c_begin = virt_beta(1,symgp)
        c_end   = virt_beta(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt_beta(1,r)
            a_end   = virt_beta(2,r)
            i_begin = occ_beta(1,s)
            i_end   = occ_beta(2,s)
            do i=i_begin,i_end
              do a=a_begin,a_end
                do j=max(i+1,j_begin),j_end
                  do c=c_begin,c_end
                    pi_ija_bbb(i,j,a) = pi_ija_bbb(i,j,a) + T2data%bb%m(a,i)%nsym(symgp,q)%n(c,j)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do


end if
if(topfac(2,1).ne.0) then
      do symgp=1,numSG
        c_begin = virt_beta(1,symgp)
        c_end   = virt_beta(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt_alpha(1,r)
            a_end   = virt_alpha(2,r)
            i_begin = occ_alpha(1,s)
            i_end   = occ_alpha(2,s)
            do i=i_begin,i_end
              do a=a_begin,a_end
                do j=j_begin,j_end
                  do c=c_begin,c_end
                    pi_ija_aba(i,j,a) = pi_ija_aba(i,j,a) + T2data%ab%m(a,i)%nsym(symgp,q)%n(c,j)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(2,1).ne.0) then
      do symgp=1,numSG
        c_begin = virt_alpha(1,symgp)
        c_end   = virt_alpha(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            b_begin = virt_beta(1,r)
            b_end   = virt_beta(2,r)
            i_begin = occ_alpha(1,s)
            i_end   = occ_alpha(2,s)
            do i=i_begin,i_end
              do b=b_begin,b_end
                do j=j_begin,j_end
                  do c=c_begin,c_end
                    pi_ijb_abb(i,j,b) = pi_ijb_abb(i,j,b) + T2data%ab%m(c,i)%nsym(r,q)%n(b,j)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if

if(topfac(1,2).ne.0) then
      do symgp=1,numSG
        k_begin = occ_alpha(1,symgp)
        k_end   = occ_alpha(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          b_begin = virt_alpha(1,q)
          b_end   = virt_alpha(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt_alpha(1,r)
            a_end   = virt_alpha(2,r)
            i_begin = occ_alpha(1,s)
            i_end   = occ_alpha(2,s)
            do i=i_begin,i_end
              do a=a_begin,a_end
                do b=max(a+1,b_begin),b_end
                  do k=k_begin,k_end
                    pi_iab_aaa(i,a,b) = pi_iab_aaa(i,a,b) + T2data%aa%m(a,i)%nsym(q,symgp)%n(b,k)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

      do symgp=1,numSG
        k_begin = occ_beta(1,symgp)
        k_end   = occ_beta(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          b_begin = virt_beta(1,q)
          b_end   = virt_beta(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt_beta(1,r)
            a_end   = virt_beta(2,r)
            i_begin = occ_beta(1,s)
            i_end   = occ_beta(2,s)
            do i=i_begin,i_end
              do a=a_begin,a_end
                do b=max(a+1,b_begin),b_end
                  do k=k_begin,k_end
                    pi_iab_bbb(i,a,b) = pi_iab_bbb(i,a,b) + T2data%bb%m(a,i)%nsym(q,symgp)%n(b,k)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

end if
if(topfac(1,2).ne.0) then
      do symgp=1,numSG
        k_begin = occ_beta(1,symgp)
        k_end   = occ_beta(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          b_begin = virt_beta(1,q)
          b_end   = virt_beta(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt_alpha(1,r)
            a_end   = virt_alpha(2,r)
            i_begin = occ_alpha(1,s)
            i_end   = occ_alpha(2,s)
            do i=i_begin,i_end
              do a=a_begin,a_end
                do b=b_begin,b_end
                  do k=k_begin,k_end
                    pi_iab_aab(i,a,b) = pi_iab_aab(i,a,b) + T2data%ab%m(a,i)%nsym(q,symgp)%n(b,k)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(1,2).ne.0) then
      do symgp=1,numSG
        k_begin = occ_alpha(1,symgp)
        k_end   = occ_alpha(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          b_begin = virt_beta(1,q)
          b_end   = virt_beta(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt_alpha(1,r)
            a_end   = virt_alpha(2,r)
            j_begin = occ_beta(1,s)
            j_end   = occ_beta(2,s)
            do j=j_begin,j_end
              do a=a_begin,a_end
                do b=b_begin,b_end
                  do k=k_begin,k_end
                    pi_jab_bab(j,a,b) = pi_jab_bab(j,a,b) + T2data%ab%m(a,k)%nsym(q,s)%n(b,j)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if

singles_pizero = 0.0
if(topsingles(0,0).ne.0.or.singlesb0_topfac(0,0).ne.0) then
       do symgp=1,numSG
         k_begin = occ_alpha(1,symgp)
         k_end   = occ_alpha(2,symgp)
         c_begin = virt_alpha(1,symgp)
         c_end   = virt_alpha(2,symgp)
         do k=k_begin,k_end
           do c=c_begin,c_end
             singles_pizero= singles_pizero + T1data%a%o(k)%vsym(symgp)%v(c)**2
           end do
         end do
       end do

       do symgp=1,numSG
         k_begin = occ_beta(1,symgp)
         k_end   = occ_beta(2,symgp)
         c_begin = virt_beta(1,symgp)
         c_end   = virt_beta(2,symgp)
         do k=k_begin,k_end
           do c=c_begin,c_end
             singles_pizero= singles_pizero + T1data%b%o(k)%vsym(symgp)%v(c)**2
           end do
         end do
       end do

end if
if(topsingles(1,0).ne.0.or.singlesb0_topfac(1,0).ne.0) then
       do symgp=1,numSG
         k_begin = occ_alpha(1,symgp)
         k_end   = occ_alpha(2,symgp)
         c_begin = virt_alpha(1,symgp)
         c_end   = virt_alpha(2,symgp)
         do k=k_begin,k_end
           do c=c_begin,c_end
             singles_cumi_alpha(k) = singles_cumi_alpha(k) + T1data%a%o(k)%vsym(symgp)%v(c)**2
           end do
         end do
      end do

       do symgp=1,numSG
         k_begin = occ_beta(1,symgp)
         k_end   = occ_beta(2,symgp)
         c_begin = virt_beta(1,symgp)
         c_end   = virt_beta(2,symgp)
         do k=k_begin,k_end
           do c=c_begin,c_end
             singles_cumi_beta(k) = singles_cumi_beta(k) + T1data%b%o(k)%vsym(symgp)%v(c)**2
           end do
         end do
      end do

end if

if(topsingles(0,1).ne.0.or.singlesb0_topfac(0,1).ne.0) then
      do symgp=1,numSG
        c_begin = virt_alpha(1,symgp)
        c_end   = virt_alpha(2,symgp)
        k_begin = occ_alpha(1,symgp)
        k_end   = occ_alpha(2,symgp)
        do c=c_begin,c_end
          do k=k_begin,k_end
            singles_cuma_alpha(c) = singles_cuma_alpha(c) + T1data%a%o(k)%vsym(symgp)%v(c)**2
          end do
        end do
      end do

      do symgp=1,numSG
        c_begin = virt_beta(1,symgp)
        c_end   = virt_beta(2,symgp)
        k_begin = occ_beta(1,symgp)
        k_end   = occ_beta(2,symgp)
        do c=c_begin,c_end
          do k=k_begin,k_end
            singles_cuma_beta(c) = singles_cuma_beta(c) + T1data%b%o(k)%vsym(symgp)%v(c)**2
          end do
        end do
      end do
end if


       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           a_begin = virt_alpha(1,q)
           a_end   = virt_alpha(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 j_begin = occ_beta(1,r)
                 j_end   = occ_beta(2,r)
                 b_begin = virt_beta(1,s)
                 b_end   = virt_beta(2,s)
                 do j=j_begin,j_end
                   do b=b_begin,b_end
                     Newc%ab%m(a,i)%nsym(s,r)%n(b,j) = topfac(0,0)*pizero +topfac(1,0)*(cumocc_alpha(i)+cumocc_beta(j)) + topfac(0,1)*(cumvirt_alpha(a) + cumvirt_beta(b)) + topfac(1,1)*(cumaj_bb(j,b)+cumaj_ab(j,a) + cumaj_ba(i,b)+cumaj_aa(i,a)) +topfac(2,0)*cumij_ab(i,j) + topfac(0,2)*cumab_ab(a,b) + topfac(2,1)*(pi_ija_aba(i,j,a) + pi_ijb_abb(i,j,b))  + topfac(1,2)*(pi_iab_aab(i,a,b) + pi_jab_bab(j,a,b)) + topfac(2,2)*T2data%ab%m(a,i)%nsym(s,r)%n(b,j)**2 + topsingles(0,0)*singles_pizero  + topsingles(1,0)*(singles_cumi_alpha(i) + singles_cumi_beta(j)) + topsingles(0,1)*(singles_cuma_alpha(a) + singles_cuma_beta(b))
                     if(r.eq.s) then
                       Newc%ab%m(a,i)%nsym(s,r)%n(b,j) =  Newc%ab%m(a,i)%nsym(s,r)%n(b,j) + topsingles(1,1)*T1data%b%o(j)%vsym(s)%v(b)**2
                     end if
                     if(p.eq.q) then
                       Newc%ab%m(a,i)%nsym(s,r)%n(b,j) =  Newc%ab%m(a,i)%nsym(s,r)%n(b,j) + topsingles(1,1)*T1data%a%o(i)%vsym(q)%v(a)**2
                     end if
                        Newc%ab%m(a,i)%nsym(s,r)%n(b,j) = sqrt(abs(1.0-Newc%ab%m(a,i)%nsym(s,r)%n(b,j)))
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           a_begin = virt_alpha(1,q)
           a_end   = virt_alpha(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 j_begin = occ_alpha(1,r)
                 j_end   = occ_alpha(2,r)
                 b_begin = virt_alpha(1,s)
                 b_end   = virt_alpha(2,s)
                 do j=max(i+1,j_begin),j_end
                   do b=max(a+1,b_begin),b_end
                     Newc%aa%m(a,i)%nsym(s,r)%n(b,j) = topfac(0,0)*pizero +topfac(1,0)*(cumocc_alpha(i)+cumocc_alpha(j)) + topfac(0,1)*(cumvirt_alpha(a) + cumvirt_alpha(b)) + topfac(1,1)*(cumaj_aa(j,b) + cumaj_aa(j,a) + cumaj_aa(i,b) + cumaj_aa(i,a)) + topfac(2,0)*cumij_aa(i,j) + topfac(0,2)*cumab_aa(a,b) + topfac(2,1)*(pi_ija_aaa(i,j,a) + pi_ija_aaa(i,j,b))  + topfac(1,2)*(pi_iab_aaa(i,a,b) + pi_iab_aaa(j,a,b)) + topfac(2,2)*T2data%aa%m(a,i)%nsym(s,r)%n(b,j)**2 +topsingles(0,0)*singles_pizero + topsingles(1,0)*(singles_cumi_alpha(i) + singles_cumi_alpha(j)) + topsingles(0,1)*(singles_cuma_alpha(a) + singles_cuma_alpha(b))
                     if(q.eq.p) then
                       Newc%aa%m(a,i)%nsym(s,r)%n(b,j) = Newc%aa%m(a,i)%nsym(s,r)%n(b,j) + topsingles(1,1)*T1data%a%o(i)%vsym(q)%v(a)**2
                     end if
                     if(q.eq.r) then
                       Newc%aa%m(a,i)%nsym(s,r)%n(b,j) = Newc%aa%m(a,i)%nsym(s,r)%n(b,j) + topsingles(1,1)*T1data%a%o(j)%vsym(q)%v(a)**2
                     end if
                     if(s.eq.p) then
                       Newc%aa%m(a,i)%nsym(s,r)%n(b,j) = Newc%aa%m(a,i)%nsym(s,r)%n(b,j) + topsingles(1,1)*T1data%a%o(i)%vsym(s)%v(b)**2
                     end if
                    if(s.eq.r) then
                       Newc%aa%m(a,i)%nsym(s,r)%n(b,j) = Newc%aa%m(a,i)%nsym(s,r)%n(b,j) + topsingles(1,1)*T1data%a%o(j)%vsym(s)%v(b)**2
                    end if
                     Newc%aa%m(a,i)%nsym(s,r)%n(b,j) = sqrt(abs((1.0-Newc%aa%m(a,i)%nsym(s,r)%n(b,j))))
                     Newc%aa%m(b,j)%nsym(q,p)%n(a,i) = Newc%aa%m(a,i)%nsym(s,r)%n(b,j)
                     Newc%aa%m(a,j)%nsym(s,p)%n(b,i) = Newc%aa%m(a,i)%nsym(s,r)%n(b,j)
                     Newc%aa%m(b,i)%nsym(q,r)%n(a,j) = Newc%aa%m(a,i)%nsym(s,r)%n(b,j)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

      do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           i_begin = occ_beta(1,p)
           i_end   = occ_beta(2,p)
           a_begin = virt_beta(1,q)
           a_end   = virt_beta(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 j_begin = occ_beta(1,r)
                 j_end   = occ_beta(2,r)
                 b_begin = virt_beta(1,s)
                 b_end   = virt_beta(2,s)
                 do j=max(i+1,j_begin),j_end
                   do b=max(a+1,b_begin),b_end
                     Newc%bb%m(a,i)%nsym(s,r)%n(b,j) = topfac(0,0)*pizero +topfac(1,0)*(cumocc_beta(i)+cumocc_beta(j)) + topfac(0,1)*(cumvirt_beta(a) + cumvirt_beta(b)) + topfac(1,1)*(cumaj_bb(j,b) + cumaj_bb(j,a) + cumaj_bb(i,b) + cumaj_bb(i,a)) + topfac(2,0)*cumij_bb(i,j) + topfac(0,2)*cumab_bb(a,b) + topfac(2,1)*(pi_ija_bbb(i,j,a) + pi_ija_bbb(i,j,b))  + topfac(1,2)*(pi_iab_bbb(i,a,b) + pi_iab_bbb(j,a,b)) + topfac(2,2)*T2data%bb%m(a,i)%nsym(s,r)%n(b,j)**2 +topsingles(0,0)*singles_pizero + topsingles(1,0)*(singles_cumi_beta(i) + singles_cumi_beta(j)) + topsingles(0,1)*(singles_cuma_beta(a) + singles_cuma_beta(b))
                     if(q.eq.p) then
                       Newc%bb%m(a,i)%nsym(s,r)%n(b,j) = Newc%bb%m(a,i)%nsym(s,r)%n(b,j) + topsingles(1,1)*T1data%b%o(i)%vsym(q)%v(a)**2
                     end if
                     if(q.eq.r) then
                       Newc%bb%m(a,i)%nsym(s,r)%n(b,j) = Newc%bb%m(a,i)%nsym(s,r)%n(b,j) + topsingles(1,1)*T1data%b%o(j)%vsym(q)%v(a)**2
                     end if
                     if(s.eq.p) then
                       Newc%bb%m(a,i)%nsym(s,r)%n(b,j) = Newc%bb%m(a,i)%nsym(s,r)%n(b,j) + topsingles(1,1)*T1data%b%o(i)%vsym(s)%v(b)**2
                     end if
                    if(s.eq.r) then
                       Newc%bb%m(a,i)%nsym(s,r)%n(b,j) = Newc%bb%m(a,i)%nsym(s,r)%n(b,j) + topsingles(1,1)*T1data%b%o(j)%vsym(s)%v(b)**2
                    end if
                     Newc%bb%m(a,i)%nsym(s,r)%n(b,j) = sqrt(abs((1.0-Newc%bb%m(a,i)%nsym(s,r)%n(b,j))))
                     Newc%bb%m(b,j)%nsym(q,p)%n(a,i) = Newc%bb%m(a,i)%nsym(s,r)%n(b,j)
                     Newc%bb%m(a,j)%nsym(s,p)%n(b,i) = Newc%bb%m(a,i)%nsym(s,r)%n(b,j)
                     Newc%bb%m(b,i)%nsym(q,r)%n(a,j) = Newc%bb%m(a,i)%nsym(s,r)%n(b,j)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do




pizero_deriv = 0.0
      if(topfac(0,0).ne.0.or.singlesb0_topfac(0,0).ne.0) then
       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           k_begin = occ_alpha(1,p)
           k_end   = occ_alpha(2,p)
           c_begin = virt_alpha(1,q)
           c_end   = virt_alpha(2,q)
           do k=k_begin,k_end
             do c=c_begin,c_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 l_begin = occ_beta(1,r)
                 l_end   = occ_beta(2,r)
                 d_begin = virt_beta(1,s)
                 d_end   = virt_beta(2,s)
                 do l=l_begin,l_end
                   do d=d_begin,d_end
                     k_gamess = OldIndex_alpha(k)
                     c_gamess = OldIndex_alpha(c)
                     l_gamess = OldIndex_beta(l)
                     d_gamess = OldIndex_beta(d)
                     pizero_deriv = pizero_deriv +T2data%ab%m(c,k)%nsym(s,r)%n(d,l)*(TwoInts(k_gamess,l_gamess,c_gamess,d_gamess))/Newc%ab%m(c,k)%nsym(s,r)%n(d,l)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           k_begin = occ_alpha(1,p)
           k_end   = occ_alpha(2,p)
           c_begin = virt_alpha(1,q)
           c_end   = virt_alpha(2,q)
           do k=k_begin,k_end
             do c=c_begin,c_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 l_begin = occ_alpha(1,r)
                 l_end   = occ_alpha(2,r)
                 d_begin = virt_alpha(1,s)
                 d_end   = virt_alpha(2,s)
                 do l=max(k+1,l_begin),l_end
                   do d=max(c+1,d_begin),d_end
                     k_gamess = OldIndex_alpha(k)
                     l_gamess = OldIndex_alpha(l)
                     c_gamess = OldIndex_alpha(c)
                     d_gamess = OldIndex_alpha(d)
                     pizero_deriv = pizero_deriv + T2data%aa%m(c,k)%nsym(s,r)%n(d,l)*(TwoInts(k_gamess,l_gamess,c_gamess,d_gamess)-TwoInts(k_gamess,l_gamess,d_gamess,c_gamess))/Newc%aa%m(c,k)%nsym(s,r)%n(d,l)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,p)
           k_end   = occ_beta(2,p)
           c_begin = virt_beta(1,q)
           c_end   = virt_beta(2,q)
           do k=k_begin,k_end
             do c=c_begin,c_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 l_begin = occ_beta(1,r)
                 l_end   = occ_beta(2,r)
                 d_begin = virt_beta(1,s)
                 d_end   = virt_beta(2,s)
                 do l=max(k+1,l_begin),l_end
                   do d=max(c+1,d_begin),d_end
                     k_gamess = OldIndex_beta(k)
                     l_gamess = OldIndex_beta(l)
                     c_gamess = OldIndex_beta(c)
                     d_gamess = OldIndex_beta(d)
                     pizero_deriv = pizero_deriv + T2data%bb%m(c,k)%nsym(s,r)%n(d,l)*(TwoInts(k_gamess,l_gamess,c_gamess,d_gamess)-TwoInts(k_gamess,l_gamess,d_gamess,c_gamess))/Newc%bb%m(c,k)%nsym(s,r)%n(d,l)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

    end if

if(topfac(1,0).ne.0) then
      do symgp=1,numSG
        i_begin = occ_alpha(1,symgp)
        i_end   = occ_alpha(2,symgp)
        do i=i_begin,i_end
          do p=1,numSG
            c_begin = virt_alpha(1,p)
            c_end   = virt_alpha(2,p)
            cisym = ProductTable(symgp,p)
            do c=c_begin,c_end
              do t=1,numSG
                q = InvPdt(cisym)%upper(t)
                r = InvPdt(cisym)%lower(t)
                if(p>r) cycle
                k_begin = occ_alpha(1,q)
                k_end   = occ_alpha(2,q)
                d_begin = virt_alpha(1,r)
                d_end   = virt_alpha(2,r)
                do k=k_begin,k_end
                  do d=max(c+1,d_begin),d_end
                    if(k.eq.i) cycle
                    i_gamess = OldIndex_alpha(i)
                    k_gamess = OldIndex_alpha(k)
                    c_gamess = OldIndex_alpha(c)
                    d_gamess = OldIndex_alpha(d)
                    cumocc_alpha_deriv(i) = cumocc_alpha_deriv(i) + T2data%aa%m(c,i)%nsym(r,q)%n(d,k)*(TwoInts(i_gamess,k_gamess,c_gamess,d_gamess)-TwoInts(i_gamess,k_gamess,d_gamess,c_gamess))/Newc%aa%m(c,i)%nsym(r,q)%n(d,k)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
      do symgp=1,numSG
        i_begin = occ_alpha(1,symgp)
        i_end   = occ_alpha(2,symgp)
        do i=i_begin,i_end
          do p=1,numSG
            c_begin = virt_alpha(1,p)
            c_end   = virt_alpha(2,p)
            cisym = ProductTable(symgp,p)
            do c=c_begin,c_end
              do t=1,numSG
                q = InvPdt(cisym)%upper(t)
                r = InvPdt(cisym)%lower(t)
                k_begin = occ_beta(1,q)
                k_end   = occ_beta(2,q)
                d_begin = virt_beta(1,r)
                d_end   = virt_beta(2,r)
                do k=k_begin,k_end
                  do d=d_begin,d_end
                    i_gamess = OldIndex_alpha(i)
                    k_gamess = OldIndex_beta(k)
                    c_gamess = OldIndex_alpha(c)
                    d_gamess = OldIndex_beta(d)
                    cumocc_alpha_deriv(i) = cumocc_alpha_deriv(i) + T2data%ab%m(c,i)%nsym(r,q)%n(d,k)*TwoInts(i_gamess,k_gamess,c_gamess,d_gamess)/Newc%ab%m(c,i)%nsym(r,q)%n(d,k)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
      do symgp=1,numSG
        i_begin = occ_beta(1,symgp)
        i_end   = occ_beta(2,symgp)
        do i=i_begin,i_end
          do p=1,numSG
            c_begin = virt_beta(1,p)
            c_end   = virt_beta(2,p)
            cisym = ProductTable(symgp,p)
            do c=c_begin,c_end
              do t=1,numSG
                q = InvPdt(cisym)%upper(t)
                r = InvPdt(cisym)%lower(t)
                if(p>r) cycle
                k_begin = occ_beta(1,q)
                k_end   = occ_beta(2,q)
                d_begin = virt_beta(1,r)
                d_end   = virt_beta(2,r)
                do k=k_begin,k_end
                  do d=max(c+1,d_begin),d_end
                    if(k.eq.i) cycle
                    i_gamess = OldIndex_beta(i)
                    k_gamess = OldIndex_beta(k)
                    c_gamess = OldIndex_beta(c)
                    d_gamess = OldIndex_beta(d)
                    cumocc_beta_deriv(i) = cumocc_beta_deriv(i) + T2data%bb%m(c,i)%nsym(r,q)%n(d,k)*(TwoInts(i_gamess,k_gamess,c_gamess,d_gamess)-TwoInts(i_gamess,k_gamess,d_gamess,c_gamess))/Newc%bb%m(c,i)%nsym(r,q)%n(d,k)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
      do symgp=1,numSG
        i_begin = occ_beta(1,symgp)
        i_end   = occ_beta(2,symgp)
        do i=i_begin,i_end
          do p=1,numSG
            k_begin = occ_alpha(1,p)
            k_end   = occ_alpha(2,p)
            cisym = ProductTable(symgp,p)
            do k=k_begin,k_end
              do t=1,numSG
                q = InvPdt(cisym)%upper(t)
                r = InvPdt(cisym)%lower(t)
                c_begin = virt_alpha(1,q)
                c_end   = virt_alpha(2,q)
                d_begin = virt_beta(1,r)
                d_end   = virt_beta(2,r)
                do c=c_begin,c_end
                  do d=d_begin,d_end
                    i_gamess = OldIndex_beta(i)
                    k_gamess = OldIndex_alpha(k)
                    c_gamess = OldIndex_alpha(c)
                    d_gamess = OldIndex_beta(d)
                    cumocc_beta_deriv(i) = cumocc_beta_deriv(i) + 1*T2data%ab%m(c,k)%nsym(r,symgp)%n(d,i)*TwoInts(k_gamess,i_gamess,c_gamess,d_gamess)/Newc%ab%m(c,k)%nsym(r,symgp)%n(d,i)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
  do i=1,numocc_beta
end do
end if
if(topfac(0,1).ne.0) then
      do symgp=1,numSG
        a_begin = virt_alpha(1,symgp)
        a_end   = virt_alpha(2,symgp)
        do a=a_begin,a_end
          do p=1,numSG
            k_begin = occ_alpha(1,p)
            k_end   = occ_alpha(2,p)
            aksym = ProductTable(symgp,p)
            do k=k_begin,k_end
              do t=1,numSG
                q = InvPdt(aksym)%upper(t)
                r = InvPdt(aksym)%lower(t)
                if(p>q) cycle
                l_begin = occ_alpha(1,q)
                l_end   = occ_alpha(2,q)
                c_begin = virt_alpha(1,r)
                c_end   = virt_alpha(2,r)
                do l=max(k+1,l_begin),l_end
                  do c=c_begin,c_end
                    if(c.eq.a) cycle
                    k_gamess = OldIndex_alpha(k)
                    l_gamess = OldIndex_alpha(l)
                    a_gamess = OldIndex_alpha(a)
                    c_gamess = OldIndex_alpha(c)
                    cumvirt_alpha_deriv(a) = cumvirt_alpha_deriv(a) + T2data%aa%m(a,k)%nsym(r,q)%n(c,l)*(TwoInts(k_gamess,l_gamess,a_gamess,c_gamess)-TwoInts(k_gamess,l_gamess,c_gamess,a_gamess))/Newc%aa%m(a,k)%nsym(r,q)%n(c,l)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
      do symgp=1,numSG
        a_begin = virt_alpha(1,symgp)
        a_end   = virt_alpha(2,symgp)
        do a=a_begin,a_end
          do p=1,numSG
            k_begin = occ_alpha(1,p)
            k_end   = occ_alpha(2,p)
            aksym = ProductTable(symgp,p)
            do k=k_begin,k_end
              do t=1,numSG
                q = InvPdt(aksym)%upper(t)
                r = InvPdt(aksym)%lower(t)
                l_begin = occ_beta(1,q)
                l_end   = occ_beta(2,q)
                c_begin = virt_beta(1,r)
                c_end   = virt_beta(2,r)
                do l=l_begin,l_end
                  do c=c_begin,c_end
                    a_gamess = OldIndex_alpha(a)
                    k_gamess = OldIndex_alpha(k)
                    l_gamess = OldIndex_beta(l)
                    c_gamess = OldIndex_beta(c)
                    cumvirt_alpha_deriv(a) = cumvirt_alpha_deriv(a) + T2data%ab%m(a,k)%nsym(r,q)%n(c,l)*TwoInts(k_gamess,l_gamess,a_gamess,c_gamess)/Newc%ab%m(a,k)%nsym(r,q)%n(c,l)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

      do symgp=1,numSG
        a_begin = virt_beta(1,symgp)
        a_end   = virt_beta(2,symgp)
        do a=a_begin,a_end
          do p=1,numSG
            k_begin = occ_beta(1,p)
            k_end   = occ_beta(2,p)
            aksym = ProductTable(symgp,p)
            do k=k_begin,k_end
              do t=1,numSG
                q = InvPdt(aksym)%upper(t)
                r = InvPdt(aksym)%lower(t)
                if(p>q) cycle
                l_begin = occ_beta(1,q)
                l_end   = occ_beta(2,q)
                c_begin = virt_beta(1,r)
                c_end   = virt_beta(2,r)
                do l=max(k+1,l_begin),l_end
                  do c=c_begin,c_end
                    if(c.eq.a) cycle
                    k_gamess = OldIndex_beta(k)
                    l_gamess = OldIndex_beta(l)
                    a_gamess = OldIndex_beta(a)
                    c_gamess = OldIndex_beta(c)
                    cumvirt_beta_deriv(a) = cumvirt_beta_deriv(a) + T2data%bb%m(a,k)%nsym(r,q)%n(c,l)*(TwoInts(k_gamess,l_gamess,a_gamess,c_gamess)-TwoInts(k_gamess,l_gamess,c_gamess,a_gamess))/Newc%bb%m(a,k)%nsym(r,q)%n(c,l)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

      do symgp=1,numSG
        a_begin = virt_beta(1,symgp)
        a_end   = virt_beta(2,symgp)
        do a=a_begin,a_end
          do p=1,numSG
            k_begin = occ_alpha(1,p)
            k_end   = occ_alpha(2,p)
            aksym = ProductTable(symgp,p)
            do k=k_begin,k_end
              do t=1,numSG
                q = InvPdt(aksym)%upper(t)
                r = InvPdt(aksym)%lower(t)
                l_begin = occ_beta(1,q)
                l_end   = occ_beta(2,q)
                c_begin = virt_alpha(1,r)
                c_end   = virt_alpha(2,r)
                do l=l_begin,l_end
                  do c=c_begin,c_end
                    a_gamess = OldIndex_beta(a)
                    k_gamess = OldIndex_alpha(k)
                    l_gamess = OldIndex_beta(l)
                    c_gamess = OldIndex_alpha(c)
                    cumvirt_beta_deriv(a) = cumvirt_beta_deriv(a) + T2data%ab%m(c,k)%nsym(symgp,q)%n(a,l)*TwoInts(k_gamess,l_gamess,c_gamess,a_gamess)/Newc%ab%m(c,k)%nsym(symgp,q)%n(a,l)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

end if
if(topfac(1,1).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          a_begin = virt_alpha(1,p)
          a_end   = virt_alpha(2,p)
          j_begin = occ_alpha(1,q)
          j_end   = occ_alpha(2,q)
          do j=j_begin,j_end
            do a=a_begin,a_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                c_begin = virt_alpha(1,r)
                c_end   = virt_alpha(2,r)
                k_begin = occ_alpha(1,s)
                k_end   = occ_alpha(2,s)
                do k=max(j+1,k_begin),k_end
                  do c=max(a+1,c_begin),c_end
                    j_gamess = OldIndex_alpha(j)
                    k_gamess = OldIndex_alpha(k)
                    a_gamess = OldIndex_alpha(a)
                    c_gamess = OldIndex_alpha(c)
                    cumaj_aa_deriv(j,a) = cumaj_aa_deriv(j,a) + T2data%aa%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j_gamess,k_gamess,a_gamess,c_gamess)-TwoInts(j_gamess,k_gamess,c_gamess,a_gamess))/Newc%aa%m(a,j)%nsym(r,s)%n(c,k)
                    cumaj_aa_deriv(j,c) = cumaj_aa_deriv(j,c) + 1*T2data%aa%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j_gamess,k_gamess,a_gamess,c_gamess)-TwoInts(j_gamess,k_gamess,c_gamess,a_gamess))/Newc%aa%m(a,j)%nsym(r,s)%n(c,k)
                    cumaj_aa_deriv(k,a) = cumaj_aa_deriv(k,a) + 1*T2data%aa%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j_gamess,k_gamess,a_gamess,c_gamess)-TwoInts(j_gamess,k_gamess,c_gamess,a_gamess))/Newc%aa%m(a,j)%nsym(r,s)%n(c,k)
                    cumaj_aa_deriv(k,c) = cumaj_aa_deriv(k,c) + T2data%aa%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j_gamess,k_gamess,a_gamess,c_gamess)-TwoInts(j_gamess,k_gamess,c_gamess,a_gamess))/Newc%aa%m(a,j)%nsym(r,s)%n(c,k)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

      do symgp=1,numSG
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          a_begin = virt_alpha(1,p)
          a_end   = virt_alpha(2,p)
          i_begin = occ_alpha(1,q)
          i_end   = occ_alpha(2,q)
          do i=i_begin,i_end
            do a=a_begin,a_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                b_begin = virt_beta(1,r)
                b_end   = virt_beta(2,r)
                j_begin = occ_beta(1,s)
                j_end   = occ_beta(2,s)
                do b=b_begin,b_end
                  do j=j_begin,j_end
                    i_gamess = OldIndex_alpha(i)
                    a_gamess = OldIndex_alpha(a)
                    j_gamess = OldIndex_beta(j)
                    b_gamess = OldIndex_beta(b)
                    cumaj_aa_deriv(i,a) = cumaj_aa_deriv(i,a) + TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)*T2data%ab%m(a,i)%nsym(r,s)%n(b,j)/Newc%ab%m(a,i)%nsym(r,s)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

      do symgp=1,numSG
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          a_begin = virt_beta(1,p)
          a_end   = virt_beta(2,p)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          do j=j_begin,j_end
            do a=a_begin,a_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                c_begin = virt_beta(1,r)
                c_end   = virt_beta(2,r)
                k_begin = occ_beta(1,s)
                k_end   = occ_beta(2,s)
                do k=max(j+1,k_begin),k_end
                  do c=max(a+1,c_begin),c_end
                    j_gamess = OldIndex_beta(j)
                    k_gamess = OldIndex_beta(k)
                    a_gamess = OldIndex_beta(a)
                    c_gamess = OldIndex_beta(c)
                    cumaj_bb_deriv(j,a) = cumaj_bb_deriv(j,a) + T2data%bb%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j_gamess,k_gamess,a_gamess,c_gamess)-TwoInts(j_gamess,k_gamess,c_gamess,a_gamess))/Newc%bb%m(a,j)%nsym(r,s)%n(c,k)
                    cumaj_bb_deriv(j,c) = cumaj_bb_deriv(j,c) + 1*T2data%bb%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j_gamess,k_gamess,a_gamess,c_gamess)-TwoInts(j_gamess,k_gamess,c_gamess,a_gamess))/Newc%bb%m(a,j)%nsym(r,s)%n(c,k)
                    cumaj_bb_deriv(k,a) = cumaj_bb_deriv(k,a) + 1*T2data%bb%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j_gamess,k_gamess,a_gamess,c_gamess)-TwoInts(j_gamess,k_gamess,c_gamess,a_gamess))/Newc%bb%m(a,j)%nsym(r,s)%n(c,k)
                    cumaj_bb_deriv(k,c) = cumaj_bb_deriv(k,c) + 1*T2data%bb%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j_gamess,k_gamess,a_gamess,c_gamess)-TwoInts(j_gamess,k_gamess,c_gamess,a_gamess))/Newc%bb%m(a,j)%nsym(r,s)%n(c,k)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
      do symgp=1,numSG
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          a_begin = virt_alpha(1,p)
          a_end   = virt_alpha(2,p)
          i_begin = occ_alpha(1,q)
          i_end   = occ_alpha(2,q)
          do i=i_begin,i_end
            do a=a_begin,a_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                b_begin = virt_beta(1,r)
                b_end   = virt_beta(2,r)
                j_begin = occ_beta(1,s)
                j_end   = occ_beta(2,s)
                do b=b_begin,b_end
                  do j=j_begin,j_end
                    i_gamess = OldIndex_alpha(i)
                    a_gamess = OldIndex_alpha(a)
                    j_gamess = OldIndex_beta(j)
                    b_gamess = OldIndex_beta(b)
                    cumaj_bb_deriv(j,b) = cumaj_bb_deriv(j,b) + TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)*T2data%ab%m(a,i)%nsym(r,s)%n(b,j)/Newc%ab%m(a,i)%nsym(r,s)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(1,1).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          a_begin = virt_alpha(1,p)
          a_end   = virt_alpha(2,p)
          i_begin = occ_alpha(1,q)
          i_end   = occ_alpha(2,q)
          do i=i_begin,i_end
            do a=a_begin,a_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                b_begin = virt_beta(1,r)
                b_end   = virt_beta(2,r)
                j_begin = occ_beta(1,s)
                j_end   = occ_beta(2,s)
                do b=b_begin,b_end
                  do j=j_begin,j_end
                  i_gamess = OldIndex_alpha(i)
                  j_gamess = OldIndex_beta(j)
                  a_gamess = OldIndex_alpha(a)
                  b_gamess = OldIndex_beta(b)
                    cumaj_ab_deriv(j,a) = cumaj_ab_deriv(j,a) + TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)*T2data%ab%m(a,i)%nsym(r,s)%n(b,j)/Newc%ab%m(a,i)%nsym(r,s)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
      do symgp=1,numSG
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          a_begin = virt_beta(1,p)
          a_end   = virt_beta(2,p)
          i_begin = occ_beta(1,q)
          i_end   = occ_beta(2,q)
          do i=i_begin,i_end
            do a=a_begin,a_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                b_begin = virt_alpha(1,r)
                b_end   = virt_alpha(2,r)
                j_begin = occ_alpha(1,s)
                j_end   = occ_alpha(2,s)
                do b=b_begin,b_end
                  do j=j_begin,j_end
                    j_gamess = OldIndex_alpha(j)
                    b_gamess = OldIndex_alpha(b)
                    a_gamess = OldIndex_beta(a)
                    i_gamess = OldIndex_beta(i)
                    cumaj_ba_deriv(j,a) = cumaj_ba_deriv(j,a) + TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)*T2data%ab%m(b,j)%nsym(p,q)%n(a,i)/Newc%ab%m(b,j)%nsym(p,q)%n(a,i)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do



end if
if(topfac(2,0).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          if(p.gt.q) cycle
          i_begin = occ_alpha(1,p)
          i_end   = occ_alpha(2,p)
          j_begin = occ_alpha(1,q)
          j_end   = occ_alpha(2,q)
          do i=i_begin,i_end
            do j=max(i+1,j_begin),j_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                if(r.gt.s) cycle
                a_begin = virt_alpha(1,r)
                a_end   = virt_alpha(2,r)
                b_begin = virt_alpha(1,s)
                b_end   = virt_alpha(2,s)
                do a=a_begin,a_end
                  do b=max(a+1,b_begin),b_end
                    i_gamess = OldIndex_alpha(i)
                    j_gamess = OldIndex_alpha(j)
                    a_gamess = OldIndex_alpha(a)
                    b_gamess = OldIndex_alpha(b)
                    cumij_aa_deriv(i,j) = cumij_aa_deriv(i,j) + T2data%aa%m(a,i)%nsym(s,q)%n(b,j)*(TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)-TwoInts(i_gamess,j_gamess,b_gamess,a_gamess))/Newc%aa%m(a,i)%nsym(s,q)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          if(p.gt.q) cycle
          i_begin = occ_beta(1,p)
          i_end   = occ_beta(2,p)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          do i=i_begin,i_end
            do j=max(i+1,j_begin),j_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                if(r.gt.s) cycle
                a_begin = virt_beta(1,r)
                a_end   = virt_beta(2,r)
                b_begin = virt_beta(1,s)
                b_end   = virt_beta(2,s)
                do a=a_begin,a_end
                  do b=max(a+1,b_begin),b_end
                    i_gamess = OldIndex_beta(i)
                    j_gamess = OldIndex_beta(j)
                    a_gamess = OldIndex_beta(a)
                    b_gamess = OldIndex_beta(b)
                    cumij_bb_deriv(i,j) = cumij_bb_deriv(i,j) + T2data%bb%m(a,i)%nsym(s,q)%n(b,j)*(TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)-TwoInts(i_gamess,j_gamess,b_gamess,a_gamess))/Newc%bb%m(a,i)%nsym(s,q)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

end if
if(topfac(2,0).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          i_begin = occ_alpha(1,p)
          i_end   = occ_alpha(2,p)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                a_begin = virt_alpha(1,r)
                a_end   = virt_alpha(2,r)
                b_begin = virt_beta(1,s)
                b_end   = virt_beta(2,s)
                do a=a_begin,a_end
                  do b=b_begin,b_end
                    i_gamess = OldIndex_alpha(i)
                    j_gamess = OldIndex_beta(j)
                    a_gamess = OldIndex_alpha(a)
                    b_gamess = OldIndex_beta(b)
                    cumij_ab_deriv(i,j) = cumij_ab_deriv(i,j) + T2data%ab%m(a,i)%nsym(s,q)%n(b,j)*TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)/Newc%ab%m(a,i)%nsym(s,q)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(0,2).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          if(p.gt.q) cycle
          a_begin = virt_alpha(1,p)
          a_end   = virt_alpha(2,p)
          b_begin = virt_alpha(1,q)
          b_end   = virt_alpha(2,q)
          do a=a_begin,a_end
            do b=max(a+1,b_begin),b_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                if(r.gt.s) cycle
                i_begin = occ_alpha(1,r)
                i_end   = occ_alpha(2,r)
                j_begin = occ_alpha(1,s)
                j_end   = occ_alpha(2,s)
                do i=i_begin,i_end
                  do j=max(i+1,j_begin),j_end
                    i_gamess = OldIndex_alpha(i)
                    j_gamess = OldIndex_alpha(j)
                    a_gamess = OldIndex_alpha(a)
                    b_gamess = OldIndex_alpha(b)
                    cumab_aa_deriv(a,b) = cumab_aa_deriv(a,b) + T2data%aa%m(a,i)%nsym(q,s)%n(b,j)*(TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)-TwoInts(i_gamess,j_gamess,b_gamess,a_gamess))/Newc%aa%m(a,i)%nsym(q,s)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          if(p.gt.q) cycle
          a_begin = virt_alpha(1,p)
          a_end   = virt_alpha(2,p)
          b_begin = virt_alpha(1,q)
          b_end   = virt_alpha(2,q)
          do a=a_begin,a_end
            do b=max(a+1,b_begin),b_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                if(r.gt.s) cycle
                i_begin = occ_alpha(1,r)
                i_end   = occ_alpha(2,r)
                j_begin = occ_alpha(1,s)
                j_end   = occ_alpha(2,s)
                do i=i_begin,i_end
                  do j=max(i+1,j_begin),j_end
                    i_gamess = OldIndex_alpha(i)
                    j_gamess = OldIndex_alpha(j)
                    a_gamess = OldIndex_alpha(a)
                    b_gamess = OldIndex_alpha(b)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          if(p.gt.q) cycle
          a_begin = virt_beta(1,p)
          a_end   = virt_beta(2,p)
          b_begin = virt_beta(1,q)
          b_end   = virt_beta(2,q)
          do a=a_begin,a_end
            do b=max(a+1,b_begin),b_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                if(r.gt.s) cycle
                i_begin = occ_beta(1,r)
                i_end   = occ_beta(2,r)
                j_begin = occ_beta(1,s)
                j_end   = occ_beta(2,s)
                do i=i_begin,i_end
                  do j=max(i+1,j_begin),j_end
                    i_gamess = OldIndex_beta(i)
                    j_gamess = OldIndex_beta(j)
                    a_gamess = OldIndex_beta(a)
                    b_gamess = OldIndex_beta(b)
                    cumab_bb_deriv(a,b) = cumab_bb_deriv(a,b) + T2data%bb%m(a,i)%nsym(q,s)%n(b,j)*(TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)-TwoInts(i_gamess,j_gamess,b_gamess,a_gamess))/Newc%bb%m(a,i)%nsym(q,s)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(0,2).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          a_begin = virt_alpha(1,p)
          a_end   = virt_alpha(2,p)
          b_begin = virt_beta(1,q)
          b_end   = virt_beta(2,q)
          do a=a_begin,a_end
            do b=b_begin,b_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                i_begin = occ_alpha(1,r)
                i_end   = occ_alpha(2,r)
                j_begin = occ_beta(1,s)
                j_end   = occ_beta(2,s)
                do i=i_begin,i_end
                  do j=j_begin,j_end
                    i_gamess = OldIndex_alpha(i)
                    j_gamess = OldIndex_beta(j)
                    a_gamess = OldIndex_alpha(a)
                    b_gamess = OldIndex_beta(b)
                    cumab_ab_deriv(a,b) = cumab_ab_deriv(a,b) + T2data%ab%m(a,i)%nsym(q,s)%n(b,j)*TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)/Newc%ab%m(a,i)%nsym(q,s)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(2,1).ne.0) then
      do symgp=1,numSG
        c_begin = virt_alpha(1,symgp)
        c_end   = virt_alpha(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          j_begin = occ_alpha(1,q)
          j_end   = occ_alpha(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt_alpha(1,r)
            a_end   = virt_alpha(2,r)
            i_begin = occ_alpha(1,s)
            i_end   = occ_alpha(2,s)
            do i=i_begin,i_end
              do a=a_begin,a_end
                do j=max(i+1,j_begin),j_end
                  do c=c_begin,c_end
                    if(c.eq.a) cycle
                    i_gamess = OldIndex_alpha(i)
                    j_gamess = OldIndex_alpha(j)
                    a_gamess = OldIndex_alpha(a)
                    c_gamess = OldIndex_alpha(c)
                    pi_ija_aaa_deriv(i,j,a) = pi_ija_aaa_deriv(i,j,a) + T2data%aa%m(a,i)%nsym(symgp,q)%n(c,j)*(TwoInts(i_gamess,j_gamess,a_gamess,c_gamess)-TwoInts(i_gamess,j_gamess,c_gamess,a_gamess))/Newc%aa%m(a,i)%nsym(symgp,q)%n(c,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

      do symgp=1,numSG
        c_begin = virt_beta(1,symgp)
        c_end   = virt_beta(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt_beta(1,r)
            a_end   = virt_beta(2,r)
            i_begin = occ_beta(1,s)
            i_end   = occ_beta(2,s)
            do i=i_begin,i_end
              do a=a_begin,a_end
                do j=max(i+1,j_begin),j_end
                  do c=c_begin,c_end
                    if(c.eq.a) cycle
                    i_gamess = OldIndex_beta(i)
                    j_gamess = OldIndex_beta(j)
                    a_gamess = OldIndex_beta(a)
                    c_gamess = OldIndex_beta(c)
                    pi_ija_bbb_deriv(i,j,a) = pi_ija_bbb_deriv(i,j,a) + T2data%bb%m(a,i)%nsym(symgp,q)%n(c,j)*(TwoInts(i_gamess,j_gamess,a_gamess,c_gamess)-TwoInts(i_gamess,j_gamess,c_gamess,a_gamess))/Newc%bb%m(a,i)%nsym(symgp,q)%n(c,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do


end if
if(topfac(2,1).ne.0) then
      do symgp=1,numSG
        c_begin = virt_beta(1,symgp)
        c_end   = virt_beta(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt_alpha(1,r)
            a_end   = virt_alpha(2,r)
            i_begin = occ_alpha(1,s)
            i_end   = occ_alpha(2,s)
            do i=i_begin,i_end
              do a=a_begin,a_end
                do j=j_begin,j_end
                  do c=c_begin,c_end
                    i_gamess = OldIndex_alpha(i)
                    a_gamess = OldIndex_alpha(a)
                    j_gamess = OldIndex_beta(j)
                    c_gamess = OldIndex_beta(c)
                    pi_ija_aba_deriv(i,j,a) = pi_ija_aba_deriv(i,j,a)  + T2data%ab%m(a,i)%nsym(symgp,q)%n(c,j)*TwoInts(i_gamess,j_gamess,a_gamess,c_gamess)/Newc%ab%m(a,i)%nsym(symgp,q)%n(c,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(2,1).ne.0) then
      do symgp=1,numSG
        c_begin = virt_alpha(1,symgp)
        c_end   = virt_alpha(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            b_begin = virt_beta(1,r)
            b_end   = virt_beta(2,r)
            i_begin = occ_alpha(1,s)
            i_end   = occ_alpha(2,s)
            do c=c_begin,c_end
              do i=i_begin,i_end
                do b=b_begin,b_end
                  do j=j_begin,j_end
                    i_gamess = OldIndex_alpha(i)
                    c_gamess = OldIndex_alpha(c)
                    b_gamess = OldIndex_beta(b)
                    j_gamess = OldIndex_beta(j)
                    pi_ijb_abb_deriv(i,j,b) = pi_ijb_abb_deriv(i,j,b)  + T2data%ab%m(c,i)%nsym(r,q)%n(b,j)*TwoInts(i_gamess,j_gamess,c_gamess,b_gamess)/Newc%ab%m(c,i)%nsym(r,q)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if

if(topfac(1,2).ne.0) then
      do symgp=1,numSG
        k_begin = occ_alpha(1,symgp)
        k_end   = occ_alpha(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          b_begin = virt_alpha(1,q)
          b_end   = virt_alpha(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt_alpha(1,r)
            a_end   = virt_alpha(2,r)
            i_begin = occ_alpha(1,s)
            i_end   = occ_alpha(2,s)
            do i=i_begin,i_end
              do a=a_begin,a_end
                do b=max(a+1,b_begin),b_end
                  do k=k_begin,k_end
                    if(i.eq.k) cycle
                    i_gamess = OldIndex_alpha(i)
                    a_gamess = OldIndex_alpha(a)
                    b_gamess = OldIndex_alpha(b)
                    k_gamess = OldIndex_alpha(k)
                    pi_iab_aaa_deriv(i,a,b) = pi_iab_aaa_deriv(i,a,b) + T2data%aa%m(a,i)%nsym(q,symgp)%n(b,k)*(TwoInts(i_gamess,k_gamess,a_gamess,b_gamess)-TwoInts(i_gamess,k_gamess,b_gamess,a_gamess))/Newc%aa%m(a,i)%nsym(q,symgp)%n(b,k)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do



      do symgp=1,numSG
        k_begin = occ_beta(1,symgp)
        k_end   = occ_beta(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          b_begin = virt_beta(1,q)
          b_end   = virt_beta(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt_beta(1,r)
            a_end   = virt_beta(2,r)
            i_begin = occ_beta(1,s)
            i_end   = occ_beta(2,s)
            do i=i_begin,i_end
              do a=a_begin,a_end
                do b=max(a+1,b_begin),b_end
                  do k=k_begin,k_end
                    if(i.eq.k) cycle
                    i_gamess = OldIndex_beta(i)
                    a_gamess = OldIndex_beta(a)
                    b_gamess = OldIndex_beta(b)
                    k_gamess = OldIndex_beta(k)
                    pi_iab_bbb_deriv(i,a,b) = pi_iab_bbb_deriv(i,a,b) + T2data%bb%m(a,i)%nsym(q,symgp)%n(b,k)*(TwoInts(i_gamess,k_gamess,a_gamess,b_gamess)-TwoInts(i_gamess,k_gamess,b_gamess,a_gamess))/Newc%bb%m(a,i)%nsym(q,symgp)%n(b,k)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

end if
if(topfac(1,2).ne.0) then
      do symgp=1,numSG
        k_begin = occ_beta(1,symgp)
        k_end   = occ_beta(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          b_begin = virt_beta(1,q)
          b_end   = virt_beta(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt_alpha(1,r)
            a_end   = virt_alpha(2,r)
            i_begin = occ_alpha(1,s)
            i_end   = occ_alpha(2,s)
            do i=i_begin,i_end
              do a=a_begin,a_end
                do b=b_begin,b_end
                  do k=k_begin,k_end
                    i_gamess = OldIndex_alpha(i)
                    a_gamess = OldIndex_alpha(a)
                    k_gamess = OldIndex_beta(k)
                    b_gamess = OldIndex_beta(b)
                    pi_iab_aab_deriv(i,a,b) = pi_iab_aab_deriv(i,a,b) + T2data%ab%m(a,i)%nsym(q,symgp)%n(b,k)*TwoInts(i_gamess,k_gamess,a_gamess,b_gamess)/Newc%ab%m(a,i)%nsym(q,symgp)%n(b,k)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if
if(topfac(1,2).ne.0) then
      do symgp=1,numSG
        k_begin = occ_alpha(1,symgp)
        k_end   = occ_alpha(2,symgp)
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          b_begin = virt_beta(1,q)
          b_end   = virt_beta(2,q)
          do u=1,numSG
            r = InvPdt(p)%upper(u)
            s = InvPdt(p)%lower(u)
            a_begin = virt_alpha(1,r)
            a_end   = virt_alpha(2,r)
            j_begin = occ_beta(1,s)
            j_end   = occ_beta(2,s)
            do j=j_begin,j_end
              do a=a_begin,a_end
                do b=b_begin,b_end
                  do k=k_begin,k_end
                    k_gamess = OldIndex_alpha(k)
                    j_gamess = OldIndex_beta(j)
                    a_gamess = OldIndex_alpha(a)
                    b_gamess = OldIndex_beta(b)
                    pi_jab_bab_deriv(j,a,b) = pi_jab_bab_deriv(j,a,b) + T2data%ab%m(a,k)%nsym(q,s)%n(b,j)*TwoInts(k_gamess,j_gamess,a_gamess,b_gamess)/Newc%ab%m(a,k)%nsym(q,s)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
end if













       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           a_begin = virt_alpha(1,q)
           a_end   = virt_alpha(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 j_begin = occ_beta(1,r)
                 j_end   = occ_beta(2,r)
                 b_begin = virt_beta(1,s)
                 b_end   = virt_beta(2,s)
                 do j=j_begin,j_end
                   do b=b_begin,b_end
                     i_gamess = OldIndex_alpha(i)
                     j_gamess = OldIndex_beta(j)
                     a_gamess = OldIndex_alpha(a)
                     b_gamess = OldIndex_beta(b)
                     DerivNewc%ab%m(a,i)%nsym(s,r)%n(b,j) = -2*(topfac(0,0)*pizero_deriv +&
                        &topfac(1,0)*(cumocc_alpha_deriv(i)+cumocc_beta_deriv(j)) + topfac(0,1)*(cumvirt_alpha_deriv(a) + cumvirt_beta_deriv(b)) +&
                        topfac(1,1)*(cumaj_bb_deriv(j,b) + cumaj_ab_deriv(j,a) + cumaj_ba_deriv(i,b) + cumaj_aa_deriv(i,a)) &
                        &+ topfac(2,0)*cumij_ab_deriv(i,j) + topfac(0,2)*cumab_ab_deriv(a,b) +&
                        & topfac(2,1)*(pi_ija_aba_deriv(i,j,a) + pi_ijb_abb_deriv(i,j,b))  &
                        &+ topfac(1,2)*(pi_iab_aab_deriv(i,a,b) + pi_jab_bab_deriv(j,a,b)) + topfac(2,2)*T2data%ab%m(a,i)%nsym(s,r)%n(b,j)*TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)/Newc%ab%m(a,i)%nsym(s,r)%n(b,j))
                     DerivNewc%ab%m(a,i)%nsym(s,r)%n(b,j) = 0.5*DerivNewc%ab%m(a,i)%nsym(s,r)%n(b,j)*T2data%ab%m(a,i)%nsym(s,r)%n(b,j)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           a_begin = virt_alpha(1,q)
           a_end   = virt_alpha(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 j_begin = occ_alpha(1,r)
                 j_end   = occ_alpha(2,r)
                 b_begin = virt_alpha(1,s)
                 b_end   = virt_alpha(2,s)
                 do j=j_begin,j_end
                   do b=b_begin,b_end
                     i_gamess = OldIndex_alpha(i)
                     j_gamess = OldIndex_alpha(j)
                     a_gamess = OldIndex_alpha(a)
                     b_gamess = OldIndex_alpha(b)
                     DerivNewc%aa%m(a,i)%nsym(s,r)%n(b,j) = -2*(topfac(0,0)*pizero_deriv +&
                        &topfac(1,0)*(cumocc_alpha_deriv(i)+cumocc_alpha_deriv(j)) + topfac(0,1)*(cumvirt_alpha_deriv(a) + cumvirt_alpha_deriv(b)) +&
                        topfac(1,1)*(cumaj_aa_deriv(j,b) + cumaj_aa_deriv(j,a) + cumaj_aa_deriv(i,b) + cumaj_aa_deriv(i,a)) &
                        &+ topfac(2,0)*cumij_aa_deriv(i,j) + topfac(0,2)*cumab_aa_deriv(a,b) +&
                        & topfac(2,1)*(pi_ija_aaa_deriv(i,j,a) + pi_ija_aaa_deriv(i,j,b))  &
                        &+ topfac(1,2)*(pi_iab_aaa_deriv(i,a,b) + pi_iab_aaa_deriv(j,a,b)) + topfac(2,2)*T2data%aa%m(a,i)%nsym(s,r)%n(b,j)*(TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)-TwoInts(i_gamess,j_gamess,b_gamess,a_gamess))/Newc%aa%m(a,i)%nsym(s,r)%n(b,j))
                     DerivNewc%aa%m(a,i)%nsym(s,r)%n(b,j) = 0.5*DerivNewc%aa%m(a,i)%nsym(s,r)%n(b,j)*T2data%aa%m(a,i)%nsym(s,r)%n(b,j)
                     if(i.ne.j.and.b.ne.a) then
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           i_begin = occ_beta(1,p)
           i_end   = occ_beta(2,p)
           a_begin = virt_beta(1,q)
           a_end   = virt_beta(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 j_begin = occ_beta(1,r)
                 j_end   = occ_beta(2,r)
                 b_begin = virt_beta(1,s)
                 b_end   = virt_beta(2,s)
                 do j=j_begin,j_end
                   do b=b_begin,b_end
                     i_gamess = OldIndex_beta(i)
                     j_gamess = OldIndex_beta(j)
                     a_gamess = OldIndex_beta(a)
                     b_gamess = OldIndex_beta(b)
                     DerivNewc%bb%m(a,i)%nsym(s,r)%n(b,j) = -2*(topfac(0,0)*pizero_deriv +&
                        &topfac(1,0)*(cumocc_beta_deriv(i)+cumocc_beta_deriv(j)) + topfac(0,1)*(cumvirt_beta_deriv(a) + cumvirt_beta_deriv(b)) +&
                        topfac(1,1)*(cumaj_bb_deriv(j,b) + cumaj_bb_deriv(j,a) + cumaj_bb_deriv(i,b) + cumaj_bb_deriv(i,a)) &
                        &+ topfac(2,0)*cumij_bb_deriv(i,j) + topfac(0,2)*cumab_bb_deriv(a,b) +&
                        & topfac(2,1)*(pi_ija_bbb_deriv(i,j,a) + pi_ija_bbb_deriv(i,j,b))  &
                        &+ topfac(1,2)*(pi_iab_bbb_deriv(i,a,b) + pi_iab_bbb_deriv(j,a,b)) + topfac(2,2)*T2data%bb%m(a,i)%nsym(s,r)%n(b,j)*(TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)-TwoInts(i_gamess,j_gamess,b_gamess,a_gamess))/Newc%bb%m(a,i)%nsym(s,r)%n(b,j))
                     DerivNewc%bb%m(a,i)%nsym(s,r)%n(b,j) = 0.5*DerivNewc%bb%m(a,i)%nsym(s,r)%n(b,j)*T2data%bb%m(a,i)%nsym(s,r)%n(b,j)
                     if(i.ne.j.and.a.ne.b) then
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do



if(topsingles(1,1).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          a_begin = virt_alpha(1,p)
          a_end   = virt_alpha(2,p)
          j_begin = occ_alpha(1,q)
          j_end   = occ_alpha(2,q)
          do j=j_begin,j_end
            do a=a_begin,a_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                c_begin = virt_alpha(1,r)
                c_end   = virt_alpha(2,r)
                k_begin = occ_alpha(1,s)
                k_end   = occ_alpha(2,s)
                do k=max(j+1,k_begin),k_end
                  do c=max(a+1,c_begin),c_end
                     j_gamess = OldIndex_alpha(j)
                     k_gamess = OldIndex_alpha(k)
                     c_gamess = OldIndex_alpha(c)
                     a_gamess = OldIndex_alpha(a)
                     singles_cumaj_aa_deriv(j,a) = singles_cumaj_aa_deriv(j,a) + T2data%aa%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j_gamess,k_gamess,a_gamess,c_gamess)-TwoInts(j_gamess,k_gamess,c_gamess,a_gamess))/Newc%aa%m(a,j)%nsym(r,s)%n(c,k)
                     singles_cumaj_aa_deriv(j,c) = singles_cumaj_aa_deriv(j,c) + T2data%aa%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j_gamess,k_gamess,a_gamess,c_gamess)-TwoInts(j_gamess,k_gamess,c_gamess,a_gamess))/Newc%aa%m(a,j)%nsym(r,s)%n(c,k)
                     singles_cumaj_aa_deriv(k,a) = singles_cumaj_aa_deriv(k,a) + T2data%aa%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j_gamess,k_gamess,a_gamess,c_gamess)-TwoInts(j_gamess,k_gamess,c_gamess,a_gamess))/Newc%aa%m(a,j)%nsym(r,s)%n(c,k)
                     singles_cumaj_aa_deriv(k,c) = singles_cumaj_aa_deriv(k,c) + T2data%aa%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j_gamess,k_gamess,a_gamess,c_gamess)-TwoInts(j_gamess,k_gamess,c_gamess,a_gamess))/Newc%aa%m(a,j)%nsym(r,s)%n(c,k)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do


      do symgp=1,numSG
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          a_begin = virt_beta(1,p)
          a_end   = virt_beta(2,p)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          do j=j_begin,j_end
            do a=a_begin,a_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                c_begin = virt_beta(1,r)
                c_end   = virt_beta(2,r)
                k_begin = occ_beta(1,s)
                k_end   = occ_beta(2,s)
                do k=max(j+1,k_begin),k_end
                  do c=max(a+1,c_begin),c_end
                     j_gamess = OldIndex_beta(j)
                     k_gamess = OldIndex_beta(k)
                     c_gamess = OldIndex_beta(c)
                     a_gamess = OldIndex_beta(a)
                     singles_cumaj_bb_deriv(j,a) = singles_cumaj_bb_deriv(j,a) + T2data%bb%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j_gamess,k_gamess,a_gamess,c_gamess)-TwoInts(j_gamess,k_gamess,c_gamess,a_gamess))/Newc%bb%m(a,j)%nsym(r,s)%n(c,k)
                     singles_cumaj_bb_deriv(j,c) = singles_cumaj_bb_deriv(j,c) + T2data%bb%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j_gamess,k_gamess,a_gamess,c_gamess)-TwoInts(j_gamess,k_gamess,c_gamess,a_gamess))/Newc%bb%m(a,j)%nsym(r,s)%n(c,k)
                     singles_cumaj_bb_deriv(k,a) = singles_cumaj_bb_deriv(k,a) + T2data%bb%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j_gamess,k_gamess,a_gamess,c_gamess)-TwoInts(j_gamess,k_gamess,c_gamess,a_gamess))/Newc%bb%m(a,j)%nsym(r,s)%n(c,k)
                     singles_cumaj_bb_deriv(k,c) = singles_cumaj_bb_deriv(k,c) + T2data%bb%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j_gamess,k_gamess,a_gamess,c_gamess)-TwoInts(j_gamess,k_gamess,c_gamess,a_gamess))/Newc%bb%m(a,j)%nsym(r,s)%n(c,k)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

end if

if(topsingles(1,1).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          a_begin = virt_alpha(1,p)
          a_end   = virt_alpha(2,p)
          j_begin = occ_alpha(1,q)
          j_end   = occ_alpha(2,q)
          do j=j_begin,j_end
            do a=a_begin,a_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                c_begin = virt_beta(1,r)
                c_end   = virt_beta(2,r)
                k_begin = occ_beta(1,s)
                k_end   = occ_beta(2,s)
                do k=k_begin,k_end
                  do c=c_begin,c_end
                     a_gamess = OldIndex_alpha(a)
                     j_gamess = OldIndex_alpha(j)
                     c_gamess = OldIndex_beta(c)
                     k_gamess = OldIndex_beta(k)
                      singles_cumaj_aa_deriv(j,a) = singles_cumaj_aa_deriv(j,a) + T2data%ab%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(j_gamess,k_gamess,a_gamess,c_gamess))/Newc%ab%m(a,j)%nsym(r,s)%n(c,k)
                      singles_cumaj_bb_deriv(k,c) = singles_cumaj_bb_deriv(k,c) + T2data%ab%m(a,j)%nsym(r,s)%n(c,k)*(TwoInts(k_gamess,j_gamess,c_gamess,a_gamess))/Newc%ab%m(a,j)%nsym(r,s)%n(c,k)
                  end do
                end do
              end do
            end do
          end do
        end do
     end do

end if

if(topsingles(1,0).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          if(p.gt.q) cycle
          i_begin = occ_alpha(1,p)
          i_end   = occ_alpha(2,p)
          j_begin = occ_alpha(1,q)
          j_end   = occ_alpha(2,q)
          do i=i_begin,i_end
            do j=max(i+1,j_begin),j_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                if(r.gt.s) cycle
                a_begin = virt_alpha(1,r)
                a_end   = virt_alpha(2,r)
                b_begin = virt_alpha(1,s)
                b_end   = virt_alpha(2,s)
                do a=a_begin,a_end
                  do b=max(a+1,b_begin),b_end
                    i_gamess = OldIndex_alpha(i)
                    j_gamess = OldIndex_alpha(j)
                    a_gamess = OldIndex_alpha(a)
                    b_gamess = OldIndex_alpha(b)
                    singles_cumocc_alpha_deriv(i) = singles_cumocc_alpha_deriv(i) + T2data%aa%m(a,i)%nsym(s,q)%n(b,j)*(TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)-TwoInts(i_gamess,j_gamess,b_gamess,a_gamess))/Newc%aa%m(a,i)%nsym(s,q)%n(b,j)
                    singles_cumocc_alpha_deriv(j) = singles_cumocc_alpha_deriv(j) + T2data%aa%m(a,i)%nsym(s,q)%n(b,j)*(TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)-TwoInts(i_gamess,j_gamess,b_gamess,a_gamess))/Newc%aa%m(a,i)%nsym(s,q)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          i_begin = occ_alpha(1,p)
          i_end   = occ_alpha(2,p)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                a_begin = virt_alpha(1,r)
                a_end   = virt_alpha(2,r)
                b_begin = virt_beta(1,s)
                b_end   = virt_beta(2,s)
                do a=a_begin,a_end
                  do b=b_begin,b_end
                    i_gamess = OldIndex_alpha(i)
                    j_gamess = OldIndex_beta(j)
                    a_gamess = OldIndex_alpha(a)
                    b_gamess = OldIndex_beta(b)
                    singles_cumocc_alpha_deriv(i) = singles_cumocc_alpha_deriv(i) + T2data%ab%m(a,i)%nsym(s,q)%n(b,j)*TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)/Newc%ab%m(a,i)%nsym(s,q)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do


      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          if(p.gt.q) cycle
          i_begin = occ_beta(1,p)
          i_end   = occ_beta(2,p)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          do i=i_begin,i_end
            do j=max(i+1,j_begin),j_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                if(r.gt.s) cycle
                a_begin = virt_beta(1,r)
                a_end   = virt_beta(2,r)
                b_begin = virt_beta(1,s)
                b_end   = virt_beta(2,s)
                do a=a_begin,a_end
                  do b=max(a+1,b_begin),b_end
                    i_gamess = OldIndex_beta(i)
                    j_gamess = OldIndex_beta(j)
                    a_gamess = OldIndex_beta(a)
                    b_gamess = OldIndex_beta(b)
                    singles_cumocc_beta_deriv(i) = singles_cumocc_beta_deriv(i) + T2data%bb%m(a,i)%nsym(s,q)%n(b,j)*(TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)-TwoInts(i_gamess,j_gamess,b_gamess,a_gamess))/Newc%bb%m(a,i)%nsym(s,q)%n(b,j)
                    singles_cumocc_beta_deriv(j) = singles_cumocc_beta_deriv(j) + T2data%bb%m(a,i)%nsym(s,q)%n(b,j)*(TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)-TwoInts(i_gamess,j_gamess,b_gamess,a_gamess))/Newc%bb%m(a,i)%nsym(s,q)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          i_begin = occ_alpha(1,p)
          i_end   = occ_alpha(2,p)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                a_begin = virt_alpha(1,r)
                a_end   = virt_alpha(2,r)
                b_begin = virt_beta(1,s)
                b_end   = virt_beta(2,s)
                do a=a_begin,a_end
                  do b=b_begin,b_end
                    i_gamess = OldIndex_alpha(i)
                    j_gamess = OldIndex_beta(j)
                    a_gamess = OldIndex_alpha(a)
                    b_gamess = OldIndex_beta(b)
                    singles_cumocc_beta_deriv(j) = singles_cumocc_beta_deriv(j) + T2data%ab%m(a,i)%nsym(s,q)%n(b,j)*TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)/Newc%ab%m(a,i)%nsym(s,q)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do




end if
if(topsingles(0,1).ne.0) then
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          if(p.gt.q) cycle
          i_begin = occ_alpha(1,p)
          i_end   = occ_alpha(2,p)
          j_begin = occ_alpha(1,q)
          j_end   = occ_alpha(2,q)
          do i=i_begin,i_end
            do j=max(i+1,j_begin),j_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                if(r.gt.s) cycle
                a_begin = virt_alpha(1,r)
                a_end   = virt_alpha(2,r)
                b_begin = virt_alpha(1,s)
                b_end   = virt_alpha(2,s)
                do a=a_begin,a_end
                  do b=max(a+1,b_begin),b_end
                    i_gamess = OldIndex_alpha(i)
                    j_gamess = OldIndex_alpha(j)
                    a_gamess = OldIndex_alpha(a)
                    b_gamess = OldIndex_alpha(b)
                    singles_cumvirt_alpha_deriv(a) = singles_cumvirt_alpha_deriv(a) + T2data%aa%m(a,i)%nsym(s,q)%n(b,j)*(TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)-TwoInts(i_gamess,j_gamess,b_gamess,a_gamess))/Newc%aa%m(a,i)%nsym(s,q)%n(b,j)
                    singles_cumvirt_alpha_deriv(b) = singles_cumvirt_alpha_deriv(b) + T2data%aa%m(a,i)%nsym(s,q)%n(b,j)*(TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)-TwoInts(i_gamess,j_gamess,b_gamess,a_gamess))/Newc%aa%m(a,i)%nsym(s,q)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          i_begin = occ_alpha(1,p)
          i_end   = occ_alpha(2,p)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                a_begin = virt_alpha(1,r)
                a_end   = virt_alpha(2,r)
                b_begin = virt_beta(1,s)
                b_end   = virt_beta(2,s)
                do a=a_begin,a_end
                  do b=b_begin,b_end
                    i_gamess = OldIndex_alpha(i)
                    j_gamess = OldIndex_beta(j)
                    a_gamess = OldIndex_alpha(a)
                    b_gamess = OldIndex_beta(b)
                    singles_cumvirt_alpha_deriv(a) = singles_cumvirt_alpha_deriv(a) + T2data%ab%m(a,i)%nsym(s,q)%n(b,j)*TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)/Newc%ab%m(a,i)%nsym(s,q)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do


      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          if(p.gt.q) cycle
          i_begin = occ_beta(1,p)
          i_end   = occ_beta(2,p)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          do i=i_begin,i_end
            do j=max(i+1,j_begin),j_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                if(r.gt.s) cycle
                a_begin = virt_beta(1,r)
                a_end   = virt_beta(2,r)
                b_begin = virt_beta(1,s)
                b_end   = virt_beta(2,s)
                do a=a_begin,a_end
                  do b=max(a+1,b_begin),b_end
                    i_gamess = OldIndex_beta(i)
                    j_gamess = OldIndex_beta(j)
                    a_gamess = OldIndex_beta(a)
                    b_gamess = OldIndex_beta(b)
                    singles_cumvirt_beta_deriv(a) = singles_cumvirt_beta_deriv(a) + T2data%bb%m(a,i)%nsym(s,q)%n(b,j)*(TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)-TwoInts(i_gamess,j_gamess,b_gamess,a_gamess))/Newc%bb%m(a,i)%nsym(s,q)%n(b,j)
                    singles_cumvirt_beta_deriv(b) = singles_cumvirt_beta_deriv(b) + T2data%bb%m(a,i)%nsym(s,q)%n(b,j)*(TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)-TwoInts(i_gamess,j_gamess,b_gamess,a_gamess))/Newc%bb%m(a,i)%nsym(s,q)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
      do symgp=1,numSG
        do t=1,numSG
          p=InvPdt(symgp)%upper(t)
          q=InvPdt(symgp)%lower(t)
          i_begin = occ_alpha(1,p)
          i_end   = occ_alpha(2,p)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              do v=1,numSG
                r = InvPdt(symgp)%upper(v)
                s = InvPdt(symgp)%lower(v)
                a_begin = virt_alpha(1,r)
                a_end   = virt_alpha(2,r)
                b_begin = virt_beta(1,s)
                b_end   = virt_beta(2,s)
                do a=a_begin,a_end
                  do b=b_begin,b_end
                    i_gamess = OldIndex_alpha(i)
                    j_gamess = OldIndex_beta(j)
                    a_gamess = OldIndex_alpha(a)
                    b_gamess = OldIndex_beta(b)
                    singles_cumvirt_beta_deriv(b) = singles_cumvirt_beta_deriv(b) + T2data%ab%m(a,i)%nsym(s,q)%n(b,j)*TwoInts(i_gamess,j_gamess,a_gamess,b_gamess)/Newc%ab%m(a,i)%nsym(s,q)%n(b,j)
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

end if






       do symgp=1,numSG
         k_begin = occ_alpha(1,symgp)
         k_end   = occ_alpha(2,symgp)
         c_begin = virt_alpha(1,symgp)
         c_end   = virt_alpha(2,symgp)
         do k=k_begin,k_end
           do c=c_begin,c_end
             T1deriv%a%o(k)%vsym(symgp)%v(c) = T1deriv%a%o(k)%vsym(symgp)%v(c) +-1*T1data%a%o(k)%vsym(symgp)%v(c)*2*(topsingles(0,0)*pizero_deriv + topsingles(1,0)*singles_cumocc_alpha_deriv(k) + topsingles(0,1)*singles_cumvirt_alpha_deriv(c) + topsingles(1,1)*(singles_cumaj_aa_deriv(k,c)))
           end do
         end do
       end do

       do symgp=1,numSG
         k_begin = occ_beta(1,symgp)
         k_end   = occ_beta(2,symgp)
         c_begin = virt_beta(1,symgp)
         c_end   = virt_beta(2,symgp)
         do k=k_begin,k_end
           do c=c_begin,c_end
             T1deriv%b%o(k)%vsym(symgp)%v(c) = T1deriv%b%o(k)%vsym(symgp)%v(c) +-1*T1data%b%o(k)%vsym(symgp)%v(c)*2*(topsingles(0,0)*pizero_deriv + topsingles(1,0)*singles_cumocc_beta_deriv(k) + topsingles(0,1)*singles_cumvirt_beta_deriv(c) + topsingles(1,1)*(singles_cumaj_bb_deriv(k,c)))
           end do
         end do
       end do




      do symgp=1,numSG
        k_begin = occ_alpha(1,symgp)
        k_end   = occ_alpha(2,symgp)
        c_begin = virt_alpha(1,symgp)
        c_end   = virt_alpha(2,symgp)
         do k=k_begin,k_end
           do c=c_begin,c_end
             Newc_singles%a%o(k)%vsym(symgp)%v(c) = singlesb0_topfac(0,0)*(pizero + singles_pizero) + singlesb0_topfac(1,0)*(cumocc_alpha(k) + singles_cumi_alpha(k)) + singlesb0_topfac(0,1)*(cumvirt_alpha(c) + singles_cuma_alpha(c)) + singlesb0_topfac(1,1)*(T1data%a%o(k)%vsym(symgp)%v(c)**2 + cumaj_aa(k,c))
             Newc_singles%a%o(k)%vsym(symgp)%v(c) = sqrt(abs(1.0 - Newc_singles%a%o(k)%vsym(symgp)%v(c)))
           end do
         end do
       end do


      do symgp=1,numSG
        k_begin = occ_beta(1,symgp)
        k_end   = occ_beta(2,symgp)
        c_begin = virt_beta(1,symgp)
        c_end   = virt_beta(2,symgp)
         do k=k_begin,k_end
           do c=c_begin,c_end
            Newc_singles%b%o(k)%vsym(symgp)%v(c) = singlesb0_topfac(0,0)*(pizero + singles_pizero) + singlesb0_topfac(1,0)*(cumocc_beta(k) + singles_cumi_beta(k)) + singlesb0_topfac(0,1)*(cumvirt_beta(c) + singles_cuma_beta(c)) + singlesb0_topfac(1,1)*(T1data%b%o(k)%vsym(symgp)%v(c)**2 + cumaj_bb(k,c))
             Newc_singles%b%o(k)%vsym(symgp)%v(c) = sqrt(abs(1.0 - Newc_singles%b%o(k)%vsym(symgp)%v(c)))
           end do
         end do
       end do




allocate(InverseBasisK1_alpha(1:numSG))
      do symgp=1,numSG
        counter = 1
        i_begin = occ_alpha(1,symgp)
        i_end   = occ_alpha(2,symgp)
        a_begin = virt_alpha(1,symgp)
        a_end   = virt_alpha(2,symgp)
        allocate(InverseBasisK1_alpha(symgp)%basis(i_begin:i_end,a_begin:a_end))
        do i=i_begin,i_end
          do a=a_begin,a_end
            InverseBasisK1_alpha(symgp)%basis(i,a) = counter
            counter = counter + 1
          end do
        end do
      end do

allocate(InverseBasisK1_beta(1:numSG))
      do symgp=1,numSG
        counter = 1
        i_begin = occ_beta(1,symgp)
        i_end   = occ_beta(2,symgp)
        a_begin = virt_beta(1,symgp)
        a_end   = virt_beta(2,symgp)
        allocate(InverseBasisK1_beta(symgp)%basis(i_begin:i_end,a_begin:a_end))
        do i=i_begin,i_end
          do a=a_begin,a_end
            InverseBasisK1_beta(symgp)%basis(i,a) = counter
            counter = counter + 1
          end do
        end do
      end do


      singles_pizero_deriv = 0.0
if(singlesb0_topfac(0,0).ne.0) then
      do symgp=1,numSG
        k_begin = occ_alpha(1,symgp)
        k_end   = occ_alpha(2,symgp)
        c_begin = virt_alpha(1,symgp)
        c_end   = virt_alpha(2,symgp)
         do k=k_begin,k_end
           do c=c_begin,c_end
             ckmap = InverseBasisK1_alpha(symgp)%basis(k,c)
             singles_pizero_deriv = singles_pizero_deriv + -1*T1data%a%o(k)%vsym(symgp)%v(c)*(2*K1(1,2)%aa%irrep(symgp)%block(ckmap,1)+K1TwoInts(1,2)%aa%irrep(symgp)%block(ckmap,1))/Newc_singles%a%o(k)%vsym(symgp)%v(c)
           end do
         end do
       end do

      do symgp=1,numSG
        k_begin = occ_beta(1,symgp)
        k_end   = occ_beta(2,symgp)
        c_begin = virt_beta(1,symgp)
        c_end   = virt_beta(2,symgp)
         do k=k_begin,k_end
           do c=c_begin,c_end
             ckmap = InverseBasisK1_beta(symgp)%basis(k,c)
             singles_pizero_deriv = singles_pizero_deriv + -1*T1data%b%o(k)%vsym(symgp)%v(c)*(2*K1(1,2)%bb%irrep(symgp)%block(ckmap,1)+K1TwoInts(1,2)%bb%irrep(symgp)%block(ckmap,1))/Newc_singles%b%o(k)%vsym(symgp)%v(c)
           end do
         end do
       end do
end if

      if(singlesb0_topfac(1,0).ne.0) then
        do symgp=1,numSG
          k_begin = occ_alpha(1,symgp)
          k_end   = occ_alpha(2,symgp)
          c_begin = virt_alpha(1,symgp)
          c_end   = virt_alpha(2,symgp)
            do k=k_begin,k_end
              do c=c_begin,c_end
                ckmap = InverseBasisK1_alpha(symgp)%basis(k,c)
                singles_cumi_alpha_deriv(k) = singles_cumi_alpha_deriv(k) + -1*T1data%a%o(k)%vsym(symgp)%v(c)*(2*K1(1,2)%aa%irrep(symgp)%block(ckmap,1)+K1TwoInts(1,2)%aa%irrep(symgp)%block(ckmap,1))/Newc_singles%a%o(k)%vsym(symgp)%v(c)
              end do
            end do
          end do
        do symgp=1,numSG
          k_begin = occ_beta(1,symgp)
          k_end   = occ_beta(2,symgp)
          c_begin = virt_beta(1,symgp)
          c_end   = virt_beta(2,symgp)
          do k=k_begin,k_end
            do c=c_begin,c_end
              ckmap = InverseBasisK1_beta(symgp)%basis(k,c)
              singles_cumi_beta_deriv(k) = singles_cumi_beta_deriv(k) + -1*T1data%b%o(k)%vsym(symgp)%v(c)*(2*K1(1,2)%bb%irrep(symgp)%block(ckmap,1) + K1TwoInts(1,2)%bb%irrep(symgp)%block(ckmap,1))/Newc_singles%b%o(k)%vsym(symgp)%v(c)
            end do
          end do
        end do
      end if

      if(singlesb0_topfac(0,1).ne.0) then
        do symgp=1,numSG
          k_begin = occ_alpha(1,symgp)
          k_end   = occ_alpha(2,symgp)
          c_begin = virt_alpha(1,symgp)
          c_end   = virt_alpha(2,symgp)
          do c=c_begin,c_end
            do k=k_begin,k_end
              ckmap = InverseBasisK1_alpha(symgp)%basis(k,c)
              singles_cuma_alpha_deriv(c) = singles_cuma_alpha_deriv(c) + -1*T1data%a%o(k)%vsym(symgp)%v(c)*(2*K1(1,2)%aa%irrep(symgp)%block(ckmap,1) + K1TwoInts(1,2)%aa%irrep(symgp)%block(ckmap,1))/Newc_singles%a%o(k)%vsym(symgp)%v(c)
            end do
          end do
        end do

        do symgp=1,numSG
          k_begin = occ_beta(1,symgp)
          k_end   = occ_beta(2,symgp)
          c_begin = virt_beta(1,symgp)
          c_end   = virt_beta(2,symgp)
          do c=c_begin,c_end
            do k=k_begin,k_end
              ckmap = InverseBasisK1_beta(symgp)%basis(k,c)
              singles_cuma_beta_deriv(c) = singles_cuma_beta_deriv(c) + -1*T1data%b%o(k)%vsym(symgp)%v(c)*(2*K1(1,2)%bb%irrep(symgp)%block(ckmap,1) + K1TwoInts(1,2)%bb%irrep(symgp)%block(ckmap,1))/Newc_singles%b%o(k)%vsym(symgp)%v(c)
            end do
          end do
        end do
       end if

       if(singlesb0_topfac(1,1).ne.0) then
         do symgp=1,numSG
           k_begin = occ_alpha(1,symgp)
           k_end   = occ_alpha(2,symgp)
           c_begin = virt_alpha(1,symgp)
           c_end   = virt_alpha(2,symgp)
           do k=k_begin,k_end
             do c=c_begin,c_end
               ckmap = InverseBasisK1_alpha(symgp)%basis(k,c)
               singles_ai_alpha_deriv(c,k) = -1*T1data%a%o(k)%vsym(symgp)%v(c)*(2*K1(1,2)%aa%irrep(symgp)%block(ckmap,1) + K1TwoInts(1,2)%aa%irrep(symgp)%block(ckmap,1))/Newc_singles%a%o(k)%vsym(symgp)%v(c)
             end do
          end do
        end do

         do symgp=1,numSG
           k_begin = occ_beta(1,symgp)
           k_end   = occ_beta(2,symgp)
           c_begin = virt_beta(1,symgp)
           c_end   = virt_beta(2,symgp)
           do k=k_begin,k_end
             do c=c_begin,c_end
               ckmap = InverseBasisK1_beta(symgp)%basis(k,c)
               singles_ai_beta_deriv(c,k) = -1*T1data%b%o(k)%vsym(symgp)%v(c)*(2*K1(1,2)%bb%irrep(symgp)%block(ckmap,1) + K1TwoInts(1,2)%bb%irrep(symgp)%block(ckmap,1))/Newc_singles%b%o(k)%vsym(symgp)%v(c)
             end do
          end do
        end do
       end if



              do symgp=1,numSG
                do t=1,numSG
                  p=InvPdt(symgp)%upper(t)
                  q=InvPdt(symgp)%lower(t)
                  i_begin = occ_alpha(1,p)
                  i_end   = occ_alpha(2,p)
                  a_begin = virt_alpha(1,q)
                  a_end   = virt_alpha(2,q)
                  do i=i_begin,i_end
                    do a=a_begin,a_end
                      do v=1,numSG
                        r = InvPdt(symgp)%upper(v)
                        s = InvPdt(symgp)%lower(v)
                        j_begin = occ_beta(1,r)
                        j_end   = occ_beta(2,r)
                        b_begin = virt_beta(1,s)
                        b_end   = virt_beta(2,s)
                        do j=j_begin,j_end
                          do b=b_begin,b_end
                            T2derivT1topfac%ab%m(a,i)%nsym(s,r)%n(b,j) = T2data%ab%m(a,i)%nsym(s,r)%n(b,j)*(singlesb0_topfac(0,0)*singles_pizero_deriv + singlesb0_topfac(1,0)*(singles_cumi_alpha_deriv(i) + singles_cumi_beta_deriv(j)) + singlesb0_topfac(0,1)*(singles_cuma_alpha_deriv(a) + singles_cuma_beta_deriv(b)) + singlesb0_topfac(1,1)*(singles_ai_alpha_deriv(a,i) + singles_ai_beta_deriv(b,j)))

                          end do
                        end do
                      end do
                    end do
                  end do

                end do
              end do
              do symgp=1,numSG
                do t=1,numSG
                  p=InvPdt(symgp)%upper(t)
                  q=InvPdt(symgp)%lower(t)
                  i_begin = occ_alpha(1,p)
                  i_end   = occ_alpha(2,p)
                  a_begin = virt_alpha(1,q)
                  a_end   = virt_alpha(2,q)
                  do i=i_begin,i_end
                    do a=a_begin,a_end
                      do v=1,numSG
                        r = InvPdt(symgp)%upper(v)
                        s = InvPdt(symgp)%lower(v)
                        j_begin = occ_alpha(1,r)
                        j_end   = occ_alpha(2,r)
                        b_begin = virt_alpha(1,s)
                        b_end   = virt_alpha(2,s)
                        do j=max(i+1,j_begin),j_end
                          do b=max(a+1,b_begin),b_end
                            T2derivT1topfac%aa%m(a,i)%nsym(s,r)%n(b,j) = T2data%aa%m(a,i)%nsym(s,r)%n(b,j)*(singlesb0_topfac(0,0)*singles_pizero_deriv + singlesb0_topfac(1,0)*(singles_cumi_alpha_deriv(i) + singles_cumi_alpha_deriv(j)) + singlesb0_topfac(0,1)*(singles_cuma_alpha_deriv(a)+singles_cuma_alpha_deriv(b)) + singlesb0_topfac(1,1)*(singles_ai_alpha_deriv(a,i) +singles_ai_alpha_deriv(b,j)  + singles_ai_alpha_deriv(a,j) + singles_ai_alpha_deriv(b,i)))

                          end do
                        end do
                      end do
                    end do
                  end do
                end do
              end do
              do symgp=1,numSG
                do t=1,numSG
                  p=InvPdt(symgp)%upper(t)
                  q=InvPdt(symgp)%lower(t)
                  i_begin = occ_beta(1,p)
                  i_end   = occ_beta(2,p)
                  a_begin = virt_beta(1,q)
                  a_end   = virt_beta(2,q)
                  do i=i_begin,i_end
                    do a=a_begin,a_end
                      do v=1,numSG
                        r = InvPdt(symgp)%upper(v)
                        s = InvPdt(symgp)%lower(v)
                        j_begin = occ_beta(1,r)
                        j_end   = occ_beta(2,r)
                        b_begin = virt_beta(1,s)
                        b_end   = virt_beta(2,s)
                        do j=max(i+1,j_begin),j_end
                          do b=max(a+1,b_begin),b_end
                              T2derivT1topfac%bb%m(a,i)%nsym(s,r)%n(b,j) =T2data%bb%m(a,i)%nsym(s,r)%n(b,j)*(singlesb0_topfac(0,0)*singles_pizero_deriv + singlesb0_topfac(1,0)*(singles_cumi_beta_deriv(i) + singles_cumi_beta_deriv(j)) + singlesb0_topfac(0,1)*(singles_cuma_beta_deriv(a) + singles_cuma_beta_deriv(b)) + singlesb0_topfac(1,1)*(singles_ai_beta_deriv(a,i) + singles_ai_beta_deriv(a,j) + singles_ai_beta_deriv(b,i) + singles_ai_beta_deriv(b,j)))
                          end do
                        end do
                      end do
                    end do
                  end do
                end do
              end do



      do symgp=1,numSG
        k_begin = occ_alpha(1,symgp)
        k_end   = occ_alpha(2,symgp)
        c_begin = virt_alpha(1,symgp)
        c_end   = virt_alpha(2,symgp)
         do k=k_begin,k_end
           do c=c_begin,c_end
             DerivNewc_singles%a%o(k)%vsym(symgp)%v(c) =T1data%a%o(k)%vsym(symgp)%v(c)*(singlesb0_topfac(0,0)*singles_pizero_deriv + singlesb0_topfac(1,0)*singles_cumi_alpha_deriv(k) + singlesb0_topfac(0,1)*singles_cuma_alpha_deriv(c) + singlesb0_topfac(1,1)*singles_ai_alpha_deriv(c,k))
           end do
         end do
       end do

      do symgp=1,numSG
        k_begin = occ_beta(1,symgp)
        k_end   = occ_beta(2,symgp)
        c_begin = virt_beta(1,symgp)
        c_end   = virt_beta(2,symgp)
         do k=k_begin,k_end
           do c=c_begin,c_end
             DerivNewc_singles%b%o(k)%vsym(symgp)%v(c) =T1data%b%o(k)%vsym(symgp)%v(c)*(singlesb0_topfac(0,0)*singles_pizero_deriv + singlesb0_topfac(1,0)*singles_cumi_beta_deriv(k) + singlesb0_topfac(0,1)*singles_cuma_beta_deriv(c) + singlesb0_topfac(1,1)*singles_ai_beta_deriv(c,k))
           end do
         end do
       end do

     deallocate(InverseBasisK1_alpha)
     deallocate(InverseBasisK1_beta)

     Call CPU_TIME(time_end)
     time_topfactor = time_topfactor + (time_end - time_begin)

      end subroutine TopFactorOS

!> @brief Builds the D1 matrix (with optimized parameters) for open shell calculations
!> @author Christine Schwerdtfeger and David Mazziotti
      subroutine BuildD1OS(T2data,T1data,numSG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,ReshapedMatrixDim,InvPdt,filename,Newc_singles)

      Use TypeMod
      Use InterfaceMod
      Use TimeMod, only : time_buildd1
      Implicit NONE

      type(T2) :: T2data
      type(T1) :: T1data, Newc_singles
      integer :: numSG,numOcc,numVirt
      integer, intent(IN), dimension(1:2,1:numSG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
      type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
      type(ReshapedMat), allocatable, dimension(:)  :: DerivReshapes, Reshapes, TempReshape, TempDerivReshape
      integer, dimension(1:numSG,1:numSG) :: ProductTable
      type(symmetry), intent(IN), dimension(:) :: InvPdt(1:numSG)
      character(len=35) :: filename
      character(len=100) :: D1alphafile, D1betafile

      integer :: i,p,a,pos,j, counter, q
      type(D1) :: D1alpha_matrix(1:numSG), D1beta_matrix(1:numSG)
      integer, allocatable, dimension(:) :: numocc_alpha_sg, numocc_beta_sg, numvirt_alpha_sg, numvirt_beta_sg
      integer :: i_begin,i_end, a_begin,a_end,row,col
      double precision, allocatable, dimension(:,:) :: TempMat
      real :: time_begin, time_end

      double precision, allocatable, dimension(:) :: UpperDiag
      double precision, allocatable, dimension(:) :: EigVal
      double precision, allocatable, dimension(:,:) :: EigVec
      double precision, allocatable, dimension(:) :: WORK
      integer, allocatable, dimension(:) :: IWORK
      integer :: dimD1block, INFO
      double precision, allocatable, dimension(:) :: NatOrbOccNums
      integer :: NumOccNums, nval
      double precision :: temp


      Call cpu_time(time_begin)

      allocate(numocc_alpha_sg(1:numSG))
      allocate(numvirt_alpha_sg(1:numSG))
      allocate(numocc_beta_sg(1:numSG))
      allocate(numvirt_beta_sg(1:numSG))
      do p=1,numSG
        i_begin = occ_alpha(1,p)
        i_end   = occ_alpha(2,p)
        a_begin = virt_alpha(1,p)
        a_end   = virt_alpha(2,p)
        numocc_alpha_sg(p) = i_end - i_begin + 1
        numvirt_alpha_sg(p) = a_end - a_begin + 1
      end do

      do p=1,numSG
        i_begin = occ_beta(1,p)
        i_end   = occ_beta(2,p)
        a_begin = virt_beta(1,p)
        a_end   = virt_beta(2,p)
        numocc_beta_sg(p) = i_end - i_begin + 1
        numvirt_beta_sg(p) = a_end - a_begin + 1
      end do


      do p=1,numSG
        allocate(D1alpha_matrix(p)%D1block(1:(numocc_alpha_sg(p)+numvirt_alpha_sg(p)),1:(numocc_alpha_sg(p)+numvirt_alpha_sg(p))))
        D1alpha_matrix(p)%D1block = 0.0
      end do

      do p=1,numSG
        allocate(D1beta_matrix(p)%D1block(1:(numocc_beta_sg(p)+numvirt_beta_sg(p)),1:(numocc_beta_sg(p)+numvirt_beta_sg(p))))
        D1beta_matrix(p)%D1block = 0.0
      end do

      do p=1,numSG
        do i=1,numocc_alpha_sg(p)
          D1alpha_matrix(p)%D1block(i,i) = 1.0
        end do
      end do

      do p=1,numSG
        do i=1,numocc_beta_sg(p)
          D1beta_matrix(p)%D1block(i,i) = 1.0
        end do
      end do

       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ialphaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)

       do p=1,numSG
         if(numocc_alpha_sg(p).ne.0) then
           D1alpha_matrix(p)%D1block(1:numocc_alpha_sg(p),1:numocc_alpha_sg(p)) = -1*matmul(transpose(Reshapes(p)%ReshapedMatrix),Reshapes(p)%ReshapedMatrix) + D1alpha_matrix(p)%D1block(1:numocc_alpha_sg(p),1:numocc_alpha_sg(p))
         end if
       end do
      deallocate(Reshapes,DerivReshapes)
      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
       Call reshape_t1t1_ialphaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        if(numocc_alpha_sg(p).ne.0) then
          D1alpha_matrix(p)%D1block(1:numocc_alpha_sg(p),1:numocc_alpha_sg(p)) = -1*matmul(transpose(Reshapes(p)%ReshapedMatrix),Reshapes(p)%ReshapedMatrix) + D1alpha_matrix(p)%D1block(1:numocc_alpha_sg(p),1:numocc_alpha_sg(p))
        end if
      end do

      do p=1,numSG
        if(numvirt_alpha_sg(p).ne.0) then
          D1alpha_matrix(p)%D1block(numocc_alpha_sg(p)+1:numocc_alpha_sg(p)+numvirt_alpha_sg(p),numocc_alpha_sg(p)+1:numocc_alpha_sg(p)+numvirt_alpha_sg(p)) = matmul(Reshapes(p)%ReshapedMatrix,transpose(Reshapes(p)%ReshapedMatrix)) + D1alpha_matrix(p)%D1block(numocc_alpha_sg(p)+1:numocc_alpha_sg(p)+numvirt_alpha_sg(p),numocc_alpha_sg(p)+1:numocc_alpha_sg(p)+numvirt_alpha_sg(p))
        end if
      end do
      deallocate(Reshapes,DerivReshapes)
      allocate(Reshapes(1:numSG),DerivReshapes(1:numSG))
      Call reshape_aalphaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        if(numvirt_alpha_sg(p).ne.0) then
          D1alpha_matrix(p)%D1block(numocc_alpha_sg(p)+1:numocc_alpha_sg(p)+numvirt_alpha_sg(p),numocc_alpha_sg(p)+1:numocc_alpha_sg(p)+numvirt_alpha_sg(p)) = matmul(transpose(Reshapes(p)%ReshapedMatrix),Reshapes(p)%ReshapedMatrix) + D1alpha_matrix(p)%D1block(numocc_alpha_sg(p)+1:numocc_alpha_sg(p)+numvirt_alpha_sg(p),numocc_alpha_sg(p)+1:numocc_alpha_sg(p)+numvirt_alpha_sg(p))
        end if
      end do
      deallocate(Reshapes,DerivReshapes)

       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ibetaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)

       do p=1,numSG
         if(numocc_beta_sg(p).ne.0) then
            D1beta_matrix(p)%D1block(1:numocc_beta_sg(p),1:numocc_beta_sg(p)) = -1*matmul(Reshapes(p)%ReshapedMatrix,transpose(Reshapes(p)%ReshapedMatrix)) + D1beta_matrix(p)%D1block(1:numocc_beta_sg(p),1:numocc_beta_sg(p))
         end if
       end do
      deallocate(Reshapes,DerivReshapes)
      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
       Call reshape_t1t1_ibetaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        if(numocc_beta_sg(p).ne.0) then
          D1beta_matrix(p)%D1block(1:numocc_beta_sg(p),1:numocc_beta_sg(p)) = -1*matmul(transpose(Reshapes(p)%ReshapedMatrix),Reshapes(p)%ReshapedMatrix) + D1beta_matrix(p)%D1block(1:numocc_beta_sg(p),1:numocc_beta_sg(p))
        end if
      end do

      do p=1,numSG
        if(numvirt_beta_sg(p).ne.0) then
          D1beta_matrix(p)%D1block(numocc_beta_sg(p)+1:numocc_beta_sg(p)+numvirt_beta_sg(p),numocc_beta_sg(p)+1:numocc_beta_sg(p)+numvirt_beta_sg(p)) = matmul(Reshapes(p)%ReshapedMatrix,transpose(Reshapes(p)%ReshapedMatrix)) + D1beta_matrix(p)%D1block(numocc_beta_sg(p)+1:numocc_beta_sg(p)+numvirt_beta_sg(p),numocc_beta_sg(p)+1:numocc_beta_sg(p)+numvirt_beta_sg(p))
        end if
      end do
      deallocate(Reshapes,DerivReshapes)
      allocate(Reshapes(1:numSG),DerivReshapes(1:numSG))
      Call reshape_abetaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        if(numvirt_beta_sg(p).ne.0) then
          D1beta_matrix(p)%D1block(numocc_beta_sg(p)+1:numocc_beta_sg(p)+numvirt_beta_sg(p),numocc_beta_sg(p)+1:numocc_beta_sg(p)+numvirt_beta_sg(p)) = matmul(Reshapes(p)%ReshapedMatrix,transpose(Reshapes(p)%ReshapedMatrix)) + D1beta_matrix(p)%D1block(numocc_beta_sg(p)+1:numocc_beta_sg(p)+numvirt_beta_sg(p),numocc_beta_sg(p)+1:numocc_beta_sg(p)+numvirt_beta_sg(p))
        end if
      end do
      deallocate(Reshapes,DerivReshapes)




      do p=1,numSG
        i_begin = occ_alpha(1,p)
        i_end   = occ_alpha(2,p)
        a_begin = virt_alpha(1,p)
        a_end   = virt_alpha(2,p)
        do i=i_begin,i_end
          do a=a_begin,a_end
          row = a - a_begin + 1 + numocc_alpha_sg(p)
          col = i - i_begin + 1
            D1alpha_matrix(p)%D1block(row,col) = D1alpha_matrix(p)%D1block(row,col) + T1data%a%o(i)%vsym(p)%v(a)*Newc_singles%a%o(i)%vsym(p)%v(a)
            D1alpha_matrix(p)%D1block(col,row) = D1alpha_matrix(p)%D1block(col,row) + T1data%a%o(i)%vsym(p)%v(a)*Newc_singles%a%o(i)%vsym(p)%v(a)
          end do
        end do
      end do


      allocate(Reshapes(1:numSG),DerivReshapes(1:numSG))
      allocate(TempReshape(1:numSG),TempDerivReshape(1:numSG))
     Call reshape_ajaa_t1OS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibrowOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      do p=1,numSG
        allocate(TempMat(1,1:numocc_alpha_sg(p)*numvirt_alpha_sg(p)))
        i_begin = occ_alpha(1,p)
        i_end   = occ_alpha(2,p)
        a_begin = virt_alpha(1,p)
        a_end   = virt_alpha(2,p)
        TempMat = matmul4(TempReshape(p)%ReshapedMatrix,Reshapes(p)%ReshapedMatrix)
        pos = 1
        do i=i_begin,i_end
          do a=a_begin,a_end
            row = a - a_begin + 1 + numocc_alpha_sg(p)
            col = i - i_begin + 1
            D1alpha_matrix(p)%D1block(row,col) = TempMat(1,pos) + D1alpha_matrix(p)%D1block(row,col)
            D1alpha_matrix(p)%D1block(col,row) = TempMat(1,pos) + D1alpha_matrix(p)%D1block(col,row)
            pos = pos + 1
          end do
        end do
        deallocate(TempMat)
      end do

      deallocate(Reshapes,DerivReshapes,TempReshape,TempDerivReshape)

      do p=1,numSG
        i_begin = occ_beta(1,p)
        i_end   = occ_beta(2,p)
        a_begin = virt_beta(1,p)
        a_end   = virt_beta(2,p)
        do i=i_begin,i_end
          do a=a_begin,a_end
          row = a - a_begin + 1 + numocc_beta_sg(p)
          col = i - i_begin + 1
            D1beta_matrix(p)%D1block(row,col) = D1beta_matrix(p)%D1block(row,col) + T1data%b%o(i)%vsym(p)%v(a)*Newc_singles%b%o(i)%vsym(p)%v(a)
            D1beta_matrix(p)%D1block(col,row) = D1beta_matrix(p)%D1block(col,row) + T1data%b%o(i)%vsym(p)%v(a)*Newc_singles%b%o(i)%vsym(p)%v(a)
          end do
        end do
      end do


      allocate(Reshapes(1:numSG),DerivReshapes(1:numSG))
      allocate(TempReshape(1:numSG),TempDerivReshape(1:numSG))
     Call reshape_ajbb_t1OS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibrowOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)

      do p=1,numSG
        allocate(TempMat(1,1:numocc_beta_sg(p)*numvirt_beta_sg(p)))
        i_begin = occ_beta(1,p)
        i_end   = occ_beta(2,p)
        a_begin = virt_beta(1,p)
        a_end   = virt_beta(2,p)
        TempMat = matmul4(TempReshape(p)%ReshapedMatrix,Reshapes(p)%ReshapedMatrix)
        pos = 1
        do i=i_begin,i_end
          do a=a_begin,a_end
            row = a - a_begin + 1 + numocc_beta_sg(p)
            col = i - i_begin + 1
            D1beta_matrix(p)%D1block(row,col) = TempMat(1,pos) + D1beta_matrix(p)%D1block(row,col)
            D1beta_matrix(p)%D1block(col,row) = TempMat(1,pos) + D1beta_matrix(p)%D1block(col,row)
            pos = pos + 1
          end do
        end do
        deallocate(TempMat)
      end do

      deallocate(Reshapes,DerivReshapes,TempReshape,TempDerivReshape)



        Call getenv("D1WRT",D1alphafile)
      open(unit=3,file=D1alphafile,action='write')
      NumOccNums = 0
      do p=1,numSG
        write(3,*) numocc_alpha_sg(p)+numvirt_alpha_sg(p)
        NumOccNums = NumOccNums + numocc_alpha_sg(p) +numvirt_alpha_sg(p)
      end do
      do p=1,numSG
        do i=1,numocc_alpha_sg(p)+numvirt_alpha_sg(p)
          do j=1,numocc_alpha_sg(p)+numvirt_alpha_sg(p)
            write(3,*) D1alpha_matrix(p)%D1block(i,j)
          end do
        end do
      end do

       Call getenv("D1WRT",D1betafile)
      open(unit=3,file=D1betafile,action='write')
      do p=1,numSG
        write(3,*) numocc_beta_sg(p)+numvirt_beta_sg(p)
      end do
      do p=1,numSG
        do i=1,numocc_beta_sg(p)+numvirt_beta_sg(p)
          do j=1,numocc_beta_sg(p)+numvirt_beta_sg(p)
            write(3,*) D1beta_matrix(p)%D1block(i,j)
          end do
        end do
      end do

       write(*,*) 'BUILDING AND DIAGONALIZING THE 1-RDM...'
       allocate(NatOrbOccNums(1:NumOccNums))
       NatOrbOccNums(1:NumOccNums) = 0.d0
       nval = 1
      do i=1,numSG
        dimD1block = size(D1alpha_matrix(i)%D1block,1)
        if(dimD1block.eq.0) then
          cycle
        else
          allocate(UpperDiag(1:dimD1block*(dimD1block+1)/2))
          allocate(EigVal(1:dimD1block))
          allocate(WORK(1:3*dimD1block))
          allocate(EigVec(1:1,1:1))
          allocate(IWORK(1:1))
          UpperDiag(1:dimD1block*(dimD1block+1)/2) = 0.D0
          EigVal(1:dimD1block) = 0.d0
          WORK(1:3*dimD1block) = 0.d0
          IWORK(1:1) = 0
          counter = 1
          do p=1,dimD1block
            do q=1,p
              UpperDiag(counter) = D1alpha_matrix(i)%D1block(q,p)
              counter = counter + 1
            end do
          end do
          Call DSPEVD('N','U',dimD1block,UpperDiag,EigVal,EigVec,dimD1block,WORK,3*dimD1block,IWORK,1,INFO)
          do q=1,dimD1block
             NatOrbOccNums(nval) = EigVal(q)
             nval = nval + 1
          end do
          deallocate(UpperDiag,EigVal,WORK,EigVec,IWORK)
        end if
      end do

       do i=1,size(NatOrbOccNums,1)
         do j=i+1,size(NatOrbOccNums,1)
           if(NatOrbOccNums(i).lt.NatOrbOccNums(j)) then
           temp = NatOrbOccNums(j)
           NatOrbOccNums(j) = NatOrbOccNums(i)
           NatOrbOccNums(i) = temp
           end if
        end do
      end do
      write(*,*) 'NATURAL ORBITAL OCCUPATION NUMBERS (ALPHA 1-RDM)'
      write(*,*) '(THE EIGENVALUES OF THE 1-RDM IN THE MO BASIS, EXCLUDING THE CORE ORBITALS)'
      write(*,*) 'ORBITAL #    OCCUPATION #'
      write(*,*) '--------------------------'
      do i=1,size(NatOrbOccNums,1)
        write(*,27) i,NatOrbOccNums(i)
      end do
      27 FORMAT(I5,9X,F10.6,1X)



      NatOrbOccNums(1:NumOccNums) = 0.d0
      nval = 1
      do i=1,numSG
        dimD1block = size(D1beta_matrix(i)%D1block,1)
        if(dimD1block.eq.0) then
          cycle
        else
          allocate(UpperDiag(1:dimD1block*(dimD1block+1)/2))
          allocate(EigVal(1:dimD1block))
          allocate(WORK(1:3*dimD1block))
          allocate(EigVec(1:1,1:1))
          allocate(IWORK(1:1))
          UpperDiag(1:dimD1block*(dimD1block+1)/2) = 0.D0
          EigVal(1:dimD1block) = 0.d0
          WORK(1:3*dimD1block) = 0.d0
          IWORK(1:1) = 0
          counter = 1
          do p=1,dimD1block
            do q=1,p
              UpperDiag(counter) = D1beta_matrix(i)%D1block(q,p)
              counter = counter + 1
            end do
          end do
          Call DSPEVD('N','U',dimD1block,UpperDiag,EigVal,EigVec,dimD1block,WORK,3*dimD1block,IWORK,1,INFO)
          do q=1,dimD1block
            NatOrbOccNums(nval) =  EigVal(q)
            nval = nval + 1
          end do
          deallocate(UpperDiag,EigVal,WORK,EigVec,IWORK)
        end if
      end do

      do i=1,size(NatOrbOccNums,1)
        do j=i+1,size(NatOrbOccNums,1)
          if(NatOrbOccNums(i).lt.NatOrbOccNums(j)) then
            temp = NatOrbOccNums(j)
            NatOrbOccNums(j) = NatOrbOccNums(i)
            NatOrbOccNums(i) = temp
          end if
        end do
      end do
      write(*,*) 'NATURAL ORBITAL OCCUPATION NUMBERS (BETA 1-RDM):'
      write(*,*) '(THE EIGENVALUES OF THE 1-RDM IN THE MO BASIS, EXCLUDING THE CORE ORBITALS)'
      write(*,*) 'ORBITAL #     OCCUPATION #'
      write(*,*) '--------------------------'
      do i=1,size(NatOrbOccNums,1)
        write(*,27)i, NatOrbOccNums(i)
      end do
      write(*,*) '  '




      Call cpu_time(time_end)
      time_buildd1 = time_end - time_begin + time_buildd1
      end subroutine BuildD1OS

!> @brief Builds the topological factor the T1 coefficients 
!> @author Christine Schwerdtfeger and David Mazziotti
      subroutine BuildNewc_singles(Newc_singles,T2data,T1data,topsingles,numSG,occ,virt,InvPdt,ProductTable)

       Use InterfaceMod
       Use TypeMod
       IMPLICIT None


      type(T1) :: Newc_singles
      type(T2) :: T2data
      type(T1) :: T1data
      real(8), dimension(0:1,0:1) :: topsingles(0:1,0:1)
      integer :: numSG
      integer, intent(IN), dimension(1:2,1:numSG) :: occ,virt
      type(symmetry), intent(IN), dimension(:) :: InvPdt(1:numSG)
      integer, dimension(1:numSG,1:numSG) :: ProductTable



      double precision :: pizero, pizero_singles
      double precision, allocatable, dimension(:) :: cumocc, cumvirt, cumocc_singles,cumvirt_singles
      double precision, allocatable, dimension(:,:) :: cumia_aa
      integer :: numOcc, numVirt
      integer :: p,q,r,s,t,v,symgp,aksym,i,k,l,c,d,cisym,j,a
      integer :: i_begin,i_end, k_begin,k_end,l_begin,l_end,c_begin,c_end,d_begin,d_end,j_begin,j_end
      integer :: a_begin,a_end


      numOcc = 0
      numVirt = 0
      do p=1,numSG
        i_begin = occ(1,p)
        i_end   = occ(2,p)
        a_begin = virt(1,p)
        a_end   = virt(2,p)
        numOcc = numOcc + i_end - i_begin + 1
        numVirt = numVirt + a_end - a_begin + 1
      end do

       allocate(cumocc(1:numOcc))
       allocate(cumvirt(numOcc+1:numOcc+numVirt))
       allocate(cumocc_singles(1:numOcc))
       allocate(cumvirt_singles(numOcc+1:numOcc+numVirt))
       allocate(cumia_aa(1:numOcc,numOcc+1:numOcc+numVirt))
       cumocc(1:numOcc) = 0.0
       cumocc(1:numOcc) = 0.0
       cumvirt(numOcc+1:numOcc+numVirt) = 0.0
       cumocc_singles(1:numOcc) = 0.0
       cumvirt_singles(numOcc+1:numOcc+numVirt) = 0.0
       cumia_aa(1:numOcc,numOcc+1:numOcc+numVirt) = 0.0
       pizero = 0.0
       pizero_singles = 0.0




      if(topsingles(0,0).ne.0) then
       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           k_begin = occ(1,p)
           k_end   = occ(2,p)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
           do k=k_begin,k_end
             do c=c_begin,c_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 l_begin = occ(1,r)
                 l_end   = occ(2,r)
                 d_begin = virt(1,s)
                 d_end   = virt(2,s)
                 do l=l_begin,l_end
                   do d=d_begin,d_end
                     pizero = pizero +T2data%ab%m(c,k)%nsym(s,r)%n(d,l)**2
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           k_begin = occ(1,p)
           k_end   = occ(2,p)
           c_begin = virt(1,q)
           c_end   = virt(2,q)
             do k=k_begin,k_end
               do c=c_begin,c_end
                 do v=1,numSG
                   r = InvPdt(symgp)%upper(v)
                   s = InvPdt(symgp)%lower(v)
                   l_begin = occ(1,r)
                   l_end   = occ(2,r)
                   d_begin = virt(1,s)
                   d_end   = virt(2,s)
                   do l=max(k+1,l_begin),l_end
                     do d=max(c+1,d_begin),d_end
                       pizero = pizero + 2*T2data%aa%m(c,k)%nsym(s,r)%n(d,l)**2
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do
       end if

     if(topsingles(1,0).ne.0) then
      do symgp=1,numSG
        i_begin = occ(1,symgp)
        i_end   = occ(2,symgp)
        do i=i_begin,i_end
          do p=1,numSG
            c_begin = virt(1,p)
            c_end   = virt(2,p)
            cisym = ProductTable(symgp,p)
            do c=c_begin,c_end
              do t=1,numSG
                q = InvPdt(cisym)%upper(t)
                r = InvPdt(cisym)%lower(t)
                if(p>r) cycle
                k_begin = occ(1,q)
                k_end   = occ(2,q)
                d_begin = virt(1,r)
                d_end   = virt(2,r)
                do k=k_begin,k_end
                  do d=max(c+1,d_begin),d_end
                    cumocc(i) = cumocc(i) + T2data%aa%m(c,i)%nsym(r,q)%n(d,k)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
      do symgp=1,numSG
        i_begin = occ(1,symgp)
        i_end   = occ(2,symgp)
        do i=i_begin,i_end
          do p=1,numSG
            c_begin = virt(1,p)
            c_end   = virt(2,p)
            cisym = ProductTable(symgp,p)
            do c=c_begin,c_end
              do t=1,numSG
                q = InvPdt(cisym)%upper(t)
                r = InvPdt(cisym)%lower(t)
                k_begin = occ(1,q)
                k_end   = occ(2,q)
                d_begin = virt(1,r)
                d_end   = virt(2,r)
                do k=k_begin,k_end
                  do d=d_begin,d_end
                    cumocc(i) = cumocc(i) + T2data%ab%m(c,i)%nsym(r,q)%n(d,k)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
      end if

      if(topsingles(0,1).ne.0) then
      do symgp=1,numSG
        a_begin = virt(1,symgp)
        a_end   = virt(2,symgp)
        do a=a_begin,a_end
          do p=1,numSG
            k_begin = occ(1,p)
            k_end   = occ(2,p)
            aksym = ProductTable(symgp,p)
            do k=k_begin,k_end
              do t=1,numSG
                q = InvPdt(aksym)%upper(t)
                r = InvPdt(aksym)%lower(t)
                if(p>q) cycle
                l_begin = occ(1,q)
                l_end   = occ(2,q)
                c_begin = virt(1,r)
                c_end   = virt(2,r)
                do l=max(k+1,l_begin),l_end
                  do c=c_begin,c_end
                    cumvirt(a) = cumvirt(a) + T2data%aa%m(a,k)%nsym(r,q)%n(c,l)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

      do symgp=1,numSG
        a_begin = virt(1,symgp)
        a_end   = virt(2,symgp)
        do a=a_begin,a_end
          do p=1,numSG
            k_begin = occ(1,p)
            k_end   = occ(2,p)
            aksym = ProductTable(symgp,p)
            do k=k_begin,k_end
              do t=1,numSG
                q = InvPdt(aksym)%upper(t)
                r = InvPdt(aksym)%lower(t)
                l_begin = occ(1,q)
                l_end   = occ(2,q)
                c_begin = virt(1,r)
                c_end   = virt(2,r)
                do l=l_begin,l_end
                  do c=c_begin,c_end
                    cumvirt(a) = cumvirt(a) + T2data%ab%m(a,k)%nsym(r,q)%n(c,l)**2
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
      end if

      if(topsingles(1,1).ne.0) then
         do symgp=1,numSG
           do t=1,numSG
             p = InvPdt(symgp)%upper(t)
             q = InvPdt(symgp)%lower(t)
             a_begin = virt(1,p)
             a_end   = virt(2,p)
             j_begin = occ(1,q)
             j_end   = occ(2,q)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do v=1,numSG
                   r = InvPdt(symgp)%upper(v)
                   s = InvPdt(symgp)%lower(v)
                   c_begin = virt(1,r)
                   c_end   = virt(2,r)
                   k_begin = occ(1,s)
                   k_end   = occ(2,s)
                   do k=k_begin,k_end
                     do c=c_begin,c_end
                       cumia_aa(j,a) = cumia_aa(j,a) + T2data%aa%m(a,j)%nsym(r,s)%n(c,k)**2
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do
         do symgp=1,numSG
           do t=1,numSG
             p = InvPdt(symgp)%upper(t)
             q = InvPdt(symgp)%lower(t)
             a_begin = virt(1,p)
             a_end   = virt(2,p)
             j_begin = occ(1,q)
             j_end   = occ(2,q)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do v=1,numSG
                   r = InvPdt(symgp)%upper(v)
                   s = InvPdt(symgp)%lower(v)
                   c_begin = virt(1,r)
                   c_end   = virt(2,r)
                   k_begin = occ(1,s)
                   k_end   = occ(2,s)
                   do k=k_begin,k_end
                     do c=c_begin,c_end
                       cumia_aa(j,a) = cumia_aa(j,a) + T2data%ab%m(a,j)%nsym(r,s)%n(c,k)**2
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do
      end if

      if(topsingles(0,0).ne.0) then
       do symgp=1,numSG
         k_begin = occ(1,symgp)
         k_end   = occ(2,symgp)
         c_begin = virt(1,symgp)
         c_end   = virt(2,symgp)
         do k=k_begin,k_end
           do c=c_begin,c_end
             pizero_singles= pizero_singles + 2*T1data%a%o(k)%vsym(symgp)%v(c)**2
           end do
         end do
       end do
end if

      if(topsingles(1,0).ne.0) then
       do symgp=1,numSG
         k_begin = occ(1,symgp)
         k_end   = occ(2,symgp)
         c_begin = virt(1,symgp)
         c_end   = virt(2,symgp)
         do k=k_begin,k_end
           do c=c_begin,c_end
             cumocc_singles(k) = cumocc_singles(k) + T1data%a%o(k)%vsym(symgp)%v(c)**2
           end do
         end do
      end do
    end if

      if(topsingles(0,1).ne.0) then
       do symgp=1,numSG
        c_begin = virt(1,symgp)
        c_end   = virt(2,symgp)
        k_begin = occ(1,symgp)
        k_end   = occ(2,symgp)
        do c=c_begin,c_end
          do k=k_begin,k_end
            cumvirt_singles(c) = cumvirt_singles(c) + T1data%a%o(k)%vsym(symgp)%v(c)**2
          end do
        end do
      end do
      end if


             do symgp=1,numSG
               k_begin = occ(1,symgp)
               k_end   = occ(2,symgp)
               c_begin = virt(1,symgp)
               c_end   = virt(2,symgp)
               do k=k_begin,k_end
                 do c=c_begin,c_end
                   Newc_singles%a%o(k)%vsym(symgp)%v(c) = topsingles(0,0)*(pizero + pizero_singles) + topsingles(1,0)*(cumocc(k)+cumocc_singles(k)) + topsingles(0,1)*(cumvirt(c)+cumvirt_singles(c)) + topsingles(1,1)*(cumia_aa(k,c) + T1data%a%o(k)%vsym(symgp)%v(c)**2)
                   Newc_singles%a%o(k)%vsym(symgp)%v(c) = sqrt(abs(1.0-Newc_singles%a%o(k)%vsym(symgp)%v(c)))
                 end do
               end do
            end do


        end subroutine BuildNewc_singles

!> @brief Builds the D2 matrix for open shell calculations
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine BuildD2OS(T2data,T1data,ReshapedMatrixDim,numSG,occ_alpha,occ_beta,virt_alpha,virt_beta,ProductTable,InvPdt,TwoInts,topfac,Newc,DerivNewc,T1deriv,topsingles,filename,Newc_singles)

       Use InterfaceMod
       Use TypeMod
       Implicit NONE
       type(T2) :: T2data
       type(T1) :: T1data,T1deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       integer :: numSG
       integer, intent(IN), dimension(1:2,1:numSG) :: occ_alpha, occ_beta,virt_alpha,virt_beta
       integer, dimension(1:numSG,1:numSG) :: ProductTable
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:numSG)
       real(8), intent(IN), allocatable, dimension(:,:,:,:) :: TwoInts
       real(8), dimension(0:2,0:2) :: topfac
       type(T2) :: Newc, DerivNewc
       real(8), dimension(0:1,0:1) :: topsingles(0:1,0:1)
       character(len=35) :: filename
       type(T1) :: Newc_singles




       type(D2) :: D2matrix
       integer :: i,j,rowdim
       integer :: k,l,symgp,i_begin,i_end, j_begin,j_end,k_begin,k_end,l_begin,l_end
       integer :: row,col,p,q,v,pos,offset,offset1,offset2,u,c
       integer :: t,r,s,a_begin,a_end,b_begin,b_end,a,b,numrows,numcols,rowoffset,coloffset
       type(ReshapedMat), allocatable, dimension(:)  :: DerivReshapes, Reshapes, TempReshape, TempDerivReshape,TopReshape
       type(D1) :: D1alpha_cum(1:numSG), D1beta_cum(1:numSG)
       integer :: reshaperows, reshapecols
       integer, allocatable, dimension(:) :: numocc_alpha_sg,numocc_beta_sg, numvirt_alpha_sg,numvirt_beta_sg
       double precision, allocatable, dimension(:,:) :: TempMat, TempProductMat
       integer :: D1row,D1col,d2symgp,D2row,D2col, symi,symj,syma,symb,symk,symc
       character(len=100) :: D2outputfile

       type(BasisMap2), allocatable, dimension(:) :: D2aabasis, D2abbasis
       type(InverseBasis2), allocatable, dimension(:) :: IbD2aa, IbD2bb
       type(InverseBasis2), allocatable, dimension(:) :: IbD2ab
       type(BasisMap2), allocatable, dimension(:) :: Basis_ajaa, Basis_ajab, Basis_jaab, Basis_ajbb
       type(BasisMap3), allocatable, dimension(:) :: Basis_jka_aaa, Basis_bci_aaa, Basis_jka_bbb, Basis_bci_bbb
       type(BasisMap3), allocatable, dimension(:) :: Basis_jka_aba, Basis_jka_abb, Basis_bci_aba, Basis_bci_abb
       type(BasisMap1), allocatable, dimension(:) :: Basis_i_alpha,Basis_i_beta,Basis_a_alpha,Basis_a_beta
       type(BasisMap2), allocatable, dimension(:) :: Sym_Basis_ajaa, Sym_Basis_ajab, Sym_Basis_jaab, Sym_basis_ajbb
       type(BasisMap3), allocatable, dimension(:) :: Sym_Basis_jka_aaa, Sym_Basis_bci_aaa, Sym_Basis_jka_bbb, Sym_Basis_bci_bbb
       type(BasisMap3), allocatable, dimension(:) :: Sym_Basis_jka_aba, Sym_Basis_jka_abb, Sym_Basis_bci_aba, Sym_Basis_bci_abb
       type(BasisMap1), allocatable, dimension(:) :: Sym_Basis_i_alpha, Sym_Basis_i_beta, Sym_Basis_a_alpha, Sym_Basis_a_beta

       allocate(IbD2aa(1:numSG))
       allocate(IbD2bb(1:numSG))
       allocate(IbD2ab(1:numSG))

       Call MapD2OS(numSG,occ_alpha,occ_beta,virt_alpha,virt_beta,ReshapedMatrixDim,IbD2aa,IbD2ab,IbD2bb, Basis_ajaa, Basis_ajbb,Basis_ajab,Basis_jaab,Basis_jka_aaa,Basis_jka_bbb,Basis_bci_aaa,Basis_bci_bbb,Basis_jka_aba, Basis_jka_abb, Basis_bci_aba, Basis_bci_abb,Basis_i_alpha,Basis_i_beta,Basis_a_alpha,Basis_a_beta,Sym_Basis_jka_aaa,Sym_Basis_jka_bbb,Sym_Basis_bci_aaa,Sym_Basis_bci_bbb,Sym_Basis_jka_aba, Sym_Basis_jka_abb, Sym_Basis_bci_aba,Sym_Basis_bci_abb,Sym_Basis_i_alpha, Sym_Basis_i_beta, Sym_Basis_a_alpha, Sym_Basis_a_beta,InvPdt,Sym_Basis_ajaa,Sym_Basis_ajbb,Sym_Basis_ajab,Sym_Basis_jaab)

       allocate(D2matrix%aa%irrep(1:numSG))
       allocate(D2matrix%ab%irrep(1:numSG))
       allocate(D2matrix%bb%irrep(1:numSG))

       do i=1,numSG
         rowdim = 0
         rowdim = ReshapedMatrixDim%ijaa(i)%col + ReshapedMatrixDim%ajaa(i)%col + ReshapedMatrixDim%ijaa(i)%row
         allocate(D2matrix%aa%irrep(i)%block(1:rowdim,1:rowdim))
         D2matrix%aa%irrep(i)%block(1:rowdim,1:rowdim) = 0.D0
      end do

      do i=1,numSG
        rowdim = 0
        rowdim = ReshapedMatrixDim%ijab(i)%row + ReshapedMatrixDim%ijab(i)%col + ReshapedMatrixDim%ajab(i)%col + ReshapedMatrixDim%ajba(i)%col
        allocate(D2matrix%ab%irrep(i)%block(1:rowdim,1:rowdim))
        D2matrix%ab%irrep(i)%block(1:rowdim,1:rowdim) = 0.D0
      end do

      do i=1,numSG
        rowdim = 0
        rowdim = ReshapedMatrixDim%ijbb(i)%col + ReshapedMatrixDim%ajbb(i)%col + ReshapedMatrixDim%ijbb(i)%row
        allocate(D2matrix%bb%irrep(i)%block(1:rowdim,1:rowdim))
        D2matrix%bb%irrep(i)%block(1:rowdim,1:rowdim) = 0.D0
      end do

      do symgp=1,numSG
         col = 0
         do t=1,numSG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             if(p.GT.q) then
               cycle
             end if
             i_begin = occ_alpha(1,p)
             i_end   = occ_alpha(2,p)
             j_begin = occ_alpha(1,q)
             j_end   = occ_alpha(2,q)
             do i=i_begin,i_end
               do j=max(i+1,j_begin),j_end
                 col = col + 1
                 row = 1
                 do v=1,numSG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   if(r.GT.s) then
                     cycle
                   end if
                   k_begin = occ_alpha(1,r)
                   k_end   = occ_alpha(2,r)
                   l_begin = occ_alpha(1,s)
                   l_end   = occ_alpha(2,s)
                   do k=k_begin,k_end
                     do l=max(k+1,l_begin),l_end
                       if(i==k.and.j==l.and.k.ne.j) then
                         D2matrix%aa%irrep(symgp)%block(row,col) = 1
                       end if
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do


      do symgp=1,numSG
         col = 0
         do t=1,numSG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             if(p.GT.q) then
               cycle
             end if
             i_begin = occ_beta(1,p)
             i_end   = occ_beta(2,p)
             j_begin = occ_beta(1,q)
             j_end   = occ_beta(2,q)
             do i=i_begin,i_end
               do j=max(i+1,j_begin),j_end
                 col = col + 1
                 row = 1
                 do v=1,numSG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   if(r.GT.s) then
                     cycle
                   end if
                   k_begin = occ_beta(1,r)
                   k_end   = occ_beta(2,r)
                   l_begin = occ_beta(1,s)
                   l_end   = occ_beta(2,s)
                   do k=k_begin,k_end
                     do l=max(k+1,l_begin),l_end
                       if(i==k.and.j==l.and.k.ne.j) then
                         D2matrix%bb%irrep(symgp)%block(row,col) = 1
                       end if
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do


      do symgp=1,numSG
         col =0
         do t=1,numSG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             i_begin = occ_alpha(1,p)
             i_end   = occ_alpha(2,p)
             j_begin = occ_beta(1,q)
             j_end   = occ_beta(2,q)
             do i=i_begin,i_end
               do j=j_begin,j_end
                 col = col + 1
                 row = 1
                 do v=1,numSG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   k_begin = occ_alpha(1,r)
                   k_end   = occ_alpha(2,r)
                   l_begin = occ_beta(1,s)
                   l_end   = occ_beta(2,s)
                   do k=k_begin,k_end
                     do l=l_begin,l_end
                       if(i==k.and.j==l) then
                         D2matrix%ab%irrep(symgp)%block(row,col) = 2*0.5
                       end if
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do


      allocate(numocc_alpha_sg(1:numSG))
      allocate(numvirt_alpha_sg(1:numSG))
      allocate(numocc_beta_sg(1:numSG))
      allocate(numvirt_beta_sg(1:numSG))


      do p=1,numSG
        i_begin = occ_alpha(1,p)
        i_end   = occ_alpha(2,p)
        a_begin = virt_alpha(1,p)
        a_end   = virt_alpha(2,p)
        numocc_alpha_sg(p) = i_end - i_begin + 1
        numvirt_alpha_sg(p) = a_end - a_begin + 1
      end do

      do p=1,numSG
        i_begin = occ_beta(1,p)
        i_end   = occ_beta(2,p)
        a_begin = virt_beta(1,p)
        a_end   = virt_beta(2,p)
        numocc_beta_sg(p) = i_end - i_begin + 1
        numvirt_beta_sg(p) = a_end - a_begin + 1
      end do

      do p=1,numSG
        allocate(D1alpha_cum(p)%D1block(1:(numocc_alpha_sg(p)+numvirt_alpha_sg(p)),1:(numocc_alpha_sg(p)+numvirt_alpha_sg(p))))
        D1alpha_cum(p)%D1block = 0.0
      end do

      do p=1,numSG
        allocate(D1beta_cum(p)%D1block(1:(numocc_beta_sg(p)+numvirt_beta_sg(p)),1:(numocc_beta_sg(p)+numvirt_beta_sg(p))))
        D1beta_cum(p)%D1block = 0.0
      end do


       allocate(Reshapes(1:numSG), DerivReshapes(1:numSG))
       Call reshape_ialphaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)

       do p=1,numSG
         if(numocc_alpha_sg(p).ne.0) then
           D1alpha_cum(p)%D1block(1:numocc_alpha_sg(p),1:numocc_alpha_sg(p)) = -1*matmul(transpose(Reshapes(p)%ReshapedMatrix),Reshapes(p)%ReshapedMatrix) + D1alpha_cum(p)%D1block(1:numocc_alpha_sg(p),1:numocc_alpha_sg(p))
         end if
       end do
      deallocate(Reshapes,DerivReshapes)

      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
       Call reshape_t1t1_ialphaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        if(numocc_alpha_sg(p).ne.0) then
          D1alpha_cum(p)%D1block(1:numocc_alpha_sg(p),1:numocc_alpha_sg(p)) = -1*matmul(transpose(Reshapes(p)%ReshapedMatrix),Reshapes(p)%ReshapedMatrix) + D1alpha_cum(p)%D1block(1:numocc_alpha_sg(p),1:numocc_alpha_sg(p))
        end if
      end do

      do p=1,numSG
        if(numvirt_alpha_sg(p).ne.0) then
          D1alpha_cum(p)%D1block(numocc_alpha_sg(p)+1:numocc_alpha_sg(p)+numvirt_alpha_sg(p),numocc_alpha_sg(p)+1:numocc_alpha_sg(p)+numvirt_alpha_sg(p)) = matmul(Reshapes(p)%ReshapedMatrix,transpose(Reshapes(p)%ReshapedMatrix)) + D1alpha_cum(p)%D1block(numocc_alpha_sg(p)+1:numocc_alpha_sg(p)+numvirt_alpha_sg(p),numocc_alpha_sg(p)+1:numocc_alpha_sg(p)+numvirt_alpha_sg(p))
        end if
      end do
      deallocate(Reshapes,DerivReshapes)

      allocate(Reshapes(1:numSG),DerivReshapes(1:numSG))
      Call reshape_aalphaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        if(numvirt_alpha_sg(p).ne.0) then
          D1alpha_cum(p)%D1block(numocc_alpha_sg(p)+1:numocc_alpha_sg(p)+numvirt_alpha_sg(p),numocc_alpha_sg(p)+1:numocc_alpha_sg(p)+numvirt_alpha_sg(p)) = matmul(transpose(Reshapes(p)%ReshapedMatrix),Reshapes(p)%ReshapedMatrix) + D1alpha_cum(p)%D1block(numocc_alpha_sg(p)+1:numocc_alpha_sg(p)+numvirt_alpha_sg(p),numocc_alpha_sg(p)+1:numocc_alpha_sg(p)+numvirt_alpha_sg(p))
        end if
      end do
      deallocate(Reshapes,DerivReshapes)

       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ibetaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         if(numocc_beta_sg(p).ne.0) then
            D1beta_cum(p)%D1block(1:numocc_beta_sg(p),1:numocc_beta_sg(p)) = -1*matmul(Reshapes(p)%ReshapedMatrix,transpose(Reshapes(p)%ReshapedMatrix)) + D1beta_cum(p)%D1block(1:numocc_beta_sg(p),1:numocc_beta_sg(p))
         end if
       end do
      deallocate(Reshapes,DerivReshapes)
      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))

       Call reshape_t1t1_ibetaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        if(numocc_beta_sg(p).ne.0) then
          D1beta_cum(p)%D1block(1:numocc_beta_sg(p),1:numocc_beta_sg(p)) = -1*matmul(transpose(Reshapes(p)%ReshapedMatrix),Reshapes(p)%ReshapedMatrix) + D1beta_cum(p)%D1block(1:numocc_beta_sg(p),1:numocc_beta_sg(p))
        end if
      end do

      do p=1,numSG
        if(numvirt_beta_sg(p).ne.0) then
          D1beta_cum(p)%D1block(numocc_beta_sg(p)+1:numocc_beta_sg(p)+numvirt_beta_sg(p),numocc_beta_sg(p)+1:numocc_beta_sg(p)+numvirt_beta_sg(p)) = matmul(Reshapes(p)%ReshapedMatrix,transpose(Reshapes(p)%ReshapedMatrix)) + D1beta_cum(p)%D1block(numocc_beta_sg(p)+1:numocc_beta_sg(p)+numvirt_beta_sg(p),numocc_beta_sg(p)+1:numocc_beta_sg(p)+numvirt_beta_sg(p))
        end if
      end do
      deallocate(Reshapes,DerivReshapes)

      allocate(Reshapes(1:numSG),DerivReshapes(1:numSG))
      Call reshape_abetaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        if(numvirt_beta_sg(p).ne.0) then
          D1beta_cum(p)%D1block(numocc_beta_sg(p)+1:numocc_beta_sg(p)+numvirt_beta_sg(p),numocc_beta_sg(p)+1:numocc_beta_sg(p)+numvirt_beta_sg(p)) = matmul(Reshapes(p)%ReshapedMatrix,transpose(Reshapes(p)%ReshapedMatrix)) + D1beta_cum(p)%D1block(numocc_beta_sg(p)+1:numocc_beta_sg(p)+numvirt_beta_sg(p),numocc_beta_sg(p)+1:numocc_beta_sg(p)+numvirt_beta_sg(p))
        end if
      end do
      deallocate(Reshapes,DerivReshapes)

      do p=1,numSG
        i_begin = occ_alpha(1,p)
        i_end   = occ_alpha(2,p)
        a_begin = virt_alpha(1,p)
        a_end   = virt_alpha(2,p)
        do i=i_begin,i_end
          do a=a_begin,a_end
          row = a - a_begin + 1 + numocc_alpha_sg(p)
          col = i - i_begin + 1
            D1alpha_cum(p)%D1block(row,col) = D1alpha_cum(p)%D1block(row,col) + T1data%a%o(i)%vsym(p)%v(a)*Newc_singles%a%o(i)%vsym(p)%v(a)
            D1alpha_cum(p)%D1block(col,row) = D1alpha_cum(p)%D1block(col,row) + T1data%a%o(i)%vsym(p)%v(a)*Newc_singles%a%o(i)%vsym(p)%v(a)
          end do
        end do
      end do

      allocate(Reshapes(1:numSG),DerivReshapes(1:numSG))
      allocate(TempReshape(1:numSG),TempDerivReshape(1:numSG))
     Call reshape_ajaa_t1OS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibrowOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      do p=1,numSG
        allocate(TempMat(1,1:numocc_alpha_sg(p)*numvirt_alpha_sg(p)))
        i_begin = occ_alpha(1,p)
        i_end   = occ_alpha(2,p)
        a_begin = virt_alpha(1,p)
        a_end   = virt_alpha(2,p)
        TempMat = matmul4(TempReshape(p)%ReshapedMatrix,Reshapes(p)%ReshapedMatrix)
        pos = 1
        do i=i_begin,i_end
          do a=a_begin,a_end
            row = a - a_begin + 1 + numocc_alpha_sg(p)
            col = i - i_begin + 1
            D1alpha_cum(p)%D1block(row,col) = TempMat(1,pos) + D1alpha_cum(p)%D1block(row,col)
            D1alpha_cum(p)%D1block(col,row) = TempMat(1,pos) + D1alpha_cum(p)%D1block(col,row)
            pos = pos + 1
          end do
        end do
        deallocate(TempMat)
      end do
      deallocate(Reshapes,DerivReshapes,TempReshape,TempDerivReshape)

      do p=1,numSG
        i_begin = occ_beta(1,p)
        i_end   = occ_beta(2,p)
        a_begin = virt_beta(1,p)
        a_end   = virt_beta(2,p)
        do i=i_begin,i_end
          do a=a_begin,a_end
          row = a - a_begin + 1 + numocc_beta_sg(p)
          col = i - i_begin + 1
            D1beta_cum(p)%D1block(row,col) = D1beta_cum(p)%D1block(row,col) + T1data%b%o(i)%vsym(p)%v(a)*Newc_singles%b%o(i)%vsym(p)%v(a)
            D1beta_cum(p)%D1block(col,row) = D1beta_cum(p)%D1block(col,row) + T1data%b%o(i)%vsym(p)%v(a)*Newc_singles%b%o(i)%vsym(p)%v(a)
          end do
        end do
      end do

      allocate(Reshapes(1:numSG),DerivReshapes(1:numSG))
      allocate(TempReshape(1:numSG),TempDerivReshape(1:numSG))
     Call reshape_ajbb_t1OS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibrowOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)

      do p=1,numSG
        allocate(TempMat(1,1:numocc_beta_sg(p)*numvirt_beta_sg(p)))
        i_begin = occ_beta(1,p)
        i_end   = occ_beta(2,p)
        a_begin = virt_beta(1,p)
        a_end   = virt_beta(2,p)
        TempMat = matmul4(TempReshape(p)%ReshapedMatrix,Reshapes(p)%ReshapedMatrix)
        pos = 1
        do i=i_begin,i_end
          do a=a_begin,a_end
            row = a - a_begin + 1 + numocc_beta_sg(p)
            col = i - i_begin + 1
            D1beta_cum(p)%D1block(row,col) = TempMat(1,pos) + D1beta_cum(p)%D1block(row,col)
            D1beta_cum(p)%D1block(col,row) = TempMat(1,pos) + D1beta_cum(p)%D1block(col,row)
            pos = pos + 1
          end do
        end do
        deallocate(TempMat)
      end do

      deallocate(Reshapes,DerivReshapes,TempReshape,TempDerivReshape)

      do symgp=1,numSG
         col = 0
         do t=1,numSG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             if(p.GT.q) then
               cycle
             end if
             i_begin = occ_alpha(1,p)
             i_end   = occ_alpha(2,p)
             j_begin = occ_alpha(1,q)
             j_end   = occ_alpha(2,q)
             do i=i_begin,i_end
               do j=max(i+1,j_begin),j_end
                 col = col + 1
                 row = 1
                 do v=1,numSG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   if(r.GT.s) then
                     cycle
                   end if
                   k_begin = occ_alpha(1,r)
                   k_end   = occ_alpha(2,r)
                   l_begin = occ_alpha(1,s)
                   l_end   = occ_alpha(2,s)
                   do k=k_begin,k_end
                     do l=max(k+1,l_begin),l_end
                       if(j==l.and.p.eq.r) then
                         D1row = i - i_begin + 1
                         D1col = k - k_begin + 1
                         D2matrix%aa%irrep(symgp)%block(row,col) = D1alpha_cum(p)%D1block(D1row,D1col) + D2matrix%aa%irrep(symgp)%block(row,col)
                       end if
                       if(j==k.and.p.eq.s) then
                         D1row = i - i_begin + 1
                         D1col = l - l_begin + 1
                         D2matrix%aa%irrep(symgp)%block(row,col) = -1*D1alpha_cum(p)%D1block(D1row,D1col) + D2matrix%aa%irrep(symgp)%block(row,col)
                       end if
                       if(i.eq.l.and.q.eq.r) then
                         D1row = j - j_begin + 1
                         D1col = k - k_begin + 1
                         D2matrix%aa%irrep(symgp)%block(row,col) = -1*D1alpha_cum(q)%D1block(D1row,D1col) + D2matrix%aa%irrep(symgp)%block(row,col)
                       end if
                       if(i.eq.k.and.q.eq.s) then
                         D1row = j - j_begin + 1
                         D1col = l - l_begin + 1
                         D2matrix%aa%irrep(symgp)%block(row,col) = D1alpha_cum(q)%D1block(D1row,D1col) + D2matrix%aa%irrep(symgp)%block(row,col)
                       end if
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do

      do symgp=1,numSG
         col = 0
         do t=1,numSG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             if(p.GT.q) then
               cycle
             end if
             i_begin = occ_beta(1,p)
             i_end   = occ_beta(2,p)
             j_begin = occ_beta(1,q)
             j_end   = occ_beta(2,q)
             do i=i_begin,i_end
               do j=max(i+1,j_begin),j_end
                 col = col + 1
                 row = 1
                 do v=1,numSG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   if(r.GT.s) then
                     cycle
                   end if
                   k_begin = occ_beta(1,r)
                   k_end   = occ_beta(2,r)
                   l_begin = occ_beta(1,s)
                   l_end   = occ_beta(2,s)
                   do k=k_begin,k_end
                     do l=max(k+1,l_begin),l_end
                       if(j==l.and.p.eq.r) then
                         D1row = i - i_begin + 1
                         D1col = k - k_begin + 1
                         D2matrix%bb%irrep(symgp)%block(row,col) = D1beta_cum(p)%D1block(D1row,D1col) + D2matrix%bb%irrep(symgp)%block(row,col)
                       end if
                       if(j==k.and.p.eq.s) then
                         D1row = i - i_begin + 1
                         D1col = l - l_begin + 1
                         D2matrix%bb%irrep(symgp)%block(row,col) = -1*D1beta_cum(p)%D1block(D1row,D1col) + D2matrix%bb%irrep(symgp)%block(row,col)
                       end if
                       if(i.eq.l.and.q.eq.r) then
                         D1row = j - j_begin + 1
                         D1col = k - k_begin + 1
                         D2matrix%bb%irrep(symgp)%block(row,col) = -1*D1beta_cum(q)%D1block(D1row,D1col) + D2matrix%bb%irrep(symgp)%block(row,col)
                       end if
                       if(i.eq.k.and.q.eq.s) then
                         D1row = j - j_begin + 1
                         D1col = l - l_begin + 1
                         D2matrix%bb%irrep(symgp)%block(row,col) = D1beta_cum(q)%D1block(D1row,D1col) + D2matrix%bb%irrep(symgp)%block(row,col)
                       end if
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do

      do symgp=1,numSG
         col =0
         do t=1,numSG
            p=InvPdt(symgp)%upper(t)
            q=InvPdt(symgp)%lower(t)
             i_begin = occ_alpha(1,p)
             i_end   = occ_alpha(2,p)
             j_begin = occ_beta(1,q)
             j_end   = occ_beta(2,q)
             do i=i_begin,i_end
               do j=j_begin,j_end
                 col = col + 1
                 row = 1
                 do v=1,numSG
                   r=InvPdt(symgp)%upper(v)
                   s=InvPdt(symgp)%lower(v)
                   k_begin = occ_alpha(1,r)
                   k_end   = occ_alpha(2,r)
                   l_begin = occ_beta(1,s)
                   l_end   = occ_beta(2,s)
                   do k=k_begin,k_end
                     do l=l_begin,l_end
                       if(j==l.and.p.eq.r) then
                         D1row = i - i_begin + 1
                         D1col = k - k_begin + 1
                         D2matrix%ab%irrep(symgp)%block(row,col) = D1alpha_cum(p)%D1block(D1row,D1col) + D2matrix%ab%irrep(symgp)%block(row,col)
                       end if
                       if(i==k.and.q.eq.s) then
                         D1row = j - j_begin + 1
                         D1col = l - l_begin + 1
                         D2matrix%ab%irrep(symgp)%block(row,col) = D1beta_cum(q)%D1block(D1row,D1col) + D2matrix%ab%irrep(symgp)%block(row,col)
                       end if
                       row = row + 1
                     end do
                   end do
                 end do
               end do
             end do
           end do
         end do

       do symgp=1,numSG
         offset = ReshapedMatrixDim%ijaa(symgp)%col
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt_alpha(1,r)
                 b_end   = virt_alpha(2,r)
                 i_begin = occ_alpha(1,s)
                 i_end   = occ_alpha(2,s)
                 do i=i_begin,i_end
                   do b=b_begin,b_end
                     if(i.eq.j.and.p.eq.r) then
                      d2symgp = ProductTable(s,p)
                      d2symgp = ProductTable(q,r)
                      d2row = IbD2aa(d2symgp)%ib(i,a)
                      d2col = IbD2aa(d2symgp)%ib(j,b)
                      D1row = a - a_begin + 1 + numocc_alpha_sg(p)
                      D1col = b - b_begin + 1 + numocc_alpha_sg(p)
                      D2matrix%aa%irrep(d2symgp)%block(d2row,d2col) = D1alpha_cum(p)%D1block(D1row,D1col) + D2matrix%aa%irrep(symgp)%block(d2row,d2col)
                      end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do


       do symgp=1,numSG
         offset = ReshapedMatrixDim%ijbb(symgp)%col
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt_beta(1,r)
                 b_end   = virt_beta(2,r)
                 i_begin = occ_beta(1,s)
                 i_end   = occ_beta(2,s)
                 do i=i_begin,i_end
                   do b=b_begin,b_end
                     if(i.eq.j.and.p.eq.r) then
                      d2symgp = ProductTable(s,p)
                      d2symgp = ProductTable(q,r)
                      d2row = IbD2bb(d2symgp)%ib(i,a)
                      d2col = IbD2bb(d2symgp)%ib(j,b)
                      D1row = a - a_begin + 1 + numocc_beta_sg(p)
                      D1col = b - b_begin + 1 + numocc_beta_sg(p)
                      D2matrix%bb%irrep(d2symgp)%block(d2row,d2col) = D1beta_cum(p)%D1block(D1row,D1col) + D2matrix%bb%irrep(symgp)%block(d2row,d2col)
                      end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do



       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do a=a_begin,a_end
             do j=j_begin,j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt_alpha(1,r)
                 b_end   = virt_alpha(2,r)
                 i_begin = occ_beta(1,s)
                 i_end   = occ_beta(2,s)
                 do b=b_begin,b_end
                   do i=i_begin,i_end
                      if(i.eq.j.and.p.eq.r)  then
                        d2symgp = ProductTable(s,p)
                        d2symgp = ProductTable(q,r)
                        D1row = a - a_begin + 1 + numocc_alpha_sg(p)
                        D1col = b - b_begin + 1 + numocc_alpha_sg(p)
                        d2row = IbD2ab(d2symgp)%ib(a,i)
                        d2col = IbD2ab(d2symgp)%ib(b,j)
                        D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = D1alpha_cum(p)%D1block(D1row,D1col) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
                      end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do


       do symgp=1,numSG
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do a=a_begin,a_end
             do j=j_begin,j_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 b_begin = virt_beta(1,r)
                 b_end   = virt_beta(2,r)
                 i_begin = occ_alpha(1,s)
                 i_end   = occ_alpha(2,s)
                 do b=b_begin,b_end
                   do i=i_begin,i_end
                      if(i.eq.j.and.p.eq.r)  then
                        d2symgp = ProductTable(s,p)
                        d2symgp = ProductTable(q,r)
                        d2row = IbD2ab(d2symgp)%ib(i,a)
                        d2col = IbD2ab(d2symgp)%ib(j,b)
                        D1row = a - a_begin + 1 + numocc_beta_sg(p)
                        D1col = b - b_begin + 1 + numocc_beta_sg(p)
                        D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = D1beta_cum(p)%D1block(D1row,D1col) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
                      end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do


       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ijaa_testOS(numSG,ProductTable,Reshapes,occ_alpha,virt_alpha,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       deallocate(DerivReshapes)
       do p=1,numSG
         numrows = ReshapedMatrixDim%ijaa(p)%col
         numcols = numrows
         reshaperows = size(Reshapes(p)%ReshapedMatrix,1)
         reshapecols = size(Reshapes(p)%ReshapedMatrix,2)
         allocate(TempMat(1:reshapecols,1:reshaperows))
         TempMat = transpose(Reshapes(p)%ReshapedMatrix)
         D2matrix%aa%irrep(p)%block(1:numrows,1:numcols) = matmul4(TempMat,Reshapes(p)%ReshapedMatrix) +  D2matrix%aa%irrep(p)%block(1:numrows,1:numcols)
         deallocate(TempMat)
       end do
      do p=1,numSG
        numrows = ReshapedMatrixDim%ijaa(p)%row
        numcols = numrows
        if(numrows.ne.0) then
          offset =  ReshapedMatrixDim%ijaa(p)%col + ReshapedMatrixDim%ajaa(p)%col
          reshaperows = size(Reshapes(p)%ReshapedMatrix,1)
          reshapecols = size(Reshapes(p)%ReshapedMatrix,2)
          allocate(TempMat(1:reshapecols,1:reshaperows))
          TempMat = transpose(Reshapes(p)%ReshapedMatrix)
          D2matrix%aa%irrep(p)%block(offset+1:offset+numrows,offset+1:offset+numcols) = matmul4(Reshapes(p)%ReshapedMatrix,TempMat) + D2matrix%aa%irrep(p)%block(offset+1:offset+numrows,offset+1:offset+numcols)
        deallocate(TempMat)
       end if
      end do

      allocate(DerivReshapes(1:numSG))
      allocate(TopReshape(1:numSG))
      Call reshape_ijaa_testOS(numSG,ProductTable,TopReshape,occ_alpha,virt_alpha,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        numrows = ReshapedMatrixdim%ijaa(p)%row
        numcols = ReshapedMatrixDim%ijaa(p)%col
        if(numrows.ne.0.and.numcols.ne.0) then
          allocate(TempMat(1:numrows,1:numcols))
          rowoffset = ReshapedMatrixDim%ijaa(p)%col + ReshapedMatrixDim%ajaa(p)%col
          coloffset = 0
          do q=1,ReshapedMatrixDim%ijaa(p)%col
            do s=1,ReshapedMatrixDim%ijaa(p)%row
              TempMat(s,q) = Reshapes(p)%ReshapedMatrix(s,q)*TopReshape(p)%ReshapedMatrix(s,q)
             end do
          end do
          D2matrix%aa%irrep(p)%block(rowoffset+1:rowoffset+numrows,coloffset+1:coloffset+numcols) = TempMat + D2matrix%aa%irrep(p)%block(rowoffset+1:rowoffset+numrows,coloffset+1:coloffset+numcols)
          D2matrix%aa%irrep(p)%block(coloffset+1:coloffset+numcols,rowoffset+1:rowoffset+numrows) = transpose(TempMat) + D2matrix%aa%irrep(p)%block(coloffset+1:coloffset+numcols,rowoffset+1:rowoffset+numrows)
          deallocate(TempMat)
        end if
      end do
      deallocate(DerivReshapes)
      deallocate(Reshapes)
      deallocate(TopReshape)

       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ijbb_testOS(numSG,ProductTable,Reshapes,occ_beta,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       deallocate(DerivReshapes)
       do p=1,numSG
         numrows = ReshapedMatrixDim%ijbb(p)%col
         numcols = numrows
         if(numrows.ne.0) then
           reshaperows = size(Reshapes(p)%ReshapedMatrix,1)
           reshapecols = size(Reshapes(p)%ReshapedMatrix,2)
           allocate(TempMat(1:reshapecols,1:reshaperows))
           TempMat = transpose(Reshapes(p)%ReshapedMatrix)
           D2matrix%bb%irrep(p)%block(1:numrows,1:numcols) = matmul4(TempMat,Reshapes(p)%ReshapedMatrix) +  D2matrix%bb%irrep(p)%block(1:numrows,1:numcols)
           deallocate(TempMat)
         end if
       end do
      do p=1,numSG
        numrows = ReshapedMatrixDim%ijbb(p)%row
        numcols = numrows
        if(numrows.ne.0) then
          offset =  ReshapedMatrixDim%ijbb(p)%col + ReshapedMatrixDim%ajbb(p)%col
          reshaperows = size(Reshapes(p)%ReshapedMatrix,1)
          reshapecols = size(Reshapes(p)%ReshapedMatrix,2)
          allocate(TempMat(1:reshapecols,1:reshaperows))
          TempMat = transpose(Reshapes(p)%ReshapedMatrix)
          D2matrix%bb%irrep(p)%block(offset+1:offset+numrows,offset+1:offset+numcols) = matmul4(Reshapes(p)%ReshapedMatrix,TempMat) + D2matrix%bb%irrep(p)%block(offset+1:offset+numrows,offset+1:offset+numcols)
          deallocate(TempMat)
        end if
      end do

      allocate(DerivReshapes(1:numSG))
      allocate(TopReshape(1:numSG))
      Call reshape_ijbb_testOS(numSG,ProductTable,TopReshape,occ_beta,virt_beta,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        numrows = ReshapedMatrixdim%ijbb(p)%row
        numcols = ReshapedMatrixDim%ijbb(p)%col
        if(numrows.ne.0.and.numcols.ne.0) then
          allocate(TempMat(1:numrows,1:numcols))
          rowoffset = ReshapedMatrixDim%ijbb(p)%col + ReshapedMatrixDim%ajbb(p)%col
          coloffset = 0
          do q=1,ReshapedMatrixDim%ijbb(p)%col
            do s=1,ReshapedMatrixDim%ijbb(p)%row
              TempMat(s,q) = Reshapes(p)%ReshapedMatrix(s,q)*TopReshape(p)%ReshapedMatrix(s,q)
             end do
          end do
          D2matrix%bb%irrep(p)%block(rowoffset+1:rowoffset+numrows,coloffset+1:coloffset+numcols) = TempMat + D2matrix%bb%irrep(p)%block(rowoffset+1:rowoffset+numrows,coloffset+1:coloffset+numcols)
          D2matrix%bb%irrep(p)%block(coloffset+1:coloffset+numcols,rowoffset+1:rowoffset+numrows) = transpose(TempMat) + D2matrix%bb%irrep(p)%block(coloffset+1:coloffset+numcols,rowoffset+1:rowoffset+numrows)
          deallocate(TempMat)
        end if
      end do
      deallocate(DerivReshapes)
      deallocate(Reshapes)
      deallocate(TopReshape)






       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ijab_testOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       deallocate(DerivReshapes)
       do p=1,numSG
         numrows = ReshapedMatrixDim%ijab(p)%col
         numcols = numrows
         reshaperows = size(Reshapes(p)%ReshapedMatrix,1)
         reshapecols = size(Reshapes(p)%ReshapedMatrix,2)
         allocate(TempMat(1:reshapecols,1:reshaperows))
         TempMat = transpose(Reshapes(p)%ReshapedMatrix)
         D2matrix%ab%irrep(p)%block(1:numrows,1:numcols) = matmul4(TempMat,Reshapes(p)%ReshapedMatrix) +  D2matrix%ab%irrep(p)%block(1:numrows,1:numcols)
         deallocate(TempMat)
       end do

      do p=1,numSG
        numrows = ReshapedMatrixDim%ijab(p)%row
        numcols = numrows
        offset = ReshapedMatrixDim%ijab(p)%col + ReshapedMatrixDim%ajab(p)%col + ReshapedMatrixDim%ajba(p)%col
        reshaperows = size(Reshapes(p)%ReshapedMatrix,1)
        reshapecols = size(Reshapes(p)%ReshapedMatrix,2)
        allocate(TempMat(1:reshapecols,1:reshaperows))
        TempMat = transpose(Reshapes(p)%ReshapedMatrix)
        D2matrix%ab%irrep(p)%block(offset+1:offset+numrows,offset+1:offset+numcols) = matmul4(Reshapes(p)%ReshapedMatrix,TempMat) + D2matrix%ab%irrep(p)%block(offset+1:offset+numrows,offset+1:offset+numcols)
        deallocate(TempMat)
      end do

      allocate(DerivReshapes(1:numSG))
      allocate(TopReshape(1:numSG))

      Call reshape_ijab_testOS(numSG,ProductTable,TopReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        numrows = ReshapedMatrixDim%ijab(p)%row
        numcols = ReshapedMatrixDim%ijab(p)%col
        allocate(TempMat(1:numrows,1:numcols))
        rowoffset = ReshapedMatrixDim%ijab(p)%col + ReshapedMatrixDim%ajab(p)%col + ReshapedMatrixDim%ajba(p)%col
        coloffset = 0
        do q=1,ReshapedMatrixDim%ijab(p)%col
          do s=1,ReshapedMatrixDim%ijab(p)%row
            TempMat(s,q) = Reshapes(p)%ReshapedMatrix(s,q)*TopReshape(p)%ReshapedMatrix(s,q)
           end do
        end do
        D2matrix%ab%irrep(p)%block(rowoffset+1:rowoffset+numrows,coloffset+1:coloffset+numcols) = TempMat + D2matrix%ab%irrep(p)%block(rowoffset+1:rowoffset+numrows,coloffset+1:coloffset+numcols)
        D2matrix%ab%irrep(p)%block(coloffset+1:coloffset+numcols,rowoffset+1:rowoffset+numrows) = transpose(TempMat) + D2matrix%ab%irrep(p)%block(coloffset+1:coloffset+numcols,rowoffset+1:rowoffset+numrows)
        deallocate(TempMat)
      end do
      deallocate(DerivReshapes)
      deallocate(Reshapes)
      deallocate(TopReshape)


       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ajaaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       deallocate(DerivReshapes)
       do p=1,numSG
         numrows = ReshapedMatrixDim%ajaa(p)%col
         reshaperows = size(Reshapes(p)%ReshapedMatrix,1)
         reshapecols = size(Reshapes(p)%ReshapedMatrix,2)
         allocate(TempMat(1:reshapecols,1:reshaperows))
         TempMat = transpose(Reshapes(p)%ReshapedMatrix)
         allocate(TempProductMat(1:numrows,1:numrows))
         TempProductMat(1:numrows,1:numrows) = 0.D0
         TempProductMat = -1*matmul4(TempMat,Reshapes(p)%ReshapedMatrix)
         do q=1,numrows
           do s=1,numrows
            j = Basis_ajaa(p)%basis(1,s)
            a = Basis_ajaa(p)%basis(2,s)
            i = Basis_ajaa(p)%basis(1,q)
            b = Basis_ajaa(p)%basis(2,q)
            symj = Sym_Basis_ajaa(p)%basis(1,s)
            syma = Sym_Basis_ajaa(p)%basis(2,s)
            symi = Sym_Basis_ajaa(p)%basis(1,q)
            symb = Sym_Basis_ajaa(p)%basis(2,q)
            d2symgp = ProductTable(symi,syma)
            d2symgp = ProductTable(symj,symb)
            d2col = IbD2aa(d2symgp)%ib(i,a)
            d2row = IbD2aa(d2symgp)%ib(j,b)
            D2matrix%aa%irrep(d2symgp)%block(d2row,d2col) = TempProductMat(s,q) + D2matrix%aa%irrep(d2symgp)%block(d2row,d2col)
           end do
         end do
         deallocate(TempMat)
         deallocate(TempProductMat)
       end do
       deallocate(Reshapes)

       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ajbbOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       deallocate(DerivReshapes)
       do p=1,numSG
         numrows = ReshapedMatrixDim%ajbb(p)%col
         reshaperows = size(Reshapes(p)%ReshapedMatrix,1)
         reshapecols = size(Reshapes(p)%ReshapedMatrix,2)
         allocate(TempMat(1:reshapecols,1:reshaperows))
         TempMat = transpose(Reshapes(p)%ReshapedMatrix)
         allocate(TempProductMat(1:numrows,1:numrows))
         TempProductMat(1:numrows,1:numrows) = 0.D0
         TempProductMat = -1*matmul4(Reshapes(p)%ReshapedMatrix,TempMat)
         do q=1,numrows
           do s=1,numrows
            j = Basis_ajbb(p)%basis(1,s)
            a = Basis_ajbb(p)%basis(2,s)
            i = Basis_ajbb(p)%basis(1,q)
            b = Basis_ajbb(p)%basis(2,q)
            symj = Sym_Basis_ajbb(p)%basis(1,s)
            syma = Sym_Basis_ajbb(p)%basis(2,s)
            symi = Sym_Basis_ajbb(p)%basis(1,q)
            symb = Sym_Basis_ajbb(p)%basis(2,q)
            d2symgp = ProductTable(symi,syma)
            d2symgp = ProductTable(symj,symb)
            d2col = IbD2bb(d2symgp)%ib(i,a)
            d2row = IbD2bb(d2symgp)%ib(j,b)
            D2matrix%bb%irrep(d2symgp)%block(d2row,d2col) = TempProductMat(s,q) + D2matrix%bb%irrep(d2symgp)%block(d2row,d2col)
           end do
         end do
         deallocate(TempMat)
         deallocate(TempProductMat)
       end do
       deallocate(Reshapes)
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ajabOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       deallocate(DerivReshapes)
       do p=1,numSG
         numrows = ReshapedMatrixDim%ajab(p)%row
         reshaperows = size(Reshapes(p)%ReshapedMatrix,1)
         reshapecols = size(Reshapes(p)%ReshapedMatrix,2)
         allocate(TempMat(1:reshapecols,1:reshaperows))
         TempMat = transpose(Reshapes(p)%ReshapedMatrix)
         allocate(TempProductMat(1:numrows,1:numrows))
         TempProductMat(1:numrows,1:numrows) = 0.D0
         TempProductMat= -1*matmul4(TempMat,Reshapes(p)%ReshapedMatrix)
         do q=1,numrows
           do s=1,numrows
            a = Basis_ajab(p)%basis(1,s)
            j = Basis_ajab(p)%basis(2,s)
            b = Basis_ajab(p)%basis(1,q)
            i = Basis_ajab(p)%basis(2,q)
            syma = Sym_Basis_ajab(p)%basis(1,s)
            symj = Sym_Basis_ajab(p)%basis(2,s)
            symb = Sym_Basis_ajab(p)%basis(1,q)
            symi = Sym_Basis_ajab(p)%basis(2,q)
            d2symgp = ProductTable(symi,syma)
            d2symgp = ProductTable(symj,symb)
            d2col = IbD2ab(d2symgp)%ib(a,i)
            d2row = IbD2ab(d2symgp)%ib(b,j)
            D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = TempProductMat(s,q) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
           end do
         end do
         deallocate(TempMat)
         deallocate(TempProductMat)
      end do
      deallocate(Reshapes)

       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ajbaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       deallocate(DerivReshapes)
       do p=1,numSG
         numrows = ReshapedMatrixDim%ajba(p)%row
         reshaperows = size(Reshapes(p)%ReshapedMatrix,1)
         reshapecols = size(Reshapes(p)%ReshapedMatrix,2)
         allocate(TempMat(1:reshapecols,1:reshaperows))
         TempMat = transpose(Reshapes(p)%ReshapedMatrix)
         allocate(TempProductMat(1:numrows,1:numrows))
         TempProductMat(1:numrows,1:numrows) = 0.D0
         TempProductMat= -1*matmul4(TempMat,Reshapes(p)%ReshapedMatrix)
         do q=1,numrows
           do s=1,numrows
            j = Basis_jaab(p)%basis(1,s)
            a = Basis_jaab(p)%basis(2,s)
            i = Basis_jaab(p)%basis(1,q)
            b = Basis_jaab(p)%basis(2,q)
            symj = Sym_Basis_jaab(p)%basis(1,s)
            syma = Sym_Basis_jaab(p)%basis(2,s)
            symi = Sym_Basis_jaab(p)%basis(1,q)
            symb = Sym_Basis_jaab(p)%basis(2,q)
            d2symgp = ProductTable(symi,syma)
            d2symgp = ProductTable(symj,symb)
            d2row = IbD2ab(d2symgp)%ib(i,a)
            d2col = IbD2ab(d2symgp)%ib(j,b)
            D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = TempProductMat(s,q) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
           end do
         end do
         deallocate(TempMat)
         deallocate(TempProductMat)
      end do
      deallocate(Reshapes)



      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
      allocate(TempReshape(1:numSG))
      allocate(TempDerivReshape(1:numSG))
      Call reshape_ajaaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_ajbbOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      deallocate(DerivReshapes)
      deallocate(TempDerivReshape)
       do p=1,numSG
          numrows = ReshapedMatrixDim%ajaa(p)%col
          numcols = ReshapedMatrixDim%ajbb(p)%col
          allocate(TempProductMat(1:numcols,1:numrows))
          TempProductMat(1:numcols,1:numrows) = 0.D0
           TempProductMat =   matmul4(TempReshape(p)%ReshapedMatrix,Reshapes(p)%ReshapedMatrix)
         do q=1,numcols
           do s=1,numrows
            a = Basis_ajaa(p)%basis(1,s)
            j = Basis_ajaa(p)%basis(2,s)
            b = Basis_ajbb(p)%basis(1,q)
            i = Basis_ajbb(p)%basis(2,q)
            symj = Sym_Basis_ajaa(p)%basis(1,s)
            syma = Sym_Basis_ajaa(p)%basis(2,s)
            symi = Sym_Basis_ajbb(p)%basis(1,q)
            symb = Sym_Basis_ajbb(p)%basis(2,q)
            d2symgp = ProductTable(symi,syma)
            d2symgp = ProductTable(symj,symb)
            d2col = IbD2ab(d2symgp)%ib(a,i)
            d2row = IbD2ab(d2symgp)%ib(j,b)
            D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = TempProductMat(q,s) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
            d2col = IbD2ab(d2symgp)%ib(j,b)
            d2row = IbD2ab(d2symgp)%ib(a,i)
            D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = TempProductMat(q,s) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
           end do
         end do
         deallocate(TempProductMat)
       end do
       deallocate(Reshapes)
       deallocate(TempReshape)

      allocate(DerivReshapes(1:numSG))
      allocate(TempDerivReshape(1:numSG))
      allocate(Reshapes(1:numSG))
      allocate(TempReshape(1:numSG))
      Call reshape_jka_aaaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_balphaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      deallocate(DerivReshapes,TempDerivReshape)
      do p=1,numSG
        numcols = ReshapedMatrixDim%jka_aaa(p)%col
        numrows = ReshapedMatrixDim%i_alpha(p)%col
        allocate(TempMat(1:numrows,1:numcols))
        TempMat =  matmul4(TempReshape(p)%ReshapedMatrix,Reshapes(p)%ReshapedMatrix)
        do q=1,numcols
          do s=1,numrows
            i = Basis_i_alpha(p)%basis(1,s)
            j = Basis_jka_aaa(p)%basis(1,q)
            k = Basis_jka_aaa(p)%basis(2,q)
            a = Basis_jka_aaa(p)%basis(3,q)
            symi = Sym_Basis_i_alpha(p)%basis(1,s)
            symj = Sym_Basis_jka_aaa(p)%basis(1,q)
            symk = Sym_Basis_jka_aaa(p)%basis(2,q)
            syma = Sym_Basis_jka_aaa(p)%basis(3,q)
            d2symgp = ProductTable(symj,symk)
            d2symgp = ProductTable(symi,syma)
            d2col = IbD2aa(d2symgp)%ib(j,k)
            d2row = IbD2aa(d2symgp)%ib(i,a)
            D2matrix%aa%irrep(d2symgp)%block(d2row,d2col) = TempMat(s,q) + D2matrix%aa%irrep(d2symgp)%block(d2row,d2col)
            D2matrix%aa%irrep(d2symgp)%block(d2col,d2row) = TempMat(s,q) + D2matrix%aa%irrep(d2symgp)%block(d2col,d2row)
          end do
        end do
        deallocate(TempMat)
      end do
      deallocate(Reshapes)
      deallocate(TempReshape)
      allocate(DerivReshapes(1:numSG))
      allocate(TempDerivReshape(1:numSG))
      allocate(Reshapes(1:numSG))
      allocate(TempReshape(1:numSG))
     Call reshape_bci_aaaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ialphaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
       do p=1,numSG
         numcols= ReshapedMatrixDim%bci_aaa(p)%col
         numrows = ReshapedMatrixDim%a_alpha(p)%col
         allocate(TempMat(1:numrows,1:numcols))
         TempMat = matmul4(TempReshape(p)%ReshapedMatrix,Reshapes(p)%ReshapedMatrix)
         do q=1,numcols
           do s=1,numrows
             a = Basis_a_alpha(p)%basis(1,s)
             b = Basis_bci_aaa(p)%basis(1,q)
             c = Basis_bci_aaa(p)%basis(2,q)
             i = Basis_bci_aaa(p)%basis(3,q)
             syma = Sym_Basis_a_alpha(p)%basis(1,s)
             symb = Sym_Basis_bci_aaa(p)%basis(1,q)
             symc = Sym_Basis_bci_aaa(p)%basis(2,q)
             symi = Sym_Basis_bci_aaa(p)%basis(3,q)
             d2symgp = ProductTable(symi,syma)
             d2symgp = ProductTable(symb,symc)
             d2row =  IbD2aa(d2symgp)%ib(i,a)
             d2col = IbD2aa(d2symgp)%ib(b,c)
             D2matrix%aa%irrep(d2symgp)%block(d2row,d2col) = TempMat(s,q) + D2matrix%aa%irrep(d2symgp)%block(d2row,d2col)
             D2matrix%aa%irrep(d2symgp)%block(d2col,d2row) = TempMat(s,q) + D2matrix%aa%irrep(d2symgp)%block(d2col,d2row)
           end do
         end do
         deallocate(TempMat)
       end do
       deallocate(TempReshape,Reshapes)
       deallocate(TempDerivReshape,DerivReshapes)

      allocate(DerivReshapes(1:numSG))
      allocate(TempDerivReshape(1:numSG))
      allocate(Reshapes(1:numSG))
      allocate(TempReshape(1:numSG))
      Call reshape_jka_bbbOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_bbetaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      deallocate(DerivReshapes,TempDerivReshape)
      do p=1,numSG
        numcols = ReshapedMatrixDim%jka_bbb(p)%col
        numrows = ReshapedMatrixDim%i_beta(p)%col
        allocate(TempMat(1:numrows,1:numcols))
        TempMat =  matmul4(TempReshape(p)%ReshapedMatrix,Reshapes(p)%ReshapedMatrix)
        do q=1,numcols
          do s=1,numrows
            i = Basis_i_beta(p)%basis(1,s)
            j = Basis_jka_bbb(p)%basis(1,q)
            k = Basis_jka_bbb(p)%basis(2,q)
            a = Basis_jka_bbb(p)%basis(3,q)
            symi = Sym_Basis_i_beta(p)%basis(1,s)
            symj = Sym_Basis_jka_bbb(p)%basis(1,q)
            symk = Sym_Basis_jka_bbb(p)%basis(2,q)
            syma = Sym_Basis_jka_bbb(p)%basis(3,q)
            d2symgp = ProductTable(symj,symk)
            d2symgp = ProductTable(symi,syma)
            d2col = IbD2bb(d2symgp)%ib(j,k)
            d2row = IbD2bb(d2symgp)%ib(i,a)
            D2matrix%bb%irrep(d2symgp)%block(d2row,d2col) = TempMat(s,q) + D2matrix%bb%irrep(d2symgp)%block(d2row,d2col)
            D2matrix%bb%irrep(d2symgp)%block(d2col,d2row) = TempMat(s,q) + D2matrix%bb%irrep(d2symgp)%block(d2col,d2row)
          end do
        end do
        deallocate(TempMat)
      end do
      deallocate(Reshapes)
      deallocate(TempReshape)
      allocate(DerivReshapes(1:numSG))
      allocate(TempDerivReshape(1:numSG))
      allocate(Reshapes(1:numSG))
      allocate(TempReshape(1:numSG))
      Call reshape_bci_bbbOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_ibetaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
       do p=1,numSG
         numcols= ReshapedMatrixDim%bci_bbb(p)%col
         numrows = ReshapedMatrixDim%a_beta(p)%col
         allocate(TempMat(1:numrows,1:numcols))
         TempMat = matmul4(TempReshape(p)%ReshapedMatrix,Reshapes(p)%ReshapedMatrix)
         do q=1,numcols
           do s=1,numrows
             a = Basis_a_beta(p)%basis(1,s)
             b = Basis_bci_bbb(p)%basis(1,q)
             c = Basis_bci_bbb(p)%basis(2,q)
             i = Basis_bci_bbb(p)%basis(3,q)
             syma = Sym_Basis_a_beta(p)%basis(1,s)
             symb = Sym_Basis_bci_bbb(p)%basis(1,q)
             symc = Sym_Basis_bci_bbb(p)%basis(2,q)
             symi = Sym_Basis_bci_bbb(p)%basis(3,q)
             d2symgp = ProductTable(symi,syma)
             d2symgp = ProductTable(symb,symc)
             d2row =  IbD2bb(d2symgp)%ib(i,a)
             d2col = IbD2bb(d2symgp)%ib(b,c)
             D2matrix%bb%irrep(d2symgp)%block(d2row,d2col) = TempMat(s,q) + D2matrix%bb%irrep(d2symgp)%block(d2row,d2col)
             D2matrix%bb%irrep(d2symgp)%block(d2col,d2row) = TempMat(s,q) + D2matrix%bb%irrep(d2symgp)%block(d2col,d2row)
           end do
         end do
         deallocate(TempMat)
       end do
       deallocate(TempReshape,Reshapes)
       deallocate(TempDerivReshape,DerivReshapes)





       allocate(DerivReshapes(1:numSG))
       allocate(TempDerivReshape(1:numSG))
       allocate(Reshapes(1:numSG))
       allocate(TempReshape(1:numSG))
      Call reshape_jka_abbOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_balphaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
       deallocate(DerivReshapes,TempDerivReshape)
      do p=1,numSG
        numrows = ReshapedMatrixDim%i_alpha(p)%col
        numcols = ReshapedMatrixDim%jka_abb(p)%col
        allocate(TempMat(1:numrows,1:numcols))
        TempMat(1:numrows,1:numcols) = 0.D0
        TempMat =  -1*matmul4(TempReshape(p)%ReshapedMatrix,Reshapes(p)%ReshapedMatrix)
         do q=1,numcols
           do s=1,numrows
             i = Basis_i_alpha(p)%basis(1,s)
             j = Basis_jka_abb(p)%basis(1,q)
             k = Basis_jka_abb(p)%basis(2,q)
             a = Basis_jka_abb(p)%basis(3,q)
             symi = Sym_Basis_i_alpha(p)%basis(1,s)
             symj = Sym_Basis_jka_abb(p)%basis(1,q)
             symk = Sym_Basis_jka_abb(p)%basis(2,q)
             syma = Sym_Basis_jka_abb(p)%basis(3,q)
             d2symgp = ProductTable(symi,syma)
             d2symgp = ProductTable(symj,symk)
             d2row =  IbD2ab(d2symgp)%ib(i,a)
             d2col = IbD2ab(d2symgp)%ib(j,k)
             D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = TempMat(s,q) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
             D2matrix%ab%irrep(d2symgp)%block(d2col,d2row) = TempMat(s,q) + D2matrix%ab%irrep(d2symgp)%block(d2col,d2row)
           end do
         end do
         deallocate(TempMat)
      end do
      deallocate(TempReshape)
      deallocate(Reshapes)
       allocate(DerivReshapes(1:numSG))
       allocate(TempDerivReshape(1:numSG))
       allocate(Reshapes(1:numSG))
       allocate(TempReshape(1:numSG))
       Call reshape_jka_abaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       Call reshape_t1_bbetaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
       do p=1,numSG
        numrows = ReshapedMatrixDim%i_beta(p)%col
        numcols = ReshapedMatrixDim%jka_aba(p)%col
        allocate(TempMat(1:numrows,1:numcols))
        TempMat  = -1*matmul4(TempReshape(p)%ReshapedMatrix,Reshapes(p)%ReshapedMatrix)
         do q=1,numcols
           do s=1,numrows
             i = Basis_i_beta(p)%basis(1,s)
             j = Basis_jka_aba(p)%basis(1,q)
             k = Basis_jka_aba(p)%basis(2,q)
             a = Basis_jka_aba(p)%basis(3,q)
             symi = Sym_Basis_i_beta(p)%basis(1,s)
             symj = Sym_Basis_jka_aba(p)%basis(1,q)
             symk = Sym_Basis_jka_aba(p)%basis(2,q)
             syma = Sym_Basis_jka_aba(p)%basis(3,q)
             d2symgp = ProductTable(syma,symi)
             d2symgp = ProductTable(symj,symk)
             d2row =  IbD2ab(d2symgp)%ib(a,i)
             d2col = IbD2ab(d2symgp)%ib(j,k)
             D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = TempMat(s,q) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
             D2matrix%ab%irrep(d2symgp)%block(d2col,d2row) = TempMat(s,q) + D2matrix%ab%irrep(d2symgp)%block(d2col,d2row)
           end do
         end do
         deallocate(TempMat)
      end do
      deallocate(Reshapes,TempReshape)
      deallocate(DerivReshapes,TempDerivReshape)
      allocate(DerivReshapes(1:numSG))
      allocate(TempDerivReshape(1:numSG))
      allocate(Reshapes(1:numSG))
      allocate(TempReshape(1:numSG))
      Call reshape_bci_abaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_ibetaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      deallocate(DerivReshapes,TempDerivReshape)
      do p=1,numSG
        numrows = ReshapedMatrixDim%a_beta(p)%col
        numcols = ReshapedMatrixDim%bci_aba(p)%col
        allocate(TempMat(1:numrows,1:numcols))
        TempMat = matmul4(TempReshape(p)%ReshapedMatrix,Reshapes(p)%ReshapedMatrix)
         do q=1,numcols
           do s=1,numrows
             a = Basis_a_beta(p)%basis(1,s)
             b = Basis_bci_aba(p)%basis(1,q)
             c = Basis_bci_aba(p)%basis(2,q)
             i = Basis_bci_aba(p)%basis(3,q)
             syma = Sym_Basis_a_beta(p)%basis(1,s)
             symb = Sym_Basis_bci_aba(p)%basis(1,q)
             symc = Sym_Basis_bci_aba(p)%basis(2,q)
             symi = Sym_Basis_bci_aba(p)%basis(3,q)
             d2symgp = ProductTable(symi,syma)
             d2symgp = ProductTable(symb,symc)
             d2row =  IbD2ab(d2symgp)%ib(i,a)
             d2col = IbD2ab(d2symgp)%ib(b,c)
             D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = TempMat(s,q) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
             D2matrix%ab%irrep(d2symgp)%block(d2col,d2row) = TempMat(s,q) + D2matrix%ab%irrep(d2symgp)%block(d2col,d2row)
           end do
         end do
         deallocate(TempMat)
      end do
      deallocate(Reshapes,TempReshape)
     allocate(DerivReshapes(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempReshape(1:numSG))
     Call reshape_bci_abbOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ialphaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
     deallocate(DerivReshapes,TempDerivReshape)
       do p=1,numSG
         numrows = ReshapedMatrixDim%a_alpha(p)%col
         numcols = ReshapedMatrixDim%bci_abb(p)%col
         allocate(TempMat(1:numrows,1:numcols))
         TempMat = matmul4(TempReshape(p)%ReshapedMatrix,Reshapes(p)%ReshapedMatrix)
         do q=1,numcols
           do s=1,numrows
             a = Basis_a_alpha(p)%basis(1,s)
             b = Basis_bci_abb(p)%basis(1,q)
             c = Basis_bci_abb(p)%basis(2,q)
             i = Basis_bci_abb(p)%basis(3,q)
             syma = Sym_Basis_a_alpha(p)%basis(1,s)
             symb = Sym_Basis_bci_abb(p)%basis(1,q)
             symc = Sym_Basis_bci_abb(p)%basis(2,q)
             symi = Sym_Basis_bci_abb(p)%basis(3,q)
             d2symgp = ProductTable(syma,symi)
             d2symgp = ProductTable(symb,symc)
             d2row = IbD2ab(d2symgp)%ib(a,i)
             d2col = IbD2ab(d2symgp)%ib(b,c)
             D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = TempMat(s,q) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
             D2matrix%ab%irrep(d2symgp)%block(d2col,d2row) = TempMat(s,q) + D2matrix%ab%irrep(d2symgp)%block(d2col,d2row)
           end do
         end do
         deallocate(TempMat)
       end do
       deallocate(TempReshape,Reshapes)






     do symgp=1,numSG
       do t=1,numSG
         p = InvPdt(symgp)%upper(t)
         q = InvPdt(symgp)%lower(t)
         a_begin = virt_alpha(1,p)
         a_end   = virt_alpha(2,p)
         i_begin = occ_alpha(1,q)
         i_end   = occ_alpha(2,q)
         j_begin = occ_alpha(1,p)
         j_end   = occ_alpha(2,p)
         b_begin = virt_alpha(1,q)
         b_end   = virt_alpha(2,q)
         do a=a_begin,a_end
           do j=j_begin,j_end
             do b=b_begin,b_end
               do i=i_begin,i_end
                 d2symgp = ProductTable(q,p)
                 d2row = IbD2aa(d2symgp)%ib(i,a)
                 d2col = IbD2aa(d2symgp)%ib(j,b)
                 D2matrix%aa%irrep(d2symgp)%block(d2row,d2col) = -1*T1data%a%o(j)%vsym(p)%v(a)*T1data%a%o(i)%vsym(q)%v(b) + D2matrix%aa%irrep(d2symgp)%block(d2row,d2col)
               end do
             end do
           end do
         end do
       end do
     end do

     do symgp=1,numSG
       do t=1,numSG
         p = InvPdt(symgp)%upper(t)
         q = InvPdt(symgp)%lower(t)
         a_begin = virt_beta(1,p)
         a_end   = virt_beta(2,p)
         i_begin = occ_beta(1,q)
         i_end   = occ_beta(2,q)
         j_begin = occ_beta(1,p)
         j_end   = occ_beta(2,p)
         b_begin = virt_beta(1,q)
         b_end   = virt_beta(2,q)
         do a=a_begin,a_end
           do j=j_begin,j_end
             do b=b_begin,b_end
               do i=i_begin,i_end
                 d2symgp = ProductTable(q,p)
                 d2row = IbD2bb(d2symgp)%ib(i,a)
                 d2col = IbD2bb(d2symgp)%ib(j,b)
                 D2matrix%bb%irrep(d2symgp)%block(d2row,d2col) = -1*T1data%b%o(j)%vsym(p)%v(a)*T1data%b%o(i)%vsym(q)%v(b) + D2matrix%bb%irrep(d2symgp)%block(d2row,d2col)
               end do
             end do
           end do
         end do
       end do
     end do





     do symgp=1,numSG
       do t=1,numSG
         p = InvPdt(symgp)%upper(t)
         q = InvPdt(symgp)%lower(t)
         a_begin = virt_beta(1,p)
         a_end   = virt_beta(2,p)
         i_begin = occ_alpha(1,q)
         i_end   = occ_alpha(2,q)
         j_begin = occ_beta(1,p)
         j_end   = occ_beta(2,p)
         b_begin = virt_alpha(1,q)
         b_end   = virt_alpha(2,q)
         do a=a_begin,a_end
           do j=j_begin,j_end
             do b=b_begin,b_end
               do i=i_begin,i_end
                 d2symgp = ProductTable(q,p)
                 d2row = IbD2ab(d2symgp)%ib(i,a)
                 d2col = IbD2ab(d2symgp)%ib(b,j)
                 D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = 1*T1data%b%o(j)%vsym(p)%v(a)*T1data%a%o(i)%vsym(q)%v(b) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
                 D2matrix%ab%irrep(d2symgp)%block(d2col,d2row) = 1*T1data%b%o(j)%vsym(p)%v(a)*T1data%a%o(i)%vsym(q)%v(b) + D2matrix%ab%irrep(d2symgp)%block(d2col,d2row)
               end do
             end do
           end do
         end do
       end do
     end do





       do symgp=1,numSG
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_alpha(1,q)
           k_end   = occ_alpha(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_alpha(1,r)
             a_end   = virt_alpha(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                   do i=i_begin,i_end
                     if(i.eq.j.and.r.eq.q) then
                       d2row = IbD2aa(ProductTable(symgp,r))%ib(i,a)
                       d2col = IbD2aa(ProductTable(q,s))%ib(j,k)
                       d2symgp = ProductTable(symgp,r)
                       d1row = a - a_begin + 1 + numocc_alpha_sg(r)
                       d1col = k - k_begin + 1

                       D2matrix%aa%irrep(d2symgp)%block(d2row,d2col) = D1alpha_cum(r)%D1block(d1row,d1col) +  D2matrix%aa%irrep(d2symgp)%block(d2row,d2col)
                       D2matrix%aa%irrep(d2symgp)%block(d2col,d2row) = D1alpha_cum(r)%D1block(d1row,d1col) +  D2matrix%aa%irrep(d2symgp)%block(d2col,d2row)
                     end if
                     if(i.eq.k.and.r.eq.s) then
                       d2row = IbD2aa(ProductTable(symgp,r))%ib(i,a)
                       d2col = IbD2aa(ProductTable(q,s))%ib(j,k)
                       d2symgp = ProductTable(symgp,r)
                       d1row = a - a_begin + 1 + numocc_alpha_sg(r)
                       d1col = j - j_begin + 1
                       D2matrix%aa%irrep(d2symgp)%block(d2row,d2col) = -1*D1alpha_cum(r)%D1block(d1row,d1col) +  D2matrix%aa%irrep(d2symgp)%block(d2row,d2col)
                       D2matrix%aa%irrep(d2symgp)%block(d2col,d2row) = -1*D1alpha_cum(r)%D1block(d1row,d1col) +  D2matrix%aa%irrep(d2symgp)%block(d2col,d2row)
                    end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_beta(1,r)
             a_end   = virt_beta(2,r)
             j_begin = occ_beta(1,s)
             j_end   = occ_beta(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                   do i=i_begin,i_end
                     if(i.eq.j.and.r.eq.q) then
                       d2row = IbD2bb(ProductTable(symgp,r))%ib(i,a)
                       d2col = IbD2bb(ProductTable(q,s))%ib(j,k)
                       d2symgp = ProductTable(symgp,r)
                       d1row = a - a_begin + 1 + numocc_beta_sg(r)
                       d1col = k - k_begin + 1
                       D2matrix%bb%irrep(d2symgp)%block(d2row,d2col) = D1beta_cum(r)%D1block(d1row,d1col) +  D2matrix%bb%irrep(d2symgp)%block(d2row,d2col)
                       D2matrix%bb%irrep(d2symgp)%block(d2col,d2row) = D1beta_cum(r)%D1block(d1row,d1col) +  D2matrix%bb%irrep(d2symgp)%block(d2col,d2row)
                     end if
                     if(i.eq.k.and.r.eq.s) then
                       d2row = IbD2bb(ProductTable(symgp,r))%ib(i,a)
                       d2col = IbD2bb(ProductTable(q,s))%ib(j,k)
                       d2symgp = ProductTable(symgp,r)
                       d1row = a - a_begin + 1 + numocc_beta_sg(r)
                       d1col = j - j_begin + 1
                       D2matrix%bb%irrep(d2symgp)%block(d2row,d2col) = -1*D1beta_cum(r)%D1block(d1row,d1col) +  D2matrix%bb%irrep(d2symgp)%block(d2row,d2col)
                       D2matrix%bb%irrep(d2symgp)%block(d2col,d2row) = -1*D1beta_cum(r)%D1block(d1row,d1col) +  D2matrix%bb%irrep(d2symgp)%block(d2col,d2row)
                    end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do






       do symgp=1,numSG
         i_begin = occ_alpha(1,symgp)
         i_end   = occ_alpha(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_beta(1,r)
             a_end   = virt_beta(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do k=k_begin,k_end
                 do a=a_begin,a_end
                   do i=i_begin,i_end
                     if(i.eq.j.and.r.eq.q) then
                       d2symgp = ProductTable(symgp,r)
                       d2symgp = ProductTable(s,q)
                       d2row = IbD2ab(d2symgp)%ib(i,a)
                       d2col = IbD2ab(d2symgp)%ib(j,k)
                       D1row = a - a_begin + 1 + numocc_beta_sg(r)
                       D1col = k - k_begin + 1
                       D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = D1beta_cum(r)%D1block(D1row,D1col) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
                       D2matrix%ab%irrep(d2symgp)%block(d2col,d2row) = D1beta_cum(r)%D1block(D1row,D1col) + D2matrix%ab%irrep(d2symgp)%block(d2col,d2row)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         i_begin = occ_beta(1,symgp)
         i_end   = occ_beta(2,symgp)
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_alpha(1,r)
             a_end   = virt_alpha(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=k_begin,k_end
                   do i=i_begin,i_end
                      if(i.eq.k.and.r.eq.s) then
                       d2row = IbD2ab(ProductTable(symgp,r))%ib(a,i)
                       d2col = IbD2ab(ProductTable(q,s))%ib(j,k)
                       d2symgp = ProductTable(symgp,r)
                       d1row = a - a_begin + 1 + numocc_alpha_sg(r)
                       d1col = j - j_begin + 1
                       D2matrix%ab%irrep(d2symgp)%block(d2row,d2col) = 1*D1alpha_cum(r)%D1block(d1row,d1col) + D2matrix%ab%irrep(d2symgp)%block(d2row,d2col)
                       D2matrix%ab%irrep(d2symgp)%block(d2col,d2row) = 1*D1alpha_cum(r)%D1block(d1row,d1col) + D2matrix%ab%irrep(d2symgp)%block(d2col,d2row)
                     end if
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do




      Call BuildQ2G2OS(D2matrix,D1alpha_cum,D1beta_cum,IbD2aa,IbD2bb,IbD2ab,occ_alpha,occ_beta,virt_alpha,virt_beta,InvPdt,ProductTable,numSG,ReshapedMatrixDim,filename)



       end subroutine BuildD2OS

!> @brief Helper routine for BuildD2OS.  Maps D2 matrix elements to proper place in matrix. 
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine MapD2OS(numSG,occ_alpha,occ_beta,virt_alpha,virt_beta,ReshapedMatrixDim,IbD2aa,IbD2ab,IbD2bb, Basis_ajaa, Basis_ajbb,Basis_ajab,Basis_jaab,Basis_jka_aaa,Basis_jka_bbb,Basis_bci_aaa,Basis_bci_bbb,Basis_jka_aba, Basis_jka_abb, Basis_bci_aba, Basis_bci_abb,Basis_i_alpha,Basis_i_beta,Basis_a_alpha,Basis_a_beta,Sym_Basis_jka_aaa,Sym_Basis_jka_bbb,Sym_Basis_bci_aaa,Sym_Basis_bci_bbb,Sym_Basis_jka_aba, Sym_Basis_jka_abb, Sym_Basis_bci_aba,Sym_Basis_bci_abb,Sym_Basis_i_alpha, Sym_Basis_i_beta, Sym_Basis_a_alpha, Sym_Basis_a_beta,InvPdt,Sym_Basis_ajaa,Sym_Basis_ajbb,Sym_Basis_ajab,Sym_Basis_jaab)

       Use InterfaceMod
       Use TypeMod
       Implicit NONE
       integer :: numSG
       integer, intent(IN), dimension(1:2,1:numSG) :: occ_alpha, occ_beta,virt_alpha, virt_beta
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim

       type(BasisMap2), allocatable, dimension(:) :: D2aabasis, D2abbasis, D2bbbasis
       type(InverseBasis2), allocatable, dimension(:) :: IbD2aa, IbD2bb
       type(InverseBasis2), allocatable, dimension(:) :: IbD2ab
       type(BasisMap2), allocatable, dimension(:) :: Basis_ajaa, Basis_ajab, Basis_jaab, Basis_ajbb
       type(BasisMap3), allocatable, dimension(:) :: Basis_jka_aaa, Basis_bci_aaa, Basis_jka_bbb, Basis_bci_bbb
       type(BasisMap3), allocatable, dimension(:) :: Basis_jka_aba, Basis_jka_abb, Basis_bci_aba, Basis_bci_abb
       type(BasisMap1), allocatable, dimension(:) :: Basis_i_alpha, Basis_i_beta,Basis_a_alpha, Basis_a_beta
       type(BasisMap2), allocatable, dimension(:) :: Sym_Basis_ajaa, Sym_Basis_ajab, Sym_Basis_jaab, Sym_Basis_ajbb
       type(BasisMap3), allocatable, dimension(:) :: Sym_Basis_jka_aaa, Sym_Basis_bci_aaa, Sym_Basis_jka_bbb, Sym_Basis_bci_bbb
       type(BasisMap3), allocatable, dimension(:) :: Sym_Basis_jka_aba, Sym_Basis_jka_abb, Sym_Basis_bci_aba, Sym_Basis_bci_abb
       type(BasisMap1), allocatable, dimension(:) :: Sym_Basis_i_alpha, Sym_Basis_i_beta, Sym_Basis_a_alpha, Sym_Basis_a_beta
       type(symmetry), intent(IN) :: InvPdt(1:numSG)


       integer :: i,j,a,b,i_begin,i_end,j_begin,j_end,a_begin,a_end,b_begin,b_end,numj
       integer :: symgp,numocc_alpha,numocc_beta,numvirt_alpha,numvirt_beta,norb
       integer :: t,u,col,q,p,r,s, k_begin,k_end,numk,numa,k,numi,c_begin,c_end,numc,numb,c
       integer :: numrow,numcol
       integer, allocatable, dimension(:) :: coloffset
       allocate(coloffset(1:numSG))
       coloffset(1:numSG) = 0.D0

       numocc_alpha = 0
       numvirt_alpha = 0
       numocc_beta = 0
       numvirt_beta = 0
       do p=1,numSG
         i_begin = occ_alpha(1,p)
         i_end   = occ_alpha(2,p)
         a_begin = virt_alpha(1,p)
         a_end   = virt_alpha(2,p)
         numocc_alpha = numocc_alpha + i_end - i_begin + 1
         numvirt_alpha = numvirt_alpha + a_end - a_begin + 1
       end do

       do p=1,numSG
         i_begin = occ_beta(1,p)
         i_end   = occ_beta(2,p)
         a_begin = virt_beta(1,p)
         a_end   = virt_beta(2,p)
         numocc_beta = numocc_beta + i_end - i_begin + 1
         numvirt_beta = numvirt_beta + a_end - a_begin + 1
       end do

       norb = numocc_alpha + numvirt_alpha

       allocate(D2aabasis(1:numSG))
       do symgp=1,numSG
         numrow = ReshapedMatrixDim%ijaa(symgp)%col + ReshapedMatrixDim%ajaa(symgp)%col + ReshapedMatrixDim%ijaa(symgp)%row
         allocate(D2aabasis(symgp)%basis(1:2,1:numrow))
         D2aabasis(symgp)%basis(1:2,1:numrow) = 0
         allocate(IbD2aa(symgp)%ib(1:norb,1:norb))
         IbD2aa(symgp)%ib(1:norb,1:norb) = 0.D0
       end do
       allocate(D2bbbasis(1:numSG))
       do symgp=1,numSG
         numrow = ReshapedMatrixDim%ijbb(symgp)%col + ReshapedMatrixDim%ajbb(symgp)%col + ReshapedMatrixDim%ijbb(symgp)%row
         allocate(D2bbbasis(symgp)%basis(1:2,1:numrow))
         D2bbbasis(symgp)%basis(1:2,1:numrow) = 0
         allocate(IbD2bb(symgp)%ib(1:norb,1:norb))
         IbD2bb(symgp)%ib(1:norb,1:norb) = 0.D0
       end do

       allocate(D2abbasis(1:numSG))
       do symgp=1,numSG
         numrow = ReshapedMatrixDim%ijab(symgp)%row + ReshapedMatrixDim%ijab(symgp)%col + ReshapedMatrixDim%ajab(symgp)%col + ReshapedMatrixDim%ajba(symgp)%col
         allocate(D2abbasis(symgp)%basis(1:2,1:numrow))
         D2abbasis(symgp)%basis(1:2,1:numrow) = 0
         allocate(IbD2ab(symgp)%ib(1:norb,1:norb))
         IbD2ab(symgp)%ib(1:norb,1:norb) = 0
       end do


       do symgp=1,numSG
         col = 1
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           if(p.gt.q) then
             cycle
           end if
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               D2aabasis(symgp)%basis(1,col) = i
               D2aabasis(symgp)%basis(2,col) = j
               IbD2aa(symgp)%ib(i,j) = col
               IbD2aa(symgp)%ib(j,i) = col
               coloffset(symgp) = col
               col = col + 1
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = coloffset(symgp) + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           i_begin = occ_alpha(1,q)
           i_end   = occ_alpha(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               D2aabasis(symgp)%basis(1,col) = i
               D2aabasis(symgp)%basis(2,col) = a
               IbD2aa(symgp)%ib(i,a) = col
               IbD2aa(symgp)%ib(a,i) = col
               coloffset(symgp) = col
               col = col + 1
             end do
           end do
         end do
       end do
      do symgp=1,numSG
        col = coloffset(symgp) + 1
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          if(p.gt.q) then
            cycle
          end if
          a_begin = virt_alpha(1,p)
          a_end   = virt_alpha(2,p)
          b_begin = virt_alpha(1,q)
          b_end   = virt_alpha(2,q)
          do a=a_begin,a_end
            do b=max(a+1,b_begin),b_end
              D2aabasis(symgp)%basis(1,col) = a
              D2aabasis(symgp)%basis(2,col) = b
              IbD2aa(symgp)%ib(a,b) = col
              IbD2aa(symgp)%ib(b,a) = col
              col = col + 1
             end do
           end do
         end do
       end do
       coloffset(1:numSG) = 0.D0
       do symgp=1,numSG
         col = 1
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           if(p.gt.q) then
             cycle
           end if
           i_begin = occ_beta(1,p)
           i_end   = occ_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               D2bbbasis(symgp)%basis(1,col) = i
               D2bbbasis(symgp)%basis(2,col) = j
               IbD2bb(symgp)%ib(i,j) = col
               IbD2bb(symgp)%ib(j,i) = col
               coloffset(symgp) = col
               col = col + 1
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = coloffset(symgp) + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           i_begin = occ_beta(1,q)
           i_end   = occ_beta(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               D2bbbasis(symgp)%basis(1,col) = i
               D2bbbasis(symgp)%basis(2,col) = a
               IbD2bb(symgp)%ib(i,a) = col
               IbD2bb(symgp)%ib(a,i) = col
               coloffset(symgp) = col
               col = col + 1
             end do
           end do
         end do
       end do
      do symgp=1,numSG
        col = coloffset(symgp) + 1
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          if(p.gt.q) then
            cycle
          end if
          a_begin = virt_beta(1,p)
          a_end   = virt_beta(2,p)
          b_begin = virt_beta(1,q)
          b_end   = virt_beta(2,q)
          do a=a_begin,a_end
            do b=max(a+1,b_begin),b_end
              D2bbbasis(symgp)%basis(1,col) = a
              D2bbbasis(symgp)%basis(2,col) = b
              IbD2bb(symgp)%ib(a,b) = col
              IbD2bb(symgp)%ib(b,a) = col
              col = col + 1
             end do
           end do
         end do
       end do

        coloffset(1:numSG) = 0
        do symgp=1,numSG
         col = 1
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               D2abbasis(symgp)%basis(1,col) = i
               D2abbasis(symgp)%basis(2,col) = j
               IbD2ab(symgp)%ib(i,j) = col
               coloffset(symgp) = col
               col = col + 1
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = coloffset(symgp) + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           i_begin = occ_alpha(1,q)
           i_end   = occ_alpha(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               D2abbasis(symgp)%basis(1,col) = i
               D2abbasis(symgp)%basis(2,col) = a
               coloffset(symgp) = col
               IbD2ab(symgp)%ib(i,a) = col
               col = col + 1
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = coloffset(symgp) + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           i_begin = occ_beta(1,q)
           i_end   = occ_beta(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               D2abbasis(symgp)%basis(1,col) = a
               D2abbasis(symgp)%basis(2,col) = i
               coloffset(symgp) = col
               IbD2ab(symgp)%ib(a,i) = col
               col = col + 1
             end do
           end do
         end do
       end do
       do symgp=1,numSG
         col = coloffset(symgp) + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           b_begin = virt_beta(1,q)
           b_end   = virt_beta(2,q)
           do a=a_begin,a_end
             do b=b_begin,b_end
               D2abbasis(symgp)%basis(1,col) = a
               D2abbasis(symgp)%basis(2,col) = b
               IbD2ab(symgp)%ib(a,b) = col
               col = col + 1
              end do
            end do
          end do
        end do


       allocate(Basis_ajaa(1:numSG))
       allocate(Sym_Basis_ajaa(1:numSG))
       do symgp=1,numSG
         numrow = ReshapedMatrixDim%ajaa(symgp)%col
         allocate(Basis_ajaa(symgp)%basis(1:2,1:numrow))
         Basis_ajaa(symgp)%basis(1:2,1:numrow) = 0
         allocate(Sym_Basis_ajaa(symgp)%basis(1:2,1:numrow))
         Sym_Basis_ajaa(symgp)%basis(1:2,1:numrow) = 0
       end do

       do symgp=1,numSG
         col = 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               Basis_ajaa(symgp)%basis(1,col) = j
               Basis_ajaa(symgp)%basis(2,col) = a
               Sym_Basis_ajaa(symgp)%basis(1,col) = q
               Sym_Basis_ajaa(symgp)%basis(2,col) = p
               col = col + 1
             end do
           end do
         end do
       end do
       allocate(Basis_ajbb(1:numSG))
       allocate(Sym_Basis_ajbb(1:numSG))
       do symgp=1,numSG
         numrow = ReshapedMatrixDim%ajbb(symgp)%col
         allocate(Basis_ajbb(symgp)%basis(1:2,1:numrow))
         Basis_ajbb(symgp)%basis(1:2,1:numrow) = 0
         allocate(Sym_Basis_ajbb(symgp)%basis(1:2,1:numrow))
         Sym_Basis_ajbb(symgp)%basis(1:2,1:numrow) = 0
       end do

       do symgp=1,numSG
         col = 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               Basis_ajbb(symgp)%basis(1,col) = j
               Basis_ajbb(symgp)%basis(2,col) = a
               Sym_Basis_ajbb(symgp)%basis(1,col) = q
               Sym_Basis_ajbb(symgp)%basis(2,col) = p
               col = col + 1
             end do
           end do
         end do
       end do


       allocate(Basis_ajab(1:numSG))
       allocate(Sym_Basis_ajab(1:numSG))
       do symgp=1,numSG
         numrow = ReshapedMatrixDim%ajab(symgp)%col
         allocate(Basis_ajab(symgp)%basis(1:2,1:numrow))
         Basis_ajab(symgp)%basis(1:2,1:numrow) = 0
         allocate(Sym_Basis_ajab(symgp)%basis(1:2,1:numrow))
         Sym_Basis_ajab(symgp)%basis(1:2,1:numrow) = 0
      end do

       do symgp=1,numSG
         col = 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do a=a_begin,a_end
             do j=j_begin,j_end
               Basis_ajab(symgp)%basis(1,col) = a
               Basis_ajab(symgp)%basis(2,col) = j
               Sym_Basis_ajab(symgp)%basis(1,col) = p
               Sym_Basis_ajab(symgp)%basis(2,col) = q
               coloffset(symgp) = col
               col = col + 1
             end do
           end do
         end do
       end do
      allocate(Basis_jaab(1:numSG))
      allocate(Sym_Basis_jaab(1:numSG))
      do symgp=1,numSG
        numrow = ReshapedMatrixDim%ajba(symgp)%row
        allocate(Basis_jaab(symgp)%basis(1:2,1:numrow))
        Basis_jaab(symgp)%basis(1:2,1:numrow) = 0
        allocate(Sym_Basis_jaab(symgp)%basis(1:2,1:numrow))
        Sym_Basis_jaab(symgp)%basis(1:2,1:numrow) = 0
      end do

       do symgp=1,numSG
         col =  1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               Basis_jaab(symgp)%basis(1,col) = j
               Basis_jaab(symgp)%basis(2,col) = a
               Sym_Basis_jaab(symgp)%basis(1,col) = q
               Sym_Basis_jaab(symgp)%basis(2,col) = p
               coloffset(symgp) = col
               col = col + 1
             end do
           end do
         end do
       end do


       allocate(Basis_jka_aaa(1:numSG))
       allocate(Sym_Basis_jka_aaa(1:numSG))
       do symgp=1,numSG
         numrow = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_alpha(1,q)
           k_end   = occ_alpha(2,q)
           numk = k_end - k_begin + 1
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_alpha(1,r)
             a_end   = virt_alpha(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             numa = a_end - a_begin + 1
             numj = j_end - j_begin + 1
             if(j_begin.eq.k_begin) then
               numrow = numrow + numj*(numk-1)*numa/2
             else
               numrow = numrow + numj*numk*numa
             end if
           end do
         end do
         allocate(Basis_jka_aaa(symgp)%basis(1:3,1:numrow))
         Basis_jka_aaa(symgp)%basis(1:3,1:numrow) = 0
         allocate(Sym_Basis_jka_aaa(symgp)%basis(1:3,1:numrow))
         Sym_Basis_jka_aaa(symgp)%basis(1:3,1:numrow) = 0
       end do

       do symgp=1,numSG
         col = 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_alpha(1,q)
           k_end   = occ_alpha(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_alpha(1,r)
             a_end   = virt_alpha(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                   Basis_jka_aaa(symgp)%basis(1,col) = j
                   Basis_jka_aaa(symgp)%basis(2,col) = k
                   Basis_jka_aaa(symgp)%basis(3,col) = a
                   Sym_Basis_jka_aaa(symgp)%basis(1,col) = s
                   Sym_Basis_jka_aaa(symgp)%basis(2,col) = q
                   Sym_Basis_jka_aaa(symgp)%basis(3,col) = r
                   col = col + 1
                 end do
               end do
             end do
           end do
         end do
       end do
      allocate(Basis_i_alpha(1:numSG))
      allocate(Sym_Basis_i_alpha(1:numSG))
      do symgp=1,numSG
        col = 1
        i_begin = occ_alpha(1,symgp)
        i_end   = occ_alpha(2,symgp)
        numi = i_end - i_begin + 1
        allocate(Basis_i_alpha(symgp)%basis(1:1,1:numi))
        Basis_i_alpha(symgp)%basis(1,1:numi) = 0
        allocate(Sym_Basis_i_alpha(symgp)%basis(1,1:numi))
        Sym_Basis_i_alpha(symgp)%basis(1,1:numi) = 0
        do i=i_begin,i_end
          Basis_i_alpha(symgp)%basis(1,col) = i
          Sym_Basis_i_alpha(symgp)%basis(1,col) = symgp
          col = col + 1
        end do
      end do

       allocate(Basis_bci_aaa(1:numSG))
       allocate(Sym_Basis_bci_aaa(1:numSG))
       do symgp=1,numSG
         numcol = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_alpha(1,q)
           c_end   = virt_alpha(2,q)
           numc = c_end - c_begin + 1
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_alpha(1,r)
             b_end   = virt_alpha(2,r)
             i_begin = occ_alpha(1,s)
             i_end   = occ_alpha(2,s)
             numb = b_end - b_begin + 1
             numi = i_end - i_begin + 1
             if(c_begin.eq.b_begin) then
               numcol = numcol + numi*numb*(numc-1)/2
             else
               numcol = numcol + numi*numb*numc
             end if
          end do
         end do
        allocate(Basis_bci_aaa(symgp)%basis(1:3,1:numcol))
        Basis_bci_aaa(symgp)%basis(1:3,1:numcol) = 0
        allocate(Sym_Basis_bci_aaa(symgp)%basis(1:3,1:numcol))
        Sym_Basis_bci_aaa(symgp)%basis(1:3,1:numcol) = 0
      end do

       do symgp=1,numSG
         col = 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_alpha(1,q)
           c_end   = virt_alpha(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_alpha(1,r)
             b_end   = virt_alpha(2,r)
             i_begin = occ_alpha(1,s)
             i_end   = occ_alpha(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=max(c_begin,b+1),c_end
                   Basis_bci_aaa(symgp)%basis(1,col) = b
                   Basis_bci_aaa(symgp)%basis(2,col) = c
                   Basis_bci_aaa(symgp)%basis(3,col) = i
                   Sym_Basis_bci_aaa(symgp)%basis(1,col) = r
                   Sym_Basis_bci_aaa(symgp)%basis(2,col) = q
                   Sym_Basis_bci_aaa(symgp)%basis(3,col) = s
                   col = col + 1
                 end do
              end do
            end do
          end do
         end do
      end do
      allocate(Basis_a_alpha(1:numSG))
      allocate(Sym_Basis_a_alpha(1:numSG))
      do symgp=1,numSG
        col = 1
        a_begin = virt_alpha(1,symgp)
        a_end   = virt_alpha(2,symgp)
        numa = a_end - a_begin + 1
        allocate(Basis_a_alpha(symgp)%basis(1:1,1:numa))
        Basis_a_alpha(symgp)%basis(1,1:numa) = 0
        allocate(Sym_Basis_a_alpha(symgp)%basis(1:1,1:numa))
        Sym_Basis_a_alpha(symgp)%basis(1:1,1:numa) = 0
        do a=a_begin,a_end
          Basis_a_alpha(symgp)%basis(1,col) = a
          Sym_Basis_a_alpha(symgp)%basis(1,col) = symgp
          col = col + 1
        end do
      end do

       allocate(Basis_jka_bbb(1:numSG))
       allocate(Sym_Basis_jka_bbb(1:numSG))
       do symgp=1,numSG
         numrow = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           numk = k_end - k_begin + 1
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_beta(1,r)
             a_end   = virt_beta(2,r)
             j_begin = occ_beta(1,s)
             j_end   = occ_beta(2,s)
             numa = a_end - a_begin + 1
             numj = j_end - j_begin + 1
             if(j_begin.eq.k_begin) then
               numrow = numrow + numj*(numk-1)*numa/2
             else
               numrow = numrow + numj*numk*numa
             end if
           end do
         end do
         allocate(Basis_jka_bbb(symgp)%basis(1:3,1:numrow))
         Basis_jka_bbb(symgp)%basis(1:3,1:numrow) = 0
         allocate(Sym_Basis_jka_bbb(symgp)%basis(1:3,1:numrow))
         Sym_Basis_jka_bbb(symgp)%basis(1:3,1:numrow) = 0
       end do

       do symgp=1,numSG
         col = 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_beta(1,r)
             a_end   = virt_beta(2,r)
             j_begin = occ_beta(1,s)
             j_end   = occ_beta(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=max(k_begin,j+1),k_end
                   Basis_jka_bbb(symgp)%basis(1,col) = j
                   Basis_jka_bbb(symgp)%basis(2,col) = k
                   Basis_jka_bbb(symgp)%basis(3,col) = a
                   Sym_Basis_jka_bbb(symgp)%basis(1,col) = s
                   Sym_Basis_jka_bbb(symgp)%basis(2,col) = q
                   Sym_Basis_jka_bbb(symgp)%basis(3,col) = r
                   col = col + 1
                 end do
               end do
             end do
           end do
         end do
       end do
      allocate(Basis_i_beta(1:numSG))
      allocate(Sym_Basis_i_beta(1:numSG))
      do symgp=1,numSG
        col = 1
        i_begin = occ_beta(1,symgp)
        i_end   = occ_beta(2,symgp)
        numi = i_end - i_begin + 1
        allocate(Basis_i_beta(symgp)%basis(1:1,1:numi))
        Basis_i_beta(symgp)%basis(1,1:numi) = 0
        allocate(Sym_Basis_i_beta(symgp)%basis(1,1:numi))
        Sym_Basis_i_beta(symgp)%basis(1,1:numi) = 0
        do i=i_begin,i_end
          Basis_i_beta(symgp)%basis(1,col) = i
          Sym_Basis_i_beta(symgp)%basis(1,col) = symgp
          col = col + 1
        end do
      end do

       allocate(Basis_bci_bbb(1:numSG))
       allocate(Sym_Basis_bci_bbb(1:numSG))
       do symgp=1,numSG
         numcol = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_beta(1,q)
           c_end   = virt_beta(2,q)
           numc = c_end - c_begin + 1
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_beta(1,r)
             b_end   = virt_beta(2,r)
             i_begin = occ_beta(1,s)
             i_end   = occ_beta(2,s)
             numb = b_end - b_begin + 1
             numi = i_end - i_begin + 1
             if(c_begin.eq.b_begin) then
               numcol = numcol + numi*numb*(numc-1)/2
             else
               numcol = numcol + numi*numb*numc
             end if
          end do
         end do
        allocate(Basis_bci_bbb(symgp)%basis(1:3,1:numcol))
        Basis_bci_bbb(symgp)%basis(1:3,1:numcol) = 0
        allocate(Sym_Basis_bci_bbb(symgp)%basis(1:3,1:numcol))
        Sym_Basis_bci_bbb(symgp)%basis(1:3,1:numcol) = 0
      end do

       do symgp=1,numSG
         col = 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_beta(1,q)
           c_end   = virt_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_beta(1,r)
             b_end   = virt_beta(2,r)
             i_begin = occ_beta(1,s)
             i_end   = occ_beta(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=max(c_begin,b+1),c_end
                   Basis_bci_bbb(symgp)%basis(1,col) = b
                   Basis_bci_bbb(symgp)%basis(2,col) = c
                   Basis_bci_bbb(symgp)%basis(3,col) = i
                   Sym_Basis_bci_bbb(symgp)%basis(1,col) = r
                   Sym_Basis_bci_bbb(symgp)%basis(2,col) = q
                   Sym_Basis_bci_bbb(symgp)%basis(3,col) = s
                   col = col + 1
                 end do
              end do
            end do
          end do
         end do
      end do
      allocate(Basis_a_beta(1:numSG))
      allocate(Sym_Basis_a_beta(1:numSG))
      do symgp=1,numSG
        col = 1
        a_begin = virt_beta(1,symgp)
        a_end   = virt_beta(2,symgp)
        numa = a_end - a_begin + 1
        allocate(Basis_a_beta(symgp)%basis(1:1,1:numa))
        Basis_a_beta(symgp)%basis(1,1:numa) = 0
        allocate(Sym_Basis_a_beta(symgp)%basis(1:1,1:numa))
        Sym_Basis_a_beta(symgp)%basis(1:1,1:numa) = 0
        do a=a_begin,a_end
          Basis_a_beta(symgp)%basis(1,col) = a
          Sym_Basis_a_beta(symgp)%basis(1,col) = symgp
          col = col + 1
        end do
      end do



     allocate(Basis_jka_aba(1:numSG))
     allocate(Sym_Basis_jka_aba(1:numSG))
       do symgp=1,numSG
         numcol = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           numk = k_end - k_begin + 1
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_alpha(1,r)
             a_end   = virt_alpha(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             numa = a_end - a_begin + 1
             numj = j_end - j_begin + 1
             numcol = numcol + numa*numj*numk
           end do
         end do

         allocate(Basis_jka_aba(symgp)%basis(1:3,1:numcol))
         Basis_jka_aba(symgp)%basis(1:3,1:numcol) = 0
         allocate(Sym_Basis_jka_aba(symgp)%basis(1:3,1:numcol))
         Sym_Basis_jka_aba(symgp)%basis(1:3,1:numcol) = 0
       end do
       do symgp=1,numSG
         col = 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_alpha(1,r)
             a_end   = virt_alpha(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 do k=k_begin,k_end
                   Basis_jka_aba(symgp)%basis(1,col) = j
                   Basis_jka_aba(symgp)%basis(2,col) = k
                   Basis_jka_aba(symgp)%basis(3,col) = a
                   Sym_Basis_jka_aba(symgp)%basis(1,col) = s
                   Sym_Basis_jka_aba(symgp)%basis(2,col) = q
                   Sym_Basis_jka_aba(symgp)%basis(3,col) = r
                   col = col + 1
                 end do
               end do
             end do
          end do
        end do
      end do
      allocate(Basis_jka_abb(1:numSG))
      allocate(Sym_Basis_jka_abb(1:numSG))
       do symgp=1,numSG
         numcol = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           numk = k_end - k_begin + 1
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_beta(1,r)
             a_end   = virt_beta(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             numa = a_end - a_begin + 1
             numj = j_end - j_begin + 1
             numcol = numcol + numk*numj*numa
           end do
         end do
       allocate(Basis_jka_abb(symgp)%basis(1:3,1:numcol))
       Basis_jka_abb(symgp)%basis(1:3,1:numcol) = 0
       allocate(Sym_Basis_jka_abb(symgp)%basis(1:3,1:numcol))
       Sym_Basis_jka_abb(symgp)%basis(1:3,1:numcol) = 0
      end do

       do symgp=1,numSG
         col = 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           k_begin = occ_beta(1,q)
           k_end   = occ_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             a_begin = virt_beta(1,r)
             a_end   = virt_beta(2,r)
             j_begin = occ_alpha(1,s)
             j_end   = occ_alpha(2,s)
             do j=j_begin,j_end
               do k=k_begin,k_end
                 do a=a_begin,a_end
                   Basis_jka_abb(symgp)%basis(1,col) = j
                   Basis_jka_abb(symgp)%basis(2,col) = k
                   Basis_jka_abb(symgp)%basis(3,col) = a
                   Sym_Basis_jka_abb(symgp)%basis(1,col) = s
                   Sym_Basis_jka_abb(symgp)%basis(2,col) = q
                   Sym_Basis_jka_abb(symgp)%basis(3,col) = r
                   col = col + 1
                 end do
               end do
             end do
           end do
         end do
       end do

       allocate(Basis_bci_aba(1:numSG))
       allocate(Sym_Basis_bci_aba(1:numSG))
       do symgp=1,numSG
         numcol = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_beta(1,q)
           c_end   = virt_beta(2,q)
           numc = c_end - c_begin + 1
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_alpha(1,r)
             b_end   = virt_alpha(2,r)
             i_begin = occ_alpha(1,s)
             i_end   = occ_alpha(2,s)
             numb = b_end - b_begin + 1
             numi = i_end - i_begin + 1
             numcol = numcol + numc*numb*numi
           end do
         end do
       allocate(Basis_bci_aba(symgp)%basis(1:3,1:numcol))
       Basis_bci_aba(symgp)%basis(1:3,1:numcol) = 0
       allocate(Sym_Basis_bci_aba(symgp)%basis(1:3,1:numcol))
       Sym_Basis_bci_aba(symgp)%basis(1:3,1:numcol) = 0
      end do

       do symgp=1,numSG
         col = 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_beta(1,q)
           c_end   = virt_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_alpha(1,r)
             b_end   = virt_alpha(2,r)
             i_begin = occ_alpha(1,s)
             i_end   = occ_alpha(2,s)
             do i=i_begin,i_end
               do b=b_begin,b_end
                 do c=c_begin,c_end
                   Basis_bci_aba(symgp)%basis(1,col) = b
                   Basis_bci_aba(symgp)%basis(2,col) = c
                   Basis_bci_aba(symgp)%basis(3,col) = i
                   Sym_Basis_bci_aba(symgp)%basis(1,col) = r
                   Sym_Basis_bci_aba(symgp)%basis(2,col) = q
                   Sym_Basis_bci_aba(symgp)%basis(3,col) = s
                   col = col + 1
                 end do
               end do
             end do
           end do
         end do
       end do

      allocate(Basis_bci_abb(1:numSG))
      allocate(Sym_Basis_bci_abb(1:numSG))
       do symgp=1,numSG
         numcol = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_beta(1,q)
           c_end   = virt_Beta(2,q)
           numc = c_end - c_begin + 1
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_alpha(1,r)
             b_end   = virt_alpha(2,r)
             i_begin = occ_beta(1,s)
             i_end   = occ_beta(2,s)
             numb = b_end - b_begin + 1
             numi = i_end - i_begin + 1
             numcol = numcol + numc*numb*numi
           end do
         end do
         allocate(Basis_bci_abb(symgp)%basis(1:3,1:numcol))
         Basis_bci_abb(symgp)%basis(1:3,1:numcol) = 0
         allocate(Sym_Basis_bci_abb(symgp)%basis(1:3,1:numcol))
         Sym_Basis_bci_abb(symgp)%basis(1:3,1:numcol) = 0
       end do
       do symgp=1,numSG
         col = 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_beta(1,q)
           c_end   = virt_beta(2,q)
           do u=1,numSG
             r = InvPdt(p)%upper(u)
             s = InvPdt(p)%lower(u)
             b_begin = virt_alpha(1,r)
             b_end   = virt_alpha(2,r)
             i_begin = occ_beta(1,s)
             i_end   = occ_beta(2,s)
             do b=b_begin,b_end
               do i=i_begin,i_end
                 do c=c_begin,c_end
                   Basis_bci_abb(symgp)%basis(1,col) = b
                   Basis_bci_abb(symgp)%basis(2,col) = c
                   Basis_bci_abb(symgp)%basis(3,col) = i
                   Sym_Basis_bci_abb(symgp)%basis(1,col) = r
                   Sym_Basis_bci_abb(symgp)%basis(2,col) = q
                   Sym_Basis_bci_abb(symgp)%basis(3,col) = s
                   col = col + 1
                 end do
               end do
             end do
           end do
         end do
       end do
      end subroutine MapD2OS

!> @brief Builds Q2 and G2 matrices for open shell calculations
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine BuildQ2G2OS(D2matrix,D1alpha_cum,D1beta_cum,IbD2aa,IbD2bb,IbD2ab,occ_alpha,occ_beta,virt_alpha,virt_beta,InvPdt,ProductTable,numSG,ReshapedMatrixDim,filename)

       Use InterfaceMod
       Use TypeMod
       Implicit NONE
       integer :: numSG
       type(D2) :: D2matrix
       type(D1) :: D1alpha_cum(1:numSG), D1beta_cum(1:numSG)
       type(InverseBasis2), allocatable, dimension(:) :: IbD2aa,IbD2bb,IbD2ab
       integer, intent(IN), dimension(1:2,1:numSG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:numSG)
       integer, dimension(1:numSG,1:numSG) :: ProductTable
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       character(len=35) :: filename



       integer :: p,q,i,i_begin,i_end
       type(BasisMap2), allocatable, dimension(:) :: Q2aabasis,Q2bbbasis,Q2abbasis
       type(BasisMap2), allocatable, dimension(:) :: Q2aabasis_sym, Q2bbbasis_sym,Q2abbasis_sym
       type(BasisMap2), allocatable, dimension(:) :: G2aabasis,G2bbbasis,G2abbasis
       type(BasisMap2), allocatable, dimension(:) :: G2aabasis_sym, G2bbbasis_sym,G2abbasis_sym
       integer, allocatable, dimension(:) :: coloffset
       type(D2) :: Q2matrix
       type(InverseBasis1), allocatable, dimension(:) :: IbD1alpha, IbD1beta
       type(D1) :: G2abmatrix(1:numSG), G2bamatrix(1:numSG), G2aabbmatrix(1:numSG)
       integer :: symgp,t,a,a_begin,a_end,b,b_begin,b_end,j,j_begin,j_end,s,r
       integer :: symi,symj,symk,syml,symp,symq,symr,syms,m,n,d2row,d2col,d1col,d1row,col,numrow,row,rowdim
       integer :: sizeG2block, symkl,symkj,k,l,symik,offset,symjl,symki,symil
       character(len=100) :: Q2outputfile, G2outputfile
       double precision :: elemsign = 1.0
       integer :: sym1,sym2, numorbitals
       double precision :: collecttrace
       double precision, dimension(:) :: LowestEigD2(1:3), LowestEigQ2(1:3),LowestEigG2(1:3)
       double precision :: lowesteig

       Call FindLowestEigenvaluetypeD2(numSG,D2matrix,1,LowestEigD2(1))
       Call FindLowestEigenvaluetypeD2(numSG,D2matrix,2,LowestEigD2(2))
       Call FindLowestEigenvaluetypeD2(numSG,D2matrix,3,LowestEigD2(3))


       allocate(IbD1alpha(1:numSG))
       allocate(IbD1beta(1:numSG))

       numorbitals = 0
       do p=1,numSG
         i_begin = occ_alpha(1,p)
         i_end   = occ_alpha(2,p)
         a_begin = virt_alpha(1,p)
         a_end   = virt_alpha(2,p)
         numorbitals = numorbitals + (i_end - i_begin + 1) + (a_end - a_begin + 1)
       end do

       do p=1,numSG
         allocate(IbD1alpha(p)%ib(1:numorbitals))
         allocate(IbD1beta(p)%ib(1:numorbitals))
         IbD1alpha(p)%ib(1:numorbitals) = 0
         IbD1beta(p)%ib(1:numorbitals) = 0
       end do

       do p=1,numSG
         i_begin = occ_alpha(1,p)
         i_end   = occ_alpha(2,p)
         a_begin = virt_alpha(1,p)
         a_end   = virt_alpha(2,p)
         do i=i_begin,i_end
           d1row = i - i_begin + 1
           IbD1alpha(p)%ib(i) = d1row
         end do
         do a=a_begin,a_end
           d1row = a - a_begin + 1 + i_end - i_begin + 1
           IbD1alpha(p)%ib(a) = d1row
         end do
       end do


       do p=1,numSG
         i_begin = occ_beta(1,p)
         i_end   = occ_beta(2,p)
         a_begin = virt_beta(1,p)
         a_end   = virt_beta(2,p)
         do i=i_begin,i_end
           d1row = i - i_begin + 1
           IbD1beta(p)%ib(i) = d1row
         end do
         do a=a_begin,a_end
           d1row = a - a_begin + 1 + i_end - i_begin + 1
           IbD1beta(p)%ib(a) = d1row
         end do
       end do



       do p=1,numSG
         i_begin = occ_alpha(1,p)
         i_end   = occ_alpha(2,p)
         do i=i_begin,i_end
           D1row = i - i_begin + 1
           D1alpha_cum(p)%D1block(D1row,D1row) = 1.0 + D1alpha_cum(p)%D1block(D1row,D1row)
         end do
       end do

       do p=1,numSG
         i_begin = occ_beta(1,p)
         i_end   = occ_beta(2,p)
         do i=i_begin,i_end
           D1row = i - i_begin + 1
           D1beta_cum(p)%D1block(D1row,D1row) = 1.0 + D1beta_cum(p)%D1block(D1row,D1row)
         end do
       end do

       allocate(coloffset(1:numSG))
       coloffset(1:numSG) = 0
       allocate(Q2aabasis(1:numSG))
       allocate(Q2aabasis_sym(1:numSG))

       do symgp=1,numSG
         col = 1
         numrow = ReshapedMatrixDim%ijaa(symgp)%row + ReshapedMatrixDim%ajaa(symgp)%col + ReshapedMatrixDim%ijaa(symgp)%col
         allocate(Q2aabasis(symgp)%basis(1:2,1:numrow))
         Q2aabasis(symgp)%basis(1:2,1:numrow) = 0
         allocate(Q2aabasis_sym(symgp)%basis(1:2,1:numrow))
         Q2aabasis_sym(symgp)%basis(1:2,1:numrow) = 0
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           if(p.gt.q) then
             cycle
           end if
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               Q2aabasis(symgp)%basis(1,col) = i
               Q2aabasis(symgp)%basis(2,col) = j
               Q2aabasis_sym(symgp)%basis(1,col) = p
               Q2aabasis_sym(symgp)%basis(2,col) = q
               coloffset(symgp) = col
               col = col + 1
             end do
          end do
        end do
      end do

       do symgp=1,numSG
         col = coloffset(symgp) + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           i_begin = occ_alpha(1,q)
           i_end   = occ_alpha(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               Q2aabasis(symgp)%basis(1,col) = i
               Q2aabasis(symgp)%basis(2,col) = a
               Q2aabasis_sym(symgp)%basis(1,col) = q
               Q2aabasis_sym(symgp)%basis(2,col) = p
               coloffset(symgp) = col
               col = col + 1
             end do
           end do
         end do
       end do

      do symgp=1,numSG
        col = coloffset(symgp) + 1
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          if(p.gt.q) then
            cycle
          end if
          a_begin = virt_alpha(1,p)
          a_end   = virt_alpha(2,p)
          b_begin = virt_alpha(1,q)
          b_end   = virt_alpha(2,q)
          do a=a_begin,a_end
            do b=max(a+1,b_begin),b_end
              Q2aabasis(symgp)%basis(1,col) = a
              Q2aabasis(symgp)%basis(2,col) = b
              Q2aabasis_sym(symgp)%basis(1,col) = p
              Q2aabasis_sym(symgp)%basis(2,col) = q
              col = col + 1
             end do
           end do
         end do
       end do

       coloffset(1:numSG) = 0
       allocate(Q2bbbasis(1:numSG))
       allocate(Q2bbbasis_sym(1:numSG))

       do symgp=1,numSG
         col = 1
         numrow = ReshapedMatrixDim%ijbb(symgp)%row + ReshapedMatrixDim%ajbb(symgp)%col + ReshapedMatrixDim%ijbb(symgp)%col
         allocate(Q2bbbasis(symgp)%basis(1:2,1:numrow))
         Q2bbbasis(symgp)%basis(1:2,1:numrow) = 0
         allocate(Q2bbbasis_sym(symgp)%basis(1:2,1:numrow))
         Q2bbbasis_sym(symgp)%basis(1:2,1:numrow) = 0
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           if(p.gt.q) then
             cycle
           end if
           i_begin = occ_beta(1,p)
           i_end   = occ_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               Q2bbbasis(symgp)%basis(1,col) = i
               Q2bbbasis(symgp)%basis(2,col) = j
               Q2bbbasis_sym(symgp)%basis(1,col) = p
               Q2bbbasis_sym(symgp)%basis(2,col) = q
               coloffset(symgp) = col
               col = col + 1
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         col = coloffset(symgp) + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           i_begin = occ_beta(1,q)
           i_end   = occ_beta(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               Q2bbbasis(symgp)%basis(1,col) = i
               Q2bbbasis(symgp)%basis(2,col) = a
               Q2bbbasis_sym(symgp)%basis(1,col) = q
               Q2bbbasis_sym(symgp)%basis(2,col) = p
               coloffset(symgp) = col
               col = col + 1
             end do
           end do
         end do
       end do

      do symgp=1,numSG
        col = coloffset(symgp) + 1
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          if(p.gt.q) then
            cycle
          end if
          a_begin = virt_beta(1,p)
          a_end   = virt_beta(2,p)
          b_begin = virt_beta(1,q)
          b_end   = virt_beta(2,q)
          do a=a_begin,a_end
            do b=max(a+1,b_begin),b_end
              Q2bbbasis(symgp)%basis(1,col) = a
              Q2bbbasis(symgp)%basis(2,col) = b
              Q2bbbasis_sym(symgp)%basis(1,col) = p
              Q2bbbasis_sym(symgp)%basis(2,col) = q
              col = col + 1
             end do
           end do
         end do
       end do
        coloffset(1:numSG) = 0
        allocate(Q2abbasis(1:numSG))
        allocate(Q2abbasis_sym(1:numSG))
        do symgp=1,numSG
         col = 1
         numrow = ReshapedMatrixDim%ijab(symgp)%row + ReshapedMatrixDim%ijab(symgp)%col + ReshapedMatrixDim%ajab(symgp)%col + ReshapedMatrixDim%ajba(symgp)%col
         allocate(Q2abbasis(symgp)%basis(1:2,1:numrow))
         allocate(Q2abbasis_sym(symgp)%basis(1:2,1:numrow))
         Q2abbasis(symgp)%basis(1:2,1:numrow) = 0
         Q2abbasis_sym(symgp)%basis(1:2,1:numrow) = 0
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               Q2abbasis(symgp)%basis(1,col) = i
               Q2abbasis(symgp)%basis(2,col) = j
               Q2abbasis_sym(symgp)%basis(1,col) = p
               Q2abbasis_sym(symgp)%basis(2,col) = q
               coloffset(symgp) = col
               col = col + 1
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         col = coloffset(symgp) + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           i_begin = occ_alpha(1,q)
           i_end   = occ_alpha(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               Q2abbasis(symgp)%basis(1,col) = i
               Q2abbasis(symgp)%basis(2,col) = a
               Q2abbasis_sym(symgp)%basis(1,col) = q
               Q2abbasis_sym(symgp)%basis(2,col) = p
               coloffset(symgp) = col
               col = col + 1
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         col = coloffset(symgp) + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           i_begin = occ_beta(1,q)
           i_end   = occ_beta(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               Q2abbasis(symgp)%basis(1,col) = a
               Q2abbasis(symgp)%basis(2,col) = i
               Q2abbasis_sym(symgp)%basis(1,col) = p
               Q2abbasis_sym(symgp)%basis(2,col) = q
               coloffset(symgp) = col
               col = col + 1
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         col = coloffset(symgp) + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           b_begin = virt_beta(1,q)
           b_end   = virt_beta(2,q)
           do a=a_begin,a_end
             do b=b_begin,b_end
               Q2abbasis(symgp)%basis(1,col) = a
               Q2abbasis(symgp)%basis(2,col) = b
               Q2abbasis_sym(symgp)%basis(1,col) = p
               Q2abbasis_sym(symgp)%basis(2,col) = q
               col = col + 1
              end do
            end do
          end do
        end do


        allocate(Q2matrix%aa%irrep(1:numSG))
        allocate(Q2matrix%ab%irrep(1:numSG))
        allocate(Q2matrix%bb%irrep(1:numSG))

       do i=1,numSG
         rowdim = size(Q2aabasis(i)%basis,2)
         allocate(Q2matrix%aa%irrep(i)%block(1:rowdim,1:rowdim))
         Q2matrix%aa%irrep(i)%block(1:rowdim,1:rowdim) = 0.D0
       end do

      do i=1,numSG
        rowdim = size(Q2abbasis(i)%basis,2)
        allocate(Q2matrix%ab%irrep(i)%block(1:rowdim,1:rowdim))
        Q2matrix%ab%irrep(i)%block(1:rowdim,1:rowdim) = 0.D0
      end do

      do i=1,numSG
        rowdim = size(Q2bbbasis(i)%basis,2)
        allocate(Q2matrix%bb%irrep(i)%block(1:rowdim,1:rowdim))
        Q2matrix%bb%irrep(i)%block(1:rowdim,1:rowdim) = 0.D0
      end do


       do symgp=1,numSG
         numrow = size(Q2aabasis(symgp)%basis,2)
         do m=1,numrow
           p = Q2aabasis(symgp)%basis(1,m)
           q = Q2aabasis(symgp)%basis(2,m)
           symp = Q2aabasis_sym(symgp)%basis(1,m)
           symq = Q2aabasis_sym(symgp)%basis(2,m)
           do n=1,m
             s = Q2aabasis(symgp)%basis(1,n)
             r = Q2aabasis(symgp)%basis(2,n)
             syms = Q2aabasis_sym(symgp)%basis(1,n)
             symr = Q2aabasis_sym(symgp)%basis(2,n)
             if(q.eq.r.and.p.eq.s) then
               Q2matrix%aa%irrep(symgp)%block(m,n) = 1.0 + Q2matrix%aa%irrep(symgp)%block(m,n)
               if(m.ne.n) then
                 Q2matrix%aa%irrep(symgp)%block(n,m) = 1.0 + Q2matrix%aa%irrep(symgp)%block(n,m)
                end if
             end if
             if(p.eq.r.and.s.eq.q) then
               Q2matrix%aa%irrep(symgp)%block(m,n) = -1.0 + Q2matrix%aa%irrep(symgp)%block(m,n)
               if(n.ne.m) then
                 Q2matrix%aa%irrep(symgp)%block(n,m) = -1.0 + Q2matrix%aa%irrep(symgp)%block(n,m)
               end if
             end if
             if(q.eq.r.and.symp.eq.syms) then
                d1row = IbD1alpha(syms)%ib(p)
                d1col = IbD1alpha(syms)%ib(s)
                Q2matrix%aa%irrep(symgp)%block(m,n) = -1*D1alpha_cum(syms)%D1block(d1row,d1col) + Q2matrix%aa%irrep(symgp)%block(m,n)
                if(m.ne.n) then
                  Q2matrix%aa%irrep(symgp)%block(n,m) = -1*D1alpha_cum(syms)%D1block(d1row,d1col) + Q2matrix%aa%irrep(symgp)%block(n,m)
                end if
             end if
             if(p.eq.r.and.symq.eq.syms) then
               d1row = IbD1alpha(symq)%ib(q)
               d1col = IbD1alpha(symq)%ib(s)
               Q2matrix%aa%irrep(symgp)%block(m,n) = D1alpha_cum(symq)%D1block(d1row,d1col) + Q2matrix%aa%irrep(symgp)%block(m,n)
               if(m.ne.n) then
                 Q2matrix%aa%irrep(symgp)%block(n,m) = D1alpha_cum(symq)%D1block(d1row,d1col) + Q2matrix%aa%irrep(symgp)%block(n,m)
               end if
             end if
             if(s.eq.q.and.symp.eq.symr) then
               d1row = IbD1alpha(symr)%ib(p)
               d1col = IbD1alpha(symr)%ib(r)
               Q2matrix%aa%irrep(symgp)%block(m,n) = D1alpha_cum(symr)%D1block(d1row,d1col) + Q2matrix%aa%irrep(symgp)%block(m,n)
               if(m.ne.n) then
                 Q2matrix%aa%irrep(symgp)%block(n,m) = D1alpha_cum(symr)%D1block(d1row,d1col) + Q2matrix%aa%irrep(symgp)%block(n,m)
               end if
             end if
             if(p.eq.s.and.symq.eq.symr) then
               d1row = IbD1alpha(symq)%ib(q)
               d1col = IbD1alpha(symq)%ib(r)
               Q2matrix%aa%irrep(symgp)%block(m,n) = -1*D1alpha_cum(symq)%D1block(d1row,d1col) + Q2matrix%aa%irrep(symgp)%block(m,n)
               if(m.ne.n) then
                 Q2matrix%aa%irrep(symgp)%block(n,m) = -1*D1alpha_cum(symq)%D1block(d1row,d1col) + Q2matrix%aa%irrep(symgp)%block(n,m)
               end if
             end if
             d2row = IbD2aa(symgp)%ib(p,q)
             d2col = IbD2aa(symgp)%ib(s,r)
             Q2matrix%aa%irrep(symgp)%block(m,n) = D2matrix%aa%irrep(symgp)%block(d2row,d2col) + Q2matrix%aa%irrep(symgp)%block(m,n)
             if(m.ne.n) then
               Q2matrix%aa%irrep(symgp)%block(n,m) = D2matrix%aa%irrep(symgp)%block(d2row,d2col) + Q2matrix%aa%irrep(symgp)%block(n,m)
             end if
         end do
       end do
      end do

      Call FindLowestEigenvaluetypeD2(numSG,Q2matrix,1,LowestEigQ2(1))

       do symgp=1,numSG
         numrow = size(Q2bbbasis(symgp)%basis,2)
         do m=1,numrow
           p = Q2bbbasis(symgp)%basis(1,m)
           q = Q2bbbasis(symgp)%basis(2,m)
           symp = Q2bbbasis_sym(symgp)%basis(1,m)
           symq = Q2bbbasis_sym(symgp)%basis(2,m)
           do n=1,m
             s = Q2bbbasis(symgp)%basis(1,n)
             r = Q2bbbasis(symgp)%basis(2,n)
             syms = Q2bbbasis_sym(symgp)%basis(1,n)
             symr = Q2bbbasis_sym(symgp)%basis(2,n)
             if(q.eq.r.and.p.eq.s) then
               Q2matrix%bb%irrep(symgp)%block(m,n) = 1.0 + Q2matrix%bb%irrep(symgp)%block(m,n)
               if(m.ne.n) then
                 Q2matrix%bb%irrep(symgp)%block(n,m) = 1.0 + Q2matrix%bb%irrep(symgp)%block(n,m)
                end if
             end if
             if(p.eq.r.and.s.eq.q) then
               Q2matrix%bb%irrep(symgp)%block(m,n) = -1.0 + Q2matrix%bb%irrep(symgp)%block(m,n)
               if(n.ne.m) then
                 Q2matrix%bb%irrep(symgp)%block(n,m) = -1.0 + Q2matrix%bb%irrep(symgp)%block(n,m)
               end if
             end if
             if(q.eq.r.and.symp.eq.syms) then
                d1row = IbD1beta(syms)%ib(p)
                d1col = IbD1beta(syms)%ib(s)
                Q2matrix%bb%irrep(symgp)%block(m,n) = -1*D1beta_cum(syms)%D1block(d1row,d1col) + Q2matrix%bb%irrep(symgp)%block(m,n)
                if(m.ne.n) then
                  Q2matrix%bb%irrep(symgp)%block(n,m) = -1*D1beta_cum(syms)%D1block(d1row,d1col) + Q2matrix%bb%irrep(symgp)%block(n,m)
                end if
             end if
             if(p.eq.r.and.symq.eq.syms) then
               d1row = IbD1beta(symq)%ib(q)
               d1col = IbD1beta(symq)%ib(s)
               Q2matrix%bb%irrep(symgp)%block(m,n) = D1beta_cum(symq)%D1block(d1row,d1col) + Q2matrix%bb%irrep(symgp)%block(m,n)
               if(m.ne.n) then
                 Q2matrix%bb%irrep(symgp)%block(n,m) = D1beta_cum(symq)%D1block(d1row,d1col) + Q2matrix%bb%irrep(symgp)%block(n,m)
               end if
             end if
             if(s.eq.q.and.symp.eq.symr) then
               d1row = IbD1beta(symr)%ib(p)
               d1col = IbD1beta(symr)%ib(r)
               Q2matrix%bb%irrep(symgp)%block(m,n) = D1beta_cum(symr)%D1block(d1row,d1col) + Q2matrix%bb%irrep(symgp)%block(m,n)
               if(m.ne.n) then
                 Q2matrix%bb%irrep(symgp)%block(n,m) = D1beta_cum(symr)%D1block(d1row,d1col) + Q2matrix%bb%irrep(symgp)%block(n,m)
               end if
             end if
             if(p.eq.s.and.symq.eq.symr) then
               d1row = IbD1beta(symq)%ib(q)
               d1col = IbD1beta(symq)%ib(r)
               Q2matrix%bb%irrep(symgp)%block(m,n) = -1*D1beta_cum(symq)%D1block(d1row,d1col) + Q2matrix%bb%irrep(symgp)%block(m,n)
               if(m.ne.n) then
                 Q2matrix%bb%irrep(symgp)%block(n,m) = -1*D1beta_cum(symq)%D1block(d1row,d1col) + Q2matrix%bb%irrep(symgp)%block(n,m)
               end if
             end if
             d2row = IbD2bb(symgp)%ib(p,q)
             d2col = IbD2bb(symgp)%ib(s,r)
             Q2matrix%bb%irrep(symgp)%block(m,n) = D2matrix%bb%irrep(symgp)%block(d2row,d2col) + Q2matrix%bb%irrep(symgp)%block(m,n)
             if(m.ne.n) then
               Q2matrix%bb%irrep(symgp)%block(n,m) = D2matrix%bb%irrep(symgp)%block(d2row,d2col) + Q2matrix%bb%irrep(symgp)%block(n,m)
             end if
         end do
       end do
      end do

     Call FindLowestEigenvaluetypeD2(numSG,Q2matrix,2,LowestEigQ2(2))


       do symgp=1,numSG
         numrow = size(Q2abbasis(symgp)%basis,2)
         do m=1,numrow
           p = Q2abbasis(symgp)%basis(1,m)
           q = Q2abbasis(symgp)%basis(2,m)
           symp = Q2abbasis_sym(symgp)%basis(1,m)
           symq = Q2abbasis_sym(symgp)%basis(2,m)
           do n=1,m
             s = Q2abbasis(symgp)%basis(1,n)
             r = Q2abbasis(symgp)%basis(2,n)
             syms = Q2abbasis_sym(symgp)%basis(1,n)
             symr = Q2abbasis_sym(symgp)%basis(2,n)
             if(q.eq.r.and.p.eq.s) then
               Q2matrix%ab%irrep(symgp)%block(m,n) = 1.0 + Q2matrix%ab%irrep(symgp)%block(m,n)
               if(m.ne.n) then
                 Q2matrix%ab%irrep(symgp)%block(n,m) = 1.0 + Q2matrix%ab%irrep(symgp)%block(n,m)
               end if
             end if
             if(q.eq.r.and.symp.eq.syms) then
               d1row = IbD1alpha(symp)%ib(p)
               d1col = IbD1alpha(syms)%ib(s)
               Q2matrix%ab%irrep(symgp)%block(m,n) = -1*D1alpha_cum(syms)%D1block(d1row,d1col) + Q2matrix%ab%irrep(symgp)%block(m,n)
               if(n.ne.m) then
                 Q2matrix%ab%irrep(symgp)%block(n,m) = -1*D1alpha_cum(syms)%D1block(d1row,d1col) + Q2matrix%ab%irrep(symgp)%block(n,m)
               end if
             end if
             if(p.eq.s.and.symq.eq.symr) then
               d1row = IbD1beta(symq)%ib(q)
               d1col = IbD1beta(symr)%ib(r)
               Q2matrix%ab%irrep(symgp)%block(m,n) = -1*D1beta_cum(symq)%D1block(d1row,d1col) + Q2matrix%ab%irrep(symgp)%block(m,n)
               if(m.ne.n) then
                 Q2matrix%ab%irrep(symgp)%block(n,m) = -1*D1beta_cum(symq)%D1block(d1row,d1col) + Q2matrix%ab%irrep(symgp)%block(n,m)
               end if
             end if
             d2row = IbD2ab(symgp)%ib(p,q)
             d2col = IbD2ab(symgp)%ib(s,r)
             Q2matrix%ab%irrep(symgp)%block(m,n) = D2matrix%ab%irrep(symgp)%block(d2row,d2col) + Q2matrix%ab%irrep(symgp)%block(m,n)
             if(m.ne.n) then
               Q2matrix%ab%irrep(symgp)%block(n,m) = D2matrix%ab%irrep(symgp)%block(d2row,d2col) + Q2matrix%ab%irrep(symgp)%block(n,m)
             end if
           end do
         end do
       end do


      Call FindLowestEigenvaluetypeD2(numSG,Q2matrix,3,LowestEigQ2(3))


       allocate(G2abbasis(1:numSG))
       allocate(G2abbasis_sym(1:numSG))
       do symgp=1,numSG
         numrow = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
           j_begin = virt_beta(1,q)
           j_end   = virt_beta(2,q)
           numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
           i_begin = virt_alpha(1,p)
           i_end   = virt_alpha(2,p)
           numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
         end do
         allocate(G2abbasis(symgp)%basis(1:2,1:numrow))
         G2abbasis(symgp)%basis(1:2,1:numrow) = 0
         allocate(G2abbasis_sym(symgp)%basis(1:2,1:numrow))
         G2abbasis_sym(symgp)%basis(1:2,1:numrow) = 0
      end do


       do symgp=1,numSG
         row = 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               G2abbasis(symgp)%basis(1,row) = i
               G2abbasis(symgp)%basis(2,row) = j
               G2abbasis_sym(symgp)%basis(1,row) = p
               G2abbasis_sym(symgp)%basis(2,row) = q
               row = row + 1
             end do
           end do
           i_begin = occ_alpha(1,p)
           i_end   = occ_alpha(2,p)
           j_begin = virt_beta(1,q)
           j_end   = virt_beta(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               G2abbasis(symgp)%basis(1,row) = i
               G2abbasis(symgp)%basis(2,row) = j
               G2abbasis_sym(symgp)%basis(1,row) = p
               G2abbasis_sym(symgp)%basis(2,row) = q
               row = row + 1
             end do
           end do
           i_begin = virt_alpha(1,p)
           i_end   = virt_alpha(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do i=i_begin,i_end
             do j=j_begin, j_end
               G2abbasis(symgp)%basis(1,row) = i
               G2abbasis(symgp)%basis(2,row) = j
               G2abbasis_sym(symgp)%basis(1,row) = p
               G2abbasis_sym(symgp)%basis(2,row) = q
               row = row + 1
             end do
           end do
           i_begin = virt_alpha(1,p)
           i_end   = virt_alpha(2,p)
           j_begin = virt_beta(1,q)
           j_end   = virt_beta(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               G2abbasis(symgp)%basis(1,row) = i
               G2abbasis(symgp)%basis(2,row) = j
               G2abbasis_sym(symgp)%basis(1,row) = p
               G2abbasis_sym(symgp)%basis(2,row) = q
               row = row + 1
             end do
           end do
         end do
      end do

      do symgp=1,numSG
        sizeG2block = size(G2abbasis(symgp)%basis,2)
        allocate(G2abmatrix(symgp)%D1block(1:sizeG2block,1:sizeG2block))
        G2abmatrix(symgp)%D1block(1:sizeG2block,1:sizeG2block) = 0.D0
        allocate(G2bamatrix(symgp)%D1block(1:sizeG2block,1:sizeG2block))
        G2bamatrix(symgp)%D1block(1:sizeG2block,1:sizeG2block) = 0.D0
      end do

      do symgp=1,numSG
        do m=1,size(G2abbasis(symgp)%basis,2)
          i = G2abbasis(symgp)%basis(1,m)
          j = G2abbasis(symgp)%basis(2,m)
          symi = G2abbasis_sym(symgp)%basis(1,m)
          symj = G2abbasis_sym(symgp)%basis(2,m)
          do n=1,m
            k = G2abbasis(symgp)%basis(1,n)
            l = G2abbasis(symgp)%basis(2,n)
            symk = G2abbasis_sym(symgp)%basis(1,n)
            syml = G2abbasis_sym(symgp)%basis(2,n)
            if(j.eq.l.and.symi.eq.symk) then
              d1row = IbD1alpha(symi)%ib(i)
              d1col = IbD1alpha(symk)%ib(k)
              G2abmatrix(symgp)%D1block(m,n) = D1alpha_cum(symi)%D1block(d1row,d1col) + G2abmatrix(symgp)%D1block(m,n)
              if(m.ne.n) then
                G2abmatrix(symgp)%D1block(n,m) = D1alpha_cum(symi)%D1block(d1row,d1col) + G2abmatrix(symgp)%D1block(n,m)
              end if
            end if
            sym1 = ProductTable(symk,symj)
            sym2 = ProductTable(symi,syml)
            if(sym1.eq.sym2) then
              d2row = IbD2ab(sym1)%ib(i,l)
              d2col = IbD2ab(sym2)%ib(k,j)
              G2abmatrix(symgp)%D1block(m,n) = -1*D2matrix%ab%irrep(sym1)%block(d2row,d2col) + G2abmatrix(symgp)%D1block(m,n)
              if(m.ne.n) then
                G2abmatrix(symgp)%D1block(n,m) = -1*D2matrix%ab%irrep(sym1)%block(d2row,d2col) + G2abmatrix(symgp)%D1block(n,m)
              end if
            end if
          end do
        end do
      end do
       Call FindLowestEigenvaluetypeD1(numSG,G2abmatrix,LowestEigG2(1))


      do symgp=1,numSG
        do m=1,size(G2abbasis(symgp)%basis,2)
          j = G2abbasis(symgp)%basis(1,m)
          i = G2abbasis(symgp)%basis(2,m)
          symj = G2abbasis_sym(symgp)%basis(1,m)
          symi = G2abbasis_sym(symgp)%basis(2,m)
          do n=1,m
            l = G2abbasis(symgp)%basis(1,n)
            k = G2abbasis(symgp)%basis(2,n)
            syml = G2abbasis_sym(symgp)%basis(1,n)
            symk = G2abbasis_sym(symgp)%basis(2,n)
            if(j.eq.l.and.symi.eq.symk) then
              d1row = IbD1beta(symi)%ib(i)
              d1col = IbD1beta(symk)%ib(k)
              G2bamatrix(symgp)%D1block(m,n) = D1beta_cum(symi)%D1block(d1row,d1col) + G2bamatrix(symgp)%D1block(m,n)
              if(m.ne.n) then
                G2bamatrix(symgp)%D1block(n,m) = D1beta_cum(symi)%D1block(d1row,d1col) + G2bamatrix(symgp)%D1block(n,m)
              end if
            end if
            sym1 = ProductTable(symk,symj)
            sym2 = ProductTable(symi,syml)
            if(sym1.eq.sym2) then
              d2row = IbD2ab(sym1)%ib(j,k)
              d2col = IbD2ab(sym2)%ib(l,i)
              G2bamatrix(symgp)%D1block(m,n) = -1*D2matrix%ab%irrep(sym1)%block(d2row,d2col) + G2bamatrix(symgp)%D1block(m,n)
              if(m.ne.n) then
                G2bamatrix(symgp)%D1block(n,m) = -1*D2matrix%ab%irrep(sym1)%block(d2row,d2col) + G2bamatrix(symgp)%D1block(n,m)
              end if
            end if
          end do
        end do
      end do
       Call FindLowestEigenvaluetypeD1(numSG,G2bamatrix,LowestEigG2(2))

      allocate(G2aabasis(1:numSG))
      allocate(G2bbbasis(1:numSG))
      allocate(G2aabasis_sym(1:numSG))
      allocate(G2bbbasis_sym(1:numSG))
      do symgp=1,numSG
        numrow = 0
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          i_begin = occ_alpha(1,p)
          i_end   = occ_alpha(2,p)
          j_begin = occ_alpha(1,q)
          j_end   = occ_alpha(2,q)
          numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
          i_begin = occ_alpha(1,p)
          i_end   = occ_alpha(2,p)
          j_begin = virt_alpha(1,q)
          j_end   = virt_alpha(2,q)
          numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
          i_begin = virt_alpha(1,p)
          i_end   = virt_alpha(2,p)
          j_begin = occ_alpha(1,q)
          j_end   = occ_alpha(2,q)
          numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
          i_begin = virt_alpha(1,p)
          i_end   = virt_alpha(2,p)
          j_begin = virt_alpha(1,q)
          j_end   = virt_alpha(2,q)
          numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
        end do
          allocate(G2aabasis(symgp)%basis(1:2,1:numrow))
          G2aabasis(symgp)%basis(1:2,1:numrow) = 0
          allocate(G2aabasis_sym(symgp)%basis(1:2,1:numrow))
          G2aabasis_sym(symgp)%basis(1:2,1:numrow) = 0
      end do

      do symgp=1,numSG
        numrow = 0
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          i_begin = occ_beta(1,p)
          i_end   = occ_beta(2,p)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
          i_begin = occ_beta(1,p)
          i_end   = occ_beta(2,p)
          j_begin = virt_beta(1,q)
          j_end   = virt_beta(2,q)
          numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
          i_begin = virt_beta(1,p)
          i_end   = virt_beta(2,p)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
          i_begin = virt_beta(1,p)
          i_end   = virt_beta(2,p)
          j_begin = virt_beta(1,q)
          j_end   = virt_beta(2,q)
          numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
        end do
          allocate(G2bbbasis(symgp)%basis(1:2,1:numrow))
          G2bbbasis(symgp)%basis(1:2,1:numrow) = 0
          allocate(G2bbbasis_sym(symgp)%basis(1:2,1:numrow))
          G2bbbasis_sym(symgp)%basis(1:2,1:numrow) = 0
      end do

      do symgp=1,numSG
        row = 1
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          i_begin = occ_alpha(1,p)
          i_end   = occ_alpha(2,p)
          j_begin = occ_alpha(1,q)
          j_end   = occ_alpha(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              G2aabasis(symgp)%basis(1,row) = i
              G2aabasis(symgp)%basis(2,row) = j
              G2aabasis_sym(symgp)%basis(1,row) = p
              G2aabasis_sym(symgp)%basis(2,row) = q
              row = row + 1
            end do
          end do
          i_begin = occ_alpha(1,p)
          i_end   = occ_alpha(2,p)
          j_begin = virt_alpha(1,q)
          j_end   = virt_alpha(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              G2aabasis(symgp)%basis(1,row) = i
              G2aabasis(symgp)%basis(2,row) = j
              G2aabasis_sym(symgp)%basis(1,row) = p
              G2aabasis_sym(symgp)%basis(2,row) = q
              row = row + 1
            end do
          end do
          i_begin = virt_alpha(1,p)
          i_end   = virt_alpha(2,p)
          j_begin = occ_alpha(1,q)
          j_end   = occ_alpha(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              G2aabasis(symgp)%basis(1,row) = i
              G2aabasis(symgp)%basis(2,row) = j
              G2aabasis_sym(symgp)%basis(1,row) = p
              G2aabasis_sym(symgp)%basis(2,row) = q
              row = row + 1
            end do
          end do
          i_begin = virt_alpha(1,p)
          i_end   = virt_alpha(2,p)
          j_begin = virt_alpha(1,q)
          j_end   = virt_alpha(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              G2aabasis(symgp)%basis(1,row) = i
              G2aabasis(symgp)%basis(2,row) = j
              G2aabasis_sym(symgp)%basis(1,row) = p
              G2aabasis_sym(symgp)%basis(2,row) = q
              row = row + 1
            end do
          end do
        end do
      end do


      do symgp=1,numSG
        row = 1
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          i_begin = occ_beta(1,p)
          i_end   = occ_beta(2,p)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              G2bbbasis(symgp)%basis(1,row) = i
              G2bbbasis(symgp)%basis(2,row) = j
              G2bbbasis_sym(symgp)%basis(1,row) = p
              G2bbbasis_sym(symgp)%basis(2,row) = q
              row = row + 1
            end do
          end do
          i_begin = occ_beta(1,p)
          i_end   = occ_beta(2,p)
          j_begin = virt_beta(1,q)
          j_end   = virt_beta(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              G2bbbasis(symgp)%basis(1,row) = i
              G2bbbasis(symgp)%basis(2,row) = j
              G2bbbasis_sym(symgp)%basis(1,row) = p
              G2bbbasis_sym(symgp)%basis(2,row) = q
              row = row + 1
            end do
          end do
          i_begin = virt_beta(1,p)
          i_end   = virt_beta(2,p)
          j_begin = occ_beta(1,q)
          j_end   = occ_beta(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              G2bbbasis(symgp)%basis(1,row) = i
              G2bbbasis(symgp)%basis(2,row) = j
              G2bbbasis_sym(symgp)%basis(1,row) = p
              G2bbbasis_sym(symgp)%basis(2,row) = q
              row = row + 1
            end do
          end do
          i_begin = virt_beta(1,p)
          i_end   = virt_beta(2,p)
          j_begin = virt_beta(1,q)
          j_end   = virt_beta(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              G2bbbasis(symgp)%basis(1,row) = i
              G2bbbasis(symgp)%basis(2,row) = j
              G2bbbasis_sym(symgp)%basis(1,row) = p
              G2bbbasis_sym(symgp)%basis(2,row) = q
              row = row + 1
            end do
          end do
        end do
      end do


      do symgp=1,numSG
        numrow = size(G2aabasis(symgp)%basis,2) + size(G2bbbasis(symgp)%basis,2)
        allocate(G2aabbmatrix(symgp)%D1block(1:numrow,1:numrow))
        G2aabbmatrix(symgp)%D1block(1:numrow,1:numrow) = 0.D0
      end do

      do symgp=1,numSG
        do m=1,size(G2aabasis(symgp)%basis,2)
          i = G2aabasis(symgp)%basis(1,m)
          j = G2aabasis(symgp)%basis(2,m)
          symi = G2aabasis_sym(symgp)%basis(1,m)
          symj = G2aabasis_sym(symgp)%basis(2,m)
          do n=1,m
            k = G2aabasis(symgp)%basis(1,n)
            l = G2aabasis(symgp)%basis(2,n)
            symk = G2aabasis_sym(symgp)%basis(1,n)
            syml = G2aabasis_sym(symgp)%basis(2,n)
            if(j.eq.l.and.symi.eq.symk) then
              d1row = IbD1alpha(symi)%ib(i)
              d1col = IbD1alpha(symk)%ib(k)
              G2aabbmatrix(symgp)%D1block(m,n) = D1alpha_cum(symk)%D1block(d1row,d1col) + G2aabbmatrix(symgp)%D1block(m,n)
              if(m.ne.n) then
                G2aabbmatrix(symgp)%D1block(n,m) = D1alpha_cum(symk)%D1block(d1row,d1col) + G2aabbmatrix(symgp)%D1block(n,m)
              end if
           end if
           sym1 = ProductTable(symk,symj)
           sym2 = ProductTable(symi,syml)
           if(sym1.eq.sym2.and.k.ne.j.and.i.ne.l) then
             elemsign = 1
             if(k.gt.j) then
               elemsign = -1*elemsign
             end if
             if(i.gt.l) then
               elemsign = -1*elemsign
             end if
             d2row = IbD2aa(sym1)%ib(k,j)
             d2col = IbD2aa(sym2)%ib(i,l)
             G2aabbmatrix(symgp)%D1block(m,n) = -1*elemsign*D2matrix%aa%irrep(sym1)%block(d2row,d2col) + G2aabbmatrix(symgp)%D1block(m,n)
             if(m.ne.n) then
               G2aabbmatrix(symgp)%D1block(n,m) = G2aabbmatrix(symgp)%D1block(m,n)
             end if
           end if
        end do
      end do
    end do




      do symgp=1,numSG
        offset = size(G2aabasis(symgp)%basis,2)
        do m=1,size(G2bbbasis(symgp)%basis,2)
          i = G2bbbasis(symgp)%basis(1,m)
          j = G2bbbasis(symgp)%basis(2,m)
          symi = G2bbbasis_sym(symgp)%basis(1,m)
          symj = G2bbbasis_sym(symgp)%basis(2,m)
          do n=1,m
            k = G2bbbasis(symgp)%basis(1,n)
            l = G2bbbasis(symgp)%basis(2,n)
            symk = G2bbbasis_sym(symgp)%basis(1,n)
            syml = G2bbbasis_sym(symgp)%basis(2,n)
            if(l.eq.j.and.symk.eq.symi) then
              d1row = IbD1beta(symk)%ib(k)
              d1col = IbD1beta(symi)%ib(i)
              G2aabbmatrix(symgp)%D1block(m+offset,n+offset) = D1beta_cum(symk)%D1block(d1row,d1col) + G2aabbmatrix(symgp)%D1block(m+offset,n+offset)
              if(n.ne.m) then
                G2aabbmatrix(symgp)%D1block(n+offset,m+offset) = D1beta_cum(symk)%D1block(d1row,d1col) + G2aabbmatrix(symgp)%D1block(n+offset,m+offset)
              end if
            end if
            sym1 = ProductTable(symk,symj)
            sym2 = ProductTable(symi,syml)
            if(sym1.eq.sym2.and.k.ne.j.and.i.ne.l) then
              d2row = IbD2bb(sym1)%ib(k,j)
              d2col = IbD2bb(sym2)%ib(i,l)
              elemsign = 1
              if(k.gt.j) then
                elemsign = -1*elemsign
              end if
              if(i.gt.l) then
                elemsign = -1*elemsign
              end if
              G2aabbmatrix(symgp)%D1block(m+offset,n+offset) = -1*elemsign*D2matrix%bb%irrep(sym1)%block(d2row,d2col) + G2aabbmatrix(symgp)%D1block(m+offset,n+offset)
              if(m.ne.n) then
                G2aabbmatrix(symgp)%D1block(n+offset,m+offset) = G2aabbmatrix(symgp)%D1block(m+offset,n+offset)
              end if
            end if
          end do
        end do
      end do


      do symgp=1,numSG
        offset = size(G2aabasis(symgp)%basis,2)
        do m=1,size(G2aabasis(symgp)%basis,2)
          i = G2aabasis(symgp)%basis(1,m)
          j = G2aabasis(symgp)%basis(2,m)
          symi = G2aabasis_sym(symgp)%basis(1,m)
          symj = G2aabasis_sym(symgp)%basis(2,m)
          do n=1,size(G2bbbasis(symgp)%basis,2)
            k = G2bbbasis(symgp)%basis(1,n)
            l = G2bbbasis(symgp)%basis(2,n)
            symk = G2bbbasis_sym(symgp)%basis(1,n)
            syml = G2bbbasis_sym(symgp)%basis(2,n)
            sym1 = ProductTable(symj,symk)
            sym2 = ProductTable(symi,syml)
            if(sym1.eq.sym2) then
              d2row = IbD2ab(sym1)%ib(j,k)
              d2col = IbD2ab(sym2)%ib(i,l)
              G2aabbmatrix(symgp)%D1block(m,n+offset) = D2matrix%ab%irrep(sym1)%block(d2row,d2col) + G2aabbmatrix(symgp)%D1block(m,n+offset)
              G2aabbmatrix(symgp)%D1block(n+offset,m) = D2matrix%ab%irrep(sym2)%block(d2row,d2col) + G2aabbmatrix(symgp)%D1block(n+offset,m)
            end if
          end do
        end do
      end do

       Call FindLowestEigenvaluetypeD1(numSG,G2aabbmatrix,LowestEigG2(3))
      write(*,*) 'Lowest Eigenvalues of the D2, Q2 and G2 matrices:'
      write(*,*) 'D2: '
      write(*,*) '   (aa):', LowestEigD2(1)
      write(*,*) '   (bb):', LowestEigD2(2)
      write(*,*) '   (ab):', LowestEigD2(3)
      write(*,*) 'Q2: '
      write(*,*) '   (aa):', LowestEigQ2(1)
      write(*,*) '   (bb):', LowestEigQ2(2)
      write(*,*) '   (ab):', LowestEigQ2(3)
      write(*,*) 'G2: '
      write(*,*) '   (ab):  ', LowestEigG2(1)
      write(*,*) '   (ba):  ', LowestEigG2(2)
      write(*,*) '   (aabb):', LowestEigG2(3)

       end subroutine BuildQ2G2OS

!> @brief Diagonalizes the two body matrices
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine  FindLowestEigenvaluetypeD2(numSG,Matrix,spinflag,lowesteig)

       Use InterfaceMod
       Use TypeMod
       Implicit NONE

       integer :: numSG
       type(D2) :: Matrix
       integer :: spinflag

       double precision, allocatable, dimension(:) :: UpperDiag
       double precision, allocatable, dimension(:) :: EigVal
       double precision, allocatable, dimension(:,:) :: EigVec
       double precision, allocatable, dimension(:) :: WORK
       integer, allocatable, dimension(:) :: IWORK
       double precision :: lowesteig
       integer :: matrixdim , INFO,p,q,symgp, counter


       if(spinflag.eq.1) then
       do symgp=1,numSG
         matrixdim = size(Matrix%aa%irrep(symgp)%block,1)
         allocate(EigVal(1:matrixdim))
         EigVal(1:matrixdim) = 0.D0
         allocate(UpperDiag(1:matrixdim*(matrixdim+1)/2))
         UpperDiag(1:matrixdim*(matrixdim+1)/2) = 0.D0
         allocate(WORK(1:3*matrixdim))
         WORK(1:3*matrixdim) = 0.D0
         allocate(IWORK(1:1))
         IWORK(1:1) = 0
          allocate(EigVec(1:1,1:1))
         counter = 1
         do p=1,matrixdim
           do q=1,p
             UpperDiag(counter) = Matrix%aa%irrep(symgp)%block(q,p)
             counter = counter + 1
           end do
         end do
         Call DSPEVD('N','U',matrixdim,UpperDiag,EigVal,EigVec,matrixdim,WORK,3*matrixdim,IWORK,1,INFO)
         if(symgp.eq.1) then
           lowesteig = EigVal(1)
         end if
         do p=1,matrixdim
           if(EigVal(p).lt.lowesteig) then
             lowesteig = EigVal(p)
           end if
         end do
         deallocate(UpperDiag,EigVal,WORK,EigVec,IWORK)
       end do
      end if


      if(spinflag.eq.2) then
       do symgp=1,numSG
         matrixdim = size(Matrix%bb%irrep(symgp)%block,1)
         allocate(EigVal(1:matrixdim))
         EigVal(1:matrixdim) = 0.D0
         allocate(UpperDiag(1:matrixdim*(matrixdim+1)/2))
         UpperDiag(1:matrixdim*(matrixdim+1)/2) = 0.D0
         allocate(WORK(1:3*matrixdim))
         WORK(1:3*matrixdim) = 0.D0
         allocate(IWORK(1:1))
         IWORK(1:1) = 0
         allocate(EigVec(1:1,1:1))
         counter = 1
         do p=1,matrixdim
           do q=1,p
             UpperDiag(counter) = Matrix%bb%irrep(symgp)%block(q,p)
             counter = counter + 1
           end do
         end do
         Call DSPEVD('N','U',matrixdim,UpperDiag,EigVal,EigVec,matrixdim,WORK,3*matrixdim,IWORK,1,INFO)
         if(symgp.eq.1) then
           lowesteig = EigVal(1)
         end if
         do p=1,matrixdim
           if(EigVal(p).lt.lowesteig) then
             lowesteig = EigVal(p)
           end if
         end do
         deallocate(UpperDiag,EigVal,WORK,EigVec,IWORK)
       end do
      end if


     if(spinflag.eq.3) then
       do symgp=1,numSG
         matrixdim = size(Matrix%ab%irrep(symgp)%block,1)
         allocate(EigVal(1:matrixdim))
         EigVal(1:matrixdim) = 0.D0
         allocate(UpperDiag(1:matrixdim*(matrixdim+1)/2))
         UpperDiag(1:matrixdim*(matrixdim+1)/2) = 0.D0
         allocate(WORK(1:3*matrixdim))
         WORK(1:3*matrixdim) = 0.D0
         allocate(IWORK(1:1))
         IWORK(1:1) = 0
         allocate(EigVec(1:1,1:1))
         counter = 1
         do p=1,matrixdim
           do q=1,p
             UpperDiag(counter) = Matrix%ab%irrep(symgp)%block(q,p)
             counter = counter + 1
           end do
         end do
         Call DSPEVD('N','U',matrixdim,UpperDiag,EigVal,EigVec,matrixdim,WORK,3*matrixdim,IWORK,1,INFO)
         if(symgp.eq.1) then
           lowesteig = EigVal(1)
         end if
         do p=1,matrixdim
           if(EigVal(p).lt.lowesteig) then
             lowesteig = EigVal(p)
           end if
         end do
         deallocate(UpperDiag,EigVal,WORK,EigVec,IWORK)
       end do
      end if


      end subroutine FindLowestEigenvaluetypeD2

!> @brief Diagonalizes the one body matrices
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine  FindLowestEigenvaluetypeD1(numSG,Matrix,lowesteig)

       Use InterfaceMod
       Use TypeMod
       Implicit NONE

       integer :: numSG
       type(D1) :: Matrix

       double precision, allocatable, dimension(:) :: UpperDiag
       double precision, allocatable, dimension(:) :: EigVal
       double precision, allocatable, dimension(:,:) :: EigVec
       double precision, allocatable, dimension(:) :: WORK
       integer, allocatable, dimension(:) :: IWORK
       double precision :: lowesteig
       integer :: matrixdim , INFO,p,q,symgp, counter


       do symgp=1,numSG
         matrixdim = size(Matrix%D1block,1)
         allocate(EigVal(1:matrixdim))
         EigVal(1:matrixdim) = 0.D0
         allocate(UpperDiag(1:matrixdim*(matrixdim+1)/2))
         UpperDiag(1:matrixdim*(matrixdim+1)/2) = 0.D0
         allocate(WORK(1:3*matrixdim))
         allocate(IWORK(1:1))
         IWORK(1:1) = 0
         WORK(1:3*matrixdim) = 0.D0
          allocate(EigVec(1:1,1:1))
         counter = 1
         do p=1,matrixdim
           do q=1,p
             UpperDiag(counter) = Matrix%D1block(q,p)
             counter = counter + 1
           end do
         end do
         Call DSPEVD('N','U',matrixdim,UpperDiag,EigVal,EigVec,matrixdim,WORK,3*matrixdim,IWORK,1,INFO)
         if(symgp.eq.1) then
           lowesteig = EigVal(1)
         end if
         do p=1,matrixdim
           if(EigVal(p).lt.lowesteig) then
             lowesteig = EigVal(p)
           end if
         end do
         deallocate(UpperDiag,EigVal,WORK,EigVec,IWORK)
       end do


      end subroutine FindLowestEigenvaluetypeD1

!> @brief Builds the Q2 and G2 matrices for closed shell species
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine BuildQ2G2CS(D2matrix,D1cum,IbD2aa,IbD2ab,occ,virt,InvPdt,ProductTable,numSG,ReshapedMatrixDim,filename)

       Use InterfaceMod
       Use TypeMod
       Implicit NONE
       integer :: numSG
       type(D2) :: D2matrix
       type(D1) :: D1cum(1:numSG)
       type(InverseBasis2), allocatable, dimension(:) :: IbD2aa,IbD2ab
       integer, intent(IN), dimension(1:2,1:numSG) :: occ,virt
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:numSG)
       integer, dimension(1:numSG,1:numSG) :: ProductTable
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       character(len=35) :: filename



       integer :: p,q,i,i_begin,i_end
       type(BasisMap2), allocatable, dimension(:) :: Q2aabasis,Q2abbasis
       type(BasisMap2), allocatable, dimension(:) :: Q2aabasis_sym, Q2bbbasis_sym,Q2abbasis_sym
       type(BasisMap2), allocatable, dimension(:) :: G2aabasis,G2bbbasis,G2abbasis
       type(BasisMap2), allocatable, dimension(:) :: G2aabasis_sym, G2bbbasis_sym,G2abbasis_sym
       integer, allocatable, dimension(:) :: coloffset
       type(D2) :: Q2matrix
       type(InverseBasis1), allocatable, dimension(:) :: IbD1
       type(D1) :: G2abmatrix(1:numSG), G2bamatrix(1:numSG), G2aabbmatrix(1:numSG)
       integer :: symgp,t,a,a_begin,a_end,b,b_begin,b_end,j,j_begin,j_end,s,r
       integer :: symi,symj,symk,syml,symp,symq,symr,syms,m,n,d2row,d2col,d1col,d1row,col,numrow,row,rowdim
       integer :: sizeG2block, symkl,symkj,k,l,symik,offset,symjl,symki,symil
       character(len=100) :: Q2outputfile, G2outputfile
       double precision :: elemsign = 1.0
       integer :: sym1,sym2, numorbitals
       double precision :: collecttrace
       double precision, dimension(:) :: LowestEigD2(1:2), LowestEigQ2(1:2),LowestEigG2(1:2)
       double precision :: lowesteig


       Call FindLowestEigenvaluetypeD2(numSG,D2matrix,1,LowestEigD2(1))
       Call FindLowestEigenvaluetypeD2(numSG,D2matrix,3,LowestEigD2(2))


       allocate(IbD1(1:numSG))

       numorbitals = 0
       do p=1,numSG
         i_begin = occ(1,p)
         i_end   = occ(2,p)
         a_begin = virt(1,p)
         a_end   = virt(2,p)
         numorbitals = numorbitals + (i_end - i_begin + 1) + (a_end - a_begin + 1)
       end do

       do p=1,numSG
         allocate(IbD1(p)%ib(1:numorbitals))
         IbD1(p)%ib(1:numorbitals) = 0
       end do

       do p=1,numSG
         i_begin = occ(1,p)
         i_end   = occ(2,p)
         a_begin = virt(1,p)
         a_end   = virt(2,p)
         do i=i_begin,i_end
           d1row = i - i_begin + 1
           IbD1(p)%ib(i) = d1row
         end do
         do a=a_begin,a_end
           d1row = a - a_begin + 1 + i_end - i_begin + 1
           IbD1(p)%ib(a) = d1row
         end do
       end do

       do p=1,numSG
         i_begin = occ(1,p)
         i_end   = occ(2,p)
         do i=i_begin,i_end
           D1row = i - i_begin + 1
           D1cum(p)%D1block(D1row,D1row) = 1.0 + D1cum(p)%D1block(D1row,D1row)
         end do
       end do

       allocate(coloffset(1:numSG))
       coloffset(1:numSG) = 0
       allocate(Q2aabasis(1:numSG))
       allocate(Q2aabasis_sym(1:numSG))

       do symgp=1,numSG
         col = 1
         numrow = ReshapedMatrixDim%ijaa(symgp)%row + ReshapedMatrixDim%ajaa(symgp)%col + ReshapedMatrixDim%ijaa(symgp)%col
         allocate(Q2aabasis(symgp)%basis(1:2,1:numrow))
         Q2aabasis(symgp)%basis(1:2,1:numrow) = 0
         allocate(Q2aabasis_sym(symgp)%basis(1:2,1:numrow))
         Q2aabasis_sym(symgp)%basis(1:2,1:numrow) = 0
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           if(p.gt.q) then
             cycle
           end if
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=max(i+1,j_begin),j_end
               Q2aabasis(symgp)%basis(1,col) = i
               Q2aabasis(symgp)%basis(2,col) = j
               Q2aabasis_sym(symgp)%basis(1,col) = p
               Q2aabasis_sym(symgp)%basis(2,col) = q
               coloffset(symgp) = col
               col = col + 1
             end do
          end do
        end do
      end do

       do symgp=1,numSG
         col = coloffset(symgp) + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           i_begin = occ(1,q)
           i_end   = occ(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               Q2aabasis(symgp)%basis(1,col) = i
               Q2aabasis(symgp)%basis(2,col) = a
               Q2aabasis_sym(symgp)%basis(1,col) = q
               Q2aabasis_sym(symgp)%basis(2,col) = p
               coloffset(symgp) = col
               col = col + 1
             end do
           end do
         end do
       end do

      do symgp=1,numSG
        col = coloffset(symgp) + 1
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          if(p.gt.q) then
            cycle
          end if
          a_begin = virt(1,p)
          a_end   = virt(2,p)
          b_begin = virt(1,q)
          b_end   = virt(2,q)
          do a=a_begin,a_end
            do b=max(a+1,b_begin),b_end
              Q2aabasis(symgp)%basis(1,col) = a
              Q2aabasis(symgp)%basis(2,col) = b
              Q2aabasis_sym(symgp)%basis(1,col) = p
              Q2aabasis_sym(symgp)%basis(2,col) = q
              col = col + 1
             end do
           end do
         end do
       end do

        coloffset(1:numSG) = 0
        allocate(Q2abbasis(1:numSG))
        allocate(Q2abbasis_sym(1:numSG))
        do symgp=1,numSG
         col = 1
         numrow = ReshapedMatrixDim%ijab(symgp)%row + ReshapedMatrixDim%ijab(symgp)%col + ReshapedMatrixDim%ajab(symgp)%col + ReshapedMatrixDim%ajba(symgp)%col
         allocate(Q2abbasis(symgp)%basis(1:2,1:numrow))
         allocate(Q2abbasis_sym(symgp)%basis(1:2,1:numrow))
         Q2abbasis(symgp)%basis(1:2,1:numrow) = 0
         Q2abbasis_sym(symgp)%basis(1:2,1:numrow) = 0
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               Q2abbasis(symgp)%basis(1,col) = i
               Q2abbasis(symgp)%basis(2,col) = j
               Q2abbasis_sym(symgp)%basis(1,col) = p
               Q2abbasis_sym(symgp)%basis(2,col) = q
               coloffset(symgp) = col
               col = col + 1
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         col = coloffset(symgp) + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           i_begin = occ(1,q)
           i_end   = occ(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               Q2abbasis(symgp)%basis(1,col) = i
               Q2abbasis(symgp)%basis(2,col) = a
               Q2abbasis_sym(symgp)%basis(1,col) = q
               Q2abbasis_sym(symgp)%basis(2,col) = p
               coloffset(symgp) = col
               col = col + 1
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         col = coloffset(symgp) + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           i_begin = occ(1,q)
           i_end   = occ(2,q)
           do i=i_begin,i_end
             do a=a_begin,a_end
               Q2abbasis(symgp)%basis(1,col) = a
               Q2abbasis(symgp)%basis(2,col) = i
               Q2abbasis_sym(symgp)%basis(1,col) = p
               Q2abbasis_sym(symgp)%basis(2,col) = q
               coloffset(symgp) = col
               col = col + 1
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         col = coloffset(symgp) + 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt(1,p)
           a_end   = virt(2,p)
           b_begin = virt(1,q)
           b_end   = virt(2,q)
           do a=a_begin,a_end
             do b=b_begin,b_end
               Q2abbasis(symgp)%basis(1,col) = a
               Q2abbasis(symgp)%basis(2,col) = b
               Q2abbasis_sym(symgp)%basis(1,col) = p
               Q2abbasis_sym(symgp)%basis(2,col) = q
               col = col + 1
              end do
            end do
          end do
        end do


        allocate(Q2matrix%aa%irrep(1:numSG))
        allocate(Q2matrix%ab%irrep(1:numSG))

       do i=1,numSG
         rowdim = size(Q2aabasis(i)%basis,2)
         allocate(Q2matrix%aa%irrep(i)%block(1:rowdim,1:rowdim))
         Q2matrix%aa%irrep(i)%block(1:rowdim,1:rowdim) = 0.D0
       end do

      do i=1,numSG
        rowdim = size(Q2abbasis(i)%basis,2)
        allocate(Q2matrix%ab%irrep(i)%block(1:rowdim,1:rowdim))
        Q2matrix%ab%irrep(i)%block(1:rowdim,1:rowdim) = 0.D0
      end do

       do symgp=1,numSG
         numrow = size(Q2aabasis(symgp)%basis,2)
         do m=1,numrow
           p = Q2aabasis(symgp)%basis(1,m)
           q = Q2aabasis(symgp)%basis(2,m)
           symp = Q2aabasis_sym(symgp)%basis(1,m)
           symq = Q2aabasis_sym(symgp)%basis(2,m)
           do n=1,m
             s = Q2aabasis(symgp)%basis(1,n)
             r = Q2aabasis(symgp)%basis(2,n)
             syms = Q2aabasis_sym(symgp)%basis(1,n)
             symr = Q2aabasis_sym(symgp)%basis(2,n)
             if(q.eq.r.and.p.eq.s) then
               Q2matrix%aa%irrep(symgp)%block(m,n) = 1.0 + Q2matrix%aa%irrep(symgp)%block(m,n)
               if(m.ne.n) then
                 Q2matrix%aa%irrep(symgp)%block(n,m) = 1.0 + Q2matrix%aa%irrep(symgp)%block(n,m)
                end if
             end if
             if(p.eq.r.and.s.eq.q) then
               Q2matrix%aa%irrep(symgp)%block(m,n) = -1.0 + Q2matrix%aa%irrep(symgp)%block(m,n)
               if(n.ne.m) then
                 Q2matrix%aa%irrep(symgp)%block(n,m) = -1.0 + Q2matrix%aa%irrep(symgp)%block(n,m)
               end if
             end if
             if(q.eq.r.and.symp.eq.syms) then
                d1row = IbD1(syms)%ib(p)
                d1col = IbD1(syms)%ib(s)
                Q2matrix%aa%irrep(symgp)%block(m,n) = -1*D1cum(syms)%D1block(d1row,d1col) + Q2matrix%aa%irrep(symgp)%block(m,n)
                if(m.ne.n) then
                  Q2matrix%aa%irrep(symgp)%block(n,m) = -1*D1cum(syms)%D1block(d1row,d1col) + Q2matrix%aa%irrep(symgp)%block(n,m)
                end if
             end if
             if(p.eq.r.and.symq.eq.syms) then
               d1row = IbD1(symq)%ib(q)
               d1col = IbD1(symq)%ib(s)
               Q2matrix%aa%irrep(symgp)%block(m,n) = D1cum(symq)%D1block(d1row,d1col) + Q2matrix%aa%irrep(symgp)%block(m,n)
               if(m.ne.n) then
                 Q2matrix%aa%irrep(symgp)%block(n,m) = D1cum(symq)%D1block(d1row,d1col) + Q2matrix%aa%irrep(symgp)%block(n,m)
               end if
             end if
             if(s.eq.q.and.symp.eq.symr) then
               d1row = IbD1(symr)%ib(p)
               d1col = IbD1(symr)%ib(r)
               Q2matrix%aa%irrep(symgp)%block(m,n) = D1cum(symr)%D1block(d1row,d1col) + Q2matrix%aa%irrep(symgp)%block(m,n)
               if(m.ne.n) then
                 Q2matrix%aa%irrep(symgp)%block(n,m) = D1cum(symr)%D1block(d1row,d1col) + Q2matrix%aa%irrep(symgp)%block(n,m)
               end if
             end if
             if(p.eq.s.and.symq.eq.symr) then
               d1row = IbD1(symq)%ib(q)
               d1col = IbD1(symq)%ib(r)
               Q2matrix%aa%irrep(symgp)%block(m,n) = -1*D1cum(symq)%D1block(d1row,d1col) + Q2matrix%aa%irrep(symgp)%block(m,n)
               if(m.ne.n) then
                 Q2matrix%aa%irrep(symgp)%block(n,m) = -1*D1cum(symq)%D1block(d1row,d1col) + Q2matrix%aa%irrep(symgp)%block(n,m)
               end if
             end if
             d2row = IbD2aa(symgp)%ib(p,q)
             d2col = IbD2aa(symgp)%ib(s,r)
             Q2matrix%aa%irrep(symgp)%block(m,n) = D2matrix%aa%irrep(symgp)%block(d2row,d2col) + Q2matrix%aa%irrep(symgp)%block(m,n)
             if(m.ne.n) then
               Q2matrix%aa%irrep(symgp)%block(n,m) = D2matrix%aa%irrep(symgp)%block(d2row,d2col) + Q2matrix%aa%irrep(symgp)%block(n,m)
             end if
         end do
       end do
      end do
      Call FindLowestEigenvaluetypeD2(numSG,Q2matrix,1,LowestEigQ2(1))



       do symgp=1,numSG
         numrow = size(Q2abbasis(symgp)%basis,2)
         do m=1,numrow
           p = Q2abbasis(symgp)%basis(1,m)
           q = Q2abbasis(symgp)%basis(2,m)
           symp = Q2abbasis_sym(symgp)%basis(1,m)
           symq = Q2abbasis_sym(symgp)%basis(2,m)
           do n=1,m
             s = Q2abbasis(symgp)%basis(1,n)
             r = Q2abbasis(symgp)%basis(2,n)
             syms = Q2abbasis_sym(symgp)%basis(1,n)
             symr = Q2abbasis_sym(symgp)%basis(2,n)
             if(q.eq.r.and.p.eq.s) then
               Q2matrix%ab%irrep(symgp)%block(m,n) = 1.0 + Q2matrix%ab%irrep(symgp)%block(m,n)
               if(m.ne.n) then
                 Q2matrix%ab%irrep(symgp)%block(n,m) = 1.0 + Q2matrix%ab%irrep(symgp)%block(n,m)
               end if
             end if
             if(q.eq.r.and.symp.eq.syms) then
               d1row = IbD1(symp)%ib(p)
               d1col = IbD1(syms)%ib(s)
               Q2matrix%ab%irrep(symgp)%block(m,n) = -1*D1cum(syms)%D1block(d1row,d1col) + Q2matrix%ab%irrep(symgp)%block(m,n)
               if(n.ne.m) then
                 Q2matrix%ab%irrep(symgp)%block(n,m) = -1*D1cum(syms)%D1block(d1row,d1col) + Q2matrix%ab%irrep(symgp)%block(n,m)
               end if
             end if
             if(p.eq.s.and.symq.eq.symr) then
               d1row = IbD1(symq)%ib(q)
               d1col = IbD1(symr)%ib(r)
               Q2matrix%ab%irrep(symgp)%block(m,n) = -1*D1cum(symq)%D1block(d1row,d1col) + Q2matrix%ab%irrep(symgp)%block(m,n)
               if(m.ne.n) then
                 Q2matrix%ab%irrep(symgp)%block(n,m) = -1*D1cum(symq)%D1block(d1row,d1col) + Q2matrix%ab%irrep(symgp)%block(n,m)
               end if
             end if
             d2row = IbD2ab(symgp)%ib(p,q)
             d2col = IbD2ab(symgp)%ib(s,r)
             Q2matrix%ab%irrep(symgp)%block(m,n) = D2matrix%ab%irrep(symgp)%block(d2row,d2col) + Q2matrix%ab%irrep(symgp)%block(m,n)
             if(m.ne.n) then
               Q2matrix%ab%irrep(symgp)%block(n,m) = D2matrix%ab%irrep(symgp)%block(d2row,d2col) + Q2matrix%ab%irrep(symgp)%block(n,m)
             end if
           end do
         end do
       end do

      Call FindLowestEigenvaluetypeD2(numSG,Q2matrix,3,LowestEigQ2(2))


       allocate(G2abbasis(1:numSG))
       allocate(G2abbasis_sym(1:numSG))
       do symgp=1,numSG
         numrow = 0
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
           j_begin = virt(1,q)
           j_end   = virt(2,q)
           numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
           i_begin = virt(1,p)
           i_end   = virt(2,p)
           numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
         end do
         allocate(G2abbasis(symgp)%basis(1:2,1:numrow))
         G2abbasis(symgp)%basis(1:2,1:numrow) = 0
         allocate(G2abbasis_sym(symgp)%basis(1:2,1:numrow))
         G2abbasis_sym(symgp)%basis(1:2,1:numrow) = 0
      end do


       do symgp=1,numSG
         row = 1
         do t=1,numSG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               G2abbasis(symgp)%basis(1,row) = i
               G2abbasis(symgp)%basis(2,row) = j
               G2abbasis_sym(symgp)%basis(1,row) = p
               G2abbasis_sym(symgp)%basis(2,row) = q
               row = row + 1
             end do
           end do
           i_begin = occ(1,p)
           i_end   = occ(2,p)
           j_begin = virt(1,q)
           j_end   = virt(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               G2abbasis(symgp)%basis(1,row) = i
               G2abbasis(symgp)%basis(2,row) = j
               G2abbasis_sym(symgp)%basis(1,row) = p
               G2abbasis_sym(symgp)%basis(2,row) = q
               row = row + 1
             end do
           end do
           i_begin = virt(1,p)
           i_end   = virt(2,p)
           j_begin = occ(1,q)
           j_end   = occ(2,q)
           do i=i_begin,i_end
             do j=j_begin, j_end
               G2abbasis(symgp)%basis(1,row) = i
               G2abbasis(symgp)%basis(2,row) = j
               G2abbasis_sym(symgp)%basis(1,row) = p
               G2abbasis_sym(symgp)%basis(2,row) = q
               row = row + 1
             end do
           end do
           i_begin = virt(1,p)
           i_end   = virt(2,p)
           j_begin = virt(1,q)
           j_end   = virt(2,q)
           do i=i_begin,i_end
             do j=j_begin,j_end
               G2abbasis(symgp)%basis(1,row) = i
               G2abbasis(symgp)%basis(2,row) = j
               G2abbasis_sym(symgp)%basis(1,row) = p
               G2abbasis_sym(symgp)%basis(2,row) = q
               row = row + 1
             end do
           end do
         end do
      end do

      do symgp=1,numSG
        sizeG2block = size(G2abbasis(symgp)%basis,2)
        allocate(G2abmatrix(symgp)%D1block(1:sizeG2block,1:sizeG2block))
        G2abmatrix(symgp)%D1block(1:sizeG2block,1:sizeG2block) = 0.D0
        allocate(G2bamatrix(symgp)%D1block(1:sizeG2block,1:sizeG2block))
        G2bamatrix(symgp)%D1block(1:sizeG2block,1:sizeG2block) = 0.D0
      end do

      do symgp=1,numSG
        do m=1,size(G2abbasis(symgp)%basis,2)
          i = G2abbasis(symgp)%basis(1,m)
          j = G2abbasis(symgp)%basis(2,m)
          symi = G2abbasis_sym(symgp)%basis(1,m)
          symj = G2abbasis_sym(symgp)%basis(2,m)
          do n=1,m
            k = G2abbasis(symgp)%basis(1,n)
            l = G2abbasis(symgp)%basis(2,n)
            symk = G2abbasis_sym(symgp)%basis(1,n)
            syml = G2abbasis_sym(symgp)%basis(2,n)
            if(j.eq.l.and.symi.eq.symk) then
              d1row = IbD1(symi)%ib(i)
              d1col = IbD1(symk)%ib(k)
              G2abmatrix(symgp)%D1block(m,n) = D1cum(symi)%D1block(d1row,d1col) + G2abmatrix(symgp)%D1block(m,n)
              if(m.ne.n) then
                G2abmatrix(symgp)%D1block(n,m) = D1cum(symi)%D1block(d1row,d1col) + G2abmatrix(symgp)%D1block(n,m)
              end if
            end if
            sym1 = ProductTable(symk,symj)
            sym2 = ProductTable(symi,syml)
            if(sym1.eq.sym2) then
              d2row = IbD2ab(sym1)%ib(i,l)
              d2col = IbD2ab(sym2)%ib(k,j)
              G2abmatrix(symgp)%D1block(m,n) = -1*D2matrix%ab%irrep(sym1)%block(d2row,d2col) + G2abmatrix(symgp)%D1block(m,n)
              if(m.ne.n) then
                G2abmatrix(symgp)%D1block(n,m) = -1*D2matrix%ab%irrep(sym1)%block(d2row,d2col) + G2abmatrix(symgp)%D1block(n,m)
              end if
            end if
          end do
        end do
      end do
       Call FindLowestEigenvaluetypeD1(numSG,G2abmatrix,LowestEigG2(1))


      allocate(G2aabasis(1:numSG))
      allocate(G2bbbasis(1:numSG))
      allocate(G2aabasis_sym(1:numSG))
      allocate(G2bbbasis_sym(1:numSG))
      do symgp=1,numSG
        numrow = 0
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          i_begin = occ(1,p)
          i_end   = occ(2,p)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
          i_begin = occ(1,p)
          i_end   = occ(2,p)
          j_begin = virt(1,q)
          j_end   = virt(2,q)
          numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
          i_begin = virt(1,p)
          i_end   = virt(2,p)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
          i_begin = virt(1,p)
          i_end   = virt(2,p)
          j_begin = virt(1,q)
          j_end   = virt(2,q)
          numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
        end do
          allocate(G2aabasis(symgp)%basis(1:2,1:numrow))
          G2aabasis(symgp)%basis(1:2,1:numrow) = 0
          allocate(G2aabasis_sym(symgp)%basis(1:2,1:numrow))
          G2aabasis_sym(symgp)%basis(1:2,1:numrow) = 0
      end do

      do symgp=1,numSG
        numrow = 0
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          i_begin = occ(1,p)
          i_end   = occ(2,p)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
          i_begin = occ(1,p)
          i_end   = occ(2,p)
          j_begin = virt(1,q)
          j_end   = virt(2,q)
          numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
          i_begin = virt(1,p)
          i_end   = virt(2,p)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
          i_begin = virt(1,p)
          i_end   = virt(2,p)
          j_begin = virt(1,q)
          j_end   = virt(2,q)
          numrow = numrow + (i_end - i_begin + 1)*(j_end - j_begin + 1)
        end do
          allocate(G2bbbasis(symgp)%basis(1:2,1:numrow))
          G2bbbasis(symgp)%basis(1:2,1:numrow) = 0
          allocate(G2bbbasis_sym(symgp)%basis(1:2,1:numrow))
          G2bbbasis_sym(symgp)%basis(1:2,1:numrow) = 0
      end do

      do symgp=1,numSG
        row = 1
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          i_begin = occ(1,p)
          i_end   = occ(2,p)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              G2aabasis(symgp)%basis(1,row) = i
              G2aabasis(symgp)%basis(2,row) = j
              G2aabasis_sym(symgp)%basis(1,row) = p
              G2aabasis_sym(symgp)%basis(2,row) = q
              row = row + 1
            end do
          end do
          i_begin = occ(1,p)
          i_end   = occ(2,p)
          j_begin = virt(1,q)
          j_end   = virt(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              G2aabasis(symgp)%basis(1,row) = i
              G2aabasis(symgp)%basis(2,row) = j
              G2aabasis_sym(symgp)%basis(1,row) = p
              G2aabasis_sym(symgp)%basis(2,row) = q
              row = row + 1
            end do
          end do
          i_begin = virt(1,p)
          i_end   = virt(2,p)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              G2aabasis(symgp)%basis(1,row) = i
              G2aabasis(symgp)%basis(2,row) = j
              G2aabasis_sym(symgp)%basis(1,row) = p
              G2aabasis_sym(symgp)%basis(2,row) = q
              row = row + 1
            end do
          end do
          i_begin = virt(1,p)
          i_end   = virt(2,p)
          j_begin = virt(1,q)
          j_end   = virt(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              G2aabasis(symgp)%basis(1,row) = i
              G2aabasis(symgp)%basis(2,row) = j
              G2aabasis_sym(symgp)%basis(1,row) = p
              G2aabasis_sym(symgp)%basis(2,row) = q
              row = row + 1
            end do
          end do
        end do
      end do


      do symgp=1,numSG
        row = 1
        do t=1,numSG
          p = InvPdt(symgp)%upper(t)
          q = InvPdt(symgp)%lower(t)
          i_begin = occ(1,p)
          i_end   = occ(2,p)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              G2bbbasis(symgp)%basis(1,row) = i
              G2bbbasis(symgp)%basis(2,row) = j
              G2bbbasis_sym(symgp)%basis(1,row) = p
              G2bbbasis_sym(symgp)%basis(2,row) = q
              row = row + 1
            end do
          end do
          i_begin = occ(1,p)
          i_end   = occ(2,p)
          j_begin = virt(1,q)
          j_end   = virt(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              G2bbbasis(symgp)%basis(1,row) = i
              G2bbbasis(symgp)%basis(2,row) = j
              G2bbbasis_sym(symgp)%basis(1,row) = p
              G2bbbasis_sym(symgp)%basis(2,row) = q
              row = row + 1
            end do
          end do
          i_begin = virt(1,p)
          i_end   = virt(2,p)
          j_begin = occ(1,q)
          j_end   = occ(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              G2bbbasis(symgp)%basis(1,row) = i
              G2bbbasis(symgp)%basis(2,row) = j
              G2bbbasis_sym(symgp)%basis(1,row) = p
              G2bbbasis_sym(symgp)%basis(2,row) = q
              row = row + 1
            end do
          end do
          i_begin = virt(1,p)
          i_end   = virt(2,p)
          j_begin = virt(1,q)
          j_end   = virt(2,q)
          do i=i_begin,i_end
            do j=j_begin,j_end
              G2bbbasis(symgp)%basis(1,row) = i
              G2bbbasis(symgp)%basis(2,row) = j
              G2bbbasis_sym(symgp)%basis(1,row) = p
              G2bbbasis_sym(symgp)%basis(2,row) = q
              row = row + 1
            end do
          end do
        end do
      end do


      do symgp=1,numSG
        numrow = size(G2aabasis(symgp)%basis,2) + size(G2bbbasis(symgp)%basis,2)
        allocate(G2aabbmatrix(symgp)%D1block(1:numrow,1:numrow))
        G2aabbmatrix(symgp)%D1block(1:numrow,1:numrow) = 0.D0
      end do

      do symgp=1,numSG
        do m=1,size(G2aabasis(symgp)%basis,2)
          i = G2aabasis(symgp)%basis(1,m)
          j = G2aabasis(symgp)%basis(2,m)
          symi = G2aabasis_sym(symgp)%basis(1,m)
          symj = G2aabasis_sym(symgp)%basis(2,m)
          do n=1,m
            k = G2aabasis(symgp)%basis(1,n)
            l = G2aabasis(symgp)%basis(2,n)
            symk = G2aabasis_sym(symgp)%basis(1,n)
            syml = G2aabasis_sym(symgp)%basis(2,n)
            if(j.eq.l.and.symi.eq.symk) then
              d1row = IbD1(symi)%ib(i)
              d1col = IbD1(symk)%ib(k)
              G2aabbmatrix(symgp)%D1block(m,n) = D1cum(symk)%D1block(d1row,d1col) + G2aabbmatrix(symgp)%D1block(m,n)
              if(m.ne.n) then
                G2aabbmatrix(symgp)%D1block(n,m) = D1cum(symk)%D1block(d1row,d1col) + G2aabbmatrix(symgp)%D1block(n,m)
              end if
           end if
           sym1 = ProductTable(symk,symj)
           sym2 = ProductTable(symi,syml)
           if(sym1.eq.sym2.and.k.ne.j.and.i.ne.l) then
             elemsign = 1
             if(k.gt.j) then
               elemsign = -1*elemsign
             end if
             if(i.gt.l) then
               elemsign = -1*elemsign
             end if
             d2row = IbD2aa(sym1)%ib(k,j)
             d2col = IbD2aa(sym2)%ib(i,l)
             G2aabbmatrix(symgp)%D1block(m,n) = -1*elemsign*D2matrix%aa%irrep(sym1)%block(d2row,d2col) + G2aabbmatrix(symgp)%D1block(m,n)
             if(m.ne.n) then
               G2aabbmatrix(symgp)%D1block(n,m) = G2aabbmatrix(symgp)%D1block(m,n)
             end if
           end if
        end do
      end do
      end do




      do symgp=1,numSG
        offset = size(G2aabasis(symgp)%basis,2)
        do m=1,size(G2bbbasis(symgp)%basis,2)
          i = G2bbbasis(symgp)%basis(1,m)
          j = G2bbbasis(symgp)%basis(2,m)
          symi = G2bbbasis_sym(symgp)%basis(1,m)
          symj = G2bbbasis_sym(symgp)%basis(2,m)
          do n=1,m
            k = G2bbbasis(symgp)%basis(1,n)
            l = G2bbbasis(symgp)%basis(2,n)
            symk = G2bbbasis_sym(symgp)%basis(1,n)
            syml = G2bbbasis_sym(symgp)%basis(2,n)
            if(l.eq.j.and.symk.eq.symi) then
              d1row = IbD1(symk)%ib(k)
              d1col = IbD1(symi)%ib(i)
              G2aabbmatrix(symgp)%D1block(m+offset,n+offset) = D1cum(symk)%D1block(d1row,d1col) + G2aabbmatrix(symgp)%D1block(m+offset,n+offset)
              if(n.ne.m) then
                G2aabbmatrix(symgp)%D1block(n+offset,m+offset) = D1cum(symk)%D1block(d1row,d1col) + G2aabbmatrix(symgp)%D1block(n+offset,m+offset)
              end if
            end if
            sym1 = ProductTable(symk,symj)
            sym2 = ProductTable(symi,syml)
            if(sym1.eq.sym2.and.k.ne.j.and.i.ne.l) then
              d2row = IbD2aa(sym1)%ib(k,j)
              d2col = IbD2aa(sym2)%ib(i,l)
              elemsign = 1
              if(k.gt.j) then
                elemsign = -1*elemsign
              end if
              if(i.gt.l) then
                elemsign = -1*elemsign
              end if
              G2aabbmatrix(symgp)%D1block(m+offset,n+offset) = -1*elemsign*D2matrix%aa%irrep(sym1)%block(d2row,d2col) + G2aabbmatrix(symgp)%D1block(m+offset,n+offset)
              if(m.ne.n) then
                G2aabbmatrix(symgp)%D1block(n+offset,m+offset) = G2aabbmatrix(symgp)%D1block(m+offset,n+offset)
              end if
            end if
          end do
        end do
      end do









      do symgp=1,numSG
        offset = size(G2aabasis(symgp)%basis,2)
        do m=1,size(G2aabasis(symgp)%basis,2)
          i = G2aabasis(symgp)%basis(1,m)
          j = G2aabasis(symgp)%basis(2,m)
          symi = G2aabasis_sym(symgp)%basis(1,m)
          symj = G2aabasis_sym(symgp)%basis(2,m)
          do n=1,size(G2bbbasis(symgp)%basis,2)
            k = G2bbbasis(symgp)%basis(1,n)
            l = G2bbbasis(symgp)%basis(2,n)
            symk = G2bbbasis_sym(symgp)%basis(1,n)
            syml = G2bbbasis_sym(symgp)%basis(2,n)
            sym1 = ProductTable(symj,symk)
            sym2 = ProductTable(symi,syml)
            if(sym1.eq.sym2) then
              d2row = IbD2ab(sym1)%ib(j,k)
              d2col = IbD2ab(sym2)%ib(i,l)
              G2aabbmatrix(symgp)%D1block(m,n+offset) = D2matrix%ab%irrep(sym1)%block(d2row,d2col) + G2aabbmatrix(symgp)%D1block(m,n+offset)
              G2aabbmatrix(symgp)%D1block(n+offset,m) = D2matrix%ab%irrep(sym2)%block(d2row,d2col) + G2aabbmatrix(symgp)%D1block(n+offset,m)
            end if
          end do
        end do
      end do

       Call FindLowestEigenvaluetypeD1(numSG,G2aabbmatrix,LowestEigG2(2))

      write(*,*) 'Lowest Eigenvalues of the D2, Q2 and G2 matrices:'
      write(*,*) 'D2: '
      write(*,*) '   (aa):', LowestEigD2(1)
      write(*,*) '   (ab):', LowestEigD2(2)
      write(*,*) 'Q2: '
      write(*,*) '   (aa):', LowestEigQ2(1)
      write(*,*) '   (ab):', LowestEigQ2(2)
      write(*,*) 'G2: '
      write(*,*) '   (ab):  ', LowestEigG2(1)
      write(*,*) '   (aabb):', LowestEigG2(2)




      Q2outputfile = trim(filename) // 'Q2aa'
      open(unit=1,file=Q2outputfile,action='write')
      do i=1,numSG
        rowdim = ReshapedMatrixDim%ijaa(i)%col + ReshapedMatrixDim%ajaa(i)%col + ReshapedMatrixDim%ijaa(i)%row
        write(1,*) rowdim
      end do

      do p=1,numSG
       rowdim = ReshapedMatrixDim%ijaa(p)%col + ReshapedMatrixDim%ajaa(p)%col + ReshapedMatrixDim%ijaa(p)%row
       do i=1,rowdim
         do j=1,rowdim
           write(1,*) Q2matrix%aa%irrep(p)%block(j,i)
         end do
      end do
      end do
      close(1)


      Q2outputfile = trim(filename) // 'Q2ab'
      open(unit=1,file=Q2outputfile,action='write')
      do i=1,numSG
        rowdim = ReshapedMatrixDim%ijab(i)%row + ReshapedMatrixDim%ijab(i)%col + ReshapedMatrixDim%ajab(i)%col + ReshapedMatrixDim%ajba(i)%col
        write(1,*) rowdim
      end do
      do p=1,numSG
       rowdim = ReshapedMatrixDim%ijab(p)%row + ReshapedMatrixDim%ijab(p)%col + ReshapedMatrixDim%ajab(p)%col + ReshapedMatrixDim%ajba(p)%col
       do i=1,rowdim
         do j=1,rowdim
           write(1,*) Q2matrix%ab%irrep(p)%block(j,i)
         end do
      end do
      end do
      close(1)


      G2outputfile = trim(filename) // 'G2aabb'
      open(unit=1,file=G2outputfile,action='write')
      do i=1,numSG
        rowdim = size(G2aabasis(i)%basis,2)
        rowdim = rowdim + size(G2bbbasis(i)%basis,2)
        write(1,*) rowdim
      end do
      do p=1,numSG
       rowdim = size(G2aabasis(p)%basis,2)
       rowdim = rowdim + size(G2bbbasis(p)%basis,2)
       do i=1,rowdim
         do j=1,rowdim
           write(1,*) G2aabbmatrix(p)%D1block(j,i)
         end do
      end do
      end do
      close(1)

      G2outputfile = trim(filename) // 'G2ab'
      open(unit=1,file=G2outputfile,action='write')
      do i=1,numSG
        rowdim = size(G2abbasis(i)%basis,2)
        write(1,*) rowdim
      end do
      do p=1,numSG
       rowdim = size(G2abbasis(p)%basis,2)
       do i=1,rowdim
         do j=1,rowdim
           write(1,*) G2abmatrix(p)%D1block(j,i)
         end do
      end do
      end do
      close(1)


       end subroutine BuildQ2G2CS

!> @brief Calculates derivative for disk writing feature (open shell calculations) (intel compiler only)
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine CalcDerivBlockK2OS(T2data,K2,K1,numSG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,ReshapedMatrixDim,InvPdt,T2deriv, energy,K1TwoInts,T1data,T1deriv,Newc,DerivNewc,topfac,TwoInts,topsingles,OldIndex_alpha,OldIndex_beta,T2derivT1topfac,Newc_singles,DerivNewc_singles,numrowblocks,inputfile,BlockDim)
       Use InterfaceMod
       Use TypeMod
       Use TimeMod
       Implicit None

       type(T2) :: T2data
       type(T1) :: T1data,T1deriv, Newc_singles, DerivNewc_singles
       type(T2) :: Newc,DerivNewc, T2derivT1topfac
       type(spin) :: K2(1:2,1:2,1:2,1:2)
       type(spin) :: K1(1:2,1:2),K1TwoInts(1:2,1:2)
       integer :: numSG
       integer, intent(IN), dimension(1:numSG,1:numSG) :: ProductTable
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN) :: InvPdt(1:numSG)
       integer, intent(IN), dimension(1:2,1:numSG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       type(T2) :: T2deriv
       real(8) :: energy
       real(8), dimension(0:2,0:2) :: topfac
       real(8), intent(IN), allocatable, dimension(:,:,:,:) :: TwoInts
       real(8), dimension(0:1,0:1) :: topsingles(0:1,0:1)
       integer, allocatable, dimension(:) :: OldIndex_alpha, OldIndex_beta
       integer :: numrowblocks
       character(len=35) :: inputfile
       type(BlockMatMulDims) :: BlockDim


       integer :: p, i_begin,i_end,j_begin,j_end,k_begin,k_end, l_begin,l_end,i,j,k,l,q,r,s,t,v,row,col,symgp
       integer :: c_begin,c_end,a_begin,a_end,c,a

       type(ReshapedMat), allocatable, dimension(:)  :: DerivReshapes, Reshapes, TopReshape,DerivTopReshape
       real(8) :: tempenergy=0.0D0
       type(ReshapedMat), allocatable, dimension(:) :: TempReshape,TempDerivReshape,TempMat1,TempMat2
       real(8), allocatable, dimension(:,:) :: temp
       integer :: time_initial(8),time_final(8)
       real :: time_total_begin, time_total_end
       integer :: numa,numi
       integer :: numocc_alpha, numvirt_alpha,numocc_beta,numvirt_beta
       double precision :: T1energy
       character(len=100) :: K2filename
       character(len=1) :: tempchar
       Call cpu_time(time_total_begin)



       energy = 0.0D0

       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ijaa_testOS(numSG,ProductTable,Reshapes,occ_alpha,virt_alpha,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,1,1)%aa%irrep(p)%block)
       end do
         do p=1,numSG
           write(tempchar,'(I1)') p
           K2filename = trim(inputfile) // 'aaSG' // trim(tempchar)
           DerivReshapes(p)%ReshapedMatrix = 2*matmul3(Reshapes(p)%ReshapedMatrix,BlockDim,'aa',p,K2filename,numrowblocks) + DerivReshapes(p)%ReshapedMatrix
        end do
       Call reshape_ijaa_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,virt_alpha,T2deriv,ReshapedMatrixDim,InvPdt)
       deallocate(DerivReshapes)
       allocate(DerivReshapes(1:numSG))
       allocate(TopReshape(1:numSG))


       Call TopFactorOS(TwoInts,T2data,occ_alpha,occ_beta,virt_alpha,virt_beta,numSG,topfac,Newc,InvPdt,ProductTable,DerivNewc,T1data,T1deriv,topsingles,OldIndex_alpha,OldIndex_beta,T2derivT1topfac,Newc_singles,DerivNewc_singles,K1,K1TwoInts)

       Call reshape_ijaa_testOS(numSG,ProductTable,TopReshape,occ_alpha,virt_alpha,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)

       do p=1,numSG
         do s=1,ReshapedMatrixDim%ijaa(p)%col
           do q=1,ReshapedMatrixDim%ijaa(p)%row
             energy = energy + Reshapes(p)%ReshapedMatrix(q,s)*2*K2(1,1,2,2)%aa%irrep(p)%block(q,s)*TopReshape(p)%ReshapedMatrix(q,s)
             tempenergy = tempenergy + Reshapes(p)%ReshapedMatrix(q,s)*2*K2(1,1,2,2)%aa%irrep(p)%block(q,s)*TopReshape(p)%ReshapedMatrix(q,s)
           end do
         end do
       end do

       deallocate(TopReshape)
       deallocate(Reshapes)
       deallocate(DerivReshapes)

       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ajaaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)

       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,2,1,2)%aa%irrep(p)%block)
       end do
       Call reshape_ajaa_inverseOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)

       deallocate(Reshapes)
       deallocate(DerivReshapes)




       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ijbb_testOS(numSG,ProductTable,Reshapes,occ_beta,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,1,1)%bb%irrep(p)%block)
       end do
         do p=1,numSG
           write(tempchar,'(I1)') p
           K2filename = trim(inputfile) // 'bbSG' // trim(tempchar)
           DerivReshapes(p)%ReshapedMatrix = 2*matmul3(Reshapes(p)%ReshapedMatrix,BlockDim,'bb',p,K2filename,numrowblocks) + DerivReshapes(p)%ReshapedMatrix
        end do
       Call reshape_ijbb_inverseOS(numSG,ProductTable,DerivReshapes,occ_beta,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
       deallocate(DerivReshapes)
       allocate(DerivReshapes(1:numSG))
       allocate(TopReshape(1:numSG))

       Call reshape_ijbb_testOS(numSG,ProductTable,TopReshape,occ_beta,virt_beta,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)

       do p=1,numSG
         do s=1,ReshapedMatrixDim%ijbb(p)%col
           do q=1,ReshapedMatrixDim%ijbb(p)%row
             energy = energy + Reshapes(p)%ReshapedMatrix(q,s)*2*K2(1,1,2,2)%bb%irrep(p)%block(q,s)*TopReshape(p)%ReshapedMatrix(q,s)
             tempenergy = tempenergy + Reshapes(p)%ReshapedMatrix(q,s)*2*K2(1,1,2,2)%bb%irrep(p)%block(q,s)*TopReshape(p)%ReshapedMatrix(q,s)

           end do
         end do
       end do
       deallocate(TopReshape)
       deallocate(Reshapes)
       deallocate(DerivReshapes)
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ajbbOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(K2(1,2,1,2)%bb%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
       end do
       Call reshape_ajbb_inverseOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       deallocate(Reshapes)
       deallocate(DerivReshapes)




       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ijab_testOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,1,1)%ab%irrep(p)%block)
       end do
       do p=1,numSG
         write(tempchar,'(I1)') p
         K2filename = trim(inputfile) // 'abSG' // trim(tempchar)
         DerivReshapes(p)%ReshapedMatrix = 2*matmul3(Reshapes(p)%ReshapedMatrix,BlockDim,'ab',p,K2filename,numrowblocks) + DerivReshapes(p)%ReshapedMatrix
       end do
       Call reshape_ijab_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)


       deallocate(DerivReshapes)
       allocate(TopReshape(1:numSG))
       allocate(DerivReshapes(1:numSG))

       Call reshape_ijab_testOS(numSG,ProductTable,TopReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)
       deallocate(DerivReshapes)
       do p=1,numSG
         do q=1,ReshapedMatrixDim%ijab(p)%col
           do s=1,ReshapedMatrixDim%ijab(p)%row
             energy = energy + Reshapes(p)%ReshapedMatrix(s,q)*2*K2(1,1,2,2)%ab%irrep(p)%block(s,q)*TopReshape(p)%ReshapedMatrix(s,q)
             tempenergy = tempenergy + Reshapes(p)%ReshapedMatrix(s,q)*2*K2(1,1,2,2)%ab%irrep(p)%block(s,q)*TopReshape(p)%ReshapedMatrix(s,q)

           end do
         end do
      end do
       deallocate(TopReshape)

       deallocate(Reshapes)
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ajabOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(2,1,2,1)%ab%irrep(p)%block)
      end do
       Call reshape_ajab_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)

       deallocate(Reshapes)
       deallocate(DerivReshapes)
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ajbaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,2,1,2)%ab%irrep(p)%block)
       end do
       Call reshape_ajba_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
       deallocate(Reshapes)
       deallocate(DerivReshapes)


       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ialphaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K1(1,1)%aa%irrep(p)%block)
       end do
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix =-1*2*matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(1,1)%aa%irrep(p)%block) + DerivReshapes(p)%ReshapedMatrix
      end do

      Call reshape_ialpha_inverseOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
      deallocate(Reshapes)
      deallocate(DerivReshapes)
      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))

      Call reshape_aalphaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K1(2,2)%aa%irrep(p)%block)
      end do
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(2,2)%aa%irrep(p)%block) + DerivReshapes(p)%ReshapedMatrix
      end do

      Call reshape_aalpha_inverseOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
      deallocate(Reshapes)
      deallocate(DerivReshapes)
       allocate(Reshapes(1:numSG))
       allocate(DerivReshapes(1:numSG))
       Call reshape_ibetaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
          DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(K1(1,1)%bb%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
       end do
       do p=1,numSG
          DerivReshapes(p)%ReshapedMatrix =-1*2*matmul4(K1TwoInts(1,1)%bb%irrep(p)%block,Reshapes(p)%ReshapedMatrix) + DerivReshapes(p)%ReshapedMatrix
      end do
      Call reshape_ibeta_inverseOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
      deallocate(Reshapes)
      deallocate(DerivReshapes)

      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
      Call reshape_abetaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K1(2,2)%bb%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
      end do

      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K1TwoInts(2,2)%bb%irrep(p)%block,Reshapes(p)%ReshapedMatrix) + DerivReshapes(p)%ReshapedMatrix
      end do
      Call reshape_abeta_inverseOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
      deallocate(Reshapes)
      deallocate(DerivReshapes)


       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_alpha(1,r)
                 c_end   = virt_alpha(2,r)
                 k_begin = occ_alpha(1,s)
                 k_end   = occ_alpha(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     energy = energy + 0.5*T2data%aa%m(a,j)%nsym(r,s)%n(c,k)*T2deriv%aa%m(a,j)%nsym(r,s)%n(c,k)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_beta(1,r)
                 c_end   = virt_beta(2,r)
                 k_begin = occ_beta(1,s)
                 k_end   = occ_beta(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     energy = energy + 0.5*T2data%bb%m(a,j)%nsym(r,s)%n(c,k)*T2deriv%bb%m(a,j)%nsym(r,s)%n(c,k)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do



       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p);
           a_end   = virt_alpha(2,p);
           j_begin = occ_alpha(1,q);
           j_end   = occ_alpha(2,q);
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_beta(1,r)
                 c_end   = virt_beta(2,r)
                 k_begin = occ_beta(1,s)
                 k_end   = occ_beta(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     energy = energy + 0.5*T2data%ab%m(a,j)%nsym(r,s)%n(c,k)*T2deriv%ab%m(a,j)%nsym(r,s)%n(c,k)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

      allocate(DerivReshapes(1:numSG))
      allocate(TopReshape(1:numSG))
      allocate(DerivTopReshape(1:numSG))

      Call reshape_ijaa_testOS(numSG,ProductTable,TopReshape,occ_alpha,virt_alpha,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)
      deallocate(DerivReshapes)
      allocate(DerivReshapes(1:numSG))
      Call reshape_ijaa_testOS(numSG,ProductTable,DerivTopReshape,occ_alpha,virt_alpha,DerivNewc,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         do q=1,ReshapedMatrixDim%ijaa(p)%col
           do s=1,ReshapedMatrixDim%ijaa(p)%row
             DerivReshapes(p)%ReshapedMatrix(s,q) = 2*(K2(1,1,2,2)%aa%irrep(p)%block(s,q)*TopReshape(p)%ReshapedMatrix(s,q) + DerivTopReshape(p)%ReshapedMatrix(s,q))
            end do
         end do
       end do

       Call reshape_ijaa_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,virt_alpha,T2deriv,ReshapedMatrixDim,InvPdt)

       deallocate(DerivReshapes)
       deallocate(TopReshape)
       deallocate(DerivTopReshape)

      allocate(DerivReshapes(1:numSG))
      allocate(TopReshape(1:numSG))
      allocate(DerivTopReshape(1:numSG))

      Call reshape_ijbb_testOS(numSG,ProductTable,TopReshape,occ_beta,virt_beta,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)
      deallocate(DerivReshapes)
      allocate(DerivReshapes(1:numSG))
      Call reshape_ijbb_testOS(numSG,ProductTable,DerivTopReshape,occ_beta,virt_beta,DerivNewc,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         do q=1,ReshapedMatrixDim%ijbb(p)%col
           do s=1,ReshapedMatrixDim%ijbb(p)%row
             DerivReshapes(p)%ReshapedMatrix(s,q) = 2*(K2(1,1,2,2)%bb%irrep(p)%block(s,q)*TopReshape(p)%ReshapedMatrix(s,q) + DerivTopReshape(p)%ReshapedMatrix(s,q))
            end do
         end do
       end do

       Call reshape_ijbb_inverseOS(numSG,ProductTable,DerivReshapes,occ_beta,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)

       deallocate(DerivReshapes)
       deallocate(TopReshape)
       deallocate(DerivTopReshape)
        allocate(DerivReshapes(1:numSG))
        allocate(TopReshape(1:numSG))
        allocate(DerivTopReshape(1:numSG))
        Call reshape_ijab_testOS(numSG,ProductTable,TopReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,Newc,ReshapedMatrixDim,InvPdt,DerivReshapes)
       deallocate(DerivReshapes)
       allocate(DerivReshapes(1:numSG))
       Call reshape_ijab_testOS(numSG,ProductTable,DerivTopReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,DerivNewc,ReshapedMatrixDim,InvPdt,DerivReshapes)
      do p=1,numSG
        do q=1,ReshapedMatrixDim%ijab(p)%col
          do s=1,ReshapedMatrixDim%ijab(p)%row
            DerivReshapes(p)%ReshapedMatrix(s,q) = 2*(K2(1,1,2,2)%ab%irrep(p)%block(s,q)*TopReshape(p)%ReshapedMatrix(s,q) + DerivTopReshape(p)%ReshapedMatrix(s,q))
          end do
        end do
      end do

      Call reshape_ijab_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
      deallocate(DerivReshapes)
      deallocate(TopReshape)
      deallocate(DerivTopReshape)
      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
      allocate(TempReshape(1:numSG))
      allocate(TempDerivReshape(1:numSG))





      Call reshape_ajaaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_ajbbOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      allocate(TempMat1(1:numSG))
      allocate(TempMat2(1:numSG))
      do p=1,numSG
        allocate(TempMat1(p)%ReshapedMatrix(1:ReshapedMatrixDim%ajaa(p)%col,1:ReshapedMatrixDim%ajaa(p)%row))
        allocate(TempMat2(p)%ReshapedMatrix(1:ReshapedMatrixdim%ajbb(p)%row,1:ReshapedMatrixDim%ajbb(p)%col))
      end do

       do p=1,numSG
          TempMat1(p)%ReshapedMatrix = 2*-1*-1*matmul4(K2(2,1,1,2)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
       end do
       do p=1,numSG
           TempMat2(p)%ReshapedMatrix = 2*-1*-1*matmul4(Reshapes(p)%ReshapedMatrix,K2(2,1,1,2)%ab%irrep(p)%block)
       end do

       do p=1,numSG
         do q=1,ReshapedMatrixDim%ajaa(p)%row
           do s=1,ReshapedMatrixDim%ajaa(p)%col
               energy = energy + TempMat1(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
           end do
         end do
      end do
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = transpose(TempMat1(p)%ReshapedMatrix)
         TempDerivReshape(p)%ReshapedMatrix = transpose(TempMat2(p)%ReshapedMatrix)
       end do
        deallocate(TempMat1,TempMat2)

         Call reshape_ajaa_inverseOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
         Call reshape_ajbb_inverseOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,TempDerivReshape)


         deallocate(DerivReshapes)
         deallocate(TempDerivReshape)
         deallocate(Reshapes)
         deallocate(TempReshape)



     allocate(DerivReshapes(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempReshape(1:numSG))
     Call reshape_jka_aaaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_balphaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
     do p=1,numSG
       TempDerivReshape(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,1,2)%aa%irrep(p)%block)
       DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K2(1,1,1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
     end do
     do p=1,numSG
      do q=1,ReshapedMatrixDim%jka_aaa(p)%row
        do s=1,ReshapedMatrixDim%jka_aaa(p)%col
         energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
        end do
      end do
     end do
     Call reshape_jka_aaa_inverseOS(numSG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_balpha_inverseOS(numSG,ProductTable,TempDerivReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
     deallocate(Reshapes)
     deallocate(TempReshape)
     deallocate(TempDerivReshape)
     deallocate(DerivReshapes)


     allocate(DerivReshapes(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempReshape(1:numSG))
     Call reshape_jka_bbbOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_bbetaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
     do p=1,numSG
       TempDerivReshape(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,1,2)%bb%irrep(p)%block)
       DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K2(1,1,1,2)%bb%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
     end do
     do p=1,numSG
      do q=1,ReshapedMatrixDim%jka_bbb(p)%row
        do s=1,ReshapedMatrixDim%jka_bbb(p)%col
         energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
        end do
      end do
     end do
     Call reshape_jka_bbb_inverseOS(numSG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_bbeta_inverseOS(numSG,ProductTable,TempDerivReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
     deallocate(Reshapes)
     deallocate(TempReshape)
     deallocate(TempDerivReshape)
     deallocate(DerivReshapes)





     allocate(DerivReshapes(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempReshape(1:numSG))
     Call reshape_bci_aaaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ialphaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K2(2,2,1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
        TempDerivReshape(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(2,2,1,2)%aa%irrep(p)%block)
      end do
     do p=1,numSG
       do q=1,ReshapedMatrixDim%bci_aaa(p)%row
         do s=1,ReshapedMatrixdim%bci_aaa(p)%col
           energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
         end do
       end do
      end do
      Call reshape_bci_aaa_inverseOS(numSG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_ialpha_inverseOS(numSG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      deallocate(Reshapes)
      deallocate(TempReshape)
      deallocate(TempDerivReshape)
      deallocate(DerivReshapes)


     allocate(DerivReshapes(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempReshape(1:numSG))
     Call reshape_bci_bbbOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibetaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K2(2,2,1,2)%bb%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
        TempDerivReshape(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(2,2,1,2)%bb%irrep(p)%block)
      end do
     do p=1,numSG
       do q=1,ReshapedMatrixDim%bci_bbb(p)%row
         do s=1,ReshapedMatrixdim%bci_bbb(p)%col
           energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
         end do
       end do
      end do
      Call reshape_bci_bbb_inverseOS(numSG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_ibeta_inverseOS(numSG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      deallocate(Reshapes)
      deallocate(TempReshape)
      deallocate(TempDerivReshape)
      deallocate(DerivReshapes)



      allocate(DerivReshapes(1:numSG))
      allocate(TempDerivReshape(1:numSG))
      allocate(Reshapes(1:numSG))
      allocate(TempReshape(1:numSG))
      Call reshape_jka_abbOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_balphaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
     do p=1,numSG
       DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(K2(1,1,1,2)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
       TempDerivReshape(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,1,2)%ab%irrep(p)%block)
     end do
     do p=1,numSG
       do q=1,ReshapedMatrixDim%jka_abb(p)%row
         do s=1,ReshapedMatrixDim%jka_abb(p)%col
           energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
         end do
       end do
     end do
      Call reshape_t1_balpha_inverseOS(numSG,ProductTable,TempDerivReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
      Call reshape_jka_abb_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
      deallocate(Reshapes)
      deallocate(TempReshape)
      deallocate(TempDerivReshape)
      deallocate(DerivReshapes)

      allocate(DerivReshapes(1:numSG))
      allocate(TempDerivReshape(1:numSG))
      allocate(Reshapes(1:numSG))
      allocate(TempReshape(1:numSG))
      Call reshape_jka_abaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      Call reshape_t1_bbetaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
     do p=1,numSG
       DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(K2(1,1,2,1)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
       TempDerivReshape(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,1,2,1)%ab%irrep(p)%block)
     end do
     do p=1,numSG
       do q=1,ReshapedMatrixDim%jka_aba(p)%row
         do s=1,ReshapedMatrixDim%jka_aba(p)%col
           energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q) * Reshapes(p)%ReshapedMatrix(q,s)
         end do
       end do
     end do
      Call reshape_t1_bbeta_inverseOS(numSG,ProductTable,TempDerivReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
      Call reshape_jka_aba_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
     deallocate(Reshapes)
     deallocate(TempReshape)
     deallocate(TempDerivReshape)
     deallocate(DerivReshapes)


    allocate(DerivReshapes(1:numSG))
    allocate(TempDerivReshape(1:numSG))
    allocate(Reshapes(1:numSG))
    allocate(TempReshape(1:numSG))
    Call reshape_bci_abaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
    Call reshape_t1_ibetaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
    do p=1,numSG
      DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K2(2,2,1,2)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
      TempDerivReshape(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(2,2,1,2)%ab%irrep(p)%block)
    end do
    do p=1,numSG
      do q=1,ReshapedMatrixDim%bci_aba(p)%row
        do s=1,ReshapedMatrixDim%bci_aba(p)%col
          energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(q,s)
        end do
      end do
    end do
     Call reshape_t1_ibeta_inverseOS(numSG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt,TempDerivReshape)
     Call reshape_bci_aba_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
    deallocate(Reshapes)
    deallocate(TempReshape)
    deallocate(TempDerivReshape)
    deallocate(DerivReshapes)

    allocate(DerivReshapes(1:numSG))
    allocate(TempDerivReshape(1:numSG))
    allocate(Reshapes(1:numSG))
    allocate(TempReshape(1:numSG))
    Call reshape_bci_abbOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
    Call reshape_t1_ialphaOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix =1*2*matmul4(K2(2,2,2,1)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
        TempDerivReshape(p)%ReshapedMatrix = 1*2*matmul4(Reshapes(p)%ReshapedMatrix,K2(2,2,2,1)%ab%irrep(p)%block)
      end do
     do p=1,numSG
       do q=1,ReshapedMatrixDim%bci_abb(p)%row
         do s=1,ReshapedMatrixDim%bci_abb(p)%col
           energy = energy + DerivReshapes(p)%ReshapedMatrix(s,q) * Reshapes(p)%ReshapedMatrix(q,s)
         end do
       end do
     end do
      Call reshape_t1_ialpha_inverseOS(numSG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      Call reshape_bci_abb_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
      deallocate(Reshapes)
      deallocate(TempReshape)
      deallocate(TempDerivReshape)
      deallocate(DerivReshapes)





       allocate(DerivReshapes(1:numSG))
       allocate(Reshapes(1:numSG))
       Call reshape_t1t1_ialphaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K1(1,1)%aa%irrep(p)%block)
       end do
       do p=1,numSG
         numa = virt_alpha(2,p) - virt_alpha(1,p) + 1
         numi = occ_alpha(2,p) - occ_alpha(1,p) + 1
         do q=1,numi
           do s=1,numa
             energy = energy + 0.5*Reshapes(p)%ReshapedMatrix(s,q)* DerivReshapes(p)%ReshapedMatrix(s,q)
           end do
         end do
       end do
       Call reshape_t1t1_ialpha_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)

       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*-1*matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(1,1)%aa%irrep(p)%block)
       end do
       do p=1,numSG
         numa = virt_alpha(2,p) - virt_alpha(1,p) + 1
         numi = occ_alpha(2,p) - occ_alpha(1,p) + 1
         do q=1,numi
           do s=1,numa
             energy = energy + 0.5*Reshapes(p)%ReshapedMatrix(s,q)* DerivReshapes(p)%ReshapedMatrix(s,q)
           end do
         end do
       end do
       Call reshape_t1t1_ialpha_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)

      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K1(2,2)%aa%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
      end do
      do p=1,numSG
         numa = virt_alpha(2,p) - virt_alpha(1,p) + 1
         numi = occ_alpha(2,p) - occ_alpha(1,p) + 1
          do q=1,numi
           do s=1,numa
             energy = energy + 0.5*DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(s,q)
            end do
         end do
      end do
        Call reshape_t1t1_ialpha_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
       do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K1TwoInts(2,2)%aa%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
      end do
      do p=1,numSG
         numa = virt_alpha(2,p) - virt_alpha(1,p) + 1
         numi = occ_alpha(2,p) - occ_alpha(1,p) + 1
          do q=1,numi
           do s=1,numa
             energy = energy + 0.5*DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(s,q)
            end do
         end do
      end do
      Call reshape_t1t1_ialpha_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)

      deallocate(DerivReshapes)
      deallocate(Reshapes)

       allocate(DerivReshapes(1:numSG))
       allocate(Reshapes(1:numSG))
       Call reshape_t1t1_ibetaOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = -1*2*matmul4(Reshapes(p)%ReshapedMatrix,K1(1,1)%bb%irrep(p)%block)
       end do
       do p=1,numSG
         numa = virt_beta(2,p) - virt_beta(1,p) + 1
         numi = occ_beta(2,p) - occ_beta(1,p) + 1
         do q=1,numi
           do s=1,numa
             energy = energy + 0.5*Reshapes(p)%ReshapedMatrix(s,q)*DerivReshapes(p)%ReshapedMatrix(s,q)
           end do
         end do
       end do
       Call reshape_t1t1_ibeta_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
       do p=1,numSG
         DerivReshapes(p)%ReshapedMatrix = 2*-1*matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(1,1)%bb%irrep(p)%block)
       end do
       do p=1,numSG
         numa = virt_beta(2,p) - virt_beta(1,p) + 1
         numi = occ_beta(2,p) - occ_beta(1,p) + 1
         do q=1,numi
           do s=1,numa
             energy = energy + 0.5*Reshapes(p)%ReshapedMatrix(s,q)* DerivReshapes(p)%ReshapedMatrix(s,q)
           end do
         end do
       end do
       Call reshape_t1t1_ibeta_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K1(2,2)%bb%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
      end do
      do p=1,numSG
         numa = virt_beta(2,p) - virt_beta(1,p) + 1
         numi = occ_beta(2,p) - occ_beta(1,p) + 1
          do q=1,numi
           do s=1,numa
             energy = energy + 0.5*DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(s,q)
            end do
         end do
      end do
        Call reshape_t1t1_ibeta_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
       do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K1TwoInts(2,2)%bb%irrep(p)%block,Reshapes(p)%ReshapedMatrix)
      end do
      do p=1,numSG
         numa = virt_beta(2,p) - virt_beta(1,p) + 1
         numi = occ_beta(2,p) - occ_beta(1,p) + 1
          do q=1,numi
           do s=1,numa
             energy = energy + 0.5*DerivReshapes(p)%ReshapedMatrix(s,q)*Reshapes(p)%ReshapedMatrix(s,q)
            end do
         end do
      end do
      Call reshape_t1t1_ibeta_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
      deallocate(Reshapes)
      deallocate(DerivReshapes)


      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
      T1energy = 0.0
      Call reshape_t1_ibrow_alphaonly_symiOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      deallocate(DerivReshapes)
      allocate(DerivReshapes(1:numsG))
      allocate(TopReshape(1:numSG))
      Call reshape_t1_ibrow_alphaonly_symiOS(numSG,ProductTable,TopReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,Newc_singles,ReshapedMatrixDim,InvPdt,DerivReshapes)
      deallocate(DerivReshapes)
      allocate(DerivReshapes(1:numSG))
      allocate(DerivTopReshape(1:numSG))
      Call reshape_t1_ibrow_alphaonly_symiOS(numSG,ProductTable,DerivTopReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,DerivNewc_singles,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         numa = virt_alpha(2,p) - virt_alpha(1,p) + 1
         numi = occ_alpha(2,p) - occ_alpha(1,p) + 1
         do q=1,numa*numi
           DerivReshapes(p)%ReshapedMatrix(q,1) = (2*K1(1,2)%aa%irrep(p)%block(q,1) + K1TwoInts(1,2)%aa%irrep(p)%block(q,1)) * TopReshape(p)%ReshapedMatrix(1,q) + DerivTopReshape(p)%ReshapedMatrix(1,q)
           T1energy = (2*K1(1,2)%aa%irrep(p)%block(q,1)+K1TwoInts(1,2)%aa%irrep(p)%block(q,1))*Reshapes(p)%ReshapedMatrix(1,q)*TopReshape(p)%ReshapedMatrix(1,q) + T1energy

           energy = energy + (2*K1(1,2)%aa%irrep(p)%block(q,1)+K1TwoInts(1,2)%aa%irrep(p)%block(q,1))*Reshapes(p)%ReshapedMatrix(1,q)*TopReshape(p)%ReshapedMatrix(1,q)
         end do
      end do
      Call reshape_t1_ibrow_alphaonly_symi_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
     deallocate(DerivReshapes)
     deallocate(Reshapes)
     deallocate(TopReshape)
     deallocate(DerivTopReshape)


      allocate(Reshapes(1:numSG))
      allocate(DerivReshapes(1:numSG))
      Call reshape_t1_ibrow_betaonly_symiOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
      deallocate(DerivReshapes)
      allocate(DerivReshapes(1:numSG))
      allocate(TopReshape(1:numSG))
      Call reshape_t1_ibrow_betaonly_symiOS(numSG,ProductTable,TopReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,Newc_singles,ReshapedMatrixDim,InvPdt,DerivReshapes)
      deallocate(DerivReshapes)
      allocate(DerivReshapes(1:numSG))
      allocate(DerivTopReshape(1:numSG))
      Call reshape_t1_ibrow_betaonly_symiOS(numSG,ProductTable,DerivTopReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,DerivNewc_singles,ReshapedMatrixDim,InvPdt,DerivReshapes)
       do p=1,numSG
         numa = virt_beta(2,p) - virt_beta(1,p) + 1
         numi = occ_beta(2,p) - occ_beta(1,p) + 1
         do q=1,numa*numi
           DerivReshapes(p)%ReshapedMatrix(q,1) = (2*K1(1,2)%bb%irrep(p)%block(q,1) + K1TwoInts(1,2)%bb%irrep(p)%block(q,1)) * TopReshape(p)%ReshapedMatrix(1,q) + DerivTopReshape(p)%ReshapedMatrix(1,q)
           T1energy = T1energy + (2*K1(1,2)%bb%irrep(p)%block(q,1)+K1TwoInts(1,2)%bb%irrep(p)%block(q,1))*Reshapes(p)%ReshapedMatrix(1,q)*TopReshape(p)%ReshapedMatrix(1,q)
           energy = energy + (2*K1(1,2)%bb%irrep(p)%block(q,1)+K1TwoInts(1,2)%bb%irrep(p)%block(q,1))*Reshapes(p)%ReshapedMatrix(1,q)*TopReshape(p)%ReshapedMatrix(1,q)
         end do
      end do
      Call reshape_t1_ibrow_betaonly_symi_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
     deallocate(DerivReshapes)
     deallocate(Reshapes)
     deallocate(TopReshape)
     deallocate(DerivTopReshape)


       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p)
           a_end   = virt_alpha(2,p)
           j_begin = occ_alpha(1,q)
           j_end   = occ_alpha(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_alpha(1,r)
                 c_end   = virt_alpha(2,r)
                 k_begin = occ_alpha(1,s)
                 k_end   = occ_alpha(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     T2deriv%aa%m(a,j)%nsym(r,s)%n(c,k) = T2deriv%aa%m(a,j)%nsym(r,s)%n(c,k) + T2derivT1topfac%aa%m(a,j)%nsym(r,s)%n(c,k)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do

       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_beta(1,r)
                 c_end   = virt_beta(2,r)
                 k_begin = occ_beta(1,s)
                 k_end   = occ_beta(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     T2deriv%bb%m(a,j)%nsym(r,s)%n(c,k) =  T2deriv%bb%m(a,j)%nsym(r,s)%n(c,k) + T2derivT1topfac%bb%m(a,j)%nsym(r,s)%n(c,k)
                   end do
                 end do
               end do
             end do
           end do
         end do
       end do



       do symgp=1,numSG
         do t=1,numSG
           p=InvPdt(symgp)%upper(t)
           q=InvPdt(symgp)%lower(t)
           a_begin = virt_alpha(1,p);
           a_end   = virt_alpha(2,p);
           j_begin = occ_alpha(1,q);
           j_end   = occ_alpha(2,q);
           do j=j_begin,j_end
             do a=a_begin,a_end
               do v=1,numSG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_beta(1,r)
                 c_end   = virt_beta(2,r)
                 k_begin = occ_beta(1,s)
                 k_end   = occ_beta(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     T2deriv%ab%m(a,j)%nsym(r,s)%n(c,k) =  T2deriv%ab%m(a,j)%nsym(r,s)%n(c,k) + T2derivT1topfac%ab%m(a,j)%nsym(r,s)%n(c,k)

                   end do
                 end do
               end do
             end do
           end do
         end do
       end do
















     allocate(DerivReshapes(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempReshape(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     Call reshape_ajaa_t1OS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibrowOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
     allocate(temp(1:1,1:1))
      do p=1,numSG
       DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K1(1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
       TempDerivReshape(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K1(1,2)%aa%irrep(p)%block)
      end do
      do p=1,numSG
        temp = matmul4(TempReshape(p)%ReshapedMatrix,TempDerivReshape(p)%ReshapedMatrix)
        energy = energy + temp(1,1)
      end do
      Call reshape_ajaa_t1_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
      Call reshape_t1_ibrow_inverseOS(numSG,ProductTable,TempDerivReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)

      deallocate(DerivReshapes)
      deallocate(Reshapes)
      deallocate(TempDerivReshape)
      deallocate(TempReshape)

     allocate(DerivReshapes(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempReshape(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     Call reshape_ajbb_t1OS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibrowOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      do p=1,numSG
       DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K1(1,2)%bb%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
       TempDerivReshape(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K1(1,2)%bb%irrep(p)%block)
      end do
      do p=1,numSG
        temp = matmul4(TempReshape(p)%ReshapedMatrix,TempDerivReshape(p)%ReshapedMatrix)
        energy = energy + temp(1,1)
      end do
      Call reshape_ajbb_t1_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
      Call reshape_t1_ibrow_inverseOS(numSG,ProductTable,TempDerivReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)

      deallocate(DerivReshapes)
      deallocate(Reshapes)
      deallocate(TempDerivReshape)
      deallocate(TempReshape)



      allocate(DerivReshapes(1:numSG))
      allocate(Reshapes(1:numSG))
      allocate(TempDerivReshape(1:numSG))
      allocate(TempReshape(1:numSG))
     Call reshape_ajaa_t1OS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibrowOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = matmul4(K1TwoInts(1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
        TempDerivReshape(p)%ReshapedMatrix = matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(1,2)%aa%irrep(p)%block)
      end do
      do p=1,numSG
        temp = matmul4(TempReshape(p)%ReshapedMatrix,TempDerivReshape(p)%ReshapedMatrix)
        energy = energy + temp(1,1)
      end do
      Call reshape_ajaa_t1_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
      Call reshape_t1_ibrow_inverseOS(numSG,ProductTable,TempDerivReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)

      deallocate(DerivReshapes)
      deallocate(Reshapes)
      deallocate(TempDerivReshape)
      deallocate(TempReshape)

      allocate(DerivReshapes(1:numSG))
      allocate(Reshapes(1:numSG))
      allocate(TempDerivReshape(1:numSG))
      allocate(TempReshape(1:numSG))
     Call reshape_ajbb_t1OS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibrowOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
      do p=1,numSG
        DerivReshapes(p)%ReshapedMatrix = matmul4(K1TwoInts(1,2)%bb%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
        TempDerivReshape(p)%ReshapedMatrix = matmul4(Reshapes(p)%ReshapedMatrix,K1TwoInts(1,2)%bb%irrep(p)%block)
      end do
      do p=1,numSG
        temp = matmul4(TempReshape(p)%ReshapedMatrix,TempDerivReshape(p)%ReshapedMatrix)
        energy = energy + temp(1,1)
      end do
      Call reshape_ajbb_t1_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt)
      Call reshape_t1_ibrow_inverseOS(numSG,ProductTable,TempDerivReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)

      deallocate(DerivReshapes)
      deallocate(Reshapes)
      deallocate(TempDerivReshape)
      deallocate(TempReshape)




     allocate(DerivReshapes(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     allocate(TempReshape(1:numSG))
     Call reshape_t1_ibrow_alphaonlyOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibcol_alphaonlyOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
         p=1
         TempDerivReshape(p)%ReshapedMatrix = -1*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,2,1,2)%aa%irrep(p)%block)
         DerivReshapes(p)%ReshapedMatrix = -1*matmul4(K2(1,2,1,2)%aa%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
         do q=1,ReshapedMatrixDim%ajaa(1)%col
             energy = energy + DerivReshapes(1)%ReshapedMatrix(q,1)*Reshapes(1)%ReshapedMatrix(1,q)
         end do
       Call reshape_t1_ibrow_alphaonly_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
       Call reshape_t1_ibcol_alphaonly_inverseOS(numSG,ProductTable,TempDerivReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
      deallocate(DerivReshapes)
      deallocate(Reshapes)
      deallocate(TempDerivReshape)
      deallocate(TempReshape)

     allocate(DerivReshapes(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     allocate(TempReshape(1:numSG))
     Call reshape_t1_ibrow_betaonlyOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibcol_betaonlyOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
         p=1
         TempDerivReshape(p)%ReshapedMatrix = -1*matmul4(Reshapes(p)%ReshapedMatrix,K2(1,2,1,2)%bb%irrep(p)%block)
         DerivReshapes(p)%ReshapedMatrix = -1*matmul4(K2(1,2,1,2)%bb%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
         do q=1,ReshapedMatrixDim%ajbb(1)%col
             energy = energy + DerivReshapes(1)%ReshapedMatrix(q,1)*Reshapes(1)%ReshapedMatrix(1,q)
         end do
       Call reshape_t1_ibrow_betaonly_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
       Call reshape_t1_ibcol_betaonly_inverseOS(numSG,ProductTable,TempDerivReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
      deallocate(DerivReshapes)
      deallocate(Reshapes)
      deallocate(TempDerivReshape)
      deallocate(TempReshape)

     allocate(DerivReshapes(1:numSG))
     allocate(Reshapes(1:numSG))
     allocate(TempDerivReshape(1:numSG))
     allocate(TempReshape(1:numSG))
     Call reshape_t1_ibrow_alphaonlyOS(numSG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,DerivReshapes)
     Call reshape_t1_ibcol_betaonlyOS(numSG,ProductTable,TempReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1data,ReshapedMatrixDim,InvPdt,TempDerivReshape)
         p = 1
         TempDerivReshape(p)%ReshapedMatrix = 2*matmul4(Reshapes(p)%ReshapedMatrix,K2(2,1,1,2)%ab%irrep(p)%block)
         DerivReshapes(p)%ReshapedMatrix = 2*matmul4(K2(2,1,1,2)%ab%irrep(p)%block,TempReshape(p)%ReshapedMatrix)
         do q=1,ReshapedMatrixDim%ajaa(1)%col
             energy = energy + DerivReshapes(1)%ReshapedMatrix(q,1)*Reshapes(1)%ReshapedMatrix(1,q)
         end do

       Call reshape_t1_ibrow_alphaonly_inverseOS(numSG,ProductTable,DerivReshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)
       Call reshape_t1_ibcol_betaonly_inverseOS(numSG,ProductTable,TempDerivReshape,occ_alpha,occ_beta,virt_alpha,virt_beta,T1deriv,ReshapedMatrixDim,InvPdt)

       deallocate(Reshapes)
       deallocate(DerivReshapes)



     call cpu_time(time_total_end)
     time_calcderiv = time_calcderiv + time_total_end - time_total_begin
      end subroutine CalcDerivBlockK2OS

!> @brief Runs the energy optimization calculation for a closed shell calculation
!> @author Christine Schwerdtfeger and David Mazziotti
      subroutine SinglePoint(N,h,SG,ProductTable,occ,virt,T2data,T2deriv,Newc,DerivNewc,T1data,T1deriv,ReshapedMatrixDim,InvPdt,OneInts,TwoIntsCompact,SymV,SymO,energy,topfac,topsingles,numElements,inputfile,numrowblocks,EPS)

      Use InterfaceMod
      USE TypeMod
      Use TimeMod, only : time_singlepoint
      Implicit NONE
      integer :: h
      integer :: N
      integer :: SG
      integer, allocatable, dimension(:,:) :: ProductTable
      integer, allocatable, dimension(:,:) :: occ,virt
      type(T2) :: T2data,T2deriv
      type(T2) :: Newc, DerivNewc
      type(T1) :: T1data,T1deriv
      integer :: numrowblocks
      type(ReshapedDim) :: ReshapedMatrixDim
      type(symmetry), allocatable, dimension(:) :: InvPdt
      real(8), allocatable, dimension(:,:) :: OneInts
      real(8), allocatable, dimension(:) :: TwoIntsCompact
      integer, allocatable, dimension(:) :: SymV, SymO
      double precision :: energy
      real(8), dimension(0:2,0:2) :: topfac
      real(8), dimension(0:1,0:1) :: topsingles
      integer :: numElements
      character(len=100) :: inputfile
      double precision :: EPS


      type(spin) :: K2(1:2,1:2,1:2,1:2)
      type(spin) :: K1(1:2,1:2)
      type(spin) :: K1TwoInts(1:2,1:2)
      real(8), allocatable, dimension(:,:,:,:) :: TwoInts
      real(8), allocatable, dimension(:) :: DerivVector, Tvector
      double precision :: energyconstants
      integer :: iter,p,M
      integer :: IPRINT(1:2), SPFLAG
      double precision, allocatable, dimension(:) :: W
      double precision ::  XTOL
      double precision, allocatable, dimension(:) :: DIAG
      real :: time_begin, time_end, begin_loop,end_loop
      integer :: begin_wall, end_wall, interval
      logical :: DIAGCO = .false.
      character(len=100) :: K2files

       type(BlockMatMulDims) :: BlockDim
       integer :: i_begin,i_end, b_begin,b_end,iindex,bindex,a,symtop,bsym,isym,t,j

      Call cpu_time(time_begin)
       if(numrowblocks.eq.1) then
         Call BuildK2K1(occ,virt,SG,InvPdt,TwoIntsCompact,OneInts,ReshapedMatrixDim,K2,K1,ProductTable,K1TwoInts,N,h,TwoInts)
       else
         Call BuildK2K1BlockK2(occ,virt,SG,InvPdt,TwoIntsCompact,OneInts,ReshapedMatrixDim,K2,K1,ProductTable,K1TwoInts,N,h,TwoInts,numrowblocks,BlockDim,inputfile)
       end if

        IPRINT(1) = -1
        IPRINT(2) = 0
        SPFLAG=0
        XTOL = epsilon(1.0D0)
        M = 5
        allocate(DIAG(1:numElements))
        allocate(W(numElements*(2*M+1)+2*M))
        allocate(Tvector(1:numElements))
        allocate(DerivVector(1:numElements))
        Tvector(1:numElements) = 0.0D0
        DerivVector(1:numElements) = 0.0D0
        DIAG(1:numElements) = 1.0D0
        energy = 0.0D0
        energyconstants = 0.0D0
        Call DataStructure(T2data,N,h,InvPdt,SG,occ,virt,ProductTable,SymO,SymV,T2deriv,1,numElements,T1data,T1deriv,Newc,DerivNewc,inputfile)
        if(numrowblocks.eq.1) then
          Call CalcDeriv(T2data,K2,K1,SG,ProductTable,N,h,occ,virt,ReshapedMatrixDim,InvPdt,T2deriv,energy,K1TwoInts,T1data,T1deriv,Newc,DerivNewc,topfac,TwoInts,topsingles)
        else
          Call CalcDerivBlockK2(T2data,K2,K1,SG,ProductTable,N,h,occ,virt,ReshapedMatrixDim,InvPdt,T2deriv, energy,K1TwoInts,T1data,T1deriv,Newc,DerivNewc,topfac,TwoInts,topsingles,numrowblocks,inputfile,BlockDim)
        end if

        Call AveDeriv(N,h,InvPdt,SG,occ,virt,ProductTable,SymO,SymV,T2deriv)
        Call CalcEnergy(T2data,SG,T2deriv,energyconstants,K2,InvPdt,ReshapedMatrixDim,occ,virt,K1)
        energy = energy + energyconstants
        Call CalcParameters(SG,occ,virt,T2data,InvPdt,T2deriv,DerivVector,Tvector,T1data,T1deriv)
        iter = 0
        do
          iter = iter + 1
          Call LBFGS(numElements,M,Tvector,energy,DerivVector,DIAGCO,DIAG,IPRINT,EPS,XTOL,W,SPFLAG)
          Call CalcParametersInverse(SG,occ,virt,T2data,InvPdt,Tvector,T1data)
          if(SPFLAG==1) then
           energy = 0.0D0
           Call DataStructure(T2data,N,h,InvPdt,SG,occ,virt,ProductTable,SymO,SymV,T2deriv,1,numElements,T1data,T1deriv,Newc,DerivNewc,inputfile)
           if(numrowblocks.eq.1) then
             Call CalcDeriv(T2data,K2,K1,SG,ProductTable,N,h,occ,virt,ReshapedMatrixDim,InvPdt,T2deriv,energy,K1TwoInts,T1data,T1deriv,Newc,DerivNewc,topfac,TwoInts,topsingles)
           else
             Call CalcDerivBlockK2(T2data,K2,K1,SG,ProductTable,N,h,occ,virt,ReshapedMatrixDim,InvPdt,T2deriv, energy,K1TwoInts,T1data,T1deriv,Newc,DerivNewc,topfac,TwoInts,topsingles,numrowblocks,inputfile,BlockDim)
           end if

           Call AveDeriv(N,h,InvPdt,SG,occ,virt,ProductTable,SymO,SymV,T2deriv)
           energy = energy + energyconstants
           1500 format(1X,'Iteration and Electronic Energy:',1X,I5,1X,F30.14)
           write(*,1500) iter,energy
           Call CalcParameters(SG,occ,virt,T2data,InvPdt,T2deriv,DerivVector,Tvector,T1data,T1deriv)
          end if
          if(SPFLAG==-1) then
            write(*,*) '***********  ERROR   **********'
            write(*,*) 'P2RDM CALCULATION DID NOT CONVERGE.'
            write(*,*) 'EXITING . . . '
            stop
          end if
          if(SPFLAG==0) then
          energy = energy - energyconstants
          write(*,*) '  '
          write(*,*) 'P2RDM ELECTRONIC ENERGY CONVERGED.'


          deallocate(OneInts)
          deallocate(TwoInts)
          deallocate(DIAG)
          deallocate(W)
          deallocate(Tvector)
          deallocate(DerivVector)
         deallocate(K2(1,1,1,1)%aa%irrep)
         if(numrowblocks.eq.1) then
           deallocate(K2(2,2,2,2)%aa%irrep)
           deallocate(K2(2,2,2,2)%ab%irrep)
         end if
         deallocate(K2(1,2,1,2)%aa%irrep)
         deallocate(K2(1,1,2,2)%aa%irrep)
         deallocate(K2(1,1,1,1)%ab%irrep)
         deallocate(K2(1,2,1,2)%ab%irrep)
         deallocate(K2(1,1,2,2)%ab%irrep)
         deallocate(K2(1,2,2,1)%ab%irrep)
         deallocate(K2(1,1,1,2)%aa%irrep)
         deallocate(K2(2,2,1,2)%aa%irrep)
         deallocate(K2(1,1,1,2)%ab%irrep)
         deallocate(K2(1,1,2,1)%ab%irrep)
         deallocate(K2(2,2,1,2)%ab%irrep)
         deallocate(K2(2,2,2,1)%ab%irrep)
         deallocate(K1(1,1)%aa%irrep)
         deallocate(K1(2,2)%aa%irrep)
         deallocate(K1(1,2)%aa%irrep)
         deallocate(K1TwoInts(1,1)%aa%irrep)
         deallocate(K1TwoInts(2,2)%aa%irrep)
         deallocate(K1TwoInts(1,2)%aa%irrep)
         if(numrowblocks.gt.1) then
           K2files = 'rm ' // trim(inputfile) // 'aa*'
           Call system(K2files)
           K2files = 'rm ' // trim(inputfile) // 'ab*'
           Call system(K2files)
           deallocate(BlockDim%aa%symgp)
           deallocate(BlockDim%ab%symgp)
         end if
          Call cpu_time(time_end)
          time_singlepoint = time_end - time_begin + time_singlepoint
          return
          end if
        end do

       end subroutine SinglePoint

       subroutine reshape_ajaa_transposederiv_inverseOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_ajaa
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: a,j,c,k
       integer :: row,col,c_begin,c_end,k_begin,k_end,t,v
       integer, dimension(1:SG) :: maxcol_SG
       real :: time_begin,time_end
       Call CPU_TIME(time_begin)

       do p=1,SG
         maxcol_SG(p) = 0
       end do

     row = 1
       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           c_begin = virt_alpha(1,p)
           c_end   = virt_alpha(2,p)
           k_begin = occ_alpha(1,q)
           k_end   = occ_alpha(2,q)
           do k=k_begin,k_end
             do c=c_begin,c_end
               col = col + 1
               row = 1
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 a_begin = virt_alpha(1,r)
                 a_end   = virt_alpha(2,r)
                 j_begin = occ_alpha(1,s)
                 j_end   = occ_alpha(2,s)
                 do j=j_begin,j_end
                   do a=a_begin,a_end
                     T2deriv%aa%m(a,j)%nsym(p,q)%n(c,k) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%aa%m(a,j)%nsym(p,q)%n(c,k)
                    row = row + 1
                    maxcol_SG(symgp) = col
                  end do
                end do
              end do
            end do
          end do
        end do
      end do

       do symgp=1,SG
         col = maxcol_SG(symgp)
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 col = col + 1
                 row = 1
                 do v=1,SG
                   r = InvPdt(symgp)%upper(v)
                   s = InvPdt(symgp)%lower(v)
                   c_begin = virt_alpha(1,r)
                   c_end   = virt_alpha(2,r)
                   k_begin = occ_alpha(1,s)
                   k_end   = occ_alpha(2,s)
                   do k=k_begin,k_end
                     do c=c_begin,c_end
                       T2deriv%ab%m(c,k)%nsym(p,q)%n(a,j) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(c,k)%nsym(p,q)%n(a,j)
                       row = row + 1
                      end do
                    end do
                  end do
                end do
              end do
            end do
          end do
          Call CPU_TIME(time_end)
          time_ajaa = time_end - time_begin + time_ajaa

      end subroutine reshape_ajaa_transposederiv_inverseOS

       subroutine reshape_ajbb_transposederiv_inverseOS(SG,ProductTable,Reshapes,occ_alpha,occ_beta,virt_alpha,virt_beta,T2deriv,ReshapedMatrixDim,InvPdt,DerivReshapes)
       USE TypeMod;
       Use TimeMod, only : time_ajaa
       Implicit None
       integer, intent(IN) :: SG
       integer, intent(IN),  dimension(1:2,1:SG) :: occ_alpha,occ_beta,virt_alpha,virt_beta
       integer, dimension(1:SG,1:SG) :: ProductTable
       type(ReshapedMat),intent(INOUT) :: Reshapes(1:SG), DerivReshapes(1:SG)
       type(T2) :: T2deriv
       type(ReshapedDim), intent(IN) :: ReshapedMatrixDim
       type(symmetry), intent(IN), dimension(:) :: InvPdt(1:SG)


       integer :: symgp,p,q,r,s,numa,numj,a_begin,a_end,j_begin,j_end
       integer, dimension(1:SG) :: total_SG_row,total_SG_col
       integer :: a,j,c,k
       integer :: row,col,c_begin,c_end,k_begin,k_end,t,v
       integer, dimension(1:SG) :: maxrow_SG
       real :: time_begin,time_end

       Call CPU_TIME(time_begin)
      do p=1,SG
        maxrow_SG(p) = 0
      end do


     row = 1
       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
           do j=j_begin,j_end
             do a=a_begin,a_end
               col = col + 1
               row = 1
               do v=1,SG
                 r = InvPdt(symgp)%upper(v)
                 s = InvPdt(symgp)%lower(v)
                 c_begin = virt_alpha(1,r)
                 c_end   = virt_alpha(2,r)
                 k_begin = occ_alpha(1,s)
                 k_end   = occ_alpha(2,s)
                 do k=k_begin,k_end
                   do c=c_begin,c_end
                     T2deriv%ab%m(c,k)%nsym(p,q)%n(a,j) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%ab%m(c,k)%nsym(p,q)%n(a,j)
                    maxrow_SG(symgp) = row
                    row = row + 1
                  end do
                end do
              end do
            end do
          end do
        end do
      end do
       do symgp=1,SG
         col = 0
         do t=1,SG
           p = InvPdt(symgp)%upper(t)
           q = InvPdt(symgp)%lower(t)
           a_begin = virt_beta(1,p)
           a_end   = virt_beta(2,p)
           j_begin = occ_beta(1,q)
           j_end   = occ_beta(2,q)
             do j=j_begin,j_end
               do a=a_begin,a_end
                 col = col + 1
                 row = maxrow_SG(symgp) + 1
                 do v=1,SG
                   r = InvPdt(symgp)%upper(v)
                   s = InvPdt(symgp)%lower(v)
                   c_begin = virt_beta(1,r)
                   c_end   = virt_beta(2,r)
                   k_begin = occ_beta(1,s)
                   k_end   = occ_beta(2,s)
                   do k=k_begin,k_end
                     do c=c_begin,c_end
                      T2deriv%bb%m(c,k)%nsym(p,q)%n(a,j) = DerivReshapes(symgp)%ReshapedMatrix(row,col) + T2deriv%bb%m(c,k)%nsym(p,q)%n(a,j)
                       row = row + 1
                      end do
                    end do
                  end do
                end do
              end do
            end do
          end do

          Call CPU_TIME(time_end)
          time_ajaa = time_end - time_begin + time_ajaa


      end subroutine reshape_ajbb_transposederiv_inverseOS

!> @brief Reads the one and two electrons integrals from binary files
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine ReadGamess_BinaryGAMESSFMT(inputfile,PointGroup,Convert_char,numSG,occ,virt,OneInts,TwoIntsCompact,SymO,SymV,numocc,numvirt,frozencore,nuclearrep,NewIndex,scrpath,SymChar,labsiz,nwdvar)


       Use InterfaceMod
       Use TimeMod, only : time_readgamess
       Implicit NONE
       character(len=50) :: gamessoutput
       character(len=100) :: inputfile
       character(len=3) :: PointGroup
       integer :: numSG
       character(len=3), dimension(:) :: Convert_char(1:numSG)
       real(8) :: frozencore,nuclearrep
       integer, allocatable, dimension(:,:) :: occ
       integer, allocatable, dimension(:,:) :: virt
       real(8), intent(OUT), allocatable, dimension(:,:) :: OneInts
       real(8), allocatable, dimension(:) :: TwoIntsCompact
       integer, intent(OUT), allocatable, dimension(:) :: SymV,SymO
       integer :: numocc, numvirt
       real(8) :: integralOne
       character(len=100) :: scrpath,binaryfile
       character(len=3) :: SymChar(1:numocc+numvirt)
       integer :: labsiz, nwdvar


       integer :: ioerror,filenumber
       character(len=123) :: readstring
       integer :: SymInt(1:numocc+numvirt)
       integer :: numact, counter=1,offset
       integer :: numalphaact,numbetaact
       integer :: i,j,symgp,orbcount,k,l,m,p, n32
       integer*8 :: n
       integer, allocatable, dimension(:) :: OldIndex,NewIndex
       real(8) :: integral
       integer*8 :: ij,kl,ijkl
       integer*8 :: index1,index2,compindex1
       real :: time_begin, time_end
       integer :: numbytes
       integer*8, allocatable, dimension(:) :: IntegerArray
       real(8), allocatable, dimension(:) :: IntegralArray
       integer*8, allocatable, dimension(:) :: CompositeIndexArray
       integer :: LABEL1, LABEL2
       integer, allocatable, dimension(:) :: IntegerArray32
       real(8), allocatable, dimension(:) :: one_ei_array

       Call CPU_TIME(time_begin)
       integral = 0.0D0
       filenumber = 1

       Call getenv("MOINTS",binaryfile)

       10 format (A10)
       20 format (A)
       30 format (A24)
       40 format (A31)
       50 format (A19)

       numact = numocc + numvirt
       do i=1,numact
          do j=1,numSG
            if(SymChar(i).eq.Convert_char(j)) then
               SymInt(i) = j
            end if
          end do
      end do


       allocate(occ(1:2,1:numSG))
       allocate(virt(1:2,1:numSG))
       offset = 0
       do symgp=1,numSG
         orbcount = 0
         do j=1,numocc
           if(SymInt(j).eq.symgp) then
             orbcount = orbcount + 1
           end if
         end do
         if(orbcount.eq.0) then
           occ(1,symgp) = 0
           occ(2,symgp) = -1
          else
           occ(1,symgp) = offset + 1
           occ(2,symgp) = offset + orbcount
        end if
         offset = offset + orbcount
       end do

       offset = numocc
       do symgp=1,numSG
         orbcount = 0
         do j=numocc+1,numact
           if(SymInt(j).eq.symgp) then
             orbcount = orbcount + 1
           end if
         end do
         if(orbcount.eq.0) then
           virt(1,symgp) = 0
           virt(2,symgp) = -1
        else
         virt(1,symgp) = offset + 1
         virt(2,symgp) = offset + orbcount
        end if
         offset = offset + orbcount
      end do

       allocate(OldIndex(1:numact))
       allocate(NewIndex(1:numact))
       allocate(SymO(1:numocc))
       allocate(SymV(numocc+1:numact))
       counter = 1
       do symgp=1,numSG
         do i=1,numocc
           if(SymInt(i).eq.symgp) then
             OldIndex(counter) = i
             NewIndex(i) = counter
             SymO(counter) = SymInt(i)
             counter = counter + 1
          end if
        end do
      end do
      do symgp=1,numSG
        do i=numocc+1,numact
          if(SymInt(i).eq.symgp) then
            OldIndex(counter) = i
            NewIndex(i) = counter
            SymV(counter) = SymInt(i)
            counter = counter + 1
          end if
        end do
      end do

if(NWDVAR.eq.1) then
       allocate(OneInts(1:numact,1:numact))
       OneInts(1:numact,1:numact) = 0.0D0
       allocate(one_ei_array(1:numact*(numact+1)/2))
       one_ei_array(1:numact*(numact+1)/2) = 0.d0
       i=1
       j=1
       read(9,iostat=ioerror) one_ei_array
       do counter=1,numact*(numact+1)/2
         OneInts(NewIndex(i),NewIndex(j)) = one_ei_array(counter)
         OneInts(NewIndex(j),NewIndex(i)) = one_ei_array(counter)
         if(j<i) then
           j=j+1
         else
           i=i+1
           j=1
         end if
       end do
       deallocate(one_ei_array)
      allocate(TwoIntsCompact(1:numact*(numact+1)/2*(numact*(numact+1)/2+1)/2))
      TwoIntsCompact(1:numact*(numact+1)/2*(numact*(numact+1)/2+1)/2) = 0.0

      if(LABSIZ.eq.1) then
        allocate(IntegerArray(1:7500))
        allocate(IntegralArray(1:15000))
        allocate(CompositeIndexArray(1:15000))
      else
        allocate(IntegerArray(1:15000))
        allocate(IntegralArray(1:15000))
        allocate(CompositeIndexArray(1:15000))
      end if

      if(LABSIZ.eq.2) then
        do
          read(9,iostat=ioerror) n, IntegerArray, IntegralArray
          do m=1,abs(n)
            i = ISHFT(IntegerArray(m),-48)
            j = IAND(ISHFT(IntegerArray(m),-32),65535)
            k = IAND(ISHFT(IntegerArray(m),-16),65535)
            l = IAND(IntegerArray(m),65535)
            i = NewIndex(i)
            j = NewIndex(j)
            k = NewIndex(k)
            l = NewIndex(l)
            ij = FirstIndex(i,j)
            kl = FirstIndex(k,l)
            ijkl = CompositeIndex(ij,kl)
            CompositeIndexArray(m) = ijkl
          end do
          do m=1,abs(n)
            TwoIntsCompact(CompositeIndexArray(m)) = IntegralArray(m)
          end do
          if(n.le.0) then
            exit
          end if
       end do
      end if
      18 format(f18.14)


      if(LABSIZ.eq.1) then
      do
        counter = 1
        read(9,iostat=ioerror) n, IntegerArray, IntegralArray
        do m=1,abs(n/2)
          i = ISHFT(IntegerArray(m), -56 )
          j = IAND(ISHFT( IntegerArray(m), -48 ), 255 )
          k = IAND(ISHFT( IntegerArray(m), -40 ), 255 )
          l = IAND(ISHFT( IntegerArray(m), -32 ), 255 )
          i = NewIndex(i)
          j = NewIndex(j)
          k = NewIndex(k)
          l = NewIndex(l)
          ij = FirstIndex(i,j)
          kl = FirstIndex(k,l)
          ijkl = CompositeIndex(ij,kl)
          CompositeIndexArray(counter) = ijkl
          counter = counter + 1
          i = IAND(ISHFT(IntegerArray(m), -24 ), 255 )
          j = IAND(ISHFT(IntegerArray(m), -16 ), 255 )
          k = IAND( ISHFT(IntegerArray(m),  -8 ), 255 )
          l = IAND(IntegerArray(m), 255 )
          i = NewIndex(i)
          j = NewIndex(j)
          k = NewIndex(k)
          l = NewIndex(l)
          ij = FirstIndex(i,j)
          kl = FirstIndex(k,l)
          ijkl = CompositeIndex(ij,kl)
          CompositeIndexArray(counter) = ijkl
          counter = counter + 1
        end do
        if(abs(mod(n,2)).ne.0) then
          i = ISHFT(IntegerArray(m), -56 )
          j = IAND(ISHFT( IntegerArray(m), -48 ), 255 )
          k = IAND(ISHFT( IntegerArray(m), -40 ), 255 )
          l = IAND(ISHFT( IntegerArray(m), -32 ), 255 )
          i = NewIndex(i)
          j = NewIndex(j)
          k = NewIndex(k)
          l = NewIndex(l)
          ij = FirstIndex(i,j)
          kl = FirstIndex(k,l)
          ijkl = CompositeIndex(ij,kl)
          CompositeIndexArray(counter) = ijkl
        end if
        do m=1,abs(n)
          TwoIntsCompact(CompositeIndexArray(m)) = IntegralArray(m)
        end do
        if(n.le.0) then
          exit
        end if
      end do
    end if
end if


if(NWDVAR.eq.2) then

       allocate(OneInts(1:numact,1:numact))
       OneInts(1:numact,1:numact) = 0.0D0

       i=1
       j=1
       allocate(one_ei_array(1:numact*(numact+1)/2))
       one_ei_array(1:numact*(numact+1)/2) = 0.D0

       read(9,iostat=ioerror) one_ei_array

       do counter=1,numact*(numact+1)/2
         OneInts(NewIndex(i),NewIndex(j)) = one_ei_array(counter)
         OneInts(NewIndex(j),NewIndex(i)) = one_ei_array(counter)
         if(j<i) then
           j=j+1
         else
           i=i+1
           j=1
         end if
       end do
       deallocate(one_ei_array)

      allocate(TwoIntsCompact(1:numact*(numact+1)/2*(numact*(numact+1)/2+1)/2))
      TwoIntsCompact(1:numact*(numact+1)/2*(numact*(numact+1)/2+1)/2) = 0.0
      allocate(IntegerArray32(1:15000))
      allocate(IntegralArray(1:15000))
      allocate(CompositeIndexArray(1:15000))
      if(LABSIZ.eq.1) then
        do
          read(9,iostat=ioerror) n32, IntegerArray32, IntegralArray
          do m=1,abs(n32)
            i = ISHFT( IntegerArray32(m), -24)
            j = IAND( ISHFT(IntegerArray32(m),-16), 255)
            k = IAND( ISHFT(IntegerArray32(m),-8 ), 255)
            l = IAND( IntegerArray32(m), 255)
            i = NewIndex(i)
            j = NewIndex(j)
            k = NewIndex(k)
            l = NewIndex(l)
            ij = FirstIndex(i,j)
            kl = FirstIndex(k,l)
            ijkl = CompositeIndex(ij,kl)
            CompositeIndexArray(m) = ijkl
          end do
          do m=1,abs(n32)
            TwoIntsCompact(CompositeIndexArray(m)) = IntegralArray(m)
          end do
          if(n32.le.0) then
            exit
          end if
        end do
      end if

      if(LABSIZ.eq.2) then
        do
          read(9,iostat=ioerror) n32, IntegerArray32, IntegralArray
          do m=1,abs(n32)
            LABEL1 = IntegerArray32(2*m-1)
            LABEL2 = IntegerArray32(2*m)
            i = ISHFT( LABEL1 , -16)
            j = IAND( LABEL1 ,65535)
            k = ISHFT( LABEL2 ,16)
            l = IAND( LABEL2  ,65535)
            i = NewIndex(i)
            j = NewIndex(j)
            k = NewIndex(k)
            l = NewIndex(l)
            ij = FirstIndex(i,j)
            kl = FirstIndex(k,l)
            ijkl = CompositeIndex(ij,kl)
            CompositeIndexArray(m) = ijkl
          end do
          do m=1,abs(n32)
            TwoIntsCompact(CompositeIndexArray(m)) = IntegralArray(m)
          end do
          if(n32.le.0) then
            exit
          end if
        end do
      end if

end if




       close(9)

       Call CPU_TIME(time_end)
       time_readgamess = time_readgamess + time_end - time_begin
       end subroutine ReadGamess_BinaryGAMESSFMT

!> @brief Read the integrals from binary files for open shell calculations
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine ReadGamess_BinaryGAMESSFMTOS(PointGroup,Convert_char,numSG,occ_alpha,occ_beta,virt_alpha,virt_beta,OneInts,TwoIntsCompact,Sym_alpha,Sym_beta,numocc_alpha,numocc_beta,numvirt_alpha, numvirt_beta,frozencore,nuclearrep,NewIndex_alpha, NewIndex_beta,scrpath,OldIndex_alpha, OldIndex_beta,SymChar,labsiz,nwdvar)

       Use InterfaceMod
       Use TimeMod, only : time_readgamess
       Implicit NONE
       character(len=50) :: gamessoutput
       character(len=100) :: inputfile
       character(len=3) :: PointGroup
       integer :: numSG
       character(len=3), dimension(:) :: Convert_char(1:numSG)
       real(8) :: frozencore,nuclearrep
       integer, allocatable, dimension(:,:) :: occ_alpha, occ_beta
       integer, allocatable, dimension(:,:) :: virt_alpha, virt_beta
       real(8), intent(OUT), allocatable, dimension(:,:) :: OneInts
       real(8), allocatable, dimension(:) :: TwoIntsCompact
       integer, intent(OUT), allocatable, dimension(:) :: Sym_alpha,Sym_beta
       integer :: numocc_alpha, numvirt_alpha, numocc_beta, numvirt_beta
       real(8) :: integralOne
       character(len=100) :: scrpath,binaryfile
       integer, allocatable, dimension(:) :: OldIndex_alpha, OldIndex_beta,NewIndex_alpha, NewIndex_beta
       character(len=3) :: SymChar(1:numocc_alpha+numvirt_alpha)
       integer :: labsiz, nwdvar


       integer :: ioerror,filenumber
       character(len=123) :: readstring
       integer :: SymInt(1:numocc_alpha+numvirt_alpha)
       integer :: numact, counter=1,offset
       integer :: i,j,symgp,orbcount,k,l,m,p, n32
       integer*8 :: n
       real(8) :: integral
       integer*8 :: ij,kl,ijkl
       integer*8 :: index1,index2,compindex1
       real :: time_begin, time_end
       integer*8, allocatable, dimension(:) :: IntegerArray
       real(8), allocatable, dimension(:) :: IntegralArray
       integer*8, allocatable, dimension(:) :: CompositeIndexArray
       integer :: LABEL1, LABEL2
       integer, allocatable, dimension(:) :: IntegerArray32
       integer :: numbytes
       character(len=100) :: symfile
       real(8), allocatable, dimension(:) :: one_ei_array


       Call CPU_TIME(time_begin)

       integral = 0.0D0
       filenumber = 1
       inputfile = ' '
       Call getenv("MOINTS",binaryfile)

       10 format (A10)
       20 format (A)
       30 format (A24)
       40 format (A31)
       50 format (A19)

       numact = numocc_alpha + numvirt_alpha
       do i=1,numocc_alpha+numvirt_alpha
          do j=1,numSG
            if(SymChar(i).eq.Convert_char(j)) then
               SymInt(i) = j
            end if
          end do
       end do

       allocate(occ_alpha(1:2,1:numSG))
       allocate(virt_alpha(1:2,1:numSG))
       allocate(occ_beta(1:2,1:numSG))
       allocate(virt_beta(1:2,1:numSG))
       offset = 0
       do symgp=1,numSG
         orbcount = 0
         do j=1,numocc_alpha
           if(SymInt(j).eq.symgp) then
             orbcount = orbcount + 1
           end if
         end do
         if(orbcount.eq.0) then
           occ_alpha(1,symgp) = 0
           occ_alpha(2,symgp) = -1
          else
           occ_alpha(1,symgp) = offset + 1
           occ_alpha(2,symgp) = offset + orbcount
        end if
         offset = offset + orbcount
       end do
       offset = numocc_alpha
       do symgp=1,numSG
         orbcount = 0
         do j=numocc_alpha+1,numact
           if(SymInt(j).eq.symgp) then
             orbcount = orbcount + 1
           end if
         end do
         if(orbcount.eq.0) then
           virt_alpha(1,symgp) = 0
           virt_alpha(2,symgp) = -1
        else
         virt_alpha(1,symgp) = offset + 1
         virt_alpha(2,symgp) = offset + orbcount
        end if
         offset = offset + orbcount
      end do

       offset = 0
       do symgp=1,numSG
         orbcount = 0
         do j=1,numocc_beta
           if(SymInt(j).eq.symgp) then
             orbcount = orbcount + 1
           end if
         end do
         if(orbcount.eq.0) then
           occ_beta(1,symgp) = 0
           occ_beta(2,symgp) = -1
          else
           occ_beta(1,symgp) = offset + 1
           occ_beta(2,symgp) = offset + orbcount
        end if
         offset = offset + orbcount
       end do

       offset = numocc_beta
       do symgp=1,numSG
         orbcount = 0
         do j=numocc_beta+1,numact
           if(SymInt(j).eq.symgp) then
             orbcount = orbcount + 1
           end if
         end do
         if(orbcount.eq.0) then
           virt_beta(1,symgp) = 0
           virt_beta(2,symgp) = -1
        else
         virt_beta(1,symgp) = offset + 1
         virt_beta(2,symgp) = offset + orbcount
        end if
         offset = offset + orbcount
      end do




       allocate(OldIndex_alpha(1:numact))
       allocate(NewIndex_alpha(1:numact))
       allocate(OldIndex_beta(1:numact))
       allocate(NewIndex_beta(1:numact))
       allocate(Sym_alpha(1:numact))
       allocate(Sym_beta(1:numact))
       counter = 1
       do symgp=1,numSG
         do i=1,numocc_alpha
           if(SymInt(i).eq.symgp) then
             OldIndex_alpha(counter) = i
             NewIndex_alpha(i) = counter
             Sym_alpha(counter) = SymInt(i)
             counter = counter + 1
          end if
        end do
      end do

      do symgp=1,numSG
        do i=numocc_alpha+1,numact
          if(SymInt(i).eq.symgp) then
            OldIndex_alpha(counter) = i
            NewIndex_alpha(i) = counter
            Sym_alpha(counter) = SymInt(i)
            counter = counter + 1
          end if
        end do
      end do

       counter = 1
       do symgp=1,numSG
         do i=1,numocc_beta
           if(SymInt(i).eq.symgp) then
             OldIndex_beta(counter) = i
             NewIndex_beta(i) = counter
             Sym_beta(counter) = SymInt(i)
             counter = counter + 1
          end if
        end do
      end do

      do symgp=1,numSG
        do i=numocc_beta+1,numact
          if(SymInt(i).eq.symgp) then
            OldIndex_beta(counter) = i
            NewIndex_beta(i) = counter
            Sym_beta(counter) = SymInt(i)
            counter = counter + 1
          end if
        end do
      end do

if(NWDVAR.eq.1) then

      allocate(OneInts(1:numact,1:numact))
      OneInts(1:numact,1:numact) = 0.0D0
      allocate(one_ei_array(1:numact*(numact+1)/2))
      one_ei_array(1:numact*(numact+1)/2) = 0.D0
      i=1
      j=1
      read(9,iostat=ioerror) one_ei_array
      do counter=1,numact*(numact+1)/2
          OneInts(i,j) = one_ei_array(counter)
          OneInts(j,i) = one_ei_array(counter)
          if(j<i) then
            j=j+1
          else
            i=i+1
            j=1
          end if
        end do
     deallocate(one_ei_array)
      allocate(TwoIntsCompact(1:numact*(numact+1)/2*(numact*(numact+1)/2+1)/2))
      TwoIntsCompact(1:numact*(numact+1)/2*(numact*(numact+1)/2+1)/2) = 0.0
      if(LABSIZ.eq.1) then
        allocate(IntegerArray(1:7500))
        allocate(IntegralArray(1:15000))
        allocate(CompositeIndexArray(1:15000))
      else
        allocate(IntegerArray(1:15000))
        allocate(IntegralArray(1:15000))
        allocate(CompositeIndexArray(1:15000))
      end if

      if(LABSIZ.eq.2) then
        do
          read(9,iostat=ioerror) n, IntegerArray, IntegralArray
          do m=1,abs(n)
            i = ISHFT(IntegerArray(m),-48)
            j = IAND(ISHFT(IntegerArray(m),-32),65535)
            k = IAND(ISHFT(IntegerArray(m),-16),65535)
            l = IAND(IntegerArray(m),65535)
            ij = FirstIndex(i,j)
            kl = FirstIndex(k,l)
            ijkl = CompositeIndex(ij,kl)
            CompositeIndexArray(m) = ijkl
          end do
          do m=1,abs(n)
            TwoIntsCompact(CompositeIndexArray(m)) = IntegralArray(m)
          end do
          if(n.le.0) then
            exit
          end if
        end do
      end if
      18 format(f18.14)



      if(LABSIZ.eq.1) then
      do
        read(9,iostat=ioerror) n, IntegerArray, IntegralArray
        counter = 1
        do m=1,abs(n/2)
          i = ISHFT(IntegerArray(m), -56 )
          j = IAND(ISHFT( IntegerArray(m), -48 ), 255 )
          k = IAND(ISHFT( IntegerArray(m), -40 ), 255 )
          l = IAND(ISHFT( IntegerArray(m), -32 ), 255 )
          ij = FirstIndex(i,j)
          kl = FirstIndex(k,l)
          ijkl = CompositeIndex(ij,kl)
          CompositeIndexArray(counter) = ijkl
          counter = counter + 1
          i = IAND(ISHFT(IntegerArray(m), -24 ), 255 )
          j = IAND(ISHFT(IntegerArray(m), -16 ), 255 )
          k = IAND( ISHFT(IntegerArray(m),  -8 ), 255 )
          l = IAND(IntegerArray(m), 255 )
          ij = FirstIndex(i,j)
          kl = FirstIndex(k,l)
          ijkl = CompositeIndex(ij,kl)
          CompositeIndexArray(counter) = ijkl
          counter = counter + 1
        end do
        if(abs(mod(n,2)).ne.0) then
          i = ISHFT(IntegerArray(m), -56 )
          j = IAND(ISHFT( IntegerArray(m), -48 ), 255 )
          k = IAND(ISHFT( IntegerArray(m), -40 ), 255 )
          l = IAND(ISHFT( IntegerArray(m), -32 ), 255 )
          ij = FirstIndex(i,j)
          kl = FirstIndex(k,l)
          ijkl = CompositeIndex(ij,kl)
          CompositeIndexArray(counter) = ijkl
        end if
        do m=1,abs(n)
          TwoIntsCompact(CompositeIndexArray(m)) = IntegralArray(m)
        end do
        if(n.le.0) then
          exit
        end if
      end do
      end if
end if


if(NWDVAR.eq.2) then

      allocate(OneInts(1:numact,1:numact))
      OneInts(1:numact,1:numact) = 0.0D0
      i=1
      j=1
      allocate(one_ei_array(1:numact*(numact+1)/2))
      one_ei_array(1:numact*(numact+1)/2) = 0.D0
      read(9,iostat=ioerror) one_ei_array
      do counter=1,numact*(numact+1)/2
          OneInts(i,j) = one_ei_array(counter)
          OneInts(j,i) = one_ei_array(counter)
          if(j<i) then
            j=j+1
          else
            i=i+1
            j=1
          end if
        end do
      deallocate(one_ei_array)

      allocate(TwoIntsCompact(1:numact*(numact+1)/2*(numact*(numact+1)/2+1)/2))
      TwoIntsCompact(1:numact*(numact+1)/2*(numact*(numact+1)/2+1)/2) = 0.0
      allocate(IntegerArray32(1:15000))
      allocate(IntegralArray(1:15000))
      allocate(CompositeIndexArray(1:15000))
      if(LABSIZ.eq.1) then
        do
          read(9,iostat=ioerror) n32, IntegerArray32, IntegralArray
          do m=1,abs(n32)
            i = ISHFT( IntegerArray32(m), -24)
            j = IAND( ISHFT(IntegerArray32(m),-16), 255)
            k = IAND( ISHFT(IntegerArray32(m),-8 ), 255)
            l = IAND( IntegerArray32(m), 255)
            ij = FirstIndex(i,j)
            kl = FirstIndex(k,l)
            ijkl = CompositeIndex(ij,kl)
            CompositeIndexArray(m) = ijkl
          end do
          do m=1,abs(n32)
            TwoIntsCompact(CompositeIndexArray(m)) = IntegralArray(m)
          end do
          if(n32.le.0) then
            exit
          end if
        end do
      end if

      if(LABSIZ.eq.2) then
        do
          read(9,iostat=ioerror) n32, IntegerArray32, IntegralArray
          do m=1,abs(n32)
            LABEL1 = IntegerArray32(2*m-1)
            LABEL2 = IntegerArray32(2*m)
            i = ISHFT( LABEL1 , -16)
            j = IAND( LABEL1 ,65535)
            k = ISHFT( LABEL2 ,16)
            l = IAND( LABEL2  ,65535)
            ij = FirstIndex(i,j)
            kl = FirstIndex(k,l)
            ijkl = CompositeIndex(ij,kl)
            CompositeIndexArray(m) = ijkl
          end do
          do m=1,abs(n32)
            TwoIntsCompact(CompositeIndexArray(m)) = IntegralArray(m)
          end do
          if(n32.le.0) then
            exit
          end if
        end do
      end if


end if




      close(9)
       Call CPU_TIME(time_end)
       time_readgamess = time_readgamess + time_end - time_begin
       end subroutine ReadGamess_BinaryGAMESSFMTOS


!> @brief This routine takes the data from p2rdmstart and starts the p2rdm energy calculation based
!> on the information provided by p2rdmstart.  
!> @author Christine Schwerdtfeger and David Mazziotti
       subroutine P2RDM(RDMparam,PointGroup,nact,nels,mult,energyconverge,paramenergy,SymChar,labsiz,nwdvar,printD1)
       USE TypeMod
       USE InterfaceMod
       Use TimeMod, only : time_total,PrintTime,Time_Initialize
       Implicit NONE
       EXTERNAL LB2

       character(len=100) :: inputfile
       character(len=4) :: RDMparam
       character(len=3) :: PointGroup
       integer :: nact
       integer :: nels, mult
       double precision :: energyconverge
       double precision :: paramenergy
       character(len=3) :: SymChar(1:nact)
       logical :: printD1

       integer :: numocc
       integer :: numvirt
       integer :: numocc_alpha, numocc_beta, numvirt_alpha, numvirt_beta
       integer :: numSG
       integer, allocatable, dimension(:,:) :: ProductTable
       integer, allocatable, dimension(:,:) :: occ,virt
       integer, allocatable, dimension(:,:) :: occ_alpha, occ_beta, virt_alpha, virt_beta
       character(len=3), allocatable, dimension(:) :: Convert_char
       type(T2) :: T2data,T2deriv
       type(T2) :: Newc, DerivNewc
       type(T2) :: T2derivT1topfac
       type(T1) :: T1data,T1deriv
       type(T1) :: Newc_singles, DerivNewc_singles
       type(ReshapedDim) :: ReshapedMatrixDim
       type(symmetry), allocatable, dimension(:) :: InvPdt
       real(8), allocatable, dimension(:,:) :: OneInts
       real(8), allocatable, dimension(:,:,:,:) :: TwoInts
       real(8), allocatable, dimension(:) :: TwoIntsCompact
       integer, allocatable, dimension(:) :: SymV, SymO
       integer, allocatable, dimension(:) :: Sym_alpha, Sym_beta
       real(8), allocatable, dimension(:) :: DerivVector, Tvector
       integer :: numElements
       double precision :: energy, energyconstants
       double precision :: EPS
       real :: time_beginmain, time_endmain
       real(8), dimension(0:2,0:2) :: topfac
       real(8), dimension(0:1,0:1) :: topsingles

       character(len=100) :: scrpath
       real(8) :: frozencore,nuclearrep
       real(8) :: stepsize
       integer, allocatable, dimension(:) :: NewIndex
       integer, allocatable, dimension(:) :: NewIndex_alpha, NewIndex_beta
       integer, allocatable, dimension(:) :: OldIndex_alpha, OldIndex_beta
       real(8) :: PI = 3.1415926535897932
       logical :: diagK2option,calcdqg
       integer :: numrowblocks
       integer :: pairedels, unpairedels
       integer :: labsiz, nwdvar

       diagK2option = .FALSE.
       calcdqg = .FALSE.
       numrowblocks = 1

       Call Time_Initialize()
       Call cpu_time(time_beginmain)
       Call getenv("JBNME",inputfile)

       if(RDMparam.eq.'M') then
        topfac(0,0) = 0
        topfac(1,0) = 0
        topfac(0,1) = 0
        topfac(1,1) = 1
        topfac(2,0) = 1
        topfac(0,2) = 1
        topfac(2,1) = -2
        topfac(1,2) = -2
        topfac(2,2) = 3
        topsingles(0,0) = 0.0
        topsingles(0,1) = 1.0
        topsingles(1,0) = 1.0
        topsingles(1,1) = -1.0
       else if(RDMparam.eq.'K') then
        topfac(0,0) = 0
        topfac(1,0) = 0.5
        topfac(0,1) = 0.5
        topfac(1,1) = -0.25
        topfac(2,0) = 0
        topfac(0,2) = 0
        topfac(2,1) = 0
        topfac(1,2) = 0
        topfac(2,2) = 0
        topsingles(0,0) = 0.0
        topsingles(0,1) = 1.0
        topsingles(1,0) = 1.0
        topsingles(1,1) = -1.0
       else if(RDMparam.eq.'CEPA') then
        topfac(0,0) = 0
        topfac(1,0) = 0
        topfac(0,1) = 0
        topfac(1,1) = 0
        topfac(2,0) = 0
        topfac(0,2) = 0
        topfac(2,1) = 0
        topfac(1,2) = 0
        topfac(2,2) = 0
        topsingles(0,0) = 0.0
        topsingles(0,1) = 0.0
        topsingles(1,0) = 0.0
        topsingles(1,1) = 0.0
      else if(RDMparam.eq.'CISD') then
        topfac(0,0) = 1
        topfac(1,0) = 0
        topfac(0,1) = 0
        topfac(1,1) = 0
        topfac(2,0) = 0
        topfac(0,2) = 0
        topfac(2,1) = 0
        topfac(1,2) = 0
        topfac(2,2) = 0
        topsingles(0,0) = 1.0
        topsingles(0,1) = 0.0
        topsingles(1,0) = 0.0
        topsingles(1,1) = 0.0
        else
          write(*,*) 'Please choose a 2-RDM parameterization.'
          write(*,*) 'Options are: Param = M, K, CISD or CEPA'
        end if


       unpairedels = mult - 1
       pairedels = nels - unpairedels
       numocc_alpha = pairedels/2 + unpairedels
       numocc_beta = pairedels/2
       numvirt_alpha = nact - numocc_alpha
       numvirt_beta = nact - numocc_beta
       mult = abs(numocc_alpha - numocc_beta) + 1
       if(mult.eq.1) then
         numocc = numocc_alpha
         numvirt = numvirt_alpha
       end if
       5050 FORMAT('Multiplicity: ',1X,I2,1X)
       5051 FORMAT('Occupied alpha orbitals: ',1X,I4,2X,'Unoccupied alpha orbitals: ',1X,I4,2X)
       5052 FORMAT('Occupied beta orbitals:  ',1X,I4,2X,'Unoccupied beta orbitals:  ',1X,I4,2X)

        Call IrreptoInt(PointGroup,Convert_char,numSG)
        Call MakeProductTable(PointGroup,ProductTable,InvPdt,numSG)

      EPS = energyconverge**(1./2.)
       if(mult.ne.1) then
           Call ReadGamess_BinaryGAMESSFMTOS(PointGroup,Convert_char,numSG,occ_alpha,occ_beta,virt_alpha,virt_beta,OneInts,TwoIntsCompact,Sym_alpha,Sym_beta,numocc_alpha,numocc_beta,numvirt_alpha, numvirt_beta,frozencore,nuclearrep,NewIndex_alpha, NewIndex_beta,scrpath,OldIndex_alpha, OldIndex_beta,SymChar,labsiz,nwdvar)
          Call DataStructureOS(T2data,numocc_alpha, numocc_beta,numvirt_alpha,numvirt_beta,InvPdt,numSG,occ_alpha, occ_beta,virt_alpha,virt_beta,ProductTable,Sym_alpha,Sym_beta,T2deriv,0,numElements,T1data,T1deriv,Newc,DerivNewc,inputfile,T2derivT1topfac,Newc_singles,DerivNewc_singles)
          Call CalcReshapeDimOS(ReshapedMatrixDim,numSG,virt_alpha,virt_beta,occ_alpha,occ_beta,ProductTable,InvPdt)
          Call SinglePointOS(numocc_alpha,numocc_beta,numvirt_alpha,numvirt_beta,numSG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,T2data,T2deriv,Newc,DerivNewc,T1data,T1deriv,ReshapedMatrixDim,InvPdt,OneInts,TwoIntsCompact,Sym_alpha,Sym_beta,energy,topfac,topsingles,numElements,inputfile,numrowblocks,EPS,OldIndex_alpha,OldIndex_beta,T2derivT1topfac,Newc_singles,DerivNewc_singles)
          paramenergy = energy
          write(*,*) '                                              '
          if(printD1.eqv..TRUE.) then
            Call BuildD1OS(T2data,T1data,numSG,ProductTable,occ_alpha,occ_beta,virt_alpha,virt_beta,ReshapedMatrixDim,InvPdt,inputfile,Newc_singles)
          end if
          !Call PrintT2CoefficientsOS(T2data,numocc_alpha,numocc_beta,numvirt_alpha,numvirt_beta,InvPdt,numSG,occ_alpha,occ_beta,virt_alpha,virt_beta,ProductTable,Sym_alpha,Sym_beta,T1data,inputfile,numElements)
          if(calcdqg.eqv..TRUE.) then
            Call BuildD2OS(T2data,T1data,ReshapedMatrixDim,numSG,occ_alpha,occ_beta,virt_alpha,virt_beta,ProductTable,InvPdt,TwoInts,topfac,Newc,DerivNewc,T1deriv,topsingles,inputfile,Newc_singles)
          end if
          Call cpu_time(time_endmain)
          time_total = time_endmain - time_beginmain
      else if(mult.eq.1) then
        if(diagK2option.eqv..TRUE.) then
       Call ReadGamess_BinaryGAMESSFMT(inputfile,PointGroup,Convert_char,numSG,occ,virt,OneInts,TwoIntsCompact,SymO,SymV,numocc,numvirt,frozencore,nuclearrep,NewIndex,scrpath,SymChar,labsiz,nwdvar)
         Call DataStructure(T2data,numocc,numvirt,InvPdt,numSG,occ,virt,ProductTable,SymO,SymV,T2deriv,0,numElements,T1data,T1deriv,Newc,DerivNewc,inputfile)
         Call CalcReshapeDim(ReshapedMatrixDim,numSG,virt,occ,ProductTable,InvPdt)
         Call SinglePoint_UpDiag(numocc,numvirt,numSG,ProductTable,occ,virt,T2data,T2deriv,Newc,DerivNewc,T1data,T1deriv,ReshapedMatrixDim,InvPdt,OneInts,TwoIntsCompact,SymV,SymO,energy,topfac,topsingles,numElements,inputfile,EPS)
          if(printD1.eqv..TRUE.) then
            Call BuildD1(T2data,T1data,numSG,ProductTable,occ,virt,ReshapedMatrixDim,InvPdt,inputfile,topsingles)
          end if
         if(calcdqg.eqv..TRUE.) then
         Call BuildD2(T2data,T1data,ReshapedMatrixDim,numSG,occ,virt,ProductTable,InvPdt,numocc,numvirt,TwoInts,topfac,Newc,DerivNewc,T1deriv,topsingles,inputfile)
       end if
       Call CPU_TIME(time_endmain)
       time_total = time_endmain - time_beginmain
      end if
      if(diagK2option.eqv..FALSE.) then
       Call ReadGamess_BinaryGAMESSFMT(inputfile,PointGroup,Convert_char,numSG,occ,virt,OneInts,TwoIntsCompact,SymO,SymV,numocc,numvirt,frozencore,nuclearrep,NewIndex,scrpath,SymChar,labsiz,nwdvar)
       Call DataStructure(T2data,numocc,numvirt,InvPdt,numSG,occ,virt,ProductTable,SymO,SymV,T2deriv,0,numElements,T1data,T1deriv,Newc,DerivNewc,inputfile)
       Call CalcReshapeDim(ReshapedMatrixDim,numSG,virt,occ,ProductTable,InvPdt)
       Call SinglePoint(numocc,numvirt,numSG,ProductTable,occ,virt,T2data,T2deriv,Newc,DerivNewc,T1data,T1deriv,ReshapedMatrixDim,InvPdt,OneInts,TwoIntsCompact,SymV,SymO,energy,topfac,topsingles,numElements,inputfile,numrowblocks,EPS)
       paramenergy = energy
       write(*,*) '                                              '
       if(printD1.eqv..TRUE.) then
         Call BuildD1(T2data,T1data,numSG,ProductTable,occ,virt,ReshapedMatrixDim,InvPdt,inputfile,topsingles)
       end if
       !Call PrintT2Coefficients(T2data,numocc,numvirt,InvPdt,numSG,occ,virt,ProductTable,SymO,SymV,T1data,inputfile,numElements)
       if(calcdqg.eqv..TRUE.) then
         Call BuildD2(T2data,T1data,ReshapedMatrixDim,numSG,occ,virt,ProductTable,InvPdt,numocc,numvirt,TwoInts,topfac,Newc,DerivNewc,T1deriv,topsingles,inputfile)
       end if
       Call cpu_time(time_endmain)
       time_total = time_endmain - time_beginmain
      end if
     else
        write(*,*) 'Error.  Could not run an open or closed shell'
        write(*,*) 'calculation, MULT=', mult
      end if

       end subroutine P2RDM

