C 21 May 13 - CHC,DGF - changes for FMO 5.0 
C 13 Aug 12 - DGF - change REAL/IMAG and DREAL/DIMAG 
C 31 Jul 12 - CHC,DGF - last changes for FMO 4.3
C 24 Jul 12 - DGF,CHC - code update to finish FMO 4.3
C 23 Mar 12 - CHC,DGF - new multipole code for FMO 
c
C*MODULE fmomm  *DECK mmdist
C>
C>     @brief Check if X-mer should be computed with multipoles 
C>
C>     @details Check if X-mer should be computed with multipoles.
C>
C>     @author Cheol Ho Choi
C>
      subroutine mmdist(ifg,jfg,kfg,lfg,t,radius,ty2z,ratio,mmdim)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(one=1.0D+00,two=2.0d+00)
c     parameter(UNITS=0.52917724924D+00)
      logical qfmm,qops
      COMMON /FMCOM / X(1)
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm  
      COMMON /QMFM  / SIZE,EPSLN,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
      dimension t(3),cij(3)
c
c     Check if dimer IJ should be computed with multipoles.
c
c     Return
c     MMDIM  0: do not use multipoles
c            1: use multipoles for (I,J,K)...L 
c
      if(kfg.eq.0.and.jfg.eq.0) then
c        do i=1,3
c          cijk(i)=x(lcrfrg+(ifg-1)*4*ncentm+i-1)
c        enddo
        call vsub(x(lcrfrg+(lfg-1)*4*ncentm),1,
     *            x(lcrfrg+(ifg-1)*4*ncentm),1,t,1,3)
        radius=max(x(lcrfrg+3+(ifg-1)*4*ncentm), 
     *             x(lcrfrg+3+(lfg-1)*4*ncentm))
        TY2Z=SQRT(T(1)*T(1)+T(2)*T(2)+T(3)*T(3))
        ratio=radius/ty2z
      else
c       For IJ dimer case, you should use the shorter distance between
c       IJ dimer and L.
        call vsub(x(lcrfrg+(lfg-1)*4*ncentm),1,
     *            x(lcrfrg+(ifg-1)*4*ncentm),1,t,1,3)
        TY2Za=SQRT(T(1)*T(1)+T(2)*T(2)+T(3)*T(3))
        call vsub(x(lcrfrg+(lfg-1)*4*ncentm),1,
     *            x(lcrfrg+(jfg-1)*4*ncentm),1,t,1,3)
        TY2Zb=SQRT(T(1)*T(1)+T(2)*T(2)+T(3)*T(3))
        TY2Z=min(TY2Za,TY2Zb)
        do 200 i=1,3
  200     cij(i)=x(lcrfrg+(ifg-1)*4+i-1)-x(lcrfrg+(jfg-1)*4+i-1)
        cija=sqrt(cij(1)*cij(1)+cij(2)*cij(2)+cij(3)*cij(3))/2
        if(ncentm.gt.1) cija=0
c       This is because for multiple centers we ignore the distances
c       between the centers of fragments, and only look at their radii. 
        rijk=cija+max(x(lcrfrg+3+(ifg-1)*4*ncentm),
     *                x(lcrfrg+3+(jfg-1)*4*ncentm))
        if(kfg.ne.0) call abrt
c       Trimer not supported yet.
c       write(6,9010) ifg,jfg,(cijk(i)*units,i=1,3),rijk*units
        radius=max(rijk,x(lcrfrg+3+(lfg-1)*4*ncentm))
        ratio=radius/ty2z
      endif
c
c     Now we got the radius and center of n0mer I, IJ or IJK.
c     We look at how it is separated from the external fragment L. 
c
c      call vsub(x(lcrfrg+(lfg-1)*4*ncentm),1,cijk,1,t,1,3)
c      radius=max(rijk,x(lcrfrg+3+(lfg-1)*4*ncentm))
c
c     Calculate the norm of translational vector.
c
c      TY2Z=SQRT(T(1)*T(1)+T(2)*T(2)+T(3)*T(3))
      criterion=one/(two*(iws+one))
c
      mmdim=0
      if(ratio.lt.criterion) mmdim=1
c
      RETURN
c9010 format(1x,'IFG=',I5,' JFG=',I5,' C=',3F13.6,' R=',F10.6)
      END
c
C*MODULE fmomm  *DECK fmmfrg
C>
C>     @brief ES dimer energy with multipoles 
C>
C>     @details Calculates ES dimer energy with multipoles.
C>
C>     @author Cheol Ho Choi
C>
      subroutine fmmfrg(ilay,nder,loadhf,loadm,layfrg,scffrg,iactfg,
     *                  iodfmo,maxl30,orbxch,da,vtilda,nZi,irec0,
     *                  clm,flm,crfrg,Ylmfrg,Zlmfrg,
     *                  Ylmfrgq,popmat,fmode,fmopg,iaglob,isdrec,esdi,
     *                  dodistr,savgrd)
c
c     Now it works both wth single and multicenter models.
c     This routine calculates 
c      1) Ylmfrg, Zlmfrg of monomer
c      2) Then ES dimer energy and monomer gradients(when nder.gt.0) are obtained
c         using them.
c      3) YlmfrgQ of I for mmESPg (ESP gradients of IJ pair)
c
c     1) Ylmfrg: Ylm of monomer I containing all nuclei and electrons of I.
c        Ylm is contracted with density of monomer I.
c     2) Zlmfrg: Zlm of monomer I 
c        Using Ylmfrg and Zlmfrg, E(I) can be calculated.
c        Using Zlmfrg, gradient of I can be calculated in which derivative of
c        Ylmfrg are regenerated.
c     3) YlmfrgQ: YlmQ of monomer I
c        YlmQ is the multipole moment of a given fragment using Atomic
c        population. YlmQ will be used in mmESPg, which calculates the one
c        electron ESP gradients for IJ pair only.
c        Potential carries mu-nu indices. 
c
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL isgddi,parout,INITGDDI,QOPS,QFMM,GOPARR,DSKWRK,MASWRK,
     *        dodistr,myjob,orbxch,savgrd,mixdim,doesp1,wasgddi
      Integer ddi_world,ddi_group
      Parameter(ddi_world=0,ddi_group=1)
      parameter(MXATM=2000,maxnp=45,ZERO=0.0D+00,ONE=1.0D+00)
      PARAMETER (MAXCOF=23821)
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /QMFM  / SIZE,EPS,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
      complex*16 Ylmfrg(((NP+1)*(NP+2))/2,ncentm,nfg),
     *           Zlmfrg(((NP+1)*(NP+2))/2,ncentm,nfg),
     *           Ylmfrgq(((NP+1)*(NP+2))/2,nfg),
     *           CZP((MAXNP+1)*(MAXNP+2)/2),
     *           Zlmj(((MAXNP+1)*(MAXNP+2))/2)
      dimension loadm(*),layfrg(*),scffrg(*),iactfg(*),da(*),vtilda(*),
     *          nZi(*),iodfmo(*),maxl30(*),crfrg(4,ncentm,nfg),
     *          fmode(3,*),fmopg(3,*),iaglob(*),isdrec(*),esdi(*),
     *          CLM(-maxNP:maxNP),FLM(-maxNP:maxNP),
     *          popmat(maxnat,nfg,2)
      DIMENSION F((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          G((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          COEFF(MAXCOF,2),ZLL(0:2*maxNP+1,2)
      dimension t(3),ez(3),rt(3,3)
c
      DATA RMC/8HMCSCF   /,RNONE/8HNONE    /,UHF/8HUHF     /
c
C     Things need to obtain before doing any multipole operation.     
c 
      if(maswrk) write(iw,*) 'Multipole generation begins.'
      ifmostp=6
c     It may be better to assign a unique number but for now just this.
c
C     GET TABLE FOR 1-ELECTRON INTEGRAL
      CALL GXYZLM
      doesp1=iand(modfmm,8).ne.0
C     
      LNP=((NP+1)*(NP+2))/2
c     the number of real*8 is twice this value. 
c
c     Finding out the largest l for generaring YlmI.
c
      call MxNPs(crfrg,nps,npst)
c
      if(nps.gt.np) then
        if(maswrk) write(iw,9000) np,nps
        call abrt
      endif
      if(maswrk) write(iw,9005) np,nps
      if(nlayer.ne.1) call abrt
      if(savgrd) call abrt
C     
c     Generating Ylm of each fragment and putting in Ylmfrg
c     Generating Ylmq of each fragment and putting in Ylmfrgq
c     Ylmq is the multipole moment of a given fragment using Atomic 
c     population. It is needed in the derivative calculations of Dimer IJ.
c     The calculation of Ylmq requires loop over I.
c
      if(isgddi) call GDDICOUNT(-1,lgroup,myjob)
      do 200 iifg=1,nfg
        if(loadhf.eq.1) then
          ifg=loadm(iifg)
        else
          ifg=iifg
        endif
        if(layfrg(ifg).ge.ilay) then
          call vclr(Ylmfrg(1,1,ifg),1,LNP*2*ncentm)
          if(doesp1) call vclr(Ylmfrgq(1,ifg),1,LNP*2)
          if(isgddi) then
            call GDDICOUNT(0,lgroup,myjob)
            if(.not.myjob) then
c             if(ncentm.gt.1) call vclr(crfrg(1,1,ifg),1,ncentm*4)
              goto 200
            endif
          endif
          call CLOSDA('DELETE')
          CALL OPENDA(0)
          call makemol(ifg,0,0,ilay,0,0,0,0,0,0,0,.true.)
          l1=num
          l2=(l1*l1+l1)/2
c         call readumond(da,Vtilda,orbxch,scffrg(ifg).eq.rmc,na,nb,l1,0,
c    *                     iodfmo,ifg+irec0)
          call readmond(da,orbxch,scffrg(ifg).eq.rmc,na,nb,l1,
     *                     iodfmo,ifg+irec0,scffrg(ifg).eq.uhf)
c         generate multipole of fragment ifg
          if (ncentm.eq.1) then
             call fmo_Y(clm,flm,crfrg(1,1,ifg),da,Ylmfrg(1,1,ifg),nps)
          else
c         If ncentm.gt.1, we should generate Ylm for multiple centers.
             call fmo_Y_M(clm,flm,crfrg(1,1,ifg),da,Ylmfrg(1,1,ifg),nps)
          endif
c
          if(doesp1) then
            if(resppc(1).eq.0) then
              dum=0
              call fmo_Yq(clm,flm,crfrg(1,1,ifg),dum,
     *                    Ylmfrgq(1,ifg),nps,.false.)
            else
              call fmo_Yq(clm,flm,crfrg(1,1,ifg),popmat(1,ifg,icurpop),
     *                    Ylmfrgq(1,ifg),nps,.true.)
            endif
          endif
        else
          if(meglob.ne.0) then
            call vclr(Ylmfrg(1,1,ifg),1,LNP*2*ncentm)
c           to avoid double counting in DDI_GSUMF 
            if(doesp1) call vclr(Ylmfrgq(1,ifg),1,LNP*2)
          endif
        endif
  200 continue
      if(isgddi) call GDDICOUNT( 1,lgroup,myjob)
      if(isgddi) call gddi_scope(ddi_world)
      call ddi_gsumf(2416,Ylmfrg,LNP*2*ncentm*nfg)
      if(doesp1) call ddi_gsumf(2416,Ylmfrgq,LNP*2*nfg)
      if(isgddi) call gddi_scope(ddi_group)
      call timit(1)
c
      if(nder.gt.0) then
c
c.....................................................................c
c     Computation of Zlmfrg
c.....................................................................c
c     Generating the Zlmfrg of each fragment on the basis of distance criteria.
c     We do Y2Z translations for the fragment pairs of I and J,
c     whose Rij.gt.Resdim.
c     Eventually, Zlmfrg will contain all the long range potentials on I due to
c     all the other J, except short distance Js.
c
c     z-axis
c
      EZ(1)=zero
      EZ(2)=zero
      EZ(3)=one
c
c     Zeroing out Zlmfrg
      call vclr(Zlmfrg,1,LNp*2*ncentm*nfg)
      call viclr(nZi,1,nfg)
c    
c     The dimer loop below is not parallelised over IJ, because
c     each dimer cannot be computed in parallel. Instead. we parallelise
c     over I among groups and over J within group, which is lame but better 
c     than nothing. 
      if(isgddi) call GDDICOUNT(-1,lgroup,myjob)
      do 460 iifg=1,nfg
        if(loadhf.eq.1) then
          ifg=loadm(iifg)
        else
          ifg=iifg
        endif
        if(isgddi) then
          call GDDICOUNT(0,lgroup,myjob)
          if(.not.myjob) goto 460
        endif
c       Since it is believed that the cost of this loop is low,
c       we hardwire static parallelisation. 
        kount=0
c     WRITE(IW,*) 'FMOFRG: IFG ',IFG
        do 450 jfg=1,ifg-1
c
          mixdim=modfd.ne.0.and.layfrg(ifg)+layfrg(jfg).eq.3
          if(modfd.eq.0) then
c         skip dimers from higher layers
            if(.not.((layfrg(ifg).eq.ilay.or.layfrg(jfg).eq.ilay).and.
     *        layfrg(ifg).ge.ilay.and.layfrg(jfg).ge.ilay)) goto 450
          else
            if(ilay.ne.2) call abrt
            if(iand(modfd,2).ne.0) then
              if(iactfg(ifg).eq.0.and.iactfg(jfg).eq.0) goto 450
c             fast
            else
              if(layfrg(ifg).lt.ilay.and.layfrg(jfg).lt.ilay .or.
     *           mixdim.and.iactfg(ifg)+iactfg(jfg).ne.1) goto 450
c             slow
            endif
          endif
          if(scffrg(ifg).eq.rnone.or.scffrg(jfg).eq.rnone) goto 450
c         skip dimers that have been done (restart jobs, no BSSE).
c         if(irststp.ge.4.and.irststp.ne.5.and.edim(ijfg,1).ne.zero)
c    *       goto 450
c         No gradient restart for now.
c
          rij=fmodist(ifg,0,0,jfg)
          call mmdist(ifg,0,0,jfg,t,radius,ty2z,ratio,mmdim)
c     WRITE(IW,*) 'FMOFRG: IFG JFG',IFG,JFG
c     WRITE(IW,*) 'FMOFRG: rij,radius,ty2z,mmdim',rij,radius,ty2z,mmdim
          if(rij.gt.resdim.and.mmdim.ne.0) then
            kount=kount+1
            if(goparr.and.mod(kount,NPROC).NE.me) goto 450 
c
c           Using very fast multipole idea.
            nps=int(log10(EPS*abs(ty2z-radius))/log10(ratio)-one)
            if(nps.gt.npst) then
              if(maswrk) write(iw,9010) npst,nps
              call abrt
            endif
c
            LNPS=((NPS+1)*(NPS+2))/2
            LFGS=((NPS*(NPS+1)*(NPS+2)*4)/3)+(NPS+1)
c           
c           Ylm are defined above (as Ylmfrg) with NP used to compute its
c           leading dimension.
c           Therefore, the same NP from QMFM should be used to define Ylm,
c           although one can use a different one for calculations (NPs).
c           
c           Some pre-computable values for rotation based translation.
c           Again very fast idea uses Nps rather than Np.
c           We'll use Nps later. But for the moment let's use Np.
c           
            if (ncentm.eq.1) then
               CALL GETZLL(ZLL,TY2Z,2*NPS+1)
               CALL GETCOF(NPS,FLM,ZLL,COEFF)
               CALL ROTR(T,EZ,RT)
               CALL GETROT(F,G,RT,NPS,CLM)
c           
c           First Potential of J on I
c           
               CALL RY2ZIR(LNPS,Ylmfrg(1,1,jfg),Zlmj,CZP,LFGS,F,G,NPS,
     *           COEFF(1,1))
c           The return value contains the Zlmj due to fragment J.
c           Now we just sum over all Zlmj to get ZlmI.
               call daxpy(LNps*2,one,Zlmj,1,Zlmfrg(1,1,ifg),1)
               nZi(ifg)=nZi(ifg)+1
c           
c           Second Potential of I on J
c           
               CALL RY2ZIR(LNPS,Ylmfrg(1,1,ifg),Zlmj,CZP,LFGS,F,G,NPS,
     *           COEFF(1,2))
               call daxpy(LNps*2,one,Zlmj,1,Zlmfrg(1,1,jfg),1)
c           Nota bene: this daxpy should probably be changed into?
c           call daxpy(LNp*2*ncentm,one,Zlmj,1,Zlmfrg(1,1,jfg),1)
c
               nZi(jfg)=nZi(jfg)+1
            else
               do i=2,int(crfrg(1,ncentm,ifg))+1
                  do j=2,int(crfrg(1,ncentm,jfg))+1
                     do k=1,3
                        t(k)=crfrg(k,i,ifg)-crfrg(k,j,jfg)
                     enddo
                     ty2z=sqrt(t(1)*t(1)+t(2)*t(2)+t(3)*t(3))
                     CALL GETZLL(ZLL,TY2Z,2*NPS+1)
                     CALL GETCOF(NPS,FLM,ZLL,COEFF)
                     CALL ROTR(T,EZ,RT)
                     CALL GETROT(F,G,RT,NPS,CLM)
c           
c           First Potential of J on I
c           
                     CALL RY2ZIR(LNPS,Ylmfrg(1,j,jfg),Zlmj,CZP,LFGS,
     *                    F,G,NPS,COEFF(1,1))
c           The return value contains the Zlmj due to fragment J.
c           Now we just sum over all Zlmj to get ZlmI.
                     call daxpy(LNps*2,one,Zlmj,1,Zlmfrg(1,i,ifg),1)
c           
c           Second Potential of I on J
c           
                     CALL RY2ZIR(LNPS,Ylmfrg(1,i,ifg),Zlmj,CZP,LFGS,
     *                    F,G,NPS,COEFF(1,2))
                     call daxpy(LNps*2,one,Zlmj,1,Zlmfrg(1,j,jfg),1)
c           Nota bene: this daxpy should probably be changed into?
c           call daxpy(LNp*2*ncentm,one,Zlmj,1,Zlmfrg(1,1,jfg),1)
c           No, Zlmj only contains values of the particular center. 
c           So each center of a given fragment should have it own Zlm.
c
                  enddo
               enddo
               nZi(ifg)=nZi(ifg)+1
               nZi(jfg)=nZi(jfg)+1 
            endif
          endif
  450   continue
  460 continue
      if(isgddi) call GDDICOUNT( 1,lgroup,myjob)
      if(isgddi) call gddi_scope(ddi_world)
      call ddi_gsumf(2416,Zlmfrg,LNP*2*ncentm*nfg)
      call ddi_gsumi(2417,nZi,nfg)
      if(isgddi) call gddi_scope(ddi_group)
      call timit(1)
      if(maswrk) write(iw,*) 'nZi=',(nZi(i),i=1,nfg)
c
c     Ok now Zlmfrg contains all the long-range potentials.
C     Note that you still have to do short-range ones separately.
c     In the future, we'll use FMM for this.
c    
c.....................................................................c
c     MM gradient part.
c.....................................................................c
c     Using Zlmfrg as obtained above, now we can calculate E(I) and
c     also gradient of monomer I.
c     By shifting Zlm to the UNIQUE center of Ylm, 
c     Nps can be Npgp*2, which saves a lot of time.
c     However, we should use maximum Np=Npst for 
c     energy calculations.
c
      nps=npgp
      LNPSt=((NPSt+1)*(NPSt+2))/2
c
      if(isgddi) call GDDICOUNT(-1,lgroup,myjob)
      do iifg=1,nfg
        if(loadhf.eq.1) then
          ifg=loadm(iifg)
        else
          ifg=iifg
        endif
        if (layfrg(ifg).ge.ilay.and.nZi(ifg).ne.0) then
          if(isgddi) then
            call GDDICOUNT(0,lgroup,myjob)
            if(.not.myjob) goto 500
          endif
          call CLOSDA('DELETE')
          CALL OPENDA(0)
          call makemol(ifg,0,0,ilay,0,0,0,0,0,0,0,.false.)
          l1=num
          l2=(l1*l1+l1)/2
c
c         Do the energy: E(I)=sum{J} E(IJ) for MM dimers
c
c        These sums can be parallelized within the group.
c
         if (ncentm.eq.1) then
            call fmo0p(Npst,lNpst,Ylmfrg(1,1,ifg),Zlmfrg(1,1,ifg),Ei)
            Ei=Ei/2
         else
            Ei=0.0d+00
            do i=2,int(crfrg(1,ncentm,ifg))+1
               call fmo0p(Npst,lNpst,Ylmfrg(1,i,ifg),Zlmfrg(1,i,ifg),Et)
               Ei=Ei+Et
            enddo
            Ei=Ei/2
         endif
c        if(maswrk) write(IW,*) 'in fmmfrg Ei',ifg,ei
         if(maswrk) esdi(ifg)=Ei
c
c        Doing the gradient
c
          call readmond(da,orbxch,scffrg(ifg).eq.rmc,na,nb,l1,
     *                  iodfmo,ifg+irec0,scffrg(ifg).eq.uhf)
          call vclr(de,1,3*nat)
          nreci=1+ifg+nfg
          if (ncentm.eq.1) then
           call fmo_mmder(l2,clm,flm,npst,crfrg(1,1,ifg),da,
     *                   Zlmfrg(1,1,ifg),de,Vtilda)
          else
            call fmo_mmder_M(l2,clm,flm,npst,crfrg(1,1,ifg),da,
     *         Zlmfrg(1,1,ifg),de,Vtilda)
          endif
c         Add the total gradient contribution, sum over J for IJ dimers. 
          call fmodeg(1,fmode,fmopg,iaglob)
c         Write out the Lagrangian of IFG1.
          if(.not.dodistr.or.maswrk) then
            imxl30=maxl30(ifg)
            nreci=1+ifg+nfg
            CALL rawrites(IDAFMO,iodfmo,Vtilda,imxl30,l2,nreci,0)
            isdrec(nreci)=1
          endif
        endif
  500   continue
      enddo
c
      if(isgddi) call GDDICOUNT( 1,lgroup,myjob)
      call timit(1)
      endif
c     end of gradient
c
      if(maswrk) write(iw,*) 'Multipole generation is done.'
      return
 9000 FORMAT(/1X,'Increase NP or decrease IEPS in $FMM: NP,NPS=',2I8)
 9005 FORMAT(/1X,'Multipole generation: NP,NPS=',2I8)
 9010 FORMAT(/1X,'Internal failure in setting NPST,NPS=',2I8)
      end
C*MODULE fmomm  *DECK fmo_Y_M
C>
C>     @brief Calculate Ylm. 
C>
C>     @details Calculate the multipole function Ylm.
C>
C>     @author Cheol Ho Choi
C>
      SUBROUTINE fmo_y_M(clm,flm,Ctr,da,Ylm,nps)
C
c     The multicenter version of fmo_Y.
c     np : The highest angluar momentum, l, which needs to be set 
c     before calling this routine. It is defined in QMFM common block.
C     ctr : the geometric center of a given fragment should be given. 
c     Ylm : the multipole moment of a given fragment which will be
c           calculated in this routine.
c     da : density matrix of a given fragment.
C
C     THIS ROUTINE RETURNS Ylm(MULTIPOLE MOMENTS OF a given fragment of
C     FMO) for dimer energy.
C              
C     Ylm : COMPLEX[(NP+1)*(NP+2)/2]
C        
C     C. H. CHOI with D. G. Fedorov Jan 2011
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXSH=5000,MXGTOT=20000,MXATM=2000)
c      PARAMETER (RLN10=2.30258D+00)
      PARAMETER (ZERO=0.00D+00,TWO=2.0D+00,MAXNP=45)
      PARAMETER (MAXCOF=23821,MAXMC=MXATM+2)
      PARAMETER (SQRT3=1.73205080756888D+00,SQRT5=2.23606797749979D+00)
      COMPLEX*16 Ylm, yp, PYP, YTP,YTP2  
      LOGICAL GOPARR,DSKWRK,MASWRK,QOPS,QFMM,IANDJ,DOUBLE,NORM,nxt
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /QMFM  / SIZE,EPS,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
      DIMENSION ctr(4,ncentm),Ylm(((NP+1)*(NP+2))/2,ncentm),
     *          F((MaxNP*(MaxNP+1)*(MaxNP+2)*4)/3+(MaxNP+1)),
     *          CLM(-MaxNP:MaxNP),
     *          G((MaxNP*(MaxNP+1)*(MaxNP+2)*4)/3+(MaxNP+1)),
     *          FLM(-MaxNP:MaxNP),
     *          COEFF(MAXCOF,2),ZLL(0:2*MaxNP+1),
     *          PYP(((MAXNP+1)*(MAXNP+2))/2),
     *          YTP(((MAXNP+1)*(MAXNP+2))/2),
     *          YTP2(((MAXNP+1)*(MAXNP+2))/2),
     *          YP(((MAXNP+1)*(MAXNP+2))/2),
     *          DA(*),RT(3,3),PNT(4),pctr(3),EZ(3)
      DIMENSION PA(3),PB(3),DIJ(255)
c     DIMENSION rMMS(MAXMC),p_counter(MAXMC),rDISTS(MAXMC),
c    *          rMAX(MAXMC)
c     DATA UHF,ROHF/8HUHF     ,8HROHF     /
C     
      NORM=NORMF.NE.1.OR.NORMP.NE.1
C
c      TOL=RLN10*ITOL
c     For better definition of radius of centers
c     BEX=SQRT(2.0D+00)*DERFINV(ONE-DPGD)
      do i=1,MAXMC
c        p_counter(i)=zero
c        rMMS(i)=zero
c        rMAX(i)=zero
c        rDISTS(i)=zero
      enddo
c     rMM_MAX=zero
C     
      LNPs=((NPs+1)*(NPs+2))/2
c     LNP=((NP+1)*(NP+2))/2
      LFG=(NPs*(NPs+1)*(NPs+2)*4)/3+(NPs+1)
      LNPGP=((NPGP+1)*(NPGP+2))/2
c
C     zeroing out 
c
      DO I=1,LNPs
         do j=1,ncentm
            Ylm(I,j)=ZERO
         enddo
      ENDDO
C
c     z-xis
c
      EZ(1)=0.0D+00
      EZ(2)=0.0D+00
      EZ(3)=1.0D+00
c
      NXT = IBTYP.EQ.1
      NEXT  = -1
      kount = -1
c
c     We first calculate the electron contributions.
C
c     First shell loop.
c
      DO II=1,NSHELL
         Iatom=KATOM(II)
         XI=C(1,iatom)
         YI=C(2,iatom)
         ZI=C(3,iatom)
         I1=KSTART(II)
         I2=I1+KNG(II)-1
         MINI=KMIN(II)
         MAXI=KMAX(II)
         LIT=KTYPE(II)
         ILOC=KLOC(II)
C
C        SECOND SHELL LOOP.
C
         DO JJ=1,II
           if(goparr) then
              kount=kount+1
              if(nxt) then
                 IF(kount.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
                 if(NEXT.ne.kount) goto 700
              else
                 if(MOD(kount,NPROC).NE.me) goto 700
              endif
            endif
            Jatom=KATOM(JJ)
            XJ=C(1,Jatom)
            YJ=C(2,Jatom)
            ZJ=C(3,Jatom)
            J1=KSTART(JJ)
            J2=J1+KNG(JJ)-1
            MINJ=KMIN(JJ)
            MAXJ=KMAX(JJ)
            LJT=KTYPE(JJ)
            JLOC=KLOC(JJ)
            RR=(XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
            IANDJ=II.EQ.JJ
c
C           Loop over primitive Gaussians
C
C           I PRIMITIVE.
C
            JGMAX=J2
            DO IG=I1,I2
               AI=EX(IG)
               ARRI=AI*RR
               AXI=AI*XI
               AYI=AI*YI
               AZI=AI*ZI
               CSI=CS(IG)
               CPI=CP(IG)
               CDI=CD(IG)
               CFI=CF(IG)
c
C              J PRIMITIVE
c
               IF(IANDJ) JGMAX=IG
               DO JG=J1,JGMAX
c
                  AJ=EX(JG)
                  AA=AI+AJ
                  DUM=AJ*ARRI/AA
c                  IF(DUM.GT.TOL) GO TO 6000
c
c                 The unique center of the primitive Gaussian product
c
                  pctr(1)=(AXI+AJ*XJ)/AA
                  pctr(2)=(AYI+AJ*YJ)/AA
                  pctr(3)=(AZI+AJ*ZJ)/AA
c
                  CSJ=CS(JG)
                  CPJ=CP(JG)
                  CDJ=CD(JG)
                  CFJ=CF(JG)
C
                  FAC= EXP(-DUM)
C
                  DOUBLE=IANDJ.AND.IG.NE.JG
                  MAX=MAXJ
                  NN=0
                  DO 310 I=MINI,MAXI
                  GO TO ( 70, 80,180,180, 90,180,180,101,180,180,
     *            110,180,180,120,180,180,180,180,180,130),I
   70             DUM1=CSI*FAC
                  GO TO 180
   80             DUM1=CPI*FAC
                  GO TO 180
   90             DUM1=CDI*FAC
                  GO TO 180
  101             IF(NORM) DUM1=DUM1*SQRT3
                  GO TO 180
  110             DUM1=CFI*FAC
                  GO TO 180
  120             IF(NORM) DUM1=DUM1*SQRT5
                  GO TO 180
  130             iF(NORM) DUM1=DUM1*SQRT3
  180             IF(IANDJ) MAX=I
                  DO 310 J=MINJ,MAX
                  GO TO (190,200,300,300,210,300,300,220,300,300,
     *            230,300,300,240,300,300,300,300,300,250),J
  190             DUM2=DUM1*CSJ
                  IF(.NOT.DOUBLE) GO TO 300
                  IF(I.GT.1) GO TO 195
                  DUM2=DUM2+DUM2
                  GO TO 300
  195             DUM2=DUM2+CSI*CPJ*FAC
                  GO TO 300
  200             DUM2=DUM1*CPJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  210             DUM2=DUM1*CDJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  220             IF(NORM) DUM2=DUM2*SQRT3
                  GO TO 300
  230             DUM2=DUM1*CFJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  240             IF(NORM) DUM2=DUM2*SQRT5
                  GO TO 300
  250             IF(NORM) DUM2=DUM2*SQRT3
  300             NN=NN+1
  310             DIJ(NN)=DUM2
c 
c
C                 The input argument ctr should contain the center of 
c                 fragment.
c
C                 Calcualte the translational vector, Pnt.
c                 Note: CTR -> center of fragment.
c                 pctr -> the unique center of product of primitive 
c                 Gaussian.
c
c                 Note that we will put the generated multipole to the closest center!
c                 We also collect information for optimum radius of centers.
                  call getnear(0,pctr,ctr(1,1),ncentm,idx,rDIST)
c                  p_counter(idx)=p_counter(idx)+one
c                  rDISTS(idx)=rDISTS(idx)+rDIST
c                  rMM=BEX/SQRT(AA)
c                  rMMS(idx)=rMMS(idx)+rMM
c                  if (rMM.gt.rMAX(idx)) rMAX(idx)=rMM
c
                  DO Iip=1,3
                     PNT(Iip)=pctr(Iip)-CTR(Iip,idx)
                  ENDDO
c
C                 OBTAIN PA AND PB: the relative vector w.r.t. unique center P.
c
                  DO Iip=1,3
                     PA(Iip)=pctr(Iip)-C(Iip,IATOM)
                     PB(Iip)=pctr(Iip)-C(Iip,JATOM)
                  ENDDO
c
c                 Translational distance of y2y translation
c
                  TY2Y=SQRT(PNT(1)*PNT(1)+PNT(2)*PNT(2)+PNT(3)*PNT(3))
c
c                 Calculate pre-computable quantities for rotation based 
c                 multipole operation.
c
                  CALL GETZLL(ZLL,TY2Y,2*NPs+1)
                  CALL GETCOF2(NPs,FLM,ZLL,COEFF)
                  CALL ROTR(PNT,EZ,RT)
                  CALL GETROT(F,G,RT,NPs,CLM)
C
                  DO III=1,LNPs
                     PYP(III)=ZERO
                     YTP(III)=ZERO
                     YTP2(III)=ZERO
                  ENDDO
C
c
c                 Loop over basis set pair IJ
c
                  jp=0  
                  DO IB=iloc,iloc+maxi-mini
                     LIN=IB*(IB-1)/2
                     DO JB=jloc,jloc+maxj-minj
                        LJN=JB+LIN
                        IF (IB.GE.JB) THEN
                           D2MAT=DA(LJN)
c                          IF (UROHF) D2MAT=D2MAT+BDMAT(LJN)
                           IF (IB.NE.JB) D2MAT=D2MAT*TWO
                           JP=JP+1
c
c                          Calculate multipole of a given pair of primitive 
c                          gaussian w.r.t. its unique center.
c
                          CALL MOMSPC(LIT,LJT,IB-iloc+MINI,JB-JLOC+MINJ,
     *                     Yp,PA,PB,AA,DIJ(JP))
c
c                          Sum up the density contracted multipoles.
c                          Since the same primitive products have the same 
c                          unique center, they can be added up.
c
                           DO IIi=1,LNPGP
                              PYP(IIi)=PYP(IiI)+D2MAT*Yp(IIi)
                           ENDDO
                        ENDIF
                     ENDDO
                  ENDDO
C
C                 TRANSLATE W.R.T. THE CENTER OF fragment AND SUM UP
C
                  CALL RY2YIR(LNPGP,LNPs,PYP,YTP2,YTP,LFG,F,G,NPs,COEFF)
                  DO IIi=1,LNPs
                     Ylm(IIi,idx)=Ylm(IIi,idx)+YTP2(IIi)
                  ENDDO
c              J primitive
               ENDDO
c           I primitive
            enddo
  700    continue 
c        J shell
         enddo
c     I shell
      enddo
      IF (GOPARR.and.nxt) CALL DDI_DLBRESET
c
c     The nuclei contributions
c
      kount = -1
      do ii=1,nat
        if(goparr) then
           kount=kount+1
           if(MOD(kount,NPROC).NE.me) goto 800
c          static load balancing
        endif
c
c        The translational vector w.r.t. center of fragment
c
         call getnear(0,c(1,ii),ctr(1,1),ncentm,idx,rDIST)
         DO Iii=1,3
            PNT(Iii)=c(Iii,ii)-CTR(Iii,idx)
         ENDDO
c
c        Translational distance of y2y translation
c
         TY2Y=SQRT(PNT(1)*PNT(1)+PNT(2)*PNT(2)+PNT(3)*PNT(3))
c
c        Calculate pre-computable quantities for rotation based
c        multipole operation.
c
         CALL GETZLL(ZLL,TY2Y,2*NPs+1)
         CALL GETCOF2(NPs,FLM,ZLL,COEFF)
         CALL ROTR(PNT,EZ,RT)
         CALL GETROT(F,G,RT,NPs,CLM)
C
         DO III=1,LNPs
            PYP(III)=ZERO
            YTP(III)=ZERO
            YTP2(III)=ZERO
         ENDDO
c
c        Since nuclei have point charges, we don't need integration.
c
         PYP(1)=zan(ii)
C
C        TRANSLATE W.R.T. THE CENTER OF fragment AND SUM UP
C
         CALL RY2YIR(LNPGP,LNPs,PYP,YTP2,YTP,LFG,F,G,NPs,COEFF)
         DO IIi=1,LNPs
            Ylm(IIi,idx)=Ylm(IIi,idx)+YTP2(IIi)
         ENDDO
c
  800    continue 
      enddo
c     Summation of Ylm over nodes is done elsewhere (in fmmfrg).
c
c     now comes the clumsy part of finding the max radius values across all nodes.
c
c      if(goparr) then
c        CALL DDI_GSUMF(2414,p_counter,ncentm)
c        CALL DDI_GSUMF(2414,rMMS,ncentm)
c        CALL DDI_GSUMF(2414,rDISTS,ncentm)
c        CALL VALFM(LOADFM)
c        lrad=LOADFM+1
c        last=lrad+nproc*2
c        NEED = LAST- LOADFM -1
c        CALL GETFM(NEED)
c        do i=2,int(ctr(1,ncentm))+1
c          call vclr(xx(lrad),1,nproc*2)
c          xx(lrad+me)=ctr(4,i)
c          xx(lrad+nproc+me)=rMAX(i)
c          CALL DDI_GSUMF(2414,xx(lrad),nproc*2)
c          ctr(4,i)=xx(lrad+idamax(nproc,xx(lrad),1)-1)
c          rMAX(i)=xx(lrad+nproc+idamax(nproc,xx(lrad+nproc),1)-1)
c        enddo
c        CALL RETFM(NEED)
c      endif 
c
c     Before returning we should set optimum radius of centers.
c     We only change radius on the basis of averaged rDIST and rMM.
c
c     Factor : the weight factor for diffuse functions.
c      Factor = 0
c      do i=2,int(ctr(1,ncentm))+1
c        write(6,*) 'wwwaaa',ctr(4,i),p_counter(i),rMMS(i),rMAX(i),
c    *                       rDISTS(i)
c         rMM=(one-factor)*rMMS(i)/p_counter(i)+Factor*rMAX(i)
c         rDIST=rDISTS(i)/p_counter(i)
c         if ((rMM+rDIST).gt.ctr(4,i)) ctr(4,i)=(ctr(4,i)+rMM+rdist)/two   
c      enddo
C
      RETURN
      END
C*MODULE fmomm  *DECK fmo_Y
C>
C>     @brief Y function for multipoles 
C>
C>     @details Calculates Y function for multipoles. 
C>
C>     @author Cheol Ho Choi
C>
      SUBROUTINE fmo_y(clm,flm,Ctr,da,Ylm,nps)
C
c     np : The highest angluar momentum, l, which needs to be set 
c     before calling this routine. It is defined in QMFM common block.
C     ctr : the geometric center of a given fragment should be given. 
c     Ylm : the multipole moment of a given fragment which will be
c           calculated in this routine.
c     da : density matrix of a given fragment.
C
C     THIS ROUTINE RETURNS Ylm(MULTIPOLE MOMENTS OF a given fragment of
C     FMO) for dimer energy.
C              
C     Ylm : COMPLEX[(NP+1)*(NP+2)/2]
C        
C     C. H. CHOI with D. G. Fedorov Jan 2011
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXSH=5000,MXGTOT=20000,MXATM=2000)
c     PARAMETER (RLN10=2.30258D+00)
      PARAMETER (ZERO=0.00D+00,TWO=2.0D+00,MAXNP=45)
      PARAMETER (MAXCOF=23821)
      PARAMETER (SQRT3=1.73205080756888D+00,SQRT5=2.23606797749979D+00)
      COMPLEX*16 Ylm, yp, PYP, YTP,YTP2  
      LOGICAL GOPARR,DSKWRK,MASWRK,QOPS,QFMM,IANDJ,DOUBLE,NORM,nxt
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /QMFM  / SIZE,EPS,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
      DIMENSION ctr(3),Ylm(((NP+1)*(NP+2))/2),
     *          F((MaxNP*(MaxNP+1)*(MaxNP+2)*4)/3+(MaxNP+1)),
     *          CLM(-MaxNP:MaxNP),
     *          G((MaxNP*(MaxNP+1)*(MaxNP+2)*4)/3+(MaxNP+1)),
     *          FLM(-MaxNP:MaxNP),
     *          COEFF(MAXCOF,2),ZLL(0:2*MaxNP+1),
     *          PYP(((MAXNP+1)*(MAXNP+2))/2),
     *          YTP(((MAXNP+1)*(MAXNP+2))/2),
     *          YTP2(((MAXNP+1)*(MAXNP+2))/2),
     *          YP(((MAXNP+1)*(MAXNP+2))/2),
     *          DA(*),RT(3,3),PNT(4),pctr(3),EZ(3)
      DIMENSION PA(3),PB(3),DIJ(255)
c     DATA UHF,ROHF/8HUHF     ,8HROHF     /
C     
      NORM=NORMF.NE.1.OR.NORMP.NE.1
C
c     TOL=RLN10*ITOL
C     
      LNPs=((NPs+1)*(NPs+2))/2
c     LNP=((NP+1)*(NP+2))/2
      LFG=(NPs*(NPs+1)*(NPs+2)*4)/3+(NPs+1)
      LNPGP=((NPGP+1)*(NPGP+2))/2
c
C     zeroing out 
c
c     call vclr(Ylm,1,LNp*2*ncentm)
       DO I=1,LNPs
          Ylm(I)=ZERO
       ENDDO
C
c     z-xis
c
      EZ(1)=0.0D+00
      EZ(2)=0.0D+00
      EZ(3)=1.0D+00
c
      NXT = IBTYP.EQ.1
      NEXT  = -1
      kount = -1
c
c     We first calculate the electron contributions.
C
c     First shell loop.
c
      DO II=1,NSHELL
         Iatom=KATOM(II)
         XI=C(1,iatom)
         YI=C(2,iatom)
         ZI=C(3,iatom)
         I1=KSTART(II)
         I2=I1+KNG(II)-1
         MINI=KMIN(II)
         MAXI=KMAX(II)
         LIT=KTYPE(II)
         ILOC=KLOC(II)
C
C        SECOND SHELL LOOP.
C
         DO JJ=1,II
           if(goparr) then
              kount=kount+1
              if(nxt) then
                 IF(kount.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
                 if(NEXT.ne.kount) goto 700
              else
                 if(MOD(kount,NPROC).NE.me) goto 700
              endif
            endif
            Jatom=KATOM(JJ)
            XJ=C(1,Jatom)
            YJ=C(2,Jatom)
            ZJ=C(3,Jatom)
            J1=KSTART(JJ)
            J2=J1+KNG(JJ)-1
            MINJ=KMIN(JJ)
            MAXJ=KMAX(JJ)
            LJT=KTYPE(JJ)
            JLOC=KLOC(JJ)
            RR=(XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
            IANDJ=II.EQ.JJ
c
C           Loop over primitive Gaussians
C
C           I PRIMITIVE.
C
            JGMAX=J2
            DO IG=I1,I2
               AI=EX(IG)
               ARRI=AI*RR
               AXI=AI*XI
               AYI=AI*YI
               AZI=AI*ZI
               CSI=CS(IG)
               CPI=CP(IG)
               CDI=CD(IG)
               CFI=CF(IG)
c
C              J PRIMITIVE
c
               IF(IANDJ) JGMAX=IG
               DO JG=J1,JGMAX
c
                  AJ=EX(JG)
                  AA=AI+AJ
                  DUM=AJ*ARRI/AA
c                  IF(DUM.GT.TOL) GO TO 6000
c
c                 The unique center of the primitive Gaussian product
c
                  pctr(1)=(AXI+AJ*XJ)/AA
                  pctr(2)=(AYI+AJ*YJ)/AA
                  pctr(3)=(AZI+AJ*ZJ)/AA
c
                  CSJ=CS(JG)
                  CPJ=CP(JG)
                  CDJ=CD(JG)
                  CFJ=CF(JG)
C
                  FAC= EXP(-DUM)
C
                  DOUBLE=IANDJ.AND.IG.NE.JG
                  MAX=MAXJ
                  NN=0
                  DO 310 I=MINI,MAXI
                  GO TO ( 70, 80,180,180, 90,180,180,101,180,180,
     *            110,180,180,120,180,180,180,180,180,130),I
   70             DUM1=CSI*FAC
                  GO TO 180
   80             DUM1=CPI*FAC
                  GO TO 180
   90             DUM1=CDI*FAC
                  GO TO 180
  101             IF(NORM) DUM1=DUM1*SQRT3
                  GO TO 180
  110             DUM1=CFI*FAC
                  GO TO 180
  120             IF(NORM) DUM1=DUM1*SQRT5
                  GO TO 180
  130             iF(NORM) DUM1=DUM1*SQRT3
  180             IF(IANDJ) MAX=I
                  DO 310 J=MINJ,MAX
                  GO TO (190,200,300,300,210,300,300,220,300,300,
     *            230,300,300,240,300,300,300,300,300,250),J
  190             DUM2=DUM1*CSJ
                  IF(.NOT.DOUBLE) GO TO 300
                  IF(I.GT.1) GO TO 195
                  DUM2=DUM2+DUM2
                  GO TO 300
  195             DUM2=DUM2+CSI*CPJ*FAC
                  GO TO 300
  200             DUM2=DUM1*CPJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  210             DUM2=DUM1*CDJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  220             IF(NORM) DUM2=DUM2*SQRT3
                  GO TO 300
  230             DUM2=DUM1*CFJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  240             IF(NORM) DUM2=DUM2*SQRT5
                  GO TO 300
  250             IF(NORM) DUM2=DUM2*SQRT3
  300             NN=NN+1
  310             DIJ(NN)=DUM2
c 
c
C                 The input argument ctr should contain the center of 
c                 fragment.
c
C                 Calcualte the translational vector, Pnt.
c                 Note: CTR -> center of fragment.
c                 pctr -> the unique center of product of primitive 
c                 Gaussian.
c
                  DO Iip=1,3
                     PNT(Iip)=pctr(Iip)-CTR(Iip)
                  ENDDO
c
C                 OBTAIN PA AND PB: the relative vector w.r.t. unique center P.
c
                  DO Iip=1,3
                     PA(Iip)=pctr(Iip)-C(Iip,IATOM)
                     PB(Iip)=pctr(Iip)-C(Iip,JATOM)
                  ENDDO
c
c                 Translational distance of y2y translation
c
                  TY2Y=SQRT(PNT(1)*PNT(1)+PNT(2)*PNT(2)+PNT(3)*PNT(3))
c
c                 Calculate pre-computable quantities for rotation based 
c                 multipole operation.
c
                  CALL GETZLL(ZLL,TY2Y,2*NPs+1)
                  CALL GETCOF2(NPs,FLM,ZLL,COEFF)
                  CALL ROTR(PNT,EZ,RT)
                  CALL GETROT(F,G,RT,NPs,CLM)
C
                  DO III=1,LNPs
                     PYP(III)=ZERO
                     YTP(III)=ZERO
                     YTP2(III)=ZERO
                  ENDDO
C
c
c                 Loop over basis set pair IJ
c
                  jp=0  
                  DO IB=iloc,iloc+maxi-mini
                     LIN=IB*(IB-1)/2
                     DO JB=jloc,jloc+maxj-minj
                        LJN=JB+LIN
                        IF (IB.GE.JB) THEN
                           D2MAT=DA(LJN)
c                          IF (UROHF) D2MAT=D2MAT+BDMAT(LJN)
                           IF (IB.NE.JB) D2MAT=D2MAT*TWO
                           JP=JP+1
c
c                          Calculate multipole of a given pair of primitive 
c                          gaussian w.r.t. its unique center.
c
                          CALL MOMSPC(LIT,LJT,IB-iloc+MINI,JB-JLOC+MINJ,
     *                     Yp,PA,PB,AA,DIJ(JP))
c
c                          Sum up the density contracted multipoles.
c                          Since the same primitive products have the same 
c                          unique center, they can be added up.
c
                           DO IIi=1,LNPGP
                              PYP(IIi)=PYP(IiI)+D2MAT*Yp(IIi)
                           ENDDO
                        ENDIF
                     ENDDO
                  ENDDO
C
C                 TRANSLATE W.R.T. THE CENTER OF fragment AND SUM UP
C
                  CALL RY2YIR(LNPGP,LNPs,PYP,YTP2,YTP,LFG,F,G,NPs,COEFF)
                  DO IIi=1,LNPs
                     Ylm(IIi)=Ylm(IIi)+YTP2(IIi)
                  ENDDO
c              J primitive
               ENDDO
c           I primitive
            enddo
  700    continue 
c        J shell
         enddo
c     I shell
      enddo
      IF (GOPARR.and.nxt) CALL DDI_DLBRESET
c
c     The nuclei contributions
c
      kount = -1
      do ii=1,nat
        if(goparr) then
           kount=kount+1
           if(MOD(kount,NPROC).NE.me) goto 800
c          static load balancing
        endif
c
c        The translational vector w.r.t. center of fragment
c
         DO Iii=1,3
            PNT(Iii)=c(Iii,ii)-CTR(Iii)
         ENDDO
c
c        Translational distance of y2y translation
c
         TY2Y=SQRT(PNT(1)*PNT(1)+PNT(2)*PNT(2)+PNT(3)*PNT(3))
c
c        Calculate pre-computable quantities for rotation based
c        multipole operation.
c
         CALL GETZLL(ZLL,TY2Y,2*NPs+1)
         CALL GETCOF2(NPs,FLM,ZLL,COEFF)
         CALL ROTR(PNT,EZ,RT)
         CALL GETROT(F,G,RT,NPs,CLM)
C
         DO III=1,LNPs
            PYP(III)=ZERO
            YTP(III)=ZERO
            YTP2(III)=ZERO
         ENDDO
c
c        Since nuclei have point charges, we don't need integration.
c
         PYP(1)=zan(ii)
C
C        TRANSLATE W.R.T. THE CENTER OF fragment AND SUM UP
C
         CALL RY2YIR(LNPGP,LNPs,PYP,YTP2,YTP,LFG,F,G,NPs,COEFF)
         DO IIi=1,LNPs
            Ylm(IIi)=Ylm(IIi)+YTP2(IIi)
         ENDDO
c
  800    continue 
      enddo
c     Summation of Ylm over nodes is done elsewhere (in fmmfrg).
C
      RETURN
      END
C*MODULE fmomm  *DECK fmo_Yd
      SUBROUTINE fmo_yd(clm,flm,Ctr,da,Ylm,nps)
C
c     nps : The highest angluar momentum, l, which needs to be set 
c     before calling this routine. 
C     ctr : the geometric center of a given fragment should be given. 
c     Ylm : the multipole moment of a given fragment which will be
c           calculated in this routine.
c     da : density matrix of a given fragment.
C
C     THIS ROUTINE RETURNS Ylm(MULTIPOLE MOMENTS OF a given fragment.
c
c     Notes on fmo_Y, fmo_Yq, fmo_Yd.
c         fmo_Y: contains both electrons and nuclei
c         fmo_Yq: contains both electrons and nuclei but using approximatly
c                 formed populations.
c         fmo_Yd: contains electrons
C              
C     Ylm : COMPLEX[(NP+1)*(NP+2)/2]
C        
C     C. H. CHOI with D. G. Fedorov Jan 2011
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXSH=5000,MXGTOT=20000,MXATM=2000)
c     PARAMETER (RLN10=2.30258D+00)
      PARAMETER (ZERO=0.00D+00,TWO=2.0D+00,MAXNP=45)
      PARAMETER (MAXCOF=23821)
      PARAMETER (SQRT3=1.73205080756888D+00,SQRT5=2.23606797749979D+00)
      COMPLEX*16 Ylm, yp, PYP, YTP,YTP2  
      LOGICAL GOPARR,DSKWRK,MASWRK,QOPS,QFMM,IANDJ,DOUBLE,NORM,nxt
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /QMFM  / SIZE,EPS,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
      DIMENSION ctr(3),Ylm(((NP+1)*(NP+2))/2),
     *          F((MaxNP*(MaxNP+1)*(MaxNP+2)*4)/3+(MaxNP+1)),
     *          CLM(-MaxNP:MaxNP),
     *          G((MaxNP*(MaxNP+1)*(MaxNP+2)*4)/3+(MaxNP+1)),
     *          FLM(-MaxNP:MaxNP),
     *          COEFF(MAXCOF,2),ZLL(0:2*MaxNP+1),
     *          PYP(((MAXNP+1)*(MAXNP+2))/2),
     *          YTP(((MAXNP+1)*(MAXNP+2))/2),
     *          YTP2(((MAXNP+1)*(MAXNP+2))/2),
     *          YP(((MAXNP+1)*(MAXNP+2))/2),
     *          DA(*),RT(3,3),PNT(4),pctr(3),EZ(3)
      DIMENSION PA(3),PB(3),DIJ(255)
c     DATA UHF,ROHF/8HUHF     ,8HROHF     /
C     
      NORM=NORMF.NE.1.OR.NORMP.NE.1
C
c     TOL=RLN10*ITOL
C     
      LNPs=((NPs+1)*(NPs+2))/2
      LFG=(NPs*(NPs+1)*(NPs+2)*4)/3+(NPs+1)
      LNPGP=((NPGP+1)*(NPGP+2))/2
c
C     zeroing out 
c
      DO I=1,LNPs
         Ylm(I)=ZERO
      ENDDO
C
c     z-xis
c
      EZ(1)=0.0D+00
      EZ(2)=0.0D+00
      EZ(3)=1.0D+00
c
      NXT = IBTYP.EQ.1
      NEXT  = -1
      kount = -1
c
c     We first calculate the electron contributions.
C
c     First shell loop.
c
      DO II=1,NSHELL
         Iatom=KATOM(II)
         XI=C(1,iatom)
         YI=C(2,iatom)
         ZI=C(3,iatom)
         I1=KSTART(II)
         I2=I1+KNG(II)-1
         MINI=KMIN(II)
         MAXI=KMAX(II)
         LIT=KTYPE(II)
         ILOC=KLOC(II)
C
C        SECOND SHELL LOOP.
C
         DO JJ=1,II
           if(goparr) then
              kount=kount+1
              if(nxt) then
                 IF(kount.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
                 if(NEXT.ne.kount) goto 700
              else
                 if(MOD(kount,NPROC).NE.me) goto 700
              endif
            endif
            Jatom=KATOM(JJ)
            XJ=C(1,Jatom)
            YJ=C(2,Jatom)
            ZJ=C(3,Jatom)
            J1=KSTART(JJ)
            J2=J1+KNG(JJ)-1
            MINJ=KMIN(JJ)
            MAXJ=KMAX(JJ)
            LJT=KTYPE(JJ)
            JLOC=KLOC(JJ)
            RR=(XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
            IANDJ=II.EQ.JJ
c
C           Loop over primitive Gaussians
C
C           I PRIMITIVE.
C
            JGMAX=J2
            DO IG=I1,I2
               AI=EX(IG)
               ARRI=AI*RR
               AXI=AI*XI
               AYI=AI*YI
               AZI=AI*ZI
               CSI=CS(IG)
               CPI=CP(IG)
               CDI=CD(IG)
               CFI=CF(IG)
c
C              J PRIMITIVE
c
               IF(IANDJ) JGMAX=IG
               DO JG=J1,JGMAX
c
                  AJ=EX(JG)
                  AA=AI+AJ
                  DUM=AJ*ARRI/AA
c                  IF(DUM.GT.TOL) GO TO 6000
c
c                 The unique center of the primitive Gaussian product
c
                  pctr(1)=(AXI+AJ*XJ)/AA
                  pctr(2)=(AYI+AJ*YJ)/AA
                  pctr(3)=(AZI+AJ*ZJ)/AA
c
                  CSJ=CS(JG)
                  CPJ=CP(JG)
                  CDJ=CD(JG)
                  CFJ=CF(JG)
C
                  FAC= EXP(-DUM)
C
                  DOUBLE=IANDJ.AND.IG.NE.JG
                  MAX=MAXJ
                  NN=0
                  DO 310 I=MINI,MAXI
                  GO TO ( 70, 80,180,180, 90,180,180,101,180,180,
     *            110,180,180,120,180,180,180,180,180,130),I
   70             DUM1=CSI*FAC
                  GO TO 180
   80             DUM1=CPI*FAC
                  GO TO 180
   90             DUM1=CDI*FAC
                  GO TO 180
  101             IF(NORM) DUM1=DUM1*SQRT3
                  GO TO 180
  110             DUM1=CFI*FAC
                  GO TO 180
  120             IF(NORM) DUM1=DUM1*SQRT5
                  GO TO 180
  130             iF(NORM) DUM1=DUM1*SQRT3
  180             IF(IANDJ) MAX=I
                  DO 310 J=MINJ,MAX
                  GO TO (190,200,300,300,210,300,300,220,300,300,
     *            230,300,300,240,300,300,300,300,300,250),J
  190             DUM2=DUM1*CSJ
                  IF(.NOT.DOUBLE) GO TO 300
                  IF(I.GT.1) GO TO 195
                  DUM2=DUM2+DUM2
                  GO TO 300
  195             DUM2=DUM2+CSI*CPJ*FAC
                  GO TO 300
  200             DUM2=DUM1*CPJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  210             DUM2=DUM1*CDJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  220             IF(NORM) DUM2=DUM2*SQRT3
                  GO TO 300
  230             DUM2=DUM1*CFJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  240             IF(NORM) DUM2=DUM2*SQRT5
                  GO TO 300
  250             IF(NORM) DUM2=DUM2*SQRT3
  300             NN=NN+1
  310             DIJ(NN)=DUM2
c 
c
C                 The input argument ctr should contain the center of 
c                 fragment.
c
C                 Calcualte the translational vector, Pnt.
c                 Note: CTR -> center of fragment.
c                 pctr -> the unique center of product of primitive 
c                 Gaussian.
c
                  DO Iip=1,3
                     PNT(Iip)=pctr(Iip)-CTR(Iip)
                  ENDDO
c
C                 OBTAIN PA AND PB: the relative vector w.r.t. unique center P.
c
                  DO Iip=1,3
                     PA(Iip)=pctr(Iip)-C(Iip,IATOM)
                     PB(Iip)=pctr(Iip)-C(Iip,JATOM)
                  ENDDO
c
c                 Translational distance of y2y translation
c
                  TY2Y=SQRT(PNT(1)*PNT(1)+PNT(2)*PNT(2)+PNT(3)*PNT(3))
c
c                 Calculate pre-computable quantities for rotation based 
c                 multipole operation.
c
                  CALL GETZLL(ZLL,TY2Y,2*NPs+1)
                  CALL GETCOF2(NPs,FLM,ZLL,COEFF)
                  CALL ROTR(PNT,EZ,RT)
                  CALL GETROT(F,G,RT,NPs,CLM)
C
                  DO III=1,LNPs
                     PYP(III)=ZERO
                     YTP(III)=ZERO
                     YTP2(III)=ZERO
                  ENDDO
C
c
c                 Loop over basis set pair IJ
c
                  jp=0  
                  DO IB=iloc,iloc+maxi-mini
                     LIN=IB*(IB-1)/2
                     DO JB=jloc,jloc+maxj-minj
                        LJN=JB+LIN
                        IF (IB.GE.JB) THEN
                           D2MAT=DA(LJN)
c                          IF (UROHF) D2MAT=D2MAT+BDMAT(LJN)
                           IF (IB.NE.JB) D2MAT=D2MAT*TWO
                           JP=JP+1
c
c                          Calculate multipole of a given pair of primitive 
c                          gaussian w.r.t. its unique center.
c
                          CALL MOMSPC(LIT,LJT,IB-iloc+MINI,JB-JLOC+MINJ,
     *                     Yp,PA,PB,AA,DIJ(JP))
c
c                          Sum up the density contracted multipoles.
c                          Since the same primitive products have the same 
c                          unique center, they can be added up.
c
                           DO IIi=1,LNPGP
                              PYP(IIi)=PYP(IiI)+D2MAT*Yp(IIi)
                           ENDDO
                        ENDIF
                     ENDDO
                  ENDDO
C
C                 TRANSLATE W.R.T. THE CENTER OF fragment AND SUM UP
C
                  CALL RY2YIR(LNPGP,LNPs,PYP,YTP2,YTP,LFG,F,G,NPs,COEFF)
                  DO IIi=1,LNPs
                     Ylm(IIi)=Ylm(IIi)+YTP2(IIi)
                  ENDDO
c              J primitive
               ENDDO
c           I primitive
            enddo
  700    continue 
c        J shell
         enddo
c     I shell
      enddo
      IF (GOPARR.and.nxt) CALL DDI_DLBRESET
c
      if(goparr) call ddi_gsumf(2417,Ylm,LNPs*2)
C
      RETURN
      END
C*MODULE fmomm  *DECK fmo_Yq
      SUBROUTINE fmo_yq(clm,flm,Ctr,Pa,Ylm,nps,addp)
C
c     np : The highest angluar momentum, l, which needs to be set 
c     before calling this routine. It is defined in QMFM common block.
C     ctr : the geometric center of a given fragment should be given. 
c     Ylm : the multipole moment of a given fragment which will be
c           calculated in this routine.
c     Pa : Atomic population.
C
C     THIS ROUTINE RETURNS Ylm(MULTIPOLE MOMENTS OF a given fragment of
C     FMO) on the basis of Atomic population.
C              
C     Ylm : COMPLEX[(NP+1)*(NP+2)/2]
C        
C     C. H. CHOI with D. G. Fedorov Jan 2011
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXATM=2000,MAXCOF=23821)
      PARAMETER (ZERO=0.00D+00,MAXNP=45)
      COMPLEX*16 Ylm, PYP, YTP,YTP2  
      LOGICAL GOPARR,DSKWRK,MASWRK,QOPS,QFMM,addp
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /QMFM  / SIZE,EPS,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
      DIMENSION ctr(3),Ylm(((NP+1)*(NP+2))/2),
     *          F((MaxNP*(MaxNP+1)*(MaxNP+2)*4)/3+(MaxNP+1)),
     *          CLM(-MaxNP:MaxNP),
     *          G((MaxNP*(MaxNP+1)*(MaxNP+2)*4)/3+(MaxNP+1)),
     *          FLM(-MaxNP:MaxNP),
     *          COEFF(MAXCOF,2),ZLL(0:2*MaxNP+1),
     *          PYP(((MAXNP+1)*(MAXNP+2))/2),
     *          YTP(((MAXNP+1)*(MAXNP+2))/2),
     *          YTP2(((MAXNP+1)*(MAXNP+2))/2),
     *          pA(*),RT(3,3),PNT(4),EZ(3)
c     DATA UHF,ROHF/8HUHF     ,8HROHF     /
C     
      LNPs=((NPs+1)*(NPs+2))/2
      LFG=(NPs*(NPs+1)*(NPs+2)*4)/3+(NPs+1)
      LNPGP=((NPGP+1)*(NPGP+2))/2
c
C     zeroing out 
c
      DO I=1,LNPs
         Ylm(I)=ZERO
      ENDDO
C
c     z-xis
c
      EZ(1)=0.0D+00
      EZ(2)=0.0D+00
      EZ(3)=1.0D+00
c
c     NXT = IBTYP.EQ.1
c     NEXT  = -1
      kount = -1
c
c     The nuclei contributions
c
      kount = -1
      do ii=1,nat
        if(goparr) then
           kount=kount+1
           if(MOD(kount,NPROC).NE.me) goto 800
c          static load balancing
        endif
c
c        The translational vector w.r.t. center of fragment
c
         DO Iii=1,3
            PNT(Iii)=c(Iii,ii)-CTR(Iii)
         ENDDO
c
c        Translational distance of y2y translation
c
         TY2Y=SQRT(PNT(1)*PNT(1)+PNT(2)*PNT(2)+PNT(3)*PNT(3))
c
c        Calculate pre-computable quantities for rotation based
c        multipole operation.
c
         CALL GETZLL(ZLL,TY2Y,2*NPs+1)
         CALL GETCOF2(NPs,FLM,ZLL,COEFF)
         CALL ROTR(PNT,EZ,RT)
         CALL GETROT(F,G,RT,NPs,CLM)
C
         DO III=1,LNPs
            PYP(III)=ZERO
            YTP(III)=ZERO
            YTP2(III)=ZERO
         ENDDO
c
c        Since nuclei have point charges, we don't need integration.
c
         if(addp) then
           PYP(1)=zan(ii)-Pa(ii)
         else 
           PYP(1)=zan(ii)
         endif 
C
C        TRANSLATE W.R.T. THE CENTER OF fragment AND SUM UP
C
         CALL RY2YIR(LNPGP,LNPs,PYP,YTP2,YTP,LFG,F,G,NPs,COEFF)
         DO IIi=1,LNPs
            Ylm(IIi)=Ylm(IIi)+YTP2(IIi)
         ENDDO
c
  800    continue 
      enddo
c     Summation of Ylm over nodes is done elsewhere (in fmmfrg).
C
      RETURN
      END
C*MODULE fmomm  *DECK esdimfmm_m
C>
C>     @brief ES dimer energy with multipoles. 
C>
C>     @details Calculate ES dimer energy with multipoles.
c>     The multicenter version of esdimFMM.
c>     This rountine calculates Eij dimer energy using density contracted regular
c>     Spherical Harmonics of Ylmi and Ylmj.
c>     Note the Ylmi and Ylmj are represented w.r.t. their own geometric
c>     center of fragments. In order to obtain Eij, the center of expasion
c>     of Ylmj should be converted irrgular Spherical Harmonics represented
c>     w.r.t. that of Ylmi, or vice versa.
c>
c>     It does nearly the same calculation of fmmfrg, except that it does
c>     it with each i and j pair energy.
c>
C>     @author Cheol Ho Choi
C>     
C>     @param ifg : fragment I
C>
C>     @param jfg : fragment J
C>
C>     @param ilay : layer I
C>
C>     @param ctri : center of fragment I
C>
C>     @param ctrj : center of fragment J
C>
C>     @param clm : C(LM)
C>
C>     @param flm : F(LM)
C>
C>     @param nps : The number of angular momentum
C>
C>     @param t : Difference vector
C>
C>     @param ty2z : distance of y2z transfer
C>
C>     @param ylmi : Ylm of fragment I
C>
C>     @param ylmj : Ylm of fragment J
C>
C>     @param Eij : Interaction energy between I and J fragments
C>
      SUBROUTINE esdimfmm_m(ifg,jfg,ilay,
     *                    ctri,ctrj,clm,flm,nps,t,ty2z,ylmi,ylmj,Eij)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXATM=2000,MAXNP=45,MAXCOF=23821,MXRT=100)
      PARAMETER (one=1.0d+00,zero=0.0d+00)
      complex*16 Ylmi,Ylmj,czp,Zlmi
      LOGICAL QOPS,QFMM
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
      COMMON /QMFM  / SIZE,EPS,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
      DIMENSION F((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          G((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          CLM(-maxNP:maxNP),FLM(-maxNP:maxNP),
     *          COEFF(MAXCOF,2),ZLL(0:2*maxNP+1,2),
     *          CZP(((MAXNP+1)*(MAXNP+2))/2),
     *          ZlmI(((MAXNP+1)*(MAXNP+2))/2),
     *          YlmI(((NP+1)*(NP+2))/2,ncentm),
     *          YlmJ(((NP+1)*(NP+2))/2,ncentm),
     *          ctrI(4,ncentm),ctrJ(4,ncentm)
      dimension t(3),ez(3),rt(3,3)
c
c     Ylm are defined elsewhere (as Ylmfrg) with NP used to compute its 
c     leading dimension.
c     Therefore, the same NP from QMFM should be used to define Ylm,
c     although one can use a different one for calculations (NPs).
c
      if(iand(modfmm,2).eq.0) then 
c
c      Translational vector
c     
c      z-axis
c
       EZ(1)=zero
       EZ(2)=zero
       EZ(3)=one
c
c      Some pre-computable values for rotation based translation.
c
       LNPS=((NPS+1)*(NPS+2))/2
       LFGS=((NPS*(NPS+1)*(NPS+2)*4)/3)+(NPS+1)
       DO IIi=1,LNPs
        ZlmI(IIi)=dcmplx(zero,zero)
       ENDDO   
       Eij=zero
c
       write(6,*) 'ESDIMFMMM: Fragment pair=(',ifg,jfg,')'
c      The main loop for multicenter multipole calculation.
       do i=2,int(ctri(1,ncentm))+1
        do j=2,int(ctrj(1,ncentm))+1
         do k=1,3
          t(k)=ctri(k,i)-ctrj(k,j)
         enddo
         TY2Z=SQRT(T(1)*T(1)+T(2)*T(2)+T(3)*T(3))
         CALL GETZLL(ZLL,TY2Z,2*NPS+1)
         CALL GETCOF(NPS,FLM,ZLL,COEFF)
         CALL ROTR(T,EZ,RT)
         CALL GETROT(F,G,RT,NPS,CLM)
c
c        YlmJ of monomer J is converted to ZlmI of monomer I, which
c        will be accumulated in ZlmIn for multicenter of monomer I.
c        Likewise, ZlmJn will contain ZlmJ of monomer J.
c
         CALL RY2ZIR(LNPS,Ylmj(1,j),ZlmI,CZP,LFGS,F,G,NPS,COEFF(1,1))
c
c        The return value contains the Zlmj.
c
         call fmo0p(NPS,LNPS,YlmI(1,i),ZlmI(1),Eijm)
         Eij=Eij+Eijm
         enddo
        enddo
c
      else
        Eij=0
      endif
c     just to get the NR
      call makemol(ifg,jfg,0,ilay,1,0,0,0,0,0,0,.false.)
      enucr=ENUC(nat,Zan,C)
c
      RETURN
      END
C*MODULE fmomm  *DECK esdimfmm
C>
C>     @brief ES dimer energy with multipoles 
C>
C>     @details Calculate ES dimer energy with multipoles. 
C>
C>     @author Cheol Ho Choi
C>
      SUBROUTINE esdimfmm(ifg,jfg,ilay,clm,flm,nps,t,ty2z,ylmi,ylmj,Eij)
c     
c     This rountine calculates Eij using density contracted regular
c     Spherical Harmonics of Ylmi and Ylmj.
c     Note the Ylmi and Ylmj are represented w.r.t. their own geometric
c     center of fragments. In order to obtain Eij, the center of expasion
c     of Ylmj should be converted irrgular Spherical Harmonics represented
c     w.r.t. that of Ylmi, or vice versa.
c
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXATM=2000,MAXNP=45,MAXCOF=23821,MXRT=100)
      PARAMETER (one=1.0d+00,zero=0.0d+00)
      complex*16 Ylmi,Ylmj,czp,Zlmi
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
      DIMENSION F((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          G((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          CLM(-maxNP:maxNP),FLM(-maxNP:maxNP),
     *          COEFF(MAXCOF,2),ZLL(0:2*maxNP+1,2),
     *          CZP(((MAXNP+1)*(MAXNP+2))/2),
     *          Zlmi(((MAXNP+1)*(MAXNP+2))/2),
     *          Ylmi(*),Ylmj(*)
      dimension t(3),ez(3),rt(3,3)
c
c     Ylm are defined elsewhere (as Ylmfrg) with NP used to compute its 
c     leading dimension.
c     Therefore, the same NP from QMFM should be used to define Ylm,
c     although one can use a different one for calculations (NPs).
c
      if(iand(modfmm,2).eq.0) then 
c
c     Translational vector
c     
c     z-axis
c
      EZ(1)=zero
      EZ(2)=zero
      EZ(3)=one
c
c     Some pre-computable values for rotation based translation.
c
      LNPS=((NPS+1)*(NPS+2))/2
      LFGS=((NPS*(NPS+1)*(NPS+2)*4)/3)+(NPS+1)
      CALL GETZLL(ZLL,TY2Z,2*NPS+1)
      CALL GETCOF(NPS,FLM,ZLL,COEFF)
      CALL ROTR(T,EZ,RT)
      CALL GETROT(F,G,RT,NPS,CLM)
c
      CALL RY2ZIR(LNPS,YlmJ,ZlmI,CZP,LFGS,F,G,NPS,COEFF(1,1))
c
c     The return value contains the Zlmj.
c
      call fmo0p(NPS,LNPS,YlmI,ZlmI,Eij)
      else
        Eij=0
      endif
c     just to get the NR
      call makemol(ifg,jfg,0,ilay,1,0,0,0,0,0,0,.false.)
      enucr=ENUC(nat,Zan,C)
c
      RETURN
      END
C*MODULE fmomm  *DECK fmo_mmder
      SUBROUTINE fmo_mmder(l2,clm,flm,nps,ctri,dai,ZlmI,de,Vtilda)
c
c     This rountine calculates derivative of monomer i due to the monomer j
c     of dimer calculations.
c     The multipole of monomer i should be recalculated on the fly, since
c     the Ylmi is the sum of all multipoles, from which we can not obtain
c     the indivisual primitive Gaussian product terms.
c
c     Note that this routine assumes you already computed ZlmI for fragment I
c     due to the long-range potentials of all J, that are Rij.gt.Resdim.
c     So this routine assumes that contractions on J are already done.
c     Now this routine also returns the V tilda over mu-nu for Lagrangian.
c
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK,IANDJ,DOUBLE,NORM,nxt
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000)
      PARAMETER (MAXNP=45,MAXCOF=23821)
      PARAMETER (SQRT2=1.414213562373095D+00,
     *        TWO=2.0d+00,one=1.0d+00,zero=0.0d+00,
     *        SQRT3=1.73205080756888D+00,SQRT5=2.23606797749979D+00)
      complex*16 ZlmI,Zlm,Ylm,Ylm2,Tlm
      LOGICAL QOPS,QFMM
      COMMON /QMFM  / SIZE,EPS,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
c     COMMON /GRAD  / DE(3,MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      DIMENSION F((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          G((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          CLM(-maxNP:maxNP),FLM(-maxNP:maxNP),
     *          COEFF(MAXCOF,2),ZLL(0:2*maxNP+1,2),
     *          ZlmI(*),ctri(3),dai(*),
     *          Ylm(((MAXNP+1)*(MAXNP+2))/2),
     *          Ylm2(((MAXNP+1)*(MAXNP+2))/2),
     *          Tlm(((MAXNP+1)*(MAXNP+2))/2),
     *          Zlm(((MAXNP+1)*(MAXNP+2))/2),de(3,*),Vtilda(*)
      dimension DIJ(255),pa(3),pb(3),pctr(3),pnt(3),ez(3),rt(3,3)
c
c
c     Translational vector
c
c     z-axis
c
      call vclr(Vtilda,1,l2)
      EZ(1)=zero
      EZ(2)=zero
      EZ(3)=one
c
      LNPs=((NPs+1)*(NPs+2))/2
      LFGs=((NPs*(NPs+1)*(NPs+2)*4)/3)+(NPs+1)
      LNPGP=((NPGP+1)*(NPGP+2))/2
c     Note that derivative of Ylm requires one more term in Y'*Z
c     calculations.
      npgG=npgp+1
      NORM=NORMF.NE.1.OR.NORMP.NE.1
c
c     Now we go through every products of primitive Gaussians and
c     compute their derivative contributions.
c
      NXT = IBTYP.EQ.1
      NEXT  = -1
      kount = -1
c
c     We first calculate the electron contributions.
C
c     First shell loop.
c
      DO II=1,NSHELL
         Iatom=KATOM(II)
         XI=C(1,iatom)
         YI=C(2,iatom)
         ZI=C(3,iatom)
         I1=KSTART(II)
         I2=I1+KNG(II)-1
         MINI=KMIN(II)
         MAXI=KMAX(II)
         LIT=KTYPE(II)
         ILOC=KLOC(II)
C
C        SECOND SHELL LOOP.
C
         DO JJ=1,II
           if(goparr) then
              kount=kount+1
              if(nxt) then
                 IF(kount.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
                 if(NEXT.ne.kount) goto 700
              else
                 if(MOD(kount,NPROC).NE.me) goto 700
              endif
            endif
            Jatom=KATOM(JJ)
            XJ=C(1,Jatom)
            YJ=C(2,Jatom)
            ZJ=C(3,Jatom)
            J1=KSTART(JJ)
            J2=J1+KNG(JJ)-1
            MINJ=KMIN(JJ)
            MAXJ=KMAX(JJ)
            LJT=KTYPE(JJ)
            JLOC=KLOC(JJ)
c
            DFX=XI-XJ
            DFY=YI-YJ
            DFZ=ZI-ZJ
            RR=(XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
            IANDJ=II.EQ.JJ
c
C           Loop over primitive Gaussians
C
C           I PRIMITIVE.
C
            JGMAX=J2
            DO IG=I1,I2
               AI=EX(IG)
               ARRI=AI*RR
               AXI=AI*XI
               AYI=AI*YI
               AZI=AI*ZI
               CSI=CS(IG)
               CPI=CP(IG)
               CDI=CD(IG)
               CFI=CF(IG)
c
C              J PRIMITIVE
c
               IF(IANDJ) JGMAX=IG
               DO JG=J1,JGMAX
c
                  AJ=EX(JG)
                  AA=AI+AJ
                  DUM=AJ*ARRI/AA
c                  IF(DUM.GT.TOL) GO TO 6000
c
c                 The unique center of the primitive Gaussian product
c
                  pctr(1)=(AXI+AJ*XJ)/AA
                  pctr(2)=(AYI+AJ*YJ)/AA
                  pctr(3)=(AZI+AJ*ZJ)/AA
c
                  CSJ=CS(JG)
                  CPJ=CP(JG)
                  CDJ=CD(JG)
                  CFJ=CF(JG)
C
                  FAC= EXP(-DUM)
C
                  DOUBLE=IANDJ.AND.IG.NE.JG
                  MAX=MAXJ
                  NN=0
                  DO 310 I=MINI,MAXI
                  GO TO ( 70, 80,180,180, 90,180,180,101,180,180,
     *            110,180,180,120,180,180,180,180,180,130),I
   70             DUM1=CSI*FAC
                  GO TO 180
   80             DUM1=CPI*FAC
                  GO TO 180
   90             DUM1=CDI*FAC
                  GO TO 180
  101             IF(NORM) DUM1=DUM1*SQRT3
                  GO TO 180
  110             DUM1=CFI*FAC
                  GO TO 180
  120             IF(NORM) DUM1=DUM1*SQRT5
                  GO TO 180
  130             iF(NORM) DUM1=DUM1*SQRT3
  180             IF(IANDJ) MAX=I
                  DO 310 J=MINJ,MAX
                  GO TO (190,200,300,300,210,300,300,220,300,300,
     *            230,300,300,240,300,300,300,300,300,250),J
  190             DUM2=DUM1*CSJ
                  IF(.NOT.DOUBLE) GO TO 300
                  IF(I.GT.1) GO TO 195
                  DUM2=DUM2+DUM2
                  GO TO 300
  195             DUM2=DUM2+CSI*CPJ*FAC
                  GO TO 300
  200             DUM2=DUM1*CPJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  210             DUM2=DUM1*CDJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  220             IF(NORM) DUM2=DUM2*SQRT3
                  GO TO 300
  230             DUM2=DUM1*CFJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  240             IF(NORM) DUM2=DUM2*SQRT5
                  GO TO 300
  250             IF(NORM) DUM2=DUM2*SQRT3
  300             NN=NN+1
  310             DIJ(NN)=DUM2
c
c
C                 The input argument ctr should contain the center of
c                 fragment.
c
C                 Calcualte the translational vector, Pnt.
c                 Note: CTRi -> center of fragment i.
c                 pctr -> the unique center of product of primitive
c                 Gaussian.
c
                  DO Iip=1,3
                     PNT(Iip)=pctr(Iip)-CTRi(Iip)
                  ENDDO
c
C                 OBTAIN PA AND PB: the relative vector w.r.t. unique center P.
c
                  DO Iip=1,3
                     PA(Iip)=pctr(Iip)-C(Iip,IATOM)
                     PB(Iip)=pctr(Iip)-C(Iip,JATOM)
                  ENDDO
c
c                 Translational distance of z2z translation
c
                  Tz2z=SQRT(PNT(1)*PNT(1)+PNT(2)*PNT(2)+PNT(3)*PNT(3))
c
c                 Calculate pre-computable quantities for rotation based
c                 multipole operation.
c
                  CALL GETZLL(ZLL,Tz2z,2*NPs+1)
                  CALL GETCOF2(NPs,FLM,ZLL,COEFF)
                  CALL ROTR(PNT,EZ,RT)
                  CALL GETROT(F,G,RT,NPs,CLM)
C
c                 We shift the center of ZlmI from the center of fragment
c                 to the unique center of primitive Gaussian product.
c
                  CALL RZ2ZIR(LNPs,ZlmI,Zlm,Tlm,LFGs,F,G,NPs,FLM,ZLL)
C
c                 Loop over basis set pair IJ
c
                  jp=0
                  DO IB=iloc,iloc+maxi-mini
                     LIN=IB*(IB-1)/2
                     DO JB=jloc,jloc+maxj-minj
                        LJN=JB+LIN
                        IF (IB.GE.JB) THEN
                          JP=JP+1
c     Get Fragment I's Ylm of mu-nu without Density of mu-nu.
                          CALL MOMSPC(LIT,LJT,IB-ILOC+MINI,JB-JLOC+MINJ,
     *                         Ylm,PA,PB,AA,dij(jp))
                          call fmo0p(npgp,lnpgp,Ylm,Zlm,sum2)
c     V tilda
                          Vtilda(LJN)=Vtilda(LJN)+sum2
                          SUM=SUM2
                          IF (IB.NE.JB) SUM=SUM2*TWO
c     z direction
                          CALL MOMAB(LIT,LJT,IB-ILOC+MINI,JB-JLOC+MINJ,
     *                         YLM2,PA,PB,AI,AJ,AA,DIJ(JP),0,0,1)
                          CALL FPDER(IB,JB,NPGP,LNPGP,YLM2,Zlm,SUMPZ)
                          CALL FZDER(IB,JB,npgG,Ylm,Zlm,CLM,DAi(LJN),AI,
     *                         AJ,DFZ,SUM,SUMPZ,DZA,DZB)
c     x direction
                          CALL MOMAB(LIT,LJT,IB-ILOC+MINI,JB-JLOC+MINJ,
     *                         YLM2,PA,PB,AI,AJ,AA,DIJ(JP),1,0,0)
                          CALL FPDER(IB,JB,NPGP,LNPGP,YLM2,Zlm,SUMPX)
                          CALL FXDER(IB,JB,npgG,Ylm,Zlm,CLM,DAi(LJN),AI,
     *                         AJ,DFX,SUM,SUMPX,DXA,DXB)
c     y direction
                          CALL MOMAB(LIT,LJT,IB-ILOC+MINI,JB-JLOC+MINJ,
     *                    YLM2,PA,PB,AI,AJ,AA,DIJ(JP),0,1,0)
                          CALL FPDER(IB,JB,NPGP,LNPGP,YLM2,Zlm,SUMPY)
                          CALL FYDER(IB,JB,npgG,Ylm,Zlm,CLM,DAi(LJN),AI,
     *                         AJ,DFY,SUM,SUMPY,DYA,DYB)
C
                          DE(1,IATOM)=DE(1,IATOM)+DXA
                          DE(1,JATOM)=DE(1,JATOM)+DXB
                          DE(2,IATOM)=DE(2,IATOM)+DYA
                          DE(2,JATOM)=DE(2,JATOM)+DYB
                          DE(3,IATOM)=DE(3,IATOM)+DZA
                          DE(3,JATOM)=DE(3,JATOM)+DZB
c
                        ENDIF
                     ENDDO
                  ENDDO
c              J primitive
               ENDDO
c           I primitive
            enddo
  700    continue
c        J shell
         enddo
c     I shell
      enddo
      IF (GOPARR.and.nxt) CALL DDI_DLBRESET
c
c     The nuclei contributions
c
      kount = -1
      do ii=1,nat
        if(goparr) then
           kount=kount+1
           if(MOD(kount,NPROC).NE.me) goto 800
c          static load balancing
        endif
c
c        The translational vector w.r.t. center of fragment i
c
         DO Iii=1,3
            PNT(Iii)=c(Iii,ii)-CTRi(Iii)
         ENDDO
c
c        Translational distance of z2z translation
c
         Tz2z=SQRT(PNT(1)*PNT(1)+PNT(2)*PNT(2)+PNT(3)*PNT(3))
c
c
c        Calculate pre-computable quantities for rotation based
c        multipole operation.
c
         CALL GETZLL(ZLL,Tz2z,2*NPs+1)
         CALL GETCOF2(NPs,FLM,ZLL,COEFF)
         CALL ROTR(PNT,EZ,RT)
         CALL GETROT(F,G,RT,NPs,CLM)
C
c        We shift the center of ZlmI from the center of fragment
c        to the unique center of nuclei.
c
         CALL RZ2ZIR(LNPs,ZlmI,Zlm,Tlm,LFGs,F,G,NPs,FLM,ZLL)
C
c        Derivative of nucei contribution is very simple,
c        since nuclei have point charges.
c
         Ylm(1)=zan(ii)
C        z direction
         de(3,ii)=de(3,ii)+dreal(Ylm(1)*Zlm(2))
c        x direction
         de(1,ii)=de(1,ii)-sqrt2*dreal(Ylm(1))*dreal(Zlm(3))
c        y direction
         de(2,ii)=de(2,ii)-sqrt2*dreal(Ylm(1))*dimag(Zlm(3))
C
  800    continue
      enddo
C
c     Summation of DE over nodes is done elsewhere (in FMOX as FMODE via DE).
c     Summation of Tilda over nodes has to be done here.
      if(goparr) call ddi_gsumf(2416,Vtilda,l2)
c
      RETURN
      END
C*MODULE fmomm  *DECK fmo_mmder_M
C>
C>     @brief Derivative of ES dimer energy with multipoles. 
C>
C>     @details This routine calculates derivative of monomer 
C>     I due to the monomer J
C>     of dimer calculations with multiple expansion centers.
C>     Therefor it does the same calculation of fmo_mmder.
C>     Therefore, ZlmI should be ZlmI(*,ncentm). Likewise ctrI=ctrI(4,ncentm)
C>     The multipole of monomer I should be recalculated on the fly, since
C>     the YlmI is the sum of all multipoles, from which we can not obtain
C>     the indivisual primitive Gaussian product terms.
C>
C>     Note that this routine assumes you already computed ZlmI for fragment I
C>     due to the long-range potentials of all J, that are Rij.gt.Resdim.
C>     So this routine assumes that contractions on J are already done.
C>
C>     Now this routine also returns the V tilda over mu-nu for Lagrangian.
C>
C>     @author Cheol Ho Choi
C>
C>     @param l2 : matrix size
C>
C>     @param clm : C(LM)
C>
C>     @param flm : F(LM)
C>
C>     @param nps : angular momentum number
C>
C>     @param ctrI : center of fragment I
C>
C>     @param dai : density matrix
C>
C>     @param ZlmI : Z(LM) of fragment I
C>
C>     @param de : derivative matrix
C>
C>     @param Vtilda : V tilda
C>
      SUBROUTINE fmo_mmder_M(l2,clm,flm,nps,ctrI,dai,ZlmI,de,Vtilda)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK,IANDJ,DOUBLE,NORM,nxt
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000)
      PARAMETER (MAXNP=45,MAXCOF=23821)
      PARAMETER (SQRT2=1.414213562373095D+00,
     *        TWO=2.0d+00,one=1.0d+00,zero=0.0d+00,
     *        SQRT3=1.73205080756888D+00,SQRT5=2.23606797749979D+00)
      complex*16 ZlmI,Zlm,Ylm,Ylm2,Tlm
      LOGICAL QOPS,QFMM
      COMMON /QMFM  / SIZE,EPS,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
c     COMMON /GRAD  / DE(3,MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
      DIMENSION F((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          G((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          CLM(-maxNP:maxNP),FLM(-maxNP:maxNP),
     *          COEFF(MAXCOF,2),ZLL(0:2*maxNP+1,2),
     *          ZlmI(((NP+1)*(NP+2))/2,ncentm),
     *          ctrI(4,ncentm),dai(*),
     *          Ylm(((MAXNP+1)*(MAXNP+2))/2),
     *          Ylm2(((MAXNP+1)*(MAXNP+2))/2),
     *          Tlm(((MAXNP+1)*(MAXNP+2))/2),
     *          Zlm(((MAXNP+1)*(MAXNP+2))/2),de(3,*),Vtilda(*)
      dimension DIJ(255),pa(3),pb(3),pctr(3),pnt(3),ez(3),rt(3,3)
c
c
c     Translational vector
c
c     z-axis
c
c     write(IW,*) 'in FMO_MMDERS'
      call vclr(Vtilda,1,l2)
      EZ(1)=zero
      EZ(2)=zero
      EZ(3)=one
c
      LNPs=((NPs+1)*(NPs+2))/2
      LFGs=((NPs*(NPs+1)*(NPs+2)*4)/3)+(NPs+1)
      LNPGP=((NPGP+1)*(NPGP+2))/2
c     Note that derivative of Ylm requires one more term in Y'*Z
c     calculations.
      npgG=npgp+1
      NORM=NORMF.NE.1.OR.NORMP.NE.1
c
c     Now we go through every products of primitive Gaussians and
c     compute their derivative contributions.
c
      NXT = IBTYP.EQ.1
      NEXT  = -1
      kount = -1
c
c     We first calculate the electron contributions.
C
c     First shell loop.
c
      DO II=1,NSHELL
         Iatom=KATOM(II)
         XI=C(1,iatom)
         YI=C(2,iatom)
         ZI=C(3,iatom)
         I1=KSTART(II)
         I2=I1+KNG(II)-1
         MINI=KMIN(II)
         MAXI=KMAX(II)
         LIT=KTYPE(II)
         ILOC=KLOC(II)
C
C        SECOND SHELL LOOP.
C
         DO JJ=1,II
           if(goparr) then
              kount=kount+1
              if(nxt) then
                 IF(kount.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
                 if(NEXT.ne.kount) goto 700
              else
                 if(MOD(kount,NPROC).NE.me) goto 700
              endif
            endif
            Jatom=KATOM(JJ)
            XJ=C(1,Jatom)
            YJ=C(2,Jatom)
            ZJ=C(3,Jatom)
            J1=KSTART(JJ)
            J2=J1+KNG(JJ)-1
            MINJ=KMIN(JJ)
            MAXJ=KMAX(JJ)
            LJT=KTYPE(JJ)
            JLOC=KLOC(JJ)
c
            DFX=XI-XJ
            DFY=YI-YJ
            DFZ=ZI-ZJ
            RR=(XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
            IANDJ=II.EQ.JJ
c
C           Loop over primitive Gaussians
C
C           I PRIMITIVE.
C
            JGMAX=J2
            DO IG=I1,I2
               AI=EX(IG)
               ARRI=AI*RR
               AXI=AI*XI
               AYI=AI*YI
               AZI=AI*ZI
               CSI=CS(IG)
               CPI=CP(IG)
               CDI=CD(IG)
               CFI=CF(IG)
c
C              J PRIMITIVE
c
               IF(IANDJ) JGMAX=IG
               DO JG=J1,JGMAX
c
                  AJ=EX(JG)
                  AA=AI+AJ
                  DUM=AJ*ARRI/AA
c                  IF(DUM.GT.TOL) GO TO 6000
c
c                 The unique center of the primitive Gaussian product
c
                  pctr(1)=(AXI+AJ*XJ)/AA
                  pctr(2)=(AYI+AJ*YJ)/AA
                  pctr(3)=(AZI+AJ*ZJ)/AA
c
                  CSJ=CS(JG)
                  CPJ=CP(JG)
                  CDJ=CD(JG)
                  CFJ=CF(JG)
C
                  FAC= EXP(-DUM)
C
                  DOUBLE=IANDJ.AND.IG.NE.JG
                  MAX=MAXJ
                  NN=0
                  DO 310 I=MINI,MAXI
                  GO TO ( 70, 80,180,180, 90,180,180,101,180,180,
     *            110,180,180,120,180,180,180,180,180,130),I
   70             DUM1=CSI*FAC
                  GO TO 180
   80             DUM1=CPI*FAC
                  GO TO 180
   90             DUM1=CDI*FAC
                  GO TO 180
  101             IF(NORM) DUM1=DUM1*SQRT3
                  GO TO 180
  110             DUM1=CFI*FAC
                  GO TO 180
  120             IF(NORM) DUM1=DUM1*SQRT5
                  GO TO 180
  130             iF(NORM) DUM1=DUM1*SQRT3
  180             IF(IANDJ) MAX=I
                  DO 310 J=MINJ,MAX
                  GO TO (190,200,300,300,210,300,300,220,300,300,
     *            230,300,300,240,300,300,300,300,300,250),J
  190             DUM2=DUM1*CSJ
                  IF(.NOT.DOUBLE) GO TO 300
                  IF(I.GT.1) GO TO 195
                  DUM2=DUM2+DUM2
                  GO TO 300
  195             DUM2=DUM2+CSI*CPJ*FAC
                  GO TO 300
  200             DUM2=DUM1*CPJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  210             DUM2=DUM1*CDJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  220             IF(NORM) DUM2=DUM2*SQRT3
                  GO TO 300
  230             DUM2=DUM1*CFJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  240             IF(NORM) DUM2=DUM2*SQRT5
                  GO TO 300
  250             IF(NORM) DUM2=DUM2*SQRT3
  300             NN=NN+1
  310             DIJ(NN)=DUM2
c
c
C                 The input argument ctr should contain the center of
c                 fragment I.
c
C                 Calcualte the translational vector, Pnt.
c                 Note: CTRi -> center of fragment i.
c                 pctr -> the unique center of product of primitive
c                 Gaussian.
c
                  call getnear(0,pctr,ctrI(1,1),ncentm,idx,rDIST)
c        write(IW,*) 'fmo_mmders, idx',idx
                  DO Iip=1,3
                     PNT(Iip)=pctr(Iip)-ctrI(Iip,idx)
                  ENDDO
c
C                 OBTAIN PA AND PB: the relative vector w.r.t. unique center P.
c
                  DO Iip=1,3
                     PA(Iip)=pctr(Iip)-C(Iip,IATOM)
                     PB(Iip)=pctr(Iip)-C(Iip,JATOM)
                  ENDDO
c
c                 Translational distance of z2z translation
c
                  Tz2z=SQRT(PNT(1)*PNT(1)+PNT(2)*PNT(2)+PNT(3)*PNT(3))
c
c                 Calculate pre-computable quantities for rotation based
c                 multipole operation.
c
                  CALL GETZLL(ZLL,Tz2z,2*NPs+1)
                  CALL GETCOF2(NPs,FLM,ZLL,COEFF)
                  CALL ROTR(PNT,EZ,RT)
                  CALL GETROT(F,G,RT,NPs,CLM)
C
c                 We shift the center of ZlmI from the one of the centers of fragment
c                 to the unique center of primitive Gaussian product.
c
                  CALL RZ2ZIR(LNPs,ZlmI(1,idx),Zlm,Tlm,LFGs,F,G,NPs,
     *                 FLM,ZLL)
C
c                 Loop over basis set pair IJ
c
                  jp=0
                  DO IB=iloc,iloc+maxi-mini
                     LIN=IB*(IB-1)/2
                     DO JB=jloc,jloc+maxj-minj
                        LJN=JB+LIN
                        IF (IB.GE.JB) THEN
                          JP=JP+1
c     Get Fragment I's Ylm of mu-nu without Density of mu-nu.
                          CALL MOMSPC(LIT,LJT,IB-ILOC+MINI,JB-JLOC+MINJ,
     *                         Ylm,PA,PB,AA,dij(jp))
                          call fmo0p(npgp,lnpgp,Ylm,Zlm,sum2)
c     V tilda
                          Vtilda(LJN)=Vtilda(LJN)+sum2
                          SUM=SUM2
                          IF (IB.NE.JB) SUM=SUM2*TWO
c     z direction
                          CALL MOMAB(LIT,LJT,IB-ILOC+MINI,JB-JLOC+MINJ,
     *                         YLM2,PA,PB,AI,AJ,AA,DIJ(JP),0,0,1)
                          CALL FPDER(IB,JB,NPGP,LNPGP,YLM2,Zlm,SUMPZ)
                          CALL FZDER(IB,JB,npgG,Ylm,Zlm,CLM,DAi(LJN),AI,
     *                         AJ,DFZ,SUM,SUMPZ,DZA,DZB)
c     x direction
                          CALL MOMAB(LIT,LJT,IB-ILOC+MINI,JB-JLOC+MINJ,
     *                         YLM2,PA,PB,AI,AJ,AA,DIJ(JP),1,0,0)
                          CALL FPDER(IB,JB,NPGP,LNPGP,YLM2,Zlm,SUMPX)
                          CALL FXDER(IB,JB,npgG,Ylm,Zlm,CLM,DAi(LJN),AI,
     *                         AJ,DFX,SUM,SUMPX,DXA,DXB)
c     y direction
                          CALL MOMAB(LIT,LJT,IB-ILOC+MINI,JB-JLOC+MINJ,
     *                    YLM2,PA,PB,AI,AJ,AA,DIJ(JP),0,1,0)
                          CALL FPDER(IB,JB,NPGP,LNPGP,YLM2,Zlm,SUMPY)
                          CALL FYDER(IB,JB,npgG,Ylm,Zlm,CLM,DAi(LJN),AI,
     *                         AJ,DFY,SUM,SUMPY,DYA,DYB)
C
                          DE(1,IATOM)=DE(1,IATOM)+DXA
                          DE(1,JATOM)=DE(1,JATOM)+DXB
                          DE(2,IATOM)=DE(2,IATOM)+DYA
                          DE(2,JATOM)=DE(2,JATOM)+DYB
                          DE(3,IATOM)=DE(3,IATOM)+DZA
                          DE(3,JATOM)=DE(3,JATOM)+DZB
c
                        ENDIF
                     ENDDO
                  ENDDO
c              J primitive
               ENDDO
c           I primitive
            enddo
  700    continue
c        J shell
         enddo
c     I shell
      enddo
      IF (GOPARR.and.nxt) CALL DDI_DLBRESET
c
c     The nuclei contributions
c
      kount = -1
      do ii=1,nat
        if(goparr) then
           kount=kount+1
           if(MOD(kount,NPROC).NE.me) goto 800
c          static load balancing
        endif
c
c        The translational vector w.r.t. center of fragment i
c
         call getnear(0,c(1,ii),ctrI(1,1),ncentm,idx,rDIST)
         DO Iii=1,3
            PNT(Iii)=c(Iii,ii)-CTRi(Iii,idx)
         ENDDO
c
c        Translational distance of z2z translation
c
         Tz2z=SQRT(PNT(1)*PNT(1)+PNT(2)*PNT(2)+PNT(3)*PNT(3))
c
c
c        Calculate pre-computable quantities for rotation based
c        multipole operation.
c
         CALL GETZLL(ZLL,Tz2z,2*NPs+1)
         CALL GETCOF2(NPs,FLM,ZLL,COEFF)
         CALL ROTR(PNT,EZ,RT)
         CALL GETROT(F,G,RT,NPs,CLM)
C
c        We shift the center of ZlmI from the center of fragment
c        to the unique center of nuclei.
c
         CALL RZ2ZIR(LNPs,ZlmI(1,idx),Zlm,Tlm,LFGs,F,G,NPs,FLM,ZLL)
C
c        Derivative of nucei contribution is very simple,
c        since nuclei have point charges.
c
         Ylm(1)=zan(ii)
C        z direction
         de(3,ii)=de(3,ii)+dreal(Ylm(1)*Zlm(2))
c        x direction
         de(1,ii)=de(1,ii)-sqrt2*dreal(Ylm(1))*dreal(Zlm(3))
c        y direction
         de(2,ii)=de(2,ii)-sqrt2*dreal(Ylm(1))*dimag(Zlm(3))
C
  800    continue
      enddo
C
c     Summation of DE over nodes is done elsewhere (in FMOX as FMODE via DE).
c     Summation of Tilda over nodes has to be done here.
      if(goparr) call ddi_gsumf(2416,Vtilda,l2)
c
      RETURN
      END
C*MODULE FMOMM  *DECK Fmo0p
      SUBROUTINE Fmo0p(NP,LNP,YP,ZP,SUM)
C   
c     It calculates the basic multipole multiplications.
c
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMPLEX*16 YP, ZP
      PARAMETER (TWO=2.0D+00)
      DIMENSION ZP((NP+1)*(NP+2)/2),YP((NP+1)*(NP+2)/2)
C
      SUM=0.0D+00
      SUB=0.0D+00
      DO II=1,LNP
         SUM=SUM + DREAL(YP(II)*ZP(II))
      ENDDO
      IK=1
      DO II=0,NP
         IK=IK+II
         SUB=SUB + DREAL(YP(IK)*ZP(IK))
      ENDDO
      SUM=TWO*SUM-SUB
C
      RETURN
      END
C*MODULE fmomm  *DECK fmo_mmderq
      SUBROUTINE fmo_mmderq(clm,flm,nps,ctrIJ,daIJ,ZlmIJ,de)
c
c     This rountine calculates derivative of monomer i due to the monomer j
c     of dimer calculations.
c     The multipole of monomer i should be recalculated on the fly, since
c     the Ylmi is the sum of all multipoles, from which we can not obtain 
c     the indivisual primitive Gaussian product terms.
c
c     Note that this routine assumes you already computed ZlmIJ for fragment IJ
c     due to the long-range potentials of all J, that are Rij.gt.Resdim.
c     So this routine assumes that contractions on J are already done.
c     Now this routine also returns the V tilda over mu-nu for Lagrangian.
c
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK,IANDJ,DOUBLE,NORM,nxt
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000)
      PARAMETER (MAXNP=45,MAXCOF=23821)
      PARAMETER (one=1.0d+00,zero=0.0d+00,
     *        SQRT3=1.73205080756888D+00,SQRT5=2.23606797749979D+00)
      complex*16 ZlmIJ,Zlm,Ylm,Ylm2,Tlm
      LOGICAL QOPS,QFMM
      COMMON /QMFM  / SIZE,EPS,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
c     COMMON /GRAD  / DE(3,MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      DIMENSION F((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          G((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          CLM(-maxNP:maxNP),FLM(-maxNP:maxNP),
     *          COEFF(MAXCOF,2),ZLL(0:2*maxNP+1,2),
     *          ZlmIJ(*),ctrIJ(3),daIJ(*),
     *          Ylm(((MAXNP+1)*(MAXNP+2))/2),
     *          Ylm2(((MAXNP+1)*(MAXNP+2))/2),
     *          Tlm(((MAXNP+1)*(MAXNP+2))/2),
     *          Zlm(((MAXNP+1)*(MAXNP+2))/2),de(3,*)
      dimension DIJ(255),pa(3),pb(3),pctr(3),pnt(3),ez(3),rt(3,3)
c
c
c     Translational vector
c
c     z-axis
c
      EZ(1)=zero
      EZ(2)=zero
      EZ(3)=one
      npgG=npgp+1
c
      LNPs=((NPs+1)*(NPs+2))/2
      LFGs=((NPs*(NPs+1)*(NPs+2)*4)/3)+(NPs+1)
      LNPGP=((NPGP+1)*(NPGP+2))/2
      NORM=NORMF.NE.1.OR.NORMP.NE.1
cc
c     Now we go through every products of primitive Gaussians and 
c     compute their derivative contributions.
c
      NXT = IBTYP.EQ.1
      NEXT  = -1
      kount = -1
c
c     We first calculate the electron contributions.
C
c     First shell loop.
c
      DO II=1,NSHELL
         Iatom=KATOM(II)
         XI=C(1,iatom)
         YI=C(2,iatom)
         ZI=C(3,iatom)
         I1=KSTART(II)
         I2=I1+KNG(II)-1
         MINI=KMIN(II)
         MAXI=KMAX(II)
         LIT=KTYPE(II)
         ILOC=KLOC(II)
C
C        SECOND SHELL LOOP.
C
         DO JJ=1,II
           if(goparr) then
              kount=kount+1
              if(nxt) then
                 IF(kount.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
                 if(NEXT.ne.kount) goto 700
              else
                 if(MOD(kount,NPROC).NE.me) goto 700
              endif
            endif
            Jatom=KATOM(JJ)
            XJ=C(1,Jatom)
            YJ=C(2,Jatom)
            ZJ=C(3,Jatom)
            J1=KSTART(JJ)
            J2=J1+KNG(JJ)-1
            MINJ=KMIN(JJ)
            MAXJ=KMAX(JJ)
            LJT=KTYPE(JJ)
            JLOC=KLOC(JJ)
c
            DFX=XI-XJ
            DFY=YI-YJ
            DFZ=ZI-ZJ
            RR=(XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
            IANDJ=II.EQ.JJ
c
C           Loop over primitive Gaussians
C
C           I PRIMITIVE.
C
            JGMAX=J2
            DO IG=I1,I2
               AI=EX(IG)
               ARRI=AI*RR
               AXI=AI*XI
               AYI=AI*YI
               AZI=AI*ZI
               CSI=CS(IG)
               CPI=CP(IG)
               CDI=CD(IG)
               CFI=CF(IG)
c
C              J PRIMITIVE
c
               IF(IANDJ) JGMAX=IG
               DO JG=J1,JGMAX
c
                  AJ=EX(JG)
                  AA=AI+AJ
                  DUM=AJ*ARRI/AA
c                  IF(DUM.GT.TOL) GO TO 6000
c
c                 The unique center of the primitive Gaussian product
c
                  pctr(1)=(AXI+AJ*XJ)/AA
                  pctr(2)=(AYI+AJ*YJ)/AA
                  pctr(3)=(AZI+AJ*ZJ)/AA
c
                  CSJ=CS(JG)
                  CPJ=CP(JG)
                  CDJ=CD(JG)
                  CFJ=CF(JG)
C
                  FAC= EXP(-DUM)
C
                  DOUBLE=IANDJ.AND.IG.NE.JG
                  MAX=MAXJ
                  NN=0
                  DO 310 I=MINI,MAXI
                  GO TO ( 70, 80,180,180, 90,180,180,101,180,180,
     *            110,180,180,120,180,180,180,180,180,130),I
   70             DUM1=CSI*FAC
                  GO TO 180
   80             DUM1=CPI*FAC
                  GO TO 180
   90             DUM1=CDI*FAC
                  GO TO 180
  101             IF(NORM) DUM1=DUM1*SQRT3
                  GO TO 180
  110             DUM1=CFI*FAC
                  GO TO 180
  120             IF(NORM) DUM1=DUM1*SQRT5
                  GO TO 180
  130             iF(NORM) DUM1=DUM1*SQRT3
  180             IF(IANDJ) MAX=I
                  DO 310 J=MINJ,MAX
                  GO TO (190,200,300,300,210,300,300,220,300,300,
     *            230,300,300,240,300,300,300,300,300,250),J
  190             DUM2=DUM1*CSJ
                  IF(.NOT.DOUBLE) GO TO 300
                  IF(I.GT.1) GO TO 195
                  DUM2=DUM2+DUM2
                  GO TO 300
  195             DUM2=DUM2+CSI*CPJ*FAC
                  GO TO 300
  200             DUM2=DUM1*CPJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  210             DUM2=DUM1*CDJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  220             IF(NORM) DUM2=DUM2*SQRT3
                  GO TO 300
  230             DUM2=DUM1*CFJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  240             IF(NORM) DUM2=DUM2*SQRT5
                  GO TO 300
  250             IF(NORM) DUM2=DUM2*SQRT3
  300             NN=NN+1
  310             DIJ(NN)=DUM2
c
c
C                 The input argument ctr should contain the center of
c                 fragment.
c
C                 Calcualte the translational vector, Pnt.
c                 Note: CTRIJ -> center of dimer IJ.
c                 pctr -> the unique center of product of primitive
c                 Gaussian.
c
                  DO Iip=1,3
                     PNT(Iip)=pctr(Iip)-CTRij(Iip)
                  ENDDO
c
C                 OBTAIN PA AND PB: the relative vector w.r.t. unique center P.
c
                  DO Iip=1,3
                     PA(Iip)=pctr(Iip)-C(Iip,IATOM)
                     PB(Iip)=pctr(Iip)-C(Iip,JATOM)
                  ENDDO
c
c                 Translational distance of z2z translation
c
                  Tz2z=SQRT(PNT(1)*PNT(1)+PNT(2)*PNT(2)+PNT(3)*PNT(3))
c
c                 Calculate pre-computable quantities for rotation based
c                 multipole operation.
c
                  CALL GETZLL(ZLL,Tz2z,2*NPs+1)
                  CALL GETCOF2(NPs,FLM,ZLL,COEFF)
                  CALL ROTR(PNT,EZ,RT)
                  CALL GETROT(F,G,RT,NPs,CLM)
C
c                 We shift the center of ZlmIJ from the center of fragment
c                 to the unique center of primitive Gaussian product.
c
                  CALL RZ2ZIR(LNPs,ZlmIJ,Zlm,Tlm,LFGs,F,G,NPs,FLM,ZLL)
C
c                 Loop over basis set pair IJ
c
                  jp=0
                  DO IB=iloc,iloc+maxi-mini
                     LIN=IB*(IB-1)/2
                     DO JB=jloc,jloc+maxj-minj
                        LJN=JB+LIN
                        IF (IB.GE.JB) THEN
                          JP=JP+1
c
                          CALL MOMSPC(LIT,LJT,IB-ILOC+MINI,JB-JLOC+MINJ,
     *                         Ylm,PA,PB,AA,DIJ(JP))
                          CALL F0DER(IB,JB,NPGP,LNPGP,Ylm,Zlm,SUM)
c     z direction
                          CALL MOMAB(LIT,LJT,IB-ILOC+MINI,JB-JLOC+MINJ,
     *                         YLM2,PA,PB,AI,AJ,AA,DIJ(JP),0,0,1)
                          CALL FPDER(IB,JB,NPGP,LNPGP,YLM2,Zlm,SUMPZ)
                          CALL FZDER(IB,JB,npgg,Ylm,Zlm,CLM,DAij(LJN),AI
     *                        ,AJ,DFZ,SUM,SUMPZ,DZA,DZB)
c     x direction
                          CALL MOMAB(LIT,LJT,IB-ILOC+MINI,JB-JLOC+MINJ,
     *                         YLM2,PA,PB,AI,AJ,AA,DIJ(JP),1,0,0)
                          CALL FPDER(IB,JB,NPGP,LNPGP,YLM2,Zlm,SUMPX)
                          CALL FXDER(IB,JB,NPGg,Ylm,Zlm,CLM,DAij(LJN),AI
     *                        ,AJ,DFX,SUM,SUMPX,DXA,DXB)
c     y direction
                          CALL MOMAB(LIT,LJT,IB-ILOC+MINI,JB-JLOC+MINJ,
     *                    YLM2,PA,PB,AI,AJ,AA,DIJ(JP),0,1,0)
                          CALL FPDER(IB,JB,NPGP,LNPGP,YLM2,Zlm,SUMPY)
                          CALL FYDER(IB,JB,NPGg,Ylm,Zlm,CLM,DAij(LJN),AI
     *                        ,AJ,DFY,SUM,SUMPY,DYA,DYB)
C
                          DE(1,IATOM)=DE(1,IATOM)+DXA
                          DE(1,JATOM)=DE(1,JATOM)+DXB
                          DE(2,IATOM)=DE(2,IATOM)+DYA
                          DE(2,JATOM)=DE(2,JATOM)+DYB
                          DE(3,IATOM)=DE(3,IATOM)+DZA
                          DE(3,JATOM)=DE(3,JATOM)+DZB
c
                        ENDIF
                     ENDDO
                  ENDDO
c              J primitive
               ENDDO
c           I primitive
            enddo
  700    continue
c        J shell
         enddo
c     I shell
      enddo
      IF (GOPARR.and.nxt) CALL DDI_DLBRESET
c
      RETURN
      END
C*MODULE FMOmm  *DECK BASEXT
      SUBROUTINE BASEXT(Center,radius)
C
C     THIS ROUTINE checks all products of basis sets of each monomer
C     and get largest distribtion of basis set products.
c     center(3) : position of monomer center
c     radius : radius of monomer, which will be changed in this routine.
C     DPGD is the maximum approximation error.
c
c     It returns new center and corresponding radius of monomer.
CC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXSH=5000,MXGTOT=20000,MXATM=2000)
      PARAMETER (RLN10=2.30258D+00)
      PARAMETER (ONE=1.0D+00)
C
      LOGICAL IANDJ,QOPS,QFMM
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
c     COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
c     COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /QMFM  / SIZE,EPS,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
      dimension center(3)
C
      TOL=RLN10*ITOL
C
C     COMPUTE BASE EXTENT AND PRINT OUT THE RESULTS.
C     THE FOLLOWING LINE REQUIRES INVERSE ERROR FUNCTION, DERFINV.
C
c     rMAX=radius
      BEX=SQRT(2.0D+00)*DERFINV(ONE-DPGD)
c     BEX=DERFINV(ONE-DPGD)
      pair_counter=0
      rMM_SUM=0
      rMM_MAX=0
      rDIST_SUM=0
C
C
C     FIRST SHELL LOOP.
C
      DO II=1,NSHELL
         I=KATOM(II)
         XI=C(1,I)
         YI=C(2,I)
         ZI=C(3,I)
         I1=KSTART(II)
         I2=I1+KNG(II)-1
c        MINI=KMIN(II)
c        MAXI=KMAX(II)
C
C        SECOND SHELL LOOP.
C
         DO JJ=1,II
            J=KATOM(JJ)
            XJ=C(1,J)
            YJ=C(2,J)
            ZJ=C(3,J)
            J1=KSTART(JJ)
            J2=J1+KNG(JJ)-1
c           MINJ=KMIN(JJ)
c           MAXJ=KMAX(JJ)
            RR=(XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
            IANDJ=II.EQ.JJ
C
C           PREPARE INDICES FOR PAIRS OF (I,J) FUNCTIONS.
C
c           MAX=MAXJ
C
C           I PRIMITIVE.
C
C    IJP : INDEX OF PRIMITIVE PAIR
C
            IJP=0
            JGMAX=J2
            DO IG=I1,I2
c              IGP=IG-I1+1
               AI=EX(IG)
               ARRI=AI*RR
               AXI=AI*XI
               AYI=AI*YI
               AZI=AI*ZI
C              J PRIMITIVE.
               IF(IANDJ) JGMAX=IG
               DO JG=J1,JGMAX
c                 JGP=JG-J1+1
                  AJ=EX(JG)
                  AA=AI+AJ
                  DUM=AJ*ARRI/AA
                  IF(DUM.GT.TOL) GO TO 6000
                  IJP=IJP+1
                  AX=(AXI+AJ*XJ)/AA
                  AY=(AYI+AJ*YJ)/AA
                  AZ=(AZI+AJ*ZJ)/AA
c
c         compute the distance beween the center of monomer and
c         current primitive gaussian product' position.
c
                  pair_counter=pair_counter+1
                  rdist=sqrt((ax-center(1))**2+(ay-center(2))**2
     *                  +(az-center(3))**2)
                  rMM=BEX/SQRT(AA)
c
                  rMM_SUM=rMM_SUM+rMM
                  rDIST_SUM=rDIST_SUM+rdist
                  if (rMM.gt.rMM_MAX) rMM_MAX=rMM
c
c         Now calculate r=(radius+rMM+rdist)/2
c
c                  r=(radius+rMM+rdist)/2
c                  if (r.gt.rMAX) then
c                     rMAX=r
c                     vecb(1)=ax
c                     vecb(2)=ay
c                     vecb(3)=az
c                     b_a=rdist
c                   endif
c
6000           ENDDO
            ENDDO
C           END OF PRIMITIVE GAUSSIAN PAIR
         ENDDO
      ENDDO
C
c     Now we don't shift the center.
c     We only change radius on the basis of averaged rDIST and rMM.
c
c     Factor : the weight factor for diffuse functions.
      Factor = 0
      rMM=(one-factor)*rMM_SUM/pair_counter+Factor*rMM_MAX
      rDIST=rDIST_SUM/pair_counter
      if ((rMM+rDIST).gt.radius) radius=(radius+rMM+rdist)/2
c
c     we shift our center
c
c      vcx=center(1)+(vecb(1)-center(1))/b_a*(rMAX-radius) 
c      vcy=center(2)+(vecb(2)-center(2))/b_a*(rMAX-radius) 
c      vcz=center(3)+(vecb(3)-center(3))/b_a*(rMAX-radius) 
c      center(1)=vcx
c      center(2)=vcy
c      center(3)=vcz
c      radius=rMAX
c
      RETURN
      END
C*MODULE fmomm  *DECK fmmfrag
C>
C>     @brief Fock matrix with multipoles 
C>
C>     @details Calculates Fock matrix with multipoles.
C>
C>     @author Cheol Ho Choi
C>
      subroutine fmmfrag(ilay,loadhf,loadm,layfrg,scffrg,
     *                  iodfmo,orbxch,da,nZi,irec0,
     *                  ncentm,clm,flm,crfrg,Ylmfrg,Zlmfrg)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL isgddi,parout,INITGDDI,QOPS,QFMM,GOPARR,DSKWRK,MASWRK,
     *        myjob,orbxch,wasgddi
      Integer ddi_world,ddi_group
      Parameter(ddi_world=0,ddi_group=1)
      parameter(MXATM=2000,maxnp=45,ZERO=0.0D+00,ONE=1.0D+00)
      PARAMETER (MAXCOF=23821)
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /QMFM  / SIZE,EPS,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      complex*16 Ylmfrg(((NP+1)*(NP+2))/2,ncentm,nfg),
     *           CLM(-maxNP:maxNP),FLM(-maxNP:maxNP),
     *           Zlmfrg(((NP+1)*(NP+2))/2,ncentm,nfg),
     *           CZP((MAXNP+1)*(MAXNP+2)/2),
     *           Zlmj(((MAXNP+1)*(MAXNP+2))/2)
      dimension loadm(*),layfrg(*),scffrg(*),da(*),
     *          nZi(*),iodfmo(*),crfrg(4,ncentm,nfg)
      DIMENSION F((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          G((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          COEFF(MAXCOF,2),ZLL(0:2*maxNP+1,2)
      dimension t(3),ez(3),rt(3,3)
c
      DATA RMC/8HMCSCF   /,RNONE/8HNONE    /,UHF/8HUHF     /
c
c     This is the main driver to construct Fock Matrix of Monomer of FMO
c
C     Things need to obtain before doing any multipole operation.     
      if(maswrk) write(iw,*) 'Multipole generation for ESP begins.'
c     ifmostp=6
c     This is needed for the gradient addition.
c     It may be better to assign a unique number but for now just this.
c
C     GET TABLE FOR 1-ELECTRON INTEGRAL
      CALL GXYZLM
C     
      LNP=((NP+1)*(NP+2))/2
c     the number of real*8 is twice this value. 
c
c     Finding out the largest l for generaring YlmI.
c
      call MxNPs(crfrg,nps,npst)
c      Nps=0
c      criterion=log10(one/(two*(iws+one)))
c      do i=1,nfg
c         npst=int((log10((two*iws+one)*EPS*crfrg(4,1,i))/criterion)-one)
c         if (npst.gt.nps) nps=npst
c      enddo
c     NPST should contain the max(nps) of all fragments.
c      npst=nps
chc
c     write(Iw,*) 'in fmmfrag npst',npst
chc
      if(nps.gt.np) then
        if(maswrk) write(iw,9000) np,nps
        call abrt
      endif
      if(maswrk) write(iw,9005) np,nps
      if(nlayer.ne.1) call abrt
c
c     The accumulation of Vtilda for multiple layers is not finished. 
c     if(savgrd) call abrt
c     Needs separate code.
C     
c     Generating Ylm for each fragment and putting in Ylmfrg
c
      if(isgddi) call GDDICOUNT(-1,lgroup,myjob)
      do 200 iifg=1,nfg
        if(loadhf.eq.1) then
          ifg=loadm(iifg)
        else
          ifg=iifg
        endif
        if(layfrg(ifg).ge.ilay) then
          call vclr(Ylmfrg(1,1,ifg),1,LNP*2*ncentm)
          if(isgddi) then
            call GDDICOUNT(0,lgroup,myjob)
            if(.not.myjob) goto 200
          endif
          call CLOSDA('DELETE')
          CALL OPENDA(0)
          call makemol(ifg,0,0,ilay,0,0,0,0,0,0,0,.true.)
          l1=num
c         l2=(l1*l1+l1)/2
c         call readumond(da,Vtilda,orbxch,scffrg(ifg).eq.rmc,na,nb,l1,0,
c    *                     iodfmo,ifg+irec0)
          call readmond(da,orbxch,scffrg(ifg).eq.rmc,na,nb,l1,
     *                     iodfmo,ifg+irec0,scffrg(ifg).eq.uhf)
c         generate multipole of fragment ifg
          if (ncentm.eq.1) then
             call fmo_Y(clm,flm,crfrg(1,1,ifg),da,Ylmfrg(1,1,ifg),nps)
          else
c            If ncentm.gt.1, we should generate Ylm for multiple centers.
             call fmo_Y_M(clm,flm,crfrg(1,1,ifg),da,Ylmfrg(1,1,ifg),nps)
          endif
c            call fmo_Y(clm,flm,crfrg(1,1,ifg),da,Ylmfrg(1,1,ifg),nps)
        else
          if(meglob.ne.0) call vclr(Ylmfrg(1,1,ifg),1,LNP*2*ncentm)
c         to avoid double counting in DDI_GSUMF 
        endif
  200 continue
      if(isgddi) call GDDICOUNT( 1,lgroup,myjob)
      if(isgddi) call gddi_scope(ddi_world)
      call ddi_gsumf(2416,Ylmfrg,LNP*2*ncentm*nfg)
      if(isgddi) call gddi_scope(ddi_group)
      call timit(1)
c
c     Generating the Zlmfrg of each fragment on the basis of distance criteria.
c     We do Y2Z translations for the fragment pairs of I and J,
c     whose Rij.gt.Resdim.
c     Eventually, Zlmfrg will contain all the long range potentials on I due to
c     all the other J, except short distance Js.
c
c     z-axis
c
      EZ(1)=zero
      EZ(2)=zero
      EZ(3)=one
c
c     Zeroing out Zlmfrg
      call vclr(Zlmfrg,1,LNp*2*ncentm*nfg)
      call viclr(nZi,1,nfg)
c    
c     The dimer loop below is not parallelised over IJ, because
c     each dimer cannot be computed in parallel. Instead. we parallelise
c     over I among groups and over J within group, which is lame but better 
c     than nothing. 
      if(isgddi) call GDDICOUNT(-1,lgroup,myjob)
      do 460 iifg=1,nfg
        if(loadhf.eq.1) then
          ifg=loadm(iifg)
        else
          ifg=iifg
        endif
        if(isgddi) then
          call GDDICOUNT(0,lgroup,myjob)
          if(.not.myjob) goto 460
        endif
c       Since it is believed that the cost of this loop is low,
c       we hardwire static parallelisation. 
        kount=0
        do 450 jfg=1,ifg-1
c
c         MFMO for now will regenerate everything for each fragment
          if(scffrg(ifg).eq.rnone.or.scffrg(jfg).eq.rnone) goto 450
c         skip dimers that have been done (restart jobs, no BSSE).
c         if(irststp.ge.4.and.irststp.ne.5.and.edim(ijfg,1).ne.zero)
c    *       goto 450
c         No gradient restart for now.
c
c         Note that mmdist should understands ncentm option so that
c         the proper radius will be returned.
          call mmdist(ifg,0,0,jfg,t,radius,ty2z,ratio,mmdim)
c
          if(mmdim.ne.0) then
            kount=kount+1
            if(goparr.and.mod(kount,NPROC).NE.me) goto 450 
c
c           Using very fast multipole idea.
            nps=int(log10(EPS*abs(ty2z-radius))/log10(ratio)-one)
            if(nps.gt.npst) then
              if(maswrk) write(iw,9010) npst,nps
              call abrt
            endif
            LNPS=((NPS+1)*(NPS+2))/2
            LFGS=((NPS*(NPS+1)*(NPS+2)*4)/3)+(NPS+1)
c           
c           Ylm are defined above (as Ylmfrg) with NP used to compute its
c           leading dimension.
c           Therefore, the same NP from QMFM should be used to define Ylm,
c           although one can use a different one for calculations (NPs).
c           
c           Some pre-computable values for rotation based translation.
c           Again very fast idea uses Nps rather than Np.
c           We'll use Nps later. But for the moment let's use Np.
c           
            if (ncentm.eq.1) then
               CALL GETZLL(ZLL,TY2Z,2*NPS+1)
               CALL GETCOF(NPS,FLM,ZLL,COEFF)
               CALL ROTR(T,EZ,RT)
               CALL GETROT(F,G,RT,NPS,CLM)
c           
c              First Potential of J on I
c           
               CALL RY2ZIR(LNPS,Ylmfrg(1,1,jfg),Zlmj,CZP,LFGS,F,G,NPS,
     *           COEFF(1,1))
c              The return value contains the Zlmj due to fragment J.
c              Now we just sum over all Zlmj to get ZlmI.
               call daxpy(LNps*2,one,Zlmj,1,Zlmfrg(1,1,ifg),1)
               nZi(ifg)=nZi(ifg)+1
c           
c              Second Potential of I on J
c           
               CALL RY2ZIR(LNPS,Ylmfrg(1,1,ifg),Zlmj,CZP,LFGS,F,G,NPS,
     *           COEFF(1,2))
               call daxpy(LNps*2,one,Zlmj,1,Zlmfrg(1,1,jfg),1)
c              Nota bene: this daxpy should probably be changed into?
c              call daxpy(LNp*2*ncentm,one,Zlmj,1,Zlmfrg(1,1,jfg),1)
c
               nZi(jfg)=nZi(jfg)+1
            else
               do i=2,int(crfrg(1,ncentm,ifg))+1
                  do j=2,int(crfrg(1,ncentm,jfg))+1
                     do k=1,3
                        t(k)=crfrg(k,i,ifg)-crfrg(k,j,jfg)
                     enddo
                     ty2z=sqrt(t(1)*t(1)+t(2)*t(2)+t(3)*t(3))
                     CALL GETZLL(ZLL,TY2Z,2*NPS+1)
                     CALL GETCOF(NPS,FLM,ZLL,COEFF)
                     CALL ROTR(T,EZ,RT)
                     CALL GETROT(F,G,RT,NPS,CLM)
c           
c           First Potential of J on I
c           
                     CALL RY2ZIR(LNPS,Ylmfrg(1,j,jfg),Zlmj,CZP,LFGS,
     *                    F,G,NPS,COEFF(1,1))
c           The return value contains the Zlmj due to fragment J.
c           Now we just sum over all Zlmj to get ZlmI.
                     call daxpy(LNps*2,one,Zlmj,1,Zlmfrg(1,i,ifg),1)
c           
c           Second Potential of I on J
c           
                     CALL RY2ZIR(LNPS,Ylmfrg(1,i,ifg),Zlmj,CZP,LFGS,
     *                    F,G,NPS,COEFF(1,2))
                     call daxpy(LNps*2,one,Zlmj,1,Zlmfrg(1,j,jfg),1)
c           Nota bene: this daxpy should probably be changed into?
c           call daxpy(LNp*2*ncentm,one,Zlmj,1,Zlmfrg(1,1,jfg),1)
c           No, Zlmj only contains values of the particular center. 
c           So each center of a given fragment should have it own Zlm.
c
                  enddo
               enddo
               nZi(ifg)=nZi(ifg)+1
               nZi(jfg)=nZi(jfg)+1 
            endif
          endif
  450   continue
  460 continue
      if(isgddi) call GDDICOUNT( 1,lgroup,myjob)
      if(isgddi) call gddi_scope(ddi_world)
      call ddi_gsumf(2416,Zlmfrg,LNP*2*ncentm*nfg)
      call ddi_gsumi(2417,nZi,nfg)
      if(isgddi) call gddi_scope(ddi_group)
      call timit(1)
      if(maswrk) write(iw,*) 'nZi=',(nZi(i),i=1,nfg)
c
c     Ok now Zlmfrg contains all the long-range potentials.
C     Note that you still have to do short-range ones separately.
c     In the future, we'll use FMM for this.
c    
c     Using Zlmfrg as obtained above, in this rountine we calculate
c     Coulomb Potential for each pair of mu-nu to construct
c     Fock Matrix of Monomers.
c
c     By shifting Zlm to the UNIQUE center of Ylm, 
c     Nps can be Npgp*2, which saves a lot of time.
c     However, we should use maximum Np=Npst for 
c     energy calculations.
c
c     nps=npgp*2
c
cc          call fmo_mmFock(l2,clm,flm,nps,crfrg(1,1,ifg),Zlmfrg(1,1,ifg),
c    *                   Vtilda)
      call timit(1)
c
      if(maswrk) write(iw,*) 'Multipole generation for ESP is done.'
      return
 9000 FORMAT(/1X,'Increase NP or decrease IEPS in $FMM: NP,NPS=',2I8)
 9005 FORMAT(/1X,'Multipole generation: NP,NPS=',2I8)
 9010 FORMAT(/1X,'Internal failure in setting NPST,NPS=',2I8)
      end
C*MODULE fmomm  *DECK fmo_mmESP
C>
C>     @brief ESP with multipoles. 
C>
C>     @details Calculates ESP with multipoles. 
C>
C>     @author Cheol Ho Choi
C>
      SUBROUTINE fmo_mmESP(l2,clm,flm,nps,ctri,ZlmI,Vtilda)
c
c     This rountine calculates Coulomb potential due to all other monomers on
c     current monomer I, which will be used for monomer Fock matrix construction.
c
c     Ylm,munu, the multipole of monomer i over mu-nu should be recalculated
c     on the fly, since the Ylmi is the sum of all multipoles, from which we
c     can not obtain the indivisual primitive Gaussian product terms.
c
c     Note that this routine assumes you already computed ZlmI for fragment I
c     due to the long-range potentials of all J, that are Rij.gt.Resdim.
c     So this routine assumes that contractions on J are already done.
c
c     Input arguments: 
c     l2: size of return matrix Vtilda
c     clm, flm: used for MM
c     nps : npgp *2 , npgp=the highest angular momentum of basis set.
c     We can set nps=npgp*2, since we shift ZlmI to the unique center of Ylm, mu-nu.
c     It saves a lot of time.
c     CTRi : The center of monomer I and ZlmI.
c     Return arguments:
c     Vtilda : Coulomb potential for Fock matrix construction. It has mu-nu indices.
c
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK,IANDJ,DOUBLE,NORM,nxt
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000)
      PARAMETER (MAXNP=45,MAXCOF=23821)
      PARAMETER (one=1.0d+00,zero=0.0d+00,
     *        SQRT3=1.73205080756888D+00,SQRT5=2.23606797749979D+00)
      complex*16 ZlmI,Zlm,Ylm,Tlm
      LOGICAL QOPS,QFMM
      COMMON /QMFM  / SIZE,EPS,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      DIMENSION F((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          G((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          CLM(-maxNP:maxNP),FLM(-maxNP:maxNP),
     *          COEFF(MAXCOF,2),ZLL(0:2*maxNP+1,2),
     *          ZlmI(*),ctri(3),Vtilda(*),
     *          Ylm(((MAXNP+1)*(MAXNP+2))/2),
     *          Tlm(((MAXNP+1)*(MAXNP+2))/2),
     *          Zlm(((MAXNP+1)*(MAXNP+2))/2)
      dimension DIJ(255),pa(3),pb(3),pctr(3),pnt(3),ez(3),rt(3,3)
c
c
c     Translational vector
c
c     z-axis
c
      call vclr(Vtilda,1,l2)
      EZ(1)=zero
      EZ(2)=zero
      EZ(3)=one
c
      LNPs=((NPs+1)*(NPs+2))/2
      LFGs=((NPs*(NPs+1)*(NPs+2)*4)/3)+(NPs+1)
      LNPGP=((NPGP+1)*(NPGP+2))/2
      NORM=NORMF.NE.1.OR.NORMP.NE.1
cc
c     Now we go through every products of primitive Gaussians and
c     compute their derivative contributions.
c
      NXT = IBTYP.EQ.1
      NEXT  = -1
      kount = -1
c
c     We first calculate the electron contributions.
C
c     First shell loop.
c
      DO II=1,NSHELL
         Iatom=KATOM(II)
         XI=C(1,iatom)
         YI=C(2,iatom)
         ZI=C(3,iatom)
         I1=KSTART(II)
         I2=I1+KNG(II)-1
         MINI=KMIN(II)
         MAXI=KMAX(II)
         LIT=KTYPE(II)
         ILOC=KLOC(II)
C
C        SECOND SHELL LOOP.
C
         DO JJ=1,II
           if(goparr) then
              kount=kount+1
              if(nxt) then
                 IF(kount.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
                 if(NEXT.ne.kount) goto 700
              else
                 if(MOD(kount,NPROC).NE.me) goto 700
              endif
            endif
            Jatom=KATOM(JJ)
            XJ=C(1,Jatom)
            YJ=C(2,Jatom)
            ZJ=C(3,Jatom)
            J1=KSTART(JJ)
            J2=J1+KNG(JJ)-1
            MINJ=KMIN(JJ)
            MAXJ=KMAX(JJ)
            LJT=KTYPE(JJ)
            JLOC=KLOC(JJ)
c
c           DFX=XI-XJ
c           DFY=YI-YJ
c           DFZ=ZI-ZJ
            RR=(XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
            IANDJ=II.EQ.JJ
c
C           Loop over primitive Gaussians
C
C           I PRIMITIVE.
C
            JGMAX=J2
            DO IG=I1,I2
               AI=EX(IG)
               ARRI=AI*RR
               AXI=AI*XI
               AYI=AI*YI
               AZI=AI*ZI
               CSI=CS(IG)
               CPI=CP(IG)
               CDI=CD(IG)
               CFI=CF(IG)
c
C              J PRIMITIVE
c
               IF(IANDJ) JGMAX=IG
               DO JG=J1,JGMAX
c
                  AJ=EX(JG)
                  AA=AI+AJ
                  DUM=AJ*ARRI/AA
c                  IF(DUM.GT.TOL) GO TO 6000
c
c                 The unique center of the primitive Gaussian product
c
                  pctr(1)=(AXI+AJ*XJ)/AA
                  pctr(2)=(AYI+AJ*YJ)/AA
                  pctr(3)=(AZI+AJ*ZJ)/AA
c
                  CSJ=CS(JG)
                  CPJ=CP(JG)
                  CDJ=CD(JG)
                  CFJ=CF(JG)
C
                  FAC= EXP(-DUM)
C
                  DOUBLE=IANDJ.AND.IG.NE.JG
                  MAX=MAXJ
                  NN=0
                  DO 310 I=MINI,MAXI
                  GO TO ( 70, 80,180,180, 90,180,180,101,180,180,
     *            110,180,180,120,180,180,180,180,180,130),I
   70             DUM1=CSI*FAC
                  GO TO 180
   80             DUM1=CPI*FAC
                  GO TO 180
   90             DUM1=CDI*FAC
                  GO TO 180
  101             IF(NORM) DUM1=DUM1*SQRT3
                  GO TO 180
  110             DUM1=CFI*FAC
                  GO TO 180
  120             IF(NORM) DUM1=DUM1*SQRT5
                  GO TO 180
  130             iF(NORM) DUM1=DUM1*SQRT3
  180             IF(IANDJ) MAX=I
                  DO 310 J=MINJ,MAX
                  GO TO (190,200,300,300,210,300,300,220,300,300,
     *            230,300,300,240,300,300,300,300,300,250),J
  190             DUM2=DUM1*CSJ
                  IF(.NOT.DOUBLE) GO TO 300
                  IF(I.GT.1) GO TO 195
                  DUM2=DUM2+DUM2
                  GO TO 300
  195             DUM2=DUM2+CSI*CPJ*FAC
                  GO TO 300
  200             DUM2=DUM1*CPJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  210             DUM2=DUM1*CDJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  220             IF(NORM) DUM2=DUM2*SQRT3
                  GO TO 300
  230             DUM2=DUM1*CFJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  240             IF(NORM) DUM2=DUM2*SQRT5
                  GO TO 300
  250             IF(NORM) DUM2=DUM2*SQRT3
  300             NN=NN+1
  310             DIJ(NN)=DUM2
c
c
C                 The input argument ctr should contain the center of
c                 fragment.
c
C                 Calcualte the translational vector, Pnt.
c                 Note: CTRi -> center of fragment i.
c                 pctr -> the unique center of product of primitive
c                 Gaussian.
c
                  DO Iip=1,3
                     PNT(Iip)=pctr(Iip)-CTRi(Iip)
                  ENDDO
c
C                 OBTAIN PA AND PB: the relative vector w.r.t. unique center P.
c
                  DO Iip=1,3
                     PA(Iip)=pctr(Iip)-C(Iip,IATOM)
                     PB(Iip)=pctr(Iip)-C(Iip,JATOM)
                  ENDDO
c
c                 Translational distance of z2z translation
c
                  Tz2z=SQRT(PNT(1)*PNT(1)+PNT(2)*PNT(2)+PNT(3)*PNT(3))
c
c                 Calculate pre-computable quantities for rotation based
c                 multipole operation.
c
                  CALL GETZLL(ZLL,Tz2z,2*NPs+1)
                  CALL GETCOF2(NPs,FLM,ZLL,COEFF)
                  CALL ROTR(PNT,EZ,RT)
                  CALL GETROT(F,G,RT,NPs,CLM)
C
c                 We shift the center of ZlmI from the center of fragment
c                 to the unique center of primitive Gaussian product.
c
                  CALL RZ2ZIR(LNPs,ZlmI,Zlm,Tlm,LFGs,F,G,NPs,FLM,ZLL)
C
c                 Loop over basis set pair IJ
c
                  jp=0
                  DO IB=iloc,iloc+maxi-mini
                     LIN=IB*(IB-1)/2
                     DO JB=jloc,jloc+maxj-minj
                        LJN=JB+LIN
                        IF (IB.GE.JB) THEN
                          JP=JP+1
c     Get Fragment I's Ylm of mu-nu without Density of mu-nu.
                          CALL MOMSPC(LIT,LJT,IB-ILOC+MINI,JB-JLOC+MINJ,
     *                         Ylm,PA,PB,AA,dij(jp))
c
                          call fmo0p(npgp,lnpgp,Ylm,Zlm,sum2)
                          Vtilda(LJN)=Vtilda(LJN)+sum2
c
c     Done with V tilda. That's it!
c
                        ENDIF
                     ENDDO
                  ENDDO
c              J primitive
               ENDDO
c           I primitive
            enddo
  700    continue
c        J shell
         enddo
c     I shell
      enddo
      IF (GOPARR.and.nxt) CALL DDI_DLBRESET
c
      kount = -1
C
c     Summation of DE over nodes is done elsewhere (in FMOX as FMODE via DE).
c     Summation of Tilda over nodes has to be done here.
      if(goparr) call ddi_gsumf(2416,Vtilda,l2)
c
      RETURN
      END
C*MODULE fmomm  *DECK fmo_mmESP_M
C>
C>     @brief Derivative of ESP with multipoles. 
C>
C>     @details The multicenter version of fmo_mmESP.
C>     This rountine calculates Coulomb potential due to all other monomers on
C>     current monomer I.
C>
C>     Ylm,munu, the multipole of monomer i over mu-nu should be recalculated
C>     on the fly, since the Ylmi is the sum of all multipoles, from which we
C>     can not obtain the indivisual primitive Gaussian product terms.
C>
C>     Note that this routine assumes you already computed ZlmI for fragment I
C>     due to the long-range potentials of all J, that are Rij.gt.Resdim.
C>     So this routine assumes that contractions on J are already done.
C>
C>     @author Cheol Ho Choi
C>
C>     @param l2: size of return matrix Vtilda
C>
C>     @param clm : used for MM
C>
C>     @param flm: used for MM
C>
C>     @param nps : npgp *2 , npgp=the highest angular momentum of basis set.
C>     We can set nps=npgp*2, since we shift ZlmI to the unique center of Ylm, 
C>     mu-nu. It saves a lot of time.
C>
C>     @param CTRi : The center of monomer I and ZlmI.
C>
C>     @param ZlmI : Z(LM) of fragment I
C>
C>     @param Vtilda : Coulomb potential for Fock matrix construction. 
C>     It has mu-nu indices.
C>
      SUBROUTINE fmo_mmESP_M(l2,clm,flm,nps,ctri,nctr,ZlmI,Vtilda)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK,IANDJ,DOUBLE,NORM,nxt
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000)
      PARAMETER (MAXNP=45,MAXCOF=23821)
      PARAMETER (one=1.0d+00,zero=0.0d+00,
     *        SQRT3=1.73205080756888D+00,SQRT5=2.23606797749979D+00)
      complex*16 ZlmI,Zlm,Ylm,Tlm
      LOGICAL QOPS,QFMM
      COMMON /QMFM  / SIZE,EPS,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
      DIMENSION F((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          G((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          CLM(-maxNP:maxNP),FLM(-maxNP:maxNP),
     *          COEFF(MAXCOF,2),ZLL(0:2*maxNP+1,2),
     *          ZlmI(((NP+1)*(NP+2))/2,ncentm),
     *          ctrI(4,nctr),Vtilda(*),
     *          Ylm(((MAXNP+1)*(MAXNP+2))/2),
     *          Tlm(((MAXNP+1)*(MAXNP+2))/2),
     *          Zlm(((MAXNP+1)*(MAXNP+2))/2)
c     *          ZlmI(*),ctri(3),Vtilda(*),
      dimension DIJ(255),pa(3),pb(3),pctr(3),pnt(3),ez(3),rt(3,3)
c
c
c     Translational vector
c
c     z-axis
c
      call vclr(Vtilda,1,l2)
      EZ(1)=zero
      EZ(2)=zero
      EZ(3)=one
c
      LNPs=((NPs+1)*(NPs+2))/2
      LFGs=((NPs*(NPs+1)*(NPs+2)*4)/3)+(NPs+1)
      LNPGP=((NPGP+1)*(NPGP+2))/2
      NORM=NORMF.NE.1.OR.NORMP.NE.1
cc
c     Now we go through every products of primitive Gaussians and
c     compute their derivative contributions.
c
      NXT = IBTYP.EQ.1
      NEXT  = -1
      kount = -1
c
c     We first calculate the electron contributions.
C
c     First shell loop.
c
      DO II=1,NSHELL
         Iatom=KATOM(II)
         XI=C(1,iatom)
         YI=C(2,iatom)
         ZI=C(3,iatom)
         I1=KSTART(II)
         I2=I1+KNG(II)-1
         MINI=KMIN(II)
         MAXI=KMAX(II)
         LIT=KTYPE(II)
         ILOC=KLOC(II)
C
C        SECOND SHELL LOOP.
C
         DO JJ=1,II
           if(goparr) then
              kount=kount+1
              if(nxt) then
                 IF(kount.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
                 if(NEXT.ne.kount) goto 700
              else
                 if(MOD(kount,NPROC).NE.me) goto 700
              endif
            endif
            Jatom=KATOM(JJ)
            XJ=C(1,Jatom)
            YJ=C(2,Jatom)
            ZJ=C(3,Jatom)
            J1=KSTART(JJ)
            J2=J1+KNG(JJ)-1
            MINJ=KMIN(JJ)
            MAXJ=KMAX(JJ)
            LJT=KTYPE(JJ)
            JLOC=KLOC(JJ)
c
c           DFX=XI-XJ
c           DFY=YI-YJ
c           DFZ=ZI-ZJ
            RR=(XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
            IANDJ=II.EQ.JJ
c
C           Loop over primitive Gaussians
C
C           I PRIMITIVE.
C
            JGMAX=J2
            DO IG=I1,I2
               AI=EX(IG)
               ARRI=AI*RR
               AXI=AI*XI
               AYI=AI*YI
               AZI=AI*ZI
               CSI=CS(IG)
               CPI=CP(IG)
               CDI=CD(IG)
               CFI=CF(IG)
c
C              J PRIMITIVE
c
               IF(IANDJ) JGMAX=IG
               DO JG=J1,JGMAX
c
                  AJ=EX(JG)
                  AA=AI+AJ
                  DUM=AJ*ARRI/AA
c                  IF(DUM.GT.TOL) GO TO 6000
c
c                 The unique center of the primitive Gaussian product
c
                  pctr(1)=(AXI+AJ*XJ)/AA
                  pctr(2)=(AYI+AJ*YJ)/AA
                  pctr(3)=(AZI+AJ*ZJ)/AA
c
                  CSJ=CS(JG)
                  CPJ=CP(JG)
                  CDJ=CD(JG)
                  CFJ=CF(JG)
C
                  FAC= EXP(-DUM)
C
                  DOUBLE=IANDJ.AND.IG.NE.JG
                  MAX=MAXJ
                  NN=0
                  DO 310 I=MINI,MAXI
                  GO TO ( 70, 80,180,180, 90,180,180,101,180,180,
     *            110,180,180,120,180,180,180,180,180,130),I
   70             DUM1=CSI*FAC
                  GO TO 180
   80             DUM1=CPI*FAC
                  GO TO 180
   90             DUM1=CDI*FAC
                  GO TO 180
  101             IF(NORM) DUM1=DUM1*SQRT3
                  GO TO 180
  110             DUM1=CFI*FAC
                  GO TO 180
  120             IF(NORM) DUM1=DUM1*SQRT5
                  GO TO 180
  130             iF(NORM) DUM1=DUM1*SQRT3
  180             IF(IANDJ) MAX=I
                  DO 310 J=MINJ,MAX
                  GO TO (190,200,300,300,210,300,300,220,300,300,
     *            230,300,300,240,300,300,300,300,300,250),J
  190             DUM2=DUM1*CSJ
                  IF(.NOT.DOUBLE) GO TO 300
                  IF(I.GT.1) GO TO 195
                  DUM2=DUM2+DUM2
                  GO TO 300
  195             DUM2=DUM2+CSI*CPJ*FAC
                  GO TO 300
  200             DUM2=DUM1*CPJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  210             DUM2=DUM1*CDJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  220             IF(NORM) DUM2=DUM2*SQRT3
                  GO TO 300
  230             DUM2=DUM1*CFJ
                  IF(DOUBLE) DUM2=DUM2+DUM2
                  GO TO 300
  240             IF(NORM) DUM2=DUM2*SQRT5
                  GO TO 300
  250             IF(NORM) DUM2=DUM2*SQRT3
  300             NN=NN+1
  310             DIJ(NN)=DUM2
c
c
C                 The input argument ctr should contain the center of
c                 fragment.
c
C                 Calcualte the translational vector, Pnt.
c                 Note: CTRi -> center of fragment i.
c                 pctr -> the unique center of product of primitive
c                 Gaussian.
c
c                 But before, we should get the center of ZlmI.
                  call getnear(0,pctr,ctrI(1,1),nctr,idx,rDIST)
c                 call getnear(0,pctr,ctrI(1,1),ncentm,idx,rDIST)
c
                  DO Iip=1,3
                     PNT(Iip)=pctr(Iip)-CTRi(Iip,idx)
c                     PNT(Iip)=pctr(Iip)-CTRi(Iip)
                  ENDDO
c
C                 OBTAIN PA AND PB: the relative vector w.r.t. unique center P.
c
                  DO Iip=1,3
                     PA(Iip)=pctr(Iip)-C(Iip,IATOM)
                     PB(Iip)=pctr(Iip)-C(Iip,JATOM)
                  ENDDO
c
c                 Translational distance of z2z translation
c
                  Tz2z=SQRT(PNT(1)*PNT(1)+PNT(2)*PNT(2)+PNT(3)*PNT(3))
c
c                 Calculate pre-computable quantities for rotation based
c                 multipole operation.
c
                  CALL GETZLL(ZLL,Tz2z,2*NPs+1)
                  CALL GETCOF2(NPs,FLM,ZLL,COEFF)
                  CALL ROTR(PNT,EZ,RT)
                  CALL GETROT(F,G,RT,NPs,CLM)
C
c                 We shift the center of ZlmI from the center of fragment
c                 to the unique center of primitive Gaussian product.
c
c                  CALL RZ2ZIR(LNPs,ZlmI,Zlm,Tlm,LFGs,F,G,NPs,FLM,ZLL)
                  CALL RZ2ZIR(LNPs,ZlmI(1,idx),Zlm,Tlm,LFGs,F,G,NPs,
     *                 FLM,ZLL)
C
c                 Loop over basis set pair IJ
c
                  jp=0
                  DO IB=iloc,iloc+maxi-mini
                     LIN=IB*(IB-1)/2
                     DO JB=jloc,jloc+maxj-minj
                        LJN=JB+LIN
                        IF (IB.GE.JB) THEN
                          JP=JP+1
c     Get Fragment I's Ylm of mu-nu without Density of mu-nu.
                          CALL MOMSPC(LIT,LJT,IB-ILOC+MINI,JB-JLOC+MINJ,
     *                         Ylm,PA,PB,AA,dij(jp))
c
                          call fmo0p(npgp,lnpgp,Ylm,Zlm,sum2)
                          Vtilda(LJN)=Vtilda(LJN)+sum2
c
c     Done with V tilda. That's it!
c
                        ENDIF
                     ENDDO
                  ENDDO
c              J primitive
               ENDDO
c           I primitive
            enddo
  700    continue
c        J shell
         enddo
c     I shell
      enddo
      IF (GOPARR.and.nxt) CALL DDI_DLBRESET
c
      kount = -1
C
c     Summation of DE over nodes is done elsewhere (in FMOX as FMODE via DE).
c     Summation of Tilda over nodes has to be done here.
      if(goparr) call ddi_gsumf(2416,Vtilda,l2)
c
      RETURN
      END
C*MODULE fmomm  *DECK mmESPg
      subroutine mmESPg(ilay,ifg,jfg,loadhf,loadm,layfrg,
     *                  da,ncentm,clm,flm,crfrg,Ylmfrgq,ZlmfrgIJ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL QOPS,QFMM,GOPARR,DSKWRK,MASWRK,nxt
      parameter(MXATM=2000,maxnp=45,ONE=1.0D+00,two=2.0D+00,
     *          MAXCOF=23821)
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /QMFM  / SIZE,EPS,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      complex*16 Ylmfrgq(((NP+1)*(NP+2))/2,nfg),
     *           ZlmfrgIJ(((NP+1)*(NP+2))/2,nfg),
     *           CZP((MAXNP+1)*(MAXNP+2)/2),
     *           ZlmK(((MAXNP+1)*(MAXNP+2))/2),
     *           ZlmIJ(((MAXNP+1)*(MAXNP+2))/2),
     *           YlmIJ(((MAXNP+1)*(MAXNP+2))/2)
      dimension loadm(*),layfrg(*),da(*),crfrg(4,ncentm,nfg),
     *          CLM(-maxNP:maxNP),FLM(-maxNP:maxNP)
      DIMENSION F((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          G((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          COEFF(MAXCOF,2),ZLL(0:2*maxNP+1,2)
      dimension t(3),ez(3),rt(3,3),ctrij(4)
c
c     This routine calculates 
c     1) the derivative of monomer IJ due to the all other monomer K.
c        So it is assumed that there is a loop over K.
c        It is also assumed that the Ylm of each K was already calculated
c        as the input argument of YlmfragQ.
c        So YlmfragQ(K) should correspond to the ylm of monomer K.
c        Da is Delta Dmu-nu of IJ.
c     2) ZlmfrgIJ(k), which contains the potential due to monomer IJ for each
c        K.
c
c     Notes on NP, NPS and NPGP for this routine:
c     This routine calculates the ylm,mu-nu,IJ at the unique center of
c     product of primitive Gaussian(mu-nu) on the fly.
c     And the multipole calculations of ylm*zlm will be done that the 
c     same unique center. Therefore, the maximum l is 2*largest 
c     angular momentum of Gaussian basis set.
c     As a result, multipoles of only NPGP is necessary.
c
C     Things need to obtain before doing any multipole operation.     
c 
c     if(maswrk) write(iw,*) 'Multipole generation begins.'
c     call timit(1)
c
      CALL VCLR(DE,1,NAT*3)
c
C     GET TABLE FOR 1-ELECTRON INTEGRAL
      CALL GXYZLM
C     
c     This is the highest angular momentum required during derivative 
c     calculations.
      lnp=((NP+1)*(NP+2))/2
      npst=0
c
      EZ(1)=0
      EZ(2)=0
      EZ(3)=1
c
c     Compute the center and radius of dimer IJ
      distjij=0.0d+00
      do i=1,3
         ctrij(i)=(crfrg(i,1,ifg)+crfrg(i,1,jfg))/2
         distjij=distjij+(ctrij(i)-crfrg(i,1,jfg))**2
      enddo
      ctrij(4)=sqrt(distjij)+max(crfrg(4,1,ifg),crfrg(4,1,jfg))
c
      if(nlayer.ne.1) call abrt
c
c     First of all, we compute the YlmIJ
c     Finding out the largest l for generaring YlmIJ.
c     Dmitri, this npst can also be in common.
c
      Nps=0
      criterion=log10(one/(two*(iws+one)))
      npst=int((log10((two*iws+one)*EPS*ctrij(4))/criterion)-one)
      if (npst.gt.nps) nps=npst
      npst=nps
      call fmo_Yd(clm,flm,ctrij,da,YlmIJ,nps)
c
      call vclr(ZlmIJ,1,LNP*2)
c
c     The main loop over monomer k
c     The Ylmfrgq will be converted to Zlm and accumulated to ZlmIJ
c     And YlmIJ will be converted to ZlmK and accumulated to ZlmfrgIJ(k).
c     The ZlmfrgIJ(k) will be used in esp1gmm.
c
      NXT = IBTYP.EQ.1
      NEXT  = -1
      kount = -1
      nZij=0
c
      do 200 kkfg=1,nfg
        if(loadhf.eq.1) then
          kfg=loadm(kkfg)
        else
          kfg=kkfg
        endif
        if(layfrg(kfg).ge.ilay.and.kfg.ne.ifg.and.kfg.ne.jfg) then
          if(goparr) then
              kount=kount+1
              if(nxt) then
                 IF(kount.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
                 if(NEXT.ne.kount) goto 200
              else
                 if(MOD(kount,NPROC).NE.me) goto 200
              endif
            endif
          call mmdist(ifg,jfg,0,kfg,t,radius,ty2z,ratio,mmdim)
          if(mmdim.ne.0) then
            nZij=nZij+1
c
C         We will get ZlmIJ which is the sum over K.
c
c         Using very fast multipole idea.
          nps=int(log10(EPS*abs(ty2z-radius))/log10(ratio)-one)
          if (nps.gt.npst) npst=nps
          if(nps.gt.np) then
             if(maswrk) write(iw,9000) np,nps
             call abrt
          endif
          LNPS=((NPS+1)*(NPS+2))/2
          LFGS=((NPS*(NPS+1)*(NPS+2)*4)/3)+(NPS+1)
c
c         Some pre-computable values for rotation based translation.
c         Again very fast idea uses Nps rather than Np.
c
          CALL GETZLL(ZLL,TY2Z,2*NPS+1)
          CALL GETCOF(NPS,FLM,ZLL,COEFF)
          CALL ROTR(T,EZ,RT)
          CALL GETROT(F,G,RT,NPS,CLM)
c         Now YlmfrgQ of monomer K is converted to ZlmK
          CALL RY2ZIR(LNPS,Ylmfrgq(1,kfg),ZlmK,CZP,LFGS,F,G,NPS,
     *           COEFF(1,1))
c         The return value contains the ZlmK due to fragment K.
c         Now we just sum over all ZlmK to get ZlmIJ.
          call daxpy(LNps*2,one,ZlmK,1,ZlmIJ,1)
c
c         We also convert YlmIJ to ZlmK and accumulated to ZlmfrgIJ.
c
c         Now YlmfrgQ of monomer K is converted to ZlmK
          CALL RY2ZIR(LNPS,YlmIJ,ZlmK,CZP,LFGS,F,G,NPS,
     *           COEFF(1,2))
c         The return value contains the ZlmK due to fragment IJ,
c         which will be accumulated to ZlmfrgIJ(k).
          call daxpy(LNps*2,one,ZlmK,1,ZlmfrgIJ(1,kfg),1)
c
          endif
        endif
  200 continue
      IF (GOPARR.and.nxt) CALL DDI_DLBRESET
      if(goparr) call ddi_gsumi(2416,nZij,1)
      if(maswrk) 
     *  write(Iw,*) ifg,jfg,' in mmespg npst=',npst,' nZij=',nZij
c
c     We now have ZlmIJ containing all long-range potential of K for IJ.
c     The gradient of IJ will be calculated as YlmIJ'*ZlmIJ in fmo_mmderq,
c     where YlmIJ' is the derivative of YlmIJ. 
c     YmIJ' will be obtained in fmo_mmderq on the fly.
c     Note that YlmIJ' contains electrons of IJ.
c
      if(nZij.ne.0) then
        nps=npgp
        LNPS=((NPS+1)*(NPS+2))/2
        if(goparr) call ddi_gsumf(2416,ZlmIJ,LNps*2)
        call fmo_mmderq(clm,flm,npgp,ctrij,da,ZlmIJ,de)
c       IF(GOPARR) CALL DDI_GSUMF(2418,DE,NAT*3)
c       do not global sum - this is done elsewhere (FMOX). 
c
c       if(maswrk) write(iw,*) 'Multipole based derivative IJ is done.'
c       call timit(1)
      endif 
c
      return
 9000 FORMAT(/1X,'Increase NP or decrease IEPS in $FMM: NP,NPS=',2I8)
c9005 FORMAT(/1X,'Multipole generation: NP,NPS=',2I8)
c9010 FORMAT(/1X,'Internal failure in setting NPST,NPS=',2I8)
      end
C*MODULE fmomm  *DECK mmZlmIJK
C>
C>     @brief Zlm for IJK 
C>
C>     @details Calculate the multipole Zlm function of IJK.
C>     We denote I=ifg, J=jfg, and K=kfg.
C>     This routine calculates ZlmIJK for IJ and IJK ESP calculations.
C>     For IJ and IJK ESP, we cannot use ZlmI, since it contains J and/or J, K 
C>     contributions, which should not be added in ZlmIJK.
C>     Furthermore, ZlmIJK is different from ZlmI, since its center and
C>     radius need to be recalculated for the particular combination of 
C>     IJ or IJK.
C>     This routine assumes you already have multi-center Ylmfrg, all 
C>     multi centers of IJ or IJK (ctrijk) and the multi centers of I (crfrg).
C>     So the crfrg and ctrijk represent the multi centers of I and IJ/IJK.
C>
C>     This routines accumulates Zlm of all monomer fragments for IJ dimer and
C>     IJK trimers.
C>
C>     @author Cheol Ho Choi
C>     
C>     @param ifg : fragment I
C>
C>     @param jfg : fragment J
C>
C>     @param kfg : fragment K
C>
C>     @param ncentm : centers of multiple points
C>
C>     @param clm : C(LM)
C>
C>     @param flm : F(LM)
C>
C>     @param crfrg : center of fragment
C>
C>     @param Ylmfrg : Ylm of fragment
C>
C>     @param ZlmIJK : Zlm of fragment
C>
C>     @param ctrijk : center of IJK fragment
C>
C>     @param ijkctr : counter of IJK fragment
C>
      subroutine mmZlmIJK(ifg,jfg,kfg,
     *   ncentm,clm,flm,crfrg,Ylmfrg,ZlmIJK,ctrijk,ijkctr)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL QOPS,QFMM
      parameter(maxnp=45,ONE=1.0D+00,two=2.0D+00,MAXCOF=23821)
      COMMON /QMFM  / SIZE,EPS,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      complex*16 Ylmfrg(((NP+1)*(NP+2))/2,ncentm,nfg),
     *           ZlmIJK(((NP+1)*(NP+2))/2,ijkctr),
     *           CZP((MAXNP+1)*(MAXNP+2)/2),
     *           ZlmL(((MAXNP+1)*(MAXNP+2))/2)
      dimension crfrg(4,ncentm,nfg),ctrijk(4,ijkctr),
     *          CLM(-maxNP:maxNP),FLM(-maxNP:maxNP)
      DIMENSION F((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          G((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          COEFF(MAXCOF,2),ZLL(0:2*maxNP+1,2)
      dimension t(3),ez(3),rt(3,3)
c
C     GET TABLE FOR 1-ELECTRON INTEGRAL
      CALL GXYZLM
C     
c     This is the highest angular momentum.
      lnp=((NP+1)*(NP+2))/2
      npst=0
c
      EZ(1)=0
      EZ(2)=0
      EZ(3)=1
c
c     The maximum NPs
c
      criterion=log10(one/(two*(iws+one)))
      npst=int((log10((two*iws+one)*EPS*ctrijk(4,1))/criterion)-one)
      nps=npst
c
      call vclr(ZlmIJK,1,LNP*2*ijkctr)
c
c     The main loop over monomer L 
c     The Ylmfrg will be converted to Zlm and accumulated to ZlmIJK
c
      nZij=0
c
c     If IJ ESP, I and J should not be zero, while K MUST be zero.
c
      do 200 lfg=1,nfg
        if (lfg.ne.ifg.and.lfg.ne.jfg.and.lfg.ne.kfg) then
c         mmcond_m should work with I, IJ and IJK.
c         mmdim=mmcond_m(ifg,jfg,kfg,lfg,t,radius,ty2z,ratio,crfrg)
          call mmdist(ifg,jfg,kfg,lfg,t,radius,ty2z,ratio,mmdim)
c
          if(mmdim.ne.0) then
            do i=2,int(ctrijk(1,ijkctr))+1
              do j=2,int(crfrg(1,ncentm,lfg))+1
                call vsub(crfrg(1,j,lfg),1,ctrijk(1,i),1,t,1,3)
                ty2z=sqrt(t(1)*t(1)+t(2)*t(2)+t(3)*t(3))
c                do k=1,3
c                  t(k)=ctrijk(k,i)-crfrg(k,j,lfg)
c                enddo
                nZij=nZij+1
c
C               We will get ZlmIJK, the sum over L.
c
c               Using very fast multipole idea.
                nps=int(log10(EPS*abs(ty2z-radius))/log10(ratio)-one)
                if (nps.gt.npst) npst=nps
                if(nps.gt.np) then
c                if(maswrk) write(iw,9000) np,nps
                  call abrt
                endif
                LNPS=((NPS+1)*(NPS+2))/2
                LFGS=((NPS*(NPS+1)*(NPS+2)*4)/3)+(NPS+1)
c
c               Some pre-computable values for rotation based translation.
c               Again very fast idea uses Nps rather than Np.
c
                CALL GETZLL(ZLL,TY2Z,2*NPS+1)
                CALL GETCOF(NPS,FLM,ZLL,COEFF)
                CALL ROTR(T,EZ,RT)
                CALL GETROT(F,G,RT,NPS,CLM)
c               Now Ylmfrg of monomer L is converted to ZlmL
                CALL RY2ZIR(LNPS,Ylmfrg(1,j,lfg),ZlmL,CZP,LFGS,F,G,NPS,
     *           COEFF(1,1))
c               The return value contains the ZlmL due to fragment L.
c               Now we just sum over all ZlmL to get ZlmIJK.
                call daxpy(LNps*2,one,ZlmL,1,ZlmIJK(1,i),1)
c
              enddo
            enddo
          endif
       endif
  200 continue
c
c     We now have ZlmIJK containing all long-range potential of L for IJ/IJK.
c
      return
c 9000 FORMAT(/1X,'Increase NP or decrease IEPS in $FMM: NP,NPS=',2I8)
c9005 FORMAT(/1X,'Multipole generation: NP,NPS=',2I8)
c9010 FORMAT(/1X,'Internal failure in setting NPST,NPS=',2I8)
      end
C*MODULE fmomm  *DECK esp1gmm
      SUBROUTINE esp1gmm(ilay,ncentm,clm,flm,crfrg,popmat,ZlmfrgIJ,
     *                   fmode,fmopg,iaglob,layfrg,loadhf,loadm)
c
c     This routine assumes you call this within loop over K.
c     This rountine calculates derivative of monomer K due to the monomer IJ.
c     The multipole of monomer K will be recalculated on the fly.
c     Note that this routine assumes you already computed ZlmIJ for fragment IJ
c     due to the long-range potentials of all IJ.
c
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL QOPS,QFMM,isgddi,parout,INITGDDI,myjob,
     *        GOPARR,DSKWRK,MASWRK,wasgddi
      PARAMETER (MXATM=2000,MAXNP=45)
      complex*16 ZlmfrgIJ(((NP+1)*(NP+2))/2,nfg) 
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /QMFM  / SIZE,EPS,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo
      DIMENSION CLM(-maxNP:maxNP),FLM(-maxNP:maxNP),
     *          crfrg(4,ncentm,nfg),popmat(maxnat,nfg,2),
     *          fmode(3,*),fmopg(3,*),iaglob(*),layfrg(*),loadm(*)
c
c     call timit(1)
c     if(maswrk) write(iw,*) 'Finishing ESP gradiients with MM.'
c
      ifmostp=6
      nps=NPGP*2
      if(isgddi) call GDDICOUNT(-1,lgroup,myjob)
      do 200 iifg=1,nfg
        if(loadhf.eq.1) then
          ifg=loadm(iifg)
        else
          ifg=iifg
        endif
        if(layfrg(ifg).ge.ilay) then
          if(isgddi) then
            call GDDICOUNT(0,lgroup,myjob)
            if(.not.myjob) goto 200
          endif
          call CLOSDA('DELETE')
          CALL OPENDA(0)
          call makemol(ifg,0,0,ilay,0,0,0,0,0,0,0,.true.)
          call vclr(de,1,3*nat)
c         compute HF terms for the gradient 
          call esp1gfrg(clm,flm,nps,crfrg(1,1,ifg),popmat(1,ifg,icurpop)
     *                 ,ZlmfrgIJ(1,ifg),de)
c         if(maswrk) write(iw,*) 'grad for ifg=',ifg
c         CALL EGOUT(DE,NAT)
          call fmodeg(1,fmode(1,1),fmopg,iaglob)
        endif
  200 continue
      if(isgddi) call GDDICOUNT( 1,lgroup,myjob)
c
      if(maswrk) write(iw,*) 'Finished dimer ESP gradients with MM.'
      call timit(1)
c
      return
      end
C*MODULE fmomm  *DECK esp1gfrg
      SUBROUTINE esp1gfrg(clm,flm,nps,ctrk,Pa,ZlmIJ,de)
c
c     This routine assumes you call this within loop over K.
c     This rountine calculates derivative of monomer K due to the monomer IJ.
c     The multipole of monomer K will be recalculated on the fly.
c     Note that this routine assumes you already computed ZlmIJ for fragment IJ
c     due to the long-range potentials of all IJ.
c
c     nps : should be NPGP*2
c     ctrk: the center of monomer K.
c     Pa : Atomic population.
c     ZlmIJ: the potential due to all IJ.
c     DE : Array for derivative
c
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      PARAMETER (MXATM=2000,MAXNP=45,MAXCOF=23821)
      PARAMETER (SQRT2=1.414213562373095D+00,one=1.0d+00,zero=0.0d+00)
      complex*16 ZlmIJ,Zlm,Ylm,Tlm
c     COMMON /GRAD  / DE(3,MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      DIMENSION F((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          G((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          CLM(-maxNP:maxNP),FLM(-maxNP:maxNP),
     *          COEFF(MAXCOF,2),ZLL(0:2*maxNP+1,2),
     *          ZlmIJ(*),ctrk(3),pa(*),de(3,*),
     *          Ylm(((MAXNP+1)*(MAXNP+2))/2),
     *          Tlm(((MAXNP+1)*(MAXNP+2))/2),
     *          Zlm(((MAXNP+1)*(MAXNP+2))/2)
      dimension pnt(3),ez(3),rt(3,3)
c
c     Translational vector
c
c     z-axis
c
      EZ(1)=zero
      EZ(2)=zero
      EZ(3)=one
c
      LNPs=((NPs+1)*(NPs+2))/2
      LFGs=((NPs*(NPs+1)*(NPs+2)*4)/3)+(NPs+1)
c     LNPGP=((NPGP+1)*(NPGP+2))/2
cc
c     Now we go through every products of primitive Gaussians and
c     compute their derivative contributions.
c
      kount = -1
c
c     The nuclei contributions
c
      kount = -1
      do ii=1,nat
        if(goparr) then
           kount=kount+1
           if(MOD(kount,NPROC).NE.me) goto 800
c          static load balancing
        endif
c
c        The translational vector w.r.t. center of fragment i
c
         DO I=1,3
            PNT(I)=c(I,ii)-CTRk(I)
         ENDDO
c
c        Translational distance of z2z translation
c
         Tz2z=SQRT(PNT(1)*PNT(1)+PNT(2)*PNT(2)+PNT(3)*PNT(3))
c
c
c        Calculate pre-computable quantities for rotation based
c        multipole operation.
c
         CALL GETZLL(ZLL,Tz2z,2*NPs+1)
         CALL GETCOF2(NPs,FLM,ZLL,COEFF)
         CALL ROTR(PNT,EZ,RT)
         CALL GETROT(F,G,RT,NPs,CLM)
C
c        We shift the center of ZlmIJ from the center of fragment
c        to the unique center of nuclei.
c
         CALL RZ2ZIR(LNPs,ZlmIJ,Zlm,Tlm,LFGs,F,G,NPs,FLM,ZLL)
C
c        Derivative of nucei contribution is very simple,
c        since nuclei have point charges.
c
         Ylm(1)=zan(ii)-Pa(ii)
C        z direction
         de(3,ii)=de(3,ii)+dreal(Ylm(1)*Zlm(2))
c        x direction
         de(1,ii)=de(1,ii)-sqrt2*dreal(Ylm(1))*dreal(Zlm(3))
c        y direction
         de(2,ii)=de(2,ii)-sqrt2*dreal(Ylm(1))*dimag(Zlm(3))
C
  800    continue
      enddo
C
c     Summation of DE over nodes is done elsewhere (in FMOX as FMODE via DE).
c
      RETURN
      END
c
C*MODULE fmomm  *DECK setmcent 
C>
C>     @brief multipole centers. 
C>
C>     @details Set multipole centers. 
C>
C>     @author Cheol Ho Choi
C>
      SUBROUTINE setmcent(ncentm,crfrg,layfrg,units)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      logical GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      dimension crfrg(4,ncentm,nfg),layfrg(*)
c     This routine will set the centers of fragments in fmox routine.
c     ncentm is the pre-determined before calling this routine.
c     If ncentm=1 : one center
c        ncentm>1 : multi-center method for MM calculations.
c        ncentm = maxnath + 2, when modfmm=16
c        ncentm = maxnat  + 2, when modfmm=32
c     Maxnath : the maximum number of heavy atoms among all fragments
c     Maxnat  : the maximum number of all atoms among all fragments
c
      if(maswrk) write(iw,9000)
      do ifg=1,nfg
        iifg=ifg
        ilay=layfrg(ifg)
        call setcent(ilay,iifg,crfrg,units)
      enddo
c
      if (ncentm.gt.1) then
c        NOTE: The centers and the corresponding radii will be set during
c        the call setcent. However, we should find out max(radii) and put it
c        to crfrg(4,1,*).
         do i=1,nfg
            rfrg=0.0d+00
c           afrg=0.0d+00
            do j=2,int(crfrg(1,ncentm,i))+1
c               afrg=afrg+crfrg(4,j,i)
               if (crfrg(4,j,i).gt.rfrg) rfrg=crfrg(4,j,i)
            enddo
            crfrg(4,1,i)=rfrg
c            crfrg(4,1,i)=afrg/crfrg(1,ncentm,i)
         enddo
      endif
c
      RETURN
 9000 format(/1x,'Fragment radii R and centers C.')
      END
c
C*MODULE FMOmm  *DECK setcent
      subroutine setcent(ilay,ifg,crfrg,units)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension crfrg(4,ncentm,nfg)
      PARAMETER (MXATM=2000,one=1.0D+00)
      logical GOPARR,DSKWRK,MASWRK
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
c
c     The dimension of crfrg is crfrg(4,ncentm,nfg)
c     crfrg(1~3,1,ifg) = the center of ifg fragment.
c     crfrg(4,1,ifg) = the radius of ifg fragment.
c     crfrg(1,ncentm,ifg) = the total number of multiple centers of ifg fragment
c
      call makemol(ifg,0,0,ilay,0,0,0,0,0,0,0,.false.)
      do i=1,3
        crfrg(i,1,ifg)=ddot(nat,C(i,1),3,one,0)/nat
      enddo
      rad=0
c     crfrg(4,1,ifg) = the radius of ifg fragment on the basis of simple nuclei's
c     geometric distances.
      do i=1,nat
        radi=sqrt((c(1,i)-crfrg(1,1,ifg))**2
     *           +(c(2,i)-crfrg(2,1,ifg))**2+
     *            (c(3,i)-crfrg(3,1,ifg))**2)
        if(radi.gt.rad) rad=radi
      enddo
      crfrg(4,1,ifg)=rad
c     The radius of ifg fragment, crfrg(4,1,ifg) will be changed to account 
c     for basis set distribution. There are three values we should take into accouts.
c     1) The nuclei's geometric radius: max(nuclei-crfrg)
c     2) The primitive center: max(center of primitive Gaussian product - crfrg)
c     3) The basis set distribution : max(basis set distribution)
c     The final radius of fragment i = 1) + 2) + 3)  / 2
c
      call BASEXT(crfrg(1,1,ifg),crfrg(4,1,ifg))
c
c       For better performance, multiple centers for multipole calculations
c       are introduced, if NCENTM > 1.We assumed that crfrg = crfrg(4,NCENTM,nfg).
c       Our first trial will adopt the heavy atom positions as additional
c       points.
c       Note that
c        ncentm = maxnath + 2, when modfmm=16
c        ncentm = maxnat  + 2, when modfmm=32
c        Maxnath : the maximum number of heavy atoms among all fragments
c        Maxnat  : the maximum number of all atoms among all fragments
c       crfrg(*,1,ifg) should contain the overall center of fragment ifg.
c       crfrg(*,2~nat+1,ifg) will contain the centers of heavy atoms.
c
c     In the case of multicenter, the nuclei's geometric distance, rad becomes
c     irrelevant. 
c     Therefore the multicenter should only be based on the the primitive center 
c     and basis set distribution.
c
      if (ncentm.gt.1) then
        icnt=1
        do i=1,nat
c
          if (ian(i).ne.1.or.iand(modfmm,32).ne.0) then  
             icnt=icnt+1
             if(icnt.ge.ncentm) call abrt
c            icnt cannot be equal to ncentm (reserved).
             do j=1,3
                 crfrg(j,icnt,ifg)=C(j,i)
             enddo
             crfrg(4,icnt,ifg)=0.0d+00
          endif
        enddo
c       The total number of multiple centers of a fragments will be saved in
c       crfrg(1,ncentm,*)
        crfrg(1,ncentm,ifg)=icnt-1
c
c       Now we set all coordinates and radii of all multiple centers of ifg.
        call setmulcent(crfrg(1,1,ifg))
c
        if(maswrk) write(iw,9020) ifg,(crfrg(i,1,ifg)*units,i=1,3),
     *                             rad*units,crfrg(4,1,ifg)*units,icnt-1
c        For multicenter points
         do j=1,icnt-1
         if(maswrk) write(iw,9030) j,(crfrg(i,j+1,ifg)*units,i=1,3),
     *                       crfrg(4,j+1,ifg)*units
        enddo
      else
        if(maswrk) write(iw,9010) ifg,(crfrg(i,1,ifg)*units,i=1,3),
     *                               rad*units,crfrg(4,1,ifg)*units
      endif
c
      return
 9010 format(1x,'IFG=',I5,' C=',3F13.6,' R0=',F10.6,' R=',F10.6)
 9020 format(1x,'IFG=',I5,' C=',3F13.6,' R0=',F10.6,' R=',F10.6,
     *          ' NMC=',I6)
 9030 format(1x,'MC= ',I5,' C=',3F13.6,' R=',F10.6)
      end
c
C*MODULE fmomm  *DECK setmulcent
C>
C>     @brief Multipole centers and their radii. 
C>
C>     @details Calculate multipole centers and their radii.
c>      This routine will set all centers and their max_radii of multicenters
c>      of fragment.
C>
C>     @author Cheol Ho Choi
C>
C>     @ param ctr : the geometric center of a given fragment should 
C>     be given. 
C
      SUBROUTINE setmulcent(Ctr)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXSH=5000,MXGTOT=20000,MXATM=2000)
      PARAMETER (ZERO=0.00D+00,ONE=1.0D+00,TWO=2.0D+00)
      PARAMETER (MAXMC=MXATM+2)
c     PARAMETER (SQRT3=1.73205080756888D+00,SQRT5=2.23606797749979D+00)
      LOGICAL GOPARR,DSKWRK,MASWRK,QOPS,QFMM,IANDJ,nxt
      COMMON /FMCOM / XX(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /QMFM  / SIZE,EPS,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
c
      DIMENSION ctr(4,ncentm),pctr(3)
      DIMENSION rMMS(MAXMC),p_counter(MAXMC),rDISTS(MAXMC),
     *          rMAX(MAXMC)
C     
c      TOL=RLN10*ITOL
c     For better definition of radius of centers
      BEX=SQRT(2.0D+00)*DERFINV(ONE-DPGD)
      do i=1,MAXMC
         p_counter(i)=zero
         rMMS(i)=zero
         rMAX(i)=zero
         rDISTS(i)=zero
      enddo
c     rMM_MAX=zero
C     
      NXT = IBTYP.EQ.1
      NEXT  = -1
      kount = -1
c
c     We first calculate the electron contributions.
C
c     First shell loop.
c
      DO II=1,NSHELL
         Iatom=KATOM(II)
         XI=C(1,iatom)
         YI=C(2,iatom)
         ZI=C(3,iatom)
         I1=KSTART(II)
         I2=I1+KNG(II)-1
c        MINI=KMIN(II)
c        MAXI=KMAX(II)
c        LIT=KTYPE(II)
c        ILOC=KLOC(II)
C
C        SECOND SHELL LOOP.
C
         DO JJ=1,II
           if(goparr) then
              kount=kount+1
              if(nxt) then
                 IF(kount.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
                 if(NEXT.ne.kount) goto 700
              else
                 if(MOD(kount,NPROC).NE.me) goto 700
              endif
            endif
            Jatom=KATOM(JJ)
            XJ=C(1,Jatom)
            YJ=C(2,Jatom)
            ZJ=C(3,Jatom)
            J1=KSTART(JJ)
            J2=J1+KNG(JJ)-1
c           MINJ=KMIN(JJ)
c           MAXJ=KMAX(JJ)
c           LJT=KTYPE(JJ)
c           JLOC=KLOC(JJ)
c           RR=(XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
            IANDJ=II.EQ.JJ
c
C           Loop over primitive Gaussians
C
C           I PRIMITIVE.
C
            JGMAX=J2
            DO IG=I1,I2
               AI=EX(IG)
c              ARRI=AI*RR
               AXI=AI*XI
               AYI=AI*YI
               AZI=AI*ZI
c              CSI=CS(IG)
c              CPI=CP(IG)
c              CDI=CD(IG)
c              CFI=CF(IG)
c
C              J PRIMITIVE
c
               IF(IANDJ) JGMAX=IG
               DO JG=J1,JGMAX
c
                  AJ=EX(JG)
                  AA=AI+AJ
c                 DUM=AJ*ARRI/AA
c                  IF(DUM.GT.TOL) GO TO 6000
c
c                 The unique center of the primitive Gaussian product
c
                  pctr(1)=(AXI+AJ*XJ)/AA
                  pctr(2)=(AYI+AJ*YJ)/AA
                  pctr(3)=(AZI+AJ*ZJ)/AA
c
C                 The input argument ctr should contain the center of 
c                 fragment.
c
C                 Calcualte the translational vector, Pnt.
c                 Note: CTR -> center of fragment.
c                 pctr -> the unique center of product of primitive 
c                 Gaussian.
c
c                 Note that we will put the generated multipole to the closest center!
c                 We also collect information for optimum radius of centers.
                  call getnear(1,pctr,ctr(1,1),ncentm,idx,rDIST)
                  p_counter(idx)=p_counter(idx)+one
c                 rDIST : The distance between the center(idx) and 
c                         primitive center(pctr).
c                 rMM : basis set distribution width
                  rDISTS(idx)=rDISTS(idx)+rDIST
                  rMM=BEX/SQRT(AA)
                  rMMS(idx)=rMMS(idx)+rMM
                  if (rMM.gt.rMAX(idx)) rMAX(idx)=rMM
c              J primitive
               ENDDO
c           I primitive
            enddo
  700    continue 
c        J shell
         enddo
c     I shell
      enddo
      IF (GOPARR.and.nxt) CALL DDI_DLBRESET
c
c     now comes the clumsy part of finding the max radius values across all nodes.
c
      if(goparr) then
        CALL DDI_GSUMF(2414,p_counter,ncentm)
        CALL DDI_GSUMF(2414,rMMS,ncentm)
        CALL DDI_GSUMF(2414,rDISTS,ncentm)
        CALL VALFM(LOADFM)
        lrad=LOADFM+1
        last=lrad+nproc*2
        NEED = LAST- LOADFM -1
        CALL GETFM(NEED)
c       We may not use rMAX and ctr for the moment.
        do i=2,int(ctr(1,ncentm))+1
          call vclr(xx(lrad),1,nproc*2)
          xx(lrad+me)=ctr(4,i)
          xx(lrad+nproc+me)=rMAX(i)
          CALL DDI_GSUMF(2414,xx(lrad),nproc*2)
          ctr(4,i)=xx(lrad+idamax(nproc,xx(lrad),1)-1)
          rMAX(i)=xx(lrad+nproc+idamax(nproc,xx(lrad+nproc),1)-1)
        enddo
        CALL RETFM(NEED)
      endif 
c
c     Before returning we should set optimum radius of multi-centers.
c     We only change radius on the basis of averaged rDIST and rMM.
c
c     Factor : the weight factor for diffuse functions.
      Factor = 0
      do i=2,int(ctr(1,ncentm))+1
c        By dividing p_counter(i), we assume that we are using the average
c        radius.
         rMM=(one-factor)*rMMS(i)/p_counter(i)+Factor*rMAX(i)
         rDIST=rDISTS(i)/p_counter(i)
c         if ((rMM+rDIST).gt.ctr(4,i)) ctr(4,i)=(ctr(4,i)+rMM+rdist)/two   
          ctr(4,i)=(rMM+rDIST)/two
      enddo
C
      RETURN
      END
C*MODULE FMOmm  *DECK getnear
      subroutine getnear(imode,vref,crfrg,ncentm,idx,rdiff)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension vref(3),crfrg(4,ncentm)
c     This routine finds the closest center from current position within a 
c     fragment.
c     If imode=1, this also sets the geometric radius of centers of fragments.
c     Otherwise, it will return idx and rdiff.
c     idx : the index of the closest center from vref.
c     rdiff : square distance between vref and crfrg
c
      rdiff=1.0d+99
      do i=2,int(crfrg(1,ncentm))+1
         diff=0.0d+00
         do j=1,3
            diff=diff+(vref(j)-crfrg(j,i))**2
         enddo
         if (diff.lt.rdiff) then
            idx=i
            rdiff=diff
c           write(6,*) '2 GETNEAR: -->  idx, rdiff',idx,sqrt(rdiff)
         endif
      enddo
c     This the place we set the geometric radius of centers of fragments.
      if (imode.eq.1) then
      rdiff=sqrt(rdiff)
cc      write(6,*) '3 GETNEAR: idx, rdiff, crfrg(4,idx)',idx,rdiff,
cc     *crfrg(4,idx)
      if (rdiff.gt.crfrg(4,idx)) crfrg(4,idx)=rdiff
      endif
c
      return
      END
C*MODULE FMOMM  *DECK MxNPs
C>
C>     @brief the largest angluar momentum 
C>
C>     @details Calculate the largest angluar momentum for multipoles. 
c>     This routine determines the largest l (NPs)  for generaring YlmI.
c>     NPst also contains the same NPs.
c>     Currently it is implemented only for single center.
C>
C>     @author Cheol Ho Choi
C>
C>     @param crfrg : center of fragment
C>
C>     @param nps : angular momentum number
C>
C>     @param npst : current angular momentum number
C>
      subroutine MxNPs(crfrg,nps,npst)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL QOPS,QFMM
      parameter(ONE=1.0D+00,two=2.0d+00)
      COMMON /QMFM  / SIZE,EPS,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,  
     *                ITERMS,QOPS,ISCUT
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody   
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm   
      dimension crfrg(4,ncentm,nfg)
c
      Nps=0
      criterion=log10(one/(two*(iws+one)))
      do i=1,nfg
         npst=int((log10((two*iws+one)*EPS*crfrg(4,1,i))/criterion)-one)
         if (npst.gt.nps) nps=npst   
      enddo
      npst=nps
c
      return
      END
C*MODULE fmomm  *DECK combcent
C>
C>     @brief combine centers 
C>
C>     @details Combine multipole centers. 
c>     This routine combines the multi-centers of I and J or I, J and K fragments.
c>     At least, I and J should not be zero.
c>     This subroutine returns the combined and expended centers in ctrijk and 
c>     their number in ijkctr. It is noted that additional points will be added
c>     for the inter-fragment regions.
C>
C>     @author Cheol Ho Choi
C>
C>     @param ncentm : number of points of a given fragment
C>
C>     @param crfrg : center of fragment
C>
C>     @param i : fragment I
C>
C>     @param J : fragment J
C>
C>     @param k : fragment K
C>
C>     @param ctrijk : center of IJK
C>
C>     @param ijkctr : number of IJK center
C>
      SUBROUTINE combcent(ncentm,crfrg,i,j,k,ctrijk,ijkctr)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      Parameter (MXATM=2000,two=2.0D+00,Three=3.0D+00)
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody   
c     COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      dimension crfrg(4,ncentm,nfg),ctrijk(4,mxatm)
c
      Li=0
      Lj=0
      Lk=0
      call vclr(ctrijk,1,4*mxatm)
      if (i.eq.0) call abrt
      Li=int(crfrg(1,ncentm,i))
      if (j.eq.0) call abrt
      if (j.ne.0) Lj=int(crfrg(1,ncentm,j))
      if (k.ne.0) Lk=int(crfrg(1,ncentm,k))
c
      do ii=1,Li
         do jj=1,4
            ctrijk(jj,ii+1)=crfrg(jj,ii+1,i)
         enddo
      enddo
c     We add 1 to ijkctr for the first element.
      ijkctr=1+Li
c
c     dimer IJ or trimer IJK.
      if (j.ne.0) then
         do ii=1,Lj
            do jj=1,4
               ctrijk(jj,ii+ijkctr)=crfrg(jj,ii+1,j)
            enddo
         enddo
         ijkctr=ijkctr+Lj
c        We add centers between the I and J fragments.
c        Note that the radius of added centers is set to
c        max(crfrg(4,1,i),crfrg(4,1,j)).
         call addcent(ncentm,crfrg,i,j,ctrijk,ijkctr)
      endif
chc
c      write(IW,*) 'combcenter',i,j,k
c      write(IW,*) 'ijkctr =',ijkctr
c      do ii=1,ijkctr
c         write(IW,1000) ctrijk(1,ii),ctrijk(2,ii),ctrijk(3,ii)
c      enddo  
c      stop
chc
c
c     trimer IJK.
      if (k.ne.0) then
         do ii=1,Lk
            do jj=1,4
               ctrijk(jj,ii+ijkctr)=crfrg(jj,ii+1,k)
            enddo
         enddo
         ijkctr=ijkctr+Lk
c        Centers between the I and J fragments are already added.
c
c        We add centers between the I and K fragments.
         call addcent(ncentm,crfrg,i,k,ctrijk,ijkctr)
c        We add centers between the J and K fragments.
         call addcent(ncentm,crfrg,j,k,ctrijk,ijkctr)
      endif
c     We add 1 to ijkctr for the last element.
      ijkctr=ijkctr+1
      ctrijk(1,ijkctr)=ijkctr-2
c     We should set the overall center and radius.
      if (k.eq.0) then
         do ii=1,3
            ctrijk(ii,1)=(crfrg(ii,1,i)+crfrg(ii,1,j))/two
         enddo
         ctrijk(4,1)=max(crfrg(4,1,i),crfrg(4,1,j))
      else
         do ii=1,3
            ctrijk(ii,1)=(crfrg(ii,1,i)+crfrg(ii,1,j)
     *                  +crfrg(ii,1,k))/three
         enddo
         ctrijk(4,1)=max(crfrg(4,1,i),crfrg(4,1,j))
         ctrijk(4,1)=max(crfrg(4,1,k),ctrijk(4,1))
      endif
c
      RETURN
c1000 format(1x,3F10.5)
      END
C*MODULE fmomm  *DECK addcent
C>
C>     @brief add centers 
C>
C>     @details Add multipole centers. 
c>     This routine add the multi-centers of I and J fragments.
c>     It is assumed that ctrIJK already contains the indivisual multi-centers
c>     of I, J and K fragments. Therefore this routine only adds the multi-
c>     centers between the I and J.
c>     In the case of IJK trimer ESP runs, this routine should be called 
c>     three times with the arguments of (I,J), (I,K) and (J,K) for the
c>     input arguments of i and j.
C>
C>     @author Cheol Ho Choi
C>
C>     @param ncentm : number of center of a given fragment:
C>
C>     @param crfrg : center of fragment
C>
C>     @param i : fragment I
C>
C>     @param j : fragment J
C>
C>     @param ctrijk : IJK center
C>
C>     @param ijkctr : ijk center idx
C>
      SUBROUTINE addcent(ncentm,crfrg,i,j,ctrijk,ijkctr)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      Parameter (MXATM=2000,MXPLATE=10,zero=0.0d+00,two=2.0D+00)
      LOGICAL GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody   
      dimension crfrg(4,ncentm,nfg),ctrijk(4,mxatm),t(3),rCnt(3),
     *          rPnt(3),rPPnt(3)
c
c     The shortest distance between I and J 
c      rIJ=fmodist(i,0,0,j)
c     The max(r) of multicenter I and J
      rMax=max(crfrg(4,1,i),crfrg(4,1,j))
c     The center to center distance between I and J
c     t=crfrg(j)-crfrg(i)
      call vsub(crfrg(1,1,i),1,crfrg(1,1,j),1,t,1,3)
      rCC=sqrt(t(1)*t(1)+t(2)*t(2)+t(3)*t(3))
      do II=1,3
         t(II)=t(II)/rCC
      enddo
c     R : The single center radius of max(I,J)
c      R=abs(rCC-two*rMax)/two
c     Iratio : The number of planes inserted between I and J.
c      Iratio=int(floor(rIJ/rMax))
      Iratio=int(floor((rCC-two*rMax)/rMax))
      If (Iratio.eq.0) Iratio=1
      if(Iratio.gt.mxplate) then
        if(maswrk) write(iw,*) 'Increase mxplate in the code.'
        call abrt
      endif
c
c     From now on, we'll generate additional 4 centers for each
c     planes between I and J.
c
      do II=1,Iratio
c        Generate center position vector (rCnt) of plane.
c        call vadd(crfrg(1,1,II),1,t*(R+rMax*II),1,rCnt,1,3)
         do 100 m=1,3
  100      rCnt(m)=crfrg(m,1,I)+t(m)*(rMax+rMax*II)
c  100      rCnt(m)=crfrg(m,1,II)+t(m)*(R+rMax*II)
c        The perpendicular directional vector (rPnt) to rCnt         
         rPnt(1)=-rCnt(2)
         rPnt(2)=rCnt(1)
         rPnt(3)=zero
         rPntN=sqrt(rPnt(1)*rPnt(1)+rPnt(2)*rPnt(2))
         do KK=1,3
            rPnt(KK)=rPnt(KK)/rPntN
         enddo
c        The perpendicular directional vector (rPPnt) to rCnt and t
         rPPnt(1)=rPnt(2)*t(3)-rPnt(3)*t(2)
         rPPnt(2)=rPnt(3)*t(1)-rPnt(1)*t(3)
         rPPnt(3)=rPnt(1)*t(2)-rPnt(2)*t(1)
         rPPntN=sqrt(rPPnt(1)*rPPnt(1)+rPPnt(2)*rPPnt(2)+
     *               rPPnt(3)*rPPnt(3))
         do KK=1,3
            rPPnt(KK)=rPPnt(KK)/rPPntN
         enddo
c        Using rPnt and rPPnt, now we generate 4 centers.
         ijkctr=ijkctr+1
c        call vadd(rCnt,1,rPnt*rMax*2,1,ctrIJK(1,ijkctr),1,3)
         do 200 m=1,3
  200      ctrIJK(m,ijkctr)=rCnt(m)+rPnt(m)*rMax
         ctrIJK(4,ijkctr)=rMax
         ijkctr=ijkctr+1
c        call vadd(rCnt,1,-rPnt*rMax*2,1,ctrIJK(1,ijkctr),1,3)
         do 300 m=1,3
  300      ctrIJK(m,ijkctr)=rCnt(m)-rPnt(m)*rMax
         ctrIJK(4,ijkctr)=rMax
         ijkctr=ijkctr+1
c        call vadd(rCnt,1,rPPnt*rMax*2,1,ctrIJK(1,ijkctr),1,3)
         do 400 m=1,3
  400      ctrIJK(m,ijkctr)=rCnt(m)+rPPnt(m)*rMax
         ctrIJK(4,ijkctr)=rMax
         ijkctr=ijkctr+1
c        call vadd(rCnt,1,-rPPnt*rMax*2,1,ctrIJK(1,ijkctr),1,3)
         do 500 m=1,3
  500      ctrIJK(m,ijkctr)=rCnt(m)-rPPnt(m)*rMax
         ctrIJK(4,ijkctr)=rMax
      enddo
c
c     Note that the radius of newly added centers were set to rMax
c
      RETURN
      END
