C 15 Apr 13 - MWS - wider format for projection wavefunction
C 19 Oct 12 - MWS - synchronize FRGINF common
C XX XXX 12 - SRP - ADD EXCHANGE REPULSION AND CHARGE TRANSFER TO EFMO
C 23 Mar 12 - CHC - Patch for num hessian with move.eq.0
C 20 Feb 12 - MWS - fix dyn.polar. centroid input, allow old CT input
C 28 DEC 11 - CS  - EFMO CHANGES FOR COVALENT BONDS
c  5 Dec 11 - PX  - charge transfer can use VVOs, input keywords changed
C 11 AUG 11 - AAD - QM/EFP ENERGY DECOMPOSITION ANALYSIS
C 11 AUG 11 - LVS - ALLOW EFP1 TO USE POL. SCREENING, BY INPUT REQUEST
C 15 APR 11 - MWS - KILL RUNS THAT ENTER CUTOFFS W/O PBC BOX GIVEN
C 12 DEC 10 - HL  - ADD POL5P,TIP5P,TIP5PE,SPC,SPCE; NEW DECK RDLJPOT
C  1 OCT 10 - CS  - ADDED EFMO CHANGES
C 11 AUG 10 - DGF - SYNCH COMMON BLOCK PRPOPT
C 25 MAR 10 - MWS - FIX DEVELOPER'S BACK DOOR KEYWORD
C 14 OCT 09 - MWS - LEVELEFP: ADDED ROUTINE TO QUERY THE EFP LEVEL
C  4 MAY 09 - NMT,HL - FLEXIBLE EFP, READ PDB ATOMS FOR EFP
C  1 MAY 09 - LVS - GATHER EFP FORCES AT CENTERS, NEW DAMPING DEFAULTS
C 15 DEC 08 - MWS - RDFRG: ALLOW ALL EFP ATOMS TO BE PRESENT, IF >3.
C 23 OCT 08 - LVS - READ NEW DAMPING DATA, CLEAN UP JIE'S CODES
C 18 JUL 08 - SRP - EFPX: WRITES UNIQUE ATOM LABELS TO -NFTEFP-
C 18 JUL 08 - SHY - FRGROT: FIX RANGE OF DISPERSION LOOP 840
C 11 APR 08 - JMM - EFPX,EFP2X: SKIP MAKEFP TERMS, OUTPUT TO -NFTEFP-
C 11 APR 08 - MWS - EFPINP: ALLOW INPUT TO SWITCH OFF SELECTED PHYSICS
C 11 APR 08 - JMM - IGNORE $EFRAG MXBF/MXMO, GET THEM FROM $FRAGNAME'S
C  7 DEC 07 - MWS - EFP2X: FIX MEMORY LEAK ABOUT OPEN SHELLS
C 28 AUG 07 - MWS - EFINP: KILL JOBS WITH PBC INPUT FOR AB INITIO RUNS
C 20 AUG 07 - LVS - PRINTS AND CHECKS FOR PBC
C 21 MAY 07 - MWS - BETTER EFP SUMMARY PRINT, RDPAO: TRAP ON ERRORS
C 24 MAR 07 - LVS - POLARIZATION SCREENING ADDED
C  6 NOV 06 - MWS - ADJUST WAVEFUNCTION COMMON BLOCK
C 25 OCT 06 - SHY - WATRHF,WATDFT: ENSURE TOTAL CHARGE IS EXACTLY ZERO
C  7 SEP 06 - DDK - INCLUDE SOME OPEN SHELL EFP WORK
C  8 MAY 06 - LVS - INTERFACE TO HIGH-ORDER ELECTR. FRAG-FRAG. SCREENING
C 13 MAR 06 - TN  - FRGROT: SMALL FIX FOR EFP/FMO INTERFACE
C 22 FEB 06 - LVS - SYNCHRONIZE STNBUF COMMON
C 17 JAN 06 - HL  - EFINP: READ ISWF,SWFR1,SWFR2 FOR PBC/MD
C 14 NOV 05 - MWS - EFP2X: SKIP DYN.POL. OUTPUT IF NOT COMPUTED
C 19 SEP 05 - IA  - SYNCHRONIZE FRGINF COMMON
C 15 JUL 05 - MWS - EFINP: VCLR EFP2 STORAGE ONLY IF USED
C 13 JUL 05 - HL  - EFINP: ZEROING, POLMETHOD=SCF MUST HAVE AB INIT SYS
C  5 JUL 05 - MWS - SELECT NEW ATOM,BASIS,EFP,PCM,DAF DIMENSIONS
C 27 JUN 05 - HL  - PERIODIC BOUNDARY COND. FOR EFP
C 27 JUN 05 - IA  - EFP2X: PARALLEL MUST READ DYN.POLAR. DAF RECORD
C  1 JUN 05 - MWS - REMOVE PARALLEL MP2/EFP1 TRAP, H2OEF2->H2ORHF
C 14 MAR 05 - HL  - EFP2X: PUNCH OUT CANONICAL MO AND FOCK MATRIX
C                   RDCANV: NEW ROUTINE TO READ IN CAN. MO/FOCK
C                   FRGROT: ROTATE CAN. MO, ADD F AND G FUNCTIONS
C  7 MAR 05 - IA  - CHANGES TO READ/ROTATE DYNAMIC POLARIZABILITY
C 22 FEB 05 - MWS - EFINP: ZERO ALL POTENTIALS, KILL BUGGY PAR. RUNS
C 13 FEB 05 - HMN - EFINP: ADD DUMMY POLMETHD=SPCE TO TREAT SPCE WATERS
C                   EFINP: ADD DUMMY FRGMNT = $H2OSPC TO GET SPCE WATERS
C                   ADD SPCEWA ROUTINE TO GET STANDARD SPCE DATA
C                   EFINP: ADD KEYWORD FRAGTYP TO CHECK FOR MP2 RUN
C 13 FEB 05 - JS  - EFP MP2 CHANGES TO EFINP,FRGROT,RDGFDP, AND READING
C  9 DEC 03 - MWS - WRITE ERROR MESSAGE BEFORE -ALL- ABORT CALLS
C 26 MAR 03 - MWS - EFPX: FIX THE PULL THE PLUG ERROR MESSAGE
C 12 DEC 02 - IA  - ADD DFT WATER PARAMETERIZATION,
C           - MWS - PREFIN: ALWAYS CALLED, EXIT W/O READ IF NOT MAKEFP
C 17 AUG 02 - MWS - PRTFRG: FIX SOME PRINTING
C  7 AUG 02 - IA  - RDSTFR,FRGROT,RDSCRN: READ EXPONENTIAL CHG SCREENING
C  7 AUG 02 - HT  - USE DYNAMIC MEMORY FOR PAULI REPULSION
C  7 AUG 02 - HL,PM - EFP2X: CONTROL EFP GENERATION, NEW PREFIN
C 17 APR 02 - PND - RDPMO: TRAP ARRAY OVERFLOW
C 26 MAR 02 - KRG - USE ABRT CALLS
C 13 JUN 01 - PM,MAF - EFP2X: OVERLAPPING BUFFERS, EFPX: CHG PEN CALLS
C 28 FEB 01 - PND - RDPMO: SAVE PAULING BASIS SET SIZE IN COMMON
C 19 NOV 00 - RMM,HL - EFP2X: PAD OUT EDCMP FOR POLAPP KEYWORD
C 26 OCT 00 - MWS - INTRODUCE MXAO PARAMETER, VARIABLES IN BCAST CALLS
C 16 FEB 00 - VK  - EFPX: REMOVED REDUNDANT LMOINP CALL
C                   EFINP: NEW KEYWORD NBUFMO FOR QM/MM CALCULATIONS
C                   EFP2X: SKIP FROZEN QM/MM BUFFER ORBS IN POLAR PUNCH
C 27 FEB 98 - MWS - EFINP: EXIT IF NOT DOING PAULI POTENTIAL
C 20 NOV 97 - MWS - EFINP: KILL AB INITIO RUNS IF JAN'S PAULI POTENTIAL
C 28 SEP 97 - MWS - CONVERT PARALLEL CALLS FROM TCGMSG TO DDI
C 16 JUL 97 - GNM - EFINP: ALLOW DEFINITION OF TIP*P MODELS
C  8 MAY 97 - PND - RDPMO: CHANGES FOR PARALLEL COMPUTATION
C  7 MAR 97 - JF  - RDFGRP: DECLARE REREAD TO BE EXTERNAL
C 20 DEC 96 - HPP - FRGROT: DECLARE ARGUMENT AS CHARACTER TYPE
C 18 DEC 96 - JHJ - NUMEROUS CHANGES RELATED TO NEW PAULI REPULSION
C 16 DEC 96 - PND - EFNP: CORRECTION FO RDFGRP'S DAREAD CLAUSE
C 30 OCT 96 - SPW - EFINP: ALLOW MCSCF+IEFP RUNS
C 17 OCT 96 - MWS - EFINP,RDFRG: BOMB MCSCF+IEFP RUNS, CHECK FOR -ZNUC-
C 29 SEP 96 - MWS - INPUT CHECKING, REMOVE FRAG-FRAG REPULSION COMMON,
C                   RDDFRL,RDFRG,RDFRG2,WATRHF: REMOVE BIEXPONENTIAL
C 14 SEP 96 - BMB - EFINP: INSERT CALL TO PREPARE ERF TABLE.
C 10 SEP 96 - JHJ - EFINP,WATRHF: STORE WATER FRAGMENT INTERNALLY.
C 10 SEP 96 - MWS - EFINP,RDDFRL: CHANGE INPUT A BIT
C 24 MAY 96 - WC  - REMOVE EFPEX IN COMMOM EFPPAR
C  9 JAN 96 - WC  - INPUT FRAGMENT ATOMIC NUMBERS TO IDENTIFY ATOMS
C 12 SEP 95 - WC  - FIXES IN FRGROT,RDSTFR, ADD RDDFRL, COMMON FRGTYP
C 18 AUG 95 - MWS - RENAME RDCRD TO RDCRDX TO AVOID NBO NAME CONFLICT
C  5 JAN 95 - PND - CHANGES FOR UNSYMMETRIC POLARIZABILITY TENSORS
C 23 NOV 94 - MWS - REMOVE ALL FTNCHEK ERRORS
C 10 AUG 94 - MWS - INCREASE NUMBER OF DAF RECORDS
C 27 NOV 91 - JHJ - PRTFRG:IMPROVE PRINTOUT.
C 28 OCT 91 - JHJ - EFINP:OPEN FILE 25.
C 30 JUL 91 - JHJ - CHANGED THE WAY MULTIPOLE INFORMATION IS READ IN.
C 11 JUL 91 - JHJ - RDREP:READ IN REPULSIVE POTENTIAL INFORMATION.
C 10 JUL 91 - JHJ - EFINP,RDFRG:USE UNIT INFORMATION FROM $CONTRL.
C  9 JUL 91 - JHJ - RDSTFR:READ IN POLARIZABILITY INFORMATION.
C                   EFINP:ADDED OPTION TO READ IN METHOD INF.
C 18 JUN 91 - JHJ - NEW MODULE-READ IN MULTIPOLE INFORMATION.
C
C*MODULE EFINP   *DECK EFINP
C>
C>    @brief Reads in input parameters for efp runs
C>
C>    @author Jan H. Jensen
C>
C>    @date October, 2012 - Colleen Bertoni
C>    - Pulled out a list of IF statements (which turn efp terms
C>      off) and put them in a separate routine, since the same
C>      code is needed for EFMO runs.
C>
C>    @date Jan 10, 2013 - Tony Smith
C>    - Added keywords for EFP-AI dispersion energy, gradients,
C>      and screening type
C>
      SUBROUTINE EFINP(IUNTRD,IEF)
      USE EFAIDIS, ONLY : IQMDISP, IDISDMP, IDSGRD
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      PARAMETER (MXATM=2000, MXAO=8192, MXSHEF=1000, MXGEFP=4000,
     *           MXPT=2000, MXFRG=1050, MXFGPT=12000, MXDFG=5,
     *           MXDPPT=MXFRG*MXDFG*12, MXIFRQ=12)
C
      LOGICAL STOP,GPSAVE,GOPARR,MASWRK,DSKWRK,BILTIN
      LOGICAL NOELEC,NOESCR,NOPOL,NOPSCR,NOEXREP,NOCHTR,NODISP
      LOGICAL EFP1MODEL,EFP2MODEL
      LOGICAL DSKSAV
      LOGICAL IFRCPNT
C
      CHARACTER*8 PTNAM,TEMP,WORD2,WORD3,FRGMNT,FRCNME,
     *            MNAME,PNAME,DPNAME,RNAME,FNAME,LJNAME,ELJNAM
      CHARACTER*6 FRGNAM
      CHARACTER*1 DOLLAR,BLANK
      CHARACTER*8 TYPCRD(2),TYPPOS(3),TYPPOL(5)
C
      COMMON /CENTRL/ RQM,XQM,YQM,ZQM,RMM,XMM,YMM,ZMM,ICENFD
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NAT(MXDFG),NUM(MXDFG),NTPATM
      COMMON /EFPBUF/ POLCHG(10),NBUFMO,LBUFF(MXAO),LBF,NAPOL,IAPOL(10)
      COMMON /EFPCT / NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CTFOK(MXAO,MXDFG),NCTMO(MXDFG),NTCTMO
      COMMON /EFPFRC/ IFRCPNT,NTFRCPN,NFRCPNT(MXFRG),LSTFPTS(MXFRG),
     *                FRCCRD(3,MXFGPT),FRCNME(MXFGPT),FRCTRQ(6,MXFGPT)
     *                ,FRCTRQX(6,MXFGPT)
      COMMON /EFPMP2/ MP2TYP
      COMMON /EFPOTD/ METHPOL,INABIO,MOVE,nfrag
      COMMON /EFPPBC/ XBOX,YBOX,ZBOX,XCUT,YCUT,ZCUT,RCUT,
     *                SWR1,SWR2,ISWF
      COMMON /EFPSCR/ POLAB(MXFRG),B,SCROFF,IELECS,IDISPS,NEW_POL
      COMMON /FMCOM / XX(1)
      COMMON /KFINFO/ KATMS(MXFRG)
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGLJP/ CORDLJ(3,MXPT),ELJCRD(3,MXFGPT),
     *                POTLJ(2,MXPT),ELJPOT(2,MXFGPT),
     *                LJNAME(MXPT),ELJNAM(MXFGPT),
     *                NLJPTS(MXFRG),NLJTTPT,ILJP,NMLJ(2)
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ*MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /INFOA / NATINF,ICH,MUL,NUMINF,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /PLSCR / IPLSCR,INDSCR
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      PARAMETER (ZERO=0.0D+00)
      SAVE ICYC
C
      DATA ENERGY/8HENERGY  /
      DATA TYPCRD/'CART    ','INT     '/
      DATA TYPPOS/'FIXED   ','OPTIMIZE','EFOPT   '/
      DATA TYPPOL/'FRGSCF  ','SCF     ','TIP3P   ','TIP4P   ',
     *             'SPCE    '/
      DATA DOLLAR,BLANK/'$',' '/
      DATA ICYC/0/
C
C   THIS ROUTINE IS THE MAIN DRIVER FOR EFFECTIVE FRAGMENT INPUT
C         WRITTEN BY JAN H. JENSEN 6/91 NDSU/CARB
C
C         ----- BY DEFAULT, SWITCH OFF ALL EFP TERMS -----
C     FIRST, ZERO THE NUMBER OF EFPS, AND THEN ALL POTENTIAL TYPES
C
      NFRG = 0
C
C                 MULTIPOLE EXPANSIONS OF THE ELECTROSTATICS
C                 CHARGE PENETRACTION SCREENING OF ELECTROSTATICS
      IEFC = 0
      IEFD = 0
      IEFQ = 0
      IEFO = 0
C                 DIPOLE POLARIZABILITY
C                 NOTE: -IEFP- IS TO BE READ AS THE E-FFECTIVE F-RAGMENT
C                       P-OLARIZABILITY.  NFRG SWITCHES THE ENTIRE EFP
C                       MODEL ON OR OFF, WHILE -IEFP- IS JUST ONE TERM.
      IEFP = 0
C                 FITTED REPULSIVE POTENTIAL (NAMELY WATER!) FOR EFP-1
      IREP = 0
C                 LENNARD-JONES POTENTIAL
      ILJP = 0
C
C                 TERMS FOR EFP-2 POTENTIALS
C                 PAULI FORMULA REPULSIVE POTENTIAL
      NTMO = 0
C                 CHARGE TRANSFER
      NTAO = 0
      NTCTMO = 0
C                 DISPERSION
      IEFDP= 0
C
C        AND THEN ZAP ALL EXPANSION POINTS FOR ALL SUCH TERMS ABOVE
C
      NMTTPT = 0
      NPTTPT = 0
      NDPTTPT= 0
      NRTTPT = 0
      NDTTPT = 0
      NTPATM = 0
      NTFRCPN= 0
      NLJTTPT= 0
      DO I=1,MXFRG
         NMPTS(I) = 0
         NPPTS(I) = 0
         NDPPTS(I)= 0
         NRPTS(I) = 0
         NLJPTS(I)= 0
         NDPTS(I) = 0
         NORB(I)  = 0
         LSTMPTS(I) = 0
         LSTFPTS(I) = 0
         NFRCPNT(I) = 0
C         NEW POLARIZATION DAMPING (SEE NEW_POL)
         POLAB(I) = 0.6D+00
      ENDDO
      DO I=1,MXDFG
         NAT(I)   = 0
         NUM(I)   = 0
         NAO(I)   = 0
         NOCC(I)  = 0
         NVIR(I)  = 0
         NCTMO(I) = 0
      ENDDO
C           THESE ARE THE FLAGS TO GLOBALLY TURN OFF CERTAIN EFP TERMS.
C           THE OPTION -NOELEC- DOES NOT WORK, ACTUALLY.
      NOELEC =.FALSE.
      NOESCR =.FALSE.
      NOPOL  =.FALSE.
      NOPSCR =.FALSE.
      NOEXREP=.FALSE.
      NOCHTR =.FALSE.
      NODISP =.FALSE.
C  EFP-AI DISPERSION KEYWORDS
      IQMDISP = 0
      IDISDMP = 1
      IDSGRD  = 1
C
      METHPOL= -1
      MOVE  = -1
      INT   = -1
      NBM   = -1
      MXMO  =  0
      MXBF  =  0
      MXCTMO = 0
C
      XBOX = 0.0D+00
      YBOX = 0.0D+00
      ZBOX = 0.0D+00
      XCUT = 1.0D+10
      YCUT = 1.0D+10
      ZCUT = 1.0D+10
      RCUT = 1.0D+10
      SWR1 = 1.0D+10
      SWR2 = 2.0D+10
      ISWF = 1
      ICENFD = 0
      RQM  = 1.0D+10
      XQM  = 1.0D+10
      YQM  = 1.0D+10
      ZQM  = 1.0D+10
      RMM  = 2.0D+10
      XMM  = 2.0D+10
      YMM  = 2.0D+10
      ZMM  = 2.0D+10
C
C  ----        VARIOUS SCRENING & DAMPING OPTIONS
C
C       WHEN TO TURN OFF THE ELECTROSTATIC AND POLARIZATION DAMPING
C       AT LONG RANGE.  DEFAULT: NEVER
      SCROFF = 1.0D+04
C                 POLARIZATION SCREENING
C     THE FOLLOWING TWO FOR THE ELECTROSTATIC-BASED FORMULAS
      IPLSCR = 0
      INDSCR = 0
C        POLARIZATION DAMPING WITH TANG-TOENNIS LIKE FORMULA,
C        THE DEFAULT FOR EFP2 (AND SECRET DEFAULT FOR EFP1)
      NEW_POL = 0
C                 DISPERSION SCREENING
C         FOR DISPERSION DAMPING COEFFICIENT IN TANG-TOENNIS FORMULA
      B = 1.5D+00
C     IF OVERLAP-BASED DISPERSION FORMULA TO BE USED (DEFAULT)
      IDISPS = 0
C                 CHARGE PENETRACTION SCREENING OF ELECTROSTATICS
      ICHGP= 0
C                 ELECTROSTATIC OVERLAP-BASED DAMPING (DEFAULT FOR EFP2)
      IELECS = 0
C
C         IF USE FORCE POINTS
      IFRCPNT =.FALSE.
      CALL VCLR(FRCCRD,1,3*MXFRG)
      CALL VCLR(FRCTRQ,1,6*MXFRG)
      CALL VCLR(FRCTRQX,1,6*MXFRG)
C
C  ----
C
      CALL VCLR(XCRD,1,50*MXFRG)
      CALL VCLR(YCRD,1,50*MXFRG)
      CALL VCLR(ZCRD,1,50*MXFRG)
C
C     ----- POSITION THE INPUT TO $PDBFRG ----
C
      IEOF = 0
      IPDB = 0
      CALL SEQREW(IR)
      CALL FNDGRP(IR,' $PDBFRG',IEOF)
      IF(IEOF.NE.0) THEN
         IEF = 0
         IPDB= 0
      ELSE
         WRITE(IW,*)' '
         WRITE(IW,*)' $PDBFRG FOUND...'
         IEF =1
         IPDB=1
         NOEXREP = .TRUE.
      END IF
C     - ONLY RUNTYP=ENERGY IS SUPPORTED FOR $PDBFRG
      KERR = 0
      IF(IPDB.EQ.1) THEN
         IF(RUNTYP.NE.ENERGY) KERR = 1
         IF(KERR.EQ.1)THEN
           WRITE(IW,*)' ERROR: ONLY ENERGY RUN IS SUPPORTED FOR $PDBFRG'
           CALL ABRT
         END IF
      END IF
C
C     ----- POSITION THE INPUT TO $EFRAG -----
C     IF THIS GROUP IS ABSENT, EXIT WITH NO EFFECTIVE FRAGMENTS IN USE
C     HOWEVER, WE MUST KEEP GOING IF $PDBFRG WAS JUST FOUND
C
      IERR = 0
      IEOF = 0
      CALL SEQREW(IR)
      CALL FNDGRP(IR,' $EFRAG ',IEOF)
      IF(IEOF.NE.0) THEN
         IEF = 0
         IEFRAG = 0
      ELSE
         IEF=1
         IEFRAG = 1
      END IF
C
      IF(IEFRAG.EQ.1) THEN
         CALL BASCHK(LMAX)
         IF (LMAX.GE.4) THEN
            IF(MASWRK) WRITE(IW,9210)
            CALL ABRT
         END IF
      END IF
C
      IF(IEFRAG.EQ.0 .AND. IPDB.EQ.0) RETURN
      IF(IEFRAG.EQ.0 .AND. IPDB.EQ.1) GO TO 145
C                                     *********
C
C        SET UP ERROR FUNCTION INTERPOLATION TABLE
C
      CALL ERRT
C
C        READ MAIN $EFRAG KEYWORDS
C
      IF(NATINF.EQ.0) CALL OPNCRD(IR,-IW)
      CALL RDCARD('$EFRAG  ',IEOF)
      IF(IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,*) 'END OF FILE LOOKING FOR $EFRAG GROUP'
         CALL ABRT
      END IF
 140  CONTINUE
      WORD2='        '
      LGSTR=-8
      CALL GSTRNG(WORD2,LGSTR)
      IF(WORD2.EQ.'        ') GO TO 145
C
      IF(WORD2.EQ.'POLMETHD') THEN
         WORD3='        '
         LGSTR=-8
         CALL GSTRNG(WORD3,LGSTR)
         METHPOL=-2
         IF(WORD3.EQ.'FRGSCF  ') METHPOL=2
         IF(WORD3.EQ.'SCF     ') METHPOL=3
         IF(METHPOL.EQ.-2) THEN
            IF(MASWRK) WRITE(IW,*) '$EFRAG: ILLEGAL POLMETHD=',WORD3
            CALL ABRT
         END IF
C           W/O AB INITIO SYSTEM, POLMETHOD=SCF MAKES NO SENSE AT ALL
         IF(NUMINF.EQ.0  .AND.  METHPOL.EQ.3) METHPOL=2
         GO TO 140
      END IF
C
      IF(WORD2.EQ.'POSITION') THEN
         WORD3='        '
         LGSTR=-8
         CALL GSTRNG(WORD3,LGSTR)
         MOVE=-2
         IF(WORD3.EQ.'FIXED   ') MOVE=0
         IF(WORD3.EQ.'OPTIMIZE') MOVE=1
         IF(WORD3.EQ.'EFOPT   ') MOVE=2
         IF(MOVE.EQ.-2) THEN
            IF(MASWRK) WRITE(IW,*) '$EFRAG: ILLEGAL POSITION=',WORD3
            CALL ABRT
         END IF
         GO TO 140
      END IF
C
      IF(WORD2.EQ.'COORD   ') THEN
         WORD3='        '
         LGSTR=-8
         CALL GSTRNG(WORD3,LGSTR)
         INT=-2
         IF(WORD3.EQ.'CART    ') INT=0
         IF(WORD3.EQ.'INT     ') INT=1
         IF(INT.EQ.-2) THEN
            IF(MASWRK) WRITE(IW,*) '$EFRAG: ILLEGAL COORD=',WORD3
            CALL ABRT
         END IF
         GO TO 140
      END IF
C
      IF(WORD2.EQ.'NBUFFMO ') THEN
        NBUFMO=-2
        NBUFMO = IFIND('NBUFMO  ',IERR)
        IF(NBM.EQ.-2) THEN
           IF(MASWRK) WRITE(IW,*) '$EFRAG: ILLEGAL NBUFFMO=',NBM
           CALL ABRT
        END IF
        GO TO 140
      END IF
C          AS OF MARCH 2008, IT IS NO LONGER NECESSARY TO READ
C          THESE VALUES, BUT SINCE THEY MAY BE PRESENT IN OLD
C          INPUT FILES, WE GO AHEAD AND READ THEM HERE.
      IF(WORD2.EQ.'MXBF    ') THEN
        MXBF = IFIND('MXBF    ',IERR)
        GO TO 140
      END IF
C
      IF(WORD2.EQ.'MXMO    ') THEN
        MXMO = IFIND('MXMO    ',IERR)
        GO TO 140
      END IF
C
      IF(WORD2.EQ.'XBOX    ') THEN
        XBOX = RFIND('XBOX    ',IERR)
        XBOX = XBOX/0.52917724924D+00
        GO TO 140
      END IF
C
      IF(WORD2.EQ.'YBOX    ') THEN
        YBOX = RFIND('YBOX    ',IERR)
        YBOX = YBOX/0.52917724924D+00
        GO TO 140
      END IF
C
      IF(WORD2.EQ.'ZBOX    ') THEN
        ZBOX = RFIND('ZBOX    ',IERR)
        ZBOX = ZBOX/0.52917724924D+00
        GO TO 140
      END IF
C
      IF(WORD2.EQ.'XCUT    ') THEN
        XCUT = RFIND('XCUT    ',IERR)
        XCUT = XCUT/0.52917724924D+00
        GO TO 140
      END IF
C
      IF(WORD2.EQ.'YCUT    ') THEN
        YCUT = RFIND('YCUT    ',IERR)
        YCUT = YCUT/0.52917724924D+00
        GO TO 140
      END IF
C
      IF(WORD2.EQ.'ZCUT    ') THEN
        ZCUT = RFIND('ZCUT    ',IERR)
        ZCUT = ZCUT/0.52917724924D+00
        GO TO 140
      END IF
C
      IF(WORD2.EQ.'RCUT    ') THEN
        RCUT = RFIND('RCUT    ',IERR)
        RCUT = RCUT/0.52917724924D+00
        RCUT = RCUT*RCUT
        GO TO 140
      END IF
C
      IF(WORD2.EQ.'SWR1    ') THEN
        SWR1 = RFIND('SWR1    ',IERR)
        SWR1 = SWR1/0.52917724924D+00
        GO TO 140
      END IF
C
      IF(WORD2.EQ.'SWR2    ') THEN
        SWR2 = RFIND('SWR2    ',IERR)
        SWR2 = SWR2/0.52917724924D+00
        GO TO 140
      END IF
C
      IF(WORD2.EQ.'ISWF    ') THEN
        ISWF = IFIND('ISWF    ',IERR)
        GO TO 140
      END IF
C
      IF(WORD2.EQ.'ICENFD  ') THEN
        ICENFD=IFIND('ICENFD  ',IERR)
        GO TO 140
      END IF
C
      IF(WORD2.EQ.'RQM     ') THEN
        RQM  = RFIND('RQM     ',IERR)
        RQM  = RQM/0.52917724924D+00
        GO TO 140
      END IF
C
      IF(WORD2.EQ.'XQM     ') THEN
        XQM  = RFIND('XQM     ',IERR)
        XQM  = XQM/0.52917724924D+00
        GO TO 140
      END IF
C
      IF(WORD2.EQ.'YQM     ') THEN
        YQM  = RFIND('YQM     ',IERR)
        YQM  = YQM/0.52917724924D+00
        GO TO 140
      END IF
C
      IF(WORD2.EQ.'ZQM     ') THEN
        ZQM  = RFIND('ZQM     ',IERR)
        ZQM  = ZQM/0.52917724924D+00
        GO TO 140
      END IF
C
      IF(WORD2.EQ.'RMM     ') THEN
        RMM  = RFIND('RMM     ',IERR)
        RMM  = RMM/0.52917724924D+00
        GO TO 140
      END IF
C
      IF(WORD2.EQ.'XMM     ') THEN
        XMM  = RFIND('XMM     ',IERR)
        XMM  = XMM/0.52917724924D+00
        GO TO 140
      END IF
C
      IF(WORD2.EQ.'YMM     ') THEN
        YMM  = RFIND('YMM     ',IERR)
        YMM  = YMM/0.52917724924D+00
        GO TO 140
      END IF
C
      IF(WORD2.EQ.'ZMM     ') THEN
        ZMM  = RFIND('ZMM     ',IERR)
        ZMM  = ZMM/0.52917724924D+00
        GO TO 140
      END IF
C
C         UNDOCUMENTED KEYWORD, RELATING TO SCREENING OF POLARIZABILITY.
C         IF INDSCR=0, SCREEN ALL POLARIZATION TERMS
C         IF INDSCR=1, SCREEN ONLY INDUCED DIPOLE-INDUCED DIPOLE
C         THE FORMER IS THE DEFAULT IF A POLSCR SUBGROUP IS GIVEN.
C
      IF(WORD2.EQ.'INDSCR  ') THEN
        INDSCR = IFIND('INDSCR  ',IERR)
        GO TO 140
      END IF
C
C         UNDOCUMENTED KEYWORD, RELATING TO SCREENING OF ELECTROSTATIC &
C         POLARIZABILITY.
C         SCROFF GIVES THE CUT-OFF FOR SCREENING. THE DEFAULT IS NO
C         CUT-OFF FOR GAUSSIAN SCREENING (SCREEN1), I.E., SCROFF=1.0D+04
C         AND SCROFF=11 BOHR FOR
C         ALL ORTHER ELECTROSTATIC AND POLARIZATIONAL SCREENING TYPES.
C         MAYBE IMPORTANT TO GIVE THE VALUE OF SCROFF <= SWR1 IN MD SIMS
C
      IF(WORD2.EQ.'SCROFF  ') THEN
        SCROFF = IFIND('SCROFF  ',IERR)
        GO TO 140
      END IF
C
C         UNDOCUMENTED KEYWORD, GIVING THE
C         DISPERSION DAMPING COEFFICIENT IN TANG-TOENNOS FORMULA
      IF(WORD2.EQ.'DISPB   ') THEN
        B = RFIND('DISPB   ',IERR)
        GO TO 140
      END IF
C
C           MULTIPOLE DAMPING OPTION
C       ISCRELEC=1: USE OVERLAP-BASED ELECTROSTATIC DAMPING
C       ISCRELEC=0: USE SCREENX INPUT, IF FOUND, OR ELSE NO SCREENING
C
      IF(WORD2.EQ.'ISCRELEC' ) THEN
        ITMP = IFIND('ISCRELEC',IERR)
        IF (ITMP .EQ. 0) THEN
           IELECS = -1
C---       ICHGP  = -1
        ELSE IF (ITMP. EQ. 1) THEN
           IELECS = 1
           ICHGP  = -1
        ELSE
C    SOMETHING ELSE - PROBABLY A MISTAKE
           IF(MASWRK) WRITE(IW,*)
     *       'ERROR, INVALID PARAMETER SPECIFIED FOR ISCRELEC, ABORT'
           CALL ABRT
        END IF
        GO TO 140
      END IF
C
C       ISCRDISP=1: USE OVERLAP-BASED DISPERSION DAMPING
C       ISCRDISP=0: USE TANG-TOENNIS  DISPERSION DAMPING
C
      IF(WORD2.EQ.'ISCRDISP') THEN
        ITMP = IFIND('ISCRDISP',IERR)
        IF (ITMP.EQ.0) IDISPS = -1
        IF (ITMP.EQ.1) IDISPS = 1
        IF (ITMP.NE.1 .AND. ITMP.NE.0) THEN
           IF(MASWRK) WRITE(IW,*)
     *        'ERROR, INVALID PARAMETER SPECIFIED FOR ISCRDISP, ABORT'
           CALL ABRT
        END IF
        GO TO 140
      END IF
C
C         SCREENING OF POLARIZABILITY
C       ISCRPOL=1: USE TANG-TOENNIS-LIKE DAMPING FORMULA
C       ISCRPOL=0: USE EXPONENTIAL DAMPING IF POLSCR INPUT IS READ,
C                  OTHERWISE NO POLARIZATION DAMPING
C
      IF(WORD2.EQ.'ISCRPOL ') THEN
        ITMP = IFIND('ISCRPOL ',IERR)
        IF (ITMP .EQ. 0) THEN
           NEW_POL = -1
C---       IPLSCR = -1
        ELSE IF (ITMP .EQ. 1) THEN
           NEW_POL = 1
           IPLSCR = -1
        ELSE
C    SOMETHING ELSE - PROBABLY A MISTAKE
           IF(MASWRK) WRITE(IW,*)
     *       'ERROR, INVALID PARAMETER SPECIFIED FOR ISCRPOL, ABORT'
           CALL ABRT
        END IF
        GO TO 140
      END IF
C
      IF(WORD2.EQ.'FRAGTYP') THEN
         WORD3='        '
         LGSTR=-8
         CALL GSTRNG(WORD3,LGSTR)
         MP2TYP = -1
         IF(WORD3.EQ.'MP2NEW  ') MP2TYP=1
         IF(MP2TYP.EQ.-1) THEN
            IF(MASWRK) WRITE(6,*) '$EFRAG: ILLEGAL FRAGTYP=',WORD3
            CALL ABRT
         END IF
         GO TO 140
      END IF
C
      IF(WORD2.EQ.'NOELEC  ') THEN
         NOELEC=.TRUE.
         GO TO 140
      END IF
      IF(WORD2.EQ.'NOESCR  ') THEN
         NOESCR=.TRUE.
         GO TO 140
      END IF
      IF(WORD2.EQ.'NOPOL   ') THEN
         NOPOL =.TRUE.
         GO TO 140
      END IF
      IF(WORD2.EQ.'NOPSCR  ') THEN
         NOPSCR=.TRUE.
         GO TO 140
      END IF
      IF(WORD2.EQ.'NOEXREP ') THEN
         NOEXREP =.TRUE.
         GO TO 140
      END IF
      IF(WORD2.EQ.'NOCHTR  ') THEN
         NOCHTR=.TRUE.
         GO TO 140
      END IF
      IF(WORD2.EQ.'NODISP  ') THEN
         NODISP=.TRUE.
         GO TO 140
      END IF
C EFP-AI DISPERSION
      IF(WORD2.EQ.'QMDISP  ') THEN
        ITMP = IFIND('QMDISP  ',IERR)
        IF (ITMP.EQ.1) THEN
          IQMDISP=1
        ELSE IF (ITMP.EQ.0) THEN
          IQMDISP=0
        ELSE
           IF(MASWRK) WRITE(IW,*)
     *        'ERROR, INVALID PARAMETER SPECIFIED FOR ISCRDISP, ABORT'
           CALL ABRT
        END IF
        GO TO 140
      END IF
      IF(WORD2.EQ.'ISCRQMDS') THEN
        ITMP = IFIND('ISCRQMDS',IERR)
        IF (ITMP.EQ.1) THEN
           IDISDMP = 1
        ELSE IF (ITMP.EQ.0) THEN
           IDISDMP = 0
        ELSE
           IF(MASWRK) WRITE(IW,*)
     *        'ERROR, INVALID PARAMETER SPECIFIED FOR ISCRDISP, ABORT'
           CALL ABRT
        END IF
        GO TO 140
      END IF
      IF(WORD2.EQ.'NODSGRD ') THEN
         IDSGRD = 0
      END IF
C
C     FORCE POINTS
      IF(WORD2.EQ.'FRCPNT  ') THEN
         IFRCPNT = .TRUE.
         GO TO 140
      END IF
C
      IF(MASWRK) THEN
         WRITE(IW,*) ' '
         WRITE(IW,*) '$EFRAG: UNRECOGNIZED KEYWORD=',WORD2
         WRITE(IW,*) 'YOU MIGHT HAVE TYPED A $EFRAG OPTION INCORRECTLY,'
         WRITE(IW,*) 'THIS CAN MEAN A "BLANK" OPTION LINE WAS NOT GIVEN'
      END IF
      CALL ABRT
C
C         PROVIDE DEFAULTS IF KEYWORD WAS NOT READ
C
 145  CONTINUE
      IF(INT   .EQ.-1) INT   =0
      IF(METHPOL.EQ.-1) METHPOL=2
      IF(MOVE  .EQ.-1) MOVE  =1
      IF(NBUFMO.EQ.-1) NBUFMO=0
C
C ---- READ IN EACH FRAGMENT AND KEEP TRACK OF HOW MANY WE READ IN ----
C
      IF(IEFRAG.EQ.1) THEN
         IF(MASWRK) WRITE(IW,9020) TYPCRD(INT+1),TYPPOS(MOVE+1),
     *                             TYPPOL(METHPOL-1),NBUFMO
         NFRG=1
         NFRaG=1
         STOP = .FALSE.
  150    CONTINUE
            IF(NFRG.GT.MXFRG) THEN
               IF(MASWRK) WRITE(IW,*) 'EXCEEDED MXFRG=',MXFRG
               CALL ABRT
            END IF
            IF(INT.EQ.0) THEN
               CALL RDFRG(IUNTRD,NFRG,STOP)
            ELSE
               CALL RDFRG2(NFRG,STOP)
            END IF
            IF(STOP) GO TO 160
            NFRG = NFRG + 1
         GO TO 150
  160    CONTINUE
         IF(MASWRK) WRITE(IW,9030) NFRG
      END IF
      nfrag=nfrg
C
      IF(IPDB.EQ.1) CALL RDPDB(NFRG)
C
C  THIS ALLOWS US TO READ THE MAXIMUM BASIS FUNCTIONS (MXBF) AND THE
C  MAXIMUM MOLECULAR ORBITALS (MXMO) FROM EFP2 $FRAGNAME GROUPS.
C  WE MUST HAVE THESE VALUES IN ORDER TO DO DYNAMIC MEMORY ALLOCATION!
C  IT IS A LOT OF CARD-IMAGE READING TO LET OTHER PROCESSORS KNOW JUST
C  TWO TEENY-TINY INTEGER VALUES, SO DO IT SERIALLY.
C
C             COMPLETELY IGNORE ANYTHING GIVEN IN $EFRAG FOR THESE!
      MXBF=0
      MXMO=0
      MXCTMO=0
C
      GPSAVE = GOPARR
      GOPARR = .FALSE.
C
      IF(MASWRK) THEN
         DO 165 IDFRG=1,NDFRG
            IF(FRGNAM(NAMIDX(IDFRG)).EQ.'H2ORHF') GO TO 165
            IF(FRGNAM(NAMIDX(IDFRG)).EQ.'H2ODFT') GO TO 165
            IF(FRGNAM(NAMIDX(IDFRG)).EQ.'POL5P ') GO TO 165
            IF(FRGNAM(NAMIDX(IDFRG)).EQ.'TIP5P ') GO TO 165
            IF(FRGNAM(NAMIDX(IDFRG)).EQ.'TIP5PE') GO TO 165
            IF(FRGNAM(NAMIDX(IDFRG)).EQ.'SPC   ') GO TO 165
            IF(FRGNAM(NAMIDX(IDFRG)).EQ.'SPCE  ') GO TO 165
            CALL RDMXBF(IDFRG,MXBF,MXMO)
            CALL RDMXCTMO(IDFRG,MXCTMO)
 165  CONTINUE
      END IF
C
      GOPARR = GPSAVE
      IF(GOPARR) THEN
         CALL DDI_BCAST(350,'I',MXBF,1,MASTER)
         CALL DDI_BCAST(351,'I',MXMO,1,MASTER)
      END IF
C
C     ---- OBTAIN THE EFFECTIVE FRAGMENT POTENTIAL ----
C     THIS MAY BE READ FROM INPUT, OR INTERNALLY BUILT-IN
C
      NTMOF=NFRG*MXMO
      MXMO2=(MXMO*MXMO+MXMO)/2
c     NTAOF=NFRG*MXBF
      NTCTMOF = NFRG*MXCTMO
      CALL VALFM(LOADFM)
      LPROVEC = LOADFM  + 1
      LFOCKMA = LPROVEC + MXBF*NTMOF
      LCTVEC  = LFOCKMA + MXMO2*NFRG
      LAVLVEC = LCTVEC  + MXBF*NTCTMOF
      LTLVEC  = LAVLVEC + MXBF
      LAVCVEC = LTLVEC  + MXBF
      LTCVEC  = LAVCVEC + MXBF
      LAST    = LTCVEC  + MXBF
      NEED = LAST-LOADFM-1
      CALL GETFM(NEED)
C
C ---- WE NOW FIND THE PERTINENT INFORMATION OF EACH FRAGMENT
C
      IF(MXBF.GT.0) THEN
         CALL VCLR(XX(LPROVEC),1,MXBF*NTMOF)
         CALL VCLR(XX(LFOCKMA),1,MXMO2*NFRG)
         CALL VCLR(XX(LCTVEC),1,MXBF*NTCTMOF)
         CALL VCLR(CTFOK     ,1,MXAO*MXDFG)
      END IF
      I=1
C ---- LIST OF MULTIPOLE POINTS
      LSTMPTS(1) = 1
      LSTFPTS(1) = 1
  170 CONTINUE
      WRITE(UNIT=TEMP,FMT='(A1,A1,A6)') BLANK,DOLLAR,FRGNAM(I)
      READ(UNIT=TEMP,FMT='(A8)') FRGMNT
C
C ---- CHECK TO SEE IF FRAGMENT POTENTIAL IS INTERNALLY STORED,
C ---- OTHERWISE FIND $FRGNAM(ICNT) AND READ IN INFORMATION
C
      IF      (FRGMNT.EQ.' $H2ORHF') THEN
                CALL WATRHF(I)
      ELSE IF (FRGMNT.EQ.' $H2ODFT') THEN
                CALL WATDFT(I)
C-DEAD-LSE IF (FRGMNT.EQ.' $H2OSPC') THEN
C-DEAD-         CALL SPCEWA(I)
      ELSE IF (FRGMNT.EQ.' $POL5P ') THEN
                CALL POL5P(I)
      ELSE IF (FRGMNT.EQ.' $TIP5P ') THEN
                CALL TIP5P(I,0)
      ELSE IF (FRGMNT.EQ.' $TIP5PE') THEN
                CALL TIP5P(I,1)
      ELSE IF (FRGMNT.EQ.' $SPC   ') THEN
                CALL SPC(I,0)
      ELSE IF (FRGMNT.EQ.' $SPCE  ') THEN
                CALL SPC(I,1)
      ELSE
         IF (MASWRK) WRITE(IW,9050) I,FRGMNT
         CALL RDSTFR(FRGMNT,I,XX(LPROVEC),XX(LFOCKMA),XX(LCTVEC),
     *               MXBF,NTCTMOF,MXMO,MXMO2,NTMOF)
      END IF
C
C        TRANSLATE/ROTATE THE FRAGMENT JUST READ TO ITS ACTUAL POSITION,
C        UPDATING ALL TERMS IN THE POTENTIAL FOR ITS TRUE ORIENTATION.
C        NOTE THAT THE FLEXIBLE FRAGMENT CHANGES INCLUDED SETTING THE
C        NUMBER OF ATOMS IN A FROZEN GEOMETRY EFP TO 3...EVEN IF THAT'S
C        NOT CORRECT!
C
      IF(KATMS(I).EQ.3) THEN
         CALL FRGROT(FRGMNT,I,XX(LPROVEC),XX(LCTVEC),MXBF,NTMOF,
     *               NTCTMOF)
      ELSE
         NBOPTS = 0
         DO KK=1,NMPTS(I)
            IF(MNAME(KK)(1:2).EQ.'BO'.AND.FPNUC(KK).EQ.0.0D+00) THEN
               NBOPTS=NBOPTS+1
            END IF
         END DO
         NLPTS = 0
         DO KK=1,NMPTS(I)
            IF(MNAME(KK)(1:1).EQ.'L'.AND.FPNUC(KK).EQ.0.0D+00.AND.
     *      (ACHG(1,KK).EQ.-2.0D+00.OR.ACHG(1,KK).EQ.-1.0D+00))THEN
               NLPTS=NLPTS+1
            END IF
         END DO
C        - BO** AND L00** CAN NOT BE IN THE SAME FRAGMENT
         IF(NBOPTS.GT.0 .AND. NLPTS.GT.0) THEN
            IF(MASWRK) WRITE(IW,*)
     *          'ERROR: USE EITHER BO** OR L00** POINTS'
            CALL ABRT
         END IF
         CALL FLEXIP(I,XX(LPROVEC),XX(LCTVEC),
     *               MXBF,NTMOF,NTCTMOF,XX(LAVLVEC),XX(LTLVEC),
     *               XX(LAVCVEC),XX(LTCVEC),NBOPTS,NLPTS)
      END IF
C
C        NOTE THAT THE RUNNING TOTALS MUST BE UPDATED AFTER ORIENTATION.
C
      NMTTPT = NMTTPT + NMPTS(I)
      NPTTPT = NPTTPT + NPPTS(I)
      NDPTTPT= NDPTTPT+ NDPPTS(I)
      NLJTTPT= NLJTTPT+ NLJPTS(I)
      NRTTPT = NRTTPT + NRPTS(I)
      NDTTPT = NDTTPT + NDPTS(I)
      NTPATM = NTPATM + NAT(ISET(I))
      NTMO   = NTMO   + NORB(I)
      NTAO   = NTAO   + NAO(ISET(I))
      NTCTMO = NTCTMO + NCTMO(ISET(I))
      NTFRCPN=NTFRCPN + NFRCPNT(I)
C
      LSTMPTS(I+1) = LSTMPTS(I)+NMPTS(I)
      LSTFPTS(I+1) = LSTFPTS(I)+NFRCPNT(I)
C
C        THE NEXT TEST IS ACTUALLY A LITTLE BIT TOO LATE, AS CREATING
C        AND STORING THE LAST FRAGMENT IN THE CALLS ABOVE WOULD HAVE
C        ALREADY GONE BEYOND THE ARRAY BOUNDS.
C        THIS IS CERTAINLY A GOOD PLACE TO QUIT, IF THAT HAS HAPPENED!
C
      NPMAX = MAX(NMTTPT,NPTTPT,NRTTPT,NDTTPT,NTFRCPN,NLJTTPT)
      IF(NPMAX.GT.MXFGPT) THEN
         IF(MASWRK) WRITE(IW,9200) I,NFRG,NMTTPT,NPTTPT,NDPTTPT,
     *                     NRTTPT,NDTTPT,NTFRCPN,NLJTTPT,MXFGPT
         CALL ABRT
      END IF
      I = I + 1
      IF(I.GT.NFRG) GO TO 200
      GO TO 170
C
  200 CONTINUE
C
C ---- WRITE PROVEC & FOCKMA
C
      LENPV=MXBF*NTMO
      LENFM=MXMO2*NFRG
      CALL DAWRIT(IDAF,IODA,XX(LPROVEC),LENPV,267,0)
      CALL DAWRIT(IDAF,IODA,XX(LFOCKMA),LENFM,268,0)
      LENCV=MXBF*NTCTMO
      CALL DAWRIT(IDAF,IODA,XX(LCTVEC),LENCV,269,0)
      CALL RETFM(NEED)
C
      EFP1MODEL = NRTTPT+NDTTPT           .GT.0 .AND. NLJTTPT.EQ.0
      EFP2MODEL = NTPATM+NTMO+NDPTTPT+NTCTMO.GT.0
C
C            SWITCH OFF ANY TERMS THE USER DOESN'T WANT.
C        THE -FFELEC- ROUTINE DOESN'T PAY ATTENTION TO THE OLD
C        ELECTROSTATIC VARIABLES, SO -NOELEC- DOESN'T WORK.
C
      call efp_turn_terms_off( noelec, noescr, nopol, nopscr, noexrep,
     *     nochtr, nodisp )
C
C     SET UP DEFAULT EFP DAMPINGS
C
      IF (EFP2MODEL) THEN
         IF(IPLSCR.NE. 1) IPLSCR=0
         IF(IELECS.NE. 1) IELECS=0
         IF(IDISPS.NE. -1) THEN
              IDISPS=1
         ELSE
              IDISPS=0
         END IF
C   EXPONENTIAL POLARIZATION DAMPING IS ALLOWED ONLY WITH
C   EXPONENTIAL ELECTROSTATIC DAMPING
         IF (IELECS .EQ. 1) IPLSCR = 0
         IF (NEW_POL .NE. -1 .AND. IPLSCR .NE. 1) THEN
              NEW_POL=1
         ELSE
              NEW_POL=0
         END IF
C---     IF (ICHGP .EQ.-1) ICHGP = 0
         IF (IELECS.EQ.1) ICHGP = MOD(ICHGP,2)
      END IF
C
C          ALLOW POLARIZATION SCREENING INPUT TO CONTROL THIS,
C          THE DEFAULT STILL REMAINS OFF (0).
      IF (EFP1MODEL) THEN
         IPLSCR=0
         IELECS=0
         IDISPS=0
C---     NEW_POL=0
      END IF
C
      IF (MASWRK) THEN
         WRITE(IW,9090)
         WRITE(IW,9100) NMTTPT
         WRITE(IW,9105) NPTTPT
         WRITE(IW,9106) NLJTTPT
         IF(EFP1MODEL) THEN
            IF(MP2TYP.EQ.1) WRITE(IW,9110) NDTTPT
            WRITE(IW,9115) NRTTPT
            WRITE(IW,9140)
         END IF
         IF(EFP2MODEL) THEN
            WRITE(IW,9120) NTPATM
            WRITE(IW,9125) NTMO
            WRITE(IW,9130) NDPTTPT
C            WRITE(IW,9135) NTAO
            WRITE(IW,9135) NTCTMO
            WRITE(IW,9145) NTPATM.GT.0, NDPTTPT.GT.0, NTCTMO.GT.0
         END IF
         IF(IFRCPNT) WRITE(IW,9147) NTFRCPN
      END IF
C
      ICPEA = MOD(ICHGP,2)
      ICPEE = ICHGP/2
      IF(MASWRK) THEN
         WRITE(IW,9150)
         IF(NATINF.GT.0) THEN
            IF(ICPEA.EQ.0) WRITE(IW,9155) 'OFF'
            IF(ICPEA.EQ.1) WRITE(IW,9155) 'ON'
         END IF
         IF(ICPEE.EQ.0 .AND. IELECS.EQ.0) WRITE(IW,9160)
     *                                   'NO ELECTROSTATIC SCREENING'
         IF(ICPEE.EQ.1) WRITE(IW,9160) 'GAUSSIAN, FOR CHARGE/CHARGE'
         IF(ICPEE.EQ.2) WRITE(IW,9160) 'EXPONENTIAL, FOR CHARGE/CHARGE'
         IF(ICPEE.EQ.3) WRITE(IW,9160) 'EXPONENTIAL, TO HIGHER ORDER'
         IF(ICPEE.EQ.4) WRITE(IW,9160) 'MODEL 1, FOR CHARGE/CHARGE'
         IF(ICPEE.EQ.5) WRITE(IW,9160) 'MODEL 1, TO HIGHER ORDER'
         IF(IELECS.EQ.1) WRITE(IW,9160) 'USING OVERLAP'
         IF(IPLSCR.EQ.0 .AND. NEW_POL.EQ.0) WRITE(IW,9170) 'OFF'
         IF(IPLSCR.EQ.1) WRITE(IW,9170) 'EXPONENTIAL'
         IF(NEW_POL.EQ.1) WRITE(IW,9170) 'TANG-TOENNIS LIKE'
         IF(IDISPS.EQ.1) THEN
            WRITE(IW,9165) 'USING OVERLAP'
         ELSE
            IF(EFP2MODEL) THEN
            WRITE(IW,9165) 'USING TANG-TOENNIS FORMULA'
            WRITE(IW,9166) B
            END IF
         END IF
      END IF
C
      IF(EFP1MODEL .AND. EFP2MODEL) THEN
         IF(MASWRK) WRITE(IW,9175)
         CALL ABRT
      END IF
C
C   ---- CHECK FOR PBC-RELATED KEYWORDS
C
      NERRPBC=0
      IF (XBOX.LT.ZERO .OR. YBOX.LT.ZERO .OR. ZBOX.LT.ZERO) THEN
         IF(MASWRK) WRITE(IW,9350) XBOX,YBOX,ZBOX
         NERRPBC=NERRPBC+1
      END IF
C
      IF(XBOX+YBOX+ZBOX.LT.1.0D-05) THEN
         IF(SWR1.LT.1.0D+10 .OR. SWR2.LT.1.0D+10 .OR. RCUT.LT.1.0D+10
     *          .OR. XCUT.LT.1.0D+10 .OR. YCUT.LT.1.0D+10
     *          .OR. ZCUT.LT.1.0D+10) THEN
            IF(MASWRK) WRITE(IW,9355)
            NERRPBC=NERRPBC+1
         ENDIF
      ENDIF
C
      IPBC = 0
      IF (XBOX.GT.ZERO .AND. YBOX.GT.ZERO .AND. ZBOX.GT.ZERO) IPBC=1
C
      IF (IPBC.EQ.1) THEN
         IF (SWR1 .GT. SWR2) THEN
            IF(MASWRK) WRITE(IW,9360) SWR1,SWR2
            NERRPBC=NERRPBC+1
         END IF
         IF ((SWR2.GT.XBOX .OR. SWR2.GT.YBOX .OR. SWR2.GT.ZBOX) .AND.
     *       (XCUT.GT.XBOX .OR. YCUT.GT.YBOX .OR. ZCUT.GT.ZBOX)) THEN
            IF(MASWRK) WRITE(IW,9370)
            NERRPBC=NERRPBC+1
         END IF
      END IF
      IF(NERRPBC.GT.0) CALL ABRT
C
      IF(MASWRK) THEN
         IF (IPBC.EQ.1) THEN
            BRANG = 0.52917724924D+00
            WRITE(IW, 9380)
            WRITE(IW,9381) XBOX*BRANG,YBOX*BRANG,ZBOX*BRANG
            IF (XCUT.LE.XBOX .AND. YCUT.LE.YBOX.AND.ZCUT.LE.ZBOX)THEN
               WRITE(IW,9382) XCUT*BRANG,YCUT*BRANG,ZCUT*BRANG
            END IF
            IF (SWR2.LE.XBOX .AND. SWR2.LE.YBOX.AND.SWR2.LE.ZBOX)THEN
               WRITE(IW,9383) SWR1*BRANG,SWR2*BRANG
            END IF
         END IF
      END IF
C
C     IF(IPBC.EQ.1  .AND.  NATINF.GT.0) THEN
C        IF(MASWRK) WRITE(IW,9390)
C        CALL ABRT
C     END IF
C
C   ---- READ $EWALD GROUP IF ANY
C
      CALL EWALDX
C
C         PARALLEL EXECUTION OF EFP2 IS NOT ENABLED AT THIS TIME
C
      IF(GOPARR  .AND.  NTMO.GT.0  .AND.  NATINF.GT.0) THEN
         IF(MASWRK) WRITE(IW,*)
     *       'ERROR, AI/EFP2 COMPUTATIONS CANNOT RUN IN PARALLEL YET.'
         CALL ABRT
      END IF
C
      CALL DERCHK(NDER)
      IF(NATINF.GT.0  .AND.  NTMO.GT.0  .AND.  NDER.GT.0) THEN
         IF(MASWRK) WRITE(IW,9180)
         CALL ABRT
      END IF
C
      IF (ICYC.GT.0) GO TO 800
C
C ---- READ FRAGMENT REPULSION CONSTANTS
C
      MXRPTS=0
      DO 400 IFRG=1,NFRG
         MXRPTS = MAX(NRPTS(IFRG),MXRPTS)
  400 CONTINUE
      MXRPTS=MXRPTS+1
      NDFRG2 = (NDFRG*NDFRG+NDFRG)/2
      LEN = MXRPTS*MXRPTS*NDFRG2
      CALL VALFM(LOADFM)
      LAREL = LOADFM + 1
      LCREL = LAREL  + LEN
      LAST  = LCREL  + LEN
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
C        READ THE INTER-FRAGMENT REPULSIVE POTENTIAL GROUP $FRGRPL.
C        IF ONLY THE INTERNALLY STORED H2ORHF IS BEING USED, SKIP.
C
      IF (NOEXREP)   GO TO 500
      IF (NTMO.GT.0) GO TO 500
      IF (ILJP.EQ.1) GO TO 500
C
      BILTIN = FRGMNT.EQ.' $H2ORHF' .OR. FRGMNT.EQ.' $H2ODFT'
      IF (NFRG.GT.1 .AND. .NOT.BILTIN) THEN
         CALL RDFGRP(XX(LAREL),XX(LCREL),MXRPTS,NDFRG2)
         CALL DAWRIT(IDAF,IODA,XX(LAREL),2*LEN,75,0)
      ELSE IF (NFRG.GT.1) THEN
         CALL DAREAD(IDAF,IODA,XX(LAREL),2*LEN,75,0)
      END IF
C
C ---- PRINT OUT INFORMATION FOR FRAGMENT
C
  500 CONTINUE
      CALL PRTFRG(XX(LAREL),XX(LCREL),MXRPTS,NDFRG2)
      CALL RETFM(NEED)
C
      IF(MP2TYP.EQ.1) THEN
C ---- READ FRAGMENT DISPERSION CONSTANTS
C
        MXDPTS=0
        DO 550 IFRG=1,NFRG
C         ATTENTION!!!!
C         TEMPORARILY NDPTS IS EQUAL TO NRPTS
C         ATTENTION!!!!
C         NDPTS(IFRG)=NRPTS(IFRG)
          MXDPTS = MAX(NDPTS(IFRG),MXDPTS)
  550   CONTINUE
        MXDPTS=MXDPTS+1
        NDFRG2 = (NDFRG*NDFRG+NDFRG)/2
        LEN = MXDPTS*MXDPTS*NDFRG2
C       **************************
C       C6 ONLY OR C6 AND C8
C       LC6=1
C       LC8=1
C       **************************
        CALL VALFM(LOADFM)
        LAREL = LOADFM + 1
        LDREL = LAREL  + LEN
        LCREL = LDREL  + LEN
C       ******************************
C       NEEDS FUTURE MODIFICATION TO
C       IDENTIFY C6 ONLY OR  LC6=1
C       C6 AND C8.           LC8=1
C       ******************************
        LAST  = LCREL  + LEN
        LBREL = LAST   + LEN
        LEREL = LBREL  + LEN
        LAST1 = LEREL  + LEN
C       ******************************
C       FOR C6 ONLY
C       IF(LC6.EQ.1)  NEED  = LAST  - LOADFM - 1
C       ******************************
C       FOR C6 AND C8
C       IF(LC8.EQ.1)  NEED  = LAST1 - LOADFM - 1
        NEED  = LAST1 - LOADFM - 1
        CALL GETFM(NEED)
C
C     READ THE INTER-FRAGMENT DISPERSION GROUP $FRGDPS.
C
C     ATTENTION: THE DATA ARE WRITTEN INTO FILE 81!!!
C
        IF (NTMO.GT.0) GO TO 600
C
        BILTIN = FRGMNT.EQ.' $H2ORHF' .OR. FRGMNT.EQ.' $H2ODFT'
C
C       0: FOR C6 TERM
C       1: FOR C8 TERM
C
        IF (NFRG.GT.1 .AND. .NOT.BILTIN) THEN
          CALL RDFGDP(XX(LAREL),XX(LDREL),XX(LCREL),MXDPTS,NDFRG2,0)
          CALL RDFGDP(XX(LAST), XX(LBREL),XX(LEREL),MXDPTS,NDFRG2,1)
          CALL DAWRIT(IDAF,IODA,XX(LAREL),6*LEN,81,0)
        ELSE IF (NFRG.GT.1) THEN
          CALL DAREAD(IDAF,IODA,XX(LAREL),6*LEN,81,0)
        END IF
  600   CONTINUE
C
C       0: FOR C6 TERM
C       1: FOR C8 TERM
        CALL PRTFRG1(XX(LAREL),XX(LDREL),XX(LCREL),MXDPTS,NDFRG2,0)
        CALL PRTFRG1(XX(LAST), XX(LBREL),XX(LEREL),MXDPTS,NDFRG2,1)
        CALL RETFM(NEED)
C
      END IF
C
C ---- OPEN FILE 25 IF WE HAVE POLARIZABLE POINTS
C
      IF(IEFP.EQ.1) THEN
             DSKSAV = DSKWRK
             DSKWRK = .TRUE.
             CALL SEQOPN(25,'EFPIND','UNKNOWN',.FALSE.,'UNFORMATTED')
             DSKWRK = DSKSAV
      ENDIF
C
  800 CONTINUE
      ICYC=ICYC+1
      RETURN
C
 9020 FORMAT(/1X,'READING $EFRAG GROUP'/
     *        1X,'COORD=',A8,'  POSITION=',A8,'  POLMETHD=',A8,
     *           ' NBUFFMO=',I1)
 9030 FORMAT(1X,'FINISHED READING $EFRAG GROUP,',
     *       1X,I3,1X,'FRAGMENTS WILL BE USED.'/)
 9050 FORMAT(1X,'READING POTENTIAL PARAMETERS FOR FRAGMENT',I5,
     *          ' FROM GROUP',A8)
C
 9090 FORMAT(//5X,'SUMMARY OF THE EFFECTIVE FRAGMENT POTENTIAL',
     *            ' MODEL CHOSEN'/5X,56(1H-))
 9100 FORMAT(1X,'TOTAL NUMBER OF MULTIPOLE POINTS   =',I10,
     *          '  (EFP1/EFP2 ELECTROSTATICS)')
 9105 FORMAT(1X,'TOTAL NUMBER OF POLARIZABLE POINTS =',I10,
     *          '  (EFP1/EFP2 INDUCTION)')
 9106 FORMAT(1X,'TOTAL NUMBER OF L-J POINTS         =',I10,
     *          '  (REPULSION AND DISPERSION)')
 9110 FORMAT(1X,'TOTAL NUMBER OF DISPERSION POINTS  =',I10,
     *          '  (EFP1/MP2 DISPERSION)')
 9115 FORMAT(1X,'TOTAL NUMBER OF REPULSIVE POINTS   =',I10,
     *          '  (EFP1 REPULSION/ETC.)')
 9120 FORMAT(1X,'TOTAL NUMBER OF AO CENTERS         =',I10,
     *          '  (EFP2 PAULI REPULSION)')
 9125 FORMAT(1X,'TOTAL NUMBER OF EFP MOS            =',I10,
     *          '  (EFP2 PAULI REPULSION)')
 9130 FORMAT(1X,'TOTAL NO OF DYNAMIC POLARIZABLE PTS=',I10,
     *          '  (EFP2 DISPERSION)')
 9135 FORMAT(1X,'TOTAL NUMBER OF EFP MOS            =',I10,
     *          '  (EFP2 CHARGE TRANSFER)')
 9140 FORMAT(/1X,'THIS IS A -EFP1- TYPE RUN, WITH PAULI REPULSION,',
     *          ' CHARGE TRANSFER, AND'/
     *       1X,'HIGHER ORDER EFFECTS COLLECTED IN A FITTED',
     *          ' REPULSIVE POTENTIAL.')
 9145 FORMAT(/1X,'THIS IS A -EFP2- TYPE RUN, INCLUDING SEPARATE',
     *          ' FORMULAE FOR'/
     *       1X,'  PAULI REPULSION=',L1,'  DISPERSION=',L1,
     *          '  CHARGE TRANSFER=',L1)
C
 9147 FORMAT(1X,'TOTAL NUMBER OF POINTS TO GATHER FORCES=',I10)
 9150 FORMAT(/1X,'OPTIONS FOR EFP SCREENING:')
 9155 FORMAT(5X,'ELECTROSTATIC AB INITIO-EFP GAUSSIAN SCREENING IS ',A)
 9160 FORMAT(5X,'ELECTROSTATIC EFP-EFP SCREENING CHOICE IS ',A)
 9165 FORMAT(5X,'DISPERSION EFP-EFP SCREENING CHOICE IS ',A)
 9166 FORMAT(5X,'WITH DAMPING COEFFICIENT ',F6.2)
 9170 FORMAT(5X,'POLARIZATION EFP-EFP SCREENING IS ',A)
C
 9175 FORMAT(1X,'YOU HAVE SELECTED BOTH EFP1 AND EFP2 POTENTIALS.'/
     *       1X,'THIS IS NOT SENSIBLE, PLEASE FIX YOUR POTENTIALS')
 9180 FORMAT(//1X,'*** ERROR ***'/
     *   1X,'THIS RUN WITH AB INITIO ATOMS REQUESTING A GRADIENT'/
     *   1X,'CURRENTLY WORKS ONLY WITH THE FITTED REPULSIVE POTENTIAL')
 9200 FORMAT(1X,'ONE OF THE EFP DIMENSIONS HAS JUST EXCEEDED MXGFPT.'/
     *       1X,'WHILE SETTING UP EFP NO.',I6,' OF',I6,' TOTAL EFPS.'/
     *       1X,'TOTAL EXPANSION POINTS OF EACH TYPE (SO FAR) ARE:'/
     *       1X,'          MULTIPOLE POINTS=',I8/
     *       1X,'     POLARIZABILITY POINTS=',I8/
     *       1X,'DYN. POLARIZABILITY POINTS=',I8/
     *       1X,'   FITTED REPULSIVE POINTS=',I8/
     *       1X,'         DISPERSION POINTS=',I8/
     *       1X,'              FORCE POINTS=',I8/
     *       1X,'      LENNARD-JONES POINTS=',I8/
     *       1X,'   BUT PARAMETER MXFGPT WAS',I8,' AT COMPILE TIME')
 9210 FORMAT(1X,'QM/EFP INTEGRALS ARE PROGRAMMED FOR SPDF AO''S ONLY'/
     *       1X,'PLEASE CHANGE YOUR AB INITIO BASIS SET.')
C
 9350 FORMAT(/5X,'PBC BOX SIZE = ',3F14.6,' ANGSTROMS, ERROR',/)
 9355 FORMAT(1X,'XBOX,YBOX,ZBOX ARE REQUIRED INPUTS IF YOU PICK ANY OF'/
     *       1X,'THE DISTANCE CUTOFFS (SWX OR RCUT OR XCUT)')
 9360 FORMAT(/5X,'SWITCHING FUNCTIONS = ',2F14.6,' ANGSTROMS, ERROR',/)
 9370 FORMAT(/5X,'SWR2 AND XCUT,YCUT,ZCUT SHOULD NOT EXCEED BOX SIZE,',
     *       1X,'ERROR',/)
 9380 FORMAT(/5X,'PERIODIC BOUNDARY CONDITIONS WILL BE APPLIED')
 9381 FORMAT(5X,'BOX SIZE IS = ',3F10.4,' ANGSTROMS')
 9382 FORMAT(5X,'CUT-OFF WILL BE USED AT ',3F10.4,' ANGSTROMS')
 9383 FORMAT(5X,'SWITCHING FUNCTIONS WILL BE APPLIED BETWEEN ',F10.4,
     *          ' AND ',F10.4,' ANG.')
C9390 FORMAT(1X,'PERIODIC BOUNDARY CONDITIONS CAN ONLY BE USED IN',
C    *          ' A SIMULATION'/
C    *       1X,'INVOLVING -EFP- PARTICLES ONLY: COORD=FRAGONLY')
C
      END
C
C*MODULE EFINP   *DECK PRTFRG1
      SUBROUTINE PRTFRG1(AREL,DREL,CREL,MXRPTS,NDFG2,LC)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      DIMENSION AREL(MXRPTS,MXRPTS,NDFG2),CREL(MXRPTS,MXRPTS,NDFG2)
      DIMENSION DREL(MXRPTS,MXRPTS,NDFG2)
C
      PARAMETER (MXDFG=5, MXPT=2000, MXFRG=1050, MXFGPT=12000)
C
      LOGICAL GOPARR,MASWRK,DSKWRK
C
      CHARACTER*6 FRGNAM
      CHARACTER*8 KNAME,LNAME,PTNAM,DNAME,DPSNAM
C
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
C
      COMMON /POL2  / DCORD(3,MXPT),CDIS(3,MXFGPT),
     *                CLPD(4*MXFGPT),ZLPD(4*MXFGPT),
     *                NLPD(4*MXFGPT),KFD(MXFGPT),KLD(MXFGPT),
     *                DNAME(MXPT),DPSNAM(MXFGPT)
C
C     ----- WRITE INFORMATION ON DISPERSION -----
C
      IF (.NOT.MASWRK) RETURN
C
      IJ=0
      WRITE(IW,9230) NDFRG,NDFG2
      NSHFTI=0
      DO 780 I=1,NDFRG
         NSHFTJ=0
         DO 770 J=1,I
            IJ=IJ+1
            IF(LC.EQ.0) THEN
              WRITE(IW,9240) FRGNAM(NAMIDX(I)),FRGNAM(NAMIDX(J))
            ELSE IF (LC.EQ.1) THEN
              WRITE(IW,9241) FRGNAM(NAMIDX(I)),FRGNAM(NAMIDX(J))
            END IF
            KMAXR = NDPTS(NAMIDX(I))+1
            LMAXR = NDPTS(NAMIDX(J))+1
            DO 760 K=1,KMAXR
               IF(K.EQ.KMAXR) THEN
                  KNAME = 'CENTER  '
               ELSE
                  KNAME = DPSNAM(NSHFTI+K)
               END IF
               DO 750 L=1,LMAXR
                  IF(L.EQ.LMAXR) THEN
                     LNAME = 'CENTER  '
                  ELSE
                     LNAME = DPSNAM(NSHFTJ+L)
                  END IF
                  WRITE(IW,9250) KNAME,LNAME,CREL(K,L,IJ),DREL(K,L,IJ),
     *                           AREL(K,L,IJ)
  750          CONTINUE
  760       CONTINUE
            NSHFTJ=NSHFTJ+NDPTS(J)
  770    CONTINUE
         NSHFTI=NSHFTI+NDPTS(I)
  780 CONTINUE
C
      RETURN
C
 9230 FORMAT(/1X,'THERE ARE',I4,' FRAGMENT TYPES, AND',I4,
     *            ' FRAGMENT-FRAGMENT INTERACTIONS.')
 9240 FORMAT(/1X,'DISPERSION FIT FOR FRAGMENT PAIR ',A6,'-',A6,
     *           ' (C6,COEF,EXPONENT)')
 9241 FORMAT(/1X,'DISPERSION FIT FOR FRAGMENT PAIR ',A6,'-',A6,
     *           ' (C8,COEF,EXPONENT)')
 9250 FORMAT(1X,A8,'-',A8,3X,F18.8,2X,F18.8,2X,F18.8)
      END
C
C*MODULE EFINP   *DECK FRGROT
      SUBROUTINE FRGROT(FRGMNT,N,PROVEC,CTVEC,MXBF,NTMOF,NTCTMOF)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      LOGICAL GOPARR,MASWRK,DSKWRK
C
      PARAMETER (MXDFG=5, MXPT=2000, MXFRG=1050, MXFGPT=12000,
     *           MXAO=8192, MXSHEF=1000, MXGEFP=4000, MXIFRQ=12,
     *           MXDPPT=MXFRG*MXDFG*12)
C
      PARAMETER (CONST=2.0D+00/1.7320508D+00)
      PARAMETER (SQRT3=1.732050808D+00,SQRT5=2.236067978D+00)
      PARAMETER (SQRT7=2.645751311D+00)
      PARAMETER (TWO=2.0D+00,THREE=3.0D+00,FOUR=4.0D+00,SIX=6.0D+00)
      PARAMETER (TWELVE=12.0D+00)
C
      LOGICAL DOMONO,DODIPO,DOQUAD,DOOCTU
      LOGICAL DOMTMP,DODTMP,DOQTMP,DOOTMP
      LOGICAL IFRCPNT
C
      CHARACTER*8 MNAME,PNAME,DPNAME,PTNAM,FRGNME,POLNAM,DPOLNAM,RNAME,
     *            REPNAM,DNAME,DPSNAM,FRGMNT,FRCNME,FNAME,LJNAME,ELJNAM
      CHARACTER*6 FRGNAM
C
      DIMENSION T1(3,3), T2(3,3), T3(3,3), T3T(3,3), IPT(3)
      DIMENSION TEMP(3,MXPT), TEMP2(6), TEMP3(3), TEMP4(6,3)
      DIMENSION TEMP5(6,3)
      DIMENSION TPXX(6),TPXY(6),TPYY(6),TPXZ(6),TPYZ(6),TPZZ(6)
      DIMENSION TPXX2(6),TPXY2(6),TPYY2(6),TPXZ2(6),TPYZ2(6),TPZZ2(6)
      DIMENSION DTEMP(3,MXIFRQ*MXPT)
C
      COMMON /DOMULT/ DOMONO(MXFGPT),DODIPO(MXFGPT),DOQUAD(MXFGPT),
     *                DOOCTU(MXFGPT)
      COMMON /DOTMP / DOMTMP(MXPT),DODTMP(MXPT),DOQTMP(MXPT),
     *                DOOTMP(MXPT)
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NAT(MXDFG),NUM(MXDFG),NTPATM
      COMMON /EFPCT / NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CTFOK(MXAO,MXDFG),NCTMO(MXDFG),NTCTMO
      COMMON /EFPFRC/ IFRCPNT,NTFRCPN,NFRCPNT(MXFRG),LSTFPTS(MXFRG),
     *                FRCCRD(3,MXFGPT),FRCNME(MXFGPT),FRCTRQ(6,MXFGPT)
     *                ,FRCTRQX(6,MXFGPT)
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ*MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGLJP/ CORDLJ(3,MXPT),ELJCRD(3,MXFGPT),
     *                POTLJ(2,MXPT),ELJPOT(2,MXFGPT),
     *                LJNAME(MXPT),ELJNAM(MXFGPT),
     *                NLJPTS(MXFRG),NLJTTPT,ILJP,NMLJ(2)
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ*MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /REPPAR/ CREP(3,MXFGPT),CLPR(4*MXFGPT),ZLPR(4*MXFGPT),
     *                NLPR(4*MXFGPT),KFR(MXFGPT),KLR(MXFGPT),
     *                REPNAM(MXFGPT)
C
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
C
      COMMON /POL2  / DCORD(3,MXPT),CDIS(3,MXFGPT),
     *                CLPD(4*MXFGPT),ZLPD(4*MXFGPT),
     *                NLPD(4*MXFGPT),KFD(MXFGPT),KLD(MXFGPT),
     *                DNAME(MXPT),DPSNAM(MXFGPT)
C   ---- LVS: TMP COMMON FOR POLARIZATION SCREENING
      COMMON /PLSCR / IIPLSCR,IINDSCR
C
      SAVE JDXSV
      DATA JDXSV/0/
C
      DIMENSION PROVEC(MXBF,NTMOF),CTVEC(MXBF,NTCTMOF)
C
      SAVE IDXSV
      DATA IDXSV/0/
C
      IF (N.EQ.1) THEN
        IDXSV = 0
        JDXSV = 0
      ENDIF
C
      NPTS = NMPTS(N)
C
C --- FIND ROTATION MATRIX CONNECTING THE FRAGMENT N TO THE
C     STANDARD FRAGMENT.
C   1.  FIND LOCAL COORD SYSTEM FOR FRAGMENT N
C
      CALL ROTMAT(XCRD(1,N),YCRD(1,N),ZCRD(1,N),
     *            XCRD(2,N),YCRD(2,N),ZCRD(2,N),
     *            XCRD(3,N),YCRD(3,N),ZCRD(3,N),T1)
C
C   2. FIND THE CORRESPONDING THREE PTS IN THE STANDARD FRAGMENT
C
      DO 100 J=1,3
        IPT(J) = 0
        DO 50 I=1,NPTS
          IF(PTNAM(J,N).EQ.MNAME(I))IPT(J)=I
   50   CONTINUE
        IF(IPT(J).EQ.0) THEN
           IF(MASWRK) WRITE(IW,9000) PTNAM(J,N),FRGMNT
           CALL ABRT
        END IF
  100 CONTINUE
C
C   3. FIND LOCAL COORD SYSTEM FOR THESE THREE POINTS
C
      CALL ROTMAT(CORD(1,IPT(1)),CORD(2,IPT(1)),CORD(3,IPT(1)),
     *            CORD(1,IPT(2)),CORD(2,IPT(2)),CORD(3,IPT(2)),
     *            CORD(1,IPT(3)),CORD(2,IPT(3)),CORD(3,IPT(3)),T2)
C
C   4. FIND ROTATION MATRIX CONNECTING THESE TWO COORDINATE SYSTEMS
C
      CALL TRPOSE(T2,T3T,3,3,1)
      CALL MRARBR(T1,3,3,3,T2,3,3,T3,3)
C
C     WRITE(6,*) 'GRAND ROTATION MATRIX'
C     DO 300 I=1,3
C       WRITE(6,FMT='(3F9.5)') (T3(I,J), J=1,3)
C 300 CONTINUE
C     CALL PRSQ(T3,3,3,3)
C
C---- THIS IS TO CALCULATE FRAGMENT ORIENTATION IN EULER ANGLES
C---- NEEDED IN Q-CHEM INPUT, PLEASE DO NOT DISCARD
C      BTOA=0.52917724924D+00
C      DX= XCRD(1,N)-CORD(1,IPT(1))*T3(1,1)-CORD(2,IPT(1))*T3(1,2)
C     *     -CORD(3,IPT(1))*T3(1,3)
C      DY= YCRD(1,N)-CORD(1,IPT(1))*T3(2,1)-CORD(2,IPT(1))*T3(2,2)
C     *     -CORD(3,IPT(1))*T3(2,3)
C      DZ= ZCRD(1,N)-CORD(1,IPT(1))*T3(3,1)-CORD(2,IPT(1))*T3(3,2)
C     *     -CORD(3,IPT(1))*T3(3,3)
C
C      CALL MAT_TO_EULER(T3,ALPHA,BETA, GAMMA)
C      WRITE(IW,122) DX*BTOA,DY*BTOA,DZ*BTOA,ALPHA,BETA,GAMMA
C  122 FORMAT(1X,'WATER  ',6F14.8)
C
C----
C
C  COMPUTE TRANSPOSE
C
      CALL TRPOSE(T3,T3T,3,3,0)
C
C   5.  ROTATE AND TRANSLATE STANDARD FRAGMENT TO COINCIDE WITH FRAG N
C
      DO 505 I=1,NPTS
        DO 504 J=1,3
          TEMP(J,I) = CORD(J,I) - CORD(J,IPT(1))
  504   CONTINUE
  505 CONTINUE
C
      CALL MRARBR(T3,3,3,3,TEMP,3,NPTS,EFC(1,NMTTPT+1),3)
C
C  FEED IN INFORMATION INTO FINAL ARRAYS AFTER ROTATION
C
C     WRITE(6,*) 'ROTATED COORDINATES'
C
      IF (FRGMNT.EQ.' $H2OSPC') THEN
        DO 549 I = 1,NPTS
          EFC(1,NMTTPT+I) = EFC(1,NMTTPT+I) + XCRD(1,N)
          EFC(2,NMTTPT+I) = EFC(2,NMTTPT+I) + YCRD(1,N)
          EFC(3,NMTTPT+I) = EFC(3,NMTTPT+I) + ZCRD(1,N)
C         WRITE(6,FMT='(3F9.5)') (EFC(J,I+NMTTPT), J=1,3)
          FRGNME(NMTTPT+I)   = MNAME(I)
          EFCHG(1,NMTTPT+I)  = ACHG(1,I)
          FMASS(NMTTPT+I)    = FPMASS(I)
  549   CONTINUE
        RETURN
      ELSE
      DO 550 I = 1,NPTS
        EFC(1,NMTTPT+I) = EFC(1,NMTTPT+I) + XCRD(1,N)
        EFC(2,NMTTPT+I) = EFC(2,NMTTPT+I) + YCRD(1,N)
        EFC(3,NMTTPT+I) = EFC(3,NMTTPT+I) + ZCRD(1,N)
C       WRITE(6,FMT='(3F9.5)') (EFC(J,I+NMTTPT), J=1,3)
        FRGNME(NMTTPT+I)   = MNAME(I)
        EFCHG(1,NMTTPT+I)  = ACHG(1,I)
        EFCHG(2,NMTTPT+I)  = ACHG(2,I)
        EFATRM(NMTTPT+I)   = AMULT(I)
        EFBTRM(NMTTPT+I)   = BMULT(I)
        EFATRM2(NMTTPT+I)  = AMULT2(I)
        EFBTRM2(NMTTPT+I)  = BMULT2(I)
        DOMONO(NMTTPT+I)   = DOMTMP(I)
        DODIPO(NMTTPT+I)   = DODTMP(I)
        DOQUAD(NMTTPT+I)   = DOQTMP(I)
        DOOCTU(NMTTPT+I)   = DOOTMP(I)
        FMASS(NMTTPT+I)    = FPMASS(I)
        FGNUC(NMTTPT+I)    = FPNUC(I)
  550 CONTINUE
C
C ROTATING DIPOLE MOMENTS
C
      CALL MRARBR(T3,3,3,3,ADIP,3,NPTS,EFDIP(1,NMTTPT+1),3)
C
C ROTATING QUADRUPOLE MOMENTS
C
C     WRITE(6,*) 'ROTATED QUADRUPOLES'
      CALL VCLR(TEMP3,1,3)
      DO 600 I=1,NPTS
        TEMP2(1)=AQAD(1,I)
        TEMP2(2)=AQAD(4,I)
        TEMP2(3)=AQAD(2,I)
        TEMP2(4)=AQAD(5,I)
        TEMP2(5)=AQAD(6,I)
        TEMP2(6)=AQAD(3,I)
        CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
        EFQAD(1,NMTTPT+I)=TEMP4(1,1)
        EFQAD(4,NMTTPT+I)=TEMP4(2,1)
        EFQAD(2,NMTTPT+I)=TEMP4(3,1)
        EFQAD(5,NMTTPT+I)=TEMP4(4,1)
        EFQAD(6,NMTTPT+I)=TEMP4(5,1)
        EFQAD(3,NMTTPT+I)=TEMP4(6,1)
C       WRITE(6,FMT='(6F9.5)') (EFQAD(J,NMTTPT+I), J=1,6)
  600 CONTINUE
C
C ROTATING OCTUPOLE MOMENTS
C
C     WRITE(6,*) 'ROTATED OCTUPOLES'
      DO 650 I=1,NPTS
        TEMP2(1) = AOCT(1,I)
        TEMP2(2) = AOCT(4,I)
        TEMP2(3) = AOCT(6,I)
        TEMP2(4) = AOCT(5,I)
        TEMP2(5) = AOCT(10,I)
        TEMP2(6) = AOCT(8,I)
        CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
C
        TEMP2(1)=AOCT(4,I)
        TEMP2(2)=AOCT(6,I)
        TEMP2(3)=AOCT(2,I)
        TEMP2(4)=AOCT(10,I)
        TEMP2(5)=AOCT(7,I)
        TEMP2(6)=AOCT(9,I)
        CALL TFTRI(TEMP4(1,2),TEMP2,T3T,TEMP3,3,3,3)
C
        TEMP2(1)=AOCT(5,I)
        TEMP2(2)=AOCT(10,I)
        TEMP2(3)=AOCT(7,I)
        TEMP2(4)=AOCT(8,I)
        TEMP2(5)=AOCT(9,I)
        TEMP2(6)=AOCT(3,I)
        CALL TFTRI(TEMP4(1,3),TEMP2,T3T,TEMP3,3,3,3)
C
        CALL MRARBR(TEMP4,6,6,3,T3T,3,3,TEMP5,6)
        EFOCT(1,NMTTPT+I)=TEMP5(1,1)
        EFOCT(2,NMTTPT+I)=TEMP5(3,2)
        EFOCT(3,NMTTPT+I)=TEMP5(6,3)
        EFOCT(4,NMTTPT+I)=TEMP5(2,1)
        EFOCT(5,NMTTPT+I)=TEMP5(4,1)
        EFOCT(6,NMTTPT+I)=TEMP5(3,1)
        EFOCT(7,NMTTPT+I)=TEMP5(5,2)
        EFOCT(8,NMTTPT+I)=TEMP5(6,1)
        EFOCT(9,NMTTPT+I)=TEMP5(6,2)
        EFOCT(10,NMTTPT+I)=TEMP5(5,1)
C       WRITE(6,FMT='(10F9.5)') (EFOCT(J,NMTTPT+I), J=1,10)
  650 CONTINUE
C
C    ROTATING FORCE POINTS
C      WRITE(6,*)'NTFRCPN = ',NTFRCPN
      NFPT = NFPNT(N)
      NFRCPNT(N)=NFPNT(N)
C      WRITE(6,*)'NFPT = ',NFPT
      DO 652 I=1,NFPT
         DO 651 J=1,3
            TEMP(J,I) = FCRD(J,I) - CORD(J,IPT(1))
  651    CONTINUE
  652 CONTINUE
C
      CALL MRARBR(T3,3,3,3,TEMP,3,NFPT,FRCCRD(1,NTFRCPN+1),3)
      DO 655 I = 1,NFPT
        FRCCRD(1,NTFRCPN+I) = FRCCRD(1,NTFRCPN+I) + XCRD(1,N)
        FRCCRD(2,NTFRCPN+I) = FRCCRD(2,NTFRCPN+I) + YCRD(1,N)
        FRCCRD(3,NTFRCPN+I) = FRCCRD(3,NTFRCPN+I) + ZCRD(1,N)
        FRCNME(NTFRCPN+I)   = FNAME(I)
  655 CONTINUE
C
C  ROTATING POLARIZABILITY-COORDINATES AND TENSOR
C
      IPPTS=NPPTS(N)
      DO 670 I=1,IPPTS
         DO 660 J=1,3
            TEMP(J,I) = PCORD(J,I) - CORD(J,IPT(1))
  660    CONTINUE
  670 CONTINUE
C
      CALL MRARBR(T3,3,3,3,TEMP,3,IPPTS,EFP(1,NPTTPT+1),3)
C
      IPLSCR = IIPLSCR
      INDSCR = IINDSCR
      DO 680 I = 1,IPPTS
         EFP(1,I+NPTTPT) = EFP(1,I+NPTTPT) + XCRD(1,N)
         EFP(2,I+NPTTPT) = EFP(2,I+NPTTPT) + YCRD(1,N)
         EFP(3,I+NPTTPT) = EFP(3,I+NPTTPT) + ZCRD(1,N)
         POLNAM(I+NPTTPT) = PNAME(I)
         POLSCR(I+NPTTPT)   = POLSCRN(I)
  680 CONTINUE
C
      DO 690 I=1,IPPTS
        T1(1,1) = POLT(1,I)
        T1(1,2) = POLT(4,I)
        T1(1,3) = POLT(5,I)
        T1(2,1) = POLT(7,I)
        T1(2,2) = POLT(2,I)
        T1(2,3) = POLT(6,I)
        T1(3,1) = POLT(8,I)
        T1(3,2) = POLT(9,I)
        T1(3,3) = POLT(3,I)
        CALL MRARBR(T3,3,3,3,T1,3,3,T2,3)
        CALL MRARBR(T2,3,3,3,T3T,3,3,T1,3)
C
        EFPOL(1,NPTTPT+I) = T1(1,1)
        EFPOL(4,NPTTPT+I) = T1(1,2)
        EFPOL(5,NPTTPT+I) = T1(1,3)
        EFPOL(7,NPTTPT+I) = T1(2,1)
        EFPOL(2,NPTTPT+I) = T1(2,2)
        EFPOL(6,NPTTPT+I) = T1(2,3)
        EFPOL(8,NPTTPT+I) = T1(3,1)
        EFPOL(9,NPTTPT+I) = T1(3,2)
        EFPOL(3,NPTTPT+I) = T1(3,3)
  690 CONTINUE
C
C         ROTATION OF LENNARD-JONES POTENTIAL
C
      ILJPTS = NLJPTS(N)
      DO I=1,ILJPTS
         DO J=1,3
            TEMP(J,I) = CORDLJ(J,I) - CORD(J,IPT(1))
         ENDDO
      ENDDO
      CALL MRARBR(T3,3,3,3,TEMP,3,ILJPTS,ELJCRD(1,NLJTTPT+1),3)
      DO I = 1,ILJPTS
         ELJCRD(1,I+NLJTTPT) = ELJCRD(1,I+NLJTTPT) + XCRD(1,N)
         ELJCRD(2,I+NLJTTPT) = ELJCRD(2,I+NLJTTPT) + YCRD(1,N)
         ELJCRD(3,I+NLJTTPT) = ELJCRD(3,I+NLJTTPT) + ZCRD(1,N)
         ELJNAM(  I+NLJTTPT) = LJNAME(I)
         ELJPOT(1,I+NLJTTPT) = POTLJ(1,I)
         ELJPOT(2,I+NLJTTPT) = POTLJ(2,I)
      ENDDO
C
C
C         ROTATION OF REPULSIVE POTENTIAL
C
      IRPTS = NRPTS(N)
      DO 720 I=1,IRPTS
        DO 710 J=1,3
          TEMP(J,I) = RCORD(J,I) - CORD(J,IPT(1))
  710   CONTINUE
  720 CONTINUE
C
      CALL MRARBR(T3,3,3,3,TEMP,3,IRPTS,CREP(1,NRTTPT+1),3)
C
      DO 740 I = 1,IRPTS
        CREP(1,I+NRTTPT) = CREP(1,I+NRTTPT) + XCRD(1,N)
        CREP(2,I+NRTTPT) = CREP(2,I+NRTTPT) + YCRD(1,N)
        CREP(3,I+NRTTPT) = CREP(3,I+NRTTPT) + ZCRD(1,N)
        REPNAM(I+NRTTPT) = RNAME(I)
        KFR(I+NRTTPT) = IKFR(I)+IDXSV
        KLR(I+NRTTPT) = IKLR(I)+IDXSV
        IFF = IKFR(I)
        ISS = IKLR(I)
        DO 730 II=IFF,ISS
          CLPR(II+IDXSV) = TCLPR(II)
          NLPR(II+IDXSV) = INLPR(II)
          ZLPR(II+IDXSV) = TZLPR(II)
  730   CONTINUE
  740 CONTINUE
C
      IDXSV=KLR(IRPTS+NRTTPT)
C
C     --- FOR DISPERSION ---
C
      IDPTS = NDPTS(N)
      DO 820 I=1,IDPTS
        DO 810 J=1,3
          TEMP(J,I) = DCORD(J,I) - CORD(J,IPT(1))
  810   CONTINUE
  820 CONTINUE
C
      CALL MRARBR(T3,3,3,3,TEMP,3,IDPTS,CDIS(1,NDTTPT+1),3)
C
      DO 840 I = 1,IDPTS
        CDIS(1,I+NDTTPT) = CDIS(1,I+NDTTPT) + XCRD(1,N)
        CDIS(2,I+NDTTPT) = CDIS(2,I+NDTTPT) + YCRD(1,N)
        CDIS(3,I+NDTTPT) = CDIS(3,I+NDTTPT) + ZCRD(1,N)
        DPSNAM(I+NDTTPT) = DNAME(I)
        KFD(I+NRTTPT) = JKFR(I)+JDXSV
        KLD(I+NRTTPT) = JKLR(I)+JDXSV
        IFF = JKFR(I)
        ISS = JKLR(I)
        DO 830 II=IFF,ISS
          CLPD(II+JDXSV) = TCLPD(II)
          NLPD(II+JDXSV) = JNLPR(II)
          ZLPD(II+JDXSV) = TZLPD(II)
  830   CONTINUE
  840 CONTINUE
C
      JDXSV=KLD(IDPTS+NDTTPT)
C
C  PAULI REPULSION INFORMATION
C
      INAT = NAT(ISET(N))
      IF(INAT.EQ.0) RETURN
      DO I=1,INAT
         DO J=1,3
            TEMP(J,I) = PRCORD(J,I+NTPATM) - CORD(J,IPT(1))
         END DO
      END DO
      CALL MRARBR(T3,3,3,3,TEMP,3,INAT,PRCORD(1,NTPATM+1),3)
      DO I=1,INAT
         PRCORD(1,I+NTPATM) = PRCORD(1,I+NTPATM) + XCRD(1,N)
         PRCORD(2,I+NTPATM) = PRCORD(2,I+NTPATM) + YCRD(1,N)
         PRCORD(3,I+NTPATM) = PRCORD(3,I+NTPATM) + ZCRD(1,N)
      END DO
C
      IMO = NORB(N)
      DO NSHL = 1,NSHELL(ISET(N))
         ITYP = KMAX(NSHL,ISET(N)) - KMIN(NSHL,ISET(N)) + 1
         LOC = KLOC(NSHL,ISET(N))
C
C  S: DO NOTHING
C
C  P:
C
         IF(ITYP.EQ.3) THEN
            DO I = 1,IMO
               TEMP3(1) = PROVEC(LOC,NTMO+I)
               TEMP3(2) = PROVEC(LOC+1,NTMO+I)
               TEMP3(3) = PROVEC(LOC+2,NTMO+I)
               CALL MRARBR(T3,3,3,3,TEMP3,3,1,TEMP4(1,1),3)
               PROVEC(LOC,NTMO+I) = TEMP4(1,1)
               PROVEC(LOC+1,NTMO+I) = TEMP4(2,1)
               PROVEC(LOC+2,NTMO+I) = TEMP4(3,1)
            END DO
         END IF
C  L:
         IF(ITYP.EQ.4) THEN
            DO I = 1,IMO
               TEMP3(1) = PROVEC(LOC+1,NTMO+I)
               TEMP3(2) = PROVEC(LOC+2,NTMO+I)
               TEMP3(3) = PROVEC(LOC+3,NTMO+I)
               CALL MRARBR(T3,3,3,3,TEMP3,3,1,TEMP4(1,1),3)
               PROVEC(LOC+1,NTMO+I) = TEMP4(1,1)
               PROVEC(LOC+2,NTMO+I) = TEMP4(2,1)
               PROVEC(LOC+3,NTMO+I) = TEMP4(3,1)
            END DO
         END IF
C  D:
C              THE NORMALIZATION FOR XY,XZ,YZ GAUSSIANS IS SQRT(3)
C              LARGER THAN XX,YY,ZZ. FACTOR OF TWO ALLOWS SUMMATION
C              OVER ALL INDICES RATHER THAN I,J<=I
C
         IF(ITYP.EQ.6) THEN
            DO I = 1,IMO
               TEMP2(1) = PROVEC(LOC,NTMO+I)
               TEMP2(2) = PROVEC(LOC+3,NTMO+I)/CONST
               TEMP2(3) = PROVEC(LOC+1,NTMO+I)
               TEMP2(4) = PROVEC(LOC+4,NTMO+I)/CONST
               TEMP2(5) = PROVEC(LOC+5,NTMO+I)/CONST
               TEMP2(6) = PROVEC(LOC+2,NTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               PROVEC(LOC,NTMO+I) = TEMP4(1,1)
               PROVEC(LOC+3,NTMO+I) = TEMP4(2,1)*CONST
               PROVEC(LOC+1,NTMO+I) = TEMP4(3,1)
               PROVEC(LOC+4,NTMO+I) = TEMP4(4,1)*CONST
               PROVEC(LOC+5,NTMO+I) = TEMP4(5,1)*CONST
               PROVEC(LOC+2,NTMO+I) = TEMP4(6,1)
            END DO
         END IF
C  F:
         IF(ITYP.EQ.10) THEN
            DO I = 1,IMO
               PROVEC(LOC+3,NTMO+I) = PROVEC(LOC+3,NTMO+I)*SQRT5/THREE
               PROVEC(LOC+4,NTMO+I) = PROVEC(LOC+4,NTMO+I)*SQRT5/THREE
               PROVEC(LOC+5,NTMO+I) = PROVEC(LOC+5,NTMO+I)*SQRT5/THREE
               PROVEC(LOC+6,NTMO+I) = PROVEC(LOC+6,NTMO+I)*SQRT5/THREE
               PROVEC(LOC+7,NTMO+I) = PROVEC(LOC+7,NTMO+I)*SQRT5/THREE
               PROVEC(LOC+8,NTMO+I) = PROVEC(LOC+8,NTMO+I)*SQRT5/THREE
               PROVEC(LOC+9,NTMO+I) = PROVEC(LOC+9,NTMO+I)*SQRT5/THREE
               PROVEC(LOC+9,NTMO+I) = PROVEC(LOC+9,NTMO+I)*SQRT3/TWO
C
               TEMP2(1) = PROVEC(LOC  ,NTMO+I)
               TEMP2(2) = PROVEC(LOC+3,NTMO+I)
               TEMP2(3) = PROVEC(LOC+5,NTMO+I)
               TEMP2(4) = PROVEC(LOC+4,NTMO+I)
               TEMP2(5) = PROVEC(LOC+9,NTMO+I)
               TEMP2(6) = PROVEC(LOC+7,NTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
C
               TEMP2(1) = PROVEC(LOC+3,NTMO+I)
               TEMP2(2) = PROVEC(LOC+5,NTMO+I)
               TEMP2(3) = PROVEC(LOC+1,NTMO+I)
               TEMP2(4) = PROVEC(LOC+9,NTMO+I)
               TEMP2(5) = PROVEC(LOC+6,NTMO+I)
               TEMP2(6) = PROVEC(LOC+8,NTMO+I)
               CALL TFTRI(TEMP4(1,2),TEMP2,T3T,TEMP3,3,3,3)
C
               TEMP2(1) = PROVEC(LOC+4,NTMO+I)
               TEMP2(2) = PROVEC(LOC+9,NTMO+I)
               TEMP2(3) = PROVEC(LOC+6,NTMO+I)
               TEMP2(4) = PROVEC(LOC+7,NTMO+I)
               TEMP2(5) = PROVEC(LOC+8,NTMO+I)
               TEMP2(6) = PROVEC(LOC+2,NTMO+I)
               CALL TFTRI(TEMP4(1,3),TEMP2,T3T,TEMP3,3,3,3)
C
               CALL MRARBR(TEMP4,6,6,3,T3T,3,3,TEMP5,6)
C
               PROVEC(LOC  ,NTMO+I) = TEMP5(1,1)
               PROVEC(LOC+1,NTMO+I) = TEMP5(3,2)
               PROVEC(LOC+2,NTMO+I) = TEMP5(6,3)
               PROVEC(LOC+3,NTMO+I) = TEMP5(2,1)/SQRT5*THREE
               PROVEC(LOC+4,NTMO+I) = TEMP5(4,1)/SQRT5*THREE
               PROVEC(LOC+5,NTMO+I) = TEMP5(3,1)/SQRT5*THREE
               PROVEC(LOC+6,NTMO+I) = TEMP5(5,2)/SQRT5*THREE
               PROVEC(LOC+7,NTMO+I) = TEMP5(6,1)/SQRT5*THREE
               PROVEC(LOC+8,NTMO+I) = TEMP5(6,2)/SQRT5*THREE
               PROVEC(LOC+9,NTMO+I) = TEMP5(5,1)/SQRT5*THREE/SQRT3*TWO
C
            END DO
         END IF
C
C  G:
C
         IF(ITYP.EQ.15) THEN
            DO I = 1,IMO
               PROVEC(LOC+ 3,NTMO+I) = PROVEC(LOC+ 3,NTMO+I)*SQRT7/FOUR
               PROVEC(LOC+ 4,NTMO+I) = PROVEC(LOC+ 4,NTMO+I)*SQRT7/FOUR
               PROVEC(LOC+ 5,NTMO+I) = PROVEC(LOC+ 5,NTMO+I)*SQRT7/FOUR
               PROVEC(LOC+ 6,NTMO+I) = PROVEC(LOC+ 6,NTMO+I)*SQRT7/FOUR
               PROVEC(LOC+ 7,NTMO+I) = PROVEC(LOC+ 7,NTMO+I)*SQRT7/FOUR
               PROVEC(LOC+ 8,NTMO+I) = PROVEC(LOC+ 8,NTMO+I)*SQRT7/FOUR
               PROVEC(LOC+ 9,NTMO+I) = PROVEC(LOC+ 9,NTMO+I)*SQRT7*
     *                                 SQRT5/SQRT3/SIX
               PROVEC(LOC+10,NTMO+I) = PROVEC(LOC+10,NTMO+I)*SQRT7*
     *                                 SQRT5/SQRT3/SIX
               PROVEC(LOC+11,NTMO+I) = PROVEC(LOC+11,NTMO+I)*SQRT7*
     *                                 SQRT5/SQRT3/SIX
               PROVEC(LOC+12,NTMO+I) = PROVEC(LOC+12,NTMO+I)*SQRT7*
     *                                 SQRT5/TWELVE
               PROVEC(LOC+13,NTMO+I) = PROVEC(LOC+13,NTMO+I)*SQRT7*
     *                                 SQRT5/TWELVE
               PROVEC(LOC+14,NTMO+I) = PROVEC(LOC+14,NTMO+I)*SQRT7*
     *                                 SQRT5/TWELVE
C
C              PERFORM THE FIRST AND SECOND ROTATION
C
               TEMP2(1) = PROVEC(LOC   ,NTMO+I)
               TEMP2(2) = PROVEC(LOC+ 3,NTMO+I)
               TEMP2(3) = PROVEC(LOC+ 9,NTMO+I)
               TEMP2(4) = PROVEC(LOC+ 4,NTMO+I)
               TEMP2(5) = PROVEC(LOC+12,NTMO+I)
               TEMP2(6) = PROVEC(LOC+10,NTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXX(1) = TEMP4(1,1)
               TPXX(2) = TEMP4(2,1)
               TPXX(3) = TEMP4(3,1)
               TPXX(4) = TEMP4(4,1)
               TPXX(5) = TEMP4(5,1)
               TPXX(6) = TEMP4(6,1)
C
               TEMP2(1) = PROVEC(LOC+ 3,NTMO+I)
               TEMP2(2) = PROVEC(LOC+ 9,NTMO+I)
               TEMP2(3) = PROVEC(LOC+ 5,NTMO+I)
               TEMP2(4) = PROVEC(LOC+12,NTMO+I)
               TEMP2(5) = PROVEC(LOC+13,NTMO+I)
               TEMP2(6) = PROVEC(LOC+14,NTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXY(1) = TEMP4(1,1)
               TPXY(2) = TEMP4(2,1)
               TPXY(3) = TEMP4(3,1)
               TPXY(4) = TEMP4(4,1)
               TPXY(5) = TEMP4(5,1)
               TPXY(6) = TEMP4(6,1)
C
               TEMP2(1) = PROVEC(LOC+ 9,NTMO+I)
               TEMP2(2) = PROVEC(LOC+ 5,NTMO+I)
               TEMP2(3) = PROVEC(LOC+ 1,NTMO+I)
               TEMP2(4) = PROVEC(LOC+13,NTMO+I)
               TEMP2(5) = PROVEC(LOC+ 6,NTMO+I)
               TEMP2(6) = PROVEC(LOC+11,NTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYY(1) = TEMP4(1,1)
               TPYY(2) = TEMP4(2,1)
               TPYY(3) = TEMP4(3,1)
               TPYY(4) = TEMP4(4,1)
               TPYY(5) = TEMP4(5,1)
               TPYY(6) = TEMP4(6,1)
C
               TEMP2(1) = PROVEC(LOC+ 4,NTMO+I)
               TEMP2(2) = PROVEC(LOC+12,NTMO+I)
               TEMP2(3) = PROVEC(LOC+13,NTMO+I)
               TEMP2(4) = PROVEC(LOC+10,NTMO+I)
               TEMP2(5) = PROVEC(LOC+14,NTMO+I)
               TEMP2(6) = PROVEC(LOC+ 7,NTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXZ(1) = TEMP4(1,1)
               TPXZ(2) = TEMP4(2,1)
               TPXZ(3) = TEMP4(3,1)
               TPXZ(4) = TEMP4(4,1)
               TPXZ(5) = TEMP4(5,1)
               TPXZ(6) = TEMP4(6,1)
C
               TEMP2(1) = PROVEC(LOC+12,NTMO+I)
               TEMP2(2) = PROVEC(LOC+13,NTMO+I)
               TEMP2(3) = PROVEC(LOC+ 6,NTMO+I)
               TEMP2(4) = PROVEC(LOC+14,NTMO+I)
               TEMP2(5) = PROVEC(LOC+11,NTMO+I)
               TEMP2(6) = PROVEC(LOC+ 8,NTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYZ(1) = TEMP4(1,1)
               TPYZ(2) = TEMP4(2,1)
               TPYZ(3) = TEMP4(3,1)
               TPYZ(4) = TEMP4(4,1)
               TPYZ(5) = TEMP4(5,1)
               TPYZ(6) = TEMP4(6,1)
C
               TEMP2(1) = PROVEC(LOC+10,NTMO+I)
               TEMP2(2) = PROVEC(LOC+14,NTMO+I)
               TEMP2(3) = PROVEC(LOC+11,NTMO+I)
               TEMP2(4) = PROVEC(LOC+ 7,NTMO+I)
               TEMP2(5) = PROVEC(LOC+ 8,NTMO+I)
               TEMP2(6) = PROVEC(LOC+ 2,NTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPZZ(1) = TEMP4(1,1)
               TPZZ(2) = TEMP4(2,1)
               TPZZ(3) = TEMP4(3,1)
               TPZZ(4) = TEMP4(4,1)
               TPZZ(5) = TEMP4(5,1)
               TPZZ(6) = TEMP4(6,1)
C
C              PERFORM THE THIRD AND FOURTH ROTATION
C
               TEMP2(1) = TPXX(1)
               TEMP2(2) = TPXY(1)
               TEMP2(3) = TPYY(1)
               TEMP2(4) = TPXZ(1)
               TEMP2(5) = TPYZ(1)
               TEMP2(6) = TPZZ(1)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXX2(1) = TEMP4(1,1)
               TPXX2(2) = TEMP4(2,1)
               TPXX2(3) = TEMP4(3,1)
               TPXX2(4) = TEMP4(4,1)
               TPXX2(5) = TEMP4(5,1)
               TPXX2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(2)
               TEMP2(2) = TPXY(2)
               TEMP2(3) = TPYY(2)
               TEMP2(4) = TPXZ(2)
               TEMP2(5) = TPYZ(2)
               TEMP2(6) = TPZZ(2)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXY2(1) = TEMP4(1,1)
               TPXY2(2) = TEMP4(2,1)
               TPXY2(3) = TEMP4(3,1)
               TPXY2(4) = TEMP4(4,1)
               TPXY2(5) = TEMP4(5,1)
               TPXY2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(3)
               TEMP2(2) = TPXY(3)
               TEMP2(3) = TPYY(3)
               TEMP2(4) = TPXZ(3)
               TEMP2(5) = TPYZ(3)
               TEMP2(6) = TPZZ(3)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYY2(1) = TEMP4(1,1)
               TPYY2(2) = TEMP4(2,1)
               TPYY2(3) = TEMP4(3,1)
               TPYY2(4) = TEMP4(4,1)
               TPYY2(5) = TEMP4(5,1)
               TPYY2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(4)
               TEMP2(2) = TPXY(4)
               TEMP2(3) = TPYY(4)
               TEMP2(4) = TPXZ(4)
               TEMP2(5) = TPYZ(4)
               TEMP2(6) = TPZZ(4)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXZ2(1) = TEMP4(1,1)
               TPXZ2(2) = TEMP4(2,1)
               TPXZ2(3) = TEMP4(3,1)
               TPXZ2(4) = TEMP4(4,1)
               TPXZ2(5) = TEMP4(5,1)
               TPXZ2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(5)
               TEMP2(2) = TPXY(5)
               TEMP2(3) = TPYY(5)
               TEMP2(4) = TPXZ(5)
               TEMP2(5) = TPYZ(5)
               TEMP2(6) = TPZZ(5)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYZ2(1) = TEMP4(1,1)
               TPYZ2(2) = TEMP4(2,1)
               TPYZ2(3) = TEMP4(3,1)
               TPYZ2(4) = TEMP4(4,1)
               TPYZ2(5) = TEMP4(5,1)
               TPYZ2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(6)
               TEMP2(2) = TPXY(6)
               TEMP2(3) = TPYY(6)
               TEMP2(4) = TPXZ(6)
               TEMP2(5) = TPYZ(6)
               TEMP2(6) = TPZZ(6)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPZZ2(1) = TEMP4(1,1)
               TPZZ2(2) = TEMP4(2,1)
               TPZZ2(3) = TEMP4(3,1)
               TPZZ2(4) = TEMP4(4,1)
               TPZZ2(5) = TEMP4(5,1)
               TPZZ2(6) = TEMP4(6,1)
C
               PROVEC(LOC   ,NTMO+I) = TPXX2(1)
               PROVEC(LOC+ 1,NTMO+I) = TPYY2(3)
               PROVEC(LOC+ 2,NTMO+I) = TPZZ2(6)
               PROVEC(LOC+ 3,NTMO+I) = TPXY2(1)/SQRT7*FOUR
               PROVEC(LOC+ 4,NTMO+I) = TPXZ2(1)/SQRT7*FOUR
               PROVEC(LOC+ 5,NTMO+I) = TPYY2(2)/SQRT7*FOUR
               PROVEC(LOC+ 6,NTMO+I) = TPYZ2(3)/SQRT7*FOUR
               PROVEC(LOC+ 7,NTMO+I) = TPXZ2(6)/SQRT7*FOUR
               PROVEC(LOC+ 8,NTMO+I) = TPYZ2(6)/SQRT7*FOUR
               PROVEC(LOC+ 9,NTMO+I) = TPYY2(1)/SQRT7/SQRT5*SQRT3*SIX
               PROVEC(LOC+10,NTMO+I) = TPZZ2(1)/SQRT7/SQRT5*SQRT3*SIX
               PROVEC(LOC+11,NTMO+I) = TPZZ2(3)/SQRT7/SQRT5*SQRT3*SIX
               PROVEC(LOC+12,NTMO+I) = TPYZ2(1)/SQRT7/SQRT5*TWELVE
               PROVEC(LOC+13,NTMO+I) = TPYZ2(2)/SQRT7/SQRT5*TWELVE
               PROVEC(LOC+14,NTMO+I) = TPZZ2(2)/SQRT7/SQRT5*TWELVE
            END DO
         END IF
      END DO
C
      DO I=1,IMO
         DO J=1,3
            TEMP(J,I) = CENTCD(J,I+NTMO) - CORD(J,IPT(1))
         END DO
      END DO
      CALL MRARBR(T3,3,3,3,TEMP,3,IMO,CENTCD(1,NTMO+1),3)
      DO I=1,IMO
         CENTCD(1,I+NTMO) = CENTCD(1,I+NTMO) + XCRD(1,N)
         CENTCD(2,I+NTMO) = CENTCD(2,I+NTMO) + YCRD(1,N)
         CENTCD(3,I+NTMO) = CENTCD(3,I+NTMO) + ZCRD(1,N)
      END DO
C
C
C  ROTATE CANONICAL VEC
C
C      IAO = NPBF(N)
      ICTMO = NCTMO(ISET(N))
      DO NSHL = 1,NSHELL(ISET(N))
         ITYP = KMAX(NSHL,ISET(N)) - KMIN(NSHL,ISET(N)) + 1
         LOC = KLOC(NSHL,ISET(N))
C
C  S: DO NOTHING
C
C  P:
C
         IF(ITYP.EQ.3) THEN
            DO I = 1,ICTMO
               TEMP3(1) = CTVEC(LOC,NTCTMO+I)
               TEMP3(2) = CTVEC(LOC+1,NTCTMO+I)
               TEMP3(3) = CTVEC(LOC+2,NTCTMO+I)
               CALL MRARBR(T3,3,3,3,TEMP3,3,1,TEMP4(1,1),3)
               CTVEC(LOC,NTCTMO+I) = TEMP4(1,1)
               CTVEC(LOC+1,NTCTMO+I) = TEMP4(2,1)
               CTVEC(LOC+2,NTCTMO+I) = TEMP4(3,1)
            END DO
         END IF
C  L:
         IF(ITYP.EQ.4) THEN
            DO I = 1,ICTMO
               TEMP3(1) = CTVEC(LOC+1,NTCTMO+I)
               TEMP3(2) = CTVEC(LOC+2,NTCTMO+I)
               TEMP3(3) = CTVEC(LOC+3,NTCTMO+I)
               CALL MRARBR(T3,3,3,3,TEMP3,3,1,TEMP4(1,1),3)
               CTVEC(LOC+1,NTCTMO+I) = TEMP4(1,1)
               CTVEC(LOC+2,NTCTMO+I) = TEMP4(2,1)
               CTVEC(LOC+3,NTCTMO+I) = TEMP4(3,1)
            END DO
         END IF
C  D:
C              THE NORMALIZATION FOR XY,XZ,YZ GAUSSIANS IS SQRT(3)
C              LARGER THAN XX,YY,ZZ. FACTOR OF TWO ALLOWS SUMMATION
C              OVER ALL INDICES RATHER THAN I,J<=I
C
         IF(ITYP.EQ.6) THEN
            DO I = 1,ICTMO
               TEMP2(1) = CTVEC(LOC,NTCTMO+I)
               TEMP2(2) = CTVEC(LOC+3,NTCTMO+I)/CONST
               TEMP2(3) = CTVEC(LOC+1,NTCTMO+I)
               TEMP2(4) = CTVEC(LOC+4,NTCTMO+I)/CONST
               TEMP2(5) = CTVEC(LOC+5,NTCTMO+I)/CONST
               TEMP2(6) = CTVEC(LOC+2,NTCTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               CTVEC(LOC,NTCTMO+I) = TEMP4(1,1)
               CTVEC(LOC+3,NTCTMO+I) = TEMP4(2,1)*CONST
               CTVEC(LOC+1,NTCTMO+I) = TEMP4(3,1)
               CTVEC(LOC+4,NTCTMO+I) = TEMP4(4,1)*CONST
               CTVEC(LOC+5,NTCTMO+I) = TEMP4(5,1)*CONST
               CTVEC(LOC+2,NTCTMO+I) = TEMP4(6,1)
            END DO
         END IF
C
C  F:
C
         IF(ITYP.EQ.10) THEN
            DO I = 1,ICTMO
               CTVEC(LOC+3,NTCTMO+I) = CTVEC(LOC+3,NTCTMO+I)*SQRT5/
     *                                  THREE
               CTVEC(LOC+4,NTCTMO+I) = CTVEC(LOC+4,NTCTMO+I)*SQRT5/
     *                                  THREE
               CTVEC(LOC+5,NTCTMO+I) = CTVEC(LOC+5,NTCTMO+I)*SQRT5/
     *                                  THREE
               CTVEC(LOC+6,NTCTMO+I) = CTVEC(LOC+6,NTCTMO+I)*SQRT5/
     *                                  THREE
               CTVEC(LOC+7,NTCTMO+I) = CTVEC(LOC+7,NTCTMO+I)*SQRT5/
     *                                  THREE
               CTVEC(LOC+8,NTCTMO+I) = CTVEC(LOC+8,NTCTMO+I)*SQRT5/
     *                                  THREE
               CTVEC(LOC+9,NTCTMO+I) = CTVEC(LOC+9,NTCTMO+I)*SQRT5/
     *                                  THREE
               CTVEC(LOC+9,NTCTMO+I) = CTVEC(LOC+9,NTCTMO+I)*SQRT3/
     *                                  TWO
C
               TEMP2(1) = CTVEC(LOC  ,NTCTMO+I)
               TEMP2(2) = CTVEC(LOC+3,NTCTMO+I)
               TEMP2(3) = CTVEC(LOC+5,NTCTMO+I)
               TEMP2(4) = CTVEC(LOC+4,NTCTMO+I)
               TEMP2(5) = CTVEC(LOC+9,NTCTMO+I)
               TEMP2(6) = CTVEC(LOC+7,NTCTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
C
               TEMP2(1) = CTVEC(LOC+3,NTCTMO+I)
               TEMP2(2) = CTVEC(LOC+5,NTCTMO+I)
               TEMP2(3) = CTVEC(LOC+1,NTCTMO+I)
               TEMP2(4) = CTVEC(LOC+9,NTCTMO+I)
               TEMP2(5) = CTVEC(LOC+6,NTCTMO+I)
               TEMP2(6) = CTVEC(LOC+8,NTCTMO+I)
               CALL TFTRI(TEMP4(1,2),TEMP2,T3T,TEMP3,3,3,3)
C
               TEMP2(1) = CTVEC(LOC+4,NTCTMO+I)
               TEMP2(2) = CTVEC(LOC+9,NTCTMO+I)
               TEMP2(3) = CTVEC(LOC+6,NTCTMO+I)
               TEMP2(4) = CTVEC(LOC+7,NTCTMO+I)
               TEMP2(5) = CTVEC(LOC+8,NTCTMO+I)
               TEMP2(6) = CTVEC(LOC+2,NTCTMO+I)
               CALL TFTRI(TEMP4(1,3),TEMP2,T3T,TEMP3,3,3,3)
C
               CALL MRARBR(TEMP4,6,6,3,T3T,3,3,TEMP5,6)
C
               CTVEC(LOC  ,NTCTMO+I) = TEMP5(1,1)
               CTVEC(LOC+1,NTCTMO+I) = TEMP5(3,2)
               CTVEC(LOC+2,NTCTMO+I) = TEMP5(6,3)
               CTVEC(LOC+3,NTCTMO+I) = TEMP5(2,1)/SQRT5*THREE
               CTVEC(LOC+4,NTCTMO+I) = TEMP5(4,1)/SQRT5*THREE
               CTVEC(LOC+5,NTCTMO+I) = TEMP5(3,1)/SQRT5*THREE
               CTVEC(LOC+6,NTCTMO+I) = TEMP5(5,2)/SQRT5*THREE
               CTVEC(LOC+7,NTCTMO+I) = TEMP5(6,1)/SQRT5*THREE
               CTVEC(LOC+8,NTCTMO+I) = TEMP5(6,2)/SQRT5*THREE
               CTVEC(LOC+9,NTCTMO+I) = TEMP5(5,1)/SQRT5*THREE/SQRT3*TWO
            END DO
         END IF
C
C  G:
C
         IF(ITYP.EQ.15) THEN
            DO I = 1,ICTMO
               CTVEC(LOC+ 3,NTCTMO+I) = CTVEC(LOC+ 3,NTCTMO+I)*SQRT7
     *                                    /FOUR
               CTVEC(LOC+ 4,NTCTMO+I) = CTVEC(LOC+ 4,NTCTMO+I)*SQRT7
     *                                    /FOUR
               CTVEC(LOC+ 5,NTCTMO+I) = CTVEC(LOC+ 5,NTCTMO+I)*SQRT7
     *                                    /FOUR
               CTVEC(LOC+ 6,NTCTMO+I) = CTVEC(LOC+ 6,NTCTMO+I)*SQRT7
     *                                    /FOUR
               CTVEC(LOC+ 7,NTCTMO+I) = CTVEC(LOC+ 7,NTCTMO+I)*SQRT7
     *                                    /FOUR
               CTVEC(LOC+ 8,NTCTMO+I) = CTVEC(LOC+ 8,NTCTMO+I)*SQRT7
     *                                    /FOUR
               CTVEC(LOC+ 9,NTCTMO+I) = CTVEC(LOC+ 9,NTCTMO+I)*SQRT7*
     *                                 SQRT5/SQRT3/SIX
               CTVEC(LOC+10,NTCTMO+I) = CTVEC(LOC+10,NTCTMO+I)*SQRT7*
     *                                 SQRT5/SQRT3/SIX
               CTVEC(LOC+11,NTCTMO+I) = CTVEC(LOC+11,NTCTMO+I)*SQRT7*
     *                                 SQRT5/SQRT3/SIX
               CTVEC(LOC+12,NTCTMO+I) = CTVEC(LOC+12,NTCTMO+I)*SQRT7*
     *                                 SQRT5/TWELVE
               CTVEC(LOC+13,NTCTMO+I) = CTVEC(LOC+13,NTCTMO+I)*SQRT7*
     *                                 SQRT5/TWELVE
               CTVEC(LOC+14,NTCTMO+I) = CTVEC(LOC+14,NTCTMO+I)*SQRT7*
     *                                 SQRT5/TWELVE
C
C              PERFORM THE FIRST AND SECOND ROTATION
C
               TEMP2(1) = CTVEC(LOC   ,NTCTMO+I)
               TEMP2(2) = CTVEC(LOC+ 3,NTCTMO+I)
               TEMP2(3) = CTVEC(LOC+ 9,NTCTMO+I)
               TEMP2(4) = CTVEC(LOC+ 4,NTCTMO+I)
               TEMP2(5) = CTVEC(LOC+12,NTCTMO+I)
               TEMP2(6) = CTVEC(LOC+10,NTCTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXX(1) = TEMP4(1,1)
               TPXX(2) = TEMP4(2,1)
               TPXX(3) = TEMP4(3,1)
               TPXX(4) = TEMP4(4,1)
               TPXX(5) = TEMP4(5,1)
               TPXX(6) = TEMP4(6,1)
C
               TEMP2(1) = CTVEC(LOC+ 3,NTCTMO+I)
               TEMP2(2) = CTVEC(LOC+ 9,NTCTMO+I)
               TEMP2(3) = CTVEC(LOC+ 5,NTCTMO+I)
               TEMP2(4) = CTVEC(LOC+12,NTCTMO+I)
               TEMP2(5) = CTVEC(LOC+13,NTCTMO+I)
               TEMP2(6) = CTVEC(LOC+14,NTCTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXY(1) = TEMP4(1,1)
               TPXY(2) = TEMP4(2,1)
               TPXY(3) = TEMP4(3,1)
               TPXY(4) = TEMP4(4,1)
               TPXY(5) = TEMP4(5,1)
               TPXY(6) = TEMP4(6,1)
C
               TEMP2(1) = CTVEC(LOC+ 9,NTCTMO+I)
               TEMP2(2) = CTVEC(LOC+ 5,NTCTMO+I)
               TEMP2(3) = CTVEC(LOC+ 1,NTCTMO+I)
               TEMP2(4) = CTVEC(LOC+13,NTCTMO+I)
               TEMP2(5) = CTVEC(LOC+ 6,NTCTMO+I)
               TEMP2(6) = CTVEC(LOC+11,NTCTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYY(1) = TEMP4(1,1)
               TPYY(2) = TEMP4(2,1)
               TPYY(3) = TEMP4(3,1)
               TPYY(4) = TEMP4(4,1)
               TPYY(5) = TEMP4(5,1)
               TPYY(6) = TEMP4(6,1)
C
               TEMP2(1) = CTVEC(LOC+ 4,NTCTMO+I)
               TEMP2(2) = CTVEC(LOC+12,NTCTMO+I)
               TEMP2(3) = CTVEC(LOC+13,NTCTMO+I)
               TEMP2(4) = CTVEC(LOC+10,NTCTMO+I)
               TEMP2(5) = CTVEC(LOC+14,NTCTMO+I)
               TEMP2(6) = CTVEC(LOC+ 7,NTCTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXZ(1) = TEMP4(1,1)
               TPXZ(2) = TEMP4(2,1)
               TPXZ(3) = TEMP4(3,1)
               TPXZ(4) = TEMP4(4,1)
               TPXZ(5) = TEMP4(5,1)
               TPXZ(6) = TEMP4(6,1)
C
               TEMP2(1) = CTVEC(LOC+12,NTCTMO+I)
               TEMP2(2) = CTVEC(LOC+13,NTCTMO+I)
               TEMP2(3) = CTVEC(LOC+ 6,NTCTMO+I)
               TEMP2(4) = CTVEC(LOC+14,NTCTMO+I)
               TEMP2(5) = CTVEC(LOC+11,NTCTMO+I)
               TEMP2(6) = CTVEC(LOC+ 8,NTCTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYZ(1) = TEMP4(1,1)
               TPYZ(2) = TEMP4(2,1)
               TPYZ(3) = TEMP4(3,1)
               TPYZ(4) = TEMP4(4,1)
               TPYZ(5) = TEMP4(5,1)
               TPYZ(6) = TEMP4(6,1)
C
               TEMP2(1) = CTVEC(LOC+10,NTCTMO+I)
               TEMP2(2) = CTVEC(LOC+14,NTCTMO+I)
               TEMP2(3) = CTVEC(LOC+11,NTCTMO+I)
               TEMP2(4) = CTVEC(LOC+ 7,NTCTMO+I)
               TEMP2(5) = CTVEC(LOC+ 8,NTCTMO+I)
               TEMP2(6) = CTVEC(LOC+ 2,NTCTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPZZ(1) = TEMP4(1,1)
               TPZZ(2) = TEMP4(2,1)
               TPZZ(3) = TEMP4(3,1)
               TPZZ(4) = TEMP4(4,1)
               TPZZ(5) = TEMP4(5,1)
               TPZZ(6) = TEMP4(6,1)
C
C              PERFORM THE THIRD AND FOURTH ROTATION
C
               TEMP2(1) = TPXX(1)
               TEMP2(2) = TPXY(1)
               TEMP2(3) = TPYY(1)
               TEMP2(4) = TPXZ(1)
               TEMP2(5) = TPYZ(1)
               TEMP2(6) = TPZZ(1)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXX2(1) = TEMP4(1,1)
               TPXX2(2) = TEMP4(2,1)
               TPXX2(3) = TEMP4(3,1)
               TPXX2(4) = TEMP4(4,1)
               TPXX2(5) = TEMP4(5,1)
               TPXX2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(2)
               TEMP2(2) = TPXY(2)
               TEMP2(3) = TPYY(2)
               TEMP2(4) = TPXZ(2)
               TEMP2(5) = TPYZ(2)
               TEMP2(6) = TPZZ(2)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXY2(1) = TEMP4(1,1)
               TPXY2(2) = TEMP4(2,1)
               TPXY2(3) = TEMP4(3,1)
               TPXY2(4) = TEMP4(4,1)
               TPXY2(5) = TEMP4(5,1)
               TPXY2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(3)
               TEMP2(2) = TPXY(3)
               TEMP2(3) = TPYY(3)
               TEMP2(4) = TPXZ(3)
               TEMP2(5) = TPYZ(3)
               TEMP2(6) = TPZZ(3)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYY2(1) = TEMP4(1,1)
               TPYY2(2) = TEMP4(2,1)
               TPYY2(3) = TEMP4(3,1)
               TPYY2(4) = TEMP4(4,1)
               TPYY2(5) = TEMP4(5,1)
               TPYY2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(4)
               TEMP2(2) = TPXY(4)
               TEMP2(3) = TPYY(4)
               TEMP2(4) = TPXZ(4)
               TEMP2(5) = TPYZ(4)
               TEMP2(6) = TPZZ(4)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXZ2(1) = TEMP4(1,1)
               TPXZ2(2) = TEMP4(2,1)
               TPXZ2(3) = TEMP4(3,1)
               TPXZ2(4) = TEMP4(4,1)
               TPXZ2(5) = TEMP4(5,1)
               TPXZ2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(5)
               TEMP2(2) = TPXY(5)
               TEMP2(3) = TPYY(5)
               TEMP2(4) = TPXZ(5)
               TEMP2(5) = TPYZ(5)
               TEMP2(6) = TPZZ(5)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYZ2(1) = TEMP4(1,1)
               TPYZ2(2) = TEMP4(2,1)
               TPYZ2(3) = TEMP4(3,1)
               TPYZ2(4) = TEMP4(4,1)
               TPYZ2(5) = TEMP4(5,1)
               TPYZ2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(6)
               TEMP2(2) = TPXY(6)
               TEMP2(3) = TPYY(6)
               TEMP2(4) = TPXZ(6)
               TEMP2(5) = TPYZ(6)
               TEMP2(6) = TPZZ(6)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPZZ2(1) = TEMP4(1,1)
               TPZZ2(2) = TEMP4(2,1)
               TPZZ2(3) = TEMP4(3,1)
               TPZZ2(4) = TEMP4(4,1)
               TPZZ2(5) = TEMP4(5,1)
               TPZZ2(6) = TEMP4(6,1)
C
               CTVEC(LOC   ,NTCTMO+I) = TPXX2(1)
               CTVEC(LOC+ 1,NTCTMO+I) = TPYY2(3)
               CTVEC(LOC+ 2,NTCTMO+I) = TPZZ2(6)
               CTVEC(LOC+ 3,NTCTMO+I) = TPXY2(1)/SQRT7*FOUR
               CTVEC(LOC+ 4,NTCTMO+I) = TPXZ2(1)/SQRT7*FOUR
               CTVEC(LOC+ 5,NTCTMO+I) = TPYY2(2)/SQRT7*FOUR
               CTVEC(LOC+ 6,NTCTMO+I) = TPYZ2(3)/SQRT7*FOUR
               CTVEC(LOC+ 7,NTCTMO+I) = TPXZ2(6)/SQRT7*FOUR
               CTVEC(LOC+ 8,NTCTMO+I) = TPYZ2(6)/SQRT7*FOUR
               CTVEC(LOC+ 9,NTCTMO+I) = TPYY2(1)/SQRT7/SQRT5*SQRT3*SIX
               CTVEC(LOC+10,NTCTMO+I) = TPZZ2(1)/SQRT7/SQRT5*SQRT3*SIX
               CTVEC(LOC+11,NTCTMO+I) = TPZZ2(3)/SQRT7/SQRT5*SQRT3*SIX
               CTVEC(LOC+12,NTCTMO+I) = TPYZ2(1)/SQRT7/SQRT5*TWELVE
               CTVEC(LOC+13,NTCTMO+I) = TPYZ2(2)/SQRT7/SQRT5*TWELVE
               CTVEC(LOC+14,NTCTMO+I) = TPZZ2(2)/SQRT7/SQRT5*TWELVE
            END DO
         END IF
      END DO
C
C  ROTATING DYNAMIC POLARIZABILITY-COORDINATES AND TENSOR
C
      IDPPTS=NDPPTS(N)
      DO 771 I=1,IDPPTS
        DO 761 J=1,3
          DTEMP(J,I) = DPCORD(J,I) - CORD(J,IPT(1))
  761   CONTINUE
  771 CONTINUE
C
      CALL MRARBR(T3,3,3,3,DTEMP,3,IDPPTS,EFDP(1,NDPTTPT+1),3)
C
      DO 781 I = 1,IDPPTS
C
        EFDP(1,I+NDPTTPT) = EFDP(1,I+NDPTTPT) + XCRD(1,N)
        EFDP(2,I+NDPTTPT) = EFDP(2,I+NDPTTPT) + YCRD(1,N)
        EFDP(3,I+NDPTTPT) = EFDP(3,I+NDPTTPT) + ZCRD(1,N)
C
        DPOLNAM(I+NDPTTPT) = DPNAME(I)
  781 CONTINUE
C
      CALL VCLR(TEMP3,1,3)
      CALL VCLR(T2,1,9)
      DO 791 I=1,IDPPTS
        T1(1,1) = DPOLT(1,I)
        T1(1,2) = DPOLT(4,I)
        T1(1,3) = DPOLT(5,I)
        T1(2,1) = DPOLT(7,I)
        T1(2,2) = DPOLT(2,I)
        T1(2,3) = DPOLT(6,I)
        T1(3,1) = DPOLT(8,I)
        T1(3,2) = DPOLT(9,I)
        T1(3,3) = DPOLT(3,I)
        CALL MRARBR(T3,3,3,3,T1,3,3,T2,3)
        CALL VCLR(T1,1,9)
        CALL MRARBR(T2,3,3,3,T3T,3,3,T1,3)
        EFDPOL(1,NDPTTPT+I) = T1(1,1)
        EFDPOL(4,NDPTTPT+I) = T1(1,2)
        EFDPOL(5,NDPTTPT+I) = T1(1,3)
        EFDPOL(7,NDPTTPT+I) = T1(2,1)
        EFDPOL(2,NDPTTPT+I) = T1(2,2)
        EFDPOL(6,NDPTTPT+I) = T1(2,3)
        EFDPOL(8,NDPTTPT+I) = T1(3,1)
        EFDPOL(9,NDPTTPT+I) = T1(3,2)
        EFDPOL(3,NDPTTPT+I) = T1(3,3)
  791 CONTINUE
C
      RETURN
      ENDIF
C
 9000 FORMAT(1X,'****',A8,' NOT FOUND IN ',A8,'****')
      END
C*MODULE EFINP   *DECK PRTFRG
      SUBROUTINE PRTFRG(AREL,CREL,MXRPTS,NDFG2)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      DIMENSION AREL(MXRPTS,MXRPTS,NDFG2),CREL(MXRPTS,MXRPTS,NDFG2)
C
      LOGICAL DOMONO,DODIPO,DOQUAD,DOOCTU
      LOGICAL DODIP,DOQUA,DOOCT
      LOGICAL GOPARR,MASWRK,DSKWRK
      LOGICAL IFRCPNT
C
      PARAMETER (MXSHEF=1000, MXGEFP=4000, MXPT=2000,
     *           MXDFG=5, MXFRG=1050, MXFGPT=12000, MXIFRQ=12,
     *           MXDPPT=MXFRG*MXDFG*12)
C
      CHARACTER*6 FRGNAM
      CHARACTER*8 PTNAM,FRGNME,POLNAM,DPOLNAM,REPNAM,KNAME,LNAME,FRCNME
      CHARACTER*8 LJNAME,ELJNAM
C
      COMMON /DOMULT/ DOMONO(MXFGPT),DODIPO(MXFGPT),DOQUAD(MXFGPT),
     *                DOOCTU(MXFGPT)
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NAT(MXDFG),NUM(MXDFG),NTPATM
      COMMON /EFPFRC/ IFRCPNT,NTFRCPN,NFRCPNT(MXFRG),LSTFPTS(MXFRG),
     *                FRCCRD(3,MXFGPT),FRCNME(MXFGPT),FRCTRQ(6,MXFGPT)
     *                ,FRCTRQX(6,MXFGPT)
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ*MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGLJP/ CORDLJ(3,MXPT),ELJCRD(3,MXFGPT),
     *                POTLJ(2,MXPT),ELJPOT(2,MXFGPT),
     *                LJNAME(MXPT),ELJNAM(MXFGPT),
     *                NLJPTS(MXFRG),NLJTTPT,ILJP,NMLJ(2)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /REPPAR/ CREP(3,MXFGPT),CLPR(4*MXFGPT),ZLPR(4*MXFGPT),
     *                NLPR(4*MXFGPT),KFR(MXFGPT),KLR(MXFGPT),
     *                REPNAM(MXFGPT)
      COMMON /EFPSCR/ POLAB(MXFRG),B,SCROFF,IELECS,IDISPS,NEW_POL
C
C     ----- WRITE INFORMATION DEFINING ALL FRAGMENTS -----
C
      IF (.NOT.MASWRK) RETURN
C
      WRITE(IW,9040)
      WRITE(IW,9042)
      DO I=1,NMTTPT
         WRITE(IW,9043) FRGNME(I),(EFC(J,I), J=1,3),EFCHG(1,I),
     *                  EFCHG(2,I)
      ENDDO
C
      IF(ILJP.EQ.0 .AND. NLJTTPT.EQ.0)THEN
      WRITE(IW,9045) ICHGP,MOD(ICHGP,2),INT(ICHGP/2.0D+00)
      WRITE(IW,9046)
      DO I=1,NMTTPT
         WRITE(IW,9047) FRGNME(I),EFBTRM(I),EFATRM(I),
     *                           EFBTRM2(I),EFATRM2(I)
      ENDDO
      END IF
C
C   --- LVS: IMFORMATION ABOUT POLARIZATION SCREENING
      IF (IPLSCR .EQ. 1) THEN
         WRITE(IW,9050) 'ON'
         WRITE(IW,9054)
         DO I=1,NPTTPT
            WRITE(IW,9052) POLNAM(I),POLSCR(I)
         ENDDO
      ELSE
         WRITE(IW,9050) 'OFF'
      END IF
C
      IF (NEW_POL .EQ. 1) THEN
         WRITE(IW,9053) 'ON'
         WRITE(IW,9054)
         DO I=1,NDFRG
            WRITE(IW,9055) FRGNAM(NAMIDX(I)), POLAB(I)
         ENDDO
      ELSE
         WRITE(IW,9053) 'OFF'
      END IF
C
      DODIP = .FALSE.
      DOQUA = .FALSE.
      DOOCT = .FALSE.
      DO I=1,NMTTPT
         DODIP = DODIP .OR. DODIPO(I)
         DOQUA = DOQUA .OR. DOQUAD(I)
         DOOCT = DOOCT .OR. DOOCTU(I)
      ENDDO
C
      IF (DODIP .OR. DOQUA) THEN
         WRITE(IW,9060)
         WRITE(IW,9065)
      END IF
      DO 610 I=1,NMTTPT
         IF(DODIPO(I) .AND. DOQUAD(I)) THEN
         WRITE(IW,9070) FRGNME(I),(EFDIP(J,I),J=1,3),(EFQAD(J,I),J=1,6)
         ELSE IF(DODIPO(I) .AND. .NOT.DOQUAD(I)) THEN
            WRITE(IW,9073) FRGNME(I),(EFDIP(J,I),J=1,3)
         ELSE IF(.NOT.DODIPO(I) .AND. DOQUAD(I)) THEN
            WRITE(IW,9075) FRGNME(I),(EFQAD(J,I),J=1,6)
         END IF
  610 CONTINUE
C
      IF (DOOCT) THEN
         WRITE(IW,9080)
         WRITE(IW,9085)
      END IF
      DO 620 I=1,NMTTPT
         IF(DOOCTU(I)) WRITE(IW,9090) FRGNME(I), (EFOCT(J,I),J=1,10)
  620 CONTINUE
C
C  PRINT INFO ON FORCE POINTS
C
      IF (NTFRCPN.GT.0) THEN
         WRITE(IW,9095)
         DO I=1,NTFRCPN
           WRITE(IW,9096) FRCNME(I),(FRCCRD(J,I),J=1,3)
         END DO
      END IF
C
C  PRINT OUT POLARIZABLE POINT-INFORMATION
C
      IF (NPTTPT.GT.0) THEN
         WRITE(IW,9100)
         WRITE(IW,9105)
      END IF
      DO 630 I=1,NPTTPT
         WRITE(IW,9110) POLNAM(I),(EFP(J,I),J=1,3),(EFPOL(J,I),J=1,9)
  630 CONTINUE
C
C  PRINT OUT DYNAMIC POLARIZABLE POINT-INFORMATION
C
      IF (NDPTTPT.GT.0) THEN
         WRITE(IW,9101)
         WRITE(IW,9105)
      END IF
      DO 631 I=1,NDPTTPT
         WRITE(IW,9110) DPOLNAM(I),(EFDP(J,I),J=1,3),(EFDPOL(J,I),J=1,9)
  631 CONTINUE
C
C      IF(IEFMORUN.GT.0) RETURN
C
C  PRINT OUT LENNARD-JONES POINTS
C
      IF (ILJP.EQ.1 .AND. NLJTTPT.GT.0) THEN
        WRITE(IW,9120)NMLJ(1),NMLJ(2)
      END IF
      DO I=1,NLJTTPT
        WRITE(IW,9121)ELJNAM(I),(ELJCRD(J,I),J=1,3),(ELJPOT(J,I),J=1,2)
      ENDDO
C
C         AB INITIO-FRAGMENT REPULSION TERM
C
      IF (NRTTPT.GT.0) THEN
         WRITE(IW,9130)
         WRITE(IW,9140)
      END IF
      DO 650 I=1,NRTTPT
         IFF = KFR(I)
         ISS = KLR(I)
        WRITE(IW,9150) REPNAM(I),(CREP(L,I),L=1,3),(CLPR(II),NLPR(II)-2,
     *                  ZLPR(II), II=IFF,ISS)
  650 CONTINUE
C
C       NEW PAULI REPULSION PARAMETERS
C
      IF (NTMO.GT.0) WRITE(IW,9400)
      IF (NTMO.GT.0) WRITE(IW,9410)
      NMAX = MAX(NTMO,NTPATM)
      NMIN = MIN(NTMO,NTPATM)
      DO I = 1,NMAX
         IF (I.LE.NMIN) THEN
            WRITE(IW,9420) PRNAME(I),(PRCORD(J,I),J=1,3),CENTNM(I),
     *                     (CENTCD(J,I),J=1,3)
         ELSEIF (I.GT.NTPATM) THEN
            WRITE(IW,9430) CENTNM(I),(CENTCD(J,I),J=1,3)
         ELSEIF (I.GT.NTMO) THEN
            WRITE(IW,9440) PRNAME(I),(PRCORD(J,I),J=1,3)
         END IF
      END DO
C
C         FRAGMENT-FRAGMENT REPULSION TERM
C
      IF(NFRG.EQ.1 .OR. NTMO.GT.0 .OR. ILJP.EQ.1) RETURN
C
      IJ=0
      WRITE(IW,9200) NDFRG,NDFG2
      NSHFTI=0
      DO 740 I=1,NDFRG
         NSHFTJ=0
         DO 730 J=1,I
            IJ=IJ+1
            WRITE(IW,9210) FRGNAM(NAMIDX(I)),FRGNAM(NAMIDX(J))
            KMAXR = NRPTS(NAMIDX(I))+1
            LMAXR = NRPTS(NAMIDX(J))+1
            DO 720 K=1,KMAXR
               IF(K.EQ.KMAXR) THEN
                  KNAME = 'CENTER  '
               ELSE
                  KNAME = REPNAM(NSHFTI+K)
               END IF
               DO 710 L=1,LMAXR
                  IF(L.EQ.LMAXR) THEN
                     LNAME = 'CENTER  '
                  ELSE
                     LNAME = REPNAM(NSHFTJ+L)
                  END IF
                  WRITE(IW,9220) KNAME,LNAME,CREL(K,L,IJ),AREL(K,L,IJ)
C-BIEXP- WRITE(IW,*) KNAME,LNAME,CREL(K,L,IJ+NDFRG2),AREL(K,L,IJ+NDFRG2)
  710          CONTINUE
  720       CONTINUE
            NSHFTJ=NSHFTJ+NRPTS(J)
  730    CONTINUE
         NSHFTI=NSHFTI+NRPTS(I)
  740 CONTINUE
C
      RETURN
C
 9040 FORMAT(/12X,'MULTIPOLE COORDINATES, ELECTRONIC AND NUCLEAR',
     *            ' CHARGES')
 9042 FORMAT(/18X,'X',14X,'Y',14X,'Z',10X,' ELEC. ',2X,'NUC.')
 9043 FORMAT(1X,A8,3F15.10,F11.5,F7.1)
 9045 FORMAT(/3X,'CHARGE SCREENING PARAMETERS (COEF AND ZETA)'/
     *        3X,'ICHGP=',I4,' AI-FRAGMENT SCREENING=',I2,
     *        3X,'FRAGMENT-FRAGMENT SCREENING=',I2)
 9046 FORMAT(/13X,'GAUSSIAN DAMPING',4X,'EXPONENTIAL DAMPING')
 9047 FORMAT(1X,A8,2F10.5,3X,2F10.5)
 9050 FORMAT(/3X,'SCREENING FOR POLARIZATION WITH EXPONENTIAL ',
     *           'FORMULA ',A4)
 9052 FORMAT(1X,A8,F10.5)
 9053 FORMAT(/3X,'SCREENING FOR POLARIZATION WITH TANG-TOENNIS ',
     *            'FORMULA ',A4)
 9054 FORMAT(/3X,' WITH COEFFICIENTS ')
 9055 FORMAT(/3X,A8,F6.2)
 9060 FORMAT(/18X,'DIPOLE MOMENTS AND THE SECOND MOMENT TENSOR')
 9065 FORMAT(/18X,'X',8X,'Y',8X,'Z',11X,'XX/XY',4X,'YY/XZ',4X,'ZZ/YZ')
 9070 FORMAT(1X,A8,4X,3F9.5,4X,3F9.5/44X,3F9.5)
 9073 FORMAT(1X,A8,4X,3F9.5)
 9075 FORMAT(1X,A8,35X,6F9.5)
 9080 FORMAT(/18X,'THE THIRD MOMENT TENSOR')
 9085 FORMAT(/15X,'XXX/XYY',2X,'YYY/YYZ',2X,'ZZZ/XZZ',2X,'XXY/YZZ',
     *         2X,'XXZ/XYZ')
 9090 FORMAT(1X,A8,4X,5F9.5/13X,5F9.5)
 9095 FORMAT(/18X,'FORCE POINTS')
 9096 FORMAT(1X,A8,4X,3F12.6)
 9100 FORMAT(/18X,'POLARIZABLE POINTS AND THE POLARIZABILITY TENSOR')
 9101 FORMAT(/18X,'DYNAMIC POLARIZABLE POINTS AND DYNAMIC TENSOR')
 9105 FORMAT(/14X,'X',7X,'Y',7X,'Z',7X,'XX/YZ',4X,'YY/YX',4X,
     *                                 'ZZ/ZX',4X,'XY/ZY',5X,'XZ')
 9110 FORMAT(1X,A8,3F8.4,1X,5F9.5/34X,4F9.5)
 9120 FORMAT(/20X,30(1H-)/
     *        20X,' LENNARD-JONES ',I2,'-',I1,' POTENTIAL '/
     *        20X,30(1H-)/
     *        17X,'X',11X,'Y',11X,'Z',10X,'SIGMA      EPSILON'/)
 9121 FORMAT(1X,A8,3F12.5,2X,2F12.7)
 9130 FORMAT(/20X,14(1H-),21X,18(1H-)/
     *        20X,'  REP POINTS  ',21X,'  REP PARAMETERS  '/
     *        20X,14(1H-),21X,18(1H-))
 9140 FORMAT(/16X,'X',9X,'Y',9X,'Z',15X,'COEF',7X,'N',10X,'ZETA'/)
 9150 FORMAT(2X,A8,3(1X,F9.5),5X,2X,F9.5,6X,I2,5X,F9.5,
     1                        (/47X,F9.5,6X,I2,5X,F9.5))
 9200 FORMAT(/1X,'THERE ARE',I4,' FRAGMENT TYPES, AND',I4,
     *            ' FRAGMENT-FRAGMENT INTERACTIONS.')
 9210 FORMAT(/1X,'REPULSIVE FIT FOR FRAGMENT PAIR ',A6,'-',A6,
     *           ' (COEF,EXPONENT)')
 9220 FORMAT(1X,A8,'-',A8,3X,F12.8,2X,F12.8)
 9400 FORMAT(/1X,18X,' AO EXPANSION POINTS',29X,'LMO CENTROIDS')
 9410 FORMAT(/,10X,6X,'X',10X,'Y',10X,'Z',25X,'X',10X,'Y',
     1        10X,'Z'/)
 9420 FORMAT(2X,A8,3(2X,F9.5),5X,2X,A8,3(2X,F9.5))
 9430 FORMAT(50X,A8,3(2X,F9.5))
 9440 FORMAT(2X,A8,3(2X,F9.5))
      END
C*MODULE EFINP   *DECK RDCRDX
      SUBROUTINE RDCRDX(CORD,EX1,EX2,NAME,NPTS,IFRAG)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      PARAMETER (MXPT=2000)
C
      CHARACTER*8 NAME
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION CORD(3,MXPT), NAME(MXPT), EX1(MXPT), EX2(MXPT)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      IERR = 0
      IEOF = 0
      NPTS = 0
  100 CONTINUE
      I = NPTS+1
      IF(I.GT.MXPT) THEN
         IF(MASWRK) WRITE(IW,9000) IFRAG,MXPT
         CALL ABRT
      END IF
C
      CALL RDCARD('RDCRDX  ',IEOF)
      IF(IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,*) 'END OF FILE READING FRAGMENT COORDS'
         CALL ABRT
      END IF
C
      NAME(I)='        '
      LGSTR=-8
      CALL GSTRNG(NAME(I),LGSTR)
      IF(NAME(I).EQ.'STOP    ') GO TO 200
C
      CORD(1,I) = RFIND('XCORD   ',IERR)
      IF(IERR.NE.0) THEN
         IF(MASWRK) WRITE(IW,*) 'RDCRDX: ERROR READING X COORD'
         CALL ABRT
      END IF
C
      CORD(2,I) = RFIND('YCORD   ',IERR)
      IF(IERR.NE.0) THEN
         IF(MASWRK) WRITE(IW,*) 'RDCRDX: ERROR READING Y COORD'
         CALL ABRT
      END IF
C
      CORD(3,I) = RFIND('ZCORD   ',IERR)
      IF(IERR.NE.0) THEN
         IF(MASWRK) WRITE(IW,*) 'RDCRDX: ERROR READING Z COORD'
         CALL ABRT
      END IF
C
      EX1(I) = RFIND('EX1     ',IERR)
      IF(IERR.NE.0) THEN
         IF(MASWRK) WRITE(IW,*) 'RDCRDX: ERROR READING EX1'
         CALL ABRT
      END IF
C
      EX2(I) = RFIND('EX2     ',IERR)
      IF(IERR.NE.0) THEN
         IF(MASWRK) WRITE(IW,*) 'RDCRDX: ERROR READING EX2'
         CALL ABRT
      END IF
C
      NPTS = NPTS + 1
      GO TO 100
C
  200 CONTINUE
      RETURN
 9000 FORMAT(1X,'ERROR IN READING COORDINATES OF FRAGMENT',I4,
     *          ' EXCEEDED MXPT=',I5)
      END
C*MODULE EFINP   *DECK RDFGRP
      SUBROUTINE RDFGRP(AREL,CREL,MXRPTS,NDFRG2)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      DIMENSION AREL(MXRPTS,MXRPTS,NDFRG2),CREL(MXRPTS,MXRPTS,NDFRG2)
C
      PARAMETER (MXFRG=1050, MXFGPT=12000, MXDFG=5,
     *           MXDPPT=MXFRG*MXDFG*12)
C
      CHARACTER*8 WORD,PTNAM,NAME1,NAME2,CENTER,CHAR,REPNAM
      CHARACTER*6 FRGNAM,FRG1,FRG2
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /REPPAR/ CREP(3,MXFGPT),CLPR(4*MXFGPT),ZLPR(4*MXFGPT),
     *                NLPR(4*MXFGPT),KFR(MXFGPT),KLR(MXFGPT),
     *                REPNAM(MXFGPT)
C
      EXTERNAL REREAD
C
C         --- READ INTERFRAGMENT REPULSIVE POTENTIAL FIT ---
C
      IF (NFRG.EQ.1) RETURN
C
      LEN=MXRPTS*MXRPTS*NDFRG2
      CALL VCLR(AREL,1,LEN)
      CALL VCLR(CREL,1,LEN)
C
C     READ IN $FRGRPL
C
      CALL SEQREW(IR)
      IF(MASWRK) WRITE(IW,9000)
      CALL FNDGRP(IR,' $FRGRPL',IEOF)
      IF(IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,*) 'ERROR: UNABLE TO FIND $FRGRPL GROUP'
         CALL ABRT
      END IF
      CENTER='CENTER  '
      IERR=0
C
   90 CALL RDCARD('$FRGRPL1',IEOF)
      IF(IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,*) 'END OF FILE READING $FRGRPL GROUP'
         CALL ABRT
      END IF
C
      WORD='        '
      LGSTR=-8
      CALL GSTRNG(WORD,LGSTR)
      IF(WORD.EQ.'$END    ') GO TO 900
C
C     READ IN NAMES OF PAIRED FRAGMENTS
C
      FRG1='      '
      FRG2='      '
      LGSTR=-6
      CALL GSTRNG(FRG1,LGSTR)
      CALL GSTRNG(FRG2,LGSTR)
      DO 100 I=1,NDFRG
         IF (FRG1.EQ.FRGNAM(NAMIDX(I))) THEN
            INDX1=I
            GO TO 110
         END IF
  100 CONTINUE
      IF(MASWRK) WRITE(IW,9010) FRG1
      CALL ABRT
C
  110 DO 120 I=1,NDFRG
         IF (FRG2.EQ.FRGNAM(NAMIDX(I))) THEN
            INDX2=I
            GO TO 130
         END IF
  120 CONTINUE
      IF(MASWRK) WRITE(IW,9010) FRG2
      CALL ABRT
C
  130 CONTINUE
      IF (INDX2.LE.INDX1) THEN
         NFIDX=(INDX1-1)*INDX1/2+INDX2
      ELSE
         NFIDX=(INDX2-1)*INDX2/2+INDX1
      END IF
      NSHFT1=0
      DO 140 I=1,INDX1-1
         NSHFT1=NSHFT1+NRPTS(I)
  140 CONTINUE
      NSHFT2=0
      DO 150 I=1,INDX2-1
         NSHFT2=NSHFT2+NRPTS(I)
  150 CONTINUE
C
C        LOOP OVER READING REPULSION BETWEEN A PAIR OF REPULSIVE PTS
C
  155 CONTINUE
      CALL RDCARD('$FRGRPL2',IEOF)
      IF(IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,*)
     *      'END OF FILE READING FRAGMENT PAIR REPULSIONS'
         CALL ABRT
      END IF
      NAME1='        '
      NAME2='        '
      LGSTR=-8
      CALL GSTRNG(NAME1,LGSTR)
      IF(NAME1.EQ.'STOP    ') GO TO 90
      CALL GSTRNG(NAME2,LGSTR)
C
      DO 160 I=1,NRPTS(INDX1)
         IF (NAME1.EQ.REPNAM(NSHFT1+I)) THEN
            IDXN1=I
            GO TO 170
         END IF
  160 CONTINUE
      IF (NAME1.EQ.CENTER) THEN
         IDXN1=NRPTS(INDX1)+1
         GO TO 170
      END IF
      IF(MASWRK) WRITE(IW,9020) NAME1,FRG1
      CALL ABRT
C
  170 CONTINUE
      DO 180 I=1,NRPTS(INDX2)
         IF (NAME2.EQ.REPNAM(NSHFT2+I)) THEN
            IDXN2=I
            GO TO 190
         END IF
  180 CONTINUE
      IF (NAME2.EQ.CENTER) THEN
         IDXN2=NRPTS(INDX2)+1
         GO TO 190
      END IF
      IF(MASWRK) WRITE(IW,9020) NAME2,FRG2
      CALL ABRT
C
C         THE CODE PERMITS USE OF A BIEXPONENTIAL EXPANSION
C         OF THE INTER-FRAGMENT REPULSION, BUT THE EFPS IN
C         USE READ IN ONLY A SINGLE EXPONENTIAL.  THEREFORE
C         ONLY THE FIRST EXPONENTIAL IS DOCUMENTED, AND THE
C         CODE FOR THE 2ND EXPONENTIAL IS COMMENTED OUT.
C
C         THE ERROR CHECK SHOULD NEVER FAIL, HOPEFULLY.
C
  190 CONTINUE
      IF(IDXN1.GT.MXRPTS .OR. IDXN2.GT.MXRPTS) THEN
         IF(MASWRK) WRITE(IW,9030) IDXN1,IDXN2,MXRPTS
         CALL ABRT
      END IF
C
      CHAR='        '
      LENGTH=0
      CALL GSTRNG(CHAR,LENGTH)
      IF(LENGTH.GT.0) GO TO 200
C
      CALL REREAD
      IF (INDX1.GE.INDX2) THEN
         CREL(IDXN1,IDXN2,NFIDX)=RFIND('CREL    ',IERR)
         IF(IERR.NE.0) THEN
            IF(MASWRK) WRITE(IW,*) 'RDFGRP: ERROR READING CREL'
            CALL ABRT
         END IF
         AREL(IDXN1,IDXN2,NFIDX)=RFIND('AREL    ',IERR)
         IF(IERR.NE.0) THEN
            IF(MASWRK) WRITE(IW,*) 'RDFGRP: ERROR READING AREL'
            CALL ABRT
         END IF
C-BIEXP- CREL(IDXN1,IDXN2,NFIDX+NDFRG2)=RFIND('CREL    ',IERR)
C-BIEXP- IF(IERR.NE.0) CALL ABRT
C-BIEXP- AREL(IDXN1,IDXN2,NFIDX+NDFRG2)=RFIND('AREL    ',IERR)
C-BIEXP- IF(IERR.NE.0) CALL ABRT
      ELSE
         CREL(IDXN2,IDXN1,NFIDX)=RFIND('CREL    ',IERR)
         IF(IERR.NE.0) THEN
            IF(MASWRK) WRITE(IW,*) 'RDFGRP: ERROR READING CREL'
            CALL ABRT
         END IF
         AREL(IDXN2,IDXN1,NFIDX)=RFIND('AREL    ',IERR)
         IF(IERR.NE.0) THEN
            IF(MASWRK) WRITE(IW,*) 'RDFGRP: ERROR READING AREL'
            CALL ABRT
         END IF
C-BIEXP- CREL(IDXN2,IDXN1,NFIDX+NDFRG2)=RFIND('CREL    ',IERR)
C-BIEXP- IF(IERR.NE.0) CALL ABRT
C-BIEXP- AREL(IDXN2,IDXN1,NFIDX+NDFRG2)=RFIND('AREL    ',IERR)
C-BIEXP- IF(IERR.NE.0) CALL ABRT
      END IF
      GO TO 155
C
  200 CONTINUE
      NAME1='        '
      NAME2='        '
      LGSTR=-8
      CALL GSTRNG(NAME1,LGSTR)
      CALL GSTRNG(NAME2,LGSTR)
      DO 210 I=1,NRPTS(INDX1)
         IF (NAME1.EQ.REPNAM(NSHFT1+I)) THEN
            IDXN3=I
            GO TO 220
         END IF
  210 CONTINUE
      IF (NAME1.EQ.CENTER) THEN
         IDXN3=NRPTS(INDX1)+1
         GO TO 220
      END IF
      IF(MASWRK) WRITE(IW,9020) NAME1,FRG1
C
  220 DO 230 I=1,NRPTS(INDX1)
         IF (NAME2.EQ.REPNAM(NSHFT2+I)) THEN
            IDXN4=I
            GO TO 240
         END IF
  230 CONTINUE
      IF (NAME2.EQ.CENTER) THEN
         IDXN4=NRPTS(INDX2)+1
         GO TO 240
      END IF
      IF(MASWRK) WRITE(IW,9020) NAME2,FRG2
      IF(IERR.NE.0) CALL ABRT
C
  240 IF (INDX1.GE.INDX2) THEN
         CREL(IDXN1,IDXN2,NFIDX)=CREL(IDXN3,IDXN4,NFIDX)
         AREL(IDXN1,IDXN2,NFIDX)=AREL(IDXN3,IDXN4,NFIDX)
C-BIEXP- CREL(IDXN1,IDXN2,NFIDX+NDFRG2)=CREL(IDXN3,IDXN4,NFIDX+NDFRG2)
C-BIEXP- AREL(IDXN1,IDXN2,NFIDX+NDFRG2)=AREL(IDXN3,IDXN4,NFIDX+NDFRG2)
      ELSE
         CREL(IDXN2,IDXN1,NFIDX)=CREL(IDXN4,IDXN3,NFIDX)
         AREL(IDXN2,IDXN1,NFIDX)=AREL(IDXN4,IDXN3,NFIDX)
C-BIEXP- CREL(IDXN2,IDXN1,NFIDX+NDFRG2)=CREL(IDXN4,IDXN3,NFIDX+NDFRG2)
C-BIEXP- AREL(IDXN2,IDXN1,NFIDX+NDFRG2)=AREL(IDXN4,IDXN3,NFIDX+NDFRG2)
      END IF
      GO TO 155
C
  900 CONTINUE
      RETURN
C
 9000 FORMAT(1X,'READING INTER-FRAGMENT REPULSION $FRGRPL...')
 9010 FORMAT(1X,'ERROR...FRAGMENT NAME USED IN $FRGRPL=',A6/
     *       1X,'DOES NOT MATCH ANY KNOWN FRAGMENT NAME.')
 9020 FORMAT(1X,'ERROR...REPULSIVE POINT USED IN $FRGRPL=',A8/
     *   1X,'DOES NOT MATCH ANY REPULSIVE POINT NAME IN FRAGMENT ',A8)
 9030 FORMAT(1X,'CONFUSION IN RDFGRP: IDXN1,IDXN2=',2I5,
     *          ' EXCEEDS MXRPTS=',I5)
      END
C
C*MODULE EFINP   *DECK RDFGDP
      SUBROUTINE RDFGDP(AREL,DREL,CREL,MXDPTS,NDFRG2,LC)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      DIMENSION AREL(MXDPTS,MXDPTS,NDFRG2),CREL(MXDPTS,MXDPTS,NDFRG2)
      DIMENSION DREL(MXDPTS,MXDPTS,NDFRG2)
C
      PARAMETER (MXPT=2000, MXFRG=1050, MXFGPT=12000,
     *           MXDFG=5,
     *           MXDPPT=MXFRG*MXDFG*12)
C
      CHARACTER*8 WORD,PTNAM,NAME1,NAME2,CENTER,CHAR,DNAME,DPSNAM
      CHARACTER*6 FRGNAM,FRG1,FRG2
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
C
      COMMON /POL2  / DCORD(3,MXPT),CDIS(3,MXFGPT),
     *                CLPD(4*MXFGPT),ZLPD(4*MXFGPT),
     *                NLPD(4*MXFGPT),KFD(MXFGPT),KLD(MXFGPT),
     *                DNAME(MXPT),DPSNAM(MXFGPT)
C
      EXTERNAL REREAD
C
C         --- READ INTERFRAGMENT DISPERSION POTENTIAL FIT ---
C
      IF (NFRG.EQ.1) RETURN
C
      LEN=MXDPTS*MXDPTS*NDFRG2
C
C     C6*(1-A*E^(-B*R))/R^6
C
C     CREL: C6 OR C8
C     DREL: A
C     AREL: B
C
      CALL VCLR(AREL,1,LEN)
      CALL VCLR(CREL,1,LEN)
      CALL VCLR(DREL,1,LEN)
C
C     READ IN $FRGDPS
C
      CALL SEQREW(IR)
      IF(LC.EQ.0) THEN
        IF(MASWRK) WRITE(IW,9000) '$FRGDPS'
        CALL FNDGRP(IR,' $FRGDPS',IEOF)
        IF(IEOF.EQ.1) THEN
          IF(MASWRK) WRITE(IW,*) 'ERROR: UNABLE TO FIND $FRGDPS GROUP'
          CALL ABRT
        END IF
      END IF
      IF(LC.EQ.1) THEN
        IF(MASWRK) WRITE(IW,9000) '$FRGDP8'
        CALL FNDGRP(IR,' $FRGDP8',IEOF)
        IF(IEOF.EQ.1) THEN
          IF(MASWRK) WRITE(IW,*) 'ERROR: UNABLE TO FIND $FRGDP8 GROUP'
          CALL ABRT
        END IF
      END IF
      CENTER='CENTER  '
      IERR=0
C
   90 CALL RDCARD('$FRGDPS1',IEOF)
      IF(IEOF.EQ.1) CALL ABRT
C
      WORD='        '
      LGSTR=-8
      CALL GSTRNG(WORD,LGSTR)
      IF(WORD.EQ.'$END    ') GO TO 900
C
C     READ IN NAMES OF PAIRED FRAGMENTS
C
      FRG1='      '
      FRG2='      '
      LGSTR=-6
      CALL GSTRNG(FRG1,LGSTR)
      CALL GSTRNG(FRG2,LGSTR)
      DO 100 I=1,NDFRG
         IF (FRG1.EQ.FRGNAM(NAMIDX(I))) THEN
            INDX1=I
            GO TO 110
         END IF
  100 CONTINUE
      IF(MASWRK) WRITE(IW,9010) FRG1
      CALL ABRT
C
  110 DO 120 I=1,NDFRG
         IF (FRG2.EQ.FRGNAM(NAMIDX(I))) THEN
            INDX2=I
            GO TO 130
         END IF
  120 CONTINUE
      IF(MASWRK) WRITE(IW,9010) FRG2
      CALL ABRT
C
  130 CONTINUE
      IF (INDX2.LE.INDX1) THEN
         NFIDX=(INDX1-1)*INDX1/2+INDX2
      ELSE
         NFIDX=(INDX2-1)*INDX2/2+INDX1
      END IF
      NSHFT1=0
      DO 140 I=1,INDX1-1
         NSHFT1=NSHFT1+NDPTS(I)
  140 CONTINUE
      NSHFT2=0
      DO 150 I=1,INDX2-1
         NSHFT2=NSHFT2+NDPTS(I)
  150 CONTINUE
C
C        LOOP OVER READING DISPERSION BETWEEN A PAIR OF DISP PTS
C
  155 CONTINUE
      CALL RDCARD('$FRGDPS2',IEOF)
      IF(IEOF.EQ.1) CALL ABRT
      NAME1='        '
      NAME2='        '
      LGSTR=-8
      CALL GSTRNG(NAME1,LGSTR)
      IF(NAME1.EQ.'STOP    ') GO TO 90
      CALL GSTRNG(NAME2,LGSTR)
C
      DO 160 I=1,NDPTS(INDX1)
        IF (NAME1.EQ.DPSNAM(NSHFT1+I)) THEN
           IDXN1=I
           GO TO 170
        END IF
  160 CONTINUE
      IF (NAME1.EQ.CENTER) THEN
         IDXN1=NDPTS(INDX1)+1
         GO TO 170
      END IF
      IF(MASWRK) WRITE(IW,9020) NAME1,FRG1
      CALL ABRT
C
  170 CONTINUE
      DO 180 I=1,NDPTS(INDX2)
         IF (NAME2.EQ.DPSNAM(NSHFT2+I)) THEN
            IDXN2=I
            GO TO 190
         END IF
  180 CONTINUE
      IF (NAME2.EQ.CENTER) THEN
         IDXN2=NDPTS(INDX2)+1
         GO TO 190
      END IF
      IF(MASWRK) WRITE(IW,9020) NAME2,FRG2
      CALL ABRT
C
C         THE CODE PERMITS USE OF A BIEXPONENTIAL EXPANSION
C         OF THE INTER-FRAGMENT DISPERSION, BUT THE EFPS IN
C         USE READ IN ONLY A SINGLE EXPONENTIAL.  THEREFORE
C         ONLY THE FIRST EXPONENTIAL IS DOCUMENTED, AND THE
C         CODE FOR THE 2ND EXPONENTIAL IS COMMENTED OUT.
C
C         THE ERROR CHECK SHOULD NEVER FAIL, HOPEFULLY.
C
  190 CONTINUE
      IF(IDXN1.GT.MXDPTS .OR. IDXN2.GT.MXDPTS) THEN
         IF(MASWRK) WRITE(IW,9030) IDXN1,IDXN2,MXDPTS
         CALL ABRT
      END IF
C
      CHAR='        '
      LENGTH=0
      CALL GSTRNG(CHAR,LENGTH)
      IF(LENGTH.GT.0) GO TO 200
C
      CALL REREAD
      IF (INDX1.GE.INDX2) THEN
         CREL(IDXN1,IDXN2,NFIDX)=RFIND('CREL    ',IERR)
         IF(IERR.NE.0) CALL ABRT
         DREL(IDXN1,IDXN2,NFIDX)=RFIND('DREL    ',IERR)
         IF(IERR.NE.0) CALL ABRT
         AREL(IDXN1,IDXN2,NFIDX)=RFIND('AREL    ',IERR)
         IF(IERR.NE.0) CALL ABRT
      ELSE
         CREL(IDXN2,IDXN1,NFIDX)=RFIND('CREL    ',IERR)
         IF(IERR.NE.0) CALL ABRT
         DREL(IDXN2,IDXN1,NFIDX)=RFIND('DREL    ',IERR)
         IF(IERR.NE.0) CALL ABRT
         AREL(IDXN2,IDXN1,NFIDX)=RFIND('AREL    ',IERR)
         IF(IERR.NE.0) CALL ABRT
      END IF
      GO TO 155
C
  200 CONTINUE
      NAME1='        '
      NAME2='        '
      LGSTR=-8
      CALL GSTRNG(NAME1,LGSTR)
      CALL GSTRNG(NAME2,LGSTR)
      DO 210 I=1,NDPTS(INDX1)
         IF (NAME1.EQ.DPSNAM(NSHFT1+I)) THEN
            IDXN3=I
            GO TO 220
         END IF
  210 CONTINUE
      IF (NAME1.EQ.CENTER) THEN
         IDXN3=NDPTS(INDX1)+1
         GO TO 220
      END IF
      IF(MASWRK) WRITE(IW,9020) NAME1,FRG1
C
  220 DO 230 I=1,NDPTS(INDX1)
         IF (NAME2.EQ.DPSNAM(NSHFT2+I)) THEN
            IDXN4=I
            GO TO 240
         END IF
  230 CONTINUE
      IF (NAME2.EQ.CENTER) THEN
         IDXN4=NDPTS(INDX2)+1
         GO TO 240
      END IF
      IF(MASWRK) WRITE(IW,9020) NAME2,FRG2
      IF(IERR.NE.0) CALL ABRT
C
  240 IF (INDX1.GE.INDX2) THEN
         CREL(IDXN1,IDXN2,NFIDX)=CREL(IDXN3,IDXN4,NFIDX)
         DREL(IDXN1,IDXN2,NFIDX)=DREL(IDXN3,IDXN4,NFIDX)
         AREL(IDXN1,IDXN2,NFIDX)=AREL(IDXN3,IDXN4,NFIDX)
      ELSE
         CREL(IDXN2,IDXN1,NFIDX)=CREL(IDXN4,IDXN3,NFIDX)
         DREL(IDXN1,IDXN2,NFIDX)=DREL(IDXN3,IDXN4,NFIDX)
         AREL(IDXN2,IDXN1,NFIDX)=AREL(IDXN4,IDXN3,NFIDX)
      END IF
      GO TO 155
C
  900 CONTINUE
      RETURN
C
 9000 FORMAT(1X,'READING INTER-FRAGMENT DISPERSION ',A7,'...')
 9010 FORMAT(1X,'ERROR...FRAGMENT NAME USED IN $FRGDPS=',A6/
     *       1X,'DOES NOT MATCH ANY KNOWN FRAGMENT NAME.')
 9020 FORMAT(1X,'ERROR...DISPERSION POINT USED IN $FRGDPS=',A8/
     *   1X,'DOES NOT MATCH ANY DISPERSION POINT NAME IN FRAGMENT ',A8)
 9030 FORMAT(1X,'CONFUSION IN RDFGDP: IDXN1,IDXN2=',2I5,
     *          ' EXCEEDS MXDPTS=',I5)
      END
C
C*MODULE EFINP   *DECK RDFRG
      SUBROUTINE RDFRG(IUNTRD,IFRG,STOP)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL STOP
C
      PARAMETER (MXFRG=1050, MXDFG=5)
C
      PARAMETER (ONE=1.00D+00, UNITS=ONE/0.52917724924D+00)
C
      CHARACTER*8 WORD,PTNAM,JUNK
      CHARACTER*6 FRGNAM
C
      COMMON /KFINFO/ KATMS(MXFRG)
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ZERO=0.0D+00)
C
C         ---- READ FRAGMENT LOCATIONS USING CARTESIAN COORDINATES -----
C
      IF (IFRG.EQ.1) NDFRG=0
C
C           IUNTRD=1 MEANS ANGS, =0 MEANS BOHR
      FACT = ONE
      IF(IUNTRD.EQ.1) FACT=UNITS
C
C          ALL BUT THE FIRST FRAGMENT WILL HAVE ALREADY READ
C          THE -FRAGNAME- LINE, SEE THE BOTTOM OF THIS ROUTINE
C
      IERR=0
      IEOF=0
      IF(IFRG.EQ.1) CALL RDCARD('$EFRAG 1',IEOF)
      IF(IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,*)
     *   'END OF FILE READING FRAGMENT CARTESIAN COORDINATES IN $EFRAG'
         CALL ABRT
      END IF
C
C          H2OEF2 WAS THE 2ND RHF PARAMETERIZATION TO BE MADE,
C          IN OTHER WORDS, THAT 2 HAS NOTHING TO DO WITH THE
C          SECOND GENERATION POTENTIAL, KNOWN AS EFP2.
C          CHANGE H2OEF2 TO THE DOCUMENTED CURRENT NAME H2ORHF,
C          SO THE REST OF THIS CODE CAN TEST ONLY ONE NAME.
C
      WORD='        '
      LGSTR=-8
      CALL GSTRNG(WORD,LGSTR)
      IF(WORD.EQ.'$END    ') THEN
         STOP=.TRUE.
         IFRG = IFRG - 1
         RETURN
      END IF
      IF(WORD.NE.'FRAGNAME') THEN
         IF(MASWRK) WRITE(IW,9010) IFRG,WORD
         CALL ABRT
      END IF
      FRGNAM(IFRG)='      '
      LGSTR=-6
      CALL GSTRNG(FRGNAM(IFRG),LGSTR)
      IF(FRGNAM(IFRG).EQ.'H2OEF2') FRGNAM(IFRG)='H2ORHF'
      IF(MASWRK) WRITE(IW,9020) IFRG,FRGNAM(IFRG)
C
C        NUMBER OF ATOMS IS NEW INPUT FOR FLEXIBLE FRAGMENTS
      KATMS(IFRG)=IFIND('ATOMS   ',IERR)
      IF(KATMS(IFRG).EQ.0) KATMS(IFRG)=3
      IF(KATMS(IFRG).GT.50) THEN
         IF(MASWRK) WRITE(IW,*) 'ERROR: TOO MANY ATOMS IN THE EFP'
         CALL ABRT
      END IF
C
      DO 100 I=1,IFRG-1
         IF (FRGNAM(IFRG).EQ.FRGNAM(I)) THEN
            ISET(IFRG)=ISET(I)
            GO TO 120
         END IF
  100 CONTINUE
      NDFRG=NDFRG+1
      IF(NDFRG.GT.MXDFG) THEN
         IF(MASWRK) WRITE(IW,9030) MXDFG
         CALL ABRT
      END IF
      ISET(IFRG)=NDFRG
      NAMIDX(NDFRG)=IFRG
C
C         READ THE FIRST THREE ATOMS IN THE EFFECTIVE FRAGMENT
C
  120 CONTINUE
      DO 110 I=1,KATMS(IFRG)
        CALL RDCARD('$EFRAG 2',IEOF)
        PTNAM(I,IFRG)='        '
        LGSTR=-8
        CALL GSTRNG(PTNAM(I,IFRG),LGSTR)
        XCRD(I,IFRG)=RFIND('XCRD    ',IERR)*FACT
        IF(IERR.NE.0) THEN
           IF(MASWRK) WRITE(IW,*) 'ERROR READING X COORD'
           CALL ABRT
        END IF
        YCRD(I,IFRG)=RFIND('YCRD    ',IERR)*FACT
        IF(IERR.NE.0) THEN
           IF(MASWRK) WRITE(IW,*) 'ERROR READING Y COORD'
           CALL ABRT
        END IF
        ZCRD(I,IFRG)=RFIND('ZCRD    ',IERR)*FACT
        IF(IERR.NE.0) THEN
           IF(MASWRK) WRITE(IW,*) 'ERROR READING Z COORD'
           CALL ABRT
        END IF
        TEST        =RFIND('TEST    ',IERR)
        IF(TEST.NE.ZERO) THEN
           IF(MASWRK) WRITE(IW,9040) PTNAM(I,IFRG),FRGNAM(IFRG)
           CALL ABRT
        END IF
  110 CONTINUE
C
C       SKIP OVER ANY OTHER NUCLEI, BEYOND THE 3RD ATOM.
C       THE ADDITIONAL NUCLEI ARE NOT NEEDED TO POSITION THE
C       EFFECTIVE FRAGMENT, WHICH HAVE A RIGID GEOMETRY, BUT IT
C       IS HANDY TO ALLOW ALL THE ATOMS TO BE PRESENT IN $EFRAG.
C
C       WE JUST SKIP LINES UNTIL POSITIONED TO THE NEXT 'FRAGNAME'.
C
      JUNK='        '
      LGSTR=-8
  300 CONTINUE
         CALL RDCARD('$EFRAG 3',IEOF)
         IF(IEOF.EQ.1) THEN
            IF(MASWRK) WRITE(IW,*)
     *         'END-OF-FILE READING FRAGMENT COORDINATES IN $EFRAG'
            CALL ABRT
         END IF
         CALL GSTRNG(JUNK,LGSTR)
         IF(JUNK.EQ.'$END    ') GO TO 310
         IF(JUNK.EQ.'FRAGNAME') GO TO 310
      GO TO 300
C
C        ANOTHER -FRAGNAME- OR PERHAPS THE $END WAS FOUND, NOW
C        BACKUP UP OVER THAT KEYWORD SO WE CAN REREAD IT ON NEXT ENTRY.
C
  310 CONTINUE
      CALL REREAD
      RETURN
C
 9010 FORMAT(/1X,'ERROR...READING FRAGMENT',I4/
     *       1X,'EXPECTED KEYWORD "FRAGNAME", FOUND "',A8,'".')
 9020 FORMAT(1X,'READING COORDINATES OF FRAGMENT',I4,' NAMED ',A8)
 9030 FORMAT(1X,'ERROR...THERE ARE TOO MANY FRAGMENT TYPES IN USE'/
     *       1X,'INCREASE MAXIMUM FRAGMENT TYPE -MXDFG- FROM',I4)
 9040 FORMAT(/1X,'*** ERROR ***'/
     *        1X,'FOUND 4 COORDINATES FOR POINT ',A,' IN FRAGMENT ',A/
     *        1X,'CHECK TO SEE IF -ZNUC- WAS ACCIDENTALLY GIVEN.')
      END
C*MODULE EFINP   *DECK RDFRG2
      SUBROUTINE RDFRG2(IFRG,STOP)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL STOP
C
      PARAMETER (MXATM=2000, MXFRG=1050, MXDFG=5)
C
      PARAMETER (ONE=1.00D+00, UNITS=ONE/0.52917724924D+00)
      PARAMETER (PI=3.14159265359D+00, ONE80=180.0D+00)
C
      CHARACTER*8 WORD, PTNAM
      CHARACTER*6 FRGNAM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /KFINFO/ KATMS(MXFRG)
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C         ---- READ FRAGMENT LOCATIONS USING INTERNAL COORDINATES -----
C
      DIMENSION BL(3), ALPHA(3), BETA(3), V1(3), V2(3),
     *          VP(3), VJ(3), AL1(3), AL2(3), AL3(3), AL4(3), IZ(3,3)
C
      IF (IFRG.EQ.1) NDFRG=0
      IERR = 0
      IEOF = 0
      NATOMS = NAT
      CALL RDCARD('$EFRAG 1',IEOF)
      IF (IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,*) 'END OF FILE READING $EFRAG GROUP'
         CALL ABRT
      END IF
C
      WORD='        '
      LGSTR=-8
      CALL GSTRNG(WORD,LGSTR)
      IF (WORD.EQ.'$END   ') THEN
         STOP = .TRUE.
         IFRG = IFRG - 1
         RETURN
      END IF
      IF(WORD.NE.'FRAGNAME') THEN
         IF(MASWRK) WRITE(IW,9010) IFRG,WORD
         CALL ABRT
      END IF
      FRGNAM(IFRG)='      '
      LGSTR=-6
      CALL GSTRNG(FRGNAM(IFRG),LGSTR)
      IF(FRGNAM(IFRG).EQ.'H2OEF2') FRGNAM(IFRG)='H2ORHF'
      IF(MASWRK) WRITE(IW,9020) IFRG,FRGNAM(IFRG)
C
C        NUMBER OF ATOMS IS NEW INPUT FOR FLEXIBLE FRAGMENTS
      KATMS(IFRG)=IFIND('ATOMS   ',IERR)
      IF(KATMS(IFRG).EQ.0) KATMS(IFRG)=3
      IF(KATMS(IFRG).GT.50) THEN
         IF(MASWRK) WRITE(IW,*) 'ERROR: TOO MANY ATOMS IN THE EFP'
         CALL ABRT
      END IF
C
      DO 100 I=1,IFRG-1
         IF (FRGNAM(IFRG).EQ.FRGNAM(I)) THEN
            ISET(IFRG)=ISET(I)
            GO TO 120
         END IF
  100 CONTINUE
      NDFRG=NDFRG+1
      IF(NDFRG.GT.MXDFG) THEN
         IF(MASWRK) WRITE(IW,9030) MXDFG
         CALL ABRT
      END IF
      ISET(IFRG)=NDFRG
      NAMIDX(NDFRG)=IFRG
C
  120 DO 110 J = 1,3
         CALL RDCARD('$EFRAG 2',IEOF)
         PTNAM(J,IFRG)='        '
         LGSTR=-8
         CALL GSTRNG(PTNAM(J,IFRG),LGSTR)
         IZ(J,1) = IFIND('IZ     ',IERR)
         BL(J) = RFIND('BL      ',IERR)*UNITS
         IZ(J,2) = IFIND('IZ     ',IERR)
         ALPHA(J) = RFIND('ALPHA   ',IERR)*PI/ONE80
         IZ(J,3) = IFIND('IZ     ',IERR)
         BETA(J) = RFIND('BETA    ',IERR)*PI/ONE80
C
C                  ****** USE DIHEDRAL ANGLE *****
C
         CALL RELVC2(V1,IZ(J,2),IZ(J,3))
         CALL UNIVEC(AL1,V1)
C
C     V1 IS A VECTOR FROM ATOM IZ(J,3) TO ATOM IZ(J,2)
C     AL1 IS A UNIT VECTOR OF V1.
C     BL(IZ(J,2)) IS BONDLENGTH OF ATOM IZ(J,2)
C
      CALL RELVC2(V2,IZ(J,1),IZ(J,2))
      CALL UNIVEC(AL2,V2)
C
C     V2 IS THE VECTOR FROM ATOM IZ(J,2) TO ATOM IZ(J,1)
C     AL2 IS THE UNIT VECTOR OF V2.
C     BL(IZ(J,1)) IS BONDLENGTH DEFINING ATOM IZ(J,1)
C
      CALL VECPRD(VP,AL1,AL2)
      DO 300 I = 1,3
         AL3(I) = VP(I)/
     *        SQRT(ONE-(AL1(1)*AL2(1)+AL1(2)*AL2(2)+AL1(3)*AL2(3))**2)
  300 CONTINUE
C
C     AL3 IS THE UNIT VECTOR OF VP.ALPHA(IZ(J,1))IS THE ANGLE DEFINING
C     ATOM IZ(J,1)
C
      CALL VECPRD(AL4,AL3,AL2)
C
C     AL4,AL3,AL2 ARE A NEW SET OF MUTUALLY ORTHOGONAL AXES. WE WILL NOW
C     GET COORD OF ATOM J IN TERMS OF THESE AXES RELATIVE TO ATOM IZ(J)
C
      DO 320 I=1,3
         VJ(I) = BL(J)*(-AL2(I)*COS(ALPHA(J))+AL4(I)*SIN(ALPHA(J))*
     *           COS(BETA(J))+AL3(I)*SIN(ALPHA(J))*SIN(BETA(J)))
C
C     VJ IS THE VECTOR FROM ATOM IZ(J,1) TO ATOM J
C
  320 CONTINUE
      ITEMP = IZ(J,1)
      IF (ITEMP.LE.NATOMS) THEN
         XCRD(J,IFRG) = VJ(1) + C(1,ITEMP)
         YCRD(J,IFRG) = VJ(2) + C(2,ITEMP)
         ZCRD(J,IFRG) = VJ(3) + C(3,ITEMP)
      ELSE
        NFRG = (ITEMP-NATOMS)/3
        I123 = MOD(ITEMP-NATOMS,3)
        IF (I123.GT.0) THEN
           NFRG = NFRG + 1
        ELSE
           I123 = 3
        END IF
        XCRD(J,IFRG) = VJ(1) + XCRD(I123,NFRG)
        YCRD(J,IFRG) = VJ(2) + YCRD(I123,NFRG)
        ZCRD(J,IFRG) = VJ(3) + ZCRD(I123,NFRG)
      END IF
  110 CONTINUE
      RETURN
C
 9010 FORMAT(/1X,'ERROR...READING FRAGMENT',I4/
     *       1X,'EXPECTED KEYWORD "FRAGNAME", FOUND "',A8,'".')
 9020 FORMAT(1X,'OBTAINING COORDINATES FOR FRAGMENT',I4,' NAMED ',A8)
 9030 FORMAT(1X,'ERROR...THERE ARE TOO MANY FRAGMENT TYPES IN USE'/
     *       1X,'INCREASE MAXIMUM FRAGMENT TYPE -MXDFG- FROM',I4)
      END
C*MODULE EFINP   *DECK RDMONO
      SUBROUTINE RDMONO(N)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      PARAMETER (MXPT=2000, MXFRG=1050, MXIFRQ=12, MXDFG=5,
     *           MXDPPT=MXFRG*MXDFG*12)
C
      LOGICAL DOMTMP,DODTMP,DOQTMP,DOOTMP
      LOGICAL GOPARR,MASWRK,DSKWRK
C
      CHARACTER*8 MNAME,PNAME,DUMY,RNAME,DPNAME,FNAME
C
      COMMON /DOTMP / DOMTMP(MXPT),DODTMP(MXPT),DOQTMP(MXPT),
     *                DOOTMP(MXPT)
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ*MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      IERR = 0
      IEOF = 0
      NPTS = NMPTS(N)
  100 CONTINUE
      CALL RDCARD('RDMONO  ',IEOF)
      IF(IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,*) 'END OF FILE READING FRAGMENT MONOPOLE'
         CALL ABRT
      END IF
      DUMY='        '
      LGSTR=-8
      CALL GSTRNG(DUMY,LGSTR)
      IF(DUMY.EQ.'STOP    ') GO TO 400
      DO 200 J=1,NPTS
        IF(DUMY.EQ.MNAME(J)) THEN
          I=J
          DOMTMP(J) = .TRUE.
          GO TO 300
        END IF
  200 CONTINUE
      IF (MASWRK) WRITE(IW,9000) DUMY
      CALL ABRT
  300 CONTINUE
C
      ACHG(1,I) = RFIND('ACHG1   ',IERR)
      IF(IERR.NE.0) THEN
       IF(MASWRK) WRITE(IW,*) 'ERROR READING ACHG-1'
       CALL ABRT
      END IF
C
      ACHG(2,I) = RFIND('ACHG2   ',IERR)
      IF(IERR.NE.0) THEN
       IF(MASWRK) WRITE(IW,*) 'ERROR READING ACHG-2'
       CALL ABRT
      END IF
C
      GO TO 100
C
  400 CONTINUE
      RETURN
 9000 FORMAT(1X,'POINT ',A8,' HAS NOT BEEN GIVEN COORDINATES')
      END
C*MODULE EFINP   *DECK RDDIPO
      SUBROUTINE RDDIPO(N)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      LOGICAL DOMTMP,DODTMP,DOQTMP,DOOTMP
      LOGICAL GOPARR,MASWRK,DSKWRK
C
      PARAMETER (MXPT=2000, MXFRG=1050, MXIFRQ=12, MXDFG=5,
     *           MXDPPT=MXFRG*MXDFG*12)
C
      CHARACTER*8 MNAME,PNAME,DUMY,RNAME,DPNAME,FNAME
C
      COMMON /DOTMP / DOMTMP(MXPT),DODTMP(MXPT),DOQTMP(MXPT),
     *                DOOTMP(MXPT)
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ*MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      IERR = 0
      IEOF = 0
      NPTS = NMPTS(N)
  100 CONTINUE
      CALL RDCARD('RDDIPO  ',IEOF)
      IF(IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,*) 'END OF FILE READING FRAGMENT DIPOLE'
         CALL ABRT
      END IF
      DUMY='        '
      LGSTR=-8
      CALL GSTRNG(DUMY,LGSTR)
      IF(DUMY.EQ.'STOP    ') GO TO 600
      DO 200 J=1,NPTS
        IF(DUMY.EQ.MNAME(J)) THEN
          I=J
          DODTMP(J) = .TRUE.
          GO TO 300
        END IF
  200 CONTINUE
      IF (MASWRK) WRITE(IW,9000) DUMY
      CALL ABRT
  300 CONTINUE
      DO 500 L=1,3
C
      ADIP(L,I) = RFIND('ADIP    ',IERR)
      IF(IERR.NE.0) THEN
       IF(MASWRK) WRITE(IW,*) 'ERROR READING ADIP-',L
       CALL ABRT
      END IF
C
  500 CONTINUE
      GO TO 100
C
  600 CONTINUE
      RETURN
 9000 FORMAT(1X,'POINT ',A8,' HAS NOT BEEN GIVEN COORDINATES')
      END
C*MODULE EFINP   *DECK RDOCTU
      SUBROUTINE RDOCTU(N)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      PARAMETER (MXPT=2000, MXFRG=1050, MXIFRQ=12, MXDFG=5,
     *           MXDPPT=MXFRG*MXDFG*12)
C
      CHARACTER*8 MNAME,PNAME,DUMY,RNAME,DPNAME,FNAME
C
      LOGICAL DOMTMP,DODTMP,DOQTMP,DOOTMP
      LOGICAL GOPARR,MASWRK,DSKWRK
C
      COMMON /DOTMP / DOMTMP(MXPT),DODTMP(MXPT),DOQTMP(MXPT),
     *                DOOTMP(MXPT)
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ*MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      IERR = 0
      IEOF = 0
      NPTS = NMPTS(N)
  100 CONTINUE
      CALL RDCARD('RDOCTU  ',IEOF)
      IF(IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,*) 'END OF FILE READING FRAGMENT OCTUPOLE'
         CALL ABRT
      END IF
      DUMY='        '
      LGSTR=-8
      CALL GSTRNG(DUMY,LGSTR)
      IF(DUMY.EQ.'STOP    ') GO TO 600
      DO 200 J=1,NPTS
        IF(DUMY.EQ.MNAME(J)) THEN
          I=J
          DOOTMP(J) = .TRUE.
          GO TO 300
        END IF
  200 CONTINUE
      IF (MASWRK) WRITE(IW,9000)DUMY
      CALL ABRT
  300 CONTINUE
      DO 500 L=1,10
        AOCT(L,I) = RFIND('AOCT    ',IERR)
        IF(IERR.NE.0) THEN
           IF(MASWRK) WRITE(IW,*) 'ERROR READING OCTUPOLE-',L
           CALL ABRT
        END IF
  500 CONTINUE
      GO TO 100
C
  600 CONTINUE
      RETURN
 9000 FORMAT(1X,'POINT ',A8,' HAS NOT BEEN GIVEN COORDINATES')
      END
C*MODULE EFINP   *DECK RDQUAD
      SUBROUTINE RDQUAD(N)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      PARAMETER (MXPT=2000, MXFRG=1050, MXIFRQ=12, MXDFG=5,
     *           MXDPPT=MXFRG*MXDFG*12)
C
      LOGICAL DOMTMP,DODTMP,DOQTMP,DOOTMP
      LOGICAL GOPARR,MASWRK,DSKWRK
C
      CHARACTER*8 MNAME,PNAME,DUMY,RNAME,DPNAME,FNAME
C
      COMMON /DOTMP / DOMTMP(MXPT),DODTMP(MXPT),DOQTMP(MXPT),
     *                DOOTMP(MXPT)
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ*MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      IERR = 0
      IEOF = 0
      NPTS = NMPTS(N)
  100 CONTINUE
      CALL RDCARD('RDQUAD  ',IEOF)
      IF(IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,*)
     *        'END OF FILE READING FRAGMENT QUADRUPOLE'
         CALL ABRT
      END IF
      DUMY='        '
      LGSTR=-8
      CALL GSTRNG(DUMY,LGSTR)
      IF(DUMY.EQ.'STOP    ') GO TO 600
      DO 200 J=1,NPTS
        IF(DUMY.EQ.MNAME(J)) THEN
          I=J
          DOQTMP(J) = .TRUE.
          GO TO 300
        END IF
  200 CONTINUE
      IF (MASWRK) WRITE(IW,9000)DUMY
      CALL ABRT
  300 CONTINUE
      DO 500 L=1,6
C
      AQAD(L,I) = RFIND('AQAD    ',IERR)
      IF(IERR.NE.0) THEN
       IF(MASWRK) WRITE(IW,*) 'ERROR READING QUADRUPOLE-',L
       CALL ABRT
      END IF
C
  500 CONTINUE
      GO TO 100
C
  600 CONTINUE
      RETURN
 9000 FORMAT(1X,'POINT ',A8,' HAS NOT BEEN GIVEN COORDINATES')
      END
C
C*MODULE EFINP   *DECK RDMUL
      SUBROUTINE RDMUL
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      LOGICAL GOPARR,MASWRK,DSKWRK
C
      CHARACTER*8 DUMY
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C        TO BE USED WHEN ROHF EFPS ARE AVAILABLE, READ MULTIPLICITY
C
      IEOF = 0
      CALL RDCARD('RDMUL   ',IEOF)
      IF(IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,*)
     *        'END OF FILE READING FRAGMENT MULTIPLICITY'
         CALL ABRT
      END IF
      DUMY='        '
      LGSTR=-8
      CALL GSTRNG(DUMY,LGSTR)
      IF(DUMY.EQ.'EFPMUL  ') GO TO 600
      IF(DUMY.EQ.'STOP    ') GO TO 600
      IF(MASWRK) WRITE(IW,*) 'ERROR READING MULTIPLICITY-'
      CALL ABRT
  600 CONTINUE
      RETURN
      END
C
C*MODULE EFINP   *DECK RDFRCPNT
      SUBROUTINE RDFRCPNT(IFRG)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      LOGICAL GOPARR,MASWRK,DSKWRK
C
      PARAMETER (MXPT=2000, MXFRG=1050, MXIFRQ=12)
C
      CHARACTER*8 MNAME,PNAME,DUMY,RNAME,DPNAME,FNAME
C
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ*MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      IERR = 0
      IEOF = 0
      K=0
      CALL VCLR(FCRD,1,3*MXPT)
C
  100 CONTINUE
      CALL RDCARD('RDFRCPNT  ',IEOF)
      IF(IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,*) 'END OF FILE READING FORCE POINTS'
         CALL ABRT
      END IF
      DUMY='        '
      LGSTR=-8
C
      CALL GSTRNG(DUMY,LGSTR)
      IF(DUMY.EQ.'STOP    ') GO TO 600
      K=K+1
      FNAME(K)=DUMY
      FCRD(1,K)=RFIND('XCRD    ',IERR)
      IF(IERR.NE.0) THEN
         IF(MASWRK) WRITE(IW,*) 'ERROR READING FORCE POINT X COORD'
         CALL ABRT
      END IF
      FCRD(2,K)=RFIND('YCRD    ',IERR)
      IF(IERR.NE.0) THEN
         IF(MASWRK) WRITE(IW,*) 'ERROR READING FORCE POINT Y COORD'
         CALL ABRT
      END IF
      FCRD(3,K)=RFIND('ZCRD    ',IERR)
      IF(IERR.NE.0) THEN
         IF(MASWRK) WRITE(IW,*) 'ERROR READING FORCE POINT Z COORD'
         CALL ABRT
      END IF
C
      GO TO 100
  600 CONTINUE
      NFPNT(IFRG)=K
C
      RETURN
      END
C
C*MODULE EFINP   *DECK RDPAO
      SUBROUTINE RDPAO(M)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DOUBLE PRECISION LABEL(28)
      LOGICAL GOPARR,MASWRK,DSKWRK
C
      PARAMETER (MXSHEF=1000, MXGEFP=4000,
     *           MXDFG=5, MXFRG=1050, MXFGPT=12000)
      PARAMETER (ZERO=0.0D+00)
C
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NAT(MXDFG),NUM(MXDFG),NTPATM
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DIMENSION NBFS(27), MINF(27), MAXF(27), NANGM(27)
C
      CHARACTER*8 CNAME
C
      DATA BLANK/8H        /
      DATA LABEL/8HS       ,8HP       ,8HD       ,8HF       ,
     *           8HG       ,8HL       ,8HM       ,8HN       ,
     *           8H1S      ,8H2S      ,8H2P      ,8H2SP     ,
     *           8H3S      ,8H3P      ,8H3D      ,8H3SP     ,8H3SPD    ,
     *           8H4S      ,8H4P      ,8H4D      ,8H4SP     ,8H4SPD    ,
     *           8H5S      ,8H5P      ,8H5D      ,8H5SP     ,8H5SPD    ,
     *           8HSV      /
C
      DATA NBFS/ 1, 3, 6,10,15,     4,10,20,
     *           1, 1, 3, 4,        1, 3, 6, 4,10,
     *           1, 3, 6, 4,10,     1, 3, 6, 4,10/
      DATA MINF/ 1, 2, 5,11,21,     1, 1, 1,
     *           1, 1, 2, 1,        1, 2, 5, 1, 1,
     *           1, 2, 5, 1, 1,     1, 2, 5, 1, 1/
      DATA MAXF/ 1, 4,10,20,35,     4,10,20,
     *           1, 1, 4, 4,        1, 4,10, 4,10,
     *           1, 4,10, 4,10,     1, 4,10, 4,10/
      DATA NANGM/1, 2, 3, 4, 5,     2, 3, 4,
     *           1, 1, 2, 2,        1, 2, 3, 2, 3,
     *           1, 2, 3, 2, 3,     1, 2, 3, 2, 3/
C
C         THIS READS THE FRAGMENT'S BASIS SET FOR BOTH
C         PAULI REPULSION AND CHARGE TRANSFER EFP2,
C         FROM A "PROJECTION BASIS SET" SUBGROUP.
C
      N=ISET(M)
      NAT0 = 0
      NSHEL0 = 0
      LOC = 0
      NGAUS0 = 0
  100 CONTINUE
C
C  --- READ POINT NAME AND COODINATES ----
C
      IEOF = 0
      IERR = 0
      CALL RDCARD('PROJECT1',IEOF)
      IF(IEOF.NE.0) GO TO 1999
      CNAME='        '
      LGSTR=-8
      CALL GSTRNG(CNAME,LGSTR)
      IF(CNAME.EQ.'STOP    ') GO TO 999
C
      NAT0 = NAT0 + 1
      READ(UNIT=CNAME,FMT='(A8)') PRNAME(NAT0+NTPATM)
      DO J = 1,3
         PRCORD(J,NAT0+NTPATM) = RFIND('PRCORD  ',IERR)
         IF(IERR.NE.0) GO TO 2999
      END DO
      EFZNUC(NAT0+NTPATM) = RFIND('EFZNUC  ',IERR)
      IF(IERR.NE.0) GO TO 2999
  150 CONTINUE
C
C  --- READ BASIS FUNCTION ---
C
      IEOF = 0
      IERR = 0
      CALL RDCARD('PROJECT2',IEOF)
      IF(IEOF.NE.0) GO TO 1999
      CNAME='        '
      LGSTR=-8
      CALL GSTRNG(CNAME,LGSTR)
      READ(UNIT=CNAME,FMT='(A8)') BASIS
      IGAUSS = IFIND('NGAUSS  ',IERR)
C
      IF(BASIS.EQ.BLANK) GO TO 100
C
C  --- DETERMINE THE KIND OF BASIS FUNCTION ---
C        (ONLY S,P,D, AND L SO FAR)
C
      ITYP = 0
      IF(BASIS.EQ.LABEL(1)) ITYP=1
      IF(BASIS.EQ.LABEL(2)) ITYP=2
      IF(BASIS.EQ.LABEL(3)) ITYP=3
      IF(BASIS.EQ.LABEL(4)) ITYP=4
      IF(BASIS.EQ.LABEL(5)) ITYP=5
      IF(BASIS.EQ.LABEL(6)) ITYP=6
      IF(ITYP.EQ.0) THEN
         IF(MASWRK) THEN
            WRITE(IW,*) ' '
            WRITE(IW,*) 'UNRECOGNIZED BASIS FUNCTION'
            WRITE(IW,*) 'CHECK YOUR "PROJECTION BASIS SET" SUBGROUP'
         END IF
         CALL ABRT
      END IF
C
C  --- READ IN BASIS FUNCTION ---
C
      NSHEL0 = NSHEL0 + 1
      KMIN(NSHEL0,N) = MINF(ITYP)
      KMAX(NSHEL0,N) = MAXF(ITYP)
      KSTART(NSHEL0,N) = NGAUS0+1
      KATOM(NSHEL0,N) = NAT0
      KTYPE(NSHEL0,N) = NANGM(ITYP)
      KNG(NSHEL0,N) = IGAUSS
      KLOC(NSHEL0,N) = LOC+1
      NGAUS0 = NGAUS0+IGAUSS
      LOC = LOC+NBFS(ITYP)
      K1 = KSTART(NSHEL0,N)
      K2 = K1+KNG(NSHEL0,N)-1
C
      DO 200 I = K1,K2
         C1 = ZERO
         CALL RDCARD('PROJECT3',IEOF)
         IF(IEOF.NE.0) GO TO 1999
         IDUM = IFIND('IDUM    ',IERR)
         EX(I,N) = RFIND('ZETA    ',IERR)
         IF(IERR.NE.0) GO TO 2999
         C1    = RFIND('C1      ',IERR)
         IF(IERR.NE.0) GO TO 2999
         C2    = RFIND('C2      ',IERR)
         IF(IERR.NE.0) GO TO 2999
         IF(ITYP.EQ.1) CS(I,N) = C1
         IF(ITYP.EQ.2) CP(I,N) = C1
         IF(ITYP.EQ.3) CD(I,N) = C1
         IF(ITYP.EQ.4) CF(I,N) = C1
         IF(ITYP.EQ.5) CG(I,N) = C1
         IF(ITYP.EQ.6) CS(I,N) = C1
         IF(ITYP.EQ.6) CP(I,N) = C2
  200 CONTINUE
C THIS GETS RID OF FTNCHECK WARNING
      IDUM = IDUM+1
      GO TO 150
C
  999 CONTINUE
      NUM(N) = LOC
      NAT(N) = NAT0
      NSHELL(N) = NSHEL0
      NGAUSS(N) = NGAUS0
      RETURN
C
 1999 CONTINUE
      IF(MASWRK) WRITE(IW,9000)
      CALL ABRT
      STOP
C
 2999 CONTINUE
      IF(MASWRK) WRITE(IW,9010)
      CALL ABRT
      STOP
C
 9000 FORMAT(1X,'END OF FILE READING -PROJECTION BASIS SET- SUBGROUP')
 9010 FORMAT(1X,'ERROR READING DATA IN -PROJECTION BASIS SET- SUBGROUP')
      END
C*MODULE EFINP   *DECK RDPMO
      SUBROUTINE RDPMO(N,NMOS,NAOS,PROVEC,FOCKMA,
     *                 MXBF,MXMO,MXMO2,NFRG,NTMOF)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXFRG=1050, MXFGPT=12000)
C
      CHARACTER*8 PTNAM
C
      LOGICAL GOPARR,MASWRK,DSKWRK
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
C
      DIMENSION PROVEC(MXBF,NTMOF),FOCKMA(MXMO2,NFRG)
C
C         THIS READS "PROJECTION WAVEFUNCTION" SUBGROUP,
C         WHICH ARE THE LOCALIZED MO'S LCAO EXPANSION
C         FOR PAULI REPULSION IN EFP2 COMPUTATIONS.
C
      IZERO = 0
      IONE  = 1
      ITWO  = 2
C
      IF(NMOS.GT.MXMO  .OR.  NAOS.GT.MXBF) THEN
         IF(MASWRK) WRITE(IW,9010) NMOS,NAOS,MXMO,MXBF
         CALL ABRT
      END IF
C
      NORB(N) = NMOS
      NPBF(N) = NAOS
      IF (MASWRK) THEN
      DO 280 J = 1,NMOS
         IMAX = 0
         IC = 0
  240    CONTINUE
            IMIN = IMAX+1
            IMAX = IMAX+5
            IC = IC+1
            IF(IMAX .GT. NAOS) IMAX = NAOS
            READ(IR,9040,END=300,ERR=300) JJ,ICC,
     *                                    (PROVEC(I,J+NTMO),I=IMIN,IMAX)
            MODJ=MOD(J,100)
            IF(JJ.EQ.MODJ . AND.  ICC.EQ.IC) GO TO 260
               WRITE(IW,9060) J,IC,JJ,ICC
               IF (GOPARR) CALL DDI_BCAST(352,'I',ITWO,1,MASTER)
               CALL ABRT
  260       CONTINUE
         IF(IMAX .LT. NPBF(N)) GO TO 240
  280 CONTINUE
      IF (GOPARR) CALL DDI_BCAST(352,'I',IZERO,1,MASTER)
C
C SLAVE WORK.  IEND=0,1,2 MEANS OK DATA, INCOMPLETE DATA, SCRAMBLED DATA
C
      ELSE
         IF (GOPARR) CALL DDI_BCAST(352,'I',IEND,1,MASTER)
         IF (IEND.EQ.IONE) GO TO 300
         IF (IEND.EQ.ITWO) CALL ABRT
      END IF
C
C  GIVE VECTORS TO ALL PROCESSES
C
      IF (GOPARR) CALL DDI_BCAST(353,'F',PROVEC,NMOS*NAOS,MASTER)
C
      IEOF = 0
      CALL RDCARD('MO1     ',IEOF)
      CALL RDCARD('MO2     ',IEOF)
      DO  I = 1,(NMOS*NMOS+NMOS)/2
         FOCKMA(I,N) = RFIND('MO2     ',IEOF)
      END DO
      CALL RDCARD('MO3     ',IEOF)
      DO I = 1,NMOS
         CALL RDCARD('MO4     ',IEOF)
         PTNAM='        '
         LGSTR=-8
         CALL GSTRNG(PTNAM,LGSTR)
         READ(UNIT=PTNAM,FMT='(A8)') CENTNM(I+NTMO)
         CENTCD(1,I+NTMO) = RFIND('MO4     ',IEOF)
         CENTCD(2,I+NTMO) = RFIND('MO4     ',IEOF)
         CENTCD(3,I+NTMO) = RFIND('MO4     ',IEOF)
      END DO
C
      CALL RDCARD('STOP    ',IEOF)
      RETURN
C
C        PREMATURE END OF $VEC INPUT ENCOUNTERED
C
  300 CONTINUE
      IF (MASWRK) THEN
         IF (GOPARR) CALL DDI_BCAST(352,'I',IONE,1,MASTER)
         WRITE(IW,9100) J,IC
      ENDIF
      CALL ABRT
      RETURN
C
 9010 FORMAT(/1X,'* * * ERROR * * *'/
     *       1X,'NUMBER OF MO''S IN THIS FRAGMENT =',I5,' OR'/
     *       1X,'NUMBER OF AO''S IN THIS FRAGMENT =',I5,' EXCEEDS THE'/
     *       1X,'MAXIMUM NO. OF MO''S AND AO''S GIVEN IN $EFRAG=',2I5/
     *       1X,'PLEASE GIVE CORRECT -MXMO- AND -MXBF- KEYWORDS',
     *       1X,' ON THE FIRST $EFRAG CARD.'/)
 9040 FORMAT(I2,I3,5E15.8)
 9060 FORMAT(' *** ERROR READING THE MO COEFFICIENTS AT',2I4/
     *       '     THE INPUT VALUES WERE',2I4)
 9100 FORMAT(' *** ERROR: PREMATURE END OF ORBITAL INPUT ENCOUNTERED'/
     *       '            LOOKING FOR ORBITAL',I4,' ELEMENT',I4)
      END
C*MODULE EFINP   *DECK RDPTEN
      SUBROUTINE RDPTEN(NPTS,N)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      PARAMETER (MXPT=2000, MXFRG=1050, MXIFRQ=12, MXDFG=5,
     *           MXDPPT=MXFRG*MXDFG*12)
C
      CHARACTER*8 MNAME,PNAME,RNAME,DPNAME,FNAME
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ*MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      IERR = 0
      IEOF = 0
      NPTS = 0
  100 CONTINUE
      K = NPTS + 1
      IF(K.GT.MXPT) THEN
         IF(MASWRK) WRITE(IW,9000) N,MXPT
         CALL ABRT
      END IF
      CALL RDCARD('RDPTEN1 ',IEOF)
      IF(IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,*) 'END OF FILE READING POLARIZATION INFO'
         CALL ABRT
      END IF
      PNAME(K) = '        '
      LGSTR=-8
      CALL GSTRNG(PNAME(K),LGSTR)
      IF(PNAME(K).EQ.'STOP    ') GO TO 600
      DO 120 L = 1,NMPTS(N)
        IF(PNAME(K).EQ.MNAME(L)) GO TO 130
  120 CONTINUE
      GO TO 140
  130 CONTINUE
      PCORD(1,K) = CORD(1,L)
      PCORD(2,K) = CORD(2,L)
      PCORD(3,K) = CORD(3,L)
      GO TO 200
  140 CONTINUE
      DO 150 J=1,3
        PCORD(J,K) = RFIND('PCORD   ',IERR)
        IF(IERR.NE.0) THEN
           IF(MASWRK) WRITE(IW,*) 'RDPTEN: ERROR READING PCORD'
           CALL ABRT
        END IF
  150 CONTINUE
  200 CONTINUE
      CALL RDCARD('RDPTEN2 ',IEOF)
      IF(IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,*) 'END OF FILE READING POLARIZATION INFO2'
         CALL ABRT
      END IF
      DO 500 L=1,9
        POLT(L,K) = RFIND('POLT    ',IERR)
        IF(IERR.NE.0) THEN
           IF(MASWRK) WRITE(IW,*) 'RDPTEN: ERROR READING POLT'
           CALL ABRT
        END IF
  500 CONTINUE
      NPTS = NPTS + 1
      GO TO 100
C
  600 CONTINUE
      RETURN
C
 9000 FORMAT(1X,'ERROR IN READING POLARIZABLE POINTS FOR FRAGMENT',I4,
     *          ' EXCEEDED MXPT=',I5)
      END
C*MODULE EFINP   *DECK RDREP
      SUBROUTINE RDREP(NPTS,N)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      PARAMETER (MXPT=2000, MXFRG=1050, MXIFRQ=12, MXDFG=5,
     *           MXDPPT=MXFRG*MXDFG*12)
C
      CHARACTER*8 MNAME,PNAME,RNAME,DPNAME,FNAME
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ*MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA ZERO/0.0D+00/
C
      IERR = 0
      IEOF = 0
      NPTS = 0
      IKFR(1) = 1
  100 CONTINUE
      K = NPTS+1
      IF(K.GT.MXPT) THEN
         IF(MASWRK) WRITE(IW,9000) N,MXPT
         CALL ABRT
      END IF
      CALL RDCARD('RDREP   ',IEOF)
      IF(IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,*)
     *     'END OF FILE READING FRAGMENT REPULSION DATA'
         CALL ABRT
      END IF
      RNAME(K) = '        '
      LGSTR=-8
      CALL GSTRNG(RNAME(K),LGSTR)
      IF(RNAME(K).EQ.'STOP    ') GO TO 400
      DO 120 L = 1,NMPTS(N)
        IF(RNAME(K).EQ.MNAME(L)) GO TO 130
  120 CONTINUE
      GO TO 140
  130 CONTINUE
      RCORD(1,K) = CORD(1,L)
      RCORD(2,K) = CORD(2,L)
      RCORD(3,K) = CORD(3,L)
      GO TO 200
  140 CONTINUE
      DO 150 J=1,3
        RCORD(J,K) = RFIND('RCORD   ',IERR)
        IF(IERR.NE.0) THEN
           IF(MASWRK) WRITE(IW,*) 'RDREP: ERROR READING RCORD-',J
           CALL ABRT
        END IF
  150 CONTINUE
C
C         -INLPR- IS AN UNDOCUMENTED OPTION TO ADD A POWER OF R
C         TO THE POTENTIAL, R**(INLPR+2).  THE CURRENT EFPS ALL
C         USE INLPR=0, HENCE IT IS NOT DOCUMENTED.
C
  200 CONTINUE
      NTERMS = IFIND('NTERM   ',IERR)
      IF(IERR.NE.0) THEN
         IF(MASWRK) WRITE(IW,*) 'RDREP: ERROR READING NTERMS'
         CALL ABRT
      END IF
      IF(K.NE.1) IKFR(K) = IKLR(K-1) + 1
      IKLR(K) = IKFR(K) + NTERMS - 1
      IFF = IKFR(K)
      ISS = IKLR(K)
      DO 300 II = IFF,ISS
        CALL RDCARD('RDREP2  ',IEOF)
        IF(IEOF.EQ.1) THEN
           IF(MASWRK) WRITE(IW,*) 'END OF FILE READING REPULSION 2'
           CALL ABRT
        END IF
C
        TCLPR(II) = RFIND('TCLPR   ',IERR)
        IF(IERR.NE.0) THEN
           IF(MASWRK) WRITE(IW,*) 'RDREP: ERORR READING TCLPR'
           CALL ABRT
        END IF
C
        TZLPR(II) = RFIND('TZLPR   ',IERR)
        IF(IERR.NE.0) THEN
           IF(MASWRK) WRITE(IW,*) 'RDREP: ERORR READING TZLPR'
           CALL ABRT
        END IF
        IF(TZLPR(II).EQ.ZERO) THEN
           IF(MASWRK) WRITE(IW,*) 'POWER PRECEEDS ZETA IN REP.POT.'
           CALL ABRT
        END IF
        INLPR(II) = IFIND('INLPR   ',IERR) + 2
  300 CONTINUE
      NPTS = NPTS + 1
      GO TO 100
C
  400 CONTINUE
      RETURN
 9000 FORMAT(1X,'ERROR IN READING REPULSIVE POINTS FOR FRAGMENT',I4,
     *          ' EXCEEDED MXPT=',I5)
      END
C*MODULE EFINP   *DECK RDDIS
      SUBROUTINE RDDIS(NPTS,N)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      PARAMETER (MXPT=2000, MXFRG=1050, MXFGPT=12000,
     *           MXIFRQ=12, MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      CHARACTER*8 MNAME,PNAME,RNAME,DPNAME,DNAME,DPSNAM,FNAME
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ*MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
      COMMON /POL2  / DCORD(3,MXPT),CDIS(3,MXFGPT),
     *                CLPD(4*MXFGPT),ZLPD(4*MXFGPT),
     *                NLPD(4*MXFGPT),KFD(MXFGPT),KLD(MXFGPT),
     *                DNAME(MXPT),DPSNAM(MXFGPT)
C
      DATA ZERO/0.0D+00/
C
      IERR = 0
      IEOF = 0
      NPTS = 0
      JKFR(1) = 1
  100 CONTINUE
      K = NPTS+1
      IF(K.GT.MXPT) THEN
         IF(MASWRK) WRITE(IW,9000) N,MXPT
         CALL ABRT
      END IF
      CALL RDCARD('RDDIS   ',IEOF)
      IF(IEOF.EQ.1) CALL ABRT
      DNAME(K) = '        '
      LGSTR=-8
      CALL GSTRNG(DNAME(K),LGSTR)
      IF(DNAME(K).EQ.'STOP    ') GO TO 400
      DO 120 L = 1,NMPTS(N)
        IF(DNAME(K).EQ.MNAME(L)) GO TO 130
  120 CONTINUE
      GO TO 140
  130 CONTINUE
      DCORD(1,K) = CORD(1,L)
      DCORD(2,K) = CORD(2,L)
      DCORD(3,K) = CORD(3,L)
      GO TO 200
  140 CONTINUE
      DO 150 J=1,3
        DCORD(J,K) = RFIND('DCORD   ',IERR)
        IF(IERR.NE.0) CALL ABRT
  150 CONTINUE
C
C         -INLPR- IS AN UNDOCUMENTED OPTION TO ADD A POWER OF R
C         TO THE POTENTIAL, R**(INLPR+2).  THE CURRENT EFPS ALL
C         USE INLPR=0, HENCE IT IS NOT DOCUMENTED.
C
  200 CONTINUE
      NTERMS = IFIND('NTERM   ',IERR)
      IF(IERR.NE.0) CALL ABRT
      IF(K.NE.1) JKFR(K) = JKLR(K-1) + 1
      JKLR(K) = JKFR(K) + NTERMS - 1
      IFF = JKFR(K)
      ISS = JKLR(K)
      DO 300 II = IFF,ISS
        CALL RDCARD('RDDIS2  ',IEOF)
        IF(IEOF.EQ.1) CALL ABRT
        TCLPD(II) = RFIND('TCLPD   ',IERR)
        IF(IERR.NE.0) CALL ABRT
        TZLPD(II) = RFIND('TZLPD   ',IERR)
        IF(IERR.NE.0) CALL ABRT
        IF(TZLPD(II).EQ.ZERO) THEN
           IF(MASWRK) WRITE(IW,*) 'POWER PRECEEDS ZETA IN DIS.POT.'
           CALL ABRT
        END IF
        JNLPR(II) = IFIND('JNLPR   ',IERR) + 2
  300 CONTINUE
      NPTS = NPTS + 1
      GO TO 100
C
  400 CONTINUE
      RETURN
 9000 FORMAT(1X,'ERROR IN READING DISPERSION POINTS FOR FRAGMENT',I4,
     *          ' EXCEEDED MXPT=',I5)
      END
C
C*MODULE EFINP   *DECK RDSCRN
      SUBROUTINE RDSCRN(N,MODE)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      LOGICAL GOPARR,MASWRK,DSKWRK
C
      PARAMETER (MXPT=2000, MXFRG=1050, MXIFRQ=12, MXDFG=5,
     *           MXDPPT=MXFRG*MXDFG*12)
C
      CHARACTER*8 MNAME,PNAME,RNAME,DPNAME,DUMY,FNAME
C
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ*MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      IERR = 0
      IEOF = 0
      NPTS = NMPTS(N)
  100 CONTINUE
      IF(MODE.EQ.1) THEN
         CALL RDCARD('RDSCRN  ',IEOF)
      ELSE
         CALL RDCARD('RDSCRN2 ',IEOF)
      ENDIF
      IF(IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,*) 'END OF FILE READING SCREENING INPUT'
         CALL ABRT
      END IF
C
      DUMY='        '
      LGSTR=-8
      CALL GSTRNG(DUMY,LGSTR)
      IF(DUMY.EQ.'STOP    ') GO TO 400
      DO 200 J=1,NPTS
        IF(DUMY.EQ.MNAME(J)) THEN
          I=J
          GO TO 300
        END IF
  200 CONTINUE
      IF (MASWRK) WRITE(IW,9000) DUMY
      CALL ABRT
  300 CONTINUE
C
C         MODE=1 READS THE QUANTUM/FRAGMENT SCREENING FIT,
C         MODE=2 READS THE FRAGMENT-FRAGMENT SCREENING FIT
C
      IF(MODE.EQ.1) THEN
           BMULT(I) = RFIND('AMULT   ',IERR)
           IF(IERR.NE.0) CALL ABRT
           AMULT(I) = RFIND('BMULT   ',IERR)
           IF(IERR.NE.0) CALL ABRT
      ELSE
           BMULT2(I) = RFIND('AMULT2  ',IERR)
           IF(IERR.NE.0) CALL ABRT
           AMULT2(I) = RFIND('BMULT2  ',IERR)
           IF(IERR.NE.0) CALL ABRT
      END IF
C
      GO TO 100
C
  400 CONTINUE
      RETURN
 9000 FORMAT(1X,'POINT ',A8,' HAS NOT BEEN GIVEN COORDINATES')
      END
C
C*MODULE EFINP   *DECK RDSCRN
      SUBROUTINE RDPLSCR(N)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      LOGICAL GOPARR,MASWRK,DSKWRK
C
      PARAMETER (MXPT=2000, MXFRG=1050, MXIFRQ=12, MXDFG=5,
     *           MXDPPT=MXFRG*MXDFG*12)
C
      CHARACTER*8 MNAME,PNAME,RNAME,DPNAME,DUMY,FNAME
C
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ*MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C
C
C   ---- THIS SUBROUTINE READS SCREENING PARAMETERS FOR POLARIZATION
C   ----  LVS, JANUARY 2007
C
      IERR = 0
      IEOF = 0
      NPTS = NPPTS(N)
  100 CONTINUE
      CALL RDCARD('RDPLSCR ',IEOF)
      IF(IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,*)
     *       'END OF FILE READING POLARIZATION SCREENING INPUT'
         CALL ABRT
      END IF
C
      DUMY='        '
      LGSTR=-8
      CALL GSTRNG(DUMY,LGSTR)
      IF(DUMY.EQ.'STOP    ') GO TO 400
      DO 200 J=1,NPTS
        IF(DUMY.EQ.PNAME(J)) THEN
          I=J
          GO TO 300
        END IF
  200 CONTINUE
      IF (MASWRK) WRITE(IW,9000) DUMY
      CALL ABRT
  300 CONTINUE
C
C      IF(IPLSCR.EQ.1) THEN
         POLSCRN(I) = RFIND('POLSCRN ',IERR)
         IF(IERR.NE.0) CALL ABRT
C      END IF
C
      GO TO 100
C
  400 CONTINUE
      RETURN
 9000 FORMAT(1X,'POL. POINT ',A8,' HAS NOT BEEN GIVEN COORDINATES')
      END
C
C*MODULE EFINP   *DECK RDSCRN
      SUBROUTINE RDPOLAB
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      LOGICAL GOPARR,MASWRK,DSKWRK
C
      CHARACTER*8 DUMY
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C   ---- THIS SUBROUTINE READS SCREENING PARAMETERS FOR POLARIZATION
C   ----  LVS, 2008
C
      IEOF = 0
      CALL RDCARD('RDPOLAB ',IEOF)
      IF(IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,*)
     *       'END OF FILE READING POLAB POLARIZATION SCREENING INPUT'
         CALL ABRT
      END IF
C
      DUMY='        '
      LGSTR=-8
      CALL GSTRNG(DUMY,LGSTR)
      IF(DUMY.EQ.'POLAB   ') GO TO 600
      IF(DUMY.EQ.'STOP    ') GO TO 600
      IF(MASWRK) WRITE(IW,*) 'ERROR READING POLARIZATION SCREENING-'
      CALL ABRT
  600 CONTINUE
      RETURN
      END
C
C*MODULE EFINP   *DECK RDSTFR
      SUBROUTINE RDSTFR(FRGMNT,IFRAG,PROVEC,FOCKMA,CTVEC,
     *                  MXBF,NTCTMOF,MXMO,MXMO2,NTMOF)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      INTEGER EFPMUL
C
      LOGICAL GOPARR,MASWRK,DSKWRK
      LOGICAL IFRCPNT
C
      PARAMETER (MXDFG=5, MXPT=2000, MXFRG=1050, MXFGPT=12000,
     *           MXAO=8192, MXIFRQ=12,
     *           MXDPPT=MXFRG*MXDFG*12)
C
      CHARACTER*8 FRGMNT,LJNAME,ELJNAM
      CHARACTER*8 WORD,MNAME,PNAME,RNAME,DPNAME,FNAME,FRCNME
      CHARACTER*80 TITLE
C
      COMMON /EFPCT / NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CTFOK(MXAO,MXDFG),NCTMO(MXDFG),NTCTMO
      COMMON /EFPFRC/ IFRCPNT,NTFRCPN,NFRCPNT(MXFRG),LSTFPTS(MXFRG),
     *                FRCCRD(3,MXFGPT),FRCNME(MXFGPT),FRCTRQ(6,MXFGPT)
     *                ,FRCTRQX(6,MXFGPT)
      COMMON /FRGLJP/ CORDLJ(3,MXPT),ELJCRD(3,MXFGPT),
     *                POTLJ(2,MXPT),ELJPOT(2,MXFGPT),
     *                LJNAME(MXPT),ELJNAM(MXFGPT),
     *                NLJPTS(MXFRG),NLJTTPT,ILJP,NMLJ(2)
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ*MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
      COMMON /EFPIO / MULMAT(MXFRG)
C   ---- LVS: TMP COMMON FOR POLARIZATION SCREENING
      COMMON /PLSCR / IPLSCR,INDSCR
      COMMON /EFPSCR/ POLAB(MXFRG),B,SCROFF,IELECS,IDISPS,NEW_POL
C
      COMMON /EFPNFO/ EFPMUL
C
      DIMENSION PROVEC(MXBF,NTMOF),FOCKMA(MXMO2,NFRG),
     *          CTVEC(MXBF,NTCTMOF)
C
      NMPTS(IFRAG)=0
      NPPTS(IFRAG)=0
      NDPPTS(IFRAG)=0
      NLJPTS(IFRAG)=0
      NRPTS(IFRAG)=0
      NDPTS(IFRAG)=0
      NFRCPNT(IFRAG)=0
C
C   TEMPORARY SCREENING VARIABLES
      ICHGPX = 0
      ICHGPY = 0
C
C     INITIALIZE LOCAL COMMON BLOCK FRGSTD
C
      CALL VCLR(CORD(1,1),1,50*MXPT)
      DO 10 I=1,MXPT
         INLPR(4*(I-1)+1)=0
         INLPR(4*(I-1)+2)=0
         INLPR(4*(I-1)+3)=0
         INLPR(4*(I-1)+4)=0
         IKFR(I)=0
         IKLR(I)=0
         MNAME(I)='        '
         PNAME(I)='        '
         RNAME(I)='        '
         FNAME(I)='        '
         LJNAME(I)='        '
C   ---- LVS: DEFAULT FOR POLARIZATION SCREENING PARAMETERS
C---     IF (IPLSCR.EQ.1) THEN
C---        POLSCRN(I) = 1.5D+00
C---     ELSE
C---        POLSCRN(I) = 1.0D+00
C---     END IF
   10 CONTINUE
C
      MXPTD=MXPT*MXIFRQ
      DO 11 I=1,MXPTD
         DPNAME(I)='        '
   11 CONTINUE
C
      IEOF=0
      CALL SEQREW(IR)
      CALL FNDGRP(IR,FRGMNT,IEOF)
      IF(IEOF.NE.0) THEN
         IF (MASWRK) WRITE(IW,9010) FRGMNT
         CALL ABRT
         RETURN
      END IF
C
      CALL RDCARD('$FRAG 1 ',IEOF)
      IF(IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,9011) FRGMNT
         CALL ABRT
      END IF
      TITLE=' '
      LGSTR=+80
      CALL GSTRNG(TITLE,LGSTR)
C
C ----- READ IN FRAGMENT INFORMATION -----
C
  200 CONTINUE
      CALL RDCARD('$FRAG 3 ',IEOF)
      IF(IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,9011) FRGMNT
         CALL ABRT
      END IF
      WORD='        '
      LGSTR=-8
      CALL GSTRNG(WORD,LGSTR)
C
      IF(WORD.NE.'COORDINA') GO TO 220
      CALL RDCRDX(CORD,FPMASS,FPNUC,MNAME,NMPTS(IFRAG),IFRAG)
      GO TO 200
C
  220 CONTINUE
      IF(WORD.NE.'MONOPOLE') GO TO 240
      IF(NMPTS(IFRAG).LE.0) GO TO 999
      CALL RDMONO(IFRAG)
      IEFC=1
      GO TO 200
C
C  ---- THIS READS AB INITIO-EFP (GAUSSIAN-TYPE) SCREENING
  240 CONTINUE
      IF(WORD.NE.'SCREEN  ') GO TO 250
      IF(NMPTS(IFRAG).LE.0) GO TO 999
      CALL RDSCRN(IFRAG,1)
      ICHGPX = 1
      GO TO 200
C
C  ---- THIS READS EFP-EFP (GAUSSIAN-TYPE) SCREENING
  250 CONTINUE
      IF(WORD.NE.'SCREEN1  ') GO TO 260
      IF(NMPTS(IFRAG).LE.0) GO TO 999
      CALL RDSCRN(IFRAG,2)
      IF (ICHGPY.NE.0) THEN
         IF (MASWRK) WRITE(IW,9250) ICHGPY
         CALL ABRT
      END IF
      ICHGPY=1
      GO TO 200
C
C  ---- THESE READ EFP-EFP DIFFERENT EXPONENTIAL-TYPE SCREENINGS
  260 CONTINUE
      IF(WORD.NE.'SCREEN2  ') GO TO 261
      IF(NMPTS(IFRAG).LE.0) GO TO 999
      CALL RDSCRN(IFRAG,2)
      IF (ICHGPY.NE.0) THEN
         IF (MASWRK) WRITE(IW,9260) ICHGPY
         CALL ABRT
      END IF
      ICHGPY=2
      GO TO 200
C
  261 CONTINUE
      IF(WORD.NE.'SCREEN3  ') GO TO 262
      IF(NMPTS(IFRAG).LE.0) GO TO 999
      CALL RDSCRN(IFRAG,2)
      IF (ICHGPY.NE.0) THEN
         IF (MASWRK) WRITE(IW,9261) ICHGPY
         CALL ABRT
      END IF
      ICHGPY=3
      GO TO 200
C
  262 CONTINUE
      IF(WORD.NE.'SCREEN4  ') GO TO 263
      IF(NMPTS(IFRAG).LE.0) GO TO 999
      CALL RDSCRN(IFRAG,2)
      IF (ICHGPY.NE.0) THEN
         IF (MASWRK) WRITE(IW,9262) ICHGPY
         CALL ABRT
      END IF
      ICHGPY=4
      GO TO 200
C
  263 CONTINUE
      IF(WORD.NE.'SCREEN5  ') GO TO 270
      IF(NMPTS(IFRAG).LE.0) GO TO 999
      CALL RDSCRN(IFRAG,2)
      IF (ICHGPY.NE.0) THEN
         IF (MASWRK) WRITE(IW,9263) ICHGPY
         CALL ABRT
      END IF
      ICHGPY=5
      GO TO 200
C
  270 CONTINUE
      IF(WORD.NE.'DIPOLES ') GO TO 280
      IF(NMPTS(IFRAG).LE.0) GO TO 999
      CALL RDDIPO(IFRAG)
      IEFD=1
      GO TO 200
C
  280 CONTINUE
      IF(WORD.NE.'QUADRUPO') GO TO 290
      IF(NMPTS(IFRAG).LE.0) GO TO 999
      CALL RDQUAD(IFRAG)
      IEFQ=1
      GO TO 200
C
  290 CONTINUE
      IF(WORD.NE.'MULTIPLI') GO TO 300
      IERR2 = 0
      EFPMUL = IFIND('MULTI   ',IERR2)
      MULMAT (IFRAG) = EFPMUL
      CALL RDMUL
C          SEE GLYCYL-WATER.INP FOR MORE INFORMATION ON NEXT IF.
      IF(EFPMUL.GT.1  .AND.  GOPARR) THEN
         IF(MASWRK) THEN
            WRITE(IW,*) ' '
            WRITE(IW,*) 'SORRY, OPEN SHELL EFP2 ONLY RUNS IN SERIAL'
            WRITE(IW,*) ' '
         END IF
         CALL ABRT
      END IF
      GO TO 200
C
  300 CONTINUE
      IF(WORD.NE.'OCTUPOLE') GO TO 320
      IF(NMPTS(IFRAG).LE.0) GO TO 999
      CALL RDOCTU(IFRAG)
      IEFO=1
      GO TO 200
C
  320 CONTINUE
      IF(WORD.NE.'POLARIZA') GO TO 330
      CALL RDPTEN(NPPTS(IFRAG),IFRAG)
      IEFP=1
      GO TO 200
C
C  ---- LVS, EXPONENTIAL FORMULA POLARIZATION SCREENING
C
  330 CONTINUE
      IF(WORD.NE.'POLSCR  ') GO TO 340
      IF(NPPTS(IFRAG).LE.0) GO TO 999
      IF (NEW_POL .NE. 1) THEN
         CALL RDPLSCR(IFRAG)
      ELSE
         IF(MASWRK) WRITE(IW,9310)
         CALL ABRT
      END IF
      IPLSCR = 1
      GO TO 200
C
C  ---- LVS, TANG-TOENNIS FORMULA POLARIZATION SCREENING
C
  340 CONTINUE
      IF(WORD.NE.'POLAB   ') GO TO 360
      IERR2 = 0
      IF (NEW_POL .EQ. 1) THEN
         TMP = RFIND('POLABSCR',IERR2)
         POLAB(IFRAG) = TMP
         CALL RDPOLAB
      ELSE
         WRITE(IW,9320)
         CALL ABRT
      END IF
      GO TO 200
C
  360 CONTINUE
      IF(WORD.NE.'DYNAMIC ') GO TO 370
      CALL RDDPTEN(NDPPTS(IFRAG),IFRAG)
      IEFDP=1
      GO TO 200
C
  370 CONTINUE
C
      IF(WORD.NE.'DISPERSI') GO TO 392
      CALL RDDIS(NDPTS(IFRAG),IFRAG)
      GO TO 200
  392 CONTINUE
C
      IF(WORD.NE.'FORCE') GO TO 395
      IF(IFRCPNT .EQV. .FALSE.) GO TO 395
      CALL RDFRCPNT(IFRAG)
      GO TO 200
  395 CONTINUE
C
      IF(WORD.NE.'REPULSIV') GO TO 400
      CALL RDREP(NRPTS(IFRAG),IFRAG)
      IREP = 1
      GO TO 200
C
  400 CONTINUE
      IF(WORD.NE.'PROJECTI') GO TO 406
      WORD='        '
      LGSTR=-8
      CALL GSTRNG(WORD,LGSTR)
      IF(WORD.EQ.'BASIS   ') CALL RDPAO(IFRAG)
      IERR = 0
      IF(WORD.EQ.'WAVEFUNC') THEN
        NMOS = IFIND('NMOS    ',IERR)
        NAOS = IFIND('NAOS    ',IERR)
        NAO(ISET(IFRAG))  = NAOS
        CALL RDPMO(IFRAG,NMOS,NAOS,PROVEC,FOCKMA,
     *             MXBF,MXMO,MXMO2,NFRG,NTMOF)
      END IF
      GO TO 200
C
C  SET ALL UNASSIGNED MULTIPLICITY VALUES TO 1, THESE ARE CLOSED SHELLS
C
  406 CONTINUE
      IF (MULMAT(IFRAG).NE.0) GO TO 407
      MULMAT(IFRAG) = 1
C
  407 CONTINUE
      IF(WORD.NE.'CTVEC   '   .AND.  WORD.NE.'CANONVEC') GO TO 420
      NOCC(ISET(IFRAG)) = IFIND('NOCC    ',IERR)
      NCTMO(ISET(IFRAG))  = IFIND('NCTMOS  ',IERR)
      NVIR(ISET(IFRAG)) = NCTMO(ISET(IFRAG)) - NOCC(ISET(IFRAG))
      CALL RDCANV(IFRAG,CTVEC,MXBF,NTCTMOF)
      GO TO 200
C
  420 CONTINUE
      IF(WORD.NE.'LJPOTENT') GO TO 430
      IERR = 0
      NMLJ(1) = IFIND('N       ',IERR)
      NMLJ(2) = IFIND('M       ',IERR)
      CALL RDLJPOT(NLJPTS(IFRAG),IFRAG)
      GO TO 200
C
  430 CONTINUE
      IF(WORD.EQ.'$END    ') THEN
         ICHGP = ICHGPX+2*ICHGPY
         IF (SCROFF.EQ.1.0D+04 .AND. ICHGPY .GT. 1) SCROFF = 11
         RETURN
      END IF
C
C     WE SHOULD NEVER GET HERE, ERROR
C
      IF (MASWRK) WRITE(IW,9020) WORD
      CALL ABRT
C
  999 CONTINUE
      IF (MASWRK) WRITE(IW,9100)
      CALL ABRT
C
      RETURN
 9010 FORMAT(1X,A8,'NOT FOUND, PLEASE CHECK FOR ERRORS')
 9011 FORMAT(1X,'ERROR, END OF FILE READING',A8,' INPUT GROUP (RDFSTR)')
 9020 FORMAT(1X,A8,' IS AN UNRECOGNIZED KEYWORD')
 9100 FORMAT(1X,'YOU MUST GIVE THE NUMBER OF POINTS TO BE READ IN BEFORE
     *       GIVING THE PERTINENT POINTS')
 9250 FORMAT(1X,'ERROR, READING SCREEN1 GROUP BUT SCREEN',I1,' GROUP
     *       WAS FOUND ALREADY')
 9260 FORMAT(1X,'ERROR, READING SCREEN2 GROUP BUT SCREEN',I1,' GROUP
     *       WAS FOUND ALREADY')
 9261 FORMAT(1X,'ERROR, READING SCREEN3 GROUP BUT SCREEN',I1,' GROUP
     *       WAS FOUND ALREADY')
 9262 FORMAT(1X,'ERROR, READING SCREEN4 GROUP BUT SCREEN',I1,' GROUP
     *       WAS FOUND ALREADY')
 9263 FORMAT(1X,'ERROR, READING SCREEN5 GROUP BUT SCREEN',I1,' GROUP
     *       WAS FOUND ALREADY')
 9310 FORMAT(1X,'CONFUSED WHILE READING EFP POLARIZATION DAMPING ',
     *            'PARAMETERS:'/
     *       1X,'SPECIFY ISCRPOL=0 TO ALLOW EXPONENTIAL DAMPING'/)
 9320 FORMAT(1X,'CONFUSED WHILE READING EFP POLARIZATION DAMPING ',
     *            'PARAMETERS:'/
     *       1X,'SPECIFY ISCRPOL=1 TO ALLOW GAUSSIAN DAMPING'/)
C
      END
C*MODULE EFINP   *DECK ROTMAT
      SUBROUTINE ROTMAT(A1,A2,A3,B1,B2,B3,C1,C2,C3,T)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      PARAMETER (ONE=1.00D+00, ZERO = 0.00D+00)
C
      DIMENSION A(3), B(3), C(3), T(3,3)
C
      A(1)=A1
      A(2)=A2
      A(3)=A3
      B(1)=B1
      B(2)=B2
      B(3)=B3
      C(1)=C1
      C(2)=C2
      C(3)=C3
C
      T1NORM = ZERO
      T2NORM = ZERO
      DO 100 I=1,3
        T(I,1) = B(I) - A(I)
        T1NORM = T1NORM + T(I,1)*T(I,1)
        T(I,2) = C(I) - A(I)
        T2NORM = T2NORM + T(I,2)*T(I,2)
  100 CONTINUE
C
      T1NORM = ONE/SQRT(T1NORM)
      T2NORM = ONE/SQRT(T2NORM)
C
      DO 150 I = 1,3
        T(I,1) = T1NORM*T(I,1)
        T(I,2) = T2NORM*T(I,2)
  150 CONTINUE
C
      DOTPRD = T(1,1)*T(1,2) + T(2,1)*T(2,2) + T(3,1)*T(3,2)
      T(1,2) = T(1,2) - DOTPRD*T(1,1)
      T(2,2) = T(2,2) - DOTPRD*T(2,1)
      T(3,2) = T(3,2) - DOTPRD*T(3,1)
C
      T(1,3) = T(2,1)*T(3,2) - T(3,1)*T(2,2)
      T(2,3) = T(3,1)*T(1,2) - T(1,1)*T(3,2)
      T(3,3) = T(1,1)*T(2,2) - T(2,1)*T(1,2)
C
      DO 300 J = 1,3
        VECSQR = ZERO
        DO 200 I = 1,3
          VECSQR = VECSQR + T(I,J)*T(I,J)
  200   CONTINUE
        VECSQR = SQRT(VECSQR)
        DO 250 I = 1,3
          T(I,J) = T(I,J) / VECSQR
  250   CONTINUE
  300 CONTINUE
C
      RETURN
      END
C*MODULE EFINP   *DECK RELVC2
      SUBROUTINE RELVC2(R,J,K)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXATM=2000)
      PARAMETER (MXFRG=1050)
      DIMENSION R(3),XYZ1(3),XYZ2(3)
C
      CHARACTER*8 PTNAM
      CHARACTER*6 FRGNAM
C
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C
      NATOMS = NAT
      IF (J.GT.NATOMS) THEN
         NFRG = (J-NATOMS)/3
         I123 = MOD(J-NATOMS,3)
         IF (I123.GT.0) THEN
            NFRG = NFRG + 1
         ELSE
            I123 = 3
         END IF
         XYZ1(1) = XCRD(I123,NFRG)
         XYZ1(2) = YCRD(I123,NFRG)
         XYZ1(3) = ZCRD(I123,NFRG)
      ELSE
         DO 20 I = 1,3
           XYZ1(I) = C(I,J)
  20     CONTINUE
      END IF
C
      IF (K.GT.NATOMS) THEN
        NFRG = (K-NATOMS)/3
        I123 = MOD(K-NATOMS,3)
        IF (I123.GT.0) THEN
           NFRG = NFRG + 1
        ELSE
           I123 = 3
        END IF
        XYZ2(1) = XCRD(I123,NFRG)
        XYZ2(2) = YCRD(I123,NFRG)
        XYZ2(3) = ZCRD(I123,NFRG)
      ELSE
        DO 40 I = 1,3
           XYZ2(I) = C(I,K)
   40   CONTINUE
      END IF
C
C     R IS THE RELATIVE VECTOR FROM ATOM K TO ATOM J
C
C---      WRITE(6,*) 'XYZ1',(XYZ1(JJ),JJ=1,3)
C---      WRITE(6,*) 'XYZ2',(XYZ2(JJ),JJ=1,3)
      DO 10 I=1,3
         R(I)=XYZ1(I)-XYZ2(I)
   10 CONTINUE
      RETURN
      END
C
C*MODULE EFINP   *DECK WATRHF
      SUBROUTINE WATRHF(IFRAG)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL DOMTMP,DODTMP,DOQTMP,DOOTMP
C
      DIMENSION AREL(4,4,2),CREL(4,4,1)
C
      PARAMETER (MXPT=2000, MXFRG=1050, MXFGPT=12000, MXIFRQ=12,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (ZERO=0.0D+00)
C
      CHARACTER*8 MNAME,PNAME,RNAME,DPNAME,FNAME
C
      COMMON /DOTMP / DOMTMP(MXPT),DODTMP(MXPT),DOQTMP(MXPT),
     *                DOOTMP(MXPT)
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ,MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
C
      EQUIVALENCE (AREL(1,1,2),CREL(1,1,1))
C
C        STANDARD PARAMETERIZATION FOR WATER RHF EFP
C        THIS WAS OBTAINED LONG BEFORE RUNTY=MAKEFP, DOING STEP BY
C        STEP CALCULATIONS.  HENCE, THE POLARIZABITY DATA BELOW WERE
C        OBTAINED BY LOCAL=BOYS WITH $LOCAL POLNUM=.TRUE.  TODAY,
C        RUEDENBERG LOCALIZATION WITH ANALYTIC POLARIZABILITY DATA
C        GIVEN BY A QUICK RUNTYP=MAKEFP WOULD BE A BIT DIFFERENT.
C
      IEFC = 1
      IEFD = 1
      IEFQ = 1
      IEFO = 1
      IEFP = 1
      IREP = 1
C   MEANS 1 (GAUSSIAN-TYPE) FOR AI-FRAG
C     AND 1 (GAUSSIAN-TYPE) FOR FRAG-FRAG
      ICHGP= 3
      NMPTS(IFRAG)=8
      NPPTS(IFRAG)=5
      NRPTS(IFRAG)=3
      NDPTS(IFRAG)=0
C
C     INITIALIZE LOCAL COMMON BLOCK FRGSTD
C
      CALL VCLR(CORD(1,1),1,50*MXPT)
      DO 10 I=1,MXPT
         INLPR(4*(I-1)+1)=0
         INLPR(4*(I-1)+2)=0
         INLPR(4*(I-1)+3)=0
         INLPR(4*(I-1)+4)=0
         IKFR(I)=0
         IKLR(I)=0
         MNAME(I)='        '
         PNAME(I)='        '
         RNAME(I)='        '
         DOMTMP(I) =  .FALSE.
         DODTMP(I) =  .FALSE.
         DOQTMP(I) =  .FALSE.
         DOOTMP(I) =  .FALSE.
   10 CONTINUE
C
C COORDINATES
C
      MNAME(1) = 'ZO1     '
      CORD(1,1) = ZERO
      CORD(2,1) = ZERO
      CORD(3,1) = -.119151D+00
      FPMASS(1) = 15.99491D+00
      FPNUC(1) = 8.0D+00
      MNAME(2) = 'ZH2     '
      CORD(1,2) = -1.431042D+00
      CORD(2,2) = ZERO
      CORD(3,2) = .945510D+00
      FPMASS(2) = 1.007825D+00
      FPNUC(2) = 1.0D+00
      MNAME(3) = 'ZH3     '
      CORD(1,3) = 1.431042D+00
      CORD(2,3) = ZERO
      CORD(3,3) = .945510D+00
      FPMASS(3) = 1.007825D+00
      FPNUC(3) = 1.0D+00
      MNAME(4) = 'O1      '
      CORD(1,4) = ZERO
      CORD(2,4) = ZERO
      CORD(3,4) = -.119151D+00
      FPMASS(4) = ZERO
      FPNUC(4) = ZERO
      MNAME(5) = 'H2      '
      CORD(1,5) = -1.431042D+00
      CORD(2,5) = ZERO
      CORD(3,5) = .945510D+00
      FPMASS(5) = ZERO
      FPNUC(5) = ZERO
      MNAME(6) = 'H3      '
      CORD(1,6) = 1.431042D+00
      CORD(2,6) = ZERO
      CORD(3,6) = .945510D+00
      FPMASS(6) = ZERO
      FPNUC(6) = ZERO
      MNAME(7) = 'B12     '
      CORD(1,7) = -.715521D+00
      CORD(2,7) = ZERO
      CORD(3,7) = .413179D+00
      FPMASS(7) = ZERO
      FPNUC(7) = ZERO
      MNAME(8) = 'B13     '
      CORD(1,8) =  .715521D+00
      CORD(2,8) = ZERO
      CORD(3,8) =  .413179D+00
      FPMASS(8) = ZERO
      FPNUC(8) = ZERO
C CHARGES
C      2D-7 ADDED TO EACH OF FIVE NEGATIVE CHARGES BELOW,
C      TO ENSURE TOTAL CHARGE IS EXACTLY ZERO (OCT 2006)
      DOMTMP(1) = .TRUE.
      ACHG(1,1) = 8.0D+00
      ACHG(2,1) = ZERO
      DOMTMP(2) = .TRUE.
      ACHG(1,2) = 1.0D+00
      ACHG(2,2) = ZERO
      DOMTMP(3) = .TRUE.
      ACHG(1,3) = 1.0D+00
      ACHG(2,3) = ZERO
      DOMTMP(4) = .TRUE.
      ACHG(1,4) = -8.2108272D+00
      ACHG(2,4) = ZERO
      DOMTMP(5) = .TRUE.
      ACHG(1,5) = -0.5566522D+00
      ACHG(2,5) = ZERO
      DOMTMP(6) = .TRUE.
      ACHG(1,6) = -0.5566522D+00
      ACHG(2,6) = ZERO
      DOMTMP(7) = .TRUE.
      ACHG(1,7) = -0.3379342D+00
      ACHG(2,7) = ZERO
      DOMTMP(8) = .TRUE.
      ACHG(1,8) = -0.3379342D+00
      ACHG(2,8) = ZERO
C DIPOLES
      DODTMP(4) = .TRUE.
      ADIP(1,4) = ZERO
      ADIP(2,4) = ZERO
      ADIP(3,4) = .435528D+00
      DODTMP(5) = .TRUE.
      ADIP(1,5) = -.053498D+00
      ADIP(2,5) = ZERO
      ADIP(3,5) = .026668D+00
      DODTMP(6) = .TRUE.
      ADIP(1,6) = .053498D+00
      ADIP(2,6) = ZERO
      ADIP(3,6) = .026668D+00
      DODTMP(7) = .TRUE.
      ADIP(1,7) = .145227D+00
      ADIP(2,7) = ZERO
      ADIP(3,7) = -.106534D+00
      DODTMP(8) = .TRUE.
      ADIP(1,8) = -.145227D+00
      ADIP(2,8) = ZERO
      ADIP(3,8) = -.106534D+00
C QUADRUPOLES
      DOQTMP(4) = .TRUE.
      AQAD(1,4) = -3.600378D+00
      AQAD(2,4) = -4.554786D+00
      AQAD(3,4) = -4.072824D+00
      AQAD(4,4) = ZERO
      AQAD(5,4) = ZERO
      AQAD(6,4) = ZERO
      DOQTMP(5) = .TRUE.
      AQAD(1,5) = -.273844D+00
      AQAD(2,5) = -.284801D+00
      AQAD(3,5) = -.273119D+00
      AQAD(4,5) = ZERO
      AQAD(5,5) = -.008071D+00
      AQAD(6,5) = ZERO
      DOQTMP(6) = .TRUE.
      AQAD(1,6) = -.273844D+00
      AQAD(2,6) = -.284801D+00
      AQAD(3,6) = -.273119D+00
      AQAD(4,6) = ZERO
      AQAD(5,6) = .008071D+00
      AQAD(6,6) = ZERO
      DOQTMP(7) = .TRUE.
      AQAD(1,7) = -.123332D+00
      AQAD(2,7) = -.156586D+00
      AQAD(3,7) = -.135104D+00
      AQAD(4,7) = ZERO
      AQAD(5,7) = -.012710D+00
      AQAD(6,7) = ZERO
      DOQTMP(8) = .TRUE.
      AQAD(1,8) = -.123332D+00
      AQAD(2,8) = -.156586D+00
      AQAD(3,8) = -.135104D+00
      AQAD(4,8) = ZERO
      AQAD(5,8) = .012710D+00
      AQAD(6,8) = ZERO
C OCTUPOLES
      DOOTMP(4) = .TRUE.
      AOCT(1,4) = ZERO
      AOCT(2,4) = ZERO
      AOCT(3,4) = 1.001522D+00
      AOCT(4,4) = ZERO
      AOCT(5,4) = .289430D+00
      AOCT(6,4) = ZERO
      AOCT(7,4) = .336875D+00
      AOCT(8,4) = ZERO
      AOCT(9,4) = ZERO
      AOCT(10,4) = ZERO
      DOOTMP(5) = .TRUE.
      AOCT(1,5) = -.050127D+00
      AOCT(2,5) = ZERO
      AOCT(3,5) = .018626D+00
      AOCT(4,5) = ZERO
      AOCT(5,5) = -.000173D+00
      AOCT(6,5) = -.020918D+00
      AOCT(7,5) = .008664D+00
      AOCT(8,5) = -.013564D+00
      AOCT(9,5) = ZERO
      AOCT(10,5) = ZERO
      DOOTMP(6) = .TRUE.
      AOCT(1,6) = .050127D+00
      AOCT(2,6) = ZERO
      AOCT(3,6) = .018626D+00
      AOCT(4,6) = ZERO
      AOCT(5,6) = -.000173D+00
      AOCT(6,6) = .020918D+00
      AOCT(7,6) = .008664D+00
      AOCT(8,6) = .013564D+00
      AOCT(9,6) = ZERO
      AOCT(10,6) = ZERO
      DOOTMP(7) = .TRUE.
      AOCT(1,7) = .442205D+00
      AOCT(2,7) = ZERO
      AOCT(3,7) = -.296631D+00
      AOCT(4,7) = ZERO
      AOCT(5,7) = -.097197D+00
      AOCT(6,7) = .145673D+00
      AOCT(7,7) = -.100224D+00
      AOCT(8,7) = .147545D+00
      AOCT(9,7) = ZERO
      AOCT(10,7) = ZERO
      DOOTMP(8) = .TRUE.
      AOCT(1,8) = -.442205D+00
      AOCT(2,8) = ZERO
      AOCT(3,8) = -.296631D+00
      AOCT(4,8) = ZERO
      AOCT(5,8) = -.097197D+00
      AOCT(6,8) = -.145673D+00
      AOCT(7,8) = -.100224D+00
      AOCT(8,8) = -.147545D+00
      AOCT(9,8) = ZERO
      AOCT(10,8) = ZERO
C SCREENING AB INITIO-FRAGMENT
      BMULT(1) = 3.171069D+00
      AMULT(1) = .307981D+00
      BMULT(2) = -.743555D+00
      AMULT(2) = .220351D+00
      BMULT(3) = -.743555D+00
      AMULT(3) = .220351D+00
      BMULT(4) = 3.063892D+00
      AMULT(4) = .308167D+00
      BMULT(5) = -1.501489D+00
      AMULT(5) = .233582D+00
      BMULT(6) = -1.501489D+00
      AMULT(6) = .233582D+00
      BMULT(7) = 1.990144D+00
      AMULT(7) = .440029D+00
      BMULT(8) = 1.990144D+00
      AMULT(8) = .440029D+00
C SCREENING FRAGMENT-FRAGMENT (SAME AS AI-FRAGMENT)
      BMULT2(1) = 3.171069D+00
      AMULT2(1) = .307981D+00
      BMULT2(2) = -.743555D+00
      AMULT2(2) = .220351D+00
      BMULT2(3) = -.743555D+00
      AMULT2(3) = .220351D+00
      BMULT2(4) = 3.063892D+00
      AMULT2(4) = .308167D+00
      BMULT2(5) = -1.501489D+00
      AMULT2(5) = .233582D+00
      BMULT2(6) = -1.501489D+00
      AMULT2(6) = .233582D+00
      BMULT2(7) = 1.990144D+00
      AMULT2(7) = .440029D+00
      BMULT2(8) = 1.990144D+00
      AMULT2(8) = .440029D+00
C POLARIZABLE POINTS
      PNAME(1) ='LMO1    '
      PCORD(1,1) = ZERO
      PCORD(2,1) = ZERO
      PCORD(3,1) = -.118948D+00
      POLT(1,1) = 0.001372D+00
      POLT(2,1) = 0.001315D+00
      POLT(3,1) = 0.001555D+00
      POLT(4,1) = ZERO
      POLT(5,1) = ZERO
      POLT(6,1) = ZERO
      POLT(7,1) = ZERO
      POLT(8,1) = ZERO
      POLT(9,1) = ZERO
      PNAME(2) ='LMO2    '
      PCORD(1,2) = .761149D+00
      PCORD(2,2) = ZERO
      PCORD(3,2) = .486642D+00
      POLT(1,2) = 2.093639D+00
      POLT(2,2) = 0.786767D+00
      POLT(3,2) = 1.541635D+00
      POLT(4,2) = ZERO
      POLT(5,2) = 0.951176D+00
      POLT(6,2) = ZERO
      POLT(7,2) = ZERO
      POLT(8,2) = 1.315027D+00
      POLT(9,2) = ZERO
      PNAME(3) ='LMO3    '
      PCORD(1,3) = -.761149D+00
      PCORD(2,3) = ZERO
      PCORD(3,3) = .486642D+00
      POLT(1,3) = 2.093639D+00
      POLT(2,3) = 0.786767D+00
      POLT(3,3) = 1.541635D+00
      POLT(4,3) = ZERO
      POLT(5,3) = -0.951176D+00
      POLT(6,3) = ZERO
      POLT(7,3) = ZERO
      POLT(8,3) = -1.315027D+00
      POLT(9,3) = ZERO
      PNAME(4) ='LMO4    '
      PCORD(1,4) = ZERO
      PCORD(2,4) = -.489534D+00
      PCORD(3,4) = -.407726D+00
      POLT(1,4) = 1.386526D+00
      POLT(2,4) = 0.729779D+00
      POLT(3,4) = 1.052409D+00
      POLT(4,4) = ZERO
      POLT(5,4) = ZERO
      POLT(6,4) = 0.086979D+00
      POLT(7,4) = ZERO
      POLT(8,4) = ZERO
      POLT(9,4) = 0.655755D+00
      PNAME(5) ='LMO5    '
      PCORD(1,5) = ZERO
      PCORD(2,5) = .489534D+00
      PCORD(3,5) = -.407726D+00
      POLT(1,5) = 1.386526D+00
      POLT(2,5) = 0.729779D+00
      POLT(3,5) = 1.052409D+00
      POLT(4,5) = ZERO
      POLT(5,5) = ZERO
      POLT(6,5) = -0.086979D+00
      POLT(7,5) = ZERO
      POLT(8,5) = ZERO
      POLT(9,5) = -0.655755D+00
C AB INITIO/EFP REPULSIVE POTENTIAL
      RNAME(1) = MNAME(4)
      RCORD(1,1) = CORD(1,4)
      RCORD(2,1) = CORD(2,4)
      RCORD(3,1) = CORD(3,4)
      IKFR(1) = 1
      IKLR(1) = 2
      TCLPR(1) = -.00015658525D+00
      INLPR(1) = 2
      TZLPR(1) = .018861917D+00
      TCLPR(2) = 1.2469537D+00
      INLPR(2) = 2
      TZLPR(2) = .41985964D+00
      RNAME(2) = MNAME(5)
      RCORD(1,2) = CORD(1,5)
      RCORD(2,2) = CORD(2,5)
      RCORD(3,2) = CORD(3,5)
      IKFR(2) = 3
      IKLR(2) = 4
      TCLPR(3) = .00044035869D+00
      INLPR(3) = 2
      TZLPR(3) = .064324281D+00
      TCLPR(4) = .11725664D+00
      INLPR(4) = 2
      TZLPR(4) = .69632546D+00
      RNAME(3) = MNAME(6)
      RCORD(1,3) = CORD(1,6)
      RCORD(2,3) = CORD(2,6)
      RCORD(3,3) = CORD(3,6)
      IKFR(3) = 5
      IKLR(3) = 6
      TCLPR(5) = .00044035869D+00
      INLPR(5) = 2
      TZLPR(5) = .064324281D+00
      TCLPR(6) = .11725664D+00
      INLPR(6) = 2
      TZLPR(6) = .69632546D+00
C EFP/EFP REPULSIVE POTENTIAL
      CREL(1,1,1) = -24.269765D+00
      AREL(1,1,1) = 1.4362041D+00
      CREL(1,2,1) = 3.7022852D+00
      AREL(1,2,1) = 1.6618349D+00
      CREL(1,3,1) = 3.7022852D+00
      AREL(1,3,1) = 1.6618349D+00
      CREL(1,4,1) = 4.2645641D+00
      AREL(1,4,1) = 1.2578017D+00
      CREL(2,1,1) = 3.7022852D+00
      AREL(2,1,1) = 1.6618349D+00
      CREL(2,2,1) = 6.2316930D+00
      AREL(2,2,1) = 3.5264849D+00
      CREL(2,3,1) = 6.2316930D+00
      AREL(2,3,1) = 3.5264849D+00
      CREL(2,4,1) = -.42798437D+00
      AREL(2,4,1) = 1.1335629D+00
      CREL(3,1,1) = 3.7022852D+00
      AREL(3,1,1) = 1.6618349D+00
      CREL(3,2,1) = 6.2316930D+00
      AREL(3,3,1) = 3.5264849D+00
      CREL(3,3,1) = 6.2316930D+00
      CREL(3,4,1) = -.42798437D+00
      AREL(3,4,1) = 1.1335629D+00
      AREL(3,2,1) = 3.5264849D+00
      CREL(4,1,1) = 4.2645641D+00
      AREL(4,1,1) = 1.2578017D+00
      CREL(4,2,1) = -.42798437D+00
      AREL(4,2,1) = 1.1335629D+00
      CREL(4,3,1) = -.42798437D+00
      AREL(4,3,1) = 1.1335629D+00
      CREL(4,4,1) = 128.74969D+00
      AREL(4,4,1) = 1.8712451D+00
      CALL DAWRIT(IDAF,IODA,AREL,4*4*2,75,0)
C
      RETURN
      END
C*MODULE EFINP   *DECK WATDFT
      SUBROUTINE WATDFT(IFRAG)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL DOMTMP,DODTMP,DOQTMP,DOOTMP
C
      DIMENSION AREL(4,4,2),CREL(4,4,1)
C
      PARAMETER (MXPT=2000, MXFRG=1050, MXFGPT=12000, MXIFRQ=12,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (ZERO=0.0D+00)
C
      CHARACTER*8 MNAME,PNAME,RNAME,DPNAME,FNAME
C
      COMMON /DOTMP / DOMTMP(MXPT),DODTMP(MXPT),DOQTMP(MXPT),
     *                DOOTMP(MXPT)
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ,MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
C
      EQUIVALENCE (AREL(1,1,2),CREL(1,1,1))
C
C         IVANA ADAMOVIC'S EFP PARAMETERIZATION FOR DFT WATER
C         ADDED 11/25/2002
C
      IEFC = 1
      IEFD = 1
      IEFQ = 1
      IEFO = 1
      IEFP = 1
      IREP = 1
C  1 - GAUSSIAN SCREEN FOR AI-FRAG AND
C  2 - EXPONENTIAL SCREEN FOR FRAG-FRAG
      ICHGP= 5
      NMPTS(IFRAG)=5
      NPPTS(IFRAG)=5
      NRPTS(IFRAG)=3
      NDPTS(IFRAG)=0
C
C     INITIALIZE LOCAL COMMON BLOCK FRGSTD
C
      CALL VCLR(CORD(1,1),1,50*MXPT)
      DO 10 I=1,MXPT
         INLPR(4*(I-1)+1)=0
         INLPR(4*(I-1)+2)=0
         INLPR(4*(I-1)+3)=0
         INLPR(4*(I-1)+4)=0
         IKFR(I)=0
         IKLR(I)=0
         MNAME(I)='        '
         PNAME(I)='        '
         RNAME(I)='        '
         DOMTMP(I) =  .FALSE.
         DODTMP(I) =  .FALSE.
         DOQTMP(I) =  .FALSE.
         DOOTMP(I) =  .FALSE.
   10 CONTINUE
C
C COORDINATES
C  NOTE, THE COORDINATES ARE IDENTICAL TO THE RHF/DH(D,P) COORDINATES.
C
      MNAME(1) = 'O1      '
      CORD(1,1) = ZERO
      CORD(2,1) = ZERO
      CORD(3,1) = -.119151D+00
      FPMASS(1) = 15.99491D+00
      FPNUC(1) = 8.0D+00
      MNAME(2) = 'H2      '
      CORD(1,2) = -1.431042D+00
      CORD(2,2) = ZERO
      CORD(3,2) = .945510D+00
      FPMASS(2) = 1.007825D+00
      FPNUC(2) = 1.0D+00
      MNAME(3) = 'H3      '
      CORD(1,3) = 1.431042D+00
      CORD(2,3) = ZERO
      CORD(3,3) = .945510D+00
      FPMASS(3) = 1.007825D+00
      FPNUC(3) = 1.0D+00
      MNAME(4) = 'B12     '
      CORD(1,4) = -.715521D+00
      CORD(2,4) = ZERO
      CORD(3,4) = .413179D+00
      FPMASS(4) = ZERO
      FPNUC(4) = ZERO
      MNAME(5) = 'B13     '
      CORD(1,5) =  .715521D+00
      CORD(2,5) = ZERO
      CORD(3,5) =  .413179D+00
      FPMASS(5) = ZERO
      FPNUC(5) = ZERO
C
C CHARGES
C      4D-7 ADDED TO EACH OF FIVE NEGATIVE CHARGES BELOW,
C      TO ENSURE TOTAL CHARGE IS EXACTLY ZERO (OCT 2006)
C
      DOMTMP(1) = .TRUE.
      ACHG(1,1) = -8.2245784D+00
      ACHG(2,1) =  8.000000D+00
      DOMTMP(2) = .TRUE.
      ACHG(1,2) = -.5790554D+00
      ACHG(2,2) =  1.00000D+00
      DOMTMP(3) = .TRUE.
      ACHG(1,3) = -.5790554D+00
      ACHG(2,3) =  1.00000D+00
      DOMTMP(4) = .TRUE.
      ACHG(1,4) = -.3086554D+00
      ACHG(2,4) = ZERO
      DOMTMP(5) = .TRUE.
      ACHG(1,5) = -.3086554D+00
      ACHG(2,5) = ZERO
C
C DIPOLES
C
      DODTMP(1) = .TRUE.
      ADIP(1,1) = ZERO
      ADIP(2,1) = ZERO
      ADIP(3,1) = .439368D+00
      DODTMP(2) = .TRUE.
      ADIP(1,2) = -.045030D+00
      ADIP(2,2) = ZERO
      ADIP(3,2) = .019745D+00
      DODTMP(3) = .TRUE.
      ADIP(1,3) = .045030D+00
      ADIP(2,3) = ZERO
      ADIP(3,3) = .019745D+00
      DODTMP(4) = .TRUE.
      ADIP(1,4) = .151206D+00
      ADIP(2,4) = ZERO
      ADIP(3,4) = -.116204D+00
      DODTMP(5) = .TRUE.
      ADIP(1,5) = -.151206D+00
      ADIP(2,5) = ZERO
      ADIP(3,5) = -.116204D+00
C
C QUADRUPOLES
C
      DOQTMP(1) = .TRUE.
      AQAD(1,1) = -3.545741D+00
      AQAD(2,1) = -4.529667D+00
      AQAD(3,1) = -4.022426D+00
      AQAD(4,1) = ZERO
      AQAD(5,1) = ZERO
      AQAD(6,1) = ZERO
      DOQTMP(2) = .TRUE.
      AQAD(1,2) = -.305693D+00
      AQAD(2,2) = -.313535D+00
      AQAD(3,2) = -.304098D+00
      AQAD(4,2) = ZERO
      AQAD(5,2) =  -.005554D+00
      AQAD(6,2) = ZERO
      DOQTMP(3) = .TRUE.
      AQAD(1,3) = -.305693D+00
      AQAD(2,3) = -.313535D+00
      AQAD(3,3) = -.304098D+00
      AQAD(4,3) = ZERO
      AQAD(5,3) = .005554D+00
      AQAD(6,3) = ZERO
      DOQTMP(4) = .TRUE.
      AQAD(1,4) = -.096367D+00
      AQAD(2,4) = -.130668D+00
      AQAD(3,4) = -.106838D+00
      AQAD(4,4) = ZERO
      AQAD(5,4) = -.011666D+00
      AQAD(6,4) = ZERO
      DOQTMP(5) = .TRUE.
      AQAD(1,5) = -.096367D+00
      AQAD(2,5) = -.130668D+00
      AQAD(3,5) = -.106838D+00
      AQAD(4,5) = ZERO
      AQAD(5,5) = .011666D+00
      AQAD(6,5) = ZERO
C
C OCTUPOLES
C
      DOOTMP(1) = .TRUE.
      AOCT(1,1) = ZERO
      AOCT(2,1) = ZERO
      AOCT(3,1) = 1.073886D+00
      AOCT(4,1) = ZERO
      AOCT(5,1) = .313291D+00
      AOCT(6,1) = ZERO
      AOCT(7,1) = .360352D+00
      AOCT(8,1) = ZERO
      AOCT(9,1) = ZERO
      AOCT(10,1) = ZERO
      DOOTMP(2) = .TRUE.
      AOCT(1,2) = -.044409D+00
      AOCT(2,2) = ZERO
      AOCT(3,2) = .012008D+00
      AOCT(4,2) = ZERO
      AOCT(5,2) = -.000817D+00
      AOCT(6,2) = -.018142D+00
      AOCT(7,2) = .006012D+00
      AOCT(8,2) = -.012450D+00
      AOCT(9,2) = ZERO
      AOCT(10,2) = ZERO
      DOOTMP(3) = .TRUE.
      AOCT(1,3) = .044409D+00
      AOCT(2,3) = ZERO
      AOCT(3,3) = .012008D+00
      AOCT(4,3) = ZERO
      AOCT(5,3) = -.000817D+00
      AOCT(6,3) = .018142D+00
      AOCT(7,3) = .006012D+00
      AOCT(8,3) = .012450D+00
      AOCT(9,3) = ZERO
      AOCT(10,3) = ZERO
      DOOTMP(4) = .TRUE.
      AOCT(1,4) = .467428D+00
      AOCT(2,4) = ZERO
      AOCT(3,4) = -.336104D+00
      AOCT(4,4) = ZERO
      AOCT(5,4) = -.109886D+00
      AOCT(6,4) = .153403D+00
      AOCT(7,4) = -.113583D+00
      AOCT(8,4) = .156548D+00
      AOCT(9,4) = ZERO
      AOCT(10,4) = ZERO
      DOOTMP(5) = .TRUE.
      AOCT(1,5) = -.467428D+00
      AOCT(2,5) = ZERO
      AOCT(3,5) = -.336104D+00
      AOCT(4,5) = ZERO
      AOCT(5,5) = -.109886D+00
      AOCT(6,5) = -.153403D+00
      AOCT(7,5) = -.113583D+00
      AOCT(8,5) = -.156548D+00
      AOCT(9,5) = ZERO
      AOCT(10,5) = ZERO
C
C SCREENING FOR AB INITIO-FRAGMENT
C
      BMULT(1) = .186119D+00
      AMULT(1) = .549105D+00
      BMULT(2) = .112182D+00
      AMULT(2) = .389541D+00
      BMULT(3) = .112182D+00
      AMULT(3) = .389541D+00
      BMULT(4) = -.717580D+00
      AMULT(4) = .962143D+00
      BMULT(5) = -.717580D+00
      AMULT(5) = .962143D+00
C
C SCREENING2 FOR FRAGMENT-FRAGMENT
C
      BMULT2(1) = 1.000000D+00
      AMULT2(1) = 1.960183D+00
      BMULT2(2) = 1.000000D+00
      AMULT2(2) = 2.383508D+00
      BMULT2(3) = 1.000000D+00
      AMULT2(3) = 2.383508D+00
      BMULT2(4) = 1.000000D+00
      AMULT2(4) = 9.999913D+00
      BMULT2(5) = 1.000000D+00
      AMULT2(5) = 9.999913D+00
C
C POLARIZABLE POINTS
C
      PNAME(1) ='LMO1    '
      PCORD(1,1) = ZERO
      PCORD(2,1) = ZERO
      PCORD(3,1) = -.118741D+00
      POLT(1,1) = .003101D+00
      POLT(2,1) = .004553D+00
      POLT(3,1) = .002822D+00
      POLT(4,1) = ZERO
      POLT(5,1) = ZERO
      POLT(6,1) = ZERO
      POLT(7,1) = ZERO
      POLT(8,1) = ZERO
      POLT(9,1) = ZERO
      PNAME(2) ='LMO2    '
      PCORD(1,2) = .767899D+00
      PCORD(2,2) = ZERO
      PCORD(3,2) = .494658D+00
      POLT(1,2) = 2.109350D+00
      POLT(2,2) = .835171D+00
      POLT(3,2) = 1.556153D+00
      POLT(4,2) = ZERO
      POLT(5,2) = 1.313981D+00
      POLT(6,2) = ZERO
      POLT(7,2) = ZERO
      POLT(8,2) = .934523D+00
      POLT(9,2) = ZERO
      PNAME(3) ='LMO3    '
      PCORD(1,3) = -.767899D+00
      PCORD(2,3) = ZERO
      PCORD(3,3) = .494658D+00
      POLT(1,3) = 2.109350D+00
      POLT(2,3) = .835171D+00
      POLT(3,3) = 1.556153D+00
      POLT(4,3) = ZERO
      POLT(5,3) = -1.313981D+00
      POLT(6,3) = ZERO
      POLT(7,3) = ZERO
      POLT(8,3) = -.934523D+00
      POLT(9,3) = ZERO
      PNAME(4) ='LMO4    '
      PCORD(1,4) = ZERO
      PCORD(2,4) = -.492163D+00
      PCORD(3,4) = -.404375D+00
      POLT(1,4) = 1.519500D+00
      POLT(2,4) = .736181D+00
      POLT(3,4) = 1.183064D+00
      POLT(4,4) = ZERO
      POLT(5,4) = ZERO
      POLT(6,4) = .780917D+00
      POLT(7,4) = ZERO
      POLT(8,4) = ZERO
      POLT(9,4) = .089060D+00
      PNAME(5) ='LMO5    '
      PCORD(1,5) = ZERO
      PCORD(2,5) = .492163D+00
      PCORD(3,5) = -.404375D+00
      POLT(1,5) = 1.519500D+00
      POLT(2,5) = .736181D+00
      POLT(3,5) = 1.183064D+00
      POLT(4,5) = ZERO
      POLT(5,5) = ZERO
      POLT(6,5) = -.780917D+00
      POLT(7,5) = ZERO
      POLT(8,5) = ZERO
      POLT(9,5) = -.089060D+00
C
C AB INITIO/EFP REPULSIVE POTENTIAL
C
      RNAME(1) = MNAME(1)
      RCORD(1,1) = CORD(1,1)
      RCORD(2,1) = CORD(2,1)
      RCORD(3,1) = CORD(3,1)
      IKFR(1) = 1
      IKLR(1) = 2
      TCLPR(1) = -.0012471382D+00
      INLPR(1) = 2
      TZLPR(1) = .0761496713D+00
      TCLPR(2) = 17.1604999173D+00
      INLPR(2) = 2
      TZLPR(2) = .9999999904D+00
      RNAME(2) = MNAME(2)
      RCORD(1,2) = CORD(1,2)
      RCORD(2,2) = CORD(2,2)
      RCORD(3,2) = CORD(3,2)
      IKFR(2) = 3
      IKLR(2) = 4
      TCLPR(3) = -.0002488372D+00
      INLPR(3) = 2
      TZLPR(3) = .0949999961D+00
      TCLPR(4) = .1063437802D+00
      INLPR(4) = 2
      TZLPR(4) = .5999987638D+00
      RNAME(3) = MNAME(3)
      RCORD(1,3) = CORD(1,3)
      RCORD(2,3) = CORD(2,3)
      RCORD(3,3) = CORD(3,3)
      IKFR(3) = 5
      IKLR(3) = 6
      TCLPR(5) = -.0002488372D+00
      INLPR(5) = 2
      TZLPR(5) = .0949999961D+00
      TCLPR(6) = .1063437802D+00
      INLPR(6) = 2
      TZLPR(6) = .5999987638D+00
C
C EFP/EFP REPULSIVE POTENTIAL
C
      CREL(1,1,1) = -47.204255D+00
      AREL(1,1,1) = 1.502333D+00
      CREL(1,2,1) = 44.184769D+00
      AREL(1,2,1) = 2.731355D+00
      CREL(1,3,1) = 44.184769D+00
      AREL(1,3,1) = 2.731355D+00
      CREL(1,4,1) = 31.732616D+00
      AREL(1,4,1) = 1.518409D+00
      CREL(2,1,1) = 44.184769D+00
      AREL(2,1,1) = 2.731355D+00
      CREL(2,2,1) = .120699D+00
      AREL(2,2,1) = 1.315321D+00
      CREL(2,3,1) = .120699D+00
      AREL(2,3,1) = 1.315321D+00
      CREL(2,4,1) = -.061708D+00
      AREL(2,4,1) = .802301D+00
      CREL(3,1,1) = 44.184769D+00
      AREL(3,1,1) = 2.731355D+00
      CREL(3,2,1) = .120699D+00
      AREL(3,2,1) = 1.315321D+00
      CREL(3,3,1) = .120699D+00
      AREL(3,3,1) = 1.315321D+00
      CREL(3,4,1) = -.061708D+00
      AREL(3,4,1) = .802301D+00
      CREL(4,1,1) = 31.732616D+00
      AREL(4,1,1) = 1.518409D+00
      CREL(4,2,1) = -.061708D+00
      AREL(4,2,1) = .802301D+00
      CREL(4,3,1) = -.061708D+00
      AREL(4,3,1) = .802301D+00
      CREL(4,4,1) = 146.763464D+00
      AREL(4,4,1) = 2.083947D+00
C
      CALL DAWRIT(IDAF,IODA,AREL,4*4*2,75,0)
C
      RETURN
      END
C*MODULE EFINP   *DECK EFPX
      SUBROUTINE EFPX
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DOUBLE PRECISION MAKEFP,MCSCF
C
      LOGICAL GOPARR,DSKWRK,MASWRK,TESTJOB
      LOGICAL POLAR,DISPER,EXREP,CHGTRN,SCREEN,CTVVO
      LOGICAL MOIDON,EDCOMP,DIPDCM,DEPRNT,QADDCM,ZDO,POLDCM
      LOGICAL POLANG,POLAPP,KMIDPT,POLDYN
C
      CHARACTER*8 FRAG
C
      PARAMETER (MXATM=2000, MXAO=8192, MXIFRQ=12, NMO=500)
C
      COMMON /EDCMP / ZIJ(NMO),ZMO(5,NMO),OCCUP(NMO),DPFREQ(50),
     *                MOIDNO(5,NMO),IJMO(2,NMO),MOIJ(NMO),NMOIJ(NMO),
     *                NMOAT(NMO),NDPFREQ,IPROT(5),NPROT,
     *                MOIDON,EDCOMP,DIPDCM,DEPRNT,QADDCM,ZDO,POLDCM,
     *                POLANG,POLAPP,KMIDPT,POLDYN
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OPTLOC/ CVGLOC,MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,
     *                MOOUTA(MXAO),MOOUTB(MXAO)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C           SET UP $MAKEFP GROUP
      PARAMETER (NNAM=8)
      DIMENSION QNAM(NNAM),KQNAM(NNAM)
      DATA MAKEFP/8HMAKEFP  /
      DATA QNAM/8HTSTJOB  ,8HFRAG    ,8HSCREEN   ,8HPOL     ,
     *          8HDISP    ,8HEXREP   ,8HCHTR     ,8HCTVVO   /
      DATA KQNAM/0,5,0,0,   0,0,0,0/
C
      DATA RNONE/8HNONE    /,NONE/4HNONE/, RHF/8HRHF     /
      DATA ROHF/8HROHF    /
      DATA GVB/8HGVB     /
      DATA UHF/8HUHF     /
      DATA MCSCF/8HMCSCF   /
C
C          ----- DRIVER FOR MAKE EFFECTIVE FRAGMENT POTENTIAL -----
C
C    THE EFP POTENTIAL WILL BE OUTPUT TO THIS FILE:
C
      NFTEFP = 1
C
C                      READ $MAKEFP GROUP
C     FRAG   : ALLOWS SPECIFYING A FRAGMENT NAME FOR THE .EFP FILE
C     POL    : ALLOWS THE POLARIZATION TO BE TURNED ON AND OFF
C     EXREP  : ALLOWS THE EXCHANGE REPULSION TO BE TURNED ON AND OFF,
C              THIS WILL FORCE TURNING OFF CHARGE TRANSFER AS WELL.
C     CHTR   : ALLOWS THE CHARGE TRANSFER TO BE TURNED ON AND OFF
C     DISP   : ALLOWS THE DISPERSION TO BE TURNED ON AND OFF
C
C        UNDOCUMENTED KEYWORD:
C     TESTJOB: PERMITS UNCODED MAKEFP RUN TO EXECUTE ANYWAY, WHILE
C              SOMEONE TRIES TO ADD THIS WAVEFUNCTION TO MAKEFP,
C              TO BE USED ONLY IN "CAVEAT EMPTOR" MODE.
C
      TESTJOB = .FALSE.
C
      FRAG='FRAGNAME'
      SCREEN=.TRUE.
      POLAR =.TRUE.
      DISPER=.TRUE.
      EXREP =.TRUE.
      CHGTRN=.TRUE.
      CTVVO = .TRUE.
C
      CALL NAMEIO(IR,JRET,MAKEFP,NNAM,QNAM,KQNAM,
     *            TESTJOB,FRAG,SCREEN,POLAR,DISPER,EXREP,
     *            CHGTRN,CTVVO,
     *   0,            0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,
     *   0,0,0,0,0,    0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,
     *   0,0,0,0,0,    0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0)
C
      IF((SCFTYP.EQ.GVB  .OR. SCFTYP.EQ.UHF .OR.
     *   SCFTYP.EQ.MCSCF .OR. MPCTYP.NE.NONE .OR.
     *   MPLEVL.GT.0     .OR.  CCTYP.NE.RNONE  .OR.
     *   CITYP.NE.RNONE  .OR.  DFTYPE.NE.RNONE  .OR.  TDDFTYP.NE.RNONE)
     *          .AND.  (.NOT.TESTJOB)) THEN
         IF(MASWRK) WRITE(IW,9210)
     *        SCFTYP,MPCTYP,MPLEVL,DFTYPE,CITYP,CCTYP
         CALL ABRT
      END IF
 9210 FORMAT(1X,'RUNTYP=MAKEFP IS PROGRAMMED FOR SCFTYP=RHF OR ROHF,'/
     *       1X,'WITHOUT THE USE OF MOPAC OR ELECTRON CORRELATION,'/
     *       1X,'BUT YOUR JOB REQUESTS SCFTYP=',A8,' MPCTYP=',A4/
     *       1X,'AND/OR MPLEVL=',I4,' DFTTYP=',A8,
     *          ' CITYP=',A8,' CCTYP=',A8)
C
C        OPEN SHELL RESPONSE EQUATIONS HAVE A PROBLEM IN PARALLEL.
C        A TEST CASE CLOCKED 24 MINUTES ON ONE PROCESS, 1 MINUTE ON
C        ANOTHER STALLED PROCESS, FOR A 90 SECOND LONG SERIAL MAKEFP.
C
      IF(SCFTYP.EQ.ROHF  .AND.  GOPARR) THEN
         IF(MASWRK) WRITE(IW,9220)
         CALL ABRT
      END IF
 9220 FORMAT(//1X,'SORRY, PLEASE RUN -MAKEFP- FOR -ROHF- MOLECULES',
     *          ' IN SERIAL ONLY'//)
C
      IF(.NOT.EXREP) CHGTRN=.FALSE.
      IF(MASWRK) WRITE(IW,9110) FRAG,SCREEN,POLAR,EXREP,DISPER,CHGTRN
C
C        --- GET THE WAVEFUNCTION ---
C
C------------ PX: do not set $SCF VVOS=.T. which will cause ENERGX to----
C------------     run a VVOS run ------------------
      CALL ENERGX
C
C        --- GENERATE DISTRIBUTED MULTIPOLE ANALYSIS ---
C        THIS ALSO OUTPUTS THE ELECTROSTATICS TO THE EFP OUTPUT FILE
C
      IF(MASWRK) WRITE(IW,9010)
      CALL STONE(NFTEFP,FRAG,0)
C
C        --- GENERATE DISTRIBUTED POLARIZABILITY ANALYSIS ---
C        --- GENERATE DYNAMIC POLARIZABILITY (DISPERSION) INFO ----
C        --- EXCHANGE REPULSION REQUIRES LOCALIZED ORBITALS ---
C        HOWEVER, THIS DOES NOT OUTPUT THE INFORMATION.
C
      IF(POLAR .OR. DISPER .OR. EXREP) THEN
         IF(MASWRK) THEN
            WRITE(IW,9020)
            IF(POLAR) THEN
               WRITE(IW,9021)
            ELSE
               POLDCM=.FALSE.
            END IF
            IF(DISPER) THEN
               WRITE(IW,9022)
            ELSE
               POLDYN=.FALSE.
            END IF
         END IF
         CALL LMOX
         ILOCAL = 0
      END IF
C
C        --- GENERATE PAULI REPULSION AND CHARGE TRANSFER INFO ---
C        OUTPUT THE POLARIZABILITY AND DISPERSION DATA, AS WELL.
C
      IF(MASWRK) THEN
         IF(EXREP)  WRITE(IW,9030)
         IF(CHGTRN) WRITE(IW,9031)
      END IF
      LNA = NA - NOUTA
      LNA2 = (LNA*LNA+LNA)/2
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
C
      CALL VALFM(LOADFM)
      LVEC    = 1       + LOADFM
      LARRAY  = LVEC    + L1*NA
      LFMO    = LARRAY  + L2
      LCCHG   = LFMO    + LNA2
      LWRK2   = LCCHG   + 3*NA
      LDLPOL  = LWRK2   + L1
      LIDMYP  = LDLPOL  + 9*LNA
      LNNOPRT = LIDMYP  + L1
      LPOL    = LNNOPRT + L1
      LCTVEC  = LPOL    + 9*LNA*MXIFRQ
      LCTFOK  = LCTVEC + L3
      LAST    = LCTFOK + L2
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      CALL EFP2X(X(LVEC),X(LARRAY),X(LFMO),X(LCCHG),X(LWRK2),
     *            X(LDLPOL),X(LIDMYP),X(LNNOPRT),X(LPOL),X(LCTVEC),
     *           X(LCTFOK),LNA,LNA2,L1,L2,
     *           POLAR,DISPER,EXREP,CHGTRN,CTVVO,NFTEFP)
      CALL RETFM(NEED)
      IF(MASWRK) THEN
         IF(EXREP) WRITE(IW,9032)
      END IF
C
C        --- SCREENING FOR THE ELECTROSTATICS AND POLARIZABILITY ---
C               THIS IS NOT YET CODED FOR ROHF MAKEFP RUNS
C
      IF(SCREEN  .AND.SCFTYP.EQ.RHF) THEN
         IF(MASWRK) WRITE(IW,9040)
         CALL CGPX(NFTEFP)
      END IF
C
C        ALL TERMS IN MAKEFP JOB ARE COMPLETE, SO $END THE $FRAG!
C        THE MULTIPOLE EXPANSION FILE -IDMP- THAT WAS USED BY THE
C        CHARGE AND POLARIZATION SCREENING SHOULD BE DISPOSED OF.
C
      IF(MASWRK) THEN
         WRITE(NFTEFP,9130)
         IDMP = 35
         CALL SEQCLO(IDMP,'DELETE')
      END IF
C
C        - LMO MULTIPOLE EXPANSION -
C
      IF(POLAR .OR. DISPER .OR. EXREP) THEN
         CONTINUE
      ELSE
         CALL LMOX
         ILOCAL = 0
      END IF
      CALL STONE(NFTEFP,FRAG,1)
C
      RETURN
C
 9010 FORMAT(/1X,'RUNTYP=MAKEFP IS NOW GENERATING DISTRIBUTED',
     *           ' MULTIPOLES FOR ELECTOSTATICS'/)
 9020 FORMAT(/1X,'RUNTYP=MAKEFP IS NOW GENERATING LOCALIZED ORBITALS')
 9021 FORMAT( 1X,'              AND DISTRIBUTED POLARIZABILITY TENSORS')
 9022 FORMAT( 1X,'              AND DATA FOR DISPERSION.'/)
 9030 FORMAT(/1X,'RUNTYP=MAKEFP IS NOW GENERATING EXCHANGE REPULSION',
     *           ' DATA')
 9031 FORMAT( 1X,'              AND CHARGE TRANSFER DATA.')
 9032 FORMAT( 1X,'RUNTYP=MAKEFP HAS JUST FINISHED DOING THAT.')
 9040 FORMAT(/1X,'RUNTYP=MAKEFP IS NOW GENERATING SCREENING',
     *           ' PARAMETERS.'/)
 9110 FORMAT(/10X,14(1H-)/10X,14HMAKEFP OPTIONS/10X,14(1H-)/
     *       10X,'FRAG=',A8/
     *       10X,'SCREEN=',L2,4X,'POL   =',L2,4X,'EXREP =',L2/
     *       10X,'DISP  =',L2,4X,'CHTR  =',L2,4X,'CTVVO =',L2)
 9130 FORMAT(' $END')
      END
C
C*MODULE EFINP   *DECK EFP2X
C>
C>     @brief Generate and output various MAKEFP terms
C>
C>     @details This routine began life as -PAULIX- but this is no longer a
C>     very good name as it deals with polarizability output, charge
C>     transfer and dispersion as well as the exchange repulsion.
C>
C>     @date 10/5/12 - Spencer Pruitt
C>     - Added calls to EFMO subroutines to save MAKEFP information in
C>       dynamic memory.
C>
      SUBROUTINE EFP2X(VEC,ARRAY,FMO,CCHG,WRK2,DLPOL,IDMYPT,NNOPRT,
     *                 POL,CTVEC,CTFOK,LNA,LNA2,L1,L2,
     *                 POLAR,DISPER,EXREP,CHGTRN,CTVVO,NFTEFP)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      INTEGER EFPMUL
C
      LOGICAL MOIDON,EDCOMP,DIPDCM,DEPRNT,QADDCM,ZDO,POLDCM,POLANG,
     *        POLAPP,KMIDPT,POLDYN,GOPARR,DSKWRK,MASWRK,DBG
      LOGICAL POLAR,DISPER,EXREP,CHGTRN
      LOGICAL CTVVO
C
      PARAMETER (MXATM=2000, MXSH=5000, MXGTOT=20000, MXAO=8192,
     *           MXFGPT=12000)
      Parameter (MXFRG=1050,MXDFG=5,MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (NMO=500, MXMID=50)
      PARAMETER (TWO=2.0D+00)
C
      CHARACTER*8 STNPNT2
      CHARACTER*8 FATMNM
      CHARACTER*5 FATMNM0
      CHARACTER*4 FATMNM1
      CHARACTER*3 FATMNM2
      CHARACTER*2 DUMMY0
      CHARACTER*3 DUMMY1
      CHARACTER*4 DUMMY2
C
      COMMON /ECP2  / CLP(400),ZLP(400),NLP(400),KFIRST(MXATM,6),
     *                KLAST(MXATM,6),LMAX(MXATM),LPSKIP(MXATM),
     *                IZCORE(MXATM)
      COMMON /EDCMP / ZIJ(NMO),ZMO(5,NMO),OCCUP(NMO),DPFREQ(50),
     *                MOIDNO(5,NMO),IJMO(2,NMO),MOIJ(NMO),NMOIJ(NMO),
     *                NMOAT(NMO),NDPFREQ,IPROT(5),NPROT,
     *                MOIDON,EDCOMP,DIPDCM,DEPRNT,QADDCM,ZDO,POLDCM,
     *                POLANG,POLAPP,KMIDPT,POLDYN
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,
     *                EFMOREPNRG,EFMOCHTNRG,EFMOEPEN,EFMOPCMG,
     *                IEFMORUN,IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,
     *                IEFMODIM(2),IMODEFE,NATEFMO,IMODEFD,IMODEFER,
     *                IMODEFCT,IDIMTYP
      COMMON /EFMOPO/ LNEFMOPTS,LEFMOPTS,LEFMOPPTS,LEFMODPTS,LNEFMOBAS,
     *                LEFMOBAS,LEFMOLMO,LEFMOFM,LEFMOCV,LEFMOCF,
     *                LEFMODIMG,LEFMOTOTG,LEFMOIPT,LEFMOIGLOB
      COMMON /EFPNFO/ EFPMUL
      COMMON /EFPPRT/ NOPRT(MXATM),MIDPRT(MXATM),NUMFFD(MXATM),
     *                INOPRT(2*MXATM),LSTGRP(20,MXATM+1),
     *                ISUM(20,MXFGPT),GRPSUM(20,4),NMDFFD
      COMMON /FMCOM / X(1)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /NOPOL / NOPATM(MXATM),KPOINT(MXMID),NODENS(MXATM)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /STNBUF/ STNPNT(4,2*MXATM),BIGEXP,NPTSTN,NBUFFM
      COMMON /STNDUM/ STNPNT2(1:MXATM),FATMNM,FATMNM0,FATMNM1,
     *                FATMNM2,DUMMY0,DUMMY1,DUMMY2
      COMMON /XYZPRP/ XP,YP,ZP
     *               ,DMX,DMY,DMZ
     *               ,QXX,QYY,QZZ,QXY,QXZ,QYZ
     *               ,QMXX,QMYY,QMZZ,QMXY,QMXZ,QMYZ
     *               ,OXXX,OXXY,OXXZ,OXYY,OYYY,OYYZ
     *               ,OXZZ,OYZZ,OZZZ,OXYZ
     *               ,OMXXX,OMXXY,OMXXZ,OMXYY,OMYYY
     *               ,OMYYZ,OMXZZ,OMYZZ,OMZZZ,OMXYZ
      COMMON /VVOPAR/ IVVOS,NVVOS,BNDDEN
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DOUBLE PRECISION LABEL(6), XYZP(3), NUMCOR(103)
      DIMENSION VEC(L1,NA), ARRAY(L2), FMO(LNA2), CCHG(3,LNA),
     *          WRK2(L1), DLPOL(9,LNA), IDMYPT(L1), NNOPRT(L1),
     *          POL(9,LNA,NDPFREQ)
      DIMENSION CTVEC(L1*L1), CTFOK(L2)
C
      DATA RHF/8HRHF     /, ROHF/8HROHF    /
      DATA LABEL/8HS       ,8HP       ,8HD       ,8HF       ,
     *           8HG       ,8HL       /
      DATA NUMCOR/2*0,
     *            2*1,                  6*1,
     *            2*5,                  6*5,
     *            2*9,          10*9,   6*14,
     *            2*18,         10*18,  6*23,
     *            2*27,  14*27, 10*34,  6*39,
     *            2*43,  14*43,    50/
      DATA CHECK/8HCHECK   /
C
C           ---- GENERATE AND OUTPUT VARIOUS MAKEFP TERMS ----
C        THIS ROUTINE BEGAN LIFE AS -PAULIX- BUT THIS IS NO LONGER A
C        VERY GOOD NAME AS IT DEALS WITH POLARIZABILITY OUTPUT, CHARGE
C        TRANSFER, AND DISPERSION AS WELL AS THE EXCHANGE REPULSION.
C
      MCORE = NA - LNA
C
C           GET LMOS (SEVERAL TERMS NEED THIS)
C
      IF(POLAR  .OR.  DISPER  .OR.  EXREP) THEN
      CALL DAREAD(IDAF,IODA,VEC,L1*NA,71,0)
      IF (MCORE.GT.0) THEN
         DO I = 1,LNA
            CALL DCOPY(L1,VEC(1,MCORE+I),1,VEC(1,I),1)
         END DO
      END IF
C
C           CALCULATE THE CENTROIDS OF THE LMO'S.
C
      XYZP(1) = XP
      XYZP(2) = YP
      XYZP(3) = ZP
      DO I = 1,3
         IF(EXETYP.NE.CHECK) CALL DAREAD(IDAF,IODA,ARRAY,L2,94+I,0)
         DO J = 1,LNA
            IF(EXETYP.NE.CHECK) THEN
               CALL TFTRI(CCHG(I,J),ARRAY,VEC(1,J),WRK2,1,L1,L1)
            ELSE
               CCHG(I,J) = 0.0D+00
            END IF
            CCHG(I,J) = CCHG(I,J) + XYZP(I)
         END DO
      END DO
      END IF
C
C        OUTPUT THE POLARIZABILITY TERM.
C
      IF(.NOT.POLAR) GO TO 300
      IF(MASWRK  .AND.  IEFMORUN.EQ.0)
     *     WRITE(NFTEFP,*) 'POLARIZABLE POINTS'
C
      IF(EXETYP.NE.CHECK) THEN
         CALL DAREAD(IDAF,IODA,DLPOL,LNA*9,251,0)
      ELSE
         CALL VCLR(DLPOL,1,LNA*9)
      END IF
C
C   1. IF FIRST FEW MO-S IN THE QM/MM BUFFER ARE SPECIFIED BY NBUFFM,
C   THEY SHOULD BE SKIPPED IN THE PUNCH OUT ... AND THEY ARE SKIPPED
C   ANYWAY WHEN THE DEFAULT NOUTA=N, WHERE NO. OF BUFFER ORBITALS, IS
C   USED.
C   2. ALSO BY DEFAULT SKIP POLARIZABILITIES NEIGHBORING TO THE BUFFER
C   ATOMS (NONEAR=1) BASED ON THE FOLLOWING CRITERION: DOES
C   POLARIZABILITY UNDER QUESTION CORRESPOND TO A BOND CONNECTED TO A
C   BUFFER ATOM? -TO ACTIVATE 2. UNCOMMENT NONEAR=1
C
      LBF=0
      NONEAR=0
C
C  WHICH ATOMS ARE IN THE BUFFER? NOTE THAT
C  WE ASSUME THERE IS ONE LUMP POLARIZABILITY FOR BUFFER MO-S
C  AND THE BUFFER ATOMS ARE FIRST IN $DATA
C
      IF(NBUFFM.GT.0) THEN
        MINBFA=1
        MAXBFA=1
        DO 150 I=1,NBUFFM
           JMAX=NMOAT(I)
           MINBFA=MIN(MINBFA,MOIDNO(1,I))
           MAXBFA=MAX(MAXBFA,MOIDNO(JMAX,I))
 150    CONTINUE
        IF(MASWRK) WRITE(IW,9500) NBUFFM
        IF(MINBFA.NE.1) THEN
           IF(MASWRK) WRITE(IW,9600) MINBFA
           CALL ABRT
        END IF
        LBF=MAXBFA
        IF(MASWRK) WRITE(IW,9520) LBF
      END IF
C
C IDENTIFY LMOS BELONGING TO THE OVERLAPPING REGION
C
      CALL VICLR(IDMYPT,1,NMO)
      INDPOL=0
      DO 160 IPOL=1,LNA
         ILMO=IPOL + MCORE
         MPOL=0
         DO 170 JAT=1,MXATM
            JMAX=NMOAT(ILMO)
            IF (JMAX.EQ.1) THEN
               IF (NODENS(JAT).EQ.MOIDNO(1,ILMO)) MPOL=1
            END IF
C
C IDENTIFY LMOS BELONGING TO LONE PAIRS OF THE KPOINT ATOM IF KMIDPT
C
            IF((JMAX.EQ.1).AND.KMIDPT) THEN
               IF (KPOINT(JAT).EQ.MOIDNO(1,ILMO)) MPOL=1
            END IF
            IF (JMAX.EQ.2) THEN
               IF ((NODENS(JAT).EQ.MOIDNO(1,ILMO)) .OR.
     *            (NODENS(JAT).EQ.MOIDNO(2,ILMO))) MPOL=1
            END IF
C           IF (JMAX.EQ.2) THEN
C              IF ((NOPATM(JAT).EQ.MOIDNO(1,ILMO)) .OR.
C    *            (NOPATM(JAT).EQ.MOIDNO(2,ILMO))) MPOL=1
C           END IF
  170    CONTINUE
         IF(MPOL.EQ.1) THEN
         INDPOL=INDPOL+1
         IDMYPT(INDPOL)=IPOL
         END IF
  160 CONTINUE
      NUMPOL=INDPOL
      IF(MASWRK.AND.NUMPOL.GT.0) THEN
         WRITE(IW,*) 'ACCORDING TO THE INFORMATION IN $LOCAL'
         WRITE(IW,9510) NUMPOL,(IDMYPT(INDPOL),INDPOL=1,NUMPOL)
      END IF
C
C         IDENTIFY LMOS BELONGING TO THE OVERLAPPING REGION
C         ACCORDING TO THE INFORMATION PROVIDED IN NOPRT(I)
C         AND MIDPRT(I)
C
      CALL VICLR(NNOPRT,1,L1)
      INDPOL=0
      DO 260 IPOL=1,LNA
         ILMO=IPOL + MCORE
         MPOL=0
         DO 270 JAT=1,MXATM
            JMAX=NMOAT(ILMO)
            IF (JMAX.EQ.1) THEN
               IF (NOPRT(JAT).EQ.MOIDNO(1,ILMO)) MPOL=1
            END IF
            IF (JMAX.EQ.2) THEN
               IF ((NOPRT(JAT).EQ.MOIDNO(1,ILMO).OR.
     *              NOPRT(JAT).EQ.MOIDNO(2,ILMO)    ).AND.
     *             (MIDPRT(JAT).NE.MOIDNO(1,ILMO).AND.
     *              MIDPRT(JAT).NE.MOIDNO(2,ILMO)         ))
     *                         MPOL=1
            END IF
  270    CONTINUE
         IF(MPOL.EQ.1) THEN
         INDPOL=INDPOL+1
         NNOPRT(INDPOL)=IPOL
         END IF
  260 CONTINUE
      NUMPOL=INDPOL
      IF(MASWRK.AND.NUMPOL.GT.0) THEN
         WRITE(IW,*) 'ACCORDING TO THE INFORMATION IN $PRTEFP'
         WRITE(IW,9510) NUMPOL,(NNOPRT(INDPOL),INDPOL=1,NUMPOL)
         WRITE(IW,*) ' '
      END IF
C
C     PUNCH OUT POLARIZABLE POINTS
C
      II=0
      DO 200 I = 1,LNA
         NEIGH=0
         IF(NONEAR.EQ.1 .AND. LBF.GT.0) THEN
C        DECIDE IF THE I-TH MO IS 'NEIGHBORING' TO THE BUFFER
            ILMO=I+NBUFFM
            JMAX=NMOAT(ILMO)
            MINAT=MOIDNO(1,ILMO)
            IF(MINAT .LE. LBF) NEIGH=1
            IF(NEIGH.EQ.1 .AND. MASWRK) THEN
              IF(JMAX.EQ.1) WRITE(IW,9541) ILMO,MOIDNO(1,ILMO)
              IF(JMAX.EQ.2) WRITE(IW,9542) ILMO,(MOIDNO(IX,ILMO),IX=1,2)
              IF(JMAX.EQ.3) WRITE(IW,9543) ILMO,(MOIDNO(IX,ILMO),IX=1,3)
              IF(JMAX.EQ.4) WRITE(IW,9544) ILMO,(MOIDNO(IX,ILMO),IX=1,4)
              IF(JMAX.EQ.5) WRITE(IW,9545) ILMO,(MOIDNO(IX,ILMO),IX=1,5)
            END IF
         END IF
         IF(NEIGH.EQ.1) GO TO 200
         IF(NEIGH.NE.1) II=II+1
C
C CHECK FOR POLARIZABLE POINT THAT SHOULD BE REMOVED
C
         DO 205 ICHK=1,NUMPOL
            IF(I.EQ.IDMYPT(ICHK)) GO TO 200
            IF(I.EQ.NNOPRT(ICHK)) GO TO 200
 205     CONTINUE
         IF(MASWRK) THEN
C        EFMO STORAGE FOR POLARIZABLE POINTS
           IF(IEFMORUN.GT.0) THEN
             IF(IEFMORT.EQ.1) THEN
               CALL EFMOPTNSAV(X(LNEFMOPTS),IEFMONFRG,IEFMOCFRG,2,LNA)
        CALL EFMOSTORP(IEFMOCFRG,I,1,X(LEFMOPPTS),IEFMONFRG,CCHG(1,I))
        CALL EFMOSTORP(IEFMOCFRG,I,2,X(LEFMOPPTS),IEFMONFRG,CCHG(2,I))
        CALL EFMOSTORP(IEFMOCFRG,I,3,X(LEFMOPPTS),IEFMONFRG,CCHG(3,I))
        CALL EFMOSTORP(IEFMOCFRG,I,4,X(LEFMOPPTS),IEFMONFRG,DLPOL(1,I))
        CALL EFMOSTORP(IEFMOCFRG,I,5,X(LEFMOPPTS),IEFMONFRG,DLPOL(2,I))
        CALL EFMOSTORP(IEFMOCFRG,I,6,X(LEFMOPPTS),IEFMONFRG,DLPOL(3,I))
        CALL EFMOSTORP(IEFMOCFRG,I,7,X(LEFMOPPTS),IEFMONFRG,DLPOL(4,I))
        CALL EFMOSTORP(IEFMOCFRG,I,8,X(LEFMOPPTS),IEFMONFRG,DLPOL(5,I))
        CALL EFMOSTORP(IEFMOCFRG,I,9,X(LEFMOPPTS),IEFMONFRG,DLPOL(6,I))
        CALL EFMOSTORP(IEFMOCFRG,I,10,X(LEFMOPPTS),IEFMONFRG,DLPOL(7,I))
        CALL EFMOSTORP(IEFMOCFRG,I,11,X(LEFMOPPTS),IEFMONFRG,DLPOL(8,I))
        CALL EFMOSTORP(IEFMOCFRG,I,12,X(LEFMOPPTS),IEFMONFRG,DLPOL(9,I))
             ENDIF
             GOTO 200
           ELSE
            IF (II.LT.10)  WRITE(NFTEFP,9301) II,(CCHG(J,I),J=1,3)
            IF (II.GE.10 .AND. II.LT.100)
     *                     WRITE(NFTEFP,9302) II,(CCHG(J,I),J=1,3)
            IF (II.GE.100) WRITE(NFTEFP,9303) II,(CCHG(J,I),J=1,3)
         WRITE(NFTEFP,9250) DLPOL(1,I),DLPOL(5,I),DLPOL(9,I),DLPOL(2,I),
     *                     DLPOL(3,I),DLPOL(6,I),DLPOL(4,I),DLPOL(7,I),
     *                     DLPOL(8,I)
           ENDIF
         END IF
C
 200  CONTINUE
      IF(MASWRK.AND.IEFMORUN.EQ.0) WRITE(NFTEFP,9111)
C
C        OUTPUT THE DYNAMIC POLARIZABILITY DATA, FOR DISPERSION.
C
  300 CONTINUE
      IF(.NOT.DISPER)   GO TO 400
      IF(SCFTYP.NE.RHF) GO TO 400
C
C        POLDYN PROBABLY ALWAYS TRUE FOR EFP RUNS, IT IS LEFT OVER FROM
C        BEFORE THE MAKEFP GROUP GAVE CENTRALIZED CONTROL OF WHAT EFP
C        TERMS ARE GENERATED.  IT IS A KEYWORD IN $LOCAL.
C
      IF(POLDYN) THEN
         IF(EXETYP.NE.CHECK) THEN
            CALL DAREAD(IDAF,IODA,POL,LNA*9*NDPFREQ,401,0)
         ELSE
            CALL VCLR(POL,1,LNA*9*NDPFREQ)
         END IF
C
C  SRP: EFMO STORAGE FOR DYNAMIC POLARIZABLE POINTS
C
         IF(MASWRK) THEN
           IF(IEFMORUN.GT.0) THEN
             IF(IEFMORT.EQ.1) THEN
               CALL EFMOPTNSAV(X(LNEFMOPTS),IEFMONFRG,IEFMOCFRG,3,LNA)
         DO J = 1,NDPFREQ
            II = 0
            DO I = 1,LNA
               II = II+I
      CALL EFMOSTORDP(IEFMOCFRG,I,J,1,X(LEFMODPTS),IEFMONFRG,CCHG(1,I))
      CALL EFMOSTORDP(IEFMOCFRG,I,J,2,X(LEFMODPTS),IEFMONFRG,CCHG(2,I))
      CALL EFMOSTORDP(IEFMOCFRG,I,J,3,X(LEFMODPTS),IEFMONFRG,CCHG(3,I))
      CALL EFMOSTORDP(IEFMOCFRG,I,J,4,X(LEFMODPTS),IEFMONFRG,POL(1,I,J))
      CALL EFMOSTORDP(IEFMOCFRG,I,J,5,X(LEFMODPTS),IEFMONFRG,POL(2,I,J))
      CALL EFMOSTORDP(IEFMOCFRG,I,J,6,X(LEFMODPTS),IEFMONFRG,POL(3,I,J))
      CALL EFMOSTORDP(IEFMOCFRG,I,J,7,X(LEFMODPTS),IEFMONFRG,POL(4,I,J))
      CALL EFMOSTORDP(IEFMOCFRG,I,J,8,X(LEFMODPTS),IEFMONFRG,POL(5,I,J))
      CALL EFMOSTORDP(IEFMOCFRG,I,J,9,X(LEFMODPTS),IEFMONFRG,POL(6,I,J))
      CALL EFMOSTORDP(IEFMOCFRG,I,J,10,X(LEFMODPTS),IEFMONFRG,
     *                  POL(7,I,J))
      CALL EFMOSTORDP(IEFMOCFRG,I,J,11,X(LEFMODPTS),IEFMONFRG,
     *                  POL(8,I,J))
      CALL EFMOSTORDP(IEFMOCFRG,I,J,12,X(LEFMODPTS),IEFMONFRG,
     *                  POL(9,I,J))
             ENDDO
          ENDDO
         ENDIF
       GOTO 350
       ELSE
             WRITE(NFTEFP,*) 'DYNAMIC POLARIZABLE POINTS'
         DO K = 1,NDPFREQ
            II = 0
            DO I = 1,LNA
               II = II+I
               IF(MASWRK) THEN
                  IF(I.EQ.1) THEN
                     WRITE(NFTEFP,9304) I,(CCHG(J,I),J=1,3),DPFREQ(K)
                  ELSE
                     WRITE(NFTEFP,9303) I,(CCHG(J,I),J=1,3)
                  END IF
                  WRITE(NFTEFP,9250) POL(1,I,K), POL(5,I,K), POL(9,I,K),
     *                           POL(2,I,K), POL(3,I,K), POL(6,I,K),
     *                           POL(4,I,K), POL(7,I,K), POL(8,I,K)
               ENDIF
            ENDDO
         ENDDO
        ENDIF
       ENDIF
         IF(MASWRK) WRITE(NFTEFP,9111)
  350 CONTINUE
C
      ENDIF
C
C        OUTPUT THE ATOMIC BASIS SET INFORMATION
C  EXCHANGE REPULSION -AND- CHARGE TRANSFER NEED TO KNOW BASIS SET INFO.
C  SINCE THE TRIGGER TO TURN OFF EXCHANGE REPULSION IS NOT FINDING
C  AN AO BASIS, TURNING OFF EXREP ALSO MUST TURN OFF CHARGE TRANSFER.
C
  400 CONTINUE
      IF(.NOT.EXREP) GO TO 700
C
C
      IF(MASWRK) THEN
       IF(IEFMORUN.GT.0) THEN
        IF(IEFMORT.EQ.1) THEN
          II=0
          N = 0
          LASTAT=0
           DO II=1,NSHELL
C
C  SRP: STORING INTEGER TYPE BASIS SET INFORMATION IN EFMOBAS
C
      CALL EFMOSTORNBAS(IEFMOCFRG,II,IEFMONFRG,X(LNEFMOBAS),1,
     *                        KSTART(II))
      CALL EFMOSTORNBAS(IEFMOCFRG,II,IEFMONFRG,X(LNEFMOBAS),2,KATOM(II))
      CALL EFMOSTORNBAS(IEFMOCFRG,II,IEFMONFRG,X(LNEFMOBAS),3,KTYPE(II))
      CALL EFMOSTORNBAS(IEFMOCFRG,II,IEFMONFRG,X(LNEFMOBAS),4,KNG(II))
      CALL EFMOSTORNBAS(IEFMOCFRG,II,IEFMONFRG,X(LNEFMOBAS),5,KLOC(II))
      CALL EFMOSTORNBAS(IEFMOCFRG,II,IEFMONFRG,X(LNEFMOBAS),6,KMIN(II))
      CALL EFMOSTORNBAS(IEFMOCFRG,II,IEFMONFRG,X(LNEFMOBAS),7,KMAX(II))
C
C  SRP: STORING FP TYPE BASIS SET INFORMATION IN EFMOBAS
C
          IAT = KATOM(II)
          J = INT(ZAN(IAT))
          I1 = KSTART(II)
          I2 = I1+KNG(II)-1
          NBFS = KMAX(II) - KMIN(II) + 1
          IF (NBFS.EQ.1)  ITYP = 1
          IF (NBFS.EQ.3)  ITYP = 2
          IF (NBFS.EQ.6)  ITYP = 3
          IF (NBFS.EQ.10) ITYP = 4
          IF (NBFS.EQ.15) ITYP = 5
          IF (NBFS.EQ.4)  ITYP = 6
          IF (LASTAT.NE.IAT) THEN
            ZNUC = ZAN(IAT)
            IZ = INT(ZAN(IAT)) + IZCORE(IAT)
            IF (MCORE.GT.0) ZNUC = ZNUC - TWO*NUMCOR(IZ)
      CALL EFMOSTORBAS(IEFMOCFRG,IAT,IEFMONFRG,X(LEFMOBAS),1,C(1,IAT))
      CALL EFMOSTORBAS(IEFMOCFRG,IAT,IEFMONFRG,X(LEFMOBAS),2,C(2,IAT))
      CALL EFMOSTORBAS(IEFMOCFRG,IAT,IEFMONFRG,X(LEFMOBAS),3,C(3,IAT))
      CALL EFMOSTORBAS(IEFMOCFRG,IAT,IEFMONFRG,X(LEFMOBAS),4,ZNUC)
            ENDIF
             DO IG = I1,I2
              N = N+1
      CALL EFMOSTORBAS(IEFMOCFRG,IG,IEFMONFRG,X(LEFMOBAS),5,EX(IG))
      CALL EFMOSTORBAS(IEFMOCFRG,IG,IEFMONFRG,X(LEFMOBAS),6,CS(IG))
      CALL EFMOSTORBAS(IEFMOCFRG,IG,IEFMONFRG,X(LEFMOBAS),7,CP(IG))
      CALL EFMOSTORBAS(IEFMOCFRG,IG,IEFMONFRG,X(LEFMOBAS),8,CD(IG))
      CALL EFMOSTORBAS(IEFMOCFRG,IG,IEFMONFRG,X(LEFMOBAS),9,CF(IG))
      CALL EFMOSTORBAS(IEFMOCFRG,IG,IEFMONFRG,X(LEFMOBAS),10,CG(IG))
             ENDDO
              LASTAT=IAT
          ENDDO
      GOTO 405
        ENDIF
      ELSE
      IF(MASWRK) WRITE(NFTEFP,8000)
      N = 0
      LASTAT=0
      DO 120 II = 1,NSHELL
         IAT = KATOM(II)
         J = INT(ZAN(IAT))
         I1 = KSTART(II)
         I2 = I1+KNG(II)-1
         NBFS = KMAX(II) - KMIN(II) + 1
         IF (NBFS.EQ.1)  ITYP = 1
         IF (NBFS.EQ.3)  ITYP = 2
         IF (NBFS.EQ.6)  ITYP = 3
         IF (NBFS.EQ.10) ITYP = 4
         IF (NBFS.EQ.15) ITYP = 5
         IF (NBFS.EQ.4)  ITYP = 6
         IF (LASTAT.NE.IAT) THEN
            IF (MASWRK  .AND.  IAT.NE.1) WRITE(NFTEFP,*) ' '
            ZNUC = ZAN(IAT)
            IZ = INT(ZAN(IAT)) + IZCORE(IAT)
            IF (MCORE.GT.0) ZNUC = ZNUC - TWO*NUMCOR(IZ)
            IF(MASWRK) WRITE(NFTEFP,9000) STNPNT2(IAT),BNAM(IAT),
     *                                (C(J,IAT),J=1,3),ZNUC
         END IF
         IF(MASWRK) WRITE(NFTEFP,9050) LABEL(ITYP),(I2-I1+1)
         DO 110 IG = I1,I2
            N = N+1
            IF(ITYP.EQ.1) C1 = CS(IG)
            IF(ITYP.EQ.2) C1 = CP(IG)
            IF(ITYP.EQ.3) C1 = CD(IG)
            IF(ITYP.EQ.4) C1 = CF(IG)
            IF(ITYP.EQ.5) C1 = CG(IG)
            IF(ITYP.EQ.6) C1 = CS(IG)
            IF(ITYP.EQ.6) C2 = CP(IG)
            IF(MASWRK.AND.ITYP.LE.5) WRITE(NFTEFP,9100) IG,EX(IG),C1
            IF(MASWRK.AND.ITYP.EQ.6) WRITE(NFTEFP,9100) IG,EX(IG),C1,C2
  110    CONTINUE
         LASTAT=IAT
  120 CONTINUE
      IF(MASWRK) THEN
         WRITE(NFTEFP,*) ' '
         WRITE(NFTEFP,9111)
      ENDIF
      ENDIF
      ENDIF

C
C        OUTPUT THE MULTIPLICITY OF THIS FRAGMENT
C
 405  CONTINUE
C
C  SRP: STORING MULTIPLICITY AND NUMBER OF BASIS SET SHELLS FOR
C       EXCHANGE REPULSION DURING EFMO CALCULATIONS
C
      IF(MASWRK) THEN
       IF(IEFMORUN.GT.0)THEN
        IF(IEFMORT.EQ.1)THEN
         CALL EFMOPTNSAV(X(LNEFMOPTS),IEFMONFRG,IEFMOCFRG,5,NSHELL)
         CALL EFMOPTNSAV(X(LNEFMOPTS),IEFMONFRG,IEFMOCFRG,6,MUL)
        ENDIF
      GOTO 410
       ELSE
        EFPMUL=MUL
        IF(MASWRK) WRITE(NFTEFP,9110) EFPMUL
        IF(MASWRK) WRITE(NFTEFP,9111)
       ENDIF
      ENDIF
C
 410  CONTINUE
C
C  SRP: EFMO STORAGE FOR LMOS (EFMOSTORLMO). WE ALSO NEED THE NUMBER
C       OF BASIS FUNCTIONS (NUM) IN EACH FRAGMENT TO PROPERLY
C       DIMENSION PROVEC DURING THE EFP ENERGY EVALUATION
C       (EFMOPTNSAV MODE=4).
C
      IF(MASWRK) THEN
       IF(IEFMORUN.GT.0) THEN
        IF(IEFMORT.EQ.1) THEN
         MXBSFN=0
         MXMOS=0
          DO I=1,IEFMONFRG
           MXBSFN=MAX(MXBSFN,NBSFN(I))
           MXMOS=MAX(MXMOS,NMXMO(I))
          ENDDO
           CALL EFMOPTNSAV(X(LNEFMOPTS),IEFMONFRG,IEFMOCFRG,4,NUM)
            DO J=1,LNA
             DO I=1,L1
              CALL EFMOSTORLMO(IEFMOCFRG,I,J,MXBSFN,MXMOS,X(LEFMOLMO),
     *                         IEFMONFRG,VEC(I,J))
             ENDDO
            ENDDO
        ENDIF
      GOTO 450
       ELSE
C
C        OUTPUT THE LOCALIZED ORBITALS, FOR EXCHANGE REPULSION
C
        IF(MASWRK) WRITE(NFTEFP,9200) LNA,L1
         CALL PUSQLF(NFTEFP,VEC,LNA,L1,L1)
       ENDIF
      ENDIF
C
  450 CONTINUE
C
C        OUTPUT THE FOCK MATRIX OVER LMO'S, FOR EXCHANGE REPULSION
C
      IF(EXETYP.NE.CHECK) THEN
        IF (SCFTYP .EQ. RHF) THEN
         CALL DAREAD(IDAF,IODA,ARRAY,L2,14,0)
         CALL TFTRI(FMO,ARRAY,VEC,WRK2,LNA,L1,L1)
        END IF
        IF(SCFTYP.EQ.ROHF) THEN
          DBG = .FALSE.
          L1SAV = L1
          L2SAV = L2
C
C            ASSEMBLE THE TOTAL ROHF FOCK MATRIX
C
          L0 = NQMT
          L1 = NUM
          L2 = (L1*L1+L1)/2
          L3 = L1*L1
C
          CALL VALFM(LOADFM)
          LSCR  = LOADFM + 1
          LWRK1 = LSCR   + L1
          LWRK2 = LWRK1  + MAX(L2,L3)
          LWRK3 = LWRK2  + MAX(L2,L3)
          LWRK4 = LWRK3  + MAX(L2,L3)
C
          LVA   = LWRK4  + L2
          LFA   = LVA    + L3
          LFB   = LFA    + L2
          LS    = LFB    + L2
          LAST  = LS     + L2
          NEED  = LAST - LOADFM - 1
          CALL GETFM(NEED)
C
          CALL DAREAD(IDAF,IODA,X(LS) ,L2   ,12,0)
          CALL DAREAD(IDAF,IODA,X(LFA),L2   ,14,0)
          CALL DAREAD(IDAF,IODA,X(LVA),L1*L1,15,0)
          CALL DAREAD(IDAF,IODA,X(LFB),L2   ,18,0)
          CALL ROFOCK(X(LFA),X(LFB),X(LWRK1),X(LVA),X(LSCR),X(LS),
     *                X(LWRK2),NA,NB,0,L0,L1,L2,L3,DBG)
          L1 = L1SAV
          L2 = L2SAV
          CALL TFTRI(FMO,X(LFA),VEC,WRK2,LNA,L1,L1)
          CALL RETFM(NEED)
          END IF
      ELSE
         CALL VCLR(FMO,1,LNA2)
      END IF
C
C  SRP: EFMO STORAGE FOR FOCK MATRIX
C
      IF(MASWRK) THEN
       IF(IEFMORUN.GT.0) THEN
        IF(IEFMORT.EQ.1) THEN
        MXMO2=(MXMOS*MXMOS+MXMOS)/2
         DO I=1,LNA2
          CALL EFMOSTORFM(IEFMOCFRG,MXMO2,I,X(LEFMOFM),IEFMONFRG,FMO(I))
          ENDDO
        ENDIF
      GOTO 460
       ELSE
        IF(MASWRK) THEN
         WRITE(NFTEFP,*) 'FOCK MATRIX ELEMENTS'
         WRITE(NFTEFP,9250) (FMO(I),I=1,LNA2)
        ENDIF
C
C
C  SRP: WE NEED THE LMO CENTROIDS FOR EFMO, HOWEVER, THEY ARE
C       STORED PREVIOUSLY WITH THE POLARIZABILITY TENSORS
C
C
        IF(MASWRK) THEN
         WRITE(NFTEFP,*) 'LMO CENTROIDS'
          DO I=1,LNA
            IF (I.LT.10)  WRITE(NFTEFP,9301) I,(CCHG(J,I),J=1,3)
            IF (I.GE.10 .AND. I.LT.100)
     *                    WRITE(NFTEFP,9302) I,(CCHG(J,I),J=1,3)
            IF (I.GE.100) WRITE(NFTEFP,9303) I,(CCHG(J,I),J=1,3)
          END DO
         WRITE(NFTEFP,9111)
        ENDIF
C
        IF(.NOT.CHGTRN)   GO TO 700
        IF(SCFTYP.NE.RHF) GO TO 700
       ENDIF
      ENDIF
C
 460  CONTINUE
C
C        OUTPUT THE CANONICAL MOLECULAR ORBITALS, FOR CHARGE TRANSFER
C               THIS IS NOT YET CODED FOR ROHF MAKEFP RUNS
C
C ---------------- PX: choose either VVO or CMO for EFP2 CT ----------
C --------- LMO -----------
      IF(CTVVO) THEN
          L0 = NQMT
          L1 = NUM
          L2 = (L1*L1+L1)/2
          L3 = L1*L1
          NOCC = NA
C
          CALL DAREAD(IDAF,IODA,CTVEC,L1*L1,15,0)
          CALL DAREAD(IDAF,IODA,CTFOK,L2,14,0)
C
          IVVOS=1
          CALL VALFM(LOADFM)
          LCTVEC  =  LOADFM + 1
          LCTFOK  =  LCTVEC + L3
          LEIG    =  LCTFOK + L2
          LWRK1   =  LEIG   + L1
          LWRK2   =  LWRK1  + L3
          LWRK3   =  LWRK2  + L3
          LSCR    =  LWRK3  + L3
          LIWRK   =  LSCR   + L1*8
          LAST    =  LIWRK  + L1
          NEED    =  LAST - LOADFM -1
          CALL GETFM(NEED)
C
          CALL VVOS(CTVEC,CTFOK,X(LEIG),
     *              X(LWRK1),X(LWRK2),X(LWRK3),X(LSCR),X(LIWRK),
     *              L0,L1,L2,L3,NOCC)

C        CALL DAREAD(IDAF,IODA,X(LCTVEC),L3,15,0)
C        CALL DAREAD(IDAF,IODA,X(LEIG),L1,17,0)

          NVVO = NVVOS
          NLMO = NOCC + NVVO

C
C   OUTPUT SEMI-CONANICALIZED MO FROM QUAMBO
C
C
C  SRP: STORING VVO'S FOR EFMO CHARGE TRANSFER
C
      IF(IEFMORUN.GT.0) THEN
       IF(IEFMORT.EQ.1) THEN
        CALL DAREAD(IDAF,IODA,CTVEC,L3,15,0)
        CALL STFASE(CTVEC,L1,L1,L1)
         IF(MASWRK) THEN
          CALL EFMOPTNSAV(X(LNEFMOPTS),IEFMONFRG,IEFMOCFRG,7,NA)
           DO I=1,NLMO*L1
            CALL EFMOSTORCV(IEFMOCFRG,I,L1,X(LEFMOCV),IEFMONFRG,
     *                      CTVEC(I))
           ENDDO
         ENDIF

C  SRP: RESTORING ORBITALS FOR POSSIBLE MP2 ENERGY CALCULATION
C       (SEE RHFUHF.SRC)
C
            CALL DAREAD(IDAF,IODA,X(LCTVEC),L3,615,0)
            CALL DAWRIT(IDAF,IODA,X(LCTVEC),L3,15,0)
        ENDIF
      ELSE
         CALL DAREAD(IDAF,IODA,CTVEC,L3,15,0)
         CALL STFASE(CTVEC,L1,L1,L1)
          IF(MASWRK) WRITE(NFTEFP,*) 'CTVEC   ',NA,' ',NLMO
          CALL PUSQLF(NFTEFP,CTVEC,NLMO,L1,L1)
C
      ENDIF
C
C   OUTPUT EXPECTATION VALUE OF FOCK OPERATOR OVER LMO
C   ONLY NEED THE FIRST NA(NOCC) ONES
C
          CALL DAREAD(IDAF,IODA,CTFOK,NA,17,0)
C
C
C  SRP: STORING FOCK MATRIX OVER VVO'S FOR EFMO CHARGE TRANSFER
C
       IF(IEFMORUN.GT.0)THEN
        IF(IEFMORT.EQ.1)THEN
         IF(MASWRK) THEN
          DO I=1,NA
           CALL EFMOSTORCF(IEFMOCFRG,I,L2,X(LEFMOCF),IEFMONFRG,
     *                     CTFOK(I))
          ENDDO
         ENDIF
          IVVOS=0
         CALL RETFM(NEED)
        ENDIF

C
C  SRP: RESTORING ORBITAL ENERGIES FOR POSSIBLE MP2 ENERGY CALCULATION
C       (SEE RHFUHF.SRC)
C
          CALL DAREAD(IDAF,IODA,X(LEIG),L1,617,0)
          CALL DAWRIT(IDAF,IODA,X(LEIG),L1,17,0)
      ELSE
        IF(MASWRK) THEN
         WRITE(NFTEFP,*) 'CTFOK'
         WRITE(NFTEFP,9250) (CTFOK(I),I=1,NA)
         WRITE(NFTEFP,9111)
         CALL RETFM(NEED)
        END IF
      ENDIF
C
C         CALL RETFM(NEED)
C
C ----------CMO------------
      ELSE
C
      IF(IEFMORUN.GT.0) THEN
       IF(IEFMORT.EQ.1) THEN
        CALL DAREAD(IDAF,IODA,CTVEC,L1*L1,15,0)
         IF(MASWRK) THEN
          CALL EFMOPTNSAV(X(LNEFMOPTS),IEFMONFRG,IEFMOCFRG,7,NA)
           DO I=1,L1*L1
            CALL EFMOSTORCV(IEFMOCFRG,I,L1,X(LEFMOCV),IEFMONFRG,
     *                      CTVEC(I))
           ENDDO
         ENDIF
       ENDIF
      ELSE
        CALL DAREAD(IDAF,IODA,CTVEC,L1*L1,15,0)
        IF(MASWRK) WRITE(NFTEFP,*) 'CTVEC   ',NA,' ',L1
        CALL PUSQLF(NFTEFP,CTVEC,L1,L1,L1)
      ENDIF
C
C
C        OUTPUT THE FOCK MATRIX OVER CMO'S, FOR CHARGE TRANSFER
C
        IF(EXETYP.NE.CHECK) THEN
           CALL DAREAD(IDAF,IODA,ARRAY,L2,14,0)
           CALL TFTRI(CTFOK,ARRAY,CTVEC,WRK2,L1,L1,L1)
        END IF
C
       IF(IEFMORUN.GT.0)THEN
        IF(IEFMORT.EQ.1)THEN
         IF(MASWRK) THEN
          DO I=1,NA
           CALL EFMOSTORCF(IEFMOCFRG,I,L2,X(LEFMOCF),IEFMONFRG,
     *                     CTFOK(I*(I+1)/2))
          ENDDO
         ENDIF
        ENDIF
       ELSE
        IF(MASWRK) THEN
           WRITE(NFTEFP,*) 'CTFOK   '
           WRITE(NFTEFP,9250)(CTFOK(I*(I+1)/2),I=1,NA)
           WRITE(NFTEFP,9111)
        ENDIF
       ENDIF
C
      END IF
C
  700 CONTINUE
      IF(IEFMORUN.NE.1) THEN
      CALL FLSHBF(NFTEFP)
      ENDIF
      RETURN
C
 8000 FORMAT(1X,'PROJECTION BASIS SET')
 9000 FORMAT(A8,A2,3F15.10,1X,F6.1)
 9050 FORMAT(3X,A8,I4)
 9100 FORMAT(3X,I3,1X,F20.10,2F15.8)
 9110 FORMAT(1X,'MULTIPLICITY',1X,I4)
 9111 FORMAT(1X,'STOP')
 9200 FORMAT(1X,'PROJECTION WAVEFUNCTION',1X,I6,1X,I6)
 9250 FORMAT(4(1X,F15.10),' >')
 9301 FORMAT('CT',I1,3F15.10)
 9302 FORMAT('CT',I2,3F15.10)
 9303 FORMAT('CT',I3,3F15.10)
 9304 FORMAT('CT',I3,3F15.10,' -- FOR W=',F9.6,'I A.U.')
 9500 FORMAT(/1X,'NUMBER OF BUFFER MO-S IS ',I4)
 9510 FORMAT(1X,'THE NUMBER OF POLARIZ. POINTS TO BE REMOVED IS',
     *       I5,/3X,'THEIR NUMBERS ARE:',(10I3))
 9520 FORMAT(1X,'NUMBER OF ATOMS IN THE BUFFER IS ',I5)
 9541 FORMAT(I5,'TH LMO CENTERED ON ATOM ',I5,
     *          ' IS EXCLUDED FROM THE LIST OF POLARIZABILITIES')
 9542 FORMAT(I5,'TH LMO CENTERED ON ATOMS ',I5,' AND ',I5,
     *          ' IS EXCLUDED FROM THE LIST OF POLARIZABILITIES')
 9543 FORMAT(I5,'TH LMO CENTERED ON ATOMS ',I5,' , ',I5,' AND ',I5,
     *          ' IS EXCLUDED FROM THE LIST OF POLARIZABILITIES')
 9544 FORMAT(I5,'TH LMO CENTERED ON ATOMS ',I5,' , ',I5,' , ',I5,
     * ' AND ',I5,' IS EXCLUDED FROM THE LIST OF POLARIZABILITIES')
 9545 FORMAT(I5,'TH LMO CENTERED ON ATOMS ',I5,' , ',I5,' , ',I5,
     *        ' , ',I5,' AND ',I5,
     *        ' IS EXCLUDED FROM THE LIST OF POLARIZABILITIES')
 9600 FORMAT(1X,'THE FIRST BUFFER ATOM IS NOT THE FIRST ATOM '/
     *       1X,'IN $DATA  (BUT #',I5,')')
      END
C*MODULE EFINP   *DECK PREFIN
      SUBROUTINE PREFIN
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION MAKEFP
C
      PARAMETER (MXATM=2000, MXFGPT=12000)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /EFPPRT/ NOPRT(MXATM),MIDPRT(MXATM),NUMFFD(MXATM),
     *                INOPRT(2*MXATM),LSTGRP(20,MXATM+1),
     *                ISUM(20,MXFGPT),GRPSUM(20,4),NMDFFD
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      PARAMETER (NNAM=3)
      DIMENSION QNAM(NNAM),KQNAM(NNAM)
      DATA PRTEFP/8HPRTEFP  /, MAKEFP/8HMAKEFP   /
      DATA QNAM /8HNOPRT   ,8HMIDPRT  ,8HNUMFFD  /
      DATA KQNAM/-1,-1,-1/
C
      KQNAM(1)=10*MXATM+1
      KQNAM(2)=10*MXATM+1
      KQNAM(3)=10*MXATM+1
C
C     NOPRT : ATOMS WITH WHICH ALL MULTIPLE EXPANSION POINTS
C             AND POLARIZABLE POINTS ASSOCIATED WILL NOT
C             BE PRINTED/PUNCHED OUT
C
C     MIDPRT: ATOMS WITH WHICH ALL MIDDLE POINTS (BONDS)
C             ASSOCIATED WILL AND MUST BE PRINTED/PUNCHED OUT.
C             THIS RANKS OVER NOPRT.
C
C     NUMFFD: ARRAY WITH THE FIRST POSITIVE NUMBER BEING THE ATOM
C             CONNECTS THE FORCE FIELD PART, I.E. THE END OF
C             THE EFP. THE SECOND NUMBER TELLS HOW MANY ATOMS
C             ARE IN THE FORCE FIELD PART THAT WILL NOT BE
C             PRINTED OUT AS INDICATED IN NOPRT(I). THE REST ARE
C             THE ATOMS OF THE FORCE FIELD PART.
C             IF THERE ARE MORE THAN ONE CONNECTION ATOM, THEN
C             REPEAT ABOVE.
C
      DO I = 1, MXATM
        NOPRT(I)  = -1
        MIDPRT(I) = -1
        NUMFFD(I) = -1
      ENDDO
      DO I = 1, 2*MXATM
        INOPRT(I) = -1
      ENDDO
      DO I = 1, 20
        DO J1 = 1, MXATM+1
          LSTGRP(I,J1) = -1
        ENDDO
        DO J2 = 1, MXFGPT
          ISUM(I,J2)   = -1
        ENDDO
        DO J3 = 1, 4
          GRPSUM(I,J3) = 0.0D+00
        ENDDO
      ENDDO
      NMDFFD = 0
C
      IF(RUNTYP.NE.MAKEFP) RETURN
C
C     READ THE PRTEFP NAMELIST
C
      JRET=0
      CALL NAMEIO(IR,JRET,PRTEFP,NNAM,QNAM,KQNAM,
     *            NOPRT,MIDPRT,NUMFFD,
     *            0,
     *   0,0,0,0,0,    0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,
     *   0,0,0,0,0,    0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,
     *   0,0,0,0,0,    0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0)
      IF(JRET.EQ.2) THEN
         IF(MASWRK) WRITE(IW,*) '**** ERROR IN $PRTEFP INPUT'
         CALL ABRT
      END IF
C
C         FIND THE GROUP ATTACHED TO THE ATOMS DEFINED IN NUMFFD(I)
C         THIS GROUP IS OR IS AMONG THE GROUPS DEFINED IN NOPRT(I)
C         THE GROUP'S EFP CHARGES(MONOPOLES) WILL BE COLLECTED AND
C         ADDED TO THE ATOM OR THE MIDPOINT DEFINED IN NUMFFD(I),
C         SO AN INTEGER CHARGE IS ASSIGNED TO THE EFP GENERATED.
C         IF THE MIDPOINT WILL BE PRINTED OUT,
C         THE CHARGE GOES TO THE MIDPOINT.
C         IF THE MIDPOINT WILL NOT BE PRINTED OUT,
C         THE CHARGE GOES TO THE ATOM.
C
       DO I =1, MXATM
         IF(NUMFFD(I).GT.0) THEN
                J = I
 200            NMDFFD = NMDFFD + 1
                IF(NMDFFD.GT.20) THEN
                  IF(MASWRK) WRITE(IW,*)
     *              ' ERROR: NMDFFD MORE THAN',20
                  CALL ABRT
                END IF
                LSTGRP(NMDFFD,1) = NUMFFD(J)
                IF(NUMFFD(J+1).GT.0) THEN
                  LSTGRP(NMDFFD,2) = NUMFFD(J+1)
                  DO K = J+2, J+1+NUMFFD(J+1)
                    IF(NUMFFD(K).GT.0) THEN
                      LSTGRP(NMDFFD,K-J+1)=NUMFFD(K)
                    ELSE
                      IF(MASWRK) WRITE(IW,*)
     *                  ' ERROR: NUMFFD(',K,') IS EMPTY'
                      CALL ABRT
                    END IF
                  ENDDO
                  IF(NUMFFD(J+2+NUMFFD(J+1)).GT.0) THEN
                    J = J + 2 + NUMFFD(J+1)
                    GO TO 200
                  END IF
                  GO TO 300
                ELSE
                  IF(MASWRK) WRITE(IW,*)
     *              ' ERROR: NUMFFD(',J+1,') IS EMPTY'
                  CALL ABRT
                END IF
         END IF
      ENDDO
C
C     PRINT MESSAGE
C
 300  CONTINUE
      DO I =1, MXATM
         IF(MIDPRT(I).GT.0 .OR.
     *       NOPRT(I).GT.0     ) THEN
           IF(MASWRK) WRITE(IW,*) ' '
           IF(MASWRK) WRITE(IW,*) '$PRTEFP INPUT IS EFFECTIVE...'
           IF(MASWRK) WRITE(IW,*)
     *'SOME EXPANSION AND POLARIZABLE POINTS WILL NOT',
     *' BE PRINTED/PUNCHED OUT.'
           GO TO 400
         END IF
      ENDDO
C
 400  CONTINUE
      IF(NMDFFD.GT.0) THEN
        IF(MASWRK) THEN
           WRITE(IW,9100)
           DO I = 1, NMDFFD
             WRITE(IW,'(A,I5,A/18I5)')
     *         ' CONNECTION ATOM',LSTGRP(I,1),
     *         ' COLLECTS THE CHARGES ON ATOMS:',
     *          (LSTGRP(I,J),J=3,2+LSTGRP(I,2))
           ENDDO
        END IF
      END IF
      RETURN
C
 9100 FORMAT(1X,'EFP/FORCE FIELD CONNECTION POINTS COLLECT ESCAPED',
     *          ' CHARGES'/
     *       1X,'SO THE EFP GENERATED HAS AN INTEGER CHARGE.')
      END
C
C*MODULE EFINP   *DECK RDDPTEN
      SUBROUTINE RDDPTEN(NPTS,N)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      PARAMETER (MXPT=2000, MXFRG=1050, MXIFRQ=12,MXDFG=5,
     *           MXDPPT=MXFRG*MXDFG*12)
C
      CHARACTER*8 MNAME,PNAME,RNAME,DPNAME,FNAME
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ*MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      IERR = 0
      IEOF = 0
      NPTS = 0
  100 CONTINUE
      K = NPTS + 1
      IF(K.GT.MXIFRQ*MXPT) THEN
         IF(MASWRK) WRITE(IW,9000) N,MXPT
         CALL ABRT
      END IF
C
      CALL RDCARD('RDDPTEN1',IEOF)
      IF(IEOF.EQ.1) CALL ABRT
      DPNAME(K) = '        '
      LGSTR=-8
      CALL GSTRNG(DPNAME(K),LGSTR)
      IF(DPNAME(K).EQ.'STOP    ') GO TO 600
      DO 120 L = 1,NMPTS(N)
        IF(DPNAME(K).EQ.MNAME(L)) GO TO 130
  120 CONTINUE
      GO TO 140
  130 CONTINUE
      DPCORD(1,K) = CORD(1,L)
      DPCORD(2,K) = CORD(2,L)
      DPCORD(3,K) = CORD(3,L)
      GO TO 200
  140 CONTINUE
C
C          input files now have an integer in front of the
C          center of LMO coordinates: this is to be ignored.
C          old input's may not have this, in which case the
C          value has to be rescanned as X-component of DPCORD.
C          Note that DPCORD is copied into EFDP storage later.
C       (this mistake survived for years, it appears EFPD isn't used?)
C
      ctno = rfind('CT no.  ',ierr)
      ictno = int(ctno)
      if (abs(ctno - ictno).lt.1.0d-06) then
         continue
      else
         call reread
      end if
C
      DO 150 J=1,3
        DPCORD(J,K) = RFIND('DPCORD  ',IERR)
        IF(IERR.NE.0) CALL ABRT
  150 CONTINUE
  200 CONTINUE
      CALL RDCARD('RDDPTEN2',IEOF)
      IF(IEOF.EQ.1) CALL ABRT
      DO 500 L=1,9
        DPOLT(L,K) = RFIND('DPOLT   ',IERR)
        IF(IERR.NE.0) CALL ABRT
  500 CONTINUE
      NPTS = NPTS + 1
      GO TO 100
C
  600 CONTINUE
      RETURN
C
 9000 FORMAT(1X,'ERROR IN READING DYNAMIC POLARIZABLE
     *       POINTS FOR FRAGMENT',I4,' EXCEEDED MXPT=',I5)
      END
C*MODULE EFINP   *DECK RDCANV
      SUBROUTINE RDCANV(N,CTVEC,MXBF,NTCTMOF)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXAO=8192, MXDFG=5, MXFRG=1050, MXFGPT=12000)
C
      LOGICAL GOPARR,MASWRK,DSKWRK
      CHARACTER*8 WORD
C
      COMMON /EFPCT / NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CTFOK(MXAO,MXDFG),NCTMO(MXDFG),NTCTMO
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
C
      DIMENSION CTVEC(MXBF,NTCTMOF)
C
      IZERO = 0
      IONE  = 1
      ITWO  = 2
C
      NCTMOS=NCTMO(ISET(N))
      NAOS=NAO(ISET(N))
      IF(NAOS.GT.MXBF) THEN
         IF(MASWRK) WRITE(IW,9010) NAOS,MXBF
         CALL ABRT
      END IF
C
      IF (MASWRK) THEN
      DO 280 J = 1,NCTMOS
         IMAX = 0
         IC = 0
  240    CONTINUE
            IMIN = IMAX+1
            IMAX = IMAX+5
            IC = IC+1
            IF(IMAX .GT. NAOS) IMAX = NAOS
            READ(IR,9040,END=800,ERR=800) JJ,ICC,
     *                               (CTVEC(I,J+NTCTMO),I=IMIN,IMAX)
            MODJ=MOD(J,100)
            IF(JJ.EQ.MODJ . AND.  ICC.EQ.IC) GO TO 260
               WRITE(IW,9060) J,IC,JJ,ICC
               IF (GOPARR) CALL DDI_BCAST(355,'I',ITWO,1,MASTER)
               CALL ABRT
  260       CONTINUE
         IF(IMAX .LT. NPBF(N)) GO TO 240
C
  280 CONTINUE
      IF (GOPARR) CALL DDI_BCAST(355,'I',IZERO,1,MASTER)
C
C SLAVE WORK.  IEND=0,1,2 MEANS OK DATA, INCOMPLETE DATA, SCRAMBLED DATA
C
      ELSE
         IF (GOPARR) CALL DDI_BCAST(355,'I',IEND,1,MASTER)
         IF (IEND.EQ.IONE) GO TO 800
         IF (IEND.EQ.ITWO) CALL ABRT
      END IF
C
C  GIVE VECTORS TO ALL PROCESSES
C
      IF (GOPARR) CALL DDI_BCAST(356,'F',CTVEC,NAOS*NCTMOS,MASTER)
C
C         PROCESS EIGENVALUES.
C         THE SUBSECTION IS A NEW STRING 'CTFOK' OR THE OLD 'CANONFOK'.
C         WE LOOP OVER READING ONLY OCCUPIED, ALL ON A "SINGLE LINE",
C         BY USING >'S TO CONTINUE ONTO MULTIPLE LINES.
C         ONLY THE OCCUPIED EIGENVALUES ARE USED IN CHARGE-TRANSFER,
C         BUT THIS CODE FORMERLY READ VIRTUALS TOO.  WE LOOP AGAIN
C         TO COME TO A 'STOP'.
C
      IEOF = 0
      CALL RDCARD('CTFOK   ',IEOF)
      WORD='        '
      LGSTR=-8
      CALL GSTRNG(WORD,LGSTR)
      IF(WORD.EQ.'CTFOK   '  .OR.  WORD.EQ.'CANONFOK') GO TO 310
      IF(MASWRK) THEN
         WRITE(IW,9140) WORD
         CALL ABRT
      END IF
C
  310 CONTINUE
      CALL RDCARD('FOCK    ',IEOF)
      DO  I = 1,NOCC(ISET(N))
         CTFOK(I,ISET(N)) = RFIND('FOCK    ',IEOF)
      END DO
c
  330 CONTINUE
         CALL RDCARD('STOP    ',IEOF)
         WORD='        '
         LGSTR=-8
         CALL GSTRNG(WORD,LGSTR)
         IF(WORD.EQ.'STOP    ') GO TO 400
      GO TO 330
C
  400 CONTINUE
      RETURN
C
C        PREMATURE END OF $VEC INPUT ENCOUNTERED
C
  800 CONTINUE
      IF (MASWRK) THEN
         IF (GOPARR) CALL DDI_BCAST(355,'I',IONE,1,MASTER)
         WRITE(IW,9100) J,IC
      ENDIF
      CALL ABRT
      RETURN
C
 9010 FORMAT(/1X,'* * * ERROR * * *'/
     *       1X,'NUMBER OF AO''S IN THIS FRAGMENT =',I5,' EXCEEDS THE'/
     *       1X,'MAXIMUM NO. OF AO''S GIVEN IN $EFRAG=',I5/
     *       1X,'PLEASE GIVE CORRECT -MXBF- KEYWORDS',
     *       1X,' ON THE FIRST $EFRAG CARD.'/)
 9040 FORMAT(I2,I3,5E15.8)
 9060 FORMAT(' *** ERROR READING THE MO COEFFICIENTS AT',2I4/
     *       '     THE INPUT VALUES WERE',2I4)
 9100 FORMAT(' *** ERROR: PREMATURE END OF ORBITAL INPUT ENCOUNTERED'/
     *       '            LOOKING FOR ORBITAL',I4,' ELEMENT',I4)
 9140 FORMAT(1X,'ERROR: SUBSECTION ''CTFOK'' CONTAINING OCCUPIED',
     *          ' ORBITAL ENERGIES'/
     *       1X,'MUST FOLLOW RIGHT BEHIND ANY ''CTVEC'' SUBSECTION,'/
     *       1X,'BUT FOUND STRING >',A8,'< INSTEAD.')
      END
C*MODULE EFINP   *DECK RDMXBF
C>
C>    @brief    read MXBF/MXMO for EFP2 repulsion
C>
C>    @details  read MXBF/MXMO for EFP2 repulsion
C>
      SUBROUTINE RDMXBF(IDFRG,MXBF,MXMO)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      LOGICAL GOPARR,MASWRK,DSKWRK
C
      PARAMETER (MXDFG=5, MXFRG=1050)
C
      CHARACTER*8 FRGMNT,PTNAM,WORD
      CHARACTER*6 FRGNAM
      CHARACTER*1 DOLLAR,BLANK
C
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA DOLLAR,BLANK/'$',' '/
C
C         READ THE NUMBER OF AOS AND MOS GIVEN IN THE EFP GROUP
C         OF FRAGMENT NUMBER -IFRG-.  POSITION TO ITS GROUP...
C
      WRITE(UNIT=FRGMNT,FMT=8000) BLANK,DOLLAR,FRGNAM(NAMIDX(IDFRG))
 8000 FORMAT(A1,A1,A6)
C
      IEOF=0
      CALL SEQREW(IR)
      CALL FNDGRP(IR,FRGMNT,IEOF)
      IF(IEOF.EQ.1) THEN
         IF (MASWRK) WRITE(IW,9010) FRGMNT
         CALL ABRT
         RETURN
      END IF
C
C         MXBF AND MXMO FOR THIS FRAGMENT ARE GIVEN ON A LINE READING
C             "PROJECTION WAVEFUNCTION <MXMO> <MXBF>"
C         IT IS POSSIBLE TO ENCOUNTER A LINE SAYING "PROJECTION BASIS",
C         SO WE HAVE TO TEST THE SECOND WORD, TOO, TO POSITION TO THE
C         CORRECT LINE IN THE GROUP.
C
  200 CONTINUE
      CALL RDCARD('$FRAG 3 ',IEOF)
      IF(IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,9011) FRGMNT
         CALL ABRT
      END IF
      WORD='        '
      LGSTR=-8
      CALL GSTRNG(WORD,LGSTR)
C
C           NO SUCH LINE, SILENTLY EXIT, BUT ITS PROBABLY A BOOBOO.
      IF(WORD.EQ.'$END    ') GO TO 800
C
      IF(WORD.NE.'PROJECTI') GO TO 200
      WORD='        '
      LGSTR=-8
      CALL GSTRNG(WORD,LGSTR)
      IF(WORD.EQ.'WAVEFUNC') THEN
         IERR = 0
         NMOS = IFIND('NMOS    ',IERR)
         NAOS = IFIND('NAOS    ',IERR)
         IF(NAOS.LE.0  .OR.  NMOS.LE.0) THEN
            IF(MASWRK) WRITE(IW,9030) NMOS,NAOS
            CALL ABRT
         END IF
         IF(NAOS.GT.MXBF) MXBF=NAOS
         IF(NMOS.GT.MXMO) MXMO=NMOS
         GO TO 800
      ELSE
         GO TO 200
      END IF
C
  800 CONTINUE
      RETURN
C
 9010 FORMAT(1X,A8,'NOT FOUND, PLEASE CHECK FOR ERRORS')
 9011 FORMAT(1X,'ERROR, END OF FILE READING',A8,' INPUT GROUP (RDMXBF)')
 9030 FORMAT(1X,'ERROR READING "PROJECTION WAVEFUNCTION" SECTION'/
     *       1X,'NAOS=',I10,' NMOS=',I10,' MUST BOTH BE POSITIVE')
      END
C
C*MODULE EFINP   *DECK RDMXCTMO
      SUBROUTINE RDMXCTMO(IDFRG,MXCTMO)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      LOGICAL GOPARR,MASWRK,DSKWRK
C
      PARAMETER (MXDFG=5, MXFRG=1050)
C
      CHARACTER*8 FRGMNT,PTNAM,WORD
      CHARACTER*6 FRGNAM
      CHARACTER*1 DOLLAR,BLANK
C
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA DOLLAR,BLANK/'$',' '/
C
C----PX:  MIMIC RDMXBF
C         READ THE NUMBER OF LMOS GIVEN IN THE EFP GROUP
C         OF FRAGMENT NUMBER -IFRG-.  POSITION TO ITS GROUP...
C
C
      WRITE(UNIT=FRGMNT,FMT=8000) BLANK,DOLLAR,FRGNAM(NAMIDX(IDFRG))
 8000 FORMAT(A1,A1,A6)
C
      IEOF=0
      CALL SEQREW(IR)
      CALL FNDGRP(IR,FRGMNT,IEOF)
      IF(IEOF.EQ.1) THEN
         IF (MASWRK) WRITE(IW,9010) FRGMNT
         CALL ABRT
         RETURN
      END IF
C
C         NUMBER OF MO (INCLUDING VIRTUAL) FOR CHARGE TRANSFER
C         FOR A FRAGMENT
C         ARE GIVEN ON A LINE READING
C             "CTVEC <NOCC> <NCTMO>"
C
  200 CONTINUE
      CALL RDCARD('$FRAG 3 ',IEOF)
      IF(IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,9011) FRGMNT
         CALL ABRT
      END IF
      WORD='        '
      LGSTR=-8
      CALL GSTRNG(WORD,LGSTR)
C         ENCOUNTERING END OF FRAGMENT GROUP MEANS NO CHARGE-TRANSFER
      IF(WORD.EQ.'$END    ') GO TO 800
C
C           this subsection used to be called "canonical vectors"
      IF(WORD.EQ.'CTVEC   '  .OR.  WORD.EQ.'CANONVEC') THEN
         IERR=0
         NOCC  = IFIND('NOCC    ',IERR)
         NCTMO = IFIND('NCTMO   ',IERR)
         IF(NCTMO.GT.MXCTMO) MXCTMO=NCTMO
         IF(NOCC.LT.0) NOCC=0  ! SUPPRESS FTNCHEK WARNING
         GO TO 800
      ELSE
         GO TO 200
      END IF
C
  800 CONTINUE
      RETURN
C
 9010 FORMAT(1X,A8,'NOT FOUND, PLEASE CHECK FOR ERRORS')
 9011 FORMAT(1X,'ERROR, END OF FILE READING',A8,
     *          ' INPUT GROUP (RDMXCTMO)')
      END
C
C
C---- NEEDED TO PREPARE Q-CHEM EFP INPUT
CC*MODULE EFINP   *DECK MAT_TO_EULER
C      SUBROUTINE MAT_TO_EULER(T3,ALPHA,BETA, GAMMA)
C      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C      LOGICAL GOPARR,MASWRK,DSKWRK
CC
C      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
CC
C      DIMENSION T3(3,3)
C      PARAMETER (ONE=1.0D+00, ZERO=0.0D+00, PI=3.1415926535897932D+00)
CC
CC     CALCULATES EULER ANGLES (ALPHA, BETA, GAMMA) IN Z-X-Z
CC     NOTATION FROM ROTATION MATRIX T3
CC
CC      IF (MASWRK) THEN
CC      WRITE(6,*) 'GRAND ROTATION MATRIX'
CC      DO I=1,3
CC        WRITE(6,FMT='(3F9.5)') (T3(I,J), J=1,3)
CC      END DO
CC      CALL PRSQ(T3,3,3,3)
CC      END IF
CC
C      T00 = T3(1,1)
C      T01 = T3(1,2)
C      T02 = T3(1,3)
C      T10 = T3(2,1)
C      T11 = T3(2,2)
C      T12 = T3(2,3)
C      T20 = T3(3,1)
C      T21 = T3(3,2)
C      T22 = T3(3,3)
CC
C      IF (T22 .LT. ONE) THEN
C         IF (T22 .GT. -1.0D+00) THEN
C              THETAX = ACOS(T22)
C              THETAZ0 = ATAN2(T02,-T12)
C              THETAZ1 = ATAN2(T20,T21)
C         END IF
C         IF (T22 .EQ. -1.0D+00) THEN
CC      NOT A UNIQUE SOLUTION: THETAZ1 - THETAZ0 = ATAN2(-R01,R00)
C             THETAX = PI
C             THETAZ0 = -ATAN2(-T01,T00)
C             THETAZ1 = ZERO
C         END IF
C      ELSE
CC               R22 = +1
CC  NOT A UNIQUE SOLUTION: THETAZ1 + THETAZ0 = ATAN2(-R01,R00)
C         THETAX = ZERO
C         THETAZ0 = ATAN2(-T01,T00)
C         THETAZ1 = ZERO
C      END IF
CC
C      ALPHA = THETAZ0
C      BETA  = THETAX
C      GAMMA = THETAZ1
CC
CC      IF (MASWRK) WRITE(6,100) ALPHA,BETA, GAMMA
C      RETURN
CC
CC  100 FORMAT(3F10.6)
CC  100 FORMAT(1X,'EULER ANGLES:  ',/3X, 3F10.6)
C      END
C----
C*MODULE EFINP   *DECK FLEXIP
      SUBROUTINE FLEXIP(IJ,PROVEC,CTVEC,MXBF,NTMOF,NTCTMOF,
     *                  AVLVEC,TLVEC,AVCVEC,TCVEC,NBOPTS,NLPTS)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      PARAMETER (MXDFG=5, MXPT=2000, MXFRG=1050, MXFGPT=12000,
     *           MXAO=8192, MXSHEF=1000, MXGEFP=4000, MXIFRQ=12,
     *           MXDPPT=MXFRG*MXDFG*12)
C
      LOGICAL DOMONO,DODIPO,DOQUAD,DOOCTU
      LOGICAL DOMTMP,DODTMP,DOQTMP,DOOTMP
C
      CHARACTER*8 MNAME,PNAME,DPNAME,PTNAM,FRGNME,POLNAM,DPOLNAM,
     *            RNAME,FNAME
      CHARACTER*6 FRGNAM
C
      INTEGER TEMP(6),TEMPA(6),P1,P2,P3
      INTEGER TEMPB(6)
C
      DIMENSION IPAIRS1(2,200)
C
      COMMON /DOMULT/ DOMONO(MXFGPT),DODIPO(MXFGPT),DOQUAD(MXFGPT),
     *                DOOCTU(MXFGPT)
      COMMON /DOTMP / DOMTMP(MXPT),DODTMP(MXPT),DOQTMP(MXPT),
     *                DOOTMP(MXPT)
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NAT(MXDFG),NUM(MXDFG),NTPATM
      COMMON /EFPCT / NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CTFOK(MXAO,MXDFG),NCTMO(MXDFG),NTCTMO
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ*MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ*MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /KFINFO/ KATMS(MXFRG)
C
      DIMENSION PROVEC(MXBF,NTMOF),CTVEC(MXBF,NTCTMOF),TDIP1(3)
      DIMENSION AVDIP(3),TQAD(6),AVQAD(6),TOCT(10)
      DIMENSION AVOCT(10),TEFP(3),TPOL(9),AVEFP(3)
      DIMENSION AVPOL(9),AVDPOL(9),TEFDP(3),TDPOL(9)
      DIMENSION AVEFDP(3),TLMO(3),AVLMO(3)
      DIMENSION AVCENT(3),TCENT(3),AVLVEC(MXBF),TLVEC(MXBF),
     *          AVCVEC(MXBF),TCVEC(MXBF)
      DATA ZERO/0.0D+00/
C
C
      KATM =KATMS(IJ)
C
C     - GET BONDS FOR IJ ONLY -
      LUNIT = 1234567890 + IJ
      CALL GTBOND(IPAIRS1,200,NBONDS,LUNIT)
C
C     - ATOMIC POINTS -
C
      DO 200 I=1,KATM
C        - XCRD, YCRD, ZCRD STORE THE ATOMIC COORDINATES FOUND
C          IN $EFRAG OR $PDBFRG. USE THEM FOR ATOMIC POINTS
         EFC(1,NMTTPT+I)    = XCRD(I,IJ)
         EFC(2,NMTTPT+I)    = YCRD(I,IJ)
         EFC(3,NMTTPT+I)    = ZCRD(I,IJ)
C        - ATOM NAMES IN MNAME() AND PTNAM() MUST MATCH
         IF(MNAME(I).NE.PTNAM(I,IJ)) THEN
            WRITE(IW,*)' ERROR: FRAGNAME MISMATCH COORDINATE NAMES'
            WRITE(IW,*)MNAME(I),' VS ',PTNAM(I,IJ)
            CALL ABRT
         ELSE
            FRGNME(NMTTPT+I)   = MNAME(I)
         END IF
C        - ASSIGN STANDARD EFP VALUES
         EFCHG(1,NMTTPT+I)  = ACHG(1,I)
         EFCHG(2,NMTTPT+I)  = ACHG(2,I)
         EFATRM(NMTTPT+I)   = AMULT(I)
         EFBTRM(NMTTPT+I)   = BMULT(I)
         EFATRM2(NMTTPT+I)  = AMULT2(I)
         EFBTRM2(NMTTPT+I)  = BMULT2(I)
         DOMONO(NMTTPT+I)   = DOMTMP(I)
         DODIPO(NMTTPT+I)   = DODTMP(I)
         DOQUAD(NMTTPT+I)   = DOQTMP(I)
         DOOCTU(NMTTPT+I)   = DOOTMP(I)
         FMASS(NMTTPT+I)    = FPMASS(I)
         FGNUC(NMTTPT+I)    = FPNUC(I)
         K=0
         NOS=0
         P1=I
C
         DO J=1,NBONDS
            IF(IPAIRS1(1,J).EQ.P1) THEN
               K=K+1
               TEMP(K)=IPAIRS1(2,J)
            END IF
            IF(IPAIRS1(2,J).EQ.P1) THEN
               K=K+1
               TEMP(K)=IPAIRS1(1,J)
            END IF
         END DO
C
         AVDIP(1)=ZERO
         AVDIP(2)=ZERO
         AVDIP(3)=ZERO
         DO KK=1,6
            AVQAD(KK)=ZERO
         ENDDO
         DO KK=1,10
            AVOCT(KK)=ZERO
         ENDDO
C
         IF(K.EQ.1) THEN
            P2=TEMP(1)
            DO LBD=1,NBONDS
               MONE = IPAIRS1(1,LBD)
               MTWO = IPAIRS1(2,LBD)
               IF(    (MONE.EQ.P2.AND.MTWO.NE.P1)
     *            .OR.(MTWO.EQ.P2.AND.MONE.NE.P1)) THEN
                  IF(MONE.EQ.P2) P3 = MTWO
                  IF(MTWO.EQ.P2) P3 = MONE
                  NOS=NOS+1
                  CALL FRGROT2(IJ,P1,P2,P3,I,TDIP1,TQAD,TOCT,0)
                  DO KK = 1, 3
                     AVDIP(KK)=(AVDIP(KK)*(NOS-1)+TDIP1(KK))/NOS
                  ENDDO
                  DO KK = 1, 6
                     AVQAD(KK)=(AVQAD(KK)*(NOS-1)+TQAD(KK))/NOS
                  ENDDO
                  DO KK = 1, 10
                     AVOCT(KK)=(AVOCT(KK)*(NOS-1)+TOCT(KK))/NOS
                  ENDDO
               END IF
            END DO
         ELSE
            DO LBD=1,NBONDS
               MONE = IPAIRS1(1,LBD)
               MTWO = IPAIRS1(2,LBD)
               IF(MONE.EQ.P1 .OR. MTWO.EQ.P1) THEN
                  IF(MONE.EQ.P1) P2=MTWO
                  IF(MTWO.EQ.P1) P2=MONE
                  DO III=1,2
                     DO N=1,NBONDS
                        MONE = IPAIRS1(1,N)
                        MTWO = IPAIRS1(2,N)
                        IF ((MONE.EQ.P1.AND.MTWO.NE.P2).OR.
     *                      (MTWO.EQ.P1.AND.MONE.NE.P2)) THEN
                           IF(MONE.EQ.P1) P3 = MTWO
                           IF(MTWO.EQ.P1) P3 = MONE
                           NOS=NOS+1
                           IF (III.EQ.1) THEN
                              CALL FRGROT2(IJ,P1,P2,P3,I,
     *                                 TDIP1,TQAD,TOCT,0)
                           ELSE IF (III.EQ.2) THEN
                              CALL FRGROT2(IJ,P2,P1,P3,I,
     *                                 TDIP1,TQAD,TOCT,0)
                           END IF
                           DO KK = 1, 3
                              AVDIP(KK)=(AVDIP(KK)*(NOS-1)+
     *                                       TDIP1(KK))/NOS
                           ENDDO
                           DO KK = 1, 6
                              AVQAD(KK)=(AVQAD(KK)*(NOS-1)+
     *                                        TQAD(KK))/NOS
                           ENDDO
                           DO KK = 1, 10
                              AVOCT(KK)=(AVOCT(KK)*(NOS-1)+
     *                                        TOCT(KK))/NOS
                           ENDDO
                        END IF
                     END DO
                  END DO
               END IF
            END DO
         END IF
         DO L=1,6
            EFDIP(L,NMTTPT+I)=AVDIP(L)
         END DO
         DO L=1,6
            EFQAD(L,NMTTPT+I)=AVQAD(L)
         END DO
         DO L=1,10
            EFOCT(L,NMTTPT+I)=AVOCT(L)
         END DO
 200  CONTINUE
C
C
C     - BOND MIDPOINTS -
C
      IF(NBOPTS.GT.0) THEN
         DO 300 I=1,NBONDS
            P1=IPAIRS1(1,I)
            P2=IPAIRS1(2,I)
            EFC(1,NMTTPT+I+KATM)    = (XCRD(P1,IJ)+XCRD(P2,IJ))/2.0D+00
            EFC(2,NMTTPT+I+KATM)    = (YCRD(P1,IJ)+YCRD(P2,IJ))/2.0D+00
            EFC(3,NMTTPT+I+KATM)    = (ZCRD(P1,IJ)+ZCRD(P2,IJ))/2.0D+00
            FRGNME(NMTTPT+I+KATM)   = MNAME(I+KATM)
            EFCHG(1,NMTTPT+I+KATM)  = ACHG(1,I+KATM)
            EFCHG(2,NMTTPT+I+KATM)  = ACHG(2,I+KATM)
            EFATRM(NMTTPT+I+KATM)   = AMULT(I+KATM)
            EFBTRM(NMTTPT+I+KATM)   = BMULT(I+KATM)
            EFATRM2(NMTTPT+I+KATM)  = AMULT2(I+KATM)
            EFBTRM2(NMTTPT+I+KATM)  = BMULT2(I+KATM)
            DOMONO(NMTTPT+I+KATM)   = DOMTMP(I+KATM)
            DODIPO(NMTTPT+I+KATM)   = DODTMP(I+KATM)
            DOQUAD(NMTTPT+I+KATM)   = DOQTMP(I+KATM)
            DOOCTU(NMTTPT+I+KATM)   = DOOTMP(I+KATM)
            FMASS(NMTTPT+I+KATM)    = FPMASS(I+KATM)
            FGNUC(NMTTPT+I+KATM)    = FPNUC(I+KATM)
            NOS=0
            AVDIP(1)=0
            AVDIP(2)=0
            AVDIP(3)=0
            DO K2=1,6
               AVQAD(K2)=0
            ENDDO
            DO K2=1,10
               AVOCT(K2)=0
            ENDDO
C
            DO III=1,2
               DO LBD=1,NBONDS
                  MONE=IPAIRS1(1,LBD)
                  MTWO=IPAIRS1(2,LBD)
                  IF(    (MONE.EQ.P1.AND.MTWO.NE.P2)
     *               .OR.(MONE.EQ.P2.AND.MTWO.NE.P1)
     *               .OR.(MTWO.EQ.P1.AND.MONE.NE.P2)
     *               .OR.(MTWO.EQ.P2.AND.MONE.NE.P1)) THEN
                     IF(MONE.EQ.P1 .OR. MONE.EQ.P2) P3=MTWO
                     IF(MTWO.EQ.P1 .OR. MTWO.EQ.P2) P3=MONE
                     NOS=NOS+1
                     IF(III.EQ.1) THEN
                        CALL FRGROT2(IJ,
     *                       P1,P2,P3,I,TDIP1,TQAD,TOCT,KATM)
                     ELSE IF(III.EQ.2) THEN
                        CALL FRGROT2(IJ,
     *                       P2,P1,P3,I,TDIP1,TQAD,TOCT,KATM)
                     END IF
                     DO K2 = 1, 3
                        AVDIP(K2)=(AVDIP(K2)*(NOS-1)+TDIP1(K2))/NOS
                     ENDDO
                     DO K2 = 1, 6
                        AVQAD(K2)=(AVQAD(K2)*(NOS-1)+TQAD(K2))/NOS
                     ENDDO
                     DO K2 = 1, 10
                        AVOCT(K2)=(AVOCT(K2)*(NOS-1)+TOCT(K2))/NOS
                     ENDDO
                  END IF
               END DO
            END DO
C
            EFDIP(1,NMTTPT+I+KATM)=AVDIP(1)
            EFDIP(2,NMTTPT+I+KATM)=AVDIP(2)
            EFDIP(3,NMTTPT+I+KATM)=AVDIP(3)
            DO L=1,6
               EFQAD(L,NMTTPT+I+KATM)=AVQAD(L)
            END DO
            DO L=1,10
               EFOCT(L,NMTTPT+I+KATM)=AVOCT(L)
            END DO
 300     CONTINUE
C
      END IF
C
C
C     - LMO CENTROIDS -
C
      IF(NLPTS.GT.0) THEN
C
         DO 400 I=1,NLPTS
            FRGNME(NMTTPT+I+KATM)  = MNAME(I+KATM)
            EFCHG(1,NMTTPT+I+KATM) = ACHG(1,I+KATM)
            EFCHG(2,NMTTPT+I+KATM) = ACHG(2,I+KATM)
            EFATRM(NMTTPT+I+KATM)  = AMULT(I+KATM)
            EFBTRM(NMTTPT+I+KATM)  = BMULT(I+KATM)
            EFATRM2(NMTTPT+I+KATM) = AMULT2(I+KATM)
            EFBTRM2(NMTTPT+I+KATM)  = BMULT2(I+KATM)
            DOMONO(NMTTPT+I+KATM)  = DOMTMP(I+KATM)
            DODIPO(NMTTPT+I+KATM)  = DODTMP(I+KATM)
            DOQUAD(NMTTPT+I+KATM)  = DOQTMP(I+KATM)
            DOOCTU(NMTTPT+I+KATM)  = DOOTMP(I+KATM)
            FMASS(NMTTPT+I+KATM)   = FPMASS(I+KATM)
            FGNUC(NMTTPT+I+KATM)   = FPNUC(I+KATM)
            NOS=0
            DO KK=1,3
               AVLMO(KK)=ZERO
               AVDIP(KK)=ZERO
            END DO
            DO KK=1,6
               AVQAD(KK)=ZERO
            END DO
            DO KK=1,10
               AVOCT(KK)=ZERO
            END DO
C
            K=0
            DO J=1,KATM
               DIST=(CORD(1,I+KATM)-CORD(1,J))**2+
     *              (CORD(2,I+KATM)-CORD(2,J))**2+
     *              (CORD(3,I+KATM)-CORD(3,J))**2
               IF(DIST.LE.2.90D+00) THEN
                  K=K+1
                  TEMPA(K)=J
               END IF
            END DO
C
            IF(K.EQ.2) THEN
               DO III=1,2
                  P1=TEMPA(1)
                  P2=TEMPA(2)
                  DO 410 LBD=1,NBONDS
                     MONE = IPAIRS1(1,LBD)
                     MTWO = IPAIRS1(2,LBD)
                     IF(    (MONE.EQ.P2.AND.MTWO.NE.P1)
     *                  .OR.(MONE.EQ.P1.AND.MTWO.NE.P2)
     *                  .OR.(MTWO.EQ.P2.AND.MONE.NE.P1)
     *                  .OR.(MTWO.EQ.P1.AND.MONE.NE.P2)) THEN
                        IF(MONE.EQ.P1 .OR. MONE.EQ.P2) P3=MTWO
                        IF(MTWO.EQ.P1 .OR. MTWO.EQ.P2) P3=MONE
                           NOS=NOS+1
                        IF(III.EQ.1) THEN
                           CALL LMOROT(IJ,TLMO,P1,P2,P3,
     *                               TDIP1,TQAD,TOCT,I)
                        ELSE IF(III.EQ.2) THEN
                           CALL LMOROT(IJ,TLMO,P2,P1,P3,
     *                               TDIP1,TQAD,TOCT,I)
                        END IF
                        DO KK = 1, 3
                           AVLMO(KK)=(AVLMO(KK)*(NOS-1)+TLMO(KK))/NOS
                           AVDIP(KK)=(AVDIP(KK)*(NOS-1)+TDIP1(KK))/NOS
                        ENDDO
                        DO KK = 1, 6
                           AVQAD(KK)=(AVQAD(KK)*(NOS-1)+TQAD(KK))/NOS
                        ENDDO
                        DO KK = 1, 10
                           AVOCT(KK)=(AVOCT(KK)*(NOS-1)+TOCT(KK))/NOS
                        ENDDO
                     END IF
 410              CONTINUE
               END DO
            END IF
C
            IF (K.EQ.1) THEN
               P1=TEMPA(1)
               K2=0
               DIST=(CORD(1,I+KATM)-CORD(1,P1))**2+
     *              (CORD(2,I+KATM)-CORD(2,P1))**2+
     *              (CORD(3,I+KATM)-CORD(3,P1))**2
C
               DO LBD=1,NBONDS
                  MONE = IPAIRS1(1,LBD)
                  MTWO = IPAIRS1(2,LBD)
                  IF(MONE.EQ.P1 .OR. MTWO.EQ.P1) THEN
                     K2=K2+1
                  END IF
               END DO
C
               IF ((K2.GT.1).AND.(DIST.LT.0.25D+00)) THEN
                  DO III=1,2
                     DO LBD=1,NBONDS
                        MONE = IPAIRS1(1,LBD)
                        MTWO = IPAIRS1(2,LBD)
                        IF(MONE.EQ.P1 .OR. MTWO.EQ.P1) THEN
                           IF(MONE.EQ.P1) P2=MTWO
                           IF(MTWO.EQ.P1) P2=MONE
                           DO 420 N=1,NBONDS
                              MONE = IPAIRS1(1,N)
                              MTWO = IPAIRS1(2,N)
                              IF(    (MONE.EQ.P1.AND.MTWO.NE.P2)
     *                           .OR.(MTWO.EQ.P1.AND.MONE.NE.P2)) THEN
                                 IF(MONE.EQ.P1) P3 = MTWO
                                 IF(MTWO.EQ.P1) P3 = MONE
                                 NOS=NOS+1
                                 IF (III.EQ.1) THEN
                                    CALL LMOROT(IJ,TLMO,P1,P2,P3,
     *                              TDIP1,TQAD,TOCT,I)
                                 ELSE IF (III.EQ.2) THEN
                                    CALL LMOROT(IJ,TLMO,P2,P1,P3,
     *                              TDIP1,TQAD,TOCT,I)
                                 END IF
                                 DO KK = 1, 3
                                    AVLMO(KK)=(AVLMO(KK)*(NOS-1)+
     *                                         TLMO(KK))/NOS
                                    AVDIP(KK)=(AVDIP(KK)*(NOS-1)+
     *                                         TDIP1(KK))/NOS
                                 ENDDO
                                 DO KK = 1, 6
                                    AVQAD(KK)=(AVQAD(KK)*(NOS-1)+
     *                              TQAD(KK))/NOS
                                 ENDDO
                                 DO KK = 1, 10
                                    AVOCT(KK)=(AVOCT(KK)*(NOS-1)+
     *                              TOCT(KK))/NOS
                                 ENDDO
                              END IF
 420                       CONTINUE
                        END IF
                     END DO
                  END DO
               ELSE
C
                  DO LBD=1,NBONDS
                     MONE = IPAIRS1(1,LBD)
                     MTWO = IPAIRS1(2,LBD)
                     IF(MONE.EQ.P1 .OR. MTWO.EQ.P1) THEN
                        IF(MONE.EQ.P1) P2=MTWO
                        IF(MTWO.EQ.P1) P2=MONE
                        DO 430 N=1,NBONDS
                           MONE = IPAIRS1(1,N)
                           MTWO = IPAIRS1(2,N)
                           IF(    (MONE.EQ.P2.AND.MTWO.NE.P1)
     *                        .OR.(MTWO.EQ.P2.AND.MONE.NE.P1)) THEN
                              IF(MONE.EQ.P2) P3 = MTWO
                              IF(MTWO.EQ.P2) P3 = MONE
                              NOS=NOS+1
                              CALL LMOROT(IJ,TLMO,P1,P2,P3,
     *                                   TDIP1,TQAD,TOCT,I)
                              DO KK = 1, 3
                                 AVLMO(KK)=(AVLMO(KK)*(NOS-1)+
     *                                           TLMO(KK))/NOS
                                 AVDIP(KK)=(AVDIP(KK)*(NOS-1)+
     *                                          TDIP1(KK))/NOS
                              ENDDO
                              DO KK = 1, 6
                                 AVQAD(KK)=(AVQAD(KK)*(NOS-1)+
     *                                           TQAD(KK))/NOS
                              ENDDO
                              DO KK = 1, 10
                                 AVOCT(KK)=(AVOCT(KK)*(NOS-1)+
     *                                           TOCT(KK))/NOS
                              ENDDO
                           END IF
 430                    CONTINUE
                     END IF
                  END DO
               END IF
            END IF
            DO L=1,3
               EFC(L,NMTTPT+I+KATM)=AVLMO(L)
               EFDIP(L,NMTTPT+I+KATM)=AVDIP(L)
            END DO
            DO L=1,6
               EFQAD(L,NMTTPT+I+KATM)=AVQAD(L)
            END DO
            DO L=1,10
               EFOCT(L,NMTTPT+I+KATM)=AVOCT(L)
            END DO
 400     CONTINUE
C
      END IF
C
C
C     - POLARIZABILITY POINTS -
C
      DO 500 I=1,NPPTS(IJ)
         DO L=1,3
            AVEFP(L)=ZERO
         ENDDO
         DO L=1,9
            AVPOL(L)=ZERO
         ENDDO
         K=0
         DO J=1,KATM
            DIST=(PCORD(1,I)-CORD(1,J))**2+
     *           (PCORD(2,I)-CORD(2,J))**2+
     *           (PCORD(3,I)-CORD(3,J))**2
            IF(DIST.LE.2.90D+00) THEN
               K=K+1
               TEMPA(K)=J
            END IF
         END DO
C
         NOS=0
C
         IF(K.EQ.2) THEN
            DO III=1,2
               P1=TEMPA(1)
               P2=TEMPA(2)
               DO 9698 LBD=1,NBONDS
                  MONE = IPAIRS1(1,LBD)
                  MTWO = IPAIRS1(2,LBD)
                  IF(    (MONE.EQ.P2.AND.MTWO.NE.P1)
     *               .OR.(MONE.EQ.P1.AND.MTWO.NE.P2)
     *               .OR.(MTWO.EQ.P2.AND.MONE.NE.P1)
     *               .OR.(MTWO.EQ.P1.AND.MONE.NE.P2)) THEN
                     IF(MONE.EQ.P1 .OR. MONE.EQ.P2) P3=MTWO
                     IF(MTWO.EQ.P1 .OR. MTWO.EQ.P2) P3=MONE
                     NOS=NOS+1
                     IF(III.EQ.1) THEN
                        CALL POLROT(IJ,TEFP,TPOL,P1,P2,P3,I)
                     ELSE IF(III.EQ.2) THEN
                        CALL POLROT(IJ,TEFP,TPOL,P2,P1,P3,I)
                     END IF
                     DO KK=1,3
                        AVEFP(KK)=(AVEFP(KK)*(NOS-1)+TEFP(KK))/NOS
                     ENDDO
                     DO KK=1,9
                        AVPOL(KK)=(AVPOL(KK)*(NOS-1)+TPOL(KK))/NOS
                     ENDDO
                  END IF
 9698          CONTINUE
            END DO
         END IF
C
         IF (K.EQ.1) THEN
            P1=TEMPA(1)
            DO LBD=1,NBONDS
               MONE = IPAIRS1(1,LBD)
               MTWO = IPAIRS1(2,LBD)
               IF(MONE.EQ.P1 .OR. MTWO.EQ.P1) THEN
                  IF(MONE.EQ.P1) P2=MTWO
                  IF(MTWO.EQ.P1) P2=MONE
                  DO 9699 N=1,NBONDS
                     MONE = IPAIRS1(1,N)
                     MTWO = IPAIRS1(2,N)
                     IF(    (MONE.EQ.P2.AND.MTWO.NE.P1)
     *                  .OR.(MTWO.EQ.P2.AND.MONE.NE.P1)) THEN
                        IF(MONE.EQ.P2) P3 = MTWO
                        IF(MTWO.EQ.P2) P3 = MONE
                        NOS=NOS+1
                        CALL POLROT(IJ,TEFP,TPOL,P1,P2,P3,I)
                        DO KK=1,3
                           AVEFP(KK)=(AVEFP(KK)*(NOS-1)+TEFP(KK))/NOS
                        ENDDO
                        DO KK=1,9
                           AVPOL(KK)=(AVPOL(KK)*(NOS-1)+TPOL(KK))/NOS
                        ENDDO
                     END IF
 9699             CONTINUE
               END IF
            ENDDO
         END IF
C
         EFP(1,I+NPTTPT)   =AVEFP(1)
         EFP(2,I+NPTTPT)   =AVEFP(2)
         EFP(3,I+NPTTPT)   =AVEFP(3)
         POLNAM(I+NPTTPT)  = PNAME(I)
         POLSCR(I+NPTTPT)  = POLSCRN(I)
         DO L=1,9
            EFPOL(L,NPTTPT+I) =AVPOL(L)
         ENDDO
 500  CONTINUE
C
C
C     - DYNAMIC POLARIZABLE POINTS -
      DO 600 I=1,NDPPTS(IJ)
         DO L=1,3
            AVEFDP(L)=ZERO
         ENDDO
         DO L=1,9
            AVDPOL(L)=ZERO
         ENDDO
C
         DO 610 J=1,KATM
            NOS=0
            DIST=(DPCORD(1,I)-CORD(1,J))**2+
     *           (DPCORD(2,I)-CORD(2,J))**2+
     *           (DPCORD(3,I)-CORD(3,J))**2
            IF(DIST.LE.2.90D+00) THEN
               K=1
               DO L=1,NBONDS
                  IF(IPAIRS1(1,L).EQ.J) THEN
                     TEMPB(K)=IPAIRS1(2,L)
                     K=K+1
                  END IF
                   IF(IPAIRS1(2,L).EQ.J) THEN
                     TEMPB(K)=IPAIRS1(1,L)
                     K=K+1
                  END IF
               END DO
               P1=J
               IF(K.EQ.2) THEN
                  P2=TEMPB(1)
                  DO N=1,NBONDS
                     IF(IPAIRS1(1,N).EQ.P2) THEN
                        IF(IPAIRS1(2,N).EQ.P1) THEN
                           GOTO 727
                        ELSE
                           P3=IPAIRS1(2,N)
                           NOS=NOS+1
                           CALL DPOLROT(IJ,TEFDP,TDPOL,P1,P2,P3,I)
                           DO KK=1,3
                              AVEFDP(KK)=(AVEFDP(KK)*(NOS-1)
     *                                   +TEFDP(KK))/NOS
                           ENDDO
                           DO KK=1,9
                              AVDPOL(KK)=(AVDPOL(KK)*(NOS-1)
     *                                   +TDPOL(KK))/NOS
                           ENDDO
                        END IF
                     END IF
  727                CONTINUE
                     IF(IPAIRS1(2,N).EQ.P2) THEN
                        IF(IPAIRS1(1,N).EQ.P1) THEN
                           GOTO 725
                        ELSE
                           P3=IPAIRS1(1,N)
                           NOS=NOS+1
                           CALL DPOLROT(IJ,TEFDP,TDPOL,P1,P2,P3,I)
                           DO KK=1,3
                              AVEFDP(KK)=(AVEFDP(KK)*(NOS-1)
     *                                   +TEFDP(KK))/NOS
                           ENDDO
                           DO KK=1,9
                              AVDPOL(KK)=(AVDPOL(KK)*(NOS-1)
     *                                   +TDPOL(KK))/NOS
                           ENDDO
                        END IF
                     END IF
  725                CONTINUE
                  END DO
               END IF
C
               DO L=1,K-1
                  P2=TEMPB(L)
                  DO M=1,L
                     IF(TEMPB(M).EQ.P2) THEN
                        GOTO 722
                     ELSE
                        P3=TEMPB(M)
                        NOS=NOS+1
                           CALL DPOLROT(IJ,TEFDP,TDPOL,P1,P2,P3,I)
                           DO KK=1,3
                              AVEFDP(KK)=(AVEFDP(KK)*(NOS-1)
     *                                   +TEFDP(KK))/NOS
                           ENDDO
                           DO KK=1,9
                              AVDPOL(KK)=(AVDPOL(KK)*(NOS-1)
     *                                   +TDPOL(KK))/NOS
                           ENDDO
                     END IF
                  END DO
  722             CONTINUE
               END DO
            END IF
 610     CONTINUE
         EFDP(1,I+NDPTTPT)   =AVEFDP(1)
         EFDP(2,I+NDPTTPT)   =AVEFDP(2)
         EFDP(3,I+NDPTTPT)   =AVEFDP(3)
         DPOLNAM(I+NDPTTPT)  = DPNAME(I)
         DO L=1,9
            EFDPOL(L,NDPTTPT+I) =AVDPOL(L)
         ENDDO
 600  CONTINUE
C
C
C     - LMO VEC FOR EX-REP -
C
      INAT = NAT(ISET(IJ))
      IF(INAT.EQ.0) RETURN
      DO I=1,INAT
         PRCORD(1,I+NTPATM) = XCRD(I,IJ)
         PRCORD(2,I+NTPATM) = YCRD(I,IJ)
         PRCORD(3,I+NTPATM) = ZCRD(I,IJ)
      END DO
C
      DO 700 I=1,NORB(IJ)
         DO L=1,3
            AVCENT(L)=ZERO
         ENDDO
         DO L=1,MXBF
            AVLVEC(L)=ZERO
            AVCVEC(L)=ZERO
         ENDDO
         K=0
         DO J=1,KATM
            DIST=(CENTCD(1,I+NTMO)-CORD(1,J))**2+
     *           (CENTCD(2,I+NTMO)-CORD(2,J))**2+
     *           (CENTCD(3,I+NTMO)-CORD(3,J))**2
            IF(DIST.LE.2.90D+00) THEN
               K=K+1
               TEMPA(K)=J
            END IF
         END DO
C
         NOS=0
C
         IF(K.EQ.2) THEN
         DO III=1,2
            P1=TEMPA(1)
            P2=TEMPA(2)
            DO 710 LBD=1,NBONDS
               MONE = IPAIRS1(1,LBD)
               MTWO = IPAIRS1(2,LBD)
               IF(    (MONE.EQ.P2.AND.MTWO.NE.P1)
     *            .OR.(MONE.EQ.P1.AND.MTWO.NE.P2)
     *            .OR.(MTWO.EQ.P2.AND.MONE.NE.P1)
     *            .OR.(MTWO.EQ.P1.AND.MONE.NE.P2)) THEN
                     IF(MONE.EQ.P1 .OR. MONE.EQ.P2) P3=MTWO
                     IF(MTWO.EQ.P1 .OR. MTWO.EQ.P2) P3=MONE
                     NOS=NOS+1
                     IF(III.EQ.1) THEN
                        CALL MOROT(IJ,PROVEC,
     *                         CTVEC,MXBF,NTMOF,NTCTMOF,
     *                         P1,P2,P3,I,TCENT,TLVEC,TCVEC)
                     ELSE IF(III.EQ.2) THEN
                        CALL MOROT(IJ,PROVEC,
     *                         CTVEC,MXBF,NTMOF,NTCTMOF,
     *                         P2,P1,P3,I,TCENT,TLVEC,TCVEC)
                     END IF
                     DO KK=1,3
                        AVCENT(KK)=(AVCENT(KK)*(NOS-1)+TCENT(KK))/NOS
                     ENDDO
                     DO KK=1,MXBF
                        AVLVEC(KK)=(AVLVEC(KK)*(NOS-1)+TLVEC(KK))/NOS
                        AVCVEC(KK)=(AVCVEC(KK)*(NOS-1)+TCVEC(KK))/NOS
                     ENDDO
               END IF
 710        CONTINUE
         END DO
         END IF
C
        IF (K.EQ.1) THEN
          P1=TEMPA(1)
          DO LBD=1,NBONDS
             MONE = IPAIRS1(1,LBD)
             MTWO = IPAIRS1(2,LBD)
             IF(MONE.EQ.P1 .OR. MTWO.EQ.P1) THEN
                IF(MONE.EQ.P1) P2=MTWO
                IF(MTWO.EQ.P1) P2=MONE
                DO 720 N=1,NBONDS
                   MONE = IPAIRS1(1,N)
                   MTWO = IPAIRS1(2,N)
                   IF(    (MONE.EQ.P2.AND.MTWO.NE.P1)
     *                .OR.(MTWO.EQ.P2.AND.MONE.NE.P1)) THEN
                      IF(MONE.EQ.P2) P3 = MTWO
                      IF(MTWO.EQ.P2) P3 = MONE
                     NOS=NOS+1
                     CALL MOROT(IJ,PROVEC,
     *                      CTVEC,MXBF,NTMOF,NTCTMOF,
     *                         P1,P2,P3,I,TCENT,TLVEC,TCVEC)
                     DO KK=1,3
                        AVCENT(KK)=(AVCENT(KK)*(NOS-1)+TCENT(KK))/NOS
                     ENDDO
                     DO KK=1,MXBF
                        AVLVEC(KK)=(AVLVEC(KK)*(NOS-1)+TLVEC(KK))/NOS
                        AVCVEC(KK)=(AVCVEC(KK)*(NOS-1)+TCVEC(KK))/NOS
                     ENDDO
                   END IF
 720            CONTINUE
             END IF
          ENDDO
        END IF
C
        DO L=1,3
           CENTCD(L,I+NTMO) = AVCENT(L)
        ENDDO
        DO L=1,MXBF
           PROVEC(L,NTMO+I) = AVLVEC(L)
           CTVEC(L,NTCTMO+I) = AVCVEC(L)
        ENDDO
 700  CONTINUE
C
      RETURN
      END
C*MODULE EFINP   *DECK FRGROT2
      SUBROUTINE FRGROT2(N,P1,P2,P3,NOW,TDIP1,TQAD,TOCT,MP)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      PARAMETER (MXPT=2000, MXFRG=1050,
     *          MXIFRQ=12)
C
C
      CHARACTER*8 MNAME,PNAME,DPNAME,PTNAM,RNAME,FNAME
      CHARACTER*6 FRGNAM
C
      INTEGER P1,P2,P3
C
      DIMENSION T1(3,3), T2(3,3), T3(3,3), T3T(3,3)
      DIMENSION TEMP2(6), TEMP3(3), TEMP4(6,3)
      DIMENSION TEMP5(6,3),TDIP(3),TDIP1(3),TQAD(6)
      DIMENSION TOCT(10)
C
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ*MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
C
C --- FIND ROTATION MATRIX CONNECTING THE FRAGMENT N TO THE
C     STANDARD FRAGMENT.
C     1. FIND LOCAL COORD SYSTEM FOR FRAGMENT N
C
      CALL ROTMAT(XCRD(P1,N),YCRD(P1,N),ZCRD(P1,N),
     *            XCRD(P2,N),YCRD(P2,N),ZCRD(P2,N),
     *            XCRD(P3,N),YCRD(P3,N),ZCRD(P3,N),T1)
C
C     2. FIND LOCAL COORD SYSTEM FOR THESE THREE POINTS FOR THE
C        STANDARD FRAGMENT
C
      CALL ROTMAT(CORD(1,P1),CORD(2,P1),CORD(3,P1),
     *            CORD(1,P2),CORD(2,P2),CORD(3,P2),
     *            CORD(1,P3),CORD(2,P3),CORD(3,P3),T2)
C
C     3. FIND ROTATION MATRIX CONNECTING THESE TWO COORDINATE SYSTEMS
C
      CALL TRPOSE(T2,T3T,3,3,1)
      CALL MRARBR(T1,3,3,3,T2,3,3,T3,3)
C
C     4. COMPUTE TRANSPOSE
C
      CALL TRPOSE(T3,T3T,3,3,0)
C
C
      TDIP(1)=ADIP(1,NOW+MP)
      TDIP(2)=ADIP(2,NOW+MP)
      TDIP(3)=ADIP(3,NOW+MP)
      CALL MRARBR(T3,3,3,3,TDIP,3,1,TDIP1,3)
C
C
      CALL VCLR(TEMP3,1,3)
      TEMP2(1)=AQAD(1,NOW+MP)
      TEMP2(2)=AQAD(4,NOW+MP)
      TEMP2(3)=AQAD(2,NOW+MP)
      TEMP2(4)=AQAD(5,NOW+MP)
      TEMP2(5)=AQAD(6,NOW+MP)
      TEMP2(6)=AQAD(3,NOW+MP)
      CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
      TQAD(1)=TEMP4(1,1)
      TQAD(4)=TEMP4(2,1)
      TQAD(2)=TEMP4(3,1)
      TQAD(5)=TEMP4(4,1)
      TQAD(6)=TEMP4(5,1)
      TQAD(3)=TEMP4(6,1)
C
C
      TEMP2(1) = AOCT(1,NOW+MP)
      TEMP2(2) = AOCT(4,NOW+MP)
      TEMP2(3) = AOCT(6,NOW+MP)
      TEMP2(4) = AOCT(5,NOW+MP)
      TEMP2(5) = AOCT(10,NOW+MP)
      TEMP2(6) = AOCT(8,NOW+MP)
      CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
C
      TEMP2(1)=AOCT(4,NOW+MP)
      TEMP2(2)=AOCT(6,NOW+MP)
      TEMP2(3)=AOCT(2,NOW+MP)
      TEMP2(4)=AOCT(10,NOW+MP)
      TEMP2(5)=AOCT(7,NOW+MP)
      TEMP2(6)=AOCT(9,NOW+MP)
      CALL TFTRI(TEMP4(1,2),TEMP2,T3T,TEMP3,3,3,3)
C
      TEMP2(1)=AOCT(5,NOW+MP)
      TEMP2(2)=AOCT(10,NOW+MP)
      TEMP2(3)=AOCT(7,NOW+MP)
      TEMP2(4)=AOCT(8,NOW+MP)
      TEMP2(5)=AOCT(9,NOW+MP)
      TEMP2(6)=AOCT(3,NOW+MP)
      CALL TFTRI(TEMP4(1,3),TEMP2,T3T,TEMP3,3,3,3)
      CALL MRARBR(TEMP4,6,6,3,T3T,3,3,TEMP5,6)
      TOCT(1)=TEMP5(1,1)
      TOCT(2)=TEMP5(3,2)
      TOCT(3)=TEMP5(6,3)
      TOCT(4)=TEMP5(2,1)
      TOCT(5)=TEMP5(4,1)
      TOCT(6)=TEMP5(3,1)
      TOCT(7)=TEMP5(5,2)
      TOCT(8)=TEMP5(6,1)
      TOCT(9)=TEMP5(6,2)
      TOCT(10)=TEMP5(5,1)
C
      RETURN
      END
C*MODULE EFINP   *DECK LMOROT
      SUBROUTINE LMOROT(N,TLMO,P1,P2,P3,TDIP1,TQAD,TOCT,ILMO)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      PARAMETER (MXPT=2000, MXFRG=1050, MXIFRQ=12)
C
      CHARACTER*8 MNAME,PNAME,DPNAME,PTNAM,RNAME,FNAME
      CHARACTER*6 FRGNAM
C
      INTEGER P1,P2,P3
C
      DIMENSION T1(3,3), T2(3,3), T3(3,3), T3T(3,3)
      DIMENSION TEMP1(3), TEMP2(6), TEMP3(3), TEMP4(6,3)
      DIMENSION TEMP5(6,3),TDIP(3),TDIP1(3),TQAD(6)
      DIMENSION TOCT(10),TLMO(3)
C     DIMENSION CORD
C
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ*MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
      COMMON /KFINFO/ KATMS(MXFRG)
C
C
      KATM = KATMS(N)
      I1BAK=P1
      I2BAK=P2
      I3BAK=P3
C
C     1.  FIND LOCAL COORD SYSTEM FOR FRAGMENT N
C
      CALL ROTMAT(XCRD(P1,N),YCRD(P1,N),ZCRD(P1,N),
     *            XCRD(P2,N),YCRD(P2,N),ZCRD(P2,N),
     *            XCRD(P3,N),YCRD(P3,N),ZCRD(P3,N),T1)
C
C     2. FIND LOCAL COORD SYSTEM FOR THESE THREE POINTS FOR THE
C        STANDARD FRAGMENT
C
      CALL ROTMAT(CORD(1,P1),CORD(2,P1),CORD(3,P1),
     *            CORD(1,P2),CORD(2,P2),CORD(3,P2),
     *            CORD(1,P3),CORD(2,P3),CORD(3,P3),T2)
C
C     3. FIND ROTATION MATRIX CONNECTING THESE TWO COORDINATE SYSTEMS
C
      CALL TRPOSE(T2,T3T,3,3,1)
      CALL MRARBR(T1,3,3,3,T2,3,3,T3,3)
C
C     4. COMPUTE TRANSPOSE
C
      CALL TRPOSE(T3,T3T,3,3,0)
C
C
      DO J=1,3
         TEMP1(J) =CORD(J,ILMO+KATM)-CORD(J,P1)
      ENDDO
      CALL MRARBR(T3,3,3,3,TEMP1,3,1,TLMO,3)
      TLMO(1)=TLMO(1)+XCRD(P1,N)
      TLMO(2)=TLMO(2)+YCRD(P1,N)
      TLMO(3)=TLMO(3)+ZCRD(P1,N)
C
      TDIP(1)=ADIP(1,ILMO+KATM)
      TDIP(2)=ADIP(2,ILMO+KATM)
      TDIP(3)=ADIP(3,ILMO+KATM)
      CALL MRARBR(T3,3,3,3,TDIP,3,1,TDIP1,3)
C
      CALL VCLR(TEMP3,1,3)
      TEMP2(1)=AQAD(1,ILMO+KATM)
      TEMP2(2)=AQAD(4,ILMO+KATM)
      TEMP2(3)=AQAD(2,ILMO+KATM)
      TEMP2(4)=AQAD(5,ILMO+KATM)
      TEMP2(5)=AQAD(6,ILMO+KATM)
      TEMP2(6)=AQAD(3,ILMO+KATM)
      CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
      TQAD(1)=TEMP4(1,1)
      TQAD(4)=TEMP4(2,1)
      TQAD(2)=TEMP4(3,1)
      TQAD(5)=TEMP4(4,1)
      TQAD(6)=TEMP4(5,1)
      TQAD(3)=TEMP4(6,1)
C
      TEMP2(1) = AOCT(1, ILMO+KATM)
      TEMP2(2) = AOCT(4, ILMO+KATM)
      TEMP2(3) = AOCT(6, ILMO+KATM)
      TEMP2(4) = AOCT(5, ILMO+KATM)
      TEMP2(5) = AOCT(10,ILMO+KATM)
      TEMP2(6) = AOCT(8, ILMO+KATM)
      CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
C
      TEMP2(1)=AOCT(4, ILMO+KATM)
      TEMP2(2)=AOCT(6, ILMO+KATM)
      TEMP2(3)=AOCT(2, ILMO+KATM)
      TEMP2(4)=AOCT(10,ILMO+KATM)
      TEMP2(5)=AOCT(7, ILMO+KATM)
      TEMP2(6)=AOCT(9, ILMO+KATM)
      CALL TFTRI(TEMP4(1,2),TEMP2,T3T,TEMP3,3,3,3)
C
      TEMP2(1)=AOCT(5, ILMO+KATM)
      TEMP2(2)=AOCT(10,ILMO+KATM)
      TEMP2(3)=AOCT(7, ILMO+KATM)
      TEMP2(4)=AOCT(8, ILMO+KATM)
      TEMP2(5)=AOCT(9, ILMO+KATM)
      TEMP2(6)=AOCT(3, ILMO+KATM)
      CALL TFTRI(TEMP4(1,3),TEMP2,T3T,TEMP3,3,3,3)
C
      CALL MRARBR(TEMP4,6,6,3,T3T,3,3,TEMP5,6)
      TOCT(1)=TEMP5(1,1)
      TOCT(2)=TEMP5(3,2)
      TOCT(3)=TEMP5(6,3)
      TOCT(4)=TEMP5(2,1)
      TOCT(5)=TEMP5(4,1)
      TOCT(6)=TEMP5(3,1)
      TOCT(7)=TEMP5(5,2)
      TOCT(8)=TEMP5(6,1)
      TOCT(9)=TEMP5(6,2)
      TOCT(10)=TEMP5(5,1)
      P1=I1BAK
      P2=I2BAK
      P3=I3BAK
C
      RETURN
      END
C*MODULE EFINP   *DECK POLROT
      SUBROUTINE POLROT(N,TEFP,TPOL,P1,P2,P3,IIP)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      PARAMETER ( MXPT=2000, MXFRG=1050,
     *            MXIFRQ=12)
C
      CHARACTER*8 MNAME,PNAME,DPNAME,PTNAM,RNAME,FNAME
      CHARACTER*6 FRGNAM
      INTEGER P1,P2,P3
C
      DIMENSION T1(3,3), T2(3,3), T3(3,3), T3T(3,3)
      DIMENSION TEMP(3)
      DIMENSION TEFP(3),TPOL(9)
C
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ*MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
C
C     1.  FIND LOCAL COORD SYSTEM FOR FRAGMENT N
C
      CALL ROTMAT(XCRD(P1,N),YCRD(P1,N),ZCRD(P1,N),
     *            XCRD(P2,N),YCRD(P2,N),ZCRD(P2,N),
     *            XCRD(P3,N),YCRD(P3,N),ZCRD(P3,N),T1)
C
C     2. FIND LOCAL COORD SYSTEM FOR THESE THREE POINTS FOR THE
C        STANDARD FRAGMENT
C
      CALL ROTMAT(CORD(1,P1),CORD(2,P1),CORD(3,P1),
     *            CORD(1,P2),CORD(2,P2),CORD(3,P2),
     *            CORD(1,P3),CORD(2,P3),CORD(3,P3),T2)
C
C     3. FIND ROTATION MATRIX CONNECTING THESE TWO COORDINATE SYSTEMS
C
      CALL TRPOSE(T2,T3T,3,3,1)
      CALL MRARBR(T1,3,3,3,T2,3,3,T3,3)
C
C     4. COMPUTE TRANSPOSE
C
      CALL TRPOSE(T3,T3T,3,3,0)
C
C
      DO J=1,3
         TEMP(J) = PCORD(J,IIP) - CORD(J,P1)
      END DO
      CALL MRARBR(T3,3,3,3,TEMP,3,1,TEFP,3)
      TEFP(1)=TEFP(1)+XCRD(P1,N)
      TEFP(2)=TEFP(2)+YCRD(P1,N)
      TEFP(3)=TEFP(3)+ZCRD(P1,N)
C
      T1(1,1) = POLT(1,IIP)
      T1(1,2) = POLT(4,IIP)
      T1(1,3) = POLT(5,IIP)
      T1(2,1) = POLT(7,IIP)
      T1(2,2) = POLT(2,IIP)
      T1(2,3) = POLT(6,IIP)
      T1(3,1) = POLT(8,IIP)
      T1(3,2) = POLT(9,IIP)
      T1(3,3) = POLT(3,IIP)
      CALL MRARBR(T3,3,3,3,T1,3,3,T2,3)
      CALL MRARBR(T2,3,3,3,T3T,3,3,T1,3)
      TPOL(1) = T1(1,1)
      TPOL(4) = T1(1,2)
      TPOL(5) = T1(1,3)
      TPOL(7) = T1(2,1)
      TPOL(2) = T1(2,2)
      TPOL(6) = T1(2,3)
      TPOL(8) = T1(3,1)
      TPOL(9) = T1(3,2)
      TPOL(3) = T1(3,3)
C
      RETURN
      END
C*MODULE EFINP   *DECK DPOLROT
      SUBROUTINE DPOLROT(N,TEFDP,TDPOL,P1,P2,P3,IIIP)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      PARAMETER ( MXPT=2000, MXFRG=1050,
     *            MXIFRQ=12)
C
C
C
      CHARACTER*8 MNAME,PNAME,DPNAME,PTNAM,RNAME,FNAME
      CHARACTER*6 FRGNAM
C
      INTEGER P1,P2,P3
C
      DIMENSION T1(3,3), T2(3,3), T3(3,3), T3T(3,3)
      DIMENSION TEMPD(3)
      DIMENSION TEFDP(3),TDPOL(9)
C
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ*MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
C   ---- LVS: TMP COMMON FOR POLARIZATION SCREENING
C
C
C     1.  FIND LOCAL COORD SYSTEM FOR FRAGMENT N
C
      CALL ROTMAT(XCRD(P1,N),YCRD(P1,N),ZCRD(P1,N),
     *            XCRD(P2,N),YCRD(P2,N),ZCRD(P2,N),
     *            XCRD(P3,N),YCRD(P3,N),ZCRD(P3,N),T1)
C
C     2. FIND LOCAL COORD SYSTEM FOR THESE THREE POINTS FOR THE
C        STANDARD FRAGMENT
C
      CALL ROTMAT(CORD(1,P1),CORD(2,P1),CORD(3,P1),
     *            CORD(1,P2),CORD(2,P2),CORD(3,P2),
     *            CORD(1,P3),CORD(2,P3),CORD(3,P3),T2)
C
C     3. FIND ROTATION MATRIX CONNECTING THESE TWO COORDINATE SYSTEMS
C
      CALL TRPOSE(T2,T3T,3,3,1)
      CALL MRARBR(T1,3,3,3,T2,3,3,T3,3)
C
C     4. COMPUTE TRANSPOSE
C
      CALL TRPOSE(T3,T3T,3,3,0)
C
      DO J=1,3
         TEMPD(J) = DPCORD(J,IIIP) - CORD(J,P1)
      ENDDO
C
      CALL MRARBR(T3,3,3,3,TEMPD,3,1,TEFDP,3)
      TEFDP(1)=TEFDP(1)+XCRD(P1,N)
      TEFDP(2)=TEFDP(2)+YCRD(P1,N)
      TEFDP(3)=TEFDP(3)+ZCRD(P1,N)
C
      CALL VCLR(TEMP3,1,3)
      CALL VCLR(T2,1,9)
C
      T1(1,1) = DPOLT(1,IIIP)
      T1(1,2) = DPOLT(4,IIIP)
      T1(1,3) = DPOLT(5,IIIP)
      T1(2,1) = DPOLT(7,IIIP)
      T1(2,2) = DPOLT(2,IIIP)
      T1(2,3) = DPOLT(6,IIIP)
      T1(3,1) = DPOLT(8,IIIP)
      T1(3,2) = DPOLT(9,IIIP)
      T1(3,3) = DPOLT(3,IIIP)
      CALL MRARBR(T3,3,3,3,T1,3,3,T2,3)
      CALL VCLR(T1,1,9)
      CALL MRARBR(T2,3,3,3,T3T,3,3,T1,3)
C
      TDPOL(1) = T1(1,1)
      TDPOL(4) = T1(1,2)
      TDPOL(5) = T1(1,3)
      TDPOL(7) = T1(2,1)
      TDPOL(2) = T1(2,2)
      TDPOL(6) = T1(2,3)
      TDPOL(8) = T1(3,1)
      TDPOL(9) = T1(3,2)
      TDPOL(3) = T1(3,3)
C
      RETURN
      END
C*MODULE EFINP   *DECK MOROT
      SUBROUTINE MOROT(N,PROVEC,CTVEC,MXBF,NTMOF,NTCTMOF,
     *                 P1,P2,P3,I,TCENT,TLVEC,TCVEC)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      PARAMETER (MXDFG=5, MXPT=2000, MXFRG=1050, MXFGPT=12000,
     *           MXAO=8192, MXSHEF=1000, MXGEFP=4000, MXIFRQ=12)
C
      PARAMETER (CONST=2.0D+00/1.7320508D+00)
      PARAMETER (SQRT3=1.732050808D+00,SQRT5=2.236067978D+00)
      PARAMETER (SQRT7=2.645751311D+00)
      PARAMETER (TWO=2.0D+00,THREE=3.0D+00,FOUR=4.0D+00,SIX=6.0D+00)
      PARAMETER (TWELVE=12.0D+00)
C
      CHARACTER*8 MNAME,PNAME,DPNAME,PTNAM,RNAME,FNAME
      CHARACTER*6 FRGNAM
C
      INTEGER P1,P2,P3
C
      DIMENSION T1(3,3), T2(3,3), T3(3,3), T3T(3,3)
      DIMENSION TEMP(3), TEMP2(6), TEMP3(3), TEMP4(6,3)
      DIMENSION TEMP5(6,3)
      DIMENSION TPXX(6),TPXY(6),TPYY(6),TPXZ(6),TPYZ(6),TPZZ(6)
      DIMENSION TPXX2(6),TPXY2(6),TPYY2(6),TPXZ2(6),TPYZ2(6),TPZZ2(6)
      DIMENSION TCENT(3),TLVEC(MXBF),TCVEC(MXBF)
C
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NAT(MXDFG),NUM(MXDFG),NTPATM
      COMMON /EFPCT / NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CTFOK(MXAO,MXDFG),NCTMO(MXDFG),NTCTMO
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ*MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
C
      DIMENSION PROVEC(MXBF,NTMOF),CTVEC(MXBF,NTCTMOF)
C
C
C --- FIND ROTATION MATRIX CONNECTING THE FRAGMENT N TO THE
C     STANDARD FRAGMENT.
C     1. FIND LOCAL COORD SYSTEM FOR FRAGMENT N
C
      CALL ROTMAT(XCRD(P1,N),YCRD(P1,N),ZCRD(P1,N),
     *            XCRD(P2,N),YCRD(P2,N),ZCRD(P2,N),
     *            XCRD(P3,N),YCRD(P3,N),ZCRD(P3,N),T1)
C
C     2. FIND LOCAL COORD SYSTEM FOR THESE THREE POINTS FOR THE
C        STANDARD FRAGMENT
C
      CALL ROTMAT(CORD(1,P1),CORD(2,P1),CORD(3,P1),
     *            CORD(1,P2),CORD(2,P2),CORD(3,P2),
     *            CORD(1,P3),CORD(2,P3),CORD(3,P3),T2)
C
C     3. FIND ROTATION MATRIX CONNECTING THESE TWO COORDINATE SYSTEMS
C
      CALL TRPOSE(T2,T3T,3,3,1)
      CALL MRARBR(T1,3,3,3,T2,3,3,T3,3)
C
C     4. COMPUTE TRANSPOSE
C
      CALL TRPOSE(T3,T3T,3,3,0)
C
C
      DO NSHL = 1,NSHELL(ISET(N))
         ITYP = KMAX(NSHL,ISET(N)) - KMIN(NSHL,ISET(N)) + 1
         LOC = KLOC(NSHL,ISET(N))
C
C  S:
C
         IF(ITYP.EQ.1) THEN
               TLVEC(LOC  ) = PROVEC(LOC  ,NTMO+I)
         END IF
C
C  P:
C
         IF(ITYP.EQ.3) THEN
               TEMP3(1) = PROVEC(LOC  ,NTMO+I)
               TEMP3(2) = PROVEC(LOC+1,NTMO+I)
               TEMP3(3) = PROVEC(LOC+2,NTMO+I)
               CALL MRARBR(T3,3,3,3,TEMP3,3,1,TEMP4(1,1),3)
               TLVEC(LOC  ) = TEMP4(1,1)
               TLVEC(LOC+1) = TEMP4(2,1)
               TLVEC(LOC+2) = TEMP4(3,1)
         END IF
C  L:
         IF(ITYP.EQ.4) THEN
               TEMP3(1) = PROVEC(LOC+1,NTMO+I)
               TEMP3(2) = PROVEC(LOC+2,NTMO+I)
               TEMP3(3) = PROVEC(LOC+3,NTMO+I)
               CALL MRARBR(T3,3,3,3,TEMP3,3,1,TEMP4(1,1),3)
               TLVEC(LOC  ) = PROVEC(LOC  ,NTMO+I)
               TLVEC(LOC+1) = TEMP4(1,1)
               TLVEC(LOC+2) = TEMP4(2,1)
               TLVEC(LOC+3) = TEMP4(3,1)
         END IF
C  D:
C              THE NORMALIZATION FOR XY,XZ,YZ GAUSSIANS IS SQRT(3)
C              LARGER THAN XX,YY,ZZ. FACTOR OF TWO ALLOWS SUMMATION
C              OVER ALL INDICES RATHER THAN I,J<=I
C
         IF(ITYP.EQ.6) THEN
               TEMP2(1) = PROVEC(LOC  ,NTMO+I)
               TEMP2(2) = PROVEC(LOC+3,NTMO+I)/CONST
               TEMP2(3) = PROVEC(LOC+1,NTMO+I)
               TEMP2(4) = PROVEC(LOC+4,NTMO+I)/CONST
               TEMP2(5) = PROVEC(LOC+5,NTMO+I)/CONST
               TEMP2(6) = PROVEC(LOC+2,NTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TLVEC(LOC  ) = TEMP4(1,1)
               TLVEC(LOC+3) = TEMP4(2,1)*CONST
               TLVEC(LOC+1) = TEMP4(3,1)
               TLVEC(LOC+4) = TEMP4(4,1)*CONST
               TLVEC(LOC+5) = TEMP4(5,1)*CONST
               TLVEC(LOC+2) = TEMP4(6,1)
         END IF
C  F:
         IF(ITYP.EQ.10) THEN
               PROVEC(LOC+3,NTMO+I) = PROVEC(LOC+3,NTMO+I)*SQRT5/THREE
               PROVEC(LOC+4,NTMO+I) = PROVEC(LOC+4,NTMO+I)*SQRT5/THREE
               PROVEC(LOC+5,NTMO+I) = PROVEC(LOC+5,NTMO+I)*SQRT5/THREE
               PROVEC(LOC+6,NTMO+I) = PROVEC(LOC+6,NTMO+I)*SQRT5/THREE
               PROVEC(LOC+7,NTMO+I) = PROVEC(LOC+7,NTMO+I)*SQRT5/THREE
               PROVEC(LOC+8,NTMO+I) = PROVEC(LOC+8,NTMO+I)*SQRT5/THREE
               PROVEC(LOC+9,NTMO+I) = PROVEC(LOC+9,NTMO+I)*SQRT5/THREE
               PROVEC(LOC+9,NTMO+I) = PROVEC(LOC+9,NTMO+I)*SQRT3/TWO
C
               TEMP2(1) = PROVEC(LOC  ,NTMO+I)
               TEMP2(2) = PROVEC(LOC+3,NTMO+I)
               TEMP2(3) = PROVEC(LOC+5,NTMO+I)
               TEMP2(4) = PROVEC(LOC+4,NTMO+I)
               TEMP2(5) = PROVEC(LOC+9,NTMO+I)
               TEMP2(6) = PROVEC(LOC+7,NTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
C
               TEMP2(1) = PROVEC(LOC+3,NTMO+I)
               TEMP2(2) = PROVEC(LOC+5,NTMO+I)
               TEMP2(3) = PROVEC(LOC+1,NTMO+I)
               TEMP2(4) = PROVEC(LOC+9,NTMO+I)
               TEMP2(5) = PROVEC(LOC+6,NTMO+I)
               TEMP2(6) = PROVEC(LOC+8,NTMO+I)
               CALL TFTRI(TEMP4(1,2),TEMP2,T3T,TEMP3,3,3,3)
C
               TEMP2(1) = PROVEC(LOC+4,NTMO+I)
               TEMP2(2) = PROVEC(LOC+9,NTMO+I)
               TEMP2(3) = PROVEC(LOC+6,NTMO+I)
               TEMP2(4) = PROVEC(LOC+7,NTMO+I)
               TEMP2(5) = PROVEC(LOC+8,NTMO+I)
               TEMP2(6) = PROVEC(LOC+2,NTMO+I)
               CALL TFTRI(TEMP4(1,3),TEMP2,T3T,TEMP3,3,3,3)
C
               CALL MRARBR(TEMP4,6,6,3,T3T,3,3,TEMP5,6)
C
               TLVEC(LOC  ) = TEMP5(1,1)
               TLVEC(LOC+1) = TEMP5(3,2)
               TLVEC(LOC+2) = TEMP5(6,3)
               TLVEC(LOC+3) = TEMP5(2,1)/SQRT5*THREE
               TLVEC(LOC+4) = TEMP5(4,1)/SQRT5*THREE
               TLVEC(LOC+5) = TEMP5(3,1)/SQRT5*THREE
               TLVEC(LOC+6) = TEMP5(5,2)/SQRT5*THREE
               TLVEC(LOC+7) = TEMP5(6,1)/SQRT5*THREE
               TLVEC(LOC+8) = TEMP5(6,2)/SQRT5*THREE
               TLVEC(LOC+9) = TEMP5(5,1)/SQRT5*THREE/SQRT3*TWO
C
               PROVEC(LOC+3,NTMO+I) = PROVEC(LOC+3,NTMO+I)/SQRT5*THREE
               PROVEC(LOC+4,NTMO+I) = PROVEC(LOC+4,NTMO+I)/SQRT5*THREE
               PROVEC(LOC+5,NTMO+I) = PROVEC(LOC+5,NTMO+I)/SQRT5*THREE
               PROVEC(LOC+6,NTMO+I) = PROVEC(LOC+6,NTMO+I)/SQRT5*THREE
               PROVEC(LOC+7,NTMO+I) = PROVEC(LOC+7,NTMO+I)/SQRT5*THREE
               PROVEC(LOC+8,NTMO+I) = PROVEC(LOC+8,NTMO+I)/SQRT5*THREE
               PROVEC(LOC+9,NTMO+I) = PROVEC(LOC+9,NTMO+I)/SQRT5*THREE
               PROVEC(LOC+9,NTMO+I) = PROVEC(LOC+9,NTMO+I)/SQRT3*TWO
         END IF
C
C  G:
C
         IF(ITYP.EQ.15) THEN
               PROVEC(LOC+ 3,NTMO+I) = PROVEC(LOC+ 3,NTMO+I)*SQRT7/FOUR
               PROVEC(LOC+ 4,NTMO+I) = PROVEC(LOC+ 4,NTMO+I)*SQRT7/FOUR
               PROVEC(LOC+ 5,NTMO+I) = PROVEC(LOC+ 5,NTMO+I)*SQRT7/FOUR
               PROVEC(LOC+ 6,NTMO+I) = PROVEC(LOC+ 6,NTMO+I)*SQRT7/FOUR
               PROVEC(LOC+ 7,NTMO+I) = PROVEC(LOC+ 7,NTMO+I)*SQRT7/FOUR
               PROVEC(LOC+ 8,NTMO+I) = PROVEC(LOC+ 8,NTMO+I)*SQRT7/FOUR
               PROVEC(LOC+ 9,NTMO+I) = PROVEC(LOC+ 9,NTMO+I)*SQRT7*
     *                                 SQRT5/SQRT3/SIX
               PROVEC(LOC+10,NTMO+I) = PROVEC(LOC+10,NTMO+I)*SQRT7*
     *                                 SQRT5/SQRT3/SIX
               PROVEC(LOC+11,NTMO+I) = PROVEC(LOC+11,NTMO+I)*SQRT7*
     *                                 SQRT5/SQRT3/SIX
               PROVEC(LOC+12,NTMO+I) = PROVEC(LOC+12,NTMO+I)*SQRT7*
     *                                 SQRT5/TWELVE
               PROVEC(LOC+13,NTMO+I) = PROVEC(LOC+13,NTMO+I)*SQRT7*
     *                                 SQRT5/TWELVE
               PROVEC(LOC+14,NTMO+I) = PROVEC(LOC+14,NTMO+I)*SQRT7*
     *                                 SQRT5/TWELVE
C
C              PERFORM THE FIRST AND SECOND ROTATION
C
               TEMP2(1) = PROVEC(LOC   ,NTMO+I)
               TEMP2(2) = PROVEC(LOC+ 3,NTMO+I)
               TEMP2(3) = PROVEC(LOC+ 9,NTMO+I)
               TEMP2(4) = PROVEC(LOC+ 4,NTMO+I)
               TEMP2(5) = PROVEC(LOC+12,NTMO+I)
               TEMP2(6) = PROVEC(LOC+10,NTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXX(1) = TEMP4(1,1)
               TPXX(2) = TEMP4(2,1)
               TPXX(3) = TEMP4(3,1)
               TPXX(4) = TEMP4(4,1)
               TPXX(5) = TEMP4(5,1)
               TPXX(6) = TEMP4(6,1)
C
               TEMP2(1) = PROVEC(LOC+ 3,NTMO+I)
               TEMP2(2) = PROVEC(LOC+ 9,NTMO+I)
               TEMP2(3) = PROVEC(LOC+ 5,NTMO+I)
               TEMP2(4) = PROVEC(LOC+12,NTMO+I)
               TEMP2(5) = PROVEC(LOC+13,NTMO+I)
               TEMP2(6) = PROVEC(LOC+14,NTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXY(1) = TEMP4(1,1)
               TPXY(2) = TEMP4(2,1)
               TPXY(3) = TEMP4(3,1)
               TPXY(4) = TEMP4(4,1)
               TPXY(5) = TEMP4(5,1)
               TPXY(6) = TEMP4(6,1)
C
               TEMP2(1) = PROVEC(LOC+ 9,NTMO+I)
               TEMP2(2) = PROVEC(LOC+ 5,NTMO+I)
               TEMP2(3) = PROVEC(LOC+ 1,NTMO+I)
               TEMP2(4) = PROVEC(LOC+13,NTMO+I)
               TEMP2(5) = PROVEC(LOC+ 6,NTMO+I)
               TEMP2(6) = PROVEC(LOC+11,NTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYY(1) = TEMP4(1,1)
               TPYY(2) = TEMP4(2,1)
               TPYY(3) = TEMP4(3,1)
               TPYY(4) = TEMP4(4,1)
               TPYY(5) = TEMP4(5,1)
               TPYY(6) = TEMP4(6,1)
C
               TEMP2(1) = PROVEC(LOC+ 4,NTMO+I)
               TEMP2(2) = PROVEC(LOC+12,NTMO+I)
               TEMP2(3) = PROVEC(LOC+13,NTMO+I)
               TEMP2(4) = PROVEC(LOC+10,NTMO+I)
               TEMP2(5) = PROVEC(LOC+14,NTMO+I)
               TEMP2(6) = PROVEC(LOC+ 7,NTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXZ(1) = TEMP4(1,1)
               TPXZ(2) = TEMP4(2,1)
               TPXZ(3) = TEMP4(3,1)
               TPXZ(4) = TEMP4(4,1)
               TPXZ(5) = TEMP4(5,1)
               TPXZ(6) = TEMP4(6,1)
C
               TEMP2(1) = PROVEC(LOC+12,NTMO+I)
               TEMP2(2) = PROVEC(LOC+13,NTMO+I)
               TEMP2(3) = PROVEC(LOC+ 6,NTMO+I)
               TEMP2(4) = PROVEC(LOC+14,NTMO+I)
               TEMP2(5) = PROVEC(LOC+11,NTMO+I)
               TEMP2(6) = PROVEC(LOC+ 8,NTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYZ(1) = TEMP4(1,1)
               TPYZ(2) = TEMP4(2,1)
               TPYZ(3) = TEMP4(3,1)
               TPYZ(4) = TEMP4(4,1)
               TPYZ(5) = TEMP4(5,1)
               TPYZ(6) = TEMP4(6,1)
C
               TEMP2(1) = PROVEC(LOC+10,NTMO+I)
               TEMP2(2) = PROVEC(LOC+14,NTMO+I)
               TEMP2(3) = PROVEC(LOC+11,NTMO+I)
               TEMP2(4) = PROVEC(LOC+ 7,NTMO+I)
               TEMP2(5) = PROVEC(LOC+ 8,NTMO+I)
               TEMP2(6) = PROVEC(LOC+ 2,NTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPZZ(1) = TEMP4(1,1)
               TPZZ(2) = TEMP4(2,1)
               TPZZ(3) = TEMP4(3,1)
               TPZZ(4) = TEMP4(4,1)
               TPZZ(5) = TEMP4(5,1)
               TPZZ(6) = TEMP4(6,1)
C
C              PERFORM THE THIRD AND FOURTH ROTATION
C
               TEMP2(1) = TPXX(1)
               TEMP2(2) = TPXY(1)
               TEMP2(3) = TPYY(1)
               TEMP2(4) = TPXZ(1)
               TEMP2(5) = TPYZ(1)
               TEMP2(6) = TPZZ(1)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXX2(1) = TEMP4(1,1)
               TPXX2(2) = TEMP4(2,1)
               TPXX2(3) = TEMP4(3,1)
               TPXX2(4) = TEMP4(4,1)
               TPXX2(5) = TEMP4(5,1)
               TPXX2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(2)
               TEMP2(2) = TPXY(2)
               TEMP2(3) = TPYY(2)
               TEMP2(4) = TPXZ(2)
               TEMP2(5) = TPYZ(2)
               TEMP2(6) = TPZZ(2)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXY2(1) = TEMP4(1,1)
               TPXY2(2) = TEMP4(2,1)
               TPXY2(3) = TEMP4(3,1)
               TPXY2(4) = TEMP4(4,1)
               TPXY2(5) = TEMP4(5,1)
               TPXY2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(3)
               TEMP2(2) = TPXY(3)
               TEMP2(3) = TPYY(3)
               TEMP2(4) = TPXZ(3)
               TEMP2(5) = TPYZ(3)
               TEMP2(6) = TPZZ(3)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYY2(1) = TEMP4(1,1)
               TPYY2(2) = TEMP4(2,1)
               TPYY2(3) = TEMP4(3,1)
               TPYY2(4) = TEMP4(4,1)
               TPYY2(5) = TEMP4(5,1)
               TPYY2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(4)
               TEMP2(2) = TPXY(4)
               TEMP2(3) = TPYY(4)
               TEMP2(4) = TPXZ(4)
               TEMP2(5) = TPYZ(4)
               TEMP2(6) = TPZZ(4)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXZ2(1) = TEMP4(1,1)
               TPXZ2(2) = TEMP4(2,1)
               TPXZ2(3) = TEMP4(3,1)
               TPXZ2(4) = TEMP4(4,1)
               TPXZ2(5) = TEMP4(5,1)
               TPXZ2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(5)
               TEMP2(2) = TPXY(5)
               TEMP2(3) = TPYY(5)
               TEMP2(4) = TPXZ(5)
               TEMP2(5) = TPYZ(5)
               TEMP2(6) = TPZZ(5)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYZ2(1) = TEMP4(1,1)
               TPYZ2(2) = TEMP4(2,1)
               TPYZ2(3) = TEMP4(3,1)
               TPYZ2(4) = TEMP4(4,1)
               TPYZ2(5) = TEMP4(5,1)
               TPYZ2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(6)
               TEMP2(2) = TPXY(6)
               TEMP2(3) = TPYY(6)
               TEMP2(4) = TPXZ(6)
               TEMP2(5) = TPYZ(6)
               TEMP2(6) = TPZZ(6)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPZZ2(1) = TEMP4(1,1)
               TPZZ2(2) = TEMP4(2,1)
               TPZZ2(3) = TEMP4(3,1)
               TPZZ2(4) = TEMP4(4,1)
               TPZZ2(5) = TEMP4(5,1)
               TPZZ2(6) = TEMP4(6,1)
C
               TLVEC(LOC   ) = TPXX2(1)
               TLVEC(LOC+ 1) = TPYY2(3)
               TLVEC(LOC+ 2) = TPZZ2(6)
               TLVEC(LOC+ 3) = TPXY2(1)/SQRT7*FOUR
               TLVEC(LOC+ 4) = TPXZ2(1)/SQRT7*FOUR
               TLVEC(LOC+ 5) = TPYY2(2)/SQRT7*FOUR
               TLVEC(LOC+ 6) = TPYZ2(3)/SQRT7*FOUR
               TLVEC(LOC+ 7) = TPXZ2(6)/SQRT7*FOUR
               TLVEC(LOC+ 8) = TPYZ2(6)/SQRT7*FOUR
               TLVEC(LOC+ 9) = TPYY2(1)/SQRT7/SQRT5*SQRT3*SIX
               TLVEC(LOC+10) = TPZZ2(1)/SQRT7/SQRT5*SQRT3*SIX
               TLVEC(LOC+11) = TPZZ2(3)/SQRT7/SQRT5*SQRT3*SIX
               TLVEC(LOC+12) = TPYZ2(1)/SQRT7/SQRT5*TWELVE
               TLVEC(LOC+13) = TPYZ2(2)/SQRT7/SQRT5*TWELVE
               TLVEC(LOC+14) = TPZZ2(2)/SQRT7/SQRT5*TWELVE
C
               PROVEC(LOC+ 3,NTMO+I) = PROVEC(LOC+ 3,NTMO+I)/SQRT7*FOUR
               PROVEC(LOC+ 4,NTMO+I) = PROVEC(LOC+ 4,NTMO+I)/SQRT7*FOUR
               PROVEC(LOC+ 5,NTMO+I) = PROVEC(LOC+ 5,NTMO+I)/SQRT7*FOUR
               PROVEC(LOC+ 6,NTMO+I) = PROVEC(LOC+ 6,NTMO+I)/SQRT7*FOUR
               PROVEC(LOC+ 7,NTMO+I) = PROVEC(LOC+ 7,NTMO+I)/SQRT7*FOUR
               PROVEC(LOC+ 8,NTMO+I) = PROVEC(LOC+ 8,NTMO+I)/SQRT7*FOUR
               PROVEC(LOC+ 9,NTMO+I) = PROVEC(LOC+ 9,NTMO+I)/SQRT7/
     *                                 SQRT5*SQRT3*SIX
               PROVEC(LOC+10,NTMO+I) = PROVEC(LOC+10,NTMO+I)/SQRT7/
     *                                 SQRT5*SQRT3*SIX
               PROVEC(LOC+11,NTMO+I) = PROVEC(LOC+11,NTMO+I)/SQRT7/
     *                                 SQRT5*SQRT3*SIX
               PROVEC(LOC+12,NTMO+I) = PROVEC(LOC+12,NTMO+I)/SQRT7/
     *                                 SQRT5*TWELVE
               PROVEC(LOC+13,NTMO+I) = PROVEC(LOC+13,NTMO+I)/SQRT7/
     *                                 SQRT5*TWELVE
               PROVEC(LOC+14,NTMO+I) = PROVEC(LOC+14,NTMO+I)/SQRT7/
     *                                 SQRT5*TWELVE
         END IF
      END DO
C
      DO J=1,3
         TEMP3(J) = CENTCD(J,I+NTMO) - CORD(J,P1)
      END DO
      CALL MRARBR(T3,3,3,3,TEMP3,3,1,TEMP,3)
      TCENT(1) = TEMP(1) + XCRD(P1,N)
      TCENT(2) = TEMP(2) + YCRD(P1,N)
      TCENT(3) = TEMP(3) + ZCRD(P1,N)
C
C
C  ROTATE CANONICAL VEC
C  - CURRENTLY THIS FUNCTION IS NOT USEFUL
C  - HOWEVER, THE CODE CAN BE EXAMPLES FOR ALTER USE
C
C     RETURN
C
      DO NSHL = 1,NSHELL(ISET(N))
         ITYP = KMAX(NSHL,ISET(N)) - KMIN(NSHL,ISET(N)) + 1
         LOC = KLOC(NSHL,ISET(N))
C
C  S:
C
         IF(ITYP.EQ.1) THEN
               TCVEC(LOC  ) = CTVEC(LOC  ,NTCTMO+I)
         END IF
C
C  P:
C
         IF(ITYP.EQ.3) THEN
               TEMP3(1) = CTVEC(LOC,NTCTMO+I)
               TEMP3(2) = CTVEC(LOC+1,NTCTMO+I)
               TEMP3(3) = CTVEC(LOC+2,NTCTMO+I)
               CALL MRARBR(T3,3,3,3,TEMP3,3,1,TEMP4(1,1),3)
               TCVEC(LOC) = TEMP4(1,1)
               TCVEC(LOC+1) = TEMP4(2,1)
               TCVEC(LOC+2) = TEMP4(3,1)
         END IF
C  L:
         IF(ITYP.EQ.4) THEN
               TEMP3(1) = CTVEC(LOC+1,NTCTMO+I)
               TEMP3(2) = CTVEC(LOC+2,NTCTMO+I)
               TEMP3(3) = CTVEC(LOC+3,NTCTMO+I)
               CALL MRARBR(T3,3,3,3,TEMP3,3,1,TEMP4(1,1),3)
               TCVEC(LOC  ) = CTVEC(LOC  ,NTCTMO+I)
               TCVEC(LOC+1) = TEMP4(1,1)
               TCVEC(LOC+2) = TEMP4(2,1)
               TCVEC(LOC+3) = TEMP4(3,1)
         END IF
C  D:
C              THE NORMALIZATION FOR XY,XZ,YZ GAUSSIANS IS SQRT(3)
C              LARGER THAN XX,YY,ZZ. FACTOR OF TWO ALLOWS SUMMATION
C              OVER ALL INDICES RATHER THAN I,J<=I
C
         IF(ITYP.EQ.6) THEN
               TEMP2(1) = CTVEC(LOC,NTCTMO+I)
               TEMP2(2) = CTVEC(LOC+3,NTCTMO+I)/CONST
               TEMP2(3) = CTVEC(LOC+1,NTCTMO+I)
               TEMP2(4) = CTVEC(LOC+4,NTCTMO+I)/CONST
               TEMP2(5) = CTVEC(LOC+5,NTCTMO+I)/CONST
               TEMP2(6) = CTVEC(LOC+2,NTCTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TCVEC(LOC  ) = TEMP4(1,1)
               TCVEC(LOC+3) = TEMP4(2,1)*CONST
               TCVEC(LOC+1) = TEMP4(3,1)
               TCVEC(LOC+4) = TEMP4(4,1)*CONST
               TCVEC(LOC+5) = TEMP4(5,1)*CONST
               TCVEC(LOC+2) = TEMP4(6,1)
         END IF
C
C  F:
C
         IF(ITYP.EQ.10) THEN
               CTVEC(LOC+3,NTCTMO+I) = CTVEC(LOC+3,NTCTMO+I)
     *                                  *SQRT5/THREE
               CTVEC(LOC+4,NTCTMO+I) = CTVEC(LOC+4,NTCTMO+I)
     *                                  *SQRT5/THREE
               CTVEC(LOC+5,NTCTMO+I) = CTVEC(LOC+5,NTCTMO+I)
     *                                  *SQRT5/THREE
               CTVEC(LOC+6,NTCTMO+I) = CTVEC(LOC+6,NTCTMO+I)
     *                                  *SQRT5/THREE
               CTVEC(LOC+7,NTCTMO+I) = CTVEC(LOC+7,NTCTMO+I)
     *                                  *SQRT5/THREE
               CTVEC(LOC+8,NTCTMO+I) = CTVEC(LOC+8,NTCTMO+I)
     *                                  *SQRT5/THREE
               CTVEC(LOC+9,NTCTMO+I) = CTVEC(LOC+9,NTCTMO+I)
     *                                  *SQRT5/THREE
               CTVEC(LOC+9,NTCTMO+I) = CTVEC(LOC+9,NTCTMO+I)
     *                                  *SQRT3/TWO
C
               TEMP2(1) = CTVEC(LOC  ,NTCTMO+I)
               TEMP2(2) = CTVEC(LOC+3,NTCTMO+I)
               TEMP2(3) = CTVEC(LOC+5,NTCTMO+I)
               TEMP2(4) = CTVEC(LOC+4,NTCTMO+I)
               TEMP2(5) = CTVEC(LOC+9,NTCTMO+I)
               TEMP2(6) = CTVEC(LOC+7,NTCTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
C
               TEMP2(1) = CTVEC(LOC+3,NTCTMO+I)
               TEMP2(2) = CTVEC(LOC+5,NTCTMO+I)
               TEMP2(3) = CTVEC(LOC+1,NTCTMO+I)
               TEMP2(4) = CTVEC(LOC+9,NTCTMO+I)
               TEMP2(5) = CTVEC(LOC+6,NTCTMO+I)
               TEMP2(6) = CTVEC(LOC+8,NTCTMO+I)
               CALL TFTRI(TEMP4(1,2),TEMP2,T3T,TEMP3,3,3,3)
C
               TEMP2(1) = CTVEC(LOC+4,NTCTMO+I)
               TEMP2(2) = CTVEC(LOC+9,NTCTMO+I)
               TEMP2(3) = CTVEC(LOC+6,NTCTMO+I)
               TEMP2(4) = CTVEC(LOC+7,NTCTMO+I)
               TEMP2(5) = CTVEC(LOC+8,NTCTMO+I)
               TEMP2(6) = CTVEC(LOC+2,NTCTMO+I)
               CALL TFTRI(TEMP4(1,3),TEMP2,T3T,TEMP3,3,3,3)
C
               CALL MRARBR(TEMP4,6,6,3,T3T,3,3,TEMP5,6)
C
               TCVEC(LOC  ) = TEMP5(1,1)
               TCVEC(LOC+1) = TEMP5(3,2)
               TCVEC(LOC+2) = TEMP5(6,3)
               TCVEC(LOC+3) = TEMP5(2,1)/SQRT5*THREE
               TCVEC(LOC+4) = TEMP5(4,1)/SQRT5*THREE
               TCVEC(LOC+5) = TEMP5(3,1)/SQRT5*THREE
               TCVEC(LOC+6) = TEMP5(5,2)/SQRT5*THREE
               TCVEC(LOC+7) = TEMP5(6,1)/SQRT5*THREE
               TCVEC(LOC+8) = TEMP5(6,2)/SQRT5*THREE
               TCVEC(LOC+9) = TEMP5(5,1)/SQRT5*THREE/SQRT3*TWO
C
               CTVEC(LOC+3,NTCTMO+I) = CTVEC(LOC+3,NTCTMO+I)
     *                                  /SQRT5*THREE
               CTVEC(LOC+4,NTCTMO+I) = CTVEC(LOC+4,NTCTMO+I)
     *                                  /SQRT5*THREE
               CTVEC(LOC+5,NTCTMO+I) = CTVEC(LOC+5,NTCTMO+I)
     *                                  /SQRT5*THREE
               CTVEC(LOC+6,NTCTMO+I) = CTVEC(LOC+6,NTCTMO+I)
     *                                  /SQRT5*THREE
               CTVEC(LOC+7,NTCTMO+I) = CTVEC(LOC+7,NTCTMO+I)
     *                                  /SQRT5*THREE
               CTVEC(LOC+8,NTCTMO+I) = CTVEC(LOC+8,NTCTMO+I)
     *                                  /SQRT5*THREE
               CTVEC(LOC+9,NTCTMO+I) = CTVEC(LOC+9,NTCTMO+I)
     *                                  /SQRT5*THREE
               CTVEC(LOC+9,NTCTMO+I) = CTVEC(LOC+9,NTCTMO+I)
     *                                  /SQRT3*TWO
         END IF
C
C  G:
C
         IF(ITYP.EQ.15) THEN
               CTVEC(LOC+ 3,NTCTMO+I) = CTVEC(LOC+ 3,NTCTMO+I)
     *                                   *SQRT7/FOUR
               CTVEC(LOC+ 4,NTCTMO+I) = CTVEC(LOC+ 4,NTCTMO+I)
     *                                   *SQRT7/FOUR
               CTVEC(LOC+ 5,NTCTMO+I) = CTVEC(LOC+ 5,NTCTMO+I)
     *                                   *SQRT7/FOUR
               CTVEC(LOC+ 6,NTCTMO+I) = CTVEC(LOC+ 6,NTCTMO+I)
     *                                   *SQRT7/FOUR
               CTVEC(LOC+ 7,NTCTMO+I) = CTVEC(LOC+ 7,NTCTMO+I)
     *                                   *SQRT7/FOUR
               CTVEC(LOC+ 8,NTCTMO+I) = CTVEC(LOC+ 8,NTCTMO+I)
     *                                   *SQRT7/FOUR
               CTVEC(LOC+ 9,NTCTMO+I) = CTVEC(LOC+ 9,NTCTMO+I)
     *                                   *SQRT7*SQRT5/SQRT3/SIX
               CTVEC(LOC+10,NTCTMO+I) = CTVEC(LOC+10,NTCTMO+I)
     *                                   *SQRT7*SQRT5/SQRT3/SIX
               CTVEC(LOC+11,NTCTMO+I) = CTVEC(LOC+11,NTCTMO+I)
     *                                   *SQRT7*SQRT5/SQRT3/SIX
               CTVEC(LOC+12,NTCTMO+I) = CTVEC(LOC+12,NTCTMO+I)
     *                                   *SQRT7*SQRT5/TWELVE
               CTVEC(LOC+13,NTCTMO+I) = CTVEC(LOC+13,NTCTMO+I)
     *                                   *SQRT7*SQRT5/TWELVE
               CTVEC(LOC+14,NTCTMO+I) = CTVEC(LOC+14,NTCTMO+I)
     *                                   *SQRT7*SQRT5/TWELVE
C
C              PERFORM THE FIRST AND SECOND ROTATION
C
               TEMP2(1) = CTVEC(LOC   ,NTCTMO+I)
               TEMP2(2) = CTVEC(LOC+ 3,NTCTMO+I)
               TEMP2(3) = CTVEC(LOC+ 9,NTCTMO+I)
               TEMP2(4) = CTVEC(LOC+ 4,NTCTMO+I)
               TEMP2(5) = CTVEC(LOC+12,NTCTMO+I)
               TEMP2(6) = CTVEC(LOC+10,NTCTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXX(1) = TEMP4(1,1)
               TPXX(2) = TEMP4(2,1)
               TPXX(3) = TEMP4(3,1)
               TPXX(4) = TEMP4(4,1)
               TPXX(5) = TEMP4(5,1)
               TPXX(6) = TEMP4(6,1)
C
               TEMP2(1) = CTVEC(LOC+ 3,NTCTMO+I)
               TEMP2(2) = CTVEC(LOC+ 9,NTCTMO+I)
               TEMP2(3) = CTVEC(LOC+ 5,NTCTMO+I)
               TEMP2(4) = CTVEC(LOC+12,NTCTMO+I)
               TEMP2(5) = CTVEC(LOC+13,NTCTMO+I)
               TEMP2(6) = CTVEC(LOC+14,NTCTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXY(1) = TEMP4(1,1)
               TPXY(2) = TEMP4(2,1)
               TPXY(3) = TEMP4(3,1)
               TPXY(4) = TEMP4(4,1)
               TPXY(5) = TEMP4(5,1)
               TPXY(6) = TEMP4(6,1)
C
               TEMP2(1) = CTVEC(LOC+ 9,NTCTMO+I)
               TEMP2(2) = CTVEC(LOC+ 5,NTCTMO+I)
               TEMP2(3) = CTVEC(LOC+ 1,NTCTMO+I)
               TEMP2(4) = CTVEC(LOC+13,NTCTMO+I)
               TEMP2(5) = CTVEC(LOC+ 6,NTCTMO+I)
               TEMP2(6) = CTVEC(LOC+11,NTCTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYY(1) = TEMP4(1,1)
               TPYY(2) = TEMP4(2,1)
               TPYY(3) = TEMP4(3,1)
               TPYY(4) = TEMP4(4,1)
               TPYY(5) = TEMP4(5,1)
               TPYY(6) = TEMP4(6,1)
C
               TEMP2(1) = CTVEC(LOC+ 4,NTCTMO+I)
               TEMP2(2) = CTVEC(LOC+12,NTCTMO+I)
               TEMP2(3) = CTVEC(LOC+13,NTCTMO+I)
               TEMP2(4) = CTVEC(LOC+10,NTCTMO+I)
               TEMP2(5) = CTVEC(LOC+14,NTCTMO+I)
               TEMP2(6) = CTVEC(LOC+ 7,NTCTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXZ(1) = TEMP4(1,1)
               TPXZ(2) = TEMP4(2,1)
               TPXZ(3) = TEMP4(3,1)
               TPXZ(4) = TEMP4(4,1)
               TPXZ(5) = TEMP4(5,1)
               TPXZ(6) = TEMP4(6,1)
C
               TEMP2(1) = CTVEC(LOC+12,NTCTMO+I)
               TEMP2(2) = CTVEC(LOC+13,NTCTMO+I)
               TEMP2(3) = CTVEC(LOC+ 6,NTCTMO+I)
               TEMP2(4) = CTVEC(LOC+14,NTCTMO+I)
               TEMP2(5) = CTVEC(LOC+11,NTCTMO+I)
               TEMP2(6) = CTVEC(LOC+ 8,NTCTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYZ(1) = TEMP4(1,1)
               TPYZ(2) = TEMP4(2,1)
               TPYZ(3) = TEMP4(3,1)
               TPYZ(4) = TEMP4(4,1)
               TPYZ(5) = TEMP4(5,1)
               TPYZ(6) = TEMP4(6,1)
C
               TEMP2(1) = CTVEC(LOC+10,NTCTMO+I)
               TEMP2(2) = CTVEC(LOC+14,NTCTMO+I)
               TEMP2(3) = CTVEC(LOC+11,NTCTMO+I)
               TEMP2(4) = CTVEC(LOC+ 7,NTCTMO+I)
               TEMP2(5) = CTVEC(LOC+ 8,NTCTMO+I)
               TEMP2(6) = CTVEC(LOC+ 2,NTCTMO+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPZZ(1) = TEMP4(1,1)
               TPZZ(2) = TEMP4(2,1)
               TPZZ(3) = TEMP4(3,1)
               TPZZ(4) = TEMP4(4,1)
               TPZZ(5) = TEMP4(5,1)
               TPZZ(6) = TEMP4(6,1)
C
C              PERFORM THE THIRD AND FOURTH ROTATION
C
               TEMP2(1) = TPXX(1)
               TEMP2(2) = TPXY(1)
               TEMP2(3) = TPYY(1)
               TEMP2(4) = TPXZ(1)
               TEMP2(5) = TPYZ(1)
               TEMP2(6) = TPZZ(1)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXX2(1) = TEMP4(1,1)
               TPXX2(2) = TEMP4(2,1)
               TPXX2(3) = TEMP4(3,1)
               TPXX2(4) = TEMP4(4,1)
               TPXX2(5) = TEMP4(5,1)
               TPXX2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(2)
               TEMP2(2) = TPXY(2)
               TEMP2(3) = TPYY(2)
               TEMP2(4) = TPXZ(2)
               TEMP2(5) = TPYZ(2)
               TEMP2(6) = TPZZ(2)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXY2(1) = TEMP4(1,1)
               TPXY2(2) = TEMP4(2,1)
               TPXY2(3) = TEMP4(3,1)
               TPXY2(4) = TEMP4(4,1)
               TPXY2(5) = TEMP4(5,1)
               TPXY2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(3)
               TEMP2(2) = TPXY(3)
               TEMP2(3) = TPYY(3)
               TEMP2(4) = TPXZ(3)
               TEMP2(5) = TPYZ(3)
               TEMP2(6) = TPZZ(3)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYY2(1) = TEMP4(1,1)
               TPYY2(2) = TEMP4(2,1)
               TPYY2(3) = TEMP4(3,1)
               TPYY2(4) = TEMP4(4,1)
               TPYY2(5) = TEMP4(5,1)
               TPYY2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(4)
               TEMP2(2) = TPXY(4)
               TEMP2(3) = TPYY(4)
               TEMP2(4) = TPXZ(4)
               TEMP2(5) = TPYZ(4)
               TEMP2(6) = TPZZ(4)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXZ2(1) = TEMP4(1,1)
               TPXZ2(2) = TEMP4(2,1)
               TPXZ2(3) = TEMP4(3,1)
               TPXZ2(4) = TEMP4(4,1)
               TPXZ2(5) = TEMP4(5,1)
               TPXZ2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(5)
               TEMP2(2) = TPXY(5)
               TEMP2(3) = TPYY(5)
               TEMP2(4) = TPXZ(5)
               TEMP2(5) = TPYZ(5)
               TEMP2(6) = TPZZ(5)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYZ2(1) = TEMP4(1,1)
               TPYZ2(2) = TEMP4(2,1)
               TPYZ2(3) = TEMP4(3,1)
               TPYZ2(4) = TEMP4(4,1)
               TPYZ2(5) = TEMP4(5,1)
               TPYZ2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(6)
               TEMP2(2) = TPXY(6)
               TEMP2(3) = TPYY(6)
               TEMP2(4) = TPXZ(6)
               TEMP2(5) = TPYZ(6)
               TEMP2(6) = TPZZ(6)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPZZ2(1) = TEMP4(1,1)
               TPZZ2(2) = TEMP4(2,1)
               TPZZ2(3) = TEMP4(3,1)
               TPZZ2(4) = TEMP4(4,1)
               TPZZ2(5) = TEMP4(5,1)
               TPZZ2(6) = TEMP4(6,1)
C
               TCVEC(LOC   ) = TPXX2(1)
               TCVEC(LOC+ 1) = TPYY2(3)
               TCVEC(LOC+ 2) = TPZZ2(6)
               TCVEC(LOC+ 3) = TPXY2(1)/SQRT7*FOUR
               TCVEC(LOC+ 4) = TPXZ2(1)/SQRT7*FOUR
               TCVEC(LOC+ 5) = TPYY2(2)/SQRT7*FOUR
               TCVEC(LOC+ 6) = TPYZ2(3)/SQRT7*FOUR
               TCVEC(LOC+ 7) = TPXZ2(6)/SQRT7*FOUR
               TCVEC(LOC+ 8) = TPYZ2(6)/SQRT7*FOUR
               TCVEC(LOC+ 9) = TPYY2(1)/SQRT7/SQRT5*SQRT3*SIX
               TCVEC(LOC+10) = TPZZ2(1)/SQRT7/SQRT5*SQRT3*SIX
               TCVEC(LOC+11) = TPZZ2(3)/SQRT7/SQRT5*SQRT3*SIX
               TCVEC(LOC+12) = TPYZ2(1)/SQRT7/SQRT5*TWELVE
               TCVEC(LOC+13) = TPYZ2(2)/SQRT7/SQRT5*TWELVE
               TCVEC(LOC+14) = TPZZ2(2)/SQRT7/SQRT5*TWELVE
C
               CTVEC(LOC+ 3,NTCTMO+I) = CTVEC(LOC+ 3,NTCTMO+I)
     *                                   /SQRT7*FOUR
               CTVEC(LOC+ 4,NTCTMO+I) = CTVEC(LOC+ 4,NTCTMO+I)
     *                                   /SQRT7*FOUR
               CTVEC(LOC+ 5,NTCTMO+I) = CTVEC(LOC+ 5,NTCTMO+I)
     *                                   /SQRT7*FOUR
               CTVEC(LOC+ 6,NTCTMO+I) = CTVEC(LOC+ 6,NTCTMO+I)
     *                                   /SQRT7*FOUR
               CTVEC(LOC+ 7,NTCTMO+I) = CTVEC(LOC+ 7,NTCTMO+I)
     *                                   /SQRT7*FOUR
               CTVEC(LOC+ 8,NTCTMO+I) = CTVEC(LOC+ 8,NTCTMO+I)
     *                                   /SQRT7*FOUR
               CTVEC(LOC+ 9,NTCTMO+I) = CTVEC(LOC+ 9,NTCTMO+I)
     *                                   /SQRT7/SQRT5*SQRT3*SIX
               CTVEC(LOC+10,NTCTMO+I) = CTVEC(LOC+10,NTCTMO+I)
     *                                   /SQRT7/SQRT5*SQRT3*SIX
               CTVEC(LOC+11,NTCTMO+I) = CTVEC(LOC+11,NTCTMO+I)
     *                                   /SQRT7/SQRT5*SQRT3*SIX
               CTVEC(LOC+12,NTCTMO+I) = CTVEC(LOC+12,NTCTMO+I)
     *                                   /SQRT7/SQRT5*TWELVE
               CTVEC(LOC+13,NTCTMO+I) = CTVEC(LOC+13,NTCTMO+I)
     *                                   /SQRT7/SQRT5*TWELVE
               CTVEC(LOC+14,NTCTMO+I) = CTVEC(LOC+14,NTCTMO+I)
     *                                   /SQRT7/SQRT5*TWELVE
         END IF
      END DO
C
      RETURN
      END
C*MODULE EFINP   *DECK RDPDB
      SUBROUTINE RDPDB(IFRG)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      CHARACTER*8 PTNAM
      CHARACTER*6 FRGNAM,NAME6
      CHARACTER*4 NAME4
      CHARACTER*3 AAA,A3
      CHARACTER*2 SYMBOL
      CHARACTER*1 ALTLOC,A1,CHAINID,ICODE
C
      PARAMETER (ONE=1.00D+00, UNITS=ONE/0.52917724924D+00)
      PARAMETER (MXDFG=5, MXFRG=1050, MXFGPT=12000,
     *           MXSHEF=1000, MXGEFP=4000)
C
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /KFINFO/ KATMS(MXFRG)
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NAT(MXDFG),NUM(MXDFG),NTPATM
C
C     - HUI LI -
C
      IEOF=0
      IF(IFRG.LT.0) IFRG  = 0
      IF(IFRG.EQ.0) NDFRG = 0
      IFRGOLD = IFRG
C
C     - POSITION THE INPUT TO $PDBFRG -
      CALL SEQREW(IR)
      CALL FNDGRP(IR,' $PDBFRG',IEOF)
      CALL OPNCRD(IR,-IW)
      NUMOLD = -10000000
  100 CONTINUE
C
C     - START READING IN $PDBFRG -
C
C     - COLUMN  1- 6 IS 'ATOM  '
C     - COLUMN  7-11 IS ATOM SERIAL NUMBER
C     - COLUMN    12 IS BLANK
C     - COLUMN 13-16 IS ATOM NAME
C     - COLUMN 17    IS ALTERNATE LOCATION INDICATOR
C     - COLUMN 18-20 IS RESIDUE NAME
C     - COLUMN 21    IS BLANK
C     - COLUMN 22    IS CHAIN ID: A, B, C, D ...
C     - COLUMN 23-26 IS RESIDUAL SEQUENCE NUMBER
C     - COLUMN 27    IS INSERTION CODE BUT IS COMMONLY USED AS RES NUM
C     - COLUMN 28-30 IS BLANK
C     - COLUMN 31-38, 39-46, 47-54 ARE X, Y, Z
C     -        55 - 60 REAL(6.2)  OCCUPANCY.
C     -        61 - 66 REAL(6.2)  TEMPERATURE FACTOR.
C     -        77 - 78 LSTRING(2) ELEMENT SYMBOL, RIGHT-JUSTIFIED.
C     -        79 - 80 LSTRING(2) CHARGE ON THE ATOM.
C
      READ(IR,1000)NAME6,NATOM,A1,NAME4,ALTLOC,AAA,A1,CHAINID,
     *             NUMAAA,ICODE,A3,XXX,YYY,ZZZ,OCC,TEMFAC,SYMBOL,ICHARG
 1000 FORMAT(A6,I5,A1,A4,A1,A3,2A1,I4,A1,A3,3F8.3,2F6.2,A2,I2)
      NOTWRT = 1
      IF(NOTWRT.EQ.0) THEN
        WRITE(IW,*)NAME6,NATOM,A1,NAME4,ALTLOC,AAA,A1,CHAINID,
     *             NUMAAA,ICODE,A3,XXX,YYY,ZZZ,OCC,TEMFAC,SYMBOL,ICHARG
      END IF
C
      IF(NAME6.EQ.' $END ') THEN
         GO TO 200
      END IF
      IF(NAME6.NE.'ATOM  ') THEN
         WRITE(IW,*)'NAME6=',NAME6
         WRITE(IW,*)' ERROR: ONLY ATOM SHALL BE IN $PDBFRG'
         CALL ABRT
      END IF
C
      IF(NUMAAA.GT.NUMOLD) THEN
         IFRG  = IFRG  + 1
         NDFRG = NDFRG + 1
         FRGNAM(IFRG)=AAA
         IF(NDFRG.GT.MXDFG) THEN
            IF(MASWRK) WRITE(IW,*) 'ERROR: MXDFG IS REACHED'
            CALL ABRT
         END IF
         ISET(IFRG)=NDFRG
         NAMIDX(NDFRG)=IFRG
         NUMOLD = NUMAAA
         JATOM  = 0
      END IF
      JATOM = JATOM + 1
C
      XCRD(JATOM,IFRG)=XXX*UNITS
      YCRD(JATOM,IFRG)=YYY*UNITS
      ZCRD(JATOM,IFRG)=ZZZ*UNITS
C     - SMALL TRICKS ON NAME4
      DO KKK = 1, 4
         A1 = NAME4(1:1)
         IF(A1.EQ.' ') NAME4 = NAME4(2:4)
      ENDDO
      PTNAM(JATOM,IFRG)=NAME4
      KATMS(IFRG)=JATOM
      NAT(ISET(IFRG))=KATMS(IFRG)
      GO TO 100
 200  CONTINUE
C
C
C     - DETERMINE THE FORM OF THE RESIDUE
C
      WRITE(IW,'(I8,A)') IFRG-IFRGOLD,' AMINO ACID RESIDUES FOUND'
      IF(IFRG.EQ.IFRGOLD) RETURN
C
      DO IRES = IFRGOLD + 1, IFRG
         AAA   = FRGNAM(IRES)(1:3)
         JATOM = KATMS(IRES)
C - ALA -
         IF      (AAA.EQ.'ALA') THEN
            IF(JATOM.EQ.12.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'NH'
            IF(JATOM.EQ.11.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'N'
            IF(JATOM.EQ.10                      )FRGNAM(IRES)=AAA
            IF(JATOM.EQ.12.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'CH'
            IF(JATOM.EQ.11.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'C'
            IF(JATOM.NE.10 .AND. JATOM.NE.11 .AND. JATOM.NE.12)THEN
               WRITE(IW,'(1X,A6,I6,A)')AAA,IRES,' WRONG NUMBER OF ATOMS'
               CALL ABRT
            END IF
C - ARG -
         ELSE IF (AAA.EQ.'ARG') THEN
            IF(JATOM.EQ.26.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'NH'
            IF(JATOM.EQ.25.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'N'
            IF(JATOM.EQ.24                      )FRGNAM(IRES)=AAA
            IF(JATOM.EQ.26.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'CH'
            IF(JATOM.EQ.25.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'C'
            IF(JATOM.NE.24 .AND. JATOM.NE.25 .AND. JATOM.NE.26)THEN
               WRITE(IW,'(1X,A6,I6,A)')AAA,IRES,' WRONG NUMBER OF ATOMS'
               CALL ABRT
            END IF
C - ASN -
         ELSE IF (AAA.EQ.'ASN') THEN
            IF(JATOM.EQ.16.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'NH'
            IF(JATOM.EQ.15.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'N'
            IF(JATOM.EQ.14                      )FRGNAM(IRES)=AAA
            IF(JATOM.EQ.16.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'CH'
            IF(JATOM.EQ.15.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'C'
            IF(JATOM.NE.14 .AND. JATOM.NE.15 .AND. JATOM.NE.16)THEN
               WRITE(IW,'(1X,A6,I6,A)')AAA,IRES,' WRONG NUMBER OF ATOMS'
               CALL ABRT
            END IF
C - ASP -
         ELSE IF (AAA.EQ.'ASP') THEN
            IF(IRES.EQ.IFRGOLD+1)THEN
               IF(JATOM.EQ.13)                   FRGNAM(IRES)=AAA//'NAA'
               IF     (JATOM.EQ.12.AND.
     *                 PTNAM(JATOM,IRES).EQ.'HD      ')THEN
                                                 FRGNAM(IRES)=AAA//'NAB'
               ELSE IF(JATOM.EQ.12.AND.
     *                 PTNAM(JATOM,IRES).EQ.'3HB     ')THEN
                                                 FRGNAM(IRES)=AAA//'NBA'
               END IF
               IF(JATOM.EQ.11)                   FRGNAM(IRES)=AAA//'NBB'
            ELSE IF(IRES.EQ.IFRG)THEN
               IF(JATOM.EQ.13)                   FRGNAM(IRES)=AAA//'CAA'
               IF     (JATOM.EQ.12.AND.
     *                 PTNAM(JATOM-1,IRES).EQ.'HD      ')THEN
                                                 FRGNAM(IRES)=AAA//'CAB'
               ELSE IF(JATOM.EQ.12.AND.
     *                 PTNAM(JATOM-1,IRES).EQ.'3HB     ')THEN
                                                 FRGNAM(IRES)=AAA//'CBA'
               END IF
               IF(JATOM.EQ.11)                   FRGNAM(IRES)=AAA//'CBB'
            ELSE
               IF(JATOM.EQ.11)                   FRGNAM(IRES)=AAA//'A'
               IF(JATOM.EQ.10)                   FRGNAM(IRES)=AAA//'B'
            END IF
            IF(JATOM.NE.10 .AND. JATOM.NE.11 .AND. JATOM.NE.12
     *                     .AND. JATOM.NE.13                  )THEN
               WRITE(IW,'(1X,A6,I6,A)')AAA,IRES,' WRONG NUMBER OF ATOMS'
               CALL ABRT
            END IF
C - CYS -
         ELSE IF (AAA.EQ.'CYS') THEN
            IF(IRES.EQ.IFRGOLD+1)THEN
               IF(JATOM.EQ.13)                   FRGNAM(IRES)=AAA//'NAA'
               IF     (JATOM.EQ.12.AND.
     *                 PTNAM(JATOM,IRES).EQ.'HG      ')THEN
                                                 FRGNAM(IRES)=AAA//'NAB'
               ELSE IF(JATOM.EQ.12.AND.
     *                 PTNAM(JATOM,IRES).EQ.'3HB     ')THEN
                                                 FRGNAM(IRES)=AAA//'NBA'
               END IF
               IF(JATOM.EQ.11)                   FRGNAM(IRES)=AAA//'NBB'
            ELSE IF(IRES.EQ.IFRG)THEN
               IF(JATOM.EQ.13)                   FRGNAM(IRES)=AAA//'CAA'
               IF     (JATOM.EQ.12.AND.
     *                 PTNAM(JATOM-1,IRES).EQ.'HG      ')THEN
                                                 FRGNAM(IRES)=AAA//'CAB'
               ELSE IF(JATOM.EQ.12.AND.
     *                 PTNAM(JATOM-1,IRES).EQ.'3HB     ')THEN
                                                 FRGNAM(IRES)=AAA//'CBA'
               END IF
               IF(JATOM.EQ.11)                   FRGNAM(IRES)=AAA//'CBB'
            ELSE
               IF(JATOM.EQ.11)                   FRGNAM(IRES)=AAA//'A'
               IF(JATOM.EQ.10)                   FRGNAM(IRES)=AAA//'B'
            END IF
            IF(JATOM.NE.10 .AND. JATOM.NE.11 .AND. JATOM.NE.12
     *                     .AND. JATOM.NE.13                  )THEN
               WRITE(IW,'(1X,A6,I6,A)')AAA,IRES,' WRONG NUMBER OF ATOMS'
               CALL ABRT
            END IF
C - GLN -
         ELSE IF (AAA.EQ.'GLN') THEN
            IF(JATOM.EQ.19.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'NH'
            IF(JATOM.EQ.18.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'N'
            IF(JATOM.EQ.17                      )FRGNAM(IRES)=AAA
            IF(JATOM.EQ.19.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'CH'
            IF(JATOM.EQ.18.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'C'
            IF(JATOM.NE.17 .AND. JATOM.NE.18 .AND. JATOM.NE.19)THEN
               WRITE(IW,'(1X,A6,I6,A)')AAA,IRES,' WRONG NUMBER OF ATOMS'
               CALL ABRT
            END IF
C - GLU -
         ELSE IF (AAA.EQ.'GLU') THEN
            IF(IRES.EQ.IFRGOLD+1)THEN
               IF(JATOM.EQ.18)                   FRGNAM(IRES)=AAA//'NAA'
               IF     (JATOM.EQ.17.AND.
     *                 PTNAM(JATOM,IRES).EQ.'HE      ')THEN
                                                 FRGNAM(IRES)=AAA//'NAB'
               ELSE IF(JATOM.EQ.17.AND.
     *                 PTNAM(JATOM,IRES).EQ.'3HG     ')THEN
                                                 FRGNAM(IRES)=AAA//'NBA'
               END IF
               IF(JATOM.EQ.16)                   FRGNAM(IRES)=AAA//'NBB'
            ELSE IF(IRES.EQ.IFRG)THEN
               IF(JATOM.EQ.18)                   FRGNAM(IRES)=AAA//'CAA'
               IF     (JATOM.EQ.17.AND.
     *                 PTNAM(JATOM-1,IRES).EQ.'HE      ')THEN
                                                 FRGNAM(IRES)=AAA//'CAB'
               ELSE IF(JATOM.EQ.17.AND.
     *                 PTNAM(JATOM-1,IRES).EQ.'3HG     ')THEN
                                                 FRGNAM(IRES)=AAA//'CBA'
               END IF
               IF(JATOM.EQ.16)                   FRGNAM(IRES)=AAA//'CBB'
            ELSE
               IF(JATOM.EQ.16)                   FRGNAM(IRES)=AAA//'A'
               IF(JATOM.EQ.15)                   FRGNAM(IRES)=AAA//'B'
            END IF
            IF(JATOM.NE.15 .AND. JATOM.NE.16 .AND. JATOM.NE.17
     *                     .AND. JATOM.NE.18                  )THEN
               WRITE(IW,'(1X,A6,I6,A)')AAA,IRES,' WRONG NUMBER OF ATOMS'
               CALL ABRT
            END IF
C - GLY -
         ELSE IF (AAA.EQ.'GLY') THEN
            IF(JATOM.EQ. 9.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'NH'
            IF(JATOM.EQ. 8.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'N'
            IF(JATOM.EQ. 7                      )FRGNAM(IRES)=AAA
            IF(JATOM.EQ. 9.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'CH'
            IF(JATOM.EQ. 8.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'C'
            IF(JATOM.NE.7 .AND. JATOM.NE.8 .AND. JATOM.NE.9)THEN
               WRITE(IW,'(1X,A6,I6,A)')AAA,IRES,' WRONG NUMBER OF ATOMS'
               CALL ABRT
            END IF
C - HIS -
         ELSE IF (AAA.EQ.'HIS') THEN
            IF(IRES.EQ.IFRGOLD+1)THEN
               IF(JATOM.EQ.20)                   FRGNAM(IRES)=AAA//'N7'
               IF     (                 JATOM.EQ.19
     *               .AND.PTNAM(JATOM  ,IRES).EQ.'HE1     ')THEN
                                                 FRGNAM(IRES)=AAA//'N6'
               ELSE IF(                 JATOM.EQ.19
     *               .AND.PTNAM(JATOM  ,IRES).EQ.'HE2     '
     *               .AND.PTNAM(JATOM-3,IRES).EQ.'HD2     ')THEN
                                                 FRGNAM(IRES)=AAA//'N5'
               ELSE IF(                 JATOM.EQ.19
     *               .AND.PTNAM(JATOM  ,IRES).EQ.'HE2     '
     *               .AND.PTNAM(JATOM-3,IRES).EQ.'3HB     ')THEN
                                                 FRGNAM(IRES)=AAA//'N4'
               END IF
               IF     (                 JATOM.EQ.18
     *               .AND.PTNAM(JATOM  ,IRES).EQ.'HE2     ')THEN
                                                 FRGNAM(IRES)=AAA//'N3'
               ELSE IF(                 JATOM.EQ.18
     *               .AND.PTNAM(JATOM  ,IRES).EQ.'HE1     '
     *               .AND.PTNAM(JATOM-2,IRES).EQ.'HD2     ')THEN
                                                 FRGNAM(IRES)=AAA//'N2'
               ELSE IF(                 JATOM.EQ.18
     *               .AND.PTNAM(JATOM  ,IRES).EQ.'HE1     '
     *               .AND.PTNAM(JATOM-2,IRES).EQ.'3HB     ')THEN
                                                 FRGNAM(IRES)=AAA//'N1'
               END IF
               IF(JATOM.EQ.17)                   FRGNAM(IRES)=AAA//'N0'
            ELSE IF(IRES.EQ.IFRG)THEN
               IF     (                 JATOM.EQ.20        )THEN
                                                 FRGNAM(IRES)=AAA//'C7'
               ELSE IF(                 JATOM.EQ.19
     *               .AND.PTNAM(JATOM-1,IRES).EQ.'HE1     ')THEN
                                                 FRGNAM(IRES)=AAA//'C6'
               ELSE IF(                 JATOM.EQ.19
     *               .AND.PTNAM(JATOM-1,IRES).EQ.'HE2     '
     *               .AND.PTNAM(JATOM-4,IRES).EQ.'HD2     ')THEN
                                                 FRGNAM(IRES)=AAA//'C5'
               ELSE IF(                 JATOM.EQ.19
     *               .AND.PTNAM(JATOM-1,IRES).EQ.'HE2     '
     *               .AND.PTNAM(JATOM-4,IRES).EQ.'3HB     ')THEN
                                                 FRGNAM(IRES)=AAA//'C4'
               ELSE IF(                 JATOM.EQ.18
     *               .AND.PTNAM(JATOM-1,IRES).EQ.'HE2     ')THEN
                                                 FRGNAM(IRES)=AAA//'C3'
               ELSE IF(                 JATOM.EQ.18
     *               .AND.PTNAM(JATOM-1,IRES).EQ.'HE1     '
     *               .AND.PTNAM(JATOM-3,IRES).EQ.'HD2     ')THEN
                                                 FRGNAM(IRES)=AAA//'C2'
               ELSE IF(                 JATOM.EQ.18
     *               .AND.PTNAM(JATOM-1,IRES).EQ.'HE1     '
     *               .AND.PTNAM(JATOM-3,IRES).EQ.'3HB     ')THEN
                                                 FRGNAM(IRES)=AAA//'C1'
               ELSE IF(                 JATOM.EQ.17        )THEN
                                                 FRGNAM(IRES)=AAA//'C0'
               END IF
            ELSE
               IF(JATOM.EQ.18)                   FRGNAM(IRES)=AAA//'AA'
               IF(JATOM.EQ.17)THEN
                  IF     (PTNAM(JATOM,IRES).EQ.'HE2     ')THEN
                                                 FRGNAM(IRES)=AAA//'AB'
                  ELSE IF(PTNAM(JATOM,IRES).EQ.'HE1     ')THEN
                                                 FRGNAM(IRES)=AAA//'BA'
                  END IF
               END IF
               IF(JATOM.EQ.16)                   FRGNAM(IRES)=AAA//'BB'
            END IF
            IF(JATOM.NE.16 .AND. JATOM.NE.17 .AND. JATOM.NE.18
     *                     .AND. JATOM.NE.19 .AND. JATOM.NE.20)THEN
               WRITE(IW,'(1X,A6,I6,A)')AAA,IRES,' WRONG NUMBER OF ATOMS'
               CALL ABRT
            END IF
C - ILE -
         ELSE IF (AAA.EQ.'ILE') THEN
            IF(JATOM.EQ.21.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'NH'
            IF(JATOM.EQ.20.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'N'
            IF(JATOM.EQ.19                      )FRGNAM(IRES)=AAA
            IF(JATOM.EQ.21.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'CH'
            IF(JATOM.EQ.20.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'C'
            IF(JATOM.NE.19 .AND. JATOM.NE.20 .AND. JATOM.NE.21)THEN
               WRITE(IW,'(1X,A6,I6,A)')AAA,IRES,' WRONG NUMBER OF ATOMS'
               CALL ABRT
            END IF
C - LEU -
         ELSE IF (AAA.EQ.'LEU') THEN
            IF(JATOM.EQ.21.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'NH'
            IF(JATOM.EQ.20.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'N'
            IF(JATOM.EQ.19                      )FRGNAM(IRES)=AAA
            IF(JATOM.EQ.21.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'CH'
            IF(JATOM.EQ.20.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'C'
            IF(JATOM.NE.19 .AND. JATOM.NE.20 .AND. JATOM.NE.21)THEN
               WRITE(IW,'(1X,A6,I6,A)')AAA,IRES,' WRONG NUMBER OF ATOMS'
               CALL ABRT
            END IF
C - LYS -
         ELSE IF (AAA.EQ.'LYS') THEN
            IF(IRES.EQ.IFRGOLD+1)THEN
               IF(JATOM.EQ.24)                   FRGNAM(IRES)=AAA//'NAA'
               IF     (JATOM.EQ.23.AND.
     *                 PTNAM(JATOM,IRES).EQ.'HZ3     ')THEN
                                                 FRGNAM(IRES)=AAA//'NAB'
               ELSE IF(JATOM.EQ.23.AND.
     *                 PTNAM(JATOM,IRES).EQ.'HZ2     ')THEN
                                                 FRGNAM(IRES)=AAA//'NBA'
               END IF
               IF(JATOM.EQ.22)                   FRGNAM(IRES)=AAA//'NBB'
            ELSE IF(IRES.EQ.IFRG)THEN
               IF(JATOM.EQ.24)                   FRGNAM(IRES)=AAA//'CAA'
               IF     (JATOM.EQ.23.AND.
     *                 PTNAM(JATOM-1,IRES).EQ.'HZ3     ')THEN
                                                 FRGNAM(IRES)=AAA//'CAB'
               ELSE IF(JATOM.EQ.23.AND.
     *                 PTNAM(JATOM-1,IRES).EQ.'HZ2     ')THEN
                                                 FRGNAM(IRES)=AAA//'CBA'
               END IF
               IF(JATOM.EQ.22)                   FRGNAM(IRES)=AAA//'CBB'
            ELSE
               IF(JATOM.EQ.22)                   FRGNAM(IRES)=AAA//'A'
               IF(JATOM.EQ.21)                   FRGNAM(IRES)=AAA//'B'
            END IF
            IF(JATOM.NE.21 .AND. JATOM.NE.22 .AND. JATOM.NE.23
     *                     .AND. JATOM.NE.24                  )THEN
               WRITE(IW,'(1X,A6,I6,A)')AAA,IRES,' WRONG NUMBER OF ATOMS'
               CALL ABRT
            END IF
C - MET -
         ELSE IF (AAA.EQ.'MET') THEN
            IF(JATOM.EQ.19.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'NH'
            IF(JATOM.EQ.18.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'N'
            IF(JATOM.EQ.17                      )FRGNAM(IRES)=AAA
            IF(JATOM.EQ.19.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'CH'
            IF(JATOM.EQ.18.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'C'
            IF(JATOM.NE.17 .AND. JATOM.NE.18 .AND. JATOM.NE.19)THEN
               WRITE(IW,'(1X,A6,I6,A)')AAA,IRES,' WRONG NUMBER OF ATOMS'
               CALL ABRT
            END IF
C - PHE -
         ELSE IF (AAA.EQ.'PHE') THEN
            IF(JATOM.EQ.22.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'NH'
            IF(JATOM.EQ.21.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'N'
            IF(JATOM.EQ.20                      )FRGNAM(IRES)=AAA
            IF(JATOM.EQ.22.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'CH'
            IF(JATOM.EQ.21.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'C'
            IF(JATOM.NE.20 .AND. JATOM.NE.21 .AND. JATOM.NE.22)THEN
               WRITE(IW,'(1X,A6,I6,A)')AAA,IRES,' WRONG NUMBER OF ATOMS'
               CALL ABRT
            END IF
C - PRO -
         ELSE IF (AAA.EQ.'PRO') THEN
            IF(JATOM.EQ.16.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'NH'
            IF(JATOM.EQ.15.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'N'
            IF(JATOM.EQ.14                      )FRGNAM(IRES)=AAA
            IF(JATOM.EQ.16.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'CH'
            IF(JATOM.EQ.15.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'C'
            IF(JATOM.NE.14 .AND. JATOM.NE.15 .AND. JATOM.NE.16)THEN
               WRITE(IW,'(1X,A6,I6,A)')AAA,IRES,' WRONG NUMBER OF ATOMS'
               CALL ABRT
            END IF
C - SER -
         ELSE IF (AAA.EQ.'SER') THEN
            IF(IRES.EQ.IFRGOLD+1)THEN
               IF(JATOM.EQ.13)                   FRGNAM(IRES)=AAA//'NAA'
               IF     (JATOM.EQ.12.AND.
     *                 PTNAM(JATOM,IRES).EQ.'HG      ')THEN
                                                 FRGNAM(IRES)=AAA//'NAB'
               ELSE IF(JATOM.EQ.12.AND.
     *                 PTNAM(JATOM,IRES).EQ.'3HB     ')THEN
                                                 FRGNAM(IRES)=AAA//'NBA'
               END IF
               IF(JATOM.EQ.11)                   FRGNAM(IRES)=AAA//'NBB'
            ELSE IF(IRES.EQ.IFRG)THEN
               IF(JATOM.EQ.13)                   FRGNAM(IRES)=AAA//'CAA'
               IF     (JATOM.EQ.12.AND.
     *                 PTNAM(JATOM-1,IRES).EQ.'HG      ')THEN
                                                 FRGNAM(IRES)=AAA//'CAB'
               ELSE IF(JATOM.EQ.12.AND.
     *                 PTNAM(JATOM-1,IRES).EQ.'3HB     ')THEN
                                                 FRGNAM(IRES)=AAA//'CBA'
               END IF
               IF(JATOM.EQ.11)                   FRGNAM(IRES)=AAA//'CBB'
            ELSE
               IF(JATOM.EQ.11)                   FRGNAM(IRES)=AAA//'A'
               IF(JATOM.EQ.10)                   FRGNAM(IRES)=AAA//'B'
            END IF
            IF(JATOM.NE.10 .AND. JATOM.NE.11 .AND. JATOM.NE.12
     *                     .AND. JATOM.NE.13                  )THEN
               WRITE(IW,'(1X,A6,I6,A)')AAA,IRES,' WRONG NUMBER OF ATOMS'
               CALL ABRT
            END IF
C - THR -
         ELSE IF (AAA.EQ.'THR') THEN
            IF(IRES.EQ.IFRGOLD+1)THEN
               IF(JATOM.EQ.16)                   FRGNAM(IRES)=AAA//'NAA'
               IF     (JATOM.EQ.15.AND.
     *                 PTNAM(JATOM,IRES).EQ.'HG1     ')THEN
                                                 FRGNAM(IRES)=AAA//'NAB'
               ELSE IF(JATOM.EQ.15.AND.
     *                 PTNAM(JATOM,IRES).EQ.'1HG2    ')THEN
                                                 FRGNAM(IRES)=AAA//'NBA'
               END IF
               IF(JATOM.EQ.14)                   FRGNAM(IRES)=AAA//'NBB'
            ELSE IF(IRES.EQ.IFRG)THEN
               IF(JATOM.EQ.16)                   FRGNAM(IRES)=AAA//'CAA'
               IF     (JATOM.EQ.15.AND.
     *                 PTNAM(JATOM-4,IRES).EQ.'HG1     ')THEN
                                                 FRGNAM(IRES)=AAA//'CAB'
               ELSE IF(JATOM.EQ.15.AND.
     *                 PTNAM(JATOM-4,IRES).EQ.'1HG2    ')THEN
                                                 FRGNAM(IRES)=AAA//'CBA'
               END IF
               IF(JATOM.EQ.14)                   FRGNAM(IRES)=AAA//'CBB'
            ELSE
               IF(JATOM.EQ.14)                   FRGNAM(IRES)=AAA//'A'
               IF(JATOM.EQ.13)                   FRGNAM(IRES)=AAA//'B'
            END IF
            IF(JATOM.NE.13 .AND. JATOM.NE.14 .AND. JATOM.NE.15
     *                     .AND. JATOM.NE.16                  )THEN
               WRITE(IW,'(1X,A6,I6,A)')AAA,IRES,' WRONG NUMBER OF ATOMS'
               CALL ABRT
            END IF
C - TRP -
         ELSE IF (AAA.EQ.'TRP') THEN
            IF(JATOM.EQ.21.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'NH'
            IF(JATOM.EQ.20.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'N'
            IF(JATOM.EQ.19                      )FRGNAM(IRES)=AAA
            IF(JATOM.EQ.21.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'CH'
            IF(JATOM.EQ.20.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'C'
            IF(JATOM.NE.19 .AND. JATOM.NE.20 .AND. JATOM.NE.21)THEN
               WRITE(IW,'(1X,A6,I6,A)')AAA,IRES,' WRONG NUMBER OF ATOMS'
               CALL ABRT
            END IF
C - TYR -
         ELSE IF (AAA.EQ.'TYR') THEN
            IF(IRES.EQ.IFRGOLD+1)THEN
               IF(JATOM.EQ.23)                   FRGNAM(IRES)=AAA//'NAA'
               IF     (JATOM.EQ.22.AND.
     *                 PTNAM(JATOM,IRES).EQ.'HH      ')THEN
                                                 FRGNAM(IRES)=AAA//'NAB'
               ELSE IF(JATOM.EQ.22.AND.
     *                 PTNAM(JATOM,IRES).EQ.'HE2     ')THEN
                                                 FRGNAM(IRES)=AAA//'NBA'
               END IF
               IF(JATOM.EQ.21)                   FRGNAM(IRES)=AAA//'NBB'
            ELSE IF(IRES.EQ.IFRG)THEN
               IF(JATOM.EQ.23)                   FRGNAM(IRES)=AAA//'CAA'
               IF     (JATOM.EQ.22.AND.
     *                 PTNAM(JATOM-1,IRES).EQ.'HH      ')THEN
                                                 FRGNAM(IRES)=AAA//'CAB'
               ELSE IF(JATOM.EQ.22.AND.
     *                 PTNAM(JATOM-1,IRES).EQ.'HE2     ')THEN
                                                 FRGNAM(IRES)=AAA//'CBA'
               END IF
               IF(JATOM.EQ.21)                   FRGNAM(IRES)=AAA//'CBB'
            ELSE
               IF(JATOM.EQ.21)                   FRGNAM(IRES)=AAA//'A'
               IF(JATOM.EQ.20)                   FRGNAM(IRES)=AAA//'B'
            END IF
            IF(JATOM.NE.20 .AND. JATOM.NE.21 .AND. JATOM.NE.22
     *                     .AND. JATOM.NE.23                  )THEN
               WRITE(IW,'(1X,A6,I6,A)')AAA,IRES,' WRONG NUMBER OF ATOMS'
               CALL ABRT
            END IF
C - VAL -
         ELSE IF (AAA.EQ.'VAL') THEN
            IF(JATOM.EQ.18.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'NH'
            IF(JATOM.EQ.17.AND.IRES.EQ.IFRGOLD+1)FRGNAM(IRES)=AAA//'N'
            IF(JATOM.EQ.16                      )FRGNAM(IRES)=AAA
            IF(JATOM.EQ.18.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'CH'
            IF(JATOM.EQ.17.AND.IRES.EQ.IFRG     )FRGNAM(IRES)=AAA//'C'
            IF(JATOM.NE.16 .AND. JATOM.NE.17 .AND. JATOM.NE.18)THEN
               WRITE(IW,'(1X,A6,I6,A)')AAA,IRES,' WRONG NUMBER OF ATOMS'
               CALL ABRT
            END IF
         END IF
      WRITE(IW,'(1X,A6,A6,I3,A6)')FRGNAM(IRES),' WITH ',JATOM,' ATOMS'
      ENDDO
C
      WRITE(IW,*)' READING $PDBFRG IS DONE'
      RETURN
      END
C*MODULE EFINP   *DECK RDLJPOT
      SUBROUTINE RDLJPOT(NPTS,N)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      PARAMETER (MXPT=2000, MXFRG=1050, MXFGPT=12000)
C
      LOGICAL GOPARR,MASWRK,DSKWRK
C
      CHARACTER*8 LJNAME,ELJNAM
C
      COMMON /FRGLJP/ CORDLJ(3,MXPT),ELJCRD(3,MXFGPT),
     *                POTLJ(2,MXPT),ELJPOT(2,MXFGPT),
     *                LJNAME(MXPT),ELJNAM(MXFGPT),
     *                NLJPTS(MXFRG),NLJTTPT,ILJP,NMLJ(2)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C
      ILJP = 1
      IERR = 0
      IEOF = 0
      NPTS = 0
  100 CONTINUE
      K = NPTS + 1
      IF(K.GT.MXPT) THEN
         IF(MASWRK) WRITE(IW,9000) N,MXPT
         CALL ABRT
      END IF
      CALL RDCARD('RDLJPOT ',IEOF)
      IF(IEOF.EQ.1) THEN
         IF(MASWRK)WRITE(IW,*)
     *      'END OF FILE READING FRAGMENT LJ POTENTIAL'
         CALL ABRT
      END IF
      LJNAME(K) = '        '
      LGSTR=-8
      CALL GSTRNG(LJNAME(K),LGSTR)
      IF(LJNAME(K).EQ.'STOP    ') RETURN
      DO J=1,3
        CORDLJ(J,K) = RFIND('LJCORD  ',IERR)
        IF(IERR.NE.0) THEN
           IF(MASWRK) WRITE(IW,*) 'RDLJPOT: ERROR READING LJCORD'
           CALL ABRT
        END IF
      ENDDO
      DO J=1,2
        POTLJ(J,K) = RFIND('LJPOT   ',IERR)
        IF(IERR.NE.0) THEN
           IF(MASWRK) WRITE(IW,*) 'RDLJPOT: ERROR READING LJPOT'
           CALL ABRT
        END IF
      ENDDO
      NPTS = NPTS + 1
      GO TO 100
C
 9000 FORMAT(1X,'ERROR IN READING LJ POINTS FOR FRAGMENT',I6,
     *          ' EXCEEDED MXPT=',I6)
      END
C*MODULE EFINP   *DECK LEVELEFP
      INTEGER FUNCTION LEVELEFP()
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL EFP0MODEL,EFP1MODEL,EFP2MODEL
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXAO=8192, MXSHEF=1000, MXGEFP=4000,
     *           MXPT=2000, MXFRG=1050, MXFGPT=12000, MXDFG=5,
     *           MXDPPT=MXFRG*MXDFG*12)
C
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NAT(MXDFG),NUM(MXDFG),NTPATM
      COMMON /EFPCT / NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CTFOK(MXAO,MXDFG),NCTMO(MXDFG),NTCTMO
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
C
C        RETURN THE EFFECTIVE FRAGMENT POTENTIAL IMPLEMENTATION USED
C
      EFP0MODEL = NMTTPT+NPTTPT           .GT.0  ! ELECSTATICS/INDUCTION
      EFP1MODEL = NRTTPT+NDTTPT           .GT.0
      EFP2MODEL = NTPATM+NTMO+NDPTTPT+NTCTMO.GT.0
C
      IF(EFP1MODEL .AND. EFP2MODEL) THEN
         IF(MASWRK) WRITE(IW,9000) NRTTPT,NDTTPT,
     *                             NTPATM,NTMO,NDPTTPT,NTCTMO
         CALL ABRT
      END IF
C
C        EFP0MODEL IS TRUE IF THERE IS NO EXREP OR OTHER FANCY STUFF,
C        BUT IF ELECTROSTATICS/POLARIZATION IS IN USE.  THAT'S A EFP1.
C
                    LEVELEFP=0
      IF(EFP0MODEL) LEVELEFP=1
      IF(EFP1MODEL) LEVELEFP=1
      IF(EFP2MODEL) LEVELEFP=2
      RETURN
C
 9000 FORMAT(1X,'LEVELEFP: BOTH LEVEL 1 AND LEVEL 2 TERMS ARE ON',
     *          ' AT THE SAME TIME?'/
     *       1X,'EFP1: NRTTPT=',I7,' NDTTPT=',I7/
     *       1X,'EFP2: NTPATM=',I7,' NTMO=',I7,' NDPTTPT=',I7,
     *          ' NTCTMO=',I7)
      END
C*MODULE EFINP   *DECK POL5P
      SUBROUTINE POL5P(IFRAG)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXPT=2000, MXFRG=1050, MXFGPT=12000, MXIFRQ=12,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      PARAMETER (ZERO=0.0D+00)
C
      LOGICAL DOMTMP,DODTMP,DOQTMP,DOOTMP
C
      CHARACTER*8 MNAME,PNAME,RNAME,DPNAME,FNAME,LJNAME,ELJNAM
C
      COMMON /DOTMP / DOMTMP(MXPT),DODTMP(MXPT),DOQTMP(MXPT),
     *                DOOTMP(MXPT)
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ,MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGLJP/ CORDLJ(3,MXPT),ELJCRD(3,MXFGPT),
     *                POTLJ(2,MXPT),ELJPOT(2,MXFGPT),
     *                LJNAME(MXPT),ELJNAM(MXFGPT),
     *                NLJPTS(MXFRG),NLJTTPT,ILJP,NMLJ(2)
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
C
      IEFC = 1
      IEFD = 0
      IEFQ = 0
      IEFO = 0
      IEFP = 1
      IREP = 1
      ILJP = 1
      NMLJ(1)=12
      NMLJ(2)= 6
      NMPTS(IFRAG)=5
      NPPTS(IFRAG)=1
      NRPTS(IFRAG)=5
      NDPTS(IFRAG)=0
      NLJPTS(IFRAG)=1
C
C     INITIALIZE LOCAL COMMON BLOCK FRGSTD
C
      CALL VCLR(CORD(1,1),1,50*MXPT)
      DO I=1,MXPT
         INLPR(4*(I-1)+1)=0
         INLPR(4*(I-1)+2)=0
         INLPR(4*(I-1)+3)=0
         INLPR(4*(I-1)+4)=0
         IKFR(I)=0
         IKLR(I)=0
         MNAME(I)='        '
         PNAME(I)='        '
         RNAME(I)='        '
         LJNAME(I)='        '
         DOMTMP(I) =  .FALSE.
         DODTMP(I) =  .FALSE.
         DOQTMP(I) =  .FALSE.
         DOOTMP(I) =  .FALSE.
      ENDDO
C
C     COORDINATES
C
      MNAME(1)  = 'O1      '
      CORD(1,1) = ZERO
      CORD(2,1) = ZERO
      CORD(3,1) = ZERO
      FPMASS(1) = 15.99491D+00
      FPNUC(1)  = 8.0D+00
      MNAME(2)  = 'H2      '
      CORD(1,2) = -1.43042D+00
      CORD(2,2) = ZERO
      CORD(3,2) = 1.107161D+00
      FPMASS(2) = 1.007825D+00
      FPNUC(2)  = 1.0D+00
      MNAME(3)  = 'H3      '
      CORD(1,3) = 1.43042D+00
      CORD(2,3) = ZERO
      CORD(3,3) = 1.107161D+00
      FPMASS(3) = 1.007825D+00
      FPNUC(3)  = 1.0D+00
      MNAME(4)  = 'L4      '
      CORD(1,4) = ZERO
      CORD(2,4) = 1.07999361D+00
      CORD(3,4) = -0.763829D+00
      FPMASS(4) = ZERO
      FPNUC(4)  = ZERO
      MNAME(5)  = 'L5      '
      CORD(1,5) = ZERO
      CORD(2,5) = -1.07999361D+00
      CORD(3,5) = -0.763829D+00
      FPMASS(5) = ZERO
      FPNUC(5)  = ZERO
C
C     CHARGES
C
      DOMTMP(1) = .TRUE.
      ACHG(1,1) =-8.0D+00
      ACHG(2,1) = 8.0D+00
      DOMTMP(2) = .TRUE.
      ACHG(1,2) = -0.805D+00
      ACHG(2,2) = 1.0D+00
      DOMTMP(3) = .TRUE.
      ACHG(1,3) = ACHG(1,2)
      ACHG(2,3) = ACHG(2,2)
      DOMTMP(4) = .TRUE.
      ACHG(1,4) = -0.195D+00
      ACHG(2,4) = ZERO
      DOMTMP(5) = .TRUE.
      ACHG(1,5) = ACHG(1,4)
      ACHG(2,5) = ACHG(2,4)
C
C     POLARIZABLE POINTS
C
      PNAME(1)   ='O1      '
      PCORD(1,1) = ZERO
      PCORD(2,1) = ZERO
      PCORD(3,1) = ZERO
      POLT(1,1)  =10.32D+00
      POLT(2,1)  = 9.55D+00
      POLT(3,1)  = 9.91D+00
      POLT(4,1)  = ZERO
      POLT(5,1)  = ZERO
      POLT(6,1)  = ZERO
      POLT(7,1)  = ZERO
      POLT(8,1)  = ZERO
      POLT(9,1)  = ZERO
C
C     QM-MM REPULSIVE POTENTIAL
C
      DO KKK=1,5
         RNAME(  KKK) = MNAME( KKK)
         RCORD(1,KKK) = CORD(1,KKK)
         RCORD(2,KKK) = CORD(2,KKK)
         RCORD(3,KKK) = CORD(3,KKK)
      ENDDO
      IKFR(1) = 1
      IKLR(1) = 1
      TCLPR(1) = 30.0D+00
      INLPR(1) = 2
      TZLPR(1) = 1.4D+00
C
      IKFR(2) = 2
      IKLR(2) = 2
      TCLPR(2) = -0.00085D+00
      INLPR(2) = 2
      TZLPR(2) = 0.1D+00
C
      IKFR(3) = 3
      IKLR(3) = 3
      TCLPR(3) = TCLPR(2)
      INLPR(3) = INLPR(2)
      TZLPR(3) = TZLPR(2)
C
      IKFR(4) = 4
      IKLR(4) = 4
      TCLPR(4) = 1.4D+00
      INLPR(4) = 2
      TZLPR(4) = 1.4D+00
C
      IKFR(5) = 5
      IKLR(5) = 5
      TCLPR(5) = TCLPR(4)
      INLPR(5) = INLPR(4)
      TZLPR(5) = TZLPR(4)
C
C     LENNARD-JONES POTENTIAL
C
      LJNAME(1)   = MNAME(1)
      CORDLJ(1,1) = CORD(1,1)
      CORDLJ(2,1) = CORD(2,1)
      CORDLJ(3,1) = CORD(3,1)
C     AAA = 654500.0  BBB = 780.0
      POTLJ(1,1)  = 3.07116046184D+00
      POTLJ(2,1)  = 0.23239113827D+00
C
      RETURN
      END
C*MODULE EFINP   *DECK TIP5P
      SUBROUTINE TIP5P(IFRAG,INDEX)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXPT=2000, MXFRG=1050, MXFGPT=12000, MXIFRQ=12,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      PARAMETER (ZERO=0.0D+00)
C
      LOGICAL DOMTMP,DODTMP,DOQTMP,DOOTMP
C
      CHARACTER*8 MNAME,PNAME,RNAME,DPNAME,FNAME,LJNAME,ELJNAM
C
      COMMON /DOTMP / DOMTMP(MXPT),DODTMP(MXPT),DOQTMP(MXPT),
     *                DOOTMP(MXPT)
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ,MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGLJP/ CORDLJ(3,MXPT),ELJCRD(3,MXFGPT),
     *                POTLJ(2,MXPT),ELJPOT(2,MXFGPT),
     *                LJNAME(MXPT),ELJNAM(MXFGPT),
     *                NLJPTS(MXFRG),NLJTTPT,ILJP,NMLJ(2)
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
C
      IEFC = 1
      IEFD = 0
      IEFQ = 0
      IEFO = 0
      IEFP = 0
      IREP = 1
      ILJP = 1
      NMLJ(1)=12
      NMLJ(2)= 6
      NMPTS(IFRAG)=5
      NPPTS(IFRAG)=0
      NRPTS(IFRAG)=5
      NDPTS(IFRAG)=0
      NLJPTS(IFRAG)=1
C
C     INITIALIZE LOCAL COMMON BLOCK FRGSTD
C
      CALL VCLR(CORD(1,1),1,50*MXPT)
      DO I=1,MXPT
         INLPR(4*(I-1)+1)=0
         INLPR(4*(I-1)+2)=0
         INLPR(4*(I-1)+3)=0
         INLPR(4*(I-1)+4)=0
         IKFR(I)=0
         IKLR(I)=0
         MNAME(I)='        '
         PNAME(I)='        '
         RNAME(I)='        '
         LJNAME(I)='        '
         DOMTMP(I) =  .FALSE.
         DODTMP(I) =  .FALSE.
         DOQTMP(I) =  .FALSE.
         DOOTMP(I) =  .FALSE.
      ENDDO
C
C     COORDINATES
C
      MNAME(1)  = 'O1      '
      CORD(1,1) = ZERO
      CORD(2,1) = ZERO
      CORD(3,1) = ZERO
      FPMASS(1) = 15.99491D+00
      FPNUC(1)  = 8.0D+00
      MNAME(2)  = 'H2      '
      CORD(1,2) = -1.43042D+00
      CORD(2,2) = ZERO
      CORD(3,2) = 1.107161D+00
      FPMASS(2) = 1.007825D+00
      FPNUC(2)  = 1.0D+00
      MNAME(3)  = 'H3      '
      CORD(1,3) = 1.43042D+00
      CORD(2,3) = ZERO
      CORD(3,3) = 1.107161D+00
      FPMASS(3) = 1.007825D+00
      FPNUC(3)  = 1.0D+00
      MNAME(4)  = 'L4      '
      CORD(1,4) = ZERO
      CORD(2,4) = 1.07999361D+00
      CORD(3,4) = -0.763829D+00
      FPMASS(4) = ZERO
      FPNUC(4)  = ZERO
      MNAME(5)  = 'L5      '
      CORD(1,5) = ZERO
      CORD(2,5) = -1.07999361D+00
      CORD(3,5) = -0.763829D+00
      FPMASS(5) = ZERO
      FPNUC(5)  = ZERO
C
C     CHARGES
C
      DOMTMP(1) = .TRUE.
      ACHG(1,1) =-8.0D+00
      ACHG(2,1) = 8.0D+00
      DOMTMP(2) = .TRUE.
      ACHG(1,2) = -0.759D+00
      ACHG(2,2) = 1.0D+00
      DOMTMP(3) = .TRUE.
      ACHG(1,3) = ACHG(1,2)
      ACHG(2,3) = ACHG(2,2)
      DOMTMP(4) = .TRUE.
      ACHG(1,4) = -0.241D+00
      ACHG(2,4) = ZERO
      DOMTMP(5) = .TRUE.
      ACHG(1,5) = ACHG(1,4)
      ACHG(2,5) = ACHG(2,4)
C
C     QM-MM REPULSIVE POTENTIAL
C
      DO KKK=1,5
         RNAME(  KKK) = MNAME( KKK)
         RCORD(1,KKK) = CORD(1,KKK)
         RCORD(2,KKK) = CORD(2,KKK)
         RCORD(3,KKK) = CORD(3,KKK)
      ENDDO
      IKFR(1) = 1
      IKLR(1) = 1
      TCLPR(1) = 30.0D+00
      INLPR(1) = 2
      TZLPR(1) = 1.4D+00
C
      IKFR(2) = 2
      IKLR(2) = 2
      TCLPR(2) = -0.00042D+00
      INLPR(2) = 2
      TZLPR(2) = 0.1D+00
C
      RNAME(3) = MNAME(3)
      RCORD(1,3) = CORD(1,3)
      RCORD(2,3) = CORD(2,3)
      RCORD(3,3) = CORD(3,3)
      IKFR(3) = 3
      IKLR(3) = 3
      TCLPR(3) = TCLPR(2)
      INLPR(3) = INLPR(2)
      TZLPR(3) = TZLPR(2)
C
      IKFR(4) = 4
      IKLR(4) = 4
      TCLPR(4) = 2.0D+00
      INLPR(4) = 2
      TZLPR(4) = 1.4D+00
C
      IKFR(5) = 5
      IKLR(5) = 5
      TCLPR(5) = TCLPR(4)
      INLPR(5) = INLPR(4)
      TZLPR(5) = TZLPR(4)
C
C     LENNARD-JONES POTENTIAL
C
      LJNAME(1)   = 'O1      '
      CORDLJ(1,1) = CORD(1,1)
      CORDLJ(2,1) = CORD(2,1)
      CORDLJ(3,1) = CORD(3,1)
      POTLJ(1,1)  = 3.120D+00
      POTLJ(2,1)  = 0.160D+00
      IF(INDEX.EQ.1)THEN
         POTLJ(1,1)  = 3.097D+00
         POTLJ(2,1)  = 0.178D+00
      END IF
C
      RETURN
      END
C*MODULE EFINP   *DECK SPC
      SUBROUTINE SPC(IFRAG,INDEX)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXPT=2000, MXFRG=1050, MXFGPT=12000, MXIFRQ=12,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      PARAMETER (ZERO=0.0D+00)
C
      LOGICAL DOMTMP,DODTMP,DOQTMP,DOOTMP
C
      CHARACTER*8 MNAME,PNAME,RNAME,DPNAME,FNAME,LJNAME,ELJNAM
C
      COMMON /DOTMP / DOMTMP(MXPT),DODTMP(MXPT),DOQTMP(MXPT),
     *                DOOTMP(MXPT)
      COMMON /FRGSTD/ CORD(3,MXPT),PCORD(3,MXPT),POLT(9,MXPT),
     *                DPCORD(3,MXIFRQ*MXPT),DPOLT(9,MXIFRQ*MXPT),
     *                ACHG(2,MXPT),ADIP(3,MXPT),AQAD(6,MXPT),
     *                AOCT(10,MXPT),AMULT(MXPT),BMULT(MXPT),
     *                AMULT2(MXPT),BMULT2(MXPT),
     *                RCORD(3,MXPT),TCLPR(4*MXPT),TZLPR(4*MXPT),
     *                INLPR(4*MXPT),IKFR(MXPT),IKLR(MXPT),
     *                MNAME(MXPT),PNAME(MXPT),RNAME(MXPT),
     *                DPNAME(MXIFRQ,MXPT),POLSCRN(MXPT),
     *                FCRD(3,MXPT),FNAME(MXPT),NFPNT(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGLJP/ CORDLJ(3,MXPT),ELJCRD(3,MXFGPT),
     *                POTLJ(2,MXPT),ELJPOT(2,MXFGPT),
     *                LJNAME(MXPT),ELJNAM(MXFGPT),
     *                NLJPTS(MXFRG),NLJTTPT,ILJP,NMLJ(2)
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
C
      IEFC = 1
      IEFD = 0
      IEFQ = 0
      IEFO = 0
      IEFP = 0
      IREP = 1
      ILJP = 1
      NMLJ(1)=12
      NMLJ(2)= 6
      NMPTS(IFRAG)=3
      NPPTS(IFRAG)=0
      NRPTS(IFRAG)=3
      NDPTS(IFRAG)=0
      NLJPTS(IFRAG)=1
C
C     INITIALIZE LOCAL COMMON BLOCK FRGSTD
C
      CALL VCLR(CORD(1,1),1,50*MXPT)
      DO I=1,MXPT
         INLPR(4*(I-1)+1)=0
         INLPR(4*(I-1)+2)=0
         INLPR(4*(I-1)+3)=0
         INLPR(4*(I-1)+4)=0
         IKFR(I)=0
         IKLR(I)=0
         MNAME(I)='        '
         PNAME(I)='        '
         RNAME(I)='        '
         LJNAME(I)='        '
         DOMTMP(I) =  .FALSE.
         DODTMP(I) =  .FALSE.
         DOQTMP(I) =  .FALSE.
         DOOTMP(I) =  .FALSE.
      ENDDO
C
C     COORDINATES
C
      MNAME(1)  = 'O1      '
      CORD(1,1) = ZERO
      CORD(2,1) = ZERO
      CORD(3,1) = ZERO
      FPMASS(1) = 15.99491D+00
      FPNUC(1)  = 8.0D+00
      MNAME(2)  = 'H2      '
      CORD(1,2) = -1.5429433D+00
      CORD(2,2) = ZERO
      CORD(3,2) = 1.0910503D+00
      FPMASS(2) = 1.007825D+00
      FPNUC(2)  = 1.0D+00
      MNAME(3)  = 'H3      '
      CORD(1,3) = 1.5429433D+00
      CORD(2,3) = ZERO
      CORD(3,3) = 1.0910503D+00
      FPMASS(3) = 1.007825D+00
      FPNUC(3)  = 1.0D+00
C
C     CHARGES
C
      DOMTMP(1) = .TRUE.
      ACHG(1,1) =-8.82D+00
      IF(INDEX.EQ.1) ACHG(1,1) =-8.8476D+00
      ACHG(2,1) = 8.00D+00
      DOMTMP(2) = .TRUE.
      ACHG(1,2) = -0.59D+00
      IF(INDEX.EQ.1) ACHG(1,2) = -0.5762D+00
      ACHG(2,2) = 1.0D+00
      DOMTMP(3) = .TRUE.
      ACHG(1,3) = ACHG(1,2)
      ACHG(2,3) = ACHG(2,2)
C
C     QM-MM REPULSIVE POTENTIAL
C
      DO KKK=1,3
         RNAME(  KKK) = MNAME( KKK)
         RCORD(1,KKK) = CORD(1,KKK)
         RCORD(2,KKK) = CORD(2,KKK)
         RCORD(3,KKK) = CORD(3,KKK)
      ENDDO
      IKFR(1) = 1
      IKLR(1) = 1
      TCLPR(1) = 30.0D+00
      INLPR(1) = 2
      TZLPR(1) = 1.1D+00
C
      IKFR(2) = 2
      IKLR(2) = 2
      TCLPR(2) = -0.00033D+00
      INLPR(2) = 2
      TZLPR(2) = 0.1D+00
C
      IKFR(3) = 3
      IKLR(3) = 3
      TCLPR(3) = TCLPR(2)
      INLPR(3) = INLPR(2)
      TZLPR(3) = TZLPR(2)
C
C     LENNARD-JONES POTENTIAL
C
      LJNAME(1)   = 'O1      '
      CORDLJ(1,1) = CORD(1,1)
      CORDLJ(2,1) = CORD(2,1)
      CORDLJ(3,1) = CORD(3,1)
C     AAA = 629400.0   BBB = 625.50
      POTLJ(1,1)  = 3.16555529528D+00
      POTLJ(2,1)  = 0.15540604147D+00
C
      RETURN
      END
C*MODULE EFINP   *DECK QMEFPEAX
      SUBROUTINE QMEFPEAX
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXFRG=1050, MXDFG=5,MXDPPT=MXFRG*MXDFG*12)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      LOGICAL MASWRK,DSKWRK,GOPARR
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      LOGICAL EFSTATIC,MTD1,MTD2
      COMMON /EFNRGY/ ENUCRP,REPNUC0,ENEL,EFRMS,QEFEA0(5),QEFEAP(5),
     *                MTD1,MTD2,EFSTATIC
      LOGICAL STEP1,STEP2
      DATA RNONE/8HNONE    /
      PARAMETER (NNAM=6)
      DIMENSION QNAM(NNAM),KQNAM(NNAM)
      DATA QMEFP /8HQMEFP   /
      DATA QNAM/8HSTEP1   ,8HSTEP2   ,8HSTOTAL  ,8HEMULT   ,
     *          8HEREM    ,8HMTD1    /
      DATA KQNAM /0,0,3,3,  3,0/
      PARAMETER (ZERO=0.D0)
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      IF(NFRG.EQ.0) THEN
         WRITE(IW,9006)
         CALL ABRT
      ENDIF
C     INITIALIZE VARIABLES
      DO I=1,5
         QEFEA0(I)=ZERO
         QEFEAP(I)=ZERO
      ENDDO
      STEP1=.TRUE.
      STEP2=.TRUE.
      STOTAL=RNONE
      EMULT=RNONE
      EREM=RNONE
C
C MTD2 IS DEALT WITH AUTOMATICALLY,
C BUT IT IS NOT UNREASONABLE TO ALLOW MTD1 IN THE INPUT
C WHEN THE USER KNOWS WHAT THEY ARE DOING.
C METHOD 1 CAN BE USED TO CHECK THAT THE EFP DIPOLES AND THE QM
C ARE TRULY SELF-CONSISTENT BY MULTIPLYING THE INDUCED DIPOLES BY
C THE INVERSE OF THE POLARIZABILITY TENSOR.  THIS NEW FIELD SHOULD
C BE IDENTICAL TO THE SUM OF THE FIELDS DUE TO THE QM REGION (BOTH
C ELECTRONIC AND NUCLEAR), THE EFP MULTIPOLE MOMENTS AND EFP INDUCED
C DIPOLES.  THE RMS DEVIATION IS PRINTED.  THIS WILL ONLY WORK FOR
C METHODS DECLARED TO BE COMPLETELY SELF-CONSISTENT.
C
      MTD1=.FALSE.
      MTD2=.FALSE.
      IF(TDDFTYP.NE.RNONE) MTD2=.TRUE.
      IF(CCTYP  .NE.RNONE) MTD2=.TRUE.
      IF(MPLEVL .NE.0    ) MTD2=.TRUE.
      IF(CITYP  .NE.RNONE) MTD2=.TRUE.
C
      CALL NAMEIO(IR,JRET,QMEFP,NNAM,QNAM,KQNAM,
     *            STEP1,STEP2,STOTAL,EMULT,EREM, MTD1,0,
     *   0,0,0,0,0,    0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,
     *   0,0,0,0,0,    0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,
     *   0,0,0,0,0,    0,0,0,0,0,   0,0,0,0,0,   0,0)
      IF(JRET .EQ. 2) THEN
         IF (MASWRK) WRITE (IW,9001)
         CALL ABRT
      END IF
C
      IF(MTD1.AND.MTD2) THEN
         IF(MASWRK) WRITE(IW,*) 'MTD1 DOES NOT WORK WITH THIS METHOD'
         CALL ABRT
      ENDIF
C
      IF(.NOT.STEP1 .AND. .NOT.STEP2) THEN
         IF(MASWRK) WRITE(IW,9005)
         CALL ABRT
      ENDIF
C
      IF(.NOT.STEP1) THEN
         IF(STOTAL.EQ.RNONE .OR. EMULT.EQ.RNONE .OR. EREM.EQ.RNONE) THEN
            IF(MASWRK) WRITE(IW,9002)
            CALL ABRT
         ELSE
            QEFEA0(1)=STOTAL
            QEFEA0(2)=EMULT
            QEFEA0(3)=EREM
         ENDIF
      ENDIF
C
C     DON'T FORGET IF POLARIZATION WAS ON OR OFF
      IEFPSAV=IEFP
C
      IF(STEP1) THEN
C        STEP 1 IS THE QM METHOD WITHOUT EFP.
C        EFP INTEGRAL AND INTERACTION ROUTINES WILL
C        SET APPROPRIATE VARIABLES TO ZERO DURING
C        STEP 1.
         EFSTATIC=.TRUE.
         IEFP=0
         CALL ENERGX
C        WRITE THE $QMEFP RESTART INFORMATION.
         IF(MASWRK) WRITE(IP,9004) QEFEA0(1),QEFEA0(2),QEFEA0(3)
         IF(.NOT.STEP2) THEN
            IF(MASWRK) WRITE(IW,9003)
            RETURN
         ENDIF
C        STEP2 CAN BE RUN SEPARATELY BY INCLUDING
C        THE $QMEFP GROUP
      ENDIF
C
      IF(STEP2) THEN
C        STEP 2 IS THE FULLY POLARIZED SOLUTION.
         EFSTATIC=.FALSE.
         IEFP=IEFPSAV
C        NEVALS CONTROLS COMPUTATION OF GUESS ORBITALS.
C        IF THIS IS NOT SET TO ZERO, THE ENERGY COMPONENTS
C        DO NOT MATCH THE RESULT FROM THE TRADITIONAL
C        RUNTYP=ENERGY.
         NEVALS=0
         CALL ENERGX
      ENDIF
C
C     AT THE END, QEFEAP() CONTAINS THE
C     FINAL ENERGY DECOMPOSITION
C
C
C SOLUTE POLARIZATION IS THE CHANGE IN THE EXPECTATION VALUE OF
C HQM+VES+VREM DUE TO THE CHANGE IN THE QM WAVEFUNCTION BETWEEN
C STEP1 AND STEP2
      QEFEAP(4) = (QEFEAP(1)-QEFEA0(1))
     *           +(QEFEAP(4)-QEFEA0(2))
     *           +(QEFEAP(3)-QEFEA0(3))
C
C     THE TOTAL ELECTROSTATIC INTERACTION
C     < PSI1 | VES  | PSI1 > + ENF
      QEFEAP(2)=QEFEA0(2)+QEFEAP(2)
C     THE REMAINDER (CHARGE-TRANSFER + EXCHANGE) INTERACTION
C     < PSI1 | VREM | PSI1 >
      QEFEAP(3)=QEFEA0(3)
C
C     THE SOLUTE ENERGY IS ANYTHING THAT IS
C     NOT A QM-EFP INTERACTION
      SOLUTE=QEFEA0(1)
C SINCE MTD2 HAS A DIFFERENT TOTAL ENERGY THAN STEP2,
C TOTAL ENERGY MUST BE A SUM OF INTRA- AND INTER-MOLECULAR
C ENERGIES.
      TOTAL=0.D0+ENEL
C     RTOTAL=QEFEA0(1)+ENEL
      DO I=2,5
C        SOLUTE=SOLUTE-QEFEAP(I)
         TOTAL=TOTAL+QEFEAP(I)
C        RTOTAL=RTOTAL+QEFEAP(I)
      ENDDO
      QTOTAL=SOLUTE+TOTAL
C
      IF(MASWRK) THEN
         WRITE(IW,9110)
         WRITE(IW,9111)
         IF(MTD1) THEN
            WRITE(IW,9112)
            WRITE(IW,9113) EFRMS
         ENDIF
         IF(MTD2) WRITE(IW,9114)
         WRITE(IW,9120) SOLUTE
         WRITE(IW,9130) QEFEAP(2)
         WRITE(IW,9140) QEFEAP(3)
         WRITE(IW,9150) QEFEAP(4)
         WRITE(IW,9160) QEFEAP(5)
         WRITE(IW,9170) ENEL
         WRITE(IW,9100)
         WRITE(IW,9180) TOTAL
         WRITE(IW,9100)
         WRITE(IW,9190) QTOTAL
      ENDIF
C
      RETURN
C
 9001 FORMAT(/1X,'TYPING ERROR IN $QMEFP  INPUT - CHECK NEAR $ MARKER'/)
 9002 FORMAT(/1X,'IF STEP1=.F., PLEASE SUPPLY THE STATIC TOTAL ENERGY,'/
     *        1X,'ELECTRON-MULTIPLE AND ELECTRON-REMAINDER ENERGIES.'/)
 9003 FORMAT(/1X,'    THIS IS A STEP1-ONLY QM/EFP ENERGY ANALYSIS.'/
     *        1X,'    INCLUDE THE $QMEFP GROUP FOUND IN THE PUNCH'/
     *        1X,'    TO RUN STEP2.'/)
 9004 FORMAT(1X,'$QMEFP STEP1=.F.'/
     *       1X,'       STOTAL=',F19.10/
     *       1X,'       EMULT =',F19.10/
     *       1X,'       EREM  =',F19.10/
     *       1X,'$END')
 9005 FORMAT(/1X,'ERROR IN $QMEFP: STEP1 AND STEP2'/
     *        1X,'CANNOT BOTH BE FALSE'/)
 9006 FORMAT(/1X,'ERROR IN RUNTYP=QMEFPEA:'/
     *        1X,'EFP MOLECULES MUST BE PRESENT'/)
 9100 FORMAT(38X,18(1H-))
 9110 FORMAT(/10X,22(1H-)/10X,22HQM/EFP ENERGY ANALYSIS/10X,22(1H-)/)
 9111 FORMAT(10X,'A. DEFUSCO, J. IVANIC, M. W. SCHMIDT, M. S. GORDON'/
     *        13X,'J. PHYS. CHEM. A, 2011, 115, 4574'/)
 9112 FORMAT(10X,'#### NOTICE: METHOD 1 POLARIZATION IN USE ###'/
     *        1X,'EFP INDUCTION = -MU(INDUCED)*(EFLD(MULT+QM) + ',
     *             '0.5*EFLD(INDUCED))'/
     *        1X,'                +0.5*MU(INDUCED)*EFLD2'/
     *        1X,'        EFLD2 = ALPHA(EFP)^-1 . MU(INDUCED)')
 9113 FORMAT(1X, 'THE RMS DEVIATION BETWEEN EFLD2 AND '/
     *       1X, '  (EFLD(MULT+QM) + EFLD(INDUCED)) IS ',1P,E9.3,0P/)
 9114 FORMAT(10X,'#### NOTICE: METHOD 2 POLARIZATION IN USE ###'/
     *       10X,'P. ARORA, L. V. SLIPCHENKO, S. P. WEBB, A. DEFUSCO,',
     *            ' M. S. GORDON'/
     *       13X,'J. PHYS. CHEM. A, 2010, 114, 6742'/)
 9120 FORMAT( 1X,'                     SOLUTE ENERGY =',F19.10/)
 9130 FORMAT( 1X,'              ELECTROSTATIC ENERGY =',F19.10)
 9140 FORMAT( 1X,'                  REMAINDER ENERGY =',F19.10)
 9150 FORMAT( 1X,'           SOLUTE INDUCTION ENERGY =',F19.10)
 9160 FORMAT( 1X,'         FRAGMENT INDUCTION ENERGY =',F19.10)
 9170 FORMAT( 1X,' FRAGMENT-FRAGMENT ELEC+REM ENERGY =',F19.10)
 9180 FORMAT( 1X,'          TOTAL INTERACTION ENERGY =',F19.10/)
 9190 FORMAT( 1X,'               QM/EFP TOTAL ENERGY =',F19.10/)
      END

C
C*MODULE EFINP     *DECK efp_turn_terms_off
C>
C>    @brief Turns certain EFP interaction terms off
C>
C>    @author Colleen Bertoni, Mike Schmidt
C>
C>    @details This stops polarization, exchange repulsion, dispersion,
C>    and/or charge transfer terms from being calculated.
C>    It also turns off various electrostatics-related terms. The
C>    original code was pulled from efinp_.
C>
C>    Colleen wrote the wrapping subroutine, and Mike (probably)
C>    wrote the contents. According to a comment in efinp_,
C>    electrostatics can't be turned off this way, but the code was
C>    left in just in case.
C>
C>    Please note that this only turns terms off if the input is
C>    true. It does nothing if the input is false.
C>
C>    @param no_electrostatics : If this is true, various
C>           electrostatics-related flags are turned off.
C>           According to the original comments, this doesn't
C>           actually turn electrostatics off, since the ffelec
C>           subroutine doesn't check these flags.
C>
C>    @param no_electro_screen : If this is true, electrostatics
C>           screening-related flags are turned off. This is
C>           automatically set to true if no_electrostatics is true.
C>
C>    @param no_polarization : If this is true, polarization is turned
C>           off.
C>
C>    @param no_polar_screen : If this is true, polarization
C>           screening-related flags are turned off. This is
C>           automatically set to true if no_polarization is true.
C>
C>    @param no_ex_repulsion : If this is true, exchange repulsion is
C>           turned off.
C>
C>    @param no_charge_transfer : If this is true, charge transfer is
C>           turned off.
C>
C>    @param no_dispersion : If this is true, dispersion is turned off.
C>
C>
      subroutine efp_turn_terms_off( no_electrostatics,
     *     no_electro_screen, no_polarization, no_polar_screen,
     *     no_ex_repulsion, no_charge_transfer, no_dispersion )
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     Parameters
      PARAMETER(MXFGPT=12000,MXFRG=1050,MXDFG=5,MXSHEF=1000,
     *     MXGEFP=4000,MXDPPT=MXFRG*MXDFG*12,MXIFRQ=12,MXAO=8192)
C     Inputs
      logical, intent(in) :: no_electrostatics,
     *     no_electro_screen, no_polarization, no_polar_screen,
     *     no_ex_repulsion, no_charge_transfer, no_dispersion
C
      CHARACTER*8 POLNAM,DPOLNAM
C     Common blocks
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NAT(MXDFG),NUM(MXDFG),NTPATM
      COMMON /EFPCT / NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CTFOK(MXAO,MXDFG),NCTMO(MXDFG),NTCTMO
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ*MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /EFPSCR/ POLAB(MXFRG),B,SCROFF,IELECS,IDISPS,NEW_POL
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
C
C    Original comment:
C
C            SWITCH OFF ANY TERMS THE USER DOESN'T WANT.
C        THE -FFELEC- ROUTINE DOESN'T PAY ATTENTION TO THE OLD
C        ELECTROSTATIC VARIABLES, SO -NOELEC- (no_electrostatics)
C        DOESN'T WORK.
C
      IF( no_electrostatics ) THEN
         IEFC=0
         IEFD=0
         IEFQ=0
         IEFO=0
         NMTTPT=0
      END IF
      IF( no_electro_screen .or. no_electrostatics ) THEN
         ICHGP=-1
         IELECS=-1
      END IF
      IF( no_polarization .or. no_electrostatics ) THEN
         IEFP=0
         NPTTPT=0
C        NDTTPT=0
      END IF
      IF( no_polar_screen .or. no_polarization
     *     .or. no_electrostatics ) THEN
         IPLSCR=-1
         NEW_POL=-1
      END IF
      IF( no_ex_repulsion ) THEN
         IREP=0
         NRTTPT=0
         NTMO=0
         NTPATM=0
      END IF
      IF( no_charge_transfer ) THEN
C        NTAO=0
         NTCTMO=0
      END IF
      IF( no_dispersion ) THEN
         IEFDP=0
         NDPTTPT=0
         IDISPS=-1
      END IF
C
      return
      end

