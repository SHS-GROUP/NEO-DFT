C*MODULE P2RDMSTART  *DECK P2RDMSTART
C> @brief This subroutine prepares the input needed for the P2RDM
C> subroutine and calls P2RDM to perform a parametric 2-RDM calculation.

C> @date February 25 2013

C> @author Christine Schwerdtfeger and David Mazziotti

C> @details This subroutine reads input from the RDMINP group and
C> prepares the parameters that will be needed to call P2RDM.
C> It also calls the integral transformation subroutine before
C> calling the P2RDM subroutine.  Finally it calls the P2RDM
C> subroutine and sends the final energy to ETOT.

C     ------------------------------
      SUBROUTINE P2RDMSTART
C     ------------------------------
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION NRNFG(10),NPFLG(10)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,DOEXCH,CLABEL,
     *        DDITRF,DOCORE,
     *        DOOOOO,DOVOOO,DOVVOO,DOVOVO,DOVVVO,DOVVVV
C
      PARAMETER (MXRT=100,MXATM=2000)
C
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,S,SZ,
     *                GRPDET,STSYM,GLIST,
     *                NFLGDM(MXRT),IWTS(MXRT),NCORSV,NCOR,NACT,NORB,
     *                NA,NB,K,KST,IROOT,IPURES,MAXW1,NITER,MAXP,NCI,
     *                IGPDET,KSTSYM,NFTGCI
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FMCOM / X(1)
      COMMON /FUNCT / E,EG(3*MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,MA,MB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IJKT,IDAF,NAV,IODA(950)
      COMMON /PCKLAB/ LABSIZ
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /SYMMOL/ GROUP,COMPLEX,IGROUP,NAXIS,ILABMO,ABEL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      COMMON /RDMOPT/ RDMTYP
C    CAS adding RDMTYP
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
     
C
      INTEGER         D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB
      LOGICAL         NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
      COMMON /TRFDMS/ D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB,
     *                NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
C
      double precision :: paramenergy
      integer :: coretemp
      DATA RDMINP/8HRDMINP   /, RNONE/8HNONE    /
      DATA CIDET/8HCIDET   /
C  CS adding NNAM defn, dimension, DATA QNAM
      PARAMETER (NNAM=5)
      DIMENSION QNAM(NNAM), KQNAM(NNAM)
      DATA QNAM/8HPARAM   ,8HECONV   ,8HNACT    ,8HNCORE   ,8HCALCD1  /
      DATA KQNAM/5,3,1,1,0/
      integer :: SymArray(1:NUM)
      character(len=3) :: SymCharValue, SymChar(1:NUM)
      logical :: CALCD1
      logical :: printD1
      character(len=4) :: PARAM
      character(len=8) :: RUNTYP
      character(len=8) :: GROUP
      character(len=3) :: PointGroup
      integer :: UnpairedElec, PairedElec
      double precision :: Nvirt, MemTot
C
C     Defaults are M 2-RDM parameterization, Multiplicity = MUL (from CONTRL group)
C     ECONV is set but can be changed in RDMINP
C     NQMT contains the total number of orbitals
C     I am still asking for the number of core orbitals

C     ----DEFAULT VALUES---
      PARAM = 'M'
      ECONV = 0.00000005
      MULT = MUL
      coretemp = NUMCOR()
      NCORE = coretemp
      NELS = MA + MB - 2*NCORE 
      NACT = NQMT - NCORE
      CALCD1 = .FALSE.
      printD1 = .FALSE.

      CALL nameio(IR,JRET,RDMINP,NNAM,QNAM,KQNAM,
     *            PARAM,ECONV,NACT,NCORE,CALCD1,0,0,0,0
     *            0,0,0,0,0,0,0,
     *            0,0,0,0,0,
     *            0,0,0,
     *    0,0,0,0,0,    0,0,0,0,0,    0,0,0,0,0,    0,0,0,0,0,
     *    0,0,0,0,0,    0,0,0,0,0,    0,0,0,0,0,    0,0,0,0,0)
C     If JRET = 2, something went wrong in reading the RDMINP group!
      if(JRET.eq.2) then 
        write(*,*) 'There was an error in the $RDMINP group near the X.'
        CALL ABRT
      end if

C      Determine the point group symmetry from GROUP and NAXIS
      if(NAXIS.eq.0) then 
        if(GROUP.eq.'C1') then 
          PointGroup = 'C1'
        else if(GROUP.eq.'CI') then 
          PointGroup = 'CI'
        else if(GROUP.eq.'CS') then 
          PointGroup = 'CS'
        else 
          write(*,*) '************************** ' 
          write(*,*) 'Your point group is not Abelian!'
          write(*,*) 'You chose:'
          write(*,9008) GROUP, NAXIS
          write(*,*) 'Only Abelian symmetry groups'
          write(*,*) '(C1, Cs, Ci, C2, C2v, C2h D2h, D2) are accepted!'
          write(*,*) ' '
          Call ABRT
        end if
      end if
      if(NAXIS.ne.0) then 
        if((GROUP.eq.'CNV').and.(NAXIS.eq.2)) then 
          PointGroup = 'C2V'
        else if((GROUP.eq.'CN').and.(NAXIS.eq.2)) then 
          PointGroup = 'C2'
        else if((GROUP.eq.'CNH').and.(NAXIS.eq.2)) then 
          PointGroup = 'C2H'
        else if((GROUP.eq.'DNH').and.(NAXIS.eq.2)) then 
          PointGroup = 'D2H'
        else if((GROUP.eq.'DN').and.(NAXIS.eq.2)) then 
          PointGroup = 'D2'
        else 
          write(*,*) '****************************'
          write(*,*) 'Your point group is not Abelian!'
          write(*,*) 'You chose:'
          write(*,9008) GROUP, NAXIS
          write(*,*) 'Only Abelian symmetry groups' 
          write(*,*) '(C1, Cs, Ci, C2, C2v, C2h D2h, D2) are accepted!'
          write(*,*) ' ' 
          Call ABRT
        end if
      end if

C     Only print D1 if this is a single point calculation      
      if((RUNTYP.eq.'ENERGY').and.(CALCD1.eqv..TRUE.)) then 
        printD1 = .TRUE.   
      end if
      if((RUNTYP.ne.'ENERGY').and.(CALCD1.eqv..TRUE.)) then 
        printD1 = .FALSE.
        CALCD1 = .FALSE. 
        write(*,*) '  '
        write(*,*) '*** WARNING: Changing CALCD1 to FALSE ***'
        write(*,*) 'CALCD1 may only be TRUE when RUNTYP=ENERGY'
      end if

      if((RUNTYP.eq.'HESSIAN').and.(PointGroup.ne.'C1')) then
        write(*,*) '    '
        write(*,*) '************* ERROR****************'
        write(*,*) 'Please use C1 symmetry in the $DATA'
        write(*,*) 'group for Hessian calculations.'
        write(*,*) ' '
        stop
      end if

      if(coretemp.ne.NCORE) then 
        NELS = MA + MB - 2*NCORE
        NACT = NQMT - NCORE
      end if

C     Approximately calculate the amount of memory needed for this calculation
      UnpairedElec = MULT - 1
      PairedElec = NELS - UnpairedElec
      Nvirt = NACT - (PairedElec/2 + UnpairedElec)
      MemTot = NACT**4/(1024)**3 + 8*Nvirt**4/(1024)**3 +
     *             (Nvirt*(Nvirt-1)/2)**2 * 8/(1024)**3

C     If it's an open shell calculation add the beta beta block
      if(MULT.ne.1) then
        MemTot = MemTot + (Nvirt*(Nvirt-1)/2)**2 * 8/(1024)**3
      end if
      if(NWDVAR.eq.1) then
C       Convert to mwords for 64 bit computer
        MemTot = MemTot * 1.d0/0.00745d0
      end if
      if(NWDVAR.eq.2) then
C       Convert to mwords for 32 bit computer
        MemTot = MemTot * 1.d0/0.00373d0
      end if
C
C        driver for determinant based CI calculations...
C
C        ----- read input defining the full CI dimensions -----
C
C     CAS adding this
C     I want to call NAMEIO to read the $RDMINP group from here.
C     I have nameio calling to get NACT,NELS,MULT

C
C        ----- integral transformation -----
C
C     CAS  I still need to call the integral transformation!
      DDITRF=GOPARR
      DOOOOO=.TRUE.
      DOVOOO=.FALSE.
      DOVVOO=.FALSE.
      DOVOVO=.FALSE.
      DOVVVO=.FALSE.
      DOVVVV=.FALSE.
      DOCORE=.TRUE.
      DOEXCH=SCFTYP.EQ.RNONE
      NCOR = NCORE
      NORB = NACT + NCORE

      NPFLG(2) = 0
      CALL TRFMCX(NPFLG(2),NCOR,NORB,NORB,.FALSE.,DOEXCH,
     *            DDITRF,DOOOOO,DOVOOO,DOVVOO,DOVOVO,
     *            DOVVVO,DOVVVV,DOCORE)
C     Integrals are printed to file at this point.  I will start the 
C     parametric 2-RDM calculation!
C
C     I need to use NUM (number of cartesian basis functions)
C     in this call to DAREAD!  It is in the common block
      Call DAREAD(IDAF,IODA,SymArray,NORB,324,1)
      do i=1,NACT
C     Write the symmetry to a string SymCharValue
        write(SymCharValue,9080) SymArray(i)
        SymChar(i) = SymCharValue
      end do 

      write(*,1050)
      if(MULT.eq.1) then 
        write(*,1060)
      else
        write(*,2000)
      end if
      if(PARAM.eq.'K') then
        write(*,1070)
      end if
      write(*,1080)
      write(*,1020) PARAM,NCORE,NACT,PointGroup,NELS,MULT,ECONV,CALCD1
      write(*,9009) MemTot






       Call P2RDM(PARAM,PointGroup,NACT,NELS,MULT,ECONV,
     * paramenergy,SymChar,LABSIZ,NWDVAR,printD1)
        E =  paramenergy + ETOT
        ETOT =  ETOT + paramenergy 
        write(*,1090) paramenergy,E
       CALL DAWRIT(IDAF,IODA,ENUCR,MXRT+15,2,0)
 9080 FORMAT(A3)
 9008 FORMAT(A5,I5)
 9009 FORMAT(20X/
     *       5X,'MEMORY ESTIMATE FOR P2RDM CALCULATION:',
     *           1X,F10.5,1X,'MWORDS'/
     *       20X)
 1020 FORMAT(3X,'------------------------------------------'
     *          '---------------------'/
     *       5X,'PARAMETRIC 2-RDM CALCULATION PARAMETERS',5X/
     *       3X,'------------------------------------------'
     *          '---------------------'/
     *       4X,' 2-RDM PARAMETERIZATION           ='1X,A5/
     *       4X,' NUMBER OF FROZEN CORE ORBITALS   =',I4/
     *       4X,' NUMBER OF ACTIVE ORBITALS        =',I4/
     *       4X,' POINT GROUP SYMMETRY             =',1X,A5/
     *       4X,' NUMBER OF ACTIVE ELECTRONS       =',I4/
     *       4X,' SPIN MULTIPLICITY                =',I4/
     *       4X,' SINGLE POINT ENERGY CONVERGENCE  =',F15.12/
     *       4X,' CALCULATE D1 NATURAL ORB OCC NUM =',1X,L3)
 1050 FORMAT(20X/
     *       3X,'---------------------------------------------'
     *          '------------------'/
     *       5X,'PARAMETRIC 2-RDM METHOD',20X/
     *       3X,'---------------------------------------------'
     *          '------------------'/
     *       5X,'CHRISTINE A. SCHWERDTFEGER',10X/
     *       5X,'DAVID A. MAZZIOTTI',15X/
     *       5X,'THE UNIVERSITY OF CHICAGO',10X)
 1060 FORMAT(3X,'---------------------------------------------'
     *          '------------------'/
     *      5X,'REFERENCES FOR CITATION',15X/
     *      5X,'D. A. MAZZIOTTI, PHYS. REV. LETT. 101, 253002 (2008).'/
     *      5X,'D. A. MAZZIOTTI, PHYS. REV. A 81, 062515 (2010).'/
     *      5X,'C. A. SCHWERDTFEGER, A. E. DEPRINCE III, AND '
     *          'D. A. MAZZIOTTI'/
     *      5X,'J. CHEM. PHYS. 134, 174102 (2011).')
 1070 FORMAT(5X,'C. KOLLMAR, J. CHEM. PHYS. 125, 084108 (2006).')
 1080 FORMAT(3X,'---------------------------------------------'
     *          '------------------'/)
 1090 FORMAT(20X/
     *       1X,'P2RDM CORRELATION ENERGY:',3X,F26.14/
     *       1X,'P2RDM TOTAL ENERGY:      ',3X,F26.14/
     *       20X)
 2000 FORMAT(3X,'---------------------------------------------'
     *          '------------------'/
     *      5X,'REFERENCES FOR CITATION',15X/
     *      5X,'D. A. MAZZIOTTI, PHYS. REV. LETT. 101, 253002 (2008).'/
     *      5X,'D. A. MAZZIOTTI, PHYS. REV. A 81, 062515 (2010).'/
     *      5X,'C. A. SCHWERDTFEGER AND D. A. MAZZIOTTI,'/
     *      5X,'J. CHEM. PHYS. 137, 034107 (2012).')

      RETURN
C
      END
