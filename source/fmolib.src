c 12 Aug 13 - DGF - finish FMO 5.0
C 21 May 13 - DGF,HN,TN - changes for FMO 5.0
C 26 Nov 12 - DGF - correct distance definition for trimers
C 31 Oct 12 - CB  - separate control over short/long range EFMO
C 12 Oct 12 - MWS - remove FTNCHEK warning
C  9 Oct 12 - SRP - extend EFMO method
C 13 SEP 12 - SRP - Minor EFMO changes.
C  2 Sep 12 - MWS - synchronize MCINP
C 22 Aug 12 - HN  - remove core electron bug for FMO-TDDFT with MCP
C 31 Jul 12 - DGF,CHC - last changes for FMO 4.3
C 24 Jul 12 - DGF,HN,CHC - code update to finish FMO 4.3
C 21 JUN 12 - DGF - changes for FMO 4.3
C  9 APR 12 - FZ  - PAD THE INFOTD COMMON FOR TPA
C 23 Mar 12 - DGF,CHC - code update to finish FMO 4.2 
C  7 Mar 12 - MWS - align DETWFN common
C 17 Feb 12 - LBR - updated DETWFN common block
C 28 DEC 11 - DGF,TN - changes for FMO 4.2
c xx xxx 11 - JJL - synch args to EOMINP
C 15 Apr 11 - DGF,TN - misc changes for FMO 4.1
C 11 Aug 10 - DGF,TN - changes for FMO 4.0 
C 14 Oct 09 - DGF - changes for FMO 3.3
C 22 May 09 - MWS - synchronize DFGRID and INFOTD common
C 12 Jan 09 - DGF - additional changes for FMO 3.2
C 15 Dec 08 - DGF,TN,MC - various changes for FMO 3.2 release
C 23 Oct 08 - MWS - MAKMOL: always call SPDTR and SYMORB
C 11 Apr 08 - MWS - synchronize INFOTD common
C 28 Aug 07 - DGF - small printing changes
C 20 Aug 07 - DGF - various changes for FMO 3.1 release
C 20 Aug 07 - TN  - changes to allow use of MCP
C 20 Aug 07 - MC  - add FMO-TDDFT arguments
C 22 Dec 06 - DGF - various changes for FMO 3.0 release
C  6 Nov 06 - MWS - adjust wavefunction and GDDI common block
C 22 Feb 06 - TN  - MAKMOL: read $EFRAG for EFP/FMO model
C 14 Nov 05 - DGF - various changes for FMO 2.1 release
C 19 Sep 05 - MWS - add true nuclear charge array to INFOA common
C  5 Jul 05 - MWS - SELECT NEW ATOM,BASIS,EFP,PCM,DAF DIMENSIONS
C  1 Jun 05 - DGF - fixes for the 2nd release
c 15 mar 05 - dgf - major changes for the second release
C 13 feb 05 - mws - pad common block nshel
C  5 Feb 05 - mws - pad common FMORUN and common MCINP
C 23 Jul 04 - MWS - FMOINP: frgnam is D.P., not character type
c 19 May 04 - DGF,KK - implement Fragment Molecular Orbital (FMO) method
c
C*MODULE fmolib  *DECK makemol
      SUBROUTINE makemol(ifg,jfg,kfg,ilayer,itask,nat0,nshell0,ngau0,ne0
     *                  ,ich0,mul0,runqm)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      logical runqm
      COMMON /FMCOM / X(1)
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
c
      call makmol(ifg,jfg,kfg,ilayer,itask,nat0,nshell0,ngau0,ne0,ich0,
     *            mul0,runqm,x(lichfg),x(lmulfg),x(lfrgnam),x(liaglob),
     *            x(liatfrg),x(lindfrg),x(lindgfrg),x(lnatfrg),
     *            x(lnat0frg),x(lianfrg),x(lzanfrg),x(lcfrg),x(llibish),
     *            x(llibnsh),x(llibng),x(lizbas),x(lloctat),x(liaoglob),
     *            x(lscffrg),x(lfmoscf))
c
      return
      end
C*MODULE fmolib  *DECK makmol
      SUBROUTINE makmol(ifg,jfg,kfg,ilayer0,itask,nat0,nshell0,ngau0,ne0
     *                 ,ich0,mul0,runqm,ichfg,mulfg,frgnam,iaglob,iatfrg
     *                ,indfrg,indgfrg,natfrg,nat0frg,ianfrg,zanfrg,cfrg,
     *                  libish,libnsh,libng,izbas,loctat,iaoglob,scffrg,
     *                  fmoscf)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      logical GOPARR,DSKWRK,MASWRK,isgddi,parout,INITGDDI,some,mptest,
     *        runqm,totprop,urohf,wasgddi
      character*8 ATOMNM,frgnam(*),c8dum
      character*4 atomnm4
      Parameter (MXATM=2000,MXSH=5000,MXGTOT=20000,MXAO=8192,MXRT=100,
     *           UNITS=0.52917724924D+00,MAXNZ=137,MAXL=5,MaxLay=5,
     *           MXSFMO=MaxLay*40,MXGFMO=MaxLay*100,MXAFMO=MaxLay*10)
      dimension ichfg(*),mulfg(*),iaglob(*),iatfrg(*),indfrg(*),
     *          indgfrg(*),natfrg(*),nat0frg(*),ianfrg(*),zanfrg(*),
     *          cfrg(3,*),libish(MAXNZ,maxbas,*),libnsh(MAXNZ,maxbas,*),
     *          libng(MAXNZ,maxbas,*),izbas(*),loctat(*),iaoglob(*),
     *          scffrg(*),fmoscf(*),INTYP(MXSH),NS(MXATM),KS(MXATM)
      COMMON /BASSPH/ QMTTOL,ISPHER
      COMMON /CORE  / CORE(107)
      COMMON /DMPING/ SHIFTO,SHIFTV,DMPCUT,SWDIIS,DIRTHR
      COMMON /EFPFMO/ RUNEFP,REFFMO,REPNUCEFP,IEFPFMO,ISWENUC,EFPEFP
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FMCOM / X(1)
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MCPFMO/ IMCPFMO,LFZCOR,LIFMPTYP,LIFMPTYP2,LMCPSW,
     *                LIZCOR2,imp0,jmp0,icorsh0,igtf0
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),ch(mxgtot),ci(mxgtot),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SOOPT / NOSO
c     COMMON /SYMBLK/ NIRRED,NSALC,NSALC2,NSALC3,NSAFMO
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
c     common /fmolat/ untang(3),untorg(3),respbc(4),abclat(3),anglat(3),
c    *                symtra(3,24),symope(3,3,24),iatorg,nsymop,maxklms,
c    *                ioporg(3),iopdir(3),iopabc(3),iopang(3)
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo
      common /fmoshl/ fzan(MXAFMO),fEX(MXGFMO),fC(MXGFMO,MAXL),
     *                LSTART(MXSFMO),LATOM(MXSFMO),LTYPE(MXSFMO),
     *                LNG(MXSFMO),LMIN(MXSFMO),LMAX(MXSFMO),llay(MXAFMO)
     *               ,lmptyp(mxafmo),lzcore(mxafmo),lshell,natl,numl
      equivalence (ATOMNM,FATOMNM)
      data blank/8H        /,none/4HNONE/,rnone/8HNONE    /,
     *     RMC/8HMCSCF   /,rohf/8HROHF    /,uhf/8HUHF     /,
     *     dbgfmo/8HDBGFMO  /,dbgme/8HMAKMOL  /,debug/8HDEBUG   /,
     *     RHF/8HRHF     /,CIS/8HCIS     /,c8dum/' '/,
     *     EOMSD,EOMSDT,CRCCL/8HEOM-CCSD,8HCR-EOM  ,8HCR-CCL  /
c
c     itask=0 make coordinates+basis set
c     itask=1 make coordinates (light version) 
c     itask=2 no change to coordinates and do basis set 
c     parstat: GroupNone
c
      some=(exetyp.eq.debug.or.exetyp.eq.dbgfmo.or.exetyp.eq.dbgme).and.
     *     maswrk
      ilayer=ilayer0
c     if(nat0.gt.0.and.ilayer.gt.1.and.nopden.gt.0) ilayer=1
c     if(ilayer.ne.ilayer0) write(6,*) 'Adjusted ilay',ilayer0,ilayer
c
      totprop=(iand(modprp,1).ne.0.or.iand(mofock,1).ne.0).and.runqm
      if(itask.eq.2) then
        IF(IMCPFMO.EQ.1) call addmcp2(iaglob,x(lIFMPTYP),x(lFZCOR))
        goto 1000
      endif
c
c     a) create atomic coordinates
c
      nat=nat0
      nati=nat0frg(ifg)
      if(jfg.eq.0) nati=natfrg(ifg)
      indi=indfrg(ifg)
c
      IF (IMCPFMO.EQ.1) CALL ADDMCP(NATI,INDI)
c
      call addfrg(nati,indi,zanfrg,cfrg,ianfrg,iatfrg,iaglob)
      nati=natfrg(ifg)
      nat0i=nat0frg(ifg)
      indgi=indgfrg(ifg)
c     first add nonghost atoms. Note that if only monomer is requested we add
c     also ghost atoms since they are never redundant.
      natj=0
      nat0j=0
      indj=1
      indgj=1
      natk=0
      nat0k=0
      indk=1
      indgk=1
      if(jfg.ne.0) then
        indj=indfrg(jfg)
        natj=natfrg(jfg)
        nat0j=nat0frg(jfg)
        indgj=indgfrg(jfg)
c
        IF (IMCPFMO.EQ.1) CALL ADDMCP(NAT0J,INDJ)
c
        call addfrg(nat0j,indj,zanfrg,cfrg,ianfrg,iatfrg,iaglob)
        if(kfg.ne.0) then
          indk=indfrg(kfg)
          natk=natfrg(kfg)
          nat0k=nat0frg(kfg)
          indgk=indgfrg(kfg)
c
          IF (IMCPFMO.EQ.1) CALL ADDMCP(NAT0K,INDK)
c
          call addfrg(nat0k,indk,zanfrg,cfrg,ianfrg,iatfrg,iaglob)
        endif
      endif
c     add ghost atoms. Some can be redundant with real atoms so one has to
c     sift through (redundant if a broken bond is inside the n-mer).
      if(nbdfg.ne.0) then 
        if(jfg.ne.0) then
        natgi=nati-nat0i
        natgj=natj-nat0j
        natgk=natk-nat0k
c       sift ghost atoms of ifg in jfg and kfg 
        if(natgi.ne.0) call addgho(natgi,zanfrg(indgi),cfrg(1,indgi),
     *     ianfrg(indgi),iatfrg(indgi),nat0j,iatfrg(indj),nat0i,nat0k,
     *     iatfrg(indk),nat0i+nat0j,iaglob,INDGI)
c       sift ghost atoms of jfg in ifg and kfg 
        if(natgj.ne.0) call addgho(natgj,zanfrg(indgj),cfrg(1,indgj),
     *     ianfrg(indgj),iatfrg(indgj),nat0i,iatfrg(indi),0,    nat0k,
     *     iatfrg(indk),nat0i+nat0j,iaglob,INDGJ)
c       sift ghost atoms of kfg in ifg and jfg 
        if(natgk.ne.0) call addgho(natgk,zanfrg(indgk),cfrg(1,indgk),
     *     ianfrg(indgk),iatfrg(indgk),nat0i,iatfrg(indi),0,    nat0j,
     *     iatfrg(indj),nat0i,      iaglob,INDGK)
        endif
c       do ibdfg=1,nbdfg
c         ibdgh(ibdfg)=0
c         iafg=indat(abs(iabdfg(ibdfg)))
c         jafg=indat(jabdfg(ibdfg))
c         if(iafg.ne.ifg.and.iafg.ne.jfg.and.iafg.ne.kfg.and.
c    *       (jafg.eq.ifg.or.jafg.eq.jfg.or.jafg.eq.kfg)) 
c    *      ibdgh(ibdfg)=iand(ialoc(natfmo+ibdfg),65535)
c       enddo
      endif
      if((some.or.iand(nprfmo,64).ne.0.and.nat0.eq.0).and.itask.eq.0) 
     *  then
        write(iw,9500) ifg,jfg,kfg
        if(nat0.eq.0) then
          write(iw,9510) (ANAM(J),ZAN(J),(C(I,J)*UNITS,I=1,3),J=1,nat)
        else
          write(iw,9510) ('    ', ZAN(J),(C(I,J)*UNITS,I=1,3),J=1,nat)
        endif
      endif 
 1000 continue
c
c     b) copy basis set from the library
c
      ne=ne0
      ii=nshell0
      ish=ngau0
c     write(6,*) 'wwwsh',nshell0,ngau0
      do iat=nat0+1,nat
        izi=ian(iat)
c       get the basis set for this atom. Use the atomic number, not charge.
        ibas=izbas(iaglob(iat))
        jj=libish(izi,ibas,ilayer)
        if(jj.eq.0) then
          write(iw,9120) izi,ibas,iat,ifg,ilayer
          call abrt
        endif
        nsh=libnsh(izi,ibas,ilayer)
        ngg=libng(izi,ibas,ilayer)
        ns(iat)=nsh
        ks(iat)=ii+1
c       write(6,*) 'wwwshh',nsh,ngg,jj,izi,ibas,ilayer
c       if(abs(ian(iat)-zan(iat)).gt.1.0d-06) then
c         write(6,*) 'wwwshh1',nsh,ngg,jj,izi,ibas,ilayer
c         nsh=5
c         ngg=14
c         write(6,*) 'wwwshh2',nsh,ngg,jj,izi,ibas,ilayer
c       endif 
        if(ii+nsh.gt.MXSH) then
          if(maswrk) write(iw,*) 'Increase MXSH',ii+nsh,MXSH
          call abrt
        endif
        if(ish+ngg.gt.MXGTOT) then
          if(maswrk) write(iw,*) 'Increase MXGTOT',ish+ngg,MXGTOT
          call abrt
        endif
        jsh=lstart(jj)
        if(itask.ne.1) then
          do k=1,ngg
            ish=ish+1
            EX(ish)=fex(jsh) 
            CS(ish)=fC(jsh,1)
            CP(ish)=fC(jsh,2)
            CD(ish)=fC(jsh,3)
            CF(ish)=fC(jsh,4)
            CG(ish)=fC(jsh,5)
            jsh=jsh+1
          enddo
c       if(nat0.eq.0.and.abs(zan(iat)-1.0D+00).lt.1.0d-06.and.
c    *     ian(iat).ne.1) then
c       if(nat0.eq.0.and.abs(zan(iat)-ian(iat)).gt.1.0d-02.and.
c    *     zan(iat).gt.1.01D+00) then
c         if(maswrk) write(6,*) 'wwwshh1',ifg,iat,ish,ex(ish)
c         ex(ish)=1.0d+06
c         if(maswrk) write(6,*) 'wwwshh2',ifg,iat,ish,ex(ish)
c       endif 
        endif
        if(totprop) iaoff=loctat(iaglob(iat))
        do i=1,nsh
          ii=ii+1
          kATOM(ii) =iat
          kTYPE(ii) =lTYPE(jj)
          kNG(ii)   =lNG(jj)
          if(ii.eq.1) then
            kstart(ii)=1
            kloc(ii)=1
          else
            kSTART(ii)=kstart(ii-1)+kng(ii-1)
            kloc(ii)=kloc(ii-1)+(kmax(ii-1)-kmin(ii-1)+1)
          endif
          kMIN(ii)  =lMIN(jj)
          kMAX(ii)  =lMAX(jj)
          intyp(ii)=kTYPE(ii)
          if(kTYPE(1).eq.1.and.kMIN(ii).eq.1.and.kMAX(ii).eq.4) 
     *      intyp(ii)=8
          jj=jj+1
          if(totprop) then
c           This code for building AOi map is not very safe if basis set
c           storage changes. In particular, it is assumed here that all 
c           shells for each atom are grouped together.
            iaomin=kloc(ii)
            iaomax=iaomin+kMAX(ii)-kMIN(ii)
            do iao=iaomin,iaomax
              iaoglob(iao)=iaoff
              iaoff=iaoff+1
            enddo
          endif
        enddo
        atomnm4='X '
        imode=ian(iat)
        if(imode.ne.0) call zsymnum(c8dum,atomnm4,imode)
c       write(UNIT=ATOMNM,FMT='(A2,I6)') atomnm4,iat
        write(UNIT=ATOMNM,FMT='(A4,A4)') atomnm4,'    '
        anam(iat)=FATOMNM
        bnam(iat)=BLANK
c       what is BNAM??
c       nei=ian(iat)
        izan=int(zan(iat)+0.5D+00)
        iian=ian(iat)
        nei=izan
c       compensate for double counting of charges of broken bonds.
        nei=izan
        if(izan.ne.iian) then
          if(izan.eq.1) then
c           nei=nei-1 
          else
c           nei=nei+1 
          endif
        endif
        if(MPCTYP.ne.NONE.and.imode.ne.0) nei=INT(CORE(imode))
        ne=ne+nei
      enddo
      nshell=ii
      num=kloc(ii)+kmax(ii)-kmin(ii)
      nqmt=num
      ich=ich0+ichfg(ifg)
      mul=1
c     if(scftyp.ne.rhf) then
      if(fmoscf(ilayer).ne.rhf) then
        mul=mulfg(ifg)
c       change multiplicity only for non-RHF (at present really only MCSCF). 
c       in case of RHF one can ask for CI of other multiplicities while
c       getting the orbitals from RHF for singlets. In this case CI
c       multiplicities will be taken from mulfg.
        if(mul0.ne.0) then
c          Allow at most one non-singlet
           if(mul0.ne.1.and.mul.ne.1) then
             if(maswrk) write(iw,9110) 'ESP',mul,mul0,ifg,jfg
             call abrt
           endif
           mul=max(mul,mul0)
        endif
      endif
      if(jfg.ne.0) then
        ich=ich+ichfg(jfg)
        if(fmoscf(ilayer).ne.rhf) then
c       if(scftyp.ne.rhf) then
          mulj=mulfg(jfg)
c         Allow at most one non-singlet
          if(mul.ne.1.and.mulj.ne.1) then
            if(maswrk) write(iw,9110) 'dim',mul,mul0,ifg,jfg
            call abrt
          endif
          mul=max(mul,mulj)
        endif
      endif
      if(kfg.ne.0) then
        ich=ich+ichfg(kfg)
        if(fmoscf(ilayer).ne.rhf) then
c       if(scftyp.ne.rhf) then
          mulk=mulfg(kfg)
c         Allow at most one non-singlet
          if(mul.ne.1.and.mulk.ne.1) then
            if(maswrk) write(iw,9110) 'trim',mul,mul0,ifg,jfg,kfg
            call abrt
          endif
          mul=max(mul,mulk)
        endif
      endif
      ngau=ish
      if(itask.eq.2) ich=ich0
      if(itask.eq.2) mul=1 
c
      NE = NE-ICH
      NA=(NE+MUL-1)/2
      NB=(NE-MUL+1)/2
c
c     The check below is stolen from ATOMS.
c 
      IF(NA+NB .NE. NE) THEN
         IF (MASWRK) WRITE(IW,9290) ifg,NE,ICH,MUL
         if(iand(nprfmo,16).eq.0) CALL ABRT
      END IF
C           IMPOSSIBLY HIGH, LOW, OR MISMATCHED TO E- COUNT
      IDUM=MUL+NE
      IF(MUL.GT.NE+1 .OR. MUL.LT.0 .OR. 2*INT(IDUM/2).EQ.IDUM) THEN
        IF (MASWRK) WRITE(IW,9280) ifg,mul,ne
        if(iand(nprfmo,16).eq.0) CALL ABRT
      END IF
c
      MPCSAV = MPCTYP
      MPCTYP = NONE
c     ENUCR  = ENUC(NAT,ZAN,C)
      MPCTYP = MPCSAV
      CALL SETLAB(1,atomnm4)
C
      IF (IMCPFMO.EQ.1.and.(itask.ne.1.and.ifmostp.ge.1.or.
     *                      itask.eq.2.and.ifmostp.eq.-1)) THEN
c       if (maswrk) write (6,'(6A8)') 'anam ', (anam(i),i=1,nat)
c       if(itask.eq.2) call abrt
        CALL MMPCOR(NAT0)
      end if
      urohf=.false.
      do lfg=1,nfg 
        if(scffrg(lfg).EQ.UHF.OR.scffrg(lfg).EQ.ROHF) urohf=.true.
      enddo
C
cnb5  This should be adjusted for MCQDPT.
c     MP2inp sets up some variables so we have to call it with every new
c     fragment. ONly call MP2inp when external monomers are not around.
      MPTEST=.FALSE.
      if(itask.ne.1.and.(icurfg.eq.0.or.ifmostp.eq.1.and.nbsse.eq.3)
     *   .and.ifmostp.ne.6) then
        if(urohf) then
          swdiisv=swdiis
          CALL SCFIN
          swdiis=swdiisv
        endif
        if(mplevl.ne.0) call MP2INP(mptest)
        IF(CCTYP.NE.RNONE) CALL CCINP
        IF(CCTYP.EQ.EOMSD.OR.CCTYP.EQ.EOMSDT.OR.CCTYP.EQ.CRCCL) 
     *    CALL EOMINP(SCFTYP,CCTYP)
        IF(SCFTYP.EQ.RMC) CALL MCIN
        IF(CITYP.EQ.CIS) CALL CISINP
        IF(TDDFTYP.NE.RNONE) CALL TDDINP
        IF(IEFPFMO.NE.0) CALL EFPFMOIO(1) 
      endif
      ENUCR  = ENUC(NAT,ZAN,C)
c     if(itask.ne.1.and..not.dirscf.and..not.dirtrf) call mod2ei
      if(itask.ne.1) call mod2ei
c
c     finally, fill in symmetry (force C1).
c
c     nt=1
c     t(1)=one
c     invt(1)=1
c
c     ispher=1 means QMTSYM must eliminate extra functions. 
c     With RHF we try to save time by not getting the Q-matrix but
c     MCSCF apparently needs one even for C1.
c
      if(itask.ne.1.and.some) then
         if(jfg.eq.0) then
           write(iw,9010) frgnam(ifg),ifg,mygroup
         else if(kfg.eq.0) then
           write(iw,9020) frgnam(ifg),frgnam(jfg),ifg,jfg,mygroup
         else
           write(iw,9030) frgnam(ifg),frgnam(jfg),frgnam(kfg),ifg,jfg,
     *                    kfg,mygroup
         endif
         write(iw,9000) nshell,num,ne,ich,mul,na,nb,nat,enucr
         call intr
      endif
c     icoord is not known
c     IF(runqm.and.ICOORD.NE.4) THEN
      IF(runqm) THEN
         if(iand(nfmopal,2).ne.0.and.maswrk.and.nprint.ne.-5.and.
     *      (ifmostp.ne.1.or.mod(nguess,2).eq.1.or.nbsse.eq.3))
     *     call mockhead(ilayer,ifg,jfg,kfg,icurit,intyp,ns,ks)
c        jrest=irest
         if(irest.gt.1) irest=0
c        if SCF does not converge IREST is set to 2. This prevents further
c        monomers/dimers from running by not saving SPDTR matrices
c        SPDTR matrices are used to rotate orbital coefficients 
c        if(nbdfg.ne.0.or.ispher.ge.0.or.SCFTYP.eq.rmc.or.maxklms.ne.0
c    *      .or.itask.eq.2) CALL SPDTR
         CALL SPDTR
         if(ispher.lt.0) noso=1
         if(scftyp.eq.rmc) noso=0
c        if(ispher.ge.0.or.scftyp.eq.rmc.or.itask.eq.2) CALL SYMORB
         CALL SYMORB
c        if(maswrk.and.(ifmostp.eq.2.or.ifmostp.eq.4.or.ifmostp.eq.9))
c    *     write(iw,9600) nsalc
c        SYMORB is needed to set up symmetry labels, which are 
c        surreptitiously used in various places, such as the integral 
c        transformation.
      END IF
c     if(totprop) write(6,*) 'wwwiaglob',(iaoglob(i),i=1,num)
      if(nat0.lt.0) then
      ind=200
      WRITE(6,*) 'DBG EX',(EX(I),I=1,IND),'CS',(CS(I),I=1,IND),'CP',
     *           (CP(I),I=1,IND),'CD',(CD(I),I=1,IND),
     *           'KATOM',(KATOM(I),I=1,IND),
     *           'KTYPE',(KTYPE(I),I=1,IND)
      endif
c     write(6,*) 'wwwian',(ian(i),i=1,nat)
c     write(6,*) 'wwwzan',(zan(i),i=1,nat)
      return
 9010 format(/1x,'Monomer fragment ',A8,'(',I3,') is done by the group',
     *           I3/)
 9020 format(/1x,'Dimer fragment ',2A9,'(',2I3,') is done by the group',
     *           I3/)
 9030 format(/1x,'Trimer fragment ',3A9,'(',3I3,') is done by the group'
     *          ,I3/)
 9000 format(/1X,'TOTAL NUMBER OF BASIS SET SHELLS             =',I5/
     *        1X,'NUMBER OF CARTESIAN GAUSSIAN BASIS FUNCTIONS =',I5/
     *        1X,'NUMBER OF ELECTRONS                          =',I5/
     *        1X,'CHARGE OF MOLECULE                           =',I5/
     *        1X,'SPIN MULTIPLICITY                            =',I5/
     *        1X,'NUMBER OF OCCUPIED ORBITALS (ALPHA)          =',I5/
     *        1X,'NUMBER OF OCCUPIED ORBITALS (BETA )          =',I5/
     *        1X,'TOTAL NUMBER OF ATOMS                        =',I5/
     *        1x,'THE NUCLEAR REPULSION ENERGY IS',F20.10)
 9110 format(/1x,'Check multiplicities, at most one nonsinglet allowed:'
     ,          ,A3,1x,2I2,2I4/)
 9120 format(/1x,'Basis set not found for iz=',I4,', ibas=',i3,', iat=',
     *           I6,', ifg=',I5,', ilay=',i2,'.',/)
 9280 FORMAT(/1X,'Impossible spin multiplicity',I3,' with',I6,
     *           ' electrons for fragment',I6,/)
 9290 FORMAT(/1X,'Fragment',I6,':',I6,' electrons, charge',I3,
     *           ', multiplicity',I3,' - impossible!',/)
c6666 format(100(F10.5,3F17.10,/))
 9500 FORMAT(2X,'                         '/
     *       2X,51(1H-),/,
     *       2X,'CURRENT N-MER COORDINATES, I=',I5,' J=',I5,' K=',I5,/
     *       2X,51(1H-))
 9510 FORMAT(30000(1X,A4,F3.1,3F15.10,/))
c9600 FORMAT(1x,'A   =',I5)
      end
c
C*MODULE fmolib  *DECK makesbs
      SUBROUTINE makesbs(ij,ifg,zsave,nesav,indat,iaglob)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      Parameter (MXATM=2000,zero=0.0D+00)
      logical mptest
      dimension zsave(*),indat(*),iaglob(*)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      data rnone/8HNONE    /,RMC/8HMCSCF   /,CIS/8HCIS     /
c
c     prepare basis sets and other info for BSSE corrections.
c     zero out charges for BSSE ghost atoms.
c     this subroutines is called twice, 
c     ij=1 : zero out charges for fragment J (must be called before ij=2)
c     ij=2 : zero out charges for fragment I 
c
      if(ij.eq.1) then
         call dcopy(nat,zan,1,zsave,1)
         nesav=ne
      else
         call dcopy(nat,zsave,1,zan,1)
         ne=nesav
      endif
c
cnb5  adjust border charges
cnb5  adjust multiplicity 
c
      nei=0
      do i=1,nat
        if(indat(iaglob(i)).ne.ifg) then
           nei=nei+int(zan(i)+0.5D+00)
           zan(i)=zero
        endif
      enddo
      NE = ne - nei
      NA = (NE+MUL-1)/2
      NB = (NE-MUL+1)/2
c
c     initialise correlation runs (under construction!). 
c
      MPTEST=.FALSE.
      if(mplevl.ne.0) call MP2INP(mptest)
      IF(CCTYP.NE.RNONE) CALL CCINP
      IF(SCFTYP.EQ.RMC) CALL MCIN
      IF(CITYP.EQ.CIS) CALL CISINP
      IF(TDDFTYP.NE.RNONE) CALL TDDINP
c
      RETURN
      END
C*MODULE fmolib  *DECK projgues
C>
C>     @brief initial guess projection
C>
C>     @details project HOP for initial orbitals.
C>
C>     @author Dmitri Fedorov
C>
      SUBROUTINE projgues(l1,l2,vv,wrk1,wrk2,wrk3)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      dimension vv(*),wrk1(l1),wrk2(l1*l1),wrk3(l2) 
      PARAMETER (MXSH=5000,MXGTOT=20000)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),ch(mxgtot),ci(mxgtot),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /FMCOM / X(1)
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
c
c
c     Project out cut bond LMOs. This is useful in making initial guess for
c     dimers using monomer orbitals.
c
c     do nothing if not exchanging orbitals
c
      if(mod(modorb,2).eq.0) return
c
c     l3=l1*l1
c     CALL DAREAD(IDAF,IODA,vv,L3,15,0)
      CALL VALFM(LOADFM)
      lss=LOADFM+1
      ldd=lss+l1*l1
      lrotlcao=ldd+(maxcbs*maxcbs+maxcbs)/2
      last=lrotlcao+maxcbs*maxcao
      lq=lss
      lscr=lss
      NEED = LAST- LOADFM -1
      CALL GETFM(NEED)
      CALL DAread(IDAF,IODA,wrk3,L2,12,0)
      call fmohop(l1,l2,vv,wrk3,x(lss),x(lq),x(ldd),x(lscr),wrk2,wrk1,
     *            x(liabdfg),x(ljabdfg),x(lidxCAO),x(liaglob),x(lnCBS),
     *            x(lnCAO),x(liaprjo),x(ljaprjo),x(lshiftb),x(lCoreAO),
     *            x(lfmoc),x(lrotlcao),x(llocfmo),nshell,KATOM,KTYPE,
     *            KLOC,kmin,.false.,.FALSE.,.FALSE.)
C    *            KLOC,kmin,.false.)
c     call prsq(vv,l1,l1,l1)
c     call TFTRI(wrk2,da,wrk1,x(lwrk),l1,l1,l1)
c     call dcopy(l2,wrk1,1,da,1)
      CALL RETFM(NEED)
c     CALL dawrit(IDAF,IODA,vv,L3,15,0)
      if(maswrk) write(iw,*) 'Orbitals have been projected'
      RETURN
      END
C*MODULE fmolib  *DECK madtrap
      SUBROUTINE madtrap(m,a,n,ix,b,c)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      dimension a(*),b(*),c(n,n)
c
c     C=C+A*B, where A is triangular, B is trapezoid (part of a triangular
c     matrix with linear dimension n starting at location ix) and C is square.
c     (only a block of C that has size m*n is updated by addition)
c
      if(m.eq.0.or.n.eq.0.or.m+ix-1.gt.n) then
        write(6,*) 'bad indices',m,n,m+ix
        return
      endif
      do i=1,m
        ic=ix+i-1
        do j=1,n
          sum=0.0D+00
          do k=1,m
            ia=max(i,k)
            ia2=(ia*ia-ia)/2
            ib=ix+k-1
            ib2=max(ib,j)
            sum=sum+a(ia2+min(i,k))*b((ib2*ib2-ib2)/2+min(ib,j))
          enddo
          c(ic,j)=c(ic,j)+sum
        enddo
      enddo
      RETURN
      END
C*MODULE fmolib  *DECK fmoatfrg
      SUBROUTINE fmoatfrg(iat0,indat,indatg,iaglob,ialoc,iabdfg,jabdfg,
     *                    indbd,fmozan,fmoc,natfmob,untxyz,popmat,iats,
     *                    jats,fracv,fracesp,iatfrg,ZNUC,cx,cy,cz)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      logical iainside,jainside,smartr(2),bimer(3),doespav,DOVFMO,
     *        dommesp
      dimension indat(*),indatg(natfmo,*),iaglob(*),ialoc(*),iabdfg(*),
     *          jabdfg(*),indbd(maxabd,*),fmozan(*),fmoc(3,*),
     *          untxyz(3,natfmob,*),popmat(maxnat,nfg,2),t(3)
      Parameter (MXATM=2000, zero=0.0D+00,one=1.0D+00,half=0.5D+00)
      COMMON /FMCOM / XX(1)
      COMMON /MCPFMO/ IMCPFMO,LFZCOR,LIFMPTYP,LIFMPTYP2,LMCPSW,
     *                LIZCOR2,imp0,jmp0,icorsh0,igtf0
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmolat/ untang(3),untorg(3),respbc(4),abclat(3),anglat(3),
     *                symtra(3,24),symope(3,3,24),iatorg,nsymop,maxklms,
     *                ioporg(3),iopdir(3),iopabc(3),iopang(3)
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo
c     data bimer/3*.false./
c
      bimer(1)=.false.
      bimer(2)=.false.
      bimer(3)=.false.
c     fracv=0 
c     fracesp=0 
c     if(iand(modfmm,1024).ne.0) return
      if(iat0.gt.natfmo.and.ifmostp.le.2) then
        iat=mod(iat0-1,natfmo)+1
        iu=(iat0-1)/natfmo+1
        iatfrg=indat(iat)
        znuc=-fmozan(iat)
        cx=untxyz(1,iat,iu)
        cy=untxyz(2,iat,iu)
        cz=untxyz(3,iat,iu)
        fracv=zero
        fracesp=one
c       write(6,*) 'w',iat,iu-1,znuc,cx,cy,cz
        return
      endif
      if(maxklms.ne.0.and.ifmostp.gt.2) then
c       iu=1
        znuc=-zan(iat0)
        cx=c(1,iat0)
        cy=c(2,iat0)
        cz=c(3,iat0)
c       Only the external potential will be computed.
        fracv=zero
        fracesp=one
        if(iat0.le.nat) fracesp=zero 
        return
      endif
      doespav=iand(nguess,4096).ne.0.and.ifmostp.eq.2.and.icurit.gt.2
      ioldpop=3-icurpop 
c     if(doespav) write(6,*) 'Averaging ESP1e'
c     iu=0
c
c     Determine if atom IAT belongs to fragment 
c
      if(ifmostp.eq.2.and.iand(ixesp,4096).ne.0) then
        iatfrg=indat(iat0)
        rk=fmodist(icurfg,0,0,iatfrg)
        if(icurfg.ne.iatfrg) then
          fracv=0
          fracesp=0
          igot=0
          if(rk.eq.0) fracesp=one
          znuc=-fmozan(iat0)
          cx=fmoc(1,iat0)
          cy=fmoc(2,iat0)
          cz=fmoc(3,iat0)
          if(nbdfg.eq.0) goto 90
          do iabd=1,maxabd
            ibdfg=indbd(iabd,iat0)
            if(ibdfg.eq.0) goto 90
            ia=abs(iabdfg(ibdfg))
            ja=abs(jabdfg(ibdfg))
            iafrg=indat(ia)
            jafrg=indat(ja)
            if(iafrg.eq.icurfg.or.jafrg.eq.icurfg) then
c             this is handled below
              igot=1
              goto 90
            endif
c           ri=fmodist(icurfg,0,0,iafrg)
            rj=fmodist(icurfg,0,0,jafrg)
c           The code below may not work for multiply cut BDAs?
            if(rj.eq.0) then
              if(rk.ne.0) fracesp=fracesp-one/znuc
            else
              if(rk.eq.0) fracesp=fracesp+one/znuc
            endif
          enddo
   90     continue
          if(igot.eq.0) return
        endif 
      endif 
      if(ifmostp.ne.6) then
        iat=iat0
        IF (IMCPFMO.EQ.1) THEN
          znuc=-(fmozan(iat)-XX(LFZCOR+iat-1))
        ELSE
          znuc=-fmozan(iat)
        END IF
        cx=fmoc(1,iat)
        cy=fmoc(2,iat)
        cz=fmoc(3,iat)
        iz=1
        ifg=icurfg
        factk=one
      else
        iat=iat0+nat
        znuc=-zan(iat)
        cx=c(1,iat)
        cy=c(2,iat)
        cz=c(3,iat)
c       iat below must be global iat
        iat=iaglob(iat)
        iz=2
        ifg=ncursh
        factk=half
      endif  
C     
C     FOR VARIATIONAL FMO: regular treatment of nuclear charges
C       
c     IF (IAND(MODESP,512).NE.0) THEN
c       IF (RESPPC(1).NE.ZERO.AND.IFMOSTP.GE.2.AND.IFMOSTP.NE.6)
c    *  FACTK = HALF
c     END IF          
      DOVFMO = IAND(MODESP,512).NE.0.AND.RESPPC(1).NE.ZERO
     *         .AND.IFMOSTP.GE.1.AND.IFMOSTP.NE.6
      dommesp=iand(modfmm,4).ne.0.and.ifmostp.ne.6 .or. 
     *        iand(modfmm,1024).ne.0
      IPPCFLG = 0
C 
      jfg=jcurfg
      lfg=kcurfg
      iatfrg=indat(iat)
      smartr(1)=iand(modesp,7).eq.1.and.jfg.ne.0
      smartr(2)=iand(modesp,7).eq.2.and.jfg.ne.0
      if(smartr(1).and.nbdfg.ne.0) then
        bimer(1)=fmodist(ifg,0,0,jfg).eq.0
        if(lfg.eq.0) then
          if(bimer(1)) smartr(1)=.false.
        else
          bimer(2)=fmodist(ifg,0,0,lfg).eq.0
          bimer(3)=fmodist(jfg,0,0,lfg).eq.0
        if(bimer(1).and.(bimer(2).or.bimer(3)).or.bimer(2).and.bimer(3))
     *    smartr(1)=.false.
        endif 
      endif 
      iatsg=iaglob(iats)
      jatsg=iaglob(jats)
      iifg=indat(iatsg)
      jjfg=indat(jatsg)
c     3 -body terms do not work with BSSE.
      if(nbdfg.eq.0.or.ifmostp.eq.6) then
        fracv=zero
        fracesp=one
c       BSSE
        if(ifmostp.eq.5) then
          if(nbsse.eq.1.and.iatfrg.eq.jfg .or. nbsse.eq.2.and.
     *      iatfrg.ne.ifg.and.(iifg.eq.jfg.or.jjfg.eq.jfg)) fracesp=zero
        endif
c       decide if the point charge iat should be included into ESP (keep=1)
        if(ifmostp.ne.6) then
         if(fracesp.eq.one.and.(nbsse.ne.2.or.ifmostp.ne.5.or.iatfrg.ne.
     *  jfg).and.(iatfrg.eq.ifg.or.iatfrg.eq.jfg.or.iatfrg.eq.lfg)) then
          fracv=one
          fracesp=zero
         endif 
        endif
      else
c       this code does not support nbsse=1,2 and 3.
        if(nbsse.ne.0) then
          write(6,*) 'bad nbsse',nbsse
          call abrt
        endif
c       set values for the case atom IAT is not shared
        if(iatfrg.eq.ifg.or.iatfrg.eq.jfg.or.iatfrg.eq.lfg) then
          fracv=one
          fracesp=zero
        else
          fracv=zero
          fracesp=one
        endif
        fracesp1=zero
c       do ibdfg=1,nbdfg
c       loop over all broken bonds in which atom IAT is involved.
c       we are only interested really in one n-mer here (n=1,2), so
c       we find if an atom is split between this n-mer and the rest, then quit. 
        do iabd=1,maxabd
          ibdfg=indbd(iabd,iat)
          if(ibdfg.eq.0) goto 100
          ia=abs(iabdfg(ibdfg))
          ja=abs(jabdfg(ibdfg))
c         reordering is now done in fmobon
c         the code below assumes the canonical order (left is negative). 
c         if(ja.lt.0) then
c           if(ia.lt.0) call abrt
c           idum=ia
c           ia=ja
c           ja=idum
c         endif
c         ia=abs(ia)
          iafrg=indat(ia)
          jafrg=indat(ja)
          iainside=iafrg.eq.ifg.or.iafrg.eq.jfg.or.iafrg.eq.lfg
          jainside=jafrg.eq.ifg.or.jafrg.eq.jfg.or.jafrg.eq.lfg
c         exclude the case when a cut bond is inside a dimer
          if(iat.eq.ia.and..not.(iainside.and.jainside)) then
            if(iainside) then
              fracv=(znuc+one)/znuc
              fracesp=-one/znuc
            endif
            if(jainside) then
              fracv=-one/znuc
              fracesp=(znuc+one)/znuc
            endif
          endif
c
c           now add partial charges. 
c           Here we add the "right" side (that is, pseudoproton). 
c           The left side (N-1) is treated below, along with all other cases. 
c           
          if(iat.eq.ia.and..not.jainside.and.resppc(iz).ne.zero) then
c           kfg is equal to jafrg.
c           tricky part! kat comes from the ghost atom stored in ialoc
c           Note that this atom has coordinates equal to those of iat
c           but its charge is stored as processed below.
            kfg=ishft(ialoc(natfmo+ibdfg),-16)
            kat=iand(ialoc(natfmo+ibdfg),65535)
cnb         ifmostp.eq.6 cannot come here?!
            if(ifmostp.ne.6) then
              if(smartr(1).or.smartr(2)) then
                rk=fmosdist(iifg,jjfg,indatg(iatsg,1),indatg(jatsg,1),
     *                      ifg,jfg,lfg,kfg,bimer)
              else
                rk=fmodist(ifg,jfg,lfg,kfg)
              endif
            else
              rk=fmodist(ifg,0,0,kfg)
            endif
            if(rk.gt.resppc(iz)) then 
              if(doespav) then
                fracesp1=fracesp1+(popmat(kat,kfg,icurpop)
     *                            +popmat(kat,kfg,ioldpop))*factk/znuc/2
              else
                fracesp1=fracesp1+popmat(kat,kfg,icurpop)*factk/znuc
              endif
              IPPCFLG = 1
            endif 
c           goto 100
          endif
          if(ifmostp.eq.6.and.resppc(iz).ne.zero) then
            write(6,*) 'fmoptc is not programmed for resppc(2) yet'
            call abrt
          endif
        enddo
  100   continue
        fracesp=fracesp+fracesp1
C 
C       FOR VARIATIONAL FMO: Gao's treatment (halves both Mulliken
C                          and nuclear charges)
C 
        IF (DOVFMO) THEN
          IF (IPPCFLG.EQ.1) THEN
            FRACESP = FRACESP*HALF
            IPPCFLG = 0
          END IF
        END IF
      endif
c     Add approximate 2e ESP contributions that become atomic Mulliken charges
c     centred at the atomic coordinates (point charge approximation).
      if(resppc(iz).ne.zero) then
        IF (DOVFMO) FACTK = HALF
        ind=iat
        kfg=ishft(ialoc(ind),-16)
        kat=iand(ialoc(ind),65535)
c       check if the gun is accidently or mistakenly loaded.  
        if(kfg.eq.0) call abrt 
c         
c       for regular runs we want all charges except those from I and J. 
        if(ifmostp.ne.6.and.(ifg.eq.kfg.or.jfg.eq.kfg.or.lfg.eq.kfg)) 
     *    goto 200
c       for esdim we only want charges coming from J
c
        if(ifmostp.ne.6) then
          if(smartr(1).or.smartr(2)) then
            rk=fmosdist(iifg,jjfg,indatg(iatsg,1),indatg(jatsg,1),
     *                   ifg,jfg,lfg,kfg,bimer)
          else
            rk=fmodist(ifg,jfg,lfg,kfg)
          endif
        else
          rk=fmodist(ifg,0,0,kfg)
        endif
        if(rk.gt.resppc(iz)) then 
          if(doespav) then
            fracesp=fracesp+(popmat(kat,kfg,icurpop)
     *                      +popmat(kat,kfg,ioldpop))*factk/znuc/2
          else
            fracesp=fracesp+popmat(kat,kfg,icurpop)*factk/znuc
          endif
        endif 
  200   continue
c
c       zero out ESP charges for the overlapping atoms
        tol2=1.0D-08
        if(fracesp.eq.0.or.iand(ixesp,32768).eq.0) goto 300
        do i=1,nat 
          if((c(1,i)-cx)**2+(c(2,i)-cy)**2+(c(3,i)-cz)**2.lt.tol2) then
c           write(6,*) 'Zeroed out ESPZ',znuc,cx,cy,cz,fracesp
            fracesp=zero
            goto 300
          endif
        enddo
  300   continue 
      endif
      if(dommesp) then
c       This subroutine only changes the ESP part for MM.
        if(resppc(iz).gt.0) call abrt
        kfg=ishft(ialoc(iat),-16)
        if(kfg.ne.ifg.and.kfg.ne.jfg.and.kfg.ne.lfg) then
          call mmdist(ifg,jfg,lfg,kfg,t,radius,ty2z,ratio,mmdim)
          if(mmdim.ne.0) fracesp=0
c         write(6,*) 'wwwaaz',iat,kfg,mmdim
          if(nbdfg.ne.0) then
            do iabd=1,maxabd
              ibdfg=indbd(iabd,iat)
              if(ibdfg.eq.0) goto 400
c             Process only BDAs here.
              ja=abs(jabdfg(ibdfg))
              jafrg=indat(ja)
              if(iat.eq.ia) then
c               This code does not support more than one bond per atom.
                if(iabd.gt.1) call abrt
c         
                call mmdist(ifg,jfg,lfg,jafrg,t,radius,ty2z,ratio,mmdim)
                if(mmdim.eq.0) then
                  if(fracesp.eq.0) fracesp=-one/znuc
                else
                  if(fracesp.ne.0) fracesp=(znuc+one)/znuc
                endif
              endif
            enddo
  400       continue 
          endif
        endif
c       write(6,*) 'wwwZ',iat,fracv,fracesp
      endif
c
      RETURN
      END
C*MODULE fmolib  *DECK DMTX2
      SUBROUTINE DMTX2(D,V,M,N,NDIM,MB)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION D(*),V(NDIM,M)
C
      PARAMETER (ZERO=0.0D+00,two=2.0D+00)
c
      IJ = 0
      DO 120 I = 1,N
         DO 110 J = 1,I
            IJ = IJ + 1
            DUM = ZERO
c           DO 100 K = 1,M
            DO 100 K = 1,MB
               DUM = DUM+V(I,K)*V(J,K)
  100       CONTINUE
            dum = two*DUM
            DO 200 K = MB+1,M
               DUM = DUM+V(I,K)*V(J,K)
  200       CONTINUE
            D(IJ) = DUM
  110    CONTINUE
  120 CONTINUE
      RETURN
      END
c
C     *MODULE fmolib  *DECK indsort
      subroutine indsort(n,ia,ind)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      integer ia(n),ind(n)
c
c     Find element indices corresponding to decreasing order in array IA.
c     example: input  IA=10,20,15,25,12
c              output IND=4,2,3,5,1
c     IA is not destroyed on exit.
c     This subroutine was provided by T. Ikegami (AIST).
c
      do i = 1, n
         ind(i) = i
      end do
c
C     Make heap
C      
      do j = (n + 1) / 2, 1, -1
         jj = j
         i = ind(jj)
 10      k = jj * 2
         if (k.le.n) then
            if ( k.ne.n .and. ia(ind(k)).gt.ia(ind(k+1)) ) k = k+1
            if ( ia(i).le.ia(ind(k)) ) goto 20
            ind(jj) = ind(k)
            jj = k
            goto 10
         end if
 20      ind(jj) = i
      end do
      
C     Do sort -- ind(1) is the index to the minimum here.
C
      do m = n-1, 1, -1
         i = ind(m + 1)
         ind(m + 1) = ind(1)
         jj = 1
 30      k = jj * 2
         if (k.le.m) then
            if (k.ne.m .and. ia(ind(k)).gt.ia(ind(k+1))) k = k+1
            if ( ia(i).le.ia(ind(k)) ) goto 40
            ind(jj) = ind(k)
            jj = k
            goto 30
         end if
 40      ind(jj) = i
      end do
      end
C*MODULE fmolib  *DECK tribrk
      subroutine tribrk(ind,is,i,j)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter (half=0.5D+00,tiny=1.0D-06)
c
c     break combined triangular index into two linear indices.
c     that is, find such i and j so that
c     ind=i*(i+is)/2+j 
c     input: ind,is (is is either +1 or -1, ind must define positive i,j)
c     output: i'=i+1,j
c     note: for triangular matrices normally is=-1.
c     Nota bene: i is produced raised by one, that is, the subroutine is suited
c     really for is=-1, assuming the diagonal is not stored.
c 
      i=int(-is*half+sqrt(half*is*is+2*ind)+tiny)
      j=ind-(i*i+is*i)/2
      if(j.eq.0) then
         i=i-1
         j=i
      endif
      i=i+1
c     
      return
      end
c
C*MODULE fmolib  *DECK cubbrk
      subroutine cubbrk(ind,is,i,j,k)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter (one=1.0D+00,three=3.0D+00,tiny=1.0D-06)
c
c     break combined pyramidal index into three linear indices.
c     that is, find such i,j and k so that
c     ind=(i-1)(i-2)(i-3)/6+j(j+1)/2+k
c     input: ind
c     output: i,j,k
c     note: at present only is=-1 is suported.
c     the equation below is obtained by analytically solving a cubic equation
c     (hint: Mathematica can do it algebraically).
c
c     if(is.ne.-1) call abrt
      a=ind*162.0D+00
      d=((a+sqrt(a*a-108.0D+00))/2.0D+00)**(one/three)
      i=int(one+one/d+d/three+tiny)
      indij=ind-(i*(i-1)*(i-2))/6
      if(indij.ne.0) then
        i=i+1
      else
        indij=indij+((i-1)*(i-2))/2
      endif  
      call tribrk(indij,is,j,k)
      return
      end
c
C*MODULE fmolib  *DECK fillind
C>
C>    @brief Setting up FMO runs
C>
C>    @details Fill in some index arrays and dimension variables.
C>
C>    @author Dmitri Fedorov
C>
C>    @date 10/5/12 - Spencer Pruitt
C>    - Saving NBSFN and NMXMO for EFMO fragments
C>
C>    @param NMXMO : Number of MOs for the fragment
C>
C>    @param NBSFN : Number of basis functions for the fragment
C>
      subroutine fillind(nfg2,nfg3,loadhf,numfrg,iwrk,loadm,loadd,loadt,
     *                   maxl30,layfrg,indat,indatg,iabdfg,jabdfg,mulfg,
     *                   scffrg,ichfg,NQMTFG,ichfmo,nefmo,mulfmo,l0fmo,
     *                   l1fmo,m1fmo,orbxch,enexch,docas,loadbf,loadgr,
     *                   nstjob,semidyn,spargrid,noffg,indgrd,vdwrad,
     *                   grdpad,nxyzg,maxg,itdfrg,nocctdm,nvirtdm,
     *                   mixlbas,maxnath,some)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      Parameter (MXATM=2000,MXFRG=1050,MXDFG=5,MXDPPT=MXFRG*MXDFG*12)
      logical GOPARR,DSKWRK,MASWRK,orbxch,enexch,docas,semidyn,spargrid,
     *        some
      dimension numfrg(*),iwrk(*),loadm(*),loadd(*),loadt(*),maxl30(*),
     *          layfrg(*),indat(*),indatg(natfmo,*),iabdfg(*),jabdfg(*),
     *          mulfg(*),scffrg(*),ichfg(*),loadbf(*),loadgr(*),
     *          nstjob(*),noffg(*),indgrd(6,*),vdwrad(*),maxg(3),
     *          NQMTFG(*)
c     COMMON /BASSPH/ QMTTOL,ISPHER
      COMMON /ECP2  / CLP(400),ZLP(400),NLP(400),KFRST(MXATM,6),
     *                KLAST(MXATM,6),LMAXE(MXATM),LPSKIP(MXATM),
     *                IZCORE(MXATM)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2
      data RMC/8HMCSCF   /,UHF,ROHF/8HUHF     ,8HROHF     /
c
c     Fill in some index arrays and dimension variables.
c
c     smart load balancing is based on layer one. It seems to be true that
c     it does not depend on layer anyway.
c     Next "trick" is to assume that load of a dimer is equal to the sum
c     of two monomer loads. This is not quite true if two monomers overlap
c     but should give very good idea of the dimer load. 
c
      maxl1=0
      maxnat=0
      maxnath=0
      l1fmo=0
      nefmo=0
      call viclr(maxl30,1,nfg)
      CALL VICLR(NQMTFG,1,NFG)
      if(nbdfg.ne.0) call viclr(indatg,1,natfmo*maxabd)
      call viclr(maxg,1,3)
      ioff=1
      mixlbas=0
      do ilay=1,nlayer
        do 100 ifg=1,nfg
          if(layfrg(ifg).lt.ilay) goto 100
          iifg=ifg
          iilay=ilay
          call makemol(iifg,0,0,iilay,1,0,0,0,0,0,0,.false.)
C
C  SRP: SAVING NBSFN AND NMXMO FOR FRAGMENT IN EFMO
C
          NBSFN(IFG)=NUM
          NMXMO(IFG)=NA
c
          maxl1=max(maxl1,num)
          maxnat=max(maxnat,nat)
          nath=0
          ncore=0
          do iat=1,nat
            if(ian(iat).ne.1) nath=nath+1
            ncore=ncore+izcore(iat)
c           It seems that MCP does not remove core electrons
c           with this way of constructing fragments.
          enddo
          maxnath=max(maxnath,nath)
          if(ilay.gt.1.and.num.ne.maxl30(ifg)) mixlbas=1
          if(num.gt.maxl30(ifg)) maxl30(ifg)=num
          if(ilay.eq.1) numfrg(ifg)=num
          if(layfrg(ifg).eq.ilay) then
            l1fmo=l1fmo+num
            nefmo=nefmo+ne
            if(ifg.eq.itdfrg) then
              nocctdm=na-ncore/2
              nvirtdm=nqmt-nocctdm
            endif
          endif
          NQMTFG(IFG) = NQMT + ISHFT(NA,16)
          if(spargrid) then
            call grdbox(indgrd(1,ifg),indgrd(2,ifg),indgrd(3,ifg),
     *                  indgrd(4,ifg),indgrd(5,ifg),indgrd(6,ifg),
     *                  vdwrad,grdpad) 
            noffg(ifg)=ioff
            ioff=ioff+(indgrd(2,ifg)-indgrd(1,ifg)+1)*
     *                (indgrd(4,ifg)-indgrd(3,ifg)+1)*
     *                (indgrd(6,ifg)-indgrd(5,ifg)+1)
            maxg(1)=max(maxg(1),indgrd(2,ifg)-indgrd(1,ifg)+1)
            maxg(2)=max(maxg(2),indgrd(4,ifg)-indgrd(3,ifg)+1)
            maxg(3)=max(maxg(3),indgrd(6,ifg)-indgrd(5,ifg)+1)
          endif
  100   continue
      enddo
      nxyzg=ioff-1
      if(loadhf.eq.1) then
        if(nbody.gt.1) then
          ishift=maxl1*2
          iloop=0
          do ifg=1,nfg 
            l1i=numfrg(ifg)
            do jfg=1,ifg-1 
              iloop=iloop+1
              l1j=numfrg(jfg)
              iwrk(iloop)=l1i+l1j
              if(scffrg(ifg).eq.rmc.or.scffrg(jfg).eq.rmc)
     *          iwrk(iloop)=iwrk(iloop)+ishift
c             semidynamic jobs should be placed before all other extensions,
c             such as correlation, use the largest shift.
              if(semidyn.and.loadbf(2).ne.0.and.loadgr(2).ne.0.and.
     *           l1i+l1j.ge.loadbf(2)) then
                iwrk(iloop)=iwrk(iloop)+ishift*2
                nstjob(2)=nstjob(2)+1
              endif 
            enddo
          enddo
          call indsort(nfg2,iwrk,loadd)
c         numfrg and iwrk are destroyed after indsort
c         loadd is overwritten later in inidfmo if approximations are used.
        endif
        if(nfg3.ne.0) then
          iloop=0
          do ifg=1,nfg
            l1i=numfrg(ifg)
            do jfg=1,ifg-1
              l1ij=l1i+numfrg(jfg)
              do kfg=1,jfg-1
                iloop=iloop+1
                iwrk(iloop)=l1ij+numfrg(kfg)
              enddo
            enddo
          enddo
          call indsort(nfg3,iwrk,loadt)
        endif
        do ifg=1,nfg
          iwrk(ifg)=numfrg(ifg)
c         Load balancing of monomers ignores layer information, and
c         it basically looks at the highest level only. 
          if(scffrg(ifg).eq.rmc.or.ifg.eq.itdfrg) 
     *       iwrk(ifg)=iwrk(ifg)+maxl1
c         semidynamic jobs should be placed before all other extensions,
c         such as correlation.
          if(semidyn.and.loadbf(1).ne.0.and.loadgr(1).ne.0.and.
     *       numfrg(ifg).ge.loadbf(1)) then
            iwrk(ifg)=iwrk(ifg)+maxl1*2
            nstjob(1)=nstjob(1)+1
          endif 
        enddo
c       call indsort(nfg,numfrg,loadm)
        call indsort(nfg,iwrk,loadm)
        if(some) then
          write(iw,*) 'loadm',(loadm(i),i=1,nfg)
          if(nbody.gt.1) write(iw,*) 'loadd',(loadd(i),i=1,nfg2)
          if(nfg3.ne.0) write(iw,*) 'loadt',(loadt(i),i=1,nfg3)
        endif
      endif
      if(some) write(iw,*) 'maxl30',(maxl30(i),i=1,nfg)
c
      mulfmo=1
      ichfmo=0
      docas=.false.
      do ifg=1,nfg
c       fill in max record size
        imxl30=maxl30(ifg)
        mmxl30=(imxl30*imxl30+imxl30)/2
        if(scffrg(ifg).eq.rmc) then
          docas=.true.
          mmxl30=mmxl30+imxl30*imxl30 
        else
          if(orbxch) mmxl30=imxl30*imxl30
        endif
        if(enexch) mmxl30=mmxl30+imxl30
        if(scffrg(ifg).eq.rohf.or.scffrg(ifg).eq.uhf) 
     *    mmxl30=mmxl30+mmxl30 
c       Double record size to save alpha and beta density
        maxl30(ifg)=mmxl30
        ichfmo=ichfmo+ichfg(ifg)
        if(mulfg(ifg).ne.1) then
          if(mulfmo.ne.1) then
c           if(maswrk) write(iw,*) 'Multiple non-singlets (mulfg)'
            call abrt
          else
            mulfmo=mulfg(ifg)
          endif
        endif
      enddo
c
c     Subtract L1 for double counted bond-fraction joints.
c
      l1bd=0
      l0bd=0
      do ibdfg=1,nbdfg
        ia=abs(iabdfg(ibdfg))
        ja=abs(jabdfg(ibdfg))
        ifg=indat(ia)
        jfg=indat(ja)
        ilay=min(layfrg(ifg),layfrg(jfg))
c       ibdtyp=idxcao(ibdfg,ilay)
c       nao=nCBS(ibdtyp)
c       l1bd=l1bd+nao
c       l0bd=l0bd+nao-nsphel(ia,ilay)
c       write(6,*) 'wwwl00',ibdtyp,nao,ia,ilay,nsphel(ia,ilay)
        call nbasat(ia,ilay,il0,il1)
        l0bd=l0bd+il0
        l1bd=l1bd+il1
c 
c       fill in the ghost fragment array. The left end atom belongs also
c       to the right end fragment as a ghost atom.
c       Find the first empty slot.
c
        do i=maxabd,1,-1
          if(indatg(ia,i).ne.0) then
            next=i+1
            goto 200
          endif
        enddo
        next=1
  200   continue  
        if(next.gt.maxabd) then
          if(maswrk) write(iw,*) 'Increase maxabd',maxabd 
          call abrt
        endif
        indatg(ia,next)=jfg
      enddo
c
      m1fmo=l1fmo
      l0fmo=l1fmo-l0bd
      l1fmo=l1fmo-l1bd
c     l0fmo is not yet finalised. spherical contaminants for each fragment
c     will be subtracted in inidfmo. Here we subtract doubly counted spherical 
c     contaminants from fractioned bonds. 
c
c     do i=1,maxabd
c       if(nbdfg.ne.0) write(6,*) (indatg(j,i),j=1,natfmo)
c     enddo 
c
c     Set charge transfer options.
c
c     do ifg=1,nfg
c       if(iand(nprfrg(ifg),8).ne.0)  ifgdon=ifg
c       if(iand(nprfrg(ifg),16).ne.0) ifgacc=ifg
c     enddo
c
      return
      end
C*MODULE fmolib  *DECK filloc
      subroutine filloc
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXSH=5000,MXGTOT=20000)
      COMMON /FMCOM / X(1)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),ch(mxgtot),ci(mxgtot),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
c
c     fill in locfmo array and do nothing else in FMOHOP.
c     (note that this option is passed through IRSTSTP and IFMOSTP).
c     dummy arguments are passed as x and 0.
c
      call fmohop(0,0,x,x,x,x,x,x,x,x,x(liabdfg),x(ljabdfg),x(lidxCAO),
     *            x(liaglob),x,x,x,x,x,x,x,x,x(llocfmo),
     *            NSHELL,KATOM,KTYPE,KLOC,kmin,.false.,.FALSE.,.FALSE.)
C    *            NSHELL,KATOM,KTYPE,KLOC,kmin,.false.)
c
      return
      end
c
C*MODULE fmolib  *DECK readcas
      subroutine readcas(nactfmo,ncasfmo)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXNORO=250)
      logical CANONC,FCORE,FORS,EKT,LINSER
      DOUBLE PRECISION METHOD
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWORD,NORB,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /SCFOPT/ CONVHF,MAXIT,MCONV,NPUNCH,npreo(4)
      DATA DETWRD,DRTWRD,GENWRD/8HDET     ,8HDRT     ,8HGEN     /
      DATA GUGA,ALDET,GENCI/8HGUGA    ,8HALDET   ,8HGENCI   /
c
c     Read CAS input. Preserve the SCF value of MAXIT.
c
      MAXITsav=MAXIT
      call mcin
      IF(CISTEP.EQ.ALDET) CALL DETINP(NPFLG(1),DETWRD)
      IF(CISTEP.EQ.GUGA)  CALL DRTGEN(NPFLG(1),DRTWRD)
      IF(CISTEP.EQ.GENCI) CALL GCIINP(NPFLG(1),GENWRD)
      call fmonad(nactfmo,ncasfmo)
      MAXIT=MAXITsav
c     write(6,*) 'wwwmaxit',MAXITsav,MAXIT
c
      return
      end
c
C*MODULE fmolib  *DECK fmoord
      subroutine fmoord(v,e,iodexch,jodexch,kodexch,mapi,mapj,mapk,
     *                  enexch,l1,nai,naj,nak,iwrk1,iwrk2) 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      logical iodexch,jodexch,kodexch,enexch
      dimension v(l1,*),e(l1),mapi(*),mapj(*),mapk(*),iwrk1(l1),
     *          iwrk2(l1)
c
c     reorder orbitals and energies for CAS dimers/trimers.
c     iwrk2 is also used as wrk2(l1), i.e. as real array.
c     for dimers nak is zero.
c
c     call viclr(iwrk1,1,l1)
      do i=1,l1
        iwrk1(i)=0
        iwrk2(i)=i
      enddo
c     newe order 
c     first reorder I orbitals
      ind=0
      if(iodexch) ind=naj+nak
      do i=1,l1
        ii=mapi(i)
        if(ii.gt.0) then
          if(ii.le.nai) then
c           active/core
            ind=ind+1
            iwrk1(ind)=i
c         else
c           indv=indv+1
c           iwrk1(indv)=i
c         i MO is used, so throw it away from the index list.
            iwrk2(i)=0
          endif
        endif
      enddo
c     now reorder J orbitals (core or CAS)
      ind=0
      if(nak.ne.0.and..not.iodexch) ind=nai
      if(jodexch) ind=nai+nak
      do i=1,l1
        jj=mapj(i)
        if(jj.gt.0) then
          if(jj.le.naj) then
            ind=ind+1
            if(iwrk1(ind).ne.0) then
              write(6,*) 'Overlapping orbital indices',i,iwrk1(ind)
              call abrt
            endif
            iwrk1(ind)=i
c           i MO is used, so throw it away from the index list.
            iwrk2(i)=0
          endif
        endif
      enddo
      if(nak.ne.0) then
      ind=0
      if(iodexch) ind=naj
      if(jodexch) ind=nai
      if(kodexch) ind=nai+naj
      do i=1,l1
        kk=mapk(i)
        if(kk.gt.0) then
          if(kk.le.nak) then
            ind=ind+1
            if(iwrk1(ind).ne.0) then
              write(6,*) 'Overlapping orbital indices',i,iwrk1(ind)
              call abrt
            endif
            iwrk1(ind)=i
c           i MO is used, so throw it away from the index list.
            iwrk2(i)=0
          endif
        endif
      enddo
      endif
c     write(6,*) 'Neue Ordnung',(iwrk1(i),i=1,l1)
c     write(6,*) 'Newe Ordnung',(iwrk2(i),i=1,l1)
c     fill in virtual indices.
c     note: projected out orbitals (due to cut bonds) with lunatic energies 
c     are not systematically got rid of here. This should present no problem 
c     as one should do a dimer SCF. If one does not do that there may be a 
c     problem.
      ind=0
      do i=1,l1
        if(iwrk1(i).eq.0) then
  100     continue
          ind=ind+1
          if(iwrk2(ind).eq.0.and.ind.lt.l1) goto 100
          if(ind.eq.l1.and.i.ne.l1) call abrt
c         ran out of virtual indices?
          iwrk1(i)=ind
        endif
      enddo
c     loose ends should match
      if(ind.ne.l1) then
        write(6,*) 'Collapsed reordering',nai,naj,ind
        call abrt
      endif
c     write(6,*) 'Neue Ordnung',(iwrk1(i),i=1,l1)
      if(enexch) CALL ICOPY(L1,iwrk1,1,IWRK2,1)
      CALL REORDR(V,IWRK1,L1,L1)
      if(enexch) CALL REORDR(E,IWRK2,L1,1)
      return
      end
C*MODULE fmolib  *DECK fmonad
      subroutine fmonad(nam,nan)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      logical CANONC,FCORE,FORS,EKT,LINSER
      PARAMETER (MXRT=100, MXNORO=250, MXATM=2000)
      DOUBLE PRECISION METHOD
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWORD,NORB,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,SDET,SZDET,
     *                GRPDET,STSYM,GLIST,DWPARM,
     *                NFLGDM(MXRT),IWTS(MXRT),NCORSV,NCOR,NACT,NORBDT,
     *                NADET,NBDET,KDET,KSTDET,IROOT,IPURES,MAXW1,NITDET,
     *                MAXP,NCIDET,IGPDET,KSTSYM,NFTGCI,IDWEIGH
      COMMON /GUGWFN/ NFZC,NMCC,NDOC,NAOS,NBOS,NALP,NVAL,NEXT,NFZV,
     *                IFORS,IEXCIT,ICICI,NOIRR
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
c     COMMON /ORBSET/ NORBMX,NORBS,NCORBS,NLEVS,NA,NB,NC,NSYM,MSYM,
c    *                IDOCC,IVAL,IMCC,ISYM(MXAO),ICODE(MXAO),
c    *                NLCS(MXAO),LEVPT(MXAO),LEVNR(MXAO),
c    *                IOUT(MXAO),NREFS,IEXCT,NFOCI,INTACT
      data GUGA/8HGUGA    /
c
c     adjust the number of orbitals in CAS,
c     return the number of CAS active and core+active orbitals.
c
      if(cistep.eq.guga) then
        nan=NDOC+NAOS+NBOS+NALP+NVAL
        nam=NFZC+NMCC+nan
      else
        nan=NACT
        nam=NCORSV+NACT
      endif
      norb=nqmt
      return
      end
C*MODULE fmolib  *DECK fmoconv
      subroutine fmoconv(modcon0,iconfg,l1,vec,enexch,orbxch,some,tryalt
     *                  ,forcedir)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      logical FOCAS,SOSCF,DROPC,JACOBI,CANONC,FCORE,FORS,EKT,LINSER
     *       ,QUD,veritas(0:1),some,enexch,orbxch,RSOSCF,rVSHIFT,tryalt,
     *        DIRSCF,FDIFF,forcedir
      dimension vec(*) 
      DOUBLE PRECISION METHOD
      PARAMETER (MXNORO=250)
      COMMON /CASOPT/ CASHFT,CASDII,NRMCAS,FOCAS,SOSCF,DROPC
      COMMON /DMPING/ SHIFTO,SHIFTV,DMPCUT,SWDIIS,DIRTHR
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /JACOBI/ JACOBI,NJAOR,ELAST,ISTAT
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWORD,NORB,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /QUDMC / QUDTHR,QUD
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SCFOPT/ CONVHF,MAXIT,MCONV,NPUNCH,npreo(4)
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
      data veritas/.false.,.true./
      DATA debug/8HDEBUG   / 
c     DATA RMC/8HMCSCF   /,GVB/8HGVB     /
c
c     Set a converger for each step in FMO. Go ahead and set all SCF types.
c     Write fake initial orbitals for SOSCF (SOSCF does not need them,
c     it really needs just the density but it reads the orbitals as well).
c     tryalt: try alternative converger (that is, flip DIIS <-> SOSCF). 
c
c     SCF:
c     IF(EXTRAP) MCDEF=MCDEF+1
c     IF(DAMPH)  MCDEF=MCDEF+2
c     IF(VSHIFT) MCDEF=MCDEF+4
c     IF(RSTRCT) MCDEF=MCDEF+8
c     IF(DIIS)   MCDEF=MCDEF+16
c     IF(DEM)    MCDEF=MCDEF+32
c     IF(SOSCF)  MCDEF=MCDEF+64
c     IF(LOCOPT) MCDEF=MCDEF+128
c
c     MCSCF:
c     IF(FOCAS)  MCDEF=MCDEF+1024
c     IF(SOSCF)  MCDEF=MCDEF+2048
c     IF(DROPC)  MCDEF=MCDEF+4096
c     IF(CANONC) MCDEF=MCDEF+8192
c     IF(FCORE)  MCDEF=MCDEF+16384
c     IF(FORS)   MCDEF=MCDEF+32768
c     IF(NOCI)   MCDEF=MCDEF+65536  ! dead option: see FINALCI
c     IF(EKT)    MCDEF=MCDEF+131072
c     IF(LINSER) MCDEF=MCDEF+262144
c     IF(JACOBI) MCDEF=MCDEF+524288
c     IF(QUD)    MCDEF=MCDEF+1048576
c
      if(modcon0.eq.-1) then
c       store the SCF defaults
        modcon0=MCONV 
        if(fdiff.and.dirscf) modcon0=logor(modcon0,256)
        if(dirscf) modcon0=logor(modcon0,512)
c       write(6,*) 'wwwaaa',modcon,dirscf
c       MCSCF options are not read in yet
      else
        modcon=modcon0
        if(iconfg.ge.0) modcon=iconfg
        MCONV=mod(modcon,1024) 
        if(tryalt) MCONV=logxor(MCONV,16+64)
c       write(6,*) 'wwwbbb',modcon,dirscf
c       write(6,*) 'new conv',MCONV
c       modcon is a global setting for all fragments.
c       iconfg is a local setting for a given fragment.
c
c       if(maswrk) write(6,*) 'Defaults',FOCAS,SOSCF,DROPC,CANONC,FCORE,
c    *                         FORS,EKT,LINSER,JACOBI,QUD
        if(modcon.ge.1024) then
c       if less use defaults given in $MCSCF, otherwise set as told
c       note that $SCF is read in only once, whereas $MCSCF is reread for
c       each energy run, allowing not to store the default values.          
          FOCAS= veritas(mod(modcon/1024,2))
          SOSCF= veritas(mod(modcon/2048,2))
          DROPC= veritas(mod(modcon/4096,2))
          CANONC=veritas(mod(modcon/8192,2))
          FCORE= veritas(mod(modcon/16384,2))
          FORS=  veritas(mod(modcon/32768,2))
          EKT=   veritas(mod(modcon/131072,2))
          LINSER=veritas(mod(modcon/262144,2))
          JACOBI=veritas(mod(modcon/524288,2))
          QUD=   veritas(mod(modcon/1048576,2))
          if(some) write(iw,*)'Reset to',FOCAS,SOSCF,DROPC,CANONC,FCORE
     *                         ,FORS,EKT,LINSER,JACOBI,QUD
c       else
c         SOSCF= veritas(mod(mconv/64,2))
        endif
        if(tryalt) SOSCF=.not.SOSCF
c       invert SOSCF for the alternative converger option
        rSOSCF= veritas(mod(mconv/64,2))
        rVSHIFT=veritas(mod(mconv/4,2))
c       if((rSOSCF.or.rVSHIFT.or.swdiis.ne.0).and..not.orbxch) then
        if((rSOSCF.or.rVSHIFT.or.swdiis.ne.0.or.exetyp.eq.debug)
     *     .and..not.orbxch) then
c         write fake initial orbitals (unit matrix) to fool SOSCF that
c         always tries to read them in. In order for this to work we must 
c         also force the first iteration to be DIIS. 
c         In some cases we should not write these dummy orbitals, e.g.
c         when doing DFT as then orbitals are essential.
          call RUNITV(l1,l1,vec)
c         call vnan(vec,1,l1*l1)
          l3=l1*l1
          CALL dawrit(IDAF,IODA,vec,l3,15,0)
c         also write fake orbital energies, that happen to be 1,0,0,...
        endif
c       if((rSOSCF.or.swdiis.ne.0).and..not.enexch) then
        if((rSOSCF.or.swdiis.ne.0.or.iand(nguess,1024).ne.0).and.
     *     .not.enexch) then
          call vclr(vec,1,l1)
c         call vnan(vec,1,l1)
          CALL dawrit(IDAF,IODA,vec,l1,17,0)
        endif 
        DIRSCF=iand(mconv,512).ne.0
        FDIFF=iand(mconv,256).ne.0
        if(forcedir.and.iconfg.lt.0) then
c         Do not overwrire fragment specific settings with forcedir
c         alter FDIFF only if the user has not requested DIRSCF.
          if(.not.DIRSCF) FDIFF=forcedir
          DIRSCF=forcedir
        endif
      endif
      return
      end
C*MODULE fmolib  *DECK fmorvec
      subroutine fmorvec(ifg,jfg,ijvec,naos,nmos,vec,igot)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension ijvec(2,*),vec(naos,naos)
      CHARACTER*8 cvec
      LOGICAL GOPARR,DSKWRK,MASWRK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2
      equivalence (cvec,vecnam)
c
c     read vectors provided by the user. igot will be set to 1 if
c     orbitals were available and 0 otherwise.
c
      igot=0
      do i=1,maxvec
        if(ifg.eq.ijvec(1,i).and.jfg.eq.ijvec(2,i)) then
          WRITE(UNIT=cvec(1:8),FMT='(A5,I1)') ' $VEC',i
          call TRNRDM(IR,IW,VECNAM,naos,NMOS,VEC)
          CALL dawrit(IDAF,IODA,vec,naos*NMOS,15,0)
          if(NMOS.lt.naos) call vclr(vec(1,NMOS+1),1,naos*(naos-NMOS))
          if(maswrk) then
            if(jfg.eq.0) write(iw,*) 'Read input MOs for monomer',ifg
            if(jfg.ne.0) write(iw,*) 'Read input MOs for dimer',ifg,jfg
          endif
          igot=1
          return
        endif
      enddo
      return
      end
C*MODULE fmolib  *DECK fmosdir
      subroutine fmosdir(imode,fmodscf,fmodtrf)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      logical DIRSCF,DIRTRF,FDIFF,fmodscf,fmodtrf
c
c     GAMESS behaves in a bizarre way when it comes to DIRSCF and DIRTRF
c     being set differently. We want DIRSCF to be used only for RHF and
c     DIRTRF only for MCSCF and no other weird stuff.
c     imode=0: save DIRSCF and DIRTRF to fmodscf,fmodtrf; set DIRSCF,DIRTRF
c     imode=1: restore DIRSCF,DIRTRF from fmodscf,fmodtrf
c
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /TRFOPT/ CUTTRF,NWDTRF,MPTRAN,ITRFAO,NOSYMT,IPURTF,DIRTRF
c
      if(imode.eq.0) then
        fmodscf=DIRSCF
        fmodtrf=DIRTRF
c       if(scftyp.eq.RHF) DIRTRF=.false.
c       the other case (MCSCF) is harmless
      else
        DIRSCF=fmodscf
        DIRTRF=fmodtrf
      endif
      return
      end
C*MODULE fmolib  *DECK fmodor
      subroutine fmodor(enexch,VECold,vecnew,ss,ee,wrk,iwrk1,iwrk2,nact,
     *                  L1,l2,L3)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      logical enexch
      PARAMETER (ZERO=0.0D+00)
      dimension vecold(l1,l1),vecnew(l1,l1),ee(l1),ss(l2),wrk(l1),
     *          iwrk1(l1),iwrk2(l1)
c
c     find nact orbitals in vecnew having maximum overlap with VECold
c     and reorder vecnew to have the same order as VECold.
c     leave remaining orbitals unchanged
c
      call daread(IDAF,IODA,ss,L2,12,0) 
      call daread(IDAF,IODA,vecnew,L3,15,0)
c     write(6,*) 'wwwmy old'
c     call prsq(vecold,l1,l1,l1)
c     write(6,*) 'wwwmy new'
c     call prsq(vecnew,l1,l1,l1)
      call viclr(iwrk1,1,l1)
      call viclr(iwrk2,1,l1)
      ovbig=0.5D+00
      do i=1,nact 
        ii=0
        ovmax=zero
        call MTARBR(ss,l1,vecold(1,i),1,wrk,l1,1)
        do 100 j=1,l1
c         skip orbitals that were already used
          if(iwrk2(j).ne.0) goto 100
          over=abs(ddot(l1,vecnew(1,j),1,wrk,1))
          if(over.gt.ovmax) then
            ii=j
            ovmax=over 
          endif
          if(over.gt.ovbig) goto 200
  100   continue
  200   continue
c       iwrk1 keeps new orbital order. iwrk2 keeps track of used orbitals.
        iwrk1(i)=ii
        iwrk2(ii)=i
        write(6,*) 'Orbital',i,' has overlap',ovmax,' with',ii
      enddo
c     fill in remaining orbitals
      ind=nact
      do j=1,l1
        if(iwrk2(j).eq.0) then
          ind=ind+1
          iwrk1(ind)=j
        endif
      enddo 
c     write(6,*) 'Neue Ordnung',(iwrk1(i),i=1,l1)
      if(enexch) call daread(IDAF,IODA,ee,L1,17,0) 
      if(enexch) CALL ICOPY(L1,iwrk1,1,IWRK2,1)
      CALL REORDR(vecnew,IWRK1,L1,L1)
      if(enexch) CALL REORDR(Ee,IWRK2,L1,1)
      if(enexch) call dawrit(IDAF,IODA,ee,L1,17,0) 
      call dawrit(IDAF,IODA,vecnew,L3,15,0) 
      return
      end
C*MODULE fmolib  *DECK matchcas
      subroutine matchcas(enexch,VECold,vecnew,ss,ee,wrk,iwrk1,iwrk2,m1,
     *                    nact,L1,l2,L3)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      logical enexch
      PARAMETER (ZERO=0.0D+00)
      dimension vecold(l1,l1),vecnew(l1,l1),ee(l1),ss(l2),wrk(l1),
     *          iwrk1(l1),iwrk2(l1)
c
c     similar to FMODOR (q.v.), but it first finds active orbitals and then
c     fills in the core.
c     M1 is the number of core+CAS active space (NACT) orbitals
c
      call daread(IDAF,IODA,ss,L2,12,0) 
      call daread(IDAF,IODA,vecnew,L3,15,0)
c     write(6,*) 'wwwmy old'
c     call prsq(vecold,l1,l1,l1)
c     write(6,*) 'wwwmy new'
c     call prsq(vecnew,l1,l1,l1)
      call viclr(iwrk1,1,l1)
      call viclr(iwrk2,1,l1)
      ovbig=0.5D+00
      do i=m1-nact+1,m1
        ii=0
        ovmax=zero
        call MTARBR(ss,l1,vecold(1,i),1,wrk,l1,1)
        do 100 j=1,l1
c         skip orbitals that were already used
          if(iwrk2(j).ne.0) goto 100
          over=abs(ddot(l1,vecnew(1,j),1,wrk,1))
          if(over.gt.ovmax) then
            ii=j
            ovmax=over 
          endif
          if(over.gt.ovbig) goto 200
  100   continue
  200   continue
c       iwrk1 keeps new orbital order. iwrk2 keeps track of used orbitals.
        iwrk1(i)=ii
        iwrk2(ii)=i
        write(6,*) 'Orbital',i,' has overlap',ovmax,' with',ii
      enddo
c     fill in core+virtual orbitals
      ind=0
      do j=1,l1
        if(iwrk2(j).eq.0) then
c         find the first empty orbital 
          do i=ind+1,l1
            ind=ind+1
            if(iwrk1(ind).eq.0) goto 500
          enddo
          write(6,*) 'CAS index could not be built',j,ind
          call abrt
  500     continue
          iwrk1(ind)=j
        endif
      enddo 
c     write(6,*) 'Neue Ordnung',(iwrk1(i),i=1,l1)
      if(enexch) call daread(IDAF,IODA,ee,L1,17,0) 
      if(enexch) CALL ICOPY(L1,iwrk1,1,IWRK2,1)
      CALL REORDR(vecnew,IWRK1,L1,L1)
      if(enexch) CALL REORDR(Ee,IWRK2,L1,1)
      if(enexch) call dawrit(IDAF,IODA,ee,L1,17,0) 
      call dawrit(IDAF,IODA,vecnew,L3,15,0) 
      return
      end
C*MODULE fmolib  *DECK fmoauto
      subroutine fmoauto(nacut,indat)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension indat(*)
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
c
c     automatic molecule partitioning
c
      do iat=1,natfmo
        indat(iat)=(iat-1)/nacut+1
      enddo
      return
      end
C*MODULE fmolib  *DECK fmodist
      function fmodist(ifg,jfg,kfg,lfg)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /FMCOM / X(1)
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
c
c     Return distance between a monomer (ifg), a dimer (ifg,jfg) or
c     a trimer (ifg,jfg,kfg) and another monomer (lfg). 
c     The choice of the n-mer is accomplished by setting extra indices to 0.
c     The distance for an n-mer is defined as min(a){Ral}, a=i,j,k.
c     The distance is stored in "waals".
c     The "diagonal" distance e.g. between ifg,ifg is not defined.
c
      if(icurunt.ne.0) then
c       For intercell lattice distances use square matrix
        if(jfg.ne.0.or.kfg.ne.0) call abrt
        mfg2=(nfg*nfg-nfg)/2
        ju=ixftch(x(lmapsu),icurunt)
        fmodist=x(lrij+mfg2+nfg*nfg*(ju-1)+(ifg-1)*nfg+lfg-1)
        return
      endif
      if(ifg.eq.lfg.or.jfg.eq.lfg.or.kfg.eq.lfg) then
c       Strictly speaking other combinations too, such as ifg and jfg,
c       but those are too unlikely by construction.
c       While mathematically it is reasonable to define R(i,i)=0 
c       it is preferred to write the program in such a way as to not
c       need it.
c       write(6,*) 'Disaster in fmodist',ifg,jfg,kfg,lfg
c       call abrt
c       Overruled by the Supreme Court!
        fmodist=0.0D+00
        return
      endif
      if(ifg.ge.lfg) then
        lrilfg=lrij+(ifg*ifg-3*ifg)/2+lfg
      else
        lrilfg=lrij+(lfg*lfg-3*lfg)/2+ifg
      endif
      rk=x(lrilfg)
      if(jfg.ne.0) then
        if(jfg.ge.lfg) then
          lrjlfg=lrij+(jfg*jfg-3*jfg)/2+lfg
        else 
          lrjlfg=lrij+(lfg*lfg-3*lfg)/2+jfg
        endif
        rk=min(rk,x(lrjlfg))
      endif
      if(kfg.ne.0) then
        if(kfg.ge.lfg) then
          lrklfg=lrij+(kfg*kfg-3*kfg)/2+lfg
        else
          lrklfg=lrij+(lfg*lfg-3*lfg)/2+kfg
        endif
        rk=min(rk,x(lrklfg))
      endif
      fmodist=rk
      return
      end
C*MODULE fmolib  *DECK fmodist3
C>
C>    @brief Compute separation in trimers. 
C>
C>    @details Compute the shortest interfragment distance in trimers.
C>
C>    @author Dmitri Fedorov
C>
      subroutine fmodist3(ifg,jfg,kfg,rmin,rmax)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /FMCOM / X(1)
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
c
c     Return inter-fragment distances for a trimer:
c     rd the distance between two closest monomers, forming a dimer,
c     rm the distance between this dimer and the remaining monomer (indm).
c     The distance is stored in "waals".
c
      if(ifg.ge.jfg) then
        lrijfg=lrij+(ifg*ifg-3*ifg)/2+jfg
      else
        lrijfg=lrij+(jfg*jfg-3*jfg)/2+ifg
      endif
      rij=x(lrijfg)
      if(ifg.ge.kfg) then
        lrikfg=lrij+(ifg*ifg-3*ifg)/2+kfg
      else
        lrikfg=lrij+(kfg*kfg-3*kfg)/2+ifg
      endif
      rik=x(lrikfg)
      if(jfg.ge.kfg) then
        lrjkfg=lrij+(jfg*jfg-3*jfg)/2+kfg
      else
        lrjkfg=lrij+(kfg*kfg-3*kfg)/2+jfg
      endif
      rjk=x(lrjkfg)
      if(rjk.le.rij.and.rjk.le.rik) then
        rmin=rjk
        rmax=min(rij,rik)
      else if(rij.le.rik.and.rij.le.rjk) then
        rmin=rij
        rmax=min(rik,rjk)
      else
        rmin=rik
        rmax=min(rij,rjk)
      endif
      return
      end
C*MODULE fmolib  *DECK monbsr
      subroutine monbsr(nat,ich,mul,num,nqmt,ne,na,nb,nshell,ngau,enucr,
     *                  nat0,ich0,mul0,num0,nqmt0,ne0,na0,nb0,
     *                  nshell0,ngau0,enucr0)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
c
c     monomer basis save / restore
c
      nat0=nat
      ich0=ich
      mul0=mul
      num0=num
      nqmt0=nqmt
      ne0=ne
      na0=na
      nb0=nb
      nshell0=nshell
      ngau0=ngau
      enucr0=enucr
c
      return
      end
C*MODULE fmolib  *DECK fmoprr
      subroutine fmoprr(indat,iabdfg,jabdfg,fmozan,fmoc,vdwr,rij,prall,
     *                  prtdst,nerr)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension indat(*),iabdfg(*),jabdfg(*),fmozan(*),fmoc(3,*),vdwr(*)
     *         ,rij(*),prtdst(4)
      logical prall
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
C
C     ----- print interfragment DISTANCES -----
C
      nerr=0
      if(nfg.eq.1) return
      if(prall) then 
        WRITE (IW,9000)
        INCR = 8
        IF(NPRINT.EQ.6) INCR=16
        do i=nfg,2,-incr
          ni=min(incr,i-1)
          write(iw,9005) (i-k,k=0,ni-1)
          do j=1,i-1
            nk=min(incr,i-j)-1
            write(iw,9010) j,(rij(((i-k)*(i-k)-3*(i-k))/2+j+1),k=0,nk)
          enddo
        enddo
        write(6,9020)
      endif
      if(prtdst(1).ne.0.or.prtdst(2).ne.0.or.prtdst(3).ge.0) then
        write(6,9100)
        loop=0 
        do i=2,nfg
          do j=1,i-1
            loop=loop+1
            rr=rij(loop)
            if(rr.lt.prtdst(2).and.rr.ne.0) then
              write(iw,9110) i,j,rr
            else if(rr.lt.prtdst(1)) then
              write(iw,9120) i,j,rr
            endif
c
c           Count fractioned bonds for a pair of fragments.
c
            ibdfg1=0
            nfract=0
            do ibdfg=1,nbdfg
              ifg=indat(abs(iabdfg(ibdfg)))
              jfg=indat(abs(jabdfg(ibdfg)))
              if(ifg.eq.i.and.jfg.eq.j.or.ifg.eq.j.and.jfg.eq.i) then
c               output cross-links if more than one is present.
                if(nfract.eq.1) write(iw,9210) i,j,nfract,ibdfg1,
     *                           abs(iabdfg(ibdfg1)),abs(jabdfg(ibdfg1))
                nfract=nfract+1
                ibdfg1=ibdfg
                if(nfract.ge.2) write(iw,9210) i,j,nfract,ibdfg,
     *                           abs(iabdfg(ibdfg)),abs(jabdfg(ibdfg))
              endif
            enddo
c
c           Check fragmentation carefully. 
c
            if(rr.le.prtdst(3).and.
     *         (nfract.eq.0.or.iand(nprfmo,16).ne.0)) then
c             In the majority of cases nfract is 1.
c             nfract>1 is a case that may be permissible sometimes.
c             E.g. two sulphur-bridged fragments or otherwise twice 
c             connected pair of fragments. 
c             nfract=0 can be a major mistake in $FMOBND.
c             There are hydrogen bonds etc that may justify nfract=0.
c             This is a suspicious fragment pair:close but no bond in $FMOBND.
c             Consider only heavy (non-H) atoms (no ghosts).
c             It may be a good idea to check hydrogens too (for steric
c             hindrances due to poor modelling) but here we only check bonds
c             that have to be but are not fractioned. 
              rijh=1.0D+30
              imin=0
              jmin=0
              do iat=1,natfmo
                ifg=indat(iat) 
                if(ifg.eq.i) then
                  ian=int(fmozan(iat)+1.0D-03)
                  if(ian.gt.1) then
                    ri=vdwr(ian)
                    xi=fmoc(1,iat)
                    yi=fmoc(2,iat)
                    zi=fmoc(3,iat)
                    do jat=1,natfmo
                      jfg=indat(jat)
                      if(jfg.eq.j) then
                        jan=int(fmozan(jat)+1.0D-03)
                        if(jan.gt.1) then
                          rj=vdwr(jan)
                          r12=sqrt((xi-fmoc(1,jat))**2+
     *                             (yi-fmoc(2,jat))**2+
     *                             (zi-fmoc(3,jat))**2)/(ri+rj)
                          if(r12.lt.rijh) then
                            rijh=r12
                            imin=iat 
                            jmin=jat 
                          endif
                          if(r12.le.prtdst(3)) then
c                         This is to sort out atoms if they can be, based on Z.
                            if(fmozan(iat).lt.fmozan(jat)) then
                              write(ip,9220) -iat,jat
                            else
                              write(ip,9220) -jat,iat
                            endif
                          endif
                        endif
                      endif
                    enddo
                  endif
                endif
              enddo
c             rijh is now the shortest distance between heavy atoms in I,J.
              if(rijh.le.prtdst(3)) then
                write(iw,9200) i,j,rr,rijh,imin,jmin
                nerr=nerr+1
              endif
c           else if(nfract.gt.1) then
c             write(iw,9210) i,j,rr,nfract
            endif
          enddo
        enddo
c       if(prtdst(3).ne.0) call timit(1)
      endif
      RETURN
 9000 FORMAT(/,10X,'INTERFRAGMENT DISTANCES',/,10X,30(1H-))
 9005 FORMAT(/1x,5x,10(I5,3x))
 9010 FORMAT(1x,I5,10F8.3)
 9020 FORMAT(1x)
 9100 FORMAT(/1x,'Close fragment pairs, distance relative to vdW',
     *           ' radii',/)
 9110 FORMAT(1x,2I6,F10.5,' very close!')
 9120 FORMAT(1x,2I6,F10.5)
 9200 FORMAT(1x,'Fragments',2I6,' are separated by',F7.3,' (all atoms)',
     *          F7.3,' (heavy only).',/1x,'Atoms',2I6,' may have to ',
     *          'have a bond between them defined in $FMOBND.',/)
 9210 FORMAT(1x,'Warning: frgs',2I6,' are cross-linked(',I2,'): bond',
     *          I6,' atoms',2I7)
 9220 FORMAT(1x,2I8)
      end
C*MODULE fmolib  *DECK setindbd
      subroutine setindbd(iabdfg,jabdfg,indbd)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension iabdfg(*),jabdfg(*),indbd(maxabd,*)
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2
c
c       fill in broken bond index for each atom (there can be several broken
c       bonds for a given atom (if none, store 0).
c
      call viclr(indbd,1,natfmo*maxabd)
      do ibdfg=1,nbdfg
        ia=abs(iabdfg(ibdfg))
        ja=abs(jabdfg(ibdfg))
        ii=1
        jj=1
        do k=1,maxabd
          if(indbd(k,ia).ne.0) ii=k+1
          if(indbd(k,ja).ne.0) jj=k+1
        enddo
        if(ii.gt.maxabd.or.jj.gt.maxabd) then
          write(6,*) 'too many abds',ii,jj,maxabd
          call abrt
        endif
        indbd(ii,ia)=ibdfg 
        indbd(jj,ja)=ibdfg
      enddo
c     write(6,6666) ((indbd(k,ia),k=1,maxabd),ia=1,natfmo)
c6666 format(1x,'indbd ',4I6)
      return
      end
C*MODULE fmolib  *DECK fmogind
      subroutine fmogind(maxi,indat,indatg)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension indat(*),indatg(*)
      logical GOPARR,DSKWRK,MASWRK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
c
c     process Gaussian-like INDAT, indicated by indat(1)=0 (therefore, skip
c     indat(1))
c
      ifg=1
      nifg=0
      natot=0
      i=1
  100 continue
        i=i+1
        if(i.ge.maxi) goto 200
        now=indat(i)
        if(now.eq.0) then
          if(ifg.eq.nfg) goto 200
          if(nifg.eq.0) then
            if(maswrk) write(iw,*) 'No atoms in fragment',ifg
            call abrt
          endif
          ifg=ifg+1
          natot=natot+nifg
          nifg=0
          goto 100
        endif
        if(indat(i+1).lt.0) then
          i=i+1
          next=abs(indat(i))
        else
          next=now
        endif
        do j=now,next
          if(j.gt.natfmo) then
            if(maswrk) write(iw,9010) i,ifg,j
            call abrt
          endif 
          nifg=nifg+1
          indatg(j)=ifg
        enddo
      goto 100
  200 continue
      natot=natot+nifg
      if(ifg.ne.nfg.or.natot.ne.natfmo) then
        if(maswrk) write(iw,9000) ifg,nfg,natot,natfmo
        call abrt
      endif
      call icopy(natfmo,indatg,1,indat,1)
      return
 9000 format(/1x,'Bad indat: nfg(indat,nfg)=',2I6,
     *           ' natfmo(indat,fmoxyz)=',2I7,
     * /1x,'Perhaps you forgot to add the final 0 at the end of indat?')
 9010 format(/1x,'Bad indat, check element',I6,', frg',i5,
     *           ' too many atoms:',I6)
      end
C*MODULE fmolib  *DECK makefg
      subroutine makefg(indat,iabdfg,jabdfg,fmozan,fmoc,ialoc,iatfrg,
     *                 indfrg,indgfrg,natfrg,nat0frg,ianfrg,zanfrg,cfrg)
c
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXSH=5000,MXATM=2000,one=1.0D+00)
      dimension indat(*),iabdfg(*),jabdfg(*),fmozan(*),fmoc(3,*),
     *          ialoc(*),iatfrg(*),indfrg(*),indgfrg(*),natfrg(*),
     *          nat0frg(*),ianfrg(*),zanfrg(*),cfrg(3,*)
      logical GOPARR,DSKWRK,MASWRK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                TT(432),INVT(48),NT
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
c
c     Prepare fragment specific data. This subroutine is not parallelised!
c
      if(maswrk) write(iw,*) 'Initialising fragments' 
      call timit(1)
c
c     first check index.
c
      do i=1,natfmo
        if(indat(i).gt.nfg.or.indat(i).le.0) then
          if(maswrk) write(6,*) 'Wrong indat:',i,indat(i),nfg
          call abrt
        endif
      enddo
c
      natfmob=natfmo+nbdfg
      ind=0
      indp=0
      do ifg=1,nfg
        indp=ind
        indfrg(ifg)=ind+1
        ifg16=ishft(ifg,16)
c       Find normal atoms that belong to fragment IFG 
        do i=1,natfmo
          if(indat(i).eq.ifg) then
            ind=ind+1
            iatfrg(ind)=i
            cfrg(1,ind)=fmoc(1,i) 
            cfrg(2,ind)=fmoc(2,i) 
            cfrg(3,ind)=fmoc(3,i) 
            zanfrg(ind)=fmozan(i)
            ianfrg(ind)=int(fmozan(i)+0.5D+00)
            ialoc(i)=ind-indp+ifg16
          endif
        enddo
        indgfrg(ifg)=ind+1
        nat0frg(ifg)=ind-indp
        if(nat0frg(ifg).eq.0) then
          write(6,*) 'Fragment',ifg,' has no atoms assigned!'
          call abrt
        endif
        do ibdfg=1,nbdfg
          ia=abs(iabdfg(ibdfg))
          ja=jabdfg(ibdfg)
c         Add ghost atoms that belong to fragment IFG 
          if(indat(ja).eq.ifg) then
            ind=ind+1
            iatfrg(ind)=ia
            cfrg(1,ind)=fmoc(1,ia)
            cfrg(2,ind)=fmoc(2,ia)
            cfrg(3,ind)=fmoc(3,ia)
            zanfrg(ind)=one
            ianfrg(ind)=int(fmozan(ia)+0.5D+00)
            ialoc(natfmo+ibdfg)=ind-indp+ifg16
          endif
c         Subtract the ghost atom charges from fragment IFG 
          if(indat(ia).eq.ifg) then
            ind1=indp+iand(ialoc(ia),65535)
            zanfrg(ind1)=zanfrg(ind1)-one
          endif
        enddo
        natfrg(ifg)=ind-indp
      enddo
      if(ind.ne.natfmob) then
        write(iw,*) 'Invalid INDAT:',ind,natfmob
        call abrt
      endif
c     create atom mapping for C1 
      do i=1,MXATM
        mapctr(i,1)=i
      enddo 
      do i=1,MXSH
        MAPSHL(i,1)=i
      enddo 
      call timit(1)
      return
      end
C*MODULE fmolib  *DECK addfrg
      subroutine addfrg(nati,indi,zanfrg,cfrg,ianfrg,iatfrg,iaglob)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=2000)
      LOGICAL GOPARR,DSKWRK,MASWRK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      dimension iaglob(*),zanfrg(*),cfrg(3,*),ianfrg(*),iatfrg(*)
c
      if(nat+nati.gt.MXATM) then
        if(maswrk) write(iw,9100) nat+nati,MXATM
        call abrt
      endif
      ii=nat+1 
      call dcopy(3*nati,cfrg(1,indi),1,c(1,ii),1)
      call dcopy(nati,zanfrg(indi),1,zan(ii),1)
      call icopy(nati,ianfrg(indi),1,ian(ii),1)
      call icopy(nati,iatfrg(indi),1,iaglob(ii),1)
      nat=nat+nati 
      return
 9100 format(/1x,'GAMESS must be recompiled with a larger MXATM',2I7/)
      end
C*MODULE fmolib  *DECK addgho
      subroutine addgho(natg,zang,cg,iang,indg,natj,indj,natjp,natk,indk
     *                 ,natkp,iaglob,INDGG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=2000)
      LOGICAL GOPARR,DSKWRK,MASWRK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /MCPFMO/ IMCPFMO,LFZCOR,LIFMPTYP,LIFMPTYP2,LMCPSW,
     *                LIZCOR2,imp0,jmp0,icorsh0,igtf0
      dimension zang(*),cg(3,*),iang(*),indg(*),indj(*),indk(*),
     *          iaglob(*)
c     
      do i=1,natg
        iat=indg(i)
        zi=zang(i)
        ifound=0
        do j=1,natj
          if(iat.eq.indj(j)) then
            ifound=j+natjp
            goto 100
          endif
        enddo
        do k=1,natk
          if(iat.eq.indk(k)) then
            ifound=k+natkp
            goto 100
          endif
        enddo
  100   continue
        if(ifound.ne.0) then
          zan(ifound)=zan(ifound)+zi
        else
          IF (IMCPFMO.EQ.1) CALL ADDMCP(1,INDGG+i-1)
          nat=nat+1
          if(nat.gt.MXATM) then
            if(maswrk) write(iw,9100) nat,MXATM
            call abrt
          endif
          zan(nat)=zi
          c(1,nat)=cg(1,i)
          c(2,nat)=cg(2,i)
          c(3,nat)=cg(3,i)
          ian(nat)=iang(i)
          iaglob(nat)=iat
        endif
      enddo
      return
 9100 format(/1x,'GAMESS must be recompiled with a larger MXATM',2I7/)
      end
C*MODULE fmolib  *DECK moldim
      subroutine moldim(molfrg,iwrk)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension molfrg(nfg),iwrk(nfg)
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
c
c     expand molfrg from compact to indexed format:
c     that is replace molfrg(1)=3,5,0 by
c     molfrg(1)=0,0,1,0,1,(0,).
c
      ires=0
      if(molfrg(1).eq.0) ires=-1 
      do ifg=1,nfg
        iwrk(ifg)=ires
      enddo
      if(ires.eq.0) then 
        do ifg=1,nfg
          mfg=molfrg(ifg)
          if(mfg.ne.0) iwrk(mfg)=1
        enddo
      endif
      call icopy(nfg,iwrk,1,molfrg,1)
      return
      end
C*MODULE fmolib  *DECK adjconv
      subroutine adjconv(iter,denmax,itol0,icut0,CONVHF0,fmajor)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      logical GOPARR,DSKWRK,MASWRK,fmajor
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /SCFOPT/ CONVHF,MAXIT,MCONV,NPUNCH,npreo(4)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
c
c     adjust convergence SCF parameters depending on monomer SCF convergence
c
      cnvmin=1.0d-04
      icutmin=6
      if(denmax.eq.0) then
c       save original convergence values
        icut0=icut
        itol0=itol
        CONVHF0=CONVHF
c       set fairly tight values
        CONVHF=1.0d-05
        icut=8
        itol=16
      else 
        if(fmajor) then
c         Force full values.
          icut=icut0
          itol=itol0
          CONVHF=CONVHF0
        else
c       determine new SCF convergence
c       Do not permit it to be ridiculous
        CONVH=min(cnvmin,denmax/cnvdmp)
c       nor go beyond the desired value
        CONVH=max(CONVH,CONVHF0) 
c       nor increase relative to previous value: otherwise weird oscillations
c       may occur.
        CONVHF=min(CONVHF,CONVH)
c       icutn=max(icutmin,int(-log10(CONVHF))+2)
        icutn=max(icutmin,icut0-int(log10(denmax/convfg)))
c       2 is some safeguard, set integral accuracy to be 100 times better 
c       than SCF
        icutn=min(icutn,icut0)
        icut=max(icut,icutn)
c       itol is more difficult to set, try twice icut.
        itol=min(icut*2,itol0)
        endif
      endif
      if(maswrk) write(iw,9000) iter,CONVHF,icut,itol
      return
 9000 format(1x,'Resetting SCF convergence for iter',I3,' to CONV=',
     *          E8.2,', ICUT=',I2,', ITOL=',I3)
      END
C*MODULE fmolib  *DECK fmolag
C>
C>     @brief FMO Lagrangian 
C>
C>     @details Calculate FMO Lagrangian. 
C>
C>     @author Dmitri Fedorov
C>
      subroutine fmolag(eps,V,wrk,L1,l2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter (one=1.0D+00,half=0.5D+00)  
      logical urohf
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /FMCOM / X(1)
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
      dimension eps(l2),v(l1,l1),wrk(l1)
      data rnone/8HNONE    /,rohf/8HROHF    /,uhf/8HUHF     /
c
c     Correct the Lagrangian subtracting diagonal ESP elements in MO basis 
c     (it looks like adding because eps has a minus in front).
c     lfmoespb is used as temporary storage L2.
c     lfmoespa contains ESP (as stored in FMOESP).
c     The Lagrangian correction is 1/2*DVD for RHF, where D=Da+Db (and Da=Db)
c                                  Da*V*Da + Db*V*Db for ROHF.
c     At present the hermiticity of D is not used.
c
      call DERCHK(NDER)
      if(NDER.eq.2) return
c       write(6,*) '1e+2e ESP in grd is',l1,na
c       call prtril(x(lfmoespa),l1)
c       write(6,*) 'orbs'
c       call prsq(v,l1,l1,l1)
c     call TFDIAG(x(lfmoespa),V,wrk,WRK1,L1,L2,l1,na)
c     The Lagrangian comes from diagonalised Fock for the ground state.
c     So, one must use the ground state density!
c     FMOLAG is called from grd1, so NDER is at least 1!
      urohf=scftyp.eq.uhf.or.scftyp.eq.rohf
      irecd=16
      iF(MPLEVL.gt.0.or.cityp.ne.rnone.or.tddftyp.ne.rnone) irecd=308
c     Only CIS stores something to rec 308?
      nloop=1
      aa=half
      iF(urohf) then
         if(mplevl.gt.0) irecd=418
         nloop=2
         aa=one
      endif 
c     Process alpha density first
      do i=1,nloop
        CALL daread(IDAF,IODA,x(lfmoespb),l2,irecd,0)
c       call prtril(x(lfmoespb),l1)
        call CPYTSQ(x(lfmoespb),V,L1,1)
        call TFTRI(x(lfmoespb),x(lfmoespa),v,WRK,l1,l1,l1)
c       call prtri(x(lfmoespb),l1)
        call daxpy(l2,aa,x(lfmoespb),1,eps,1)
c       Process beta density next
        irecd=20
        if(mplevl.gt.0) irecd=428
      enddo
      return
      END
C*MODULE fmolib  *DECK fndcntr
      SUBROUTINE fndcntr(natfmo,fmozan,fmoc,fmomas,iwhere,xc,yc,zc)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      parameter (zero=0.0D+00,one=1.0D+00)
      dimension fmozan(*),fmoc(3,*),fmomas(*),cc(3)
c
c     Find the centre of mass (iwhere=0) or charge (1); do nothing for -1.
c     At present no parallelisation. 
c
      if(iwhere.eq.0) then
        call MRARBR(fmoc,3,3,natfmo,fmomas,natfmo,1,cc,3)
        centre=ddot(natfmo,fmomas,1,one,0)
      endif
      if(iwhere.eq.1) then
        call MRARBR(fmoc,3,3,natfmo,fmozan,natfmo,1,cc,3)
        centre=ddot(natfmo,fmozan,1,one,0)
      endif
      if(iwhere.ge.0) then
        if(abs(centre).lt.1.0D-08) then
          xc=zero
          yc=zero
          zc=zero
        else
          xc=cc(1)/centre
          yc=cc(2)/centre
          zc=cc(3)/centre
        endif
      endif
c     write(6,*) iwhere,'wwwc',xc,yc,zc,centre,cc(1),cc(2),cc(3)
      RETURN
      END
C*MODULE fmolib  *DECK fmosdist
      function fmosdist(iifg0,jjfg0,iifgg,jjfgg,ifg,jfg,kfg,lfg,bimer)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter (huge=1.0D+32)
      logical bimer(3),needi,needj,needk 
      COMMON /FMCOM / X(1)
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      dimension iifgg(*),jjfgg(*)
c
c     Return distance between a monomer (ifg), a dimer (ifg,jfg) or
c     a trimer (ifg,jfg,kfg) and another monomer (lfg).
c     The choice of the n-mer is accomplished by setting extra indices to 0.
c     This subroutine defines distance as a function of iifg,jjfg that are
c     row and column fragments of the ESP Vi,j matrix, where iifg and jjfg are
c     fragments to which i and j belong. In other words, in case of a dimer
c     there are 3 blocks in the triangular matrix Vij:
c     ii block where i,j are from ifg. The distance fmosdist is then ril.
c     ij block where i,j are from ifg,jfg. The distance is then min(ril,rjl).
c     jj block where i,j are from jfg. The distance fmosdist is then rjl.
c     Note that some i (or j) may belong to more than one fragment (on the
c     cloven bonds; e.g. to both ifg and jfg). This introduces a problem
c     of ambiguity which is solved by using the "main" fragment, that is,
c     that fragment which is defined for the atom in INDAT, not those other
c     fragments, in which this atom serves as a ghost. 
c     Trouble occurs for ghost atoms: they belong (according to indat) to 
c     neither of (ifg,jfg,kfg). The solution is to use ghost index arrays
c     that contain alternative fragment IDs. 
c     fmosdist produces the same answer as fmodist only for monomers (jfg=kfg=0)
c     and in all cases fmosdist>=fmodist with the same arguments ifg,jfg,kfg,lfg
c     The distance is stored in "waals".
c
c     Note on bimer: for connected trimers, all bimers must be set to true 
c     (not just the two directly connected).
c
c     First redirect ghost atoms to one of ifg,jfg,kfg.
c
      iifg=iifg0
      jjfg=jjfg0
      if(nbdfg.ne.0) then
        if(iifg0.ne.ifg.and.iifg0.ne.jfg.and.iifg0.ne.kfg) then
c         iifg0 is a ghost atom to be redirected
          do i=1,maxabd
            iifgi=iifgg(i)
            if(iifgi.eq.0) goto 100
            if(iifgi.eq.ifg) then
              iifg=ifg
              goto 100
            endif
            if(iifgi.eq.jfg) then
              iifg=jfg
              goto 100
            endif
            if(iifgi.eq.kfg) then
              iifg=kfg
              goto 100
            endif
          enddo
  100     continue
        endif
        if(jjfg0.ne.ifg.and.jjfg0.ne.jfg.and.jjfg0.ne.kfg) then
c         jjfg0 is a ghost atom to be redirected
          do i=1,maxabd
            jjfgi=jjfgg(i)
            if(jjfgi.eq.0) goto 200
            if(jjfgi.eq.ifg) then
              jjfg=ifg
              goto 200
            endif
            if(jjfgi.eq.jfg) then
              jjfg=jfg
              goto 200
            endif
            if(jjfgi.eq.kfg) then
              jjfg=kfg
              goto 200
            endif
          enddo
  200     continue
        endif
c
c     Now force "bound fragments". This means if rij=0 then i and j become one,
c     so if i fragment is used to get distance, j is used too, irrespective of
c     what iifg and jjfg directly imply (they both can point just to i). 
c
      endif
c
c     Now do the real distance work. 
c
      fmosdist=huge 
      needi=iifg.eq.ifg.or.jjfg.eq.ifg
      needj=iifg.eq.jfg.or.jjfg.eq.jfg
      needk=iifg.eq.kfg.or.jjfg.eq.kfg
      if(needi.or.needj.and.bimer(1).or.needk.and.bimer(2)) then
        if(ifg.ge.lfg) then
          lrilfg=lrij+(ifg*ifg-3*ifg)/2+lfg
        else
          lrilfg=lrij+(lfg*lfg-3*lfg)/2+ifg
        endif
        fmosdist=x(lrilfg)
      endif
c     with sane arguments if jfg is 0 (monomer) iifg and jjfg are never zeros
      if(needj.or.needi.and.bimer(1).or.needk.and.bimer(3)) then
        if(jfg.ge.lfg) then
          lrjlfg=lrij+(jfg*jfg-3*jfg)/2+lfg
        else
          lrjlfg=lrij+(lfg*lfg-3*lfg)/2+jfg
        endif
        rjl=x(lrjlfg)
        if(fmosdist.gt.rjl) fmosdist=rjl
      endif
c     with sane arguments if kfg is 0 (1,2-mer) iifg and jjfg are never zeros
      if(needk.or.needi.and.bimer(2).or.needj.and.bimer(3)) then
        if(kfg.ge.lfg) then
          lrklfg=lrij+(kfg*kfg-3*kfg)/2+lfg
        else
          lrklfg=lrij+(lfg*lfg-3*lfg)/2+kfg
        endif
        rkl=x(lrklfg)
        if(fmosdist.gt.rkl) fmosdist=rkl
      endif
      if(fmosdist.eq.huge) call abrt
c     abort means indices (calling arguments) are out of match:
c     iifg and jjfg must be equal to some of (ifg,jfg,kfg).
c     write(6,*) '  aa',iifg0,jjfg0,iifg,jjfg
      return
      end
C*MODULE fmolib  *DECK fndchr
      function ifndchr(string,len,chr)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      character*1 string(len),chr
c
c     find chr in string and return its position (0 if not found)
c
      do i=1,len
        if(string(i).eq.chr) then
          ifndchr=i
          return
        endif
      enddo
      ifndchr=0
      RETURN
      END
C*MODULE fmolib  *DECK convlmo
      subroutine convlmo(nao,nlmo,nlmo0,in0,iaprjo,japrjo,CoreAO,libish)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (shiftb=1.0D+06,tolb=1.0D+01)
      PARAMETER (MXSH=5000,MXGTOT=20000)
      PARAMETER (MXATM=2000,MAXL=5,
     *           MAXNZ=137,MaxLay=5,
     *           MXSFMO=MaxLay*40,MXGFMO=MaxLay*100,MXAFMO=MaxLay*10)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),ch(mxgtot),ci(mxgtot),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /FMCOM / X(1)
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2
      common /fmoshl/ fzan(MXAFMO),fEX(MXGFMO),fC(MXGFMO,MAXL),
     *                LSTART(MXSFMO),LATOM(MXSFMO),LTYPE(MXSFMO),
     *                LNG(MXSFMO),LMIN(MXSFMO),LMAX(MXSFMO),llay(MXAFMO)
     *               ,lmptyp(mxafmo),lzcore(mxafmo),lshell,natl,numl
      dimension iaprjo(MaxCAO),japrjo(MaxCAO),CoreAO(MaxCBS,MaxCAO,*),
     *          nlmo0(0:1),libish(MAXNZ,maxbas,*)
c
c     convert LMOs.   
c     for now assume 1 layer, 1 basis set
c     shiftb in this subroutine may be different from FMOHOP and such.
c     It is only used to tell black from white, so any large value will do. 
c
      if(maxbas.ne.1.or.nlayer.ne.1) call abrt
c
      nao2=(nao*nao*nao)/2
      l2=(NUM*NUM+NUM)/2
      CALL VALFM(LOADFM)
      lss=LOADFM+1
      ls=lss+l2
      lsq=ls+nao2
      ld=lsq+nao*nao
      lp=ld+nao*nao
      lq=lp+nao2
      le=lq+nao*nao
      lscr=le+nao
      liwrk=lscr+nao*8
      last=liwrk+nao
      NEED = LAST- LOADFM -1
      CALL GETFM(NEED)
      CALL daread(IDAF,IODA,x(lss),l2,12,0)
c
c     Find what atom that is. For now hardwire to C.
c 
      iz=6
      ilay=1
      ibas=1
      jz=0
      do jat=1,nat
        jz=int(fzan(jat)+0.5D+00)
        jlay=mod(llay(jat),100)
        jbas=llay(jat)/100
        if(jz.eq.iz.and.ilay.eq.jlay.and.ibas.eq.jbas) goto 100
      enddo  
  100 continue
      if(jz.eq.0) then
        write(6,*) 'Bonding atom not found'
        call abrt
      endif
      ii=libish(jz,ibas,ilay)
cnb   for now use kloc since lloc is not saved
      iloc=kloc(ii)
c     copy a triangular block from the triangular matrix SS
      iloop=(iloc*iloc+iloc)/2-1
      jloop=0
      do i=1,nao
        call dcopy(i,x(lss+iloop),1,x(ls+jloop),1)
        iloop=iloop+iloc+i-1
        jloop=jloop+i
      enddo
c     write(6,*) 'wwwaha',NAT,nao,nlmo,ii,iloc
c     call prtri(x(lss),num)
c     call prtri(x(ls),nao)
c
c     Compute the Q matrix for one atom.
c     No d functions yet!
c
      call dcopy(nao2,x(ls),1,x(lp),1) 
      nao0=nao
      call QMATRX(x(lp),x(lq),x(le),x(lscr),x(lIWrk),nbo0,nao0,nao0,
     *            .false.)
      call MTARBR(x(ls),nao,x(lq),nao0,x(lsq),nao,1)
c
c     Loop over sides: 0 left, 1 right
c
      do iside=0,1
c
c       Form B=C*b*Ct
c       where C are LMO LCAO coefficients and b is the diagonal matrix of B 
c       constants.
c
        call vclr(x(ld),1,nao2)
        nmos=0
        do imo=1,nlmo
          if(iside.eq.0.and.iaprjo(imo).ne.0 .or.
     *       iside.ne.0.and.japrjo(imo).ne.0) then
            iloop=0
            do i=1,nao
              call daxpy(i,shiftb*CoreAO(i,imo,in0),CoreAO(1,imo,in0),1,
     *                   x(ld+iloop),1)
              iloop=iloop+i
            enddo
            nmos=nmos+1
          endif
        enddo
c       call prtri(x(ld),nao)
c       Form Pq=Qt * P * Q = Qt * St * B * S * Q
        call TFTRI(x(lp),x(ld),x(lsq),x(liwrk),nao0,nao,nao)
c       diagonalise Pq
        nkept=nao0-nmos
        IGERR = 0
        CALL GLDIAG(nao,nao0,nao0,x(lp),x(lSCR),x(lE),x(ld),
     *              IGERR,x(lIWRK))
        IF (IGERR .NE. 0) CALL ABRT
        CALL TFSQB(X(Ld),X(LQ),X(LSCR),nao0,nao,nao)
c       check upper eigenvalues
        do imo=nao0-nmos+1,nao0
          if(x(lE+imo-1).lt.shiftb/tolb) then
            write(6,*) 'P eigenvalue too small?',x(lE+imo-1),imo
            call abrt 
          endif
        enddo
c       write(6,*) 'wwwZ',iside
c       call prsq(X(Ld),nao0,nao,nao)
        ishift=nlmo0(iside)
        do i=1,nao0
          call dcopy(nao,x(ld+(i-1)*nao),1,CoreAO(1,i,ishift),1)
        enddo
c       call dcopy(MaxCBS*nao,x(ld),1,CoreAO(1,1,ishift),1)
        nlmo0(iside)=nkept
        write(6,*) 'Generated ',nkept,'orbitals for side',iside
      enddo
      CALL RETFM(NEED)
      RETURN
      END
C*MODULE fmolib  *DECK dolend
      logical function dolend(str)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      character*99 str
      character*5 str0
c
c     check if str is equal to $end (ignoring case and following characters).
c 
      do i=1,5
        str0(i:i)=str(i:i) 
      enddo
      call UPRCAS(str0,5)
      dolend=str0.eq.' $END' 
      RETURN
      END
c
C*MODULE fmolib  *DECK glolat
      SUBROUTINE glolat(loctat,libish,libnsh,izbas,fmozan)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MAXL=5,MAXNZ=137,MaxLay=5,
     *           MXSFMO=MaxLay*40,MXGFMO=MaxLay*100,MXAFMO=MaxLay*10)
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2
      common /fmoshl/ fzan(MXAFMO),fEX(MXGFMO),fC(MXGFMO,MAXL),
     *                LSTART(MXSFMO),LATOM(MXSFMO),LTYPE(MXSFMO),
     *                LNG(MXSFMO),LMIN(MXSFMO),LMAX(MXSFMO),llay(MXAFMO)
     *               ,lmptyp(mxafmo),lzcore(mxafmo),lshell,natl,numl
      DIMENSION loctat(*),libish(MAXNZ,maxbas,*),libnsh(MAXNZ,maxbas,*),
     *          izbas(*),fmozan(*) 
c
c     Fill the array that gives the beginning AO index for each atom
c     in the total molecule. 
c     This subroutine makes some assumptions about basis set storing
c     that do not use "legally available" data.
c     Only unilayer runs make sense.
c
      iao=1
      do iat=1,natfmo
        iz=int(fmozan(iat)+0.1D+00)
        ibas=izbas(iat)
        ilay=1
        ist=libish(iz,ibas,ilay)
        ifi=ist+libnsh(iz,ibas,ilay)-1
        nao=0 
        do ii=ist,ifi
          nao=nao+lmax(ii)-lmin(ii)+1
        enddo
        loctat(iat)=iao
        iao=iao+nao 
      enddo
c     write(6,*) 'wwwglol',(loctat(i),i=1,natfmo)
      return
      end
C*MODULE fmolib  *DECK fmomul
      SUBROUTINE fmomul
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      logical GOPARR,DSKWRK,MASWRK
      PARAMETER (MXATM=2000)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /FMCOM / X(1)
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo
c
c     Change multiplicity for FMO-CI runs (monomers+dimers).
c
      mul0=mul
      if(ifmostp.eq.2) then
        mul=ixftch(x(lmulfg),icurfg)
      else if(ifmostp.eq.4) then
        muli=ixftch(x(lmulfg),icurfg)
        mulj=ixftch(x(lmulfg),jcurfg)
        mul=max(muli,mulj) 
c       Such choice is intended to work in the following cases:
c       Singlet and non-singlet -> choose non-singlet 
c       non-singlet and non-singlet -> choose non-singlet 
c       The latter case should mostly be limited to muli=mulj.
      endif
      if(mul.ne.mul0.and.maswrk) write(iw,9000) mul0,mul
      return
 9000 format(/1x,'Warning: multiplicity was changed from',I2,' to',I2/)
      end
C*MODULE fmolib  *DECK pullfrg
      SUBROUTINE pullfrg(ifg0,jndat,ilayfrg,ifgdat,jzbas,indat,iabdfg,
     *                   jabdfg,fmozan,fmoc,izbas,ichfg,mulfg,frgnam,
     *                   layfrg,scffrg,mconfg,molfrg,nprfrg)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      character*8 tstring
      logical GOPARR,DSKWRK,MASWRK
      parameter(MXATM=2000,ncaps=1,maxabd0=4-1,one=1.0D+00,zero=0.0D+00)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      dimension jndat(*),ilayfrg(*),ifgdat(*),jzbas(*),indat(*),
     *          iabdfg(*),jabdfg(*),fmozan(*),fmoc(3,*),izbas(*),
     *          ichfg(*),mulfg(*),frgnam(*),layfrg(*),scffrg(*),
     *          mconfg(*),molfrg(*),nprfrg(*),
     *          zcap(ncaps),ccap(3,maxabd0,ncaps),nhcap(ncaps),
     *          a1(3,3),a2(3,3),a3(3,3),zaxis(3),bond(3)
      EQUIVALENCE (tstring,dstring)
      data zaxis/0,0,1/
      data zcap/6.0D+00/,nhcap/3/,
     *     ccap/-0.9709996570D+00,  1.6818207400D+00,-0.6866004421D+00,
     *          -0.9709996570D+00, -1.6818207400D+00,-0.6866004421D+00,
     *           1.9419993140D+00,  0.0000000000D+00,-0.6866004421D+00/
c
c     "Pull out" fragment ifg0, that is, create its "free monomer" data set
c     for RUNTYP=FMO0. 
c
c     capsc stores the library for ncaps prestored sets. It is assumed that
c     all capping atoms are hydrogens, and the atoms to which they are capped
c     are taken from the given molecule. For example, a molecule may have
c     a fractioned bond Ca|---Cb, so for the fragment containing Ca,
c     Cb will be added, and then 3 capping hydrogens to have Ca---CbH3.  
c     At present only CH3 is stored, for R(C-H)=1.09 A. 
c     The central atom should be at the origin. The omitted hydrogen (from CH4) 
c     was put on the z-axis in the positive direction.
c     ifgdat is used to store mapping global indices -> local
c
c     The basis set for the caps is that of the dangling atom.
c     In rare cases the basis set of H may have not be required for normal FMO
c     but will be needed in FMO0. 
c
c     First add the fragment itself.
c
      PI=ACOS(-ONE)
      nat=0
      nfg0=nfg
      nfg=1
      do iat=1,natfmo
        if(indat(iat).eq.ifg0) then
          nat=nat+1
          if(nat.gt.MXATM) call abrt
          zan(nat)=fmozan(iat) 
          jzbas(nat)=izbas(iat)
          call dcopy(3,fmoc(1,iat),1,c(1,nat),1)
          jndat(nat)=nfg
          ifgdat(iat)=nat
        else
          ifgdat(iat)=0
        endif
      enddo
      nat0=nat
c
c     Process fragment-specific options.
c
      ichfg(1)=ichfg(ifg0)
      mulfg(1)=mulfg(ifg0)
      frgnam(1)=frgnam(ifg0)
      ilayfrg(1)=layfrg(ifg0)
      scffrg(1)=scffrg(ifg0)
      mconfg(1)=mconfg(ifg0)
      molfrg(1)=molfrg(ifg0)
      nprfrg(1)=nprfrg(ifg0)
c 
c     write(6,*) 'Added own',nat,nfg,nbdfg
      nbdfgi=0
c     Now add methyl caps. This consists of:
c     adding dangling atoms. Put each into its own fragment.
      do ibdfg=1,nbdfg
        ia=abs(iabdfg(ibdfg))
        ja=abs(jabdfg(ibdfg))
        ifg=indat(ia)
        jfg=indat(ja)
        if(ifg.eq.ifg0) then
          iat=ia
          jat=ja
        else if(jfg.eq.ifg0) then
          iat=ja
          jat=ia
        else
          iat=0
          jat=0
        endif
        if(iat.ne.0) then
c         add the caps. 
c
c         Search the library
          icap=0
          zj=fmozan(jat)
          do i=1,ncaps
            if(abs(zcap(i)-zj).lt.1.0D-06) then
              icap=i
              goto 100
            endif 
          enddo 
          write(6,*) 'Atom not found in the cap library',zj
          call abrt
  100     continue 
c         First add the broken bond information (overwriting the arrays!).
          nat=nat+1
          ialoc=ifgdat(iat)
          jaloc=nat
c         ifgdat should be set for all atoms in ifg0, and iat is guaranteed to 
c         be be in ifg0, so the condition below should never be met. 
          if(ialoc.eq.0) call abrt
          nbdfgi=nbdfgi+1
          if(ifg.eq.ifg0) then
            iabdfg(nbdfgi)=-ialoc
            jabdfg(nbdfgi)= jaloc
          else
            iabdfg(nbdfgi)=-jaloc
            jabdfg(nbdfgi)= ialoc
          endif
          if(nat.gt.MXATM) call abrt
          zan(nat)=fmozan(jat) 
          jzbas(nat)=izbas(jat)
          call dcopy(3,fmoc(1,jat),1,c(1,nat),1)
          nfg=nfg+1
          jndat(nat)=nfg
c
c         Frgament specific options.
c         Make uncharged singlets.
c
          ichfg(nfg)=0
          mulfg(nfg)=1
          WRITE(UNIT=tstring,FMT='(A3,I5.5)') 'cap',ibdfg
          frgnam(nfg)=dstring
c         The cap's layer is determined by the layer of the dangling atom. 
          if(ifg.eq.ifg0) then
            ilayfrg(nfg)=layfrg(jfg)
          else
            ilayfrg(nfg)=layfrg(ifg)
          endif
          scffrg(nfg)=scftyp
          mconfg(nfg)=mconfg(1)
          molfrg(nfg)=0
          nprfrg(nfg)=0
c
          call vsub(fmoc(1,jat),1,fmoc(1,iat),1,bond,1,3)
c         write(6,*) 'Added neighbour',nat,nfg,nbdfg
          call vecrot(bond,zaxis,a1)
c
c         Find the closest neighbour of iat (excluding jat). 
c         Search only among ifg0's own atoms (excluding all caps to insure 
c         maximum invariance about input permutations and such).
c         Save time by computing square of the distance.
c
          kat=0
          rk=1.0D+30
          do i=1,nat0
            if(i.ne.ialoc.and.i.ne.jaloc) then
              ri=(c(1,i)-c(1,ialoc))**2 + (c(2,i)-c(2,ialoc))**2 +
     *           (c(3,i)-c(3,ialoc))**2
              if(ri.lt.rk) then
                rk=ri
                kat=i
              endif
            endif
          enddo
c         write(6,*) 'Backbone partner was ',kat
c         if no atom was found (kat=0) it should only mean that there was only
c         one atom in the fragment, in which case the angle does not matter
c         if there is only one cap. In any case recover by setting the angle 
c         to zero. This case of just one atom per frg bonded to others is 
c         probably not practically possible (and using zero angle is not very
c         bad either). 
          if(nat0.eq.1) then
            ANGLE=zero 
            signa=one
          else
            if(kat.eq.0) call abrt
c
c           Add the first capping hydrogen in order to obtain the dihedral
c           angle. Note that nat is not yet modified.
c
            lat=nat+1 
            call MRARBR(a1,3,3,3,ccap(1,1,icap),3,1,c(1,lat),3)
            call daxpy(3,one,fmoc(1,jat),1,c(1,lat),1)
            call DIHED(C,lat,jaloc,ialoc,kat,ANGLE,SIGNA)
c           write(6,*) 'Dihedrals',lat,jaloc,ialoc,kat,SIGNA*ANGLE
          endif
c
c         Build the rotation matrix along the bond, with the angle
c         such that the dihedral angle becomes PI.
c         bond does have to be normalised to call MATNOM.
c         The order of a2*a1 is important! 
c         First rotate R by a1 (rotate z-axis for the caps). 
c         Then rotate a1*R by a2 (rotate caps along the bond).
c
          call dscal(3,one/sqrt(ddot(3,bond,1,bond,1)),bond,1)
          call MATNOM(pi-SIGNA*ANGLE,bond,a2)
          call MRARBR(a2,3,3,3,a1,3,3,a3,3)
c
c         Rotate the capping hydrogens and shift to fmoc(1,jat). 
c
          do i=1,nhcap(icap)
            nat=nat+1
            if(nat.gt.MXATM) call abrt
            zan(nat)=one
            jzbas(nat)=izbas(jat)
            call MRARBR(a3,3,3,3,ccap(1,i,icap),3,1,c(1,nat),3)
            call daxpy(3,one,fmoc(1,jat),1,c(1,nat),1)
            jndat(nat)=nfg
c           write(6,*) 'Added neighbour caps',nat,nfg
          enddo
c         if(kat.ne.0) call DIHED(C,lat,jaloc,ialoc,kat,ANGLE,SIGNA)
c         write(6,*) 'Rotated Dihedral',SIGNA*ANGLE
          if(maswrk) write(iw,9010) ifg0,ibdfg,icap,nhcap(icap)+1,kat,
     *                              SIGNA*ANGLE
        endif
      enddo
      nbdfg=nbdfgi
c
c     Rewrite the coordinates+charges.
c
      if(nat.gt.natfmo.or.nfg.gt.nfg0) then
        write(iw,9200) nat,natfmo,nfg,nfg0
        call abrt
      endif
      call dcopy(nat,zan,1,fmozan,1)
      call dcopy(nat*3,c,1,fmoc,1)
      call icopy(nat,jndat,1,indat,1)
      call icopy(nat,jzbas,1,izbas,1)
      call icopy(nfg,ilayfrg,1,layfrg,1)
      natfmo=nat
c     write(6,6666) (zan(kk),(c(jj,kk),jj=1,3),kk=1,nat)
c6666 format(100(F10.5,3F12.5,/))
c     write(6,*) 'bonds',(iabdfg(i),jabdfg(i),i=1,nbdfg)
c
      return
 9010 format(1x,'Free monomer',I5,', ibdfg=',I5,', icap=',I2,
     *          ', natc=',I2,', iatdih=',I4,', angle=',F10.6/)
 9200 format(/1x,'Oh no! Your tiny molecule generated a larger capped ',
     *           'system than the original',/1x,'one. The solution is ',
     *           'to add some dummy non-bonded fragment(s).'
     *       /1x,'We suggest one or two H2 coinciding with some real ',
     *           'atoms. Such dummy will have',
     *       /1x,'-zero- effect upon the results but will allocate ',
     *           'enough memory.',
     *       /1x,'You will have to manually remove dummy fragments ',
     *           'from the sparse cube file',
     *       /1x,'though, if you asked for one.',4I5/)
      end
C*MODULE fmolib  *DECK nzCOPY
      SUBROUTINE  nzCOPY(N,DX,INCX,DY,INCY)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION DX(n,INCX),DY(n,INCY)
C
C     COPIES non-zero elements of a VECTOR.
C           DY(I) <== DX(I)
c
      do i=1,n
        if(dx(i,1).ne.0) dy(i,1)=dx(i,1)
      enddo
      return
      end
C*MODULE fmolib  *DECK forcedir 
      logical function forcedir(l1dir,l1,out)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      logical out,GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      common /INT2IC/ NINTIC,iNINTIC,nxxic,lbufpic,lixic,labsix,nintix
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
c
c     This function compares the maximum basis set size appropriate for
c     conventional SCF with the current size l1 and returns true if
c     direct SCF should be enfiorced due to insufficient memory.
c
c     The amount is computed based on two assumptions:
c     1.  l1dir (typically, 150-200) basis functions produce 1d+8 integrals,
c     2.  the change to this amount for a different L1 (basis set size) is
c         given by (L1/LDIR)**powerint 
c     Tests indicate powerint=1/3.6 ... 1/3.8, however, we take a bit an 
c     aggressive stance here and use 1/3.5. It is still better to dump some 
c     integrals on disk rather than recompute them at each SCF iteration. 
c     In addition, the larger the fragments, the lower powerint can get. 
c
c     Memory is the amount per group (not per node), assuming AOINT=DIST 
c     (will not work for sequential MP2?), although this can be
c     adjusted by an appropriate calling argument.
c
c     Input: l1dir,l1,out.
c
      if(l1dir.eq.0.or.NINTIC.eq.0) then
        forcedir=.false.
        return
      else
        powerint=1.0D+00/3.5D+00
        fmem=abs(NINTIC)
        maxAOdir=int(l1dir * (fmem*nproc/1.0d+08)**powerint)
        forcedir=l1.gt.maxAOdir
        if(out) write(iw,9000) maxAOdir,l1,forcedir
      endif
      return
 9000 format(1x,'Max L1 incore=',I6,' current l1=',I6,' force dirscf=',
     *          L2) 
      end
c
C*MODULE fmolib  *DECK dmexch
      SUBROUTINE dmexch(ilay,nfge,jobgrp,layfrg,numfrg,natfrg,scffrg,
     *                  LDAF,iodfmo,maxl30,emon,ewrk,glocon,nconv,irec0,
     *                  dosap,dospc,orbxch,enexch,atonce,dodistr,mastid,
     *                  popmul,popmat,ifgbuf,nfgbuf,skipscc,modcnv)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      logical GOPARR,DSKWRK,MASWRK,dosap,dospc,orbxch,enexch,atonce,
     *        dodistr,isgddi,parout,INITGDDI,maswrks,skipscc,wasgddi
      Integer ddi_world,ddi_group
      Parameter(ddi_world=0,ddi_group=1)
      COMMON /FMCOM / X(1)
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /TIMING/ CPU,WALL
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo
      dimension jobgrp(*),layfrg(*),numfrg(*),scffrg(*),iodfmo(*),
     *          maxl30(*),emon(*),ewrk(*),glocon(*),mastid(0:*),
     *          popmul(maxl1,*),natfrg(*),popmat(maxnat,*),
     *          ifgbuf(2,nfg,0:*),nfgbuf(2,0:*)
      data RMC/8HMCSCF   /,rnone/8HNONE    /,uhf/8HUHF     /
c
c       now exchange the initial/current density matrices.
c       the number of converged fragments (nconv) is summed over nodes as
c       part of jobgrp to save one GSUM. 
cnb     skip this subroutine if not running in parallel.
c
c     parstat: GlobalBcast
c
      call stopwa(12,0)
      CALL TSECND(TIMe0)
      wall0=wall 
      call timit(1)
c     if(MASWRK) write(6,*) 'Entering dmexch.',skipscc
c     call gddi_scope(ddi_masters)
      jobgrp(nfg+1)=nconv 
      maswrks=maswrk
      idoprops=idoprop
      ifmostps=ifmostp
      if(.not.maswrk) then
cnb      these are probably not needed
         call viclr(jobgrp,1,nfg+1) 
c        It is wrong to exchange energy for restarts since it will be
c        double counted (duplicated on ALL nodes).
c        if(nconv.ge.0.or.irststp.lt.2) call vclr(emon,1,nfge) 
         if(nconv.ge.0.or.irststp.lt.2) call vclr(emon,1,nfg*2) 
      endif
      mygrp=mygroup
      call gddi_scope(ddi_world)
      ndata=0
c     if(maswrk) then
      CALL DDI_GSUMI(2414,jobgrp,nfg+1)
      nconv=jobgrp(nfg+1)
      if(nconv.ge.0.or.irststp.lt.2) call ddi_gsumf(2422,emon,nfge)
      if(iand(modcnv,1).ne.0) call ddi_gsumf(2422,ewrk,nfg)
      if(nconv.ge.0) call ddi_gsumf(2422,glocon,ngroups)
      if(maswrk.and.iand(nprfmo,3).le.0) 
     *  write(6,*) 'jobs:',(jobgrp(i),i=1,nfg)
      if(dodistr) then
c         only exchange populations and charges
c       if(dospc) write(6,*) 'wwwz1',(popmat(i,1),i=1,maxnat*nfg)
        do ifg=1,nfg
          mefg=jobgrp(ifg)
          ididit=mastid(mefg)
          if(layfrg(ifg).lt.ilay.or.scffrg(ifg).eq.rnone) ididit=0 
c         pretend that grand master did the undone work 
          l1=iand(numfrg(ifg),65535)
          nati=natfrg(ifg)
          if(me.ne.ididit) then
            if(dosap) call vclr(popmul(1,ifg),1,l1)
            if(dospc) call vclr(popmat(1,ifg),1,nati)
c           to prevent double counting on slaves
          endif
        enddo
c       if(dospc) write(6,*) 'wwwz2',(popmat(i,1),i=1,maxnat*nfg)
        if(dosap) call ddi_gsumf(2422,popmul,maxl1*nfg)
        if(dospc) call ddi_gsumf(2423,popmat,maxnat*nfg)
c       if(dospc) write(6,*) 'wwwz3',(popmat(i,1),i=1,maxnat*nfg)
        ndata=ndata+maxl1*nfg+maxnat*nfg
      else
        if(atonce) then
          call viclr(nfgbuf,1,2*ngroups)
          do 100 ifg=1,nfg
            if(layfrg(ifg).lt.ilay) goto 100
            if(skipscc.and.layfrg(ifg).gt.ilay) goto 100
            mefg=jobgrp(ifg)
            l1=iand(numfrg(ifg),65535)
            m2=(l1*l1+l1)/2+l1*l1+l1*3 
            if(scffrg(ifg).eq.uhf) m2=m2+l1*l1+l1
c           do an upper estimate of m2
            nfgbuf(2,mefg)=nfgbuf(2,mefg)+m2
  100     continue 
          maxb=0
          do i=0,ngroups-1
            maxb=max(maxb,nfgbuf(2,i))
          enddo
c         lbuf1 is used to accumulate data for mygroup 
c         lbuf2 is used for other groups 
          CALL VALFM(LOADFM)
          lbuf1=LOADFM+1
          lbuf2=lbuf1+maxb
          last=lbuf2+maxb
          NEED = LAST- LOADFM -1
          if(MASWRK) write(6,*) 'dmexch needs',NEED,' words of memory.'
          CALL GETFM(NEED)
          ibuf=lbuf1
          call viclr(nfgbuf,1,2*ngroups)
        else
          if(MASWRK) write(6,*) 'Entering dmexch.'
          ibuf=lfmoda
        endif
        if(MASWRK.and.skipscc) 
     *    write(iw,*) 'Skipping upper layer data in FMO/FD.'
        do 110 ifg=1,nfg
          if(layfrg(ifg).lt.ilay.or.scffrg(ifg).eq.rnone) goto 110
          if(skipscc.and.layfrg(ifg).gt.ilay) goto 110
          l1=iand(numfrg(ifg),65535)
          l2=(l1*l1+l1)/2
          mefg=jobgrp(ifg)
          m2=l2
          if(orbxch) m2=l1*l1
          if(scffrg(ifg).eq.rmc) m2=l2+l1*l1
          if(enexch) m2=m2+l1
          if(scffrg(ifg).eq.uhf) m2=m2+m2
c         if(scffrg(ifg).eq.uhf.or.scffrg(ifg).eq.rohf) m2=m2+m2
          imxl30=maxl30(ifg)
c         The master of the group that did that fragment reads the data in.
          ididit=mastid(mefg)
          nati=natfrg(ifg)
          l1pop=0
          if(dosap) l1pop=l1
          if(dospc) l1pop=l1pop+nati
          m2a=m2+l1pop-nati
          m2t=m2+l1pop
          if(me.eq.ididit) then
            ifmostp=6
c           Save on one broadcast and just read the density on the doer.
            call rareads(LDAF,iodfmo,x(ibuf),m2,ifg+irec0,0)
            ifmostp=ifmostps
            if(dosap) call dcopy(l1,popmul(1,ifg),1,x(ibuf+m2),1)
            if(dospc) call dcopy(nati,popmat(1,ifg),1,x(ibuf+m2a),1)
            if(atonce) ibuf=ibuf+m2t
          endif
          ndata=ndata+m2t
          if(atonce) then
c           accumulate all data in lbuf along with indexing 
c           note that indexing must be prepared on all nodes.
            ind=nfgbuf(1,mefg)
            ind=ind+1
            nfgbuf(1,mefg)=ind 
            nfgbuf(2,mefg)=nfgbuf(2,mefg)+m2t
            ifgbuf(1,ind,mefg)=ifg
            ifgbuf(2,ind,mefg)=m2
          else
            CALL DDI_BCAST(2416,'F',x(ibuf),m2t,ididit)
c           it may be a bit of a philosophical decision: whether to enforce
c           having the same density for each node here. At present group
c           members do not write what their master broadcast because they
c           should have the same thing anyway (or very nearly so).
c           if(mygrp.ne.mefg) then
            if(me.ne.ididit) then
c             
              if(iand(modpar,256).eq.0.or.maswrks.or.idoprop.ne.0) then
                idoprop=1
c               This saves density only on group masters or on all nodes
c               during the last SCC cycle.
                CALL rawrites(LDAF,iodfmo,x(ibuf),imxl30,m2,ifg+irec0,0)
                idoprop=idoprops
              endif
              if(dosap) call dcopy(l1,x(ibuf+m2),1,popmul(1,ifg),1)
              if(dospc) call dcopy(nati,x(ibuf+m2a),1,popmat(1,ifg),1)
            endif
          endif
c         if(dosap.and.maswrk) then
c           write(6,*) ifg,'orbital Mullikens',l1
c           call prsq(popmul(1,ifg),l1,1,1)
c         endif
c         if(dospc.and.maswrk) then
c           write(6,*) ifg,'atomic Mullikens',nat0
c           call prsq(popmat(1,ifg),nat0,1,1)
c         endif
  110   continue 
        if(atonce) then
c       now broadcast the accumulated data
          do i=0,ngroups-1
            m2t=nfgbuf(2,i) 
            if(m2t.ne.0) then
              ididit=mastid(i)
c             sending side provides mygroup data in lbuf1, receiving side
c             stores to lbuf2, in order not to overwrite its own data.
              ibuf=lbuf2
              if(mygrp.eq.i) ibuf=lbuf1
              CALL DDI_BCAST(2416,'F',x(ibuf),m2t,ididit)
c             if(me.ne.ididit) then
              if(mygrp.ne.i) then
                nn=nfgbuf(1,i)
                do j=1,nn
                  ifg=ifgbuf(1,j,i)
                  m2= ifgbuf(2,j,i)
                  imxl30=maxl30(ifg)
                  l1=iand(numfrg(ifg),65535)
                  nati=natfrg(ifg)
                  l1pop=0
                  if(dosap) l1pop=l1
                  if(dospc) l1pop=l1pop+nati
                  m2a=m2+l1pop-nati
                  if(iand(modpar,256).eq.0.or.maswrks.or.idoprop.ne.0)
     *            then
                    idoprop=1
                    CALL rawrites(LDAF,iodfmo,x(ibuf),imxl30,m2,
     *                            ifg+irec0,0)
                    idoprop=idoprops
                  endif
                  if(dosap) call dcopy(l1,x(ibuf+m2),1,popmul(1,ifg),1)
                if(dospc) call dcopy(nati,x(ibuf+m2a),1,popmat(1,ifg),1)
                  ibuf=ibuf+m2+l1pop
                enddo
              endif
            else
              if(maswrk) write(6,*) 'Nothing done by group',i
            endif
          enddo
          call retfm(need) 
        endif
      endif
c     endif
      call gddi_scope(ddi_group)
c     CALL DDI_BCAST(2417,'I',nconv,1,master)
      call timit(1)
      CALL TSECND(TIMe1)
      if(maswrk) write(iw,9600) ndata,wall-wall0
      call stopwa(12,1)
      return
 9600 format(/1x,'Data exchange of',I10,' words took',F8.1,' s.')
      end
c
C*MODULE fmolib  *DECK fmopre
      subroutine fmopre(ilay,nstep,ngrfmo,mannod,mastid)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      logical GOPARR,DSKWRK,MASWRK,isgddi,parout,INITGDDI,wasgddi
      COMMON /EFPFMO/ RUNEFP,REFFMO,REPNUCEFP,IEFPFMO,ISWENUC,EFPEFP
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      parameter (maxpst=10)
      dimension ngrfmo(maxpst,*),mannod(*),mastid(*)
c
      call timit(1)
c
c     Find the offset: mannod is stored as an array of vectors with variable
c     size. Each vector contains one set of group sizes.
c     This is repeated for each layer.
c
      ioff=1
      do i=1,ilay-1
        do j=1,maxpst
          ioff=ioff+ngrfmo(j,i)
        enddo
      enddo
      do i=1,nstep-1
        ioff=ioff+ngrfmo(i,ilay)
      enddo
      call gddi_init(ngrfmo(nstep,ilay),mannod(ioff),nprint.ne.-5)
      call gddi_mastid(mastid)
c
      if(maswrk.and..not.parout) then
c       SEQOPN will NOT open files if they are already opened.
        CALL SEQOPN(IR,'INPUT', 'OLD',.TRUE., 'FORMATTED')
        CALL SEQOPN(IW,'OUTPUT','UNKNOWN',.FALSE., 'FORMATTED')
        CALL SEQOPN(IP,'PUNCH', 'NEW',.FALSE.,'FORMATTED')
      endif
c
c     FMO/EFP needs to reinitialise its arrays
c
      IF(IEFPFMO.NE.0) CALL EFPPARL
c
      call timit(1)
c
      return
      end
C*MODULE fmolib  *DECK ddexch
      SUBROUTINE ddexch(ilay,nfg2,job2grp,layfrg,IDAcFMO,iodcfmo,mastid,
     *                  buf)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      logical GOPARR,DSKWRK,MASWRK,isgddi,parout,INITGDDI,wasgddi
      Integer ddi_world,ddi_group
      Parameter(ddi_world=0,ddi_group=1)
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /TIMING/ CPU,WALL
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      dimension job2grp(*),layfrg(*),iodcfmo(*),mastid(0:*),buf(*)
c
c     exchange the dimer density matrices.
cnb   skip this subroutine if not running in parallel.
c     This subroutine cannot handle multilayer FMO. 
c     The difference with dmexch: only density is exchanged; "At once"
c     strategy is not supported due to its smaller importance for dimers
c     and (much) larger memory costs. 
c
c     parstat: GlobalBcast
c
c     dummy statement for ftnchek 
      if(ilay.ne.layfrg(1)) call abrt
      CALL TSECND(TIMe0)
      wall0=wall 
      call timit(1)
      if(MASWRK) write(6,*) 'Entering ddexch.'
c     mygrp=mygroup
      call gddi_scope(ddi_world)
      ndata=0
      CALL DDI_GSUMI(2414,job2grp,nfg2)
      ijfg=0 
      do 110 ifg=1,nfg
        do 110 jfg=1,ifg-1
          ijfg=ijfg+1
c         if(layfrg(ifg).lt.ilay) goto 110
          igr2=mod(job2grp(ijfg),npglob)
          if(job2grp(ijfg).ne.0) then
            l1=job2grp(ijfg)/npglob
            l2=(l1*l1+l1)/2
c           imxl30=maxl30(ifg)
c           The master of the group that did that dimer reads the data in.
            ididit=mastid(igr2)
            l2all=l2
c           l2all should be max(L){l2(L)}, the max value over layers:
c           now FMO3/ESapp must have the same basis set.
            if(me.eq.ididit)
     *        call rareads(IDAcFMO,iodcfmo,buf,l2,ijfg,0)
            ndata=ndata+l2
            CALL DDI_BCAST(2416,'F',buf,l2,ididit)
c           it may be a bit of a philosophical decision: whether to enforce
c           having the same density for each node here. At present group
c           members do not write what their master broadcast because they
c           should have the same thing anyway (or very nearly so).
c           if(mygrp.ne.mefg) then
            if(me.ne.ididit)
     *        CALL rawrites(IDAcFMO,iodcfmo,buf,l2all,l2,ijfg,0)
          endif
  110 continue 
      call gddi_scope(ddi_group)
      call timit(1)
      CALL TSECND(TIMe1)
      if(maswrk) write(iw,9600) ndata,wall-wall0
      return
 9600 format(/1x,'Dimer data exchange of',I10,' words took',F8.1,' s.')
      end
c
C*MODULE fmolib  *DECK ddexch
      SUBROUTINE fmocvij(ifg,jfg,kfg,mconvex,mconfg2,iconvijk)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      logical GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      dimension mconfg2(4,*)
c
      do i=1,mconvex
        if(mconfg2(1,i).le.0) return
        if(ifg.eq.mconfg2(1,i).and.jfg.eq.mconfg2(2,i).and.
     *     kfg.eq.mconfg2(3,i)) then
           iconvijk=mconfg2(4,i)
           if(maswrk) write(iw,*) 'SCF converger changed to:',iconvijk
           return
        endif
      enddo
      return
      end
c
C*MODULE fmolib  *DECK setvskip 
      SUBROUTINE setvskip(natfrg,xyz,indvmul)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension natfrg(*),xyz(3,*),indvmul(*)
      PARAMETER (MXATM=2000)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo
c
      huge=1.0D+30
      natfmob=natfmo+nbdfg
      lfg=1
      inat=0
      do i=1,natfmob
        inat=inat+1
        if(inat.gt.natfrg(lfg)) then
          lfg=lfg+1
          inat=1
        endif
        indvmul(i)=0
        rl=-huge
        if(ifmostp.ne.6) then
          if(lfg.ne.icurfg.and.lfg.ne.jcurfg.and.lfg.ne.kcurfg)
     *      rl=fmodist(icurfg,jcurfg,kcurfg,lfg)
        else 
          if(lfg.eq.jcurfg) rl=huge
        endif
        if(rl.gt.resppc(1).and.resppc(1).ne.0) then
          indvmul(i)=1
          if(iand(ixesp,32768).ne.0) then 
            tol2=1.0D-08
            cx=xyz(1,i)
            cy=xyz(2,i)
            cz=xyz(3,i)
            do j=1,nat
              if((c(1,j)-cx)**2+(c(2,j)-cy)**2+(c(3,j)-cz)**2.lt.tol2)
     *        then
                write(6,*) 'Zeroed out ESPZ',i,cx,cy,cz
                indvmul(i)=0 
                goto 100
              endif
            enddo
  100       continue
          endif
        endif
      enddo 
      write(6,*) (indvmul(i),i=1,natfmob)
      return
      end
c
C*MODULE fmolib  *DECK storemul
      SUBROUTINE storemul(ic,ifg,nat,nfrgmul,xyz,frgmul,natfrg,c,stonep)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension natfrg(*),xyz(3,*),frgmul(nfrgmul,*),c(3,*),
     *          stonep(nat,*)
c
      iat=1
      do jfg=1,ifg-1
       iat=iat+natfrg(jfg)
      enddo
      if(ic.ne.0) call dcopy(3*nat,c,1,xyz(1,iat),1)
c     do i=1,3
c       call dcopy(nat,c(i,1),3,frgmul(i,iat),nfrgmul+3)
c     enddo
      do i=1,nfrgmul
        call dcopy(nat,stonep(1,i),1,frgmul(i,iat),nfrgmul)
      enddo
      return
      end
C*MODULE fmolib  *DECK excmono
      subroutine excmono(iexcit,eexcit,texcit,MONOC,MONVR,NSTMONO)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      logical TRIPLET,SG1T,GOPARR,DSKWRK,MASWRK,MNMEDG,MNMEOP,UNVGSS,
     *        DGAPRX,RDCISV,TAMMD,TPA
      parameter(mxrt=100)
      dimension iexcit(5),eexcit(mxrt,2),texcit(3,mxrt,2),
     *          MONOC(mxrt),MONVR(mxrt)
      COMMON /CISPAR/ HAMTYP,DIAGZN,DAVCVG,PRTTOL,NSTATE,ISTATE,MULT,
     &                MXV,NDAVIT,ICISPR,NACORE,NBCORE,NOA,NOB,NORBOC,
     &                NBF,NGSVEC,MNMEDG,MNMEOP,ICLOBBR,UNVGSS,DGAPRX,
     &                RDCISV
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /INFOEX/ TDM(3,mxrt),MOCC(mxrt),MVIR(mxrt),MONOC1,MONVR1,
     *                IFMODIM
      COMMON /INFOTD/ CNVTOL,TRIPLET,SG1T,JANST,NRADT,NTHET,NPHIT,NLEBT,
     *                NSTAT,NTRIAL,MAXVEC,NTHST,IRECTD,ITDFG,NONEQR,
     *                ITDPRP,TAMMD,TPA
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      data rnone/8HNONE    /,cis/8HCIS     /
c
      NSTMAX=0
      if(TDDFTYP.ne.rnone) NSTMAX=NSTAT
      if(cityp.eq.cis) NSTMAX=NSTATE
c
      IF(NSTAT.GT.mxrt) NSTMAX=mxrt
      IF(maswrk) nstmono=NSTMAX
c
      DO IST=1,NSTMAX
c      CSCAL=1.0D+00
c      if(TDM(IDXYZ(IST),IST).LT.0.0D+00) CSCAL=-CSCAL
       IF(maswrk) then
        eexcit(IST,1)=Estate(IST)-escf
        eexcit(IST,2)=eexcit(IST,1)
        if(iexcit(5).eq.0) then
          call dcopy(3,TDM(1,IST),1,texcit(1,IST,1),1)
          call dcopy(3,TDM(1,IST),1,texcit(1,IST,2),1)
        else if(iexcit(5).eq.1) then
          dd=ddot(3,TDM(1,IST),1,TDM(1,IST),1)
          texcit(1,IST,1)=dd
          texcit(1,IST,2)=dd
          write(6,*) 'monomer DD',dd
        else if (iexcit(5).eq.2) then
          CALL OSCALC(OSD,TDM(1,IST),eexcit(IST,1),1)
          texcit(1,IST,1)=osd
          texcit(1,IST,2)=osd
          write(6,*) 'monomer OSC',osd
        endif
        MONOC(IST)=MOCC(IST)
        MONVR(IST)=MVIR(IST)
        MONOC1=MOCC(1)
        MONVR1=MVIR(1)
c       IF(maswrk) write(6,*)'IST,IDXYZ(IST),TDM(1,IST) IN tdmono=',
c    *  IST,IDXYZ(IST),texcit(1,IST,1)
       ENDIF
      ENDDO
c
      return
      END
C*MODULE fmolib  *DECK tdesum
      subroutine tdesum(iexcit,eexcit,texcit,NSTMONO,ICST,ISUMD,
     *                  ifg,jfg,idfg,rij,eexfg)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      logical GOPARR,DSKWRK,MASWRK
      parameter(mxrt=100,one=1.0D+00)
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /INFOEX/ TDM(3,mxrt),MOCC(mxrt),MVIR(mxrt),MONOC1,MONVR1,
     *                IFMODIM
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      dimension iexcit(5),eexcit(mxrt,2),texcit(3,mxrt,2),
     *          ICST(mxrt),ISUMD(mxrt+1),eexfg(2,nfg,mxrt)
      dimension temp(3)
c
      NSTMAXM=NSTMONO
      IF(maswrk) ISUMD(mxrt+1)=ISUMD(mxrt+1)+1
      IF(NSTMAXM.GT.mxrt) NSTMAXM=mxrt
      DO 100 IST=1,NSTMAXM
        ISTD=ICST(IST)
        IF(ISTD.EQ.0) THEN
          GOTO 100
        ELSE
          IF(maswrk) ISUMD(IST)=ISUMD(IST)+1
        ENDIF
        EED=Estate(ISTD)-escf-eexcit(IST,1)
        EEDEV=EED*27.212D+00
        IF(maswrk) then
          eexfg(1,idfg,IST)=EED
          eexcit(IST,2)=eexcit(IST,2)+EED
c
c         iexcsav=iexcit(5)
c         iexcit(5)=3
          if(iexcit(5).eq.0) then
c           expand D in the FMO series
            ss=ddot(3,TDM(1,ISTD),1,texcit(1,IST,1),1)
            cscal=1
            if(ss.lt.0) cscal=-1
            if(cscal.lt.0) write(iw,*) 'Changing the sign of D',IST
            do IXYZ=1,3
              temp(IXYZ)=CSCAL*TDM(IXYZ,ISTD)-texcit(IXYZ,IST,1)
c         write(6,*) 'wwwD',temp(IXYZ),TDM(IXYZ,ISTD),texcit(IXYZ,IST,1)
            enddo
            write(IW,9700) ifg,jfg,IST,rij,EEDEV,(temp(i),i=1,3)
            call daxpy(3,one,temp,1,texcit(1,IST,2),1)
          else if(iexcit(5).eq.1) then
c           expand D^2 in the FMO series
            dd=ddot(3,TDM(1,ISTD),1,TDM(1,ISTD),1)
          write(6,*) 'dimer DD',dd
            dd=dd-texcit(1,IST,1)
            texcit(1,IST,2)=texcit(1,IST,2)+dd
            write(IW,9710) ifg,jfg,IST,rij,EEDEV,dd
          else if(iexcit(5).eq.2) then        
c           expand f in the FMO series
            CALL OSCALC(OSD,TDM(1,ISTD),Estate(ISTD)-escf,1)
          write(6,*) 'dimer OSC',osd
            osd=osd-texcit(1,IST,1)
            texcit(1,IST,2)=texcit(1,IST,2)+osd
            write(IW,9720) ifg,jfg,IST,rij,EEDEV,osd
          endif
c         iexcit(5)=iexcsav
        endif
c
  100 CONTINUE
c
c     IF(maswrk) then
c      WRITE(IW,*)'DIMER CORRECTED ENERGY' 
c      DO ISTM=1,NSTMONO
c       ISTD=ICST(ISTM)
c       DUM=EEXCIT(ISTM,2)*27.212D+00+EEXCIT(ISTM,1)
c       WRITE(IW,9750) ISTM, ISTD,DUM
c      ENDDO
c     ENDIF
c
      return
 9700 format(/1x,' dimer',I5,I5,' IST=',I4,' RIJ=',F8.3,
     * ' dEIJ=',F12.6,' dTIJ=',F8.4,F8.4,F8.4)
 9710 format(/1x,' dimer',I5,I5,' IST=',I4,' RIJ=',F8.3,
     * ' dEIJ=',F12.6,' dTTIJ=',F8.4)
 9720 format(/1x,' dimer',I5,I5,' IST=',I4,' RIJ=',F8.3,
     * ' dEIJ=',F12.6,' dfIJ=',F8.4)
c9750 FORMAT(1X,'   MONO-STATE',I4,1X,' DIME-STATE',
c    * I4,2X,'ENERGY =',F12.6,1X,'EV')
      END
C*MODULE fmolib  *DECK excout
      subroutine excout(frgnam,eexcit,texcit,osmd,iexcit,nstmono,
     *                  isumd,eexfg,haver,dotd,doci)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK,haver,dotd,doci
      parameter(TOEV=27.21138386D+00,mxrt=100)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IRPPCM,IEFPCM,IP_F,nfmopcm
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      dimension frgnam(*),eexcit(mxrt,2),texcit(3,mxrt,2),
     *         osmd(mxrt,2),iexcit(5),isumd(mxrt+1),eexfg(2,nfg,mxrt)
      data TWO/2.0D+00/,THREE/3.0D+00/
c
      NSTMAXM=nstmono
      IF(NSTMAXM.GT.mxrt) NSTMAXM=mxrt
      prttol=0.001D+00
C
C     OSCILLATOR STRENGTH
C
      do i=1,iexcit(2)
        DO IST=1,NSTMAXM
         if(iexcit(5).eq.0) then
           CALL OSCALC(OSMD(IST,i),Texcit(1,IST,i),eexcit(IST,i),1)
         else if(iexcit(5).eq.1) then
           OSMD(IST,i)=Texcit(1,IST,i)*eexcit(IST,i)*two/three
         else if(iexcit(5).eq.2) then
           OSMD(IST,i)=Texcit(1,IST,i)
         endif
        ENDDO
      ENDDO
C
C     PRINT OUT
C
      IF (MASWRK) THEN
       WRITE(IW,*)' '
       WRITE(IW,*)' ' 
       if(dotd) WRITE(IW,9000) 'TDDFT   '
       if(doci) WRITE(IW,9000) 'CIS     ' 
       WRITE(IW,*)' ====================' 
       if(dotd.and.nfmopcm.ne.0) WRITE(IW,9910)
C
       if(dotd) WRITE(IW,9800)
       WRITE(IW,9810)
       DO IST=1,NSTMAXM
        if(iexcit(5).eq.0) then 
        WRITE(IW,9850) IST,Eexcit(IST,1)*TOEV,texcit(1,IST,1),
     *  texcit(2,IST,1),texcit(3,IST,1),OSMD(IST,1)
        else
        WRITE(IW,9855) IST,Eexcit(IST,1)*TOEV,OSMD(IST,1)
        endif
       ENDDO
       rij=-1.0D+00
       if(iexcit(2).ge.2) then
        if(dotd) WRITE(IW,9900)
c       if(iand(iexcit(5),1).ne.0) then
          if(iexcit(5).eq.0) then
            WRITE(IW,9810)
          else if(iexcit(5).eq.1) then
            WRITE(IW,9812)
          else
            WRITE(IW,9815)
          endif
          DO IST=1,NSTMAXM
            if(iexcit(5).eq.0) then
              WRITE(IW,9850) IST,EExcit(IST,2)*TOEV,texcit(1,IST,2),
     *                       texcit(2,IST,2),texcit(3,IST,2),OSMD(IST,2)
c         write(6,*) 'final OSC',OSMD(IST,2)
            else if(iexcit(5).eq.1) then
              WRITE(IW,9852) IST,Eexcit(IST,2)*TOEV,texcit(1,IST,2),
     *                       OSMD(IST,2)
c         write(6,*) 'final OSC',texcit(1,IST,2),OSMD(IST,2)
            else
              WRITE(IW,9855) IST,Eexcit(IST,2)*TOEV,OSMD(IST,2)
c         write(6,*) 'final OSC',OSMD(IST,2)
            endif
          enddo
c
c       endif
        DO IST=1,NSTMAXM
         WRITE(IW,9960) IST,EExcit(IST,2)*TOEV,ISUMD(IST),ISUMD(mxrt+1)
         itdfrg=iexcit(1)
c        Print intrafragment excitation
         WRITE(IW,9860) iexcit(1),frgnam(itdfrg),0.0D+00,1.0D+02,
     *                  Eexcit(IST,1)*TOEV
c        Print interfragment excitations
         do ifg=1,nfg
           deifg=eexfg(1,ifg,IST)*TOEV
           daifg=eexfg(2,ifg,IST)*1.0D+02
           if(haver) rij=fmodist(ifg,0,0,itdfrg)
           if(abs(deifg).gt.prttol) then
             WRITE(IW,9860) ifg,frgnam(ifg),rij,daifg,deifg
           endif
         enddo
        ENDDO
       endif
C
       WRITE(IW,*)' '
      ENDIF
c
      return
 9000 FORMAT(2X,'RESULTS OF FMO-',A8)
 9800 FORMAT(/13X,'SUMMARY OF FMO1-TDDFT RESULTS'
     *        /13X,'-----------------------------'/5X,
     *        'FMO1-TDDFT by M. Chiba, D.G. Fedorov, K. Kitaura,'/
     *         19X,'Chem. Phys. Lett. 444 (2007) 346-350.')
 9810 FORMAT(/3X,'STATE',2X,'EXCITATION',
     *         2X,'TRANSITION DIPOLE, A.U.',2X,'OSCILLATOR'/
     *        14X,'eV',10X,'X',7X,'Y',7X,'Z',5X,'STRENGTH')
 9812 FORMAT(/3X,'STATE',2X,'EXCITATION','DIPOLE SQUARED',
     *         2X,'OSCILLATOR STRENGTH')
 9815 FORMAT(/3X,'STATE',2X,'EXCITATION',
     *         2X,'OSCILLATOR STRENGTH')
 9850 FORMAT(3X,I3,4X,F8.3,3X,3F8.4,1X,F8.3)
 9852 FORMAT(3X,I3,4X,F8.3,3X,F8.4,1X,F8.3)
 9855 FORMAT(3X,I3,4X,F8.3,3X,F8.3)
 9860 FORMAT(1X,I5,1X,A8,F8.3,3x,F6.1,F13.3)
 9900 FORMAT(/13X,'SUMMARY OF FMO2-TDDFT RESULTS'
     *        /13X,'-----------------------------'/5X,
     *        'FMO2-TDDFT by M. Chiba, D.G. Fedorov, K. Kitaura.'/
     *         19X,'J. Chem. Phys. 127 (2007) 104108.')
 9910 FORMAT(/2X,'FMO-TDDFT/PCM by M. Chiba, D.G. Fedorov, K. Kitaura,',
     *       /19X,'J. Comp. Chem. 29 (2008) 2667-2676')
c9950 FORMAT(3X,I3,4X,F8.3,3X,3F8.4,1X,F8.3,6x,I4,'  /',1x,I4)
 9960 FORMAT(/1X,'STATE',I3,' , EXCITATION ENERGY =',F8.3,' eV (',I5,
     *           ' corrections out of',I5,')',
     *       /3X,'IFG',3X,'NAME',6X,'RIJ',1x,'confidence,%',1x,
     *           'contribution,eV')
      END
C*MODULE fmolib  *DECK monovec
      subroutine monovec(VIJ,wrk,mapi,L1I,L1D,ifg,irec0,iodfmo,
     * orbxch,enexch,iodexch)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      logical orbxch,enexch,iodexch
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo
      dimension wrk(*),VIJ(*),mapi(*),iodfmo(*)
      l2i=(l1i*l1i+l1i)/2
      l3i=l1i*l1i
c
c     Clear VIJ //
c
      call VCLR(VIJ,1,l1d*l1d)
c
      if(.not.orbxch) then
      write(6,*)'FMO-TDHF REQUIRES MODORB>0 in $FMOPRP' 
      call abrt
      endif
c
c     Read monomer-MO: VI //
c
      m3i=l3i
      if(enexch) m3i=m3i+l1i
      if(iodexch) then
          CALL rareads(IDAFMO,iodfmo,wrk,l2i+m3i,ifg+irec0,0)
        else
          CALL rareads(IDAFMO,iodfmo,wrk(l2i+1),m3i,ifg+irec0,0)
      endif
c
c     Expands the size of monomer-MO into the dimer size: VI -> VIJ //
c      
      call monoexp(VIJ,wrk(l2i+1),mapi,L1I,L1D)
c
      return
      END
     
C*MODULE fmolib  *DECK monoexp
      subroutine monoexp(VIJ,VI,mapi,L1I,L1D)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension VI(l1I,*),VIJ(l1d,*),mapi(*)
c
c     write(6,*)'VI(3,4)=',VI(3,4)
      do i=1,L1d
      m=mapi(i)
       do j=1,L1I
        if(m.ne.0) then
        VIJ(i,j)=VI(m,j)
        endif
c       if(m.eq.3.and.j.eq.4) write(6,*)'VIJ=',VIJ(i,j)
       enddo
      enddo     
c
      return
      end
C*MODULE fmolib  *DECK excheck
      subroutine excheck(vecold,vecnew,ss,wrk,l0,L1,NSTMONO,MONOC,
     *                   MONVR,ICST,iexcit,idfg,eexfg,noccm,nvirm,noccd,
     *                   nvird,exfid,ctdm)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(mxrt=100)
      logical TRIPLET,sg1t,GOPARR,DSKWRK,MASWRK,TAMMD,TPA
      COMMON /FMCOM / X(1)
      COMMON /INFOEX/ TDM(3,mxrt),MOCC(mxrt),MVIR(mxrt),MONOC1,MONVR1,
     *                IFMODIM
      COMMON /INFOTD/ CNVTOL,TRIPLET,SG1T,JANST,NRADT,NTHET,NPHIT,NLEBT,
     *                NSTAT,NTRIAL,MAXVEC,NTHST,IRECTD,ITDFG,NONEQR,
     *                ITDPRP,TAMMD,TPA
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      dimension vecold(*),vecnew(*),ss(*),wrk(*),monoc(mxrt),
     *        monvr(mxrt),icst(mxrt),iexcit(5),eexfg(2,nfg,mxrt),CTDM(*)
c
      l2=(l1*l1+l1)/2
      l3=l1*l1
      call daread(IDAF,IODA,ss,l2,12,0) 
      call daread(IDAF,IODA,vecnew,l3,15,0)
      IF (iexcit(4).EQ.0) THEN
       DO I=1,mxrt
        ICST(I)=I
       ENDDO 
       RETURN
      ENDIF
c
c     -- FIND ORBITALS CORRESPOINDING TO MONOC AND MONVR
c
      call viclr(ICST,1,mxrt)
      NSTMAXM=NSTMONO
      IF(NSTMAXM.GT.mxrt) NSTMAXM=mxrt
      NSTMAXD=NSTAT
      IF(NSTMAXD.GT.mxrt) NSTMAXD=mxrt
      if(maswrk) WRITE(IW,*) 'Dimer -> monomer excitation matching...' 
      if(iexcit(4).eq.1) then
      DO ISTM=1,NSTMAXM
c      WRITE(IW,*)'MONOC/MONVR IN ISTMONO=',MONOC(ISTM),MONVR(ISTM)
       call orbchck(vecold,vecnew,ss,wrk,MONOC(ISTM),MONOCD,l0,L1,overc)
       call orbchck(vecold,vecnew,ss,wrk,MONVR(ISTM),MONVRD,l0,L1,overv)
       DO ISTD=1,NSTMAXD
        if((MONOCD.EQ.MOCC(ISTD)).AND.(MONVRD.EQ.MVIR(ISTD))) then
         ICST(ISTM)=ISTD
c        eexfg(2,idfg,ISTM)=overc*overv
         if(maswrk) WRITE(IW,9000) ISTM,ISTD
        endif
       ENDDO
      ENDDO
      else if(iexcit(4).eq.2) then
        CALL VALFM(LOADFM)
        lctdd=LOADFM+1
        lsumd=lctdd+noccd*nvird*NSTAT
        last=lsumd+NSTMAXD
        NEED = LAST- LOADFM -1
        CALL GETFM(NEED)
c       vecnew is used as an integer array of size of L1. 
        do i=1,noccm+nvirm
          call orbchck(vecold,vecnew,ss,wrk,i,id,l0,L1,wrk(i+l1))
          call ixstor(wrk(1+l1*2),i,id)
        enddo
        CALL DAREAD(IDAF,IODA,x(lCTDD),noccd*nvird*NSTAT,471,0)
        do istm=1,NSTMAXM 
          call exmatch(noccm,nvirm,noccd,nvird,NSTMAXM,NSTMAXD,CTDM,
     *                x(lCTDD),wrk(1+l1*2),wrk(1+l1),istm,istd,
     *                x(lsumd),confid)
          if(confid.ge.exfid) then
            ICST(istm)=istd
            if(maswrk) WRITE(IW,9000) ISTM,ISTD
            eexfg(2,idfg,istm)=confid
          endif
c         if(maswrk.and.iand(iexcit(5),1).ne.0) then
          if(maswrk) then
            write(iw,9100) (i,abs(x(lsumd-1+i))*1.0D+02,i=1,NSTMAXD)
          endif
        enddo
        CALL RETFM(NEED)
      endif
      return
 9000 format(1x,'Monomer state',I4,' matched to dimer state',I4)
 9100 format(5x,'State',I4,', confidence=',F5.1)
      END
C*MODULE fmolib  *DECK orbchk
      subroutine orbchck(vecold,vecnew,ss,wrk,ITH,JTH,l0,L1,ovmax)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (ZERO=0.0D+00)
      logical GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      dimension vecold(l1,*),vecnew(l1,*),ss(*),wrk(l1)
c
c     Find one orbital in vecnew having maximum overlap with 
c     the Ith orbital in the VECold
c
      call MTARBR(ss,l1,vecold(1,ITH),1,wrk,l1,1)
c
c     ovbig=0.5D+00
      JTH=0
      ovmax=zero
c     Orbitals after l0 are UNDEFINED.
      do 100 j=1,l0
          over=ddot(l1,vecnew(1,j),1,wrk,1)
          if(abs(over).gt.abs(ovmax)) then
            JTH=j
            ovmax=over 
          endif
c         if(over.gt.ovbig) goto 200
  100 continue
c 200 continue
      if(maswrk) write(iw,9000) ITH,ovmax,JTH
c
      return
 9000 format(1X,'Orbital',I4,' has overlap',F8.4,' with',I4)
      END
C*MODULE fmolib  *DECK exmatch
      subroutine exmatch(noccm,nvirm,noccd,nvird,nstm,nstd,CTDM,CTDD,
     *                   mmod,overd,istm,istd,sumd,confid)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension CTDM(noccm,nvirm,nstm),CTDD(noccd,nvird,nstd),
     *          mmod(*),overd(*),sumd(*)
c
c     Skip orbitals that have not been matched (at present, all should be).
c
      call vclr(sumd,1,nstd)
      do iocc=1,noccm
        ioccd=mmod(iocc)
        if(ioccd.ne.0) then
          do ivir=1,nvirm
            ivird=mmod(ivir+noccm)-noccd
            if(ivird+noccd.ne.0) then
              cm=CTDM(iocc,ivir,istm)*overd(iocc)*overd(ivir+noccm)
              do istd=1,nstd
                sumd(istd)=sumd(istd)+cm*CTDD(ioccd,ivird,istd)
c               if(abs(cm*CTDD(ioccd,ivird,istd)).gt.0.1d+00)
c               if(istd.eq.3)
c    *            write(6,*) 'wwwa',istd,iocc,ivir,ioccd,ivird,
c    *            CTDM(iocc,ivir,istm),
c    *            CTDD(ioccd,ivird,istd),overd(iocc),overd(ivir+noccm)
              enddo
            endif
          enddo
        endif
      enddo
c     write(6,*) 'wwwi',istm,'=',(sumd(i),i=1,nstd)
      istd=idamax(nstd,sumd,1)
      confid=abs(sumd(istd))
      return
      END
c
C*MODULE FMOlib  *DECK MCPFMOCK
      SUBROUTINE MCPFMOCK
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MCPFMO/ IMCPFMO,LFZCOR,LIFMPTYP,LIFMPTYP2,LMCPSW,
     *                LIZCOR2,imp0,jmp0,icorsh0,igtf0
      COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEXTFLD
C
      IMCPFMO  = 0
      IF (IECP.EQ.5) THEN
        IEOF = 0
        CALL SEQREW(IR)
        CALL FNDGRP(IR,' $FMO   ',IEOF)
        IF (IEOF.NE.0) THEN
          RETURN
        ELSE
          IMCPFMO  = 1
        END IF
      END IF
C
      RETURN
      END
C*MODULE FMOlib  *DECK MCPFALOC
      SUBROUTINE MCPFALOC(LAST)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /MCPFMO/ IMCPFMO,LFZCOR,LIFMPTYP,LIFMPTYP2,LMCPSW,
     *                LIZCOR2,imp0,jmp0,icorsh0,igtf0
C
      IF (IMCPFMO.EQ.1) THEN
        LFZCOR    = LAST
        LIFMPTYP  = LFZCOR    +  NATFMO
        LIFMPTYP2 = LIFMPTYP  + (NATFMO-1)/NWDVAR + 1
        LMCPSW    = LIFMPTYP2 + (NATFMO + NBDFG-1)/NWDVAR + 1
        LIZCOR2   = LMCPSW    + (NFG -1)/NWDVAR + 1
        LAST      = LIZCOR2   + (NATFMO + NBDFG-1)/NWDVAR + 1
      ELSE
        LFZCOR    = LAST
        LIFMPTYP  = LAST
        LIFMPTYP2 = LAST
        RETURN
      END IF
C
C     write (6,*) 'MCPFALOC',LFZCOR,LIFMPTYP,LIFMPTYP2
      RETURN
      END
C*MODULE FMOlib  *DECK MCPPRPR
      SUBROUTINE MCPPRPR(FMOZAN,INDFRG,NAT0FRG,NATFRG,IATFRG,
     *                   FZCOR,IZCOR2,IFMPTYP,IFMPTYP2,MCPSW)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION FMOZAN(*),INDFRG(*),NAT0FRG(*),NATFRG(*),IATFRG(*)
      DIMENSION FZCOR(*),IZCOR2(*),IFMPTYP(*),IFMPTYP2(*),MCPSW(*)
C
      PARAMETER (MAXL=5,MaxLay=5,MXSFMO=MaxLay*40,MXGFMO=MaxLay*100,
     *           MXAFMO=MaxLay*10)
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      common /fmoshl/ fzan(MXAFMO),fEX(MXGFMO),fC(MXGFMO,MAXL),
     *                LSTART(MXSFMO),LATOM(MXSFMO),LTYPE(MXSFMO),
     *                LNG(MXSFMO),LMIN(MXSFMO),LMAX(MXSFMO),llay(MXAFMO)
     *               ,lmptyp(mxafmo),lzcore(mxafmo),lshell,natl,numl
C
C     This routine must be called before data in $DATA is replaced.
C
C     write (6,*) 'IN MCPPRPR', (IZCORE(I),I=1,NAT)
      CALL  VCLR(FZCOR,  1,NATFMO)
      CALL VICLR(IFMPTYP,1,NATFMO)
      DO I = 1, NATFMO
        DO J = 1, NATL
          IF (LMPTYP(J).NE.0) THEN
            IF (INT(FZAN(J)+0.1D+00).EQ.INT(FMOZAN(I)+0.1D+00)) THEN
              FZCOR(I)   = LZCORE(J)
              IFMPTYP(I) = LMPTYP(J)
            END IF
          END IF
        END DO
      END DO
c     write (6,*) 'FZCORE', (FZCOR(I), I=1,NATFMO)
C     write (6,*) 'IFMPTYP', (IFMPTYP(I),I=1,NATFMO)
C     write (6,*) 'MPTYP', (MPTYP(I),I=1,NAT)
C
      CALL VICLR(IZCOR2,  1,NATFMO+NBDFG)
      CALL VICLR(IFMPTYP2,1,NATFMO+NBDFG)
C      write (6,*) 'LIFMPTYP2', LIFMPTYP2
C
C     IFMPTYP CONTAINS MPTYP VALUES CORRESPONDING TO FMO ATOMS IN $FMOXYZ
C     IFMPTYP2 CONTAINS ARRANGED VALUES FOR FMO FRAGMENTS
C
      IC = 0
      DO IFG = 1, NFG
        ISWTCH = 0
        NST = INDFRG(IFG)
        NED = NST + NAT0FRG(IFG) - 1
        DO J = NST, NED
          IC = IC + 1
          ICC = IATFRG(IC)
          IFMPTYP2(IC) = IFMPTYP(ICC)
          IZCOR2(IC)   = INT(FZCOR(ICC)+0.01D+00)
          ISWTCH = ISWTCH + IFMPTYP2(IC)
        END DO
C
        NST = NED + 1
        NED = NST + NATFRG(IFG) - NAT0FRG(IFG) - 1
        DO J = NST, NED
          IC = IC + 1
          ICC = IATFRG(IC)
          IFMPTYP2(IC) = IFMPTYP(ICC)
          IZCOR2(IC)   = 0
          ISWTCH = ISWTCH + IFMPTYP2(IC)
        END DO
        MCPSW(IFG) = ISWTCH
      END DO
C     write (6,*) 'FMPTYP2', (IFMPTYP2(I),I=1,NATFMO+NBDFG)
C
      RETURN
      END
C*MODULE FMOlib  *DECK ADDMCP
      SUBROUTINE ADDMCP(NATI,INDI)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000)
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /MMPDOC/ MPTYP(MXATM),IMVO,IMCORE
      COMMON /ECP2  / CLP(400),ZLP(400),NLP(400),KFRST(MXATM,6),
     *                KLAST(MXATM,6),LMAXE(MXATM),LPSKIP(MXATM),
     *                IZCORE(MXATM)
      COMMON /MCPFMO/ IMCPFMO,LFZCOR,LIFMPTYP,LIFMPTYP2,LMCPSW,
     *                LIZCOR2,imp0,jmp0,icorsh0,igtf0
C
C     THIS ROUTINE MUST BE CALLED JUST BEFORE ADDFRG
C
      II=NAT+1
c     CALL ICOPY(NATI,X(LIFMPTYP2+INDI-1),1,MPTYP(II),1)
c     CALL ICOPY(NATI,X(LIZCOR2+INDI-1),1,IZCORE(II),1)
      DO I = 1, NATI
        III = I-1
         MPTYP(II+III) = IXFTCH(X(LIFMPTYP2),INDI+III)
        IZCORE(II+III) = IXFTCH(  X(LIZCOR2),INDI+III)
      END DO
C
      RETURN
      END
C*MODULE fmolib  *DECK makelmo
      subroutine makelmo(ilay,iter,ichfg,indat,fmozan,fmoc,iaglob,
     *                   iabdfg,jabdfg,idxcao,clmo,ialmo,indlmo,ibuf,
     *                   ilocals,orbxch,naoafo3,naoafod,vafo,dafo,
     *                   timeafo,l1dir)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      Parameter(MXATM=2000,mxrt=100,MXGRID=10,UNITS=0.52917724924D+00,
     *          MAXNZ=137,one=1.0D+00)
      logical ISGDDI,PAROUT,INITGDDI,GOPARR,DSKWRK,MASWRK,DIRTRF,myjob,
     *        DIRSCF,FDIFF,addc,bonded1,bonded2,orbxch,forcedir,fullmul,
     *        cutdiff,SG1,wasgddi
      integer ddi_world,ddi_group
      Parameter(ddi_world=0,ddi_group=1)
      COMMON /DFGRID/ DFTTHR,DFTGTHR,SWOFF,SW0,BSLRD(137),NDFTFG,
     *                NRAD,NTHE,NPHI,NRAD0,NTHE0,NPHI0,
     *                NANGPT(MXGRID),NANGPT0(MXGRID),SG1,JANS
      COMMON /FMCOM / xX(1)
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MMPDOC/ MPTYP(MXATM),IMVO,IMCORE
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SCFOPT/ CONVHF,MAXIT,MCONV,NPUNCH,NPREO(4)
      COMMON /TIMING/ CPU,WALL
      COMMON /TRFOPT/ CUTTRF,NWDTRF,MPTRAN,ITRFAO,NOSYMT,IPURTF,DIRTRF
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo
      dimension ichfg(*),indat(*),fmozan(*),fmoc(3,*),iaglob(*),
     *          iabdfg(*),jabdfg(*),idxcao(maxbnd,*),
     *          clmo(maxbbd,maxabd2,maxlmo,*),
     *          ialmo(2,maxabd2,maxlmo,nbdfg),indlmo(2,nbdfg),
     *          ibuf(natfmo),vafo(naoafo3),dafo(naoafod,*),rh(MAXNZ)
      data rh/0.74,0,   0,   0,   1.19,1.09,1.01,0.96,0.92,0,
     *        0,   0,   0,   1.48,1.44,1.34,1.27,0,   0,   0,
     *        0,0,0,0,0, 0,0,0,0,0,
     *        0,   1.53,1.52,1.46,1.41, 0,0,0,0,0,
     *        0,0,0,0,0, 0,0,0,0,1.70,
     *        0,   1.70,1.61,0,0, 0,0,0,0,0,
     *        77*0/
c     source of common X-H bond lengths: 
c     http://www.wiredchemist.com/chemistry/data/bond_energies_lengths.html
      data energy/8HENERGY  /,rnone/8HNONE    /
c
      call timit(1)
      CALL TSECND(TIMe0)
      wall0=wall
      ifmostps=ifmostp
      ifmostp=-1
c     rback=rflmo(1)
c     rcaps=rflmo(2)
c     rcut2=rcut*rcut
c     rback2=rback*rback
c     rcaps2=rcaps*rcaps
      nbdfgsav=nbdfg
      nbdfg=0
      ilocal=ilocals
      convhfs=convhf
      cuttrfs=cuttrf
      itols=itol
      icuts=icut
      convhf=1.0D-06
      cuttrf=1.0D-09
c     0 value means no diffuse function cutoff ->
c     hence no diffuse function expected
      if(rflmo(4).eq.0) then
        itol=20
        icut=10
      endif
      mplevls=mplevl
      cctyps=cctyp
      cityps=cityp
      tddftyps=tddftyp
      mplevl=0
      cctyp=rnone
      cityp=rnone
      tddftyp=rnone
      NRAD0s=NRAD0
      NPHI0s=NPHI0
      NTHE0s=NTHE0
      swoffs=swoff
      if(maswrk) write(iw,9020) convhfs,convhf,cuttrfs,cuttrf,
     *                          itols,itol,icuts,icut
      call vclr(clmo,1,maxbbd*maxabd2*maxlmo*nbdfgsav)
      call viclr(ialmo,1,2*maxabd2*maxlmo*nbdfgsav)
      call viclr(indlmo,1,2*nbdfgsav)
c     call vclr(elmo,1,2*maxlmo*nbdfgsav)
      ndidlmo=0
      if(naoafo3.gt.0) call vclr(vafo,1,naoafo3)
      fullmul=iand(modlmo,32).ne.0
      cutdiff=rflmo(4).ne.0
      expdiff=rflmo(4)
      if(fullmul) write(6,*) 'Using full Mulliken for criteria.'
c
C     ----- INITIALIZATION FOR PARALLEL WORK -----
C     
      if(isgddi) call GDDICOUNT(-1,lgroup,myjob)
      do 300 ibdfg=1,nbdfgsav
        if(isgddi) then
          call GDDICOUNT(0,lgroup,myjob)
          if(.not.myjob) then
            if(naoafod.gt.0) call vclr(dafo(1,ibdfg),1,naoafod)
            goto 300
          endif
        endif
        ndidlmo=ndidlmo+1
c       write(iw,9000) ibdfg 
        ibda=abs(iabdfg(ibdfg))
        jbda=abs(jabdfg(ibdfg))
c       add the bond 
        nat=1 
        zan(nat)=fmozan(ibda)
        ian(nat)=int(zan(nat)+0.1D+00) 
        call dcopy(3,fmoc(1,ibda),1,c(1,nat),1)
        iaglob(nat)=ibda
        nat=nat+1 
        zan(nat)=fmozan(jbda)
        ian(nat)=int(zan(nat)+0.1D+00) 
        call dcopy(3,fmoc(1,jbda),1,c(1,nat),1)
        iaglob(nat)=jbda
        if(iand(modlmo,64).ne.0) then
          ifg=indat(ibda)
          jfg=indat(jbda)
c         add atoms from the two fragments
          do iat=1,natfmo
            kfg=indat(iat)
            if(iat.ne.ibda.and.iat.ne.jbda.and.
     *         (kfg.eq.ifg.or.kfg.eq.jfg)) then 
              nat=nat+1
              zan(nat)=fmozan(iat)
              ian(nat)=int(zan(nat)+0.1D+00)
              call dcopy(3,fmoc(1,iat),1,c(1,nat),1)
              iaglob(nat)=iat
            endif
          enddo
          noh=0
c         add atoms from the bonds terminating the fragment pair.
          do jbdfg=1,nbdfgsav
            if(jbdfg.ne.ibdfg) then
              ibda2=abs(iabdfg(jbdfg))
              jbda2=abs(jabdfg(jbdfg))
              ifg2=indat(ibda2)
              jfg2=indat(jbda2)
              iat=0 
              jat=0
              if(ifg2.eq.ifg.or.ifg2.eq.jfg) then
                iat=jbda2
                jat=ibda2
              endif
              if(jfg2.eq.ifg.or.jfg2.eq.jfg) then
                iat=ibda2
                jat=jbda2
              endif
              if(iat.ne.0) then
                noh=noh+1
                nat=nat+1
                zan(nat)=1
                ian(nat)=1
                rr1=(fmoc(1,jat)-fmoc(1,iat))**2
     *             +(fmoc(2,jat)-fmoc(2,iat))**2
     *             +(fmoc(3,jat)-fmoc(3,iat))**2
                jz=int(fmozan(jat)+0.1D+00)
                rhi=rh(jz)
                scalef=rhi/UNITS/sqrt(rr1)
                do i=1,3
                  c(i,nat)=fmoc(i,jat)+scalef*(fmoc(i,iat)-fmoc(i,jat))
                enddo
c               call dcopy(3,fmoc(1,iat),1,c(1,nat),1)
                iaglob(nat)=iat
              endif
            endif
          enddo
          ich0=ichfg(ifg)+ichfg(jfg)
          mul0=1
          if(maswrk) write(iw,9030) ibdfg,noh,nat,ICH0,mul0
        else
c       indlmo(1,ibdfg)=ilmo+1 
        call viclr(ibuf,1,natfmo)
        ibuf(ibda)=1
        ibuf(jbda)=2
        r1=rflmo(1)
        r2=rflmo(1)
        if(iand(modlmo,32768).ne.0) r1=0.1D+00
        if(iand(modlmo,131072).ne.0) r2=0.1D+00
c       look for close contacts of BDA 
        do iat=1,natfmo
          if(ibuf(iat).eq.0) then
c         x=fmoc(1,iat) 
c         y=fmoc(2,iat) 
c         z=fmoc(3,iat) 
          iani=int(fmozan(iat)+0.1D+00)
          call pairbond(c(1,1),fmoc(1,iat),ian(1),iani,r1,bonded1)
          call pairbond(c(1,2),fmoc(1,iat),ian(2),iani,r2,bonded2)
c         rr1=(c(1,1)-x)**2+(c(2,1)-y)**2+(c(3,1)-z)**2
c         rr2=(c(1,2)-x)**2+(c(2,2)-y)**2+(c(3,2)-z)**2
c         if(rr1.lt.rback2.or.rr2.lt.rback2) then 
          if(bonded1.or.bonded2) then
            nat=nat+1
            zan(nat)=fmozan(iat)
            ian(nat)=int(zan(nat)+0.1D+00) 
            call dcopy(3,fmoc(1,iat),1,c(1,nat),1)
            ibuf(iat)=nat
            iaglob(nat)=iat
c           write(6,*) 'wwwadding',bonded1,bonded2,iat,nat
          endif 
          endif 
        enddo 
c       add H caps to terminal atoms
        nat0=nat
        noldh=0
        do 100 iat=1,natfmo
          if(ibuf(iat).eq.0) then
            iani=int(fmozan(iat)+0.1D+00)
            do jat=1,nat0
c             if(rr1.lt.rcaps2) then
              call pairbond(c(1,jat),fmoc(1,iat),ian(jat),iani,rflmo(2),
     *                      bonded1)
              if(bonded1) then
              rr1=(c(1,jat)-fmoc(1,iat))**2+(c(2,jat)-fmoc(2,iat))**2
     *           +(c(3,jat)-fmoc(3,iat))**2
                nat=nat+1
                zan(nat)=1
                ian(nat)=1
c               call dcopy(3,fmoc(1,iat),1,c(1,nat),1)
                jz=int(zan(jat)+0.1D+00)
                iz=int(fmozan(iat)+0.1D+00)
                rhi=rh(jz)
                if(rhi.eq.0) then
                  rhi=1.6D+00
                  if(maswrk) write(iw,9010) jz,rhi
                endif
c               jz=1 means the atom to be capped is hydrogen! 
                if(jz.ne.1) then 
                  scalef=rhi/UNITS/sqrt(rr1)
c                 For original hydrogens put as caps use their pristine
c                 coordinates.
                  if(iz.eq.1) then
                    scalef=1 
                    noldh=noldh+1
                  endif
                  if(scalef.lt.1.0D-06) call abrt
                  do i=1,3
                    c(i,nat)=c(i,jat)+scalef*(fmoc(i,iat)-c(i,jat))
                  enddo
c        write(6,*) 'Saving',iat,nat,fmoc(1,iat),fmoc(2,iat),fmoc(3,iat)
                  ibuf(iat)=nat
                  iaglob(nat)=iat
                  goto 100 
                endif
              endif
            enddo
          endif
  100   continue
        ich0=idxcao(ibdfg,nlayer+1)
        mul0=idxcao(ibdfg,nlayer+2)
        if(maswrk) write(iw,9030) ibdfg,nat-nat0-noldh,nat,ICH0,mul0
        endif
        if(maswrk) write(iw,9200) 
     *    (iaglob(k),zan(k),(c(jj,k)*units,jj=1,3),k=1,nat)
c       do iat=1,nat
c         write(6,*) 'wwwZ',iat,iaglob(iat),zan(iat)
c       enddo
c       call abrt
c       make a fake ifg used for print-out in makmol
        ifg=min(ibdfg,nfg)
        call CLOSDA('DELETE')
        CALL OPENDA(0)
        NEVALS=0
        if(naoafod.gt.0) NEVALS=iter-1
c       The meaning is:
c       iter=0 do Huckel guess (inside BRNCHX)
c       iter>0 do a restart
c
c       The trick to run multiple basis sets is to define H atom basis set
c       for those heavy atoms in place of which H caps are added.
c
        call makemol(ifg,0,0,ilay,2,0,0,0,0,ich0,mul0,.true.)
        l1=num
        l2=(l1*l1+l1)/2
        l3=l1*l1
        if(naoafo3.gt.0.and.l3.gt.naoafo3) then
           if(maswrk) write(iw,9080) l1 
           call abrt
        endif 
c
        if(iter.gt.1.and.naoafod.gt.0) then
          if(orbxch) then 
            call dawrit(IDAF,IODA,dafo(1,ibdfg),L3,15,0) 
            call DMTX2(vafo,dafo(1,ibdfg),na,l1,l1,nb)
            call dawrit(IDAF,IODA,vafo,L2,16,0)
            call vclr(vafo,1,l1)
            call dawrit(IDAF,IODA,vafo,L1,17,0)
          else
c           write 0 MO vector and energies for SOSCF.
            call dawrit(IDAF,IODA,vafo,L3,15,0)
            call dawrit(IDAF,IODA,dafo(1,ibdfg),L2,16,0) 
            call dawrit(IDAF,IODA,vafo,L1,17,0)
          endif
          NRAD0=NRAD
          NPHI0=NPHI
          NTHE0=NTHE
          swoff=0
        endif
c
        if(forcedir(l1dir,l1,maswrk).or.ilocal.eq.2) then
          DIRSCF=.true.
          FDIFF=.true.
        endif
c
c       SYMORB is needed for Ruedenberg localisation, because it needs
c       symmetry labels.
c
        CALL BRNCHX(energy)
c
        if(naoafod.gt.0) then
          if(orbxch) then
            call daread(IDAF,IODA,dafo(1,ibdfg),L3,15,0)
            if(.not.maswrk) call vclr(dafo(1,ibdfg),1,l3)
          else
            call daread(IDAF,IODA,dafo(1,ibdfg),L2,16,0)
            if(.not.maswrk) call vclr(dafo(1,ibdfg),1,l2)
          endif
        endif
c
        CALL LMOINP
        CALL LMOX
c       IJKT=IPK
c       if(ilocals.eq.2) CALL SEQCLO(IJKT,'DELETE')
c
        if(maswrk) write(iw,9070) iter,ibdfg,etot
c
c       Finally, match LMOs to find the interesting ones.
c
        CALL VALFM(LOADFM)
        lvv=LOADFM+1
        lss=lvv+l3
        lvi=lss+l2
        lover=lvi+l1*2
        lilmo=lover+l1
        lflmo=lilmo+l1
        last=lflmo+l2
        NEED = LAST- LOADFM -1
        CALL GETFM(NEED)
        call daread(IDAF,IODA,xx(lvv),l3,71,0)
c       call daread(IDAF,IODA,xx(lss),l2,14,0)
c       CALL TFTRI(xx(lflmo),xx(lss),xx(lvv),xx(lilmo),na,l1,l1)
c
        call daread(IDAF,IODA,xx(lss),l2,12,0)
c       na2=(na*na+na)/2
c       na is the number of localised MO 
c       if(ilocal.eq.2) CALL DAread(IDAF,IODA,xx(lflmo),na2,285,0)
        do i=1,na
          xx(lover+i-1)=abs(critloc(l1,1,xx(lvv+(i-1)*l1),
     *                      xx(lss),fullmul,cutdiff,expdiff))
        enddo
        izc=ian(1)-int(zan(1)+0.1D+00)
        nlmo=lmoatom(ian(1),MPTYP(1),izc)
        if(nlmo.gt.maxlmo) then
          if(maswrk) write(iw,*) 'Increase maxlmo',nlmo,maxlmo
          call abrt
        endif
        do i=1,nlmo
          ilmo=idamax(na,xx(lover),1)
          call ixstor(xx(lilmo),i,ilmo)
c         ind=(ilmo*ilmo+ilmo)/2
c         elmo(1,i,ibdfg)=xx(lflmo+ind-1)
          if(maswrk) write(iw,9040) ibdfg,ilmo,xx(lover+ilmo-1)
c    *                              elmo(1,i,ibdfg)
          xx(lover+ilmo-1)=0
        enddo
        ilmo=idamax(na,xx(lover),1)
        if(maswrk) write(iw,9050) ibdfg,ilmo,xx(lover+ilmo-1)
c
c       Find the special bond
c
        do jlmo=1,nlmo
          i=ixftch(xx(lilmo),jlmo)
          xx(lover+jlmo-1)=abs(critloc(l1,2,xx(lvv+(i-1)*l1),xx(lss),
     *                         fullmul,cutdiff,expdiff))
        enddo
        jlmos=idamax(nlmo,xx(lover),1)
        jlmo=ixftch(xx(lilmo),jlmos)
        if(maswrk) write(iw,9060) ibdfg,jlmo,xx(lover+jlmos-1)
        xx(lover+jlmos-1)=0
        ilmo=idamax(nlmo,xx(lover),1)
        i=ixftch(xx(lilmo),ilmo)
        if(maswrk) write(iw,9065) ibdfg,i,xx(lover+ilmo-1)
c       if(iand(modlmo,4194304).ne.0) then
c         jlmos=ilmo
c         if(maswrk) write(iw,*) "Changing the special orbital to",i
c       endif
c
        do jlmo=1,nlmo
          i=ixftch(xx(lilmo),jlmo)
c         if(over.gt.scut) then
c         check if it is the "special" one (between atoms 1 and 2)
c         over2=abs(critloc(l1,2,xx(lvv+(i-1)*l1),xx(lss),fullmul))
c         call mocoze(2,xx(lvv+(i-1)*l1),xx(lvi))
c         call MTARBR(xx(lss),l1,xx(lvi),1,xx(lvi+l1),l1,1)
c         over2=ddot(l1,xx(lvi),1,xx(lvi+l1),1)
c         ilmo=ilmo+1 
c         jlmo=jlmo+1 
c         if(over2.gt.scut) then
c           if(maswrk) write(iw,9060) ibdfg,i
c           if(jlmos.ne.0) call abrt
c           jlmos=jlmo
c         endif
c         find the closest atoms to the BDA
          jat=0
          rstore1=rflmo(3)
c         if(iand(modlmo,3).eq.0) rstore1=rflmo(3)
          rstore2=rstore1
c         if(iand(modlmo,3).eq.0) rstore1=rflmo(3)
          if(iand(modlmo,65536).ne.0) rstore2=0.1D+00
          do iat=1,nat
c           rr1=(c(1,1)-c(1,iat))**2+(c(2,1)-c(2,iat))**2
c    *            +(c(3,1)-c(3,iat))**2
            call pairbond(c(1,1),c(1,iat),ian(1),ian(iat),rstore1,
     *                      bonded1)
            if(iand(modlmo,8).ne.0) then
c             for the special bond LMO only copy atoms 1 and 2, for other LMOs
c             copy atoms except 2. 
c             addc=rr1.lt.rcut2.and.(over2.le.scut.and.iat.ne.2.or.
              addc=bonded1.and.(jlmo.ne.jlmos.and.iat.ne.2.or.
     *                          jlmo.eq.jlmos.and.iat.le.2)
c             addc=bonded1.and.(over2.le.scut.and.iat.ne.2.or.
c    *                          over2.gt.scut.and.iat.le.2)
            else
c             copy all atoms close to atoms 1 and 2
c             rr2=(c(1,2)-c(1,iat))**2+(c(2,2)-c(2,iat))**2
c    *           +(c(3,2)-c(3,iat))**2
              call pairbond(c(1,2),c(1,iat),ian(2),ian(iat),rstore2,
     *                      bonded2)
c             addc=rr1.lt.rcut2.or.rr2.lt.rcut2
              addc=bonded1.or.bonded2
            endif
            if(iand(modlmo,128).ne.0) then
              ifg=indat(ibda)
              iatg=iaglob(iat)
              if(indat(iatg).eq.ifg.and.iatg.ne.ibda) addc=.false.
c             Only allow the left BDA from the left fragment. 
            endif
c           Never consider caps for adding their coefficients
c          if(abs(zan(iat)-fmozan(iaglob(iat))).gt.1.0D-06) addc=.false.
           if(abs(ian(iat)-fmozan(iaglob(iat))).gt.1.0D-06) addc=.false.
            if(addc.and.maswrk) then
c             write(6,*) 'Close atom',jlmo,iat,iaglob(iat)
              jat=jat+1
              if(jat.gt.maxabd2) then
                if(maswrk) write(iw,9090) maxabd2 
                call abrt
              endif
              ialmo(1,jat,jlmo,ibdfg)=iaglob(iat) 
              call mococp(iat,xx(lvv+(i-1)*l1),ialmo(2,jat,jlmo,ibdfg)
     *                   ,clmo(1,jat,jlmo,ibdfg))
c             call prsq(clmo(1,jat,jlmo,ibdfg),ialmo(2,jat,jlmo,ibdfg),1,1)
              if(ialmo(2,jat,jlmo,ibdfg).gt.maxbbd) then
                if(maswrk) write(iw,*) 'Increase maxbbd',
     *                                 ialmo(2,jat,jlmo,ibdfg),maxbbd
                call abrt
              endif
            endif
          enddo
c         exchange orbitals (special <-> 1) 
c         ilmo1=indlmo(1,ibdfg)
          if(jlmo.eq.jlmos.and.jlmos.ne.1.and.maswrk) then
            call dswap(maxbbd*maxabd2,clmo(1,1,1,ibdfg),1,
     *                                clmo(1,1,jlmos,ibdfg),1)
            call iswap(2*maxabd2,ialmo(1,1,1,ibdfg),1,
     *                           ialmo(1,1,jlmos,ibdfg),1)
c           call dswap(1,elmo(1,1,ibdfg),1,elmo(1,jlmos,ibdfg),1)
          endif
c         endif
        enddo
        if(jlmos.eq.0) then
          if(maswrk) write(iw,*) 'No special bond found'
          call abrt
        endif
        if(maswrk) indlmo(1,ibdfg)=nlmo
c       Occupied LMOs done, now proceed to the virtuals.
        if(iand(modlmo,2097152).ne.0.and.maswrk) then
c         call dacopy(l1,one,xx(lvi+1),1) 
c         call mocoze(1,xx(lvi+1),xx(lvi))
c         get a fake LCAO vector consisiting of 1's for all basis functions
c         on atom 1.
c         Copy 1 set to get nbf1. 
          nbf1=ialmo(2,1,1,ibdfg)
c         jlmo=nlmo+1 
c         ialmo(1,1,jlmo,ibdfg)=iaglob(1)
c         call mococp(1,xx(lvi),nbf1,clmo(1,1,jlmo,ibdfg))
c         ialmo(2,1,jlmo,ibdfg)=nbf1
c         if(nbf1.gt.maxlmo) call abrt
c         set natd=1 to remove the diffuse from the left atom only 
          natd=2
          if(nlmo+4*natd.gt.maxlmo) call abrt
          do iatd=1,natd
          jlmoe=nlmo+4
          iao=9
c         These settings are for 6-31++G**.
          do jlmo=nlmo+1,jlmoe
             ialmo(1,1,jlmo,ibdfg)=iaglob(iatd)
             call vclr(xx(lvi),1,nbf1)
             iao=iao+1
             xx(lvi+iao-1)=one
             ialmo(2,1,jlmo,ibdfg)=nbf1
             call dcopy(nbf1,xx(lvi),1,clmo(1,1,jlmo,ibdfg),1) 
c            call mococp(1,xx(lvi),ialmo(2,1,jlmo,ibdfg),
c    *                   clmo(1,1,jlmo,ibdfg))
          enddo
          nlmo=nlmo+4
          enddo
c         write(6,*) 'added',nbf1-indlmo(1,ibdfg),' virtuals'
c         indlmo(1,ibdfg)=nbf1
          indlmo(1,ibdfg)=nlmo
          indlmo(2,ibdfg)=4*natd
          if(maswrk) write(iw,*) 'added',indlmo(2,ibdfg),' virtuals'
        endif
        CALL RETFM(NEED)
  300 continue 
      nbdfg=nbdfgsav
      if(isgddi) then
        call GDDICOUNT( 1,lgroup,myjob)
        call gddi_scope(ddi_world)
        CALL DDI_GSUMF(2414,clmo,maxbbd*maxabd2*maxlmo*nbdfg)
        CALL DDI_GSUMI(2414,ialmo,2*maxabd2*maxlmo*nbdfg)
        CALL DDI_GSUMI(2414,indlmo,2*nbdfg)
        if(naoafod.gt.0) CALL DDI_GSUMF(2414,dafo,naoafod*nbdfg)
c       CALL DDI_GSUMF(2414,elmo,2*maxlmo*nbdfg)
        call gddi_scope(ddi_group)
      endif
      ilocal=0
      NRAD0=NRAD0s
      NPHI0=NPHI0s
      NTHE0=NTHE0s
      swoff=swoffs
      mplevl=mplevls
      cctyp=cctyps
      cityp=cityps
      tddftyp=tddftyps
      convhf=convhfs
      cuttrf=cuttrfs
      itol=itols
      icut=icuts
      ifmostp=ifmostps
      if(maswrk) write(iw,9025)
c     if(maswrk) write(iw,9020) convhfs,convhf,cuttrfs,cuttrf,
c    *                          itols,itol,icuts,icut
      call timit(1)
      CALL TSECND(TIMe1)
      timeafo=wall-wall0
      if(maswrk) write(iw,9100) iter,ndidlmo,timeafo
      return
c9000 format(/1x,'Computing LMOs for bond',I5)
 9010 format(1x,'No X-H bond length is defined for X, Z=',I3,
     *          ', using ',F4.2)
 9020 format(/1x,'Changing the thresholds:',
     *       /1x,'CONV=',2E8.1,' CUTTRF=',2E8.1,' ITOL=',2I3,' ICUT=',
     *           2I3,/)
 9025 format(/1x,'The thresholds are restored.')
 9030 format(/1x,'Bond ',I5,' :',I3,' caps added,',I5,
     *           ' atoms total. Charge',I3,' , multiplicity',I2,' .')
 9040 format(1x,'Bond ',I5,' : LMO',I5,' has overlap',F10.6)
 9050 format(1x,'Bond ',I5,' : the first discarded LMO',I5,
     *          ' has overlap',F10.6)
 9060 format(1x,'Bond ',I5,' : LMO',I5,' is the detached bond orbital,',
     *          ' overlap=',F10.6)
 9065 format(1x,'Bond ',I5,' : the closest to the detached bond LMO',I5,
     *          ' has overlap',F10.6)
 9070 format(/1x,'Iteration',I4,': model system for bond',I5,' has E=',
     *          F18.10,/)
 9080 format(/1x,'Increase NAOAFO at least to',I6)
 9090 format(/1x,'Internal storage overflow, maxabd2=',I6) 
 9100 format(/1x,'Iteration',I4,':',I5,' bond AFO construction took',
     *           F10.1,' seconds.')
 9200 format(100(I5,F10.5,3F15.8,/))
      END
C*MODULE fmolib  *DECK mococp
      subroutine mococp(iat,cmo,naoat,cmoat)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension cmo(*),cmoat(*) 
      PARAMETER (MXSH=5000, MXGTOT=20000)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
c
      naoat=0
      do ii=1,nshell
        mini=kmin(ii)
        maxi=kmax(ii)
        loci=kloc(ii)
        do i=mini,maxi
          if(katom(ii).eq.iat) then
            naoat=naoat+1
            cmoat(naoat)=cmo(loci)
          endif
          loci=loci+1
        enddo
      enddo
      return
      END
C*MODULE fmolib  *DECK flmovec 
      SUBROUTINE flmovec(indat,iaglob,iabdfg,jabdfg,clmo,ialmo,indlmo,
     *                   l1,vv,dd,ee,iwrk,iwrk2,noflmo,nflmo,lmobdf)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXSH=5000,MXGTOT=20000,MXATM=2000)
      integer rightend
      logical some,GOPARR,DSKWRK,MASWRK,occupied
      character*1 symafo
      COMMON /ECP2  / CLP(400),ZLP(400),NLP(400),KFRST(MXATM,6),
     *                KLAST(MXATM,6),LMAXE(MXATM),LPSKIP(MXATM),
     *                IZCORE(MXATM)
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo
      dimension indat(*),iaglob(*),iabdfg(*),jabdfg(*),
     *          clmo(maxbbd,maxabd2,maxlmo,*),ialmo(2,maxabd2,maxlmo,*),
     *          indlmo(2,nbdfg),vv(l1,l1),dd(*),ee(l1),iwrk(l1),
     *          iwrk2(l1),lmobdf(*)
      data dbgfmo/8HDBGFMO  /,dbgme/8HFLMOVEC /,debug/8HDEBUG   /
c
      nflmo=0
      noflmo=0
      if(nbdfg.eq.0) return
      some=(exetyp.eq.debug.or.exetyp.eq.dbgfmo.or.exetyp.eq.dbgme).and.
     *     maswrk
      if(maswrk) write(iw,9000)
c
      l2=(l1*l1+l1)/2
      l3=l1*l1
      call vclr(vv,1,l3)
      call vclr(ee,1,l1)
      call viclr(iwrk,1,l1)
      do 300 ibdfg=1,nbdfg
c       atoms between which the bond is cut. 
        ierr=0
        if(iabdfg(ibdfg).lt.0) then
          leftend=-iabdfg(ibdfg)
          rightend=jabdfg(ibdfg)
          if(rightend.lt.0) ierr=1 
        else if(jabdfg(ibdfg).lt.0) then
          leftend=-jabdfg(ibdfg)
          rightend=iabdfg(ibdfg)
        else
          ierr=1
        endif
        if(ierr.ne.0) then
          write(iw,*)'Confusion in FLMOVEC:',iabdfg(ibdfg),jabdfg(ibdfg)
          call abrt
        endif
c       find the negative side; that is where the basis set for the overlaps
c       (positive one has a ghost atom added at the negative side so we 
c       always want the negative side).
c       is located.
        ial0=0
        ial=0
        iar=0
c       do not accept bonds that are fully inside a dimer (in which case
c       atomic charges are not modified), that is, only work with split atoms
c       having Z-1 and 1 charges.
        do iat=1,nat 
          izat=int(zan(iat)+1.0D-02)+IZCORE(iat)
          if(iaglob(iat).eq.leftend) ial0=iat
          if(izat.ne.ian(iat)) then
            if(iaglob(iat).eq.leftend) ial=iat
            if(iaglob(iat).eq.rightend.and.izat.ne.1) iar=iat
c           izat.ne.1 guards against false propagation when a ghost atom
c           attracts a second broken bond it is involved in.
          endif
        enddo
c       enforce precedence of the left end if both are there and the left end
c       is Z-1. This is neccessary for complicated cases when an atom is
c       involved into two bonds with different ends, e.g.
c       -1 2
c       -2 3
        jat=0
        if(ial.ne.0) then
          jat=ial
        else
          jat=iar
        endif 
c       the left end should be a ghost atom if the right end is in 
c       otherwise the whole bond is inside and it does contribute
c       write(6,*) 'wwwhuhu',jat,iar,ial0,zan(ial0),iat 
c       if(iar.ne.0.and.ial0.ne.0.and.int(zan(ial0)+1.0D-02).ne.1) jat=0
        if(iar.ne.0.and.ial0.ne.0) then
          if(int(zan(ial0)+1.0D-02)+IZCORE(ial0).ne.1) jat=0
        endif
        if(jat.ne.0) then
          iside=0
          if(int(zan(jat)+1.0D-02)+IZCORE(JAT).eq.1) iside=1
          if(some) write(6,*) 'Found bond',ibdfg,jat
c         ilmo=indlmo(1,ibdfg)
          nmo=indlmo(1,ibdfg)
          ndmo=indlmo(2,ibdfg)
          nblmo=1
c         nblmo is the number of special ("bond") LMO along the fractioned bond
c         if(iside.eq.0) then
c           imob=nblmo+1
c           imoe=nmo
c           ilmo=ilmo+nblmo
c         else
c           imob=1
c           imoe=nblmo
c         endif
          imob=1
          imoe=nmo
          if(iside.eq.0.and.iand(modlmo,4).eq.0) imoe=nblmo
c         Uncomment one line below to project out diffuse on the left side 
c         if(iside.eq.0.and.iand(modlmo,32).ne.0.and.ndmo.ne.0) imoe=nmo
          if(iside.eq.0.and.iand(modlmo,2097152).ne.0.and.ndmo.ne.0) 
     *      imoe=nmo-ndmo/2
c         ndmo/2 only removes diffuse on the left atom for the left fragment
c         go back to imoe=nmo for some alternative. 
          do 200 imo=imob,imoe
c           proceed from the occupied to the diffuse skipping the virtuals
            if(iside.eq.0.and.iand(modlmo,2097152).ne.0.and.
     *         imo.gt.nblmo.and.imo.le.nmo-ndmo) goto 200
c    *         imo.gt.nblmo.and.imo.le.nmo-ndmo) goto 200
c           Skip occupied for converged SCC
            if(iside.eq.1.and.iand(modlmo,16384).ne.0.and.idoprop.gt.0
     *         .and.imo.le.nblmo) goto 200
            if(some) write(6,*) '  Found i-LMO',imo,ibdfg
            nflmo=nflmo+1
            lmobdf(nflmo)=indat(leftend)
            occupied=iside.eq.0.and.imo.gt.nblmo.or.
     *               iside.eq.1.and.imo.le.nblmo
            ias=0
            maxia=maxabd2
c         if(iand(modlmo,128).ne.0.and..not.occupied) maxia=min(maxia,2)
            do ia=1,maxia
              ibda=ialmo(1,ia,imo,ibdfg)
              if(ibda.ne.0) then
                if(some) write(6,*) 'AOs',imo,ibdfg,ia,ibda
                nbbda=ialmo(2,ia,imo,ibdfg)
c               find the atom from LMO in the current n-mer
                do ja=1,nat 
                  if(iaglob(ja).eq.ibda) then
                    if(some) write(6,*) 'Copy block',ja,iaglob(ja)
                    ias=ias+1
                    do i=1,nshell
                      if(katom(i).eq.ja) then
                        call dcopy(nbbda,clmo(1,ia,imo,ibdfg),1,
     *                                   vv(kloc(i),nflmo),1)
                        goto 100
                      endif
                    enddo
                  endif
                enddo
  100           continue
              endif
            enddo
c           if(iside.eq.0.and.iand(modlmo,32).ne.0.and.imo.gt.nmo-ndmo)
            if(iand(modlmo,2097152).ne.0.and.imo.gt.nmo-ndmo) then
              ee(nflmo)=orshft*2
            else
              if(occupied) then
c               occupied FLMO
                noflmo=noflmo+1
                iwrk(noflmo)=nflmo
c               ee(nflmo)=elmo(1,imo,ibdfg)
              else
                ee(nflmo)=orshft
              endif
            endif
            symafo='o' 
            if(ee(nflmo).ge.orshft) symafo='v'
            if(maswrk.and.iand(nprfmo,3).eq.0)
     *        write(iw,9010) symafo,nflmo,ibdfg,ias
c           ilmo=ilmo+1
  200     continue
c         write(6,*) 'wwwhereproj',norbproj,ifound
c
        endif
  300 continue
c     if(locsav) return
c     now reorder to push projected out virtual orbitals to the back
      loop=noflmo
      do i=1,nflmo
c       if(ee(i).ne.0.and.ee(i).le.orshft) then
        if(ee(i).eq.orshft) then
          loop=loop+1
          iwrk(loop)=i
        endif
      enddo
c     Finally, handle the diffuse projected out orbitals
      do i=1,nflmo
        if(ee(i).gt.orshft) then
          loop=loop+1
          iwrk(loop)=i
        endif
      enddo
c     call prsq(vv,nflmo,l1,l1)
      call icopy(l1,iwrk,1,iwrk2,1)
      call REORDR(vv,iwrk,nflmo,l1)
c     call prsq(vv,nflmo,l1,l1)
      call REORDR(ee,iwrk2,nflmo,1) 
c     call prsq(ee,nflmo,1,1)
c     To remove virtual projection, uncomment below.
c     nflmo=noflmo
      if(iand(modlmo,256).ne.0) then
        CALL VALFM(LOADFM)
        LD = LOADFM + 1
        LS = LD     + L2
        LAST  = LS   + L3 
        NEED = LAST - LOADFM - 1
        CALL GETFM(NEED)
        CALL daread(IDAF,IODA,x(ld),L2,12,0)
        do i=noflmo+1,nflmo
          CALL TFTRI(ai,x(ld),vv(1,i),iwrk2,1,L1,L1)
          write(6,*) 'norm-',i,'=',ai
          call dscal(l1,1/sqrt(ai),vv(1,i),1)
        enddo
        CALL CPYTSQ(x(ld),x(ls),L1,1)
        call DMTX2(Dd,Vv(1,noflmo+1),nflmo-noflmo,l1,l1,nflmo-noflmo)
cnb     This is probably not right for UHF 
c       call prsq(Vv(1,noflmo+1),nflmo-noflmo,l1,l1)
c       call prtril(dd,l1)
        CALL TFTRI(x(ld),dd,x(ls),iwrk2,L1,L1,L1)
c       call prtril(x(ld),l1)
        CALL DAwrit(IDAF,IODA,x(ld),L2,312,0)
c       Read the Fock matrix and add the projection matrix
        CALL DAread(IDAF,IODA,dd,L2,11,0)
c       call prtril(dd,l1)
        call daxpy(l2,orshft/2,x(ld),1,dd,1)
c       call prtril(dd,l1)
        CALL DAwrit(IDAF,IODA,dd,L2,11,0)
        CALL RETFM(NEED)
        write(iw,*) 'Non-orthogonal virtual AFOs are to be projected.'
c       nflmo=noflmo 
        nflmo=0 
c       call abrt
      endif
      if(iand(modlmo,1024).ne.0) then
        nflmo=0
        noflmo=0
      endif
      if(iand(modlmo,2048).ne.0) nflmo=noflmo
c
      return
 9000 format(/1x,'Preparing AFOs for this system...')
 9010 format(1x,'AFO(',A1,')',I3,' from bond',I5,' spans',I3,' atoms.')
      END
C*MODULE fmolib  *DECK storelmo
      subroutine storelmo(ilay,lmobdf,vec,da,ss,popi,fgflmo,nfglmo,
     *                    lfglmo,pfglmo)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      Parameter(MXATM=2000,MXAO=8192)
      logical MFRZ
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MFRPAR/ MFRZ,NUMFRZ,NORFRZ,IFRZ(MXAO)
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo
      dimension lmobdf(*),vec(*),fgflmo(maxl1,maxslo,*),nfglmo(*),
     *          lfglmo(maxslo,*),pfglmo(maxnat,maxslo,*)
c
      ifmostps=ifmostp
      ifmostp=1
      call vclr(fgflmo,1,maxl1*maxslo*nfg)
      call viclr(nfglmo,1,nfg) 
      call viclr(lfglmo,1,maxslo*nfg)
      call vclr(pfglmo,1,maxnat*maxslo*nfg)
c     fgflmo contains LMOs for a given fragment 
c     nfglmo is their number
c     lfglmo is the left fragment number for each LMO in a fragment
c     (A|-B, A and B are BDAs, then atom A belongs to the left fargment). 
c     pfglmo are atomic populations for each LMO in a fragment. 
c
      do ifg=1,nfg
        call CLOSDA('DELETE')
        CALL OPENDA(0)
        iifg=ifg
        call makemol(iifg,0,0,ilay,0,0,0,0,0,0,0,.true.)
        l1=num
        l2=(l1*l1+l1)/2
        l3=l1*l1
        call oneei
        call orthdn
        write(6,*) 'saving',numfrz,' for frg',ifg
        if(numfrz.gt.maxslo) call abrt
        CALL daread(IDAF,IODA,vec,l3,318,0)
        CALL daread(IDAF,IODA,ss,l2,12,0)
        do i=1,numfrz
          call dcopy(l1,vec((i-1)*l1+1),1,fgflmo(1,i,ifg),1)
          lfglmo(i,ifg)=lmobdf(i)
          write(6,*) '  conn',i,' with',lmobdf(i)
          call DMTX2(da,fgflmo(1,i,ifg),1,l1,l1,1)
cnb       Probably, not right for UHF
          call mulpop(l1,da,ss,popi)
          call mulpopa(popi,pfglmo(1,i,ifg))
        enddo
        nfglmo(ifg)=numfrz
      enddo
      ifmostp=ifmostps
      return
      END
C*MODULE fmolib  *DECK lmoatom
C>
C>     @brief atomic index in LMO 
C>
C>     @details Find atomic index in LMO. 
C>
C>     @author Dmitri Fedorov
C>
      function lmoatom(iz,imcp,izc)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      logical GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2
c
c     Return the number of occupied orbitals in an atom, when it is fully
c     bonded to other atoms. 
c     e.g., for C it would be 1s + 4*(sp3)= 5
c
c     if(maswrk) write(iw,*) 'Experimental code:',iz,imcp,izc
      if(iz.le.2) then 
        lmoatom=1
      else if(iz.le.4) then
        lmoatom=2
      else if(iz.le.10) then
        lmoatom=5
      else if(iz.le.12) then
        lmoatom=6
      else if(iz.le.18) then
        lmoatom=9
      else if(iz.le.20) then
        lmoatom=10
      else if(iz.le.36) then
        lmoatom=13
      else 
        write(6,*) 'Undefined atom in lmoatom'
        call abrt
      endif
      if(imcp.ne.0) then
        lmoatom=lmoatom-izc/2
        if(maswrk) write(iw,*) 'Experimental code 1:',iz,lmoatom,izc/2
      endif
      if(iand(modlmo,4194304).ne.0) then
        lmoatom=maxcao
        if(maswrk) write(iw,*) 'Experimental code 2:',lmoatom
      endif
      return
      END
C*MODULE fmolib  *DECK pairbond
      subroutine pairbond(c1,c2,iz1,iz2,ss,bonded)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION c1(3),c2(3),RCOV(86)
      PARAMETER (TOANGS=0.52917724924D+00)
      logical bonded
C
C      COVALENT RADII FROM J.EMSLEY, "THE ELEMENTS", 2ND EDITION, 1991
C      EXCEPT VAN DER WAALS RADII FOR HE,NE,AR,KR (SAME SOURCE),
C      AND GUESSES FOR NA,V,CR,RB,TC,PM,EU,YB,AT,RN
C
      DATA (RCOV(NUCZ),NUCZ=1,2)/0.30D+00,1.22D+00/
      DATA (RCOV(NUCZ),NUCZ=3,10)
     *  /1.23D+00,0.89D+00,0.88D+00,0.77D+00,
     *   0.70D+00,0.66D+00,0.58D+00,1.60D+00/
      DATA (RCOV(NUCZ),NUCZ=11,18)
     *  /1.66D+00,1.36D+00,1.25D+00,1.17D+00,
     *   1.10D+00,1.04D+00,0.99D+00,1.91D+00/
      DATA (RCOV(NUCZ),NUCZ=19,36)
     *  /2.03D+00,1.74D+00,
     *   1.44D+00,1.32D+00,1.22D+00,1.19D+00,1.17D+00,
     *   1.165D+00,1.16D+00,1.15D+00,1.17D+00,1.25D+00,
     *   1.25D+00,1.22D+00,1.21D+00,1.17D+00,1.14D+00,1.98D+00/
      DATA (RCOV(NUCZ),NUCZ=37,54)
     *  /2.22D+00,1.92D+00,
     *   1.62D+00,1.45D+00,1.34D+00,1.29D+00,1.27D+00,
     *   1.24D+00,1.25D+00,1.28D+00,1.34D+00,1.41D+00,
     *   1.50D+00,1.40D+00,1.41D+00,1.37D+00,1.33D+00,2.09D+00/
      DATA (RCOV(NUCZ),NUCZ=55,86)
     *  /2.35D+00,1.98D+00,
     *   1.69D+00,1.65D+00,1.65D+00,1.64D+00,1.65D+00,1.66D+00,1.65D+00,
     *   1.61D+00,1.59D+00,1.59D+00,1.58D+00,1.57D+00,1.56D+00,1.56D+00,
     *   1.56D+00,1.44D+00,1.34D+00,1.30D+00,1.28D+00,
     *   1.26D+00,1.26D+00,1.29D+00,1.34D+00,1.44D+00,
     *   1.55D+00,1.54D+00,1.52D+00,1.53D+00,1.50D+00,2.20D+00/
c
c    Determine if there is a chemical bond between two atoms, with
c    an allowance factor ss (ss is normally 1.0; if ss<1, then atoms
c    should be closer than their covalent radii). 
c
c    This code is cloned from GTBOND.   
c
      R1 = 1.6D+00
      IF(iz1.EQ.1)               R1 =         RCOV(1)
      IF(iz1.GT.1.AND.iz1.LE.86) R1 = 1.2D+00*RCOV(iz1)
      R2 = 1.6D+00
      IF(iz2.EQ.1)               R2 =         RCOV(1)
      IF(iz2.GT.1.AND.iz2.LE.86) R2 = 1.2D+00*RCOV(iz2)
      DIST = SQRT((C1(1)-C2(1))**2 + (C1(2)-C2(2))**2
     *          + (C1(3)-C2(3))**2) * TOANGS
      BOND = R1 + R2
      bonded=DIST.LE.ss*BOND
c     write(6,*) 'dist=',DIST,ss*BOND,';'
      return
      end
C*MODULE fmolib  *DECK getflmo
      subroutine getflmo(ifg,l1,l2,l3,nlmo,indat,iaglob,ss,vv,nbndfg,
     *                   fgflmo,nfglmo)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      logical GOPARR,DSKWRK,MASWRK,fullmul,cutdiff
      Parameter (MXATM=2000,one=1.0D+00)
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      DIMENSION indat(*),iaglob(*),ss(*),vv(l1,*),
     *          fgflmo(maxl1,nbndfg,*),nfglmo(*)
c
      call daread(IDAF,IODA,vv,l3,71,0)
      call daread(IDAF,IODA,ss,l2,12,0)
      nfglmo(ifg)=0
      fullmul=iand(modlmo,32).ne.0
      cutdiff=rflmo(4).ne.0
      expdiff=rflmo(4)
      do iat=1,nat
c       find ghost atoms
        if(indat(iaglob(iat)).ne.ifg) then
c         find the LMO which is localised most on iat
          over=-one
          jmo=1
          do imo=1,nlmo
c           call mocoze(iat,vv(1,imo),vi)
c           call MTARBR(ss,l1,vi,1,vi(1,2),l1,1)
c           overi=abs(ddot(l1,vi,1,vi(1,2),1))
            overi=abs(critloc(l1,iat,vv(1,imo),ss,fullmul,cutdiff,
     *                expdiff))
            if(overi.gt.over) then
              jmo=imo 
              over=overi
            endif
          enddo
          if(maswrk) write(iw,9050) iat,jmo,over
          call dcopy(l1,vv(1,jmo),1,fgflmo(1,1,ifg),1)
          nfglmo(ifg)=nfglmo(ifg)+1
c         Only one bond per fragment is saved now.
          return
        endif
      enddo
      return
 9050 format(/1x,'Atom ',I5,' : the special LMO',I5,
     *           ' has overlap',F10.6)
      end
C*MODULE FMOlib  *DECK ADDMCP2
      SUBROUTINE ADDMCP2(iaglob,IFMPTYP,FZCOR)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=2000)
      dimension iaglob(*),IFMPTYP(*),FZCOR(*)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /MMPDOC/ MPTYP(MXATM),IMVO,IMCORE
      COMMON /ECP2  / CLP(400),ZLP(400),NLP(400),KFRST(MXATM,6),
     *                KLAST(MXATM,6),LMAXE(MXATM),LPSKIP(MXATM),
     *                IZCORE(MXATM)
C
      DO I=1,NAT
        ig=iaglob(i)
        MPTYP(I)=IFMPTYP(ig)
        IZCORE(I)=INT(FZCOR(ig)+0.1D+00)
c
c       nasty hack: added hydrogen caps are assigned no MCP, no core electrons
c       Since it is not determined here, which hydrogens are which, all
c       are thus ruthlessly doomed. 
c
        if(IAN(i).eq.1) then
          MPTYP(I)=0
          IZCORE(I)=0
        endif 
      END DO
c     write(6,*) 'wwwmcp',(MPTYP(i),i=1,nat)
c     write(6,*) 'wwwmcp',(IZCORE(i),i=1,nat)
C
      RETURN
      END
C*MODULE FMOlib  *DECK mockhead
      SUBROUTINE mockhead(ilay,ifg,jfg,kfg,icurit,intyp,ns,ks)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      logical LINEAR
      PARAMETER (MXATM=2000,MXSH=5000,MXGTOT=20000,MXAO=8192)
      PARAMETER (ONE=1.0D+00,HALF=0.5D+00,
     *           PT75=0.75D+00, PT187=1.875D+00, PT6562=6.5625D+00,
     *           PT2953=29.53125D+00, PT1624=162.421875D+00)
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /RUNLAB/ TITLE(10),A(MXATM),B(MXATM),BFLAB(MXAO)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      COMMON /ZMAT  / NZMAT,NZVAR,NVAR,NSYMC,LINEAR
      COMMON /ZMTALT/ NZMAT2,NZVAR2,NVAR2,NZMTRD,ICOORD
      DIMENSION intyp(*),ns(*),ks(*),MELDIX(5)
      data UNIQUE/8HUNIQUE  /
C
c     This subroutine knows about s,p,d,f,g,h,i and l shells only
c     (this restriction is also in INTYP set up elsewhere).
c
      write(iw,8000) ilay,ifg,jfg,kfg,icurit
      write(iw,9000) 
      PI = ACOS(-ONE)
      PI32 = PI * SQRT(PI)
      CALL VALFM(LOADFM)
      lCSinp = LOADFM + 1
      lCpinp = lCSinp + MXGTOT
      lCdinp = lCpinp + MXGTOT
      lCfinp = lCdinp + MXGTOT
      lCginp = lCfinp + MXGTOT
      lChinp = lCginp + MXGTOT
      lCiinp = lChinp + MXGTOT
      LAST   = lCiinp + MXGTOT 
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
      WRITE (IW,9050)
      DO 1100 IAT = 1,NAT
         WRITE (IW,9060) A(IAT),B(IAT),ZAN(IAT),
     *                   C(1,IAT),C(2,IAT),C(3,IAT)
 1100 CONTINUE
c     write(6,*) 'wwwks=',(ks(i),i=1,nat) 
c     write(6,*) 'wwwns=',(ns(i),i=1,nat) 
c     write(iw,9100) 
c     This piece is stolen from ATOMS
      IF(NORMP.EQ.1) then
        write(iw,*) 'NORMP=1 is not supported with NFRND=2.'
        call abrt
c       In general, not supported, as NORMP applies only to explicit
c       basis functions, but it is not known now whether a basis function
c       was prestored or explicit. As for NORMF, it applies to all (?)
c       basis functions, and equally to CSINP and CS, so there is no need to
c       unscale CS to get CSINP.
c 
      endif    
      DO 720 II = 1,NSHELL
        k1 = KSTART(II)
        k2 = k1+KNG(II)-1
        DO 720 IG = K1,K2
          EE = EX(IG)+EX(IG)
          FACS = PI32/(EE*SQRT(EE))
          FACP = HALF  *FACS/EE
          FACD = PT75  *FACS/(EE*EE)
          FACF = PT187 *FACS/(EE**3)
          FACG = PT6562*FACS/(EE**4)
          FACH = PT2953*FACS/(EE**5)
          FACI = PT1624*FACS/(EE**6)
          jg=ig-1 
          x(lCSinp+jG) = CS(IG)*SQRT(FACS)
          x(lCPinp+jG) = CP(IG)*SQRT(FACP)
          x(lCDinp+jG) = CD(IG)*SQRT(FACD)
          x(lCFinp+jG) = CF(IG)*SQRT(FACF)
          x(lCGinp+jG) = CG(IG)*SQRT(FACG)
          x(lCHinp+jG) = CH(IG)*SQRT(FACH)
          x(lCIinp+jG) = CI(IG)*SQRT(FACI)
c         write(6,*) 'wwwaaa',CS(IG),x(lCSinp+jG)
  720 CONTINUE
      call prtbasis(0,x(lCSinp),x(lCPinp),x(lCDinp),x(lCFinp),x(lCGinp),
     *              x(lCHinp),x(lCIinp),dum,MXSH,MXATM,MXGTOT,dum,intyp,
     *              NS,KS,.false.,dum,dum,dum,MELDIX,MLDNDA,MLDUDF,
     *              .false.)
      call prtstat(0)
c     print truncated version of $CONTRL 
      coord=UNIQUE
      if(icoord.ne.-1) write(iw,*) 'Confusion in mockhead!!'
      WRITE (IW,9520) SCFTYP, RUNTYP, EXETYP,
     *                MPLEVL, CITYP,  CCTYP,  VBTYP,
     *                DFTYPE, TDDFTYP,
     *                MUL,    ICH,    NZVAR,  COORD
      CALL RETFM(NEED)
      RETURN
 8000 format(/1x,16(1H~),' BEGIN FMO OUTPUT for',I2,3I6,I4,1x,16(1H~),/)
 9000 format(1x,'GAMESS VERSION')
 9050 FORMAT(/1X,'ATOM',6X,'ATOMIC',22X,'COORDINATES (BOHR)'/
     *         11X,'CHARGE',9X,'X',19X,'Y',19X,'Z')
 9060 FORMAT(1X,A8,A2,F5.1,F17.10,2F20.10)
c9100 format(/1x,'CONTRACTION COEFFIECIENTS BELOW are not normalized.')
 9520 FORMAT(/5X,'$CONTRL OPTIONS'/5X,15(1H-)/
     * 1X,'SCFTYP=',A8,5X,'RUNTYP=',A8,5X,'EXETYP=',A8/
     * 1X,'MPLEVL=',I8,5X,'CITYP =',A8,5X,'CCTYP =',A8,5X,'VBTYP =',A8/
     * 1X,'DFTTYP=',A8,5X,'TDDFT =',A8/
     * 1X,'MULT  =',I8,5X,'ICHARG=',I8,5X,'NZVAR =',I8,5X,'COORD =',A8)
      END
C*MODULE FMOlib  *DECK fmoesca
      SUBROUTINE fmoesca(mode,E,nmo)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=2000)
      logical GOPARR,DSKWRK,MASWRK
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo
      dimension E(nmo)
c
c     Scale orbital enregies for projected orbitals in FMO,
c     because otherwise they do not fit into the printing format! 
c     mode=0 scale in (divide by 10)
c     mode=1 scale out (multiply by 10)
c
      if(iand(nfmopal,2).ne.0) then
        l0=nqmt
        fact=1.0D-02 
        if(mode.ne.0) fact=1.0D+02
        if(nmo.gt.l0-norbproj) then
           np=nmo-l0+norbproj
           call dscal(np,fact,E(l0-norbproj+1),1)
           if(mode.eq.0.and.maswrk) write(iw,9000) np 
        endif
      endif
      RETURN
 9000 format(1x,'Scaling',I4,' last orbital energies projected out in ',
     *          'FMO by the factor of 100.')
      end
C*MODULE FMOlib  *DECK loadhfd
      SUBROUTINE loadhfd
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=2000)
      logical GOPARR,DSKWRK,MASWRK
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
C
      if(maswrk) write(iw,*) 'Restoring the RHF density...'
      l1=num
      l2=(l1*l1+l1)/2
      CALL daread(IDAF,IODA,x(lfmoda),L2,308,0)
      CALL dawrit(IDAF,IODA,x(lfmoda),L2,16,0)
      RETURN
      end
C*MODULE FMOlib  *DECK critloc
      function critloc(l1,iat,vv,ss,fullmul,cutdiff,expdiff)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      logical fullmul,cutdiff
      parameter(one=1.0D+00,half=0.5D+00)
      dimension vv(l1),ss(*)
      PARAMETER (MXSH=5000, MXGTOT=20000)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
c
      sum=0
      do ii=1,nshell
        mini=kmin(ii)
        maxi=kmax(ii)
        loci=kloc(ii)
        ati=katom(ii)
        I1 = KSTART(II)
        I2 = I1+KNG(II)-1
        ig=idamax(i2-i1+1,ex(i1),1)
        AI = EX(IG+i1-1)
c       write(6,*) 'shell=',ii,' exp=',ai,ig,i1,i2
        if(ati.eq.iat.and.(.not.cutdiff.or.ai.gt.expdiff)) then
          do i=mini,maxi
            cci=vv(loci)
            do jj=1,nshell 
              minj=kmin(jj)
              maxj=kmax(jj)
              locj=kloc(jj)
              atj=katom(jj)
              if(atj.ne.iat) then
                fac=half*cci
              else
                fac=one*cci
              endif
              j1 = KSTART(JJ)
              j2 = j1+KNG(JJ)-1
              jg=idamax(j2-j1+1,ex(j1),1)
              AJ = EX(JG+j1-1)
c             write(6,*) 'Shell=',jj,' exp=',aj
              if((atj.eq.iat.or.fullmul).and.
     *           (.not.cutdiff.or.aj.gt.expdiff)) then 
                do j=minj,maxj
                  mm=min(loci,locj)
                  nn=max(loci,locj)
                  sum=sum+fac*ss((nn*nn-nn)/2+mm)*vv(locj) 
                  locj=locj+1 
                enddo
              endif
            enddo
            loci=loci+1
          enddo
        endif
      enddo
      critloc=sum
c
c     call mocoze(iat,vv,ww)
c     call prsq(ww,l1,1,1)
c     call MTARBR(ss,l1,ww,1,ww(1+l1),l1,1)
c     critloc=ddot(l1,ww,1,ww(1+l1),1)
c     over is ct * S * c , where c is one MO vector with
c     only atom 1 coefficients.
c     write(6,*) 'critloc=',critloc
      return
c         xx(lover+i-1)=critloc(l1,1,xx(lvv+(i-1)*l1),xx(lvi),xx(lss),
c    *                          fullmul)
c         call mocoze(1,xx(lvv+(i-1)*l1),xx(lvi))
c         call prsq(xx(lvi),l1,1,1) 
c         call MTARBR(xx(lss),l1,xx(lvi),1,xx(lvi+l1),l1,1)
c         xx(lover+i-1)=ddot(l1,xx(lvi),1,xx(lvi+l1),1)
c         over is ct * S * c , where c is one MO vector with
c         only atom 1 coefficients.  
      end
C*MODULE FMOlib  *DECK setatz
      subroutine setatz(mode,MAXIC,fastvesp,lfvesp,needfv)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      logical fastvesp
      COMMON /FMCOM / X(1)
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
c
c     mode=1 set up atomic fractions with FMOATFRG 
c
      lfvesp=0
      needfv=0
      fastvesp=iand(modesp,3).eq.0.and.nbsse.ne.2
c    *         .and.iand(modesp,1024).ne.0
      if(.not.fastvesp) return
c
      needv=MAXIC*6
      CALL VALFM(LOADFM)
      lfvesp = LOADFM + 1
      last=lfvesp + needv 
      NEEDfv = LAST - LOADFM - 1
      CALL GETFM(needfv)
      DO IC = 1,MAXIC
        icind=lfvesp+(ic-1)*6
        if(mode.eq.1) then
          CALL FMOATFRG(IC,X(LINDAT),X(LINDATG),X(LIAGLOB),
     *                  X(LIALOC),X(LIABDFG),X(LJABDFG),
     *                  X(LINDBD),X(LFMOZAN),X(LFMOC),
     *                  NATFMO+NBDFG,X(LUNTXYZ),X(LPOPMAT),
     *                  1,1,x(icind),x(icind+1),
     *                  KFG,x(icind+2),x(icind+3),x(icind+4),x(icind+5))
c         1 and 1 are dummy shell atom indices (not used).
        endif
      enddo
c
      return
      end
