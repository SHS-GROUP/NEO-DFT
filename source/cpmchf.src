C  2 Sep 12 - MWS - synchronize MCINP
C  9 Aug 12 - ACW - Tighten analytic convergence criterion.
C                   Split residual into 3 parts: orbs, dets, wstate.
C 24 Apr 12 - ACW - MCPCGX: prevent garbage preconditioning
C                           essential to ormas nacme convergence
C                           (more long term work needed here)
C 16 Mar 12 - MWS - ZCPMCX: handles decrement/increment of MSTA data
C 14 Mar 12 - MWS - PRTNAC: skip unweighted states to pick IROOT grad
C  7 MAR 12 - MWS - ALIGN DETWFN COMMON
C 17 Feb 12 - LBR - updated DETWFN common block
C 15 DEC 11 - ACW - CPCTST:  for conical intersection searches,    
C                            force NACST array to coincide with
C                            IXROOT array
C 15 DEC 11 - ACW - MCPCG:  turned mcpcg into mcpcgx with more
C                           convergers added
C 14 DEC 11 - ACW - ZCPMCX:  added code for iroot for gradient runs
C                   PRTNAC:  added irttmp var for gradient runs
C 27 OCT 11 - ACW - PRTNAC:
C                   orig. prtnac changed to format found in fmnac
C                   fmnac now also calls prtnac
C                   conical intersections searchs now work with
C                           Z-VECTOR nacme
C 27 OCT 11 - AAD - DETOSC:
C                   oscillator strength evaluation moved to detosc 
C                   ormas oscillator strengths now available
C 22 OCT 11 - ACW - CPMCX,FMNAC,PRTNAC:
C                   increase formats for printing nacme components 
C                   (nacme near conical intersections reach into
C                    1000s or 10,000s)
C 24 SEP 11 - ACW - CPMCX,FMNAC, PRTNAC(if kept):
C                   enable print offs for user selected nacmes
C                   with non-zero wstate
C 15 SEP 11 - ACW - NACMEX:  least approp. repsonses based on cistep,
C                            non-zero wstate,dofs
C                            i.e. call cpmcx vs. call zcpmcx
C 15 SEP 11 - ACW - ZCPMCX:  memory allocations increased to account 
C                            for nstats >> dofs ormas cases
C 15 SEP 11 - ACW - HSMLT1:  no do loops around calls to this sub 
C 15 SEP 11 - TJD - ORMAS NACME IMPLEMENTED
C 15 SEP 11 - TJD - Z-VECTOR NACME IMPLEMENTED
C 11 Aug 11 - AAD - FMTDEN: evaluate oscillator strengths
C 11 Aug 11 - NM  - NACMEX,CPMCX: SA-MCSCF grad and conical intersect.
C 11 Aug 10 - DGF - SYNCH COMMON BLOCK ENRGYS
C  1 May 09 - SK  - check basis set is spd only
C 23 Oct 08 - TJD - fixed state index problem in FMNAC (NACME runs)
C 11 Apr 08 - MWS - implement a run type of NACME
C  4 Mar 08 - TJD - changes for NACME and SA-MCSCF gradient computation
C 24 Mar 06 - MWS - JCPOVR: file 18 processed only by master
C 22 Sep 06 - TJD - soup up runs with large active space, add ORMAS
C 10 Jul 06 - MWS - CHECK runs should not DDI_DESTROY
C 13 Mar 06 - TJD - soup up runs with many filled orbitals
C 17 Jan 06 - MWS - use new DDI transf common TRFDMS
C 14 Nov 05 - DGF - pad common block ENRGYS
C 19 Sep 05 - MWS - add true nuclear charge array to INFOA common
C  5 Jul 05 - MWS - SELECT NEW ATOM,BASIS,EFP,PCM,DAF DIMENSIONS
C 13 feb 05 - MWS - pad common block NSHEL
C 07 Sep 04 - MWS - pad common block INTFIL
C 23 Jul 04 - TJD - MCCPCG: carry on if nearly cvgd., or not pos.def.
C 20 Apr 04 - TJD - improve execution speed and parallel scalability
C 19 Feb 04 - TJD - fix right hand sides, and again excited states
C 16 Jan 04 - TJD - fix nact2/norb dimensioning, and excited states
C  9 Dec 03 - TJD - SOLVE CPMCHF EQUATIONS FOR ANALYTIC MCSCF HESSIANS
C
C*MODULE CPMCHF  *DECK ADVNCP
C     ---------------------------------------------
      SUBROUTINE ADVNCP(CON,NELE,NORB)
C     ---------------------------------------------
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER CON(*)
C
C     This routine is the same as ADVANC in ALDECI
C
      IF (CON(NELE).EQ.NORB) THEN
         DO 50 I=NELE-1,1,-1
            IF (CON(I+1)-CON(I).GT.1) THEN
               CON(I) = CON(I) + 1
               DO 40 J=I+1,NELE
                  CON(J) = CON(J-1) + 1
   40          CONTINUE
               RETURN
            ENDIF
   50    CONTINUE
      ENDIF
C
      CON(NELE) = CON(NELE)+1
C
      RETURN
      END
C*MODULE CPMCHF  *DECK CPDRD2
      SUBROUTINE CPDRD2(WAXCI,PRCNDC,CI,DFC,DERI,FCOR,ERI,INDEX,IACON1,
     *                  IACON2,IMMA,IMMC,ISPA,ISPB,ISYMA,ISYMB,ITAB,IOX,
     *                  IMUL,IPOSA,IPERA,IIND1,IBCON1,ISAS,ISBS,ISAC,
     *                  ISBC,ISTART,ISTRB,ISTRP,IFA,NINDX,NDETLN,NACT,
     *                  NCOR,NA,NB,NALP,NBLP,NSYM,NXYZ,L1,NNACT,JLO,JHI,
     *                  NCI,NSTATS)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER POSDET
C
      DIMENSION WAXCI(NXYZ,NSTATS*NDETLN),PRCNDC(*),CI(*),DFC(*),
     *          DERI(*),FCOR(*),ERI(L1,NACT,NNACT)
      DIMENSION INDEX(NINDX,NINDX),IACON1(NA),IACON2(NA),
     *          IMMA(NSYM,(NA*(NACT-NA))),IMMC(NSYM),ISPA(NALP),
     *          ISPB(NBLP),ISYMA(NALP),ISYMB(NBLP),ITAB(NSYM),IOX(NACT),
     *          IMUL(NSYM,NSYM),IPOSA(NA*(NACT-NA)),IPERA(NA*(NACT-NA)),
     *          IIND1(NA*(NACT-NA)),IBCON1(NA),ISAS(NSYM+1),
     *          ISBS(NSYM+1),ISAC(NALP),ISBC(NBLP),ISTART(NBLP),
     *          ISTRB((NBLP*(NB*(NACT-NB)))/2),
     *          ISTRP((NBLP*(NB*(NACT-NB)))/2),
     *          IFA(0:NACT,0:NACT)
C
      ICONST = 1
      IZERO = 0
C
      DO 7 I=1,NINDX
         DO 8 J=1,I
            INDEX(I,J) = I*(I-1)/2 + J
            INDEX(J,I) = INDEX(I,J)
    8    CONTINUE
    7 CONTINUE
C
      DO 30 I=1,NA
         IACON1(I) = I
   30 CONTINUE
C
C     ----- Big Loop over all alpha determinants -----
C
      DO 9000 IJK = 1,NALP
C
C          ----- Alpha excitations here -----
C          -----      Single first      -----
C
         IAC = 0
         DO 45 II=1,NSYM
            IMMC(II) = 0
   45    CONTINUE
         ICAT = ISPA(IJK)
         ISA1 = ISYMA(IJK)
         ITAS = ITAB(ISA1)
         DO 7030 IA=1,NA
             IO1 = IACON1(IA)
             IS1 = IOX(IO1)
             IST = IO1 + 1
             IEN = IACON1(IA+1)-1
             IF (IA.EQ.NA) IEN=NACT
             DO 7025 KKJ=IA+1,NA+1
                DO 7020 JJ=IST,IEN
                IS2 = IOX(JJ)
                IP1 = IMUL(IS2,IS1)
C
             IAC = IAC + 1
             CALL RET1DET(IACON1,IACON2,NA,IA,JJ,IZERO,KKJ,IPER1)
C
C          ----- Storage here for later use, well worth it -----
C
             IPET = POSDET(NACT,NA,IACON2,IFA)
             IPOSA(IAC) = ISPA(IPET)
             IMMC(ISYMA(IPET)) = IMMC(ISYMA(IPET)) + 1
             IMMA(ISYMA(IPET),IMMC(ISYMA(IPET))) = IAC
             IPERA(IAC) = ((-1)**IPER1)*ICONST
             IND = INDEX(JJ,IO1)
             IIND1(IAC) = IND
C
             IF(IS1.NE.IS2) GO TO 417
C
         DO 49 I=1,NB
            IBCON1(I) = I
   49    CONTINUE
C
C          ----- Loop over beta dets of the right symmetry -----
C
                   IJ = (IND-1)*NXYZ + 1
                   DO 407 INBB = ISBS(ISA1),ISBS(ISA1+1)-1
                   INB1 = ISBC(INBB)
                   ICIT = ICAT+ISPB(INB1)
                   ICI2 = IPOSA(IAC) + ISPB(INB1)
C
                   IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                     DO ISTAT=1,NSTATS
                       NCI2 = (ISTAT-1)*NCI + ICI2
                       FC = CI(NCI2)*IPERA(IAC)
                       IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
                       CALL DAXPY(NXYZ,FC,DFC(IJ),1,WAXCI(1,IWIT),1)
                     ENDDO
                   ENDIF
C
                   IF(ICI2.GE.JLO .AND. ICI2.LE.JHI) THEN
                     DO ISTAT=1,NSTATS
                       NCIT = (ISTAT-1)*NCI + ICIT
                       FC = CI(NCIT)*IPERA(IAC)
                       IWI2 = (ISTAT-1)*NDETLN + ICI2 - JLO + 1
                       CALL DAXPY(NXYZ,FC,DFC(IJ),1,WAXCI(1,IWI2),1)
                     ENDDO
                   ENDIF
  407          CONTINUE
C
                   DO 487 IK=1,NA
                      IF (IK.EQ.IA) GOTO 487
                      ION = IACON1(IK)
                      J1 = INDEX(ION,ION)
                      JJ1 = INDEX(IND,J1)
                      J2 = INDEX(ION,JJ)
                      J3 = INDEX(ION,IO1)
                      INX = INDEX(J2,J3)
C
                      IJKL = (JJ1-1)*NXYZ + 1
                      ILKJ = (INX-1)*NXYZ + 1
                   DO 413 INBB=ISBS(ISA1),ISBS(ISA1+1)-1
                      INB1 = ISBC(INBB)
                      ICIT = ICAT+ISPB(INB1)
                      ICI2 = IPOSA(IAC)+ISPB(INB1)
C
                      IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                        DO ISTAT=1,NSTATS
                          NCI2 = (ISTAT-1)*NCI + ICI2
                          FC = CI(NCI2)*IPERA(IAC)
                          IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
                          CALL DAXPY(NXYZ,FC,DERI(IJKL),1,
     *                               WAXCI(1,IWIT),1)
                          CALL DAXPY(NXYZ,-FC,DERI(ILKJ),1,
     *                               WAXCI(1,IWIT),1)
                        ENDDO
                      ENDIF
C
                      IF(ICI2.GE.JLO .AND. ICI2.LE.JHI) THEN
                        DO ISTAT=1,NSTATS
                          NCIT = (ISTAT-1)*NCI + ICIT
                          FC = CI(NCIT)*IPERA(IAC)
                          IWI2 = (ISTAT-1)*NDETLN + ICI2 - JLO + 1
                          CALL DAXPY(NXYZ,FC,DERI(IJKL),1,
     *                               WAXCI(1,IWI2),1)
                          CALL DAXPY(NXYZ,-FC,DERI(ILKJ),1,
     *                               WAXCI(1,IWI2),1)
                        ENDDO
                      ENDIF
  413              CONTINUE
C
  487              CONTINUE
C
                  NST = 1
                  DO 415 INBB = ISBS(ISA1),ISBS(ISA1+1)-1
                  NEND = ISBC(INBB)
                  DO 5510 KK=NST,NEND-1
                     CALL ADVANC(IBCON1,NB,NACT)
 5510             CONTINUE
                  ICIT = ICAT+ISPB(NEND)
                  ICI2 = IPOSA(IAC)+ISPB(NEND)
C
                     DO 790 IK=1,NB
                      ION = IBCON1(IK)
                      J1 = INDEX(ION,ION)
                      JJ1 = INDEX(IND,J1)
C
                      IJKL = (JJ1-1)*NXYZ + 1
C
                      IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                        DO ISTAT=1,NSTATS
                          NCI2 = (ISTAT-1)*NCI + ICI2
                          FC = CI(NCI2)*IPERA(IAC)
                          IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
                          CALL DAXPY(NXYZ,FC,DERI(IJKL),1,
     *                               WAXCI(1,IWIT),1)
                        ENDDO
                      ENDIF
C
                      IF(ICI2.GE.JLO .AND. ICI2.LE.JHI) THEN
                        DO ISTAT=1,NSTATS
                          NCIT = (ISTAT-1)*NCI + ICIT
                          FC = CI(NCIT)*IPERA(IAC)
                          IWI2 = (ISTAT-1)*NDETLN + ICI2 - JLO + 1
                          CALL DAXPY(NXYZ,FC,DERI(IJKL),1,
     *                               WAXCI(1,IWI2),1)
                        ENDDO
                      ENDIF
  790              CONTINUE
C
          NST = NEND
  415     CONTINUE
C
  417     CONTINUE
C
C          ----- Double excitations -----
C
          DO 4015 IAA = IA+1,NA
             IPA = IAA
             IIA = IACON1(IAA)
             IS3 = IOX(IIA)
             IF (JJ.GT.IIA) IPA = IPA - 1
             ISTAA = JJ+1
             IENAA = IEN
             DO 4010 KKJAA=KKJ,NA+1
                DO 4005 JJAA=ISTAA,IENAA
                IS4 = IOX(JJAA)
                IP2 = IMUL(IS4,IS3)
                IF (IP1.NE.IP2) GOTO 4005
C
             CALL RET1DET(IACON2,IBCON1,NA,IPA,JJAA,IZERO,KKJAA,IPER2)
             IPET = POSDET(NACT,NA,IBCON1,IFA)
             ICA1 = ISPA(IPET)
             IPERT = IPER1+IPER2
             IPERT = ((-1)**IPERT)*ICONST
                   I2 = INDEX(IACON1(IAA),JJAA)
                   INX = INDEX(I2,IND)
                   II1 = INDEX(JJAA,IO1)
                   II2 = INDEX(IACON1(IAA),JJ)
                   INX2 = INDEX(II1,II2)
C
                   IJKL = (INX-1)*NXYZ + 1
                   ILKJ = (INX2-1)*NXYZ + 1
                DO 786 INB1 = ISBS(ISA1),ISBS(ISA1+1)-1
                   NEND = ISBC(INB1)
                   ICI2 = ICA1 + ISPB(NEND)
                   ICIT = ICAT+ISPB(NEND)
C
                   IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                     DO ISTAT=1,NSTATS
                       NCI2 = (ISTAT-1)*NCI + ICI2
                       FC = CI(NCI2)*IPERT
                       IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
                       CALL DAXPY(NXYZ,FC,DERI(IJKL),1,WAXCI(1,IWIT),1)
                       CALL DAXPY(NXYZ,-FC,DERI(ILKJ),1,WAXCI(1,IWIT),1)
                     ENDDO
                   ENDIF
C
                   IF(ICI2.GE.JLO .AND. ICI2.LE.JHI) THEN
                     DO ISTAT=1,NSTATS
                       NCIT = (ISTAT-1)*NCI + ICIT
                       FC = CI(NCIT)*IPERT
                       IWI2 = (ISTAT-1)*NDETLN + ICI2 - JLO + 1
                       CALL DAXPY(NXYZ,FC,DERI(IJKL),1,WAXCI(1,IWI2),1)
                       CALL DAXPY(NXYZ,-FC,DERI(ILKJ),1,WAXCI(1,IWI2),1)
                     ENDDO
                   ENDIF
  786       CONTINUE
C
 4005           CONTINUE
                ISTAA = IACON1(KKJAA)+1
                IENAA = IACON1(KKJAA+1)-1
                IF (KKJAA.EQ.NA) IENAA=NACT
 4010        CONTINUE
 4015 CONTINUE
C
C
 7020           CONTINUE
                IST = IACON1(KKJ)+1
                IEN = IACON1(KKJ+1)-1
                IF (KKJ.EQ.NA) IEN=NACT
 7025        CONTINUE
 7030     CONTINUE
C
C          ----- Diagonal -----
C
            DO 67 II=1,NA
               I1 = IACON1(II)
               IND1 = INDEX(I1,I1)
C
               IJ1 = INDEX(I1+NCOR,I1+NCOR)
               IJ2 = (IND1-1)*NXYZ + 1
              DO 53 INB1 = ISBS(ISA1),ISBS(ISA1+1)-1
              NEND = ISBC(INB1)
              ICIT = ICAT+ISPB(NEND)
C
              IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                DO ISTAT=1,NSTATS
                  NCIT = (ISTAT-1)*NCI + ICIT
                  FC = CI(NCIT)
                  IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
                  CALL DAXPY(NXYZ,FC,DFC(IJ2),1,WAXCI(1,IWIT),1)
                  PRCNDC(IWIT) = PRCNDC(IWIT) + FCOR(IJ1)
                ENDDO
              ENDIF
   53         CONTINUE
C
               DO 64 JJ=II+1,NA
                  I2 = IACON1(JJ)
                  IND2 = INDEX(I2,I2)
                  INDM = IND2 - I2 + I1
                  J1 = INDEX(INDM,INDM)
                  J2 = INDEX(IND2,IND1)
C
                  IIKK = (J2-1)*NXYZ + 1
                  IKIK = (J1-1)*NXYZ + 1
               DO 55 INB1 = ISBS(ISA1),ISBS(ISA1+1)-1
                  NEND = ISBC(INB1)
                  ICIT = ICAT+ISPB(NEND)
C
                  IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      NCIT = (ISTAT-1)*NCI + ICIT
                      FC = CI(NCIT)
                      IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
                      CALL DAXPY(NXYZ,FC,DERI(IIKK),1,WAXCI(1,IWIT),1)
                      CALL DAXPY(NXYZ,-FC,DERI(IKIK),1,WAXCI(1,IWIT),1)
                      DVAL = ERI(I1+NCOR,I1,IND2) - ERI(I1+NCOR,I2,INDM)
                      PRCNDC(IWIT) = PRCNDC(IWIT) + DVAL
                    ENDDO
                  ENDIF
   55          CONTINUE
C
   64          CONTINUE
C
         DO 47 I=1,NB
            IBCON1(I) = I
   47    CONTINUE
C
             NST = 1
             DO 56 INB1 = ISBS(ISA1),ISBS(ISA1+1)-1
             NEND = ISBC(INB1)
             DO 7710 KK=NST,NEND-1
                CALL ADVANC(IBCON1,NB,NACT)
 7710        CONTINUE
             ICIT = ICAT+ISPB(NEND)
C
               DO 68 JJ=1,NB
                  I2 = IBCON1(JJ)
                  IND2 = INDEX(I2,I2)
                  J2 = INDEX(IND1,IND2)
C
                  IIKK = (J2-1)*NXYZ + 1
                  FC = CI(ICIT)
                  IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      NCIT = (ISTAT-1)*NCI + ICIT
                      FC = CI(NCIT)
                      IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
                      CALL DAXPY(NXYZ,FC,DERI(IIKK),1,WAXCI(1,IWIT),1)
                      PRCNDC(IWIT) = PRCNDC(IWIT) + ERI(I1+NCOR,I1,IND2)
                    ENDDO
                  ENDIF
   68          CONTINUE
C
            NST = NEND
   56       CONTINUE
C
   67       CONTINUE
C
C          ----- Loop over Beta dets now -----
C
         DO 40 II=1,NB
            IBCON1(II) = II
   40    CONTINUE
         JJZ = 1
C        ELSE
C        DO 41 II=1,NB
C           IBCON1(II) = IACON1(II)
C  41    CONTINUE
C        JJZ = IJK
C        ENDIF
C
         DO 8000 KJI = JJZ,NBLP
         ISTAR = ISTART(KJI)-1
         IPB1 = ISPB(KJI)
         ISB1 = ISYMB(KJI)
         ITBS = ITAB(ISB1)
         IMZZ = IMMC(ITBS)
         M1 = 0
         M2 = 0
         IF (ISB1.EQ.ITAS) M1 = 1
         IF (IMZZ.NE.0) M2 = 1
         IF (M1.EQ.0.AND.M2.EQ.0) GOTO 7998
         QNUM = 1.0D+00
         IC1 = ICAT + IPB1
C
C          ----- Beta first *********************** Single -----
C
          DO 900 IB=1,NB
             IBB = IBCON1(IB)
             IB1 = IOX(IBB)
             IR1 = IMUL(IB1,ISB1)
             IST = IBB+1
             IEN = IBCON1(IB+1)-1
             IF (IB.EQ.NB) IEN = NACT
             DO 895 KKJ=IB+1,NB+1
                DO 890 JJ=IST,IEN
                IB2 = IOX(JJ)
                ISB2 = IMUL(IR1,IB2)
                ITB2 = ITAB(ISB2)
                ISTAR = ISTAR + 1
                IF (ISB2.NE.ITAS.AND.M1.EQ.0) GOTO 890
                IF (M2.EQ.0.AND.IMMC(ITB2).EQ.0) GOTO 890
                IF (ISB2.NE.ITAS.AND.IMMC(ITB2).EQ.0) GOTO 890
C
                   IPB2 = ISTRB(ISTAR)
                   IC2 = ICAT + IPB2
                   ZPERB = ISTRP(ISTAR)/QNUM
                   IOB = INDEX(IBB,JJ)
C
            IF (M2.EQ.0.AND.IMMC(ITB2).NE.0) THEN
               DO 1013 IAT = 1,IMMC(ITB2)
                  IJU = IMMA(ITB2,IAT)
                  IC4 = IPOSA(IJU) + IPB2
                  IND = IIND1(IJU)
                  IX = INDEX(IND,IOB)
C
                  IJKL = (IX-1)*NXYZ + 1
C
                  IF(IC4.GE.JLO .AND. IC4.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      NIC1 = (ISTAT-1)*NCI + IC1
                      FC = CI(NIC1)*IPERA(IJU)*ZPERB
                      IW4 = (ISTAT-1)*NDETLN + IC4 - JLO + 1
                      CALL DAXPY(NXYZ,FC,DERI(IJKL),1,WAXCI(1,IW4),1)
                    ENDDO
                  ENDIF
C
                  IF(IC1.GE.JLO .AND. IC1.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      NIC4 = (ISTAT-1)*NCI + IC4
                      FC = CI(NIC4)*IPERA(IJU)*ZPERB
                      IW1 = (ISTAT-1)*NDETLN + IC1 - JLO + 1
                      CALL DAXPY(NXYZ,FC,DERI(IJKL),1,WAXCI(1,IW1),1)
                    ENDDO
                  ENDIF
 1013          CONTINUE
               GOTO 890
          ENDIF
C
            IF (M1.EQ.0.AND.ISB2.EQ.ITAS) THEN
               DO 2013 IAT =1,IMMC(ITBS)
                  IJU = IMMA(ITBS,IAT)
                  IC3 = IPOSA(IJU) + IPB1
                  IND = IIND1(IJU)
                  IX = INDEX(IND,IOB)
C
                  IJKL = (IX-1)*NXYZ + 1
C
                  IF(IC3.GE.JLO .AND. IC3.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      NIC2 = (ISTAT-1)*NCI + IC2
                      FC = CI(NIC2)*IPERA(IJU)*ZPERB
                      IW3 = (ISTAT-1)*NDETLN + IC3 - JLO + 1
                      CALL DAXPY(NXYZ,FC,DERI(IJKL),1,WAXCI(1,IW3),1)
                    ENDDO
                  ENDIF
C
                  IF(IC2.GE.JLO .AND. IC2.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      NIC3 = (ISTAT-1)*NCI + IC3
                      FC = CI(NIC3)*IPERA(IJU)*ZPERB
                      IW2 = (ISTAT-1)*NDETLN + IC2 - JLO + 1
                      CALL DAXPY(NXYZ,FC,DERI(IJKL),1,WAXCI(1,IW2),1)
                    ENDDO
                  ENDIF
 2013          CONTINUE
               GOTO 890
            ENDIF
C
            IF (ISB2.NE.ITAS.AND.IMMC(ITB2).NE.0) THEN
               DO 3013 IAT = 1,IMMC(ITB2)
                  IJU = IMMA(ITB2,IAT)
                  IC4 = IPOSA(IJU) + IPB2
                  IND = IIND1(IJU)
                  IX = INDEX(IND,IOB)
C
                  IJKL = (IX-1)*NXYZ + 1
C
                  IF(IC4.GE.JLO .AND. IC4.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      NIC1 = (ISTAT-1)*NCI + IC1
                      FC = CI(NIC1)*IPERA(IJU)*ZPERB
                      IW4 = (ISTAT-1)*NDETLN + IC4 - JLO + 1
                      CALL DAXPY(NXYZ,FC,DERI(IJKL),1,WAXCI(1,IW4),1)
                    ENDDO
                  ENDIF
C
                  IF(IC1.GE.JLO .AND. IC1.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      NIC4 = (ISTAT-1)*NCI + IC4
                      FC = CI(NIC4)*IPERA(IJU)*ZPERB
                      IW1 = (ISTAT-1)*NDETLN + IC1 - JLO + 1
                      CALL DAXPY(NXYZ,FC,DERI(IJKL),1,WAXCI(1,IW1),1)
                    ENDDO
                  ENDIF
 3013          CONTINUE
               GOTO 890
            ENDIF
C
            IF (IMMC(ITB2).EQ.0.AND.ISB2.EQ.ITAS) THEN
               DO 4013 IAT =1,IMMC(ITBS)
                  IJU = IMMA(ITBS,IAT)
                  IC3 = IPOSA(IJU) + IPB1
                  IND = IIND1(IJU)
                  IX = INDEX(IND,IOB)
C
                  IJKL = (IX-1)*NXYZ + 1
C
                  IF(IC3.GE.JLO .AND. IC3.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      NIC2 = (ISTAT-1)*NCI + IC2
                      FC = CI(NIC2)*IPERA(IJU)*ZPERB
                      IW3 = (ISTAT-1)*NDETLN + IC3 - JLO + 1
                      CALL DAXPY(NXYZ,FC,DERI(IJKL),1,WAXCI(1,IW3),1)
                    ENDDO
                  ENDIF
C
                  IF(IC2.GE.JLO .AND. IC2.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      NIC3 = (ISTAT-1)*NCI + IC3
                      FC = CI(NIC3)*IPERA(IJU)*ZPERB
                      IW2 = (ISTAT-1)*NDETLN + IC2 - JLO + 1
                      CALL DAXPY(NXYZ,FC,DERI(IJKL),1,WAXCI(1,IW2),1)
                    ENDDO
                  ENDIF
 4013          CONTINUE
               GOTO 890
            ENDIF
C
            IF (IMMC(ITB2).NE.0.AND.ISB2.EQ.ITAS) THEN
               DO 5013 IAT=1,IMMC(ITB2)
                  IJU = IMMA(ITB2,IAT)
                  IC3 = IPOSA(IJU) + IPB1
                  IC4 = IPOSA(IJU) + IPB2
                  IND = IIND1(IJU)
                  IX = INDEX(IND,IOB)
C
                  IJKL = (IX-1)*NXYZ + 1
C
                  IF(IC4.GE.JLO .AND. IC4.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      NIC1 = (ISTAT-1)*NCI + IC1
                      FC = CI(NIC1)*IPERA(IJU)*ZPERB
                      IW4 = (ISTAT-1)*NDETLN + IC4 - JLO + 1
                      CALL DAXPY(NXYZ,FC,DERI(IJKL),1,WAXCI(1,IW4),1)
                    ENDDO
                  ENDIF
C
                  IF(IC1.GE.JLO .AND. IC1.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      NIC4 = (ISTAT-1)*NCI + IC4
                      FC = CI(NIC4)*IPERA(IJU)*ZPERB
                      IW1 = (ISTAT-1)*NDETLN + IC1 - JLO + 1
                      CALL DAXPY(NXYZ,FC,DERI(IJKL),1,WAXCI(1,IW1),1)
                    ENDDO
                  ENDIF
C
                  IF(IC3.GE.JLO .AND. IC3.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      NIC2 = (ISTAT-1)*NCI + IC2
                      FC = CI(NIC2)*IPERA(IJU)*ZPERB
                      IW3 = (ISTAT-1)*NDETLN + IC3 - JLO + 1
                      CALL DAXPY(NXYZ,FC,DERI(IJKL),1,WAXCI(1,IW3),1)
                    ENDDO
                  ENDIF
C
                  IF(IC2.GE.JLO .AND. IC2.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      NIC3 = (ISTAT-1)*NCI + IC3
                      FC = CI(NIC3)*IPERA(IJU)*ZPERB
                      IW2 = (ISTAT-1)*NDETLN + IC2 - JLO + 1
                      CALL DAXPY(NXYZ,FC,DERI(IJKL),1,WAXCI(1,IW2),1)
                    ENDDO
                  ENDIF
 5013          CONTINUE
               GOTO 890
            ENDIF
C
  890           CONTINUE
                IST = IBCON1(KKJ)+1
                IEN = IBCON1(KKJ+1)-1
                IF (KKJ.EQ.NB) IEN=NACT
  895        CONTINUE
  900     CONTINUE
C
 7998     CONTINUE
           CALL ADVANC(IBCON1,NB,NACT)
 8000    CONTINUE
      CALL ADVANC(IACON1,NA,NACT)
 9000 CONTINUE
C
C          ----- Now for the Beta part -----
C
C
      DO 876 JJI=1,NB
         IBCON1(JJI) = JJI
  876 CONTINUE
C
      DO 9999 IJK = 1,NBLP
         ICAB = ISPB(IJK)
         ISB1 = ISYMB(IJK)
C
      DO 6030 IB=1,NB
         IST = IBCON1(IB)+1
         IEN = IBCON1(IB+1)-1
         IF (IB.EQ.NB) IEN=NACT
         IO1 = IBCON1(IB)
         IS1 = IOX(IO1)
         DO 6025 KKJ=IB+1,NB+1
            DO 6020 JJ=IST,IEN
            IS2 = IOX(JJ)
            IP1 = IMUL(IS2,IS1)
C
            CALL RET1DET(IBCON1,IACON2,NB,IB,JJ,IZERO,KKJ,IPER1)
C           IPER = ((-1)**IPER1)*2
            IPER = ((-1)**IPER1)
            IND = INDEX(JJ,IO1)
            IF (IS1.NE.IS2) GOTO 517
            IPB1 = POSDET(NACT,NB,IACON2,IFA)
            IPB1 = ISPB(IPB1)
C
       DO 89 I=1,NA
          IACON1(I) = I
   89 CONTINUE
C
C          ----- Loop over alpha -----
C
             IJ = (IND-1)*NXYZ + 1
          DO 907 INA1 = ISAS(ISB1),ISAS(ISB1+1)-1
             ICIA = ISAC(INA1)
             ICIT = ISPA(ICIA) + ICAB
             ICI2 = ISPA(ICIA) + IPB1
C
             IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
               DO ISTAT=1,NSTATS
                 NCI2 = (ISTAT-1)*NCI + ICI2
                 FC = CI(NCI2)*IPER
                 IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
                 CALL DAXPY(NXYZ,FC,DFC(IJ),1,WAXCI(1,IWIT),1)
               ENDDO
             ENDIF
C
             IF(ICI2.GE.JLO .AND. ICI2.LE.JHI) THEN
               DO ISTAT=1,NSTATS
                 NCIT = (ISTAT-1)*NCI + ICIT
                 FC = CI(NCIT)*IPER
                 IWI2 = (ISTAT-1)*NDETLN + ICI2 - JLO + 1
                 CALL DAXPY(NXYZ,FC,DFC(IJ),1,WAXCI(1,IWI2),1)
               ENDDO
             ENDIF
  907     CONTINUE
C
             DO 687 IK=1,NB
                IF (IK.EQ.IB) GOTO 687
                ION = IBCON1(IK)
                J1 = INDEX(ION,ION)
                JJ1 = INDEX(IND,J1)
                J1 = INDEX(ION,JJ)
                J2 = INDEX(ION,IO1)
                INX = INDEX(J1,J2)
C
                IJKL = (JJ1-1)*NXYZ + 1
                ILKJ = (INX-1)*NXYZ + 1
           DO 918 INA1 = ISAS(ISB1),ISAS(ISB1+1)-1
               ICIA = ISAC(INA1)
               ICIT = ISPA(ICIA) + ICAB
               ICI2 = ISPA(ICIA) + IPB1
C
               IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                 DO ISTAT=1,NSTATS
                   NCI2 = (ISTAT-1)*NCI + ICI2
                   FC = CI(NCI2)*IPER
                   IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
                   CALL DAXPY(NXYZ,FC,DERI(IJKL),1,WAXCI(1,IWIT),1)
                   CALL DAXPY(NXYZ,-FC,DERI(ILKJ),1,WAXCI(1,IWIT),1)
                 ENDDO
               ENDIF
C
               IF(ICI2.GE.JLO .AND. ICI2.LE.JHI) THEN
                 DO ISTAT=1,NSTATS
                   NCIT = (ISTAT-1)*NCI + ICIT
                   FC = CI(NCIT)*IPER
                   IWI2 = (ISTAT-1)*NDETLN + ICI2 - JLO + 1
                   CALL DAXPY(NXYZ,FC,DERI(IJKL),1,WAXCI(1,IWI2),1)
                   CALL DAXPY(NXYZ,-FC,DERI(ILKJ),1,WAXCI(1,IWI2),1)
                 ENDDO
               ENDIF
  918      CONTINUE
C
  687        CONTINUE
C
            NST = 1
            DO 920 INA1 = ISAS(ISB1),ISAS(ISB1+1)-1
            NEND = ISAC(INA1)
            DO 8810 KK=NST,NEND-1
               CALL ADVANC(IACON1,NA,NACT)
 8810       CONTINUE
            ICIA = ISPA(NEND)
            ICIT = ICIA + ICAB
            ICI2 = ICIA  + IPB1
C
             DO 690 IK=1,NA
                ION = IACON1(IK)
                J1 = INDEX(ION,ION)
                JJ1 = INDEX(IND,J1)
C
                IJKK = (JJ1-1)*NXYZ + 1
                IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                  DO ISTAT=1,NSTATS
                    NCI2 = (ISTAT-1)*NCI + ICI2
                    FC = CI(NCI2)*IPER
                    IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
                    CALL DAXPY(NXYZ,FC,DERI(IJKK),1,WAXCI(1,IWIT),1)
                  ENDDO
                ENDIF
C
                IF(ICI2.GE.JLO .AND. ICI2.LE.JHI) THEN
                  DO ISTAT=1,NSTATS
                    NCIT = (ISTAT-1)*NCI + ICIT
                    FC = CI(NCIT)*IPER
                    IWI2 = (ISTAT-1)*NDETLN + ICI2 - JLO + 1
                    CALL DAXPY(NXYZ,FC,DERI(IJKK),1,WAXCI(1,IWI2),1)
                  ENDDO
                ENDIF
  690        CONTINUE
             NST = NEND
  920    CONTINUE
C
  517   CONTINUE
C
C          ----- Now for beta doubles -----
C
       DO 6015 IBB = IB+1,NB
               ISTBB = JJ+1
               IENBB = IEN
               JB = IBCON1(IBB)
               IS3 = IOX(JB)
               IPB = IBB
               IF (JJ.GT.JB) IPB = IPB - 1
               DO 6010 KKJBB = KKJ,NB+1
                  DO 6005 JJBB = ISTBB,IENBB
                    IS4 = IOX(JJBB)
                    IP2 = IMUL(IS4,IS3)
                    IF (IP1.NE.IP2) GOTO 6005
C
          CALL RET1DET(IACON2,IACON1,NB,IPB,JJBB,IZERO,KKJBB,IPER2)
          IBP2 = POSDET(NACT,NB,IACON1,IFA)
          IBP2 = ISPB(IBP2)
          IPER = IPER1+IPER2
C         IPER = ((-1)**IPER)*2
          IPER = ((-1)**IPER)
               I2 = INDEX(JB,JJBB)
               INX = INDEX(I2,IND)
               II1 = INDEX(JJBB,IO1)
               II2 = INDEX(JB,JJ)
               INX2 = INDEX(II1,II2)
C
               IJKL = (INX-1)*NXYZ + 1
               ILKJ = (INX2-1)*NXYZ + 1
             DO 686 INA1 = ISAS(ISB1),ISAS(ISB1+1)-1
             NEND = ISAC(INA1)
             ICIA = ISPA(NEND)
             ICIT = ICIA + ICAB
             ICI2 = ICIA + IBP2
C
             IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
               DO ISTAT=1,NSTATS
                 NCI2 = (ISTAT-1)*NCI + ICI2
                 FC = CI(NCI2)*IPER
                 IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
                 CALL DAXPY(NXYZ,FC,DERI(IJKL),1,WAXCI(1,IWIT),1)
                 CALL DAXPY(NXYZ,-FC,DERI(ILKJ),1,WAXCI(1,IWIT),1)
               ENDDO
             ENDIF
C
             IF(ICI2.GE.JLO .AND. ICI2.LE.JHI) THEN
               DO ISTAT=1,NSTATS
                 NCIT = (ISTAT-1)*NCI + ICIT
                 FC = CI(NCIT)*IPER
                 IWI2 = (ISTAT-1)*NDETLN + ICI2 - JLO + 1
                 CALL DAXPY(NXYZ,FC,DERI(IJKL),1,WAXCI(1,IWI2),1)
                 CALL DAXPY(NXYZ,-FC,DERI(ILKJ),1,WAXCI(1,IWI2),1)
               ENDDO
             ENDIF
  686       CONTINUE
C
 6005          CONTINUE
               ISTBB = IBCON1(KKJBB)+1
               IENBB = IBCON1(KKJBB+1)-1
               IF (KKJBB.EQ.NB) IENBB=NACT
 6010      CONTINUE
 6015 CONTINUE
C
 6020       CONTINUE
            IST = IBCON1(KKJ)+1
            IEN=IBCON1(KKJ+1)-1
            IF (KKJ.EQ.NB) IEN=NACT
 6025     CONTINUE
 6030 CONTINUE
C
C          ----- Remaining part of diagonal contributions -----
C
            DO 69 II=1,NB
               I1 = IBCON1(II)
               IND1 = INDEX(I1,I1)
C
               IJ1 = INDEX(I1+NCOR,I1+NCOR)
               IJ2 = (IND1-1)*NXYZ + 1
            DO 93 INA1 = ISAS(ISB1),ISAS(ISB1+1)-1
              NEND = ISAC(INA1)
              ICIA = ISPA(NEND)
              ICIT = ICIA + ICAB
C
              IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                DO ISTAT=1,NSTATS
                  NCIT = (ISTAT-1)*NCI + ICIT
                  FC = CI(NCIT)
                  IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
                  CALL DAXPY(NXYZ,FC,DFC(IJ2),1,WAXCI(1,IWIT),1)
                  PRCNDC(IWIT) = PRCNDC(IWIT) + FCOR(IJ1)
                ENDDO
              ENDIF
   93       CONTINUE
C
               DO 74 JJ=II+1,NB
                  I2 = IBCON1(JJ)
                  IND2 = INDEX(I2,I2)
                  INDM = IND2-I2+I1
                  J1 = INDEX(INDM,INDM)
                  J2 = INDEX(IND2,IND1)
C
                  IIKK = (J2-1)*NXYZ + 1
                  IKIK = (J1-1)*NXYZ + 1
            DO 97 INA1 = ISAS(ISB1),ISAS(ISB1+1)-1
               NEND = ISAC(INA1)
               ICIA = ISPA(NEND)
               ICIT = ICIA + ICAB
C
               IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                 DO ISTAT=1,NSTATS
                   NCIT = (ISTAT-1)*NCI + ICIT
                   FC = CI(NCIT)
                   IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
                   CALL DAXPY(NXYZ,FC,DERI(IIKK),1,WAXCI(1,IWIT),1)
                   CALL DAXPY(NXYZ,-FC,DERI(IKIK),1,WAXCI(1,IWIT),1)
                   DVAL = ERI(I1+NCOR,I1,IND2) - ERI(I1+NCOR,I2,INDM)
                   PRCNDC(IWIT) = PRCNDC(IWIT) + DVAL
                 ENDDO
               ENDIF
   97       CONTINUE
C
   74          CONTINUE
C
   69       CONTINUE
           CALL ADVANC(IBCON1,NB,NACT)
 9999 CONTINUE
C
      RETURN
      END
C*MODULE CPMCHF  *DECK CPMCX
      SUBROUTINE CPMCX
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION METHOD,NACME
C
      LOGICAL SVDSWK,MASWRK,GOPARR,DSKWRK,SOME,PACK2E,FDIRCT,QCORR
      LOGICAL CANONC,FCORE,FORS,EKT,LINSER,GENMC,NOCAS
      LOGICAL NAPICK
C
      INTEGER         C_OOOO, C_VOOO, C_VVOO, C_VOVO
C
      PARAMETER (MXRT=100, MXATM=2000, MXSH=5000, MXNORO=250)
C
      DIMENSION NOCP(3*MXATM)
      DIMENSION NACST(MXRT*(MXRT-1))
C
      COMMON /CIFILS/ NFT11,NFT12,NFT13,NFT14,NFT15,NFT16,IDAF20,NEMEMX
      COMMON /DLBTIM/ C_OOOO,C_VOOO,C_VVOO,C_VOVO
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,S,SZ,
     *                GRPDET,STSYM,GLIST,DWPARM,
     *                NFLGDM(MXRT),IWTS(MXRT),NCORSV,NCOR,NACT,NORB,
     *                NA,NB,K,KST,IROOT,IPURES,MAXW1,NITER,MAXP,NCI,
     *                IGPDET,KSTSYM,NFTGCI,IDWEIGH
      COMMON /ECP2  / CLP(400),ZLP(400),NLP(400),KFIRST(MXATM,6),
     *                KLAST(MXATM,6),LMAX(MXATM),LPSKIP(MXATM),
     *                IZCORE(MXATM)
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,STOT,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,
     *                EDFT(2),EDISP
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIM(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA2,NB2,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWORD,NORBMC,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                T(432),INVT(48),NT
C
      INTEGER         D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB
      LOGICAL         NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
      COMMON /TRFDMS/ D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB,
     *                NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
C
      DATA ORMAS /8HORMAS   /
      DATA CHECK /8HCHECK   /
      DATA NACME,HESS,CONICL /8HNACME   ,8HHESSIAN ,8HCONICAL /
C
      PARAMETER (ZERO=0.0D+00)
C
      L0 = NQMT
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
      N1 = NACT
      N2 = (N1*N1+N1)/2
      N4 = (N2*N2+N2)/2
      M1 = NCORSV+NACT
C
      NSYM = 2**IGPDET
      NXYZ = 3*NAT
      NC3 = NXYZ**2
C
      SOME = NPRINT.NE.-5 .AND. MASWRK
      NFT18 = 18
      NFT19 = 19
      GENMC = .FALSE.
      NOCAS = .FALSE.
      IF(CISTEP.EQ.ORMAS) THEN
        GENMC = .TRUE.
        LBST(1) = 1
        DO II=2,NSPACE
          IDIM(II-1) = MAX(IAMA(II-1),IBMA(II-1))
          LBST(II) = LBST(II-1) + ((MNUM(II-1)+1)*(IDIM(II-1)+1))
        ENDDO
        IDIM(NSPACE) = MAX(IAMA(NSPACE),IBMA(NSPACE))
        LNEED = LBST(NSPACE)+((MNUM(NSPACE)+1)*(IDIM(NSPACE)+1))
      ELSE
        NSPACE = 1
        LNEED = 0
        ITGA = 1
        ITGB = 1
        NB1EX = 0
      ENDIF
C
      IF(GOPARR) THEN
         CALL DDI_PROCDLB_CREATE(C_OOOO)
         CALL DDI_PROCDLB_CREATE(C_VOOO)
         CALL DDI_PROCDLB_CREATE(C_VVOO)
         CALL DDI_PROCDLB_CREATE(C_VOVO)
      END IF
C
      IF(MASWRK) WRITE(IW,9000)
      CALL FLSHBF(IW)
C
C     ----- Get memory required for whole program -----
C
      CALL GOTFM(NGOTMX)
      CALL VALFM(LOADFM)
      LIBO = LOADFM + 1
      LIND = LIBO + L1
      LIFA = LIND + L3
      LV = LIFA + ((N1+1)**2)/NWDVAR + 1
      LWRK = LV + L3
      LIA = LWRK + MAX(2*L3,N4)
      LEG = LIA + L2
      LEH = LEG + NXYZ
      LOINT = LEH + 9*(NAT*NAT+NAT)/2
      LFCOR = LOINT + L2
      LERI = LFCOR + L2
      LAMAT = LERI + L1*N1*N2
      LOPDM = LAMAT + L1*NCORSV*N2
      LEPS = LOPDM + N2
      LTPDM = LEPS + L3
      LX = LTPDM + N4
      LIX = LX + NINTMX
      LFCM = LIX + NINTMX
      LSDER = LFCM + NC3
      LDDM = LSDER + L3*NXYZ
      LSK = LDDM + 3*NXYZ
      LWSTMP = LSK + NAT
      LETMP = LWSTMP + MXRT
      LNG = LETMP + MXRT
      LBOX1 = LNG + NXYZ
      LBOX2 = LBOX1 + NSPACE
      LBOX3 = LBOX2 + NSPACE
      LBOX4 = LBOX3 + NSPACE
      LBOX5 = LBOX4 + NSPACE
      LAST = LBOX5 + NSPACE
      NEED1 = LAST - LOADFM - 1 + LNEED
      CALL GETFM(NEED1)
C
C     ----- Determine unique xyz for which CPMCSCF is needed -----
C
      NUNIQ = 0
      DO IXYZ=1,NXYZ
        NOCP(IXYZ) = 1
      ENDDO
      DO 200 IAT=1,NAT
        NUCZ = INT(ZAN(IAT)+0.01D+00) + IZCORE(IAT)
        IF(NUCZ.EQ.0) GO TO 200
        DO IT=1,NT
          IF(MAPCTR(IAT,IT).GT.IAT) GO TO 200
        ENDDO
        IXYZ=3*(IAT-1)
        NOCP(IXYZ+1) = 0
        NOCP(IXYZ+2) = 0
        NOCP(IXYZ+3) = 0
        NUNIQ = NUNIQ + 3
  200 CONTINUE
C
C     ----- Determine quantities related to generation of -----
C     -----              coupling constants               -----
C
      IAST = 0
      IBST = 0
C
      IF(GENMC) THEN
        DO II=1,NSPACE
          LBST(II) = LBST(II) + LAST
          CALL BINOM8(X(LBST(II)),MNUM(II),IDIM(II))
        ENDDO
C
        CALL TOTALCO(X(LBOX1),NSPACE,NA,IAMA,IAMI,X(LBOX2),ITGA)
        CALL TOTALCO(X(LBOX1),NSPACE,NB,IBMA,IBMI,X(LBOX2),ITGB)
C
        CALL RESETCO(X(LBOX1),NSPACE,NA,IAMA,IAMI,X(LBOX2))
        DO II=1,ITGA
          CALL TOTDETG(X(LBOX1),NSPACE,LBST,X(LBST(1)),LNEED,
     *                 MNUM,IDIM,ITOT)
          IAST = IAST + ITOT
          CALL PUSHCO(X(LBOX1),NSPACE,NA,IAMA,IAMI,X(LBOX2),IEND)
        ENDDO
C
        CALL RESETCO(X(LBOX1),NSPACE,NB,IBMA,IBMI,X(LBOX2))
        DO II=1,ITGB
          CALL TOTDETG(X(LBOX1),NSPACE,LBST,X(LBST(1)),LNEED,
     *                 MNUM,IDIM,ITOT)
          IBST = IBST + ITOT
          CALL PUSHCO(X(LBOX1),NSPACE,NB,IBMA,IBMI,X(LBOX2),IEND)
        ENDDO
      ENDIF
      CALL BINOM6(X(LIFA),N1)
      CALL MATMC2(L1,M1,NCORSV,NA,NB,X(LIFA),NSYM,IIS,NDETMX,
     *            ITGA,ITGB,NSPACE,IAST,IBST,GENMC)
C
      CALL VALFM(LOADFM)
      LIWRK = LOADFM + 1
      LAST = LIWRK + IIS
      NEEDWK = LAST - LOADFM - 1
      CALL GETFM(NEEDWK)
C
      IF(GENMC) THEN
        CALL VCLR(X(LIWRK),1,IIS)
        LCON = LIWRK
        LANDET = LCON + NA
        LBNDET = LANDET + NSPACE*ITGA
        LGCOM = LBNDET + NSPACE*ITGB
        LCOB = LGCOM + ITGA*ITGB
        CALL MATMC3(NDETMX,NCORSV,ITGA,ITGB,NA,NB,X(LBOX1),X(LBOX2),
     *              X(LBOX3),X(LCON),X(LANDET),X(LBNDET),X(LGCOM),
     *              X(LCOB),X(LBST(1)),NOCAS)
      ENDIF
C
C     ----- Determine independent orbital rotations -----
C
C-MWS-CALL DERCHK(NDER)
      NDER=2
      CALL DAREAD(IDAF,IODA,X(LIBO),L1,255,1)
      CALL FMPAIR(X(LIND),X(LIBO),MSTA,NCORSV,N1,L1,L0,NROT,NDER,
     *            NSPACE,GENMC,NOCAS)
C
      CALL DAREAD(IDAF,IODA,X(LIBO),L1,262,1)
      CALL CORTRA(X(LIBO),M1,NCORSV)
      IF(NDER.NE.2) NDETMX = NCI
C
C     ----- Get memory for CPMCHF configuration solution -----
C
      NDETLN = NDETMX
      JLO = 1
      JHI = NDETMX
      JROTLO = 1
      JROTHI = NROT
      IF(GOPARR) THEN
        NDETLN = NDETMX/NPROC
        NDTMOD = MOD(NDETMX,NPROC)
        IF(ME.LT.NDTMOD) THEN
          JLO = ME*(NDETLN+1) + 1
          JHI = JLO + NDETLN
        ELSE
          JLO = NDTMOD*(NDETLN+1) + (ME-NDTMOD)*NDETLN + 1
          JHI = JLO + NDETLN - 1
        ENDIF
        IF(NDTMOD.GT.0) NDETLN = NDETLN + 1
C
        NROTLN = NROT/NPROC
        NDTMOD = MOD(NROT,NPROC)
        IF(ME.LT.NDTMOD) THEN
          JROTLO = ME*(NROTLN+1) + 1
          JROTHI = JROTLO + NROTLN
        ELSE
          JROTLO = NDTMOD*(NROTLN+1) + (ME-NDTMOD)*NROTLN + 1
          JROTHI = JROTLO + NROTLN - 1
        ENDIF
        IF(NDTMOD.GT.0) NROTLN = NROTLN + 1
      ENDIF
C
C     ----- Determine number of spin states     -----
C     ----- Take care of analytic gradient runs -----
C
      IWST = 0
      NSTATS = 0
      DO 100 IST=1,K
        IF(IPURES.EQ.1) THEN
          IF(ABS(SPINS(IST)-S) .GT. 0.03D+00) GO TO 100
          IWST = IWST + 1
        ELSE
          IWST = IWST + 1
        ENDIF
        IF(WSTATE(IWST).NE.ZERO) THEN
          NSTATS = NSTATS + 1
          X(LWSTMP+NSTATS-1) = WSTATE(IWST)
        ENDIF
  100 CONTINUE
      IRTTMP = IROOT
C
      CALL DERCHK(MAXDER)
      IF((NSTATS.NE.1) .AND. (RUNTYP.EQ.HESS .OR. MAXDER.EQ.2)) THEN
         IF(MASWRK) WRITE(IW,9005)
         CALL ABRT
      END IF
 9005 FORMAT(/1X,'CANNOT PERFORM HESSIAN EVALUATION FOR STATE-',
     *           'AVERAGED WAVEFUNCTION.')
C
      NNSTAT = (NSTATS*NSTATS+NSTATS)/2
C
C     ----- Get more memory required for whole program -----
C
      CALL VALFM(LOADFM)
      LCI = LOADFM + 1
      LYAO = LCI + NSTATS*NDETMX
      LYAC = LYAO + NUNIQ*NROT
      LYAS = LYAC + NXYZ*NSTATS*NDETLN
      LPRCDO = LYAS + NUNIQ*NNSTAT
      LPRCDC = LPRCDO + NROT
      LPRCDS = LPRCDC + NSTATS*NDETLN
      LEGRAD = LPRCDS + NNSTAT
      LDERI = LEGRAD + NXYZ*NNSTAT
      LAST = LDERI + N1*N1*N2*NXYZ
      NEED2 = LAST - LOADFM - 1
      IF(EXETYP.NE.CHECK) CALL GETFM(NEED2)
C
C     ----- Get temporary memory -----
C
      CALL VALFM(LOADFM)
      LDFC = LOADFM + 1
      LDLAG = LDFC + L2*NXYZ
      LDSAO = LDLAG + L3*NXYZ
      LDHC = LDSAO + L3
      LTMPWK = LDHC + NXYZ
      LCIOLD = LTMPWK + NSTATS*NDETLN
      LAST = LCIOLD + K*NCI
      NEEDT = LAST - LOADFM - 1
      IF(EXETYP.NE.CHECK) CALL GETFM(NEEDT)
C
      MEMREP = NEED1 + NEED2 + NEEDT
      IF(EXETYP.EQ.CHECK) THEN
        CALL CPCHK1(MEMREP,IW,NSTATS,NXYZ,NDETMX)
      ELSE
        IF(SOME) WRITE(IW,9010) MEMREP,NGOTMX
      ENDIF
C
      IF(EXETYP.EQ.CHECK) THEN
         CALL VCLR(X(LEG),1,NXYZ)
         CALL DAWRIT(IDAF,IODA,X(LEG),NXYZ,3,0)
         CALL DAWRIT(IDAF,IODA,X(LEG),NXYZ,29,0)
         NEGH = NXYZ + 9*(NAT*NAT+NAT)/2
         CALL DAREAD(IDAF,IODA,X(LEG),NEGH,67,0)
         CALL CPWAB0(X(LFCM),X(LEH),NAT)
         CALL DAWRIT(IDAF,IODA,X(LFCM),NC3,4,0)
         CALL VCLR(X(LDDM),1,3*NXYZ)
         CALL DAWRIT(IDAF,IODA,X(LDDM),3*NXYZ,34,0)
         GO TO 300
      END IF
C
C     ----- Get CI vectors from file -----
C
      SVDSWK = DSKWRK
      DSKWRK = .FALSE.
      CALL SEQREW(NFT12)
      IF(MASWRK) READ(NFT12) NSTATS,NDETS
      IF(GOPARR) CALL DDI_BCAST(2150,'I',NSTATS,1,MASTER)
      IF(GOPARR) CALL DDI_BCAST(2151,'I',NDETS,1,MASTER)
C
      IF(NSTATS.NE.K .OR. NDETS.NE.NCI) THEN
        IF(MASWRK) WRITE(IW,9360) NSTATS,NDETS,K,NCI
        CALL ABRT
      END IF
C
      IWST = 0
      NSTATS = 0
      CALL DCOPY(MXRT,ESTATE,1,X(LETMP),1)
      DO 150 IST=1,K
        IF(IPURES.EQ.1) THEN
          IF(ABS(SPINS(IST)-S) .GT. 0.03D+00) THEN
            CALL SEQADV(NFT12)
            GO TO 150
          END IF
          IWST = IWST + 1
        ELSE
          IWST = IWST + 1
        ENDIF
        IF(WSTATE(IWST).NE.ZERO) NSTATS = NSTATS + 1
C
        IF(WSTATE(IWST).EQ.ZERO) THEN
          CALL SEQADV(NFT12)
          GO TO 150
        ENDIF
        IF(MASWRK) THEN
           IF(RUNTYP.EQ.HESS)   WRITE(IW,9060) ESTATE(IST),SPINS(IST)
           IF(RUNTYP.EQ.NACME)  WRITE(IW,9065) ESTATE(IST),SPINS(IST)
           IF(RUNTYP.EQ.CONICL) WRITE(IW,9065) ESTATE(IST),SPINS(IST)
        ENDIF
        LCITMP = LCIOLD + (NSTATS-1)*NCI
        CALL SQREAD(NFT12,X(LCITMP),NCI)
        ESTATE(NSTATS) = X(LETMP+IST-1)
  150 CONTINUE
      CALL SEQREW(NFT12)
      DSKWRK = SVDSWK
C
C     ----- Construct derivative overlap terms -----
C
      IF(NDER.EQ.2) THEN
        NEGH = NXYZ + 9*(NAT*NAT+NAT)/2
        CALL DAREAD(IDAF,IODA,X(LEG),NEGH,67,0)
        CALL CPWAB0(X(LFCM),X(LEH),NAT)
        CALL DAWRIT(IDAF,IODA,X(LEG),NXYZ,3,0)
        CALL DAWRIT(IDAF,IODA,X(LEG),NXYZ,29,0)
      ENDIF
C
      CALL DAREAD(IDAF,IODA,X(LEPS),L3,403,0)
      CALL DAREAD(IDAF,IODA,X(LOPDM),N2,320,0)
      CALL GTTPDM(X(LTPDM),X(LX),X(LIX),N4,NINTMX)
C
      CALL JCPOVR(X(LFCM),X(LSDER),X(LDFC),X(LDERI),X(LDLAG),X(LDHC),
     *            X(LDSAO),X(LV),X(LOINT),X(LFCOR),X(LERI),X(LAMAT),
     *            X(LOPDM),X(LTPDM),X(LPRCDO),X(LEPS),X(LWRK),
     *            X(LWRK+L3),X(LIA),X(LIND),NCORSV,N1,NXYZ,L0,L1,L2,N2,
     *            N4,NROT,NDER,NFT18)
C
C     ----- Construct configuration part of right-hand -----
C     -----          side of CPMCSCF equations         -----
C
      CALL DAREAD(IDAF,IODA,X(LEG),NXYZ,3,0)
      CALL DAREAD(IDAF,IODA,X(LNG),NXYZ,258,0)
      CALL VSUB(X(LNG),1,X(LEG),1,X(LEG),1,NXYZ)
C
      LWAXCI = LYAC
      IF(GENMC) THEN
        CALL JCPORM(X(LDFC),X(LWAXCI),X(LDHC),X(LDERI),X(LFCOR),
     *              X(LOINT),X(LERI),X(LPRCDC),X(LPRCDS),X(LCI),
     *              X(LCIOLD),X(LWSTMP),X(LEGRAD),X(LBOX1),X(LBOX2),
     *              X(LBOX3),X(LBOX4),X(LBOX5),X(LIBO),X(LIWRK),IW,
     *              NDER,NXYZ,L1,L2,N2,N4,LNEED,JLO,JHI,NDETMX,NDETLN,
     *              NSTATS,ITGA,ITGB,IAST,IBST,IIS,NNSTAT,NB1EX)
      ELSE
        CALL JCPDET(X(LWAXCI),X(LPRCDC),X(LPRCDS),X(LCI),X(LCIOLD),
     *              X(LDFC),X(LDERI),X(LDHC),X(LFCOR),X(LERI),X(LEGRAD),
     *              X(LOINT),X(LWSTMP),X(LIBO),X(LIFA),X(LIWRK),NDETMX,
     *              NDETLN,NCI,N1,NCORSV,NA,NB,IGPDET,KSTSYM,NSYM,IIS,
     *              IW,NXYZ,L1,JLO,JHI,NSTATS,NNSTAT)
      ENDIF
C
C     ----- Write configuration part of right-hand side of -----
C     -----           CPMCSCF equations to file            -----
C
      SVDSWK = DSKWRK
      DSKWRK = .TRUE.
      CALL SEQOPN(NFT19,'WORK19','UNKNOWN',.FALSE.,'UNFORMATTED')
      CALL SEQREW(NFT19)
      DO IXYZ=1,NXYZ
        LVAL = LWAXCI + IXYZ - 1
        CALL DCOPY(NSTATS*NDETLN,X(LVAL),NXYZ,X(LTMPWK),1)
        CALL SQWRIT(NFT19,X(LTMPWK),NSTATS*NDETLN)
      ENDDO
C
      CALL RETFM(NEEDT)
  300 CONTINUE
C
C     ----- Solve CPMCSCF equations using conjugate gradient -----
C
      IWKVEC = MAX(L3,NSTATS*NDETLN)
      CALL VALFM(LOADFM)
      LRSIDO = LOADFM + 1
      LRSIDC = LRSIDO + NUNIQ*NROT
      LRSIDS = LRSIDC + NUNIQ*NDETLN*NSTATS
      LZRSO = LRSIDS + NUNIQ*NNSTAT
      LZRSC = LZRSO + NUNIQ*NROT
      LZRSS = LZRSC + NUNIQ*NDETLN*NSTATS
      LPDIRO = LZRSS + NUNIQ*NNSTAT
      LPDIRC = LPDIRO + NUNIQ*NROT
      LPDIRS = LPDIRC + NUNIQ*NDETMX*NSTATS
      LBNORMO = LPDIRS + NUNIQ*NNSTAT
      LBNORMC = LBNORMO + NUNIQ
      LBNORMS = LBNORMC + NUNIQ
      LBKNUM = LBNORMS + NUNIQ
      LBKDEN = LBKNUM + NUNIQ
      LTMPWK = LBKDEN + NUNIQ
      LDDEN = LTMPWK + MAX(2*NXYZ,IWKVEC)
      LDDEN2 = LDDEN + MAX(NSTATS*NSTATS*N1*N1,NUNIQ*N2)
      LSALAG = LDDEN2 + NUNIQ*N1*N1
      LSAGRD = LSALAG + NSTATS*NSTATS*L3
      LFCORS = LSAGRD + NSTATS*NSTATS*NXYZ
      LYTMP = LFCORS + L3
      LAST = LYTMP + NUNIQ*N1*N1*N2
      NEEDT = LAST - LOADFM - 1
      IF(EXETYP.NE.CHECK) CALL GETFM(NEEDT)
C
      IF(SOME) THEN
        WRITE(IW,9020)
        CALL TIMIT(1)
        WRITE(IW,9030) NROT,NDETMX
C
        MEMREP = NEED1 + NEED2 + NEEDT
        IF(EXETYP.EQ.CHECK) THEN
          WRITE(IW,9044)
          CALL CPCHK2(MEMREP,IW,NSTATS,NUNIQ,NXYZ,NDETMX,L3)
        ELSE
          WRITE(IW,9045) MEMREP,NGOTMX
        ENDIF
        CALL FLSHBF(IW)
      ENDIF
C
      DSKWRK = SVDSWK
C
C     NDER = 1 FOR Z-VECTOR NACME
C     NDER = 2 FOR HESSIANS OR OLD NACME
      CALL MCPCGX(X(LYAO),X(LYAC),X(LYAS),X(LPRCDO),X(LPRCDC),X(LPRCDS),
     *            X(LRSIDO),X(LRSIDC),X(LRSIDS),X(LZRSO),X(LZRSC),
     *            X(LZRSS),X(LPDIRO),X(LPDIRC),X(LPDIRS),
     *            X(LBNORMO),X(LBNORMC),X(LBNORMS),
     *            X(LBKNUM),X(LBKDEN),X(LOINT),X(LFCOR),X(LAMAT),
     *            X(LERI),X(LEPS),X(LOPDM),X(LTPDM),X(LCI),X(LTMPWK),
     *            X(LIND),X(LIA),X(LIWRK),X(LIFA),X(LIBO),NOCP,
     *            NXYZ,NUNIQ,NROT,NDETLN,NDETMX,IIS,JLO,JHI,NA,NB,NSYM,
     *            NCORSV,N1,L0,L1,L2,NFT18,NFT19,NSTATS,X(LWSTMP),
     *            X(LEGRAD),X(LSALAG),X(LDERI),X(LDDEN),X(LDDEN2),
     *            X(LFCORS),X(LYTMP),GENMC,LNEED,X(LBOX1),X(LBOX2),
     *            X(LBOX3),X(LBOX4),X(LBOX5),ITGA,ITGB,IAST,IBST,NB1EX,
     *            JROTLO,JROTHI,NDER,NAPICK,NACST)
C
      IF(EXETYP.EQ.CHECK) GO TO 400
C
C     ----- Add CPMCHF contributions to force constant matrix -----
C     -----        and symmetrize force constant matrix       -----
C
      IF(NDER.EQ.2) THEN
        CALL VCLR(X(LDDM),1,3*NXYZ)
        LDIAO = LEPS
        LDIMO = LOINT
C
        CALL FMDDEN(X(LDDEN),X(LYAC),X(LCI),X(LIFA),X(LIBO),X(LIWRK),
     *              NACT,N2,NUNIQ,NDETLN,NSYM,NA,NB,IIS,JLO,JHI,LNEED,
     *              ITGA,ITGB,IAST,IBST,X(LBOX1),X(LBOX2),X(LBOX4),
     *              X(LBOX5),GENMC)
C
        CALL UAFCM(X(LFCM),X(LDDM),X(LYAO),X(LYAC),X(LDDEN),X(LZRSO),
     *             X(LZRSC),X(LSDER),X(LCI),X(LEG),X(LOPDM),X(LV),
     *             X(LDIAO),X(LDIMO),X(LTMPWK),X(LIND),NOCP,X(LIA),L0,
     *             L1,L2,NXYZ,NUNIQ,NROT,NDETLN,NCORSV,NACT,N2,JLO,JHI,
     *             NFT18,NFT19)
C
        CALL CPSYM(X(LFCM),NXYZ)
C SUPPRESS THE HESSIAN OUTPUT IN THE SA-MCSCF CALCULATION
        IF(NSTATS.EQ.1) CALL DAWRIT(IDAF,IODA,X(LFCM),NC3,4,0)
C
        CALL VCLR(X(LFCM),1,3*NXYZ)
        CALL DAREAD(IDAF,IODA,X(LFCM),3*NXYZ,34,0)
        CALL VADD(X(LDDM),1,X(LFCM),1,X(LDDM),1,3*NXYZ)
        CALL DAWRIT(IDAF,IODA,X(LDDM),3*NXYZ,34,0)
        CALL CPSDDM(X(LDDM),X(LSK),NXYZ)
      ENDIF
C
      IF(NSTATS.GT.1) THEN
        CALL FMNAC(X(LSAGRD),X(LEGRAD),X(LNG),X(LSALAG),X(LYAO),
     *             X(LDDEN),X(LCI),X(LSDER),X(LV),X(LWRK),X(LIA),NOCP,
     *             X(LIND),X(LIFA),X(LIBO),X(LIWRK),L0,L1,NSTATS,NNSTAT,
     *             NXYZ,NUNIQ,NROT,NACT,NCORSV,NDETMX,NSYM,NA,NB,IIS,
     *             IRTTMP,NAPICK,NACST)
      ENDIF
C
      CALL DCOPY(MXRT,X(LETMP),1,ESTATE,1)
C
C     ----- Return memory and counters -----
C
      CALL RETFM(NEEDT)
      CALL RETFM(NEED2)
  400 CONTINUE
      CALL RETFM(NEEDWK)
      CALL RETFM(NEED1)
C
      IF(GOPARR) THEN
        CALL DDI_PROCDLB_DESTROY(C_VOVO)
        CALL DDI_PROCDLB_DESTROY(C_VVOO)
        CALL DDI_PROCDLB_DESTROY(C_VOOO)
        CALL DDI_PROCDLB_DESTROY(C_OOOO)
        IF(EXETYP.NE.CHECK) THEN
          IF(MASWRK) WRITE(IW,9151)
          CALL DDI_DESTROY(D_VVOO)
          IF(MASWRK) WRITE(IW,9152)
          CALL DDI_DESTROY(D_OOOO)
          IF(MASWRK) WRITE(IW,9153)
          CALL DDI_DESTROY(D_VOOO)
          IF(MASWRK) WRITE(IW,9154)
          CALL DDI_DESTROY(D_VOVO)
        ENDIF
      ENDIF
C
      IF(GENMC) THEN
        DO II=1,NSPACE+1
          MSTA(II) = MSTA(II) + NCORSV
        ENDDO
      ENDIF
C
      IF(MASWRK) WRITE(IW,9100)
      CALL TIMIT(1)
C
 9000 FORMAT(/5X,49(1H-)/
     *        5X,'COUPLED-PERTURBED MULTICONFIGURATION HARTREE-FOCK'/
     *        5X,49(1H-))
 9010 FORMAT(/1X,'SETTING UP RIGHT-HAND SIDE OF CPMCHF EQUATIONS.',
     *       /1X,'# OF WORDS REQUIRED  = ',I10,
     *       /1X,'# OF WORDS AVAILABLE = ',I10,
     *       /1X,'NOTE THAT THE CP-MCHF DISTRIBUTED MEMORY',
     *           ' REQUIREMENTS ARE JUST THE',
     *       /1X,'MEMORY NEEDED TO STORE TRANSFORMED INTEGRAL',
     *           ' CLASSES (ALLOCATED ABOVE).')
 9020 FORMAT(/1X,'FINISHED SETTING UP RIGHT-HAND SIDE.')
 9030 FORMAT(/1X,'CALCULATING MCSCF ELECTRONIC HESSIAN ON THE FLY.',
     *       /1X,'# OF ORBITAL ROTATIONS   = ',I10,
     *       /1X,'LENGTH OF DET. EXPANSION = ',I10)
 9044 FORMAT(/1X,'ESSENTIAL CPMCHF SOLVER MEMORY.')
 9045 FORMAT(/1X,'SOLVING CPMCHF EQUATIONS - ESSENTIAL MEMORY.',
     *       /1X,'# OF WORDS REQUIRED  = ',I10,
     *       /1X,'# OF WORDS AVAILABLE = ',I10)
 9100 FORMAT(/1X,'...... DONE WITH CPMCHF EQUATIONS ......')
 9151 FORMAT(1X,'FREEING DISTRIBUTED STORAGE FOR',
     *          ' [VIR VIR|OCC OCC] INTEGRALS')
 9152 FORMAT(1X,'FREEING DISTRIBUTED STORAGE FOR',
     *          ' [OCC OCC|OCC OCC] INTEGRALS')
 9153 FORMAT(1X,'FREEING DISTRIBUTED STORAGE FOR',
     *          ' [VIR OCC|OCC OCC] INTEGRALS')
 9154 FORMAT(1X,'FREEING DISTRIBUTED STORAGE FOR',
     *          ' [VIR OCC|VIR OCC] INTEGRALS')
 9060 FORMAT(1X,'COMPUTING HESSIAN OF STATE WITH E=',F20.10,' S=',F5.1)
 9065 FORMAT(1X,'COMPUTING NACME FOR STATE WITH E=',F20.10,' S=',F5.1)
 9360 FORMAT(/1X,'***** ERROR IN -CPMCX- ROUTINE *****'/
     *       1X,'CI EIGENVECTOR FILE HAS DATA FOR NSTATE,NDETS=',I3,I10/
     *       1X,'BUT THE PRESENT CALCULATION HAS NSTATE,NDETS=',I3,I10)
      RETURN
      END
C*MODULE CPMCHF  *DECK NACMEX
      SUBROUTINE NACMEX(ENCALC)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION METHOD
C     ,NACME
C
      LOGICAL ENCALC,FIRST,SECND,CPHF,BOTH,MFIRST,MSECND,MCPHF,
     *        SVGPAR,SVDSKW,SVDTRF,
     *        DIRTRF,GOPARR,DSKWRK,MASWRK,
     *        CANONC,FCORE,FORS,EKT,LINSER,
     *        NAPICK
C
      PARAMETER (MXRT=100, MXATM=2000, MXNORO=250)
C
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,S,SZ,
     *                GRPDET,STSYM,GLIST,DWPARM,
     *                NFLGDM(MXRT),IWTS(MXRT),NCORSV,NCOR,NACT,NDTORB,
     *                MNA,MNB,K,KSTDET,IROOT,IPURES,MAXW1,NITER,MAXP,
     *                NCIDET,IGPDET,KSTSYM,NFTGCI,IDWEIGH
      COMMON /FUNCT / E,EG(3*MXATM)
      COMMON /HSSPAR/ FIRST,SECND,CPHF,BOTH,MFIRST,MSECND,MCPHF
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /TRFOPT/ CUTTRF,NWDTRF,MPTRAN,ITRFAO,NOSYMT,IPURTF,DIRTRF
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWORD,NORBMC,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
C
      PARAMETER (ZERO=0.0D+00, TOL=1.0D-09)
C
      DATA CHECK/8HCHECK   /
      DATA ORMAS/8HORMAS   /
C
C     ----- driver for Non-Adiabatic Coupling Matrix Elements -----
C     The NACME program written by Tim Dudley of Villanova University
C                 completed in the summer of 2008
C     This driver also handles computation of SA-MCSCF gradients.
C     This driver may only be called for MCSCF wavefunctions!
C
C     We take the easy way out with symmetry usage, turning it off
C     for the entire calculation.
C     1. In some cases, perhaps when the electronic state is totally
C        symmetric, it is OK to turn symmetry off after the integral
C        transformation, and thus be sure of getting a wavefunction
C        with good symmetry control.  But, see the MgH2 test case.
C     2. Symmetry must be off in the integral derivative terms.
C     3. Symmetry is also turned off in the response equations, but
C        it almost works to solve for only symmetry unique responses.
C        Some sort of clever symmetrization routine is needed.
C
      CALL SYMOFF
C
C     we only use 1st derivative ints from the 2nd derivative package
C
      FIRST=.TRUE.
      SECND=.FALSE.
      CPHF =.TRUE.
      BOTH =.FALSE.
      MFIRST=.TRUE.
      MSECND=.FALSE.
      MCPHF =.TRUE.
C
      CALL BASCHK(MAXL)
      IF(MAXL.GT.2) THEN
         IF(MASWRK) WRITE(IW,*) 'RUNTYP=NACME IS LIMITED TO S,P,D AOS'
         CALL ABRT
      END IF
C
      NSTATS = 0
      DO ISTAT=1,MXRT
         IF(WSTATE(ISTAT).GT.TOL) NSTATS = NSTATS+1
      ENDDO
      IF(NSTATS.EQ.1) THEN
        IF(MASWRK) WRITE(IW,9030)
        CALL ABRT
      END IF
C
C     ----- READ $CPHF INPUT -----
C
      CALL CPINP
C
C     ----- GET THE ENERGY AND THE WAVEFUNCTION -----
C
      IF(ENCALC) CALL ENERGX
      IF(E.EQ.ZERO  .AND.  EXETYP.NE.CHECK) THEN
         IF(MASWRK) WRITE(IW,9040)
         CALL ABRT
      END IF
C
C         MCSCF response code requires A DISTRIBUTED MEMORY PARALLEL
C         INTEGRAL TRANSFORMATION, AND so is "parallel", even for p=1.
C         the wavefunction, just above, is allowed to be serial.
C
      SVDSKW = DSKWRK
      SVGPAR = GOPARR
      SVDTRF = DIRTRF
      GOPARR = .TRUE.
      DIRTRF = .TRUE.
C
C     ----- INTEGRAL TRANSFORMATION -----
C     The MCSCF response equations use distributed MO integrals, only.
C
      NOCC=NCORSV+NACT
      NPR = 0
      IF(NPRINT.EQ.-5) NPR=-5
      CALL TRFMCX(NPR,0,NOCC,NQMT,.FALSE.,.FALSE.,.TRUE.,.TRUE.,
     *            .TRUE.,.TRUE.,.TRUE.,.FALSE.,.FALSE.,.TRUE.)
C
C     ----- OPEN DERIVATIVE FOCK (DERIVATIVE LAGRANGIAN) MATRIX FILE
C
      NFT18 = 18
      DSKWRK = .FALSE.
      CALL SEQOPN(NFT18,'FOCKDER','UNKNOWN',.FALSE.,'UNFORMATTED')
C
C     ----- ONE ELECTRON INTEGRAL DERIVATIVE TERMS -----
C
      CALL STVDD
C
C     ----- DIPOLE INTEGRALS AND THEIR DERIVATIVES -----
C
      CALL CALCOM(XC,YC,ZC)
      CALL DIPINT(XC,YC,ZC,.FALSE.)
      CALL DDINT
C
C     ----- TWO ELECTRON INTEGRAL DERIVATIVE TERMS -----
C
      CALL DDERJK
C
C     ----- SOLVE THE COUPLED PERTURBED EQUATIONS -----
C
      DSKWRK=.TRUE.
C
C     NOTE:  THE ORDER OF THE NEXT 3 ITEMS MATTERS.
C     1)  USE THE LEAST NUMBER OF RESPONSES BASED ON THE 2 CODES
C         (WITHOUT USER CHOSEN NACMES)
C     2)  USER COULD REQUEST Z-VECTOR CODE, CHOOSE NA COUPLINGS,
C         AND SOLVE FOR LESS RESPONSES BY CHOICE
C         (DYNAMICS DRIVER TYPICALLY CONTROLS THESE CHOICES)
C         (2 FOLLOWS 1 TO FORCE ANY REASONABLE USER INPUTS)
C     3)  TRANSITION DENSITY FOR CISTEP=ORMAS ONLY CODED IN ZCPMCX
C         (ALWAYS LASTLY FORCE THIS OPTION UNTIL NEW CODE DEVELOPMENT)
      NAPICK=.FALSE.
      ITMP = NSTATS*(NSTATS+1)/2
      ITMP2 = 3*NAT
      IF (ITMP.LT.ITMP2) NAPICK=.TRUE.
      CALL CPNAGET(NAPICK)
      IF (CISTEP.EQ.ORMAS) NAPICK=.TRUE.
      IF (NAPICK) THEN
C       ALWAYS SET NAPICK BACK TO FALSE HERE FOR INSIDE SUB. MCPCGX.
        NAPICK=.FALSE.
        CALL ZCPMCX
      ELSE
        CALL CPMCX
      ENDIF
C
      CALL SYMON
C
      DSKWRK = SVDSKW
      GOPARR = SVGPAR
      DIRTRF = SVDTRF
C
      RETURN
C
 9030 FORMAT(/1X,'CONFUSION, ONLY ONE STATE IN SA-MC GRADIENT,',
     *           ' OR NACME RUN?')
 9040 FORMAT(//1X,'ENERGY DID NOT CONVERGE...ABORTING HESSIAN'//)
      END
C*MODULE CPMCHF  *DECK DETCP
      SUBROUTINE DETCP(IW,IBO,NACT,NA,NB,IDSYM,ISYM1,NSYM,NALP,NBLP,
     *                 ICON,ISYMA,ISYMB,ICOA,ICOB,ITAB,IMUL,ISPA,ISPB,
     *                 ISAS,ISBS,ISAC,ISBC,NSTATS,CI,CIOLD)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION CI(*),CIOLD(*)
      DIMENSION ICON(*)
      DIMENSION ISPA(NALP),ISPB(NBLP),ICOA(NSYM),ICOB(NSYM)
      DIMENSION ISYMA(NALP),ISYMB(NBLP),ITAB(NSYM)
      DIMENSION ISAS(NSYM+1),ISBS(NSYM+1)
      DIMENSION ISAC(NALP),ISBC(NBLP)
      DIMENSION IMUL(NSYM,NSYM)
      DIMENSION IBO(NACT)
C
C     ----- This code is similar to SYMWRK in aldeci.src -----
C
      CALL GTAB(IDSYM,ISYM1,ITAB,ICON(1),ICON(4),ICON(7),ICON(10))
      CALL GMUL(IDSYM,IMUL,ICON(1),ICON(4),ICON(7),ICON(10))
C
      DO 13 II=1,NSYM
         ISAS(II) = 0
         ISBS(II) = 0
         ICOA(II) = 0
         ICOB(II) = 0
   13 CONTINUE
C
      DO 23 II=1,NB
        ICON(II) = II
   23 CONTINUE
C
      DO 43 IB=1,NBLP
        CALL GETSYM1(IW,ICON(1),NACT,NB,IBO,IDSYM,ISYM,
     *               ICON(NA+1),ICON(NA+4),ICON(NA+7),ICON(NA+10))
        ISYMB(IB) = ISYM
        ICOB(ISYM) = ICOB(ISYM) + 1
        ISPB(IB) = ICOB(ISYM)
        CALL ADVANC(ICON,NB,NACT)
   43 CONTINUE
C
      DO 33 II=1,NA
        ICON(II) = II
   33 CONTINUE
C
C     ----- Expand the ci vector over all determinants -----
C     -----     if performing hessian calculation      -----
C
      NCI = 0
      IVAL = 1
      JVAL = 1
      DO 53 IA=1,NALP
        CALL GETSYM1(IW,ICON(1),NACT,NA,IBO,IDSYM,ISYM,
     *               ICON(NA+1),ICON(NA+4),ICON(NA+7),ICON(NA+10))
        ISYMA(IA) = ISYM
        ICOA(ISYM) = ICOA(ISYM) + 1
        ISPA(IA) = NCI
        NCI = NCI + ICOB(ITAB(ISYM))
        CALL ADVANC(ICON,NA,NACT)
        IF(NSTATS.GT.1) GO TO 53
C
        DO 50 IB=1,NBLP
          JSYM = IMUL(ISYM,ISYMB(IB))
          IF(JSYM.EQ.ISYM1) THEN
            CI(IVAL) = CIOLD(JVAL)
            JVAL = JVAL + 1
          END IF
          IVAL = IVAL + 1
   50   CONTINUE
   53 CONTINUE
C
      IF(NSTATS.GT.1) THEN
        CALL DCOPY(NSTATS*NCI,CIOLD,1,CI,1)
        ISAS(1) = 1
        ISBS(1) = 1
        ISAS(NSYM+1) = NALP + 1
        ISBS(NSYM+1) = NBLP + 1
C
        DO 63 II=2,NSYM
          ISAS(II) = ISAS(II-1) + ICOA(ITAB(II-1))
          ISBS(II) = ISBS(II-1) + ICOB(ITAB(II-1))
   63   CONTINUE
C
        DO 73 II=1,NSYM
          ICOA(II) = 0
          ICOB(II) = 0
   73   CONTINUE
C
        DO 83 IA=1,NALP
          NSA = ISYMA(IA)
          ICOA(NSA) = ICOA(NSA) + 1
          ISAC(ISAS(ITAB(NSA))+ICOA(NSA)-1) = IA
   83   CONTINUE
C
        DO 93 IB=1,NBLP
          NSA = ISYMB(IB)
          ICOB(NSA) = ICOB(NSA) + 1
          ISBC(ISBS(ITAB(NSA))+ICOB(NSA)-1) = IB
   93   CONTINUE
C
        RETURN
      ENDIF
C
C     ----- Now reset quantities to reflect C1 symmetry -----
C     -----      if performing hessian calculation      -----
C
      DO 103 IB=1,NBLP
        ISYMB(IB) = 1
        ICOB(1) = IB
        ISPB(IB) = ICOB(1)
        ISBC(IB) = IB
  103 CONTINUE
C
      NCI = 0
      DO 113 IA=1,NALP
        ISYMA(IA) = 1
        ICOA(1) = IA
        ISPA(IA) = NCI
        ISAC(IA) = IA
        NCI = NCI + NBLP
  113 CONTINUE
C
      ISAS(1) = 1
      ISBS(1) = 1
      ISAS(2) = NALP + 1
      ISBS(2) = NBLP + 1
C
      DO 123 II=1,NACT
        IBO(II) = 1
  123 CONTINUE
C
      CALL GTAB(1,1,ITAB,ICON(1),ICON(4),ICON(7),ICON(10))
      CALL GMUL(1,IMUL,ICON(1),ICON(4),ICON(7),ICON(10))
C
      RETURN
      END
C*MODULE CPMCHF  *DECK FMAVEC
      SUBROUTINE FMAVEC(AVEC,YAO,AMAT,OINT,IROT,INDEX,L1,NCOR,NACT,
     *                  NNACT,NXYZ,NROT,NINDX,JRLO,JRHI)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION AVEC(NXYZ,NNACT),YAO(NXYZ,NROT),AMAT(L1,NCOR,NNACT),
     *          OINT(L1,L1)
      DIMENSION IROT(L1,L1),INDEX(NINDX,NINDX)
C
      PARAMETER (TWO=2.0D+00,TOL=1.0D-09)
C
      CALL VCLR(AVEC,1,NXYZ*NNACT)
C
      DO 100 M=1,L1
        DO 20 N=1,NCOR
          IPHSE = IROT(M,N)
          MN = IABS(IPHSE)
          IF(MN.LT.JRLO .OR. MN.GT.JRHI) GO TO 20
          DO 10 IJ=1,NNACT
            DVAL = AMAT(M,N,IJ)
            DVAL = DVAL*MN/IPHSE
            IF(ABS(DVAL).LT.TOL) GO TO 10
            CALL DAXPY(NXYZ,DVAL,YAO(1,MN),1,AVEC(1,IJ),1)
   10     CONTINUE
   20   CONTINUE
C
        DO 60 I=1,NACT
          II = I+NCOR
          IPHSE = IROT(M,II)
          MI = IABS(IPHSE)
          IF(MI.LT.JRLO .OR. MI.GT.JRHI) GO TO 60
          DO 50 J=1,NACT
            DVAL = OINT(M,J+NCOR)*MI/IPHSE
            IF(ABS(DVAL).LT.TOL) GO TO 50
            IJ = INDEX(I,J)
            IF(I.EQ.J) DVAL = DVAL*TWO
            CALL DAXPY(NXYZ,DVAL,YAO(1,MI),1,AVEC(1,IJ),1)
   50     CONTINUE
   60   CONTINUE
  100 CONTINUE
C
      RETURN
      END
C*MODULE CPMCHF  *DECK FMDDEN
      SUBROUTINE FMDDEN(DDEN,YAC,CI,IFA,IOX,IWRK,NACT,NNACT,NUNIQ,
     *                  NDETLN,NSYM,NA,NB,IIS,JLO,JHI,LNEED,ITGA,ITGB,
     *                  IAST,IBST,LBOX1,LBOX2,LBOX4,LBOX5,GENMC)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,FDIRCT,QCORR,GENMC
C
      DIMENSION DDEN(NUNIQ,NNACT),YAC(NUNIQ,NDETLN),CI(*)
      DIMENSION IFA(0:NACT,0:NACT),IOX(NACT),IWRK(IIS)
      DIMENSION LBOX1(*),LBOX2(*),LBOX4(*),LBOX5(*)
C
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIM(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      IF(GENMC) THEN
        LWRK = 1
        LKTAB = LWRK + 43
        LGMUL = LKTAB + NSYM
        LCON = LGMUL + NSYM*NSYM
        LCOA = LCON + NA
        LCOB = LCOA + NSYM*ITGA
        LANDET = LCOB + NSYM*ITGB
        LBNDET = LANDET + NSPACE*ITGA
        NAST = LBNDET + NSPACE*ITGB
        NBST = NAST + ITGA + 1
        LSYMA = NBST + ITGB + 1
        LSYMB = LSYMA + IAST
        LGCOM = LSYMB + IBST
        LSPA = LGCOM + ITGB*ITGA
        LSPB = LSPA + IAST
        LDISB = LSPB + IBST
        LSAS = LDISB + NSYM*ITGB*ITGA
        LSBS = LSAS + (NSYM+1)*ITGA
        LSAC = LSBS + (NSYM+1)*ITGB
        LSBC = LSAC + IAST
        LIND = LSBC + IBST
        LACON1 = LIND + NNACT + 1
        LACON2 = LACON1 + NA
        LBCON1 = LACON2 + NA
        LBCON2 = LBCON1 + NA
        ITOT = LBCON2 + NA - 1
      ELSE
        NALP = IFA(NACT,NA)
        NBLP = IFA(NACT,NB)
C
        ISYMA = 1
        ISYMB = ISYMA + NALP
        ICOA = ISYMB + NBLP
        ICOB = ICOA + NSYM
        ITAB = ICOB + NSYM
        IMUL = ITAB + NSYM
        ISPA = IMUL + NSYM*NSYM
        ISPB = ISPA + NALP
        ISAS = ISPB + NBLP
        ISBS = ISAS + NSYM+1
        ISAC = ISBS + NSYM+1
        ISBC = ISAC + NALP
C
        IACON1 = ISBC + NBLP
        IBCON1 = IACON1 + NA + 43
        IACON2 = IBCON1 + NA
        IBCON2 = IACON2 + NA
        IPOSA = IBCON2 + NB
        IPERA = IPOSA + (NA*(NACT-NA))
        IIND1 = IPERA + (NA*(NACT-NA))
        INDEX = IIND1 + (NA*(NACT-NA))
        ITOT = INDEX + NACT*NACT - 1
      ENDIF
C
      IF (ITOT.GT.IIS) THEN
         IF(MASWRK) THEN
           WRITE(IW,*) 'NOT ENOUGH MEMORY SPECIFIED FOR IWRK'
           WRITE(IW,*) 'ASKED FOR ',IIS,' NEED ',ITOT
         END IF
         CALL ABRT
      ENDIF
C
      IF(GENMC) THEN
        CALL ORMDD1(DDEN,YAC,NDETLN,NUNIQ,JLO,JHI,NNACT,NACT,NA,NB,
     *              X(LBST(1)),LNEED,CI,IWRK(LIND),NSYM,IOX,LBOX1,
     *              LBOX2,LBOX4,LBOX5,IWRK(LKTAB),IWRK(LACON1),
     *              IWRK(LACON2),IWRK(LBCON1),IWRK(LBCON2),IWRK(LANDET),
     *              IWRK(LBNDET),IWRK(NAST),IWRK(NBST),IWRK(LSYMA),
     *              IWRK(LSYMB),IWRK(LGCOM),IWRK(LSPA),IWRK(LSPB),
     *              IWRK(LDISB),IWRK(LSAS),IWRK(LSBS),IWRK(LSAC),
     *              ITGA,ITGB,IAST,IBST)
      ELSE
        CALL MATDD1(DDEN,YAC,CI,NNACT,NUNIQ,NACT,NA,NB,NDETLN,NALP,NBLP,
     *              IFA,IOX,NSYM,IWRK(IACON1),IWRK(IBCON1),IWRK(IACON2),
     *              IWRK(IPOSA),IWRK(IPERA),IWRK(IIND1),IWRK(INDEX),
     *              IWRK(ISYMA),IWRK(ISYMB),IWRK(ISPA),IWRK(ISPB),
     *              IWRK(ISAS),IWRK(ISBS),IWRK(ISAC),IWRK(ISBC),JLO,JHI)
      ENDIF
C
      IF(GOPARR) CALL DDI_GSUMF(2188,DDEN,NUNIQ*NNACT)
C
      RETURN
      END
C*MODULE CPMCHF  *DECK FMNAC
      SUBROUTINE FMNAC(SAGRAD,EGRAD,DNUC,SALAG,YAO,TDEN,CIVEC,SDER,V,
     *                 WRK,IA,NOCP,INDEX,IFA,IOX,IWRK,L0,L1,NSTATS,
     *                 NNSTAT,NXYZ,NUNIQ,NROT,NACT,NCOR,NDETMX,NSYM,
     *                 NA,NB,IIS,IRTTMP,NAPICK,NACST)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION SAGRAD(NXYZ,NSTATS*NSTATS),EGRAD(NXYZ,NNSTAT),
     *          DNUC(NXYZ),SALAG(L1,L1,NSTATS*NSTATS),YAO(NUNIQ,NROT),
     *          TDEN(NACT,NACT,NSTATS*NSTATS),CIVEC(NDETMX,NSTATS),
     *          SDER(NXYZ,L1,L1),V(L1,L1),WRK(*)
      DIMENSION IA(*),NOCP(NXYZ),INDEX(L1,L1),IFA(*),IOX(*),IWRK(IIS)
C
      LOGICAL NAPICK
C
      PARAMETER (MXGTOT=20000, MXSH=5000, MXRT=100)
C
      DIMENSION NACST(MXRT*(MXRT-1))
C
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,
     *                EDFT(2),EDISP
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
C      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00,TWO=2.0D+00)
C
      L3 = L1*L1
      NSTAT2 = NSTATS*NSTATS
C
      DO 20 ISTAT=1,NSTATS
        DO 20 JSTAT=1,NSTATS
          IG = MAX(ISTAT,JSTAT)
          JG = MIN(ISTAT,JSTAT)
          IJG = IA(IG) + JG
          IJSTAT = (ISTAT-1)*NSTATS + JSTAT
          CALL DCOPY(NXYZ,EGRAD(1,IJG),1,SAGRAD(1,IJSTAT),1)
          IF(ISTAT.NE.JSTAT) THEN
            EVAL = ESTATE(ISTAT) - ESTATE(JSTAT)
            EVAL = ONE/EVAL
            CALL DSCAL(NXYZ,EVAL,SAGRAD(1,IJSTAT),1)
          ELSE
            CALL VADD(DNUC,1,SAGRAD(1,IJSTAT),1,SAGRAD(1,IJSTAT),1,NXYZ)
          ENDIF
   20 CONTINUE
C
C     ----- Generate CI portion of non-adiabatic coupling -----
C     -----  matrix elements, noting that diagonal terms  -----
C     -----   are state-averaged MCSCF energy gradients   -----
C
      DO 100 I=1,L0
        DO 100 J=1,I
          IPHSE = INDEX(I,J)
          IROT = IABS(IPHSE)
          IF(IROT.EQ.0) GO TO 100
C
          DO 90 ISTAT=1,NSTATS
            DO 90 JSTAT=1,NSTATS
              IJSTAT = (ISTAT-1)*NSTATS + JSTAT
              EVAL = ONE
              IF(ISTAT.NE.JSTAT) EVAL = ESTATE(ISTAT) - ESTATE(JSTAT)
              DVAL = SALAG(I,J,IJSTAT) - SALAG(J,I,IJSTAT)
              DVAL = TWO*DVAL/EVAL
              IUNIQ = 0
              DO 80 IXYZ=1,NXYZ
                IF(NOCP(IXYZ).EQ.1) GO TO 80
                IUNIQ = IUNIQ + 1
                DTMP = YAO(IUNIQ,IROT)*DVAL
                SAGRAD(IXYZ,IJSTAT) = SAGRAD(IXYZ,IJSTAT) + DTMP
   80         CONTINUE
   90     CONTINUE
  100 CONTINUE
C
C     ----- Generate CSF portion of non-adiabatic coupling -----
C     -----                 matrix elements                -----
C
      NTOT = NCOR+NACT
      CALL FMTDEN(TDEN,CIVEC,IFA,IOX,IWRK,NACT,NSTATS,NDETMX,NSYM,
     *            NA,NB,IIS,NCOR,NTOT,L1,ESTATE)
C
      DO 200 IXYZ=1,NXYZ
        DO 150 I=1,NACT
          DO 150 J=1,NACT
            SVAL = SDER(IXYZ,I+NCOR,J+NCOR)
            SVAL = SVAL/TWO
            DO 120 ISTAT=1,NSTATS
              DO 120 JSTAT=1,NSTATS
                IF(ISTAT.EQ.JSTAT) GO TO 120
                IJSTAT = (ISTAT-1)*NSTATS + JSTAT
                JISTAT = (JSTAT-1)*NSTATS + ISTAT
                DVAL = SVAL*TDEN(I,J,JISTAT)
                SAGRAD(IXYZ,IJSTAT) = SAGRAD(IXYZ,IJSTAT) - DVAL
  120       CONTINUE
  150   CONTINUE
  200 CONTINUE
C
      DO 300 MU=1,L1
        DO 300 NU=1,L1
          DO 250 ISTAT=1,NSTAT2
            DVAL = ZERO
            DO 220 I=1,NACT
              CVAL = V(MU,I+NCOR)
              DO 220 J=1,NACT
                DVAL = DVAL + CVAL*V(NU,J+NCOR)*TDEN(I,J,ISTAT)
  220       CONTINUE
            SALAG(MU,NU,ISTAT) = DVAL
  250     CONTINUE
  300 CONTINUE
C
      DO 400 M=1,3
        IF(M.EQ.1) CALL DAREAD(IDAF,IODA,WRK,L3,63,0)
        IF(M.EQ.2) CALL DAREAD(IDAF,IODA,WRK,L3,64,0)
        IF(M.EQ.3) CALL DAREAD(IDAF,IODA,WRK,L3,65,0)
        DO 360 ISHELL=1,NSHELL
          IAT  = KATOM(ISHELL)
          IXYZ = 3*(IAT-1)
          LOCI = KLOC(ISHELL) - KMIN(ISHELL)
          MINI = KMIN(ISHELL)
          MAXI = KMAX(ISHELL)
          DO 340 ISTAT=1,NSTATS
            DO 340 JSTAT=1,NSTATS
              IF(ISTAT.EQ.JSTAT) GO TO 340
              IJSTAT = (ISTAT-1)*NSTATS + JSTAT
              JISTAT = (JSTAT-1)*NSTATS + ISTAT
              DVAL = ZERO
C
              DO 320 I=MINI,MAXI
                II = LOCI + I
                DO 320 JJ=1,L1
                  IIJJ = (JJ-1)*L1 + II
                  DVAL = DVAL + SALAG(JJ,II,JISTAT)*WRK(IIJJ)
  320         CONTINUE
C
              SAGRAD(IXYZ+M,IJSTAT) = SAGRAD(IXYZ+M,IJSTAT) + DVAL
  340     CONTINUE
  360   CONTINUE
  400 CONTINUE
C
C     ----- Since we have a CASSCF wavefunction, we don't need -----
C     ----- to consider the perturbed orbital contribution to  -----
C     -----                      CSF NACME                     -----
C
C      DO ISTAT=1,NSTATS*NSTATS
C        CALL PRSQ(TDEN(1,1,ISTAT),NACT,NACT,NACT)
C      ENDDO
C
C           prints raw results:
C     IF(MASWRK) then
C        WRITE(IW,*) ' '
C        WRITE(iw,*) 'dump of THE ENTIRE NACME/SA-GRADIENT ARRAY'
C        CALL PRSQ(SAGRAD,NSTATS*NSTATS,NXYZ,NXYZ)
C     end if
C
C
      CALL PRTNAC(SAGRAD,EGRAD,NXYZ,NSTATS,NNSTAT,
     *            IRTTMP,NAPICK,NACST)
C
      RETURN
      END
C*MODULE CPMCHF  *DECK FMPAIR
      SUBROUTINE FMPAIR(INDEX,IOX,MSTA,NCOR,NACT,NUM,NQMT,NROT,NDER,
     *                  NSPACE,GENMC,NOCAS)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION INDEX(NUM,NUM),IOX(NUM),MSTA(*)
      LOGICAL GENMC,NOCAS
C
C     Determine independent orbital rotations for CASSCF
C     wavefunctions
C
      NOCC = NCOR+NACT
      L3 = NUM**2
      CALL VICLR(INDEX,1,L3)
C
C     Active-core
C
      IJ=-1
      DO 100 I=NCOR+1,NOCC
        IS1 = IOX(I)
        DO 80 J=1,NCOR
          IS2 = IOX(J)
          IF((IS1.NE.IS2) .AND. (NDER.NE.2)) GO TO 80
          INDEX(J,I) = IJ
          INDEX(I,J) = IABS(IJ)
          IJ = IJ-1
   80   CONTINUE
  100 CONTINUE
C
C     Virtual-occupied
C
      DO 200 I=NOCC+1,NQMT
        IS1 = IOX(I)
        DO 180 J=1,NOCC
          IS2 = IOX(J)
          IF((IS1.NE.IS2) .AND. (NDER.NE.2)) GO TO 180
          INDEX(J,I) = IJ
          INDEX(I,J) = IABS(IJ)
          IJ = IJ-1
  180   CONTINUE
  200 CONTINUE
C
C     Active-active orbital rotations for non-CAS wavefunctions
C
      IF(GENMC .AND. NOCAS) THEN
        DO 400 II=NSPACE,1,-1
          DO 350 JJ=1,II-1
            DO 340 I=MSTA(II),MSTA(II+1)-1
              IS1 = IOX(I)
              DO 320 J=MSTA(JJ),MSTA(JJ+1)-1
                IS2 = IOX(J)
                IF((IS1.NE.IS2) .AND. (NDER.NE.2)) GO TO 320
                INDEX(J,I) = IJ
                INDEX(I,J) = IABS(IJ)
                IJ = IJ-1
  320         CONTINUE
  340       CONTINUE
  350     CONTINUE
  400   CONTINUE
      ENDIF
C
      NROT = IABS(IJ) - 1
C
      RETURN
      END
C*MODULE CPMCHF  *DECK FMRHS
      SUBROUTINE FMRHS(RHSO,RHSC,RHSS,CI,EGRAD,WSTATE,WRK,INDEX,NOCP,
     *                 NXYZ,NUNIQ,NROT,NDETLN,NOCC,L1,NFT18,NFT19,
     *                 NSTATS,JLO,JHI,NCI,NNSTAT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,SVDSWK
C
      DIMENSION RHSO(NUNIQ,NROT),RHSC(NUNIQ,NSTATS*NDETLN),
     *          RHSS(NUNIQ,NNSTAT),CI(NCI,NSTATS),EGRAD(NXYZ,NNSTAT),
     *          WSTATE(*),WRK(*)
      DIMENSION INDEX(L1,L1),NOCP(NXYZ)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (TWO=2.0D+00)
C
      CALL VCLR(RHSO,1,NUNIQ*NROT)
      CALL VCLR(RHSS,1,NUNIQ*NNSTAT)
      CALL VCLR(RHSC,1,NUNIQ*NSTATS*NDETLN)
      L3 = L1*L1
      NDETS = JHI-JLO+1
C
C     ----- Form orbital part of rhs of CPMCSCF equations -----
C
      SVDSWK = DSKWRK
      DSKWRK = .FALSE.
      CALL SEQREW(NFT18)
C
      IUNIQ = 0
      DO 100 IXYZ=1,NXYZ
        CALL SQREAD(NFT18,WRK,L3)
        IF(NOCP(IXYZ).EQ.1) GO TO 100
        IUNIQ=IUNIQ+1
C
        DO 50 J=1,NOCC
          DO 50 I=1,L1
            IJ = (J-1)*L1 + I
            IPHSE = INDEX(I,J)
            IROT = IABS(IPHSE)
            IF(IROT.EQ.0) GO TO 50
            DLT = IROT
            DLT = DLT/IPHSE
            RHSO(IUNIQ,IROT) = RHSO(IUNIQ,IROT) + DLT*WRK(IJ)
   50   CONTINUE
  100 CONTINUE
      CALL DSCAL(NUNIQ*NROT,TWO,RHSO,1)
C
C     ----- Form configuration part of rhs of CPMCSCF equations -----
C
      DSKWRK = .TRUE.
      CALL SEQREW(NFT19)
      IUNIQ = 0
C
      DO 200 IXYZ=1,NXYZ
        IF(NOCP(IXYZ).EQ.1) THEN
          CALL SEQADV(NFT19)
          GO TO 200
        ENDIF
C
        IUNIQ = IUNIQ + 1
        NLEN = NSTATS*NDETLN
        CALL SQREAD(NFT19,WRK,NLEN)
        CALL DCOPY(NSTATS*NDETLN,WRK,1,RHSC(IUNIQ,1),NUNIQ)
C
        DO 150 ISTAT=1,NSTATS
          II = (ISTAT-1)*NDETLN + 1
          DO 150 JSTAT=1,NSTATS
            IG = MAX(ISTAT,JSTAT)
            JG = MIN(ISTAT,JSTAT)
            IJ = (IG*IG-IG)/2 + JG
            DVAL = EGRAD(IXYZ,IJ)
            CALL DAXPY(NDETS,-DVAL,CI(JLO,JSTAT),1,RHSC(IUNIQ,II),NUNIQ)
  150   CONTINUE
C
C     ----- Form state-state part of rhs of CPMCSCF equations -----
C
        IJSTAT = 0
        DO 180 ISTAT=1,NSTATS
          DO 180 JSTAT=1,ISTAT-1
            IJSTAT = IJSTAT + 1
            IJ = (ISTAT*ISTAT-ISTAT)/2 + JSTAT
            DVAL = WSTATE(JSTAT)-WSTATE(ISTAT)
            DVAL = TWO*DVAL
            RHSS(IUNIQ,IJSTAT) = DVAL*EGRAD(IXYZ,IJ)
  180   CONTINUE
  200 CONTINUE
C
      DO ISTAT=1,NSTATS
        IVAL = (ISTAT-1)*NDETLN + 1
        DVAL = TWO*WSTATE(ISTAT)
        CALL DSCAL(NUNIQ*NDETLN,DVAL,RHSC(1,IVAL),1)
      ENDDO
C
      DSKWRK = SVDSWK
C
      RETURN
      END
C*MODULE CPMCHF  *DECK FMRHSO
      SUBROUTINE FMRHSO(RHSO,YADEN,Y1DEN,ERI,AMAT,OINT,WRK,IROT,INDEX,
     *                  NACT,NNACT,NCOR,NXYZ,L1,NROT,NINDX)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION RHSO(NXYZ,NROT),YADEN(NXYZ,NACT,NACT*NNACT),
     *          Y1DEN(NXYZ,NNACT),ERI(L1,NACT,NNACT),
     *          AMAT(L1,NCOR,NNACT),WRK(NXYZ),OINT(L1,L1)
      DIMENSION IROT(L1,L1),INDEX(NINDX,NINDX)
C
      PARAMETER (ONE=1.0D+00,TWO=2.0D+00,TOL=1.0D-09)
C
      N1 = NACT*NNACT
      N2 = NXYZ*NACT
C
      DO 1000 M=1,L1
        DO 200 I=1,NACT
          IPHSE = IROT(M,I+NCOR)
          MI = IABS(IPHSE)
          IF(MI.EQ.0) GO TO 200
          DTMP = ONE*MI/IPHSE
          DO IXYZ=1,NXYZ
            WRK(IXYZ) = DDOT(N1,ERI(M,1,1),L1,YADEN(IXYZ,I,1),N2)
          ENDDO
          CALL DAXPY(NXYZ,DTMP,WRK,1,RHSO(1,MI),1)
C
          DO 100 J=1,NACT
            DVAL = OINT(M,J+NCOR)*MI/IPHSE
            IF(ABS(DVAL).LT.TOL) GO TO 100
            JI = INDEX(J,I)
            IF(I.EQ.J) DVAL = TWO*DVAL
            CALL DAXPY(NXYZ,DVAL,Y1DEN(1,JI),1,RHSO(1,MI),1)
  100     CONTINUE
  200   CONTINUE
C
        DO 400 I=1,NCOR
          IPHSE = IROT(M,I)
          MI = IABS(IPHSE)
          IF(MI.EQ.0) GO TO 400
          DO 300 K=1,NACT
            DO 300 L=1,K
              KL = INDEX(K,L)
              DVAL = AMAT(M,I,KL)*MI/IPHSE
              IF(ABS(DVAL).LT.TOL) GO TO 300
              CALL DAXPY(NXYZ,DVAL,Y1DEN(1,KL),1,RHSO(1,MI),1)
  300     CONTINUE
  400   CONTINUE
C
 1000 CONTINUE
C
      RETURN
      END
C*MODULE CPMCHF  *DECK FMTDEN
      SUBROUTINE FMTDEN(TDEN,CI,IFA,IOX,IWRK,NACT,NSTATS,NDETMX,NSYM,
     *                  NA,NB,IIS,NCORE,NTOT,L1,ESTATE)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION TDEN(NACT,NACT,NSTATS*NSTATS),CI(NDETMX,NSTATS)
      DIMENSION IFA(0:NACT,0:NACT),IOX(NACT),IWRK(IIS)
      DIMENSION ESTATE(NSTATS)
C
      common /fmcom / xx(1)
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      NALP = IFA(NACT,NA)
      NBLP = IFA(NACT,NB)
C
      ISYMA = 1
      ISYMB = ISYMA + NALP
      ICOA = ISYMB + NBLP
      ICOB = ICOA + NSYM
      ITAB = ICOB + NSYM
      IMUL = ITAB + NSYM
      ISPA = IMUL + NSYM*NSYM
      ISPB = ISPA + NALP
      ISAS = ISPB + NBLP
      ISBS = ISAS + NSYM+1
      ISAC = ISBS + NSYM+1
      ISBC = ISAC + NALP
C
      IACON1 = ISBC + NBLP
      IBCON1 = IACON1 + NA + 43
      IACON2 = IBCON1 + NA
      IBCON2 = IACON2 + NA
      IPOSA = IBCON2 + NB
      IPERA = IPOSA + (NA*(NACT-NA))
      IIND1 = IPERA + (NA*(NACT-NA))
      INDEX = IIND1 + (NA*(NACT-NA))
      ITOT = INDEX + NACT*NACT - 1
C
      IF (ITOT.GT.IIS) THEN
         IF(MASWRK) THEN
           WRITE(IW,*) 'NOT ENOUGH MEMORY SPECIFIED FOR IWRK'
           WRITE(IW,*) 'ASKED FOR ',IIS,' NEED ',ITOT
         END IF
         CALL ABRT
      ENDIF
C
      CALL MATTD1(TDEN,CI,NSTATS,NACT,NA,NB,NDETMX,NALP,
     *            NBLP, IFA,IOX,NSYM,IWRK(IACON1),IWRK(IBCON1),
     *            IWRK(IACON2),IWRK(IPOSA),IWRK(IPERA),IWRK(IIND1),
     *            IWRK(INDEX),IWRK(ISYMA),IWRK(ISYMB),IWRK(ISPA),
     *            IWRK(ISPB),IWRK(ISAS),IWRK(ISBS),IWRK(ISAC),
     *            IWRK(ISBC))
C
      l2 = (l1*l1+l1)/2
      nstats2 = (nstats*nstats+nstats)/2
      call valfm(loadfm)
      lxao = loadfm + 1
      lyao = lxao   + l2
      lzao = lyao   + l2
      lxmo = lzao   + l2
      lymo = lxmo   + ntot*ntot
      lzmo = lymo   + ntot*ntot
      losc = lzmo   + ntot*ntot
      lvao = losc   + nstats2
      last = lvao   + l1*l1
      need = last - loadfm - 1
      call getfm(need)
c
      call detosc(tden,nact,nstats,nstats2,l1,l2,ntot,estate,ncore,
     *            xx(lxao),xx(lyao),xx(lzao),xx(lxmo),xx(lymo),xx(lzmo),
     *            xx(losc),xx(lvao))
c
      call retfm(need)
C
      RETURN
      END
C*MODULE CPMCHF  *DECK GTTPDM
      SUBROUTINE GTTPDM(TPDM,XX,IX,NIJKL,NINTMX)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,DWSAVE
C
      DIMENSION TPDM(NIJKL),XX(*),IX(*)
C
      COMMON /CIFILS/ NFT11,NFT12,NFT13,NFT14,NFT15,NFT16,IDAF20,NEMEMX
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCKLAB/ LABSIZ
C
      CALL VCLR(TPDM,1,NIJKL)
      DWSAVE = DSKWRK
      DSKWRK = .FALSE.
C
      IF(MASWRK) THEN
        CALL SEQREW(NFT15)
 2000   CONTINUE
        CALL PREAD(NFT15,XX,IX,NXX,NINTMX)
        IF(NXX.NE.0) THEN
          MGIJKL=IABS(NXX)
          IF(MGIJKL.GT.NINTMX) CALL ABRT
          DO 2100 MG=1,MGIJKL
             GGIJKL=XX(MG)
C
             NPACK = MG
             IF (LABSIZ .EQ. 2) THEN
*I32              LABEL1 = IX( 2*NPACK - 1 )
*I32              LABEL2 = IX( 2*NPACK     )
*I32              IPACK = ISHFT( LABEL1, -16 )
*I32              JPACK = IAND( LABEL1, 65535 )
*I32              KPACK = ISHFT( LABEL2, -16 )
*I32              LPACK = IAND( LABEL2, 65535 )
*I64              LABEL = IX(NPACK)
*I64              IPACK = ISHFT( LABEL, -48 )
*I64              JPACK = IAND( ISHFT( LABEL, -32 ), 65535 )
*I64              KPACK = IAND( ISHFT( LABEL, -16 ), 65535 )
*I64              LPACK = IAND( LABEL, 65535 )
              ELSE IF (LABSIZ .EQ. 1) THEN
*I32              LABEL = IX(NPACK)
*I32              IPACK = ISHFT( LABEL, -24 )
*I32              JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
*I32              KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
*I32              LPACK = IAND( LABEL, 255 )
*I64              IF ( MOD(NPACK,2) .EQ. 0 ) THEN
*I64                LABEL = IX( NPACK/2 )
*I64                IPACK = IAND( ISHFT( LABEL, -24 ), 255 )
*I64                JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
*I64                KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
*I64                LPACK = IAND( LABEL, 255 )
*I64            ELSE
*I64                LABEL = IX( (NPACK/2)+1 )
*I64                IPACK = ISHFT( LABEL, -56 )
*I64                JPACK = IAND( ISHFT( LABEL, -48 ), 255 )
*I64                KPACK = IAND( ISHFT( LABEL, -40 ), 255 )
*I64                LPACK = IAND( ISHFT( LABEL, -32 ), 255 )
*I64            END IF
              END IF
              IG = IPACK
              JG = JPACK
              KG = KPACK
              LG = LPACK
C
              II = MAX(IG,JG)
              JJ = MIN(IG,JG)
              IJ = (II*II-II)/2 + JJ
              KK = MAX(KG,LG)
              LL = MIN(KG,LG)
              KL = (KK*KK-KK)/2 + LL
              IJG = MAX(IJ,KL)
              KLG = MIN(IJ,KL)
              IJKL = (IJG*IJG-IJG)/2 + KLG
C
              TPDM(IJKL) = GGIJKL
 2100     CONTINUE
          IF(NXX.GT.0) GO TO 2000
        END IF
C
      ENDIF
C
      IF(GOPARR) CALL DDI_BCAST(2150,'F',TPDM,NIJKL,MASTER)
      DSKWRK = DWSAVE
C
      RETURN
      END
C*MODULE CPMCHF  *DECK HSMLTC
      SUBROUTINE HSMLTC(RHSC,RHSO,RHSS,YAO,YAC,YAS,PRCNDS,SALAG,CI,OINT,
     *                  FCOR,AMAT,ERI,IROT,IWRK,IFA,IOX,NCOR,NACT,NA,NB,
     *                  L1,L2,NSYM,IIS,NDETMX,NDETLN,NROT,NUNIQ,JLO,JHI,
     *                  NSTATS,WSTATE,WRK,YADEN,AVEC,BVEC,YAOTMP,ITER,
     *                  GENMC,LNEED,LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,ITGA,
     *                  ITGB,IAST,IBST,NB1EX,JROTLO,JROTHI)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL FDIRCT,QCORR,GENMC
C
      DIMENSION RHSC(NUNIQ,NSTATS*NDETLN),RHSO(NUNIQ,NROT),
     *          RHSS(NUNIQ,*),YAO(NUNIQ,NROT),YAC(NUNIQ,NSTATS*NDETMX),
     *          YAS(NUNIQ,*),PRCNDS(*),SALAG(L1,L1,NSTATS*NSTATS),
     *          CI(NDETMX,NSTATS),OINT(L2),FCOR(L1,L1),AMAT(*),ERI(*),
     *          WSTATE(*),WRK(*),YADEN(*),AVEC(*),BVEC(*),YAOTMP(*)
      DIMENSION LBOX1(*),LBOX2(*),LBOX3(*),LBOX4(*),LBOX5(*)
      DIMENSION IROT(L1,L1),IWRK(IIS),IFA(0:NACT,0:NACT),IOX(NACT)
C
      PARAMETER (MXRT=100)
C
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,
     *                EDFT(2),EDISP
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIM(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (HALF=0.5D+00,FOUR=4.0D+00,TOL=1.0D-09)
C
      NALP = IFA(NACT,NA)
      NBLP = IFA(NACT,NB)
      NINDX = (NACT**2+NACT)/2
      IF(L1.GT.NINDX) NINDX = L1
      NNSTAT = (NSTATS*NSTATS+NSTATS)/2
      L3 = L1*L1
      NNACT = (NACT*NACT+NACT)/2
      NDETVL = JHI-JLO+1
C
      CALL VCLR(RHSC,1,NDETLN*NSTATS*NUNIQ)
      CALL VCLR(RHSS,1,NUNIQ*NNSTAT)
      CALL VCLR(YADEN,1,NUNIQ*NACT*NACT*NNACT)
C
      IF(GENMC) THEN
        IF(.NOT.FDIRCT) THEN
          IDIM1 = NSYM + 1
          IDIM2 = IBST + 1
        ELSE
          IDIM1 = 1
          IDIM2 = 1
        ENDIF
C
        LWRK = 1
        LKTAB = LWRK + 43
        LGMUL = LKTAB + NSYM
        LCON = LGMUL + NSYM*NSYM
        LCOA = LCON + NA
        LCOB = LCOA + NSYM*ITGA
        LANDET = LCOB + NSYM*ITGB
        LBNDET = LANDET + NSPACE*ITGA
        NAST = LBNDET + NSPACE*ITGB
        NBST = NAST + ITGA + 1
        LSYMA = NBST + ITGB + 1
        LSYMB = LSYMA + IAST
        LGCOM = LSYMB + IBST
        LSPA = LGCOM + ITGB*ITGA
        LSPB = LSPA + IAST
        LDISB = LSPB + IBST
        LSAS = LDISB + NSYM*ITGB*ITGA
        LSBS = LSAS + (NSYM+1)*ITGA
        LSAC = LSBS + (NSYM+1)*ITGB
        LSBC = LSAC + IAST
        LIND = LSBC + IBST
        LACON1 = LIND + NNACT + 1
        LACON2 = LACON1 + NA
        LBCON1 = LACON2 + NA
        LBCON2 = LBCON1 + NA
        IPOSA = LBCON2 + NA
        IPERA = IPOSA + NA*(NACT-NA)*NSYM
        IIND1 = IPERA + NA*(NACT-NA)*NSYM
        IIND2 = IIND1 + NA*(NACT-NA)*NSYM
        IIND3 = IIND2 + NA*(NACT-NA)*NSYM
        IGROA = IIND3 + NA*(NACT-NA)*NSYM
        IMMC = IGROA + NA*(NACT-NA)*NSYM
        INDEX2 = IMMC + NSYM
        JB1GR = INDEX2 + NINDX*NINDX
        JB1PE = JB1GR + NB1EX
        JB1IN = JB1PE + NB1EX
        JB1PO = JB1IN + NB1EX
        JB1ST = JB1PO + NB1EX
        JB1SY = JB1ST + IDIM1*IDIM2
        JB1IN2 = JB1SY + NB*(NACT-NB)
        ITOT = JB1IN2 + 2*NB1EX - 1
      ELSE
        ISYMA = 1
        ISYMB = ISYMA + NALP
        ICOA = ISYMB + NBLP
        ICOB = ICOA + NSYM
        ITAB = ICOB + NSYM
        IMUL = ITAB + NSYM
        ISPA = IMUL + NSYM*NSYM
        ISPB = ISPA + NALP
        ISAS = ISPB + NBLP
        ISBS = ISAS + NSYM+1
        ISAC = ISBS + NSYM+1
        ISBC = ISAC + NALP
C
        IACON1 = ISBC + NBLP
        IBCON1 = IACON1 + NA + 43
        IACON2 = IBCON1 + NA
        IBCON2 = IACON2 + NA
        IPOSA = IBCON2 + NB
        IPERA = IPOSA + (NA*(NACT-NA))
        IIND1 = IPERA + (NA*(NACT-NA))
        INDEX = IIND1 + 3*(NA*(NACT-NA))
        IMMA = INDEX + NINDX**2
        IMMC = IMMA + NSYM*(NA*(NACT-NA))
        ISTRB = IMMC + NSYM
        ISTRP = ISTRB + ((NB*(NACT-NB))*NBLP)/2
        ISTAR = ISTRP + ((NB*(NACT-NB))*NBLP)/2
        ITOT = ISTAR + NBLP - 1
C
        CALL SETUP(NACT,0,NA,NB,IWRK(IBCON1),
     *             IWRK(IACON2),IFA,IWRK(INDEX),IWRK(ISPB),NBLP,
     *             IWRK(ISTRB),IWRK(ISTRP),IWRK(ISTAR))
      ENDIF
C
      IF(ITOT.GT.IIS) THEN
        IF(MASWRK) THEN
          WRITE(IW,*) 'NOT ENOUGH MEMORY SPECIFIED FOR IWRK'
          WRITE(IW,*) 'ASKED FOR ',IIS,' NEED ',ITOT
        END IF
        CALL ABRT
      END IF
C
C     ----- Calculate terms independent of coupling constants -----
C
      DHCME = ENUCR
      DO I=1,NCOR
        II = (I*I+I)/2
        DHCME = DHCME + OINT(II) + FCOR(I,I)
      ENDDO
C
      IF(NSTATS.GT.1 .AND. ITER.EQ.1) THEN
        CALL VCLR(SALAG,1,L3*NSTATS*NSTATS)
C
        DO 200 M=JLO,JHI
          DO 150 ISTAT=1,NSTATS
            CVAL = CI(M,ISTAT)
            IF(ABS(CVAL).LT.TOL) GO TO 150
            DO 100 I=1,L1
              DO 100 J=1,NCOR
                IPHSE = IROT(I,J)
                IF(IPHSE.EQ.0) GO TO 100
                DVAL = FOUR*CVAL
                DVAL = DVAL*FCOR(I,J)
                DO JSTAT=1,NSTATS
                  DTMP = DVAL*CI(M,JSTAT)
                  IJSTAT = (ISTAT-1)*NSTATS + JSTAT
                  SALAG(I,J,IJSTAT) = SALAG(I,J,IJSTAT) + DTMP
                ENDDO
  100       CONTINUE
  150     CONTINUE
  200   CONTINUE
      ENDIF
C
C          ----- Configuation/Orbital Cross Terms -----
C
      CALL VCLR(WRK,1,2*NUNIQ)
      DO 300 ISTAT=1,NSTATS
        WVAL = WSTATE(ISTAT)
        IYM = (ISTAT-1)*NDETMX + JLO
        DO IUNIQ=1,NUNIQ
          DVAL = DDOT(NDETVL,CI(JLO,ISTAT),1,YAC(IUNIQ,IYM),NUNIQ)
          WRK(NUNIQ+IUNIQ) = WRK(NUNIQ+IUNIQ) + DVAL*WVAL
        ENDDO
  300 CONTINUE
C
      DO 400 I=1,L1
        DO 400 J=1,NCOR
          IPHSE = IROT(I,J)
          IJ = IABS(IPHSE)
          IF(IJ.EQ.0) GO TO 400
          DVAL = FOUR*IJ/IPHSE
          DVAL = DVAL*FCOR(I,J)
          CALL DAXPY(NUNIQ,DVAL,YAO(1,IJ),1,WRK,1)
          CALL DAXPY(NUNIQ,DVAL,WRK(NUNIQ+1),1,RHSO(1,IJ),1)
  400 CONTINUE
C
      DO 450 ISTAT=1,NSTATS
        WVAL = WSTATE(ISTAT)
        IWM = (ISTAT-1)*NDETLN + 1
        DO IUNIQ=1,NUNIQ
          DVAL = WVAL*WRK(IUNIQ)
          CALL DAXPY(NDETVL,DVAL,CI(JLO,ISTAT),1,RHSC(IUNIQ,IWM),NUNIQ)
        ENDDO
  450 CONTINUE
C
C     ----- Configuation Hessian Terms -----
C
      DO 500 ISTAT=1,NSTATS
        WVAL = WSTATE(ISTAT)
        IM = (ISTAT-1)*NDETLN + 1
        HVAL = WVAL*(DHCME-ESTATE(ISTAT))
        IYM = (ISTAT-1)*NDETMX
        DO 500 JSTAT=1,NSTATS
          DVAL = ESTATE(ISTAT) - ESTATE(JSTAT)
          DVAL = DVAL*WVAL
          DVAL = DVAL + HALF
          DO IUNIQ=1,NUNIQ
            DTMP = DDOT(NDETMX,CI(1,JSTAT),1,YAC(IUNIQ,IYM+1),NUNIQ)
            DTMP = DTMP*DVAL
            CALL DAXPY(NDETVL,DTMP,CI(JLO,JSTAT),1,RHSC(IUNIQ,IM),NUNIQ)
            IF(ISTAT.EQ.JSTAT) THEN
              CALL DAXPY(NDETVL,HVAL,YAC(IUNIQ,IYM+JLO),NUNIQ,
     *                   RHSC(IUNIQ,IM),NUNIQ)
            ENDIF
          ENDDO
  500 CONTINUE
C
C     ----- Calculate terms dependent on coupling constants -----
C
      CALL HSSCXO(YAOTMP,YAO,ERI,IROT,NUNIQ,NACT,NCOR,NNACT,NROT,L1,
     *            JROTLO,JROTHI,GOPARR)
C
      IF(GENMC) THEN
        CALL HSSCX1(AVEC,YAC,YAO,AMAT,FCOR,IROT,IWRK(INDEX2),BVEC,RHSC,
     *              RHSO,YADEN,ERI,WRK(NUNIQ+1),WRK,YAOTMP,WSTATE,SALAG,
     *              CI,NCOR,JLO,JHI,NSTATS,NDETLN,ITER,NINDX,NROT,
     *              NUNIQ,L1,NACT,NDETMX,NA,NB,X(LBST(1)),LNEED,
     *              IWRK(LIND),NSYM,IOX,LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,
     *              IWRK(LGMUL),IWRK(LKTAB),IWRK(LACON1),IWRK(LACON2),
     *              IWRK(LBCON1),IWRK(LBCON2),IWRK(LANDET),IWRK(LBNDET),
     *              IWRK(NAST),IWRK(NBST),IWRK(LSYMA),IWRK(LSYMB),
     *              IWRK(LGCOM),IWRK(LSPA),IWRK(LSPB),IWRK(LDISB),
     *              IWRK(LSAS),IWRK(LSBS),IWRK(LSAC),IWRK(LSBC),ITGA,
     *              ITGB,IAST,IBST,IWRK(IPOSA),IWRK(IPERA),IWRK(IIND1),
     *              IWRK(IGROA),IWRK(IMMC),NB1EX,IWRK(JB1GR),
     *              IWRK(JB1PE),IWRK(JB1IN),IWRK(JB1PO),IWRK(JB1ST),
     *              IWRK(JB1IN2),IWRK(IIND2),IWRK(IIND3),IDIM1,IDIM2,
     *              JROTLO,JROTHI)
      ELSE
        CALL HSSCX2(NACT,NCOR,NA,NB,NALP,NBLP,IFA,IOX,NSYM,IWRK(IACON1),
     *              IWRK(IBCON1),IWRK(IACON2),IWRK(IPOSA),IWRK(IPERA),
     *              IWRK(IIND1),IWRK(INDEX),IWRK(IMMA),IWRK(IMMC),
     *              IWRK(ISYMA),IWRK(ISYMB),IWRK(ITAB),IWRK(IMUL),
     *              IWRK(ISPA),IWRK(ISPB),IWRK(ISAS),IWRK(ISBS),
     *              IWRK(ISAC),IWRK(ISBC),IWRK(ISTRB),IWRK(ISTRP),
     *              IWRK(ISTAR),CI,FCOR,AMAT,ERI,L1,NROT,NDETMX,
     *              IROT,RHSC,RHSO,YAO,YAC,NDETLN,NUNIQ,NINDX,JLO,JHI,
     *              NSTATS,WSTATE,SALAG,WRK,WRK(NUNIQ+1),YADEN,AVEC,
     *              BVEC,YAOTMP,ITER,JROTLO,JROTHI)
      ENDIF
C
C     ----- Finish with Lagrangian terms if SAMC -----
C
      IF(NSTATS.EQ.1) GO TO 2000
C
      IF(ITER.EQ.1) THEN
        CALL DSCAL(L3*NSTATS*NSTATS,HALF,SALAG,1)
        IF(GOPARR) CALL DDI_GSUMF(2174,SALAG,L3*NSTATS*NSTATS)
      ENDIF
C
      CALL VCLR(WRK,1,2*NUNIQ)
      DO 600 ISTAT=1,NSTATS
        DO 600 JSTAT=1,NSTATS
          JY = (JSTAT-1)*NDETMX + JLO
          WVAL = WSTATE(JSTAT)
          DO IUNIQ=1,NUNIQ
            DLT = DDOT(NDETVL,CI(JLO,ISTAT),1,YAC(IUNIQ,JY),NUNIQ)
            WRK(IUNIQ) = -DLT*WVAL
          ENDDO
C
          IJSTAT = (ISTAT-1)*NSTATS + JSTAT
          JISTAT = (JSTAT-1)*NSTATS + ISTAT
          DO 550 I=1,L1
            DO 550 J=1,I
             IPHSE = IROT(I,J)
             IF(IPHSE.EQ.0) GO TO 550
             IJ = IABS(IPHSE)
             DVAL = SALAG(I,J,IJSTAT) + SALAG(I,J,JISTAT)
             DVAL = DVAL - SALAG(J,I,IJSTAT) - SALAG(J,I,JISTAT)
             CALL DAXPY(NUNIQ,DVAL,WRK,1,RHSO(1,IJ),1)
C
             CALL DAXPY(NUNIQ,DVAL,YAO(1,IJ),1,WRK(NUNIQ+1),1)
  550     CONTINUE
C
          CALL DSCAL(NUNIQ,-WVAL,WRK(NUNIQ+1),1)
          JW = (JSTAT-1)*NDETLN + 1
          DO IUNIQ=1,NUNIQ
            DVAL = WRK(NUNIQ+IUNIQ)
            CALL DAXPY(NDETVL,DVAL,CI(JLO,ISTAT),1,RHSC(IUNIQ,JW),NUNIQ)
          ENDDO
  600 CONTINUE
C
C          ----- State-orbital contribution -----
C
      DO 700 I=1,L1
        DO 700 J=1,I
          IPHSE = IROT(I,J)
          IF(IPHSE.EQ.0) GO TO 700
          IJ = IABS(IPHSE)
          IJVAL = 0
          DO 650 ISTAT=1,NSTATS
            DO 620 JSTAT=1,ISTAT-1
              IJVAL = IJVAL + 1
              IJSTAT = (ISTAT-1)*NSTATS + JSTAT
              JISTAT = (JSTAT-1)*NSTATS + ISTAT
              WVAL = WSTATE(JSTAT) - WSTATE(ISTAT)
              DVAL = SALAG(I,J,IJSTAT) + SALAG(I,J,JISTAT)
              DVAL = DVAL - SALAG(J,I,IJSTAT) - SALAG(J,I,JISTAT)
              DVAL = WVAL*DVAL
              CALL DAXPY(NUNIQ,DVAL,YAO(1,IJ),1,RHSS(1,IJVAL),1)
              IF(MASWRK) THEN
                CALL DAXPY(NUNIQ,DVAL,YAS(1,IJVAL),1,RHSO(1,IJ),1)
              ENDIF
  620       CONTINUE
  650     CONTINUE
  700 CONTINUE
C
C     ----- Add state-state hessian contribution -----
C
      IJSTAT = 0
      DO 1000 ISTAT=1,NSTATS
        DO 1000 JSTAT=1,ISTAT-1
          IJSTAT = IJSTAT + 1
          DVAL = HALF*PRCNDS(IJSTAT)
          CALL DAXPY(NUNIQ,DVAL,YAS(1,IJSTAT),1,RHSS(1,IJSTAT),1)
 1000 CONTINUE
C
 2000 CONTINUE
      RETURN
      END
C*MODULE CPMCHF  *DECK HSMLTN
      SUBROUTINE HSMLTN(YAOG,YAO,I,J,K,L,IJ,KL,NACT,NNACT,NXYZ,DPHSE)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION YAOG(NXYZ),YAO(NXYZ,NACT*NACT,NNACT)
C
      PARAMETER (TWO=2.0D+00)
C
      IIJJ = (J-1)*NACT + I
      DLT = DPHSE
      IF(I.EQ.J) DLT = TWO*DLT
      IF(IJ.EQ.KL) DLT = TWO*DLT
      CALL DAXPY(NXYZ,DLT,YAO(1,IIJJ,KL),1,YAOG,1)
C
      IF(I.EQ.J) GO TO 200
      JJII = (I-1)*NACT + J
      DLT = DPHSE
      IF(IJ.EQ.KL) DLT = TWO*DLT
      CALL DAXPY(NXYZ,DLT,YAO(1,JJII,KL),1,YAOG,1)
C
  200 IF(IJ.EQ.KL) RETURN
      KKLL = (L-1)*NACT + K
      DLT = DPHSE
      IF(K.EQ.L) DLT = TWO*DLT
      CALL DAXPY(NXYZ,DLT,YAO(1,KKLL,IJ),1,YAOG,1)
C
      IF(K.EQ.L) RETURN
      LLKK = (K-1)*NACT + L
      DLT = DPHSE
      CALL DAXPY(NXYZ,DLT,YAO(1,LLKK,IJ),1,YAOG,1)
C
      RETURN
      END
C*MODULE CPMCHF  *DECK HSMLTP
C> @brief      Performs matvec with orbital Hessian.
C> 
C> @author     Tim Dudley
C>             -2003
C> 
C> @details    Performs matvec on trial vector with
C>             SA-MCSCF orbital Hessian.
C>             This routine is for coupled perturbed
C>             MCSCF equations only at the moment.
C>
C> @date July 29, 2013-Aaron West
C> -Fixed long time bug for ORMAS orbital Hessian.
C>  Aaron West,Tim Dudley,Mike Schmidt,Theresa Windus made fix possible.
C> 
      SUBROUTINE HSMLTP(RHSO,YAO,OINT,EPS,OPDM,TPDM,BUFF,INDEX,IA,
     *                  NROT,NUNIQ,NCOR,NACT,L0,L1,L2)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER         C_OOOO, C_VOOO, C_VVOO, C_VOVO
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION RHSO(NUNIQ,NROT),YAO(NUNIQ,NROT),OINT(L2),EPS(L1,L1),
     *          OPDM(*),TPDM(*),BUFF(*)
      DIMENSION INDEX(L1,L1),IA(*)
C
      COMMON /DLBTIM/ C_OOOO,C_VOOO,C_VVOO,C_VOVO
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      INTEGER         D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB
      LOGICAL         NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
      COMMON /TRFDMS/ D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB,
     *                NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
C
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00,TWO=2.0D+00,FOUR=4.0D+00)
      PARAMETER (HALF=0.5D+00,TOL=1.0D-09)
C
      NOCC = NACT + NCOR
      NOTR = (NOCC*NOCC+NOCC)/2
      IVAL = (L1-NOCC)*L1
C
      NVIR = L0 - NOCC
C
      NBVIR = L0 - NOCC
      NBTR = (NBVIR*NBVIR+NBVIR)/2
      NBSQ = NBVIR*NBVIR
C
      CALL VCLR(BUFF,1,L2)
      CALL VCLR(EPS(1,NOCC+1),1,IVAL)
      CALL VCLR(RHSO,1,NROT*NUNIQ)
C
C     ----- Construct full one-particle density matrix -----
C
      DO I=1,NCOR
        II = IA(I) + I
        BUFF(II) = TWO
      ENDDO
C
      DO 10 I=NCOR+1,NOCC
        DO 10 J=NCOR+1,I
          IJ = IA(I) + J
          IIJJ = IA(I-NCOR) + J-NCOR
          BUFF(IJ) = OPDM(IIJJ)
   10 CONTINUE
C
C     ----- Construct one-electron contribution to orbital hessian -----
C
      IF(MASWRK) THEN
        DO 30 K=1,L0
          DO 30 L=1,K
            KL = IABS(INDEX(K,L))
            IF(KL.EQ.0) GO TO 30
C
            DO 20 I=1,L0
              IG = MAX(I,K)
              KG = MIN(I,K)
              IK = IA(IG)+KG
              IG = MAX(I,L)
              LG = MIN(I,L)
              IL = IA(IG)+LG
              DO 20 J=1,I
                IJ = IABS(INDEX(I,J))
                IF(IJ.EQ.0) GO TO 20
                JG = MAX(J,K)
                KG = MIN(J,K)
                JK = IA(JG)+KG
                JG = MAX(J,L)
                LG = MIN(J,L)
                JL = IA(JG)+LG
C
                DVAL = ZERO
                DVAL = DVAL + OINT(IK)*BUFF(JL)
                DVAL = DVAL + OINT(JL)*BUFF(IK)
                DVAL = DVAL - OINT(JK)*BUFF(IL)
                DVAL = DVAL - OINT(IL)*BUFF(JK)
                IF((I.EQ.L).AND.(K.LE.NOCC)) DVAL = DVAL + EPS(J,K)
                IF(J.EQ.K) DVAL = DVAL + EPS(I,L)
                IF(I.EQ.K) DVAL = DVAL - EPS(J,L)
                IF((J.EQ.L).AND.(K.LE.NOCC)) DVAL = DVAL - EPS(I,K)
C
                CALL DAXPY(NUNIQ,DVAL,YAO(1,KL),1,RHSO(1,IJ),1)
   20       CONTINUE
   30   CONTINUE
      ENDIF
C
C     ----- Construct two-electron part of orbital hessian -----
C
      IP = 0
      CALL TSECND(T0)
      DO 8000 IP=0,NPROC-1
        IWP = MOD(ME+IP,NPROC)
C
C     ----- Get and use (OO|OO) integrals -----
C
        CALL DDI_DISTRIB(D_OOOO,IWP,ILO,IHI,JLO,JHI)
        MAXWRK = JHI-JLO+1
C
        CALL DDI_PROCDLB_NEXT(C_OOOO,IWP,ICNTR1)
C
        DO WHILE(ICNTR1.LT.MAXWRK)
          IJ = JLO + ICNTR1
C
          DO II=1,NOCC
            DO JJ=1,II
              IJTMP = IA(II) + JJ
              IF(IJTMP.EQ.IJ) THEN
                I = II
                J = JJ
                GO TO 40
              ENDIF
            ENDDO
          ENDDO
C
   40     CALL DDI_GET(D_OOOO,1,NOTR,IJ,IJ,BUFF)
C
C          ----- Coulomb contribution to orbital hessian -----
C          -----       Inner indices are both core       -----
C
          DO 100 N=1,NCOR
            JNG = IABS(INDEX(J,N))
            IF(JNG.EQ.0) GO TO 70
            DO 60 M=1,NCOR
              IMG = IABS(INDEX(I,M))
              IF(IMG.EQ.0) GO TO 60
              MG = MAX(M,N)
              NG = MIN(M,N)
              MN = IA(MG) + NG
C
              DVAL = ZERO
              IF(M.EQ.N) THEN
                DO K=1,NCOR
                  KK = IA(K) + K
                  DVAL = DVAL + BUFF(KK)
                ENDDO
                DVAL = DVAL*TWO
C
                DO 50 K=1,NACT
                  DO 50 L=1,K
                    KL = IA(K+NCOR) + L+NCOR
                    XIJKL = BUFF(KL)
                    IF(K.NE.L) XIJKL = TWO*XIJKL
                    KL = IA(K) + L
                    DVAL = DVAL + OPDM(KL)*XIJKL
   50           CONTINUE
              ENDIF
C
              DVAL = DVAL - BUFF(MN)
              DVAL = DVAL*TWO
              IF(N.GT.J) DVAL = -DVAL
              IF(M.GT.I) DVAL = -DVAL
              CALL DAXPY(NUNIQ,DVAL,YAO(1,JNG),1,RHSO(1,IMG),1)
   60       CONTINUE
C
   70       IF(I.EQ.J) GO TO 100
            ING = IABS(INDEX(I,N))
            IF(ING.EQ.0) GO TO 100
            DO 90 M=1,NCOR
              JMG = IABS(INDEX(J,M))
              IF(JMG.EQ.0) GO TO 90
              MG = MAX(M,N)
              NG = MIN(M,N)
              MN = IA(MG) + NG
C
              DVAL = ZERO
              IF(M.EQ.N) THEN
                DO K=1,NCOR
                  KK = IA(K) + K
                  DVAL = DVAL + BUFF(KK)
                ENDDO
                DVAL = DVAL*TWO
C
                DO 80 K=1,NACT
                  DO 80 L=1,K
                    KL = IA(K+NCOR) + L+NCOR
                    XIJKL = BUFF(KL)
                    IF(K.NE.L) XIJKL = TWO*XIJKL
                    KL = IA(K) + L
                    DVAL = DVAL + OPDM(KL)*XIJKL
   80           CONTINUE
              ENDIF
C
              DVAL = DVAL - BUFF(MN)
              DVAL = TWO*DVAL
              IF(N.GT.I) DVAL = -DVAL
              IF(M.GT.J) DVAL = -DVAL
              CALL DAXPY(NUNIQ,DVAL,YAO(1,ING),1,RHSO(1,JMG),1)
   90       CONTINUE
  100     CONTINUE
C
C          ----- Coulomb contribution to orbital hessian -----
C          -----    One core index, one active index     -----
C
          DO 200 N=1,NCOR
            JNG = IABS(INDEX(J,N))
            IF(JNG.EQ.0) GO TO 150
            DO 120 M=1,NACT
              IMG = IABS(INDEX(I,M+NCOR))
              IF(IMG.EQ.0) GO TO 120
              DO K=1,NACT
                KN = IA(K+NCOR) + N
                XIJKL = BUFF(KN)
                KG = MAX(K,M)
                MG = MIN(K,M)
                KM = IA(KG) + MG
                IF(N.GT.J) XIJKL = -XIJKL
                IF((M+NCOR).GT.I) XIJKL = -XIJKL
                DVAL = XIJKL*OPDM(KM)
                CALL DAXPY(NUNIQ,-DVAL,YAO(1,JNG),1,RHSO(1,IMG),1)
                CALL DAXPY(NUNIQ,-DVAL,YAO(1,IMG),1,RHSO(1,JNG),1)
              ENDDO
  120       CONTINUE
C
  150       ING = IABS(INDEX(I,N))
            IF(ING.EQ.0) GO TO 200
C------------
C           ORMAS BUG FIX 7-29-2013
            IF(I.EQ.J) GO TO 200
C------------
            DO 170 M=1,NACT
              JMG = IABS(INDEX(J,M+NCOR))
              IF(JMG.EQ.0) GO TO 170
              DO K=1,NACT
                KN = IA(K+NCOR) + N
                XIJKL = BUFF(KN)
                KG = MAX(K,M)
                MG = MIN(K,M)
                KM = IA(KG) + MG
                IF(N.GT.I) XIJKL = -XIJKL
                IF((M+NCOR).GT.J) XIJKL = -XIJKL
                DVAL = XIJKL*OPDM(KM)
                CALL DAXPY(NUNIQ,-DVAL,YAO(1,JMG),1,RHSO(1,ING),1)
                CALL DAXPY(NUNIQ,-DVAL,YAO(1,ING),1,RHSO(1,JMG),1)
              ENDDO
  170       CONTINUE
  200     CONTINUE
C
C          ----- Coulomb contribution to orbital hessian -----
C          -----      Inner indices are both active      -----
C
          DO 300 N=1,NACT
            JNG = IABS(INDEX(J,N+NCOR))
            IF(JNG.EQ.0) GO TO 250
            DO 240 M=1,NACT
              IMG = IABS(INDEX(I,M+NCOR))
              IF(IMG.EQ.0) GO TO 240
              MG = MAX(M,N)
              NG = MIN(M,N)
              MN = IA(MG) + NG
C
              DVAL = ZERO
              DO K=1,NCOR
                KK = IA(K) + K
                DVAL = DVAL + BUFF(KK)
              ENDDO
              DVAL = TWO*DVAL
              DVAL = OPDM(MN)*DVAL
C
              DO 220 K=1,NACT
                DO 210 L=1,K
                  KL = IA(K+NCOR) + L+NCOR
                  XIJKL = BUFF(KL)
                  IF(ABS(XIJKL).LT.TOL) GO TO 210
                  IF(K.NE.L) XIJKL = TWO*XIJKL
                  KL = IA(K) + L
                  MNG = MAX(MN,KL)
                  KLG = MIN(MN,KL)
                  MNKL = IA(MNG) + KLG
                  DVAL = DVAL + TPDM(MNKL)*XIJKL
  210           CONTINUE
  220         CONTINUE
C
              IF((N+NCOR).GT.J) DVAL = -DVAL
              IF((M+NCOR).GT.I) DVAL = -DVAL
              CALL DAXPY(NUNIQ,DVAL,YAO(1,JNG),1,RHSO(1,IMG),1)
  240       CONTINUE
C
  250       IF(I.EQ.J) GO TO 300
            ING = IABS(INDEX(I,N+NCOR))
            IF(ING.EQ.0) GO TO 300
            DO 290 M=1,NACT
              JMG = IABS(INDEX(J,M+NCOR))
              IF(JMG.EQ.0) GO TO 290
              MG = MAX(M,N)
              NG = MIN(M,N)
              MN = IA(MG) + NG
C
              DVAL = ZERO
              DO K=1,NCOR
                KK = IA(K) + K
                DVAL = DVAL + BUFF(KK)
              ENDDO
              DVAL = TWO*DVAL
              DVAL = OPDM(MN)*DVAL
C
              DO 270 K=1,NACT
                DO 270 L=1,K
                  KL = IA(K+NCOR) + L+NCOR
                  XIJKL = BUFF(KL)
                  IF(ABS(XIJKL).LT.TOL) GO TO 260
                  IF(K.NE.L) XIJKL = TWO*XIJKL
                  KL = IA(K) + L
                  MNG = MAX(MN,KL)
                  KLG = MIN(MN,KL)
                  MNKL = IA(MNG) + KLG
                  DVAL = DVAL + TPDM(MNKL)*XIJKL
  260           CONTINUE
  270         CONTINUE
C
              IF((N+NCOR).GT.I) DVAL = -DVAL
              IF((M+NCOR).GT.J) DVAL = -DVAL
              CALL DAXPY(NUNIQ,DVAL,YAO(1,ING),1,RHSO(1,JMG),1)
  290       CONTINUE
  300     CONTINUE
C
C          ----- Exchange contribution to orbital hessian -----
C          -----      First summation index over core     -----
C
          IF(J.GT.NCOR) GO TO 610
          DO 500 K=1,NOCC
            DO 450 L=1,NCOR
              KG = MAX(K,L)
              LG = MIN(K,L)
              KL = IA(KG) + LG
              XIJKL = BUFF(KL)
              IF(ABS(XIJKL).LT.TOL) GO TO 450
C
              IMG = IABS(INDEX(I,J))
              KNG = IABS(INDEX(K,L))
              IF((IMG.NE.0) .AND. (KNG.NE.0)) THEN
                DVAL = TWO*FOUR*XIJKL
                IF(J.GT.I) DVAL = -DVAL
                IF(L.GT.K) DVAL = -DVAL
                CALL DAXPY(NUNIQ,DVAL,YAO(1,KNG),1,RHSO(1,IMG),1)
              ENDIF
C
              IMG = IABS(INDEX(I,L))
              KNG = IABS(INDEX(K,J))
              IF((IMG.NE.0) .AND. (KNG.NE.0)) THEN
                DVAL = TWO*XIJKL
                IF(L.GT.I) DVAL = -DVAL
                IF(J.GT.K) DVAL = -DVAL
                CALL DAXPY(NUNIQ,-DVAL,YAO(1,KNG),1,RHSO(1,IMG),1)
              ENDIF
C
              IF(J.EQ.L) THEN
                DO 400 M=1,NCOR
                  IMG = IABS(INDEX(I,M))
                  KMG = IABS(INDEX(K,M))
                  IF((IMG.EQ.0) .OR. (KMG.EQ.0)) GO TO 400
                  DVAL = TWO*XIJKL
                  IF(M.GT.I) DVAL = -DVAL
                  IF(M.GT.K) DVAL = -DVAL
                  CALL DAXPY(NUNIQ,-DVAL,YAO(1,KMG),1,RHSO(1,IMG),1)
  400           CONTINUE
C
                DO 440 M=1,NACT
                  IMG = IABS(INDEX(I,M+NCOR))
                  IF(IMG.EQ.0) GO TO 440
                  DO 430 N=1,NACT
                    KNG = IABS(INDEX(K,N+NCOR))
                    IF(KNG.EQ.0) GO TO 430
                    MG = MAX(M,N)
                    NG = MIN(M,N)
                    MN = IA(MG) + NG
                    DVAL = OPDM(MN)*XIJKL
                    IF((M+NCOR).GT.I) DVAL = -DVAL
                    IF((N+NCOR).GT.K) DVAL = -DVAL
                    CALL DAXPY(NUNIQ,-DVAL,YAO(1,KNG),1,RHSO(1,IMG),1)
  430             CONTINUE
  440           CONTINUE
              ENDIF
  450       CONTINUE
C
            DO 490 L=1,NACT
              KG = MAX(K,L+NCOR)
              LG = MIN(K,L+NCOR)
              KL = IA(KG) + LG
              XIJKL = BUFF(KL)
              IF(ABS(XIJKL).LT.TOL) GO TO 490
C
              IMG = IABS(INDEX(I,J))
              IF(IMG.NE.0) THEN
                DO 460 N=1,NACT
                  KNG = IABS(INDEX(K,N+NCOR))
                  IF(KNG.EQ.0) GO TO 460
                  LG = MAX(L,N)
                  NG = MIN(L,N)
                  LN = IA(LG) + NG
                  DVAL = OPDM(LN)*XIJKL
                  DVAL = FOUR*DVAL
                  IF(J.GT.I) DVAL = -DVAL
                  IF((N+NCOR).GT.K) DVAL = -DVAL
                  CALL DAXPY(NUNIQ,DVAL,YAO(1,KNG),1,RHSO(1,IMG),1)
  460           CONTINUE
              ENDIF
C
              KNG = IABS(INDEX(K,J))
              IF(KNG.NE.0) THEN
                DO 470 M=1,NACT
                  IMG = IABS(INDEX(I,M+NCOR))
                  IF(IMG.EQ.0) GO TO 470
                  LG = MAX(L,M)
                  MG = MIN(L,M)
                  LM = IA(LG) + MG
                  DVAL = OPDM(LM)*XIJKL
                  IF(J.GT.K) DVAL = -DVAL
                  IF((M+NCOR).GT.I) DVAL = -DVAL
                  CALL DAXPY(NUNIQ,-DVAL,YAO(1,KNG),1,RHSO(1,IMG),1)
  470           CONTINUE
              ENDIF
  490       CONTINUE
  500     CONTINUE
C
          IF((I.EQ.J) .OR. (I.GT.NCOR)) GO TO 610
          DO 600 K=1,NOCC
            DO 550 L=1,NCOR
              KG = MAX(K,L)
              LG = MIN(K,L)
              KL = IA(KG) + LG
              XIJKL = BUFF(KL)
              IF(ABS(XIJKL).LT.TOL) GO TO 550
C
              JMG = IABS(INDEX(J,I))
              KNG = IABS(INDEX(K,L))
              IF((JMG.NE.0) .AND. (KNG.NE.0)) THEN
                DVAL = TWO*FOUR*XIJKL
                IF(I.GT.J) DVAL = -DVAL
                IF(L.GT.K) DVAL = -DVAL
                CALL DAXPY(NUNIQ,DVAL,YAO(1,KNG),1,RHSO(1,JMG),1)
              ENDIF
C
              JMG = IABS(INDEX(J,L))
              KNG = IABS(INDEX(K,I))
              IF((JMG.NE.0) .AND. (KNG.NE.0)) THEN
                DVAL = TWO*XIJKL
                IF(L.GT.J) DVAL = -DVAL
                IF(I.GT.K) DVAL = -DVAL
                CALL DAXPY(NUNIQ,-DVAL,YAO(1,KNG),1,RHSO(1,JMG),1)
              ENDIF
C
              IF(I.EQ.L) THEN
                DO 510 M=1,NCOR
                  JMG = IABS(INDEX(J,M))
                  KMG = IABS(INDEX(K,M))
                  IF((JMG.EQ.0) .OR. (KMG.EQ.0)) GO TO 510
                  DVAL = TWO*XIJKL
                  IF(M.GT.J) DVAL = -DVAL
                  IF(M.GT.K) DVAL = -DVAL
                  CALL DAXPY(NUNIQ,-DVAL,YAO(1,KMG),1,RHSO(1,JMG),1)
  510           CONTINUE
C
                DO 540 M=1,NACT
                  JMG = IABS(INDEX(J,M+NCOR))
                  IF(JMG.EQ.0) GO TO 540
                  DO 530 N=1,NACT
                    KNG = IABS(INDEX(K,N+NCOR))
                    IF(KNG.EQ.0) GO TO 530
                    MG = MAX(M,N)
                    NG = MIN(M,N)
                    MN = IA(MG) + NG
                    DVAL = OPDM(MN)*XIJKL
                    IF((M+NCOR).GT.J) DVAL = -DVAL
                    IF((N+NCOR).GT.K) DVAL = -DVAL
                    CALL DAXPY(NUNIQ,-DVAL,YAO(1,KNG),1,RHSO(1,JMG),1)
  530             CONTINUE
  540           CONTINUE
              ENDIF
  550       CONTINUE
C
            DO 590 L=1,NACT
              KG = MAX(K,L+NCOR)
              LG = MIN(K,L+NCOR)
              KL = IA(KG) + LG
              XIJKL = BUFF(KL)
              IF(ABS(XIJKL).LT.TOL) GO TO 590
C
              JMG = IABS(INDEX(J,I))
              IF(JMG.NE.0) THEN
                DO 560 N=1,NACT
                  KNG = IABS(INDEX(K,N+NCOR))
                  IF(KNG.EQ.0) GO TO 560
                  LG = MAX(L,N)
                  NG = MIN(L,N)
                  LN = IA(LG) + NG
                  DVAL = OPDM(LN)*XIJKL
                  DVAL = FOUR*DVAL
                  IF(I.GT.J) DVAL = -DVAL
                  IF((N+NCOR).GT.K) DVAL = -DVAL
                  CALL DAXPY(NUNIQ,DVAL,YAO(1,KNG),1,RHSO(1,JMG),1)
  560           CONTINUE
              ENDIF
C
              KNG = IABS(INDEX(K,I))
              IF(KNG.NE.0) THEN
                DO 570 M=1,NACT
                  JMG = IABS(INDEX(J,M+NCOR))
                  IF(JMG.EQ.0) GO TO 570
                  LG = MAX(L,M)
                  MG = MIN(L,M)
                  LM = IA(LG) + MG
                  DVAL = OPDM(LM)*XIJKL
                  IF(I.GT.K) DVAL = -DVAL
                  IF((M+NCOR).GT.J) DVAL = -DVAL
                  CALL DAXPY(NUNIQ,-DVAL,YAO(1,KNG),1,RHSO(1,JMG),1)
  570           CONTINUE
              ENDIF
  590       CONTINUE
  600     CONTINUE
C
C          ----- Exchange contribution to orbital hessian -----
C          -----    First summation index over valence    -----
C
  610     IF(I.LE.NCOR) GO TO 1000
          DO 800 K=1,NOCC
            DO 700 L=1,NCOR
              KG = MAX(K,L)
              LG = MIN(K,L)
              KL = IA(KG) + LG
              XIJKL = BUFF(KL)
              IF(ABS(XIJKL).LT.TOL) GO TO 700
C
              IF(J.LE.NCOR) GO TO 650
              IMG = IABS(INDEX(I,L))
              IF(IMG.NE.0) THEN
                DO 620 N=1,NACT
                  KNG = IABS(INDEX(K,N+NCOR))
                  IF(KNG.EQ.0) GO TO 620
                  NG = MAX(N,J-NCOR)
                  JG = MIN(N,J-NCOR)
                  NJ = IA(NG) + JG
                  DVAL = OPDM(NJ)*XIJKL
                  IF(L.GT.I) DVAL = -DVAL
                  IF((N+NCOR).GT.K) DVAL = -DVAL
                  CALL DAXPY(NUNIQ,-DVAL,YAO(1,KNG),1,RHSO(1,IMG),1)
  620           CONTINUE
              ENDIF
C
              KNG = IABS(INDEX(K,L))
              IF(KNG.NE.0) THEN
                DO 640 M=1,NACT
                  IMG = IABS(INDEX(I,M+NCOR))
                  IF(IMG.EQ.0) GO TO 640
                  MG = MAX(M,J-NCOR)
                  JG = MIN(M,J-NCOR)
                  MJ = IA(MG) + JG
                  DVAL = OPDM(MJ)*XIJKL
                  DVAL = FOUR*DVAL
                  IF(L.GT.K) DVAL = -DVAL
                  IF((M+NCOR).GT.I) DVAL = -DVAL
                  CALL DAXPY(NUNIQ,DVAL,YAO(1,KNG),1,RHSO(1,IMG),1)
  640           CONTINUE
              ENDIF
C
  650         IF(I.EQ.J) GO TO 700
              JMG = IABS(INDEX(J,L))
              IF(JMG.NE.0) THEN
                DO 670 N=1,NACT
                  KNG = IABS(INDEX(K,N+NCOR))
                  IF(KNG.EQ.0) GO TO 670
                  NG = MAX(N,I-NCOR)
                  IG = MIN(N,I-NCOR)
                  NI = IA(NG) + IG
                  DVAL = OPDM(NI)*XIJKL
                  IF(L.GT.J) DVAL = -DVAL
                  IF((N+NCOR).GT.K) DVAL = -DVAL
                  CALL DAXPY(NUNIQ,-DVAL,YAO(1,KNG),1,RHSO(1,JMG),1)
  670           CONTINUE
              ENDIF
C
              KNG = IABS(INDEX(K,L))
              IF(KNG.NE.0) THEN
                DO 690 M=1,NACT
                  JMG = IABS(INDEX(J,M+NCOR))
                  IF(JMG.EQ.0) GO TO 690
                  MG = MAX(M,I-NCOR)
                  IG = MIN(M,I-NCOR)
                  MI = IA(MG) + IG
                  DVAL = OPDM(MI)*XIJKL
                  DVAL = FOUR*DVAL
                  IF(L.GT.K) DVAL = -DVAL
                  IF((M+NCOR).GT.J) DVAL = -DVAL
                  CALL DAXPY(NUNIQ,DVAL,YAO(1,KNG),1,RHSO(1,JMG),1)
  690           CONTINUE
              ENDIF
  700       CONTINUE
C
            DO 790 L=1,NACT
              KG = MAX(K,L+NCOR)
              LG = MIN(K,L+NCOR)
              KL = IA(KG) + LG
              XIJKL = BUFF(KL)
              IF(ABS(XIJKL).LT.TOL) GO TO 790
C
              IF(J.LE.NCOR) GO TO 750
              JG = MAX(J-NCOR,L)
              LG = MIN(J-NCOR,L)
              JL = IA(JG) + LG
              DO 720 M=1,NCOR
                IMG = IABS(INDEX(I,M))
                KMG = IABS(INDEX(K,M))
                IF((IMG.EQ.0) .OR. (KMG.EQ.0)) GO TO 720
                DVAL = OPDM(JL)*XIJKL
                IF(M.GT.I) DVAL = -DVAL
                IF(M.GT.K) DVAL = -DVAL
                CALL DAXPY(NUNIQ,-DVAL,YAO(1,KMG),1,RHSO(1,IMG),1)
  720         CONTINUE
C
              DO 740 M=1,NACT
                IMG = IABS(INDEX(I,M+NCOR))
                IF(IMG.EQ.0) GO TO 740
                MG = MAX(M,J-NCOR)
                JG = MIN(M,J-NCOR)
                MJ = IA(MG) + JG
                DO 730 N=1,NACT
                  KNG = IABS(INDEX(K,N+NCOR))
                  IF(KNG.EQ.0) GO TO 730
                  NG = MAX(N,L)
                  LG = MIN(N,L)
                  NL = IA(NG) + LG
                  MJG = MAX(MJ,NL)
                  NLG = MIN(MJ,NL)
                  MJNL = IA(MJG) + NLG
                  DVAL = TPDM(MJNL)*XIJKL
                  DVAL = TWO*DVAL
                  IF((M+NCOR).GT.I) DVAL = -DVAL
                  IF((N+NCOR).GT.K) DVAL = -DVAL
                  CALL DAXPY(NUNIQ,DVAL,YAO(1,KNG),1,RHSO(1,IMG),1)
  730           CONTINUE
  740         CONTINUE
C
  750         IF(I.EQ.J) GO TO 790
              IG = MAX(I-NCOR,L)
              LG = MIN(I-NCOR,L)
              IL = IA(IG) + LG
              DO 760 M=1,NCOR
                JMG = IABS(INDEX(J,M))
                KMG = IABS(INDEX(K,M))
                IF((JMG.EQ.0) .OR. (KMG.EQ.0)) GO TO 760
                DVAL = OPDM(IL)*XIJKL
                IF(M.GT.J) DVAL = -DVAL
                IF(M.GT.K) DVAL = -DVAL
                CALL DAXPY(NUNIQ,-DVAL,YAO(1,KMG),1,RHSO(1,JMG),1)
  760         CONTINUE
C
              DO 780 M=1,NACT
                JMG = IABS(INDEX(J,M+NCOR))
                IF(JMG.EQ.0) GO TO 780
                MG = MAX(M,I-NCOR)
                IG = MIN(M,I-NCOR)
                MI = IA(MG) + IG
                DO 770 N=1,NACT
                  KNG = IABS(INDEX(K,N+NCOR))
                  IF(KNG.EQ.0) GO TO 770
                  NG = MAX(N,L)
                  LG = MIN(N,L)
                  NL = IA(NG) + LG
                  MIG = MAX(MI,NL)
                  NLG = MIN(MI,NL)
                  MINL = IA(MIG) + NLG
                  DVAL = TPDM(MINL)*XIJKL
                  DVAL = TWO*DVAL
                  IF((M+NCOR).GT.J) DVAL = -DVAL
                  IF((N+NCOR).GT.K) DVAL = -DVAL
                  CALL DAXPY(NUNIQ,DVAL,YAO(1,KNG),1,RHSO(1,JMG),1)
  770           CONTINUE
  780         CONTINUE
  790       CONTINUE
  800     CONTINUE
C
C          ----- Finished with current integral buffer -----
C
 1000     CALL DDI_PROCDLB_NEXT(C_OOOO,IWP,ICNTR1)
C
        ENDDO
C
C     ----- Get and use (VO|OO) integrals -----
C
        CALL DDI_DISTRIB(D_VOOO,IWP,ILO,IHI,JLO,JHI)
        MAXWRK = JHI-JLO+1
C
        CALL DDI_PROCDLB_NEXT(C_VOOO,IWP,ICNTR2)
C
        DO WHILE(ICNTR2.LT.MAXWRK)
          JKL = JLO + ICNTR2
C
          DO KK=1,NOCC
            DO LL=1,KK
              KL = IA(KK) + LL
              DLT = TWO
              IF(KK.EQ.LL) DLT = ONE
              DO JJ=1,NOCC
                JKLTMP = (KL-1)*NOCC + JJ
                IF(JKL.EQ.JKLTMP) THEN
                  J = JJ
                  K = KK
                  L = LL
                  GO TO 1010
                END IF
              ENDDO
            ENDDO
          ENDDO
C
 1010     CALL DDI_GET(D_VOOO,1,NBVIR,JKL,JKL,BUFF)
C
C          ----- Coulomb contribution to orbital hessian -----
C          -----   Ket integral indicies are both core   -----
C
          IF(K.GT.NCOR) GO TO 1120
          JKG = IABS(INDEX(J,K))
          JLG = IABS(INDEX(J,L))
          DO 1100 I=NOCC+1,L0
            XIJKL = BUFF(I-NOCC)
            IF(ABS(XIJKL).LT.TOL) GO TO 1100
C
            ILG = IABS(INDEX(I,L))
            IF((ILG.EQ.0) .OR. (JKG.EQ.0)) GO TO 1020
            DVAL = DLT*XIJKL
            IF(K.GT.J) DVAL = -DVAL
            CALL DAXPY(NUNIQ,-DVAL,YAO(1,JKG),1,RHSO(1,ILG),1)
            CALL DAXPY(NUNIQ,-DVAL,YAO(1,ILG),1,RHSO(1,JKG),1)
C
 1020       IKG = IABS(INDEX(I,K))
            IF((IKG.EQ.0) .OR. (JLG.EQ.0)) GO TO 1030
            DVAL = DLT*XIJKL
            IF(L.GT.J) DVAL = -DVAL
            CALL DAXPY(NUNIQ,-DVAL,YAO(1,JLG),1,RHSO(1,IKG),1)
            CALL DAXPY(NUNIQ,-DVAL,YAO(1,IKG),1,RHSO(1,JLG),1)
C
 1030       IF(K.NE.L) GO TO 1100
            DO 1050 M=1,NCOR
              IMG = IABS(INDEX(I,M))
              JMG = IABS(INDEX(J,M))
              IF((IMG.EQ.0) .OR. (JMG.EQ.0)) GO TO 1050
              DVAL = FOUR*XIJKL
              IF(M.GT.J) DVAL = -DVAL
              CALL DAXPY(NUNIQ,DVAL,YAO(1,JMG),1,RHSO(1,IMG),1)
              CALL DAXPY(NUNIQ,DVAL,YAO(1,IMG),1,RHSO(1,JMG),1)
 1050       CONTINUE
C
            DO 1070 M=1,NACT
              IMG = IABS(INDEX(I,M+NCOR))
              IF(IMG.EQ.0) GO TO 1070
              DO 1060 N=1,NACT
                JNG = IABS(INDEX(J,N+NCOR))
                IF(JNG.EQ.0) GO TO 1060
                MG = MAX(M,N)
                NG = MIN(M,N)
                MN = IA(MG) + NG
                DVAL = OPDM(MN)*XIJKL
                DVAL = TWO*DVAL
                IF((N+NCOR).GT.J) DVAL = -DVAL
                CALL DAXPY(NUNIQ,DVAL,YAO(1,JNG),1,RHSO(1,IMG),1)
                CALL DAXPY(NUNIQ,DVAL,YAO(1,IMG),1,RHSO(1,JNG),1)
 1060         CONTINUE
 1070       CONTINUE
 1100     CONTINUE
          GO TO 1500
C
C          ----- Coulomb contribution to orbital hessian -----
C          -----     One ket integral index is active    -----
C
 1120     IF(L.GT.NCOR) GO TO 1220
          JLG = IABS(INDEX(J,L))
          DO 1200 I=NOCC+1,L0
            XIJKL = BUFF(I-NOCC)
            IF(ABS(XIJKL).LT.TOL) GO TO 1200
            ILG = IABS(INDEX(I,L))
C
            DO 1140 M=1,NACT
              KG = MAX(K-NCOR,M)
              MG = MIN(K-NCOR,M)
              KM = IA(KG) + MG
C
              IMG = IABS(INDEX(I,M+NCOR))
              IF((IMG.EQ.0) .OR. (JLG.EQ.0)) GO TO 1130
              DVAL = OPDM(KM)*XIJKL
              IF(L.GT.J) DVAL = -DVAL
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,JLG),1,RHSO(1,IMG),1)
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,IMG),1,RHSO(1,JLG),1)
C
 1130         JMG = IABS(INDEX(J,M+NCOR))
              IF((ILG.EQ.0) .OR. (JMG.EQ.0)) GO TO 1140
              DVAL = OPDM(KM)*XIJKL
              IF((M+NCOR).GT.J) DVAL = -DVAL
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,JMG),1,RHSO(1,ILG),1)
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,ILG),1,RHSO(1,JMG),1)
 1140       CONTINUE
 1200     CONTINUE
          GO TO 1500
C
C          ----- Coulomb contribution to orbital hessian -----
C          -----  Ket integral indicies are both active  -----
C
 1220     KKLL = IA(K-NCOR) + L-NCOR
          DO 1300 I=NOCC+1,L0
            XIJKL = BUFF(I-NOCC)
            IF(ABS(XIJKL).LT.TOL) GO TO 1300
C
            DO 1240 M=1,NCOR
              IMG = IABS(INDEX(I,M))
              JMG = IABS(INDEX(J,M))
              IF((IMG.EQ.0) .OR. (JMG.EQ.0)) GO TO 1240
              DVAL = OPDM(KKLL)*XIJKL
              DVAL = TWO*DLT*DVAL
              IF(M.GT.J) DVAL = -DVAL
              CALL DAXPY(NUNIQ,DVAL,YAO(1,JMG),1,RHSO(1,IMG),1)
              CALL DAXPY(NUNIQ,DVAL,YAO(1,IMG),1,RHSO(1,JMG),1)
 1240       CONTINUE
C
            DO 1260 M=1,NACT
              IMG = IABS(INDEX(I,M+NCOR))
              IF(IMG.EQ.0) GO TO 1260
              DO 1250 N=1,NACT
                JNG = IABS(INDEX(J,N+NCOR))
                IF(JNG.EQ.0) GO TO 1250
                MG = MAX(M,N)
                NG = MIN(M,N)
                MN = IA(MG) + NG
                MNG = MAX(MN,KKLL)
                KLG = MIN(MN,KKLL)
                MNKL = IA(MNG) + KLG
                DVAL = TPDM(MNKL)*XIJKL
                DVAL = DLT*DVAL
                IF((N+NCOR).GT.J) DVAL = -DVAL
                CALL DAXPY(NUNIQ,DVAL,YAO(1,JNG),1,RHSO(1,IMG),1)
                CALL DAXPY(NUNIQ,DVAL,YAO(1,IMG),1,RHSO(1,JNG),1)
 1250         CONTINUE
 1260       CONTINUE
 1300     CONTINUE
C
C          ----- Exchange contribution to orbital hessian -----
C          -----              J index is core             -----
C
 1500     IF(J.GT.NCOR) GO TO 1760
          IF(L.GT.NCOR) GO TO 1660
          KLG = IABS(INDEX(K,L))
          KJG = IABS(INDEX(K,J))
          LKG = IABS(INDEX(L,K))
          LJG = IABS(INDEX(L,J))
C
          DO 1650 I=NOCC+1,L0
            XIJKL = BUFF(I-NOCC)
            IF(ABS(XIJKL).LT.TOL) GO TO 1650
C
            IJG = IABS(INDEX(I,J))
            IF((IJG.EQ.0) .OR. (KLG.EQ.0)) GO TO 1510
            DVAL = FOUR*XIJKL
            DVAL = TWO*DVAL
            CALL DAXPY(NUNIQ,DVAL,YAO(1,KLG),1,RHSO(1,IJG),1)
            CALL DAXPY(NUNIQ,DVAL,YAO(1,IJG),1,RHSO(1,KLG),1)
C
 1510       ILG = IABS(INDEX(I,L))
            IF((ILG.EQ.0) .OR. (KJG.EQ.0)) GO TO 1520
            DVAL = TWO*XIJKL
            IF(J.GT.K) DVAL = -DVAL
            CALL DAXPY(NUNIQ,-DVAL,YAO(1,KJG),1,RHSO(1,ILG),1)
            CALL DAXPY(NUNIQ,-DVAL,YAO(1,ILG),1,RHSO(1,KJG),1)
C
 1520       IF(J.NE.L) GO TO 1560
            DO 1530 M=1,NCOR
              IMG = IABS(INDEX(I,M))
              KMG = IABS(INDEX(K,M))
              IF((IMG.EQ.0) .OR. (KMG.EQ.0)) GO TO 1530
              DVAL = TWO*XIJKL
              IF(M.GT.K) DVAL = -DVAL
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,KMG),1,RHSO(1,IMG),1)
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,IMG),1,RHSO(1,KMG),1)
 1530       CONTINUE
C
            DO 1550 M=1,NACT
              IMG = IABS(INDEX(I,M+NCOR))
              IF(IMG.EQ.0) GO TO 1550
              DO 1540 N=1,NACT
                KNG = IABS(INDEX(K,N+NCOR))
                IF(KNG.EQ.0) GO TO 1540
                MG = MAX(M,N)
                NG = MIN(M,N)
                MN = IA(MG) + NG
                DVAL = OPDM(MN)*XIJKL
                IF((N+NCOR).GT.K) DVAL = -DVAL
                CALL DAXPY(NUNIQ,-DVAL,YAO(1,KNG),1,RHSO(1,IMG),1)
                CALL DAXPY(NUNIQ,-DVAL,YAO(1,IMG),1,RHSO(1,KNG),1)
 1540         CONTINUE
 1550       CONTINUE
C
 1560       IF((K.EQ.L) .OR. (K.GT.NCOR)) GO TO 1650
            IF((IJG.EQ.0) .OR. (LKG.EQ.0)) GO TO 1570
            DVAL = FOUR*XIJKL
            DVAL = TWO*DVAL
            IF(K.GT.L) DVAL = -DVAL
            CALL DAXPY(NUNIQ,DVAL,YAO(1,LKG),1,RHSO(1,IJG),1)
            CALL DAXPY(NUNIQ,DVAL,YAO(1,IJG),1,RHSO(1,LKG),1)
C
 1570       IKG = IABS(INDEX(I,K))
            IF((IKG.EQ.0) .OR. (LJG.EQ.0)) GO TO 1580
            DVAL = TWO*XIJKL
            IF(J.GT.L) DVAL = -DVAL
            CALL DAXPY(NUNIQ,-DVAL,YAO(1,LJG),1,RHSO(1,IKG),1)
            CALL DAXPY(NUNIQ,-DVAL,YAO(1,IKG),1,RHSO(1,LJG),1)
C
 1580       IF(J.NE.K) GO TO 1650
            DO 1590 M=1,NCOR
              IMG = IABS(INDEX(I,M))
              LMG = IABS(INDEX(L,M))
              IF((IMG.EQ.0) .OR. (LMG.EQ.0)) GO TO 1590
              DVAL = TWO*XIJKL
              IF(M.GT.L) DVAL = -DVAL
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,LMG),1,RHSO(1,IMG),1)
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,IMG),1,RHSO(1,LMG),1)
 1590       CONTINUE
C
            DO 1610 M=1,NACT
              IMG = IABS(INDEX(I,M+NCOR))
              IF(IMG.EQ.0) GO TO 1610
              DO 1600 N=1,NACT
                LNG = IABS(INDEX(L,N+NCOR))
                IF(LNG.EQ.0) GO TO 1600
                MG = MAX(M,N)
                NG = MIN(M,N)
                MN = IA(MG) + NG
                DVAL = OPDM(MN)*XIJKL
                IF((N+NCOR).GT.L) DVAL = -DVAL
                CALL DAXPY(NUNIQ,-DVAL,YAO(1,LNG),1,RHSO(1,IMG),1)
                CALL DAXPY(NUNIQ,-DVAL,YAO(1,IMG),1,RHSO(1,LNG),1)
 1600         CONTINUE
 1610       CONTINUE
 1650     CONTINUE
C
 1660     IF(K.LE.NCOR) GO TO 1760
          KJG = IABS(INDEX(K,J))
          LJG = IABS(INDEX(L,J))
          DO 1750 I=NOCC+1,L0
            XIJKL = BUFF(I-NOCC)
            IF(ABS(XIJKL).LT.TOL) GO TO 1750
            IJG = IABS(INDEX(I,J))
C
            IF(L.LE.NCOR) GO TO 1700
            DO 1690 M=1,NACT
              MG = MAX(M,L-NCOR)
              LG = MIN(M,L-NCOR)
              ML = IA(MG) + LG
C
              IMG = IABS(INDEX(I,M+NCOR))
              IF((IMG.EQ.0) .OR. (KJG.EQ.0)) GO TO 1680
              DVAL = OPDM(ML)*XIJKL
              IF(J.GT.K) DVAL = -DVAL
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,KJG),1,RHSO(1,IMG),1)
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,IMG),1,RHSO(1,KJG),1)
C
 1680         KMG = IABS(INDEX(K,M+NCOR))
              IF((IJG.EQ.0) .OR. (KMG.EQ.0)) GO TO 1690
              DVAL = OPDM(ML)*XIJKL
              DVAL = FOUR*DVAL
              IF((M+NCOR).GT.K) DVAL = -DVAL
              CALL DAXPY(NUNIQ,DVAL,YAO(1,KMG),1,RHSO(1,IJG),1)
              CALL DAXPY(NUNIQ,DVAL,YAO(1,IJG),1,RHSO(1,KMG),1)
 1690       CONTINUE
C
 1700       IF(K.EQ.L) GO TO 1750
            DO 1740 M=1,NACT
              MG = MAX(M,K-NCOR)
              KG = MIN(M,K-NCOR)
              MK = IA(MG) + KG
C
              IMG = IABS(INDEX(I,M+NCOR))
              IF((IMG.EQ.0) .OR. (LJG.EQ.0)) GO TO 1720
              DVAL = OPDM(MK)*XIJKL
              IF(J.GT.L) DVAL = -DVAL
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,LJG),1,RHSO(1,IMG),1)
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,IMG),1,RHSO(1,LJG),1)
C
 1720         LMG = IABS(INDEX(L,M+NCOR))
              IF((IJG.EQ.0) .OR. (LMG.EQ.0)) GO TO 1740
              DVAL = OPDM(MK)*XIJKL
              DVAL = FOUR*DVAL
              IF((M+NCOR).GT.L) DVAL = -DVAL
              CALL DAXPY(NUNIQ,DVAL,YAO(1,LMG),1,RHSO(1,IJG),1)
              CALL DAXPY(NUNIQ,DVAL,YAO(1,IJG),1,RHSO(1,LMG),1)
 1740       CONTINUE
 1750     CONTINUE
C
C          ----- Exchange contribution to orbital hessian -----
C          -----            J index is active             -----
C
 1760     IF(J.LE.NCOR) GO TO 2000
          IF(L.GT.NCOR) GO TO 1860
          DO 1850 I=NOCC+1,L0
            XIJKL = BUFF(I-NOCC)
            IF(ABS(XIJKL).LT.TOL) GO TO 1850
C
            ILG = IABS(INDEX(I,L))
            KLG = IABS(INDEX(K,L))
            DO 1800 M=1,NACT
              MG = MAX(M,J-NCOR)
              JG = MIN(M,J-NCOR)
              MJ = IA(MG) + JG
C
              IMG = IABS(INDEX(I,M+NCOR))
              IF((IMG.EQ.0) .OR. (KLG.EQ.0)) GO TO 1780
              DVAL = OPDM(MJ)*XIJKL
              DVAL = FOUR*DVAL
              CALL DAXPY(NUNIQ,DVAL,YAO(1,KLG),1,RHSO(1,IMG),1)
              CALL DAXPY(NUNIQ,DVAL,YAO(1,IMG),1,RHSO(1,KLG),1)
C
 1780         KMG = IABS(INDEX(K,M+NCOR))
              IF((ILG.EQ.0) .OR. (KMG.EQ.0)) GO TO 1800
              DVAL = OPDM(MJ)*XIJKL
              IF((M+NCOR).GT.K) DVAL = -DVAL
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,KMG),1,RHSO(1,ILG),1)
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,ILG),1,RHSO(1,KMG),1)
 1800       CONTINUE
C
            IF((K.EQ.L) .OR. (K.GT.NCOR)) GO TO 1850
            IKG = IABS(INDEX(I,K))
            LKG = IABS(INDEX(L,K))
            DO 1840 M=1,NACT
              MG = MAX(M,J-NCOR)
              JG = MIN(M,J-NCOR)
              MJ = IA(MG) + JG
C
              IMG = IABS(INDEX(I,M+NCOR))
              IF((IMG.EQ.0) .OR. (LKG.EQ.0)) GO TO 1820
              DVAL = OPDM(MJ)*XIJKL
              DVAL = FOUR*DVAL
              IF(K.GT.L) DVAL = -DVAL
              CALL DAXPY(NUNIQ,DVAL,YAO(1,LKG),1,RHSO(1,IMG),1)
              CALL DAXPY(NUNIQ,DVAL,YAO(1,IMG),1,RHSO(1,LKG),1)
C
 1820         LMG = IABS(INDEX(L,M+NCOR))
              IF((IKG.EQ.0) .OR. (LMG.EQ.0)) GO TO 1840
              DVAL = OPDM(MJ)*XIJKL
              IF((M+NCOR).GT.L) DVAL = -DVAL
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,LMG),1,RHSO(1,IKG),1)
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,IKG),1,RHSO(1,LMG),1)
 1840       CONTINUE
 1850     CONTINUE
C
 1860     IF(K.LE.NCOR) GO TO 2000
          DO 1950 I=NOCC+1,L0
            XIJKL = BUFF(I-NOCC)
            IF(ABS(XIJKL).LT.TOL) GO TO 1950
C
            IF(L.LE.NCOR) GO TO 1900
            JG = MAX(J-NCOR,L-NCOR)
            LG = MIN(J-NCOR,L-NCOR)
            JL = IA(JG) + LG
            DO 1870 M=1,NCOR
              IMG = IABS(INDEX(I,M))
              KMG = IABS(INDEX(K,M))
              IF((IMG.EQ.0) .OR. (KMG.EQ.0)) GO TO 1870
              DVAL = OPDM(JL)*XIJKL
              IF(M.GT.K) DVAL = -DVAL
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,KMG),1,RHSO(1,IMG),1)
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,IMG),1,RHSO(1,KMG),1)
 1870       CONTINUE
C
            DO 1890 M=1,NACT
              IMG = IABS(INDEX(I,M+NCOR))
              IF(IMG.EQ.0) GO TO 1890
              MG = MAX(M,J-NCOR)
              JG = MIN(M,J-NCOR)
              MJ = IA(MG) + JG
              DO 1880 N=1,NACT
                KNG = IABS(INDEX(K,N+NCOR))
                IF(KNG.EQ.0) GO TO 1880
                NG = MAX(N,L-NCOR)
                LG = MIN(N,L-NCOR)
                NL = IA(NG) + LG
                MJG = MAX(MJ,NL)
                NLG = MIN(MJ,NL)
                MJNL = IA(MJG) + NLG
                DVAL = TPDM(MJNL)*XIJKL
                DVAL = TWO*DVAL
                IF((N+NCOR).GT.K) DVAL = -DVAL
                CALL DAXPY(NUNIQ,DVAL,YAO(1,KNG),1,RHSO(1,IMG),1)
                CALL DAXPY(NUNIQ,DVAL,YAO(1,IMG),1,RHSO(1,KNG),1)
 1880         CONTINUE
 1890       CONTINUE
C
 1900       IF(K.EQ.L) GO TO 1950
            JG = MAX(J-NCOR,K-NCOR)
            KG = MIN(J-NCOR,K-NCOR)
            JK = IA(JG) + KG
            DO 1910 M=1,NCOR
              IMG = IABS(INDEX(I,M))
              LMG = IABS(INDEX(L,M))
              IF((IMG.EQ.0) .OR. (LMG.EQ.0)) GO TO 1910
              DVAL = OPDM(JK)*XIJKL
              IF(M.GT.L) DVAL = -DVAL
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,LMG),1,RHSO(1,IMG),1)
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,IMG),1,RHSO(1,LMG),1)
 1910       CONTINUE
C
            DO 1940 M=1,NACT
              IMG = IABS(INDEX(I,M+NCOR))
              IF(IMG.EQ.0) GO TO 1940
              MG = MAX(M,J-NCOR)
              JG = MIN(M,J-NCOR)
              MJ = IA(MG) + JG
              DO 1930 N=1,NACT
                LNG = IABS(INDEX(L,N+NCOR))
                IF(LNG.EQ.0) GO TO 1930
                NG = MAX(N,K-NCOR)
                KG = MIN(N,K-NCOR)
                NK = IA(NG) + KG
                MJG = MAX(MJ,NK)
                NKG = MIN(MJ,NK)
                MJNK = IA(MJG) + NKG
                DVAL = TPDM(MJNK)*XIJKL
                DVAL = TWO*DVAL
                IF((N+NCOR).GT.L) DVAL = -DVAL
                CALL DAXPY(NUNIQ,DVAL,YAO(1,LNG),1,RHSO(1,IMG),1)
                CALL DAXPY(NUNIQ,DVAL,YAO(1,IMG),1,RHSO(1,LNG),1)
 1930         CONTINUE
 1940       CONTINUE
 1950     CONTINUE
C
C          ----- Finished with current integral buffer -----
C
 2000     CALL DDI_PROCDLB_NEXT(C_VOOO,IWP,ICNTR2)
C
        ENDDO
C
C     ----- Get and use (VV|OO) integrals -----
C
        CALL DDI_DISTRIB(D_VVOO,IWP,ILO,IHI,JLO,JHI)
        MAXWRK = JHI-JLO+1
C
        CALL DDI_PROCDLB_NEXT(C_VVOO,IWP,ICNTR3)
C
        DO WHILE(ICNTR3.LT.MAXWRK)
          KL = JLO + ICNTR3
C
          DO KK=1,NOCC
            DO LL=1,KK
              DLT = TWO
              IF(KK.EQ.LL) DLT = ONE
              KLTMP = IA(KK) + LL
              IF(KL.EQ.KLTMP) THEN
                K = KK
                L = LL
                GO TO 2010
              ENDIF
            ENDDO
          ENDDO
C
 2010     CALL DDI_GET(D_VVOO,1,NBTR,KL,KL,BUFF)
C
C          ----- Coulomb contribution to orbital hessian -----
C          -----      K and L are both core indicies     -----
C
          IF(K.GT.NCOR) GO TO 2150
          DO 2100 I=1,NVIR
            II = I + NOCC
            ILG = IABS(INDEX(II,L))
            IKG = IABS(INDEX(II,K))
            DO 2100 J=1,I
              JJ = J + NOCC
              IJ = IA(I) + J
              XIJKL = BUFF(IJ)
              IF(ABS(XIJKL).LT.TOL) GO TO 2100
C
              JKG = IABS(INDEX(JJ,K))
              IF((ILG.EQ.0) .OR. (JKG.EQ.0)) GO TO 2030
              DVAL = DLT*XIJKL
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,JKG),1,RHSO(1,ILG),1)
              IF(I.EQ.J) GO TO 2030
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,ILG),1,RHSO(1,JKG),1)
C
 2030         JLG = IABS(INDEX(JJ,L))
              IF((IKG.EQ.0) .OR. (JLG.EQ.0)) GO TO 2040
              DVAL = DLT*XIJKL
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,JLG),1,RHSO(1,IKG),1)
              IF(I.EQ.J) GO TO 2040
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,IKG),1,RHSO(1,JLG),1)
C
 2040         IF(K.NE.L) GO TO 2100
              DO 2050 M=1,NCOR
                IMG = IABS(INDEX(II,M))
                JMG = IABS(INDEX(JJ,M))
                IF((IMG.EQ.0) .OR. (JMG.EQ.0)) GO TO 2050
                DVAL = FOUR*XIJKL
                CALL DAXPY(NUNIQ,DVAL,YAO(1,JMG),1,RHSO(1,IMG),1)
                IF(I.EQ.J) GO TO 2050
                CALL DAXPY(NUNIQ,DVAL,YAO(1,IMG),1,RHSO(1,JMG),1)
 2050         CONTINUE
C
              DO 2070 M=1,NACT
                IMG = IABS(INDEX(II,M+NCOR))
                IF(IMG.EQ.0) GO TO 2070
                DO 2060 N=1,NACT
                  JNG = IABS(INDEX(JJ,N+NCOR))
                  IF(JNG.EQ.0) GO TO 2060
                  MG = MAX(M,N)
                  NG = MIN(M,N)
                  MN = IA(MG) + NG
                  DVAL = OPDM(MN)*XIJKL
                  DVAL = TWO*DVAL
                  CALL DAXPY(NUNIQ,DVAL,YAO(1,JNG),1,RHSO(1,IMG),1)
                  IF(I.EQ.J) GO TO 2060
                  CALL DAXPY(NUNIQ,DVAL,YAO(1,IMG),1,RHSO(1,JNG),1)
 2060           CONTINUE
 2070         CONTINUE
 2100     CONTINUE
          GO TO 3000
C
C          ----- Coulomb contribution to orbital hessian -----
C          -----         K is active, L is core          -----
C
 2150     IF(L.GT.NCOR) GO TO 2350
          DO 2300 I=1,NVIR
            II = I + NOCC
            ILG = IABS(INDEX(II,L))
            DO 2300 J=1,I
              JJ = J + NOCC
              IJ = IA(I) + J
              XIJKL = BUFF(IJ)
              IF(ABS(XIJKL).LT.TOL) GO TO 2300
              JLG = IABS(INDEX(JJ,L))
C
              DO 2200 M=1,NACT
                MG = MAX(M,K-NCOR)
                KG = MIN(M,K-NCOR)
                MK = IA(MG) + KG
C
                JMG = IABS(INDEX(JJ,M+NCOR))
                IF((ILG.EQ.0) .OR. (JMG.EQ.0)) GO TO 2170
                DVAL = OPDM(MK)*XIJKL
                DVAL = HALF*DLT*DVAL
                CALL DAXPY(NUNIQ,-DVAL,YAO(1,JMG),1,RHSO(1,ILG),1)
                IF(I.EQ.J) GO TO 2170
                CALL DAXPY(NUNIQ,-DVAL,YAO(1,ILG),1,RHSO(1,JMG),1)
C
 2170           IMG = IABS(INDEX(II,M+NCOR))
                IF((IMG.EQ.0) .OR. (JLG.EQ.0)) GO TO 2200
                DVAL = OPDM(MK)*XIJKL
                DVAL = HALF*DLT*DVAL
                CALL DAXPY(NUNIQ,-DVAL,YAO(1,JLG),1,RHSO(1,IMG),1)
                IF(I.EQ.J) GO TO 2200
                CALL DAXPY(NUNIQ,-DVAL,YAO(1,IMG),1,RHSO(1,JLG),1)
 2200         CONTINUE
 2300     CONTINUE
          GO TO 3000
C
C          ----- Coulomb contribution to orbital hessian -----
C          -----     K and L are both active indicies    -----
C
 2350     KKLL = IA(K-NCOR) + L-NCOR
          DO 2500 I=1,NVIR
            II = I + NOCC
            DO 2500 J=1,I
              JJ = J + NOCC
              IJ = IA(I) + J
              XIJKL = BUFF(IJ)
              IF(ABS(XIJKL).LT.TOL) GO TO 2500
              XIJKL = DLT*XIJKL
C
              DO 2400 M=1,NCOR
                IMG = IABS(INDEX(II,M))
                JMG = IABS(INDEX(JJ,M))
                IF((IMG.EQ.0) .OR. (JMG.EQ.0)) GO TO 2400
                DVAL = OPDM(KKLL)*XIJKL
                DVAL = TWO*DVAL
                CALL DAXPY(NUNIQ,DVAL,YAO(1,JMG),1,RHSO(1,IMG),1)
                IF(I.EQ.J) GO TO 2400
                CALL DAXPY(NUNIQ,DVAL,YAO(1,IMG),1,RHSO(1,JMG),1)
 2400         CONTINUE
C
              DO 2440 M=1,NACT
                IMG = IABS(INDEX(II,M+NCOR))
                IF(IMG.EQ.0) GO TO 2440
                DO 2420 N=1,NACT
                  JNG = IABS(INDEX(JJ,N+NCOR))
                  IF(JNG.EQ.0) GO TO 2420
                  MG = MAX(M,N)
                  NG = MIN(M,N)
                  MN = IA(MG) + NG
                  MNG = MAX(MN,KKLL)
                  KLG = MIN(MN,KKLL)
                  MNKL = IA(MNG) + KLG
                  DVAL = TPDM(MNKL)*XIJKL
                  IF(ABS(DVAL).LT.TOL) GO TO 2420
                  CALL DAXPY(NUNIQ,DVAL,YAO(1,JNG),1,RHSO(1,IMG),1)
                  IF(I.EQ.J) GO TO 2420
                  CALL DAXPY(NUNIQ,DVAL,YAO(1,IMG),1,RHSO(1,JNG),1)
 2420           CONTINUE
 2440         CONTINUE
 2500     CONTINUE
C
C          ----- Finished with current integral buffer -----
C
 3000     CALL DDI_PROCDLB_NEXT(C_VVOO,IWP,ICNTR3)
C
        ENDDO
C
C     ----- Get and use (VO|VO) integrals -----
C
        CALL DDI_DISTRIB(D_VOVO,IWP,ILO,IHI,JLO,JHI)
        MAXWRK = JHI-JLO+1
C
        CALL DDI_PROCDLB_NEXT(C_VOVO,IWP,ICNTR4)
C
        DO WHILE(ICNTR4.LT.MAXWRK)
          JL = JLO + ICNTR4
C
          DO JJ=1,NOCC
            DO LL=1,JJ
              JLTMP = IA(JJ) + LL
              IF(JL.EQ.JLTMP) THEN
                J = JJ
                L = LL
                GO TO 3010
              END IF
            ENDDO
          ENDDO
C
 3010     CALL DDI_GET(D_VOVO,1,NBSQ,JL,JL,BUFF)
C
C          ----- Exchange contribution to orbital hessian -----
C          -----        J and L are core orbitals         -----
C
          IF(J.GT.NCOR) GO TO 3120
          DO 3100 I=1,NVIR
            II = I + NOCC
            IJG = IABS(INDEX(II,J))
            ILG = IABS(INDEX(II,L))
            DO 3100 K=1,NVIR
              KK = K + NOCC
              KJG = IABS(INDEX(KK,J))
              KLG = IABS(INDEX(KK,L))
              IK = (K-1)*NVIR + I
              XIJKL = BUFF(IK)
              IF(ABS(XIJKL).LT.TOL) GO TO 3040
C
              IF((IJG.EQ.0) .OR. (KLG.EQ.0)) GO TO 3030
              DVAL = FOUR*XIJKL
              DVAL = TWO*DVAL
              CALL DAXPY(NUNIQ,DVAL,YAO(1,KLG),1,RHSO(1,IJG),1)
C
 3030         IF((ILG.EQ.0) .OR. (KJG.EQ.0)) GO TO 3040
              DVAL = TWO*XIJKL
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,KJG),1,RHSO(1,ILG),1)
C
 3040         KI = (I-1)*NVIR + K
              XIJKL = BUFF(KI)
              IF(ABS(XIJKL).LT.TOL) GO TO 3100
              IF(J.EQ.L) GO TO 3060
C
              IF((ILG.EQ.0) .OR. (KJG.EQ.0)) GO TO 3050
              DVAL = FOUR*XIJKL
              DVAL = TWO*DVAL
              CALL DAXPY(NUNIQ,DVAL,YAO(1,KJG),1,RHSO(1,ILG),1)
C
 3050         IF((IJG.EQ.0) .OR. (KLG.EQ.0)) GO TO 3060
              DVAL = TWO*XIJKL
              CALL DAXPY(NUNIQ,-DVAL,YAO(1,KLG),1,RHSO(1,IJG),1)
C
 3060         IF(J.NE.L) GO TO 3100
              DO 3070 M=1,NCOR
                IMG = IABS(INDEX(II,M))
                KMG = IABS(INDEX(KK,M))
                IF((IMG.EQ.0) .OR. (KMG.EQ.0)) GO TO 3070
                DVAL = TWO*XIJKL
                CALL DAXPY(NUNIQ,-DVAL,YAO(1,KMG),1,RHSO(1,IMG),1)
 3070         CONTINUE
C
              DO 3090 M=1,NACT
                IMG = IABS(INDEX(II,M+NCOR))
                IF(IMG.EQ.0) GO TO 3090
                DO 3080 N=1,NACT
                  KNG = IABS(INDEX(KK,N+NCOR))
                  IF(KNG.EQ.0) GO TO 3080
                  MG = MAX(M,N)
                  NG = MIN(M,N)
                  MN = IA(MG) + NG
                  DVAL = OPDM(MN)*XIJKL
                  CALL DAXPY(NUNIQ,-DVAL,YAO(1,KNG),1,RHSO(1,IMG),1)
 3080           CONTINUE
 3090         CONTINUE
 3100     CONTINUE
          GO TO 4000
C
C          ----- Exchange contribution to orbital hessian -----
C          -----          J is active, L is core          -----
C
 3120     IF(L.GT.NCOR) GO TO 3220
          DO 3200 I=1,NVIR
            II = I + NOCC
            ILG = IABS(INDEX(II,L))
            DO 3200 K=1,NVIR
              KK = K + NOCC
              IK = (K-1)*NVIR + I
              XIJKL = BUFF(IK)
              IF(ABS(XIJKL).LT.TOL) GO TO 3160
              KLG = IABS(INDEX(KK,L))
C
              DO 3150 M=1,NACT
                MG = MAX(M,J-NCOR)
                JG = MIN(M,J-NCOR)
                MJ = IA(MG) + JG
C
                KMG = IABS(INDEX(KK,M+NCOR))
                IF((ILG.EQ.0) .OR. (KMG.EQ.0)) GO TO 3140
                DVAL = OPDM(MJ)*XIJKL
                CALL DAXPY(NUNIQ,-DVAL,YAO(1,KMG),1,RHSO(1,ILG),1)
C
 3140           IMG = IABS(INDEX(II,M+NCOR))
                IF((IMG.EQ.0) .OR. (KLG.EQ.0)) GO TO 3150
                DVAL = OPDM(MJ)*XIJKL
                DVAL = FOUR*DVAL
                CALL DAXPY(NUNIQ,DVAL,YAO(1,KLG),1,RHSO(1,IMG),1)
 3150         CONTINUE
C
 3160         KI = (I-1)*NVIR + K
              XIJKL = BUFF(KI)
              IF(ABS(XIJKL).LT.TOL) GO TO 3200
C
              DO 3190 M=1,NACT
                MG = MAX(M,J-NCOR)
                JG = MIN(M,J-NCOR)
                MJ = IA(MG) + JG
C
                KMG = IABS(INDEX(KK,M+NCOR))
                IF((ILG.EQ.0) .OR. (KMG.EQ.0)) GO TO 3180
                DVAL = OPDM(MJ)*XIJKL
                DVAL = FOUR*DVAL
                CALL DAXPY(NUNIQ,DVAL,YAO(1,KMG),1,RHSO(1,ILG),1)
C
 3180           IMG = IABS(INDEX(II,M+NCOR))
                IF((IMG.EQ.0) .OR. (KLG.EQ.0)) GO TO 3190
                DVAL = OPDM(MJ)*XIJKL
                CALL DAXPY(NUNIQ,-DVAL,YAO(1,KLG),1,RHSO(1,IMG),1)
 3190         CONTINUE
 3200     CONTINUE
          GO TO 4000
C
C          ----- Exchange contribution to orbital hessian -----
C          -----       J and L are active orbitals        -----
C
 3220     JJLL = IA(J-NCOR) + L-NCOR
          DO 3300 I=1,NVIR
            II = I + NOCC
            DO 3300 K=1,NVIR
              KK = K + NOCC
              IK = (K-1)*NVIR + I
              XIJKL = BUFF(IK)
              IF(ABS(XIJKL).LT.TOL) GO TO 3260
C
              DO 3230 M=1,NCOR
                IMG = IABS(INDEX(II,M))
                KMG = IABS(INDEX(KK,M))
                IF((IMG.EQ.0) .OR. (KMG.EQ.0)) GO TO 3230
                DVAL = OPDM(JJLL)*XIJKL
                CALL DAXPY(NUNIQ,-DVAL,YAO(1,KMG),1,RHSO(1,IMG),1)
 3230         CONTINUE
C
              DO 3250 M=1,NACT
                IMG = IABS(INDEX(II,M+NCOR))
                IF(IMG.EQ.0) GO TO 3250
                MG = MAX(M,J-NCOR)
                JG = MIN(M,J-NCOR)
                MJ = IA(MG) + JG
                DO 3240 N=1,NACT
                  KNG = IABS(INDEX(KK,N+NCOR))
                  IF(KNG.EQ.0) GO TO 3240
                  NG = MAX(N,L-NCOR)
                  LG = MIN(N,L-NCOR)
                  NL = IA(NG) + LG
                  MJG = MAX(MJ,NL)
                  NLG = MIN(MJ,NL)
                  MJNL = IA(MJG) + NLG
                  DVAL = TPDM(MJNL)*XIJKL
                  DVAL = TWO*DVAL
                  CALL DAXPY(NUNIQ,DVAL,YAO(1,KNG),1,RHSO(1,IMG),1)
 3240           CONTINUE
 3250         CONTINUE
C
 3260         IF(J.EQ.L) GO TO 3300
              KI = (I-1)*NVIR + K
              XIJKL = BUFF(KI)
              IF(ABS(XIJKL).LT.TOL) GO TO 3300
C
              DO 3270 M=1,NCOR
                IMG = IABS(INDEX(II,M))
                KMG = IABS(INDEX(KK,M))
                IF((IMG.EQ.0) .OR. (KMG.EQ.0)) GO TO 3270
                DVAL = OPDM(JJLL)*XIJKL
                CALL DAXPY(NUNIQ,-DVAL,YAO(1,KMG),1,RHSO(1,IMG),1)
 3270         CONTINUE
C
              DO 3290 M=1,NACT
                IMG = IABS(INDEX(II,M+NCOR))
                IF(IMG.EQ.0) GO TO 3290
                MG = MAX(M,L-NCOR)
                LG = MIN(M,L-NCOR)
                ML = IA(MG) + LG
                DO 3280 N=1,NACT
                  KNG = IABS(INDEX(KK,N+NCOR))
                  IF(KNG.EQ.0) GO TO 3280
                  NG = MAX(N,J-NCOR)
                  JG = MIN(N,J-NCOR)
                  NJ = IA(NG) + JG
                  MLG = MAX(ML,NJ)
                  NJG = MIN(ML,NJ)
                  MLNJ = IA(MLG) + NJG
                  DVAL = TPDM(MLNJ)*XIJKL
                  DVAL = TWO*DVAL
                  CALL DAXPY(NUNIQ,DVAL,YAO(1,KNG),1,RHSO(1,IMG),1)
 3280           CONTINUE
 3290         CONTINUE
 3300     CONTINUE
C
C          ----- Finished with current integral buffer -----
C
 4000     CALL DDI_PROCDLB_NEXT(C_VOVO,IWP,ICNTR4)
C
        ENDDO
C
 8000 CONTINUE
C
      RETURN
      END
C*MODULE CPMCHF  *DECK HSMLT1
      SUBROUTINE HSMLT1(AVEC,YAC,Y1DEN,RHSC,CI,OINT,AMAT,FC,ICIT,ICI2,
     *                  IND,IO1,JJ,JLO,NSTATS,NDETMX,NDETLN,L1,NCOR,
     *                  N2,NXYZ,WSTATE,SALAG,ITER)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION AVEC(NXYZ,N2),YAC(NXYZ,NSTATS*NDETMX),Y1DEN(NXYZ,N2),
     *          RHSC(NXYZ,NSTATS*NDETLN),CI(NDETMX,NSTATS),OINT(L1,L1),
     *          AMAT(L1,NCOR,N2),WSTATE(*),SALAG(L1,L1,NSTATS*NSTATS)
C
      PARAMETER (TWO=2.0D+00,TOL=1.0D-09)
C
      DO 2000 ISTAT=1,NSTATS
        CVAL = CI(ICI2,ISTAT)
        IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
        FCW = FC*WSTATE(ISTAT)
        IF(ABS(CVAL).LT.TOL) GO TO 1000
        IYIT = (ISTAT-1)*NDETMX + ICIT
C
        DVAL = CVAL*FCW
        CALL DAXPY(NXYZ,DVAL,AVEC(1,IND),1,RHSC(1,IWIT),1)
C
        CALL DAXPY(NXYZ,DVAL,YAC(1,IYIT),1,Y1DEN(1,IND),1)
C
        IF(NSTATS.EQ.1 .OR. ITER.NE.1) GO TO 1000
C
        DO 100 JSTAT=1,NSTATS
          CVAL2 = CI(ICIT,JSTAT)
          IF(ABS(CVAL2).LT.TOL) GO TO 100
          DVAL = FC*CVAL*CVAL2
          IJS = (ISTAT-1)*NSTATS + JSTAT
C
          CALL DAXPY(L1*NCOR,DVAL,AMAT(1,1,IND),1,SALAG(1,1,IJS),1)
C
          IF(IO1.EQ.JJ) DVAL = DVAL*TWO
          CALL DAXPY(L1,DVAL,OINT(1,IO1+NCOR),1,SALAG(1,JJ+NCOR,IJS),1)
          IF(IO1.EQ.JJ) GO TO 100
          CALL DAXPY(L1,DVAL,OINT(1,JJ+NCOR),1,SALAG(1,IO1+NCOR,IJS),1)
  100   CONTINUE
C
C     ----- Multiply one-electron part of configuration hessian -----
C     -----            cross term with trial vector             -----
C
 1000   IF(ABS(FCW).LT.TOL) GO TO 2000
        DLT = FCW*OINT(IO1+NCOR,JJ+NCOR)
        IYI2 = (ISTAT-1)*NDETMX + ICI2
        CALL DAXPY(NXYZ,DLT,YAC(1,IYI2),1,RHSC(1,IWIT),1)
 2000 CONTINUE
C
      RETURN
      END
C*MODULE CPMCHF  *DECK HSMLT2
      SUBROUTINE HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,FC,ICIT,
     *                  ICI2,I,J,K,L,IJ,KL,NACT,NNACT,NSTATS,NXYZ,
     *                  NDETMX,NDETLN,JLO,L1,NCOR,SALAG,ITER,KILL)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL KILL
C
      DIMENSION YADEN(NXYZ,NACT*NACT,NNACT),YAC(NXYZ,NSTATS*NDETMX),
     *          RHSC(NXYZ,NSTATS*NDETLN),WSTATE(*),CI(NDETMX,NSTATS),
     *          ERI(L1,NACT,NNACT),WRK(*),SALAG(L1,L1,NSTATS*NSTATS)
C
      PARAMETER (ONE=1.0D+00,TWO=2.0D+00,TOL=1.0D-09)
C
      CALL VCLR(WRK,1,NXYZ)
      IWRK = 0
C
      IF(KILL) RETURN
      IM = MAX(I,J)
      JM = MIN(I,J)
      IMJM = (IM*IM-IM)/2 + JM
      KM = MAX(K,L)
      LM = MIN(K,L)
      KMLM = (KM*KM-KM)/2 + LM
      IF(IJ.NE.IMJM .OR. KL.NE.KMLM) THEN
        WRITE(6,*) 'IDET,JDET=',ICIT,ICI2
        WRITE(6,*) '   I,J,K,L=',I,J,K,L
        WRITE(6,*) '      IJ,KL=',IJ,KL
        WRITE(6,*) ' '
      ENDIF
C
C
      DO 100 ISTAT=1,NSTATS
        CVAL = CI(ICI2,ISTAT)
        WVAL = WSTATE(ISTAT)
        DVAL = CVAL*WVAL
        IF(ABS(DVAL).LT.TOL) THEN
          IWRK = IWRK + 1
          GO TO 80
        ENDIF
        IYIT = (ISTAT-1)*NDETMX + ICIT
        DVAL = FC*DVAL
        CALL DAXPY(NXYZ,DVAL,YAC(1,IYIT),1,WRK,1)
C
        IF(NSTATS.EQ.1 .OR. ITER.NE.1) GO TO 80
C
        DO 60 JSTAT=1,NSTATS
          CVAL2 = CI(ICIT,JSTAT)
          IF(ABS(CVAL2).LT.TOL) GO TO 60
          DLT = FC*CVAL*CVAL2
          IJS = (ISTAT-1)*NSTATS + JSTAT
C
          DVAL = DLT
          IF(I.EQ.J) DVAL = DVAL*TWO
          IF(IJ.EQ.KL) DVAL = DVAL*TWO
          CALL DAXPY(L1,DVAL,ERI(1,J,KL),1,SALAG(1,I+NCOR,IJS),1)
          IF(I.EQ.J) GO TO 20
C
          DVAL = DLT
          IF(IJ.EQ.KL) DVAL = DVAL*TWO
          CALL DAXPY(L1,DVAL,ERI(1,I,KL),1,SALAG(1,J+NCOR,IJS),1)
C
   20     IF(IJ.EQ.KL) GO TO 60
          DVAL = DLT
          IF(K.EQ.L) DVAL = DVAL*TWO
          CALL DAXPY(L1,DVAL,ERI(1,L,IJ),1,SALAG(1,K+NCOR,IJS),1)
C
          IF(K.EQ.L) GO TO 60
          DVAL = DLT
          CALL DAXPY(L1,DVAL,ERI(1,K,IJ),1,SALAG(1,L+NCOR,IJS),1)
   60   CONTINUE
C
C     ----- Multiply two-electron part of configuration hessian -----
C     -----                 with trial vectors                  -----
C
   80   DVAL = ERI(I+NCOR,J,KL)
        IF(ABS(DVAL).LT.TOL) GO TO 100
        DVAL = DVAL*FC*WVAL
        IYI2 = (ISTAT-1)*NDETMX + ICI2
        IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
        CALL DAXPY(NXYZ,DVAL,YAC(1,IYI2),1,RHSC(1,IWIT),1)
  100 CONTINUE
C
      IF(IWRK.EQ.NSTATS) GO TO 2000
C
      DVAL = ONE
      IIJJ = (J-1)*NACT + I
      IF(I.EQ.J) DVAL = DVAL*TWO
      IF(IJ.EQ.KL) DVAL = DVAL*TWO
      CALL DAXPY(NXYZ,DVAL,WRK,1,YADEN(1,IIJJ,KL),1)
C
      IF(I.EQ.J) GO TO 200
      DVAL = ONE
      JJII = (I-1)*NACT + J
      IF(IJ.EQ.KL) DVAL = DVAL*TWO
      CALL DAXPY(NXYZ,DVAL,WRK,1,YADEN(1,JJII,KL),1)
C
  200 IF(IJ.EQ.KL) GO TO 2000
      DVAL = ONE
      KKLL = (K-1)*NACT + L
      IF(K.EQ.L) DVAL = DVAL*TWO
      CALL DAXPY(NXYZ,DVAL,WRK,1,YADEN(1,KKLL,IJ),1)
C
      IF(K.EQ.L) GO TO 2000
      DVAL = ONE
      LLKK = (L-1)*NACT + K
      CALL DAXPY(NXYZ,DVAL,WRK,1,YADEN(1,LLKK,IJ),1)
C
 2000 CONTINUE
      RETURN
      END
C*MODULE CPMCHF  *DECK HSSCX2
      SUBROUTINE HSSCX2(NACT,NCOR,NA,NB,NALP,NBLP,IFA,IOX,NSYM,IACON1,
     *                  IBCON1,IACON2,IPOSA,IPERA,IIND1,INDEX,IMMA,
     *                  IMMC,ISYMA,ISYMB,ITAB,IMUL,ISPA,ISPB,ISAS,
     *                  ISBS,ISAC,ISBC,ISTRB,ISTRP,ISTART,CI,OINT,
     *                  AMAT,ERI,L1,NROT,NCI,IROT,RHSC,RHSO,YAO,
     *                  YAC,NDETLN,NXYZ,NINDX,JLO,JHI,NSTATS,WSTATE,
     *                  SALAG,YAOG,WRK,YADEN,AVEC,BVEC,YAOTMP,ITER,
     *                  JROTLO,JROTHI)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL RUN
C
      INTEGER POSCP
C
      DIMENSION RHSC(NXYZ,NSTATS*NDETLN),RHSO(NXYZ,NROT)
      DIMENSION YAO(NXYZ,NROT),CI(NCI,NSTATS),YAC(NXYZ,NSTATS*NCI)
      DIMENSION OINT(L1,L1),ERI(L1,NACT,(NACT**2+NACT)/2)
      DIMENSION AMAT(L1,NCOR,(NACT**2+NACT)/2),IROT(L1,L1)
      DIMENSION WSTATE(*),SALAG(*),YAOG(NXYZ),WRK(*)
      DIMENSION YADEN(NXYZ,NACT,NACT*(NACT**2+NACT)/2),AVEC(*),BVEC(*)
      DIMENSION YAOTMP(*)
C
      DIMENSION IOX(NACT)
      DIMENSION IFA(0:NACT,0:NACT)
      DIMENSION IACON1(NA),IBCON1(NA)
      DIMENSION IACON2(NA),IPERA(NA*(NACT-NA))
      DIMENSION IIND1(NA*(NACT-NA),3)
      DIMENSION IPOSA(NA*(NACT-NA))
      DIMENSION INDEX(NINDX,NINDX)
      DIMENSION IMMA(NSYM,NA*(NACT-NA)),IMMC(NSYM)
      DIMENSION ISYMA(NALP),ISYMB(NBLP)
      DIMENSION ITAB(NSYM),IMUL(NSYM,NSYM)
      DIMENSION ISPA(NALP),ISPB(NBLP)
      DIMENSION ISAS(NSYM+1),ISBS(NSYM+1),ISAC(NALP),ISBC(NBLP)
      DIMENSION ISTRB((NBLP*NB*(NACT-NB))/2)
      DIMENSION ISTRP((NBLP*NB*(NACT-NB))/2)
      DIMENSION ISTART(NBLP)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ONE=1.0D+00,TOL=1.0D-09)
      ICONST = 1
C     IF (NA.EQ.NB) ICONST = 1
C
C
      RUN = .FALSE.
C
      DO 7 I=1,NINDX
         DO 8 J=1,I
            INDEX(I,J) = I*(I-1)/2 + J
            INDEX(J,I) = INDEX(I,J)
    8    CONTINUE
    7 CONTINUE
C
      NAT = NA
      NBT = NB
      NNACT = (NACT*NACT+NACT)/2
C
      DO 30 I=1,NAT
         IACON1(I) = I
   30 CONTINUE
C
      CALL FMAVEC(AVEC,YAO,AMAT,OINT,IROT,INDEX,L1,NCOR,NACT,NNACT,
     *            NXYZ,NROT,NINDX,JROTLO,JROTHI)
      IF(GOPARR) CALL DDI_GSUMF(2177,AVEC,NXYZ*NNACT)
      CALL VCLR(BVEC,1,NXYZ*NNACT)
C
C   Big Loop over all alpha determinants
C
      DO 9000 IJK = 1,NALP
C
C  Alpha excitations here
C   Single first
C
         IAC = 0
         DO 45 II=1,NSYM
            IMMC(II) = 0
   45    CONTINUE
         ICAT = ISPA(IJK)
         ISA1 = ISYMA(IJK)
         ITAS = ITAB(ISA1)
         DO 7030 IA=1,NAT
             IO1 = IACON1(IA)
             IS1 = IOX(IO1)
             IST = IO1 + 1
             IEN = IACON1(IA+1)-1
             IF (IA.EQ.NAT) IEN=NACT
             DO 7025 KKJ=IA+1,NA+1
                DO 7020 JJ=IST,IEN
                IS2 = IOX(JJ)
                IP1 = IMUL(IS2,IS1)
C
             IAC = IAC + 1
             CALL RET1CP(IACON1,IACON2,NA,IA,JJ,0,KKJ,IPER1)
C
C   Storage here for later use, well worth it
C
             IPET = POSCP(NACT,NA,IACON2,IFA)
             IPOSA(IAC) = ISPA(IPET)
             IMMC(ISYMA(IPET)) = IMMC(ISYMA(IPET)) + 1
             IMMA(ISYMA(IPET),IMMC(ISYMA(IPET))) = IAC
             IPERA(IAC) = ((-1)**IPER1)*ICONST
             IND = INDEX(JJ,IO1)
             IIND1(IAC,1) = IND
             IIND1(IAC,2) = IO1
             IIND1(IAC,3) = JJ
Cc If deoccupied and newly occupied orbitals are of diff symm,
C  skip to doubles
             IF (IS1.NE.IS2) GOTO 417
C
         DO 49 I=1,NBT
            IBCON1(I) = I
   49    CONTINUE
C
C    Loop over beta dets of the right symmetry
C
                   DO 407 INBB = ISBS(ISA1),ISBS(ISA1+1)-1
                   INB1 = ISBC(INBB)
                   ICIT = ICAT+ISPB(INB1)
                   ICI2 = IPOSA(IAC) + ISPB(INB1)
                   FC = IPERA(IAC)
C
                   IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                     CALL HSMLT1(AVEC,YAC,BVEC,RHSC,CI,OINT,AMAT,
     *                           FC,ICIT,ICI2,IND,IO1,JJ,JLO,
     *                           NSTATS,NCI,NDETLN,L1,NCOR,
     *                           NNACT,NXYZ,WSTATE,SALAG,ITER)
                   ENDIF
                   IF(ICI2.GE.JLO .AND. ICI2.LE.JHI) THEN
                     CALL HSMLT1(AVEC,YAC,BVEC,RHSC,CI,OINT,AMAT,
     *                           FC,ICI2,ICIT,IND,IO1,JJ,JLO,
     *                           NSTATS,NCI,NDETLN,L1,NCOR,
     *                           NNACT,NXYZ,WSTATE,SALAG,ITER)
                   ENDIF
  407          CONTINUE
C
                   DO 487 IK=1,NAT
                      IF (IK.EQ.IA) GOTO 487
                      ION = IACON1(IK)
                      J1 = INDEX(ION,ION)
                      J2 = INDEX(ION,JJ)
                      J3 = INDEX(ION,IO1)
                      CALL VCLR(YAOG,1,NXYZ)
                      CALL HSMLTN(YAOG,YAOTMP,IO1,JJ,ION,ION,IND,
     *                            J1,NACT,NNACT,NXYZ,ONE)
                      CALL HSMLTN(YAOG,YAOTMP,IO1,ION,ION,JJ,J3,
     *                            J2,NACT,NNACT,NXYZ,-ONE)
C
                   DO 413 INBB=ISBS(ISA1),ISBS(ISA1+1)-1
                      INB1 = ISBC(INBB)
                      ICIT = ICAT+ISPB(INB1)
                      ICI2 = IPOSA(IAC)+ISPB(INB1)
                      FC = IPERA(IAC)
C
                     IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                       DO ISTAT=1,NSTATS
                         CVAL = CI(ICI2,ISTAT)
                         WVAL = WSTATE(ISTAT)
                         IF(ABS(CVAL).GT.TOL) THEN
                           IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
                           DVAL = CVAL*WVAL*FC
                           CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWIT),1)
                         ENDIF
                       ENDDO
                       CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                             FC,ICIT,ICI2,IO1,JJ,ION,ION,IND,J1,
     *                             NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                             JLO,L1,NCOR,SALAG,ITER,RUN)
                       CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                             -FC,ICIT,ICI2,IO1,ION,ION,JJ,J3,J2,
     *                             NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                             JLO,L1,NCOR,SALAG,ITER,RUN)
                     ENDIF
                     IF(ICI2.GE.JLO .AND. ICI2.LE.JHI) THEN
                       DO ISTAT=1,NSTATS
                         CVAL = CI(ICIT,ISTAT)
                         WVAL = WSTATE(ISTAT)
                         IF(ABS(CVAL).GT.TOL) THEN
                           IWI2 = (ISTAT-1)*NDETLN + ICI2 - JLO + 1
                           DVAL = CVAL*WVAL*FC
                           CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI2),1)
                         ENDIF
                       ENDDO
                       CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                             FC,ICI2,ICIT,IO1,JJ,ION,ION,IND,J1,
     *                             NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                             JLO,L1,NCOR,SALAG,ITER,RUN)
                       CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                             -FC,ICI2,ICIT,IO1,ION,ION,JJ,J3,J2,
     *                             NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                             JLO,L1,NCOR,SALAG,ITER,RUN)
                     ENDIF
  413              CONTINUE
C
  487              CONTINUE
C
C                  do 415 inb1=1,nblp
                  NST = 1
                  DO 415 INBB = ISBS(ISA1),ISBS(ISA1+1)-1
                  NEND = ISBC(INBB)
                  DO 5510 KK=NST,NEND-1
                     CALL ADVNCP(IBCON1,NBT,NACT)
 5510             CONTINUE
C
                  ICIT = ICAT+ISPB(NEND)
                  ICI2 = IPOSA(IAC)+ISPB(NEND)
C
                  FC = IPERA(IAC)
C
                     DO 790 IK=1,NBT
                     ION = IBCON1(IK)
                     J1 = INDEX(ION,ION)
                     CALL VCLR(YAOG,1,NXYZ)
                     CALL HSMLTN(YAOG,YAOTMP,IO1,JJ,ION,ION,IND,
     *                           J1,NACT,NNACT,NXYZ,ONE)
C
                     IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                       DO ISTAT=1,NSTATS
                         CVAL = CI(ICI2,ISTAT)
                         WVAL = WSTATE(ISTAT)
                         IF(ABS(CVAL).GT.TOL) THEN
                           IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
                           DVAL = CVAL*WVAL*FC
                           CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWIT),1)
                         ENDIF
                       ENDDO
                       CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                             FC,ICIT,ICI2,IO1,JJ,ION,ION,IND,J1,
     *                             NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                             JLO,L1,NCOR,SALAG,ITER,RUN)
                     ENDIF
                     IF(ICI2.GE.JLO .AND. ICI2.LE.JHI) THEN
                       DO ISTAT=1,NSTATS
                         CVAL = CI(ICIT,ISTAT)
                         WVAL = WSTATE(ISTAT)
                         IF(ABS(CVAL).GT.TOL) THEN
                           IWI2 = (ISTAT-1)*NDETLN + ICI2 - JLO + 1
                           DVAL = CVAL*WVAL*FC
                           CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI2),1)
                         ENDIF
                       ENDDO
                       CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                             FC,ICI2,ICIT,IO1,JJ,ION,ION,IND,J1,
     *                             NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                             JLO,L1,NCOR,SALAG,ITER,RUN)
                     ENDIF
  790              CONTINUE
C
Cd           call ADVNCP(ibcon1,nbt,norb)
          NST = NEND
  415     CONTINUE
C
  417     CONTINUE
C
C      Double excitations
C
          DO 4015 IAA = IA+1,NAT
             IPA = IAA
             IIA = IACON1(IAA)
             IS3 = IOX(IIA)
             IF (JJ.GT.IIA) IPA = IPA - 1
             ISTAA = JJ+1
             IENAA = IEN
             DO 4010 KKJAA=KKJ,NA+1
                DO 4005 JJAA=ISTAA,IENAA
                IS4 = IOX(JJAA)
                IP2 = IMUL(IS4,IS3)
                IF (IP1.NE.IP2) GOTO 4005
C
             CALL RET1CP(IACON2,IBCON1,NA,IPA,JJAA,0,KKJAA,IPER2)
             IPET = POSCP(NACT,NA,IBCON1,IFA)
             ICA1 = ISPA(IPET)
             IPERT = IPER1+IPER2
             IPERT = ((-1)**IPERT)*ICONST
                   I2 = INDEX(IACON1(IAA),JJAA)
                   II1 = INDEX(JJAA,IO1)
                   II2 = INDEX(IACON1(IAA),JJ)
                   CALL VCLR(YAOG,1,NXYZ)
                   CALL HSMLTN(YAOG,YAOTMP,IO1,JJ,IIA,JJAA,IND,
     *                         I2,NACT,NNACT,NXYZ,ONE)
                   CALL HSMLTN(YAOG,YAOTMP,IO1,JJAA,IIA,JJ,II1,
     *                         II2,NACT,NNACT,NXYZ,-ONE)
C
                DO 786 INB1 = ISBS(ISA1),ISBS(ISA1+1)-1
                   NEND = ISBC(INB1)
                   ICI2 = ICA1 + ISPB(NEND)
                   ICIT = ICAT+ISPB(NEND)
                   FC = IPERT
C
                   IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                       DO ISTAT=1,NSTATS
                         CVAL = CI(ICI2,ISTAT)
                         WVAL = WSTATE(ISTAT)
                         IF(ABS(CVAL).GT.TOL) THEN
                           IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
                           DVAL = CVAL*WVAL*FC
                           CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWIT),1)
                         ENDIF
                       ENDDO
                       CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                             FC,ICIT,ICI2,IO1,JJ,IIA,JJAA,IND,I2,
     *                             NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                             JLO,L1,NCOR,SALAG,ITER,RUN)
                       CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,-FC,
     *                             ICIT,ICI2,IO1,JJAA,IIA,JJ,II1,II2,
     *                             NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                             JLO,L1,NCOR,SALAG,ITER,RUN)
                   ENDIF
                   IF(ICI2.GE.JLO .AND. ICI2.LE.JHI) THEN
                       DO ISTAT=1,NSTATS
                         CVAL = CI(ICIT,ISTAT)
                         WVAL = WSTATE(ISTAT)
                         IF(ABS(CVAL).GT.TOL) THEN
                           IWI2 = (ISTAT-1)*NDETLN + ICI2 - JLO + 1
                           DVAL = CVAL*WVAL*FC
                           CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI2),1)
                         ENDIF
                       ENDDO
                       CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                             FC,ICI2,ICIT,IO1,JJ,IIA,JJAA,IND,I2,
     *                             NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                             JLO,L1,NCOR,SALAG,ITER,RUN)
                       CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,-FC,
     *                             ICI2,ICIT,IO1,JJAA,IIA,JJ,II1,II2,
     *                             NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                             JLO,L1,NCOR,SALAG,ITER,RUN)
                   ENDIF
  786       CONTINUE
C
 4005           CONTINUE
                ISTAA = IACON1(KKJAA)+1
                IENAA = IACON1(KKJAA+1)-1
                IF (KKJAA.EQ.NA) IENAA=NACT
 4010        CONTINUE
 4015 CONTINUE
C
C
 7020           CONTINUE
                IST = IACON1(KKJ)+1
                IEN = IACON1(KKJ+1)-1
                IF (KKJ.EQ.NA) IEN=NACT
 7025        CONTINUE
 7030     CONTINUE
C
C  Diagonal
C
            DO 67 II=1,NAT
               I1 = IACON1(II)
               IND1 = INDEX(I1,I1)
C
              DO 53 INB1 = ISBS(ISA1),ISBS(ISA1+1)-1
                NEND = ISBC(INB1)
                ICIT = ICAT+ISPB(NEND)
                FC = ONE
C
                IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                  CALL HSMLT1(AVEC,YAC,BVEC,RHSC,CI,OINT,AMAT,
     *                        FC,ICIT,ICIT,IND1,I1,I1,JLO,
     *                        NSTATS,NCI,NDETLN,L1,NCOR,
     *                        NNACT,NXYZ,WSTATE,SALAG,ITER)
                ENDIF
   53         CONTINUE
C
               DO 64 JJ=II+1,NAT
                  I2 = IACON1(JJ)
                  IND2 = INDEX(I2,I2)
                  INDM = IND2 - I2 + I1
                  J1 = INDEX(INDM,INDM)
                  J2 = INDEX(IND2,IND1)
                  CALL VCLR(YAOG,1,NXYZ)
                  CALL HSMLTN(YAOG,YAOTMP,I1,I1,I2,I2,IND1,
     *                        IND2,NACT,NNACT,NXYZ,ONE)
                  CALL HSMLTN(YAOG,YAOTMP,I1,I2,I2,I1,INDM,
     *                        INDM,NACT,NNACT,NXYZ,-ONE)
C
               DO 55 INB1 = ISBS(ISA1),ISBS(ISA1+1)-1
                  NEND = ISBC(INB1)
                  ICIT = ICAT+ISPB(NEND)
                  FC = ONE
C
                  IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                       DO ISTAT=1,NSTATS
                         CVAL = CI(ICIT,ISTAT)
                         WVAL = WSTATE(ISTAT)
                         IF(ABS(CVAL).GT.TOL) THEN
                           IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
                           DVAL = CVAL*WVAL*FC
                           CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWIT),1)
                         ENDIF
                       ENDDO
                       CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                             FC,ICIT,ICIT,I1,I1,I2,I2,IND1,IND2,
     *                             NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                             JLO,L1,NCOR,SALAG,ITER,RUN)
                       CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,-FC,
     *                             ICIT,ICIT,I1,I2,I2,I1,INDM,INDM,NACT,
     *                             NNACT,NSTATS,NXYZ,NCI,NDETLN,JLO,L1,
     *                             NCOR,SALAG,ITER,RUN)
                  ENDIF
   55          CONTINUE
C
   64          CONTINUE
C
         DO 47 I=1,NBT
            IBCON1(I) = I
   47    CONTINUE
C
             NST = 1
             DO 56 INB1 = ISBS(ISA1),ISBS(ISA1+1)-1
             NEND = ISBC(INB1)
             DO 7710 KK=NST,NEND-1
                CALL ADVNCP(IBCON1,NBT,NACT)
 7710        CONTINUE
             ICIT = ICAT+ISPB(NEND)
C
               DO 68 JJ=1,NBT
                  I2 = IBCON1(JJ)
                  IND2 = INDEX(I2,I2)
                  J2 = INDEX(IND1,IND2)
                  FC = ONE
                  CALL VCLR(YAOG,1,NXYZ)
                  CALL HSMLTN(YAOG,YAOTMP,I1,I1,I2,I2,IND1,
     *                        IND2,NACT,NNACT,NXYZ,ONE)
C
                  IWIT = 0
                  IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                       DO ISTAT=1,NSTATS
                         CVAL = CI(ICIT,ISTAT)
                         WVAL = WSTATE(ISTAT)
                         IF(ABS(CVAL).GT.TOL) THEN
                           IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
                           DVAL = CVAL*WVAL*FC
                           CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWIT),1)
                         ENDIF
                       ENDDO
                       CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,FC,
     *                             ICIT,ICIT,I1,I1,I2,I2,IND1,IND2,NACT,
     *                             NNACT,NSTATS,NXYZ,NCI,NDETLN,JLO,L1,
     *                             NCOR,SALAG,ITER,RUN)
                  ENDIF
   68          CONTINUE
C
Cc           call ADVNCP(ibcon1,nbt,norb)
            NST = NEND
   56       CONTINUE
C
   67       CONTINUE
C
C   Loop over Beta dets now
C
C        IF (NA.NE.NB) THEN
         DO 40 II=1,NBT
            IBCON1(II) = II
   40    CONTINUE
         JJZ = 1
C        ELSE
C        DO 41 II=1,NBT
C           IBCON1(II) = IACON1(II)
C  41    CONTINUE
C        JJZ = IJK
C        ENDIF
C
         DO 8000 KJI = JJZ,NBLP
         ISTAR = ISTART(KJI)-1
         IPB1 = ISPB(KJI)
         ISB1 = ISYMB(KJI)
         ITBS = ITAB(ISB1)
         IMZZ = IMMC(ITBS)
         M1 = 0
         M2 = 0
         IF (ISB1.EQ.ITAS) M1 = 1
         IF (IMZZ.NE.0) M2 = 1
         IF (M1.EQ.0.AND.M2.EQ.0) GOTO 7998
         QNUM = 1.0D+00
C        IF (NA.EQ.NB.AND.IJK.EQ.KJI) QNUM=2.0D+00
         IC1 = ICAT + IPB1
C
C   Beta first *********************** Single
C
          DO 900 IB=1,NBT
             IBB = IBCON1(IB)
             IB1 = IOX(IBB)
             IR1 = IMUL(IB1,ISB1)
             IST = IBB+1
             IEN = IBCON1(IB+1)-1
             IF (IB.EQ.NBT) IEN = NACT
             DO 895 KKJ=IB+1,NB+1
                DO 890 JJ=IST,IEN
                IB2 = IOX(JJ)
                ISB2 = IMUL(IR1,IB2)
                ITB2 = ITAB(ISB2)
                ISTAR = ISTAR + 1
                IF (ISB2.NE.ITAS.AND.M1.EQ.0) GOTO 890
                IF (M2.EQ.0.AND.IMMC(ITB2).EQ.0) GOTO 890
                IF (ISB2.NE.ITAS.AND.IMMC(ITB2).EQ.0) GOTO 890
C
C               call RET1MC(ibcon1,iacon2,nb,ib,jj,ncor,kkj,iper1)
C                   iposb = POSCP(nact,nb,iacon2,ifa)
C                  ipb2 = ispb(iposb)
                   IPB2 = ISTRB(ISTAR)
                   IC2 = ICAT + IPB2
C           iperb = ((-1)**iper1)
C   iperb1 = ((-1)**iper1)
                   ZPERB = ISTRP(ISTAR)/QNUM
                   IOB = INDEX(IBB,JJ)
C
C           do 1013 iat=1,iac
C                  ici2 = iposa(iat) + iposb
C                  ici3 = iposa(iat) + kji
CcState average here
C               fc = 0.0d+00
C               fc1 = 0.0d+00
C             do 319 kki=1,nstate
C             fc = fc + W(kki)*CI(ici1,iwh(kki))*CI(ici2,iwh(kki))
C             fc1 = fc1+W(kki)*CI(ici3,iwh(kki))*CI(icit,iwh(kki))
C  319          continue
C             fc = fc * ipera(iat)*zperb
C             fc1=fc1 * ipera(iat)*zperb1
C
C                   ind = iind1(iat)
C                    ix = index(ind,iob)
C                   den2(ix) = den2(ix)+fc+fc1
C                   den2(ix) = den2(ix) + fc
C 1013      continue
C
            IF (M2.EQ.0.AND.IMMC(ITB2).NE.0) THEN
               DO 1013 IAT = 1,IMMC(ITB2)
                  IJU = IMMA(ITB2,IAT)
                  IC4 = IPOSA(IJU) + IPB2
                  IND = IIND1(IJU,1)
                  IXI = IIND1(IJU,2)
                  IXJ = IIND1(IJU,3)
                  FC = IPERA(IJU)*ZPERB
                  CALL VCLR(YAOG,1,NXYZ)
                  CALL HSMLTN(YAOG,YAOTMP,IXI,IXJ,IBB,JJ,IND,
     *                        IOB,NACT,NNACT,NXYZ,ONE)
C
                  IF(IC1.GE.JLO .AND. IC1.LE.JHI) THEN
                     DO ISTAT=1,NSTATS
                       CVAL = CI(IC4,ISTAT)
                       WVAL = WSTATE(ISTAT)
                       IF(ABS(CVAL).GT.TOL) THEN
                         IW1 = (ISTAT-1)*NDETLN + IC1 - JLO + 1
                         DVAL = CVAL*WVAL*FC
                         CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IW1),1)
                       ENDIF
                     ENDDO
                     CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,FC,
     *                           IC1,IC4,IXI,IXJ,IBB,JJ,IND,IOB,NACT,
     *                           NNACT,NSTATS,NXYZ,NCI,NDETLN,JLO,L1,
     *                           NCOR,SALAG,ITER,RUN)
                  ENDIF
                  IF(IC4.GE.JLO .AND. IC4.LE.JHI) THEN
                     DO ISTAT=1,NSTATS
                       CVAL = CI(IC1,ISTAT)
                       WVAL = WSTATE(ISTAT)
                       IF(ABS(CVAL).GT.TOL) THEN
                         IW4 = (ISTAT-1)*NDETLN + IC4 - JLO + 1
                         DVAL = CVAL*WVAL*FC
                         CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IW4),1)
                       ENDIF
                     ENDDO
                     CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,FC,
     *                           IC4,IC1,IXI,IXJ,IBB,JJ,IND,IOB,NACT,
     *                           NNACT,NSTATS,NXYZ,NCI,NDETLN,JLO,L1,
     *                           NCOR,SALAG,ITER,RUN)
                  ENDIF
 1013          CONTINUE
               GOTO 890
          ENDIF
C
            IF (M1.EQ.0.AND.ISB2.EQ.ITAS) THEN
               DO 2013 IAT =1,IMMC(ITBS)
                  IJU = IMMA(ITBS,IAT)
                  IC3 = IPOSA(IJU) + IPB1
                  IND = IIND1(IJU,1)
                  IXI = IIND1(IJU,2)
                  IXJ = IIND1(IJU,3)
                  FC = IPERA(IJU)*ZPERB
                  CALL VCLR(YAOG,1,NXYZ)
                  CALL HSMLTN(YAOG,YAOTMP,IXI,IXJ,IBB,JJ,IND,
     *                        IOB,NACT,NNACT,NXYZ,ONE)
C
                  IF(IC2.GE.JLO .AND. IC2.LE.JHI) THEN
                     DO ISTAT=1,NSTATS
                       CVAL = CI(IC3,ISTAT)
                       WVAL = WSTATE(ISTAT)
                       IF(ABS(CVAL).GT.TOL) THEN
                         IW2 = (ISTAT-1)*NDETLN + IC2 - JLO + 1
                         DVAL = CVAL*WVAL*FC
                         CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IW2),1)
                       ENDIF
                     ENDDO
                     CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,FC,
     *                           IC2,IC3,IXI,IXJ,IBB,JJ,IND,IOB,NACT,
     *                           NNACT,NSTATS,NXYZ,NCI,NDETLN,JLO,L1,
     *                           NCOR,SALAG,ITER,RUN)
                  ENDIF
                  IF(IC3.GE.JLO .AND. IC3.LE.JHI) THEN
                     DO ISTAT=1,NSTATS
                       CVAL = CI(IC2,ISTAT)
                       WVAL = WSTATE(ISTAT)
                       IF(ABS(CVAL).GT.TOL) THEN
                         IW3 = (ISTAT-1)*NDETLN + IC3 - JLO + 1
                         DVAL = CVAL*WVAL*FC
                         CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IW3),1)
                       ENDIF
                     ENDDO
                     CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,FC,
     *                           IC3,IC2,IXI,IXJ,IBB,JJ,IND,IOB,NACT,
     *                           NNACT,NSTATS,NXYZ,NCI,NDETLN,JLO,L1,
     *                           NCOR,SALAG,ITER,RUN)
                  ENDIF
 2013          CONTINUE
               GOTO 890
            ENDIF
C
            IF (ISB2.NE.ITAS.AND.IMMC(ITB2).NE.0) THEN
               DO 3013 IAT = 1,IMMC(ITB2)
                  IJU = IMMA(ITB2,IAT)
                  IC4 = IPOSA(IJU) + IPB2
                  IND = IIND1(IJU,1)
                  IXI = IIND1(IJU,2)
                  IXJ = IIND1(IJU,3)
                  FC = IPERA(IJU)*ZPERB
                  CALL VCLR(YAOG,1,NXYZ)
                  CALL HSMLTN(YAOG,YAOTMP,IXI,IXJ,IBB,JJ,IND,
     *                        IOB,NACT,NNACT,NXYZ,ONE)
C
                  IF(IC1.GE.JLO .AND. IC1.LE.JHI) THEN
                     DO ISTAT=1,NSTATS
                       CVAL = CI(IC4,ISTAT)
                       WVAL = WSTATE(ISTAT)
                       IF(ABS(CVAL).GT.TOL) THEN
                         IW1 = (ISTAT-1)*NDETLN + IC1 - JLO + 1
                         DVAL = CVAL*WVAL*FC
                         CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IW1),1)
                       ENDIF
                     ENDDO
                     CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,FC,
     *                           IC1,IC4,IXI,IXJ,IBB,JJ,IND,IOB,NACT,
     *                           NNACT,NSTATS,NXYZ,NCI,NDETLN,JLO,L1,
     *                           NCOR,SALAG,ITER,RUN)
                  ENDIF
                  IF(IC4.GE.JLO .AND. IC4.LE.JHI) THEN
                     DO ISTAT=1,NSTATS
                       CVAL = CI(IC1,ISTAT)
                       WVAL = WSTATE(ISTAT)
                       IF(ABS(CVAL).GT.TOL) THEN
                         IW4 = (ISTAT-1)*NDETLN + IC4 - JLO + 1
                         DVAL = CVAL*WVAL*FC
                         CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IW4),1)
                       ENDIF
                     ENDDO
                     CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,FC,
     *                           IC4,IC1,IXI,IXJ,IBB,JJ,IND,IOB,NACT,
     *                           NNACT,NSTATS,NXYZ,NCI,NDETLN,JLO,L1,
     *                           NCOR,SALAG,ITER,RUN)
                  ENDIF
 3013          CONTINUE
               GOTO 890
            ENDIF
C
            IF (IMMC(ITB2).EQ.0.AND.ISB2.EQ.ITAS) THEN
               DO 4013 IAT =1,IMMC(ITBS)
                  IJU = IMMA(ITBS,IAT)
                  IC3 = IPOSA(IJU) + IPB1
                  IND = IIND1(IJU,1)
                  IXI = IIND1(IJU,2)
                  IXJ = IIND1(IJU,3)
                  FC = IPERA(IJU)*ZPERB
                  CALL VCLR(YAOG,1,NXYZ)
                  CALL HSMLTN(YAOG,YAOTMP,IXI,IXJ,IBB,JJ,IND,
     *                        IOB,NACT,NNACT,NXYZ,ONE)
C
                  IF(IC2.GE.JLO .AND. IC2.LE.JHI) THEN
                     DO ISTAT=1,NSTATS
                       CVAL = CI(IC3,ISTAT)
                       WVAL = WSTATE(ISTAT)
                       IF(ABS(CVAL).GT.TOL) THEN
                         IW2 = (ISTAT-1)*NDETLN + IC2 - JLO + 1
                         DVAL = CVAL*WVAL*FC
                         CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IW2),1)
                       ENDIF
                     ENDDO
                     CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,FC,
     *                           IC2,IC3,IXI,IXJ,IBB,JJ,IND,IOB,NACT,
     *                           NNACT,NSTATS,NXYZ,NCI,NDETLN,JLO,L1,
     *                           NCOR,SALAG,ITER,RUN)
                  ENDIF
                  IF(IC3.GE.JLO .AND. IC3.LE.JHI) THEN
                     DO ISTAT=1,NSTATS
                       CVAL = CI(IC2,ISTAT)
                       WVAL = WSTATE(ISTAT)
                       IF(ABS(CVAL).GT.TOL) THEN
                         IW3 = (ISTAT-1)*NDETLN + IC3 - JLO + 1
                         DVAL = CVAL*WVAL*FC
                         CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IW3),1)
                       ENDIF
                     ENDDO
                     CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,FC,
     *                           IC3,IC2,IXI,IXJ,IBB,JJ,IND,IOB,NACT,
     *                           NNACT,NSTATS,NXYZ,NCI,NDETLN,JLO,L1,
     *                           NCOR,SALAG,ITER,RUN)
                  ENDIF
 4013          CONTINUE
               GOTO 890
            ENDIF
C
            IF (IMMC(ITB2).NE.0.AND.ISB2.EQ.ITAS) THEN
               DO 5013 IAT=1,IMMC(ITB2)
                  IJU = IMMA(ITB2,IAT)
                  IC3 = IPOSA(IJU) + IPB1
                  IC4 = IPOSA(IJU) + IPB2
                  IND = IIND1(IJU,1)
                  IXI = IIND1(IJU,2)
                  IXJ = IIND1(IJU,3)
                  FC = IPERA(IJU)*ZPERB
                  CALL VCLR(YAOG,1,NXYZ)
                  CALL HSMLTN(YAOG,YAOTMP,IXI,IXJ,IBB,JJ,IND,
     *                        IOB,NACT,NNACT,NXYZ,ONE)
C
                  IF(IC2.GE.JLO .AND. IC2.LE.JHI) THEN
                     DO ISTAT=1,NSTATS
                       CVAL = CI(IC3,ISTAT)
                       WVAL = WSTATE(ISTAT)
                       IF(ABS(CVAL).GT.TOL) THEN
                         IW2 = (ISTAT-1)*NDETLN + IC2 - JLO + 1
                         DVAL = CVAL*WVAL*FC
                         CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IW2),1)
                       ENDIF
                     ENDDO
                     CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,FC,
     *                           IC2,IC3,IXI,IXJ,IBB,JJ,IND,IOB,NACT,
     *                           NNACT,NSTATS,NXYZ,NCI,NDETLN,JLO,L1,
     *                           NCOR,SALAG,ITER,RUN)
                  ENDIF
                  IF(IC3.GE.JLO .AND. IC3.LE.JHI) THEN
                     DO ISTAT=1,NSTATS
                       CVAL = CI(IC2,ISTAT)
                       WVAL = WSTATE(ISTAT)
                       IF(ABS(CVAL).GT.TOL) THEN
                         IW3 = (ISTAT-1)*NDETLN + IC3 - JLO + 1
                         DVAL = CVAL*WVAL*FC
                         CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IW3),1)
                       ENDIF
                     ENDDO
                     CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,FC,
     *                           IC3,IC2,IXI,IXJ,IBB,JJ,IND,IOB,NACT,
     *                           NNACT,NSTATS,NXYZ,NCI,NDETLN,JLO,L1,
     *                           NCOR,SALAG,ITER,RUN)
                  ENDIF
C
                  IF(IC1.GE.JLO .AND. IC1.LE.JHI) THEN
                     DO ISTAT=1,NSTATS
                       CVAL = CI(IC4,ISTAT)
                       WVAL = WSTATE(ISTAT)
                       IF(ABS(CVAL).GT.TOL) THEN
                         IW1 = (ISTAT-1)*NDETLN + IC1 - JLO + 1
                         DVAL = CVAL*WVAL*FC
                         CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IW1),1)
                       ENDIF
                     ENDDO
                     CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,FC,
     *                           IC1,IC4,IXI,IXJ,IBB,JJ,IND,IOB,NACT,
     *                           NNACT,NSTATS,NXYZ,NCI,NDETLN,JLO,L1,
     *                           NCOR,SALAG,ITER,RUN)
                  ENDIF
                  IF(IC4.GE.JLO .AND. IC4.LE.JHI) THEN
                     DO ISTAT=1,NSTATS
                       CVAL = CI(IC1,ISTAT)
                       WVAL = WSTATE(ISTAT)
                       IF(ABS(CVAL).GT.TOL) THEN
                         IW4 = (ISTAT-1)*NDETLN + IC4 - JLO + 1
                         DVAL = CVAL*WVAL*FC
                         CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IW4),1)
                       ENDIF
                     ENDDO
                     CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,FC,
     *                           IC4,IC1,IXI,IXJ,IBB,JJ,IND,IOB,NACT,
     *                           NNACT,NSTATS,NXYZ,NCI,NDETLN,JLO,L1,
     *                           NCOR,SALAG,ITER,RUN)
                  ENDIF
 5013          CONTINUE
               GOTO 890
            ENDIF
C
  890           CONTINUE
                IST = IBCON1(KKJ)+1
                IEN = IBCON1(KKJ+1)-1
                IF (KKJ.EQ.NB) IEN=NACT
  895        CONTINUE
  900     CONTINUE
C
 7998     CONTINUE
           CALL ADVNCP(IBCON1,NBT,NACT)
 8000    CONTINUE
      CALL ADVNCP(IACON1,NAT,NACT)
 9000 CONTINUE
C
C   Now for the Beta part
C
C
      DO 876 JJI=1,NBT
         IBCON1(JJI) = JJI
  876 CONTINUE
C
      DO 9999 IJK = 1,NBLP
         ICAB = ISPB(IJK)
         ISB1 = ISYMB(IJK)
C itb1 = itab(isb1)
C        IF (NA.EQ.NB) GOTO 7999
C
      DO 6030 IB=1,NBT
         IST = IBCON1(IB)+1
         IEN = IBCON1(IB+1)-1
         IF (IB.EQ.NBT) IEN=NACT
         IO1 = IBCON1(IB)
         IS1 = IOX(IO1)
         DO 6025 KKJ=IB+1,NB+1
            DO 6020 JJ=IST,IEN
            IS2 = IOX(JJ)
            IP1 = IMUL(IS2,IS1)
C
            CALL RET1CP(IBCON1,IACON2,NB,IB,JJ,0,KKJ,IPER1)
C           IPER = ((-1)**IPER1)*2
            IPER = ((-1)**IPER1)
            IND = INDEX(JJ,IO1)
Cc If deoccupied and newly occupied are of diff sym,
C   then skip to doubles
            IF (IS1.NE.IS2) GOTO 517
            IPB1 = POSCP(NACT,NB,IACON2,IFA)
            IPB1 = ISPB(IPB1)
       DO 89 I=1,NAT
          IACON1(I) = I
   89 CONTINUE
C
C  Loop over alpha
C
          DO 907 INA1 = ISAS(ISB1),ISAS(ISB1+1)-1
             ICIA = ISAC(INA1)
             ICIT = ISPA(ICIA) + ICAB
             ICI2 = ISPA(ICIA) + IPB1
             FC = IPER
C
             IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
               CALL HSMLT1(AVEC,YAC,BVEC,RHSC,CI,OINT,AMAT,
     *                     FC,ICIT,ICI2,IND,IO1,JJ,JLO,
     *                     NSTATS,NCI,NDETLN,L1,NCOR,
     *                     NNACT,NXYZ,WSTATE,SALAG,ITER)
             ENDIF
             IF(ICI2.GE.JLO .AND. ICI2.LE.JHI) THEN
               CALL HSMLT1(AVEC,YAC,BVEC,RHSC,CI,OINT,AMAT,
     *                     FC,ICI2,ICIT,IND,IO1,JJ,JLO,
     *                     NSTATS,NCI,NDETLN,L1,NCOR,
     *                     NNACT,NXYZ,WSTATE,SALAG,ITER)
             ENDIF
  907     CONTINUE
C
             DO 687 IK=1,NBT
                IF (IK.EQ.IB) GOTO 687
                ION = IBCON1(IK)
                J1 = INDEX(ION,ION)
                J2 = INDEX(ION,JJ)
                J3 = INDEX(ION,IO1)
                CALL VCLR(YAOG,1,NXYZ)
                CALL HSMLTN(YAOG,YAOTMP,IO1,JJ,ION,ION,IND,
     *                      J1,NACT,NNACT,NXYZ,ONE)
                CALL HSMLTN(YAOG,YAOTMP,IO1,ION,ION,JJ,J3,
     *                      J2,NACT,NNACT,NXYZ,-ONE)
C
           DO 918 INA1 = ISAS(ISB1),ISAS(ISB1+1)-1
               ICIA = ISAC(INA1)
               ICIT = ISPA(ICIA) + ICAB
               ICI2 = ISPA(ICIA) + IPB1
               FC = IPER
C
               IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                 DO ISTAT=1,NSTATS
                   CVAL = CI(ICI2,ISTAT)
                   WVAL = WSTATE(ISTAT)
                   IF(ABS(CVAL).GT.TOL) THEN
                     IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
                     DVAL = CVAL*WVAL*FC
                     CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWIT),1)
                   ENDIF
                 ENDDO
                 CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,FC,ICIT,
     *                       ICI2,IO1,JJ,ION,ION,IND,J1,NACT,
     *                       NNACT,NSTATS,NXYZ,NCI,NDETLN,JLO,L1,NCOR,
     *                       SALAG,ITER,RUN)
                 CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,-FC,ICIT,
     *                       ICI2,IO1,ION,ION,JJ,J3,J2,NACT,NNACT,
     *                       NSTATS,NXYZ,NCI,NDETLN,JLO,L1,NCOR,SALAG,
     *                       ITER,RUN)
               ENDIF
               IF(ICI2.GE.JLO .AND. ICI2.LE.JHI) THEN
                 DO ISTAT=1,NSTATS
                   CVAL = CI(ICIT,ISTAT)
                   WVAL = WSTATE(ISTAT)
                   IF(ABS(CVAL).GT.TOL) THEN
                     IWI2 = (ISTAT-1)*NDETLN + ICI2 - JLO + 1
                     DVAL = CVAL*WVAL*FC
                     CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI2),1)
                   ENDIF
                 ENDDO
                 CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,FC,ICI2,
     *                       ICIT,IO1,JJ,ION,ION,IND,J1,NACT,NNACT,
     *                       NSTATS,NXYZ,NCI,NDETLN,JLO,L1,NCOR,SALAG,
     *                       ITER,RUN)
                 CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,-FC,ICI2,
     *                       ICIT,IO1,ION,ION,JJ,J3,J2,NACT,NNACT,
     *                       NSTATS,NXYZ,NCI,NDETLN,JLO,L1,NCOR,SALAG,
     *                       ITER,RUN)
               ENDIF
  918      CONTINUE
C
  687        CONTINUE
C
            NST = 1
            DO 920 INA1 = ISAS(ISB1),ISAS(ISB1+1)-1
            NEND = ISAC(INA1)
            DO 8810 KK=NST,NEND-1
               CALL ADVNCP(IACON1,NAT,NACT)
 8810       CONTINUE
            ICIA = ISPA(NEND)
            ICIT = ICIA + ICAB
            ICI2 = ICIA  + IPB1
C
             DO 690 IK=1,NAT
                ION = IACON1(IK)
                J1 = INDEX(ION,ION)
                FC = IPER
                CALL VCLR(YAOG,1,NXYZ)
                CALL HSMLTN(YAOG,YAOTMP,IO1,JJ,ION,ION,IND,
     *                      J1,NACT,NNACT,NXYZ,ONE)
C
                IWIT = 0
                IWI2 = 0
                IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                  DO ISTAT=1,NSTATS
                    CVAL = CI(ICI2,ISTAT)
                    WVAL = WSTATE(ISTAT)
                    IF(ABS(CVAL).GT.TOL) THEN
                      IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
                      DVAL = CVAL*WVAL*FC
                      CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWIT),1)
                    ENDIF
                  ENDDO
                  CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,FC,ICIT,
     *                        ICI2,IO1,JJ,ION,ION,IND,J1,NACT,NNACT,
     *                        NSTATS,NXYZ,NCI,NDETLN,JLO,L1,NCOR,SALAG,
     *                        ITER,RUN)
                ENDIF
                IF(ICI2.GE.JLO .AND. ICI2.LE.JHI) THEN
                  DO ISTAT=1,NSTATS
                    CVAL = CI(ICIT,ISTAT)
                    WVAL = WSTATE(ISTAT)
                    IF(ABS(CVAL).GT.TOL) THEN
                      IWI2 = (ISTAT-1)*NDETLN + ICI2 - JLO + 1
                      DVAL = CVAL*WVAL*FC
                      CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI2),1)
                    ENDIF
                  ENDDO
                  CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,FC,ICI2,
     *                        ICIT,IO1,JJ,ION,ION,IND,J1,NACT,NNACT,
     *                        NSTATS,NXYZ,NCI,NDETLN,JLO,L1,NCOR,SALAG,
     *                        ITER,RUN)
                ENDIF
  690        CONTINUE
Cdo           call ADVNCP(iacon1,nat,norb)
             NST = NEND
  920    CONTINUE
C
  517   CONTINUE
C
C  Now for beta doubles
C
       DO 6015 IBB = IB+1,NBT
               ISTBB = JJ+1
               IENBB = IEN
               JB = IBCON1(IBB)
               IS3 = IOX(JB)
               IPB = IBB
               IF (JJ.GT.JB) IPB = IPB - 1
               DO 6010 KKJBB = KKJ,NB+1
                  DO 6005 JJBB = ISTBB,IENBB
                    IS4 = IOX(JJBB)
                    IP2 = IMUL(IS4,IS3)
                    IF (IP1.NE.IP2) GOTO 6005
C
          CALL RET1CP(IACON2,IACON1,NB,IPB,JJBB,0,KKJBB,IPER2)
          IBP2 = POSCP(NACT,NB,IACON1,IFA)
          IBP2 = ISPB(IBP2)
          IPER = IPER1+IPER2
C         IPER = ((-1)**IPER)*2
          IPER = ((-1)**IPER)
               I2 = INDEX(JB,JJBB)
               II1 = INDEX(JJBB,IO1)
               II2 = INDEX(JB,JJ)
               CALL VCLR(YAOG,1,NXYZ)
               CALL HSMLTN(YAOG,YAOTMP,IO1,JJ,JB,JJBB,IND,
     *                     I2,NACT,NNACT,NXYZ,ONE)
               CALL HSMLTN(YAOG,YAOTMP,IO1,JJBB,JB,JJ,II1,
     *                     II2,NACT,NNACT,NXYZ,-ONE)
C
             DO 686 INA1 = ISAS(ISB1),ISAS(ISB1+1)-1
             NEND = ISAC(INA1)
             ICIA = ISPA(NEND)
             ICIT = ICIA + ICAB
             ICI2 = ICIA + IBP2
             FC = IPER
C
               IWIT = 0
               IWI2 = 0
               IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                  DO ISTAT=1,NSTATS
                    CVAL = CI(ICI2,ISTAT)
                    WVAL = WSTATE(ISTAT)
                    IF(ABS(CVAL).GT.TOL) THEN
                      IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
                      DVAL = CVAL*WVAL*FC
                      CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWIT),1)
                    ENDIF
                  ENDDO
                  CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,FC,ICIT,
     *                        ICI2,IO1,JJ,JB,JJBB,IND,I2,NACT,NNACT,
     *                        NSTATS,NXYZ,NCI,NDETLN,JLO,L1,NCOR,SALAG,
     *                        ITER,RUN)
                  CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,-FC,ICIT,
     *                        ICI2,IO1,JJBB,JB,JJ,II1,II2,NACT,NNACT,
     *                        NSTATS,NXYZ,NCI,NDETLN,JLO,L1,NCOR,SALAG,
     *                        ITER,RUN)
               ENDIF
               IF(ICI2.GE.JLO .AND. ICI2.LE.JHI) THEN
                  DO ISTAT=1,NSTATS
                    CVAL = CI(ICIT,ISTAT)
                    WVAL = WSTATE(ISTAT)
                    IF(ABS(CVAL).GT.TOL) THEN
                      IWI2 = (ISTAT-1)*NDETLN + ICI2 - JLO + 1
                      DVAL = CVAL*WVAL*FC
                      CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI2),1)
                    ENDIF
                  ENDDO
                  CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,FC,ICI2,
     *                        ICIT,IO1,JJ,JB,JJBB,IND,I2,NACT,NNACT,
     *                        NSTATS,NXYZ,NCI,NDETLN,JLO,L1,NCOR,SALAG,
     *                        ITER,RUN)
                  CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,-FC,ICI2,
     *                        ICIT,IO1,JJBB,JB,JJ,II1,II2,NACT,NNACT,
     *                        NSTATS,NXYZ,NCI,NDETLN,JLO,L1,NCOR,SALAG,
     *                        ITER,RUN)
               ENDIF
  686       CONTINUE
C
 6005          CONTINUE
               ISTBB = IBCON1(KKJBB)+1
               IENBB = IBCON1(KKJBB+1)-1
               IF (KKJBB.EQ.NB) IENBB=NACT
 6010      CONTINUE
 6015 CONTINUE
C
 6020       CONTINUE
            IST = IBCON1(KKJ)+1
            IEN=IBCON1(KKJ+1)-1
            IF (KKJ.EQ.NB) IEN=NACT
 6025     CONTINUE
 6030 CONTINUE
C
C    Remaining part of diagonal contributions
C
            DO 69 II=1,NBT
               I1 = IBCON1(II)
               IND1 = INDEX(I1,I1)
C
            DO 93 INA1 = ISAS(ISB1),ISAS(ISB1+1)-1
              NEND = ISAC(INA1)
              ICIA = ISPA(NEND)
              ICIT = ICIA + ICAB
              FC = ONE
C
              IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                CALL HSMLT1(AVEC,YAC,BVEC,RHSC,CI,OINT,AMAT,
     *                      FC,ICIT,ICIT,IND1,I1,I1,JLO,
     *                      NSTATS,NCI,NDETLN,L1,NCOR,
     *                      NNACT,NXYZ,WSTATE,SALAG,ITER)
              ENDIF
   93       CONTINUE
C
               DO 74 JJ=II+1,NBT
                  I2 = IBCON1(JJ)
                  IND2 = INDEX(I2,I2)
                  INDM = IND2-I2+I1
                  J1 = INDEX(INDM,INDM)
                  J2 = INDEX(IND2,IND1)
                  CALL VCLR(YAOG,1,NXYZ)
                  CALL HSMLTN(YAOG,YAOTMP,I1,I1,I2,I2,IND1,
     *                        IND2,NACT,NNACT,NXYZ,ONE)
                  CALL HSMLTN(YAOG,YAOTMP,I1,I2,I2,I1,INDM,
     *                        INDM,NACT,NNACT,NXYZ,-ONE)
C
            DO 97 INA1 = ISAS(ISB1),ISAS(ISB1+1)-1
               NEND = ISAC(INA1)
               ICIA = ISPA(NEND)
               ICIT = ICIA + ICAB
               FC = ONE
C
               IWIT = 0
               IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                  DO ISTAT=1,NSTATS
                    CVAL = CI(ICIT,ISTAT)
                    WVAL = WSTATE(ISTAT)
                    IF(ABS(CVAL).GT.TOL) THEN
                      IWIT = (ISTAT-1)*NDETLN + ICIT - JLO + 1
                      DVAL = CVAL*WVAL*FC
                      CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWIT),1)
                    ENDIF
                  ENDDO
                  CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,FC,ICIT,
     *                        ICIT,I1,I1,I2,I2,IND1,IND2,NACT,NNACT,
     *                        NSTATS,NXYZ,NCI,NDETLN,JLO,L1,NCOR,SALAG,
     *                        ITER,RUN)
                  CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,-FC,ICIT,
     *                        ICIT,I1,I2,I2,I1,INDM,INDM,NACT,NNACT,
     *                        NSTATS,NXYZ,NCI,NDETLN,JLO,L1,NCOR,SALAG,
     *                        ITER,RUN)
               ENDIF
   97       CONTINUE
C
   74          CONTINUE
C
   69       CONTINUE
           CALL ADVNCP(IBCON1,NBT,NACT)
 9999 CONTINUE
C
      CALL FMRHSO(RHSO,YADEN,BVEC,ERI,AMAT,OINT,WRK,IROT,INDEX,NACT,
     *            NNACT,NCOR,NXYZ,L1,NROT,NINDX)
C
      RETURN
      END
C*MODULE CPMCHF  *DECK HSSCXO
      SUBROUTINE HSSCXO(YAOG,YAO,ERI,IROT,NXYZ,NACT,NCOR,NNACT,NROT,L1,
     *                  JRLO,JRHI,GOPARR)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR
C
      DIMENSION YAOG(NXYZ,NACT*NACT,NNACT),YAO(NXYZ,NROT),
     *          ERI(L1,NACT,NNACT)
      DIMENSION IROT(L1,L1)
C
      PARAMETER (TOL=1.0D-09)
C
      CALL VCLR(YAOG,1,NXYZ*NACT*NACT*NNACT)
C
      DO 1000 I=1,NACT
        DO 900 M=1,L1
          IPHSE = IROT(M,I+NCOR)
          MI = IABS(IPHSE)
          IF(MI.LT.JRLO .OR. MI.GT.JRHI) GO TO 900
          DO 800 J=1,NACT
            IJ = (J-1)*NACT + I
            DO 700 KL=1,NNACT
              DLT = ERI(M,J,KL)
              IF(ABS(DLT).LT.TOL) GO TO 700
              DLT = DLT*MI/IPHSE
              CALL DAXPY(NXYZ,DLT,YAO(1,MI),1,YAOG(1,IJ,KL),1)
  700       CONTINUE
  800     CONTINUE
  900   CONTINUE
 1000 CONTINUE
C
      IF(GOPARR) CALL DDI_GSUMF(2179,YAOG,NXYZ*NACT*NACT*NNACT)
C
      RETURN
      END
C*MODULE CPMCHF  *DECK JCPDET
      SUBROUTINE JCPDET(WAXCI,PRCNDC,PRCNDS,CI,CIOLD,DFC,DERI,DHC,FCOR,
     *                  ERI,EG,OINT,WSTATE,IOX,IFA,IWRK,NDETMX,NDETLN,
     *                  NCI,NACT,NCOR,NA,NB,IDSYM,ISYM1,NSYM,IIS,IW,
     *                  NXYZ,L1,JLO,JHI,NSTATS,NNSTAT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION WAXCI(NXYZ,NSTATS*NDETLN),PRCNDC(NDETLN,NSTATS),
     *          PRCNDS(*),CI(NDETMX,NSTATS),CIOLD(NCI,NSTATS),DFC(*),
     *          DERI(*),DHC(NXYZ),FCOR(*),ERI(*),EG(NXYZ,NNSTAT),
     *          OINT(*),WSTATE(*)
      DIMENSION IOX(NACT),IFA(0:NACT,0:NACT),IWRK(IIS)
C
      PARAMETER (MXRT=100)
C
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,
     *                EDFT(2),EDISP
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (HALF=0.5D+00,TOL=1.0D-09)
C
      NORB = NACT+NCOR
      N2 = (NACT*NACT+NACT)/2
      NINDX = N2
      IF(NORB.GT.NINDX) NINDX = NORB
      NALP = IFA(NACT,NA)
      NBLP = IFA(NACT,NB)
C
C     ----- Set starting point for various arrays -----
C
      ISYMA = 1
      ISYMB = ISYMA + NALP
      ICOA = ISYMB + NBLP
      ICOB = ICOA + NSYM
      ITAB = ICOB + NSYM
      IMUL = ITAB + NSYM
      ISPA = IMUL + NSYM*NSYM
      ISPB = ISPA + NALP
      ISAS = ISPB + NBLP
      ISBS = ISAS + NSYM+1
      ISAC = ISBS + NSYM+1
      ISBC = ISAC + NALP
C
      IACON1 = ISBC + NBLP
      IBCON1 = IACON1 + NA + 43
      IACON2 = IBCON1 + NA
      IBCON2 = IACON2 + NA
      IPOSA = IBCON2 + NB
      IPERA = IPOSA + (NA*(NACT-NA))
      IIND1 = IPERA + (NA*(NACT-NA))
      INDEX = IIND1 + (NA*(NACT-NA))
      IMMA = INDEX + NINDX*NINDX
      IMMC = IMMA + NSYM*(NA*(NACT-NA))
      ISTRB = IMMC + NSYM
      ISTRP = ISTRB + ((NB*(NACT-NB))*NBLP)/2
      ISTAR = ISTRP + ((NB*(NACT-NB))*NBLP)/2
      ITOT = ISTAR + NBLP - 1
C
      IF(ITOT.GT.IIS) THEN
        IF(MASWRK) THEN
          WRITE(IW,*) 'NOT ENOUGH MEMORY SPECIFIED FOR IWRK'
          WRITE(IW,*) 'ASKED FOR ',IIS,' NEED ',ITOT
        END IF
        CALL ABRT
      END IF
C
C     ----- Expand CI vector over all symmetry determinants -----
C     -----             and set symmetry to C1              -----
C
        CALL VCLR(CI,1,NSTATS*NDETMX)
        CALL DETCP(IW,IOX,NACT,NA,NB,IDSYM,ISYM1,NSYM,NALP,NBLP,
     *             IWRK(IACON1),IWRK(ISYMA),IWRK(ISYMB),IWRK(ICOA),
     *             IWRK(ICOB),IWRK(ITAB),IWRK(IMUL),IWRK(ISPA),
     *             IWRK(ISPB),IWRK(ISAS),IWRK(ISBS),IWRK(ISAC),
     *             IWRK(ISBC),NSTATS,CI,CIOLD)
C
      CALL SETUP(NACT,0,NA,NB,IWRK(IBCON1),
     *           IWRK(IACON2),IFA,IWRK(INDEX),IWRK(ISPB),NBLP,
     *           IWRK(ISTRB),IWRK(ISTRP),IWRK(ISTAR))
C
C     ----- Add one- and two-electron coupling constant terms -----
C     -----              to perturbed quantities              -----
C
      CALL VCLR(PRCNDC,1,NSTATS*NDETLN)
      CALL VCLR(PRCNDS,1,NNSTAT)
      CALL VCLR(WAXCI,1,NXYZ*NSTATS*NDETLN)
      CALL CPDRD2(WAXCI,PRCNDC,CI,DFC,DERI,FCOR,ERI,IWRK(INDEX),
     *            IWRK(IACON1),IWRK(IACON2),IWRK(IMMA),IWRK(IMMC),
     *            IWRK(ISPA),IWRK(ISPB),IWRK(ISYMA),IWRK(ISYMB),
     *            IWRK(ITAB),IOX,IWRK(IMUL),IWRK(IPOSA),IWRK(IPERA),
     *            IWRK(IIND1),IWRK(IBCON1),IWRK(ISAS),IWRK(ISBS),
     *            IWRK(ISAC),IWRK(ISBC),IWRK(ISTAR),IWRK(ISTRB),
     *            IWRK(ISTRP),IFA,NINDX,NDETLN,NACT,NCOR,NA,NB,NALP,
     *            NBLP,NSYM,NXYZ,L1,N2,JLO,JHI,NDETMX,NSTATS)
C
C     ----- Finish perturbed configuration gradient -----
C     -----            and preconditioner           -----
C
      DHCME = ENUCR
      DO I=1,NCOR
        II = (I*I+I)/2
        DHCME = DHCME + OINT(II) + FCOR(II)
      ENDDO
C
      IJSTAT = 0
      DO ISTAT=1,NSTATS
        EVAL = DHCME - ESTATE(ISTAT)
        DO 100 I=JLO,JHI
          CVAL = CI(I,ISTAT)
          IVAL = I - JLO + 1
          PRCNDC(IVAL,ISTAT) = PRCNDC(IVAL,ISTAT) + EVAL
          IF(ABS(CVAL).LT.TOL) GO TO 100
          PRCNDC(IVAL,ISTAT) = PRCNDC(IVAL,ISTAT) + HALF*CVAL*CVAL
          IVAL = IVAL + (ISTAT-1)*NDETLN
          CALL DAXPY(NXYZ,CVAL,DHC,1,WAXCI(1,IVAL),1)
  100   CONTINUE
C
        DO 120 JSTAT=1,ISTAT-1
          IJSTAT = IJSTAT + 1
          EVAL = ESTATE(JSTAT) - ESTATE(ISTAT)
          WVAL = WSTATE(ISTAT) - WSTATE(JSTAT)
          PRCNDS(IJSTAT) = EVAL*WVAL
  120   CONTINUE
      ENDDO
C
      CALL VCLR(EG,1,NNSTAT*NXYZ)
C
      DO 200 ISTAT=1,NSTATS
        DO 200 JSTAT=1,ISTAT
          IJ = (ISTAT*ISTAT-ISTAT)/2 + JSTAT
          DO 150 I=JLO,JHI
            CVAL = CI(I,JSTAT)
            IF(ABS(CVAL).LT.TOL) GO TO 150
            IVAL = (ISTAT-1)*NDETLN + I - JLO + 1
            CALL DAXPY(NXYZ,CVAL,WAXCI(1,IVAL),1,EG(1,IJ),1)
  150     CONTINUE
  200 CONTINUE
C
      IF(GOPARR) CALL DDI_GSUMF(2175,EG,NXYZ*NNSTAT)
C
      RETURN
      END
C*MODULE CPMCHF  *DECK JCPORM
      SUBROUTINE JCPORM(DFC,WAXCI,DHC,DERI,FCOR,OINT,ERI,PRCNDC,PRCNDS,
     *                  CI,CIOLD,WSTMP,EG,LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,
     *                  IOX,IWRK,IW,NDER,NXYZ,L1,L2,N2,N4,LNEED,JLO,
     *                  JHI,NDETMX,NDETLN,NSTATS,ITGA,ITGB,IAST,IBST,
     *                  IIS,NNSTAT,NB1EX)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL FDIRCT,QCORR,GOPARR,DSKWRK,MASWRK
C
      DIMENSION DFC(NXYZ,L2),WAXCI(NXYZ,NSTATS*NDETLN),DHC(NXYZ),
     *          DERI(NXYZ,N4),FCOR(L2),OINT(*),ERI(*),
     *          PRCNDC(NDETLN,NSTATS),PRCNDS(*),CI(NDETMX,NSTATS),
     *          CIOLD(*),EG(NXYZ,NNSTAT),WSTMP(*)
      DIMENSION LBOX1(*),LBOX2(*),LBOX3(*),LBOX4(*),LBOX5(*),
     *          IOX(NACT),IWRK(IIS)
C
      PARAMETER (MXRT=100)
C
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,S,SZ,
     *                GRPDET,STSYM,GLIST,DWPARM,
     *                NFLGDM(MXRT),IWTS(MXRT),NCORSV,NCOR,NACT,NORB,
     *                NA,NB,K,KST,IROOT,IPURES,MAXW1,NITER,MAXP,NCI,
     *                IGPDET,KSTSYM,NFTGCI,IDWEIGH
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ2,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,
     *                EDFT(2),EDISP
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIM(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /FMCOM / X(1)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (HALF=0.5D+00,TOL=1.0D-09)
C
      NSYM = 2**IGPDET
      NINDX = N2
      IF(L1.GT.NINDX) NINDX = L1
C
      LWRK = 1
      LKTAB = LWRK + 43
      LGMUL = LKTAB + NSYM
      LCON = LGMUL + NSYM*NSYM
      LCOA = LCON + NA
      LCOB = LCOA + NSYM*ITGA
      LANDET = LCOB + NSYM*ITGB
      LBNDET = LANDET + NSPACE*ITGA
      NAST = LBNDET + NSPACE*ITGB
      NBST = NAST + ITGA + 1
      LSYMA = NBST + ITGB + 1
      LSYMB = LSYMA + IAST
      LGCOM = LSYMB + IBST
      LSPA = LGCOM + ITGB*ITGA
      LSPB = LSPA + IAST
      LDISB = LSPB + IBST
      LSAS = LDISB + NSYM*ITGB*ITGA
      LSBS = LSAS + (NSYM+1)*ITGA
      LSAC = LSBS + (NSYM+1)*ITGB
      LSBC = LSAC + IAST
      LIND = LSBC + IBST
      LACON1 = LIND + N2 + 1
      LACON2 = LACON1 + NA
      LBCON1 = LACON2 + NA
      LBCON2 = LBCON1 + NA
      IPOSA = LBCON2 + NA
      IPERA = IPOSA + NA*(NACT-NA)*NSYM
      IIND1 = IPERA + NA*(NACT-NA)*NSYM
      IIND2 = IIND1 + NA*(NACT-NA)*NSYM
      IIND3 = IIND2 + NA*(NACT-NA)*NSYM
      IGROA = IIND3 + NA*(NACT-NA)*NSYM
      IMMC = IGROA + NA*(NACT-NA)*NSYM
      INDEX2 = IMMC + NSYM
      LAST = INDEX2 + NINDX*NINDX
C
      IF(IIS.LT.(LAST-1)) THEN
        WRITE(IW,*) 'MEMORY ALLOCATION ERROR IN JCPORM!'
        CALL ABRT
      ENDIF
C
      DO II=1,NSPACE+1
        MSTA(II) = MSTA(II) - NCORSV
      ENDDO
C
      IVAL = LIND
      DO I=1,(NACT*(NACT+1))/2 + 1
         IWRK(IVAL) = (I*(I-1))/2
         IVAL = IVAL + 1
      ENDDO
C
      CALL VCLR(CI,1,NSTATS*NDETMX)
C
      CALL ORMCP(IW,NDER,LBOX1,LBOX2,LBOX3,NA,NB,CI,CIOLD,X(LBST(1)),
     *           NSTATS,NCI,NDETMX,IOX,IGPDET,KSTSYM,NSYM,NACT,IWRK,
     *           IWRK(LKTAB),IWRK(LGMUL),IWRK(LCON),IWRK(LCOA),
     *           IWRK(LCOB),IWRK(LANDET),IWRK(LBNDET),IWRK(NAST),
     *           IWRK(NBST),IWRK(LSYMA),IWRK(LSYMB),IWRK(LGCOM),
     *           IWRK(LSPA),IWRK(LSPB),IWRK(LDISB),IWRK(LSAS),
     *           IWRK(LSBS),IWRK(LSAC),IWRK(LSBC),ITGA,ITGB,IAST,IBST,
     *           NA1EX,NB1EX)
C
      IF(.NOT.FDIRCT) THEN
        IDIM1 = NSYM + 1
        IDIM2 = IBST + 1
      ELSE
        IDIM1 = 1
        IDIM2 = 1
      ENDIF
C
      JB1GR = LAST
      JB1PE = JB1GR + NB1EX
      JB1IN = JB1PE + NB1EX
      JB1PO = JB1IN + NB1EX
      JB1ST = JB1PO + NB1EX
      JB1SY = JB1ST + IDIM1*IDIM2
      JB1IN2 = JB1SY + NB*(NACT-NB)
      LAST = JB1IN2 + 2*NB1EX
C
      IF(.NOT.FDIRCT) THEN
        CALL FCPSUP(IW,NA,NB,NACT,IWRK(LACON1),IWRK(LBCON1),
     *              IWRK(LBCON2),IWRK(LIND),IWRK(NBST),IWRK(LSPB),
     *              LBOX1,LBOX2,LBOX3,LBOX4,
     *              X(LBST(1)),LNEED,IWRK(LBNDET),IWRK(LSYMB),NSYM,
     *              ITGB,IBST,NB1EX,
     *              IWRK(JB1GR),IWRK(JB1PE),IWRK(JB1IN),IWRK(JB1PO),
     *              IWRK(JB1ST),IWRK(JB1SY),IWRK(JB1IN2))
      ENDIF
C
      IF(IIS.LT.(LAST-1)) THEN
        WRITE(IW,*) 'MEMORY ALLOCATION ERROR IN JCPORM!'
        IVAL = NA*MAX(IAST,IBST)
        WRITE(IW,*) 'NA1EX,NB1EX,NB1EX(APPROX)=',NA1EX,NB1EX,IVAL
        CALL ABRT
      ENDIF
C
      CALL VCLR(PRCNDC,1,NSTATS*NDETLN)
      CALL VCLR(PRCNDS,1,NNSTAT)
      CALL VCLR(WAXCI,1,NXYZ*NSTATS*NDETLN)
C
      CALL CPDRDO(WAXCI,DFC,DERI,CI,FCOR,ERI,PRCNDC,
     *            NCORSV,JLO,JHI,NSTATS,NDETLN,
     *            N2,N4,NXYZ,L1,NACT,NDETMX,NA,NB,X(LBST(1)),LNEED,
     *            IWRK(LIND),NSYM,IOX,LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,
     *            IWRK(LGMUL),IWRK(LKTAB),IWRK(LACON1),IWRK(LACON2),
     *            IWRK(LBCON1),IWRK(LBCON2),IWRK(LANDET),IWRK(LBNDET),
     *            IWRK(NAST),IWRK(NBST),IWRK(LSYMA),IWRK(LSYMB),
     *            IWRK(LGCOM),IWRK(LSPA),IWRK(LSPB),IWRK(LDISB),
     *            IWRK(LSAS),IWRK(LSBS),IWRK(LSAC),IWRK(LSBC),ITGA,
     *            ITGB,IAST,IBST,IWRK(IPOSA),IWRK(IPERA),IWRK(IIND1),
     *            IWRK(IGROA),IWRK(IMMC),NB1EX,IWRK(JB1GR),IWRK(JB1PE),
     *            IWRK(JB1IN),IWRK(JB1PO),IWRK(JB1ST),IDIM1,IDIM2)
C
C     ----- Finish perturbed configuration gradient -----
C     -----            and preconditioner           -----
C
      DHCME = ENUCR
      DO I=1,NCORSV
        II = (I*I+I)/2
        DHCME = DHCME + OINT(II) + FCOR(II)
      ENDDO
C
      IJSTAT = 0
      DO ISTAT=1,NSTATS
        EVAL = DHCME - ESTATE(ISTAT)
        DO 100 I=JLO,JHI
          CVAL = CI(I,ISTAT)
          IVAL = I - JLO + 1
          PRCNDC(IVAL,ISTAT) = PRCNDC(IVAL,ISTAT) + EVAL
          IF(ABS(CVAL).LT.TOL) GO TO 100
          PRCNDC(IVAL,ISTAT) = PRCNDC(IVAL,ISTAT) + HALF*CVAL*CVAL
          IVAL = IVAL + (ISTAT-1)*NDETLN
          CALL DAXPY(NXYZ,CVAL,DHC,1,WAXCI(1,IVAL),1)
  100   CONTINUE
C
        DO 120 JSTAT=1,ISTAT-1
          IJSTAT = IJSTAT + 1
          EVAL = ESTATE(JSTAT) - ESTATE(ISTAT)
          WVAL = WSTMP(ISTAT) - WSTMP(JSTAT)
          PRCNDS(IJSTAT) = EVAL*WVAL
  120   CONTINUE
      ENDDO
C
      CALL VCLR(EG,1,NNSTAT*NXYZ)
C
      DO 200 ISTAT=1,NSTATS
        DO 200 JSTAT=1,ISTAT
          IJ = (ISTAT*ISTAT-ISTAT)/2 + JSTAT
          DO 150 I=JLO,JHI
            CVAL = CI(I,JSTAT)
            IF(ABS(CVAL).LT.TOL) GO TO 150
            IVAL = (ISTAT-1)*NDETLN + I - JLO + 1
            CALL DAXPY(NXYZ,CVAL,WAXCI(1,IVAL),1,EG(1,IJ),1)
  150     CONTINUE
  200 CONTINUE
C
      IF(GOPARR) CALL DDI_GSUMF(2176,EG,NXYZ*NNSTAT)
C
      RETURN
      END
C*MODULE CPMCHF  *DECK JCPOVR
      SUBROUTINE JCPOVR(FCM,SDER,DFC,DERI,DLAG,DHC,DSAO,V,OINT,FCOR,ERI,
     *                  AMAT,DMMO,TPDM,PRCNDO,EPS,WRK,WRK2,IA,INDEX,
     *                  NCOR,NACT,NXYZ,L0,L1,L2,N2,N4,NROT,NDER,NFT18)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,SVDSKW
C
      INTEGER         C_OOOO, C_VOOO, C_VVOO, C_VOVO
C
      DIMENSION FCM(NXYZ,NXYZ),SDER(NXYZ,L1*L1),DFC(NXYZ,L2),
     *          DERI(NXYZ,N4),DLAG(NXYZ,L1,L1),DHC(NXYZ),DSAO(L1*L1),
     *          V(L1,L1),OINT(L2),ERI(L1,NACT,N2),FCOR(L2),
     *          AMAT(L1,NCOR,N2),DMMO(N2),TPDM(N4),PRCNDO(NROT),
     *          EPS(L1,L1),WRK(*),WRK2(*)
      DIMENSION IA(L2),INDEX(L1,L1)
C
      PARAMETER (MXGTOT=20000,MXSH=5000)
C
      COMMON /DLBTIM/ C_OOOO,C_VOOO,C_VVOO,C_VOVO
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ZERO=0.0D+00,HALF=0.5D+00,ONE=1.0D+00,TWO=2.0D+00)
C
      L3 = L1*L1
      L0TRI = (L0*L0+L0)/2
      NOCC = NACT + NCOR
C
      DO 10 I=1,L2
   10   IA(I) = (I*I-I)/2
C
      CALL VCLR(FCOR,1,L2)
      CALL VCLR(ERI,1,L1*NACT*N2)
      CALL VCLR(AMAT,1,L1*NCOR*N2)
C
      CALL DAREAD(IDAF,IODA,DHC,NXYZ,259,0)
C
      IF(GOPARR) THEN
        CALL DAREAD(IDAF,IODA,OINT,L0TRI,355,0)
      ELSE
        DSKWRK = .TRUE.
        CALL SEQREW(IJKT)
        CALL SQREAD(IJKT,OINT,L0TRI)
      END IF
C
      IF(MASWRK) CALL DCOPY(L2,OINT,1,FCOR,1)
C
C     ----- Read in perturbed integrals from NFT18 -----
C
      SVDSKW = DSKWRK
      DSKWRK = .FALSE.
      CALL SEQREW(NFT18)
C
      DO IXYZ=1,NXYZ
        CALL SQREAD(NFT18,WRK,L2)
        CALL DCOPY(L2,WRK,1,DFC(IXYZ,1),NXYZ)
        CALL SQREAD(NFT18,WRK,N4)
        CALL DCOPY(N4,WRK,1,DERI(IXYZ,1),NXYZ)
        CALL SQREAD(NFT18,WRK,L3)
        CALL DCOPY(L3,WRK,1,DLAG(IXYZ,1,1),NXYZ)
      ENDDO
C
      DSKWRK = SVDSKW
C
C     ----- Transform derivative overlap integrals into MO basis -----
C
      CALL VCLR(SDER,1,L3*NXYZ)
      CALL DAREAD(IDAF,IODA,V,L3,15,0)
C
      IF(NDER.EQ.2) THEN
        DO 40 M=1,3
          IF(M.EQ.1) CALL DAREAD(IDAF,IODA,DSAO,L3,63,0)
          IF(M.EQ.2) CALL DAREAD(IDAF,IODA,DSAO,L3,64,0)
          IF(M.EQ.3) CALL DAREAD(IDAF,IODA,DSAO,L3,65,0)
          DO 30 ISHELL=1,NSHELL
            IAT  = KATOM(ISHELL)
            IXYZ = 3*(IAT-1)
            LOCI = KLOC(ISHELL) - KMIN(ISHELL)
            MINI = KMIN(ISHELL)
            MAXI = KMAX(ISHELL)
            DO 20 I=MINI,MAXI
              II = LOCI + I
              DO JJ=1,L1
                IJ = IA(MAX(II,JJ)) + MIN(II,JJ)
                IIJJ = (JJ-1)*L1 + II
                SDER(IXYZ+M,IJ) = SDER(IXYZ+M,IJ) + DSAO(IIJJ)
              ENDDO
   20       CONTINUE
   30     CONTINUE
   40   CONTINUE
      ELSE
C
        SVDSKW = DSKWRK
        DSKWRK = .FALSE.
        DO IXYZ=1,NXYZ
          CALL SQREAD(NFT18,WRK,L2)
          CALL DCOPY(L2,WRK,1,SDER(IXYZ,1),NXYZ)
        ENDDO
        DSKWRK = SVDSKW
      ENDIF
C
      DO 70 IXYZ=1,NXYZ
        CALL DCOPY(L3,SDER(IXYZ,1),NXYZ,WRK,1)
        CALL TFTRI(DSAO,WRK,V,WRK2,L0,L1,L1)
        CALL VCLR(SDER(IXYZ,1),NXYZ,L3)
        DO 60 I=1,L0
          DO 60 J=1,I
            IIJJ = IA(I) + J
            DVAL = DSAO(IIJJ)
            IJ = (J-1)*L1 + I
            JI = (I-1)*L1 + J
            SDER(IXYZ,IJ) = DVAL
            SDER(IXYZ,JI) = DVAL
   60   CONTINUE
   70 CONTINUE
C
C     ----- Add derivative overlap contributions to force constant -----
C     -----                         matrix                         -----
C
      IF(NDER.EQ.2) THEN
        DO 100 JXYZ=1,NXYZ
          CALL DCOPY(L3,SDER(JXYZ,1),NXYZ,WRK,1)
          DO 90 J=1,NOCC
            DO 90 I=1,L1
              IJ = (J-1)*L1 + I
              DVAL = ZERO
              DO M=1,L1
                MI = (I-1)*L1 + M
                DVAL = DVAL + WRK(MI)*EPS(M,J)
              ENDDO
              WRK2(IJ) = DVAL
   90     CONTINUE
          CALL DAXPY(L1*NOCC,-ONE,DLAG(JXYZ,1,1),NXYZ,WRK2,1)
C
          DO IXYZ=1,NXYZ
            DVAL = DDOT(L1*NOCC,WRK2,1,SDER(IXYZ,1),NXYZ)
            FCM(IXYZ,JXYZ) = FCM(IXYZ,JXYZ) + DVAL
          ENDDO
  100   CONTINUE
      ENDIF
C
C     ----- Add derivative overlap (two-electron) contributions to -----
C     -----                      various terms                     -----
C
      IF(GOPARR) THEN
        CALL DDI_PROCDLB_RESET(C_OOOO)
        CALL DDI_PROCDLB_RESET(C_VOOO)
        CALL DDI_PROCDLB_RESET(C_VVOO)
        CALL DDI_PROCDLB_RESET(C_VOVO)
C
        CALL DSCAL(L2*NXYZ,ONE/NPROC,DFC,1)
        CALL DSCAL(N4*NXYZ,ONE/NPROC,DERI,1)
        CALL DSCAL(L3*NXYZ,ONE/NPROC,DLAG,1)
C
        CALL PCPSDR(WRK,SDER,DLAG,DFC,DERI,FCOR,ERI,AMAT,DMMO,TPDM,
     *              PRCNDO,IA,INDEX,NCOR,NACT,NXYZ,L0,L1,L2,N2,N4,NROT,
     *              IW)
      ENDIF
C
C     ----- Add derivative overlap (one-electron) contributions to -----
C     -----   the derivative core Fock and Hamiltonian matrices    -----
C
      DO 180 IXYZ=1,NXYZ
C
        DO 160 I=1,L1
          DO 160 J=1,I
            IJ = IA(I) + J
            DVAL = ZERO
            DO M=1,L1
              IG = MAX(I,M)
              MG = MIN(I,M)
              IM = IA(IG) + MG
C
              JG = MAX(J,M)
              MG = MIN(J,M)
              JM = IA(JG) + MG
C
              MI = (I-1)*L1 + M
              MJ = (J-1)*L1 + M
              DVAL = DVAL + SDER(IXYZ,MI)*FCOR(JM)
              DVAL = DVAL + SDER(IXYZ,MJ)*FCOR(IM)
            ENDDO
            DFC(IXYZ,IJ) = DFC(IXYZ,IJ) - HALF*DVAL
  160   CONTINUE
C
        DVAL = ZERO
        DO 170 I=1,NCOR
          II = IA(I) + I
          DVAL = DVAL + DFC(IXYZ,II)
          DO M=1,L1
            IG = MAX(I,M)
            MG = MIN(I,M)
            IM = IA(IG) + MG
            MI = (I-1)*L1 + M
            DVAL = DVAL - SDER(IXYZ,MI)*OINT(IM)
          ENDDO
  170   CONTINUE
C
        DHC(IXYZ) = DHC(IXYZ) + DVAL
  180 CONTINUE
C
C     ----- Add derivative overlap (one-electron) contributions to -----
C     -----               the derivative Lagrangian                -----
C
      DO 300 IXYZ=1,NXYZ
        DO 280 I=1,L1
C
          DO 200 J=1,NCOR
            DVAL = ZERO
            DO N=1,L1
              NG = MAX(N,I)
              IG = MIN(N,I)
              NI = IA(NG) + IG
              NJ = (J-1)*L1 + N
              DVAL = DVAL + SDER(IXYZ,NJ)*OINT(NI)
            ENDDO
            DLAG(IXYZ,I,J) = DLAG(IXYZ,I,J) - DVAL
  200     CONTINUE
C
          DO 240 J=1,NACT
            DVAL = ZERO
            DO 220 M=1,NACT
              MG = MAX(M,J)
              JG = MIN(M,J)
              MJ = IA(MG) + JG
              DMVAL = DMMO(MJ)
              DO 220 N=1,L1
                NG = MAX(N,I)
                IG = MIN(N,I)
                NI = IA(NG) + IG
                NM = (M+NCOR-1)*L1 + N
                DVAL = DVAL + SDER(IXYZ,NM)*DMVAL*OINT(NI)
  220       CONTINUE
            DLAG(IXYZ,I,J+NCOR) = DLAG(IXYZ,I,J+NCOR) - HALF*DVAL
  240     CONTINUE
C
          DO 260 J=1,NOCC
            DVAL = ZERO
            DO M=1,L1
              MI = (I-1)*L1 + M
              DVAL = DVAL + SDER(IXYZ,MI)*EPS(M,J)
            ENDDO
            DLAG(IXYZ,I,J) = DLAG(IXYZ,I,J) - HALF*DVAL
  260     CONTINUE
  280   CONTINUE
  300 CONTINUE
C
C     ----- Write total derivative Lagrangian to file -----
C
      SVDSKW = DSKWRK
      DSKWRK = .FALSE.
      CALL SEQREW(NFT18)
      DO IXYZ=1,NXYZ
        CALL DCOPY(L3,DLAG(IXYZ,1,1),NXYZ,WRK,1)
        CALL SQWRIT(NFT18,WRK,L3)
      ENDDO
      DSKWRK = SVDSKW
C
C     ----- Store derivative core Fock matrices over active -----
C     -----                  orbitals only                  -----
C
      DO 1000 I=1,NACT
        IF(NCOR.EQ.0) GO TO 1000
        II = I + NCOR
        DO J=1,I
          JJ = J + NCOR
          IJ = IA(I) + J
          IIJJ = IA(II) + JJ
          CALL DCOPY(NXYZ,DFC(1,IIJJ),1,DFC(1,IJ),1)
        ENDDO
 1000 CONTINUE
C
C     ----- Add one-electron part to orbital preconditioner -----
C
      DO 1100 I=1,L1
        DMI = ZERO
        IF(I.LE.NCOR) DMI = TWO
        IF(I.GT.NCOR .AND. I.LE.NOCC) THEN
          II = IA(I-NCOR) + I-NCOR
          DMI = DMMO(II)
        ENDIF
C
        DO 1100 J=1,I
          IJ = IABS(INDEX(I,J))
          IF(IJ.EQ.0) GO TO 1100
C
          IF(J.LE.NCOR) DMJ = TWO
          IF(J.GT.NCOR) THEN
            JJ = IA(J-NCOR) + J-NCOR
            DMJ = DMMO(JJ)
          ENDIF
C
          II = IA(I) + I
          JJ = IA(J) + J
          DVAL = DMJ*OINT(II) - EPS(J,J)
          IF(I.LE.NOCC) DVAL = DVAL - EPS(I,I) + DMI*OINT(JJ)
          PRCNDO(IJ) = PRCNDO(IJ) + DVAL
 1100 CONTINUE
C
      RETURN
      END
C*MODULE CPMCHF  *DECK MATDD1
      SUBROUTINE MATDD1(DDEN,DCI,CI,M2,NXYZ,NACT,NA,NB,
     *                  NDETLN,NALP,NBLP,IFA,IOX,NSYM,
     *                  IACON1,IBCON1,IACON2,IPOSA,IPERA,IIND1,
     *                  INDEX,ISYMA,ISYMB,
     *                  ISPA,ISPB,ISAS,ISBS,ISAC,ISBC,JLO,JHI)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      INTEGER POSCP
      DIMENSION IOX(NACT)
      DIMENSION DDEN(NXYZ,M2), CI(*), DCI(NXYZ,NDETLN)
      DIMENSION IFA(0:NACT,0:NACT)
      DIMENSION IACON1(NA),IBCON1(NA)
      DIMENSION IACON2(NA),IPERA(NA*(NACT-NA))
      DIMENSION IIND1(NA*(NACT-NA))
      DIMENSION IPOSA(NA*(NACT-NA))
      DIMENSION INDEX(NACT,NACT)
      DIMENSION ISYMA(NALP),ISYMB(NBLP)
      DIMENSION ISPA(NALP),ISPB(NBLP)
      DIMENSION ISAS(NSYM+1),ISBS(NSYM+1),ISAC(NALP),ISBC(NBLP)
C
      PARAMETER (TWO=2.0D+00)
C
      DO 7 I=1,NACT
         DO 8 J=1,I
            INDEX(I,J) = I*(I-1)/2 + J
            INDEX(J,I) = INDEX(I,J)
    8    CONTINUE
    7 CONTINUE
C
      NAT = NA
      NBT = NB
C
      CALL VCLR(DDEN,1,M2*NXYZ)
C
      DO 30 I=1,NAT
         IACON1(I) = I
   30 CONTINUE
C
C   Big Loop over all alpha determinants
C
      DO 9000 IJK = 1,NALP
C
C  Alpha excitations here
C   Single first
C
         IAC = 0
         ICAT = ISPA(IJK)
         ISA1 = ISYMA(IJK)
C itas = itab(isa1)
         DO 7030 IA=1,NAT
             IO1 = IACON1(IA)
             IS1 = IOX(IO1)
             IST = IO1 + 1
             IEN = IACON1(IA+1)-1
             IF (IA.EQ.NAT) IEN=NACT
             DO 7025 KKJ=IA+1,NA+1
                DO 7020 JJ=IST,IEN
                IS2 = IOX(JJ)
C
             IAC = IAC + 1
             CALL RET1CP(IACON1,IACON2,NA,IA,JJ,0,KKJ,IPER1)
C
C   Storage here for later use, well worth it
C
             IPET = POSCP(NACT,NA,IACON2,IFA)
             IPOSA(IAC) = ISPA(IPET)
             IPERA(IAC) = ((-1)**IPER1)
             IND = INDEX(JJ,IO1)
             IIND1(IAC) = IND
C
         DO 49 I=1,NBT
            IBCON1(I) = I
   49    CONTINUE
C
C
                   DO 407 INBB = ISBS(ISA1),ISBS(ISA1+1)-1
                   INB1 = ISBC(INBB)
                   ICIT = ICAT+ISPB(INB1)
                   ICI2 = IPOSA(IAC) + ISPB(INB1)
C
                   IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                     FC = CI(ICI2)*IPERA(IAC)
                     IWIT = ICIT - JLO + 1
                     CALL DAXPY(NXYZ,FC,DCI(1,IWIT),1,DDEN(1,IND),1)
                   ENDIF
C
                   IF(ICI2.GE.JLO .AND. ICI2.LE.JHI) THEN
                     FC = CI(ICIT)*IPERA(IAC)
                     IWI2 = ICI2 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DCI(1,IWI2),1,DDEN(1,IND),1)
                   ENDIF
  407          CONTINUE
C
 7020           CONTINUE
                IST = IACON1(KKJ)+1
                IEN = IACON1(KKJ+1)-1
                IF (KKJ.EQ.NA) IEN=NACT
 7025        CONTINUE
 7030     CONTINUE
C
C  Diagonal
C
            DO 67 II=1,NAT
               I1 = IACON1(II)
               IND1 = INDEX(I1,I1)
C
              DO 53 INB1 = ISBS(ISA1),ISBS(ISA1+1)-1
              NEND = ISBC(INB1)
              ICIT = ICAT+ISPB(NEND)
C
              IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                FC = TWO*CI(ICIT)
                IWIT = ICIT - JLO + 1
                CALL DAXPY(NXYZ,FC,DCI(1,IWIT),1,DDEN(1,IND1),1)
              ENDIF
   53         CONTINUE
C
   67       CONTINUE
C
C   Loop over Beta dets now
C
      CALL ADVNCP(IACON1,NAT,NACT)
 9000 CONTINUE
C
C   Now for the Beta part
C
C
      DO 876 JJI=1,NBT
         IBCON1(JJI) = JJI
  876 CONTINUE
C
      DO 9999 IJK = 1,NBLP
         ICAB = ISPB(IJK)
         ISB1 = ISYMB(IJK)
C itb1 = itab(isb1)
C
      DO 6030 IB=1,NBT
         IST = IBCON1(IB)+1
         IEN = IBCON1(IB+1)-1
         IF (IB.EQ.NBT) IEN=NACT
         IO1 = IBCON1(IB)
         IS1 = IOX(IO1)
         DO 6025 KKJ=IB+1,NB+1
            DO 6020 JJ=IST,IEN
            IS2 = IOX(JJ)
C
            CALL RET1CP(IBCON1,IACON2,NB,IB,JJ,0,KKJ,IPER1)
            IPER = ((-1)**IPER1)
            IND = INDEX(JJ,IO1)
Cc If deoccupied and newly occupied are of diff sym, then
C   skip to doubles
            IF (IS1.NE.IS2) GOTO 517
            IPB1 = POSCP(NACT,NB,IACON2,IFA)
            IPB1 = ISPB(IPB1)
C
       DO 89 I=1,NAT
          IACON1(I) = I
   89 CONTINUE
C
C  Loop over alpha
C
          DO 907 INA1 = ISAS(ISB1),ISAS(ISB1+1)-1
             ICIA = ISAC(INA1)
             ICIT = ISPA(ICIA) + ICAB
             ICI2 = ISPA(ICIA) + IPB1
C
             IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
               FC = CI(ICI2)*IPER
               IWIT = ICIT - JLO + 1
               CALL DAXPY(NXYZ,FC,DCI(1,IWIT),1,DDEN(1,IND),1)
             ENDIF
C
             IF(ICI2.GE.JLO .AND. ICI2.LE.JHI) THEN
               FC = CI(ICIT)*IPER
               IWI2 = ICI2 - JLO + 1
               CALL DAXPY(NXYZ,FC,DCI(1,IWI2),1,DDEN(1,IND),1)
             ENDIF
  907     CONTINUE
C
  517 CONTINUE
 6020      CONTINUE
            IST = IBCON1(KKJ)+1
            IEN=IBCON1(KKJ+1)-1
            IF (KKJ.EQ.NB) IEN=NACT
 6025     CONTINUE
 6030 CONTINUE
C
C    Remaining part of diagonal contributions
C
            DO 69 II=1,NBT
               I1 = IBCON1(II)
               IND1 = INDEX(I1,I1)
            DO 93 INA1 = ISAS(ISB1),ISAS(ISB1+1)-1
              NEND = ISAC(INA1)
              ICIA = ISPA(NEND)
              ICIT = ICIA + ICAB
C
              IF(ICIT.GE.JLO .AND. ICIT.LE.JHI) THEN
                FC = TWO*CI(ICIT)
                IWIT = ICIT - JLO + 1
                CALL DAXPY(NXYZ,FC,DCI(1,IWIT),1,DDEN(1,IND1),1)
              ENDIF
   93       CONTINUE
C
   69       CONTINUE
           CALL ADVNCP(IBCON1,NBT,NACT)
C
 9999 CONTINUE
      RETURN
      END
C*MODULE CPMCHF  *DECK MATMC2
C     ----------------------------------------------------------
      SUBROUTINE MATMC2(NUM,NORB,NCOR,NA,NB,IFA,NSYM,IIS,NDETMX,
     *                  ITGA,ITGB,NSPACE,IAST,IBST,GENMC)
C     ----------------------------------------------------------
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GENMC
      DIMENSION IFA(0:NORB-NCOR,0:NORB-NCOR)
C
      NACT = NORB - NCOR
      N2 = (NACT*NACT+NACT)/2
      NLEN = (NACT**2+NACT)/2
      IF(NUM.GT.NLEN) NLEN = NUM
      NALP = IFA(NACT,NA)
      NBLP = IFA(NACT,NB)
      NDETMX = NALP*NBLP
C
      IF(GENMC) THEN
        IIS = 43 + NSYM*(2+NSYM+ITGA+ITGB+ITGB*ITGA) +
     *        (NSYM+1)*(ITGA+ITGB) + 5*NA + NSPACE*(ITGA+ITGB) +
     *        ITGA+1 + ITGB+1 + 3*IAST + 3*IBST + ITGA*ITGB + N2+1 +
     *        6*NA*(NACT-NA)*NSYM + 6*NA*(NACT-NB)*MAX(IAST,IBST) +
     *        (NSYM+1)*(IBST+1) + NB*(NACT-NB) + NLEN*NLEN
C
      ELSE
        IAST = NALP
        IBST = NBLP
C
C       Similar to MATME2 in ALDECI
C
        IIS = 3*NA + NB + 5*(NA*(NACT-NA)) +
     *    NLEN**2 + 3*(NALP+NBLP) + 4*NSYM +
     *     2*(NSYM+1) + NSYM*NSYM + NSYM*(NA*(NACT-NA)) +
     *    ((NB*(NORB-NCOR-NB))*NBLP) + NBLP + 43
      ENDIF
C
      RETURN
      END
C*MODULE CPMCHF  *DECK MATMC3
      SUBROUTINE MATMC3(NDETMX,NCORSV,ITGA,ITGB,NA,NB,LBOX1,LBOX2,
     *                  LBOX3,LCON,LANDET,LBNDET,LGCOM,LCOB,X,NOCAS)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION X(*)
      DIMENSION LBOX1(*),LBOX2(*),LBOX3(*),LCON(NA),LANDET(NSPACE,ITGA),
     *          LBNDET(NSPACE,ITGB),LGCOM(ITGB,ITGA),LCOB(ITGB)
C
      LOGICAL FDIRCT,QCORR,NOCAS
C
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIM(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
C
      DO II=1,NSPACE+1
        MSTA(II) = MSTA(II) - NCORSV
      ENDDO
C
C     Make LANDET and LBNDET
C
      ISTA1 = LBST(1)
      CALL RESETCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX2)
      DO II=1,ITGA
         DO JJ=1,NSPACE
            ISTA2 = LBST(JJ) - ISTA1 + 1
            LANDET(JJ,II)=ISPADET(X(ISTA2),MNUM(JJ),IDIM(JJ),LBOX1(JJ))
         ENDDO
      CALL PUSHCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX2,IEND)
      ENDDO
C
      CALL RESETCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX2)
      DO II=1,ITGB
         DO JJ=1,NSPACE
            ISTA2 = LBST(JJ) - ISTA1 + 1
            LBNDET(JJ,II)=ISPADET(X(ISTA2),MNUM(JJ),IDIM(JJ),LBOX1(JJ))
         ENDDO
      CALL PUSHCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX2,IEND)
      ENDDO
C
C     Make LGCOM
C
      ICOMP = 0
      CALL RESETCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX3)
      DO JJ=1,ITGA
         CALL RESETCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3)
         DO II=1,ITGB
            LGCOM(II,JJ) = 0
            DO KK=1,NSPACE
               IOC = LBOX1(KK) + LBOX2(KK)
               IF (IOC.GT.MAXI(KK).OR.IOC.LT.MINI(KK)) GO TO 100
            ENDDO
C
            LGCOM(II,JJ) = 1
            ICOMP = ICOMP + 1
  100       CALL PUSHCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3,IEND)
         ENDDO
         CALL PUSHCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX3,IEND)
      ENDDO
C
C     Make LCOB
C
      CALL RESETCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX2)
      DO II=1,ITGB
        CALL RESETDE(LBOX1,NSPACE,NB,MSTA,LCON)
        ITOT = 1
        DO JJ=1,NSPACE
           ITOT = ITOT * LBNDET(JJ,II)
        ENDDO
C
        LCOB(II) = ITOT
        CALL PUSHCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX2,IEND)
      ENDDO
C
C     Determine number of determinants
C
      CALL RESETCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX2)
      NDETMP = 0
      DO II=1,ITGA
        CALL RESETDE(LBOX1,NSPACE,NA,MSTA,LCON)
        ITOT = 1
        DO JJ=1,NSPACE
          ITOT = ITOT*LANDET(JJ,II)
        ENDDO
C
        DO 200 LL=1,ITGB
          IF(LGCOM(LL,II).EQ.0) GO TO 200
          NDETMP = NDETMP + ITOT*LCOB(LL)
  200   CONTINUE
C
        CALL PUSHCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX2,IEND)
      ENDDO
C
      DO II=1,NSPACE+1
        MSTA(II) = MSTA(II) + NCORSV
      ENDDO
C
      IF(NDETMP.NE.NDETMX) THEN
        NOCAS = .TRUE.
        NDETMX = NDETMP
      ENDIF
C
      RETURN
      END
C*MODULE CPMCHF  *DECK MATTD1
      SUBROUTINE MATTD1(TDEN,CI,NSTATS,NACT,NA,NB,
     *                  NDETMX,NALP,NBLP,IFA,IOX,NSYM,
     *                  IACON1,IBCON1,IACON2,IPOSA,IPERA,IIND1,
     *                  INDEX,ISYMA,ISYMB,
     *                  ISPA,ISPB,ISAS,ISBS,ISAC,ISBC)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      INTEGER POSCP
      DIMENSION IOX(NACT)
      DIMENSION TDEN(NACT,NACT,NSTATS*NSTATS), CI(NDETMX,NSTATS)
      DIMENSION IFA(0:NACT,0:NACT)
      DIMENSION IACON1(NA),IBCON1(NA)
      DIMENSION IACON2(NA),IPERA(NA*(NACT-NA))
      DIMENSION IIND1(NA*(NACT-NA))
      DIMENSION IPOSA(NA*(NACT-NA))
      DIMENSION INDEX(NACT,NACT)
      DIMENSION ISYMA(NALP),ISYMB(NBLP)
      DIMENSION ISPA(NALP),ISPB(NBLP)
      DIMENSION ISAS(NSYM+1),ISBS(NSYM+1),ISAC(NALP),ISBC(NBLP)
C
      DO 7 I=1,NACT
         DO 8 J=1,I
            INDEX(I,J) = I*(I-1)/2 + J
            INDEX(J,I) = INDEX(I,J)
    8    CONTINUE
    7 CONTINUE
C
      NAT = NA
      NBT = NB
C
      CALL VCLR(TDEN,1,NACT*NACT*NSTATS*NSTATS)
C
      DO 30 I=1,NAT
         IACON1(I) = I
   30 CONTINUE
C
C   Big Loop over all alpha determinants
C
      DO 9000 IJK = 1,NALP
C
C  Alpha excitations here
C   Single first
C
         IAC = 0
         ICAT = ISPA(IJK)
         ISA1 = ISYMA(IJK)
C itas = itab(isa1)
         DO 7030 IA=1,NAT
             IO1 = IACON1(IA)
             IS1 = IOX(IO1)
             IST = IO1 + 1
             IEN = IACON1(IA+1)-1
             IF (IA.EQ.NAT) IEN=NACT
             DO 7025 KKJ=IA+1,NA+1
                DO 7020 JJ=IST,IEN
                IS2 = IOX(JJ)
C
             IAC = IAC + 1
             CALL RET1CP(IACON1,IACON2,NA,IA,JJ,0,KKJ,IPER1)
C
C   Storage here for later use, well worth it
C
             IPET = POSCP(NACT,NA,IACON2,IFA)
             IPOSA(IAC) = ISPA(IPET)
             IPERA(IAC) = ((-1)**IPER1)
             IND = INDEX(JJ,IO1)
             IIND1(IAC) = IND
             IF (IS1.NE.IS2) GOTO 417
C
         DO 49 I=1,NBT
            IBCON1(I) = I
   49    CONTINUE
C
C
                   DO 407 INBB = ISBS(ISA1),ISBS(ISA1+1)-1
                   INB1 = ISBC(INBB)
                   ICIT = ICAT+ISPB(INB1)
                   ICI2 = IPOSA(IAC) + ISPB(INB1)
C
                   FC = IPERA(IAC)
                   DO 406 ISTAT=1,NSTATS
                     DO 406 JSTAT=1,NSTATS
                       IJSTAT = (ISTAT-1)*NSTATS + JSTAT
                       FCJI = FC*CI(ICIT,JSTAT)*CI(ICI2,ISTAT)
                       TDEN(JJ,IO1,IJSTAT) = TDEN(JJ,IO1,IJSTAT) + FCJI
                       FCJI = FC*CI(ICI2,JSTAT)*CI(ICIT,ISTAT)
                       TDEN(IO1,JJ,IJSTAT) = TDEN(IO1,JJ,IJSTAT) + FCJI
  406              CONTINUE
  407          CONTINUE
C
C
  417     CONTINUE
C
 7020           CONTINUE
                IST = IACON1(KKJ)+1
                IEN = IACON1(KKJ+1)-1
                IF (KKJ.EQ.NA) IEN=NACT
 7025        CONTINUE
 7030     CONTINUE
C
C  Diagonal
C
            DO 67 II=1,NAT
               I1 = IACON1(II)
C
              DO 53 INB1 = ISBS(ISA1),ISBS(ISA1+1)-1
              NEND = ISBC(INB1)
              ICIT = ICAT+ISPB(NEND)
C
               DO 52 ISTAT=1,NSTATS
                 DO 52 JSTAT=1,NSTATS
                   IJSTAT = (ISTAT-1)*NSTATS + JSTAT
                   FCJI = CI(ICIT,JSTAT)*CI(ICIT,ISTAT)
                   TDEN(I1,I1,IJSTAT) = TDEN(I1,I1,IJSTAT) + FCJI
   52          CONTINUE
   53         CONTINUE
C
   67       CONTINUE
C
C   Loop over Beta dets now
C
      CALL ADVNCP(IACON1,NAT,NACT)
 9000 CONTINUE
C
C   Now for the Beta part
C
C
      DO 876 JJI=1,NBT
         IBCON1(JJI) = JJI
  876 CONTINUE
C
      DO 9999 IJK = 1,NBLP
         ICAB = ISPB(IJK)
         ISB1 = ISYMB(IJK)
C itb1 = itab(isb1)
C
      DO 6030 IB=1,NBT
         IST = IBCON1(IB)+1
         IEN = IBCON1(IB+1)-1
         IF (IB.EQ.NBT) IEN=NACT
         IO1 = IBCON1(IB)
         IS1 = IOX(IO1)
         DO 6025 KKJ=IB+1,NB+1
            DO 6020 JJ=IST,IEN
            IS2 = IOX(JJ)
C
            CALL RET1CP(IBCON1,IACON2,NB,IB,JJ,0,KKJ,IPER1)
            IPER = ((-1)**IPER1)
            IND = INDEX(JJ,IO1)
Cc If deoccupied and newly occupied are of diff sym, then
C   skip to doubles
            IF (IS1.NE.IS2) GOTO 517
            IPB1 = POSCP(NACT,NB,IACON2,IFA)
            IPB1 = ISPB(IPB1)
C
       DO 89 I=1,NAT
          IACON1(I) = I
   89 CONTINUE
C
C  Loop over alpha
C
          DO 907 INA1 = ISAS(ISB1),ISAS(ISB1+1)-1
             ICIA = ISAC(INA1)
             ICIT = ISPA(ICIA) + ICAB
             ICI2 = ISPA(ICIA) + IPB1
C
             FC = IPER
             DO 906 ISTAT=1,NSTATS
               DO 906 JSTAT=1,NSTATS
                 IJSTAT = (ISTAT-1)*NSTATS + JSTAT
                 FCJI = FC*CI(ICIT,JSTAT)*CI(ICI2,ISTAT)
                 TDEN(JJ,IO1,IJSTAT) = TDEN(JJ,IO1,IJSTAT) + FCJI
                 FCJI = FC*CI(ICI2,JSTAT)*CI(ICIT,ISTAT)
                 TDEN(IO1,JJ,IJSTAT) = TDEN(IO1,JJ,IJSTAT) + FCJI
  906        CONTINUE
  907     CONTINUE
C
  517 CONTINUE
 6020      CONTINUE
            IST = IBCON1(KKJ)+1
            IEN=IBCON1(KKJ+1)-1
            IF (KKJ.EQ.NB) IEN=NACT
 6025     CONTINUE
 6030 CONTINUE
C
C    Remaining part of diagonal contributions
C
            DO 69 II=1,NBT
               I1 = IBCON1(II)
            DO 93 INA1 = ISAS(ISB1),ISAS(ISB1+1)-1
              NEND = ISAC(INA1)
              ICIA = ISPA(NEND)
              ICIT = ICIA + ICAB
C
              DO 92 ISTAT=1,NSTATS
                DO 92 JSTAT=1,NSTATS
                  IJSTAT = (ISTAT-1)*NSTATS + JSTAT
                  FCJI = CI(ICIT,JSTAT)*CI(ICIT,ISTAT)
                  TDEN(I1,I1,IJSTAT) = TDEN(I1,I1,IJSTAT) + FCJI
   92         CONTINUE
   93       CONTINUE
C
   69       CONTINUE
           CALL ADVNCP(IBCON1,NBT,NACT)
C
 9999 CONTINUE
      RETURN
      END
C*MODULE CPMCHF  *DECK ORMCP
C     ------------------------------------------------------------------
      SUBROUTINE ORMCP(IW,NDER,LBOX1,LBOX2,LBOX3,NA,NB,
     *            CI,CIOLD,X,NSTATS,NX,NDETMX,IBO,
     *            IDSYM,ISYM1,NSYM,
     *            NACT,LWRK,KTAB,LGMUL,
     *            LCON,LCOA,LCOB,
     *            LANDET,LBNDET,NAST,NBST,LSYMA,LSYMB,LGCOM,
     *            LSPA,LSPB,LDISB,
     *            LSAS,LSBS,LSAC,LSBC,
     *            ITGA,ITGB,IAST,IBST,NA1EX,NB1EX)
C     ------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL FDIRCT,QCORR
C
      DIMENSION LBOX1(*),LBOX2(*),LBOX3(*)
      DIMENSION CI(NDETMX,NSTATS),CIOLD(NX,NSTATS),X(*)
      DIMENSION IBO(NACT)
      DIMENSION LWRK(43),KTAB(NSYM),LGMUL(NSYM,NSYM)
      DIMENSION LCON(NA)
      DIMENSION LCOA(NSYM,ITGA),LCOB(NSYM,ITGB)
      DIMENSION LANDET(NSPACE,ITGA),LBNDET(NSPACE,ITGB)
      DIMENSION NAST(ITGA+1),NBST(ITGB+1)
      DIMENSION LSYMA(IAST),LSYMB(IBST)
      DIMENSION LGCOM(ITGB,ITGA)
      DIMENSION LSPA(IAST),LSPB(IBST)
      DIMENSION LDISB(NSYM,ITGB,ITGA)
      DIMENSION LSAS(NSYM+1,ITGA),LSBS(NSYM+1,ITGB)
      DIMENSION LSAC(IAST),LSBC(IBST)
C
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIM(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
C
      IF(NDER.EQ.1 .OR. IDSYM.LT.1) CALL DCOPY(NSTATS*NX,CIOLD,1,CI,1)
C
C 1/
C   MAKE SYMMETRY TABLES
C
      IF (IDSYM.GT.0) THEN
      CALL GTAB(IDSYM,ISYM1,KTAB,LWRK(1),LWRK(4),LWRK(7),LWRK(10))
      CALL GMUL(IDSYM,LGMUL,LWRK(1),LWRK(4),LWRK(7),LWRK(10))
      ELSE
      CALL GTAB(1,1,KTAB,LWRK(1),LWRK(4),LWRK(7),LWRK(10))
      CALL GMUL(1,LGMUL,LWRK(1),LWRK(4),LWRK(7),LWRK(10))
      ENDIF
C
      DO II=1,ITGA
         DO JJ=1,NSYM
            LCOA(JJ,II) = 0
         ENDDO
      ENDDO
C
      DO II=1,ITGB
         DO JJ=1,NSYM
            LCOB(JJ,II) = 0
         ENDDO
      ENDDO
C
C  2/
C    MAKE LANDET, LBNDET.  LANDET(I,J) SAYS HOW MANY ALPHA STRINGS
C    THERE ARE FOR GROUP J, SPACE I.  ANALOGOUS FOR LBNDET(I,J).
C
C    LOOP THROUGH ALL ALPHA GROUPS:
C
      ISTA1 = LBST(1)
      CALL RESETCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX2)
      DO II=1,ITGA
         DO JJ=1,NSPACE
            ISTA2 = LBST(JJ) - ISTA1 + 1
            LANDET(JJ,II)=ISPADET(X(ISTA2),MNUM(JJ),IDIM(JJ),LBOX1(JJ))
         ENDDO
      CALL PUSHCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX2,IEND)
      ENDDO
C
C    LOOP THROUGH ALL BETA GROUPS, DO SAME AS ABOVE ESSENTIALLY.
C
      CALL RESETCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX2)
      DO II=1,ITGB
         DO JJ=1,NSPACE
            ISTA2 = LBST(JJ) - ISTA1 + 1
            LBNDET(JJ,II)=ISPADET(X(ISTA2),MNUM(JJ),IDIM(JJ),LBOX1(JJ))
         ENDDO
      CALL PUSHCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX2,IEND)
      ENDDO
C
C  3/
C    MAKE NAST, NBST.  NAST(I) SAYS WHERE ALPHA STRINGS OF GROUP I
C    START IN FULL STRING LIST - 1.  ANALOGOUS FOR NBST.
C
      NAST(1) = 0
      NBST(1) = 0
      DO II=1,ITGA
         ITOT = 1
         DO JJ=1,NSPACE
            ITOT = ITOT * LANDET(JJ,II)
         ENDDO
         NAST(II+1) = NAST(II) + ITOT
      ENDDO
C
      DO II=1,ITGB
         ITOT = 1
         DO JJ=1,NSPACE
            ITOT = ITOT * LBNDET(JJ,II)
         ENDDO
         NBST(II+1) = NBST(II) + ITOT
      ENDDO
C
C  4/
C       MAKE LGCOM.  IF LGCOM(I,J).NE.0 THEN BETA GROUP I
C       AND ALPHA GROUP J ARE COMPATIBLE.
C
      ICOMP = 0
      CALL RESETCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX3)
      DO JJ=1,ITGA
         CALL RESETCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3)
         DO II=1,ITGB
            LGCOM(II,JJ) = 0
            DO KK=1,NSPACE
               IOC = LBOX1(KK) + LBOX2(KK)
               IF (IOC.GT.MAXI(KK).OR.IOC.LT.MINI(KK)) GO TO 100
            ENDDO
C
            LGCOM(II,JJ) = 1
            ICOMP = ICOMP + 1
  100       CALL PUSHCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3,IEND)
         ENDDO
         CALL PUSHCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX3,IEND)
      ENDDO
C
C  5/
C    A) MAKE LSYMB.  LSYMB(I) IS SYMMETRY OF BETA STRING I.
C       MAKE LCOB.  LCOB(I,J) IS NUMBER OF DETERMINANTS
C       OF SYMMETRY I IN GROUP J.
C       MAKE LSPB.  LSPB(I) IS BETA STRING I'S SYMMETRY POSITION IN
C       IT'S OWN GROUP.
C
      CALL RESETCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX2)
C
C    LOOP THROUGH GROUPS.
C
      ICOUNT = 0
      DO II=1,ITGB
C
C    LOOP THROUGH ALL STRINGS IN GROUP II.
C
         CALL RESETDE(LBOX1,NSPACE,NB,MSTA,LCON)
C
         ITOT = 1
         DO JJ=1,NSPACE
            ITOT = ITOT * LBNDET(JJ,II)
         ENDDO
C
         DO KK=1,ITOT
            ICOUNT = ICOUNT + 1
            CALL GETSYM1(IW,LCON,NACT,NB,IBO,IDSYM,ISYM,
     *      LWRK(1),LWRK(4),LWRK(7),LWRK(10))
            LSYMB(ICOUNT) = ISYM
            LCOB(ISYM,II) = LCOB(ISYM,II) + 1
            LSPB(ICOUNT) = LCOB(ISYM,II)
C
            CALL MOVEUP2(LBOX1,NSPACE,NB,MSTA,LCON)
         ENDDO
C
         CALL PUSHCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX2,IEND)
      ENDDO
C
C    B) - MAKE LSYMA.  LSYMA(I) IS SYMMETRY OF ALPHA STRING I.
C       - MAKE LCOA.  LCOA(I,J) IS NUMBER OF DETERMINANTS
C         OF SYMMETRY I IN GROUP J.
C       - MAKE LSPA.  LSPA(I) IS WHERE ALPHA STRING I STARTS IN
C         THE FULL LIST OF DETERMINANTS.  EACH ALPHA STRING IS COUPLED
C         WITH RELEVANT BETA STRINGS (IN BETA GROUP AND SYMMETRY ORDER).
C       - MAKE LDISB.  LDISB(ISYM,I,J) SAYS WHERE BETA GROUP I, AND
C         SYMMETRY ISYM STARTS WHEN COUPLED TO ALPHA GROUP J.
C
      CALL RESETCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX2)
C
C    LOOP THROUGH GROUPS.
C
      ICOUNT = 0
      NCI = 0
      IVAL = 1
      JVAL = 1
      DO II=1,ITGA
C
C    LOOP THROUGH ALL STRINGS IN GROUP II.
C
         CALL RESETDE(LBOX1,NSPACE,NA,MSTA,LCON)
         ITOT = 1
         DO JJ=1,NSPACE
            ITOT = ITOT * LANDET(JJ,II)
         ENDDO
C
         DO KK=1,ITOT
            ICOUNT = ICOUNT + 1
            CALL GETSYM1(IW,LCON,NACT,NA,IBO,IDSYM,ISYM,
     *      LWRK(1),LWRK(4),LWRK(7),LWRK(10))
            LSYMA(ICOUNT) = ISYM
            LCOA(ISYM,II) = LCOA(ISYM,II) + 1
C
            LSPA(ICOUNT) = NCI
            JSYM = KTAB(ISYM)
            DO 200 LL=1,ITGB
               IF (LGCOM(LL,II).EQ.0) GO TO 200
               NCI = NCI + LCOB(JSYM,LL)
  200       CONTINUE
C
C      The following code places the CI vector into C1 order
C      for hessians involving higher-order point groups
C
            IF(NDER.EQ.2 .AND. IDSYM.GT.0) THEN
              JCOUNT = 0
              DO 180 LL=1,ITGB
                IF(LGCOM(LL,II).EQ.0) GO TO 180
C
                DO 160 JJ=NBST(LL)+1,NBST(LL+1)
                  JCOUNT = JCOUNT + 1
                  JSYM = LGMUL(ISYM,LSYMB(JCOUNT))
                  IF(JSYM.EQ.ISYM1) THEN
                    CI(IVAL,1) = CIOLD(JVAL,1)
                    JVAL = JVAL + 1
                  ENDIF
                  IVAL = IVAL + 1
  160           CONTINUE
  180         CONTINUE
            ENDIF
C
C      End of new code
C
            CALL MOVEUP2(LBOX1,NSPACE,NA,MSTA,LCON)
         ENDDO
C
         DO KK=1,NSYM
            LWRK(KK) = 0
         ENDDO
         DO 300 JJ=1,ITGB
            DO KK=1,NSYM
               LDISB(KK,JJ,II) = 0
            ENDDO
            IF (LGCOM(JJ,II).EQ.0) GO TO 300
            DO KK=1,NSYM
               LDISB(KK,JJ,II) = LWRK(KK)
               LWRK(KK) = LWRK(KK) + LCOB(KK,JJ)
            ENDDO
  300    CONTINUE
C
         CALL PUSHCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX2,IEND)
      ENDDO
C
C  6/
C    A) MAKE LSAS,LSBS,AND LSAC, LSBC.
C       LSAS(I,J) SAYS WHERE ALPHA STRINGS
C       OF GROUP J AND SYMMETRY I, START IN LSAC.
C       ANALOGOUS FOR LSBS AND LSBC.
C
      IPLA = 1
      DO II=1,ITGA
         DO JJ=1,NSYM
            LSAS(JJ,II) = IPLA
            IPLA = IPLA + LCOA(JJ,II)
         ENDDO
         LSAS(NSYM+1,II) = IPLA
      ENDDO
C
      IPLB = 1
      DO II=1,ITGB
         DO JJ=1,NSYM
            LSBS(JJ,II) = IPLB
            IPLB = IPLB + LCOB(JJ,II)
         ENDDO
         LSBS(NSYM+1,II) = IPLB
      ENDDO
C
      DO II=1,ITGA
         ITOT = 1
         DO JJ=1,NSYM
            LWRK(JJ) = 0
         ENDDO
         DO JJ=1,NSPACE
            ITOT = ITOT * LANDET(JJ,II)
         ENDDO
         IDISA = NAST(II)
         DO KK=1,ITOT
            JSYM = LSYMA(IDISA+KK)
            LWRK(JSYM) = LWRK(JSYM)+1
            LSAC(LSAS(JSYM,II)+LWRK(JSYM)-1) = KK
         ENDDO
      ENDDO
C
      DO II=1,ITGB
         ITOT = 1
         DO JJ=1,NSYM
            LWRK(JJ) = 0
         ENDDO
         DO JJ=1,NSPACE
            ITOT = ITOT * LBNDET(JJ,II)
         ENDDO
         IDISB = NBST(II)
         DO KK=1,ITOT
            JSYM = LSYMB(IDISB+KK)
            LWRK(JSYM) = LWRK(JSYM)+1
            LSBC(LSBS(JSYM,II)+LWRK(JSYM)-1) = KK
         ENDDO
      ENDDO
C
C       This code generates ORMAS arrays that reflect C1 symmetry
C
      IF(NDER.EQ.2 .AND. IDSYM.GT.0) THEN
        CALL GTAB(1,1,KTAB,LWRK(1),LWRK(4),LWRK(7),LWRK(10))
        CALL GMUL(1,LGMUL,LWRK(1),LWRK(4),LWRK(7),LWRK(10))
C
        DO II=1,ITGA
           DO JJ=1,NSYM
              LCOA(JJ,II) = 0
           ENDDO
        ENDDO
C
        CALL RESETCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX2)
        ICOUNT = 0
        DO II=1,ITGB
          DO JJ=1,NSYM
             LCOB(JJ,II) = 0
          ENDDO
C
          CALL RESETDE(LBOX1,NSPACE,NB,MSTA,LCON)
C
          ITOT = 1
          DO JJ=1,NSPACE
            ITOT = ITOT * LBNDET(JJ,II)
          ENDDO
C
          DO KK=1,ITOT
            ICOUNT = ICOUNT + 1
            LSYMB(ICOUNT) = 1
            LCOB(1,II) = LCOB(1,II) + 1
            LSPB(ICOUNT) = LCOB(1,II)
C
            CALL MOVEUP2(LBOX1,NSPACE,NB,MSTA,LCON)
          ENDDO
C
          CALL PUSHCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX2,IEND)
        ENDDO
C
        CALL RESETCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX2)
        ICOUNT = 0
        NCITMP = 0
        DO II=1,ITGA
          CALL RESETDE(LBOX1,NSPACE,NA,MSTA,LCON)
C
          ITOT = 1
          DO JJ=1,NSPACE
            ITOT = ITOT * LANDET(JJ,II)
          ENDDO
C
          DO KK=1,ITOT
            ICOUNT = ICOUNT + 1
            LSYMA(ICOUNT) = 1
            LCOA(1,II) = LCOA(1,II) + 1
            LSPA(ICOUNT) = NCITMP
            DO 350 LL=1,ITGB
              IF(LGCOM(LL,II).EQ.0) GO TO 350
              NCITMP = NCITMP + LCOB(1,LL)
  350       CONTINUE
C
            CALL MOVEUP2(LBOX1,NSPACE,NA,MSTA,LCON)
          ENDDO
C
          DO KK=1,NSYM
             LWRK(KK) = 0
          ENDDO
          DO 400 JJ=1,ITGB
            DO KK=1,NSYM
              LDISB(KK,JJ,II) = 0
            ENDDO
            IF (LGCOM(JJ,II).EQ.0) GO TO 400
            LDISB(1,JJ,II) = LWRK(1)
            LWRK(1) = LWRK(1) + LCOB(1,JJ)
  400     CONTINUE
C
          CALL PUSHCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX2,IEND)
        ENDDO
C
        IPLA = 1
        DO II=1,ITGA
          DO JJ=1,NSYM
            LSAS(JJ,II) = 0
          ENDDO
          LSAS(1,II) = IPLA
          IPLA = IPLA + LCOA(1,II)
          LSAS(2,II) = IPLA
        ENDDO
C
        IPLB = 1
        DO II=1,ITGB
          DO JJ=1,NSYM
            LSBS(JJ,II) = 0
          ENDDO
          LSBS(1,II) = IPLB
          IPLB = IPLB + LCOB(1,II)
          LSBS(2,II) = IPLB
        ENDDO
C
        DO II=1,ITGA
          ITOT = 1
          DO JJ=1,NSYM
            LWRK(JJ) = 0
          ENDDO
          DO JJ=1,NSPACE
            ITOT = ITOT * LANDET(JJ,II)
          ENDDO
          IDISA = NAST(II)
          DO KK=1,ITOT
            JSYM = LSYMA(IDISA+KK)
            LWRK(JSYM) = LWRK(JSYM)+1
            LSAC(LSAS(JSYM,II)+LWRK(JSYM)-1) = KK
          ENDDO
        ENDDO
C
        DO II=1,ITGB
          ITOT = 1
          DO JJ=1,NSYM
            LWRK(JJ) = 0
          ENDDO
          DO JJ=1,NSPACE
            ITOT = ITOT * LBNDET(JJ,II)
          ENDDO
          IDISB = NBST(II)
          DO KK=1,ITOT
            JSYM = LSYMB(IDISB+KK)
            LWRK(JSYM) = LWRK(JSYM)+1
            LSBC(LSBS(JSYM,II)+LWRK(JSYM)-1) = KK
          ENDDO
        ENDDO
C
        DO II=1,NACT
          IBO(II) = 1
        ENDDO
      ENDIF
C
C       End of new code
C
      NA1EX = 0
      NB1EX = ITGA
      IF (FDIRCT) RETURN
      NB1EX = 0
C
C ****************************************
C   DETERMINE TOTAL NUMBER OF SINGLE BETA EXCITATIONS
C   WHERE B' > B.
C ****************************************
C
C    LOOP THROUGH ALL BETA GROUPS
C
      CALL RESETCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX3)
C
      DO 1000 IIB = 1,ITGB
C
         CALL RESETDE(LBOX1,NSPACE,NB,MSTA,LCON)
C
         DO 900 KKB=NBST(IIB)+1,NBST(IIB+1)
            DO II=1,NSPACE
               LBOX2(II) = LBOX1(II)
            ENDDO
C
C  LOOP OVER ALL SINGLE EXCITATIONS, CHECKING TO SEE
C  IF IT IS VALID.
C
C  LOOP SPACES TO EXCITE ELECTRONS FROM.
C
            IEBS = NB+1
            DO 890 ISPB1=NSPACE,1,-1
               IOC1 = LBOX1(ISPB1)
               IEBE = IEBS - 1
               IEBS = IEBS - IOC1
               IF (IOC1.EQ.0) GO TO 890
               LBOX2(ISPB1) = LBOX2(ISPB1)-1
C
C  LOOP ELECTRONS IN SPACE ISPB1
C  IEBS, IEBE ARE THE ELECTRONS IN SPACE ISPB1
C
               DO 885 IB1=IEBE,IEBS,-1
                  IO1 = LCON(IB1)
C
                  IGBE = IEBE - LBOX1(ISPB1)
C
C  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
C
               DO 880 ISPB2=ISPB1,NSPACE
C
C  IGBS,IGBE ARE ELECTRONS SPECIFYING ISPB2 SPACE ELECTRON LIMITS.
C
                  IGBS = IGBE + 1
                  IGBE = IGBE + LBOX1(ISPB2)
C
                  LBOX2(ISPB2) = LBOX2(ISPB2) + 1
                  IF (LBOX2(ISPB1).LT.IBMI(ISPB1)) GO TO 870
                  IF (LBOX2(ISPB2).GT.IBMA(ISPB2)) GO TO 870
C
C  MAKE GAP INFORMATION HERE.
C
                  IGBA = MAX(IB1+1,IGBS)
                  IF (LBOX1(ISPB2).EQ.0) THEN
                     ISTA = MSTA(ISPB2)
                     IEND = MSTA(ISPB2+1)-1
                  ELSEIF (ISPB2.EQ.ISPB1) THEN
                     ISTA = IO1+1
                     IEND = LCON(IGBA)-1
                     IF (IB1.EQ.IEBE) IEND=MSTA(ISPB1+1)-1
                  ELSE
                     ISTA = MSTA(ISPB2)
                     IEND = LCON(IGBA)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 860 IGAP=IGBA,IGBE+1
C
                     DO 850 JJ=ISTA,IEND
C
                     NB1EX = NB1EX + 1
C
C  ****** ALL THE WORK HAS TO BE DONE IN HERE. *******
C
  850             CONTINUE
C
                  ISTA = LCON(IGAP)+1
                  IEND = LCON(IGAP+1)-1
                  IF (IGAP.EQ.IGBE) IEND=MSTA(ISPB2+1)-1
  860             CONTINUE
C
  870             LBOX2(ISPB2) = LBOX2(ISPB2) - 1
  880          CONTINUE
C
  885          CONTINUE
C
               LBOX2(ISPB1) = LBOX2(ISPB1) + 1
  890       CONTINUE
C
            CALL MOVEUP2(LBOX1,NSPACE,NB,MSTA,LCON)
  900    CONTINUE
C
         CALL PUSHCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX3,IEND)
C
 1000 CONTINUE
C
      RETURN
      END
C
C*MODULE CPMCHF  *DECK PCPSDR
      SUBROUTINE PCPSDR(BUFF,SDER,DLAG,DFC,DERI,FCOR,ERI,AMAT,OPDM,TPDM,
     *                  PRCNDO,IA,INDEX,NCOR,NACT,NXYZ,L0,L1,L2,N2,N4,
     *                  NROT,IW)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER         C_OOOO, C_VOOO, C_VVOO, C_VOVO
      LOGICAL         GOPARR, DSKWRK, MASWRK
      LOGICAL         IJVAL
C
      DIMENSION BUFF(*),SDER(NXYZ,L1,L1),DLAG(NXYZ,L1,L1),DFC(NXYZ,L2),
     *          DERI(NXYZ,N4),FCOR(L2),ERI(L1,NACT,N2),AMAT(L1,NCOR,N2),
     *          OPDM(*),TPDM(N4),PRCNDO(NROT)
      DIMENSION IA(*),INDEX(L1,L1)
C
      COMMON /DLBTIM/ C_OOOO,C_VOOO,C_VVOO,C_VOVO
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      INTEGER         D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB
      LOGICAL         NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
      COMMON /TRFDMS/ D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB,
     *                NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
C
      PARAMETER (ZERO=0.0D+00,HALF=0.5D+00,ONE=1.0D+00,TWO=2.0D+00)
      PARAMETER (FOUR=4.0D+00,TOL=1.0D-09)
C
      NOCC = NCOR+NACT
      NOTR = (NOCC*NOCC+NOCC)/2
      NVIR = L0 - NOCC
      NBVIR = L0 - NOCC
      NBTR = (NBVIR*NBVIR+NBVIR)/2
      NBSQ = NBVIR*NBVIR
      L3 = L1*L1
C
      CALL VCLR(PRCNDO,1,NROT)
C
      IP = 0
      CALL TSECND(T0)
      DO 8000 IP=0,NPROC-1
        IWP = MOD(ME+IP,NPROC)
C
C     ----- Get and use (OO|OO) integrals -----
C
        CALL DDI_DISTRIB(D_OOOO,IWP,ILO,IHI,JLO,JHI)
        MAXWRK = JHI-JLO+1
C
        CALL DDI_PROCDLB_NEXT(C_OOOO,IWP,ICNTR1)
C
        DO WHILE(ICNTR1.LT.MAXWRK)
          IJ = JLO + ICNTR1
C
          DO II=1,NOCC
            DO JJ=1,II
              IJTMP = IA(II) + JJ
              IF(IJTMP.EQ.IJ) THEN
                I = II
                J = JJ
                GO TO 10
              ENDIF
            ENDDO
          ENDDO
C
   10     CALL DDI_GET(D_OOOO,1,NOTR,IJ,IJ,BUFF)
C
C          ----- Derivative core Fock matrices -----
C
          DO 50 M=1,NOCC
            DO 50 IC=1,NCOR
              MG = MAX(M,IC)
              ICG = MIN(M,IC)
              MIC = IA(MG) + ICG
              XIJKL = BUFF(MIC)
              IF(ABS(XIJKL).LT.TOL) GO TO 50
              AVAL = TWO*XIJKL
              CALL DAXPY(NXYZ,-AVAL,SDER(1,M,IC),1,DFC(1,IJ),1)
C
              AVAL = HALF*XIJKL
              IF(M.GT.I) GO TO 20
              IM = IA(I) + M
              CALL DAXPY(NXYZ,AVAL,SDER(1,J,IC),1,DFC(1,IM),1)
C
   20         IF((I.EQ.J).OR.(M.GT.J)) GO TO 30
              JM = IA(J) + M
              CALL DAXPY(NXYZ,AVAL,SDER(1,I,IC),1,DFC(1,JM),1)
C
   30         IF(J.GT.M) GO TO 40
              MJ = IA(M) + J
              CALL DAXPY(NXYZ,AVAL,SDER(1,I,IC),1,DFC(1,MJ),1)
C
   40         IF((I.EQ.J).OR.(I.GT.M)) GO TO 50
              MI = IA(M) + I
              CALL DAXPY(NXYZ,AVAL,SDER(1,J,IC),1,DFC(1,MI),1)
   50     CONTINUE
C
C          ----- Derivative two-electron integrals -----
C
          IF((I.LE.NCOR).OR.(J.LE.NCOR)) GO TO 100
          II = I-NCOR
          JJ = J-NCOR
          IIJJ = IA(II) + JJ
          DO 90 K=NCOR+1,NOCC
            DO 90 L=1,NOCC
              KG = MAX(K,L)
              LG = MIN(K,L)
              KL = IA(KG) + LG
              XIJKL = BUFF(KL)
              IF(ABS(XIJKL).LT.TOL) GO TO 90
              XIJKL = HALF*XIJKL
              DO 80 M=NCOR+1,NOCC
                IF(K.GT.M) GO TO 70
                MK = IA(M-NCOR) + K-NCOR
                IF(IIJJ.LE.MK) THEN
                  MKIJ = IA(MK) + IIJJ
                  CALL DAXPY(NXYZ,-XIJKL,SDER(1,M,L),1,DERI(1,MKIJ),1)
                ENDIF
C
                IF(MK.LE.IIJJ) THEN
                  IJMK = IA(IIJJ) + MK
                  CALL DAXPY(NXYZ,-XIJKL,SDER(1,M,L),1,DERI(1,IJMK),1)
                ENDIF
C
   70           IF(M.GT.K) GO TO 80
C
                KM = IA(K-NCOR) + M-NCOR
                IF(IIJJ.LE.KM) THEN
                  KMIJ = IA(KM) + IIJJ
                  CALL DAXPY(NXYZ,-XIJKL,SDER(1,M,L),1,DERI(1,KMIJ),1)
                ENDIF
C
                IF(KM.LE.IIJJ) THEN
                  IJKM = IA(IIJJ) + KM
                  CALL DAXPY(NXYZ,-XIJKL,SDER(1,M,L),1,DERI(1,IJKM),1)
                ENDIF
   80         CONTINUE
   90     CONTINUE
C
C          ----- Construct core Fock matrix -----
C
  100     DVAL = ZERO
          DO IC=1,NCOR
            ICIC = IA(IC) + IC
            DVAL = DVAL + BUFF(ICIC)
          ENDDO
          FCOR(IJ) = FCOR(IJ) + TWO*DVAL
C
          IF(J.GT.NCOR) GO TO 110
          DO K=1,I
            IK = IA(I) + K
            JG = MAX(J,K)
            KG = MIN(J,K)
            JK = IA(JG) + KG
            FCOR(IK) = FCOR(IK) - BUFF(JK)
          ENDDO
C
  110     IF((I.GT.NCOR) .OR. (I.EQ.J)) GO TO 120
          DO K=1,J
            JK = IA(J) + K
            IG = MAX(I,K)
            KG = MIN(I,K)
            IK = IA(IG) + KG
            FCOR(JK) = FCOR(JK) - BUFF(IK)
          ENDDO
C
C          ----- Construct two-electron integral array -----
C
  120     IF(J.LE.NCOR) GO TO 140
          JJ = J-NCOR
          DO 130 K=1,NACT
            DO 130 L=1,K
              KL = IA(K) + L
              KKLL = IA(K+NCOR) + L+NCOR
              ERI(I,JJ,KL) = BUFF(KKLL)
  130     CONTINUE
C
  140     IF((I.LE.NCOR) .OR. (I.EQ.J)) GO TO 155
          II = I-NCOR
          DO 150 K=1,NACT
            DO 150 L=1,K
              KL = IA(K) + L
              KKLL = IA(K+NCOR) + L+NCOR
              ERI(J,II,KL) = BUFF(KKLL)
  150     CONTINUE
C
C          ----- Construct A matrix -----
C
  155     IF(J.GT.NCOR) GO TO 160
          DO K=1,NACT
            KK = K + NCOR
            DO 157 L=1,K
              LL = L + NCOR
              KL = IA(K) + L
              KKLL = IA(KK) + LL
              DVAL = FOUR*BUFF(KKLL)
              AMAT(I,J,KL) = AMAT(I,J,KL) + DVAL
              IF((I.EQ.J) .OR. (I.GT.NCOR)) GO TO 157
              AMAT(J,I,KL) = AMAT(J,I,KL) + DVAL
  157       CONTINUE
          ENDDO
C
  160     IF(J.LE.NCOR) GO TO 165
          JJ = J - NCOR
          DO 163 K=1,NCOR
            DO L=1,NACT
              LL = L +  NCOR
              KL = IA(LL) + K
              JG = MAX(JJ,L)
              LG = MIN(JJ,L)
              JL = IA(JG) + LG
              IF(JJ.GE.L) AMAT(I,K,JL) = AMAT(I,K,JL) - BUFF(KL)
              IF(L.GE.JJ) AMAT(I,K,JL) = AMAT(I,K,JL) - BUFF(KL)
            ENDDO
  163     CONTINUE
C
  165     IF((I.LE.NCOR) .OR. (I.EQ.J)) GO TO 169
          II = I - NCOR
          DO 167 K=1,NCOR
            DO L=1,NACT
              LL = L + NCOR
              KL = IA(LL) + K
              IG = MAX(II,L)
              LG = MIN(II,L)
              IL = IA(IG) + LG
              IF(II.GE.L) AMAT(J,K,IL) = AMAT(J,K,IL) - BUFF(KL)
              IF(L.GE.II) AMAT(J,K,IL) = AMAT(J,K,IL) - BUFF(KL)
            ENDDO
  167     CONTINUE
C
C          ----- Coulomb contribution to derivative Lagrangian -----
C          -----   Lder(i,m) where m is a core orbital index   -----
C
  169     CONTINUE
          DO 200 M=1,NCOR
C
            DVAL = ZERO
            DO K=1,NCOR
              KK = IA(K) + K
              DVAL = DVAL + BUFF(KK)
            ENDDO
            DVAL = TWO*DVAL
            DO 170 K=1,NACT
              DO 170 L=1,K
                KL = IA(K) + L
                DTMP = OPDM(KL)
                IF(K.NE.L) DTMP = TWO*DTMP
                KL = IA(K+NCOR) + L+NCOR
                DVAL = DVAL + DTMP*BUFF(KL)
  170       CONTINUE
            CALL DAXPY(NXYZ,-DVAL,SDER(1,I,M),1,DLAG(1,J,M),1)
            IF(I.NE.J)
     *        CALL DAXPY(NXYZ,-DVAL,SDER(1,J,M),1,DLAG(1,I,M),1)
C
            DO 180 K=1,NCOR
              MG = MAX(M,K)
              KG = MIN(M,K)
              MK = IA(MG) + KG
              DVAL = BUFF(MK)
              IF(ABS(DVAL).LT.TOL) GO TO 180
              CALL DAXPY(NXYZ,DVAL,SDER(1,I,K),1,DLAG(1,J,M),1)
              IF(I.NE.J)
     *          CALL DAXPY(NXYZ,DVAL,SDER(1,J,K),1,DLAG(1,I,M),1)
  180       CONTINUE
C
            DO 190 K=1,NACT
              KK = K + NCOR
              DVAL = ZERO
              DO L=1,NACT
                KG = MAX(K,L)
                LG = MIN(K,L)
                KL = IA(KG) + LG
                DTMP = OPDM(KL)
                ML = IA(L+NCOR) + M
                DVAL = DVAL + DTMP*BUFF(ML)
              ENDDO
              DVAL = HALF*DVAL
              CALL DAXPY(NXYZ,DVAL,SDER(1,I,KK),1,DLAG(1,J,M),1)
              IF(I.NE.J)
     *          CALL DAXPY(NXYZ,DVAL,SDER(1,J,KK),1,DLAG(1,I,M),1)
  190       CONTINUE
  200     CONTINUE
C
C          ----- Coulomb contribution to derivative Lagrangian -----
C          ----- Lder(i,m) where m is an active orbital index  -----
C
          DO 300 M=1,NACT
            MM = M + NCOR
C
            DO 220 N=1,NCOR
              DVAL = ZERO
              DO K=1,NACT
                MG = MAX(M,K)
                KG = MIN(M,K)
                MK = IA(MG) + KG
                DTMP = OPDM(MK)
                KN = IA(K+NCOR) + N
                DVAL = DVAL + DTMP*BUFF(KN)
              ENDDO
              DVAL = HALF*DVAL
              CALL DAXPY(NXYZ,DVAL,SDER(1,I,N),1,DLAG(1,J,MM),1)
              IF(I.NE.J)
     *          CALL DAXPY(NXYZ,DVAL,SDER(1,J,N),1,DLAG(1,I,MM),1)
  220       CONTINUE
C
            DO 260 N=1,NACT
              DVAL = ZERO
              NG = MAX(N,M)
              MG = MIN(N,M)
              NM = IA(NG) + MG
              DO K=1,NCOR
                KK = IA(K) + K
                DVAL = DVAL + BUFF(KK)
              ENDDO
              DVAL = OPDM(NM)*DVAL
              DVAL = TWO*DVAL
C
              DO 240 K=1,NACT
                DO 240 L=1,K
                  KL = IA(K+NCOR) + L+NCOR
                  DTMP = BUFF(KL)
                  IF(K.NE.L) DTMP = TWO*DTMP
                  KL = IA(K) + L
                  NMG = MAX(NM,KL)
                  KLG = MIN(NM,KL)
                  NMKL = IA(NMG) + KLG
                  DVAL = DVAL + DTMP*TPDM(NMKL)
  240         CONTINUE
              DVAL = HALF*DVAL
              CALL DAXPY(NXYZ,-DVAL,SDER(1,I,N+NCOR),1,DLAG(1,J,MM),1)
              IF(I.NE.J)
     *          CALL DAXPY(NXYZ,-DVAL,SDER(1,J,N+NCOR),1,DLAG(1,I,MM),1)
  260       CONTINUE
  300     CONTINUE
C
C          ----- Exchange contribution to derivative Lagrangian -----
C
          DO 400 M=1,NOCC
            IF(J.GT.NCOR) GO TO 350
            IJVAL = .TRUE.
            IF((I.EQ.J) .OR. (I.GT.NCOR)) IJVAL = .FALSE.
            DO 330 N=1,NCOR
              MG = MAX(M,J)
              JG = MIN(M,J)
              MJ = IA(MG) + JG
              XIJKL = BUFF(MJ)
              CALL DAXPY(NXYZ,XIJKL,SDER(1,I,N),1,DLAG(1,M,N),1)
              IF(IJVAL) THEN
                MG = MAX(M,I)
                IG = MIN(M,I)
                MI = IA(MG) + IG
                XIJKL = BUFF(MI)
                CALL DAXPY(NXYZ,XIJKL,SDER(1,J,N),1,DLAG(1,M,N),1)
              ENDIF
C
              MG = MAX(M,N)
              NG = MIN(M,N)
              MN = IA(MG) + NG
              XIJKL = BUFF(MN)
              DVAL = FOUR*XIJKL
              CALL DAXPY(NXYZ,-DVAL,SDER(1,I,J),1,DLAG(1,M,N),1)
              IF(IJVAL) CALL DAXPY(NXYZ,-DVAL,SDER(1,J,I),1,
     *                             DLAG(1,M,N),1)
C
              IF(N.EQ.J) THEN
                DO K=1,NCOR
                  MG = MAX(M,K)
                  KG = MIN(M,K)
                  MK = IA(MG) + KG
                  XIJKL = BUFF(MK)
                  CALL DAXPY(NXYZ,XIJKL,SDER(1,I,K),1,DLAG(1,M,N),1)
                ENDDO
C
                DO 310 K=1,NACT
                  DO 310 L=1,NACT
                    KG = MAX(K,L)
                    LG = MIN(K,L)
                    KL = IA(KG) + LG
                    MG = MAX(M,L+NCOR)
                    LG = MIN(M,L+NCOR)
                    ML = IA(MG) + LG
                    DVAL = OPDM(KL)*BUFF(ML)
                    DVAL = HALF*DVAL
                    CALL DAXPY(NXYZ,DVAL,SDER(1,I,K+NCOR),1,
     *                         DLAG(1,M,N),1)
  310           CONTINUE
              ENDIF
C
              IF((N.EQ.I) .AND. (I.NE.J)) THEN
                DO K=1,NCOR
                  MG = MAX(M,K)
                  KG = MIN(M,K)
                  MK = IA(MG) + KG
                  XIJKL = BUFF(MK)
                  CALL DAXPY(NXYZ,XIJKL,SDER(1,J,K),1,DLAG(1,M,N),1)
                ENDDO
C
                DO 320 K=1,NACT
                  DO 320 L=1,NACT
                    KG = MAX(K,L)
                    LG = MIN(K,L)
                    KL = IA(KG) + LG
                    MG = MAX(M,L+NCOR)
                    LG = MIN(M,L+NCOR)
                    ML = IA(MG) + LG
                    DVAL = OPDM(KL)*BUFF(ML)
                    DVAL = HALF*DVAL
                    CALL DAXPY(NXYZ,DVAL,SDER(1,J,K+NCOR),1,
     *                         DLAG(1,M,N),1)
  320           CONTINUE
              ENDIF
  330       CONTINUE
C
            MG = MAX(M,J)
            JG = MIN(M,J)
            MJ = IA(MG) + JG
            IF(IJVAL) THEN
              MG = MAX(M,I)
              IG = MIN(M,I)
              MI = IA(MG) + IG
            ENDIF
            DO 340 N=1,NACT
              DO K=1,NACT
                NG = MAX(N,K)
                KG = MIN(N,K)
                NK = IA(NG) + KG
                MG = MAX(M,K+NCOR)
                KG = MIN(M,K+NCOR)
                MK = IA(MG) + KG
                DVAL = OPDM(NK)*BUFF(MK)
                DVAL = TWO*DVAL
                CALL DAXPY(NXYZ,-DVAL,SDER(1,I,J),1,DLAG(1,M,N+NCOR),1)
                IF(IJVAL) CALL DAXPY(NXYZ,-DVAL,SDER(1,J,I),1,
     *                               DLAG(1,M,N+NCOR),1)
C
                DVAL = OPDM(NK)*BUFF(MJ)
                DVAL = HALF*DVAL
                CALL DAXPY(NXYZ,DVAL,SDER(1,I,K+NCOR),1,
     *                     DLAG(1,M,N+NCOR),1)
                IF(IJVAL) THEN
                  DVAL = OPDM(NK)*BUFF(MI)
                  DVAL = HALF*DVAL
                  CALL DAXPY(NXYZ,DVAL,SDER(1,J,K+NCOR),1,
     *                       DLAG(1,M,N+NCOR),1)
                ENDIF
              ENDDO
  340       CONTINUE
C
  350       IF(I.LE.NCOR) GO TO 400
            IJVAL = .TRUE.
            IF((I.EQ.J) .OR. (J.LE.NCOR)) IJVAL = .FALSE.
            DO 360 N=1,NCOR
              MG = MAX(M,N)
              NG = MIN(M,N)
              MN = IA(MG) + NG
              DO K=1,NACT
                KG = MAX(K,I-NCOR)
                IG = MIN(K,I-NCOR)
                KI = IA(KG) + IG
                DVAL = OPDM(KI)*BUFF(MN)
                DVAL = TWO*DVAL
                CALL DAXPY(NXYZ,-DVAL,SDER(1,J,K+NCOR),1,DLAG(1,M,N),1)
                IF(IJVAL) THEN
                  KG = MAX(K,J-NCOR)
                  JG = MIN(K,J-NCOR)
                  KJ = IA(KG) + JG
                  DVAL = OPDM(KJ)*BUFF(MN)
                  DVAL = TWO*DVAL
                  CALL DAXPY(NXYZ,-DVAL,SDER(1,I,K+NCOR),1,
     *                       DLAG(1,M,N),1)
                ENDIF
C
                MG = MAX(M,K+NCOR)
                KG = MIN(M,K+NCOR)
                MK = IA(MG) + KG
                DVAL = OPDM(KI)*BUFF(MK)
                DVAL = HALF*DVAL
                CALL DAXPY(NXYZ,DVAL,SDER(1,J,N),1,DLAG(1,M,N),1)
                IF(IJVAL) THEN
                  DVAL = OPDM(KJ)*BUFF(MK)
                  DVAL = HALF*DVAL
                  CALL DAXPY(NXYZ,DVAL,SDER(1,I,N),1,DLAG(1,M,N),1)
                ENDIF
              ENDDO
  360       CONTINUE
C
            DO 390 N=1,NACT
              IG = MAX(I-NCOR,N)
              NG = MIN(I-NCOR,N)
              IN = IA(IG) + NG
              IF(IJVAL) THEN
                JG = MAX(J-NCOR,N)
                NG = MIN(J-NCOR,N)
                JN = IA(JG) + NG
              ENDIF
              DO K=1,NCOR
                MG = MAX(M,K)
                KG = MIN(M,K)
                MK = IA(MG) + KG
                DVAL = OPDM(IN)*BUFF(MK)
                DVAL = HALF*DVAL
                CALL DAXPY(NXYZ,DVAL,SDER(1,J,K),1,DLAG(1,M,N+NCOR),1)
                IF(IJVAL) THEN
                  DVAL = OPDM(JN)*BUFF(MK)
                  DVAL = HALF*DVAL
                  CALL DAXPY(NXYZ,DVAL,SDER(1,I,K),1,DLAG(1,M,N+NCOR),1)
                ENDIF
              ENDDO
C
              DO 370 K=1,NACT
                KG = MAX(K,I-NCOR)
                IG = MIN(K,I-NCOR)
                KI = IA(KG) + IG
                IF(IJVAL) THEN
                  KG = MAX(K,J-NCOR)
                  JG = MIN(K,J-NCOR)
                  KJ = IA(KG) + JG
                ENDIF
                DO 370 L=1,NACT
                  MG = MAX(M,L+NCOR)
                  LG = MIN(M,L+NCOR)
                  ML = IA(MG) + LG
                  NG = MAX(N,L)
                  LG = MIN(N,L)
                  NL = IA(NG) + LG
                  KIG = MAX(KI,NL)
                  NLG = MIN(KI,NL)
                  KINL = IA(KIG) + NLG
                  DVAL = TPDM(KINL)*BUFF(ML)
                  CALL DAXPY(NXYZ,-DVAL,SDER(1,J,K+NCOR),1,
     *                       DLAG(1,M,N+NCOR),1)
                  IF(IJVAL) THEN
                    KJG = MAX(KJ,NL)
                    NLG = MIN(KJ,NL)
                    KJNL = IA(KJG) + NLG
                    DVAL = TPDM(KJNL)*BUFF(ML)
                    CALL DAXPY(NXYZ,-DVAL,SDER(1,I,K+NCOR),1,
     *                         DLAG(1,M,N+NCOR),1)
                  ENDIF
  370         CONTINUE
  390       CONTINUE
  400     CONTINUE
C
C          ----- Coulomb contribution to preconditioner -----
C          -----      Inner indicies are both core      -----
C
           DO 440 N=1,NCOR
             JNG = IABS(INDEX(J,N))
             IF(JNG.EQ.0) GO TO 440
             DO 430 M=1,NCOR
               IMG = IABS(INDEX(I,M))
               IF(IMG.NE.JNG) GO TO 430
               MG = MAX(M,N)
               NG = MIN(M,N)
               MN = IA(MG) + NG
C
               DVAL = ZERO
               IF(M.EQ.N) THEN
                 DO K=1,NCOR
                   KK = IA(K) + K
                   DVAL = DVAL + BUFF(KK)
                 ENDDO
                 DVAL = TWO*DVAL
C
                 DO 420 K=1,NACT
                   DO 420 L=1,K
                     KL = IA(K+NCOR) + L+NCOR
                     XIJKL = BUFF(KL)
                     IF(K.NE.L) XIJKL = TWO*XIJKL
                     KL = IA(K) + L
                     DVAL = DVAL + OPDM(KL)*XIJKL
  420            CONTINUE
               ENDIF
C
               DVAL = DVAL - BUFF(MN)
               DVAL = TWO*DVAL
               IF(N.GT.J) DVAL = -DVAL
               IF(M.GT.I) DVAL = -DVAL
               PRCNDO(IMG) = PRCNDO(IMG) + DVAL
  430        CONTINUE
  440      CONTINUE
           IF(I.EQ.J) GO TO 480
C
           DO 470 N=1,NCOR
             ING = IABS(INDEX(I,N))
             IF(ING.EQ.0) GO TO 470
             DO 460 M=1,NCOR
               JMG = IABS(INDEX(J,M))
               IF(JMG.NE.ING) GO TO 460
               MG = MAX(M,N)
               NG = MIN(M,N)
               MN = IA(MG) + NG
C
               DVAL = ZERO
               IF(M.EQ.N) THEN
                 DO K=1,NCOR
                   KK = IA(K) + K
                   DVAL = DVAL + BUFF(KK)
                 ENDDO
                 DVAL = TWO*DVAL
C
                 DO 450 K=1,NACT
                   DO 450 L=1,K
                     KL = IA(K+NCOR) + L+NCOR
                     XIJKL = BUFF(KL)
                     IF(K.NE.L) XIJKL = TWO*XIJKL
                     KL = IA(K) + L
                     DVAL = DVAL + OPDM(KL)*XIJKL
  450            CONTINUE
               ENDIF
C
               DVAL = DVAL - BUFF(MN)
               DVAL = TWO*DVAL
               IF(N.GT.I) DVAL = -DVAL
               IF(M.GT.J) DVAL = -DVAL
               PRCNDO(JMG) = PRCNDO(JMG) + DVAL
  460        CONTINUE
  470      CONTINUE
C
C          ----- Coulomb contribution to preconditioner -----
C          -----    One core index, one active index    -----
C
  480      CONTINUE
           DO 540 N=1,NCOR
             JNG = IABS(INDEX(J,N))
             IF(JNG.EQ.0) GO TO 510
             DO 500 M=1,NACT
               IMG = IABS(INDEX(I,M+NCOR))
               IF(IMG.NE.JNG) GO TO 500
               DO K=1,NACT
                 KN = IA(K+NCOR) + N
                 XIJKL = BUFF(KN)
                 KG = MAX(K,M)
                 MG = MIN(K,M)
                 KM = IA(KG) + MG
                 IF(N.GT.J) XIJKL = -XIJKL
                 IF((M+NCOR).GT.I) XIJKL = -XIJKL
                 IF(I.NE.J) XIJKL = TWO*XIJKL
                 PRCNDO(IMG) = PRCNDO(IMG) - OPDM(KM)*XIJKL
               ENDDO
  500        CONTINUE
C
  510        ING = IABS(INDEX(I,N))
             IF(ING.EQ.0) GO TO 540
             DO 520 M=1,NACT
               JMG = IABS(INDEX(J,M+NCOR))
               IF(JMG.NE.ING) GO TO 520
               DO K=1,NACT
                 KN = IA(K+NCOR) + N
                 XIJKL = BUFF(KN)
                 KG = MAX(K,M)
                 MG = MIN(K,M)
                 KM = IA(KG) + MG
                 IF(N.GT.I) XIJKL = -XIJKL
                 IF((M+NCOR).GT.J) XIJKL = -XIJKL
                 IF(I.NE.J) XIJKL = TWO*XIJKL
                 PRCNDO(JMG) = PRCNDO(JMG) - OPDM(KM)*XIJKL
               ENDDO
  520        CONTINUE
  540      CONTINUE
C
C          ----- Coulomb contribution to preconditioner -----
C          -----     Inner indicies are both active     -----
C
           DO 580 N=1,NACT
             JNG = IABS(INDEX(J,N+NCOR))
             IF(JNG.EQ.0) GO TO 580
             DO 570 M=1,NACT
               IMG = IABS(INDEX(I,M+NCOR))
               IF(IMG.NE.JNG) GO TO 570
               MG = MAX(M,N)
               NG = MIN(M,N)
               MN = IA(MG) + NG
C
               DVAL = ZERO
               DO K=1,NCOR
                 KK = IA(K) + K
                 DVAL = DVAL + BUFF(KK)
               ENDDO
               DVAL = TWO*DVAL
               DVAL = OPDM(MN)*DVAL
C
               DO 560 K=1,NACT
                 DO 560 L=1,K
                   KL = IA(K+NCOR) + L+NCOR
                   XIJKL = BUFF(KL)
                   IF(ABS(XIJKL).LT.TOL) GO TO 560
                   IF(K.NE.L) XIJKL = TWO*XIJKL
                   KL = IA(K) + L
                   MNG = MAX(MN,KL)
                   KLG = MIN(MN,KL)
                   MNKL = IA(MNG) + KLG
                   DVAL = DVAL + TPDM(MNKL)*XIJKL
  560          CONTINUE
C
               IF((N+NCOR).GT.J) DVAL = -DVAL
               IF((M+NCOR).GT.I) DVAL = -DVAL
               PRCNDO(IMG) = PRCNDO(IMG) + DVAL
  570        CONTINUE
  580      CONTINUE
           IF(I.EQ.J) GO TO 650
C
           DO 640 N=1,NACT
             ING = IABS(INDEX(I,N+NCOR))
             IF(ING.EQ.0) GO TO 640
             DO 630 M=1,NACT
               JMG = IABS(INDEX(J,M+NCOR))
               IF(JMG.NE.ING) GO TO 630
               MG = MAX(M,N)
               NG = MIN(M,N)
               MN = IA(MG) + NG
C
               DVAL = ZERO
               DO K=1,NCOR
                 KK = IA(K) + K
                 DVAL = DVAL + BUFF(KK)
               ENDDO
               DVAL = TWO*DVAL
               DVAL = OPDM(MN)*DVAL
C
               DO 620 K=1,NACT
                 DO 620 L=1,K
                   KL = IA(K+NCOR) + L+NCOR
                   XIJKL = BUFF(KL)
                   IF(ABS(XIJKL).LT.TOL) GO TO 620
                   IF(K.NE.L) XIJKL = TWO*XIJKL
                   KL = IA(K) + L
                   MNG = MAX(MN,KL)
                   KLG = MIN(MN,KL)
                   MNKL = IA(MNG) + KLG
                   DVAL = DVAL + TPDM(MNKL)*XIJKL
  620          CONTINUE
C
               IF((N+NCOR).GT.I) DVAL = -DVAL
               IF((M+NCOR).GT.J) DVAL = -DVAL
               PRCNDO(JMG) = PRCNDO(JMG) + DVAL
  630        CONTINUE
  640      CONTINUE
C
C          ----- Exchange contribution to preconditioner -----
C          -----           Second index is core          -----
C
  650     IF(J.GT.NCOR) GO TO 850
          DO 740 K=1,NOCC
            DO 690 L=1,NCOR
              KG = MAX(K,L)
              LG = MIN(K,L)
              KL = IA(KG) + LG
              XIJKL = BUFF(KL)
              IF(ABS(XIJKL).LT.TOL) GO TO 690
C
              IMG = IABS(INDEX(I,J))
              KNG = IABS(INDEX(K,L))
              IF((IMG.EQ.KNG) .AND. (IMG.NE.0)) THEN
                DVAL = TWO*XIJKL
                IF(J.GT.I) DVAL = -DVAL
                IF(L.GT.K) DVAL = -DVAL
                PRCNDO(IMG) = PRCNDO(IMG) + FOUR*DVAL
              ENDIF
C
              IMG = IABS(INDEX(I,L))
              KNG = IABS(INDEX(K,J))
              IF((IMG.EQ.KNG) .AND. (IMG.NE.0)) THEN
                DVAL = TWO*XIJKL
                IF(L.GT.I) DVAL = -DVAL
                IF(J.GT.K) DVAL = -DVAL
                PRCNDO(IMG) = PRCNDO(IMG) - DVAL
              ENDIF
C
              IF(J.EQ.L) THEN
                DO 660 M=1,NCOR
                  IMG = IABS(INDEX(I,M))
                  KMG = IABS(INDEX(K,M))
                  IF((IMG.NE.KMG) .OR. (IMG.EQ.0)) GO TO 660
                  DVAL = TWO*XIJKL
                  IF(M.GT.I) DVAL = -DVAL
                  IF(M.GT.K) DVAL = -DVAL
                  PRCNDO(IMG) = PRCNDO(IMG) - DVAL
  660           CONTINUE
C
                DO 680 M=1,NACT
                  IMG = IABS(INDEX(I,M+NCOR))
                  IF(IMG.EQ.0) GO TO 680
                  DO 670 N=1,NACT
                    KNG = IABS(INDEX(K,N+NCOR))
                    IF(IMG.NE.KNG) GO TO 670
                    MG = MAX(M,N)
                    NG = MIN(M,N)
                    MN = IA(MG) + NG
                    DVAL = OPDM(MN)*XIJKL
                    IF((M+NCOR).GT.I) DVAL = -DVAL
                    IF((N+NCOR).GT.K) DVAL = -DVAL
                    PRCNDO(IMG) = PRCNDO(IMG) - DVAL
  670             CONTINUE
  680           CONTINUE
              ENDIF
  690       CONTINUE
C
            DO 730 L=1,NACT
              KG = MAX(K,L+NCOR)
              LG = MIN(K,L+NCOR)
              KL = IA(KG) + LG
              XIJKL = BUFF(KL)
              IF(ABS(XIJKL).LT.TOL) GO TO 730
C
              IMG = IABS(INDEX(I,J))
              IF(IMG.NE.0) THEN
                DO 710 N=1,NACT
                  KNG = IABS(INDEX(K,N+NCOR))
                  IF(IMG.NE.KNG) GO TO 710
                  LG = MAX(L,N)
                  NG = MIN(L,N)
                  LN = IA(LG) + NG
                  DVAL = OPDM(LN)*XIJKL
                  IF(J.GT.I) DVAL = -DVAL
                  IF((N+NCOR).GT.K) DVAL = -DVAL
                  PRCNDO(IMG) = PRCNDO(IMG) + FOUR*DVAL
  710           CONTINUE
              ENDIF
C
              KNG = IABS(INDEX(K,J))
              IF(KNG.NE.0) THEN
                DO 720 M=1,NACT
                  IMG = IABS(INDEX(I,M+NCOR))
                  IF(IMG.NE.KNG) GO TO 720
                  LG = MAX(L,M)
                  MG = MIN(L,M)
                  LM = IA(LG) + MG
                  DVAL = OPDM(LM)*XIJKL
                  IF(J.GT.K) DVAL = -DVAL
                  IF((M+NCOR).GT.I) DVAL = -DVAL
                  PRCNDO(IMG) = PRCNDO(IMG) - DVAL
  720           CONTINUE
              ENDIF
  730       CONTINUE
  740     CONTINUE
C
          IF((I.EQ.J) .OR. (I.GT.NCOR)) GO TO 850
          DO 840 K=1,NOCC
            DO 790 L=1,NCOR
              KG = MAX(K,L)
              LG = MIN(K,L)
              KL = IA(KG) + LG
              XIJKL = BUFF(KL)
              IF(ABS(XIJKL).LT.TOL) GO TO 790
C
              JMG = IABS(INDEX(J,I))
              KNG = IABS(INDEX(K,L))
              IF((JMG.EQ.KNG) .AND. (JMG.NE.0)) THEN
                DVAL = TWO*XIJKL
                IF(I.GT.J) DVAL = -DVAL
                IF(L.GT.K) DVAL = -DVAL
                PRCNDO(JMG) = PRCNDO(JMG) + FOUR*DVAL
              ENDIF
C
              JMG = IABS(INDEX(J,L))
              KNG = IABS(INDEX(K,I))
              IF((JMG.EQ.KNG) .AND. (JMG.NE.0)) THEN
                DVAL = TWO*XIJKL
                IF(L.GT.J) DVAL = -DVAL
                IF(I.GT.K) DVAL = -DVAL
                PRCNDO(JMG) = PRCNDO(JMG) - DVAL
              ENDIF
C
              IF(I.EQ.L) THEN
                DO 760 M=1,NCOR
                  JMG = IABS(INDEX(J,M))
                  KMG = IABS(INDEX(K,M))
                  IF((JMG.NE.KMG) .OR. (JMG.EQ.0)) GO TO 760
                  DVAL = TWO*XIJKL
                  IF(M.GT.J) DVAL = -DVAL
                  IF(M.GT.K) DVAL = -DVAL
                  PRCNDO(JMG) = PRCNDO(JMG) - DVAL
  760           CONTINUE
C
                DO 780 M=1,NACT
                  JMG = IABS(INDEX(J,M+NCOR))
                  IF(JMG.EQ.0) GO TO 780
                  DO 770 N=1,NACT
                    KNG = IABS(INDEX(K,N+NCOR))
                    IF(JMG.NE.KNG) GO TO 770
                    MG = MAX(M,N)
                    NG = MIN(M,N)
                    MN = IA(MG) + NG
                    DVAL = OPDM(MN)*XIJKL
                    IF((M+NCOR).GT.J) DVAL = -DVAL
                    IF((N+NCOR).GT.K) DVAL = -DVAL
                    PRCNDO(JMG) = PRCNDO(JMG) - DVAL
  770             CONTINUE
  780           CONTINUE
              ENDIF
  790       CONTINUE
C
            DO 830 L=1,NACT
              KG = MAX(K,L+NCOR)
              LG = MIN(K,L+NCOR)
              KL = IA(KG) + LG
              XIJKL = BUFF(KL)
              IF(ABS(XIJKL).LT.TOL) GO TO 830
C
              JMG = IABS(INDEX(J,I))
              IF(JMG.NE.0) THEN
                DO 810 N=1,NACT
                  KNG = IABS(INDEX(K,N+NCOR))
                  IF(JMG.NE.KNG) GO TO 810
                  LG = MAX(L,N)
                  NG = MIN(L,N)
                  LN = IA(LG) + NG
                  DVAL = OPDM(LN)*XIJKL
                  IF(I.GT.J) DVAL = -DVAL
                  IF((N+NCOR).GT.K) DVAL = -DVAL
                  PRCNDO(JMG) = PRCNDO(JMG) + FOUR*DVAL
  810           CONTINUE
              ENDIF
C
              KNG = IABS(INDEX(K,I))
              IF(KNG.NE.0) THEN
                DO 820 M=1,NACT
                  JMG = IABS(INDEX(J,M+NCOR))
                  IF(JMG.NE.KNG) GO TO 820
                  LG = MAX(L,M)
                  MG = MIN(L,M)
                  LM = IA(LG) + MG
                  DVAL = OPDM(LM)*XIJKL
                  IF(I.GT.K) DVAL = -DVAL
                  IF((M+NCOR).GT.J) DVAL = -DVAL
                  PRCNDO(JMG) = PRCNDO(JMG) - DVAL
  820           CONTINUE
              ENDIF
  830       CONTINUE
  840     CONTINUE
C
C          ----- Exchange contribution to preconditioner -----
C          -----         Second index is valence         -----
C
  850     IF(I.LE.NCOR) GO TO 1000
          DO 990 K=1,NOCC
            DO 910 L=1,NCOR
              KG = MAX(K,L)
              LG = MIN(K,L)
              KL = IA(KG) + LG
              XIJKL = BUFF(KL)
              IF(ABS(XIJKL).LT.TOL) GO TO 910
C
              IF(J.LE.NCOR) GO TO 880
              IMG = IABS(INDEX(I,L))
              IF(IMG.NE.0) THEN
                DO 860 N=1,NACT
                  KNG = IABS(INDEX(K,N+NCOR))
                  IF(IMG.NE.KNG) GO TO 860
                  NG = MAX(N,J-NCOR)
                  JG = MIN(N,J-NCOR)
                  NJ = IA(NG) + JG
                  DVAL = OPDM(NJ)*XIJKL
                  IF(L.GT.I) DVAL = -DVAL
                  IF((N+NCOR).GT.K) DVAL = -DVAL
                  PRCNDO(IMG) = PRCNDO(IMG) - DVAL
  860           CONTINUE
              ENDIF
C
              KNG = IABS(INDEX(K,L))
              IF(KNG.NE.0) THEN
                DO 870 M=1,NACT
                  IMG = IABS(INDEX(I,M+NCOR))
                  IF(IMG.NE.KNG) GO TO 870
                  MG = MAX(M,J-NCOR)
                  JG = MIN(M,J-NCOR)
                  MJ = IA(MG) + JG
                  DVAL = OPDM(MJ)*XIJKL
                  IF(L.GT.K) DVAL = -DVAL
                  IF((M+NCOR).GT.I) DVAL = -DVAL
                  PRCNDO(IMG) = PRCNDO(IMG) + FOUR*DVAL
  870           CONTINUE
              ENDIF
C
  880         IF(I.EQ.J) GO TO 910
              JMG = IABS(INDEX(J,L))
              IF(JMG.NE.0) THEN
                DO 890 N=1,NACT
                  KNG = IABS(INDEX(K,N+NCOR))
                  IF(JMG.NE.KNG) GO TO 890
                  NG = MAX(N,I-NCOR)
                  IG = MIN(N,I-NCOR)
                  NI = IA(NG) + IG
                  DVAL = OPDM(NI)*XIJKL
                  IF(L.GT.J) DVAL = -DVAL
                  IF((N+NCOR).GT.K) DVAL = -DVAL
                  PRCNDO(JMG) = PRCNDO(JMG) - DVAL
  890           CONTINUE
              ENDIF
C
              KNG = IABS(INDEX(K,L))
              IF(KNG.NE.0) THEN
                DO 900 M=1,NACT
                  JMG = IABS(INDEX(J,M+NCOR))
                  IF(JMG.NE.KNG) GO TO 900
                  MG = MAX(M,I-NCOR)
                  IG = MIN(M,I-NCOR)
                  MI = IA(MG) + IG
                  DVAL = OPDM(MI)*XIJKL
                  IF(L.GT.K) DVAL = -DVAL
                  IF((M+NCOR).GT.J) DVAL = -DVAL
                  PRCNDO(JMG) = PRCNDO(JMG) + FOUR*DVAL
  900           CONTINUE
              ENDIF
  910       CONTINUE
C
            DO 980 L=1,NACT
              KG = MAX(K,L+NCOR)
              LG = MIN(K,L+NCOR)
              KL = IA(KG) + LG
              XIJKL = BUFF(KL)
              IF(ABS(XIJKL).LT.TOL) GO TO 980
C
              IF(J.LE.NCOR) GO TO 945
              JG = MAX(J-NCOR,L)
              LG = MIN(J-NCOR,L)
              JL = IA(JG) + LG
              DO 920 M=1,NCOR
                IMG = IABS(INDEX(I,M))
                KMG = IABS(INDEX(K,M))
                IF((KMG.NE.IMG) .OR. (IMG.EQ.0)) GO TO 920
                DVAL = OPDM(JL)*XIJKL
                IF(M.GT.I) DVAL = -DVAL
                IF(M.GT.K) DVAL = -DVAL
                PRCNDO(IMG) = PRCNDO(IMG) - DVAL
  920         CONTINUE
C
              DO 940 M=1,NACT
                IMG = IABS(INDEX(I,M+NCOR))
                IF(IMG.EQ.0) GO TO 940
                MG = MAX(M,J-NCOR)
                JG = MIN(M,J-NCOR)
                MJ = IA(MG) + JG
                DO 930 N=1,NACT
                  KNG = IABS(INDEX(K,N+NCOR))
                  IF(IMG.NE.KNG) GO TO 930
                  NG = MAX(N,L)
                  LG = MIN(N,L)
                  NL = IA(NG) + LG
                  MJG = MAX(MJ,NL)
                  NLG = MIN(MJ,NL)
                  MJNL = IA(MJG) + NLG
                  DVAL = TPDM(MJNL)*XIJKL
                  IF((M+NCOR).GT.I) DVAL = -DVAL
                  IF((N+NCOR).GT.K) DVAL = -DVAL
                  PRCNDO(IMG) = PRCNDO(IMG) + TWO*DVAL
  930           CONTINUE
  940         CONTINUE
C
  945         IF(I.EQ.J) GO TO 980
              IG = MAX(I-NCOR,L)
              LG = MIN(I-NCOR,L)
              IL = IA(IG) + LG
              DO 950 M=1,NCOR
                JMG = IABS(INDEX(J,M))
                KMG = IABS(INDEX(K,M))
                IF((KMG.NE.JMG) .OR. (JMG.EQ.0)) GO TO 950
                DVAL = OPDM(IL)*XIJKL
                IF(M.GT.J) DVAL = -DVAL
                IF(M.GT.K) DVAL = -DVAL
                PRCNDO(JMG) = PRCNDO(JMG) - DVAL
  950         CONTINUE
C
              DO 970 M=1,NACT
                JMG = IABS(INDEX(J,M+NCOR))
                IF(JMG.EQ.0) GO TO 970
                MG = MAX(M,I-NCOR)
                IG = MIN(M,I-NCOR)
                MI = IA(MG) + IG
                DO 960 N=1,NACT
                  KNG = IABS(INDEX(K,N+NCOR))
                  IF(JMG.NE.KNG) GO TO 960
                  NG = MAX(N,L)
                  LG = MIN(N,L)
                  NL = IA(NG) + LG
                  MIG = MAX(MI,NL)
                  NLG = MIN(MI,NL)
                  MINL = IA(MIG) + NLG
                  DVAL = TPDM(MINL)*XIJKL
                  IF((M+NCOR).GT.J) DVAL = -DVAL
                  IF((N+NCOR).GT.K) DVAL = -DVAL
                  PRCNDO(JMG) = PRCNDO(JMG) + TWO*DVAL
  960           CONTINUE
  970         CONTINUE
  980       CONTINUE
  990     CONTINUE
C
C          ----- Finished with current integral buffer -----
C
 1000     CALL DDI_PROCDLB_NEXT(C_OOOO,IWP,ICNTR1)
C
        ENDDO
        CALL TSECND(T1)
        IF(IWP.EQ.ME  .AND.  MASWRK) WRITE(IW,9000) T1-T0
        CALL FLSHBF(IW)
        T0 = T1
C
C     ----- Get and use (VO|OO) integrals -----
C
        CALL DDI_DISTRIB(D_VOOO,IWP,ILO,IHI,JLO,JHI)
        MAXWRK = JHI-JLO+1
C
        CALL DDI_PROCDLB_NEXT(C_VOOO,IWP,ICNTR2)
C
        DO WHILE(ICNTR2.LT.MAXWRK)
          JKL = JLO + ICNTR2
C
          DO KK=1,NOCC
            DO LL=1,KK
              KL = IA(KK) + LL
              DLT = ONE
              IF(KK.EQ.LL) DLT = HALF
              DO JJ=1,NOCC
                JKLTMP = (KL-1)*NOCC + JJ
                IF(JKL.EQ.JKLTMP) THEN
                  J = JJ
                  K = KK
                  L = LL
                  IF(K.GT.NCOR .AND. L.GT.NCOR) THEN
                    KKLL = IA(K-NCOR) + L-NCOR
                  ENDIF
                  GO TO 1010
                END IF
              ENDDO
            ENDDO
          ENDDO
C
 1010     CALL DDI_GET(D_VOOO,1,NBVIR,JKL,JKL,BUFF)
C
C          ----- Derivative core Fock matrices -----
C
          DO 1060 I=NOCC+1,L0
            XIJKL = BUFF(I-NOCC)
            IF(ABS(XIJKL).LT.TOL) GO TO 1060
            IF(J.GT.NCOR) GO TO 1020
            AVAL = TWO*XIJKL
            CALL DAXPY(NXYZ,-AVAL,SDER(1,I,J),1,DFC(1,KL),1)
C
 1020       IF((K.GT.NCOR).AND.(L.GT.NCOR)) GO TO 1060
            AVAL = HALF*XIJKL
            IF(K.EQ.L) AVAL = HALF*AVAL
            IF((K.GT.J).OR.(L.GT.NCOR)) GO TO 1030
            JK = IA(J) + K
            CALL DAXPY(NXYZ,AVAL,SDER(1,I,L),1,DFC(1,JK),1)
C
 1030       IF((L.GT.J).OR.(K.GT.NCOR)) GO TO 1040
            JL = IA(J) + L
            CALL DAXPY(NXYZ,AVAL,SDER(1,I,K),1,DFC(1,JL),1)
C
 1040       IF((J.GT.K).OR.(L.GT.NCOR)) GO TO 1050
            KJ = IA(K) + J
            CALL DAXPY(NXYZ,AVAL,SDER(1,I,L),1,DFC(1,KJ),1)
C
 1050       IF((J.GT.L).OR.(K.GT.NCOR)) GO TO 1060
            LJ = IA(L) + J
            CALL DAXPY(NXYZ,AVAL,SDER(1,I,K),1,DFC(1,LJ),1)
 1060     CONTINUE
C
C          ----- Derivative two-electron integrals -----
C
          IF((J.LE.NCOR).OR.(K.LE.NCOR).OR.(L.LE.NCOR)) GO TO 1100
          DO 1090 I=NOCC+1,L0
            XIJKL = BUFF(I-NOCC)
            IF(ABS(XIJKL).LT.TOL) GO TO 1090
            XIJKL = HALF*XIJKL
            DO 1080 M=NCOR+1,NOCC
              IF(J.GT.M) GO TO 1070
              MJ = IA(M-NCOR) + J-NCOR
              IF(KKLL.LE.MJ) THEN
                MJKL = IA(MJ) + KKLL
                CALL DAXPY(NXYZ,-XIJKL,SDER(1,M,I),1,DERI(1,MJKL),1)
              ENDIF
C
              IF(MJ.LE.KKLL) THEN
                KLMJ = IA(KKLL) + MJ
                CALL DAXPY(NXYZ,-XIJKL,SDER(1,M,I),1,DERI(1,KLMJ),1)
              ENDIF
C
 1070         IF(M.GT.J) GO TO 1080
C
              JM = IA(J-NCOR) + M-NCOR
              IF(KKLL.LE.JM) THEN
                JMKL = IA(JM) + KKLL
                CALL DAXPY(NXYZ,-XIJKL,SDER(1,M,I),1,DERI(1,JMKL),1)
              ENDIF
C
              IF(JM.LE.KKLL) THEN
                KLJM = IA(KKLL) + JM
                CALL DAXPY(NXYZ,-XIJKL,SDER(1,M,I),1,DERI(1,KLJM),1)
              ENDIF
 1080       CONTINUE
 1090     CONTINUE
C
C          ----- Construct core Fock matrix -----
C
 1100     IF((K.NE.L) .OR. (K.GT.NCOR)) GO TO 1110
          DO I=NOCC+1,L0
            IJ = IA(I) + J
            FCOR(IJ) = FCOR(IJ) + TWO*BUFF(I-NOCC)
          ENDDO
C
 1110     IF(J.GT.NCOR) GO TO 1130
          IF(J.NE.L) GO TO 1120
          DO I=NOCC+1,L0
            IK = IA(I) + K
            FCOR(IK) = FCOR(IK) - BUFF(I-NOCC)
          ENDDO
C
 1120     IF((J.NE.K) .OR. (K.EQ.L)) GO TO 1130
          DO I=NOCC+1,L0
            IL = IA(I) + L
            FCOR(IL) = FCOR(IL) - BUFF(I-NOCC)
          ENDDO
C
C          ----- Coulomb contribution to derivative Lagrangian -----
C
 1130     CONTINUE
          DO 1200 I=NOCC+1,L0
            XIJKL = BUFF(I-NOCC)
            IF(ABS(XIJKL).LT.TOL) GO TO 1200
C
C               ----- Lder(j,m) where m is a core orbital index -----
C
            IF(K.LE.NCOR) THEN
              CALL DAXPY(NXYZ,XIJKL,SDER(1,I,K),1,DLAG(1,J,L),1)
              CALL DAXPY(NXYZ,XIJKL,SDER(1,J,K),1,DLAG(1,I,L),1)
              IF(K.NE.L) THEN
                CALL DAXPY(NXYZ,XIJKL,SDER(1,I,L),1,DLAG(1,J,K),1)
                CALL DAXPY(NXYZ,XIJKL,SDER(1,J,L),1,DLAG(1,I,K),1)
              ENDIF
            ENDIF
C
            DO 1140 M=1,NCOR
              DVAL = ZERO
              IF(L.GT.NCOR) DVAL = TWO*OPDM(KKLL)*XIJKL
              IF(K.EQ.L) THEN
                DVAL = HALF*DVAL
                IF(K.LE.NCOR) DVAL = TWO*XIJKL
              ENDIF
              CALL DAXPY(NXYZ,-DVAL,SDER(1,I,M),1,DLAG(1,J,M),1)
              CALL DAXPY(NXYZ,-DVAL,SDER(1,J,M),1,DLAG(1,I,M),1)
 1140       CONTINUE
C
            DO 1150 M=1,NACT
              IF((K.GT.NCOR) .AND. (L.LE.NCOR)) THEN
                MM = M+NCOR
                MG = MAX(M,K-NCOR)
                KG = MIN(M,K-NCOR)
                MK = IA(MG) + KG
                DVAL = OPDM(MK)*XIJKL
                DVAL = HALF*DVAL
                CALL DAXPY(NXYZ,DVAL,SDER(1,I,MM),1,DLAG(1,J,L),1)
                CALL DAXPY(NXYZ,DVAL,SDER(1,J,MM),1,DLAG(1,I,L),1)
              ENDIF
 1150       CONTINUE
C
C               ----- Lder(j,m) where m is an active orbital index -----
C
             DO 1180 M=1,NACT
               MM = M+NCOR
               IF((K.GT.NCOR) .AND. (L.LE.NCOR)) THEN
                 MG = MAX(M,K-NCOR)
                 KG = MIN(M,K-NCOR)
                 MK = IA(MG) + KG
                 DVAL = OPDM(MK)*XIJKL
                 DVAL = HALF*DVAL
                 CALL DAXPY(NXYZ,DVAL,SDER(1,I,L),1,DLAG(1,J,MM),1)
                 CALL DAXPY(NXYZ,DVAL,SDER(1,J,L),1,DLAG(1,I,MM),1)
               ENDIF
C
               DO 1170 N=1,NACT
                 NN = N+NCOR
                 MG = MAX(M,N)
                 NG = MIN(M,N)
                 MN = IA(MG) + NG
                 IF((K.LE.NCOR) .AND. (K.EQ.L)) THEN
                   DVAL = OPDM(MN)*XIJKL
                   CALL DAXPY(NXYZ,-DVAL,SDER(1,I,NN),1,DLAG(1,J,MM),1)
                   CALL DAXPY(NXYZ,-DVAL,SDER(1,J,NN),1,DLAG(1,I,MM),1)
                 ENDIF
                 IF(L.GT.NCOR) THEN
                   MNG = MAX(MN,KKLL)
                   KLG = MIN(MN,KKLL)
                   MNKL = IA(MNG) + KLG
                   DVAL = TPDM(MNKL)*XIJKL
                   IF(K.EQ.L) DVAL = HALF*DVAL
                   CALL DAXPY(NXYZ,-DVAL,SDER(1,I,NN),1,DLAG(1,J,MM),1)
                   CALL DAXPY(NXYZ,-DVAL,SDER(1,J,NN),1,DLAG(1,I,MM),1)
                 ENDIF
 1170          CONTINUE
 1180        CONTINUE
 1200      CONTINUE
C
C          ----- Exchange contribution to derivative Lagrangian -----
C
          DO 1400 I=NOCC+1,L0
            XIJKL = BUFF(I-NOCC)
            IF(ABS(XIJKL).LT.TOL) GO TO 1400
C
C               ----- Lder(k,m) where j or l is a core orbital -----
C
            IF(J.GT.NCOR) GO TO 1220
            IF(L.LE.NCOR) THEN
              DVAL = FOUR*XIJKL
              CALL DAXPY(NXYZ,-DVAL,SDER(1,I,J),1,DLAG(1,K,L),1)
              CALL DAXPY(NXYZ,XIJKL,SDER(1,I,L),1,DLAG(1,K,J),1)
            ENDIF
            IF((K.LE.NCOR) .AND. (K.NE.L)) THEN
              DVAL = FOUR*XIJKL
              CALL DAXPY(NXYZ,-DVAL,SDER(1,I,J),1,DLAG(1,L,K),1)
              CALL DAXPY(NXYZ,XIJKL,SDER(1,I,K),1,DLAG(1,L,J),1)
            ENDIF
C
            DO M=1,NCOR
              IF(L.EQ.J)
     *          CALL DAXPY(NXYZ,XIJKL,SDER(1,I,M),1,DLAG(1,K,M),1)
              IF((K.EQ.J) .AND. (K.NE.L))
     *          CALL DAXPY(NXYZ,XIJKL,SDER(1,I,M),1,DLAG(1,L,M),1)
            ENDDO
C
            DO 1210 M=1,NACT
              MM = M+NCOR
              IF(L.GT.NCOR) THEN
                MG = MAX(M,L-NCOR)
                LG = MIN(M,L-NCOR)
                ML = IA(MG) + LG
                DVAL = OPDM(ML)*XIJKL
                DVAL = HALF*DVAL
                CALL DAXPY(NXYZ,DVAL,SDER(1,I,MM),1,DLAG(1,K,J),1)
                DVAL = FOUR*DVAL
                CALL DAXPY(NXYZ,-DVAL,SDER(1,I,J),1,DLAG(1,K,MM),1)
              ENDIF
              IF((K.GT.NCOR) .AND. (K.NE.L)) THEN
                MG = MAX(M,K-NCOR)
                KG = MIN(M,K-NCOR)
                MK = IA(MG) + KG
                DVAL = OPDM(MK)*XIJKL
                DVAL = HALF*DVAL
                CALL DAXPY(NXYZ,DVAL,SDER(1,I,MM),1,DLAG(1,L,J),1)
                DVAL = FOUR*DVAL
                CALL DAXPY(NXYZ,-DVAL,SDER(1,I,J),1,DLAG(1,L,MM),1)
              ENDIF
C
              DO 1210 N=1,NACT
                NN = N+NCOR
                MG = MAX(M,N)
                NG = MIN(M,N)
                MN = IA(MG) + NG
                DVAL = OPDM(MN)*XIJKL
                DVAL = HALF*DVAL
                IF(L.EQ.J)
     *            CALL DAXPY(NXYZ,DVAL,SDER(1,I,MM),1,DLAG(1,K,NN),1)
                IF((K.EQ.J) .AND. (K.NE.L))
     *            CALL DAXPY(NXYZ,DVAL,SDER(1,I,MM),1,DLAG(1,L,NN),1)
 1210       CONTINUE
C
 1220       IF(L.GT.NCOR) GO TO 1260
            IF(J.LE.NCOR) THEN
              DVAL = FOUR*XIJKL
              CALL DAXPY(NXYZ,-DVAL,SDER(1,K,L),1,DLAG(1,I,J),1)
              CALL DAXPY(NXYZ,XIJKL,SDER(1,K,J),1,DLAG(1,I,L),1)
            ENDIF
C
            DO M=1,NCOR
              IF(J.EQ.L)
     *          CALL DAXPY(NXYZ,XIJKL,SDER(1,K,M),1,DLAG(1,I,M),1)
            ENDDO
C
            DO 1230 M=1,NACT
              MM = M+NCOR
              IF(J.GT.NCOR) THEN
                MG = MAX(M,J-NCOR)
                JG = MIN(M,J-NCOR)
                MJ = IA(MG) + JG
                DVAL = OPDM(MJ)*XIJKL
                DVAL = HALF*DVAL
                CALL DAXPY(NXYZ,DVAL,SDER(1,K,MM),1,DLAG(1,I,L),1)
                DVAL = FOUR*DVAL
                CALL DAXPY(NXYZ,-DVAL,SDER(1,K,L),1,DLAG(1,I,MM),1)
              ENDIF
C
              DO 1230 N=1,NACT
                NN = N+NCOR
                MG = MAX(M,N)
                NG = MIN(M,N)
                MN = IA(MG) + NG
                DVAL = OPDM(MN)*XIJKL
                DVAL = HALF*DVAL
                IF(J.EQ.L)
     *            CALL DAXPY(NXYZ,DVAL,SDER(1,K,MM),1,DLAG(1,I,NN),1)
 1230       CONTINUE
C
            IF((K.GT.NCOR) .OR. (K.EQ.L)) GO TO 1260
            IF(J.LE.NCOR) THEN
              DVAL = FOUR*XIJKL
              CALL DAXPY(NXYZ,-DVAL,SDER(1,L,K),1,DLAG(1,I,J),1)
              CALL DAXPY(NXYZ,XIJKL,SDER(1,L,J),1,DLAG(1,I,K),1)
            ENDIF
C
            DO M=1,NCOR
              IF(J.EQ.K)
     *          CALL DAXPY(NXYZ,XIJKL,SDER(1,L,M),1,DLAG(1,I,M),1)
            ENDDO
C
            DO 1250 M=1,NACT
              MM = M+NCOR
              IF(J.GT.NCOR) THEN
                MG = MAX(M,J-NCOR)
                JG = MIN(M,J-NCOR)
                MJ = IA(MG) + JG
                DVAL = OPDM(MJ)*XIJKL
                DVAL = HALF*DVAL
                CALL DAXPY(NXYZ,DVAL,SDER(1,L,MM),1,DLAG(1,I,K),1)
                DVAL = FOUR*DVAL
                CALL DAXPY(NXYZ,-DVAL,SDER(1,L,K),1,DLAG(1,I,MM),1)
              ENDIF
C
              DO 1250 N=1,NACT
                NN = N+NCOR
                MG = MAX(M,N)
                NG = MIN(M,N)
                MN = IA(MG) + NG
                DVAL = OPDM(MN)*XIJKL
                DVAL = HALF*DVAL
                IF(J.EQ.K)
     *            CALL DAXPY(NXYZ,DVAL,SDER(1,L,MM),1,DLAG(1,I,NN),1)
 1250       CONTINUE
C
C               ----- Lder(k,m) where j or l is an active orbital -----
C
 1260       IF(J.LE.NCOR) GO TO 1280
            DO M=1,NCOR
              IF(L.GT.NCOR) THEN
                JG = MAX(J-NCOR,L-NCOR)
                LG = MIN(J-NCOR,L-NCOR)
                JL = IA(JG) + LG
                DVAL = OPDM(JL)*XIJKL
                DVAL = HALF*DVAL
                CALL DAXPY(NXYZ,DVAL,SDER(1,I,M),1,DLAG(1,K,M),1)
              ENDIF
              IF((K.GT.NCOR) .AND. (K.NE.L)) THEN
                JG = MAX(J-NCOR,K-NCOR)
                KG = MIN(J-NCOR,K-NCOR)
                JK = IA(JG) + KG
                DVAL = OPDM(JK)*XIJKL
                DVAL = HALF*DVAL
                CALL DAXPY(NXYZ,DVAL,SDER(1,I,M),1,DLAG(1,L,M),1)
              ENDIF
            ENDDO
C
            DO 1270 M=1,NACT
              MM = M+NCOR
              JG = MAX(J-NCOR,M)
              MG = MIN(J-NCOR,M)
              JM = IA(JG) + MG
              DVAL = OPDM(JM)*XIJKL
              DVAL = HALF*DVAL
              IF(L.LE.NCOR) THEN
                CALL DAXPY(NXYZ,DVAL,SDER(1,I,L),1,DLAG(1,K,MM),1)
                DLT = FOUR*DVAL
                CALL DAXPY(NXYZ,-DLT,SDER(1,I,MM),1,DLAG(1,K,L),1)
              ENDIF
              IF((K.LE.NCOR) .AND. (K.NE.L)) THEN
                CALL DAXPY(NXYZ,DVAL,SDER(1,I,K),1,DLAG(1,L,MM),1)
                DLT = FOUR*DVAL
                CALL DAXPY(NXYZ,-DLT,SDER(1,I,MM),1,DLAG(1,L,K),1)
              ENDIF
C
              DO N=1,NACT
                NN = N+NCOR
                IF(L.GT.NCOR) THEN
                  NG = MAX(N,L-NCOR)
                  LG = MIN(N,L-NCOR)
                  NL = IA(NG) + LG
                  JMG = MAX(JM,NL)
                  NLG = MIN(JM,NL)
                  JMNL = IA(JMG) + NLG
                  DVAL = TPDM(JMNL)*XIJKL
                  CALL DAXPY(NXYZ,-DVAL,SDER(1,I,MM),1,DLAG(1,K,NN),1)
                ENDIF
                IF((K.GT.NCOR) .AND. (K.NE.L)) THEN
                  NG = MAX(N,K-NCOR)
                  KG = MIN(N,K-NCOR)
                  NK = IA(NG) + KG
                  JMG = MAX(JM,NK)
                  NKG = MIN(JM,NK)
                  JMNK = IA(JMG) + NKG
                  DVAL = TPDM(JMNK)*XIJKL
                  CALL DAXPY(NXYZ,-DVAL,SDER(1,I,MM),1,DLAG(1,L,NN),1)
                ENDIF
              ENDDO
 1270       CONTINUE
C
 1280       IF(L.LE.NCOR) GO TO 1300
            DO M=1,NCOR
              IF(J.GT.NCOR) THEN
                JG = MAX(J-NCOR,L-NCOR)
                LG = MIN(J-NCOR,L-NCOR)
                JL = IA(JG) + LG
                DVAL = OPDM(JL)*XIJKL
                DVAL = HALF*DVAL
                CALL DAXPY(NXYZ,DVAL,SDER(1,K,M),1,DLAG(1,I,M),1)
              ENDIF
            ENDDO
C
            DO 1290 M=1,NACT
              MM = M+NCOR
              LG = MAX(L-NCOR,M)
              MG = MIN(L-NCOR,M)
              LM = IA(LG) + MG
              DVAL = OPDM(LM)*XIJKL
              DVAL = HALF*DVAL
              IF(J.LE.NCOR) THEN
                CALL DAXPY(NXYZ,DVAL,SDER(1,K,J),1,DLAG(1,I,MM),1)
                DVAL = FOUR*DVAL
                CALL DAXPY(NXYZ,-DVAL,SDER(1,K,MM),1,DLAG(1,I,J),1)
              ENDIF
C
              DO N=1,NACT
                NN = N+NCOR
                IF(J.GT.NCOR) THEN
                  NG = MAX(N,J-NCOR)
                  JG = MIN(N,J-NCOR)
                  NJ = IA(NG) + JG
                  LMG = MAX(LM,NJ)
                  NJG = MIN(LM,NJ)
                  LMNJ = IA(LMG) + NJG
                  DVAL = TPDM(LMNJ)*XIJKL
                  CALL DAXPY(NXYZ,-DVAL,SDER(1,K,MM),1,DLAG(1,I,NN),1)
                ENDIF
              ENDDO
 1290       CONTINUE
C
 1300       IF((K.LE.NCOR) .OR. (K.EQ.L)) GO TO 1400
            DO M=1,NCOR
              IF(J.GT.NCOR) THEN
                JG = MAX(J-NCOR,K-NCOR)
                KG = MIN(J-NCOR,K-NCOR)
                JK = IA(JG) + KG
                DVAL = OPDM(JK)*XIJKL
                DVAL = HALF*DVAL
                CALL DAXPY(NXYZ,DVAL,SDER(1,L,M),1,DLAG(1,I,M),1)
              ENDIF
            ENDDO
C
            DO 1310 M=1,NACT
              MM = M+NCOR
              KG = MAX(K-NCOR,M)
              MG = MIN(K-NCOR,M)
              KM = IA(KG) + MG
              DVAL = OPDM(KM)*XIJKL
              DVAL = HALF*DVAL
              IF(J.LE.NCOR) THEN
                CALL DAXPY(NXYZ,DVAL,SDER(1,L,J),1,DLAG(1,I,MM),1)
                DVAL = FOUR*DVAL
                CALL DAXPY(NXYZ,-DVAL,SDER(1,L,MM),1,DLAG(1,I,J),1)
              ENDIF
C
              DO N=1,NACT
                NN = N+NCOR
                IF(J.GT.NCOR) THEN
                  NG = MAX(N,J-NCOR)
                  JG = MIN(N,J-NCOR)
                  NJ = IA(NG) + JG
                  KMG = MAX(KM,NJ)
                  NJG = MIN(KM,NJ)
                  KMNJ = IA(KMG) + NJG
                  DVAL = TPDM(KMNJ)*XIJKL
                  CALL DAXPY(NXYZ,-DVAL,SDER(1,L,MM),1,DLAG(1,I,NN),1)
                ENDIF
              ENDDO
 1310       CONTINUE
 1400     CONTINUE
C
C          ----- Construct two-electron integral array -----
C
          IF(J.LE.NCOR) GO TO 1500
          IF((K.LE.NCOR) .OR. (L.LE.NCOR)) GO TO 1500
          JJ = J-NCOR
          DO I=NOCC+1,L0
            ERI(I,JJ,KKLL) = BUFF(I-NOCC)
          ENDDO
C
C          ----- Construct A matrix -----
C
 1500     IF(J.GT.NCOR) GO TO 1550
          IF((K.LE.NCOR) .OR. (L.LE.NCOR)) GO TO 1550
          DO I=NOCC+1,L0
            AMAT(I,J,KKLL) = AMAT(I,J,KKLL) + FOUR*BUFF(I-NOCC)
          ENDDO
C
 1550     IF(J.LE.NCOR) GO TO 1600
          IF((K.LE.NCOR) .OR. (L.GT.NCOR)) GO TO 1600
          JJ = J-NCOR
          KK = K-NCOR
          JG = MAX(JJ,KK)
          KG = MIN(JJ,KK)
          JK = IA(JG) + KG
          DO I=NOCC+1,L0
            DVAL = BUFF(I-NOCC)
            IF(J.GE.K) AMAT(I,L,JK) = AMAT(I,L,JK) - DVAL
            IF(K.GE.J) AMAT(I,L,JK) = AMAT(I,L,JK) - DVAL
          ENDDO
C
C          ----- Finished with current integral buffer -----
C
 1600     CALL DDI_PROCDLB_NEXT(C_VOOO,IWP,ICNTR2)
C
        ENDDO
        CALL TSECND(T1)
        IF(IWP.EQ.ME  .AND.  MASWRK) WRITE(IW,9010) T1-T0
        CALL FLSHBF(IW)
        T0 = T1
C
C     ----- Get and use (VV|OO) integrals -----
C
        CALL DDI_DISTRIB(D_VVOO,IWP,ILO,IHI,JLO,JHI)
        MAXWRK = JHI-JLO+1
C
        CALL DDI_PROCDLB_NEXT(C_VVOO,IWP,ICNTR3)
C
        DO WHILE(ICNTR3.LT.MAXWRK)
          KL = JLO + ICNTR3
C
          DO KK=1,NOCC
            DO LL=1,KK
              KLTMP = IA(KK) + LL
              IF(KL.EQ.KLTMP) THEN
                K = KK
                L = LL
                GO TO 2010
              END IF
            ENDDO
          ENDDO
C
 2010     CALL DDI_GET(D_VVOO,1,NBTR,KL,KL,BUFF)
C
C          ----- Construct core Fock matrix -----
C
          IF((K.NE.L) .OR. (K.GT.NCOR)) GO TO 2030
          DO 2020 I=1,NVIR
            II = I + NOCC
            DO 2020 J=1,I
              JJ = J + NOCC
              IIJJ = IA(II) + JJ
              IJ = IA(I) + J
              FCOR(IIJJ) = FCOR(IIJJ) + TWO*BUFF(IJ)
 2020     CONTINUE
C
C          ----- Coulomb contribution to derivative Lagrangian -----
C
 2030     IF(L.GT.NCOR) KKLL = IA(K-NCOR) + L-NCOR
          DO 2100 I=1,NVIR
            II = I+NOCC
            DO 2100 J=1,I
              JJ = J+NOCC
              IJ = IA(I) + J
              XIJKL = BUFF(IJ)
              IF(ABS(XIJKL).LT.TOL) GO TO 2100
              IJVAL = .TRUE.
              IF(I.EQ.J) IJVAL = .FALSE.
C
C               ----- K and L are core indices -----
C
              IF(K.LE.NCOR) THEN
                CALL DAXPY(NXYZ,XIJKL,SDER(1,II,K),1,DLAG(1,JJ,L),1)
                IF(IJVAL) CALL DAXPY(NXYZ,XIJKL,SDER(1,JJ,K),1,
     *                               DLAG(1,II,L),1)
C
                IF(K.NE.L) THEN
                  CALL DAXPY(NXYZ,XIJKL,SDER(1,II,L),1,DLAG(1,JJ,K),1)
                  IF(IJVAL) CALL DAXPY(NXYZ,XIJKL,SDER(1,JJ,L),1,
     *                                 DLAG(1,II,K),1)
                ENDIF
C
                IF(K.EQ.L) THEN
                  DVAL = TWO*XIJKL
                  DO M=1,NCOR
                    CALL DAXPY(NXYZ,-DVAL,SDER(1,II,M),1,DLAG(1,JJ,M),1)
                    IF(IJVAL) CALL DAXPY(NXYZ,-DVAL,SDER(1,JJ,M),1,
     *                                   DLAG(1,II,M),1)
                  ENDDO
C
                  DO 2040 M=1,NACT
                    MM = M+NCOR
                    DO 2040 N=1,NACT
                      NN = N+NCOR
                      MG = MAX(M,N)
                      NG = MIN(M,N)
                      MN = IA(MG) + NG
                      DVAL = OPDM(MN)*XIJKL
                      CALL DAXPY(NXYZ,-DVAL,SDER(1,II,MM),1,
     *                           DLAG(1,JJ,NN),1)
                      IF(IJVAL) CALL DAXPY(NXYZ,-DVAL,SDER(1,JJ,MM),1,
     *                                     DLAG(1,II,NN),1)
 2040             CONTINUE
                ENDIF
                GO TO 2100
              ENDIF
C
C               ----- K is active, L is core -----
C
              IF(L.LE.NCOR) THEN
                DO M=1,NACT
                  MM = M+NCOR
                  MG = MAX(M,K-NCOR)
                  KG = MIN(M,K-NCOR)
                  MK = IA(MG) + KG
                  DVAL = OPDM(MK)*XIJKL
                  DVAL = HALF*DVAL
                  CALL DAXPY(NXYZ,DVAL,SDER(1,II,MM),1,DLAG(1,JJ,L),1)
                  IF(IJVAL) CALL DAXPY(NXYZ,DVAL,SDER(1,JJ,MM),1,
     *                                 DLAG(1,II,L),1)
C
                  CALL DAXPY(NXYZ,DVAL,SDER(1,II,L),1,DLAG(1,JJ,MM),1)
                  IF(IJVAL) CALL DAXPY(NXYZ,DVAL,SDER(1,JJ,L),1,
     *                                 DLAG(1,II,MM),1)
                ENDDO
                GO TO 2100
              ENDIF
C
C               ----- K and L are active indicies -----
C
               DVAL = OPDM(KKLL)*XIJKL
               IF(K.NE.L) DVAL = TWO*DVAL
               DO M=1,NCOR
                 CALL DAXPY(NXYZ,-DVAL,SDER(1,II,M),1,DLAG(1,JJ,M),1)
                 IF(IJVAL) CALL DAXPY(NXYZ,-DVAL,SDER(1,JJ,M),1,
     *                                DLAG(1,II,M),1)
               ENDDO
C
               DO 2050 M=1,NACT
                 MM = M+NCOR
                 DO 2050 N=1,NACT
                   NN = N+NCOR
                   MG = MAX(M,N)
                   NG = MIN(M,N)
                   MN = IA(MG) + NG
                   MNG = MAX(MN,KKLL)
                   KLG = MIN(MN,KKLL)
                   MNKL = IA(MNG) + KLG
                   DVAL = TPDM(MNKL)*XIJKL
                   IF(K.EQ.L) DVAL = HALF*DVAL
                   CALL DAXPY(NXYZ,-DVAL,SDER(1,II,MM),1,
     *                        DLAG(1,JJ,NN),1)
                   IF(IJVAL) CALL DAXPY(NXYZ,-DVAL,SDER(1,JJ,MM),1,
     *                                  DLAG(1,II,NN),1)
 2050          CONTINUE
 2100     CONTINUE
C
C          ----- Coulomb contribution to preconditioner -----
C
          DO 2300 I=1,NVIR
            II = I+NOCC
            IJ = IA(I) + I
            XIJKL = BUFF(IJ)
            IF(ABS(XIJKL).LT.TOL) GO TO 2300
C
            IF((K.GT.NCOR) .OR. (K.NE.L)) GO TO 2200
            DO 2120 M=1,NCOR
              IMG = IABS(INDEX(II,M))
              IF(IMG.EQ.0) GO TO 2120
              DVAL = FOUR*XIJKL
              IF(M.EQ.K) DVAL = HALF*DVAL
              PRCNDO(IMG) = PRCNDO(IMG) + DVAL
 2120       CONTINUE
C
            DO 2130 M=1,NACT
              IMG = IABS(INDEX(II,M+NCOR))
              IF(IMG.EQ.0) GO TO 2130
              MM = IA(M) + M
              DVAL = OPDM(MM)*XIJKL
              PRCNDO(IMG) = PRCNDO(IMG) + TWO*DVAL
 2130       CONTINUE
C
 2200       IF(L.LE.NCOR) GO TO 2300
C
            DO 2220 M=1,NCOR
              IMG = IABS(INDEX(II,M))
              IF(IMG.EQ.0) GO TO 2220
              DVAL = OPDM(KKLL)*XIJKL
              IF(K.NE.L) DVAL = TWO*DVAL
              PRCNDO(IMG) = PRCNDO(IMG) + TWO*DVAL
 2220       CONTINUE
C
            DO 2230 M=1,NACT
              IMG = IABS(INDEX(II,M+NCOR))
              IF(IMG.EQ.0) GO TO 2230
              MM = IA(M) + M
              MMG = MAX(MM,KKLL)
              KLG = MIN(MM,KKLL)
              MMKL = IA(MMG) + KLG
              DVAL = TPDM(MMKL)*XIJKL
              IF(K.NE.L) DVAL = TWO*DVAL
              PRCNDO(IMG) = PRCNDO(IMG) + DVAL
 2230       CONTINUE
 2300     CONTINUE
C
C          ----- Finished with current integral buffer -----
C
          CALL DDI_PROCDLB_NEXT(C_VVOO,IWP,ICNTR3)
C
        ENDDO
        CALL TSECND(T1)
        IF(IWP.EQ.ME  .AND.  MASWRK) WRITE(IW,9020) T1-T0
        CALL FLSHBF(IW)
        T0 = T1
C
C     ----- Get and use (VO|VO) integrals -----
C
        CALL DDI_DISTRIB(D_VOVO,IWP,ILO,IHI,JLO,JHI)
        MAXWRK = JHI-JLO+1
C
        CALL DDI_PROCDLB_NEXT(C_VOVO,IWP,ICNTR4)
C
        DO WHILE(ICNTR4.LT.MAXWRK)
          JL = JLO + ICNTR4
C
          DO JJ=1,NOCC
            DO LL=1,JJ
              JLTMP = IA(JJ) + LL
              IF(JL.EQ.JLTMP) THEN
                J = JJ
                L = LL
                GO TO 3010
              END IF
            ENDDO
          ENDDO
C
 3010     CALL DDI_GET(D_VOVO,1,NBSQ,JL,JL,BUFF)
C
C          ----- Construct core Fock matrix -----
C
          IF((J.NE.L) .OR. (J.GT.NCOR)) GO TO 3030
          DO 3020 I=1,NVIR
            II = I + NOCC
            DO 3020 K=1,I
              KK = K + NOCC
              IIKK = IA(II) + KK
              IK = (I-1)*NVIR + K
              FCOR(IIKK) = FCOR(IIKK) - BUFF(IK)
 3020     CONTINUE
C
C          ----- Exchange contribution to derivative Lagrangian -----
C
 3030     IF(J.GT.NCOR) GO TO 3130
          IF(J.EQ.L) THEN
            DO 3050 I=1,NVIR
              II = I+NOCC
              DO 3050 K=1,NVIR
                KK = K+NOCC
                KI = (K-1)*NVIR + I
                XKJIL = BUFF(KI)
                IF(ABS(XKJIL).LT.TOL) GO TO 3050
                DO M=1,NCOR
                  CALL DAXPY(NXYZ,XKJIL,SDER(1,II,M),1,DLAG(1,KK,M),1)
                ENDDO
C
                DO 3040 M=1,NACT
                  MM = M+NCOR
                  DO 3040 N=1,NACT
                   NN = N+NCOR
                   MG = MAX(M,N)
                   NG = MIN(M,N)
                   MN = IA(MG) + NG
                   DVAL = OPDM(MN)*XKJIL
                   DVAL = HALF*DVAL
                   CALL DAXPY(NXYZ,DVAL,SDER(1,II,MM),1,DLAG(1,KK,NN),1)
 3040           CONTINUE
 3050       CONTINUE
          ENDIF
C
          DO 3060 I=1,NVIR
            II = I+NOCC
            DO 3060 K=1,NVIR
              KK = K+NOCC
              IK = (I-1)*NVIR + K
              KI = (K-1)*NVIR + I
              DVAL = BUFF(KI) - FOUR*BUFF(IK)
              CALL DAXPY(NXYZ,DVAL,SDER(1,II,L),1,DLAG(1,KK,J),1)
              IF(J.EQ.L) GO TO 3060
              DVAL = BUFF(IK) - FOUR*BUFF(KI)
              CALL DAXPY(NXYZ,DVAL,SDER(1,II,J),1,DLAG(1,KK,L),1)
 3060     CONTINUE
          GO TO 3400
C
 3130     IF(L.GT.NCOR) GO TO 3230
          DO 3150 I=1,NVIR
            II = I+NOCC
            DO 3150 K=1,NVIR
              KK = K+NOCC
              KI = (K-1)*NVIR + I
              XKJIL = BUFF(KI)
              IF(ABS(XKJIL).LT.TOL) GO TO 3140
              DO M=1,NACT
                MM = M+NCOR
                MG = MAX(M,J-NCOR)
                JG = MIN(M,J-NCOR)
                MJ = IA(MG) + JG
                DVAL = OPDM(MJ)*XKJIL
                DVAL = HALF*DVAL
                CALL DAXPY(NXYZ,DVAL,SDER(1,II,L),1,DLAG(1,KK,MM),1)
                DVAL = FOUR*DVAL
                CALL DAXPY(NXYZ,-DVAL,SDER(1,II,MM),1,DLAG(1,KK,L),1)
              ENDDO
C
 3140         IK = (I-1)*NVIR + K
              XIJKL = BUFF(IK)
              IF(ABS(XIJKL).LT.TOL) GO TO 3150
              DO M=1,NACT
                MM = M+NCOR
                MG = MAX(M,J-NCOR)
                JG = MIN(M,J-NCOR)
                MJ = IA(MG) + JG
                DVAL = OPDM(MJ)*XIJKL
                DVAL = HALF*DVAL
                CALL DAXPY(NXYZ,DVAL,SDER(1,II,MM),1,DLAG(1,KK,L),1)
                DVAL = FOUR*DVAL
                CALL DAXPY(NXYZ,-DVAL,SDER(1,II,L),1,DLAG(1,KK,MM),1)
              ENDDO
 3150     CONTINUE
          GO TO 3400
C
 3230    JL = IA(J-NCOR) + L-NCOR
         DO 3300 I=1,NVIR
           II = I+NOCC
           DO 3300 K=1,NVIR
             KK = K+NOCC
             KI = (K-1)*NVIR + I
             XKJIL = BUFF(KI)
             IF(ABS(XKJIL).LT.TOL) GO TO 3270
             DO M=1,NCOR
               DVAL = OPDM(JL)*XKJIL
               DVAL = HALF*DVAL
               CALL DAXPY(NXYZ,DVAL,SDER(1,II,M),1,DLAG(1,KK,M),1)
             ENDDO
C
             DO 3250 M=1,NACT
               MM = M+NCOR
               MG = MAX(M,J-NCOR)
               JG = MIN(M,J-NCOR)
               MJ = IA(MG) + JG
               DO 3250 N=1,NACT
                 NN = N+NCOR
                 NG = MAX(N,L-NCOR)
                 LG = MIN(N,L-NCOR)
                 NL = IA(NG) + LG
                 MJG = MAX(MJ,NL)
                 NLG = MIN(MJ,NL)
                 MJNL = IA(MJG) + NLG
                 DVAL = TPDM(MJNL)*XKJIL
                 CALL DAXPY(NXYZ,-DVAL,SDER(1,II,MM),1,DLAG(1,KK,NN),1)
 3250        CONTINUE
C
 3270        IF(J.EQ.L) GO TO 3300
             IK = (I-1)*NVIR + K
             XIJKL = BUFF(IK)
             IF(ABS(XIJKL).LT.TOL) GO TO 3300
             DO M=1,NCOR
               DVAL = OPDM(JL)*XIJKL
               DVAL = HALF*DVAL
               CALL DAXPY(NXYZ,DVAL,SDER(1,II,M),1,DLAG(1,KK,M),1)
             ENDDO
C
             DO 3290 M=1,NACT
               MM = M+NCOR
               MG = MAX(M,L-NCOR)
               LG = MIN(M,L-NCOR)
               ML = IA(MG) + LG
               DO 3290 N=1,NACT
                 NN = N+NCOR
                 NG = MAX(N,J-NCOR)
                 JG = MIN(N,J-NCOR)
                 NJ = IA(NG) + JG
                 MLG = MAX(ML,NJ)
                 NJG = MIN(ML,NJ)
                 MLNJ = IA(MLG) + NJG
                 DVAL = TPDM(MLNJ)*XIJKL
                 CALL DAXPY(NXYZ,-DVAL,SDER(1,II,MM),1,DLAG(1,KK,NN),1)
 3290        CONTINUE
 3300    CONTINUE
C
C          ----- Exchange contribution to preconditioner -----
C
 3400    CONTINUE
         DO 3600 I=1,NVIR
           II = I+NOCC
           IK = (I-1)*NVIR + I
           XIJKL = BUFF(IK)
           IF(ABS(XIJKL).LT.TOL) GO TO 3600
C
           IF((J.GT.NCOR) .OR. (J.NE.L)) GO TO 3500
           DO 3420 M=1,NCOR
             IMG = IABS(INDEX(II,M))
             IF(IMG.EQ.0) GO TO 3420
             DVAL = -TWO*XIJKL
             IF(M.EQ.J) DVAL = -TWO*DVAL
             PRCNDO(IMG) = PRCNDO(IMG) + DVAL
 3420      CONTINUE
C
           DO 3430 M=1,NACT
             IMG = IABS(INDEX(II,M+NCOR))
             IF(IMG.EQ.0) GO TO 3430
             MM = IA(M) + M
             PRCNDO(IMG) = PRCNDO(IMG) - OPDM(MM)*XIJKL
 3430      CONTINUE
C
 3500      IF(L.LE.NCOR) GO TO 3600
C
           DO 3520 M=1,NCOR
             IMG = IABS(INDEX(II,M))
             IF(IMG.EQ.0) GO TO 3520
             DVAL = OPDM(JL)*XIJKL
             IF(J.NE.L) DVAL = TWO*DVAL
             PRCNDO(IMG) = PRCNDO(IMG) - DVAL
 3520      CONTINUE
C
           DO 3530 M=1,NACT
             IMG = IABS(INDEX(II,M+NCOR))
             IF(IMG.EQ.0) GO TO 3530
             MG = MAX(M,J-NCOR)
             JG = MIN(M,J-NCOR)
             MJ = IA(MG) + JG
             MG = MAX(M,L-NCOR)
             LG = MIN(M,L-NCOR)
             ML = IA(MG) + LG
             MJG = MAX(MJ,ML)
             MLG = MIN(MJ,ML)
             MJML = IA(MJG) + MLG
             DVAL = TPDM(MJML)*XIJKL
             IF(J.NE.L) DVAL = TWO*DVAL
             PRCNDO(IMG) = PRCNDO(IMG) + TWO*DVAL
 3530      CONTINUE
 3600    CONTINUE
C
C          ----- Finished with current integral buffer -----
C
          CALL DDI_PROCDLB_NEXT(C_VOVO,IWP,ICNTR4)
C
        ENDDO
        CALL TSECND(T1)
        IF(IWP.EQ.ME  .AND.  MASWRK) WRITE(IW,9030) T1-T0
        CALL FLSHBF(IW)
        T0 = T1
C
 8000 CONTINUE
C
      CALL DDI_GSUMF(2160,DFC,L2*NXYZ)
      CALL DDI_GSUMF(2161,DERI,N4*NXYZ)
      CALL DDI_GSUMF(2162,DLAG,L3*NXYZ)
      CALL DDI_GSUMF(2163,FCOR,L2)
      CALL DDI_GSUMF(2164,ERI,L1*N2*NACT)
      CALL DDI_GSUMF(2165,PRCNDO,NROT)
      CALL DDI_GSUMF(2166,AMAT,L1*NCOR*N2)
C
 9000 FORMAT(/1X,'MASTER NODE HAS FINISHED WITH (OO|OO) INTEGRALS,',
     *           ' T=',F7.1)
 9010 FORMAT(1X,'MASTER NODE HAS FINISHED WITH (VO|OO) INTEGRALS,',
     *           ' T=',F7.1)
 9020 FORMAT(1X,'MASTER NODE HAS FINISHED WITH (VV|OO) INTEGRALS,',
     *           ' T=',F7.1)
 9030 FORMAT(1X,'MASTER NODE HAS FINISHED WITH (VO|VO) INTEGRALS,',
     *           ' T=',F7.1)
      RETURN
      END
C*MODULE CPMCHF  *DECK POSCP
C     -------------------------------------------
      INTEGER FUNCTION POSCP(NACT,NOEL,CON,IFA)
C     -------------------------------------------
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER CON(NOEL),POS1,I,J
      DIMENSION IFA(0:NACT,0:NACT)
C
C     This function is the same as POSDET in ALDECI
C
      POS1 = 0
      POSCP = 1
      DO 33 I=1,NOEL
         DO 55 J=POS1+1,CON(I)-1
            POSCP = POSCP + IFA(NACT-J,NOEL-I)
   55    CONTINUE
         POS1 = CON(I)
   33 CONTINUE
C
      RETURN
      END
C*MODULE CPMCHF  *DECK RET1CP
C     --------------------------------------------------------
      SUBROUTINE RET1CP(IBCON1,IBCON2,NB,IB,JJ,NCOR,KKJ,IPER)
C     --------------------------------------------------------
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION IBCON1(*),IBCON2(*)
C
C     This routine is the same as RET1DET in ALDECI
C
      IF (JJ.LT.IBCON1(IB)) THEN
         DO 870 KI=1,KKJ-1
               IBCON2(KI) = IBCON1(KI+NCOR)-NCOR
  870    CONTINUE
         IBCON2(KKJ) = JJ-NCOR
         IPR = KKJ
         DO 875 KI=KKJ,NB
              IF (KI+NCOR.EQ.IB) GOTO 875
            IPR = IPR+1
            IBCON2(IPR) = IBCON1(KI+NCOR)-NCOR
  875    CONTINUE
         IPER = IB-KKJ-NCOR
      ELSE
         IPR = 0
         DO 880 KI=1,KKJ-1
            IF (KI+NCOR.EQ.IB) GOTO 880
              IPR = IPR + 1
              IBCON2(IPR) = IBCON1(KI+NCOR)-NCOR
  880    CONTINUE
            IBCON2(KKJ-1) = JJ-NCOR
            DO 885 KI=KKJ,NB
                 IBCON2(KI) = IBCON1(KI+NCOR)-NCOR
  885       CONTINUE
            IPER = KKJ-1-IB+NCOR
      ENDIF
C
      RETURN
      END
C*MODULE CPMCHF  *DECK UAFCM
      SUBROUTINE UAFCM(FCM,DDM,YAO,YAC,DDEN,WAXO,WAXC,SDER,CI,EG,OPDM,
     *                 VEC,DIPAO,DIPMO,WRK,INDEX,NOCP,IA,L0,L1,L2,NXYZ,
     *                 NUNIQ,NROT,NDETLN,NCOR,NACT,NNACT,JLO,JHI,NFT18,
     *                 NFT19)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,SVDSKW
C
      DIMENSION FCM(NXYZ,NXYZ),DDM(3*NXYZ),YAO(NUNIQ,NROT),
     *          YAC(NUNIQ,NDETLN),DDEN(NUNIQ,NNACT),WAXO(NROT),
     *          WAXC(NDETLN),SDER(NXYZ,L1,L1),CI(*),EG(NXYZ),
     *          OPDM(*),VEC(L1,L1),DIPAO(*),DIPMO(*),WRK(*)
      DIMENSION INDEX(L1,L1),NOCP(NXYZ),IA(*)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00,TWO=2.0D+00,FOUR=4.0D+00)
      PARAMETER (TOL=1.0D-09)
C
      L3 = L1*L1
      NOCC = NCOR + NACT
C
      SVDSKW = DSKWRK
      DSKWRK = .FALSE.
      CALL SEQREW(NFT18)
C
C     ----- Add orbital perturbation to force constant matrix -----
C
      DO 100 IXYZ=1,NXYZ
        CALL SQREAD(NFT18,WRK,L3)
        CALL VCLR(WAXO,1,NROT)
C
        DO 50 J=1,NOCC
          DO 50 I=1,L1
            IJ = (J-1)*L1 + I
            IPHSE = INDEX(I,J)
            IROT = IABS(IPHSE)
            IF(IROT.EQ.0) GO TO 50
            DLT = IROT
            DLT = DLT/IPHSE
            WAXO(IROT) = WAXO(IROT) + DLT*WRK(IJ)
   50   CONTINUE
        CALL DSCAL(NROT,TWO,WAXO,1)
C
        JUNIQ = 0
        DO 80 JXYZ=1,NXYZ
          NJXYZ = NOCP(JXYZ)
          IF(NJXYZ.NE.1) JUNIQ = JUNIQ + 1
C
          DVAL = DDOT(L3,WRK,1,SDER(JXYZ,1,1),NXYZ)
          DVAL = -DVAL
          IF(NJXYZ.EQ.0) THEN
            DVAL = DVAL + DDOT(NROT,YAO(JUNIQ,1),NUNIQ,WAXO,1)
          ENDIF
          FCM(IXYZ,JXYZ) = FCM(IXYZ,JXYZ) + DVAL
   80   CONTINUE
  100 CONTINUE
C
C     ----- Add config. perturbation to force constant matrix -----
C
      IF(GOPARR) CALL DSCAL(NXYZ*NXYZ,ONE/NPROC,FCM,1)
C
      DSKWRK = .TRUE.
      CALL SEQREW(NFT19)
C
      DO 200 IXYZ=1,NXYZ
        CALL SQREAD(NFT19,WAXC,NDETLN)
        CALL DSCAL(NDETLN,TWO,WAXC,1)
C
        JUNIQ = 0
        DO 180 JXYZ=1,NXYZ
          NJXYZ = NOCP(JXYZ)
          IF(NJXYZ.EQ.1) GO TO 180
          JUNIQ = JUNIQ + 1
C
          DO 160 M=JLO,JHI
            MM = M-JLO+1
            YVAL = YAC(JUNIQ,MM)
            IF(ABS(YVAL).LT.TOL) GO TO 160
            CVAL = FOUR*CI(M)
C
            DVAL = YVAL*WAXC(MM)
            DVAL = DVAL - CVAL*YVAL*EG(IXYZ)
            FCM(IXYZ,JXYZ) = FCM(IXYZ,JXYZ) + DVAL
  160     CONTINUE
  180   CONTINUE
  200 CONTINUE
C
      IF(GOPARR) CALL DDI_GSUMF(2187,FCM,NXYZ*NXYZ)
C
      DSKWRK = SVDSKW
C
C     ----- Form complete MO derivative -----
C
      DO 300 I=1,L1
        DO 300 J=1,L1
          IPHSE = INDEX(I,J)
          IJ = IABS(IPHSE)
          IF(IJ.EQ.0) GO TO 300
          DLT = TWO*IJ/IPHSE
          IUNIQ = 0
          DO 250 IXYZ=1,NXYZ
            IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
            IF(NOCP(IXYZ).NE.0) GO TO 250
            SDER(IXYZ,I,J) = SDER(IXYZ,I,J) - DLT*YAO(IUNIQ,IJ)
  250     CONTINUE
  300 CONTINUE
C
C     ----- Add derivative overlap and response terms to -----
C     -----               dipole derivative              -----
C
      DO 1000 IXYZ=1,3
C
C          ----- Transform dipole integrals to MO basis -----
C
        CALL DAREAD(IDAF,IODA,DIPAO,L2,95+IXYZ-1,0)
        CALL TFTRI(DIPMO,DIPAO,VEC,WRK,L0,L1,L1)
        CALL DAWRIT(IDAF,IODA,DIPMO,L2,252+IXYZ-1,0)
C
C          ----- Construct dipole "Lagrangian" -----
C
        CALL VCLR(WRK,1,L3)
        DO 400 I=1,L0
          DO J=1,NCOR
            II = MAX(I,J)
            JJ = MIN(I,J)
            IJ = IA(II)+JJ
            JI = (J-1)*L1 + I
            WRK(JI) = TWO*DIPMO(IJ)
          ENDDO
C
          DO 400 J=1,NACT
            DVAL = ZERO
            DO M=1,NACT
              JJ = MAX(J,M)
              MM = MIN(J,M)
              JM = IA(JJ)+MM
              II = MAX(I,M+NCOR)
              MM = MIN(I,M+NCOR)
              IM = IA(II)+MM
              DVAL = DVAL + DIPMO(IM)*OPDM(JM)
            ENDDO
            JI = (J+NCOR-1)*L1 + I
            WRK(JI) = DVAL
  400   CONTINUE
C
C          ----- Add response contributions to dipole derivative -----
C
        DO JXYZ=1,NXYZ
          IJXYZ = (JXYZ-1)*3 + IXYZ
          DDM(IJXYZ) = DDOT(L3,SDER(JXYZ,1,1),NXYZ,WRK,1)
        ENDDO
C
        DO 500 I=1,NACT
          DO 500 J=1,I
            IJ = IA(I+NCOR) + J+NCOR
            IIJJ = IA(I) + J
            DLT = TWO
            IF(I.EQ.J) DLT = ONE
            DLT = DLT*DIPMO(IJ)
            JUNIQ = 0
            DO 450 JXYZ=1,NXYZ
              NJXYZ = NOCP(JXYZ)
              IF(NJXYZ.NE.1) JUNIQ = JUNIQ + 1
              IF(NJXYZ.NE.0) GO TO 450
              JIXYZ = (JXYZ-1)*3 + IXYZ
              DDM(JIXYZ) = DDM(JIXYZ) - DLT*DDEN(JUNIQ,IIJJ)
  450       CONTINUE
  500   CONTINUE
 1000 CONTINUE
C
      RETURN
      END
C*MODULE CPMCHF  *DECK CPCHK1
      SUBROUTINE CPCHK1(MEMREP,IW,NSTATS,NXYZ,NDETMX)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      WRITE(IW,9000)
C
C     1 processor
C
      MEMCON = MEMREP
      MEMDIS = 0
      NDETLN = NDETMX
      MEMDIS = MEMDIS + NXYZ + 2
      MEMCON = MEMCON - MEMDIS*NSTATS*NDETMX
      MEMDIS = MEMDIS*NDETLN*NSTATS
      MEMTOT = MEMCON + MEMDIS
      MWDTOT = MEMTOT/1000000
      IF(MOD(MEMTOT,1000000).GT.0) MWDTOT = MWDTOT + 1
      WRITE(IW,9010) 1,MEMCON,MEMDIS,MWDTOT
C
C     2 processors
C
      MEMCON = MEMREP
      MEMDIS = 0
      NDETLN = NDETMX/2
      IF(MOD(NDETMX,2).GT.0) NDETLN = NDETLN + 1
      MEMDIS = MEMDIS + NXYZ + 2
      MEMCON = MEMCON - MEMDIS*NSTATS*NDETMX
      MEMDIS = MEMDIS*NDETLN*NSTATS
      MEMTOT = MEMCON + MEMDIS
      MWDTOT = MEMTOT/1000000
      IF(MOD(MEMTOT,1000000).GT.0) MWDTOT = MWDTOT + 1
      WRITE(IW,9010) 2,MEMCON,MEMDIS,MWDTOT
C
C     4 processors
C
      MEMCON = MEMREP
      MEMDIS = 0
      NDETLN = NDETMX/4
      IF(MOD(NDETMX,4).GT.0) NDETLN = NDETLN + 1
      MEMDIS = MEMDIS + NXYZ + 2
      MEMCON = MEMCON - MEMDIS*NSTATS*NDETMX
      MEMDIS = MEMDIS*NDETLN*NSTATS
      MEMTOT = MEMCON + MEMDIS
      MWDTOT = MEMTOT/1000000
      IF(MOD(MEMTOT,1000000).GT.0) MWDTOT = MWDTOT + 1
      WRITE(IW,9010) 4,MEMCON,MEMDIS,MWDTOT
C
C     8 processors
C
      MEMCON = MEMREP
      MEMDIS = 0
      NDETLN = NDETMX/8
      IF(MOD(NDETMX,8).GT.0) NDETLN = NDETLN + 1
      MEMDIS = MEMDIS + NXYZ + 2
      MEMCON = MEMCON - MEMDIS*NSTATS*NDETMX
      MEMDIS = MEMDIS*NDETLN*NSTATS
      MEMTOT = MEMCON + MEMDIS
      MWDTOT = MEMTOT/1000000
      IF(MOD(MEMTOT,1000000).GT.0) MWDTOT = MWDTOT + 1
      WRITE(IW,9010) 8,MEMCON,MEMDIS,MWDTOT
C
C     16 processors
C
      MEMCON = MEMREP
      MEMDIS = 0
      NDETLN = NDETMX/16
      IF(MOD(NDETMX,16).GT.0) NDETLN = NDETLN + 1
      MEMDIS = MEMDIS + NXYZ + 2
      MEMCON = MEMCON - MEMDIS*NSTATS*NDETMX
      MEMDIS = MEMDIS*NDETLN*NSTATS
      MEMTOT = MEMCON + MEMDIS
      MWDTOT = MEMTOT/1000000
      IF(MOD(MEMTOT,1000000).GT.0) MWDTOT = MWDTOT + 1
      WRITE(IW,9010) 16,MEMCON,MEMDIS,MWDTOT
C
 9000 FORMAT(/1X,'SETTING UP RIGHT-HAND SIDE OF CPMCHF EQUATIONS.',
     *       /1X,'FOLLOWING TABLE ILLUSTRATES MEMORY REQUIREMENTS.',/,
     *       /11X,'CONSTANT',7X,'SCALABLE',6X,'TOTAL',
     *       /1X,'# CPUS',3X,'REPLICATED',5X,'REPLICATED',5X,'MWORDS',
     *       /1X,6(1H-),3X,10(1H-),5X,10(1H-),5X,6(1H-))
 9010 FORMAT(3X,I2,5X,I10,5X,I10,5X,I4)
      RETURN
      END
C*MODULE CPMCHF  *DECK CPCHK2
      SUBROUTINE CPCHK2(MEMREP,IW,NSTATS,NUNIQ,NXYZ,NDETMX,L3)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      WRITE(IW,9000)
C
C     1 processor
C
      MEMCON = MEMREP
      MEMDIS = 0
      NDETLN = NDETMX
      IF(NSTATS*NDETLN .GT. L3) MEMDIS = 1
      MEMDIS = MEMDIS + 2*NUNIQ + NXYZ + 1
      MEMCON = MEMCON - MEMDIS*NSTATS*NDETMX
      MEMDIS = MEMDIS*NDETLN*NSTATS
      MEMTOT = MEMCON + MEMDIS
      MWDTOT = MEMTOT/1000000
      IF(MOD(MEMTOT,1000000).GT.0) MWDTOT = MWDTOT + 1
      WRITE(IW,9010) 1,MEMCON,MEMDIS,MWDTOT
C
C     2 processors
C
      MEMCON = MEMREP
      MEMDIS = 0
      NDETLN = NDETMX/2
      IF(MOD(NDETMX,2).GT.0) NDETLN = NDETLN + 1
      IF(NSTATS*NDETLN .GT. L3) MEMDIS = 1
      MEMDIS = MEMDIS + 2*NUNIQ + NXYZ + 1
      MEMCON = MEMCON - MEMDIS*NSTATS*NDETMX
      MEMDIS = MEMDIS*NDETLN*NSTATS
      MEMTOT = MEMCON + MEMDIS
      MWDTOT = MEMTOT/1000000
      IF(MOD(MEMTOT,1000000).GT.0) MWDTOT = MWDTOT + 1
      WRITE(IW,9010) 2,MEMCON,MEMDIS,MWDTOT
C
C     4 processors
C
      MEMCON = MEMREP
      MEMDIS = 0
      NDETLN = NDETMX/4
      IF(MOD(NDETMX,4).GT.0) NDETLN = NDETLN + 1
      IF(NSTATS*NDETLN .GT. L3) MEMDIS = 1
      MEMDIS = MEMDIS + 2*NUNIQ + NXYZ + 1
      MEMCON = MEMCON - MEMDIS*NSTATS*NDETMX
      MEMDIS = MEMDIS*NDETLN*NSTATS
      MEMTOT = MEMCON + MEMDIS
      MWDTOT = MEMTOT/1000000
      IF(MOD(MEMTOT,1000000).GT.0) MWDTOT = MWDTOT + 1
      WRITE(IW,9010) 4,MEMCON,MEMDIS,MWDTOT
C
C     8 processors
C
      MEMCON = MEMREP
      MEMDIS = 0
      NDETLN = NDETMX/8
      IF(MOD(NDETMX,8).GT.0) NDETLN = NDETLN + 1
      IF(NSTATS*NDETLN .GT. L3) MEMDIS = 1
      MEMDIS = MEMDIS + 2*NUNIQ + NXYZ + 1
      MEMCON = MEMCON - MEMDIS*NSTATS*NDETMX
      MEMDIS = MEMDIS*NDETLN*NSTATS
      MEMTOT = MEMCON + MEMDIS
      MWDTOT = MEMTOT/1000000
      IF(MOD(MEMTOT,1000000).GT.0) MWDTOT = MWDTOT + 1
      WRITE(IW,9010) 8,MEMCON,MEMDIS,MWDTOT
C
C     16 processors
C
      MEMCON = MEMREP
      MEMDIS = 0
      NDETLN = NDETMX/16
      IF(MOD(NDETMX,16).GT.0) NDETLN = NDETLN + 1
      IF(NSTATS*NDETLN .GT. L3) MEMDIS = 1
      MEMDIS = MEMDIS + 2*NUNIQ + NXYZ + 1
      MEMCON = MEMCON - MEMDIS*NSTATS*NDETMX
      MEMDIS = MEMDIS*NDETLN*NSTATS
      MEMTOT = MEMCON + MEMDIS
      MWDTOT = MEMTOT/1000000
      IF(MOD(MEMTOT,1000000).GT.0) MWDTOT = MWDTOT + 1
      WRITE(IW,9010) 16,MEMCON,MEMDIS,MWDTOT
C
 9000 FORMAT(1X,'SOLVING CPMCHF EQUATIONS.',
     *       /1X,'FOLLOWING TABLE ILLUSTRATES MEMORY REQUIREMENTS.',/,
     *       /11X,'CONSTANT',7X,'SCALABLE',6X,'TOTAL',
     *       /1X,'# CPUS',3X,'REPLICATED',5X,'REPLICATED',5X,'MWORDS',
     *       /1X,6(1H-),3X,10(1H-),5X,10(1H-),5X,6(1H-))
 9010 FORMAT(3X,I2,5X,I10,5X,I10,5X,I4)
      RETURN
      END
C*MODULE CPMCHF  *DECK CPDRDO
C     ----------------------------------------------------------------
      SUBROUTINE CPDRDO(WAXCI,DFC,DERI,CI,FCOR,ERI,PRCNDC,
     *     NCOR,JLO,JHI,NSTATS,NDETLN,
     *     M2,M4,NXYZ,L1,NACT,NCI,NA,NB,
     *     Y,NX,INDEX,NSYM,IOB,
     *     LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,
     *     LGMUL,KTAB,IACON1,IACON2,IBCON1,IBCON2,
     *     LANDET,LBNDET,NAST,NBST,LSYMA,LSYMB,LGCOM,
     *     LSPA,LSPB,LDISB,LSAS,LSBS,LSAC,LSBC,
     *     ITGA,ITGB,IAST,IBST,
     *     IPOSA,IPERA,IIND1,IGROA,IMMC,
     *     NB1EX,JB1GR,JB1PE,JB1IN,JB1PO,JB1ST,IDIM1,IDIM2)
C     ----------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL FDIRCT,QCORR
C
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIM(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
C
      DIMENSION WAXCI(NXYZ,NSTATS*NDETLN),DFC(NXYZ,M2),DERI(NXYZ,M4)
      DIMENSION CI(NCI,NSTATS),FCOR(*),ERI(L1,NACT,M2),PRCNDC(*)
      DIMENSION Y(NX)
      DIMENSION INDEX((NACT*(NACT+1))/2+1),IOB(NACT)
      DIMENSION LBOX1(NSPACE),LBOX2(NSPACE),LBOX3(NSPACE)
      DIMENSION LBOX4(NSPACE),LBOX5(NSPACE)
      DIMENSION LGMUL(NSYM,NSYM),KTAB(NSYM)
      DIMENSION IACON1(NA),IACON2(NA),IBCON1(NA),IBCON2(NA)
      DIMENSION LANDET(NSPACE,ITGA),LBNDET(NSPACE,ITGB)
      DIMENSION NAST(ITGA+1),NBST(ITGB+1)
      DIMENSION LSYMA(IAST),LSYMB(IBST),LGCOM(ITGB,ITGA)
      DIMENSION LSPA(IAST),LSPB(IBST),LDISB(NSYM,ITGB,ITGA)
      DIMENSION LSAS(NSYM+1,ITGA),LSBS(NSYM+1,ITGB)
      DIMENSION LSAC(IAST),LSBC(IBST)
      DIMENSION IPOSA(NA*(NACT-NA),NSYM)
      DIMENSION IPERA(NA*(NACT-NA),NSYM)
      DIMENSION IIND1(NA*(NACT-NA),NSYM)
      DIMENSION IGROA(NA*(NACT-NA),NSYM)
      DIMENSION IMMC(NSYM)
      DIMENSION JB1GR(NB1EX),JB1PE(NB1EX),JB1IN(NB1EX),JB1PO(NB1EX)
      DIMENSION JB1ST(IDIM1,IDIM2)
C
C  --- BIG LOOP OVER ALL ALPHA STRINGS. ---
C
      CALL RESETCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX5)
C
      DO 5000 IGA=1,ITGA
C
         CALL RESETDE(LBOX1,NSPACE,NA,MSTA,IACON1)
C
C  KKA GIVES THE ACTUAL POSITION OF THE ALPHA STRING IACON1 IN
C  THE FULL ALPHA STRING LIST.
C
         DO 4900 KKA=NAST(IGA)+1,NAST(IGA+1)
            JPZA1 = LSPA(KKA)
            JASYM = LSYMA(KKA)
            KSYM=KTAB(JASYM)
            DO II=1,NSYM
               IMMC(II)=0
            ENDDO
C
            DO II=1,NSPACE
               LBOX2(II) = LBOX1(II)
            ENDDO
C
C  LOOP OVER SPACES TO EXCITE ELECTRON FROM.
C
            IEAS = NA+1
            DO 4890 ISPA1=NSPACE,1,-1
               IOC1 = LBOX1(ISPA1)
               IEAE = IEAS - 1
               IEAS = IEAS - IOC1
               IF (IOC1.EQ.0) GO TO 4890
               LBOX2(ISPA1) = LBOX2(ISPA1)-1
C
C  LOOP ELECTRONS IN SPACE ISPA1.
C  IEAS, IEAE ARE THE ELECTRONS IN SPACE ISPA1.
C
               DO 4885 IA1=IEAE,IEAS,-1
                  IO1 = IACON1(IA1)
                  IGAE = IEAE - LBOX1(ISPA1)
                  IS1 = IOB(IO1)
C
C  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
C
               DO 4880 ISPA2=ISPA1,NSPACE
C
C  IGAS, IGAE ARE ELECTRONS SPECIFYING ISPA2 SPACE ELECTRON LIMITS.
C
                  IGAS = IGAE + 1
                  IGAE = IGAE + LBOX1(ISPA2)
C
                  LBOX2(ISPA2) = LBOX2(ISPA2) + 1
                  IF (LBOX2(ISPA1).LT.IAMI(ISPA1)) GO TO 4870
C
C  MAKE GAP INFORMATION HERE.
C
                  IGAA = MAX(IA1+1,IGAS)
                  IF (LBOX1(ISPA2).EQ.0) THEN
                     ISTA = MSTA(ISPA2)
                     IEND = MSTA(ISPA2+1)-1
                  ELSEIF (ISPA2.EQ.ISPA1) THEN
                     ISTA = IO1+1
                     IEND = IACON1(IGAA)-1
                     IF (IA1.EQ.IEAE) IEND=MSTA(ISPA1+1)-1
                  ELSE
                     ISTA = MSTA(ISPA2)
                     IEND = IACON1(IGAA)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 4860 IGAP=IGAA,IGAE+1
C
                     DO 4850 JJ=ISTA,IEND
                        IS2 = IOB(JJ)
                        IP1 = LGMUL(IS1,IS2)
C
                     IND = INDEX(JJ) + IO1
C
              CALL REDE00(IACON1,IACON2,NA,IA1,IGAP-1,JJ,JPERA)
              IF (LBOX2(ISPA2).GT.IAMA(ISPA2)) GO TO 4800
C
C  GET GROUP NUMBER
C
           CALL POSITCO(LBOX5,NSPACE,NA,IAMA,IAMI,LBOX4,LBOX2,IGA2)
           NIAS = NAST(IGA2)
C
              CALL IDPOST(IACON2,NA,LBOX2,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LANDET(1,IGA2),IBCON1,JPOSA)
              KAPOS = JPOSA + NIAS
              JPZA2 = LSPA(KAPOS)
              KASYM = LSYMA(KAPOS)
C              KPER1 = ((-1)**JPERA)*2
              KPER1 = (-1)**JPERA
              IMMC(KASYM) = IMMC(KASYM) + 1
              JSPO = IMMC(KASYM)
              IPOSA(JSPO,KASYM) = JPZA2
              IPERA(JSPO,KASYM) = KPER1
              IIND1(JSPO,KASYM) = IND
              IGROA(JSPO,KASYM) = IGA2
C
C   IF DEOCCUPIED AND NEWLY OCCUPIED ORBITALS ARE OF DIFFERENT SYMMETRY,
C   SKIP TO DOUBLES.
C
              IF (IS1.NE.IS2) GO TO 4800
C
C  LOOP OVER APPROPRIATE BETA DETS
C
              DO 1700 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB,IGA2).NE.1) GOTO 1700
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
              JCI2 = JPZA2 + LDISB(KSYM,IGB,IGA2)
C
              DO 1680 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 JCI1 = JCI1 + 1
                 JCI2 = JCI2 + 1
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = KPER1*CI(JCI2,ISTAT)
                     IWI1 = (ISTAT-1)*NDETLN + JCI1 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DFC(1,IND),1,WAXCI(1,IWI1),1)
                   ENDDO
                 ENDIF
C
                 IF(JCI2.GE.JLO .AND. JCI2.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = KPER1*CI(JCI1,ISTAT)
                     IWI2 = (ISTAT-1)*NDETLN + JCI2 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DFC(1,IND),1,WAXCI(1,IWI2),1)
                   ENDDO
                 ENDIF
C
 1680         CONTINUE
C
 1700         CONTINUE
C
C   DETERMINE THE ALPHA STRING CONTRIBUTION TO THE MATRIX ELEMENT.
C
              DO 4712 IK=1,NA
                 IF (IK.EQ.IA1) GO TO 4712
                 ION = IACON1(IK)
                 J1 = INDEX(ION+1)
                 JMA = MAX(J1,IND)
                 JMI = MIN(J1,IND)
                 JJ1 = INDEX(JMA) + JMI
                 JMA = MAX(ION,JJ)
                 JMI = MIN(ION,JJ)
                 J1 = INDEX(JMA)+JMI
                 JMA = MAX(IO1,ION)
                 JMI = MIN(IO1,ION)
                 J2 = INDEX(JMA)+JMI
                 JMA = MAX(J1,J2)
                 JMI = MIN(J1,J2)
                 INX = INDEX(JMA)+JMI
C
C  LOOP OVER APPROPRIATE BETA DETS
C
              DO 1705 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB,IGA2).NE.1) GOTO 1705
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
              JCI2 = JPZA2 + LDISB(KSYM,IGB,IGA2)
C
              DO 1685 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 JCI1 = JCI1 + 1
                 JCI2 = JCI2 + 1
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = KPER1*CI(JCI2,ISTAT)
                     IWI1 = (ISTAT-1)*NDETLN + JCI1 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,JJ1),1,WAXCI(1,IWI1),1)
                     CALL DAXPY(NXYZ,-FC,DERI(1,INX),1,WAXCI(1,IWI1),1)
                   ENDDO
                 ENDIF
C
                 IF(JCI2.GE.JLO .AND. JCI2.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = KPER1*CI(JCI1,ISTAT)
                     IWI2 = (ISTAT-1)*NDETLN + JCI2 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,JJ1),1,WAXCI(1,IWI2),1)
                     CALL DAXPY(NXYZ,-FC,DERI(1,INX),1,WAXCI(1,IWI2),1)
                   ENDDO
                 ENDIF
C
 1685         CONTINUE
C
 1705         CONTINUE
C
 4712         CONTINUE
C
C  LOOP OVER BETA DETS OF THE RIGHT GROUP AND SYMMETRY.
C
              CALL RESETCO(LBOX3,NSPACE,NB,IBMA,IBMI,LBOX4)
C
              DO 4700 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB,IGA2).NE.1) GOTO 4690
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
              JCI2 = JPZA2 + LDISB(KSYM,IGB,IGA2)
C
              CALL RESETDE(LBOX3,NSPACE,NB,MSTA,IBCON1)
              ISTB = 1
              DO 4680 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 IENB = LSBC(KKB)
                 DO IIZ=ISTB,IENB-1
                    CALL MOVEUP2(LBOX3,NSPACE,NB,MSTA,IBCON1)
                 ENDDO
                 ISTB = IENB
                 JCI1 = JCI1 + 1
                 JCI2 = JCI2 + 1
C
                 DO 4670 IK=1,NB
                    ION = IBCON1(IK)
                    J1 = INDEX(ION+1)
                    JMA = MAX(J1,IND)
                    JMI = MIN(J1,IND)
                    JJ1 = INDEX(JMA) + JMI
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = KPER1*CI(JCI2,ISTAT)
                     IWI1 = (ISTAT-1)*NDETLN + JCI1 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,JJ1),1,WAXCI(1,IWI1),1)
                   ENDDO
                 ENDIF
C
                 IF(JCI2.GE.JLO .AND. JCI2.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = KPER1*CI(JCI1,ISTAT)
                     IWI2 = (ISTAT-1)*NDETLN + JCI2 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,JJ1),1,WAXCI(1,IWI2),1)
                   ENDDO
                 ENDIF
C
 4670            CONTINUE
C
 4680         CONTINUE
C
 4690         CALL PUSHCO(LBOX3,NSPACE,NB,IBMA,IBMI,LBOX4,IEND)
 4700         CONTINUE
C
C --  DOUBLE ALPHA EXCITATIONS START HERE  ---
C
 4800         CONTINUE
C
            IF (IA1.EQ.NA) GOTO 4850
            IF (JJ.EQ.NACT) GOTO 4850
C
            DO II=1,NSPACE
               LBOX3(II) = LBOX2(II)
            ENDDO
            IAES3 = 1
            DO KK=1,ISPA1-1
               IAES3 = IAES3 + LBOX2(KK)
            ENDDO
C
C  LOOP OVER SPACES TO EXCITE ELECTRONS FROM, MUST BE GE THAN
C  SPACE OF FIRST EXCITATION, ISPA1.
C
            DO 3890 ISPA3 = ISPA1,NSPACE
               IF (LBOX1(ISPA3).EQ.0) GOTO 3887
               IF (ISPA3.EQ.ISPA1.AND.IA1.EQ.IEAE) GOTO 3887
               IOC3 = LBOX2(ISPA3)
               IF (IOC3.EQ.0) GOTO 3887
C
               IAEE3 = IAES3 + LBOX2(ISPA3)-1
               LBOX3(ISPA3) = LBOX3(ISPA3)-1
C
C  LOOP OVER ELECTRONS IN ISPA3, WHICH ARE LARGER THAN IA1,
C  MAKING SURE IT ISN'T THE ALREADY EXCITED ELECTRON.
C
               JSTA3 = IAES3
               IF (ISPA3.EQ.ISPA1) THEN
                  JSTA3=IA1
                  IF (IGAP-1.EQ.IA1) JSTA3=JSTA3+1
               ENDIF
C
               DO 3880 IA3=JSTA3,IAEE3
                  IF (IA3.EQ.IGAP-1) GOTO 3880
                  IO3 = IACON2(IA3)
                  IS3 = IOB(IO3)
C
C  LOOP OVER SPACES TO EXCITE ELECTRON INTO.  MUST BE GE THAN
C  SPACE FIRST ELECTRON WAS EXCITED INTO.
C
                  IGAE3 = 0
                  DO JIK=1,ISPA2-1
                     IGAE3 = IGAE3 + LBOX2(JIK)
                  ENDDO
                  DO 3850 ISPA4=ISPA2,NSPACE
C
C  IGAS3, IGAE3 ARE ELECTRONS SPECIFYING ISPA4 SPACE ELECTRON LIMITS.
C
                  LBOX3(ISPA4) = LBOX3(ISPA4) + 1
                  IGAS3 = IGAE3 + 1
                  IGAE3 = IGAE3 + LBOX2(ISPA4)
                  IF (LBOX3(ISPA3).LT.IAMI(ISPA3)) GOTO 3840
                  IF (LBOX3(ISPA4).GT.IAMA(ISPA4)) GOTO 3840
             IF (ISPA4.EQ.ISPA2.AND.JJ.EQ.MSTA(ISPA2+1)-1) GOTO 3840
C
C  GET GROUP NUMBER
C
               CALL POSITCO(LBOX5,NSPACE,NA,IAMA,IAMI,LBOX4,LBOX3,IGA3)
               NIAS3 = NAST(IGA3)
C
C  MAKE GAP INFORMATION HERE.
C
                  IGAA3 = MAX(IGAS3,IGAP)
C
                  IF (LBOX2(ISPA4).EQ.0) THEN
                     ISTA3 = MSTA(ISPA4)
                     IEND3 = MSTA(ISPA4+1)-1
                  ELSEIF (ISPA4.EQ.ISPA2) THEN
                     ISTA3 = JJ+1
                     IEND3 = IACON2(IGAA3)-1
C
C  I AM SUSPECT ABOUT THIS NEXT LINE, WE'LL SEE WHAT HAPPENS.......
C
                     IF (IGAP-1.EQ.IGAE3) IEND3=MSTA(ISPA2+1)-1
C
                  ELSE
                     ISTA3 = MSTA(ISPA4)
                     IEND3 = IACON2(IGAA3)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 3830 IGAP3=IGAA3,IGAE3+1
C
                     DO 3820 JJ3=ISTA3,IEND3
                        IS4 = IOB(JJ3)
                        IP2 = LGMUL(IS3,IS4)
                        IF (IP1.NE.IP2) GOTO 3820
C
              CALL REDE00(IACON2,IBCON1,NA,IA3,IGAP3-1,JJ3,JPERA3)
              CALL IDPOST(IBCON1,NA,LBOX3,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LANDET(1,IGA3),IBCON2,JPOSA3)
C              IPER3 = ((-1)**(JPERA3+JPERA))*2
              IPER3 = (-1)**(JPERA3+JPERA)
              KAPOS3 = JPOSA3 + NIAS3
              JPZA3 = LSPA(KAPOS3)
                 JMA=MAX(JJ3,IO3)
                 JMI=MIN(JJ3,IO3)
                 I2 = INDEX(JMA) + JMI
                 INX = INDEX(I2) + IND
                 II1 = INDEX(JJ3) + IO1
                 JMA=MAX(IO3,JJ)
                 JMI=MIN(IO3,JJ)
                 II2 = INDEX(JMA) + JMI
                 JMA=MAX(II1,II2)
                 JMI=MIN(II1,II2)
                 INX2 = INDEX(JMA) + JMI
C
C  LOOP OVER BETA STRINGS OF RIGHT SYMMETRY AND GROUP.
C
              DO 3700 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB,IGA3).NE.1) GOTO 3700
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
              JCI3 = JPZA3 + LDISB(KSYM,IGB,IGA3)
C
              DO 3680 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 JCI1 = JCI1 + 1
                 JCI3 = JCI3 + 1
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = IPER3*CI(JCI3,ISTAT)
                     IWI1 = (ISTAT-1)*NDETLN + JCI1 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,INX),1,WAXCI(1,IWI1),1)
                     CALL DAXPY(NXYZ,-FC,DERI(1,INX2),1,WAXCI(1,IWI1),1)
                   ENDDO
                 ENDIF
C
                 IF(JCI3.GE.JLO .AND. JCI3.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = IPER3*CI(JCI1,ISTAT)
                     IWI3 = (ISTAT-1)*NDETLN + JCI3 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,INX),1,WAXCI(1,IWI3),1)
                     CALL DAXPY(NXYZ,-FC,DERI(1,INX2),1,WAXCI(1,IWI3),1)
                   ENDDO
                 ENDIF
C
 3680         CONTINUE
C
 3700         CONTINUE
C
 3820                CONTINUE
C
                     ISTA3 = IACON2(IGAP3)+1
                     IEND3 = IACON2(IGAP3+1)-1
                     IF (IGAP3.EQ.IGAE3) IEND3=MSTA(ISPA4+1)-1
 3830             CONTINUE
C
 3840             LBOX3(ISPA4) = LBOX3(ISPA4) - 1
 3850             CONTINUE
C
 3880          CONTINUE
C
               LBOX3(ISPA3) = LBOX3(ISPA3)+1
 3887          IAES3 = IAES3 + LBOX3(ISPA3)
 3890       CONTINUE
C
 4850                CONTINUE
C
                  ISTA = IACON1(IGAP)+1
                  IEND = IACON1(IGAP+1)-1
                  IF (IGAP.EQ.IGAE) IEND=MSTA(ISPA2+1)-1
 4860             CONTINUE
C
 4870             LBOX2(ISPA2) = LBOX2(ISPA2) - 1
 4880          CONTINUE
C
 4885          CONTINUE
C
               LBOX2(ISPA1) = LBOX2(ISPA1)+1
 4890       CONTINUE
C
C  DIAGONAL ELEMENTS HERE
C
            DO 67 II=1,NA
               I1 = IACON1(II)
               IND1 = INDEX(I1+1)
               IIFC = ((NCOR+I1)*(NCOR+I1+1))/2
C
C  LOOP OVER BETA STRINGS OF RIGHT SYMMETRY AND GROUP.
C
              DO 3705 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1) GOTO 3705
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
C
              DO 3685 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 JCI1 = JCI1 + 1
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = CI(JCI1,ISTAT)
                     IWI1 = (ISTAT-1)*NDETLN + JCI1 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DFC(1,IND1),1,WAXCI(1,IWI1),1)
                     PRCNDC(IWI1) = PRCNDC(IWI1) + FCOR(IIFC)
                   ENDDO
                 ENDIF
C
 3685         CONTINUE
C
 3705         CONTINUE
C
              DO 64 JJ=II+1,NA
                 I2 = IACON1(JJ)
                 IND2 = INDEX(I2+1)
                 INDM = IND2 - I2 + I1
                 J1 = INDEX(INDM+1)
                 J2 = INDEX(IND2) + IND1
C
              DO 3710 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1) GOTO 3710
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
C
              DO 3690 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 JCI1 = JCI1 + 1
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = CI(JCI1,ISTAT)
                     IWI1 = (ISTAT-1)*NDETLN + JCI1 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,J2),1,WAXCI(1,IWI1),1)
                     CALL DAXPY(NXYZ,-FC,DERI(1,J1),1,WAXCI(1,IWI1),1)
                     PRCNDC(IWI1) = PRCNDC(IWI1) + ERI(I1+NCOR,I1,IND2)
                     PRCNDC(IWI1) = PRCNDC(IWI1) - ERI(I1+NCOR,I2,INDM)
                   ENDDO
                 ENDIF
C
 3690         CONTINUE
C
 3710         CONTINUE
C
   64         CONTINUE
C
C  LOOP OVER BETA DETS OF THE RIGHT GROUP AND SYMMETRY.
C
              CALL RESETCO(LBOX3,NSPACE,NB,IBMA,IBMI,LBOX4)
C
              DO 4709 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1) GOTO 4699
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
C
              CALL RESETDE(LBOX3,NSPACE,NB,MSTA,IBCON1)
              ISTB = 1
              DO 4689 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 IENB = LSBC(KKB)
                 DO IIZ=ISTB,IENB-1
                    CALL MOVEUP2(LBOX3,NSPACE,NB,MSTA,IBCON1)
                 ENDDO
                 ISTB = IENB
                 JCI1 = JCI1 + 1
                 IF(JCI1.LT.JLO .OR. JCI1.GT.JHI) GO TO 4689
C
                 DO 4679 IK=1,NB
                    I2 = IBCON1(IK)
                    IND2 = INDEX(I2+1)
                    JMI = MIN(IND1,IND2)
                    JMA = MAX(IND1,IND2)
                    J2 = INDEX(JMA) + JMI
C
                    DO ISTAT=1,NSTATS
                      FC = CI(JCI1,ISTAT)
                      IWI1 = (ISTAT-1)*NDETLN + JCI1 - JLO + 1
                      CALL DAXPY(NXYZ,FC,DERI(1,J2),1,WAXCI(1,IWI1),1)
                      PRCNDC(IWI1) = PRCNDC(IWI1) + ERI(I1+NCOR,I1,IND2)
                    ENDDO
C
 4679            CONTINUE
C
 4689         CONTINUE
C
 4699         CALL PUSHCO(LBOX3,NSPACE,NB,IBMA,IBMI,LBOX4,IEND)
 4709         CONTINUE
C
   67       CONTINUE
C
C  --- END OF LOOP OVER SINGLE ALPHA EXCITATIONS. ---
C      NOW TO SORT THEM BY POSITIONS WITHIN SYMMETRIES.
C
            DO II=1,NSYM
               CALL FCCSRT3(IGROA(1,II),IPERA(1,II),IIND1(1,II),
     *                   IPOSA(1,II),IMMC(II))
            ENDDO
C
C  --- END OF LOOP OVER PURE ALPHA EXCITATIONS.
C  NOW TO LOOP OVER ALL SIMULTANEOUS AB -> A'B' EXCITATIONS.
C
      IF (NSPACE.EQ.1) GOTO 3400
C
C  ***** GENERAL CASE OF MORE THAN ONE SPACE !!!!! *******
C
      IF (.NOT.FDIRCT) THEN
C
C  LOOP OVER SINGLE ALPHA EXCITES WITHIN EACH SYMMETRY.
C
      DO 3000 ISAE=1,NSYM
         KBSYM=KTAB(ISAE)
         DO 2900 JSAE=1,IMMC(ISAE)
            JPOSAE=IPOSA(JSAE,ISAE)
            JPERAE=IPERA(JSAE,ISAE)
            JINDAE=IIND1(JSAE,ISAE)
            JGROAE=IGROA(JSAE,ISAE)
C
C  IF ISAE.EQ.JASYM THEN SPECIAL CASE.
C
       IF (ISAE.EQ.JASYM.AND.IGA.EQ.JGROAE) THEN
C
C  LOOP OVER ALL RELEVANT BETAS
C
            LABPOS = JPZA1
            LABPOS2 = JPOSAE
            DO 2813 IGB=1,ITGB
               IF (LGCOM(IGB,IGA).NE.1) GOTO 2813
               NIBS = NBST(IGB)
               DO 2763 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                  LABPOS = LABPOS + 1
                  LABPOS2 = LABPOS2 + 1
                  IBPOS = NIBS + LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2613 JBINDX=JB1ST(KBSYM,IBPOS),JB1ST(KBSYM+1,IBPOS)-1
                  IGB2=JB1GR(JBINDX)
                  IF (LGCOM(IGB2,JGROAE).NE.1) GOTO 2613
C
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  IX=INDEX(JMA)+JMI
                  JCIB=JPOSAE+LDISB(KBSYM,IGB2,JGROAE)+JB1PO(JBINDX)
                  JCIB2=JPZA1+LDISB(KBSYM,IGB2,JGROAE)+JB1PO(JBINDX)
C
                 IF(LABPOS.GE.JLO .AND. LABPOS.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = JPERAE*JB1PE(JBINDX)*CI(JCIB,ISTAT)
                     IWI1 = (ISTAT-1)*NDETLN + LABPOS - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,IX),1,WAXCI(1,IWI1),1)
                   ENDDO
                 ENDIF
C
                 IF(JCIB.GE.JLO .AND. JCIB.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = JPERAE*JB1PE(JBINDX)*CI(LABPOS,ISTAT)
                     IWIB = (ISTAT-1)*NDETLN + JCIB - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,IX),1,WAXCI(1,IWIB),1)
                   ENDDO
                 ENDIF
C
                 IF(LABPOS2.GE.JLO .AND. LABPOS2.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = JPERAE*JB1PE(JBINDX)*CI(JCIB2,ISTAT)
                     IWI1 = (ISTAT-1)*NDETLN + LABPOS2 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,IX),1,WAXCI(1,IWI1),1)
                   ENDDO
                 ENDIF
C
                 IF(JCIB2.GE.JLO .AND. JCIB2.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = JPERAE*JB1PE(JBINDX)*CI(LABPOS2,ISTAT)
                     IWIB = (ISTAT-1)*NDETLN + JCIB2 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,IX),1,WAXCI(1,IWIB),1)
                   ENDDO
                 ENDIF
C
 2613          CONTINUE
C
 2763          CONTINUE
 2813       CONTINUE
C
       ELSE
C
C  LOOP OVER ALL RELEVANT (A-)BETA DETS.
C
            LABPOS = JPZA1
            DO 2800 IGB=1,ITGB
               IF (LGCOM(IGB,IGA).NE.1) GOTO 2800
               NIBS = NBST(IGB)
               DO 2750 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                  LABPOS = LABPOS + 1
                  IBPOS = NIBS + LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2600 JBINDX=JB1ST(KBSYM,IBPOS),JB1ST(KBSYM+1,IBPOS)-1
                  IGB2=JB1GR(JBINDX)
                  IF (LGCOM(IGB2,JGROAE).NE.1) GOTO 2600
C
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  IX=INDEX(JMA)+JMI
                  JCIB=JPOSAE+LDISB(KBSYM,IGB2,JGROAE)+JB1PO(JBINDX)
C
                 IF(LABPOS.GE.JLO .AND. LABPOS.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = JPERAE*JB1PE(JBINDX)*CI(JCIB,ISTAT)
                     IWI1 = (ISTAT-1)*NDETLN + LABPOS - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,IX),1,WAXCI(1,IWI1),1)
                   ENDDO
                 ENDIF
C
                 IF(JCIB.GE.JLO .AND. JCIB.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = JPERAE*JB1PE(JBINDX)*CI(LABPOS,ISTAT)
                     IWIB = (ISTAT-1)*NDETLN + JCIB - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,IX),1,WAXCI(1,IWIB),1)
                   ENDDO
                 ENDIF
C
 2600          CONTINUE
C
 2750          CONTINUE
 2800       CONTINUE
C
C  LOOP OVER ALL RELEVANT (A'-)BETA DETS.
C
            LABPOS = JPOSAE
            DO 2803 IGB=1,ITGB
               IF (LGCOM(IGB,JGROAE).NE.1) GOTO 2803
               NIBS = NBST(IGB)
               DO 2753 KKB=LSBS(KBSYM,IGB),LSBS(KBSYM+1,IGB)-1
                  LABPOS = LABPOS + 1
                  IBPOS = NIBS + LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2603 JBINDX=JB1ST(KSYM,IBPOS),JB1ST(KSYM+1,IBPOS)-1
                  IGB2=JB1GR(JBINDX)
                  IF (LGCOM(IGB2,IGA).NE.1) GOTO 2603
C
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  IX=INDEX(JMA)+JMI
                  JCIB=JPZA1+LDISB(KSYM,IGB2,IGA)+JB1PO(JBINDX)
C
                 IF(LABPOS.GE.JLO .AND. LABPOS.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = JPERAE*JB1PE(JBINDX)*CI(JCIB,ISTAT)
                     IWI1 = (ISTAT-1)*NDETLN + LABPOS - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,IX),1,WAXCI(1,IWI1),1)
                   ENDDO
                 ENDIF
C
                 IF(JCIB.GE.JLO .AND. JCIB.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = JPERAE*JB1PE(JBINDX)*CI(LABPOS,ISTAT)
                     IWIB = (ISTAT-1)*NDETLN + JCIB - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,IX),1,WAXCI(1,IWIB),1)
                   ENDDO
                 ENDIF
C
 2603          CONTINUE
C
 2753          CONTINUE
 2803       CONTINUE
C
      ENDIF
C
 2900    CONTINUE
 3000 CONTINUE
C
      ELSE
C
C  ***** DIRECT METHOD BELOW *****
C
      DO 4000 ISAE=1,NSYM
         KBSYM = KTAB(ISAE)
C
C  ANALYSE EXCITED A' GROUPS FOR COMPATIBILITY WITH B.
C
      NGRPS = 0
      DO 1976 II=1,IMMC(ISAE)
         ICGR = IGROA(II,ISAE)
         DO JJ=1,NGRPS
            IF (JB1GR(JJ).EQ.ICGR) GOTO 1976
         ENDDO
         NGRPS = NGRPS + 1
         JB1GR(NGRPS) = ICGR
 1976 CONTINUE
C
C FIRST TYPE OF BETAS, KSYM -> KBSYM
C
          CALL RESETCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3)
          DO 7400 IGB=1,ITGB
             IF (LGCOM(IGB,IGA).NE.1) GOTO 7399
             LAB1 = JPZA1 + LDISB(KSYM,IGB,IGA)
C
             CALL RESETDE(LBOX2,NSPACE,NB,MSTA,IBCON1)
             NIBS = NBST(IGB)
             ISTB = 1
             DO 7300 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                IENB = LSBC(KKB)
                DO IIZ=ISTB,IENB-1
                   CALL MOVEUP2(LBOX2,NSPACE,NB,MSTA,IBCON1)
                ENDDO
                ISTB = IENB
C
                IBPOS = NIBS + LSBC(KKB)
                LABPOS = LAB1 + LSPB(IBPOS)
C
C LOOP OVER SINGLE BETA EXCITES FROM IBPOS WHICH ARE OF SYMMETRY KBSYM
C
                MESYM1 = LGMUL(KSYM,KBSYM)
                DO II=1,NSPACE
                   LBOX3(II) = LBOX2(II)
                ENDDO
                IEBS = NB + 1
                DO 7290 ISPB1=NSPACE,1,-1
                   IOC1 = LBOX2(ISPB1)
                   IEBE = IEBS - 1
                   IEBS = IEBS - IOC1
                   IF (IOC1.EQ.0) GO TO 7290
                   LBOX3(ISPB1) = LBOX3(ISPB1)-1
C
C  LOOP ELECTRONS IN SPACE ISPB1
C  IEBS, IEBE ARE THE ELECTRONS IN SPACE ISPB1
C
                DO 7285 IB1 = IEBE,IEBS,-1
                   IO1 = IBCON1(IB1)
                   MESYM2 = LGMUL(MESYM1,IOB(IO1))
                   IGBE = IEBE - LBOX2(ISPB1)
C
C  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
C
                DO 7280 ISPB2=ISPB1,NSPACE
C
C  IGBS,IGBE ARE ELECTRONS SPECIFYING ISPB2 SPACE ELECTRON LIMITS.
C
                   IGBS = IGBE + 1
                   IGBE = IGBE + LBOX2(ISPB2)
C
                   LBOX3(ISPB2) = LBOX3(ISPB2) + 1
                   IF (LBOX3(ISPB1).LT.IBMI(ISPB1)) GO TO 7270
                   IF (LBOX3(ISPB2).GT.IBMA(ISPB2)) GO TO 7270
C
C  GET GROUP NUMBER
C
          CALL POSITCO(LBOX5,NSPACE,NB,IBMA,IBMI,LBOX4,LBOX3,IGB2)
          NIAS = NBST(IGB2)
C
C CHECK FOR A' GROUP COMPATIBILITY
C
             DO II=1,NGRPS
                IAGRP = JB1GR(II)
                IF (LGCOM(IGB2,IAGRP).EQ.1) GOTO 7555
             ENDDO
             GOTO 7270
 7555        CONTINUE
C
C  MAKE GAP INFORMATION HERE.
C
                  IGBA = MAX(IB1+1,IGBS)
                  IF (LBOX2(ISPB2).EQ.0) THEN
                     ISTA = MSTA(ISPB2)
                     IEND = MSTA(ISPB2+1)-1
                  ELSEIF (ISPB2.EQ.ISPB1) THEN
                     ISTA = IO1+1
                     IEND = IBCON1(IGBA)-1
                     IF (IB1.EQ.IEBE) IEND=MSTA(ISPB1+1)-1
                  ELSE
                     ISTA = MSTA(ISPB2)
                     IEND = IBCON1(IGBA)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 7260 IGAP=IGBA,IGBE+1
C
                     DO 7250 JJ=ISTA,IEND
C
C CHECK TO SEE IF EXCITED BETA IS OF RIGHT SYMMETRY (KBSYM)
C
            IF (IOB(JJ).NE.MESYM2) GOTO 7250
C
            IND1 = INDEX(JJ) + IO1
            CALL REDE00(IBCON1,IBCON2,NB,IB1,IGAP-1,JJ,IPER)
            CALL IDPOST(IBCON2,NB,LBOX3,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LBNDET(1,IGB2),IACON2,IPOSB)
            QJPER = ((-1)**IPER)
            JB1P = LSPB(IPOSB + NIAS)
C
            DO 3900 JSAE=1,IMMC(ISAE)
               JGROAE=IGROA(JSAE,ISAE)
               IF (LGCOM(IGB2,JGROAE).NE.1) GOTO 3900
C
               JPOSAE=IPOSA(JSAE,ISAE)
               JCIB = JB1P + JPOSAE + LDISB(KBSYM,IGB2,JGROAE)
C
               JINDAE=IIND1(JSAE,ISAE)
               JMA=MAX(JINDAE,IND1)
               JMI=MIN(JINDAE,IND1)
               IX=INDEX(JMA)+JMI
C
               JPERAE=IPERA(JSAE,ISAE)
C
                 IF(LABPOS.GE.JLO .AND. LABPOS.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = JPERAE*QJPER*CI(JCIB,ISTAT)
                     IWI1 = (ISTAT-1)*NDETLN + LABPOS - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,IX),1,WAXCI(1,IWI1),1)
                   ENDDO
                 ENDIF
C
                 IF(JCIB.GE.JLO .AND. JCIB.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = JPERAE*QJPER*CI(LABPOS,ISTAT)
                     IWIB = (ISTAT-1)*NDETLN + JCIB - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,IX),1,WAXCI(1,IWIB),1)
                   ENDDO
                 ENDIF
C
 3900       CONTINUE
C
 7250                CONTINUE
C
                  ISTA = IBCON1(IGAP)+1
                  IEND = IBCON1(IGAP+1)-1
                  IF (IGAP.EQ.IGBE) IEND=MSTA(ISPB2+1)-1
 7260             CONTINUE
C
 7270              LBOX3(ISPB2) = LBOX3(ISPB2) - 1
 7280           CONTINUE
C
 7285           CONTINUE
C
                   LBOX3(ISPB1) = LBOX3(ISPB1) + 1
 7290           CONTINUE
C
 7300        CONTINUE
C
 7399        CALL PUSHCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3,IEND)
 7400     CONTINUE
C
C
C SECOND TYPE OF BETAS, KBSYM -> KSYM
C
          CALL RESETCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3)
          DO 7801 IGB=1,ITGB
C
C CHECK FOR A' GROUP COMPATIBILITY
C
             DO II=1,NGRPS
                IAGRP = JB1GR(II)
                IF (LGCOM(IGB,IAGRP).EQ.1) GOTO 7655
             ENDDO
             GOTO 7799
 7655        CONTINUE
C
             CALL RESETDE(LBOX2,NSPACE,NB,MSTA,IBCON1)
             NIBS = NBST(IGB)
             ISTB = 1
C
             DO 7701 KKB=LSBS(KBSYM,IGB),LSBS(KBSYM+1,IGB)-1
                IENB = LSBC(KKB)
                DO IIZ=ISTB,IENB-1
                   CALL MOVEUP2(LBOX2,NSPACE,NB,MSTA,IBCON1)
                ENDDO
                ISTB = IENB
C
                IBPOS = NIBS + LSBC(KKB)
                LAB1 = LSPB(IBPOS)
C
C LOOP OVER SINGLE BETA EXCITES FROM IBPOS WHICH ARE OF SYMMETRY KSYM
C
                MESYM1 = LGMUL(KSYM,KBSYM)
                DO II=1,NSPACE
                   LBOX3(II) = LBOX2(II)
                ENDDO
                IEBS = NB + 1
                DO 7691 ISPB1=NSPACE,1,-1
                   IOC1 = LBOX2(ISPB1)
                   IEBE = IEBS - 1
                   IEBS = IEBS - IOC1
                   IF (IOC1.EQ.0) GO TO 7691
                   LBOX3(ISPB1) = LBOX3(ISPB1)-1
C
C  LOOP ELECTRONS IN SPACE ISPB1
C  IEBS, IEBE ARE THE ELECTRONS IN SPACE ISPB1
C
                DO 7686 IB1 = IEBE,IEBS,-1
                   IO1 = IBCON1(IB1)
                   MESYM2 = LGMUL(MESYM1,IOB(IO1))
                   IGBE = IEBE - LBOX2(ISPB1)
C
C  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
C
                DO 7681 ISPB2=ISPB1,NSPACE
C
C  IGBS,IGBE ARE ELECTRONS SPECIFYING ISPB2 SPACE ELECTRON LIMITS.
C
                   IGBS = IGBE + 1
                   IGBE = IGBE + LBOX2(ISPB2)
C
                   LBOX3(ISPB2) = LBOX3(ISPB2) + 1
                   IF (LBOX3(ISPB1).LT.IBMI(ISPB1)) GO TO 7671
                   IF (LBOX3(ISPB2).GT.IBMA(ISPB2)) GO TO 7671
C
          CALL POSITCO(LBOX5,NSPACE,NB,IBMA,IBMI,LBOX4,LBOX3,IGB2)
          IF (LGCOM(IGB2,IGA).NE.1) GOTO 7671
          JCIBS = JPZA1 + LDISB(KSYM,IGB2,IGA)
          NIAS = NBST(IGB2)
C
C  MAKE GAP INFORMATION HERE.
C
                  IGBA = MAX(IB1+1,IGBS)
                  IF (LBOX2(ISPB2).EQ.0) THEN
                     ISTA = MSTA(ISPB2)
                     IEND = MSTA(ISPB2+1)-1
                  ELSEIF (ISPB2.EQ.ISPB1) THEN
                     ISTA = IO1+1
                     IEND = IBCON1(IGBA)-1
                     IF (IB1.EQ.IEBE) IEND=MSTA(ISPB1+1)-1
                  ELSE
                     ISTA = MSTA(ISPB2)
                     IEND = IBCON1(IGBA)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 7660 IGAP=IGBA,IGBE+1
C
                     DO 7650 JJ=ISTA,IEND
C
C CHECK TO SEE IF EXCITED BETA IS OF RIGHT SYMMETRY (KBSYM)
C
            IF (IOB(JJ).NE.MESYM2) GOTO 7650
C
            IND1 = INDEX(JJ) + IO1
            CALL REDE00(IBCON1,IBCON2,NB,IB1,IGAP-1,JJ,IPER)
            CALL IDPOST(IBCON2,NB,LBOX3,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LBNDET(1,IGB2),IACON2,IPOSB)
            QJPER = ((-1)**IPER)
            JCIB= JCIBS + LSPB(IPOSB + NIAS)
C
            DO 4300 JSAE=1,IMMC(ISAE)
               JGROAE=IGROA(JSAE,ISAE)
               IF (LGCOM(IGB,JGROAE).NE.1) GOTO 4300
C
               JPOSAE=IPOSA(JSAE,ISAE)
               LABPOS = LAB1 + JPOSAE + LDISB(KBSYM,IGB,JGROAE)
C
               JINDAE=IIND1(JSAE,ISAE)
               JMA=MAX(JINDAE,IND1)
               JMI=MIN(JINDAE,IND1)
               IX=INDEX(JMA)+JMI
C
               JPERAE=IPERA(JSAE,ISAE)
C
                 IF(LABPOS.GE.JLO .AND. LABPOS.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = JPERAE*QJPER*CI(JCIB,ISTAT)
                     IWI1 = (ISTAT-1)*NDETLN + LABPOS - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,IX),1,WAXCI(1,IWI1),1)
                   ENDDO
                 ENDIF
C
                 IF(JCIB.GE.JLO .AND. JCIB.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = JPERAE*QJPER*CI(LABPOS,ISTAT)
                     IWIB = (ISTAT-1)*NDETLN + JCIB - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,IX),1,WAXCI(1,IWIB),1)
                   ENDDO
                 ENDIF
C
 4300       CONTINUE
C
 7650                CONTINUE
C
                  ISTA = IBCON1(IGAP)+1
                  IEND = IBCON1(IGAP+1)-1
                  IF (IGAP.EQ.IGBE) IEND=MSTA(ISPB2+1)-1
 7660             CONTINUE
C
 7671              LBOX3(ISPB2) = LBOX3(ISPB2) - 1
 7681           CONTINUE
C
 7686           CONTINUE
C
                   LBOX3(ISPB1) = LBOX3(ISPB1) + 1
 7691           CONTINUE
C
 7701        CONTINUE
C
 7799        CALL PUSHCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3,IEND)
 7801     CONTINUE
C
 4000 CONTINUE
C
      ENDIF
C
C  ***** END OF DIRECT OPTION *****
C
C  **** END OF GENERAL CASE OF MORE THAN ONE SPACE ******
C
      GOTO 4899
C
 3400 CONTINUE
C
C ***** SPECIAL CASE OF ONE SPACE !!!!! ******
C
C  LOOP OVER SINGLE ALPHA EXCITES WITHIN EACH SYMMETRY.
C
       DO 2901 ISAE=1,NSYM
          KBSYM=KTAB(ISAE)
          DO 2801 JSAE=1,IMMC(ISAE)
                JPOSAE=IPOSA(JSAE,ISAE)
                JPERAE=IPERA(JSAE,ISAE)
                JINDAE=IIND1(JSAE,ISAE)
                JGROAE=IGROA(JSAE,ISAE)
C
C  IF ISAE.EQ.JASYM THEN SPECIAL CASE.
C
       IF (ISAE.EQ.JASYM) THEN
C
C  LOOP OVER ALL RELEVANT BETAS
C
             LABPOS=JPZA1
             LABPOS2=JPOSAE
                DO 2721 KKB=LSBS(KSYM,1),LSBS(KSYM+1,1)-1
                    LABPOS = LABPOS + 1
                    LABPOS2 = LABPOS2 + 1
                    IBPOS =  LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2621 JBINDX=JB1ST(KSYM,IBPOS),JB1ST(KSYM+1,IBPOS)-1
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  IX=INDEX(JMA)+JMI
                  JCIB = JPOSAE+JB1PO(JBINDX)
                  JCIB2 = JPZA1+JB1PO(JBINDX)
C
                 IF(LABPOS.GE.JLO .AND. LABPOS.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = JPERAE*JB1PE(JBINDX)*CI(JCIB,ISTAT)
                     IWI1 = (ISTAT-1)*NDETLN + LABPOS - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,IX),1,WAXCI(1,IWI1),1)
                   ENDDO
                 ENDIF
C
                 IF(JCIB.GE.JLO .AND. JCIB.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = JPERAE*JB1PE(JBINDX)*CI(LABPOS,ISTAT)
                     IWIB = (ISTAT-1)*NDETLN + JCIB - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,IX),1,WAXCI(1,IWIB),1)
                   ENDDO
                 ENDIF
C
                 IF(LABPOS2.GE.JLO .AND. LABPOS2.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = JPERAE*JB1PE(JBINDX)*CI(JCIB2,ISTAT)
                     IWI1 = (ISTAT-1)*NDETLN + LABPOS2 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,IX),1,WAXCI(1,IWI1),1)
                   ENDDO
                 ENDIF
C
                 IF(JCIB2.GE.JLO .AND. JCIB2.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = JPERAE*JB1PE(JBINDX)*CI(LABPOS2,ISTAT)
                     IWIB = (ISTAT-1)*NDETLN + JCIB2 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,IX),1,WAXCI(1,IWIB),1)
                   ENDDO
                 ENDIF
C
 2621          CONTINUE
C
 2721          CONTINUE
C
      ELSE
C
C  LOOP OVER ALL RELEVANT (A-)BETA DETS.
C
                LABPOS = JPZA1
                DO 2751 KKB=LSBS(KSYM,1),LSBS(KSYM+1,1)-1
                    LABPOS = LABPOS + 1
                    IBPOS =  LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2601 JBINDX=JB1ST(KBSYM,IBPOS),JB1ST(KBSYM+1,IBPOS)-1
C
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  IX=INDEX(JMA)+JMI
                  JCIB=JPOSAE+JB1PO(JBINDX)
C
                 IF(LABPOS.GE.JLO .AND. LABPOS.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = JPERAE*JB1PE(JBINDX)*CI(JCIB,ISTAT)
                     IWI1 = (ISTAT-1)*NDETLN + LABPOS - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,IX),1,WAXCI(1,IWI1),1)
                   ENDDO
                 ENDIF
C
                 IF(JCIB.GE.JLO .AND. JCIB.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = JPERAE*JB1PE(JBINDX)*CI(LABPOS,ISTAT)
                     IWIB = (ISTAT-1)*NDETLN + JCIB - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,IX),1,WAXCI(1,IWIB),1)
                   ENDDO
                 ENDIF
C
 2601          CONTINUE
C
 2751          CONTINUE
C
C  LOOP OVER ALL RELEVANT (A'-)BETA DETS.
C
               LABPOS = JPOSAE
               DO 2761 KKB=LSBS(KBSYM,1),LSBS(KBSYM+1,1)-1
                  LABPOS = LABPOS + 1
                  IBPOS = LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2611 JBINDX=JB1ST(KSYM,IBPOS),JB1ST(KSYM+1,IBPOS)-1
C
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  IX=INDEX(JMA)+JMI
                  JCIB=JPZA1+JB1PO(JBINDX)
C
                 IF(LABPOS.GE.JLO .AND. LABPOS.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = JPERAE*JB1PE(JBINDX)*CI(JCIB,ISTAT)
                     IWI1 = (ISTAT-1)*NDETLN + LABPOS - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,IX),1,WAXCI(1,IWI1),1)
                   ENDDO
                 ENDIF
C
                 IF(JCIB.GE.JLO .AND. JCIB.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = JPERAE*JB1PE(JBINDX)*CI(LABPOS,ISTAT)
                     IWIB = (ISTAT-1)*NDETLN + JCIB - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,IX),1,WAXCI(1,IWIB),1)
                   ENDDO
                 ENDIF
C
 2611          CONTINUE
C
 2761          CONTINUE
C
      ENDIF
C
 2801       CONTINUE
 2901   CONTINUE
C
C  **** END OF SPECIAL CASE OF ONE SPACE *******
C
 4899       CALL MOVEUP2(LBOX1,NSPACE,NA,MSTA,IACON1)
 4900    CONTINUE
C
         CALL PUSHCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX5,IEND)
 5000 CONTINUE
C
C  --- END OF LOOP OVER ALPHA STRINGS. ---
C **
C  --- LOOP OVER ALL PURE BETA EXCITATIONS.
C
      CALL RESETCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX5)
C
      DO 8000 IGB=1,ITGB
C
         CALL RESETDE(LBOX1,NSPACE,NB,MSTA,IBCON1)
C
C  KKB GIVES THE ACTUAL POSITION OF THE BETA STRING IBCON1 IN
C  THE FULL BETA STRING LIST.
C
         DO 7900 KKB=NBST(IGB)+1,NBST(IGB+1)
            JPZB1 = LSPB(KKB)
            KBSYM = LSYMB(KKB)
            KSYM=KTAB(KBSYM)
C
            DO II=1,NSPACE
               LBOX2(II) = LBOX1(II)
            ENDDO
C
C  LOOP OVER SPACES TO EXCITE ELECTRON FROM.
C
            IEBS = NB+1
            DO 7890 ISPB1=NSPACE,1,-1
               IOC1 = LBOX1(ISPB1)
               IEBE = IEBS - 1
               IEBS = IEBS - IOC1
               IF (IOC1.EQ.0) GOTO 7890
               LBOX2(ISPB1) = LBOX2(ISPB1)-1
C
C  LOOP ELECTRONS IN SPACE ISPB1.
C  IEBS, IEBE ARE THE ELECTRONS IN SPACE ISPB1.
C
               DO 7885 IB1=IEBE,IEBS,-1
                  IO1 = IBCON1(IB1)
                  IGBE = IEBE - LBOX1(ISPB1)
                  IS1 = IOB(IO1)
C
C  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
C
               DO 7880 ISPB2=ISPB1,NSPACE
C
C  IGBS, IGBE ARE ELECTRONS SPECIFYING ISPB2 SPACE ELECTRON LIMITS.
C
                  IGBS = IGBE + 1
                  IGBE = IGBE + LBOX1(ISPB2)
C
                  LBOX2(ISPB2) = LBOX2(ISPB2) + 1
                  IF (LBOX2(ISPB1).LT.IBMI(ISPB1)) GOTO 7870
C
C  MAKE GAP INFORMATION HERE.
C
                  IGBB = MAX(IB1+1,IGBS)
                  IF (LBOX1(ISPB2).EQ.0) THEN
                     ISTA = MSTA(ISPB2)
                     IEND = MSTA(ISPB2+1)-1
                  ELSEIF (ISPB2.EQ.ISPB1) THEN
                     ISTA = IO1+1
                     IEND = IBCON1(IGBB)-1
                     IF (IB1.EQ.IEBE) IEND=MSTA(ISPB1+1)-1
                  ELSE
                     ISTA = MSTA(ISPB2)
                     IEND = IBCON1(IGBB)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 7860 IGAP=IGBB,IGBE+1
C
                     DO 7850 JJ=ISTA,IEND
                        IS2 = IOB(JJ)
                        IP1 = LGMUL(IS1,IS2)
                        IND = INDEX(JJ) + IO1
C
              CALL REDE00(IBCON1,IBCON2,NB,IB1,IGAP-1,JJ,JPERB)
                  IF (LBOX2(ISPB2).GT.IBMA(ISPB2)) GOTO 7800
C
C   IF DEOCCUPIED AND NEWLY OCCUPIED ORBITALS ARE OF DIFFERENT SYMMETRY,
C   SKIP TO DOUBLES.
C
              IF (IS1.NE.IS2) GOTO 7800
C
C  GET GROUP NUMBER
C
           CALL POSITCO(LBOX5,NSPACE,NB,IBMA,IBMI,LBOX4,LBOX2,IGB2)
           NIBS = NBST(IGB2)
C
              CALL IDPOST(IBCON2,NB,LBOX2,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LBNDET(1,IGB2),IACON1,JPOSB)
              KBPOS = JPOSB + NIBS
              JPZB2 = LSPB(KBPOS)
C              KPER1 = ((-1)**JPERB)*2
              KPER1 = (-1)**JPERB
C
C  LOOP OVER ALPHA
C
              DO 7705 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB2,IGA).NE.1) GOTO 7705
                 JCIB1 = LDISB(KBSYM,IGB,IGA) + JPZB1
                 JCIB2 = LDISB(KBSYM,IGB2,IGA) + JPZB2
                 NIAS = NAST(IGA)
C
              DO 7685 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA1 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA1)
                 JCI1 = JCIA + JCIB1
                 JCI2 = JCIA + JCIB2
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = KPER1*CI(JCI2,ISTAT)
                     IWI1 = (ISTAT-1)*NDETLN + JCI1 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DFC(1,IND),1,WAXCI(1,IWI1),1)
                   ENDDO
                 ENDIF
C
                 IF(JCI2.GE.JLO .AND. JCI2.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = KPER1*CI(JCI1,ISTAT)
                     IWI2 = (ISTAT-1)*NDETLN + JCI2 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DFC(1,IND),1,WAXCI(1,IWI2),1)
                   ENDDO
                 ENDIF
C
 7685         CONTINUE
C
 7705         CONTINUE
C
              DO 7712 IK=1,NB
                 IF (IK.EQ.IB1) GOTO 7712
                 ION = IBCON1(IK)
                 J1 = INDEX(ION+1)
                 JMA = MAX(J1,IND)
                 JMI = MIN(J1,IND)
                 JJ1 = INDEX(JMA) + JMI
                 JMA = MAX(ION,JJ)
                 JMI = MIN(ION,JJ)
                 J1 = INDEX(JMA)+JMI
                 JMA = MAX(IO1,ION)
                 JMI = MIN(IO1,ION)
                 J2 = INDEX(JMA)+JMI
                 JMA = MAX(J1,J2)
                 JMI = MIN(J1,J2)
                 INX = INDEX(JMA)+JMI
C
              DO 7710 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB2,IGA).NE.1) GOTO 7710
                 JCIB1 = LDISB(KBSYM,IGB,IGA) + JPZB1
                 JCIB2 = LDISB(KBSYM,IGB2,IGA) + JPZB2
                 NIAS = NAST(IGA)
C
              DO 7695 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA1 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA1)
                 JCI1 = JCIA + JCIB1
                 JCI2 = JCIA + JCIB2
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = KPER1*CI(JCI2,ISTAT)
                     IWI1 = (ISTAT-1)*NDETLN + JCI1 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,JJ1),1,WAXCI(1,IWI1),1)
                     CALL DAXPY(NXYZ,-FC,DERI(1,INX),1,WAXCI(1,IWI1),1)
                   ENDDO
                 ENDIF
C
                 IF(JCI2.GE.JLO .AND. JCI2.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = KPER1*CI(JCI1,ISTAT)
                     IWI2 = (ISTAT-1)*NDETLN + JCI2 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,JJ1),1,WAXCI(1,IWI2),1)
                     CALL DAXPY(NXYZ,-FC,DERI(1,INX),1,WAXCI(1,IWI2),1)
                   ENDDO
                 ENDIF
C
 7695         CONTINUE
C
 7710         CONTINUE
C
 7712         CONTINUE
C
C  LOOP OVER ALPHA STRINGS OF THE RIGHT GROUP AND SYMMETRY.
C
              CALL RESETCO(LBOX3,NSPACE,NA,IAMA,IAMI,LBOX4)
C
              DO 7700 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB2,IGA).NE.1) GOTO 7690
                 JCIB1 = LDISB(KBSYM,IGB,IGA) + JPZB1
                 JCIB2 = LDISB(KBSYM,IGB2,IGA) + JPZB2
                 NIAS = NAST(IGA)
C
              CALL RESETDE(LBOX3,NSPACE,NA,MSTA,IACON1)
              ISTA1 = 1
              DO 7680 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA1 = LSAC(KKA)
                 DO IIZ=ISTA1,IENA1-1
                    CALL MOVEUP2(LBOX3,NSPACE,NA,MSTA,IACON1)
                 ENDDO
                 ISTA1 = IENA1
                 JCIA = LSPA(NIAS+IENA1)
                 JCI1 = JCIA + JCIB1
                 JCI2 = JCIA + JCIB2
C
                 DO 7670 IK=1,NA
                    ION = IACON1(IK)
                    J1 = INDEX(ION+1)
                    JMA = MAX(J1,IND)
                    JMI = MIN(J1,IND)
                    JJ1 = INDEX(JMA) + JMI
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = KPER1*CI(JCI2,ISTAT)
                     IWI1 = (ISTAT-1)*NDETLN + JCI1 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,JJ1),1,WAXCI(1,IWI1),1)
                   ENDDO
                 ENDIF
C
                 IF(JCI2.GE.JLO .AND. JCI2.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = KPER1*CI(JCI1,ISTAT)
                     IWI2 = (ISTAT-1)*NDETLN + JCI2 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,JJ1),1,WAXCI(1,IWI2),1)
                   ENDDO
                 ENDIF
C
 7670            CONTINUE
C
 7680         CONTINUE
C
 7690         CALL PUSHCO(LBOX3,NSPACE,NA,IAMA,IAMI,LBOX4,IEND)
 7700         CONTINUE
C
C  --- DOUBLE EXCITATIONS START HERE
C
 7800         CONTINUE
C
           IF (IB1.EQ.NB) GOTO 7850
           IF (JJ.EQ.NACT) GOTO 7850
C
            DO II=1,NSPACE
               LBOX3(II) = LBOX2(II)
            ENDDO
            IBES3 = 1
            DO KK=1,ISPB1-1
               IBES3 = IBES3 + LBOX2(KK)
            ENDDO
C
C  LOOP OVER SPACES TO EXCITE ELECTRONS FROM, MUST BE GE THAN
C  SPACE OF FIRST EXCITATION, ISPB1.
C
            DO 6890 ISPB3 = ISPB1,NSPACE
               IF (LBOX1(ISPB3).EQ.0) GOTO 6887
               IF (ISPB3.EQ.ISPB1.AND.IB1.EQ.IEBE) GOTO 6887
               IOC3 = LBOX2(ISPB3)
               IF (IOC3.EQ.0) GOTO 6887
C
               IBEE3 = IBES3 + LBOX2(ISPB3)-1
               LBOX3(ISPB3) = LBOX3(ISPB3)-1
C
C  LOOP OVER ELECTRONS IN ISPB3, WHICH ARE LARGER THAN IB1,
C  MAKING SURE IT ISN'T THE ALREADY EXCITED ELECTRON.
C
               JSTB3 = IBES3
               IF (ISPB3.EQ.ISPB1) THEN
                  JSTB3=IB1
                  IF (IGAP-1.EQ.IB1) JSTB3=JSTB3+1
               ENDIF
C
               DO 6880 IB3=JSTB3,IBEE3
                  IF (IB3.EQ.IGAP-1) GOTO 6880
                  IO3 = IBCON2(IB3)
                  IS3 = IOB(IO3)
C
C  LOOP OVER SPACES TO EXCITE ELECTRON INTO.  MUST BE GE THAN
C  SPACE FIRST ELECTRON WAS EXCITED INTO.
C
                  IGBE3 = 0
                  DO JIK=1,ISPB2-1
                     IGBE3 = IGBE3 + LBOX2(JIK)
                  ENDDO
                  DO 6850 ISPB4=ISPB2,NSPACE
C
C  IGBS3, IGBE3 ARE ELECTRONS SPECIFYING ISPB4 SPACE ELECTRON LIMITS.
C
                  LBOX3(ISPB4) = LBOX3(ISPB4) + 1
                  IGBS3 = IGBE3 + 1
                  IGBE3 = IGBE3 + LBOX2(ISPB4)
                  IF (LBOX3(ISPB3).LT.IBMI(ISPB3)) GOTO 6840
                  IF (LBOX3(ISPB4).GT.IBMA(ISPB4)) GOTO 6840
             IF (ISPB4.EQ.ISPB2.AND.JJ.EQ.MSTA(ISPB2+1)-1) GOTO 6840
C
C  GET GROUP NUMBER
C
               CALL POSITCO(LBOX5,NSPACE,NB,IBMA,IBMI,LBOX4,LBOX3,IGB3)
               NIBS3 = NBST(IGB3)
C
C  MAKE GAP INFORMATION HERE.
C
                  IGBB3 = MAX(IGBS3,IGAP)
C
                  IF (LBOX2(ISPB4).EQ.0) THEN
                     ISTA3 = MSTA(ISPB4)
                     IEND3 = MSTA(ISPB4+1)-1
                  ELSEIF (ISPB4.EQ.ISPB2) THEN
                     ISTA3 = JJ+1
                     IEND3 = IBCON2(IGBB3)-1
C
C  I AM SUSPECT ABOUT THIS NEXT LINE, WE'LL SEE WHAT HAPPENS.......
C
                     IF (IGAP-1.EQ.IGBE3) IEND3=MSTA(ISPB2+1)-1
C
                  ELSE
                     ISTA3 = MSTA(ISPB4)
                     IEND3 = IBCON2(IGBB3)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 6830 IGAP3=IGBB3,IGBE3+1
C
                     DO 6820 JJ3=ISTA3,IEND3
                        IS4 = IOB(JJ3)
                        IP2 = LGMUL(IS3,IS4)
                        IF (IP1.NE.IP2) GOTO 6820
C
              CALL REDE00(IBCON2,IACON1,NB,IB3,IGAP3-1,JJ3,JPERB3)
              CALL IDPOST(IACON1,NB,LBOX3,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LBNDET(1,IGB3),IACON2,JPOSB3)
C              IPER3 = ((-1)**(JPERB3+JPERB))*2
              IPER3 = (-1)**(JPERB3+JPERB)
              KBPOS3 = JPOSB3 + NIBS3
              JPZB3 = LSPB(KBPOS3)
C
                 JMA=MAX(JJ3,IO3)
                 JMI=MIN(JJ3,IO3)
                 I2 = INDEX(JMA) + JMI
                 INX = INDEX(I2) + IND
                 II1 = INDEX(JJ3) + IO1
                 JMA=MAX(IO3,JJ)
                 JMI=MIN(IO3,JJ)
                 II2 = INDEX(JMA) + JMI
                 JMA=MAX(II1,II2)
                 JMI=MIN(II1,II2)
                 INX2 = INDEX(JMA) + JMI
C
C  LOOP OVER ALPHA STRINGS OF RIGHT SYMMETRY AND GROUP.
C
              DO 6700 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB3,IGA).NE.1) GOTO 6700
              JCIB1 = JPZB1 + LDISB(KBSYM,IGB,IGA)
              JCIB3 = JPZB3 + LDISB(KBSYM,IGB3,IGA)
              NIAS = NAST(IGA)
C
              DO 6680 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA3 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA3)
                 JCI1 = JCIA + JCIB1
                 JCI3 = JCIA + JCIB3
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = IPER3*CI(JCI3,ISTAT)
                     IWI1 = (ISTAT-1)*NDETLN + JCI1 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,INX),1,WAXCI(1,IWI1),1)
                     CALL DAXPY(NXYZ,-FC,DERI(1,INX2),1,WAXCI(1,IWI1),1)
                   ENDDO
                 ENDIF
C
                 IF(JCI3.GE.JLO .AND. JCI3.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = IPER3*CI(JCI1,ISTAT)
                     IWI3 = (ISTAT-1)*NDETLN + JCI3 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,INX),1,WAXCI(1,IWI3),1)
                     CALL DAXPY(NXYZ,-FC,DERI(1,INX2),1,WAXCI(1,IWI3),1)
                   ENDDO
                 ENDIF
C
 6680         CONTINUE
C
 6700         CONTINUE
C
 6820                CONTINUE
C
                     ISTA3 = IBCON2(IGAP3)+1
                     IEND3 = IBCON2(IGAP3+1)-1
                     IF (IGAP3.EQ.IGBE3) IEND3=MSTA(ISPB4+1)-1
 6830             CONTINUE
C
 6840             LBOX3(ISPB4) = LBOX3(ISPB4) - 1
 6850             CONTINUE
C
 6880          CONTINUE
C
               LBOX3(ISPB3) = LBOX3(ISPB3)+1
 6887          IBES3 = IBES3 + LBOX3(ISPB3)
 6890       CONTINUE
C
C  --- END OF LOOP OVER DOUBLE BETA EXCITATIONS.
C
 7850                CONTINUE
C
                  ISTA = IBCON1(IGAP)+1
                  IEND = IBCON1(IGAP+1)-1
                  IF (IGAP.EQ.IGBE) IEND=MSTA(ISPB2+1)-1
 7860             CONTINUE
C
 7870             LBOX2(ISPB2) = LBOX2(ISPB2) - 1
 7880          CONTINUE
C
 7885          CONTINUE
C
               LBOX2(ISPB1) = LBOX2(ISPB1)+1
 7890       CONTINUE
C
C REMAINING DIAGONAL CONTRIBUTIONS HERE
C
            DO 69 II=1,NB
               I1 = IBCON1(II)
               IND1 = INDEX(I1+1)
               IIFC = ((NCOR+I1)*(NCOR+I1+1))/2
C
              DO 6705 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1) GOTO 6705
              JCIB1 = JPZB1 + LDISB(KBSYM,IGB,IGA)
              NIAS = NAST(IGA)
C
              DO 6685 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA3 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA3)
                 JCI1 = JCIA + JCIB1
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = CI(JCI1,ISTAT)
                     IWI1 = (ISTAT-1)*NDETLN + JCI1 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DFC(1,IND1),1,WAXCI(1,IWI1),1)
                     PRCNDC(IWI1) = PRCNDC(IWI1) + FCOR(IIFC)
                   ENDDO
                 ENDIF
C
 6685         CONTINUE
C
 6705         CONTINUE
C
              DO 74 JJ=II+1,NB
                 I2 = IBCON1(JJ)
                 IND2 = INDEX(I2+1)
                 INDM = IND2 - I2 + I1
                 J1 = INDEX(INDM+1)
                 JMI = MIN(IND1,IND2)
                 JMA = MAX(IND1,IND2)
                 J2 = INDEX(JMA) + JMI
C
              DO 6710 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1) GOTO 6710
              JCIB1 = JPZB1 + LDISB(KBSYM,IGB,IGA)
              NIAS = NAST(IGA)
C
              DO 6690 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA3 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA3)
                 JCI1 = JCIA + JCIB1
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     FC = CI(JCI1,ISTAT)
                     IWI1 = (ISTAT-1)*NDETLN + JCI1 - JLO + 1
                     CALL DAXPY(NXYZ,FC,DERI(1,J2),1,WAXCI(1,IWI1),1)
                     CALL DAXPY(NXYZ,-FC,DERI(1,J1),1,WAXCI(1,IWI1),1)
                     PRCNDC(IWI1) = PRCNDC(IWI1) + ERI(I1+NCOR,I1,IND2)
                     PRCNDC(IWI1) = PRCNDC(IWI1) - ERI(I1+NCOR,I2,INDM)
                   ENDDO
                 ENDIF
C
 6690         CONTINUE
C
 6710         CONTINUE
C
   74         CONTINUE
C
   69         CONTINUE
C
            CALL MOVEUP2(LBOX1,NSPACE,NB,MSTA,IBCON1)
 7900    CONTINUE
C
         CALL PUSHCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX5,IEND)
 8000 CONTINUE
C
C  --- END OF LOOP OVER BETA STRINGS. ---
C
C ----    END OF DENSITY MATRIX GENERATION ----------
C
      RETURN
      END
C*MODULE CPMCHF  *DECK HSSCX1
C     ----------------------------------------------------------------
      SUBROUTINE HSSCX1(AVEC,YAC,YAO,AMAT,OINT,IROT,INDEX2,BVEC,
     *     RHSC,RHSO,YADEN,ERI,WRK,YAOG,YAOTMP,WSTATE,SALAG,CI,
     *     NCOR,JLO,JHI,NSTATS,NDETLN,ITER,NINDX,
     *     NROT,NXYZ,L1,NACT,NCI,NA,NB,
     *     Y,NX,INDEX,NSYM,IOB,
     *     LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,
     *     LGMUL,KTAB,IACON1,IACON2,IBCON1,IBCON2,
     *     LANDET,LBNDET,NAST,NBST,LSYMA,LSYMB,LGCOM,
     *     LSPA,LSPB,LDISB,LSAS,LSBS,LSAC,LSBC,
     *     ITGA,ITGB,IAST,IBST,
     *     IPOSA,IPERA,IIND1,IGROA,IMMC,
     *     NB1EX,JB1GR,JB1PE,JB1IN,JB1PO,JB1ST,JB1IN2,IIND2,IIND3,
     *     IDIM1,IDIM2,JROTLO,JROTHI)
C     ----------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,FDIRCT,QCORR
      LOGICAL RUN,KILL
C
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIM(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DIMENSION AVEC(*),YAC(NXYZ,NSTATS*NCI),YAO(NXYZ,NROT),AMAT(*)
      DIMENSION CI(NCI,NSTATS),OINT(L1,L1),IROT(L1,L1)
      DIMENSION INDEX2(NINDX,NINDX),BVEC(*),RHSC(NXYZ,NSTATS*NDETLN)
      DIMENSION RHSO(NXYZ,NROT),YADEN(*),ERI(*),WRK(*),YAOG(NXYZ)
      DIMENSION YAOTMP(*),WSTATE(*),SALAG(*)
      DIMENSION Y(NX)
      DIMENSION INDEX((NACT*(NACT+1))/2+1),IOB(NACT)
      DIMENSION LBOX1(NSPACE),LBOX2(NSPACE),LBOX3(NSPACE)
      DIMENSION LBOX4(NSPACE),LBOX5(NSPACE)
      DIMENSION LGMUL(NSYM,NSYM),KTAB(NSYM)
      DIMENSION IACON1(NA),IACON2(NA),IBCON1(NA),IBCON2(NA)
      DIMENSION LANDET(NSPACE,ITGA),LBNDET(NSPACE,ITGB)
      DIMENSION NAST(ITGA+1),NBST(ITGB+1)
      DIMENSION LSYMA(IAST),LSYMB(IBST),LGCOM(ITGB,ITGA)
      DIMENSION LSPA(IAST),LSPB(IBST),LDISB(NSYM,ITGB,ITGA)
      DIMENSION LSAS(NSYM+1,ITGA),LSBS(NSYM+1,ITGB)
      DIMENSION LSAC(IAST),LSBC(IBST)
      DIMENSION IPOSA(NA*(NACT-NA),NSYM)
      DIMENSION IPERA(NA*(NACT-NA),NSYM)
      DIMENSION IIND1(NA*(NACT-NA),NSYM)
      DIMENSION IIND2(NA*(NACT-NA),NSYM),IIND3(NA*(NACT-NA),NSYM)
      DIMENSION IGROA(NA*(NACT-NA),NSYM)
      DIMENSION IMMC(NSYM)
      DIMENSION JB1GR(NB1EX),JB1PE(NB1EX),JB1IN(NB1EX),JB1PO(NB1EX)
      DIMENSION JB1ST(IDIM1,IDIM2),JB1IN2(NB1EX,2)
C
      PARAMETER (TOL=1.0D-09,ONE=1.0D+00)
C
      M1 = NACT
      NNACT = (M1*M1+M1)/2
      KILL = .FALSE.
      RUN = .FALSE.
C
      DO 7 I=1,NINDX
         DO 8 J=1,I
            INDEX2(I,J) = I*(I-1)/2 + J
            INDEX2(J,I) = INDEX2(I,J)
    8    CONTINUE
    7 CONTINUE
C
      CALL FMAVEC(AVEC,YAO,AMAT,OINT,IROT,INDEX2,L1,NCOR,NACT,NNACT,
     *            NXYZ,NROT,NINDX,JROTLO,JROTHI)
      IF(GOPARR) CALL DDI_GSUMF(2178,AVEC,NXYZ*NNACT)
      CALL VCLR(BVEC,1,NXYZ*NNACT)
C
C  --- BIG LOOP OVER ALL ALPHA STRINGS. ---
C
      CALL RESETCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX5)
C
      DO 5000 IGA=1,ITGA
C
         CALL RESETDE(LBOX1,NSPACE,NA,MSTA,IACON1)
C
C  KKA GIVES THE ACTUAL POSITION OF THE ALPHA STRING IACON1 IN
C  THE FULL ALPHA STRING LIST.
C
         DO 4900 KKA=NAST(IGA)+1,NAST(IGA+1)
            JPZA1 = LSPA(KKA)
            JASYM = LSYMA(KKA)
            KSYM=KTAB(JASYM)
            DO II=1,NSYM
               IMMC(II)=0
            ENDDO
C
            DO II=1,NSPACE
               LBOX2(II) = LBOX1(II)
            ENDDO
C
C  LOOP OVER SPACES TO EXCITE ELECTRON FROM.
C
            IEAS = NA+1
            DO 4890 ISPA1=NSPACE,1,-1
               IOC1 = LBOX1(ISPA1)
               IEAE = IEAS - 1
               IEAS = IEAS - IOC1
               IF (IOC1.EQ.0) GO TO 4890
               LBOX2(ISPA1) = LBOX2(ISPA1)-1
C
C  LOOP ELECTRONS IN SPACE ISPA1.
C  IEAS, IEAE ARE THE ELECTRONS IN SPACE ISPA1.
C
               DO 4885 IA1=IEAE,IEAS,-1
                  IO1 = IACON1(IA1)
                  IGAE = IEAE - LBOX1(ISPA1)
                  IS1 = IOB(IO1)
C
C  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
C
               DO 4880 ISPA2=ISPA1,NSPACE
C
C  IGAS, IGAE ARE ELECTRONS SPECIFYING ISPA2 SPACE ELECTRON LIMITS.
C
                  IGAS = IGAE + 1
                  IGAE = IGAE + LBOX1(ISPA2)
C
                  LBOX2(ISPA2) = LBOX2(ISPA2) + 1
                  IF (LBOX2(ISPA1).LT.IAMI(ISPA1)) GO TO 4870
C
C  MAKE GAP INFORMATION HERE.
C
                  IGAA = MAX(IA1+1,IGAS)
                  IF (LBOX1(ISPA2).EQ.0) THEN
                     ISTA = MSTA(ISPA2)
                     IEND = MSTA(ISPA2+1)-1
                  ELSEIF (ISPA2.EQ.ISPA1) THEN
                     ISTA = IO1+1
                     IEND = IACON1(IGAA)-1
                     IF (IA1.EQ.IEAE) IEND=MSTA(ISPA1+1)-1
                  ELSE
                     ISTA = MSTA(ISPA2)
                     IEND = IACON1(IGAA)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 4860 IGAP=IGAA,IGAE+1
C
                     DO 4850 JJ=ISTA,IEND
                        IS2 = IOB(JJ)
                        IP1 = LGMUL(IS1,IS2)
C
                     IND = INDEX(JJ) + IO1
C
              CALL REDE00(IACON1,IACON2,NA,IA1,IGAP-1,JJ,JPERA)
              IF (LBOX2(ISPA2).GT.IAMA(ISPA2)) GO TO 4800
C
C  GET GROUP NUMBER
C
           CALL POSITCO(LBOX5,NSPACE,NA,IAMA,IAMI,LBOX4,LBOX2,IGA2)
           NIAS = NAST(IGA2)
C
              CALL IDPOST(IACON2,NA,LBOX2,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LANDET(1,IGA2),IBCON1,JPOSA)
              KAPOS = JPOSA + NIAS
              JPZA2 = LSPA(KAPOS)
              KASYM = LSYMA(KAPOS)
C              KPER1 = ((-1)**JPERA)*2
              KPER1 = (-1)**JPERA
              IMMC(KASYM) = IMMC(KASYM) + 1
              JSPO = IMMC(KASYM)
              IPOSA(JSPO,KASYM) = JPZA2
              IPERA(JSPO,KASYM) = KPER1
              IIND1(JSPO,KASYM) = IND
              IIND2(JSPO,KASYM) = IO1
              IIND3(JSPO,KASYM) = JJ
              IGROA(JSPO,KASYM) = IGA2
C
C   IF DEOCCUPIED AND NEWLY OCCUPIED ORBITALS ARE OF DIFFERENT SYMMETRY,
C   SKIP TO DOUBLES.
C
              IF (IS1.NE.IS2) GO TO 4800
C
C  LOOP OVER APPROPRIATE BETA DETS
C
              DO 1700 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB,IGA2).NE.1) GOTO 1700
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
              JCI2 = JPZA2 + LDISB(KSYM,IGB,IGA2)
C
              DO 1680 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 JCI1 = JCI1 + 1
                 JCI2 = JCI2 + 1
                 FC = KPER1
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   CALL HSMLT1(AVEC,YAC,BVEC,RHSC,CI,OINT,AMAT,
     *                         FC,JCI1,JCI2,IND,IO1,JJ,JLO,
     *                         NSTATS,NCI,NDETLN,L1,NCOR,
     *                         NNACT,NXYZ,WSTATE,SALAG,ITER)
                 ENDIF
C
                 IF(JCI2.GE.JLO .AND. JCI2.LE.JHI) THEN
                   CALL HSMLT1(AVEC,YAC,BVEC,RHSC,CI,OINT,AMAT,
     *                         FC,JCI2,JCI1,IND,IO1,JJ,JLO,
     *                         NSTATS,NCI,NDETLN,L1,NCOR,
     *                         NNACT,NXYZ,WSTATE,SALAG,ITER)
                 ENDIF
C
 1680         CONTINUE
C
 1700         CONTINUE
C
C   DETERMINE THE ALPHA STRING CONTRIBUTION TO THE MATRIX ELEMENT.
C
              DO 4712 IK=1,NA
                 IF (IK.EQ.IA1) GO TO 4712
                 ION = IACON1(IK)
                 J1 = INDEX(ION+1)
                 JMA = MAX(J1,IND)
                 JMI = MIN(J1,IND)
                 JMA = MAX(ION,JJ)
                 JMI = MIN(ION,JJ)
                 J2 = INDEX(JMA)+JMI
                 JMA = MAX(IO1,ION)
                 JMI = MIN(IO1,ION)
                 J3 = INDEX(JMA)+JMI
                 JMA = MAX(J2,J3)
                 JMI = MIN(J2,J3)
C
                 CALL VCLR(YAOG,1,NXYZ)
                 CALL HSMLTN(YAOG,YAOTMP,IO1,JJ,ION,ION,IND,J1,NACT,
     *                       NNACT,NXYZ,ONE)
                 CALL HSMLTN(YAOG,YAOTMP,IO1,ION,ION,JJ,J3,J2,NACT,
     *                       NNACT,NXYZ,-ONE)
C
C
C  LOOP OVER APPROPRIATE BETA DETS
C
              DO 1705 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB,IGA2).NE.1) GOTO 1705
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
              JCI2 = JPZA2 + LDISB(KSYM,IGB,IGA2)
C
              DO 1685 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 JCI1 = JCI1 + 1
                 JCI2 = JCI2 + 1
                 FC = KPER1
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     CVAL = CI(JCI2,ISTAT)
                     WVAL = WSTATE(ISTAT)
                     IF(ABS(CVAL).GT.TOL) THEN
                       IWI1 = (ISTAT-1)*NDETLN + JCI1 - JLO + 1
                       DVAL = CVAL*WVAL*FC
                       CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI1),1)
                     ENDIF
                   ENDDO
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         FC,JCI1,JCI2,IO1,JJ,ION,ION,IND,J1,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         -FC,JCI1,JCI2,IO1,ION,ION,JJ,J3,J2,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                 ENDIF
C
                 IF(JCI2.GE.JLO .AND. JCI2.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     CVAL = CI(JCI1,ISTAT)
                     WVAL = WSTATE(ISTAT)
                     IF(ABS(CVAL).GT.TOL) THEN
                       IWI2 = (ISTAT-1)*NDETLN + JCI2 - JLO + 1
                       DVAL = CVAL*WVAL*FC
                       CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI2),1)
                     ENDIF
                   ENDDO
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         FC,JCI2,JCI1,IO1,JJ,ION,ION,IND,J1,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         -FC,JCI2,JCI1,IO1,ION,ION,JJ,J3,J2,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                 ENDIF
C
 1685         CONTINUE
C
 1705         CONTINUE
C
 4712         CONTINUE
C
C  LOOP OVER BETA DETS OF THE RIGHT GROUP AND SYMMETRY.
C
              CALL RESETCO(LBOX3,NSPACE,NB,IBMA,IBMI,LBOX4)
C
              DO 4700 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB,IGA2).NE.1) GOTO 4690
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
              JCI2 = JPZA2 + LDISB(KSYM,IGB,IGA2)
C
              CALL RESETDE(LBOX3,NSPACE,NB,MSTA,IBCON1)
              ISTB = 1
              DO 4680 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 IENB = LSBC(KKB)
                 DO IIZ=ISTB,IENB-1
                    CALL MOVEUP2(LBOX3,NSPACE,NB,MSTA,IBCON1)
                 ENDDO
                 ISTB = IENB
                 JCI1 = JCI1 + 1
                 JCI2 = JCI2 + 1
                 FC = KPER1
C
                 DO 4670 IK=1,NB
                    ION = IBCON1(IK)
                    J1 = INDEX(ION+1)
                    JMA = MAX(J1,IND)
                    JMI = MIN(J1,IND)
C
                 CALL VCLR(YAOG,1,NXYZ)
                 CALL HSMLTN(YAOG,YAOTMP,IO1,JJ,ION,ION,IND,J1,NACT,
     *                       NNACT,NXYZ,ONE)
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     CVAL = CI(JCI2,ISTAT)
                     WVAL = WSTATE(ISTAT)
                     IF(ABS(CVAL).GT.TOL) THEN
                       IWI1 = (ISTAT-1)*NDETLN + JCI1 - JLO + 1
                       DVAL = CVAL*WVAL*FC
                       CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI1),1)
                     ENDIF
                   ENDDO
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         FC,JCI1,JCI2,IO1,JJ,ION,ION,IND,J1,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                 ENDIF
C
                 IF(JCI2.GE.JLO .AND. JCI2.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     CVAL = CI(JCI1,ISTAT)
                     WVAL = WSTATE(ISTAT)
                     IF(ABS(CVAL).GT.TOL) THEN
                       IWI2 = (ISTAT-1)*NDETLN + JCI2 - JLO + 1
                       DVAL = CVAL*WVAL*FC
                       CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI2),1)
                     ENDIF
                   ENDDO
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         FC,JCI2,JCI1,IO1,JJ,ION,ION,IND,J1,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                 ENDIF
C
 4670            CONTINUE
C
 4680         CONTINUE
C
 4690         CALL PUSHCO(LBOX3,NSPACE,NB,IBMA,IBMI,LBOX4,IEND)
 4700         CONTINUE
C
C --  DOUBLE ALPHA EXCITATIONS START HERE  ---
C
 4800         CONTINUE
C
            IF (IA1.EQ.NA) GOTO 4850
            IF (JJ.EQ.NACT) GOTO 4850
C
            DO II=1,NSPACE
               LBOX3(II) = LBOX2(II)
            ENDDO
            IAES3 = 1
            DO KK=1,ISPA1-1
               IAES3 = IAES3 + LBOX2(KK)
            ENDDO
C
C  LOOP OVER SPACES TO EXCITE ELECTRONS FROM, MUST BE GE THAN
C  SPACE OF FIRST EXCITATION, ISPA1.
C
            DO 3890 ISPA3 = ISPA1,NSPACE
               IF (LBOX1(ISPA3).EQ.0) GOTO 3887
               IF (ISPA3.EQ.ISPA1.AND.IA1.EQ.IEAE) GOTO 3887
               IOC3 = LBOX2(ISPA3)
               IF (IOC3.EQ.0) GOTO 3887
C
               IAEE3 = IAES3 + LBOX2(ISPA3)-1
               LBOX3(ISPA3) = LBOX3(ISPA3)-1
C
C  LOOP OVER ELECTRONS IN ISPA3, WHICH ARE LARGER THAN IA1,
C  MAKING SURE IT ISN'T THE ALREADY EXCITED ELECTRON.
C
               JSTA3 = IAES3
               IF (ISPA3.EQ.ISPA1) THEN
                  JSTA3=IA1
                  IF (IGAP-1.EQ.IA1) JSTA3=JSTA3+1
               ENDIF
C
               DO 3880 IA3=JSTA3,IAEE3
                  IF (IA3.EQ.IGAP-1) GOTO 3880
                  IO3 = IACON2(IA3)
                  IS3 = IOB(IO3)
C
C  LOOP OVER SPACES TO EXCITE ELECTRON INTO.  MUST BE GE THAN
C  SPACE FIRST ELECTRON WAS EXCITED INTO.
C
                  IGAE3 = 0
                  DO JIK=1,ISPA2-1
                     IGAE3 = IGAE3 + LBOX2(JIK)
                  ENDDO
                  DO 3850 ISPA4=ISPA2,NSPACE
C
C  IGAS3, IGAE3 ARE ELECTRONS SPECIFYING ISPA4 SPACE ELECTRON LIMITS.
C
                  LBOX3(ISPA4) = LBOX3(ISPA4) + 1
                  IGAS3 = IGAE3 + 1
                  IGAE3 = IGAE3 + LBOX2(ISPA4)
                  IF (LBOX3(ISPA3).LT.IAMI(ISPA3)) GOTO 3840
                  IF (LBOX3(ISPA4).GT.IAMA(ISPA4)) GOTO 3840
             IF (ISPA4.EQ.ISPA2.AND.JJ.EQ.MSTA(ISPA2+1)-1) GOTO 3840
C
C  GET GROUP NUMBER
C
               CALL POSITCO(LBOX5,NSPACE,NA,IAMA,IAMI,LBOX4,LBOX3,IGA3)
               NIAS3 = NAST(IGA3)
C
C  MAKE GAP INFORMATION HERE.
C
                  IGAA3 = MAX(IGAS3,IGAP)
C
                  IF (LBOX2(ISPA4).EQ.0) THEN
                     ISTA3 = MSTA(ISPA4)
                     IEND3 = MSTA(ISPA4+1)-1
                  ELSEIF (ISPA4.EQ.ISPA2) THEN
                     ISTA3 = JJ+1
                     IEND3 = IACON2(IGAA3)-1
C
C  I AM SUSPECT ABOUT THIS NEXT LINE, WE'LL SEE WHAT HAPPENS.......
C
                     IF (IGAP-1.EQ.IGAE3) IEND3=MSTA(ISPA2+1)-1
C
                  ELSE
                     ISTA3 = MSTA(ISPA4)
                     IEND3 = IACON2(IGAA3)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 3830 IGAP3=IGAA3,IGAE3+1
C
                     DO 3820 JJ3=ISTA3,IEND3
                        IS4 = IOB(JJ3)
                        IP2 = LGMUL(IS3,IS4)
                        IF (IP1.NE.IP2) GOTO 3820
C
              CALL REDE00(IACON2,IBCON1,NA,IA3,IGAP3-1,JJ3,JPERA3)
              CALL IDPOST(IBCON1,NA,LBOX3,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LANDET(1,IGA3),IBCON2,JPOSA3)
C              IPER3 = ((-1)**(JPERA3+JPERA))*2
              IPER3 = (-1)**(JPERA3+JPERA)
              KAPOS3 = JPOSA3 + NIAS3
              JPZA3 = LSPA(KAPOS3)
                 JMA=MAX(JJ3,IO3)
                 JMI=MIN(JJ3,IO3)
                 I2 = INDEX(JMA) + JMI
                 II1 = INDEX(JJ3) + IO1
                 JMA=MAX(IO3,JJ)
                 JMI=MIN(IO3,JJ)
                 II2 = INDEX(JMA) + JMI
                 JMA=MAX(II1,II2)
                 JMI=MIN(II1,II2)
C
                 CALL VCLR(YAOG,1,NXYZ)
                 CALL HSMLTN(YAOG,YAOTMP,IO1,JJ,IO3,JJ3,IND,I2,NACT,
     *                       NNACT,NXYZ,ONE)
                 CALL HSMLTN(YAOG,YAOTMP,IO1,JJ3,IO3,JJ,II1,II2,NACT,
     *                       NNACT,NXYZ,-ONE)
C
C
C  LOOP OVER BETA STRINGS OF RIGHT SYMMETRY AND GROUP.
C
              DO 3700 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB,IGA3).NE.1) GOTO 3700
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
              JCI3 = JPZA3 + LDISB(KSYM,IGB,IGA3)
C
              DO 3680 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 JCI1 = JCI1 + 1
                 JCI3 = JCI3 + 1
                 FC = IPER3
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     CVAL = CI(JCI3,ISTAT)
                     WVAL = WSTATE(ISTAT)
                     IF(ABS(CVAL).GT.TOL) THEN
                       IWI1 = (ISTAT-1)*NDETLN + JCI1 - JLO + 1
                       DVAL = CVAL*WVAL*FC
                       CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI1),1)
                     ENDIF
                   ENDDO
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         FC,JCI1,JCI3,IO1,JJ,IO3,JJ3,IND,I2,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         -FC,JCI1,JCI3,IO1,JJ3,IO3,JJ,II1,II2,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                 ENDIF
C
                 IF(JCI3.GE.JLO .AND. JCI3.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     CVAL = CI(JCI1,ISTAT)
                     WVAL = WSTATE(ISTAT)
                     IF(ABS(CVAL).GT.TOL) THEN
                       IWI3 = (ISTAT-1)*NDETLN + JCI3 - JLO + 1
                       DVAL = CVAL*WVAL*FC
                       CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI3),1)
                     ENDIF
                   ENDDO
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         FC,JCI3,JCI1,IO1,JJ,IO3,JJ3,IND,I2,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         -FC,JCI3,JCI1,IO1,JJ3,IO3,JJ,II1,II2,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                 ENDIF
C
 3680         CONTINUE
C
 3700         CONTINUE
C
 3820                CONTINUE
C
                     ISTA3 = IACON2(IGAP3)+1
                     IEND3 = IACON2(IGAP3+1)-1
                     IF (IGAP3.EQ.IGAE3) IEND3=MSTA(ISPA4+1)-1
 3830             CONTINUE
C
 3840             LBOX3(ISPA4) = LBOX3(ISPA4) - 1
 3850             CONTINUE
C
 3880          CONTINUE
C
               LBOX3(ISPA3) = LBOX3(ISPA3)+1
 3887          IAES3 = IAES3 + LBOX3(ISPA3)
 3890       CONTINUE
C
 4850                CONTINUE
C
                  ISTA = IACON1(IGAP)+1
                  IEND = IACON1(IGAP+1)-1
                  IF (IGAP.EQ.IGAE) IEND=MSTA(ISPA2+1)-1
 4860             CONTINUE
C
 4870             LBOX2(ISPA2) = LBOX2(ISPA2) - 1
 4880          CONTINUE
C
 4885          CONTINUE
C
               LBOX2(ISPA1) = LBOX2(ISPA1)+1
 4890       CONTINUE
C
C  DIAGONAL ELEMENTS HERE
C
            DO 67 II=1,NA
               I1 = IACON1(II)
               IND1 = INDEX(I1+1)
C
C  LOOP OVER BETA STRINGS OF RIGHT SYMMETRY AND GROUP.
C
              DO 3705 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1) GOTO 3705
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
C
              DO 3685 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 JCI1 = JCI1 + 1
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   CALL HSMLT1(AVEC,YAC,BVEC,RHSC,CI,OINT,AMAT,
     *                         ONE,JCI1,JCI1,IND1,I1,I1,JLO,
     *                         NSTATS,NCI,NDETLN,L1,NCOR,
     *                         NNACT,NXYZ,WSTATE,SALAG,ITER)
                 ENDIF
C
 3685         CONTINUE
C
 3705         CONTINUE
C
              DO 64 JJ=II+1,NA
                 I2 = IACON1(JJ)
                 IND2 = INDEX(I2+1)
                 INDM = IND2 - I2 + I1
                 J1 = INDEX(INDM+1)
                 J2 = INDEX(IND2) + IND1
C
                 CALL VCLR(YAOG,1,NXYZ)
                 CALL HSMLTN(YAOG,YAOTMP,I1,I1,I2,I2,IND1,IND2,NACT,
     *                       NNACT,NXYZ,ONE)
                 CALL HSMLTN(YAOG,YAOTMP,I1,I2,I2,I1,INDM,INDM,NACT,
     *                       NNACT,NXYZ,-ONE)
C
C
              DO 3710 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1) GOTO 3710
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
C
              DO 3690 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 JCI1 = JCI1 + 1
                 FC = IPER3
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     CVAL = CI(JCI1,ISTAT)
                     WVAL = WSTATE(ISTAT)
                     IF(ABS(CVAL).GT.TOL) THEN
                       IWI1 = (ISTAT-1)*NDETLN + JCI1 - JLO + 1
                       DVAL = CVAL*WVAL
                       CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI1),1)
                     ENDIF
                   ENDDO
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         ONE,JCI1,JCI1,I1,I1,I2,I2,IND1,IND2,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         -ONE,JCI1,JCI1,I1,I2,I2,I1,INDM,INDM,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                 ENDIF
C
 3690         CONTINUE
C
 3710         CONTINUE
C
   64         CONTINUE
C
C  LOOP OVER BETA DETS OF THE RIGHT GROUP AND SYMMETRY.
C
              CALL RESETCO(LBOX3,NSPACE,NB,IBMA,IBMI,LBOX4)
C
              DO 4709 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1) GOTO 4699
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
C
              CALL RESETDE(LBOX3,NSPACE,NB,MSTA,IBCON1)
              ISTB = 1
              DO 4689 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 IENB = LSBC(KKB)
                 DO IIZ=ISTB,IENB-1
                    CALL MOVEUP2(LBOX3,NSPACE,NB,MSTA,IBCON1)
                 ENDDO
                 ISTB = IENB
                 JCI1 = JCI1 + 1
                 IF(JCI1.LT.JLO .OR. JCI1.GT.JHI) GO TO 4689
C
                 DO 4679 IK=1,NB
                    I2 = IBCON1(IK)
                    IND2 = INDEX(I2+1)
                    JMI = MIN(IND1,IND2)
                    JMA = MAX(IND1,IND2)
                    J2 = INDEX(JMA) + JMI
C
                   CALL VCLR(YAOG,1,NXYZ)
                   CALL HSMLTN(YAOG,YAOTMP,I1,I1,I2,I2,IND1,IND2,NACT,
     *                         NNACT,NXYZ,ONE)
C
                   DO ISTAT=1,NSTATS
                     CVAL = CI(JCI1,ISTAT)
                     WVAL = WSTATE(ISTAT)
                     IF(ABS(CVAL).GT.TOL) THEN
                       IWI1 = (ISTAT-1)*NDETLN + JCI1 - JLO + 1
                       DVAL = CVAL*WVAL
                       CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI1),1)
                     ENDIF
                   ENDDO
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         ONE,JCI1,JCI1,I1,I1,I2,I2,IND1,IND2,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
C
 4679            CONTINUE
C
 4689         CONTINUE
C
 4699         CALL PUSHCO(LBOX3,NSPACE,NB,IBMA,IBMI,LBOX4,IEND)
 4709         CONTINUE
C
   67       CONTINUE
C
C  --- END OF LOOP OVER SINGLE ALPHA EXCITATIONS. ---
C      NOW TO SORT THEM BY POSITIONS WITHIN SYMMETRIES.
C
            DO II=1,NSYM
               CALL FCPSRT3(IGROA(1,II),IPERA(1,II),IIND1(1,II),
     *                   IPOSA(1,II),IMMC(II),IIND2(1,II),IIND3(1,II))
            ENDDO
C
C  --- END OF LOOP OVER PURE ALPHA EXCITATIONS.
C  NOW TO LOOP OVER ALL SIMULTANEOUS AB -> A'B' EXCITATIONS.
C
      IF (NSPACE.EQ.1) GOTO 3400
C
C  ***** GENERAL CASE OF MORE THAN ONE SPACE !!!!! *******
C
      IF (.NOT.FDIRCT) THEN
C
C  LOOP OVER SINGLE ALPHA EXCITES WITHIN EACH SYMMETRY.
C
      DO 3000 ISAE=1,NSYM
         KBSYM=KTAB(ISAE)
         DO 2900 JSAE=1,IMMC(ISAE)
            JPOSAE=IPOSA(JSAE,ISAE)
            JPERAE=IPERA(JSAE,ISAE)
            JINDAE=IIND1(JSAE,ISAE)
            JGROAE=IGROA(JSAE,ISAE)
C
            IXI = IIND2(JSAE,ISAE)
            IXJ = IIND3(JSAE,ISAE)
C
C
C  IF ISAE.EQ.JASYM THEN SPECIAL CASE.
C
       IF (ISAE.EQ.JASYM.AND.IGA.EQ.JGROAE) THEN
C
C  LOOP OVER ALL RELEVANT BETAS
C
            LABPOS = JPZA1
            LABPOS2 = JPOSAE
            DO 2813 IGB=1,ITGB
               IF (LGCOM(IGB,IGA).NE.1) GOTO 2813
               NIBS = NBST(IGB)
               DO 2763 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                  LABPOS = LABPOS + 1
                  LABPOS2 = LABPOS2 + 1
                  IBPOS = NIBS + LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2613 JBINDX=JB1ST(KBSYM,IBPOS),JB1ST(KBSYM+1,IBPOS)-1
                  IGB2=JB1GR(JBINDX)
                  IF (LGCOM(IGB2,JGROAE).NE.1) GOTO 2613
C
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  JCIB=JPOSAE+LDISB(KBSYM,IGB2,JGROAE)+JB1PO(JBINDX)
                  JCIB2=JPZA1+LDISB(KBSYM,IGB2,JGROAE)+JB1PO(JBINDX)
C
                  FC = JPERAE*JB1PE(JBINDX)
                  IXK = JB1IN2(JBINDX,1)
                  IXL = JB1IN2(JBINDX,2)
                  CALL VCLR(YAOG,1,NXYZ)
                  CALL HSMLTN(YAOG,YAOTMP,IXI,IXJ,IXK,IXL,JINDAE,
     *                        JB1IN(JBINDX),NACT,NNACT,NXYZ,ONE)
C
                  IF(LABPOS.GE.JLO .AND. LABPOS.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      CVAL = CI(JCIB,ISTAT)
                      WVAL = WSTATE(ISTAT)
                      IF(ABS(CVAL).GT.TOL) THEN
                        IWI1 = (ISTAT-1)*NDETLN + LABPOS - JLO + 1
                        DVAL = CVAL*WVAL*FC
                        CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI1),1)
                      ENDIF
                    ENDDO
                    CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                          FC,LABPOS,JCIB,IXI,IXJ,IXK,IXL,JINDAE,
     *                          JB1IN(JBINDX),NACT,NNACT,NSTATS,NXYZ,
     *                          NCI,NDETLN,JLO,L1,NCOR,SALAG,ITER,KILL)
                  ENDIF
C
                  IF(JCIB.GE.JLO .AND. JCIB.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      CVAL = CI(LABPOS,ISTAT)
                      WVAL = WSTATE(ISTAT)
                      IF(ABS(CVAL).GT.TOL) THEN
                        IWIB = (ISTAT-1)*NDETLN + JCIB - JLO + 1
                        DVAL = CVAL*WVAL*FC
                        CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWIB),1)
                      ENDIF
                    ENDDO
                    CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                          FC,JCIB,LABPOS,IXI,IXJ,IXK,IXL,JINDAE,
     *                          JB1IN(JBINDX),NACT,NNACT,NSTATS,NXYZ,
     *                          NCI,NDETLN,JLO,L1,NCOR,SALAG,ITER,KILL)
                  ENDIF
C
                  IF(LABPOS2.GE.JLO .AND. LABPOS2.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      CVAL = CI(JCIB2,ISTAT)
                      WVAL = WSTATE(ISTAT)
                      IF(ABS(CVAL).GT.TOL) THEN
                        IWI1 = (ISTAT-1)*NDETLN + LABPOS2 - JLO + 1
                        DVAL = CVAL*WVAL*FC
                        CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI1),1)
                      ENDIF
                    ENDDO
                    CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                          FC,LABPOS2,JCIB2,IXI,IXJ,IXK,IXL,JINDAE,
     *                          JB1IN(JBINDX),NACT,NNACT,NSTATS,NXYZ,
     *                          NCI,NDETLN,JLO,L1,NCOR,SALAG,ITER,KILL)
                  ENDIF
C
                  IF(JCIB2.GE.JLO .AND. JCIB2.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      CVAL = CI(LABPOS2,ISTAT)
                      WVAL = WSTATE(ISTAT)
                      IF(ABS(CVAL).GT.TOL) THEN
                        IWIB = (ISTAT-1)*NDETLN + JCIB2 - JLO + 1
                        DVAL = CVAL*WVAL*FC
                        CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWIB),1)
                      ENDIF
                    ENDDO
                    CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                          FC,JCIB2,LABPOS2,IXI,IXJ,IXK,IXL,JINDAE,
     *                          JB1IN(JBINDX),NACT,NNACT,NSTATS,NXYZ,
     *                          NCI,NDETLN,JLO,L1,NCOR,SALAG,ITER,KILL)
                  ENDIF
C
 2613          CONTINUE
C
 2763          CONTINUE
 2813       CONTINUE
C
       ELSE
C
C  LOOP OVER ALL RELEVANT (A-)BETA DETS.
C
            LABPOS = JPZA1
            DO 2800 IGB=1,ITGB
               IF (LGCOM(IGB,IGA).NE.1) GOTO 2800
               NIBS = NBST(IGB)
               DO 2750 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                  LABPOS = LABPOS + 1
                  IBPOS = NIBS + LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2600 JBINDX=JB1ST(KBSYM,IBPOS),JB1ST(KBSYM+1,IBPOS)-1
                  IGB2=JB1GR(JBINDX)
                  IF (LGCOM(IGB2,JGROAE).NE.1) GOTO 2600
C
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  JCIB=JPOSAE+LDISB(KBSYM,IGB2,JGROAE)+JB1PO(JBINDX)
C
                  FC = JPERAE*JB1PE(JBINDX)
                  IXK = JB1IN2(JBINDX,1)
                  IXL = JB1IN2(JBINDX,2)
                  CALL VCLR(YAOG,1,NXYZ)
                  CALL HSMLTN(YAOG,YAOTMP,IXI,IXJ,IXK,IXL,JINDAE,
     *                        JB1IN(JBINDX),NACT,NNACT,NXYZ,ONE)
C
                  IF(LABPOS.GE.JLO .AND. LABPOS.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      CVAL = CI(JCIB,ISTAT)
                      WVAL = WSTATE(ISTAT)
                      IF(ABS(CVAL).GT.TOL) THEN
                        IWI1 = (ISTAT-1)*NDETLN + LABPOS - JLO + 1
                        DVAL = CVAL*WVAL*FC
                        CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI1),1)
                      ENDIF
                    ENDDO
                    CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                          FC,LABPOS,JCIB,IXI,IXJ,IXK,IXL,JINDAE,
     *                          JB1IN(JBINDX),NACT,NNACT,NSTATS,NXYZ,
     *                          NCI,NDETLN,JLO,L1,NCOR,SALAG,ITER,KILL)
                  ENDIF
C
                  IF(JCIB.GE.JLO .AND. JCIB.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      CVAL = CI(LABPOS,ISTAT)
                      WVAL = WSTATE(ISTAT)
                      IF(ABS(CVAL).GT.TOL) THEN
                        IWIB = (ISTAT-1)*NDETLN + JCIB - JLO + 1
                        DVAL = CVAL*WVAL*FC
                        CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWIB),1)
                      ENDIF
                    ENDDO
                    CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                          FC,JCIB,LABPOS,IXI,IXJ,IXK,IXL,JINDAE,
     *                          JB1IN(JBINDX),NACT,NNACT,NSTATS,NXYZ,
     *                          NCI,NDETLN,JLO,L1,NCOR,SALAG,ITER,KILL)
                  ENDIF
C
 2600          CONTINUE
C
 2750          CONTINUE
 2800       CONTINUE
C
C  LOOP OVER ALL RELEVANT (A'-)BETA DETS.
C
            LABPOS = JPOSAE
            DO 2803 IGB=1,ITGB
               IF (LGCOM(IGB,JGROAE).NE.1) GOTO 2803
               NIBS = NBST(IGB)
               DO 2753 KKB=LSBS(KBSYM,IGB),LSBS(KBSYM+1,IGB)-1
                  LABPOS = LABPOS + 1
                  IBPOS = NIBS + LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2603 JBINDX=JB1ST(KSYM,IBPOS),JB1ST(KSYM+1,IBPOS)-1
                  IGB2=JB1GR(JBINDX)
                  IF (LGCOM(IGB2,IGA).NE.1) GOTO 2603
C
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  JCIB=JPZA1+LDISB(KSYM,IGB2,IGA)+JB1PO(JBINDX)
C
                  FC = JPERAE*JB1PE(JBINDX)
                  IXK = JB1IN2(JBINDX,1)
                  IXL = JB1IN2(JBINDX,2)
                  CALL VCLR(YAOG,1,NXYZ)
                  CALL HSMLTN(YAOG,YAOTMP,IXI,IXJ,IXK,IXL,JINDAE,
     *                        JB1IN(JBINDX),NACT,NNACT,NXYZ,ONE)
C
                  IF(LABPOS.GE.JLO .AND. LABPOS.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      CVAL = CI(JCIB,ISTAT)
                      WVAL = WSTATE(ISTAT)
                      IF(ABS(CVAL).GT.TOL) THEN
                        IWI1 = (ISTAT-1)*NDETLN + LABPOS - JLO + 1
                        DVAL = CVAL*WVAL*FC
                        CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI1),1)
                      ENDIF
                    ENDDO
                    CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                          FC,LABPOS,JCIB,IXI,IXJ,IXK,IXL,JINDAE,
     *                          JB1IN(JBINDX),NACT,NNACT,NSTATS,NXYZ,
     *                          NCI,NDETLN,JLO,L1,NCOR,SALAG,ITER,KILL)
                  ENDIF
C
                  IF(JCIB.GE.JLO .AND. JCIB.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      CVAL = CI(LABPOS,ISTAT)
                      WVAL = WSTATE(ISTAT)
                      IF(ABS(CVAL).GT.TOL) THEN
                        IWIB = (ISTAT-1)*NDETLN + JCIB - JLO + 1
                        DVAL = CVAL*WVAL*FC
                        CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWIB),1)
                      ENDIF
                    ENDDO
                    CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                          FC,JCIB,LABPOS,IXI,IXJ,IXK,IXL,JINDAE,
     *                          JB1IN(JBINDX),NACT,NNACT,NSTATS,NXYZ,
     *                          NCI,NDETLN,JLO,L1,NCOR,SALAG,ITER,KILL)
                  ENDIF
C
 2603          CONTINUE
C
 2753          CONTINUE
 2803       CONTINUE
C
      ENDIF
C
 2900    CONTINUE
 3000 CONTINUE
C
      ELSE
C
C  ***** DIRECT METHOD BELOW *****
C
      DO 4000 ISAE=1,NSYM
         KBSYM = KTAB(ISAE)
C
C  ANALYSE EXCITED A' GROUPS FOR COMPATIBILITY WITH B.
C
      NGRPS = 0
      DO 1976 II=1,IMMC(ISAE)
         ICGR = IGROA(II,ISAE)
         DO JJ=1,NGRPS
            IF (JB1GR(JJ).EQ.ICGR) GOTO 1976
         ENDDO
         NGRPS = NGRPS + 1
         JB1GR(NGRPS) = ICGR
 1976 CONTINUE
C
C FIRST TYPE OF BETAS, KSYM -> KBSYM
C
          CALL RESETCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3)
          DO 7400 IGB=1,ITGB
             IF (LGCOM(IGB,IGA).NE.1) GOTO 7399
             LAB1 = JPZA1 + LDISB(KSYM,IGB,IGA)
C
             CALL RESETDE(LBOX2,NSPACE,NB,MSTA,IBCON1)
             NIBS = NBST(IGB)
             ISTB = 1
             DO 7300 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                IENB = LSBC(KKB)
                DO IIZ=ISTB,IENB-1
                   CALL MOVEUP2(LBOX2,NSPACE,NB,MSTA,IBCON1)
                ENDDO
                ISTB = IENB
C
                IBPOS = NIBS + LSBC(KKB)
                LABPOS = LAB1 + LSPB(IBPOS)
C
C LOOP OVER SINGLE BETA EXCITES FROM IBPOS WHICH ARE OF SYMMETRY KBSYM
C
                MESYM1 = LGMUL(KSYM,KBSYM)
                DO II=1,NSPACE
                   LBOX3(II) = LBOX2(II)
                ENDDO
                IEBS = NB + 1
                DO 7290 ISPB1=NSPACE,1,-1
                   IOC1 = LBOX2(ISPB1)
                   IEBE = IEBS - 1
                   IEBS = IEBS - IOC1
                   IF (IOC1.EQ.0) GO TO 7290
                   LBOX3(ISPB1) = LBOX3(ISPB1)-1
C
C  LOOP ELECTRONS IN SPACE ISPB1
C  IEBS, IEBE ARE THE ELECTRONS IN SPACE ISPB1
C
                DO 7285 IB1 = IEBE,IEBS,-1
                   IO1 = IBCON1(IB1)
                   MESYM2 = LGMUL(MESYM1,IOB(IO1))
                   IGBE = IEBE - LBOX2(ISPB1)
C
C  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
C
                DO 7280 ISPB2=ISPB1,NSPACE
C
C  IGBS,IGBE ARE ELECTRONS SPECIFYING ISPB2 SPACE ELECTRON LIMITS.
C
                   IGBS = IGBE + 1
                   IGBE = IGBE + LBOX2(ISPB2)
C
                   LBOX3(ISPB2) = LBOX3(ISPB2) + 1
                   IF (LBOX3(ISPB1).LT.IBMI(ISPB1)) GO TO 7270
                   IF (LBOX3(ISPB2).GT.IBMA(ISPB2)) GO TO 7270
C
C  GET GROUP NUMBER
C
          CALL POSITCO(LBOX5,NSPACE,NB,IBMA,IBMI,LBOX4,LBOX3,IGB2)
          NIAS = NBST(IGB2)
C
C CHECK FOR A' GROUP COMPATIBILITY
C
             DO II=1,NGRPS
                IAGRP = JB1GR(II)
                IF (LGCOM(IGB2,IAGRP).EQ.1) GOTO 7555
             ENDDO
             GOTO 7270
 7555        CONTINUE
C
C  MAKE GAP INFORMATION HERE.
C
                  IGBA = MAX(IB1+1,IGBS)
                  IF (LBOX2(ISPB2).EQ.0) THEN
                     ISTA = MSTA(ISPB2)
                     IEND = MSTA(ISPB2+1)-1
                  ELSEIF (ISPB2.EQ.ISPB1) THEN
                     ISTA = IO1+1
                     IEND = IBCON1(IGBA)-1
                     IF (IB1.EQ.IEBE) IEND=MSTA(ISPB1+1)-1
                  ELSE
                     ISTA = MSTA(ISPB2)
                     IEND = IBCON1(IGBA)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 7260 IGAP=IGBA,IGBE+1
C
                     DO 7250 JJ=ISTA,IEND
C
C CHECK TO SEE IF EXCITED BETA IS OF RIGHT SYMMETRY (KBSYM)
C
            IF (IOB(JJ).NE.MESYM2) GOTO 7250
C
            IND1 = INDEX(JJ) + IO1
            CALL REDE00(IBCON1,IBCON2,NB,IB1,IGAP-1,JJ,IPER)
            CALL IDPOST(IBCON2,NB,LBOX3,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LBNDET(1,IGB2),IACON2,IPOSB)
            JB1P = LSPB(IPOSB + NIAS)
C
            DO 3900 JSAE=1,IMMC(ISAE)
               JGROAE=IGROA(JSAE,ISAE)
               IF (LGCOM(IGB2,JGROAE).NE.1) GOTO 3900
C
               JPOSAE=IPOSA(JSAE,ISAE)
               JCIB = JB1P + JPOSAE + LDISB(KBSYM,IGB2,JGROAE)
C
               JINDAE=IIND1(JSAE,ISAE)
               JMA=MAX(JINDAE,IND1)
               JMI=MIN(JINDAE,IND1)
C
               JPERAE=IPERA(JSAE,ISAE)
 3900       CONTINUE
C
 7250                CONTINUE
C
                  ISTA = IBCON1(IGAP)+1
                  IEND = IBCON1(IGAP+1)-1
                  IF (IGAP.EQ.IGBE) IEND=MSTA(ISPB2+1)-1
 7260             CONTINUE
C
 7270              LBOX3(ISPB2) = LBOX3(ISPB2) - 1
 7280           CONTINUE
C
 7285           CONTINUE
C
                   LBOX3(ISPB1) = LBOX3(ISPB1) + 1
 7290           CONTINUE
C
 7300        CONTINUE
C
 7399        CALL PUSHCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3,IEND)
 7400     CONTINUE
C
C
C SECOND TYPE OF BETAS, KBSYM -> KSYM
C
          CALL RESETCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3)
          DO 7801 IGB=1,ITGB
C
C CHECK FOR A' GROUP COMPATIBILITY
C
             DO II=1,NGRPS
                IAGRP = JB1GR(II)
                IF (LGCOM(IGB,IAGRP).EQ.1) GOTO 7655
             ENDDO
             GOTO 7799
 7655        CONTINUE
C
             CALL RESETDE(LBOX2,NSPACE,NB,MSTA,IBCON1)
             NIBS = NBST(IGB)
             ISTB = 1
C
             DO 7701 KKB=LSBS(KBSYM,IGB),LSBS(KBSYM+1,IGB)-1
                IENB = LSBC(KKB)
                DO IIZ=ISTB,IENB-1
                   CALL MOVEUP2(LBOX2,NSPACE,NB,MSTA,IBCON1)
                ENDDO
                ISTB = IENB
C
                IBPOS = NIBS + LSBC(KKB)
                LAB1 = LSPB(IBPOS)
C
C LOOP OVER SINGLE BETA EXCITES FROM IBPOS WHICH ARE OF SYMMETRY KSYM
C
                MESYM1 = LGMUL(KSYM,KBSYM)
                DO II=1,NSPACE
                   LBOX3(II) = LBOX2(II)
                ENDDO
                IEBS = NB + 1
                DO 7691 ISPB1=NSPACE,1,-1
                   IOC1 = LBOX2(ISPB1)
                   IEBE = IEBS - 1
                   IEBS = IEBS - IOC1
                   IF (IOC1.EQ.0) GO TO 7691
                   LBOX3(ISPB1) = LBOX3(ISPB1)-1
C
C  LOOP ELECTRONS IN SPACE ISPB1
C  IEBS, IEBE ARE THE ELECTRONS IN SPACE ISPB1
C
                DO 7686 IB1 = IEBE,IEBS,-1
                   IO1 = IBCON1(IB1)
                   MESYM2 = LGMUL(MESYM1,IOB(IO1))
                   IGBE = IEBE - LBOX2(ISPB1)
C
C  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
C
                DO 7681 ISPB2=ISPB1,NSPACE
C
C  IGBS,IGBE ARE ELECTRONS SPECIFYING ISPB2 SPACE ELECTRON LIMITS.
C
                   IGBS = IGBE + 1
                   IGBE = IGBE + LBOX2(ISPB2)
C
                   LBOX3(ISPB2) = LBOX3(ISPB2) + 1
                   IF (LBOX3(ISPB1).LT.IBMI(ISPB1)) GO TO 7671
                   IF (LBOX3(ISPB2).GT.IBMA(ISPB2)) GO TO 7671
C
          CALL POSITCO(LBOX5,NSPACE,NB,IBMA,IBMI,LBOX4,LBOX3,IGB2)
          IF (LGCOM(IGB2,IGA).NE.1) GOTO 7671
          JCIBS = JPZA1 + LDISB(KSYM,IGB2,IGA)
          NIAS = NBST(IGB2)
C
C  MAKE GAP INFORMATION HERE.
C
                  IGBA = MAX(IB1+1,IGBS)
                  IF (LBOX2(ISPB2).EQ.0) THEN
                     ISTA = MSTA(ISPB2)
                     IEND = MSTA(ISPB2+1)-1
                  ELSEIF (ISPB2.EQ.ISPB1) THEN
                     ISTA = IO1+1
                     IEND = IBCON1(IGBA)-1
                     IF (IB1.EQ.IEBE) IEND=MSTA(ISPB1+1)-1
                  ELSE
                     ISTA = MSTA(ISPB2)
                     IEND = IBCON1(IGBA)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 7660 IGAP=IGBA,IGBE+1
C
                     DO 7650 JJ=ISTA,IEND
C
C CHECK TO SEE IF EXCITED BETA IS OF RIGHT SYMMETRY (KBSYM)
C
            IF (IOB(JJ).NE.MESYM2) GOTO 7650
C
            IND1 = INDEX(JJ) + IO1
            CALL REDE00(IBCON1,IBCON2,NB,IB1,IGAP-1,JJ,IPER)
            CALL IDPOST(IBCON2,NB,LBOX3,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LBNDET(1,IGB2),IACON2,IPOSB)
            JCIB= JCIBS + LSPB(IPOSB + NIAS)
C
            DO 4300 JSAE=1,IMMC(ISAE)
               JGROAE=IGROA(JSAE,ISAE)
               IF (LGCOM(IGB,JGROAE).NE.1) GOTO 4300
C
               JPOSAE=IPOSA(JSAE,ISAE)
               LABPOS = LAB1 + JPOSAE + LDISB(KBSYM,IGB,JGROAE)
C
               JINDAE=IIND1(JSAE,ISAE)
               JMA=MAX(JINDAE,IND1)
               JMI=MIN(JINDAE,IND1)
C
               JPERAE=IPERA(JSAE,ISAE)
 4300       CONTINUE
C
 7650                CONTINUE
C
                  ISTA = IBCON1(IGAP)+1
                  IEND = IBCON1(IGAP+1)-1
                  IF (IGAP.EQ.IGBE) IEND=MSTA(ISPB2+1)-1
 7660             CONTINUE
C
 7671              LBOX3(ISPB2) = LBOX3(ISPB2) - 1
 7681           CONTINUE
C
 7686           CONTINUE
C
                   LBOX3(ISPB1) = LBOX3(ISPB1) + 1
 7691           CONTINUE
C
 7701        CONTINUE
C
 7799        CALL PUSHCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3,IEND)
 7801     CONTINUE
C
 4000 CONTINUE
C
      ENDIF
C
C  ***** END OF DIRECT OPTION *****
C
C  **** END OF GENERAL CASE OF MORE THAN ONE SPACE ******
C
      GOTO 4899
C
 3400 CONTINUE
C
C ***** SPECIAL CASE OF ONE SPACE !!!!! ******
C
C  LOOP OVER SINGLE ALPHA EXCITES WITHIN EACH SYMMETRY.
C
       DO 2901 ISAE=1,NSYM
          KBSYM=KTAB(ISAE)
          DO 2801 JSAE=1,IMMC(ISAE)
                JPOSAE=IPOSA(JSAE,ISAE)
                JPERAE=IPERA(JSAE,ISAE)
                JINDAE=IIND1(JSAE,ISAE)
                JGROAE=IGROA(JSAE,ISAE)
C
                IXI = IIND2(JSAE,ISAE)
                IXJ = IIND3(JSAE,ISAE)
C
C
C  IF ISAE.EQ.JASYM THEN SPECIAL CASE.
C
       IF (ISAE.EQ.JASYM) THEN
C
C  LOOP OVER ALL RELEVANT BETAS
C
             LABPOS=JPZA1
             LABPOS2=JPOSAE
                DO 2721 KKB=LSBS(KSYM,1),LSBS(KSYM+1,1)-1
                    LABPOS = LABPOS + 1
                    LABPOS2 = LABPOS2 + 1
                    IBPOS =  LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2621 JBINDX=JB1ST(KSYM,IBPOS),JB1ST(KSYM+1,IBPOS)-1
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  JCIB = JPOSAE+JB1PO(JBINDX)
                  JCIB2 = JPZA1+JB1PO(JBINDX)
C
                  FC = JPERAE*JB1PE(JBINDX)
                  IXK = JB1IN2(JBINDX,1)
                  IXL = JB1IN2(JBINDX,2)
                  CALL VCLR(YAOG,1,NXYZ)
                  CALL HSMLTN(YAOG,YAOTMP,IXI,IXJ,IXK,IXL,JINDAE,
     *                        JB1IN(JBINDX),NACT,NNACT,NXYZ,ONE)
C
                  IF(LABPOS.GE.JLO .AND. LABPOS.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      CVAL = CI(JCIB,ISTAT)
                      WVAL = WSTATE(ISTAT)
                      IF(ABS(CVAL).GT.TOL) THEN
                        IWI1 = (ISTAT-1)*NDETLN + LABPOS - JLO + 1
                        DVAL = CVAL*WVAL*FC
                        CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI1),1)
                      ENDIF
                    ENDDO
                    CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                          FC,LABPOS,JCIB,IXI,IXJ,IXK,IXL,JINDAE,
     *                          JB1IN(JBINDX),NACT,NNACT,NSTATS,NXYZ,
     *                          NCI,NDETLN,JLO,L1,NCOR,SALAG,ITER,KILL)
                  ENDIF
C
                  IF(JCIB.GE.JLO .AND. JCIB.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      CVAL = CI(LABPOS,ISTAT)
                      WVAL = WSTATE(ISTAT)
                      IF(ABS(CVAL).GT.TOL) THEN
                        IWIB = (ISTAT-1)*NDETLN + JCIB - JLO + 1
                        DVAL = CVAL*WVAL*FC
                        CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWIB),1)
                      ENDIF
                    ENDDO
                    CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                          FC,JCIB,LABPOS,IXI,IXJ,IXK,IXL,JINDAE,
     *                          JB1IN(JBINDX),NACT,NNACT,NSTATS,NXYZ,
     *                          NCI,NDETLN,JLO,L1,NCOR,SALAG,ITER,KILL)
                  ENDIF
C
                  IF(LABPOS2.GE.JLO .AND. LABPOS2.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      CVAL = CI(JCIB2,ISTAT)
                      WVAL = WSTATE(ISTAT)
                      IF(ABS(CVAL).GT.TOL) THEN
                        IWI1 = (ISTAT-1)*NDETLN + LABPOS2 - JLO + 1
                        DVAL = CVAL*WVAL*FC
                        CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI1),1)
                      ENDIF
                    ENDDO
                    CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                          FC,LABPOS2,JCIB2,IXI,IXJ,IXK,IXL,JINDAE,
     *                          JB1IN(JBINDX),NACT,NNACT,NSTATS,NXYZ,
     *                          NCI,NDETLN,JLO,L1,NCOR,SALAG,ITER,KILL)
                  ENDIF
C
                  IF(JCIB2.GE.JLO .AND. JCIB2.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      CVAL = CI(LABPOS2,ISTAT)
                      WVAL = WSTATE(ISTAT)
                      IF(ABS(CVAL).GT.TOL) THEN
                        IWIB = (ISTAT-1)*NDETLN + JCIB2 - JLO + 1
                        DVAL = CVAL*WVAL*FC
                        CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWIB),1)
                      ENDIF
                    ENDDO
                    CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                          FC,JCIB2,LABPOS2,IXI,IXJ,IXK,IXL,JINDAE,
     *                          JB1IN(JBINDX),NACT,NNACT,NSTATS,NXYZ,
     *                          NCI,NDETLN,JLO,L1,NCOR,SALAG,ITER,KILL)
                  ENDIF
C
 2621          CONTINUE
C
 2721          CONTINUE
C
      ELSE
C
C  LOOP OVER ALL RELEVANT (A-)BETA DETS.
C
                LABPOS = JPZA1
                DO 2751 KKB=LSBS(KSYM,1),LSBS(KSYM+1,1)-1
                    LABPOS = LABPOS + 1
                    IBPOS =  LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2601 JBINDX=JB1ST(KBSYM,IBPOS),JB1ST(KBSYM+1,IBPOS)-1
C
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  JCIB=JPOSAE+JB1PO(JBINDX)
C
                  FC = JPERAE*JB1PE(JBINDX)
                  IXK = JB1IN2(JBINDX,1)
                  IXL = JB1IN2(JBINDX,2)
                  CALL VCLR(YAOG,1,NXYZ)
                  CALL HSMLTN(YAOG,YAOTMP,IXI,IXJ,IXK,IXL,JINDAE,
     *                        JB1IN(JBINDX),NACT,NNACT,NXYZ,ONE)
C
                  IF(LABPOS.GE.JLO .AND. LABPOS.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      CVAL = CI(JCIB,ISTAT)
                      WVAL = WSTATE(ISTAT)
                      IF(ABS(CVAL).GT.TOL) THEN
                        IWI1 = (ISTAT-1)*NDETLN + LABPOS - JLO + 1
                        DVAL = CVAL*WVAL*FC
                        CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI1),1)
                      ENDIF
                    ENDDO
                    CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                          FC,LABPOS,JCIB,IXI,IXJ,IXK,IXL,JINDAE,
     *                          JB1IN(JBINDX),NACT,NNACT,NSTATS,NXYZ,
     *                          NCI,NDETLN,JLO,L1,NCOR,SALAG,ITER,KILL)
                  ENDIF
C
                  IF(JCIB.GE.JLO .AND. JCIB.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      CVAL = CI(LABPOS,ISTAT)
                      WVAL = WSTATE(ISTAT)
                      IF(ABS(CVAL).GT.TOL) THEN
                        IWIB = (ISTAT-1)*NDETLN + JCIB - JLO + 1
                        DVAL = CVAL*WVAL*FC
                        CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWIB),1)
                      ENDIF
                    ENDDO
                    CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                          FC,JCIB,LABPOS,IXI,IXJ,IXK,IXL,JINDAE,
     *                          JB1IN(JBINDX),NACT,NNACT,NSTATS,NXYZ,
     *                          NCI,NDETLN,JLO,L1,NCOR,SALAG,ITER,KILL)
                  ENDIF
C
 2601          CONTINUE
C
 2751          CONTINUE
C
C  LOOP OVER ALL RELEVANT (A'-)BETA DETS.
C
               LABPOS = JPOSAE
               DO 2761 KKB=LSBS(KBSYM,1),LSBS(KBSYM+1,1)-1
                  LABPOS = LABPOS + 1
                  IBPOS = LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2611 JBINDX=JB1ST(KSYM,IBPOS),JB1ST(KSYM+1,IBPOS)-1
C
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  JCIB=JPZA1+JB1PO(JBINDX)
C
                  FC = JPERAE*JB1PE(JBINDX)
                  IXK = JB1IN2(JBINDX,1)
                  IXL = JB1IN2(JBINDX,2)
                  CALL VCLR(YAOG,1,NXYZ)
                  CALL HSMLTN(YAOG,YAOTMP,IXI,IXJ,IXK,IXL,JINDAE,
     *                        JB1IN(JBINDX),NACT,NNACT,NXYZ,ONE)
C
                  IF(LABPOS.GE.JLO .AND. LABPOS.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      CVAL = CI(JCIB,ISTAT)
                      WVAL = WSTATE(ISTAT)
                      IF(ABS(CVAL).GT.TOL) THEN
                        IWI1 = (ISTAT-1)*NDETLN + LABPOS - JLO + 1
                        DVAL = CVAL*WVAL*FC
                        CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI1),1)
                      ENDIF
                    ENDDO
                    CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                          FC,LABPOS,JCIB,IXI,IXJ,IXK,IXL,JINDAE,
     *                          JB1IN(JBINDX),NACT,NNACT,NSTATS,NXYZ,
     *                          NCI,NDETLN,JLO,L1,NCOR,SALAG,ITER,KILL)
                  ENDIF
C
                  IF(JCIB.GE.JLO .AND. JCIB.LE.JHI) THEN
                    DO ISTAT=1,NSTATS
                      CVAL = CI(LABPOS,ISTAT)
                      WVAL = WSTATE(ISTAT)
                      IF(ABS(CVAL).GT.TOL) THEN
                        IWIB = (ISTAT-1)*NDETLN + JCIB - JLO + 1
                        DVAL = CVAL*WVAL*FC
                        CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWIB),1)
                      ENDIF
                    ENDDO
                    CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                          FC,JCIB,LABPOS,IXI,IXJ,IXK,IXL,JINDAE,
     *                          JB1IN(JBINDX),NACT,NNACT,NSTATS,NXYZ,
     *                          NCI,NDETLN,JLO,L1,NCOR,SALAG,ITER,KILL)
                  ENDIF
C
 2611          CONTINUE
C
 2761          CONTINUE
C
      ENDIF
C
 2801       CONTINUE
 2901   CONTINUE
C
C  **** END OF SPECIAL CASE OF ONE SPACE *******
C
 4899       CALL MOVEUP2(LBOX1,NSPACE,NA,MSTA,IACON1)
 4900    CONTINUE
C
         CALL PUSHCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX5,IEND)
 5000 CONTINUE
C
C  --- END OF LOOP OVER ALPHA STRINGS. ---
C **
C  --- LOOP OVER ALL PURE BETA EXCITATIONS.
C
      CALL RESETCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX5)
C
      DO 8000 IGB=1,ITGB
C
         CALL RESETDE(LBOX1,NSPACE,NB,MSTA,IBCON1)
C
C  KKB GIVES THE ACTUAL POSITION OF THE BETA STRING IBCON1 IN
C  THE FULL BETA STRING LIST.
C
         DO 7900 KKB=NBST(IGB)+1,NBST(IGB+1)
            JPZB1 = LSPB(KKB)
            KBSYM = LSYMB(KKB)
            KSYM=KTAB(KBSYM)
C
            DO II=1,NSPACE
               LBOX2(II) = LBOX1(II)
            ENDDO
C
C  LOOP OVER SPACES TO EXCITE ELECTRON FROM.
C
            IEBS = NB+1
            DO 7890 ISPB1=NSPACE,1,-1
               IOC1 = LBOX1(ISPB1)
               IEBE = IEBS - 1
               IEBS = IEBS - IOC1
               IF (IOC1.EQ.0) GOTO 7890
               LBOX2(ISPB1) = LBOX2(ISPB1)-1
C
C  LOOP ELECTRONS IN SPACE ISPB1.
C  IEBS, IEBE ARE THE ELECTRONS IN SPACE ISPB1.
C
               DO 7885 IB1=IEBE,IEBS,-1
                  IO1 = IBCON1(IB1)
                  IGBE = IEBE - LBOX1(ISPB1)
                  IS1 = IOB(IO1)
C
C  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
C
               DO 7880 ISPB2=ISPB1,NSPACE
C
C  IGBS, IGBE ARE ELECTRONS SPECIFYING ISPB2 SPACE ELECTRON LIMITS.
C
                  IGBS = IGBE + 1
                  IGBE = IGBE + LBOX1(ISPB2)
C
                  LBOX2(ISPB2) = LBOX2(ISPB2) + 1
                  IF (LBOX2(ISPB1).LT.IBMI(ISPB1)) GOTO 7870
C
C  MAKE GAP INFORMATION HERE.
C
                  IGBB = MAX(IB1+1,IGBS)
                  IF (LBOX1(ISPB2).EQ.0) THEN
                     ISTA = MSTA(ISPB2)
                     IEND = MSTA(ISPB2+1)-1
                  ELSEIF (ISPB2.EQ.ISPB1) THEN
                     ISTA = IO1+1
                     IEND = IBCON1(IGBB)-1
                     IF (IB1.EQ.IEBE) IEND=MSTA(ISPB1+1)-1
                  ELSE
                     ISTA = MSTA(ISPB2)
                     IEND = IBCON1(IGBB)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 7860 IGAP=IGBB,IGBE+1
C
                     DO 7850 JJ=ISTA,IEND
                        IS2 = IOB(JJ)
                        IP1 = LGMUL(IS1,IS2)
                        IND = INDEX(JJ) + IO1
C
              CALL REDE00(IBCON1,IBCON2,NB,IB1,IGAP-1,JJ,JPERB)
                  IF (LBOX2(ISPB2).GT.IBMA(ISPB2)) GOTO 7800
C
C   IF DEOCCUPIED AND NEWLY OCCUPIED ORBITALS ARE OF DIFFERENT SYMMETRY,
C   SKIP TO DOUBLES.
C
              IF (IS1.NE.IS2) GOTO 7800
C
C  GET GROUP NUMBER
C
           CALL POSITCO(LBOX5,NSPACE,NB,IBMA,IBMI,LBOX4,LBOX2,IGB2)
           NIBS = NBST(IGB2)
C
              CALL IDPOST(IBCON2,NB,LBOX2,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LBNDET(1,IGB2),IACON1,JPOSB)
              KBPOS = JPOSB + NIBS
              JPZB2 = LSPB(KBPOS)
C              KPER1 = ((-1)**JPERB)*2
              KPER1 = (-1)**JPERB
C
C  LOOP OVER ALPHA
C
              DO 7705 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB2,IGA).NE.1) GOTO 7705
                 JCIB1 = LDISB(KBSYM,IGB,IGA) + JPZB1
                 JCIB2 = LDISB(KBSYM,IGB2,IGA) + JPZB2
                 NIAS = NAST(IGA)
C
              DO 7685 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA1 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA1)
                 JCI1 = JCIA + JCIB1
                 JCI2 = JCIA + JCIB2
                 FC = KPER1
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   CALL HSMLT1(AVEC,YAC,BVEC,RHSC,CI,OINT,AMAT,
     *                         FC,JCI1,JCI2,IND,IO1,JJ,JLO,
     *                         NSTATS,NCI,NDETLN,L1,NCOR,
     *                         NNACT,NXYZ,WSTATE,SALAG,ITER)
                 ENDIF
C
                 IF(JCI2.GE.JLO .AND. JCI2.LE.JHI) THEN
                   CALL HSMLT1(AVEC,YAC,BVEC,RHSC,CI,OINT,AMAT,
     *                         FC,JCI2,JCI1,IND,IO1,JJ,JLO,
     *                         NSTATS,NCI,NDETLN,L1,NCOR,
     *                         NNACT,NXYZ,WSTATE,SALAG,ITER)
                 ENDIF
C
 7685         CONTINUE
C
 7705         CONTINUE
C
              DO 7712 IK=1,NB
                 IF (IK.EQ.IB1) GOTO 7712
                 ION = IBCON1(IK)
                 J1 = INDEX(ION+1)
                 JMA = MAX(J1,IND)
                 JMI = MIN(J1,IND)
                 JMA = MAX(ION,JJ)
                 JMI = MIN(ION,JJ)
                 J2 = INDEX(JMA)+JMI
                 JMA = MAX(IO1,ION)
                 JMI = MIN(IO1,ION)
                 J3 = INDEX(JMA)+JMI
                 JMA = MAX(J2,J3)
                 JMI = MIN(J2,J3)
C
                 CALL VCLR(YAOG,1,NXYZ)
                 CALL HSMLTN(YAOG,YAOTMP,IO1,JJ,ION,ION,IND,
     *                       J1,NACT,NNACT,NXYZ,ONE)
                 CALL HSMLTN(YAOG,YAOTMP,IO1,ION,ION,JJ,J3,
     *                       J2,NACT,NNACT,NXYZ,-ONE)
C
C
              DO 7710 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB2,IGA).NE.1) GOTO 7710
                 JCIB1 = LDISB(KBSYM,IGB,IGA) + JPZB1
                 JCIB2 = LDISB(KBSYM,IGB2,IGA) + JPZB2
                 NIAS = NAST(IGA)
C
              DO 7695 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA1 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA1)
                 JCI1 = JCIA + JCIB1
                 JCI2 = JCIA + JCIB2
                 FC = KPER1
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     CVAL = CI(JCI2,ISTAT)
                     WVAL = WSTATE(ISTAT)
                     IF(ABS(CVAL).GT.TOL) THEN
                       IWI1 = (ISTAT-1)*NDETLN + JCI1 - JLO + 1
                       DVAL = CVAL*WVAL*FC
                       CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI1),1)
                     ENDIF
                   ENDDO
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         FC,JCI1,JCI2,IO1,JJ,ION,ION,IND,J1,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         -FC,JCI1,JCI2,IO1,ION,ION,JJ,J3,J2,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                 ENDIF
C
                 IF(JCI2.GE.JLO .AND. JCI2.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     CVAL = CI(JCI1,ISTAT)
                     WVAL = WSTATE(ISTAT)
                     IF(ABS(CVAL).GT.TOL) THEN
                       IWI2 = (ISTAT-1)*NDETLN + JCI2 - JLO + 1
                       DVAL = CVAL*WVAL*FC
                       CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI2),1)
                     ENDIF
                   ENDDO
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         FC,JCI2,JCI1,IO1,JJ,ION,ION,IND,J1,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         -FC,JCI2,JCI1,IO1,ION,ION,JJ,J3,J2,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                 ENDIF
C
 7695         CONTINUE
C
 7710         CONTINUE
C
 7712         CONTINUE
C
C  LOOP OVER ALPHA STRINGS OF THE RIGHT GROUP AND SYMMETRY.
C
              CALL RESETCO(LBOX3,NSPACE,NA,IAMA,IAMI,LBOX4)
C
              DO 7700 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB2,IGA).NE.1) GOTO 7690
                 JCIB1 = LDISB(KBSYM,IGB,IGA) + JPZB1
                 JCIB2 = LDISB(KBSYM,IGB2,IGA) + JPZB2
                 NIAS = NAST(IGA)
C
              CALL RESETDE(LBOX3,NSPACE,NA,MSTA,IACON1)
              ISTA1 = 1
              DO 7680 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA1 = LSAC(KKA)
                 DO IIZ=ISTA1,IENA1-1
                    CALL MOVEUP2(LBOX3,NSPACE,NA,MSTA,IACON1)
                 ENDDO
                 ISTA1 = IENA1
                 JCIA = LSPA(NIAS+IENA1)
                 JCI1 = JCIA + JCIB1
                 JCI2 = JCIA + JCIB2
                 FC = KPER1
C
                 DO 7670 IK=1,NA
                    ION = IACON1(IK)
                    J1 = INDEX(ION+1)
                    JMA = MAX(J1,IND)
                    JMI = MIN(J1,IND)
C
                 CALL VCLR(YAOG,1,NXYZ)
                 CALL HSMLTN(YAOG,YAOTMP,IO1,JJ,ION,ION,IND,
     *                       J1,NACT,NNACT,NXYZ,ONE)
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     CVAL = CI(JCI2,ISTAT)
                     WVAL = WSTATE(ISTAT)
                     IF(ABS(CVAL).GT.TOL) THEN
                       IWI1 = (ISTAT-1)*NDETLN + JCI1 - JLO + 1
                       DVAL = CVAL*WVAL*FC
                       CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI1),1)
                     ENDIF
                   ENDDO
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         FC,JCI1,JCI2,IO1,JJ,ION,ION,IND,J1,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                 ENDIF
C
                 IF(JCI2.GE.JLO .AND. JCI2.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     CVAL = CI(JCI1,ISTAT)
                     WVAL = WSTATE(ISTAT)
                     IF(ABS(CVAL).GT.TOL) THEN
                       IWI2 = (ISTAT-1)*NDETLN + JCI2 - JLO + 1
                       DVAL = CVAL*WVAL*FC
                       CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI2),1)
                     ENDIF
                   ENDDO
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         FC,JCI2,JCI1,IO1,JJ,ION,ION,IND,J1,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                 ENDIF
C
 7670            CONTINUE
C
 7680         CONTINUE
C
 7690         CALL PUSHCO(LBOX3,NSPACE,NA,IAMA,IAMI,LBOX4,IEND)
 7700         CONTINUE
C
C  --- DOUBLE EXCITATIONS START HERE
C
 7800         CONTINUE
C
           IF (IB1.EQ.NB) GOTO 7850
           IF (JJ.EQ.NACT) GOTO 7850
C
            DO II=1,NSPACE
               LBOX3(II) = LBOX2(II)
            ENDDO
            IBES3 = 1
            DO KK=1,ISPB1-1
               IBES3 = IBES3 + LBOX2(KK)
            ENDDO
C
C  LOOP OVER SPACES TO EXCITE ELECTRONS FROM, MUST BE GE THAN
C  SPACE OF FIRST EXCITATION, ISPB1.
C
            DO 6890 ISPB3 = ISPB1,NSPACE
               IF (LBOX1(ISPB3).EQ.0) GOTO 6887
               IF (ISPB3.EQ.ISPB1.AND.IB1.EQ.IEBE) GOTO 6887
               IOC3 = LBOX2(ISPB3)
               IF (IOC3.EQ.0) GOTO 6887
C
               IBEE3 = IBES3 + LBOX2(ISPB3)-1
               LBOX3(ISPB3) = LBOX3(ISPB3)-1
C
C  LOOP OVER ELECTRONS IN ISPB3, WHICH ARE LARGER THAN IB1,
C  MAKING SURE IT ISN'T THE ALREADY EXCITED ELECTRON.
C
               JSTB3 = IBES3
               IF (ISPB3.EQ.ISPB1) THEN
                  JSTB3=IB1
                  IF (IGAP-1.EQ.IB1) JSTB3=JSTB3+1
               ENDIF
C
               DO 6880 IB3=JSTB3,IBEE3
                  IF (IB3.EQ.IGAP-1) GOTO 6880
                  IO3 = IBCON2(IB3)
                  IS3 = IOB(IO3)
C
C  LOOP OVER SPACES TO EXCITE ELECTRON INTO.  MUST BE GE THAN
C  SPACE FIRST ELECTRON WAS EXCITED INTO.
C
                  IGBE3 = 0
                  DO JIK=1,ISPB2-1
                     IGBE3 = IGBE3 + LBOX2(JIK)
                  ENDDO
                  DO 6850 ISPB4=ISPB2,NSPACE
C
C  IGBS3, IGBE3 ARE ELECTRONS SPECIFYING ISPB4 SPACE ELECTRON LIMITS.
C
                  LBOX3(ISPB4) = LBOX3(ISPB4) + 1
                  IGBS3 = IGBE3 + 1
                  IGBE3 = IGBE3 + LBOX2(ISPB4)
                  IF (LBOX3(ISPB3).LT.IBMI(ISPB3)) GOTO 6840
                  IF (LBOX3(ISPB4).GT.IBMA(ISPB4)) GOTO 6840
             IF (ISPB4.EQ.ISPB2.AND.JJ.EQ.MSTA(ISPB2+1)-1) GOTO 6840
C
C  GET GROUP NUMBER
C
               CALL POSITCO(LBOX5,NSPACE,NB,IBMA,IBMI,LBOX4,LBOX3,IGB3)
               NIBS3 = NBST(IGB3)
C
C  MAKE GAP INFORMATION HERE.
C
                  IGBB3 = MAX(IGBS3,IGAP)
C
                  IF (LBOX2(ISPB4).EQ.0) THEN
                     ISTA3 = MSTA(ISPB4)
                     IEND3 = MSTA(ISPB4+1)-1
                  ELSEIF (ISPB4.EQ.ISPB2) THEN
                     ISTA3 = JJ+1
                     IEND3 = IBCON2(IGBB3)-1
C
C  I AM SUSPECT ABOUT THIS NEXT LINE, WE'LL SEE WHAT HAPPENS.......
C
                     IF (IGAP-1.EQ.IGBE3) IEND3=MSTA(ISPB2+1)-1
C
                  ELSE
                     ISTA3 = MSTA(ISPB4)
                     IEND3 = IBCON2(IGBB3)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 6830 IGAP3=IGBB3,IGBE3+1
C
                     DO 6820 JJ3=ISTA3,IEND3
                        IS4 = IOB(JJ3)
                        IP2 = LGMUL(IS3,IS4)
                        IF (IP1.NE.IP2) GOTO 6820
C
              CALL REDE00(IBCON2,IACON1,NB,IB3,IGAP3-1,JJ3,JPERB3)
              CALL IDPOST(IACON1,NB,LBOX3,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LBNDET(1,IGB3),IACON2,JPOSB3)
C              IPER3 = ((-1)**(JPERB3+JPERB))*2
              IPER3 = (-1)**(JPERB3+JPERB)
              KBPOS3 = JPOSB3 + NIBS3
              JPZB3 = LSPB(KBPOS3)
C
                 JMA=MAX(JJ3,IO3)
                 JMI=MIN(JJ3,IO3)
                 I2 = INDEX(JMA) + JMI
                 II1 = INDEX(JJ3) + IO1
                 JMA=MAX(IO3,JJ)
                 JMI=MIN(IO3,JJ)
                 II2 = INDEX(JMA) + JMI
                 JMA=MAX(II1,II2)
                 JMI=MIN(II1,II2)
C
                 CALL VCLR(YAOG,1,NXYZ)
                 CALL HSMLTN(YAOG,YAOTMP,IO1,JJ,IO3,JJ3,IND,I2,NACT,
     *                       NNACT,NXYZ,ONE)
                 CALL HSMLTN(YAOG,YAOTMP,IO1,JJ3,IO3,JJ,II1,II2,NACT,
     *                       NNACT,NXYZ,-ONE)
C
C
C  LOOP OVER ALPHA STRINGS OF RIGHT SYMMETRY AND GROUP.
C
              DO 6700 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB3,IGA).NE.1) GOTO 6700
              JCIB1 = JPZB1 + LDISB(KBSYM,IGB,IGA)
              JCIB3 = JPZB3 + LDISB(KBSYM,IGB3,IGA)
              NIAS = NAST(IGA)
C
              DO 6680 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA3 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA3)
                 JCI1 = JCIA + JCIB1
                 JCI3 = JCIA + JCIB3
                 FC = IPER3
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     CVAL = CI(JCI3,ISTAT)
                     WVAL = WSTATE(ISTAT)
                     IF(ABS(CVAL).GT.TOL) THEN
                       IWI1 = (ISTAT-1)*NDETLN + JCI1 - JLO + 1
                       DVAL = CVAL*WVAL*FC
                       CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI1),1)
                     ENDIF
                   ENDDO
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         FC,JCI1,JCI3,IO1,JJ,IO3,JJ3,IND,I2,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         -FC,JCI1,JCI3,IO1,JJ3,IO3,JJ,II1,II2,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                 ENDIF
C
                 IF(JCI3.GE.JLO .AND. JCI3.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     CVAL = CI(JCI1,ISTAT)
                     WVAL = WSTATE(ISTAT)
                     IF(ABS(CVAL).GT.TOL) THEN
                       IWI3 = (ISTAT-1)*NDETLN + JCI3 - JLO + 1
                       DVAL = CVAL*WVAL*FC
                       CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI3),1)
                     ENDIF
                   ENDDO
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         FC,JCI3,JCI1,IO1,JJ,IO3,JJ3,IND,I2,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         -FC,JCI3,JCI1,IO1,JJ3,IO3,JJ,II1,II2,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                 ENDIF
C
 6680         CONTINUE
C
 6700         CONTINUE
C
 6820                CONTINUE
C
                     ISTA3 = IBCON2(IGAP3)+1
                     IEND3 = IBCON2(IGAP3+1)-1
                     IF (IGAP3.EQ.IGBE3) IEND3=MSTA(ISPB4+1)-1
 6830             CONTINUE
C
 6840             LBOX3(ISPB4) = LBOX3(ISPB4) - 1
 6850             CONTINUE
C
 6880          CONTINUE
C
               LBOX3(ISPB3) = LBOX3(ISPB3)+1
 6887          IBES3 = IBES3 + LBOX3(ISPB3)
 6890       CONTINUE
C
C  --- END OF LOOP OVER DOUBLE BETA EXCITATIONS.
C
 7850                CONTINUE
C
                  ISTA = IBCON1(IGAP)+1
                  IEND = IBCON1(IGAP+1)-1
                  IF (IGAP.EQ.IGBE) IEND=MSTA(ISPB2+1)-1
 7860             CONTINUE
C
 7870             LBOX2(ISPB2) = LBOX2(ISPB2) - 1
 7880          CONTINUE
C
 7885          CONTINUE
C
               LBOX2(ISPB1) = LBOX2(ISPB1)+1
 7890       CONTINUE
C
C REMAINING DIAGONAL CONTRIBUTIONS HERE
C
            DO 69 II=1,NB
               I1 = IBCON1(II)
               IND1 = INDEX(I1+1)
C
              DO 6705 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1) GOTO 6705
              JCIB1 = JPZB1 + LDISB(KBSYM,IGB,IGA)
              NIAS = NAST(IGA)
C
              DO 6685 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA3 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA3)
                 JCI1 = JCIA + JCIB1
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   CALL HSMLT1(AVEC,YAC,BVEC,RHSC,CI,OINT,AMAT,
     *                         ONE,JCI1,JCI1,IND1,I1,I1,JLO,
     *                         NSTATS,NCI,NDETLN,L1,NCOR,
     *                         NNACT,NXYZ,WSTATE,SALAG,ITER)
                 ENDIF
C
 6685         CONTINUE
C
 6705         CONTINUE
C
              DO 74 JJ=II+1,NB
                 I2 = IBCON1(JJ)
                 IND2 = INDEX(I2+1)
                 INDM = IND2 - I2 + I1
                 J1 = INDEX(INDM+1)
                 JMI = MIN(IND1,IND2)
                 JMA = MAX(IND1,IND2)
                 J2 = INDEX(JMA) + JMI
C
                 CALL VCLR(YAOG,1,NXYZ)
                 CALL HSMLTN(YAOG,YAOTMP,I1,I1,I2,I2,IND1,IND2,NACT,
     *                       NNACT,NXYZ,ONE)
                 CALL HSMLTN(YAOG,YAOTMP,I1,I2,I2,I1,INDM,INDM,NACT,
     *                       NNACT,NXYZ,-ONE)
C
C
              DO 6710 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1) GOTO 6710
              JCIB1 = JPZB1 + LDISB(KBSYM,IGB,IGA)
              NIAS = NAST(IGA)
C
              DO 6690 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA3 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA3)
                 JCI1 = JCIA + JCIB1
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   DO ISTAT=1,NSTATS
                     CVAL = CI(JCI1,ISTAT)
                     WVAL = WSTATE(ISTAT)
                     IF(ABS(CVAL).GT.TOL) THEN
                       IWI1 = (ISTAT-1)*NDETLN + JCI1 - JLO + 1
                       DVAL = CVAL*WVAL
                       CALL DAXPY(NXYZ,DVAL,YAOG,1,RHSC(1,IWI1),1)
                     ENDIF
                   ENDDO
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         ONE,JCI1,JCI1,I1,I1,I2,I2,IND1,IND2,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                   CALL HSMLT2(YADEN,YAC,RHSC,WSTATE,CI,ERI,WRK,
     *                         -ONE,JCI1,JCI1,I1,I2,I2,I1,INDM,INDM,
     *                         NACT,NNACT,NSTATS,NXYZ,NCI,NDETLN,
     *                         JLO,L1,NCOR,SALAG,ITER,RUN)
                 ENDIF
C
 6690         CONTINUE
C
 6710         CONTINUE
C
   74         CONTINUE
C
   69         CONTINUE
C
            CALL MOVEUP2(LBOX1,NSPACE,NB,MSTA,IBCON1)
 7900    CONTINUE
C
         CALL PUSHCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX5,IEND)
 8000 CONTINUE
C
C  --- END OF LOOP OVER BETA STRINGS. ---
C
      CALL FMRHSO(RHSO,YADEN,BVEC,ERI,AMAT,OINT,WRK,IROT,INDEX2,NACT,
     *            NNACT,NCOR,NXYZ,L1,NROT,NINDX)
C
      RETURN
      END
C*MODULE CPMCHF  *DECK FCPSUP
C     ------------------------------------------------------------------
      SUBROUTINE FCPSUP(IW,NA,NB,NACT,IACON1,IBCON1,IBCON2,
     *           INDEX,NBST,LSPB,
     *           LBOX1,LBOX2,LBOX3,LBOX4,
     *           X,NX,LBNDET,LSYMB,NSYM,ITGB,IBST,
     *           NB1EX,JB1GR,JB1PE,JB1IN,JB1PO,JB1ST,JB1SY,JB1IN2)
C     ------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL FDIRCT,QCORR
C
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIM(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
C
      DIMENSION IACON1(NA),IBCON1(NB),IBCON2(NB)
      DIMENSION INDEX((NACT*(NACT+1))/2+1)
      DIMENSION LBOX1(NSPACE),LBOX2(NSPACE),LBOX3(NSPACE)
      DIMENSION LBOX4(NSPACE)
      DIMENSION NBST(ITGB+1),LSPB(IBST)
      DIMENSION X(NX)
      DIMENSION LBNDET(NSPACE,ITGB),LSYMB(IBST)
      DIMENSION JB1GR(NB1EX),JB1PE(NB1EX),JB1IN(NB1EX),JB1PO(NB1EX)
      DIMENSION JB1ST(NSYM+1,IBST+1),JB1SY(NB*(NACT-NB))
      DIMENSION JB1IN2(NB1EX,2)
C
C  MAKE AND STORE ALL B -> B' DATA, WHERE B' > B.
C
      NB1CH = 0
      INB = 0
C
C  LOOP THROUGH ALL BETA GROUPS
C
      CALL RESETCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX3)
C
      DO 1000 IIB = 1,ITGB
C
         CALL RESETDE(LBOX1,NSPACE,NB,MSTA,IBCON1)
C
         DO 900 KKB=NBST(IIB)+1,NBST(IIB+1)
            INB = INB + 1
            DO II=1,NSPACE
               LBOX2(II) = LBOX1(II)
            ENDDO
            JB1ST(1,INB) = NB1CH+1
            KBST = NB1CH+1
C
C  LOOP OVER ALL SINGLE EXCITATIONS, CHECKING TO SEE IF IT IS VALID.
C
C  LOOP OVER SPACES TO EXCITE ELECTRON FROM.
C
            IEBS = NB+1
            DO 890 ISPB1=NSPACE,1,-1
               IOC1 = LBOX1(ISPB1)
               IEBE = IEBS - 1
               IEBS = IEBS - IOC1
               IF (IOC1.EQ.0) GO TO 890
               LBOX2(ISPB1) = LBOX2(ISPB1)-1
C
C  LOOP ELECTRONS IN SPACE ISPB1
C  IEBS, IEBE ARE THE ELECTRONS IN SPACE ISPB1
C
               DO 885 IB1 = IEBE,IEBS,-1
                  IO1 = IBCON1(IB1)
                  IGBE = IEBE - LBOX1(ISPB1)
C
C  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
C
               DO 880 ISPB2=ISPB1,NSPACE
C
C  IGBS,IGBE ARE ELECTRONS SPECIFYING ISPB2 SPACE ELECTRON LIMITS.
C
                  IGBS = IGBE + 1
                  IGBE = IGBE + LBOX1(ISPB2)
C
                  LBOX2(ISPB2) = LBOX2(ISPB2) + 1
                  IF (LBOX2(ISPB1).LT.IBMI(ISPB1)) GO TO 870
                  IF (LBOX2(ISPB2).GT.IBMA(ISPB2)) GO TO 870
C
C  GET GROUP NUMBER
C
          CALL POSITCO(LBOX4,NSPACE,NB,IBMA,IBMI,LBOX3,LBOX2,IGB)
          NIAS = NBST(IGB)
C
C  MAKE GAP INFORMATION HERE.
C
                  IGBA = MAX(IB1+1,IGBS)
                  IF (LBOX1(ISPB2).EQ.0) THEN
                     ISTA = MSTA(ISPB2)
                     IEND = MSTA(ISPB2+1)-1
                  ELSEIF (ISPB2.EQ.ISPB1) THEN
                     ISTA = IO1+1
                     IEND = IBCON1(IGBA)-1
                     IF (IB1.EQ.IEBE) IEND=MSTA(ISPB1+1)-1
                  ELSE
                     ISTA = MSTA(ISPB2)
                     IEND = IBCON1(IGBA)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 860 IGAP=IGBA,IGBE+1
C
                     DO 850 JJ=ISTA,IEND
C
                        NB1CH = NB1CH + 1
                        JB1GR(NB1CH) = IGB
                        JB1IN(NB1CH) = INDEX(JJ)+IO1
                        JB1IN2(NB1CH,1) = IO1
                        JB1IN2(NB1CH,2) = JJ
C
            CALL REDE00(IBCON1,IBCON2,NB,IB1,IGAP-1,JJ,IPER)
            CALL IDPOST(IBCON2,NB,LBOX2,NSPACE,MSTA,IDIM,X,NX,LBST,
     *                  LBNDET(1,IGB),IACON1,IPOSB)
C
                        JB1PE(NB1CH) = (-1)**IPER
                        JB1PO(NB1CH) = LSPB(IPOSB+NIAS)
                        JB1SY(NB1CH-KBST+1) = LSYMB(IPOSB+NIAS)
C
  850                CONTINUE
C
                  ISTA = IBCON1(IGAP)+1
                  IEND = IBCON1(IGAP+1)-1
                  IF (IGAP.EQ.IGBE) IEND=MSTA(ISPB2+1)-1
  860             CONTINUE
C
  870             LBOX2(ISPB2) = LBOX2(ISPB2) - 1
  880          CONTINUE
C
  885          CONTINUE
C
               LBOX2(ISPB1) = LBOX2(ISPB1) + 1
  890       CONTINUE
C
C  ORDER THESE EXCITATIONS FOR BETA INB ACCORDING TO SYMMETRY.
C
            KNUM = NB1CH - KBST + 1
            CALL FCPSRT2(JB1GR(KBST),JB1PE(KBST),JB1IN(KBST),
     *                   JB1PO(KBST),JB1SY,KNUM,JB1IN2(KBST,1),
     *                   JB1IN2(KBST,2))
C
C  MAKE THE SYMMETRY STARTING POINTS
C ----
            IST=1
            DO 100 II=1,NSYM
               DO 200 JJ=IST,KNUM
                  IF (JB1SY(JJ).NE.II) GO TO 180
  200          CONTINUE
  180          JB1ST(II+1,INB) = JJ+KBST-1
               IST = JJ
  100       CONTINUE
C ----
C
C  REORDER WITHIN EACH SYMMETRY BY POSITION.
C
            IJST=JB1ST(1,INB)
            DO 300 II=1,NSYM
               JSTA=JB1ST(II,INB)
               JEND=JB1ST(II+1,INB)
               JNUM=JEND-JSTA
               IF (JNUM.LE.1) GO TO 300
               CALL FCPSRT2(JB1GR(JSTA),JB1PE(JSTA),JB1IN(JSTA),
     *                      JB1SY(JSTA-IJST+1),JB1PO(JSTA),JNUM,
     *                      JB1IN2(JSTA,1),JB1IN2(JSTA,2))
  300       CONTINUE
C
            CALL MOVEUP2(LBOX1,NSPACE,NB,MSTA,IBCON1)
  900    CONTINUE
C
         CALL PUSHCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX3,IEND)
C
 1000 CONTINUE
C
      IF (NB1CH.NE.NB1EX) THEN
         WRITE(IW,9000)
         CALL ABRT
         STOP
      ENDIF
      JB1ST(1,IBST+1) = NB1CH+1
C
      RETURN
C
 9000 FORMAT(/1X,'ERROR IN CALCULATION OF SINGLE BETA EXCITES !!! ')
C
      END
C*MODULE CPMCHF  *DECK ORMDD1
C     ------------------------------------------------------------------
      SUBROUTINE ORMDD1(DDEN,DCI,NDETLN,
     *           NXYZ,JLO,JHI,M2,NACT,NA,NB,X,NX,CI,
     *           INDEX,NSYM,IOB,
     *           LBOX1,LBOX2,LBOX4,LBOX5,
     *           KTAB,IACON1,IACON2,IBCON1,IBCON2,
     *           LANDET,LBNDET,NAST,NBST,LSYMA,LSYMB,LGCOM,
     *           LSPA,LSPB,LDISB,LSAS,LSBS,LSAC,
     *           ITGA,ITGB,IAST,IBST)
C     ------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL FDIRCT,QCORR
C
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIM(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
C
      DIMENSION DDEN(NXYZ,M2),DCI(NXYZ,NDETLN),X(NX),CI(*)
      DIMENSION INDEX((NACT*(NACT+1))/2+1),IOB(NACT)
      DIMENSION LBOX1(NSPACE),LBOX2(NSPACE)
      DIMENSION LBOX4(NSPACE),LBOX5(NSPACE)
      DIMENSION KTAB(NSYM)
      DIMENSION IACON1(NA),IACON2(NA),IBCON1(NA),IBCON2(NA)
      DIMENSION LANDET(NSPACE,ITGA),LBNDET(NSPACE,ITGB)
      DIMENSION NAST(ITGA+1),NBST(ITGB+1)
      DIMENSION LSYMA(IAST),LSYMB(IBST),LGCOM(ITGB,ITGA)
      DIMENSION LSPA(IAST),LSPB(IBST),LDISB(NSYM,ITGB,ITGA)
      DIMENSION LSAS(NSYM+1,ITGA),LSBS(NSYM+1,ITGB)
      DIMENSION LSAC(IAST)
C
      PARAMETER (TWO=2.0D+00)
C
      CALL VCLR(DDEN,1,M2*NXYZ)
C
C ---  BIG LOOP OVER ALL ALPHA DETERMINANTS ---
C
      CALL RESETCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX5)
C
      DO 5000 IGA=1,ITGA
C
         CALL RESETDE(LBOX1,NSPACE,NA,MSTA,IACON1)
C
C  KKA GIVES THE ACTUAL POSITION OF THE ALPHA STRING IACON1 IN
C  THE FULL ALPHA STRING LIST.
C
         DO 4900 KKA=NAST(IGA)+1,NAST(IGA+1)
            JPZA1 = LSPA(KKA)
            JASYM = LSYMA(KKA)
            KSYM=KTAB(JASYM)
C
            DO II=1,NSPACE
               LBOX2(II) = LBOX1(II)
            ENDDO
C
C  LOOP OVER SPACES TO EXCITE ELECTRON FROM.
C
            IEAS = NA+1
            DO 4890 ISPA1=NSPACE,1,-1
               IOC1 = LBOX1(ISPA1)
               IEAE = IEAS - 1
               IEAS = IEAS - IOC1
               IF (IOC1.EQ.0) GO TO 4890
               LBOX2(ISPA1) = LBOX2(ISPA1)-1
C
C  LOOP ELECTRONS IN SPACE ISPA1.
C  IEAS, IEAE ARE THE ELECTRONS IN SPACE ISPA1.
C
               DO 4885 IA1=IEAE,IEAS,-1
                  IO1 = IACON1(IA1)
                  IGAE = IEAE - LBOX1(ISPA1)
                  IS1 = IOB(IO1)
C
C  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
C
               DO 4880 ISPA2=ISPA1,NSPACE
C
C  IGAS, IGAE ARE ELECTRONS SPECIFYING ISPA2 SPACE ELECTRON LIMITS.
C
                  IGAS = IGAE + 1
                  IGAE = IGAE + LBOX1(ISPA2)
C
                  LBOX2(ISPA2) = LBOX2(ISPA2) + 1
                  IF (LBOX2(ISPA1).LT.IAMI(ISPA1)) GO TO 4870
                  IF (LBOX2(ISPA2).GT.IAMA(ISPA2)) GO TO 4870
C
C  GET GROUP NUMBER
C
           CALL POSITCO(LBOX5,NSPACE,NA,IAMA,IAMI,LBOX4,LBOX2,IGA2)
           NIAS = NAST(IGA2)
C
C  MAKE GAP INFORMATION HERE.
C
                  IGAA = MAX(IA1+1,IGAS)
                  IF (LBOX1(ISPA2).EQ.0) THEN
                     ISTA = MSTA(ISPA2)
                     IEND = MSTA(ISPA2+1)-1
                  ELSEIF (ISPA2.EQ.ISPA1) THEN
                     ISTA = IO1+1
                     IEND = IACON1(IGAA)-1
                     IF (IA1.EQ.IEAE) IEND=MSTA(ISPA1+1)-1
                  ELSE
                     ISTA = MSTA(ISPA2)
                     IEND = IACON1(IGAA)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 4860 IGAP=IGAA,IGAE+1
C
                     DO 4850 JJ=ISTA,IEND
                        IS2 = IOB(JJ)
C
C   IF DEOCCUPIED AND NEWLY OCCUPIED ORBITALS ARE OF DIFFERENT SYMMETRY,
C   SKIP.
C
              IF (IS1.NE.IS2) GO TO 4850
C
              IND = INDEX(JJ) + IO1
C
              CALL REDE00(IACON1,IACON2,NA,IA1,IGAP-1,JJ,JPERA)
              CALL IDPOST(IACON2,NA,LBOX2,NSPACE,MSTA,IDIM,X,NX,LBST,
     *                  LANDET(1,IGA2),IBCON1,JPOSA)
              KAPOS = JPOSA + NIAS
              JPZA2 = LSPA(KAPOS)
              KPER1 = (-1)**JPERA
C
C  LOOP OVER BETA STRINGS OF RIGHT SYMMETRY AND GROUP
C
              DO 4700 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB,IGA2).NE.1) GOTO 4700
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
              JCI2 = JPZA2 + LDISB(KSYM,IGB,IGA2)
C
              DO 4680 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 JCI1 = JCI1 + 1
                 JCI2 = JCI2 + 1
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   FC = CI(JCI2)*KPER1
                   IWI1 = JCI1 - JLO + 1
                   CALL DAXPY(NXYZ,FC,DCI(1,IWI1),1,DDEN(1,IND),1)
                 ENDIF
C
                 IF(JCI2.GE.JLO .AND. JCI2.LE.JHI) THEN
                   FC = CI(JCI1)*KPER1
                   IWI2 = JCI2 - JLO + 1
                   CALL DAXPY(NXYZ,FC,DCI(1,IWI2),1,DDEN(1,IND),1)
                 ENDIF
C
 4680         CONTINUE
C
 4700         CONTINUE
C
 4850          CONTINUE
C
                  ISTA = IACON1(IGAP)+1
                  IEND = IACON1(IGAP+1)-1
                  IF (IGAP.EQ.IGAE) IEND=MSTA(ISPA2+1)-1
 4860             CONTINUE
C
 4870             LBOX2(ISPA2) = LBOX2(ISPA2) - 1
 4880          CONTINUE
C
 4885          CONTINUE
C
               LBOX2(ISPA1) = LBOX2(ISPA1)+1
 4890       CONTINUE
C
C   DIAGONAL CONTRIBUTIONS HERE.
C
            DO 67 II=1,NA
               I1 = IACON1(II)
               IND1 = INDEX(I1+1)
C
               DO 53 IGB=1,ITGB
                  IF (LGCOM(IGB,IGA).NE.1) GO TO 53
                  JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
                  DO 58 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                     JCI1 = JCI1 + 1
C
                     IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                       FC = TWO*CI(JCI1)
                       IWI1 = JCI1 - JLO + 1
                       CALL DAXPY(NXYZ,FC,DCI(1,IWI1),1,DDEN(1,IND1),1)
                     ENDIF
C
   58             CONTINUE
   53          CONTINUE
C
   67       CONTINUE
C
            CALL MOVEUP2(LBOX1,NSPACE,NA,MSTA,IACON1)
 4900    CONTINUE
C
         CALL PUSHCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX5,IEND)
 5000 CONTINUE
C
C  --- END OF LOOP OVER ALPHA STRINGS ----
C
C  --- BIG LOOP OVER BETA -----
C
      CALL RESETCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX5)
C
      DO 8000 IGB=1,ITGB
C
         CALL RESETDE(LBOX1,NSPACE,NB,MSTA,IBCON1)
C
C  KKB GIVES THE ACTUAL POSITION OF THE BETA STRING IBCON1 IN
C  THE FULL BETA STRING LIST.
C
         DO 7900 KKB=NBST(IGB)+1,NBST(IGB+1)
            JPZB1 = LSPB(KKB)
            KBSYM = LSYMB(KKB)
            KSYM=KTAB(KBSYM)
C
            DO II=1,NSPACE
               LBOX2(II) = LBOX1(II)
            ENDDO
C
C  LOOP OVER SPACES TO EXCITE ELECTRON FROM.
C
            IEBS = NB+1
            DO 7890 ISPB1=NSPACE,1,-1
               IOC1 = LBOX1(ISPB1)
               IEBE = IEBS - 1
               IEBS = IEBS - IOC1
               IF (IOC1.EQ.0) GO TO 7890
               LBOX2(ISPB1) = LBOX2(ISPB1)-1
C
C  LOOP ELECTRONS IN SPACE ISPB1.
C  IEBS, IEBE ARE THE ELECTRONS IN SPACE ISPB1.
C
               DO 7885 IB1=IEBE,IEBS,-1
                  IO1 = IBCON1(IB1)
                  IGBE = IEBE - LBOX1(ISPB1)
                  IS1 = IOB(IO1)
C
C  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
C
               DO 7880 ISPB2=ISPB1,NSPACE
C
C  IGBS, IGBE ARE ELECTRONS SPECIFYING ISPB2 SPACE ELECTRON LIMITS.
C
                  IGBS = IGBE + 1
                  IGBE = IGBE + LBOX1(ISPB2)
C
                  LBOX2(ISPB2) = LBOX2(ISPB2) + 1
                  IF (LBOX2(ISPB1).LT.IBMI(ISPB1)) GO TO 7870
                  IF (LBOX2(ISPB2).GT.IBMA(ISPB2)) GO TO 7870
C
C  GET GROUP NUMBER
C
           CALL POSITCO(LBOX5,NSPACE,NB,IBMA,IBMI,LBOX4,LBOX2,IGB2)
           NIBS = NBST(IGB2)
C
C  MAKE GAP INFORMATION HERE.
C
                  IGBB = MAX(IB1+1,IGBS)
                  IF (LBOX1(ISPB2).EQ.0) THEN
                     ISTA = MSTA(ISPB2)
                     IEND = MSTA(ISPB2+1)-1
                  ELSEIF (ISPB2.EQ.ISPB1) THEN
                     ISTA = IO1+1
                     IEND = IBCON1(IGBB)-1
                     IF (IB1.EQ.IEBE) IEND=MSTA(ISPB1+1)-1
                  ELSE
                     ISTA = MSTA(ISPB2)
                     IEND = IBCON1(IGBB)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 7860 IGAP=IGBB,IGBE+1
C
                     DO 7850 JJ=ISTA,IEND
                        IS2 = IOB(JJ)
                        IND = INDEX(JJ) + IO1
C
C   IF DEOCCUPIED AND NEWLY OCCUPIED ORBITALS ARE OF DIFFERENT SYMMETRY,
C   SKIP TO DOUBLES.
C
                        IF (IS1.NE.IS2) GO TO 7850
C
              CALL REDE00(IBCON1,IBCON2,NB,IB1,IGAP-1,JJ,JPERB)
C
              CALL IDPOST(IBCON2,NB,LBOX2,NSPACE,MSTA,IDIM,X,NX,LBST,
     *                  LBNDET(1,IGB2),IACON1,JPOSB)
              KBPOS = JPOSB + NIBS
              JPZB2 = LSPB(KBPOS)
              KPER1 = (-1)**JPERB
C
C  LOOP OVER ALPHA STRINGS OF THE RIGHT GROUP AND SYMMETRY.
C
              DO 7700 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB2,IGA).NE.1) GOTO 7700
                 JCIB1 = LDISB(KBSYM,IGB,IGA) + JPZB1
                 JCIB2 = LDISB(KBSYM,IGB2,IGA) + JPZB2
                 NIAS = NAST(IGA)
C
              DO 7680 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA1 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA1)
                 JCI1 = JCIA + JCIB1
                 JCI2 = JCIA + JCIB2
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   FC = KPER1*CI(JCI2)
                   IWI1 = JCI1 - JLO + 1
                   CALL DAXPY(NXYZ,FC,DCI(1,IWI1),1,DDEN(1,IND),1)
                 ENDIF
C
                 IF(JCI2.GE.JLO .AND. JCI2.LE.JHI) THEN
                   FC = KPER1*CI(JCI1)
                   IWI2 = JCI2 - JLO + 1
                   CALL DAXPY(NXYZ,FC,DCI(1,IWI2),1,DDEN(1,IND),1)
                 ENDIF
C
 7680         CONTINUE
 7700         CONTINUE
C
 7850                CONTINUE
C
                  ISTA = IBCON1(IGAP)+1
                  IEND = IBCON1(IGAP+1)-1
                  IF (IGAP.EQ.IGBE) IEND=MSTA(ISPB2+1)-1
 7860             CONTINUE
C
 7870             LBOX2(ISPB2) = LBOX2(ISPB2) - 1
 7880          CONTINUE
C
 7885          CONTINUE
C
               LBOX2(ISPB1) = LBOX2(ISPB1)+1
 7890       CONTINUE
C
C  REMAINING PART OF DIAGONAL CONTRIBUTIONS.
C
            DO 69 II=1,NB
               I1 = IBCON1(II)
               IND1 = INDEX(I1+1)
C
              DO 76 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1) GO TO 76
                 JCIB1 = LDISB(KBSYM,IGB,IGA) + JPZB1
                 NIAS = NAST(IGA)
C
              DO 78 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA1 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA1)
                 JCI1 = JCIA + JCIB1
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   FC = TWO*CI(JCI1)
                   IWI1 = JCI1 - JLO + 1
                   CALL DAXPY(NXYZ,FC,DCI(1,IWI1),1,DDEN(1,IND1),1)
                 ENDIF
C
   78         CONTINUE
   76         CONTINUE
C
   69       CONTINUE
C
            CALL MOVEUP2(LBOX1,NSPACE,NB,MSTA,IBCON1)
 7900    CONTINUE
C
         CALL PUSHCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX5,IEND)
 8000 CONTINUE
C
      RETURN
C
      END
C*MODULE CPMCHF  *DECK FCPSRT2
C     ------------------------------------------------------
      SUBROUTINE FCPSRT2(JB1GR,JB1PE,JB1IN,JB1PO,JB1SY,N,JB1INI,JB1INJ)
C     ------------------------------------------------------
      IMPLICIT INTEGER(A-Z)
      DIMENSION JB1GR(N),JB1PE(N),JB1IN(N),JB1PO(N),JB1SY(N)
      DIMENSION JB1INI(N),JB1INJ(N)
C
C    SORTING GARBAGE.
C
      IF (N.LT.2) RETURN
      L=N/2+1
      IR=N
C
   10 CONTINUE
         IF (L.GT.1) THEN
            L=L-1
            IRRA=JB1SY(L)
            IRRB=JB1GR(L)
            IRRC=JB1PE(L)
            IRRD=JB1IN(L)
            IRRE=JB1PO(L)
            IRRI=JB1INI(L)
            IRRJ=JB1INJ(L)
         ELSE
            IRRA=JB1SY(IR)
            IRRB=JB1GR(IR)
            IRRC=JB1PE(IR)
            IRRD=JB1IN(IR)
            IRRE=JB1PO(IR)
            IRRI=JB1INI(IR)
            IRRJ=JB1INJ(IR)
            JB1SY(IR)=JB1SY(1)
            JB1GR(IR)=JB1GR(1)
            JB1PE(IR)=JB1PE(1)
            JB1IN(IR)=JB1IN(1)
            JB1PO(IR)=JB1PO(1)
            JB1INI(IR)=JB1INI(1)
            JB1INJ(IR)=JB1INJ(1)
C
            IR=IR-1
            IF (IR.EQ.1) THEN
               JB1SY(1)=IRRA
               JB1GR(1)=IRRB
               JB1PE(1)=IRRC
               JB1IN(1)=IRRD
               JB1PO(1)=IRRE
               JB1INI(1)=IRRI
               JB1INJ(1)=IRRJ
C
               GO TO 122
            ENDIF
         ENDIF
         I=L
         J=L+L
   20    IF (J.LE.IR) THEN
            IF (J.LT.IR) THEN
                   IF (JB1SY(J).LT.JB1SY(J+1)) J=J+1
            ENDIF
            IF (IRRA.LT.JB1SY(J)) THEN
               JB1SY(I)=JB1SY(J)
               JB1GR(I)=JB1GR(J)
               JB1PE(I)=JB1PE(J)
               JB1IN(I)=JB1IN(J)
               JB1PO(I)=JB1PO(J)
               JB1INI(I) = JB1INI(J)
               JB1INJ(I) = JB1INJ(J)
               I=J
               J=J+J
            ELSE
               J=IR+1
            ENDIF
         GO TO 20
         ENDIF
         JB1SY(I)=IRRA
         JB1GR(I)=IRRB
         JB1PE(I)=IRRC
         JB1IN(I)=IRRD
         JB1PO(I)=IRRE
         JB1INI(I)=IRRI
         JB1INJ(I)=IRRJ
      GO TO 10
C
  122 CONTINUE
C
      RETURN
      END
C*MODULE CPMCHF  *DECK FCPSRT3
C     ------------------------------------------------------
      SUBROUTINE FCPSRT3(JB1GR,JB1PE,JB1IN,JB1SY,N,JB1INI,JB1INJ)
C     ------------------------------------------------------
      IMPLICIT INTEGER(A-Z)
      DIMENSION JB1GR(N),JB1PE(N),JB1IN(N),JB1SY(N),JB1INI(N),JB1INJ(N)
C
C    SORTING GARBAGE.
C
      IF (N.LT.2) RETURN
      L=N/2+1
      IR=N
C
   10 CONTINUE
         IF (L.GT.1) THEN
            L=L-1
            IRRA=JB1SY(L)
            IRRB=JB1GR(L)
            IRRC=JB1PE(L)
            IRRD=JB1IN(L)
            IRRI=JB1INI(L)
            IRRJ=JB1INJ(L)
         ELSE
            IRRA=JB1SY(IR)
            IRRB=JB1GR(IR)
            IRRC=JB1PE(IR)
            IRRD=JB1IN(IR)
            IRRI=JB1INI(IR)
            IRRJ=JB1INJ(IR)
            JB1SY(IR)=JB1SY(1)
            JB1GR(IR)=JB1GR(1)
            JB1PE(IR)=JB1PE(1)
            JB1IN(IR)=JB1IN(1)
            JB1INI(IR)=JB1INI(1)
            JB1INJ(IR)=JB1INJ(1)
C
            IR=IR-1
            IF (IR.EQ.1) THEN
               JB1SY(1)=IRRA
               JB1GR(1)=IRRB
               JB1PE(1)=IRRC
               JB1IN(1)=IRRD
               JB1INI(1)=IRRI
               JB1INJ(1)=IRRJ
C
               GO TO 122
            ENDIF
         ENDIF
         I=L
         J=L+L
   20    IF (J.LE.IR) THEN
            IF (J.LT.IR) THEN
                   IF (JB1SY(J).LT.JB1SY(J+1)) J=J+1
            ENDIF
            IF (IRRA.LT.JB1SY(J)) THEN
               JB1SY(I)=JB1SY(J)
               JB1GR(I)=JB1GR(J)
               JB1PE(I)=JB1PE(J)
               JB1IN(I)=JB1IN(J)
               JB1INI(I)=JB1INI(J)
               JB1INJ(I)=JB1INJ(J)
               I=J
               J=J+J
            ELSE
               J=IR+1
            ENDIF
         GO TO 20
         ENDIF
         JB1SY(I)=IRRA
         JB1GR(I)=IRRB
         JB1PE(I)=IRRC
         JB1IN(I)=IRRD
         JB1INI(I)=IRRI
         JB1INJ(I)=IRRJ
      GO TO 10
C
  122 CONTINUE
C
      RETURN
      END
C*MODULE ZCPRMC  *DECK ZCPMCX
C> @brief      Driver for Z-vector CAS and ORMAS NACME.
C> 
C> @author     Tim Dudley
C>             -November 01, 2011
C> 
C> @details    Driver for Z-vector CAS and ORMAS NACME.
C> 
C> @date April 10, 2013-Aaron West
C> -Bug fix for more mis-allocated memory.
C>  The issues in for LWRK2 buried inside of CSFNAC routine.
C>  LWRK2 actually turns into WRK inside of CSFNAC.
C>  It unforunately is masked and does not resolve the
C>  ORMAS NACME issue at this time.
C>
      SUBROUTINE ZCPMCX
C     NOTE:  THIS Z-VECTOR SUB DOES IS NOT READY FOR HESSIANS ANYWAYS.
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DOUBLE PRECISION NACME,METHOD
C
      LOGICAL SVDSWK,MASWRK,GOPARR,DSKWRK,FDIRCT,QCORR,PACK2E
      LOGICAL GENMC,CANONC,FCORE,FORS,EKT,LINSER,NOCAS
      LOGICAL SOME
      LOGICAL NAPICK
C
      INTEGER         C_OOOO, C_VOOO, C_VVOO, C_VOVO
C
      PARAMETER (MXRT=100, MXNORO=250, MXATM=2000, MXSH=5000)
C
      DIMENSION NOCP(3*MXATM)
      DIMENSION NACST(MXRT*(MXRT-1))
C
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /CIFILS/ NFT11,NFT12,NFT13,NFT14,NFT15,NFT16,IDAF20,NEMEMX
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,S,SZ,
     *                GRPDET,STSYM,GLIST,DWPARM,
     *                NFLGDM(MXRT),IWTS(MXRT),NCORSV,NCOR,NACT,NORB,
     *                NA,NB,K,KST,IROOT,IPURES,MAXW1,NITER,MAXP,NCI,
     *                IGPDET,KSTSYM,NFTGCI,IDWEIGH
      COMMON /DLBTIM/ C_OOOO,C_VOOO,C_VVOO,C_VOVO
      COMMON /ECP2  / CLP(400),ZLP(400),NLP(400),KFIRST(MXATM,6),
     *                KLAST(MXATM,6),LMAX(MXATM),LPSKIP(MXATM),
     *                IZCORE(MXATM)
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,STOT,SSQUAR,ECORE,ESCF,EERD,
     *                E1,E2,VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,
     *                EDFT(2),EDISP
      COMMON /FMCOM / X(1)
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIM(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA2,NB2,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWORD,NORBMC,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                T(432),INVT(48),NT
C
      INTEGER         D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB
      LOGICAL         NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
      COMMON /TRFDMS/ D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB,
     *                NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
C
      DATA ORMAS /8HORMAS   /
      DATA CHECK /8HCHECK   /
      DATA NACME,HESS,CONICL /8HNACME   ,8HHESSIAN ,8HCONICAL /
C
      PARAMETER (ZERO=0.0D+00,HALF=0.5D+00,ONE=1.0D+00)
C
      N1 = NACT
      N2 = (N1*N1+N1)/2
      N3 = N1*N1
      N4 = (N2*N2+N2)/2
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
      M1 = NCORSV+NACT
      NSYM = 2**IGPDET
      NXYZ = 3*NAT
      NFT18 = 18
      NFT19 = 19
      NDER = 1
C
C     ----- Setting up ORMAS parameters since CI -----
C     ----- algorithms in this code are based on -----
C     -----             ORMAS scheme             -----
C
      NOCAS = .FALSE.
      GENMC = .TRUE.
      LBST(1) = 1
      IF(CISTEP.NE.ORMAS) THEN
        NSPACE = 1
        MSTA(1) = NCORSV+1
        MSTA(2) = NACT+NCORSV+1
        MNUM(1) = NACT
        MINI(1) = NA + NB
        MAXI(1) = NA + NB
        FDIRCT=.FALSE.
        QCORR = .FALSE.
        CALL FCCHECK(IW,.FALSE.,NSPACE,MNUM,MINI,MAXI,IAMI,IAMA,IBMI,
     *               IBMA,NA,NB)
      ENDIF
C 
      DO II=2,NSPACE
        IDIM(II-1) = MAX(IAMA(II-1),IBMA(II-1))
        LBST(II) = LBST(II-1) + ((MNUM(II-1)+1)*(IDIM(II-1)+1))
      ENDDO
      IDIM(NSPACE) = MAX(IAMA(NSPACE),IBMA(NSPACE))
      LNEED = LBST(NSPACE)+((MNUM(NSPACE)+1)*(IDIM(NSPACE)+1))
C
C     ----- Get memory required for entire program -----
C
      CALL GOTFM(NGOTMX)
      CALL VALFM(LOADFM)
      LCI = LOADFM + 1
      LTDM1 = LCI + K*NCI
      LBOX1 = LTDM1 + N1*N1*K*K
      LBOX2 = LBOX1 + NSPACE
      LBOX3 = LBOX2 + NSPACE
      LBOX4 = LBOX3 + NSPACE
      LBOX5 = LBOX4 + NSPACE
      LIFA = LBOX5 + NSPACE
      LIBO = LIFA + ((N1+1)**2)/NWDVAR + 1
      LIND = LIBO + L1
      LIA = LIND + L3
      LOINT = LIA + L2
      LBUFF = LOINT + L2
      LETMP = LBUFF + L3
      LWSTMP = LETMP + MXRT
      LX = LWSTMP + MXRT
      LIX = LX + NINTMX
      LAST = LIX + NINTMX
      NEED1 = LAST - LOADFM - 1 + LNEED
      CALL GETFM(NEED1)
C
C     ----- Calculate quantities related to generation -----
C     ----- of coupling constants and grab some memory ----- 
C
      IAST = 0
      IBST = 0 
      DO II=1,NSPACE
        LBST(II) = LBST(II) + LAST
        CALL BINOM8(X(LBST(II)),MNUM(II),IDIM(II))
      ENDDO
      CALL TOTALCO(X(LBOX1),NSPACE,NA,IAMA,IAMI,X(LBOX2),ITGA)
      CALL TOTALCO(X(LBOX1),NSPACE,NB,IBMA,IBMI,X(LBOX2),ITGB)
      CALL RESETCO(X(LBOX1),NSPACE,NA,IAMA,IAMI,X(LBOX2))
      DO II=1,ITGA
        CALL TOTDETG(X(LBOX1),NSPACE,LBST,X(LBST(1)),LNEED,
     *               MNUM,IDIM,ITOT)
        IAST = IAST + ITOT
        CALL PUSHCO(X(LBOX1),NSPACE,NA,IAMA,IAMI,X(LBOX2),IEND)
      ENDDO
      CALL RESETCO(X(LBOX1),NSPACE,NB,IBMA,IBMI,X(LBOX2))
      DO II=1,ITGB
        CALL TOTDETG(X(LBOX1),NSPACE,LBST,X(LBST(1)),LNEED,
     *               MNUM,IDIM,ITOT)
        IBST = IBST + ITOT
        CALL PUSHCO(X(LBOX1),NSPACE,NB,IBMA,IBMI,X(LBOX2),IEND)
      ENDDO
      CALL BINOM6(X(LIFA),N1)
      CALL MATMC2(L1,M1,NCORSV,NA,NB,X(LIFA),NSYM,IIS,NDETMX,
     *           ITGA,ITGB,NSPACE,IAST,IBST,GENMC)
C
      CALL VALFM(LOADFM)
      LIWRK = LOADFM + 1
      LAST = LIWRK + IIS
      NEEDWK = LAST - LOADFM - 1
      CALL GETFM(NEEDWK)
C
      CALL VCLR(X(LIWRK),1,IIS)
      LCON = LIWRK
      LANDET = LCON + NA
      LBNDET = LANDET + NSPACE*ITGA
      LGCOM = LBNDET + NSPACE*ITGB
      LCOB = LGCOM + ITGA*ITGB
      CALL MATMC3(NDETMX,NCORSV,ITGA,ITGB,NA,NB,X(LBOX1),X(LBOX2),
     *            X(LBOX3),X(LCON),X(LANDET),X(LBNDET),X(LGCOM),
     *            X(LCOB),X(LBST(1)),NOCAS)
C
C     ----- Take care of analytic gradient runs -----
C
      IWST = 0
      NSTATS = 0
      DO 105 IST=1,K
        IF(IPURES.EQ.1) THEN
          IF(ABS(SPINS(IST)-S) .GT. 0.03D+00) GO TO 105
          IWST = IWST + 1
        ELSE
          IWST = IWST + 1
        ENDIF
        IF(WSTATE(IWST).NE.ZERO) THEN
          NSTATS = NSTATS + 1
        ENDIF
  105 CONTINUE
      IRTTMP = IROOT
C
C     ----- Get CI vectors from file -----
C
      SVDSWK = DSKWRK
      DSKWRK = .FALSE.
      CALL SEQREW(NFT12)
      IF(MASWRK) READ(NFT12) NSTATS,NDETS
      IF(GOPARR) CALL DDI_BCAST(2160,'I',NSTATS,1,MASTER)
      IF(GOPARR) CALL DDI_BCAST(2161,'I',NDETS,1,MASTER)
      IF(NSTATS.NE.K .OR. NDETS.NE.NCI) THEN
        IF(MASWRK) WRITE(IW,9360) NSTATS,NDETS,K,NCI
        CALL ABRT
      END IF
C
      IWST = 0
      NSTATS = 0
      CALL VCLR(X(LCI),1,K*NCI)
      CALL DCOPY(MXRT,ESTATE,1,X(LETMP),1)
      DO 150 IST=1,K
        IF(IPURES.EQ.1) THEN
          IF(ABS(SPINS(IST)-S) .GT. 0.03D+00) THEN
            CALL SEQADV(NFT12)
            GO TO 150
          ENDIF
          IWST = IWST + 1
        ELSE
          IWST = IWST + 1
        ENDIF
        IF(WSTATE(IWST).NE.ZERO) THEN
          NSTATS = NSTATS + 1
          X(LWSTMP+NSTATS-1) = WSTATE(IWST)
        ENDIF
        IF(WSTATE(IWST).EQ.ZERO) THEN
          CALL SEQADV(NFT12)
          GO TO 150
        ENDIF
        IF(MASWRK) THEN
          IF(RUNTYP.EQ.HESS)   WRITE(IW,9060) ESTATE(IST),SPINS(IST)
          IF(RUNTYP.EQ.NACME)  WRITE(IW,9065) ESTATE(IST),SPINS(IST)
          IF(RUNTYP.EQ.CONICL) WRITE(IW,9065) ESTATE(IST),SPINS(IST)
        ENDIF
        LCITMP = LCI + (NSTATS-1)*NCI
        CALL SQREAD(NFT12,X(LCITMP),NCI)
        ESTATE(NSTATS) = X(LETMP+IST-1)
  150 CONTINUE
      CALL SEQREW(NFT12)
      DSKWRK = SVDSWK
C
      IF(MASWRK) WRITE(IW,9000)
      CALL FLSHBF(IW)
C
C     ----- Determine independent orbital rotations -----
C    
      NROT = 0
      NST2 = (NSTATS*NSTATS+NSTATS)/2
C
      CALL DAREAD(IDAF,IODA,X(LIBO),L1,262,1)
      CALL FMDELT(X(LIND),X(LIBO),MSTA,NCORSV,NACT,L1,NQMT,NSPACE,
     *            NROT,NOCAS,NDER)
C
C     ----- Divide determinant list among all processors -----
C
      NDETLN = NDETMX
      JLO = 1
      JHI = NDETMX
      JROTLO = 1
      JROTHI = NROT
      IF(GOPARR) THEN
        NDETLN = NDETMX/NPROC
        NDTMOD = MOD(NDETMX,NPROC)
        IF(ME.LT.NDTMOD) THEN
          JLO = ME*(NDETLN+1) + 1
          JHI = JLO + NDETLN 
        ELSE
          JLO = NDTMOD*(NDETLN+1) + (ME-NDTMOD)*NDETLN + 1
          JHI = JLO + NDETLN - 1
        ENDIF
        IF(NDTMOD.GT.0) NDETLN = NDETLN + 1
C
        NROTLN = NROT/NPROC
        NDTMOD = MOD(NROT,NPROC)
        IF(ME.LT.NDTMOD) THEN
          JROTLO = ME*(NROTLN+1) + 1
          JROTHI = JROTLO + NROTLN
        ELSE
          JROTLO = NDTMOD*(NROTLN+1) + (ME-NDTMOD)*NROTLN + 1
          JROTHI = JROTLO + NROTLN - 1
        ENDIF
        IF(NDTMOD.GT.0) NROTLN = NROTLN + 1
      ENDIF
C
C     ----- Determine unique xyz for which CPMCSCF is needed -----
C
      NUNIQ = 0
      DO IXYZ=1,3*MXATM
        NOCP(IXYZ) = 1
      ENDDO
      IF(NDER.EQ.2) THEN
        DO 100 IAT=1,NAT
          NUCZ = INT(ZAN(IAT)+0.01D+00) + IZCORE(IAT)
          IF(NUCZ.EQ.0) GO TO 100
          DO IT=1,NT
            IF(MAPCTR(IAT,IT).GT.IAT) GO TO 100
          ENDDO
          IXYZ=3*(IAT-1)
          NOCP(IXYZ+1) = 0
          NOCP(IXYZ+2) = 0
          NOCP(IXYZ+3) = 0
          NUNIQ = NUNIQ + 3
  100   CONTINUE
        NDIM = NXYZ
      ENDIF
C
      IF(NDER.EQ.1) THEN
        DO 110 ISTAT=1,NSTATS
          DO 110 JSTAT=1,NSTATS
            NUNIQ = NUNIQ + 1 
            IJST = (ISTAT-1)*NSTATS + JSTAT
            NOCP(IJST) = 0
  110   CONTINUE
        NDIM = NSTATS*NSTATS
      ENDIF
C
C     ----- Get memory for constructing NACME -----
C 
      CALL VALFM(LOADFM)
      LRHSO = LOADFM + 1
      LSALAG = LRHSO + NSTATS*NSTATS*NROT
      LTDM2 = LSALAG + L3*NSTATS*NSTATS
      LSAGRD = LTDM2 + N2*N2*NSTATS*NSTATS
      LSDER = LSAGRD + NXYZ*NSTATS*NSTATS
      LV = LSDER + NXYZ*L3
      LDSAO = LV + L3
      LWRK = LDSAO + L3 
      LWRK2 = LWRK + MAX(L3,N4) 
CAW      LDFC = LWRK2 + MAX(L3,NXYZ) 
      LDFC = LWRK2 + MAX(L3*nstats*nstats,NXYZ)
      LDERI = LDFC + NXYZ*L2
CAW      LDHC = LDERI + NXYZ*N3*N2
      LDHC = LDERI + MAX(NUNIQ,NXYZ)*N3*N2
      LDLAG = LDHC + NXYZ
      LNG = LDLAG + NXYZ*L3 
      LAST = LNG + NXYZ
      NEED2 = LAST - LOADFM - 1
      CALL GETFM(NEED2)
CAWCHECK      MEMREP = NEED1 + NEED2 + NEEDT
      SOME = NPRINT.NE.-5 .AND. MASWRK
      MEMREP = NEED1 + NEED2 + NEEDWK
      IF(EXETYP.EQ.CHECK) THEN
        CALL CPCHK1(MEMREP,IW,NSTATS,NXYZ,NDETMX)
      ELSE
        IF(SOME) WRITE(IW,9010) MEMREP,NGOTMX
      ENDIF
CAWCHECK
C
C     ----- Construct and utilize transition one-particle -----
C     -----            density matrix elements            -----
C
      CALL DAREAD(IDAF,IODA,X(LV),L3,15,0)
      CALL DAREAD(IDAF,IODA,X(LIBO),L1,262,1)
      CALL CORTRA(X(LIBO),M1,NCORSV)
      CALL VCLR(X(LRHSO),1,NSTATS*NSTATS*NROT)
C
      L0 = NQMT
      L0TRI = (L0*L0+L0)/2
      IF(GOPARR) THEN
        CALL DAREAD(IDAF,IODA,X(LOINT),L0TRI,355,0)
      ELSE
        DSKWRK = .TRUE.
        CALL SEQREW(IJKT)
        CALL SQREAD(IJKT,X(LOINT),L0TRI)
      ENDIF
C
      NS2 = NSTATS*NSTATS
      CALL MKSDER(X(LSDER),X(LV),X(LDSAO),X(LWRK),X(LWRK2),X(LIA),
     *            L0,L1,L3,NXYZ)
C
      CALL VCLR(X(LSAGRD),1,NXYZ*NS2)
C
C        ORMAS prefers to operate with cores removed from subspaces,
C        this remains in effect throughout the following, until exit.
C
      DO II=1,NSPACE+1
        MSTA(II) = MSTA(II) - NCORSV
      ENDDO
C
      CALL TROPDM(X(LBUFF),X(LTDM1),X(LTDM2),X(LCI),X(LRHSO),X(LOINT),
     *            X(LSALAG),X(LSAGRD),X(LSDER),X(LV),
     *            X(LWRK2),X(LIND),X(LIWRK),X(LIBO),
     *            X(LBOX1),X(LBOX2),X(LBOX3),X(LBOX4),X(LBOX5),X(LIA),
     *            N1,NSTATS,NDETMX,ITGA,ITGB,IAST,IBST,N2,L1,IIS,
     *            NB1EX,LNEED,NROT,L2,NQMT,JLO,JHI,NXYZ)
C
C     ----- Construct NACME terms involving derivative -----
C     -----                 integrals                  -----
C
CAWCHECK
      IF (EXETYP.EQ.CHECK) THEN
         CALL VCLR(X(LDHC),1,NXYZ)
         CALL DAWRIT(IDAF,IODA,X(LDHC),NXYZ,259,0)
         CALL DAWRIT(IDAF,IODA,X(LDHC),NXYZ,258,0)
      ENDIF
CAWCHECK
      CALL DAREAD(IDAF,IODA,X(LDHC),NXYZ,259,0)
      CALL DAREAD(IDAF,IODA,X(LNG),NXYZ,258,0)
      CALL FMNACI(X(LSAGRD),X(LSDER),X(LSALAG),X(LDFC),X(LDERI),
     *            X(LDHC),X(LDLAG),X(LNG),X(LTDM1),X(LTDM2),X(LWRK),
     *            X(LIA),NXYZ,NSTATS,NS2,L0,L1,L2,L3,NCORSV,N1,N2,N4,
     *            NFT18)
      CALL DSCAL(L3*NSTATS*NSTATS,HALF,X(LSALAG),1)
C
C     ----- Get memory for solving CPMCHF equations -----
C
      ITMP = MAX(L3,NSTATS*NDETLN)
      ITMP2 = MAX(NXYZ,NUNIQ)
C
      CALL VALFM(LOADFM)
      LYAO = LOADFM + 1
      LYAC = LYAO + ITMP2*NROT
      LYAS = LYAC + ITMP2*NSTATS*NDETLN
      LPRCDO = LYAS + ITMP2*NST2
      LPRCDC = LPRCDO + NROT
      LPRCDS = LPRCDC + NSTATS*NDETLN
      LRSIDO = LPRCDS + NST2 
      LRSIDC = LRSIDO + NUNIQ*NROT
      LRSIDS = LRSIDC + NUNIQ*NDETLN*NSTATS
      LZRSO = LRSIDS + NUNIQ*NST2
      LZRSC = LZRSO + NUNIQ*NROT
      LZRSS = LZRSC + NUNIQ*NDETLN*NSTATS
      LPDIRO = LZRSS + NUNIQ*NST2
      LPDIRC = LPDIRO + NUNIQ*NROT
      LPDIRS = LPDIRC + NUNIQ*NDETMX*NSTATS
      LBNORMO = LPDIRS + NUNIQ*NST2
      LBNORMC = LBNORMO + NUNIQ
      LBNORMS = LBNORMC + NUNIQ
      LBKNUM = LBNORMS + NUNIQ
      LBKDEN = LBKNUM + NUNIQ
      LFCOR = LBKDEN + NUNIQ
      LAMAT = LFCOR + L2
      LERI = LAMAT + L1*NCORSV*N2 
      LEPS = LERI + L1*N1*N2
      LTMPWK = LEPS + L3
CAW      LEGRAD = LTMPWK + MAX(ITMP,2*NXYZ) 
      LEGRAD = LTMPWK + MAX(ITMP,2*ITMP2)
      LDDEN = LEGRAD + NXYZ*NST2
      LDDEN2 = LDDEN + MAX(NS2*N3,NUNIQ*N2)
      LFCORS = LDDEN2 + NUNIQ*N3
      LYTMP = LFCORS + L3
      LOPDM = LYTMP + NUNIQ*N3*N2
      LTPDM = LOPDM + N2
      LAST = LTPDM + N4
      NEEDT = LAST - LOADFM - 1
      CALL GETFM(NEEDT)
C
C     ----- Solve CPMCSCF equations -----
C
      CALL VCLR(X(LOPDM),1,N2)
CAWCHECK
      IF (EXETYP.EQ.CHECK) THEN
        CALL VCLR(X(LOPDM),1,N2)
        CALL DAWRIT(IDAF,IODA,X(LOPDM),N2,320,0)
        GO TO 401
      ENDIF
CAWCHECK
      CALL DAREAD(IDAF,IODA,X(LOPDM),N2,320,0)
      CALL DAREAD(IDAF,IODA,X(LEPS),L3,403,0)
      CALL VCLR(X(LTPDM),1,N4)
      CALL GTTPDM(X(LTPDM),X(LX),X(LIX),N4,NINTMX)
CTJD
CTJD      CALL TSTDM2(X(LTPDM),X(LTDM2),X(LWSTMP),X(LIA),N1,N2,NSTATS,IW)
CTJD
C
      CALL VCLR(X(LFCOR),1,L2)
      IF(MASWRK) CALL DCOPY(L2,X(LOINT),1,X(LFCOR),1)
      CALL VCLR(X(LERI),1,L1*N1*N2)
      CALL VCLR(X(LAMAT),1,L1*NCORSV*N2)
C
      IF(GOPARR) THEN
         CALL DDI_PROCDLB_CREATE(C_OOOO)
         CALL DDI_PROCDLB_CREATE(C_VOOO)
         CALL DDI_PROCDLB_CREATE(C_VVOO)
         CALL DDI_PROCDLB_CREATE(C_VOVO)
C
         CALL DSCAL(L2*NXYZ,ONE/NPROC,X(LDFC),1)
         CALL DSCAL(N4*NXYZ,ONE/NPROC,X(LDERI),1)
         CALL DSCAL(L3*NXYZ,ONE/NPROC,X(LDLAG),1)
C
C     ----- Utilize two-electron integrals to construct -----
C     -----    various regular and derivative arrays    -----
C
         CALL PCPSDR(X(LWRK),X(LSDER),X(LDLAG),X(LDFC),X(LDERI),
     *               X(LFCOR),X(LERI),X(LAMAT),X(LOPDM),X(LTPDM),
     *               X(LPRCDO),X(LIA),X(LIND),NCORSV,NACT,NXYZ,L0,L1,
     *               L2,N2,N4,NROT,IW)
      END IF
C
C     ----- Utilize one-electron integrals to construct -----
C     -----    various regular and derivative arrays    -----
C
      CALL PCPSD1(X(LDHC),X(LDFC),X(LDLAG),X(LSDER),X(LFCOR),
     *            X(LOINT),X(LOPDM),X(LEPS),X(LPRCDO),X(LWRK),
     *            X(LIA),X(LIND),NXYZ,L1,L2,L3,NCORSV,NACT,NFT18)
C
C     ----- Construct configuration portions of RHS and -----
C     -----               preconditioner                -----
C
  401 CONTINUE
      CALL PCPDET(X(LDFC),X(LYAC),X(LDHC),X(LDERI),X(LFCOR),X(LOINT),
     *            X(LERI),X(LPRCDC),X(LPRCDS),X(LCI),X(LWSTMP),
     *            X(LEGRAD),X(LBOX1),X(LBOX2),X(LBOX3),X(LBOX4),
     *            X(LBOX5),X(LIBO),X(LIWRK),NXYZ,L1,L2,N2,N4,LNEED,
     *            JLO,JHI,NDETMX,NDETLN,NSTATS,ITGA,ITGB,IAST,IBST,
     *            IIS,NST2,NB1EX)
C
      SVDSWK = DSKWRK
      CALL SEQOPN(NFT19,'WORK19','UNKNOWN',.FALSE.,'UNFORMATTED')
      CALL SEQREW(NFT19)
      DO IXYZ=1,NXYZ
        LVAL = LYAC + IXYZ - 1
        CALL DCOPY(NSTATS*NDETLN,X(LVAL),NXYZ,X(LTMPWK),1)
        CALL SQWRIT(NFT19,X(LTMPWK),NSTATS*NDETLN)
      ENDDO
CAWCHECK
C
      IF(SOME) THEN
        WRITE(IW,9020)
        CALL TIMIT(1)
        WRITE(IW,9030) NROT,NDETMX
C
        MEMREP = NEED1 + NEED2 + NEEDT
        IF(EXETYP.EQ.CHECK) THEN
          WRITE(IW,9044)
          CALL CPCHK2(MEMREP,IW,NSTATS,NUNIQ,NXYZ,NDETMX,L3)
        ELSE
          WRITE(IW,9045) MEMREP,NGOTMX
        ENDIF
        CALL FLSHBF(IW)
      ENDIF
CAWCHECK
C
C     ----- Preconditioned solvers for MC electronic hessian -----
C
C     NDER = 1 FOR Z-VECTOR NACME CODE
C     NDER = 2 FOR HESSIANS OR OLD NACME CODE
      CALL MCPCGX(X(LYAO),X(LYAC),X(LYAS),X(LPRCDO),X(LPRCDC),X(LPRCDS),
     *            X(LRSIDO),X(LRSIDC),X(LRSIDS),X(LZRSO),X(LZRSC),
     *            X(LZRSS),X(LPDIRO),X(LPDIRC),X(LPDIRS),
     *            X(LBNORMO),X(LBNORMC),X(LBNORMS),
     *            X(LBKNUM),X(LBKDEN),X(LOINT),X(LFCOR),X(LAMAT),
     *            X(LERI),X(LEPS),X(LOPDM),X(LTPDM),X(LCI),
     *            X(LTMPWK),X(LIND),X(LIA),X(LIWRK),X(LIFA),X(LIBO),
     *            NOCP,NDIM,NUNIQ,NROT,NDETLN,NDETMX,IIS,JLO,JHI,NA,NB,
     *            NSYM,NCORSV,N1,L0,L1,L2,NFT18,NFT19,NSTATS,X(LWSTMP),
     *            X(LEGRAD),X(LSALAG),X(LDERI),X(LDDEN),X(LDDEN2),
     *            X(LFCORS),X(LYTMP),GENMC,LNEED,X(LBOX1),X(LBOX2),
     *            X(LBOX3),X(LBOX4),X(LBOX5),ITGA,ITGB,IAST,IBST,NB1EX,
     *            JROTLO,JROTHI,NDER,NAPICK,NACST)
C
      IF(EXETYP.EQ.CHECK) GO TO 400
C
C     -----     Construct NACME and SAMC gradients     -----
C     ----- NOTE:  ZRSO,ZRSS,ZRSC are solution vectors -----
C
      IF(NDER.EQ.1) THEN
        CALL FMNACD(X(LSAGRD),X(LZRSO),X(LZRSS),X(LZRSC),X(LYAO),
     *              X(LYAS),X(LYAC),NROT,NSTATS,NST2,NDETLN,NXYZ)
      ENDIF
      IF(NDER.EQ.2) THEN
        CALL FMNACT(X(LSAGRD),X(LYAO),X(LRHSO),NOCP,NROT,NXYZ,NUNIQ,
     *              NSTATS,X(LSALAG),ESTATE,X(LIND),L1)
      ENDIF
C
C     NOTE:  THIS Z-VECTOR SUB IS NOT READY FOR HESSIANS ANYWAYS.
C     PRINT NA COUPLINGS
      CALL PRTNAC(X(LSAGRD),X(LEGRAD),NXYZ,NSTATS,NST2,
     *            IRTTMP,NAPICK,NACST)
C
C     ----- Free memory -----
C
      CALL DCOPY(MXRT,X(LETMP),1,ESTATE,1)
C
  400 CONTINUE
C
C        restore core orbitals to the subspace counters
C
      DO II=1,NSPACE+1
        MSTA(II) = MSTA(II) + NCORSV
      ENDDO
C
      CALL RETFM(NEEDT)
      CALL RETFM(NEED2)
      CALL RETFM(NEEDWK)
      CALL RETFM(NEED1)
      IF(GOPARR) THEN
        CALL DDI_PROCDLB_DESTROY(C_VOVO)
        CALL DDI_PROCDLB_DESTROY(C_VVOO)
        CALL DDI_PROCDLB_DESTROY(C_VOOO)
        CALL DDI_PROCDLB_DESTROY(C_OOOO)
        IF(EXETYP.NE.CHECK) THEN
          IF(MASWRK) WRITE(IW,9151)
          CALL DDI_DESTROY(D_VVOO)
          IF(MASWRK) WRITE(IW,9152)
          CALL DDI_DESTROY(D_OOOO)
          IF(MASWRK) WRITE(IW,9153)
          CALL DDI_DESTROY(D_VOOO)
          IF(MASWRK) WRITE(IW,9154)
          CALL DDI_DESTROY(D_VOVO)
        ENDIF
      ENDIF
C
      IF(MASWRK) WRITE(IW,9100)
      CALL TIMIT(1)
      RETURN
C
 9000 FORMAT(/5X,49(1H-)/
     *        5X,'COUPLED-PERTURBED MULTICONFIGURATION HARTREE-FOCK'/
     *        5X,'Z-VECTOR VERSION'/
     *        5X,49(1H-))
 9010 FORMAT(/1X,'SETTING UP RIGHT-HAND SIDE OF CPMCHF EQUATIONS.',
     *       /1X,'# OF WORDS REQUIRED  = ',I10,
     *       /1X,'# OF WORDS AVAILABLE = ',I10,
     *       /1X,'NOTE THAT THE CP-MCHF DISTRIBUTED MEMORY',
     *           ' REQUIREMENTS ARE JUST THE',
     *       /1X,'MEMORY NEEDED TO STORE TRANSFORMED INTEGRAL',
     *           ' CLASSES (ALLOCATED ABOVE).')
 9020 FORMAT(/1X,'FINISHED SETTING UP RIGHT-HAND SIDE.')
 9030 FORMAT(/1X,'CALCULATING MCSCF ELECTRONIC HESSIAN ON THE FLY.',
     *       /1X,'# OF ORBITAL ROTATIONS   = ',I10,
     *       /1X,'LENGTH OF DET. EXPANSION = ',I10)
 9044 FORMAT(/1X,'ESSENTIAL CPMCHF SOLVER MEMORY.')
 9045 FORMAT(/1X,'SOLVING CPMCHF EQUATIONS - ESSENTIAL MEMORY.',
     *       /1X,'# OF WORDS REQUIRED  = ',I10,
     *       /1X,'# OF WORDS AVAILABLE = ',I10)
 9060 FORMAT(1X,'COMPUTING HESSIAN OF STATE WITH E=',F20.10,' S=',F5.1)
 9065 FORMAT(1X,'COMPUTING NACME FOR STATE WITH E=',F20.10,' S=',F5.1) 
 9100 FORMAT(/1X,'...... DONE WITH CPMCHF EQUATIONS ......')
 9151 FORMAT(1X,'FREEING DISTRIBUTED STORAGE FOR',
     *          ' [VIR VIR|OCC OCC] INTEGRALS')
 9152 FORMAT(1X,'FREEING DISTRIBUTED STORAGE FOR',
     *          ' [OCC OCC|OCC OCC] INTEGRALS')
 9153 FORMAT(1X,'FREEING DISTRIBUTED STORAGE FOR',
     *          ' [VIR OCC|OCC OCC] INTEGRALS')
 9154 FORMAT(1X,'FREEING DISTRIBUTED STORAGE FOR',
     *          ' [VIR OCC|VIR OCC] INTEGRALS') 
 9360 FORMAT(/1X,'***** ERROR IN -ZCPMCX- ROUTINE *****'/
     *       1X,'CI EIGENVECTOR FILE HAS DATA FOR NSTATE,NDETS=',I3,I10/
     *       1X,'BUT THE PRESENT CALCULATION HAS NSTATE,NDETS=',I3,I10)
      END 
C*MODULE ZCPRMC  *DECK TROPDM 
      SUBROUTINE TROPDM(BUFF,TOPDM,TTPDM,CI,RHSO,OINT,SALAG,SAGRAD,
     *                  SDER,V,WRK,INDEX,IWRK,
     *                  IOX,LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,IA,N1,
     *                  NSTATS,NDETMX,ITGA,ITGB,IAST,IBST,N2,L1,IIS,
     *                  NB1EX,LNEED,NROT,L2,L0,JLO,JHI,NXYZ)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL FDIRCT,QCORR,GOPARR,DSKWRK,MASWRK
C
      PARAMETER(MXRT=100)
C
      DIMENSION TOPDM(N1,N1,NSTATS*NSTATS),CI(NDETMX,NSTATS),BUFF(*)
      DIMENSION TTPDM(N2,N2,NSTATS*NSTATS)
      DIMENSION RHSO(NSTATS*NSTATS,NROT),OINT(*)
      DIMENSION SALAG(L1,L1,NSTATS*NSTATS),SAGRAD(*),SDER(*),V(*)
      DIMENSION WRK(*)
CAW2      DIMENSION WSTMP(*)
CAW2      DIMENSION IFA(0:N1,0:N1)
      DIMENSION IOX(N1),IWRK(IIS),LBOX1(*),LBOX2(*)
      DIMENSION LBOX3(*),LBOX4(*),LBOX5(*),INDEX(L1,L1),IA(*)
C
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,S,SZ,
     *                GRPDET,STSYM,GLIST,DWPARM,
     *                NFLGDM(MXRT),IWTS(MXRT),NCORSV,NCOR,NACT,NORB,
     *                NA,NB,K,KST,IROOT,IPURES,MAXW1,NITER,MAXP,NCI,
     *                IGPDET,KSTSYM,NFTGCI,IDWEIGH
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,STOT,SSQUAR,ECORE,ESCF,EERD,
     *                E1,E2,VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,
     *                EDFT(2),EDISP
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIM(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (TWO=2.0D+00)
C
      NSYM = 2**IGPDET
      NINDX = N2
      IF(L1.GT.NINDX) NINDX = L1
      L3 = L1*L1
C
      LWRK = 1
      LKTAB = LWRK + 43
      LGMUL = LKTAB + NSYM
      LCON = LGMUL + NSYM*NSYM
      LCOA = LCON + NA
      LCOB = LCOA + NSYM*ITGA
      LANDET = LCOB + NSYM*ITGB
      LBNDET = LANDET + NSPACE*ITGA
      NAST = LBNDET + NSPACE*ITGB
      NBST = NAST + ITGA + 1
      LSYMA = NBST + ITGB + 1
      LSYMB = LSYMA + IAST
      LGCOM = LSYMB + IBST
      LSPA = LGCOM + ITGB*ITGA
      LSPB = LSPA + IAST
      LDISB = LSPB + IBST
      LSAS = LDISB + NSYM*ITGB*ITGA
      LSBS = LSAS + (NSYM+1)*ITGA
      LSAC = LSBS + (NSYM+1)*ITGB
      LSBC = LSAC + IAST      
      LIND = LSBC + IBST
      LACON1 = LIND + N2 + 1
      LACON2 = LACON1 + NA
      LBCON1 = LACON2 + NA
      LBCON2 = LBCON1 + NA
      IPOSA = LBCON2 + NA
      IPERA = IPOSA + NA*(NACT-NA)*NSYM
      IIND1 = IPERA + NA*(NACT-NA)*NSYM
      IIND2 = IIND1 + NA*(NACT-NA)*NSYM
      IIND3 = IIND2 + NA*(NACT-NA)*NSYM
      IGROA = IIND3 + NA*(NACT-NA)*NSYM
      IMMC = IGROA + NA*(NACT-NA)*NSYM
      INDEX2 = IMMC + NSYM
      LAST = INDEX2 + NINDX*NINDX
C
      IF(IIS.LT.(LAST-1)) THEN
        IF(MASWRK) WRITE(IW,*) 'MEMORY ALLOCATION ERROR IN TROPDM'
        CALL ABRT
      ENDIF
C
      DO 10 I=1,L2
   10   IA(I) = (I*I-I)/2
C
      IVAL = LIND
      DO I=1,(N1*(N1+1))/2 + 1
        IWRK(IVAL) = (I*(I-1))/2
        IVAL = IVAL + 1
      ENDDO
C
      CALL ORMZCP(X(LBST(1)),IWRK(LKTAB),IWRK(LWRK),IWRK(LGMUL),
     *            IWRK(LCOA),IWRK(LCOB),LBOX1,LBOX2,IWRK(LANDET),
     *            IWRK(LBNDET),IWRK(NAST),IWRK(NBST),LBOX3,
     *            IWRK(LGCOM),IWRK(LCON),IOX,IWRK(LSYMB),IWRK(LSPB),
     *            IWRK(LSYMA),IWRK(LSPA),IWRK(LDISB),IWRK(LSAS),
     *            IWRK(LSBS),IWRK(LSAC),IWRK(LSBC),IGPDET,KSTSYM,
     *            ITGA,ITGB,NSYM,NA,NB,NACT,IBST,IAST,NA1EX,NB1EX,IW)
C
      IF(.NOT.FDIRCT) THEN
        IDIM1 = NSYM + 1
        IDIM2 = IBST + 1
      ELSE
        IDIM1 = 1
        IDIM2 = 1
      ENDIF
C   
      JB1GR = LAST
      JB1PE = JB1GR + NB1EX
      JB1IN = JB1PE + NB1EX
      JB1PO = JB1IN + NB1EX
      JB1ST = JB1PO + NB1EX
      JB1SY = JB1ST + IDIM1*IDIM2
      JB1IN2 = JB1SY + NB*(NACT-NB)
      LAST = JB1IN2 + 2*NB1EX
C
      IF(.NOT.FDIRCT) THEN
        CALL FCPSUP(IW,NA,NB,NACT,IWRK(LACON1),IWRK(LBCON1),
     *              IWRK(LBCON2),IWRK(LIND),IWRK(NBST),IWRK(LSPB),
     *              LBOX1,LBOX2,LBOX3,LBOX4,
     *              X(LBST(1)),LNEED,IWRK(LBNDET),IWRK(LSYMB),NSYM,
     *              ITGB,IBST,NB1EX,
     *              IWRK(JB1GR),IWRK(JB1PE),IWRK(JB1IN),IWRK(JB1PO),
     *              IWRK(JB1ST),IWRK(JB1SY),IWRK(JB1IN2))
      ENDIF
C
      IF(IIS.LT.(LAST-1)) THEN
        IVAL = NA*MAX(IAST,IBST)
        IF(MASWRK) THEN
          WRITE(IW,*) 'MEMORY ALLOCATION ERROR IN TROPDM!'
          WRITE(IW,*) 'NA1EX,NB1EX,NB1EX(APPROX)=',NA1EX,NB1EX,IVAL
        ENDIF
        CALL ABRT
      ENDIF
C
C     ----- Make transition opdm -----
C
      CALL FMTDM1(TOPDM,CI,X(LBST(1)),IOX,LBOX1,LBOX2,
     *            LBOX4,LBOX5,IWRK(LKTAB),IWRK(LACON1),
     *            IWRK(LACON2),IWRK(LBCON1),IWRK(LBCON2),IWRK(LANDET),
     *            IWRK(LBNDET),IWRK(NAST),IWRK(NBST),IWRK(LSYMA),
     *            IWRK(LSYMB),IWRK(LGCOM),IWRK(LSPA),IWRK(LSPB),
     *            IWRK(LDISB),IWRK(LSAS),IWRK(LSBS),IWRK(LSAC),ITGA,
     *            ITGB,IAST,IBST,LNEED,NACT,NA,NB,NSTATS,NSYM,NDETMX)
C
C     OSCILLATOR STRENGTHS FORMED HERE BEFORE
C     SYMMETRIZING TROPDM DENSITY MATRIX.
c
      ntot=nact+ncorsv
C
      nstats2 = (nstats*nstats+nstats)/2
      call valfm(loadfm)
      lxao    = loadfm + 1
      lyao    = lxao   + l2
      lzao    = lyao   + l2
      lxmo    = lzao   + l2
      lymo    = lxmo   + ntot*ntot
      lzmo    = lymo   + ntot*ntot
      losc    = lzmo   + ntot*ntot
      lvao    = losc   + nstats2
      lastosc = lvao   + l1*l1
      needosc = lastosc - loadfm - 1
      call getfm(needosc)
c
      call detosc(topdm,n1,nstats,nstats2,l1,l2,ntot,estate,ncorsv,
     *            x(lxao),x(lyao),x(lzao),x(lxmo),x(lymo),x(lzmo),
     *            x(losc),x(lvao))
c
      call retfm(needosc)
C
CAW2      NSTAT3 = NSTATS*NSTATS
CAW2      N3 = N1*N1
CTJD      IF(MASWRK) THEN
CTJD        WRITE(IW,*) 'TR OPDM SQUARE'
CTJD        CALL PRSQ(TOPDM,NSTAT3,N3,N3)
CTJD        CALL FLSHBF(IW)
CTJD      ENDIF
CTJD
C
C     ----- Initialize orbital part of rhs of cpmchf equations ----- 
C
      NOCC = NCORSV + NACT
      DO 100 J=NCORSV+1,NOCC
        DO 100 I=NCORSV+1,NOCC
          IPHSE = INDEX(I,J)
          IROT = IABS(IPHSE)
          IF(IROT.EQ.0) GO TO 100
          DLT = IROT
          DLT = DLT/IPHSE
          DO 80 ISTAT=1,NSTATS
            DO 80 JSTAT=1,NSTATS
              IF(ISTAT.EQ.JSTAT) GO TO 80
              IJSTAT = (ISTAT-1)*NSTATS + JSTAT 
              DVAL = DLT*TOPDM(I-NCORSV,J-NCORSV,IJSTAT)
              RHSO(IJSTAT,IROT) = RHSO(IJSTAT,IROT) + DVAL
   80     CONTINUE
  100 CONTINUE
C
C     ----- Utilize asymmetric transition opdm before -----
C     -----  constructing symmetric transition opdm  -----
C
      NS2 = NSTATS*NSTATS
      CALL VCLR(SALAG,1,L3*NS2)
      CALL CSFNAC(TOPDM,SAGRAD,SDER,V,SALAG,WRK,NXYZ,NCORSV,NACT,
     *            NSTATS,NS2,L1,L3)
      CALL VCLR(SALAG,1,L3*NS2)
C
C     ----- Initialize transition lagrangian with -----
C     -----          one-electron terms           -----      
C
      DO 280 ISTAT=1,NSTATS
        DO 280 JSTAT=1,NSTATS
          IF(ISTAT.EQ.JSTAT) GO TO 280
          IJST = (ISTAT-1)*NSTATS + JSTAT
          DO 270 I=1,NACT
            DO 270 J=1,I-1
              DVAL = TOPDM(I,J,IJST) + TOPDM(J,I,IJST)
              DVAL = DVAL/TWO 
              TOPDM(I,J,IJST) = DVAL
              TOPDM(J,I,IJST) = DVAL
  270     CONTINUE         
  280 CONTINUE
C
      IF(.NOT.MASWRK) GO TO 700
      DO 400 I=1,L0
        DO 300 J=1,NCORSV
          IG = MAX(I,J)
          JG = MIN(I,J)
          IJ = IA(IG) + JG 
          DVAL = TWO*OINT(IJ)
          DO ISTAT=1,NSTATS
            IISTAT = (ISTAT-1)*NSTATS + ISTAT
            SALAG(I,J,IISTAT) = SALAG(I,J,IISTAT) + DVAL 
          ENDDO
  300   CONTINUE
  400 CONTINUE
C
      DO 600 I=1,L0
        DO 500 M=NCORSV+1,NOCC
          IG = MAX(I,M)
          MG = MIN(I,M)
          IM = IA(IG) + MG
          DINT = OINT(IM)
          DO 450 J=NCORSV+1,NOCC
            DO 420 ISTAT=1,NSTATS
              DO 420 JSTAT=1,NSTATS
                IJSTAT = (ISTAT-1)*NSTATS + JSTAT
                DVAL = DINT*TOPDM(M-NCORSV,J-NCORSV,IJSTAT)
                SALAG(I,J,IJSTAT) = SALAG(I,J,IJSTAT) + DVAL
  420       CONTINUE 
  450     CONTINUE
  500   CONTINUE
  600 CONTINUE
CTJD
CTJD      WRITE(IW,*) 'TR OPDM SYMMETRIC'
CTJD      CALL PRSQ(TOPDM,NSTAT3,N3,N3)
CTJD      CALL FLSHBF(IW)
CTJD
C
C     ----- Add two-electron terms to transition lagrangian -----      
C
  700 CALL VCLR(TTPDM,1,NSTATS*NSTATS*N2*N2)
      CALL FMTDM2(X(LBST(1)),CI,TTPDM,LBOX1,LBOX5,IWRK(LACON1),
     *            IWRK(NAST),IWRK(LSPA),IWRK(LSYMA),IWRK(LKTAB),
     *            IWRK(IMMC),LBOX2,IOX,IWRK(LGMUL),IWRK(LIND),
     *            IWRK(LACON2),LBOX4,IWRK(LANDET),IWRK(LBCON1),
     *            IWRK(IPOSA),IWRK(IPERA),IWRK(IIND1),IWRK(IIND2),
     *            IWRK(IIND3),IWRK(IGROA),IWRK(LGCOM),IWRK(LDISB),
     *            IWRK(LSBS),LBOX3,IWRK(LSBC),IWRK(LBCON2),IWRK(NBST),
     *            IWRK(JB1GR),IWRK(JB1PE),IWRK(JB1IN),IWRK(JB1PO),
     *            IWRK(JB1ST),IWRK(JB1IN2),IWRK(LSPB),IWRK(LSAS),
     *            IWRK(LSAC),IWRK(LBNDET),IWRK(LSYMB),NA,ITGA,IAST,
     *            NSYM,NACT,LNEED,ITGB,JLO,JHI,NSTATS,NDETMX,N2,NB,
     *            IBST,NB1EX,IDIM1,IDIM2)
C
      CALL TRLAG2(BUFF,SALAG,TOPDM,TTPDM,IA,NCORSV,NACT,NSTATS,
     *            L1,L0,N2)
CTJD
CTJD          NTMP = NSTATS*NSTATS
CTJD          WRITE(IW,*) 'TR OPDM SQUARE'
CTJD          DO IJSTAT=1,NTMP 
CTJD            WRITE(IW,*) 'SALAG= ',IJSTAT
CTJD            CALL PRSQ(SALAG(1,1,IJSTAT),L0,L0,L0)
CTJD          ENDDO
CTJD          CALL FLSHBF(IW)
CTJD
C
C     ----- Finish constructing orbital part of RHS -----
C
      DO 1000 I=1,L0
        DO 1000 J=1,I
          IPHSE = INDEX(I,J)
          IROT = IABS(IPHSE)
          IF(IROT.EQ.0) GO TO 1000
CTJD
CTJD          DCONV=ZERO
CTJD
          DO 900 ISTAT=1,NSTATS
            DO 900 JSTAT=1,NSTATS
              IJSTAT = (ISTAT-1)*NSTATS + JSTAT
              DVAL = SALAG(I,J,IJSTAT) - SALAG(J,I,IJSTAT)
              IF(ISTAT.NE.JSTAT) 
     *                 DVAL = DVAL/(ESTATE(ISTAT)-ESTATE(JSTAT))
              RHSO(IJSTAT,IROT) = RHSO(IJSTAT,IROT) + DVAL
CTJD
CTJD              IF(ISTAT.EQ.JSTAT) DCONV=DCONV+WSTMP(ISTAT)*DVAL
CTJD
  900     CONTINUE
CTJD
CTJD          IF(ABS(DCONV).GT.TOL) WRITE(IW,9721) I,J,DCONV
CTJD
 1000 CONTINUE
C
      CALL DAWRIT(IDAF,IODA,RHSO,NSTATS*NSTATS*NROT,490,0)
C
CAW2 9721 FORMAT(1X,'I,J=',I4,I4,1X,'Lij - Lji=',F10.7)
      RETURN
      END
C*MODULE ZCPRMC  *DECK FMTDM1
      SUBROUTINE FMTDM1(TOPDM,CI,X,IOB,LBOX1,LBOX2,
     *                  LBOX4,LBOX5,KTAB,IACON1,IACON2,
     *                  IBCON1,IBCON2,LANDET,LBNDET,NAST,NBST,
     *                  LSYMA,LSYMB,LGCOM,LSPA,LSPB,LDISB,LSAS,
     *                  LSBS,LSAC,ITGA,ITGB,IAST,IBST,NX,
     *                  NACT,NA,NB,NSTATS,NSYM,NDETMX)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL FDIRCT,QCORR
C
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIM(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
C
      DIMENSION TOPDM(NACT,NACT,NSTATS*NSTATS),CI(NDETMX,NSTATS)
      DIMENSION X(NX)
CAW2      DIMENSION INDEX((NACT*(NACT+1))/2+1)
      DIMENSION IOB(NACT)
      DIMENSION LBOX1(NSPACE),LBOX2(NSPACE)
      DIMENSION LBOX4(NSPACE),LBOX5(NSPACE)
      DIMENSION KTAB(NSYM)
      DIMENSION IACON1(NA),IACON2(NA),IBCON1(NA),IBCON2(NA)
      DIMENSION LANDET(NSPACE,ITGA),LBNDET(NSPACE,ITGB)
      DIMENSION NAST(ITGA+1),NBST(ITGB+1)
      DIMENSION LSYMA(IAST),LSYMB(IBST),LGCOM(ITGB,ITGA)
      DIMENSION LSPA(IAST),LSPB(IBST),LDISB(NSYM,ITGB,ITGA)
      DIMENSION LSAS(NSYM+1,ITGA),LSBS(NSYM+1,ITGB)
      DIMENSION LSAC(IAST)
C
CAW2      NAT = NA
CAW2      NBT = NB
      CALL VCLR(TOPDM,1,NACT*NACT*NSTATS*NSTATS)
C
      CALL RESETCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX5)
C
      DO 5000 IGA=1,ITGA
C
         CALL RESETDE(LBOX1,NSPACE,NA,MSTA,IACON1)
C
C  KKA GIVES THE ACTUAL POSITION OF THE ALPHA STRING IACON1 IN
C  THE FULL ALPHA STRING LIST.
C
         DO 4900 KKA=NAST(IGA)+1,NAST(IGA+1)
            JPZA1 = LSPA(KKA)
            JASYM = LSYMA(KKA)
            KSYM=KTAB(JASYM)
C
            DO II=1,NSPACE
               LBOX2(II) = LBOX1(II)
            ENDDO
C
C  LOOP OVER SPACES TO EXCITE ELECTRON FROM.
C
            IEAS = NA+1
            DO 4890 ISPA1=NSPACE,1,-1
               IOC1 = LBOX1(ISPA1)
               IEAE = IEAS - 1
               IEAS = IEAS - IOC1
               IF (IOC1.EQ.0) GO TO 4890
               LBOX2(ISPA1) = LBOX2(ISPA1)-1
C
C  LOOP ELECTRONS IN SPACE ISPA1.
C  IEAS, IEAE ARE THE ELECTRONS IN SPACE ISPA1.
C
               DO 4885 IA1=IEAE,IEAS,-1
                  IO1 = IACON1(IA1)
                  IGAE = IEAE - LBOX1(ISPA1)
                  IS1 = IOB(IO1)
C
C  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
C
               DO 4880 ISPA2=ISPA1,NSPACE
C
C  IGAS, IGAE ARE ELECTRONS SPECIFYING ISPA2 SPACE ELECTRON LIMITS.
C
                  IGAS = IGAE + 1
                  IGAE = IGAE + LBOX1(ISPA2)
C
                  LBOX2(ISPA2) = LBOX2(ISPA2) + 1
                  IF (LBOX2(ISPA1).LT.IAMI(ISPA1)) GO TO 4870
                  IF (LBOX2(ISPA2).GT.IAMA(ISPA2)) GO TO 4870
C
C  GET GROUP NUMBER
C
           CALL POSITCO(LBOX5,NSPACE,NA,IAMA,IAMI,LBOX4,LBOX2,IGA2)
           NIAS = NAST(IGA2)
C
C  MAKE GAP INFORMATION HERE.
C
                  IGAA = MAX(IA1+1,IGAS)
                  IF (LBOX1(ISPA2).EQ.0) THEN
                     ISTA = MSTA(ISPA2)
                     IEND = MSTA(ISPA2+1)-1
                  ELSEIF (ISPA2.EQ.ISPA1) THEN
                     ISTA = IO1+1
                     IEND = IACON1(IGAA)-1
                     IF (IA1.EQ.IEAE) IEND=MSTA(ISPA1+1)-1
                  ELSE
                     ISTA = MSTA(ISPA2)
                     IEND = IACON1(IGAA)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 4860 IGAP=IGAA,IGAE+1
C
                     DO 4850 JJ=ISTA,IEND
                        IS2 = IOB(JJ)
C
C   IF DEOCCUPIED AND NEWLY OCCUPIED ORBITALS ARE OF DIFFERENT SYMMETRY,
C   SKIP.
C
              IF (IS1.NE.IS2) GO TO 4850
C
CAW2              FTNCHCK --> NEVER USED.
CAW2              IND = INDEX(JJ) + IO1
C
              CALL REDE00(IACON1,IACON2,NA,IA1,IGAP-1,JJ,JPERA)
              CALL IDPOST(IACON2,NA,LBOX2,NSPACE,MSTA,IDIM,X,NX,LBST,
     *                  LANDET(1,IGA2),IBCON1,JPOSA)
              KAPOS = JPOSA + NIAS
              JPZA2 = LSPA(KAPOS)
              KPER1 = (-1)**JPERA
C
C  LOOP OVER BETA STRINGS OF RIGHT SYMMETRY AND GROUP
C
              DO 4700 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB,IGA2).NE.1) GOTO 4700
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
              JCI2 = JPZA2 + LDISB(KSYM,IGB,IGA2)
C
              DO 4680 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 JCI1 = JCI1 + 1
                 JCI2 = JCI2 + 1
                 FC = KPER1
                 DO 4670 ISTAT=1,NSTATS
                   DO 4670 JSTAT=1,NSTATS
                     IJSTAT = (ISTAT-1)*NSTATS + JSTAT
                     FCJI = FC*CI(JCI1,JSTAT)*CI(JCI2,ISTAT)
                     TOPDM(IO1,JJ,IJSTAT) = TOPDM(IO1,JJ,IJSTAT) + FCJI 
                     FCJI = FC*CI(JCI2,JSTAT)*CI(JCI1,ISTAT)
                     TOPDM(JJ,IO1,IJSTAT) = TOPDM(JJ,IO1,IJSTAT) + FCJI
 4670            CONTINUE
 4680         CONTINUE
C
 4700         CONTINUE
C
 4850          CONTINUE
C
                  ISTA = IACON1(IGAP)+1
                  IEND = IACON1(IGAP+1)-1
                  IF (IGAP.EQ.IGAE) IEND=MSTA(ISPA2+1)-1
 4860             CONTINUE
C
 4870             LBOX2(ISPA2) = LBOX2(ISPA2) - 1
 4880          CONTINUE
C
 4885          CONTINUE
C
               LBOX2(ISPA1) = LBOX2(ISPA1)+1
 4890       CONTINUE
C
C   DIAGONAL CONTRIBUTIONS HERE.
C
            DO 67 II=1,NA
               I1 = IACON1(II)
CAW2               FTNCHK --> NEVER USED.
CAW2               IND1 = INDEX(I1+1)
C             
               DO 53 IGB=1,ITGB
                  IF (LGCOM(IGB,IGA).NE.1) GO TO 53
                  JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
                  DO 58 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                     JCI1 = JCI1 + 1
                     DO 52 ISTAT=1,NSTATS
                       DO 52 JSTAT=1,NSTATS
                        IJSTAT = (ISTAT-1)*NSTATS + JSTAT
                        FC = CI(JCI1,JSTAT)*CI(JCI1,ISTAT)
                        TOPDM(I1,I1,IJSTAT) = TOPDM(I1,I1,IJSTAT) + FC
   52                CONTINUE
   58             CONTINUE
   53          CONTINUE
C
   67       CONTINUE
C                 
CAW2 4899     CONTINUE
            CALL MOVEUP2(LBOX1,NSPACE,NA,MSTA,IACON1)
 4900    CONTINUE 
C
         CALL PUSHCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX5,IEND)
 5000 CONTINUE 
C
C  --- END OF LOOP OVER ALPHA STRINGS ----
C
C  --- BIG LOOP OVER BETA -----
C
      CALL RESETCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX5)
C
      DO 8000 IGB=1,ITGB
C
         CALL RESETDE(LBOX1,NSPACE,NB,MSTA,IBCON1)
C
C  KKB GIVES THE ACTUAL POSITION OF THE BETA STRING IBCON1 IN
C  THE FULL BETA STRING LIST.
C
         DO 7900 KKB=NBST(IGB)+1,NBST(IGB+1)
            JPZB1 = LSPB(KKB)
            KBSYM = LSYMB(KKB)
            KSYM=KTAB(KBSYM)
C
            DO II=1,NSPACE
               LBOX2(II) = LBOX1(II)
            ENDDO
C
C  LOOP OVER SPACES TO EXCITE ELECTRON FROM.
C
            IEBS = NB+1
            DO 7890 ISPB1=NSPACE,1,-1
               IOC1 = LBOX1(ISPB1)
               IEBE = IEBS - 1
               IEBS = IEBS - IOC1
               IF (IOC1.EQ.0) GO TO 7890
               LBOX2(ISPB1) = LBOX2(ISPB1)-1
C
C  LOOP ELECTRONS IN SPACE ISPB1.
C  IEBS, IEBE ARE THE ELECTRONS IN SPACE ISPB1.
C
               DO 7885 IB1=IEBE,IEBS,-1
                  IO1 = IBCON1(IB1)
                  IGBE = IEBE - LBOX1(ISPB1)
                  IS1 = IOB(IO1)
C
C  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
C
               DO 7880 ISPB2=ISPB1,NSPACE
C
C  IGBS, IGBE ARE ELECTRONS SPECIFYING ISPB2 SPACE ELECTRON LIMITS.
C
                  IGBS = IGBE + 1
                  IGBE = IGBE + LBOX1(ISPB2)
C
                  LBOX2(ISPB2) = LBOX2(ISPB2) + 1
                  IF (LBOX2(ISPB1).LT.IBMI(ISPB1)) GO TO 7870
                  IF (LBOX2(ISPB2).GT.IBMA(ISPB2)) GO TO 7870
C
C  GET GROUP NUMBER
C
           CALL POSITCO(LBOX5,NSPACE,NB,IBMA,IBMI,LBOX4,LBOX2,IGB2)
           NIBS = NBST(IGB2)
C
C  MAKE GAP INFORMATION HERE.
C
                  IGBB = MAX(IB1+1,IGBS)
                  IF (LBOX1(ISPB2).EQ.0) THEN
                     ISTA = MSTA(ISPB2)
                     IEND = MSTA(ISPB2+1)-1
                  ELSEIF (ISPB2.EQ.ISPB1) THEN
                     ISTA = IO1+1
                     IEND = IBCON1(IGBB)-1
                     IF (IB1.EQ.IEBE) IEND=MSTA(ISPB1+1)-1
                  ELSE
                     ISTA = MSTA(ISPB2)
                     IEND = IBCON1(IGBB)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 7860 IGAP=IGBB,IGBE+1
C
                     DO 7850 JJ=ISTA,IEND
                        IS2 = IOB(JJ)
CAW2                        FTNCHCK --> NEVER USED.
CAW2                        IND = INDEX(JJ) + IO1
C
C   IF DEOCCUPIED AND NEWLY OCCUPIED ORBITALS ARE OF DIFFERENT SYMMETRY,
C   SKIP TO DOUBLES.
C
                        IF (IS1.NE.IS2) GO TO 7850
C
              CALL REDE00(IBCON1,IBCON2,NB,IB1,IGAP-1,JJ,JPERB)
C
              CALL IDPOST(IBCON2,NB,LBOX2,NSPACE,MSTA,IDIM,X,NX,LBST,
     *                  LBNDET(1,IGB2),IACON1,JPOSB)
              KBPOS = JPOSB + NIBS
              JPZB2 = LSPB(KBPOS)
              KPER1 = (-1)**JPERB
C
C  LOOP OVER ALPHA STRINGS OF THE RIGHT GROUP AND SYMMETRY.
C
              DO 7700 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB2,IGA).NE.1) GOTO 7700
                 JCIB1 = LDISB(KBSYM,IGB,IGA) + JPZB1
                 JCIB2 = LDISB(KBSYM,IGB2,IGA) + JPZB2
                 NIAS = NAST(IGA)
C
              DO 7680 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA1 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA1)
                 JCI1 = JCIA + JCIB1
                 JCI2 = JCIA + JCIB2
C
                 FC = KPER1
                 DO 7670 ISTAT=1,NSTATS
                   DO 7670 JSTAT=1,NSTATS
                     IJSTAT = (ISTAT-1)*NSTATS + JSTAT
                     FCJI = FC*CI(JCI1,JSTAT)*CI(JCI2,ISTAT)
                     TOPDM(IO1,JJ,IJSTAT) = TOPDM(IO1,JJ,IJSTAT) + FCJI
                     FCJI = FC*CI(JCI2,JSTAT)*CI(JCI1,ISTAT)
                     TOPDM(JJ,IO1,IJSTAT) = TOPDM(JJ,IO1,IJSTAT) + FCJI
 7670            CONTINUE
C
 7680         CONTINUE
 7700         CONTINUE
C
 7850                CONTINUE
C
                  ISTA = IBCON1(IGAP)+1
                  IEND = IBCON1(IGAP+1)-1
                  IF (IGAP.EQ.IGBE) IEND=MSTA(ISPB2+1)-1
 7860             CONTINUE
C
 7870             LBOX2(ISPB2) = LBOX2(ISPB2) - 1
 7880          CONTINUE
C
 7885          CONTINUE
C
               LBOX2(ISPB1) = LBOX2(ISPB1)+1
 7890       CONTINUE
C
C  REMAINING PART OF DIAGONAL CONTRIBUTIONS.
C
            DO 69 II=1,NB
               I1 = IBCON1(II)
CAW2               FTNCHCK --> NEVER USED.
CAW2               IND1 = INDEX(I1+1)
C
              DO 76 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1) GO TO 76
                 JCIB1 = LDISB(KBSYM,IGB,IGA) + JPZB1
                 NIAS = NAST(IGA)
C
              DO 78 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA1 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA1)
                 JCI1 = JCIA + JCIB1
C
                 DO 92 ISTAT=1,NSTATS
                   DO 92 JSTAT=1,NSTATS
                     IJSTAT = (ISTAT-1)*NSTATS + JSTAT
                     FC = CI(JCI1,JSTAT)*CI(JCI1,ISTAT)
                     TOPDM(I1,I1,IJSTAT) = TOPDM(I1,I1,IJSTAT) + FC
   92            CONTINUE
C
   78         CONTINUE
   76         CONTINUE
C
   69       CONTINUE
C
CAW2 7899      CONTINUE
            CALL MOVEUP2(LBOX1,NSPACE,NB,MSTA,IBCON1)
 7900    CONTINUE
C
         CALL PUSHCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX5,IEND)
 8000 CONTINUE
C
C --- END OF LOOP OVER BETA STRINGS. ---
C
      RETURN
      END 
C*MODULE ZCPRMC  *DECK ORMZCP
      SUBROUTINE ORMZCP(X,KTAB,LWRK,LGMUL,LCOA,LCOB,LBOX1,LBOX2,
     *                 LANDET,LBNDET,NAST,NBST,LBOX3,LGCOM,LCON,IBO,
     *                 LSYMB,LSPB,LSYMA,LSPA,LDISB,LSAS,LSBS,LSAC,LSBC,
     *                 IDSYM,ISYM1,ITGA,ITGB,NSYM,NA,NB,NACT,IBST,IAST,
     *                 NA1EX,NB1EX,IW)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL FDIRCT,QCORR
C
      DIMENSION X(*)
      DIMENSION KTAB(NSYM),LWRK(43),LGMUL(NSYM,NSYM)
      DIMENSION LCOA(NSYM,ITGA),LCOB(NSYM,ITGB),LBOX1(*),LBOX2(*)
      DIMENSION LANDET(NSPACE,ITGA),LBNDET(NSPACE,ITGB),NAST(ITGA+1)
      DIMENSION NBST(ITGB+1),LBOX3(*),LGCOM(ITGB,ITGA),LCON(NA)
      DIMENSION IBO(NACT),LSYMB(IBST),LSPB(IBST),LSYMA(IAST)
      DIMENSION LSPA(IAST),LDISB(NSYM,ITGB,ITGA),LSAS(NSYM+1,ITGA)
      DIMENSION LSBS(NSYM+1,ITGB),LSAC(IAST),LSBC(IBST)
C
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIM(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
C
C 1/
C   MAKE SYMMETRY TABLES
C
      IF (IDSYM.GT.0) THEN
      CALL GTAB(IDSYM,ISYM1,KTAB,LWRK(1),LWRK(4),LWRK(7),LWRK(10))
      CALL GMUL(IDSYM,LGMUL,LWRK(1),LWRK(4),LWRK(7),LWRK(10))
      ELSE
      CALL GTAB(1,1,KTAB,LWRK(1),LWRK(4),LWRK(7),LWRK(10))
      CALL GMUL(1,LGMUL,LWRK(1),LWRK(4),LWRK(7),LWRK(10))
      ENDIF
C
      DO II=1,ITGA
         DO JJ=1,NSYM
            LCOA(JJ,II) = 0
         ENDDO
      ENDDO
C
      DO II=1,ITGB
         DO JJ=1,NSYM
            LCOB(JJ,II) = 0
         ENDDO
      ENDDO
C
C  2/
C    MAKE LANDET, LBNDET.  LANDET(I,J) SAYS HOW MANY ALPHA STRINGS
C    THERE ARE FOR GROUP J, SPACE I.  ANALOGOUS FOR LBNDET(I,J).
C
C    LOOP THROUGH ALL ALPHA GROUPS:
C
      ISTA1 = LBST(1)
      CALL RESETCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX2)
      DO II=1,ITGA
         DO JJ=1,NSPACE
            ISTA2 = LBST(JJ) - ISTA1 + 1
            LANDET(JJ,II)=ISPADET(X(ISTA2),MNUM(JJ),IDIM(JJ),LBOX1(JJ))
         ENDDO
      CALL PUSHCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX2,IEND)
      ENDDO
C
C    LOOP THROUGH ALL BETA GROUPS, DO SAME AS ABOVE ESSENTIALLY.
C
      CALL RESETCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX2)
      DO II=1,ITGB
         DO JJ=1,NSPACE
            ISTA2 = LBST(JJ) - ISTA1 + 1
            LBNDET(JJ,II)=ISPADET(X(ISTA2),MNUM(JJ),IDIM(JJ),LBOX1(JJ))
         ENDDO
      CALL PUSHCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX2,IEND)
      ENDDO
C
C  3/
C    MAKE NAST, NBST.  NAST(I) SAYS WHERE ALPHA STRINGS OF GROUP I
C    START IN FULL STRING LIST - 1.  ANALOGOUS FOR NBST.
C
      NAST(1) = 0
      NBST(1) = 0
      DO II=1,ITGA
         ITOT = 1
         DO JJ=1,NSPACE
            ITOT = ITOT * LANDET(JJ,II)
         ENDDO
         NAST(II+1) = NAST(II) + ITOT
      ENDDO
C
      DO II=1,ITGB
         ITOT = 1
         DO JJ=1,NSPACE
            ITOT = ITOT * LBNDET(JJ,II)
         ENDDO
         NBST(II+1) = NBST(II) + ITOT
      ENDDO
C
C  4/
C       MAKE LGCOM.  IF LGCOM(I,J).NE.0 THEN BETA GROUP I
C       AND ALPHA GROUP J ARE COMPATIBLE.
C
      ICOMP = 0
      CALL RESETCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX3)
      DO JJ=1,ITGA
         CALL RESETCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3)
         DO II=1,ITGB
            LGCOM(II,JJ) = 0
            DO KK=1,NSPACE
               IOC = LBOX1(KK) + LBOX2(KK)
               IF (IOC.GT.MAXI(KK).OR.IOC.LT.MINI(KK)) GO TO 100
            ENDDO
C
            LGCOM(II,JJ) = 1
            ICOMP = ICOMP + 1
  100       CALL PUSHCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3,IEND)
         ENDDO
         CALL PUSHCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX3,IEND)
      ENDDO
C
C  5/
C    A) MAKE LSYMB.  LSYMB(I) IS SYMMETRY OF BETA STRING I.
C       MAKE LCOB.  LCOB(I,J) IS NUMBER OF DETERMINANTS
C       OF SYMMETRY I IN GROUP J.
C       MAKE LSPB.  LSPB(I) IS BETA STRING I'S SYMMETRY POSITION IN
C       IT'S OWN GROUP.
C
      CALL RESETCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX2)
C
C    LOOP THROUGH GROUPS.
C
      ICOUNT = 0
      DO II=1,ITGB
C
C    LOOP THROUGH ALL STRINGS IN GROUP II.
C
         CALL RESETDE(LBOX1,NSPACE,NB,MSTA,LCON)
C
         ITOT = 1
         DO JJ=1,NSPACE
            ITOT = ITOT * LBNDET(JJ,II)
         ENDDO
C
         DO KK=1,ITOT
            ICOUNT = ICOUNT + 1
            CALL GETSYM1(IW,LCON,NACT,NB,IBO,IDSYM,ISYM,
     *      LWRK(1),LWRK(4),LWRK(7),LWRK(10))
            LSYMB(ICOUNT) = ISYM
            LCOB(ISYM,II) = LCOB(ISYM,II) + 1
            LSPB(ICOUNT) = LCOB(ISYM,II)
C
            CALL MOVEUP2(LBOX1,NSPACE,NB,MSTA,LCON)
         ENDDO
C
         CALL PUSHCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX2,IEND)
      ENDDO
C
C    B) - MAKE LSYMA.  LSYMA(I) IS SYMMETRY OF ALPHA STRING I.
C       - MAKE LCOA.  LCOA(I,J) IS NUMBER OF DETERMINANTS
C         OF SYMMETRY I IN GROUP J.
C       - MAKE LSPA.  LSPA(I) IS WHERE ALPHA STRING I STARTS IN
C         THE FULL LIST OF DETERMINANTS.  EACH ALPHA STRING IS COUPLED
C         WITH RELEVANT BETA STRINGS (IN BETA GROUP AND SYMMETRY ORDER).
C       - MAKE LDISB.  LDISB(ISYM,I,J) SAYS WHERE BETA GROUP I, AND
C         SYMMETRY ISYM STARTS WHEN COUPLED TO ALPHA GROUP J.
C
      CALL RESETCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX2)
C
C    LOOP THROUGH GROUPS.
C
      ICOUNT = 0
      NCI = 0
CAW2      IVAL = 1
CAW2      JVAL = 1
      DO II=1,ITGA
C
C    LOOP THROUGH ALL STRINGS IN GROUP II.
C
         CALL RESETDE(LBOX1,NSPACE,NA,MSTA,LCON)
         ITOT = 1
         DO JJ=1,NSPACE
            ITOT = ITOT * LANDET(JJ,II)
         ENDDO
C
         DO KK=1,ITOT
            ICOUNT = ICOUNT + 1
            CALL GETSYM1(IW,LCON,NACT,NA,IBO,IDSYM,ISYM,
     *      LWRK(1),LWRK(4),LWRK(7),LWRK(10))
            LSYMA(ICOUNT) = ISYM
            LCOA(ISYM,II) = LCOA(ISYM,II) + 1
C
            LSPA(ICOUNT) = NCI
            JSYM = KTAB(ISYM)
            DO 200 LL=1,ITGB
               IF (LGCOM(LL,II).EQ.0) GO TO 200
               NCI = NCI + LCOB(JSYM,LL)
  200       CONTINUE
C
            CALL MOVEUP2(LBOX1,NSPACE,NA,MSTA,LCON)
         ENDDO
C
         DO KK=1,NSYM
            LWRK(KK) = 0
         ENDDO
         DO 300 JJ=1,ITGB
            DO KK=1,NSYM
               LDISB(KK,JJ,II) = 0
            ENDDO
            IF (LGCOM(JJ,II).EQ.0) GO TO 300
            DO KK=1,NSYM
               LDISB(KK,JJ,II) = LWRK(KK)
               LWRK(KK) = LWRK(KK) + LCOB(KK,JJ)
            ENDDO
  300    CONTINUE
C
         CALL PUSHCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX2,IEND)
      ENDDO
C
C  6/
C    A) MAKE LSAS,LSBS,AND LSAC, LSBC.
C       LSAS(I,J) SAYS WHERE ALPHA STRINGS
C       OF GROUP J AND SYMMETRY I, START IN LSAC.
C       ANALOGOUS FOR LSBS AND LSBC.
C
      IPLA = 1
      DO II=1,ITGA
         DO JJ=1,NSYM
            LSAS(JJ,II) = IPLA
            IPLA = IPLA + LCOA(JJ,II)
         ENDDO
         LSAS(NSYM+1,II) = IPLA
      ENDDO
C
      IPLB = 1
      DO II=1,ITGB
         DO JJ=1,NSYM
            LSBS(JJ,II) = IPLB
            IPLB = IPLB + LCOB(JJ,II)
         ENDDO
         LSBS(NSYM+1,II) = IPLB
      ENDDO
C
      DO II=1,ITGA
         ITOT = 1
         DO JJ=1,NSYM
            LWRK(JJ) = 0
         ENDDO
         DO JJ=1,NSPACE
            ITOT = ITOT * LANDET(JJ,II)
         ENDDO
         IDISA = NAST(II)
         DO KK=1,ITOT
            JSYM = LSYMA(IDISA+KK)
            LWRK(JSYM) = LWRK(JSYM)+1
            LSAC(LSAS(JSYM,II)+LWRK(JSYM)-1) = KK
         ENDDO
      ENDDO
C
      DO II=1,ITGB
         ITOT = 1
         DO JJ=1,NSYM
            LWRK(JJ) = 0
         ENDDO
         DO JJ=1,NSPACE
            ITOT = ITOT * LBNDET(JJ,II)
         ENDDO
         IDISB = NBST(II)
         DO KK=1,ITOT
            JSYM = LSYMB(IDISB+KK)
            LWRK(JSYM) = LWRK(JSYM)+1
            LSBC(LSBS(JSYM,II)+LWRK(JSYM)-1) = KK
         ENDDO
      ENDDO
CAW2  IN FUTURE, MAYBE REMOVE NA1EX FROM HERE AND CALLS.
      NA1EX = 0
      NB1EX = ITGA
      IF (FDIRCT) RETURN
      NB1EX = 0
C
C ****************************************
C   DETERMINE TOTAL NUMBER OF SINGLE BETA EXCITATIONS
C   WHERE B' > B.
C ****************************************
C
C    LOOP THROUGH ALL BETA GROUPS
C
      CALL RESETCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX3)
C
      DO 1000 IIB = 1,ITGB
C
         CALL RESETDE(LBOX1,NSPACE,NB,MSTA,LCON)
C
         DO 900 KKB=NBST(IIB)+1,NBST(IIB+1)
            DO II=1,NSPACE
               LBOX2(II) = LBOX1(II)
            ENDDO
C
C  LOOP OVER ALL SINGLE EXCITATIONS, CHECKING TO SEE
C  IF IT IS VALID.
C
C  LOOP SPACES TO EXCITE ELECTRONS FROM.
C
            IEBS = NB+1
            DO 890 ISPB1=NSPACE,1,-1
               IOC1 = LBOX1(ISPB1)
               IEBE = IEBS - 1
               IEBS = IEBS - IOC1
               IF (IOC1.EQ.0) GO TO 890
               LBOX2(ISPB1) = LBOX2(ISPB1)-1
C
C  LOOP ELECTRONS IN SPACE ISPB1
C  IEBS, IEBE ARE THE ELECTRONS IN SPACE ISPB1
C
               DO 885 IB1=IEBE,IEBS,-1
                  IO1 = LCON(IB1)
C
                  IGBE = IEBE - LBOX1(ISPB1)
C
C  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
C
               DO 880 ISPB2=ISPB1,NSPACE
C
C  IGBS,IGBE ARE ELECTRONS SPECIFYING ISPB2 SPACE ELECTRON LIMITS.
C
                  IGBS = IGBE + 1
                  IGBE = IGBE + LBOX1(ISPB2)
C
                  LBOX2(ISPB2) = LBOX2(ISPB2) + 1
                  IF (LBOX2(ISPB1).LT.IBMI(ISPB1)) GO TO 870
                  IF (LBOX2(ISPB2).GT.IBMA(ISPB2)) GO TO 870
C
C  MAKE GAP INFORMATION HERE.
C
                  IGBA = MAX(IB1+1,IGBS)
                  IF (LBOX1(ISPB2).EQ.0) THEN
                     ISTA = MSTA(ISPB2)
                     IEND = MSTA(ISPB2+1)-1
                  ELSEIF (ISPB2.EQ.ISPB1) THEN
                     ISTA = IO1+1
                     IEND = LCON(IGBA)-1
                     IF (IB1.EQ.IEBE) IEND=MSTA(ISPB1+1)-1
                  ELSE
                     ISTA = MSTA(ISPB2)
                     IEND = LCON(IGBA)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 860 IGAP=IGBA,IGBE+1
C
                     DO 850 JJ=ISTA,IEND
C
                     NB1EX = NB1EX + 1
C
C  ****** ALL THE WORK HAS TO BE DONE IN HERE. *******
C
  850             CONTINUE
C
                  ISTA = LCON(IGAP)+1
                  IEND = LCON(IGAP+1)-1
                  IF (IGAP.EQ.IGBE) IEND=MSTA(ISPB2+1)-1
  860             CONTINUE
C
  870             LBOX2(ISPB2) = LBOX2(ISPB2) - 1
  880          CONTINUE
C
  885          CONTINUE
C
               LBOX2(ISPB1) = LBOX2(ISPB1) + 1
  890       CONTINUE
C
            CALL MOVEUP2(LBOX1,NSPACE,NB,MSTA,LCON)
  900    CONTINUE
C
         CALL PUSHCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX3,IEND)
C
 1000 CONTINUE
C
      RETURN
      END 
C*MODULE ZCPRMC  *DECK FMDELT 
      SUBROUTINE FMDELT(INDEX,IOX,MSTA,NCOR,NACT,NUM,NQMT,NSPACE,
     *                  NROT,NOCAS,NDER)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION INDEX(NUM,NUM),IOX(NUM),MSTA(*)
      LOGICAL NOCAS
C
      NOCC = NCOR+NACT
      L3 = NUM*NUM
      CALL VICLR(INDEX,1,L3)
C
C     ----- Determine active-core rotation pairs -----
C
      IJ = -1
      DO 100 I=NCOR+1,NOCC
        IS1 = IOX(I)
        DO 80 J=1,NCOR
          IS2 = IOX(J)
          IF(IS1.NE.IS2 .AND. NDER.NE.2) GO TO 80
          INDEX(J,I) = IJ
          INDEX(I,J) = IABS(IJ)
          IJ = IJ - 1
   80   CONTINUE
  100 CONTINUE
C
C     ----- Determine virtual-occupied rotation pairs -----
C
      DO 200 I=NOCC+1,NQMT
        IS1 = IOX(I)
        DO 180 J=1,NOCC
          IS2 = IOX(J)
          IF(IS1.NE.IS2 .AND. NDER.NE.2) GO TO 180
          INDEX(J,I) = IJ
          INDEX(I,J) = IABS(IJ)
          IJ = IJ - 1
  180   CONTINUE
  200 CONTINUE
C
C     ----- If not a CAS wavefunction, we need to -----
C     -----    consider active-active rotations   -----
C
      IF(.NOT.NOCAS) GO TO 400
      DO 300 II=NSPACE,1,-1
        DO 250 JJ=1,II-1
          DO 240 I=MSTA(II),MSTA(II+1)-1
            IS1 = IOX(I)
            DO 220 J=MSTA(JJ),MSTA(JJ+1)-1
              IS2 = IOX(J)
              IF(IS1.NE.IS2 .AND. NDER.NE.2) GO TO 220
              INDEX(J,I) = IJ
              INDEX(I,J) = IABS(IJ)
              IJ = IJ - 1
  220       CONTINUE
  240     CONTINUE
  250   CONTINUE
  300 CONTINUE
C
  400 NROT = IABS(IJ) - 1 
C 
      RETURN
      END
C*MODULE ZCPRMC  *DECK TRLAG2 
      SUBROUTINE TRLAG2(BUFF,SALAG,TOPDM,TTPDM,IA,NCOR,NACT,NSTATS,
     *                  L1,L0,N2)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION BUFF(*),SALAG(L1,L1,NSTATS*NSTATS)
      DIMENSION TOPDM(NACT,NACT,NSTATS*NSTATS)
      DIMENSION TTPDM(N2,N2,NSTATS*NSTATS)
      DIMENSION IA(*)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      INTEGER         D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB
      LOGICAL         NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
      COMMON /TRFDMS/ D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB,
     *                NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
C
      PARAMETER (TWO=2.0D+00,FOUR=4.0D+00,HALF=0.5D+00)
C
      NOCC = NCOR+NACT
      NOTR = (NOCC*NOCC+NOCC)/2
      L3 = L1*L1
      NBVIR = L0 - NOCC
CTJD
CTJD      IF(MASWRK) THEN
CTJD        WRITE(IW,*) 'TR TPDM 1'
CAW         DO I=1,NSTATS*NSTATS
CTJD          CALL PRSQ(TTPDM(1,1,I),N2,N2,N2)
CAW         ENDDO
CTJD        CALL FLSHBF(IW)
CTJD      ENDIF
CTJD
      CALL DSCAL(N2*N2*NSTATS*NSTATS,HALF,TTPDM,1)
C
C     ----- Get (occ occ | occ occ) integrals -----
C 
      CALL DDI_DISTRIB(D_OOOO,ME,ILO,IHI,JLO,JHI)
      DO 1000 IJ=JLO,JHI
        DO II=1,NOCC
          DO JJ=1,II
            IJTMP = IA(II) + JJ
            IF(IJTMP.EQ.IJ) THEN
              I = II
              J = JJ
              GO TO 100
            ENDIF
          ENDDO
        ENDDO 
C
  100   CALL DDI_GET(D_OOOO,1,NOTR,IJ,IJ,BUFF)
C
        IF(I.LE.NCOR) THEN
          DO 200 K=1,NCOR
            KK = IA(K) + K
            DVAL1 = FOUR*BUFF(KK)
            JG = MAX(J,K)
            KG = MIN(J,K)
            JK = IA(JG) + KG
            DVAL2 = TWO*BUFF(JK)
            IF(I.NE.J) THEN
              IG = MAX(I,K)
              KG = MIN(I,K)
              IK = IA(IG) + KG
              DVAL3 =TWO*BUFF(IK) 
            ENDIF
            DO ISTAT=1,NSTATS
              IISTAT = (ISTAT-1)*NSTATS + ISTAT
              SALAG(I,J,IISTAT) = SALAG(I,J,IISTAT) + DVAL1
              SALAG(I,K,IISTAT) = SALAG(I,K,IISTAT) - DVAL2
              IF(I.NE.J) THEN
                SALAG(J,I,IISTAT) = SALAG(J,I,IISTAT) + DVAL1
                SALAG(J,K,IISTAT) = SALAG(J,K,IISTAT) - DVAL3
              ENDIF
            ENDDO
  200     CONTINUE
C
          DO 220 K=NCOR+1,NOCC
            KJ = IA(K) + J
            KI = IA(K) + I
            DINT1 = BUFF(KJ)
            IF(I.NE.J) DINT2 = BUFF(KI)
            DO 220 L=NCOR+1,NOCC
              DO 210 ISTAT=1,NSTATS
                DO 210 JSTAT=1,NSTATS
                  IJST = (ISTAT-1)*NSTATS + JSTAT
                  TDVAL = TOPDM(L-NCOR,K-NCOR,IJST)
                  SALAG(I,L,IJST) = SALAG(I,L,IJST) - DINT1*TDVAL
                  IF(I.NE.J) THEN
                    SALAG(J,L,IJST) = SALAG(J,L,IJST) - DINT2*TDVAL
                  ENDIF
  210         CONTINUE 
  220     CONTINUE
        ENDIF
C
        IF(I.GT.NCOR .AND. J.LE.NCOR) THEN 
          DO 400 K=1,NCOR
            KK = IA(K) + K
            DVAL1 = FOUR*BUFF(KK) 
            JG = MAX(J,K)
            KG = MIN(J,K)
            JK = IA(JG) + KG
            DVAL2 = TWO*BUFF(JK)
            DO ISTAT=1,NSTATS
              IISTAT = (ISTAT-1)*NSTATS + ISTAT
              SALAG(I,J,IISTAT) = SALAG(I,J,IISTAT) + DVAL1
              SALAG(I,K,IISTAT) = SALAG(I,K,IISTAT) - DVAL2
            ENDDO
C
            DVAL1 = DVAL1/TWO 
            DO 300 L=NCOR+1,NOCC
              DO 250 ISTAT=1,NSTATS
                DO 250 JSTAT=1,NSTATS
                  IJST = (ISTAT-1)*NSTATS + JSTAT
                  TDVAL = TOPDM(L-NCOR,I-NCOR,IJST)
                  SALAG(J,L,IJST) = SALAG(J,L,IJST) + TDVAL*DVAL1
  250         CONTINUE
  300       CONTINUE
C
            DO 380 L=NCOR+1,NOCC
              LK = IA(L) + K
              DVAL = BUFF(LK)
              DO 350 ISTAT=1,NSTATS
                DO 350 JSTAT=1,NSTATS
                  IJST = (ISTAT-1)*NSTATS + JSTAT
                  TDVAL = TOPDM(L-NCOR,I-NCOR,IJST)
                  SALAG(J,K,IJST) = SALAG(J,K,IJST) - TDVAL*DVAL
  350         CONTINUE
  380       CONTINUE
  400     CONTINUE        
C
          DO 500 K=NCOR+1,NOCC
            DO 500 L=NCOR+1,K
             KL = IA(K) + L 
             DVAL1 = TWO*BUFF(KL)
             KJ = IA(K) + J
             DVAL2 = BUFF(KJ)
             IF(K.NE.L) THEN
               LJ = IA(L) + J
               DVAL3 = BUFF(LJ)
             ENDIF 
             DO 450 ISTAT=1,NSTATS
               DO 450 JSTAT=1,NSTATS
                 IJST = (ISTAT-1)*NSTATS + JSTAT
                 TDVAL1 = TOPDM(K-NCOR,L-NCOR,IJST)
                 TDVAL2 = TOPDM(L-NCOR,K-NCOR,IJST)
                 SALAG(I,L,IJST) = SALAG(I,L,IJST) - DVAL2*TDVAL2
                 IF(K.NE.L) THEN
                    SALAG(I,K,IJST) = SALAG(I,K,IJST) - DVAL3*TDVAL1
                    TDVAL1 = TDVAL1 + TDVAL2
                 ENDIF
                 SALAG(I,J,IJST) = SALAG(I,J,IJST) + TDVAL1*DVAL1
  450        CONTINUE
  500     CONTINUE
        ENDIF 
C
        IF(J.GT.NCOR) THEN 
          DO 700 K=1,NCOR
            DO 700 L=1,K
              KL = IA(K) + L
              DINT = TWO*BUFF(KL)
              DO 600 ISTAT=1,NSTATS
                DO 600 JSTAT=1,NSTATS
                  IJST = (ISTAT-1)*NSTATS + JSTAT
                  TDVAL = TOPDM(I-NCOR,J-NCOR,IJST)
                  IF(I.NE.J) TDVAL = TDVAL + TOPDM(J-NCOR,I-NCOR,IJST)
                  DVAL = TDVAL*DINT
                  SALAG(K,L,IJST) = SALAG(K,L,IJST) + DVAL
                  IF(K.NE.L) SALAG(L,K,IJST) = SALAG(L,K,IJST) + DVAL       
  600         CONTINUE
  700     CONTINUE
C
          DO 900 K=1,NCOR
            KK = IA(K) + K
            DVAL1 = TWO*BUFF(KK)
            DO 800 L=NCOR+1,NOCC
              LK = IA(L) + K
              DVAL2 = BUFF(LK)
              DO 750 ISTAT=1,NSTATS
                DO 750 JSTAT=1,NSTATS
                  IJST = (ISTAT-1)*NSTATS + JSTAT
                  TDVAL = TOPDM(L-NCOR,J-NCOR,IJST)
                  SALAG(I,L,IJST) = SALAG(I,L,IJST) + DVAL1*TDVAL
                  SALAG(I,K,IJST) = SALAG(I,K,IJST) - DVAL2*TDVAL
                  IF(I.NE.J) THEN
                    TDVAL = TOPDM(L-NCOR,I-NCOR,IJST)
                    SALAG(J,L,IJST) = SALAG(J,L,IJST) + DVAL1*TDVAL
                    SALAG(J,K,IJST) = SALAG(J,K,IJST) - DVAL2*TDVAL
                  ENDIF
  750         CONTINUE
  800       CONTINUE
  900     CONTINUE
C
C         Two particle DM contribution to lagrangian
C
          II = I-NCOR
          JJ = J-NCOR
          IIJJ = IA(II) + JJ 
          DO 990 K=NCOR+1,NOCC
            KK = K-NCOR
            DO 930 L=1,NOCC
              KM = MAX(K,L)
              LM = MIN(K,L)
              KL = IA(KM) + LM
              DVAL = BUFF(KL)
              IF(I.NE.J) DVAL = TWO*DVAL
              DO 920 M=NCOR+1,NOCC
                KKM = MAX(KK,M-NCOR)
                MM = MIN(KK,M-NCOR)
                KM = IA(KKM) + MM
                DO 910 ISTAT=1,NSTATS
                  DO 910 JSTAT=1,NSTATS
                    IJST = (ISTAT-1)*NSTATS + JSTAT
                    TDVAL = TTPDM(IIJJ,KM,IJST)
                    SALAG(L,M,IJST) = SALAG(L,M,IJST) +
     *                                DVAL*TDVAL
  910           CONTINUE
  920         CONTINUE 
  930       CONTINUE
  990     CONTINUE
        ENDIF
C
 1000 CONTINUE 
C
C     ----- Get (vir occ | occ occ) integrals -----
C 
      CALL DDI_DISTRIB(D_VOOO,ME,ILO,IHI,JLO,JHI)
      DO 2000 JKL=JLO,JHI
        DO KK=1,NOCC
          DO LL=1,KK
            KL = IA(KK) + LL
            DO JJ=1,NOCC
              JKLTMP = (KL-1)*NOCC + JJ
              IF(JKL.EQ.JKLTMP) THEN
                J = JJ
                K = KK
                L = LL
                GO TO 1100
              ENDIF
            ENDDO
          ENDDO
        ENDDO
C
 1100   CALL DDI_GET(D_VOOO,1,NBVIR,JKL,JKL,BUFF)
        IF(J.GT.NCOR) GO TO 1700
        IF(K.GT.NCOR .AND. L.GT.NCOR) GO TO 1500
        IF(K.EQ.L) THEN
          DO 1200 I=NOCC+1,L0
            DVAL = FOUR*BUFF(I-NOCC)
            DO ISTAT=1,NSTATS
              IISTAT = (ISTAT-1)*NSTATS + ISTAT
              SALAG(I,J,IISTAT) = SALAG(I,J,IISTAT) + DVAL
            ENDDO
 1200     CONTINUE
        ENDIF
C
        IF(J.EQ.K) THEN
          DO 1300 I=NOCC+1,L0
            DVAL = TWO*BUFF(I-NOCC)
            DO ISTAT=1,NSTATS
              IISTAT = (ISTAT-1)*NSTATS + ISTAT
              SALAG(I,L,IISTAT) = SALAG(I,L,IISTAT) - DVAL
            ENDDO
 1300     CONTINUE
        ENDIF
C
        IF(J.EQ.L .AND. K.NE.L) THEN
          DO 1400 I=NOCC+1,L0
            DVAL = BUFF(I-NOCC)
            IF(K.LE.NCOR) THEN 
              DO ISTAT=1,NSTATS
                IISTAT = (ISTAT-1)*NSTATS + ISTAT
                SALAG(I,K,IISTAT) = SALAG(I,K,IISTAT) - TWO*DVAL
              ENDDO
            ELSE
              DO 1380 M=NCOR+1,NOCC
                DO 1350 ISTAT=1,NSTATS
                  DO 1350 JSTAT=1,NSTATS
                    IJST = (ISTAT-1)*NSTATS + JSTAT
                    TDVAL = TOPDM(M-NCOR,K-NCOR,IJST)
                    SALAG(I,M,IJST) = SALAG(I,M,IJST) - DVAL*TDVAL
 1350           CONTINUE
 1380         CONTINUE
            ENDIF
 1400     CONTINUE
        ENDIF
        GO TO 2000
C
 1500   CONTINUE
        DO 1600 I=NOCC+1,L0
          DVAL = TWO*BUFF(I-NOCC)
          DO 1550 ISTAT=1,NSTATS
            DO 1550 JSTAT=1,NSTATS
              IJST = (ISTAT-1)*NSTATS + JSTAT
              TDVAL = TOPDM(K-NCOR,L-NCOR,IJST)
              IF(K.NE.L) TDVAL = TDVAL + TOPDM(L-NCOR,K-NCOR,IJST)
              SALAG(I,J,IJST) = SALAG(I,J,IJST) + TDVAL*DVAL
 1550     CONTINUE
 1600   CONTINUE
        GO TO 2000
C
 1700   IF(K.NE.L) GO TO 1920 
        IF(K.LE.NCOR) THEN
          DO 1900 I=NOCC+1,L0
            DVAL = TWO*BUFF(I-NOCC)
            DO 1800 M=NCOR+1,NOCC
              DO 1750 ISTAT=1,NSTATS
                DO 1750 JSTAT=1,NSTATS
                  IJST = (ISTAT-1)*NSTATS + JSTAT
                  TDVAL = TOPDM(M-NCOR,J-NCOR,IJST)
                  SALAG(I,M,IJST) = SALAG(I,M,IJST) + DVAL*TDVAL
 1750         CONTINUE
 1800       CONTINUE
 1900     CONTINUE
        ENDIF
C
 1920   IF(L.GT.NCOR .OR. K.LE.NCOR) GO TO 1950 
        DO 1940 I=NOCC+1,L0
          DVAL = BUFF(I-NOCC)
          DO 1930 ISTAT=1,NSTATS
            DO 1930 JSTAT=1,NSTATS
              IJST = (ISTAT-1)*NSTATS + JSTAT
              TDVAL = TOPDM(K-NCOR,J-NCOR,IJST)
              SALAG(I,L,IJST) = SALAG(I,L,IJST) - DVAL*TDVAL 
 1930     CONTINUE
 1940   CONTINUE 
C
C         Two particle DM contribution to lagrangian
C
 1950   IF(K.LE.NCOR .OR. L.LE.NCOR) GO TO 2000
        JJ = J-NCOR
        KK = K-NCOR
        LL = L-NCOR
        KKLL = IA(KK) + LL
        DO 1980 I=NOCC+1,L0
          DVAL = BUFF(I-NOCC)
          IF(K.NE.L) DVAL = TWO*DVAL
          DO 1970 M=NCOR+1,NOCC
            JJM = MAX(JJ,M-NCOR)
            MM = MIN(JJ,M-NCOR)
            JM = IA(JJM) + MM
            DO 1960 ISTAT=1,NSTATS
              DO 1960 JSTAT=1,NSTATS
                IJST = (ISTAT-1)*NSTATS + JSTAT
                TDVAL = TTPDM(JM,KKLL,IJST)
                SALAG(I,M,IJST) = SALAG(I,M,IJST) + DVAL*TDVAL
 1960       CONTINUE
 1970     CONTINUE
 1980   CONTINUE 
 2000 CONTINUE
C       
      IF(GOPARR) CALL DDI_GSUMF(2174,SALAG,L3*NSTATS*NSTATS)
      CALL DSCAL(L3*NSTATS*NSTATS,TWO,SALAG,1)
C
      RETURN
      END
C*MODULE ZCPRMC  *DECK FMTDM2
      SUBROUTINE FMTDM2(Y,CI,TTPDM,LBOX1,LBOX5,IACON1,NAST,LSPA,LSYMA,
     *                  KTAB,IMMC,LBOX2,IOB,LGMUL,INDEX,IACON2,LBOX4,
     *                  LANDET,IBCON1,IPOSA,IPERA,IIND1,IIND2,IIND3,
     *                  IGROA,LGCOM,LDISB,LSBS,LBOX3,LSBC,IBCON2,NBST,
     *                  JB1GR,JB1PE,JB1IN,JB1PO,JB1ST,JB1IN2,LSPB,LSAS,
     *                  LSAC,LBNDET,LSYMB,NA,ITGA,IAST,NSYM,NACT,NX,
     *                  ITGB,JLO,JHI,NSTATS,NCI,N2,NB,IBST,NB1EX,IDIM1,
     *                  IDIM2)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL FDIRCT,QCORR,GOPARR,DSKWRK,MASWRK
C
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIM(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DIMENSION Y(NX),CI(NCI,NSTATS),TTPDM(N2,N2,NSTATS*NSTATS)
      DIMENSION LBOX1(NSPACE),LBOX5(NSPACE),IACON1(NA)
      DIMENSION NAST(ITGA+1),LSPA(IAST),LSYMA(IAST),KTAB(NSYM)
      DIMENSION IMMC(NSYM),LBOX2(NSPACE),IOB(NACT)
      DIMENSION LGMUL(NSYM,NSYM),INDEX(*),IACON2(NA),LBOX4(NSPACE)
      DIMENSION LANDET(NSPACE,ITGA),IBCON1(NA)
      DIMENSION IPOSA(NA*(NACT-NA),NSYM),IPERA(NA*(NACT-NA),NSYM)
      DIMENSION IIND1(NA*(NACT-NA),NSYM),IIND2(NA*(NACT-NA),NSYM)
      DIMENSION IIND3(NA*(NACT-NA),NSYM),IGROA(NA*(NACT-NA),NSYM)
      DIMENSION LGCOM(ITGB,ITGA),LDISB(NSYM,ITGB,ITGA)
      DIMENSION LSBS(NSYM+1,ITGB),LBOX3(NSPACE),LSBC(IBST)
      DIMENSION IBCON2(NA),NBST(ITGB+1),JB1GR(NB1EX),JB1PE(NB1EX)
      DIMENSION JB1IN(NB1EX),JB1PO(NB1EX),JB1ST(IDIM1,IDIM2)
      DIMENSION JB1IN2(NB1EX,2),LSPB(IBST),LSAS(NSYM+1,ITGA),LSAC(IAST)
      DIMENSION LBNDET(NSPACE,ITGB),LSYMB(IBST)
C
      PARAMETER (ONE=1.0D+00)
C
C  --- BIG LOOP OVER ALL ALPHA STRINGS. ---
C
      CALL RESETCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX5)
C
      DO 5000 IGA=1,ITGA
C
         CALL RESETDE(LBOX1,NSPACE,NA,MSTA,IACON1)
C
C  KKA GIVES THE ACTUAL POSITION OF THE ALPHA STRING IACON1 IN
C  THE FULL ALPHA STRING LIST.
C
         DO 4900 KKA=NAST(IGA)+1,NAST(IGA+1)
            JPZA1 = LSPA(KKA)
            JASYM = LSYMA(KKA)
            KSYM=KTAB(JASYM)
            DO II=1,NSYM
               IMMC(II)=0
            ENDDO
C
            DO II=1,NSPACE
               LBOX2(II) = LBOX1(II)
            ENDDO
C
C  LOOP OVER SPACES TO EXCITE ELECTRON FROM.
C
            IEAS = NA+1
            DO 4890 ISPA1=NSPACE,1,-1
               IOC1 = LBOX1(ISPA1)
               IEAE = IEAS - 1
               IEAS = IEAS - IOC1
               IF (IOC1.EQ.0) GO TO 4890
               LBOX2(ISPA1) = LBOX2(ISPA1)-1
C
C  LOOP ELECTRONS IN SPACE ISPA1.
C  IEAS, IEAE ARE THE ELECTRONS IN SPACE ISPA1.
C
               DO 4885 IA1=IEAE,IEAS,-1
                  IO1 = IACON1(IA1)
                  IGAE = IEAE - LBOX1(ISPA1)
                  IS1 = IOB(IO1)
C
C  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
C
               DO 4880 ISPA2=ISPA1,NSPACE
C
C  IGAS, IGAE ARE ELECTRONS SPECIFYING ISPA2 SPACE ELECTRON LIMITS.
C
                  IGAS = IGAE + 1
                  IGAE = IGAE + LBOX1(ISPA2)
C
                  LBOX2(ISPA2) = LBOX2(ISPA2) + 1
                  IF (LBOX2(ISPA1).LT.IAMI(ISPA1)) GO TO 4870
C
C  MAKE GAP INFORMATION HERE.
C
                  IGAA = MAX(IA1+1,IGAS)
                  IF (LBOX1(ISPA2).EQ.0) THEN
                     ISTA = MSTA(ISPA2)
                     IEND = MSTA(ISPA2+1)-1
                  ELSEIF (ISPA2.EQ.ISPA1) THEN
                     ISTA = IO1+1
                     IEND = IACON1(IGAA)-1
                     IF (IA1.EQ.IEAE) IEND=MSTA(ISPA1+1)-1
                  ELSE
                     ISTA = MSTA(ISPA2)
                     IEND = IACON1(IGAA)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 4860 IGAP=IGAA,IGAE+1
C
                     DO 4850 JJ=ISTA,IEND
                        IS2 = IOB(JJ)
                        IP1 = LGMUL(IS1,IS2)
C
                     IND = INDEX(JJ) + IO1
C
              CALL REDE00(IACON1,IACON2,NA,IA1,IGAP-1,JJ,JPERA)
              IF (LBOX2(ISPA2).GT.IAMA(ISPA2)) GO TO 4800
C
C  GET GROUP NUMBER
C
           CALL POSITCO(LBOX5,NSPACE,NA,IAMA,IAMI,LBOX4,LBOX2,IGA2)
           NIAS = NAST(IGA2)
C
              CALL IDPOST(IACON2,NA,LBOX2,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LANDET(1,IGA2),IBCON1,JPOSA)
              KAPOS = JPOSA + NIAS
              JPZA2 = LSPA(KAPOS)
              KASYM = LSYMA(KAPOS)
C              KPER1 = ((-1)**JPERA)*2
              KPER1 = (-1)**JPERA
              IMMC(KASYM) = IMMC(KASYM) + 1
              JSPO = IMMC(KASYM)
              IPOSA(JSPO,KASYM) = JPZA2
              IPERA(JSPO,KASYM) = KPER1
              IIND1(JSPO,KASYM) = IND
              IIND2(JSPO,KASYM) = IO1
              IIND3(JSPO,KASYM) = JJ
              IGROA(JSPO,KASYM) = IGA2
C
C   IF DEOCCUPIED AND NEWLY OCCUPIED ORBITALS ARE OF DIFFERENT SYMMETRY,
C   SKIP TO DOUBLES.
C
              IF (IS1.NE.IS2) GO TO 4800
C
C  LOOP OVER APPROPRIATE BETA DETS
C
              DO 1700 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB,IGA2).NE.1) GOTO 1700
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
              JCI2 = JPZA2 + LDISB(KSYM,IGB,IGA2)
C
              DO 1680 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 JCI1 = JCI1 + 1
                 JCI2 = JCI2 + 1
                 FC = KPER1
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                 ENDIF
C
                 IF(JCI2.GE.JLO .AND. JCI2.LE.JHI) THEN
                 ENDIF
C
 1680         CONTINUE
C
 1700         CONTINUE
C
C   DETERMINE THE ALPHA STRING CONTRIBUTION TO THE MATRIX ELEMENT.
C
              DO 4712 IK=1,NA
                 IF (IK.EQ.IA1) GO TO 4712
                 ION = IACON1(IK)
                 J1 = INDEX(ION+1)
                 JMA = MAX(J1,IND)
                 JMI = MIN(J1,IND)
                 JMA = MAX(ION,JJ)
                 JMI = MIN(ION,JJ)
                 J2 = INDEX(JMA)+JMI
                 JMA = MAX(IO1,ION)
                 JMI = MIN(IO1,ION)
                 J3 = INDEX(JMA)+JMI
                 JMA = MAX(J2,J3)
                 JMI = MIN(J2,J3)
C
C  LOOP OVER APPROPRIATE BETA DETS
C
              DO 1705 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB,IGA2).NE.1) GOTO 1705
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
              JCI2 = JPZA2 + LDISB(KSYM,IGB,IGA2)
C
              DO 1685 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 JCI1 = JCI1 + 1
                 JCI2 = JCI2 + 1
                 FC = KPER1
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   CALL TDM2FM(TTPDM,CI,INDEX,FC,JCI1,JCI2,IO1,JJ,
     *                         ION,ION,NSTATS,NCI,N2)
                   CALL TDM2FM(TTPDM,CI,INDEX,-FC,JCI1,JCI2,IO1,ION,
     *                         JJ,ION,NSTATS,NCI,N2)
                 ENDIF
C
                 IF(JCI2.GE.JLO .AND. JCI2.LE.JHI) THEN
                   CALL TDM2FM(TTPDM,CI,INDEX,FC,JCI2,JCI1,IO1,JJ,
     *                         ION,ION,NSTATS,NCI,N2)
                   CALL TDM2FM(TTPDM,CI,INDEX,-FC,JCI2,JCI1,IO1,ION,
     *                         JJ,ION,NSTATS,NCI,N2)
                 ENDIF
C
 1685         CONTINUE
C
 1705         CONTINUE
C
 4712         CONTINUE
C
C  LOOP OVER BETA DETS OF THE RIGHT GROUP AND SYMMETRY.
C
              CALL RESETCO(LBOX3,NSPACE,NB,IBMA,IBMI,LBOX4)
C
              DO 4700 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB,IGA2).NE.1) GOTO 4690
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
              JCI2 = JPZA2 + LDISB(KSYM,IGB,IGA2)
C
              CALL RESETDE(LBOX3,NSPACE,NB,MSTA,IBCON1)
              ISTB = 1
              DO 4680 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 IENB = LSBC(KKB)
                 DO IIZ=ISTB,IENB-1
                    CALL MOVEUP2(LBOX3,NSPACE,NB,MSTA,IBCON1)
                 ENDDO
                 ISTB = IENB
                 JCI1 = JCI1 + 1
                 JCI2 = JCI2 + 1
                 FC = KPER1
C
                 DO 4670 IK=1,NB
                    ION = IBCON1(IK)
                    J1 = INDEX(ION+1)
                    JMA = MAX(J1,IND)
                    JMI = MIN(J1,IND)
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   CALL TDM2FM(TTPDM,CI,INDEX,FC,JCI1,JCI2,IO1,JJ,
     *                         ION,ION,NSTATS,NCI,N2)
                 ENDIF
C
                 IF(JCI2.GE.JLO .AND. JCI2.LE.JHI) THEN
                   CALL TDM2FM(TTPDM,CI,INDEX,FC,JCI2,JCI1,IO1,JJ,
     *                         ION,ION,NSTATS,NCI,N2)
                 ENDIF
C
 4670            CONTINUE
C
 4680         CONTINUE
C
 4690         CALL PUSHCO(LBOX3,NSPACE,NB,IBMA,IBMI,LBOX4,IEND)
 4700         CONTINUE
C
C --  DOUBLE ALPHA EXCITATIONS START HERE  ---
C
 4800         CONTINUE
C
            IF (IA1.EQ.NA) GOTO 4850
            IF (JJ.EQ.NACT) GOTO 4850
C
            DO II=1,NSPACE
               LBOX3(II) = LBOX2(II)
            ENDDO
            IAES3 = 1
            DO KK=1,ISPA1-1
               IAES3 = IAES3 + LBOX2(KK)
            ENDDO
C
C  LOOP OVER SPACES TO EXCITE ELECTRONS FROM, MUST BE GE THAN
C  SPACE OF FIRST EXCITATION, ISPA1.
C
            DO 3890 ISPA3 = ISPA1,NSPACE
               IF (LBOX1(ISPA3).EQ.0) GOTO 3887
               IF (ISPA3.EQ.ISPA1.AND.IA1.EQ.IEAE) GOTO 3887
               IOC3 = LBOX2(ISPA3)
               IF (IOC3.EQ.0) GOTO 3887
C
               IAEE3 = IAES3 + LBOX2(ISPA3)-1
               LBOX3(ISPA3) = LBOX3(ISPA3)-1
C
C  LOOP OVER ELECTRONS IN ISPA3, WHICH ARE LARGER THAN IA1,
C  MAKING SURE IT ISN'T THE ALREADY EXCITED ELECTRON.
C
               JSTA3 = IAES3
               IF (ISPA3.EQ.ISPA1) THEN
                  JSTA3=IA1
                  IF (IGAP-1.EQ.IA1) JSTA3=JSTA3+1
               ENDIF
C
               DO 3880 IA3=JSTA3,IAEE3
                  IF (IA3.EQ.IGAP-1) GOTO 3880
                  IO3 = IACON2(IA3)
                  IS3 = IOB(IO3)
C
C  LOOP OVER SPACES TO EXCITE ELECTRON INTO.  MUST BE GE THAN
C  SPACE FIRST ELECTRON WAS EXCITED INTO.
C
                  IGAE3 = 0
                  DO JIK=1,ISPA2-1
                     IGAE3 = IGAE3 + LBOX2(JIK)
                  ENDDO
                  DO 3850 ISPA4=ISPA2,NSPACE
C
C  IGAS3, IGAE3 ARE ELECTRONS SPECIFYING ISPA4 SPACE ELECTRON LIMITS.
C
                  LBOX3(ISPA4) = LBOX3(ISPA4) + 1
                  IGAS3 = IGAE3 + 1
                  IGAE3 = IGAE3 + LBOX2(ISPA4)
                  IF (LBOX3(ISPA3).LT.IAMI(ISPA3)) GOTO 3840
                  IF (LBOX3(ISPA4).GT.IAMA(ISPA4)) GOTO 3840
             IF (ISPA4.EQ.ISPA2.AND.JJ.EQ.MSTA(ISPA2+1)-1) GOTO 3840
C
C  GET GROUP NUMBER
C
               CALL POSITCO(LBOX5,NSPACE,NA,IAMA,IAMI,LBOX4,LBOX3,IGA3)
               NIAS3 = NAST(IGA3)
C
C  MAKE GAP INFORMATION HERE.
C
                  IGAA3 = MAX(IGAS3,IGAP)
C
                  IF (LBOX2(ISPA4).EQ.0) THEN
                     ISTA3 = MSTA(ISPA4)
                     IEND3 = MSTA(ISPA4+1)-1
                  ELSEIF (ISPA4.EQ.ISPA2) THEN
                     ISTA3 = JJ+1
                     IEND3 = IACON2(IGAA3)-1
C
C  I AM SUSPECT ABOUT THIS NEXT LINE, WE'LL SEE WHAT HAPPENS.......
C
                     IF (IGAP-1.EQ.IGAE3) IEND3=MSTA(ISPA2+1)-1
C
                  ELSE
                     ISTA3 = MSTA(ISPA4)
                     IEND3 = IACON2(IGAA3)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 3830 IGAP3=IGAA3,IGAE3+1
C
                     DO 3820 JJ3=ISTA3,IEND3
                        IS4 = IOB(JJ3)
                        IP2 = LGMUL(IS3,IS4)
                        IF (IP1.NE.IP2) GOTO 3820
C
              CALL REDE00(IACON2,IBCON1,NA,IA3,IGAP3-1,JJ3,JPERA3)
              CALL IDPOST(IBCON1,NA,LBOX3,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LANDET(1,IGA3),IBCON2,JPOSA3)
C              IPER3 = ((-1)**(JPERA3+JPERA))*2
              IPER3 = (-1)**(JPERA3+JPERA)
              KAPOS3 = JPOSA3 + NIAS3
              JPZA3 = LSPA(KAPOS3)
                 JMA=MAX(JJ3,IO3)
                 JMI=MIN(JJ3,IO3)
                 I2 = INDEX(JMA) + JMI
                 II1 = INDEX(JJ3) + IO1
                 JMA=MAX(IO3,JJ)
                 JMI=MIN(IO3,JJ)
                 II2 = INDEX(JMA) + JMI
                 JMA=MAX(II1,II2)
                 JMI=MIN(II1,II2)
C
C
C  LOOP OVER BETA STRINGS OF RIGHT SYMMETRY AND GROUP.
C
              DO 3700 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB,IGA3).NE.1) GOTO 3700
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
              JCI3 = JPZA3 + LDISB(KSYM,IGB,IGA3)
C
              DO 3680 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 JCI1 = JCI1 + 1
                 JCI3 = JCI3 + 1
                 FC = IPER3
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   CALL TDM2FM(TTPDM,CI,INDEX,FC,JCI1,JCI3,IO1,JJ,
     *                         JJ3,IO3,NSTATS,NCI,N2)
                   CALL TDM2FM(TTPDM,CI,INDEX,-FC,JCI1,JCI3,IO1,JJ3,
     *                         JJ,IO3,NSTATS,NCI,N2)
                 ENDIF
C
                 IF(JCI3.GE.JLO .AND. JCI3.LE.JHI) THEN
                   CALL TDM2FM(TTPDM,CI,INDEX,FC,JCI3,JCI1,IO1,JJ,
     *                         JJ3,IO3,NSTATS,NCI,N2)
                   CALL TDM2FM(TTPDM,CI,INDEX,-FC,JCI3,JCI1,IO1,JJ3,
     *                         JJ,IO3,NSTATS,NCI,N2)
                 ENDIF
C
 3680         CONTINUE
C
 3700         CONTINUE
C
 3820                CONTINUE
C
                     ISTA3 = IACON2(IGAP3)+1
                     IEND3 = IACON2(IGAP3+1)-1
                     IF (IGAP3.EQ.IGAE3) IEND3=MSTA(ISPA4+1)-1
 3830             CONTINUE
C
 3840             LBOX3(ISPA4) = LBOX3(ISPA4) - 1
 3850             CONTINUE
C
 3880          CONTINUE
C
               LBOX3(ISPA3) = LBOX3(ISPA3)+1
 3887          IAES3 = IAES3 + LBOX3(ISPA3)
 3890       CONTINUE
C
 4850                CONTINUE
C
                  ISTA = IACON1(IGAP)+1
                  IEND = IACON1(IGAP+1)-1
                  IF (IGAP.EQ.IGAE) IEND=MSTA(ISPA2+1)-1
 4860             CONTINUE
C
 4870             LBOX2(ISPA2) = LBOX2(ISPA2) - 1
 4880          CONTINUE
C
 4885          CONTINUE
C
               LBOX2(ISPA1) = LBOX2(ISPA1)+1
 4890       CONTINUE
C
C  DIAGONAL ELEMENTS HERE
C
            DO 67 II=1,NA
               I1 = IACON1(II)
               IND1 = INDEX(I1+1)
C
C  LOOP OVER BETA STRINGS OF RIGHT SYMMETRY AND GROUP.
C
              DO 3705 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1) GOTO 3705
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
C
              DO 3685 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 JCI1 = JCI1 + 1
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                 ENDIF
C
 3685         CONTINUE
C
 3705         CONTINUE
C
              DO 64 JJ=II+1,NA
                 I2 = IACON1(JJ)
                 IND2 = INDEX(I2+1)
                 INDM = IND2 - I2 + I1
                 J1 = INDEX(INDM+1)
                 J2 = INDEX(IND2) + IND1
C
              DO 3710 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1) GOTO 3710
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
C
              DO 3690 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                JCI1 = JCI1 + 1
                FC = IPER3
C
                IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                  CALL TDM2FM(TTPDM,CI,INDEX,ONE,JCI1,JCI1,I1,I1,
     *                        I2,I2,NSTATS,NCI,N2)
                  CALL TDM2FM(TTPDM,CI,INDEX,-ONE,JCI1,JCI1,I1,I2,
     *                        I1,I2,NSTATS,NCI,N2)
                ENDIF
C
 3690         CONTINUE
C
 3710         CONTINUE
C
   64         CONTINUE
C
C  LOOP OVER BETA DETS OF THE RIGHT GROUP AND SYMMETRY.
C
              CALL RESETCO(LBOX3,NSPACE,NB,IBMA,IBMI,LBOX4)
C
              DO 4709 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1) GOTO 4699
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
C
              CALL RESETDE(LBOX3,NSPACE,NB,MSTA,IBCON1)
              ISTB = 1
              DO 4689 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 IENB = LSBC(KKB)
                 DO IIZ=ISTB,IENB-1
                    CALL MOVEUP2(LBOX3,NSPACE,NB,MSTA,IBCON1)
                 ENDDO
                 ISTB = IENB
                 JCI1 = JCI1 + 1
                 IF(JCI1.LT.JLO .OR. JCI1.GT.JHI) GO TO 4689
C
                 DO 4679 IK=1,NB
                    I2 = IBCON1(IK)
                    IND2 = INDEX(I2+1)
                    JMI = MIN(IND1,IND2)
                    JMA = MAX(IND1,IND2)
                    J2 = INDEX(JMA) + JMI
C
                  CALL TDM2FM(TTPDM,CI,INDEX,ONE,JCI1,JCI1,I1,I1,
     *                        I2,I2,NSTATS,NCI,N2)
C
 4679            CONTINUE
C
 4689         CONTINUE
C
 4699         CALL PUSHCO(LBOX3,NSPACE,NB,IBMA,IBMI,LBOX4,IEND)
 4709         CONTINUE
C
   67       CONTINUE
C
C  --- END OF LOOP OVER SINGLE ALPHA EXCITATIONS. ---
C      NOW TO SORT THEM BY POSITIONS WITHIN SYMMETRIES.
C
            DO II=1,NSYM
               CALL FCPSRT3(IGROA(1,II),IPERA(1,II),IIND1(1,II),
     *                   IPOSA(1,II),IMMC(II),IIND2(1,II),IIND3(1,II))
            ENDDO
C
C  --- END OF LOOP OVER PURE ALPHA EXCITATIONS.
C  NOW TO LOOP OVER ALL SIMULTANEOUS AB -> A'B' EXCITATIONS.
C
      IF (NSPACE.EQ.1) GOTO 3400
C
C  ***** GENERAL CASE OF MORE THAN ONE SPACE !!!!! *******
C
      IF (.NOT.FDIRCT) THEN
C
C  LOOP OVER SINGLE ALPHA EXCITES WITHIN EACH SYMMETRY.
C
      DO 3000 ISAE=1,NSYM
         KBSYM=KTAB(ISAE)
         DO 2900 JSAE=1,IMMC(ISAE)
            JPOSAE=IPOSA(JSAE,ISAE)
            JPERAE=IPERA(JSAE,ISAE)
            JINDAE=IIND1(JSAE,ISAE)
            JGROAE=IGROA(JSAE,ISAE)
C
            IXI = IIND2(JSAE,ISAE)
            IXJ = IIND3(JSAE,ISAE)
C
C
C  IF ISAE.EQ.JASYM THEN SPECIAL CASE.
C
       IF (ISAE.EQ.JASYM.AND.IGA.EQ.JGROAE) THEN
C
C  LOOP OVER ALL RELEVANT BETAS
C
            LABPOS = JPZA1
            LABPOS2 = JPOSAE
            DO 2813 IGB=1,ITGB
               IF (LGCOM(IGB,IGA).NE.1) GOTO 2813
               NIBS = NBST(IGB)
               DO 2763 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                  LABPOS = LABPOS + 1
                  LABPOS2 = LABPOS2 + 1
                  IBPOS = NIBS + LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2613 JBINDX=JB1ST(KBSYM,IBPOS),JB1ST(KBSYM+1,IBPOS)-1
                  IGB2=JB1GR(JBINDX)
                  IF (LGCOM(IGB2,JGROAE).NE.1) GOTO 2613
C
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  JCIB=JPOSAE+LDISB(KBSYM,IGB2,JGROAE)+JB1PO(JBINDX)
                  JCIB2=JPZA1+LDISB(KBSYM,IGB2,JGROAE)+JB1PO(JBINDX)
C
                  FC = JPERAE*JB1PE(JBINDX)
                  IXK = JB1IN2(JBINDX,1)
                  IXL = JB1IN2(JBINDX,2)
CAW2                  IVAL = JB1IN(JBINDX)
C
                  IF(LABPOS.GE.JLO .AND. LABPOS.LE.JHI) THEN
                    CALL TDM2FM(TTPDM,CI,INDEX,FC,LABPOS,JCIB,IXI,IXJ,
     *                          IXK,IXL,NSTATS,NCI,N2)
                  ENDIF
C
                  IF(JCIB.GE.JLO .AND. JCIB.LE.JHI) THEN
                    CALL TDM2FM(TTPDM,CI,INDEX,FC,JCIB,LABPOS,IXI,IXJ,
     *                          IXK,IXL,NSTATS,NCI,N2)
                  ENDIF
C
                  IF(LABPOS2.GE.JLO .AND. LABPOS2.LE.JHI) THEN
                    CALL TDM2FM(TTPDM,CI,INDEX,FC,LABPOS2,JCIB2,IXI,
     *                          IXJ,IXK,IXL,NSTATS,NCI,N2)
                  ENDIF
C
                  IF(JCIB2.GE.JLO .AND. JCIB2.LE.JHI) THEN
                    CALL TDM2FM(TTPDM,CI,INDEX,FC,JCIB2,LABPOS2,IXI,
     *                          IXJ,IXK,IXL,NSTATS,NCI,N2)
                  ENDIF
C
 2613          CONTINUE
C
 2763          CONTINUE
 2813       CONTINUE
C
       ELSE
C
C  LOOP OVER ALL RELEVANT (A-)BETA DETS.
C
            LABPOS = JPZA1
            DO 2800 IGB=1,ITGB
               IF (LGCOM(IGB,IGA).NE.1) GOTO 2800
               NIBS = NBST(IGB)
               DO 2750 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                  LABPOS = LABPOS + 1
                  IBPOS = NIBS + LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2600 JBINDX=JB1ST(KBSYM,IBPOS),JB1ST(KBSYM+1,IBPOS)-1
                  IGB2=JB1GR(JBINDX)
                  IF (LGCOM(IGB2,JGROAE).NE.1) GOTO 2600
C
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  JCIB=JPOSAE+LDISB(KBSYM,IGB2,JGROAE)+JB1PO(JBINDX)
C
                  FC = JPERAE*JB1PE(JBINDX)
                  IXK = JB1IN2(JBINDX,1)
                  IXL = JB1IN2(JBINDX,2)
CAW2                  IVAL = JB1IN(JBINDX)
C
                  IF(LABPOS.GE.JLO .AND. LABPOS.LE.JHI) THEN
                    CALL TDM2FM(TTPDM,CI,INDEX,FC,LABPOS,JCIB,IXI,IXJ,
     *                          IXK,IXL,NSTATS,NCI,N2)
                  ENDIF
C
                  IF(JCIB.GE.JLO .AND. JCIB.LE.JHI) THEN
                    CALL TDM2FM(TTPDM,CI,INDEX,FC,JCIB,LABPOS,IXI,IXJ,
     *                          IXK,IXL,NSTATS,NCI,N2)
                  ENDIF
C
 2600          CONTINUE
C
 2750          CONTINUE
 2800       CONTINUE
C
C  LOOP OVER ALL RELEVANT (A'-)BETA DETS.
C
            LABPOS = JPOSAE
            DO 2803 IGB=1,ITGB
               IF (LGCOM(IGB,JGROAE).NE.1) GOTO 2803
               NIBS = NBST(IGB)
               DO 2753 KKB=LSBS(KBSYM,IGB),LSBS(KBSYM+1,IGB)-1
                  LABPOS = LABPOS + 1
                  IBPOS = NIBS + LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2603 JBINDX=JB1ST(KSYM,IBPOS),JB1ST(KSYM+1,IBPOS)-1
                  IGB2=JB1GR(JBINDX)
                  IF (LGCOM(IGB2,IGA).NE.1) GOTO 2603
C
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  JCIB=JPZA1+LDISB(KSYM,IGB2,IGA)+JB1PO(JBINDX)
C
                  FC = JPERAE*JB1PE(JBINDX)
                  IXK = JB1IN2(JBINDX,1)
                  IXL = JB1IN2(JBINDX,2)
CAW2                  IVAL = JB1IN(JBINDX)
C
                  IF(LABPOS.GE.JLO .AND. LABPOS.LE.JHI) THEN
                    CALL TDM2FM(TTPDM,CI,INDEX,FC,LABPOS,JCIB,IXI,IXJ,
     *                          IXK,IXL,NSTATS,NCI,N2)
                  ENDIF
C
                  IF(JCIB.GE.JLO .AND. JCIB.LE.JHI) THEN
                    CALL TDM2FM(TTPDM,CI,INDEX,FC,JCIB,LABPOS,IXI,IXJ,
     *                          IXK,IXL,NSTATS,NCI,N2)
                  ENDIF
C
 2603          CONTINUE
C
 2753          CONTINUE
 2803       CONTINUE
C
      ENDIF
C
 2900    CONTINUE
 3000 CONTINUE
C
      ELSE
C
C  ***** DIRECT METHOD BELOW *****
C
      DO 4000 ISAE=1,NSYM
         KBSYM = KTAB(ISAE)
C
C  ANALYSE EXCITED A' GROUPS FOR COMPATIBILITY WITH B.
C
      NGRPS = 0
      DO 1976 II=1,IMMC(ISAE)
         ICGR = IGROA(II,ISAE)
         DO JJ=1,NGRPS
            IF (JB1GR(JJ).EQ.ICGR) GOTO 1976
         ENDDO
         NGRPS = NGRPS + 1
         JB1GR(NGRPS) = ICGR
 1976 CONTINUE
C
C FIRST TYPE OF BETAS, KSYM -> KBSYM
C
          CALL RESETCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3)
          DO 7400 IGB=1,ITGB
             IF (LGCOM(IGB,IGA).NE.1) GOTO 7399
             LAB1 = JPZA1 + LDISB(KSYM,IGB,IGA)
C
             CALL RESETDE(LBOX2,NSPACE,NB,MSTA,IBCON1)
             NIBS = NBST(IGB)
             ISTB = 1
             DO 7300 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                IENB = LSBC(KKB)
                DO IIZ=ISTB,IENB-1
                   CALL MOVEUP2(LBOX2,NSPACE,NB,MSTA,IBCON1)
                ENDDO
                ISTB = IENB
C
                IBPOS = NIBS + LSBC(KKB)
                LABPOS = LAB1 + LSPB(IBPOS)
C
C LOOP OVER SINGLE BETA EXCITES FROM IBPOS WHICH ARE OF SYMMETRY KBSYM
C
                MESYM1 = LGMUL(KSYM,KBSYM)
                DO II=1,NSPACE
                   LBOX3(II) = LBOX2(II)
                ENDDO
                IEBS = NB + 1
                DO 7290 ISPB1=NSPACE,1,-1
                   IOC1 = LBOX2(ISPB1)
                   IEBE = IEBS - 1
                   IEBS = IEBS - IOC1
                   IF (IOC1.EQ.0) GO TO 7290
                   LBOX3(ISPB1) = LBOX3(ISPB1)-1
C
C  LOOP ELECTRONS IN SPACE ISPB1
C  IEBS, IEBE ARE THE ELECTRONS IN SPACE ISPB1
C
                DO 7285 IB1 = IEBE,IEBS,-1
                   IO1 = IBCON1(IB1)
                   MESYM2 = LGMUL(MESYM1,IOB(IO1))
                   IGBE = IEBE - LBOX2(ISPB1)
C
C  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
C
                DO 7280 ISPB2=ISPB1,NSPACE
C
C  IGBS,IGBE ARE ELECTRONS SPECIFYING ISPB2 SPACE ELECTRON LIMITS.
C
                   IGBS = IGBE + 1
                   IGBE = IGBE + LBOX2(ISPB2)
C
                   LBOX3(ISPB2) = LBOX3(ISPB2) + 1
                   IF (LBOX3(ISPB1).LT.IBMI(ISPB1)) GO TO 7270
                   IF (LBOX3(ISPB2).GT.IBMA(ISPB2)) GO TO 7270
C
C  GET GROUP NUMBER
C
          CALL POSITCO(LBOX5,NSPACE,NB,IBMA,IBMI,LBOX4,LBOX3,IGB2)
          NIAS = NBST(IGB2)
C
C CHECK FOR A' GROUP COMPATIBILITY
C
             DO II=1,NGRPS
                IAGRP = JB1GR(II)
                IF (LGCOM(IGB2,IAGRP).EQ.1) GOTO 7555
             ENDDO
             GOTO 7270
 7555        CONTINUE
C
C  MAKE GAP INFORMATION HERE.
C
                  IGBA = MAX(IB1+1,IGBS)
                  IF (LBOX2(ISPB2).EQ.0) THEN
                     ISTA = MSTA(ISPB2)
                     IEND = MSTA(ISPB2+1)-1
                  ELSEIF (ISPB2.EQ.ISPB1) THEN
                     ISTA = IO1+1
                     IEND = IBCON1(IGBA)-1
                     IF (IB1.EQ.IEBE) IEND=MSTA(ISPB1+1)-1
                  ELSE
                     ISTA = MSTA(ISPB2)
                     IEND = IBCON1(IGBA)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 7260 IGAP=IGBA,IGBE+1
C
                     DO 7250 JJ=ISTA,IEND
C
C CHECK TO SEE IF EXCITED BETA IS OF RIGHT SYMMETRY (KBSYM)
C
            IF (IOB(JJ).NE.MESYM2) GOTO 7250
C
            IND1 = INDEX(JJ) + IO1
            CALL REDE00(IBCON1,IBCON2,NB,IB1,IGAP-1,JJ,IPER)
            CALL IDPOST(IBCON2,NB,LBOX3,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LBNDET(1,IGB2),IACON2,IPOSB)
            JB1P = LSPB(IPOSB + NIAS)
C
            DO 3900 JSAE=1,IMMC(ISAE)
               JGROAE=IGROA(JSAE,ISAE)
               IF (LGCOM(IGB2,JGROAE).NE.1) GOTO 3900
C
               JPOSAE=IPOSA(JSAE,ISAE)
               JCIB = JB1P + JPOSAE + LDISB(KBSYM,IGB2,JGROAE)
C
               JINDAE=IIND1(JSAE,ISAE)
               JMA=MAX(JINDAE,IND1)
               JMI=MIN(JINDAE,IND1)
C
               JPERAE=IPERA(JSAE,ISAE)
 3900       CONTINUE
C
 7250                CONTINUE
C
                  ISTA = IBCON1(IGAP)+1
                  IEND = IBCON1(IGAP+1)-1
                  IF (IGAP.EQ.IGBE) IEND=MSTA(ISPB2+1)-1
 7260             CONTINUE
C
 7270              LBOX3(ISPB2) = LBOX3(ISPB2) - 1
 7280           CONTINUE
C
 7285           CONTINUE
C
                   LBOX3(ISPB1) = LBOX3(ISPB1) + 1
 7290           CONTINUE
C
 7300        CONTINUE
C
 7399        CALL PUSHCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3,IEND)
 7400     CONTINUE
C
C
C SECOND TYPE OF BETAS, KBSYM -> KSYM
C
          CALL RESETCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3)
          DO 7801 IGB=1,ITGB
C
C CHECK FOR A' GROUP COMPATIBILITY
C
             DO II=1,NGRPS
                IAGRP = JB1GR(II)
                IF (LGCOM(IGB,IAGRP).EQ.1) GOTO 7655
             ENDDO
             GOTO 7799
 7655        CONTINUE
C
             CALL RESETDE(LBOX2,NSPACE,NB,MSTA,IBCON1)
             NIBS = NBST(IGB)
             ISTB = 1
C
             DO 7701 KKB=LSBS(KBSYM,IGB),LSBS(KBSYM+1,IGB)-1
                IENB = LSBC(KKB)
                DO IIZ=ISTB,IENB-1
                   CALL MOVEUP2(LBOX2,NSPACE,NB,MSTA,IBCON1)
                ENDDO
                ISTB = IENB
C
                IBPOS = NIBS + LSBC(KKB)
                LAB1 = LSPB(IBPOS)
C
C LOOP OVER SINGLE BETA EXCITES FROM IBPOS WHICH ARE OF SYMMETRY KSYM
C
                MESYM1 = LGMUL(KSYM,KBSYM)
                DO II=1,NSPACE
                   LBOX3(II) = LBOX2(II)
                ENDDO
                IEBS = NB + 1
                DO 7691 ISPB1=NSPACE,1,-1
                   IOC1 = LBOX2(ISPB1)
                   IEBE = IEBS - 1
                   IEBS = IEBS - IOC1
                   IF (IOC1.EQ.0) GO TO 7691
                   LBOX3(ISPB1) = LBOX3(ISPB1)-1
C
C  LOOP ELECTRONS IN SPACE ISPB1
C  IEBS, IEBE ARE THE ELECTRONS IN SPACE ISPB1
C
                DO 7686 IB1 = IEBE,IEBS,-1
                   IO1 = IBCON1(IB1)
                   MESYM2 = LGMUL(MESYM1,IOB(IO1))
                   IGBE = IEBE - LBOX2(ISPB1)
C
C  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
C
                DO 7681 ISPB2=ISPB1,NSPACE
C
C  IGBS,IGBE ARE ELECTRONS SPECIFYING ISPB2 SPACE ELECTRON LIMITS.
C
                   IGBS = IGBE + 1
                   IGBE = IGBE + LBOX2(ISPB2)
C
                   LBOX3(ISPB2) = LBOX3(ISPB2) + 1
                   IF (LBOX3(ISPB1).LT.IBMI(ISPB1)) GO TO 7671
                   IF (LBOX3(ISPB2).GT.IBMA(ISPB2)) GO TO 7671
C
          CALL POSITCO(LBOX5,NSPACE,NB,IBMA,IBMI,LBOX4,LBOX3,IGB2)
          IF (LGCOM(IGB2,IGA).NE.1) GOTO 7671
          JCIBS = JPZA1 + LDISB(KSYM,IGB2,IGA)
          NIAS = NBST(IGB2)
C
C  MAKE GAP INFORMATION HERE.
C
                  IGBA = MAX(IB1+1,IGBS)
                  IF (LBOX2(ISPB2).EQ.0) THEN
                     ISTA = MSTA(ISPB2)
                     IEND = MSTA(ISPB2+1)-1
                  ELSEIF (ISPB2.EQ.ISPB1) THEN
                     ISTA = IO1+1
                     IEND = IBCON1(IGBA)-1
                     IF (IB1.EQ.IEBE) IEND=MSTA(ISPB1+1)-1
                  ELSE
                     ISTA = MSTA(ISPB2)
                     IEND = IBCON1(IGBA)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 7660 IGAP=IGBA,IGBE+1
C
                     DO 7650 JJ=ISTA,IEND
C
C CHECK TO SEE IF EXCITED BETA IS OF RIGHT SYMMETRY (KBSYM)
C
            IF (IOB(JJ).NE.MESYM2) GOTO 7650
C
            IND1 = INDEX(JJ) + IO1
            CALL REDE00(IBCON1,IBCON2,NB,IB1,IGAP-1,JJ,IPER)
            CALL IDPOST(IBCON2,NB,LBOX3,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LBNDET(1,IGB2),IACON2,IPOSB)
            JCIB= JCIBS + LSPB(IPOSB + NIAS)
C
            DO 4300 JSAE=1,IMMC(ISAE)
               JGROAE=IGROA(JSAE,ISAE)
               IF (LGCOM(IGB,JGROAE).NE.1) GOTO 4300
C
               JPOSAE=IPOSA(JSAE,ISAE)
               LABPOS = LAB1 + JPOSAE + LDISB(KBSYM,IGB,JGROAE)
C
               JINDAE=IIND1(JSAE,ISAE)
               JMA=MAX(JINDAE,IND1)
               JMI=MIN(JINDAE,IND1)
C
               JPERAE=IPERA(JSAE,ISAE)
 4300       CONTINUE
C
 7650                CONTINUE
C
                  ISTA = IBCON1(IGAP)+1
                  IEND = IBCON1(IGAP+1)-1
                  IF (IGAP.EQ.IGBE) IEND=MSTA(ISPB2+1)-1
 7660             CONTINUE
C
 7671              LBOX3(ISPB2) = LBOX3(ISPB2) - 1
 7681           CONTINUE
C
 7686           CONTINUE
C
                   LBOX3(ISPB1) = LBOX3(ISPB1) + 1
 7691           CONTINUE
C
 7701        CONTINUE
C
 7799        CALL PUSHCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3,IEND)
 7801     CONTINUE
C
 4000 CONTINUE
C
      ENDIF
C
C  ***** END OF DIRECT OPTION *****
C
C  **** END OF GENERAL CASE OF MORE THAN ONE SPACE ******
C
      GOTO 4899
C
 3400 CONTINUE
C
C ***** SPECIAL CASE OF ONE SPACE !!!!! ******
C
C  LOOP OVER SINGLE ALPHA EXCITES WITHIN EACH SYMMETRY.
C
       DO 2901 ISAE=1,NSYM
          KBSYM=KTAB(ISAE)
          DO 2801 JSAE=1,IMMC(ISAE)
                JPOSAE=IPOSA(JSAE,ISAE)
                JPERAE=IPERA(JSAE,ISAE)
                JINDAE=IIND1(JSAE,ISAE)
                JGROAE=IGROA(JSAE,ISAE)
C
                IXI = IIND2(JSAE,ISAE)
                IXJ = IIND3(JSAE,ISAE)
C
C
C  IF ISAE.EQ.JASYM THEN SPECIAL CASE.
C
       IF (ISAE.EQ.JASYM) THEN
C
C  LOOP OVER ALL RELEVANT BETAS
C
             LABPOS=JPZA1
             LABPOS2=JPOSAE
                DO 2721 KKB=LSBS(KSYM,1),LSBS(KSYM+1,1)-1
                    LABPOS = LABPOS + 1
                    LABPOS2 = LABPOS2 + 1
                    IBPOS =  LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2621 JBINDX=JB1ST(KSYM,IBPOS),JB1ST(KSYM+1,IBPOS)-1
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  JCIB = JPOSAE+JB1PO(JBINDX)
                  JCIB2 = JPZA1+JB1PO(JBINDX)
C
                  FC = JPERAE*JB1PE(JBINDX)
                  IXK = JB1IN2(JBINDX,1)
                  IXL = JB1IN2(JBINDX,2)
CAW2                  IVAL = JB1IN(JBINDX)
C
                  IF(LABPOS.GE.JLO .AND. LABPOS.LE.JHI) THEN
                    CALL TDM2FM(TTPDM,CI,INDEX,FC,LABPOS,JCIB,IXI,IXJ,
     *                          IXK,IXL,NSTATS,NCI,N2)
                  ENDIF
C
                  IF(JCIB.GE.JLO .AND. JCIB.LE.JHI) THEN
                    CALL TDM2FM(TTPDM,CI,INDEX,FC,JCIB,LABPOS,IXI,IXJ,
     *                          IXK,IXL,NSTATS,NCI,N2)
                  ENDIF
C
                  IF(LABPOS2.GE.JLO .AND. LABPOS2.LE.JHI) THEN
                    CALL TDM2FM(TTPDM,CI,INDEX,FC,LABPOS2,JCIB2,IXI,
     *                          IXJ,IXK,IXL,NSTATS,NCI,N2)
                  ENDIF
C
                  IF(JCIB2.GE.JLO .AND. JCIB2.LE.JHI) THEN
                    CALL TDM2FM(TTPDM,CI,INDEX,FC,JCIB2,LABPOS2,IXI,
     *                          IXJ,IXK,IXL,NSTATS,NCI,N2)
                  ENDIF
C
 2621          CONTINUE
C
 2721          CONTINUE
C
      ELSE
C
C  LOOP OVER ALL RELEVANT (A-)BETA DETS.
C
                LABPOS = JPZA1
                DO 2751 KKB=LSBS(KSYM,1),LSBS(KSYM+1,1)-1
                    LABPOS = LABPOS + 1
                    IBPOS =  LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2601 JBINDX=JB1ST(KBSYM,IBPOS),JB1ST(KBSYM+1,IBPOS)-1
C
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  JCIB=JPOSAE+JB1PO(JBINDX)
C
                  FC = JPERAE*JB1PE(JBINDX)
                  IXK = JB1IN2(JBINDX,1)
                  IXL = JB1IN2(JBINDX,2)
CAW2                  IVAL = JB1IN(JBINDX)
C
                  IF(LABPOS.GE.JLO .AND. LABPOS.LE.JHI) THEN
                    CALL TDM2FM(TTPDM,CI,INDEX,FC,LABPOS,JCIB,IXI,IXJ,
     *                          IXK,IXL,NSTATS,NCI,N2)
                  ENDIF
C
                  IF(JCIB.GE.JLO .AND. JCIB.LE.JHI) THEN
                    CALL TDM2FM(TTPDM,CI,INDEX,FC,JCIB,LABPOS,IXI,IXJ,
     *                          IXK,IXL,NSTATS,NCI,N2)
                  ENDIF
C
 2601          CONTINUE
C
 2751          CONTINUE
C
C  LOOP OVER ALL RELEVANT (A'-)BETA DETS.
C
               LABPOS = JPOSAE
               DO 2761 KKB=LSBS(KBSYM,1),LSBS(KBSYM+1,1)-1
                  LABPOS = LABPOS + 1
                  IBPOS = LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2611 JBINDX=JB1ST(KSYM,IBPOS),JB1ST(KSYM+1,IBPOS)-1
C
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  JCIB=JPZA1+JB1PO(JBINDX)
C
                  FC = JPERAE*JB1PE(JBINDX)
                  IXK = JB1IN2(JBINDX,1)
                  IXL = JB1IN2(JBINDX,2)
CAW2                  IVAL = JB1IN(JBINDX)
C
                  IF(LABPOS.GE.JLO .AND. LABPOS.LE.JHI) THEN
                    CALL TDM2FM(TTPDM,CI,INDEX,FC,LABPOS,JCIB,IXI,IXJ,
     *                          IXK,IXL,NSTATS,NCI,N2)
                  ENDIF
C
                  IF(JCIB.GE.JLO .AND. JCIB.LE.JHI) THEN
                    CALL TDM2FM(TTPDM,CI,INDEX,FC,JCIB,LABPOS,IXI,IXJ,
     *                          IXK,IXL,NSTATS,NCI,N2)
                  ENDIF
C
 2611          CONTINUE
C
 2761          CONTINUE
C
      ENDIF
C
 2801       CONTINUE
 2901   CONTINUE
C
C  **** END OF SPECIAL CASE OF ONE SPACE *******
C
 4899       CALL MOVEUP2(LBOX1,NSPACE,NA,MSTA,IACON1)
 4900    CONTINUE
C
         CALL PUSHCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX5,IEND)
 5000 CONTINUE
C
C  --- END OF LOOP OVER ALPHA STRINGS. ---
C **
C  --- LOOP OVER ALL PURE BETA EXCITATIONS.
C
      CALL RESETCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX5)
C
      DO 8000 IGB=1,ITGB
C
         CALL RESETDE(LBOX1,NSPACE,NB,MSTA,IBCON1)
C
C  KKB GIVES THE ACTUAL POSITION OF THE BETA STRING IBCON1 IN
C  THE FULL BETA STRING LIST.
C
         DO 7900 KKB=NBST(IGB)+1,NBST(IGB+1)
            JPZB1 = LSPB(KKB)
            KBSYM = LSYMB(KKB)
            KSYM=KTAB(KBSYM)
C
            DO II=1,NSPACE
               LBOX2(II) = LBOX1(II)
            ENDDO
C
C  LOOP OVER SPACES TO EXCITE ELECTRON FROM.
C
            IEBS = NB+1
            DO 7890 ISPB1=NSPACE,1,-1
               IOC1 = LBOX1(ISPB1)
               IEBE = IEBS - 1
               IEBS = IEBS - IOC1
               IF (IOC1.EQ.0) GOTO 7890
               LBOX2(ISPB1) = LBOX2(ISPB1)-1
C
C  LOOP ELECTRONS IN SPACE ISPB1.
C  IEBS, IEBE ARE THE ELECTRONS IN SPACE ISPB1.
C
               DO 7885 IB1=IEBE,IEBS,-1
                  IO1 = IBCON1(IB1)
                  IGBE = IEBE - LBOX1(ISPB1)
                  IS1 = IOB(IO1)
C
C  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
C
               DO 7880 ISPB2=ISPB1,NSPACE
C
C  IGBS, IGBE ARE ELECTRONS SPECIFYING ISPB2 SPACE ELECTRON LIMITS.
C
                  IGBS = IGBE + 1
                  IGBE = IGBE + LBOX1(ISPB2)
C
                  LBOX2(ISPB2) = LBOX2(ISPB2) + 1
                  IF (LBOX2(ISPB1).LT.IBMI(ISPB1)) GOTO 7870
C
C  MAKE GAP INFORMATION HERE.
C
                  IGBB = MAX(IB1+1,IGBS)
                  IF (LBOX1(ISPB2).EQ.0) THEN
                     ISTA = MSTA(ISPB2)
                     IEND = MSTA(ISPB2+1)-1
                  ELSEIF (ISPB2.EQ.ISPB1) THEN
                     ISTA = IO1+1
                     IEND = IBCON1(IGBB)-1
                     IF (IB1.EQ.IEBE) IEND=MSTA(ISPB1+1)-1
                  ELSE
                     ISTA = MSTA(ISPB2)
                     IEND = IBCON1(IGBB)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 7860 IGAP=IGBB,IGBE+1
C
                     DO 7850 JJ=ISTA,IEND
                        IS2 = IOB(JJ)
                        IP1 = LGMUL(IS1,IS2)
                        IND = INDEX(JJ) + IO1
C
              CALL REDE00(IBCON1,IBCON2,NB,IB1,IGAP-1,JJ,JPERB)
                  IF (LBOX2(ISPB2).GT.IBMA(ISPB2)) GOTO 7800
C
C   IF DEOCCUPIED AND NEWLY OCCUPIED ORBITALS ARE OF DIFFERENT SYMMETRY,
C   SKIP TO DOUBLES.
C
              IF (IS1.NE.IS2) GOTO 7800
C
C  GET GROUP NUMBER
C
           CALL POSITCO(LBOX5,NSPACE,NB,IBMA,IBMI,LBOX4,LBOX2,IGB2)
           NIBS = NBST(IGB2)
C
              CALL IDPOST(IBCON2,NB,LBOX2,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LBNDET(1,IGB2),IACON1,JPOSB)
              KBPOS = JPOSB + NIBS
              JPZB2 = LSPB(KBPOS)
C              KPER1 = ((-1)**JPERB)*2
              KPER1 = (-1)**JPERB
C
C  LOOP OVER ALPHA
C
              DO 7705 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB2,IGA).NE.1) GOTO 7705
                 JCIB1 = LDISB(KBSYM,IGB,IGA) + JPZB1
                 JCIB2 = LDISB(KBSYM,IGB2,IGA) + JPZB2
                 NIAS = NAST(IGA)
C
              DO 7685 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA1 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA1)
                 JCI1 = JCIA + JCIB1
                 JCI2 = JCIA + JCIB2
                 FC = KPER1
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                 ENDIF
C
                 IF(JCI2.GE.JLO .AND. JCI2.LE.JHI) THEN
                 ENDIF
C
 7685         CONTINUE
C
 7705         CONTINUE
C
              DO 7712 IK=1,NB
                 IF (IK.EQ.IB1) GOTO 7712
                 ION = IBCON1(IK)
                 J1 = INDEX(ION+1)
                 JMA = MAX(J1,IND)
                 JMI = MIN(J1,IND)
                 JMA = MAX(ION,JJ)
                 JMI = MIN(ION,JJ)
                 J2 = INDEX(JMA)+JMI
                 JMA = MAX(IO1,ION)
                 JMI = MIN(IO1,ION)
                 J3 = INDEX(JMA)+JMI
                 JMA = MAX(J2,J3)
                 JMI = MIN(J2,J3)
C
              DO 7710 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB2,IGA).NE.1) GOTO 7710
                 JCIB1 = LDISB(KBSYM,IGB,IGA) + JPZB1
                 JCIB2 = LDISB(KBSYM,IGB2,IGA) + JPZB2
                 NIAS = NAST(IGA)
C
              DO 7695 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA1 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA1)
                 JCI1 = JCIA + JCIB1
                 JCI2 = JCIA + JCIB2
                 FC = KPER1
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   CALL TDM2FM(TTPDM,CI,INDEX,FC,JCI1,JCI2,IO1,JJ,
     *                         ION,ION,NSTATS,NCI,N2)
                   CALL TDM2FM(TTPDM,CI,INDEX,-FC,JCI1,JCI2,IO1,ION,
     *                         JJ,ION,NSTATS,NCI,N2)
                 ENDIF
C
                 IF(JCI2.GE.JLO .AND. JCI2.LE.JHI) THEN
                   CALL TDM2FM(TTPDM,CI,INDEX,FC,JCI2,JCI1,IO1,JJ,
     *                         ION,ION,NSTATS,NCI,N2)
                   CALL TDM2FM(TTPDM,CI,INDEX,-FC,JCI2,JCI1,IO1,ION,
     *                         JJ,ION,NSTATS,NCI,N2)
                 ENDIF
C
 7695         CONTINUE
C
 7710         CONTINUE
C
 7712         CONTINUE
C
C  LOOP OVER ALPHA STRINGS OF THE RIGHT GROUP AND SYMMETRY.
C
              CALL RESETCO(LBOX3,NSPACE,NA,IAMA,IAMI,LBOX4)
C
              DO 7700 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB2,IGA).NE.1) GOTO 7690
                 JCIB1 = LDISB(KBSYM,IGB,IGA) + JPZB1
                 JCIB2 = LDISB(KBSYM,IGB2,IGA) + JPZB2
                 NIAS = NAST(IGA)
C
              CALL RESETDE(LBOX3,NSPACE,NA,MSTA,IACON1)
              ISTA1 = 1
              DO 7680 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA1 = LSAC(KKA)
                 DO IIZ=ISTA1,IENA1-1
                    CALL MOVEUP2(LBOX3,NSPACE,NA,MSTA,IACON1)
                 ENDDO
                 ISTA1 = IENA1
                 JCIA = LSPA(NIAS+IENA1)
                 JCI1 = JCIA + JCIB1
                 JCI2 = JCIA + JCIB2
                 FC = KPER1
C
                 DO 7670 IK=1,NA
                    ION = IACON1(IK)
                    J1 = INDEX(ION+1)
                    JMA = MAX(J1,IND)
                    JMI = MIN(J1,IND)
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   CALL TDM2FM(TTPDM,CI,INDEX,FC,JCI1,JCI2,IO1,JJ,
     *                         ION,ION,NSTATS,NCI,N2)
                 ENDIF
C
                 IF(JCI2.GE.JLO .AND. JCI2.LE.JHI) THEN
                   CALL TDM2FM(TTPDM,CI,INDEX,FC,JCI2,JCI1,IO1,JJ,
     *                         ION,ION,NSTATS,NCI,N2)
                 ENDIF
C
 7670            CONTINUE
C
 7680         CONTINUE
C
 7690         CALL PUSHCO(LBOX3,NSPACE,NA,IAMA,IAMI,LBOX4,IEND)
 7700         CONTINUE
C
C  --- DOUBLE EXCITATIONS START HERE
C
 7800         CONTINUE
C
           IF (IB1.EQ.NB) GOTO 7850
           IF (JJ.EQ.NACT) GOTO 7850
C
            DO II=1,NSPACE
               LBOX3(II) = LBOX2(II)
            ENDDO
            IBES3 = 1
            DO KK=1,ISPB1-1
               IBES3 = IBES3 + LBOX2(KK)
            ENDDO
C
C  LOOP OVER SPACES TO EXCITE ELECTRONS FROM, MUST BE GE THAN
C  SPACE OF FIRST EXCITATION, ISPB1.
C
            DO 6890 ISPB3 = ISPB1,NSPACE
               IF (LBOX1(ISPB3).EQ.0) GOTO 6887
               IF (ISPB3.EQ.ISPB1.AND.IB1.EQ.IEBE) GOTO 6887
               IOC3 = LBOX2(ISPB3)
               IF (IOC3.EQ.0) GOTO 6887
C
               IBEE3 = IBES3 + LBOX2(ISPB3)-1
               LBOX3(ISPB3) = LBOX3(ISPB3)-1
C
C  LOOP OVER ELECTRONS IN ISPB3, WHICH ARE LARGER THAN IB1,
C  MAKING SURE IT ISN'T THE ALREADY EXCITED ELECTRON.
C
               JSTB3 = IBES3
               IF (ISPB3.EQ.ISPB1) THEN
                  JSTB3=IB1
                  IF (IGAP-1.EQ.IB1) JSTB3=JSTB3+1
               ENDIF
C
               DO 6880 IB3=JSTB3,IBEE3
                  IF (IB3.EQ.IGAP-1) GOTO 6880
                  IO3 = IBCON2(IB3)
                  IS3 = IOB(IO3)
C
C  LOOP OVER SPACES TO EXCITE ELECTRON INTO.  MUST BE GE THAN
C  SPACE FIRST ELECTRON WAS EXCITED INTO.
C
                  IGBE3 = 0
                  DO JIK=1,ISPB2-1
                     IGBE3 = IGBE3 + LBOX2(JIK)
                  ENDDO
                  DO 6850 ISPB4=ISPB2,NSPACE
C
C  IGBS3, IGBE3 ARE ELECTRONS SPECIFYING ISPB4 SPACE ELECTRON LIMITS.
C
                  LBOX3(ISPB4) = LBOX3(ISPB4) + 1
                  IGBS3 = IGBE3 + 1
                  IGBE3 = IGBE3 + LBOX2(ISPB4)
                  IF (LBOX3(ISPB3).LT.IBMI(ISPB3)) GOTO 6840
                  IF (LBOX3(ISPB4).GT.IBMA(ISPB4)) GOTO 6840
             IF (ISPB4.EQ.ISPB2.AND.JJ.EQ.MSTA(ISPB2+1)-1) GOTO 6840
C
C  GET GROUP NUMBER
C
               CALL POSITCO(LBOX5,NSPACE,NB,IBMA,IBMI,LBOX4,LBOX3,IGB3)
               NIBS3 = NBST(IGB3)
C
C  MAKE GAP INFORMATION HERE.
C
                  IGBB3 = MAX(IGBS3,IGAP)
C
                  IF (LBOX2(ISPB4).EQ.0) THEN
                     ISTA3 = MSTA(ISPB4)
                     IEND3 = MSTA(ISPB4+1)-1
                  ELSEIF (ISPB4.EQ.ISPB2) THEN
                     ISTA3 = JJ+1
                     IEND3 = IBCON2(IGBB3)-1
C
C  I AM SUSPECT ABOUT THIS NEXT LINE, WE'LL SEE WHAT HAPPENS.......
C
                     IF (IGAP-1.EQ.IGBE3) IEND3=MSTA(ISPB2+1)-1
C
                  ELSE
                     ISTA3 = MSTA(ISPB4)
                     IEND3 = IBCON2(IGBB3)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 6830 IGAP3=IGBB3,IGBE3+1
C
                     DO 6820 JJ3=ISTA3,IEND3
                        IS4 = IOB(JJ3)
                        IP2 = LGMUL(IS3,IS4)
                        IF (IP1.NE.IP2) GOTO 6820
C
              CALL REDE00(IBCON2,IACON1,NB,IB3,IGAP3-1,JJ3,JPERB3)
              CALL IDPOST(IACON1,NB,LBOX3,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LBNDET(1,IGB3),IACON2,JPOSB3)
C              IPER3 = ((-1)**(JPERB3+JPERB))*2
              IPER3 = (-1)**(JPERB3+JPERB)
              KBPOS3 = JPOSB3 + NIBS3
              JPZB3 = LSPB(KBPOS3)
C
                 JMA=MAX(JJ3,IO3)
                 JMI=MIN(JJ3,IO3)
                 I2 = INDEX(JMA) + JMI
                 II1 = INDEX(JJ3) + IO1
                 JMA=MAX(IO3,JJ)
                 JMI=MIN(IO3,JJ)
                 II2 = INDEX(JMA) + JMI
                 JMA=MAX(II1,II2)
                 JMI=MIN(II1,II2)
C
C  LOOP OVER ALPHA STRINGS OF RIGHT SYMMETRY AND GROUP.
C
              DO 6700 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB3,IGA).NE.1) GOTO 6700
              JCIB1 = JPZB1 + LDISB(KBSYM,IGB,IGA)
              JCIB3 = JPZB3 + LDISB(KBSYM,IGB3,IGA)
              NIAS = NAST(IGA)
C
              DO 6680 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA3 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA3)
                 JCI1 = JCIA + JCIB1
                 JCI3 = JCIA + JCIB3
                 FC = IPER3
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   CALL TDM2FM(TTPDM,CI,INDEX,FC,JCI1,JCI3,IO1,JJ,
     *                         JJ3,IO3,NSTATS,NCI,N2)
                   CALL TDM2FM(TTPDM,CI,INDEX,-FC,JCI1,JCI3,IO1,JJ3,
     *                         JJ,IO3,NSTATS,NCI,N2)
                 ENDIF
C
                 IF(JCI3.GE.JLO .AND. JCI3.LE.JHI) THEN
                   CALL TDM2FM(TTPDM,CI,INDEX,FC,JCI3,JCI1,IO1,JJ,
     *                         JJ3,IO3,NSTATS,NCI,N2)
                   CALL TDM2FM(TTPDM,CI,INDEX,-FC,JCI3,JCI1,IO1,JJ3,
     *                         JJ,IO3,NSTATS,NCI,N2)
                 ENDIF
C
 6680         CONTINUE
C
 6700         CONTINUE
C
 6820                CONTINUE
C
                     ISTA3 = IBCON2(IGAP3)+1
                     IEND3 = IBCON2(IGAP3+1)-1
                     IF (IGAP3.EQ.IGBE3) IEND3=MSTA(ISPB4+1)-1
 6830             CONTINUE
C
 6840             LBOX3(ISPB4) = LBOX3(ISPB4) - 1
 6850             CONTINUE
C
 6880          CONTINUE
C
               LBOX3(ISPB3) = LBOX3(ISPB3)+1
 6887          IBES3 = IBES3 + LBOX3(ISPB3)
 6890       CONTINUE
C
C  --- END OF LOOP OVER DOUBLE BETA EXCITATIONS.
C
 7850                CONTINUE
C
                  ISTA = IBCON1(IGAP)+1
                  IEND = IBCON1(IGAP+1)-1
                  IF (IGAP.EQ.IGBE) IEND=MSTA(ISPB2+1)-1
 7860             CONTINUE
C
 7870             LBOX2(ISPB2) = LBOX2(ISPB2) - 1
 7880          CONTINUE
C
 7885          CONTINUE
C
               LBOX2(ISPB1) = LBOX2(ISPB1)+1
 7890       CONTINUE
C
C REMAINING DIAGONAL CONTRIBUTIONS HERE
C
            DO 69 II=1,NB
               I1 = IBCON1(II)
               IND1 = INDEX(I1+1)
C
              DO 6705 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1) GOTO 6705
              JCIB1 = JPZB1 + LDISB(KBSYM,IGB,IGA)
              NIAS = NAST(IGA)
C
              DO 6685 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA3 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA3)
                 JCI1 = JCIA + JCIB1
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                 ENDIF
C
 6685         CONTINUE
C
 6705         CONTINUE
C
              DO 74 JJ=II+1,NB
                 I2 = IBCON1(JJ)
                 IND2 = INDEX(I2+1)
                 INDM = IND2 - I2 + I1
                 J1 = INDEX(INDM+1)
                 JMI = MIN(IND1,IND2)
                 JMA = MAX(IND1,IND2)
                 J2 = INDEX(JMA) + JMI
C
              DO 6710 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1) GOTO 6710
              JCIB1 = JPZB1 + LDISB(KBSYM,IGB,IGA)
              NIAS = NAST(IGA)
C
              DO 6690 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA3 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA3)
                 JCI1 = JCIA + JCIB1
C
                 IF(JCI1.GE.JLO .AND. JCI1.LE.JHI) THEN
                   CALL TDM2FM(TTPDM,CI,INDEX,ONE,JCI1,JCI1,I1,I1,
     *                         I2,I2,NSTATS,NCI,N2)
                   CALL TDM2FM(TTPDM,CI,INDEX,-ONE,JCI1,JCI1,I1,I2,
     *                         I1,I2,NSTATS,NCI,N2)
                 ENDIF
C
 6690         CONTINUE
C
 6710         CONTINUE
C
   74         CONTINUE
C
   69         CONTINUE
C
            CALL MOVEUP2(LBOX1,NSPACE,NB,MSTA,IBCON1)
 7900    CONTINUE
C
         CALL PUSHCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX5,IEND)
 8000 CONTINUE
C
C  --- END OF LOOP OVER BETA STRINGS. ---
C
      IF(GOPARR) CALL DDI_GSUMF(2175,TTPDM,N2*N2*NSTATS*NSTATS)
C
      RETURN
      END
C*MODULE ZCPRMC  *DECK TDM2FM 
      SUBROUTINE TDM2FM(TDM2,CI,IA,FC,JC1,JC2,I,J,K,L,NSTATS,NCI,N2)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION TDM2(N2,N2,NSTATS*NSTATS),CI(NCI,NSTATS)
      DIMENSION IA(*)
C
      PARAMETER (TOL=1.0D-10,TWO=2.0D+00,HALF=0.5D+00)
C
      IM = MAX(I,J)
      JM = MIN(I,J)
      IJ = IA(IM) + JM
      KM = MAX(K,L)
      LM = MIN(K,L)
      KL = IA(KM) + LM
      IJM = MAX(IJ,KL)
      KLM = MIN(IJ,KL)
C
      DO 100 ISTAT=1,NSTATS
        CVAL2 = CI(JC2,ISTAT)
        DO 100 JSTAT=1,NSTATS
          IJST = (ISTAT-1)*NSTATS + JSTAT
          FCVAL = FC*CVAL2*CI(JC1,JSTAT)
          IF(ABS(FCVAL).LT.TOL) GO TO 100
          DLT = HALF 
          IF(I.EQ.J) DLT = TWO*DLT
          IF(K.EQ.L) DLT = TWO*DLT
CTJD          IF(IJ.EQ.KL) DLT = TWO*DLT
          TDM2(IJM,KLM,IJST) = TDM2(IJM,KLM,IJST) + DLT*FCVAL
          TDM2(KLM,IJM,IJST) = TDM2(KLM,IJM,IJST) + DLT*FCVAL
  100 CONTINUE
C
CAW2 9720 FORMAT(1X,'DETL,DETR=',I5,I5,1X,'CL,CR,FC=',F10.6,F10.6,F10.6)
CAW2 9721 FORMAT(1X,'I,J,K,L=',I3,I3,I3,I3,1X,'IJ,KL=',I5,I5)
      RETURN
      END
C*MODULE ZCPRMC  *DECK MKSDER 
      SUBROUTINE MKSDER(SDER,V,DSAO,WRK,WRK2,IA,L0,L1,L3,NXYZ)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION SDER(NXYZ,L3),V(L1,L1),DSAO(*),WRK(*),WRK2(*)
      DIMENSION IA(*)
C
      PARAMETER (MXGTOT=20000,MXSH=5000)
C
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
C
      CALL VCLR(SDER,1,L3*NXYZ)
      L2 = (L1*L1+L1)/2
C
      DO 10 I=1,L2
   10   IA(I) = (I*I-I)/2
C
      DO 60 M=1,3
        IF(M.EQ.1) CALL DAREAD(IDAF,IODA,DSAO,L3,63,0)
        IF(M.EQ.2) CALL DAREAD(IDAF,IODA,DSAO,L3,64,0)
        IF(M.EQ.3) CALL DAREAD(IDAF,IODA,DSAO,L3,65,0)
        DO 40 ISHELL=1,NSHELL
          IAT = KATOM(ISHELL)
          IXYZ = 3*(IAT-1)
          LOCI = KLOC(ISHELL) - KMIN(ISHELL)
          MINI = KMIN(ISHELL)
          MAXI = KMAX(ISHELL)
          DO 20 I=MINI,MAXI
            II = LOCI + I
            DO JJ=1,L1
              IJ = IA(MAX(II,JJ)) + MIN(II,JJ)
              IIJJ = (JJ-1)*L1 + II
              SDER(IXYZ+M,IJ) = SDER(IXYZ+M,IJ) + DSAO(IIJJ)
            ENDDO
   20     CONTINUE
   40   CONTINUE
   60 CONTINUE
C
      DO 100 IXYZ=1,NXYZ
        CALL DCOPY(L3,SDER(IXYZ,1),NXYZ,WRK,1)
        CALL TFTRI(DSAO,WRK,V,WRK2,L0,L1,L1)
        CALL VCLR(SDER(IXYZ,1),NXYZ,L3)
        DO 80 I=1,L0
          DO 80 J=1,I
            IIJJ = IA(I) + J
            DVAL = DSAO(IIJJ)
            IJ = (J-1)*L1 + I
            JI = (I-1)*L1 + J
            SDER(IXYZ,IJ) = DVAL
            SDER(IXYZ,JI) = DVAL
   80   CONTINUE
  100 CONTINUE
C
CTJD
CTJD      IF(MASWRK) THEN
CTJD        WRITE(IW,*) 'SDER MO'
CAW        CALL PRSQ(SDER,L3,NXYZ,NXYZ) 
CTJD        CALL FLSHBF(IW)
CTJD      ENDIF
CTJD
      RETURN
      END 
C*MODULE ZCPRMC  *DECK FMNACI 
      SUBROUTINE FMNACI(SAGRAD,SDER,SALAG,DFC,DERI,DHC,DLAG,DNUC,TOPDM,
     *                  TTPDM,WRK,IA,NXYZ,NSTATS,NST2,L0,L1,L2,L3,NCOR,
     *                  N1,N2,N4,NFT18)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION SAGRAD(NXYZ,NST2),SALAG(L1,L1,NST2),SDER(NXYZ,L3)
      DIMENSION DFC(NXYZ,L2),DERI(NXYZ,N4),DHC(NXYZ)
      DIMENSION DLAG(NXYZ,L1,L1),DNUC(NXYZ)
      DIMENSION TOPDM(N1,N1,NST2),TTPDM(N2,N2,NST2),WRK(*)
      DIMENSION IA(*)
      LOGICAL GOPARR,DSKWRK,MASWRK,SVDSWK
C
      PARAMETER (MXRT=100)
C
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,STOT,SSQUAR,ECORE,ESCF,EERD,
     *                E1,E2,VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,
     *                EDFT(2),EDISP
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      PARAMETER (TOL=1.0D-12,ONE=1.0D+00,TWO=2.0D+00,HALF=0.5D+00)
C
      NOCC = N1 + NCOR 
C
C     Get derivative integrals off of NFT18
C
      SVDSWK = DSKWRK
      DSKWRK = .FALSE.
      CALL SEQREW(NFT18)
      DO IXYZ=1,NXYZ
        CALL SQREAD(NFT18,WRK,L2)
        CALL DCOPY(L2,WRK,1,DFC(IXYZ,1),NXYZ)
        CALL SQREAD(NFT18,WRK,N4)
        CALL DCOPY(N4,WRK,1,DERI(IXYZ,1),NXYZ)
        CALL SQREAD(NFT18,WRK,L3)
        CALL DCOPY(L3,WRK,1,DLAG(IXYZ,1,1),NXYZ)
      ENDDO
      DSKWRK = SVDSWK 
C
C     Construct lagrangian-deriv overlap term to gradient
C
      DO 100 I=1,L0
        DO 100 J=1,NOCC
          IJ = (J-1)*L1 + I
          DO 80 ISTAT=1,NSTATS
            DO 80 JSTAT=1,NSTATS
              IJST = (ISTAT-1)*NSTATS + JSTAT
              VAL = HALF*SALAG(I,J,IJST)
              IF(ABS(VAL).LT.TOL) GO TO 80
              CALL DAXPY(NXYZ,-VAL,SDER(1,IJ),1,SAGRAD(1,IJST),1)
   80     CONTINUE
  100 CONTINUE 
C
C     Construct core contribution to gradient
C
      DO 200 ISTAT=1,NSTATS
        IIST = (ISTAT-1)*NSTATS + ISTAT
        CALL DAXPY(NXYZ,ONE,DHC,1,SAGRAD(1,IIST),1)
        CALL VADD(DNUC,1,SAGRAD(1,IIST),1,SAGRAD(1,IIST),1,NXYZ)
        DO 150 I=1,NCOR
          II = IA(I) + I
          CALL DAXPY(NXYZ,ONE,DFC(1,II),1,SAGRAD(1,IIST),1)
  150   CONTINUE
  200 CONTINUE 
C
C     Construct one-electron contribution to gradient
C
      DO 300 I=NCOR+1,NOCC
        DO 300 J=NCOR+1,I
          IJ = IA(I) + J
          DO 250 ISTAT=1,NSTATS
            DO 250 JSTAT=1,NSTATS
              IJST = (ISTAT-1)*NSTATS + JSTAT
              VAL = TOPDM(I-NCOR,J-NCOR,IJST)
              IF(I.NE.J) VAL = TWO*VAL 
              IF(ABS(VAL).LT.TOL) GO TO 250
              CALL DAXPY(NXYZ,VAL,DFC(1,IJ),1,SAGRAD(1,IJST),1)
  250     CONTINUE
  300 CONTINUE
C
C     Construct two-electron contribution to gradient
C
      DO 500 I=1,N1
        DO 500 J=1,I
          IJ = IA(I) + J
          DO 500 K=1,I
            LMAX = K
            IF(K.EQ.I) LMAX = J
            DO 500 L=1,LMAX
              KL = IA(K) + L
              IJKL = IA(IJ) + KL
              DTMP = HALF 
              IF(I.NE.J) DTMP = TWO*DTMP
              IF(K.NE.L) DTMP = TWO*DTMP
              IF(IJ.NE.KL) DTMP = TWO*DTMP 
              DO 400 ISTAT=1,NSTATS
                DO 400 JSTAT=1,NSTATS
                  IJST = (ISTAT-1)*NSTATS + JSTAT
                  VAL = DTMP*TTPDM(IJ,KL,IJST)
                  IF(ABS(VAL).LT.TOL) GO TO 400
                  CALL DAXPY(NXYZ,VAL,DERI(1,IJKL),1,SAGRAD(1,IJST),1)
  400         CONTINUE 
  500 CONTINUE 
C
      DO 600 ISTAT=1,NSTATS
        DO 600 JSTAT=1,NSTATS
          IF(ISTAT.EQ.JSTAT) GO TO 600
          IJST = (ISTAT-1)*NSTATS + JSTAT
          EVAL = ONE/(ESTATE(ISTAT)-ESTATE(JSTAT))
          CALL DSCAL(NXYZ,EVAL,SAGRAD(1,IJST),1)
  600 CONTINUE
C 
C     Add contributions to CSF component of NACME
C
      RETURN
      END
C*MODULE ZCPRMC  *DECK PRTNAC
      SUBROUTINE PRTNAC(SAGRAD,EGRAD,NXYZ,NSTATS,NST2,
     *                  IRTTMP,NAPICK,NACST)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION SAGRAD(NXYZ,NSTATS*NSTATS),EGRAD(NXYZ,NST2)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL NAPICK
C
      PARAMETER(MXRT=100, MXAO=8192, MXATM=2000)
C
      DIMENSION NACST(MXRT*(MXRT-1))
C
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,SDET,SZDET,
     *                GRPDET,STSYM,GLIST,DWPARM,
     *                NFLGDM(MXRT),IWTS(MXRT),
     *                NCORSVDET,NCORDET,NACTDET,NORBDET,NADET,NBDET,
     *                KDET,KSTDET,IROOTDET,IPURES,MAXW1,NITERDET,
     *                MAXP,NCIDET,IGPDET,KSTSYMDET,NFTGCI,IDWEIGH
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
C
      PARAMETER (ZERO=0.0D+00)
C
C
C     NOTE:  PRTNAC CHANGED FROM TIM'S ORIG. TO LINES WITHIN SUB FMNAC
C            SHOULD ALLOW FOR CONICAL INTERSECTION SEARCHS
C            WITH ORMAS AND Z-VECTOR NOW.
C
C        process the state-specific gradients (diagonals of SAGRAD)
C
      ISTATM=0   ! COUNTS STATES MATCHING DESIRED MULTIPLICITY
      ISTAT =0   ! COUNTS SUCH STATES THAT ALSO HAVE NON-ZERO WEIGHT
      DO 500 IST=1,KDET
        IF(ABS(SPINS(IST)-SDET) .GT. 0.03D+00) GO TO 500
        ISTATM = ISTATM + 1
        IF(WSTATE(ISTATM).EQ.ZERO) GO TO 500
        ISTAT  = ISTAT  + 1
        IJSTAT = (ISTAT-1)*NSTATS + ISTAT
        CALL DCOPY(NXYZ,SAGRAD(1,IJSTAT),1,EGRAD(1,ISTAT),1)
C           save the gradient of state -iroot-
        IF(ISTAT.EQ.IRTTMP) THEN
          CALL DAWRIT(IDAF,IODA,EGRAD(1,ISTAT),NXYZ,3,0)
        ENDIF
        IF(MASWRK) THEN
           WRITE(IW,9030) ISTATM,IST,
     *                    ESTATE(ISTATM),SPINS(IST),WSTATE(ISTATM)
           NAT=NXYZ/3
           CALL EGOUT(EGRAD(1,ISTAT),NAT)
        END IF
  500 CONTINUE
C         save the sa-mcscf gradients for all states
      CALL DAWRIT(IDAF,IODA,EGRAD,NSTATS*NXYZ,491,0)
C
C        process the NACME vectors (offdiagonals of SAGRAD
C
      IF(MASWRK) WRITE(IW,9000) SDET
      IJG = 0
      ISTATM=0   ! COUNTS STATES MATCHING DESIRED MULTIPLICITY
      ISTAT =0   ! COUNTS SUCH STATES THAT ALSO HAVE NON-ZERO WEIGHT
      DO 610 IST=1,KDET
        IF(ABS(SPINS(IST)-SDET) .GT. 0.03D+00) GO TO 610
        ISTATM = ISTATM + 1
        IF(WSTATE(ISTATM).EQ.ZERO) GO TO 610
        ISTAT  = ISTAT  + 1
        JSTATM=0
        JSTAT =0
        DO 600 JST=1,IST-1
          IF(ABS(SPINS(JST)-SDET) .GT. 0.03D+00) GO TO 600
          JSTATM = JSTATM + 1
          IF(WSTATE(JSTATM).EQ.ZERO) GO TO 600
          JSTAT  = JSTAT  + 1
          IJG = IJG + 1
C         account for user selected nacmes
          IF (NAPICK) THEN
            ICHK=0
            DO 590 IPKA=1,KDET**2,2
              IF (NACST(IPKA).EQ.JSTAT
     *        .AND.
     *        NACST(IPKA+1).EQ.ISTAT) ICHK = ICHK + 1
  590       CONTINUE
            IF (ICHK.EQ.0) GO TO 600
          ENDIF
C         end account for user selected nacmes
          IJSTAT = (ISTAT-1)*NSTATS + JSTAT
          CALL DCOPY(NXYZ,SAGRAD(1,IJSTAT),1,EGRAD(1,IJG),1)
          IF(MASWRK) THEN
             WRITE(IW,9010) ISTATM,WSTATE(ISTATM),JSTATM,WSTATE(JSTATM)
             IX=0
             NAT=NXYZ/3
             DO IAT=1,NAT
                WRITE(IW,9020) IAT,ANAM(IAT),BNAM(IAT),
     *                         (EGRAD(IX+III,IJG),III=1,3)
                IX=IX+3
             ENDDO
          END IF
  600   CONTINUE
  610 CONTINUE
C         save the nacme elements for all i>j pairs of states
      CALL DAWRIT(IDAF,IODA,EGRAD,IJG*NXYZ,492,0)
      RETURN
C
 9000 FORMAT(/1X,'NACME FOR STATE J->I HAVE OPPOSITE SIGN TO THE',
     *           ' NACME CONNECTING STATE I->J,'/
     *        1X,'SO ONLY NACME FOR I>J ARE PRINTED,',
     *        1X,'FOR STATES WITH SPIN QUANTUM NO. S=',F6.2)
 9010 FORMAT(/1X,'NONADIABATIC COUPLING MATRIX ELEMENT (NACME),',
     *           ' IN ONE/BOHR'/
     *        1X,'<STATE',I3,', WEIGHT=',F10.5,
     *           ' | D/DQ | STATE',I3,', WEIGHT=',F10.5,'>'/
     *        3X,'ATOM',15X,'D/DX',11X,'D/DY',11X,'D/DZ')
 9020 FORMAT(1X,I4,1X,A8,A2,3F15.7)
 9030 FORMAT(/1X,'STATE-SPECIFIC GRADIENT OF STATE',I4,
     *           ' (OVERALL STATE',I4,')'/
     *        1X,'ENERGY=',F20.10,' SPIN=',F6.2,' WEIGHT=',F9.6)
      END
C*MODULE ZCPRMC  *DECK CSFNAC 
      SUBROUTINE CSFNAC(TOPDM,SAGRAD,SDER,V,WRK,WRK2,NXYZ,NCOR,
     *                  NACT,NSTATS,NST2,L1,L3)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION TOPDM(NACT,NACT,NST2),SAGRAD(NXYZ,NST2)
      DIMENSION SDER(NXYZ,L1,L1),V(L1,L1),WRK(L1,L1,NST2),WRK2(*)
CAW2      DIMENSION IA(*)
C
      PARAMETER (MXGTOT=20000, MXSH=5000, MXRT=100)
C
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,STOT,SSQUAR,ECORE,ESCF,EERD,
     *                E1,E2,VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,
     *                EDFT(2),EDISP
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
C
      PARAMETER (ZERO=0.0D+00,HALF=0.5D+00)
C
      DO 100 IXYZ=1,NXYZ
        DO 50 I=1,NACT
          DO 50 J=1,NACT
            SVAL = HALF*SDER(IXYZ,I+NCOR,J+NCOR)
            DO 20 ISTAT=1,NSTATS
              DO 20 JSTAT=1,NSTATS
                IF(ISTAT.EQ.JSTAT) GO TO 20
                IJST = (ISTAT-1)*NSTATS + JSTAT
                DVAL = SVAL*TOPDM(I,J,IJST)
                SAGRAD(IXYZ,IJST) = SAGRAD(IXYZ,IJST) - DVAL
   20       CONTINUE  
   50   CONTINUE
  100 CONTINUE
C
      DO 300 MU=1,L1
        DO 300 NU=1,L1
          DO 250 ISTAT=1,NST2
            DVAL = ZERO
            DO 220 I=1,NACT
              CVAL = V(MU,I+NCOR)
              DO 220 J=1,NACT
                DVAL = DVAL + CVAL*V(NU,J+NCOR)*TOPDM(I,J,ISTAT)
  220       CONTINUE
            WRK(MU,NU,ISTAT) = DVAL
  250     CONTINUE
  300 CONTINUE
C
      DO 400 M=1,3
        IF(M.EQ.1) CALL DAREAD(IDAF,IODA,WRK2,L3,63,0)
        IF(M.EQ.2) CALL DAREAD(IDAF,IODA,WRK2,L3,64,0)
        IF(M.EQ.3) CALL DAREAD(IDAF,IODA,WRK2,L3,65,0)
        DO 360 ISHELL=1,NSHELL
          IAT  = KATOM(ISHELL)
          IXYZ = 3*(IAT-1)
          LOCI = KLOC(ISHELL) - KMIN(ISHELL)
          MINI = KMIN(ISHELL)
          MAXI = KMAX(ISHELL)
          DO 340 ISTAT=1,NSTATS
            DO 340 JSTAT=1,NSTATS
              IF(ISTAT.EQ.JSTAT) GO TO 340
              IJST = (ISTAT-1)*NSTATS + JSTAT
              DVAL = ZERO
C
              DO 320 I=MINI,MAXI
                II = LOCI + I
                DO 320 JJ=1,L1
                  IIJJ = (JJ-1)*L1 + II
                  DVAL = DVAL + WRK(JJ,II,IJST)*WRK2(IIJJ)
  320         CONTINUE
C
              SAGRAD(IXYZ+M,IJST) = SAGRAD(IXYZ+M,IJST) + DVAL
  340     CONTINUE
  360   CONTINUE
  400 CONTINUE
C
C     This is needed since the vector will be scaled by
C      1/Eij later on
C
      DO 600 ISTAT=1,NSTATS
        DO 600 JSTAT=1,NSTATS
          IF(ISTAT.EQ.JSTAT) GO TO 600
          IJST = (ISTAT-1)*NSTATS + JSTAT
          EVAL = ESTATE(ISTAT)-ESTATE(JSTAT)
          CALL DSCAL(NXYZ,EVAL,SAGRAD(1,IJST),1)
  600 CONTINUE
C
      RETURN
      END 
C*MODULE ZCPRMC  *DECK PCPSD1 
      SUBROUTINE PCPSD1(DHC,DFC,DLAG,SDER,FCOR,OINT,DMMO,EPS,PRCNDO,
     *                  WRK,IA,INDEX,NXYZ,L1,L2,L3,NCOR,NACT,NFT18)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,SVDSKW
C
      DIMENSION DHC(NXYZ),DFC(NXYZ,L2),DLAG(NXYZ,L1,L1),SDER(NXYZ,L3)
      DIMENSION FCOR(*),OINT(*),DMMO(*),EPS(L1,L1),PRCNDO(*),WRK(*)
      DIMENSION IA(*),INDEX(L1,L1)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ZERO=0.0D+00,HALF=0.5D+00,TWO=2.0D+00)
C
      NOCC = NCOR+NACT
C
C     ----- Add derivative overlap (one-electron) contributions to -----
C     -----   the derivative core Fock and Hamiltonian matrices    -----
C
      DO 180 IXYZ=1,NXYZ
C
        DO 160 I=1,L1
          DO 160 J=1,I
            IJ = IA(I) + J
            DVAL = ZERO
            DO M=1,L1
              IG = MAX(I,M)
              MG = MIN(I,M)
              IM = IA(IG) + MG
C
              JG = MAX(J,M)
              MG = MIN(J,M)
              JM = IA(JG) + MG
C
              MI = (I-1)*L1 + M
              MJ = (J-1)*L1 + M
              DVAL = DVAL + SDER(IXYZ,MI)*FCOR(JM)
              DVAL = DVAL + SDER(IXYZ,MJ)*FCOR(IM)
            ENDDO
            DFC(IXYZ,IJ) = DFC(IXYZ,IJ) - HALF*DVAL
  160   CONTINUE
C
        DVAL = ZERO
        DO 170 I=1,NCOR
          II = IA(I) + I
          DVAL = DVAL + DFC(IXYZ,II)
          DO M=1,L1
            IG = MAX(I,M)
            MG = MIN(I,M)
            IM = IA(IG) + MG
            MI = (I-1)*L1 + M
            DVAL = DVAL - SDER(IXYZ,MI)*OINT(IM)
          ENDDO
  170   CONTINUE
C
        DHC(IXYZ) = DHC(IXYZ) + DVAL
  180 CONTINUE
C
C     ----- Add derivative overlap (one-electron) contributions to -----
C     -----               the derivative Lagrangian                -----
C
      DO 300 IXYZ=1,NXYZ
        DO 280 I=1,L1
C
          DO 200 J=1,NCOR
            DVAL = ZERO
            DO N=1,L1
              NG = MAX(N,I)
              IG = MIN(N,I)
              NI = IA(NG) + IG
              NJ = (J-1)*L1 + N
              DVAL = DVAL + SDER(IXYZ,NJ)*OINT(NI)
            ENDDO
            DLAG(IXYZ,I,J) = DLAG(IXYZ,I,J) - DVAL
  200     CONTINUE
C
          DO 240 J=1,NACT
            DVAL = ZERO
            DO 220 M=1,NACT
              MG = MAX(M,J)
              JG = MIN(M,J)
              MJ = IA(MG) + JG
              DMVAL = DMMO(MJ)
              DO 220 N=1,L1
                NG = MAX(N,I)
                IG = MIN(N,I)
                NI = IA(NG) + IG
                NM = (M+NCOR-1)*L1 + N
                DVAL = DVAL + SDER(IXYZ,NM)*DMVAL*OINT(NI)
  220       CONTINUE
            DLAG(IXYZ,I,J+NCOR) = DLAG(IXYZ,I,J+NCOR) - HALF*DVAL
  240     CONTINUE
C
          DO 260 J=1,NOCC
            DVAL = ZERO
            DO M=1,L1
              MI = (I-1)*L1 + M
              DVAL = DVAL + SDER(IXYZ,MI)*EPS(M,J)
            ENDDO
            DLAG(IXYZ,I,J) = DLAG(IXYZ,I,J) - HALF*DVAL
  260     CONTINUE
  280   CONTINUE
  300 CONTINUE
C
C     ----- Write total derivative Lagrangian to file -----
C
      SVDSKW = DSKWRK
      DSKWRK = .FALSE.
      CALL SEQREW(NFT18)
      DO IXYZ=1,NXYZ
        CALL DCOPY(L3,DLAG(IXYZ,1,1),NXYZ,WRK,1)
        CALL SQWRIT(NFT18,WRK,L3)
      ENDDO
      DSKWRK = SVDSKW
C
C     ----- Store derivative core Fock matrices over active -----
C     -----                  orbitals only                  -----
C
      DO 1000 I=1,NACT
        IF(NCOR.EQ.0) GO TO 1000
        II = I + NCOR
        DO J=1,I
          JJ = J + NCOR
          IJ = IA(I) + J
          IIJJ = IA(II) + JJ
          CALL DCOPY(NXYZ,DFC(1,IIJJ),1,DFC(1,IJ),1)
        ENDDO
 1000 CONTINUE
C
C     ----- Add one-electron part to orbital preconditioner -----
C
      DO 1100 I=1,L1
        DMI = ZERO
        IF(I.LE.NCOR) DMI = TWO
        IF(I.GT.NCOR .AND. I.LE.NOCC) THEN
          II = IA(I-NCOR) + I-NCOR
          DMI = DMMO(II)
        ENDIF
C
        DO 1100 J=1,I
          IJ = IABS(INDEX(I,J))
          IF(IJ.EQ.0) GO TO 1100
C
          IF(J.LE.NCOR) DMJ = TWO
          IF(J.GT.NCOR) THEN
            JJ = IA(J-NCOR) + J-NCOR
            DMJ = DMMO(JJ)
          ENDIF
C
          II = IA(I) + I
          JJ = IA(J) + J
          DVAL = DMJ*OINT(II) - EPS(J,J)
          IF(I.LE.NOCC) DVAL = DVAL - EPS(I,I) + DMI*OINT(JJ)
          PRCNDO(IJ) = PRCNDO(IJ) + DVAL
 1100 CONTINUE
C
      RETURN
      END
C*MODULE ZCPRMC  *DECK PCPDET 
      SUBROUTINE PCPDET(DFC,WAXCI,DHC,DERI,FCOR,OINT,ERI,PRCNDC,PRCNDS,
     *                  CI,WSTMP,EG,LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,IOX,
     *                  IWRK,NXYZ,L1,L2,N2,N4,LNEED,JLO,JHI,NDETMX,
     *                  NDETLN,NSTATS,ITGA,ITGB,IAST,IBST,IIS,NNSTAT,
     *                  NB1EX)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL FDIRCT,QCORR,GOPARR,DSKWRK,MASWRK
C
      DIMENSION DFC(NXYZ,L2),WAXCI(NXYZ,NSTATS*NDETLN),DHC(NXYZ),
     *          DERI(NXYZ,N4),FCOR(L2),OINT(*),ERI(*),
     *          PRCNDC(NDETLN,NSTATS),PRCNDS(*),CI(NDETMX,NSTATS),
     *          WSTMP(*),EG(NXYZ,NNSTAT)
      DIMENSION LBOX1(*),LBOX2(*),LBOX3(*),LBOX4(*),LBOX5(*),
     *          IOX(*),IWRK(IIS)
C
      PARAMETER (MXRT=100)
C
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,S,SZ,
     *                GRPDET,STSYM,GLIST,DWPARM,
     *                NFLGDM(MXRT),IWTS(MXRT),NCORSV,NCOR,NACT,NORB,
     *                NA,NB,K,KST,IROOT,IPURES,MAXW1,NITER,MAXP,NCI,
     *                IGPDET,KSTSYM,NFTGCI,IDWEIGH
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ2,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,
     *                EDFT(2),EDISP
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIM(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /FMCOM / X(1)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (HALF=0.5D+00,TOL=1.0D-09)
C
      NSYM = 2**IGPDET
      NINDX = N2
      IF(L1.GT.NINDX) NINDX = L1
C
      LWRK = 1
      LKTAB = LWRK + 43
      LGMUL = LKTAB + NSYM
      LCON = LGMUL + NSYM*NSYM
      LCOA = LCON + NA
      LCOB = LCOA + NSYM*ITGA
      LANDET = LCOB + NSYM*ITGB
      LBNDET = LANDET + NSPACE*ITGA
      NAST = LBNDET + NSPACE*ITGB
      NBST = NAST + ITGA + 1
      LSYMA = NBST + ITGB + 1
      LSYMB = LSYMA + IAST
      LGCOM = LSYMB + IBST
      LSPA = LGCOM + ITGB*ITGA
      LSPB = LSPA + IAST
      LDISB = LSPB + IBST
      LSAS = LDISB + NSYM*ITGB*ITGA
      LSBS = LSAS + (NSYM+1)*ITGA
      LSAC = LSBS + (NSYM+1)*ITGB
      LSBC = LSAC + IAST
      LIND = LSBC + IBST
      LACON1 = LIND + N2 + 1
      LACON2 = LACON1 + NA
      LBCON1 = LACON2 + NA
      LBCON2 = LBCON1 + NA
      IPOSA = LBCON2 + NA
      IPERA = IPOSA + NA*(NACT-NA)*NSYM
      IIND1 = IPERA + NA*(NACT-NA)*NSYM
      IIND2 = IIND1 + NA*(NACT-NA)*NSYM
      IIND3 = IIND2 + NA*(NACT-NA)*NSYM
      IGROA = IIND3 + NA*(NACT-NA)*NSYM
      IMMC = IGROA + NA*(NACT-NA)*NSYM
      INDEX2 = IMMC + NSYM
      LAST = INDEX2 + NINDX*NINDX
C
      IVAL = LIND
      DO I=1,(NACT*(NACT+1))/2 + 1
         IWRK(IVAL) = (I*(I-1))/2
         IVAL = IVAL + 1
      ENDDO
C
      IF(.NOT.FDIRCT) THEN
        IDIM1 = NSYM + 1
        IDIM2 = IBST + 1
      ELSE
        IDIM1 = 1
        IDIM2 = 1
      ENDIF
C
      JB1GR = LAST
      JB1PE = JB1GR + NB1EX
      JB1IN = JB1PE + NB1EX
      JB1PO = JB1IN + NB1EX
      JB1ST = JB1PO + NB1EX
      JB1SY = JB1ST + IDIM1*IDIM2
      JB1IN2 = JB1SY + NB*(NACT-NB)
      LAST = JB1IN2 + 2*NB1EX
C
      CALL VCLR(PRCNDC,1,NSTATS*NDETLN)
      CALL VCLR(PRCNDS,1,NNSTAT)
      CALL VCLR(WAXCI,1,NXYZ*NSTATS*NDETLN)
C
      CALL CPDRDO(WAXCI,DFC,DERI,CI,FCOR,ERI,PRCNDC,
     *            NCORSV,JLO,JHI,NSTATS,NDETLN,
     *            N2,N4,NXYZ,L1,NACT,NDETMX,NA,NB,X(LBST(1)),LNEED,
     *            IWRK(LIND),NSYM,IOX,LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,
     *            IWRK(LGMUL),IWRK(LKTAB),IWRK(LACON1),IWRK(LACON2),
     *            IWRK(LBCON1),IWRK(LBCON2),IWRK(LANDET),IWRK(LBNDET),
     *            IWRK(NAST),IWRK(NBST),IWRK(LSYMA),IWRK(LSYMB),
     *            IWRK(LGCOM),IWRK(LSPA),IWRK(LSPB),IWRK(LDISB),
     *            IWRK(LSAS),IWRK(LSBS),IWRK(LSAC),IWRK(LSBC),ITGA,
     *            ITGB,IAST,IBST,IWRK(IPOSA),IWRK(IPERA),IWRK(IIND1),
     *            IWRK(IGROA),IWRK(IMMC),NB1EX,IWRK(JB1GR),IWRK(JB1PE),
     *            IWRK(JB1IN),IWRK(JB1PO),IWRK(JB1ST),IDIM1,IDIM2)
C
C     ----- Finish perturbed configuration gradient -----
C     -----            and preconditioner           -----
C
      DHCME = ENUCR
      DO I=1,NCORSV
        II = (I*I+I)/2
        DHCME = DHCME + OINT(II) + FCOR(II)
      ENDDO
C
      IJSTAT = 0
      DO ISTAT=1,NSTATS
        EVAL = DHCME - ESTATE(ISTAT)
        DO 100 I=JLO,JHI
          CVAL = CI(I,ISTAT)
          IVAL = I - JLO + 1
          PRCNDC(IVAL,ISTAT) = PRCNDC(IVAL,ISTAT) + EVAL
          IF(ABS(CVAL).LT.TOL) GO TO 100
          PRCNDC(IVAL,ISTAT) = PRCNDC(IVAL,ISTAT) + HALF*CVAL*CVAL
          IVAL = IVAL + (ISTAT-1)*NDETLN
          CALL DAXPY(NXYZ,CVAL,DHC,1,WAXCI(1,IVAL),1)
  100   CONTINUE
C
        DO 120 JSTAT=1,ISTAT-1
          IJSTAT = IJSTAT + 1
          EVAL = ESTATE(JSTAT) - ESTATE(ISTAT)
          WVAL = WSTMP(ISTAT) - WSTMP(JSTAT)
          PRCNDS(IJSTAT) = EVAL*WVAL
  120   CONTINUE
      ENDDO
C
      CALL VCLR(EG,1,NNSTAT*NXYZ)
C
      DO 200 ISTAT=1,NSTATS
        DO 200 JSTAT=1,ISTAT
          IJ = (ISTAT*ISTAT-ISTAT)/2 + JSTAT
          DO 150 I=JLO,JHI
            CVAL = CI(I,JSTAT)
            IF(ABS(CVAL).LT.TOL) GO TO 150
            IVAL = (ISTAT-1)*NDETLN + I - JLO + 1
            CALL DAXPY(NXYZ,CVAL,WAXCI(1,IVAL),1,EG(1,IJ),1)
  150     CONTINUE
  200 CONTINUE
C
      IF(GOPARR) CALL DDI_GSUMF(2176,EG,NXYZ*NNSTAT)
C
CTJD
CTJD      WRITE(IW,*) 'prcndc'
CAW      CALL PRSQ(PRCNDC,NSTATS,NDETLN,NDETLN)
CTJD      CALL FLSHBF(IW)
CTJD
      RETURN
      END 
C*MODULE ZCPRMC  *DECK FMNACD 
      SUBROUTINE FMNACD(SAGRAD,YAO,YAS,YAC,RHSO,RHSS,RHSC,NROT,NSTATS,
     *                  NST2,NDETLN,NXYZ)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION SAGRAD(NXYZ,NSTATS*NSTATS),YAO(NSTATS*NSTATS,NROT)
      DIMENSION YAS(NSTATS*NSTATS,NST2),YAC(NSTATS*NSTATS,NSTATS*NDETLN)
      DIMENSION RHSO(NXYZ,NROT),RHSS(NXYZ,NST2),RHSC(NXYZ,NSTATS*NDETLN)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ONE=1.0D+00)
C
      DO 100 IROT=1,NROT
        DO 50 ISTAT=1,NSTATS
          DO 50 JSTAT=1,NSTATS
            IJST = (ISTAT-1)*NSTATS + JSTAT
            VAL1 = YAO(IJST,IROT)
            DO IXYZ=1,NXYZ
              VAL2 = RHSO(IXYZ,IROT)
              SAGRAD(IXYZ,IJST) = SAGRAD(IXYZ,IJST) + VAL1*VAL2
            ENDDO
   50   CONTINUE
  100 CONTINUE
C
      DO 200 I=1,NST2
        DO 150 ISTAT=1,NSTATS
          DO 150 JSTAT=1,NSTATS
            IJST = (ISTAT-1)*NSTATS + JSTAT
            VAL1 = YAS(IJST,I)
            DO IXYZ=1,NXYZ
              VAL2 = RHSS(IXYZ,I)
              SAGRAD(IXYZ,IJST) = SAGRAD(IXYZ,IJST) + VAL1*VAL2
            ENDDO
  150   CONTINUE
  200 CONTINUE
C
      IF(GOPARR) CALL DSCAL(NXYZ*NSTATS*NSTATS,ONE/NPROC,SAGRAD,1)
C
      NLEN = NSTATS*NDETLN
      DO 300 IDET=1,NLEN
        DO 250 ISTAT=1,NSTATS
          DO 250 JSTAT=1,NSTATS
            IJST = (ISTAT-1)*NSTATS + JSTAT
            VAL1 = YAC(IJST,IDET)
            DO IXYZ=1,NXYZ
              VAL2 = RHSC(IXYZ,IDET)
              SAGRAD(IXYZ,IJST) = SAGRAD(IXYZ,IJST) + VAL1*VAL2
            ENDDO
  250   CONTINUE
  300 CONTINUE
C
      IF(GOPARR) CALL DDI_GSUMF(2189,SAGRAD,NXYZ*NSTATS*NSTATS)
C
      RETURN
      END 
C*MODULE ZCPRMC  *DECK FMNACT 
      SUBROUTINE FMNACT(SAGRAD,DVEC,VEC,NOCP,NROT,NXYZ,NUNIQ,NSTATS,
     *                  SALAG,ESTATE,INDEX,L1)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION SAGRAD(NXYZ,NSTATS*NSTATS),DVEC(NUNIQ,NROT)
      DIMENSION VEC(NSTATS*NSTATS,NROT)
      DIMENSION SALAG(L1,L1,NSTATS*NSTATS),ESTATE(*)
CAW2      DIMENSION WSTATE(*)
      DIMENSION NOCP(*)
      DIMENSION INDEX(L1,L1)
C
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
C
      PARAMETER (TWO=2.0D+00)
C
C     ----- Finish constructing orbital part of RHS -----
C
      CALL VCLR(VEC,1,NSTATS*NSTATS*NROT)
      DO 10 I=1,L1
        DO 10 J=1,I
          IPHSE = INDEX(I,J)
          IROT = IABS(IPHSE)
          IF(IROT.EQ.0) GO TO 10
CTJD
CAW2          DCONV=ZERO
CTJD
          DO 9 ISTAT=1,NSTATS
            DO 9 JSTAT=1,NSTATS
              IJSTAT = (ISTAT-1)*NSTATS + JSTAT
              DVAL = SALAG(I,J,IJSTAT) - SALAG(J,I,IJSTAT)
              IF(ISTAT.NE.JSTAT) 
     *                 DVAL = DVAL/(ESTATE(ISTAT)-ESTATE(JSTAT))
              VEC(IJSTAT,IROT) = VEC(IJSTAT,IROT) + TWO*DVAL
CTJD
CTJD              IF(ISTAT.EQ.JSTAT) DCONV=DCONV+WSTATE(ISTAT)*TWO*DVAL
CTJD
    9     CONTINUE
CTJD
CTJD          IF(ABS(DCONV).GT.TOL) WRITE(IW,9721) I,J,DCONV
CTJD
   10 CONTINUE
C
      CALL DAREAD(IDAF,IODA,VEC,NSTATS*NSTATS*NROT,490,0) 
C
      DO 100 IROT=1,NROT
        IUNIQ = 0
        DO 80 IXYZ=1,NXYZ
         IF(NOCP(IXYZ).EQ.1) GO TO 80
         IUNIQ = IUNIQ + 1
         DVAL = DVEC(IUNIQ,IROT)
         DO 60 ISTAT=1,NSTATS
           DO 60 JSTAT=1,NSTATS
             IJSTAT = (ISTAT-1)*NSTATS + JSTAT
             VAL = DVAL*VEC(IJSTAT,IROT)
             SAGRAD(IXYZ,IJSTAT) = SAGRAD(IXYZ,IJSTAT) + VAL
   60     CONTINUE
   80   CONTINUE
  100 CONTINUE
C
CAW2 9721 FORMAT(1X,'I,J=',I4,I4,1X,'Lij - Lji=',F10.7)
      RETURN
      END 
C*MODULE ZCPRMC  *DECK TSTDM2 
      SUBROUTINE TSTDM2(TPDM,TTPDM,WSTATE,IA,N1,N2,NSTATS,IW)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION TPDM(*),TTPDM(N2,N2,NSTATS*NSTATS),WSTATE(*)
      DIMENSION IA(*)
C
      PARAMETER(TOL=1.0D-06)
C
      IJKL = 0
      DO 100 I=1,N1
        DO 90 J=1,I
          IJ = IA(I) + J
          DO 80 K=1,I
            LMAX = K
            IF(K.EQ.I) LMAX = J
            DO 70 L=1,LMAX
              IJKL = IJKL + 1
              TVAL = TPDM(IJKL)
              KL = IA(K) + L
              DO 60 ISTAT=1,NSTATS
                IIST = (ISTAT-1)*NSTATS + ISTAT
                TVAL = TVAL - WSTATE(ISTAT)*TTPDM(IJ,KL,IIST)
   60         CONTINUE
              IF(ABS(TVAL).LE.TOL) GO TO 70
              WRITE(IW,9721) I,J,K,L,TVAL
              CALL FLSHBF(IW)
   70       CONTINUE 
   80     CONTINUE 
   90   CONTINUE
  100 CONTINUE
C
 9721 FORMAT(1X,'I,J,K,L=',I4,I4,I4,I4,1X,'TDIFF=',F10.7)
      RETURN
      END
C*MODULE CPMCHF  *DECK DETOSC 
      subroutine detosc(tden,nact,nstats,nstats2,l1,l2,ntot,
     *                  estate,ncore,xao,yao,zao,xmo,ymo,zmo,osc,vao)
c
      implicit double precision(a-h,o-z)
      parameter (mxatm=2000)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,MA,MB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      LOGICAL GOPARR,DSKWRK,MASWRK,DBG
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      DIMENSION ITAG(3,2)
      DATA ITAG/4H   X,4H   Y,4H   Z,
     *          4HD/DX,4HD/DY,4HD/DZ/

      parameter (debye=2.541766D+00)
      parameter (zero=0.d0,two=2.d0,three=3.d0)
      dimension tden(nact,nact,nstats*nstats),estate(nstats),
     *          xao(l2),yao(l2),zao(l2),
     *          xmo(ntot,ntot),ymo(ntot,ntot),zmo(ntot,ntot),
     *          osc(nstats2),vao(l1,l1)
C---      double precision, allocatable :: xao(:),yao(:),zao(:)
c---      double precision, allocatable :: xmo(:,:),ymo(:,:),zmo(:,:)
CAW2      FTNCHCK --> VAR NOT USED.
CAW2      double precision, allocatable :: tdip(:,:)
c---      double precision, allocatable :: osc(:)
c---      double precision, allocatable :: vao(:,:)

      L2 = (L1*L1+L1)/2
      l3 = l1*l1
      NSTATS2=(NSTATS*NSTATS+NSTATS)/2
      
c---      allocate(xao(l2),yao(l2),zao(l2))
c---      allocate(xmo(ntot,ntot),ymo(ntot,ntot),zmo(ntot,ntot))
CAW2      FTNCHCK --> VAR NOT USED.
CAW2      allocate(tdip(3,nstats2))
c---      allocate(osc(nstats2))
c---      allocate(vao(l1,l1))
C
C ALL NUCLEAR CONTRIBUTIONS TO DIPOLE MOMENT
C
      CALL CALCOM(XP,YP,ZP)
      CALL DIPINT(XP,YP,ZP,.FALSE.)
      CALL DAREAD(IDAF,IODA,XAO,L2,95,0)
      CALL DAREAD(IDAF,IODA,YAO,L2,96,0)
      CALL DAREAD(IDAF,IODA,ZAO,L2,97,0)
      DMXNU=0.0D+00
      DMYNU=0.0D+00
      DMZNU=0.0D+00
      CHARGE=0.0D+00
      DO 280  I=1,NAT
         ZNUC = ZAN(I)
         CHARGE = CHARGE + ZNUC
         XN = C(1,I) - XP
         YN = C(2,I) - YP
         ZN = C(3,I) - ZP
         DMXNU = DMXNU + ZNUC*XN
         DMYNU = DMYNU + ZNUC*YN
         DMZNU = DMZNU + ZNUC*ZN
 280  CONTINUE
C
C     ----- TRANSFORM THE AO INTEGRALS TO MO INTEGRALS -----
C
      CALL DAREAD(IDAF,IODA,VAO,L3,15,0)
      IFORM=1
      DBG=.FALSE.
      CALL TMOINT(XMO,VAO,VAO,XAO,
     *            ITAG(1,IFORM),IFORM,NTOT,L1,L2,DBG)
      CALL TMOINT(YMO,VAO,VAO,YAO,
     *            ITAG(2,IFORM),IFORM,NTOT,L1,L2,DBG)
      CALL TMOINT(ZMO,VAO,VAO,ZAO,
     *            ITAG(3,IFORM),IFORM,NTOT,L1,L2,DBG)
C
C assume core contribution are the same for all states
      DMCOREX=ZERO
      DMCOREY=ZERO
      DMCOREZ=ZERO
      DO II=1,NCORE
         DMCOREX = DMCOREX - TWO*XMO(II,II)
         DMCOREY = DMCOREY - TWO*YMO(II,II)
         DMCOREZ = DMCOREZ - TWO*ZMO(II,II)
      ENDDO
C
      CALL VCLR(OSC,1,NSTATS2)
C
C the transition dipole moment
      CALL FLSHBF(IW)
      IF(MASWRK) WRITE(IW,*)
      IF(MASWRK) WRITE(IW,*) ' --- DIPOLE MOMENTS (DEBYE) ---'
      IJ2=0
      DO JST=1,NSTATS
         DO IST=1,JST
            IJ=(IST-1)*NSTATS+JST
            IJ2=IJ2+1
            DMX=ZERO
            DMY=ZERO
            DMZ=ZERO
            DO II=1,NACT
               DO JJ=1,NACT
                  DMX = DMX - XMO(NCORE+II,NCORE+JJ)*TDEN(II,JJ,IJ)
                  DMY = DMY - YMO(NCORE+II,NCORE+JJ)*TDEN(II,JJ,IJ)
                  DMZ = DMZ - ZMO(NCORE+II,NCORE+JJ)*TDEN(II,JJ,IJ)
               ENDDO
            ENDDO
C nuclear and core moments needed for single state
            IF(IST.EQ.JST) THEN
               DMX = DMX + DMXNU + DMCOREX
               DMY = DMY + DMYNU + DMCOREY
               DMZ = DMZ + DMZNU + DMCOREZ
               DIP=SQRT(DMX*DMX+DMY*DMY+DMZ*DMZ)
               IF(MASWRK) WRITE(IW,"(I3,',',I3,' :  DIPOLE',4F12.6)")
     *            IST,JST,
     *            DMX*DEBYE,DMY*DEBYE,DMZ*DEBYE,DIP*DEBYE
            ELSE
               DIP=SQRT(DMX*DMX+DMY*DMY+DMZ*DMZ)
               OSC(IJ2)=TWO*(ESTATE(JST)-ESTATE(IST))*DIP*DIP/THREE
               IF(MASWRK) WRITE(IW,"(I3,',',I3,' : TDIPOLE',4F12.6)")
     *            IST,JST,
     *            DMX*DEBYE,DMY*DEBYE,DMZ*DEBYE,DIP*DEBYE
            ENDIF
CAW2            FTNCHCK --> VARS NOT USED.
CAW2            TDIP(1,IJ2) = DMX
CAW2            TDIP(2,IJ2) = DMY
CAW2            TDIP(3,IJ2) = DMZ
         ENDDO
      ENDDO
C
      IF(MASWRK) WRITE(IW,*)
      IF(MASWRK) WRITE(IW,*) ' --- OSCILLATOR STRENGTHS  ---'
      CALL PRTRI(OSC,NSTATS)
      IF(MASWRK) WRITE(IW,*)
      CALL FLSHBF(IW)
C
c---      deallocate(xao,yao,zao)
c---      deallocate(xmo,ymo,zmo)
CAW2      FTNCHCK --> VAR NOT USED.
CAW2      deallocate(tdip)
c---      deallocate(osc)
      RETURN
      END
C*MODULE CPMCHF  *DECK MCPCGX
      SUBROUTINE MCPCGX(YAO,YAC,YAS,PRCNDO,PRCNDC,PRCNDS,RESIDO,RESIDC,
     *                  RESIDS,ZRESO,ZRESC,ZRESS,PDIRO,PDIRC,PDIRS,
     *                  BNORMO,BNORMC,BNORMS,
     *                  BKNUM,BKDEN,OINT,FCOR,AMAT,ERI,EPS,OPDM,
     *                  TPDM,CI,WRK,INDEX,IA,IWRK,IFA,IOX,NOCP,
     *                  NXYZ,NUNIQ,NROT,NDETLN,NDETMX,IIS,JLO,JHI,NA,
     *                  NB,NSYM,NCOR,NACT,L0,L1,L2,NFT18,NFT19,NSTATS,
     *                  WSTATE,EGRAD,SALAG,YADEN,AVEC,BVEC,FCORSQ,
     *                  YAOTMP,GENMC,LNEED,LBOX1,LBOX2,LBOX3,LBOX4,
     *                  LBOX5,ITGA,ITGB,IAST,IBST,NB1EX,JROTLO,JROTHI,
     *                  NDER,NAPICK,NACST)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL GENMC
      LOGICAL SETUP 
C
C     REMINDER:  NACME DP RATHER THAN INTEGER
C      DOUBLE PRECISION NACME
C
C     FOR ALL SOLVERS:
      LOGICAL NACMEGUESS,NAPICK,RECLIN,PRCCHG
C     (NON-COMBINED)
      LOGICAL GCRO,GCRODR,CONGRD
C     (COMBINED)
      LOGICAL CPCOMBO,CGGCRO
C
C
      DIMENSION YAO(NUNIQ,NROT),YAC(NUNIQ,NSTATS*NDETLN),YAS(NUNIQ,*),
     *          PRCNDO(NROT),PRCNDC(NSTATS*NDETLN),PRCNDS(*),
     *          RESIDO(NUNIQ,NROT),RESIDC(NUNIQ,NSTATS*NDETLN),
     *          RESIDS(NUNIQ,*),ZRESO(NUNIQ,NROT),
     *          ZRESC(NUNIQ,NSTATS*NDETLN),ZRESS(NUNIQ,*),
     *          PDIRO(NUNIQ,NROT),PDIRC(NUNIQ,NSTATS*NDETMX),
     *          PDIRS(NUNIQ,*),BKNUM(NUNIQ),BKDEN(NUNIQ),
     *          BNORMO(NUNIQ),BNORMC(NUNIQ),BNORMS(NUNIQ),
     *          OINT(L2),FCOR(L2),AMAT(*),ERI(*),EPS(L1,L1),OPDM(*),
     *          TPDM(*),CI(NDETMX,NSTATS),WRK(*),
     *          WSTATE(*),EGRAD(*),SALAG(L1,L1,NSTATS*NSTATS),
     *          YADEN(*),AVEC(*),BVEC(*),FCORSQ(L1,L1),YAOTMP(*)
      DIMENSION INDEX(L1,L1),IA(*),IWRK(IIS),IFA(0:NACT,0:NACT),
     *          IOX(NACT),NOCP(NXYZ)
      DIMENSION LBOX1(*),LBOX2(*),LBOX3(*),LBOX4(*),LBOX5(*)
C
      PARAMETER (MXRT=100, MXATM=2000)
      DIMENSION NOCPZ(3*MXATM)
      DIMENSION NACST(MXRT*(MXRT-1))
C
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA2,NB2,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /FMCOM / X(1)
C
      DATA CHECK /8HCHECK   /
C
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00,TWO=2.0D+00)
C
C
C
C
C
C     SUGGESTED MAIN FUTURE IMPROVEMENTS:
C     ***********
C     THE TWO MOST LONG-TERM THEORETICAL IMPROVEMENTS OF SOLVING
C     THE SPARSEST OF EQUATIONS MIGHT DERIVE FROM:
C     NOTE:  THE WORD MIGHT...
C     a)
C     M. ILI'C, I.W. TURNER, Y. SAAD, LINEAR SYSTEM SOLUTION 
C     BY NULL-SPACE APPROXIMATION AND PROJECTION (SNAP),
C     NUMERICAL LINEAR ALGEBRA WITH APPLICATIONS,
C     14(1):61-82, 2006.
C     b)
C     FAST INEXACT SUBSPACE ITERATION FOR GENERALIZED 
C     EIGENVALUE PROBLEMS WITH SPECTRAL TRANSFORMATION.
C     LINEAR ALGEBRA AND ITS APPLICATIONS 435 (2011) 601622
C     ***********
C     0)  ITEM 0 IS MORE OF A NOTE.
C         RATHER THAN TAKE THE EVECTORS OF SMALLEST MAGNITUDE,
C         THE EIGENVECTORS ARE SORTED BY MAGNITUDE WITH SIGNS.
C         SO, THE GCRO-DR SPACE CURRENTLY INCLUDES EIGENVECTORS
C             WITH NEGATIVE EIGENVALUES FROM THE HESSIAN.
C             (APPROX. RATHER THAN EXACT)
C             THIS ITEM SIGNIFICANTLY IMPROVES CONVERGENCE.
C     0.1)ITEM 0.1 IS MORE OF A NOTE.
C         SETTING THE TRIAL VECTOR TO THE 0 VECTOR 
C         WORKS TO PRODUCE A RESIDUAL NORM. OF 1.
C         THIS ITEM APPEARS TO WORK FOR NACME AND HESSIAN RUNS.
C         IN RECYCLING MODE, A RESIDUAL NORM LARGER THAN 1
C         DOES NOT LEAD TO A RESET IN HOPES THAT THE RECYCLED
C         BASIS AND PROJECTED SOLUTION WILL ACCELERATE CONVERG.
C         WE MIGHT NEED TO RE-VISIT THIS ITEM LATER ON.
C     ***********
C     1)  DOMAIN DECOMPOSITION TOWARDS FULL SOLUTION
C         (DIVIDE AND CONQUER CONVERGERS)
C     2a) IMPLEMENT AUGMENTED HESSIAN CONVERGER.
C     2b) POSSIBLY IMPLEMENT SHEPARD'S PARTITIONED CONVERGER FROM 
C         ADVANCES IN CHEMICAL PHYSICS VOL. 69, PG. 186.
C         -AW HAS ALREADY CREATED COPIES OF SUBS HSMLTC,HSSCX1,HSSCX2
C          THAT SEPERATE THE PREVIOUSLY COMBINED MAT-VEC PRODUCTS
C          OF (C+M)*X. 
C          M = DET.-DET. HESSIAN BLOCK
C          C = DET.-ORB. HESSIAN BLOCK
C          X = TRIAL VECTOR
C         -IN ESSENCE, THIS SEPERATION ALLOWS THE PARTITIONED HESSIAN,
C                      WHICH IN TURN CAN ALLOW ONE FULL MAT-VEC AND
C                      EITHER A ORB. MAT-VEC OR A DET. MAT-VEC.
C                      THE SECOND MAT-VEC IS CHOSEN BASED ON 
C                      THE RESIDUAL NORM CONTRIBUTION.
C     ***********
C     3)  BETTER PRECONDITIONING TECHNIQUE
C         (WHICH MAYBE INCORPORATED INTO DOMAIN DECOMP.)
C     4)  CARRYING OVER PARTICULAR VECTORS FROM GEOMETRY TO GEOMETRY
C         -USES QR DECOMPOSITION AND PROJECTION FOR GCRO-DR SUB.
C         -CARRY OVER AT LEAST ONE SET OF THE SUBSPACES FROM ONE R.H.S.
C         -CARRYING OVER SUBSPACES FROM SEVERAL R.H.S. SHOULD GIVE
C          FASTER CONVERGENCE BUT WILL INVOLVE LARGE .DAT FILE FOR
C          THIRD PARTY PROGRAMS.
C         (SEE PARK'S RECYCLING REFERENCE BELOW)
C     5)  SYMMETRIZE FROM THE BEGINNING... SUB ZCPRMC
C         FOR NOW...
C         -SEVERAL SUBROUTINES FOR SYM. IN THE SOLVERS EXIST
C         -MATRIX-VECTOR PRODUCTS ARE DONE ONLY FOR UNCONVERGED VECTORS
C          IN GCRO SUBS.
C         -SHIFTING OCCURS FOR EACH MATRIX-VECTOR PRODUCT IF
C          NUMBER OF UNCONVERGED/SELECTED VECTORS < NUNIQ.
C          (YES, THIS ITEM COULD BE IMPROVED, 
C           BUT SEVERAL SUBS MUST BE MODIFIED.)
C         -FOR NACME Z-VECTOR VERSION, 
C          STATE A <--> STATE B COUPLING VECTORS ARE NOT REPEATED.
C     ***********
C
C
C
C
C     PAPERS USED IN NEWER IMPLEMENTATIONS:
C     -PARKS AND DE STURLER,ETC, RECYCLING KRYLOV SUBSPACES 
C      FOR SEQUENCES OF LINEAR SYSTEMS,SIAM J. Sci. Comput,2006
C      (GCRO-DR)
C
C     -DE STURLER, TRUNCATION STRATEGIES FOR OPTIMAL KRYLOV SUBSPACE 
C      METHODS,TECH.REPORT TR-96-38, SWISS CENTER FOR SCIENTIFIC 
C      COMPUTING,ETC,1996,
C      http://www.cscs.ch/Official/PubTR.html
C     -DE STURLER, NESTED KRYLOV METHODS BASED ON GCR, 1996,
C      J COMPUT APPL MATH,67,15-41
C      [GCRO]
C
C     (IF SYM. GCRO IS DESIRED...MAYBE SEE)
C     MISHA KILMER, ERIC DE STURLER, RECYCLING SUBSPACE INFORMATION FOR
C     DIFUSE OPTICAL TOMOGRAPHY,SIAM J. SCI. COMPUT.,2140-2166.
C
C     OTHER HIGHLY RECOMMENDED PAPERS:
C
C     RESTARTING LINEAR EQUATIONS BASED ON GMRES-LIKE METHODS:
C     -JING AND HUANG, RESTARTED WEIGHTED FULL ORTHOGONALIZATION
C      METHOD FOR SHIFTED LINEAR SYSTEMS, COMPTERS AND MATHEMATICS
C      WITH APPLICATIONS, 57, 2009, 1583-1591
C
C     BASIC GCRO PAPERS:
C     -ERIC DE STURLER,TRUNCATION STRATEGIES FOR OPTIMAL KYRLOV SUBSPACE
C      METHODS,SIAM J NUMER ANAL,1999,VOL 36,NO.3,864-889
C     -DE STURLER, TRUNCATION STRATEGIES FOR OPTIMAL KRYLOV SUBSPACE
C      METHODS,TECH.REPORT TR-96-38, SWISS CENTER FOR
C      SCIENTIFIC COMPUTING,ETC,1996,
C      http://www.cscs.ch/Official/PubTR.html
C     -DE STURLER, NESTED KRYLOV METHODS BASED ON GCR, 1996,
C      J COMPUT APPL MATH,67,15-41
C
C     MISC. PAPERS:
C     -KUROIWA AND NODERA, A NOTE ON THE GMRES METHOD FOR LINEAR
C      DISCRETE ILL-POSED PROBLEMS,ADV APPL MATH MECH,VOL 1,NO. 6,
C      816-829
C     -RONALD B. MORGAN, GMRES WITH DEFLATED RESTARTING,
C      SIAM J SCI COMPUT,24,2003,20-37
C     -CHAPMAN AND SAAD, DEFLATED AND AUGMENTED KRYLOV SUBSPACE
C      TECHNIQUES. NUM LIN ALG WITH APP, 1997, 4, 43-66.
C
C     AIN PAPERS:
C     -ROBERT HARRISON, KRYLOV SUBSPACE ACCELERATED INEXACT NEWTON
C      METHOD FOR LINEAR AND NONLINEAR EQUATIONS, J COMP CHEM,
C      VOL 25, NO 3, 2003.
C     -FOKKEMA, SLEIJPEN, AND VAN DER VORST, ACCELERATED INEXACT
C      NEWTON SCHEMES FOR LARGE SYSTEMS OF NONLINEAR EQUATIONS
C      SIAM J. SCI. COMPUT, 1998, VOL 19, NO 2, 657674.
C      ****THIS VERY NICE PAPER CLASSIFIES METHODS SUCH AS DAVIDSON,
C      ETC, UNDER AIN.****
C
C     'THE' TRADITIONAL LARGE NON-SYM. LINEAR EQUATIONS PAPER:
C     -SAAD AND SCHULTZ, GMRES:  A GENERALIZED MINMAL RESIDUAL ALGORITHM
C      FOR SOLVING
C      NONSYM. LINEAR SYSTEMS,SIAM J SCI STAT COMPUT, VOL 7,NO 3,
C      JULY 1986
C
C     AN INTERESTING BEGINNER'S CONJUGATE GRADIENT PAPER:
C     -AN INTRODUCTION TO CONJUGATE GRADIENT METHOD WITHOUT THE
C      AGONIZING PAIN.
C      EDITION 1 1/4
C      JONATHON RICHARD SHEWCHUK
C      AUGUST 4, 1994
C      SCHOOL OF COMPUTER SCIENCE
C      CARNEGIE MELLON UNIVERSITY
C      PITTSBURGH, PA 15213
C
C
C
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     DEFINITION OF VARIABLES PASSED INTO MCPCGX
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C
C
C
C     FOR ALL SOLVERS:
C     VARIABLE DEFINITIONS 1:
C     NDER = 1 FOR Z-VECTOR NACME
C          = 2 FOR EITHER HESSIAN OR CALL NEW SOLVER FROM OLD SUB CPMCX
C
C     VARS ENDING WITH O = ORBITAL WITH DIMENSION NROT
C     VARS ENDING WITH C = CSF WITH DIMENSION NDETLN*NDET
C                          (OR NDETMX*NDET)
C     VARS ENDING WITH S = STATE WITH DIMENSION NNSTAT
C
C     NATM   = TOTAL NUMBER OF ATOMS
C     NXYZ   = 3*NATM FOR HESSIANS
C            = NDIM = NSTATS**2 FOR Z-VECTOR NACME
C            = NDIM = 3*NATM FOR OLDER NACME
C     NUNIQ  = NUMBER OF NA COUPLINGS FOR NDER = 1
C            = THIS VARIABLE CAN BE USER SELECTED
C              (SEE NACST FOR USER SELECTION LATER)
C     NROT   =  NUMBER OF ORBITAL ROTATIONS
C     NDETLN = LENGTH OF 1 CSF VECTOR FOR 1 PROCESS
C     NDETMX = LENGTH OF 1 CSF VECTOR FOR ALL PROCESSES
C     NNSTAT = LENGTH OF STATE-STATE VARIABLES
C              WITH LENGTH OF TRIANGULAR PIECE OF NSTATS**2
C     NSTATS = NUMBER OF ELECTRONIC STATES 
C              WITH NON-ZERO WEIGHTS IN WSTATE ARRAY
C     YAO    = NUNIQ SOLUTION VECTORS
C     YAC
C     YAS
C     PRCNDO = PRECONDITIONERS
C     PRCNDC
C     PRCNDS
C     RESIDO = NUNIQ RESIDUAL VECTORS
C     RESIDC
C     RESIDS
C     ZRESO  = NUNIQ RHS / LAGRANGIAN VECTORS
C     ZRESC
C     ZRESS
C     PDIRO  = COPY OF YAO FOR MATRIX-VECTOR PRODUCT
C     PDIRC  = PARALLELY COMBINED CSF VECTORS FOR MATRIX-VECTOR PRODUCT
C     PDIRS  = COPY OF YAS FOR MATRIX-VECTOR PRODUCT
C     BNORMO = NUNIQ NORMS OF ORBITAL RHS VECTORS
C     BNORMC = NUNIQ NORMS OF DETERMINANT RHS VECTORS
C     BNORMS = NUNIQ NORMS OF 'SA WEIGHTS' RHS VECTORS
C     BKNUM  = NUNIQ NORMS / DOT PRODUCTS (E.G.RESIDUALS)
C     BKDEN  = NUNIQ DOT PRODUCTS USUALLY FOR GRAM-SCHMIDT O.N.
C     NOCP   = ARRAY WITH 0,1,2 VALUES TO INDICATE
C              WHICH VECTORS TO USE IN THE MATRIX-VECTOR PRODUCTS.
C              THIS ARRAY ALSO INDICATES WHICH VECTORS CONVERGED
C              AS WELL AS VECTORS TO BE SKIPPED BASED ON NDER
C              (SEE BELOW).
C     NOCPZ  = 
C     NAPICK = LOGICAL USED TO INDICATE USER SELECTED NACME.
C              IN THIS SUB MCPCGX, THE DECISION FOR (NON-) Z-VECTOR
C              HAS ALREADY OCCURRED.
C     CGINIT = LOGICAL USED TO CONTROL SORTING VECTORS FOR
C              A MAT-VEC DURING TRUE RESIDUAL FORMATION
C              VERSUS JUST PLAIN MAT-VEC
C              (SEE SUB. CPINIT1)
C     PRCCHG = LOGICAL WHICH ALLOWS USER TO REMOVE 
C              SMALL ELEMENTS FROM THE PRECONDITIONER PRCNDX
C              BASED ON A USER-INPUT TOLERANCE CALLED PRCTOL
C     PRCTOL = USER-INPUT TOLERANCE FOR LOGICAL PRCCHG VAR
C
C
C
C     FOR ALL SOLVERS:
C     (NON-COMBINED)
C     VARIABLE DEFINITIONS 2A:  COMMON CONVERGER VARS
C     MAXIT  = TOTAL ITERS ALLOWED... USER INPUT.
C              ITERATIONS FROM EACH TYPE OF CONVERGER.
C     CPTOL  = CONVERGENCE TOLERANCE FOR THE RESIDUAL... USER INPUT.
C     TOL    = SET TO CPTOL AT THE BEGINNING
C              ALSO, INPUT INTO ALL SOLVERS
C              HOWEVER, IT CAN CHANGE INCREASE FOR CONJUGATE GRADIENT.
C     ERR    = COMMONLY USED TO DETERMINE IF MAX. TOL IS BELOW THRESHOLD
C     ITERX  = INTEGER THAT PREVENTS EXCESS WORK ON OTHER LINEAR EQS
C              IN CALLS TO THE CPMCHF SUBS.
C     ITER   = INTEGER THAT REPRESENTS TOTAL ITERATIONS.
C              ITER GETS PASSED SINCE PRINT STATEMNTS USE IT.
C              FOR COMBO METHODS, WE ACCUMULATE ITERS BASED ON
C              HOW EACH METHOD DEFINES AN ITER. 
C     NACST(1)
C            = AN INTEGER ARRAY THAT DEFINES PAIRS OF GRADIENTS AND 
C              NA COUPLINGS TO ACTUALLY CALCULATE.
C              IF ARRAY IS NOT INPUT, THE DEFAULT IS TO CALCULATE ALL
C              GRADIENTS AND NA COUPLINGS OF NSTATS = NON-ZERO WEIGHTS
C              IN THE WSTATE ARRAY ONCE PASSED INTO MCPCGX.
C              THIS OPTION DOES NOT AFFECT WSTATE WEIGHTINGS OF COURSE.
C
C
C
C
C     FOR ALL SOLVERS:
C     (COMBINED)
C     VARIABLE DEFINITIONS 2B:  COMMON CONVERGER VARS
C     ITERA  = ITERS OF LESS EXPENSIVE SOLVER BEFORE ALTERNATING
C              TO NEXT SOLVER
C     ITERB  = ITERS OF MORE EXPENSIVE SOLVER BEFORE ALTERNATING
C              TO NEXT SOLVER
C     ICGGCRO= VAR USED TO SAVE TOTAL NUMBER OF ITERATIONS
C     MAXIT  = INDICATES THE MAX ITERATIONS FOR 1 CYCLE OF BOTH METHODS
C     MAXIT2 = VAR USED TO SAVE THE VALUE OF MAXIT WHEN CALLING MULTIPLE
C              SUBS
C
C
C
C
C     VARIABLE DEFINITIONS 3:  CONJUGATE GRADIENT CONVERGER VARS
C     IPDIR  = NUMBER OF ITERATIONS TO DO BEFORE
C              RESETING THE SEARCH DIRECTIONS
C              AND
C              CALCULATING THE TRUE RESIDUAL
C     NACFAC = LOOSEN THE CONVERGENCE TOLERANCE EVERY NACFAC
C              ITERATIONS... USER INPUT
C     ***TOL = CAN GET CHNAGED BY NACFAC > 0 WITH ENOUGH ITERATIONS
C
C
C
C
C     VARIABLE DEFINITIONS 4:  GCRO CONVERGER VARS
C     VMATO  = (NUNIQ,X,MICIT+1) KRYLOV VECTORS FOR NUNIQ VECTORS
C     VMATS
C     VMATC
C     CMATO  = (NUNIQ,X,KICIT) C BASIS IN C = HESSIAN * U
C     CMATS
C     CMATC
C     UMATO  = (NUNIQ,X,KICIT) U BASIS IN C = HESSIAN * U
C     UMATS
C     UMATC
C     HMAT   = (MICIT+1,MICIT,NUNIQ) REDUCED MATRICES FOR REDUCED
C              LINEAR EQUATIONS
C     HMAT2  = (MICIT+1,MICIT) TEMP. MATRIX
C     WKDGEL = WORK ARRAY FOR SOLVING LEAST SQUARES (I.E. SUB DGELS)
C     BETA   = A SINGLE (MICIT) REDUCED RHS VECTOR
C              (MICIT+1) IS THE DIMENSION FOR DGELS FOR LAST ENTRY
C              THE REDUCED RHS GETS REPLACED FOR EACH IUNIQ IN NUNIQ
C              RHS VECTORS
C     BMAT   = (KICIT,MICIT,NUNIQ) REDUCED MATRICES FROM
C              (C)_T * HESSIAN * KRYLOV
C     ZMAT   = (KICIT) TEMP. VECTOR
C
C
C
C
C     VARIABLE DEFINITIONS 5:  GCRO-DR CONVERGER VARS
C     VMATO  = (NUNIQ,X,MICIT+1) KRYLOV VECTORS FOR NUNIQ VECTORS
C     VMATS
C     VMATC
C     CMATO  = (NUNIQ,X,KICIT) C BASIS IN C = HESSIAN * U
C     CMATS
C     CMATC
C     WMATO  = (NUNIQ,X,MICIT+1) VECTORS FROM CMATX BASIS 
C                            AND LAST PART OF VMATX BASIS
C     WMATS
C     WMATC
C     UMATO  = (NUNIQ,X,KICIT) U BASIS IN C = HESSIAN * U
C     UMATS
C     UMATC
C     YMATO  = (NUNIQ,X,KICIT) VECTORS FROM [U_k * V_m-k] * PMAT
C              (SEE BELOW FOR DEF. OF PMAT)
C     YMATS
C     YMATC
C     HMAT   = (MICIT+1,MICIT,NUNIQ) REDUCED MATRICES FOR REDUCED
C              LINEAR EQUATIONS
C     HMAT2  = (MICIT+1,MICIT) TEMP. MATRIX
C     GMAT   = (MICIT+1,MICIT) REDUCED MATRIX MADE UP OF
C              LOTS OF 0 ELEMENTS,
C              KICIT DIAGONAL ELEMENTS THAT NORMALIZE UMAT,
C              BMAT,
C              AND PART OF HMAT.
C              (GMAT ATTEMPTS TO REDUCE THE ILL-CONDITIONING OF THE
C               REDUCED SYSTEM)
C     WKDGEL = WORK ARRAY FOR SOLVING LEAST SQUARES (I.E. SUB DGELS)
C     BETA   = A SINGLE (MICIT) REDUCED RHS VECTOR
C              (MICIT+1) IS THE DIMENSION FOR DGELS FOR LAST ENTRY
C              THE REDUCED RHS GETS REPLACED FOR EACH IUNIQ IN NUNIQ
C              RHS VECTORS
C     BMAT   = (KICIT,MICIT,NUNIQ) REDUCED MATRICES FROM
C              (C)_T * HESSIAN * KRYLOV
C     RMAT   = (MICIT,MICIT) MATRIX USED FOR R MATRIX IN SOME
C               QR DECOMPOSITION
C     RMATINV= (MICIT,MICIT) INVERSE MATRIX OF RMAT
C     QMAT   = (MICIT+1,MICIT) MATRIX USED FOR Q MATRIX IN SOME
C              QR DEOMPOSITION
C     IPVT   = (MICIT) TEMP. VECTOR USED FOR DGECO AND DGEDI
C     WRKMP  = (MICIT+1) WORK SPACE FOR VARIOUS CALLS
C     WRKK   = (KICIT) WORK SPACE FOR VARIOUS CALLS
C     PMAT   = (MICIT,KICIT) MATRIX THAT HOLDS THE SMALLEST MAGNITUDE,
C              HARMONIC RITZ EIGENVECTORS FROM THE 
C              REDUCED HARMONIC RITZ EIGENVALUE PROBLEM
C     EVALR  = (MICIT) VECTOR THAT HOLDS THE REAL EIGENVALUES FOR PMAT
C     EVALI  = (MICIT) VECTOR THAT POSSIBLY HOLDS THE IMAGNIARY
C               EIGENVALUES FOR PMAT
C              (SEE SUB DGEEV FOR FURTHER DETAILS)
C     WRKD   = WORKSPACE FOR CALL TO DGEVV IN SOLVING FOR PMAT
C
C
C
C
C     VARIABLE DEFINITIONS 6:  GCRO + CONJUGATE GRADIENT SOLVER
C     ITERA = CG ITERS BEFORE ALTERNATING CONVERGER
C     ITERB = GCRO ITERS BEFORE ALTERNATING CONVERGER
C
C
C
C
C     MORE VARIABLE DEFINITIONS :
C     CI     = CI COEFFICIENTS
C     OINT
C     FCOR
C     AMAT
C     ERI = ELECTRON REPULSION INTEGRALS
C     EPS
C     OPDM = ONE PARTICLE DENSITY MATRIX
C     TPDM = TRANSITION DENSITY MATRIX
C     WRK
C     INDEX
C     IA
C     IWRK
C     IFA
C     IOX
C     IIS
C     JLO = LOW/HIGH PARALLEL VAR. FOR DIVIDING THE DETERMINANT LIST UP.
C     JHI 
C     NA
C     NB
C     NSYM
C     NCOR = NUMBER OF MCSCF CORE ORBITALS
C     NACT = NUMBER OF ACTIVE ORBITALS
C     NOCC = NCOR+NACT = ALL OCCUPIED ORBITALS
C     L0 = NQMT
C     L1 = NUM
C     L2 = (L1*L1+L1)/2
C     L3 = L1*L1
C     NFT18 = FOCK DERIVATIVE MATRICES FOR ANALYTIC HESSIAN
C     NFT19 = USED DURING CP-MCHF RESPONSE EQUATIONS
C     WSTATE = THE ARRAY CONTAINING NSTATS ELECTRONIC STATES INVOLVED
C              IN STATE-AVERAGING
C     EGRAD = ENERGY GRADIENT
C     SALAG = STATE AVERAGED LAGRANGIAN
C     YADEN
C     AVEC
C     BVEC
C     FCORSQ = UNFOLDED FORM OF THE SYM. FCOR MATRIX
C     YAOTMP
C     GENMC = GENERAL MCSCF
C     LBOX1 = ORMAS VARIABLES THAT RELATE TO 'NSPACE'
C     LBOX2
C     LBOX3
C     LBOX4
C     LBOX5
C     ITGA = ORMAS VARIABLES INVOLVING ALPHA VS. BETA
C     ITGB
C     IAST
C     IBST
C     NB1EX
C     JROTLO = THE SUPPOSED LOW/HIGH PARALLEL VAR. FOR NROT VARIABLES
C     JROTHI 
C              (PAR. NROT VARS. WERE NEVER FINISHED...
C               AND GET CARRIED ALONG WITH JHI AND JLO)
C
C
C
C
C
C     SET UP NAMELIST SIMULATION FOR $CPMCHF GROUP
C     NOTE:  KEEP IDENTICAL TO OTHER CALL NAMEIO AT TOP OF MCPCG.SRC
      PARAMETER (NNAM=16)
      DIMENSION QNAM(NNAM),KQNAM(NNAM)
      DATA RNAM/8HCPMCHF  /
      DATA QNAM/8HMAXIT   ,8HCPTOL   ,8HNACFAC  ,8HIPDIR   ,
     *          8HGCRO    ,8HGCRODR  ,8HMICIT   ,8HKICIT   ,
     *          8HCGGCRO  ,8HITERA   ,8HITERB   ,
     *          8HNAPICK  ,8HNACST   ,8HRECLIN  ,
     *          8HPRCCHG  ,8HPRCTOL  /
      DATA KQNAM/1,3,1,1, 0,0,1,1, 0,1,1, 0,-1,0, 0,3/
C     NOTE:  FOR NACST...
      KQNAM(13) = 10*MXRT*(MXRT-1) + 1
C
C     DEFAULT VALUES FOR $CPMCHF GROUP...
C     NOTE1:  DEFAULT SOLVER = CG
C     NOTE2:  MICIT,KICIT DEPEND ON GCRO VS. GCRO-DR.
      PRCCHG=.FALSE.
      RECLIN=.TRUE.
      NAPICK=.FALSE.
      CALL VICLR(NACST,1,(MXRT*(MXRT-1)))
      MAXIT=300
      CPTOL=1.0D-07
      PRCTOL=CPTOL
C     FOR ALL SOLVERS:
C     (NON-COMBINED)
      CONGRD=.TRUE.
      NACFAC=50
      IPDIR=MAXIT
C
      GCRODR=.FALSE.
      GCRO=.FALSE.
      MICIT=5
      KICIT=5
C     FOR ALL SOLVERS:
C     (COMBINED)
      CGGCRO=.FALSE.
      ITERA = 5
      ITERB = 5
C
C     SAVE DEFAULT VALUES TO CHECK FOR REASONABLE VALUES
C     RIGHT AFTER READING $CPMCHF GROUP
      ITERADEF=ITERA
      ITERBDEF=ITERB
      MICITDEF=MICIT
      KICITDEF=KICIT
      IPDIRDEF=IPDIR
      NACFACDEF=NACFAC
      MAXITDEF=MAXIT
      CPTOLDEF=CPTOL
      PRCTOLDEF=PRCTOL
C
C
C
C
C     READ USER INPUT SOLVER VALUES
C     NOTE:  KEEP IDENTICAL TO OTHER CALL NAMEIO AT TOP OF MCPCG.SRC
      JRET = 0
      CALL NAMEIO(IR,JRET,RNAM,NNAM,QNAM,KQNAM,
     *     MAXIT,CPTOL,NACFAC,IPDIR,
     *     GCRO,GCRODR,MICIT,KICIT,
     *     CGGCRO,ITERA,ITERB,
     *     NAPICK,NACST,RECLIN,
     *     PRCCHG,PRCTOL,0,
     *     0,0,0,0,
     *     0,0,0,0,
     *     0,0,0,0,
     *     0,0,0,0,
     *     0,0,0,0,
     *     0,0,0,0,
     *     0,0,0,0,
     *     0,0,0,0,
     *     0,0,0,0,
     *     0,0,0,0,
     *     0,0,0,0
     *     0,0,0,0)
      IF(JRET.EQ.2) CALL ABRT
C
C
C
C
C
C     FOR ALL SOLVERS:
C     CHECK SOME INPUT VARS FOR GREATER THAN 0 REQUIREMENTS
      ICHNG=0
      IF(ITERA.LE.0) ICHNG=ICHNG+1 
      IF(ITERB.LE.0) ICHNG=ICHNG+1
      IF(MICIT.LE.0) ICHNG=ICHNG+1
      IF(KICIT.LE.0) ICHNG=ICHNG+1
      IF(IPDIR.LE.0) ICHNG=ICHNG+1
      IF(NACFAC.LT.0) ICHNG=ICHNG+1
      IF(MAXIT.LE.0) ICHNG=ICHNG+1
      IF(CPTOL.LE.ZERO) ICHNG=ICHNG+1
      IF(PRCTOL.LE.ZERO) ICHNG=ICHNG+1
      IF(MASWRK.AND.ICHNG.NE.0) WRITE(IW,9009) ICHNG
C     RESET ANY NEG. VARS
      IF(ITERA.LE.0) ITERA=ITERADEF
      IF(ITERB.LE.0) ITERB=ITERBDEF
      IF(MICIT.LE.0) MICIT=MICITDEF
      IF(KICIT.LE.0) KICIT=KICITDEF
      IF(IPDIR.LE.0) IPDIR=IPDIRDEF
      IF(NACFAC.LT.0) NACFAC=NACFACDEF
      IF(MAXIT.LE.0) MAXIT=MAXITDEF
      IF(CPTOL.LE.ZERO) CPTOL=CPTOLDEF
      IF(PRCTOL.LE.ZERO) PRCTOL=PRCTOLDEF
C
C
C
C
C
C     FOR ALL SOLVERS:
C     INITIALIZE ANY NEEDED SIMPLE VARS BASED ON INPUT VARS
      TOL = CPTOL
      IF (NACFAC .EQ. 0) NACFAC = MAXIT
C
C
C
C
C
C     FOR ALL SOLVERS:
C     ELIMINATE CONFLICTING CONVERGER SELECTIONS
C     NOTE:  DE-PRIORITIZE CONVERGERS BASED ON SUPPOSED ROBUSTNESS
C            THIS ACTION PREVENTS IMPROPER CHECKS ON INPUT VARS NEXT
      IF (GCRODR) THEN
        GCRO=.FALSE.
        CGGCRO=.FALSE.
        CONGRD=.FALSE.
      ENDIF
      IF (GCRO) THEN
        CGGCRO=.FALSE.
        CONGRD=.FALSE.
      ENDIF
      IF (CGGCRO) THEN
        CONGRD=.FALSE.
      ENDIF
C
C     FOR ALL SOLVERS:
C     (COMBINED)
C     SET CPCOMBO IF COMBINATION OF METHODS IS USED.
      CPCOMBO=.FALSE.
C
C
C
C     FOR ALL SOLVERS:
C     ENSURE THAT INPUT VARS ARE REASONABLE FOR THE GIVEN CONVERGER
C
      IF (GCRO .OR. GCRODR .OR. CGGCRO) THEN
        NNSTAT = (NSTATS*NSTATS+NSTATS)/2
        ISIZE=NROT+NNSTAT+NSTATS*NDETLN
        IF (MICIT .GT. ISIZE) THEN
          MICIT=INT(DBLE(ISIZE/2))
          IF (MASWRK) WRITE(IW,9010) MICIT
        ENDIF
      ENDIF
C
C
C
C
      IF (GCRODR) THEN
        IF (KICIT .GE. MICIT) THEN
          KICIT=INT(DBLE(MICIT/2))
          IF (MASWRK) WRITE(IW,9011) KICIT
        ENDIF
      ENDIF
C
C
C
C
      IF (GCRO .OR. CGGCRO) THEN
        IF (MICIT .GT. KICIT) THEN
          MICIT=INT(DBLE(KICIT/2))
          IF (MASWRK) WRITE(IW,9012) MICIT
        ENDIF
      ENDIF
C
C
C
C
      IF (CONGRD) THEN  
        IF (IPDIR .GT. MAXIT) THEN
          IPDIR = INT(DBLE(MAXIT/4))
          IF (MASWRK) WRITE(IW,9013) IPDIR
        ENDIF
      ENDIF
C
C
C
C
      IF (CGGCRO) THEN
        ITMP = ITERA + ITERB
        IF (ITMP.GT.MAXIT) THEN
          MAXIT = ITMP
          IF (MASWRK) WRITE(IW,9014)
          IF (MASWRK) WRITE(IW,9015) MAXIT
        ENDIF
C       NOTE:  IT SEEMS NOT PROMISING FOR NACME BUT MAYBE HESSIANS
        IPDIR = ITERA+1
C       NOTE:  SET NACFAC TO ITERB+1 ALWAYS...AVOIDS PRINT OFFS
        NACFAC = ITERA+1
      ENDIF
C
C
C     FOR ALL SOLVERS:
C     ONE FLUSH TO WRITE OUT ANY ADJUSTMENTS FOR REASONABLE VARS
      CALL FLSHBF(IW)
C
C
C
C     SET UP SOME BASIC VARIABLES
      NOCC = NCOR+NACT
      NNSTAT = (NSTATS*NSTATS+NSTATS)/2
C
C     UNFOLD SYM. FCOR MATRIX 
      IJ = 1
      DO 10 I=1,L1
        DO J=1,I
          FCORSQ(I,J) = FCOR(IJ)
          FCORSQ(J,I) = FCORSQ(I,J)
          IJ = IJ + 1
        ENDDO
   10 CONTINUE
C
C
C
C
CKEEP CKEEP COMMENTS ARE RELATED TO INPUT NACME VECTORS.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     CONSTRUCT INITIAL GUESS FOR SOLUTION
C     WITH(OUT) INITIAL NACME TRIAL VECTORS
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     FOR GCRO-DR, READ SOLUTION VECTORS, EXPANSION VECTORS,ETC
      NACMEGUESS =.FALSE.
CKEEP
C
C
C
C
C
C
C
C
C     FOR ALL SOLVERS:
      CALL GOTFM(NGOTMX) 
C
C
C
C
C
C
C
C
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     CREATE COPIES OF ZRESX CALLED ZZRESX
C     FOR DIMENSIONING MANIPULATION LATER.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
      NUNIQT = NUNIQ
      CALL VALFM(LOADFM)
      LZZRESO = LOADFM + 1
      LZZRESS = LZZRESO + NUNIQT*NROT
      LZZRESC = LZZRESS + NUNIQT*NNSTAT
      LNSORT = LZZRESC + NUNIQT*NDETLN*NSTATS
      LAST = LNSORT + NUNIQT
      NEEDAW4 = LAST - LOADFM - 1
      IF(EXETYP.NE.CHECK) CALL GETFM(NEEDAW4)
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     APPLY SYMMETRY TO NDER = 1 (FOR Z-VECTOR)
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     IMPORTANT NOTES:
C     1)  SOME LEADING DIMENSIONS CHANGED BEFORE SOLVER IS CALLED.
C     2)  KRYLOV MEMORY IS REDUCED BY 1).
C     3)  NDIM = NUNIQ FOR NDER=1 CASE
C     4)  NXYZ GETS PASSED FROM ZCPRMC.SRC AS NDIM.
      IF (NDER.EQ.1) THEN
        NUNIQ = NNSTAT
        NXYZ = NUNIQ
C       ALSO INITIALIZE THE NSORT ARRAY, WHICH CONTAINS VECTOR LABELS...
        CALL CPNSORT(X(LNSORT),NUNIQT,NSTATS)
      ENDIF
C
C
C
C
C
C
C
C
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     CHECK AND DETERMINE ACTUAL NUMBER OF RESPONSES
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     NOTES:
C     ALL GRADIENTS KEPT FOR NOW.
C     WSTATE STILL INDICATES WHICH GRADIENTS TO CALCULATE.
C     THE LOWEST STATE IN WSTATE IS SIMPLY THE LOWEST STATE
C     WITH NON-ZERO WEIGHTING.
C     CHANGE NOCP TO REFLECT USER SELECTED NACME.
C     FOR SOME CONVERGERS, CPNAPICK GETS RECALLED
C     IN VARIOUS SUBS.
C     WE WANT TO PRINT OFF THE NUMBER OF RESPONSES
C     TO SOLVE FOR AFTER WE HAVE APPLIED ANY SYMMETRY POSSIBLE.
C
C     FIRST, CHECK USER INPUTS
C     NOTE:  IF CHANGE NEXT LINE, SUB CPCTST NEEDS CHANGES.
      IF(NACST(1).NE.0) NAPICK=.TRUE.
      IF(NAPICK .OR. NDER.EQ.1) THEN
        CALL CPCTST(NAPICK,NACST)
      ENDIF
      IF (NDER.EQ.2 .AND. NAPICK) THEN
        IF(MASWRK) WRITE(IW,9100)
        CALL FLSHBF(IW)
        CALL ABRT
      ENDIF
C
C     SECOND, PRINT OFF THE NUMBER OF RESPONSES TO BE SOLVED.
      DO IXYZ=1,NXYZ
        IF(NOCP(IXYZ).NE.1) NOCP(IXYZ) = 0
      ENDDO
        IF(NAPICK) CALL CPNAPICK(NACST,NSTATS,NOCP,NXYZ)
      NXYZF = 0
      DO IXYZ = 1,NXYZ
        IF (NOCP(IXYZ).EQ.0) NXYZF = NXYZF+1
      END DO
      IF(MASWRK) WRITE(IW,9016) NXYZF,0
C
C
C
C
C
C
C
CKEEPC     --------------------------------------------
CKEEPC     --------------------------------------------
CKEEPC     --------------------------------------------
CKEEPC     APPLY SYM. TO READ IN GUESS...
CKEEPC     NOTE:  WITH USE OF ZZRESO, THIS ITEM MAY NEED
CKEEPC            TO BE BEFORE READING RHS.
CKEEPC     --------------------------------------------
CKEEPC     --------------------------------------------
CKEEPC     --------------------------------------------
CKEEP        IF (NACMEGUESS .AND. NDER.EQ.1) THEN
CKEEP          CALL CPSHFTYAX(
CKEEP     *         X(LNSORT),
CKEEP     *         X(LZZRESO),X(LZZRESS),X(LZZRESC),
CKEEP     *         YAO,YAS,YAC,
CKEEP     *         NUNIQT,NROT,NNSTAT,NDETLN,NSTATS)
CKEEP        ENDIF
CKEEP
CKEEP        USE CPINITVEC HERE.  (SEE ALT. VERSIONS)
CKEEP
C
C
C
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     CONSTRUCT RHS AND TEMPORARILY PLACE IN ARRAY
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
      CALL CPMKRHS(NDER,ZRESO,ZRESC,ZRESS,
     *              CI,EGRAD,WSTATE,WRK,INDEX,NOCP,
     *              NXYZ,NUNIQT,NROT,NDETLN,
     *              NOCC,L1,NFT18,NFT19,NSTATS,
     *              JLO,JHI,NDETMX,NNSTAT)
      IF (NDER.EQ.1) THEN
        CALL CPSHFTRHS(X(LNSORT),X(LZZRESO),ZRESO,
     *                       NUNIQT,NROT,NSTATS)
      ENDIF
C     -------------------------------------------------
C     -------------------------------------------------
C     -------------------------------------------------
C     CONSTRUCT RHS NORM AND PERMANENTLY PLACE IN ARRAY
C     NOTE:  FOR NDER=1 Z-VECTOR, ARRAY IS SYMMETRIC.
C     -------------------------------------------------
C     -------------------------------------------------
C     -------------------------------------------------
      DO IXYZ=1,NUNIQ
        BNORMC(IXYZ) = ZERO
        BNORMC(IXYZ) = DDOT(NSTATS*NDETLN,ZRESC(IXYZ,1),NUNIQ,
     *                     ZRESC(IXYZ,1),NUNIQ)
      ENDDO
      IF(GOPARR) CALL DDI_GSUMF(2169,BNORMC,NUNIQ)
C
      DO IXYZ=1,NUNIQ
C
C       PRODUCE ACTUAL NORM FOR BNORMC DIRECLTY ABOVE.
        BVAL = BNORMC(IXYZ)
        BNORMC(IXYZ) = SQRT(BVAL)
C
        BVAL = DDOT(NROT,ZRESO(IXYZ,1),NUNIQ,ZRESO(IXYZ,1),NUNIQ)
        BNORMO(IXYZ) = SQRT(BVAL)
        BVAL = DDOT(NNSTAT,ZRESS(IXYZ,1),NUNIQ,ZRESS(IXYZ,1),NUNIQ)
        BNORMS(IXYZ) = SQRT(BVAL)
C        IF(MASWRK) WRITE(IW,9720) IXYZ,BNORM(IXYZ)
C        CALL FLSHBF(IW)
      ENDDO
C
C
C
C     -------------------------------------------------
C     -------------------------------------------------
C     -------------------------------------------------
C     SCALE PRECONDITIONERS
C     IMPORTANT NOTE:
C     WITHOUT THIS SCALING OF PRCNDS,
C     THIS CODE GIVES WRONG ANSWERS
C     FOR NON-EVEN SA WEIGHTS RELATIVE TO THE OLD CODE
C     -------------------------------------------------
C     -------------------------------------------------
C     -------------------------------------------------
      CALL DSCAL(NROT,TWO,PRCNDO,1)
      CALL DSCAL(NSTATS*NDETLN,TWO,PRCNDC,1)
      CALL DSCAL(NNSTAT,TWO,PRCNDS,1)
C     -------------------------------------------------
C     -------------------------------------------------
C     -------------------------------------------------
C     PREVENT GARBAGE PRECONDITIONING
C     NOTE:  THIS ACTION IS SIMILAR TO A
C            WEIGHTED-GMRES ACTION
C            BUT ON PRECOND. RATHER THAN RESIDUALS
C     NOTE2: DO NOT TOUCH PRCNDS VAR (SEE NOTES ABOVE).
C     -------------------------------------------------
C     -------------------------------------------------
C     -------------------------------------------------
      IF (PRCCHG) THEN
        ICHGROT=0
        ICHGDET=0
        DO I=1,NROT
          TEMP = PRCNDO(I)
          IF (TEMP.LT.PRCTOL) ICHGROT=ICHGROT+1
          IF (TEMP.LT.PRCTOL) PRCNDO(I)=ONE
        ENDDO
        DO ISTAT=1,NSTATS
          IVAL = (ISTAT-1)*NDETLN
          DO I=JLO,JHI
            IVAL = IVAL + 1
            TEMP = PRCNDC(IVAL)
            IF (TEMP.LT.PRCTOL) ICHGDET=ICHGDET+1
            IF (TEMP.LT.PRCTOL) PRCNDC(IVAL)=ONE
          ENDDO
        ENDDO
        WRITE(IW,9043) ICHGROT,ICHGDET
        CALL FLSHBF(IW)
      ENDIF
C
C
C
C     -----------------------------------------------------
C     -----------------------------------------------------
C     -----------------------------------------------------
C     SET UP INITIAL GUESS VECTOR (I.E. YAX)
C     NOTE:  NACMEGUESS VAR SHOULD BE ADDED AT A LATER DATE
C     -----------------------------------------------------
C     -----------------------------------------------------
C     -----------------------------------------------------
      IF(.NOT.NACMEGUESS) THEN
        CALL DCOPY(NUNIQ*NROT,ZRESO,1,YAO,1)
        CALL DCOPY(NUNIQ*NDETLN*NSTATS,ZRESC,1,YAC,1)
        CALL DCOPY(NUNIQ*NNSTAT,ZRESS,1,YAS,1)
C
        DO I=1,NROT
          FACTOR = ONE/PRCNDO(I)
          CALL DSCAL(NUNIQ,FACTOR,YAO(1,I),1)
        ENDDO
C
        DO I=1,NNSTAT
          FACTOR = ONE
          CALL DSCAL(NUNIQ,FACTOR,YAS(1,I),1)
        ENDDO
C
        DO 20 ISTAT=1,NSTATS
          IVAL = (ISTAT-1)*NDETLN
          DO I=JLO,JHI
            IVAL = IVAL + 1
            FACTOR = ONE/PRCNDC(IVAL)
            CALL DSCAL(NUNIQ,FACTOR,YAC(1,IVAL),1)
          ENDDO
   20   CONTINUE
      ENDIF
C
C
C
C
C
C     FOR ALL SOLVERS:
C     ----------------------------------
C     ----------------------------------
C     ----------------------------------
C     SETUP MEMORY FOR ANY CPMCHF SOLVER 
C     ----------------------------------
C     ----------------------------------
C     ----------------------------------
C     NOTES:
C     TO MIX AND MATCH SOLVERS, CREATE NEW SOLVER SUBROUTINE TO
C                               CALL PREVIOUS SOLVERS
C
C
C     FOR ALL SOLVERS:
C     INITIALIZE MEMORY VALUES FOR LATER PRINT OFFS
      NEEDAW3 = 0
C
C
C
C
      IF (GCRODR) THEN
        CALL VALFM(LOADFM)
        LVMATO = LOADFM + 1
        LVMATS = LVMATO + NUNIQ*NROT*(MICIT+1)
        LVMATC = LVMATS + NUNIQ*NNSTAT*(MICIT+1)
        LHMAT = LVMATC + NUNIQ*NSTATS*NDETLN*(MICIT+1)
        LHMAT2 = LHMAT + (MICIT+1)*MICIT*NUNIQ
        LGMAT = LHMAT2 + (MICIT+1)*MICIT
        LWKDGEL = LGMAT + (MICIT+1)*MICIT
        LBETA = LWKDGEL + 2*(MICIT+1)*MICIT
        LCMATO = LBETA + (MICIT+1)
        LCMATS = LCMATO + NUNIQ*NROT*KICIT
        LCMATC = LCMATS + NUNIQ*NNSTAT*KICIT
        LBMAT = LCMATC + NUNIQ*NSTATS*NDETLN*KICIT
        LUMATO = LBMAT + KICIT*MICIT*NUNIQ
        LUMATS = LUMATO + NUNIQ*NROT*KICIT
        LUMATC = LUMATS + NUNIQ*NNSTAT*KICIT
        IPVT = LUMATC + NUNIQ*NSTATS*NDETLN*KICIT
        LWRKMP = IPVT + MICIT 
        LWRKK = LWRKMP + (MICIT+1)
        LQMAT = LWRKK + KICIT
        LRMAT = LQMAT + (MICIT+1)*MICIT
        LRMATINV = LRMAT + MICIT*MICIT
        LPMAT = LRMATINV + MICIT*MICIT
        LEVALR = LPMAT + MICIT*KICIT
        LEVALI = LEVALR + MICIT
        LWRKD = LEVALI + MICIT
        LYMATO = LWRKD + 8*MICIT
        LYMATS = LYMATO + NUNIQ*NROT*KICIT
        LYMATC = LYMATS + NUNIQ*NNSTAT*KICIT
        LWMATO = LYMATC + NUNIQ*NDETLN*NSTATS*KICIT
        LWMATS = LWMATO + NUNIQ*NROT*(MICIT+1)
        LWMATC = LWMATS + NUNIQ*NNSTAT*(MICIT+1)
        LAST = LWMATC + NUNIQ*NDETLN*NSTATS*(MICIT+1)
        NEEDAW3 = LAST - LOADFM - 1
        IF(EXETYP.NE.CHECK) CALL GETFM(NEEDAW3)
      ENDIF
C
C
C
C
      IF (GCRO .OR. CGGCRO) THEN
        CALL VALFM(LOADFM)
        LVMATO = LOADFM + 1
        LVMATS = LVMATO + NUNIQ*NROT*(MICIT+1)
        LVMATC = LVMATS + NUNIQ*NNSTAT*(MICIT+1)
        LHMAT = LVMATC + NUNIQ*NSTATS*NDETLN*(MICIT+1)
        LWKDGEL = LHMAT + (MICIT+1)*MICIT*NUNIQ
        LBETA = LWKDGEL + 2*(MICIT+1)*MICIT
        LHMAT2 = LBETA + (MICIT+1)
        LCMATO = LHMAT2 + (MICIT+1)*MICIT
        LCMATS = LCMATO + NUNIQ*NROT*KICIT
        LCMATC = LCMATS + NUNIQ*NNSTAT*KICIT
        LBMAT = LCMATC + NUNIQ*NSTATS*NDETLN*KICIT
        LZMAT = LBMAT + KICIT*MICIT*NUNIQ
        LUMATO = LZMAT + KICIT
        LUMATS = LUMATO + NUNIQ*NROT*KICIT
        LUMATC = LUMATS + NUNIQ*NNSTAT*KICIT
        LAST = LUMATC + NUNIQ*NSTATS*NDETLN*KICIT
        NEEDAW3 = LAST - LOADFM - 1
        IF(EXETYP.NE.CHECK) CALL GETFM(NEEDAW3)
      ENDIF
C
C
C
C
C     FOR ALL SOLVERS:
C     -ASSIGN MEMORY ALLOCATION INFO
C     -PRINT OFF INFO
C     -SKIP SOLVERS FOR EXETYP=CHECK
      SETUP = NPRINT.NE.-5 .AND. MASWRK .AND. .NOT.CONGRD
      L3 = L1*L1
      MEMREP = NEEDAW3 + NEEDAW4
C     NOTE:  CALL GOTFM CALLED EARLIER BEFORE ALL MEM. ALL. IN THIS SUB
      IF (SETUP) THEN
        IF(EXETYP.EQ.CHECK) THEN
          WRITE(IW,9044)
          CALL CPCHK2(MEMREP,IW,NSTATS,NUNIQ,NXYZ,NDETMX,L3)
        ELSE
          WRITE(IW,9045) MEMREP,NGOTMX
        ENDIF
        CALL FLSHBF(IW)
      ENDIF
C
C
C
C
C     FOR ALL SOLVERS:
C     ----------------------------------
C     ----------------------------------
C     ----------------------------------
C     CALL ONE CPMCHF SOLVER
C     ----------------------------------
C     ----------------------------------
C     ----------------------------------
C     PRINT OFF SOLVER TYPE HERE.
C     PRINT OFF TABLE HERE.
      IF (MASWRK) THEN
        IF (CONGRD)    WRITE(IW,9000) TOL
        IF (GCRODR)    WRITE(IW,9001) TOL
        IF (GCRO)      WRITE(IW,9002) TOL
        IF (CGGCRO)    WRITE(IW,9003) TOL
        WRITE(IW,9030)
        CALL FLSHBF(IW)
      ENDIF
C
C     CHECK THAT SOME CONVERGER IS SELECTED.
      IF (.NOT.GCRO .AND. .NOT.GCRODR .AND. .NOT.CONGRD
     *              .AND. .NOT. CGGCRO
     *                                           ) THEN
        IF(MASWRK) WRITE(IW,9065)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      IF (EXETYP.EQ.CHECK) GO TO 800
C
      IF (CONGRD) THEN
        CALL CPCG(CPCOMBO,ERR,ITER,NUNIQT,X(LNSORT),
     *            X(LZZRESO),X(LZZRESS),X(LZZRESC),
     *            YAO,YAC,YAS,PRCNDO,PRCNDC,PRCNDS,RESIDO,RESIDC,
     *            RESIDS,ZRESO,ZRESC,ZRESS,PDIRO,PDIRC,PDIRS,
     *            BKNUM,BKDEN,OINT,AMAT,ERI,EPS,OPDM,
     *            BNORMO,BNORMC,BNORMS,
     *            TPDM,CI,WRK,INDEX,IA,IWRK,IFA,IOX,NOCP,
     *            NXYZ,NUNIQ,NROT,NDETLN,NDETMX,IIS,JLO,JHI,NA,
     *            NB,NSYM,NCOR,NACT,L0,L1,L2,NFT18,NFT19,NSTATS,
     *            WSTATE,EGRAD,SALAG,YADEN,AVEC,BVEC,FCORSQ,
     *            YAOTMP,GENMC,LNEED,LBOX1,LBOX2,LBOX3,LBOX4,
     *            LBOX5,ITGA,ITGB,IAST,IBST,NB1EX,JROTLO,JROTHI,
     *            IPDIR,NNSTAT,MAXIT,NACFAC,TOL,NOCC,
     *            NDER,NAPICK,NACST)
      ELSEIF (GCRODR) THEN
        CALL CPGCRODR(RECLIN,ITER,NUNIQT,X(LNSORT),
     *       X(LZZRESO),X(LZZRESS),X(LZZRESC),
     *       YAO,YAC,YAS,PRCNDO,PRCNDC,PRCNDS,RESIDO,RESIDC,
     *       RESIDS,ZRESO,ZRESC,ZRESS,PDIRO,PDIRC,PDIRS,
     *       BKNUM,BKDEN,OINT,AMAT,ERI,EPS,OPDM,
     *       BNORMO,BNORMC,BNORMS,
     *       TPDM,CI,WRK,INDEX,IA,IWRK,IFA,IOX,NOCP,
     *       NXYZ,NUNIQ,NROT,NDETLN,NDETMX,IIS,JLO,JHI,NA,
     *       NB,NSYM,NCOR,NACT,L0,L1,L2,NFT18,NFT19,NSTATS,
     *       WSTATE,EGRAD,SALAG,YADEN,AVEC,BVEC,FCORSQ,
     *       YAOTMP,GENMC,LNEED,LBOX1,LBOX2,LBOX3,LBOX4,
     *       LBOX5,ITGA,ITGB,IAST,IBST,NB1EX,JROTLO,JROTHI,
     *       MICIT,KICIT,NOCC,TOL,MAXIT,NNSTAT,
     *       X(LVMATO),X(LVMATS),X(LVMATC),
     *       X(LCMATO),X(LCMATS),X(LCMATC),
     *       X(LUMATO),X(LUMATS),X(LUMATC),
     *       X(LWMATO),X(LWMATS),X(LWMATC),
     *       X(LYMATO),X(LYMATS),X(LYMATC),
     *       X(LHMAT),X(LHMAT2),X(LWKDGEL),X(LBETA),X(LBMAT),
     *       X(LGMAT),X(IPVT),X(LWRKMP),X(LWRKK),
     *       X(LQMAT),X(LRMAT),X(LRMATINV),
     *       X(LPMAT),X(LEVALR),X(LEVALI),X(LWRKD),
     *       NDER,NAPICK,NACST)
      ELSEIF (GCRO) THEN
        CALL CPGCRO(CPCOMBO,ERR,ITER,NUNIQT,X(LNSORT),
     *       X(LZZRESO),X(LZZRESS),X(LZZRESC),
     *       YAO,YAC,YAS,PRCNDO,PRCNDC,PRCNDS,RESIDO,RESIDC,
     *       RESIDS,ZRESO,ZRESC,ZRESS,PDIRO,PDIRC,PDIRS,
     *       BKNUM,BKDEN,OINT,AMAT,ERI,EPS,OPDM,
     *       BNORMO,BNORMC,BNORMS,
     *       TPDM,CI,WRK,INDEX,IA,IWRK,IFA,IOX,NOCP,
     *       NXYZ,NUNIQ,NROT,NDETLN,NDETMX,IIS,JLO,JHI,NA,
     *       NB,NSYM,NCOR,NACT,L0,L1,L2,NFT18,NFT19,NSTATS,
     *       WSTATE,EGRAD,SALAG,YADEN,AVEC,BVEC,FCORSQ,
     *       YAOTMP,GENMC,LNEED,LBOX1,LBOX2,LBOX3,LBOX4,
     *       LBOX5,ITGA,ITGB,IAST,IBST,NB1EX,JROTLO,JROTHI,
     *       MICIT,KICIT,NOCC,TOL,MAXIT,NNSTAT,
     *       X(LVMATO),X(LVMATS),X(LVMATC),
     *       X(LCMATO),X(LCMATS),X(LCMATC),
     *       X(LUMATO),X(LUMATS),X(LUMATC),
     *       X(LHMAT),X(LHMAT2),X(LWKDGEL),
     *       X(LBETA),X(LBMAT),X(LZMAT),
     *       NDER,NAPICK,NACST)
      ELSEIF (CGGCRO) THEN
C       SAVE ORIGINAL MAXIMUM ITERATIONS
        MAXIT2 = MAXIT
C       INITIALIZE TOTAL INTERATIONS VAR
        ICGGCRO = 0
C
C
        DO ITER2=1,MAXIT2
C
C
          MAXIT = ITERA
          IF(ITER2.EQ.1) CPCOMBO=.FALSE.
          CALL CPCG(CPCOMBO,ERR,ITER,NUNIQT,X(LNSORT),
     *              X(LZZRESO),X(LZZRESS),X(LZZRESC),
     *              YAO,YAC,YAS,PRCNDO,PRCNDC,PRCNDS,RESIDO,RESIDC,
     *              RESIDS,ZRESO,ZRESC,ZRESS,PDIRO,PDIRC,PDIRS,
     *              BKNUM,BKDEN,OINT,AMAT,ERI,EPS,OPDM,
     *              BNORMO,BNORMC,BNORMS,
     *              TPDM,CI,WRK,INDEX,IA,IWRK,IFA,IOX,NOCP,
     *              NXYZ,NUNIQ,NROT,NDETLN,NDETMX,IIS,JLO,JHI,NA,
     *              NB,NSYM,NCOR,NACT,L0,L1,L2,NFT18,NFT19,NSTATS,
     *              WSTATE,EGRAD,SALAG,YADEN,AVEC,BVEC,FCORSQ,
     *              YAOTMP,GENMC,LNEED,LBOX1,LBOX2,LBOX3,LBOX4,
     *              LBOX5,ITGA,ITGB,IAST,IBST,NB1EX,JROTLO,JROTHI,
     *              IPDIR,NNSTAT,MAXIT,NACFAC,TOL,NOCC,
     *              NDER,NAPICK,NACST)
C
         IF(ITER2.EQ.1) CPCOMBO=.TRUE.
C
C        ACCUMULATE REAL ITERATIONS
         ICGGCRO = ICGGCRO + ITER
C
C        EXIT IF ERR < TOL
         IF (ERR.LT.TOL) GO TO 41
C
C
          MAXIT=ITERB
          CALL CPGCRO(CPCOMBO,ERR,ITER,NUNIQT,X(LNSORT),
     *         X(LZZRESO),X(LZZRESS),X(LZZRESC),
     *         YAO,YAC,YAS,PRCNDO,PRCNDC,PRCNDS,RESIDO,RESIDC,
     *         RESIDS,ZRESO,ZRESC,ZRESS,PDIRO,PDIRC,PDIRS,
     *         BKNUM,BKDEN,OINT,AMAT,ERI,EPS,OPDM,
     *         BNORMO,BNORMC,BNORMS,
     *         TPDM,CI,WRK,INDEX,IA,IWRK,IFA,IOX,NOCP,
     *         NXYZ,NUNIQ,NROT,NDETLN,NDETMX,IIS,JLO,JHI,NA,
     *         NB,NSYM,NCOR,NACT,L0,L1,L2,NFT18,NFT19,NSTATS,
     *         WSTATE,EGRAD,SALAG,YADEN,AVEC,BVEC,FCORSQ,
     *         YAOTMP,GENMC,LNEED,LBOX1,LBOX2,LBOX3,LBOX4,
     *         LBOX5,ITGA,ITGB,IAST,IBST,NB1EX,JROTLO,JROTHI,
     *         MICIT,KICIT,NOCC,TOL,MAXIT,NNSTAT,
     *         X(LVMATO),X(LVMATS),X(LVMATC),
     *         X(LCMATO),X(LCMATS),X(LCMATC),
     *         X(LUMATO),X(LUMATS),X(LUMATC),
     *         X(LHMAT),X(LHMAT2),X(LWKDGEL),
     *         X(LBETA),X(LBMAT),X(LZMAT),
     *         NDER,NAPICK,NACST)
C        ACCUMULATE REAL ITERATIONS
         ICGGCRO = ICGGCRO + ITER
C
C
        ENDDO
   41   CONTINUE
C
C       RESTORE ORIGINAL MAXIMUM ITERATIONS
        MAXIT = MAXIT2
C       RESTORE TOTAL NUMBER OF ITERATIONS
        ITER = ICGGCRO
      ENDIF
C
C
C
C
C
C
C
C     FOR ALL SOLVERS:
C     ONE FINAL FLUSH FOR SOLVER INFO JUST IN CASE...
      CALL FLSHBF(IW)
C     FOR ALL SOLVERS:
C     RETURN APPROPRIATE MEMORY
      IF (GCRO .OR. GCRODR .OR. CGGCRO) CALL RETFM(NEEDAW3)
C     -----------------------------------------------
C     -----------------------------------------------
C     -----------------------------------------------
C     FINISHED WITH CALL TO ONE CPMCHF SOLVER 
C     -----------------------------------------------
C     -----------------------------------------------
C     -----------------------------------------------
C
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     CHECK IF TOO MANY ITERATIONS 
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
      IF (ITER.GE.MAXIT) THEN
        IF(MASWRK) WRITE(IW,9070) MAXIT
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     REMOVE SYMMETRY FROM NDER = 1 
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
      IF (NDER.EQ.1) THEN
        NUNIQ = NUNIQT
        NXYZ = NUNIQ
        CALL CPUNSHFT(
     *       BKNUM,X(LNSORT),
     *       BNORMO,BNORMC,BNORMS,
     *       YAO,YAS,YAC,
     *       NUNIQ,NROT,NNSTAT,NDETLN,NSTATS,
     *       X(LZZRESO),X(LZZRESS),X(LZZRESC))
      ENDIF
C     DONE WITH SYMMETRY MEMORY
      CALL RETFM(NEEDAW4)
C
C
C
C     -----------------------------------------------
C     -----------------------------------------------
C     -----------------------------------------------
C     DETERMINE WHETHER SOLUTION VECTORS ARE CORRECT.
C     -----------------------------------------------
C     -----------------------------------------------
C     -----------------------------------------------
      CALL CPMKPDIRTOT(
     *     YAO,YAS,YAC,PDIRO,PDIRS,PDIRC,
     *     NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *     NDETMX,JLO,JHI,2169)
CKEEPC
CKEEPC     PRINT OFF THE RELEVANT CPMCHF VECTORS FOR RECYCLING AT
CKEEPC               NEXT GEOMETRY
CKEEP      IF(MASWRK) THEN
CKEEP        WRITE(IP,*) '$NACVEC'
CKEEP        CALL CPPRDAT(PDIRO,NROT,NUNIQ,NUNIQ)
CKEEP        CALL CPPRDAT(PDIRS,NNSTAT,NUNIQ,NUNIQ)
CKEEP        CALL CPPRDAT(PDIRC,NDETMX*NSTATS,NUNIQ,NUNIQ)
CKEEP        WRITE(IP,*) '$END'
CKEEP        CALL FLSHBF(IP)
CKEEP      ENDIF
C     
C     RESET COUNTER AND DO EXTRA WORK IN CPMCHF FOR NOW
C     TO ENSURE LESS CONVERGER MISTAKES...
      ITERX = 1
      CALL CPMATVEC_NOSYM(2170,
     *     RESIDC,RESIDO,RESIDS,
     *     PDIRO,EPS,OPDM,TPDM,IA,L0,
     *     PDIRC,PDIRS,PRCNDS,SALAG,
     *     CI,OINT,FCORSQ,AMAT,ERI,INDEX,IWRK,IFA,IOX,NCOR,NACT,
     *     NA,NB,L1,L2,NSYM,IIS,NDETMX,NDETLN,NROT,NUNIQ,JLO,JHI,
     *     NSTATS,WSTATE,WRK,YADEN,AVEC,BVEC,YAOTMP,ITERX,GENMC,
     *     LNEED,LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,ITGA,ITGB,IAST,
     *     IBST,NB1EX,JROTLO,JROTHI,
     *     NNSTAT,
     *     TIMCI,TIMORB)
C
C     NOTE1:  FOR OLD NACME CPMCX SUB, WE ACTUALLY GET THE RHS HERE.
      CALL CPMKRHS(NDER,ZRESO,ZRESC,ZRESS,
     *     CI,EGRAD,WSTATE,WRK,INDEX,NOCP,
     *     NXYZ,NUNIQ,NROT,NDETLN,
     *     NOCC,L1,NFT18,NFT19,NSTATS,
     *     JLO,JHI,NDETMX,NNSTAT)
C     NOTE:  INTENTIONALLY LEFT OFF SYMMETRY CALL HERE
C            SINCE SYM. WAS REMOVED
C
C     ACCOUNT FOR USER SELECTED NACME
      IF (NAPICK) THEN
        CALL CPNAZERO(NACST,NOCP,NXYZ,NSTATS)
      ENDIF
C     DOUBLE CHECK THAT NAPICK IS NOT TRUE WITH NDER=2
C     BEFORE CLAIMING SOLUTION IS VALID
      IF (NDER.EQ.2 .AND. NAPICK) THEN
        IF(MASWRK) WRITE(IW,9100)
        CALL FLSHBF(IW)
        CALL ABRT
      ENDIF
C
C     FORM FINAL RESIDUAL NORM
      ERR = ZERO
      IUNIQ=0
      DO 50 IXYZ=1,NXYZ
        IF(NOCP(IXYZ).NE.1) IUNIQ=IUNIQ+1
        IF(NOCP(IXYZ).EQ.1) GO TO 50
C
C       CAREFULLY ACCOUNT FOR USER SELECTED NACME
        IF(NOCP(IXYZ).NE.0 .AND. NAPICK) GO TO 50
C
        CALL CPDAXPY(ZRESO,ZRESS,ZRESC,RESIDO,RESIDS,RESIDC,
     *       NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *       IUNIQ,ONE)
        CALL CPDSCAL(RESIDO,RESIDS,RESIDC,
     *       NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *       IUNIQ,-ONE)
C
        CALL CPRNORM(2180,RESIDO,RESIDS,RESIDC,
     *       NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *       IUNIQ,TOL,TEST,ERR,
     *       BNORMO,BNORMC,BNORMS,NDETMX)
        IF(TEST.GT.TOL) THEN
          IF(MASWRK) WRITE(IW,9050) IUNIQ,TEST
        END IF
   50 CONTINUE
      IF(GOPARR) CALL DDI_SYNC(6676)
      IF(ERR.GT.TOL) THEN
         IF(MASWRK) WRITE(IW,9060)
         CALL FLSHBF(IW)
         CALL ABRT
         STOP
      END IF
C
C
C
C
C
C
C
C     ----- Print convergence message and restore original NOCP -----
C
      IF(MASWRK .AND. CPTOL.EQ.TOL) WRITE(IW,9080) ITER
      IF(MASWRK .AND. CPTOL.LT.TOL) WRITE(IW,9090) ITER
      DO IXYZ=1,NXYZ
         IF(NOCP(IXYZ).EQ.2) NOCP(IXYZ)=0
      ENDDO
C
C     ----- If doing gradient calculation, generate true RHS -----
C
C     NOTE1:  FOR Z-VECTOR NACME, NEXT CALL THE RHS.
      IF(NDER.EQ.1) THEN
        CALL DCOPY(NUNIQ*NROT,YAO,1,ZRESO,1)
        CALL DCOPY(NUNIQ*NDETLN*NSTATS,YAC,1,ZRESC,1)
        CALL DCOPY(NUNIQ*NNSTAT,YAS,1,ZRESS,1)
        NTMP = 3*NAT
        CALL VICLR(NOCPZ,1,NTMP)
        CALL FMRHS(YAO,YAC,YAS,CI,EGRAD,WSTATE,WRK,INDEX,NOCPZ,
     *             NTMP,NTMP,NROT,NDETLN,NOCC,L1,NFT18,NFT19,NSTATS,
     *             JLO,JHI,NDETMX,NNSTAT)
      ENDIF
C
C
C
C
C     FOR EXETYP=CHECK...
  800 CONTINUE
      CALL FLSHBF(IW)
C
C
C
 9000 FORMAT(/1X,'PRECONDITIONED CONJUGATE GRADIENT SOLVER',4X,
     *           'CONV. TOLERANCE=',1P,E8.2)
 9001 FORMAT(/1X,'PRECONDITIONED GCRODR SOLVER',3X,
     *           'CONV. TOLERANCE=',1P,E8.2)
 9002 FORMAT(/1X,'PRECONDITIONED GCRO SOLVER',3X,
     *           'CONV. TOLERANCE=',1P,E8.2)
 9003 FORMAT(/1X,'PRECONDITIONED GCRO+CONJUGATE GRADIENT SOLVER',4X,
     *           'CONV. TOLERANCE=',1P,E8.2)
C
 9009 FORMAT(/1X,'RESETTING NEGATIVE VARS INPUT INTO CPMCHF.',
     *       /1X,'NEGATIVE VAR COUNT=',1X,I4)
 9010 FORMAT(/1X,'RESETTING MICIT = ISIZE/2 =',1X,I4)
 9011 FORMAT(/1X,'RESETTING KICIT = MICIT/2 =',1X,I4)
 9012 FORMAT(/1X,'RESETTING MICIT = KICIT/2 =',1X,I4)
 9013 FORMAT(/1X,'RESET IPDIR = MAXIT/4 =',1X,I4)
 9014 FORMAT(1X,'MAXIT MUST EXCEED ITERA + ITERB')
 9015 FORMAT(/1X,'RESETTING MAXIT =',1X,I4)
 9016 FORMAT(/1X,'SOLVING FOR',I5,' NUCLEAR RESPONSES AND',I2,
     *          ' ELECTRIC FIELD RESPONSES')
 9030 FORMAT(1X,'ITER',3X,'RESPONSE ERROR',4X,'IMPROVED',5X,
     *       'ORB-ORB',4X,' CI-ORB',5X)
 9043 FORMAT(/1X,'POSSIBLE RESET OF SMALL PRECONDITIONING',
     *        1X,'ELEMENTS TO 1:',
     *       /1X,'ORBITAL ELEMENTS RESET     = ',I10,
     *       /1X,'DETERMINANT ELEMENTS RESET = ',I10)
 9044 FORMAT(/1X,'EXTRA CPMCHF SOLVER MEMORY.')
 9045 FORMAT(/1X,'SOLVING CPMCHF EQUATIONS - EXTRA SOLVER MEMORY.',
     *       /1X,'# OF WORDS REQUIRED  = ',I10,
     *       /1X,'# OF WORDS AVAILABLE = ',I10)
 9050 FORMAT(1X,'INCORRECT SOLUTION VECTOR: IUNIQ=',I3,5X,'ERR=',E13.5)
 9060 FORMAT(1X,'CPMCHF SOLUTIONS ARE JUNK...SORRY')
 9065 FORMAT(1X,'DID NOT PASS THROUGH CONVERGER CODE')
 9070 FORMAT(1X,'*** TOO MANY ITERATIONS IN MCCPCG *** MAXIT=',I5)
 9080 FORMAT(1X,'THE CPMCHF HAS CONVERGED AFTER',I4,' ITERATIONS.')
 9090 FORMAT(1X,'*** CAUTION! *** '/
     *       1X,'RESPONSES CONVERGED AFTER',I4,' ITERATIONS,'/
     *       1X,'BUT ONLY TO WITHIN AN INCREASED CONVERGENCE TOLERANCE')
 9100 FORMAT(1X,'CANNOT USER-SELECT NA COUPLINGS WITH NDER=2')
C
      RETURN
      END
C*MODULE MCPCGX  *DECK CPCG
      SUBROUTINE CPCG(CPCOMBO,ERR,ITER,NUNIQT,NSORT,
     *           ZZRESO,ZZRESS,ZZRESC,
     *           YAO,YAC,YAS,PRCNDO,PRCNDC,PRCNDS,RESIDO,RESIDC,
     *           RESIDS,ZRESO,ZRESC,ZRESS,PDIRO,PDIRC,PDIRS,
     *           BKNUM,BKDEN,OINT,AMAT,ERI,EPS,OPDM,
     *           BNORMO,BNORMC,BNORMS,
     *           TPDM,CI,WRK,INDEX,IA,IWRK,IFA,IOX,NOCP,
     *           NXYZ,NUNIQ,NROT,NDETLN,NDETMX,IIS,JLO,JHI,NA,
     *           NB,NSYM,NCOR,NACT,L0,L1,L2,NFT18,NFT19,NSTATS,
     *           WSTATE,EGRAD,SALAG,YADEN,AVEC,BVEC,FCORSQ,
     *           YAOTMP,GENMC,LNEED,LBOX1,LBOX2,LBOX3,LBOX4,
     *           LBOX5,ITGA,ITGB,IAST,IBST,NB1EX,JROTLO,JROTHI,
     *           IPDIR,NNSTAT,MAXIT,NACFAC,TOL,NOCC,
     *           NDER,NAPICK,NACST)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL GENMC
      LOGICAL CGCONV
      LOGICAL CPCOMBO
      LOGICAL NAPICK
      LOGICAL ZGUESS
      LOGICAL CGINIT
      LOGICAL STUFF
C
      DIMENSION NSORT(NUNIQT)
      DIMENSION ZZRESO(NUNIQ,NROT),
     *          ZZRESS(NUNIQ,*),
     *          ZZRESC(NUNIQ,NDETLN*NSTATS)
      DIMENSION YAO(NUNIQ,NROT),YAC(NUNIQ,NSTATS*NDETLN),YAS(NUNIQ,*),
     *          PRCNDO(NROT),PRCNDC(NSTATS*NDETLN),PRCNDS(*),
     *          RESIDO(NUNIQ,NROT),RESIDC(NUNIQ,NSTATS*NDETLN),
     *          RESIDS(NUNIQ,*),ZRESO(NUNIQ,NROT),
     *          ZRESC(NUNIQ,NSTATS*NDETLN),ZRESS(NUNIQ,*),
     *          PDIRO(NUNIQ,NROT),PDIRC(NUNIQ,NSTATS*NDETMX),
     *          PDIRS(NUNIQ,*),BKNUM(NUNIQ),BKDEN(NUNIQ),
     *          BNORMO(NUNIQ),BNORMC(NUNIQ),BNORMS(NUNIQ),
     *          OINT(L2),AMAT(*),ERI(*),EPS(L1,L1),OPDM(*),
     *          TPDM(*),CI(NDETMX,NSTATS),WRK(*),
     *          WSTATE(*),EGRAD(*),SALAG(L1,L1,NSTATS*NSTATS),
     *          YADEN(*),AVEC(*),BVEC(*),FCORSQ(L1,L1),YAOTMP(*)
      DIMENSION INDEX(L1,L1),IA(*),IWRK(IIS),IFA(0:NACT,0:NACT),
     *          IOX(NACT),NOCP(NXYZ)
      DIMENSION LBOX1(*),LBOX2(*),LBOX3(*),LBOX4(*),LBOX5(*)
C
      PARAMETER (MXRT=100)
      DIMENSION NACST(MXRT*(MXRT-1))
C
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00)
      PARAMETER (THREE=3.0D+00)
C
C
C
C
C
C
C     INITIALIZE ITERX
      ITERX=1
      IF (CPCOMBO) ITERX=2
C
C     INITIALIZE VARIABLE FOR ZERO GUESS
      ZGUESS=.TRUE.
    3 CONTINUE
C
C     INITIALIZE VAR TO EXIT WITH ONLY TRUE RESIDUAL
      CGCONV = .FALSE.
C
C     INITIALIZE UNCONVERGED SOLUTION VECTORS
      DO IXYZ=1,NXYZ
        IF(NOCP(IXYZ).NE.1) NOCP(IXYZ) = 0
      ENDDO
C     ACCOUNT FOR USER SELECTED NACME
      IF (NAPICK)
     *   CALL CPNAPICK(NACST,NSTATS,NOCP,NXYZ)
      NXYZF = 0
      DO IXYZ = 1,NXYZ
        IF (NOCP(IXYZ).EQ.0) NXYZF = NXYZF+1
      END DO
C
C
      ERR = ZERO
      DO 400 ITER=1,MAXIT
C
C
C       ASSIGN NACFAC
        IF(MOD(ITER,NACFAC).EQ.0) THEN
          TOL = THREE*TOL
          IF(MASWRK) WRITE(IW,9075) TOL
        ENDIF
C
C       PREPARE FOR MAT-VEC
        CGCONV=.FALSE.
        STUFF=ITER.EQ.1.OR.ITER.EQ.MAXIT
     *        .OR.MOD(ITER,IPDIR).EQ.0.OR.ERR.LT.TOL
        IF(STUFF) THEN
C
C         PREPARE NOCP ARRAY FOR AFTER MAT-VEC
          DO IXYZ=1,NXYZ
            IF(NOCP(IXYZ).NE.1) NOCP(IXYZ) = 0
          ENDDO
C         ACCOUNT FOR USER SELECTED NACME
          IF (NAPICK)
     *       CALL CPNAPICK(NACST,NSTATS,NOCP,NXYZ)
          NXYZF = 0
          DO IXYZ = 1,NXYZ
            IF (NOCP(IXYZ).EQ.0) NXYZF = NXYZF+1
          END DO
C
C         PRINT OUT TRUE RESIDUAL
          STUFF=ITER.GT.1.AND.MASWRK.AND..NOT.CPCOMBO
          STUFF=STUFF.OR.NXYZF.EQ.0
          IF(STUFF) WRITE(IW,9021)
          CALL FLSHBF(IW)
C
C         MAT-VEC
          CGCONV=.TRUE.
          CALL CPINIT1(2181,2182,2183,CGINIT,
     *         NDER,NXYZF,NUNIQT,NFT18,NFT19,EGRAD,NSORT,NOCP,NOCC,
     *         YAC,YAO,YAS,
     *         ZRESC,ZRESO,ZRESS,
     *         ZZRESC,ZZRESO,ZZRESS,
     *         RESIDC,RESIDO,RESIDS,
     *         PDIRO,EPS,OPDM,TPDM,IA,L0,
     *         PDIRC,PDIRS,PRCNDS,SALAG,
     *         CI,OINT,FCORSQ,AMAT,ERI,INDEX,IWRK,IFA,IOX,NCOR,NACT,
     *         NA,NB,L1,L2,NSYM,IIS,NDETMX,NDETLN,NROT,NUNIQ,JLO,JHI,
     *         NSTATS,WSTATE,WRK,YADEN,AVEC,BVEC,YAOTMP,ITERX,GENMC,
     *         LNEED,LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,ITGA,ITGB,IAST,
     *         IBST,NB1EX,JROTLO,JROTHI,
     *         PRCNDO,PRCNDC,
     *         NNSTAT,NXYZ,
     *         TIMCI,TIMORB)
C
          ITERX = ITERX + 1
C
          CALL CPINIT2(2184,2185,
     *         BKNUM,BKDEN,
     *         RESIDO,RESIDS,RESIDC,ZRESO,ZRESS,ZRESC,
     *         NROT,NSTATS,NDETLN,NNSTAT,
     *         NUNIQ,NXYZ,NOCP,
     *         PDIRO,PDIRS,PDIRC,
     *         NDETMX,JLO,JHI)
        ENDIF
C
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     CHECK CONVERGENCE
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
        ERR = ZERO
        IUNIQ = 0
        DO 10 IXYZ=1,NXYZ
          IF(NOCP(IXYZ).NE.1) IUNIQ=IUNIQ+1
          IF(NOCP(IXYZ).NE.0) GO TO 10
          CALL CPRNORM(2186,RESIDO,RESIDS,RESIDC,
     *                    NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *                    IUNIQ,TOL,TEST,ERR,
     *                    BNORMO,BNORMC,BNORMS,NDETMX)
          IF(TEST.LT.TOL) NOCP(IXYZ) = 2
   10   CONTINUE
C
C       FIND UNCONVERGED VECTORS
        NXYZF = 0
        DO IXYZ = 1,NXYZ
          IF (NOCP(IXYZ).EQ.0) NXYZF = NXYZF+1
        END DO
C
C       PRINT OFF IMPROVED RESPONSES.
        IF (MASWRK) THEN
          WRITE(IW,9020) ITER,ERR,NXYZF,TIMORB,TIMCI
          CALL FLSHBF(IW)
        ENDIF
C
C       EXIT SUB.
        IF(ERR.LT.TOL.AND.CGCONV) GO TO 800
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     IF RESIDUAL NORM. TOO LARGE, SET THE INITIAL
C     GUESS YAX VECTOR TO THE 0 VECTOR. 
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
      IF(ZGUESS .AND. ERR.GT.1.0D+00) THEN
        CALL VCLR(YAO,1,NUNIQ*NROT)
        CALL VCLR(YAS,1,NUNIQ*NNSTAT)
        CALL VCLR(YAC,1,NUNIQ*NDETLN*NSTATS)
        ZGUESS=.FALSE.
        IF(MASWRK) WRITE(IW,9100)
        CALL FLSHBF(IW)
        GO TO 3
      ENDIF
C
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     CALCULATE COEF. BK AND DIRECTION VECTOR PDIR
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
        CALL CPMKBK(2173,BKNUM,
     *       RESIDO,RESIDS,RESIDC,ZRESO,ZRESS,ZRESC,
     *       NROT,NSTATS,NDETLN,NNSTAT,
     *       NUNIQ,NXYZ,NOCP)
C
C
        ITMP = IPDIR + 1
        IF (ITER.EQ.2
     *  .OR. MOD(ITER,ITMP).EQ.0
     *  ) THEN
          IF (GOPARR) CALL VCLR(PDIRC,1,NUNIQ*NDETMX*NSTATS)
          CALL VCLR(PDIRO,1,NUNIQ*NROT)
          CALL VCLR(PDIRS,1,NUNIQ*NNSTAT)
        ELSE
          IF (GOPARR) CALL DSCAL(NUNIQ*NDETMX*NSTATS,ONE/NPROC,PDIRC,1)
        ENDIF
C
C
        IUNIQ = 0
        DO 20 IXYZ=1,NXYZ
          IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
          IF(NOCP(IXYZ).NE.0) GO TO 20
          BK = BKNUM(IUNIQ)/BKDEN(IUNIQ)
C         NOTE:  NEXT IS NDETMX INSTEAD...
          CALL CPDSCAL(PDIRO,PDIRS,PDIRC,
     *         NUNIQ,NROT,NSTATS,NDETMX,NNSTAT,
     *         IUNIQ,BK)
          CALL CPMKPDIR(ZRESO,ZRESS,ZRESC,PDIRO,PDIRS,PDIRC,
     *         NUNIQ,IUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *         NDETMX,JLO,JHI,1)
C
C         SAVE THE OLD COEFFICIENTS AFTER USE
          BKDEN(IUNIQ) = BKNUM(IUNIQ)
  20    CONTINUE
        IF(GOPARR) CALL DDI_GSUMF(2172,PDIRC,NUNIQ*NDETMX*NSTATS)
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     CALCULATE COEFFICNET AK, NEW ITERATE YA,
C     NEW RESIDUAL RESID, AND NEW PSEUDO-RESIDUAL ZRES
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C       NOTE:  CANNOT SWITCH BACK TO SYM. HERE
        CALL CPMATVEC_NOSYM(2169,
     *       ZRESC,ZRESO,ZRESS,
     *       PDIRO,EPS,OPDM,TPDM,IA,L0,
     *       PDIRC,PDIRS,PRCNDS,SALAG,
     *       CI,OINT,FCORSQ,AMAT,ERI,INDEX,IWRK,IFA,IOX,NCOR,NACT,
     *       NA,NB,L1,L2,NSYM,IIS,NDETMX,NDETLN,NROT,NUNIQ,JLO,JHI,
     *       NSTATS,WSTATE,WRK,YADEN,AVEC,BVEC,YAOTMP,ITERX,GENMC,
     *       LNEED,LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,ITGA,ITGB,IAST,
     *       IBST,NB1EX,JROTLO,JROTHI,
     *       NNSTAT,
     *       TIMCI,TIMORB)
C
        ITERX = ITERX + 1
C
C
        IUNIQ = 0
        DO 30 IXYZ=1,NXYZ
          IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
          IF(NOCP(IXYZ).NE.0) GO TO 30
C
C         MAKE LINE SEARCH COEFF. 'AK'
          CALL CPMKAKDEN(AKDEN,PDIRO,PDIRS,PDIRC,
     *         ZRESO,ZRESS,ZRESC,
     *         NUNIQ,NROT,NSTATS,NNSTAT,
     *         NDETMX,NDETLN,
     *         JLO,JHI,IUNIQ,2171)
          AK = BKNUM(IUNIQ)/AKDEN
C
          CALL CPMKYAX(PDIRO,PDIRS,PDIRC,YAO,YAS,YAC,
     *         NUNIQ,IUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *         NDETMX,JLO,JHI,AK,1)
          CALL CPDAXPY(ZRESO,ZRESS,ZRESC,RESIDO,RESIDS,RESIDC,
     *         NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *         IUNIQ,-AK)
C
          CALL CPMKPRES(RESIDO,RESIDS,RESIDC,ZRESO,ZRESS,ZRESC,
     *         PRCNDO,PRCNDS,PRCNDC,
     *         NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *         JLO,JHI,IUNIQ)
C
  30    CONTINUE
C
C
C
  400 CONTINUE
C 
C     ----- End overall iterations for CPCG ----
C
  800 CONTINUE
C
C
C
C
 9020 FORMAT(1X,I3,4X,1P,E13.5,0P,4X,I6,8X,F7.1,4X,F7.1)
 9021 FORMAT(1X,'RESET PDIRX AND RESIDUAL.')
 9075 FORMAT(1X,'DUE TO SLOW CONVERGENCE, TOLERANCE HAS BEEN',
     *       1X,'RAISED TO ',1P,E8.2)
 9100 FORMAT(1X,'DUE TO LARGE RES. NORM, GUESS SET TO 0 VECTOR.')
C 9720 FORMAT(/2X,'iuniq=',I3,2X,'bnorm=',F18.12)
C 9721 FORMAT(/2X,'iuniq=',I3,2X,'test=',F18.12)
      RETURN
      END
C*MODULE CPMCHF  *DECK CPGCRODR
      SUBROUTINE CPGCRODR(RECLIN,ITER,NUNIQT,NSORT,
     *       ZZRESO,ZZRESS,ZZRESC,
     *       YAO,YAC,YAS,
     *       PRCNDO,PRCNDC,PRCNDS,RESIDO,RESIDC,
     *       RESIDS,ZRESO,ZRESC,ZRESS,PDIRO,PDIRC,PDIRS,
     *       BKNUM,BKDEN,OINT,AMAT,ERI,EPS,OPDM,
     *       BNORMO,BNORMC,BNORMS,
     *       TPDM,CI,WRK,INDEX,IA,IWRK,IFA,IOX,NOCP,
     *       NXYZ,NUNIQ,NROT,NDETLN,NDETMX,IIS,JLO,JHI,NA,
     *       NB,NSYM,NCOR,NACT,L0,L1,L2,NFT18,NFT19,NSTATS,
     *       WSTATE,EGRAD,SALAG,YADEN,AVEC,BVEC,FCORSQ,
     *       YAOTMP,GENMC,LNEED,LBOX1,LBOX2,LBOX3,LBOX4,
     *       LBOX5,ITGA,ITGB,IAST,IBST,NB1EX,JROTLO,JROTHI,
     *       MICIT,KICIT,NOCC,TOL,MAXIT,NNSTAT,
     *       VMATO,VMATS,VMATC,
     *       CMATO,CMATS,CMATC,
     *       UMATO,UMATS,UMATC,
     *       WMATO,WMATS,WMATC,
     *       YMATO,YMATS,YMATC,
     *       HMAT,HMAT2,WKDGEL,BETA,BMAT,
     *       GMAT,IPVT,WRKMP,WRKK,
     *       QMAT,RMAT,RMATINV,
     *       PMAT,EVALR,EVALI,WRKD,
     *       NDER,NAPICK,NACST)
C
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL GENMC
      LOGICAL RECYC,RECLIN
      LOGICAL NAPICK
      LOGICAL ZGUESS
      LOGICAL CGINIT
C
      DIMENSION NSORT(NUNIQT)
      DIMENSION ZZRESO(NUNIQ,NROT),
     *          ZZRESS(NUNIQ,*),
     *          ZZRESC(NUNIQ,NDETLN*NSTATS)
      DIMENSION CMATO(NUNIQ,NROT,KICIT),
     *          CMATS(NUNIQ,NNSTAT,KICIT),
     *          CMATC(NUNIQ,NDETLN*NSTATS,KICIT),
     *          UMATO(NUNIQ,NROT,KICIT),
     *          UMATS(NUNIQ,NNSTAT,KICIT),
     *          UMATC(NUNIQ,NDETLN*NSTATS,KICIT),
     *          BMAT(KICIT,MICIT,NUNIQ),
     *          IPVT(MICIT),WRKMP(MICIT+1),WRKK(KICIT),
     *          QMAT(MICIT+1,MICIT),
     *          RMAT(MICIT,MICIT),
     *          RMATINV(MICIT,MICIT),
     *          PMAT(MICIT,KICIT),
     *          EVALR(MICIT),EVALI(MICIT),
     *          WRKD(8*MICIT)
      DIMENSION YMATO(NUNIQ,NROT,KICIT),
     *          YMATS(NUNIQ,NNSTAT,KICIT),
     *          YMATC(NUNIQ,NDETLN*NSTATS,KICIT),
     *          WMATO(NUNIQ,NROT,MICIT+1),
     *          WMATS(NUNIQ,NNSTAT,MICIT+1),
     *          WMATC(NUNIQ,NDETLN*NSTATS,MICIT+1)
      DIMENSION VMATO(NUNIQ,NROT,MICIT+1),
     *          VMATS(NUNIQ,NNSTAT,MICIT+1),
     *          VMATC(NUNIQ,NDETLN*NSTATS,MICIT+1),
     *          HMAT(MICIT+1,MICIT,NUNIQ),
     *          HMAT2(MICIT+1,MICIT),
     *          GMAT(MICIT+1,MICIT),
     *          WKDGEL(2*(MICIT+1)*MICIT),BETA(MICIT+1)
      DIMENSION YAO(NUNIQ,NROT),YAC(NUNIQ,NSTATS*NDETLN),YAS(NUNIQ,*),
     *          PRCNDO(NROT),PRCNDC(NSTATS*NDETLN),PRCNDS(*),
     *          RESIDO(NUNIQ,NROT),RESIDC(NUNIQ,NSTATS*NDETLN),
     *          RESIDS(NUNIQ,*),ZRESO(NUNIQ,NROT),
     *          ZRESC(NUNIQ,NSTATS*NDETLN),ZRESS(NUNIQ,*),
     *          PDIRO(NUNIQ,NROT),PDIRC(NUNIQ,NSTATS*NDETMX),
     *          PDIRS(NUNIQ,*),BKNUM(NUNIQ),BKDEN(NUNIQ),
     *          BNORMO(NUNIQ),BNORMC(NUNIQ),BNORMS(NUNIQ),
     *          OINT(L2),AMAT(*),ERI(*),EPS(L1,L1),OPDM(*),
     *          TPDM(*),CI(NDETMX,NSTATS),WRK(*),
     *          WSTATE(*),EGRAD(*),SALAG(L1,L1,NSTATS*NSTATS),
     *          YADEN(*),AVEC(*),BVEC(*),FCORSQ(L1,L1),YAOTMP(*)
      DIMENSION INDEX(L1,L1),IA(*),IWRK(IIS),IFA(0:NACT,0:NACT),
     *          IOX(NACT),NOCP(NXYZ)
      DIMENSION LBOX1(*),LBOX2(*),LBOX3(*),LBOX4(*),LBOX5(*)
C
      PARAMETER (MXRT=100)
      DIMENSION NACST(MXRT*(MXRT-1))
C
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00)
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     INITIALIZATIONS FOR RECYCLING PIECE OF GCRO-DR
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C     INITIALIZE ITERX...
      ITERX=1
C
C     INITIALIZE VARIABLE FOR ZERO GUESS
      ZGUESS=.TRUE.
    3 CONTINUE
C
C     INITIALIZE FOR RECYCLING
C     NOTE:  VAR INDICATES IF CURRENTLY RECYCLING VECTORS
      RECYC=.FALSE.
C
C     ACCORDINGLY INITIALIZE NOCP
      IF(RECLIN) THEN
        DO IXYZ=2,NXYZ
          IF(NOCP(IXYZ).NE.1) NOCP(IXYZ) = 2
        ENDDO
      ELSE
        DO IXYZ=1,NXYZ
          IF(NOCP(IXYZ).NE.1) NOCP(IXYZ) = 0
        ENDDO
C       ACCOUNT FOR USER SELECTED NACME
        IF (NAPICK)
     *     CALL CPNAPICK(NACST,NSTATS,NOCP,NXYZ)
      ENDIF
C
      NXYZF = 0
      DO IXYZ = 1,NXYZ
        IF (NOCP(IXYZ).EQ.0) NXYZF = NXYZF+1
      END DO
C
C
C     DEFINE YAX BASED ON RECYCLING...
  399 CONTINUE
      IF (RECYC.AND.RECLIN) THEN
        IUNIQ = 1
        DO 10 IXYZ=2,NXYZ
C         CHANGE VECTORS BACK...
          IF(NOCP(IXYZ).EQ.2) NOCP(IXYZ) = 0
          IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
          IF(NOCP(IXYZ).NE.0) GO TO 10 
C         COPY REQUIRED VECTORS OVER...
          CALL DCOPY(NROT,YAO(1,1),NUNIQ,
     *                    YAO(IUNIQ,1),NUNIQ)
          CALL DCOPY(NNSTAT,YAS(1,1),NUNIQ,
     *                      YAS(IUNIQ,1),NUNIQ)
          CALL DCOPY(NDETLN*NSTATS,YAC(1,1),NUNIQ,
     *                             YAC(IUNIQ,1),NUNIQ)
          DO I=1,KICIT
           CALL CPDCOPYREC(
     *          CMATO(1,1,I),CMATS(1,1,I),CMATC(1,1,I),
     *          CMATO(1,1,I),CMATS(1,1,I),CMATC(1,1,I),
     *          NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *          IUNIQ)
           CALL CPDCOPYREC(
     *          UMATO(1,1,I),UMATS(1,1,I),UMATC(1,1,I),
     *          UMATO(1,1,I),UMATS(1,1,I),UMATC(1,1,I),
     *          NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *          IUNIQ)
          ENDDO
   10   CONTINUE
C
C       ACCOUNT FOR USER SELECTED NACME
        IF (NAPICK)
     *    CALL CPNAPICK(NACST,NSTATS,NOCP,NXYZ)
C
C       NXYZF INDICATES UN-CONVERGED VECTORS FOR THE PRINT OUT
        NXYZF = 0
        DO IXYZ = 1,NXYZ
          IF (NOCP(IXYZ).EQ.0) NXYZF = NXYZF+1
        END DO
C
      ENDIF
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     FORM TRUE RESIDUAL AND
C     APPLY SYM. TO VECTORS AND MAT.-VEC. PROD.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
      CALL CPINIT1(2182,2183,2184,CGINIT,
     *     NDER,NXYZF,NUNIQT,NFT18,NFT19,EGRAD,NSORT,NOCP,NOCC,
     *     YAC,YAO,YAS,
     *     ZRESC,ZRESO,ZRESS,
     *     ZZRESC,ZZRESO,ZZRESS,
     *     RESIDC,RESIDO,RESIDS,
     *     PDIRO,EPS,OPDM,TPDM,IA,L0,
     *     PDIRC,PDIRS,PRCNDS,SALAG,
     *     CI,OINT,FCORSQ,AMAT,ERI,INDEX,IWRK,IFA,IOX,NCOR,NACT,
     *     NA,NB,L1,L2,NSYM,IIS,NDETMX,NDETLN,NROT,NUNIQ,JLO,JHI,
     *     NSTATS,WSTATE,WRK,YADEN,AVEC,BVEC,YAOTMP,ITERX,GENMC,
     *     LNEED,LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,ITGA,ITGB,IAST,
     *     IBST,NB1EX,JROTLO,JROTHI,
     *     PRCNDO,PRCNDC,
     *     NNSTAT,NXYZ,
     *     TIMCI,TIMORB)
C
C     DON'T WASTE TIME WITH EXTRA FROM ITER BEING 1 MANY TIMES!
      ITERX=ITERX + 1
C
        ERR = ZERO
        IUNIQ = 0
        DO 15 IXYZ=1,NXYZ
          IF(NOCP(IXYZ).NE.1) IUNIQ=IUNIQ+1
          IF(NOCP(IXYZ).NE.0) GO TO 15
          CALL CPRNORM(2185,RESIDO,RESIDS,RESIDC,
     *                    NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *                    IUNIQ,TOL,TEST,ERR,
     *                    BNORMO,BNORMC,BNORMS,NDETMX)
          IF(TEST.LT.TOL) NOCP(IXYZ) = 2
  15   CONTINUE
C
C
C       NXYZF INDICATES UN-CONVERGED VECTORS FOR THE PRINT OUT
        NXYZF = 0
        DO IXYZ = 1,NXYZ
          IF (NOCP(IXYZ).EQ.0) NXYZF = NXYZF+1
        END DO
C
C
        IF (MASWRK) THEN
C         PRINT OFF IMPROVED RESPONSES.
          WRITE(IW,9020) 1,ERR,NXYZF,TIMORB,TIMCI
          CALL FLSHBF(IW)
        END IF
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     IF RESIDUAL NORM. TOO LARGE, SET THE INITIAL
C     GUESS YAX VECTOR TO THE 0 VECTOR.
C     NOTE:
C     FOR GCRO-DR, PREVENT FOR >1ST SYSTEM.
C     RECYCLING MIGHT START WITH LARGER RES. NORM.,
C     BUT IT SUPPOSEDLY LEADS TO LESS ITERS.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
      IF(.NOT.RECYC.AND.ZGUESS.AND.ERR.GT.1.0D+00) THEN
        CALL VCLR(YAO,1,NUNIQ*NROT)
        CALL VCLR(YAS,1,NUNIQ*NNSTAT)
        CALL VCLR(YAC,1,NUNIQ*NDETLN*NSTATS)
        ZGUESS=.FALSE.
        IF(MASWRK) WRITE(IW,9100)
        CALL FLSHBF(IW)
        GO TO 3
      ENDIF
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     CONTINUE WITH GCRO-DR ALG.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C
      IF (RECYC) THEN
        CALL CPPROJYAX(2181,
     *       CMATO,CMATS,CMATC,
     *       UMATO,UMATS,UMATC,
     *       YAO,YAC,YAS,
     *       RESIDO,RESIDC,RESIDS,
     *       ZRESO,ZRESC,ZRESS,
     *       PRCNDO,PRCNDC,PRCNDS,
     *       ZZRESO,ZZRESS,ZZRESC,
     *       NXYZ,NUNIQ,NROT,NDETLN,NSTATS,NNSTAT,
     *       JLO,JHI,
     *       NOCP,KICIT,WRKK)
C
C     IF-THEN RECYCLE
      ELSE
C
C       CALL 1 CYCLE OF GMRES(MICIT)
        CALL CPGMRES1(ITERX,CGINIT,
     *       ZZRESO,ZZRESS,ZZRESC,
     *       YAO,YAC,YAS,
     *       PRCNDO,PRCNDC,PRCNDS,RESIDO,RESIDC,
     *       RESIDS,ZRESO,ZRESC,ZRESS,PDIRO,PDIRC,PDIRS,
     *       BKNUM,BKDEN,OINT,AMAT,ERI,EPS,OPDM,
     *       TPDM,CI,WRK,INDEX,IA,IWRK,IFA,IOX,NOCP,
     *       NXYZ,NUNIQ,NROT,NDETLN,NDETMX,IIS,JLO,JHI,NA,
     *       NB,NSYM,NCOR,NACT,L0,L1,L2,NSTATS,
     *       WSTATE,SALAG,YADEN,AVEC,BVEC,FCORSQ,
     *       YAOTMP,GENMC,LNEED,LBOX1,LBOX2,LBOX3,LBOX4,
     *       LBOX5,ITGA,ITGB,IAST,IBST,NB1EX,JROTLO,JROTHI,
     *       VMATO,VMATS,VMATC,
     *       HMAT,HMAT2,
     *       WKDGEL,BETA,
     *       MICIT,NNSTAT,
     *       WRKMP,NXYZF)
C       NOTE:  PROPER YAX AND RESIDX ALREADY DEFINED IN CALL CPGMRES1
C
C
C
C
        IUNIQ = 0
        DO 40 IXYZ=1,NXYZ
          IF(NOCP(IXYZ).NE.1) IUNIQ=IUNIQ+1
          IF(NOCP(IXYZ).NE.0) GO TO 40 
C
C         COMPUTE K HARMONIC RITZ VECTORS AND STORE IN PMAT
C         REG. EVALUE PROBLEM
          CALL CPEIGEN(HMAT(1,1,IUNIQ),HMAT2,
     *         IPVT,WRKMP,WRKD,WKDGEL,
     *         RMAT,RMATINV,EVALR,EVALI,
     *         PMAT,MICIT,KICIT,0)
C
C         DEFINE YMATX
          DO I=1,KICIT
            CALL CPMATVEC2(
     *           VMATO,VMATS,VMATC,
     *           YMATO(1,1,I),YMATS(1,1,I),YMATC(1,1,I),
     *           PMAT(1,I),
     *           NROT,NSTATS,NDETLN,NNSTAT,
     *           IUNIQ,NUNIQ,
     *           MICIT+1,MICIT,
     *           1,MICIT)
          ENDDO
C
C         QR-FACTORIZATION OF HMAT*PMAT
          CALL CPQRPROJ(
     *         HMAT2,HMAT(1,1,IUNIQ),IPVT,WRKMP,WRKK,
     *         RMATINV,QMAT,PMAT,MICIT,KICIT)
C
C         DEFINE CMAT
          DO I=1,KICIT
            CALL CPMATVEC2(
     *           VMATO,VMATS,VMATC,
     *           CMATO(1,1,I),CMATS(1,1,I),CMATC(1,1,I),
     *           QMAT(1,I),
     *           NROT,NSTATS,NDETLN,NNSTAT,
     *           IUNIQ,NUNIQ,
     *           MICIT+1,MICIT+1,
     *           1,MICIT+1)
          ENDDO
C
C         DEFINE UMAT
          DO I=1,KICIT
            CALL CPMATVEC2(
     *           YMATO,YMATS,YMATC,
     *           UMATO(1,1,I),UMATS(1,1,I),UMATC(1,1,I),
     *           RMATINV(1,I),
     *           NROT,NSTATS,NDETLN,NNSTAT,
     *           IUNIQ,NUNIQ,
     *           KICIT,KICIT,
     *           1,KICIT)
          ENDDO
   40   CONTINUE

C     IF-THEN RECYCLE
      ENDIF
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     BEGIN GCRODR ITERATIONS 
C     NESTED IN OVERALL ITERATIONS
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
      DO 400 ITER=2,MAXIT
C
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     FORM TRUE RESIDUAL AND
C     APPLY SYM. TO VECTORS AND MAT.-VEC. PROD.
C     NOTE:  THIS NEXT MATVEC ADDED TO PREVENT 
C            ROUNDING ERRORS IN THE FAKE UPDATES BELOW
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C
C
        CALL CPINIT1(2182,2183,2184,CGINIT,
     *       NDER,NXYZF,NUNIQT,NFT18,NFT19,EGRAD,NSORT,NOCP,NOCC,
     *       YAC,YAO,YAS,
     *       ZRESC,ZRESO,ZRESS,
     *       ZZRESC,ZZRESO,ZZRESS,
     *       RESIDC,RESIDO,RESIDS,
     *       PDIRO,EPS,OPDM,TPDM,IA,L0,
     *       PDIRC,PDIRS,PRCNDS,SALAG,
     *       CI,OINT,FCORSQ,AMAT,ERI,INDEX,IWRK,IFA,IOX,NCOR,NACT,
     *       NA,NB,L1,L2,NSYM,IIS,NDETMX,NDETLN,NROT,NUNIQ,JLO,JHI,
     *       NSTATS,WSTATE,WRK,YADEN,AVEC,BVEC,YAOTMP,ITERX,GENMC,
     *       LNEED,LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,ITGA,ITGB,IAST,
     *       IBST,NB1EX,JROTLO,JROTHI,
     *       PRCNDO,PRCNDC,
     *       NNSTAT,NXYZ,
     *       TIMCI,TIMORB)
C
C       DON'T WASTE TIME WITH EXTRA FROM ITER BEING 1 MANY TIMES!
        ITERX=ITERX + 1
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     CHECK CONVERGENCE
C     AND
C     FORM TRUE RESIDUAL NORM SQUARED
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
        ERR = ZERO
        IUNIQ = 0
        DO 50 IXYZ=1,NXYZ
          IF(NOCP(IXYZ).NE.1) IUNIQ=IUNIQ+1
          IF(NOCP(IXYZ).NE.0) GO TO 50 
          CALL CPRNORM(2185,RESIDO,RESIDS,RESIDC,
     *                    NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *                    IUNIQ,TOL,TEST,ERR,
     *                    BNORMO,BNORMC,BNORMS,NDETMX)
          IF(TEST.LT.TOL) NOCP(IXYZ) = 2
  50   CONTINUE
C
C
C       NXYZF INDICATES UN-CONVERGED VECTORS FOR THE PRINT OUT
        NXYZF = 0
        DO IXYZ = 1,NXYZ
          IF (NOCP(IXYZ).EQ.0) NXYZF = NXYZF+1
        END DO
C
C
        IF (MASWRK) THEN
C         PRINT OFF IMPROVED RESPONSES.
          WRITE(IW,9020) ITER,ERR,NXYZF,TIMORB,TIMCI
          CALL FLSHBF(IW)
        END IF
        IF (.NOT.RECLIN) THEN
          RECYC=.TRUE.
        ENDIF
        IF(ERR.LT.TOL .AND. .NOT.RECYC) THEN
          RECYC=.TRUE.
          GO TO 399
        ENDIF
        IF(ERR.LT.TOL .AND. RECYC) GO TO 800
        IF(ERR.GT.1.0D+15) THEN
          IF (MASWRK) WRITE(IW,9022)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C         SET VMAT_1 = NORM. RESIDUAL
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
          CALL CPMKBK(2169,BKNUM,
     *         RESIDO,RESIDS,RESIDC,
     *         RESIDO,RESIDS,RESIDC,
     *         NROT,NSTATS,NDETLN,NNSTAT,
     *         NUNIQ,NXYZ,NOCP)
          IUNIQ = 0
          DO 60 IXYZ=1,NXYZ
            IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
            IF(NOCP(IXYZ).NE.0) GO TO 60 
C
            BKNUM(IUNIQ) = SQRT( BKNUM(IUNIQ) )
C
            CALL CPDCOPY(
     *           RESIDO,RESIDS,RESIDC,
     *           VMATO(1,1,KICIT+1),
     *           VMATS(1,1,KICIT+1),
     *           VMATC(1,1,KICIT+1),
     *           NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *           IUNIQ)
            CALL CPDSCAL(
     *           VMATO(1,1,KICIT+1),
     *           VMATS(1,1,KICIT+1),
     *           VMATC(1,1,KICIT+1),
     *           NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *           IUNIQ,ONE/BKNUM(IUNIQ))

   60     CONTINUE
C
C         CLEAR OUT SOME NEEDED ITEMS (MAYBE)
          CALL VCLR(HMAT,1,(MICIT+1)*MICIT*NUNIQ)
          CALL VCLR(BMAT,1,KICIT*MICIT*NUNIQ)
C
C         PERFORM ARNOLDI WITH MODIFIED LINEAR OPERATOR
          KICITP = KICIT + 1
          DO 888 MICRO=KICITP,MICIT
C
C           RIGHT PRECONDITION PDIRX...
            IUNIQ=0
            DO 70 IXYZ=1,NXYZ
              IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
              IF(NOCP(IXYZ).NE.0) GO TO 70 
              CALL CPMKPRES(
     *             VMATO(1,1,MICRO),
     *             VMATS(1,1,MICRO),
     *             VMATC(1,1,MICRO),
     *             ZRESO,ZRESS,ZRESC,
     *             PRCNDO,PRCNDS,PRCNDC,
     *             NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *             JLO,JHI,IUNIQ)
   70       CONTINUE
C
            CALL CPMATVEC(2170,2171,CGINIT,
     *           ZRESC,ZRESO,ZRESS,
     *           NXYZF,NXYZ,NOCP,
     *           ZZRESC,ZZRESO,ZZRESS,
     *           PDIRO,EPS,OPDM,TPDM,IA,L0,
     *           PDIRC,PDIRS,PRCNDS,SALAG,
     *           CI,OINT,FCORSQ,AMAT,ERI,INDEX,IWRK,IFA,IOX,NCOR,NACT,
     *           NA,NB,L1,L2,NSYM,IIS,NDETMX,NDETLN,NROT,NUNIQ,JLO,JHI,
     *           NSTATS,WSTATE,WRK,YADEN,AVEC,BVEC,YAOTMP,ITERX,GENMC,
     *           LNEED,LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,ITGA,ITGB,IAST,
     *           IBST,NB1EX,JROTLO,JROTHI,
     *           NNSTAT,
     *           TIMCI,TIMORB)
C
          ITERX = ITERX + 1
C
C         MODIFIED PIECE IN MODIFIED ARNOLDI...
          DO 80 III=1,KICIT
            CALL CPMKBK(2172,BKDEN,
     *           CMATO(1,1,III),
     *           CMATS(1,1,III),
     *           CMATC(1,1,III),
     *           ZRESO,ZRESS,ZRESC,
     *           NROT,NSTATS,NDETLN,NNSTAT,
     *           NUNIQ,NXYZ,NOCP)

            IUNIQ = 0
            DO 90 IXYZ=1,NXYZ
              IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
              IF(NOCP(IXYZ).NE.0) GO TO 90 
              BMAT(III,MICRO,IUNIQ) = BKDEN(IUNIQ)
              CALL CPDAXPY(
     *             CMATO(1,1,III),
     *             CMATS(1,1,III),
     *             CMATC(1,1,III),
     *             ZRESO,ZRESS,ZRESC,
     *             NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *             IUNIQ,-BKDEN(IUNIQ))
   90       CONTINUE

   80     CONTINUE
C
C         BEGIN 2ND LOOP FOR MICROITERS
          DO 999 MICRO2=KICITP,MICRO
            CALL CPMKBK(2175,BKDEN,
     *           VMATO(1,1,MICRO2),
     *           VMATS(1,1,MICRO2),
     *           VMATC(1,1,MICRO2),
     *           ZRESO,ZRESS,ZRESC,
     *           NROT,NSTATS,NDETLN,NNSTAT,
     *           NUNIQ,NXYZ,NOCP)
C
C           FORM MOST OF HESSENBERG MATRIX
            IUNIQ = 0
            DO 100 IXYZ=1,NXYZ
              IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
              IF(NOCP(IXYZ).NE.0) GO TO 100 
              HMAT(MICRO2,MICRO,IUNIQ) = BKDEN(IUNIQ)
              CALL CPDAXPY(
     *             VMATO(1,1,MICRO2),
     *             VMATS(1,1,MICRO2),
     *             VMATC(1,1,MICRO2),
     *             ZRESO,ZRESS,ZRESC,
     *             NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *             IUNIQ,-BKDEN(IUNIQ))
  100       CONTINUE
C
C         END MICRO2 LOOP
  999     CONTINUE
C
C         FORM LAST PIECES OF HESSENBERG AND KRYLOV SPACE
          CALL CPMKBK(2177,BKDEN,
     *         ZRESO,ZRESS,ZRESC,ZRESO,ZRESS,ZRESC,
     *         NROT,NSTATS,NDETLN,NNSTAT,
     *         NUNIQ,NXYZ,NOCP)
          IUNIQ = 0
            DO 110 IXYZ=1,NXYZ
              IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
              IF(NOCP(IXYZ).NE.0) GO TO 110 
C             FINISH MAKING NORM OF ZRESX FROM BEFORE...
              BKDEN(IUNIQ) = SQRT( BKDEN(IUNIQ) )
              HMAT(MICRO+1,MICRO,IUNIQ) = BKDEN(IUNIQ)
              CALL CPDCOPY(
     *             ZRESO,ZRESS,ZRESC,
     *             VMATO(1,1,MICRO+1),
     *             VMATS(1,1,MICRO+1),
     *             VMATC(1,1,MICRO+1),
     *             NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *             IUNIQ)
              CALL CPDSCAL(
     *             VMATO(1,1,MICRO+1),
     *             VMATS(1,1,MICRO+1),
     *             VMATC(1,1,MICRO+1),
     *             NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *             IUNIQ,ONE/BKDEN(IUNIQ))

  110       CONTINUE
C
C         END ALL MICRO LOOPS
  888     CONTINUE
C
C         BEGIN LARGE IUNIQ LOOP 
C         NOTE:  LEAST SQUARES CONTAINED WITHIN THIS LOOP LATER...
          IUNIQ = 0
          DO 444 IXYZ=1,NXYZ
            IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
            IF(NOCP(IXYZ).NE.0) GO TO 444 
C
C           CLEAR SOME NEEDED ITEMS
            CALL VCLR(GMAT,1,(MICIT+1)*MICIT)
C
C           FIND DIAGONAL SCALING MATRIX FOR UMATX
C           AND
C           NORM. UMATX
            DO I=1,KICIT
              CALL CPMKNORM(2179,
     *             UMATO(1,1,I),UMATS(1,1,I),UMATC(1,1,I),
     *             NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *             IUNIQ,TMP)
              TMP = ONE/TMP
              GMAT(I,I) = TMP
              CALL CPDSCAL(
     *             UMATO(1,1,I),UMATS(1,1,I),UMATC(1,1,I),
     *             NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *             IUNIQ,TMP)
              CALL CPDCOPY(
     *             UMATO(1,1,I),UMATS(1,1,I),UMATC(1,1,I),
     *             VMATO(1,1,I),VMATS(1,1,I),VMATC(1,1,I),
     *             NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *             IUNIQ)
            ENDDO
C
C           FORM WMAT
            DO I=1,KICIT
              CALL CPDCOPY(
     *             CMATO(1,1,I),CMATS(1,1,I),CMATC(1,1,I),
     *             WMATO(1,1,I),WMATS(1,1,I),WMATC(1,1,I),
     *             NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *             IUNIQ)
            ENDDO
C
            KICITP = KICIT + 1
            MICITP = MICIT + 1
            DO I=KICITP,MICITP
              CALL CPDCOPY(
     *             VMATO(1,1,I),VMATS(1,1,I),VMATC(1,1,I),
     *             WMATO(1,1,I),WMATS(1,1,I),WMATC(1,1,I),
     *             NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *             IUNIQ)
            ENDDO
C
C           FORM THE REST OF GMAT
            KICITP = KICIT + 1
            MICITP = MICIT + 1
            KICIT2 = MICIT - KICIT + 1
            DO J=KICITP,MICITP
              CALL DCOPY(KICIT,BMAT(1,J,IUNIQ),1,GMAT(1,J),1)
              CALL DCOPY(KICIT2,HMAT(KICITP,J,IUNIQ),1,GMAT(KICITP,J),1)
            ENDDO
C
C           FORM WMAT*RESIDX VECTOR FOR LEAST SQUARES
            MICITP = MICIT + 1
            DO I=1,MICITP
              CALL CPMKDOT(2181,
     *             WMATO(1,1,I),WMATS(1,1,I),WMATC(1,1,I),
     *             RESIDO,RESIDS,RESIDC,
     *             NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *             IUNIQ,TMP)
              BETA(I) = TMP
            ENDDO
C
C           SOLVE LEAST SQUARES
            CALL DCOPY((MICIT+1)*MICIT,GMAT,1,HMAT2,1)
            CALL DGELS('N',MICIT+1,MICIT,1,
     *                  HMAT2,MICIT+1,
     *                  BETA,MICIT+1,WKDGEL,
     *                  2*(MICIT+1)*MICIT,INFO)
C
C           UPDATE YAX
            CALL CPMATVEC2(
     *           VMATO,VMATS,VMATC,
     *           ZRESO,ZRESS,ZRESC,
     *           BETA,
     *           NROT,NSTATS,NDETLN,NNSTAT,
     *           IUNIQ,NUNIQ,
     *           MICIT+1,MICIT,
     *           1,MICIT)
            CALL CPMKPRES(
     *           ZRESO,ZRESS,ZRESC,
     *           ZZRESO,ZZRESS,ZZRESC,
     *           PRCNDO,PRCNDS,PRCNDC,
     *           NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *           JLO,JHI,IUNIQ)
            CALL CPDAXPY(
     *           ZZRESO,ZZRESS,ZZRESC,
     *           YAO,YAS,YAC,
     *           NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *           IUNIQ,ONE)
C
C           UPDATE RESIDX
            CALL MRARBR(GMAT,
     *                  MICIT+1,MICIT+1,MICIT,
     *                  BETA,MICIT+1,1,
     *                  WRKMP,MICIT+1)
            CALL CPMATVEC2(
     *           WMATO,WMATS,WMATC,
     *           ZRESO,ZRESS,ZRESC,
     *           WRKMP,
     *           NROT,NSTATS,NDETLN,NNSTAT,
     *           IUNIQ,NUNIQ,
     *           MICIT+1,MICIT,
     *           1,MICIT)
            CALL CPDAXPY(
     *           ZRESO,ZRESS,ZRESC,
     *           RESIDO,RESIDS,RESIDC,
     *           NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *           IUNIQ,-ONE)
C
C           SOME SETUP FOR GENERALIZED EIGENVALUE PROBLEM
C           FORM RHS MATRIX
            MICITP = MICIT + 1
            DO I=1,MICITP
              DO J=1,MICIT
                CALL CPMKDOT(2183,
     *               WMATO(1,1,I),WMATS(1,1,I),WMATC(1,1,I),
     *               VMATO(1,1,J),VMATS(1,1,J),VMATC(1,1,J),
     *               NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *               IUNIQ,TMP)
                HMAT2(I,J) = TMP
              ENDDO
            ENDDO
C
C           COMPUTE K HARMONIC RITZ VECTORS AND STORE IN PMAT
C           GEN. EVALUE PROBLEM
            CALL CPEIGEN(GMAT,HMAT2,
     *           IPVT,WRKMP,WRKD,WKDGEL,
     *           RMAT,RMATINV,EVALR,EVALI,
     *           PMAT,MICIT,KICIT,1)
C
C           DEFINE YMATX
            DO I=1,KICIT
              CALL CPMATVEC2(
     *             VMATO,VMATS,VMATC,
     *             YMATO(1,1,I),YMATS(1,1,I),YMATC(1,1,I),
     *             PMAT(1,I),
     *             NROT,NSTATS,NDETLN,NNSTAT,
     *             IUNIQ,NUNIQ,
     *             MICIT+1,MICIT,
     *             1,MICIT)
            ENDDO
C
C           QR-FACTORIZATION OF GMAT*PMAT
            CALL CPQRPROJ(
     *           HMAT2,GMAT,IPVT,WRKMP,WRKK,
     *           RMATINV,QMAT,PMAT,MICIT,KICIT)
C
C           DEFINE CMAT
            DO I=1,KICIT
              CALL CPMATVEC2(
     *             WMATO,WMATS,WMATC,
     *             CMATO(1,1,I),CMATS(1,1,I),CMATC(1,1,I),
     *             QMAT(1,I),
     *             NROT,NSTATS,NDETLN,NNSTAT,
     *             IUNIQ,NUNIQ,
     *             MICIT+1,MICIT+1,
     *             1,MICIT+1)
            ENDDO
C
C           DEFINE UMAT
            DO I=1,KICIT
              CALL CPMATVEC2(
     *             YMATO,YMATS,YMATC,
     *             UMATO(1,1,I),UMATS(1,1,I),UMATC(1,1,I),
     *             RMATINV(1,I),
     *             NROT,NSTATS,NDETLN,NNSTAT,
     *             IUNIQ,NUNIQ,
     *             KICIT,KICIT,
     *             1,KICIT)
            ENDDO
C
C         END LARGE IUNIQ LOOP
  444     CONTINUE
C
  400   CONTINUE
C
C     ----- End overall iterations for GCRODR                 ----
C
  800 CONTINUE
C
 9020 FORMAT(1X,I3,4X,1P,E13.5,0P,4X,I6,8X,F7.1,4X,F7.1)
 9022 FORMAT(1X,'TOLERANCE DIVERGING.  PLEASE RE-EXAMINE MICIT INPUT.')
 9100 FORMAT(1X,'DUE TO LARGE RES. NORM, GUESS SET TO 0 VECTOR.')
C 9720 FORMAT(/2X,'iuniq=',I3,2X,'bnorm=',F18.12)
C 9721 FORMAT(/2X,'iuniq=',I3,2X,'test=',F18.12)
      RETURN
      END
C*MODULE CPMCHF  *DECK CPGCRO
      SUBROUTINE CPGCRO(CPCOMBO,ERR,ITER,NUNIQT,NSORT,
     *       ZZRESO,ZZRESS,ZZRESC,
     *       YAO,YAC,YAS,
     *       PRCNDO,PRCNDC,PRCNDS,RESIDO,RESIDC,
     *       RESIDS,ZRESO,ZRESC,ZRESS,PDIRO,PDIRC,PDIRS,
     *       BKNUM,BKDEN,OINT,AMAT,ERI,EPS,OPDM,
     *       BNORMO,BNORMC,BNORMS,
     *       TPDM,CI,WRK,INDEX,IA,IWRK,IFA,IOX,NOCP,
     *       NXYZ,NUNIQ,NROT,NDETLN,NDETMX,IIS,JLO,JHI,NA,
     *       NB,NSYM,NCOR,NACT,L0,L1,L2,NFT18,NFT19,NSTATS,
     *       WSTATE,EGRAD,SALAG,YADEN,AVEC,BVEC,FCORSQ,
     *       YAOTMP,GENMC,LNEED,LBOX1,LBOX2,LBOX3,LBOX4,
     *       LBOX5,ITGA,ITGB,IAST,IBST,NB1EX,JROTLO,JROTHI,
     *       MICIT,KICIT,NOCC,TOL,MAXIT,NNSTAT,
     *       VMATO,VMATS,VMATC,
     *       CMATO,CMATS,CMATC,
     *       UMATO,UMATS,UMATC,
     *       HMAT,HMAT2,WKDGEL,
     *       BETA,BMAT,ZMAT,
     *       NDER,NAPICK,NACST) 
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL GENMC
      LOGICAL RESET
      LOGICAL CPCOMBO
      LOGICAL NAPICK
      LOGICAL ZGUESS
      LOGICAL CGINIT
C
      DIMENSION NSORT(NUNIQT)
      DIMENSION ZZRESO(NUNIQ,NROT),ZZRESS(NUNIQ,*),
     *          ZZRESC(NUNIQ,NDETLN*NSTATS)
      DIMENSION CMATO(NUNIQ,NROT,KICIT),
     *          CMATS(NUNIQ,NNSTAT,KICIT),
     *          CMATC(NUNIQ,NDETLN*NSTATS,KICIT),
     *          UMATO(NUNIQ,NROT,KICIT),
     *          UMATS(NUNIQ,NNSTAT,KICIT),
     *          UMATC(NUNIQ,NDETLN*NSTATS,KICIT),
     *          BMAT(KICIT,MICIT,NUNIQ),ZMAT(KICIT)
      DIMENSION VMATO(NUNIQ,NROT,MICIT+1),
     *          VMATS(NUNIQ,NNSTAT,MICIT+1),
     *          VMATC(NUNIQ,NDETLN*NSTATS,MICIT+1),
     *          HMAT(MICIT+1,MICIT,NUNIQ),HMAT2(MICIT+1,MICIT),
     *          WKDGEL(2*(MICIT+1)*MICIT),BETA(MICIT+1)
      DIMENSION YAO(NUNIQ,NROT),YAC(NUNIQ,NSTATS*NDETLN),YAS(NUNIQ,*),
     *          PRCNDO(NROT),PRCNDC(NSTATS*NDETLN),PRCNDS(*),
     *          RESIDO(NUNIQ,NROT),RESIDC(NUNIQ,NSTATS*NDETLN),
     *          RESIDS(NUNIQ,*),ZRESO(NUNIQ,NROT),
     *          ZRESC(NUNIQ,NSTATS*NDETLN),ZRESS(NUNIQ,*),
     *          PDIRO(NUNIQ,NROT),PDIRC(NUNIQ,NSTATS*NDETMX),
     *          PDIRS(NUNIQ,*),BKNUM(NUNIQ),BKDEN(NUNIQ),
     *          BNORMO(NUNIQ),BNORMC(NUNIQ),BNORMS(NUNIQ),
     *          OINT(L2),AMAT(*),ERI(*),EPS(L1,L1),OPDM(*),
     *          TPDM(*),CI(NDETMX,NSTATS),WRK(*),
     *          WSTATE(*),EGRAD(*),SALAG(L1,L1,NSTATS*NSTATS),
     *          YADEN(*),AVEC(*),BVEC(*),FCORSQ(L1,L1),YAOTMP(*)
      DIMENSION INDEX(L1,L1),IA(*),IWRK(IIS),IFA(0:NACT,0:NACT),
     *          IOX(NACT),NOCP(NXYZ)
      DIMENSION LBOX1(*),LBOX2(*),LBOX3(*),LBOX4(*),LBOX5(*)
C
      PARAMETER (MXRT=100)
      DIMENSION NACST(MXRT*(MXRT-1))
C
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00)
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     INITIALIZATIONS 
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C     INITIALIZE ITERX AND NOCP IF NEEDED...
C     ALSO, SET RESET AS NEEDED...
      IF (.NOT.CPCOMBO) THEN
        RESET = .TRUE.
        ITERX=1
      ELSE
        RESET = .FALSE.
        ITERX=2
      ENDIF
C
C     INITIALIZE VARIABLE FOR ZERO GUESS
      ZGUESS=.TRUE.
    3 CONTINUE
C
C     INITIALIZE UNCONVERGED SOLUTION VECTORS
      DO IXYZ=1,NXYZ
        IF(NOCP(IXYZ).NE.1) NOCP(IXYZ) = 0
      ENDDO
C     ACCOUNT FOR USER SELECTED NACME
      IF (NAPICK)
     *   CALL CPNAPICK(NACST,NSTATS,NOCP,NXYZ)
      NXYZF = 0
      DO IXYZ = 1,NXYZ
        IF (NOCP(IXYZ).EQ.0) NXYZF = NXYZF+1
      END DO
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     BEGIN OVERALL ITERATIONS
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
      DO 400 ITER=1,MAXIT
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     FORM TRUE RESIDUAL AND
C     APPLY SYM. TO VECTORS AND MAT.-VEC. PROD.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
  600   CONTINUE
        ITERARG = ITER
        CALL CPINIT1(2169,2170,2171,CGINIT,
     *       NDER,NXYZF,NUNIQT,NFT18,NFT19,EGRAD,NSORT,NOCP,NOCC,
     *       YAC,YAO,YAS,
     *       ZRESC,ZRESO,ZRESS,
     *       ZZRESC,ZZRESO,ZZRESS,
     *       RESIDC,RESIDO,RESIDS,
     *       PDIRO,EPS,OPDM,TPDM,IA,L0,
     *       PDIRC,PDIRS,PRCNDS,SALAG,
     *       CI,OINT,FCORSQ,AMAT,ERI,INDEX,IWRK,IFA,IOX,NCOR,NACT,
     *       NA,NB,L1,L2,NSYM,IIS,NDETMX,NDETLN,NROT,NUNIQ,JLO,JHI,
     *       NSTATS,WSTATE,WRK,YADEN,AVEC,BVEC,YAOTMP,ITERARG,GENMC,
     *       LNEED,LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,ITGA,ITGB,IAST,
     *       IBST,NB1EX,JROTLO,JROTHI,
     *       PRCNDO,PRCNDC,
     *       NNSTAT,NXYZ,
     *       TIMCI,TIMORB)
C
C       DON'T WASTE TIME WITH EXTRA FROM ITER BEING 1 MANY TIMES!
        ITERX=ITERX + 1
C
C
C
C       NEXT LINES DECREASE MATVECS IN FIRST ITERATION
        IF (RESET) THEN
          RESET=.FALSE.
C         RESTORE NOCP
          DO IXYZ=2,NXYZ
            IF(NOCP(IXYZ).NE.1) NOCP(IXYZ) = 0
          ENDDO
C         ACCOUNT FOR USER SELECTED NACME
          IF (NAPICK) 
     *      CALL CPNAPICK(NACST,NSTATS,NOCP,NXYZ)
C         COUNT UNCONVERGED RESPONSES.
          NXYZF = 0
          DO IXYZ = 1,NXYZ
            IF (NOCP(IXYZ).EQ.0) NXYZF = NXYZF+1
          ENDDO
C         RE-DO OTHER MATVECS WITH DECREASED EFFORT
C               (SEE ITER AND CPMCHF FILE)
          GO TO 600
        ENDIF
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     CHECK CONVERGENCE
C     AND
C     FORM TRUE RESIDUAL NORM SQUARED
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
        ERR = ZERO
        IUNIQ = 0
        DO 10 IXYZ=1,NXYZ
          IF(NOCP(IXYZ).NE.1) IUNIQ=IUNIQ+1
          IF(NOCP(IXYZ).NE.0) GO TO 10
          CALL CPRNORM(2175,RESIDO,RESIDS,RESIDC,
     *         NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *         IUNIQ,TOL,TEST,ERR,
     *         BNORMO,BNORMC,BNORMS,NDETMX)
          IF(TEST.LT.TOL) NOCP(IXYZ) = 2
  10   CONTINUE
C
C       NXYZF INDICATES UN-CONVERGED VECTORS FOR THE PRINT OUT,ETC
        NXYZF = 0
        DO IXYZ = 1,NXYZ
          IF (NOCP(IXYZ).EQ.0) NXYZF = NXYZF+1
        END DO
C
        IF (MASWRK) THEN
C         PRINT OFF IMPROVED RESPONSES.
          WRITE(IW,9020) ITER,ERR,NXYZF,TIMORB,TIMCI
          CALL FLSHBF(IW)
        END IF
        IF(ERR.LT.TOL) GO TO 800
        IF(ERR.GT.1.0D+15) THEN
          IF (MASWRK) WRITE(IW,9022)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     IF RESIDUAL NORM. TOO LARGE, SET THE INITIAL
C     GUESS YAX VECTOR TO THE 0 VECTOR.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
      IF(ZGUESS .AND. ERR.GT.1.0D+00) THEN
        CALL VCLR(YAO,1,NUNIQ*NROT)
        CALL VCLR(YAS,1,NUNIQ*NNSTAT)
        CALL VCLR(YAC,1,NUNIQ*NDETLN*NSTATS)
        ZGUESS=.FALSE.
        IF(MASWRK) WRITE(IW,9100)
        CALL FLSHBF(IW)
        GO TO 3
      ENDIF
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     BEGIN GCRO(M,K) ITERATIONS
C     NESTED IN OVERALL ITERATIONS
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
        KMINUS = KICIT - 1
        DO 401 KNEW=0,KMINUS
C
C         KEEP BKNUM FOR 1 MACRO-ITER TO USE IN THE LEAST SQUARES:
          CALL CPMKBK(2177,BKNUM,
     *         RESIDO,RESIDS,RESIDC,
     *         RESIDO,RESIDS,RESIDC,
     *         NROT,NSTATS,NDETLN,NNSTAT,
     *         NUNIQ,NXYZ,NOCP)
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     BEGIN NESTED GMRES ITERATIONS
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C         ----- Form 1st set of normalized Krylov vectors      -----
C         ----- note:  sqrt(bknum) = norm. of residual         -----
C
C         CLEAR KRYLOV AND HESSENBERG MATRICES FOR NEXT ROUND
          CALL VCLR(BMAT,1,KICIT*MICIT*NUNIQ)
          CALL VCLR(HMAT,1,(MICIT+1)*MICIT*NUNIQ)
          CALL VCLR(VMATO,1,NUNIQ*NROT*(MICIT+1))
          CALL VCLR(VMATS,1,NUNIQ*NNSTAT*(MICIT+1))
          CALL VCLR(VMATC,1,NUNIQ*NSTATS*NDETLN*(MICIT+1))
C
          IUNIQ = 0
          DO 20 IXYZ=1,NXYZ
            IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
            IF(NOCP(IXYZ).NE.0) GO TO 20 
C
            BKNUM(IUNIQ) = SQRT( BKNUM(IUNIQ) )
C
            CALL CPDCOPY(
     *           RESIDO,RESIDS,RESIDC,
     *           VMATO(1,1,1),
     *           VMATS(1,1,1),
     *           VMATC(1,1,1),
     *           NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *           IUNIQ)
            CALL CPDSCAL(
     *           VMATO(1,1,1),
     *           VMATS(1,1,1),
     *           VMATC(1,1,1),
     *           NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *           IUNIQ,ONE/BKNUM(IUNIQ))
   20     CONTINUE
C
C       ----- Begin microiterations for GMRES-------
C
          DO 888 MICRO=1,MICIT
C
C           RIGHT PRECONDITION PDIRX...
C           TEMP. STORE RESULT IN ZRESX...
            IUNIQ=0
            DO 30 IXYZ=1,NXYZ
              IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
              IF(NOCP(IXYZ).NE.0) GO TO 30
              CALL CPMKPRES(
     *             VMATO(1,1,MICRO),
     *             VMATS(1,1,MICRO),
     *             VMATC(1,1,MICRO),
     *             ZRESO,ZRESS,ZRESC,
     *             PRCNDO,PRCNDS,PRCNDC,
     *             NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *             JLO,JHI,IUNIQ)
   30       CONTINUE
C
C
C
C
            CALL CPMATVEC(2179,2180,CGINIT,
     *           ZRESC,ZRESO,ZRESS,
     *           NXYZF,NXYZ,NOCP,
     *           ZZRESC,ZZRESO,ZZRESS,
     *           PDIRO,EPS,OPDM,TPDM,IA,L0,
     *           PDIRC,PDIRS,PRCNDS,SALAG,
     *           CI,OINT,FCORSQ,AMAT,ERI,INDEX,IWRK,IFA,IOX,NCOR,NACT,
     *           NA,NB,L1,L2,NSYM,IIS,NDETMX,NDETLN,NROT,NUNIQ,JLO,JHI,
     *           NSTATS,WSTATE,WRK,YADEN,AVEC,BVEC,YAOTMP,ITERX,GENMC,
     *           LNEED,LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,ITGA,ITGB,IAST,
     *           IBST,NB1EX,JROTLO,JROTHI,
     *           NNSTAT,
     *           TIMCI,TIMORB)
C
          ITERX = ITERX + 1
C
C         ORTHOG. THE NEW RESIDUAL AGAINST THE SAVED SPACE...
          IF (KNEW .GT. 0) THEN
            DO 35 III=1,KNEW
              CALL CPMKBK(2181,BKDEN,
     *             CMATO(1,1,III),
     *             CMATS(1,1,III),
     *             CMATC(1,1,III),
     *             ZRESO,ZRESS,ZRESC,
     *             NROT,NSTATS,NDETLN,NNSTAT,
     *             NUNIQ,NXYZ,NOCP)

              IUNIQ = 0
              DO 40 IXYZ=1,NXYZ
                IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
                IF(NOCP(IXYZ).NE.0) GO TO 40 
                BMAT(III,MICRO,IUNIQ) = BKDEN(IUNIQ)
                CALL CPDAXPY(
     *               CMATO(1,1,III),
     *               CMATS(1,1,III),
     *               CMATC(1,1,III),
     *               ZRESO,ZRESS,ZRESC,
     *               NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *               IUNIQ,-BKDEN(IUNIQ))
   40         CONTINUE
C
   35       CONTINUE
          ENDIF
C
C         NOTE:  NO INDENT HERE FOR ROOM
          DO 999 MICRO2=1,MICRO
            CALL CPMKBK(2182,BKDEN,
     *           VMATO(1,1,MICRO2),
     *           VMATS(1,1,MICRO2),
     *           VMATC(1,1,MICRO2),
     *           ZRESO,ZRESS,ZRESC,
     *           NROT,NSTATS,NDETLN,NNSTAT,
     *           NUNIQ,NXYZ,NOCP)
C
C           FORM MOST OF HESSENBERG MATRIX
C           AND UPDATE HESSIAN*KRYLOV_MICIT
            IUNIQ = 0
            DO 50 IXYZ=1,NXYZ
              IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
              IF(NOCP(IXYZ).NE.0) GO TO 50 
              HMAT(MICRO2,MICRO,IUNIQ) = BKDEN(IUNIQ)
              CALL CPDAXPY(
     *             VMATO(1,1,MICRO2),
     *             VMATS(1,1,MICRO2),
     *             VMATC(1,1,MICRO2),
     *             ZRESO,ZRESS,ZRESC,
     *             NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *             IUNIQ,-BKDEN(IUNIQ))
   50       CONTINUE
C
C         END MICRO2 LOOP
  999     CONTINUE
C
C         NOW, NEED TO CALCULATE NORMS OF MICRO+1 VECTORS
          CALL CPMKBK(2183,BKDEN,
     *         ZRESO,ZRESS,ZRESC,ZRESO,ZRESS,ZRESC,
     *         NROT,NSTATS,NDETLN,NNSTAT,
     *         NUNIQ,NXYZ,NOCP)
C         NOTE:  AT BEGINNING OF MICRO DO LOOP
C                WE START WITH KRYLOV VECTORS
C                FORMED BELOW. 
          IUNIQ = 0
          DO 60 IXYZ=1,NXYZ
            IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
            IF(NOCP(IXYZ).NE.0) GO TO 60 
C           FINISH MAKING NORM OF ZRESX FROM BEFORE...
            BKDEN(IUNIQ) = SQRT( BKDEN(IUNIQ) )
            HMAT(MICRO+1,MICRO,IUNIQ) = BKDEN(IUNIQ)
            CALL CPDCOPY(
     *           ZRESO,ZRESS,ZRESC,
     *           VMATO(1,1,MICRO+1),
     *           VMATS(1,1,MICRO+1),
     *           VMATC(1,1,MICRO+1),
     *           NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *           IUNIQ)
            CALL CPDSCAL(
     *           VMATO(1,1,MICRO+1),
     *           VMATS(1,1,MICRO+1),
     *           VMATC(1,1,MICRO+1),
     *           NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *           IUNIQ,ONE/BKDEN(IUNIQ))
   60     CONTINUE
C
C       END ALL MICRO LOOPS
  888   CONTINUE 
C
C       ---- End microiterations   ---
C       ---- Solve least squares   ---
C       ---- Form approx. solution ---
C
C
C
C       SOLVING LEAST SQUARES
        IUNIQ = 0
        DO 444 IXYZ=1,NXYZ
          IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
          IF(NOCP(IXYZ).NE.0) GO TO 444 
C
C         CLEAR OUT THE 'BETA' VECTOR
          CALL VCLR(BETA,1,MICIT+1)
          BETA(1) = BKNUM(IUNIQ)
C
C         DGELS DESTROYS THE CONTENTS OF THE INPUT MATRIX
          CALL DCOPY((MICIT+1)*MICIT,
     *               HMAT(1,1,IUNIQ),1,
     *               HMAT2,1)
C
C         FIND LEAST SQUARES MINIMIZED VECTOR
          CALL DGELS('N',MICIT+1,MICIT,1,
     *                HMAT2,MICIT+1,
     *                BETA,MICIT+1,WKDGEL,
     *                2*(MICIT+1)*MICIT,INFO)

C
C   ----- FORM U_K+1 COLUMN VECTOR OF THE U_K MATRIX ----- 
C
C         KRYLOV SPACE DOTTED ONTO MINIMIZED SOLUTION
          CALL CPMATVEC2(VMATO,VMATS,VMATC,
     *         UMATO(1,1,KNEW+1),
     *         UMATS(1,1,KNEW+1),
     *         UMATC(1,1,KNEW+1),
     *         BETA,
     *         NROT,NSTATS,NDETLN,NNSTAT,
     *         IUNIQ,NUNIQ,
     *         MICIT+1,MICIT+1,
     *         1,MICIT)
C
          IF (KNEW.GT.0) THEN
C           CREATE ZMAT = BMAT * BETA
            KNEWARG = KNEW
            CALL MRARBR(BMAT(1,1,IUNIQ),
     *                  KICIT,KNEWARG,MICIT,
     *                  BETA,MICIT+1,1,
     *                  ZMAT,KICIT)
C           CREATE U_k*B_m*beta
            CALL CPMATVEC2(UMATO,UMATS,UMATC,
     *           ZRESO,ZRESS,ZRESC,
     *           ZMAT,
     *           NROT,NSTATS,NDETLN,NNSTAT,
     *           IUNIQ,NUNIQ,
     *           KICIT,KICIT,
     *           1,KNEW)
C           FORM U_k+1 = W_m*beta - U_k*B_m*beta
            CALL CPDAXPY(
     *           ZRESO,ZRESS,ZRESC,
     *           UMATO(1,1,KNEW+1),
     *           UMATS(1,1,KNEW+1),
     *           UMATC(1,1,KNEW+1),
     *           NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *           IUNIQ,-ONE)
          ENDIF
C
C
C
C     ----- FORM C_K+1 COLUMN VECTOR OF C_K MATRIX -----
C
          CALL VCLR(HMAT2,1,(MICIT+1)*MICIT)
          CALL MRARBR(HMAT(1,1,IUNIQ),
     *                MICIT+1,MICIT+1,MICIT,
     *                BETA,(MICIT+1),1,
     *                HMAT2(1,1),(MICIT+1))
          CALL CPMATVEC2(VMATO,VMATS,VMATC,
     *         CMATO(1,1,KNEW+1),
     *         CMATS(1,1,KNEW+1),
     *         CMATC(1,1,KNEW+1),
     *         HMAT2(1,1),
     *         NROT,NSTATS,NDETLN,NNSTAT,
     *         IUNIQ,NUNIQ,
     *         MICIT+1,MICIT+1,
     *         1,MICIT+1)
C
C     ----- FORM UPDATE TO RESIDUAL AND SOLUTION VECTORS -----
C     ----- NOTE:  PRECONDITION ONLY THE SOLUTION VECTOR -----
C
C
C         UPDATE THE RESIDUAL...
          CALL CPDAXPY(
     *         CMATO(1,1,KNEW+1),
     *         CMATS(1,1,KNEW+1),
     *         CMATC(1,1,KNEW+1),
     *         RESIDO,RESIDS,RESIDC,
     *         NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *         IUNIQ,-ONE)
C
C         UPDATE YAX...
          CALL CPMKPRES(
     *         UMATO(1,1,KNEW+1),
     *         UMATS(1,1,KNEW+1),
     *         UMATC(1,1,KNEW+1),
     *         ZRESO,ZRESS,ZRESC,
     *         PRCNDO,PRCNDS,PRCNDC,
     *         NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *         JLO,JHI,IUNIQ)
          CALL CPDAXPY(
     *         ZRESO,ZRESS,ZRESC,
     *         YAO,YAS,YAC,
     *         NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *         IUNIQ,ONE)
C
C     ----- NORMALIZE THE U_K+1 AND C_K+1 COLUMN VECTORS -----
C
          CALL CPMKNORM(2185,
     *         CMATO(1,1,KNEW+1),
     *         CMATS(1,1,KNEW+1),
     *         CMATC(1,1,KNEW+1),
     *         NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *         IUNIQ,TMP)
          TMP = ONE/TMP
          CALL DSCAL(NROT,TMP,
     *               CMATO(IUNIQ,1,KNEW+1),NUNIQ)
          CALL DSCAL(NNSTAT,TMP,
     *               CMATS(IUNIQ,1,KNEW+1),NUNIQ)
          CALL DSCAL(NDETLN*NSTATS,TMP,
     *               CMATC(IUNIQ,1,KNEW+1),NUNIQ)
          CALL DSCAL(NROT,TMP,
     *               UMATO(IUNIQ,1,KNEW+1),NUNIQ)
          CALL DSCAL(NNSTAT,TMP,
     *               UMATS(IUNIQ,1,KNEW+1),NUNIQ)
          CALL DSCAL(NDETLN*NSTATS,TMP,
     *               UMATC(IUNIQ,1,KNEW+1),NUNIQ)
C 
  444   CONTINUE
C
C       ----- END NESTED GMRES(M) ITERATIONS  -----
C       ----- END OF GCRO(M) ADDITIONS   -----
C
C       THIS NEXT FEW LINES ALLOWS THE USER TO PUT IN LARGE
C       VALUES FOR MICIT AND KICIT FOR TOUGH PROBLEMS
C       SO, MONITORING THE APPROX. RESIDUAL
C           AND EXITING TO THE MACRO LOOP
C           WILL CUT TIME BY DROPPING OUT
C           LOTS OF MATVECS BEYOND THE CONV. TOLERANCE.
C       HOWEVER, IT WILL ALSO RESTART THE BASISES
C                AND GIVES A TRADE-OFF.
C       SINCE GCRO-DR IS SUPPOSED TO RECYCLE THE BASIS,
C             NO CHANGE WILL BE MADE HERE FOR NOW.
        ERR = ZERO
        IUNIQ = 0
        DO 80 IXYZ=1,NXYZ
          IF(NOCP(IXYZ).NE.1) IUNIQ=IUNIQ+1
          IF(NOCP(IXYZ).NE.0) GO TO 80 
          CALL CPRNORM(2169,RESIDO,RESIDS,RESIDC,
     *         NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *         IUNIQ,TOL,TEST,ERR,
     *         BNORMO,BNORMC,BNORMS,NDETMX)
C         NO CONVERGENCE HERE SINCE NOT TRUE RESIDUAL
          IF(TEST.LT.TOL) GO TO 400
   80   CONTINUE
C
C
C     END LOOP OVER KNEW FOR GCRO(KICIT)
  401 CONTINUE
C
C
C
C     END LOOP OVER MACROITERS
  400 CONTINUE
C
C     ----- End overall iterations for GCRO                 ----
C
  800 CONTINUE
C
 9020 FORMAT(1X,I3,4X,1P,E13.5,0P,4X,I6,8X,F7.1,4X,F7.1)
 9022 FORMAT(1X,'TOLERANCE DIVERGING.  PLEASE RE-EXAMINE MICIT INPUT.')
 9100 FORMAT(1X,'DUE TO LARGE RES. NORM, GUESS SET TO 0 VECTOR.')
C 9720 FORMAT(/2X,'iuniq=',I3,2X,'bnorm=',F18.12)
C 9721 FORMAT(/2X,'iuniq=',I3,2X,'test=',F18.12)
      RETURN
      END
C*MODULE CPMCHF  *DECK CPGMRES1
      SUBROUTINE CPGMRES1(ITERX,CGINIT,
     *       ZZRESO,ZZRESS,ZZRESC,
     *       YAO,YAC,YAS,
     *       PRCNDO,PRCNDC,PRCNDS,RESIDO,RESIDC,
     *       RESIDS,ZRESO,ZRESC,ZRESS,PDIRO,PDIRC,PDIRS,
     *       BKNUM,BKDEN,OINT,AMAT,ERI,EPS,OPDM,
     *       TPDM,CI,WRK,INDEX,IA,IWRK,IFA,IOX,NOCP,
     *       NXYZ,NUNIQ,NROT,NDETLN,NDETMX,IIS,JLO,JHI,NA,
     *       NB,NSYM,NCOR,NACT,L0,L1,L2,NSTATS,
     *       WSTATE,SALAG,YADEN,AVEC,BVEC,FCORSQ,
     *       YAOTMP,GENMC,LNEED,LBOX1,LBOX2,LBOX3,LBOX4,
     *       LBOX5,ITGA,ITGB,IAST,IBST,NB1EX,JROTLO,JROTHI,
     *       VMATO,VMATS,VMATC,
     *       HMAT,HMAT2,
     *       WKDGEL,BETA,
     *       MICIT,NNSTAT,
     *       WRKMP,NXYZF)

C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GENMC
      LOGICAL CGINIT
C
      DIMENSION WRKMP(MICIT+1)
      DIMENSION ZZRESO(NUNIQ,NROT),
     *          ZZRESS(NUNIQ,*),
     *          ZZRESC(NUNIQ,NDETLN*NSTATS)
      DIMENSION VMATO(NUNIQ,NROT,MICIT+1),
     *          VMATS(NUNIQ,NNSTAT,MICIT+1),
     *          VMATC(NUNIQ,NDETLN*NSTATS,MICIT+1),
     *          HMAT(MICIT+1,MICIT,NUNIQ),
     *          HMAT2(MICIT+1,MICIT),
     *          WKDGEL(2*(MICIT+1)*MICIT),BETA(MICIT+1)
      DIMENSION YAO(NUNIQ,NROT),YAC(NUNIQ,NSTATS*NDETLN),YAS(NUNIQ,*),
     *          PRCNDO(NROT),PRCNDC(NSTATS*NDETLN),PRCNDS(*),
     *          RESIDO(NUNIQ,NROT),RESIDC(NUNIQ,NSTATS*NDETLN),
     *          RESIDS(NUNIQ,*),ZRESO(NUNIQ,NROT),
     *          ZRESC(NUNIQ,NSTATS*NDETLN),ZRESS(NUNIQ,*),
     *          PDIRO(NUNIQ,NROT),PDIRC(NUNIQ,NSTATS*NDETMX),
     *          PDIRS(NUNIQ,*),BKNUM(NUNIQ),BKDEN(NUNIQ),
     *          OINT(L2),AMAT(*),ERI(*),EPS(L1,L1),OPDM(*),
     *          TPDM(*),CI(NDETMX,NSTATS),WRK(*),
     *          WSTATE(*),SALAG(L1,L1,NSTATS*NSTATS),
     *          YADEN(*),AVEC(*),BVEC(*),FCORSQ(L1,L1),YAOTMP(*)
      DIMENSION INDEX(L1,L1),IA(*),IWRK(IIS),IFA(0:NACT,0:NACT),
     *          IOX(NACT),NOCP(NXYZ)
      DIMENSION LBOX1(*),LBOX2(*),LBOX3(*),LBOX4(*),LBOX5(*)
C
      PARAMETER (ONE=1.0D+00)
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     GMRES ITERATION SUB. FOR GCRO-DR
C     NOTE:  COULD EASILY CONVERT INTO GMRES SUB. 
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C       NOTE:  LEFT INDENT FROM OLDER VERSION WITH DO LOOP.
C       KEEP BKNUM FOR 1 MACRO-ITER TO USE IN THE LEAST SQUARES:
        CALL CPMKBK(2169,BKNUM,
     *       RESIDO,RESIDS,RESIDC,
     *       RESIDO,RESIDS,RESIDC,
     *       NROT,NSTATS,NDETLN,NNSTAT,
     *       NUNIQ,NXYZ,NOCP)
C
C     ----- Form 1st set of normalized Krylov vectors      -----
C     ----- note:  sqrt(bknum) = norm. of residual         -----
C
C       CLEAR KRYLOV AND HESSENBERG MATRICES FOR NEXT ROUND
        CALL VCLR(HMAT,1,(MICIT+1)*MICIT*NUNIQ)
        CALL VCLR(VMATO,1,NUNIQ*NROT*(MICIT+1))
        CALL VCLR(VMATS,1,NUNIQ*NNSTAT*(MICIT+1))
        CALL VCLR(VMATC,1,NUNIQ*NSTATS*NDETLN*(MICIT+1))
        IUNIQ = 0
        DO 10 IXYZ=1,NXYZ
          IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
          IF(NOCP(IXYZ).NE.0) GO TO 10 
C
          BKNUM(IUNIQ) = SQRT( BKNUM(IUNIQ) )
C
          CALL CPDCOPY(
     *         RESIDO,RESIDS,RESIDC,
     *         VMATO(1,1,1),
     *         VMATS(1,1,1),
     *         VMATC(1,1,1),
     *         NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *         IUNIQ)
          CALL CPDSCAL(
     *         VMATO(1,1,1),
     *         VMATS(1,1,1),
     *         VMATC(1,1,1),
     *         NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *         IUNIQ,ONE/BKNUM(IUNIQ))
   10   CONTINUE
C
C       ----- Begin microiterations for GMRES-------
C
          DO 888 MICRO=1,MICIT
C
C           RIGHT PRECONDITION PDIRX...
C           TEMP. STORE RESULT IN ZRESX...
            IUNIQ=0
            DO 20 IXYZ=1,NXYZ
              IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
              IF(NOCP(IXYZ).NE.0) GO TO 20 
              CALL CPMKPRES(
     *             VMATO(1,1,MICRO),
     *             VMATS(1,1,MICRO),
     *             VMATC(1,1,MICRO),
     *             ZRESO,ZRESS,ZRESC,
     *             PRCNDO,PRCNDS,PRCNDC,
     *             NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *             JLO,JHI,IUNIQ)
   20       CONTINUE
C
            CALL CPMATVEC(2170,2171,CGINIT,
     *           ZRESC,ZRESO,ZRESS,
     *           NXYZF,NXYZ,NOCP,
     *           ZZRESC,ZZRESO,ZZRESS,
     *           PDIRO,EPS,OPDM,TPDM,IA,L0,
     *           PDIRC,PDIRS,PRCNDS,SALAG,
     *           CI,OINT,FCORSQ,AMAT,ERI,INDEX,IWRK,IFA,IOX,NCOR,NACT,
     *           NA,NB,L1,L2,NSYM,IIS,NDETMX,NDETLN,NROT,NUNIQ,JLO,JHI,
     *           NSTATS,WSTATE,WRK,YADEN,AVEC,BVEC,YAOTMP,ITERX,GENMC,
     *           LNEED,LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,ITGA,ITGB,IAST,
     *           IBST,NB1EX,JROTLO,JROTHI,
     *           NNSTAT,
     *           TIMCI,TIMORB)
C
            ITERX = ITERX + 1
C
            DO 999 MICRO2=1,MICRO
              CALL CPMKBK(2173,BKDEN,
     *             VMATO(1,1,MICRO2),
     *             VMATS(1,1,MICRO2),
     *             VMATC(1,1,MICRO2),
     *             ZRESO,ZRESS,ZRESC,
     *             NROT,NSTATS,NDETLN,NNSTAT,
     *             NUNIQ,NXYZ,NOCP)
C
C             FORM MOST OF HESSENBERG MATRIX
C             AND UPDATE HESSIAN*KRYLOV_MICIT
              IUNIQ = 0
              DO 30 IXYZ=1,NXYZ
                IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
                IF(NOCP(IXYZ).NE.0) GO TO 30 
                HMAT(MICRO2,MICRO,IUNIQ) = BKDEN(IUNIQ)
                CALL CPDAXPY(
     *               VMATO(1,1,MICRO2),
     *               VMATS(1,1,MICRO2),
     *               VMATC(1,1,MICRO2),
     *               ZRESO,ZRESS,ZRESC,
     *               NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *               IUNIQ,-BKDEN(IUNIQ))
   30         CONTINUE
C
C           END MICRO2 LOOP
  999       CONTINUE
C
C           NOW, NEED TO CALCULATE NORMS OF MICRO+1 VECTORS
            CALL CPMKBK(2175,BKDEN,
     *           ZRESO,ZRESS,ZRESC,ZRESO,ZRESS,ZRESC,
     *           NROT,NSTATS,NDETLN,NNSTAT,
     *           NUNIQ,NXYZ,NOCP)
            IUNIQ = 0
            DO 40 IXYZ=1,NXYZ
              IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
              IF(NOCP(IXYZ).NE.0) GO TO 40 
C             FINISH MAKING NORM OF ZRESX FROM BEFORE...
              BKDEN(IUNIQ) = SQRT( BKDEN(IUNIQ) )
              HMAT(MICRO+1,MICRO,IUNIQ) = BKDEN(IUNIQ)
              CALL CPDCOPY(
     *             ZRESO,ZRESS,ZRESC,
     *             VMATO(1,1,MICRO+1),
     *             VMATS(1,1,MICRO+1),
     *             VMATC(1,1,MICRO+1),
     *             NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *             IUNIQ)
              CALL CPDSCAL(
     *             VMATO(1,1,MICRO+1),
     *             VMATS(1,1,MICRO+1),
     *             VMATC(1,1,MICRO+1),
     *             NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *             IUNIQ,ONE/BKDEN(IUNIQ))
   40       CONTINUE
C
C         END ALL MICRO LOOPS
  888     CONTINUE 
C
C       ---- End microiterations   ---
C       ---- Solve least squares   ---
C       ---- Form approx. solution ---
C
C
C       SOLVING LEAST SQUARES
        IUNIQ = 0
        DO 444 IXYZ=1,NXYZ
          IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
          IF(NOCP(IXYZ).NE.0) GO TO 444 
C         CLEAR OUT THE 'BETA' VECTOR
          CALL VCLR(BETA,1,MICIT+1)
          BETA(1) = BKNUM(IUNIQ)
C         FIND LEAST SQUARES MINIMIZED VECTOR
          CALL DCOPY((MICIT+1)*MICIT,
     *               HMAT(1,1,IUNIQ),1,
     *               HMAT2,1)
          CALL DGELS('N',MICIT+1,MICIT,1,
     *                HMAT2,MICIT+1,
     *                BETA,MICIT+1,WKDGEL,
     *                2*(MICIT+1)*MICIT,INFO)
C
C         KRYLOV SPACE DOTTED ONTO MINIMIZED SOLUTION
          CALL CPMATVEC2(VMATO,VMATS,VMATC,
     *                ZRESO,ZRESS,ZRESC,
     *                BETA,
     *                NROT,NSTATS,NDETLN,NNSTAT,
     *                IUNIQ,NUNIQ,
     *                MICIT+1,MICIT,
     *                1,MICIT)
C
C         PRECONDITION AND STORE IN RESIDX
          CALL CPMKPRES(
     *         ZRESO,ZRESS,ZRESC,
     *         RESIDO,RESIDS,RESIDC,
     *         PRCNDO,PRCNDS,PRCNDC,
     *         NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *         JLO,JHI,IUNIQ)
C         FORM APPROX GMRES SOLUTION
C         NOTE:  ACTUALLY UPDATING YAX...
          CALL CPDAXPY(
     *         RESIDO,RESIDS,RESIDC,
     *         YAO,YAS,YAC,
     *         NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *         IUNIQ,ONE)
C
C         UPDATE THE RESIDUAL ACCORDING TO PARKS...
          CALL VCLR(WRKMP,1,MICIT+1)
          CALL MRARBR(HMAT(1,1,IUNIQ),
     *                MICIT+1,MICIT+1,MICIT,
     *                BETA,MICIT+1,1,
     *                WRKMP,MICIT+1)
          CALL VCLR(BETA,1,MICIT+1)
          BETA(1) = BKNUM(IUNIQ)
          CALL DAXPY(MICIT+1,-ONE,WRKMP,1,BETA,1)
          CALL CPMATVEC2(VMATO,VMATS,VMATC,
     *                RESIDO,RESIDS,RESIDC,
     *                BETA,
     *                NROT,NSTATS,NDETLN,NNSTAT,
     *                IUNIQ,NUNIQ,
     *                MICIT+1,MICIT+1,
     *                1,MICIT+1)
C
C
  444   CONTINUE
C
C
      RETURN
      END
CKEEP
CKEEP    THE NEXT TWO ROUTINES WERE CREATED TO CREATE AND READ
CKEEP           THE NACME VECTORS.
CKEEP    PLEASE KEEP THIS FOR A LATER DATE TO READ IN GCRO-DR
CKEP            INFO FOR RECYCLING
CKEEP           BETWEEN GEOMETRIES.
CKEEP    SO FAR, THE RECYCLING B/T GEOMETRIES PROVES UN-USEFUL AS THE
CKEEP            SYSTEMS VARY TOO MUCH FOR GCRO-DR TO BE BENEFICIAL.
CKEEP
C*MODULE MCPCGX  *DECK CPPRDAT
      SUBROUTINE CPPRDAT(V,M,N,NDIM)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      DIMENSION V(NDIM,M)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     SUB PRINTS OFF THE NACME SOLUTION VECTORS
C     NOTE:  COULD BE USED B/T GEOMETRIES.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C     ----- PRINT OUT A SQUARE MATRIX -----
C     -V- IS -N- ROWS BY -M- COLUMNS, WITH LEADING DIMENSION -NDIM-
C
      IF (MASWRK) THEN
        MAX = 5
        IF (NPRINT .EQ. 6) MAX = 10
        IMAX = 0
  100   IMIN = IMAX+1
        IMAX = IMAX+MAX
        IF (IMAX .GT. M) IMAX = M
        WRITE (IP,9008)
        WRITE (IP,9028) (I,I = IMIN,IMAX)
        WRITE (IP,9008)
        DO 120 J = 1,N
  120     WRITE (IP,9048) J,(V(J,I),I = IMIN,IMAX)
        IF (IMAX .LT. M) GO TO 100
      END IF
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
CAW         potential format from vec group...
CAW         9040 FORMAT(I2,I3,5E15.8)
      RETURN
      END
C*MODULE MCPCGX  *DECK CPINITVEC
      SUBROUTINE CPINITVEC(V,M,N,NDIM)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER DUMMY,DUMMY2
CAW      LOGICAL GOPARR,DSKWRK,MASWRK
      DIMENSION V(NDIM,M)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
CAW      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     READS IN NACME SOLUTION VECTORS FROM .INP
C     FORMATED TO MATCH SUB. CPPRDAT
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
CAW      IF (MASWRK) THEN
        MAX = 5
        IF (NPRINT .EQ. 6) MAX = 10
        IMAX = 0
  100   IMIN = IMAX+1
        IMAX = IMAX+MAX
        IF (IMAX .GT. M) IMAX = M
        READ(IR,*)
        READ(IR,*) (DUMMY,DUMMY2 = IMIN,IMAX)
        READ(IR,*)
        DO 120 J = 1,N
  120     READ(IR,*) DUMMY,(V(J,I),I = IMIN,IMAX)
          IF (IMAX .LT. M) GO TO 100
CAW      END IF
c
c            next line never true, suppresses unused variable warnings
      if(n.lt.0) v(1,1) = dummy
      RETURN
      END
C*MODULE MCPCGX  *DECK CPMKRES 
      SUBROUTINE CPMKRES(ZRESO,ZRESS,ZRESC,RESIDO,RESIDS,RESIDC,
     *                    NUNIQ,NROT,NSTATS,NDETLN,NNSTAT) 
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (ONE=1.0D+00)
      DIMENSION RESIDO(NUNIQ,NROT), RESIDS(NUNIQ,*),
     *                RESIDC(NUNIQ,NSTATS*NDETLN), 
     *          ZRESO(NUNIQ,NROT), ZRESS(NUNIQ,*),
     *                ZRESC(NUNIQ,NSTATS*NDETLN)
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     SUB FORMS TRUE RESIDUAL
C     NOTE:  R = B - AX WINDS UP BEING (-B - AX)
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
      CALL DAXPY(NROT*NUNIQ,ONE,ZRESO,1,RESIDO,1)
      CALL DSCAL(NROT*NUNIQ,-ONE,RESIDO,1)
C
      CALL DAXPY(NSTATS*NDETLN*NUNIQ,ONE,ZRESC,1,RESIDC,1)
      CALL DSCAL(NSTATS*NDETLN*NUNIQ,-ONE,RESIDC,1)
C
      CALL DAXPY(NNSTAT*NUNIQ,ONE,ZRESS,1,RESIDS,1)
      CALL DSCAL(NNSTAT*NUNIQ,-ONE,RESIDS,1)
C
      RETURN
      END
C*MODULE MCPCGX  *DECK CPDAXPY
      SUBROUTINE CPDAXPY(ZRESO,ZRESS,ZRESC,RESIDO,RESIDS,RESIDC,
     *                      NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *                      IUNIQ,AK)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION RESIDO(NUNIQ,NROT), RESIDS(NUNIQ,*),
     *                RESIDC(NUNIQ,NSTATS*NDETLN),
     *          ZRESO(NUNIQ,NROT), ZRESS(NUNIQ,*),
     *                ZRESC(NUNIQ,NSTATS*NDETLN)
C
      CALL DAXPY(NROT,AK,ZRESO(IUNIQ,1),NUNIQ,RESIDO(IUNIQ,1),
     *           NUNIQ)
      CALL DAXPY(NNSTAT,AK,ZRESS(IUNIQ,1),NUNIQ,RESIDS(IUNIQ,1),
     *           NUNIQ)
      CALL DAXPY(NSTATS*NDETLN,AK,ZRESC(IUNIQ,1),NUNIQ,
     *           RESIDC(IUNIQ,1),NUNIQ)
C
      RETURN
      END
C*MODULE MCPCGX  *DECK CPDSCAL 
      SUBROUTINE CPDSCAL(RESIDO,RESIDS,RESIDC,
     *                   NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *                   IUNIQ,AKK)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION RESIDO(NUNIQ,NROT), RESIDS(NUNIQ,*),
     *                RESIDC(NUNIQ,NSTATS*NDETLN)
C
      CALL DSCAL(NROT,AKK,RESIDO(IUNIQ,1),NUNIQ)
      CALL DSCAL(NNSTAT,AKK,RESIDS(IUNIQ,1),NUNIQ)
      CALL DSCAL(NSTATS*NDETLN,AKK,RESIDC(IUNIQ,1),NUNIQ)
C
      RETURN
      END
C*MODULE MCPCGX  *DECK CPDCOPY
      SUBROUTINE CPDCOPY(ZRESO,ZRESS,ZRESC,RESIDO,RESIDS,RESIDC,
     *                      NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *                      IUNIQ)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION RESIDO(NUNIQ,NROT), RESIDS(NUNIQ,*),
     *                RESIDC(NUNIQ,NSTATS*NDETLN),
     *          ZRESO(NUNIQ,NROT), ZRESS(NUNIQ,*),
     *                ZRESC(NUNIQ,NSTATS*NDETLN)
C
      CALL DCOPY(NROT,ZRESO(IUNIQ,1),NUNIQ,RESIDO(IUNIQ,1),
     *           NUNIQ)
      CALL DCOPY(NNSTAT,ZRESS(IUNIQ,1),NUNIQ,RESIDS(IUNIQ,1),
     *           NUNIQ)
      CALL DCOPY(NSTATS*NDETLN,ZRESC(IUNIQ,1),NUNIQ,
     *           RESIDC(IUNIQ,1),NUNIQ)
C
      RETURN
      END
C*MODULE MCPCGX  *DECK CPMKPRES
      SUBROUTINE CPMKPRES(RESIDO,RESIDS,RESIDC,ZRESO,ZRESS,ZRESC,
     *                      PRCNDO,PRCNDS,PRCNDC,
     *                      NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *                      JLO,JHI,IITEMP)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION RESIDO(NUNIQ,NROT), RESIDS(NUNIQ,*),
     *                RESIDC(NUNIQ,NSTATS*NDETLN),
     *          ZRESO(NUNIQ,NROT), ZRESS(NUNIQ,*),
     *                ZRESC(NUNIQ,NSTATS*NDETLN),
     *          PRCNDO(NROT), PRCNDS(*),
     *                PRCNDC(NSTATS*NDETLN)
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     SUB FORMS PRECONDITIONED RESIDUAL.
C     NOTE:  PRCNDS CARRIED ALONG WITH PRECOND. VARS.
C            next line, unexecuted, suppresses unused variable warnings.
C     --------------------------------------------
      IF(NROT.LT.0) PRCNDS(1) = 0.0d+00
C     --------------------------------------------
C     --------------------------------------------
C
      DO IROT=1,NROT
        ZRESO(IITEMP,IROT) = RESIDO(IITEMP,IROT)/PRCNDO(IROT)
      ENDDO
      DO 100 ISTAT=1,NSTATS
        IVAL = (ISTAT-1)*NDETLN
        DO IDET=JLO,JHI
          IVAL = IVAL + 1
          ZRESC(IITEMP,IVAL) = RESIDC(IITEMP,IVAL)/PRCNDC(IVAL)
        ENDDO
  100 CONTINUE
      DO I=1,NNSTAT
        ZRESS(IITEMP,I) = RESIDS(IITEMP,I)
      ENDDO
C
      RETURN
      END
C*MODULE MCPCGX  *DECK CPRNORM
      SUBROUTINE CPRNORM(NUMPARR,RESIDO,RESIDS,RESIDC,
     *                   NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *                   IUNIQ,TOL,TEST,ERR,
     *                   BNORMO,BNORMC,BNORMS,NDETMX)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      DIMENSION RESIDO(NUNIQ,NROT), RESIDS(NUNIQ,*),
     *                RESIDC(NUNIQ,NSTATS*NDETLN)
      DIMENSION BNORMO(NUNIQ),BNORMC(NUNIQ),BNORMS(NUNIQ)
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     SUB FORMS RESIDUAL EUCLIDEAN NORM.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
      RNORM = DDOT(NSTATS*NDETLN,RESIDC(IUNIQ,1),NUNIQ,
     *             RESIDC(IUNIQ,1),NUNIQ)
      IF(GOPARR) CALL DDI_GSUMF(NUMPARR,RNORM,1)
      RDET = RNORM
      TMP = DBLE(NSTATS*NDETMX)
      RDET = RDET / TMP
      RDET = SQRT(RDET)
      IF(BNORMC(IUNIQ).GT.TOL) RDET = RDET/BNORMC(IUNIQ)
C     NOTE:  ABOVE SHOULD PREVENT DIVISIION BY ZERO IN CASE OF Z-VECTOR
C
      RORB = DDOT(NROT,RESIDO(IUNIQ,1),NUNIQ,RESIDO(IUNIQ,1),NUNIQ)
      RNORM = RNORM + RORB
      TMP = DBLE(NROT)
      RORB = RORB / TMP
      RORB = SQRT(RORB)
      IF(BNORMO(IUNIQ).GT.TOL) RORB = RORB/BNORMO(IUNIQ)
C
      RSTAT = DDOT(NNSTAT,RESIDS(IUNIQ,1),NUNIQ,RESIDS(IUNIQ,1),NUNIQ)
      RNORM = RNORM + RSTAT
      TMP = DBLE(NNSTAT)
      RSTAT = RSTAT / TMP
      RSTAT = SQRT(RSTAT)
      IF(BNORMS(IUNIQ).GT.TOL) RSTAT = RSTAT/BNORMS(IUNIQ)
      TEST = MAX(RORB,RDET)
      TEST = MAX(TEST,RSTAT)
CAWSAV      OLD CONVERGENCE CRITERION
CAWSAV      TEST = SQRT(RNORM)
CAWSAV      BTOT = BNORMO(IUNIQ)**2 + BNORMC(IUNIQ)**2 + BNORMS(IUNIQ)**2
CAWSAV      BTOT = SQRT(BTOT)
CAWSAV      IF(BTOT.GT.TOL) TEST = TEST/BTOT
      ERR = MAX(ERR,TEST)
C
      RETURN
      END
C*MODULE MCPCGX  *DECK CPMKPDIRTOT
      SUBROUTINE CPMKPDIRTOT(YAO,YAS,YAC,PDIRO,PDIRS,PDIRC,
     *                          NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *                          NDETMX,JLO,JHI,NUMPARR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      DIMENSION PDIRO(NUNIQ,NROT), PDIRS(NUNIQ,*),
     *                PDIRC(NUNIQ,NSTATS*NDETMX),
     *          YAO(NUNIQ,NROT), YAS(NUNIQ,*),
     *                YAC(NUNIQ,NSTATS*NDETLN)
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     SUB PREPARES FOR CP-MCSCF MAT-VEC PRODUCT
C     BY GATHERING APPROPRIATE VECTORS FROM
C     SERIAL PROCESSES,ETC.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
      CALL DCOPY(NUNIQ*NROT,YAO,1,PDIRO,1)
      CALL DCOPY(NUNIQ*NNSTAT,YAS,1,PDIRS,1)
C
      IF(GOPARR) CALL VCLR(PDIRC,1,NUNIQ*NDETMX*NSTATS)
      DO ISTAT=1,NSTATS
        IYVAL = (ISTAT-1)*NDETLN + 1
        IPVAL = (ISTAT-1)*NDETMX + JLO
        CALL DCOPY(NUNIQ*(JHI-JLO+1),YAC(1,IYVAL),1,PDIRC(1,IPVAL),1)
      ENDDO
C
      IF(GOPARR) CALL DDI_GSUMF(NUMPARR,PDIRC,NUNIQ*NDETMX*NSTATS)
C
      RETURN
      END
C*MODULE MCPCGX  *DECK CPMKPDIR
      SUBROUTINE CPMKPDIR(ZRESO,ZRESS,ZRESC,PDIRO,PDIRS,PDIRC,
     *                      NUNIQ,IUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *                      NDETMX,JLO,JHI,IINDICATE)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      PARAMETER (ONE=1.0D+00)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      DIMENSION PDIRO(NUNIQ,NROT), PDIRS(NUNIQ,*),
     *                PDIRC(NUNIQ,NSTATS*NDETMX),
     *          ZRESO(NUNIQ,NROT), ZRESS(NUNIQ,*),
     *                ZRESC(NUNIQ,NSTATS*NDETLN)
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     SUB PREPARES FOR CP-MCSCF MAT-VEC PRODUCT
C     BY GATHERING APPROPRIATE VECTORS FROM
C     SERIAL PROCESSES,ETC, INSIDE OF A NUNIQ LOOP.
C     NOTE:  NO GOPARR IN THIS SUB
C            B/C SUB IN A DO LOOP
C            THAT GETS GSUM'D AFTER THE NUNIQ LOOP.
C     NOTE2:  THUS, THIS SUB FOR CONJUGATE GRADIENT ONLY RIGHT NOW.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C     IINDICATE = 0 --> COPY ITEMS 1-3 OVER ITEMS 4-6 ABOVE
C     IINDICATE = 1 --> ADD ITEMS 1-3 ONTO ITEMS 4-6 ABOVE
C
      IF (IINDICATE.NE.0 .AND. IINDICATE.NE.1) THEN
        IF (MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      IF (IINDICATE .EQ. 0) THEN
            CALL DCOPY(NROT,ZRESO(IUNIQ,1),NUNIQ,PDIRO(IUNIQ,1),NUNIQ)
            CALL DCOPY(NNSTAT,ZRESS(IUNIQ,1),NUNIQ,PDIRS(IUNIQ,1),NUNIQ)
            DO ISTAT=1,NSTATS
              IZVAL = (ISTAT-1)*NDETLN + 1
              IPVAL = (ISTAT-1)*NDETMX + JLO
              CALL DCOPY((JHI-JLO+1),ZRESC(IUNIQ,IZVAL),NUNIQ,
     *                   PDIRC(IUNIQ,IPVAL),NUNIQ)
            ENDDO
      ENDIF
C
      IF (IINDICATE .EQ. 1) THEN
            CALL DAXPY(NROT,ONE,ZRESO(IUNIQ,1),NUNIQ,PDIRO(IUNIQ,1),
     *                 NUNIQ)
            CALL DAXPY(NNSTAT,ONE,ZRESS(IUNIQ,1),NUNIQ,PDIRS(IUNIQ,1),
     *                 NUNIQ)
            DO ISTAT=1,NSTATS
              IZVAL = (ISTAT-1)*NDETLN + 1
              IPVAL = (ISTAT-1)*NDETMX + JLO
              CALL DAXPY((JHI-JLO+1),ONE,ZRESC(IUNIQ,IZVAL),NUNIQ,
     *                   PDIRC(IUNIQ,IPVAL),NUNIQ)
            ENDDO
      ENDIF
C
 9000 FORMAT(1X,'PROBLEM WITH INPUT FOR SUB CPMKPDIR')
      RETURN
      END
C*MODULE MCPCGX  *DECK CPMATVEC
      SUBROUTINE CPMATVEC(NUMPARR2,NUMPARR3,CGINIT,
     *           RESIDC,RESIDO,RESIDS,
     *           NXYZF,NXYZ,NOCP,
     *           ZZRESC,ZZRESO,ZZRESS,
     *           PDIRO,EPS,OPDM,TPDM,IA,L0,
     *           PDIRC,PDIRS,PRCNDS,SALAG,
     *           CI,OINT,FCORSQ,AMAT,ERI,INDEX,IWRK,IFA,IOX,NCOR,NACT,
     *           NA,NB,L1,L2,NSYM,IIS,NDETMX,NDETLN,NROT,NUNIQ,JLO,JHI,
     *           NSTATS,WSTATE,WRK,YADEN,AVEC,BVEC,YAOTMP,ITER,GENMC,
     *           LNEED,LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,ITGA,ITGB,IAST,
     *           IBST,NB1EX,JROTLO,JROTHI,
     *           NNSTAT,
     *           TIMCI,TIMORB)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GENMC
      LOGICAL CGINIT
      DIMENSION  NOCP(NXYZ),
     *           ZZRESC(NUNIQ,NSTATS*NDETLN),ZZRESO(NUNIQ,NROT),
     *           ZZRESS(NUNIQ,*),
     *           RESIDC(NUNIQ,NSTATS*NDETLN),RESIDO(NUNIQ,NROT),
     *           RESIDS(NUNIQ,*),
     *           EPS(L1,L1),OPDM(*),TPDM(*),IA(*),
     *           PDIRC(NUNIQ,NSTATS*NDETMX),PDIRO(NUNIQ,NROT),
     *           PDIRS(NUNIQ,*),
     *           PRCNDS(*),
     *           SALAG(L1,L1,NSTATS*NSTATS),
     *           CI(NDETMX,NSTATS),OINT(L2),FCORSQ(L1,L1),AMAT(*),
     *           ERI(*),
     *           INDEX(L1,L1),IWRK(IIS),IFA(0:NACT,0:NACT),IOX(NACT),
     *           WSTATE(*),WRK(*),YADEN(*),AVEC(*),BVEC(*),YAOTMP(*)
C
      DIMENSION LBOX1(*),LBOX2(*),LBOX3(*),LBOX4(*),LBOX5(*)
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     SUB. PREPARES FOR MAT-VEC.
C     NOTE:  TOP-MOST SUB FOR MAT-VEC PREP.
C            IN SUB. MCPCGX
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C     MATVEC BEFORE
C
      IF (.NOT.CGINIT) THEN
      IF (NXYZF.NE.NUNIQ) THEN
        CALL CPSHFTVEC(
     *       NOCP,NXYZ,
     *       RESIDO,RESIDS,RESIDC,NUNIQ,
     *       ZZRESO,ZZRESS,ZZRESC,NXYZF,
     *       NROT,NNSTAT,NDETLN,NSTATS,0)
        CALL CPMKPDIRTOT(
     *       ZZRESO,ZZRESS,ZZRESC,
     *       PDIRO,PDIRS,PDIRC,
     *       NXYZF,NROT,NSTATS,NDETLN,NNSTAT,
     *       NDETMX,JLO,JHI,NUMPARR2)
      ELSE
        CALL CPMKPDIRTOT(
     *       RESIDO,RESIDS,RESIDC,
     *       PDIRO,PDIRS,PDIRC,
     *       NXYZF,NROT,NSTATS,NDETLN,NNSTAT,
     *       NDETMX,JLO,JHI,NUMPARR2)
      ENDIF
      ENDIF
C
C
C
C
C
      CALL CPMATVEC_NOSYM(NUMPARR3,
     *     RESIDC,RESIDO,RESIDS,
     *     PDIRO,EPS,OPDM,TPDM,IA,L0,
     *     PDIRC,PDIRS,PRCNDS,SALAG,
     *     CI,OINT,FCORSQ,AMAT,ERI,INDEX,IWRK,IFA,IOX,NCOR,NACT,
     *     NA,NB,L1,L2,NSYM,IIS,NDETMX,NDETLN,NROT,NXYZF,JLO,JHI,
     *     NSTATS,WSTATE,WRK,YADEN,AVEC,BVEC,YAOTMP,ITER,GENMC,
     *     LNEED,LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,ITGA,ITGB,IAST,
     *     IBST,NB1EX,JROTLO,JROTHI,
     *     NNSTAT,
     *     TIMCI,TIMORB)
C
C
C
C
C     MATVEC AFTER
C     RESTORE UNCONVERGED PIECES OF SOME VECTORS
      IF (NXYZF.NE.NUNIQ) THEN
      CALL CPSHFTVEC(
     *     NOCP,NXYZ,
     *     ZZRESO,ZZRESS,ZZRESC,NUNIQ,
     *     RESIDO,RESIDS,RESIDC,NXYZF,
     *     NROT,NNSTAT,NDETLN,NSTATS,1)
      CALL CPSHFTVEC(
     *     NOCP,NXYZ,
     *     ZZRESO,ZZRESS,ZZRESC,NUNIQ,
     *     RESIDO,RESIDS,RESIDC,NUNIQ,
     *     NROT,NNSTAT,NDETLN,NSTATS,2)
      ENDIF
C
C
      RETURN
      END
C*MODULE MCPCGX  *DECK CPMKAKDEN
      SUBROUTINE CPMKAKDEN(AKDEN,PDIRO,PDIRS,PDIRC,
     *                      ZRESO,ZRESS,ZRESC,
     *                      NUNIQ,NROT,NSTATS,NNSTAT,
     *                      NDETMX,NDETLN,
     *                      JLO,JHI,IUNIQ,NUMPARR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      PARAMETER (ZERO=0.0D+00)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      DIMENSION PDIRC(NUNIQ,NSTATS*NDETMX),PDIRO(NUNIQ,NROT),
     *                PDIRS(NUNIQ,*),
     *          ZRESO(NUNIQ,NROT), ZRESS(NUNIQ,*),
     *                ZRESC(NUNIQ,NSTATS*NDETLN)
C
          AKDEN = ZERO
          DO ISTAT=1,NSTATS
            IZVAL = (ISTAT-1)*NDETLN + 1
            IPVAL = (ISTAT-1)*NDETMX + JLO
            AKDEN = AKDEN + DDOT((JHI-JLO+1),PDIRC(IUNIQ,IPVAL),
     *                           NUNIQ,ZRESC(IUNIQ,IZVAL),NUNIQ)
          ENDDO
          IF(GOPARR) CALL DDI_GSUMF(NUMPARR,AKDEN,1)
          AKDEN = AKDEN + DDOT(NROT,PDIRO(IUNIQ,1),NUNIQ,ZRESO(IUNIQ,1),
     *                         NUNIQ)
          AKDEN = AKDEN + DDOT(NNSTAT,PDIRS(IUNIQ,1),NUNIQ,
     *                         ZRESS(IUNIQ,1),NUNIQ)
C
      RETURN
      END
C*MODULE MCPCGX  *DECK CPMKYAX
      SUBROUTINE CPMKYAX(PDIRO,PDIRS,PDIRC,YAO,YAS,YAC,
     *                      NUNIQ,IUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *                      NDETMX,JLO,JHI,AK,IINDICATE)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      DIMENSION PDIRO(NUNIQ,NROT), PDIRS(NUNIQ,*),
     *                PDIRC(NUNIQ,NSTATS*NDETMX),
     *          YAO(NUNIQ,NROT), YAS(NUNIQ,*),
     *                YAC(NUNIQ,NSTATS*NDETLN)
C
C     IINDICATE = 0 --> COPY ITEMS 1-3 OVER ITEMS 4-6 ABOVE
C     IINDICATE = 1 --> ADD AK*ITEMS 1-3 ONTO ITEMS 4-6 ABOVE
C
      IF (IINDICATE.NE.0 .AND. IINDICATE.NE.1) THEN
        IF (MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      IF (IINDICATE .EQ. 0) THEN
          CALL DCOPY(NROT,PDIRO(IUNIQ,1),NUNIQ,YAO(IUNIQ,1),NUNIQ)
          CALL DCOPY(NNSTAT,PDIRS(IUNIQ,1),NUNIQ,YAS(IUNIQ,1),NUNIQ)
          IF(GOPARR) CALL VCLR(YAC,1,NUNIQ*NSTATS*NDETLN)
          DO ISTAT=1,NSTATS
            IPVAL = (ISTAT-1)*NDETMX + JLO
            IYVAL = (ISTAT-1)*NDETLN + 1
            CALL DCOPY((JHI-JLO+1),PDIRC(IUNIQ,IPVAL),NUNIQ,
     *                 YAC(IUNIQ,IYVAL),NUNIQ)
          ENDDO
      ENDIF
C
      IF (IINDICATE .EQ. 1) THEN
          CALL DAXPY(NROT,AK,PDIRO(IUNIQ,1),NUNIQ,YAO(IUNIQ,1),NUNIQ)
          CALL DAXPY(NNSTAT,AK,PDIRS(IUNIQ,1),NUNIQ,YAS(IUNIQ,1),NUNIQ)
          DO ISTAT=1,NSTATS
            IPVAL = (ISTAT-1)*NDETMX + JLO
            IYVAL = (ISTAT-1)*NDETLN + 1
            CALL DAXPY((JHI-JLO+1),AK,PDIRC(IUNIQ,IPVAL),NUNIQ,
     *                 YAC(IUNIQ,IYVAL),NUNIQ)
          ENDDO
      ENDIF
C
 9000 FORMAT(1X,'PROBLEM WITH INPUT FOR SUB CPMKYAX')
      RETURN
      END
C*MODULE MCPCGX  *DECK CPMKBK
      SUBROUTINE CPMKBK(NUMPARR,BKNUM,
     *                      RESIDO,RESIDS,RESIDC,ZRESO,ZRESS,ZRESC,
     *                      NROT,NSTATS,NDETLN,NNSTAT,
     *                      NUNIQ,NXYZ,NOCP)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      DIMENSION RESIDO(NUNIQ,NROT), RESIDS(NUNIQ,*),
     *                RESIDC(NUNIQ,NSTATS*NDETLN),
     *          ZRESO(NUNIQ,NROT), ZRESS(NUNIQ,*),
     *                ZRESC(NUNIQ,NSTATS*NDETLN),
     *          BKNUM(NUNIQ), NOCP(NXYZ)
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     SUB. FORMS DOT-PRODUCTS OUTSIDE OF NUNIQ LOOP.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C
      DO IUNIQ=1,NUNIQ
        BKNUM(IUNIQ) = DDOT(NSTATS*NDETLN,ZRESC(IUNIQ,1),NUNIQ,
     *                      RESIDC(IUNIQ,1),NUNIQ)
      ENDDO
C
      IF(GOPARR) CALL DDI_GSUMF(NUMPARR,BKNUM,NUNIQ)
C
      IUNIQ = 0
      DO 100 IXYZ=1,NXYZ
        IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
        IF(NOCP(IXYZ).NE.0) GO TO 100 
        BVAL = DDOT(NROT,ZRESO(IUNIQ,1),NUNIQ,RESIDO(IUNIQ,1),NUNIQ)
        BVAL = BVAL +
     *         DDOT(NNSTAT,ZRESS(IUNIQ,1),NUNIQ,RESIDS(IUNIQ,1),NUNIQ)
        BKNUM(IUNIQ) = BKNUM(IUNIQ) + BVAL
  100 CONTINUE
C
      RETURN
      END
C*MODULE MCPCGX  *DECK CPINIT1
      SUBROUTINE CPINIT1(NUMPARR,NUMPARR2,NUMPARR3,CGINIT,
     *     NDER,NXYZF,NUNIQT,NFT18,NFT19,EGRAD,NSORT,NOCP,NOCC,
     *     YAC,YAO,YAS,
     *     ZRESC,ZRESO,ZRESS,
     *     ZZRESC,ZZRESO,ZZRESS,
     *     RESIDC,RESIDO,RESIDS,
     *     PDIRO,EPS,OPDM,TPDM,IA,L0,
     *     PDIRC,PDIRS,PRCNDS,SALAG,
     *     CI,OINT,FCORSQ,AMAT,ERI,INDEX,IWRK,IFA,IOX,NCOR,NACT,
     *     NA,NB,L1,L2,NSYM,IIS,NDETMX,NDETLN,NROT,NUNIQ,JLO,JHI,
     *     NSTATS,WSTATE,WRK,YADEN,AVEC,BVEC,YAOTMP,ITER,GENMC,
     *     LNEED,LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,ITGA,ITGB,IAST,
     *     IBST,NB1EX,JROTLO,JROTHI,
     *     PRCNDO,PRCNDC,
     *     NNSTAT,NXYZ,
     *     TIMCI,TIMORB)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GENMC
      LOGICAL CGINIT
      DIMENSION  NSORT(NUNIQ),NOCP(NXYZ),EGRAD(*),
     *           YAC(NUNIQ,NSTATS*NDETLN),YAO(NUNIQ,NROT),
     *           YAS(NUNIQ,*),
     *           ZRESC(NUNIQ,NSTATS*NDETLN),ZRESO(NUNIQ,NROT),
     *           ZRESS(NUNIQ,*),
     *           ZZRESC(NUNIQ,NSTATS*NDETLN),ZZRESO(NUNIQ,NROT),
     *           ZZRESS(NUNIQ,*),
     *           RESIDC(NUNIQ,NSTATS*NDETLN),RESIDO(NUNIQ,NROT),
     *           RESIDS(NUNIQ,*),
     *           EPS(L1,L1),OPDM(*),TPDM(*),IA(*),
     *           PDIRC(NUNIQ,NSTATS*NDETMX),PDIRO(NUNIQ,NROT),
     *           PDIRS(NUNIQ,*),
     *           SALAG(L1,L1,NSTATS*NSTATS),
     *           CI(NDETMX,NSTATS),OINT(L2),FCORSQ(L1,L1),AMAT(*),
     *           ERI(*),
     *           INDEX(L1,L1),IWRK(IIS),
     *           IFA(0:NACT,0:NACT),IOX(NACT),
     *           WSTATE(*),WRK(*),YADEN(*),AVEC(*),
     *           BVEC(*),YAOTMP(*),
     *           PRCNDO(NROT), PRCNDS(*),
     *           PRCNDC(NSTATS*NDETLN)
      DIMENSION LBOX1(*),LBOX2(*),LBOX3(*),LBOX4(*),LBOX5(*)
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     SUB. STARTS OFF FORMING THE TRUE RESIDUAL.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C
C
C
C     SHIFT YAX VECTORS INTO PDIRX VECTORS
      CALL CPSHFTVEC(
     *     NOCP,NXYZ,
     *     YAO,YAS,YAC,NUNIQ,
     *     ZZRESO,ZZRESS,ZZRESC,NXYZF,
     *     NROT,NNSTAT,NDETLN,NSTATS,0)
      CALL CPMKPDIRTOT(ZZRESO,ZZRESS,ZZRESC,PDIRO,PDIRS,PDIRC,
     *                    NXYZF,NROT,NSTATS,NDETLN,NNSTAT,
     *                    NDETMX,JLO,JHI,NUMPARR)
C     FORM TRUE RIGHT HAND SIDE
      CALL CPMKRHS(NDER,ZZRESO,ZZRESC,ZZRESS,
     *     CI,EGRAD,WSTATE,WRK,INDEX,NOCP,
     *     NXYZ,NUNIQT,NROT,NDETLN,
     *     NOCC,L1,NFT18,NFT19,NSTATS,
     *     JLO,JHI,NDETMX,NNSTAT)
C     SHIFT RHS VECTORS
      IF (NDER.EQ.1) THEN
        CALL CPSHFTRHS(NSORT,ZRESO,ZZRESO,
     *                       NUNIQT,NROT,NSTATS)
      ENDIF
C
C
C     MATVEC BEFORE FOR THE RHS OR SOME TEMP. VECTOR 
      CALL CPSHFTVEC(
     *     NOCP,NXYZ,
     *     ZZRESO,ZZRESS,ZZRESC,NUNIQ,
     *     ZRESO,ZRESS,ZRESC,NXYZF,
     *     NROT,NNSTAT,NDETLN,NSTATS,0)
C
C
C     ----- Perform matrix multiplication for first interation -----
C     -----                of CPMCHF equations                 -----
C
      CGINIT=.TRUE.
      CALL CPMATVEC(NUMPARR2,NUMPARR3,CGINIT,
     *     RESIDC,RESIDO,RESIDS,
     *     NXYZF,NXYZ,NOCP,
     *     ZZRESC,ZZRESO,ZZRESS,
     *     PDIRO,EPS,OPDM,TPDM,IA,L0,
     *     PDIRC,PDIRS,PRCNDS,SALAG,
     *     CI,OINT,FCORSQ,AMAT,ERI,INDEX,IWRK,IFA,IOX,NCOR,NACT,
     *     NA,NB,L1,L2,NSYM,IIS,NDETMX,NDETLN,NROT,NUNIQ,JLO,JHI,
     *     NSTATS,WSTATE,WRK,YADEN,AVEC,BVEC,YAOTMP,ITER,GENMC,
     *     LNEED,LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,ITGA,ITGB,IAST,
     *     IBST,NB1EX,JROTLO,JROTHI,
     *     NNSTAT,
     *     TIMCI,TIMORB)
      CGINIT=.FALSE.
C
C     NOTE:  NO ITERX INSIDE SUB CPINIT1
C
C
C
C
C     MATVEC AFTER FOR THE RHS OR SOME TEMP. VECTOR 
C     RESTORE UNCONVERGED PIECES OF ZRESX
      CALL CPSHFTVEC(
     *     NOCP,NXYZ,
     *     ZZRESO,ZZRESS,ZZRESC,NUNIQ,
     *     ZRESO,ZRESS,ZRESC,NXYZF,
     *     NROT,NNSTAT,NDETLN,NSTATS,1)
      CALL CPSHFTVEC(
     *     NOCP,NXYZ,
     *     ZZRESO,ZZRESS,ZZRESC,NUNIQ,
     *     ZRESO,ZRESS,ZRESC,NUNIQ,
     *     NROT,NNSTAT,NDETLN,NSTATS,2)

C
C     ----- Calculate residual for first iteration -----
C
      CALL CPMKRES(ZRESO,ZRESS,ZRESC,RESIDO,RESIDS,RESIDC,
     *              NUNIQ,NROT,NSTATS,NDETLN,NNSTAT)
C
C     ----- Calculate initial psuedoresidual -----
C
      DO 100 IXYZ=1,NXYZ
        CALL CPMKPRES(RESIDO,RESIDS,RESIDC,
     *                  ZRESO,ZRESS,ZRESC,
     *                  PRCNDO,PRCNDS,PRCNDC,
     *                  NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *                  JLO,JHI,IXYZ)
  100 CONTINUE
C
C
C
      RETURN
      END
C*MODULE MCPCGX  *DECK CPINIT2
      SUBROUTINE CPINIT2(NUMPARR1,NUMPARR2,
     *           BKNUM,BKDEN,
     *           RESIDO,RESIDS,RESIDC,ZRESO,ZRESS,ZRESC,
     *           NROT,NSTATS,NDETLN,NNSTAT,
     *           NUNIQ,NXYZ,NOCP,
     *           PDIRO,PDIRS,PDIRC,
     *           NDETMX,JLO,JHI)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION  RESIDC(NUNIQ,NSTATS*NDETLN),RESIDO(NUNIQ,NROT),
     *           RESIDS(NUNIQ,*),
     *           PDIRC(NUNIQ,NSTATS*NDETMX),PDIRO(NUNIQ,NROT),
     *           PDIRS(NUNIQ,*),
     *           ZRESO(NUNIQ,NROT), ZRESS(NUNIQ,*),
     *                ZRESC(NUNIQ,NSTATS*NDETLN),
     *           BKNUM(NUNIQ), BKDEN(NUNIQ), NOCP(NXYZ)
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     SUB. IS FOR CONJUGATE GRADIENT ONLY.
C     NOTE:  ADDED FOR COMPACTNESS.
C            COULD PROBABLY BE REMOVED.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C
C     ---- Set up line search coefficients' numerator -----
C     ---- and save them as old coeffs now too        -----
C
      CALL CPMKBK(NUMPARR1,BKNUM,
     *                RESIDO,RESIDS,RESIDC,ZRESO,ZRESS,ZRESC,
     *                NROT,NSTATS,NDETLN,NNSTAT,
     *                NUNIQ,NXYZ,NOCP)
      IUNIQ = 0
      DO 100 IXYZ=1,NXYZ
        IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
        IF(NOCP(IXYZ).NE.0) GO TO 100
          BKDEN(IUNIQ) = BKNUM(IUNIQ)
  100   CONTINUE
C
C     ----- Copy preconditioned true residual(pseudo resid) over to pdirx  -----
C
      CALL CPMKPDIRTOT(ZRESO,ZRESS,ZRESC,PDIRO,PDIRS,PDIRC,
     *                    NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *                    NDETMX,JLO,JHI,NUMPARR2)
C
      RETURN
      END
C*MODULE MCPCGX  *DECK CPMKRHS
      SUBROUTINE CPMKRHS(NDER,ZRESO,ZRESC,ZRESS,
     *           CI,EGRAD,WSTATE,WRK,INDEX,NOCP,
     *           NXYZ,NUNIQ,NROT,NDETLN,
     *           NOCC,L1,NFT18,NFT19,NSTATS,
     *           JLO,JHI,NDETMX,NNSTAT)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      DIMENSION  ZRESO(NUNIQ,NROT), ZRESS(NUNIQ,*),
     *                ZRESC(NUNIQ,NSTATS*NDETLN),
     *           NOCP(NXYZ),CI(NDETMX,NSTATS),EGRAD(*),
     *           WRK(*),INDEX(L1,L1),WSTATE(*)
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     SUB FORMS RIGHT-HAND SIDE.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C
      IF(NDER.EQ.2) THEN
        CALL FMRHS(ZRESO,ZRESC,ZRESS,CI,EGRAD,WSTATE,WRK,INDEX,NOCP,
     *             NXYZ,NUNIQ,NROT,NDETLN,NOCC,L1,NFT18,NFT19,NSTATS,
     *             JLO,JHI,NDETMX,NNSTAT)
      ENDIF
C
      IF(NDER.EQ.1) THEN
        CALL DAREAD(IDAF,IODA,ZRESO,NUNIQ*NROT,490,0)
        CALL VCLR(ZRESC,1,NUNIQ*NSTATS*NDETLN)
        CALL VCLR(ZRESS,1,NUNIQ*NNSTAT)
      ENDIF
C
      RETURN
      END
C*MODULE MCPCGX  *DECK CPMKNORM
      SUBROUTINE CPMKNORM(NUMPARR,RESIDO,RESIDS,RESIDC,
     *                      NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *                      IUNIQ,TEST)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      DIMENSION RESIDO(NUNIQ,NROT), RESIDS(NUNIQ,*),
     *                RESIDC(NUNIQ,NSTATS*NDETLN)
C
      RNORM = DDOT(NSTATS*NDETLN,RESIDC(IUNIQ,1),NUNIQ,
     *             RESIDC(IUNIQ,1),NUNIQ)
      IF(GOPARR) CALL DDI_GSUMF(NUMPARR,RNORM,1)
      RNORM = RNORM +
     *        DDOT(NROT,RESIDO(IUNIQ,1),NUNIQ,RESIDO(IUNIQ,1),NUNIQ)
      RNORM = RNORM +
     *        DDOT(NNSTAT,RESIDS(IUNIQ,1),NUNIQ,RESIDS(IUNIQ,1),NUNIQ)
      TEST = SQRT(RNORM)
C
      RETURN
      END
C*MODULE MCPCGX  *DECK CPMKDOT
      SUBROUTINE CPMKDOT(NUMPARR,RESIDO,RESIDS,RESIDC,
     *                      RESIDO2,RESIDS2,RESIDC2,
     *                      NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *                      IUNIQ,RNORM)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      DIMENSION RESIDO(NUNIQ,NROT), RESIDS(NUNIQ,*),
     *                RESIDC(NUNIQ,NSTATS*NDETLN)
      DIMENSION RESIDO2(NUNIQ,NROT), RESIDS2(NUNIQ,*),
     *                RESIDC2(NUNIQ,NSTATS*NDETLN)
C
      RNORM = DDOT(NSTATS*NDETLN,RESIDC(IUNIQ,1),NUNIQ,
     *             RESIDC2(IUNIQ,1),NUNIQ)
      IF(GOPARR) CALL DDI_GSUMF(NUMPARR,RNORM,1)
      RNORM = RNORM +
     * DDOT(NROT,RESIDO(IUNIQ,1),NUNIQ,RESIDO2(IUNIQ,1),NUNIQ)
      RNORM = RNORM +
     * DDOT(NNSTAT,RESIDS(IUNIQ,1),NUNIQ,RESIDS2(IUNIQ,1),NUNIQ)
C
      RETURN
      END
C
C*MODULE MCPCGX  *DECK CPMATVEC2 
      SUBROUTINE CPMATVEC2(VMATO,VMATS,VMATC,
     *                  ZRESO,ZRESS,ZRESC,
     *                  BETA,
     *                  NROT,NSTATS,NDETLN,NNSTAT,
     *                  IUNIQ,NUNIQ,
     *                  MICIT2,MICIT3,
     *                  ISTART,IEND)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION VMATO(NUNIQ,NROT,MICIT2),
     *          VMATS(NUNIQ,NNSTAT,MICIT2),
     *          VMATC(NUNIQ,NSTATS*NDETLN,MICIT2),
     *          ZRESO(NUNIQ,NROT), ZRESS(NUNIQ,*),
     *          ZRESC(NUNIQ,NSTATS*NDETLN),
     *          BETA(MICIT3)
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     SUB OFTEN FORMS MAT-VEC PRODUCT FOR
C     (KRYLOV SPACE) * (REDUCED VECTOR).
C     NOTE:  WRKMP MAY GET REDIMENSIONED TO BE SMALLER
C            WHEN PASSING INTO THIS SUB
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
      CALL VCLR(ZRESO(IUNIQ,1),NUNIQ,NROT)
      CALL VCLR(ZRESS(IUNIQ,1),NUNIQ,NNSTAT)
      CALL VCLR(ZRESC(IUNIQ,1),NUNIQ,NDETLN*NSTATS)
C
      DO II=1,NROT
        K=0
        DO JJ=ISTART,IEND
          K = K+1
          ZRESO(IUNIQ,II) = ZRESO(IUNIQ,II)
     *                    + VMATO(IUNIQ,II,JJ)*BETA(K)
        ENDDO
      ENDDO
      DO II=1,NNSTAT
        K=0
        DO JJ=ISTART,IEND
          K = K+1
          ZRESS(IUNIQ,II) = ZRESS(IUNIQ,II)
     *                    + VMATS(IUNIQ,II,JJ)*BETA(K)
        ENDDO
      ENDDO
      ICSF=NDETLN*NSTATS
      DO II=1,ICSF
        K=0
        DO JJ=ISTART,IEND
          K = K+1
          ZRESC(IUNIQ,II) = ZRESC(IUNIQ,II)
     *                    + VMATC(IUNIQ,II,JJ)*BETA(K)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
C*MODULE MCPCGX  *DECK CPSHFTRHS
      SUBROUTINE CPSHFTRHS(NSORT,ZZRESO,ZRESO,NUNIQ,NROT,NSTATS)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION ZRESO(NUNIQ,NROT)
      DIMENSION NSORT(NUNIQ)
      DIMENSION ZZRESO(NSTATS*(NSTATS+1)/2,NROT) 
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     SHIFT TRULY UNIQUE RHS VECTORS TO PROPER PLACE.
C     NOTE:  WANT TO COPY THE LEAST NUMBER OF VECTORS
C     NOTE2:  TEMP. SUB TO PREVENT SOLVER FROM
C             -HAVING A LOT OF EXTRA MEMORY
C             -DOING EXTRA WORK ON NDER=1
C     NOTE3:  SUB REPLACED WITH FULL SYM. OF SUB ZCPMCX
C     NOTE4:  NOTE WHAT GETS PASSED IN AS NUNIQ...
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
      NNSTAT = NSTATS*(NSTATS+1)/2
C
      DO I=1,NNSTAT
      ITMP = NSORT(I)
        CALL DCOPY(NROT,ZRESO(ITMP,1),NUNIQ,
     *             ZZRESO(I,1),NNSTAT)
      ENDDO
C
C     NOW, REWRITE ZRESO... 
C     ESSENTIALLY CHANGE THE WORKING L.D. OF ZRESO...
      CALL VCLR(ZRESO,1,NUNIQ*NROT)
      CALL DCOPY(NNSTAT*NROT,ZZRESO,1,ZRESO,1)
C
      RETURN
      END
C
C*MODULE MCPCGX  *DECK CPNSORT
      SUBROUTINE CPNSORT(NSORT,NUNIQ,NSTATS)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION NSORT(NUNIQ)
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     THIS SUB CREATES THE NSORT ARRAY THAT HOLDS
C     WHICH LINEAR EQUATION AFTER SYMMETRIZATION.
C     LATER, THE NSORT ARRAY IS MANIPULATED
C     WITH THE MAT-VEC REDIMENSIONINGS,ETC.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C     DESPITE LOOPS RUNNING OVER NSTATS**2,
C     THAT SHOULD NOT MATTER FOR SYM.
      ISAV = 0
      DO J=1,NSTATS
        DO I=1,NSTATS
          IF(I.GE.J) THEN
            ITMP = I + NSTATS*(J-1)
            ISAV = ISAV + 1
C           SAVE THE VECTOR LABELS HERE...
            NSORT(ISAV) = ITMP
          ENDIF
        ENDDO
      ENDDO
C
C
      RETURN
      END
C*MODULE MCPCGX  *DECK CPSHFTVEC
      SUBROUTINE CPSHFTVEC(
     *           NOCP,NXYZ,
     *           YAO,YAS,YAC,NUNIQ,
     *           YAO2,YAS2,YAC2,NXYZF,
     *           NROT,NNSTAT,NDETLN,NSTATS,IOPT)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
C
      DIMENSION NOCP(NXYZ)
      DIMENSION YAO(NUNIQ,NROT), YAS(NUNIQ,*),
     *                YAC(NUNIQ,NSTATS*NDETLN)
      DIMENSION YAO2(NXYZF,NROT), YAS2(NXYZF,*),
     *                YAC2(NXYZF,NSTATS*NDETLN)
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     THIS SUB RE-DIMENSIONS THE ARRAYS PASSED INTO
C     THE MAT-VEC SUBS TO CUT DOWN ON MAT-VECS.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C     IOPT = 0 --> COPIES FROM NUNIQ TO SMALLER/SAME SIZE NXYZF
C     IOPT = 1 --> COPIES FROM SMALLER/SAME SIZE NXYZF TO NUNIQ
C     IOPT = 2 --> COPIES WITH NUNIQ SIZE BUT ONLY UNCONVERTED VECTORS
      IF (IOPT.NE.0 .AND. IOPT.NE.1 .AND. IOPT.NE.2) THEN
        IF (MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      IF (IOPT.EQ.0) THEN
        IUNIQ=0
        ITMP=0
        DO 100 IXYZ=1,NXYZ
          IF(NOCP(IXYZ).NE.1) IUNIQ=IUNIQ+1
          IF(NOCP(IXYZ).EQ.1) GO TO 100
          IF(NOCP(IXYZ).EQ.2) GO TO 100
            ITMP = ITMP + 1
            CALL DCOPY(NROT,YAO(IUNIQ,1),NUNIQ,YAO2(ITMP,1),NXYZF)
            CALL DCOPY(NNSTAT,YAS(IUNIQ,1),NUNIQ,YAS2(ITMP,1),NXYZF)
            CALL DCOPY(NDETLN*NSTATS,YAC(IUNIQ,1),NUNIQ,
     *                 YAC2(ITMP,1),NXYZF)
  100   CONTINUE
      ENDIF
      IF (IOPT.EQ.1) THEN
        IUNIQ=0
        ITMP=0
        DO 110 IXYZ=1,NXYZ
          IF(NOCP(IXYZ).NE.1) IUNIQ=IUNIQ+1
          IF(NOCP(IXYZ).EQ.1) GO TO 110
          IF(NOCP(IXYZ).EQ.2) GO TO 110
          ITMP = ITMP + 1
            CALL DCOPY(NROT,YAO2(ITMP,1),NXYZF,YAO(IUNIQ,1),NUNIQ)
            CALL DCOPY(NNSTAT,YAS2(ITMP,1),NXYZF,YAS(IUNIQ,1),NUNIQ)
            CALL DCOPY(NDETLN*NSTATS,YAC2(ITMP,1),NXYZF,
     *                 YAC(IUNIQ,1),NUNIQ)
  110   CONTINUE
      ENDIF
      IF (IOPT.EQ.2) THEN
        IUNIQ=0
        DO 120 IXYZ=1,NXYZ
          IF(NOCP(IXYZ).NE.1) IUNIQ=IUNIQ+1
          IF(NOCP(IXYZ).EQ.1) GO TO 120
          IF(NOCP(IXYZ).EQ.2) GO TO 120
            CALL DCOPY(NROT,YAO(IUNIQ,1),NXYZF,YAO2(IUNIQ,1),NUNIQ)
            CALL DCOPY(NNSTAT,YAS(IUNIQ,1),NXYZF,YAS2(IUNIQ,1),NUNIQ)
            CALL DCOPY(NDETLN*NSTATS,YAC(IUNIQ,1),NXYZF,
     *                 YAC2(IUNIQ,1),NUNIQ)
  120   CONTINUE
      ENDIF
C
C
 9000 FORMAT(1X,'PROBLEM WITH INPUT FOR SUB CPSHFTVEC')
      RETURN
      END
C*MODULE MCPCGX  *DECK CPSHFTYAX
      SUBROUTINE CPSHFTYAX(
     *           NSORT,
     *           ZZRESO,ZZRESS,ZZRESC,
     *           YAO,YAS,YAC,
     *           NUNIQ,NROT,NNSTAT,NDETLN,NSTATS)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION YAO(NUNIQ,NROT), YAS(NUNIQ,*),
     *                YAC(NUNIQ,NSTATS*NDETLN)
      DIMENSION ZZRESO(NNSTAT,NROT), 
     *          ZZRESS(NNSTAT,*),
     *          ZZRESC(NNSTAT,NSTATS*NDETLN)
      DIMENSION NSORT(NUNIQ)
C     
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     ***CPNSORT MUST BE CALLED BEFORE THIS SUB IS USED...***
C     ***BNORMX FORMED AFTER CALL TO CPSHFTYAX***
C     FOR NACME SOLUTION VECTORS READ IN FROM .INP FILE,
C     THIS SUB SYMMETRIZES THESE GUESS VECTORS.
C     NOTE:  IF DESIRED, COULD PRINT OFF TO .DAT FILE IN SYM. FORM
C     NOTE2:  TEMP. SUB TO PREVENT SOLVER FROM
C             -HAVING A LOT OF EXTRA MEMORY
C             -DOING EXTRA WORK ON NDER=1
C     NOTE3:  SUB REPLACED WITH FULL SYM. OF SUB ZCPMCX
C     NOTE4:  NOTE WHAT GETS PASSED IN AS NUNIQ...
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C     SHIFT TRULY UNIQUE RHS VECTORS TO PROPER PLACE.
      DO I=1,NNSTAT
      J = NSORT(I)
        CALL DCOPY(NROT,YAO(J,1),NUNIQ,
     *             ZZRESO(I,1),NNSTAT)
        CALL DCOPY(NNSTAT,YAS(J,1),NUNIQ,
     *             ZZRESS(I,1),NNSTAT)
        CALL DCOPY(NDETLN*NSTATS,YAC(J,1),NUNIQ,
     *             ZZRESC(I,1),NNSTAT)
      ENDDO
C
C     ESSENTIALLY RE-DEFINE THE LEADING DEMINSIONS
C     FOR YAX BEING READ IN...
      CALL VCLR(YAO,1,NUNIQ*NROT)
      CALL VCLR(YAS,1,NUNIQ*NNSTAT)
      CALL VCLR(YAC,1,NUNIQ*NDETLN*NSTATS)
      CALL DCOPY(NNSTAT*NROT,ZZRESO,1,YAO,1)
      CALL DCOPY(NNSTAT*NNSTAT,ZZRESS,1,YAS,1)
      CALL DCOPY(NNSTAT*NDETLN*NSTATS,ZZRESC,1,YAC,1)
      RETURN
      END
C
C*MODULE MCPCGX  *DECK CPUNSHFT
      SUBROUTINE CPUNSHFT(BKNUM,NSORT,
     *           BNORMO,BNORMC,BNORMS,
     *           YAO,YAS,YAC,
     *           NUNIQ,NROT,NNSTAT,NDETLN,NSTATS,
     *           YYAO,YYAS,YYAC)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (ONE=1.0D+00)
      DIMENSION YAO(NUNIQ,NROT), YAS(NUNIQ,*),
     *                YAC(NUNIQ,NSTATS*NDETLN)
      DIMENSION YYAO(NNSTAT,NROT),YYAS(NNSTAT,*),
     *                YYAC(NNSTAT,NSTATS*NDETLN)
      DIMENSION NSORT(NUNIQ),BKNUM(NUNIQ),
     *          BNORMO(NUNIQ),BNORMC(NUNIQ),BNORMS(NUNIQ)
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     THIS SUB UN-DOES ALL SYMMETRY FOR NDER=1.
C     A FINAL CHECK OF THE SOLUTION VECTORS
C     WITHOUT SYMMETRY IS THEN DONE.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C     HERE DEFINE LNUNIQ
      LNUNIQ = NNSTAT
C
C     NOTE:  NSORT ARRAY NOW CONTAINS THE REAL IUNIQ VALUE
C            WITH ZEROS AT THE END...
C
C     COPY YAX OVER TO YAXX...
C     WE NEED TO MANIPULATE THE LEAD DIMENSION AGAIN...
      CALL DCOPY(LNUNIQ*NROT,YAO,1,YYAO,1)
      CALL DCOPY(LNUNIQ*NNSTAT,YAS,1,YYAS,1)
      CALL DCOPY(LNUNIQ*NDETLN*NSTATS,YAC,1,YYAC,1)
C
C     FIRST, DISTRIBUTE THE SOLUTIONS TO PROPER LOCATIONS
      CALL VCLR(BKNUM,1,NUNIQ)
      DO I=1,LNUNIQ
        ITMP = NSORT(I)
        CALL DCOPY(NROT,YYAO(I,1),LNUNIQ,
     *             YAO(ITMP,1),NUNIQ)
        CALL DCOPY(NNSTAT,YYAS(I,1),LNUNIQ,
     *             YAS(ITMP,1),NUNIQ)
        CALL DCOPY(NDETLN*NSTATS,YYAC(I,1),LNUNIQ,
     *             YAC(ITMP,1),NUNIQ)
      ENDDO
C
C     RE-SORT THE RHS PIECES AS WELL...
      CALL VCLR(BKNUM,1,NUNIQ)
      DO I=1,LNUNIQ
        ITMP = NSORT(I)
        BKNUM(ITMP) = BNORMO(I)
      ENDDO
      CALL DCOPY(NUNIQ,BKNUM,1,BNORMO,1)
      CALL VCLR(BKNUM,1,NUNIQ)
      DO I=1,LNUNIQ
        ITMP = NSORT(I)
        BKNUM(ITMP) = BNORMC(I)
      ENDDO
      CALL DCOPY(NUNIQ,BKNUM,1,BNORMC,1)
      CALL VCLR(BKNUM,1,NUNIQ)
      DO I=1,LNUNIQ
        ITMP = NSORT(I)
        BKNUM(ITMP) = BNORMS(I)
      ENDDO
      CALL DCOPY(NUNIQ,BKNUM,1,BNORMS,1)
C
C     SECOND, COPY THE SOLUTION VECTORS BASED ON J >= I
      DO J=1,NSTATS
        DO I=1,NSTATS
          IF(I.LT.J) THEN
            I2 = I + NSTATS*(J-1)
            J2 = J + NSTATS*(I-1)
            BNORMO(I2) = BNORMO(J2)
            BNORMC(I2) = BNORMC(J2)
            BNORMS(I2) = BNORMS(J2)
            CALL DCOPY(NROT,YAO(J2,1),NUNIQ,
     *                 YAO(I2,1),NUNIQ)
            CALL DCOPY(NNSTAT,YAS(J2,1),NUNIQ,
     *                 YAS(I2,1),NUNIQ)
            CALL DCOPY(NDETLN*NSTATS,YAC(J2,1),NUNIQ,
     *                 YAC(I2,1),NUNIQ)
            CALL DSCAL(NROT,-ONE,YAO(I2,1),NUNIQ)
            CALL DSCAL(NNSTAT,-ONE,YAS(I2,1),NUNIQ)
            CALL DSCAL(NDETLN*NSTATS,-ONE,YAC(I2,1),NUNIQ)
          ENDIF
        ENDDO
      ENDDO
C
      RETURN
      END
C
C*MODULE MCPCGX  *DECK CPDCOPYREC
      SUBROUTINE CPDCOPYREC(ZRESO,ZRESS,ZRESC,
     *                      RESIDO,RESIDS,RESIDC,
     *                      NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *                      IUNIQ)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION RESIDO(NUNIQ,NROT), RESIDS(NUNIQ,*),
     *                RESIDC(NUNIQ,NSTATS*NDETLN),
     *          ZRESO(NUNIQ,NROT), ZRESS(NUNIQ,*),
     *                ZRESC(NUNIQ,NSTATS*NDETLN)
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     THIS SUB COPIES OVER VECTORS FROM POSITION 1
C     TO ALL OTHER POSITIONS.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C
          CALL DCOPY(NROT,ZRESO(1,1),NUNIQ,RESIDO(IUNIQ,1),
     *               NUNIQ)
          CALL DCOPY(NNSTAT,ZRESS(1,1),NUNIQ,RESIDS(IUNIQ,1),
     *               NUNIQ)
          CALL DCOPY(NSTATS*NDETLN,ZRESC(1,1),NUNIQ,
     *               RESIDC(IUNIQ,1),NUNIQ)
C
      RETURN
      END
C*MODULE MCPCGX  *DECK CPMATVEC_NOSYM
      SUBROUTINE CPMATVEC_NOSYM(NUMPARR3,
     *           RESIDC,RESIDO,RESIDS,
     *           PDIRO,EPS,OPDM,TPDM,IA,L0,
     *           PDIRC,PDIRS,PRCNDS,SALAG,
     *           CI,OINT,FCORSQ,AMAT,ERI,INDEX,IWRK,IFA,IOX,NCOR,NACT,
     *           NA,NB,L1,L2,NSYM,IIS,NDETMX,NDETLN,NROT,NUNIQ,JLO,JHI,
     *           NSTATS,WSTATE,WRK,YADEN,AVEC,BVEC,YAOTMP,ITER,GENMC,
     *           LNEED,LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,ITGA,ITGB,IAST,
     *           IBST,NB1EX,JROTLO,JROTHI,
     *           NNSTAT,
     *           TIMCI,TIMORB)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER         C_OOOO, C_VOOO, C_VVOO, C_VOVO
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL GENMC
      PARAMETER (TWO=2.0D+00)
      DIMENSION  RESIDC(NUNIQ,NSTATS*NDETLN),RESIDO(NUNIQ,NROT),
     *           RESIDS(NUNIQ,*),
     *           EPS(L1,L1),OPDM(*),TPDM(*),IA(*),
     *           PDIRC(NUNIQ,NSTATS*NDETMX),PDIRO(NUNIQ,NROT),
     *           PDIRS(NUNIQ,*),
     *           PRCNDS(*),
     *           SALAG(L1,L1,NSTATS*NSTATS),
     *           CI(NDETMX,NSTATS),OINT(L2),FCORSQ(L1,L1),AMAT(*),
     *           ERI(*),
     *           INDEX(L1,L1),IWRK(IIS),IFA(0:NACT,0:NACT),IOX(NACT),
     *           WSTATE(*),WRK(*),YADEN(*),AVEC(*),BVEC(*),YAOTMP(*)
C
      DIMENSION LBOX1(*),LBOX2(*),LBOX3(*),LBOX4(*),LBOX5(*)
C
      COMMON /DLBTIM/ C_OOOO,C_VOOO,C_VVOO,C_VOVO
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     THIS SUB DIRECTLY CALLS TOP-MOST SUBS TO
C     MATRIX-VECTOR MULTIPLY.
C     NOTE:  IT CAN BE USED WITHOUT SYMMETRY.
C            HOWEVER, SYM. VECTORS ARE OFTEN FED IN.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C
      CALL TSECND(TIM)
      TIM1 = TIM
      IF(GOPARR) THEN
        CALL DDI_PROCDLB_RESET(C_OOOO)
        CALL DDI_PROCDLB_RESET(C_VOOO)
        CALL DDI_PROCDLB_RESET(C_VVOO)
        CALL DDI_PROCDLB_RESET(C_VOVO)
        CALL HSMLTP(RESIDO,PDIRO,OINT,EPS,OPDM,TPDM,WRK,INDEX,IA,NROT,
     *              NUNIQ,NCOR,NACT,L0,L1,L2)
C
      ENDIF
      CALL TSECND(TIM)
      TIM2 = TIM
      TIMORB = TIM2 - TIM1
C
      CALL HSMLTC(RESIDC,RESIDO,RESIDS,PDIRO,PDIRC,PDIRS,PRCNDS,SALAG,
     *            CI,OINT,FCORSQ,AMAT,ERI,INDEX,IWRK,IFA,IOX,NCOR,NACT,
     *            NA,NB,L1,L2,NSYM,IIS,NDETMX,NDETLN,NROT,NUNIQ,JLO,JHI,
     *            NSTATS,WSTATE,WRK,YADEN,AVEC,BVEC,YAOTMP,ITER,GENMC,
     *            LNEED,LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,ITGA,ITGB,IAST,
     *            IBST,NB1EX,JROTLO,JROTHI)
      CALL TSECND(TIM)
      TIMCI = TIM - TIM2
C
      IF(GOPARR) CALL DDI_GSUMF(NUMPARR3,RESIDO,NROT*NUNIQ)
C
C     HAMILTONIAN SUPPOSEDLY CONTAINS A FACTOR OF 1/2
      CALL DSCAL(NROT*NUNIQ,TWO,RESIDO,1)
      CALL DSCAL(NNSTAT*NUNIQ,TWO,RESIDS,1)
      CALL DSCAL(NSTATS*NDETLN*NUNIQ,TWO,RESIDC,1)
C
      RETURN
      END
C*MODULE MCPCGX  *DECK CPCTST 
      SUBROUTINE CPCTST(NAPICK,NACST)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL NAPICK
      PARAMETER (MXRT=100)
      PARAMETER (ZERO=0.0D+00)
      DIMENSION NACST(MXRT*(MXRT-1))
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,SDET,SZDET,
     *                GRPDET,STSYM,GLIST,DWPARM,
     *                NFLGDM(MXRT),IWTS(MXRT),
     *                NCORSVDET,NCORDET,NACTDET,NORBDET,NADET,NBDET,
     *                KDET,KSTDET,IROOTDET,IPURES,MAXW1,NITERDET,
     *                MAXP,NCIDET,IGPDET,KSTSYMDET,NFTGCI,IDWEIGH
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /C0NICL/ PNTSTP,PNTGRD,PNALFA,PNSIGM,NCVGPN,NCNCL,NEG2CL,
     *                NDBGCI,IXROOT(2),IXSTAT(2)
      DATA CONICAL/8HCONICAL /
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     USED FOR USER SELECTED NA COUPLINGS
C     NOTE:  CONTAINS VARIOUS ERROR OUTS.
C     NOTE2:  TEST ALL POSSIBLE INPUTS IF YOU
C             DECIDE TO CHANGE THIS.
C     NOTE3:  NACST ARRAY IS FILLED BEFORE THIS SUB.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C     COUNT UP THE TOTAL NUMBER OF SPIN STATES OF A GIVEN MULTIPLICITY
      ISTATM=0   ! COUNTS STATES MATCHING DESIRED MULTIPLICITY
      ISTAT =0   ! COUNTS SUCH STATES THAT ALSO HAVE NON-ZERO WEIGHT
      DO 3 IST=1,KDET
        IF(ABS(SPINS(IST)-SDET) .GT. 0.03D+00) GO TO 3
        ISTATM = ISTATM + 1
        IF(WSTATE(ISTATM).EQ.ZERO) GO TO 3
        ISTAT = ISTAT + 1
   3  CONTINUE
C
C     CHECK IF THIS RUN IS A CONICAL INTERSECTION SEARCH
C     AND
C     FORCE THE STATES TO BE THE 2 STATES OF INTEREST.
      IF(RUNTYP.EQ.CONICAL) THEN
        IF(MASWRK) WRITE(IW,9200) NACST(1),NACST(2),IXROOT(1),IXROOT(2)
        DO I=1,MXRT*(MXRT-1)
          NACST(I)=0
        ENDDO
        NACST(1)=IXROOT(1)
        NACST(2)=IXROOT(2)
      ENDIF
C
C     CHECK THAT USER INPUTS NO 0'S FOR THE STATE NUMBER
      ICHK = 0
      DO I=1,MXRT*(MXRT-1)
        IF (NACST(I).EQ.0 .AND. ICHK.EQ.0) ICHK = 1
        IF (ICHK.EQ.1 .AND. NACST(I).NE.0) ICHK = ICHK + 1
      ENDDO
      IF (ICHK.NE.1) THEN
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     IF NAPICK IS SET TRUE BY THE USER,
C     CHECK THAT NACST ARRAY IS INPUT.
      IF(NAPICK .AND. NACST(1).EQ.0) THEN
          IF(MASWRK) WRITE(IW,9001)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP 
      ENDIF 
C
C     SET NAPICK TO TRUE TO INDICATE LESS LINEAR EQUATIONS FOR CPMCHF.
      IF (NACST(1).NE.0) NAPICK=.TRUE.
      IF (.NOT.NAPICK) GO TO 100
      IF (NAPICK) THEN
C       DETERMINE TOTAL POSSIBLE UNIQUE COUPLINGS
        ITOT = (ISTAT - 1)*ISTAT/2
C       ERROR OUT IF TOTAL NA COUPLINGS EXCEEDS POSSIBLE
C                          NUMBER OF COUPLINGS
C       NOTE:  THESE ARE PAIRS OF STATES.
        IF (NACST(2*ITOT+1).NE.0) THEN
          IF(MASWRK) WRITE(IW,9002) ITOT
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
C
C       RE-SET ITOT TO BE OVER STATES RATHER THAN PAIRS OF STATES
        ITOT = 2*ITOT
C
C       CHECK THAT USER HAS INPUT PAIRS OF STATES
C       NOTE:  ITOT+1 UPPER BOUND IS FOR ALL FILLED.
        DO I=1,ITOT+1
          IF (NACST(I).EQ.0) THEN
            IF(MOD(I,2).NE.0) THEN
              ITOT2 = I-1
              GO TO 4
            ELSE
              IF(MASWRK) WRITE(IW,9003)
              CALL FLSHBF(IW)
              CALL ABRT
              STOP
            ENDIF
          ENDIF
        ENDDO
      ENDIF
   4  CONTINUE
C
C     FOR EACH STATE PAIR,
C     ENSURE THE STATE ORDER IS INPUT FROM LOWEST TO HIGHEST
      DO I=1,ITOT2,2
        ITMP=NACST(I)
        ITMP2=NACST(I+1)
        IF (ITMP .GE. ITMP2) THEN
          IF(MASWRK .AND. ITMP.GT.ITMP2) WRITE(IW,9004)
          IF(MASWRK .AND. ITMP.EQ.ITMP2) WRITE(IW,9005)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
      ENDDO
C
C
      ISTATM=0   ! COUNTS STATES MATCHING DESIRED MULTIPLICITY
      ISTAT =0   ! COUNTS SUCH STATES THAT ALSO HAVE NON-ZERO WEIGHT
      DO 5 IST=1,KDET
        IF(ABS(SPINS(IST)-SDET) .GT. 0.03D+00) GO TO 5
        ISTATM = ISTATM + 1
C       NOTE:  USUALLY .EQ.ZERO
        IF(WSTATE(ISTATM).NE.ZERO) GO TO 5
C       CHECK THAT NO DYNAMICS INPUTS FOR ZERO WEIGHTS
        DO I=1,ITOT2
          ITMP = NACST(I)
          IF (ITMP.EQ.ISTATM) THEN
            IF(MASWRK) WRITE(IW,9006) ISTATM
            CALL FLSHBF(IW)
            CALL ABRT
            STOP
          ENDIF
        ENDDO
   5  CONTINUE
C
C
C
C     CHECK THAT USER ENTERED STATES PAIRS ARE UNIQUE.
      DO I=1,ITOT2,2
        DO J=I+2,ITOT2,2
          ITMP = NACST(I) - NACST(J)
          ITMP2 = NACST(I+1) - NACST(J+1)
          IF (ITMP.EQ.0 .AND. ITMP2.EQ.0) THEN
            IF(MASWRK) WRITE(IW,9007)
            CALL FLSHBF(IW)
            CALL ABRT
            STOP
          ENDIF
        ENDDO
      ENDDO
C
C     DEFINE THE NON-ZERO STATES AND SHIFT THE STATE LABELS
C     TO BE APPROP. FOR OBTAINING THE APPROP. USER SELECTED
C     GRADIENTS AND NA COUPLINGS.
      ISTATM=0   ! COUNTS STATES MATCHING DESIRED MULTIPLICITY
      ISTAT =0   ! COUNTS SUCH STATES THAT ALSO HAVE NON-ZERO WEIGHT
      I     =1   ! COUNTS UP THE USER SELECTED NON-ZERO STATES
      DO 6 IST=1,KDET
        IF(ABS(SPINS(IST)-SDET) .GT. 0.03D+00) GO TO 6
        ISTATM = ISTATM + 1
        IF(WSTATE(ISTATM).EQ.ZERO) GO TO 6
        ISTAT  = ISTAT  + 1
C       ASSIGN NEW LABEL BASED ON NON-ZERO WSTATE HERE
        IF (ISTATM.EQ.NACST(I)) THEN
          NACST(I) = ISTAT
          I = I + 1
        ENDIF
   6  CONTINUE
C
C
 100  CONTINUE
C
C
 9000 FORMAT(/1X,'NACST ARRAY CANNOT HAVE STATE ENTRIES OF 0.')
 9001 FORMAT(/1X,'SELECTING NAPICK=.TRUE. REQUIRES INPUT OF',1X,
     *           'NACST ARRAY.')
 9002 FORMAT(/1X,'STATE PAIRS CANNOT EXCEED',1X,
     *          'TOTAL WSTATE NA COUPLING PAIRS OF',1X,I4)
 9003 FORMAT(/1X,'NEED TO ENTER PAIRS OF STATES FOR NA COUPLINGS.')
 9004 FORMAT(/1X,'SELECT STATE PAIRS IN NACST IN INCREASING ORDER.')
 9005 FORMAT(/1X,'EQUAL STATES CANNOT GIVE NA COUPLINGS IN NACST.')
 9006 FORMAT(/1X,'NO NACME FOR ZERO ELEMENT IN WSTATE FOR STATE',1X,I4)
 9007 FORMAT(/1X,'STATE PAIRS NEED TO BE UNIQUE')
 9200 FORMAT(/1X, 'FOR Z-VECTOR ONLY,'
     *       /1X, 'NACST ARRAY IS NOW RESTRICTED TO ',
     *            'ONE NA COUPLING VIA IXROOT ARRAY:',
     *       /1X, 'Z-VECTOR ONLY',
     *       /1X, 'OLD NACST(1)=',1X,I4,1X,I4,
     *       /1X, 'NEW NACST(1)=',1X,I4,1X,I4)
      RETURN
      END
C*MODULE MCPCGX  *DECK CPNAPICK
      SUBROUTINE CPNAPICK(NACST,NSTATS,NOCP,NXYZ)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXRT=100)
      DIMENSION NACST(MXRT*(MXRT-1)),NOCP(NXYZ)
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     USED FOR USER SELECTED NA COUPLINGS
C     NOTE:  READS THE NACST ARRAY FOR
C            USER-SELECTED NA COUPLINGS
C     NOTE:  MADE FOR SYM. NDER=1 Z-VECTOR ONLY.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C     REOBTAIN MAX. USER ENTRY
C     NOTE:  OTHER SUB CHECKS FOR INTRA-ENTRY ZEROS IN NACST
C     NOTE:  A LITTLE EXTRA WORK HERE...
      ICHK = 0
      DO I=1,MXRT*(MXRT-1)
        IF (NACST(I).EQ.0) ICHK = ICHK + 1
        IF (ICHK.EQ.1) ITOT2 = I - 1
      ENDDO
C
C     DESPITE LOOPS RUNNING OVER NSTATS**2,
C     THAT SHOULD NOT MATTER FOR SYM. 
C     'CONVERGE' ALL NA COUPLINGS
C     NOTE:  KEEPING ALL GRADIENTS FOR NOW
      IXYZ = 0
      DO J=1,NSTATS
        DO I=1,NSTATS
          IF (I.GE.J) IXYZ = IXYZ + 1
          IF (I.GT.J) THEN
            IF(NOCP(IXYZ).NE.1) NOCP(IXYZ) = 2
          ENDIF
        ENDDO
      ENDDO
C
C     USE NACST ARRAY TO EXTRACT THE SELECT NA COUPLINGS
      DO I=1,ITOT2,2
        J1 = NACST(I)
        I1 = NACST(I+1)
C       COUNT UP TO THE PROPER IUNIQ VECTOR
        ISAV = 0
        DO JJ=1,NSTATS
          DO II=1,NSTATS
            IF (II.GE.JJ) ISAV = ISAV + 1
            IF (JJ.EQ.J1 .AND. II.EQ.I1) IXYZ = ISAV
          ENDDO
        ENDDO
C       SET THE NA COUPLINGS AS UNCONVERGED
        IF(NOCP(IXYZ).NE.1) NOCP(IXYZ) = 0
      ENDDO
C
C
      RETURN
      END
C*MODULE MCPCGX  *DECK CPNAZERO
      SUBROUTINE CPNAZERO(NACST,NOCP,NXYZ,NSTATS)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      PARAMETER (MXRT=100)
      DIMENSION NACST(MXRT*(MXRT-1)),NOCP(NXYZ)
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     USED FOR USER SELECTED NA COUPLINGS
C     NOTE:  FORMS UNSYM. NACST ARRAY
C            FOR FINAL UNSYM. NACME VECTORS.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
C     INITIALIZE NOCP ARRAY JUST TO CHECK.
      DO I=1,NXYZ
        IF(NOCP(I).EQ.0) NOCP(I)=2
      ENDDO
C
C
      NERR=0
      DO I=1,NSTATS**2,2
        J1 = NACST(I)
        I1 = NACST(I+1)
C       COUNT UP TO THE PROPER IUNIQ VECTOR
        ISAV = 0
        DO JJ=1,NSTATS
          DO II=1,NSTATS
            ISAV = ISAV + 1
            IF (JJ.EQ.J1 .AND. II.EQ.I1) IXYZ = ISAV
            IF (II.EQ.J1 .AND. JJ.EQ.I1) IXYZ2 = ISAV
          ENDDO
        ENDDO
C       ERROR OUT IF ANY VECTORS HAVE VALUE OF 1
        IF(NOCP(IXYZ).EQ.1) NERR = 1
C       SET THESE SPECIFIC NOCP VECTORS AS UNCONVERGED,
C       AND HENCE LEAVE THE NON-REQUESTED VECTORS AS CONVERGED
        NOCP(IXYZ) = 0
        NOCP(IXYZ2) = 0
      ENDDO
C
      IF (NERR.EQ.1) THEN
        IF(MASWRK) WRITE(IW,*) "PROBLEM IN SUB CPNAZERO"
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
      END
C*MODULE MCPCGX  *DECK CPNAGET
      SUBROUTINE CPNAGET(NAPICK)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXRT=100)
      DIMENSION NACST(MXRT*(MXRT-1))
      LOGICAL NAPICK,GCRO,GCRODR,CGGCRO,PRCCHG
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
C
C     NOTE:  HERE WE ONLY CARE ABOUT RETURNING THE NAPICK LOGICAL
C            FOR USER INPUT PURPOSES (FOR CALLING ZPCMCX VS. CPMCX)
C            THE DEFAULT SETTINGS THAT APPEAR EARLIER IN THE
C            SUB MCPCGX ARE MUCH MORE EXTENSIVE AND APPROPRIATE.
C     NOTE2:  COULD RE-WRITE WITH EXTRA INITIAL VARS
C             AND CALL FROM SUB MCPCGX AS WELL.
C
C     SET UP NAMELIST SIMULATION FOR $CPMCHF GROUP
C     NOTE:  KEEP IDENTICAL TO OTHER CALL NAMEIO AT TOP OF MCPCG.SRC
      PARAMETER (NNAM=16)
      DIMENSION QNAM(NNAM),KQNAM(NNAM)
      DATA RNAM/8HCPMCHF  /
      DATA QNAM/8HMAXIT   ,8HCPTOL   ,8HNACFAC  ,8HIPDIR   ,
     *          8HGCRO    ,8HGCRODR  ,8HMICIT   ,8HKICIT   ,
     *          8HCGGCRO  ,8HITERA   ,8HITERB   ,
     *          8HNAPICK  ,8HNACST   ,8HRECLIN  ,
     *          8HPRCCHG  ,8HPRCTOL  /
      DATA KQNAM/1,3,1,1, 0,0,1,1, 0,1,1, 0,-1,0, 0,3/
      KQNAM(13) = 10*MXRT*(MXRT-1) + 1
      JRET = 0
      CALL NAMEIO(IR,JRET,RNAM,NNAM,QNAM,KQNAM,
     *     MAXIT,CPTOL,NACFAC,IPDIR,
     *     GCRO,GCRODR,MICIT,KICIT,
     *     CGGCRO,ITERA,ITERB,
     *     NAPICK,NACST,RECLIN,
     *     PRCCHG,PRCTOL,0,
     *     0,0,0,0,
     *     0,0,0,0,
     *     0,0,0,0,
     *     0,0,0,0,
     *     0,0,0,0,
     *     0,0,0,0,
     *     0,0,0,0,
     *     0,0,0,0,
     *     0,0,0,0,
     *     0,0,0,0,
     *     0,0,0,0
     *     0,0,0,0)
      IF(JRET.EQ.2) CALL ABRT
C
      RETURN
      END
C*MODULE MCPCGX  *DECK CPQRPROJ
      SUBROUTINE CPQRPROJ(HMAT2,GMAT,IPVT,WRKMP,WRKK,
     *                    RMATINV,QMAT,PMAT,MICIT,KICIT)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
C     THIS SUB PERFORM A QR FACTORIZATION ON SOME
C     PROJECTED/REDUCED MATRIX.
C
      DIMENSION HMAT2(MICIT+1,MICIT),GMAT(MICIT+1,MICIT),
     *          IPVT(MICIT),WRKMP(MICIT+1),WRKK(KICIT),
     *          RMATINV(MICIT,MICIT),QMAT(MICIT+1,MICIT),
     *          PMAT(MICIT,KICIT)
C
      CALL VCLR(HMAT2,1,(MICIT+1)*MICIT)
      CALL MRARBR(GMAT,
     *            MICIT+1,MICIT+1,MICIT,
     *            PMAT,MICIT,KICIT,
     *            HMAT2,MICIT+1)
C     NOTE:  GMAT IS NOW DESTROYED...
      CALL DCOPY((MICIT+1)*MICIT,HMAT2,1,GMAT,1)
C     NOTE:  COULD INCREASE WORK DIMENSIONS LATER ON.
      CALL DGEQRF(MICIT+1,KICIT,HMAT2,MICIT+1,
     *            WRKK,WRKMP,MICIT+1,INFO)
      CALL VCLR(RMATINV,1,MICIT**2)
      DO I=1,KICIT
        CALL DCOPY(I,HMAT2(1,I),1,RMATINV(1,I),1)
      ENDDO
      CALL DGECO(RMATINV,MICIT,MICIT,IPVT,RCOND,WRKMP)
      CALL DGEDI(RMATINV,MICIT,MICIT,IPVT,DET,WRKMP,01)
C     NOTE:  LATER ON, GO BACK AND GET QMAT FROM INFO IN THE DGELS CALL.
      CALL VCLR(QMAT,1,(MICIT+1)*MICIT)
      CALL MRARBR(GMAT,
     *            MICIT+1,MICIT+1,KICIT,
     *            RMATINV,MICIT,KICIT,
     *            QMAT,MICIT+1)

      RETURN
      END
C*MODULE MCPCGX  *DECK CPEIGEN
      SUBROUTINE CPEIGEN(GMAT,HMAT2,
     *                  IPVT,WRKMP,WRKD,WKDGEL,
     *                  RMAT,RMATINV,EVALR,EVALI,
     *                  PMAT,MICIT,KICIT,IKIND)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00)
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     THIS SUB GRABS OUT THE SMALLEST, APPROX. EIGENVECTORS
C     FROM SOME PROJECTED/REDUCED SYSTEM.
C     NOTE:  THESE INJECTED EIGENVECTORS INCLUDE THE
C            NEGATIVE HARMONIC ONES.
C
C     IKIND = 1 --> INDICATES REGULAR EVALUE PROBLEM FROM GMRES-DR
C     IKIND = 2 --> INDICATES GENERALIZED EVALUE PROBLEM FROM GCRO-DR
C
C     NOTE:  SINCE MATRICES GENERAL AND SMALL,
C            INVERTING TO A REGULAR EVALUE PROBLEM
C
      DIMENSION GMAT(MICIT+1,MICIT),HMAT2(MICIT+1,MICIT),
     *          EVALR(MICIT),EVALI(MICIT),PMAT(MICIT,KICIT),
     *          RMATINV(MICIT,MICIT),RMAT(MICIT,MICIT),
     *          IPVT(MICIT),WRKMP(MICIT+1),WRKD(8*MICIT),
     *          WKDGEL(2*(MICIT+1)*MICIT)
C
C
      IF (IKIND.GT.2.OR.IKIND.LT.0) THEN
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      IF (IKIND.EQ.0) THEN
C       FINISH SET UP FOR REGULAR EVALUE PROBLEM
        DO I=1,MICIT
          CALL DCOPY(MICIT,GMAT(1,I),1,RMAT(1,I),1)
          CALL DCOPY(MICIT,GMAT(1,I),1,RMATINV(1,I),1)
        ENDDO
C       NOTE:  THE ORDER OF OPERATIONS IS TRANSPOSE AND THEN INVERSE
        CALL TRPOSQ(RMATINV,MICIT)
        CALL DGECO(RMATINV,MICIT,MICIT,IPVT,RCOND,WRKMP)
        CALL DGEDI(RMATINV,MICIT,MICIT,IPVT,DET,WRKMP,01)
        TMP = GMAT(MICIT+1,MICIT)
        TMP = TMP**2   
        CALL DSCAL(MICIT,TMP,RMATINV(1,MICIT),1)
        CALL DAXPY(MICIT,ONE,RMATINV(1,MICIT),1,RMAT(1,MICIT),1)
      ELSE
C       FINISH SET UP FOR GENEARLIZED EVALUE PROBLEM
        CALL MRTRBR(GMAT,
     *              MICIT+1,MICIT+1,MICIT,
     *              HMAT2,MICIT+1,MICIT,
     *              RMATINV,MICIT)
C       FORM LHS MATRIX
        CALL VCLR(HMAT2,1,(MICIT+1)*MICIT)
        CALL MRTRBR(GMAT,
     *              MICIT+1,MICIT+1,MICIT,
     *              GMAT,MICIT+1,MICIT,
     *              HMAT2,MICIT+1)
C       FORM FINAL MATRIX FOR EIGENVALUE PROBLEM
        CALL DGECO(RMATINV,MICIT,MICIT,IPVT,RCOND,WRKMP)
        CALL DGEDI(RMATINV,MICIT,MICIT,IPVT,DET,WRKMP,01)
        CALL MRARBR(RMATINV,
     *              MICIT,MICIT,MICIT,
     *              HMAT2,MICIT+1,MICIT,
     *              RMAT,MICIT)
      ENDIF
C
C     FINISH OFF SOLVING REGULAR OR GENERALIZED EVALUE PROBLEM.
C     NOTE:  SEE INSTRUCTIONS IN DGEEV IF TROUBLED BY VL BELOW.
      CALL VCLR(RMATINV,1,MICIT**2)
      CALL DGEEV('N','V',
     *          MICIT,RMAT,MICIT,
     *          EVALR,EVALI,
     *          VL,1,RMATINV,MICIT,
     *          WRKD,8*MICIT,INFO)
C     SORT THE EIGENVECTORS 
      DO I=1,MICIT
        TMP1 = EVALR(I)
        IF (EVALI(I).NE.ZERO) THEN
C         NOT QUITE RIGHT BELOW BUT REAL EVALUES ANYWAYS.
          SIGN=ABS(TMP1)/TMP1
          TMP2 = EVALI(I)
          TMP2 = TMP2**2
          TMP1 = TMP1**2
          TMP1 = TMP1 + TMP2
          TMP1 = SIGN*SQRT(TMP1)
        ENDIF
C       SAVE SIGN AND MAGNITUDE OF REAL OR COMPLEX EIGENVALUE 
C       NOTE:  INCLUSION OF NEG. EVALUES HELPS
C              WITHOUT PARTITIONED VERSION.
        EVALR(I) = TMP1
      ENDDO
CAW      CALL ORDERV(RMATINV,EVALR,WKDGEL,WRKMP,MICIT,KICIT,MICIT)
      CALL ORDERV(RMATINV,EVALR,WKDGEL,WRKMP,MICIT,MICIT,MICIT)
C     SAVE KICIT EIGENVECTORS INTO PMAT
      DO I=1,KICIT
        CALL DCOPY(MICIT,RMATINV(1,I),1,PMAT(1,I),1)
      ENDDO
C
C
 9000 FORMAT(/1X,'PROGRAMMING ERROR IN SUB CPEIGEN.  PRINT IKIND.')
      RETURN
      END
C*MODULE CPMCHF  *DECK CPPROJYAX
      SUBROUTINE CPPROJYAX(NUMPARR,
     *           CMATO,CMATS,CMATC,
     *           UMATO,UMATS,UMATC,
     *           YAO,YAC,YAS,
     *           RESIDO,RESIDC,RESIDS,
     *           ZRESO,ZRESC,ZRESS,
     *           PRCNDO,PRCNDC,PRCNDS,
     *           ZZRESO,ZZRESS,ZZRESC,
     *           NXYZ,NUNIQ,NROT,NDETLN,NSTATS,NNSTAT,
     *           JLO,JHI,
     *           NOCP,KICIT,WRKK)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (ONE=1.0D+00)
C
      DIMENSION NOCP(NXYZ),WRKK(KICIT)
      DIMENSION ZZRESO(NUNIQ,NROT),
     *          ZZRESS(NUNIQ,*),
     *          ZZRESC(NUNIQ,NDETLN*NSTATS)
      DIMENSION CMATO(NUNIQ,NROT,KICIT),
     *          CMATS(NUNIQ,NNSTAT,KICIT),
     *          CMATC(NUNIQ,NDETLN*NSTATS,KICIT),
     *          UMATO(NUNIQ,NROT,KICIT),
     *          UMATS(NUNIQ,NNSTAT,KICIT),
     *          UMATC(NUNIQ,NDETLN*NSTATS,KICIT)
      DIMENSION YAO(NUNIQ,NROT),YAC(NUNIQ,NSTATS*NDETLN),YAS(NUNIQ,*),
     *          PRCNDO(NROT),PRCNDC(NSTATS*NDETLN),PRCNDS(*),
     *          RESIDO(NUNIQ,NROT),RESIDC(NUNIQ,NSTATS*NDETLN),
     *          RESIDS(NUNIQ,*),ZRESO(NUNIQ,NROT),
     *          ZRESC(NUNIQ,NSTATS*NDETLN),ZRESS(NUNIQ,*)
C
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C     THIS SUB USES THE TRUE RESIDUAL RESIDX,
C     GUESS VECTORS YAX, AND OLD BASES UMATX,CMATX.
C     THIS SUB PROJECTS OVER THE OLD BASES
C     TO FORM A MORE OPTIMAL GUESS.
C     NOTE:  SUB. CAN BE USED B/T GEOMETRIES
C            OR AT SAME GEOMETRY B/T EQUATIONS.
C     NOTE2: THIS WORKS ONLY AS
C            AS WELL AS SLOWLY-VARYING EQS.
C     --------------------------------------------
C     --------------------------------------------
C     --------------------------------------------
C
        IUNIQ = 0
        DO 20 IXYZ=1,NXYZ
          IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
          IF(NOCP(IXYZ).NE.0) GO TO 20 
C         UPDATE YAX FOR THE OTHER SYSTEMS BASED ON THE 1ST SYSTEM...
          DO I=1,KICIT
            CALL CPMKDOT(NUMPARR,
     *           RESIDO,RESIDS,RESIDC,
     *           CMATO(1,1,I),
     *           CMATS(1,1,I),
     *           CMATC(1,1,I),
     *           NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *           IUNIQ,TMP)
            WRKK(I) = TMP
          ENDDO
          CALL CPMATVEC2(
     *         UMATO,UMATS,UMATC,
     *         ZRESO,ZRESS,ZRESC,
     *         WRKK,
     *         NROT,NSTATS,NDETLN,NNSTAT,
     *         IUNIQ,NUNIQ,
     *         KICIT,KICIT,
     *         1,KICIT)
          CALL CPMKPRES(
     *         ZRESO,ZRESS,ZRESC,
     *         ZZRESO,ZZRESS,ZZRESC,
     *         PRCNDO,PRCNDS,PRCNDC,
     *         NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *         JLO,JHI,IUNIQ)
          CALL CPDAXPY(
     *         ZZRESO,ZZRESS,ZZRESC,
     *         YAO,YAS,YAC,
     *         NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
     *         IUNIQ,ONE)
   20   CONTINUE
C       NOTE:  WE DO NOT USE THE RECURSIVE RESIDUAL
C              B/C OF ITS ROUNDING ERRORS FOR
C              SPARSE MATRICES
C              BELOW CODE LEFT FOR COMPLETENESS.
C
C        IUNIQ = 0
C        DO 30 IXYZ=1,NXYZ
C          IF(NOCP(IXYZ).NE.1) IUNIQ = IUNIQ + 1
C          IF(NOCP(IXYZ).NE.0) GO TO 30 
CC         NOTE:  WRKK DOES NOT CHANGE...
C          CALL CPMATVEC2(
C     *         CMATO,CMATS,CMATC,
C     *         ZRESO,ZRESS,ZRESC,
C     *         WRKK,
C     *         NROT,NSTATS,NDETLN,NNSTAT,
C     *         IUNIQ,NUNIQ,
C     *         KICIT,KICIT,
C     *         1,KICIT)
C          CALL CPDAXPY(
C     *         ZRESO,ZRESS,ZRESC,
C     *         RESIDO,RESIDS,RESIDC,
C     *         NUNIQ,NROT,NSTATS,NDETLN,NNSTAT,
C     *         IUNIQ,-ONE)
C   30   CONTINUE
C
      RETURN
      END
