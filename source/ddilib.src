C  6 Feb 13 - SRP - delete old communicators when making new ones
C 23 MAR 12 - DGF - PAD COMMON BLOCKS
C 28 DEC 11 - DGF - REDUCE GDDI OUTPUT
C 11 AUG 11 - MWS/GDF - GDDI_INIT: SUPPRESS SCOPE CHANGE MESSAGES
C 11 AUG 10 - DGF - ADD GDDI_ASCOPE TO CHANGE SCOPE ASYNCHRONOUSLY
C 22 DEC 06 - BN,DGF  - VSCF SUBGROUP SUPPORT, REMOVE UNUSED ROUTINES
C  6 NOV 06 - MWS - ADJUST GDDI COMMON BLOCK
C  7 SEP 06 - RMO - CHANGE INTERFACE TO DDI GROUPS
C  5 JUL 05 - MWS - SELECT NEW ATOM,BASIS,EFP,PCM,DAF DIMENSIONS
C 30 APR 05 - DGF - SYNCHRONISE SYMBLK COMMON GDDI
C 19 MAY 04 - DGF - GAMESS-SPECIFIC INTERFACE WITH DDI ROUTINES
C
C*MODULE DDILIB   *DECK DDI_NSUMI
      SUBROUTINE DDI_NSUMI(MSGTAG, INT1, INT2, INT3, INT4, MSGLEN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (NBUF=4)
      INTEGER IBUF(NBUF)
C
C     SUM UP TO 4 INTEGERS IN ONE DDI_GSUMI
C
      IF(MSGLEN.GT.NBUF) CALL ABRT
C
C
      IF(MSGLEN.GE.1) IBUF(1)=INT1
      IF(MSGLEN.GE.2) IBUF(2)=INT2
      IF(MSGLEN.GE.3) IBUF(3)=INT3
      IF(MSGLEN.GE.4) IBUF(4)=INT4
C
      CALL DDI_GSUMI(MSGTAG,IBUF,MSGLEN)
C
      IF(MSGLEN.GE.1) INT1=IBUF(1)
      IF(MSGLEN.GE.2) INT2=IBUF(2)
      IF(MSGLEN.GE.3) INT3=IBUF(3)
      IF(MSGLEN.GE.4) INT4=IBUF(4)
C
      RETURN
      END
C*MODULE DDILIB   *DECK GDDI_INIT
C>
C>  @brief   create desired subgroup partitioning of assigned nodes
C>
C>  @details create desired subgroup partitioning of assigned nodes
C>
C>  @author  Dmitri Fedorov and/or Ryan Olson
C>
      SUBROUTINE GDDI_INIT(NEWNGROUPS,MANNOD,some)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL ISGDDI,PAROUT,INITGDDI,some,wasgddi
      INTEGER DDI_WORLD,DDI_GROUP,MANNOD(0:*)
      PARAMETER(DDI_WORLD=0,DDI_GROUP=1)
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,NPGLOB,NNGLOB,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
      INTEGER COMM(0:2)
      COMMON /GRPCOM/ COMM
      LOGICAL FIRST
      DATA FIRST /.TRUE./
      SAVE FIRST
C
      CALL GDDI_SCOPE(DDI_WORLD)
      if(some) WRITE(IW,9000) MEGLOB,NGROUPS,MYGROUP
C
C  SRP: DESTROYING OLD MPI COMMUNICATORS
C
      IF(.NOT.FIRST) THEN
        DO I=1,2
         CALL DDI_COMM_DESTROY(COMM(I))
        ENDDO
      ENDIF
C
      FIRST=.FALSE.
C
      IF(MANNOD(0).LT.0) THEN
        CALL DDI_GROUP_CREATE(NEWNGROUPS,COMM(0),COMM(1),COMM(2))
      ELSE
        CALL DDI_GROUP_CREATE_CUSTOM(NEWNGROUPS,MANNOD,
     &                               COMM(0),COMM(1),COMM(2))
      ENDIF
C
      NGROUPS=NEWNGROUPS
      CALL GDDI_SCOPE(DDI_GROUP)
      CALL DDI_NGROUP(NGROUPS,MYGROUP)
      if(some) WRITE(IW,9010) MEGLOB,NGROUPS,MYGROUP
C
      RETURN
 9000 FORMAT(/1X,'GDDI IS ABOUT TO SWITCH GROUPS: ',
     *        'MEGLOB=',I4,' NGROUPS=',I3,' MYGROUP=',I3)
 9010 FORMAT(/1X,'GDDI HAS SWITCHED GROUPS: ',
     *        'MEGLOB=',I4,' NGROUPS=',I3,' MYGROUP=',I3)
      END
C
C*MODULE DDILIB   *DECK GDDI_COMMID
      SUBROUTINE DDI_COMMID(DDI_SCOPE,COMMID)
      IMPLICIT NONE
C
      INTEGER DDI_SCOPE,COMMID
      INTEGER COMM(0:2)
      COMMON /GRPCOM/ COMM
C
      COMMID = COMM(DDI_SCOPE)
      RETURN
      END
C
C*MODULE DDILIB   *DECK GDDI_MASTID
      SUBROUTINE GDDI_MASTID(MASTID)
      IMPLICIT NONE
      INTEGER DDI_WORLD,DDI_GROUP
      LOGICAL ISGDDI,PAROUT,INITGDDI,GOPARR,DSKWRK,MASWRK,wasgddi
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      PARAMETER(DDI_WORLD=0,DDI_GROUP=1)
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,NPGLOB,NNGLOB,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      INTEGER NGROUPS,MYGROUP,ISCOPE,MEGLOB,NPGLOB,NNGLOB,JBTYP,
     *        MASTID(0:NGROUPS-1),I
C
C     FOR MASTID TO BE FILLED IN PROPERLY THE SCOPE MUST BE DDI_GROUP.
C     MASTID WILL CONTAIN THE GLOBAL ID OF MASTERS.
C
      DO I=0,NGROUPS-1
        MASTID(I)=0
        IF(I.EQ.MYGROUP.AND.ME.EQ.MASTER) MASTID(I)=MEGLOB
      ENDDO
      CALL GDDI_SCOPE(DDI_WORLD)
      CALL DDI_GSUMI( 2900, MASTID, NGROUPS )
      CALL GDDI_SCOPE(DDI_GROUP)
      RETURN
      END
C
C*MODULE DDILIB   *DECK GDDICOUNT
      SUBROUTINE GDDICOUNT(IMODE,LGROUP,MYJOB)
      IMPLICIT NONE
      INTEGER IMODE,MINE,NEXT,NGROUPS,LGROUP,MYGROUP,ISCOPE,MEGLOB,
     *        NPGLOB,NNGLOB,JBTYP,DDI_WORLD,DDI_GROUP
      PARAMETER(DDI_WORLD=0,DDI_GROUP=1)
      LOGICAL MYJOB,NXT,ISGDDI,PAROUT,INITGDDI,wasgddi
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,NPGLOB,NNGLOB,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi
      SAVE MINE,NEXT
C
C     STATIC AND DYNAMIC LOAD BALANCING BETWEEN GROUPS FOR GDDI.
C     NOTE THAT WORK DIVISION INSIDE A GROUP IS DONE ELSEWHERE.
C     DETERMINE IF THE CURRENT TASK MUST BE DONE BY THIS NODE.
C     BEFORE USAGE CALL WITH IMODE=-1 TO INITIALISE. THEN USE WITH
C     IMODE=0 FOR GETTING JOB STATUS. AFTER USAGE CALL WITH IMODE=1.
C     ON EXIT MYJOB IS TRUE OR FALSE, LGROUP WILL POINT WHAT GROUP WILL
C     DO THIS JOB IF STATIC LOAD BALANCING IS IN EFFECT.
C     HOPEFULLY IT IS UNDERSTOOD THAT CALLS TO GDDICOUNT CAN'T BE NESTED
C     (ONLY ONE LOOP CAN BE DIVIDED INTO GROUPS AT A TIME).
C
      NXT = JBTYP.EQ.1
      IF(ABS(IMODE).EQ.1) THEN
        NEXT = -1
        MINE = -1
        LGROUP=-1
C       NEVER, NEVER ADD .AND. GOPARR TO NXT FOR GDDI!
C       SOME GROUPS MAY HAVE ONE NODE AND GOPARR=.FALSE.
        IF(NXT) THEN
C        ACCORDING TO THE REST OF GAMESS WE CALL DDI_DLBRESET AT THE
C
C        END (NOT AT THE BEGINNING, STRANGE AS IT MAY BE).
C        CHANGING SCOPES TO THE WORLD BACK IS NECESSARY, BECAUSE
C        OTHERWISE SYNCING WILL BE DONE IN THE SAME GROUP, THUS
C        LEADING TO PROCESSES RESETTING AND ASKING FOR DLB OUT OF SYNC.
C
           IF(IMODE.EQ.1) THEN
             CALL GDDI_SCOPE(DDI_WORLD)
             CALL DDI_GDLBRESET()
             CALL GDDI_SCOPE(DDI_GROUP)
           ENDIF
        ENDIF
        MYJOB=.TRUE.
      ELSE
        MINE=MINE+1
        IF(NXT) THEN
C         DYNAMIC LOAD BALANCING
          IF(MINE.GT.NEXT) CALL DDI_GDLBNEXT(NEXT)
C         -1 SHOWS THAT THE GROUP RESPONSIBLE IS UNKNOWN.
          LGROUP=-1
          MYJOB=NEXT.EQ.MINE
        ELSE
C         STATIC LOAD BALANCING
          LGROUP=MOD(MINE,NGROUPS)
          MYJOB=LGROUP.EQ.MYGROUP
        ENDIF
      ENDIF
      RETURN
      END
C
C*MODULE DDILIB   *DECK GDDI_SCOPE
      SUBROUTINE GDDI_SCOPE(NEWSCOPE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK,ISGDDI,PAROUT,INITGDDI,wasgddi
      INTEGER DDI_MASTERS
      PARAMETER(DDI_MASTERS=2)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,NPGLOB,NNGLOB,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi
C
      INTEGER COMM(0:2)
      COMMON /GRPCOM/ COMM
C
C           POTENTIALLY USEFUL FOR DEBUGGING SUBGROUPS SHIFTS.
C--   WRITE(6,1) ISCOPE,NEWSCOPE
C-- 1 FORMAT(1X,'GDDI_SCOPE: CHANGING SCOPE FROM',I4,' TO ', I4)
C--   CALL FLSHBF(6)
C
      ISCOPE=NEWSCOPE
      CALL DDI_SCOPE(COMM(NEWSCOPE))
      CALL DDI_NPROC( NPROC, ME )
C
C     NGROUPS HAS THE TOTAL NUMBER OF GROUPS,
C     NOT THIS NUMBER WITHIN THE CURRENT SCOPE
C     MASWRK=IMASTER.NE.0
C
C  NOTE: DDI_NGROUP WAS NEVER USED.  THE FUNCTIONALITY HAS CHANGED, IT
C  NOW REPORTS THE TOTAL NUMBER OF GROUPS AND THE RANK OF THE GROUP OF
C  THE CALLING PROCESS.  IN THE DDI_MASTERS SCOPE, THERE ARE ALWAYS TWO
C  GROUPS: MYGRP.EQ0 = GROUP MASTERS, MYGRP.EQ.1 = ALL OTHER PROCESSES
C  THE CONVENTION IS TO USE THE LOGICAL VARIABLE MASWRK TO DECIDE WHICH
C  PROCESSES SHOULD CONTINUE ON AND PERFORM COMMUNICATION CALL AND WHICH
C  PROCESSES SHOULD BYPASS THE COMMUNICATION.
C
      MASWRK=ME.EQ.MASTER
      IF(NEWSCOPE.EQ.DDI_MASTERS) THEN
         CALL DDI_NGROUP(NGRP,MYGRP)
         MASWRK=MYGRP.EQ.MASTER
      END IF
C
      GOPARR=NPROC.GT.1
      RETURN
      END
C
C*MODULE DDILIB   *DECK GDDI_ASCOPE
      SUBROUTINE GDDI_ASCOPE(NEWSCOPE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK,ISGDDI,PAROUT,INITGDDI,wasgddi
      INTEGER DDI_MASTERS
      PARAMETER(DDI_MASTERS=2)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,NPGLOB,NNGLOB,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi
C
C     ASYNCHRONOUS CLONE OF GDDI_SCOPE (DO NOT RUN DDI_SYNC WHILE
C     SWITCHING SCOPES IN DDI_ASCOPE). 
C     DDI_NPROC AND DDI_NGROUP SHOULD NOT CALL DDI_SYNC, OR ELSE
C     THEY CAN PROBABLY BE COMMENTED OUT BELOW.
C
      INTEGER COMM(0:2)
      COMMON /GRPCOM/ COMM
C
      ISCOPE=NEWSCOPE
      CALL DDI_ASCOPE(COMM(NEWSCOPE))
      CALL DDI_NPROC( NPROC, ME )
C
      MASWRK=ME.EQ.MASTER
      IF(NEWSCOPE.EQ.DDI_MASTERS) THEN
         CALL DDI_NGROUP(NGRP,MYGRP)
         MASWRK=MYGRP.EQ.MASTER
      END IF
C
      GOPARR=NPROC.GT.1
      RETURN
      END
