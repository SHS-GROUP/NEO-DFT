C  2 Sep 12 - MWS - synchronize MCINP
C  7 MAR 12 - MWS - ALIGN DETWFN COMMON
C 17 Feb 12 - LBR - updated DETWFN common block
C 28 DEC 11 - CS  - EFMO CHANGES FOR COVALENT BONDS
C 12 DEC 10 - MWS - FIX E- COUNT ERROR INTRODUCED AT MAY 2009
C  1 OCT 10 - CS  - ADDED EFMO CHANGES
C 11 AUG 10 - DGF - SYNCH COMMON BLOCK PRPOPT
C 25 MAR 10 - MWS - DEACTIVATE $TWOEI GROUP (SEE JUNE 1994)
C  1 MAY 09 - MWS - LMOINP: ADD POLARIZABILITY INPUT CHECKING
C  1 MAY 09 - PFS,HL - LMOINP,LOCENG,LOCLIZ,LMOTVM-LMODJK: ADD LMOEDA
C 12 JAN 09 - DGF - ENABLE OLD STYLE INTEGRAL TRANSFORMATION FOR FMO
C 12 JAN 09 - MWS - LMOPSI: ADD CISTEP=GMCCI
C 15 DEC 08 - DGF - CHANGES FOR FMO/AFO
C  7 DEC 07 - MWS - BONDING ANALYSIS CHANGES, AND USE PAR. INT. TRANSF.
C  6 NOV 06 - MWS - ADJUST WAVEFUNCTION COMMON BLOCK
C 10 JUL 06 - SS  - VMTOL,NPRDTL OPTIONS FOR LOCALIZED HYPERPOL.CALC
C  2 FEB 06 - MWS - POLNMX: USE PRCALC TO DO THE DIPOLE INTS
C 17 JAN 06 - MWS - UPDATE ARGS TO TRFMCX
C 14 NOV 05 - DGF - PAD COMMON BLOCK SCFOPT
C 19 SEP 05 - MWS - ADD TRUE NUCLEAR CHARGE ARRAY TO INFOA COMMON
C  5 JUL 05 - MWS - SELECT NEW ATOM,BASIS,EFP,PCM,DAF DIMENSIONS
C 27 JUN 05 - IA  - LOCINP: REMOVE 1 JUN 05 TRAP AFTER FIXING THE BUG
C  1 JUN 05 - MWS - LOCINP: TURN OFF DYNAMIC POLARIZATION IF PARALLEL
C 30 APR 05 - DGF - SYNCHRONISE SYMBLK COMMON BLOCK
C  7 MAR 05 - IA  - LMOINP: READ IMAG FREQS FOR DYN. POLARIZABILITY
C 13 FEB 05 - MWS - PAD COMMON BLOCK NSHEL, EDCMP
C  5 FEB 05 - MWS - PAD COMMON MCINP
C  7 SEP 04 - MWS - PAD COMMON BLOCK INTFIL
C  7 APR 03 - MWS - SYNCH FCCWFN COMMON
C  9 DEC 03 - MWS - SYNCH COMMON BLOCK RUNOPT
C 26 MAR 03 - MWS - SYNCH FCCWFN COMMON
C 14 JAN 03 - MWS - LOCFRZ,LMOFRZ: ENSURE PSI INVARIANT ORMAS-MCSCF LOCS
C 12 DEC 02 - MWS - ABORT LOCALIZATIONS W/O ANY ORBITALS TO LOCALIZE
C 17 AUG 02 - MWS - LMOFRZ: SYMLOC JOBS SHOULD NOT CHANGE ORBITAL PHASES
C  7 AUG 02 - PM  - LMOINP: NEW KEYWORD NODENS CONTROLS MAKING EFP
C 22 MAY 02 - MWS - PROVIDE ADDITIONAL TRFMCX ARGUMENTS
C 24 JAN 02 - JI  - DIRLMO,DIMOID,ORIPRI,ORIANAL: FIX NORBS.LT.NATOMS
C 30 NOV 01 - JI  - ORIEN: TINY FIX, LMOINP: TURN OFF ORIENT IF NOT MC
C 26 OCT 01 - JI  - IMPLEMENT ORIENTED (DIRECTED) LOCALIZED ORBITALS
C  6 SEP 01 - MWS - ADD DUMMY ARGUMENTS TO NAMEIO CALL
C  1 AUG 01 - JI  - TWEAKS FOR GENERAL CI
C 25 JUN 01 - MWS - ALTER COMMON BLOCK SCFOPT AND WFNOPT
C 13 JUN 01 - PM  - LMOINP: PERMIT INPUT ABOUT OVERLAPPING REGION
C 19 NOV 00 - JHJ,HL - LMOINP: POLDCM DEFAULT MOVED, POLAPP OPTION ADDED
C 11 OCT 00 - MWS - UPDATE THE DETWFN COMMON
C  1 MAY 00 - MWS - NO SYMMETRY OPTION IN TRFOPT COMMON
C 16 FEB 00 - VK  - POLNMM,POLNMX: NEW CODE; LMOINP: NEW POLNUM KEYWORD
C 21 DEC 99 - MWS - REMOVE C1 DOWNSHIFT FROM TRANSF. BUT NOT AO INTS
C 13 MAR 99 - MWS - LOCSET: FIX CHECK RUN DAF RECORD EXISTENCE BUG
C 13 FEB 99 - MWS - LOCFRZ: CHANGE CALL TO SYMMOS
C 12 NOV 98 - GDF - CHANGE BIT PACKING TO ISHIFT
C 12 SEP 98 - MWS - LMOPSI: CHANGES FOR DETERMINANT MCSCF
C 13 APR 98 - MWS - LMOFRZ,LOCFRZ: READ SYMMETRY LABELS FROM DAF
C 28 SEP 97 - MWS - CONVERT PARALLEL CALLS FROM TCGMSG TO DDI
C 29 APR 97 - MWS - LOCSET: SKIP EIG/DEN IF RUN TYPE IS PROPERTY
C 18 MAR 97 - PMD - BOYLOC: ALLOW UP TO FIVE RESTARTS
C 14 FEB 97 - MWS - LOCENG,LOCSET MODEIFIED FOR NEW LOCANA ROUTINE
C  7 FEB 97 - MWS - LOCENG: SET DKSWRK PROPERLY FOR PARALLEL RUNS
C 17 JAN 97 - MWS - LOCENG: FIX BUG WITH INTEGRAL SKIPPING FOR MCSCF
C 18 DEC 96 - JHJ - LMOINP: IF RUNTYP IS MAKEFP, POLDCM=.T.
C  9 DEC 96 - JHJ - LMOINP,LMOLOC,BOYLOC: NPRINT=-23 OPTION
C 18 JUL 96 - MWS - LOCENG: FIX ENERGY LOC. FOR DIRECT RUNTYP=PROP JOBS
C 13 JUN 96 - MWS - CHANGES TO SUPPORT NEW CITYP INPUT
C  5 MAR 96 - MWS - CHANGE SHELL SYMMETRY PACKING COMMONS
C 14 SEP 95 - SPW - LMOINP,LMOX: CHANGES TO POLARIZABILITY DECOMPOSITION
C 26 JUL 95 - JHJ - LOCENG: IF(RDINT) WRITE BOGUS TLOC MATRIX TO DAF 73.
C 24 MAY 95 - MWS - LOCENG: WORK WITH DISTRIBUTED AO INTEGRALS
C 19 MAY 95 - SPW - BOYLOC,POPLOC: SAVE ALL VIRTUALS
C 21 APR 95 - JHJ - MLOINP: READ NEW ZDO OPTION
C  1 FEB 95 - JHJ - LMOINP: READ QUADRUPOLE DECOMPOSITION OPTION
C 12 NOV 94 - MWS - REMOVE FTNCHEK WARNINGS
C 14 OCT 94 - MWS - GLOBAL SUM IN LOCINT, ALL NODES MUST ENTER LOCLIZ
C 10 AUG 94 - MWS - INCREASE NUMBER OF DAF RECORDS
C  5 AUG 94 - MWS - LOCINT,LOCENG: USE DOUBLE LABEL PACKING
C 17 JUN 94 - JHJ - LMOINP: NEW INPUT FOR EDCOMP, LOCENG: READ IN $TWOEI
C                   LMOX: CALLS TO MOIDM,EDCMPM,DIPLMM
C                   LOCLIZ: PUNCH $TWOEI, WRITE TRANSF. INTEGRALS TO DAF
C                   BOYLOC,LOCLIZ,POPLOC: WRITE TRANSF. MATRIX TO DAF
C  1 JUN 94 - MWS - LOCENG: ENABLE DIRECT AND/OR PARALLEL LOCALIZING
C 17 DEC 93 - MWS - BOYLOC: CHANGE DAF RECORD NOS.
C  3 MAR 93 - MWS - LOCENG: PROP RUNS NEED TO DO 2E- INTEGRALS
C  8 SEP 92 - MWS - LMOPSI: CHANGE NUMCOR FOR LU AND LR
C 12 MAR 92 - MWS - REDIMENSION TO 500 ATOMS
C  3 MAR 92 - MWS - LMOFRZ,LOCFRZ: CHANGE SYMLOC FREEZE TO USE SYMMOS
C 21 JAN 92 - MWS - UPDATE CREDITS FOR RUEDENBERG LOCALIZATION
C 11 JAN 92 - TLW - LOCINT: MAKE READS PARALLEL
C 10 JAN 92 - TLW - CHANGE REWINDS TO CALL SEQREW
C 10 JAN 92 - MWS,TLW - CHANGE OPENPK TO SEQOPN
C  7 JAN 92 - TLW - MAKE WRITES PARALLEL; ADD COMMON PAR
C  5 DEC 91 - MWS - LOCFRZ: FIX RUEDENBERG ORB FREEZING BUG
C  7 OCT 91 - MWS - CHANGE UNIX BYTE UNPACKING
C 16 AUG 91 - JAM - INCLUDE PIPEK/MEZEY POPULATION LOCALIZATION
C 24 APR 91 - MWS - COMPUTE NUMBER OF VIRTUALS IN BOYLOC, FIX CHECK RUNS
C  5 APR 91 - MWS - INCORPORATE ENERGY LOCALIZATION FROM ALIS,
C                   CLEAN UP BOYS, CHANGES TO INPUT (MOIN,SYMLOC),
C                   IMPLEMENT SINGLE JOB WAVEFUNCTION LOCALIZATION.
C 29 DEC 89 - MWS - ELIMINATE EQUIVALENCE OF IX TO /FMCOM/
C  8 MAY 88 - MWS - UP AO-S FROM 255 TO 2047
C 14 NOV 87 - STE - ADD TLOCAL TO BOYIN CALL, USE EXETYP
C  3 NOV 86 - STE - BOYLOC: USE IF/THEN LOGIC; REMOVE NAV REFERENCES
C                   USE PARAMETER STATEMENTS
C 11 JUL 86 - MWS - SAVE U IN LMORND FOR ALL MACHINES
C  7 JUL 86 - MWS - SANITIZE FLOATING POINT CONSTANTS,
C                   CHANGE CONVERSION FACTOR TO DEBYES
C 14 OCT 85 - STE - USE GENERIC MAX,ABS,ATAN,ATAN2,COS,SIN,SQRT
C 10 OCT 85 - STE - BOYLOC: USE DROT INSTEAD OF 900 LOOP
C  9 SEP 85 - STE - BOYIN: FIX NNAM,RNAM,JRET; DELETE 9028 FORMAT
C                   BOYLOC: FIX LOADFM. BOYLOC: FIX ZERO,NORB,K,KL,ONE
C                   LMORND: SAVE U, DFLOAT TO REAL, IDINT TO INT
C 19 FEB 85 - MWS - MOVE BOYIN FROM INPUT TO HERE
C 19 FEB 85 - STE - FIX 9030 FORMAT IN BOYLOC
C 15 NOV 84 - MWS - ALLOW VARIABLE NUMBER OF ITERS, CLEANER OUTPUT
C 15 AUG 84 - SS  - PRINT CENTROIDS OF CHARGE
C 11 FEB 83 - MWS - EXTENSIVE REWORKING, CLEANED UP, PRINT THE
C                   LOCALIZATION SUMS, TRANSFORMATION, ETC.
C 29 SEP 82 - MWS - CONVERT TO IBM
C
C     ROUTINE NAMES IMPLY: LMO*=SHARED BY MORE THAN ONE METHOD,
C         BOY*=BOYS, LOC*=RUEDENBERG, POP*=POPULATION
C
C*MODULE LOCAL   *DECK BOYLOC
      SUBROUTINE BOYLOC(IPASS,VECIN,TRAN,VECOUT,IORD,IIR,
     *                  IA,RIJ,QPIX,QPJX,NOROT,DMAO,WRK,
     *                  L1,L2,N1,N2,NOUT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXAO=8192)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,MFRZ
      
C
      DOUBLE PRECISION LMORND
C
      DIMENSION VECIN(L1,L1),TRAN(N1,N1),VECOUT(L1,L1),DMAO(L2),
     *          WRK(L1),RIJ(N2,3),IORD(N1),IIR(N1),
     *          IA(L1),QPIX(L1),QPJX(L1),NOROT(N1,N1)
C
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,
     *                IEFMORUN,IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,
     *                IEFMODIM(2),IMODEFE,NATEFMO,IMODEFD,IMODEFER,
     *                IMODEFCT,EFMOREPNRG,EFMOCHTNRG,EFMOEPEN
      COMMON /ELPROP/ ELDLOC,ELMLOC,ELPLOC,ELFLOC,
     *                IEDEN,IEMOM,IEPOT,IEFLD,MODENS,
     *                IEDOUT,IEMOUT,IEPOUT,IEFOUT,
     *                IEDINT,IEMINT,IEPINT,IEFINT
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MFRPAR/ MFRZ,NUMFRZ,NORFRZ,IFRZ(MXAO)
      COMMON /OPTLOC/ CVGLOC,MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,
     *                MOOUTA(MXAO),MOOUTB(MXAO)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /SCFOPT/ CONVHF,MAXIT,MCONV,NPUNCH,NPREO(4)
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00, TWO=2.0D+00, FOUR=4.0D+00,
     *           TENM3=1.0D-03, TENM8=1.0D-08, TENM10=1.0D-10,
     *           FAC=2.541766D+00)
C
      DATA UHF/8HUHF     /
C
C     ----- BOYS ORBITAL LOCALIZATION -----
C     THIS IMPLEMENTATION IS A MODIFIED VERSION OF QCPE PROGRAM 354.
C                     ORIGINAL DESCRIPTION:
C     ANDREW STREITWIESER, JR.; DONALD BOERTH; JOSEPH A. HASHMALL
C     QUANTUM CHEMISTRY PROGRAM EXCHANGE BULLETIN  11, 354 (1978)
C
      NORB  = N1
      NBASIS= L1
      NFROZ = NOUT
C                THIS NEXT IS DREADFUL, IT IS OVERWRITING SCF COUNT
C                I GUESS THIS WORKS BECAUSE LOCALIZATION IS DEAD LAST.
C                IT IS NOT, THE DOOM HATH OVERCOME US!
      MAXITS= MAXIT
      MAXIT = MAXLOC
C
      DO 100 I=1,NBASIS
         IA(I) = (I*I-I)/2
  100 CONTINUE
C
C        BEGIN LOCALIZATION RETRYS HERE.
C
      NREDO = 0
  200 CONTINUE
      NREDO = NREDO + 1
C
C        TRANSFORM DIPOLE INTEGRALS FROM AO TO MO BASIS
C
      IF(NPRINT.EQ.-5) THEN
         CALL POINT(ELMLOC,1,XP,YP,ZP,ISTAT)
         CALL DIPINT(XP,YP,ZP,.FALSE.)
      END IF
C
      CALL DAREAD(IDAF,IODA,DMAO,L2,95,0)
      CALL TFTRI(RIJ(1,1),DMAO,VECIN,WRK,NORB,NBASIS,NBASIS)
      CALL DAREAD(IDAF,IODA,DMAO,L2,96,0)
      CALL TFTRI(RIJ(1,2),DMAO,VECIN,WRK,NORB,NBASIS,NBASIS)
      CALL DAREAD(IDAF,IODA,DMAO,L2,97,0)
      CALL TFTRI(RIJ(1,3),DMAO,VECIN,WRK,NORB,NBASIS,NBASIS)
C
C                    COMPUTE INITIAL LOCALIZATION SUM
C
      SUMRR = ZERO
      II=0
      DO 260 I=1,NORB
         II=II+I
         IF(NOROT(I,I).EQ.1) GO TO 260
         SUMRR = SUMRR + RIJ(II,1)**2 + RIJ(II,2)**2 + RIJ(II,3)**2
  260 CONTINUE
      SUMRR=SUMRR*FAC*FAC
      IF (MASWRK .AND. NPRINT.NE.-23) WRITE(IW,9010) SUMRR
C
C        SEED THE RANDOM FUNCTION
C
      ONEPT0 = ONE
      IF (NREDO.EQ.1) XX = LMORND(ONEPT0,VECIN,NBASIS)
      SHIFT = ATAN(ONEPT0)
C
C        INITIALIZE LOCALIZATION TRANSFORM
C
      CALL VCLR(TRAN,1,NORB*NORB)
      DO 280 I = 1,NORB
         TRAN(I,I) = ONE
  280 CONTINUE
C
C        BEGIN LOCALIZATION CYCLES
C
      ITER = 0
  300 CONTINUE
      CHANGE = ZERO
      ITER = ITER+1
      DO 320 I = 1,NORB
         IIR(I) = I
  320 CONTINUE
      NNN = NORB
      DO 330 I = 1,NORB
         XX = LMORND(CHANGE,VECIN,NBASIS)
         III = INT(XX*NNN+ONE)
         IORD(I) = IIR(III)
         IIR(III) = IIR(NNN)
         NNN = NNN-1
  330 CONTINUE
C
C        FOR EACH PAIR OF ORBITALS A 2X2 UNITARY TRANSFORMATION
C        IS PERFORMED. THE JACOBI TYPE TRANSFORMATION IS
C             PSI PRIME(I) =  COS(T)*PSI(I) + SIN(T)*PSI(J)  AND
C             PSI PRIME(J) = -SIN(T)*PSI(I) + COS(T)*PSI(J).
C        THE BOYS METHOD REQUIRES THAT T BE SUCH AS TO MAXIMIZE
C        THE SUM OF THE SQUARES OF THE ONE CENTER MOLECULAR ORBITAL
C        DIPOLE MOMENT INTEGRALS.
C
      DO 600 III = 1,NORB
         I = IORD(III)
         IF(NOROT(I,I).EQ.1) GO TO 600
C
         II = IA(I)+I
         IM  = I
         JM  = 1
         IJM = IA(IM)+JM
         RM  = ZERO
         TM  = ZERO
         SM  = ZERO
         CM  = ONE
C
C           LOOK FOR MAXIMUM ROTATION INVOLVING ORBITAL I AND ANY J
C
         DO 490 J = 1,NORB
            IF(I.EQ.J) GO TO 490
            IF(NOROT(I,J).EQ.1) GO TO 490
            IJ = IA(I) + J
            JJ = IA(J) + J
            IF(J.GT.I) IJ = IA(J) + I
            T = ZERO
            TX = ZERO
            DO 410 KK = 1,3
               T = T + FOUR*RIJ(IJ,KK)**2
     *               - RIJ(II,KK)**2 - RIJ(JJ,KK)**2
     *               + TWO*RIJ(II,KK)*RIJ(JJ,KK)
               TX = TX+RIJ(IJ,KK)*(RIJ(JJ,KK)-RIJ(II,KK))
  410       CONTINUE
            IF((ABS(T).LE.TENM10) .AND. (ABS(TX).LE.TENM10)) GO TO 490
            TX = FOUR*TX
            T = ATAN2(TX,T)
            T = T/FOUR
            SIGN = ONE
            IF (T .GT. ZERO) SIGN = -ONE
            T = T+SIGN*SHIFT
            ITIM = 0
  420       CONTINUE
            ITIM = ITIM+1
            S = SIN(T)
            C = COS(T)
            RIN = ZERO
            DO 430 KK = 1,3
               QPI = C*C*RIJ(II,KK)+S*S*RIJ(JJ,KK)+TWO*C*S*RIJ(IJ,KK)
               QPJ = C*C*RIJ(JJ,KK)+S*S*RIJ(II,KK)-TWO*C*S*RIJ(IJ,KK)
               RIN = RIN+QPI*QPI+QPJ*QPJ-RIJ(II,KK)**2-RIJ(JJ,KK)**2
  430       CONTINUE
            TTEST = ABS(T)-SHIFT
            IF((ABS(T).LE.TENM8) .OR. (ABS(TTEST).LE.TENM8)) GO TO 470
            IF(RIN .GE. -TENM8) GO TO 470
            IF(ITIM .LE. 1) GO TO 460
            IF (MASWRK) THEN
               WRITE (IW,9020) I,J
               WRITE (IW,9030) T,S,C,RIN
            END IF
            RETURN
C
  460       CONTINUE
            SIGN = ONE
            IF (T .GT. ZERO) SIGN = -ONE
            T = T+SHIFT*SIGN
            GO TO 420
C
  470       CONTINUE
            IF (RIN .LE. RM) GO TO 490
            RM  = RIN
            JM  = J
            IJM = IJ
            SM  = S
            CM  = C
            TM  = T
  490    CONTINUE
C
         T   = TM
         RIN = RM
         S   = SM
         C   = CM
         J   = JM
         IJ  = IJM
         JJ  = IA(J)+J
         IF(NOROT(I,J).EQ.1) GO TO 600
C
C           ACCUMULATE THE 2X2 ROTATION
C
         CHANGE = CHANGE+T*T
         CALL DROT(NORB,TRAN(1,I),1,TRAN(1,J),1,C,S)
C
C           UPDATE THE DIPOLE INTEGRALS FOR THIS ROTATION
C
         DO 550 KK = 1,3
            QPI = C*C*RIJ(II,KK)+S*S*RIJ(JJ,KK)+TWO*C*S*RIJ(IJ,KK)
            QPJ = C*C*RIJ(JJ,KK)+S*S*RIJ(II,KK)-TWO*C*S*RIJ(IJ,KK)
            QPIJ = (C*C-S*S)*RIJ(IJ,KK)+C*S*(RIJ(JJ,KK)-RIJ(II,KK))
            DO 510 K = 1,NORB
               IF(I.EQ.K  .OR.  J.EQ.K) GO TO 510
               IK = IA(I) + K
               IF(K.GT.I) IK = IA(K)+I
               JK = IA(J) + K
               IF(K.GT.J) JK = IA(K)+J
               QPIX(K) = C*RIJ(IK,KK)+S*RIJ(JK,KK)
               QPJX(K) = C*RIJ(JK,KK)-S*RIJ(IK,KK)
               RIJ(IK,KK) = QPIX(K)
               RIJ(JK,KK) = QPJX(K)
  510       CONTINUE
            RIN = RIN+QPI+QPJ-RIJ(II,KK)-RIJ(JJ,KK)
            RIJ(II,KK) = QPI
            RIJ(JJ,KK) = QPJ
            RIJ(IJ,KK) = QPIJ
  550    CONTINUE
  600 CONTINUE
C
C        TEST FOR CONVERGENCE OF THE LOCALIZATION
C
      CHANGE = SQRT(TWO*CHANGE/(NORB*(NORB-1)))
      IF((MOD(ITER,10).EQ.0) .AND. MASWRK .AND. NPRINT.NE.-23)
     *                                    WRITE(IW,9040) ITER,CHANGE
C
      IF(ITER.LT.MAXIT  .AND.  CHANGE.GT.TENM3*CVGLOC) GO TO 300
      IF(CHANGE.GT.CVGLOC) THEN
         IF(NREDO.LE.5) THEN
            IF (MASWRK) WRITE(IW,9050) NREDO
            GO TO 200
         ELSE
            IF (MASWRK) WRITE(IW,9060)
            MAXIT= MAXITS
            RETURN
         END IF
      END IF
C
C        FINISHED WITH LOCALIZATION CYCLES
C
      IF (MASWRK .AND. NPRINT.NE.-23) WRITE(IW,9070) ITER
C
C        COMPUTE FINAL LOCALIZATION SUM
C
      SUMRR = ZERO
      II=0
      DO 710 I=1,NORB
         II=II+I
         IF(NOROT(I,I).EQ.1) GO TO 710
         SUMRR = SUMRR + RIJ(II,1)**2 + RIJ(II,2)**2 + RIJ(II,3)**2
  710 CONTINUE
      SUMRR=SUMRR*FAC*FAC
      IF (MASWRK .AND. NPRINT.NE.-23) WRITE(IW,9080) SUMRR
C
C        TRANSFORM TO FINAL ORBITALS, COPY VIRTUAL SPACE
C
      CALL MRARBR(VECIN,NBASIS,NBASIS,NORB,TRAN,NORB,NORB,VECOUT,NBASIS)
      NVIRT = NBASIS - NORB
      CALL DCOPY(NVIRT*NBASIS,VECIN(1,NORB+1),1,VECOUT(1,NORB+1),1)
C
C        OUTPUT LOCALIZATION TRANSFORMATION AND FINAL ORBITALS
C
      IF(IPRTLO.EQ.1) THEN
         IF (MASWRK) WRITE(IW,9090)
         CALL PRSQ(TRAN,NORB,NORB,NORB)
      END IF
C     ----- SAVE THIS FOR EVENTUAL MP2 LOCALIZATION -----
C
C     IN EFMO, THE NUMBER OF FROZEN ORBITALS IS NOT JUST
C     THE NUMBER OF ORBITALS - THE NUMBER OF CORE ATOMS
C     SINCE THE FROZEN BOND ORBITAL NEEDS TO BE INCLUDED
C     IN THE ACTUAL ANALYSIS OF THE TENSORS.
      IF( IEFMORUN.GT.0 .AND. NUMFRZ.GT.0 ) THEN
        NOUT = NOUT - NUMFRZ
C       WE SET NOUTA HERE FOR MOID LATER ON
        NOUTA = NOUTA - NUMFRZ
      ENDIF
C     WE NEED THE MATRIX WITHOUT THE CORE
C
      DO 760 I = 1,NORB
         DO 750 J = 1,NORB
            TRAN(I,J) = TRAN(I+NOUT,J+NOUT)
  750    CONTINUE
  760 CONTINUE
      NLOC = NORB - NOUT
C
C
      CALL SQZMAT(TRAN,NORB,NLOC,NORB)
      IF(IPASS.EQ.1) CALL DAWRIT(IDAF,IODA,TRAN,NLOC*NLOC,73,0)
      IF(IPASS.EQ.2) CALL DAWRIT(IDAF,IODA,TRAN,NLOC*NLOC,74,0)
C
      IF (MASWRK .AND. NPRINT.NE.-23) THEN
         WRITE(IW,9100)
         CALL PRSQL(VECOUT,NORB,NBASIS,NBASIS)
      END IF
C
      IF((IPASS.EQ.1) .AND. MASWRK) WRITE(IP,8000)
      CALL PUSQL(VECOUT,NORB,NBASIS,NBASIS)
      IF((SCFTYP.NE.UHF  .OR.  IPASS.EQ.2) .AND. MASWRK)
     *    WRITE(IP,8010)
      MAXIT= MAXITS
C
C        OPTIONALLY, PRINT ORBITAL CENTROIDS
C     THIS IS JUST A FANCY NAME FOR THE ORBITAL DIPOLE MOMENT.
C
      IF(IPRTLO.EQ.0) RETURN
      IF (MASWRK) THEN
      WRITE (IW,9110)
      II = 0
      DO 850 I = 1,NORB
         II = II + I
         DO 820 K=1,NFROZ
            IF(IPASS.EQ.1) THEN
               KK=MOOUTA(K)
            ELSE
               KK=MOOUTB(K)
            END IF
            IF(KK.EQ.I) GO TO 850
  820    CONTINUE
         WRITE(IW,9120) I,(RIJ(II,IMU),IMU=1,3)
  850 CONTINUE
      END IF
      RETURN
C
 8000 FORMAT('BOYS LOCALIZED ORBITALS'/' $VEC')
 8010 FORMAT(' $END')
C                           PRINT FORMATS
 9020 FORMAT(/1X,'NO ROTATION INCREASES DIPOLE INTEGRALS',
     *           ' --- LOCALIZATION ABORTED'/
     *           10X,2HI=,I3,5X,2HJ=,I3)
 9030 FORMAT(5X,8HTHETA = ,1P,E20.10,0P/
     *          5X,12HSIN(THETA)= ,F10.7,' COS(THETA)=',F10.7/
     *          5X,'TOTAL CHANGE TO THIS POINT =',1P,E20.10)
 9040 FORMAT(10X,'BOYS ITERATION',I4,' ORBITAL CHANGE=',1P,E20.10)
 9050 FORMAT (/5X,'**** LOCALIZATION',I4,' HAS BEEN UNSUCESSFUL! ****'/
     *  5X,'RESTARTING WITH NEW RANDOM NUMBER AND ROTATION SEQUENCE')
 9060 FORMAT(/1X,'LOCALIZATION FAILED --- LOCALIZATION ABORTED')
 9070 FORMAT(10X,'LOCALIZATION CONVERGED IN',I4,' ITERATIONS')
 9010 FORMAT(/10X,'THE INITIAL LOCALIZATION SUM IS',F14.6,' DEBYE**2')
 9080 FORMAT(10X,'  THE FINAL LOCALIZATION SUM IS',F14.6,' DEBYE**2')
 9090 FORMAT(/10X,'THE LOCALIZATION TRANSFORMATION MATRIX IS')
 9100 FORMAT(/10X,'THE BOYS LOCALIZED ORBITALS ARE')
 9110 FORMAT(/4X,'CENTROIDS OF LOCALIZED ORBITALS (BOHR)'/
     *        5X,2HMO,9X,1HX,8X,1HY,8X,1HZ)
 9120 FORMAT(3X,I4,5X,3(F8.4,1X))
      END
C*MODULE LOCAL   *DECK LMOFRZ
C> @brief      This routine decides which orbitals to localize.
C>
C> @author     Mike Schmidt
C>             -1991
C>
C> @details    LOCALIZE AS MUCH AS POSSIBLE,
C>             LEAVING WAVEFUNCTION INVARIANT.
C>
C>    @date December 7, 2012-Aaron West
C>    -Added NATMOR to ORNTMO common block.
C>     This integer array is different from NATORB.
C>
      SUBROUTINE LMOFRZ(NOUT,IPASS,MCORE,MDOC,NUMLOC,NOROT,LABMO,L1)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION METHOD
C
      PARAMETER (MXAO=8192)
C
      LOGICAL IDOC,IACT,JDOC,JACT,GOPARR,DSKWRK,MASWRK,ABEL,
     *        CANONC,FCORE,FORS,EKT,LINSER,FDIRCT,QCORR,
     *        ORIENT,ORMFUL
C
      DIMENSION NOROT(NUMLOC,NUMLOC),LABMO(NUMLOC)
C
      PARAMETER (MXNORO=250)
C
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIMFCC(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWORD,NORBMC,NORTMC(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /OPTLOC/ CVGLOC,MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,
     *                MOOUTA(MXAO),MOOUTB(MXAO)
      COMMON /ORNTMO/ ORIENT,ORMFUL,NATMOR(MXAO)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /SYMBLK/ NIRRED,NSALC,NSALC2,NSALC3,NSAFMO
      COMMON /SYMMOL/ GROUP,COMPLEX,IGROUP,NAXIS,ILABMO,ABEL
      COMMON /SYMQMT/ IRPLAB(14),IRPNUM(14),IRPDIM(14),IRPDEG(14)
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DATA RMC,ORMAS/8HMCSCF   ,8HORMAS   /
C
      DO 120 I=1,NUMLOC
         DO 110 J=1,NUMLOC
            NOROT(I,J) = 0
  110    CONTINUE
  120 CONTINUE
C
C     BLOCK OUT ANY ROTATIONS INVOLVING THE FROZEN ORBITALS
C
      DO 170 K=1,NOUT
         IF(IPASS.EQ.1) THEN
            KK = MOOUTA(K)
         ELSE
            KK = MOOUTB(K)
         END IF
         DO 160 I=1,NUMLOC
            NOROT(I,KK) = 1
            NOROT(KK,I) = 1
  160    CONTINUE
  170 CONTINUE
C
C     LOCALIZE AS MUCH AS POSSIBLE, LEAVING WAVEFUNCTION INVARIANT.
C
      NDBOCC = MCORE+MDOC
      DO 220 I=1,NUMLOC
         IDOC  = I.LE.NDBOCC
         IACT  = I.GT.NDBOCC
         DO 210 J=1,NUMLOC
            JDOC  = J.LE.NDBOCC
            JACT  = J.GT.NDBOCC
            IF(IDOC .AND. JACT) NOROT(I,J)=1
            IF(IACT .AND. JDOC) NOROT(I,J)=1
  210    CONTINUE
  220 CONTINUE
C
C         ORMAS-MCSCF IS NOT INVARIANT TO ROTATIONS THAT MIX
C         ORBITALS BETWEEN THE MULTIPLE ACTIVE SPACES, SO UNLESS
C         THE USER SPECIFICALLY WANTS TO, FREEZE THESE ROTATIONS.
C         STORAGE -LABMO- USED TO DEFINE ORBITAL SPACE COUNTER
C
      IF(.NOT.(SCFTYP.EQ.RMC  .AND.  CISTEP.EQ.ORMAS)) GO TO 500
      IF(ORMFUL) GO TO 500
C
      DO I=1,NDBOCC
         LABMO(I) = 1
      ENDDO
      DO ISPACE=1,NSPACE
         DO I=MSTA(ISPACE),NUMLOC
            LABMO(I) = ISPACE+1
         ENDDO
      ENDDO
C
      DO I=1,NUMLOC
         ISPACE = LABMO(I)
         DO J=1,I
            IF(ISPACE.NE.LABMO(J)) THEN
               NOROT(I,J)=1
               NOROT(J,I)=1
            END IF
         ENDDO
      ENDDO
C
C        OPTIONALLY, RESTRICT ROTATIONS SO THAT ORBITALS WITH
C        DIFFERENT SYMMETRIES ARE NOT MIXED.
C
  500 CONTINUE
      IF(ISYMLO.EQ.0) RETURN
C
      IF(ILABMO.EQ.0) THEN
         IF (MASWRK) WRITE(IW,9010)
         RETURN
      ELSE
         IF(IPASS.EQ.1) CALL DAREAD(IDAF,IODA,LABMO,L1,255,1)
         IF(IPASS.EQ.2) CALL DAREAD(IDAF,IODA,LABMO,L1,256,1)
      END IF
C
      IDEG=0
      DO 390 I=1,NUMLOC
         ISYM=LABMO(I)
         IDEG=IDEG+1
         DO 310 IRP=1,NIRRED
            IF(ISYM.EQ.IRPLAB(IRP)) IRREP = IRP
  310    CONTINUE
         IDIM = IRPDIM(IRREP)
         IF(IDIM.EQ.1) IDEG=0
C
         JDEG = 0
         DO 380 J=1,I
            JSYM = LABMO(J)
            JDEG = JDEG + 1
            DO 330 IRP=1,NIRRED
               IF(JSYM.EQ.IRPLAB(IRP)) IRREP = IRP
  330       CONTINUE
            JDIM = IRPDIM(IRREP)
            IF(JDIM.EQ.1) JDEG=0
            IF(ISYM.NE.JSYM  .OR.  IDEG.NE.JDEG) THEN
               NOROT(I,J)=1
               NOROT(J,I)=1
            END IF
            IF(JDEG.EQ.JDIM) JDEG=0
  380    CONTINUE
         IF(IDEG.EQ.IDIM) IDEG=0
  390 CONTINUE
C
      RETURN
 9010 FORMAT(//1X,55(1H*)/
     *       1X,'YOUR GROUP DOES NOT SUPPORT ORBITAL SYMMETRY LABELS.'/
     *       1X,'-SYMLOC- OPTION IS DEACTIVATED.  MAXIMUM LOCALIZATION'/
     *       1X,'CONSISTENT WITH WAVEFUNCTION INVARIANCE WILL BE DONE.'/
     *       1X,55(1H*)//)
      END
C*MODULE LOCAL   *DECK LMOINP
C>
C>    @brief Reads in localization input parameters from $local
C>
C>    @author Mike Schmidt
C>
C>    @date October, 2012 - Colleen Bertoni
C>    - Switched check of imodefd to check of the .or. of all the
C>      short-range EFP flags.
C>
C>    @date November 4, 2012 - Aaron West
C>    -Added to TYPES array for SVD-localized orbitals.
C>    -Allow orientation to be true for SVD-localized orbitals.
C>
C>    @date December 7, 2012-Aaron West
C>    -Added NATMOR to ORNTMO common block.
C>     This integer array is different from NATORB.
C>
C>    @date Jan 10.2013 - Tony Smith
C>    -Make localization mandatory for EFP-AI dispersion
C>
      SUBROUTINE LMOINP
C
      USE EFAIDIS, ONLY : IQMDISP
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DOUBLE PRECISION LOCAL,MAKEFP,METHOD,LMOEDA
C
      LOGICAL PRTLOC,FCORE,SYMLOC,GOPARR,DSKWRK,MASWRK
      LOGICAL MOIDON,EDCOMP,DIPDCM,QADDCM,DEPRNT,ZDO,POLDCM,POLANG
      LOGICAL POLNUM,POLAPP,KMIDPT,POLDYN,ORIENT,ORMFUL
      LOGICAL CANONC,FCORMC,FORS,EKT,LINSER,MFRZ
      LOGICAL COMBO
C
      PARAMETER (MXATM=2000, NMO=500, MXAO=8192)
      PARAMETER (MXMID=50, MXNORO=250)
      PARAMETER (ONE=1.0D+00)
C
      DIMENSION MOINA(50),MOINB(50),TYPES(4)
C
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,
     *                IEFMORUN,IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,
     *                IEFMODIM(2),IMODEFE,NATEFMO,IMODEFD,IMODEFER,
     *                IMODEFCT,EFMOREPNRG,EFMOCHTNRG,EFMOEPEN
      COMMON /EFPBUF/ POLCHG(10),NBUFMO,LBUFF(MXAO),LBF,NAPOL,IAPOL(10)
      COMMON /EDCMP / ZIJ(NMO),ZMO(5,NMO),OCCUP(NMO),DPFREQ(50),
     *                MOIDNO(5,NMO),IJMO(2,NMO),MOIJ(NMO),NMOIJ(NMO),
     *                NMOAT(NMO),NDPFREQ,IPROT(5),NPROT,
     *                MOIDON,EDCOMP,DIPDCM,DEPRNT,QADDCM,ZDO,POLDCM,
     *                POLANG,POLAPP,KMIDPT,POLDYN
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /LOCHYP/ VMTOL, CENLMO(3,NMO), FLDLMO(3), ESTLOC,
     *                NPRDTL, LOCLNA(1), NIFLD
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWORD,NORBMC,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORMC,FORS,EKT,LINSER
      COMMON /MFRPAR/ MFRZ,NUMFRZ,NORFRZ,IFRZ(MXAO)
      COMMON /NOPOL / NOPATM(MXATM),KPOINT(MXMID),NODENS(MXATM)
      COMMON /OPTLOC/ CVGLOC,MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,
     *                MOOUTA(MXAO),MOOUTB(MXAO)
      COMMON /ORNTMO/ ORIENT,ORMFUL,NATMOR(MXAO)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /POLNMP/ POLNUM
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
C     ----- SET UP NAMELIST SIMULATION -----
C
      PARAMETER (NNAM=40)
      DIMENSION QNAM(NNAM),KQNAM(NNAM)
      DATA LOCAL/8HLOCAL   /
      DATA QNAM/8HNOUTA   ,8HNOUTB   ,8HMOOUTA  ,8HMOOUTB  ,
     *          8HNINA    ,8HNINB    ,8HMOINA   ,8HMOINB   ,
     *          8HCVGLOC  ,8HMAXLOC  ,8HPRTLOC  ,8HFCORE   ,
     *          8HSYMLOC  ,8HIJMO    ,8HZIJ     ,8HMOIDON  ,
     *          8HEDCOMP  ,8HDIPDCM  ,8HMOIJ    ,8HNMOIJ   ,
     *          8HIPROT   ,8HDEPRNT  ,8HQADDCM  ,8HZDO     ,
     *          8HPOLDCM  ,8HPOLANG  ,8HPOLNUM  ,8HPOLAPP  ,
     *          8HNOPATM  ,8HKPOINT  ,8HKMIDPT  ,8HORIENT  ,
     *          8HNODENS  ,8HORMFUL  ,8HPOLDYN  ,8HDPFREQ  ,
     *          8HNDPFRQ  ,8HVMTOL   ,8HNPRDTL  ,8HNATMOR  /
      DATA KQNAM/1,1,-1,-1,1,1,501,501,3,1,0,0,0,10001,5003,0,0,0,
     *           5001,5001,51,0,0,0,0,0,0,0,1001,101,0,0,5001,0,0,
     *           503,1,3,1,-1/
C
      DATA TYPES/8HBOYS    ,8HRUEDNBRG,8HPOP     ,8HSVD     /
      DATA GUGA,GVB,UHF/8HGUGA    ,8HGVB     ,8HUHF     /
      DATA RHF,ROHF,RMC/8HRHF     ,8HROHF    ,8HMCSCF   /
      DATA ORMAS/8HORMAS   /
      DATA MAKEFP,LMOEDA/8HMAKEFP  ,8HLMOEDA  /
      DATA RNONE,NONE/8HNONE    ,4HNONE/
C
C     ----- READ IN LOCALIZATION INPUT PARAMETERS -----
C
C LOCALIZATION IS MANDATORY FOR EFP-AI DISPERSION
      IF(IQMDISP.NE.0 .AND. ILOCAL.EQ.0) THEN
         ILOCAL=1
      END IF
C
      IF(RUNTYP.NE.LMOEDA) THEN
         IF(ILOCAL.EQ.0 .AND. NBUFMO.EQ.0) RETURN
      ELSE
         ILOCAL = 2
      END IF
C
      IF(CITYP.EQ.GUGA  .OR.  SCFTYP.EQ.GVB) THEN
         IF (MASWRK) WRITE(IW,9000) SCFTYP
         CALL ABRT
      END IF
C
      KQNAM(3) =10*MXAO + 1
      KQNAM(4) =10*MXAO + 1
      KQNAM(40)=10*MXAO + 1
      NOUTA = 0
      NOUTB = 0
      DO 100 I = 1,NUM
         MOOUTA(I) = 0
         MOOUTB(I) = 0
  100 CONTINUE
      DO I = 1,NUM
        NATMOR(I)=0
      ENDDO
      NINA = 0
      NINB = 0
      DO 110 I=1,50
         MOINA(I) = 0
         MOINB(I) = 0
  110 CONTINUE
      CVGLOC= 1.0D-06
      MAXLOC= 250
      PRTLOC= .FALSE.
      FCORE = .TRUE.
      IF(RUNTYP.EQ.LMOEDA) FCORE = .FALSE.
      SYMLOC= .FALSE.
      IF(NFG.NE.0) THEN
         CVGLOC= 1.0D-07
         MAXLOC= 1000
         FCORE=.FALSE.
      END IF
      DO 120 I = 1,NMO
         IJMO(1,I) = 0
         IJMO(2,I) = 0
         ZIJ(I) = -ONE
         MOIJ(I) = 0
         NMOIJ(I) = -1
  120 CONTINUE
      MOIDON = .FALSE.
      EDCOMP = .FALSE.
      DIPDCM = .FALSE.
      QADDCM = .FALSE.
      DO 130 I = 1,5
         IPROT(I) = 0
  130 CONTINUE
      NPROT=0
      DEPRNT = .FALSE.
      ZDO = .FALSE.
C
      POLDCM=.FALSE.
      POLDYN=.FALSE.
      POLANG=.TRUE.
      POLNUM=.FALSE.
      POLAPP=.FALSE.
      IF (RUNTYP.EQ.MAKEFP) POLDCM = .TRUE.
      IF (RUNTYP.EQ.MAKEFP) POLDYN = .TRUE.
      IF (IEFMORUN.GT.0.AND.IEFMORT.EQ.0) THEN
        POLAPP = .TRUE.
        IF(IAND(IMODEFP,16).NE.0) POLAPP=.FALSE.
        IF((IAND(IMODEFD,1).NE.0) .OR. (IAND(IMODEFCT,1).NE.0)
     *       .OR. (IAND(IMODEFER,1).NE.0)) POLDYN=.TRUE.
        POLDCM = .TRUE.
        FCORE = .TRUE.
      ENDIF
C
      KMIDPT=.TRUE.
      ORIENT=.FALSE.
      ORMFUL=.FALSE.
C
      DO I = 1,MXATM
         NOPATM(I) = 0
      ENDDO
      DO I = 1,MXMID
         KPOINT(I) = 0
      ENDDO
      DO I = 1,MXATM
         NODENS(I) = 0
      ENDDO
C
      IF (RUNTYP.EQ.MAKEFP.OR.IEFMORUN.GT.0) THEN
         NDPFREQ=12
         DPFREQ(1) = 0.00279164292546976127D+00
         DPFREQ(2) = 0.015106644820649056973D+00
         DPFREQ(3) = 0.03900169130663191517D+00
         DPFREQ(4) = 0.077996102406373782231D+00
         DPFREQ(5) = 0.13865052123704475618D+00
         DPFREQ(6) = 0.233222703362246034002D+00
         DPFREQ(7) = 0.38589725057860362524D+00
         DPFREQ(8) = 0.649114040084500804964D+00
         DPFREQ(9) = 1.15390381343780158400D+00
         DPFREQ(10)= 2.307592234716658147562D+00
         DPFREQ(11)= 5.95764321386442380950D+00
         DPFREQ(12)= 32.239080141259587698936D+00
      ELSE
         NDPFREQ=1
         DPFREQ(1) = 0.0D+00
      END IF
C
      VMTOL  = 0.15D+00
      NPRDTL = 2
C
C     ----- READ IN $LOCAL PARAMETERS -----
C
      JRET=0
      CALL NAMEIO(IR,JRET,LOCAL,NNAM,QNAM,KQNAM,
     *            NOUTA,NOUTB,MOOUTA,MOOUTB,NINA,NINB,MOINA,MOINB,
     *            CVGLOC,MAXLOC,PRTLOC,FCORE,SYMLOC,IJMO,ZIJ,MOIDON,
     *            EDCOMP,DIPDCM,MOIJ,NMOIJ,IPROT,DEPRNT,QADDCM,
     *            ZDO,POLDCM,POLANG,POLNUM,POLAPP,NOPATM,KPOINT,KMIDPT,
     *            ORIENT,NODENS,ORMFUL,POLDYN,DPFREQ,NDPFREQ,
     *            VMTOL,NPRDTL,NATMOR,
     *   0,0,0,0,
     *   0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0)
C
      IF (JRET .EQ. 2) THEN
         IF (MASWRK) WRITE (IW,9010)
         CALL ABRT
      END IF
C
C         COUNT ERRORS, POSTPONING BOMBOUT TO THE END OF THIS ROUTINE
C
      NERR=0
C
C     ----- THE ENERGY DECOMPOSITION IS ONLY IMPLEMENTED FOR RHF/ROHF
C     CHECKING HERE IS UNDOUBTEDLY INCOMPLETE, E.G. DFT? MP2? ...
C
      IF (EDCOMP .AND. (SCFTYP.NE.RHF .AND. SCFTYP.NE.ROHF)) THEN
         IF (MASWRK) WRITE(IW,9015)
         NERR=NERR+1
      END IF
C
C             ----- POLARIZABILITY CHECKING ----
C     ANALYTIC COMPUTATION APPLIES ONLY TO PURE RHF AND ROHF,
C     NUMERICAL COMPUTATION APPLIES TO EITHER HF OR DFT.
C     POLNUM APPEARS TO BE A NUMERICAL APPROACH USING APPLIED FIELDS.
C     POLAPP IS SAID TO BE LIKE THE FIRST CPHF ITERATION, ONLY.
C
C     -POLDYN- IS AN ANALYTIC CALCULATION, ELSEWHERE, THE CODE FORCES
C     BOTH NUMERICAL APPROACHES OFF, SO LET'S FORCE THEM HERE, EARLY.
C     THEN THE PRINT BELOW LOOKS OK, AND THE TESTS HERE CAN BE ENFORCED,
C     AND WE CAN EVEN EXPLAIN WHAT WE ARE DOING WITH A MESSAGE.
C
      IF(POLDYN) THEN
         IF((POLNUM .OR. POLAPP)  .AND.  MASWRK) WRITE(IW,9085)
         POLNUM=.FALSE.
         POLAPP=.FALSE.
      END IF
C
      IF(POLDCM  .OR.  POLDYN) THEN
         NBAD=0
         IF(SCFTYP.NE.RHF  .AND.  SCFTYP.NE.ROHF)            NBAD=NBAD+1
         IF(DFTYPE.NE.RNONE  .AND.  .NOT.(POLNUM.OR.POLAPP)) NBAD=NBAD+1
         IF(MPLEVL.GT.0)      NBAD=NBAD+1
         IF(VBTYP.NE.RNONE)   NBAD=NBAD+1
         IF(CITYP.NE.RNONE)   NBAD=NBAD+1
         IF(CCTYP.NE.RNONE)   NBAD=NBAD+1
         IF(TDDFTYP.NE.RNONE) NBAD=NBAD+1
         IF(MPCTYP.NE.NONE)   NBAD=NBAD+1
         IF(NBAD.GT.0  .AND.  MASWRK) WRITE(IW,9080)
         IF(POLNUM .AND. POLAPP) THEN
            IF(MASWRK) WRITE(IW,9087)
            NBAD=NBAD+1
         END IF
         IF(NBAD.GT.0) NERR=NERR+1
      END IF
C
C           ----- ORIENTATION CHECKING ----
C           ORIENTATION APPLIES ONLY TO MCSCF ACTIVE ORBITALS
C           AND NEEDS THE INTEGRALS OF A RUEDENBERG LOCALIZATION
C
      COMBO=.FALSE.
      IF(ILOCAL.NE.2.AND.ILOCAL.NE.4) COMBO=.TRUE.
      IF(SCFTYP.NE.RMC  .OR.  COMBO) ORIENT=.FALSE.
C
C     ---- LONG PASSAGE TO SET UP INCLUDING/EXCLUDING ORBITALS ----
C
      IF(SCFTYP.NE.UHF) THEN
         NOUTB=0
         NINB=0
      END IF
C
      IPRTLO=0
      IF(PRTLOC .OR. EDCOMP) IPRTLO=1
      ISYMLO=0
      IF(SYMLOC) ISYMLO=1
      IFCORE=0
      IF (EDCOMP) FCORE = .FALSE.
      IF(FCORE)  IFCORE=1
      DO 200 I = 1,5
         IF (IPROT(I) .NE. 0) NPROT = NPROT + 1
  200 CONTINUE
C
C        GENERATE NOUTA/NOUTB DATA FOR FROZEN CORES ONLY
C
      IF(FCORE) THEN
         IF(NINA .GT.0) THEN
            IF (MASWRK) WRITE(IW,9060) 'NINA '
            NERR=NERR+1
         END IF
         IF(NOUTA.GT.0) THEN
            IF (MASWRK) WRITE(IW,9060) 'NOUTA'
            NERR=NERR+1
         END IF
         CALL LMOPSI(1,MCORE,MDOC,MACT,NUMLOC)
         NOUTA = MCORE
         DO 210 I=1,MCORE
            MOOUTA(I) = I
  210    CONTINUE
C
C        FREEZE AFO FROZEN ORBITALS IN EFMO
         IF( IEFMORUN.GT.0 ) THEN
           IF( MASWRK .AND. NUMFRZ.GT.0 ) WRITE(IW,9090)
           DO I=1,NUMFRZ
             NOUTA = NOUTA + 1
             IDM = I+MCORE
             IDX = NUM - NORFRZ + I
             MOOUTA(IDM) = IDX
             IF(MASWRK) WRITE(IW,9091) IDX
           ENDDO
         ENDIF
C
         IF(SCFTYP.EQ.UHF) THEN
            IF(NINB .GT.0) THEN
               IF (MASWRK) WRITE(IW,9060) 'NINB '
               NERR=NERR+1
            END IF
            IF(NOUTB.GT.0) THEN
               IF (MASWRK) WRITE(IW,9060) 'NOUTB'
               NERR=NERR+1
            END IF
            CALL LMOPSI(2,MCORE,MDOC,MACT,NUMLOC)
            NOUTB = MCORE
            DO 220 I=1,MCORE
               MOOUTB(I) = I
  220       CONTINUE
         END IF
      END IF
C
C        CONVERT NINA/NINB TO EQUIVALENT NOUTA/NOUTB DATA
C
      IF(NINA.GT.0) THEN
         IF(NOUTA.GT.0) THEN
            IF (MASWRK) WRITE(IW,9050) 'NINA','NOUTA'
            NERR=NERR+1
         END IF
         CALL LMOPSI(1,MCORE,MDOC,MACT,NUMLOC)
         NOUTA = NUMLOC-NINA
         MO = 0
         DO 320 I=1,NUMLOC
            DO 310 J=1,NINA
               IF(I.EQ.MOINA(J)) GO TO 320
  310       CONTINUE
            MO = MO+1
            MOOUTA(MO)=I
  320    CONTINUE
      END IF
      IF(NINB.GT.0) THEN
         IF(NOUTB.GT.0) THEN
            IF (MASWRK) WRITE(IW,9050) 'NINB','NOUTB'
            NERR=NERR+1
         END IF
         CALL LMOPSI(2,MCORE,MDOC,MACT,NUMLOC)
         NOUTB = NUMLOC-NINB
         MO = 0
         DO 360 I=1,NUMLOC
            DO 350 J=1,NINB
               IF(I.EQ.MOINB(J)) GO TO 360
  350       CONTINUE
            MO = MO+1
            MOOUTB(MO)=I
  360    CONTINUE
      END IF
C
C        AT THIS POINT ALL FREEZING DATA, EXCEPT SYMLOC,
C        IS INCORPORATED INTO NOUTA/NOUTB FORM.
C
      IF (MASWRK .AND. (NERR.GT.0  .OR.  NPRINT.NE.-23)) THEN
         WRITE(IW,9020) TYPES(ILOCAL),NOUTA,PRTLOC,NOUTB,MAXLOC,CVGLOC,
     *                  FCORE,SYMLOC,MOIDON,EDCOMP,DIPDCM,NPROT,QADDCM,
     *                  DEPRNT,POLNUM,ORIENT,POLDYN,VMTOL,NPRDTL
         IF(SCFTYP.EQ.RMC  .AND.  CISTEP.EQ.ORMAS) WRITE(IW,9025) ORMFUL
         IF(NOUTA.NE.0) WRITE (IW,9030) (MOOUTA(I),I = 1,NOUTA)
         IF(NOUTB.NE.0) WRITE (IW,9040) (MOOUTB(I),I = 1,NOUTB)
         IF(NPROT.NE.0) WRITE (IW,9045) (IPROT(I),I=1,NPROT)
      END IF
C
C     EFMO TO RESTORE ORIGINAL NON-EFMO RUN
      IF (IEFMORUN.GT.0.AND.IEFMORT.EQ.0) THEN
        FCORE = .FALSE.
      ENDIF
C
      IF(NERR.GT.0) THEN
         IF(MASWRK) WRITE(IW,*) 'PLEASE FIX ERROR(S) IN $LOCAL'
         CALL ABRT
      END IF
C
      RETURN
C
 9000 FORMAT(/1X,'ERROR! LOCALIZATION DOES NOT WORK WITH SCFTYP=',A8)
 9010 FORMAT(/1X,'ERROR! YOUR $LOCAL INPUT IS INCORRECT')
 9015 FORMAT(/1X,'ERROR! EDCOMP ONLY WORKS FOR SCFTYP=RHF/ROHF')
 9020 FORMAT(/10X,29(1H-)/
     *       10X,'LOCALIZATION INPUT PARAMETERS'/10X,29(1H-)/
     *       10X,' LOCAL=',A8,5X,' NOUTA=',I8/
     *       10X,'PRTLOC=',L8,5X,' NOUTB=',I8/
     *       10X,'MAXLOC=',I8,5X,'CVGLOC=',1P,E8.2,0P/
     *       10X,' FCORE=',L8,5X,'SYMLOC=',L8/
     *       10X,'MOIDON=',L8,5X,'EDCOMP=',L8/
     *       10X,'DIPDCM=',L8,5X,' NPROT=',I8/
     *       10X,'QADDCM=',L8,5X,'DEPRNT=',L8/
     *       10X,'POLNUM=',L8,5X,'ORIENT=',L8/
     *       10X,'POLDYN=',L8,5X,' VMTOL=',1P,E8.2,0P/
     *       10X,'NPRDTL=',I8)
 9025 FORMAT(10X,'ORMAS-MCSCF FULL LOCALIZATION FLAG ORMFUL=',L1)
 9030 FORMAT(10X,'MOOUTA =',2X,12I5,30(/20X,12I5))
 9040 FORMAT(10X,'MOOUTB =',2X,12I5,50(/20X,12I5))
 9045 FORMAT(10X,'IPROT  =',2X,5I5)
 9050 FORMAT(1X,'ERROR! ',A4,' AND ',A5,' ARE MUTUALLY EXCLUSIVE')
 9060 FORMAT(1X,'ERROR!  FCORE IS INCOMPATIBLE WITH',A5)
 9080 FORMAT(1X,'*** ERROR USING -POLDCM- AND/OR -POLDYN-:'/
     *       1X,'THIS CANNOT BE USED WITH MOPAC WAVEFUNCTIONS,'/
     *       1X,'THIS CAN BE USED ONLY FOR SCFTYP=RHF OR ROHF,'/
     *       1X,'THE ONLY CORRELATION METHOD USABLE WITH THESE IS DFT,'/
     *       1X,'NOTING THAT DFT REQUIRES NUMERICAL CALCULATION',
     *          ' (POLNUM=.TRUE. OR POLAPP=.TRUE.).')
 9085 FORMAT(1X,'*** NOTE: POLDYN IS AVAILABLE ONLY BY AN ANALYTIC',
     *          ' METHOD'/
     *       1X,'THEREFORE, POLNUM/POLAPP ARE FORCED OFF.')
 9087 FORMAT(1X,'*** ERROR, ONLY ONE OF -POLNUM- OR -POLAPP- SHOULD',
     *          ' BE CHOSEN.')
 9090 FORMAT(/1X,'FREEZING EXTRA ORBITALS IN ',
     *          'EFMO MONOMER LOCALIZATION.')
 9091 FORMAT(10X,'ORBITAL',2X,I5,' HAS BEEN FROZEN.')
      END
C*MODULE LOCAL   *DECK LMOLOC
      SUBROUTINE LMOLOC(ILOCAL)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION SPIN(2)
C
      PARAMETER (MXATM=2000, MXAO=8192)
C
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /OPTLOC/ CVGLOC,MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,
     *                MOOUTA(MXAO),MOOUTB(MXAO)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DATA UHF/8HUHF     /, SPIN/8H ALPHA  ,8H* BETA  /
      DATA CHECK/8HCHECK   /
C
C     ----- MEMORY DRIVER FOR BOYS/POPULATION LOCALIZATION -----
C
      IF (NPRINT.NE.-23) THEN
         IF((ILOCAL.EQ.1) .AND. MASWRK) WRITE(IW,9000)
         IF((ILOCAL.EQ.3) .AND. MASWRK) WRITE(IW,9100)
      END IF
C
      IPASS=0
  200 CONTINUE
      IPASS=IPASS+1
      IF(IPASS.GT.2) GO TO 700
      IF((SCFTYP.EQ.UHF) .AND. MASWRK) WRITE(IW,9010) SPIN(IPASS)
C
      CALL LMOPSI(IPASS,MCORE,MDOC,MACT,NUMLOC)
C
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
      N1 = NUMLOC
      N2 = (N1*N1+N1)/2
      N3 = N1*N1
C
C     PARTITION FAST MEMORY
C
      CALL VALFM(LOADFM)
      LVIN  = 1     + LOADFM
      LTRAN = LVIN  + L1*L1
      LVOUT = LTRAN + N1*N1
      LTRI  = LVOUT + L1*L1
      LWRK  = LTRI  + L2
      LIORD = LWRK  + L1
      LIIR  = LIORD + N1
      LIA   = LIIR  + L1
      LRIJ  = LIA   + L1
      IF(ILOCAL.EQ.1) THEN
         LAST  = LRIJ  + N2*3
      ELSE
         LAST  = LRIJ  + N2*NAT
      END IF
      LQPIX = LAST
      LQPJX = LQPIX + L1
      LNOROT= LQPJX + L1
      LAST  = LNOROT+ N3
      NEED = LAST - LOADFM -1
      IF (MASWRK .AND. NPRINT.NE.-23) WRITE(IW,9020) NEED
      CALL GETFM(NEED)
      IF(EXETYP.EQ.CHECK) GO TO 600
C
C        READ IN THE ORBITALS TO BE LOCALIZED
C
      IF(IPASS.EQ.1) THEN
         NOUT=NOUTA
         CALL DAREAD(IDAF,IODA,X(LVIN),L3,15,0)
      ELSE
         NOUT=NOUTB
         CALL DAREAD(IDAF,IODA,X(LVIN),L3,19,0)
      END IF
C
      CALL LMOFRZ(NOUT,IPASS,MCORE,MDOC,N1,X(LNOROT),X(LIIR),L1)
C
C        CARRY OUT THE LOCALIZATION
C
      IF (MASWRK .AND. NPRINT.NE.-23) WRITE(IW,9030) NUMLOC,NOUT
      IF (NUMLOC-NOUT .LE.0) THEN
         IF(MASWRK) WRITE(IW,9040)
         CALL ABRT
      END IF
C
      IF(ILOCAL.EQ.1) THEN
         CALL BOYLOC(IPASS,X(LVIN),X(LTRAN),X(LVOUT),
     *               X(LIORD),X(LIIR),X(LIA),X(LRIJ),
     *               X(LQPIX),X(LQPJX),X(LNOROT),X(LTRI),X(LWRK),
     *               L1,L2,N1,N2,NOUT)
      END IF
      IF(ILOCAL.EQ.3) THEN
         LSAO=LTRI
         LMAP=LIA
         CALL POPLOC(IPASS,X(LVIN),X(LTRAN),X(LVOUT),
     *               X(LIORD),X(LIIR),X(LMAP),X(LRIJ),
     *               X(LQPIX),X(LQPJX),X(LNOROT),X(LSAO),
     *               L1,L2,N1,N2,NAT,NOUT)
      END IF
C
      IF(IPASS.EQ.1) THEN
         CALL DAWRIT(IDAF,IODA,X(LVOUT),L3,71,0)
      ELSE
         CALL DAWRIT(IDAF,IODA,X(LVOUT),L3,72,0)
      END IF
C
  600 CONTINUE
      CALL RETFM(NEED)
      IF(SCFTYP.EQ.UHF) GO TO 200
C
  700 CONTINUE
C
      IF (MASWRK .AND. NPRINT.NE.-23)
     * WRITE(IW, FMT='('' ...... END OF ORBITAL LOCALIZATION ......'')')
      CALL TIMIT(1)
      RETURN
 9000 FORMAT(/10X,25(1H-)/10X,'BOYS ORBITAL LOCALIZATION'/10X,25(1H-)/
     *        10X,'S.F.BOYS, IN "QUANTUM THEORY OF ATOMS, MOLECULES,',
     *            ' AND SOLIDS"'/
     *        10X,'P.O.LOWDIN, ED. ACADEMIC PRESS, NY, 1966 PP253-266.')
 9100 FORMAT(/10X,53(1H-)/,10X,
     * 'MOLECULAR ORBITALS LOCALIZED BY THE POPULATION METHOD'/
     *  10X,53(1H-)/10X,'REFERENCE: ',
     * 'J. PIPEK AND P. G. MEZEY, J. CHEM. PHYS. 90, 4916 (1989)')
 9010 FORMAT(/10X,'*****',A6,' ORBITAL LOCALIZATION *****')
 9020 FORMAT(/10X,'THIS LOCALIZATION REQUIRES',I10,' WORDS OF MEMORY.')
 9030 FORMAT(10X,'THIS LOCALIZATION HAS',I4,' ORBITALS, OF WHICH',
     *        I4,' ARE FROZEN.')
 9040 FORMAT(/1X,'*** ERROR ***'/
     *       1X,'THIS LOCALIZATION HAS NO ORBITALS TO LOCALIZE.'/
     *       1X,'PLEASE RECONSIDER YOUR FCORE/MOIN/MOOUT INPUT.')
      END
C*MODULE LOCAL   *DECK LMOPSI
      SUBROUTINE LMOPSI(IPASS,MCORE,MDOC,MACT,MOCC)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION METHOD
C
      LOGICAL CANONC,FCORE,FORS,EKT,LINSER
C
      PARAMETER (MXATM=2000, MXRT=100, MXNORO=250)
C
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,SDET,SZDET,
     *                GRPDET,STSYM,GLIST,DWPARM,
     *                NFLGDM(MXRT),IWTS(MXRT),NCORSV,NCOR,NACTDT,NORBDT,
     *                NADET,NBDET,KDET,KSTDET,IROOT,IPURES,MAXW1,NITDET,
     *                MAXP,NCIDET,IGPDET,KSTSYM,NFTGCI,IDWEIGH
      COMMON /GUGWFN/ NFZC,NMCC,NDOC,NAOS,NBOS,NALP,NVAL,NEXT,NFZV,
     *                IFORS,IEXCIT,ICICI,NOIRR
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWORD,NORBMC,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /VVOPAR/ IVVOS,NVVOS,BNDDEN
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DATA RHF,UHF,ROHF/8HRHF     ,8HUHF     ,8HROHF    /
      DATA RMC/8HMCSCF   /
      DATA GUGA,ALDET,GENCI,ORMAS,GMCCI
     *    /8HGUGA    ,8HALDET   ,8HGENCI   ,8HORMAS   ,8HGMCCI   /
      DATA BNDANA/8HBONDANAL/
C
C     ----- SET UP DEFAULTS FOR THE WAVEFUNCTION -----
C     -MCORE- IS THE NUMBER OF CHEMICAL CORE (NONVALENCE) ORBITALS,
C     -MDOC- IS THE NUMBER OF DOUBLY OCCUPIED VALENCE ORBITALS,
C     -MACT- IS THE NUMBER OF PARTIALLY OCCUPIED ORBITALS.
C     FOR UHF, -MCORE- IS STILL THE CHEMICAL CORE, BUT -MDOC- IS THE
C     NUMBER OF SINGLY OCCUPIED VALENCE ORBITALS, OF ALPHA OR BETA
C     SPIN DEPENDING ON THE VALUE FOR -IPASS-.
C
      MCORE= 0
      MDOC = 0
      MACT = 0
C
C     FIRST COUNT THE CHEMICAL CORE ORBITALS.
C
      MCORE = NUMCOR()
C
C     ASSIGN VALENCE ORBITALS ACCORDING TO THE SCF TYPE.
C
      IF(SCFTYP.EQ.RHF) THEN
         MDOC = NA - MCORE
         MACT = 0
         IF(IVVOS.GT.0) THEN
            IF(RUNTYP.EQ.BNDANA) THEN
               MDOC=NA + NVVOS - MCORE
               MACT=0
            ELSE
               MDOC=NA         - MCORE
               MACT=NVVOS
            END IF
         END IF
      END IF
      IF(SCFTYP.EQ.UHF) THEN
         IF(IPASS.EQ.1) THEN
            MDOC = NA - MCORE
         ELSE
            MDOC = NB - MCORE
         END IF
         MACT = 0
      END IF
      IF(SCFTYP.EQ.ROHF) THEN
         MDOC = NB - MCORE
         MACT = NA - NB
      END IF
      IF(SCFTYP.EQ.RMC) THEN
         IF(CISTEP.EQ.ALDET  .OR.  CISTEP.EQ.ORMAS  .OR.
     *      CISTEP.EQ.GENCI  .OR.  CISTEP.EQ.GMCCI) THEN
            MDOC = NCORSV - MCORE
            MACT = NACTDT
         END IF
         IF(CISTEP.EQ.GUGA) THEN
            MDOC = NMCC - MCORE
            MACT = NDOC + NALP + NAOS + NBOS + NVAL
         END IF
      END IF
C
      MOCC = MCORE + MDOC + MACT
      RETURN
      END
C*MODULE LOCAL   *DECK LMORND
      DOUBLE PRECISION FUNCTION LMORND(XX,D,L1)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000)
C
      COMMON /INFOA / NAT,ICH,MUL,NBASIS,NQMT,NE,NAE,NBE,
     *                ZAN(MXATM),COORD(3,MXATM),IAN(MXATM)
C
      DIMENSION D(L1,L1),U(1)
C
      SAVE U
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
      PI = ACOS(-ONE)
      IF (XX .EQ. ZERO) GO TO 100
         N = ABS(NAE-NBASIS)+1
         M = N+5
         XY = D(N,M)*ATAN(ONE)
         U(1) = (PI+XY)**5
         IU1 = INT(U(1))
         XY = IU1
         U(1) = U(1)-XY
         LMORND = U(1)
         RETURN
C
  100 CONTINUE
      U(1) = (PI+U(1))**5
      IU1 = INT(U(1))
      XY = IU1
      U(1) = U(1)-XY
      LMORND = U(1)
      RETURN
      END
C*MODULE LOCAL   *DECK LMOX
c> @brief      Orbital localization driver.
c>
c> @author     Mike Schmidt
c>             -1990s
c> @details    Routine selects initiates different orbital localizations.
c>
c> @date November 4, 2012-Aaron West
c> -Added SVD-localized orbitals option (part 1 of 3).
c> @date November 6, 2012-Aaron West
c> -Added malmq_cidriv call for future use (parts 2 and 3).
c> @date November 16, 2012-Aaron West
c> -Added another malmq_cidriv call for charge transfer.
c> @date December 7, 2012-Aaron West
c> -Added NATMOR to ORNTMO common block.
c>
      SUBROUTINE LMOX
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXAO=8192, NMO=500, MXMOL=10)
C
      LOGICAL MOIDON,EDCOMP,DIPDCM,QADDCM,DEPRNT,ZDO,POLDCM,POLANG,
     *        POLNUM,POLAPP,KMIDPT,POLDYN,ORIENT,ORMFUL,COMBO
C
      COMMON /EDCMP / ZIJ(NMO),ZMO(5,NMO),OCCUP(NMO),DPFREQ(50),
     *                MOIDNO(5,NMO),IJMO(2,NMO),MOIJ(NMO),NMOIJ(NMO),
     *                NMOAT(NMO),NDPFREQ,IPROT(5),NPROT,
     *                MOIDON,EDCOMP,DIPDCM,DEPRNT,QADDCM,ZDO,POLDCM,
     *                POLANG,POLAPP,KMIDPT,POLDYN
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
      COMMON /ORNTMO/ ORIENT,ORMFUL,NATMOR(MXAO)
      COMMON /POLNMP/ POLNUM
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DATA AMOROK /8HMOROKUMA/
      DATA RHF/8HRHF     /
C
      IF (ILOCAL.EQ.0) RETURN
      IF (ILOCAL.EQ.1) CALL LMOLOC(ILOCAL)
      IF (ILOCAL.EQ.2) CALL LOCENG
      IF (ILOCAL.EQ.3) CALL LMOLOC(ILOCAL)
      IORBF1=15
      IF (ILOCAL.EQ.4) CALL LOCAL_LMOSVD(IORBF1)
C
      IF (RUNTYP.EQ.AMOROK .AND. NMORO.LE.2) RETURN
C
C     ----- ASSIGN ORBITALS TO ATOM(S) -----
C
      IF (MOIDON)      CALL MOIDM
C
C     ----- ORBITAL ENERGY DECOMPOSITION -----
C
      IF (EDCOMP)      CALL EDCMPM
C
C     ----- MOMENTS LMO-DECOMPOSITION -----
C
      IF (DIPDCM)      CALL DIPLMM
      IF (QADDCM)      CALL QUADMM
C
C     ----- ALPHA POLARIZABILITY LMO-DECOMPOSITION -----
C
      IF(POLDYN) POLNUM=.FALSE.
      IF(POLDCM.OR.POLDYN) THEN
         IF(SCFTYP.EQ.RHF) THEN
            CALL MOIDM
            CALL DIPLMM
         END IF
         IF(POLNUM) THEN
            CALL POLNMM
         ELSE
            CALL LPOLX
         END IF
      END IF
C
C     ----- ORIENTATION AND BONDING ANALYSIS OF ORBITALS -----
C     CURRENTLY AVAILABLE FOR:
C     --EDMISTON-RUEDENBERG ORBITALS
C     --SVD LOCALIZED ORBITALS
C
      COMBO=.FALSE.
      IF(ILOCAL.EQ.2.OR.ILOCAL.EQ.4) COMBO=.TRUE.
      IF (ORIENT.AND.COMBO) CALL DIRLMO
C
C     ----- PERFORM ATOMS-IN-MOLECULES BONDING ANALYSIS -----
C
      IF(ILOCAL.EQ.4) THEN
C       ORIENTED OR NOT ORIENTED SELECTION
        IORBF2=71
        IF(ORIENT) IORBF2=286
C       OBTAIN CI COEFFICIENTS FOR LOCALIZED ORBITALS OF CHOICE.
        ICIMALMQ=1
        CALL MALMQ_CIDRIV(325,IORBF2,ICIMALMQ)
C       OBTAIN CI COEFFICIENTS FOR NO CHARGE TRANSFER WAVEFUNCTION.
        ICIMALMQ=3
        CALL MALMQ_CIDRIV(325,IORBF2,ICIMALMQ)
      ENDIF
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCANA
      SUBROUTINE LOCANA(TLOC,TRI,TRILOC,WRK,M1,M2)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION TLOC(M1,M1),TRI(M2),TRILOC(M2),WRK(M1)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DATA RHF,UHF,AMCSCF/8HRHF     ,8HUHF     ,8HMCSCF   /
      DATA ROHF,GVB/8HROHF    ,8HGVB     /
C
C     ----- ANALYSIS ROUTINE FOR RUEDENBERG LMO'S -----
C     FOR RHF AND UHF, ROTATE THE FOCK MATRIX TO THE LOCALIZED ORBITAL
C     BASIS, WHILE FOR MCSCF ROTATE THE DENSITY MATRIX.  NOTE THAT
C     ONLY THE LOCALIZED ORBITAL SPACE IS PRESENT IN THE -TRI- MATRIX
C     HOLDING THE FOCK/DENSITY, AND IN THE TRANSFORMATION MATRIX -TLOC-.
C
      IF(SCFTYP.EQ.ROHF) RETURN
      IF(SCFTYP.EQ.GVB)  RETURN
C
      CALL TFTRI(TRILOC,TRI,TLOC,WRK,M1,M1,M1)
C
      IF(MASWRK) THEN
         IF(SCFTYP.EQ.RHF  .OR.  SCFTYP.EQ.UHF) WRITE(IW,9010)
         IF(SCFTYP.EQ.AMCSCF) WRITE(IW,9020)
         IF(NFG.EQ.0.OR.NPRINT.NE.-5) CALL PRTRI(TRILOC,M1)
      END IF
C
C          WRITE OUT THE LOCALIZED MO FOCK -OR- DENSITY TO DAF
C
      CALL DAWRIT(IDAF,IODA,TRILOC,M2,285,0)
      RETURN
C
 9010 FORMAT(1X,'FOCK OPERATOR FOR THE LOCALIZED ORBITALS IS')
 9020 FORMAT(1X,'DENSITY MATRIX FOR THE LOCALIZED ORBITALS IS')
      END
C*MODULE LOCAL   *DECK LOCCHK
      SUBROUTINE LOCCHK(IW,TWOEI,IA,M1,M2,M4)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION TWOEI(M4),IA(M2)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ZERO=0.0D+00)
C
C     ----- COMPUTE SUBSUMS OF INTEGRALS DURING LOCALIZATION -----
C     M1    NUMBER OF ORBITALS BEING LOCALIZED
C     TWOEI ARRAY OF INTEGRALS STORED WITH TOTAL SYMMETRY
C
C     D =  LOCALIZATION SUM   GOES TO A MAXIMUM
C     C =  COULOMB SUM        INVARIANT
C     X =  EXCHANGE SUM       INVARIANT
C
      C=ZERO
      X=ZERO
      D=ZERO
      IT=0
      DO 110 I=1,M1
         II=IT + I
         IIT=IA(II)
         IIII=IIT + II
         D=D + TWOEI(IIII)
         JJ=0
         DO 100 J=1,I
            JJ=JJ+J
            IF(I.EQ.J) GO TO 100
               IJ=IT + J
               IJIJ=IA(IJ) + IJ
               X=X + TWOEI(IJIJ)
               IIJJ=IIT+JJ
               C=C + TWOEI(IIJJ)
  100    CONTINUE
         IT=IT+I
  110 CONTINUE
      C=D + C + C
      X=D + X + X
      IF (MASWRK) WRITE(IW,9000) D,C,X
      RETURN
C
 9000 FORMAT(5X,'DIAGONAL SUM D=',F20.10/
     *       5X,' COULOMB SUM C=',F20.10/
     *       5X,'EXCHANGE SUM X=',F20.10)
      END
C*MODULE LOCAL   *DECK LOCENG
      SUBROUTINE LOCENG
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION LMOEDA
C
      LOGICAL PACK2E,PK,PANDK,BLOCK,GOPARR,DSKWRK,MASWRK,
     *        SVDSKW,SVGPAR,SVDIRT,ABEL,ABELPT,
     *        DIRSCF,FDIFF,DIRTRF,DDITRF,RDINT,DOTRAN,
     *        DOEXCH,DOFOCK,
     *        DOOOOO,DOVOOO,DOVVOO,DOVOVO,DOVVVO,DOVVVV,DOCORE
C
      DIMENSION SPIN(2)
C
      PARAMETER (MXATM=2000, MXSH=5000, MXAO=8192, MXRT=100)
C
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,SDET,SZDET,
     *                GRPDET,STSYM,GLIST,DWPARM,
     *                NFLGDM(MXRT),IWTS(MXRT),NCORSV,NCOR,NACTDT,NORBDT,
     *                NADET,NBDET,KDET,KSTDET,IROOT,IPURES,MAXW1,NITDET,
     *                MAXP,NCIDET,IGPDET,KSTSYM,NFTGCI,IDWEIGH
      COMMON /FMCOM / X(1)
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /OPTLOC/ CVGLOC,MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,
     *                MOOUTA(MXAO),MOOUTB(MXAO)
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PKFIL / PK,PANDK,BLOCK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                T(432),INVT(48),NT
      COMMON /TRFOPT/ CUTTRF,NWDTRF,MPTRAN,ITRFAO,NOSYMT,IPURTF,DIRTRF
      COMMON /VVOPAR/ IVVOS,NVVOS,BNDDEN
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      INTEGER         D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB
      LOGICAL         NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
      COMMON /TRFDMS/ D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB,
     *                NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
C
      DATA UHF/8HUHF     /
      DATA RMC/8HMCSCF   /
      DATA SCF/8HSCF     /
      DATA LMOEDA/8HLMOEDA  /
      DATA SPIN/6H ALPHA,6H* BETA/
      DATA CHECK/8HCHECK   /
      DATA HSSIAN,PROP,BNDANA/8HHESSIAN ,8HPROP    ,8HBONDANAL/
C
C     ----- MAIN DRIVER FOR ENERGY LOCALIZATION -----
C     THE CODE ASSOCIATED WITH ENERGY LOCALIZATION IS TAKEN
C     PROGRAM 'LOCL' FROM THE 'ALIS' (AMES LAB, IOWA STATE)
C     PROGRAM SYSTEM, IN A 1984 VERSION.
C
C     MANY PEOPLE FROM THE RUEDENBERG GROUP PARTICIPATED
C     IN THE DEVELOPMENT OF THIS PROGRAM.  THE MAIN PORTION
C     OF THIS PROGRAM (THE PRESENT ROUTINE LOCLIZ) WAS WRITTEN
C     BY RICH RAFFENETTI BETWEEN 1966-1968.  OF COURSE, MANY
C     OTHERS IN THE RUEDENBERG GROUP, SUCH AS CLYDE EDMISTON,
C     KEN SUNDBERG, STEVE ELBERT, ... ALSO CONTRIBUTED.
C
C     THE ENERGY LOCALIZATION CODE WAS ADAPTED TO GAMESS
C     BY MIKE SCHMIDT AT NORTH DAKOTA STATE UNIVERSITY
C     IN MARCH OF 1991, BY PERMISSION OF KLAUS RUEDENBERG.
C
C     TWO PAPERS GERMANE TO THIS METHOD AND ITS IMPLEMENTATION ARE
C     C.EDMISTON, K.RUEDENBERG, REV.MOD.PHYS. 1963, 35, 457-465
C     R.C.RAFFENETTI, K.RUEDENBERG, C.L.JANSSEN, H.F.SCHAEFER,
C     THEORET.CHIM.ACTA 1993, 86, 149-165.
C
      IF (MASWRK) WRITE(IW,9000)
      SVDIRT = DIRTRF
C
C     ----- CHECK TO SEE IF THE TRANSFORMED TWO-ELECTRON INTEGRALS
C           ARE GIVEN -----
C     FEB 2010, MWS: THE FNDGRP CALL STRING WAS REVERSED IN ORDER,
C     FOR THE PURPOSE OF DEACTIVATING THIS OPTION.  THE CHANCE OF
C     A USER HAVING EXACTLY THE RIGHT TRANSFORMED INTEGRALS TO
C     RESTART CORRECTLY SEEMS VERY SLIM.  THE CODE BELOW JAMS UP
C     IN CASE OF PARALLEL EXECUTION, SO LET'S FORCE -RDINT- OFF.
C
C     JAN'S DOCUMENTATION FOR THIS FOLLOWS:
C         $TWOEI GROUP    (RELEVANT FOR EDCOMP=.TRUE. IN $LOCAL)
C            FORMATTED TRANSFORMED TWO-ELECTRON COULOMB AND EXCHANGE
C         INTEGRALS AS PUNCHED DURING A LOCAL=RUEDNBRG RUN.  IF THIS
C         GROUP IS PRESENT IT WILL AUTOMATICALLY BE READ IN DURING
C         SUCH A RUN AND THE TWO-ELECTRON INTEGRALS DO NOT HAVE TO
C         BE RE-TRANSFORMED.  THIS GROUP IS ESPECIALLY USEFUL FOR
C         EDCOMP=.TRUE. RUNS WHEN THE LOCALIZATION HAS TO BE REPEATED
C         FOR DIFFERENT DEFINITIONS OF NUCLEAR LCDS.
C
      RDINT = .FALSE.
      CALL SEQREW(IR)
      CALL FNDGRP(IR,' $IEOWT ',IEOF)
      IF (IEOF.EQ.0) RDINT = .TRUE.
      IF (RDINT) GO TO 100
C
C     ----- PREPARE CORRECT INTEGRAL LIST ---
C     THIS MUST BE -J- FORMAT
C     IN SOME CASES, THIS FILE MAY BE ALREADY THERE.
C
      IF(PK) THEN
         IF(MASWRK) WRITE(IW,*) 'LOCENG: SOMEHOW THIS IS A -PK- FILE'
         CALL ABRT
      END IF
C
C        THERE'S A SELDOM USED OPTION TO RESTART BY READING IN
C        THE TRANSFORMED INTEGRALS (FROM INPUT FILE).
C        THE BOND ORDER ANALYSIS HAS PROBABLY ALREADY DONE THE
C        INTEGRAL TRANSFORMATION IN ORDER TO OBTAIN A CI DENSITY
C        MATRIX, SO WE CAN JUST READ THE SAME -MOINTS- FILE.
C
      DOTRAN=.TRUE.
      IF(RDINT) DOTRAN=.FALSE.
      IF(RUNTYP.EQ.BNDANA) THEN
         DOTRAN=.FALSE.
         IF(BNDDEN.EQ.SCF) DOTRAN=.TRUE.
      END IF
C
      IF(SCFTYP.EQ.RMC  .AND.  RUNTYP.NE.PROP) GO TO 100
      IF(RUNTYP.EQ.HSSIAN) GO TO 100
C
C     IF DUPLICATED INTEGRAL FILES DESIRED FOR TRANSF., GENERATE THEM.
C     IF POINT GROUP IS NON-ABELIAN, GENERATE A C1 INTEGRAL FILE.
C     IF THIS IS A PROPERTIES RUN, NO 2E- INTEGRALS HAVE BEEN CREATED.
C
      ABEL = ABELPT()
      NTSAVE = NT
      SVDSKW = DSKWRK
      SVGPAR = GOPARR
      DSKWRK = .TRUE.
C
C     IF(DDITRF.OR..NOT.GOPARR) THEN
      IF(NFG.EQ.0) THEN
      IF(DOTRAN) THEN
         IF(.NOT.GOPARR  .AND.  (.NOT.ABEL .OR.  RUNTYP.EQ.PROP)) THEN
            IF(.NOT.ABEL) NT = 1
            IF(.NOT.DIRSCF) CALL JANDK
         END IF
      END IF
      ELSE
C     THIS CODE SHOULD BE FOR .NOT.DDITRF .AND. GOPARR
C             (IRRESPECTIVE OF NFG)??
      IF((GOPARR.AND.ITRFAO.EQ.1)
     *   .OR.  .NOT.ABEL
     *   .OR.   RUNTYP.EQ.PROP) THEN
         IF(ITRFAO.EQ.1) GOPARR = .FALSE.
         IF(.NOT.ABEL) NT = 1
         IF(.NOT.DIRSCF) CALL JANDK
      END IF
      END IF
C
      GOPARR = SVGPAR
      NT = NTSAVE
C
C     LOOP OVER SEPARATE ALPHA AND (MAYBE) BETA LOCALIZATIONS
C
  100 CONTINUE
      DSKWRK = .TRUE.
      IPASS = 0
  110 CONTINUE
      IPASS = IPASS+1
      IF(IPASS.GT.2) GO TO 800
      IF((SCFTYP.EQ.UHF) .AND. MASWRK) WRITE(IW,9010) SPIN(IPASS)
C
      CALL LMOPSI(IPASS,MCORE,MDOC,MACT,NUMLOC)
      IF(IPASS.EQ.1) THEN
         NOUT=NOUTA
      ELSE
         NOUT=NOUTB
      END IF
C
      L0 = NQMT
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
      M1 = NUMLOC - NOUT
      M2 = (M1*M1+M1)/2
      M4 = (M2*M2+M2)/2
      NUMLC2 = (NUMLOC*NUMLOC+NUMLOC)/2
C
C     ----- SELECT THE ORBITALS WHICH ARE TO BE LOCALIZED -----
C     CANONICAL ORBITALS AT -LCLMO- ARE REORDERED INTO -LCMO-
C
      CALL VALFM(LOADFM)
      LCLMO  = LOADFM + 1
      LCMO   = LCLMO  + L3
      LRHOC  = LCMO   + L3
      LEIGC  = LRHOC  + NUMLC2
      LTRIC  = LEIGC  + L1
      LMAP   = LTRIC  + M2
      LAST   = LMAP   + M1
      NEED1 = LAST - LOADFM -1
      CALL GETFM(NEED1)
C
      CALL LOCSET(IPASS,X(LCLMO),X(LCMO),X(LRHOC),X(LEIGC),X(LTRIC),
     *            X(LMAP),L1,M1,M2,NUMLOC,NUMLC2)
C
C     ----- INTEGRAL TRANSFORMATION -----
C     THIS IS PERFORMED ONLY FOR THE ORBITALS TO BE LOCALIZED.
C
      IF(DIRSCF) DIRTRF=.TRUE.
      IPRT=0
      DDITRF=GOPARR
      IF(NFG.NE.0) DDITRF=.FALSE.
C
      DOEXCH=.FALSE.
      IF(RUNTYP.EQ.PROP  .AND.  DIRTRF) DOEXCH=.TRUE.
      DOFOCK=.FALSE.
      DOOOOO=.TRUE.
      DOVOOO=.FALSE.
      DOVVOO=.FALSE.
      DOVOVO=.FALSE.
      DOVVVO=.FALSE.
      DOVVVV=.FALSE.
      DOCORE=.FALSE.
C
C         THESE ARGS FOR THE TRANSF. DO [OO|OO] ONLY, ACCORDING TO THE
C         VAGARIES OF THE SERIAL OR DDI TRANSFORMATION INNER WORKINGS!
C         HERE "O" MEANS THOSE ORBITALS WHICH ARE BEING LOCALIZED.
C         THE CALL TO -LOCSET- HAS PLACED ANY ORBITALS WHICH ARE
C         OCCUPIED AND FROZEN AT THE FRONT OF DIRECT ACCESS RECORD 15,
C         WHICH ARE CONSIDERED "CORE" DURING THE TRANSFORMATION,
C         TO SKIP COMPUTING THOSE INTEGRALS.
C
      IF(DDITRF) THEN
         ICORE  = NOUT
         NMOTOT = NQMT
      ELSE
         ICORE  = -NOUT
         NMOTOT = NUMLOC
      END IF
C
      IF(DOTRAN) CALL TRFMCX(IPRT,ICORE,NUMLOC,NMOTOT,DOFOCK,DOEXCH,
     *                       DDITRF,DOOOOO,DOVOOO,DOVVOO,DOVOVO,
     *                       DOVVVO,DOVVVV,DOCORE)
C
C     ----- ALLOCATE MEMORY FOR THE LOCALIZATION -----
C
      IF (MASWRK  .AND.  DOTRAN) THEN
         WRITE(IW,9000)
         IF(SCFTYP.EQ.UHF) WRITE(IW,9010) SPIN(IPASS)
      END IF
      IF(DDITRF) THEN
         LENXX = M2
         LENIX = M1
      ELSE
         LENXX = NINTMX
         LENIX = NINTMX
      ENDIF
      CALL VALFM(LOADFM)
      LIA    = LOADFM + 1
      LXX    = LIA    + M2
      LIX    = LXX    + LENXX
      LONEEI = LIX    + LENIX
      LTWOEI = LONEEI + M2
      LCINT  = LTWOEI + M4
      LXINT  = LCINT  + M2
      LTLOC  = LXINT  + M2
      LNOROT = LTLOC  + L3
      LAST   = LNOROT + M2
      IF(ISYMLO.EQ.1) THEN
         LS     = LAST
         LQ     = LS     + L2
         LWRK   = LQ     + L3
         LLABMO = LWRK   + L1
         LAST   = LLABMO + M1
      ELSE
         LS     = LAST
         LQ     = LAST
         LWRK   = LAST
         LLABMO = LAST
      END IF
C
      NEED2 = LAST - LOADFM - 1
      NEED = NEED1+NEED2
      IF (MASWRK) WRITE(IW,9020) NEED
      CALL GETFM(NEED2)
      IF(EXETYP.EQ.CHECK) GO TO 600
C
C     ----- READ ALL TRANSFORMED INTEGRALS INTO MEMORY ----
C
      IF (RDINT) THEN
         CALL TWEIIN(X(LCINT),X(LXINT),M2)
         CALL DAREAD(IDAF,IODA,X(LCLMO),L3,15,0)
         GO TO 400
      ELSE
C           IF WE ARE RECYCLING A DDI TRANSFORMATION FOR BOND ANALYSIS,
C           THE CORE ORBITALS ARE PRESENT IN THE DISTRIBUTED ARRAY.
C           OTHERWISE, WE HAVE MOVED THE ORBITALS TO BE LOCALIZED TO
C           THE FRONT OF THE ARRAY, AND SO THERE ARE NO CORES IN FRONT.
C
         IF(MASWRK .AND. DDITRF) WRITE(IW,9025)
                                             NCORE = 0
         IF(RUNTYP.EQ.BNDANA  .AND.  DDITRF) NCORE = NCORSV
         IF(DOTRAN)                          NCORE = 0
         CALL RDCI12(DDITRF,IJKT,X(LONEEI),X(LTWOEI),NCORE,M1,M2,M4,
     *               X(LIA),X(LXX),X(LIX),NINTMX)
         IF(DDITRF) THEN
            IF(MASWRK) WRITE(IW,9035) D_OOOO
            CALL DDI_DESTROY(D_OOOO)
         END IF
      END IF
C
C     ----- CARRY OUT THE LOCALIZATION -----
C
      IF (MASWRK) WRITE(IW,9030) NUMLOC,NOUT
      IF (NUMLOC-NOUT .LE.0) THEN
         IF(MASWRK) WRITE(IW,9040)
         CALL ABRT
      END IF
C
      CALL DAREAD(IDAF,IODA,X(LCMO),L3,15,0)
      CALL LOCFRZ(IPASS,MCORE,MDOC,X(LNOROT),X(LS),X(LQ),
     *            X(LWRK),X(LCMO+L1*NOUT),X(LLABMO),L0,L1,L2,L3,M1,M2)
      CALL LOCLIZ(X(LCMO+L1*NOUT),X(LTLOC),X(LCLMO),
     *            X(LCINT),X(LXINT),X(LTWOEI),X(LIA),X(LNOROT),
     *            IW,L1,M1,M2,M4,CVGLOC,IPRTLO,IPASS)
C
      IF(RUNTYP.EQ.LMOEDA) THEN
         CALL LMODJKM(IPASS,X(LTWOEI),X(LIA),M1,M2,M4)
         CALL LOCFIN(IPASS,X(LCMO),X(LCLMO),L1,M1,NUMLOC)
         CALL LMOTVM(IPASS,L1,X(LCLMO),M1)
         GO TO 600
      END IF
C
C     ----- ANALYSIS OF FOCK OR DENSITY MATRIX -----
C     STORAGE AT -LCINT- AND -LXINT- USED AS SCRATCH HERE
C
      IF(RUNTYP.NE.PROP) CALL LOCANA(X(LTLOC),X(LTRIC),X(LCINT),
     *                               X(LXINT),M1,M2)
C
C     ----- OUTPUT THE FINAL ORBITALS -----
C
  400 CONTINUE
      CALL LOCFIN(IPASS,X(LCMO),X(LCLMO),L1,M1,NUMLOC)
  600 CONTINUE
      CALL RETFM(NEED2)
      CALL RETFM(NEED1)
      IF(SCFTYP.EQ.UHF  .AND.  NB.GT.0) GO TO 110
C
  800 CONTINUE
C
      IF(.NOT. RDINT.AND.NFG.NE.0) CALL SEQCLO(IJKT,'DELETE')
C     DESTROY ALL MO INTEGRAL FILES.
C
      DIRTRF = SVDIRT
      DSKWRK = SVDSKW
      IF (MASWRK) WRITE(IW,9050)
      CALL TIMIT(1)
      RETURN
C
 9000 FORMAT(/10X,39(1H-)/
     *       10X,'EDMISTON-RUEDENBERG ENERGY LOCALIZATION'/10X,39(1H-)/
     *       10X,'C.EDMISTON AND K.RUEDENBERG,',
     *           ' REV.MOD.PHYS. 35, 457-465 (1963)')
 9010 FORMAT(/1X,'*****',A6,' ORBITAL LOCALIZATION *****')
 9020 FORMAT(/1X,'THIS LOCALIZATION REQUIRES',I10,' WORDS OF MEMORY.')
 9025 FORMAT(1X,'THE ENERGY LOCALIZATION STEP RUNS IN SERIAL, BUT',
     *          ' WILL USE WAVEFUNCTION'/
     *       1X,'AND TRANSFORMED INTEGRAL INFORMATION PREVIOUSLY',
     *          ' GENERATED IN PARALLEL MODE.')
 9030 FORMAT(1X,'THIS LOCALIZATION HAS',I4,' ORBITALS, OF WHICH',
     *        I4,' ARE FROZEN.')
 9035 FORMAT(1X,'DESTROYING DDI ARRAY [',I2,
     *          '] CONTAINING [OO|OO] INTEGRALS')
 9040 FORMAT(/1X,'*** ERROR ***'/
     *       1X,'THIS LOCALIZATION HAS NO ORBITALS TO LOCALIZE.'/
     *       1X,'PLEASE RECONSIDER YOUR FCORE/MOIN/MOOUT INPUT.')
 9050 FORMAT(1X,'... DONE WITH ENERGY LOCALIZATION ...')
      END
C*MODULE LOCAL   *DECK LOCFIN
      SUBROUTINE LOCFIN(IPASS,CMO,CLMO,L1,M1,NUMLOC)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXAO=8192)
      LOGICAL GOPARR,DSKWRK,MASWRK
      DIMENSION CMO(L1,L1),CLMO(L1,M1)
C
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /OPTLOC/ CVGLOC,MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,
     *                MOOUTA(MXAO),MOOUTB(MXAO)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DATA UHF/8HUHF     /
C
C     ----- FINAL ENERGY LOCALIZATION OUTPUT -----
C     ON EXIT, IPASS=1, 15 = CANONICAL ALPHA MO-S
C                       71 = LOCALIZED ALPHA MO-S
C                       19 = CANONICAL BETA MO-S
C                       72 = NOTHING
C     ON EXIT, IPASS=2, 15 = CANONICAL ALPHA MO-S
C                       71 = LOCALIZED ALPHA MO-S
C                       19 = CANONICAL BETA MO-S
C                       72 = LOCALIZED BETA MO-S
C
      IF(IPASS.EQ.1) THEN
         NOUT=NOUTA
         NDAFC=15
         NDAFL=71
      ELSE
         NOUT=NOUTB
         CALL DAREAD(IDAF,IODA,CMO,L1*L1,19,0)
         CALL DAWRIT(IDAF,IODA,CMO,L1*L1,15,0)
         NDAFC=19
         NDAFL=72
      END IF
C
C     RECOVER THE ORIGINAL CANONICAL ORBITALS.
C
      CALL DAREAD(IDAF,IODA,CMO,L1*L1,NDAFL,0)
      CALL DAWRIT(IDAF,IODA,CMO,L1*L1,NDAFC,0)
C
C     COPY THE MOS WHICH HAVE BEEN LOCALIZED TO THEIR ORIGINAL SPOT.
C
      NMO = 0
      DO 120 J=1,NUMLOC
         DO 110 I=1,NOUT
            IF(IPASS.EQ.1) THEN
               IF(MOOUTA(I).EQ.J) GO TO 120
            ELSE
               IF(MOOUTB(I).EQ.J) GO TO 120
            END IF
  110    CONTINUE
         NMO=NMO+1
         CALL DCOPY(L1,CLMO(1,NMO),1,CMO(1,J),1)
  120 CONTINUE
C
C     OUTPUT THE LOCALIZED ORBITALS
C
      CALL DAWRIT(IDAF,IODA,CMO,L1*L1,NDAFL,0)
C
      IF(NFG.EQ.0  .AND.  NPRINT.NE.-5) THEN
         IF (MASWRK) WRITE(IW,9010)
         CALL PRSQL(CMO,NUMLOC,L1,L1)
         IF((IPASS.EQ.1) .AND. MASWRK) WRITE(IP,9020)
         CALL PUSQL(CMO,NUMLOC,L1,L1)
         IF((IPASS.EQ.2  .OR.  SCFTYP.NE.UHF) .AND. MASWRK)
     *      WRITE(IP,9030)
      END IF
      RETURN
C
 9010 FORMAT(/1X,'EDMISTON-RUEDENBERG ENERGY LOCALIZED ORBITALS')
 9020 FORMAT('ENERGY LOCALIZED ORBITALS'/' $VEC')
 9030 FORMAT(' $END')
      END
C*MODULE LOCAL   *DECK LOCFRZ
C> @brief      This routine decides which orbitals to localize.
C>
C> @author     Mike Schmidt
C>             -1991
C>
C> @details    SET UP DEFAULTS FOR FREEZING ORBITALS
C>             FOR RUEDENBERG LOCALIZATION.
C>
C>    @date December 7, 2012-Aaron West
C>    -Added NATMOR to ORNTMO common block.
C>     This integer array is different from NATORB.
C>
      SUBROUTINE LOCFRZ(IPASS,MCORE,MDOC,NOROT,S,Q,
     *                  WRK,CMO,LABMO,L0,L1,L2,L3,M1,M2)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION METHOD
C
      PARAMETER (MXAO=8192)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,ABEL,CANONC,FCORE,FORS,
     *        EKT,LINSER,FDIRCT,QCORR,ORIENT,ORMFUL
C
      DIMENSION NOROT(M2),S(L2),Q(L3),WRK(L1),CMO(L1,M1),LABMO(L1)
C
      PARAMETER (MXNORO=250)
C
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIMFCC(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWORD,NORBMC,NORTMC(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /OPTLOC/ CVGLOC,MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,
     *                MOOUTA(MXAO),MOOUTB(MXAO)
      COMMON /ORNTMO/ ORIENT,ORMFUL,NATMOR(MXAO)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /SYMBLK/ NIRRED,NSALC,NSALC2,NSALC3,NSAFMO
      COMMON /SYMMOL/ GROUP,COMPLEX,IGROUP,NAXIS,ILABMO,ABEL
      COMMON /SYMQMT/ IRPLAB(14),IRPNUM(14),IRPDIM(14),IRPDEG(14)
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DATA RMC,ORMAS/8HMCSCF   ,8HORMAS   /
C
C     ----- SET UP DEFAULTS FOR FREEZING ORBITALS -----
C
      DO 100 I=1,M2
         NOROT(I) = 0
  100 CONTINUE
C
C     SET UP AN INVARIANT LOCALIZATION, BY RESTRICTING ANY
C     ROTATIONS MIXING DOUBLY AND PARTIALLY OCCUPIED ORBITALS.
C     LEAVE OUT ANY ROW AND COLUMN INVOLVING A FROZEN ORBITAL.
C
      NUMLOC = M1
      NDBOCC = MCORE + MDOC
      IJ=0
      DO 280 I=1,NUMLOC+NOUTA
         IF(IPASS.EQ.1) THEN
            DO KK=1,NOUTA
               IF(I.EQ.MOOUTA(KK)) GO TO 280
            ENDDO
         ELSE
            DO KK=1,NOUTB
               IF(I.EQ.MOOUTB(KK)) GO TO 280
            ENDDO
         END IF
         DO 270 J=1,I
            IF(IPASS.EQ.1) THEN
               DO 240 KK=1,NOUTA
                  IF(J.EQ.MOOUTA(KK)) GO TO 270
  240          CONTINUE
            ELSE
               DO 250 KK=1,NOUTB
                  IF(J.EQ.MOOUTB(KK)) GO TO 270
  250          CONTINUE
            END IF
            IJ = IJ+1
            IF(I.GT.NDBOCC  .AND.  J.LE.NDBOCC) NOROT(IJ)=1
  270    CONTINUE
  280 CONTINUE
C
C         ORMAS-MCSCF IS NOT INVARIANT TO ROTATIONS THAT MIX
C         ORBITALS BETWEEN THE MULTIPLE ACTIVE SPACES, SO UNLESS
C         THE USER SPECIFICALLY WANTS TO, FREEZE THESE ROTATIONS.
C         STORAGE -LABMO- USED TO DEFINE ORBITAL SPACE COUNTER
C
      IF(.NOT.(SCFTYP.EQ.RMC  .AND.  CISTEP.EQ.ORMAS)) GO TO 500
      IF(ORMFUL) GO TO 500
C
      DO I=1,MDOC
         LABMO(I) = 1
      ENDDO
      DO 330 ISPACE=1,NSPACE
         DO 320 I=MSTA(ISPACE),M1+NOUTA
            IF(IPASS.EQ.1) THEN
               DO KK=1,NOUTA
                  IF(I.EQ.MOOUTA(KK)) GO TO 320
               ENDDO
            ELSE
               DO KK=1,NOUTB
                  IF(I.EQ.MOOUTB(KK)) GO TO 320
               ENDDO
            END IF
            LABMO(I-MCORE) = ISPACE+1
  320    CONTINUE
  330 CONTINUE
C
      IJ=0
      DO I=1,M1
         ISPACE = LABMO(I)
         DO J=1,I
            IJ=IJ+1
            IF(ISPACE.NE.LABMO(J)) NOROT(IJ)=1
         ENDDO
      ENDDO
C
C        OPTIONALLY, RESTRICT ROTATIONS SO THAT ORBITALS WITH
C        DIFFERENT SYMMETRIES ARE NOT MIXED.
C
  500 CONTINUE
      IF(ISYMLO.EQ.0) RETURN
C                     ******
C
C        -SYMMOS- WILL CHANGE ORBITAL PHASES, MAKING THE MOS
C        INCONSISTENT WITH THOSE USED ALREADY IN THE INTEGRAL
C        TRANSFORMATION, AND WITH DATA LIKE DENSITY MATRICES
C        READ FROM DISK FOR EXTENDED ANALYSIS.  SO, WE PRESERVE
C        THE ORIGINAL ORBITAL PHASES BY DUMPING THEM TO DISK,
C        AND THEN RELOADING THEM.  ALL WE WANT IS -LABMO-
C
                     NDAFC=15
      IF(IPASS.EQ.2) NDAFC=19
C
      IF(ILABMO.EQ.0) THEN
         IF (MASWRK) WRITE(IW,9010)
         RETURN
      ELSE
         CALL DAREAD(IDAF,IODA,S,L2,12,0)
         CALL DAREAD(IDAF,IODA,Q,L3,45,0)
         CALL DAWRIT(IDAF,IODA,CMO,L3,NDAFC,0)
         CALL SYMMOS(LABMO,Q,S,CMO,WRK,L0,L1,NUMLOC,L1)
         CALL DAREAD(IDAF,IODA,CMO,L3,NDAFC,0)
      END IF
C
      IJ=0
      IDEG=0
      DO 590 I=1,NUMLOC
         ISYM=LABMO(I)
         IDEG=IDEG+1
         DO 510 IRP=1,NIRRED
            IF(ISYM.EQ.IRPLAB(IRP)) IRREP = IRP
  510    CONTINUE
         IDIM = IRPDIM(IRREP)
         IF(IDIM.EQ.1) IDEG=0
C
         JDEG = 0
         DO 580 J=1,I
            IJ=IJ+1
            JSYM = LABMO(J)
            JDEG = JDEG + 1
            DO 530 IRP=1,NIRRED
               IF(JSYM.EQ.IRPLAB(IRP)) IRREP = IRP
  530       CONTINUE
            JDIM = IRPDIM(IRREP)
            IF(JDIM.EQ.1) JDEG=0
            IF(ISYM.NE.JSYM  .OR.  IDEG.NE.JDEG) NOROT(IJ)=1
            IF(JDEG.EQ.JDIM) JDEG=0
  580    CONTINUE
         IF(IDEG.EQ.IDIM) IDEG=0
  590 CONTINUE
      RETURN
C
 9010 FORMAT(//1X,55(1H*)/
     *       1X,'YOUR GROUP DOES NOT SUPPORT ORBITAL SYMMETRY LABELS.'/
     *       1X,'-SYMLOC- OPTION IS DEACTIVATED.  MAXIMUM LOCALIZATION'/
     *       1X,'CONSISTENT WITH WAVEFUNCTION INVARIANCE WILL BE DONE.'/
     *       1X,55(1H*)//)
      END
C*MODULE LOCAL   *DECK LOCLIZ
      SUBROUTINE LOCLIZ(CMO,TLOC,CLMO,CINT,XINT,TWOEI,IA,NOROT,
     *                  IW,L1,M1,M2,M4,CVGLOC,IPRTLO,IPASS)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION CMO(L1,M1),TLOC(M1,M1),CLMO(L1,M1),IA(M2),
     *          CINT(M2),XINT(M2),TWOEI(M4),NOROT(M2)
C
      COMMON /IOFILE/ IR,IWDUM,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
C
      PARAMETER (ONE=1.0D+00, TENTH=0.1D+00,
     *           TEN6=1.0D+06)
C
C        ----- CONVERGENCE DRIVER FOR ENERGY LOCALIZATION -----
C
      II = 0
      DO 100 I=1,M2
         IA(I) = II
         II = II + I
  100 CONTINUE
C
      CALL VCLR(TLOC,1,M1*M1)
      DO 130 J=1,M1
         TLOC(J,J) = ONE
  130 CONTINUE
C
C        "COPY" CANONICAL TO LOCALIZED ORBITALS
C
      IF(ILOCAL.EQ.0) THEN
         CALL MRARBR(CMO,L1,L1,M1,TLOC,M1,M1,CLMO,L1)
         RETURN
      END IF
C
C        PRINT INITIAL COULOMB AND EXCHANGE INTEGRALS.
C        COMPUTE INITIAL LOCALIZATION, COULOUMB, AND EXCHANGE SUMS.
C
      IF(IPRTLO.EQ.1) THEN
         IF (MASWRK) WRITE(IW,9050) 'INITIAL'
         CALL LOCPCX(IW,TWOEI,CINT,XINT,IA,M1,M2,M4)
      END IF
      IF (MASWRK) WRITE(IW,9060) 'INITIAL'
      CALL LOCCHK(IW,TWOEI,IA,M1,M2,M4)
C
C        CARRY OUT LOCALIZATION ROTATIONS AT 6 CONVERGENCE LEVELS
C        ONLY THE MASTER NODE CARRIES OUT THE JACOBI INTEGRAL UPDATES,
C        SO LOCALIZING IS A SEQUENTIAL BOTTLENECK.
C
      IF(MASWRK) THEN
         WRITE(IW,9040)
         NTROT=0
         LOCOPT=0
         CVG = CVGLOC*TEN6
         IF(CVGLOC.LT.0) GO TO 301
         DO 300 LOCYCL=1,6
            CVG=TENTH*CVG
            CALL LOCROT(IW,TWOEI,TLOC,IA,NOROT,CVG,LOCOPT,NROT,M1,M2,M4)
            NTROT=NTROT+NROT
  300    CONTINUE
  301    CONTINUE
         WRITE(IW,9000) NTROT,CVG
      END IF
C
C        PRINT FINAL COULOMB AND EXCHANGE INTEGRALS.
C        COMPUTE FINAL LOCALIZATION, COULOUMB, AND EXCHANGE SUMS.
C
      IF(IPRTLO.EQ.1) THEN
         IF (MASWRK) WRITE(IW,9050) '  FINAL'
         CALL LOCPCX(IW,TWOEI,CINT,XINT,IA,M1,M2,M4)
         IF (MASWRK) THEN
            WRITE(IP,*) '$TWOEI'
            WRITE(IP,FMT='(1X,1P,5E15.8)') (CINT(J),J=1,M2)
            WRITE(IP,FMT='(1X,1P,5E15.8)') (XINT(J),J=1,M2)
            WRITE(IP,*) '$END'
         END IF
         CALL DAWRIT(IDAF,IODA,CINT,M2,59,0)
         CALL DAWRIT(IDAF,IODA,XINT,M2,60,0)
      END IF
      IF (MASWRK) WRITE(IW,9060) '  FINAL'
      CALL LOCCHK(IW,TWOEI,IA,M1,M2,M4)
C
C        TRANSFORM INPUT ORBITALS TO LOCALIZED ORBITALS.
C
      CALL MRARBR(CMO,L1,L1,M1,TLOC,M1,M1,CLMO,L1)
C
C        PRINT LOCALIZATION TRANSFORMATION
C
      IF(IPRTLO.EQ.1) THEN
         IF (MASWRK) WRITE(IW,9020)
         CALL PRSQ(TLOC,M1,M1,M1)
      END IF
C
C     ----- SAVE FOR MP2 LOCALIZATIONS -----
C
      IF(IPASS.EQ.1) CALL DAWRIT(IDAF,IODA,TLOC,M1*M1,73,0)
      IF(IPASS.EQ.2) CALL DAWRIT(IDAF,IODA,TLOC,M1*M1,74,0)
      RETURN
C
 9000 FORMAT(1X,I10,' TOTAL PAIR ROTATIONS REQUIRED TO CONVERGE TO',
     *       1P,E12.2)
 9020 FORMAT(/1X,'LOCALIZATION TRANSFORMATION')
 9040 FORMAT(/1X,'BEGINNING 2X2 JACOBI ROTATIONS...')
 9050 FORMAT(/1X,A7,' COULOMB AND EXCHANGE INTEGRALS')
 9060 FORMAT(/1X,A7,' LOCALIZATION SUMS ARE')
      END
C*MODULE LOCAL   *DECK LOCPCX
      SUBROUTINE LOCPCX(IW,TWOEI,CINT,XINT,IA,M1,M2,M4)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION TWOEI(M4),CINT(M2),XINT(M2),IA(M2)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C        ----- PRINT COULOMB AND EXCHANGE INTEGRALS -----
C        ON ENTRY, ALL TWO ELECTRON MO INTEGRALS ARE IN -TWOEI-.
C        COPY COULOMB AND EXCHANGE INTEGRALS INTO -CINT- AND
C        -XINT-, AND PRINT THESE FOR THE USER'S CONVENIENCE.
C
      CALL VCLR(CINT,1,M2)
      CALL VCLR(XINT,1,M2)
C
      II=0
      IJ=0
      DO 120 I=1,M1
         II=II+I
         IIA=IA(II)
         JJ=0
         DO 110 J=1,I
            IJ=IJ+1
            JJ=JJ+J
            IJIJ=IA(IJ)+IJ
            IIJJ=IIA+JJ
            CINT(IJ)=TWOEI(IIJJ)
            XINT(IJ)=TWOEI(IJIJ)
  110    CONTINUE
  120 CONTINUE
C
      IF (MASWRK) WRITE(IW,9000) ' COULOMB'
      CALL PRTRI(CINT,M1)
      IF (MASWRK) WRITE(IW,9000) 'EXCHANGE'
      CALL PRTRI(XINT,M1)
      RETURN
C
 9000 FORMAT(/1X,A8,' INTEGRAL MATRIX')
      END
C*MODULE LOCAL   *DECK LOCROT
      SUBROUTINE LOCROT(IW,TWOEI,TLOC,IA,NOROT,CVG,LOCOPT,NROT,
     *                  M1,M2,M4)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION TLOC(M1,M1),IA(M2),TWOEI(M4),NOROT(M2)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (PIOVR4=7.853981633974D-01, ZERO=0.0D+00,
     *           TENTH=0.1D+00, QUARTR=0.25D+00, HALF=0.5D+00,
     *           ONE=1.0D+00, TWO=2.0D+00, FOUR=4.0D+00)
C
C     ----- ENERGY LOCALIZATION VIA A JACOBI TECHNIQUE -----
C     TWO BY TWO ORBITAL ROTATIONS, USING INTEGRAL UPDATING.
C     C.EDMISTON AND K.RUEDENBERG, REV.MOD.PHYS. 35, 457 (1963)
C
C  TWOEI    ARRAY OF MINIMUM NUMBER OF MOLECULAR INTEGRALS STORED
C           WITH ORDINARY SYMMETRY; I.GE.J, K.GE.L, (IJ).GE.(KL)
C  TLOC     TRANSFORMATION MATRIX (INITIALIZE TO UNITY BEFORE CALLING)
C  M1       NUMBER OF MOS TO BE LOCALIZED
C  CVG      CONVERGENCE CRITERION ON THE TRANSFORMATION MATRIX.
C           1.0D-06 IMPLIES BETTER THAN SIX FIGURES IN THE TRANS.
C  LOCOPT   NONZERO TO DELOCALIZE ORBITALS, OTHERWISE LOCALIZE
C  NROT     RETURNS THE NUMBER OF PAIR ROTATIONS ACTUALLY CARRIED OUT
C
C           LL > LM > MM
C           LLLL > LLLM > LLMM > LMLM > LMMM > MMMM
C
      NROT=0
      NTRI=IA(M1) + M1
      DIV=TENTH
      THR=ONE
C
  130 CONTINUE
      THR=THR*DIV
  140 CONTINUE
      IND = 0
C
      DO 370 L=2,M1
         LMO=L - 1
         LT=IA(L)
         LL=LT + L
         LLT=IA(LL)
         LLLL=LLT + LL
         DO 360 M=1,LMO
            LM=LT + M
            IF(NOROT(LM).EQ.1) GO TO 360
            LMT=IA(LM)
            CLLLL=TWOEI(LLLL)
            LLLM=LLT + LM
            CLLLM=TWOEI(LLLM)
            MT=IA(M)
            MM=MT + M
            LMMM=LMT + MM
            CLMMM=TWOEI(LMMM)
            BLM=CLLLM - CLMMM
            LMLM=LMT + LM
            CLMLM=TWOEI(LMLM)
            LLMM=LLT + MM
            CLLMM=TWOEI(LLMM)
            MMT=IA(MM)
            MMMM=MMT + MM
            CMMMM=TWOEI(MMMM)
            ALM=QUARTR*(CLLLL + CMMMM - CLLMM - CLLMM) - CLMLM
            ALPHA=QUARTR*ATAN2(BLM,ALM)
            IF (LOCOPT.NE.0 .AND. ALM.GT.ZERO) ALPHA=ALPHA+PIOVR4
            IF(ABS(ALPHA).LT.THR)GO TO 360
               NROT=NROT + 1
C
               IND=1
C
               SINA=SIN(ALPHA)
               COSA=COS(ALPHA)
               SINA2=SINA*SINA
               COSA2=COSA*COSA
               SCA=SINA*COSA
               COS2A=COSA2 - SINA2
               SIN2A=SCA + SCA
               COS2A2=COS2A*COS2A
               SIN2A2=SIN2A*SIN2A
               SC2A=SIN2A*COS2A
               SIN4A=SC2A + SC2A
               COSA4=COSA2*COSA2
               SINA4=SINA2*SINA2
C
               DO 230 IJ=1,NTRI
                  IJT=IA(IJ)
                  IF(IJ.GT.LL)GO TO 170
                     IF(IJ.EQ.LL)GO TO 230
                        LLIJ=LLT + IJ
                        GO TO 180
C
  170                LLIJ=IJT + LL
  180                IF(IJ.GT.LM)GO TO 190
                        IF(IJ.EQ.LM)GO TO 230
                           LMIJ=LMT + IJ
                           GO TO 200
C
  190                   LMIJ=IJT + LM
  200                   IF(IJ.GT.MM)GO TO 210
                           IF(IJ.EQ.MM)GO TO 230
                              MMIJ=MMT + IJ
                              GO TO 220
C
  210                      MMIJ=IJT + MM
  220                      CONTINUE
                           CLLIJ=TWOEI(LLIJ)
                           CLMIJ=TWOEI(LMIJ)
                           CMMIJ=TWOEI(MMIJ)
                           TWOEI(LMIJ)=COS2A*CLMIJ-SCA*(CLLIJ-CMMIJ)
                           T=COSA2*CMMIJ+SINA2*CLLIJ- SIN2A*CLMIJ
                           TWOEI(MMIJ)=T
                           TWOEI(LLIJ)=CLLIJ + CMMIJ - T
  230          CONTINUE
C
          TWOEI(LLLL)=COSA4*CLLLL + SINA4*CMMMM + SIN2A2*(HALF*
     *         CLLMM + CLMLM) + TWO*SIN2A*(COSA2*CLLLM + SINA2*CLMMM)
          TWOEI(MMMM)=COSA4*CMMMM + SINA4*CLLLL + SIN2A2*(HALF*
     *         CLLMM + CLMLM) - TWO*SIN2A*(SINA2*CLLLM + COSA2*CLMMM)
          TWOEI(LMLM)=COS2A2*CLMLM - SC2A*(CLLLM - CLMMM)
     *         + QUARTR*SIN2A2*(CLLLL + CMMMM - CLLMM - CLLMM)
          TWOEI(LLMM)=(COSA4 + SINA4)*CLLMM + QUARTR*SIN2A2*
     *         (CLLLL+ CMMMM-FOUR*CLMLM)-SC2A*(CLLLM-CLMMM)
          TWOEI(LLLM)=(COS2A*COSA2 - HALF*SIN2A2)*CLLLM
     *         + (COS2A*SINA2 + HALF*SIN2A2)*CLMMM
     *         + QUARTR*SIN4A*(CLMLM + CLMLM + CLLMM)
     *         - SCA*(COSA2*CLLLL - SINA2*CMMMM)
          TWOEI(LMMM)=(COS2A*COSA2 - HALF*SIN2A2)*CLMMM
     *         + (COS2A*SINA2 + HALF*SIN2A2)*CLLLM
     *         - QUARTR*SIN4A*(CLLMM + CLMLM + CLMLM)
     *         + SCA*(COSA2*CMMMM - SINA2*CLLLL)
C
          DO 340 K=1,M1
             IF(K.EQ.L.OR.K.EQ.M)GO TO 340
                KT=IA(K)
                IF(K.GT.L)GO TO 240
                   KL=LT + K
                   GO TO 250
C
  240           KL=  KT + L
  250           IF(K.GT.M)GO TO 260
                   KM=MT + K
                   GO TO 270
C
  260           KM=KT + M
  270           CONTINUE
                KLT=IA(KL)
                KMT=IA(KM)
                DO 330 IJ=1,NTRI
                   IJT=IA(IJ)
                   IF(KL.GT.IJ)GO TO 280
                      KLIJ=IJT + KL
                      GO TO 290
C
  280              KLIJ=KLT + IJ
  290              IF(KM.GT.IJ)GO TO 300
                      IF(KM.EQ.IJ)GO TO 330
                         KMIJ=IJT + KM
                         GO TO 310
C
  300                 KMIJ=KMT + IJ
  310                 CONTINUE
                      CKLIJ=TWOEI(KLIJ)
                      CKMIJ=TWOEI(KMIJ)
                      IF(KL.EQ.IJ)GO TO 320
                         TWOEI(KLIJ)=COSA*CKLIJ + SINA*CKMIJ
                         TWOEI(KMIJ)=COSA*CKMIJ - SINA*CKLIJ
                         GO TO 330
C
  320                 KMKM=KMT + KM
                      KLKL=KLIJ
                      KLKM=KMIJ
                      CKMKM=TWOEI(KMKM)
                      CKLKL=CKLIJ
                      CKLKM=CKMIJ
                      T=COSA2*CKLKL + SINA2*CKMKM + SIN2A*CKLKM
                      TWOEI(KLKL)=T
                      TWOEI(KMKM)=CKLKL + CKMKM - T
                      TWOEI(KLKM)=COS2A*CKLKM - SCA*(CKLKL - CKMKM)
  330           CONTINUE
  340     CONTINUE
C
            DO 350 K=1,M1
               T1 =  COSA*TLOC(K,L) + SINA*TLOC(K,M)
               T2 = -SINA*TLOC(K,L) + COSA*TLOC(K,M)
               TLOC(K,L) = T1
               TLOC(K,M) = T2
  350       CONTINUE
  360    CONTINUE
  370 CONTINUE
C
      IF(IND.EQ.1) GO TO 140
      IF(THR.GT.CVG) GO TO 130
C
      IF (MASWRK) WRITE(IW,9000) NROT, CVG
      RETURN
C
 9000 FORMAT(1X,I10,' PAIR ROTATIONS WHEN CONVERGED TO',1P,E12.2)
      END
C*MODULE LOCAL   *DECK LOCSET
      SUBROUTINE LOCSET(IPASS,VCANON,VLOC,RHOC,EIGC,TRIC,MAP,
     *                  L1,M1,M2,NUMLOC,NUMLC2)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXAO=8192)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION VCANON(L1,L1),VLOC(L1,L1),RHOC(NUMLC2),EIGC(L1),
     *          TRIC(M2),MAP(M1)
C
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /OPTLOC/ CVGLOC,MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,
     *                MOOUTA(MXAO),MOOUTB(MXAO)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DATA RHF,UHF,AMCSCF/8HRHF     ,8HUHF     ,8HMCSCF   /
      DATA CHECK,PROP/8HCHECK   ,8HPROP    /
C
C     ----- REORDER THE ORBITALS FOR ENERGY LOCALIZATION -----
C     ALL FROZEN ORBITALS MUST BE IN FRONT OF ALL ORBITALS
C     WHICH ARE TO BE LOCALIZED, FOR THE INTEGRAL TRANSFORMATION.
C     THE TRANSFORMATION WORKS WITH WHATEVER ORBITALS ARE STORED
C     ON DAF RECORD 15.
C
      IF(IPASS.EQ.1) THEN
         NOUT=NOUTA
         NDAFC=15
         NDAFE=17
         NDAFL=71
      ELSE
         NOUT=NOUTB
         NDAFC=19
         NDAFE=21
         NDAFL=72
      END IF
C
C     LOAD ORBITALS, AND MAYBE EIGENVALUES OR DENSITY MATRIX
C
      CALL DAREAD(IDAF,IODA,VCANON,L1*L1,NDAFC,0)
      IF(RUNTYP.EQ.PROP  .OR.  EXETYP.EQ.CHECK) THEN
         IF(SCFTYP.EQ.RHF)    CALL VCLR(EIGC,1,L1)
         IF(SCFTYP.EQ.UHF)    CALL VCLR(EIGC,1,L1)
         IF(SCFTYP.EQ.AMCSCF) CALL VCLR(RHOC,1,NUMLC2)
      ELSE
         IF(SCFTYP.EQ.RHF)    CALL DAREAD(IDAF,IODA,EIGC,L1,NDAFE,0)
         IF(SCFTYP.EQ.UHF)    CALL DAREAD(IDAF,IODA,EIGC,L1,NDAFE,0)
         IF(SCFTYP.EQ.AMCSCF) CALL DAREAD(IDAF,IODA,RHOC,NUMLC2,68,0)
      END IF
C
C     A COPY OF THE ORIGINAL ORDER ORBITALS IS KEPT.
C
      CALL DAWRIT(IDAF,IODA,VCANON,L1*L1,NDAFL,0)
      CALL VCLR(VLOC,1,L1*L1)
C
C     PUT THE ORBITALS WHICH ARE TO BE FROZEN FIRST...
C
      NMO=0
      DO 120 J=1,NUMLOC
         DO 110 I=1,NOUT
            IF((IPASS.EQ.1  .AND.  MOOUTA(I).EQ.J)  .OR.
     *         (IPASS.EQ.2  .AND.  MOOUTB(I).EQ.J)) THEN
                  NMO = NMO+1
                  CALL DCOPY(L1,VCANON(1,J),1,VLOC(1,NMO),1)
                  GO TO 120
            END IF
  110    CONTINUE
  120 CONTINUE
C
C     ...THEN PUT IN THE ORBITALS TO BE LOCALIZED...
C
      LL=0
      DO 220 J=1,NUMLOC
         DO 210 I=1,NOUT
            IF(IPASS.EQ.1) THEN
               IF(MOOUTA(I).EQ.J) GO TO 220
            ELSE
               IF(MOOUTB(I).EQ.J) GO TO 220
            END IF
  210    CONTINUE
         NMO = NMO+1
         CALL DCOPY(L1,VCANON(1,J),1,VLOC(1,NMO),1)
         LL = LL+1
         MAP(LL) = J
  220 CONTINUE
C
      IF(NMO.NE.NUMLOC) THEN
         IF (MASWRK) WRITE(IW,9000) NMO,NUMLOC
         CALL ABRT
      END IF
C
C     ...AND FINISH UP WITH THE VIRTUAL SPACE.
C
      LVIRT = (L1-NUMLOC)*L1
      CALL DCOPY(LVIRT,VCANON(1,NMO+1),1,VLOC(1,NMO+1),1)
C
C        RHF/UHF WILL LATER TRANSFORM CANONICAL FOCK MATRIX TO LMO BASIS
C        STORE THE EIGENVALUES DOWN THE DIAGONAL OF A SYMMETRIC MATRIX
C
      IF(SCFTYP.EQ.RHF  .OR.  SCFTYP.EQ.UHF) THEN
         CALL VCLR(TRIC,1,M2)
         II = 0
         DO 310 I=1,M1
            II = II+I
            TRIC(II) = EIGC(MAP(I))
  310    CONTINUE
      END IF
C
C        MCSCF WILL LATER TRANSFORM DENSITY MATRIX TO LMO BASIS
C        PICK OUT THE DENSITY ELEMENTS FOR THE ORBITALS BEING LOCALIZED
C
      IF(SCFTYP.EQ.AMCSCF) THEN
         IJ=0
         DO 330 I=1,M1
            IMAP = MAP(I)
            DO 320 J=1,I
               IJ=IJ+1
               JMAP = MAP(J)
               IJMAP = (IMAP*IMAP-IMAP)/2 + JMAP
               TRIC(IJ) = RHOC(IJMAP)
  320       CONTINUE
  330    CONTINUE
      END IF
C
C     THE INTEGRAL TRANSFORMATION WORKS WITH WHATEVER ORBITALS
C     HAPPEN TO BE STORED IN RECORD 15.  IF THIS IS A UHF RUN,
C     WE MUST GRAB THE ALPHA ORBITALS, AND SAVE THEM FOR
C     LATER RESTORATION.  ON EXIT, WE WILL HAVE
C        IPASS=1      15 = ALPHA'S READY TO BE LOCALIZED
C                     71 = CANONICAL ALPHA MO-S
C                     19 = CANONICAL BETA MO-S
C                     72 = NOTHING
C        IPASS=2      15 = BETA'S READY TO BE LOCALIZED
C                     71 = LOCALIZED ALPHA MO-S
C                     19 = CANONICAL ALPHA MO-S
C                     72 = CANONICAL BETA MO-S
C
      IF(IPASS.EQ.2) THEN
         CALL DAREAD(IDAF,IODA,VCANON,L1*L1,15,0)
         CALL DAWRIT(IDAF,IODA,VCANON,L1*L1,19,0)
      END IF
      CALL DAWRIT(IDAF,IODA,VLOC,L1*L1,15,0)
      RETURN
C
 9000 FORMAT(1X,'PROBLEM GETTING ORBITALS TO BE LOCALIZED'/
     *       1X,'NMO=',I5,' BUT NUMLOC=',I5)
      END
C*MODULE LOCAL   *DECK POPLOC
      SUBROUTINE POPLOC(IPASS,VECIN,TRAN,VECOUT,IORD,IIR,
     *                  MAP,RIJ,QPIX,QPJX,NOROT,SAO,
     *                  L1,L2,N1,N2,NATOMS,NOUT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION LMORND
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION VECIN(L1,N1),TRAN(N1,N1),SAO(L2),NOROT(N1,N1),
     *          VECOUT(L1,N1),RIJ(N2,NATOMS),
     *          IIR(L1),MAP(L1),IORD(L1),QPIX(L1),QPJX(L1)
C
      PARAMETER (MXATM=2000, MXAO=8192)
C
      COMMON /ATLIM / LIMLOW(MXATM),LIMSUP(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /OPTLOC/ CVGLOC,MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,
     *                MOOUTA(MXAO),MOOUTB(MXAO)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /SCFOPT/ CONVHF,MAXIT,MCONV,NPUNCH,NPREO(4)
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00, TWO=2.0D+00, FOUR=4.0D+00,
     *           TENM3=1.0D-03, TENM8=1.0D-08, TENM10=1.0D-10)
C
      DATA UHF/8HUHF     /
C
      INDX(I,J) = ((MAX(I,J)*(MAX(I,J)-1))/2+MIN(I,J))
C
C     POPLOC CALCULATES THE LOCALIZED MOLECULAR ORBITALS BY THE
C     POPULATION METHOD OF
C     J. PIPEK AND P. G. MEZEY  J. CHEM. PHYS. 90, 4916 (1989),
C
C     THIS IMPLEMENTATION IS A MODIFICATION OF THE JACOBI PROCEDURE
C     CONTAINED IN QCPE PROGRAM 354 BY JOHN MONTGOMERY, JULY 1991,
C     WITH ADAPTATION TO THE LOCALIZATION CRITERION OF PIPEK AND MEZEY.
C
      NORB  = N1
      NBASIS= L1
      NFROZ = NOUT
      MAXITS= MAXIT
      MAXIT = MAXLOC
C
      CALL AOLIM
      DO 20 K=1,NBASIS
      DO 20 I=1,NATOMS
      IF(LIMLOW(I).LE.K.AND.LIMSUP(I).GE.K) MAP(K)=I
   20 CONTINUE
C
      NREDO = 0
  110 CONTINUE
      NREDO=NREDO+1
C
C          CONSTRUCT INITIAL ATOMIC POPULATIONS
C
      CALL VCLR(RIJ,1,N2*NATOMS)
      CALL DAREAD(IDAF,IODA,SAO,L2,12,0)
      IJ = 0
      DO 280 I = 1,NORB
         DO 280 J = 1,I
            IJ = IJ+1
            DO 260 K = 1,NBASIS
               KK = MAP(K)
               DO 260 L = 1,NBASIS
                  LL = MAP(L)
                  KL = INDX(K,L)
                  SUM = VECIN(K,I)*VECIN(L,J)*SAO(KL)/TWO
                  RIJ(IJ,KK) = RIJ(IJ,KK) + SUM
                  RIJ(IJ,LL) = RIJ(IJ,LL) + SUM
  260       CONTINUE
  280 CONTINUE
C
C          COMPUTE INITIAL LOCALIZATION SUM
C
      SUMRR = ZERO
      DO 320 I=1,NORB
         IF(NOROT(I,I).EQ.1) GO TO 320
         II = INDX(I,I)
         DO 310 K=1,NATOMS
            SUMRR = SUMRR + RIJ(II,K)**2
  310    CONTINUE
  320 CONTINUE
      IF (MASWRK) WRITE(IW,9010) SUMRR
      IF(IPRTLO.EQ.1) CALL POPQAT(RIJ,VECOUT,N2,NORB,NATOMS)
C
C          SEED THE RANDOM FUNCTION, INITIALIZE
C          THE LOCALIZATION TRANSFORMATION, ETC.
C
      ONEPT0 = ONE
      IF (NREDO.EQ.1) XX = LMORND(ONEPT0,VECIN,L1)
C
      CALL VCLR(TRAN,1,NORB*NORB)
      DO 340 I = 1,NORB
         TRAN(I,I) = ONE
  340 CONTINUE
      ITER = 0
      SHIFT = ATAN(ONEPT0)
C
C          BEGIN LOCALIZATION CYCLES
C
  360 CONTINUE
      CHANGE = ZERO
      ITER = ITER+1
      DO 380 I = 1,NORB
         IIR(I) = I
  380 CONTINUE
      NNN = NORB
      DO 400 I = 1,NORB
         XX = LMORND(CHANGE,VECIN,L1)
         III = INT(XX*NNN+ONE)
         IORD(I) = IIR(III)
         IIR(III) = IIR(NNN)
         NNN = NNN-1
  400 CONTINUE
C
C        FOR EACH PAIR OF ORBITALS A TWO DIMENSIONAL UNITARY
C        TRANSFORMATION IS PERFORMED. THE TRANSFORMATION IS
C
C           PSI'(I) =  COS(T)*PSI(I) + SIN(T)*PSI(J)  AND
C           PSI'(J) = -SIN(T)*PSI(I) + COS(T)*PSI(J).
C
C        LOCALIZATION REQUIRES THAT T BE SUCH AS TO MAXIMIZE
C        THE SUM OF THE SQUARES OF THE ATOMIC POPULATIONS.
C
      DO 920 III = 1,NORB
      I = IORD(III)
      IF(NOROT(I,I).EQ.1) GO TO 920
      II = INDX(I,I)
      JM = 1
      RM = ZERO
      TM = ZERO
      SM = ZERO
      CM = ONE
      DO 580 J = 1,NORB
      IF(I.EQ.J) GO TO 580
      IF(NOROT(I,J).EQ.1) GO TO 580
      IJ = INDX(I,J)
      JJ = INDX(J,J)
      T = ZERO
      TX = ZERO
      DO 480 KK = 1,NATOMS
         T = T + FOUR*RIJ(IJ,KK)**2 - RIJ(II,KK)**2 - RIJ(JJ,KK)**2
     *         + TWO*RIJ(II,KK)*RIJ(JJ,KK)
         TX = TX + RIJ(IJ,KK)*(RIJ(JJ,KK) - RIJ(II,KK))
  480 CONTINUE
      IF ((ABS(T) .LE. TENM10) .AND. (ABS(TX) .LE. TENM10)) GO TO 580
      TX = FOUR*TX
      T = ATAN2(TX,T)/FOUR
      SIGN = ONE
      IF (T .GT. ZERO) SIGN = -ONE
      T = T+SIGN*SHIFT
      ITIM = 0
  500 ITIM = ITIM+1
      S = SIN(T)
      C = COS(T)
      RIN = ZERO
      DO 520 KK = 1,NATOMS
         QPI = C*C*RIJ(II,KK)+S*S*RIJ(JJ,KK)+TWO*C*S*RIJ(IJ,KK)
         QPJ = C*C*RIJ(JJ,KK)+S*S*RIJ(II,KK)-TWO*C*S*RIJ(IJ,KK)
         RIN = RIN+QPI*QPI+QPJ*QPJ-RIJ(II,KK)**2-RIJ(JJ,KK)**2
  520 CONTINUE
      TTEST = ABS(T)-SHIFT
      IF ((ABS(T) .LE. TENM8) .OR. (ABS(TTEST) .LE. TENM8)) GO TO 560
      IF (RIN .GE. -TENM8) GO TO 560
      IF (ITIM .LE. 1) GO TO 540
      IF (MASWRK) THEN
         WRITE (IW,9020) I,J
         WRITE (IW,9030) T,S,C,RIN
      END IF
      MAXIT= MAXITS
      RETURN
C
  540 SIGN = ONE
      IF (T .GT. ZERO) SIGN = -ONE
      T = T+SHIFT*SIGN
      GO TO 500
C
  560 IF (RIN .LE. RM) GO TO 580
      RM = RIN
      TM = T
      SM = S
      CM = C
      JM = J
  580 CONTINUE
C
      RIN = RM
      T = TM
      S = SM
      C = CM
      J = JM
      IJ = INDX(I,J)
      JJ = INDX(J,J)
      IF(NOROT(I,J).EQ.1) GO TO 920
C
C        ACCUMULATE THE 2X2 ROTATION
C
      CHANGE = CHANGE+T*T
      CALL DROT(NORB,TRAN(1,I),1,TRAN(1,J),1,C,S)
C
C        UPDATE THE ATOMIC POPULATIONS
C
      DO 880 KK = 1,NATOMS
         QPI = C*C*RIJ(II,KK)+S*S*RIJ(JJ,KK)+TWO*C*S*RIJ(IJ,KK)
         QPJ = C*C*RIJ(JJ,KK)+S*S*RIJ(II,KK)-TWO*C*S*RIJ(IJ,KK)
         QPIJ = (C*C-S*S)*RIJ(IJ,KK)+C*S*(RIJ(JJ,KK)-RIJ(II,KK))
         DO 720 K = 1,NORB
            IF (I.EQ.K.OR.J.EQ.K) GO TO 720
            IK = INDX(I,K)
            JK = INDX(J,K)
            QPIX(K) = C*RIJ(IK,KK)+S*RIJ(JK,KK)
            QPJX(K) = C*RIJ(JK,KK)-S*RIJ(IK,KK)
            RIJ(IK,KK) = QPIX(K)
            RIJ(JK,KK) = QPJX(K)
  720    CONTINUE
         RIN = RIN+QPI+QPJ-RIJ(II,KK)-RIJ(JJ,KK)
         RIJ(II,KK) = QPI
         RIJ(JJ,KK) = QPJ
         RIJ(IJ,KK) = QPIJ
  880 CONTINUE
  920 CONTINUE
C
C          TEST FOR CONVERGENCE OF LOCALIZATION PROCEDURE
C
      CHANGE = SQRT(TWO*CHANGE/(NORB*(NORB-1)))
      IF((NPRINT.EQ.-7) .AND. MASWRK) WRITE(IW,9050) ITER,CHANGE
      IF((MOD(ITER,10).EQ.0) .AND. MASWRK) WRITE(IW,9050) ITER,CHANGE
      IF(ITER.LT.MAXIT  .AND.  CHANGE.GT.TENM3*CVGLOC) GO TO 360
      IF(CHANGE.LE.CVGLOC) GO TO 1000
         IF((NREDO.LE.2) .AND. MASWRK) WRITE(IW,9060)
         IF(NREDO.LE.2) GO TO 110
            IF (MASWRK) WRITE(IW,9070)
            MAXIT= MAXITS
            RETURN
C
C          FINISHED WITH LOCALIZATION CYCLES
C
 1000 CONTINUE
      IF (MASWRK) WRITE (IW,9080) ITER
C
C        TRANSFORM TO FINAL ORBITALS, COPY VIRTUAL SPACE
C
      CALL MRARBR(VECIN,NBASIS,NBASIS,NORB,TRAN,NORB,NORB,VECOUT,NBASIS)
      NVIRT = NBASIS - NORB
      CALL DCOPY(NVIRT*NBASIS,VECIN(1,NORB+1),1,VECOUT(1,NORB+1),1)
C
C          PRINT/PUNCH FINAL LOCALIZED ORBITALS
C
      IF (MASWRK) WRITE(IW,9090)
      CALL PRSQL(VECOUT,NORB,L1,L1)
C
      IF(IPRTLO.EQ.1) THEN
         IF (MASWRK) WRITE(IW,9120)
         CALL PRSQ(TRAN,NORB,NORB,N1)
      END IF
C
C     ----- SAVE THIS FOR EVENTUAL MP2 LOCALIZATION -----
C     WE NEED THE MATRIX WITHOUT THE CORE
C
      DO 1110 I = 1,NORB
         DO 1100 J = 1,NORB
            TRAN(I,J) = TRAN(I+NOUT,J+NOUT)
 1100    CONTINUE
 1110 CONTINUE
      NLOC = NORB - NOUT
      CALL SQZMAT(TRAN,NORB,NLOC,NORB)
      IF(IPASS.EQ.1) CALL DAWRIT(IDAF,IODA,TRAN,NLOC*NLOC,73,0)
      IF(IPASS.EQ.2) CALL DAWRIT(IDAF,IODA,TRAN,NLOC*NLOC,74,0)
C
      IF (MASWRK) WRITE (IW,9130) NORB,NFROZ,NBASIS
C
      IF((IPASS.EQ.1) .AND. MASWRK) WRITE(IP,8000)
      CALL PUSQL(VECOUT,NORB,L1,L1)
      IF((SCFTYP.NE.UHF  .OR.  IPASS.EQ.2) .AND. MASWRK)
     *   WRITE(IP,8010)
C
C          CONSTRUCT FINAL ATOMIC POPULATIONS
C
      CALL VCLR(RIJ,1,N2*NATOMS)
      CALL DAREAD(IDAF,IODA,SAO,L2,12,0)
      IJ = 0
      DO 1280 I = 1,NORB
         DO 1280 J = 1,I
            IJ = IJ+1
            DO 1260 K = 1,NBASIS
               KK = MAP(K)
               DO 1260 L = 1,NBASIS
                  LL = MAP(L)
                  KL = INDX(K,L)
                  SUM = VECOUT(K,I)*VECOUT(L,J)*SAO(KL)/TWO
                  RIJ(IJ,KK) = RIJ(IJ,KK) + SUM
                  RIJ(IJ,LL) = RIJ(IJ,LL) + SUM
 1260       CONTINUE
 1280 CONTINUE
C
C               COMPUTE FINAL LOCALIZATION SUM (SKIP FROZEN MO-S)
C
      SUMRR = ZERO
      DO 1380 I=1,NORB
         IF(NOROT(I,I).EQ.1) GO TO 1380
         II = INDX(I,I)
         DO 1370 K = 1,NATOMS
            SUMRR = SUMRR + RIJ(II,K)**2
 1370    CONTINUE
 1380 CONTINUE
      IF (MASWRK) WRITE(IW,9140) SUMRR
      IF(IPRTLO.EQ.1) CALL POPQAT(RIJ,VECIN,N2,NORB,NATOMS)
      MAXIT= MAXITS
      RETURN
C
 8000 FORMAT('PIPEK-MEZEY POPULATION LOCALIZED ORBITALS'/' $VEC')
 8010 FORMAT(' $END')
C
 9010 FORMAT(/10X,'THE INITIAL LOCALIZATION SUM IS',F14.6)
 9020 FORMAT(1H0,'NO ROTATION INCREASES ATOMIC POPULATIONS',
     *           ' --- LOCALIZATION ABORTED'/
     *           10X,2HI=,I3,5X,2HJ=,I3)
 9030 FORMAT(5X,8HTHETA = ,G20.10/5X,12HSIN(THETA)= ,F10.7,
     +     15H   COS(THETA)= ,F10.7/5X,29HTOTAL CHANGE TO THIS POINT = ,
     +     G20.10)
 9050 FORMAT(10X,'ITERATION',I4,'   ORBITAL CHANGE=',G20.10)
 9060 FORMAT (/10X,
     +     114HLOCALIZATION HAS BEEN UNSUCESSFUL. PROGRAM WILL RESTART W
     +ITH NEW RANDOM NUMBER AND ROTATION SEQUENCE FOR ORBITALS.)
 9070 FORMAT(1H0,'LOCALIZATION FAILS --- LOCALIZATION ABORTED')
 9080 FORMAT(10X,'LOCALIZATION CONVERGED IN',I4,' ITERATIONS')
 9090 FORMAT(/10X,'THE PIPEK-MEZEY POPULATION LOCALIZED ORBITALS ARE')
 9120 FORMAT(//10X,'THE TRANSFORMATION FROM INITIAL MO-S (ROWS)',
     *             ' TO LOCALIZED MO-S (COLUMNS) IS')
 9130 FORMAT(//10X,'THIS LOCALIZATION HAD',I3,' M.O. S (',
     *       I3,' FROZEN) AND',I3,' BASIS FUNCTIONS')
 9140 FORMAT(10X,'THE FINAL LOCALIZATION SUM IS',F16.6/)
      END
C*MODULE LOCAL   *DECK POPQAT
      SUBROUTINE POPQAT(RIJ,POP,N2,NORB,NATOMS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      DIMENSION RIJ(N2,1),POP(NATOMS,NORB)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      PARAMETER (ONE=1.0D+00, TWO=2.0D+00)
      DATA UHF/8HUHF     /
C
C     COMPUTE MULLIKEN GROSS ATOMIC POPULATIONS
C
      INDX(I,J) = ((MAX(I,J)*(MAX(I,J)-1))/2+MIN(I,J))
      OCC = TWO
      IF (SCFTYP.EQ.UHF) OCC = ONE
      DO 10 I=1,NORB
      II = INDX(I,I)
      DO 10 J=1,NATOMS
   10 POP(J,I) = OCC*RIJ(II,J)
      IF (MASWRK) WRITE(IW,1000)
 1000 FORMAT(/'          MULLIKEN GROSS ATOMIC POPULATIONS')
      CALL PRSQ(POP,NORB,NATOMS,NATOMS)
      IF (MASWRK) WRITE(IW,1001)
 1001 FORMAT(/)
      RETURN
      END
C*MODULE LOCAL   *DECK POLNMM
      SUBROUTINE POLNMM
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXAO=8192)
C
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /OPTLOC/ CVGLOC,MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,
     *                MOOUTA(MXAO),MOOUTB(MXAO)
C
      L0 = NQMT
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
      LNA = NA - NOUTA
C
C     PARTITION FAST MEMORY
C
      CALL VALFM(LOADFM)
      LVA  = 1     + LOADFM
      LVX  = LVA  + L3
      LARR  = LVX  + L3
      LWRK  = LARR + L2
      LWRK2 = LWRK + L1
      LWRK3 = LWRK2+ L1
      LIWRK = LWRK3+ L3
      LCCH0 = LIWRK+ L1
      LCCHX = LCCH0+ 3*NA
      LPOL  = LCCHX+ 3*NA
      LNMOA0= LPOL + 9*LNA
      LMOID0= LNMOA0+ NA
      LXDIP = LMOID0+ 5*NA
      LYDIP = LXDIP + L2
      LZDIP = LYDIP + L2
      LWINT = LZDIP + L2
      LAST  = LWINT + 784*3
C
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      CALL POLNMX(X(LVA),X(LVX),X(LARR),X(LCCH0),X(LCCHX),X(LWRK),
     *            X(LWRK2),X(LWRK3),X(LIWRK),X(LPOL),X(LNMOA0),
     *            X(LMOID0),X(LXDIP),X(LYDIP),X(LZDIP),X(LWINT),
     *            L0,L1,L2,LNA,NA)
C
      CALL RETFM(NEED)
      RETURN
      END
C*MODULE LOCAL   *DECK POLNMX
      SUBROUTINE POLNMX(VA,VX,ARRAY,CCHG,CCHX,WRK,WRK2,WRK3,IWRK,DLPOL,
     *                  NMOA0,MOID0,XDIP,YDIP,ZDIP,WINT,
     *                  L0,L1,L2,LNA,NORB)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL EFLDL,MFRZ,MFRZBK
      LOGICAL MOIDON,EDCOMP,DIPDCM,QADDCM,DEPRNT,ZDO,POLDCM,POLANG
      LOGICAL GOPARR,DSKWRK,MASWRK,POLAPP,KMIDPT,POLDYN
C
      PARAMETER (MXATM=2000, NMO=500, MXAO=8192)
      PARAMETER (ZERO=0.0D+00,THREE=3.0D+00)
      PARAMETER (UNIT=0.52917724924D+00)
      PARAMETER (SMFLD=1.0D-04)
C
      DIMENSION VA(L1,L1), VX(L1,L1), ARRAY(L2)
      DIMENSION CCHG(3,LNA), CCHX(3,LNA), WRK(L1), WRK2(L1), WRK3(L1,L1)
      DIMENSION IWRK(L1),DLPOL(9,LNA),NMOA0(NORB),MOID0(5,NORB),
     *          XDIP(L2),YDIP(L2),ZDIP(L2),WINT(784*3)
C
      COMMON /EDCMP / ZIJ(NMO),ZMO(5,NMO),OCCUP(NMO),DPFREQ(50),
     *                MOIDNO(5,NMO),IJMO(2,NMO),MOIJ(NMO),NMOIJ(NMO),
     *                NMOAT(NMO),NDPFREQ,IPROT(5),NPROT,
     *                MOIDON,EDCOMP,DIPDCM,DEPRNT,QADDCM,ZDO,POLDCM,
     *                POLANG,POLAPP,KMIDPT,POLDYN
      COMMON /EFLDC / EVEC(3),EFLDL
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MFRPAR/ MFRZ,NUMFRZ,NORFRZ,IFRZ(MXAO)
      COMMON /OPTLOC/ CVGLOC,MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,
     *                MOOUTA(MXAO),MOOUTB(MXAO)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /SCFOPT/ CONVHF,MAXIT,MCONV,NPUNCH,NPREO(4)
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      COMMON /XYZPRP/ XP,YP,ZP,
     *                DIPMX,DIPMY,DIPMZ,
     *                QXX,QYY,QZZ,QXY,QXZ,QYZ,
     *                QMXX,QMYY,QMZZ,QMXY,QMXZ,QMYZ,
     *                OXXX,OXXY,OXXZ,OXYY,OYYY,OYYZ,
     *                OXZZ,OYZZ,OZZZ,OXYZ,
     *                OMXXX,OMXXY,OMXXZ,OMXYY,OMYYY,
     *                OMYYZ,OMXZZ,OMYZZ,OMZZZ,OMXYZ
C
      DATA RHF,RMC/8HRHF     ,8HMCSCF   /
      DATA RNONE/8HNONE    /
      DATA ELMOM/8HELMOM   /
C
C----THE DRIVER FOR CALCULATING LMO NUMERIC POLARIZABILITIES----
C    D.R.GARMER, W.J.STEVENS J.PHYS.CHEM. 93, 8263-8270(1989)
C
C   THE ZERO FIELD DIPOLES (IN AO BASIS) WERE CALCULATED BEFORE,
C   WE JUST READ THEM IN AND THEN TRANSFORM TO MO BASIS. THIS IS ALMOST
C   THE SAME AS IN THE PAULIX ROUTINE.
C
C GET LMOS
C
      CALL DAREAD(IDAF,IODA,VA,L1*NA,71,0)
C    SAVE LMOS ON DAF RECORD 280.
C    READ THE FOCK MATRIX, ALPHA AND BETA DENSITY MATRICES AND SAVE THEM
C    FOR THE LATER USE IN STONE ANALYSIS.
C
      CALL DAWRIT(IDAF,IODA,VA,L1*L1,280,0)
      CALL DAREAD(IDAF,IODA,ARRAY,L2,14,0)
      CALL DAWRIT(IDAF,IODA,ARRAY,L2,283,0)
      CALL DAREAD(IDAF,IODA,ARRAY,L2,16,0)
      CALL DAWRIT(IDAF,IODA,ARRAY,L2,281,0)
      IF(SCFTYP.EQ.RHF .OR. SCFTYP.EQ.RMC .OR. CITYP.NE.RNONE)GOTO 120
        CALL DAREAD(IDAF,IODA,ARRAY,L2,20,0)
        CALL DAWRIT(IDAF,IODA,ARRAY,L2,282,0)
 120  CONTINUE
C
      IF (NOUTA.GT.0) THEN
         DO I = 1,LNA
            CALL DCOPY(L1,VA(1,NOUTA+I),1,VA(1,I),1)
         END DO
      END IF
C
C  COPY ZERO FIELD MOIDNO AND NMOAT INTO AUXILIARY ARRAYS
C  TO BE USED SOLELY FOR THE PRINTOUT
C
      CALL ICOPY(NORB,NMOAT,1,NMOA0,1)
      CALL ICOPY(5*NORB,MOIDNO,1,MOID0,1)
C
C   CLEAN UP JUNK FROM THE "VIRTUAL SPACE" OF VA MATRIX
C   AND FILL IT WITH IDENTICAL UNIT VECTORS SO THAT
C   LATER THE OVERLAP CAN BE MORE SAFELY CALCULATED.
C
      CALL VCLR(VA(1,LNA+1),1,L1*(L1-LNA))
      DO I=LNA+1,L1
        VA(1,I)=1.0D+00
      END DO
C
C   CALCULATE CENTROIDS OF CHARGE AND SAVE THE ZERO ELECTRIC FIELD
C   CENTROIDS ON DAF RECORDS 252-254  WRITTEN LATER
C   BACK ON RECORDS 95-97, TO BE USED WITH THE STONE ANALYSIS
C   DURING THE MAKEFP RUN.
C
      DO I = 1,3
         CALL DAREAD(IDAF,IODA,ARRAY,L2,94+I,0)
         CALL DAWRIT(IDAF,IODA,ARRAY,L2,251+I,0)
         DO J = 1,LNA
            CALL TFTRI(CCHG(I,J),ARRAY,VA(1,J),WRK2,1,L1,L1)
         END DO
      END DO
C      WRITE(IW,*)'CCHG:'
C      DO J=1,LNA
C          WRITE(IW,*)J,(CCHG(I,J),I=1,3)
C      END DO
C
C   NOW WE JUST HAVE TO APPLY FIELD IN 3 DIRECTIONS
C
      NPRBAK=NPRINT
      NPUNBK=NPUNCH
      IF(MASWRK) WRITE(IW,9000)
      EFLDL=.TRUE.
      EVEC(1)=ZERO
      EVEC(2)=ZERO
      EVEC(3)=ZERO
C
      NPUNCH=0
      DO 100 IEF=1,3
      EVEC(IEF)=SMFLD
      IF(MASWRK) WRITE(IW,9010) (EVEC(I),I=1,3)
      NPRBAK=NPRINT
      NPRINT=-5
C
      CALL ENERGX
C
C        MAKE SURE DIPOLE INTEGRALS EXIST (EVEN IF NPRINT.EQ.-5).
C        ORIGINAL VERSION DIDN'T ATTEMPT TO CONTROL CENTER OF MOMENT
C        EVALUATION, BUT WHY NOT USE CENTER OF MASS?
C        NOTE, X,Y,Z DIPOLES MUST BE BACK TO BACK TO BACK STORAGE.
C
      CALL CALCOM(XP,YP,ZP)
      CALL PRCALC(ELMOM,XDIP,WINT,3,L2,.FALSE.)
      CALL DAWRIT(IDAF,IODA,XDIP,L2,95,0)
      CALL DAWRIT(IDAF,IODA,YDIP,L2,96,0)
      CALL DAWRIT(IDAF,IODA,ZDIP,L2,97,0)
C
C   LMOLOC USES UNDOCUMENTED NPRINT=-23 FOR MINIMAL PRINTOUT
C
      NPRINT=-23
      IF(SCFTYP.EQ.RHF) THEN
         CALL MOIDM
         CALL DIPLMM
      END IF
      IF (ILOCAL.EQ.1) CALL LMOLOC(ILOCAL)
      IF (ILOCAL.EQ.2) CALL LOCENG
      IF (ILOCAL.EQ.3) CALL LMOLOC(ILOCAL)
C
C GET LMOS
C
      CALL DAREAD(IDAF,IODA,VX,L1*NA,71,0)
      IF (NOUTA.GT.0) THEN
         DO I = 1,LNA
            CALL DCOPY(L1,VX(1,NOUTA+I),1,VX(1,I),1)
         END DO
      END IF
      CALL VCLR(VX(1,LNA+1),1,L1*(L1-LNA))
      DO I=LNA+1,L1
         VX(1,I)=1.0D+00
      END DO
C
C   CALCULATE CENTROIDS OF CHARGE
C
      DO I = 1,3
         CALL DAREAD(IDAF,IODA,ARRAY,L2,94+I,0)
         DO J = 1,LNA
            CALL TFTRI(CCHX(I,J),ARRAY,VX(1,J),WRK2,1,L1,L1)
CCC            CCHX(I,J) = CCHX(I,J) +XYZP(I)
         END DO
      END DO
C
C   KEEP THE ORDER OF MOS IN VX THE SAME AS IN VA -
C   IN CASE THE ORBITAL ORDER CHANGES UNDER THE EXTERNAL FIELD
C   WE HAVE TO SWITCH OFF MO FREEZING IN OVLSEL
C
      MFRZBK=.FALSE.
      IF(MFRZ) THEN
          MFRZBK=MFRZ
          MFRZ=.FALSE.
      END IF
      CALL DAREAD(IDAF,IODA,ARRAY,L2,12,0)
      idum=0
      CALL OVLSEL(VX,WRK2,VA,ARRAY,WRK3,WRK,IWRK,WRK,
     *            IDUM,IDUM,L0,L1,L2,.FALSE.)
      IF(MFRZBK) MFRZ=MFRZBK
C
C   CENTROIDS NEED TO BE REORDERED TOO
C
      CALL ICOPY(L1,WRK,1,IWRK,1)
      CALL REORDR(CCHX,IWRK,LNA,3)
C      WRITE(IW,*)'REORDERED CCHX:'
C     DO J=1,LNA
C         WRITE(IW,*)J,(CCHX(I,J),I=1,3)
C     END DO
      IEFPR=(IEF-1)*3
      DO I=1,LNA
        DLPOL(IEFPR+1,I)=2*(CCHG(1,I)-CCHX(1,I))/SMFLD
        DLPOL(IEFPR+2,I)=2*(CCHG(2,I)-CCHX(2,I))/SMFLD
        DLPOL(IEFPR+3,I)=2*(CCHG(3,I)-CCHX(3,I))/SMFLD
      END DO
      EVEC(IEF)=ZERO
 100  CONTINUE
      EFLDL=.FALSE.
      CALL DAWRIT(IDAF,IODA,DLPOL,LNA*9,251,0)
C
C ----- PRINT OUT POLARIZABILITIES----
C
      IF (MASWRK) THEN
         IF(POLANG) THEN
            WRITE(IW,9020)
         ELSE
            WRITE(IW,9025)
         END IF
      END IF
      DO I=1,LNA
         DO 520 J=1,9
            IF(POLANG) THEN
               DLPOL(J,I)=DLPOL(J,I)*UNIT**THREE
            END IF
  520    CONTINUE
C
C
       ILO=I+NOUTA
       IF (MASWRK) THEN
            IF(NMOA0(ILO).EQ.1) WRITE(IW,9003) I, MOID0(1,ILO)
            IF(NMOA0(ILO).GE.2)
     *               WRITE(IW,9005) I, MOID0(1,ILO),MOID0(2,ILO)
            WRITE(IW,9050)
            WRITE(IW,9060) (DLPOL(J,I),J=1,3)
            WRITE(IW,9080) (DLPOL(J,I),J=4,6)
            WRITE(IW,9100) (DLPOL(J,I),J=7,9)
            ALPHAM=(DLPOL(1,I)+DLPOL(5,I)+DLPOL(9,I))/THREE
            WRITE(IW,9110) ALPHAM
        END IF
      END DO
      NPRINT=NPRBAK
      NPUNCH=NPUNBK
C
C   FILL THE DAF RECORDS 71, 14, 16, 20, 95-7 WITH THE ARRAYS SAVED
C   BEFORE, THEY WILL BE USED IN THE PAULIX ROUTINE
C
      CALL DAREAD(IDAF,IODA,VA,L1*L1,280,0)
      CALL DAWRIT(IDAF,IODA,VA,L1*L1,71,0)
      CALL DAREAD(IDAF,IODA,ARRAY,L2,283,0)
      CALL DAWRIT(IDAF,IODA,ARRAY,L2,14,0)
      CALL DAREAD(IDAF,IODA,ARRAY,L2,281,0)
      CALL DAWRIT(IDAF,IODA,ARRAY,L2,16,0)
      IF(SCFTYP.EQ.RHF .OR. SCFTYP.EQ.RMC .OR. CITYP.NE.RNONE) GOTO 130
         CALL DAREAD(IDAF,IODA,ARRAY,L2,282,0)
         CALL DAWRIT(IDAF,IODA,ARRAY,L2,20,0)
 130  CONTINUE
      DO I = 1,3
         CALL DAREAD(IDAF,IODA,ARRAY,L2,251+I,0)
         CALL DAWRIT(IDAF,IODA,ARRAY,L2,94+I,0)
      END DO
      RETURN
C
 9000 FORMAT(/1X,'*** NUMERIC COMPUTATION OF LOCALIZED ORBITAL ',
     *       'POLARIZABILITIES ***'/5X,
     *'D.R.GARMER AND W.J.STEVENS J.PHYS.CHEM. 93, 8263-8270(1989)')
 9003 FORMAT(/1X,'LMO NUMBER ',I4,' ALPHA POLARIZABILITY ',
     *        'FOR CORE OR LONE PAIR ON ATOM',I4)
 9005 FORMAT(/1X,'LMO NUMBER ',I4,' ALPHA POLARIZABILITY ',
     *        'FOR BOND BETWEEN ATOM',I4,' AND ATOM',I4)
 9010 FORMAT(/1X,'APPLIED ELECTRIC FIELD: X=',F7.4,' Y=',F7.4,
     *       ' Z=',F7.4/)
 9020 FORMAT(/10X,35(1H-)/
     *        10X,' LOCALIZED ALPHA POLARIZABILITIES '/
     *        10X,'       IN ANGSTROMS**3            '/
     *        10X,35(1H-)/)
 9025 FORMAT(//10X,35(1H-)/
     *        10X,' LOCALIZED ALPHA POLARIZABILITIES '/
     *        10X,'       IN ATOMIC UNITS            '/
     *        10X,35(1H-)/)
 9050 FORMAT(22X,'UX',13X,'UY',13X,'UZ')
 9060 FORMAT(10X,     ' UX ',3F15.9)
 9080 FORMAT(10X,     ' UY ',3F15.9)
 9100 FORMAT(10X,     ' UZ ',3F15.9)
 9110 FORMAT(/10X,     ' MEAN ALPHA POLARIZABILITY = ',3F15.9)
      END
C
C*MODULE LOCAL   *DECK DIRLMO
C> @brief      This routine drives LMOs orientation.
C>
C> @author     Joe Ivanic
C>             -2008
C>
C> @details    This code orients LMOs on each atom
C>             by maximizing sum of fourth powers
C>             of all off-diagonal density matrix elements
C>             so that a select off-diagonal elements are
C>             as large as possible.
C>
C> @date December 14, 2012-Aaron West
C> -Restricted orientation for ORMAS wavefunctions.
C>
      SUBROUTINE DIRLMO
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION METHOD,FINALCI
C
      PARAMETER (MXATM=2000, MXAO=8192, MXNORO=250)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL CANONC,FCORE,FORS,EKT,LINSER,FDIRCT,QCORR
C
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIMFCC(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /OPTLOC/ CVGLOC,MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,
     *                MOOUTA(MXAO),MOOUTB(MXAO)
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWRDMC,NORBMC,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DATA UHF/8HUHF     /, CHECK/8HCHECK   /
      DATA ORMAS/8HORMAS   /
C
C   ROUTINE TO ORIENT A SET OF LOCALIZED ORBITALS:
C
C   1/  THE LOCALIZED ORBITALS ARE ANALYSED TO DETERMINE WHICH ARE
C       QUASI-ATOMIC.  THIS IS DONE BY DETERMINING THE MULLIKEN
C       POPULATIONS AND IS LIKE THE METHOD IN MOIDM WHICH WAS WRITTEN
C       BY JAN JENSEN.
C   2/  THESE QASI-AO'S ARE THEN DIRECTED BY SIMPLIFICATION OF THE
C       DENSITY MATRIX USING THE FOURTH POWER METHOD. ONLY ROTATIONS
C       BETWEEN ORBITALS ON THE SAME ATOM ARE CONSIDERED. ONLY THE
C       ALPHA ORBITALS ARE DIRECTED.
C   3/  ORIENTED DENSITY IS PRINTED OUT, FOR ALL ORBITALS NOT FROZEN
C       IN THE LOCALIZATION.
C   4/  BONDING ANALYSIS IS PERFORMED AND PRINTED OUT.
C   5/  ALL OCCUPIED ORBITALS ARE PRINTED OUT.
C   6/  ORBITALS AND DENSITY WRITTEN OUT TO .F10 AND .DAT.
C
C   REFERENCE FOR THE METHOD WILL COME SOON,
C   JOE IVANIC AND KLAUS RUEDENBERG.
C   CODE WRITTEN BY J. IVANIC.
C
C   CVGLOC USED AS LOCALIZATION CRITERION IS USED AS CRITERION IN
C          ORIENTATION.
C   MAXLOC USED FOR MAXIMUM NUMBER OF CYCLES IN LOCALIZATION METHODS
C          WHICH ARE NOT EDMISTON-RUEDENBERG.  IT IS USED HERE FOR
C          MAXIMUM NUMBER OF SWEEPS IN ORIENTATION.  DEFAULT VALUE
C          FOR MAXLOC IN LOCALIZATION METHODS IS 250.  IF DEFAULT
C          VALUE USED THEN DEFAULT VALUE FOR ORIENTATION IS 100,000
C          OTHERWISE USE READ IN VALUE.
C
C   READ IN:
C       71: LOCALIZED ORBITALS
C      285: LOCALIZED DENSITY
C   WRITTEN OUT:
C      286: ORIENTED ORBITALS
C      287: ORIENTED DENSITY
C
      NDAFL =  71
      NDADL = 285
      NDAGL = 286
      NDAHL = 287
C
C
      IF (MASWRK) WRITE(IW,9000)
C
C     DIE OFF IF ORMAS + NSPACE>1 + NOT ILOCAL=4.
C
      IF(ILOCAL.NE.4.AND.CISTEP.EQ.ORMAS.AND.NSPACE.GT.1) THEN
        IF(MASWRK) WRITE(IW,9005)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C
      IF (MAXLOC.EQ.250) THEN
         MITER=100000
      ELSE
         MITER=MAXLOC
      END IF
C                      THRESHOLD FOR INSIGNIFICANT BOND ORDERS:
      PRITOL = 0.02D+00
C
C  DETERMINE SIZES OF ORBITAL SPACES.
C
      IPASS = 1
      CALL LMOPSI(IPASS,MCORE,MDOC,MACT,NUMLOC)
      NOUT = NOUTA
C
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
      M1 = NUMLOC - NOUT
      M2 = (M1*M1+M1)/2
      M3 = M1*M1
C
C  MEMORY REQUIREMENTS.
C
      CALL VALFM(LOADFM)
      LCLMO  = LOADFM + 1
      LRLMO  = LCLMO  + L3
      LSTRI  = LRLMO  + L3
      LTRAN  = LSTRI  + L2
      LDEN   = LTRAN  + M3
      LIWHI  = LDEN   + M2
      LINAT  = LIWHI  + M1 + NAT
      LIATB  = LINAT  + M1 + NAT
      LATMU  = LIATB  + NAT*M1
      LMAPT  = LATMU  + NAT*M1
      LIATM  = LMAPT  + M1
      LMAPT2 = LIATM  + NAT*M1
      LMAPT3 = LMAPT2 + M1
      LAST   = LMAPT3 + L1
      NEED1 = LAST - LOADFM -1
      IF (MASWRK) WRITE(IW,9010) NEED1
      CALL GETFM(NEED1)
      IF(EXETYP.EQ.CHECK) GO TO 800
C
C  PRINT OUT NUMBER OF OCCUPIED AND CORE ORBITALS.
C
      IF (MASWRK) WRITE(IW,9020) NUMLOC,MCORE
      IF (MASWRK.AND.SCFTYP.EQ.UHF) WRITE(IW,9025)
C
C  READ LOCALIZED ORBITALS AND LOCALIZED DENSITY.
C
      CALL DAREAD(IDAF,IODA,X(LCLMO),L3,NDAFL,0)
      CALL DAREAD(IDAF,IODA,X(LDEN) ,M2,NDADL,0)
C
C  PRINT OUT THE LIST OF FROZEN ORBITALS. THESE WILL NOT
C  BE INCLUDED IN THE ORIENTATION ANALYSIS.
C
      IF (MASWRK) THEN
         WRITE(IW,9030) NOUTA,(MOOUTA(I),I=1,NOUTA)
         WRITE(IW,9040)
      END IF
C
C  REORDER ORBITALS SUCH THAT FROZEN ONES OCCUR FIRST.
C
      CALL GETMAP(NUMLOC,X(LCLMO),X(LRLMO),L1)
C
C  IDENTIFY WHICH ORBITALS ARE QUASI-ATOMIC AND REORDER SO THAT
C  THESE OCCUR FIRST IN THE UNFROZEN SET.
C
      NATS = NAT
      CALL DIMOID(X(LDEN),X(LRLMO),X(LCLMO),X(LSTRI),X(LATMU),X(LIATM),
     *            X(LIWHI),X(LMAPT),X(LINAT),X(LIATB),
     *            L1,L2,M1,M2,NATS,NOSI,NCAT,NSWE,
     *            X(LMAPT2))
C
C  LMAPT2 IS NOW SETUP FOR USE IN ORIEN.
C  LMAPT2 CONTAINS ACTIVE INDICES IN ACTIVE INDEX POSITIONS.
C  LMAPT2 GETS USED AND THEN TRASHED IN ORIEN; SO SAVE A COPY.
C
      CALL ICOPY(M1,X(LMAPT2),1,X(LMAPT),1)
C
C  NOW TO PRINT OUT THE CONVERGENCE CRITERION FOR THE ANGLE, AND
C  THEN PERFORM THE ORIENTATION PROCEDURE.
C
      IF (MASWRK) WRITE(IW,9050) M1-NOSI,CVGLOC,NSWE
      CALL ORIEN(IW,NCAT,M1,X(LINAT),X(LDEN),X(LTRAN),CVGLOC,MITER,
     *           X(LMAPT2),MSTA,NSPACE,CISTEP,MCORE)
C     NOTE:  LMAPT2 NOW CONTAINS NON-CUM. REORDER FROM OCCUPATIONS.
C
C  NOW TO PRINT OUT THE DENSITY MATRIX FOR NON-FROZEN ORBITALS.
C
      IF (MASWRK) WRITE(IW,9060) PRITOL
      CALL ORIPRI(IW,NCAT,NATS,M1,X(LINAT),X(LDEN),X(LIWHI),X(LIATB),
     *  NOSI,PRITOL)
C
C  PRINT OUT THE BONDING ANALYSIS.
C
      IF (MASWRK) WRITE(IW,9065)
      CALL ORIANAL(IW,NCAT,NATS,M1,X(LINAT),X(LDEN),X(LIATB),NOSI)
C
C  MAKE NEW ORBITAL BASIS COEFFICIENTS.
C
      CALL MRARBR(X(LRLMO+NOUTA*L1),L1,L1,M1,X(LTRAN),M1,M1,
     *            X(LCLMO+NOUTA*L1),L1)
C
C  PRINT OUT FINAL ORIENTED ORBITALS TO GAMESS OUTPUT FILE..
C
      IF (MASWRK) THEN
         WRITE(IW,9070)
         CALL PRSQL(X(LCLMO),NUMLOC,L1,L1)
      END IF
C
C  PRINT OUT ORBITALS TO .DAT FILE.
C
      IF(MASWRK) THEN
         WRITE(IP,9080)
         CALL PUSQL(X(LCLMO),NUMLOC,L1,L1)
         WRITE(IP,9085)
      END IF
C
C  WRITE OUT ORIENTED ORBITALS TO NDAGL = 286
C
      CALL DAWRIT(IDAF,IODA,X(LCLMO),L1*L1,NDAGL,0)
C
C  WRITE OUT ORIENTED DENSITY TO NDAHL = 287
C
      CALL DAWRIT(IDAF,IODA,X(LDEN),M2,NDAHL,0)
C
C  FINISH UP.
C
  800 CONTINUE
      CALL RETFM(NEED1)
      IF (MASWRK) WRITE(IW,9075)
C
C  FOR BOTH CASSCF AND ORMAS FOR ILOCAL=4,
C  TAKE CARE OF ORBITAL AND ATOM REORDERINGS.
C  -----RIGHT NOW, WE ONLY CARE ABOUT REORDERINGS GIVEN BY LMAPT AND LMAPT2.
C
      IF(EXETYP.NE.CHECK.AND.ILOCAL.EQ.4)
     *  CALL MALMQ_REORDER2(X(LMAPT),X(LMAPT2),X(LMAPT3),
     *                      MCORE,M1,L1,MASWRK)
C
C  FINISH UP2
C
      CALL TIMIT(1)
      RETURN
C
 9000 FORMAT(/10X,50(1H-)/
     * 10X,'IVANIC-RUEDENBERG QUASI-ATOMIC ORBITAL ORIENTATION'/
     * 10X,50(1H-))
 9005 FORMAT(/1X,'CISTEP ORMAS ONLY ALLOWED WITH ILOCAL=4 OPTION.')
 9010 FORMAT(/1X,'THIS ORIENTATION REQUIRES',I10,' WORDS OF MEMORY.')
 9020 FORMAT(/1X,'THIS WAVEFUNCTION HAS',I4,' OCCUPIED ORBITALS',
     *       ' OF WHICH',I4,' ARE CORE.')
 9025 FORMAT(1X,'ONLY ALPHA LOCALIZED ORBITALS WILL BE ORIENTED')
 9030 FORMAT(1X,'THERE WERE',I3,' ORBITALS FROZEN IN THE ',
     * 'LOCALIZATION.  THESE ARE: '/
     *      (1X,15I5))
 9040 FORMAT(1X,'THEY WILL BE MOVED TO THE BEGINNING OF THE ',
     * 'ORBITAL LIST'/1X,'AND OMITTED FROM THE ORIENTATION ANALYSIS.')
 9050 FORMAT(/1X,'***********************************************'
     *       /1X,'    ORIENTING FIRST ',I3,' NON-FROZEN ORBITALS    '
     *       /1X,'***********************************************'
     *  //1X,'ROTATION ANGLES WILL BE CONVERGED TO ',1P,E9.2,0P,
     *  /1X,'NUMBER OF ANGLES IN A SWEEP = ',I6)
 9060 FORMAT(
     *    1X,'----------------------------------------------------'/
     *    1X,'DENSITY MATRIX FOR QUASI-ATOMIC AND BONDING ORBITALS'/
     *    1X,'----------------------------------------------------'/
     *    1X,'ONLY ELEMENTS BIGGER THAN ',F4.2,' ARE PRINTED'/
     *    1X,'BE SURE TO CHECK ORBITAL PHASES OF THE -ORIENTED',
     *       ' ORBITALS- USING MACMOLPLT.'/
     *    1X,'IF ANY ORBITAL HAS AN UNDESIRED PHASE, CHANGE THE',
     *       ' SIGN OF ITS ENTIRE -ROW-'/
     *    1X,'AND -COLUMN- IN THE DENSITY MATRIX BELOW, THUS LEAVING',
     *       ' DIAGONAL POPULATIONS'/
     *    1X,'AS POSITIVE NUMBERS.')
 9065 FORMAT(
     *   /1X,'----------------'
     *   /1X,'BONDING ANALYSIS'
     *   /1X,'----------------')
 9070 FORMAT(//10X,'ORIENTED LOCALIZED ORBITALS')
 9075 FORMAT(1X,'... DONE WITH ORIENTATION ...')
 9080 FORMAT('ORIENTED LOCALIZED ORBITALS'/' $VEC')
 9085 FORMAT(' $END')
C
      END
C
C*MODULE LOCAL   *DECK GETMAP
      SUBROUTINE GETMAP(NUMLOC,CLMO,RLMO,L1)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION CLMO(L1,L1),RLMO(L1,L1)
C
      PARAMETER (MXAO=8192)
C
      COMMON /OPTLOC/ CVGLOC,MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,
     *                MOOUTA(MXAO),MOOUTB(MXAO)
C
C  ROUTINE TO DETERMINE WHICH ALPHA ORBITALS HAVE BEEN LOCALIZED,
C  AND REORDER THE ORBITALS SO THAT FROZEN ONES OCCUR FIRST, AND
C  VIRTUAL LAST.  THIS HAS BEEN RIPPED OUT OF ROUTINE LOCSET.
C
      NOUT = NOUTA
      CALL VCLR(RLMO,1,L1*L1)
C
C     PUT THE ORBITALS WHICH ARE TO BE FROZEN FIRST...
C
      NMO=0
      DO 120 J=1,NUMLOC
         DO 110 I=1,NOUT
            IF(MOOUTA(I).EQ.J) THEN
                  NMO = NMO+1
                  CALL DCOPY(L1,CLMO(1,J),1,RLMO(1,NMO),1)
                  GO TO 120
            END IF
  110    CONTINUE
  120 CONTINUE
C
C     ...THEN PUT IN THE ORBITALS TO BE LOCALIZED...
C
      LL=0
      DO 220 J=1,NUMLOC
         DO 210 I=1,NOUT
            IF(MOOUTA(I).EQ.J) GO TO 220
  210    CONTINUE
         NMO = NMO+1
         CALL DCOPY(L1,CLMO(1,J),1,RLMO(1,NMO),1)
         LL = LL+1
  220 CONTINUE
C
C     ...AND FINISH UP WITH THE VIRTUAL SPACE.
C
      LVIRT = (L1-NUMLOC)*L1
      CALL DCOPY(LVIRT,CLMO(1,NMO+1),1,RLMO(1,NMO+1),1)
C
      RETURN
      END
C
C*MODULE LOCAL   *DECK DIMOID
C> @brief      This routine determines atomic populations.
C>
C> @author     Joe Ivanic
C>             -2008
C>
C> @details    ROUTINE TO DETERMINE ATOMIC MULLIKEN POPULATIONS
C>             FOR EACH NON-FROZEN LOCALIZED MO.
C>             LMO'S ARE THEN SORTED AS EITHER QUASI-ATOMIC OR BOND MO'S.
C>             QUASI-ATOMIC ORBITALS ARE PLACED FIRST AND
C>             BOND MO'S PLACED LAST IN THE NON-FROZEN LMO LIST.
C>
C> @date December 17, 2012-Aaron West
C> -Added tracking for MO swaps for use in Malmqvist procedure.
C>
C> @param MAPT2   is the array used for tracking MO swaps.
C>
      SUBROUTINE DIMOID(DEN,RLMO,SSQU,STRI,ATMU,IATM,IWHI,MAPT,INAT,
     *                  IATB,L1,L2,M1,M2,NATS,NOSI,NCAT,NSWE,
     *                  MAPT2)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION RLMO(L1,L1),SSQU(L1,L1),STRI(L2),ATMU(NATS,M1),DEN(M2)
      DIMENSION IATM(NATS,M1),IWHI(M1+NATS),MAPT(M1),INAT(M1+NATS)
      DIMENSION IATB(NATS,M1)
      DIMENSION MAPT2(M1)
C
      PARAMETER (MXATM=2000, MXSH=5000, MXGTOT=20000, MXAO=8192)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OPTLOC/ CVGLOC,MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,
     *                MOOUTA(MXAO),MOOUTB(MXAO)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNLAB/ TITLE(10),A(MXATM),B(MXATM),BFLAB(MXAO)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      DATA BNDANA/8HBONDANAL/
C
C   ROUTINE TO DETERMINE ATOMIC MULLIKEN POPULATIONS FOR
C   EACH NON-FROZEN LOCALIZED MO.
C   LMO'S ARE THEN SORTED AS EITHER QUASI-ATOMIC OR BOND MO'S.
C   QUASI-ATOMIC ORBITALS ARE PLACED FIRST AND BOND MO'S PLACED
C   LAST IN THE NON-FROZEN LMO LIST.
C
      TOLR = 0.30D+00
      NUMLOC = M1+NOUTA
C
      CALL DAREAD(IDAF,IODA,STRI,L2,12,0)
      CALL CPYTSQ(STRI,SSQU,L1,1)
C
      DO 920 II=1,M1
         INAT(II) = 0
  920 CONTINUE
C
      IF (MASWRK) THEN
         WRITE(IW,8000)
         WRITE(IW,8010)
      END IF
C
      NST = 1
 2000 CONTINUE
      NEND = MIN(NAT,NST+8)
C
      IF (MASWRK) THEN
         WRITE(IW,9000) (I,A(I),I=NST,NEND)
         WRITE(IW,9005)
      END IF
C
      DO 900 IO = NOUTA+1,NUMLOC
         IZ = IO - NOUTA
         DO 895 II=NST,NEND
            ATMU(II,IZ) = 0.0D+00
            IATM(II,IZ) = 0
  895    CONTINUE
         IFUNC = 0
         DO 890 ISHELL = 1,NSHELL
            IAT = KATOM(ISHELL)
            IST = KMIN(ISHELL)
            IEN = KMAX(ISHELL)
            DO 880 INO = IST,IEN
               IFUNC = IFUNC + 1
               IF (IAT.LT.NST.OR.IAT.GT.NEND) GOTO 880
               ZINT  = 0.0D+00
               DO 870 II = 1,L1
                  ZINT = ZINT + RLMO(II,IO)*SSQU(II,IFUNC)
  870          CONTINUE
               ATMU(IAT,IZ) = ATMU(IAT,IZ) + RLMO(IFUNC,IO)*ZINT
  880       CONTINUE
  890    CONTINUE
         IF (MASWRK) WRITE(IW,9010) IZ,(ATMU(II,IZ),II=NST,NEND)
C
C              ORIENTATION AFTER MCSCF WILL HAVE A NUMBER OF SCF-LIKE
C              IN THE VALENCE CLOSED SHELL SPACE, THIS COUNTS ORBITALS
C              ON MORE THAN ONE CENTER (INAT IS THE CENTER COUNTER)..
C
         IF(RUNTYP.NE.BNDANA) THEN
            DO IA=NST,NEND
               IF (ATMU(IA,IZ).GT.TOLR) THEN
                  INAT(IZ) = INAT(IZ) + 1
                  IND = INAT(IZ)
                  IATM(IND,IZ) = IA
               END IF
            ENDDO
         END IF
  900 CONTINUE
C
      NST = NST + 9
      IF (NEND.LT.NAT) GOTO 2000
C
C         BONDING ANALYSIS SHOULD FORCE A SINGLE ATOM TO BE CHOSEN
C
      IF(RUNTYP.EQ.BNDANA) THEN
         DO IO = NOUTA+1,NUMLOC
            IZ = IO - NOUTA
            IA = IDAMAX(NATS,ATMU(1,IZ),1)
            INAT(IZ)=1
            IATM(1,IZ)=IA
         ENDDO
      END IF
C
      IF (MASWRK) THEN
         WRITE(IW,9015) TOLR
         WRITE(IW,9020)
      END IF
C
      NOSI = 0
      DO 700 II=1,M1
         NO=0
         DO 720 JJ=1,NAT
            IF (IATM(JJ,II).EQ.0) GOTO 740
            NO = NO + 1
  720    CONTINUE
  740    CONTINUE
         IF (NO.GT.1.OR.NO.EQ.0) THEN
            NOSI = NOSI + 1
            IWHI(NOSI) = II
         END IF
        IF (MASWRK)
     *     WRITE(IW,9030) II,(IATM(J,II),A(IATM(J,II)),J=1,NO)
  700 CONTINUE
C
      IF (MASWRK) THEN
         WRITE(IW,9035) NOSI
         IF (NOSI.GT.0) THEN
            WRITE(IW,9040) (IWHI(I),I=1,NOSI)
            WRITE(IW,9045)
         ELSE
            WRITE(IW,9050)
         END IF
      END IF
C
      CALL DCOPY(L1*L1,RLMO,1,SSQU,1)
      CALL DCOPY(M2,DEN,1,STRI,1)
C
      IP2 = NOUTA
      IS2 = M1+NOUTA-NOSI
      DO 695 II=1,NAT
         INAT(II) = 0
  695 CONTINUE
C
      DO 690 IAT=1,NAT
         DO 680 IORB=1,M1
            IP1 = IORB + NOUTA
            IF (IATM(1,IORB).NE.IAT) GOTO 680
            IF (IATM(2,IORB).NE.0) GOTO 680
            INAT(IAT) = INAT(IAT) + 1
            IP2 = IP2 + 1
C--------------------------------------------------------------
C           ORMAS ADDITION FOR TRACKING
C           NOTES:  STORE AS ACTIVE INDICES IN ACTIVE POSITIONS.
            MAPT2(IP2-NOUTA)=IP1-NOUTA
C---------------------------------------------------------------
            CALL DCOPY(L1,SSQU(1,IP1),1,RLMO(1,IP2),1)
            CALL ICOPY(NAT,IATM(1,IORB),1,IATB(1,IP2-NOUTA),1)
            MAPT(IORB) = IP2-NOUTA
  680    CONTINUE
         DO 670 IORB=1,NOSI
            IS1 = IWHI(IORB) + NOUTA
            IF (IAT.EQ.NAT.AND.IATM(1,IWHI(IORB)).EQ.0) GOTO 675
            IF (IATM(1,IWHI(IORB)).NE.IAT) GOTO 670
  675       CONTINUE
            IS2 = IS2 + 1
            CALL DCOPY(L1,SSQU(1,IS1),1,RLMO(1,IS2),1)
            CALL ICOPY(NAT,IATM(1,IS1-NOUTA),1,IATB(1,IS2-NOUTA),1)
            MAPT(IWHI(IORB)) = IS2-NOUTA
  670    CONTINUE
  690 CONTINUE
C
      IJ=0
      DO 650 I=1,M1
         IMAP = MAPT(I)
         DO 640 J=1,I
            IJ=IJ+1
            JMAP = MAPT(J)
            IN1 = MAX(IMAP,JMAP)
            IN2 = MIN(IMAP,JMAP)
            IJMAP = (IN1*IN1-IN1)/2 + IN2
            DEN(IJMAP) = STRI(IJ)
  640    CONTINUE
  650 CONTINUE
C
      DO 630 II=1,NAT
         IWHI(II) = INAT(II)
  630 CONTINUE
C
      NSWE = 0
      NCAT = 0
      LASP = 1
      NLAST = 0
      DO 620 II=1,NAT
         NSWE = NSWE + (IWHI(II)*(IWHI(II)-1))/2
         IF (IWHI(II).EQ.0) GOTO 620
         NCAT = NCAT + 1
         INAT(NCAT) = LASP + NLAST
         LASP = INAT(NCAT)
         NLAST = IWHI(II)
         IWHI(NCAT) = II
  620 CONTINUE
C
      DO 610 II=1,NOSI
         NCAT = NCAT + 1
         INAT(NCAT) = LASP + NLAST
         LASP = INAT(NCAT)
         NLAST = 1
         IWHI(NCAT) = 0
  610 CONTINUE
C
      RETURN
C
 8000 FORMAT(/1X,'** MULLIKEN ATOMIC POPULATIONS FOR EACH NON-FROZEN ',
     *       'LOCALIZED ORBITAL **')
 8010 FORMAT(1X,'POPULATIONS SUM TO 1 E- PER ORBITAL, AND SO ARE',
     *          ' STRICTLY FOR THE'/
     *       1X,'PURPOSE OF ASSIGNING ORBITALS TO ATOMS OR BONDS.')
 9000 FORMAT(/3X,'ATOM',2X,100(I2,1X,A4))
 9005 FORMAT(1X,'LMO')
 9010 FORMAT(1X,I3,3X,100F7.3)
 9015 FORMAT(/1X,'** ATOMIC POPULATIONS GREATER THAN ',F4.2,
     *   ' ARE CONSIDERED MAJOR **')
 9020 FORMAT(/2X,'LMO',3X,'MAJOR CONTRIBUTIONS FROM ATOM(S)')
 9030 FORMAT(2X,I3,2X,100(I2,1X,A2,2X))
 9035 FORMAT(/1X,'NO OF LMOS INVOLVING MORE THAN ONE ATOM =',I3)
 9040 FORMAT(1X,'THESE ARE LMOS :',100I3)
 9045 FORMAT(
     *1X,'THESE WILL BE MOVED TO THE END OF THE NON-FROZEN LMO LIST'/
     *1X,'AND REMOVED FROM THE ORIENTATION PROCEDURE.'/
     *1X,'REMAINING ORBITALS WILL BE REORDERED ACCORDING TO WHICH ATOM'/
     *1X,'THEY BELONG TO, I.E. LMOS ON ATOM 1 COME FIRST, ETC..')
 9050 FORMAT(1X,
     * 'LMOS WILL BE REORDERED ACCORDING TO WHICH ATOM THEY BELONG TO'/
     * 1X,'I.E. LMOS ON ATOM 1 COME FIRST, ETC..')
C
      END
C
C*MODULE LOCAL   *DECK ORIEN
C> @brief      This routine directs atomic orbitals in orientation.
C>
C> @author     Joe Ivanic
C>             -2008
C>
C> @details    DIRECTS ATOMIC ORBITALS SUCH THAT THEY ARE BOND-ORIENTED.
C>             TAKES A DENSITY MATRIX, EXPRESSED IN TERMS OF
C>             ATOMIC ORBITALS, AND REFINES IT AS FOLLOWS:
C>             ORBITALS ON EACH ATOM ARE ROTATED SUCH THAT
C>             THE OFF-DIAGONAL INTER-ATOMIC BLOCKS CONTAIN
C>             1) AS FEW LARGE ELEMENTS AS POSSIBLE,
C>             2) AS MANY NEAR-ZERO ELEMENTS AS POSSIBLE.
C>
C> @date December 14, 2012-Aaron West
C> -Restricted orientation for ORMAS wavefunctions.
C>
C> @param MAPT2        currently contains the back-mapping
C>                     of orbital re-orderings from DIMOID.
C>                     It is used to identify orbitals from
C>                     different ORMAS groups and keep
C>                     wavefunction invariance.
C>                     On exit, it will contain occupation
C>                              reorderings.
C> @param MSTA         contains the starting orbitals for each
C>                     ORMAS group, or subspace.
C> @param NSPACE indicates the number of ORMAS groups.
C> @param CISTEP indicates the kind of CI converger.
C> @param MCORE  indicates the number of chemical core orbitals.
C>
C     --------------------------------------------------------------
      SUBROUTINE ORIEN(IW,NATOT,NTOTORB,NATORB,P,T,CRIT,MXITER,
     *                 MAPT2,MSTA,NSPACE,CISTEP,MCORE)
C     ---------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION NATORB(NATOT),P(NTOTORB*(NTOTORB+1)/2)
      DIMENSION T(NTOTORB,NTOTORB)
      DIMENSION MSTA(NSPACE),MAPT2(NTOTORB)
      LOGICAL GOPARR,DSKWRK,MASWRK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C    DIRECTS ATOMIC ORBITALS SUCH THAT THEY ARE BOND-ORIENTED.
C    TAKES A DENSITY MATRIX, EXPRESSED IN TERMS OF ATOMIC ORBITALS,
C    AND REFINES IT AS FOLLOWS:
C    ORBITALS ON EACH ATOM ARE ROTATED SUCH THAT THE OFF-DIAGONAL
C    INTER-ATOMIC BLOCKS CONTAIN 1) AS FEW LARGE ELEMENTS AS POSSIBLE,
C    AND 2) AS MANY NEAR-ZERO ELEMENTS AS POSSIBLE.
C
C    *  IW    = UNIT WHERE ANY OUTPUT IS WRITTEN TO.
C    *  NATOT = NUMBER OF CATEGORIES OF ORBITALS.
C    *  NTOTORB = TOTAL NUMBER OF ORBITALS.
C    *  NATORB(I) = WHERE THE VALENCE ATOMIC ORBS OF CATEGORY I BEGIN.
C    *  P IS DENSITY MATRIX, STORED IN LOWER TRIANGLE FORM.
C       ORBITALS SHOULD OCCUR AT THE BEGINNING.
C    *  T IS THE RETURNED TRANSFORMATION MATRIX FOR THE ORBITALS.
C    *  CRIT = ROTATION EXECUTION THRESHOLD.  IE. FOR A PAIR OF
C       ORBITALS TO BE UPDATED, THE ABSOLUTE VALUE OF THE ANGLE MUST
C       BE LARGER THAN CRIT (I LIKE THE VALUE OF 1.0D-06)
C       -CRIT- IS OBTAINED FROM THE INPUT PARAMETER -CVGLOC-
C    *  MXITER = MAXIMUM NUMBER OF SWEEPS.  THIS CODE FLIES ALONG
C       SO MAKE IT BIG, E.G. 100,000 OR MAGNITUDES BIGGER.
C
C-----------------------------------------------------------------
C     ORMAS ADDITION
      DATA ORMAS/8HORMAS   /
C-----------------------------------------------------------------
C
      ITER = 0
      CALL INITT(T,NTOTORB)
C
C    LOOP OVER ALL ATOMS
C
  100 CONTINUE
      ITER = ITER + 1
      NUMROT = 0
      DO 9000 IATOM=1,NATOT
C
C     LOOP OVER ALL PAIRS OF AOS ON ATOM IATOM.
C
         ILAST = NTOTORB
         IF (IATOM.NE.NATOT) ILAST=NATORB(IATOM+1)-1
C
         DO 8000 IAOI=NATORB(IATOM),ILAST
C-----------------------------------------------------------------
C           ORMAS ADDITION
            IF(CISTEP.EQ.ORMAS) THEN
            DO ISPACE=1,NSPACE
            IF(MAPT2(IAOI)+MCORE.GE.MSTA(ISPACE).AND.
     *         MAPT2(IAOI)+MCORE.LE.MSTA(ISPACE+1)-1) ISAVGRP=ISPACE
            ENDDO
            ENDIF
C-----------------------------------------------------------------
            DO 7000 IAOJ = IAOI+1,ILAST
C-----------------------------------------------------------------
C              ORMAS ADDITION
               IF(CISTEP.EQ.ORMAS) THEN
               IF(MAPT2(IAOJ)+MCORE.LT.MSTA(ISAVGRP).OR.
     *            MAPT2(IAOJ)+MCORE.GT.MSTA(ISAVGRP+1)-1) GO TO 7000
               ENDIF
C-----------------------------------------------------------------
C
               R2 = 0.0D+00
               R3 = 0.0D+00
C
               DO 6000 INOTA=1,NATOT
                  IF (INOTA.EQ.IATOM) GOTO 6000
                  ILAST2 = NTOTORB
                  IF (INOTA.NE.NATOT) ILAST2=NATORB(INOTA+1)-1
C
                  DO 5000 IK=NATORB(INOTA),ILAST2
                     IMAI=MAX(IK,IAOI)
                     IMII=MIN(IK,IAOI)
                     IMAJ=MAX(IK,IAOJ)
                     IMIJ=MIN(IK,IAOJ)
                     IKI=(IMAI*(IMAI-1))/2 + IMII
                     IKJ=(IMAJ*(IMAJ-1))/2 + IMIJ
                     PIKI=P(IKI)
                     PIKJ=P(IKJ)
                     PIKI2 = PIKI*PIKI
                     PIKJ2 = PIKJ*PIKJ
                     PIKIJ = PIKI*PIKJ
C
                     R2 = R2 + PIKI2*PIKI2
     *                       - 6.0D+00*PIKI2*PIKJ2
     *                       + PIKJ2*PIKJ2
                     R3 = R3 + PIKI2*PIKIJ - PIKJ2*PIKIJ
C
 5000             CONTINUE
 6000          CONTINUE
C
               R2 = (R2/4.0D+00)
               Q = SQRT(R2*R2 + R3*R3)
               IF (Q.LT.1.0D-08) GO TO 7000
               THETA = (ATAN2((R3/Q),(R2/Q)))/4.0D+00
C
C    CHECK IF THE ROTATION IS WORTH EXECUTING.
C
               IF (ABS(THETA).LT.CRIT) GOTO 7000
C
C    NOW HAVE THE ANGLE, THETA, HAVE TO ROTATE DENSITY MATRIX
C    AND UPDATE THE TRANSFORMATION T.
C
               NUMROT = NUMROT + 1
               A = COS(THETA)
               B = -SIN(THETA)
               CALL ROT1INT(NTOTORB,IAOI,IAOJ,A,B,P)
               CALL ADJTR(IAOI,IAOJ,NTOTORB,A,B,T)
C
 7000       CONTINUE
 8000    CONTINUE
 9000 CONTINUE
C
      IF (ITER.GT.MXITER) THEN
         IF(MASWRK) THEN
           WRITE(IW,*) '**********************************************'
           WRITE(IW,*) 'ORBITALS NOT CONVERGED AFTER ',MXITER,' ITERS.'
           WRITE(IW,*) '**********************************************'
         END IF
         CALL ABRT
      END IF
C
C  IF THERE WERE ANY ROTATIONS, DO ANOTHER SWEEP.
C
      IF (NUMROT.GT.0) GOTO 100
C
      IF(MASWRK) WRITE(IW,9010) ITER
 9010 FORMAT(/1X,' -- NUMBER OF SWEEPS REQUIRED FOR CONVERGENCE =',I5)
C
C  NOW ORDER THE ATOMIC ORBITALS ACCORDING TO THEIR OCCUPATION NUMBER.
C
C-----------------------------------------------------------------
C     ADDITION:  TEACH MAPT2 OCCUPATION-BASED REORDERINGS.
      DO I=1,NTOTORB
        MAPT2(I)=I
      ENDDO
C-----------------------------------------------------------------
      DO 9100 IATOM=1,NATOT
         ILAST = NTOTORB
         IF (IATOM.NE.NATOT) ILAST=NATORB(IATOM+1)-1
         IF (ILAST-NATORB(IATOM).EQ.0) GOTO 9100
         DO 9150 IO1=NATORB(IATOM),ILAST
            IMAX = IO1
            INDX = LTPOS(IO1,IO1)
            PMAX = P(INDX)
            DO 9160 IO2=IO1+1,ILAST
               IND = LTPOS(IO2,IO2)
               IF (P(IND).GT.PMAX) THEN
                  PMAX = P(IND)
                  IMAX = IO2
               END IF
 9160       CONTINUE
            IF (IMAX.EQ.IO1) GOTO 9150
C-----------------------------------------------------------------
C           ADDITION:  TEACH MAPT2 OCCUPATION-BASED REORDERINGS.
            ITMP=MAPT2(IO1)
            MAPT2(IO1)=MAPT2(IMAX)
            MAPT2(IMAX)=ITMP
C-----------------------------------------------------------------
            DO 9170 II=1,NTOTORB
               TEMP = T(II,IO1)
               T(II,IO1) = T(II,IMAX)
               T(II,IMAX) = TEMP
               IF (II.EQ.IO1.OR.II.EQ.IMAX) GOTO 9170
               IND1 = LTPOS(IO1,II)
               IND2 = LTPOS(IMAX,II)
               TEMP = P(IND1)
               P(IND1) = P(IND2)
               P(IND2) = TEMP
 9170       CONTINUE
            IND1 = LTPOS(IO1,IO1)
            IND2 = LTPOS(IMAX,IMAX)
            TEMP = P(IND1)
            P(IND1) = P(IND2)
            P(IND2) = TEMP
 9150    CONTINUE
 9100 CONTINUE
C
C  NOW TRY TO MAKE AS MANY OFF-DIAGONAL ELEMENTS AS POSSIBLE POSITIVE.
C
C
      DO 9200 IATOM=1,NATOT
         ILAST = NTOTORB
         IF (IATOM.NE.NATOT) ILAST = NATORB(IATOM+1)-1
         DO 9210 IO1=NATORB(IATOM),ILAST
            IMAX = 1
            ZMAX = 0.0D+00
            DO 9230 IO2=IO1+1,NTOTORB
               DO 9240 II=NATORB(IATOM),ILAST
                  IF (IO2.EQ.II) GOTO 9230
 9240          CONTINUE
               IND1 = LTPOS(IO1,IO2)
               IF (ABS(P(IND1)).GT.ZMAX) THEN
                  IOZ = IO2
                  IMAX = IND1
                  ZMAX = ABS(P(IND1))
               END IF
 9230       CONTINUE
            IF (P(IMAX).LT.0.0D+00) THEN
               DO 9250 IO2=1,NTOTORB
                  IPOS = LTPOS(IO2,IOZ)
                  T(IO2,IOZ) = -T(IO2,IOZ)
                  P(IPOS) = -P(IPOS)
 9250          CONTINUE
               IPOS = LTPOS(IOZ,IOZ)
               P(IPOS) = ABS(P(IPOS))
            END IF
 9210    CONTINUE
 9200 CONTINUE
      RETURN
      END
C
C*MODULE LOCAL   *DECK INITT
C     ---------------------
      SUBROUTINE INITT(T,N)
C     ---------------------
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION T(N,N)
C
      DO 13 I=1,N
         DO 113 J=1,N
            T(I,J) = 0.0D+00
  113    CONTINUE
   13 CONTINUE
      DO 14 I=1,N
         T(I,I) = 1.0D+00
   14 CONTINUE
C
      RETURN
      END
C
C*MODULE LOCAL   *DECK ROT1INT
C     --------------------------------------------------------
      SUBROUTINE ROT1INT(N,I,J,A,B,CL)
C     --------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,T-Z)
      IMPLICIT INTEGER(I-S)
      DIMENSION CL(1)
C
C     APPLICATION OF JACOBI TRANSFORMATION TO A CANONICAL
C     ARRAY OF 1-ELECTRON INTEGRALS.
C     IE FOR <P|Q> WHERE P.GE.Q
C
C     N       ORBITAL DIMENSION OF THE INTEGRAL MATRIX
C     I,J     ORBITALS TO BE ROTATED, I<J
C     A,B     TOP LEFT AND RIGHT ELEMENTS, RESPECTIVELY, OF THE JACOBI
C             TRANSFORMATION MATRIX
C     CL      ARRAY CONTAINING INTEGRALS.
C
C     CONSTANTS REQUIRED FOR FULL TRANSFORMATION.
C
      A2 = A*A
      AB = A*B
      B2 = B*B
      T1 = 2.0D+00*AB
      T2 = A2 - B2
C
C     END OF CONSTANTS
C
C     GROUP A/  BOTH ORBITALS IN INTEGRAL ARE EITHER I OR J.
C
      II = I*(I+1)/2
      JJ = J*(J+1)/2
      JI = JJ - J + I
C
C    UP TO HERE OKAY
C
      C1 = CL(II)
      C2 = CL(JI)
      C3 = CL(JJ)
C
      CL(II) = A2*C1 - T1*C2 + B2*C3
      CL(JI) = AB*C1 + T2*C2 - AB*C3
      CL(JJ) = B2*C1 + T1*C2 + A2*C3
C
C    GROUP B/  ONE ORBITAL IN INTEGRAL IS EITHER I OR J.
C
      DO 13 K=1,N
         IF (K.EQ.I.OR.K.EQ.J) GOTO 13
         IF (K.LT.I) THEN
            I1 = II - I + K
            I2 = JJ - J + K
         ELSE IF(K.GT.I.AND.K.LT.J) THEN
            I1 = K*(K-1)/2 + I
            I2 = JJ - J + K
         ELSE
            KX = K*(K-1)/2
            I1 = KX + I
            I2 = KX + J
         END IF
C
         C1 = CL(I1)
         C2 = CL(I2)
         CL(I1) = A*C1 - B*C2
         CL(I2) = B*C1 + A*C2
C
   13 CONTINUE
C
      RETURN
      END
C
C*MODULE LOCAL   *DECK ORIPRI
C     --------------------------------------------------------------
      SUBROUTINE ORIPRI(IW,NATOT,NATS,NTOTORB,NATORB,P,IWRK2,IATB,
     *    NOSI,CRIT)
C     ---------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION NATORB(NATOT),P(NTOTORB*(NTOTORB+1)/2)
      DIMENSION IWRK2(NATOT),IATB(NATS,NTOTORB)
      CHARACTER*3 MOL
      LOGICAL GOPARR,DSKWRK,MASWRK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXATM=2000, MXAO=8192)
C
      COMMON /RUNLAB/ TITLE(10),A(MXATM),B(MXATM),BFLAB(MXAO)
C
C     PRINTS 1-PARTICLE DENSITY MATRIX.
C
C    *  IW IS UNIT NUMBER FOR WRITING OUTPUT.
C    *  NATOT = NUMBER OF CATEGORIES OF ORBITALS.
C    *  NATS  = NUMBER OF ACTUAL ATOMS.
C    *  NTOTORB = TOTAL NUMBER OF ORBITALS.
C    *  NATORB(I) IS WHERE THE ORBITALS OF CATEGORY I BEGIN.
C    *  P IS DENSITY MATRIX, STORED IN LOWER TRIANGLE FORM.
C    *  IWRK2 IS A SCRATCH INTEGER ARRAY.
C    *  IATB(I,J) CONTAINS INFORMATION ABOUT WHICH ATOMS ARE INVOLVED
C       IN ORBITAL J.
C    *  NOSI IS THE NUMBER OF ORBITALS THAT ARE NOT ATOMIC IN NATURE.
C    *  CRIT = ELEMENTS WITH ABS. VALUE GREATER THAN CRIT ARE PRINTED.
C
      NOAO = NTOTORB - NOSI
C
      DO 41 II=1,NATOT
         IEND = NTOTORB
         IF (II.LT.NATOT) IEND = NATORB(II+1)-1
         IWRK2(II) = IEND-NATORB(II)+1
   41 CONTINUE
C
      NST = 1
C
   10 CONTINUE
      ICOL = 8
      IF(MASWRK) WRITE(IW,8050)
C
      DO 13 II=NST,NATOT
         IF (NATORB(II).GT.NOAO.
     *   AND.NATORB(II-1).LE.NOAO.AND.(II-NST).GT.0) GOTO 14
         NY1 = IWRK2(II)
         ICOL = ICOL + 6*(NY1-1)+8
         IF (ICOL.GT.85) GOTO 14
         ICOL = ICOL + 1
   13 CONTINUE
C
   14 IAT = II-1
C
      DO 113 IQ = NST,IAT
         IF (IWRK2(IQ).LT.1) GOTO 113
         IF (NATORB(IQ).LE.NOAO) THEN
            IF(MASWRK) WRITE(IW,9000) 'ATOM',IATB(1,NATORB(IQ))
         ELSE
            IF(MASWRK) WRITE(IW,9000) 'BOND',NATORB(IQ)-NOAO
         END IF
         IF (IWRK2(IQ).EQ.1) THEN
            IF(MASWRK) WRITE(IW,9003)
            GOTO 113
         END IF
         DO 32 IO = 2,IWRK2(IQ)
            IF(MASWRK) WRITE(IW,9006)
   32    CONTINUE
         IF(MASWRK) WRITE(IW,9003)
  113 CONTINUE
C
      IF(MASWRK) WRITE(IW,9020)
      DO 313 IQ = NST,IAT
         IF (IWRK2(IQ).LT.1) GOTO 313
         IF (IWRK2(IQ).EQ.1) THEN
            IF(MASWRK) WRITE(IW,9030) NATORB(IQ)
            GOTO 313
         END IF
         DO 332 IO=1,IWRK2(IQ)
            IF(MASWRK) WRITE(IW,9032) NATORB(IQ)+IO-1
  332    CONTINUE
         IF(MASWRK) WRITE(IW,9004)
  313 CONTINUE
C
      IF (NATORB(IAT).LE.NOAO) THEN
         IF(MASWRK) WRITE(IW,8060)
      ELSE
         IF(MASWRK) WRITE(IW,8061)
      END IF
      DO 413 IQ = NST, IAT
         IF (IWRK2(IQ).LT.1) GOTO 413
         IF (IWRK2(IQ).EQ.1) THEN
            IF (NATORB(IQ).LE.NOAO) THEN
               IF(MASWRK) WRITE(IW,9037) A(IATB(1,NATORB(IQ))),
     *     IATB(1,NATORB(IQ))
            ELSE
               IF(MASWRK) THEN
               IF (IATB(1,NATORB(IQ)).EQ.0) WRITE(IW,7039)
               IF (IATB(1,NATORB(IQ)).NE.0.AND.
     *             NATS.GT.2.AND.
     *             IATB(3,NATORB(IQ)).EQ.0)
     *             WRITE(IW,7037)
     *  IATB(1,NATORB(IQ)),IATB(2,NATORB(IQ))
               IF (IATB(1,NATORB(IQ)).NE.0.AND.
     *             NATS.LE.2)
     *             WRITE(IW,7037)
     *  IATB(1,NATORB(IQ)),IATB(2,NATORB(IQ))
               IF (IATB(1,NATORB(IQ)).NE.0.AND.
     *             NATS.GT.2.AND.
     *             IATB(3,NATORB(IQ)).NE.0)
     *             WRITE(IW,7038)
     *  IATB(1,NATORB(IQ)),IATB(2,NATORB(IQ))
               END IF
            END IF
            GOTO 413
         END IF
         DO 432 IO=1,IWRK2(IQ)
            IF(MASWRK) WRITE(IW,9039) A(IATB(1,NATORB(IQ))),IO
  432    CONTINUE
         IF(MASWRK) WRITE(IW,9005)
  413 CONTINUE
C
      IF(MASWRK) WRITE(IW,7062)
      DO 513 IQ = NST, IAT
         IF (IWRK2(IQ).LT.1) GOTO 513
         IF (IWRK2(IQ).EQ.1) THEN
            IF(MASWRK) WRITE(IW,7040)
            GOTO 513
         END IF
         DO 532 IO=1,IWRK2(IQ)
            IF(MASWRK) WRITE(IW,7042)
  532    CONTINUE
         IF(MASWRK) WRITE(IW,7044)
  513 CONTINUE
C
      DO 613 IQA = 1,NATOT
         IF (IWRK2(IQA).LT.1) GOTO 613
         DO 676 IQO = 1,IWRK2(IQA)
            ICT = NATORB(IQA)+IQO-1
            IF (NATORB(IQA).LE.NOAO) THEN
            IF(MASWRK) WRITE(IW,9052) ICT,A(IATB(1,NATORB(IQA))),
     *                                IATB(1,NATORB(IQA))
            ELSE
            IF(MASWRK) WRITE(IW,9052) ICT,'BD',ICT-NOAO
            END IF
C
            DO 713 IQ = NST,IAT
               IF (IWRK2(IQ).LT.1) GOTO 713
               IF (IWRK2(IQ).EQ.1) THEN
                  IJT = NATORB(IQ)
                  IPOS = LTPOS(ICT,IJT)
C                        SMALL BOND ORDERS ARE PRINTED AS BLANK TO
C                        KEEP ANYONE FROM OBSESSING OVER THEM.
                  IF (ABS(P(IPOS)).LT.CRIT) THEN
                     MOL = ' | '
                     IF(MASWRK) WRITE(IW,9053) MOL(1:3)
                     GOTO 713
                  END IF
C                        PRINT AN EXTRA DECIMAL POINT FOR THE DIAGONALS.
C                          IT IS NOT SIGNIFICANT, BUT CAN HELP DECIDE
C                          WHICH WAY TO ROUND TO 2 DIGITS IF TRYING TO
C                          GET THE MOLECULE TO SUM TO EXACTLY -ICHARG-.
C                        STARS HELP DRAW THE EYE TO LARGER BOND ORDERS.
                  IF (ICT.EQ.IJT) THEN
                     MOL = '| '
                     IF(MASWRK) WRITE(IW,9354) P(IPOS),MOL(1:2)
                  ELSE
                     IF (ABS(P(IPOS)).LT.0.3D+00) THEN
                        MOL = ' | '
                     ELSE
                        MOL = '*| '
                     END IF
                     IF(MASWRK) WRITE(IW,9254) P(IPOS),MOL(1:3)
                  END IF
                  GOTO 713
               END IF
               DO 732 IO = 1,IWRK2(IQ)
                  IJT = NATORB(IQ)+IO-1
                  IPOS = LTPOS(ICT,IJT)
                  IF (ABS(P(IPOS)).LT.CRIT) THEN
                     MOL = ' '
                     IF(MASWRK) WRITE(IW,9056) MOL
                     GOTO 732
                  END IF
                  IF (ICT.EQ.IJT) THEN
                     IF(MASWRK) WRITE(IW,9355) P(IPOS)
                  ELSE
                     IF (ABS(P(IPOS)).LT.0.3D+00) THEN
                        MOL = ' '
                     ELSE
                        MOL = '*'
                     END IF
                     IF(MASWRK) WRITE(IW,9255) P(IPOS),MOL(1:1)
                  END IF
  732          CONTINUE
               IF(MASWRK) WRITE(IW,9057)
  713       CONTINUE
  676    CONTINUE
C
C
      IF(MASWRK) WRITE(IW,8062)
      DO 913 IQ = NST, IAT
         IF (IWRK2(IQ).LT.1) GOTO 913
         IF (IWRK2(IQ).EQ.1) THEN
            IF(MASWRK) WRITE(IW,9040)
            GOTO 913
         END IF
         DO 932 IO=1,IWRK2(IQ)
            IF(MASWRK) WRITE(IW,9042)
  932    CONTINUE
         IF(MASWRK) WRITE(IW,9044)
  913 CONTINUE
  613 CONTINUE
      IF(MASWRK) WRITE(IW,'(/)')
C
      NST = II
      IF (IAT.LT.NATOT) GOTO 10
C
C   OUTPUT IS BUILT A FIELD AT A TIME, SUPPRESSING CARRIAGE RETURNS
C   WITH THE UNCOMMONLY USED -$- FORMAT SPECIFIER.
C   BACKSTROKE FORMAT WILL EVENTUALLY PRODUCE A FULL LINE OF OUTPUT.
C
 8050 FORMAT(/1X,'       |',$)
 8060 FORMAT(/1X,'       | ',$)
 8061 FORMAT(/1X,' ATOMS | ',$)
 8062 FORMAT(/1X,'-------|',$)
 7062 FORMAT(/1X,'=======|',$)
 9000 FORMAT(A4,I3,$)
 9003 FORMAT('|',$)
 9004 FORMAT(' |',$)
 9005 FORMAT('| ',$)
 9006 FORMAT('      ',$)
 9020 FORMAT(/1X,' OLMO  |',$)
 9030 FORMAT(2X,I2,'   |',$)
 9032 FORMAT(2X,I2,'  ',$)
 9037 FORMAT(1X,A2,I2,' | ',$)
 9039 FORMAT(1X,A2,I1,'  ',$)
 7037 FORMAT(I2,'-',I2,' | ',$)
 7038 FORMAT(I2,'-',I2,'-| ',$)
 7039 FORMAT(1X,'  ?  | ',$)
 9040 FORMAT('-------|',$)
 7040 FORMAT('=======|',$)
 9042 FORMAT('------',$)
 7042 FORMAT('======',$)
 9044 FORMAT('-|',$)
 7044 FORMAT('=|',$)
 9052 FORMAT(/1X,I2,1X,A2,I2,'| ',$)
 9053 FORMAT('     ',A3,$)
 9254 FORMAT(F5.2,A3,$)
 9354 FORMAT(F6.3,A2,$)
 9255 FORMAT(F5.2,A1,$)
 9355 FORMAT(F6.3,$)
 9056 FORMAT('     ',A1,$)
 9057 FORMAT('| ',$)
C
      RETURN
      END
C
C*MODULE LOCAL   *DECK ORIANAL
C     --------------------------------------------------------------
      SUBROUTINE ORIANAL(IW,NATOT,NATS,NTOTORB,NATORB,P,IATB,
     *                   NOSI)
C     ---------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION NATORB(NATOT),P(NTOTORB*(NTOTORB+1)/2)
      DIMENSION IATB(NATS,NTOTORB)
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXATM=2000, MXAO=8192)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNLAB/ TITLE(10),A(MXATM),B(MXATM),BFLAB(MXAO)
C
C     PERFORMS ANALYSIS ON DENSITY MATRIX.
C
C    *  IW IS UNIT NAME FOR WRITING OUTPUT
C    *  NATOT = NUMBER OF CATEGORIES OF ORBITALS.
C    *  NATS  = ACTUAL NUMBER OF ATOMS.
C    *  NTOTORB = TOTAL NUMBER OF ORBITALS.
C    *  NATORB(I) IS WHERE THE ORBITALS OF CATEGORY I BEGIN.
C    *  P IS DENSITY MATRIX, STORED IN LOWER TRIANGLE FORM.
C    *  IATB(I,J) CONTAINS INFORMATION ABOUT WHICH ATOMS ARE INVOLVED
C       IN ORBITAL J.
C    *  NOSI IS THE NUMBER OF ORBITALS THAT ARE NOT ATOMIC IN NATURE.
C
      NOAO = NTOTORB - NOSI
C
      IF (NOSI.EQ.0) THEN
         IF(MASWRK) WRITE(IW,9080)
         IF(MASWRK) WRITE(IW,*)
         DO 67 IU = 1,NATOT
            IF(MASWRK) WRITE(IW,9081) IATB(1,NATORB(IU)),
     *    A(IATB(1,NATORB(IU)))
   67    CONTINUE
         IF(MASWRK) WRITE(IW,*)
C
         DO 89 II=1,NATOT
               IST = NATORB(II)
            IEND = NTOTORB
            IF (II.LT.NATOT) IEND = NATORB(II+1)-1
            TPOP = 0.0D+00
            DO 92 JJ=IST,IEND
               IND = LTPOS(JJ,JJ)
               TPOP = TPOP + P(IND)
   92       CONTINUE
            IF(MASWRK) WRITE(IW,9085) TPOP
   89    CONTINUE
         IF(MASWRK) WRITE(IW,*)
      END IF
C
      IF(MASWRK) THEN
      WRITE(IW,*)
      WRITE(IW,*) 'BONDING CHARACTERISTICS OF ORIENTED LOCALIZED MOS'
      WRITE(IW,*)
      WRITE(IW,*) 'COLUMNS OLMO,COMP: POPULATIONS OF THE OLMO ',
     *    ' AND ITS COMPLEMENTARY MO.'
      WRITE(IW,*) 'COLUMN MXBO      : MAXIMUM TOTAL BOND ORDER ',
     *      'COMPATIBLE WITH THE ORBITAL '
      WRITE(IW,*) '                   OCCUPANCIES FOR ANTISYMMETRIC ',
     *     ' WAVEFUNCTIONS.'
      WRITE(IW,*) 'COLUMN ACBO      : ACTUAL TOTAL BOND ORDER OF ',
     *            'THE OLMO.'
      WRITE(IW,*) 'COLUMN %         : COLUMN ACBO AS A PERCENTAGE OF ',
     *    'COLUMN MXBO.'
      WRITE(IW,*)
     * 'COLUMN NOBDS     : NUMBER OF OTHER INTERACTING OLMOS ',
     * 'X/Y IMPLIES '
      WRITE(IW,'(2A/A)') '            ',
     *   '        X PIJ ELEMENTS >= 0.5 AND Y PIJ ELEMENTS >= 0.2',
     *           '                    BUT < 0.5.'
      WRITE(IW,'(2A/2A/2A)')
     *   ' COLUMNS T11,T21  : TRANSFORMATION MATRIX ',
     *      ' ELEMENTS FOR FORMING THE',
     *'                    BONDING(+) AND ANTIBONDING(-) ',
     *      'COMBINATIONS OF THE OLMO ',
     *         '                    AND ITS COMPLIMENTARY',
     * ' ORBITAL (T22 = T11, T12 = -T21).'
      WRITE(IW,'(2A/A)')
     *  ' COLUMNS N+,N-    : OCCUPATION NUMBERS OF THE ',
     *     'BONDING(+) AND ANTIBONDING(-)',
     *   '                    MOS GIVEN BY COLUMNS OF THE MATRIX T.'
      WRITE(IW,*)
      WRITE(IW,*)
      WRITE(IW,9060)
      WRITE(IW,9061)
      WRITE(IW,9062)
      WRITE(IW,9064)
      END IF
C
      DO 678 II=1,NATOT
         IST  = NATORB(II)
         IEND = NTOTORB
         IF (II.LT.NATOT) IEND = NATORB(II+1)-1
         IL = 0
         DO 689 IO = IST,IEND
            IL = IL + 1
            IF (NATORB(II).LE.NOAO) THEN
            IF(MASWRK) WRITE(IW,9052) IO,A(IATB(1,IO))
            ELSE
            IF(MASWRK) WRITE(IW,9052) IO,'BD',IL
            END IF
            PAN = 0.0D+00
            P11 = 0.0D+00
            IND = LTPOS(IO,IO)
            PAA = P(IND)
            MS = 0
            MW = 0
            DO 786 IY = 1,NATOT
               IF (IY.EQ.II) GOTO 786
               IST1 = NATORB(IY)
               IEND1 = NTOTORB
               IF (IY.LT.NATOT) IEND1 = NATORB(IY+1)-1
               DO 777 IT = IST1,IEND1
                  IND = LTPOS(IT,IO)
                  IF (ABS(P(IND)).GT.0.5D+00) THEN
                     MS = MS + 1
                  ELSE IF (ABS(P(IND)).GT.0.2D+00) THEN
                     MW = MW + 1
                  END IF
                  PAN = PAN + P(IND)*P(IND)
                  DO 789 IZ = 1,NATOT
                     IF (IZ.EQ.II) GOTO 789
                     IST2 = NATORB(IZ)
                     IEND2 = NTOTORB
                     IF (IZ.LT.NATOT) IEND2 = NATORB(IZ+1)-1
                     DO 877 IQ = IST2,IEND2
                     INDQ = LTPOS(IQ,IO)
                     INDT = LTPOS(IT,IQ)
                     P11 = P11 + P(IND)*P(INDQ)*P(INDT)
  877                CONTINUE
  789             CONTINUE
  777          CONTINUE
  786       CONTINUE
            IF (ABS(PAN).LT.1.0D-08) THEN
               P11 = 0.0D+00
               PAN = 0.0D+00
               DEL = 0.0D+00
               S2G = 0.0D+00
            ELSE
               P11 = P11/PAN
               PAN = SQRT(PAN)
               DEL = (PAA - P11)/2.0D+00
               S2G = PAN/SQRT(DEL*DEL + PAN*PAN)
            END IF
            TOT = P11 + PAA
            PBA = TOT/2.0D+00
            BMX =
     *  SQRT(MIN((PBA*PBA - DEL*DEL),((2-PBA)**2.0D+00 - DEL*DEL)))
            GAM = ASIN(S2G)/2.0D+00
            CG = COS(GAM)
            SG = SIN(GAM)
            BON = PBA + SQRT((DEL*DEL + PAN*PAN))
            ANT = PBA - SQRT((DEL*DEL + PAN*PAN))
            P3 = (PAN/BMX)*100
            IF(MASWRK) WRITE(IW,9070) PAA,P11,BMX,PAN,P3,MS,MW,
     *                                CG,SG,BON,ANT
  689    CONTINUE
         IF(MASWRK) WRITE(IW,9068)
  678 CONTINUE
C
 9052 FORMAT(/I2,1X,A2,' | ',$)
 9060 FORMAT(6X,'|',2X,'POPULATIONS','  |       BOND ORDERS',10X,
     *       '| BONDING/ANTIBONDING MOS',$)
 9061 FORMAT(/' OLMO ','|',15X,'|',28X,'|')
 9062 FORMAT(6X,'|  OLMO   COMP  |  MXBO   ACBO    %    NOBDS | T11',
     *        '   T21    N+    N-')
 9064 FORMAT('======|===============|============================|',
     *       '========================',$)
 9068 FORMAT(/'------|---------------|----------------------------|',
     *       '------------------------',$)
 9070 FORMAT(1X,F4.2,3X,F4.2,1X,' |  ',
     *    F4.2,3X,F4.2,1X,'  ',F4.1,' ',
     *       2X,I1,'/',I1,2X,'| ',F4.2,2X,F4.2,2X,F4.2,2X,F4.2,$)
 9080 FORMAT(/' QUASIATOMIC VALENCE POPULATIONS')
 9081 FORMAT(' AT',I2,'(',A2,')',$)
 9085 FORMAT(2X,F5.3,'  ',$)
C
      RETURN
      END
C
C*MODULE LOCAL   *DECK LTPOS
C     ---------------------------
      INTEGER FUNCTION LTPOS(I,J)
C     ---------------------------
      IMPLICIT INTEGER(A-Z)
      IMA=MAX(I,J)
      IMI=MIN(I,J)
      LTPOS=(IMA*(IMA-1))/2 + IMI
      RETURN
      END
C*MODULE LOCAL   *DECK LMOTVM
      SUBROUTINE LMOTVM(IPASS,L1,CLMO,M1)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXATM=2000,NMO=500)
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IWDUM,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
C
      NMO2    = NMO*NMO
      CALL VALFM(LOADFM)
      LHAO    = LOADFM  + 1
      LTAO    = LHAO    + NUM*NUM
      LCLOC   = LTAO    + NUM*NUM
      LHLMOA  = LCLOC   + NUM*NA
      LHLMOB  = LHLMOA  + NMO*NMO
      LT1     = LHLMOB  + NMO*NMO
      LH1     = LT1     + NUM*NUM
      LTLMOA  = LH1     + NUM*NUM
      LVLMOA  = LTLMOA  + NMO2
      LTLMOB  = LVLMOA  + NMO2
      LVLMOB  = LTLMOB  + NMO2
      LAST    = LVLMOB  + NMO2
      NEED    = LAST    - LOADFM - 1
      CALL GETFM(NEED)
      CALL LMOTV(X(LHAO),X(LTAO),X(LCLOC),X(LHLMOA),
     *           X(LHLMOB),X(LT1),X(LH1),
     *           X(LTLMOA),X(LVLMOA),X(LTLMOB),X(LVLMOB),
     *           IPASS,L1,CLMO,M1)
      IF(ILOCAL.EQ.2 .AND. IPASS.EQ.1) THEN
         CALL DAWRIT(IDAF,IODA,X(LTLMOA),NMO2,600,0)
         CALL DAWRIT(IDAF,IODA,X(LVLMOA),NMO2,601,0)
         CALL DAWRIT(IDAF,IODA,X(LTLMOA),NMO2,602,0)
         CALL DAWRIT(IDAF,IODA,X(LVLMOA),NMO2,603,0)
      ELSE IF(ILOCAL.EQ.2 .AND. IPASS.EQ.2) THEN
         CALL DAWRIT(IDAF,IODA,X(LTLMOB),NMO2,602,0)
         CALL DAWRIT(IDAF,IODA,X(LVLMOB),NMO2,603,0)
      END IF
      CALL RETFM(NEED)
      RETURN
      END
C*MODULE LOCAL   *DECK LMOTV
      SUBROUTINE LMOTV(HAO,TAO,CLOC,HLMOA,HLMOB,T1,H1,
     *                 TLMOA,VLMOA,TLMOB,VLMOB,
     *                 IPASS,L1,CLMO,M1)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXATM=2000,NMO=500)
      DIMENSION HAO(NUM*NUM),TAO(NUM*NUM),
     *          HLMOA(NMO,NMO),T1(NUM,NUM),H1(NUM,NUM),
     *          CLOC(NUM,NA),
     *          HLMOB(NMO,NMO),
     *          TLMOA(NMO,NMO),VLMOA(NMO,NMO),
     *          TLMOB(NMO,NMO),VLMOB(NMO,NMO),CLMO(*)
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /LMOEDA/ GDTOLA,GJTOLA,GKTOLA,TKTOLA,VTOLA,
     *                GDTOLB,GJTOLB,GKTOLB,TKTOLB,VTOLB,
     *                ECORL,EXCOR
C
      DATA ZERO/0.0D+00/
C
      L2 = (L1*L1+L1)/2
      CALL DAREAD(IDAF,IODA,HAO,L2,11,0)
      CALL DAREAD(IDAF,IODA,TAO,L2,13,0)
      DO I=1,M1
         DO J=1,L1
            CLOC(J,I)=CLMO((I-1)*L1+J)
         ENDDO
      ENDDO
C
      DO I=1,L1
         DO J=1,I
            T1(I,J)=TAO(I*(I-1)/2+J)
            T1(J,I)=T1(I,J)
            H1(I,J)=HAO(I*(I-1)/2+J)
            H1(J,I)=H1(I,J)
         ENDDO
      ENDDO
C
      IF(IPASS.EQ.1) THEN
         TKTOLA=ZERO
         VTOLA=ZERO
         DO I1=1,M1
            TLMOA(I1,I1)=ZERO
            HLMOA(I1,I1)=ZERO
            VLMOA(I1,I1)=ZERO
            DO J=1,L1
               DO K=1,L1
                  TLMOA(I1,I1)=
     *               TLMOA(I1,I1)+CLOC(J,I1)*CLOC(K,I1)*T1(J,K)
                  HLMOA(I1,I1)=
     *               HLMOA(I1,I1)+CLOC(J,I1)*CLOC(K,I1)*H1(J,K)
               ENDDO
            ENDDO
            VLMOA(I1,I1) = HLMOA(I1,I1) - TLMOA(I1,I1)
            TKTOLA       = TKTOLA       + TLMOA(I1,I1)
            VTOLA        = VTOLA        + VLMOA(I1,I1)
         ENDDO
      ELSE IF(IPASS.EQ.2) THEN
         TKTOLB=ZERO
         VTOLB=ZERO
         DO I1=1,M1
            TLMOB(I1,I1)=ZERO
            HLMOB(I1,I1)=ZERO
            VLMOB(I1,I1)=ZERO
            DO J=1,L1
               DO K=1,L1
                  TLMOB(I1,I1)=
     *               TLMOB(I1,I1)+CLOC(J,I1)*CLOC(K,I1)*T1(J,K)
                  HLMOB(I1,I1)=
     *               HLMOB(I1,I1)+CLOC(J,I1)*CLOC(K,I1)*H1(J,K)
               ENDDO
            ENDDO
            VLMOB(I1,I1) = HLMOB(I1,I1) - TLMOB(I1,I1)
            TKTOLB       = TKTOLB       + TLMOB(I1,I1)
            VTOLB        = VTOLB        + VLMOB(I1,I1)
         ENDDO
      END IF
      RETURN
      END
C*MODULE LOCAL   *DECK LMODJKM
      SUBROUTINE LMODJKM(IPASS,TWOEI,IA,M1,M2,M4)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION TWOEI(M4),IA(M2)
      PARAMETER (NMO=500)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /FMCOM / X(1)
C
      NMO2    = NMO*NMO
      CALL VALFM(LOADFM)
      LGJA    = LOADFM  + 1
      LGKA    = LGJA    + NMO2
      LGDA    = LGKA    + NMO2
      LGJB    = LGDA    + NMO
      LGKB    = LGJB    + NMO2
      LGDB    = LGKB    + NMO2
      LAST    = LGDB    + NMO
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
      CALL LMODJK(IPASS,TWOEI,IA,M1,M2,M4,
     *            X(LGJA),X(LGKA),X(LGDA),X(LGJB),X(LGKB),X(LGDB))
      IF(IPASS.EQ.1) THEN
         CALL DAWRIT(IDAF,IODA,X(LGJA),NMO2,604,0)
         CALL DAWRIT(IDAF,IODA,X(LGKA),NMO2,605,0)
         CALL DAWRIT(IDAF,IODA,X(LGDA),NMO ,606,0)
      ELSE IF(IPASS.EQ.2) THEN
         CALL DAWRIT(IDAF,IODA,X(LGJB),NMO2,607,0)
         CALL DAWRIT(IDAF,IODA,X(LGKB),NMO2,608,0)
         CALL DAWRIT(IDAF,IODA,X(LGDB),NMO ,609,0)
      END IF
      CALL RETFM(NEED)
      RETURN
      END
C*MODULE LOCAL   *DECK LMODJK
      SUBROUTINE LMODJK(IPASS,TWOEI,IA,M1,M2,M4,
     *                  GJA,GKA,GDA,GJB,GKB,GDB)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (NMO=500)
      DIMENSION TWOEI(M4),IA(M2),
     *          GJA(NMO,NMO),GKA(NMO,NMO),GDA(NMO),
     *          GJB(NMO,NMO),GKB(NMO,NMO),GDB(NMO)
C
      COMMON /LMOEDA/ GDTOLA,GJTOLA,GKTOLA,TKTOLA,VTOLA,
     *                GDTOLB,GJTOLB,GKTOLB,TKTOLB,VTOLB,
     *                ECORL,EXCOR
C
      DATA ZERO,TWO/0.0D+00,2.0D+00/
C
      IF(IPASS.EQ.1) THEN
         CALL VCLR(GDA,1,NMO)
         CALL VCLR(GJA,1,NMO*NMO)
         CALL VCLR(GKA,1,NMO*NMO)
         GDTOLA = ZERO
         GJTOLA = ZERO
         GKTOLA = ZERO
      ELSE IF(IPASS.EQ.2) THEN
         CALL VCLR(GDB,1,NMO)
         CALL VCLR(GJB,1,NMO*NMO)
         CALL VCLR(GKB,1,NMO*NMO)
         GDTOLB = ZERO
         GJTOLB = ZERO
         GKTOLB = ZERO
      END IF
C
      IT=0
      DO 110 I=1,M1
         II=IT + I
         IIT=IA(II)
         IIII=IIT + II
         IF(IPASS.EQ.1) GDA(I)=TWOEI(IIII)
         IF(IPASS.EQ.1) GDTOLA=GDTOLA+TWOEI(IIII)
         IF(IPASS.EQ.2) GDB(I)=TWOEI(IIII)
         IF(IPASS.EQ.2) GDTOLB=GDTOLB+TWOEI(IIII)
         JJ=0
         DO 100 J=1,I
            JJ=JJ+J
            IF(I.EQ.J) GO TO 100
               IJ=IT + J
               IJIJ=IA(IJ) + IJ
               IF(IPASS.EQ.1) GKA(J,I)=TWOEI(IJIJ)
               IF(IPASS.EQ.1) GKA(I,J)=GKA(J,I)
               IF(IPASS.EQ.1) GKTOLA  =GKTOLA+TWOEI(IJIJ)*TWO
               IF(IPASS.EQ.2) GKB(J,I)=TWOEI(IJIJ)
               IF(IPASS.EQ.2) GKB(I,J)=GKB(J,I)
               IF(IPASS.EQ.2) GKTOLB  =GKTOLB+TWOEI(IJIJ)*TWO
               IIJJ=IIT+JJ
               IF(IPASS.EQ.1) GJA(J,I)=TWOEI(IIJJ)
               IF(IPASS.EQ.1) GJA(I,J)=GJA(J,I)
               IF(IPASS.EQ.1) GJTOLA  =GJTOLA+TWOEI(IIJJ)*TWO
               IF(IPASS.EQ.2) GJB(J,I)=TWOEI(IIJJ)
               IF(IPASS.EQ.2) GJB(I,J)=GJB(J,I)
               IF(IPASS.EQ.2) GJTOLB  =GJTOLB+TWOEI(IIJJ)*TWO
  100    CONTINUE
         IT=IT+I
  110 CONTINUE
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_LMOSVD
c> @brief      Local_lmosvd calls local_ppasvd routines.
c>
c> @author     Aaron West and Klaus Ruedenberg
c>             -November 4, 2012
c> @details    Local_lmosvd grabs memory and calls svd routines.
c>
c> @date December 13, 2012-Aaron West
c> -Added ORMAS svd localization.
c>
c> @param IORBF1 indicates daf dict file with starting orbitals
c>               from which the localized orbitals are formed.
      SUBROUTINE LOCAL_LMOSVD(IORBF1)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C
C     VARS
C     MASWRK LINE PLACED BELOW TO MATCH...
      LOGICAL KEEPER
      DOUBLE PRECISION :: ZAN,X
      INTEGER IORBF1,ISIZSVD,ISIZSVD2,
     *        L0,L1,L2,L3,NDAWN1,
     *        LEIG1,LIWRK,LS,LS2,LSAOMO,LSV,LUVEC,LVNACT,LVOLD,LVSAV,
     *        LVTMP,LVTVEC,LWRKSVD,NCORTOT,NACT,ISIZE_FCCWFN
C
C     NEW CODING STANDARDS VARS
      DOUBLE PRECISION ::
     *       C,CRIT,DWPARM,GLIST,GRPDET,PRTTOL,SDET,SPINS,SZDET,
     *       WSTATE,STSYM
      INTEGER MXRT,IAN,ICH,IDWEIGH,IGPDET,IPURES,IROOT,IWTS,KDET,KSTDET,
     *        KSTSYM,MAXP,MAXW1,MUL,MXATM,MXAO,NA,NACTDT,NADET,NAT,NB,
     *        NBDET,NCI,NCOR,NCORSV,
     *        NGOTMX,LAST,LOADFM,
     *        NE,NFLGDM,NFTGCI,NITDET,NORBDT,NQMT,NUM,NUMORB
      INTEGER LIMLOW,LIMSUP,LIATMSTA,LIATMSTA2
      INTEGER IW,IDAF,IODA,IP,IPK,IR,IS,NAV
C
      LOGICAL FDIRCT,QCORR
      DOUBLE PRECISION ::
     *       C0SQ
      INTEGER NSPACE,NSPACE2,
     *        MSTA,MNUM,MINI,MAXI,IAMI,IAMA,IBMI,IBMA,
     *        IDIMFCC,LBST,NREF0
C
      LOGICAL CANONC,FCORE,FORS,EKT,LINSER
      DOUBLE PRECISION ::
     *       FINALCI,METHOD,CISTEP,ORMAS,ACURCY,ENGTOL,DAMP
      INTEGER MICIT,NWRDMC,NORBMC,NOROT,MOFRZ,
     *        NPFLG,NOFO,MCFMO,IDIABAT,MXNORO
C
      LOGICAL ORIENT,ORMFUL
      INTEGER NATMOR
C
      DOUBLE PRECISION ::
     *       RUNTYP,EXETYP,CHECK
      INTEGER NEVALS,NGLEVL,NHLEVL
C
      LOGICAL SOME
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      INTEGER LATMU,LIATM,LINAT,LIWHI
C-----------------------------------------------------------------------
      PARAMETER (MXAO=8192, MXATM=2000, MXRT=100, MXNORO=250)
      COMMON /ATLIM / LIMLOW(MXATM),LIMSUP(MXATM)
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,SDET,SZDET,
     *                GRPDET,STSYM,GLIST,DWPARM,
     *                NFLGDM(MXRT),IWTS(MXRT),NCORSV,NCOR,NACTDT,NORBDT,
     *                NADET,NBDET,KDET,KSTDET,IROOT,IPURES,MAXW1,NITDET,
     *                MAXP,NCI,IGPDET,KSTSYM,NFTGCI,IDWEIGH
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIMFCC(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWRDMC,NORBMC,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /ORNTMO/ ORIENT,ORMFUL,NATMOR(MXAO)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C-----------------------------------------------------------------------
C
C     DATA STUFF
      DATA CHECK/8HCHECK   /
      DATA ORMAS/8HORMAS   /
C
C     DEFINE PRINT STUFF
      SOME = NPRINT.NE.-5 .AND. MASWRK
C
C     PRINT STUFF
      IF(SOME) WRITE(IW,9000)
C
C     MEMORY ROUTINE FOR ATOMIC-LIKE ORBITALS.
C
C     SET UP SOME DIMENSIONS
      L0 = NQMT
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
      NACT=NACTDT
      ISIZE_FCCWFN=51
C
C
C     BEFOREHAND, DETERMINE SIZES OF ANY EXTRA WORK ARRAYS
C     NOTE:  EXPLICITLY DETERMINE LARGEST WORKSPACE
C            AND
C            FORCE INTO 1 VARIABLE.
      ISIZSVD  = MAX(3*MIN(L1,L0)+MAX(L1,L0),5*MIN(L1,L0))
      ISIZSVD2 = 5*L0
C     NEXT LINE GIVES SVD
      ISIZSVD  = MAX(ISIZSVD,ISIZSVD2)
      ISIZSVD2 = 8*L1
C     NEXT LINE GIVES GLDIAG
      ISIZSVD  = MAX(ISIZSVD,ISIZSVD2)
C     NEXT LINE GIVES A BIT MORE WORKSPACE
      ISIZSVD  = 40*ISIZSVD
C
C     DEFINE MAX SIZE OF LVNACT VAR BELOW.
      NUMORB=MAX(NACT,NCORSV)
C
C     FAKE OUT ALDECI NSPACE2
      IF(CISTEP.EQ.ORMAS) THEN
        NSPACE2=NSPACE
      ELSE
        NSPACE2=1
      ENDIF
C
C
C     GET ALL MEMORY FOR LOCAL_PPASVD.
      CALL GOTFM(NGOTMX)
      CALL VALFM(LOADFM)
      LS = LOADFM + 1
      LUVEC = LS + L2
      LEIG1 = LUVEC + L3
      LVTVEC = LEIG1 + L1
      LWRKSVD = LVTVEC + L0*L0
      LSV = LWRKSVD + ISIZSVD
      LVOLD = LSV + L3
      LVNACT = LVOLD + L3
      LVTMP = LVNACT + L1*NUMORB*NAT
      LVSAV = LVTMP + L3
      LSAOMO = LVSAV + L3
      LS2 = LSAOMO + L3
      LIWRK = LS2 + L2
      LIATMSTA2 = LIWRK + L2
      LIATMSTA = LIATMSTA2  + NSPACE2*NAT
      LATMU = LIATMSTA + NSPACE2*NAT
C     MORE MEMORY FOR THE RIP OFF OF DIMOID.
      LIATM = LATMU + NAT*NACT
      LIWHI = LIATM + NAT*NACT
      LINAT = LIWHI + NAT+NACT
      LAST  = LINAT + NAT+NACT
      NDAWN1 = LAST - LOADFM - 1
      CALL GETFM(NDAWN1)
C
C     SETUP LIMLOW AND LIMSUP ARRAYS BY CALLING AOLIM.
C     LIMLOW CONTAINS INITIAL BASIS FXN INDEX FOR EACH ATOM.
C     LIMSUP CONTAINS FINAL BASIS FXN INDEX FOR EACH ATOM.
C     E.G. TRIATOMIC
C     LIMLOW LIMSUP
C     1      33
C     34     57
C     58     93 = NUM IN INFOA BLOCK
      CALL AOLIM
C
C     LOOK FOR USER INPUT ON NATMOR.
C     IF NO USER INPUT, SETUP NATMOR VIA LOCAL_DIMOID2.
      IF(CISTEP.EQ.ORMAS.AND.NSPACE.GT.1) THEN
        CALL DAREAD(IDAF,IODA,X(LVOLD),L3,IORBF1,0)
        CALL LOCAL_PPA_NATMOR_SETUP(NATMOR,MASWRK,IW,
     *       X(LVOLD),X(LUVEC),X(LS),X(LATMU),
     *       X(LIATM),X(LIWHI),X(LINAT),
     *       L1,L2,NCORSV,NACT,NAT)
      ENDIF
C
C     MAKE THE CALLS FOR SVD-BASED ORBITALS.
      NCORTOT=0
      CALL LOCAL_PPAERR(ZAN,IAN,NAT,NACT,NATMOR,L0,
     *                  MSTA,ISIZE_FCCWFN,NSPACE2,CISTEP,
     *                  X(LIATMSTA),X(LIATMSTA2),MASWRK,IW)
      IF(EXETYP.EQ.CHECK) GO TO 8999
      CALL LOCAL_PPASVDCORE(
     *     NCORTOT,IORBF1,X(LS2),
     *     X(LS),X(LUVEC),X(LEIG1),X(LVTVEC),
     *     X(LWRKSVD),X(LIWRK),
     *     X(LVOLD),X(LVNACT),X(LVTMP),X(LVSAV),
     *     X(LSV),X(LSAOMO),
     *     ISIZSVD,NCORSV,L0,L1,L2,L3,
     *     LIMLOW,LIMSUP,NAT,MASWRK)
      CALL LOCAL_PPASVD(
     *     NCORTOT,IORBF1,X(LS2),
     *     X(LS),X(LUVEC),X(LEIG1),X(LVTVEC),
     *     X(LWRKSVD),X(LIWRK),
     *     X(LVOLD),X(LVNACT),X(LVTMP),X(LVSAV),
     *     X(LSV),X(LSAOMO),
     *     ISIZSVD,NACT,L0,L1,L2,L3,
     *     MSTA,ISIZE_FCCWFN,NSPACE2,CISTEP,
     *     LIMLOW,LIMSUP,NAT,X(LIATMSTA),X(LIATMSTA2),
     *     MASWRK)
C
C     FOR ORIENTATION DILRMO ROUTINE:
C     LOCAL_PPADEN PUTS DENSITY ON DAF FILE 285.
C     PUT ORTHOGONAL SVD-ORBITALS INTO FILE 71.
C     ----LATER, MIGHT PROVIDE CHOICES IF DOING NONORTHOGONAL ORBITALS.
      CALL LOCAL_PPADEN(
     *     X(LVTMP),X(LVSAV),X(LVOLD),X(LSV),
     *     NCORTOT,NACT,L1,L3,MASWRK)
      CALL DAREAD(IDAF,IODA,X(LVTMP),L3,521,0)
      CALL DAWRIT(IDAF,IODA,X(LVTMP),L3,71,0)
C
C     1. FINAL ORBITAL ORDER ==> FILE 527
C     2. FINAL ATOM ORDER    ==> FILE 531
      KEEPER=CISTEP.EQ.ORMAS.AND.NSPACE.GT.1
      CALL MALMQ_REORDER1(NAT,L1,X(LEIG1),NATMOR,
     *                    NACT,NCORSV,KEEPER,
     *                    SOME)
C
C     RELEASE ALL MEMORY FOR ATOMIC-LIKE ORBITALS.
 8999 CONTINUE
      CALL RETFM(NDAWN1)
C
      RETURN
 9000 FORMAT(/5X,60(1H-)/
     *   5X,'LOCAL_LMOSVD NOW LOCALIZES ATOMIC BASIS ONTO MO SPACE.'/
     *   5X,60(1H-))
      END
C*MODULE LOCAL   *DECK LOCAL_PPAERR
c> @brief      Routine checks basis set for SVD-localization.
c>
c> @author     Aaron West and Klaus Ruedenberg
c>             -November 4, 2012
c> @details    Routine checks basis set for SVD-localization.
c>
c> @param ZAN          is from INFOA common.
c> @param IAN          is from INFOA common.
c> @param NAT          is the number of atoms.
c> @param NACT         is the number of active orbitals.
c> @param NATMOR       is an integer array of atom numbers for each
c>                     orbital in the ORMAS subpsaces.
c>                     It restricts the localization by user input.
c> @param L0           is the length of the MO variational space.
c> @param MSTA         contains the starting orbitals for each
c>                     ORMAS group, or subspace.
c> @param ISIZE_FCCWFN is current size of fccwfn integer arrays.
c> @param NSPACE       is the number ORMAS groups.
c> @param CISTEP       is the kind of CI performed e.g. ormas,aldet.
c> @param IATMSTA      is an array that defines sets of atoms and
c>                     orbitals to localized based on natmor input.
c> @param IATMSTA2     is for catching bugs across to local_ppasvd.
c> @param MASWRK       indicates the master process.
c> @param IW           indicates write out to the log file.
      SUBROUTINE LOCAL_PPAERR(ZAN,IAN,NAT,NACT,NATMOR,L0,
     *                  MSTA,ISIZE_FCCWFN,NSPACE,CISTEP,
     *                  IATMSTA,IATMSTA2,MASWRK,IW)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL MASWRK
      INTEGER MXATM,NSPACE
      PARAMETER (MXATM=2000)
      DOUBLE PRECISION :: ZAN(MXATM),CISTEP,ORMAS
      INTEGER NAT,IW,I,J,II,NERR,IERR,ILAST,NUCZ,ITMP,NACT,
     *        ISIZE_FCCWFN,L0
      INTEGER NUMVAL1,LOCAL_NUMVAL
      INTEGER IAN(MXATM),MSTA(ISIZE_FCCWFN),NATMOR(L0),
     *        IATMSTA(NSPACE*NAT),IATMSTA2(NSPACE*NAT)
C-----------------------------------------------------------------------
C
      DATA ORMAS /8HORMAS   /
C
C     INITIALIZE NERR
      NERR=0
C
C     MAKE SOME MAIN ERROR OUTS FIRST.
C     --FOR NOW, ABORT IF BASIS IS NOT ALL ELECTRON BASIS.
      IERR=0
      ILAST=55
      DO I=1,NAT
        NUCZ = INT(ZAN(I) + 1.0D-03)
        IF(NUCZ.NE.IAN(I).OR.IAN(I).GE.ILAST) IERR=IERR+1
      ENDDO
      NERR=NERR+IERR
      IF(MASWRK) WRITE(IW,9001)
      IF(MASWRK.AND.IERR.GT.0) WRITE(IW,9002)
C
C     ERROR OUT IF ACTIVE ORBITALS ARE NOT THE LENGTH
C     OF THE FULL-VALENCE ORBITALS.
C     THIS ITEM IS ACTUALLY NEEDED FOR THIS METHOD.
      ITMP=0
      DO I=1,NAT
        NUMVAL1=LOCAL_NUMVAL(I)
        ITMP=ITMP+NUMVAL1
      ENDDO
      IERR=0
      IF(ITMP.NE.NACT) IERR=1
      NERR=NERR+IERR
      IF(MASWRK) WRITE(IW,9003)
      IF(MASWRK.AND.IERR.GT.0) WRITE(IW,9004)
C
C     MAKE CHECKS ON NATMOR FOR ORMAS NSPACE>1.
C     --CHECK THAT NSPACE IS ACTUALLY GREATER THAN 0.
C     --CHECK THAT ALL ACTIVE ORBITALS ARE ASSIGNED ATOM NUMBERS.
C     --ATOM NUMBERS IN NATMOR MUST BE LESS THAN NAT.
C     --OCCURENCES OF ATOM NUMBERS IN NATMOR
C       CANNOT EXCEED NUMBER OF VALENCE ORBITALS ON EACH ATOM.
C
      IF(CISTEP.NE.ORMAS.OR.NSPACE.EQ.1) GO TO 8000
CKEEP22 SEARCH ON CKEEP22 TO GET THE OTHER REQUIRED LINES.
CKEEP22 NEXT LINE IS USEFUL IF WE WANT TO COMPARE NSPACE=1 RESULTS
CKEEP22 AND EASILY SEE IF OUR ORBITAL-ATOM SETUP IS WORKING OR NOT.
CKEEP22 IF(CISTEP.NE.ORMAS) GO TO 8000
      IERR=0
      IF(NSPACE.EQ.0) IERR=IERR+1
      NERR=NERR+IERR
      IF(MASWRK) WRITE(IW,9005)
      IF(NSPACE.EQ.0) WRITE(IW,9006)
C
C     AT THIS POINT, MSTA ORBITAL INDICES CONTAINS CORES.
      IERR=0
      DO I=MSTA(1),MSTA(NSPACE+1)-1
        IF(NATMOR(I).EQ.0) IERR=IERR+1
      ENDDO
      NERR=NERR+IERR
      IF(MASWRK) WRITE(IW,9007)
      IF(IERR.GT.0.AND.MASWRK) WRITE(IW,9008)
C
      IERR=0
      DO I=1,NAT
        ITMP=0
        DO II=MSTA(1),MSTA(NSPACE+1)-1
          IF(NATMOR(II).EQ.I) ITMP=ITMP+1
        ENDDO
        NUMVAL1=LOCAL_NUMVAL(I)
        IF(ITMP.GT.NUMVAL1) IERR=IERR+1
      ENDDO
      NERR=NERR+IERR
      IF(MASWRK) WRITE(IW,9009)
      IF(MASWRK.AND.IERR.GT.0) WRITE(IW,9010)
C
C     NOW, USE NATMOR TO CREATE THE IATMSTA ARRAY.
C          THE IATMSTA ARRAY WILL SOON DEFINE THE
C          THE SVD SIZES IN THE SUBSEQUENT ROUTINES.
C          THE IATMSTA2 ARRAY IS CATCHING BUGS IN -LOCAL_PPASVD-.
C          IATMSTA2 WILL THEN CHANGE TO DEFINE STARTING ORBITAL NUMBER.
      CALL VICLR(IATMSTA,1,NSPACE*NAT)
      CALL VICLR(IATMSTA2,1,NSPACE*NAT)
      DO II=1,NSPACE
        DO I=MSTA(II),MSTA(II+1)-1
          DO J=1,NAT
            ITMP=(J-1)*NSPACE+II
            IF(NATMOR(I).EQ.J) IATMSTA(ITMP)=IATMSTA(ITMP)+1
            IF(NATMOR(I).EQ.J) IATMSTA2(ITMP)=1
          ENDDO
        ENDDO
      ENDDO
      IF(MASWRK) THEN
        WRITE(IW,9012)
        DO II=1,NSPACE
          WRITE(IW,9013) II
          DO J=1,NAT
            ITMP=(J-1)*NSPACE+II
            IF(IATMSTA2(ITMP).EQ.1) WRITE(IW,9014) J
          ENDDO
        ENDDO
        WRITE(IW,9015)
        WRITE(IW,9016)
        DO II=1,NSPACE
          DO J=1,NAT
            ITMP=(J-1)*NSPACE+II
            IF(IATMSTA(ITMP).NE.0)
     *        WRITE(IW,9017) II,J,IATMSTA(ITMP)
          ENDDO
        ENDDO
        WRITE(IW,9015)
      ENDIF
C
C     ACTUALLY ERROR OUT.
 8000 CONTINUE
      IF(NERR.GT.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9001 FORMAT(/1X,'BASIS SET CHECK IS DONE.')
 9002 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.'/
     *       1X,'ERROR OCCURS FOR USING BASIS SET.')
 9003 FORMAT(1X,'MBS VALENCE ORBITAL CHECK IS DONE.')
 9004 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.'/
     *       1X,'NACT MUST EQUAL NUMBER OF MBS VALENCE ORBITALS.')
 9005 FORMAT(1X,'FCCWFN CHECK IS DONE.')
 9006 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.'/
     *       1X,'FCCWFN COMMON IS NOT YET DEFINED.'/)
 9007 FORMAT(1X,'NATMOR ARRAY CHECK IS DONE.')
 9008 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.'/
     *       1X,'SVD ORMAS REQUIRES NATMOR ARRAY BE FILLED IN.'/)
 9009 FORMAT(1X,'ATOM OCCURENCES IN NATMOR ARRAY CHECK IS DONE.')
 9010 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.'/
     *       1X,'SVD ORMAS REQUIRES NATMOR ARRAY VALUE OCCURENCES',
     *       1X,'MAX OUT WITH THE'/,
     *       1X,'MAXIMUM NUMBER OF VALENCE ORBITALS',
     *       1X,'ALLOWED ON EACH ATOM.'/)
 9012 FORMAT(/1X,'*** DEFINING SVD ATOM ASSIGNEMENTS',
     *        1X,'BASED ON USER INPUT. ***',
     *       /1X,'NSPACE',4X,'ATOM')
 9013 FORMAT(/I3,4X,' ',$)
 9014 FORMAT(1X,I3,$)
 9015 FORMAT(/)
 9016 FORMAT(/1X,'*** DEFINING SVD OUTPUTS BASED ON USER INPUT. ***',
     *       /1X,'NSPACE',4X,'ATOM',4X,'NUMBER OF MOs')
 9017 FORMAT(1X,I3,4X,I3,4X,I3)
      END
C*MODULE LOCAL    *DECK LOCAL_NUMVAL 
c> @brief      Routine returns number of valences orbitals.
c>
c> @author     Aaron West and Klaus Ruedenberg
c>             -November 4, 2012
c> @details    Routine returns number of valence orbitals for
c>             atom ITMP2.
c>
c> @param ITMP2 is the atom number.
      INTEGER FUNCTION LOCAL_NUMVAL(ITMP2)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      INTEGER I,ITMP,ITMP2,NVALAT
C     NEW CODING STANDARDS VARS
      DOUBLE PRECISION :: ZAN,C
      INTEGER MXATM,NAT,ICH,MUL,NUM,NQMT,NEX,NA,NB,IAN
      PARAMETER (MXATM=2000)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NEX,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C-----------------------------------------------------------------------
C
C     RETURN THE NUMBER OF VALENCE ORBITALS ON A GIVEN ATOM.
C     ALSO SEE NUMCOR,NVVOS_NUMCOR,AND VVOS ROUTINES.
C     STILL NEED TO ADDRESS ECPs,ETC.
C     STILL NEED TO ADDRESS SEMI-CORE ORBS.
C
      I=ITMP2
      ITMP=IAN(I)
      IF(               ITMP.LE. 2) NVALAT=1
      IF(ITMP.GE. 3.AND.ITMP.LE. 4) NVALAT=1
      IF(ITMP.GE. 5.AND.ITMP.LE.10) NVALAT=4
      IF(ITMP.GE.11.AND.ITMP.LE.12) NVALAT=1
      IF(ITMP.GE.13.AND.ITMP.LE.18) NVALAT=4
      IF(ITMP.GE.19.AND.ITMP.LE.20) NVALAT=1
      IF(ITMP.GE.21.AND.ITMP.LE.30) NVALAT=6
      IF(ITMP.GE.31.AND.ITMP.LE.36) NVALAT=4
      IF(ITMP.GE.37.AND.ITMP.LE.38) NVALAT=1
      IF(ITMP.GE.39.AND.ITMP.LE.48) NVALAT=6
      IF(ITMP.GE.49.AND.ITMP.LE.54) NVALAT=4
C
      LOCAL_NUMVAL=NVALAT
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_ATM_CH
C> @brief      This routine return integer value of nuclear charge.
C> 
C> @author     Aaron West
C>             -November 15, 2012
C> 
C> @details    This routine return integer value of nuclear charge.
C>             Using function avoids any conflict of variables very
C>             easily.  e.g. in Davidson routines for Malmqvist items
C> 
C> @param IAT is the atom number.
      INTEGER FUNCTION LOCAL_ATM_CH(IAT)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      INTEGER IAT
C     NEW CODING STANDARDS VARS
      DOUBLE PRECISION :: ZAN,C
      INTEGER MXATM,NAT,ICH,MUL,NUM,NQMT,NEX,NA,NB,IAN
      PARAMETER (MXATM=2000)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NEX,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C-----------------------------------------------------------------------
C
      LOCAL_ATM_CH=INT(ZAN(IAT)) 
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_PPASVDCORE
c> @brief      Routine makes SVD-localized core orbitals.
c>
c> @author     Aaron West and Klaus Ruedenberg
c>             -November 4, 2012
c>
c> @details    Routine makes SVD-localized core orbitals.
c>             LOCAL_PPASVD contains equivalent and 
c>             better comments in the routine itself.
c>
c> @date November 16, 2012-Aaron West
c> -Removed some error outs for vtvec.  Symmetric molecules
c>  can have zeros here even in C1 point group.
c>  This error out was mainly for debugging bad code.
c>
c> @param NCORTOT is total number of MCSCF core orbitals. 
c> @param IORBF1 is the dat dict file for initial orbitals.
c> @param S2 stores AO basis overlaps on each atom.
c> @param S stores all the AO basis overlaps.
c> @param UVEC is the u matrix in SVD.
c> @param EIG holds eigenvalues from SVD.
c> @param VTVEC is the V-transpose matrix in SVD.
c> @param WRKSVD is the work array designed for gldiag and svd calls.
c> @param IWRK is the integer work array used
c>                    -- for symmetric matrix indices
c>                    -- for gldiag calls
c> @param VOLD contains the AO coefficients from IORBF1 daf dict file.
c> @param VCOR holds AO coefficients for core orbitals.
c> @param VTMP is temporary storage.
c> @param VSAV is temporary storage.
c> @param SV holds the AO basis overlap times AO coefficients matvec.
c> @param SAOMO is often S_IATM1**(-1/2) * SV on each IATM1 atom.
c> @param ISIZSVD is the workspace size for WRKSVD array.
c> @param NCORSV is the total number of core orbitals out of the common.
c> @param L0 is the length of the MO variational space.
c> @param L1 is the length of the AO coefficients.
c> @param L2 is the triangular length of L1.
c> @param L3 is the square of L1.
c> @param LIMLOW array contains the lower basis function on an atom.
c> @param LIMSUP array contains the upper basis function on an atom.
c> @param NAT is the number of atoms.
c> @param MASWRK indicates the master process.
c> @todo  Routine might need gram-schmidt orthogonalization
c>        instead of symmetric orthogonalization.
c>        Error outs will indicate.
c> @see   LOCAL_PPASVD
      SUBROUTINE LOCAL_PPASVDCORE(
     *           NCORTOT,IORBF1,S2,
     *           S,UVEC,EIG,VTVEC,WRKSVD,IWRK,
     *           VOLD,VCOR,VTMP,VSAV,
     *           SV,SAOMO,
     *           ISIZSVD,NCORSV,L0,L1,L2,L3,
     *           LIMLOW,LIMSUP,NAT,MASWRK)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL MASWRK
      INTEGER MXATM
      PARAMETER (MXATM=2000)
      DOUBLE PRECISION :: ONE,TOL
      INTEGER NAT,LIMLOW(MXATM),LIMSUP(MXATM),
     *        NVVOS_NUMCOR
      PARAMETER (ONE=1.0D+00, TOL=1.0D-06)
      INTEGER I,IATM1,IBAS1,IBAS2,IERR2,IERR3,IHACT,
     *        ILTH,IMO,IORBF1,ISIZSVD,J,JHACT,L0,L1,L2,L3,NCORSV,
     *        NCORTOT,NUMCOR1,IJ,IJ2
C     NEW CODING STANDARDS VARS
      INTEGER IDAF,INFO,IODA,IP,IPK,IR,IS,IW,NAV
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950) 
C-----------------------------------------------------------------------
      DOUBLE PRECISION :: 
     *       S2(L2),S(L2),
     *       UVEC(L1,L1),EIG(L1),VTVEC(L0,L0),
     *       WRKSVD(ISIZSVD),
     *       VOLD(L1,L1),VTMP(L1,L1),VSAV(L1,L1),
     *       VCOR(L1,NCORSV,NAT),
     *       SV(L1,L1),SAOMO(L1,L1)
      INTEGER IWRK(L2)
C
C     -------------------------------------------------------
C     SEE LOCAL_PPASVD ROUTINE FOR ANALOGOUS COMMENTS.
C     -------------------------------------------------------
C
C     SETUP NAME FOR TOTAL # OF CORE ORBITALS = NCORTOT
C     NOTE:  EASY TO RE-DEFINE # OF CORES IF NEEDED.
      NCORTOT=NCORSV
C
C     READ IN THE DESIRED ORBITALS.
      CALL DAREAD(IDAF,IODA,VOLD,L3,IORBF1,0)
C
C     SV=S*V=AO BASIS OVERLAP*AO COEFFS WITH INNER CONTRACTIN OVER ALL ATOMS.
C     GET AND SAVE SV FOR ALL ATOMS
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL MTARBR(S,L1,VOLD,L0,SV,L1,1)
C
C     VCLR (CORE) NONROTHOGONAL QUASI-ATOMIC ORBITAL TRANSFORMATION.
      CALL VCLR(VSAV,1,L3)
C
C     LOOP OVER ALL ATOMS
      DO 100 IATM1=1,NAT
C
C       SKIP IF NUMCOR1=0.
        NUMCOR1=NVVOS_NUMCOR(IATM1,1)
        IF(NUMCOR1.EQ.0) GO TO 100
C
C       SET UP BASIS SET DIMENSION FOR IATM1.
        IBAS1=LIMLOW(IATM1)
        IBAS2=LIMSUP(IATM1)
        ILTH=IBAS2-IBAS1+1
C
C       (UNFOLDED FORM) OBTAIN S_IATM1**(-1/2) ON IATM1
        DO I=1,L2
          IWRK(I) = (I*I-I)/2
        ENDDO
        CALL VCLR(S2,1,L2)
        IJ2=1
        DO I=IBAS1,IBAS2
          DO J=IBAS1,I
            IJ=IWRK(I) + J
            S2(IJ2)=S(IJ)
            IJ2=IJ2+1
          ENDDO
        ENDDO
        IERR2=0
        CALL VCLR(VTMP,1,L3)
        CALL GLDIAG(L1,ILTH,ILTH,S2,WRKSVD,EIG,VTMP,IERR2,IWRK)
        IF(IERR2.GT.0) GO TO 8999
        IERR3=0
        DO I=1,ILTH
          IF(EIG(I).LT.TOL) IERR3=IERR3+1
          EIG(I)=ONE/SQRT(EIG(I))
C          WRITE(IW,*) "IATM1,I,EIG=",IATM1,I,EIG(I)
        ENDDO
        IF(IERR3.GT.0) GO TO 8999
        CALL VCLR(UVEC,1,L3)
        DO I=1,ILTH
          DO J=1,ILTH
            UVEC(I,J)=VTMP(J,I)
            UVEC(J,I)=VTMP(I,J)
          ENDDO
        ENDDO
        DO I=1,ILTH
          CALL DSCAL(ILTH,EIG(I),VTMP(1,I),1)
        ENDDO
C       DO MATVEC TO S_IATM1**(-1/2)
        CALL VCLR(SAOMO,1,L3)
        CALL MRARBR(VTMP,L1,ILTH,ILTH,UVEC,L1,ILTH,SAOMO,L1)
        CALL DCOPY(L3,SAOMO,1,VTMP,1)
C
C       SAOMO= OVERLAP MATRIX B/T CORE MO AND AOS ON IATM1.
        CALL VCLR(UVEC,1,L3)
        DO IMO=1,NCORTOT
          CALL DCOPY(ILTH,SV(IBAS1,IMO),1,UVEC(1,IMO),1)
        ENDDO
        CALL VCLR(SAOMO,1,L3)
        CALL MRARBR(VTMP,L1,ILTH,ILTH,UVEC,L1,NCORTOT,SAOMO,L1)
C
C       PERFORM SVD FOR IATM1
        CALL VCLR(UVEC,1,L3)
        CALL VCLR(VTVEC,1,L0*L0)
        CALL VCLR(EIG,1,L1)
        CALL DGESVD('A','A',
     *              ILTH,NCORTOT,SAOMO,L1,EIG,
     *              UVEC,L1,VTVEC,L0,
     *              WRKSVD,ISIZSVD,INFO)
C
C       FORM TRANSFORMATION MATRIX VTVEC-TRANS FOR THE NEWLY PROJECTED MOS.
        CALL TRPOSQ(VTVEC,L0)
C
C       FORM AND SAVE VNEW
        NUMCOR1=NVVOS_NUMCOR(IATM1,1)
        CALL MRARBR(VOLD,L1,L1,NCORTOT,
     *              VTVEC,L0,NUMCOR1,
     *              VCOR(1,1,IATM1),L1)
C
C       GRAB OUT THE (CORE) NONORTHOGONAL QUASI-ATOMIC ORBITAL TRANSFORMATION.
C       NOTE:  COULD RE-WRITE THIS PART LATER.
        IHACT=0
        DO I=1,IATM1-1
          IHACT=IHACT+NVVOS_NUMCOR(I,1)
        ENDDO
        DO I=1,NUMCOR1
          IHACT=IHACT+1
          CALL DCOPY(NCORTOT,VTVEC(1,I),1,VSAV(1,IHACT),1)
        ENDDO
C
C     END LOOP OVER ALL ATOMS
  100 CONTINUE
C
C     SAVE THE (CORE) NONORTHOGONAL QUASI-ATOMIC ORBITAL TRANSFORMATION.
      CALL DAWRIT(IDAF,IODA,VSAV,L3,523,0)
C
C
C
C
C     FORM SV=NEW OVERLAP B/T NEW MO ORBITALS FROM VCOR ARRAY.
      CALL VCLR(UVEC,1,L3)
      CALL VCLR(SV,1,L3)
      CALL DAREAD(IDAF,IODA,SV,L3,IORBF1,0)
C
      IHACT=0
      DO I=1,NAT
        NUMCOR1=NVVOS_NUMCOR(I,1)
        DO J=1,NUMCOR1
          JHACT=IHACT+J
          CALL DCOPY(L1,VCOR(1,J,I),1,UVEC(1,JHACT),1)
        ENDDO
        IHACT=IHACT+NUMCOR1
      ENDDO
C
      CALL DAWRIT(IDAF,IODA,UVEC,L3,522,0)
C
      CALL VCLR(SV,1,L3)
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL MTARBR(S,L1,UVEC,NCORTOT,SV,L1,1)
      CALL MRTRBR(UVEC,L1,L1,NCORTOT,SV,L1,NCORTOT,VTMP,L1)
C
C     FORM VTMP=[ NEW SMO**(-1/2) ] VIA SYM. ORTHOGONALIZATION.
C     HERE INITIAL VTMP=NEW MO OVERLAPS.
      DO I=1,L2
        IWRK(I) = (I*I-I)/2
      ENDDO
      CALL VCLR(S2,1,L2)
      IJ2=1
      DO I=1,NCORTOT
        DO J=1,I
          S2(IJ2)=VTMP(I,J)
          IJ2=IJ2+1
        ENDDO
      ENDDO
      IERR2=0
      CALL VCLR(VTMP,1,L3)
      CALL GLDIAG(L1,NCORTOT,NCORTOT,S2,WRKSVD,EIG,VTMP,IERR2,IWRK)
      IF(IERR2.GT.0) GO TO 8999
      IERR3=0
      DO I=1,NCORTOT
        IF(EIG(I).LT.TOL) IERR3=IERR3+1
        EIG(I)=ONE/SQRT(EIG(I))
C       WRITE(IW,*) "IATM1,I,EIG=",IATM1,I,EIG(I)
      ENDDO
      IF(IERR3.GT.0) GO TO 8999
      DO I=1,NCORTOT
        DO J=1,NCORTOT
          SV(I,J)=VTMP(J,I)
          SV(J,I)=VTMP(I,J)
        ENDDO
      ENDDO
      DO I=1,NCORTOT
        CALL DSCAL(NCORTOT,EIG(I),VTMP(1,I),1)
      ENDDO
C     DO MATVEC TO S_IATM1**(-1/2)
      CALL VCLR(SAOMO,1,L3)
      CALL MRARBR(VTMP,L1,NCORTOT,NCORTOT,SV,L1,NCORTOT,SAOMO,L1)
      CALL DCOPY(L3,SAOMO,1,VTMP,1)
C
C     FORM UVEC * [VTMP = NEW SMO**(-1/2)] MATVEC
C     THIS NEXT PIECE ORTHOGONALIZES THE ALREADY PROJECTED MOS.
      CALL VCLR(SV,1,L3)
      CALL MRARBR(UVEC,L1,L1,NCORTOT,VTMP,L1,NCORTOT,SV,L1)
C     SAVE THE ORTHOGONAL QUASI-ATOMIC ORBITAL TRANSFORMATION NOW.
      CALL DAWRIT(IDAF,IODA,VTMP,L3,524,0)
      CALL DAREAD(IDAF,IODA,VTMP,L3,IORBF1,0)
      DO I=1,NCORTOT
        CALL DCOPY(L1,SV(1,I),1,VTMP(1,I),1)
      ENDDO
C     SAVE THE (CORE) ORTHOGONAL QUASI-ATOMIC ORBITALS.
      CALL DAWRIT(IDAF,IODA,VTMP,L3,521,0)
C
C
C
C
C     PERFORM FINAL ERROR OUTS.
 8999 CONTINUE
      IF(MASWRK) THEN
        IF(IERR2.GT.0) THEN
          WRITE(IW,9003)
        ELSEIF(IERR3.GT.0) THEN
          WRITE(IW,9004) IERR3
        ENDIF
      ENDIF
      IF(IERR2.GT.0
     *  .OR.IERR3.GT.0
     *  ) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9003 FORMAT(1X,'*** ERROR IN LOCAL_PPASVDCORE ROUTINE.'/
     *       1X,'ERROR OCCURS FOR GLDIAG CALL.')
 9004 FORMAT(1X,'*** ERROR IN LOCAL_PPASVDCORE ROUTINE.'/
     *       1X,'IN SYMMETRIC ORTHOG.,'/
     *       1X,I4,' EIGENVALUES ARE BELOW TOL.')
      END
C*MODULE LOCAL   *DECK LOCAL_PPASVD
c> @brief      Routine makes SVD-localized valence orbitals.
c>
c> @author     Aaron West and Klaus Ruedenberg
c>             -November 4, 2012
c>
c> @details    Routine makes SVD-localized core orbitals.
c>
c> @date November 16, 2012-Aaron West
c> -Removed some error outs for vtvec.  Symmetric molecules
c>  can have zeros here even in C1 point group.
c>  This error out was mainly for debugging bad code.
c>
c> @param NCORTOT is total number of MCSCF core orbitals.
c> @param IORBF1 is the dat dict file for initial orbitals.
c> @param S2 stores AO basis overlaps on each atom.
c> @param S stores all the AO basis overlaps.
c> @param UVEC is the u matrix in SVD.
c> @param EIG holds eigenvalues from SVD.
c> @param VTVEC is the V-transpose matrix in SVD.
c> @param WRKSVD is the work array designed for gldiag and svd calls.
c> @param IWRK is the integer work array used
c>                    -- for symmetric matrix indices
c>                    -- for gldiag calls
c> @param VOLD contains the AO coefficients from IORBF1 daf dict file.
c> @param VNACT holds AO coefficients for valence orbitals.
c> @param VTMP is temporary storage.
c> @param VSAV is temporary storage.
c> @param SV holds the AO basis overlap times AO coefficients matvec.
c> @param SAOMO is often S_IATM1**(-1/2) * SV on each IATM1 atom.
c> @param ISIZSVD is the workspace size for WRKSVD array.
c> @param NACT is the total number of active orbitals.
c> @param L0 is the length of the MO variational space.
c> @param L1 is the length of the AO coefficients.
c> @param L2 is the triangular length of L1.
c> @param L3 is the square of L1.
c> @param MSTA         contains the starting orbitals for each
c>                     ORMAS group, or subspace.
c> @param ISIZE_FCCWFN is current size of fccwfn integer arrays.
c> @param NSPACE       is the number ORMAS groups.
c> @param CISTEP       is the kind of CI performed e.g. ormas,aldet.
c> @param LIMLOW array contains the lower basis function on an atom.
c> @param LIMSUP array contains the upper basis function on an atom.
c> @param NAT is the number of atoms.
c> @param IATMSTA      is an array that defines sets of atoms and
c>                     orbitals to localized based on natmor input.
c> @param IATMSTA2     is for catching bugs across to local_ppasvd.
c> @param MASWRK indicates the master process.
c> @todo  Routine might need gram-schmidt orthogonalization
c>        instead of symmetric orthogonalization.
c>        Error outs will indicate.
      SUBROUTINE LOCAL_PPASVD(
     *     NCORTOT,IORBF1,S2,
     *     S,UVEC,EIG,VTVEC,
     *     WRKSVD,IWRK,
     *     VOLD,VNACT,VTMP,VSAV,
     *     SV,SAOMO,
     *     ISIZSVD,NACT,L0,L1,L2,L3,
     *     MSTA,ISIZE_FCCWFN,NSPACE,CISTEP,
     *     LIMLOW,LIMSUP,NAT,IATMSTA,IATMSTA2,MASWRK)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL MASWRK,KEEPER
      INTEGER MXATM
      PARAMETER (MXATM=2000)
      DOUBLE PRECISION :: ONE,TOL,CISTEP,ORMAS
      PARAMETER (ONE=1.0D+00, TOL=1.0D-06)
      INTEGER NAT,LIMLOW(MXATM),LIMSUP(MXATM)
      INTEGER I,IATM1,IBAS1,IBAS2,IERR0,IERR1,IERR2,IERR3,IHACT,
     *        ILTH,IORBF1,ISIZSVD,J,JHACT,L0,L1,L2,L3,
     *        JHACT2,NACT,NCORTOT,NUMVAL1,IJ,IJ2,
     *        LOCAL_NUMVAL
      INTEGER ICOL1,ICOL2,IROW,JORB1,JORB2,ITMP,III,JJJ
      INTEGER NSPACE,ISPACE,NACTFIN,ISIZE_FCCWFN
C     NEW CODING STANDARDS VARS
      INTEGER IDAF,INFO,IODA,IP,IPK,IR,IS,IW,NAV
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C-----------------------------------------------------------------------
      DOUBLE PRECISION ::
     *       S2(L2),S(L2),
     *       UVEC(L1,L1),EIG(L1),VTVEC(L0,L0),
     *       WRKSVD(ISIZSVD),
     *       VOLD(L1,L1),VTMP(L1,L1),VSAV(L1,L1),
     *       VNACT(L1,NACT,NAT),
     *       SV(L1,L1),SAOMO(L1,L1)
      INTEGER IWRK(L2),
     *        IATMSTA2(NSPACE,NAT),IATMSTA(NSPACE,NAT),
     *        MSTA(ISIZE_FCCWFN)
C
C     DEFINE SOME DATA STUFF
      DATA ORMAS /8HORMAS   /
      KEEPER=CISTEP.EQ.ORMAS.AND.NSPACE.GT.1
C------------------------------------------------------------
C------------------------------------------------------------
C
C     A FEW LAST CHECKS JUST TO BE SURE.
C     NOTE:  THIS NEXT CHECK IS IMPORTANT.  PLEASE KEEP IT.
      IF(KEEPER) THEN
        IF(MASWRK) WRITE(IW,9000)
        IERR0=0
        DO I=1,NSPACE
          DO J=1,NAT
            ITMP=IATMSTA2(I,J)
            IF(ITMP.NE.0.AND.ITMP.NE.1) IERR0=IERR0+1
          ENDDO
        ENDDO
        IF(IERR0.GT.0) GO TO 8999
      ENDIF
C
      ITMP=0
      DO I=1,NAT
        NUMVAL1=LOCAL_NUMVAL(I)
        ITMP=ITMP+NUMVAL1
      ENDDO
      IERR1=0
      IF(ITMP.NE.NACT) IERR1=1
      IF(IERR1.EQ.1) GO TO 8999
C
C     ALLRIGHT.  LAST CHECKS DONE.
C     FIRST CHECK HAS A GOOD CHANCE OF FINDING ANY FUTURE MEMORY ISSUES.
C------------------------------------------------------------
C------------------------------------------------------------
C
C     RE-DEFINE IATMSTA2 ARRAY.
C     IATMSTA2 = STARTING ORBITAL ON PARTICULAR ATOM.
C     IATMSTA  = ALREADY CONTAINS NUMBER OF SVD ORBITALS TO EXTRACT.
C                ...NOT THE SIZE OF THE SVD MATRIX...
      IF(KEEPER) THEN
        CALL VICLR(IATMSTA2,1,NSPACE*NAT)
        DO I=1,NSPACE
          JHACT=MSTA(I)
          DO J=1,NAT
            IF(IATMSTA(I,J).NE.0) THEN
              IATMSTA2(I,J)=JHACT
              JHACT=JHACT+IATMSTA(I,J)
            ENDIF
          ENDDO
        ENDDO
      ENDIF
C------------------------------------------------------------
C     CONTINUE WITH CHUNKS OF ORIGINALLY INTENDED ROUTINE...
C------------------------------------------------------------
C
C     READ IN THE DESIRED ORBITALS.
      CALL DAREAD(IDAF,IODA,VOLD,L3,IORBF1,0)
C
C     SV=S*V=AO BASIS OVERLAP*AO COEFFS WITH INNER CONTRACTIN OVER ALL ATOMS.
C     GET AND SAVE SV FOR ALL ATOMS
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL MTARBR(S,L1,VOLD,L0,SV,L1,1)
C
C     READ IN THE (CORE) NONROTHOGONAL QUASI-ATOMIC ORBITAL TRANSFORMATION.
      CALL DAREAD(IDAF,IODA,VSAV,L3,523,0)
C
C     LOOP OVER ALL ATOMS
C     NOTE:  SEPARATE CASES WITH 1 DIM.
      DO 100 IATM1=1,NAT
C
C       SET UP BASIS SET DIMENSION FOR IATM1.
        IBAS1=LIMLOW(IATM1)
        IBAS2=LIMSUP(IATM1)
        ILTH=IBAS2-IBAS1+1
C
C       SET UP NUMBER OF VALENCE ORBITALS FOR IATM1.
        NUMVAL1=LOCAL_NUMVAL(IATM1)
        IF(NUMVAL1.EQ.0) GO TO 100
C
C       (UNFOLDED FORM) OBTAIN S_IATM1**(-1/2) ON IATM1
C       --FORM SYM ARRAY
C       --COPY OUT TO POS 1--> 'L2'
C       --GLDIAG CALL
C       --SQRT AND INVERT EIG ARRAY
C       --MAKE TRANSPOSE OF EVECTORS
C       --SCALE ORIG. MATRIX
C       --PERFORM NEEDED MATVEC TO INVERSE
        DO I=1,L2
          IWRK(I) = (I*I-I)/2
        ENDDO
        CALL VCLR(S2,1,L2)
        IJ2=1
        DO I=IBAS1,IBAS2
          DO J=IBAS1,I
            IJ=IWRK(I) + J
            S2(IJ2)=S(IJ)
            IJ2=IJ2+1
          ENDDO
        ENDDO
        IERR2=0
        CALL VCLR(VTMP,1,L3)
        CALL GLDIAG(L1,ILTH,ILTH,S2,WRKSVD,EIG,VTMP,IERR2,IWRK)
        IF(IERR2.GT.0) GO TO 8999
        IERR3=0
        DO I=1,ILTH
          IF(EIG(I).LT.TOL) IERR3=IERR3+1
          EIG(I)=ONE/SQRT(EIG(I))
C         WRITE(IW,*) "IATM1,I,EIG=",IATM1,I,EIG(I)
        ENDDO
        IF(IERR3.GT.0) GO TO 8999
        CALL VCLR(UVEC,1,L3)
        DO I=1,ILTH
          DO J=1,ILTH
            UVEC(I,J)=VTMP(J,I)
            UVEC(J,I)=VTMP(I,J)
          ENDDO
        ENDDO
        DO I=1,ILTH
          CALL DSCAL(ILTH,EIG(I),VTMP(1,I),1)
        ENDDO
C       DO MATVEC TO S_IATM1**(-1/2)
        CALL VCLR(SAOMO,1,L3)
        CALL MRARBR(VTMP,L1,ILTH,ILTH,UVEC,L1,ILTH,SAOMO,L1)
        CALL DCOPY(L3,SAOMO,1,VTMP,1)
C
C       SAOMO= OVERLAP MATRIX B/T ACTIVE MO AND AOS ON IATM1.
C       SAOMO= (VTMP orthog matrix on one atom)
C            * (SV already contracted over all atoms)
C              i.e.  contract inner index over one atom
C       --GET OUT SV ELEMENTS FOR IATM1.
C       --CONTRACT OVER INNER AO ELEMENTS ON IATM1.
C------------------------------------------------------------
C       INITIALIZE NSPACE FOR ALDET TO AVOID COMPLAINTS
C       NOTE: EVEN THOUGH THE DIM WAS ALREADY DEFINED TO BE 1.
        IF(CISTEP.NE.ORMAS) NSPACE=1
C       THE ORMAS LOOP
        DO 90 ISPACE=1,NSPACE
          IF(KEEPER.AND.IATMSTA(ISPACE,IATM1).EQ.0) GO TO 90
C------------------------------------------------------------
C         DEFINE NACTFIN
C         DEFINE ITEMS NEEDED FOR UVEC COPY
C         DEFINE UVEC
          CALL VCLR(UVEC,1,L3)
          IF(KEEPER) THEN
            NACTFIN=MSTA(ISPACE+1)-MSTA(ISPACE)
            JORB1=MSTA(ISPACE)
            JORB2=MSTA(ISPACE+1)-1
          ELSE
            NACTFIN=NACT
            JORB1=NCORTOT+1
            JORB2=NCORTOT+NACT
          ENDIF
          III=1
          DO JJJ=JORB1,JORB2
            CALL DCOPY(ILTH,SV(IBAS1,JJJ),1,UVEC(1,III),1)
            III=III+1
          ENDDO
C------------------------------------------------------------
C         FINISH FORMING THE SAOMO OVERLAP MATRIX.
          CALL VCLR(SAOMO,1,L3)
          CALL MRARBR(VTMP,L1,ILTH,ILTH,UVEC,L1,NACTFIN,SAOMO,L1)
C------------------------------------------------------------
C
C         PERFORM SVD FOR IATM1
          CALL VCLR(UVEC,1,L3)
          CALL VCLR(VTVEC,1,L0*L0)
          CALL VCLR(EIG,1,L1)
          CALL DGESVD('A','A',
     *                ILTH,NACTFIN,SAOMO,L1,EIG,
     *                UVEC,L1,VTVEC,L0,
     *                WRKSVD,ISIZSVD,INFO)
C-------------------------------------------------------------
C
C         FORM (NACTFIN,NACTFIN) VTVEC-TRANS MATRIX
C         EVEN IF ILTH<NACTFIN. 
          CALL TRPOSQ(VTVEC,L0)
C-------------------------------------------------------------
C
C         FORM AND SAVE VNEW
C         --> (L1,NACTFIN)*(NACTFIN,NUMVAL1)
C         --> HERE WE USE ONLY THE COLUMNS
C         --> WITH THE LARGEST EIGS FROM SVD.
C         --> VCLR TO SEE DIMS WORK OUT IF NEEDED.
C         --> NUMVAL1 IS THE NUMBER OF ALLOWED
C                     VALENCE ORBITALS ON A GIVEN ATOM.
C
          IF(KEEPER) THEN
            CALL VCLR(UVEC,1,L3)
            CALL VCLR(SAOMO,1,L3)
            III=1
            DO JJJ=JORB1,JORB2
              CALL DCOPY(L1,VOLD(1,JJJ),1,SAOMO(1,III),1)
              III=III+1
            ENDDO
            NUMVAL1=IATMSTA(ISPACE,IATM1)
            CALL MRARBR(SAOMO,L1,L1,NACTFIN,VTVEC,L0,NUMVAL1,UVEC,L1)
            DO I=1,NUMVAL1
              IROW =MSTA(ISPACE)
              ICOL1=IATMSTA2(ISPACE,IATM1)+I-1
              ICOL2=ICOL1-NCORTOT
              CALL DCOPY(NACTFIN,VTVEC(1,I),1,VSAV(IROW,ICOL1),1)
              CALL DCOPY(L1,UVEC(1,I),1,VNACT(1,ICOL2,1),1)
            ENDDO
          ELSE
            NUMVAL1=LOCAL_NUMVAL(IATM1)
            CALL MRARBR(VOLD(1,NCORTOT+1),L1,L1,NACTFIN,
     *                  VTVEC,L0,NUMVAL1,
     *                  VNACT(1,1,IATM1),L1)
C
C           GRAB OUT THE (VALENCE) NONORTHOGONAL QUASI-ATOMIC
C                                ORBITAL TRANSFORMATION.
            IHACT=NCORTOT
            DO I=1,IATM1-1
              IHACT=IHACT+LOCAL_NUMVAL(I)
            ENDDO
            NUMVAL1=LOCAL_NUMVAL(IATM1)
            DO I=1,NUMVAL1
              IHACT=IHACT+1
              CALL DCOPY(NACTFIN,VTVEC(1,I),1,VSAV(NCORTOT+1,IHACT),1)
            ENDDO
          ENDIF
C------------------------------------------------------------
C
C       END LOOP OVER ORMAS GROUPS
   90   CONTINUE
C------------------------------------------------------------
C
C     END LOOP OVER ALL ATOMS
  100 CONTINUE
C
C
C
C
C
C     FORM SV=NEW OVERLAP B/T NEW MO ORBITALS FROM VNACT ARRAY.
C     --PUT VNACT(1,1,xxx) ORBITALS (ALL NACT OF THEM) INTO UVEC AND SV ARRAYS
C     ------READ IN THE NONORTHOGONAL LOCALIZED MCSCF CORES FROM FILE 522
C     ------KEEP UVEC ARRAY FOR BIT.
C     --READ IN S AGAIN
C     --MAKE SV
C     --MAKE UNFOLDED MO OVERLAP [ I.E. (V-TRANS)*(SV) ] AND PUT IN VTMP 
      CALL VCLR(UVEC,1,L3)
      CALL VCLR(SV,1,L3)
      CALL DAREAD(IDAF,IODA,SV,L3,522,0)
C
      IF(KEEPER) THEN
C       ORMAS NSPACE>1
C       ---FOR ORMAS, WE DID MOVE ORBITALS BACK INTO ORMAS GROUPS.
        IF(MASWRK) WRITE(IW,9060)
        DO I=1,NACT
          CALL DCOPY(L1,VNACT(1,I,1),1,UVEC(1,I),1)
          CALL DCOPY(L1,VNACT(1,I,1),1,SV(1,NCORTOT+I),1)
        ENDDO
      ELSE
C       CASES:  ORMAS NSPACE=1 + CASSCF
        IHACT=0
        DO I=1,NAT
          NUMVAL1=LOCAL_NUMVAL(I)
          DO J=1,NUMVAL1
            JHACT=IHACT+J
            JHACT2=IHACT+J+NCORTOT
            CALL DCOPY(L1,VNACT(1,J,I),1,UVEC(1,JHACT),1)
            CALL DCOPY(L1,VNACT(1,J,I),1,SV(1,JHACT2),1)
          ENDDO
          IHACT=IHACT+NUMVAL1
        ENDDO
      ENDIF



C
C     AT THIS POINT, WE ARE ALL DONE WITH ATOMIC-LIKE ORBITAL
C                    REORDERING IN THIS ROUTINE.



C
C     SAVE THE NONORTHOGONAL QUASI-ATOMIC ORBITAL TRANSFORMATION.
      DO I=NCORTOT+NACT+1,L0
        VSAV(I,I)=1.0D+00
      ENDDO
      CALL DAWRIT(IDAF,IODA,VSAV,L3,523,0)
C
C     SAVE THE NONORTHOGONAL ORBITALS
      CALL DAWRIT(IDAF,IODA,SV,L3,522,0)
C
      CALL VCLR(SV,1,L3)
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL MTARBR(S,L1,UVEC,NACT,SV,L1,1)
      CALL MRTRBR(UVEC,L1,L1,NACT,SV,L1,NACT,VTMP,L1)
C
C     FORM VTMP=[ NEW SMO**(-1/2) ] VIA SYM. ORTHOGONALIZATION.
C     HERE INITIAL VTMP=NEW MO OVERLAPS.
C     --UVEC REMAINS UNTOUCHED AS THE AO COEFFS OF THE NACT ACTIVE MOS
C     --PUT VTMP INTO SYM. FORM INTO S2
C     --TRASH VTMP AND REPLACE WITH EVECTORS.
C     --TRASH SV AND REPLACE WITH VTMP-TRANS
      DO I=1,L2
        IWRK(I) = (I*I-I)/2
      ENDDO
      CALL VCLR(S2,1,L2)
      IJ2=1
      DO I=1,NACT
        DO J=1,I
          S2(IJ2)=VTMP(I,J)
          IJ2=IJ2+1
        ENDDO
      ENDDO
      IERR2=0
      CALL VCLR(VTMP,1,L3)
      CALL GLDIAG(L1,NACT,NACT,S2,WRKSVD,EIG,VTMP,IERR2,IWRK)
      IF(IERR2.GT.0) GO TO 8999
      IERR3=0
      DO I=1,NACT
        IF(EIG(I).LT.TOL) IERR3=IERR3+1
        EIG(I)=ONE/SQRT(EIG(I))
C       WRITE(IW,*) "IATM1,I,EIG=",IATM1,I,EIG(I)
      ENDDO
      IF(IERR3.GT.0) GO TO 8999
      DO I=1,NACT
        DO J=1,NACT
          SV(I,J)=VTMP(J,I)
          SV(J,I)=VTMP(I,J)
        ENDDO
      ENDDO
      DO I=1,NACT
        CALL DSCAL(NACT,EIG(I),VTMP(1,I),1)
      ENDDO
C     DO MATVEC TO S_IATM1**(-1/2)
      CALL VCLR(SAOMO,1,L3)
      CALL MRARBR(VTMP,L1,NACT,NACT,SV,L1,NACT,SAOMO,L1)
      CALL DCOPY(L3,SAOMO,1,VTMP,1)
C
C     SAVE THE ORTHOGONAL QUASI-ATOMIC ORBITAL TRANSFORMATION NOW.
      CALL DAREAD(IDAF,IODA,SAOMO,L3,524,0)
      DO I=1,NACT
        CALL DCOPY(NACT,VTMP(1,I),1,SAOMO(NCORTOT+1,NCORTOT+I),1)
      ENDDO
      DO I=NCORTOT+NACT+1,L0
        SAOMO(I,I)=1.0D+00
      ENDDO
      CALL DAWRIT(IDAF,IODA,SAOMO,L3,524,0)
C
C     FORM UVEC * [VTMP = NEW SMO**(-1/2)] MATVEC
C     THIS NEXT PIECE ORTHOGONALIZES THE ALREADY PROJECTED MOS.
C     --UVEC REMAINS UNTOUCHED AS THE AO COEFFS OF THE NACT ACTIVE MOS
C     --VTMP IS THE (NACT,NACT) ORTHOGONALIZING TRANSFORMATION.
C     --PERFORM MATVEC AND PUT RESULT INTO SV
C     --READ IORBF1 ORBITALS AGAIN JUST IN CASE
C     --REPLACE THE OLD NACT IORBF1 MOS BY THE NEW MOS IN SV
      CALL VCLR(SV,1,L3)
      CALL MRARBR(UVEC,L1,L1,NACT,VTMP,L1,NACT,SV,L1)
      CALL DAREAD(IDAF,IODA,VTMP,L3,521,0)
      DO I=1,NACT
        J=NCORTOT+I
        CALL DCOPY(L1,SV(1,I),1,VTMP(1,J),1)
      ENDDO
C
C
C
C     WRITE OUT NEW ORTHOGONAL QUASI-ATOMIC ORBITALS TO FILE 521
      CALL DAWRIT(IDAF,IODA,VTMP,L3,521,0)
C
C     PRINT OUT FINAL ORIENTED ORBITALS TO GAMESS .LOG FILE.
C-----PRINT OUT CORES+VALENCE ORBITALS ONLY.
ckeep---      Remove the below line and print out nonorthogonal orbitals.
ckeep---      CALL DAREAD(IDAF,IODA,VTMP,L3,522,0)
      IF(MASWRK) THEN
        WRITE(IW,9070)
ckeep---        Uncomment the write statement.
ckeep---        Check that orient=.f. in the input.
ckeep---        Now, one can view the SVD orbitals for any checks
ckeep---        to what gets put into daf file 71. 
ckeep---        Uncomment the next line.
ckeep---        WRITE(IW,9071)
        CALL PRSQL(VTMP,NCORTOT+NACT,L1,L1)
      ENDIF
C
C     PRINT OUT ORBITALS TO .DAT FILE.
C-----PRINT OUT CORES+VALENCE ORBITALS ONLY.
      IF(MASWRK) THEN
        WRITE(IP,9080)
        CALL PUSQL(VTMP,NCORTOT+NACT,L1,L1)
        WRITE(IP,9085)
      ENDIF
C
C
C
C
C     CONSTRUCT AND SAVE THE OVERALL ORBITAL TRANSFORMATION
C     FROM IORBF1 ORBITALS TO ORTHOGONAL PPASVD ORBITALS.
      CALL VCLR(VOLD,1,L3)
      CALL DAREAD(IDAF,IODA,VTMP,L3,523,0)
      CALL DAREAD(IDAF,IODA,VSAV,L3,524,0)
      CALL MRARBR(VTMP,L1,L0,L0,VSAV,L1,L0,VOLD,L1)
      CALL DAWRIT(IDAF,IODA,VOLD,L3,525,0)
C
C
C
C
C     PERFORM FINAL ERROR OUTS.
 8999 CONTINUE
      IF(MASWRK) THEN
        IF(IERR0.GT.0) THEN
          WRITE(IW,9001)
        ELSEIF(IERR1.GT.0) THEN
          WRITE(IW,9002)
        ELSEIF(IERR2.GT.0) THEN
          WRITE(IW,9003)
        ELSEIF(IERR3.GT.0) THEN
          WRITE(IW,9004) IERR3
        ENDIF
      ENDIF
      IF(IERR0.GT.0
     *  .OR.IERR1.GT.0
     *  .OR.IERR2.GT.0
     *  .OR.IERR3.GT.0
     *  ) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9000 FORMAT(1X,'LAST IATMSTA CHECK IS DONE.')
 9001 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'SOME ISSUE WITH IATMSTA ARRAY VALUES.  FIX IT.')
 9002 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'NACT MUST EQUAL NUMBER OF MBS VALENCE ORBITALS.')
 9003 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'ERROR OCCURS FOR GLDIAG CALL.')
 9004 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'IN SYMMETRIC ORTHOG., '
     *       1X,I4,' EIGENVALUES ARE BELOW TOL.')
 9060 FORMAT(/1X,'LOCAL_PPASVD KEEPS ORBITALS WITHIN',
     *        1X,'ORMAS SUBSPACES.',
     *       /1X,'ORIENTATION DESTROYS THIS ITEM.  REORGANIZE THEN.')
 9070 FORMAT(/1X,'PPASVD LOCALIZED ORBITALS')
ckeep--- 9071 FORMAT(//10X,'ORIENTED LOCALIZED ORBITALS')
 9080 FORMAT('PPASVD LOCALIZED ORBITALS'/' $VEC')
 9085 FORMAT(' $END')
      END
C*MODULE LOCAL   *DECK LOCAL_PPADEN
c> @brief      Routine forms density in orthogonal quasi-atomic MO basis.
c>
c> @author     Aaron West and Klaus Ruedenberg
c>             -November 4, 2012
c>
c> @details    Routine forms density in orthogonal quasi-atomic MO basis.
c>             The density of the canonical orbitals in daf dict. file 15
c>             is transformed over to the orthogonal quasi-atomic MO basis.
c>             Please also see MALMQ_DEN for any information
c>             on orbital re-ordering.
c>
c> @param VTMP holds the overall orthogonal orbital transformation.
c> @param DEN contains the original density in the canonical MO basis.
c> @param DEN2 will hold the transformed density.
c> @param SCR is workspace for the transformation.
c> @param NCORTOT is the total number of MCSCF core orbitals.
c> @param NACT is the total number of MCSCF active oribtals.
c> @param L1 is the length of the AO coefficients.
c> @param L3 is the square of L1.
c> @param MASWRK indicates master process.
      SUBROUTINE LOCAL_PPADEN(
     *           VTMP,DEN,DEN2,SCR,
     *           NCORTOT,NACT,L1,L3,MASWRK)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL MASWRK
      INTEGER L1,L3,NCORTOT,NACT,NACT2 
C     NEW CODING STANDARDS VARS
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C----------------------------------------------------------------------
      DOUBLE PRECISION ::
     *       VTMP(L1,L1),DEN(L3),DEN2(L3),SCR(L3)
C
C     DAF FILE  68 CONTAINS THE DENSITY IN THE CANONICAL MO BASIS.
C     DAF FILE 320 CONTAINS THE DENSITY IN THE CANONICAL MO BASIS
C                  OVER ACTIVE ORBITALS
C
C     DEFINE SOME NEEDED DIMENSIONS.
      NACT2 = (NACT*NACT+NACT)/2
C
C     READ IN THE DENSITY IN THE BASIS OF CANONICAL ORBITALS.
      CALL DAREAD(IDAF,IODA,DEN,NACT2,320,0)
C
C     READ IN THE OVERALL ORTHOGONAL QUASI-ATOMIC ORBITAL TRANSFORMATION.
      CALL DAREAD(IDAF,IODA,VTMP,L3,525,0)
C
C     TRANSFORM THE DENSITY BY BLOCK-DIAGONAL TRANFORMATION:
C     NEW ORBS = ORIG ORBS * VTMP
C     NEW DENSITY = VTMP-TRANS * DEN * VTMP
C     --SAVE DENSITY MATRIX
C     ----FILE 526 FOR KEEPS
C     ----FILE 285 FOR ORIENTATION
      CALL TFTRI(DEN2,DEN,VTMP(NCORTOT+1,NCORTOT+1),SCR,
     *           NACT,NACT,L1)
      CALL DAWRIT(IDAF,IODA,DEN2,NACT2,526,0)
      CALL DAWRIT(IDAF,IODA,DEN2,NACT2,285,0)
C
C     PRINT OUT THE DENSITY.
      IF(MASWRK) THEN
        WRITE(IW,9000)
        CALL PRTRI(DEN2,NACT)
      ENDIF
C
      RETURN
 9000 FORMAT(/1X,'DENSITY MATRIX IN THE',
     *        1X,'ORTHOGONAL QUASI-ATOMIC SVD MO BASIS',
     *       /1X,'OVER ACTIVE ORBITALS IS')
      END
C*MODULE LOCAL   *DECK MALMQ_REORDER1
C> @brief      This routine initializes daf files 527 after SVD.
C> 
C> @author     Aaron West
C>             -December 17, 2012
C> 
C> @details    This routine initializes daf files 527 after SVD.
C>             It accounts for differences in orbital orderings
C>             between CASSCF and ORMAS SVD. 
C>
C> @see        MALMQ_REORDER,MALMQ_REORDER2,MALMQ_REORDER_FINAL
C>             MALMQ_GETORB
C>
C> @param NAT    is the number of atoms.
C> @param L1     denotes the length of the AO coefficients.
C> @param IAT    is an integer scratch array of length L1.
C> @param NATMOR is the user input array that creates a correspondence
C>               between an oribital and which atom it resides on.
C> @param NACT   is the number of active orbitals.
C> @param NCORSV is the number of chemical core orbitals.
C> @param KEEPER is a logical that equals true when cistep=ormas and nspace>1.
C> @param SOME   is true for master process with nprint not equal -5.
C>
      SUBROUTINE MALMQ_REORDER1(NAT,L1,IAT,NATMOR,
     *                          NACT,NCORSV,KEEPER,
     *                          SOME)
      IMPLICIT NONE
      LOGICAL KEEPER,SOME
      INTEGER J,LOCAL_NUMVAL,NAT,IHACT,NUMVAL1
      INTEGER I,L1,NCORSV,NACT,NATMOR(L1),IAT(L1)
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
      CALL VICLR(IAT,1,L1)
      IF(KEEPER) THEN
C       ORMAS NSPACE>1
        DO I=1,NACT
          IAT(I)=NATMOR(I+NCORSV)
        ENDDO
      ELSE
C       ORMAS NSPACE=1 + CASSCF
        IHACT=0
        DO I=1,NAT
          NUMVAL1=LOCAL_NUMVAL(I)
          DO J=1,NUMVAL1
            IHACT=IHACT+1
            IAT(IHACT)=I
          ENDDO
        ENDDO
      ENDIF
CKEEP      DAF FILE 531 IS NOW DONE THROUGH LOCAL_DIMOID2.
CKEEP      HOWEVER, I WANT TO SAVE THIS ROUTINE
CKEEP               SO THAT I NEVER HAVE TO FIGURE
CKEEP               THIS OUT AGAIN.
CKEEP      CALL DAWRIT(IDAF,IODA,IAT,NACT,531,1)
C
C     WITHIN SUBSPACES, CAN'T CONTROL ORMAS ORBITAL ORDER.
C     INITIALIZE FILE 527 HERE TO HAVE A 527 FOR DA READS.
      DO I=1,L1
        IAT(I)=I
      ENDDO
      CALL DAWRIT(IDAF,IODA,IAT,L1,527,1)
C
      IF(SOME) WRITE(IW,9000)
C
      RETURN
 9000 FORMAT(/1X,'LOCAL_ORDERS:',
     *        1X,'MALMQ_REORDER1 ROUTINE NOW ALTERS',
     *        1X,'DAF FILES 527 AND 531.')
      END
C*MODULE LOCAL   *DECK MALMQ_REORDER2
C> @brief      This routine updates daf files 527 after orientation.
C> 
C> @author     Aaron West
C>             -December 17, 2012
C> 
C> @details    After orbital orientation, this routine keeps file 527
C>             updated.
C>             Long winded explainations are provided in the 
C>             source code to aid in any future modifications.
C>             It is a good idea to keep and update
C>             the explanations since the information
C>             gathering is a bit spread out.
C> 
C> @see        MALMQ_REORDER,MALMQ_REORDER2,MALMQ_REORDER_FINAL
C>             MALMQ_GETORB
C>
C> @param MAPT   holds orbital swaps from DIMOID
C>               from atomic reorderings.
C> @param MAPT2  holds orbital swaps from ORIEN
C>               from occupation reorderings.
C> @param MAPT3  is integer scratch array of length L1.
C> @param MCORE  is the number of chemical core orbitals.
c> @param NACT   is the number of active orbitals.
c> @param L1     is the length of the AO coefficients.
c> @param MASWRK indicates the master process.
      SUBROUTINE MALMQ_REORDER2(MAPT,MAPT2,MAPT3,
     *                          MCORE,NACT,L1,MASWRK)
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER I,MCORE,NACT,L1
      INTEGER MAPT(NACT),MAPT2(NACT),MAPT3(L1)
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
C     NOTES:
C     ---MAPT STILL HOLDS THE ORBITAL SWITCHES FROM DMOID ROUTINE.
C        I.E. SVD --> ORIENTED 1ST
C     ---UPON EXIT FROM ORIEN, MAPT2 WILL HOLD ORBITAL SWITCHES DUE TO
C        JOE'S OCCUPATION REORDERINGS.
C        I.E. ORIENTED 1ST --> ORIENTED 2ND
C             WHERE 2ND INDICATES OCCUPATION REORDERINGS DONE.
C     ---OUR SVD WAS KEPT IN THE ORDER OF THE CANON. SPACE
C           (EXCEPT FOR THE LOC. INSIDE OF EACH GROUP OF COURSE)
C     ---IN MALMQ_GETORB LATER,
C     ------WE KEEP THE MALMQ ORDERING
C           BUT FORCIBLY REORDER THE ATOM LABELS TO MATCH.
C     ------WE ALSO CHECK THE GROUP LABELS.  IF NEEDED, FORCE ANY BACK.
C     ------IF THE ORIENTATION SWITCHES TWO ORBITALS ON THE SAME ATOM,
C           OUR ATOMIC REORDERING WOULD STILL BE CORRECT!
C           HOWEVER, DAF FILE 531 IS ALL DONE THROUGH LOCAL_DIMOID2 RIGHT NOW.
C     ------DONE WITH MAPT2.
C
C     INITIALIZE MAPT3
      DO I=1,L1
        MAPT3(I)=I
      ENDDO
C
C     APPLY THE OCCUPATION REORDERINGS IN MAPT2 TO MAPT.
      CALL REORDR(MAPT,MAPT2,NACT,1)
C
C     NOW, TO GET ORIENTED 2ND--> SVD, BACK MAP IT.
      CALL ICOPY(NACT,MAPT,1,MAPT2,1)
      DO I=1,NACT
        MAPT(MAPT2(I))=I
      ENDDO
C
C     MOVE FROM ACTIVE INDICES AND ACTIVE VALUES.
C     AND
C     MOVE MAPT INTO INTO MAPT3.
      DO I=1,NACT
        MAPT3(I+MCORE)=MAPT(I)+MCORE
      ENDDO
C
      CALL DAWRIT(IDAF,IODA,MAPT3,L1,527,1)
C
      IF(MASWRK) WRITE(IW,9000)
C
      RETURN
 9000 FORMAT(/1X,'LOCAL_ORDERS:',
     *        1X,'MALMQ_REORDER2 ROUTINE NOW ALTERS',
     *        1X,'DAF FILE 527.')
      END
C*MODULE LOCAL   *DECK LOCAL_DIMOID2
C> @brief      This routine assigns orbitals to atoms in MALMQ_CIDRIV.
C> 
C> @author     Aaron West
C>             -December 17, 2012
C> 
C> @details    This routine assigns orbitals to atoms in MALMQ_CIDRIV.
C>             It is stripped down version of DIMOID.
C> 
C> @see        DIMOID
C>
C> @param RLMO holds the (L1,L1) atomic orbital coefficients.
C> @param SSQU is a (L1,L1) scratch array.
C> @param STRI is a scratch array of L2 length.
C> @param ATMU is a (NATS,M1) scratch array for overlaps.
C> @param IATM is a (NATS,M1) integer array for atom numbers.
C> @param IWHI is a NATS+M1 integer scratch array.
C> @param INAT is a NATS+M1 integer array for frequency of atom number.
c> @param L1 is the length of the AO coefficients.
c> @param L2 is the triangular length of L1.
C> @param M1 is the number of active orbitals for ilocal=4 method.
C> @param NATS is the number of atoms.
C>
      SUBROUTINE LOCAL_DIMOID2(
     *           RLMO,SSQU,STRI,ATMU,IATM,IWHI,INAT,
     *           L1,L2,M1,NATS)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION RLMO(L1,L1),SSQU(L1,L1),STRI(L2),ATMU(NATS,M1)
      DIMENSION IATM(NATS,M1),IWHI(M1+NATS),INAT(M1+NATS)
C
      PARAMETER (MXATM=2000, MXSH=5000, MXGTOT=20000, MXAO=8192)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OPTLOC/ CVGLOC,MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,
     *                MOOUTA(MXAO),MOOUTB(MXAO)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNLAB/ TITLE(10),A(MXATM),B(MXATM),BFLAB(MXAO)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
C   SEE DIMOID ROUTINE FOR ORIGINAL DESCRIPTION.
C
      TOLR = 0.30D+00
      NUMLOC = M1+NOUTA
C
      CALL DAREAD(IDAF,IODA,STRI,L2,12,0)
      CALL CPYTSQ(STRI,SSQU,L1,1)
C
      DO 920 II=1,M1
         INAT(II) = 0
  920 CONTINUE
C
      IF (MASWRK) THEN
         WRITE(IW,8000)
         WRITE(IW,8010)
      END IF
C
      NST = 1
 2000 CONTINUE
      NEND = MIN(NAT,NST+8)
C
      IF (MASWRK) THEN
         WRITE(IW,9000) (I,A(I),I=NST,NEND)
         WRITE(IW,9005)
      END IF
C
      DO 900 IO = NOUTA+1,NUMLOC
         IZ = IO - NOUTA
         DO 895 II=NST,NEND
            ATMU(II,IZ) = 0.0D+00
            IATM(II,IZ) = 0
  895    CONTINUE
         IFUNC = 0
         DO 890 ISHELL = 1,NSHELL
            IAT = KATOM(ISHELL)
            IST = KMIN(ISHELL)
            IEN = KMAX(ISHELL)
            DO 880 INO = IST,IEN
               IFUNC = IFUNC + 1
               IF (IAT.LT.NST.OR.IAT.GT.NEND) GOTO 880
               ZINT  = 0.0D+00
               DO 870 II = 1,L1
                  ZINT = ZINT + RLMO(II,IO)*SSQU(II,IFUNC)
  870          CONTINUE
               ATMU(IAT,IZ) = ATMU(IAT,IZ) + RLMO(IFUNC,IO)*ZINT
  880       CONTINUE
  890    CONTINUE
         IF (MASWRK) WRITE(IW,9010) IZ,(ATMU(II,IZ),II=NST,NEND)
C
C        THIS PIECE IS NOW FORCED.
C
         DO IA=NST,NEND
            IF (ATMU(IA,IZ).GT.TOLR) THEN
               INAT(IZ) = INAT(IZ) + 1
               IND = INAT(IZ)
               IATM(IND,IZ) = IA
            END IF
         ENDDO
  900 CONTINUE
C
      NST = NST + 9
      IF (NEND.LT.NAT) GOTO 2000
C
C     THIS PIECE IS NOW FORCED.
C     FORCE A SINGLE ATOM TO BE CHOSEN
C
      DO IO = NOUTA+1,NUMLOC
         IZ = IO - NOUTA
         IA = IDAMAX(NATS,ATMU(1,IZ),1)
         INAT(IZ)=1
         IATM(1,IZ)=IA
      ENDDO
C
      IF (MASWRK) THEN
         WRITE(IW,9015) TOLR
         WRITE(IW,9020)
      END IF
C
      NOSI = 0
      DO 700 II=1,M1
         NO=0
         DO 720 JJ=1,NAT
            IF (IATM(JJ,II).EQ.0) GOTO 740
            NO = NO + 1
  720    CONTINUE
  740    CONTINUE
         IF (NO.GT.1.OR.NO.EQ.0) THEN
            NOSI = NOSI + 1
            IWHI(NOSI) = II
         END IF
        IF (MASWRK)
     *     WRITE(IW,9030) II,(IATM(J,II),A(IATM(J,II)),J=1,NO)
  700 CONTINUE
C
      IF (MASWRK) THEN
         WRITE(IW,9035) NOSI
         IF (NOSI.GT.0) THEN
            WRITE(IW,9040) (IWHI(I),I=1,NOSI)
         ELSE
            WRITE(IW,9050)
         END IF
      END IF
C
C     PREPARE THE IWHI ARRAY WITH THE ATOM NUMBERS FOR DAF FILE 531.
C
      CALL VICLR(IWHI,1,M1+NATS)
      DO I=1,M1
        IWHI(I)=IATM(1,I)
      ENDDO
C
      RETURN
 8000 FORMAT(/1X,'** MULLIKEN ATOMIC POPULATIONS FOR EACH NON-FROZEN ',
     *       'LOCALIZED ORBITAL **')
 8010 FORMAT(1X,'POPULATIONS SUM TO 1 E- PER ORBITAL, AND SO ARE',
     *          ' STRICTLY FOR THE'/
     *       1X,'PURPOSE OF ASSIGNING ORBITALS TO ATOMS OR BONDS.')
 9000 FORMAT(/3X,'ATOM',2X,100(I2,1X,A4))
 9005 FORMAT(1X,'LMO')
 9010 FORMAT(1X,I3,3X,100F7.3)
 9015 FORMAT(/1X,'** ATOMIC POPULATIONS GREATER THAN ',F4.2,
     *   ' ARE CONSIDERED MAJOR **')
 9020 FORMAT(/2X,'LMO',3X,'MAJOR CONTRIBUTIONS FROM ATOM(S)')
 9030 FORMAT(2X,I3,2X,100(I2,1X,A2,2X))
 9035 FORMAT(/1X,'NO OF LMOS INVOLVING MORE THAN ONE ATOM =',I3)
 9040 FORMAT(1X,'THESE ARE LMOS :',100I3)
 9050 FORMAT(1X,
     * 'LMOS WILL BE REORDERED ACCORDING TO WHICH ATOM THEY BELONG TO'/
     * 1X,'I.E. LMOS ON ATOM 1 COME FIRST, ETC..')
      END
C*MODULE LOCAL   *DECK LOCAL_PPA_NATMOR_SETUP
C> @brief      This routine matches orbitals to atoms if no NATMOR input.
C> 
C> @author     Aaron West
C>             -December 17, 2012
C> 
C> @details    When the user does not input active orbital values to
C>             the NATMOR index array in the local group,
C>             this routine attempts to determine atom numbers
C>             through atomic Mulliken populations.
C>             It will fail if the orbitals are too delocalized.
C>             However, it saves the user time if the orbitals
C>             are already localized enough.
C>             The subsequent code has enough fail safes to prevent
C>             error, and the error is obvious.
C> 
C> @param NATMOR is an integer array that contains the atom labels
C>               of the orbitals.
C> @param MASWRK indicates the master process.
C> @param IW     indicates write out to the log file.
C> @param RLMO   holds the (L1,L1) atomic orbital coefficients.
C> @param SSQU   is a (L1,L1) scratch array.
C> @param STRI   is a scratch array of L2 length.
C> @param ATMU   is a (NATS,M1) scratch array for overlaps.
C> @param IATM   is a (NATS,M1) integer array for atom numbers.
C> @param IWHI   is a NATS+M1 integer scratch array.
C> @param INAT   is a NATS+M1 integer array for frequency of atom number.
c> @param L1     is the length of the AO coefficients.
c> @param L2     is the triangular length of L1.
C> @param M1     is the number of active orbitals for ilocal=4 method.
C> @param NATS   is the number of atoms.
C>
      SUBROUTINE LOCAL_PPA_NATMOR_SETUP(NATMOR,MASWRK,IW,
     *           RLMO,SSQU,STRI,ATMU,IATM,IWHI,INAT,
     *           L1,L2,MCORE,M1,NATS)
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER IW
      INTEGER I,ICHK,L1,L2,M1,NATS,MCORE
      DOUBLE PRECISION ::
     *       RLMO(L1,L1),SSQU(L1,L1),STRI(L2),ATMU(NATS,M1)
      INTEGER IATM(NATS,M1),IWHI(M1+NATS),INAT(M1+NATS)
      INTEGER NATMOR(L1)
C
      ICHK=0
      DO I=MCORE+1,MCORE+M1
        IF(NATMOR(I).NE.0) ICHK=1
      ENDDO
      IF(ICHK.EQ.0) THEN
        IF(MASWRK) WRITE(IW,9000)
C       ALREADY READ IN ORBITALS TO RLMO.
        CALL LOCAL_DIMOID2(
     *       RLMO,SSQU,STRI,ATMU,IATM,IWHI,INAT,
     *       L1,L2,M1,NATS)
        DO I=1,M1
          NATMOR(I+MCORE)=IWHI(I)
        ENDDO
      ENDIF
C
      RETURN
 9000 FORMAT(/1X,'USER DID NOT ASSIGN NATMOR ARRAY.',
     *       /1X,'NOW ATTEMPTING TO ASSIGN ATOMS WITH',
     *        1X,'MULLIKEN POPULATIONS.',
     *        1X,'THE RUN MAY FAIL.')
      END
