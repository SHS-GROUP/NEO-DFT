C 15 APR 11 - MK  - DC-CC BECOMES COMPATIBLE WITH DIRECT SCF
C 11 AUG 10 - DGF - SYNCH COMMON BLOCK ENRGYS
C 25 MAR 10 - MK  - DC-CCSD(T) AND DC-R-CCSD(T) ROUTINES
C 12 JAN 09 - MK  - IMPLEMENTATION OF DIVIDE-AND-CONQUER CC
C
C*MODULE DCCC    *DECK DCCCDRVR
C        MODIFIED FROM CCDRVR
      SUBROUTINE DCCCDRVR(BESTCC,EOM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL EOM,CNVR,DBUG
      LOGICAL QDR,QDCR
C
      PARAMETER (MXRT=100, MXATM=2000)
      PARAMETER (MXLATM=200, MXLSHL=700)
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL DDITRF,NDINTS
C
      COMMON /CCENGY/ ENRG,EREF,EMP2,ECCN,ETOT(6),ECORR(6),
     *                DIAGS(3),AMPMX(5,2),IAMPMX(5,4,2),XO1,XO2,
     *                DIFMAX,DIFFENG,ITER,CNVR
      COMMON /CCFILE/ INTG,NT1,NT2,NT3,NVM,NVE,NFRLE,NRESF,NRESL
      COMMON /CCINFO/ TSH,NH,NP,MET,MEM,ICONV,MAXIT,IREST,IDISC
      COMMON /CCPAR / AMPTSH,METHCC,NCCTOT,NCCOCC,NCCFZC,NCCFZV,
     *                MXCCIT,MXRLEIT,NWRDCC,ICCCNV,ICCRST,IDSKCC
      COMMON /CCRLE / MXRLE,NRLE0,NRLE,IRLE,ITRLE
      COMMON /ENRGYS/ VNN,EELCT,ETOTX,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON/QUADRUPLE/QDR,QDCR
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      LOGICAL DCFLG
      LOGICAL DODCCR,ONLYOC,RMKORB,FZCORE,DOMP1,HFFRM
      COMMON /DCCORR/ RBUFCR,WOCC,ISTCOR,ITPART,DODCCR,ONLYOC,RMKORB,
     *                FZCORE,DOMP1,HFFRM
      COMMON /DCOPT / SUBTYP,BUFTYP,SUBLNG,BUFRAD,NDCPRT,NSUBS,DCFLG
      COMMON /SUBSP / ILCST1(MXATM),NLC1,LNUMMX,ILATST(MXATM),NLCAT1
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
      COMMON /IODC  / IDCSUB,IDCVEC,IDCDM,IDCQ,IDCDMO,IDCEIG,IDCW,IDCEDM
      COMMON /DCFRM / FRMLVA,FRMLVB,FRBETA,FTOL,MXITDC
C
      COMMON /CCRENO/ OSS,ODS,ODD,OTS,OTD,OTT,ODS_S,ODS_D,ODS_T,
     *                OQS,OQDS,OQDD,OQTS,ESD,ETD,ETS,ETTM,ESD_TM
C
      DIMENSION ECORRT(6)
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
      PARAMETER (UNITS=0.52917724924D+00)
C
      DATA CHECK/8HCHECK   /
C
      CHARACTER*10 CMET(6)
      DATA CMET/'LCCD      ','CCD       ','CCSD      ','   CCSD(T)',
     &          ' R-CCSD(T)','CR-CCSD(T)'/
C
C     ----------------------------------------------------------
C           DIVIDE-AND-CONQUER SUBSYSTEM CCSD CALCULATION
C                                        CODED BY M. KOBAYASHI
C                             BASED ON
C             ---- MAIN DRIVER FOR CC CALCULATIONS ----
C            PIOTR PIECUCH (A), STANISLAW A. KUCHARSKI (B),
C              KAROL KOWALSKI (A) AND MONIKA MUSIAL (B)
C       (A) DEPARTMENT OF CHEMISTRY, MICHIGAN STATE UNIVERSITY
C           (B) INSTITUTE OF CHEMISTRY, UNIVERSITY OF SILESIA
C     ----------------------------------------------------------
C
C     INTERFACED TO GAMESS IN MARCH 2002.  FOR INFORMATION ON THE
C     UNIQUE FEATURES OF THIS CODE, THE RENORMALIZED AND COMPLETELY
C     RENORMALIZED COUPLED-CLUSTER THEORY, SEE THE FOLLOWING:
C     K.KOWALSKI, P.PIECUCH  J.CHEM.PHYS. 113, 18-35(2000)
C     K.KOWALSKI, P.PIECUCH  J.CHEM.PHYS. 113, 5644-5652(2000)
C
C     THE BIGGEST (QUARTIC) MEMORY ALLOCATIONS ARE AS FOLLOWS
C     INTEGRAL PREPARATION
C        SRTING:  SOMEWHERE BETWEEN NONU3 AND NU4
C     CCSD ITERATIONS
C          CCSD:   NO4   NO3NU  4NO2U2   NONU3
C     NON-ITERATIVE TRIPLES (ONLY 1 OF INTRIPL/INTRIP WILL BE RUN)
C         T3WT2:         NO3NU  2NO2U2   NONU3
C        INTQUA:         NO3NU   NO2U2   NONU3
C       INTRIPL:         NO3NU   NO2U2  2NONU3
C          OR
C        INTRIP:        2NO3NU   NO2U2   NONU3
C        INTRIH:        3NO3NU   NO2U2   NONU3
C        T3WT2N:         NO3NU  2NO2U2   NONU3
C       T3SQTOT:                2NO2U2
C     SINCE T3WT2 HAS TWO NU3 ARRAYS, IT MAY BE THE MEMORY BOTTLENECK
C     RATHER THAN CCSD, DEPENDING ON HOW BIG NU IS RELATIVE TO NO2.
C
      DBUG=.FALSE.
C
      IF(MASWRK) THEN
         WRITE(IW,9010)
         IF(EXETYP.NE.CHECK .AND. NPRINT.NE.-5) THEN
           WRITE(IW,9011)
           IF(GOPARR) WRITE(IW,9012)
           WRITE(IW,9013)
         END IF
      ENDIF
C
      IF(NPROC.GT.1) THEN
         IF(MASWRK) WRITE(IW,*) 'PARALLEL DC-CC IS NOT IMPLEMENTED'
         CALL ABRT
      END IF
C
      IDMP=35
      CALL SEQOPN(IDMP,'RESTART','NEW',.FALSE.,'FORMATTED')
C
      IF(EOM)THEN
         WRITE(IW,*) '## ERROR!! DC-EOM-CC HAS NOT BEEN IMPLEMENTED'
         CALL ABRT
      ENDIF
C
CPA      IF(GOPARR) THEN
CPA         DDITRF=.TRUE.
CPA         NDINTS=.TRUE.
CPA      ELSE
         DDITRF=.FALSE.
         NDINTS=.FALSE.
CPA      END IF
C
C        ETOTX IS THE SCF ENERGY, INCLUDING NUCLEAR REPULSION
C
      EREF = ETOTX
      ENRG = ZERO
      EMP2 = ZERO
      ECCN = ZERO
      DO I=1,6
        ECORR(I)= ZERO
        ETOT(I) = ZERO
      ENDDO
      ENRGT= ZERO
      EMP2T= ZERO
      DO I=1,6
        ECORRT(I)=ZERO
      ENDDO
      DIAGS(1) = ZERO
      DIAGS(2) = ZERO
      DIAGS(3) = ZERO
      DO J=1,2
         DO I=1,5
            AMPMX(I,J) = ZERO
            IAMPMX(I,1,J) = 0
            IAMPMX(I,2,J) = 0
            IAMPMX(I,3,J) = 0
            IAMPMX(I,4,J) = 0
         ENDDO
      ENDDO
      XO1 = ONE
      XO2 = ONE
C
C  PREPARE DEFAULT VALUES
C
      IF(RBUFCR.LE.ZERO) RBUFCR=BUFRAD
      IF(RBUFCR.NE.BUFRAD) RMKORB=.TRUE.
      IF(.NOT.DCFLG .AND. DODCCR) RMKORB=.TRUE.
C
C     DC-CC CODE FOR WOCC=1 IS ONLY AVAILABLE.
C     FORCE ONLYOC=.T. AND WOCC=1
C
      IF(.NOT.ONLYOC .OR. WOCC.NE.ONE) THEN
         IF(WOCC.NE.ZERO) THEN
            IF(MASWRK) WRITE(IW,9510)
            WOCC=ONE
         END IF
         ONLYOC=.TRUE.
      END IF
C
      IF(MASWRK) WRITE(IW,9500) ISTCOR,WOCC,ITPART,RMKORB,HFFRM,
     *                          RBUFCR,RBUFCR*UNITS
C
C  IF RMKORB=.TRUE. RECONSTRUCT DC SUBSYSTEMS
C
      IF(RMKORB) THEN
         IF(.NOT.DCFLG) THEN
           IDCSUB=250
           IDCVEC=251
           IDCQ  =255
           CALL SEQOPN(IDCSUB,'DCSUB', 'UNKNOWN',.FALSE., 'UNFORMATTED')
           CALL SEQOPN(IDCVEC,'DCVEC', 'UNKNOWN',.FALSE., 'UNFORMATTED')
           CALL SEQOPN(IDCQ,  'DCQ',   'UNKNOWN',.FALSE., 'UNFORMATTED')
         END IF
         CALL DFLCST(1,.TRUE.)
      END IF
C
C  ALLOCATE TOTAL SYSTEM ARRAYS
C
      L1SUB=NSUBS
C
      NUM1=NUM
      NUM2=NUM*(NUM+1)/2
C
      CALL VALFM(LOADFM)
      LEIGT = LOADFM + 1
      LFT   = LEIGT  + NLC1
      LST   = LFT    + NUM2
      LESUB = LST    + NUM2
      LEMP2S= LESUB  + L1SUB
C   LECORS: RESERVED FOR (T) CORRECTION
      LECORS= LEMP2S + L1SUB
      LASTT = LECORS + L1SUB*6
C
      NEEDT = LASTT  - LOADFM -1
      CALL GETFM(NEEDT)
C
      CALL DAREAD(IDAF,IODA,X(LFT)  ,NUM2,14,0)
      CALL DAREAD(IDAF,IODA,X(LST)  ,NUM2,12,0)
C
      IF(RMKORB) THEN
C
C  RECONSTRUCTION OF SUBSYSTEM ORBITALS
C
         FRMOLD=FRMLVA
         CALL ORBRMK(X(LST),X(LFT),DUMMY,X(LEIGT),DUMMY,NUM1,NUM2,NLC1,
     *               NSUBS,DBUG,.FALSE.)
C
      ELSE
         CALL SEQREW(IDCEIG)
         CALL SQREAD(IDCEIG,X(LEIGT),NLC1)
      END IF
C
      CALL SEQREW(IDCVEC)
      CALL SEQREW(IDCQ)
C
      MET   = METHCC
      ICONV = ICCCNV
      MAXIT = MXCCIT
      MXRLE = MXRLEIT
      MEM   = NWRDCC
      IF(MEM.EQ.0) CALL GOTFM(MEM)
      TSH   = AMPTSH
      CALL DRPRINT(1)
C
C  SUBSYSTEM LOOP
C     THIS LOOP SHOULD BE PARALLELIZE BY DDI
C
      IF(MASWRK) THEN
         WRITE(IDMP, FMT='(7H $CCRES)')
         WRITE(IDMP, FMT='(I1)') MET
      END IF
C
      IF(ISTCOR.GE.2) THEN
         CALL RDCCDC(X(LESUB),X(LEMP2S),X(LECORS),L1SUB,ENRGT,EMP2T,
     *               ECORRT,ISTCOR,IDMP)
      ENDIF
C
      DO 100 ISUB=1, NSUBS
         IF(MASWRK) WRITE(IW,9100) ISUB
         CALL LOCREG(ISUB)
         CALL TOLOC
C
         NFZC=0
         IF(FZCORE) NFZC=NUMCORDC()
         NOCC=0
         DO I=1, LNUM
            IF(X(LEIGT+ILCST1(ISUB)+I-2).LE.FRMLVA) NOCC=NOCC+1
         END DO
C
C        SET INPUT PARAMETERS FOR SUBSYSTEM
C
         NH    = NOCC-NFZC
         NP    = LNUM-NOCC
         IREST = 0
         IFC   = NFZC
         IDISC = IDSKCC
C
         ITER=IREST
C
         WRITE(IW,9700) LNUM,NOCC,NFZC,0
C
         IF(ISUB.LT.ISTCOR) THEN
            CALL SEQADV(IDCVEC)
            CALL SEQADV(IDCQ)
            GO TO 100
         END IF
C
C        THE CC PROGRAM'S MEMORY ALLOCATIONS, ETC. ASSUME NP>NH,
C        SO KILL ANY RUN WITH TOO FEW VIRTUALS
C
         IF(NP.LT.NH) THEN
            IF(MASWRK) WRITE(IW,9020) NH,NP
            CALL ABRT
         END IF
C
C        ORBITAL ENERGIES ARE HELD THROUGHOUT THE ENTIRE RUN
C
         LNUM2=(LNUM+1)*LNUM/2
         LNUM3=LNUM*LNUM
C
         CALL VALFM(LOADFM)
         LEH  = LOADFM + 1
         LEP  = LEH    + NH
         LCO  = LEP    + NP
         LFAO = LCO    + LNUM3
         LAST = LFAO   + LNUM2
         NEED = LAST - LOADFM - 1
         CALL GETFM(NEED)
C
         CALL SQREAD(IDCVEC,X(LCO),LNUM3)
         CALL TRT2LC(X(LFT),X(LFAO),NUM1,NUM2,LNUM,LNUM2,'FOCK    ')
C
C        INTEGRAL TRANSFORMATION IS REQUIRED
C
         CALL VALFM(LOADFM)
         LQ   = LOADFM + 1
         LS   = LQ     + LNUM3
         LAST = LS     + LNUM2
         NEED1= LAST   - LOADFM-1
         CALL GETFM(NEED1)
C
         CALL SQREAD(IDCQ,X(LQ),LNUM3)
         CALL TRT2LC(X(LST),X(LS),NUM1,NUM2,LNUM,LNUM2,'OVERLAP ')
C
         NTOTMO= LNUM
         NPRINT= -5
         LCOTP=LCO
C
         CALL TRFMCXDC(NPRINT,NFZC,NTOTMO,NTOTMO,.FALSE.,.FALSE.,DDITRF,
     *                 NDINTS,NDINTS,NDINTS,NDINTS,NDINTS,.FALSE.,
     *                 .FALSE.,LCO,X(LQ),X(LS),ISUB)
C
         LCO=LCOTP
         CALL RETFM(NEED1)
C
C        PARALLEL CCSD OR CCSD(T) IS DONE IN A DIFFERENT PLACE
C
CPA      IF(GOPARR) THEN
CPA         CALL DCDRCCSD_DDI(NH,NP,X(LEH),X(LEP))
CPA         CALL RETFM(NEED)
CPA         BESTCC = ENRG + EREF
CPA         RETURN
CPA      END IF
C
C        SERIAL RUNS (ALL CCTYP) PASS THIS WAY...
C
C        PREPARE INTEGRALS AND FOCK MATRIX ELEMENTS FOR THE RUN
C
         CALL DCDRSRTING(NH,NP,LNUM,X(LEH),X(LEP),
     *                   X(LCO),X(LFAO),IFC,EOM,LCO)
         IF(MASWRK) WRITE(IW,9060)
         CALL TIMIT(1)
C
C        CARRY OUT THE COUPLED-CLUSTER AMPLITUDE ITERATIONS (E.G. CCSD)
C
         CALL DCDRCCSD(NH,NP,X(LEH),X(LEP),IFC,EOM,
     C                 X(LESUB+ISUB-1),X(LEMP2S+ISUB-1))
         CALL DRPRINT(3)
         IF(MASWRK) WRITE(IW,9070)
         CALL TIMIT(1)
         IF(.NOT.CNVR) THEN
            IF(MASWRK)WRITE(IW,*)'AMPLITUDE ITERATIONS DID NOT CONVERGE'
            CALL ABRT
         END IF
C
         ESD=X(LESUB+ISUB-1)
C
C        NON-ITERATIVE TRIPLES AND/OR QUADRUPLES CORRECTIONS
C         (NOT IMPLEMENTED FOR DC CALCULATION)
C
         IF(MET.GE.3) THEN
            IF(QDR) THEN
              WRITE(IW,*) '## ERROR!!',
     *                    'DC-CC QUADRUPLE HAS NOT BEEN IMPLEMENTED.'
              CALL ABRT
            END IF
            IF(MET.GE.5) THEN
               WRITE(IW,*) '## ERROR!!',
     *                     'DC-CR-CC HAS NOT BEEN IMPLEMENTED.'
              CALL ABRT
            END IF
            IF(MET.EQ.3.OR.MET.EQ.4.OR.IDISC.EQ.0) THEN
               CALL DRT3WT2DC(NH,NP,X(LEH),X(LEP))
            END IF
C
C           ### NOT IMPLEMENTED ###
            IF(MET.GE.5) THEN
               CALL DRINTRI(NH,NP,0)
               CALL DRT3WT2N(NH,NP,X(LEH),X(LEP),IDISC)
            END IF
            CALL DRSUMA(NH,NP,X(LEH),X(LEP),MET)
C
            IF(MET.GE.4  .OR.  QDCR) THEN
              IF(MASWRK) WRITE(IW,9328) XO1
              IF(MASWRK) WRITE(IW,9329) XO2
            END IF
C
            DO ICORR=1,6
               X(LECORS+6*(ISUB-1)+ICORR)=ECORR(ICORR)
            ENDDO
            WRITE(6,9075)
            CALL TIMIT(1)
         END IF
C
         ENRGT=ENRGT+X(LESUB+ISUB-1)
         EMP2T=EMP2T+X(LEMP2S+ISUB-1)
         DO ICORR=1,6
            ECORRT(ICORR)=ECORRT(ICORR)+ECORR(ICORR)
         ENDDO
C
         IF(MASWRK) THEN
            WRITE(IW  ,9600) ISUB,X(LESUB+ISUB-1),X(LEMP2S+ISUB-1)
            WRITE(IDMP,9650) ISUB,X(LESUB+ISUB-1),X(LEMP2S+ISUB-1)
            IF(MET.GE.3) THEN
               WRITE(IW  ,9610) (X(LECORS+(ISUB-1)*6+I), I=1, 2)
               WRITE(IDMP,9660) (X(LECORS+(ISUB-1)*6+I), I=1, 2)
            END IF
            IF(MET.GE.4) THEN
               WRITE(IW  ,9620) (X(LECORS+(ISUB-1)*6+I), I=3, 4)
               WRITE(IDMP,9660) (X(LECORS+(ISUB-1)*6+I), I=3, 4)
            END IF
         END IF
         IF(MET.EQ.3) X(LESUB+ISUB-1)=ECORR(2)
         IF(MET.EQ.4) X(LESUB+ISUB-1)=ECORR(4)
C
         CALL RETFM(NEED)
C
         CALL RACLOS(NRESF,'KEEP')
         CALL RACLOS(NFRLE,'KEEP')
         CALL RACLOS(INTG ,'KEEP')
         CALL RACLOS(NT1  ,'KEEP')
         CALL RACLOS(NT2  ,'KEEP')
         CALL RACLOS(NT3  ,'KEEP')
         CALL RACLOS(NVM  ,'KEEP')
         CALL RACLOS(NVE  ,'KEEP')
         CALL SEQCLO(IJKT ,'KEEP')
C
  100 CONTINUE
      IF(MASWRK) WRITE(IDMP, FMT='(5H $END)')
C
      ENRG=ENRGT
      EMP2=EMP2T
      DO I=1, 6
         ECORR(I)=ECORRT(I)
      ENDDO
C
      IF(MASWRK) THEN
         WRITE(IW,9300)
         WRITE(IW,9310) EREF,EMP2+EREF,EMP2
         IF(MET.EQ.0) THEN
            WRITE(IW,9320) ENRG+EREF,ENRG
         ELSE IF(MET.EQ.1) THEN
            WRITE(IW,9321) ENRG+EREF,ENRG
         ELSE
            WRITE(IW,9322) ENRG+EREF,ENRG
         ENDIF
         IF(MET.GE.3) WRITE(IW,9323) ECORR(1)+EREF,ECORR(1),
     *                               ECORR(2)+EREF,ECORR(2)
         IF(MET.GE.4) WRITE(IW,9324) ECORR(3)+EREF,ECORR(3),
     *                               ECORR(4)+EREF,ECORR(4)
C
         WRITE(IW,9400) CMET(MET+1)
         DO ILOOP=1,NSUBS
           WRITE(IW,9410) ILOOP, X(LESUB+ILOOP-1),X(LEMP2S+ILOOP-1)
         END DO
         WRITE(IW,*)
      END IF
C
      BESTCC=ENRG+EREF
      IF(MET.EQ.3) BESTCC=ECORR(2)+EREF
      IF(MET.EQ.4) BESTCC=ECORR(4)+EREF
C
C  IF RMKORB=.TRUE. RESTORE DC SUBSYSTEMS
C
      IF(RMKORB .AND. DCFLG) THEN
         CALL DFLCST(0,.FALSE.)
         CALL ORBRMK(X(LST),X(LFT),DUMMY,X(LEIGT),DUMMY,NUM1,NUM2,NLC1,
     *               NSUBS,DBUG,.FALSE.)
         FRMLVA = FRMOLD
      ENDIF
C
      CALL RETFM(NEEDT)
      IF(MASWRK) WRITE(IW,9080)
      CALL TIMIT(1)
      RETURN
C
 9010 FORMAT(/3X,58(1H-)/
     *     3X,'DIVIDE-AND-CONQUER COUPLED-CLUSTER PROGRAM',5X,
     *         'M.KOBAYASHI'//
     *     27X,'BASED ON'/
     *     3X,'COUPLED-CLUSTER PROGRAM'/
     *     6X,'P.PIECUCH, S.A.KUCHARSKI, M.WLOCH, K.KOWALSKI, M.MUSIAL'/
     *     3X,58(1H-))
 9011 FORMAT(/1X,65(1H*)/
     *        1X,'THE FOLLOWING PAPERS SHOULD BE CITED WHEN USING',
     *        1X,'COUPLED-CLUSTER'/
     *        1X,'OPTIONS:'//
     *        1X,'CCTYP = LCCD, CCD, CCSD, CCSD(T)'/
     *    1X,'P. PIECUCH, S.A. KUCHARSKI, K. KOWALSKI, AND M. MUSIAL,'/
     *        1X,'COMP. PHYS. COMMUN. 149, 71-96 (2002).'//
     *        1X,'CCTYP = R-CC, CR-CC, CCSD(TQ), CR-CC(Q)'/
     *    1X,'P. PIECUCH, S.A. KUCHARSKI, K. KOWALSKI, AND M. MUSIAL,'/
     *        1X,'COMP. PHYS. COMMUN. 149, 71-96 (2002);'/
     *        1X,'K. KOWALSKI AND P. PIECUCH, J. CHEM. PHYS. 113,',
     *        ' 18-35 (2000);'/
     *        1X,'K. KOWALSKI AND P. PIECUCH, J. CHEM. PHYS. 113,',
     *        ' 5644-5652 (2000).'//
     *        1X,'CCTYP = EOM-CCSD, CR-EOM'/
     *    1X,'P. PIECUCH, S.A. KUCHARSKI, K. KOWALSKI, AND M. MUSIAL,'/
     *        1X,'COMP. PHYS. COMMUN. 149, 71-96 (2002);'/
     *        1X,'K. KOWALSKI AND P. PIECUCH, J. CHEM. PHYS. 120,',
     *        ' 1715-1738 (2004);'/
     *        1X,'M. WLOCH, J.R. GOUR, K. KOWALSKI, AND P. PIECUCH,'/
     *        1X,'J. CHEM. PHYS. 122, 214107-1 - 214107-15 (2005).'//
     *        1X,'CCTYP = CR-CCL'/
     *    1X,'P. PIECUCH, S.A. KUCHARSKI, K. KOWALSKI, AND M. MUSIAL,'/
     *        1X,'COMP. PHYS. COMMUN. 149, 71-96 (2002);'/
     *        1X,'P. PIECUCH AND M. WLOCH, J. CHEM. PHYS. 123,'/
     *        1X,'224105-1 - 224105-10 (2005).'//
     *        1X,'CCTYP = CR-EOML'/
     *    1X,'P. PIECUCH, S.A. KUCHARSKI, K. KOWALSKI, AND M. MUSIAL,'/
     *        1X,'COMP. PHYS. COMMUN. 149, 71-96 (2002);'/
     *        1X,'P. PIECUCH, J. R. GOUR, AND M. WLOCH,'/
     *        1X,'INT. J. QUANTUM CHEM. 109, 3268-3304 (2009);'/
     *        1X,'K. KOWALSKI AND P. PIECUCH,'/
     *        1X,'J. CHEM. PHYS. 120, 1715-1738 (2004).'//
     *        1X,'IN ADDITION, THE USE OF CCPRP=.TRUE. IN $CCINP',
     *        ' AND/OR THE USE'/
     *        1X,'OF CCPRPE=.TRUE. IN $EOMINP SHOULD REFERENCE'//
     *        1X,'M. WLOCH, J.R. GOUR, K. KOWALSKI, AND P. PIECUCH,'/
     *        1X,'J. CHEM. PHYS. 122, 214107-1 - 214107-15 (2005).'/
     *        1X,65(1H*)/)
 9012 FORMAT(1X,'PARALLELIZATION OF CLOSED SHELL CCSD(T) IS'/
     *       1X,'J.L.BENTZ, R.M.OLSON, M.S.GORDON, M.W.SCHMIDT,',
     *          ' R.A.KENDALL'/
     *       3X,'COMPUT.PHYS.COMMUN.  176, 589-600(2007)'/
     *       1X,'R.M.OLSON, J.L.BENTZ, R.A.KENDALL, M.W.SCHMIDT,',
     *          ' M.S.GORDON'/
     *       3X,'J.COMPUT.THEORET.CHEM. 3, 1312-1328(2007)')
 9013 FORMAT(1X,'DIVIDE-AND-CONQUER CC IS'/
     *       1X,'M. KOBAYASHI AND H. NAKAI,',
     *       3X,'J. CHEM. PHYS. 129, 044103 (2008)'//
     *       1X,'DIVIDE-AND-CONQUER CCSD(T) AND R-CCSD(T) ARE'/
     *       1X,'M. KOBAYASHI AND H. NAKAI,',
     *       3X,'J. CHEM. PHYS. 131, 114108 (2009)'/
     *       1X,65(1H*)/)
 9020 FORMAT(/5X,'*** ERROR READING CC INPUT ***'/
     *        1X,'THE NUMBER OF OCCUPIED CORRELATED ORBITALS=',I6/
     *        1X,'THE NUMBER OF EMPTY, CORRELATING ORBITALS =',I6/
     *        1X,'PLEASE RUN WITH MORE EMPTY THAN FILLED ORBITALS.')
 9060 FORMAT(1X,'....... DONE WITH CC INTEGRAL PREPARATION .......')
 9070 FORMAT(1X,'....... DONE WITH CC AMPLITUDE ITERATIONS .......')
 9075 FORMAT(1X,'..... DONE WITH CC NON-ITERATIVE TRIPLES CORRECTIONS',
     *          ' .....')
 9080 FORMAT(1X,'....... DONE WITH CC CALCULATION .......')
C
 9100 FORMAT(/1X,'---CALCULATING ',I8,'-TH SUBSYSTEM CC ENERGY---')
 9300 FORMAT(/3X,49(1H=)/
     *        3X,'DIVIDE-AND-CONQUER COUPLED-CLUSTER ENERGY SUMMARY'/
     *        3X,49(1H=))
 9310 FORMAT(/5X,' REFERENCE ENERGY:',F20.10/
     *        5X,'   MBPT(2) ENERGY:',F20.10,'   CORR.E=',F15.10)
 9320 FORMAT( 5X,'   LCCD    ENERGY:',F20.10,'   CORR.E=',F15.10)
 9321 FORMAT( 5X,'    CCD    ENERGY:',F20.10,'   CORR.E=',F15.10)
 9322 FORMAT( 5X,'   CCSD    ENERGY:',F20.10,'   CORR.E=',F15.10)
 9323 FORMAT( 5X,'   CCSD[T] ENERGY:',F20.10,'   CORR.E=',F15.10/
     *        5X,'   CCSD(T) ENERGY:',F20.10,'   CORR.E=',F15.10)
 9324 FORMAT( 5X,' R-CCSD[T] ENERGY:',F20.10,'   CORR.E=',F15.10/
     *        5X,' R-CCSD(T) ENERGY:',F20.10,'   CORR.E=',F15.10)
 9328 FORMAT(/10X,'R-CCSD[T] DENOMINATOR',F17.10)
 9329 FORMAT( 10X,'R-CCSD(T) DENOMINATOR',F17.10)
 9400 FORMAT(/5X,28(1H-)/
     *        5X,'SUBSYSTEM CORRELATION ENERGY'/
     *        10X,'CC = ',A10/
     *        5X,28(1H-)/
     *        3X,'SUBSYSTEM',8X,'CC CORRELATION',6X,'MP2 CORRELATION')
 9410 FORMAT( 5X,I5,5X,2F20.10)
 9500 FORMAT(/10X,21(1H-)/10X,'DC-CC CONTROL OPTIONS'/10X,21(1H-)/
     *        10X,'ISTCOR = ',I8/
     *        10X,'WOCC   = ',F8.6,2X,'ITPART = ',I8/
     *        10X,'RMKORB = ',L8  ,2X,'HFFRM  = ',L8/
     *        10X,'RBUFCR = ',F8.4,' BOHR (',F8.4,' ANGS)'/)
 9510 FORMAT(/1X,'*** WARNING ***'/
     *        1X,'DC-CC CODE IS ONLY AVAILABLE FOR WOCC=1 OR WOCC=0.'/
     *        1X,'FORCE ONLYOC=.T. AND WOCC=1')
 9600 FORMAT(1X,'ISUB=',I5,' ECORR(CC)=',E15.7,' ECORR(MP2)=',E15.7)
 9610 FORMAT(11X,          ' CCSD[T]  =',E15.7,' CCSD(T)   =',E15.7)
 9620 FORMAT(11X,          ' R-CCSD[T]=',E15.7,' R-CCSD(T) =',E15.7)
 9650 FORMAT(I5,2E21.12)
 9660 FORMAT(5X,2E21.12)
 9700 FORMAT(/1X,'TOTAL NUMBER OF MOS          =',I6/
     *        1X,'NUMBER OF OCCUPIED MOS       =',I6/
     *        1X,'NUMBER OF FROZEN CORE MOS    =',I6/
     *        1X,'NUMBER OF FROZEN VIRTUAL MOS =',I6)
      END
C
C*MODULE DCCC    *DECK DCDRSRTING
C        MODIFIED FROM DRSRTING
      SUBROUTINE DCDRSRTING(NO,NU,NTOT,EH,EP,VEC,FAO,IFC,EOM,LVEC)
      IMPLICIT DOUBLE PRECISION  (A-H,O-Z)
      LOGICAL EOM
      LOGICAL PACK2E
      DIMENSION EH(NO),EP(NU)
      DIMENSION VEC(1),FAO(1)
C 06/23/2004 QUADRUPLES ----
      LOGICAL QDR,QDCR
      COMMON /QUADRUPLE/QDR,QDCR
C --------------------------
C
      COMMON /CCFILE/ INTG,NT1,NT2,NT3,NVM,NVE,NFRLE,NRESF,NRESL
      COMMON /CCINFO/ TSH,NH,NP,MET,MEM,ICONV,MAXIT,IREST,IDISC
      COMMON /FMCOM / X(1)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      PARAMETER (MXLATM=200, MXLSHL=700)
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
C
      DATA CHECK/8HCHECK   /
C
C     MEMORY ALLOCATION FOR TRANSFORMED INTEGRAL MANIPULATIONS
C         H=OCCUPIED, H MEANS "HOLES" WHICH ARE OCCUPIED
C                       STATES IN THE FERMI VACUUM
C         P= VIRTUAL, P MEANS "PARTICLES" WHICH ARE UNOCCUPIED
C                       STATES IN THE FERMI VACUUM
C
      NO2   = NO*NO
      NO3   = NO*NO2
      NO4   = NO*NO3
      NU2   = NU*NU
      NU3   = NU*NU2
      NOU   = NO*NU
      NO3U  = NO3*NU
      NOU2  = NO*NU2
      NOU3  = NO*NU3
      NO2U2 = NO2*NU2
C
C     OPEN ALL DISK FILES ASSOCIATED WITH CC CALCULATIONS
C
      NRESF=70
      NFRLE=71
      INTG=72
      NT1=73
      NT2=74
      NT3=75
      NVM=76
      NVE=77
C
C        FILE -NRESF- HAS RECORDS CONSISTING OF ONE FLOATING POINT
C        AND ONE INTEGER ARRAY, BOTH OF THE SAME LENGTH.  THE NUMBER
C        BELOW IS THE NUMBER OF BYTES IN ONE F.P. AND ONE INTEGER.
C        BE CAREFUL TO ENSURE THAT LWORD*NRESL IS A MULTIPLE OF 8.
C
      LWORD = 8 + 8/NWDVAR
      NRESL = 8096
C
C        THESE ARE THE DIRECT ACCESS FILE LENGTHS
C
      LRESF = (LWORD*NRESL)/8
      LRLE  = (NOU+NO2U2)
      LT3   = NU*NU*NU
      LNOU  = NOU
      LNO2U2= NO2U2
      LNU3  = NU3
      LVM   = NO3U
      LVE   = NU3
C
C        ALL OF THESE FILES ARE RANDOM ACCESS TYPE FILES
C
      CALL CCOPEN(NRESF,LRESF ,'CCREST')
      CALL CCOPEN(NFRLE,LRLE  ,'CCDIIS')
      CALL CCOPEN(INTG ,LT3   ,'CCINTS')
      CALL CCOPEN(NT1  ,LNOU  ,'CCT1AMP')
      CALL CCOPEN(NT2  ,LNO2U2,'CCT2AMP')
      CALL CCOPEN(NT3  ,LNU3  ,'CCT3AMP')
      CALL CCOPEN(NVM  ,LVM   ,'CCVM')
      CALL CCOPEN(NVE  ,LVE   ,'CCVE')
C 06/23/2004 QUADRUPLES ----
CCCX ORIGINAL VERSION BEFORE ADDING QUADRUPLES
CCCX      IF(EOM) THEN
CCCX         NHHHH = 85
CCCX         LHHHH = MAX(NU2,NO4)
CCCX         CALL CCOPEN(NHHHH,LHHHH,'EOMHHHH')
CCCX      END IF
C
      IF(EOM.OR.QDR) THEN
         NHHHH = 85
         LHHHH = MAX(NU2,NO4)
         CALL CCOPEN(NHHHH,LHHHH,'EOMHHHH')
      END IF
C
      CALL GOTFM(NGOTMX)
      IF(MEM.LT.NGOTMX) NGOTMX=MEM
C
      L1 = NTOT
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
      M1 = NTOT - IFC
CC      M1 = NCCTOT - NCCFZC - NCCFZV
      M2 = (M1*M1+M1)/2
C
C         ONE ELECTRON CONTRIBUTIONS TO THE ENERGY ARE MADE
C         USING FOCK MATRIX ELEMENTS, IN THE MO BASIS.
C
      CALL VALFM(LOADFM)
      LFMO  = LOADFM+1
      LFHH  = LFMO  + M2
      LFPP  = LFHH  + NO*NO
      LFHP  = LFPP  + NU*NU
      LWRK  = LFHP  + NO*NU
      LWRK2 = LWRK  + L1
      LWRK3 = LWRK2 + L3
      LAST  = LWRK3 + (M1-NO)*LNUMC
      NEED = LAST - LOADFM - 1
C
      CALL GETFM(NEED)
      IF(EXETYP.EQ.CHECK) GO TO 700
C
      CALL DCCCFOCK(INTG,FAO,X(LFMO),VEC,X(LFHH),X(LFPP),X(LFHP),
     *              X(LWRK),X(LWRK2),X(LWRK3),
     *              EH,EP,L1,L2,M1,M2,LNUMC,NO,NU,IFC)
C
  700 CONTINUE
      CALL RETFM(NEED)
C
C         PREPARE 2E- INTEGRALS, ALL PASSES NEED THE DISK BUFFERS
C
      CALL VALFM(LOADFM)
      LXX    = LOADFM + 1
      LIX    = LXX    + NINTMX
      LAST   = LIX    + NINTMX
C                          STORAGE FOR IPASS=1
      LTI1   = LAST
      LTI3   = LTI1   + NOU2
      LVHHHH = LTI3   + NO3
      LVPHHH = LVHHHH + NO4
      LVPPHH = LVPHHH + NO3U
      LVHPPH = LVPPHH + NO2U2
      LAST1  = LVHPPH + NO2U2
      NEED1 = LAST1 - LOADFM - 1
C                          STORAGE FOR IPASS=2
      LTI0   = LAST
      LVPPPH = LTI0   + NU3
      LAST2  = LVPPPH + NOU3
      NEED2 = LAST2 - LOADFM - 1
C                          STORAGE FOR IPASS=3
C                ALL LATER STEPS NEED AT LEAST NONU3 MEMORY, SO
C                THE MININUM NUMBER OF ORBITALS -NSLICE- FOR EACH
C                SUBPASS WITHIN PASS 3 CAN BE ASSUMED TO BE -NO-.
C                IN OTHER WORDS, WE CAN DEDICATE AT LEAST AS MUCH
C                MEMORY TO PASS 3 SUBPASSES AS WE NEED FOR PASS 2.
      NSLICE = (NGOTMX-2*NINTMX-NU3)/NU3
      IF(NSLICE.LE.NO) NSLICE=NO
      IF(NSLICE.GT.NU) NSLICE=NU
      NU3NS = NU3*NSLICE
C
      LTI0   = LAST
      LVPPPP = LTI0   + NU3
      LAST3  = LVPPPP + NU3NS
      NEED3 = LAST3 - LOADFM - 1
      MNND3 = 2*NINTMX + NU3 + NU3*NO
C
      NEED = MAX(NEED1,NEED2,NEED3)
      WRITE(6,90) NEED,MAX(NEED1,NEED2,MNND3)
C
      IF(NEED.GT.NGOTMX) THEN
         WRITE(6,91) NEED,NGOTMX
         CALL ABRT
      END IF
C
      CALL GETFM(NEED)
      IF(EXETYP.EQ.CHECK) GO TO 800
C
      CALL SRTING(IJKT,X(LXX),X(LIX),NINTMX,NO,NU,NSLICE,
     *          X(LVHHHH),X(LVPHHH),X(LVHPPH),X(LVPPHH),X(LVPPPH),
     *          X(LVPPPP),X(LTI0),X(LTI1),X(LTI3),EH,EP)
C
  800 CONTINUE
      CALL RETFM(NEED)
C
      CALL DCSRTING(NO,NU,LNUM,IFC,VEC,LVEC,MET,LNUMC)
      RETURN
C
 90   FORMAT(/1X,'MEMORY TO BE USED IN CC INTEGRAL SORTING IS',I12,
     *          ' WORDS.'/
     *        1X,'THE MINIMUM MEMORY TO ACCOMPLISH SORTING IS',I12,
     *          ' WORDS.')
 91   FORMAT(1X,'INSUFFICIENT MEMORY FOR CC INTEGRAL SORTING'/
     *       1X,'REQUIRED:',I12,'     AVAILABLE:',I12)
      END
C
C*MODULE DCCC    *DECK DCCCFOCK
C        MODIFIED FROM CCFOCK
      SUBROUTINE DCCCFOCK(INTG,FAO,FMO,VEC,FHH,FPP,FHP,WRK,WRK2,WRK3,
     *                    EH,EP,L1,L2,M1,M2,LNUMC,NO,NU,IFC)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION FAO(L2),FMO(M2),VEC(L1,L1),FHH(NO,NO),FPP(NU,NU),
     *          FHP(NO,NU),EH(NO),EP(NU),WRK(L1),WRK2(L1,L1),
     *          WRK3(LNUMC,M1)
      PARAMETER (ZERO=0.0D+00)
C
C        PERFORM A SIMILARITY TRANSFORMATION OVER ONLY THE
C        ORBITALS WHICH ARE TO BE INCLUDED IN THE CORRELATION.
C
      CALL TFTRI(FMO,FAO,VEC(1,IFC+1),WRK,M1,L1,L1)
C
C        FILL HOLE AND PARTICLE ORBITAL ENERGY ARRAY
C
      II = 0
      DO 101 I=1,NO+NU
         II = II+I
         IF(I.LE.NO) THEN
            EH(I) = FMO(II)
         ELSE
            EP(I-NO) = FMO(II)
         END IF
 101  CONTINUE
C
C        FILL HOLE/HOLE, PARTICLE/PARTICLE, AND HOLE/PARTICLE
C        BLOCKS OF THE FOCK MATRIX.  DIAGONALS ARE SET TO ZERO
C
      IJ = 0
      DO 103 I=1,NO
         DO 104 J=1,I
            IJ = IJ+1
            FHH(I,J)=FMO(IJ)
            FHH(J,I)=FMO(IJ)
 104     CONTINUE
         FHH(I,I)=ZERO
 103  CONTINUE
C
      DO 105 I=1,NU
         IROW = I+NO
         II = (IROW*IROW-IROW)/2
         DO 106 J=1,I
            JROW = J+NO
            IJ = II + JROW
            FPP(I,J)=FMO(IJ)
            FPP(J,I)=FMO(IJ)
 106     CONTINUE
         FPP(I,I)=ZERO
 105  CONTINUE
C
      DO 108 I=1,NU
         IROW = I+NO
         II = (IROW*IROW-IROW)/2
         DO 107 J=1,NO
            IJ = II + J
            FHP(J,I)=FMO(IJ)
 107     CONTINUE
 108  CONTINUE
C
C        THESE FOCK BLOCKS FORM THE FINAL RECORDS OF THE INTEGRAL FILE
C
      NLAST=5*NO+2*NU
      WRITE(INTG,REC=NLAST+1) FHH
      WRITE(INTG,REC=NLAST+2) FPP
      WRITE(INTG,REC=NLAST+3) FHP
C
C        FOR DC-CC EDA
C
      CALL EXPND(FAO,WRK2,L1,0)
      CALL MRARBR(WRK2,L1,LNUMC,L1,VEC(1,IFC+NO+1),L1,NU,WRK3,LNUMC)
      CALL MRTRBR(VEC(1,IFC+1),L1,LNUMC,NO,WRK3,LNUMC,NU,FHP,NO)
C
      WRITE(INTG,REC=NLAST+4) FHP
C
      RETURN
      END
C
C*MODULE DCCC    *DECK DCDRCCSD
C        MODIFIED FROM DRCCSD
      SUBROUTINE DCDRCCSD(NO,NU,OEH,OEP,IFC,EOM,ESUB,EMP2S)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL EOM
      LOGICAL CNVR
      DIMENSION OEH(NO),OEP(NU)
C
      COMMON /CCENGY/ ENRG,EREF,EMP2,ECCN,ETOT(6),ECORR(6),
     *                DIAGS(3),AMPMX(5,2),IAMPMX(5,4,2),XO1,XO2,
     *                DIFMAX,DIFFENG,ITER,CNVR
      COMMON /CCINFO/ TSH,NH,NP,MET,MEM,ICONV,MAXIT,IREST,IDISC
      COMMON /FMCOM / X(1)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      DATA CHECK/8HCHECK   /
C
      PARAMETER (TWO=2.0D+00)
C
C        ----- ALLOCATE MEMORY FOR THE CCSD ITERATIONS -----
C
      CALL GOTFM(NGOTMX)
      IF(MEM.LT.NGOTMX) NGOTMX=MEM
C
      NO2   = NO*NO
      NO3   = NO*NO2
      NO4   = NO*NO3
      NU2   = NU*NU
      NU3   = NU*NU2
      NOU   = NO*NU
      NO3U  = NO3*NU
      NOU3  = NO*NU3
      NO2U2 = NO2*NU2
C
C        CAUTION.  THE FIRST ARRAY ALLOCATED HERE, AT ADDRESS -LO1-
C        WILL BE PASSED TO ROUTINES DRCMP AND DRRLEN, WHICH WILL
C        RE-ALLOCATE SEVERAL ARRAYS BEGINNING AT THE SAME ADDRESS.
C
      CALL VALFM(LOADFM)
      LO1  = LOADFM + 1
      LT1  = LO1    + NOU
      LFH  = LT1    + NOU
      LFPH = LFH    + NO2
      LFP  = LFPH   + NOU
      LVHH = LFP    + NU2
      LVM  = LVHH   + NO4
      LTI  = LVM    + NO3U
      LO2  = LTI    + NU3
      LT2  = LO2    + NO2U2
      LVL  = LT2    + NO2U2
      LVR  = LVL    + NO2U2
      LVPP = LVR    + NO2U2
      LAST = LVPP   + NOU3
      NEED = LAST - LOADFM - 1
      IF(MET.EQ.0) WRITE(6,190) NEED
      IF(MET.EQ.1) WRITE(6,290) NEED
      IF(MET.GE.2) WRITE(6,390) NEED
C
      IF(NEED.GT.NGOTMX) THEN
         IF(MEM.EQ.0) WRITE(6,191)
         IF(MEM.EQ.1) WRITE(6,291)
         IF(MEM.EQ.2) WRITE(6,391)
         WRITE(6,92) NEED,NGOTMX
         CALL ABRT
      END IF
C
      CALL GETFM(NEED)
      IF(EXETYP.EQ.CHECK) CNVR=.TRUE.
      IF(EXETYP.EQ.CHECK) GO TO 800
C
C     OBTAIN MP2 ENERGY
C
      CALL RO2HPP(1,NO,NU,X(LTI),X(LO2))
      CALL ADDDEN(NO,NU,X(LO2),OEH,OEP)
      CALL ENERGYMMDC(NO,NU,X(LTI),X(LO2),X(LT2),EMP2S)
C
C        PERFORM CCSD ITERATIONS FOR T1 AND T2 AMPLITUDES
C
      CALL CCSD(NO,NU,X(LO1),X(LT1),X(LFH),X(LFPH),X(LFP),
     *          X(LVHH),X(LVM),X(LTI),X(LO2),X(LT2),X(LVL),X(LVR),
     *          X(LVPP),OEH,OEP,IFC,EOM)
C
C     PERFORM EDA
C
      CALL RO1(1,NO,NU,X(LT1))
      NLAST=5*NO+2*NU
      CALL RCCINT(NOU,NLAST+4,X(LFPH))
      ZZ=TWO*DDOT(NOU,X(LT1),1,X(LFPH),1)
      CALL ENERGYMMDC(NO,NU,X(LTI),X(LT2),X(LVR),ESUB)
      ESUB=ESUB+ZZ
C
  800 CONTINUE
      CALL RETFM(NEED)
      RETURN
C
190   FORMAT(/1X,'MEMORY REQUIRED FOR THE LCCD ITERATIONS IS',
     *            I12,' WORDS.')
290   FORMAT(/1X,'MEMORY REQUIRED FOR THE CCD ITERATIONS IS',
     *            I12,' WORDS.')
390   FORMAT(/1X,'MEMORY REQUIRED FOR THE CCSD ITERATIONS IS',
     *            I12,' WORDS.')
191   FORMAT(1X,'INSUFFICIENT MEMORY FOR LCCD STEP')
291   FORMAT(1X,'INSUFFICIENT MEMORY FOR CCD STEP')
391   FORMAT(1X,'INSUFFICIENT MEMORY FOR CCSD STEP')
 92   FORMAT(1X,'REQUIRED:',I12,'     AVAILABLE:',I12)
      END
C
C*MODULE DCCC    *DECK RDCCDC
      SUBROUTINE RDCCDC(ESUB,EMP2S,ECORRS,L1AT,ECOR,EMP2,ECORRT,
     *                  ISTCOR,IDMP)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION ESUB(L1AT),EMP2S(L1AT),ECORRS(6,L1AT),ECORRT(6)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      CHARACTER*8 STVEC
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     *** READ PARTIAL SUBSYSTEM CC ENERGY FOR RESTART ***
C
C     POSITION THE INPUT FILE TO $CCRES
C
      STVEC = ' $CCRES'
      CALL SEQREW(IR)
      CALL FNDGRP(IR,STVEC,IEOF)
C
      IF (IEOF.NE.0) THEN
C
C        $CCRES CARD NOT FOUND, KILL JOB
C
         IF (MASWRK) WRITE(IW,9020)
         CALL ABRT
         STOP
C
      ELSE
C
C        $CCRES CARD FOUND, READ THE CANONICAL DENSITY MATRIX
C
         IF (MASWRK) THEN
            READ(IR,9030,END=300,ERR=300) MET
            DO I0=1,ISTCOR-1
               READ(IR,9040,END=300,ERR=300) IDUM,ECCSUB,EMPSUB
               IF(IDUM.NE.I0) WRITE(IW,9300) IDUM,I0
               ESUB(I0)=ECCSUB
               EMP2S(I0)=EMPSUB
               ECOR=ECOR+ECCSUB
               EMP2=EMP2+EMPSUB
               WRITE(IW  ,9100) I0,ECCSUB,EMPSUB
               WRITE(IDMP,9040) I0,ECCSUB,EMPSUB
               IF(MET.GE.3) THEN
                  READ(IR,9050,END=300,ERR=300) ECORR1,ECORR2
                  ECORRS(1,I0)=ECORR1
                  ECORRS(2,I0)=ECORR2
                  ECORRT(1)=ECORRT(1)+ECORR1
                  ECORRT(2)=ECORRT(2)+ECORR2
                  WRITE(IW  ,9110) ECORR1,ECORR2
                  WRITE(IDMP,9050) ECORR1,ECORR2
               ENDIF
               IF(MET.GE.4) THEN
                  READ(IR,9050,END=300,ERR=300) ECORR3,ECORR4
                  ECORRS(3,I0)=ECORR3
                  ECORRS(4,I0)=ECORR4
                  ECORRT(3)=ECORRT(3)+ECORR3
                  ECORRT(4)=ECORRT(4)+ECORR4
                  WRITE(IW  ,9120) ECORR3,ECORR4
                  WRITE(IDMP,9050) ECORR3,ECORR4
               ENDIF
            END DO
         END IF
C
         IF (GOPARR) CALL DDI_BCAST(11201,'F',ESUB,ISTCOR-1,MASTER)
         IF (GOPARR) CALL DDI_BCAST(11202,'F',EMP2S,ISTCOR-1,MASTER)
C
      END IF
C
      RETURN
C
  300 CONTINUE
      IF (MASWRK) WRITE(IW,9200)
      CALL ABRT
      STOP
C
 9020 FORMAT(30H NO $CCRES INPUT FOUND - STOP  )
 9030 FORMAT(I1)
 9040 FORMAT(I5,2E21.12)
 9050 FORMAT(5X,2E21.12)
 9100 FORMAT(1X,'ISUB=',I5,' ECORR(CC)=',E15.7,' ECORR(MP2)=',E15.7)
 9110 FORMAT(11X,          ' CCSD[T]  =',E15.7,' CCSD(T)   =',E15.7)
 9120 FORMAT(11X,          ' R-CCSD[T]=',E15.7,' R-CCSD(T) =',E15.7)
 9200 FORMAT(' *** ERROR: PREMATURE END OF $CCRES')
 9300 FORMAT(' *** WARNING:'/
     *       ' $CCRES ENCOUNTERED SUBSYSTEM ',I5,' WHEN READING',I5)
      END
C
C*MODULE DCCC    *DECK ENERGYMMDC
C        MODIFIED FROM ENERGYMM
      SUBROUTINE ENERGYMMDC(NO,NU,TI,O2,V,Y)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION V(1),TI(1),O2(1)
      DATA TWO/2.0D+00/,HALF/0.5D+00/
C
      NO2U2 = NO*NO*NU*NU
      CALL RO2HPPDC(NO,NU,TI,V)
      CALL VECMUL(V,NO2U2,TWO)
      Y=DDOT(NO2U2,O2,1,V,1)
      CALL TRANMD(V,NO,NU,NU,NO,23)
      CALL VECMUL(V,NO2U2,HALF)
      Y=Y-DDOT(NO2U2,O2,1,V,1)
      RETURN
      END
C
C*MODULE DCCC    *DECK RO2HPPDC
C        MODIFIED FROM RO2HPP
      SUBROUTINE RO2HPPDC(NO,NU,TI,T2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER A,B
      DIMENSION TI(NU,NU,NO),T2(NO,NU,NU,NO)
      COMMON /CCFILE/ INTG,NT1,NT2,NT3,NVM,NVE,NFRLE,NRESF,NRESL
C
      DO 1 I=1,NO
      IASV=I+4+5*NO+2*NU
      READ(INTG,REC=IASV)TI
      DO 1 J=1,NO
      DO 1 A=1,NU
      DO 1 B=1,NU
      T2(I,A,B,J)=TI(A,B,J)
 1    CONTINUE
      RETURN
      END
C
C*MODULE DCCC    *DECK DCSRTING
C PARTIALLY MODIFIED FROM MP2NDC
      SUBROUTINE DCSRTING(NOC,NVIR,NBF,NFZC,VEC,LVEC,MET,LNUMC)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION VEC(NBF,*)
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXGSH=30, MXG2=MXGSH*MXGSH)
C
      LOGICAL DIRSCF,FDIFF,PACK2E
      COMMON /DCMEM2/ IPQRJI,IDCMOD
      COMMON /DIRMEM/ LPQRJ,IVEC,IDEN,IFCK,NUM,NOCC,NDIM,MINPQ,MAXPQ
      COMMON /FMCOM / X(1)
      COMMON /INT2IC/ NINTIC,ININTIC,NXXIC,LBUFPIC,LIXIC,LABSIX,NINTIX
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      LOGICAL DODCCR,ONLYOC,RMKORB,FZCORE,DOMP1,HFFRM
      COMMON /DCCORR/ RBUFCR,WOCC,ISTCOR,ITPART,DODCCR,ONLYOC,RMKORB,
     *                FZCORE,DOMP1,HFFRM
C
      DATA CHECK/8HCHECK   /
C
      ITVVVO=ITPART/10
      ITOOOV=ITPART-ITVVVO*10
      IDVOVO=1
      IF(WOCC.EQ.0.D0) IDVOVO=2
C
      NBF2 = (NBF*NBF+NBF)/2
      NBF3 = NBF*NBF
      NDIM = MAX(NBF2,NVIR*NOC)
      IF(MET.GE.3) NDIM = MAX(NDIM,NVIR*NVIR)
      IVEC = LVEC+NFZC*NBF
C
      IDCMOD=2
C
      CALL GOTFM(NGOTMX)
C
C     ----- SORT INTEGRALS INTO CLASSES FOR CC CALCULATIONS -----
C     WITHIN EACH CLASS, DIRECT ACCESS RECORDS ARE WRITTEN FOR
C     EASY RECOVERY OF ALL INTEGRALS WITH A SINGLE FIXED LABEL.
C
C      NHPPH = 0
C
C     ----- INTEGRAL STORAGE FOR DIRECT OR CONVENTIONAL MP2 -----
C     BEWARE!  THE DIRECT TRANSFORMATIONS PASS STORAGE LOCATIONS
C     FOR THE TRANSFORMED INTEGRAL ARRAY AND THE VECTORS THROUGH
C     THE -LPQRJ- AND -IVEC- VARIABLES IN COMMON.  THE NUMBER OF
C     MO-S IN THE 1ST INDEX TRANSFORM IS -NOCC-, WHICH IS SET LATER.
C
      CALL BASCHK(LMAX)
                    NANGM =  4
      IF(LMAX.EQ.2) NANGM =  6
      IF(LMAX.EQ.3) NANGM = 10
      IF(LMAX.EQ.4) NANGM = 15
      IF(LMAX.EQ.5) NANGM = 21
      IF(LMAX.EQ.6) NANGM = 28
      MAXG = NANGM**4
      NSH2 = (NSHELL*NSHELL+NSHELL)/2
C
      CALL VALFM(LOADFM)
      MINTMX=NINTMX
      IF(NINTIC.NE.0) MINTMX=0
      IF(DIRSCF) THEN
         LGHND  = 1      + LOADFM
         LXINTS = LGHND  + MAXG
         LDDIJ  = LXINTS + NSH2
         LXX    = LDDIJ  + 49*MXG2
         LIX    = LXX    + NINTMX
         LAST   = LIX    + NINTMX
      ELSE
         LGHND  = 1      + LOADFM
         LXINTS = LGHND
         LDDIJ  = LXINTS
         LXX    = LDDIJ
         LIX    = LXX    + MINTMX
         LAST   = LIX    + MINTMX
         IF(NINTIC.NE.0) THEN
            LXX  = LBUFPIC
            LIX  = LIXIC
         ENDIF
      END IF
      NEEDD = LAST - LOADFM - 1
      CALL GETFM(NEEDD)
C
      IF(DIRSCF) THEN
         IF(EXETYP.EQ.CHECK) THEN
            CALL VCLR(X(LXINTS),1,NSH2)
         ELSE
            IF(ISCHWZ.EQ.1) THEN
               CALL DAREAD(IDAF,IODA,X(LXINTS),NSH2,54,0)
            ELSE
               CALL DCOPY(NSH2,1.0D+01,0,X(LXINTS),1)
            END IF
         END IF
      END IF
C
      NGOT = NGOTMX - NEEDD
      IF(GOPARR) GO TO 600
C
C     ----- SEQUENTIAL SEGMENTED TRANSFORMATION -----
C     THE "SEGMENTED" TRANSFORMATION USES MORE MEMORY BUT LESS DISK
C     THAN THE "ALTERNATIVE" METHOD IMPLEMENTED BELOW.  IT HAS BOTH
C     DIRECT AND CONVENTIONAL TRANSFORMATIONS.
C
      LENTI1= NOC*NVIR*NVIR
      IF(MET.GE.3) LENTI1= NVIR*NVIR*NVIR
      NEED  = NBF3*2 + NBF + LENTI1
      LEFT  = NGOT - NEED
      NMIN  = NDIM*NBF
      MNMEM = NEEDD + NEED + NMIN*1
      MXMEM = NEEDD + NEED + NMIN*NOC
      IF(MASWRK) WRITE(IW,9110) MNMEM,MXMEM
C
      IF(NMIN.GT.LEFT) THEN
         NTOT = NEEDD + NEED + NMIN
         IF(MASWRK) WRITE(IW,9120) NTOT,NGOTMX
         IF(MASWRK) WRITE(IW,9130)
         CALL ABRT
      END IF
C
      LPASS = MIN(NOC,LEFT/NMIN)
      NPASS = (NOC+LPASS-1)/LPASS
      LPASS = (NOC+NPASS-1)/NPASS
C
      CALL VALFM(LOADFM)
      LIRP  = 1     + LOADFM
      LWRK1 = LIRP  + NBF
      LWRK2 = LWRK1 + NBF3
      LTI1  = LWRK2 + NBF3
      LPQRJ = LTI1  + LENTI1
      LAST  = LPQRJ + NDIM*NBF*LPASS
      NEEDE = LAST - LOADFM - 1
      CALL GETFM(NEEDE)
C
      IPQRJI= LPQRJ
      MEM = NEEDD + NEEDE
      IF(MASWRK) WRITE(IW,9150) LPASS,NPASS,MEM
      IF(EXETYP.EQ.CHECK) GO TO 700
C
      CALL CCSDC(VEC(1,NFZC+1),X(LPQRJ),
     *           X(LXX),X(LIX),X(LWRK1),X(LWRK2),X(LIRP),LNUMC,NBF,
     *           NBF3,NOC,NVIR,NDIM,IJK,NPASS,LPASS,X(LGHND),X(LXINTS),
     *           X(LDDIJ),X(LTI1),NINTMX,MAXG,NSH2,MXG2,IDVOVO)
C
      IF(MET.GE.3) THEN
         IVEC = LVEC+NFZC*NBF
         CALL CCSDC2(VEC(1,NFZC+1),X(LPQRJ),
     *           X(LXX),X(LIX),X(LWRK1),X(LWRK2),X(LIRP),LNUMC,NBF,
     *           NBF3,NOC,NVIR,NDIM,IJK,NPASS,LPASS,X(LGHND),X(LXINTS),
     *           X(LDDIJ),X(LTI1),NINTMX,MAXG,NSH2,MXG2,ITVVVO)
C
         CALL RETFM(NEEDE)
C
         LENTI1= NOC*NOC*NOC
         NEED  = NBF3*2 + NBF + LENTI1
         LEFT  = NGOT - NEED
         NMIN  = NDIM*NBF
         MNMEM = NEEDD + NEED + NMIN*1
         MXMEM = NEEDD + NEED + NMIN*NOC
         IF(MASWRK) WRITE(IW,9110) MNMEM,MXMEM
C
         LPASS = MIN(NVIR,LEFT/NMIN)
         NPASS = (NVIR+LPASS-1)/LPASS
         LPASS = (NVIR+NPASS-1)/NPASS
C
         CALL VALFM(LOADFM)
         LIRP  = 1     + LOADFM
         LWRK1 = LIRP  + NBF
         LWRK2 = LWRK1 + NBF3
         LTI1  = LWRK2 + NBF3
         LPQRJ = LTI1  + LENTI1
         LAST  = LPQRJ + NDIM*NBF*LPASS
         NEEDE = LAST - LOADFM - 1
         CALL GETFM(NEEDE)
C
         MEM = NEEDD + NEEDE
         IF(MASWRK) WRITE(IW,9150) LPASS,NPASS,MEM
C
         IVEC = LVEC+(NFZC+NOC)*NBF
         CALL CCSDC3(VEC(1,NFZC+1),X(LPQRJ),
     *           X(LXX),X(LIX),X(LWRK1),X(LWRK2),X(LIRP),LNUMC,NBF,
     *           NBF3,NOC,NVIR,NDIM,IJK,NPASS,LPASS,X(LGHND),X(LXINTS),
     *           X(LDDIJ),X(LTI1),NINTMX,MAXG,NSH2,MXG2,ITOOOV)
      ENDIF
      GO TO 700
C
C     ----- PARALLEL  -----
C
  600 CONTINUE
C
      WRITE(IW,*) "PARALLEL DC-CC HAS NOT BEEN IMPLEMENTED"
      CALL ABRT
C
      NEED  = NBF3*2 + NPROC
      LEFT  = NGOT - NEED
      NMIN  = NDIM*NBF
      IF(NMIN.GT.LEFT) THEN
         NTOT = NEEDD + NEED + NMIN
         IF(MASWRK) WRITE(IW,9320) NTOT,NGOTMX
         CALL ABRT
      END IF
C
C         -NOCP- ORBITALS WILL BE TRANSFORMED BY EACH NODE,
C         DOING -MOCP- OF THEN IN EACH PASS.  -IOCP- IS THE
C         INDEX OF THE FIRST ORBITAL ASSIGNED TO EACH NODE.
C
      IAP = ME+1
      NOCP = (NOC+NPROC-1)/NPROC
      MOCP = MIN(NOCP,LEFT/NMIN)
      NPASS= (NOCP+MOCP-1)/MOCP
      NOCP = NOCP-1
      NOCL = NOC-NPROC*NOCP
      IF(IAP.LE.NOCL) NOCP=NOCP+1
      IOCP = (IAP-1)*NOCP+1
      IF(IAP.GT.NOCL) IOCP = IOCP+NOCL
      MOCP = MIN(NOCP,MOCP)
C
      MNMEM = NEEDD + NEED + NMIN*1
      MXMEM = NEEDD + NEED + NMIN*NOCP
      IF(MASWRK) WRITE(IW,9310) MNMEM,MXMEM
C
      CALL VALFM(LOADFM)
      LWRK1 = 1     + LOADFM
      LWRK2 = LWRK1 + NBF3
      LJFLG = LWRK2 + NBF3
      LPQRJ = LJFLG + NPROC
      LAST  = LPQRJ + NDIM*NBF*MOCP
      NEEDE = LAST - LOADFM - 1
      CALL GETFM(NEEDE)
C
      MEM = NEEDD + NEEDE
      IF(MASWRK) WRITE(IW,9350) MOCP,NPASS,MEM
      IF(EXETYP.EQ.CHECK) GO TO 700
C
CPA    CALL CCPDC(E2OC,E2VI,ENG,VEC,X(LPQRJ),X(LPQRJI),X(LPQRJA),
CPA   *           X(LXX),X(LIX),X(LWRK1),X(LWRK2),X(IIRP),NBF,NOC,NVIR,
CPA     *           NDIM,IJK,IOCP,NOCP,MOCP,NPASS,X(LGHND),X(LXINTS),
CPA     *           X(LDDIJ),NINTMX,MAXG,NSH2,MXG2,X(LJFLG),NPROC-1)
C
  700 CONTINUE
      CALL RETFM(NEEDE)
      CALL RETFM(NEEDD)
      IDCMOD=3
C
      RETURN
 9110 FORMAT(/1X,'MEMORY REQUIREMENTS FOR CC TRANSFORMATION'/
     *       1X,'  MINIMUM=',I15,' WORDS, USING 1 MOLECULAR ORBITAL',
     *          ' PER PASS'/
     *       1X,'  MAXIMUM=',I15,' WORDS, MAKING ONLY 1 INTEGRAL PASS')
 9120 FORMAT(1X,'THERE IS INSUFFICIENT MEMORY TO RUN THE',
     *       1X,'CC TRANSFORMATION.'/
     *       1X,'REQUIRED,AVAILABLE MEMORY=',2I15,' WORDS.')
 9130 FORMAT(1X,'**** ERROR: TOO LITTLE MEMORY TO RUN CC *****'/
     *       1X,'INCREASE MEMORY TO AT LEAST THE MINIMUM SHOWN.')
 9150 FORMAT(1X,'CHOOSING THE CC TRANSFORMATION...'/
     *       1X,'  NUMBER OF MOS/PASS = ',I4/
     *       1X,'  NUMBER OF PASSES   = ',I4/
     *       1X,'  MEMORY USED = ',I15,' WORDS.')
 9310 FORMAT(/1X,'MEMORY REQUIREMENTS FOR PARALLEL CC TRANSFORMATION'/
     *       1X,'  MINIMUM=',I15,' WORDS, USING 1 ORBITAL PER PASS'/
     *       1X,'  MAXIMUM=',I15,' WORDS, MAKING ONLY 1 INTEGRAL PASS')
 9320 FORMAT(1X,'THERE IS INSUFFICIENT MEMORY TO RUN THE PARALLEL',
     *       1X,'CC TRANSFORMATION.'/
     *       1X,'REQUIRED,AVAILABLE MEMORY=',2I15,' WORDS.'/
     *       1X,'INCREASE MEMORY TO AT LEAST THE MINIMUM SHOWN.')
 9350 FORMAT(1X,'PARAMETERS FOR THE PARALLEL CC TRANSFORMATION'/
     *       1X,'  NUMBER OF MOS/NODE/PASS = ',I4/
     *       1X,'  NUMBER OF PASSES        = ',I4/
     *       1X,'  MEMORY USED = ',I15,' WORDS.')
      END
C
C*MODULE DCCC    *DECK CCSDC
C        MODIFIED FROM MP2SDC
      SUBROUTINE CCSDC(C,XPQRJ,XX,IX,X,Y,MOSIRP,LNUMC,
     *                 NBF,NBF3,NOC,NVIR,NDIM,IJK,NPASS,LPASS,GHONDO,
     *                 XINTS,DDIJ,TI1,NINTMX,MAXG,NSH2,MXG2,IDVOVO)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION C(NBF,*),XPQRJ(*),
     *          X(NBF3),Y(NBF3),MOSIRP(*),
     *          GHONDO(MAXG),XINTS(NSH2),DDIJ(MXG2),
     *          XX(NINTMX),IX(NINTMX)
C
      DIMENSION TI1(NVIR,NVIR,NOC)
C
      COMMON /CCFILE/ INTG,NT1,NT2,NT3,NVM,NVE,NFRLE,NRESF,NRESL
      COMMON /IOFILE/ IR,IW,IP,IK,IJKT,IDAF,NAV,IODA(950)
      COMMON /DIRMEM/ IPQKL,IVEC,IDEN,IFCK,NUM,NOCC,NNNDIM,MINPQ,MAXPQ
      COMMON /DCMEM2/ IPQRJI,IDCMOD
C
      J0 = 1
      CALL TSECND(TIM1)
C
      DO I=1, NBF
        MOSIRP(I)=1
      ENDDO
C
C     ----- LOOP OVER NUMBER OF PASSES -----
C     ----- FOR ALL  J = J0, ..., J0+NOCC-1 -----
C
      DO 100 IPASS=1,NPASS
         NOCC = MIN(NOC,J0+LPASS-1)-J0+1
C
C     ----- FORM -(PQ/RJ)- -----
C
         IDCMOD=2
         IF(IDVOVO.EQ.2) IDCMOD=1
         CALL MP2C1D(IJK,XPQRJ,XPQRJ,XX,IX,C(1,J0),
     *               NBF,NOCC,NDIM,GHONDO,XINTS,DDIJ,MAXG,NSH2,IDCMOD)
C
C     ----- FORM -(AI/RJ)- ALL A,I -----
C
         CALL MP2C23(XPQRJ,X,Y,C,NBF,NVIR,NOC,NOCC,NDIM,NBF)
C
C     ----- FORM -(AI/BJ)-  ALL B -----
C
         NMUL=NBF
         IF(IDVOVO.EQ.2) NMUL=LNUMC
         CALL MP2S4(XPQRJ,X,Y,C(1,NOC+1),MOSIRP,J0,NOC,NVIR,NBF,
     *              NOCC,NDIM,NMUL)
C
         DO NJ=1,NOCC
           NAI=0
           DO NA=1,NVIR
           DO NI=1,NOC
             NAI=NAI+1
             DO NB=1,NVIR
               TI1(NB,NA,NI)=XPQRJ(NDIM*NOCC*(NB-1)+NOCC*(NAI-1)+NJ)
             ENDDO
           ENDDO
           ENDDO
           IRC=2*NVIR+5*NOC+NJ+J0-1+4
           WRITE(INTG,REC=IRC) TI1
         ENDDO
C
         J0 = J0+NOCC
         IVEC = IVEC+NOCC*NBF
C
         CALL TSECND(TIM2)
         TIME = TIM2-TIM1
         TIM1 = TIM2
         WRITE(IW,9020) IPASS,TIME
         CALL FLSHBF(IW)
  100 CONTINUE
C
      RETURN
C
 9020 FORMAT(1X,'PASS #',I4,' TOOK',F12.2,' SECONDS.')
      END
C
C*MODULE DCCC    *DECK CCSDC2
C        MODIFIED FROM MP2SDC
      SUBROUTINE CCSDC2(C,XPQRJ,XX,IX,X,Y,MOSIRP,LNUMC,
     *                  NBF,NBF3,NOC,NVIR,NDIM,IJK,NPASS,LPASS,GHONDO,
     *                  XINTS,DDIJ,TI1,NINTMX,MAXG,NSH2,MXG2,ITVVVO)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION C(NBF,*),XPQRJ(*),
     *          X(NBF3),Y(NBF3),MOSIRP(*),
     *          GHONDO(MAXG),XINTS(NSH2),DDIJ(MXG2),
     *          XX(NINTMX),IX(NINTMX)
C
      DIMENSION TI1(NVIR,NVIR,NVIR)
C
      COMMON /CCFILE/ INTG,NT1,NT2,NT3,NVM,NVE,NFRLE,NRESF,NRESL
      COMMON /IOFILE/ IR,IW,IP,IK,IJKT,IDAF,NAV,IODA(950)
      COMMON /DIRMEM/ IPQKL,IVEC,IDEN,IFCK,NUM,NOCC,NNNDIM,MINPQ,MAXPQ
      COMMON /DCMEM2/ IPQRJI,IDCMOD
C
      J0 = 1
      CALL TSECND(TIM1)
C
      DO I=1, NBF
        MOSIRP(I)=1
      ENDDO
C
C     ----- LOOP OVER NUMBER OF PASSES -----
C     ----- FOR ALL  J = J0, ..., J0+NOCC-1 -----
C
      DO 100 IPASS=1,NPASS
         NOCC = MIN(NOC,J0+LPASS-1)-J0+1
C
C     ----- FORM -(PQ/RJ)- -----
C
         IDCMOD=2
         IF(ITVVVO.EQ.1 .OR. ITVVVO.EQ.2) IDCMOD=1
         CALL MP2C1D(IJK,XPQRJ,XPQRJ,XX,IX,C(1,J0),
     *               NBF,NOCC,NDIM,GHONDO,XINTS,DDIJ,MAXG,NSH2,IDCMOD)
C
C     ----- FORM -(AB/RJ)- ALL A,B -----
C
         NMUL=NBF
         IF(ITVVVO.EQ.1) NMUL=LNUMC
         CALL DCCC23(XPQRJ,X,Y,C,NBF,NOC+1,NVIR,NOCC,NDIM,NBF,NMUL)
C
C     ----- FORM -(AB/CJ)-  ALL C -----
C
         NMUL=NBF
         IF(ITVVVO.EQ.2) NMUL=LNUMC
         CALL DCCCS4(XPQRJ,X,Y,C(1,NOC+1),NVIR*NVIR,NVIR,NBF,NOCC,NDIM,
     *               NMUL)
C
         DO NJ=1,NOCC
           DO NC=1,NVIR
             NAB=0
             DO NB=1,NVIR
             DO NA=1,NVIR
               NAB=NAB+1
               TI1(NA,NB,NC)=XPQRJ(NDIM*NOCC*(NC-1)+NOCC*(NAB-1)+NJ)
             ENDDO
             ENDDO
           ENDDO
           IRC=2*NVIR+6*NOC+NJ+J0-1+4
           WRITE(INTG,REC=IRC) TI1
         ENDDO
C
         J0 = J0+NOCC
         IVEC = IVEC+NOCC*NBF
C
         CALL TSECND(TIM2)
         TIME = TIM2-TIM1
         TIM1 = TIM2
         WRITE(IW,9020) IPASS,TIME
         CALL FLSHBF(IW)
  100 CONTINUE
C
      RETURN
C
 9020 FORMAT(1X,'PASS #',I4,' TOOK',F12.2,' SECONDS.')
      END
C
C*MODULE DCCC    *DECK CCSDC3
C        MODIFIED FROM MP2SDC
      SUBROUTINE CCSDC3(C,XPQRJ,XX,IX,X,Y,MOSIRP,LNUMC,
     *                  NBF,NBF3,NOC,NVIR,NDIM,IJK,NPASS,LPASS,GHONDO,
     *                  XINTS,DDIJ,TI1,NINTMX,MAXG,NSH2,MXG2,ITOOOV)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION C(NBF,*),XPQRJ(*),
     *          X(NBF3),Y(NBF3),MOSIRP(*),
     *          GHONDO(MAXG),XINTS(NSH2),DDIJ(MXG2),
     *          XX(NINTMX),IX(NINTMX)
C
      DIMENSION TI1(NOC,NOC,NOC)
C
      COMMON /CCFILE/ INTG,NT1,NT2,NT3,NVM,NVE,NFRLE,NRESF,NRESL
      COMMON /IOFILE/ IR,IW,IP,IK,IJKT,IDAF,NAV,IODA(950)
      COMMON /DIRMEM/ IPQKL,IVEC,IDEN,IFCK,NUM,NOCC,NNNDIM,MINPQ,MAXPQ
      COMMON /DCMEM2/ IPQRJI,IDCMOD
C
      J0 = 1
      CALL TSECND(TIM1)
C
      DO I=1, NBF
        MOSIRP(I)=1
      ENDDO
C
C     ----- LOOP OVER NUMBER OF PASSES -----
C     ----- FOR ALL  J = J0, ..., J0+NVIRC-1 -----
C
      DO 100 IPASS=1,NPASS
         NVIRC = MIN(NVIR,J0+LPASS-1)-J0+1
         NOCC   = NVIRC
C
C     ----- FORM -(PQ/RA)- -----
C
         IDCMOD=1
         IF(ITOOOV.EQ.2) IDCMOD=2
         CALL MP2C1D(IJK,XPQRJ,XPQRJ,XX,IX,C(1,J0+NOC),
     *               NBF,NVIRC,NDIM,GHONDO,XINTS,DDIJ,MAXG,NSH2,IDCMOD)
C
C     ----- FORM -(JK/RA)- ALL J,K -----
C
         NMUL=NBF
         IF(ITOOOV.EQ.1) NMUL=LNUMC
         CALL DCCC23(XPQRJ,X,Y,C,NBF,1,NOC,NVIRC,NDIM,NBF,NMUL)
C
C     ----- FORM -(JK/IA)-  ALL I -----
C
         NMUL=LNUMC
         IF(ITOOOV.EQ.1 .OR. ITOOOV.EQ.2) NMUL=NBF
         CALL DCCCS4(XPQRJ,X,Y,C,NOC*NOC,NOC,NBF,NVIRC,NDIM,NMUL)
C
         DO NA=1,NVIRC
           DO NI=1,NOC
             NJK=0
             DO NJ=1,NOC
             DO NK=1,NOC
               NJK=NJK+1
               TI1(NK,NJ,NI)=XPQRJ(NDIM*NVIRC*(NI-1)+NVIRC*(NJK-1)+NA)
             ENDDO
           ENDDO
           ENDDO
           IRC=2*NVIR+7*NOC+NA+J0-1+4
           WRITE(INTG,REC=IRC) TI1
         ENDDO
C
         J0 = J0+NVIRC
         IVEC = IVEC+NVIRC*NBF
C
         CALL TSECND(TIM2)
         TIME = TIM2-TIM1
         TIM1 = TIM2
         WRITE(IW,9020) IPASS,TIME
         CALL FLSHBF(IW)
  100 CONTINUE
C
      RETURN
C
 9020 FORMAT(1X,'PASS #',I4,' TOOK',F12.2,' SECONDS.')
      END
C
C*MODULE DCCC     *DECK RCCINT
      SUBROUTINE RCCINT(LEN,IREC,T1)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION T1(LEN)
      COMMON /CCFILE/ INTG,NT1,NT2,NT3,NVM,NVE,NFRLE,NRESF,NRESL
C
      READ(INTG,REC=IREC)T1
      RETURN
      END
C
C*MODULE DCCC    *DECK DCCC23
      SUBROUTINE DCCC23(XPQRJ,X,Y,C,NBF,NST,NLEN,NOCC,NDIM,NUMR,NMUL)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION C(NBF,*),XPQRJ(NOCC,NDIM,NBF),X(NBF,NBF),Y(NBF,NBF)
C
C     ----- FORM (PI|RJ) , AND THEN (AI|RJ) -----
C        ON ENTRY XPQRJ IS MULTIPLIED BY OCCUPIED MO'S
C        AND THEN VIRTUAL.  ON EXIT XPQRJ IS REWRITTEN TO
C        CONTAIN 3-INDEX TRANSFORMED INTEGRAL
C           FIRST MATRIX MULTIPLY INVOLVES Y BEING RETURNED FROM
C        MULTIPLICATION OF X, CONTAINING ONE-INDEX TRANSFORMED
C        INTEGRALS, AND C, MO COEFFICIENTS FOR OCCUPIED
C        ORBITALS.
C           THE SECOND MATRIX MULTIPLY RETURNS X AFTER MULTIPLYING
C        A TRANSPOSE OF MO COEFFICIENTS FOR VIRTUAL ORBITALS
C        AND Y, THE TWO-INDEX TRANSFORMED INTEGRALS.
C
      DO 35 MR=1,NUMR
      DO 30 MJ=1,NOCC
         CALL VCLR(X,1,NBF*NBF)
         CALL VCLR(Y,1,NBF*NBF)
         MPQ=0
         DO 15 MP=1,NBF
            DO 10 MQ=1,MP
               MPQ=MPQ+1
               X(MP,MQ)=XPQRJ(MJ,MPQ,MR)
               X(MQ,MP)=X(MP,MQ)
   10       CONTINUE
   15    CONTINUE
C
         CALL MRARBR(X,NBF,NBF,NBF,C(1,NST),NBF,NLEN,Y,NBF)
         CALL MRTRBR(C(1,NST),NBF,NMUL,NLEN,Y,NBF,NLEN,X,NBF)
         MAI=0
         DO 25 MA=1,NLEN
            DO 20 MI=1,NLEN
               MAI=MAI+1
               XPQRJ(MJ,MAI,MR)=X(MA,MI)
   20       CONTINUE
   25    CONTINUE
C
   30 CONTINUE
   35 CONTINUE
      RETURN
      END
C
C*MODULE DCCC    *DECK DCCCS4
C        MODIFIED FROM MP2S4
      SUBROUTINE DCCCS4(XPQRJ,X,Y,CV,NAI,NVIR,NBF,NOCC,NDIM,NMUL)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION XPQRJ(NOCC,NDIM,NBF),X(NBF,*),Y(NBF,*),CV(NBF,*)
C
C     ----- FORM (AI/BJ) FOR CURRENT BATCH OF J -----
C
      DO 30 MAI=1,NAI
         DO 15 MJ=1,NOCC
            DO 10 MR=1,NMUL
               X(MR,MJ) = XPQRJ(MJ,MAI,MR)
   10       CONTINUE
   15    CONTINUE
C
         CALL MRTRBR(CV,NBF,NMUL,NVIR,X,NBF,NOCC,Y,NBF)
         DO 25 MB=1,NVIR
            DO 20 MJ=1,NOCC
               XPQRJ(MJ,MAI,MB) = Y(MB,MJ)
   20       CONTINUE
   25    CONTINUE
   30 CONTINUE
      RETURN
      END
C
C*MODULE DCCC    *DECK DRT3WT2DC
C        MODIFIED FROM DRT3WT2
      SUBROUTINE DRT3WT2DC(NO,NU,EH,EP)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION EH(NO),EP(NU)
      COMMON /CCINFO/ TSH,NH,NP,MET,MEM,ICONV,MAXIT,IREST,IDISC
      COMMON /FMCOM/ X(1)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      DATA CHECK/8HCHECK   /
C
      NO2   = NO*NO
      NO3   = NO*NO2
      NU2   = NU*NU
      NU3   = NU*NU2
      NOU   = NO*NU
      NO3U  = NO3*NU
      NOU3  = NO*NU3
      NO2U2 = NO2*NU2
C
      CALL GOTFM(NGOTMX)
      IF(MEM.LT.NGOTMX) NGOTMX=MEM
C
      CALL VALFM(LOADFM)
      I1   = LOADFM + 1
      I2   = I1     + NOU
      I3   = I2     + NO2U2
      I3T  = I3     + NO3U
      I4   = I3T    + NO3U
      I4T  = I4     + NOU3
      I5   = I4T    + NOU3
      I6   = I5     + NU3
      I7   = I6     + NU3
      I8   = I7     + NO2U2
      LAST = I8     + NOU
      NEED = LAST - LOADFM - 1
      WRITE(6,90) NEED
      CALL FLSHBF(6)
C
      IF(NEED.GT.NGOTMX) THEN
         WRITE(6,91) NEED,NGOTMX
         CALL ABRT
      END IF
C
      CALL GETFM(NEED)
      IF(EXETYP.EQ.CHECK) GO TO 800
C
      CALL T3WT2DC(NH,NP,X(I1),X(I2),X(I3),X(I3T),X(I4),X(I4T),X(I5),
     *             X(I6),X(I7),X(I8),EH,EP)
C
  800 CONTINUE
      CALL RETFM(NEED)
      RETURN
C
 90   FORMAT(/1X,'MEMORY REQUIRED FOR NONITERATIVE TRIPLES (T3WT2DC)',
     *           ' IS ',I12,' WORDS.')
 91   FORMAT(1X,'INSUFFICIENT MEMORY FOR NONITERATIVE TRIPLES'/
     *       1X,'REQUIRED:',I12,'     AVAILABLE:',I12)
      END
C
C*MODULE DCCC    *DECK T3WT2DC
C        MODIFIED FROM T3WT2
      SUBROUTINE T3WT2DC(NO,NU,T1,T2,VM,VMT,VE,VET,V3,T3,VOE,O1,EH,EP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION T1(1),T2(NU,NU,NO,NO),VM(NO,NU,NO,NO),VOE(1),
     *          V3(1),T3(1),VE(NU,NU,NU,NO),EH(NO),EP(NU),O1(1)
      DIMENSION VMT(NO,NU,NO,NO),VET(NU,NU,NU,NO)
      COMMON /CCRENO/ OSS,ODS,ODD,OTS,OTD,OTT,ODS_S,ODS_D,ODS_T,
     *                OQS,OQDS,OQDD,OQTS,ESD,ETD,ETS,ETTM,ESD_TM
      COMMON /CCINFO/ TSH,NH,NP,MET,MEM,ICONV,MAXIT,IREST,IDISC
      DATA ZERO/0.0D+00/, OM/-1.0D+00/, ONE/1.0D+00/
C
      NU2   = NU*NU
      NU3   = NU*NU2
      NOU   = NO*NU
C
      CALL ZEROMA(V3,1,NU3)
      OTS=ZERO
      OTD=ZERO
      ETD=ZERO
      ETTM=ZERO
      ESD_TM=ZERO
      CALL ZEROMA(T1,1,NOU)
      CALL RO2HPP(1,NO,NU,V3,VOE)
      CALL INSITU(NO,NU,NU,NO,V3,VOE,13)
      CALL TRANMD(VOE,NU,NU,NO,NO,12)
      CALL RDVEM4DC(0,NO,NU,V3,VE)
      CALL TRANMD(VE,NU,NU,NU,NO,23)
      CALL RDVEM4DC(1,NU,NO,V3,T2)
      CALL VMCP1(NO,NU,VM,T2)
      CALL TRANMD(VM,NO,NU,NO,NO,13)
      CALL RDVEM4(0,NO,NU,V3,VET)
      CALL TRANMD(VET,NU,NU,NU,NO,23)
      CALL RDVEM4(1,NU,NO,V3,T2)
      CALL VMCP1(NO,NU,VMT,T2)
      CALL TRANMD(VMT,NO,NU,NO,NO,13)
      CALL RO2(1,NO,NU,T2)
      CALL INSITU(NO,NU,NU,NO,V3,T2,13)
      CALL RO1(1,NO,NU,O1)
C
      KK=0
      DO 351 I=1,NO
         I1=I-1
      DO 351 J=1,I1
         J1=J-1
      DO 351 K=1,J1
         KK=IT3(I,J,K)
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,I),NU2,VM(1,1,K,J),NO,
     *ZERO,V3,NU2)
      CALL TRANT3(V3,NU,1)
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,I),NU2,VM(1,1,J,K),NO,
     *ONE,V3,NU2)
      CALL TRANT3(V3,NU,4)
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,J),NU2,VM(1,1,K,I),NO,
     *ONE,V3,NU2)
      CALL TRANT3(V3,NU,1)
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,J),NU2,VM(1,1,I,K),NO,
     *ONE,V3,NU2)
      CALL TRANT3(V3,NU,5)
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,K),NU2,VM(1,1,J,I),NO,
     *ONE,V3,NU2)
      CALL TRANT3(V3,NU,1)
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,K),NU2,VM(1,1,I,J),NO,
     *ONE,V3,NU2)
      CALL TRANT3(V3,NU,4)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,J,I),NU,VE(1,1,1,K),NU,
     *ONE,V3,NU)
      CALL TRANT3(V3,NU,1)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,K,I),NU,VE(1,1,1,J),NU,
     *ONE,V3,NU)
      CALL TRANT3(V3,NU,5)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,I,J),NU,VE(1,1,1,K),NU,
     *ONE,V3,NU)
      CALL TRANT3(V3,NU,1)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,K,J),NU,VE(1,1,1,I),NU,
     *ONE,V3,NU)
      CALL TRANT3(V3,NU,4)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,I,K),NU,VE(1,1,1,J),NU,
     *ONE,V3,NU)
      CALL TRANT3(V3,NU,1)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,J,K),NU,VE(1,1,1,I),NU,
     *ONE,V3,NU)
      CALL TRANT3(V3,NU,5)
      CALL ZEROT3(V3,NU)
      IF(IDISC.EQ.0.AND.MET.GT.4) THEN
      CALL WRT3(KK,NU,V3)
      END IF
C
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,I),NU2,VMT(1,1,K,J),NO,
     *ZERO,T3,NU2)
      CALL TRANT3(T3,NU,1)
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,I),NU2,VMT(1,1,J,K),NO,
     *ONE,T3,NU2)
      CALL TRANT3(T3,NU,4)
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,J),NU2,VMT(1,1,K,I),NO,
     *ONE,T3,NU2)
      CALL TRANT3(T3,NU,1)
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,J),NU2,VMT(1,1,I,K),NO,
     *ONE,T3,NU2)
      CALL TRANT3(T3,NU,5)
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,K),NU2,VMT(1,1,J,I),NO,
     *ONE,T3,NU2)
      CALL TRANT3(T3,NU,1)
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,K),NU2,VMT(1,1,I,J),NO,
     *ONE,T3,NU2)
      CALL TRANT3(T3,NU,4)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,J,I),NU,VET(1,1,1,K),NU,
     *ONE,T3,NU)
      CALL TRANT3(T3,NU,1)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,K,I),NU,VET(1,1,1,J),NU,
     *ONE,T3,NU)
      CALL TRANT3(T3,NU,5)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,I,J),NU,VET(1,1,1,K),NU,
     *ONE,T3,NU)
      CALL TRANT3(T3,NU,1)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,K,J),NU,VET(1,1,1,I),NU,
     *ONE,T3,NU)
      CALL TRANT3(T3,NU,4)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,I,K),NU,VET(1,1,1,J),NU,
     *ONE,T3,NU)
      CALL TRANT3(T3,NU,1)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,J,K),NU,VET(1,1,1,I),NU,
     *ONE,T3,NU)
      CALL TRANT3(T3,NU,5)
      CALL ZEROT3(T3,NU)
C
      CALL T3SQUADC(I,J,K,NO,NU,O1,T2,T3,V3,EH,EP)
      DEH=EH(I)+EH(J)+EH(K)
      CALL ADT3DEN(NU,DEH,V3,EP)
      ITMP=I
      JTMP=J
      KTMP=K
      CALL DRT1WT3IJK(ITMP,JTMP,KTMP,NO,NU,T1,VOE,V3,T3)
 351  CONTINUE
C
      DO 352 I=1,NO
         I1=I-1
      DO 352 J=1,I1
      KK=IT3(I,J,J)
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,I),NU2,VM(1,1,J,J),NO,
     *ZERO,V3,NU2)
      CALL TRANT3(V3,NU,2)
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,J),NU2,VM(1,1,J,I),NO,
     *ONE,V3,NU2)
      CALL TRANT3(V3,NU,1)
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,J),NU2,VM(1,1,I,J),NO,
     *ONE,V3,NU2)
      CALL TRANT3(V3,NU,4)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,J,I),NU,VE(1,1,1,J),NU,
     *ONE,V3,NU)
      CALL TRANT3(V3,NU,3)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,I,J),NU,VE(1,1,1,J),NU,
     *ONE,V3,NU)
      CALL TRANT3(V3,NU,1)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,J,J),NU,VE(1,1,1,I),NU,
     *ONE,V3,NU)
      CALL TRANT3(V3,NU,2)
      CALL SYMT311(V3,NU,23)
      CALL ZEROT3(V3,NU)
      IF(IDISC.EQ.0.AND.MET.GT.4) THEN
      CALL WRT3(KK,NU,V3)
      END IF
C
      KK=IT3(I,J,J)
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,I),NU2,VMT(1,1,J,J),NO,
     *ZERO,T3,NU2)
      CALL TRANT3(T3,NU,2)
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,J),NU2,VMT(1,1,J,I),NO,
     *ONE,T3,NU2)
      CALL TRANT3(T3,NU,1)
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,J),NU2,VMT(1,1,I,J),NO,
     *ONE,T3,NU2)
      CALL TRANT3(T3,NU,4)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,J,I),NU,VET(1,1,1,J),NU,
     *ONE,T3,NU)
      CALL TRANT3(T3,NU,3)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,I,J),NU,VET(1,1,1,J),NU,
     *ONE,T3,NU)
      CALL TRANT3(T3,NU,1)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,J,J),NU,VET(1,1,1,I),NU,
     *ONE,T3,NU)
      CALL TRANT3(T3,NU,2)
      CALL SYMT311(T3,NU,23)
      CALL ZEROT3(T3,NU)
C
      CALL T3SQUADC(I,J,J,NO,NU,O1,T2,T3,V3,EH,EP)
      DEH=EH(I)+EH(J)+EH(J)
      CALL ADT3DEN(NU,DEH,V3,EP)
      ITMP=I
      JTMP=J
      CALL DRT1WT3IJ(ITMP,JTMP,NO,NU,T1,VOE,V3,T3)
 352  CONTINUE
C
      DO 353 I=1,NO
         I1=I-1
      DO 353 J=1,I1
      KK=IT3(I,I,J)
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,I),NU2,VM(1,1,J,I),NO,
     *ZERO,V3,NU2)
      CALL TRANT3(V3,NU,1)
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,I),NU2,VM(1,1,I,J),NO,
     *ONE,V3,NU2)
      CALL TRANT3(V3,NU,2)
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,J),NU2,VM(1,1,I,I),NO,
     *ONE,V3,NU2)
      CALL TRANT3(V3,NU,2)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,I,I),NU,VE(1,1,1,J),NU,
     *ONE,V3,NU)
      CALL TRANT3(V3,NU,1)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,J,I),NU,VE(1,1,1,I),NU,
     *ONE,V3,NU)
      CALL TRANT3(V3,NU,3)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,I,J),NU,VE(1,1,1,I),NU,
     *ONE,V3,NU)
      CALL TRANT3(V3,NU,3)
      CALL SYMT311(V3,NU,12)
      CALL ZEROT3(V3,NU)
      IF(IDISC.EQ.0.AND.MET.GT.4) THEN
      CALL WRT3(KK,NU,V3)
      END IF
C
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,I),NU2,VMT(1,1,J,I),NO,
     *ZERO,T3,NU2)
      CALL TRANT3(T3,NU,1)
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,I),NU2,VMT(1,1,I,J),NO,
     *ONE,T3,NU2)
      CALL TRANT3(T3,NU,2)
      CALL DGEMM('N','N',NU2,NU,NO,OM,T2(1,1,1,J),NU2,VMT(1,1,I,I),NO,
     *ONE,T3,NU2)
      CALL TRANT3(T3,NU,2)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,I,I),NU,VET(1,1,1,J),NU,
     *ONE,T3,NU)
      CALL TRANT3(T3,NU,1)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,J,I),NU,VET(1,1,1,I),NU,
     *ONE,T3,NU)
      CALL TRANT3(T3,NU,3)
      CALL DGEMM('N','N',NU,NU2,NU,ONE,T2(1,1,I,J),NU,VET(1,1,1,I),NU,
     *ONE,T3,NU)
      CALL TRANT3(T3,NU,3)
      CALL SYMT311(T3,NU,12)
      CALL ZEROT3(T3,NU)
C
      CALL T3SQUADC(I,I,J,NO,NU,O1,T2,T3,V3,EH,EP)
      DEH=EH(I)+EH(I)+EH(J)
      CALL ADT3DEN(NU,DEH,V3,EP)
      ITMP=I
      JTMP=J
      CALL DRT1WT3JK(ITMP,JTMP,NO,NU,T1,VOE,V3,T3)
 353  CONTINUE
      CALL TRT1(NU,NO,T3,T1)
      CALL T1SQ(NO,NU,T3,T1)
      CALL ADDDEN1(NO,NU,T1,EH,EP)
      CALL WO1(4,NO,NU,T1)
      RETURN
      END
C
C*MODULE DCCC    *DECK RDVEM4DC
C        MODIFIED FROM RDVEM4
      SUBROUTINE RDVEM4DC(IN,NO,NU,TI,VEM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER A,B,C
      DIMENSION TI(NU,NU,NU),VEM(NU,NU,NU,NO)
      COMMON /CCFILE/ INTG,NT1,NT2,NT3,NVM,NVE,NFRLE,NRESF,NRESL
C
      NNO=NO
      NNU=NU
      IF (IN.EQ.1) THEN
         NNO=NU
         NNU=NO
      ENDIF
      NLAST=2*NNU+6*NNO+4
      DO 1 I=1,NO
      IASV=NLAST+NU*IN+I
      READ(INTG,REC=IASV)TI
      DO 1 A=1,NU
      DO 1 B=1,NU
      DO 1 C=1,NU
      VEM(A,B,C,I)=TI(A,B,C)
 1    CONTINUE
      RETURN
      END
C
C*MODULE DCCC    *DECK T3SQUADC
C        MODIFIED FROM T3SQUA
      SUBROUTINE T3SQUADC(I,J,K,NO,NU,T1,T2,T3,V3,EH,EP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL IEJ,JEK
      INTEGER A,B,C
      DIMENSION T1(NO,NU),T2(NU,NU,NO,NO),T3(NU,NU,NU),EH(NO),EP(NU)
      DIMENSION V3(NU,NU,NU)
      COMMON /CCRENO/ OSS,ODS,ODD,OTS,OTD,OTT,ODS_S,ODS_D,ODS_T,
     *                OQS,OQDS,OQDD,OQTS,ESD,ETD,ETS,ETTM,ESD_TM
      DATA TWO/2.0D+00/,FOUR/4.0D+00/,EIGHT/8.0D+00/,ZERO/0.0D+00/,
     *     HALF/0.5D+00/,ONE/1.0D+00/
C
      DIJK=EH(I)+EH(J)+EH(K)
      X1=ZERO
      X2=ZERO
      X3=ZERO
      DO 150 A=1,NU
      DO 150 B=1,NU
      DO 150 C=1,NU
      IF (A.EQ.B.AND.B.EQ.C)GOTO 150
      DABC=EP(A)+EP(B)+EP(C)
      DENOM=DIJK-DABC
      XT111=T1(I,A)*T1(J,B)*T1(K,C)
      XT21=T1(I,A)*T2(B,C,K,J)+T1(J,B)*T2(A,C,K,I)+T1(K,C)*T2(A,B,J,I)
      D1=  T3(A,B,C)
      D2=  T3(A,C,B)+T3(C,B,A)+T3(B,A,C)
      D3=  T3(B,C,A)+T3(C,A,B)
      F=D1*EIGHT-FOUR*D2+D3*TWO
      X1=X1+F*XT111/DENOM
      X2=X2+F*XT21/DENOM
      X3=X3+F*V3(A,B,C)/DENOM
 150  CONTINUE
      CF=ONE
      IEJ=I.EQ.J
      JEK=J.EQ.K
      IF(IEJ.OR.JEK) CF=HALF
      OTS=OTS+CF*X1
      OTD=OTD+CF*X2
      ETD=ETD+CF*X3
      RETURN
      END
C
