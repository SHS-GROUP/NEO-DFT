C 20 Sep 13 - MWS - BUNCON: adapt to possible input of zero contr.coefs
C 19 DEC 12 - JI,GDF - Add h/i functionality to SPDTR
C 21 AUG 12 - MWS - CORE/VALENCE SAPPORO BASIS SET FAMILY ADDED
C 15 APR 11 - MWS - SAPPORO FAMILY (SPK) OF BASES IS ON EXTERNAL FILE
C  1 OCT 10 - MJB,MK - IOTC, READ MCP BASES MCP-A?ZP, MCPC?ZP, MCPAC?ZP
C 11 AUG 10 - DGF - SYNCH COMMON BLOCK TINOPT
C 11 AUG 10 - MMG - ALLOW FOR RM1 SEMI-EMPIRICISM
C 23 JUN 10 - RP  - ALLOW FOR KARLSRUHE BASIS SETS
C 10 MAY 10 - TZ,MK - CUSTOMIZED BASIS SETS FOR DIFFERENT ATOMS, ZFK MCP
C 25 MAR 10 - HL  - RELAX ISPHER CHANGE OF 8/09 IN CASE OF MOROKUMA RUNS
C 14 AUG 09 - MWS - ENFORCE SPHERICAL HARMONICS FOR PC, CC (ETC) BASES
C 23 JAN 09 - DGF - FORBID USE OF NESOC=2, PENDING FIXES
C 18 JUL 08 - KRG - BASISS: RELOCATE JRET=1 CODE TO NAMEIO BLOCK
C 11 APR 08 - SAN - BASISS,MOLE: ADD G3LARGE BASIS SET, ENABLE G3(MP2)
C 21 MAY 07 - MWS - BASISS: IMPROVE POLAR= ERROR MESSAGE
C  7 SEP 06 - TK  - BASISS: CHANGE N-31G(*) POLARIZATION (K-CA,GA-KR)
C 29 MAR 06 - FLG - SETLAB: ELONGATION STORES ATOM FOR EVERY AO
C 19 SEP 05 - MK,GDF - CHANGES FOR MCP BASIS AND FOR H+I INPUT
C  5 JUL 05 - MWS - SELECT NEW ATOM,BASIS,EFP,PCM,DAF DIMENSIONS
C 27 JUN 05 - MWS - BASISS: REMOVE PCN AND CCN SPINACH AUTOMATICALLY
C 13 FEB 05 - MWS - PAD COMMON BLOCK NSHEL
C 19 MAY 04 - DGF - CHANGES TO ADD THE FMO METHOD
C  7 APR 04 - BSD - SETLAB: CHANGE VECTOR LABEL'S FORMAT
C  9 DEC 03 - MWS - SYNCH COMMON BLOCK RUNOPT
C  4 NOV 03 - MWS - FLIPB2,RWFINP: MERGE IN DOUGLAS-KROLL CHANGES
C  3 SEP 03 - MWS - SYNCHRONIZE RELWFN COMMON
C 16 JUN 03 - CHC - TIN2GMS: REMOVE NEED FOR LINKGE INPUT
C 26 MAR 02 - KRG - USE ABRT CALL
C  6 SEP 01 - MWS - ADD DUMMY ARGUMENTS TO NAME IO CALL
C 13 JUN 01 - DGF,TN - IMPLEMENT INTERNALLY UNCONTRACTED RESC METHOD
C  9 MAY 01 - RP  - BASISS: TEST FOR ECP USED WITH NON-ECP BASIS SET
C 11 JUN 00 - GNM - BASISS: KEYWORD TO REQUEST EXTERNAL BASIS FILE
C 25 MAR 00 - DGF,TN - CODE RESC AND NESC GRADIENT
C 10 MAR 00 - CHC - FIX SIMMOM SNAGS
C 10 JAN 00 - DGF - FINISH ADDING NESC (RELATIVISTIC METHOD OF K. DYALL)
C 21 DEC 99 - HN,DGF - ADD RESC; SPDTR: WRITE F AND G TRF MATS TO DAF;
C                   ADD NEW ROUTINES FLIPBASIS, RWFINP, RELCOEFS
C  9 NOV 99 - MWS - BASISS: ADD F'S TO 6-31G TM ONLY, FIXES 13FEB99 BUG
C  2 NOV 99 - MWS - TIN2GMS: TRUNCATE MAXATM FOR NON-TINKER GAMESS
C 29 AUG 99 - CHC - USER FRIENDLY INPUT OF QMMM
C  9 APR 99 - MWS - BASISS: FIX SBKJC POLARIZATION DEFAULT
C 13 FEB 99 - MWS - PROVIDE POLARIZATION EXPONENTS FOR K-ZN FOR 6-31G
C 12 NOV 98 - GDF - MAKE SYMTRY COMMON CONSISTENT
C 16 JUL 97 - MWS - SETLAB: ADJUST FORMATTING A BIT
C 30 SEP 96 - MWS - BASISS: IMPLEMENT NFFUNC KEYWORD
C  5 MAR 96 - MWS - CHANGE SHELL SYMMETRY PACKING COMMONS
C 14 SEP 95 - MWS - CHANGE CALL TO ATOMS ROUTINE
C 10 NOV 94 - MWS - REMOVE FTNCHEK WARNINGS
C 10 AUG 94 - MWS - INCREASE NUMBER OF DAF RECORDS
C  3 NOV 93 - MH  - MOLE,PTGRP: CHARMM SKIPS READ OF TITLE, POINT GROUP
C  1 NOV 92 - MWS - BASISS: LET LIGHT ATOMS SET TO "HW" BASIS
C 12 MAR 92 - MWS - REDIMENSION TO 500 ATOMS
C 24 FEB 92 - MWS - PTGRP: CHANGE TO USE OF SYMMOL COMMON
C 20 FEB 92 - TLW - MOLE: USE NEW CALL TO FNDGRP
C  6 FEB 92 - JHJ - BASISS: IF NO P,D POLAR=NONE.
C 30 JAN 92 - TLW - SETLAB: FIX INTERNAL READS AND WRITES
C 11 JAN 92 - TLW - MOLE,SETLAB: MAKE READS PARALLEL
C 10 JAN 92 - TLW - CHANGE REWIND TO CALL SEQREW
C  7 JAN 92 - TLW - MAKE WRITES PARALLEL;ADD COMMON PAR
C 16 AUG 91 - TLW - SPDTR: EXPANDED FOR F AND G FUNCTIONS
C 14 AUG 91 - TLW - SPDTR: ADD FTR AND GTR TO COMMON SYMSPD
C 12 JUN 91 - TJP,MWS - EXTEND POLARIZATION AND DIFFUSE FUNCTIONS TO RN
C 11 APR 91 - TJP - CHANGE GALLIUM DIFFUSE EXP. TO THE SEMICORE VALUE
C 22 MAR 91 - MWS - ADD TED PACKWOOD'S DIFFUSE EXPONENTS FOR GA-BR,IN-I
C 15 DEC 90 - MWS - 6-31G BASIS SETS USE BC BASIS FOR GA-KR NOW.
C  9 NOV 90 - JHJ - MOLE: CALL TO MBLDR ADDED, SETLAB: NEW CALL OPTION.
C 17 AUG 90 - TLW - SETLAB: ADD F AND G TYPES TO BFNAM.
C  7 AUG 90 - TLW - ADD CF AND CG TO COMMON NSHEL
C 25 JUL 90 - MWS - MOVE MOLPLT AND PLTORB INTERFACE TO PARLEY MODULE
C 13 JUN 90 - MWS - BASISS: MAKE POLARIZATION TABLES DOUBLE PRECISION
C 12 MAY 90 - MWS - SPLIT INPUT INTO INPUTA AND INPUTB
C
C*MODULE INPUTB  *DECK ATOMSS
      SUBROUTINE ATOMSS(NBFS,NAT,LOC,NS1
     *                 ,KMINO,KMAXO,KSTRTO,KTYPEO,KNGO,INTYPO,KATOM
     *                 ,KMINN,KMAXN,KSTRTN,KTYPEN,KNGN,INTYPN,KLOC)
C
C           COPY INFORMATION FOR ATOM RELATED BY SYMMETRY
C
      DIMENSION KMINN(NS1),KMAXN(NS1),KSTRTN(NS1),KATOM(NS1)
     *         ,KTYPEN(NS1),KNGN(NS1),INTYPN(NS1),KLOC(NS1)
     *         ,KMINO(NS1),KMAXO(NS1),KSTRTO(NS1)
     *         ,KTYPEO(NS1),KNGO(NS1),INTYPO(NS1),NBFS(*)
C
      DO 880 K = 1,NS1
         KMINN(K) = KMINO(K)
         KMAXN(K) = KMAXO(K)
         KSTRTN(K) = KSTRTO(K)
         KTYPEN(K) = KTYPEO(K)
         KNGN(K) = KNGO(K)
         INTYPN(K) = INTYPO(K)
         KATOM(K) = NAT
         KLOC(K) = LOC+1
         LOC = LOC+NBFS(INTYPO(K))
  880    CONTINUE
      RETURN
      END
C*MODULE INPUTB  *DECK BASISS
      SUBROUTINE BASISS
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION MCP_DZP, MCP_TZP, MCP_QZP
      DOUBLE PRECISION MCPCDZP, MCPCTZP, MCPCQZP
      DOUBLE PRECISION AMCP_DZP, AMCP_TZP, AMCP_QZP
      DOUBLE PRECISION AMCPCDZP, AMCPCTZP, AMCPCQZP
      DOUBLE PRECISION IMCP_NR1, IMCP_NR2, IMCP_SR1, IMCP_SR2
      DOUBLE PRECISION MOROKM
C
      CHARACTER*8 CHBASIS
      CHARACTER*80 LINE80
C
      LOGICAL DIFFS,DIFFSP,EXTFIL,GOPARR,DSKWRK,MASWRK,ZAPSPINACH,REQSPH
      LOGICAL ENDBAS,SECONDD
C
C        MAXL IS THE MAXIMUM SHELL TYPES GENERATED BELOW.
C        7 = THE SP(D) ATOMIC BASIS + UP TO 1 DIFFUSE SHELL
C          + UP TO 3 1ST LEVEL POLARIZATION FUNCTIONS
C          + UP TO 1 2ND LEVEL POLARIZATION + 1 BLANK CARD
C
      PARAMETER (NNAM=12, MAXA=103, MAXL=7, MAXP=86)
      PARAMETER (MXATM=2000)
C
      DIMENSION QNAM(NNAM), KQNAM(NNAM)
      DIMENSION SPLIT(3,3),SPLIT2(2),SPLIT3(3)
      DIMENSION POLF1(MAXP), POLF2(MAXP), POLF3(MAXP), POLF4(MAXP),
     *          POLF5(MAXP), POLF6(MAXP), ADIFF(MAXP), SPOL(MAXP),
     *          POLF7(MAXP)
C
      COMMON /BASISC/ GBASIS,AEX(MAXA,MAXL),ABASIS(MAXA,MAXL),
     *                IAGAUS(MAXA,MAXL),IRDBAS
      COMMON /BASISD/ BASNAM(MXATM),NUMBASNM,LUBASNM
      COMMON /BASSPH/ QMTTOL,ISPHER
      COMMON /COMPBS/ IGAUSS,NDFUNC,NFFUNC,NPFUNC,DIFFSP,DIFFS,
     *                POLAR
      COMMON /CXTHRM/ CXTHERM(11),CXZPE,METHCX,ICXBAS,ICXPCM,SECONDD
      COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SOOPT / NOSO
      COMMON /WFNMPC/ MPCALT,MPCGAU
C
      PARAMETER (ZERO=0.0D+00)
C
      DATA BASMD3,BASMND/8HMINDO   ,8HMNDO    /
      DATA BASAM1,BASPM3,BASRM1/8HAM1     ,8HPM3     ,8HRM1     /
      DATA BASSTO,BASN31,BASN21/8HSTO     ,8HN31     ,8HN21     /
      DATA BASDH, BASBC /8HDH      ,8HBC      /
      DATA BASMC, BAS311/8HMC      ,8HN311    /
      DATA BASDZV,BASTZV/8HDZV     ,8HTZV     /
      DATA SBK,BASSBK,BASHW /8HSBK     ,8HSBKJC   ,8HHW      /
      DATA BASMIN,BASMID/8HMINI    ,8HMIDI    /
      DATA BASS,BASP/8HS       ,8HP       /
      DATA BASD,BASF/8HD       ,8HF       /
      DATA BASL/8HL       /

C -RP-
      DATA BASKTZV,BASKTZVP/8HKTZV    ,8HKTZVP   /
      DATA BASKTZVPP/8HKTZVPP  /
C
      DATA BLANK,UNGIVEN/8H        ,8HBLANK   /
      DATA ANONE/8HNONE    /
      DATA MOROKM/8HMOROKUMA/
      DATA COMP /8HCOMP    /
C
      DATA DEFALT,POPN31/8HCOMMON  ,8HPOPN31  /
      DATA POP311,DUNNNG/8HPOPN311 ,8HDUNNING /
      DATA HUZNGA,HONDO7,UNDOC/8HHUZINAGA,8HHONDO7  ,8HUNDOC   /
      DATA BASG3L /8HG3L     /
      DATA BASG3LX/8HG3LX    /
C
      DATA BASPC0,BASPC1,BASPC2/8HPC0     ,8HPC1     ,8HPC2     /
      DATA BASPC3,BASPC4/8HPC3     ,8HPC4     /
      DATA BAAPC0,BAAPC1,BAAPC2/8HAPC0    ,8HAPC1    ,8HAPC2    /
      DATA BAAPC3,BAAPC4/8HAPC3    ,8HAPC4    /
      DATA BASCCD,BASCCT,BASCCQ/8HCCD     ,8HCCT     ,8HCCQ     /
      DATA BASCC5,BASCC6/8HCC5     ,8HCC6     /
      DATA BASNCD,BASNCT,BASNCQ/8HNCD     ,8HNCT     ,8HNCQ     /
      DATA BASNC5,BASNC6/8HNC5     ,8HNC6     /
      DATA BASACD,BASACT,BASACQ/8HACCD    ,8HACCT    ,8HACCQ    /
      DATA BASAC5,BASAC6/8HACC5    ,8HACC6    /
      DATA BACCCD,BACCCT,BACCCQ/8HCCDC    ,8HCCTC    ,8HCCQC    /
      DATA BACCC5,BACCC6/8HCC5C    ,8HCC6C    /
      DATA BACACD,BACACT,BACACQ/8HACCDC   ,8HACCTC   ,8HACCQC   /
      DATA BACAC5,BACAC6/8HACC5C   ,8HACC6C   /
      DATA BACWCD,BACWCT,BACWCQ/8HCCDWC   ,8HCCTWC   ,8HCCQWC   /
      DATA BACWC5,BACWC6/8HCC5WC   ,8HCC6WC   /
      DATA BACAWD,BACAWT,BACAWQ/8HACCDWC  ,8HACCTWC  ,8HACCQWC  /
      DATA BACAW5,BACAW6/8HACC5WC  ,8HACC6WC  /
C
      DATA MCP_DZP, MCP_TZP, MCP_QZP/8HMCP-DZP ,8HMCP-TZP ,8HMCP-QZP /
      DATA MCPCDZP, MCPCTZP,  MCPCQZP /8HMCPCDZP ,8HMCPCTZP ,8HMCPCQZP /
      DATA AMCP_DZP,AMCP_TZP, AMCP_QZP/8HMCP-ADZP,8HMCP-ATZP,8HMCP-AQZP/
      DATA AMCPCDZP,AMCPCTZP, AMCPCQZP/8HMCPACDZP,8HMCPACTZP,8HMCPACQZP/
      DATA IMCP_NR1, IMCP_NR2, IMCP_SR1, IMCP_SR2
     +   /8HIMCP-NR1, 8HIMCP-NR2, 8HIMCP-SR1, 8HIMCP-SR2/
C
      DATA ZFK5_DK3, ZFK4_DK3, ZFK3_DK3, ZFK5LDK3, ZFK4LDK3, ZFK3LDK3
     + /8HZFK5-DK3, 8HZFK4-DK3, 8HZFK3-DK3,
     +  8HZFK5LDK3, 8HZFK4LDK3, 8HZFK3LDK3/
C
      DATA SPK_DZP, SPK_TZP, SPK_QZP /8HSPK-DZP ,8HSPK-TZP ,8HSPK-QZP /
      DATA SPK_ADZP,SPK_ATZP,SPK_AQZP/8HSPK-ADZP,8HSPK-ATZP,8HSPK-AQZP/
      DATA SPKRDZP, SPKRTZP, SPKRQZP /8HSPKRDZP ,8HSPKRTZP ,8HSPKRQZP /
      DATA SPKRADZP,SPKRATZP,SPKRAQZP/8HSPKRADZP,8HSPKRATZP,8HSPKRAQZP/
C        note a=augmented in variables, but d=diffuse in strings
      DATA SPK_DZC, SPK_TZC, SPK_QZC /8HSPK-DZC ,8HSPK-TZC ,8HSPK-QZC /
      DATA SPK_ADZC,SPK_ATZC,SPK_AQZC/8HSPK-DZCD,8HSPK-TZCD,8HSPK-QZCD/
      DATA SPKRDZC, SPKRTZC, SPKRQZC /8HSPKRDZC ,8HSPKRTZC ,8HSPKRQZC /
      DATA SPKRADZC,SPKRATZC,SPKRAQZC/8HSPKRDZCD,8HSPKRTZCD,8HSPKRQZCD/
C
C    ---- STANDARD DIFFUSE EXPONENTS ----
C
      DATA ADIFF /0.0360D+00,0.086D+00,
     *  0.0074D+00,0.0207D+00,
     * 0.0315D+00,0.0438D+00,0.0639D+00,0.0845D+00,0.1076D+00,0.130D+00,
     *  0.0076D+00,0.0146D+00,
     * 0.0318D+00,0.0331D+00,0.0348D+00,0.0405D+00,0.0483D+00,0.060D+00,
     *  2*0.0D+00, 10*0.0D+00,
     *  0.0205D+00,0.0222D+00,0.0287D+00,0.0318D+00,0.0376D+00,0.0D+00,
     *  2*0.0D+00, 10*0.0D+00,
     *  0.0223D+00,0.0231D+00,0.0259D+00,0.0306D+00,0.0368D+00,0.0D+00,
     *  2*0.0D+00, 14*0.0D+00, 10*0.0D+00,
     *  0.0170D+00,0.0171D+00,0.0215D+00,0.0230D+00,0.0294D+00,0.0D+00/
C
C    ---- SECOND LEVEL POLARIZATION (I.E. F FUNCTIONS ON SP ATOMS) ----
C
      DATA SPOL/0.0D+00, 0.0D+00,
     *  0.15D+00,0.26D+00,
     *  0.50D+00,0.80D+00,1.00D+00,1.40D+00,1.85D+00,2.50D+00,
     *  0.15D+00,0.20D+00,
     *  0.25D+00,0.32D+00,0.45D+00,0.55D+00,0.70D+00,0.00D+00,
     *  68*0.0D+00/
C
C    ---- "COMMON" POLARIZATION SET ----
C    THESE VALUES ARE INSPIRED BY POPLE BASIS SETS FOR THE LIGHTER
C    ELEMENTS, AND BY THE HUZINAGA "GREEN BOOK" FOR THE HEAVIER ATOMS.
C
      DATA POLF1    /1.100D+00,1.100D+00,
     *   0.200D+00,0.400D+00,
     *   0.600D+00,0.800D+00,0.800D+00,0.800D+00,0.800D+00,0.800D+00,
     *   0.175D+00,0.175D+00,
     *   0.325D+00,0.395D+00,0.550D+00,0.650D+00,0.750D+00,0.850D+00,
     *   0.200D+00,0.200D+00,    10*0.0D+00,
     *   0.207D+00,0.246D+00,0.293D+00,0.338D+00,0.389D+00,0.443D+00,
     *   0.110D+00,0.110D+00,    10*0.0D+00,
     *   0.160D+00,0.183D+00,0.211D+00,0.237D+00,0.266D+00,0.297D+00,
     *   2*0.0D+00, 10*0.0D+00, 14*0.0D+00,
     *   0.146D+00,0.164D+00,0.185D+00,0.204D+00,0.225D+00,0.247D+00/
C
C    ---- "POPN31" POLARIZATION SET ----
C    VALUES BEYOND -KR- ARE ACTUALLY ADAPTED FROM HUZINAGA
C
      DATA POLF7    /1.100D+00,1.100D+00,
     *   0.200D+00,0.400D+00,
     *   0.600D+00,0.800D+00,0.800D+00,0.800D+00,0.800D+00,0.800D+00,
     *   0.175D+00,0.175D+00,
     *   0.325D+00,0.395D+00,0.550D+00,0.650D+00,0.750D+00,0.850D+00,
     *   0.4485D-01,0.502D-01,    10*0.8D+00,
     *   0.2289D+00,0.2772D+00,0.3277D+00,0.3810D+00,0.4366D+00,
     *   0.4948D+00,
     *   0.110D+00,0.110D+00,    10*0.0D+00,
     *   0.160D+00,0.183D+00,0.211D+00,0.237D+00,0.266D+00,0.297D+00,
     *   2*0.0D+00, 10*0.0D+00, 14*0.0D+00,
     *   0.146D+00,0.164D+00,0.185D+00,0.204D+00,0.225D+00,0.247D+00/
C
C    ---- "POPN311" POLARIZATION SET ----
C
      DATA POLF2    /0.750D+00,0.750D+00,
     *   0.200D+00,0.255D+00,
     *   0.401D+00,0.626D+00,0.913D+00,1.292D+00,1.750D+00,2.304D+00,
     *   0.175D+00,0.175D+00,
     *   0.325D+00,0.395D+00,0.550D+00,0.650D+00,0.750D+00,0.850D+00,
     *   0.200D+00,0.200D+00,  10*0.0D+00,
     *   0.207D+00,0.246D+00,0.293D+00,0.338D+00,0.389D+00,0.443D+00,
     *   0.110D+00,0.110D+00,  10*0.0D+00,
     *   0.160D+00,0.183D+00,0.211D+00,0.237D+00,0.266D+00,0.297D+00,
     *   2*0.0D+00, 10*0.0D+00, 14*0.0D+00,
     *   0.146D+00,0.164D+00,0.185D+00,0.204D+00,0.225D+00,0.247D+00/
C
C    ---- "DUNNING" POLARIZATION SET ----
C
      DATA POLF3    /1.000D+00,1.000D+00,
     *   0.200D+00,0.400D+00,
     *   0.700D+00,0.750D+00,0.800D+00,0.850D+00,0.900D+00,0.950D+00,
     *   0.175D+00,0.175D+00,
     *   0.325D+00,0.395D+00,0.550D+00,0.650D+00,0.750D+00,0.850D+00,
     *   0.260D+00,0.229D+00,  10*0.0D+00,
     *   0.141D+00,0.202D+00,0.273D+00,0.315D+00,0.338D+00,0.318D+00,
     *   0.110D+00,0.110D+00,  10*0.0D+00,
     *   0.160D+00,0.183D+00,0.211D+00,0.237D+00,0.266D+00,0.297D+00,
     *   2*0.0D+00, 10*0.0D+00, 14*0.0D+00,
     *   0.146D+00,0.164D+00,0.185D+00,0.204D+00,0.225D+00,0.247D+00/
C
C    ---- "HUZINAGA" POLARIZATION SET ----
C
      DATA POLF4    /1.000D+00,1.000D+00,    0.076D+00,0.164D+00,
     *   0.388D+00,0.600D+00,0.864D+00,1.154D+00,1.496D+00,1.888D+00,
     *   0.061D+00,0.101D+00,
     *   0.198D+00,0.262D+00,0.340D+00,0.421D+00,0.514D+00,0.617D+00,
     *   0.039D+00,0.059D+00,
     *   0.059D+00,0.065D+00,0.071D+00,0.077D+00,0.080D+00,0.082D+00,
     *   0.085D+00,0.088D+00,0.090D+00,0.095D+00,
     *   0.207D+00,0.246D+00,0.293D+00,0.338D+00,0.389D+00,0.443D+00,
     *   0.034D+00,0.048D+00,
     *   0.053D+00,0.059D+00,0.065D+00,0.070D+00,0.072D+00,0.074D+00,
     *   0.075D+00,0.077D+00,0.078D+00,0.800D+00,
     *   0.160D+00,0.183D+00,0.211D+00,0.237D+00,0.266D+00,0.297D+00,
     *   0.026D+00,0.037D+00,
     *   0.038D+00,0.039D+00,0.040D+00,0.041D+00,0.042D+00,0.043D+00,
     *   0.042D+00,0.043D+00,0.044D+00,0.045D+00,0.046D+00,0.047D+00,
     *   0.048D+00,0.049D+00,
     *   0.054D+00,0.059D+00,0.065D+00,0.069D+00,0.073D+00,
     *   0.077D+00,0.081D+00,0.086D+00,0.089D+00,0.093D+00,
     *   0.146D+00,0.164D+00,0.185D+00,0.204D+00,0.225D+00,0.247D+00/
C
C    ---- "HONDO7" POLARIZATION SET ----
C
      DATA POLF5    /1.000D+00,1.000D+00,
     *   0.200D+00,0.320D+00,
     *   0.500D+00,0.720D+00,0.980D+00,1.280D+00,1.620D+00,2.050D+00,
     *   0.157D+00,0.234D+00,
     *   0.311D+00,0.388D+00,0.465D+00,0.542D+00,0.619D+00,0.696D+00,
     *   0.200D+00,0.200D+00,  10*0.0D+00,
     *   0.207D+00,0.246D+00,0.293D+00,0.338D+00,0.389D+00,0.443D+00,
     *   0.110D+00,0.110D+00,  10*0.0D+00,
     *   0.160D+00,0.183D+00,0.211D+00,0.237D+00,0.266D+00,0.297D+00,
     *   2*0.0D+00, 10*0.0D+00, 14*0.0D+00,
     *   0.146D+00,0.164D+00,0.185D+00,0.204D+00,0.225D+00,0.247D+00/
C
C    ---- "UNDOC" POLARIZATION SET ----
C
      DATA POLF6    /1.100D+00,0.000D+00,
     *   0.200D+00,0.400D+00,
     *   0.600D+00,0.800D+00,0.800D+00,0.800D+00,0.800D+00,0.800D+00,
     *   0.175D+00,0.175D+00,
     *   0.325D+00,0.395D+00,0.550D+00,0.650D+00,0.750D+00,0.850D+00,
     *   0.200D+00,0.200D+00,    10*0.0D+00,
     *   0.141D+00,0.202D+00,0.273D+00,0.315D+00,0.338D+00,0.318D+00,
     *   0.110D+00,0.110D+00,    10*0.0D+00,
     *   0.160D+00,0.183D+00,0.211D+00,0.237D+00,0.266D+00,0.297D+00,
     *   2*0.0D+00, 10*0.0D+00, 14*0.0D+00,
     *   0.146D+00,0.164D+00,0.185D+00,0.204D+00,0.225D+00,0.247D+00/
C
C     ---- SET UP NAMELIST $BASIS TABLES ----
C
      DATA BASIS/8HBASIS   /
      DATA QNAM/8HGBASIS  ,8HNGAUSS  ,8HNPFUNC  ,8HNDFUNC  ,
     *          8HNFFUNC  ,8HDIFFSP  ,8HDIFFS   ,8HPOLAR   ,
     *          8HSPLIT2  ,8HSPLIT3  ,8HEXTFIL  ,8HBASNAM  /
      DATA KQNAM/5,1,1,1, 1,0,0,5, 23,33,0,20005/
C
C     ---- READ THE MOLECULAR BASIS FROM A $BASIS GROUP -----
C
      NUMBASNM = 0
C
      ZETA = ZERO
      DO 110 J=1,MAXL
         DO 100 I=1,MAXA
            ABASIS(I,J) = BLANK
            IAGAUS(I,J) = 0
            AEX(I,J) = ZERO
  100    CONTINUE
  110 CONTINUE
CSN
C     ---- ONLY CERTAIN VARIABLES INITIALIZED FOR COMPOSITE METHODS ----
C
      IF(RUNTYP.EQ.COMP .AND.(ICXBAS.EQ.3 .OR. ICXBAS.EQ.1)) THEN
      POLAR  = BLANK
      EXTFIL = .FALSE.
      SPLIT2(1) = 2.00D+00
      SPLIT2(2) = 0.50D+00
      SPLIT3(1) = 4.00D+00
      SPLIT3(2) = 1.00D+00
      SPLIT3(3) = 0.25D+00
      DO I=1,MXATM
        BASNAM(I)=BLANK
      ENDDO
      GO TO 111
      END IF
C
C     ---- INITIALIZE VARIABLES FOR NAMELIST $BASIS ----
C
      GBASIS = BLANK
      IGAUSS = 0
      NPFUNC = 0
      NDFUNC = 0
      NFFUNC = 0
      DIFFSP = .FALSE.
      DIFFS  = .FALSE.
      POLAR  = BLANK
      EXTFIL = .FALSE.
      SPLIT2(1) = 2.00D+00
      SPLIT2(2) = 0.50D+00
      SPLIT3(1) = 4.00D+00
      SPLIT3(2) = 1.00D+00
      SPLIT3(3) = 0.25D+00
      DO I=1,MXATM
        BASNAM(I)=BLANK
      ENDDO
C
  111 CONTINUE
C
C             ----- SELECT BASIS SET STYLE -----
C     MOST RUNS WILL LET THE USER PICK HOW TO DO THIS,
C        IRDBAS=0 MEANS $BASIS KEYWORDS SUCH AS -GBASIS- ARE USED
C        IRDBAS=1 MEANS ORIGINAL $DATA INPUT SPECIFICATION
C        IRDBAS=2 MEANS USER SUPPLIED S,P,...,L-ONLY EXTERNAL FILE
C        IRDBAS=3 MEANS "ON THE FLY" EXTERNAL FILE FROM -BASNAM-
C     BUT THERMOCHEMISTRY REQUIRES SEQUENCES OF STANDARD BASIS SETS.
C
      IF(ICXBAS.EQ.0) THEN
C
C     ---- READ NAMELIST $BASIS ----
C
         JRET = 0
         CALL NAMEIO(IR,JRET,BASIS,NNAM,QNAM,KQNAM,
     *               GBASIS,IGAUSS,NPFUNC,NDFUNC,NFFUNC,DIFFSP,DIFFS,
     *               POLAR,SPLIT2,SPLIT3,EXTFIL,BASNAM,
     *               0,0,
     *      0,0,0,0,0,  0,0,0,0,0,
     *      0,0,0,0,0,  0,0,0,0,0,   0,0,0,0,0,  0,0,0,0,0,
     *      0,0,0,0,0,  0,0,0,0,0,   0,0,0,0,0,  0,0,0,0,0)
C
         IF(JRET.EQ.2) THEN
            IF (MASWRK) WRITE(IW,9000)
            CALL ABRT
         END IF
C
C     ---- IF $BASIS NOT FOUND, WE MUST READ BASIS IN $DATA ----
C
         IF(JRET.EQ.1) THEN
            IRDBAS = 1
            RETURN
         END IF
C
C     ...BUT IF FOUND, WE ARE ON PATHWAY 0, 2, OR 3
C     -EXTFIL- GETS ADJUSTED BELOW, SO ONLY THEN CAN WE SET '2'
C
         IRDBAS = 0
         IF(BASNAM(1).NE.BLANK) IRDBAS = 3
C
C     ---- THIS PART FORCES BASIS SETS FOR THERMOCHEMISTRY SCHEMES ----
C
      ELSE IF(ICXBAS.EQ.1) THEN
         GBASIS = BASN31
         IGAUSS = 6
         NDFUNC = 1
         IRDBAS = 0
      ELSE IF(ICXBAS.EQ.2) THEN
         GBASIS = BASG3L
         IGAUSS = 0
         NDFUNC = 0
         IRDBAS = 0
      ELSE IF(ICXBAS.EQ.3) THEN
         IRDBAS=0
CSN      NUM = 0
      END IF
C
C         SOME OF THE BASIS SETS ARE SUPPLIED ON DISK FILES
C
      IF(GBASIS.EQ.MCP_DZP .OR. GBASIS.EQ.MCP_TZP  .OR.
     *   GBASIS.EQ.MCP_QZP .OR. GBASIS.EQ.IMCP_NR1 .OR.
     *   GBASIS.EQ.IMCP_NR2.OR. GBASIS.EQ.IMCP_SR1 .OR.
     *   GBASIS.EQ.IMCP_SR2.OR.
     +   GBASIS.EQ.MCPCDZP  .OR. GBASIS.EQ.MCPCTZP  .OR.
     +   GBASIS.EQ.MCPCQZP  .OR.
     +   GBASIS.EQ.AMCP_DZP .OR. GBASIS.EQ.AMCP_TZP .OR.
     +   GBASIS.EQ.AMCP_QZP .OR.
     +   GBASIS.EQ.AMCPCDZP .OR. GBASIS.EQ.AMCPCTZP .OR.
     +   GBASIS.EQ.AMCPCQZP) EXTFIL=.TRUE.
C
      IF(GBASIS.EQ.ZFK5_DK3.OR. GBASIS.EQ.ZFK4_DK3 .OR.
     *   GBASIS.EQ.ZFK3_DK3.OR. GBASIS.EQ.ZFK5LDK3 .OR.
     *   GBASIS.EQ.ZFK4LDK3.OR. GBASIS.EQ.ZFK3LDK3) EXTFIL=.TRUE.
C
      IF(GBASIS.EQ.SPK_DZP   .OR. GBASIS.EQ.SPK_TZP  .OR.
     *   GBASIS.EQ.SPK_QZP   .OR.
     *   GBASIS.EQ.SPK_ADZP  .OR. GBASIS.EQ.SPK_ATZP .OR.
     *   GBASIS.EQ.SPK_AQZP  .OR.
     *   GBASIS.EQ.SPKRDZP   .OR. GBASIS.EQ.SPKRTZP  .OR.
     *   GBASIS.EQ.SPKRQZP   .OR.
     *   GBASIS.EQ.SPKRADZP  .OR. GBASIS.EQ.SPKRATZP .OR.
     *   GBASIS.EQ.SPKRAQZP) EXTFIL=.TRUE.
C
      IF(GBASIS.EQ.SPK_DZC   .OR. GBASIS.EQ.SPK_TZC  .OR.
     *   GBASIS.EQ.SPK_QZC   .OR.
     *   GBASIS.EQ.SPK_ADZC  .OR. GBASIS.EQ.SPK_ATZC .OR.
     *   GBASIS.EQ.SPK_AQZC  .OR.
     *   GBASIS.EQ.SPKRDZC   .OR. GBASIS.EQ.SPKRTZC  .OR.
     *   GBASIS.EQ.SPKRQZC   .OR.
     *   GBASIS.EQ.SPKRADZC  .OR. GBASIS.EQ.SPKRATZC .OR.
     *   GBASIS.EQ.SPKRAQZC) EXTFIL=.TRUE.
C
      IF(EXTFIL) THEN
         IF(MASWRK) WRITE(IW,9040) GBASIS
         IRDBAS = 2
         RETURN
      END IF
C
      IF(GBASIS.EQ.SBK) GBASIS=BASSBK
C
      IF(IECP.NE.0 .AND. (GBASIS.NE.BASSBK .AND. GBASIS.NE.BASHW
     *                                     .AND. IRDBAS.NE.3)) THEN
         IF(MASWRK) WRITE(IW,9050) GBASIS
         CALL ABRT
      END IF
C
C        SEMI-EMPIRICAL RUNS (WHICH DON'T EVEN USE GAUSSIAN BASIS SETS)
C        DO NOT USE SUPPLEMENTARY FUNCTIONS, SO IGNORE ANY SUCH INPUT.
C        LIKEWISE, POLARIZATION-CONSISTENT AND CORRELATION-CONSISTENT
C        BASIS SETS SHOULD NOT HAVE ANY "SPINACH" ADDED TO -GBASIS-,
C        AS THEY CAREFULLY ADD THEIR OWN RECIPE FOR THIS.
C
      ZAPSPINACH=.FALSE.
      IF(GBASIS.EQ.BASMD3  .OR.  GBASIS.EQ.BASMND  .OR.
     *   GBASIS.EQ.BASAM1  .OR.  GBASIS.EQ.BASPM3  .OR.
     *   GBASIS.EQ.BASRM1) ZAPSPINACH=.TRUE.
      IF(GBASIS.EQ.BASPC0  .OR.  GBASIS.EQ.BASPC1  .OR.
     *   GBASIS.EQ.BASPC2  .OR.  GBASIS.EQ.BASPC3  .OR.
     *   GBASIS.EQ.BASPC4) ZAPSPINACH=.TRUE.
      IF(GBASIS.EQ.BAAPC0  .OR.  GBASIS.EQ.BAAPC1  .OR.
     *   GBASIS.EQ.BAAPC2  .OR.  GBASIS.EQ.BAAPC3  .OR.
     *   GBASIS.EQ.BAAPC4) ZAPSPINACH=.TRUE.
      IF(GBASIS.EQ.BASCCD  .OR.  GBASIS.EQ.BASCCT  .OR.
     *   GBASIS.EQ.BASCCQ  .OR.  GBASIS.EQ.BASCC5  .OR.
     *   GBASIS.EQ.BASCC6) ZAPSPINACH=.TRUE.
      IF(GBASIS.EQ.BASNCD  .OR.  GBASIS.EQ.BASNCT  .OR.
     *   GBASIS.EQ.BASNCQ  .OR.  GBASIS.EQ.BASNC5  .OR.
     *   GBASIS.EQ.BASNC6) ZAPSPINACH=.TRUE.
      IF(GBASIS.EQ.BASACD  .OR.  GBASIS.EQ.BASACT  .OR.
     *   GBASIS.EQ.BASACQ  .OR.  GBASIS.EQ.BASAC5  .OR.
     *   GBASIS.EQ.BASAC6) ZAPSPINACH=.TRUE.
      IF(GBASIS.EQ.BACCCD  .OR.  GBASIS.EQ.BACCCT  .OR.
     *   GBASIS.EQ.BACCCQ  .OR.  GBASIS.EQ.BACCC5  .OR.
     *   GBASIS.EQ.BACCC6) ZAPSPINACH=.TRUE.
      IF(GBASIS.EQ.BACACD  .OR.  GBASIS.EQ.BACACT  .OR.
     *   GBASIS.EQ.BACACQ  .OR.  GBASIS.EQ.BACAC5  .OR.
     *   GBASIS.EQ.BACAC6) ZAPSPINACH=.TRUE.
      IF(GBASIS.EQ.BACWCD  .OR.  GBASIS.EQ.BACWCT  .OR.
     *   GBASIS.EQ.BACWCQ  .OR.  GBASIS.EQ.BACWC5  .OR.
     *   GBASIS.EQ.BACWC6) ZAPSPINACH=.TRUE.
      IF(GBASIS.EQ.BACAWD  .OR.  GBASIS.EQ.BACAWT  .OR.
     *   GBASIS.EQ.BACAWQ  .OR.  GBASIS.EQ.BACAW5  .OR.
     *   GBASIS.EQ.BACAW6) ZAPSPINACH=.TRUE.
      IF(GBASIS.EQ.MCP_DZP .OR. GBASIS.EQ.MCP_TZP  .OR.
     *   GBASIS.EQ.MCP_QZP .OR. GBASIS.EQ.IMCP_NR1 .OR.
     *   GBASIS.EQ.IMCP_NR2.OR. GBASIS.EQ.IMCP_SR1 .OR.
     *   GBASIS.EQ.IMCP_SR2 .OR.
     +   GBASIS.EQ.MCPCDZP .OR. GBASIS.EQ.MCPCTZP  .OR.
     +   GBASIS.EQ.MCPCQZP .OR.
     +   GBASIS.EQ.AMCP_DZP .OR. GBASIS.EQ.AMCP_TZP .OR.
     +   GBASIS.EQ.AMCP_QZP .OR.
     +   GBASIS.EQ.AMCPCDZP .OR. GBASIS.EQ.AMCPCTZP .OR.
     +   GBASIS.EQ.AMCPCQZP) ZAPSPINACH=.TRUE.
C -RP-
      IF(GBASIS.EQ.BASKTZV .OR. GBASIS.EQ.BASKTZVP .OR.
     *   GBASIS.EQ.BASKTZVPP)
     *   ZAPSPINACH=.TRUE.
C
C          SEMI-EMPIRICAL SETS ARE OF COURSE STO-TYPE BASIS SETS!!!
C          BUT, GAUSSIAN APPROXIMATIONS TO THEM, OF STO-NG FORM, CAN
C          BE USED FOR PLOTTING PURPOSES (MORE OR LESS), AND HENCE
C          THAT EXPANSION LENGTH CAN BE STORED FOR SUCH PURPOSES.
C          0 SUPPRESSES PUTTING THE STO-NG EXANSIONS ON THE LOG FILE.
      IF(GBASIS.EQ.BASMD3  .OR.  GBASIS.EQ.BASMND  .OR.
     *   GBASIS.EQ.BASAM1  .OR.  GBASIS.EQ.BASPM3  .OR.
     *   GBASIS.EQ.BASRM1) MPCGAU=IGAUSS
C
      IF(ZAPSPINACH) THEN
         IGAUSS=0
         NDFUNC=0
         NPFUNC=0
         NFFUNC=0
         DIFFSP=.FALSE.
         DIFFS=.FALSE.
         POLAR=ANONE
      END IF
C
      SPLIT(1,1) = 1.0D+00
      SPLIT(2,1) = SPLIT2(1)
      SPLIT(2,2) = SPLIT2(2)
      SPLIT(3,1) = SPLIT3(1)
      SPLIT(3,2) = SPLIT3(2)
      SPLIT(3,3) = SPLIT3(3)
C
      IF(POLAR.EQ.BLANK) THEN
         IF(GBASIS.EQ.BASMIN) POLAR=HUZNGA
         IF(GBASIS.EQ.BASMID) POLAR=HUZNGA
         IF(GBASIS.EQ.BASSTO) POLAR=DEFALT
         IF(GBASIS.EQ.BASN21) POLAR=DEFALT
         IF(GBASIS.EQ.BASN31) POLAR=POPN31
         IF(GBASIS.EQ.BAS311) POLAR=POP311
         IF(GBASIS.EQ.BASMC ) POLAR=POP311
         IF(GBASIS.EQ.BASSBK) POLAR=DEFALT
         IF(GBASIS.EQ.BASHW ) POLAR=DEFALT
         IF(GBASIS.EQ.BASDH ) POLAR=DUNNNG
         IF(GBASIS.EQ.BASBC ) POLAR=DUNNNG
         IF(GBASIS.EQ.BASDZV) POLAR=DUNNNG
         IF(GBASIS.EQ.BASTZV) POLAR=HONDO7
         IF(GBASIS.EQ.BASG3L) POLAR=ANONE
         IF(GBASIS.EQ.BASG3LX) POLAR=ANONE
      END IF
      IF(NPFUNC+NDFUNC.EQ.0) POLAR=ANONE
C
      IF(GBASIS.NE.BASSTO  .AND.  GBASIS.NE.BASN21  .AND.
     *   GBASIS.NE.BASN31  .AND.  GBASIS.NE.BAS311 .AND.
     *   GBASIS.NE.BASG3L  .AND.  GBASIS.NE.BASG3LX) IGAUSS=0
C
      IF(RUNTYP.NE.COMP .OR.
     *  (RUNTYP.EQ.COMP .AND. ICXBAS.NE.1)) THEN
      IF (MASWRK) WRITE (IW,9010) GBASIS, IGAUSS, POLAR,
     *                NDFUNC, NFFUNC, DIFFSP,
     *                NPFUNC, DIFFS, BASNAM(1)
      IF((NDFUNC.EQ.2 .OR. NPFUNC.EQ.2) .AND. MASWRK)
     *  WRITE(IW,9020) SPLIT2
      IF((NDFUNC.EQ.3 .OR. NPFUNC.EQ.3) .AND. MASWRK)
     *  WRITE(IW,9030) SPLIT3
      END IF
C
C           THE -BASNAM- KEYWORD GENERATES AN EXTERNAL BASIS SET FILE,
C           ON THE FLY, BY COPYING ITS INFORMATION FROM THE INPUT FILE.
C           REMEMBER, THIS IS BEFORE READING $DATA, SO WE CAN'T CHECK
C           THE NUMBER OF BASIS SET NAMES AGAINST THE NUMBER OF ATOMS.
C
      IF(IRDBAS.EQ.3) THEN
         IF(MASWRK) WRITE(IW,7002)
C
C                  'WORK15' USED AS FORMATTED DATA
C              THIS FILE WILL BE CLOSED WITH DELETION,
C              SO IT CAN BE USED AS A BINARY FILE LATER.
         LUBASNM = 15
         CALL SEQOPN(LUBASNM,'WORK15','NEW',.FALSE.,'FORMATTED')
C
         ISBAS = 1
         DO WHILE (BASNAM(ISBAS).NE.BLANK)
           IF(MASWRK) THEN
             WRITE(IW,7003) ISBAS,BASNAM(ISBAS)
           ENDIF
           ISBAS = ISBAS + 1
         ENDDO
         NUMBASNM = ISBAS - 1
         IF(MASWRK) WRITE(IW,7004) NUMBASNM
C
         NUNIQ = 0
         DO 700 I=1,NUMBASNM
            DO J=1,I-1
               IF(BASNAM(J).EQ.BASNAM(I)) GO TO 700
            ENDDO
            NUNIQ = NUNIQ + 1
            WRITE(UNIT=CHBASIS,FMT='(2H $,A6)') BASNAM(I)
            CALL SEQREW(IR)
            CALL FNDGRP(IR,CHBASIS,IEOF)
            IF(IEOF.NE.0) THEN
               IF(MASWRK) WRITE(IW,7006) CHBASIS
               CALL ABRT
            END IF
C      ONLY THE MASTER COPIES BASIS FROM THE INPUT TO FILE -LUBASNM-
C      WHAT WE ARE TRYING TO DO HERE IS CREATE AN EXTERNAL BASIS FILE,
C      ON A TEMPORARY FILE -LUBASNM- WHICH WILL BE DELETED LATER.
            IF(MASWRK) THEN
               WRITE(IW,7005) CHBASIS
               WRITE(LUBASNM,FMT='(A8)') CHBASIS
               ENDBAS = .FALSE.
               DO WHILE (.NOT.ENDBAS)
                  READ(IR,FMT='(A80)') LINE80
                  WRITE(IW,*) LINE80(1:30)
                  CALL UPRCAS(LINE80,80)
                  WRITE(LUBASNM,FMT='(A80)') LINE80
                  IF(LINE80(1:5).EQ.' $END') ENDBAS = .TRUE.
               ENDDO
            ENDIF
  700    CONTINUE
         IF(MASWRK) WRITE(IW,7007) NUNIQ
C
C ...      CHECK IF $MCP GROUP PRESENT
         IF(MASWRK) WRITE(IW,FMT='(/5X,''SEARCHING FOR $MCP'')')
         CALL SEQREW(IR)
         CALL FNDGRP(IR,' $MCP   ',IEOF)
         IF(IEOF.EQ.0) THEN
            IF(MASWRK) WRITE(IW,FMT='(5X,''$MCP GROUP FOUND'')')
            WRITE(LUBASNM,FMT='('' $MCP'')')
            ENDBAS = .FALSE.
            IF(MASWRK) THEN
               DO WHILE (.NOT.ENDBAS)
                  READ(IR,FMT='(A80)') LINE80
                  WRITE(IW,*) LINE80(1:30)
                  CALL UPRCAS(LINE80,80)
                  WRITE(LUBASNM,FMT='(A80)') LINE80
                  IF(LINE80(1:5).EQ.' $END') ENDBAS = .TRUE.
                ENDDO
            ENDIF
         ELSE
            IF(MASWRK) WRITE(IW,FMT='(5X,''$MCP GROUP NOT FOUND'')')
         ENDIF
         CALL SEQREW(IR)
      ENDIF
C
 7002 FORMAT(/1X,'USING BASNAM FOR ATOM CUSTOMIZED BASIS CONSTRUCTION'/
     *        5X,'----------------'/
     *        5X,'ATOM  BASIS NAME'/
     *        5X,'----------------')
 7003 FORMAT(5X,I3,3X,A8)
 7004 FORMAT(1X,'NOW LOCATING ALL',I5,
     *          ' BASIS SETS IN YOUR INPUT FILE...')
 7005 FORMAT(1X,'FOUND BASIS SET ',A8)
 7006 FORMAT(1X,'ERROR, COULD NOT FIND BASIS SET NAMED ',A8)
 7007 FORMAT(1X,I4,' UNIQUE ATOM CUSTOMIZED BASIS SETS WERE FOUND.')
C
C     ---- CHECK FOR BOOBOOS ---
C
      IERR=0
      IF(NPFUNC.GT.3  .OR.  NDFUNC.GT.3) THEN
         IF (MASWRK) WRITE(IW,*) 'NDFUNC AND NPFUNC CANNOT EXCEED 3'
         IERR=IERR+1
      END IF
      IF(NFFUNC.GT.1) THEN
         IF (MASWRK) WRITE(IW,*) 'NFFUNC CANNOT EXCEED 1'
         IERR=IERR+1
      END IF
      IF((GBASIS.NE.BASMIN.AND.GBASIS.NE.BASMID)
     *    .AND.  POLAR.EQ.HUZNGA) THEN
         IF (MASWRK) WRITE(IW,*)
     *      'USE HUZINAGA POLARIZATION WITH MINI/MIDI ONLY!'
         IERR=IERR+1
      END IF
      IF(POLAR.NE.DEFALT  .AND.  POLAR.NE.POP311  .AND.
     *   POLAR.NE.POPN31  .AND.
     *   POLAR.NE.DUNNNG  .AND.  POLAR.NE.HUZNGA  .AND.
     *   POLAR.NE.HONDO7  .AND.  POLAR.NE.UNDOC   .AND.
     *   POLAR.NE.ANONE) THEN
         IF(POLAR.EQ.BLANK) POLAR = UNGIVEN
         IF (MASWRK) WRITE(IW,9060) POLAR,
     *                              DEFALT,POP311,POPN31,DUNNNG,
     *                              HUZNGA,HONDO7,ANONE
         IERR=IERR+1
      END IF
C
C        AS OF JUNE 2009, DON'T TRUST USERS TO PICK SPHERICAL HARMONICS
C
      REQSPH = GBASIS.EQ.BASPC0 .OR. GBASIS.EQ.BASPC1  .OR.
     *         GBASIS.EQ.BASPC2 .OR. GBASIS.EQ.BASPC2  .OR.
     *         GBASIS.EQ.BASPC3
      REQSPH = GBASIS.EQ.BAAPC0 .OR. GBASIS.EQ.BAAPC1  .OR.
     *         GBASIS.EQ.BAAPC2 .OR. GBASIS.EQ.BAAPC2  .OR.
     *         GBASIS.EQ.BAAPC3 .OR. REQSPH
      REQSPH = GBASIS.EQ.BASCCD .OR. GBASIS.EQ.BASCCT  .OR.
     *         GBASIS.EQ.BASCCQ .OR. GBASIS.EQ.BASCC5  .OR.
     *         GBASIS.EQ.BASCC6 .OR. REQSPH
      REQSPH = GBASIS.EQ.BASNCD .OR. GBASIS.EQ.BASNCT  .OR.
     *         GBASIS.EQ.BASNCQ .OR. GBASIS.EQ.BASNC5  .OR.
     *         GBASIS.EQ.BASNC6 .OR. REQSPH
      REQSPH = GBASIS.EQ.BASACD .OR. GBASIS.EQ.BASACT  .OR.
     *         GBASIS.EQ.BASACQ .OR. GBASIS.EQ.BASAC5  .OR.
     *         GBASIS.EQ.BASAC6 .OR. REQSPH
      REQSPH = GBASIS.EQ.BACCCD .OR. GBASIS.EQ.BACCCT  .OR.
     *         GBASIS.EQ.BACCCQ .OR. GBASIS.EQ.BACCC5  .OR.
     *         GBASIS.EQ.BACCC6 .OR. REQSPH
      REQSPH = GBASIS.EQ.BACACD .OR. GBASIS.EQ.BACACT  .OR.
     *         GBASIS.EQ.BACACQ .OR. GBASIS.EQ.BACAC5  .OR.
     *         GBASIS.EQ.BACAC6 .OR. REQSPH
      REQSPH = GBASIS.EQ.BACWCD .OR. GBASIS.EQ.BACWCT  .OR.
     *         GBASIS.EQ.BACWCQ .OR. GBASIS.EQ.BACWC5  .OR.
     *         GBASIS.EQ.BACWC6 .OR. REQSPH
      REQSPH = GBASIS.EQ.BACAWD .OR. GBASIS.EQ.BACAWT  .OR.
     *         GBASIS.EQ.BACAWQ .OR. GBASIS.EQ.BACAW5  .OR.
     *         GBASIS.EQ.BACAW6 .OR. REQSPH
      REQSPH = GBASIS.EQ.MCP_DZP .OR. GBASIS.EQ.MCP_TZP  .OR.
     *         GBASIS.EQ.MCP_QZP .OR. REQSPH  .OR.
     +         GBASIS.EQ.MCPCDZP  .OR. GBASIS.EQ.MCPCTZP  .OR.
     +         GBASIS.EQ.MCPCQZP  .OR.
     +         GBASIS.EQ.AMCP_DZP .OR. GBASIS.EQ.AMCP_TZP .OR.
     +         GBASIS.EQ.AMCP_QZP .OR.
     +         GBASIS.EQ.AMCPCDZP .OR. GBASIS.EQ.AMCPCTZP .OR.
     +         GBASIS.EQ.AMCPCQZP
      REQSPH = GBASIS.EQ.IMCP_NR1 .OR. GBASIS.EQ.IMCP_NR2 .OR.
     *         GBASIS.EQ.IMCP_SR1 .OR. GBASIS.EQ.IMCP_SR2 .OR.  REQSPH
      REQSPH = GBASIS.EQ.ZFK5_DK3 .OR. GBASIS.EQ.ZFK4_DK3 .OR.
     *         GBASIS.EQ.ZFK3_DK3 .OR. GBASIS.EQ.ZFK5LDK3 .OR.
     *         GBASIS.EQ.ZFK4LDK3 .OR. GBASIS.EQ.ZFK3LDK3 .OR.  REQSPH
      REQSPH = GBASIS.EQ.SPK_DZP   .OR. GBASIS.EQ.SPK_TZP  .OR.
     *         GBASIS.EQ.SPK_QZP   .OR.
     *         GBASIS.EQ.SPK_ADZP  .OR. GBASIS.EQ.SPK_ATZP .OR.
     *         GBASIS.EQ.SPK_AQZP  .OR.
     *         GBASIS.EQ.SPKRDZP   .OR. GBASIS.EQ.SPKRTZP  .OR.
     *         GBASIS.EQ.SPKRQZP   .OR.
     *         GBASIS.EQ.SPKRADZP  .OR. GBASIS.EQ.SPKRATZP .OR.
     *         GBASIS.EQ.SPKRAQZP  .OR.     REQSPH
      REQSPH = GBASIS.EQ.SPK_DZC   .OR. GBASIS.EQ.SPK_TZC  .OR.
     *         GBASIS.EQ.SPK_QZC   .OR.
     *         GBASIS.EQ.SPK_ADZC  .OR. GBASIS.EQ.SPK_ATZC .OR.
     *         GBASIS.EQ.SPK_AQZC  .OR.
     *         GBASIS.EQ.SPKRDZC   .OR. GBASIS.EQ.SPKRTZC  .OR.
     *         GBASIS.EQ.SPKRQZC   .OR.
     *         GBASIS.EQ.SPKRADZC  .OR. GBASIS.EQ.SPKRATZC .OR.
     *         GBASIS.EQ.SPKRAQZC  .OR.     REQSPH
C
C         AUTOMATICALLY BOMB OUT RUNS IF USER DIDN'T SPECIFY ISPHER=1
C         FOR BASES THAT SHOULD HAVE IT.  THE POINT OF CRASHING HERE
C         INSTEAD OF JUST FLIPPING -ISPHER- FOR THE USER IS TO MAKE
C         IT VERY CLEAR THAT OLDER RUNS, BEFORE GAMESS HAD THIS CHECK
C         ADDED IN 8/2009, WILL NEED TO BE REPEATED.
C         IN 9/2010, LET UNDOCUMENTED -NOSO- KEYWORD DEFEAT THE CHECK.
C
      IF(REQSPH  .AND.  ISPHER.NE.1) THEN
         IF(MASWRK) WRITE(IW,9070) GBASIS
         IF(NOSO.EQ.0  .AND.  RUNTYP.NE.MOROKM) THEN
            IERR=IERR+1
         ELSE
            IF(MASWRK) THEN
               IF(NOSO.NE.0) WRITE(IW,9075) 'NOSO INPUT',GBASIS
               IF(RUNTYP.EQ.MOROKM) WRITE(IW,9075)
     *                       'RUNTYP=MOROKM',GBASIS
            ENDIF
         ENDIF
      END IF
C
      IF(IERR.GT.0) CALL ABRT
C
C        FIRST, PUT IN THE SP OR SPD ATOMIC BASIS.
C
      DO 120 I = 1,MAXA
         ABASIS(I,1) = GBASIS
         IAGAUS(I,1) = IGAUSS
  120 CONTINUE
      ICOUNT = 2
      IHCNT = 2
C
C        -DH- AND -BC- ARE JUST SYNONYMS FOR -DZV-
C
      IF(GBASIS.EQ.BASBC  .OR.  GBASIS.EQ.BASDH) GBASIS=BASDZV
C
C        USE 6-311G IN CONJUCTION WITH -MC- BASIS SETS.
C
      IF(GBASIS.EQ.BAS311  .OR.  GBASIS.EQ.BASMC) THEN
         DO 200 I=1,10
            ABASIS(I,1) = BAS311
            IAGAUS(I,1) = 6
  200    CONTINUE
         DO 205 I=11,18
            ABASIS(I,1) = BASMC
  205    CONTINUE
      END IF
C
C        USE -BC- IN CONJUCTION WITH 6-31G BASIS SETS.
C
C     IF(GBASIS.EQ.BASN31) THEN
C        DO 220 I=31,36
C           ABASIS(I,1) = BASBC
C 220    CONTINUE
C     END IF
C
C     ---- ADD POSSIBLE DIFFUSE S SHELL TO H,HE ----
C
      IF(DIFFS) THEN
         DO 300 I=1,2
            ABASIS(I,IHCNT) = BASS
            IAGAUS(I,IHCNT) = 1
               AEX(I,IHCNT) = ADIFF(I)
  300    CONTINUE
         IHCNT = IHCNT+1
      END IF
C
C     ---- ADD POSSIBLE DIFFUSE SP (L) SHELL ON LI-RN ----
C
      IF(DIFFSP) THEN
         DO 310 I=3,MAXP
             ABASIS(I,ICOUNT) = BASL
             IAGAUS(I,ICOUNT) = 1
                AEX(I,ICOUNT) = ADIFF(I)
  310    CONTINUE
         ICOUNT = ICOUNT + 1
      END IF
C
C     ---- ADD POSSIBLE P POLARIZATION FUNCTIONS TO H, HE ----
C
      IF(NPFUNC.GT.0) THEN
         DO 420 I=1,2
            IF(POLAR.EQ.DEFALT) ZETA = POLF1(I)
            IF(POLAR.EQ.POP311) ZETA = POLF2(I)
            IF(POLAR.EQ.DUNNNG) ZETA = POLF3(I)
            IF(POLAR.EQ.HUZNGA) ZETA = POLF4(I)
            IF(POLAR.EQ.HONDO7) ZETA = POLF5(I)
            IF(POLAR.EQ.UNDOC)  ZETA = POLF6(I)
            IF(POLAR.EQ.POPN31) ZETA = POLF7(I)
            IHC = IHCNT
            DO 410 IG = 1,NPFUNC
               ABASIS(I,IHC) = BASP
               IAGAUS(I,IHC) = 1
                  AEX(I,IHC) = SPLIT(NPFUNC,IG) * ZETA
               IHC = IHC + 1
  410       CONTINUE
  420    CONTINUE
         IHCNT = IHCNT + NPFUNC
      END IF
C
C     ---- ADD POSSIBLE POLARIZATION FUNCTIONS TO HEAVY ATOMS ----
C
      IF(NDFUNC.GT.0) THEN
         MINZ=3
         IF(GBASIS.EQ.BASN21  .OR.  GBASIS.EQ.BASHW  .OR.
     *      GBASIS.EQ.BASSTO) MINZ=11
         DO 560 I = MINZ,MAXP
            IF(POLAR.EQ.DEFALT) ZETA = POLF1(I)
            IF(POLAR.EQ.POP311) ZETA = POLF2(I)
            IF(POLAR.EQ.DUNNNG) ZETA = POLF3(I)
            IF(POLAR.EQ.HUZNGA) ZETA = POLF4(I)
            IF(POLAR.EQ.HONDO7) ZETA = POLF5(I)
            IF(POLAR.EQ.UNDOC)  ZETA = POLF6(I)
            IF(POLAR.EQ.POPN31) ZETA = POLF7(I)
            IC = ICOUNT
            DO 550 IG = 1,NDFUNC
               ABASIS(I,IC) = BASD
               IAGAUS(I,IC) = 1
                  AEX(I,IC) = SPLIT(NDFUNC,IG) * ZETA
C
C     HUZINAGA USES P POLARIZATION FOR ALKALI AND TRANSITION METALS.
C     OTHER BASIS SETS SKIP POLARIZATION ON TRANSITION METALS, EXCEPT
C     FOR 6-31G* FOR WHICH POPLE AND THERESA HAVE DEFINED F EXPONENTS.
C
               IF(POLAR.EQ.HUZNGA) THEN
                  IF(I.GE. 3 .AND. I.LE. 4) ABASIS(I,IC) = BASP
                  IF(I.GE.11 .AND. I.LE.12) ABASIS(I,IC) = BASP
                  IF(I.GE.19 .AND. I.LE.30) ABASIS(I,IC) = BASP
                  IF(I.GE.37 .AND. I.LE.48) ABASIS(I,IC) = BASP
                  IF(I.GE.55 .AND. I.LE.80) ABASIS(I,IC) = BASP
               ELSE
                  IF(I.GE.21 .AND. I.LE.30) THEN
                      ABASIS(I,IC) = BLANK
                      IF(GBASIS.EQ.BASN31) ABASIS(I,IC) = BASF
                  END IF
                  IF(I.GE.39 .AND. I.LE.48) ABASIS(I,IC) = BLANK
                  IF(I.GE.57 .AND. I.LE.80) ABASIS(I,IC) = BLANK
               END IF
               IC = IC + 1
  550       CONTINUE
  560    CONTINUE
         ICOUNT = ICOUNT + NDFUNC
      END IF
C
C           NOTE THAT ICOUNT IS NOW MESSED UP BETWEEN LIGHT ATOMS,
C           TRANSITION METALS, AND MAIN GROUP, BUT WE DON'T CARE.
C           THE VALUE IS CORRECT FOR MAIN GROUP ATOMS, WHICH ARE
C           THE ONLY TYPE OF ATOM FOR WHICH WE WILL ADD A F FUNCTION.
C
C     ---- ADD POSSIBLE F POLARIZATION FUNCTIONS TO LI-CL ----
C
      IF(NFFUNC.EQ.1) THEN
         IF(GBASIS.EQ.BASN21  .OR.  GBASIS.EQ.BASHW  .OR.
     *      GBASIS.EQ.BASSTO) THEN
            IF(MASWRK) WRITE(IW,*) 'DO NOT USE F WITH SMALL SP BASES'
            CALL ABRT
         END IF
         DO 620 I = 3,17
            ZETA = SPOL(I)
            ABASIS(I,ICOUNT) = BASF
            IAGAUS(I,ICOUNT) = 1
               AEX(I,ICOUNT) = ZETA
  620    CONTINUE
         ICOUNT = ICOUNT + 1
      END IF
C
      RETURN
C
 9000 FORMAT(1X,'SYNTAX ERROR FOUND IN YOUR $BASIS GROUP')
 9010 FORMAT(/5X,13HBASIS OPTIONS/5X,13(1H-)/
     *  5X,7HGBASIS=,A8,5X,7HIGAUSS=,I8,5X,7H POLAR=,A8/
     *  5X,7HNDFUNC=,I8,5X,7HNFFUNC=,I8,5X,7HDIFFSP=,L8/
     *  5X,7HNPFUNC=,I8,5X,7H DIFFS=,L8,5X,7HBASNAM=,A8)
 9020 FORMAT(5X,'SPLIT2=',2F15.8)
 9030 FORMAT(5X,'SPLIT3=',3F15.8)
 9040 FORMAT(/5X,'$BASIS REQUESTS READING THE "',A8,
     *          '" BASIS SET FROM AN EXTERNAL FILE')
 9050 FORMAT(/1X,'*** ERROR ***'/
     *      1X,'THIS RUN REQUESTED THE USE OF AN ECP IN $CONTRL,'/
     *      1X,'BUT IT REQUESTS A NON-ECP BASIS SET=',A8,'IN $BASIS.'//)
 9060 FORMAT(/1X,'**** ERROR WITH $BASIS GROUP *****'/
     *       1X,'UNRECOGNIZED POLARIZATION STRING, POLAR=',A8/
     *       1X,'VALID CHOICES FOR THIS KEYWORD ARE'/
     *       5X,7(A8,2X)/
     *       1X,'POLAR=BLANK USUALLY MEANS THE GBASIS KEYWORD WAS',
     *          ' UNRECOGNIZABLE.'/)
 9070 FORMAT(/1X,'MODERN BASIS SET FAMILIES (CCN, PCN, MCP_NZP, IMCP)',
     *          ' ARE INTENDED'/
     *       1X,'FOR USE ONLY AS SPHERICAL HARMONIC BASIS SETS.',
     *          ' PLEASE SET ISPHER=1'/
     *       1X,'IN THE $CONTRL GROUP IN ORDER TO USE GBASIS=',A8/)
 9075 FORMAT(/1X,'=== WARNING ==='/
     *        1X,'BECAUSE ',A,' WAS CHOSEN,'/
     *        1X,'THIS RUN WILL ALLOW THE USE OF GBASIS=',A8/
     *        1X,'IN CARTESIAN GAUSSIAN FORM.  NON-STANDARD USAGE!!!'/)
      END
C*MODULE INPUTB  *DECK BERROR
      SUBROUTINE BERROR(K)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION BASIS(4)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA BASIS /8HMINIMAL ,8HEXTENDED,8HGENERAL ,8H        /
C
C        *****  ROUTINE TO KICK YOU  OFF FOR AN IMPROPER *****
C        *****  BASIS-FUNCTION SPECIFICATION             *****
C
      IF (MASWRK) THEN
         WRITE (IW,9008)
         WRITE (IW,9028) BASIS(K)
      END IF
      CALL ABRT
      RETURN
C
 9008 FORMAT(1X,'   LUCY: DO NOT WORRY, CHARLIE BROWN, WE LEARN MORE'/
     *       1X,'         FROM LOSING THAN WE DO FROM WINNING.'/
     *       1X,'CHARLIE: THEN THAT MAKES ME THE SMARTEST PERSON IN'/
     *       1X,'         THE WORLD!')
 9028 FORMAT(/10X,'ILLEGAL ',A8,' BASIS FUNCTION REQUESTED.')
      END
C*MODULE INPUTB *DECK GTDIST
      SUBROUTINE GTDIST(ATOMN1,ATOMN2,RDIST)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION RCOV(86)
C
C      COVALENT RADII FROM J.EMSLEY, "THE ELEMENTS", 2ND EDITION, 1991
C      EXCEPT VAN DER WAALS RADII FOR HE,NE,AR,KR (SAME SOURCE),
C      AND GUESSES FOR NA,V,CR,RB,TC,PM,EU,YB,AT,RN
C
      DATA (RCOV(NUCZ),NUCZ=1,2)/0.30D+00,1.22D+00/
      DATA (RCOV(NUCZ),NUCZ=3,10)
     *  /1.23D+00,0.89D+00,0.88D+00,0.77D+00,
     *   0.70D+00,0.66D+00,0.58D+00,1.60D+00/
      DATA (RCOV(NUCZ),NUCZ=11,18)
     *  /1.66D+00,1.36D+00,1.25D+00,1.17D+00,
     *   1.10D+00,1.04D+00,0.99D+00,1.91D+00/
      DATA (RCOV(NUCZ),NUCZ=19,36)
     *  /2.03D+00,1.74D+00,
     *   1.44D+00,1.32D+00,1.22D+00,1.19D+00,1.17D+00,
     *   1.165D+00,1.16D+00,1.15D+00,1.17D+00,1.25D+00,
     *   1.25D+00,1.22D+00,1.21D+00,1.17D+00,1.14D+00,1.98D+00/
      DATA (RCOV(NUCZ),NUCZ=37,54)
     *  /2.22D+00,1.92D+00,
     *   1.62D+00,1.45D+00,1.34D+00,1.29D+00,1.27D+00,
     *   1.24D+00,1.25D+00,1.28D+00,1.34D+00,1.41D+00,
     *   1.50D+00,1.40D+00,1.41D+00,1.37D+00,1.33D+00,2.09D+00/
      DATA (RCOV(NUCZ),NUCZ=55,86)
     *  /2.35D+00,1.98D+00,
     *   1.69D+00,1.65D+00,1.65D+00,1.64D+00,1.65D+00,1.66D+00,1.65D+00,
     *   1.61D+00,1.59D+00,1.59D+00,1.58D+00,1.57D+00,1.56D+00,1.56D+00,
     *   1.56D+00,1.44D+00,1.34D+00,1.30D+00,1.28D+00,
     *   1.26D+00,1.26D+00,1.29D+00,1.34D+00,1.44D+00,
     *   1.55D+00,1.54D+00,1.52D+00,1.53D+00,1.50D+00,2.20D+00/
C
      RDIST=RCOV(INT(ATOMN1))+RCOV(INT(ATOMN2))
      END
C
C*MODULE INPUTB  *DECK MOLE
      SUBROUTINE MOLE(DECKNAME,IUNTRD,ICOORD,RELNORM)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,RELNORM,SECONDD
C
      CHARACTER*8 DECKNAME
      CHARACTER*4 CDUMMY
C
      PARAMETER (MXATM=2000, MXGSH=30, MXGTOT=20000, MXAO=8192)
      PARAMETER (MAXA=103, MAXL=7)
      PARAMETER (MXCHRM=1)
C
      COMMON /BASISC/ GBASIS,AEX(MAXA,MAXL),ABASIS(MAXA,MAXL),
     *                IAGAUS(MAXA,MAXL),IRDBAS
      COMMON /CHMGMS/ XCHM(MXCHRM),YCHM(MXCHRM),ZCHM(MXCHRM),
     *                DXELMM(MXCHRM),DYELMM(MXCHRM),DZELMM(MXCHRM),
     *                QCHM(MXCHRM),NCHMAT,KCHRMM
      COMMON /CXTHRM/ CXTHERM(11),CXZPE,METHCX,ICXBAS,ICXPCM,SECONDD
      COMMON /FMCOM / X(1)
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RELWFN/ RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,IQRORD,MODQR,NESOC,
     *                NRATOM,NUMU,NQMTR,NQRDAF,MORDA,NDARELB
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      DATA ANONE/8HNONE    /
      DATA G3MP2/8HG3MP2   /
      DATA COMP /8HCOMP    /
C
      IF(RUNTYP.EQ.G3MP2) GO TO 100
      IF(RUNTYP.EQ.COMP) GO TO 100
      ICXBAS = 0
  100 CONTINUE
      IF(RUNTYP.EQ.COMP) THEN
       IF(ICXBAS.GT.1) GO TO 401
      END IF
      IF(ICXBAS.EQ.2) GO TO 401
C
      IF (ICOORD.EQ.5) GO TO 200
C
      IF(DECKNAME.EQ.' $DATAL '  .AND.  MASWRK)
     *      WRITE(IW,9025) DECKNAME,'LARGE'
      IF(DECKNAME.EQ.' $DATAS '  .AND.  MASWRK)
     *      WRITE(IW,9025) DECKNAME,'SMALL'
C
C     ----- POSITION THE INPUT FILE TO $DATA -----
C
      CALL SEQREW(IR)
      CALL FNDGRP(IR,DECKNAME,IEOF)
      IF(IEOF.NE.0) THEN
         IF(MASWRK) WRITE (IW,9028) DECKNAME
         CALL ABRT
      END IF
C
C     OPEN THE FREE FORMAT INPUT SCANNER.
C     READ TITLE CARD.
C
      IF(KCHRMM.EQ.0) THEN
         CALL OPNCRD(IR,-IW)
         IF (MASWRK) THEN
            READ (IR,9088) TITLE
            WRITE(IW,9048) TITLE
            WRITE(IP,9008) DECKNAME
            WRITE(IP,9088) TITLE
         END IF
      END IF
 200  CONTINUE
C
C        READ SYMMETRY POINT GROUP OF THE MOLECULE,
C        AND GENERATE THE TRANSFORMATION MATRICES.
C
      CALL PTGRP
C
C        FOR COORD=CART,ZMT,ZMTMPC, WE MUST FIRST READ THE
C        FULL MOLECULE, AND DISCARD DOWN TO THE UNIQUE ATOMS.
C
      IF((IRDBAS.EQ.0  .OR. IRDBAS.EQ.2)  .AND.
     *   (ICOORD.GE.1 .AND. ICOORD.LE.3)) CALL MBLDR(IUNTRD)
C
C        FOR COORD=TINKER, WE MUST FIRST READ THE FULL SYSTEM
C        IN TINXYZ CARD, AND GENERATE QM PART OF COORDINATES
C        ACCORDING TO LINK CARD INFORMATION.
C
      IF((IRDBAS.EQ.0  .OR. IRDBAS.EQ.2) .AND.
     *   (ICOORD.EQ.5).AND.NFG.EQ.0) CALL TIN2GMS
C
C        READ THE COORDINATES OF THE UNIQUE CENTERS, IN ORDER TO
C        GENERATE THE FULL MOLECULE AND THE BASIS SET.
C
  401 CALL VALFM(LOADFM)
      LS   = LOADFM + 1
      LP   = LS + MXGTOT
      LD   = LP + MXGTOT
      LF   = LD + MXGTOT
      LG   = LF + MXGTOT
      LH   = LG + MXGTOT
      LI   = LH + MXGTOT
C
      LS2  = LI  + MXGTOT
      LP2  = LS2 + MXGTOT
      LD2  = LP2 + MXGTOT
      LF2  = LD2 + MXGTOT
      LG2  = LF2 + MXGTOT
      LH2  = LG2 + MXGTOT
      LI2  = LH2 + MXGTOT
C
      LMELD= LI2 + MXGTOT
      LAST = LMELD + MXGSH*5*MXATM
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      IF(ICXBAS.EQ.2 .OR. ICXBAS.EQ.3) GO TO 402
C
      CALL ATOMS(IUNTRD,X(LS),X(LP),X(LD),X(LF),X(LG),X(LH),X(LI),
     *           X(LS2),X(LP2),X(LD2),X(LF2),X(LG2),X(LH2),X(LI2),
     *           X(LMELD),MXGSH,MXATM,MXGTOT,ICOORD,RELNORM,ICXBAS)
      CALL RETFM(NEED)
C
      CALL SETLAB(1,CDUMMY)
C
C     ----- WRITE ATOMIC COOORDINATES IN THE FIRST RECORD OF DAF -----
C
  402 CALL DAWRIT(IDAF,IODA,C,3*NAT,1,0)
      NUMU=NUM
      IF(RMETHOD.NE.ANONE) CALL RWFINP
      RETURN
C
 9008 FORMAT(A8)
 9025 FORMAT(/1X,'READING',A8,'GROUP FOR ',A5,' COMPONENT BASIS SET...')
 9028 FORMAT(1X,'**** ERROR, NO ',A8,' GROUP WAS FOUND')
 9048 FORMAT(//5X,'RUN TITLE'/5X,9(1H-)/1X,10A8)
 9088 FORMAT(10A8)
      END
C*MODULE INPUTB  *DECK PRINT
      SUBROUTINE PRINT(N1,N2)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXSH=5000, MXATM=2000)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                T(9,48),INVT(48),NT
C
      IF (MASWRK) THEN
      DO 160 IMIN = N1,N2,4
         IMAX = MIN(IMIN+1, N2)
         DO 140 J = 1,9,3
            WRITE (IW,9008) (T(J,I),T(J+1,I),T(J+2,I), I = IMIN,IMAX)
  140    CONTINUE
         WRITE (IW,9028)
  160 CONTINUE
      END IF
      RETURN
C
 9008 FORMAT(4X,4(3F10.5,2H *))
 9028 FORMAT(/)
      END
C*MODULE INPUTB  *DECK PTGRP
      SUBROUTINE PTGRP
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,ABEL
C
      DIMENSION GRP(19),DRC(2)
C
      CHARACTER*5 GROUPC,GRP2(19)
      CHARACTER*8 DRC2(2),DIRCT2
C
      PARAMETER (MXSH=5000, MXATM=2000)
      PARAMETER (MXCHRM=1)
C
      COMMON /CHMGMS/ XCHM(MXCHRM),YCHM(MXCHRM),ZCHM(MXCHRM),
     *                DXELMM(MXCHRM),DYELMM(MXCHRM),DZELMM(MXCHRM),
     *                QCHM(MXCHRM),NCHMAT,KCHRMM
      COMMON /FRAME / U1,U2,U3,V1,V2,V3,W1,W2,W3,X0,Y0,Z0
      COMMON /FRAMES/ X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3,DIRECT
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /SYMMOL/ GROUP,COMPLEX,IGROUP,NAXIS,ILABMO,ABEL
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                T(9,48),INVT(48),NT
      COMMON /ZMTALT/ NZMAT2,NZVAR2,NVAR2,NZMTRD,ICOORD
      LOGICAL MMONLY, QMMM
      COMMON /TINOPT/ MPARTI,MMONLY, QMMM
C
      PARAMETER (ZERO=0.0D+00, HALF=0.5D+00, ONE=1.0D+00, TWO=2.0D+00)
      PARAMETER (TOL=1.0D-10)
C
      DATA GRP2/'C1   ','CS   ','CI   ','CN   ','S2N  ','CNH  ',
     +          'CNV  ','DN   ','DNH  ','DND  ','CINFV','DINFH','T    ',
     +          'TH   ','TD   ','O    ','OH   ','I    ','IH   '/
C
      DATA GRP /5HC1   ,5HCS   ,5HCI   ,5HCN   ,5HS2N  ,5HCNH  ,
     +          5HCNV  ,5HDN   ,5HDNH  ,5HDND  ,5HCINFV,5HDINFH,5HT    ,
     +          5HTH   ,5HTD   ,5HO    ,5HOH   ,5HI    ,5HIH   /
      DATA BLANK/8H        /
      DATA DRC /8HNORMAL  ,8HPARALLEL/
      DATA DRC2/'NORMAL  ','PARALLEL'/
C
      PI2 = TWO * ACOS(-ONE)
      ALPH = ZERO
      N2 = -2**20
C
C     ---- READ THE POINT GROUP -----
C
      IF (QMMM .AND. (ICOORD.EQ.5)) THEN
         GROUPC = 'C1   '
      ELSE
       IF(KCHRMM.EQ.0) THEN
         IERR=0
         IEOF=0
         CALL RDCARD('$DATA 2 ',IEOF)
         IF(IEOF.EQ.1) THEN
            IF(MASWRK) WRITE(IW,*) 'TROUBLE FINDING POINT GROUP CARD'
            CALL ABRT
         END IF
         GROUPC = '     '
         NAXIS = 0
         KSIZE = -5
         CALL GSTRNG(GROUPC,KSIZE)
         NAXIS = IFIND('NAXIS   ',IERR)
         IF(IERR.NE.0) THEN
            IF(MASWRK) WRITE(IW,*) 'TROUBLE READING ROTATION AXIS'
            CALL ABRT
         END IF
       ELSE
         GROUPC = 'C1   '
         NAXIS=1
       END IF
      END IF
C
      IGROUP = 0
      DO 90 I = 1,19
        IF(GROUPC.EQ.GRP2(I)) IGROUP = I
   90 CONTINUE
      IF(IGROUP.LE.0) THEN
         IF (MASWRK) WRITE(IW,9108) GROUPC
         CALL ABRT
      END IF
      GROUP = GRP(IGROUP)
C
C        GROUPS I AND IH DON'T EXIST, REALLY.
C
      IF (IGROUP .EQ. 18 .OR. IGROUP .EQ. 19) THEN
         IF (MASWRK) WRITE (IW,9008) GROUPC
         CALL ABRT
      END IF
C
      IF(MASWRK) THEN
         WRITE(IW,9128) GROUP,NAXIS
         WRITE(IP,9008) GROUP,NAXIS
      END IF
C
      IF (IGROUP .LE. 3) GO TO 580
      IF (IGROUP .EQ. 11 .OR. IGROUP .EQ. 12) GO TO 580
C
C     DEFINE LOCAL FRAME
C     READ IN PRINCIPAL AXIS   ( 1 CARD )
C     READ IN X-LOCAL AXIS   ( 1 CARD )
C     DEFAULT OPTION - LOCAL FRAME IDENTICAL TO MASTER FRAME
C           READ X0,Y0,Z0,X1,Y1,Z1
C
      IEOF = 0
      IERR = 0
      CALL RDCARD('$DATA 3 ',IEOF)
      X0 = RFIND('X0      ',IERR)
         IF(IERR.NE.0) CALL ABRT
      Y0 = RFIND('Y0      ',IERR)
         IF(IERR.NE.0) CALL ABRT
      Z0 = RFIND('Z0      ',IERR)
         IF(IERR.NE.0) CALL ABRT
      X1 = RFIND('X1      ',IERR)
         IF(IERR.NE.0) CALL ABRT
      Y1 = RFIND('Y1      ',IERR)
         IF(IERR.NE.0) CALL ABRT
      Z1 = RFIND('Z1      ',IERR)
         IF(IERR.NE.0) CALL ABRT
      RHO = SQRT((X1-X0)**2+(Y1-Y0)**2+(Z1-Z0)**2)
      IF (RHO .GT. TOL) THEN
         IF (MASWRK) WRITE (IP,9048) X0,Y0,Z0,X1,Y1,Z1
C                  READ (IR,*) X2,Y2,Z2,DIRECT
         IEOF = 0
         IERR = 0
         CALL RDCARD('$DATA 4 ',IEOF)
         X2 = RFIND('X2      ',IERR)
              IF(IERR.NE.0) CALL ABRT
         Y2 = RFIND('Y2      ',IERR)
              IF(IERR.NE.0) CALL ABRT
         Z2 = RFIND('Z2      ',IERR)
              IF(IERR.NE.0) CALL ABRT
         DIRCT2='        '
         KSIZE = -8
         CALL GSTRNG(DIRCT2,KSIZE)
         DIRECT = BLANK
         IF(DIRCT2.EQ.DRC2(1)) DIRECT = DRC(1)
         IF(DIRCT2.EQ.DRC2(2)) DIRECT = DRC(2)
         IF (MASWRK) WRITE (IP,9068) X2,Y2,Z2,DIRECT
      ELSE
         IF (MASWRK) WRITE (IP,9068)
         X0 = ZERO
         Y0 = ZERO
         Z0 = ZERO
         X1 = ZERO
         Y1 = ZERO
         Z1 = ONE
         X2 = ONE
         Y2 = ZERO
         Z2 = ZERO
         DIRECT = DRC(2)
         RHO = ONE
      END IF
C
      IF (DIRECT .NE. DRC(1)) DIRECT = DRC(2)
      W1 = (X1-X0)/RHO
      W2 = (Y1-Y0)/RHO
      W3 = (Z1-Z0)/RHO
      WW = W1*W1+W2*W2+W3*W3
      X02 = X2-X0
      Y02 = Y2-Y0
      Z02 = Z2-Z0
      RHO = (W1*X02+W2*Y02+W3*Z02)/WW
      DUM = RHO*W1
      X0 = X0+DUM
      X02 = X02-DUM
      DUM = RHO*W2
      Y0 = Y0+DUM
      Y02 = Y02-DUM
      DUM = RHO*W3
      Z0 = Z0+DUM
      Z02 = Z02-DUM
      UU = (X02*X02+Y02*Y02+Z02*Z02)
      U = SQRT(UU)
      U1 = X02/U
      U2 = Y02/U
      U3 = Z02/U
      V3 = W1*U2-W2*U1
      V2 = W3*U1-W1*U3
      V1 = W2*U3-W3*U2
      IF (DIRECT .EQ. DRC(2)) GO TO 200
         DUM = U1
         U1 = V1
         V1 = -DUM
         DUM = U2
         U2 = V2
         V2 = -DUM
         DUM = U3
         U3 = V3
         V3 = -DUM
  200 CONTINUE
      IF ((NPRINT .EQ. 1) .AND. MASWRK)
     *    WRITE (IW,9148) X0,Y0,Z0,U1,V1,W1,U2,V2,W2,U3,V3,W3
      IF (IGROUP .GE. 13) GO TO 580
C
C     ROTATION ABOUT PRINCIPAL AXIS
C
      N = NAXIS
      ALPHA = ZERO
      ALPH = PI2 / N
      DO 240 NN = 1,N
         COSA = COS(ALPHA)
         SINA = SIN(ALPHA)
         T(1,NN) = COSA
         T(5,NN) = COSA
         T(2,NN) = -SINA
         T(4,NN) = SINA
         T(3,NN) = ZERO
         T(6,NN) = ZERO
         T(7,NN) = ZERO
         T(8,NN) = ZERO
         T(9,NN) = ONE
         ALPHA = ALPHA+ALPH
  240 CONTINUE
C
C     END OF GROUP 4
C
      NT = N
      IF (NPRINT .NE. 1) GO TO 280
      IF (MASWRK) WRITE (IW,9168)
      N1 = 1
      N2 = NAXIS
      CALL PRINT(N1,N2)
  280 CONTINUE
      IF (IGROUP .EQ. 4) GO TO 980
      IF (IGROUP .EQ. 5) GO TO 720
      IF (IGROUP .EQ. 7) GO TO 520
      IF (IGROUP .NE. 6 .AND. IGROUP .NE. 9) GO TO 380
C
C     SIGMA-H PLANE  EQUATION (Z=0) IN LOCAL FRAME
C
C
C        GROUP 6 0R 9
C
      CALL DCOPY(9*NT,T,1,T(1,NT+1),1)
      DO 340 NN = NT+1,NT+NT
         T(9,NN) = -T(9,NN)
  340 CONTINUE
      NT = NT+NT
      IF (NPRINT .NE. 1) GO TO 360
         IF (MASWRK) WRITE (IW,9188)
         N1 = N2+1
         N2 = N2+NAXIS
         CALL PRINT(N1,N2)
  360 CONTINUE
C
C     END OF GROUP 6
C
      IF (IGROUP .EQ. 6) GO TO 980
C
C     ONE CP2 AXIS IS THE X-AXIS OF THE LOCAL FRAME
C     GROUP 8 , 9 ,10
C
  380 CONTINUE
      CALL DCOPY(9*NT,T,1,T(1,NT+1),1)
      DO 420 NN = NT+1,NT+NT
         T(2,NN) = -T(2,NN)
         T(3,NN) = -T(3,NN)
         T(5,NN) = -T(5,NN)
         T(6,NN) = -T(6,NN)
         T(8,NN) = -T(8,NN)
         T(9,NN) = -T(9,NN)
  420 CONTINUE
      NT = NT+NT
      IF (NPRINT .NE. 1) GO TO 440
         IF (MASWRK) WRITE (IW,9208)
         N1 = N2+1
         N2 = N2+NAXIS
         CALL PRINT(N1,N2)
         IF (IGROUP .NE. 9) GO TO 440
            IF (MASWRK) WRITE (IW,9328)
            N1 = N2+1
            N2 = N2+NAXIS
            CALL PRINT(N1,N2)
  440 CONTINUE
C
C     END OF GROUP 8 AND 9
C
      IF (IGROUP .EQ. 8 .OR. IGROUP .EQ. 9) GO TO 980
C
C     DND GROUP . EQUATION OF PLANE SIGMA-D IS _
C     SIN(ALPH/4)*X-COS(ALPH/4)*Y=0
C     THE X-AXIS IS THE CP2 AXIS.
C
C     GROUP 10
C
      BETA = HALF*ALPH
      COSB = COS(BETA)
      SINB = SIN(BETA)
      CALL DCOPY(9*NT,T,1,T(1,NT+1),1)
      DO 480 NN = 1,9,3
         CALL DROT(NT,T(NN,NT+1),9,T(NN+1,NT+1),9,COSB,SINB)
  480 CONTINUE
      DO 490 NN = NT+1,NT+NT
         T(2,NN) = -T(2,NN)
         T(5,NN) = -T(5,NN)
         T(8,NN) = -T(8,NN)
  490 CONTINUE
      NT = NT+NT
      IF (NPRINT .NE. 1) GO TO 500
         IF (MASWRK) WRITE (IW,9228)
         N1 = N2+1
         N2 = N2+NAXIS
         CALL PRINT(N1,N2)
         IF (MASWRK) WRITE (IW,9348)
         N1 = N2+1
         N2 = N2+NAXIS
         CALL PRINT(N1,N2)
  500 CONTINUE
C
C     END OF GROUP 10
C
      GO TO 980
C
C     GROUP 7
C     SIGMA-V IS THE (X-Z) PLANE OF LOCAL FRAME
C
  520 CONTINUE
      CALL DCOPY(9*NT,T,1,T(1,NT+1),1)
      DO 560 NN = NT+1,NT+NT
         T(2,NN) = -T(2,NN)
         T(5,NN) = -T(5,NN)
         T(8,NN) = -T(8,NN)
  560 CONTINUE
      NT = NT+NT
C
C     END OF GROUP 7
C
      IF (NPRINT .NE. 1) GO TO 980
         IF (MASWRK) WRITE (IW,9248)
         N1 = N2+1
         N2 = N2+NAXIS
         CALL PRINT(N1,N2)
         GO TO 980
C
  580 CONTINUE
      T(1,1) = ONE
      T(5,1) = ONE
      T(9,1) = ONE
      T(2,1) = ZERO
      T(3,1) = ZERO
      T(4,1) = ZERO
      T(6,1) = ZERO
      T(7,1) = ZERO
      T(8,1) = ZERO
C
      IF (IGROUP .EQ. 1) GO TO 600
      IF (IGROUP .EQ. 2) GO TO 620
      IF (IGROUP .EQ. 3) GO TO 680
      IF (IGROUP .EQ. 11 .OR. IGROUP .EQ. 12) GO TO 700
      GO TO 780
C
  600 NT = 1
      X0 = ZERO
      Y0 = ZERO
      Z0 = ZERO
      U1 = ONE
      V2 = ONE
      W3 = ONE
      U2 = ZERO
      U3 = ZERO
      V1 = ZERO
      V3 = ZERO
      W1 = ZERO
      W2 = ZERO
      GO TO 980
C
C     CS SYMMETRY GROUP
C     THE 3 POINTS 1,2,3 DEFINE SIGMA-H PLANE
C
C            READ (IR,*) X1,Y1,Z1,X2,Y2,Z2
  620 CONTINUE
      IEOF = 0
      IERR = 0
      CALL RDCARD('$DATA 3 ',IEOF)
      X1 = RFIND('X1      ',IERR)
         IF(IERR.NE.0) CALL ABRT
      Y1 = RFIND('Y1      ',IERR)
         IF(IERR.NE.0) CALL ABRT
      Z1 = RFIND('Z1      ',IERR)
         IF(IERR.NE.0) CALL ABRT
      X2 = RFIND('X2      ',IERR)
         IF(IERR.NE.0) CALL ABRT
      Y2 = RFIND('Y2      ',IERR)
         IF(IERR.NE.0) CALL ABRT
      Z2 = RFIND('Z2      ',IERR)
         IF(IERR.NE.0) CALL ABRT
      RHO = (X2-X1)**2+(Y2-Y1)**2+(Z2-Z1)**2
      IF (RHO .GT. TOL) THEN
         IF (MASWRK) WRITE (IP,9048) X1,Y1,Z1,X2,Y2,Z2
C                 READ (IR,*) X3,Y3,Z3
         IERR = 0
         IEOF = 0
         CALL RDCARD('$DATA 4 ',IEOF)
         X3 = RFIND('X3      ',IERR)
            IF(IERR.NE.0) CALL ABRT
         Y3 = RFIND('Y3      ',IERR)
            IF(IERR.NE.0) CALL ABRT
         Z3 = RFIND('Z3      ',IERR)
            IF(IERR.NE.0) CALL ABRT
         IF (MASWRK) WRITE (IP,9048) X3,Y3,Z3
      ELSE
C            DEFAULT OPTION - PLANE IS THE (X,Y) PLANE
         IF (MASWRK) WRITE(IP,9048)
         X1 = ZERO
         Y1 = ZERO
         Z1 = ZERO
         Y2 = ZERO
         Z2 = ZERO
         X3 = ZERO
         Z3 = ZERO
         X2 = ONE
         Y3 = ONE
      END IF
C
      NT = 2
      W1 = (Y2-Y1)*(Z3-Z1)-(Y3-Y1)*(Z2-Z1)
      W2 = (Z2-Z1)*(X3-X1)-(Z3-Z1)*(X2-X1)
      W3 = (X2-X1)*(Y3-Y1)-(X3-X1)*(Y2-Y1)
      RHO = SQRT(W1*W1+W2*W2+W3*W3)
      W1 = W1/RHO
      W2 = W2/RHO
      W3 = W3/RHO
      U1 = X2-X1
      U2 = Y2-Y1
      U3 = Z2-Z1
      RHO = SQRT(U1*U1+U2*U2+U3*U3)
      U1 = U1/RHO
      U2 = U2/RHO
      U3 = U3/RHO
      V1 = W2*U3-W3*U2
      V2 = W3*U1-W1*U3
      V3 = W1*U2-W2*U1
      X0 = X1
      Y0 = Y1
      Z0 = Z1
      T(1,2) =  ONE
      T(5,2) =  ONE
      T(9,2) = -ONE
      T(2,2) = ZERO
      T(3,2) = ZERO
      T(4,2) = ZERO
      T(6,2) = ZERO
      T(7,2) = ZERO
      T(8,2) = ZERO
C
      IF (NPRINT .NE. 1) GO TO 980
         IF (MASWRK) THEN
            WRITE (IW,9288) W1,W2,W3
            WRITE (IW,9308) U1,V1,W1,U2,V2,W2,U3,V3,W3
         END IF
         GO TO 980
C
C     CI SYMMETRY GROUP
C     CENTER OF INVERSION IS (X0,Y0,Z0)
C
C            READ (IR,*) X0,Y0,Z0
  680 CONTINUE
      IEOF = 0
      IERR = 0
      CALL RDCARD('$DATA 3 ',IEOF)
      X0 = RFIND('X0      ',IERR)
         IF(IERR.NE.0) CALL ABRT
      Y0 = RFIND('Y0      ',IERR)
         IF(IERR.NE.0) CALL ABRT
      Z0 = RFIND('Z0      ',IERR)
         IF(IERR.NE.0) CALL ABRT
      IF ((NPRINT .EQ. 3) .AND. MASWRK) WRITE (IW,9268) X0,Y0,Z0
      T(1,2) = -ONE
      T(5,2) = -ONE
      T(9,2) = -ONE
      T(2,2) = ZERO
      T(3,2) = ZERO
      T(4,2) = ZERO
      T(6,2) = ZERO
      T(7,2) = ZERO
      T(8,2) = ZERO
      NT = 2
      U1 = ONE
      V2 = ONE
      W3 = ONE
      U2 = ZERO
      U3 = ZERO
      V1 = ZERO
      V3 = ZERO
      W1 = ZERO
      W2 = ZERO
      GO TO 980
C
  700 IF (MASWRK) WRITE (IW,9088)
      CALL ABRT
C
  720 CONTINUE
      BETA = HALF*ALPH
      COSB = COS(BETA)
      SINB = SIN(BETA)
C
C     S2N GROUP
C     THE PLANE OF SYMMETRY FOR THE IMPROPER ROTATION
C     IS THE (X,Y) PLANE OF THE LOCAL FRAME
C
      CALL DCOPY(9*NT,T,1,T(1,NT+1),1)
      DO 750 NN = NT+1,NT+NT
         T(3,NN) = -T(3,NN)
         T(6,NN) = -T(6,NN)
         T(9,NN) = -T(9,NN)
  750 CONTINUE
      DO 760 NN = 1,9,3
         CALL DROT(NT,T(NN,NT+1),9,T(NN+1,NT+1),9,COSB,SINB)
  760 CONTINUE
      NT = NT+NT
      IF (NPRINT .NE. 1) GO TO 980
         IF (MASWRK) WRITE (IW,9368)
         N1 = N2+1
         N2 = N2+NAXIS
         CALL PRINT(N1,N2)
         GO TO 980
C
C     T GROUP AND OTHERS CONTAINING A SUBGROUP T _
C     LOCAL X,Y,Z ARE THE C2 AXES
C
  780 CONTINUE
      CALL VCLR(T(1,2),1,27)
      T(1,2) =  ONE
      T(5,3) =  ONE
      T(9,4) =  ONE
      T(5,2) = -ONE
      T(9,2) = -ONE
      T(1,3) = -ONE
      T(9,3) = -ONE
      T(1,4) = -ONE
      T(5,4) = -ONE
      DO 820 I = 5,12
      T(1,I) = T(7,I-4)
      T(2,I) = T(8,I-4)
      T(3,I) = T(9,I-4)
      T(4,I) = T(1,I-4)
      T(5,I) = T(2,I-4)
      T(6,I) = T(3,I-4)
      T(7,I) = T(4,I-4)
      T(8,I) = T(5,I-4)
      T(9,I) = T(6,I-4)
  820 CONTINUE
      NT = 12
      IF (IGROUP .EQ. 13) GO TO 980
      IF (IGROUP .EQ. 14) GO TO 840
      IF (IGROUP .EQ. 15) GO TO 900
      GO TO 880
C
C     TH GROUP
C     EXPAND GROUP BY TAKING DIRECT PRODUCT WITH CI
C
  840 CONTINUE
      CALL DCOPY(9*NT,T,1,T(1,NT+1),1)
      DO 860 J = NT+1,NT+NT
         DO 850 I = 1,9
            T(I,J) = -T(I,J)
  850    CONTINUE
  860 CONTINUE
      NT = NT+NT
      GO TO 980
C
C     OCTAHEDRAL GROUP IS DIRECT PRODUCT OF T AND A C4 ROTATION
C     ABOUT Z AXIS
C
  880 SIGN = -ONE
      GO TO 920
C
C     TD GROUP IS DIRECT PRODUCT OF T AND A REFLECTION IN A
C     PLANE ( EQUATION OF THE PLANE   X=Y  )
C
  900 SIGN = ONE
  920 CONTINUE
      DO 940 I = 13,24
         T(1,I) = T(4,I-12)*SIGN
         T(2,I) = T(5,I-12)*SIGN
         T(3,I) = T(6,I-12)*SIGN
         T(4,I) = T(1,I-12)
         T(5,I) = T(2,I-12)
         T(6,I) = T(3,I-12)
         T(7,I) = T(7,I-12)
         T(8,I) = T(8,I-12)
         T(9,I) = T(9,I-12)
  940 CONTINUE
      NT = 24
      IF (IGROUP .NE. 17) GO TO 980
C
C     OH GROUP IS DIRECT PRODUCT OF O AND CI
C
      CALL DCOPY(9*NT,T,1,T(1,NT+1),1)
      DO 960 J = NT+1,NT+NT
         DO 950 I = 1,9
            T(I,J) = -T(I,J)
  950    CONTINUE
  960 CONTINUE
      NT = 48
C
C     FIND THE INVERSE TRANSFORMATIONS
C
  980 CONTINUE
      DO 1020 ITR = 1,NT
      DO 1000 IT = 1,NT
      TEST =T(1,ITR)*T(1,IT)+T(2,ITR)*T(4,IT)+T(3,ITR)*T(7,IT)+T(4,ITR)*
     *     T(2,IT)+T(5,ITR)*T(5,IT)+T(6,ITR)*T(8,IT)+T(7,ITR)*T(3,IT)+
     *     T(8,ITR)*T(6,IT)+T(9,ITR)*T(9,IT) -3.0D+00
      IF (ABS(TEST) .GT. TOL) GO TO 1000
         INVT(ITR) = IT
         GO TO 1020
C
 1000 CONTINUE
 1020 CONTINUE
C
      CALL SPDTR
      RETURN
C
 9008 FORMAT(A5,I5)
 9048 FORMAT(9F10.5)
 9068 FORMAT(3F10.5,1X,A8)
 9088 FORMAT(49H LINEAR MOLECULE , POINT GROUP IS CINFV OR DINFH ,/,
     +     31H PLEASE USE GROUP CNV OR DNH...)
 9108 FORMAT(1X,'*** ERROR, ILLEGAL POINT GROUP=',A5,' CHOSEN.')
 9128 FORMAT(/1X,'THE POINT GROUP OF THE MOLECULE IS ',A8/
     *        1X,'THE ORDER OF THE PRINCIPAL AXIS IS ',I5)
 9148 FORMAT(/,42H THE ORIGIN OF THE LOCAL FRAME IS AT X =  ,F10.5,
     +     5H Y = ,F10.5,5H Z = ,F10.5,/,
     +     34H DIRECTOR COSINES OF THE NEW AXES ,/,34X,3(5X,F10.5),/,
     +     34X, 3(5X,F10.5),/,34X,3(5X,F10.5))
 9168 FORMAT(31H ROTATIONS ABOUT PRINCIPAL AXIS)
 9188 FORMAT(30H SIGMA-H FOLLOWED BY ROTATIONS)
 9208 FORMAT(26H C2 FOLLOWED BY ROTATIONS )
 9228 FORMAT(30H SIGMA-D FOLLOWED BY ROTATIONS)
 9248 FORMAT(30H SIGMA-V FOLLOWED BY ROTATIONS)
 9268 FORMAT(/,10X,27H CENTER OF SYMMETRY AT X = ,F10.5,5H Y = ,F10.5,
     +     5H Z = ,F10.5)
 9288 FORMAT(/,45H PLANE OF SYMMETRY DEFINED BY ITS NORMAL U = ,F10.5,
     +     5H V = ,F10.5,5H W = ,F10.5)
 9308 FORMAT(/,10X,3F15.9,/,10X,3F15.9,/,10X,3F15.9)
 9328 FORMAT(45H C2 FOLLOWED BY SIGMA-H FOLLOWED BY ROTATIONS)
 9348 FORMAT(45H SIGMA-D FOLLOWED BY C2 FOLLOWED BY ROTATIONS)
 9368 FORMAT(35H S2N ROTATION FOLLOWED BY ROTATIONS)
      END
C*MODULE INPUTB  *DECK RIJ
      DOUBLE PRECISION FUNCTION RIJ(C,I,J)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION C(3,*)
C
      RIJSQ = (C(1,I)-C(1,J))**2+(C(2,I)-C(2,J))**2+(C(3,I)-C(3,J))**2
      RIJ = SQRT(RIJSQ)
      RETURN
      END
C*MODULE INPUTB  *DECK SETLAB
      SUBROUTINE SETLAB(IARG,ATMSYM)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      CHARACTER*4 ATMSYM(*)
      CHARACTER*4 BFNAM1(35)
      CHARACTER*6 BFNAM2(49)
      CHARACTER*4 ATMLAB(106),BONDF,LABEL
      CHARACTER*8 BFL
C
      PARAMETER (MXATM=2000, MXSH=5000, MXGTOT=20000, MXAO=8192)
C
      COMMON /ECP2  / CLP(400),ZLP(400),NLP(400),KFIRST(MXATM,6),
     *                KLAST(MXATM,6),LMAX(MXATM),LPSKIP(MXATM),
     *                IZCORE(MXATM)
      COMMON /ELGLAB/ IATM(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
C
      DATA BFNAM1/'  S ','  X ','  Y ','  Z ',
     *            ' XX ',' YY ',' ZZ ',' XY ',' XZ ',' YZ ',
     *            ' XXX',' YYY',' ZZZ',' XXY',' XXZ',
     *            ' YYX',' YYZ',' ZZX',' ZZY',' XYZ',
     *            'XXXX','YYYY','ZZZZ','XXXY','XXXZ',
     *            'YYYX','YYYZ','ZZZX','ZZZY','XXYY',
     *            'XXZZ','YYZZ','XXYZ','YYXZ','ZZXY'/
      DATA BFNAM2/' XXXXX',' YYYYY',' ZZZZZ',' XXXXY',' XXXXZ',
     *            ' YYYYX',' YYYYZ',' ZZZZX',' ZZZZY',' XXXYY',
     *            ' XXXZZ',' YYYXX',' YYYZZ',' ZZZXX',' ZZZYY',
     *            ' XXXYZ',' YYYXZ',' ZZZXY',' XXYYZ',' XXZZY',
     *            ' YYZZX',
     *            '    X6','    Y6','    Z6','   X5Y','   X5Z',
     *            '   Y5X','   Y5Z','   Z5X','   Z5Y','  X4Y2',
     *            '  X4Z2','  Y4X2','  Y4Z2','  Z4X2','  Z4Y2',
     *            '  X4YZ','  Y4XZ','  Z4XY','  X3Y3','  X3Z3',
     *            '  Y3Z3',' X3Y2Z',' X3Z2Y',' Y3X2Z',' Y3Z2X',
     *            ' Z3X2Y',' Z3Y2X','X2Y2Z2'/
      DATA BONDF/' BF '/
C
C                           104 TRUE ELEMENTS, AND 2 DUMMIES
C
      DATA ATMLAB/'H   ','HE  ','LI  ','BE  ','B   ','C   ',
     *            'N   ','O   ','F   ','NE  ','NA  ','MG  ',
     *            'AL  ','SI  ','P   ','S   ','CL  ','AR  ',
     *            'K   ','CA  ','SC  ','TI  ','V   ','CR  ',
     *            'MN  ','FE  ','CO  ','NI  ','CU  ','ZN  ',
     *            'GA  ','GE  ','AS  ','SE  ','BR  ','KR  ',
     *            'RB  ','SR  ','Y   ','ZR  ','NB  ','MO  ',
     *            'TC  ','RU  ','RH  ','PD  ','AG  ','CD  ',
     *            'IN  ','SN  ','SB  ','TE  ','I   ','XE  ',
     *            'CS  ','BA  ','LA  ','CE  ','PR  ','ND  ',
     *            'PM  ','SM  ','EU  ','GD  ','TB  ','DY  ',
     *            'HO  ','ER  ','TM  ','YB  ','LU  ','HF  ',
     *            'TA  ','W   ','RE  ','OS  ','IR  ','PT  ',
     *            'AU  ','HG  ','TL  ','PB  ','BI  ','PO  ',
     *            'AT  ','RN  ','FR  ','RA  ','AC  ','TH  ',
     *            'PA  ','U   ','NP  ','PU  ','AM  ','CM  ',
     *            'BK  ','CF  ','ES  ','FM  ','MD  ','NO  ',
     *            'LR  ','RF  ','X   ','BQ  '/
C
      IF(IARG.EQ.1) GO TO 100
      IF(IARG.EQ.2) GO TO 200
      IF(IARG.EQ.3) GO TO 300
      CALL ABRT
C
C         ----- FILL BASIS FUNCTION SYMBOL TABLE -----
C
  100 CONTINUE
      N = 0
      DO 120 II = 1,NSHELL
         IAT = KATOM(II)
         J = INT(ZAN(IAT))
         IF (J .GT. 106) J = 106
         IF (J .GT. 0) LABEL=ATMLAB(J)
         IF (J .LE. 0) LABEL=BONDF
         MINI = KMIN(II)
         MAXI = KMAX(II)
         DO 110 I = MINI,MAXI
            N = N+1
            IF(I.LE.35) THEN
               WRITE(UNIT=BFL,FMT='(A2,I2,A4)')
     *                      LABEL,MOD(IAT,100),BFNAM1(I)
            ELSE
               WRITE(UNIT=BFL,FMT='(A2,A6)')
     *                      LABEL,BFNAM2(I-35)
            END IF
            READ (UNIT=BFL,FMT='(A8)') BFLAB(N)
C
C              STORES ATOM CENTER FOR ELONGATION METHOD
            IATM(N) = IAT
  110    CONTINUE
  120 CONTINUE
      RETURN
C
C        ----- FILL ATOM SYMBOL TABLE -----
C
  200 CONTINUE
      DO 210 IAT=1,NAT
         NUCZ = INT(ZAN(IAT)) + IZCORE(IAT)
         ATMSYM(IAT) = ATMLAB(105)
         IF(NUCZ.GE.1  .AND.  NUCZ.LE.104) ATMSYM(IAT) = ATMLAB(NUCZ)
  210 CONTINUE
      RETURN
C
C        ----- RETURN THE PERIODIC TABLE -----
C
  300 CONTINUE
      DO 310 IAT=1,106
         ATMSYM(IAT) = ATMLAB(IAT)
  310 CONTINUE
      RETURN
      END
C*MODULE INPUTB  *DECK SPDTR
C
C> @brief : Calculate transforms of p,d,f,g,h,i functions for all
C>          symmetry operations
C>
C> @date  : December 21, 2012 - Joe Ivanic, Graham Fletcher
C>          Add functionality for h,i functions
C
      SUBROUTINE SPDTR
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXSH=5000, MXATM=2000)
C
      COMMON /FRAME / U1,U2,U3,V1,V2,V3,W1,W2,W3,X0,Y0,Z0
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /SYMSPD/ PTR(3,144),DTR(6,288),FTR(10,480),GTR(15,720)
      common /symhi / htr(21,1008),aitr(28,1344)
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                T(9,48),INVT(48),NT
      COMMON /TRANSF/ XSMAL,YSMAL,ZSMAL,XNEW,YNEW,ZNEW,XP,YP,ZP
C
      DIMENSION PNAME(3),DNAME(6),FNAME(10),GNAME(15)
      dimension hname(21),ainame(28)
C
      PARAMETER (ONE=1.0D+00, SQRT3=1.73205080756888D+00,
     *           SQRT5=2.23606797749979D+00,
     *           SQRT7=2.64575131106459D+00)
      parameter (sqrt9=3.0d+00,sqrt11=3.3166247903553998d+00)
C
      DATA PNAME /4HX   ,4HY   ,4HZ   /
      DATA DNAME /4HXX  ,4HYY  ,4HZZ  ,4HXY  ,4HXZ  ,4HYZ  /
      DATA FNAME /4HXXX ,4HYYY ,4HZZZ ,4HXXY ,4HXXZ ,4HYYX ,
     *            4HYYZ ,4HZZX ,4HZZY ,4HXYZ /
      DATA GNAME /4HXXXX,4HYYYY,4HZZZZ,4HXXXY,4HXXXZ,4HYYYX,
     *            4HYYYZ,4HZZZX,4HZZZY,4HXXYY,4HXXZZ,4HYYZZ,
     *            4HXXYZ,4HYYXZ,4HZZXY/
      data hname /6h xxxxx,6h yyyyy,6h zzzzz,6h xxxxy,6h xxxxz,
     1            6h yyyyx,6h yyyyz,6h zzzzx,6h zzzzy,6h xxxyy,
     2            6h xxxzz,6h yyyxx,6h yyyzz,6h zzzxx,6h zzzyy,
     3            6h xxxyz,6h yyyxz,6h zzzxy,6h xxyyz,6h xxzzy,
     4            6h yyzzx/
      data ainame/6h    x6,6h    y6,6h    z6,6h   x5y,6h   x5z,
     1            6h   y5x,6h   y5z,6h   z5x,6h   z5y,6h  x4y2,
     2            6h  x4z2,6h  y4x2,6h  y4z2,6h  z4x2,6h  z4y2,
     3            6h  x4yz,6h  y4xz,6h  z4xy,6h  x3y3,6h  x3z3,
     4            6h  y3z3,6h x3y2z,6h x3z2y,6h y3x2z,6h y3z2x,
     5            6h z3x2y,6h z3y2x,6hx2y2z2/
C
C     ----- CALCULATE TRANSFORMS OF P, D, F, G, H, I FUNCTIONS
C           FOR ALL SYMMETRY OPERATIONS.
C
      X = X0+ONE
      Y = Y0
      Z = Z0
      XS = X
      YS = Y
      ZS = Z
      CALL LOCAL(X,Y,Z,XS,YS,ZS)
      XSMAL = XS
      YSMAL = YS
      ZSMAL = ZS
      DO 100 IT = 1,NT
      NN = 9*(IT-1)
      CALL TRANS(NN)
      CALL ROT
      N = 3*(IT-1)
      PTR(1,N+1) = XP-X0
      PTR(2,N+1) = YP-Y0
      PTR(3,N+1) = ZP-Z0
  100 CONTINUE
      X = X0
      Y = Y0+ONE
      Z = Z0
      CALL LOCAL(X,Y,Z,XS,YS,ZS)
      XSMAL = XS
      YSMAL = YS
      ZSMAL = ZS
      DO 120 IT = 1,NT
      NN = 9*(IT-1)
      CALL TRANS(NN)
      CALL ROT
      N = 3*(IT-1)
      PTR(1,N+2) = XP-X0
      PTR(2,N+2) = YP-Y0
      PTR(3,N+2) = ZP-Z0
  120 CONTINUE
      X = X0
      Y = Y0
      Z = Z0+ONE
      CALL LOCAL(X,Y,Z,XS,YS,ZS)
      XSMAL = XS
      YSMAL = YS
      ZSMAL = ZS
      DO 140 IT = 1,NT
      NN = 9*(IT-1)
      CALL TRANS(NN)
      CALL ROT
      N = 3*(IT-1)
      PTR(1,N+3) = XP-X0
      PTR(2,N+3) = YP-Y0
      PTR(3,N+3) = ZP-Z0
  140 CONTINUE
      DO 640 IT = 1,NT
      NP = 3*(IT-1)
      ND = 6*(IT-1)
      NF = 10*(IT-1)
      NG = 15*(IT-1)
      nh = 21*(it-1)
      ni = 28*(it-1)
C
      DO 300 I = 1,6
      GO TO (160,180,200,220,240,260) ,I
  160 J = 1
      K = 1
      GO TO 280
C
  180 J = 2
      K = 2
      GO TO 280
C
  200 J = 3
      K = 3
      GO TO 280
C
  220 J = 1
      K = 2
      GO TO 280
C
  240 J = 1
      K = 3
      GO TO 280
C
  260 J = 2
      K = 3
  280 DTR(1,ND+I) = PTR(1,NP+J)*PTR(1,NP+K)
      DTR(2,ND+I) = PTR(2,NP+J)*PTR(2,NP+K)
      DTR(3,ND+I) = PTR(3,NP+J)*PTR(3,NP+K)
      DTR(4,ND+I) = PTR(1,NP+J)*PTR(2,NP+K) +PTR(2,NP+J)*PTR(1,NP+K)
      DTR(5,ND+I) = PTR(1,NP+J)*PTR(3,NP+K) +PTR(3,NP+J)*PTR(1,NP+K)
      DTR(6,ND+I) = PTR(2,NP+J)*PTR(3,NP+K) +PTR(3,NP+J)*PTR(2,NP+K)
  300 CONTINUE
      DO 440 I=1,10
      GO TO (320,330,340,350,360,370,380,390,400,410),I
  320 J=1
      K=1
      GO TO 420
  330 J=2
      K=2
      GO TO 420
  340 J=3
      K=3
      GO TO 420
  350 J=1
      K=2
      GO TO 420
  360 J=1
      K=3
      GO TO 420
  370 J=2
      K=1
      GO TO 420
  380 J=2
      K=3
      GO TO 420
  390 J=3
      K=1
      GO TO 420
  400 J=3
      K=2
      GO TO 420
  410 J=4
      K=3
  420 FTR(1,NF+I)=DTR(1,ND+J)*PTR(1,NP+K)
      FTR(2,NF+I)=DTR(2,ND+J)*PTR(2,NP+K)
      FTR(3,NF+I)=DTR(3,ND+J)*PTR(3,NP+K)
      FTR(4,NF+I)=DTR(1,ND+J)*PTR(2,NP+K)
     1           +DTR(4,ND+J)*PTR(1,NP+K)
      FTR(5,NF+I)=DTR(1,ND+J)*PTR(3,NP+K)
     1           +DTR(5,ND+J)*PTR(1,NP+K)
      FTR(6,NF+I)=DTR(2,ND+J)*PTR(1,NP+K)
     1           +DTR(4,ND+J)*PTR(2,NP+K)
      FTR(7,NF+I)=DTR(2,ND+J)*PTR(3,NP+K)
     1           +DTR(6,ND+J)*PTR(2,NP+K)
      FTR(8,NF+I)=DTR(3,ND+J)*PTR(1,NP+K)
     1           +DTR(5,ND+J)*PTR(3,NP+K)
      FTR(9,NF+I)=DTR(3,ND+J)*PTR(2,NP+K)
     1           +DTR(6,ND+J)*PTR(3,NP+K)
      FTR(10,NF+I)=DTR(4,ND+J)*PTR(3,NP+K)
     1           + DTR(5,ND+J)*PTR(2,NP+K)
     2           + DTR(6,ND+J)*PTR(1,NP+K)
  440 CONTINUE
      DO 620 I=1,15
      GO TO (460,470,480,490,500,510,520,530,
     1       540,550,560,570,580,590,600),I
  460 J=1
      K=1
      GO TO 610
  470 J=2
      K=2
      GO TO 610
  480 J=3
      K=3
      GO TO 610
  490 J=1
      K=2
      GO TO 610
  500 J=1
      K=3
      GO TO 610
  510 J=2
      K=1
      GO TO 610
  520 J=2
      K=3
      GO TO 610
  530 J=3
      K=1
      GO TO 610
  540 J=3
      K=2
      GO TO 610
  550 J=4
      K=2
      GO TO 610
  560 J=5
      K=3
      GO TO 610
  570 J=7
      K=3
      GO TO 610
  580 J=4
      K=3
      GO TO 610
  590 J=6
      K=3
      GO TO 610
  600 J=8
      K=2
  610 GTR(1,NG+I)=FTR(1,NF+J)*PTR(1,NP+K)
      GTR(2,NG+I)=FTR(2,NF+J)*PTR(2,NP+K)
      GTR(3,NG+I)=FTR(3,NF+J)*PTR(3,NP+K)
      GTR(4,NG+I)=FTR(1,NF+J)*PTR(2,NP+K)
     1           +FTR(4,NF+J)*PTR(1,NP+K)
      GTR(5,NG+I)=FTR(1,NF+J)*PTR(3,NP+K)
     1           +FTR(5,NF+J)*PTR(1,NP+K)
      GTR(6,NG+I)=FTR(2,NF+J)*PTR(1,NP+K)
     1           +FTR(6,NF+J)*PTR(2,NP+K)
      GTR(7,NG+I)=FTR(2,NF+J)*PTR(3,NP+K)
     1           +FTR(7,NF+J)*PTR(2,NP+K)
      GTR(8,NG+I)=FTR(3,NF+J)*PTR(1,NP+K)
     1           +FTR(8,NF+J)*PTR(3,NP+K)
      GTR(9,NG+I)=FTR(3,NF+J)*PTR(2,NP+K)
     1           +FTR(9,NF+J)*PTR(3,NP+K)
      GTR(10,NG+I)=FTR(4,NF+J)*PTR(2,NP+K)
     1           + FTR(6,NF+J)*PTR(1,NP+K)
      GTR(11,NG+I)=FTR(5,NF+J)*PTR(3,NP+K)
     1           + FTR(8,NF+J)*PTR(1,NP+K)
      GTR(12,NG+I)=FTR(7,NF+J)*PTR(3,NP+K)
     1           + FTR(9,NF+J)*PTR(2,NP+K)
      GTR(13,NG+I)=FTR(4,NF+J)*PTR(3,NP+K)
     1           + FTR(5,NF+J)*PTR(2,NP+K)
     2           +FTR(10,NF+J)*PTR(1,NP+K)
      GTR(14,NG+I)=FTR(6,NF+J)*PTR(3,NP+K)
     1           + FTR(7,NF+J)*PTR(1,NP+K)
     2           +FTR(10,NF+J)*PTR(2,NP+K)
      GTR(15,NG+I)=FTR(8,NF+J)*PTR(2,NP+K)
     1           + FTR(9,NF+J)*PTR(1,NP+K)
     2           +FTR(10,NF+J)*PTR(3,NP+K)
  620 CONTINUE
C
CGDF  Add loops for h,i
C     Convention is to always use the 'p' transformation
C
      do 1000 i=1,21
      go to (1010,1020,1030,1040,1050,1060,1070,
     1       1080,1090,1100,1110,1120,1130,1140,
     2       1150,1160,1170,1180,1190,1200,1210), i
 1010 j=1
      k=1
      go to 1220
 1020 j=2
      k=2
      go to 1220
 1030 j=3
      k=3
      go to 1220
 1040 j=1
      k=2
      go to 1220
 1050 j=1
      k=3
      go to 1220
 1060 j=2
      k=1
      go to 1220
 1070 j=2
      k=3
      go to 1220
 1080 j=3
      k=1
      go to 1220
 1090 j=3
      k=2
      go to 1220
 1100 j=4
      k=2
      go to 1220
 1110 j=5
      k=3
      go to 1220
 1120 j=6
      k=1
      go to 1220
 1130 j=7
      k=3
      go to 1220
 1140 j=8
      k=1
      go to 1220
 1150 j=9
      k=2
      go to 1220
 1160 j=4
      k=3
      go to 1220
 1170 j=6
      k=3
      go to 1220
 1180 j=8
      k=2
      go to 1220
 1190 j=10
      k=3
      go to 1220
 1200 j=11
      k=2
      go to 1220
 1210 j=12
      k=1
 1220 htr( 1,nh+i)=gtr( 1,ng+j)*ptr(1,np+k)
      htr( 2,nh+i)=gtr( 2,ng+j)*ptr(2,np+k)
      htr( 3,nh+i)=gtr( 3,ng+j)*ptr(3,np+k)
      htr( 4,nh+i)=gtr( 1,ng+j)*ptr(2,np+k)
     1            +gtr( 4,ng+j)*ptr(1,np+k)
      htr( 5,nh+i)=gtr( 1,ng+j)*ptr(3,np+k)
     1            +gtr( 5,ng+j)*ptr(1,np+k)
      htr( 6,nh+i)=gtr( 2,ng+j)*ptr(1,np+k)
     1            +gtr( 6,ng+j)*ptr(2,np+k)
      htr( 7,nh+i)=gtr( 2,ng+j)*ptr(3,np+k)
     1            +gtr( 7,ng+j)*ptr(2,np+k)
      htr( 8,nh+i)=gtr( 3,ng+j)*ptr(1,np+k)
     1            +gtr( 8,ng+j)*ptr(3,np+k)
      htr( 9,nh+i)=gtr( 3,ng+j)*ptr(2,np+k)
     1            +gtr( 9,ng+j)*ptr(3,np+k)
      htr(10,nh+i)=gtr( 4,ng+j)*ptr(2,np+k)
     1            +gtr(10,ng+j)*ptr(1,np+k)
      htr(11,nh+i)=gtr( 5,ng+j)*ptr(3,np+k)
     1            +gtr(11,ng+j)*ptr(1,np+k)
      htr(12,nh+i)=gtr( 6,ng+j)*ptr(1,np+k)
     1            +gtr(10,ng+j)*ptr(2,np+k)
      htr(13,nh+i)=gtr( 7,ng+j)*ptr(3,np+k)
     1            +gtr(12,ng+j)*ptr(2,np+k)
      htr(14,nh+i)=gtr( 8,ng+j)*ptr(1,np+k)
     1            +gtr(11,ng+j)*ptr(3,np+k)
      htr(15,nh+i)=gtr( 9,ng+j)*ptr(2,np+k)
     1            +gtr(12,ng+j)*ptr(3,np+k)
      htr(16,nh+i)=gtr( 4,ng+j)*ptr(3,np+k)
     1            +gtr( 5,ng+j)*ptr(2,np+k)
     2            +gtr(13,ng+j)*ptr(1,np+k)
      htr(17,nh+i)=gtr( 6,ng+j)*ptr(3,np+k)
     1            +gtr( 7,ng+j)*ptr(1,np+k)
     2            +gtr(14,ng+j)*ptr(2,np+k)
      htr(18,nh+i)=gtr( 8,ng+j)*ptr(2,np+k)
     1            +gtr( 9,ng+j)*ptr(1,np+k)
     2            +gtr(15,ng+j)*ptr(3,np+k)
      htr(19,nh+i)=gtr(10,ng+j)*ptr(3,np+k)
     1            +gtr(13,ng+j)*ptr(2,np+k)
     2            +gtr(14,ng+j)*ptr(1,np+k)
      htr(20,nh+i)=gtr(11,ng+j)*ptr(2,np+k)
     1            +gtr(13,ng+j)*ptr(3,np+k)
     2            +gtr(15,ng+j)*ptr(1,np+k)
      htr(21,nh+i)=gtr(12,ng+j)*ptr(1,np+k)
     1            +gtr(14,ng+j)*ptr(3,np+k)
     2            +gtr(15,ng+j)*ptr(2,np+k)
 1000 continue
c
      do 2000 i=1,28
      go to (2010,2020,2030,2040,2050,2060,2070,
     1       2080,2090,2100,2110,2120,2130,2140,
     2       2150,2160,2170,2180,2190,2200,2210,
     3       2220,2230,2240,2250,2260,2270,2280), i
 2010 j=1
      k=1
      go to 2290
 2020 j=2
      k=2
      go to 2290
 2030 j=3
      k=3
      go to 2290
 2040 j=1
      k=2
      go to 2290
 2050 j=1
      k=3
      go to 2290
 2060 j=2
      k=1
      go to 2290
 2070 j=2
      k=3
      go to 2290
 2080 j=3
      k=1
      go to 2290
 2090 j=3
      k=2
      go to 2290
 2100 j=4
      k=2
      go to 2290
 2110 j=5
      k=3
      go to 2290
 2120 j=6
      k=1
      go to 2290
 2130 j=7
      k=3
      go to 2290
 2140 j=8
      k=1
      go to 2290
 2150 j=9
      k=2
      go to 2290
 2160 j=4
      k=3
      go to 2290
 2170 j=6
      k=3
      go to 2290
 2180 j=8
      k=2
      go to 2290
 2190 j=10
      k=2
      go to 2290
 2200 j=11
      k=3
      go to 2290
 2210 j=13
      k=3
      go to 2290
 2220 j=10
      k=3
      go to 2290
 2230 j=11
      k=2
      go to 2290
 2240 j=12
      k=3
      go to 2290
 2250 j=13
      k=1
      go to 2290
 2260 j=14
      k=2
      go to 2290
 2270 j=15
      k=1
      go to 2290
 2280 j=19
      k=3
 2290 aitr( 1,ni+i)=htr( 1,nh+j)*ptr(1,np+k)
      aitr( 2,ni+i)=htr( 2,nh+j)*ptr(2,np+k)
      aitr( 3,ni+i)=htr( 3,nh+j)*ptr(3,np+k)
      aitr( 4,ni+i)=htr( 1,nh+j)*ptr(2,np+k)
     1             +htr( 4,nh+j)*ptr(1,np+k)
      aitr( 5,ni+i)=htr( 1,nh+j)*ptr(3,np+k)
     1             +htr( 5,nh+j)*ptr(1,np+k)
      aitr( 6,ni+i)=htr( 2,nh+j)*ptr(1,np+k)
     1             +htr( 6,nh+j)*ptr(2,np+k)
      aitr( 7,ni+i)=htr( 2,nh+j)*ptr(3,np+k)
     1             +htr( 7,nh+j)*ptr(2,np+k)
      aitr( 8,ni+i)=htr( 3,nh+j)*ptr(1,np+k)
     1             +htr( 8,nh+j)*ptr(3,np+k)
      aitr( 9,ni+i)=htr( 3,nh+j)*ptr(2,np+k)
     1             +htr( 9,nh+j)*ptr(3,np+k)
      aitr(10,ni+i)=htr( 4,nh+j)*ptr(2,np+k)
     1             +htr(10,nh+j)*ptr(1,np+k)
      aitr(11,ni+i)=htr( 5,nh+j)*ptr(3,np+k)
     1             +htr(11,nh+j)*ptr(1,np+k)
      aitr(12,ni+i)=htr( 6,nh+j)*ptr(1,np+k)
     1             +htr(12,nh+j)*ptr(2,np+k)
      aitr(13,ni+i)=htr( 7,nh+j)*ptr(3,np+k)
     1             +htr(13,nh+j)*ptr(2,np+k)
      aitr(14,ni+i)=htr( 8,nh+j)*ptr(1,np+k)
     1             +htr(14,nh+j)*ptr(3,np+k)
      aitr(15,ni+i)=htr( 9,nh+j)*ptr(2,np+k)
     1             +htr(15,nh+j)*ptr(3,np+k)
      aitr(16,ni+i)=htr( 4,nh+j)*ptr(3,np+k)
     1             +htr( 5,nh+j)*ptr(2,np+k)
     2             +htr(16,nh+j)*ptr(1,np+k)
      aitr(17,ni+i)=htr( 6,nh+j)*ptr(3,np+k)
     1             +htr( 7,nh+j)*ptr(1,np+k)
     2             +htr(17,nh+j)*ptr(2,np+k)
      aitr(18,ni+i)=htr( 8,nh+j)*ptr(2,np+k)
     1             +htr( 9,nh+j)*ptr(1,np+k)
     2             +htr(18,nh+j)*ptr(3,np+k)
      aitr(19,ni+i)=htr(10,nh+j)*ptr(2,np+k)
     1             +htr(12,nh+j)*ptr(1,np+k)
      aitr(20,ni+i)=htr(11,nh+j)*ptr(3,np+k)
     1             +htr(14,nh+j)*ptr(1,np+k)
      aitr(21,ni+i)=htr(13,nh+j)*ptr(3,np+k)
     1             +htr(15,nh+j)*ptr(2,np+k)
      aitr(22,ni+i)=htr(10,nh+j)*ptr(3,np+k)
     1             +htr(16,nh+j)*ptr(2,np+k)
     2             +htr(19,nh+j)*ptr(1,np+k)
      aitr(23,ni+i)=htr(11,nh+j)*ptr(2,np+k)
     1             +htr(16,nh+j)*ptr(3,np+k)
     2             +htr(20,nh+j)*ptr(1,np+k)
      aitr(24,ni+i)=htr(12,nh+j)*ptr(3,np+k)
     1             +htr(17,nh+j)*ptr(1,np+k)
     2             +htr(19,nh+j)*ptr(2,np+k)
      aitr(25,ni+i)=htr(13,nh+j)*ptr(1,np+k)
     1             +htr(17,nh+j)*ptr(3,np+k)
     2             +htr(21,nh+j)*ptr(2,np+k)
      aitr(26,ni+i)=htr(14,nh+j)*ptr(2,np+k)
     1             +htr(18,nh+j)*ptr(1,np+k)
     2             +htr(20,nh+j)*ptr(3,np+k)
      aitr(27,ni+i)=htr(15,nh+j)*ptr(1,np+k)
     1             +htr(18,nh+j)*ptr(2,np+k)
     2             +htr(21,nh+j)*ptr(3,np+k)
      aitr(28,ni+i)=htr(19,nh+j)*ptr(3,np+k)
     1             +htr(20,nh+j)*ptr(2,np+k)
     2             +htr(21,nh+j)*ptr(1,np+k)
 2000 continue
C
  640 CONTINUE
C
      IF (NORMF .EQ. 1 .AND. NORMP .EQ. 1) GO TO 750
      DO 740 IT = 1,NT
      ND = 6*(IT-1)
      NF = 10*(IT-1)
      NG = 15*(IT-1)
      nh = 21*(it-1)
      ni = 28*(it-1)
C
      DO 660 I = 1,6
      IF (I .GT. 3) GO TO 650
      DTR(4,ND+I) = DTR(4,ND+I)/SQRT3
      DTR(5,ND+I) = DTR(5,ND+I)/SQRT3
      DTR(6,ND+I) = DTR(6,ND+I)/SQRT3
      GO TO 660
C
  650 DTR(1,ND+I) = DTR(1,ND+I)*SQRT3
      DTR(2,ND+I) = DTR(2,ND+I)*SQRT3
      DTR(3,ND+I) = DTR(3,ND+I)*SQRT3
  660 CONTINUE
      DO 690 I=1,10
      IF(I.GT.3) GO TO 670
      FTR(4,NF+I)=FTR(4,NF+I)/SQRT5
      FTR(5,NF+I)=FTR(5,NF+I)/SQRT5
      FTR(6,NF+I)=FTR(6,NF+I)/SQRT5
      FTR(7,NF+I)=FTR(7,NF+I)/SQRT5
      FTR(8,NF+I)=FTR(8,NF+I)/SQRT5
      FTR(9,NF+I)=FTR(9,NF+I)/SQRT5
      FTR(10,NF+I)=FTR(10,NF+I)/(SQRT5*SQRT3)
      GO TO 690
  670 IF(I.GT.9) GO TO 680
      FTR(1,NF+I)=FTR(1,NF+I)*SQRT5
      FTR(2,NF+I)=FTR(2,NF+I)*SQRT5
      FTR(3,NF+I)=FTR(3,NF+I)*SQRT5
      FTR(10,NF+I)=FTR(10,NF+I)/SQRT3
      GO TO 690
  680 FTR(1,NF+I)=FTR(1,NF+I)*SQRT5*SQRT3
      FTR(2,NF+I)=FTR(2,NF+I)*SQRT5*SQRT3
      FTR(3,NF+I)=FTR(3,NF+I)*SQRT5*SQRT3
      FTR(4,NF+I)=FTR(4,NF+I)*SQRT3
      FTR(5,NF+I)=FTR(5,NF+I)*SQRT3
      FTR(6,NF+I)=FTR(6,NF+I)*SQRT3
      FTR(7,NF+I)=FTR(7,NF+I)*SQRT3
      FTR(8,NF+I)=FTR(8,NF+I)*SQRT3
      FTR(9,NF+I)=FTR(9,NF+I)*SQRT3
  690 CONTINUE
      DO 730 I=1,15
      IF(I.GT.3) GO TO 700
      GTR(4,NG+I)=GTR(4,NG+I)/SQRT7
      GTR(5,NG+I)=GTR(5,NG+I)/SQRT7
      GTR(6,NG+I)=GTR(6,NG+I)/SQRT7
      GTR(7,NG+I)=GTR(7,NG+I)/SQRT7
      GTR(8,NG+I)=GTR(8,NG+I)/SQRT7
      GTR(9,NG+I)=GTR(9,NG+I)/SQRT7
      GTR(10,NG+I)=GTR(10,NG+I)*SQRT3/(SQRT5*SQRT7)
      GTR(11,NG+I)=GTR(11,NG+I)*SQRT3/(SQRT5*SQRT7)
      GTR(12,NG+I)=GTR(12,NG+I)*SQRT3/(SQRT5*SQRT7)
      GTR(13,NG+I)=GTR(13,NG+I)/(SQRT5*SQRT7)
      GTR(14,NG+I)=GTR(14,NG+I)/(SQRT5*SQRT7)
      GTR(15,NG+I)=GTR(15,NG+I)/(SQRT5*SQRT7)
      GO TO 730
  700 IF(I.GT.9) GO TO 710
      GTR(1,NG+I)=GTR(1,NG+I)*SQRT7
      GTR(2,NG+I)=GTR(2,NG+I)*SQRT7
      GTR(3,NG+I)=GTR(3,NG+I)*SQRT7
      GTR(10,NG+I)=GTR(10,NG+I)*SQRT3/SQRT5
      GTR(11,NG+I)=GTR(11,NG+I)*SQRT3/SQRT5
      GTR(12,NG+I)=GTR(12,NG+I)*SQRT3/SQRT5
      GTR(13,NG+I)=GTR(13,NG+I)/SQRT5
      GTR(14,NG+I)=GTR(14,NG+I)/SQRT5
      GTR(15,NG+I)=GTR(15,NG+I)/SQRT5
      GO TO 730
  710 IF(I.GT.12) GO TO 720
      GTR(1,NG+I)=GTR(1,NG+I)*SQRT7*SQRT5/SQRT3
      GTR(2,NG+I)=GTR(2,NG+I)*SQRT7*SQRT5/SQRT3
      GTR(3,NG+I)=GTR(3,NG+I)*SQRT7*SQRT5/SQRT3
      GTR(4,NG+I)=GTR(4,NG+I)*SQRT5/SQRT3
      GTR(5,NG+I)=GTR(5,NG+I)*SQRT5/SQRT3
      GTR(6,NG+I)=GTR(6,NG+I)*SQRT5/SQRT3
      GTR(7,NG+I)=GTR(7,NG+I)*SQRT5/SQRT3
      GTR(8,NG+I)=GTR(8,NG+I)*SQRT5/SQRT3
      GTR(9,NG+I)=GTR(9,NG+I)*SQRT5/SQRT3
      GTR(13,NG+I)=GTR(13,NG+I)/SQRT3
      GTR(14,NG+I)=GTR(14,NG+I)/SQRT3
      GTR(15,NG+I)=GTR(15,NG+I)/SQRT3
      GO TO 730
  720 GTR(1,NG+I)=GTR(1,NG+I)*SQRT7*SQRT5
      GTR(2,NG+I)=GTR(2,NG+I)*SQRT7*SQRT5
      GTR(3,NG+I)=GTR(3,NG+I)*SQRT7*SQRT5
      GTR(4,NG+I)=GTR(4,NG+I)*SQRT5
      GTR(5,NG+I)=GTR(5,NG+I)*SQRT5
      GTR(6,NG+I)=GTR(6,NG+I)*SQRT5
      GTR(7,NG+I)=GTR(7,NG+I)*SQRT5
      GTR(8,NG+I)=GTR(8,NG+I)*SQRT5
      GTR(9,NG+I)=GTR(9,NG+I)*SQRT5
      GTR(10,NG+I)=GTR(10,NG+I)*SQRT3
      GTR(11,NG+I)=GTR(11,NG+I)*SQRT3
      GTR(12,NG+I)=GTR(12,NG+I)*SQRT3
  730 CONTINUE
C
CJI  Add new normalizations of HTR and AITR blocks
C
      do 3000 i=1,21
      if(i.gt.3) go to 3010
      htr( 4,nh+i)=htr( 4,nh+i)/sqrt9
      htr( 5,nh+i)=htr( 5,nh+i)/sqrt9
      htr( 6,nh+i)=htr( 6,nh+i)/sqrt9
      htr( 7,nh+i)=htr( 7,nh+i)/sqrt9
      htr( 8,nh+i)=htr( 8,nh+i)/sqrt9
      htr( 9,nh+i)=htr( 9,nh+i)/sqrt9
      htr(10,nh+i)=htr(10,nh+i)*sqrt3/(sqrt7*sqrt9)
      htr(11,nh+i)=htr(11,nh+i)*sqrt3/(sqrt7*sqrt9)
      htr(12,nh+i)=htr(12,nh+i)*sqrt3/(sqrt7*sqrt9)
      htr(13,nh+i)=htr(13,nh+i)*sqrt3/(sqrt7*sqrt9)
      htr(14,nh+i)=htr(14,nh+i)*sqrt3/(sqrt7*sqrt9)
      htr(15,nh+i)=htr(15,nh+i)*sqrt3/(sqrt7*sqrt9)
      htr(16,nh+i)=htr(16,nh+i)/(sqrt7*sqrt9)
      htr(17,nh+i)=htr(17,nh+i)/(sqrt7*sqrt9)
      htr(18,nh+i)=htr(18,nh+i)/(sqrt7*sqrt9)
      htr(19,nh+i)=htr(19,nh+i)*sqrt3/(sqrt5*sqrt7*sqrt9)
      htr(20,nh+i)=htr(20,nh+i)*sqrt3/(sqrt5*sqrt7*sqrt9)
      htr(21,nh+i)=htr(21,nh+i)*sqrt3/(sqrt5*sqrt7*sqrt9)
      go to 3000
 3010 if(i.gt.9) go to 3020
      htr( 1,nh+i)=htr( 1,nh+i)*sqrt9
      htr( 2,nh+i)=htr( 2,nh+i)*sqrt9
      htr( 3,nh+i)=htr( 3,nh+i)*sqrt9
      htr(10,nh+i)=htr(10,nh+i)*sqrt3/sqrt7
      htr(11,nh+i)=htr(11,nh+i)*sqrt3/sqrt7
      htr(12,nh+i)=htr(12,nh+i)*sqrt3/sqrt7
      htr(13,nh+i)=htr(13,nh+i)*sqrt3/sqrt7
      htr(14,nh+i)=htr(14,nh+i)*sqrt3/sqrt7
      htr(15,nh+i)=htr(15,nh+i)*sqrt3/sqrt7
      htr(16,nh+i)=htr(16,nh+i)/sqrt7
      htr(17,nh+i)=htr(17,nh+i)/sqrt7
      htr(18,nh+i)=htr(18,nh+i)/sqrt7
      htr(19,nh+i)=htr(19,nh+i)*sqrt3/(sqrt5*sqrt7)
      htr(20,nh+i)=htr(20,nh+i)*sqrt3/(sqrt5*sqrt7)
      htr(21,nh+i)=htr(21,nh+i)*sqrt3/(sqrt5*sqrt7)
      go to 3000
 3020 if(i.gt.15) go to 3030
      htr( 1,nh+i)=htr( 1,nh+i)*(sqrt7*sqrt9)/sqrt3
      htr( 2,nh+i)=htr( 2,nh+i)*(sqrt7*sqrt9)/sqrt3
      htr( 3,nh+i)=htr( 3,nh+i)*(sqrt7*sqrt9)/sqrt3
      htr( 4,nh+i)=htr( 4,nh+i)*sqrt7/sqrt3
      htr( 5,nh+i)=htr( 5,nh+i)*sqrt7/sqrt3
      htr( 6,nh+i)=htr( 6,nh+i)*sqrt7/sqrt3
      htr( 7,nh+i)=htr( 7,nh+i)*sqrt7/sqrt3
      htr( 8,nh+i)=htr( 8,nh+i)*sqrt7/sqrt3
      htr( 9,nh+i)=htr( 9,nh+i)*sqrt7/sqrt3
      htr(16,nh+i)=htr(16,nh+i)/sqrt3
      htr(17,nh+i)=htr(17,nh+i)/sqrt3
      htr(18,nh+i)=htr(18,nh+i)/sqrt3
      htr(19,nh+i)=htr(19,nh+i)/sqrt5
      htr(20,nh+i)=htr(20,nh+i)/sqrt5
      htr(21,nh+i)=htr(21,nh+i)/sqrt5
      go to 3000
 3030 if(i.gt.18) go to 3040
      htr( 1,nh+i)=htr( 1,nh+i)*sqrt7*sqrt9
      htr( 2,nh+i)=htr( 2,nh+i)*sqrt7*sqrt9
      htr( 3,nh+i)=htr( 3,nh+i)*sqrt7*sqrt9
      htr( 4,nh+i)=htr( 4,nh+i)*sqrt7
      htr( 5,nh+i)=htr( 5,nh+i)*sqrt7
      htr( 6,nh+i)=htr( 6,nh+i)*sqrt7
      htr( 7,nh+i)=htr( 7,nh+i)*sqrt7
      htr( 8,nh+i)=htr( 8,nh+i)*sqrt7
      htr( 9,nh+i)=htr( 9,nh+i)*sqrt7
      htr(10,nh+i)=htr(10,nh+i)*sqrt3
      htr(11,nh+i)=htr(11,nh+i)*sqrt3
      htr(12,nh+i)=htr(12,nh+i)*sqrt3
      htr(13,nh+i)=htr(13,nh+i)*sqrt3
      htr(14,nh+i)=htr(14,nh+i)*sqrt3
      htr(15,nh+i)=htr(15,nh+i)*sqrt3
      htr(19,nh+i)=htr(19,nh+i)*sqrt3/sqrt5
      htr(20,nh+i)=htr(20,nh+i)*sqrt3/sqrt5
      htr(21,nh+i)=htr(21,nh+i)*sqrt3/sqrt5
      go to 3000
 3040 htr( 1,nh+i)=htr( 1,nh+i)*sqrt5*sqrt7*sqrt9/sqrt3
      htr( 2,nh+i)=htr( 2,nh+i)*sqrt5*sqrt7*sqrt9/sqrt3
      htr( 3,nh+i)=htr( 3,nh+i)*sqrt5*sqrt7*sqrt9/sqrt3
      htr( 4,nh+i)=htr( 4,nh+i)*sqrt5*sqrt7/sqrt3
      htr( 5,nh+i)=htr( 5,nh+i)*sqrt5*sqrt7/sqrt3
      htr( 6,nh+i)=htr( 6,nh+i)*sqrt5*sqrt7/sqrt3
      htr( 7,nh+i)=htr( 7,nh+i)*sqrt5*sqrt7/sqrt3
      htr( 8,nh+i)=htr( 8,nh+i)*sqrt5*sqrt7/sqrt3
      htr( 9,nh+i)=htr( 9,nh+i)*sqrt5*sqrt7/sqrt3
      htr(10,nh+i)=htr(10,nh+i)*sqrt5
      htr(11,nh+i)=htr(11,nh+i)*sqrt5
      htr(12,nh+i)=htr(12,nh+i)*sqrt5
      htr(13,nh+i)=htr(13,nh+i)*sqrt5
      htr(14,nh+i)=htr(14,nh+i)*sqrt5
      htr(15,nh+i)=htr(15,nh+i)*sqrt5
      htr(16,nh+i)=htr(16,nh+i)*sqrt5/sqrt3
      htr(17,nh+i)=htr(17,nh+i)*sqrt5/sqrt3
      htr(18,nh+i)=htr(18,nh+i)*sqrt5/sqrt3
 3000 continue
C
      do 4000 i=1,28
      if(i.gt.3) go to 4010
      aitr( 4,ni+i)=aitr( 4,ni+i)/sqrt11
      aitr( 5,ni+i)=aitr( 5,ni+i)/sqrt11
      aitr( 6,ni+i)=aitr( 6,ni+i)/sqrt11
      aitr( 7,ni+i)=aitr( 7,ni+i)/sqrt11
      aitr( 8,ni+i)=aitr( 8,ni+i)/sqrt11
      aitr( 9,ni+i)=aitr( 9,ni+i)/sqrt11
      aitr(10,ni+i)=aitr(10,ni+i)*sqrt3/(sqrt9*sqrt11)
      aitr(11,ni+i)=aitr(11,ni+i)*sqrt3/(sqrt9*sqrt11)
      aitr(12,ni+i)=aitr(12,ni+i)*sqrt3/(sqrt9*sqrt11)
      aitr(13,ni+i)=aitr(13,ni+i)*sqrt3/(sqrt9*sqrt11)
      aitr(14,ni+i)=aitr(14,ni+i)*sqrt3/(sqrt9*sqrt11)
      aitr(15,ni+i)=aitr(15,ni+i)*sqrt3/(sqrt9*sqrt11)
      aitr(16,ni+i)=aitr(16,ni+i)/(sqrt9*sqrt11)
      aitr(17,ni+i)=aitr(17,ni+i)/(sqrt9*sqrt11)
      aitr(18,ni+i)=aitr(18,ni+i)/(sqrt9*sqrt11)
      aitr(19,ni+i)=aitr(19,ni+i)*sqrt5*sqrt3/(sqrt7*sqrt9*sqrt11)
      aitr(20,ni+i)=aitr(20,ni+i)*sqrt5*sqrt3/(sqrt7*sqrt9*sqrt11)
      aitr(21,ni+i)=aitr(21,ni+i)*sqrt5*sqrt3/(sqrt7*sqrt9*sqrt11)
      aitr(22,ni+i)=aitr(22,ni+i)*sqrt3/(sqrt7*sqrt9*sqrt11)
      aitr(23,ni+i)=aitr(23,ni+i)*sqrt3/(sqrt7*sqrt9*sqrt11)
      aitr(24,ni+i)=aitr(24,ni+i)*sqrt3/(sqrt7*sqrt9*sqrt11)
      aitr(25,ni+i)=aitr(25,ni+i)*sqrt3/(sqrt7*sqrt9*sqrt11)
      aitr(26,ni+i)=aitr(26,ni+i)*sqrt3/(sqrt7*sqrt9*sqrt11)
      aitr(27,ni+i)=aitr(27,ni+i)*sqrt3/(sqrt7*sqrt9*sqrt11)
      aitr(28,ni+i)=aitr(28,ni+i)*sqrt3*sqrt3/(sqrt5*sqrt7*sqrt9*sqrt11)
      go to 4000
 4010 if(i.gt.9) go to 4015
      aitr( 1,ni+i)=aitr( 1,ni+i)*sqrt11
      aitr( 2,ni+i)=aitr( 2,ni+i)*sqrt11
      aitr( 3,ni+i)=aitr( 3,ni+i)*sqrt11
      aitr(10,ni+i)=aitr(10,ni+i)*sqrt3/sqrt9
      aitr(11,ni+i)=aitr(11,ni+i)*sqrt3/sqrt9
      aitr(12,ni+i)=aitr(12,ni+i)*sqrt3/sqrt9
      aitr(13,ni+i)=aitr(13,ni+i)*sqrt3/sqrt9
      aitr(14,ni+i)=aitr(14,ni+i)*sqrt3/sqrt9
      aitr(15,ni+i)=aitr(15,ni+i)*sqrt3/sqrt9
      aitr(16,ni+i)=aitr(16,ni+i)/sqrt9
      aitr(17,ni+i)=aitr(17,ni+i)/sqrt9
      aitr(18,ni+i)=aitr(18,ni+i)/sqrt9
      aitr(19,ni+i)=aitr(19,ni+i)*sqrt5*sqrt3/(sqrt7*sqrt9)
      aitr(20,ni+i)=aitr(20,ni+i)*sqrt5*sqrt3/(sqrt7*sqrt9)
      aitr(21,ni+i)=aitr(21,ni+i)*sqrt5*sqrt3/(sqrt7*sqrt9)
      aitr(22,ni+i)=aitr(22,ni+i)*sqrt3/(sqrt7*sqrt9)
      aitr(23,ni+i)=aitr(23,ni+i)*sqrt3/(sqrt7*sqrt9)
      aitr(24,ni+i)=aitr(24,ni+i)*sqrt3/(sqrt7*sqrt9)
      aitr(25,ni+i)=aitr(25,ni+i)*sqrt3/(sqrt7*sqrt9)
      aitr(26,ni+i)=aitr(26,ni+i)*sqrt3/(sqrt7*sqrt9)
      aitr(27,ni+i)=aitr(27,ni+i)*sqrt3/(sqrt7*sqrt9)
      aitr(28,ni+i)=aitr(28,ni+i)*sqrt3*sqrt3/(sqrt5*sqrt7*sqrt9)
      go to 4000
 4015 if(i.gt.15) go to 4020
      aitr( 1,ni+i)=aitr( 1,ni+i)*sqrt11*sqrt9/sqrt3
      aitr( 2,ni+i)=aitr( 2,ni+i)*sqrt11*sqrt9/sqrt3
      aitr( 3,ni+i)=aitr( 3,ni+i)*sqrt11*sqrt9/sqrt3
      aitr( 4,ni+i)=aitr( 4,ni+i)*sqrt9/sqrt3
      aitr( 5,ni+i)=aitr( 5,ni+i)*sqrt9/sqrt3
      aitr( 6,ni+i)=aitr( 6,ni+i)*sqrt9/sqrt3
      aitr( 7,ni+i)=aitr( 7,ni+i)*sqrt9/sqrt3
      aitr( 8,ni+i)=aitr( 8,ni+i)*sqrt9/sqrt3
      aitr( 9,ni+i)=aitr( 9,ni+i)*sqrt9/sqrt3
      aitr(16,ni+i)=aitr(16,ni+i)/sqrt3
      aitr(17,ni+i)=aitr(17,ni+i)/sqrt3
      aitr(18,ni+i)=aitr(18,ni+i)/sqrt3
      aitr(19,ni+i)=aitr(19,ni+i)*sqrt5/sqrt7
      aitr(20,ni+i)=aitr(20,ni+i)*sqrt5/sqrt7
      aitr(21,ni+i)=aitr(21,ni+i)*sqrt5/sqrt7
      aitr(22,ni+i)=aitr(22,ni+i)/sqrt7
      aitr(23,ni+i)=aitr(23,ni+i)/sqrt7
      aitr(24,ni+i)=aitr(24,ni+i)/sqrt7
      aitr(25,ni+i)=aitr(25,ni+i)/sqrt7
      aitr(26,ni+i)=aitr(26,ni+i)/sqrt7
      aitr(27,ni+i)=aitr(27,ni+i)/sqrt7
      aitr(28,ni+i)=aitr(28,ni+i)*sqrt3/(sqrt5*sqrt7)
      goto 4000
 4020 if(i.gt.18) go to 4030
      aitr( 1,ni+i)=aitr( 1,ni+i)*sqrt11*sqrt9
      aitr( 2,ni+i)=aitr( 2,ni+i)*sqrt11*sqrt9
      aitr( 3,ni+i)=aitr( 3,ni+i)*sqrt11*sqrt9
      aitr( 4,ni+i)=aitr( 4,ni+i)*sqrt9
      aitr( 5,ni+i)=aitr( 5,ni+i)*sqrt9
      aitr( 6,ni+i)=aitr( 6,ni+i)*sqrt9
      aitr( 7,ni+i)=aitr( 7,ni+i)*sqrt9
      aitr( 8,ni+i)=aitr( 8,ni+i)*sqrt9
      aitr( 9,ni+i)=aitr( 9,ni+i)*sqrt9
      aitr(10,ni+i)=aitr(10,ni+i)*sqrt3
      aitr(11,ni+i)=aitr(11,ni+i)*sqrt3
      aitr(12,ni+i)=aitr(12,ni+i)*sqrt3
      aitr(13,ni+i)=aitr(13,ni+i)*sqrt3
      aitr(14,ni+i)=aitr(14,ni+i)*sqrt3
      aitr(15,ni+i)=aitr(15,ni+i)*sqrt3
      aitr(19,ni+i)=aitr(19,ni+i)*sqrt3*sqrt5/sqrt7
      aitr(20,ni+i)=aitr(20,ni+i)*sqrt3*sqrt5/sqrt7
      aitr(21,ni+i)=aitr(21,ni+i)*sqrt3*sqrt5/sqrt7
      aitr(22,ni+i)=aitr(22,ni+i)*sqrt3/sqrt7
      aitr(23,ni+i)=aitr(23,ni+i)*sqrt3/sqrt7
      aitr(24,ni+i)=aitr(24,ni+i)*sqrt3/sqrt7
      aitr(25,ni+i)=aitr(25,ni+i)*sqrt3/sqrt7
      aitr(26,ni+i)=aitr(26,ni+i)*sqrt3/sqrt7
      aitr(27,ni+i)=aitr(27,ni+i)*sqrt3/sqrt7
      aitr(28,ni+i)=aitr(28,ni+i)*sqrt3*sqrt3/(sqrt5*sqrt7)
      go to 4000
 4030 if(i.gt.21) go to 4040
      aitr( 1,ni+i)=aitr( 1,ni+i)*sqrt7*sqrt9*sqrt11/(sqrt5*sqrt3)
      aitr( 2,ni+i)=aitr( 2,ni+i)*sqrt7*sqrt9*sqrt11/(sqrt5*sqrt3)
      aitr( 3,ni+i)=aitr( 3,ni+i)*sqrt7*sqrt9*sqrt11/(sqrt5*sqrt3)
      aitr( 4,ni+i)=aitr( 4,ni+i)*sqrt7*sqrt9/(sqrt5*sqrt3)
      aitr( 5,ni+i)=aitr( 5,ni+i)*sqrt7*sqrt9/(sqrt5*sqrt3)
      aitr( 6,ni+i)=aitr( 6,ni+i)*sqrt7*sqrt9/(sqrt5*sqrt3)
      aitr( 7,ni+i)=aitr( 7,ni+i)*sqrt7*sqrt9/(sqrt5*sqrt3)
      aitr( 8,ni+i)=aitr( 8,ni+i)*sqrt7*sqrt9/(sqrt5*sqrt3)
      aitr( 9,ni+i)=aitr( 9,ni+i)*sqrt7*sqrt9/(sqrt5*sqrt3)
      aitr(10,ni+i)=aitr(10,ni+i)*sqrt7/sqrt5
      aitr(11,ni+i)=aitr(11,ni+i)*sqrt7/sqrt5
      aitr(12,ni+i)=aitr(12,ni+i)*sqrt7/sqrt5
      aitr(13,ni+i)=aitr(13,ni+i)*sqrt7/sqrt5
      aitr(14,ni+i)=aitr(14,ni+i)*sqrt7/sqrt5
      aitr(15,ni+i)=aitr(15,ni+i)*sqrt7/sqrt5
      aitr(16,ni+i)=aitr(16,ni+i)*sqrt7/(sqrt3*sqrt5)
      aitr(17,ni+i)=aitr(17,ni+i)*sqrt7/(sqrt3*sqrt5)
      aitr(18,ni+i)=aitr(18,ni+i)*sqrt7/(sqrt3*sqrt5)
      aitr(22,ni+i)=aitr(22,ni+i)/sqrt5
      aitr(23,ni+i)=aitr(23,ni+i)/sqrt5
      aitr(24,ni+i)=aitr(24,ni+i)/sqrt5
      aitr(25,ni+i)=aitr(25,ni+i)/sqrt5
      aitr(26,ni+i)=aitr(26,ni+i)/sqrt5
      aitr(27,ni+i)=aitr(27,ni+i)/sqrt5
      aitr(28,ni+i)=aitr(28,ni+i)*sqrt3/(sqrt5*sqrt5)
      go to 4000
 4040 if(i.gt.27) go to 4050
      aitr( 1,ni+i)=aitr( 1,ni+i)*sqrt7*sqrt9*sqrt11/sqrt3
      aitr( 2,ni+i)=aitr( 2,ni+i)*sqrt7*sqrt9*sqrt11/sqrt3
      aitr( 3,ni+i)=aitr( 3,ni+i)*sqrt7*sqrt9*sqrt11/sqrt3
      aitr( 4,ni+i)=aitr( 4,ni+i)*sqrt7*sqrt9/sqrt3
      aitr( 5,ni+i)=aitr( 5,ni+i)*sqrt7*sqrt9/sqrt3
      aitr( 6,ni+i)=aitr( 6,ni+i)*sqrt7*sqrt9/sqrt3
      aitr( 7,ni+i)=aitr( 7,ni+i)*sqrt7*sqrt9/sqrt3
      aitr( 8,ni+i)=aitr( 8,ni+i)*sqrt7*sqrt9/sqrt3
      aitr( 9,ni+i)=aitr( 9,ni+i)*sqrt7*sqrt9/sqrt3
      aitr(10,ni+i)=aitr(10,ni+i)*sqrt7
      aitr(11,ni+i)=aitr(11,ni+i)*sqrt7
      aitr(12,ni+i)=aitr(12,ni+i)*sqrt7
      aitr(13,ni+i)=aitr(13,ni+i)*sqrt7
      aitr(14,ni+i)=aitr(14,ni+i)*sqrt7
      aitr(15,ni+i)=aitr(15,ni+i)*sqrt7
      aitr(16,ni+i)=aitr(16,ni+i)*sqrt7/sqrt3
      aitr(17,ni+i)=aitr(17,ni+i)*sqrt7/sqrt3
      aitr(18,ni+i)=aitr(18,ni+i)*sqrt7/sqrt3
      aitr(19,ni+i)=aitr(19,ni+i)*sqrt5
      aitr(20,ni+i)=aitr(20,ni+i)*sqrt5
      aitr(21,ni+i)=aitr(21,ni+i)*sqrt5
      aitr(28,ni+i)=aitr(28,ni+i)*sqrt3/sqrt5
      go to 4000
 4050 aitr( 1,ni+i)=aitr( 1,ni+i)*sqrt5*sqrt7*sqrt9*sqrt11/(sqrt3*sqrt3)
      aitr( 2,ni+i)=aitr( 2,ni+i)*sqrt5*sqrt7*sqrt9*sqrt11/(sqrt3*sqrt3)
      aitr( 3,ni+i)=aitr( 3,ni+i)*sqrt5*sqrt7*sqrt9*sqrt11/(sqrt3*sqrt3)
      aitr( 4,ni+i)=aitr( 4,ni+i)*sqrt5*sqrt7*sqrt9/(sqrt3*sqrt3)
      aitr( 5,ni+i)=aitr( 5,ni+i)*sqrt5*sqrt7*sqrt9/(sqrt3*sqrt3)
      aitr( 6,ni+i)=aitr( 6,ni+i)*sqrt5*sqrt7*sqrt9/(sqrt3*sqrt3)
      aitr( 7,ni+i)=aitr( 7,ni+i)*sqrt5*sqrt7*sqrt9/(sqrt3*sqrt3)
      aitr( 8,ni+i)=aitr( 8,ni+i)*sqrt5*sqrt7*sqrt9/(sqrt3*sqrt3)
      aitr( 9,ni+i)=aitr( 9,ni+i)*sqrt5*sqrt7*sqrt9/(sqrt3*sqrt3)
      aitr(10,ni+i)=aitr(10,ni+i)*sqrt5*sqrt7/sqrt3
      aitr(11,ni+i)=aitr(11,ni+i)*sqrt5*sqrt7/sqrt3
      aitr(12,ni+i)=aitr(12,ni+i)*sqrt5*sqrt7/sqrt3
      aitr(13,ni+i)=aitr(13,ni+i)*sqrt5*sqrt7/sqrt3
      aitr(14,ni+i)=aitr(14,ni+i)*sqrt5*sqrt7/sqrt3
      aitr(15,ni+i)=aitr(15,ni+i)*sqrt5*sqrt7/sqrt3
      aitr(16,ni+i)=aitr(16,ni+i)*sqrt5*sqrt7/(sqrt3*sqrt3)
      aitr(17,ni+i)=aitr(17,ni+i)*sqrt5*sqrt7/(sqrt3*sqrt3)
      aitr(18,ni+i)=aitr(18,ni+i)*sqrt5*sqrt7/(sqrt3*sqrt3)
      aitr(19,ni+i)=aitr(19,ni+i)*sqrt5*sqrt5/sqrt3
      aitr(20,ni+i)=aitr(20,ni+i)*sqrt5*sqrt5/sqrt3
      aitr(21,ni+i)=aitr(21,ni+i)*sqrt5*sqrt5/sqrt3
      aitr(22,ni+i)=aitr(22,ni+i)*sqrt5/sqrt3
      aitr(23,ni+i)=aitr(23,ni+i)*sqrt5/sqrt3
      aitr(24,ni+i)=aitr(24,ni+i)*sqrt5/sqrt3
      aitr(25,ni+i)=aitr(25,ni+i)*sqrt5/sqrt3
      aitr(26,ni+i)=aitr(26,ni+i)*sqrt5/sqrt3
      aitr(27,ni+i)=aitr(27,ni+i)*sqrt5/sqrt3
 4000 continue
C
  740 CONTINUE
  750 CONTINUE
C
C     ----- PRINT MATRICES IF NPRINT.EQ.5 -----
C
      IF (NPRINT .NE. 5) GO TO 860
      IF (MASWRK) THEN
      WRITE (IW,9028)
      DO 840 IT = 1,NT
      WRITE (IW,9088)
      WRITE (IW,9108) IT
      NP = 3*(IT-1)
      WRITE (IW,9048) (PNAME(J),J = 1,3)
      WRITE (IW,9128)
      DO 760 I = 1,3
  760 WRITE (IW,9068) PNAME(I),(PTR(I,NP+J),J = 1,3)
      WRITE (IW,9008)
      ND = 6*(IT-1)
      WRITE (IW,9048) (DNAME(J),J = 1,6)
      WRITE (IW,9128)
      DO 780 I = 1,6
  780 WRITE (IW,9068) DNAME(I),(DTR(I,ND+J),J = 1,6)
      WRITE (IW,9008)
      NF = 10*(IT-1)
      WRITE (IW,9048) (FNAME(J),J = 1,10)
      WRITE (IW,9128)
      DO 800 I = 1,10
C
  800 WRITE (IW,9068) FNAME(I),(FTR(I,nf+J),J = 1,10)
C
      WRITE (IW,9008)
      NG = 15*(IT-1)
      WRITE (IW,9048) (GNAME(J),J = 1,15)
      WRITE (IW,9128)
      DO 820 I = 1,15
C
  820 WRITE (IW,9068) GNAME(I),(GTR(I,ng+J),J = 1,15)
C
      WRITE (IW,9008)
C
      nh = 21*(it-1)
      write (iw,9048) (hname(j),j = 1,21)
      write (iw,9128)
      do 830 i = 1,21
  830 write (iw,9068) hname(i),(htr(i,nh+j),j = 1,21)
      write (iw,9008)
      ni = 28*(it-1)
      write (iw,9048) (ainame(j),j = 1,28)
      write (iw,9128)
      do 835 i = 1,28
  835 write (iw,9068) ainame(i),(aitr(i,ni+j),j = 1,28)
      write (iw,9008)
C
  840 CONTINUE
      END IF
  860 CONTINUE
C
C     -- WRITE PTR, DTR, FTR, GTR, HTR, AITR ON IDAF --
C
      IF(IREST.LT.1) CALL DAWRIT(IDAF,IODA,PTR,  432, 7,0)
      IF(IREST.LT.1) CALL DAWRIT(IDAF,IODA,DTR, 1728, 8,0)
      IF(IREST.LT.1) CALL DAWRIT(IDAF,IODA,FTR, 4800, 9,0)
      IF(IREST.LT.1) CALL DAWRIT(IDAF,IODA,GTR,10800,10,0)
C
      if(irest.lt.1) call dawrit(idaf,ioda,htr,21168,911,0)
      if(irest.lt.1) call dawrit(idaf,ioda,aitr,37632,912,0)
C
      RETURN
C
 9008 FORMAT(//)
 9028 FORMAT(/,38H TRANSFORMATION OF THE BASIS FUNCTIONS,/)
 9048 FORMAT(7X,15(2X,A4,2X))
 9068 FORMAT(2X,A4,1X,15F8.4)
 9088 FORMAT(1H1)
 9108 FORMAT(/,21X,21HTRANSFORMATION NUMBER,I4,/)
 9128 FORMAT(/)
      END
C*MODULE INPUTB *DECK TIN2GMS
      SUBROUTINE TIN2GMS
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
C    GAMESS
      PARAMETER (MXATM=2000)
      PARAMETER (MAXLNK=100, MAXR1=2000)
      PARAMETER (ONE=1.0D+00)
C
      INTEGER TYPE,TAG,CLASS,ATOMIC,VALENCE
      DOUBLE PRECISION DY,DZ,X,Y,Z,MASS
      CHARACTER*10 NAME,UATOM,XYZNAME
      CHARACTER*20 STORY
      LOGICAL IMOMM,SIMOMM
      DIMENSION ITMPLNK(MAXLNK)
C
      COMMON /COORDN/ UZNUC(MXATM),CUNIQ(MXATM,3),NATREL,UATOM(MXATM)
C
C                   NUMBER OF MM ATOMS IS -MAXATM-
C             THIS VALUE IS CONTROLLED BY A "SED-HACK", SO DO NOT
C             HAND-EDIT HERE, RATHER HAND-EDIT IN 'COMP', AND ALSO
C             HAND-EDIT TINKER'S SIZES.I INCLUDE FILE, AND RECOMPILE
C             INPUTB/QMMM/FMOGRD ALONG WITH TINKER.
      PARAMETER (MAXATM=10)
      COMMON /ATMTYP/ MASS(MAXATM),TAG(MAXATM),CLASS(MAXATM),
     *                ATOMIC(MAXATM),VALENCE(MAXATM),NAME(MAXATM),
     *                STORY(MAXATM), XYZNAME(MAXATM)
      COMMON /ATOMST/ X(MAXATM),Y(MAXATM),Z(MAXATM),N,TYPE(MAXATM)
C
      COMMON /QMMM1/ IMOMM,SIMOMM,NPAIR,NSEQ
      COMMON /QMMM2/ IQMATM(MAXR1),IBASFMO(MAXR1)
      COMMON /QMMM3/ LINKGE(3*MAXLNK),BLQM(MAXLNK),BLMM(MAXLNK)
C
C     TITLE CARD
C     TITLE(1)=TTITLE
C     TOTAL NUMBER OF QUANTUM ATOMS
C
      NATREL=NSEQ+NPAIR
C
C     ASSIGN CHARGE, CARTESIAN COORDINATES AND ATOM NAME OF QM ATOMS
C
      DO I=1,NSEQ
        UZNUC(I)=ATOMIC(IQMATM(I))
        CUNIQ(I,1)=X(IQMATM(I))
        CUNIQ(I,2)=Y(IQMATM(I))
        CUNIQ(I,3)=Z(IQMATM(I))
        UATOM(I)=NAME(IQMATM(I))
      ENDDO
C
C     DANGLING BONDS ARE REPLACED BY HYDROGENS
C
      DO I=1,NPAIR
         LR1=LINKGE(3*I-2)
         LR2=LINKGE(3*I  )
         DX=(X(LR2)-X(LR1))
         DY=(Y(LR2)-Y(LR1))
         DZ=(Z(LR2)-Z(LR1))
         TDIST=SQRT(DX**2+DY**2+DZ**2)
         DO J=1,NSEQ
            IF (LR1.EQ.IQMATM(J)) ITMPLNK(I)=J
         ENDDO
         ZAN1 = ATOMIC(LR1)
         CALL GTDIST(ZAN1,ONE,RDIST)
         UZNUC(I+NSEQ)=ONE
         UATOM(I+NSEQ)='H         '
         CUNIQ(I+NSEQ,1)=X(LR1)+DX*RDIST/TDIST
         CUNIQ(I+NSEQ,2)=Y(LR1)+DY*RDIST/TDIST
         CUNIQ(I+NSEQ,3)=Z(LR1)+DZ*RDIST/TDIST
      ENDDO
      UATOM(NSEQ+NPAIR+1)='$END      '
C
C     ASSIGN LINKGE VALUES
C
      DO I=1,NPAIR
         LINKGE(I*3-2)=ITMPLNK(I)
      ENDDO
C
      RETURN
      END
C*MODULE INPUTB  *DECK FLIPBASIS
      SUBROUTINE FLIPBASIS(NREC)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMMON /FMCOM / XX(1)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      PARAMETER (MXSH=5000, MXGTOT=20000)
C
C          ALLOCATE MEMORY TO RESTORE A BASIS SET FROM DAF
C
      CALL VALFM(LOADFM)
      LCC  = LOADFM + 1
      LKK  = LCC    + MXGTOT*6
      LAST = LKK    + (7*MXSH+1)/NWDVAR + 1
      NEED = LAST - LOADFM -1
      CALL GETFM(NEED)
      CALL FLIPB2(NREC,XX(LCC),XX(LKK),MXGTOT,MXSH)
      CALL RETFM(NEED)
      RETURN
      END
C*MODULE INPUTB  *DECK FLIPB2
      SUBROUTINE FLIPB2(NREC,CC,KK,MAXGTOT,MAXSH)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXSH=5000, MXGTOT=20000)
C
      DIMENSION CC(MAXGTOT*6),KK(MAXSH*7+1)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /RELWFN/ RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,IQRORD,MODQR,NESOC,
     *                NRATOM,NUMU,NQMTR,NQRDAF,MORDA,NDARELB
C
      DATA RNONE/8HNONE    /
C
C     READ IN THE BASIS SET
C
      NCOEF=MXGTOT
      NN=5
      IF(RMETHOD.NE.RNONE.AND.MOD(MODQR,2).EQ.1) NN=6
C
      CALL DAREAD(IDAF,IODA,CC,NCOEF*NN,NREC+NDARELB,0)
      CALL DCOPY(NCOEF,CC(        1),1,CS,1)
      CALL DCOPY(NCOEF,CC(  NCOEF+1),1,CP,1)
      CALL DCOPY(NCOEF,CC(2*NCOEF+1),1,CD,1)
      CALL DCOPY(NCOEF,CC(3*NCOEF+1),1,CF,1)
      CALL DCOPY(NCOEF,CC(4*NCOEF+1),1,CG,1)
C
      IF(RMETHOD.NE.RNONE.AND.MOD(MODQR,2).EQ.1) THEN
         CALL DCOPY(NCOEF,CC(5*NCOEF+1),1,EX,1)
         NK=MXSH
         CALL DAREAD(IDAF,IODA,KK,(NK*7+1)/NWDVAR+1,NDARELB+NREC+1,1)
         CALL ICOPY(NK,KK(1     ),1,KSTART,1)
         CALL ICOPY(NK,KK(1+  NK),1,KATOM,1)
         CALL ICOPY(NK,KK(1+2*NK),1,KTYPE,1)
         CALL ICOPY(NK,KK(1+3*NK),1,KNG,1)
         CALL ICOPY(NK,KK(1+4*NK),1,KLOC,1)
         CALL ICOPY(NK,KK(1+5*NK),1,KMIN,1)
         CALL ICOPY(NK,KK(1+6*NK),1,KMAX,1)
         NSHELL=       KK(1+7*NK)
      ENDIF
      RETURN
      END
C*MODULE INPUTB  *DECK RWFINP
      SUBROUTINE RWFINP
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXATM=2000)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /BASSPH/ QMTTOL,ISPHER
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,ITYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RELWFN/ RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,IQRORD,MODQR,NESOC,
     *                NRATOM,NUMU,NQMTR,NQRDAF,MORDA,NDARELB
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
C              $RELWFN NAMELIST INFORMATION
C
      PARAMETER (NNAM=9)
      DIMENSION KQNAM(NNAM),QNAM(NNAM),CHARGE(MXATM)
      DATA RELWFN/8HRELWFN  /
      DATA KQNAM/1,-3,1,3,1,3,3,1,1/
      DATA QNAM/8HNRATOM  ,8HCHARGE  ,8HNESOC   ,8HQMTTOL  ,8HMODEQR  ,
     *          8HQRTOL   ,8HCLIGHT  ,8HNORDER  ,8HNVIB    /
C
      DATA RESC,ANESC,DK/8HRESC    ,8HNESC    ,8HDK      /
      DATA RIOTC/8HIOTC    /
      DATA TRANST/8HTRANSITN/
C
C     ----- RELATIVISTIC WAVEFUNCTION INPUT -----
C     DATA FOR NAKAJIMA/HIRAO'S -RESC-
C                    OR DYALL'S -NESC-
C         OR DOUGLAS/KROLL/HESS -DK- METHODOLOGIES
C         OR IOTC METHOD
C
C     DICTIONARY FILE WILL BE USED, FROM RECORD NDARELB AND FURTHER
C
      NDARELB=370
C
      CLIG=137.0359895D+00
C
      KQNAM(2) = 10*NAT + 3
      NRATOM=0
      NESOC=0
      MODQR=1
      IF(ISPHER.GT.0) MODQR=MODQR+2
      NVIB=2
C
C     ADDITIVE OPTIONS FOR RESC AND DK
C     1 - TURN ON INTERNAL UNCONTRACTED BASIS
C     2 - HONDO STYLE INTERNAL UNCONTRACTION RI (ISPHER=1 TYPE)
C         INTERNALLY UNCONTRACTED OPTION ELIMINATES SPHERICAL
C         CONTAMINANTS BUT DOES NOT USE SYMMETRY IN CONSTRUCTION OF
C         RIS (IN THE CONTRACTED CASE IT DOES).
C         RESC GRADIENT CANNOT RUN WITH THIS OPTION SET.
C         IT IS RECOMMENDED THAT ISPHER=1 BE ALWAYS USED WITH THIS BIT
C         OF MODQR SET TO 1.
C     4 - L-SHELL TO BE SPLIT INTO S AND P IN THE UNCONTRACTION
C     8 - USE QUADRUPLE PRECISION (128 BIT) FOR RIS IF AVAILABLE
C         (OTHERWISE USE DOUBLE PRECISION).
C
C     65536 - IS NOT AN INPUT OPTION, BUT A WAY TO PASS NVIB
C         (NVIB=1: 1; NVIB=2: 0).
C    131072 - IS NOT AN INPUT OPTION, BUT A WAY TO PASS CARTESIAN MODE
C
      IQRORD=2
C
C     ORDER OF THE RELATIVISTIC APPROXIMATION, CURRENTLY ONLY
C     USED FOR DK, POSSIBLE VALUES: 1,2,3.
C     NOTE THAT 1 CORRESPONDS TO THE FREE PARTICLE.
C     RESC HAS THIS VALUE EQUAL TO 2 FIXED IN THIS IMPLEMENTATION.
C     (SECRET CODE/RESULTS FOR HIGHER ORDERS MAY EXIST ELSEWHERE).
C
      IF(RUNTYP.EQ.TRANST) NESOC=-1
      QRQMT=QMTTOL
      QRTOL=0.0D+00
C
      JRET = 0
      CALL NAMEIO(IR,JRET,RELWFN,NNAM,QNAM,KQNAM,
     *            NRATOM,CHARGE,NESOC,QRQMT,MODQR,QRTOL,
     *            CLIG,IQRORD,NVIB,   0,0,0,0,0,
     *   0,0,0,0,0,   0,0,0,0,0,
     *   0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,
     *   0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0)
      IF(JRET.GT.1) THEN
         IF (MASWRK) WRITE(IW,9000) RELWFN
         CALL ABRT
      END IF
C
C     ORDER MUST BE 2 FOR IOTC
C
      IF(RMETHOD.EQ.RIOTC) IQRORD=2
C
      CLIG2=CLIG*CLIG
      IF(RMETHOD.EQ.RESC.OR.RMETHOD.EQ.DK) THEN
         IF(MOD(MODQR,2).EQ.1.AND.NESOC.EQ.2) NESOC=1
         IF(NESOC.LT.0) NESOC=2
      ENDIF
      IF(RMETHOD.EQ.ANESC.AND.NESOC.LT.0) NESOC=1
C
C     DIMA SAYS "TOBY (IN MARIUSZ' GROUP) FOUND THIS TO BE DEFINITELY
C     WRONG FOR DK AND I THINK IT IS WRONG FOR RESC AS WELL.  WHAT
C     IS DISTURBING IS THAT THE ORDER IN THE SPEED OF LIGHT IS WRONG
C     FOR THE 2E SOC TRANSFORMATION, IT IS JUST THAT THE EFFECT IS
C     FAIRLY SMALL, SO THAT NO NUMERIC DISASTER SHOWS UP."
C
C     PENDING FIXING THIS OPTION, DISALLOW NESOC=2.
C     HERE WE SAVE SOME WORDS FROM THE ORIGINAL INPUT.DOC, THAT
C     DESCRIBE THE LOGIC ABOVE, AND WHAT NESOC=2 WAS MEANT TO DO:
C NESOC = 2 ONE AND TWO-ELECTRON SPIN-ORBIT INTEGRALS
C           (DK AND RESC DEFAULT).  THIS IS NOT PROGRAMMED
C           FOR RESC WITH INTERNAL UNCONTRACTION (MODEQR=1),
C           SO THE PROGRAM IN THIS CASE WILL RESET NESOC=1.
C     FOR RELWFN=RESC OR NESC, RELATIVISTIC SOC CORRECTIONS
C     CORRESPOND TO THE SAME ORDER AS THE SPIN-FREE HAMILTONIAN
C     TRANSFORMATION, THAT IS, TO SECOND ORDER.  FOR RELWFN=DK, NO
C     MATTER WHAT NORDER IS, SOC CORRECTIONS ARE OBTAINED FROM THE
C     SPIN-DEPENDENT DK TRANSFORMATION AT 1ST ORDER.
C
      IF(NESOC.EQ.2) NESOC=1
C
      IF(RMETHOD.EQ.RESC.AND.QRTOL.EQ.0.0D+00) QRTOL=MIN(1.0D-08,QRQMT)
      IF(RMETHOD.EQ.DK.AND.QRTOL.EQ.0.0D+00) QRTOL=0.01D+00
      IF(RMETHOD.EQ.RIOTC.AND.QRTOL.EQ.0.0D+00) QRTOL=0.01D+00
C     NO INTERNAL UNCONTRACTION FOR NESC
      IF(RMETHOD.EQ.ANESC) MODQR=0
      IF(MOD(MODQR,3).EQ.3.AND.ISPHER.NE.1) THEN
         IF (MASWRK) WRITE(IW,9420)
         CALL ABRT
      END IF
      IF(MOD(MODQR/2,2).EQ.1.AND.ISPHER.NE.1) THEN
         IF (MASWRK) WRITE(IW,9425)
C        THE CODE WILL RUN, DON'T ABORT
C--      CALL ABRT
      END IF
      IF(NVIB.LT.0) THEN
         MODQR=IOR(MODQR,131072)
         NVIB=-NVIB
      ENDIF
      IF(NVIB.NE.1.AND.NVIB.NE.2) THEN
         IF (MASWRK) WRITE(IW,9430)
         CALL ABRT
      END IF
      IF(NVIB.EQ.1) MODQR=IOR(MODQR,65536)
C
      IF(MASWRK) WRITE(IW,9300) RMETHOD,IQRORD,NESOC,MODQR,NRATOM,
     *                          QRQMT,QRTOL,CLIG
C
C        NO GRADIENT FOR HONDO OPTION AT PRESENT, AND PROBABLY NEVER,
C        SO INSTEAD WE FORCE A DIFFERENT -MODQR-
C
      CALL DERCHK(NDER)
      IF(RMETHOD.EQ.RESC.AND.NDER.GT.0.AND.MOD(MODQR/2,2).EQ.1) THEN
         WRITE(IW,9410)
         MODQR=MODQR-2
      END IF
C
C         CHECK TO SEE IF MACHINE HAS TRUE QUADRUPLE PRECISION
C         THIS ROUTINE KILLS THE JOB IF Q.P. IS NOT AVAILABLE
C
      IF(MOD(MODQR/8,2).NE.0) CALL IQTEST(.TRUE.)
C
      IRAREC=NDARELB+21
      IF(RMETHOD.EQ.ANESC) THEN
         IRAREC=NDARELB+5
         IF(MASWRK) WRITE(IW,9500)
      ENDIF
      IF(NRATOM.GT.0) CALL DAWRIT(IDAF,IODA,CHARGE,NRATOM,IRAREC,0)
C
      RETURN
C
 9000 FORMAT(1X,'**** ERROR IN ',A8,' GROUP...PLEASE FIX IT.')
 9300 FORMAT(/5X,33(1H-)/5X,'RELATIVISTIC WAVEFUNCTION OPTIONS',
     *       /5X,33(1H-)/5X,'METHOD=',A8,' NORDER=',I2,6X,' NESOC= ',I2,
     *      6X,'MODEQR=',I7/5X,'NRATOM=',I3,6X,'QMTTOL=',1P,E10.3,0P,
     *      6X,'QRTOL=',1P,E10.3,0P/5X,'CLIGHT=',F12.8)
 9410 FORMAT(1X,'NO ANALYTICAL GRADIENT FOR HONDO STYLE RI FORCES',
     *          'THE LATTER OFF.',/)
 9420 FORMAT(1X,'ISPHER.NE.1 AND MOD(MODQR,3)=3 ARE INCOMPATIBLE.',/)
 9425 FORMAT(1X,'USING ISPHER.NE.1 AND THE HONDO OPTION IS DISCOURAGED')
 9430 FORMAT(1X,'NVIB CAN BE 1 OR 2'/)
 9500 FORMAT(1X,'AO NON-RELATIVISTIC NORMALISATION WILL BE OMITTED.')
      END
C*MODULE INPUTB  *DECK RELSAVE
      SUBROUTINE RELSAVE(NREC)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXATM=2000, MXGTOT=20000)
      COMMON /FMCOM / XX(1)
C
C          ALLOCATE MEMORY TO SAVE A BASIS SET ON DAF
C
      CALL VALFM(LOADFM)
      LCC  = LOADFM + 1
      LCC0 = LCC    + MXGTOT*5
      LEX0 = LCC0   + MXGTOT*5
      LCHG = LEX0   + MXGTOT
      LZN0 = LCHG   + MXATM
      LC0  = LZN0   + MXATM
      LAST = LC0    + MXATM*3
      NEED = LAST - LOADFM -1
      CALL GETFM(NEED)
      CALL RELSV1(NREC,XX(LCC0),XX(LCC),XX(LEX0),XX(LCHG),
     *            XX(LZN0),XX(LC0),MXGTOT,MXATM)
      CALL RETFM(NEED)
      RETURN
      END
C*MODULE INPUTB  *DECK RELSV1
      SUBROUTINE RELSV1(NREC,CC0,CC,EX0,CHARGE,ZAN0,C0,MAXGTOT,MAXATM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXSH=5000, MXGTOT=20000)
      PARAMETER (ONE=1.0D+00)
C
      CHARACTER*1 SYMB
C
      DIMENSION CC0(MAXGTOT,5),CC(MAXGTOT,5),EX0(MAXGTOT),
     *          CHARGE(MAXATM),ZAN0(MAXATM),C0(3,MAXATM)
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /RELWFN/ RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,IQRORD,MODQR,NESOC,
     *                NRATOM,NUMU,NQMTR,NQRDAF,MORDA,NDARELB
C
      NCOEF=MAXGTOT
C
C    THE ORDER OF CALLS IS IMPORTANT. IT MUST BE NREC=4,0,3
C
C     THE ORDER OF THE RECORDS IS (RELATIVE TO NDARELB):
C
C     THESE ARE USED BY METHOD=NESC
C
C     0: A (LARGE COMPONENT)
C     1: B (SMALL COMPONENT) <- ZEROS FOR NON-RELATIVISTIC ATOMS
C     2: A-B1
C     3: N (RELATIVISTICALLY NORMALISED LARGE COMPONENT)
C     4: B1 (SMALL COMPONENT) <- LARGE COMPONENT FOR NON-RELVSTIC ATOMS
C
C     5: CHARGES OF ATOMS TO BE TREATED NON-RELATIVISTICALLY
C     6: ZAN, FROM INFOA FOR INTERNAL CHECK
C     7: C, FROM INFOA FOR INTERNAL CHECK
C     8: EX, FROM NSHEL FOR INTERNAL CHECK
C
C     THESE ARE USED BY METHOD=RESC
C
C     0: LEFT TRANSFORMATION MATRIX OQ
C     1: RIGHT TRANSFORMATION MATRIX Q(O**-1)
C     BOTH ARE USED TO TRANSFORM SOC INTEGRALS
C
C     PERFORM INTERNAL CHECK FOR CONSISTENCY OF THE THREE $DATA GROUPS
C
      IF(NREC.EQ.4) THEN
         CALL DAWRIT(IDAF,IODA,ZAN ,NAT   ,NDARELB+6,0)
         CALL DAWRIT(IDAF,IODA,C   ,3*NAT ,NDARELB+7,0)
         CALL DAWRIT(IDAF,IODA,EX  ,NSHELL,NDARELB+8,0)
      ELSE
         CALL DAREAD(IDAF,IODA,ZAN0,NAT   ,NDARELB+6,0)
         CALL DAREAD(IDAF,IODA,C0  ,3*NAT ,NDARELB+7,0)
         CALL DAREAD(IDAF,IODA,EX0 ,NSHELL,NDARELB+8,0)
         IZAN=KOMVEC(NAT   ,1.0D-06,ZAN,ZAN0,1)
         IC=  KOMVEC(NAT*3 ,1.0D-06,C  ,C0  ,1)
         IEX= KOMVEC(NSHELL,1.0D-06,EX ,EX0 ,1)
         SYMB='?'
         IF(NREC.EQ.3) SYMB=' '
         IF(NREC.EQ.0) SYMB='L'
         IF(IZAN.NE.0) THEN
            WRITE(IW,9000) SYMB,IZAN
            CALL ABRT
         ENDIF
         IF(IC.NE.0) THEN
            WRITE(IW,9100) SYMB,IC
            CALL ABRT
         ENDIF
         IF(IEX.NE.0) THEN
            WRITE(IW,9200) SYMB,IEX
            CALL ABRT
         ENDIF
      ENDIF
      CALL DCOPY(NCOEF,CS,1,CC(1,1),1)
      CALL DCOPY(NCOEF,CP,1,CC(1,2),1)
      CALL DCOPY(NCOEF,CD,1,CC(1,3),1)
      CALL DCOPY(NCOEF,CF,1,CC(1,4),1)
      CALL DCOPY(NCOEF,CG,1,CC(1,5),1)
      CALL DAWRIT(IDAF,IODA,CC,NCOEF*5,NDARELB+NREC,0)
      IF(NREC.EQ.0) THEN
C        SMALL COMPONENT IS TO BE SUBSTRACTED FROM LARGE AND SAVED
C        SMALL MUST HAVE ALREADY BEEN SAVED!
C        CALL RELSAVE(0) LAST.
C        WRITE(6,*) NRATOM,'LARGE',CC
         IF(NRATOM.GT.0)
     *      CALL DAREAD(IDAF,IODA,CHARGE,NRATOM,NDARELB+5,0)
         CALL DAREAD(IDAF,IODA,CC0,NCOEF*5,NDARELB+4,0)
         CALL DAXPY(NCOEF*5,-ONE,CC0,1,CC,1)
         CALL DAWRIT(IDAF,IODA,CC ,NCOEF*5,NDARELB+2,0)
C
C        ZERO OUT SMALL COMPONENT FOR NON-RELATIVISTIC ATOMS
C
         IND=1
         DO 900 II=1,NSHELL
            DO 800 I=1,KNG(II)
               DO 700 IAT=1,NRATOM
                  IF(ABS(ZAN(KATOM(II))-CHARGE(IAT)).LT.1.0D-02)
     *               CALL VCLR(CC0(IND,1),MXGTOT,5)
  700          CONTINUE
               IND=IND+1
  800       CONTINUE
  900    CONTINUE
         CALL DAWRIT(IDAF,IODA,CC0,NCOEF*5,NDARELB+1,0)
      ENDIF
      RETURN
 9000 FORMAT(1X,    'NUCLEAR CHARGES IN $DATA',A1,' AND $DATAS ',
     *         'MISMATCH, ELEMENT',I4,/)
 9100 FORMAT(1X, 'ATOMIC COORDINATES IN $DATA',A1,' AND $DATAS ',
     *         'MISMATCH, ELEMENT',I4,/)
 9200 FORMAT(1X,'PRIMITIVE EXPONENTS IN $DATA',A1,' AND $DATAS ',
     *         'MISMATCH, ELEMENT',I4,/)
      END
C*MODULE INPUTB  *DECK RELSAVEU
      SUBROUTINE RELSAVEU(NREC,EX,CS,CP,CD,CF,CG,KSTART,KATOM,KTYPE,KNG,
     *                    KLOC,KMIN,KMAX,NSHELL)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXSH=5000, MXGTOT=20000)
      DIMENSION EX(*),CS(*),CP(*),CD(*),CF(*),CG(*),KSTART(*),KATOM(*),
     *          KTYPE(*),KNG(*),KLOC(*),KMIN(*),KMAX(*)
      COMMON /FMCOM / XX(1)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
C
C          ALLOCATE MEMORY TO SAVE A BASIS SET ON DAF
C
      CALL VALFM(LOADFM)
      LCC  = LOADFM + 1
      LKK  = LCC    + MXGTOT*6
      LAST = LKK    + (7*MXSH+1)/NWDVAR + 1
      NEED = LAST - LOADFM -1
      CALL GETFM(NEED)
      CALL RELSV2(NREC,EX,CS,CP,CD,CF,CG,KSTART,KATOM,KTYPE,KNG,
     *            KLOC,KMIN,KMAX,NSHELL,XX(LCC),XX(LKK),MXGTOT,MXSH)
      CALL RETFM(NEED)
      RETURN
      END
C*MODULE INPUTB  *DECK RELSV2
      SUBROUTINE RELSV2(NREC,EX,CS,CP,CD,CF,CG,KSTART,KATOM,KTYPE,KNG,
     *                  KLOC,KMIN,KMAX,NSHELL,CC,KK,MAXGTOT,MAXSH)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION CC(MAXGTOT,6),KK(MAXSH*7+1),
     *          EX(*),CS(*),CP(*),CD(*),CF(*),CG(*),KSTART(*),KATOM(*),
     *          KTYPE(*),KNG(*),KLOC(*),KMIN(*),KMAX(*)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /RELWFN/ RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,IQRORD,MODQR,NESOC,
     *                NRATOM,NUMU,NQMTR,NQRDAF,MORDA,NDARELB
C
      NCOEF = MAXGTOT
C
      CALL DCOPY(NCOEF,CS,1,CC(1,1),1)
      CALL DCOPY(NCOEF,CP,1,CC(1,2),1)
      CALL DCOPY(NCOEF,CD,1,CC(1,3),1)
      CALL DCOPY(NCOEF,CF,1,CC(1,4),1)
      CALL DCOPY(NCOEF,CG,1,CC(1,5),1)
      CALL DCOPY(NCOEF,EX,1,CC(1,6),1)
      CALL DAWRIT(IDAF,IODA,CC,NCOEF*6,NDARELB+NREC,0)
C
      NK=MAXSH
C
      CALL ICOPY(NK,KSTART,1,KK(1     ),1)
      CALL ICOPY(NK,KATOM ,1,KK(1+  NK),1)
      CALL ICOPY(NK,KTYPE ,1,KK(1+2*NK),1)
      CALL ICOPY(NK,KNG   ,1,KK(1+3*NK),1)
      CALL ICOPY(NK,KLOC  ,1,KK(1+4*NK),1)
      CALL ICOPY(NK,KMIN  ,1,KK(1+5*NK),1)
      CALL ICOPY(NK,KMAX  ,1,KK(1+6*NK),1)
      KK(1+7*NK)=NSHELL
      CALL DAWRIT(IDAF,IODA,KK,(NK*7+1)/NWDVAR+1,NDARELB+NREC+1,1)
C
      RETURN
      END
C*MODULE INPUTB  *DECK BUNCON
C>
C>    @brief   set up uncontracted form of the basis set
C>
C>    @details set up internally uncontracted basis set
C>             used for relativistic RI integral approximations.
C>
C>    @author  Dmitri Fedorov, circa 2001
C>
      SUBROUTINE BUNCON(MAXGTOT,MAXSH,EXU,CSU,CPU,CDU,CFU,CGU,
     *                  KSTARTU,KATOMU,KTYPEU,KNGU,KLOCU,KMINU,KMAXU,
     *                  MAPLE,LARCH,ELM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,ADDPRIM,ADDSHELL,COPYSHELL,
     *        LSHELL,DEBUG
C
      DIMENSION EXU(MAXGTOT),CSU(MAXGTOT),CPU(MAXGTOT),CDU(MAXGTOT),
     *          CFU(MAXGTOT),CGU(MAXGTOT),
     *          KSTARTU(MAXSH),KATOMU(MAXSH),KTYPEU(MAXSH),
     *          KNGU(MAXSH),KLOCU(MAXSH),KMINU(MAXSH),KMAXU(MAXSH),
     *          MAPLE(MAXGTOT),LARCH(MAXGTOT)
      INTEGER ELM(MAXGTOT)
C
      PARAMETER (MXATM=2000, MXSH=5000, MXGTOT=20000)
C
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RELWFN/ RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,IQRORD,MODQR,NESOC,
     *                NRATOM,NUMU,NQMTR,NQRDAF,MORDA,NDARELB
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                T(432),INVT(48),NT
C
      PARAMETER (TINY=1.0D-10,ZERO=0.0D+00, ONE=1.0D+00, HALF=0.5D+00,
     *           PT75=0.75D+00, PT187=1.875D+00, PT6562=6.5625D+00)
C
      PI = ACOS(-ONE)
      PI32 = PI * SQRT(PI)
      L1=NUM
      LU1=0
      DO I=1,NSHELL
         LU1=LU1+(KMAX(I)-KMIN(I)+1)*KNG(I)
      ENDDO
      CALL VALFM(LOADFM)
      LUU     = LOADFM  + 1
      LUU1    = LUU     + L1*LU1
      LCHARGE = LUU1    + LU1*L1
      LAST    = LCHARGE + NRATOM
      NEED = LAST-LOADFM-1
      CALL GETFM(NEED)
C
      CALL VCLR(X(LUU),1,LU1*L1)
      CALL VICLR(MAPLE,1,MXGTOT)
      CALL VICLR(ELM,1,MXGTOT)
C
      LUNCON=MOD(MODQR/4,2)
      IRAREC=NDARELB+21
      IF(NRATOM.GT.0) CALL DAREAD(IDAF,IODA,X(LCHARGE),NRATOM,IRAREC,0)
      NREDUN=0
      NCOPIED=0
      NGHOST=0
      NUMU=0
      NSHELLU=0
      INDU=0
      KLOCU0=0
      KMM=1
C
      DO 200 I=1,NSHELL
        COPYSHELL=.FALSE.
        DO IAT=1,NRATOM
           IF(ABS(X(LCHARGE-1+IAT)-ZAN(KATOM(I))).LT.1.0D-08) THEN
              COPYSHELL=.TRUE.
              GO TO 90
           ENDIF
        ENDDO
   90   CONTINUE
        IF(COPYSHELL) THEN
C
C         ---- ADD NEW SHELL WITHOUT UNCONTRACTION
C
          NCOPIED=NCOPIED+1
          IND=KSTART(I)
          NEXP=INDU+1
          NSHELLU=NSHELLU+1
          DO J=1,KNG(I)
            MAPLE(IND+J-1)=NEXP+J-1
            LARCH(INDU+J-1)=NSHELLU
C           LARCH IS SEMI-BOGUS BUT IT SHOULN'T BE REQUESTED HENCE
          ENDDO
          KSTARTU(NSHELLU)=NEXP
          KATOMU(NSHELLU)=KATOM(I)
          KTYPEU(NSHELLU)=KTYPE(I)
          KNGU(NSHELLU)=KNG(I)
          KLOCU(NSHELLU)=KMM+KLOCU0
          KMINU(NSHELLU)=KMIN(I)
          KMAXU(NSHELLU)=KMAX(I)
          KLOCU0=KLOCU(NSHELLU)
          KMM=KMAXU(NSHELLU)-KMINU(NSHELLU)+1
          NUMU=NUMU+KMM
          CALL DCOPY(KNG(I),EX(IND),1,EXU(NEXP),1)
          CALL DCOPY(KNG(I),CS(IND),1,CSU(NEXP),1)
          CALL DCOPY(KNG(I),CP(IND),1,CPU(NEXP),1)
          CALL DCOPY(KNG(I),CD(IND),1,CDU(NEXP),1)
          CALL DCOPY(KNG(I),CF(IND),1,CFU(NEXP),1)
          CALL DCOPY(KNG(I),CG(IND),1,CGU(NEXP),1)
          INDU=INDU+KNG(I)
          DO K=0,KMAX(I)-KMIN(I)
            X(LUU-1+ (KLOCU(NSHELLU)+K -1)*L1 + KLOC(I)+K)=ONE
          ENDDO
          GO TO 200
        ENDIF
C       LLOOP SPLITS L-SHELLS IN THE INTERNALLY UNCONTRACTED BASI SET
        LSHELL=KTYPE(I).EQ.2.AND.KMIN(I).EQ.1
        LOOPS=LUNCON
        IF(.NOT.LSHELL) LOOPS=0
        DO J=1,KNG(I)
          IND=J-1+KSTART(I)
        DO 190 LLOOP=0,LOOPS
          NEXP=INDU+1
          IF(LUNCON.NE.0.AND.LSHELL) THEN
            IF(LLOOP.EQ.0) THEN
              CSSAVE=CS(IND)
              CPSAVE=CP(IND)
              KTYPE(I)=1
              KMIN(I)=1
              KMAX(I)=1
              CP(IND)=ZERO
              IF(ABS(CSSAVE).LT.TINY) THEN
C                DO NOT ADD PRIMITIVES WITH ZERO COEFFICIENTS
                 NGHOST=NGHOST+1
                 GO TO 190
              ENDIF
            ENDIF
            IF(LLOOP.EQ.1) THEN
              KTYPE(I)=2
              KMIN(I)=2
              KMAX(I)=4
              CS(IND)=ZERO
              CP(IND)=CPSAVE
              IF(ABS(CPSAVE).LT.TINY) THEN
                 NGHOST=NGHOST+1
                 GO TO 190
              ENDIF
            ENDIF
          ENDIF
          ADDPRIM=.TRUE.
          ADDSHELL=.TRUE.
          DO IT=1,NT
C         SEARCH IF THE SHELL IS A COPY OF A SYMMETRY UNIQUE ONE
            IF(MAPSHL(I,IT).LT.I) THEN
              NEXP=MAPLE(J-1+KSTART(MAPSHL(I,IT)))
              ADDPRIM=.FALSE.
              IF(NEXP.LT.0) THEN
                ADDSHELL=.FALSE.
                II=LARCH(NEXP)
                NEXP=-NEXP
              ENDIF
              NEXP=NEXP+LLOOP
C             MAPLE POINTED TO S SHELL, AND P COMES NEXT
              GO TO 100
            ENDIF
          ENDDO
  100     CONTINUE
          DO K=1,NSHELLU
C         SEARCH IF THE PRIMITIVE HAS ALREADY BEEN STORED
            IF(ABS(EX(IND)-EXU(KSTARTU(K))).LT.1.0D-08.AND.
     *         (KMIN(I).EQ.KMINU(K).OR.KMAX(I).EQ.KMAXU(K)).AND.
     *         KATOM(I).EQ.KATOMU(K)) THEN
              NEXP=KSTARTU(K)
              II=K
              ADDPRIM=.FALSE.
              ADDSHELL=.FALSE.
              GO TO 110
            ENDIF
          ENDDO
  110     CONTINUE
C
C         MAPLE MAPS THE CONTRACTED PRIMITIVES INTO UNCONTRACTED
C         POSITIVE INDICATES THAT THE PRIMITIVE NEEDS TO BE ADDED FOR
C         SYMMETRY RELATED ATOMS.
C
          IF(ADDSHELL) THEN
C
C           ---- ADD NEW UNCONTRACTED SHELL
C
            IF(LLOOP.EQ.0) MAPLE(IND)=NEXP
C           FOR L-SHELLS MAPLE POINTS TO S SHELL. P ALWAYS COMES NEXT.
            NSHELLU=NSHELLU+1
            KSTARTU(NSHELLU)=NEXP
            KATOMU(NSHELLU)=KATOM(I)
            KTYPEU(NSHELLU)=KTYPE(I)
            KNGU(NSHELLU)=1
            KLOCU(NSHELLU)=KMM+KLOCU0
            KMINU(NSHELLU)=KMIN(I)
            KMAXU(NSHELLU)=KMAX(I)
            KLOCU0=KLOCU(NSHELLU)
            KMM=KMAXU(NSHELLU)-KMINU(NSHELLU)+1
            NUMU=NUMU+KMM
            II=NSHELLU
            IF(ADDPRIM) THEN
C
C           --- ADD NEW UNCONTRACTED PRIMITIVE
C
              INDU=INDU+1
C             LARCH CONTAINS THE NUMBER OF THE SHELL FOR A PRIMITIVE
              LARCH(INDU)=NSHELLU
              EXU(INDU)=EX(IND)
              CSU(INDU)=ZERO
              CPU(INDU)=ZERO
              CDU(INDU)=ZERO
              CFU(INDU)=ZERO
              CGU(INDU)=ZERO
C
C                 IF PRIMITIVE COEFFICIENTS ARE NORMALISED ONES
              IF(NORMP .NE. 1) THEN
                EE = EX(IND)+EX(IND)
                FACS = PI32/(EE*SQRT(EE))
                FACP = HALF*FACS/EE
                FACD = PT75*FACS/(EE*EE)
                FACF = PT187*FACS/(EE**3)
                FACG = PT6562*FACS/(EE**4)
              END IF
C
              IF(KTYPEU(INDU).EQ.1) THEN
                 IF(NORMP .NE. 1) THEN
                    CSU(INDU) = ONE/SQRT(FACS)
                 ELSE
                    CSU(INDU) = ONE
                 ENDIF
              END IF
              IF (KTYPEU(INDU).EQ.2) THEN
                 IF(NORMP .NE. 1) THEN
                    CPU(INDU) = ONE/SQRT(FACP)
                 ELSE
                    CPU(INDU) = ONE
                 ENDIF
              END IF
              IF (KTYPEU(INDU).EQ.3) THEN
                 IF(NORMP .NE. 1) THEN
                    CDU(INDU) = ONE/SQRT(FACD)
                 ELSE
                    CDU(INDU) = ONE
                 ENDIF
              END IF
              IF (KTYPEU(INDU).EQ.4) THEN
                 IF(NORMP .NE. 1) THEN
                    CFU(INDU) = ONE/SQRT(FACF)
                 ELSE
                    CFU(INDU) = ONE
                 ENDIF
              END IF
              IF (KTYPEU(INDU).EQ.5) THEN
                 IF(NORMP .NE. 1) THEN
                    CGU(INDU) = ONE/SQRT(FACG)
                 ELSE
                    CGU(INDU) = ONE
                 ENDIF
              END IF
            ENDIF   ! end of ADDPRIM block
          ELSE      ! middle of ADDSHELL block
            NREDUN=NREDUN+1
            MAPLE(IND)=-NEXP
C           II=LARCH(NEXP)
            IF(KMIN(I).NE.KMINU(II).OR.KMAX(I).NE.KMAXU(II)) THEN
              WRITE(IW,9000) I,NEXP
              CALL ABRT
C
C         THIS IS NOT A REAL DEAD END, BUT MORE CODE NEEDS TO BE WRITTEN
C         FOR THE CASE WHEN THE RADIAL PARTS OVERLAP, SUCH AS WHEN
C         AN L-SHELL OVERLAPS WITH AN S OR P-SHELL, IN WHICH CASE THE
C         L-SHELL NEEDS TO BE SPLIT INTO S AND P AND THEN THE REDUNDANT
C         RADIAL PART THROWN AWAY.
C
              ENDIF
          ENDIF      ! end of ADDSHELL block
C
C         A) FOR REDUNDANT AOS (GIVEN AN ATOM), POINT TO THE FIRST ONE
C         B) FOR SYMMETRY RELATED ONES, POINT TO THE CORRECT AO
C            (WITHOUT IF(ADDSHELL) WE WOULD POINT TO UNIQUE PRIMITIVE)
C         SECOND LOOP (LABEL 110) GIVES HIGHER PRIORITY TO A).
C
          IF(NEXP.EQ.0) CALL ABRT
          DO K=0,KMAX(I)-KMIN(I)
           IF(KTYPE(I).EQ.1.OR.(LSHELL.AND.K.EQ.0.AND.LUNCON.EQ.0)) THEN
              DUM=CS(IND)/CSU(NEXP)
            ELSE IF (KTYPE(I).EQ.2) THEN
              DUM=CP(IND)/CPU(NEXP)
            ELSE IF (KTYPE(I).EQ.3) THEN
              DUM=CD(IND)/CDU(NEXP)
            ELSE IF (KTYPE(I).EQ.4) THEN
              DUM=CF(IND)/CFU(NEXP)
            ELSE IF (KTYPE(I).EQ.5) THEN
              DUM=CG(IND)/CGU(NEXP)
            ENDIF
C           WE SAVE TRASPOSE MATRIX BECAUSE THE ROW DIMENSION LU1 CAN
C           CHANGE. NEED U(LU1,L1), BUT SAVE U(L1,LU1)
C           IN PLAIN FORTRAN, U(KLOC(I)+K,KLOCU(II)+K0)=DUM
            K0=K
            IF(LSHELL.AND.LUNCON.NE.0.AND.LLOOP.EQ.1) K0=K0+1
            X(LUU-1+ (KLOCU(II)+K -1)*L1 + KLOC(I)+K0)=DUM
          ENDDO
          IF(LUNCON.NE.0.AND.LSHELL.AND.LLOOP.EQ.1) THEN
            CS(IND)=CSSAVE
            CP(IND)=CPSAVE
            KTYPE(I)=2
            KMIN(I)=1
            KMAX(I)=4
          ENDIF
  190 CONTINUE
        ENDDO
  200 CONTINUE
C
C             in case you need to see the uncontracted basis set...
C
      DEBUG=.FALSE.
      IF(DEBUG  .AND.  MASWRK) THEN
         WRITE(IW,9050)
         DO N=1,NSHELLU
            IF(KTYPEU(N).EQ.1) DUM = CSU(N)
            IF(KTYPEU(N).EQ.2) DUM = CPU(N)
            IF(KTYPEU(N).EQ.3) DUM = CDU(N)
            IF(KTYPEU(N).EQ.4) DUM = CFU(N)
            IF(KTYPEU(N).EQ.5) DUM = CGU(N)
            WRITE(IW,9052) N,KTYPEU(N)-1,EXU(N),DUM
         ENDDO
      ENDIF
c
      IF(NUMU.LT.NUM) THEN
         WRITE(IW,*) 'FAILURE IN UNCONTRACTION?',NUM,NUMU
         CALL ABRT
C        NOTE: WE DO ASSUME IN STORAGE ALLOCATION THE OPPOSITE RELATION
      ENDIF
      IF(MASWRK) THEN
         WRITE(IW,9010) NSHELLU,NUMU,NSHELL,NUM
         IF(NREDUN.NE.0)  WRITE(IW,9020) NREDUN
         IF(NCOPIED.NE.0) WRITE(IW,9030) NCOPIED
         IF(NGHOST.NE.0) WRITE(IW,9040) NGHOST
      ENDIF
C     WRITE(6,*) 'DBG EX',(EXU(I),I=1,INDU),'CS',(CSU(I),I=1,INDU),'CP',
C    *           (CPU(I),I=1,INDU),'CD',(CDU(I),I=1,INDU),'CF',
C    *           (CFU(I),I=1,INDU),'CG',(CGU(I),I=1,INDU),'KSTART',
C    *           (KSTARTU(I),I=1,INDU),'KATOM',(KATOMU(I),I=1,INDU),
C    *           'KTYPE',(KTYPEU(I),I=1,INDU),'KNG',(KNGU(I),I=1,INDU),
C    *           'KLOC',(KLOCU(I),I=1,INDU),'KMIN',(KMINU(I),I=1,INDU),
C    *           'KMAX',(KMAXU(I),I=1,INDU)
C     CALL PRSQ(X(LUU),NUMU,L1,L1)
      CALL TRPOSE(X(LUU),X(LUU1),L1,NUMU,0)
      CALL RELSAVEU(15,EX,CS,CP,CD,CF,CG,KSTART,KATOM,KTYPE,
     *                    KNG,KLOC,KMIN,KMAX,NSHELL)
      CALL RELSAVEU(17,EXU,CSU,CPU,CDU,CFU,CGU,KSTARTU,KATOMU,KTYPEU,
     *                    KNGU,KLOCU,KMINU,KMAXU,NSHELLU)
      CALL DAWRIT(IDAF,IODA,X(LUU1),NUMU*L1,NDARELB+19,0)
      CALL RETFM(NEED)
      RETURN
 9000 FORMAT('ALAS, YOUR BASIS SET HAS SAME EXPONENTS WITH DIFFERENT',/,
     *     'RADIAL PARTS (CONTRACTED SHELL',I4,' AND PRIMITIVE',I4,').',
     *      /,'IF THE OFFENDING SHELL IS OF L TYPE, USE L-SHELL',
     *      /,'INTERNAL SPLITTING, ADD 4 TO OPRESC IN $RELWFN *AND* ',
     *      /,'PUT L-SHELLS BEFORE S AND P FOR EACH ATOM.',/)
 9010 FORMAT(/1X,'INTERNAL BASIS SET UNCONTRACTION FOR RESC/DK/IOTC:',/,
     *       I6,' SHELLS AND ',I6,' AOS ARE CONSTRUCTED, COMPARED TO',/,
     *       I6,' SHELLS AND ',I6,' AOS IN THE CONTRACTED BASIS SET',/)
 9020 FORMAT(I6,' REDUNDANT PRIMITIVE(S) ELIMINATED.',/)
 9030 FORMAT(I6,' SHELL(S) COPIED FOR NON-RELATIVISTIC ATOMS.',/)
 9040 FORMAT(I6,' SHELL(S) REMOVED BECAUSE OF ZERO COEFFICIENTS.',/)
 9050 FORMAT(//7X,'DUMPING THE MODEQR=1 UNCONTRACTED BASIS SET.'/
     *    1X,'PRIMITIVE  ANG.MOM.',7X,'EXPONENT',6X,'GTO NORMALIZATION')
 9052 FORMAT(I10,I8,2F20.6)
      END
