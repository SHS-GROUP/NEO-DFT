c 12 Aug 13 - DGF - finish FMO 5.0
C 21 May 13 - DGF - pad common blocks
C 20 Feb 12 - MWS - RIMP2DRIVER: add CUMP2 printing
C  2 NOV 11 - MWS - REMOVE COUNTERPOISE/ENERGY DECOMPOSITION BLOCKAGE
C 11 AUG 10 - MK  - NEW MODULE FOR PARALLEL RI-RMP2 AND RI-UMP2 ENERGY
C
C*MODULE RIMP2   *DECK CP2CAUXINT
      SUBROUTINE CP2CAUXINT(GHONDO,V,TI,TJ,W,NAUXBAS,
     *     LOCI,LOCJ,MINI,MAXI,MINJ,MAXJ,NI,NJ,
     *     LOCIS,LOCJS,MINIS,MAXIS,MINJS,MAXJS,NIS,NJS,SPHAUX,IANDJ)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL SPHAUX,IANDJ
      DOUBLE PRECISION GHONDO(*), V(NAUXBAS,NAUXBAS), TI(*), TJ(*),W(*)
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
      IF(SPHAUX) THEN
         MINIT = MINIS
         MAXIT = MAXIS
         MINJT = MINJS
         MAXJT = MAXJS
         LOCIT = LOCIS
         LOCJT = LOCJS
         NIT = NIS
C         WRITE(6,*) 'NI=',NI,'NJ=',NJ
C         WRITE(6,*) 'NIS=',NIS,'NJS=',NJS
C         CALL PRSQ(TI,NI,NI,NI)
C         CALL PRSQ(TJ,NJ,NJ,NJ)
C         CALL PRSQ(GHONDO,NJ,NI,NI)
         CALL DGEMM('N','N',NI,NJS,NJ,ONE,GHONDO,NI,TJ,NJ,ZERO,W,NI)
         CALL DGEMM('T','N',NIS,NJS,NI,ONE,TI,NI,W,NI,ZERO,GHONDO,NIS)
C         CALL PRSQ(GHONDO,NJS,NIS,NIS)
      ELSE
         MINIT = MINI
         MAXIT = MAXI
         MINJT = MINJ
         MAXJT = MAXJ
         LOCIT = LOCI
         LOCJT = LOCJ
         NIT = NI
      END IF
C
      JMAX = MAXJT
      ICNT = 0
      DO I = MINIT, MAXIT
         ICNT = ICNT+1
         IAUX = LOCIT+I
         JCNT = 0
         IF(IANDJ) JMAX = I
         DO J = MINJT, JMAX
            JCNT = JCNT+1
            JAUX = LOCJT+J
            IJ = ICNT+(JCNT-1)*NIT
            V(IAUX,JAUX) = GHONDO(IJ)
            V(JAUX,IAUX) = GHONDO(IJ)
C            WRITE(6,'(2I4,D20.10)') IAUX,JAUX,GHONDO(IJ)
         END DO
      END DO
C
      RETURN
      END
C*MODULE RIMP2   *DECK CP3CAUXINT
      SUBROUTINE CP3CAUXINT(GHONDO,T0,TL,W,NBASIS,LOCI,LOCJ,
     *     MINI,MAXI,MINJ,MAXJ,MINL,MAXL,NI,NJ,NL,MINLS,MAXLS,NLS,
     *     SPHAUX,IANDJ)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL SPHAUX,IANDJ
      DOUBLE PRECISION GHONDO(*),T0(NBASIS,NBASIS,*),TL(*),W(*)
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
      IF(SPHAUX) THEN
         MINLT = MINLS
         MAXLT = MAXLS
         NLT = NLS
         NLJ = NLS*NJ
         CALL DGEMM('T','N',NLS,NI*NJ,NL,ONE,TL,NL,GHONDO,NL,ZERO,W,NLS)
         CALL DCOPY(NLJ*NI,W,1,GHONDO,1)
      ELSE
         MINLT = MINL
         MAXLT = MAXL
         NLT = NL
         NLJ = NL*NJ
      END IF
C
      JMAX = MAXJ
      LL = 0
      DO L = MINLT, MAXLT
         LL = LL+1
         ICNT = 0
         DO I = MINI, MAXI
            ICNT = ICNT+1
            IBF = LOCI+I
            JCNT = 0
            IF(IANDJ) JMAX = I
            DO J = MINJ, JMAX
               JCNT = JCNT+1
               JBF = LOCJ+J
               LIJ = LL+(JCNT-1)*NLT+(ICNT-1)*NLJ
               T0(IBF,JBF,LL) = GHONDO(LIJ)
               T0(JBF,IBF,LL) = GHONDO(LIJ)
            END DO
         END DO
      END DO
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIMP2CSTRM
      SUBROUTINE RIMP2CSTRM(TR,IT,MINI,NI,MINIS,MAXIS)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION TR(NI,*)
C
      COMMON /SPHERI/ PSHELL(3,3),DSHELL(6,6),
     *                FSHELL(10,10),GSHELL(15,15),
     *                PIHELL(3,3),DIHELL(6,6),
     *                FIHELL(10,10),GIHELL(15,15)
C
      IF(IT .EQ. 0) THEN
         MINIS = 1
         MAXIS = 1
         TR(1,1) = 1.0D+00
      ELSE IF(IT .EQ. 1) THEN
         IF(MINI .EQ. 1) THEN
            MINIS = 1
            MAXIS = 4
            TR(1,1) = 1.0D+00
            TR(2,1) = 0.0D+00
            TR(3,1) = 0.0D+00
            TR(4,1) = 0.0D+00
            TR(1,2) = 0.0D+00
            TR(1,3) = 0.0D+00
            TR(1,4) = 0.0D+00
            DO I = 2, 4
               DO J = 2, 4
                  TR(I,J) = PSHELL(I,J)
               END DO
            END DO
         ELSE
            MINIS = 2
            MAXIS = 4
            DO I = 1, 3
               DO J = 1, 3
                  TR(I,J) = PSHELL(I,J)
               END DO
            END DO
         END IF
      ELSE IF(IT .EQ. 2) THEN
         MINIS = 5
         MAXIS = 9
         DO I = 1, 6
            DO J = 1, 5
               TR(I,J) = DSHELL(I,J)
            END DO
         END DO
      ELSE IF(IT .EQ. 3) THEN
         MINIS = 10
         MAXIS = 16
         DO I = 1, 10
            DO J = 1, 7
               TR(I,J) = FSHELL(I,J)
            END DO
         END DO
      ELSE IF(IT .EQ. 4) THEN
         MINIS = 17
         MAXIS = 25
         DO I = 1, 15
            DO J = 1, 9
               TR(I,J) = GSHELL(I,J)
            END DO
         END DO
      END IF
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIMP2DRIVER
C>
C>  @brief   drive Resolution of the Identity MP2 (RHF and UHF)
C>
C>  @author  Michio Katouda, Institute for Molecular Science, 2008
C>
      SUBROUTINE RIMP2DRIVER
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,SAVDSK
      LOGICAL GOSMP,GONODE
      LOGICAL OTHAUX,USEDM,EXTCAB
C
      INTEGER DDI_NP,DDI_ME,DDI_NN,DDI_MY
      INTEGER SMP_NP,SMP_ME
C
C     MAIN DRIVER OF RI-MP2 ENERGY CALCULATION PROGRAM
C     FOR GAMESS 2008APR AND GAMESS 2009JAN
C
C     WRITTEN BY MICHIO KATOUDA (INSTITUTE OF MOLECULAR SCIENCE)
C     JAPAN,
C     FEBRUARY 21, 2008.
C
C     REF. M.KATOUDA AND S.NAGASE,INT.J.QUANT.CHEM.,109,2121(2009).
C
      PARAMETER (NORIMP=8,NOAUBF=2)
      DOUBLE PRECISION QRIMP(NORIMP),QAUXBF(NOAUBF)
      INTEGER KQRIMP(NORIMP),KQAUXBF(NOAUBF)
C
      PARAMETER (MXRT=100, MXSH=5000, MXGTOT=20000)
      PARAMETER (MXAUXSH=10000, MXAXGTOT=20000)
C
      COMMON /AUXBAS/ EXAUX(MXAXGTOT),CAUXS(MXAXGTOT),CAUXP(MXAXGTOT),
     *                CAUXD(MXAXGTOT),CAUXF(MXAXGTOT),CAUXG(MXAXGTOT),
     *                CAUXH(MXAXGTOT),CAUXI(MXAXGTOT),
     *                KAUXST(MXAUXSH),KAUXAT(MXAUXSH),KAUXTY(MXAUXSH),
     *                KAUXNG(MXAUXSH),KAUXLO(MXAUXSH),KAUXMI(MXAUXSH),
     *                KAUXMX(MXAUXSH),NAUXSH
      COMMON /BASSPH/ QMTTOL,ISPHER
      COMMON /ENRGMP/ EMP2,EMP3,EMP4,EMP2A
      COMMON /ENRGYS/ ENUC,EELEC,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FMCOM / X(1)
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOL,METHOD,NWDMP2,MEMPRI,MPPROP,
     *                NACORE,NBCORE,NOA,NOB,NO,NBF,NOMIT,MOCPHF,MAXITC
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /ONEELC/ EONE,E1A,E1B
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SCFWFN/ AROHF(3),BROHF(3),PACAVO(6),IACAVO,IUHFNO,ICUHF,
     *                MVOQ
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      COMMON /RIMPFI/ IFILV,IFILT2A,IFILT3A,IFILT2B,IFILT3B
C
C     DISTRIBUTED ARRAY
      INTEGER D_V,D_TA,D_TB
      COMMON /RIMPDD/ D_V,D_TA,D_TB
C
      PARAMETER (THREE=3.0D+00, P12=1.2D+00)
C
      DATA RHF      /8HRHF     /
      DATA UHF      /8HUHF     /
      DATA CHECK    /8HCHECK   /
C
      DATA RIMP2    /8HRIMP2   /
      DATA AUXBAS   /8HAUXBAS  /
      DATA QRIMP    /8HIAUXBF  ,8HIVMTD   ,8HVTOL    ,8HSTOL    ,
     *               8HOTHAUX  ,8HGOSMP   ,8HMEMSH   ,8HUSEDM   /
      DATA QAUXBF   /8HCABNAM  ,8HEXTCAB  /
      DATA KQRIMP   /1,1,3,3,0,0,1,0/
      DATA KQAUXBF  /5,0/
C
      CALL DDI_SYNC(5121)
      CALL DDI_NPROC(DDI_NP,DDI_ME)
      CALL DDI_NNODE(DDI_NN,DDI_MY)
      CALL DDI_SMP_NPROC(SMP_NP,SMP_ME)
      GOSMP = SMP_NP .GT. 1
      GONODE= DDI_NN .GT. 1
C
      CALL DDI_SMP_SYNC()
C
      IF(MASWRK) THEN
         IF(SCFTYP .EQ. RHF) WRITE (IW,9000)
         IF(SCFTYP .EQ. UHF) WRITE (IW,9001)
      END IF
C
C     SUBTRACT FMO PROJECTED OUT ORBITALS.
C
      IF(NFG.NE.0) NO = NO - NORBPROJ
C
C    ----- VARIABLES FOR MP2 ENERGY -----
C
      NBASIS = NBF
      NOCCA  = NOA - NACORE
      NVIRA  = NO  - NOA
      NORBA  = NO  - NACORE
      NOCCB  = NOB - NBCORE
      NVIRB  = NO  - NOB
      NORBB  = NO  - NBCORE
C
C     INITIALIZE VARIABLES FOR NAMELIST $RIMP2
C
      IAUXBF= 0
      IF(ISPHER .EQ. 1) IAUXBF= 1
      OTHAUX= .FALSE.
      STOL  = 1.0D-6
      IVMTD = 0
      VTOL  = 1.0D-6
C        NOTE THAT -MEMSH- IS NOT ACTUALLY USED TO LIMIT -GOSMP-'S SIZES
      MEMSH = 0
      USEDM = .TRUE.
C
C     READ INFORMATION
C     FOR RI-MP2 ENERGY CALCULATION FROM NAMELIST $RIMP2
C
      CALL NAMEIO(IR,JRET,RIMP2,NORIMP,QRIMP,KQRIMP,
     *    IAUXBF,IVMTD,VTOL,STOL,OTHAUX,GOSMP,MEMSH,USEDM,
     *    0,
     *    0,0,0,0,0,  0,0,0,0,0,   0,0,0,0,0,
     *    0,0,0,0,0,  0,0,0,0,0,   0,0,0,0,0,  0,0,0,0,0,
     *    0,0,0,0,0,  0,0,0,0,0,   0,0,0,0,0,  0,0,0,0,0)
      IF(JRET .EQ. 2) THEN
         IF (MASWRK) WRITE(IW,9004)
         CALL ABRT
      END IF
      IF(IAUXBF .LT. 0 .AND. IAUXBF .GT. 1) THEN
         IF(MASWRK) WRITE(IW,9015)
         CALL ABRT
      END IF
      IF(IAUXBF .EQ. 1 .AND. ISPHER .NE. 1) THEN
         IF(MASWRK) THEN
            WRITE(IW,*)
     *           ' SPHERICAL HARMONIC AUXILIARY GAUSSIAN BASIS SET'
            WRITE(IW,*)
     *           ' CAN NOT BE USED WITH CARTESIAN GAUSSIAN BASIS SET'
         END IF
         CALL ABRT
      END IF
C
C        THE FOLLOWING TEST IS DUE TO NOT KNOWING WHAT AUXILIARY
C        BASIS SHOULD BE PLACED ON A NUCLEUS FOR COUNTERPOISE
C        CORRECTIONS.  AT THIS POINT, THE ORIGINAL NUCLEAR CHARGE'S
C        VALUE WILL BE LOST, WITH ZAN BEING ZERO.
C            BUT, SEE RIGHOATM IN RICAB.SRC...
C---  OK=.TRUE.
C---  DO I=1,NAT
C---     IF(ZAN(I).LE.ZERO) OK=.FALSE.
C---  ENDDO
C---  IF(.NOT.OK) THEN
C---     IF(MASWRK) WRITE(IW,6)
C---     CALL ABRT
C---  END IF
C---6 FORMAT(1X,'RI-MP2 CANNOT BE USED WITH COUNTERPOISE CORRECTION,'/
C--- *       1X,'OR ANY OTHER KIND OF RUN WITH ZERO NUCLEAR CHARGES.')
C
C        SAME REASON, INVOLVES ATOMS WITH NUCLEAR CHARGE TURNED OFF.
C---  IF(RUNTYP.EQ.LMOEDA  .OR.  RUNTYP.EQ.MOROKUMA) THEN
C---     IF(MASWRK) WRITE(IW,7)
C---     CALL ABRT
C---  END IF
C---7 FORMAT(1X,'BOTH ENERGY DECOMPOSITION ANALYSES INVOLVE ZERO'/
C--- *       1X,'NUCLEAR CHARGES FOR ATOMS NOT IN A PARTICULAR MONOMER'/
C--- *       1X,'SO UNABLE TO SET UP AUXILIARY BASIS SETS FOR THEM.'/
C--- *       1X,'PLEASE USE AN EXACT MP2 PROGRAM TO HANDLE EDA RUNS.')
C
      IF(IVMTD .LT . 0 .AND. IVMTD .GT. 3) THEN
         IF(MASWRK) WRITE(IW,9020)
         CALL ABRT
      END IF
      IF(MASWRK) WRITE(IW,9021) IAUXBF,OTHAUX,STOL,IVMTD,VTOL
C
      MEMSH = MEMSH*1000000
C----      IF(MEMSH .EQ. 0) GOSMP=.FALSE.
      IF(.NOT. GOSMP .AND. NPROC .GT. 1) GONODE=.TRUE.
      IF(MASWRK) THEN
         IF(GOSMP) THEN
            WRITE(IW,9030)
         ELSE
            WRITE(IW,9031)
         END IF
         IF(USEDM) WRITE(IW,9032)
      END IF
C
C     INITIALIZE VARIABLES FOR NAMELIST $AUXBAS
C
      EXTCAB=.FALSE.
C
C     READ PRESETTED AUXILIARY BASIS SETS INFORMATION
C     FOR RI-MP2 ENERGY CALCULATION FROM NAMELIST $AUXBAS
C
      CALL NAMEIO(IR,JRET,AUXBAS,NOAUBF,QAUXBF,KQAUXBF,
     *    CABNAM,EXTCAB,
     *    0,0,0,0,0,  0,0,
     *    0,0,0,0,0,  0,0,0,0,0,   0,0,0,0,0,
     *    0,0,0,0,0,  0,0,0,0,0,   0,0,0,0,0,  0,0,0,0,0,
     *    0,0,0,0,0,  0,0,0,0,0,   0,0,0,0,0,  0,0,0,0,0)
      IF(JRET .EQ. 2) THEN
         IF (MASWRK) WRITE(IW,9005)
         CALL ABRT
      END IF
      IF (MASWRK) WRITE (IW,9010) CABNAM,EXTCAB
C
C     PREPARE AUXILIARY BASIS SETS
C
      CALL RICAUXBAS(CABNAM,EXTCAB,NAUXCAT)
      CALL FLSHBF(IW)
C
      NAUXBAS = NAUXCAT
      CALL VALFM(LOADFM)
      LLOCSPH = LOADFM  + 1
      IF(IAUXBF .EQ. 1) THEN
         LAST    = LLOCSPH + NAUXSH
         NEED0   = LAST-LOADFM-1
         CALL GETFM(NEED0)
         CALL SPHAUX(X(LLOCSPH),NAUXSPH)
         NAUXBAS = NAUXSPH
      END IF
C
C     DETERMINE OCCUPIED ORBITAL BATCH INFOMATION
C
      IF(GOSMP) THEN
         NPROCTMP=DDI_NN
      ELSE
         NPROCTMP=NPROC
      END IF
C
C        ALL AVAILABLE -MWORDS- CAN BE USED FOR REPLICATED
C        DATA STRUCTURES, TO TRY FOR A SMALL "LV" VALUE,
C        INDEPENDENT OF WHETHER OR NOT GOSMP=.TRUE.
      CALL GOTFM(NGOTMX)
C
      CALL RIMP2OCCBATCHK(SCFTYP,NSHELL,NBF,NAUXSH,NAUXBAS,
     *     NOCCA,NOCCB,NVIRA,NVIRB,NACORE,NBCORE,NGOTMX,
     *     GONODE,MASWRK,NPROCTMP,IW,
     *     LINFOCCABAT,LINFOCCBBAT,NEED1,NN,NOCCBAT,
     *     LENOCCABAT,LENOCCBBAT,NINTMXA,NINTMXB)
C
      IF(MASWRK) THEN
         IF(SCFTYP .EQ. RHF) THEN
            WRITE(IW,9050) NOCCA+NACORE,NOCCA,NVIRA,NBASIS,NSHELL,
     *           NAUXBAS,NAUXSH,NN,LENOCCABAT,NOCCBAT
         ELSE IF(SCFTYP .EQ. UHF) THEN
            WRITE(IW,9051) NOCCA+NACORE,NOCCB+NBCORE,NOCCA,NOCCB,NVIRA,
     *           NVIRB,NBASIS,NSHELL,NAUXBAS,NAUXSH,NN,LENOCCABAT,
     *           NOCCBAT
         END IF
         IF(NFG.NE.0.AND.NORBPROJ.NE.0) WRITE(IW,9055) NORBPROJ
      END IF
C
      IF(.NOT. USEDM) THEN
C
C        OPEN FILES
C
         IF(MASWRK) WRITE(IW,9070)
         INTSIZ=8/NWDVAR
         IFILV   = 51
         IFILT2A = 52
         IFILT3A = 53
         LRECT2A = NINTMXA+INTSIZ*2
         LRECT3A = NAUXBAS*NVIRA
         SAVDSK  = DSKWRK
         DSKWRK  = .TRUE.
         CALL SEQOPN(IFILV  ,'RIVMAT','UNKNOWN',.FALSE.,'UNFORMATTED')
         CALL DIROPN(IFILT2A,'RIT2A' ,'UNKNOWN',LRECT2A)
         CALL DIROPN(IFILT3A,'RIT3A' ,'UNKNOWN',LRECT3A)
         IF(SCFTYP .EQ. UHF) THEN
            IFILT2B = 54
            IFILT3B = 55
            LRECT2B = NINTMXB+INTSIZ*2
            LRECT3B = NAUXBAS*NVIRB
            CALL DIROPN(IFILT2B,'RIT2B','UNKNOWN',LRECT2B)
            CALL DIROPN(IFILT3B,'RIT3B','UNKNOWN',LRECT3B)
         ENDIF
         DSKWRK = SAVDSK
      ELSE
C
C        CREATE DISTRIBUTED MEMORY ARRAY
C
         MEMDDITOT = NAUXBAS*NVIRA*NOCCA + NAUXBAS*NAUXBAS
         IF (SCFTYP.EQ.UHF) MEMDDITOT = MEMDDITOT + NAUXBAS*NVIRB*NOCCB
         MEMDDITOT = (MEMDDITOT-1)/1000000 + 1
         IF(MASWRK) THEN
            WRITE(IW,9080) MEMDDITOT
            IF(EXETYP.EQ.CHECK) THEN
               WRITE(IW,9082)
               DO I=0,8
                  NP = 2**I
                  GBYTES = 8*MEMDDITOT/(1024.0D+00*NP)
                  WRITE(IW,9083) NP,GBYTES
               ENDDO
               WRITE(IW,9084)
            ELSE
               GBYTES = 8*MEMDDITOT/(1024.0D+00*NPROC)
               WRITE(IW,9086) NPROC,GBYTES
            ENDIF
         ENDIF
C
C            THERE IS SEEMINGLY NO PROTECTION IN DDI ITSELF ABOUT
C            CREATING MORE STORAGE THAN THE INPUT ALLOWS, SO WE
C            MUST TEST THIS OURSELVES.
C
         CALL SYSINP( INPMEM, INPMDDI )
         IF(MEMDDITOT.GT.INPMDDI) THEN
            IF(MASWRK) WRITE(IW,9088) INPMDDI,MEMDDITOT
            CALL ABRT
         END IF
         CALL FLSHBF(IW)
C
         IF(EXETYP.NE.CHECK) THEN
            IF(SCFTYP.EQ.UHF) CALL DDI_CREATE(NAUXBAS*NVIRB,NOCCB,D_TB)
            CALL DDI_CREATE(NAUXBAS*NVIRA,NOCCA,D_TA)
            CALL DDI_CREATE(NAUXBAS,NAUXBAS,D_V)
         END IF
      END IF
C
C     GENERATE DECOMPOSED MATRIX OR OF V^(-1) MATRIX.
C
      IF(GOSMP) THEN
         CALL RIMP2GENVINVSMP(X(LLOCSPH),STOL,VTOL,NAUXBAS,NAUXBASD,
     *        IAUXBF,IVMTD,OTHAUX,USEDM)
      ELSE
         CALL RIMP2GENVINV(X(LLOCSPH),STOL,VTOL,NAUXBAS,NAUXBASD,IAUXBF,
     *        IVMTD,OTHAUX,USEDM)
      END IF
      IF(MASWRK) WRITE(IW,9060) IVMTD,VTOL,NAUXBAS,NAUXBASD
C
C     PERFORM 3C-2E ELECTRON REPULSION INTEGRAL TRANSFORMATION.
C
      IF(GOSMP) THEN
         CALL RIMP2INTTRNSMP(X(LLOCSPH),X(LINFOCCABAT),X(LINFOCCBBAT),
     *        NSHELL,NBF,NAUXSH,NAUXBAS,NAUXBASD,
     *        NORBA,NORBB,NOCCA,NOCCB,NVIRA,NVIRB,NACORE,NBCORE,
     *        NINTMXA,NINTMXB,NOCCBAT,LENOCCABAT,LENOCCBBAT,IAUXBF,
     *        USEDM)
      ELSE
         CALL RIMP2INTTRN(X(LLOCSPH),X(LINFOCCABAT),X(LINFOCCBBAT),
     *        NSHELL,NBF,NAUXSH,NAUXBAS,NAUXBASD,
     *        NORBA,NORBB,NOCCA,NOCCB,NVIRA,NVIRB,NACORE,NBCORE,
     *        NINTMXA,NINTMXB,NOCCBAT,LENOCCABAT,LENOCCBBAT,IAUXBF,
     *        USEDM)
      END IF
C
      IF(.NOT. USEDM) THEN
C
C        CLOSE V AND T2 FILES
C
         SAVDSK = DSKWRK
         DSKWRK = .TRUE.
         CALL SEQCLO(IFILV,'KEEP')
         CALL DIRCLO(IFILT2A,'KEEP')
         IF(SCFTYP.EQ.UHF) CALL DIRCLO(IFILT2B,'KEEP')
         DSKWRK = SAVDSK
C
      ELSE
C
C        DESTROY DISTRIBUTED MEMORY ARRAYS
C
         IF(EXETYP.NE.CHECK) CALL DDI_DESTROY(D_V)
C
      END IF
C
C     GENERATE 4C-2E ELECTRON REPULSION INTEGRALS FROM 3C-2E
C     INTEGRAL MATRICES AND ACCUMULATE MP2 CORRELATION ENERGY.
C
      IF(GOSMP) THEN
         CALL RIMP2ENGSMP(X(LINFOCCABAT),X(LINFOCCBBAT),E2,E2T,E2S,
     *        NBF,NAUXBASD,NORBA,NORBB,NOCCA,NOCCB,NVIRA,NVIRB,
     *        NACORE,NBCORE,NOCCBAT,LENOCCABAT,LENOCCBBAT,USEDM)
      ELSE
         CALL RIMP2ENG(X(LINFOCCABAT),X(LINFOCCBBAT),E2,E2T,E2S,
     *        NBF,NAUXBASD,NORBA,NORBB,NOCCA,NOCCB,NVIRA,NVIRB,
     *        NACORE,NBCORE,NOCCBAT,LENOCCABAT,LENOCCBBAT,USEDM)
      END IF
C
      IF(.NOT. USEDM) THEN
C
C        CLOSE T3 FILES
C
         SAVDSK = DSKWRK
         DSKWRK = .TRUE.
         CALL DIRCLO(IFILT3A,'KEEP')
         IF(SCFTYP.EQ.UHF) CALL DIRCLO(IFILT3B,'KEEP')
         DSKWRK = SAVDSK
C
      ELSE
C
C        DESTROY DISTRIBUTED MEMORY ARRAYS
C
         IF(EXETYP.NE.CHECK) THEN
            CALL DDI_DESTROY(D_TA)
            IF(SCFTYP .EQ. UHF) CALL DDI_DESTROY(D_TB)
         END IF
C
      END IF
C
C     FREE MEMORY
C
      CALL RETFM(NEED1)
      IF(IAUXBF .EQ. 1) CALL RETFM(NEED0)
C
C     ----- PRINT ENERGY DATA -----
C
C     SCS-MP2 ENERGY IS CALCULATED ACCOMPANYING WITH MP2 ENERGY
C
      EHF  = ESCF
      IF(ICUHF.NE.1) EONE=0.0D+00
      EMP2 = EHF+E2-EONE
      SCSE2= E2S*P12+E2T/THREE
      ESCSMP2=EHF+SCSE2
      EMP2A=ESCSMP2
      IF(MASWRK) THEN
         IF(ICUHF.EQ.1) WRITE(IW,9220) -E1A,-E1B,E2
         WRITE(IW,9200) EHF,E2,EMP2
         IF(ICUHF.EQ.0) WRITE(IW,9210) E2S,E2T,SCSE2,ESCSMP2
      END IF
C
      RETURN
 9000 FORMAT(/1X,29(1H-),5X,34(1H-)/
     *        1X,'RHF RI-MP2 ENERGY CALCULATION',5X,
     *           'PROGRAM WRITTEN BY M.KATOUDA (IMS)'/
     *        1X,29(1H-),5X,34(1H-))
 9001 FORMAT(/1X,29(1H-),5X,34(1H-)/
     *        1X,'UHF RI-MP2 ENERGY CALCULATION',5X,
     *           'PROGRAM WRITTEN BY M.KATOUDA (IMS)'/
     *        1X,29(1H-),5X,34(1H-))
 9004 FORMAT(1X,'SYNTAX ERROR FOUND IN YOUR $RIMP2 GROUP')
 9005 FORMAT(1X,'SYNTAX ERROR FOUND IN YOUR $AUXBAS GROUP')
 9010 FORMAT(/5X,23HAUXILIARY BASIS OPTIONS/5X,23(1H-)/
     *        5X,7HCABNAM=,A8,1X,7HEXTCAB=,L2)
 9015 FORMAT(1X,'ILLEGUL VALUE OF IAUXBF IS FOUND')
 9020 FORMAT(1X,'ILLEGUL VALUE OF IVMTD IS FOUND')
 9021 FORMAT(1X,'IAUXBF=',I1,3X,'OTHAUX=',L2,
     *       1X,'STOL=',1P,E9.2,0P,3X,'IVMTD=',I1,1X,'VTOL=',1P,E9.2)
 9030 FORMAT(/10X,'NODE BASED PARALLEL RI-MP2 ALGORITHM IS CHOOSEN'/
     *        1X,'(ONLY ONE COPY OF EACH SHARED MEMORY ALLOCATION',
     *           ' IS USED PER NODE)')
 9031 FORMAT(/8X,'PROCESS BASED PARALLEL RI-MP2 ALGORITHM IS CHOOSEN'/
     *        1X,'(EACH AND EVERY PROCESS ALLOCATES THE REPLICATED',
     *           ' MEMORY ARRAYS)')
 9032 FORMAT(/1X,'DISTRIBUTED MEMORY IS USED TO STORE DATA,',
     *           ' INSTEAD OF DISKS')
 9050 FORMAT(/1X,'NUMBER OF OCCUPIED ORBITALS            =',I6,/
     *        1X,'NUMBER OF CORRELATED OCCUPIED ORBITALS =',I6,/
     *        1X,'NUMBER OF VIRTUAL ORBITALS             =',I6,/
     *        1X,'NUMBER OF BASIS FUNCTIONS              =',I6,/
     *        1X,'NUMBER OF BASIS SHELLS                 =',I6,/
     *        1X,'NUMBER OF AUXILIARY BASIS FUNCTIONS    =',I6,/
     *        1X,'NUMBER OF AUXILIARY BASIS SHELLS       =',I6,/
     *        1X,'LEVEL  OF OCCUPIED ORBITAL BATCH       =',I6,/
     *        1X,'LENGTH OF OCCUPIED ORBITAL BATCH       =',I6,/
     *        1X,'NUMBER OF OCCUPIED ORBITAL BATCH       =',I6)
 9051 FORMAT(/1X,'NUMBER OF OCCUPIED ORBITALS A            =',I6,/
     *        1X,'NUMBER OF OCCUPIED ORBITALS B            =',I6,/
     *        1X,'NUMBER OF CORRELATED OCCUPIED ORBITALS A =',I6,/
     *        1X,'NUMBER OF CORRELATED OCCUPIED ORBITALS B =',I6,/
     *        1X,'NUMBER OF VIRTUAL ORBITALS A             =',I6,/
     *        1X,'NUMBER OF VIRTUAL ORBITALS B             =',I6,/
     *        1X,'NUMBER OF BASIS FUNCTIONS                =',I6,/
     *        1X,'NUMBER OF BASIS SHELLS                   =',I6,/
     *        1X,'NUMBER OF AUXILIARY BASIS FUNCTIONS      =',I6,/
     *        1X,'NUMBER OF AUXILIARY BASIS SHELLS         =',I6,/
     *        1X,'LEVEL  OF OCCUPIED ORBITAL BATCH         =',I6,/
     *        1X,'LENGTH OF OCCUPIED ORBITAL BATCH         =',I6,/
     *        1X,'NUMBER OF OCCUPIED ORBITAL BATCH         =',I6)
 9055 FORMAT(/1X,'NUMBER OF REDUNDANT MOS IN FMO         =',I5)
 9060 FORMAT(/1X,'IVMTD=',I1,1X,'VTOL=',E10.4,
     *        1X,'NAUXBAS=',I6,1X,'NAUXBASD=',I6)
 9070 FORMAT(/1X,'USING MULTIPLE DISK FILES TO CONTAIN LARGE DATA SETS',
     *          ' (USEDM = .FALSE.)')
 9080 FORMAT(/1X,'USING DISTRIBUTED MEMORY TO CONTAIN LARGE DATA SETS',
     *          ' (USEDM = .TRUE.)'/
     *       1X,'TOTAL MEMDDI REQUIRED=',I10,' MILLION WORDS')
 9082 FORMAT(1X,'SAMPLE -DISTRIBUTED- MEMORY REQUIREMENTS FOR THIS',
     *          ' RUN:'/
     *       1X,'NO. COMPUTE PROCESSES     GBYTES/COMPUTE PROCESS')
 9083 FORMAT(7X,I5,15X,F12.2)
 9084 FORMAT(1X,'THE REPLICATED MEMORY AND SHARED MEMORY REQUIREMENTS',
     *          ' WILL BE SHOWN BELOW.')
 9086 FORMAT(1X,'MEMDDI IN THIS RUN IS SPREAD OVER',I6,
     *          ' COMPUTE PROCESSES, SO'/
     *       1X,'MEMDDI USED PER COMPUTE PROCESS WILL BE ',F12.2,
     *          ' GBYTES.')
 9088 FORMAT(/1X,'*** ERROR ***'/1X,'YOUR INPUT MEMDDI=',I8,
     *           ' IS SMALLER THAN NECESSARY=',I8/)
 9200 FORMAT(/1X,'RESULTS OF RI-MOLLER-PLESSET 2ND ORDER CORRECTION ARE'
     *       ,/,
     *       12X,'   E(0)=',1X,F20.10/
     *       12X,'   E(1)=',9X,'0.0'/
     *       12X,'   E(2)=',1X,F20.10/
     *       12X,' E(MP2)=',1X,F20.10)
 9210 FORMAT( 1X,'SPIN-COMPONENT-SCALED MP2 RESULTS ARE'/
     *       12X,'  E(2S)=',1X,F20.10/
     *       12X,'  E(2T)=',1X,F20.10/
     *       12X,' E(2ST)=',1X,F20.10,' = 6/5 * E(2S) + 1/3 * E(2T)'/
     *       12X,'SCS-MP2=',1X,F20.10)
 9220 FORMAT(/5X,'SINGLE EXCITATION CONTRIBUTION',
     *       /9X,'ALPHA',1X,F20.10,
     *       /9X,'BETA ',1X,F20.10,
     *       /5X,'DOUBLE EXCITATION CONTRIBUTION',
     *       /15X,F20.10)
      END
C*MODULE RIMP2   *DECK RIMP2E2ACC
      SUBROUTINE RIMP2E2ACC(EIG,BB,BK,Q,INFOCCBAT,E2,E2T,E2S,
     *     NAUXBAS,NORB,NOCC,NVIR,NOCCBAT,IFILT3,IW,MASWRK,USEDM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL MASWRK
      LOGICAL USEDM
C
      DOUBLE PRECISION EIG(*),BB(NAUXBAS,NVIR,*),BK(NAUXBAS,NVIR,*),Q(*)
      INTEGER INFOCCBAT(2,NOCCBAT)
C
      INTEGER D_V,D_T,D_TB
      COMMON /RIMPDD/ D_V,D_T,D_TB
C
      PARAMETER (ZERO=0.0D+00)
C
C     GENERATE 4C-2E ERI FROM 3 INDICES INTERMEDIATE MATRICES
C     AND ACCUMULATE MP2 CORRELATION ENERGY.
C
      TIMER = ZERO
      TIME4 = ZERO
      TIME5 = ZERO
C
      LENT3 = NAUXBAS*NVIR
C
      E2T = ZERO
      E2S = ZERO
      DO JBAT = 1, NOCCBAT
         JOCCBG = INFOCCBAT(1,JBAT)+1
         JOCCED = INFOCCBAT(1,JBAT)+INFOCCBAT(2,JBAT)
         CALL TSECND(TIMER0)
         IF(.NOT. USEDM) THEN
            DO JOCC = JOCCBG, JOCCED
               J = JOCC-JOCCBG+1
               CALL RIMP2T3RD(BK(1,1,J),LENT3,IFILT3,JOCC)
            END DO
         ELSE
            CALL DDI_GET(D_T,1,LENT3,JOCCBG,JOCCED,BK)
         END IF
         CALL TSECND(TIMER1)
         TIMER = TIMER+(TIMER1-TIMER0)
         DO IBAT = 1, JBAT
            IOCCBG = INFOCCBAT(1,IBAT)+1
            IOCCED = INFOCCBAT(1,IBAT)+INFOCCBAT(2,IBAT)
            IF(IBAT .NE. JBAT) THEN
               CALL TSECND(TIMER0)
               IF(.NOT. USEDM) THEN
                  DO IOCC = IOCCBG, IOCCED
                     I = IOCC-IOCCBG+1
                     CALL RIMP2T3RD(BB(1,1,I),LENT3,IFILT3,IOCC)
                  END DO
               ELSE
                  CALL DDI_GET(D_T,1,LENT3,IOCCBG,IOCCED,BB)
               END IF
               CALL TSECND(TIMER1)
               TIMER = TIMER+(TIMER1-TIMER0)
            ELSE
               CALL DCOPY(LENT3*INFOCCBAT(2,IBAT),BK,1,BB,1)
            END IF
C
            CALL RIMP2TEIE2(EIG,BB,BK,Q,E2T,E2S,NAUXBAS,NORB,NOCC,NVIR,
     *           IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,JBAT,TIME4,TIME5)
C
         END DO                 !IBAT
      END DO                    !JBAT
      E2 = E2S+E2T
C
      IF(MASWRK) WRITE(IW,9999) TIMER,TIME4,TIME5
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 3/3 INTEGRAL READ           =    ',F9.1,
     *       /1X,'TIME OF TEI GENERATION              =    ',F9.1,
     *       /1X,'TIME OF MP2 ENERGY ACCUMULATION     =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIMP2E2ACCP2
      SUBROUTINE RIMP2E2ACCP2(EIG,BB,BK,Q,INFOCCBAT,E2,E2T,E2S,
     *     NAUXBAS,NORB,NOCC,NVIR,NOCCBAT,IW)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION EIG(*),BB(NAUXBAS,NVIR,*),BK(NAUXBAS,NVIR,*),Q(*)
      INTEGER INFOCCBAT(2,NOCCBAT)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      INTEGER D_V,D_TA,D_TB
      COMMON /RIMPDD/ D_V,D_TA,D_TB
C
      PARAMETER (ZERO=0.0D+00)
C
C     GENERATE 4C-2E ERI FROM 3 INDICES INTERMEDIATE MATRICES
C     AND ACCUMULATE MP2 CORRELATION ENERGY.
C     THIS SUBROUTINE IS FOR PARALLEL CALCULATIONS.
C
      TIMEC = ZERO
      TIME4 = ZERO
      TIME5 = ZERO
C
      LENT3 = NAUXBAS*NVIR
C
      MYPROC = ME+1
      NBATP1 = NOCCBAT/NPROC
      NBATP1C = NBATP1/2
C      WRITE(6,*) 'NPROC=',NPROC,'ME=',ME,'MYPROC=',MYPROC
C      WRITE(6,*) 'NOCCBAT=',NOCCBAT,'NBATP1=',NBATP1,'NBATP1C=',NBATP1C
C
      E2T = ZERO
      E2S = ZERO
      DO JBATP1 = 1, NBATP1
         DO JPDIF = 1, NPROC/2
            J2PROC = MYPROC+JPDIF
            IF(J2PROC .GT. NPROC) J2PROC = J2PROC-NPROC
            J2BAT = (J2PROC-1)*NBATP1+JBATP1
            JOCCBG = INFOCCBAT(1,J2BAT)+1
            JOCCED = INFOCCBAT(1,J2BAT)+INFOCCBAT(2,J2BAT)
C            WRITE(6,*) 'JBAT=',JBAT,'JOCCBG=',JOCCBG,'JOCCED=',JOCCED
            CALL TSECND(TIMEC0)
            CALL DDI_GET(D_TA,1,LENT3,JOCCBG,JOCCED,BK)
            CALL TSECND(TIMEC1)
            TIMEC = TIMEC+(TIMEC1-TIMEC0)
            IBATBG = (MYPROC-1)*NBATP1+1
            IBATED = MYPROC*NBATP1
            IF(MOD(NPROC,2) .EQ. 0 .AND. JPDIF .EQ. NPROC/2) THEN
               IF(MYPROC .LT. J2PROC) THEN
                  IF(JBATP1 .LE. NBATP1C) THEN
                     IBATBG = (MYPROC-1)*NBATP1+1
                     IBATED = (MYPROC-1)*NBATP1+NBATP1C
                  ELSE
                     IBATBG = (MYPROC-1)*NBATP1+NBATP1C+1
                     IBATED = MYPROC*NBATP1
                  END IF
               ELSE
                  IF(JBATP1 .LE. NBATP1C) THEN
                     IBATBG = (MYPROC-1)*NBATP1+NBATP1C+1
                     IBATED = MYPROC*NBATP1
                  ELSE
                     IBATBG = (MYPROC-1)*NBATP1+1
                     IBATED = (MYPROC-1)*NBATP1+NBATP1C
                  END IF
               END IF
            END IF
            DO IBAT = IBATBG, IBATED
               IOCCBG = INFOCCBAT(1,IBAT)+1
               IOCCED = INFOCCBAT(1,IBAT)+INFOCCBAT(2,IBAT)
C          WRITE(6,*) 'IBAT=',IBAT,'IOCCBG=',IOCCBG,'IOCCED=',IOCCED
               CALL TSECND(TIMEC0)
               CALL DDI_GET(D_TA,1,LENT3,IOCCBG,IOCCED,BB)
               CALL TSECND(TIMEC1)
               TIMEC = TIMEC+(TIMEC1-TIMEC0)
C
               CALL RIMP2TEIE2(EIG,BB,BK,Q,E2T,E2S,NAUXBAS,NORB,NOCC,
     *              NVIR,IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,J2BAT,
     *              TIME4,TIME5)
C
            END DO              !IBAT
         END DO                 !JPDIF
C
         J1BAT = (MYPROC-1)*NBATP1+JBATP1
         JOCCBG = INFOCCBAT(1,J1BAT)+1
         JOCCED = INFOCCBAT(1,J1BAT)+INFOCCBAT(2,J1BAT)
         CALL TSECND(TIMEC0)
         CALL DDI_GET(D_TA,1,LENT3,JOCCBG,JOCCED,BK)
         CALL TSECND(TIMEC1)
         TIMEC = TIMEC+(TIMEC1-TIMEC0)
         IBATBG = (MYPROC-1)*NBATP1+1
         DO IBAT = IBATBG, J1BAT
            IOCCBG = INFOCCBAT(1,IBAT)+1
            IOCCED = INFOCCBAT(1,IBAT)+INFOCCBAT(2,IBAT)
C            WRITE(6,*) 'IBAT=',IBAT,'IOCCBG=',IOCCBG,'IOCCED=',IOCCED
            CALL TSECND(TIMEC0)
            IF(IBAT .NE. J1BAT) THEN
               CALL DDI_GET(D_TA,1,LENT3,IOCCBG,IOCCED,BB)
            ELSE
               CALL DCOPY(LENT3*INFOCCBAT(2,IBAT),BK,1,BB,1)
            END IF
            CALL TSECND(TIMEC1)
            TIMEC = TIMEC+(TIMEC1-TIMEC0)
C
            CALL RIMP2TEIE2(EIG,BB,BK,Q,E2T,E2S,NAUXBAS,NORB,NOCC,NVIR,
     *           IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,J1BAT,TIME4,TIME5)
C
         END DO                 !IBAT
      END DO                    !JBATP1
C
      CALL DDI_GSUMF(3100,E2T,1)
      CALL DDI_GSUMF(3101,E2S,1)
      E2 = E2T+E2S
C
      IF(MASWRK) WRITE(IW,9999) TIMEC,TIME4,TIME5
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 3/3 INTEGRAL NETWORK COMM.  =    ',F9.1,
     *       /1X,'TIME OF TEI GENERATION              =    ',F9.1,
     *       /1X,'TIME OF MP2 ENERGY ACCUMULATION     =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIMP2E2ACCP2SMP
      SUBROUTINE RIMP2E2ACCP2SMP(EIG,BB,BK,Q,INFOCCBAT,E2,E2T,E2S,
     *     NAUXBAS,NORB,NOCC,NVIR,NOCCBAT,
     *     IW,DDI_NN,DDI_MY,SMP_NP,SMP_ME)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION EIG(*),BB(NAUXBAS,NVIR,*),BK(NAUXBAS,NVIR,*),Q(*)
      INTEGER INFOCCBAT(2,NOCCBAT)
C
      INTEGER DDI_NN,DDI_MY,SMP_NP,SMP_ME
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      INTEGER D_V,D_TA,D_TB
      COMMON /RIMPDD/ D_V,D_TA,D_TB
C
      PARAMETER (ZERO=0.0D+00)
C
C     GENERATE 4C-2E ERI FROM 3 INDICES INTERMEDIATE MATRICES
C     AND ACCUMULATE MP2 CORRELATION ENERGY.
C     THIS SUBROUTINE IS FOR PARALLEL CALCULATIONS.
C
      TIMEC = ZERO
      TIME4 = ZERO
      TIME5 = ZERO
C
      LENT3 = NAUXBAS*NVIR
C
      MYNODE = DDI_MY+1
      NBATP1 = NOCCBAT/DDI_NN
      NBATP1C = NBATP1/2
C
      E2T = ZERO
      E2S = ZERO
      DO JBATP1 = 1, NBATP1
         DO JPDIF = 1, DDI_NN/2
            J2NODE = MYNODE+JPDIF
            IF(J2NODE .GT. DDI_NN) J2NODE = J2NODE-DDI_NN
            J2BAT = (J2NODE-1)*NBATP1+JBATP1
            JOCCBG = INFOCCBAT(1,J2BAT)+1
            JOCCED = INFOCCBAT(1,J2BAT)+INFOCCBAT(2,J2BAT)
C            WRITE(6,*) 'J2BAT=',J2BAT,'JOCCBG=',JOCCBG,'JOCCED=',JOCCED
            CALL TSECND(TIMEC0)
            IF(SMP_ME .EQ. 0)
     *           CALL DDI_GET(D_TA,1,LENT3,JOCCBG,JOCCED,BK)
            CALL DDI_SMP_SYNC()
            CALL TSECND(TIMEC1)
            TIMEC = TIMEC+(TIMEC1-TIMEC0)
            IBATBG = (MYNODE-1)*NBATP1+1
            IBATED = MYNODE*NBATP1
            IF(MOD(DDI_NN,2) .EQ. 0 .AND. JPDIF .EQ. DDI_NN/2) THEN
               IF(MYNODE .LT. J2NODE) THEN
                  IF(JBATP1 .LE. NBATP1C) THEN
                     IBATBG = (MYNODE-1)*NBATP1+1
                     IBATED = (MYNODE-1)*NBATP1+NBATP1C
                  ELSE
                     IBATBG = (MYNODE-1)*NBATP1+NBATP1C+1
                     IBATED = MYNODE*NBATP1
                  END IF
               ELSE
                  IF(JBATP1 .LE. NBATP1C) THEN
                     IBATBG = (MYNODE-1)*NBATP1+NBATP1C+1
                     IBATED = MYNODE*NBATP1
                  ELSE
                     IBATBG = (MYNODE-1)*NBATP1+1
                     IBATED = (MYNODE-1)*NBATP1+NBATP1C
                  END IF
               END IF
            END IF
            CALL DDI_SMP_SYNC()
            DO IBAT = IBATBG, IBATED
               IOCCBG = INFOCCBAT(1,IBAT)+1
               IOCCED = INFOCCBAT(1,IBAT)+INFOCCBAT(2,IBAT)
C          WRITE(6,*) 'IBAT=',IBAT,'IOCCBG=',IOCCBG,'IOCCED=',IOCCED
               CALL TSECND(TIMEC0)
               IF(SMP_ME .EQ. 0)
     *              CALL DDI_GET(D_TA,1,LENT3,IOCCBG,IOCCED,BB)
               CALL DDI_SMP_SYNC()
               CALL TSECND(TIMEC1)
               TIMEC = TIMEC+(TIMEC1-TIMEC0)
C
               CALL RIMP2TEIE2SMP(EIG,BB,BK,Q,E2T,E2S,NAUXBAS,NORB,NOCC,
     *              NVIR,IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,J2BAT,
     *              TIME4,TIME5,SMP_NP,SMP_ME)
C
               CALL DDI_SMP_SYNC()
            END DO              !IBAT
         END DO                 !JPDIF
C
         J1BAT = (MYNODE-1)*NBATP1+JBATP1
         JOCCBG = INFOCCBAT(1,J1BAT)+1
         JOCCED = INFOCCBAT(1,J1BAT)+INFOCCBAT(2,J1BAT)
         CALL TSECND(TIMEC0)
         IF(SMP_ME .EQ. 0) CALL DDI_GET(D_TA,1,LENT3,JOCCBG,JOCCED,BK)
         CALL DDI_SMP_SYNC()
         CALL TSECND(TIMEC1)
         TIMEC = TIMEC+(TIMEC1-TIMEC0)
         IBATBG = (MYNODE-1)*NBATP1+1
         DO IBAT = IBATBG, J1BAT
            IOCCBG = INFOCCBAT(1,IBAT)+1
            IOCCED = INFOCCBAT(1,IBAT)+INFOCCBAT(2,IBAT)
            CALL TSECND(TIMEC0)
            IF(SMP_ME .EQ. 0) THEN
               IF(IBAT .NE. J1BAT) THEN
                  CALL DDI_GET(D_TA,1,LENT3,IOCCBG,IOCCED,BB)
               ELSE
                  CALL DCOPY(LENT3*INFOCCBAT(2,IBAT),BK,1,BB,1)
               END IF
            END IF
            CALL DDI_SMP_SYNC()
            CALL TSECND(TIMEC1)
            TIMEC = TIMEC+(TIMEC1-TIMEC0)
C
            CALL RIMP2TEIE2SMP(EIG,BB,BK,Q,E2T,E2S,NAUXBAS,NORB,NOCC,
     *           NVIR,IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,J1BAT,
     *           TIME4,TIME5,SMP_NP,SMP_ME)
C
            CALL DDI_SMP_SYNC()
         END DO                 !IBAT
      END DO                    !JBATP1
C
      CALL DDI_GSUMF(3100,E2T,1)
      CALL DDI_GSUMF(3101,E2S,1)
      E2 = E2T+E2S
C
      IF(MASWRK) WRITE(IW,9999) TIMEC,TIME4,TIME5
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 3/3 INTEGRAL NETWORK COMM.  =    ',F9.1,
     *       /1X,'TIME OF TEI GENERATION              =    ',F9.1,
     *       /1X,'TIME OF MP2 ENERGY ACCUMULATION     =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIMP2E2ACCP
      SUBROUTINE RIMP2E2ACCP(EIG,BB,BK1,BK2,Q,INFOCCBAT,E2,E2T,E2S,
     *     NAUXBAS,NORB,NOCC,NVIR,NOCCBAT,LENOCCBAT,IFILT3,IW)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION EIG(*),BB(NAUXBAS,NVIR,*),BK1(NAUXBAS,NVIR,*),
     *     BK2(NAUXBAS,NVIR,*),Q(*)
      INTEGER INFOCCBAT(2,NOCCBAT)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ZERO=0.0D+00)
C
C     GENERATE 4C-2E ERI FROM 3 INDICES INTERMEDIATE MATRICES
C     AND ACCUMULATE MP2 CORRELATION ENERGY.
C     THIS SUBROUTINE IS FOR PARALLEL CALCULATIONS.
C
      TIMER = ZERO
      TIMEC = ZERO
      TIME4 = ZERO
      TIME5 = ZERO
C
      LENT3 = NAUXBAS*NVIR
      LENB = NAUXBAS*NVIR*LENOCCBAT
C
      MYPROC = ME+1
      NBATP1 = NOCCBAT/NPROC
      NBATP1C = NBATP1/2
C
      E2T = ZERO
      E2S = ZERO
      DO JBATP1 = 1, NBATP1
         J1BAT = (MYPROC-1)*NBATP1+JBATP1
         J1OCCBG = INFOCCBAT(1,J1BAT)+1
         J1OCCED = INFOCCBAT(1,J1BAT)+INFOCCBAT(2,J1BAT)
         CALL TSECND(TIMER0)
         DO JOCC = J1OCCBG, J1OCCED
            J = JOCC-J1OCCBG+1
            CALL RIMP2T3RD(BK1(1,1,J),LENT3,IFILT3,JOCC)
         END DO
         CALL TSECND(TIMER1)
         TIMER = TIMER+(TIMER1-TIMER0)
         DO JPDIF = 1, NPROC/2
            J1PROC = MYPROC-JPDIF
            J2PROC = MYPROC+JPDIF
            IF(J1PROC .LE. 0)     J1PROC = J1PROC+NPROC
            IF(J2PROC .GT. NPROC) J2PROC = J2PROC-NPROC
            J1RANK = J1PROC-1
            J2RANK = J2PROC-1
            CALL TSECND(TIMEC0)
            CALL DDI_ISEND(BK1,8*LENB,J1RANK,IREQ1)
            CALL DDI_IRECV(BK2,8*LENB,J2RANK,IREQ2)
            CALL DDI_WAIT(IREQ1)
            CALL DDI_WAIT(IREQ2)
            CALL TSECND(TIMEC1)
            TIMEC = TIMEC+(TIMEC1-TIMEC0)
            J2BAT = (J2PROC-1)*NBATP1+JBATP1
            JOCCBG = INFOCCBAT(1,J2BAT)+1
            JOCCED = INFOCCBAT(1,J2BAT)+INFOCCBAT(2,J2BAT)
            IBATBG = (MYPROC-1)*NBATP1+1
            IBATED = MYPROC*NBATP1
            IF(MOD(NPROC,2) .EQ. 0 .AND. JPDIF .EQ. NPROC/2) THEN
               IF(MYPROC .LT. J2PROC) THEN
                  IF(JBATP1 .LE. NBATP1C) THEN
                     IBATBG = (MYPROC-1)*NBATP1+1
                     IBATED = (MYPROC-1)*NBATP1+NBATP1C
                  ELSE
                     IBATBG = (MYPROC-1)*NBATP1+NBATP1C+1
                     IBATED = MYPROC*NBATP1
                  END IF
               ELSE
                  IF(JBATP1 .LE. NBATP1C) THEN
                     IBATBG = (MYPROC-1)*NBATP1+NBATP1C+1
                     IBATED = MYPROC*NBATP1
                  ELSE
                     IBATBG = (MYPROC-1)*NBATP1+1
                     IBATED = (MYPROC-1)*NBATP1+NBATP1C
                  END IF
               END IF
            END IF
            DO IBAT = IBATBG, IBATED
               IOCCBG = INFOCCBAT(1,IBAT)+1
               IOCCED = INFOCCBAT(1,IBAT)+INFOCCBAT(2,IBAT)
               CALL TSECND(TIMER0)
               DO IOCC = IOCCBG, IOCCED
                  I = IOCC-IOCCBG+1
                  CALL RIMP2T3RD(BB(1,1,I),LENT3,IFILT3,IOCC)
               END DO
               CALL TSECND(TIMER1)
               TIMER = TIMER+(TIMER1-TIMER0)
C
               CALL RIMP2TEIE2(EIG,BB,BK2,Q,E2T,E2S,NAUXBAS,NORB,NOCC,
     *              NVIR,IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,J2BAT,
     *              TIME4,TIME5)
C
            END DO              !IBAT
         END DO                 !JPDIF
C
         IBATBG = (MYPROC-1)*NBATP1+1
         JOCCBG = J1OCCBG
         JOCCED = J1OCCED
         DO IBAT = IBATBG, J1BAT
            IOCCBG = INFOCCBAT(1,IBAT)+1
            IOCCED = INFOCCBAT(1,IBAT)+INFOCCBAT(2,IBAT)
            CALL TSECND(TIMER0)
            IF(IBAT .NE. J1BAT) THEN
               DO IOCC = IOCCBG, IOCCED
                  I = IOCC-IOCCBG+1
                  CALL RIMP2T3RD(BB(1,1,I),LENT3,IFILT3,IOCC)
               END DO
            ELSE
               CALL DCOPY(LENT3*INFOCCBAT(2,IBAT),BK1,1,BB,1)
            END IF
            CALL TSECND(TIMER1)
            TIMER = TIMER+(TIMER1-TIMER0)
C
            CALL RIMP2TEIE2(EIG,BB,BK1,Q,E2T,E2S,NAUXBAS,NORB,NOCC,NVIR,
     *           IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,J1BAT,TIME4,TIME5)
C
         END DO                 !IBAT
      END DO                    !JBATP1
C
      CALL DDI_GSUMF(3100,E2T,1)
      CALL DDI_GSUMF(3101,E2S,1)
      E2 = E2T+E2S
C
      IF(MASWRK) WRITE(IW,9999) TIMER,TIMEC,TIME4,TIME5
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 3/3 INTEGRAL READ           =    ',F9.1,
     *       /1X,'TIME OF 3/3 INTEGRAL NETWORK COMM.  =    ',F9.1,
     *       /1X,'TIME OF TEI GENERATION              =    ',F9.1,
     *       /1X,'TIME OF MP2 ENERGY ACCUMULATION     =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIMP2E2ACCPSMP
      SUBROUTINE RIMP2E2ACCPSMP(EIG,BB,BK1,BK2,Q,INFOCCBAT,E2,E2T,E2S,
     *     NAUXBAS,NORB,NOCC,NVIR,NOCCBAT,LENOCCBAT,IFILT3,IW,
     *     DDI_NN,DDI_MY,SMP_NP,SMP_ME)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION EIG(*),BB(NAUXBAS,NVIR,*),BK1(NAUXBAS,NVIR,*),
     *     BK2(NAUXBAS,NVIR,*),Q(*)
      INTEGER INFOCCBAT(2,NOCCBAT)
C
      INTEGER DDI_NN,DDI_MY,SMP_NP,SMP_ME
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ZERO=0.0D+00)
C
C     GENERATE 4C-2E ERI FROM 3 INDICES INTERMEDIATE MATRICES
C     AND ACCUMULATE MP2 CORRELATION ENERGY.
C     THIS SUBROUTINE IS FOR PARALLEL CALCULATIONS.
C
      TIMER = ZERO
      TIMEC = ZERO
      TIME4 = ZERO
      TIME5 = ZERO
C
      LENT3 = NAUXBAS*NVIR
      LENB = NAUXBAS*NVIR*LENOCCBAT
C
      MYNODE = DDI_MY+1
      NBATP1 = NOCCBAT/DDI_NN
      NBATP1C = NBATP1/2
C
      E2T = ZERO
      E2S = ZERO
      DO JBATP1 = 1, NBATP1
         J1BAT = (MYNODE-1)*NBATP1+JBATP1
         J1OCCBG = INFOCCBAT(1,J1BAT)+1
         J1OCCED = INFOCCBAT(1,J1BAT)+INFOCCBAT(2,J1BAT)
         CALL TSECND(TIMER0)
         IF(SMP_ME .EQ. 0) THEN
            DO JOCC = J1OCCBG, J1OCCED
               J = JOCC-J1OCCBG+1
               CALL RIMP2T3RD(BK1(1,1,J),LENT3,IFILT3,JOCC)
            END DO
         END IF
         CALL DDI_SMP_SYNC()
         CALL TSECND(TIMER1)
         TIMER = TIMER+(TIMER1-TIMER0)
         DO JPDIF = 1, DDI_NN/2
            J1NODE = MYNODE-JPDIF
            J2NODE = MYNODE+JPDIF
            IF(J1NODE .LE. 0)      J1NODE = J1NODE+DDI_NN
            IF(J2NODE .GT. DDI_NN) J2NODE = J2NODE-DDI_NN
C       WRITE(6,*) 'MYNODE=',MYNODE,'J1NODE=',J1NODE,'J2NODE=',J2NODE
            CALL TSECND(TIMEC0)
            IF(SMP_ME .EQ. 0) THEN
               J1RANK = (J1NODE-1)*SMP_NP
               J2RANK = (J2NODE-1)*SMP_NP
C               WRITE(6,*) 'MYNODE=',MYNODE,'J1RANK=',J1RANK,
C     *              'J2RANK=',J2RANK
               CALL DDI_ISEND(BK1,8*LENB,J1RANK,IREQ1)
               CALL DDI_IRECV(BK2,8*LENB,J2RANK,IREQ2)
               CALL DDI_WAIT(IREQ1)
               CALL DDI_WAIT(IREQ2)
            END IF
            CALL DDI_SMP_SYNC()
            CALL TSECND(TIMEC1)
            TIMEC = TIMEC+(TIMEC1-TIMEC0)
            J2BAT = (J2NODE-1)*NBATP1+JBATP1
            JOCCBG = INFOCCBAT(1,J2BAT)+1
            JOCCED = INFOCCBAT(1,J2BAT)+INFOCCBAT(2,J2BAT)
C            WRITE(6,*) 'J2BAT=',J2BAT,'JOCCBG=',JOCCBG,'JOCCED=',JOCCED
            IBATBG = (MYNODE-1)*NBATP1+1
            IBATED = MYNODE*NBATP1
            IF(MOD(DDI_NN,2) .EQ. 0 .AND. JPDIF .EQ. DDI_NN/2) THEN
               IF(MYNODE .LT. J2NODE) THEN
                  IF(JBATP1 .LE. NBATP1C) THEN
                     IBATBG = (MYNODE-1)*NBATP1+1
                     IBATED = (MYNODE-1)*NBATP1+NBATP1C
                  ELSE
                     IBATBG = (MYNODE-1)*NBATP1+NBATP1C+1
                     IBATED = MYNODE*NBATP1
                  END IF
               ELSE
                  IF(JBATP1 .LE. NBATP1C) THEN
                     IBATBG = (MYNODE-1)*NBATP1+NBATP1C+1
                     IBATED = MYNODE*NBATP1
                  ELSE
                     IBATBG = (MYNODE-1)*NBATP1+1
                     IBATED = (MYNODE-1)*NBATP1+NBATP1C
                  END IF
               END IF
            END IF
            CALL DDI_SMP_SYNC()
            DO IBAT = IBATBG, IBATED
               IOCCBG = INFOCCBAT(1,IBAT)+1
               IOCCED = INFOCCBAT(1,IBAT)+INFOCCBAT(2,IBAT)
C          WRITE(6,*) 'IBAT=',IBAT,'IOCCBG=',IOCCBG,'IOCCED=',IOCCED
               CALL TSECND(TIMER0)
               IF(SMP_ME .EQ. 0) THEN
                  DO IOCC = IOCCBG, IOCCED
                     I = IOCC-IOCCBG+1
                     CALL RIMP2T3RD(BB(1,1,I),LENT3,IFILT3,IOCC)
                  END DO
               END IF
               CALL DDI_SMP_SYNC()
               CALL TSECND(TIMER1)
               TIMER = TIMER+(TIMER1-TIMER0)
C
               CALL RIMP2TEIE2SMP(EIG,BB,BK2,Q,E2T,E2S,NAUXBAS,NORB,
     *              NOCC,NVIR,IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,J2BAT,
     *              TIME4,TIME5,SMP_NP,SMP_ME)
C
               CALL DDI_SMP_SYNC()
            END DO              !IBAT
         END DO                 !JPDIF
C
         IBATBG = (MYNODE-1)*NBATP1+1
         JOCCBG = J1OCCBG
         JOCCED = J1OCCED
         DO IBAT = IBATBG, J1BAT
            IOCCBG = INFOCCBAT(1,IBAT)+1
            IOCCED = INFOCCBAT(1,IBAT)+INFOCCBAT(2,IBAT)
C            WRITE(6,*) 'IBAT=',IBAT,'IOCCBG=',IOCCBG,'IOCCED=',IOCCED
            CALL TSECND(TIMER0)
            IF(SMP_ME .EQ. 0) THEN
               IF(IBAT .NE. J1BAT) THEN
                  DO IOCC = IOCCBG, IOCCED
                     I = IOCC-IOCCBG+1
                     CALL RIMP2T3RD(BB(1,1,I),LENT3,IFILT3,IOCC)
                  END DO
               ELSE
                  CALL DCOPY(LENT3*INFOCCBAT(2,IBAT),BK1,1,BB,1)
               END IF
            END IF
            CALL DDI_SMP_SYNC()
            CALL TSECND(TIMER1)
            TIMER = TIMER+(TIMER1-TIMER0)
C
            CALL RIMP2TEIE2SMP(EIG,BB,BK1,Q,E2T,E2S,NAUXBAS,NORB,NOCC,
     *           NVIR,IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,J1BAT,
     *           TIME4,TIME5,SMP_NP,SMP_ME)
C
            CALL DDI_SMP_SYNC()
         END DO                 !IBAT
      END DO                    !JBATP1
C
      CALL DDI_GSUMF(3100,E2T,1)
      CALL DDI_GSUMF(3101,E2S,1)
      E2 = E2T+E2S
C
      IF(MASWRK) WRITE(IW,9999) TIMER,TIMEC,TIME4,TIME5
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 3/3 INTEGRAL READ           =    ',F9.1,
     *       /1X,'TIME OF 3/3 INTEGRAL NETWORK COMM.  =    ',F9.1,
     *       /1X,'TIME OF TEI GENERATION              =    ',F9.1,
     *       /1X,'TIME OF MP2 ENERGY ACCUMULATION     =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIMP2E2ACCSMP
      SUBROUTINE RIMP2E2ACCSMP(EIG,BB,BK,Q,INFOCCBAT,E2,E2T,E2S,
     *     NAUXBAS,NORB,NOCC,NVIR,NOCCBAT,
     *     IFILT3,IW,MASWRK,SMP_NP,SMP_ME,USEDM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL MASWRK
      LOGICAL USEDM
C
      DOUBLE PRECISION EIG(*),BB(NAUXBAS,NVIR,*),BK(NAUXBAS,NVIR,*),Q(*)
      INTEGER INFOCCBAT(2,NOCCBAT)
C
      INTEGER SMP_NP,SMP_ME
C
      INTEGER D_V,D_T,D_TB
      COMMON /RIMPDD/ D_V,D_T,D_TB
C
      PARAMETER (ZERO=0.0D+00)
C
C     GENERATE 4C-2E ERI FROM 3 INDICES INTERMEDIATE MATRICES
C     AND ACCUMULATE MP2 CORRELATION ENERGY.
C
      TIMER = ZERO
      TIME4 = ZERO
      TIME5 = ZERO
C
      LENT3 = NAUXBAS*NVIR
C
      E2T = ZERO
      E2S = ZERO
      DO JBAT = 1, NOCCBAT
         JOCCBG = INFOCCBAT(1,JBAT)+1
         JOCCED = INFOCCBAT(1,JBAT)+INFOCCBAT(2,JBAT)
         CALL TSECND(TIMER0)
         IF(SMP_ME .EQ. 0) THEN
            IF(.NOT. USEDM) THEN
               DO JOCC = JOCCBG, JOCCED
                  J = JOCC-JOCCBG+1
                  CALL RIMP2T3RD(BK(1,1,J),LENT3,IFILT3,JOCC)
               END DO
            ELSE
               CALL DDI_GET(D_T,1,LENT3,JOCCBG,JOCCED,BK)
            END IF
         END IF
         CALL DDI_SMP_SYNC()
         CALL TSECND(TIMER1)
         TIMER = TIMER+(TIMER1-TIMER0)
         DO IBAT = 1, JBAT
            IOCCBG = INFOCCBAT(1,IBAT)+1
            IOCCED = INFOCCBAT(1,IBAT)+INFOCCBAT(2,IBAT)
            CALL TSECND(TIMER0)
            IF(SMP_ME .EQ. 0) THEN
               IF(IBAT .NE. JBAT) THEN
                  IF(.NOT. USEDM) THEN
                     DO IOCC = IOCCBG, IOCCED
                        I = IOCC-IOCCBG+1
                        CALL RIMP2T3RD(BB(1,1,I),LENT3,IFILT3,IOCC)
                     END DO
                  ELSE
                     CALL DDI_GET(D_T,1,LENT3,IOCCBG,IOCCED,BB)
                  END IF
               ELSE
                  CALL DCOPY(LENT3*INFOCCBAT(2,JBAT),BK,1,BB,1)
               END IF
            END IF
            CALL DDI_SMP_SYNC()
            CALL TSECND(TIMER1)
            TIMER = TIMER+(TIMER1-TIMER0)
C
            CALL RIMP2TEIE2SMP(EIG,BB,BK,Q,E2T,E2S,NAUXBAS,NORB,NOCC,
     *           NVIR,IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,JBAT,TIME4,TIME5,
     *           SMP_NP,SMP_ME)
C
            CALL DDI_SMP_SYNC()
         END DO                 !IBAT
      END DO                    !JBAT
      E2 = E2S+E2T
C
      IF(MASWRK) WRITE(IW,9999) TIMER,TIME4,TIME5
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 3/3 INTEGRAL READ           =    ',F9.1,
     *       /1X,'TIME OF TEI GENERATION              =    ',F9.1,
     *       /1X,'TIME OF MP2 ENERGY ACCUMULATION     =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIMP2E2
      SUBROUTINE RIMP2E2(EIG,Q,E2T,E2S,NORB,NOCC,NVIR,IOCC,JOCC)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION EIG(NORB),Q(NVIR,NVIR)
C
C     ACCUMULATE MP2 CORRELATION ENERGY
C
      DO JVIR = 1, NVIR
         DO IVIR = 1, NVIR
            T2 = Q(IVIR,JVIR)
     *           /(EIG(IOCC)+EIG(JOCC)-EIG(NOCC+IVIR)-EIG(NOCC+JVIR))
            E2T = E2T+T2*(Q(IVIR,JVIR)-Q(JVIR,IVIR))
            E2S = E2S+T2*Q(IVIR,JVIR)
         END DO
      END DO
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIMP2E2SMP
      SUBROUTINE RIMP2E2SMP(EIG,Q,E2T,E2S,NORB,NOCC,NVIR,IOCC,JOCC,
     *     SMP_NP,SMP_ME)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION EIG(NORB),Q(NVIR,NVIR)
C
      INTEGER SMP_NP,SMP_ME
      INTEGER NR,SR
C
C     ACCUMULATE MP2 CORRELATION ENERGY
C
      CALL DIV_EVEN(NVIR,SMP_NP,SMP_ME,NR,SR)
      DO JVIR = SR, SR+NR-1
         DO IVIR = 1, NVIR
            T2 = Q(IVIR,JVIR)
     *           /(EIG(IOCC)+EIG(JOCC)-EIG(NOCC+IVIR)-EIG(NOCC+JVIR))
            E2T = E2T+T2*(Q(IVIR,JVIR)-Q(JVIR,IVIR))
            E2S = E2S+T2*Q(IVIR,JVIR)
         END DO
      END DO
      CALL DDI_SMP_SYNC()
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIMP2ENG
      SUBROUTINE RIMP2ENG(INFOCCABAT,INFOCCBBAT,E2,E2T,E2S,
     *     NBASIS,NAUXBAS,NORBA,NORBB,NOCCA,NOCCB,NVIRA,NVIRB,
     *     NACORE,NBCORE,NOCCBAT,LENOCCABAT,LENOCCBBAT,USEDM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL USEDM
C
      INTEGER INFOCCABAT(2,NOCCBAT),INFOCCBBAT(2,NOCCBAT)
C
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      COMMON /RIMPFI/ IFILV,IFILT2A,IFILT3A,IFILT2B,IFILT3B
C
      INTEGER D_V,D_TA,D_TB
      COMMON /RIMPDD/ D_V,D_TA,D_TB
C
      DATA CHECK    /8HCHECK   /
      DATA UHF      /8HUHF     /
      DATA RHF      /8HRHF     /
C
C     SUBROUTINE OF RI-MP2 ENERGY CALCULATION PROGRAM FOR
C     GENERATE 4C-2E ELECTRON REPULSION INTEGRALS FROM 3C-2E
C     INTEGRAL MATRICES AND ACCUMULATE MP2 CORRELATION ENERGY.
C
C     WRITTEN BY MICHIO KATOUDA (INSTITUTE OF MOLECULAR SCIENCE)
C     JAPAN,
C     FEBRUARY 21, 2008.
C
C     ALLOCATE MEMORY
C
      CALL VALFM(LOADFM)
      IF(SCFTYP .EQ. RHF) THEN
         L1 = NVIRA*NVIRA
         L2 = NAUXBAS*NVIRA*LENOCCABAT
         LEIGA    = LOADFM   + 1
         LBB      = LEIGA    + NBASIS
         LBK1     = LBB      + L2
         IF(GOPARR .AND. .NOT. USEDM) THEN
            LBK2     = LBK1     + L2
            LQ       = LBK2     + L2
         ELSE
            LQ       = LBK1     + L2
         END IF
         LAST     = LQ       + L1
      ELSE IF(SCFTYP .EQ. UHF) THEN
         L1 = MAX(NVIRA,NVIRB)**2
         L2 = NAUXBAS*MAX(NVIRA,NVIRB)*MAX(LENOCCABAT,LENOCCBBAT)
         LEIGA    = LOADFM   + 1
         LEIGB    = LEIGA    + NBASIS
         LBB      = LEIGB    + NBASIS
         LBK1     = LBB      + L2
         IF(GOPARR .AND. .NOT. USEDM) THEN
            LBK2     = LBK1     + L2
            LQ       = LBK2     + L2
         ELSE
            LQ       = LBK1     + L2
         END IF
         LAST     = LQ       + L1
      END IF
      INEED    = LAST-LOADFM-1
      IF(MASWRK) WRITE(IW,9010) INEED
      CALL FLSHBF(IW)
      CALL GETFM(INEED)
      IF(EXETYP .EQ. CHECK) GO TO 1000
C
C     READ MOLECULAR ORBITAL ENERGY
C
      CALL DAREAD(IDAF,IODA,X(LEIGA),NBASIS,17,0)
      DO I = 1, NORBA
         X(LEIGA-1+I) = X(LEIGA-1+I+NACORE)
C         WRITE(6,'(I4,E20.10)') I,X(LEIGA-1+I)
      END DO
      IF(SCFTYP .EQ. UHF) THEN
         CALL DAREAD(IDAF,IODA,X(LEIGB),NBASIS,21,0)
         DO I = 1, NORBB
            X(LEIGB-1+I) = X(LEIGB-1+I+NBCORE)
C         WRITE(6,'(I4,E20.10)') I,X(LEIGB-1+I)
         END DO
      END IF
C
C     ACCUMULATE MP2 CORRELATION ENERGY
C
      IF(GOPARR .AND. .NOT. USEDM) THEN
         IF(SCFTYP .EQ. RHF) THEN
            CALL RIMP2E2ACCP(X(LEIGA),X(LBB),X(LBK1),X(LBK2),X(LQ),
     *           INFOCCABAT,E2,E2T,E2S,NAUXBAS,NORBA,NOCCA,NVIRA,
     *           NOCCBAT,LENOCCABAT,IFILT3A,IW)
         ELSE IF(SCFTYP .EQ. UHF) THEN
            CALL RIUMP2E2ACCAP(X(LEIGA),X(LBB),X(LBK1),X(LBK2),X(LQ),
     *           INFOCCABAT,E2TA,NAUXBAS,NORBA,NOCCA,NVIRA,NOCCBAT,
     *           LENOCCABAT,IFILT3A,IW)
            CALL RIUMP2E2ACCAP(X(LEIGB),X(LBB),X(LBK1),X(LBK2),X(LQ),
     *           INFOCCBBAT,E2TB,NAUXBAS,NORBB,NOCCB,NVIRB,NOCCBAT,
     *           LENOCCBBAT,IFILT3B,IW)
            CALL RIUMP2E2ACCBP(X(LEIGA),X(LEIGB),X(LBB),X(LBK1),X(LBK2),
     *           X(LQ),INFOCCABAT,INFOCCBBAT,E2S,
     *           NAUXBAS,NORBA,NORBB,NOCCA,NOCCB,NVIRA,NVIRB,
     *           NOCCBAT,LENOCCBBAT,IFILT3A,IFILT3B,IW)
            E2T = E2TA+E2TB
            CALL DDI_GSUMF(3100,E2T,1)
            CALL DDI_GSUMF(3101,E2S,1)
         END IF
      ELSE
         IF(SCFTYP .EQ. RHF) THEN
            IF(GOPARR) THEN
               CALL RIMP2E2ACCP2(X(LEIGA),X(LBB),X(LBK1),X(LQ),
     *              INFOCCABAT,E2,E2T,E2S,NAUXBAS,NORBA,NOCCA,NVIRA,
     *              NOCCBAT,IW)
            ELSE
               CALL RIMP2E2ACC(X(LEIGA),X(LBB),X(LBK1),X(LQ),INFOCCABAT,
     *              E2,E2T,E2S,NAUXBAS,NORBA,NOCCA,NVIRA,NOCCBAT,
     *              IFILT3A,IW,MASWRK,USEDM)
            END IF
         ELSE IF(SCFTYP .EQ. UHF) THEN
            IF(GOPARR) THEN
               CALL RIUMP2E2ACCAP2(X(LEIGA),X(LBB),X(LBK1),X(LQ),
     *              INFOCCABAT,E2TA,NAUXBAS,NORBA,NOCCA,NVIRA,NOCCBAT,
     *              IW,D_TA)
               CALL RIUMP2E2ACCAP2(X(LEIGB),X(LBB),X(LBK1),X(LQ),
     *              INFOCCBBAT,E2TB,NAUXBAS,NORBB,NOCCB,NVIRB,NOCCBAT,
     *              IW,D_TB)
               CALL RIUMP2E2ACCBP2(X(LEIGA),X(LEIGB),X(LBB),X(LBK1),
     *              X(LQ),INFOCCABAT,INFOCCBBAT,E2S,NAUXBAS,NORBA,NORBB,
     *              NOCCA,NOCCB,NVIRA,NVIRB,NOCCBAT,IW)
               E2T = E2TA+E2TB
               CALL DDI_GSUMF(3100,E2T,1)
               CALL DDI_GSUMF(3101,E2S,1)
            ELSE
               CALL RIUMP2E2ACCA(X(LEIGA),X(LBB),X(LBK1),X(LQ),
     *              INFOCCABAT,E2TA,NAUXBAS,NORBA,NOCCA,NVIRA,NOCCBAT,
     *              IFILT3A,IW,MASWRK,USEDM,D_TA)
               CALL RIUMP2E2ACCA(X(LEIGB),X(LBB),X(LBK1),X(LQ),
     *              INFOCCBBAT,E2TB,NAUXBAS,NORBB,NOCCB,NVIRB,NOCCBAT,
     *              IFILT3B,IW,MASWRK,USEDM,D_TB)
               CALL RIUMP2E2ACCB(X(LEIGA),X(LEIGB),X(LBB),X(LBK1),X(LQ),
     *              INFOCCABAT,INFOCCBBAT,
     *              E2S,NAUXBAS,NORBA,NORBB,NOCCA,NOCCB,NVIRA,NVIRB,
     *              NOCCBAT,IFILT3A,IFILT3B,IW,MASWRK,USEDM,D_TA,D_TB)
               E2T = E2TA+E2TB
            END IF
         END IF
      END IF
      E2 = E2T+E2S
C
 1000 CONTINUE
C
C     FREE MEMORY
C
      CALL RETFM(INEED)
C
      RETURN
 9010 FORMAT(/1X,'MEMORY REQUIRED FOR 4C-2E ERI GENERATION',
     *       /1X,'AND MP2 ENERGY ACCUMULATION',22X,'=',I12,' WORDS')
      END
C*MODULE RIMP2   *DECK RIMP2ENGSMP
      SUBROUTINE RIMP2ENGSMP(INFOCCABAT,INFOCCBBAT,E2,E2T,E2S,
     *     NBASIS,NAUXBAS,NORBA,NORBB,NOCCA,NOCCB,NVIRA,NVIRB,
     *     NACORE,NBCORE,NOCCBAT,LENOCCABAT,LENOCCBBAT,USEDM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL USEDM
      LOGICAL GONODE
C
      CHARACTER*1 ADDR(1)
      INTEGER DDI_NP,DDI_ME,DDI_NN,DDI_MY
      INTEGER SMP_NP,SMP_ME
C
      INTEGER D_BB,D_BK1,D_BK2,D_Q
      INTEGER LBB,LBK1,LBK2,LQ
      INTEGER SHARED_E2
C
      INTEGER INFOCCABAT(2,NOCCBAT),INFOCCBBAT(2,NOCCBAT)
C
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      COMMON /RIMPFI/ IFILV,IFILT2A,IFILT3A,IFILT2B,IFILT3B
C
      INTEGER D_V,D_TA,D_TB
      COMMON /RIMPDD/ D_V,D_TA,D_TB
C
      DATA CHECK    /8HCHECK   /
      DATA UHF      /8HUHF     /
      DATA RHF      /8HRHF     /
C
C     SUBROUTINE OF RI-MP2 ENERGY CALCULATION PROGRAM FOR
C     GENERATE 4C-2E ELECTRON REPULSION INTEGRALS FROM 3C-2E
C     INTEGRAL MATRICES AND ACCUMULATE MP2 CORRELATION ENERGY.
C
C     WRITTEN BY MICHIO KATOUDA (INSTITUTE OF MOLECULAR SCIENCE)
C     JAPAN,
C     FEBRUARY 21, 2008.
C
      CALL DDI_NPROC(DDI_NP,DDI_ME)
      CALL DDI_NNODE(DDI_NN,DDI_MY)
      CALL DDI_SMP_NPROC(SMP_NP,SMP_ME)
      GONODE = DDI_NN .GT. 1
C
C     ESTIMETE REPLICATED MEMORY
C
      CALL VALFM(LOADFM)
      IF(SCFTYP .EQ. RHF) THEN
         L1 = NVIRA*NVIRA
         L2 = NAUXBAS*NVIRA*LENOCCABAT
         LEIGA    = LOADFM   + 1
         LAST     = LEIGA    + NBASIS
      ELSE IF(SCFTYP .EQ. UHF) THEN
         L1 = MAX(NVIRA,NVIRB)**2
         L2 = NAUXBAS*MAX(NVIRA,NVIRB)*MAX(LENOCCABAT,LENOCCBBAT)
         LEIGA    = LOADFM   + 1
         LEIGB    = LEIGA    + NBASIS
         LAST     = LEIGB    + NBASIS
      END IF
      INEED    = LAST-LOADFM-1
      IF(MASWRK) WRITE(IW,9010) INEED
C
C     ESTIMATE SHARED MEMORY
C
      IF(GONODE) THEN
         SHARED_E2 = L1+3*L2
      ELSE
         SHARED_E2 = L1+2*L2
      END IF
      GBYTES = 8*SHARED_E2/(1024.0D+00**3)
      IF(MASWRK) WRITE(IW,9020) SHARED_E2,GBYTES
      CALL FLSHBF(IW)
C
C     ALLOCATE REPLICATED MEMORY
C
      CALL GETFM(INEED)
C
C     ALLOCATE SHARED MEMORY
C
C      CALL DDI_SMP_CREATE(NBASIS,D_EIGA)
C      IF(SCFTYP .EQ. UHF) CALL DDI_SMP_CREATE(NBASIS,D_EIGB)
      CALL DDI_SMP_CREATE(L2,D_BB)
      CALL DDI_SMP_CREATE(L2,D_BK1)
      IF(GONODE .AND. .NOT. USEDM) CALL DDI_SMP_CREATE(L2,D_BK2)
      CALL DDI_SMP_CREATE(L1,D_Q)
C     DETERMINE OFFSETS FOR SHARED MEMORY ARRAYS
C      CALL DDI_SMP_OFFSET(D_EIGA,ADDR,LEIGA1)
C      IF(SCFTYP .EQ. UHF) CALL DDI_SMP_OFFSET(D_EIGB,ADDR,LEIGB1)
      CALL DDI_SMP_OFFSET(D_BB,ADDR,LBB)
      CALL DDI_SMP_OFFSET(D_BK1,ADDR,LBK1)
      IF(GONODE .AND. .NOT. USEDM) CALL DDI_SMP_OFFSET(D_BK2,EDDR,LBK2)
      CALL DDI_SMP_OFFSET(D_Q,ADDR,LQ)
C
C      LEIGA1 = LEIGA1+1
C      IF(SCFTYP .EQ. UHF) LEIGB1+1
      LBB = LBB+1
      LBK1 = LBK1+1
      IF(GONODE) LBK2 = LBK2+1
      LQ = LQ+1
C
      CALL DDI_SMP_SYNC()
C
      IF(EXETYP .EQ. CHECK) GO TO 1000
C
C     READ MOLECULAR ORBITAL ENERGY, DROP CORE ORBITALS OUT.
C
C      IF(SMP_ME .EQ. 0) THEN
C         CALL DAREAD(IDAF,IODA,ADDR(LEIGA1),NBASIS,17,0)
C         CALL RIMP2EIGSFT(ADDR(LEIGA1),NORBA,NACORE)
C      END IF
      CALL DAREAD(IDAF,IODA,X(LEIGA),NBASIS,17,0)
      DO I = 1, NORBA
         X(LEIGA-1+I) = X(LEIGA-1+I+NACORE)
C         WRITE(6,'(I4,E20.10)') I,X(LEIGA-1+I)
      END DO
      IF(SCFTYP .EQ. UHF) THEN
C         IF(SMP_ME .EQ. 0) THEN
C            CALL DAREAD(IDAF,IODA,ADDR(LEIGB1),NBASIS,17,0)
C            CALL RIMP2EIGSFT(ADDR(LEIGB1),NORBB,NBCORE)
C         END IF
         CALL DAREAD(IDAF,IODA,X(LEIGB),NBASIS,21,0)
         DO I = 1, NORBB
            X(LEIGB-1+I) = X(LEIGB-1+I+NBCORE)
C         WRITE(6,'(I4,E20.10)') I,X(LEIGB-1+I)
         END DO
      END IF
C
C     ACCUMULATE MP2 CORRELATION ENERGY
C
      IF(GONODE .AND. .NOT. USEDM) THEN
         IF(SCFTYP .EQ. RHF) THEN
            CALL RIMP2E2ACCPSMP(X(LEIGA),ADDR(LBB),ADDR(LBK1),
     *           ADDR(LBK2),ADDR(LQ),INFOCCABAT,E2,E2T,E2S,
     *           NAUXBAS,NORBA,NOCCA,NVIRA,NOCCBAT,LENOCCABAT,
     *           IFILT3A,IW,DDI_NN,DDI_MY,SMP_NP,SMP_ME)
         ELSE IF(SCFTYP .EQ. UHF) THEN
            CALL RIUMP2E2ACCAPSMP(X(LEIGA),ADDR(LBB),ADDR(LBK1),
     *           ADDR(LBK2),ADDR(LQ),INFOCCABAT,E2TA,
     *           NAUXBAS,NORBA,NOCCA,NVIRA,NOCCBAT,LENOCCABAT,
     *           IFILT3A,IW,DDI_NN,DDI_MY,SMP_NP,SMP_ME)
            CALL RIUMP2E2ACCAPSMP(X(LEIGB),ADDR(LBB),ADDR(LBK1),
     *           ADDR(LBK2),ADDR(LQ),INFOCCBBAT,E2TB,
     *           NAUXBAS,NORBB,NOCCB,NVIRB,NOCCBAT,LENOCCBBAT,
     *           IFILT3B,IW,DDI_NN,DDI_MY,SMP_NP,SMP_ME)
            CALL RIUMP2E2ACCBPSMP(X(LEIGA),X(LEIGB),ADDR(LBB),
     *           ADDR(LBK1),ADDR(LBK2),ADDR(LQ),INFOCCABAT,INFOCCBBAT,
     *           E2S,NAUXBAS,NORBA,NORBB,NOCCA,NOCCB,NVIRA,NVIRB,
     *           NOCCBAT,LENOCCBBAT,IFILT3A,IFILT3B,IW,
     *           DDI_NN,DDI_MY,SMP_NP,SMP_ME)
            E2T = E2TA+E2TB
            CALL DDI_GSUMF(3100,E2T,1)
            CALL DDI_GSUMF(3101,E2S,1)
         END IF
      ELSE IF(GONODE) THEN
         IF(SCFTYP .EQ. RHF) THEN
            CALL RIMP2E2ACCP2SMP(X(LEIGA),ADDR(LBB),ADDR(LBK1),ADDR(LQ),
     *           INFOCCABAT,E2,E2T,E2S,
     *           NAUXBAS,NORBA,NOCCA,NVIRA,NOCCBAT,
     *           IW,DDI_NN,DDI_MY,SMP_NP,SMP_ME)
         ELSE IF(SCFTYP .EQ. UHF) THEN
            CALL RIUMP2E2ACCAP2SMP(X(LEIGA),ADDR(LBB),ADDR(LBK1),
     *           ADDR(LQ),INFOCCABAT,E2TA,NAUXBAS,NORBA,NOCCA,NVIRA,
     *           NOCCBAT,IW,DDI_NN,DDI_MY,SMP_NP,SMP_ME,D_TA)
            CALL RIUMP2E2ACCAP2SMP(X(LEIGB),ADDR(LBB),ADDR(LBK1),
     *           ADDR(LQ),INFOCCBBAT,E2TB,NAUXBAS,NORBB,NOCCB,NVIRB,
     *           NOCCBAT,IW,DDI_NN,DDI_MY,SMP_NP,SMP_ME,D_TB)
            CALL RIUMP2E2ACCBP2SMP(X(LEIGA),X(LEIGB),ADDR(LBB),
     *           ADDR(LBK1),ADDR(LQ),INFOCCABAT,INFOCCBBAT,E2S,
     *           NAUXBAS,NORBA,NORBB,NOCCA,NOCCB,NVIRA,NVIRB,NOCCBAT,
     *           IW,DDI_NN,DDI_MY,SMP_NP,SMP_ME,
     *           D_TA,D_TB)
            E2T = E2TA+E2TB
            CALL DDI_GSUMF(3100,E2T,1)
            CALL DDI_GSUMF(3101,E2S,1)
         END IF
      ELSE
         IF(SCFTYP .EQ. RHF) THEN
            CALL RIMP2E2ACCSMP(X(LEIGA),ADDR(LBB),ADDR(LBK1),ADDR(LQ),
     *           INFOCCABAT,E2,E2T,E2S,NAUXBAS,NORBA,NOCCA,NVIRA,
     *           NOCCBAT,IFILT3A,IW,MASWRK,SMP_NP,SMP_ME,USEDM)
            CALL DDI_GSUMF(3100,E2T,1)
            CALL DDI_GSUMF(3101,E2S,1)
         ELSE IF(SCFTYP .EQ. UHF) THEN
            CALL RIUMP2E2ACCASMP(X(LEIGA),ADDR(LBB),ADDR(LBK1),ADDR(LQ),
     *           INFOCCABAT,E2TA,NAUXBAS,NORBA,NOCCA,NVIRA,NOCCBAT,
     *           IFILT3A,IW,MASWRK,SMP_NP,SMP_ME,USEDM,D_TA)
            CALL RIUMP2E2ACCASMP(X(LEIGB),ADDR(LBB),ADDR(LBK1),ADDR(LQ),
     *           INFOCCBBAT,E2TB,NAUXBAS,NORBB,NOCCB,NVIRB,NOCCBAT,
     *           IFILT3B,IW,MASWRK,SMP_NP,SMP_ME,USEDM,D_TB)
            CALL RIUMP2E2ACCBSMP(X(LEIGA),X(LEIGB),ADDR(LBB),ADDR(LBK1),
     *           ADDR(LQ),INFOCCABAT,INFOCCBBAT,E2S,NAUXBAS,NORBA,NORBB,
     *           NOCCA,NOCCB,NVIRA,NVIRB,NOCCBAT,IFILT3A,IFILT3B,
     *           IW,MASWRK,SMP_NP,SMP_ME,USEDM,D_TA,D_TB)
            E2T = E2TA+E2TB
            CALL DDI_GSUMF(3100,E2T,1)
            CALL DDI_GSUMF(3101,E2S,1)
         END IF
      END IF
      E2 = E2T+E2S
C
 1000 CONTINUE
C
C     DESTROY SHARED-MEMORY ARRAYS
C
C      CALL DDI_SMP_DESTROY(D_EIGA)
C      IF(SCFTYP .EQ. UHF) CALL DDI_SMP_DESTROY(D_EIGB)
      CALL DDI_SMP_DESTROY(D_BB)
      CALL DDI_SMP_DESTROY(D_BK1)
      IF(GONODE .AND. .NOT. USEDM) CALL DDI_SMP_DESTROY(D_BK2)
      CALL DDI_SMP_DESTROY(D_Q)
C
C     FREE REPLICATED MEMORY
C
      CALL RETFM(INEED)
C
      RETURN
 9010 FORMAT(/1X,'REPLICATED MEMORY REQUIRED FOR 4C-2E ERI GENERATION',
     *       /1X,'AND MP2 ENERGY ACCUMULATION',22X,'=',I12,' WORDS')
 9020 FORMAT( 1X,'SHARED MEMORY REQUIRED FOR 4C-2E ERI GENERATION  =',
     *        I12,' WORDS'/50X,'=',F12.2,' GBYTES/NODE')
      END
C*MODULE RIMP2   *DECK RIMP2GENVINV
      SUBROUTINE RIMP2GENVINV(LOCSPH,STOL,VTOL,NAUXBAS,NAUXBASD,IAUXBF,
     *     IVMTD,OTHAUX,USEDM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL OTHAUX,USEDM
      LOGICAL SPHAUX
C
      INTEGER LOCSPH(*)
C
      PARAMETER (MXAUXSH=10000, MXAXGTOT=20000)
C
      COMMON /AUXBAS/ EXAUX(MXAXGTOT),CAUXS(MXAXGTOT),CAUXP(MXAXGTOT),
     *                CAUXD(MXAXGTOT),CAUXF(MXAXGTOT),CAUXG(MXAXGTOT),
     *                CAUXH(MXAXGTOT),CAUXI(MXAXGTOT),
     *                KAUXST(MXAUXSH),KAUXAT(MXAUXSH),KAUXTY(MXAUXSH),
     *                KAUXNG(MXAUXSH),KAUXLO(MXAUXSH),KAUXMI(MXAUXSH),
     *                KAUXMX(MXAUXSH),NAUXSH
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      COMMON /RIMPFI/ IFILV,IFILT2A,IFILT3A,IFILT2B,IFILT3B
C
      INTEGER D_V,D_TA,D_TB
      COMMON /RIMPDD/ D_V,D_TA,D_TB
C
      DATA CHECK    /8HCHECK   /
C
C     SUB DRIVER FOR EVALUATION INVERSE OF CHOLESKY DECONPOSED MATRIX OF
C     2C-2E ERI MATRIX (L|M)
C
      SPHAUX = .FALSE.
      IF(IAUXBF .EQ. 1) SPHAUX = .TRUE.
C
      IF(MASWRK) THEN
         IF(SPHAUX) THEN
            WRITE(IW,9001)
         ELSE
            WRITE(IW,9002)
         END IF
         IF(OTHAUX) WRITE(IW,9003)
      END IF
C
C     CHECK HIGHEST ANGLAR MOMENTUM OF AUXILIARY BASIS SETS
C
      KANG = 0
      DO II = 1, NAUXSH
         IF(KAUXTY(II) .GT. KANG) KANG = KAUXTY(II)
      END DO
      LMAX = KANG-1
                    NANGM =  4
      IF(LMAX.EQ.2) NANGM =  6
      IF(LMAX.EQ.3) NANGM = 10
      IF(LMAX.EQ.4) NANGM = 15
      IF(LMAX.EQ.5) NANGM = 21
      IF(LMAX.EQ.6) NANGM = 28
      MAXG = NANGM**2
C
      L1 = NAUXBAS*NAUXBAS
      NAUX2 = (NAUXBAS*NAUXBAS+NAUXBAS)/2
C
      IF(OTHAUX) THEN
C
C        ALLOCATE MEMORY FOR 2C-OVERLAP INTEGRAL EVALUATION
C        AND GENERATON OF ORTHOGONALIZATION TRANSFORMATION MATRIX
C
         CALL VALFM(LOADFM)
         LS       = LOADFM   + 1
         LWRK1    = LS       + L1
         LWRK2    = LWRK1    + MAX(L1,MAXG)
         LWRK3    = LWRK2    + MAX(NAUXBAS,MAXG)
         LWRK4    = LWRK3    + MAXG
         LCC      = LWRK4    + MAXG
         LTRI     = LCC      + 6
         LIWRK    = LTRI     + NAUX2
         LSCR     = LIWRK    + NAUXBAS
         LAST     = LSCR     + NAUXBAS*8
         INEED1   = LAST-LOADFM-1
         IF(MASWRK) WRITE(IW,9004) INEED1
         CALL FLSHBF(IW)
         CALL GETFM(INEED1)
C
C        GENERATE 2C-1E OVERLAP MATRIX (LM)
C
         CALL RIMP2SGEN(X(LS),X(LWRK1),X(LWRK2),X(LWRK3),X(LWRK4),
     *        X(LCC),LOCSPH,NAUXSH,NAUXBAS,IW,SPHAUX)
C
C        GENERATE ORTHOGONALIZATION TRANSFORMATION MATRIX
C        AND REMOVE REDUNDANCY
C
         CALL RIMP2SINV(X(LS),X(LWRK1),X(LWRK2),X(LTRI),X(LIWRK),
     *                  X(LSCR),STOL,NAUXBAS,NAUXBAS1,IW,MASWRK)
C
C        STORE ORTHOGONALIZATION TRANSFORMATION MATRIX
C
         IF(USEDM) THEN
            CALL DDI_SYNC(5122)
            IF(MASWRK) CALL DDI_PUT(D_V,1,NAUXBAS,1,NAUXBAS1,X(LS))
            CALL DDI_SYNC(5123)
         ELSE
            LENX = NAUXBAS*NAUXBAS1
            CALL RIMP2VWT(X(LS),LENX,IFILV)
         END IF
C
C        FREE MEMORY
C
         CALL RETFM(INEED1)
C
         IF(MASWRK) WRITE(IW,9005) NAUXBAS,NAUXBAS1
C
      ELSE
         NAUXBAS1 = NAUXBAS
      END IF
C
C     ALLOCATE MEMORY FOR 2C-2E ERI STRAGE
C
      CALL VALFM(LOADFM)
      LV       = LOADFM   + 1
      LAST     = LV       + L1
      INEED2   = LAST-LOADFM-1
      CALL GETFM(INEED2)
C
C     ALLOCATE MEMORY FOR 2C-2E ERI MATRIX GENERATION
C
      CALL VALFM(LOADFM)
      LWRK1    = LOADFM   + 1
      LWRK2    = LWRK1    + MAXG
      LWRK3    = LWRK2    + MAXG
      LWRK4    = LWRK3    + MAXG
      LCC      = LWRK4    + MAXG
      LAST     = LCC      + 6
      INEED3   = LAST-LOADFM-1
      IF(MASWRK) WRITE(IW,9006) INEED2+INEED3
      CALL FLSHBF(IW)
      CALL GETFM(INEED3)
C
C     GENERATE 2C-2E ERI MATRIX (L|M)
C
C     CALL TSECND(TIME00)
      CALL RIMP2VGEN(X(LV),X(LWRK1),X(LWRK2),X(LWRK3),X(LWRK4),
     *     X(LCC),LOCSPH,NAUXSH,NAUXBAS,IW,SPHAUX)
C     CALL TSECND(TIME01)
C     TIME0 = TIME01-TIME00
C
C     FREE MEMORY
C
      CALL RETFM(INEED3)
C
      IF(OTHAUX) THEN
C
C        ALLOCATE MEMORY FOR 2C-2E ERI MATRIX ORTHOGONALIZATION
C
         CALL VALFM(LOADFM)
         LWRK1    = LOADFM   + 1
         LWRK2    = LWRK1    + L1
         LAST     = LWRK2    + L1
         INEED4   = LAST-LOADFM-1
         IF(MASWRK) WRITE(IW,9007) INEED2+INEED4
         CALL FLSHBF(IW)
         CALL GETFM(INEED4)
C
C        TRANSFORM 2C-2E ERI MATRIX (L|M) (CARTESIAN->ORTHOGONAL)
C
         IF(.NOT. USEDM) THEN
            CALL RIMP2VRD(X(LWRK1),LENX,IFILV)
         ELSE
            CALL DDI_GET(D_V,1,NAUXBAS,1,NAUXBAS1,X(LWRK1))
            CALL DDI_SYNC(5124)
         END IF
         CALL RIMP2VOTH(X(LV),X(LWRK1),X(LWRK2),NAUXBAS,NAUXBAS1)
C
C        FREE MEMORY
C
         CALL RETFM(INEED4)
C
      END IF
C
C     CALL TSECND(TIME10)
C
C     CHOOSE DECOMPOSITION METHOD OF INVERSE OF 2C-2E ERI MATRIX
C
      IF(IVMTD .EQ. 2) THEN
C
C        DIAGONALIZATION OF 2C-2E ERI MATRIX
C        EVALUATION OF INVERSE SQUARE MATRIX OF 2C-2E ERI MATRIX
C
         CALL VALFM(LOADFM)
         LWRK1    = LOADFM   + 1
         LWRK2    = LWRK1    + L1
         LTRI     = LWRK2    + NAUXBAS
         LIWRK    = LTRI     + NAUX2
         LSCR     = LIWRK    + NAUXBAS
         LAST     = LSCR     + NAUXBAS*8
         INEED5   = LAST-LOADFM-1
         IF(MASWRK) WRITE(IW,9008) INEED2+INEED5
         CALL FLSHBF(IW)
         CALL GETFM(INEED5)
         CALL RIMP2VINV2(X(LV),X(LWRK1),X(LWRK2),X(LTRI),X(LIWRK),
     *                   X(LSCR),VTOL,NAUXBAS1,NAUXBASD,IW,MASWRK)
         CALL RETFM(INEED5)
C
      ELSE
C
C        CHOLESKY DECOMPOSITION OF 2C-2E ERI MATRIX
C        EVALUATION OF INVERSE MATRIX OF CHOLESKY DECOMPOSED MATRIX
C
         CALL RIMP2VINV(X(LV),NAUXBAS1,IW,MASWRK)
         NAUXBASD = NAUXBAS1
C
      END IF
C
      IF(OTHAUX) THEN
C
C        ALLOCATE MEMORY
C
         CALL VALFM(LOADFM)
         LWRK1    = LOADFM   + 1
         LWRK2    = LWRK1    + L1
         LAST     = LWRK2    + L1
         INEED6   = LAST-LOADFM-1
         IF(MASWRK) WRITE(IW,9009) INEED2+INEED6
         CALL FLSHBF(IW)
         CALL GETFM(INEED6)
C
C        BACK TRANSFORM 2C-2E ERI MATRIX (L|M)
C        (ORTHOGONAL->CARTESIAN OR SPHERICAL)
C
         IF(EXETYP .NE. CHECK) THEN
            IF(.NOT. USEDM) THEN
               CALL RIMP2VRD(X(LWRK1),LENX,IFILV)
            ELSE
               CALL DDI_GET(D_V,1,NAUXBAS,1,NAUXBAS1,X(LWRK1))
               CALL DDI_SYNC(5125)
            END IF
            CALL RIMP2VINVBCK(X(LV),X(LWRK1),X(LWRK2),
     *           NAUXBAS,NAUXBAS1,NAUXBASD)
         END IF
C
C        FREE MEMORY
C
         CALL RETFM(INEED6)
C
      END IF
C
C        STORE DECOMPOSED MATRIX
C
      IF(EXETYP .NE. CHECK) THEN
         IF(USEDM) THEN
            CALL DDI_SYNC(5126)
            IF(MASWRK) CALL DDI_PUT(D_V,1,NAUXBASD,1,NAUXBAS,X(LV))
            CALL DDI_SYNC(5127)
         ELSE
            LENV = NAUXBAS*NAUXBASD
            CALL RIMP2VWT(X(LV),LENV,IFILV)
         END IF
      END IF
C
C     CALL TSECND(TIME11)
C     TIME1 = TIME11-TIME10
C     IF(MASWRK) WRITE(IW,9999) TIME0,TIME1
C9999 FORMAT(/1X,'TIME OF 2C-2E ERI MATRIX GENERATION =    ',F9.1,
C    *       /1X,'TIME OF L^(-1) MATRIX GENERATION    =    ',F9.1)
C
C     FREE MEMORY
C
      CALL RETFM(INEED2)
C
      RETURN
 9001 FORMAT(/1X,'SPHERICAL HARMONIC GAUSSIANS ARE EMPLOYED',
     *        1X,'FOR AUXILIARY BASIS SETS')
 9002 FORMAT(/1X,'CARTESIAN GAUSSIANS ARE EMPLOYED',
     *        1X,'FOR AUXILIARY BASIS SETS')
 9003 FORMAT(/1X,'CANONICAL TRANSFORMATION IS EMPLOYED TO REMOVE'
     *       /1X,'LINEAR DEPENDENCY OF AUXILIARY BASIS SETS')
 9004 FORMAT(/1X,'MEMORY REQUIRED FOR',
     *        1X,'TRANSFORMATION MATRIX        =',I12,' WORDS')
 9005 FORMAT(/1X,'NUMBER OF AUX. BASIS FUNCTIONS (ORIG.) =',I6,/
     *        1X,'NUMBER OF AUX. BASIS FUNCTIONS (ORTH.) =',I6)
 9006 FORMAT(/1X,'MEMORY REQUIRED FOR',
     *        1X,'2C-2E ERI MATRIX GENERATION  =',I12,' WORDS')
 9007 FORMAT(/1X,'MEMORY REQUIRED FOR',
     *        1X,'2C-2E ERI MATRIX ORTHOG.     =',I12,' WORDS')
 9008 FORMAT(/1X,'MEMORY REQUIRED FOR',
     *        1X,'DECOMPOSITION OF 2C-2E ERI   =',I12,' WORDS')
 9009 FORMAT(/1X,'MEMORY REQUIRED FOR',
     *        1X,'2C-2E BACK-TRANSFORM TO AO''S =',I12,' WORDS')
      END
C*MODULE RIMP2   *DECK RIMP2GENVINVSMP
      SUBROUTINE RIMP2GENVINVSMP(LOCSPH,STOL,VTOL,NAUXBAS,NAUXBASD,
     *     IAUXBF,IVMTD,OTHAUX,USEDM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL OTHAUX,USEDM
      LOGICAL SPHAUX
C
      CHARACTER*1 ADDR(1)
      INTEGER DDI_NP,DDI_ME,DDI_NN,DDI_MY
      INTEGER SMP_NP,SMP_ME
C
      INTEGER D_V,D_X,D_W1,D_W2
      INTEGER LV,LX,LW1,LW2
C
      INTEGER LOCSPH(*)
C
      PARAMETER (MXAUXSH=10000, MXAXGTOT=20000)
C
      COMMON /AUXBAS/ EXAUX(MXAXGTOT),CAUXS(MXAXGTOT),CAUXP(MXAXGTOT),
     *                CAUXD(MXAXGTOT),CAUXF(MXAXGTOT),CAUXG(MXAXGTOT),
     *                CAUXH(MXAXGTOT),CAUXI(MXAXGTOT),
     *                KAUXST(MXAUXSH),KAUXAT(MXAUXSH),KAUXTY(MXAUXSH),
     *                KAUXNG(MXAUXSH),KAUXLO(MXAUXSH),KAUXMI(MXAUXSH),
     *                KAUXMX(MXAUXSH),NAUXSH
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      COMMON /RIMPFI/ IFILV,IFILT2A,IFILT3A,IFILT2B,IFILT3B
C
      INTEGER D_VD,D_TA,D_TB
      COMMON /RIMPDD/ D_VD,D_TA,D_TB
C
      DATA CHECK    /8HCHECK   /
C
C     SUB DRIVER FOR EVALUATION INVERSE OF CHOLESKY DECONPOSED MATRIX OF
C     2C-2E ERI MATRIX (L|M)
C
      CALL DDI_SYNC(5128)
      CALL DDI_NPROC(DDI_NP,DDI_ME)
      CALL DDI_NNODE(DDI_NN,DDI_MY)
      CALL DDI_SMP_NPROC(SMP_NP,SMP_ME)
C
      SPHAUX = .FALSE.
      IF(IAUXBF .EQ. 1) SPHAUX = .TRUE.
C
      IF(MASWRK) THEN
         IF(SPHAUX) THEN
            WRITE(IW,9001)
         ELSE
            WRITE(IW,9002)
         END IF
         IF(OTHAUX) WRITE(IW,9003)
      END IF
C
C     CHECK HIGHEST ANGLAR MOMENTUM OF AUXILIARY BASIS SETS
C
      KANG = 0
      DO II = 1, NAUXSH
         IF(KAUXTY(II) .GT. KANG) KANG = KAUXTY(II)
      END DO
      LMAX = KANG-1
                    NANGM =  4
      IF(LMAX.EQ.2) NANGM =  6
      IF(LMAX.EQ.3) NANGM = 10
      IF(LMAX.EQ.4) NANGM = 15
      IF(LMAX.EQ.5) NANGM = 21
      IF(LMAX.EQ.6) NANGM = 28
      MAXG = NANGM**2
C
      L1 = NAUXBAS*NAUXBAS
      NAUX2 = (NAUXBAS*NAUXBAS+NAUXBAS)/2
C
C     ALLOCATE SHARED MEMORY ARRAYS
C
      CALL DDI_SMP_CREATE(L1,D_V)
C     DETERMINE OFFSETS FOR SHARED MEMORY ARRAYS
      CALL DDI_SMP_OFFSET(D_V,ADDR,LV)
      LV  = LV+1
      IF(OTHAUX) THEN
         CALL DDI_SMP_CREATE(L1,D_X)
C        DETERMINE OFFSETS FOR SHARED MEMORY ARRAYS
         CALL DDI_SMP_OFFSET(D_X,ADDR,LX)
         LX  = LX+1
      END IF
      IF(OTHAUX .OR. IVMTD .EQ. 2) THEN
         CALL DDI_SMP_CREATE(MAX(L1,MAXG),D_W1)
         CALL DDI_SMP_CREATE(MAX(L1,MAXG),D_W2)
C        DETERMINE OFFSETS FOR SHARED MEMORY ARRAYS
         CALL DDI_SMP_OFFSET(D_W1,ADDR,LW1)
         CALL DDI_SMP_OFFSET(D_W2,ADDR,LW2)
         LW1 = LW1+1
         LW2 = LW2+1
      END IF
      CALL DDI_SMP_SYNC()
C
      IF(OTHAUX) THEN
C
C        ALLOCATE MEMORY FOR 2C-OVERLAP INTEGRAL EVALUATION
C        AND GENERATON OF ORTHOGONALIZATION TRANSFORMATION MATRIX
C
         CALL VALFM(LOADFM)
         LS       = LOADFM   + 1
         LWRK1    = LS       + L1
         LWRK2    = LWRK1    + MAX(L1,MAXG)
         LWRK3    = LWRK2    + MAX(NAUXBAS,MAXG)
         LWRK4    = LWRK3    + MAXG
         LCC      = LWRK4    + MAXG
         LTRI     = LCC      + 6
         LIWRK    = LTRI     + NAUX2
         LSCR     = LIWRK    + NAUXBAS
         LAST     = LSCR     + NAUXBAS*8
         INEED1   = LAST-LOADFM-1
         IF(MASWRK) WRITE(IW,9004) INEED1
         CALL FLSHBF(IW)
         CALL GETFM(INEED1)
C
C        GENERATE 2C-1E OVERLAP MATRIX (LM)
C
         CALL DDI_SMP_SYNC()
         CALL RIMP2SGENSMP(ADDR(LX),X(LWRK1),X(LWRK2),X(LWRK3),X(LWRK4),
     *        X(LCC),LOCSPH,NAUXSH,NAUXBAS,IW,SPHAUX,SMP_NP,SMP_ME)
         CALL DDI_SMP_SYNC()
C
C           GENERATE ORTHOGONALIZATION TRANSFORMATION MATRIX
C           AND REMOVE REDUNDANCY
C
         CALL DCOPY(L1,ADDR(LX),1,X(LS),1)
         CALL RIMP2SINV(X(LS),X(LWRK1),X(LWRK2),X(LTRI),X(LIWRK),
     *                  X(LSCR),STOL,NAUXBAS,NAUXBAS1,IW,MASWRK)
         CALL DDI_SMP_SYNC()
         IF(SMP_ME .EQ. 0) THEN
            CALL DCOPY(L1,     X(LS)   ,1,ADDR(LX) ,1)
            CALL DCOPY(L1,     X(LWRK1),1,ADDR(LW1),1)
            CALL DCOPY(NAUXBAS,X(LWRK2),1,ADDR(LW2),1)
         END IF
         CALL DDI_SMP_SYNC()
C
C        FREE MEMORY
C
         CALL RETFM(INEED1)
C
         IF(MASWRK) WRITE(IW,9005) NAUXBAS,NAUXBAS1
      ELSE
         NAUXBAS1 = NAUXBAS
      END IF
C
C     ALLOCATE MEMORY FOR 2C-2E ERI MATRIX GENERATION
C
      CALL VALFM(LOADFM)
      LVMAT    = LOADFM   + 1
      LWRK1    = LVMAT    + L1
      LWRK2    = LWRK1    + MAX(L1,MAXG)
      LWRK3    = LWRK2    + MAX(NAUXBAS,MAXG)
      LWRK4    = LWRK3    + MAXG
      LCC      = LWRK4    + MAXG
      LTRI     = LCC      + 6
      LIWRK    = LTRI     + NAUX2
      LSCR     = LIWRK    + NAUXBAS
      LAST     = LSCR     + NAUXBAS*8
      INEED3   = LAST-LOADFM-1
      IF(MASWRK) WRITE(IW,9006) INEED3
      CALL FLSHBF(IW)
      CALL GETFM(INEED3)
C
C     GENERATE 2C-2E ERI MATRIX (L|M)
C
      CALL DDI_SMP_SYNC()
      CALL RIMP2VGENSMP(ADDR(LV),X(LWRK1),X(LWRK2),X(LWRK3),X(LWRK4),
     *     X(LCC),LOCSPH,NAUXSH,NAUXBAS,IW,SPHAUX,SMP_NP,SMP_ME)
      CALL DDI_SMP_SYNC()
C
      IF(OTHAUX  .AND.  SMP_ME.EQ.0) THEN
C
C           TRANSFORM 2C-2E ERI MATRIX (L|M) (CARTESIAN->ORTHOGONAL)
C
         CALL RIMP2VOTH(ADDR(LV),ADDR(LW1),ADDR(LW2),NAUXBAS,NAUXBAS1)
C
      END IF
      CALL DDI_SMP_SYNC()
C
C        CHOOSE DECOMPOSITION METHOD OF INVERSE OF 2C-2E ERI MATRIX
C
      IF(IVMTD .EQ. 2) THEN
C
C           DIAGONALIZATION OF 2C-2E ERI MATRIX
C           EVALUATION OF INVERSE SQUARE MATRIX OF 2C-2E ERI MATRIX
C
         CALL DCOPY(L1,ADDR(LV),1,X(LVMAT),1)
         CALL RIMP2VINV2(X(LVMAT),X(LWRK1),X(LWRK2),X(LTRI),X(LIWRK),
     *                   X(LSCR),VTOL,NAUXBAS1,NAUXBASD,IW,MASWRK)
         CALL DDI_SMP_SYNC()
         IF(SMP_ME .EQ. 0) THEN
            CALL DCOPY(L1,     X(LVMAT),1,ADDR(LV) ,1)
            CALL DCOPY(L1,     X(LWRK1),1,ADDR(LW1),1)
            CALL DCOPY(NAUXBAS,X(LWRK2),1,ADDR(LW2),1)
         END IF
C
      ELSE
C
C           CHOLESKY DECOMPOSITION OF 2C-2E ERI MATRIX
C           EVALUATION OF INVERSE MATRIX OF CHOLESKY DECOMPOSED MATRIX
C
         IF(SMP_ME.EQ.0) THEN
            CALL RIMP2VINV(ADDR(LV),NAUXBAS1,IW,MASWRK)
            NAUXBASD = NAUXBAS1
         END IF
         CALL DDI_SMP_SYNC()
      END IF
C
C     FREE MEMORY
C
      CALL RETFM(INEED3)
C
      IF(SMP_ME.EQ.0) THEN
         IF(OTHAUX .AND. EXETYP .NE. CHECK) THEN
C
C           BACK TRANSFORM 2C-2E ERI MATRIX (L|M)
C           (ORTHOGONAL->CARTESIAN OR SPHERICAL)
C
            CALL RIMP2VINVBCK(ADDR(LV),ADDR(LX),ADDR(LW1),
     *           NAUXBAS,NAUXBAS1,NAUXBASD)
         END IF
      END IF
      CALL DDI_BCAST(101,'I',NAUXBASD,1,0)
C
C        STORE DECOMPOSED MATRIX
C
      IF(EXETYP .NE. CHECK) THEN
         IF(USEDM) THEN
            CALL DDI_SYNC(5129)
            IF(MASWRK) CALL DDI_PUT(D_VD,1,NAUXBASD,1,NAUXBAS,ADDR(LV))
            CALL DDI_SYNC(5130)
         ELSE
            LENV = NAUXBAS*NAUXBASD
            CALL RIMP2VWT(ADDR(LV),LENV,IFILV)
         END IF
      END IF
C
C     DESTROY SHARED-MEMORY ARRAYS
C
      IF(OTHAUX .OR. IVMTD .EQ. 2) THEN
         CALL DDI_SMP_DESTROY(D_W2)
         CALL DDI_SMP_DESTROY(D_W1)
      END IF
      IF(OTHAUX) CALL DDI_SMP_DESTROY(D_X)
      CALL DDI_SMP_DESTROY(D_V)
      RETURN
C
 9001 FORMAT(/1X,'SPHERICAL HARMONIC GAUSSIANS ARE EMPLOYED',
     *        1X,'FOR AUXILIARY BASIS SETS')
 9002 FORMAT(/1X,'CARTESIAN GAUSSIANS ARE EMPLOYED',
     *        1X,'FOR AUXILIARY BASIS SETS')
 9003 FORMAT(/1X,'CANONICAL TRANSFORMATION IS EMPLOYED TO REMOVE'
     *       /1X,'LINEAR DEPENDENCY OF AUXILIARY BASIS SETS')
 9004 FORMAT(/1X,'MEMORY REQUIRED FOR',
     *        1X,'TRANSFORMATION MATRIX        =',I12,' WORDS')
 9005 FORMAT(/1X,'NUMBER OF AUX. BASIS FUNCTIONS (ORIG.) =',I6,/
     *        1X,'NUMBER OF AUX. BASIS FUNCTIONS (ORTH.) =',I6)
 9006 FORMAT(/1X,'MEMORY REQUIRED FOR',
     *        1X,'2C-2E ERI MATRIX GENERATION  =',I12,' WORDS')
      END
C*MODULE RIMP2   *DECK RIMP2INTTR1
      SUBROUTINE RIMP2INTTR1(VEC,CC,T0,T1,T2,TL,LOCSPH,INFOCCBAT,NT2BUF,
     *     NSHELL,NBASIS,NAUXSH,NOCC,NVIR,
     *     NINTMX,NOCCBAT,IFILT2,IW,SPHAUX,USEDM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL SPHAUX,USEDM
      LOGICAL SLB,DLB
      LOGICAL NORM
C
      DOUBLE PRECISION VEC(*),CC(3,3),T0(NBASIS,NBASIS,*),T1(*),T2(*),
     *     TL(*)
      INTEGER LOCSPH(*),INFOCCBAT(*),NT2BUF(*)
C
      PARAMETER (MXATM=2000)
      PARAMETER (MXAUXSH=10000, MXAXGTOT=20000)
C
      COMMON /AUXBAS/ EXAUX(MXAXGTOT),CAUXS(MXAXGTOT),CAUXP(MXAXGTOT),
     *                CAUXD(MXAXGTOT),CAUXF(MXAXGTOT),CAUXG(MXAXGTOT),
     *                CAUXH(MXAXGTOT),CAUXI(MXAXGTOT),
     *                KAUXST(MXAUXSH),KAUXAT(MXAUXSH),KAUXTY(MXAUXSH),
     *                KAUXNG(MXAUXSH),KAUXLO(MXAUXSH),KAUXMI(MXAUXSH),
     *                KAUXMX(MXAUXSH),NAUXSHX
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER D_V,D_TA,D_TB
      COMMON /RIMPDD/ D_V,D_TA,D_TB
C
      PARAMETER (ZERO=0.0D+00)
C
C     PERFORM ERI EVALUATION AND FIRST 1/3 AND 2/3 TRANSFORMATION
C     THIS SUBROUTINE IS FOR RMP2 CALCULATIONS.
C
      TIME0 = ZERO
      TIME1 = ZERO
      TIME2 = ZERO
      TIMEW = ZERO
C
      NORM = NORMF .NE. 1 .OR. NORMP .NE. 1
C
C     ----- INITIALIZATION FOR PARALLEL WORK -----
C     STATIC AND DYNAMIC LOAD BALANCING IS IMPLEMENTED BELOW,
C     BUT THE FORMER DOESN'T SEEM TO WORK IF FORCED IN THE INPUT.
C
      SLB = GOPARR .AND. IBTYP .EQ. 0
      DLB = GOPARR .AND. IBTYP .EQ. 1
      SLB = .FALSE.
      DLB = .TRUE.
      NEXT = -1
      MINE = -1
      IPCOUNT = 0
C
      NRECT2 = 0
      DO IBAT = 1, 2*NOCCBAT
         NT2BUF(IBAT) = 0
      END DO
C
      DO LAUXSH = 1, NAUXSH
         LAT = KAUXAT(LAUXSH)
         CC(1,3) = C(1,LAT)
         CC(2,3) = C(2,LAT)
         CC(3,3) = C(3,LAT)
         LANGL = KAUXTY(LAUXSH)-1
         MINL  = KAUXMI(LAUXSH)
         MAXL  = KAUXMX(LAUXSH)
         NL    = MAXL-MINL+1
         NGL   = KAUXNG(LAUXSH)
         L1    = KAUXST(LAUXSH)
         LOCL  = KAUXLO(LAUXSH)-MINL
         IF(SPHAUX) THEN
            CALL RIMP2CSTRM(TL,LANGL,MINL,NL,MINLS,MAXLS)
            LOCLS = LOCSPH(LAUXSH)-MINLS
            NLS = MAXLS-MINLS+1
            MINLT = MINLS
            MAXLT = MAXLS
            LOCLT = LOCLS
         ELSE
            MINLT = MINL
            MAXLT = MAXL
            LOCLT = LOCL
         END IF
C
C     ----- GO PARALLEL! -----
C
         IF(SLB) THEN
            IPCOUNT = IPCOUNT + 1
            IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 900
         END IF
         IF(DLB) THEN
            MINE = MINE+1
            IF (MINE .GT. NEXT) CALL DDI_DLBNEXT(NEXT)
            IF (NEXT .NE. MINE) GO TO 900
         END IF
C
C        3C-2E ERI EVALUATION
C
         CALL TSECND(TIME00)
         CALL RIMP2T0GEN(CC,T0,T2,TL,T1,NSHELL,NBASIS,
     *        LANGL,MINL,MAXL,NL,NGL,L1,MINLS,MAXLS,NLS,SPHAUX,NORM)
         CALL TSECND(TIME01)
         TIME0 = TIME0+(TIME01-TIME00)
C
         LL = 0
         DO L = MINLT, MAXLT
            LL = LL+1
            LAUX = LOCLT+L
C
C           1/3 AND 2/3 INTEGRAL TRANSFORMATION AND
C           STORE 2/3 TRANSFORMED INTEGRAL MATRIX T2
C
            CALL RIMP2INTTRT02(VEC,T0(1,1,LL),T1,T2,INFOCCBAT,NT2BUF,
     *           NBASIS,NOCC,NVIR,NINTMX,NOCCBAT,IFILT2,NRECT2,D_TA,
     *           LAUX,USEDM,TIME1,TIME2,TIMEW)
C
         END DO                 !LL
  900    CONTINUE
      END DO                    !LAUXSH
C
      IF(DLB) CALL DDI_DLBRESET
C
      IF(MASWRK) WRITE(IW,9999) TIME0,TIME1,TIME2,TIMEW
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 3C-2E ERI GENERATION        =    ',F9.1,
     *       /1X,'TIME OF 1/3 INTEGRAL TRANSFORMATION =    ',F9.1,
     *       /1X,'TIME OF 2/3 INTEGRAL TRANSFORMATION =    ',F9.1,
     *       /1X,'TIME OF 2/3 INTEGRAL WRITE          =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIMP2INTTR1SMP
      SUBROUTINE RIMP2INTTR1SMP(VEC,CC,T0,T1,T2,T2BUFF,GHONDO,TL,W,
     *                          LOCSPH,INFOCCBAT,NT2BUF,NSHELL,NBASIS,
     *                          NAUXSH,NOCC,NVIR,NINTMX,NOCCBAT,IFILT2,
     *                          IW,SPHAUX,
     *                          USEDM,DDI_NN,DDI_MY,SMP_NP,SMP_ME)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL SPHAUX,USEDM
      LOGICAL SLB
      LOGICAL NORM
C
C                ALLOCATED FROM SHARED MEMORY:
      DOUBLE PRECISION T0(NBASIS,NBASIS,*),T1(*),T2(*)
      INTEGER NT2BUF(*)
C                ALLOCATED FROM REPLICATED MEMORY:
      DOUBLE PRECISION VEC(*),CC(3,3),GHONDO(*),TL(*),W(*),T2BUFF(*)
      INTEGER LOCSPH(*),INFOCCBAT(*)
C
      INTEGER DDI_NN,DDI_MY,SMP_NP,SMP_ME
C
      PARAMETER (MXATM=2000)
      PARAMETER (MXAUXSH=10000, MXAXGTOT=20000)
C
      COMMON /AUXBAS/ EXAUX(MXAXGTOT),CAUXS(MXAXGTOT),CAUXP(MXAXGTOT),
     *                CAUXD(MXAXGTOT),CAUXF(MXAXGTOT),CAUXG(MXAXGTOT),
     *                CAUXH(MXAXGTOT),CAUXI(MXAXGTOT),
     *                KAUXST(MXAUXSH),KAUXAT(MXAUXSH),KAUXTY(MXAUXSH),
     *                KAUXNG(MXAUXSH),KAUXLO(MXAUXSH),KAUXMI(MXAUXSH),
     *                KAUXMX(MXAUXSH),NAUXSHX
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER D_V,D_TA,D_TB
      COMMON /RIMPDD/ D_V,D_TA,D_TB
C
      PARAMETER (ZERO=0.0D+00)
C
C     PERFORM ERI EVALUATION AND FIRST 1/3 AND 2/3 TRANSFORMATION
C     THIS SUBROUTINE IS FOR RMP2 CALCULATIONS.
C
      TIME0 = ZERO
      TIME1 = ZERO
      TIME2 = ZERO
      TIMEW = ZERO
C
      NORM = NORMF .NE. 1 .OR. NORMP .NE. 1
C
C     ----- INITIALIZATION FOR PARALLEL WORK -----
C     ONLY STATIC LOAD BALANCING IS IMPLEMENTED BELOW
C
      SLB = .TRUE.
      IPCOUNT = 0
C
      NRECT2 = 0
      IF(SMP_ME .EQ. 0) THEN
         DO IBAT = 1, 2*NOCCBAT
            NT2BUF(IBAT) = 0
         END DO
      END IF
      CALL DDI_SMP_SYNC()
C
      DO LAUXSH = 1, NAUXSH
         LAT = KAUXAT(LAUXSH)
         CC(1,3) = C(1,LAT)
         CC(2,3) = C(2,LAT)
         CC(3,3) = C(3,LAT)
         LANGL = KAUXTY(LAUXSH)-1
         MINL  = KAUXMI(LAUXSH)
         MAXL  = KAUXMX(LAUXSH)
         NL    = MAXL-MINL+1
         NGL   = KAUXNG(LAUXSH)
         L1    = KAUXST(LAUXSH)
         LOCL  = KAUXLO(LAUXSH)-MINL
         IF(SPHAUX) THEN
            CALL RIMP2CSTRM(TL,LANGL,MINL,NL,MINLS,MAXLS)
            LOCLS = LOCSPH(LAUXSH)-MINLS
            NLS   = MAXLS-MINLS+1
            MINLT = MINLS
            MAXLT = MAXLS
            LOCLT = LOCLS
         ELSE
            MINLT = MINL
            MAXLT = MAXL
            LOCLT = LOCL
         END IF
C
C        ----- GO PARALLEL! -----
C
         IF(SLB) THEN
            IPCOUNT = IPCOUNT + 1
            IF (MOD(IPCOUNT,DDI_NN) .NE. DDI_MY) GO TO 900
         END IF
C
C        3C-2E ERI EVALUATION
C
         CALL TSECND(TIME00)
         CALL RIMP2T0GENSMP(CC,T0,GHONDO,TL,W,NSHELL,NBASIS,LANGL,MINL,
     *        MAXL,NL,NGL,L1,MINLS,MAXLS,NLS,SPHAUX,NORM,SMP_NP,SMP_ME)
         CALL DDI_SMP_SYNC()
         CALL TSECND(TIME01)
         TIME0 = TIME0+(TIME01-TIME00)
C
         LL = 0
         DO L = MINLT, MAXLT
            LL = LL+1
            LAUX = LOCLT+L
C
C           1/3 AND 2/3 INTEGRAL TRANSFORMATION AND
C           STORE 2/3 TRANSFORMED INTEGRAL MATRIX T2
C
            CALL RIMP2INTTRT02SMP(VEC,T0(1,1,LL),T1,T2,T2BUFF,
     *           INFOCCBAT,NT2BUF,NBASIS,NOCC,NVIR,NINTMX,NOCCBAT,
     *           IFILT2,NRECT2,D_TA,LAUX,USEDM,
     *           TIME1,TIME2,TIMEW,SMP_NP,SMP_ME)
C
         END DO                 !LL
  900    CONTINUE
      END DO                    !LAUXSH
C
      IF(MASWRK) WRITE(IW,9999) TIME0,TIME1,TIME2,TIMEW
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 3C-2E ERI GENERATION        =    ',F9.1,
     *       /1X,'TIME OF 1/3 INTEGRAL TRANSFORMATION =    ',F9.1,
     *       /1X,'TIME OF 2/3 INTEGRAL TRANSFORMATION =    ',F9.1,
     *       /1X,'TIME OF 2/3 INTEGRAL WRITE          =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIMP2INTTR2
      SUBROUTINE RIMP2INTTR2(V,T2,T3,INFOCCBAT,NT2BUF,
     *     NAUXBAS,NAUXBASD,NVIR,NINTMX,
     *     NOCCBAT,IFILV,IFILT2,IFILT3,IW,USEDM,D_V,D_T)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL USEDM
C
      DOUBLE PRECISION V(NAUXBASD,NAUXBAS),T2(NAUXBAS,NVIR,*),T3(*)
      INTEGER INFOCCBAT(2,NOCCBAT),NT2BUF(2,NOCCBAT)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      INTEGER D_V,D_T
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
C     PERFORM 3/3 INTEGRAL TRANSFORMATION.
C     THIS 3/3 ROUTINE IS FOR UNIPROCESSORS/GOSMP=FALSE AND USEDM=TRUE
C     2/3 TRANSFORMED INTEGRAL DATA IS SORTED
C     BY YOSHIMINE BIN SORT ALGORITHM.
C
      TIMER = ZERO
      TIME3 = ZERO
      TIMEW = ZERO
C
      MYPROC = ME+1
      NBATP1 = NOCCBAT/NPROC
C
      LENT2 = NAUXBAS*NVIR
      LENT3 = NAUXBASD*NVIR
C
      IF(.NOT. USEDM) THEN
         REWIND(IFILV)
         READ(IFILV) V
      ELSE
         CALL DDI_GET(D_V,1,NAUXBASD,1,NAUXBAS,V)
      END IF
C
      DO IBATP1 = 1, NBATP1
         IBAT = (MYPROC-1)*NBATP1+IBATP1
C
C        READ 2/3 TRANSFORMED INTEGRAL MATRIX T2
C        BY REFFERING YOSHIMINE DATA CHAIN
C
         CALL TSECND(TIMER0)
         IF(.NOT. USEDM) THEN
            NBUF = NT2BUF(1,IBAT)
            IREC = NT2BUF(2,IBAT)
            DO IBUF = 1, NBUF
               CALL RIMP2T2RD(T3,NINTMX,IFILT2,IREC,IRECNEW,LAUX)
               IT2BGN = 0
               DO I = 1, INFOCCBAT(2,IBAT)
                  DO IVIR = 1, NVIR
                     T2(LAUX,IVIR,I) = T3(IVIR+IT2BGN)
                  END DO
                  IT2BGN = IT2BGN+NVIR
               END DO
               IREC = IRECNEW
            END DO
         END IF
         CALL TSECND(TIMER1)
         TIMER = TIMER+(TIMER1-TIMER0)
C
         IOCCBG = INFOCCBAT(1,IBAT)
         DO I = 1, INFOCCBAT(2,IBAT)
            IOCC = IOCCBG+I
            IF(USEDM) THEN
               CALL DDI_GET(D_T,1,LENT2,IOCC,IOCC,T3)
               ICNT=0
               DO LAUX = 1, NAUXBAS
                  DO IVIR = 1, NVIR
                     ICNT = ICNT+1
                     T2(LAUX,IVIR,I) = T3(ICNT)
                  END DO
               END DO
            END IF
C
C           3/3 INTEGRAL TRANSFORMATION.
C           MULTIPLY T2 WITH L^(-1) MATRIX
C
C            WRITE(IW,*) 'T2 MATRIX'
C            CALL RIMP2PRTT2(T2(1,1,I),NAUXBAS,NVIR,IOCC)
C
            CALL TSECND(TIME30)
            CALL DGEMM('N','N',NAUXBASD,NVIR,NAUXBAS,ONE,V,NAUXBASD,
     *           T2(1,1,I),NAUXBAS,ZERO,T3,NAUXBASD)
            CALL TSECND(TIME31)
            TIME3 = TIME3+(TIME31-TIME30)
C
C            WRITE(IW,*) 'T3 MATRIX'
C            CALL RIMP2PRTT2(T3,NAUXBAS0,NVIR,IOCC)
C
C           STORE 3/3 TRANSFORMED INTEGRAL MATRIX T3
C
            CALL TSECND(TIMEW0)
            IF(.NOT. USEDM) THEN
               CALL RIMP2T3WT(T3,LENT3,IFILT3,IOCC)
            ELSE
               CALL DDI_PUT(D_T,1,LENT3,IOCC,IOCC,T3)
            END IF
            CALL TSECND(TIMEW1)
            TIMEW = TIMEW+(TIMEW1-TIMEW0)
C
         END DO                 !I
      END DO                    !IBAT
C
      IF(MASWRK) WRITE(IW,9999) TIMER,TIME3,TIMEW
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 2/3 INTEGRAL READ           =    ',F9.1,
     *       /1X,'TIME OF 3/3 INTEGRAL TRANSFORMATION =    ',F9.1,
     *       /1X,'TIME OF 3/3 INTEGRAL WRITE          =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIMP2INTTR2P
      SUBROUTINE RIMP2INTTR2P(V,T2,T3,T2A,INFOCCBAT,IT2A,IT2B,NT2BUF,
     *     NAUXBAS,NAUXBASD,NVIR,NINTMX,
     *     NOCCBAT,IFILV,IFILT2,IFILT3,IW)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION V(NAUXBASD,NAUXBAS),T2(NAUXBAS,NVIR,*),T3(*),
     *     T2A(*)
      INTEGER INFOCCBAT(2,NOCCBAT),IT2A(*),IT2B(*),NT2BUF(2,NOCCBAT)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
C     PERFORM 3/3 INTEGRAL TRANSFORMATION.
C     THIS 3/3 ROUTINE IS FOR UNIPROCESSORS/GOSMP=FALSE AND USEDM=FALSE
C     2/3 TRANSFORMED INTEGRAL DATA IS SORTED
C     BY YOSHIMINE BIN SORT ALGORITHM.
C
      INTSIZ=8/NWDVAR
C
      TIMER = ZERO
      TIMEC = ZERO
      TIME3 = ZERO
      TIMEW = ZERO
C
      LENT3 = NAUXBASD*NVIR
C
      REWIND(IFILV)
      READ(IFILV) V
C
      MYPROC = ME+1
      NBATP1 = NOCCBAT/NPROC
C      WRITE(6,*) 'NPROC=',NPROC,'ME=',ME,'MYPROC=',MYPROC
C      WRITE(6,*) 'NOCCBAT=',NOCCBAT,'NBATP1=',NBATP1
C
      DO IBATP1 = 1, NBATP1
         IBAT = (MYPROC-1)*NBATP1+IBATP1
C
C        READ 2/3 TRANSFORMED INTEGRAL MATRIX T2
C        BY REFFERING YOSHIMINE DATA CHAIN
C
         CALL TSECND(TIMER0)
         NBUF = NT2BUF(1,IBAT)
         IREC = NT2BUF(2,IBAT)
         DO IBUF = 1, NBUF
            CALL RIMP2T2RD(T3,NINTMX,IFILT2,IREC,IRECNEW,LAUX)
            IT2BGN = 0
            DO I = 1, INFOCCBAT(2,IBAT)
               DO IVIR = 1, NVIR
                  T2(LAUX,IVIR,I) = T3(IVIR+IT2BGN)
               END DO
               IT2BGN = IT2BGN+NVIR
            END DO
            IREC = IRECNEW
         END DO
         CALL TSECND(TIMER1)
         TIMER = TIMER+(TIMER1-TIMER0)
C
         NT2B = INFOCCBAT(2,IBAT)*NVIR
         DO IPDIF = 1, NPROC-1
            IPROC = MYPROC+IPDIF
            JPROC = MYPROC-IPDIF
            IF(IPROC .GT. NPROC) IPROC = IPROC-NPROC
            IF(JPROC .LE. 0)     JPROC = JPROC+NPROC
            IRANK = IPROC-1
            JRANK = JPROC-1
C            WRITE(6,*) 'MYPROC=',MYPROC,'IPROC=',IPROC,'JPROC=',JPROC
C            WRITE(6,*) 'ME=',ME,'IRANK=',IRANK,'JRANK=',JRANK
C
C           READ 2/3 TRANSFORMED INTEGRAL MATRIX T2
C           BY REFFERING YOSHIMINE DATA CHAIN
C
            CALL TSECND(TIMER0)
            JBAT = (IPROC-1)*NBATP1+IBATP1
            NT2A  = INFOCCBAT(2,JBAT)*NVIR
            IT2BGN = 0
            NBUFA = NT2BUF(1,JBAT)
            IREC  = NT2BUF(2,JBAT)
            DO IBUF = 1, NBUFA
               CALL RIMP2T2RD(T3,NINTMX,IFILT2,IREC,IRECNEW,LAUX)
               IT2A(IBUF) = LAUX
               DO ICNT = 1, NT2A
                  T2A(ICNT+IT2BGN) = T3(ICNT)
               END DO
               IT2BGN = IT2BGN+NT2A
               IREC = IRECNEW
            END DO
            CALL TSECND(TIMER1)
            TIMER = TIMER+(TIMER1-TIMER0)
C
C           COMMUNICATE 2/3 TRANSFORMED INTEGRAL MATRIX T2
C
            CALL TSECND(TIMEC0)
            CALL DDI_ISEND(NBUFA,INTSIZ,IRANK,IREQ1)
            CALL DDI_IRECV(NBUFB,INTSIZ,JRANK,IREQ2)
            CALL DDI_WAIT(IREQ1)
            CALL DDI_WAIT(IREQ2)
            CALL DDI_ISEND(T2A,8*NBUFA*NT2A,IRANK,IREQ3)
            CALL DDI_IRECV(T3 ,8*NBUFB*NT2B,JRANK,IREQ4)
            CALL DDI_WAIT(IREQ3)
            CALL DDI_WAIT(IREQ4)
            CALL DDI_ISEND(IT2A,INTSIZ*NBUFA,IRANK,IREQ5)
            CALL DDI_IRECV(IT2B,INTSIZ*NBUFB,JRANK,IREQ6)
            CALL DDI_WAIT(IREQ5)
            CALL DDI_WAIT(IREQ6)
            IT2BGN = 0
            DO IBUF = 1, NBUFB
               LAUX = IT2B(IBUF)
               DO I = 1, INFOCCBAT(2,IBAT)
                  DO IVIR = 1, NVIR
                     T2(LAUX,IVIR,I) = T3(IVIR+IT2BGN)
                  END DO
                  IT2BGN = IT2BGN+NVIR
               END DO
            END DO
            CALL TSECND(TIMEC1)
            TIMEC = TIMEC+(TIMEC1-TIMEC0)
         END DO                 !IPDIF
C
         IBAT = (MYPROC-1)*NBATP1+IBATP1
         IOCCBG = INFOCCBAT(1,IBAT)
         DO I = 1, INFOCCBAT(2,IBAT)
            IOCC = IOCCBG+I
C
C           3/3 INTEGRAL TRANSFORMATION.
C           MULTIPLY T2 WITH L^(-1) MATRIX
C
C            WRITE(IW,*) 'T2 MATRIX'
C            CALL RIMP2PRTT2(T2(1,1,I),NAUXBAS,NVIR,IOCC)
C
            CALL TSECND(TIME30)
            CALL DGEMM('N','N',NAUXBASD,NVIR,NAUXBAS,ONE,V,NAUXBASD,
     *           T2(1,1,I),NAUXBAS,ZERO,T3,NAUXBASD)
            CALL TSECND(TIME31)
            TIME3 = TIME3+(TIME31-TIME30)
C
C            WRITE(IW,*) 'T3 MATRIX'
C            CALL RIMP2PRTT2(T3,NAUXBAS0,NVIR,IOCC)
C
C           STORE 3/3 TRANSFORMED INTEGRAL MATRIX T3
C
            CALL TSECND(TIMEW0)
            CALL RIMP2T3WT(T3,LENT3,IFILT3,IOCC)
            CALL TSECND(TIMEW1)
            TIMEW = TIMEW+(TIMEW1-TIMEW0)
C
         END DO                 !I
      END DO                    !IBATP1
C
      IF(MASWRK) WRITE(IW,9999) TIMER,TIMEC,TIME3,TIMEW
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 2/3 INTEGRAL READ           =    ',F9.1,
     *       /1X,'TIME OF 2/3 INTEGRAL NETWORK COMM.  =    ',F9.1,
     *       /1X,'TIME OF 3/3 INTEGRAL TRANSFORMATION =    ',F9.1,
     *       /1X,'TIME OF 3/3 INTEGRAL WRITE          =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIMP2INTTR2PSMP
      SUBROUTINE RIMP2INTTR2PSMP(V,T2,T3,T2A,INFOCCBAT,IT2A,IT2B,NT2BUF,
     *     NAUXBAS,NAUXBAS0,NVIR,NINTMX,NOCCBAT,
     *     IFILV,IFILT2,IFILT3,IW,DDI_NN,DDI_MY,SMP_NP,SMP_ME)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION V(NAUXBAS0,NAUXBAS),T2(NAUXBAS,NVIR,*),T3(*),
     *     T2A(*)
      INTEGER INFOCCBAT(2,NOCCBAT),IT2A(*),IT2B(*),NT2BUF(2,NOCCBAT)
C
      INTEGER DDI_NN,DDI_MY,SMP_NP,SMP_ME
      INTEGER NR,SR
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
C     PERFORM 3/3 INTEGRAL TRANSFORMATION.
C     THIS 3/3 ROUTINE IS FOR GOSMP=TRUE AND USEDM=FALSE
C     2/3 TRANSFORMED INTEGRAL DATA IS SORTED
C     BY YOSHIMINE BIN SORT ALGORITHM.
C
      INTSIZ=8/NWDVAR
C
      TIMER = ZERO
      TIMEC = ZERO
      TIME3 = ZERO
      TIMEW = ZERO
C
      MYNODE = DDI_MY+1
      NBATP1 = NOCCBAT/DDI_NN
C
      LENT3 = NAUXBAS0*NVIR
C
      IF(SMP_ME .EQ. 0) THEN
         REWIND(IFILV)
         READ(IFILV) V
      END IF
      CALL DDI_SMP_SYNC()
C
      DO IBATP1 = 1, NBATP1
         IBAT = (MYNODE-1)*NBATP1+IBATP1
         IF(SMP_ME .EQ. 0) THEN
C
C           READ 2/3 TRANSFORMED INTEGRAL MATRIX T2
C           BY REFFERING YOSHIMINE DATA CHAIN
C
            CALL TSECND(TIMER0)
            NBUF = NT2BUF(1,IBAT)
            IREC = NT2BUF(2,IBAT)
            DO IBUF = 1, NBUF
               CALL RIMP2T2RD(T3,NINTMX,IFILT2,IREC,IRECNEW,LAUX)
               IT2BGN = 0
               DO I = 1, INFOCCBAT(2,IBAT)
                  DO IVIR = 1, NVIR
                     T2(LAUX,IVIR,I) = T3(IVIR+IT2BGN)
                  END DO
                  IT2BGN = IT2BGN+NVIR
               END DO
               IREC = IRECNEW
            END DO
            CALL TSECND(TIMER1)
            TIMER = TIMER+(TIMER1-TIMER0)
C
            NT2B = INFOCCBAT(2,IBAT)*NVIR
            DO IPDIF = 1, DDI_NN-1
               INODE = MYNODE+IPDIF
               JNODE = MYNODE-IPDIF
               IF(INODE .GT. DDI_NN) INODE = INODE-DDI_NN
               IF(JNODE .LE. 0)      JNODE = JNODE+DDI_NN
               IRANK = (INODE-1)*SMP_NP
               JRANK = (JNODE-1)*SMP_NP
C
C              READ 2/3 TRANSFORMED INTEGRAL MATRIX T2
C              BY REFFERING YOSHIMINE DATA CHAIN
C
               CALL TSECND(TIMER0)
               JBAT = (INODE-1)*NBATP1+IBATP1
               NT2A  = INFOCCBAT(2,JBAT)*NVIR
               IT2BGN = 0
               NBUFA = NT2BUF(1,JBAT)
               IREC  = NT2BUF(2,JBAT)
               DO IBUF = 1, NBUFA
                  CALL RIMP2T2RD(T3,NINTMX,IFILT2,IREC,IRECNEW,LAUX)
                  IT2A(IBUF) = LAUX
                  DO ICNT = 1, NT2A
                     T2A(ICNT+IT2BGN) = T3(ICNT)
                  END DO
                  IT2BGN = IT2BGN+NT2A
                  IREC = IRECNEW
               END DO
               CALL TSECND(TIMER1)
               TIMER = TIMER+(TIMER1-TIMER0)
C
C              COMMUNICATE 2/3 TRANSFORMED INTEGRAL MATRIX T2
C
               CALL TSECND(TIMEC0)
               CALL DDI_ISEND(NBUFA,INTSIZ,IRANK,IREQ1)
               CALL DDI_IRECV(NBUFB,INTSIZ,JRANK,IREQ2)
               CALL DDI_WAIT(IREQ1)
               CALL DDI_WAIT(IREQ2)
               CALL DDI_ISEND(T2A,8*NBUFA*NT2A,IRANK,IREQ3)
               CALL DDI_IRECV(T3 ,8*NBUFB*NT2B,JRANK,IREQ4)
               CALL DDI_WAIT(IREQ3)
               CALL DDI_WAIT(IREQ4)
               CALL DDI_ISEND(IT2A,INTSIZ*NBUFA,IRANK,IREQ5)
               CALL DDI_IRECV(IT2B,INTSIZ*NBUFB,JRANK,IREQ6)
               CALL DDI_WAIT(IREQ5)
               CALL DDI_WAIT(IREQ6)
               IT2BGN = 0
               DO IBUF = 1, NBUFB
                  LAUX = IT2B(IBUF)
                  DO I = 1, INFOCCBAT(2,IBAT)
                     DO IVIR = 1, NVIR
                        T2(LAUX,IVIR,I) = T3(IVIR+IT2BGN)
                     END DO
                     IT2BGN = IT2BGN+NVIR
                  END DO
               END DO
               CALL TSECND(TIMEC1)
               TIMEC = TIMEC+(TIMEC1-TIMEC0)
            END DO              !IPDIF
         END IF
         CALL DDI_SMP_SYNC()
C
         IOCCBG = INFOCCBAT(1,IBAT)
         DO I = 1, INFOCCBAT(2,IBAT)
            IOCC = IOCCBG+I
C
C           3/3 INTEGRAL TRANSFORMATION.
C           MULTIPLY T2 WITH L^(-1) MATRIX
C
            CALL TSECND(TIME30)
            CALL DIV_EVEN(NVIR,SMP_NP,SMP_ME,NR,SR)
            IT3 = NAUXBAS0*(SR-1)+1
            CALL DGEMM('N','N',NAUXBAS0,NR,NAUXBAS,ONE,V,NAUXBAS0,
     *           T2(1,SR,I),NAUXBAS,ZERO,T3(IT3),NAUXBAS0)
            CALL DDI_SMP_SYNC()
            CALL TSECND(TIME31)
            TIME3 = TIME3+(TIME31-TIME30)
C
C           STORE 3/3 TRANSFORMED INTEGRAL MATRIX T3
C
            CALL TSECND(TIMEW0)
            IF(SMP_ME .EQ. 0) CALL RIMP2T3WT(T3,LENT3,IFILT3,IOCC)
            CALL DDI_SMP_SYNC()
            CALL TSECND(TIMEW1)
            TIMEW = TIMEW+(TIMEW1-TIMEW0)
         END DO                 !I
      END DO                    !IBATP1
C
      IF(MASWRK) WRITE(IW,9999) TIMER,TIMEC,TIME3,TIMEW
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 2/3 INTEGRAL READ           =    ',F9.1,
     *       /1X,'TIME OF 2/3 INTEGRAL NETWORK COMM.  =    ',F9.1,
     *       /1X,'TIME OF 3/3 INTEGRAL TRANSFORMATION =    ',F9.1,
     *       /1X,'TIME OF 3/3 INTEGRAL WRITE          =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIMP2INTTR2SMP
      SUBROUTINE RIMP2INTTR2SMP(V,T2,T3,INFOCCBAT,NT2BUF,
     *     NAUXBAS,NAUXBAS0,NVIR,NINTMX,
     *     NOCCBAT,IFILV,IFILT2,IFILT3,IW,
     *     DDI_NN,DDI_MY,SMP_NP,SMP_ME,USEDM,D_V,D_T)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL USEDM
C
      DOUBLE PRECISION V(NAUXBAS0,NAUXBAS),T2(NAUXBAS,NVIR,*),T3(*)
      INTEGER INFOCCBAT(2,NOCCBAT),NT2BUF(2,NOCCBAT)
C
      INTEGER DDI_NN,DDI_MY
      INTEGER SMP_NP,SMP_ME
      INTEGER NR,SR
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      INTEGER D_V,D_T
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
C     PERFORM 3/3 INTEGRAL TRANSFORMATION.
C     THIS 3/3 ROUTINE IS FOR GOSMP=TRUE AND USEDM=TRUE
C     2/3 TRANSFORMED INTEGRAL DATA IS SORTED
C     BY YOSHIMINE BIN SORT ALGORITHM.
C
      TIMER = ZERO
      TIME3 = ZERO
      TIMEW = ZERO
C
      MYNODE = DDI_MY+1
      NBATP1 = NOCCBAT/DDI_NN
C
      LENT2 = NAUXBAS*NVIR
      LENT3 = NAUXBAS0*NVIR
C
      IF(SMP_ME .EQ. 0) THEN
         IF(.NOT. USEDM) THEN
            REWIND(IFILV)
            READ(IFILV) V
         ELSE
            CALL DDI_GET(D_V,1,NAUXBAS0,1,NAUXBAS,V)
         END IF
      END IF
      CALL DDI_SMP_SYNC()
C
      DO IBATP1 = 1, NBATP1
         IBAT = (MYNODE-1)*NBATP1+IBATP1
C
C        READ 2/3 TRANSFORMED INTEGRAL MATRIX T2
C        BY REFFERING YOSHIMINE DATA CHAIN
C
         CALL TSECND(TIMER0)
C             NOTE THAT THIS ROUTINE IS CALLED WITH USEDM TRUE...
         IF(.NOT. USEDM) THEN
            IF(SMP_ME .EQ. 0) THEN
               NBUF = NT2BUF(1,IBAT)
               IREC = NT2BUF(2,IBAT)
               DO IBUF = 1, NBUF
                  CALL RIMP2T2RD(T3,NINTMX,IFILT2,IREC,IRECNEW,LAUX)
                  IT2BGN = 0
                  DO I = 1, INFOCCBAT(2,IBAT)
                     DO IVIR = 1, NVIR
                        T2(LAUX,IVIR,I) = T3(IVIR+IT2BGN)
                     END DO
                     IT2BGN = IT2BGN+NVIR
                  END DO
                  IREC = IRECNEW
               END DO
            END IF
            CALL DDI_SMP_SYNC()
         END IF
         CALL TSECND(TIMER1)
         TIMER = TIMER+(TIMER1-TIMER0)
C
         IOCCBG = INFOCCBAT(1,IBAT)
         DO I = 1, INFOCCBAT(2,IBAT)
            IOCC = IOCCBG+I
            IF(USEDM) THEN
               IF(SMP_ME .EQ. 0) THEN
                  CALL DDI_GET(D_T,1,LENT2,IOCC,IOCC,T3)
                  ICNT=0
                  DO LAUX = 1, NAUXBAS
                     DO IVIR = 1, NVIR
                        ICNT = ICNT+1
                        T2(LAUX,IVIR,I) = T3(ICNT)
                     END DO
                  END DO
               END IF
               CALL DDI_SMP_SYNC()
            END IF
C
C           3/3 INTEGRAL TRANSFORMATION.
C           MULTIPLY T2 WITH L^(-1) MATRIX
C
            CALL TSECND(TIME30)
            CALL DIV_EVEN(NVIR,SMP_NP,SMP_ME,NR,SR)
            IT3 = NAUXBAS0*(SR-1)+1
            CALL DGEMM('N','N',NAUXBAS0,NR,NAUXBAS,ONE,V,NAUXBAS0,
     *           T2(1,SR,I),NAUXBAS,ZERO,T3(IT3),NAUXBAS0)
            CALL DDI_SMP_SYNC()
            CALL TSECND(TIME31)
            TIME3 = TIME3+(TIME31-TIME30)
C
C           STORE 3/3 TRANSFORMED INTEGRAL MATRIX T3
C
            CALL TSECND(TIMEW0)
            IF(SMP_ME.EQ.0) THEN
               IF(USEDM) THEN
                 CALL DDI_PUT(D_T,1,LENT3,IOCC,IOCC,T3)
               ELSE
                 CALL RIMP2T3WT(T3,LENT3,IFILT3,IOCC)
               END IF
            END IF
            CALL DDI_SMP_SYNC()
            CALL TSECND(TIMEW1)
            TIMEW = TIMEW+(TIMEW1-TIMEW0)
C
         END DO                 !I
      END DO                    !IBAT
C
      IF(MASWRK) WRITE(IW,9999) TIMER,TIME3,TIMEW
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 2/3 INTEGRAL READ           =    ',F9.1,
     *       /1X,'TIME OF 3/3 INTEGRAL TRANSFORMATION =    ',F9.1,
     *       /1X,'TIME OF 3/3 INTEGRAL WRITE          =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIMP2INTTRN
      SUBROUTINE RIMP2INTTRN(LOCSPH,INFOCCABAT,INFOCCBBAT,
     *     NSHELL,NBASIS,NAUXSH,NAUXBAS,NAUXBASD,
     *     NORBA,NORBB,NOCCA,NOCCB,NVIRA,NVIRB,NACORE,NBCORE,
     *     NINTMXA,NINTMXB,NOCCBAT,LENOCCABAT,LENOCCBBAT,IAUXBF,USEDM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL SPHAUX,USEDM
C
      INTEGER LOCSPH(*),INFOCCABAT(*),INFOCCBBAT(*)
C
      PARAMETER (MXSH=5000, MXGTOT=20000)
      PARAMETER (MXAUXSH=10000, MXAXGTOT=20000)
      PARAMETER (MXATM=2000, MXAO=8192)
C
      COMMON /AUXBAS/ EXAUX(MXAXGTOT),CAUXS(MXAXGTOT),CAUXP(MXAXGTOT),
     *                CAUXD(MXAXGTOT),CAUXF(MXAXGTOT),CAUXG(MXAXGTOT),
     *                CAUXH(MXAXGTOT),CAUXI(MXAXGTOT),
     *                KAUXST(MXAUXSH),KAUXAT(MXAUXSH),KAUXTY(MXAUXSH),
     *                KAUXNG(MXAUXSH),KAUXLO(MXAUXSH),KAUXMI(MXAUXSH),
     *                KAUXMX(MXAUXSH),NAUXSHX
      COMMON /FMCOM / X(1)
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELLX
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      COMMON /RIMPFI/ IFILV,IFILT2A,IFILT3A,IFILT2B,IFILT3B
C
      INTEGER D_V,D_TA,D_TB
      COMMON /RIMPDD/ D_V,D_TA,D_TB
C
      DATA CHECK    /8HCHECK   /
      DATA RHF      /8HRHF     /
      DATA UHF      /8HUHF     /
C
C     SUB DRIVER FOR INTEGRAL TRANSFORMATION OF 3C-2E ERIS (PQ|L).
C     RIMP2INTTR1: ERI EVALUATION AND FIRST 1/3 AND 2/3 TRANSFORMATION
C     RIMP2INTTR2: 3/3 TRANSFORMATION
C
      SPHAUX = .FALSE.
      IF(IAUXBF .EQ. 1) SPHAUX = .TRUE.
C
C     CHECK HIGHEST ANGLAR MOMENTUM OF ATOMIC ORBITAL AND
C     AUXILIARY BASIS FUNCTIONS.
C
      KANG = 0
      DO N = 1, NSHELL
         IF(KTYPE(N)  .GT. KANG) KANG = KTYPE(N)
      END DO
      DO N = 1, NAUXSH
         IF(KAUXTY(N) .GT. KANG) KANG = KAUXTY(N)
      END DO
      LMAX = KANG-1
                    NANGM =  4
      IF(LMAX.EQ.2) NANGM =  6
      IF(LMAX.EQ.3) NANGM = 10
      IF(LMAX.EQ.4) NANGM = 15
      IF(LMAX.EQ.5) NANGM = 21
      IF(LMAX.EQ.6) NANGM = 28
                 MAXG = NANGM**3
C
C     ALLOCATE MEMORY FOR BATCH INFORMATION OF
C     2/3 TRANSFORMED INTEGRALS TO BE STORED IN DISKS.
C
      CALL VALFM(LOADFM)
      LNT2ABUF = LOADFM    + 1
      LAST     = LNT2ABUF  + 2*NOCCBAT
      IF(SCFTYP .EQ. UHF) THEN
         LNT2BBUF = LAST
         LAST     = LNT2BBUF  + 2*NOCCBAT
      END IF
      INEED0   = LAST-LOADFM-1
      CALL GETFM(INEED0)
C
C     ALLOCATE MEMORY FOR RIMP2INTTR1
C
      NBF2   = NBASIS*(NBASIS+1)/2
      NBF3   = NBASIS*NBASIS
      CALL VALFM(LOADFM)
      LVECA    = LOADFM   + 1
      LAST     = LVECA    + NBF3
      IF(SCFTYP .EQ. UHF) THEN
         LVECB    = LAST
         LAST     = LVECB    + NBF3
      END IF
      INEED1   = LAST-LOADFM-1
      CALL GETFM(INEED1)
C
C     READ MOLECULAR ORBITALS
C
      IF(EXETYP .NE. CHECK) THEN
         CALL DAREAD(IDAF,IODA,X(LVECA),NBF3,15,0)
         NORB = NORBA+NACORE
         MAXC = IDAMAX(NBASIS*NORB,X(LVECA),1)
         IF(ABS(X(LVECA+MAXC-1)).GT.1.0D+02) THEN
            MAXM = 1 + MAXC/NBASIS
            MAXA = MAXC - NBASIS*(MAXM-1)
            IF(MASWRK) WRITE(IW,9030) ABS(X(LVECA+MAXC-1)),MAXA,MAXM
         END IF
         IF(SCFTYP .EQ. UHF) THEN
            CALL DAREAD(IDAF,IODA,X(LVECB),NBF3,19,0)
            NORB = NORBB+NBCORE
            MAXC = IDAMAX(NBASIS*NORB,X(LVECB),1)
            IF(ABS(X(LVECB+MAXC-1)).GT.1.0D+02) THEN
               MAXM = 1 + MAXC/NBASIS
               MAXA = MAXC - NBASIS*(MAXM-1)
               IF(MASWRK) WRITE(IW,9030) ABS(X(LVECB+MAXC-1)),MAXA,MAXM
            END IF
         END IF
      END IF
C
C     ALLOCATE MEMORY FOR AO TRANSFORMATIONS
C     (CARTESIAN->SPHERICAL HARMONIC)
C
      CALL VALFM(LOADFM)
      LS     = LOADFM + 1
      LQ     = LS     + NBF2
      LWRK   = LQ     + NBF3
      LMOLAB = LWRK   + NBASIS
      LMOIRP = LMOLAB + NBASIS
      LMODEG = LMOIRP + NBASIS
      LAST   = LMODEG + NBASIS
      NEEDS  = LAST   - LOADFM+1
C--   IF(MASWRK) WRITE(IW,9010) INEED0+INEED1+INEEDS
      CALL GETFM(NEEDS)
C
C     DO AO TRANSFORMATIONS (CARTESIAN->SPHERICAL HARMONIC)
C
      IF(EXETYP .NE. CHECK) THEN
         CALL DAREAD(IDAF,IODA,X(LS),NBF2,12,0)
         CALL DAREAD(IDAF,IODA,X(LQ),NBF3,45,0)
         NORB = NORBA+NACORE
         CALL TRFSYM(X(LMOLAB),X(LMOIRP),X(LMODEG),X(LQ),X(LS),
     *        X(LVECA),X(LWRK),IA,NQMT,NBASIS,NORB,NBASIS)
         IF(SCFTYP .EQ. UHF) THEN
            CALL DAREAD(IDAF,IODA,X(LQ),NBF3,45,0)
            NORB = NORBB+NBCORE
            CALL TRFSYM(X(LMOLAB),X(LMOIRP),X(LMODEG),X(LQ),X(LS),
     *           X(LVECB),X(LWRK),IA,NQMT,NBASIS,NORB,NBASIS)
         END IF
      END IF
C
C     FREE MEMORY
C
      CALL RETFM(NEEDS)
C
C     REMOVE CORE MOLECULAR ORBITALS
C
      IF(EXETYP .NE. CHECK) THEN
         CALL RIMP2SHIFTORB(X(LVECA),NBASIS,NORBA,NACORE)
         IF(SCFTYP .EQ. UHF)
     *        CALL RIMP2SHIFTORB(X(LVECB),NBASIS,NORBB,NBCORE)
      END IF
C
C     ALLOCATE MEMORY FOR 1/3 AND 2/3 INDEX TRANSFORMATIONS
C
      CALL VALFM(LOADFM)
      LCC      = LOADFM   + 1
      LT0      = LCC      + 9
      LT1      = LT0      + NBF3*NANGM
      LT2      = LT1
     *         + MAX(NOCCA*NBASIS,NOCCB*NBASIS,NINTMXA,NINTMXB,MAXG)
      LW       = LT2      + MAX(NOCCA*NVIRA,NOCCB*NVIRB,MAXG)
      LAST     = LW       + NANGM*NANGM
      INEED2   = LAST-LOADFM-1
      IF(MASWRK) WRITE(IW,9010) INEED0+INEED1+INEED2
      CALL FLSHBF(IW)
      CALL GETFM(INEED2)
C
C     PERFORM 1/3 AND 2/3 INDEX TRANSFORMATIONS
C
      IF(EXETYP .NE. CHECK) THEN
         IF(SCFTYP .EQ. RHF) THEN
            CALL RIMP2INTTR1(X(LVECA),X(LCC),X(LT0),X(LT1),X(LT2),X(LW),
     *           LOCSPH,INFOCCABAT,X(LNT2ABUF),
     *           NSHELL,NBASIS,NAUXSH,NOCCA,NVIRA,
     *           NINTMXA,NOCCBAT,IFILT2A,IW,SPHAUX,USEDM)
         ELSE IF(SCFTYP .EQ. UHF) THEN
            CALL RIUMP2INTTR1(X(LVECA),X(LVECB),X(LCC),X(LT0),X(LT1),
     *           X(LT2),X(LW),LOCSPH,INFOCCABAT,INFOCCBBAT,X(LNT2ABUF),
     *           X(LNT2BBUF),
     *           NSHELL,NBASIS,NAUXSH,NOCCA,NOCCB,
     *           NVIRA,NVIRB,NINTMXA,NINTMXB,NOCCBAT,
     *           IFILT2A,IFILT2B,IW,SPHAUX,USEDM)
         END IF
      END IF
      CALL DDI_SYNC(5131)
C
C     FREE REPLICATED MEMORY USED DURING 1/3 AND 2/3 TRANSFORMATIONS
C
      CALL RETFM(INEED2)
      CALL RETFM(INEED1)
C
C     ALLOCATE MEMORY FOR 3/3 INDEX TRANSFORMATION
C
      CALL VALFM(LOADFM)
      IF(SCFTYP .EQ. RHF) THEN
         L1 = NAUXBAS*NAUXBAS
         L2 = NAUXBAS*NVIRA
         L3 = NAUXBAS*NVIRA*LENOCCABAT
         L4 = NINTMXA
         L5 = NAUXBAS*NINTMXA
      ELSE IF(SCFTYP .EQ. UHF) THEN
         L1 = NAUXBAS*NAUXBAS
         L2 = NAUXBAS*MAX(NVIRA,NVIRB)
         L3 = NAUXBAS*MAX(NVIRA,NVIRB)*MAX(LENOCCABAT,LENOCCBBAT)
         L4 = MAX(NINTMXA,NINTMXB)
         L5 = NAUXBAS*MAX(NINTMXA,NINTMXB)
      END IF
      LV       = LOADFM   + 1
      LT2      = LV       + L1
      LT3      = LT2      + L3
      LAST     = LT3      + MAX(L2,L4)
      IF(GOPARR .AND. .NOT. USEDM) THEN
         LTA      = LT3      + MAX(L2,L4,L5)
         LITA     = LTA      + L5
         LITB     = LITA     + NAUXBAS
         LAST     = LITB     + NAUXBAS
CC       LITB     = LITA     + NLMAX
CC       LAST     = LITB     + NLMAX
      END IF
      INEED3   = LAST-LOADFM-1
      IF(MASWRK) WRITE(IW,9020) INEED0+INEED3
      CALL FLSHBF(IW)
      CALL GETFM(INEED3)
C
C     PERFORM 3/3 INDEX TRANSFORMATION
C     MULTIPLY CHOLESKY DECOMPOSED MATRIX OF V^(-1) MATRIX
C
      IF(EXETYP .NE. CHECK) THEN
         IF(GOPARR .AND. .NOT. USEDM) THEN
            CALL RIMP2INTTR2P(X(LV),X(LT2),X(LT3),X(LTA),
     *           INFOCCABAT,X(LITA),X(LITB),X(LNT2ABUF),
     *           NAUXBAS,NAUXBASD,NVIRA,NINTMXA,
     *           NOCCBAT,IFILV,IFILT2A,IFILT3A,IW)
            IF(SCFTYP .EQ. UHF) THEN
               CALL RIMP2INTTR2P(X(LV),X(LT2),X(LT3),X(LTA),
     *              INFOCCBBAT,X(LITA),X(LITB),X(LNT2BBUF),
     *              NAUXBAS,NAUXBASD,NVIRB,NINTMXB,
     *              NOCCBAT,IFILV,IFILT2B,IFILT3B,IW)
            END IF
         ELSE
            CALL RIMP2INTTR2(X(LV),X(LT2),X(LT3),INFOCCABAT,X(LNT2ABUF),
     *           NAUXBAS,NAUXBASD,NVIRA,NINTMXA,
     *           NOCCBAT,IFILV,IFILT2A,IFILT3A,IW,USEDM,D_V,D_TA)
            IF(SCFTYP .EQ. UHF) THEN
               CALL RIMP2INTTR2(X(LV),X(LT2),X(LT3),INFOCCBBAT,
     *              X(LNT2BBUF),
     *              NAUXBAS,NAUXBASD,NVIRB,NINTMXB,
     *              NOCCBAT,IFILV,IFILT2B,IFILT3B,IW,USEDM,D_V,D_TB)
            END IF
         END IF
      END IF
C
C     FREE MEMORY FOR INTTR2
C
      CALL RETFM(INEED3)
      CALL RETFM(INEED0)
C
      RETURN
 9010 FORMAT(/1X,'MEMORY REQUIRED FOR 1/3 TRANSFORMATION',11X,'=',
     *       I12,' WORDS')
 9020 FORMAT(/1X,'MEMORY REQUIRED FOR 2/3 TRANSFORMATION',11X,'=',
     *       I12,' WORDS')
 9030 FORMAT(/1X,'*** WARNING: THE MAXIMUM LCAO COEF=',F15.6,
     *           ', FOR AO',I6,' IN MO=',I6,','/
     *        1X,'EXCEEDS 100.  ADDITIONAL INPUTS MAY BE REQUIRED TO',
     *           ' OBTAIN GOOD MP2 ACCURACY:'/
     *        1X,' $CONTRL ICUT=10 OR 11'/
     *        1X,' $SCF    CONV=2.5D-7 FDIFF=.FALSE.'/)
      END
C*MODULE RIMP2   *DECK RIMP2INTTRNSMP
      SUBROUTINE RIMP2INTTRNSMP(LOCSPH,INFOCCABAT,INFOCCBBAT,
     *     NSHELL,NBASIS,NAUXSH,NAUXBAS,NAUXBASD,
     *     NORBA,NORBB,NOCCA,NOCCB,NVIRA,NVIRB,NACORE,NBCORE,
     *     NINTMXA,NINTMXB,NOCCBAT,LENOCCABAT,LENOCCBBAT,IAUXBF,USEDM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL GONODE,DEBUG
      LOGICAL SPHAUX,USEDM
C
      CHARACTER*1 ADDR(1)
      INTEGER DDI_NP,DDI_ME,DDI_NN,DDI_MY
      INTEGER SMP_NP,SMP_ME
C
      INTEGER D_NT2ABUF,D_NT2BBUF
      INTEGER D_T0,D_T1,D_T2,D_V,D_T3,D_TA,D_ITA,D_ITB
      INTEGER LNT2ABUF,LNT2BBUF
      INTEGER LT0,LT1,LT2,LV,LT3,LTA,LITA,LITB
      INTEGER SHARED_T1,SHARED_T2
C
      INTEGER LOCSPH(*),INFOCCABAT(*),INFOCCBBAT(*)
C
      PARAMETER (MXSH=5000, MXGTOT=20000)
      PARAMETER (MXAUXSH=10000, MXAXGTOT=20000)
      PARAMETER (MXATM=2000, MXAO=8192)
C
      COMMON /AUXBAS/ EXAUX(MXAXGTOT),CAUXS(MXAXGTOT),CAUXP(MXAXGTOT),
     *                CAUXD(MXAXGTOT),CAUXF(MXAXGTOT),CAUXG(MXAXGTOT),
     *                CAUXH(MXAXGTOT),CAUXI(MXAXGTOT),
     *                KAUXST(MXAUXSH),KAUXAT(MXAUXSH),KAUXTY(MXAUXSH),
     *                KAUXNG(MXAUXSH),KAUXLO(MXAUXSH),KAUXMI(MXAUXSH),
     *                KAUXMX(MXAUXSH),NAUXSHX
      COMMON /FMCOM / X(1)
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELLX
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      COMMON /RIMPFI/ IFILV,IFILT2A,IFILT3A,IFILT2B,IFILT3B
C
      INTEGER D_VD,D_TAD,D_TBD
      COMMON /RIMPDD/ D_VD,D_TAD,D_TBD
C
      DATA CHECK    /8HCHECK   /
      DATA RHF      /8HRHF     /
      DATA UHF      /8HUHF     /
C
C     SUB DRIVER FOR INTEGRAL TRANSFORMATION OF 3C-2E ERIS (PQ|L).
C     RIMP2INTTR1: ERI EVALUATION AND FIRST 1/3 AND 2/3 TRANSFORMATION
C     RIMP2INTTR2: 3/3 TRANSFORMATION
C
      CALL DDI_NPROC(DDI_NP,DDI_ME)
      CALL DDI_NNODE(DDI_NN,DDI_MY)
      CALL DDI_SMP_NPROC(SMP_NP,SMP_ME)
      GONODE = DDI_NN .GT. 1
C
      SPHAUX = .FALSE.
      IF(IAUXBF .EQ. 1) SPHAUX = .TRUE.
C
C     CHECK HIGHEST ANGLAR MOMENTUM OF ATOMIC ORBITAL AND
C     AUXILIARY BASIS FUNCTIONS.
C
      KANG = 0
      DO N = 1, NSHELL
         IF(KTYPE(N)  .GT. KANG) KANG = KTYPE(N)
      END DO
      DO N = 1, NAUXSH
         IF(KAUXTY(N) .GT. KANG) KANG = KAUXTY(N)
      END DO
      LMAX = KANG-1
                    NANGM =  4
      IF(LMAX.EQ.2) NANGM =  6
      IF(LMAX.EQ.3) NANGM = 10
      IF(LMAX.EQ.4) NANGM = 15
      IF(LMAX.EQ.5) NANGM = 21
      IF(LMAX.EQ.6) NANGM = 28
                 MAXG = NANGM**3
C
C     ALLOCATE SHARED MEMORY FOR BATCH INFORMATION OF
C     2/3 TRANSFORMED INTEGRALS TO BE STORED IN DISKS.
C
      CALL DDI_SMP_CREATE(2*NOCCBAT,D_NT2ABUF)
C     DETERMINE OFFSETS FOR SHARED MEMORY ARRAYSD
      CALL DDI_SMP_OFFSET(D_NT2ABUF,ADDR,LNT2ABUF)
      LNT2ABUF = LNT2ABUF+1
      IF(SCFTYP .EQ. UHF) THEN
         CALL DDI_SMP_CREATE(2*NOCCBAT,D_NT2BBUF)
C        DETERMINE OFFSETS FOR SHARED MEMORY ARRAYSD
         CALL DDI_SMP_OFFSET(D_NT2BBUF,ADDR,LNT2BBUF)
         LNT2BBUF = LNT2BBUF+1
      END IF
C
      CALL DDI_SMP_SYNC()
C
C     SPECIFY MATRIX SIZES
C
      NBF2 = NBASIS*(NBASIS+1)/2
      NBF3 = NBASIS*NBASIS
C
C     ALLOCATE REPLICATED MEMORY FOR VEC
C
      CALL VALFM(LOADFM)
      LVECA  = LOADFM + 1
      LAST   = LVECA  + NBF3
      IF(SCFTYP .EQ. UHF) THEN
         LVECB  = LAST
         LAST   = LVECB  + NBF3
      END IF
      NEEDV = LAST-LOADFM-1
      CALL GETFM(NEEDV)
C
C     READ MOLECULAR ORBITALS
C
      IF(EXETYP .NE. CHECK) THEN
         CALL DAREAD(IDAF,IODA,X(LVECA),NBF3,15,0)
         NORB = NORBA+NACORE
         MAXC = IDAMAX(NBASIS*NORB,X(LVECA),1)
         IF(ABS(X(LVECA+MAXC-1)).GT.1.0D+02) THEN
            MAXM = 1 + MAXC/NBASIS
            MAXA = MAXC - NBASIS*(MAXM-1)
            IF(MASWRK) WRITE(IW,9030) ABS(X(LVECA+MAXC-1)),MAXA,MAXM
         END IF
         IF(SCFTYP .EQ. UHF) THEN
            CALL DAREAD(IDAF,IODA,X(LVECB),NBF3,19,0)
            NORB = NORBB+NBCORE
            MAXC = IDAMAX(NBASIS*NORB,X(LVECB),1)
            IF(ABS(X(LVECB+MAXC-1)).GT.1.0D+02) THEN
               MAXM = 1 + MAXC/NBASIS
               MAXA = MAXC - NBASIS*(MAXM-1)
               IF(MASWRK) WRITE(IW,9030) ABS(X(LVECB+MAXC-1)),MAXA,MAXM
            END IF
         END IF
      END IF
C
C     ALLOCATE MEMORY FOR AO TRANSFORMATIONS
C     (CARTESIAN->SPHERICAL HARMONIC)
C
      CALL VALFM(LOADFM)
      LS     = LOADFM + 1
      LQ     = LS     + NBF2
      LWRK   = LQ     + NBF3
      LMOLAB = LWRK   + NBASIS
      LMOIRP = LMOLAB + NBASIS
      LMODEG = LMOIRP + NBASIS
      LAST   = LMODEG + NBASIS
      NEEDS  = LAST   - LOADFM+1
      CALL GETFM(NEEDS)
C
C     TRANSFORM CARTESIAN TO SPHERICAL HARMONICS
C
      IF(EXETYP .NE. CHECK) THEN
         CALL DAREAD(IDAF,IODA,X(LS),NBF2,12,0)
         CALL DAREAD(IDAF,IODA,X(LQ),NBF3,45,0)
         NORB = NORBA+NACORE
         CALL TRFSYM(X(LMOLAB),X(LMOIRP),X(LMODEG),X(LQ),X(LS),
     *        X(LVECA),X(LWRK),IA,NQMT,NBASIS,NORB,NBASIS)
         IF(SCFTYP .EQ. UHF) THEN
            CALL DAREAD(IDAF,IODA,X(LQ),NBF3,45,0)
            NORB = NORBB+NBCORE
            CALL TRFSYM(X(LMOLAB),X(LMOIRP),X(LMODEG),X(LQ),X(LS),
     *           X(LVECB),X(LWRK),IA,NQMT,NBASIS,NORB,NBASIS)
         END IF
      END IF
C
C     FREE REPLICATED MEMORY
C
      CALL RETFM(NEEDS)
C
C     REMOVE CORE MOLECULAR ORBITALS
C
      IF(EXETYP .NE. CHECK) THEN
         CALL RIMP2SHIFTORB(X(LVECA),NBASIS,NORBA,NACORE)
         IF(SCFTYP .EQ. UHF)
     *        CALL RIMP2SHIFTORB(X(LVECB),NBASIS,NORBB,NBCORE)
      END IF
C
C     ALLOCATE MEMORY FOR 1/3 AND 2/3 INDEX TRANSFORMATIONS
C
      CALL VALFM(LOADFM)
      LCC     = LOADFM  + 1
      LGHONDO = LCC     + 9
      LTL     = LGHONDO + MAXG
      LW      = LTL     + NANGM*NANGM
      LT2BUFF = LW      + NANGM*NANGM
      LAST    = LT2BUFF + MAX(NOCCA*NVIRA,NOCCB*NVIRB)
      NEED1   = LAST-LOADFM-1
      IF(MASWRK) WRITE(IW,9010) NEEDV+NEED1
      CALL FLSHBF(IW)
      CALL GETFM(NEED1)
C
C     ESTIMATE SHARED MEMORY
C
      LENT0 = NBF3*NANGM
      LENT1 = MAX(NOCCA*NBASIS,NOCCB*NBASIS,NINTMXA,NINTMXB)
      LENT2 = MAX(NOCCA*NVIRA,NOCCB*NVIRB)
      SHARED_T1 = LENT0+LENT1+LENT2
      GBYTES = 8*SHARED_T1/(1024.0D+00**3)
      IF(MASWRK) WRITE(IW,9020) 1,SHARED_T1,GBYTES
C
C     ALLOCATE SHARED MEMORY
C
      CALL DDI_SMP_CREATE(LENT0,D_T0)
      CALL DDI_SMP_CREATE(LENT1,D_T1)
      CALL DDI_SMP_CREATE(LENT2,D_T2)
C     DETERMINE OFFSETS FOR SHARED MEMORY ARRAYS
      CALL DDI_SMP_OFFSET(D_T0,ADDR,LT0)
      CALL DDI_SMP_OFFSET(D_T1,ADDR,LT1)
      CALL DDI_SMP_OFFSET(D_T2,ADDR,LT2)
C
      LT0 = LT0+1
      LT1 = LT1+1
      LT2 = LT2+1
C
      CALL DDI_SMP_SYNC()
C
C     PERFORM 1/3 AND 2/3 INDEX TRANSFORMATIONS
C
      IF(EXETYP .NE. CHECK) THEN
         IF(SCFTYP .EQ. RHF) THEN
            CALL RIMP2INTTR1SMP(X(LVECA),X(LCC),
     *           ADDR(LT0),ADDR(LT1),ADDR(LT2),X(LT2BUFF),
     *           X(LGHONDO),X(LTL),X(LW),LOCSPH,
     *           INFOCCABAT,ADDR(LNT2ABUF),
     *           NSHELL,NBASIS,NAUXSH,
     *           NOCCA,NVIRA,NINTMXA,NOCCBAT,
     *           IFILT2A,IW,SPHAUX,USEDM,
     *           DDI_NN,DDI_MY,SMP_NP,SMP_ME)
         ELSE IF(SCFTYP .EQ. UHF) THEN
            CALL RIUMP2INTTR1SMP(X(LVECA),X(LVECB),X(LCC),
     *           ADDR(LT0),ADDR(LT1),ADDR(LT2),X(LT2BUFF),
     *           X(LGHONDO),X(LTL),X(LW),LOCSPH,
     *           INFOCCABAT,INFOCCBBAT,ADDR(LNT2ABUF),ADDR(LNT2BBUF),
     *           NSHELL,NBASIS,NAUXSH,
     *           NOCCA,NOCCB,NVIRA,NVIRB,NINTMXA,NINTMXB,NOCCBAT,
     *           IFILT2A,IFILT2B,IW,SPHAUX,USEDM,
     *           DDI_NN,DDI_MY,SMP_NP,SMP_ME)
         END IF
      END IF
      CALL DDI_SYNC(5132)
C
C     DESTROY SHARED-MEMORY ARRAYS
C
      CALL DDI_SMP_DESTROY(D_T0)
      CALL DDI_SMP_DESTROY(D_T1)
      CALL DDI_SMP_DESTROY(D_T2)
      CALL DDI_SMP_SYNC()
C
C     FREE REPLICATED MEMORY FOR 1/3 AND 2/3 TRANSFORMATIONS
C     FREE REPLICATED MEMORY FOR VECTORS
C
      CALL RETFM(NEED1)
      CALL RETFM(NEEDV)
C
C          THIS IS A GOOD PLACE TO LEAVE SOME DEBUGGING CODE,
C          BUT NOT TURNED ON, SINCE THE PRINT FILE IS ALWAYS 6.
C
      DEBUG = IW.LT.0  .AND.  USEDM
      IF(.NOT.DEBUG) GO TO 500
C
C          THE FOLLOWING PRINTS THE ALPHA T2 DISTRIBUTED MATRIX.
C          IT WOULD BE EASY TO VERIFY THE BETA MATRIX IF YOU WISH.
C
      IF(MASWRK) THEN
         WRITE(IW,8013) D_TAD,NAUXBAS,NVIRA,NOCCA
C
         CALL VALFM(LOADFM)
         LBUF = LOADFM + 1
         LAST = LBUF   + NVIRA*NOCCA
         NEEDDBG = LAST - LOADFM - 1
         CALL GETFM(NEEDDBG)
C                SHOW THE SUM OF ONLY A FEW ROWS
         DO LAUX = 1,MIN(10,NAUXBAS)
            IBG=NVIRA*(LAUX-1)+1
            IED=NVIRA*LAUX
            CALL DDI_GET(D_TAD,IBG,IED,1,NOCCA,X(LBUF))
            CALL MTXCHECK(X(LBUF),NVIRA,NVIRA,NOCCA,1,ABSSUM)
            WRITE(IW,8015) LAUX,ABSSUM
         ENDDO
         CALL RETFM(NEEDDBG)
C
         CALL VALFM(LOADFM)
         LBUF = LOADFM + 1
         LAST = LBUF   + NAUXBAS*NVIRA
         NEEDDBG = LAST - LOADFM - 1
         CALL GETFM(NEEDDBG)
         LENCOL = NAUXBAS*NVIRA
         DO I=1,NOCCA
            CALL DDI_GET(D_TAD,1,LENCOL,I,I,X(LBUF))
            CALL MTXCHECK(X(LBUF),LENCOL,LENCOL,1,1,ABSSUM)
            WRITE(IW,8017) I,ABSSUM
         ENDDO
         CALL RETFM(NEEDDBG)
      END IF
      CALL DDI_SYNC(5232)
 8013 FORMAT(1X,'DM=',I4,' WITH ROWS NAUXBAS=',I6,' * NVIRA=',I5,
     *          ' AND COLS NOCCA=',I5)
 8015 FORMAT(1X,'HAS    ROW=',I5,'''S ABSOLUTE VALUE SUM =',F22.8)
 8017 FORMAT(1X,'HAS COLUMN=',I5,'''S ABSOLUTE VALUE SUM =',F22.8)
C
C     ESTIMATE SHARED MEMORY FOR 3RD INDEX TRANSFORMATION
C
  500 CONTINUE
      IF(SCFTYP .EQ. RHF) THEN
         L1 = NAUXBAS*NAUXBAS
         L2 = NAUXBAS*NVIRA
         L3 = NAUXBAS*NVIRA*LENOCCABAT
         L4 = NINTMXA
         L5 = NAUXBAS*NINTMXA
      ELSE IF(SCFTYP .EQ. UHF) THEN
         L1 = NAUXBAS*NAUXBAS
         L2 = NAUXBAS*MAX(NVIRA,NVIRB)
         L3 = NAUXBAS*MAX(NVIRA,NVIRB)*MAX(LENOCCABAT,LENOCCBBAT)
         L4 = MAX(NINTMXA,NINTMXB)
         L5 = NAUXBAS*MAX(NINTMXA,NINTMXB)
      END IF
      IF(GONODE) THEN
         SHARED_T2 = L1+L3+MAX(L2,L4,L5)+L5+2*NAUXBAS
      ELSE
         SHARED_T2 = L1+L3+MAX(L2,L4,L5)
      END IF
      GBYTES = 8*SHARED_T2/(1024.0D+00**3)
      IF(MASWRK) WRITE(IW,9020) 2,SHARED_T2,GBYTES
C
C     ALLOCATE SHARED MEMORY
C
      CALL DDI_SMP_CREATE(L1,D_V)
      CALL DDI_SMP_CREATE(L3,D_T2)
      CALL DDI_SMP_CREATE(MAX(L2,L4,L5),D_T3)
      IF(GONODE) THEN
         CALL DDI_SMP_CREATE(L5,D_TA)
         CALL DDI_SMP_CREATE(NAUXBAS,D_ITA)
         CALL DDI_SMP_CREATE(NAUXBAS,D_ITB)
      END IF
C     DETERMINE OFFSETS FOR SHARED MEMORY ARRAYS
      CALL DDI_SMP_OFFSET(D_V,ADDR,LV)
      CALL DDI_SMP_OFFSET(D_T2,ADDR,LT2)
      CALL DDI_SMP_OFFSET(D_T3,ADDR,LT3)
      IF(GONODE) THEN
         CALL DDI_SMP_OFFSET(D_TA,ADDR,LTA)
         CALL DDI_SMP_OFFSET(D_ITA,ADDR,LITA)
         CALL DDI_SMP_OFFSET(D_ITB,ADDR,LITB)
      END IF
C
      LV  = LV+1
      LT2 = LT2+1
      LT3 = LT3+1
      IF(GONODE) THEN
         LTA  = LTA+1
         LITA = LITA+1
         LITB = LITB+1
      END IF
C
      CALL DDI_SMP_SYNC()
C
C     PERFORM 3/3 INDEX TRANSFORMATION
C     MULTIPLY CHOLESKY DECOMPOSED MATRIX OF V^(-1) MATRIX
C
      IF(EXETYP .NE. CHECK) THEN
         IF(GONODE .AND. .NOT. USEDM) THEN
            CALL RIMP2INTTR2PSMP(ADDR(LV),ADDR(LT2),ADDR(LT3),ADDR(LTA),
     *           INFOCCABAT,ADDR(LITA),ADDR(LITB),ADDR(LNT2ABUF),
     *           NAUXBAS,NAUXBASD,NVIRA,NINTMXA,
     *           NOCCBAT,IFILV,IFILT2A,IFILT3A,IW,
     *           DDI_NN,DDI_MY,SMP_NP,SMP_ME)
            IF(SCFTYP .EQ. UHF) THEN
               CALL RIMP2INTTR2PSMP(ADDR(LV),ADDR(LT2),ADDR(LT3),
     *              ADDR(LTA),
     *              INFOCCBBAT,ADDR(LITA),ADDR(LITB),ADDR(LNT2BBUF),
     *              NAUXBAS,NAUXBASD,NVIRB,NINTMXB,
     *              NOCCBAT,IFILV,IFILT2B,IFILT3B,IW,
     *              DDI_NN,DDI_MY,SMP_NP,SMP_ME)
            END IF
         ELSE
            CALL RIMP2INTTR2SMP(ADDR(LV),ADDR(LT2),ADDR(LT3),INFOCCABAT,
     *           ADDR(LNT2ABUF),
     *           NAUXBAS,NAUXBASD,NVIRA,NINTMXA,
     *           NOCCBAT,IFILV,IFILT2A,IFILT3A,IW,
     *           DDI_NN,DDI_MY,SMP_NP,SMP_ME,USEDM,D_VD,D_TAD)
            IF(SCFTYP .EQ. UHF) THEN
               CALL RIMP2INTTR2SMP(ADDR(LV),ADDR(LT2),ADDR(LT3),
     *              INFOCCBBAT,ADDR(LNT2BBUF),
     *              NAUXBAS,NAUXBASD,NVIRB,NINTMXB,
     *              NOCCBAT,IFILV,IFILT2B,IFILT3B,IW,
     *              DDI_NN,DDI_MY,SMP_NP,SMP_ME,USEDM,D_VD,D_TBD)
            END IF
         END IF
      END IF
C
C     DESTROY SHARED-MEMORY ARRAYS
C
      CALL DDI_SMP_DESTROY(D_V)
      CALL DDI_SMP_DESTROY(D_T2)
      CALL DDI_SMP_DESTROY(D_T3)
      IF(GONODE) THEN
         CALL DDI_SMP_DESTROY(D_TA)
         CALL DDI_SMP_DESTROY(D_ITA)
         CALL DDI_SMP_DESTROY(D_ITB)
      END IF
C
C     DESTROY SHARED-MEMORY ARRAYS
C
      CALL DDI_SMP_DESTROY(D_NT2ABUF)
      IF(SCFTYP .EQ. UHF) CALL DDI_SMP_DESTROY(D_NT2BBUF)
C
      CALL DDI_SYNC(5133)
      RETURN
C
 9010 FORMAT(/1X,'REPLICATED MEMORY REQUIRED FOR 1/3 TRANSFORMATION=',
     *           I12,' WORDS')
 9020 FORMAT( 1X,'SHARED MEMORY REQUIRED FOR ',I1,
     *           '/3 TRANSFORMATION    =',I12,' WORDS'/
     *       50X,'=',F12.2,' GBYTES/NODE')
 9030 FORMAT(/1X,'*** WARNING: THE MAXIMUM LCAO COEF=',F15.6,
     *           ', FOR AO',I6,' IN MO=',I6,','/
     *        1X,'EXCEEDS 100.  ADDITIONAL INPUTS MAY BE REQUIRED TO',
     *           ' OBTAIN GOOD MP2 ACCURACY:'/
     *        1X,' $CONTRL ICUT=10 OR 11'/
     *        1X,' $SCF    CONV=2.5D-7 FDIFF=.FALSE.'/)
      END
C*MODULE RIMP2   *DECK RIMP2INTTRT02
      SUBROUTINE RIMP2INTTRT02(VEC,T0,T1,T2,INFOCCBAT,NT2BUF,
     *     NBASIS,NOCC,NVIR,NINTMX,NOCCBAT,IFILT2,NRECT2,D_T,LAUX,
     *     USEDM,TIME1,TIME2,TIMEW)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL USEDM
      DOUBLE PRECISION VEC(NBASIS,*),T0(*),T1(*),T2(*)
      INTEGER INFOCCBAT(*),NT2BUF(*)
C
      INTEGER D_T
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
C     1/3 INTEGRAL TRANSFORMATION
C     T1=TO*CI
C
C     WRITE(IW,*) 'T0 MATRIX'
C     CALL RIMP2PRTT1A(T0(1,1,LL),NBASIS,LAUX)
C
      CALL TSECND(TIME10)
      CALL DGEMM('N','N',NBASIS,NOCC,NBASIS,ONE,T0,NBASIS,
     *           VEC,NBASIS,ZERO,T1,NBASIS)
      CALL TSECND(TIME11)
      TIME1 = TIME1+(TIME11-TIME10)
C
C     WRITE(IW,*) 'T1 MATRIX'
C     CALL RIMP2PRTT1B(T1,NBASIS,NOCC,LAUX)
C
C     2/3 INTEGRAL TRANSFORMATION
C     T2=CVT*T1
C
      CALL TSECND(TIME20)
      CALL DGEMM('T','N',NVIR,NOCC,NBASIS,ONE,VEC(1,NOCC+1),
     *     NBASIS,T1,NBASIS,ZERO,T2,NVIR)
      CALL TSECND(TIME21)
      TIME2 = TIME2+(TIME21-TIME20)
C
C      WRITE(IW,*) 'T2 MATRIX'
C      CALL RIMP2PRTT1C(T2,NOCC,NVIR,LAUX)
C
C     STORE 2/3 TRANSFORMED INTEGRAL MATRIX T2
C
      CALL TSECND(TIMEW0)
      CALL RIMP2T2ST(T1,T2,INFOCCBAT,NT2BUF,NOCC,NVIR,NINTMX,
     *     NOCCBAT,LAUX,IFILT2,NRECT2,D_T,USEDM)
      CALL TSECND(TIMEW1)
      TIMEW = TIMEW+(TIMEW1-TIMEW0)
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIMP2INTTRT02SMP
      SUBROUTINE RIMP2INTTRT02SMP(VEC,T0,T1,T2,T2BUFF,INFOCCBAT,NT2BUF,
     *     NBASIS,NOCC,NVIR,NINTMX,NOCCBAT,IFILT2,NRECT2,D_T,LAUX,
     *     USEDM,TIME1,TIME2,TIMEW,SMP_NP,SMP_ME)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL USEDM
C
C                ALLOCATED FROM SHARED MEMORY
      DOUBLE PRECISION T0(*),T1(*),T2(*)
      INTEGER NT2BUF(*)
C
C                ALLOCATED FROM REPLICATED MEMORY
      DOUBLE PRECISION VEC(NBASIS,*),T2BUFF(*)
      INTEGER INFOCCBAT(*)
C
      INTEGER SMP_NP,SMP_ME
      INTEGER NR,SR
      INTEGER D_T
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
C         EACH NODE WORKS ON ONE PARTICULAR AUXILIARY BASIS -LAUX-
C         ON ENTRY, -T0- IS INTEGRALS OVER THE AO BASIS SET, FOR ONE
C         VALUE OF -LAUX-, AND IS -NBASIS- BY -NBASIS-.
C         OTHER NODES ARE WORKING ON OTHER -LAUX- INDEPENDENTLY.
C         WORK DIVISION ACROSS CORES IN THIS NODE IS BY PATCHES OF
C         THE MATRIX MULTIPLY.
C         NOTE THAT -T0-, -T1-, AND -T2- ARE IN NODE-REPLICATED STORAGE.
C
      CALL DIV_EVEN(NOCC,SMP_NP,SMP_ME,NR,SR)
      IT1 = NBASIS*(SR-1)+1
      IT2 = NVIR*(SR-1)+1
C
C     1/3 INTEGRAL TRANSFORMATION
C     T1=TO*CI, THE RESULT -T1- IS A -NBASIS- BY -NOCC- MATRIX
C
      CALL TSECND(TIME10)
      CALL DGEMM('N','N',NBASIS,NR,NBASIS,ONE,T0,NBASIS,
     *           VEC(1,SR),NBASIS,ZERO,T1(IT1),NBASIS)
      CALL DDI_SMP_SYNC()
      CALL TSECND(TIME11)
      TIME1 = TIME1+(TIME11-TIME10)
C
C     2/3 INTEGRAL TRANSFORMATION
C     T2=CVT*T1, THE RESULT -T2- IS A -NVIR- BY -NOCC- MATRIX
C
      CALL TSECND(TIME20)
      CALL DGEMM('T','N',NVIR,NR,NBASIS,ONE,VEC(1,NOCC+1),
     *           NBASIS,T1(IT1),NBASIS,ZERO,T2(IT2),NVIR)
      CALL DDI_SMP_SYNC()
      CALL TSECND(TIME21)
      TIME2 = TIME2+(TIME21-TIME20)
C
C     STORE 2/3 TRANSFORMED INTEGRAL MATRIX T2
C
C     THE RESULT IS COPIED FROM SHARED MEMORY TO REPLICATED MEMORY,
C     BECAUSE OF AN APPARENT INABILITY OF DDI IF USING MPI (BUT NOT
C     IF USING TCP/IP) TO CORRECTLY STORE THE MATRIX -T2- STRAIGHT
C     FROM SHARED MEMORY TO DISTRIBUTED MEMORY.
C
      CALL TSECND(TIMEW0)
      IF(SMP_ME .EQ. 0) THEN
         CALL DCOPY(NVIR*NOCC,T2,1,T2BUFF,1)
         CALL RIMP2T2ST(T1,T2BUFF,INFOCCBAT,NT2BUF,NOCC,NVIR,NINTMX,
     *                  NOCCBAT,LAUX,IFILT2,NRECT2,D_T,USEDM)
      END IF
      CALL DDI_SMP_SYNC()
      CALL TSECND(TIMEW1)
      TIMEW = TIMEW+(TIMEW1-TIMEW0)
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIMP2OCCBATCHK
      SUBROUTINE RIMP2OCCBATCHK(
     *     SCFTYP,NSHELL,NBASIS,NAUXSH,NAUXBAS,NOCCA,NOCCB,
     *     NVIRA,NVIRB,NACORE,NBCORE,NGOTMX,
     *     GONODE,MASWRK,NPROC,IW,
     *     LINFOCCABAT,LINFOCCBBAT,NEED0,NN,NOCCBAT,
     *     LENOCCABAT,LENOCCBBAT,NINTMXA,NINTMXB)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GONODE,MASWRK
C
      COMMON /FMCOM / X(1)
C
      DATA RHF      /8HRHF     /
      DATA UHF      /8HUHF     /
C
C     DETERMINE OCCUPIED ORBITAL BATCH INFOMATION
C
      MEMAVIL = NGOTMX
C
      IF(MASWRK) WRITE (IW,9010)
      CALL VALFM(LOADFM)
      NN = 0
      IF(GONODE .AND. (MOD(NPROC,2) .EQ. 0)) NN = 1
C
C     DETERMINE NUMBER OF OCCPIED ORBITAL BATCH
C
 1000 CONTINUE
      NOCCBAT = 2**NN*NPROC
C
C     ALLOCATE REPLICATED MEMORY FOR OCCPIED ORBITAL BATCH
C
      LINFOCCABAT = LOADFM     + 1
      LAST0       = LINFOCCABAT + 2*NOCCBAT
      IF(SCFTYP .EQ. UHF) THEN
         LINFOCCBBAT = LINFOCCABAT + 2*NOCCBAT
         LAST0       = LINFOCCBBAT + 2*NOCCBAT
      END IF
      NEED0       = LAST0-LOADFM-1
      CALL GETFM(NEED0)
C
C     DETERMINE SIZE OF OCCUPIED ORBITAL BATCH
C
      LENOCCABAT = NOCCA/NOCCBAT
      CALL RIMP2OCCBAT(X(LINFOCCABAT),NOCCA,NOCCBAT,LENOCCABAT,NPROC)
      NINTMXA = LENOCCABAT*NVIRA
      LENOCCBBAT = LENOCCABAT
      NINTMXB = NINTMXA
      IF(SCFTYP .EQ. UHF) THEN
         LENOCCBBAT = NOCCB/NOCCBAT
         CALL RIMP2OCCBAT(X(LINFOCCBBAT),NOCCB,NOCCBAT,LENOCCBBAT,
     *        NPROC)
         NINTMXB = LENOCCBBAT*NVIRB
      END IF
C
C     CHECK REQUIRED MEMORY FOR RI-MP2 ENERGY CALCULATION
C
C     CHECK REQUIRED MEMORY SIZE FOR RIMP2INTTR2
C
      IF(SCFTYP .EQ. RHF) THEN
         L1 = NAUXBAS*NAUXBAS
         L2 = NAUXBAS*NVIRA
         L3 = NAUXBAS*NVIRA*LENOCCABAT
         L4 = NINTMXA
         L5 = NAUXBAS*NINTMXA
      ELSE IF(SCFTYP .EQ. UHF) THEN
         L1 = NAUXBAS*NAUXBAS
         L2 = NAUXBAS*MAX(NVIRA,NVIRB)
         L3 = NAUXBAS*MAX(NVIRA,NVIRB)*MAX(LENOCCABAT,LENOCCBBAT)
         L4 = MAX(NINTMXA,NINTMXB)
         L5 = NAUXBAS*MAX(NINTMXA,NINTMXB)
      END IF
      LV       = LOADFM   + 1
      LT2      = LV       + L1
      LT3      = LT2      + L3
      LAST3    = LT3      + MAX(L2,L4,L5)
      IF(GONODE) THEN
         LTA      = LAST3
         LITA     = LTA      + L5
         LITB     = LITA     + NAUXBAS
         LAST3    = LITB     + NAUXBAS
      END IF
      NEED3 = LAST3-LAST0-1
C
C     CHECK REQUIRED MEMORY SIZE FOR RIMP2ENG
C
      IF(SCFTYP .EQ. RHF) THEN
         L1 = NVIRA*NVIRA
         L2 = NAUXBAS*NVIRA*LENOCCABAT
         LEIGA    = LOADFM   + 1
         LBB      = LEIGA    + NBASIS
         LBK1     = LBB      + L2
         IF(GONODE) THEN
            LBK2     = LBK1     + L2
            LQ       = LBK2     + L2
         ELSE
            LQ       = LBK1     + L2
         END IF
         LAST4    = LQ       + L1
      ELSE IF(SCFTYP .EQ. UHF) THEN
         L1 = MAX(NVIRA,NVIRB)**2
         L2 = NAUXBAS*MAX(NVIRA,NVIRB)*MAX(LENOCCABAT,LENOCCBBAT)
         LEIGA    = LOADFM   + 1
         LEIGB    = LEIGA    + NBASIS
         LBB      = LEIGB    + NBASIS
         LBK1     = LBB      + L2
         IF(GONODE) THEN
            LBK2     = LBK1     + L2
            LQ       = LBK2     + L2
         ELSE
            LQ       = LBK1     + L2
         END IF
         LAST4    = LQ       + L1
      END IF
      NEED4   = LAST4-LAST0-1
      IF(MASWRK) WRITE(IW,9020) NN,LENOCCABAT,NEED3,NEED4
      IF(MAX(NEED3,NEED4) .GT. MEMAVIL) THEN
         CALL RETFM(NEED0)
         IF(LENOCCABAT .EQ. 1) THEN
            IF(MASWRK) THEN
               WRITE(IW,*)
     *    'MEMORY IS NOT ENOUGH TO PERFORM RI-MP2 ENERGY CALCULATIONS'
               IF(SCFTYP .EQ. RHF) THEN
                  WRITE(IW,9050) NOCCA+NACORE,NOCCA,NVIRA,NBASIS,NSHELL,
     *                 NAUXBAS,NAUXSH,NN,LENOCCABAT,NOCCBAT
               ELSE IF(SCFTYP .EQ. UHF) THEN
                  WRITE(IW,9051) NOCCA+NACORE,NOCCB+NBCORE,NOCCA,NOCCB,
     *                 NVIRA,NVIRB,NBASIS,NSHELL,NAUXBAS,NAUXSH,NN,
     *                 LENOCCABAT,NOCCBAT
               END IF
            END IF
            CALL ABRT
         END IF
         NN = NN+1
         GO TO 1000
      END IF
      IF(MASWRK  .AND.  NN.GT.1) WRITE(IW,9030)
      RETURN
C
 9010 FORMAT(/1X,'CHECKING SIZE OF OCCUPIED ORBITAL BATCH')
 9020 FORMAT(1X,'LV=',I3,1X,'LENBAT=',I4,1X,'INEED3=',I12,1X,
     *          'INEED4=',I12)
 9030 FORMAT(1X,'INCREASING -MWORDS- TO LOWER -LV- WOULD IMPROVE',
     *          ' PERFORMANCE.')
 9050 FORMAT(/1X,'NUMBER OF OCCUPIED ORBITALS            =',I6,/
     *        1X,'NUMBER OF CORRELATED OCCUPIED ORBITALS =',I6,/
     *        1X,'NUMBER OF VIRTUAL ORBITALS             =',I6,/
     *        1X,'NUMBER OF BASIS FUNCTIONS              =',I6,/
     *        1X,'NUMBER OF BASIS SHELLS                 =',I6,/
     *        1X,'NUMBER OF AUXILIARY BASIS FUNCTIONS    =',I6,/
     *        1X,'NUMBER OF AUXILIARY BASIS SHELLS       =',I6,/
     *        1X,'LEVEL OF OCCUPIED ORBITAL BATCH        =',I6,/
     *        1X,'LENGTH OF OCCUPIED ORBITAL BATCH       =',I6,/
     *        1X,'NUMBER OF OCCUPIED ORBITAL BATCH       =',I6)
 9051 FORMAT(/1X,'NUMBER OF OCCUPIED ORBITALS A            =',I6,/
     *        1X,'NUMBER OF OCCUPIED ORBITALS B            =',I6,/
     *        1X,'NUMBER OF CORRELATED OCCUPIED ORBITALS A =',I6,/
     *        1X,'NUMBER OF CORRELATED OCCUPIED ORBITALS B =',I6,/
     *        1X,'NUMBER OF VIRTUAL ORBITALS A             =',I6,/
     *        1X,'NUMBER OF VIRTUAL ORBITALS B             =',I6,/
     *        1X,'NUMBER OF BASIS FUNCTIONS                =',I6,/
     *        1X,'NUMBER OF BASIS SHELLS                   =',I6,/
     *        1X,'NUMBER OF AUXILIARY BASIS FUNCTIONS      =',I6,/
     *        1X,'NUMBER OF AUXILIARY BASIS SHELLS         =',I6,/
     *        1X,'LEVEL OF OCCUPIED ORBITAL BATCH          =',I6,/
     *        1X,'LENGTH OF OCCUPIED ORBITAL BATCH         =',I6,/
     *        1X,'NUMBER OF OCCUPIED ORBITAL BATCH         =',I6)
      END
C*MODULE RIMP2   *DECK RIMP2OCCBAT
      SUBROUTINE RIMP2OCCBAT(INFOCCBAT,NOCC,NOCCBAT,LENOCCBAT,NPROC)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      INTEGER INFOCCBAT(2,NOCCBAT)
C
C     DETRMINE LENGTH OF OCCPIED ORBITAL BATCH
C
      NOCCBATP1 = NOCCBAT/NPROC
      IOCCREST = NOCC-NOCCBAT*LENOCCBAT
      DO IBAT = 1, NOCCBAT
         INFOCCBAT(2,IBAT) = LENOCCBAT
      END DO
      IF(IOCCREST .EQ. 0) GO TO 1000
      DO IBATP1 = 1, NOCCBATP1
         DO IPROC = 1, NPROC
            IBAT = (IPROC-1)*NOCCBATP1+IBATP1
            INFOCCBAT(2,IBAT) = INFOCCBAT(2,IBAT)+1
            IOCCREST = IOCCREST-1
            IF(IOCCREST .EQ. 0) GO TO 1000
         END DO
      END DO
C
 1000 CONTINUE
      LENOCCBAT = 0
      DO IBAT = 1, NOCCBAT
         IF(LENOCCBAT .LT. INFOCCBAT(2,IBAT))
     *        LENOCCBAT = INFOCCBAT(2,IBAT)
      END DO
C
      IOCCBG = 0
      DO IBAT = 1, NOCCBAT
         INFOCCBAT(1,IBAT) = IOCCBG
         IOCCBG = IOCCBG+INFOCCBAT(2,IBAT)
      END DO
C
C      WRITE(6,*) 'INFOCCBAT'
C      DO IBAT = 1, NOCCBAT
C         WRITE(6,*) IBAT,(INFOCCBAT(I,IBAT),I=1,2)
C      END DO
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIMP2SGEN
      SUBROUTINE RIMP2SGEN(S,GHONDO,TI,TJ,W,CC,LOCSPH,NAUXSH,NAUXBAS,
     *     IW,SPHAUX)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL SPHAUX
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL IANDJ,NORM
C
      DOUBLE PRECISION S(NAUXBAS,NAUXBAS),GHONDO(*),TI(*),TJ(*),W(*)
      DOUBLE PRECISION CC(3,2)
      INTEGER LOCSPH(*)
C
      PARAMETER (MXATM=2000)
      PARAMETER (MXAUXSH=10000, MXAXGTOT=20000)
C
      COMMON /AUXBAS/ EXAUX(MXAXGTOT),CAUXS(MXAXGTOT),CAUXP(MXAXGTOT),
     *                CAUXD(MXAXGTOT),CAUXF(MXAXGTOT),CAUXG(MXAXGTOT),
     *                CAUXH(MXAXGTOT),CAUXI(MXAXGTOT),
     *                KAUXST(MXAUXSH),KAUXAT(MXAUXSH),KAUXTY(MXAUXSH),
     *                KAUXNG(MXAUXSH),KAUXLO(MXAUXSH),KAUXMI(MXAUXSH),
     *                KAUXMX(MXAUXSH),NAUXSHX
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
C     GANERATE 2C-1E OVERLAP MATRIX (LM)
C     L,M: AUXLIARY BASIS SETS
C
      NORM = NORMF .NE. 1 .OR. NORMP .NE. 1
C
      CALL TSECND(TIME00)
C      IPCOUNT = 0
C      IF (GOPARR) CALL VCLR(S,1,NAUXBAS2)
      DO II = 1, NAUXSH
         IAT = KAUXAT(II)
         CC(1,1) = C(1,IAT)
         CC(2,1) = C(2,IAT)
         CC(3,1) = C(3,IAT)
         LANGI = KAUXTY(II)-1
         NGI   = KAUXNG(II)
         MINI  = KAUXMI(II)
         MAXI  = KAUXMX(II)
         I1    = KAUXST(II)
         LOCI  = KAUXLO(II)-MINI
         NI    = MAXI-MINI+1
         IF(SPHAUX) THEN
            CALL RIMP2CSTRM(TI,LANGI,MINI,NI,MINIS,MAXIS)
            LOCIS = LOCSPH(II)-MINIS
            NIS   = MAXIS-MINIS+1
C            WRITE(6,*) 'II=',II,'LANGI=',LANGI
C            WRITE(6,*) 'MINIS=',MINIS,'MAXIS=',MAXIS
C            WRITE(6,*) 'LOCIS=',LOCIS
C            CALL PRSQ(TI,NI,NI,NI)
         END IF
C
         DO JJ = 1, II
C
C     ----- GO PARALLEL! -----
C
C            IF (GOPARR) THEN
C               IPCOUNT = IPCOUNT + 1
C               IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 1000
C            END IF
C
            JAT = KAUXAT(JJ)
            CC(1,2) = C(1,JAT)
            CC(2,2) = C(2,JAT)
            CC(3,2) = C(3,JAT)
            LANGJ = KAUXTY(JJ)-1
            NGJ   = KAUXNG(JJ)
            MINJ  = KAUXMI(JJ)
            MAXJ  = KAUXMX(JJ)
            J1    = KAUXST(JJ)
            LOCJ  = KAUXLO(JJ)-MINJ
            NJ = MAXJ-MINJ+1
            IANDJ = II .EQ. JJ
            IF(SPHAUX) THEN
               CALL RIMP2CSTRM(TJ,LANGJ,MINJ,NJ,MINJS,MAXJS)
               LOCJS = LOCSPH(JJ)-MINJS
               NJS   = MAXJS-MINJS+1
C               WRITE(6,*) 'JJ=',JJ,'LANGJ=',LANGJ
C               WRITE(6,*) 'MINJS=',MINJS,'MAXJS=',MAXJS
C               WRITE(6,*) 'LOCJS=',LOCJS
C               CALL PRSQ(TJ,NJ,NJ,NJ)
            END IF
C
C           EVALUATE 2C-OVERLAP INTEGRALS (IJ)
C
            CALL GEN2C1OV(CC,EXAUX(I1),CAUXS(I1),CAUXP(I1),CAUXD(I1),
     *           CAUXF(I1),CAUXG(I1),CAUXH(I1),CAUXI(I1),
     *           EXAUX(J1),CAUXS(J1),CAUXP(J1),CAUXD(J1),CAUXF(J1),
     *           CAUXG(J1),CAUXH(J1),CAUXI(J1),GHONDO,
     *           LANGI,LANGJ,NGI,NGJ,MINI,MAXI,MINJ,MAXJ,NORM,NORM)
C     *           LANGI,LANGJ,NGI,NGJ,MINI,MAXI,MINJ,MAXJ,
C     *           .FALSE.,.FALSE.)
C
C           COPY 2C-OVERLAP INTEGRALS FROM BUFFER TO MATRIX
C
            CALL CP2CAUXINT(GHONDO,S,TI,TJ,W,NAUXBAS,
     *           LOCI,LOCJ,MINI,MAXI,MINJ,MAXJ,NI,NJ,
     *           LOCIS,LOCJS,MINIS,MAXIS,MINJS,MAXJS,NIS,NJS,
     *           SPHAUX,IANDJ)
C
C 1000       CONTINUE
         END DO
      END DO
      CALL TSECND(TIME01)
      TIME0 = TIME01-TIME00
C
C     ----- SUM UP PARTIAL CONTRIBUTIONS IF PARALLEL -----
C
C      IF (GOPARR) CALL DDI_GSUMF(3000,S,NAUXBAS2)
C
C      IF(MASWRK) THEN
C         WRITE(IW,*) 'S MATRIX'
C         CALL PRSQ(S,NAUXBAS,NAUXBAS,NAUXBAS)
C      END IF
      IF(MASWRK) WRITE(IW,9999) TIME0
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 2C-1E OVERLAP MATRIX GENERATION =',F9.1)
      END
C*MODULE RIMP2   *DECK RIMP2SGENSMP
      SUBROUTINE RIMP2SGENSMP(S,GHONDO,TI,TJ,W,CC,LOCSPH,NAUXSH,NAUXBAS,
     *     IW,SPHAUX,SMP_NP,SMP_ME)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL SPHAUX
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL IANDJ,NORM
C
      DOUBLE PRECISION S(NAUXBAS,NAUXBAS),GHONDO(*),TI(*),TJ(*),W(*)
      DOUBLE PRECISION CC(3,2)
      INTEGER LOCSPH(*)
C
      INTEGER SMP_NP,SMP_ME
C
      PARAMETER (MXATM=2000)
      PARAMETER (MXAUXSH=10000, MXAXGTOT=20000)
C
      COMMON /AUXBAS/ EXAUX(MXAXGTOT),CAUXS(MXAXGTOT),CAUXP(MXAXGTOT),
     *                CAUXD(MXAXGTOT),CAUXF(MXAXGTOT),CAUXG(MXAXGTOT),
     *                CAUXH(MXAXGTOT),CAUXI(MXAXGTOT),
     *                KAUXST(MXAUXSH),KAUXAT(MXAUXSH),KAUXTY(MXAUXSH),
     *                KAUXNG(MXAUXSH),KAUXLO(MXAUXSH),KAUXMI(MXAUXSH),
     *                KAUXMX(MXAUXSH),NAUXSHX
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
C     GANERATE 2C-1E OVERLAP MATRIX (LM)
C     L,M: AUXLIARY BASIS SETS
C
      NORM = NORMF .NE. 1 .OR. NORMP .NE. 1
C
      CALL TSECND(TIME00)
      IPCOUNT = 0
C      IF (GOPARR) CALL VCLR(S,1,NAUXBAS2)
      DO II = 1, NAUXSH
         IAT = KAUXAT(II)
         CC(1,1) = C(1,IAT)
         CC(2,1) = C(2,IAT)
         CC(3,1) = C(3,IAT)
         LANGI = KAUXTY(II)-1
         NGI   = KAUXNG(II)
         MINI  = KAUXMI(II)
         MAXI  = KAUXMX(II)
         I1    = KAUXST(II)
         LOCI  = KAUXLO(II)-MINI
         NI    = MAXI-MINI+1
         IF(SPHAUX) THEN
            CALL RIMP2CSTRM(TI,LANGI,MINI,NI,MINIS,MAXIS)
            LOCIS = LOCSPH(II)-MINIS
            NIS   = MAXIS-MINIS+1
C            WRITE(6,*) 'II=',II,'LANGI=',LANGI
C            WRITE(6,*) 'MINIS=',MINIS,'MAXIS=',MAXIS
C            WRITE(6,*) 'LOCIS=',LOCIS
C            CALL PRSQ(TI,NI,NI,NI)
         END IF
C
         DO JJ = 1, II
C
C     ----- GO PARALLEL! -----
C
C            IF (GOPARR) THEN
C               IPCOUNT = IPCOUNT + 1
C               IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 1000
C            END IF
            IPCOUNT = IPCOUNT+1
            IF(MOD(IPCOUNT,SMP_NP) .NE. SMP_ME) GO TO 1000
C
            JAT = KAUXAT(JJ)
            CC(1,2) = C(1,JAT)
            CC(2,2) = C(2,JAT)
            CC(3,2) = C(3,JAT)
            LANGJ = KAUXTY(JJ)-1
            NGJ   = KAUXNG(JJ)
            MINJ  = KAUXMI(JJ)
            MAXJ  = KAUXMX(JJ)
            J1    = KAUXST(JJ)
            LOCJ  = KAUXLO(JJ)-MINJ
            NJ = MAXJ-MINJ+1
            IANDJ = II .EQ. JJ
            IF(SPHAUX) THEN
               CALL RIMP2CSTRM(TJ,LANGJ,MINJ,NJ,MINJS,MAXJS)
               LOCJS = LOCSPH(JJ)-MINJS
               NJS   = MAXJS-MINJS+1
C               WRITE(6,*) 'JJ=',JJ,'LANGJ=',LANGJ
C               WRITE(6,*) 'MINJS=',MINJS,'MAXJS=',MAXJS
C               WRITE(6,*) 'LOCJS=',LOCJS
C               CALL PRSQ(TJ,NJ,NJ,NJ)
            END IF
C
C           EVALUATE 2C-OVERLAP INTEGRALS (IJ)
C
            CALL GEN2C1OV(CC,EXAUX(I1),CAUXS(I1),CAUXP(I1),CAUXD(I1),
     *           CAUXF(I1),CAUXG(I1),CAUXH(I1),CAUXI(I1),
     *           EXAUX(J1),CAUXS(J1),CAUXP(J1),CAUXD(J1),CAUXF(J1),
     *           CAUXG(J1),CAUXH(J1),CAUXI(J1),GHONDO,
     *           LANGI,LANGJ,NGI,NGJ,MINI,MAXI,MINJ,MAXJ,NORM,NORM)
C
C           COPY 2C-OVERLAP INTEGRALS FROM BUFFER TO MATRIX
C
            CALL CP2CAUXINT(GHONDO,S,TI,TJ,W,NAUXBAS,
     *           LOCI,LOCJ,MINI,MAXI,MINJ,MAXJ,NI,NJ,
     *           LOCIS,LOCJS,MINIS,MAXIS,MINJS,MAXJS,NIS,NJS,
     *           SPHAUX,IANDJ)
C
 1000       CONTINUE
         END DO
      END DO
      CALL DDI_SMP_SYNC()
      CALL TSECND(TIME01)
      TIME0 = TIME01-TIME00
C
C     ----- SUM UP PARTIAL CONTRIBUTIONS IF PARALLEL -----
C
C      IF (GOPARR) CALL DDI_GSUMF(3000,S,NAUXBAS2)
C
C      IF(MASWRK) THEN
C         WRITE(IW,*) 'S MATRIX'
C         CALL PRSQ(S,NAUXBAS,NAUXBAS,NAUXBAS)
C      END IF
      IF(MASWRK) WRITE(IW,9999) TIME0
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 2C-1E OVERLAP MATRIX GENERATION =',F9.1)
      END
      SUBROUTINE RIMP2SHIFTORB(VEC,NBASIS,NORB,NCORE)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION VEC(NBASIS,NBASIS)
C
C     REMOVE FLOZEN CORE OCCUPIED MOLECULAR ORBITALS.
C
C      WRITE(6,*) 'NBASIS=',NBASIS,'NORB=',NORB,'NCORE=',NCORE
C      WRITE(6,*) 'ORBITAL COEFFICIENTS'
      DO J = 1, NORB
         DO I = 1, NBASIS
            VEC(I,J) = VEC(I,J+NCORE)
C            WRITE(6,'(2I5,E20.10)') I,J,VEC(I,J)
         END DO
      END DO
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIMP2SINV
      SUBROUTINE RIMP2SINV(S,WRK1,WRK2,TRI,IWRK,SCR,STOL,
     *                     NAUXBAS,NAUXBAS1,IW,MASWRK)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL MASWRK
C
      DOUBLE PRECISION S(NAUXBAS,NAUXBAS),WRK1(NAUXBAS*NAUXBAS),
     *                 WRK2(NAUXBAS),TRI(*),IWRK(NAUXBAS),SCR(NAUXBAS,8)
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
C      IF(MASWRK) THEN
C         WRITE(IW,*) 'S MATRIX'
C         CALL PRSQ(S,NAUXBAS,NAUXBAS,NAUXBAS)
C      END IF
C
C     DIAGONALIZE S MATRIX: EIGENVALUES TO -WRK2- AND VECTORS TO -S-
C
C---  NAUXBAS2 = NAUXBAS*NAUXBAS
C---  CALL DSYEV('V','U',NAUXBAS,S,NAUXBAS,WRK2,WRK1,NAUXBAS2,INFO)
C
      CALL CPYSQT(S,TRI,NAUXBAS,1)
      CALL GLDIAG(NAUXBAS,NAUXBAS,NAUXBAS,TRI,SCR,WRK2,S,IERR,IWRK)
C
C      IF(MASWRK) THEN
C         WRITE(IW,*) 'EIGENVECTORS OF 2C-1E S MATRIX'
C         CALL PREV(S,WRK2,NAUXBAS,NAUXBAS,NAUXBAS)
C      END IF
C
C     MAKE S^(-1/2) MATRIX
C
      NAUXBAS1 = 0
      DO IAUX = NAUXBAS, 1, -1
         IF(WRK2(IAUX) .LT. STOL) GO TO 100
         NAUXBAS1 = NAUXBAS1+1
         WRK1(NAUXBAS1) = WRK2(IAUX)
      END DO
 100  CONTINUE
      IVAL = NAUXBAS-NAUXBAS1
      IF(MASWRK .AND. IVAL .GT. 0) THEN
         WRITE(IW,9010) STOL,IVAL
         WRITE(IW,*) (WRK2(I),I=1,IVAL)
         ICNT = 0
         DO I = 1, IVAL
            IF(WRK2(I) .LT. ZERO) ICNT = ICNT+1
         END DO
         IF(ICNT .GT. 0) WRITE(IW,9020) ICNT
      END IF
      DO IAUX = 1, NAUXBAS1
         WRK2(IAUX) = ONE/SQRT(WRK1(IAUX))
      END DO
      IJ = 0
      JAUX2 = NAUXBAS
      DO JAUX = 1, NAUXBAS1
         DO IAUX = 1, NAUXBAS
            IJ = IJ+1
            WRK1(IJ) = S(IAUX,JAUX2)*WRK2(JAUX)
         END DO
         JAUX2 = JAUX2-1
      END DO
      CALL DCOPY(NAUXBAS*NAUXBAS1,WRK1,1,S,1)
C
C      IF(MASWRK) THEN
C         WRITE(IW,*) 'S^(-1/2) MATRIX'
C         CALL PRSQ(S,NAUXBAS1,NAUXBAS,NAUXBAS)
C      END IF
C
      RETURN
 9010 FORMAT(/1X,'NUMBER OF AUX. BASIS FUNCTIONS'/,
     *        1X,'LESS THAN ',E10.4,' =',I5)
 9020 FORMAT(1X,'WARNING!! ',I5,' EIGENVALUES ARE NEGATIVE VALUES!')
      END
C*MODULE RIMP2   *DECK RIMP2T0GEN
      SUBROUTINE RIMP2T0GEN(CC,T0,GHONDO,TL,W,NSHELL,NBASIS,
     *     LANGL,MINL,MAXL,NL,NGL,L1,MINLS,MAXLS,NLS,SPHAUX,NORM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL SPHAUX
      LOGICAL IANDJ
      LOGICAL NORM
C
      DOUBLE PRECISION CC(3,3),T0(*),GHONDO(*),TL(*),W(*)
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000)
      PARAMETER (MXAUXSH=10000, MXAXGTOT=20000)
C
      COMMON /AUXBAS/ EXAUX(MXAXGTOT),CAUXS(MXAXGTOT),CAUXP(MXAXGTOT),
     *                CAUXD(MXAXGTOT),CAUXF(MXAXGTOT),CAUXG(MXAXGTOT),
     *                CAUXH(MXAXGTOT),CAUXI(MXAXGTOT),
     *                KAUXST(MXAUXSH),KAUXAT(MXAUXSH),KAUXTY(MXAUXSH),
     *                KAUXNG(MXAUXSH),KAUXLO(MXAUXSH),KAUXMI(MXAUXSH),
     *                KAUXMX(MXAUXSH),NAUXSHX
      COMMON /FMCOM / XX(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELLX
C
      DO II = 1, NSHELL
         IAT = KATOM(II)
         CC(1,1) = C(1,IAT)
         CC(2,1) = C(2,IAT)
         CC(3,1) = C(3,IAT)
         LANGI = KTYPE(II)-1
         MINI  = KMIN(II)
         MAXI  = KMAX(II)
         NI    = KMAX(II)-KMIN(II)+1
         NGI   = KNG(II)
         I1    = KSTART(II)
         LOCI  = KLOC(II)-MINI
C
         DO JJ = 1, II
            JAT = KATOM(JJ)
            CC(1,2) = C(1,JAT)
            CC(2,2) = C(2,JAT)
            CC(3,2) = C(3,JAT)
            LANGJ = KTYPE(JJ)-1
            MINJ  = KMIN(JJ)
            MAXJ  = KMAX(JJ)
            NJ    = KMAX(JJ)-KMIN(JJ)+1
            NGJ   = KNG(JJ)
            J1    = KSTART(JJ)
            LOCJ  = KLOC(JJ)-MINJ
            IANDJ = II .EQ. JJ
            CALL VALFM(LOADFM)
            LAKINVV = LOADFM  + 1
            LDK     = LAKINVV + NGL
            LAST    = LDK     + NGL*28
            NEED = LAST - LOADFM - 1
            CALL GETFM(NEED)
C
C           3C-2E ERI EVALUATION
C
            CALL GEN3C2ERI(CC,EX(I1),CS(I1),CP(I1),CD(I1),CF(I1),
     *           CG(I1),CH(I1),CI(I1),EX(J1),CS(J1),CP(J1),CD(J1),
     *           CF(J1),CG(J1),CH(J1),CI(J1),
     *           EXAUX(L1),CAUXS(L1),CAUXP(L1),CAUXD(L1),CAUXF(L1),
     *           CAUXG(L1),CAUXH(L1),CAUXI(L1),GHONDO,
     *           LANGI,LANGJ,LANGL,NGI,NGJ,NGL,MINI,MAXI,MINJ,MAXJ,
     *           MINL,MAXL,NORM,NORM,NORM,XX(LAKINVV),XX(LDK))
            CALL RETFM(NEED)
C
C           CORRECT 3C-2E ERI VALUES IN T0 ARRAY
C
            CALL CP3CAUXINT(GHONDO,T0,TL,W,NBASIS,LOCI,LOCJ,
     *           MINI,MAXI,MINJ,MAXJ,MINL,MAXL,NI,NJ,NL,MINLS,MAXLS,
     *           NLS,SPHAUX,IANDJ)
C
         END DO                 !JJ
      END DO                    !II
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIMP2T0GENSMP
      SUBROUTINE RIMP2T0GENSMP(CC,T0,GHONDO,TL,W,NSHELL,NBASIS,
     *     LANGL,MINL,MAXL,NL,NGL,L1,MINLS,MAXLS,NLS,SPHAUX,NORM,
     *     SMP_NP,SMP_ME)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL SPHAUX
      LOGICAL IANDJ
      LOGICAL NORM
C
      DOUBLE PRECISION CC(3,3),T0(*),GHONDO(*),TL(*),W(*)
C
      INTEGER SMP_NP,SMP_ME
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000)
      PARAMETER (MXAUXSH=10000, MXAXGTOT=20000)
C
      COMMON /AUXBAS/ EXAUX(MXAXGTOT),CAUXS(MXAXGTOT),CAUXP(MXAXGTOT),
     *                CAUXD(MXAXGTOT),CAUXF(MXAXGTOT),CAUXG(MXAXGTOT),
     *                CAUXH(MXAXGTOT),CAUXI(MXAXGTOT),
     *                KAUXST(MXAUXSH),KAUXAT(MXAUXSH),KAUXTY(MXAUXSH),
     *                KAUXNG(MXAUXSH),KAUXLO(MXAUXSH),KAUXMI(MXAUXSH),
     *                KAUXMX(MXAUXSH),NAUXSHX
      COMMON /FMCOM / XX(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELLX
C
      IJCNT = 0
      DO II = 1, NSHELL
         IAT = KATOM(II)
         CC(1,1) = C(1,IAT)
         CC(2,1) = C(2,IAT)
         CC(3,1) = C(3,IAT)
         LANGI = KTYPE(II)-1
         MINI  = KMIN(II)
         MAXI  = KMAX(II)
         NI    = KMAX(II)-KMIN(II)+1
         NGI   = KNG(II)
         I1    = KSTART(II)
         LOCI  = KLOC(II)-MINI
C
         DO JJ = 1, II
            JAT = KATOM(JJ)
            CC(1,2) = C(1,JAT)
            CC(2,2) = C(2,JAT)
            CC(3,2) = C(3,JAT)
            LANGJ = KTYPE(JJ)-1
            MINJ  = KMIN(JJ)
            MAXJ  = KMAX(JJ)
            NJ    = KMAX(JJ)-KMIN(JJ)+1
            NGJ   = KNG(JJ)
            J1    = KSTART(JJ)
            LOCJ  = KLOC(JJ)-MINJ
            IJCNT = IJCNT+1
            IF(MOD(IJCNT,SMP_NP) .NE. SMP_ME) GO TO 500
            IANDJ = II .EQ. JJ
            CALL VALFM(LOADFM)
            LAKINVV = LOADFM  + 1
            LDK     = LAKINVV + NGL
            LAST    = LDK     + NGL*28
            NEED = LAST - LOADFM - 1
            CALL GETFM(NEED)
C
C           3C-2E ERI EVALUATION
C
            CALL GEN3C2ERI(CC,EX(I1),CS(I1),CP(I1),CD(I1),CF(I1),
     *           CG(I1),CH(I1),CI(I1),EX(J1),CS(J1),CP(J1),CD(J1),
     *           CF(J1),CG(J1),CH(J1),CI(J1),
     *           EXAUX(L1),CAUXS(L1),CAUXP(L1),CAUXD(L1),CAUXF(L1),
     *           CAUXG(L1),CAUXH(L1),CAUXI(L1),GHONDO,
     *           LANGI,LANGJ,LANGL,NGI,NGJ,NGL,MINI,MAXI,MINJ,MAXJ,
     *           MINL,MAXL,NORM,NORM,NORM,XX(LAKINVV),XX(LDK))
            CALL RETFM(NEED)
C
C           CORRECT 3C-2E ERI VALUES IN T0 ARRAY
C
            CALL CP3CAUXINT(GHONDO,T0,TL,W,NBASIS,LOCI,LOCJ,
     *           MINI,MAXI,MINJ,MAXJ,MINL,MAXL,NI,NJ,NL,MINLS,MAXLS,
     *           NLS,SPHAUX,IANDJ)
C
 500        CONTINUE
         END DO                 !JJ
      END DO                    !II
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIMP2T2RD
      SUBROUTINE RIMP2T2RD(T2,LENT2,IFILT2,IREC,IRECNEW,LAUX)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION T2(LENT2)
C
      READ(IFILT2,REC=IREC) IRECNEW,LAUX,T2
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIMP2T2ST
      SUBROUTINE RIMP2T2ST(T1,T2,INFOCCBAT,NT2BUF,NOCC,NVIR,NINTMX,
     *                     NOCCBAT,LAUX,IFILT2,NRECT2,D_T,USEDM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL USEDM
      INTEGER D_T
C
      DOUBLE PRECISION T1(*),T2(*)
      INTEGER INFOCCBAT(2,*),NT2BUF(2,*)
C
      IF(.NOT. USEDM) THEN
         DO IBAT = 1, NOCCBAT
            ICNT = 0
            IOCCBG = INFOCCBAT(1,IBAT)
            DO I = 1 ,INFOCCBAT(2,IBAT)
               IOCC = IOCCBG+I
               DO IVIR = 1, NVIR
                  IVO = IVIR+(IOCC-1)*NVIR
                  ICNT = ICNT+1
                  T1(ICNT) = T2(IVO)
               END DO
            END DO
            NRECT2 = NRECT2+1
            NT2BUF(1,IBAT) = NT2BUF(1,IBAT)+1
            CALL RIMP2T2WT(T1,NINTMX,IFILT2,NRECT2,NT2BUF(2,IBAT),LAUX)
            NT2BUF(2,IBAT) = NRECT2
         END DO
      ELSE
         IBG=NVIR*(LAUX-1)+1
         IED=NVIR*LAUX
         CALL DDI_PUT(D_T,IBG,IED,1,NOCC,T2)
      END IF
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIMP2T2WT
      SUBROUTINE RIMP2T2WT(T2,LENT2,IFILT2,IREC,IRECOLD,LAUX)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION T2(LENT2)
C
      WRITE(IFILT2,REC=IREC) IRECOLD,LAUX,T2
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIMP2T3RD
      SUBROUTINE RIMP2T3RD(T3,LENT3,IFILT3,IOCC)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION T3(LENT3)
C
      READ(IFILT3,REC=IOCC) T3
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIMP2T3WT
      SUBROUTINE RIMP2T3WT(T3,LENT3,IFILT3,IOCC)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION T3(LENT3)
C
      WRITE(IFILT3,REC=IOCC) T3
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIMP2TEIE2
      SUBROUTINE RIMP2TEIE2(EIG,BB,BK,Q,E2T,E2S,NAUXBAS,NORB,NOCC,NVIR,
     *     IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,JBAT,TIME4,TIME5)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION EIG(*),BB(NAUXBAS,NVIR,*),BK(NAUXBAS,NVIR,*),Q(*)
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00, TWO=2.0D+00)
C
      DO JOCC = JOCCBG, JOCCED
         J = JOCC-JOCCBG+1
         IF(JBAT .EQ. IBAT) IOCCED = JOCC
         DO IOCC = IOCCBG, IOCCED
            I = IOCC-IOCCBG+1
C
C           4C-2E ERI (IA|JB) GENERATION FROM 3C-2E ERIS
C           (IA|L) AND (IJ|L)
C
            CALL TSECND(TIME40)
            CALL RIMP2TEI(BB(1,1,I),BK(1,1,J),Q,NAUXBAS,NVIR,NVIR)
            CALL TSECND(TIME41)
            TIME4 = TIME4+(TIME41-TIME40)
C
C           MP2 CORRELATION ENERGY EVALUATION
C
            CALL TSECND(TIME50)
            E2TP = ZERO
            E2SP = ZERO
            CALL RIMP2E2(EIG,Q,E2TP,E2SP,NORB,NOCC,NVIR,
     *           IOCC,JOCC)
            IF(IOCC .NE. JOCC) THEN
               FAC = TWO
            ELSE
               FAC = ONE
            END IF
C            WRITE(6,*) 'IOCC=',IOCC,'JOCC=',JOCC,'E2TP=',E2TP,
C     *                 'E2SP=',E2SP,'E2P=',E2TP+E2SP
            E2T = E2T+FAC*E2TP
            E2S = E2S+FAC*E2SP
            CALL TSECND(TIME51)
            TIME5 = TIME5+(TIME51-TIME50)
C
         END DO                 !IOCC
      END DO                    !JOCC
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIMP2TEIE2SMP
      SUBROUTINE RIMP2TEIE2SMP(EIG,BB,BK,Q,E2T,E2S,NAUXBAS,NORB,NOCC,
     *     NVIR,IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,JBAT,TIME4,TIME5,
     *     SMP_NP,SMP_ME)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION EIG(*),BB(NAUXBAS,NVIR,*),BK(NAUXBAS,NVIR,*),Q(*)
C
      INTEGER SMP_NP,SMP_ME
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00, TWO=2.0D+00)
C
      DO JOCC = JOCCBG, JOCCED
         J = JOCC-JOCCBG+1
         IF(JBAT .EQ. IBAT) IOCCED = JOCC
         DO IOCC = IOCCBG, IOCCED
            I = IOCC-IOCCBG+1
C
C           4C-2E ERI (IA|JB) GENERATION FROM 3C-2E ERIS
C           (IA|L) AND (IJ|L)
C
            CALL TSECND(TIME40)
            CALL RIMP2TEISMP(BB(1,1,I),BK(1,1,J),Q,NAUXBAS,NVIR,NVIR,
     *           SMP_NP,SMP_ME)
            CALL TSECND(TIME41)
            TIME4 = TIME4+(TIME41-TIME40)
C
C           MP2 CORRELATION ENERGY EVALUATION
C
            CALL TSECND(TIME50)
            E2TP = ZERO
            E2SP = ZERO
            CALL RIMP2E2SMP(EIG,Q,E2TP,E2SP,NORB,NOCC,NVIR,
     *           IOCC,JOCC,SMP_NP,SMP_ME)
            IF(IOCC .NE. JOCC) THEN
               FAC = TWO
            ELSE
               FAC = ONE
            END IF
            E2T = E2T+FAC*E2TP
            E2S = E2S+FAC*E2SP
            CALL TSECND(TIME51)
            TIME5 = TIME5+(TIME51-TIME50)
C
         END DO                 !IOCC
      END DO                    !JOCC
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIMP2TEI
      SUBROUTINE RIMP2TEI(BB,BK,Q,NAUXBAS,NVIRA,NVIRB)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION BB(*),BK(*),Q(*)
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
C     GEMERATE TWO ELECTRON INTEGRALS FROM INTERMADIATE MATRICES
C
      CALL DGEMM('T','N',NVIRA,NVIRB,NAUXBAS,ONE,BB,NAUXBAS,BK,NAUXBAS,
     *     ZERO,Q,NVIRA)
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIMP2TEISMP
      SUBROUTINE RIMP2TEISMP(BB,BK,Q,NAUXBAS,NVIRA,NVIRB,SMP_NP,SMP_ME)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION BB(*),BK(*),Q(*)
C
      INTEGER SMP_NP,SMP_ME
      INTEGER NR,SR
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
C     GEMERATE TWO ELECTRON INTEGRALS FROM INTERMADIATE MATRICES
C
      CALL DIV_EVEN(NVIRB,SMP_NP,SMP_ME,NR,SR)
      IBK = NAUXBAS*(SR-1)+1
      IQ  = NVIRA*(SR-1)+1
      CALL DGEMM('T','N',NVIRA,NR,NAUXBAS,ONE,BB,NAUXBAS,
     *     BK(IBK),NAUXBAS,ZERO,Q(IQ),NVIRA)
      CALL DDI_SMP_SYNC()
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIMP2VGEN
      SUBROUTINE RIMP2VGEN(V,GHONDO,TI,TJ,W,CC,LOCSPH,NAUXSH,NAUXBAS,
     *     IW,SPHAUX)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL SPHAUX
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL IANDJ,NORM
C
      DOUBLE PRECISION V(NAUXBAS,NAUXBAS),GHONDO(*),TI(*),TJ(*),W(*)
      DOUBLE PRECISION CC(3,2)
      INTEGER LOCSPH(*)
C
      PARAMETER (MXATM=2000)
      PARAMETER (MXAUXSH=10000, MXAXGTOT=20000)
C
      COMMON /AUXBAS/ EXAUX(MXAXGTOT),CAUXS(MXAXGTOT),CAUXP(MXAXGTOT),
     *                CAUXD(MXAXGTOT),CAUXF(MXAXGTOT),CAUXG(MXAXGTOT),
     *                CAUXH(MXAXGTOT),CAUXI(MXAXGTOT),
     *                KAUXST(MXAUXSH),KAUXAT(MXAUXSH),KAUXTY(MXAUXSH),
     *                KAUXNG(MXAUXSH),KAUXLO(MXAUXSH),KAUXMI(MXAUXSH),
     *                KAUXMX(MXAUXSH),NAUXSHX
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
C     GANERATE 2C-2E ERI MATRIX (L|M)
C     L,M: AUXLIARY BASIS SETS
C
      NORM = NORMF .NE. 1 .OR. NORMP .NE. 1
C
      CALL TSECND(TIME00)
C      IPCOUNT = 0
C      IF (GOPARR) CALL VCLR(V,1,NAUXBAS2)
      DO II = 1, NAUXSH
         IAT = KAUXAT(II)
         CC(1,1) = C(1,IAT)
         CC(2,1) = C(2,IAT)
         CC(3,1) = C(3,IAT)
         LANGI = KAUXTY(II)-1
         NGI   = KAUXNG(II)
         MINI  = KAUXMI(II)
         MAXI  = KAUXMX(II)
         I1    = KAUXST(II)
         LOCI  = KAUXLO(II)-MINI
         NI    = MAXI-MINI+1
         IF(SPHAUX) THEN
            CALL RIMP2CSTRM(TI,LANGI,MINI,NI,MINIS,MAXIS)
            LOCIS = LOCSPH(II)-MINIS
            NIS   = MAXIS-MINIS+1
C            WRITE(6,*) 'II=',II,'LANGI=',LANGI
C            WRITE(6,*) 'MINIS=',MINIS,'MAXIS=',MAXIS
C            WRITE(6,*) 'LOCIS=',LOCIS
C            CALL PRSQ(TI,NI,NI,NI)
         END IF
C
         DO JJ = 1, II
C
C     ----- GO PARALLEL! -----
C
C            IF (GOPARR) THEN
C               IPCOUNT = IPCOUNT + 1
C               IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 1000
C            END IF
C
            JAT = KAUXAT(JJ)
            CC(1,2) = C(1,JAT)
            CC(2,2) = C(2,JAT)
            CC(3,2) = C(3,JAT)
            LANGJ = KAUXTY(JJ)-1
            NGJ   = KAUXNG(JJ)
            MINJ  = KAUXMI(JJ)
            MAXJ  = KAUXMX(JJ)
            J1    = KAUXST(JJ)
            LOCJ  = KAUXLO(JJ)-MINJ
            NJ = MAXJ-MINJ+1
            IANDJ = II .EQ. JJ
            IF(SPHAUX) THEN
               CALL RIMP2CSTRM(TJ,LANGJ,MINJ,NJ,MINJS,MAXJS)
               LOCJS = LOCSPH(JJ)-MINJS
               NJS   = MAXJS-MINJS+1
C               WRITE(6,*) 'JJ=',JJ,'LANGJ=',LANGJ
C               WRITE(6,*) 'MINJS=',MINJS,'MAXJS=',MAXJS
C               WRITE(6,*) 'LOCJS=',LOCJS
C               CALL PRSQ(TJ,NJ,NJ,NJ)
            END IF
C
C           EVALUATE 2C-ERIS (I|J)
C
            CALL GEN2C2ERI(CC,EXAUX(I1),CAUXS(I1),CAUXP(I1),CAUXD(I1),
     *           CAUXF(I1),CAUXG(I1),CAUXH(I1),CAUXI(I1),
     *           EXAUX(J1),CAUXS(J1),CAUXP(J1),CAUXD(J1),CAUXF(J1),
     *           CAUXG(J1),CAUXH(J1),CAUXI(J1),GHONDO,
     *           LANGI,LANGJ,NGI,NGJ,MINI,MAXI,MINJ,MAXJ,NORM,NORM)
C     *           LANGI,LANGJ,NGI,NGJ,MINI,MAXI,MINJ,MAXJ,
C     *           .FALSE.,.FALSE.)
C
C           COPY 2C-ERIS FROM BUFFER TO MATRIX
C
            CALL CP2CAUXINT(GHONDO,V,TI,TJ,W,NAUXBAS,
     *           LOCI,LOCJ,MINI,MAXI,MINJ,MAXJ,NI,NJ,
     *           LOCIS,LOCJS,MINIS,MAXIS,MINJS,MAXJS,NIS,NJS,
     *           SPHAUX,IANDJ)
C
C 1000       CONTINUE
         END DO
      END DO
      CALL TSECND(TIME01)
      TIME0 = TIME01-TIME00
C
C     ----- SUM UP PARTIAL CONTRIBUTIONS IF PARALLEL -----
C
C      IF (GOPARR) CALL DDI_GSUMF(3000,V,NAUXBAS2)
C
C      IF(MASWRK) THEN
C         WRITE(IW,*) 'V MATRIX'
C         CALL PRSQ(V,NAUXBAS,NAUXBAS,NAUXBAS)
C      END IF
      IF(MASWRK) WRITE(IW,9999) TIME0
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 2C-2E ERI MATRIX GENERATION =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIMP2VGENSMP
      SUBROUTINE RIMP2VGENSMP(V,GHONDO,TI,TJ,W,CC,LOCSPH,NAUXSH,NAUXBAS,
     *     IW,SPHAUX,SMP_NP,SMP_ME)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL SPHAUX
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL IANDJ,NORM
C
      DOUBLE PRECISION V(NAUXBAS,NAUXBAS),GHONDO(*),TI(*),TJ(*),W(*)
      DOUBLE PRECISION CC(3,2)
      INTEGER LOCSPH(*)
C
      INTEGER SMP_NP,SMP_ME
C
      PARAMETER (MXATM=2000)
      PARAMETER (MXAUXSH=10000, MXAXGTOT=20000)
C
      COMMON /AUXBAS/ EXAUX(MXAXGTOT),CAUXS(MXAXGTOT),CAUXP(MXAXGTOT),
     *                CAUXD(MXAXGTOT),CAUXF(MXAXGTOT),CAUXG(MXAXGTOT),
     *                CAUXH(MXAXGTOT),CAUXI(MXAXGTOT),
     *                KAUXST(MXAUXSH),KAUXAT(MXAUXSH),KAUXTY(MXAUXSH),
     *                KAUXNG(MXAUXSH),KAUXLO(MXAUXSH),KAUXMI(MXAUXSH),
     *                KAUXMX(MXAUXSH),NAUXSHX
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
C     GANERATE 2C-2E ERI MATRIX (L|M)
C     L,M: AUXLIARY BASIS SETS
C
      NORM = NORMF .NE. 1 .OR. NORMP .NE. 1
C
      CALL TSECND(TIME00)
      IPCOUNT = 0
C      IF (GOPARR) CALL VCLR(V,1,NAUXBAS2)
      DO II = 1, NAUXSH
         IAT = KAUXAT(II)
         CC(1,1) = C(1,IAT)
         CC(2,1) = C(2,IAT)
         CC(3,1) = C(3,IAT)
         LANGI = KAUXTY(II)-1
         NGI   = KAUXNG(II)
         MINI  = KAUXMI(II)
         MAXI  = KAUXMX(II)
         I1    = KAUXST(II)
         LOCI  = KAUXLO(II)-MINI
         NI    = MAXI-MINI+1
         IF(SPHAUX) THEN
            CALL RIMP2CSTRM(TI,LANGI,MINI,NI,MINIS,MAXIS)
            LOCIS = LOCSPH(II)-MINIS
            NIS   = MAXIS-MINIS+1
C            WRITE(6,*) 'II=',II,'LANGI=',LANGI
C            WRITE(6,*) 'MINIS=',MINIS,'MAXIS=',MAXIS
C            WRITE(6,*) 'LOCIS=',LOCIS
C            CALL PRSQ(TI,NI,NI,NI)
         END IF
C
         DO JJ = 1, II
C
C     ----- GO PARALLEL! -----
C
C            IF (GOPARR) THEN
C               IPCOUNT = IPCOUNT + 1
C               IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 1000
C            END IF
            IPCOUNT = IPCOUNT+1
            IF(MOD(IPCOUNT,SMP_NP) .NE. SMP_ME) GO TO 1000
C
            JAT = KAUXAT(JJ)
            CC(1,2) = C(1,JAT)
            CC(2,2) = C(2,JAT)
            CC(3,2) = C(3,JAT)
            LANGJ = KAUXTY(JJ)-1
            NGJ   = KAUXNG(JJ)
            MINJ  = KAUXMI(JJ)
            MAXJ  = KAUXMX(JJ)
            J1    = KAUXST(JJ)
            LOCJ  = KAUXLO(JJ)-MINJ
            NJ = MAXJ-MINJ+1
            IANDJ = II .EQ. JJ
            IF(SPHAUX) THEN
               CALL RIMP2CSTRM(TJ,LANGJ,MINJ,NJ,MINJS,MAXJS)
               LOCJS = LOCSPH(JJ)-MINJS
               NJS   = MAXJS-MINJS+1
C               WRITE(6,*) 'JJ=',JJ,'LANGJ=',LANGJ
C               WRITE(6,*) 'MINJS=',MINJS,'MAXJS=',MAXJS
C               WRITE(6,*) 'LOCJS=',LOCJS
C               CALL PRSQ(TJ,NJ,NJ,NJ)
            END IF
C
C           EVALUATE 2C-ERIS (I|J)
C
            CALL GEN2C2ERI(CC,EXAUX(I1),CAUXS(I1),CAUXP(I1),CAUXD(I1),
     *           CAUXF(I1),CAUXG(I1),CAUXH(I1),CAUXI(I1),
     *           EXAUX(J1),CAUXS(J1),CAUXP(J1),CAUXD(J1),CAUXF(J1),
     *           CAUXG(J1),CAUXH(J1),CAUXI(J1),GHONDO,
     *           LANGI,LANGJ,NGI,NGJ,MINI,MAXI,MINJ,MAXJ,NORM,NORM)
C
C           COPY 2C-ERIS FROM BUFFER TO MATRIX
C
            CALL CP2CAUXINT(GHONDO,V,TI,TJ,W,NAUXBAS,
     *           LOCI,LOCJ,MINI,MAXI,MINJ,MAXJ,NI,NJ,
     *           LOCIS,LOCJS,MINIS,MAXIS,MINJS,MAXJS,NIS,NJS,
     *           SPHAUX,IANDJ)
C
 1000       CONTINUE
         END DO
      END DO
      CALL DDI_SMP_SYNC()
      CALL TSECND(TIME01)
      TIME0 = TIME01-TIME00
C
C     ----- SUM UP PARTIAL CONTRIBUTIONS IF PARALLEL -----
C
C      IF (GOPARR) CALL DDI_GSUMF(3000,V,NAUXBAS2)
C
C      IF(MASWRK) THEN
C         WRITE(IW,*) 'V MATRIX'
C         CALL PRSQ(V,NAUXBAS,NAUXBAS,NAUXBAS)
C      END IF
      IF(MASWRK) WRITE(IW,9999) TIME0
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 2C-2E ERI MATRIX GENERATION =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIMP2VINV2
      SUBROUTINE RIMP2VINV2(V,WRK1,WRK2,TRI,IWRK,SCR,VTOL,
     *                      NAUXBAS,NAUXBASD,IW,MASWRK)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL MASWRK
C
      DOUBLE PRECISION V(NAUXBAS,NAUXBAS),WRK1(NAUXBAS*NAUXBAS),
     *     WRK2(NAUXBAS),TRI(*),IWRK(NAUXBAS),SCR(NAUXBAS,8)
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
C
C      IF(MASWRK) THEN
C         WRITE(IW,*) 'V MATRIX'
C         CALL PRSQ(V,NAUXBAS,NAUXBAS,NAUXBAS)
C      END IF
C
C     DIAGONALIZE V MATRIX: VECTORS TO -V- AND EIGENVALUES TO -WRK2-
C
      CALL TSECND(TIME10)
C---  NAUXBAS2 = NAUXBAS*NAUXBAS
C---  CALL DSYEV('V','U',NAUXBAS,V,NAUXBAS,WRK2,WRK1,NAUXBAS2,INFO)
C
      CALL CPYSQT(V,TRI,NAUXBAS,1)
      CALL GLDIAG(NAUXBAS,NAUXBAS,NAUXBAS,TRI,SCR,WRK2,V,IERR,IWRK)
      CALL TSECND(TIME11)
      TIME1 = TIME11-TIME10
C
C      IF(MASWRK) THEN
C         WRITE(IW,*) 'EIGENVECTORS OF 2C-2E V MATRIX'
C         CALL PREV(V,WRK2,NAUXBAS,NAUXBAS,NAUXBAS)
C      END IF
C
C     MAKE V^(-1/2) MATRIX
C
      CALL TSECND(TIME20)
      NAUXBASD = 0
      DO IAUX = NAUXBAS, 1, -1
         IF(WRK2(IAUX) .LT. VTOL) GO TO 100
         NAUXBASD = NAUXBASD+1
         WRK1(NAUXBASD) = WRK2(IAUX)
      END DO
 100  CONTINUE
      IVAL = NAUXBAS-NAUXBASD
      IF(MASWRK .AND. IVAL .GT. 0) THEN
         WRITE(IW,9010) VTOL,IVAL
         WRITE(IW,*) (WRK2(I),I=1,IVAL)
         ICNT = 0
         DO I = 1, IVAL
            IF(WRK2(I) .LT. ZERO) ICNT = ICNT+1
         END DO
         IF(ICNT .GT. 0) WRITE(IW,9020) ICNT
      END IF
      DO IAUX = 1, NAUXBASD
         WRK2(IAUX) = ONE/SQRT(WRK1(IAUX))
      END DO
      ICNT = 0
      DO JAUX = 1, NAUXBAS
         IAUX2 = NAUXBAS
         DO IAUX = 1, NAUXBASD
            ICNT = ICNT+1
            WRK1(ICNT) = V(JAUX,IAUX2)*WRK2(IAUX)
            IAUX2 = IAUX2-1
         END DO
      END DO
      CALL DCOPY(NAUXBAS*NAUXBASD,WRK1,1,V,1)
      CALL TSECND(TIME21)
      TIME2 = TIME21-TIME20
C
C      IF(MASWRK) THEN
C         WRITE(IW,*) 'V^(-1/2) MATRIX'
C         CALL PRSQ(V,NAUXBASD,NAUXBAS,NAUXBASD)
C      END IF
C
      IF(MASWRK) WRITE(IW,9999) TIME1,TIME2
      CALL FLSHBF(IW)
      RETURN
C
 9010 FORMAT(/1X,'NUMBER OF AUX. BASIS FUNCTIONS'/,
     *        1X,'LESS THAN ',E10.4,' =',I5)
 9020 FORMAT(1X,'WARNING!! ',I5,' EIGENVALUES ARE NEGATIVE VALUES!')
 9999 FORMAT(/1X,'TIME OF V MATRIX DIAGONALIZATION    =    ',F9.1,
     *       /1X,'TIME OF V^(-1/2) MATRIX GENERATION  =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIMP2VINVBCK
      SUBROUTINE RIMP2VINVBCK(V,X,W,NAUXBAS,NAUXBAS1,NAUXBASD)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION V(*),X(*),W(*)
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
C     BUCK TRANSFORM DECOMPOSED MATRIX
C     (ORTHOGONAL -> CARTESIAN OR SPHERICAL)
C
      CALL DCOPY(NAUXBAS1*NAUXBASD,V,1,W,1)
      CALL DGEMM('N','T',NAUXBASD,NAUXBAS,NAUXBAS1,ONE,W,NAUXBASD,
     *     X,NAUXBAS,ZERO,V,NAUXBASD)
C
C      WRITE(IW,*) 'FINAL V^(-1/2) MATRIX'
C      CALL PRSQ(V,NAUXBAS,NAUXBASD,NAUXBASD)
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIMP2VINV
      SUBROUTINE RIMP2VINV(V,NAUXBAS,IW,MASWRK)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL MASWRK
C
      DOUBLE PRECISION V(NAUXBAS,NAUXBAS)
C
      PARAMETER (ZERO=0.0D+00)
C
C      IF(MASWRK) THEN
C         WRITE(IW,*) 'V MATRIX'
C         CALL PRSQ(V,NAUXBAS,NAUXBAS,NAUXBAS)
C      END IF
C
C     CHOLESKY DECOMPOSION OF 2C-2E MATRIX V=L*LT
C
      CALL TSECND(TIME10)
      CALL DPOTRF('L',NAUXBAS,V,NAUXBAS,INFO)
      CALL TSECND(TIME11)
      TIME1 = TIME11-TIME10
C
C      IF(MASWRK) THEN
C         WRITE(IW,*) 'CHOLESKY DECOMPOSED V MATRIX'
C         CALL PRSQ(V,NAUXBAS,NAUXBAS,NAUXBAS)
C      END IF
C
C     DETERMINATION OF INVERSE OF CHOLESKY DECOMPOSED MATRIX L^(-1)
C
      CALL TSECND(TIME20)
      CALL DTRTRI('L','N',NAUXBAS,V,NAUXBAS,INFO)
      IF(NAUXBAS .GT. 1) THEN
         DO JAUX = 2, NAUXBAS
            DO IAUX = 1, JAUX-1
               V(IAUX,JAUX) = ZERO
            END DO
         END DO
      END IF
      CALL TSECND(TIME21)
      TIME2 = TIME21-TIME20
C
C      IF(MASWRK) THEN
C         WRITE(IW,*) 'L^(-1) MATRIX'
C         CALL PRSQ(V,NAUXBAS,NAUXBAS,NAUXBAS)
C      END IF
C
      IF(MASWRK) WRITE(IW,9999) TIME1,TIME2
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF CHOLESKY DECOMPOSITION      =    ',F9.1,
     *       /1X,'TIME OF INVERSE MATRIX GENERATION   =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIMP2VOTH
      SUBROUTINE RIMP2VOTH(V,X,W,NAUXBAS,NAUXBAS1)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION V(*),X(*),W(*)
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
      CALL DGEMM('T','N',NAUXBAS1,NAUXBAS,NAUXBAS,ONE,X,NAUXBAS,
     *     V,NAUXBAS,ZERO,W,NAUXBAS1)
      CALL DGEMM('N','N',NAUXBAS1,NAUXBAS1,NAUXBAS,ONE,W,NAUXBAS1,
     *     X,NAUXBAS,ZERO,V,NAUXBAS1)
C
C      WRITE(IW,*) 'V ORTH MATRIX'
C      CALL PRSQ(V,NAUXBAS1,NAUXBAS1,NAUXBAS1)
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIMP2VRD
      SUBROUTINE RIMP2VRD(V,LENV,IFILV)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION V(LENV)
C
      READ(IFILV) V
      REWIND(IFILV)
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIMP2VWT
      SUBROUTINE RIMP2VWT(V,LENV,IFILV)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION V(LENV)
C
      WRITE(IFILV) V
      REWIND(IFILV)
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIUMP2E2ACCA
      SUBROUTINE RIUMP2E2ACCA(EIG,BB,BK,Q,INFOCCBAT,E2T,NAUXBAS,NORB,
     *     NOCC,NVIR,NOCCBAT,IFILT3,IW,MASWRK,USEDM,D_T)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL MASWRK
      LOGICAL USEDM
C
      DOUBLE PRECISION EIG(*),BB(NAUXBAS,NVIR,*),BK(NAUXBAS,NVIR,*),Q(*)
      INTEGER INFOCCBAT(2,NOCCBAT)
C
      INTEGER D_T
C
      PARAMETER (ZERO=0.0D+00, PT5=0.5D+00)
C
C     GENERATE 4C-2E ERI FROM 3 INDICES INTERMEDIATE MATRICES
C     AND ACCUMULATE UMP2 CORRELATION ENERGY.
C
      TIMER = ZERO
      TIME4 = ZERO
      TIME5 = ZERO
C
      LENT3 = NAUXBAS*NVIR
C
      E2T = ZERO
      DO JBAT = 1, NOCCBAT
         JOCCBG = INFOCCBAT(1,JBAT)+1
         JOCCED = INFOCCBAT(1,JBAT)+INFOCCBAT(2,JBAT)
         CALL TSECND(TIMER0)
         IF(.NOT. USEDM) THEN
            DO JOCC = JOCCBG, JOCCED
               J = JOCC-JOCCBG+1
               CALL RIMP2T3RD(BK(1,1,J),LENT3,IFILT3,JOCC)
            END DO
         ELSE
            CALL DDI_GET(D_T,1,LENT3,JOCCBG,JOCCED,BK)
         END IF
         CALL TSECND(TIMER1)
         TIMER = TIMER+(TIMER1-TIMER0)
C
         DO IBAT = 1, JBAT
            IOCCBG = INFOCCBAT(1,IBAT)+1
            IOCCED = INFOCCBAT(1,IBAT)+INFOCCBAT(2,IBAT)
            IF(IBAT .NE. JBAT) THEN
               CALL TSECND(TIMER0)
               IF(.NOT. USEDM) THEN
                  DO IOCC = IOCCBG, IOCCED
                     I = IOCC-IOCCBG+1
                     CALL RIMP2T3RD(BB(1,1,I),LENT3,IFILT3,IOCC)
                  END DO
               ELSE
                  CALL DDI_GET(D_T,1,LENT3,IOCCBG,IOCCED,BB)
               END IF
               CALL TSECND(TIMER1)
               TIMER = TIMER+(TIMER1-TIMER0)
            ELSE
               CALL DCOPY(LENT3*INFOCCBAT(2,IBAT),BK,1,BB,1)
            END IF
C
            CALL RIUMP2TEIE2A(EIG,BB,BK,Q,E2T,NAUXBAS,NORB,NOCC,NVIR,
     *           IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,JBAT,TIME4,TIME5)
C
         END DO                 !IBAT
      END DO                    !JBAT
      E2T = PT5*E2T
C
      IF(MASWRK) WRITE(IW,9999) TIMER,TIME4,TIME5
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 3/3 INTEGRAL READ           =    ',F9.1,
     *       /1X,'TIME OF TEI GENERATION              =    ',F9.1,
     *       /1X,'TIME OF MP2 ENERGY ACCUMULATION     =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIUMP2E2ACCAP2
      SUBROUTINE RIUMP2E2ACCAP2(EIG,BB,BK,Q,INFOCCBAT,E2T,NAUXBAS,
     *     NORB,NOCC,NVIR,NOCCBAT,IW,D_T)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION EIG(*),BB(NAUXBAS,NVIR,*),BK(NAUXBAS,NVIR,*),Q(*)
      INTEGER INFOCCBAT(2,NOCCBAT)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      INTEGER D_T
C
      PARAMETER (ZERO=0.0D+00, PT5=0.5D+00)
C
C     GENERATE 4C-2E ERI FROM 3 INDICES INTERMEDIATE MATRICES
C     AND ACCUMULATE UMP2 CORRELATION ENERGY.
C     THIS SUBROUTINE IS FOR PARALLEL CALCULATIONS.
C
      TIMEC = ZERO
      TIME4 = ZERO
      TIME5 = ZERO
C
      LENT3 = NAUXBAS*NVIR
C
      MYPROC = ME+1
      NBATP1 = NOCCBAT/NPROC
      NBATP1C = NBATP1/2
C
      E2T = ZERO
      DO JBATP1 = 1, NBATP1
         DO JPDIF = 1, NPROC/2
            J2PROC = MYPROC+JPDIF
            IF(J2PROC .GT. NPROC) J2PROC = J2PROC-NPROC
            J2BAT = (J2PROC-1)*NBATP1+JBATP1
            JOCCBG = INFOCCBAT(1,J2BAT)+1
            JOCCED = INFOCCBAT(1,J2BAT)+INFOCCBAT(2,J2BAT)
            CALL TSECND(TIMEC0)
            CALL DDI_GET(D_T,1,LENT3,JOCCBG,JOCCED,BK)
            CALL TSECND(TIMEC1)
            TIMEC = TIMEC+(TIMEC1-TIMEC0)
            IBATBG = (MYPROC-1)*NBATP1+1
            IBATED = MYPROC*NBATP1
            IF(MOD(NPROC,2) .EQ. 0 .AND. JPDIF .EQ. NPROC/2) THEN
               IF(MYPROC .LT. J2PROC) THEN
                  IF(JBATP1 .LE. NBATP1C) THEN
                     IBATBG = (MYPROC-1)*NBATP1+1
                     IBATED = (MYPROC-1)*NBATP1+NBATP1C
                  ELSE
                     IBATBG = (MYPROC-1)*NBATP1+NBATP1C+1
                     IBATED = MYPROC*NBATP1
                  END IF
               ELSE
                  IF(JBATP1 .LE. NBATP1C) THEN
                     IBATBG = (MYPROC-1)*NBATP1+NBATP1C+1
                     IBATED = MYPROC*NBATP1
                  ELSE
                     IBATBG = (MYPROC-1)*NBATP1+1
                     IBATED = (MYPROC-1)*NBATP1+NBATP1C
                  END IF
               END IF
            END IF
            DO IBAT = IBATBG, IBATED
               IOCCBG = INFOCCBAT(1,IBAT)+1
               IOCCED = INFOCCBAT(1,IBAT)+INFOCCBAT(2,IBAT)
               CALL TSECND(TIMEC0)
               CALL DDI_GET(D_T,1,LENT3,IOCCBG,IOCCED,BB)
               CALL TSECND(TIMEC1)
               TIMEC = TIMEC+(TIMEC1-TIMEC0)
C
               CALL RIUMP2TEIE2A(EIG,BB,BK,Q,E2T,NAUXBAS,NORB,NOCC,NVIR,
     *              IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,J2BAT,TIME4,TIME5)
C
            END DO              !IBAT
C
         END DO                 !JPDIF
C
         J1BAT = (MYPROC-1)*NBATP1+JBATP1
         JOCCBG = INFOCCBAT(1,J1BAT)+1
         JOCCED = INFOCCBAT(1,J1BAT)+INFOCCBAT(2,J1BAT)
         CALL TSECND(TIMEC0)
         CALL DDI_GET(D_T,1,LENT3,JOCCBG,JOCCED,BK)
         CALL TSECND(TIMEC1)
         TIMEC = TIMEC+(TIMEC1-TIMEC0)
         IBATBG = (MYPROC-1)*NBATP1+1
         DO IBAT = IBATBG, J1BAT
            IOCCBG = INFOCCBAT(1,IBAT)+1
            IOCCED = INFOCCBAT(1,IBAT)+INFOCCBAT(2,IBAT)
            CALL TSECND(TIMEC0)
            IF(IBAT .NE. J1BAT) THEN
               CALL DDI_GET(D_T,1,LENT3,IOCCBG,IOCCED,BB)
            ELSE
               CALL DCOPY(LENT3*INFOCCBAT(2,IBAT),BK,1,BB,1)
            END IF
            CALL TSECND(TIMEC1)
            TIMEC = TIMEC+(TIMEC1-TIMEC0)
C
            CALL RIUMP2TEIE2A(EIG,BB,BK,Q,E2T,NAUXBAS,NORB,NOCC,NVIR,
     *           IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,J1BAT,TIME4,TIME5)
C
         END DO                 !IBAT
      END DO                    !JBATP1
C
      E2T = PT5*E2T
C
      IF(MASWRK) WRITE(IW,9999) TIMEC,TIMEC,TIME4,TIME5
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 3/3 INTEGRAL READ           =    ',F9.1,
     *       /1X,'TIME OF 3/3 INTEGRAL NETWORK COMM.  =    ',F9.1,
     *       /1X,'TIME OF TEI GENERATION              =    ',F9.1,
     *       /1X,'TIME OF MP2 ENERGY ACCUMULATION     =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIUMP2E2ACCAP2SMP
      SUBROUTINE RIUMP2E2ACCAP2SMP(EIG,BB,BK,Q,INFOCCBAT,E2T,
     *     NAUXBAS,NORB,NOCC,NVIR,NOCCBAT,
     *     IW,DDI_NN,DDI_MY,SMP_NP,SMP_ME,D_T)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION EIG(*),BB(NAUXBAS,NVIR,*),BK(NAUXBAS,NVIR,*),Q(*)
      INTEGER INFOCCBAT(2,NOCCBAT)
C
      INTEGER DDI_NN,DDI_MY,SMP_NP,SMP_ME
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      INTEGER D_T
C
      PARAMETER (ZERO=0.0D+00, PT5=0.5D+00)
C
C     GENERATE 4C-2E ERI FROM 3 INDICES INTERMEDIATE MATRICES
C     AND ACCUMULATE UMP2 CORRELATION ENERGY.
C     THIS SUBROUTINE IS FOR PARALLEL CALCULATIONS.
C
      TIMEC = ZERO
      TIME4 = ZERO
      TIME5 = ZERO
C
      LENT3 = NAUXBAS*NVIR
C
      MYNODE = DDI_MY+1
      NBATP1 = NOCCBAT/DDI_NN
      NBATP1C = NBATP1/2
C
      E2T = ZERO
      DO JBATP1 = 1, NBATP1
         DO JPDIF = 1, DDI_NN/2
            J2NODE = MYNODE+JPDIF
            IF(J2NODE .GT. DDI_NN) J2NODE = J2NODE-DDI_NN
            J2BAT = (J2NODE-1)*NBATP1+JBATP1
            JOCCBG = INFOCCBAT(1,J2BAT)+1
            JOCCED = INFOCCBAT(1,J2BAT)+INFOCCBAT(2,J2BAT)
C            WRITE(6,*) 'J2BAT=',J2BAT,'JOCCBG=',JOCCBG,'JOCCED=',JOCCED
            CALL TSECND(TIMEC0)
            IF(SMP_ME .EQ. 0)
     *           CALL DDI_GET(D_T,1,LENT3,JOCCBG,JOCCED,BK)
            CALL DDI_SMP_SYNC()
            CALL TSECND(TIMEC1)
            TIMEC = TIMEC+(TIMEC1-TIMEC0)
            IBATBG = (MYNODE-1)*NBATP1+1
            IBATED = MYNODE*NBATP1
            IF(MOD(DDI_NN,2) .EQ. 0 .AND. JPDIF .EQ. DDI_NN/2) THEN
               IF(MYNODE .LT. J2NODE) THEN
                  IF(JBATP1 .LE. NBATP1C) THEN
                     IBATBG = (MYNODE-1)*NBATP1+1
                     IBATED = (MYNODE-1)*NBATP1+NBATP1C
                  ELSE
                     IBATBG = (MYNODE-1)*NBATP1+NBATP1C+1
                     IBATED = MYNODE*NBATP1
                  END IF
               ELSE
                  IF(JBATP1 .LE. NBATP1C) THEN
                     IBATBG = (MYNODE-1)*NBATP1+NBATP1C+1
                     IBATED = MYNODE*NBATP1
                  ELSE
                     IBATBG = (MYNODE-1)*NBATP1+1
                     IBATED = (MYNODE-1)*NBATP1+NBATP1C
                  END IF
               END IF
            END IF
            CALL DDI_SMP_SYNC()
            DO IBAT = IBATBG, IBATED
               IOCCBG = INFOCCBAT(1,IBAT)+1
               IOCCED = INFOCCBAT(1,IBAT)+INFOCCBAT(2,IBAT)
C         WRITE(6,*) 'IBAT=',IBAT,'IOCCBG=',IOCCBG,'IOCCED=',IOCCED
               CALL TSECND(TIMEC0)
               IF(SMP_ME .EQ. 0)
     *              CALL DDI_GET(D_T,1,LENT3,IOCCBG,IOCCED,BB)
               CALL DDI_SMP_SYNC()
               CALL TSECND(TIMEC1)
               TIMEC = TIMEC+(TIMEC1-TIMEC0)
C
               CALL RIUMP2TEIE2ASMP(EIG,BB,BK,Q,E2T,NAUXBAS,NORB,NOCC,
     *              NVIR,IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,J2BAT,
     *              TIME4,TIME5,SMP_NP,SMP_ME)
C
               CALL DDI_SMP_SYNC()
            END DO              !IBAT
C
         END DO                 !JPDIF
C
         J1BAT = (MYNODE-1)*NBATP1+JBATP1
         JOCCBG = INFOCCBAT(1,J1BAT)+1
         JOCCED = INFOCCBAT(1,J1BAT)+INFOCCBAT(2,J1BAT)
         CALL TSECND(TIMEC0)
         IF(SMP_ME .EQ. 0) CALL DDI_GET(D_T,1,LENT3,JOCCBG,JOCCED,BK)
         CALL DDI_SMP_SYNC()
         CALL TSECND(TIMEC1)
         TIMEC = TIMEC+(TIMEC1-TIMEC0)
         IBATBG = (MYNODE-1)*NBATP1+1
         DO IBAT = IBATBG, J1BAT
            IOCCBG = INFOCCBAT(1,IBAT)+1
            IOCCED = INFOCCBAT(1,IBAT)+INFOCCBAT(2,IBAT)
            CALL TSECND(TIMEC0)
            IF(SMP_ME .EQ. 0) THEN
               IF(IBAT .NE. J1BAT) THEN
                  CALL DDI_GET(D_T,1,LENT3,IOCCBG,IOCCED,BB)
               ELSE
                  CALL DCOPY(LENT3*INFOCCBAT(2,IBAT),BK,1,BB,1)
               END IF
            END IF
            CALL DDI_SMP_SYNC()
            CALL TSECND(TIMEC1)
            TIMEC = TIMEC+(TIMEC1-TIMEC0)
C
            CALL RIUMP2TEIE2ASMP(EIG,BB,BK,Q,E2T,NAUXBAS,NORB,NOCC,NVIR,
     *           IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,J1BAT,
     *           TIME4,TIME5,SMP_NP,SMP_ME)
C
            CALL DDI_SMP_SYNC()
         END DO                 !IBAT
      END DO                    !JBATP1
C
      E2T = PT5*E2T
C
      IF(MASWRK) WRITE(IW,9999) TIMEC,TIME4,TIME5
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 3/3 INTEGRAL NETWORK COMM.  =    ',F9.1,
     *       /1X,'TIME OF TEI GENERATION              =    ',F9.1,
     *       /1X,'TIME OF MP2 ENERGY ACCUMULATION     =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIUMP2E2ACCAP
      SUBROUTINE RIUMP2E2ACCAP(EIG,BB,BK1,BK2,Q,INFOCCBAT,E2T,
     *     NAUXBAS,NORB,NOCC,NVIR,NOCCBAT,LENOCCBAT,IFILT3,IW)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION EIG(*),BB(NAUXBAS,NVIR,*),BK1(NAUXBAS,NVIR,*),
     *     BK2(NAUXBAS,NVIR,*),Q(*)
      INTEGER INFOCCBAT(2,NOCCBAT)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ZERO=0.0D+00, PT5=0.5D+00)
C
C     GENERATE 4C-2E ERI FROM 3 INDICES INTERMEDIATE MATRICES
C     AND ACCUMULATE UMP2 CORRELATION ENERGY.
C     THIS SUBROUTINE IS FOR PARALLEL CALCULATIONS.
C
      TIMER = ZERO
      TIMEC = ZERO
      TIME4 = ZERO
      TIME5 = ZERO
C
      LENT3 = NAUXBAS*NVIR
      LENB = NAUXBAS*NVIR*LENOCCBAT
C
      MYPROC = ME+1
      NBATP1 = NOCCBAT/NPROC
      NBATP1C = NBATP1/2
C
      E2T = ZERO
      DO JBATP1 = 1, NBATP1
         J1BAT = (MYPROC-1)*NBATP1+JBATP1
         J1OCCBG = INFOCCBAT(1,J1BAT)+1
         J1OCCED = INFOCCBAT(1,J1BAT)+INFOCCBAT(2,J1BAT)
         CALL TSECND(TIMER0)
         DO JOCC = J1OCCBG, J1OCCED
            J = JOCC-J1OCCBG+1
            CALL RIMP2T3RD(BK1(1,1,J),LENT3,IFILT3,JOCC)
         END DO
         CALL TSECND(TIMER1)
         TIMER = TIMER+(TIMER1-TIMER0)
         DO JPDIF = 1, NPROC/2
            J1PROC = MYPROC-JPDIF
            J2PROC = MYPROC+JPDIF
            IF(J1PROC .LE. 0)     J1PROC = J1PROC+NPROC
            IF(J2PROC .GT. NPROC) J2PROC = J2PROC-NPROC
            J1RANK = J1PROC-1
            J2RANK = J2PROC-1
            CALL TSECND(TIMEC0)
            CALL DDI_ISEND(BK1,8*LENB,J1RANK,IREQ1)
            CALL DDI_IRECV(BK2,8*LENB,J2RANK,IREQ2)
            CALL DDI_WAIT(IREQ1)
            CALL DDI_WAIT(IREQ2)
            CALL TSECND(TIMEC1)
            TIMEC = TIMEC+(TIMEC1-TIMEC0)
            J2BAT = (J2PROC-1)*NBATP1+JBATP1
            JOCCBG = INFOCCBAT(1,J2BAT)+1
            JOCCED = INFOCCBAT(1,J2BAT)+INFOCCBAT(2,J2BAT)
            IBATBG = (MYPROC-1)*NBATP1+1
            IBATED = MYPROC*NBATP1
            IF(MOD(NPROC,2) .EQ. 0 .AND. JPDIF .EQ. NPROC/2) THEN
               IF(MYPROC .LT. J2PROC) THEN
                  IF(JBATP1 .LE. NBATP1C) THEN
                     IBATBG = (MYPROC-1)*NBATP1+1
                     IBATED = (MYPROC-1)*NBATP1+NBATP1C
                  ELSE
                     IBATBG = (MYPROC-1)*NBATP1+NBATP1C+1
                     IBATED = MYPROC*NBATP1
                  END IF
               ELSE
                  IF(JBATP1 .LE. NBATP1C) THEN
                     IBATBG = (MYPROC-1)*NBATP1+NBATP1C+1
                     IBATED = MYPROC*NBATP1
                  ELSE
                     IBATBG = (MYPROC-1)*NBATP1+1
                     IBATED = (MYPROC-1)*NBATP1+NBATP1C
                  END IF
               END IF
            END IF
            DO IBAT = IBATBG, IBATED
               IOCCBG = INFOCCBAT(1,IBAT)+1
               IOCCED = INFOCCBAT(1,IBAT)+INFOCCBAT(2,IBAT)
               CALL TSECND(TIMER0)
               DO IOCC = IOCCBG, IOCCED
                  I = IOCC-IOCCBG+1
                  CALL RIMP2T3RD(BB(1,1,I),LENT3,IFILT3,IOCC)
               END DO
               CALL TSECND(TIMER1)
               TIMER = TIMER+(TIMER1-TIMER0)
C
               CALL RIUMP2TEIE2A(EIG,BB,BK2,Q,E2T,NAUXBAS,NORB,NOCC,
     *              NVIR,IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,J2BAT,
     *              TIME4,TIME5)
C
            END DO              !IBAT
C
         END DO                 !JPDIF
C
         IBATBG = (MYPROC-1)*NBATP1+1
         JOCCBG = J1OCCBG
         JOCCED = J1OCCED
         DO IBAT = IBATBG, J1BAT
            IOCCBG = INFOCCBAT(1,IBAT)+1
            IOCCED = INFOCCBAT(1,IBAT)+INFOCCBAT(2,IBAT)
            CALL TSECND(TIMER0)
            IF(IBAT .NE. J1BAT) THEN
               DO IOCC = IOCCBG, IOCCED
                  I = IOCC-IOCCBG+1
                  CALL RIMP2T3RD(BB(1,1,I),LENT3,IFILT3,IOCC)
               END DO
            ELSE
               CALL DCOPY(LENT3*INFOCCBAT(2,IBAT),BK1,1,BB,1)
            END IF
            CALL TSECND(TIMER1)
            TIMER = TIMER+(TIMER1-TIMER0)
C
            CALL RIUMP2TEIE2A(EIG,BB,BK1,Q,E2T,NAUXBAS,NORB,NOCC,NVIR,
     *           IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,J1BAT,TIME4,TIME5)
C
         END DO                 !IBAT
      END DO                    !JBATP1
C
      E2T = PT5*E2T
C
      IF(MASWRK) WRITE(IW,9999) TIMER,TIMEC,TIME4,TIME5
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 3/3 INTEGRAL READ           =    ',F9.1,
     *       /1X,'TIME OF 3/3 INTEGRAL NETWORK COMM.  =    ',F9.1,
     *       /1X,'TIME OF TEI GENERATION              =    ',F9.1,
     *       /1X,'TIME OF MP2 ENERGY ACCUMULATION     =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIUMP2E2ACCAPSMP
      SUBROUTINE RIUMP2E2ACCAPSMP(EIG,BB,BK1,BK2,Q,INFOCCBAT,E2T,
     *     NAUXBAS,NORB,NOCC,NVIR,NOCCBAT,LENOCCBAT,
     *     IFILT3,IW,DDI_NN,DDI_MY,SMP_NP,SMP_ME)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION EIG(*),BB(NAUXBAS,NVIR,*),BK1(NAUXBAS,NVIR,*),
     *     BK2(NAUXBAS,NVIR,*),Q(*)
      INTEGER INFOCCBAT(2,NOCCBAT)
C
      INTEGER DDI_NN,DDI_MY,SMP_NP,SMP_ME
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ZERO=0.0D+00, PT5=0.5D+00)
C
C     GENERATE 4C-2E ERI FROM 3 INDICES INTERMEDIATE MATRICES
C     AND ACCUMULATE UMP2 CORRELATION ENERGY.
C     THIS SUBROUTINE IS FOR PARALLEL CALCULATIONS.
C
      TIMER = ZERO
      TIMEC = ZERO
      TIME4 = ZERO
      TIME5 = ZERO
C
      LENT3 = NAUXBAS*NVIR
      LENB = NAUXBAS*NVIR*LENOCCBAT
C
      MYNODE = DDI_MY+1
      NBATP1 = NOCCBAT/DDI_NN
      NBATP1C = NBATP1/2
C
      E2T = ZERO
      DO JBATP1 = 1, NBATP1
         J1BAT = (MYNODE-1)*NBATP1+JBATP1
         J1OCCBG = INFOCCBAT(1,J1BAT)+1
         J1OCCED = INFOCCBAT(1,J1BAT)+INFOCCBAT(2,J1BAT)
         CALL TSECND(TIMER0)
         IF(SMP_ME .EQ. 0) THEN
            DO JOCC = J1OCCBG, J1OCCED
               J = JOCC-J1OCCBG+1
               CALL RIMP2T3RD(BK1(1,1,J),LENT3,IFILT3,JOCC)
            END DO
         END IF
         CALL DDI_SMP_SYNC()
         CALL TSECND(TIMER1)
         TIMER = TIMER+(TIMER1-TIMER0)
         DO JPDIF = 1, DDI_NN/2
            J1NODE = MYNODE-JPDIF
            J2NODE = MYNODE+JPDIF
            IF(J1NODE .LE. 0)      J1NODE = J1NODE+DDI_NN
            IF(J2NODE .GT. DDI_NN) J2NODE = J2NODE-DDI_NN
            CALL TSECND(TIMEC0)
            IF(SMP_ME .EQ. 0) THEN
               J1RANK = (J1NODE-1)*SMP_NP
               J2RANK = (J2NODE-1)*SMP_NP
               CALL DDI_ISEND(BK1,8*LENB,J1RANK,IREQ1)
               CALL DDI_IRECV(BK2,8*LENB,J2RANK,IREQ2)
               CALL DDI_WAIT(IREQ1)
               CALL DDI_WAIT(IREQ2)
            END IF
            CALL DDI_SMP_SYNC()
            CALL TSECND(TIMEC1)
            TIMEC = TIMEC+(TIMEC1-TIMEC0)
            J2BAT = (J2NODE-1)*NBATP1+JBATP1
            JOCCBG = INFOCCBAT(1,J2BAT)+1
            JOCCED = INFOCCBAT(1,J2BAT)+INFOCCBAT(2,J2BAT)
            IBATBG = (MYNODE-1)*NBATP1+1
            IBATED = MYNODE*NBATP1
            IF(MOD(DDI_NN,2) .EQ. 0 .AND. JPDIF .EQ. DDI_NN/2) THEN
               IF(MYNODE .LT. J2NODE) THEN
                  IF(JBATP1 .LE. NBATP1C) THEN
                     IBATBG = (MYNODE-1)*NBATP1+1
                     IBATED = (MYNODE-1)*NBATP1+NBATP1C
                  ELSE
                     IBATBG = (MYNODE-1)*NBATP1+NBATP1C+1
                     IBATED = MYNODE*NBATP1
                  END IF
               ELSE
                  IF(JBATP1 .LE. NBATP1C) THEN
                     IBATBG = (MYNODE-1)*NBATP1+NBATP1C+1
                     IBATED = MYNODE*NBATP1
                  ELSE
                     IBATBG = (MYNODE-1)*NBATP1+1
                     IBATED = (MYNODE-1)*NBATP1+NBATP1C
                  END IF
               END IF
            END IF
            CALL DDI_SMP_SYNC()
            DO IBAT = IBATBG, IBATED
               IOCCBG = INFOCCBAT(1,IBAT)+1
               IOCCED = INFOCCBAT(1,IBAT)+INFOCCBAT(2,IBAT)
               CALL TSECND(TIMER0)
               IF(SMP_ME .EQ. 0) THEN
                  DO IOCC = IOCCBG, IOCCED
                     I = IOCC-IOCCBG+1
                     CALL RIMP2T3RD(BB(1,1,I),LENT3,IFILT3,IOCC)
                  END DO
               END IF
               CALL DDI_SMP_SYNC()
               CALL TSECND(TIMER1)
               TIMER = TIMER+(TIMER1-TIMER0)
C
               CALL RIUMP2TEIE2ASMP(EIG,BB,BK2,Q,E2T,NAUXBAS,NORB,NOCC,
     *              NVIR,IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,J2BAT,
     *              TIME4,TIME5,SMP_NP,SMP_ME)
C
               CALL DDI_SMP_SYNC()
            END DO              !IBAT
C
         END DO                 !JPDIF
C
         IBATBG = (MYNODE-1)*NBATP1+1
         JOCCBG = J1OCCBG
         JOCCED = J1OCCED
         DO IBAT = IBATBG, J1BAT
            IOCCBG = INFOCCBAT(1,IBAT)+1
            IOCCED = INFOCCBAT(1,IBAT)+INFOCCBAT(2,IBAT)
            CALL TSECND(TIMER0)
            IF(SMP_ME .EQ. 0) THEN
               IF(IBAT .NE. J1BAT) THEN
                  DO IOCC = IOCCBG, IOCCED
                     I = IOCC-IOCCBG+1
                     CALL RIMP2T3RD(BB(1,1,I),LENT3,IFILT3,IOCC)
                  END DO
               ELSE
                  CALL DCOPY(LENT3*INFOCCBAT(2,IBAT),BK1,1,BB,1)
               END IF
            END IF
            CALL DDI_SMP_SYNC()
            CALL TSECND(TIMER1)
            TIMER = TIMER+(TIMER1-TIMER0)
C
            CALL RIUMP2TEIE2ASMP(EIG,BB,BK1,Q,E2T,NAUXBAS,NORB,NOCC,
     *           NVIR,IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,J1BAT,
     *           TIME4,TIME5,SMP_NP,SMP_ME)
C
            CALL DDI_SMP_SYNC()
C
         END DO                 !IBAT
      END DO                    !JBATP1
C
      E2T = PT5*E2T
C
      IF(MASWRK) WRITE(IW,9999) TIMER,TIMEC,TIME4,TIME5
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 3/3 INTEGRAL READ           =    ',F9.1,
     *       /1X,'TIME OF 3/3 INTEGRAL NETWORK COMM.  =    ',F9.1,
     *       /1X,'TIME OF TEI GENERATION              =    ',F9.1,
     *       /1X,'TIME OF MP2 ENERGY ACCUMULATION     =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIUMP2E2ACCASMP
      SUBROUTINE RIUMP2E2ACCASMP(EIG,BB,BK,Q,INFOCCBAT,E2T,NAUXBAS,NORB,
     *     NOCC,NVIR,NOCCBAT,IFILT3,IW,MASWRK,SMP_NP,SMP_ME,USEDM,D_T)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL MASWRK
      LOGICAL USEDM
C
      DOUBLE PRECISION EIG(*),BB(NAUXBAS,NVIR,*),BK(NAUXBAS,NVIR,*),Q(*)
      INTEGER INFOCCBAT(2,NOCCBAT)
C
      INTEGER SMP_NP,SMP_ME
C
      INTEGER D_T
C
      PARAMETER (ZERO=0.0D+00, PT5=0.5D+00)
C
C     GENERATE 4C-2E ERI FROM 3 INDICES INTERMEDIATE MATRICES
C     AND ACCUMULATE UMP2 CORRELATION ENERGY.
C
      TIMER = ZERO
      TIME4 = ZERO
      TIME5 = ZERO
C
      LENT3 = NAUXBAS*NVIR
C
      E2T = ZERO
      DO JBAT = 1, NOCCBAT
         JOCCBG = INFOCCBAT(1,JBAT)+1
         JOCCED = INFOCCBAT(1,JBAT)+INFOCCBAT(2,JBAT)
         CALL TSECND(TIMER0)
         IF(SMP_ME .EQ. 0) THEN
            IF(.NOT. USEDM) THEN
               DO JOCC = JOCCBG, JOCCED
                  J = JOCC-JOCCBG+1
                  CALL RIMP2T3RD(BK(1,1,J),LENT3,IFILT3,JOCC)
               END DO
            ELSE
               CALL DDI_GET(D_T,1,LENT3,JOCCBG,JOCCED,BK)
            END IF
         END IF
         CALL DDI_SMP_SYNC()
         CALL TSECND(TIMER1)
         TIMER = TIMER+(TIMER1-TIMER0)
         DO IBAT = 1, JBAT
            IOCCBG = INFOCCBAT(1,IBAT)+1
            IOCCED = INFOCCBAT(1,IBAT)+INFOCCBAT(2,IBAT)
            CALL TSECND(TIMER0)
            IF(SMP_ME .EQ. 0) THEN
               IF(IBAT .NE. JBAT) THEN
                  IF(.NOT. USEDM) THEN
                     DO IOCC = IOCCBG, IOCCED
                        I = IOCC-IOCCBG+1
                        CALL RIMP2T3RD(BB(1,1,I),LENT3,IFILT3,IOCC)
                     END DO
                  ELSE
                     CALL DDI_GET(D_T,1,LENT3,IOCCBG,IOCCED,BB)
                  END IF
               ELSE
                  CALL DCOPY(LENT3*INFOCCBAT(2,IBAT),BK,1,BB,1)
               END IF
            END IF
            CALL DDI_SMP_SYNC()
            CALL TSECND(TIMER1)
            TIMER = TIMER+(TIMER1-TIMER0)
C
            CALL RIUMP2TEIE2ASMP(EIG,BB,BK,Q,E2T,NAUXBAS,NORB,NOCC,NVIR,
     *           IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,JBAT,TIME4,TIME5,
     *           SMP_NP,SMP_ME)
C
            CALL DDI_SMP_SYNC()
         END DO                 !IBAT
      END DO                    !JBAT
      E2T = PT5*E2T
C
      IF(MASWRK) WRITE(IW,9999) TIMER,TIME4,TIME5
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 3/3 INTEGRAL READ           =    ',F9.1,
     *       /1X,'TIME OF TEI GENERATION              =    ',F9.1,
     *       /1X,'TIME OF MP2 ENERGY ACCUMULATION     =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIUMP2E2ACCB
      SUBROUTINE RIUMP2E2ACCB(EIGA,EIGB,BB,BK,Q,INFOCCABAT,INFOCCBBAT,
     *     E2S,NAUXBAS,NORBA,NORBB,NOCCA,NOCCB,NVIRA,NVIRB,NOCCBAT,
     *     IFILT3A,IFILT3B,IW,MASWRK,USEDM,D_TA,D_TB)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL MASWRK
      LOGICAL USEDM
C
      DOUBLE PRECISION EIGA(*),EIGB(*),BB(NAUXBAS,NVIRA,*),
     *     BK(NAUXBAS,NVIRB,*),Q(*)
      INTEGER INFOCCABAT(2,NOCCBAT),INFOCCBBAT(2,NOCCBAT)
C
      INTEGER D_TA,D_TB
C
      PARAMETER (ZERO=0.0D+00)
C
C     GENERATE 4C-2E ERI FROM 3 INDICES INTERMEDIATE MATRICES
C     AND ACCUMULATE MP2 CORRELATION ENERGY.
C
      TIMER = ZERO
      TIME4 = ZERO
      TIME5 = ZERO
C
      LENT3A = NAUXBAS*NVIRA
      LENT3B = NAUXBAS*NVIRB
C
      E2S = ZERO
      DO JBAT = 1, NOCCBAT
         JOCCBG = INFOCCBBAT(1,JBAT)+1
         JOCCED = INFOCCBBAT(1,JBAT)+INFOCCBBAT(2,JBAT)
         CALL TSECND(TIMER0)
         IF(.NOT. USEDM) THEN
            DO JOCC = JOCCBG, JOCCED
               J = JOCC-JOCCBG+1
               CALL RIMP2T3RD(BK(1,1,J),LENT3B,IFILT3B,JOCC)
            END DO
         ELSE
            CALL DDI_GET(D_TB,1,LENT3B,JOCCBG,JOCCED,BK)
         END IF
         CALL TSECND(TIMER1)
         TIMER = TIMER+(TIMER1-TIMER0)
         DO IBAT = 1, NOCCBAT
            IOCCBG = INFOCCABAT(1,IBAT)+1
            IOCCED = INFOCCABAT(1,IBAT)+INFOCCABAT(2,IBAT)
            CALL TSECND(TIMER0)
            IF(.NOT. USEDM) THEN
               DO IOCC = IOCCBG, IOCCED
                  I = IOCC-IOCCBG+1
                  CALL RIMP2T3RD(BB(1,1,I),LENT3A,IFILT3A,IOCC)
               END DO
            ELSE
               CALL DDI_GET(D_TA,1,LENT3A,IOCCBG,IOCCED,BB)
            END IF
            CALL TSECND(TIMER1)
            TIMER = TIMER+(TIMER1-TIMER0)
C
            CALL RIUMP2TEIE2B(EIGA,EIGB,BB,BK,Q,E2S,NAUXBAS,NORBA,NORBB,
     *           NOCCA,NOCCB,NVIRA,NVIRB,IOCCBG,IOCCED,JOCCBG,JOCCED,
     *           TIME4,TIME5)
C
         END DO                 !IBAT
      END DO                    !JBAT
C
      IF(MASWRK) WRITE(IW,9999) TIMER,TIME4,TIME5
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 3/3 INTEGRAL READ           =    ',F9.1,
     *       /1X,'TIME OF TEI GENERATION              =    ',F9.1,
     *       /1X,'TIME OF MP2 ENERGY ACCUMULATION     =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIUMP2E2ACCBP2
      SUBROUTINE RIUMP2E2ACCBP2(EIGA,EIGB,BB,BK,Q,INFOCCABAT,
     *     INFOCCBBAT,E2S,NAUXBAS,NORBA,NORBB,NOCCA,NOCCB,NVIRA,
     *     NVIRB,NOCCBAT,IW)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION EIGA(*),EIGB(*),BB(NAUXBAS,NVIRA,*),
     *     BK(NAUXBAS,NVIRB,*),Q(*)
      INTEGER INFOCCABAT(2,NOCCBAT),INFOCCBBAT(2,NOCCBAT)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      INTEGER D_V,D_TA,D_TB
      COMMON /RIMPDD/ D_V,D_TA,D_TB
C
      PARAMETER (ZERO=0.0D+00)
C
C     GENERATE 4C-2E ERI FROM 3 INDICES INTERMEDIATE MATRICES
C     AND ACCUMULATE UMP2 CORRELATION ENERGY.
C     THIS SUBROUTINE IS FOR PARALLEL CALCULATIONS.
C
      TIMER = ZERO
      TIMEC = ZERO
      TIME4 = ZERO
      TIME5 = ZERO
C
      LENT3A = NAUXBAS*NVIRA
      LENT3B = NAUXBAS*NVIRB
C
      MYPROC = ME+1
      NBATP1 = NOCCBAT/NPROC
C
      E2S = ZERO
      IBATBG = (MYPROC-1)*NBATP1+1
      IBATED = MYPROC*NBATP1
      DO JBATP1 = 1, NBATP1
         DO JPDIF = 1, NPROC-1
            J2PROC = MYPROC+JPDIF
            IF(J2PROC .GT. NPROC) J2PROC = J2PROC-NPROC
            J2BAT = (J2PROC-1)*NBATP1+JBATP1
            JOCCBG = INFOCCBBAT(1,J2BAT)+1
            JOCCED = INFOCCBBAT(1,J2BAT)+INFOCCBBAT(2,J2BAT)
            CALL TSECND(TIMEC0)
            CALL DDI_GET(D_TB,1,LENT3B,JOCCBG,JOCCED,BK)
            CALL TSECND(TIMEC1)
            TIMEC = TIMEC+(TIMEC1-TIMEC0)
            DO IBAT = IBATBG, IBATED
               IOCCBG = INFOCCABAT(1,IBAT)+1
               IOCCED = INFOCCABAT(1,IBAT)+INFOCCABAT(2,IBAT)
               CALL TSECND(TIMEC0)
               CALL DDI_GET(D_TA,1,LENT3A,IOCCBG,IOCCED,BB)
               CALL TSECND(TIMEC1)
               TIMEC = TIMEC+(TIMEC1-TIMEC0)
C
               CALL RIUMP2TEIE2B(EIGA,EIGB,BB,BK,Q,E2S,NAUXBAS,NORBA,
     *              NORBB,NOCCA,NOCCB,NVIRA,NVIRB,IOCCBG,IOCCED,JOCCBG,
     *              JOCCED,TIME4,TIME5)
C
            END DO              !IBAT
C
         END DO                 !JPDIF
C
         J1BAT = (MYPROC-1)*NBATP1+JBATP1
         JOCCBG = INFOCCBBAT(1,J1BAT)+1
         JOCCED = INFOCCBBAT(1,J1BAT)+INFOCCBBAT(2,J1BAT)
         CALL TSECND(TIMEC0)
         CALL DDI_GET(D_TB,1,LENT3B,JOCCBG,JOCCED,BK)
         CALL TSECND(TIMEC1)
         TIMEC = TIMEC+(TIMEC1-TIMEC0)
         DO IBAT = IBATBG, IBATED
            IOCCBG = INFOCCABAT(1,IBAT)+1
            IOCCED = INFOCCABAT(1,IBAT)+INFOCCABAT(2,IBAT)
            CALL TSECND(TIMEC0)
            CALL DDI_GET(D_TA,1,LENT3A,IOCCBG,IOCCED,BB)
            CALL TSECND(TIMEC1)
            TIMEC = TIMEC+(TIMEC1-TIMEC0)
C
            CALL RIUMP2TEIE2B(EIGA,EIGB,BB,BK,Q,E2S,NAUXBAS,NORBA,NORBB,
     *           NOCCA,NOCCB,NVIRA,NVIRB,IOCCBG,IOCCED,JOCCBG,JOCCED,
     *           TIME4,TIME5)
C
         END DO                 !IBAT
      END DO                    !JBATP1
C
      IF(MASWRK) WRITE(IW,9999) TIMER,TIMEC,TIME4,TIME5
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 3/3 INTEGRAL READ           =    ',F9.1,
     *       /1X,'TIME OF 3/3 INTEGRAL NETWORK COMM.  =    ',F9.1,
     *       /1X,'TIME OF TEI GENERATION              =    ',F9.1,
     *       /1X,'TIME OF MP2 ENERGY ACCUMULATION     =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIUMP2E2ACCBP2SMP
      SUBROUTINE RIUMP2E2ACCBP2SMP(EIGA,EIGB,BB,BK,Q,INFOCCABAT,
     *     INFOCCBBAT,E2S,NAUXBAS,NORBA,NORBB,NOCCA,NOCCB,NVIRA,
     *     NVIRB,NOCCBAT,IW,
     *     DDI_NN,DDI_MY,SMP_NP,SMP_ME,D_TA,D_TB)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION EIGA(*),EIGB(*),BB(NAUXBAS,NVIRA,*),
     *     BK(NAUXBAS,NVIRB,*),Q(*)
      INTEGER INFOCCABAT(2,NOCCBAT),INFOCCBBAT(2,NOCCBAT)
C
      INTEGER DDI_NN,DDI_MY,SMP_NP,SMP_ME
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      INTEGER D_TA,D_TB
C
      PARAMETER (ZERO=0.0D+00)
C
C     GENERATE 4C-2E ERI FROM 3 INDICES INTERMEDIATE MATRICES
C     AND ACCUMULATE UMP2 CORRELATION ENERGY.
C     THIS SUBROUTINE IS FOR PARALLEL CALCULATIONS.
C
      TIMEC = ZERO
      TIME4 = ZERO
      TIME5 = ZERO
C
      LENT3A = NAUXBAS*NVIRA
      LENT3B = NAUXBAS*NVIRB
C
      MYNODE = DDI_MY+1
      NBATP1 = NOCCBAT/DDI_NN
C
      E2S = ZERO
      IBATBG = (MYNODE-1)*NBATP1+1
      IBATED = MYNODE*NBATP1
      DO JBATP1 = 1, NBATP1
         DO JPDIF = 1, DDI_NN-1
            J2NODE = MYNODE+JPDIF
            IF(J2NODE .GT. DDI_NN) J2NODE = J2NODE-DDI_NN
            J2BAT = (J2NODE-1)*NBATP1+JBATP1
            JOCCBG = INFOCCBBAT(1,J2BAT)+1
            JOCCED = INFOCCBBAT(1,J2BAT)+INFOCCBBAT(2,J2BAT)
            CALL TSECND(TIMEC0)
            IF(SMP_ME .EQ. 0)
     *           CALL DDI_GET(D_TB,1,LENT3B,JOCCBG,JOCCED,BK)
            CALL DDI_SMP_SYNC()
            CALL TSECND(TIMEC1)
            TIMEC = TIMEC+(TIMEC1-TIMEC0)
            DO IBAT = IBATBG, IBATED
               IOCCBG = INFOCCABAT(1,IBAT)+1
               IOCCED = INFOCCABAT(1,IBAT)+INFOCCABAT(2,IBAT)
               CALL TSECND(TIMEC0)
               IF(SMP_ME .EQ. 0)
     *              CALL DDI_GET(D_TA,1,LENT3A,IOCCBG,IOCCED,BB)
               CALL DDI_SMP_SYNC()
               CALL TSECND(TIMEC1)
               TIMEC = TIMEC+(TIMEC1-TIMEC0)
C
               CALL RIUMP2TEIE2BSMP(EIGA,EIGB,BB,BK,Q,E2S,NAUXBAS,
     *              NORBA,NORBB,NOCCA,NOCCB,NVIRA,NVIRB,
     *              IOCCBG,IOCCED,JOCCBG,JOCCED,
     *              TIME4,TIME5,SMP_NP,SMP_ME)
C
               CALL DDI_SMP_SYNC()
            END DO              !IBAT
C
         END DO                 !JPDIF
C
         J1BAT = (MYNODE-1)*NBATP1+JBATP1
         JOCCBG = INFOCCBBAT(1,J1BAT)+1
         JOCCED = INFOCCBBAT(1,J1BAT)+INFOCCBBAT(2,J1BAT)
         CALL TSECND(TIMEC0)
         IF(SMP_ME .EQ. 0)
     *        CALL DDI_GET(D_TB,1,LENT3B,JOCCBG,JOCCED,BK)
         CALL DDI_SMP_SYNC()
         CALL TSECND(TIMEC1)
         TIMEC = TIMEC+(TIMEC1-TIMEC0)
         DO IBAT = IBATBG, IBATED
            IOCCBG = INFOCCABAT(1,IBAT)+1
            IOCCED = INFOCCABAT(1,IBAT)+INFOCCABAT(2,IBAT)
            CALL TSECND(TIMEC0)
            IF(SMP_ME .EQ. 0)
     *           CALL DDI_GET(D_TA,1,LENT3A,IOCCBG,IOCCED,BB)
            CALL DDI_SMP_SYNC()
            CALL TSECND(TIMEC1)
            TIMEC = TIMEC+(TIMEC1-TIMEC0)
C
            CALL RIUMP2TEIE2BSMP(EIGA,EIGB,BB,BK,Q,E2S,NAUXBAS,
     *           NORBA,NORBB,NOCCA,NOCCB,NVIRA,NVIRB,
     *           IOCCBG,IOCCED,JOCCBG,JOCCED,
     *           TIME4,TIME5,SMP_NP,SMP_ME)
C
            CALL DDI_SMP_SYNC()
         END DO                 !IBAT
      END DO                    !JBATP1
C
      IF(MASWRK) WRITE(IW,9999) TIMEC,TIMEC,TIME4,TIME5
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 3/3 INTEGRAL NETWORK COMM.  =    ',F9.1,
     *       /1X,'TIME OF TEI GENERATION              =    ',F9.1,
     *       /1X,'TIME OF MP2 ENERGY ACCUMULATION     =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIUMP2E2ACCBP
      SUBROUTINE RIUMP2E2ACCBP(EIGA,EIGB,BB,BK1,BK2,Q,INFOCCABAT,
     *     INFOCCBBAT,E2S,NAUXBAS,NORBA,NORBB,NOCCA,NOCCB,NVIRA,
     *     NVIRB,NOCCBAT,LENOCCBBAT,IFILT3A,IFILT3B,IW)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION EIGA(*),EIGB(*),BB(NAUXBAS,NVIRA,*),
     *     BK1(NAUXBAS,NVIRB,*),BK2(NAUXBAS,NVIRB,*),Q(*)
      INTEGER INFOCCABAT(2,NOCCBAT),INFOCCBBAT(2,NOCCBAT)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ZERO=0.0D+00)
C
C     GENERATE 4C-2E ERI FROM 3 INDICES INTERMEDIATE MATRICES
C     AND ACCUMULATE MP2 CORRELATION ENERGY.
C     THIS SUBROUTINE IS FOR PARALLEL CALCULATIONS.
C
      TIMER = ZERO
      TIMEC = ZERO
      TIME4 = ZERO
      TIME5 = ZERO
C
      LENT3A = NAUXBAS*NVIRA
      LENT3B = NAUXBAS*NVIRB
      LENB = NAUXBAS*NVIRB*LENOCCBBAT
C
      MYPROC = ME+1
      NBATP1 = NOCCBAT/NPROC
C      WRITE(6,*) 'NPROC=',NPROC,'ME=',ME,'MYPROC=',MYPROC
C      WRITE(6,*) 'NOCCBAT=',NOCCBAT,'NBATP1=',NBATP1,'NBATP1C=',NBATP1C
C
      E2S = ZERO
      IBATBG = (MYPROC-1)*NBATP1+1
      IBATED = MYPROC*NBATP1
      DO JBATP1 = 1, NBATP1
         J1BAT = (MYPROC-1)*NBATP1+JBATP1
         J1OCCBG = INFOCCBBAT(1,J1BAT)+1
         J1OCCED = INFOCCBBAT(1,J1BAT)+INFOCCBBAT(2,J1BAT)
         CALL TSECND(TIMER0)
         DO JOCC = J1OCCBG, J1OCCED
            J = JOCC-J1OCCBG+1
            CALL RIMP2T3RD(BK1(1,1,J),LENT3B,IFILT3B,JOCC)
         END DO
         CALL TSECND(TIMER1)
         TIMER = TIMER+(TIMER1-TIMER0)
         DO JPDIF = 1, NPROC-1
            J1PROC = MYPROC-JPDIF
            J2PROC = MYPROC+JPDIF
            IF(J1PROC .LE. 0)     J1PROC = J1PROC+NPROC
            IF(J2PROC .GT. NPROC) J2PROC = J2PROC-NPROC
            J1RANK = J1PROC-1
            J2RANK = J2PROC-1
            CALL TSECND(TIMEC0)
            CALL DDI_ISEND(BK1,8*LENB,J1RANK,IREQ1)
            CALL DDI_IRECV(BK2,8*LENB,J2RANK,IREQ2)
            CALL DDI_WAIT(IREQ1)
            CALL DDI_WAIT(IREQ2)
            CALL TSECND(TIMEC1)
            TIMEC = TIMEC+(TIMEC1-TIMEC0)
            J2BAT = (J2PROC-1)*NBATP1+JBATP1
            JOCCBG = INFOCCBBAT(1,J2BAT)+1
            JOCCED = INFOCCBBAT(1,J2BAT)+INFOCCBBAT(2,J2BAT)
            DO IBAT = IBATBG, IBATED
               IOCCBG = INFOCCABAT(1,IBAT)+1
               IOCCED = INFOCCABAT(1,IBAT)+INFOCCABAT(2,IBAT)
               CALL TSECND(TIMER0)
               DO IOCC = IOCCBG, IOCCED
                  I = IOCC-IOCCBG+1
                  CALL RIMP2T3RD(BB(1,1,I),LENT3A,IFILT3A,IOCC)
               END DO
               CALL TSECND(TIMER1)
               TIMER = TIMER+(TIMER1-TIMER0)
C
               CALL RIUMP2TEIE2B(EIGA,EIGB,BB,BK2,Q,E2S,NAUXBAS,NORBA,
     *              NORBB,NOCCA,NOCCB,NVIRA,NVIRB,IOCCBG,IOCCED,JOCCBG,
     *              JOCCED,TIME4,TIME5)
C
            END DO              !IBAT
C
         END DO                 !JPDIF
C
         JOCCBG = J1OCCBG
         JOCCED = J1OCCED
         DO IBAT = IBATBG, IBATED
            IOCCBG = INFOCCABAT(1,IBAT)+1
            IOCCED = INFOCCABAT(1,IBAT)+INFOCCABAT(2,IBAT)
C            WRITE(6,*) 'IBAT=',IBAT,'IOCCBG=',IOCCBG,'IOCCED=',IOCCED
            CALL TSECND(TIMER0)
            DO IOCC = IOCCBG, IOCCED
               I = IOCC-IOCCBG+1
               CALL RIMP2T3RD(BB(1,1,I),LENT3A,IFILT3A,IOCC)
            END DO
            CALL TSECND(TIMER1)
            TIMER = TIMER+(TIMER1-TIMER0)
C
            CALL RIUMP2TEIE2B(EIGA,EIGB,BB,BK1,Q,E2S,NAUXBAS,NORBA,
     *           NORBB,NOCCA,NOCCB,NVIRA,NVIRB,IOCCBG,IOCCED,JOCCBG,
     *           JOCCED,TIME4,TIME5)
C
         END DO                 !IBAT
      END DO                    !JBATP1
C
      IF(MASWRK) WRITE(IW,9999) TIMER,TIMEC,TIME4,TIME5
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 3/3 INTEGRAL READ           =    ',F9.1,
     *       /1X,'TIME OF 3/3 INTEGRAL NETWORK COMM.  =    ',F9.1,
     *       /1X,'TIME OF TEI GENERATION              =    ',F9.1,
     *       /1X,'TIME OF MP2 ENERGY ACCUMULATION     =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIUMP2E2ACCBPSMP
      SUBROUTINE RIUMP2E2ACCBPSMP(EIGA,EIGB,BB,BK1,BK2,Q,INFOCCABAT,
     *     INFOCCBBAT,E2S,NAUXBAS,NORBA,NORBB,NOCCA,NOCCB,NVIRA,
     *     NVIRB,NOCCBAT,LENOCCBBAT,IFILT3A,IFILT3B,IW,
     *     DDI_NN,DDI_MY,SMP_NP,SMP_ME)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION EIGA(*),EIGB(*),BB(NAUXBAS,NVIRA,*),
     *     BK1(NAUXBAS,NVIRB,*),BK2(NAUXBAS,NVIRB,*),Q(*)
      INTEGER INFOCCABAT(2,NOCCBAT),INFOCCBBAT(2,NOCCBAT)
C
      INTEGER DDI_NN,DDI_MY,SMP_NP,SMP_ME
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ZERO=0.0D+00)
C
C     GENERATE 4C-2E ERI FROM 3 INDICES INTERMEDIATE MATRICES
C     AND ACCUMULATE UMP2 CORRELATION ENERGY.
C     THIS SUBROUTINE IS FOR PARALLEL CALCULATIONS.
C
      TIMER = ZERO
      TIMEC = ZERO
      TIME4 = ZERO
      TIME5 = ZERO
C
      LENT3A = NAUXBAS*NVIRA
      LENT3B = NAUXBAS*NVIRB
      LENB = NAUXBAS*NVIRB*LENOCCBBAT
C
      MYNODE = DDI_MY+1
      NBATP1 = NOCCBAT/DDI_NN
C
      E2S = ZERO
      IBATBG = (MYNODE-1)*NBATP1+1
      IBATED = MYNODE*NBATP1
      DO JBATP1 = 1, NBATP1
         J1BAT = (MYNODE-1)*NBATP1+JBATP1
         J1OCCBG = INFOCCBBAT(1,J1BAT)+1
         J1OCCED = INFOCCBBAT(1,J1BAT)+INFOCCBBAT(2,J1BAT)
         CALL TSECND(TIMER0)
         IF(SMP_ME .EQ. 0) THEN
            DO JOCC = J1OCCBG, J1OCCED
               J = JOCC-J1OCCBG+1
               CALL RIMP2T3RD(BK1(1,1,J),LENT3B,IFILT3B,JOCC)
            END DO
         END IF
         CALL DDI_SMP_SYNC()
         CALL TSECND(TIMER1)
         TIMER = TIMER+(TIMER1-TIMER0)
         DO JPDIF = 1, DDI_NN-1
            J1NODE = MYNODE-JPDIF
            J2NODE = MYNODE+JPDIF
            IF(J1NODE .LE. 0)      J1NODE = J1NODE+DDI_NN
            IF(J2NODE .GT. DDI_NN) J2NODE = J2NODE-DDI_NN
            CALL TSECND(TIMEC0)
            IF(SMP_ME .EQ. 0) THEN
               J1RANK = (J1NODE-1)*SMP_NP
               J2RANK = (J2NODE-1)*SMP_NP
               CALL DDI_ISEND(BK1,8*LENB,J1RANK,IREQ1)
               CALL DDI_IRECV(BK2,8*LENB,J2RANK,IREQ2)
               CALL DDI_WAIT(IREQ1)
               CALL DDI_WAIT(IREQ2)
            END IF
            CALL DDI_SMP_SYNC()
            CALL TSECND(TIMEC1)
            TIMEC = TIMEC+(TIMEC1-TIMEC0)
            J2BAT = (J2NODE-1)*NBATP1+JBATP1
            JOCCBG = INFOCCBBAT(1,J2BAT)+1
            JOCCED = INFOCCBBAT(1,J2BAT)+INFOCCBBAT(2,J2BAT)
            DO IBAT = IBATBG, IBATED
               IOCCBG = INFOCCABAT(1,IBAT)+1
               IOCCED = INFOCCABAT(1,IBAT)+INFOCCABAT(2,IBAT)
               CALL TSECND(TIMER0)
               IF(SMP_ME .EQ. 0) THEN
                  DO IOCC = IOCCBG, IOCCED
                     I = IOCC-IOCCBG+1
                     CALL RIMP2T3RD(BB(1,1,I),LENT3A,IFILT3A,IOCC)
                  END DO
               END IF
               CALL DDI_SMP_SYNC()
               CALL TSECND(TIMER1)
               TIMER = TIMER+(TIMER1-TIMER0)
C
               CALL RIUMP2TEIE2BSMP(EIGA,EIGB,BB,BK2,Q,E2S,NAUXBAS,
     *              NORBA,NORBB,NOCCA,NOCCB,NVIRA,NVIRB,
     *              IOCCBG,IOCCED,JOCCBG,JOCCED,
     *              TIME4,TIME5,SMP_NP,SMP_ME)
C
               CALL DDI_SMP_SYNC()
            END DO              !IBAT
C
         END DO                 !JPDIF
C
         JOCCBG = J1OCCBG
         JOCCED = J1OCCED
         DO IBAT = IBATBG, IBATED
            IOCCBG = INFOCCABAT(1,IBAT)+1
            IOCCED = INFOCCABAT(1,IBAT)+INFOCCABAT(2,IBAT)
            CALL TSECND(TIMER0)
            IF(SMP_ME .EQ. 0) THEN
               DO IOCC = IOCCBG, IOCCED
                  I = IOCC-IOCCBG+1
                  CALL RIMP2T3RD(BB(1,1,I),LENT3A,IFILT3A,IOCC)
               END DO
            END IF
            CALL DDI_SMP_SYNC()
            CALL TSECND(TIMER1)
            TIMER = TIMER+(TIMER1-TIMER0)
C
            CALL RIUMP2TEIE2BSMP(EIGA,EIGB,BB,BK1,Q,E2S,NAUXBAS,
     *           NORBA,NORBB,NOCCA,NOCCB,NVIRA,NVIRB,
     *           IOCCBG,IOCCED,JOCCBG,JOCCED,
     *           TIME4,TIME5,SMP_NP,SMP_ME)
C
            CALL DDI_SMP_SYNC()
         END DO                 !IBAT
      END DO                    !JBATP1
C
      IF(MASWRK) WRITE(IW,9999) TIMER,TIMEC,TIME4,TIME5
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 3/3 INTEGRAL READ           =    ',F9.1,
     *       /1X,'TIME OF 3/3 INTEGRAL NETWORK COMM.  =    ',F9.1,
     *       /1X,'TIME OF TEI GENERATION              =    ',F9.1,
     *       /1X,'TIME OF MP2 ENERGY ACCUMULATION     =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIUMP2E2ACCBSMP
      SUBROUTINE RIUMP2E2ACCBSMP(EIGA,EIGB,BB,BK,Q,INFOCCABAT,
     *     INFOCCBBAT,E2S,NAUXBAS,NORBA,NORBB,NOCCA,NOCCB,NVIRA,NVIRB,
     *     NOCCBAT,IFILT3A,IFILT3B,IW,MASWRK,SMP_NP,SMP_ME,USEDM,
     *     D_TA,D_TB)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL MASWRK
      LOGICAL USEDM
C
      DOUBLE PRECISION EIGA(*),EIGB(*),BB(NAUXBAS,NVIRA,*),
     *     BK(NAUXBAS,NVIRB,*),Q(*)
      INTEGER INFOCCABAT(2,NOCCBAT),INFOCCBBAT(2,NOCCBAT)
C
      INTEGER SMP_NP,SMP_ME
C
      INTEGER D_TA,D_TB
C
      PARAMETER (ZERO=0.0D+00)
C
C     GENERATE 4C-2E ERI FROM 3 INDICES INTERMEDIATE MATRICES
C     AND ACCUMULATE MP2 CORRELATION ENERGY.
C
      TIMER = ZERO
      TIME4 = ZERO
      TIME5 = ZERO
C
      LENT3A = NAUXBAS*NVIRA
      LENT3B = NAUXBAS*NVIRB
C
      E2S = ZERO
      DO JBAT = 1, NOCCBAT
         JOCCBG = INFOCCBBAT(1,JBAT)+1
         JOCCED = INFOCCBBAT(1,JBAT)+INFOCCBBAT(2,JBAT)
         CALL TSECND(TIMER0)
         IF(SMP_ME .EQ. 0) THEN
            IF(.NOT. USEDM) THEN
               DO JOCC = JOCCBG, JOCCED
                  J = JOCC-JOCCBG+1
                  CALL RIMP2T3RD(BK(1,1,J),LENT3B,IFILT3B,JOCC)
               END DO
            ELSE
               CALL DDI_GET(D_TB,1,LENT3B,JOCCBG,JOCCED,BK)
            END IF
         END IF
         CALL DDI_SMP_SYNC()
         CALL TSECND(TIMER1)
         TIMER = TIMER+(TIMER1-TIMER0)
         DO IBAT = 1, NOCCBAT
            IOCCBG = INFOCCABAT(1,IBAT)+1
            IOCCED = INFOCCABAT(1,IBAT)+INFOCCABAT(2,IBAT)
            CALL TSECND(TIMER0)
            IF(SMP_ME .EQ. 0) THEN
               IF(.NOT. USEDM) THEN
                  DO IOCC = IOCCBG, IOCCED
                     I = IOCC-IOCCBG+1
                     CALL RIMP2T3RD(BB(1,1,I),LENT3A,IFILT3A,IOCC)
                  END DO
               ELSE
                  CALL DDI_GET(D_TA,1,LENT3A,IOCCBG,IOCCED,BB)
               END IF
            END IF
            CALL DDI_SMP_SYNC()
            CALL TSECND(TIMER1)
            TIMER = TIMER+(TIMER1-TIMER0)
C
            CALL RIUMP2TEIE2BSMP(EIGA,EIGB,BB,BK,Q,E2S,NAUXBAS,
     *           NORBA,NORBB,NOCCA,NOCCB,NVIRA,NVIRB,
     *           IOCCBG,IOCCED,JOCCBG,JOCCED,
     *           TIME4,TIME5,SMP_NP,SMP_ME)
C
            CALL DDI_SMP_SYNC()
         END DO                 !IBAT
      END DO                    !JBAT
C
      IF(MASWRK) WRITE(IW,9999) TIMER,TIME4,TIME5
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 3/3 INTEGRAL READ           =    ',F9.1,
     *       /1X,'TIME OF TEI GENERATION              =    ',F9.1,
     *       /1X,'TIME OF MP2 ENERGY ACCUMULATION     =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIUMP2E2A
      SUBROUTINE RIUMP2E2A(EIG,Q,E2T,NORB,NOCC,NVIR,IOCC,JOCC)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION EIG(NORB),Q(NVIR,NVIR)
C
C     ACCUMULATE MP2 CORRELATION ENERGY
C
      DO JVIR = 1, NVIR
         DO IVIR = 1, NVIR
            T2 = Q(IVIR,JVIR)
     *           /(EIG(IOCC)+EIG(JOCC)-EIG(NOCC+IVIR)-EIG(NOCC+JVIR))
            E2T = E2T+T2*(Q(IVIR,JVIR)-Q(JVIR,IVIR))
         END DO
      END DO
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIUMP2E2ASMP
      SUBROUTINE RIUMP2E2ASMP(EIG,Q,E2T,NORB,NOCC,NVIR,IOCC,JOCC,
     *     SMP_NP,SMP_ME)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION EIG(NORB),Q(NVIR,NVIR)
C
      INTEGER SMP_NP,SMP_ME
      INTEGER NR,SR
C
C     ACCUMULATE MP2 CORRELATION ENERGY
C
      CALL DIV_EVEN(NVIR,SMP_NP,SMP_ME,NR,SR)
      DO JVIR = SR, SR+NR-1
         DO IVIR = 1, NVIR
            T2 = Q(IVIR,JVIR)
     *           /(EIG(IOCC)+EIG(JOCC)-EIG(NOCC+IVIR)-EIG(NOCC+JVIR))
            E2T = E2T+T2*(Q(IVIR,JVIR)-Q(JVIR,IVIR))
         END DO
      END DO
      CALL DDI_SMP_SYNC()
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIUMP2E2B
      SUBROUTINE RIUMP2E2B(EIGA,EIGB,Q,E2S,NORBA,NORBB,NOCCA,NOCCB,
     *     NVIRA,NVIRB,IOCC,JOCC)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION EIGA(NORBA),EIGB(NORBB),Q(NVIRA,NVIRB)
C
C     ACCUMULATE MP2 CORRELATION ENERGY
C
      DO JVIR = 1, NVIRB
         DO IVIR = 1, NVIRA
            T2 = Q(IVIR,JVIR)
     *           /(EIGA(IOCC)+EIGB(JOCC)
     *           -EIGA(NOCCA+IVIR)-EIGB(NOCCB+JVIR))
            E2S = E2S+T2*Q(IVIR,JVIR)
         END DO
      END DO
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIUMP2E2BSMP
      SUBROUTINE RIUMP2E2BSMP(EIGA,EIGB,Q,E2S,NORBA,NORBB,NOCCA,NOCCB,
     *     NVIRA,NVIRB,IOCC,JOCC,SMP_NP,SMP_ME)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION EIGA(NORBA),EIGB(NORBB),Q(NVIRA,NVIRB)
C
      INTEGER SMP_NP,SMP_ME
      INTEGER NR,SR
C
C     ACCUMULATE MP2 CORRELATION ENERGY
C
      CALL DIV_EVEN(NVIRB,SMP_NP,SMP_ME,NR,SR)
      DO JVIR = SR, SR+NR-1
         DO IVIR = 1, NVIRA
            T2 = Q(IVIR,JVIR)
     *           /(EIGA(IOCC)+EIGB(JOCC)
     *           -EIGA(NOCCA+IVIR)-EIGB(NOCCB+JVIR))
            E2S = E2S+T2*Q(IVIR,JVIR)
         END DO
      END DO
      CALL DDI_SMP_SYNC()
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIUMP2INTTR1
      SUBROUTINE RIUMP2INTTR1(VECA,VECB,CC,T0,T1,T2,TL,
     *     LOCSPH,INFOCCABAT,INFOCCBBAT,NT2ABUF,NT2BBUF,
     *     NSHELL,NBASIS,NAUXSH,NOCCA,NOCCB,
     *     NVIRA,NVIRB,NINTMXA,NINTMXB,NOCCBAT,
     *     IFILT2A,IFILT2B,IW,SPHAUX,USEDM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL SPHAUX,USEDM
      LOGICAL SLB,DLB
      LOGICAL NORM
C
      DOUBLE PRECISION VECA(NBASIS,*),VECB(NBASIS,*),CC(3,3),
     *     T0(NBASIS,NBASIS,*),T1(*),T2(*),TL(*)
      INTEGER LOCSPH(*),INFOCCABAT(*),INFOCCBBAT(*),
     *     NT2ABUF(*),NT2BBUF(*)
C
      PARAMETER (MXATM=2000)
      PARAMETER (MXAUXSH=10000, MXAXGTOT=20000)
C
      COMMON /AUXBAS/ EXAUX(MXAXGTOT),CAUXS(MXAXGTOT),CAUXP(MXAXGTOT),
     *                CAUXD(MXAXGTOT),CAUXF(MXAXGTOT),CAUXG(MXAXGTOT),
     *                CAUXH(MXAXGTOT),CAUXI(MXAXGTOT),
     *                KAUXST(MXAUXSH),KAUXAT(MXAUXSH),KAUXTY(MXAUXSH),
     *                KAUXNG(MXAUXSH),KAUXLO(MXAUXSH),KAUXMI(MXAUXSH),
     *                KAUXMX(MXAUXSH),NAUXSHX
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER D_V,D_TA,D_TB
      COMMON /RIMPDD/ D_V,D_TA,D_TB
C
      PARAMETER (ZERO=0.0D+00)
C
C     PERFORM ERI EVALUATION AND FIRST 1/3 AND 2/3 TRANSFORMATION
C     THIS SUBROUTINE IS FOR UMP2 CALCULATIONS.
C
      TIME0  = ZERO
      TIME1A = ZERO
      TIME1B = ZERO
      TIME2A = ZERO
      TIME2B = ZERO
      TIMEWA = ZERO
      TIMEWB = ZERO
C
      NORM = NORMF .NE. 1 .OR. NORMP .NE. 1
C
C     ----- INITIALIZATION FOR PARALLEL WORK -----
C     STATIC AND DYNAMIC LOAD BALANCING IS IMPLEMENTED BELOW,
C     BUT THE FORMER DOESN'T SEEM TO WORK IF FORCED IN THE INPUT.
C
      SLB = GOPARR .AND. IBTYP .EQ. 0
      DLB = GOPARR .AND. IBTYP .EQ. 1
      SLB = .FALSE.
      DLB = .TRUE.
      NEXT = -1
      MINE = -1
      IPCOUNT = 0
C
      NRECT2A = 0
      NRECT2B = 0
      DO IBAT = 1, 2*NOCCBAT
         NT2ABUF(IBAT) = 0
      END DO
      DO IBAT = 1, 2*NOCCBAT
         NT2BBUF(IBAT) = 0
      END DO
C
      DO LAUXSH = 1, NAUXSH
         LAT = KAUXAT(LAUXSH)
         CC(1,3) = C(1,LAT)
         CC(2,3) = C(2,LAT)
         CC(3,3) = C(3,LAT)
         LANGL = KAUXTY(LAUXSH)-1
         MINL  = KAUXMI(LAUXSH)
         MAXL  = KAUXMX(LAUXSH)
         NL    = MAXL-MINL+1
         NGL   = KAUXNG(LAUXSH)
         L1    = KAUXST(LAUXSH)
         LOCL  = KAUXLO(LAUXSH)-MINL
         IF(SPHAUX) THEN
            CALL RIMP2CSTRM(TL,LANGL,MINL,NL,MINLS,MAXLS)
            LOCLS = LOCSPH(LAUXSH)-MINLS
            NLS = MAXLS-MINLS+1
            MINLT = MINLS
            MAXLT = MAXLS
            LOCLT = LOCLS
         ELSE
            MINLT = MINL
            MAXLT = MAXL
            LOCLT = LOCL
         END IF
C
C     ----- GO PARALLEL! -----
C
         IF(SLB) THEN
            IPCOUNT = IPCOUNT + 1
            IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 900
         END IF
         IF(DLB) THEN
            MINE = MINE+1
            IF (MINE .GT. NEXT) CALL DDI_DLBNEXT(NEXT)
            IF (NEXT .NE. MINE) GO TO 900
         END IF
C
C        3C-2E ERI EVALUATION
C
         CALL TSECND(TIME00)
         CALL RIMP2T0GEN(CC,T0,T2,TL,T1,NSHELL,NBASIS,
     *        LANGL,MINL,MAXL,NL,NGL,L1,MINLS,MAXLS,NLS,SPHAUX,NORM)
         CALL TSECND(TIME01)
         TIME0 = TIME0+(TIME01-TIME00)
C
         LL = 0
         DO L = MINLT, MAXLT
            LL = LL+1
            LAUX = LOCLT+L
C
C           1/3 AND 2/3 INTEGRAL TRANSFORMATION AND
C           STORE 2/3 TRANSFORMED INTEGRAL MATRIX T2 (ALPHA)
C
            CALL RIMP2INTTRT02(VECA,T0(1,1,LL),T1,T2,INFOCCABAT,NT2ABUF,
     *           NBASIS,NOCCA,NVIRA,NINTMXA,NOCCBAT,IFILT2A,NRECT2A,
     *           D_TA,LAUX,USEDM,TIME1A,TIME2A,TIMEWA)
C
C           1/3 AND 2/3 INTEGRAL TRANSFORMATION AND
C           STORE 2/3 TRANSFORMED INTEGRAL MATRIX T2 (BETA)
C
            CALL RIMP2INTTRT02(VECB,T0(1,1,LL),T1,T2,INFOCCBBAT,NT2BBUF,
     *           NBASIS,NOCCB,NVIRB,NINTMXB,NOCCBAT,IFILT2B,NRECT2B,
     *           D_TB,LAUX,USEDM,TIME1B,TIME2B,TIMEWB)
C
         END DO                 !LL
  900    CONTINUE
      END DO                    !LAUXSH
C
      IF(DLB) CALL DDI_DLBRESET
C
      IF(MASWRK) WRITE(IW,9999) TIME0,TIME1A,TIME1B,TIME2A,TIME2B,
     *     TIMEWA,TIMEWB
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 3C-2E INTEGRAL GENERATION   =    ',F9.1,
     *       /1X,'TIME OF 1/3 INTEGRAL TRANSFORMATIONA=    ',F9.1,
     *       /1X,'TIME OF 1/3 INTEGRAL TRANSFORMATIONB=    ',F9.1,
     *       /1X,'TIME OF 2/3 INTEGRAL TRANSFORMATIONA=    ',F9.1,
     *       /1X,'TIME OF 2/3 INTEGRAL TRANSFORMATIONB=    ',F9.1,
     *       /1X,'TIME OF 2/3 INTEGRAL WRITEA         =    ',F9.1,
     *       /1X,'TIME OF 2/3 INTEGRAL WRITEB         =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIUMP2INTTR1SMP
      SUBROUTINE RIUMP2INTTR1SMP(VECA,VECB,CC,T0,T1,T2,T2BUFF,
     *     GHONDO,TL,W,LOCSPH,INFOCCABAT,INFOCCBBAT,NT2ABUF,NT2BBUF,
     *     NSHELL,NBASIS,NAUXSH,NOCCA,NOCCB,
     *     NVIRA,NVIRB,NINTMXA,NINTMXB,NOCCBAT,
     *     IFILT2A,IFILT2B,IW,SPHAUX,USEDM,
     *     DDI_NN,DDI_MY,SMP_NP,SMP_ME)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL SPHAUX,USEDM
      LOGICAL SLB
      LOGICAL NORM
C
C                ALLOCATED FROM SHARED MEMORY
      DOUBLE PRECISION T0(NBASIS,NBASIS,*),T1(*),T2(*)
      INTEGER NT2ABUF(*),NT2BBUF(*)
C                ALLOCATED FROM REPLICATED MEMORY
      DOUBLE PRECISION VECA(*),VECB(*),CC(3,3),GHONDO(*),TL(*),W(*),
     *                 T2BUFF(*)
      INTEGER LOCSPH(*),INFOCCABAT(*),INFOCCBBAT(*)
C
      INTEGER DDI_NN,DDI_MY,SMP_NP,SMP_ME
C
      PARAMETER (MXATM=2000)
      PARAMETER (MXAUXSH=10000, MXAXGTOT=20000)
C
      COMMON /AUXBAS/ EXAUX(MXAXGTOT),CAUXS(MXAXGTOT),CAUXP(MXAXGTOT),
     *                CAUXD(MXAXGTOT),CAUXF(MXAXGTOT),CAUXG(MXAXGTOT),
     *                CAUXH(MXAXGTOT),CAUXI(MXAXGTOT),
     *                KAUXST(MXAUXSH),KAUXAT(MXAUXSH),KAUXTY(MXAUXSH),
     *                KAUXNG(MXAUXSH),KAUXLO(MXAUXSH),KAUXMI(MXAUXSH),
     *                KAUXMX(MXAUXSH),NAUXSHX
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER D_V,D_TA,D_TB
      COMMON /RIMPDD/ D_V,D_TA,D_TB
C
      PARAMETER (ZERO=0.0D+00)
C
C     PERFORM ERI EVALUATION AND FIRST 1/3 AND 2/3 TRANSFORMATION
C     THIS SUBROUTINE IS FOR UMP2 CALCULATIONS.
C
      TIME0  = ZERO
      TIME1A = ZERO
      TIME1B = ZERO
      TIME2A = ZERO
      TIME2B = ZERO
      TIMEWA = ZERO
      TIMEWB = ZERO
C
      NORM = NORMF .NE. 1 .OR. NORMP .NE. 1
C
C     ----- INITIALIZATION FOR PARALLEL WORK -----
C     ONLY STATIC LOAD BALANCING IS IMPLEMENTED BELOW
C
      SLB = .TRUE.
      IPCOUNT = 0
C
      NRECT2A = 0
      NRECT2B = 0
      IF(SMP_ME .EQ. 0) THEN
         DO IBAT = 1, 2*NOCCBAT
            NT2ABUF(IBAT) = 0
         END DO
         DO IBAT = 1, 2*NOCCBAT
            NT2BBUF(IBAT) = 0
         END DO
      END IF
      CALL DDI_SMP_SYNC()
C
      DO LAUXSH = 1, NAUXSH
         LAT = KAUXAT(LAUXSH)
         CC(1,3) = C(1,LAT)
         CC(2,3) = C(2,LAT)
         CC(3,3) = C(3,LAT)
         LANGL = KAUXTY(LAUXSH)-1
         MINL  = KAUXMI(LAUXSH)
         MAXL  = KAUXMX(LAUXSH)
         NL    = MAXL-MINL+1
         NGL   = KAUXNG(LAUXSH)
         L1    = KAUXST(LAUXSH)
         LOCL  = KAUXLO(LAUXSH)-MINL
         IF(SPHAUX) THEN
            CALL RIMP2CSTRM(TL,LANGL,MINL,NL,MINLS,MAXLS)
            LOCLS = LOCSPH(LAUXSH)-MINLS
            NLS   = MAXLS-MINLS+1
            MINLT = MINLS
            MAXLT = MAXLS
            LOCLT = LOCLS
         ELSE
            MINLT = MINL
            MAXLT = MAXL
            LOCLT = LOCL
         END IF
C
C        ----- GO PARALLEL! -----
C
         IF(SLB) THEN
            IPCOUNT = IPCOUNT + 1
            IF (MOD(IPCOUNT,DDI_NN) .NE. DDI_MY) GO TO 900
         END IF
C
C        3C-2E ERI EVALUATION
C
         CALL TSECND(TIME00)
         CALL RIMP2T0GENSMP(CC,T0,GHONDO,TL,W,NSHELL,NBASIS,LANGL,MINL,
     *        MAXL,NL,NGL,L1,MINLS,MAXLS,NLS,SPHAUX,NORM,SMP_NP,SMP_ME)
         CALL DDI_SMP_SYNC()
         CALL TSECND(TIME01)
         TIME0 = TIME0+(TIME01-TIME00)
C
         LL = 0
         DO L = MINLT, MAXLT
            LL = LL+1
            LAUX = LOCLT+L
C
C           1/3 AND 2/3 INTEGRAL TRANSFORMATION AND
C           STORE 2/3 TRANSFORMED INTEGRAL MATRIX T2 (ALPHA)
C
            CALL RIMP2INTTRT02SMP(VECA,T0(1,1,LL),T1,T2,T2BUFF,
     *           INFOCCABAT,NT2ABUF,NBASIS,NOCCA,NVIRA,NINTMXA,
     *           NOCCBAT,IFILT2A,NRECT2A,D_TA,LAUX,USEDM,
     *           TIME1A,TIME2A,TIMEWA,SMP_NP,SMP_ME)
C
C           1/3 AND 2/3 INTEGRAL TRANSFORMATION AND
C           STORE 2/3 TRANSFORMED INTEGRAL MATRIX T2 (BETA)
C
            CALL RIMP2INTTRT02SMP(VECB,T0(1,1,LL),T1,T2,T2BUFF,
     *           INFOCCBBAT,NT2BBUF,NBASIS,NOCCB,NVIRB,NINTMXB,
     *           NOCCBAT,IFILT2B,NRECT2B,D_TB,LAUX,USEDM,
     *           TIME1B,TIME2B,TIMEWB,SMP_NP,SMP_ME)
C
         END DO                 !LL
  900    CONTINUE
      END DO                    !LAUXSH
C
      IF(MASWRK) WRITE(IW,9999) TIME0,TIME1A,TIME1B,TIME2A,TIME2B,
     *     TIMEWA,TIMEWB
      CALL FLSHBF(IW)
      RETURN
C
 9999 FORMAT(/1X,'TIME OF 3C-2E INTEGRAL GENERATION   =    ',F9.1,
     *       /1X,'TIME OF 1/3 INTEGRAL TRANSFORMATIONA=    ',F9.1,
     *       /1X,'TIME OF 1/3 INTEGRAL TRANSFORMATIONB=    ',F9.1,
     *       /1X,'TIME OF 2/3 INTEGRAL TRANSFORMATIONA=    ',F9.1,
     *       /1X,'TIME OF 2/3 INTEGRAL TRANSFORMATIONB=    ',F9.1,
     *       /1X,'TIME OF 2/3 INTEGRAL WRITEA         =    ',F9.1,
     *       /1X,'TIME OF 2/3 INTEGRAL WRITEB         =    ',F9.1)
      END
C*MODULE RIMP2   *DECK RIUMP2TEIE2A
      SUBROUTINE RIUMP2TEIE2A(EIG,BB,BK,Q,E2T,NAUXBAS,NORB,NOCC,NVIR,
     *     IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,JBAT,TIME4,TIME5)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION EIG(*),BB(NAUXBAS,NVIR,*),BK(NAUXBAS,NVIR,*),Q(*)
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00, TWO=2.0D+00)
C
      DO JOCC = JOCCBG, JOCCED
         J = JOCC-JOCCBG+1
         IF(IBAT .EQ. JBAT) IOCCED = JOCC
         DO IOCC = IOCCBG, IOCCED
            I = IOCC-IOCCBG+1
C
C           4C-2E ERI (IA|JB) GENERATION FROM 3C-2E ERIS
C           (IA|L) AND (IJ|L)
C
            CALL TSECND(TIME40)
            CALL RIMP2TEI(BB(1,1,I),BK(1,1,J),Q,NAUXBAS,NVIR,NVIR)
            CALL TSECND(TIME41)
            TIME4 = TIME4+(TIME41-TIME40)
C
C           MP2 CORRELATION ENERGY EVALUATION
C
            CALL TSECND(TIME50)
            E2TP = ZERO
            CALL RIUMP2E2A(EIG,Q,E2TP,NORB,NOCC,NVIR,IOCC,JOCC)
            IF(IOCC .NE. JOCC) THEN
               FAC = TWO
            ELSE
               FAC = ONE
            END IF
C           WRITE(6,*) 'IOCC=',IOCC,'JOCC=',JOCC,'E2TP=',E2TP
            E2T = E2T+FAC*E2TP
            CALL TSECND(TIME51)
            TIME5 = TIME5+(TIME51-TIME50)
C
         END DO                 !IOCC
      END DO                    !JOCC
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIMP2TEIE2ASMP
      SUBROUTINE RIUMP2TEIE2ASMP(EIG,BB,BK,Q,E2T,NAUXBAS,NORB,NOCC,NVIR,
     *     IOCCBG,IOCCED,JOCCBG,JOCCED,IBAT,JBAT,TIME4,TIME5,
     *     SMP_NP,SMP_ME)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION EIG(*),BB(NAUXBAS,NVIR,*),BK(NAUXBAS,NVIR,*),Q(*)
C
      INTEGER SMP_NP,SMP_ME
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00, TWO=2.0D+00)
C
      DO JOCC = JOCCBG, JOCCED
         J = JOCC-JOCCBG+1
         IF(JBAT .EQ. IBAT) IOCCED = JOCC
         DO IOCC = IOCCBG, IOCCED
            I = IOCC-IOCCBG+1
C
C           4C-2E ERI (IA|JB) GENERATION FROM 3C-2E ERIS
C           (IA|L) AND (IJ|L)
C
            CALL TSECND(TIME40)
            CALL RIMP2TEISMP(BB(1,1,I),BK(1,1,J),Q,NAUXBAS,NVIR,NVIR,
     *           SMP_NP,SMP_ME)
            CALL TSECND(TIME41)
            TIME4 = TIME4+(TIME41-TIME40)
C
C           MP2 CORRELATION ENERGY EVALUATION
C
            CALL TSECND(TIME50)
            E2TP = ZERO
            CALL RIUMP2E2ASMP(EIG,Q,E2TP,NORB,NOCC,NVIR,
     *           IOCC,JOCC,SMP_NP,SMP_ME)
            IF(IOCC .NE. JOCC) THEN
               FAC = TWO
            ELSE
               FAC = ONE
            END IF
            E2T = E2T+FAC*E2TP
            CALL TSECND(TIME51)
            TIME5 = TIME5+(TIME51-TIME50)
C
         END DO                 !IOCC
      END DO                    !JOCC
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIUMP2TEIE2B
      SUBROUTINE RIUMP2TEIE2B(EIGA,EIGB,BB,BK,Q,E2S,NAUXBAS,NORBA,NORBB,
     *     NOCCA,NOCCB,NVIRA,NVIRB,IOCCBG,IOCCED,JOCCBG,JOCCED,
     *     TIME4,TIME5)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION EIGA(*),EIGB(*),BB(NAUXBAS,NVIRA,*),
     *     BK(NAUXBAS,NVIRB,*),Q(*)
C
      PARAMETER (ZERO=0.0D+00)
C
      DO JOCC = JOCCBG, JOCCED
         J = JOCC-JOCCBG+1
         DO IOCC = IOCCBG, IOCCED
            I = IOCC-IOCCBG+1
C
C           4C-2E ERI (IA|JB) GENERATION
C
            CALL TSECND(TIME40)
            CALL RIMP2TEI(BB(1,1,I),BK(1,1,J),Q,NAUXBAS,NVIRA,NVIRB)
            CALL TSECND(TIME41)
            TIME4 = TIME4+(TIME41-TIME40)
C
C           MP2 CORRELATION ENERGY EVALUATION
C
            CALL TSECND(TIME50)
            E2SP = ZERO
            CALL RIUMP2E2B(EIGA,EIGB,Q,E2SP,NORBA,NORBB,NOCCA,NOCCB,
     *           NVIRA,NVIRB,IOCC,JOCC)
            E2S = E2S+E2SP
            CALL TSECND(TIME51)
            TIME5 = TIME5+(TIME51-TIME50)
C
         END DO                 !IOCC
      END DO                    !JOCC
C
      RETURN
      END
C*MODULE RIMP2   *DECK RIUMP2TEIE2BSMP
      SUBROUTINE RIUMP2TEIE2BSMP(EIGA,EIGB,BB,BK,Q,E2S,NAUXBAS,
     *     NORBA,NORBB,NOCCA,NOCCB,NVIRA,NVIRB,IOCCBG,IOCCED,
     *     JOCCBG,JOCCED,TIME4,TIME5,SMP_NP,SMP_ME)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DOUBLE PRECISION EIGA(*),EIGB(*),BB(NAUXBAS,NVIRA,*),
     *     BK(NAUXBAS,NVIRB,*),Q(*)

      INTEGER SMP_NP,SMP_ME
C
      PARAMETER (ZERO=0.0D+00)
C
      DO JOCC = JOCCBG, JOCCED
         J = JOCC-JOCCBG+1
         DO IOCC = IOCCBG, IOCCED
            I = IOCC-IOCCBG+1
C
C           4C-2E ERI (IA|JB) GENERATION FROM 3C-2E ERIS
C           (IA|L) AND (IJ|L)
C
            CALL TSECND(TIME40)
            CALL RIMP2TEISMP(BB(1,1,I),BK(1,1,J),Q,NAUXBAS,NVIRA,NVIRB,
     *           SMP_NP,SMP_ME)
            CALL TSECND(TIME41)
            TIME4 = TIME4+(TIME41-TIME40)
C
C           MP2 CORRELATION ENERGY EVALUATION
C
            CALL TSECND(TIME50)
            E2SP = ZERO
            CALL RIUMP2E2BSMP(EIGA,EIGB,Q,E2SP,NORBA,NORBB,NOCCA,
     *           NOCCB,NVIRA,NVIRB,IOCC,JOCC,SMP_NP,SMP_ME)
            E2S = E2S+E2SP
            CALL TSECND(TIME51)
            TIME5 = TIME5+(TIME51-TIME50)
C
         END DO                 !IOCC
      END DO                    !JOCC
C
      RETURN
      END
      SUBROUTINE SPHAUX(LOCSPH,NAUXSPH)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      INTEGER LOCSPH(*)
C
      PARAMETER (MXAUXSH=10000, MXAXGTOT=20000)
C
      COMMON /AUXBAS/ EXAUX(MXAXGTOT),CAUXS(MXAXGTOT),CAUXP(MXAXGTOT),
     *                CAUXD(MXAXGTOT),CAUXF(MXAXGTOT),CAUXG(MXAXGTOT),
     *                CAUXH(MXAXGTOT),CAUXI(MXAXGTOT),
     *                KAUXST(MXAUXSH),KAUXAT(MXAUXSH),KAUXTY(MXAUXSH),
     *                KAUXNG(MXAUXSH),KAUXLO(MXAUXSH),KAUXMI(MXAUXSH),
     *                KAUXMX(MXAUXSH),NAUXSH
C
      NAUXSPH = 0
C
C      DO ISH = 1, NAUXSH
C         WRITE(6,'(2I4)'),ISH,KAUXLO(ISH)
C      END DO
C
      DO ISH = 1, NAUXSH
         IT  = KAUXTY(ISH)
         MIN = KAUXMI(ISH)
C
         LOCSPH(ISH) = NAUXSPH+1
         NAUXSPH=NAUXSPH+(2*IT-1)
C                                     L-SHELLS
         IF(IT.EQ.2.AND.MIN.EQ.1) NAUXSPH=NAUXSPH+1
C
      END DO
C
      RETURN
      END
