C 21 May 13 - DGF,HN,TN - changes for FMO 5.0
C 19 Oct 12 - MWS - synchronize FRGINF common
C  2 Sep 12 - MWS - synchronize MCINP
C 21 JUN 12 - DGF - changes for FMO 4.3
C 23 MAR 12 - DGF - pad common blocks
C 28 DEC 11 - DGF - pad commons for FMO 4.2
C 15 Apr 11 - MWS - synch FMOPNT common
C 11 Aug 10 - TN  - new module for Hessians in FMO
c
C*MODULE FMOHSS  *DECK FMODEH
C>
C>     @brief Hessian contributions 
C>
C>     @details Accumulates Hessian contributions. 
C>
C>     @author Takeshi Nagata
C>
      SUBROUTINE FMODEH(ida,FCM,fmoddm,FMOFCM,fmopg,iaglob)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      Parameter (MXATM=2000)
CZCZ  common /GRAD  / DE(3,MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
CZCZ  COMMON /PCMPAR/ IPCM,NFT26,NFT27,IRPPCM,IEF,IP_F,nfmopcm
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
cz    common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
cz   *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
cz   *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
cz   *                IESDPPC,idoprop,mp2run
      dimension fmopg(3,*),iaglob(*)
      DIMENSION fmoddm(3,3,natfmo),FMOFCM(3*natfmo,*),FCM(3*nat,*)
c
c     gather FMO HESSIAN contributions coming from the analytic gradient of a
c     monomer/dimer.
c
c     Add the contribution from electrostatic potential 
      if(ida.eq.0) return
      da  = ida
      neh = natfmo * natfmo * 9
      if(maswrk) call daxpy(neh,da,FCM,1,FMOFCM,1)
C
      if(nat.lt.0) write(iw,*) fmopg(1,1)
      NC1 = 3*NAT
c
c     Accumulate the dipole derivatives. 
c
      CALL DAREAD(IDAF,IODA,FCM,3*NC1,34,0)

      if(maswrk) then
      da = ida
      do i = 1, nat
        ih  = iaglob(i)
        do k = 1,3
          ii  = 9*(i-1)+(k-1)*3
          do l = 1,3
            fmoddm(l,k,ih) = fmoddm(l,k,ih)+da*fcm(ii+l,1)
c           Here we treat fcm as a linear array of size 3*3*nat.
          end do
        end do
      end do
      endif
c
c     Accumulate the Hessian
c
      CALL DAREAD(IDAF,IODA,FCM,NC1*NC1,4,0)
   
      if(maswrk) then
      da = ida
      do i = 1, nat
        ih  = iaglob(i)
        ii  = 3*(i-1)
        ims = 3*(ih-1)
        do j = 1, nat
          jh  = iaglob(j)
          jj  = 3*(j-1)
          jms = 3*(jh-1)
          do k = 1,3
            do l = 1,3
              fmofcm(ims+k,jms+l)=fmofcm(ims+k,jms+l)+da*fcm(ii+k,jj+l)
            end do
          end do
        end do
      end do
      endif
c
      CALL VCLR(FCM,1,NC1*NC1)
      CALL DAWRIT(IDAF,IODA,FCM,NC1*NC1,4,0)
c
c     No FMO/PCM contribution for separated dimers.
CZCZ  if(nfmopcm.gt.0.and.ifmostp.ne.6.and.ifmostp.ne.7
CZCZ *   .and.IESDPPC.eq.0) call daxpy(natfmo*3,da,fmopg,1,fmode,1)
      return
      end
C*MODULE FMOHSS  *DECK FMOHESSX
C>
C>     @brief FMO Hessian driver
C>
C>     @details Perform FMO Hessian calculations. 
C>
C>     @author Takeshi Nakata
C>
      SUBROUTINE FMOHESSX(VIBOVR,GOTWFN)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION METHOD,METHNR
C
      LOGICAL PRTIFC,PURIFY,PROJCT,VIBANL,RDHESS,DECOMP,LINEAR,
     *        GOTEG,GOTEH,GOTDDM,GOTADM,STATPT,SOME,PRTSCN,GOTFRQ,
     *        VIBOVR,GOTWFN,GOPARR,DSKWRK,MASWRK,TEST,
     *        PULCOR,EFLDL,POLAR,HSSEND,SCFOK,REDOVB,OK,FGONLY,
     *        QMMM,MMONLY,CARTSN,CANONC,FCORE,FORS,EKT,LINSER,
     *        MPGRD,CIGRD,DIISON
C
      PARAMETER (MXATM=2000, MXAO=8192, MXPT=2000, MXFRG=1050,
     *           MXFGPT=12000, MXNORO=250, MAXNFRAGS=10,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (NNAM=18)
C
      DIMENSION QNAM(NNAM), KQNAM(NNAM), APOL(6), RAMALF(6)
C
      COMMON /CHFINF/ CHFSLV,CPTYPE,NWDCHF,POLAR
      COMMON /EFLDC / EVEC(3),EFLDL
      COMMON /FMCOM / X(1)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      COMMON /FROZNC/ IFREEZ(3*MXATM),NFRZ
      COMMON /FUNCT / E,EG(3,MXATM)
      COMMON /GVBWFN/ CICOEF(2,12),F(25),ALPHA(325),BETA(325),NO(10),
     *                NCO,NSETO,NOPEN,NPAIR,NORB,NCONF(MXAO),NHAM
      COMMON /HSSCTL/ IHESSM,IHREP,HSSEND
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MCINP / METHNR,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWORD,NORBMC,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /MIOPT / DTOL,CNVLOC,DIISTL,ALPHAX,
     *                NF(MAXNFRAGS),MF(MAXNFRAGS),NFRAGS,MSHIFT,ITERMI,
     *                ITLOC,IGUESS,MXDIIS,
     *                IOPT,MIFLAG,DIISON
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOLMP,METHMP,NWDMP2,MEMPRI,
     *                MPPROP,NACORMP,NBCORMP,NOAMP,NOBMP,NORBMP,NBFMP,
     *                NOMITMP,MPCPHF,MAXITCMP
      COMMON /NEOJOB/ NEORUN,NELERM
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IRPPCM,IEF,IP_F,NFMOPCM
      COMMON /RELWFN/ RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,IQRORD,MODQR,NESOC,
     *                NRATOM,NUMU,NQMTR,NQRDAF,MORDA,NDARELB
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SVPOPT/ ISVP,NSVP,MTHSVP,NCAV,NVLPL,IQP
      COMMON /THERMD/ FREQ(3*MXATM),TEMP(10),SCLFAC,NTEMP,PRTSCN,GOTFRQ
      COMMON /TINOPT/ mparti,MMONLY,QMMM
      COMMON /VBDCMP/ DECOMP,NROW,NDEG
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      COMMON /ZMAT  / NZMAT,NZVAR,NVAR,NSYMC,LINEAR
      COMMON /ZRFPAR/ GZRF,FIND(3),GNUCF,EBORN,DIELEC,IZRF,ICALC
c
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
C
C     COSMO information
C
      LOGICAL ISEPS,USEPS
      COMMON /ISEPS / ISEPS, USEPS
      LOGICAL COSBUG,COSWRT,DCOSMO,PRFCND,IOUTCH
      COMMON /COSDAT/ SE2,SECORR,QVCOSMO,ELAST,EMP2COS,EMP2LAST,
     *                COSVOL,COSSAR,EDIEL,EOC1,DEOC_RS,SUMQSC,
     *                SUMQSCOLD,ZSUM,ZSUM2,ZSUM3,FEPSI,RDS,DISEX2,
     *                EPSI,COSRAD,DISEX,OUTCHG,EDIEL_SAVE,
     *                MAXNPS,ICORR,ITRIP,NQS,MP2TRIP,MP2ITER,
     *                ICFREQ,NSPA,NSPH,NPSD,NPS,NPS2,NDEN,NPSPHER,
     *                COSBUG,COSWRT,DCOSMO,PRFCND,IOUTCH
C
      PARAMETER (TOLG=0.0005D+00, ZERO=0.0D+00)
C
C     ----- SET UP NAMELIST SIMULATION -----
C
      DATA FORCE/8HFORCE   /
      DATA QNAM/8HNVIB    ,8HVIBSIZ  ,8HPRTIFC  ,8HPURIFY  ,8HPROJCT  ,
     *          8HMETHOD  ,8HVIBANL  ,8HRDHESS  ,8HDECOMP  ,8HSCLFAC  ,
     *          8HTEMP    ,8HFREQ    ,8HPRTSCN  ,8HNPRT    ,8HNPUN    ,
     *          8HPULCOR  ,8HTEST    ,8HREDOVB  /
      DATA KQNAM/1,3,0,0,0,5,0,0,0,3,103,-3,0,1,1,0,0,0/
C
      DATA HSSIAN/8HHESSIAN /
      DATA GAMMA/8HGAMMA    /
      DATA ANAL,SNUM,FNUM,RNUM
     *      /8HANALYTIC,8HSEMINUM ,8HFULLNUM ,8HNUMERIC /
      DATA RHF,ROHF,UHF/8HRHF     ,8HROHF    ,8HUHF     /
      DATA      GVB,RMC/8HGVB     ,8HMCSCF   /
      DATA GENCI,GUGA,CIS/8HGENCI   ,8HGUGA    ,8HCIS     /
      DATA ZAPT/8HZAPT    /
      DATA NONE,RNONE/4HNONE,8HNONE    /
      DATA CHECK/8HCHECK   /
czcz
      DATA FMOHESS/8HFMOHESS /
      dimension dum3(3)
czcz
C
C     ----- MAIN DRIVER TO OBTAIN HESSIAN MATRIX -----
C
C     THE ENERGY, GRADIENT, HESSIAN, AND DIPOLE DERIVATIVE TENSOR
C     ARE OBTAINED BY READING THEM FROM CARDS, OR COMPUTING THEM.
C     THE ALPHA POLARIZABILITY DERIVATIVE TENSOR IS OBTAINED ONLY
C     BY READING IT FROM CARDS.  IT IS COMPUTED ONLY BY RUNTYP=RAMAN.
C
C     THE CALLING ARGUMENTS PERMIT YOU TO OVERRIDE THE VALUE OF
C     VIBANL GIVEN IN $FORCE BELOW, AND INDICATE THE SUCCESFUL
C     CONCLUSION OF A GEOMETRY SEARCH, USEFUL FOR $STATPT 'HSSEND'
C
CZCZ    
CZ    Scan $FMOXYZ to find natfmo.
CZ    
      call fmoxyz(' $FMOXYZ',1,natfmo,dum,dum3,idum)
CZ
      CALL VALFM(LOADFM)
      LFMOC   = LOADFM  + 1
      LFMOZAN = LFMOC   + 3*(NATFMO+1)
      LFMOMAS = LFMOZAN + NATFMO
      LIZBAS  = LFMOMAS + NATFMO
      LAST    = LIZBAS  + (NATFMO-1)/NWDVAR+1 
      NEEDFMO = LAST - LOADFM - 1
      CALL GETFM(NEEDFMO)
CZCZ

      SOME = NPRINT.NE.-5 .AND. MASWRK
CZCZ  NCOORD = 3*NAT
      NCOORD = 3*natfmo
      NCF    = 6*NFRG
      GOTEG  = .FALSE.
      GOTEH  = .FALSE.
      GOTDDM = .FALSE.
      GOTADM = .FALSE.
C
C     ----- READ $FORCE INPUT GROUP -----
C
C        THE STRATEGY FOR DETERMINING THE DEFAULT DIFFERENTIATION
C        IS TO PERFORM AN ANALYTIC CALCULATION IF POSSIBLE, OR TO
C        CHOOSE SEMI-NUMERICAL DIFFERENTIATION OF ANALYTIC GRADIENTS.
C        IF THE ANALYTIC GRADIENT IS NOT CODED, THE USER IS PERMITTED
C        TO REQUEST FULLY NUMERIC DIFFERENTIATION, BUT BECAUSE THIS
C        IS REASONABLE ONLY FOR SMALL MOLECULES, WE NEVER PICK THAT
C        AS A DEFAULT (THEY MUST TYPE IT).
C
      METHOD=ANAL
C
C     ---- THE FOLLOWING METHODS ONLY ALLOW SEMI-NUMERIC HESSIANS ----
C        BASIS SETS WITH F OR G FUNCTIONS
C        UHF, OR GVB WITH MORE THAN ONE PERFECT PAIR
C        MCSCF IF IT DOES NOT USE FULL ACTIVE SPACE DETERMINANT CODE
C        CI, MP2 (RHF OR UHF), DFT
C        MOPAC WAVEFUNCTIONS
C        SIMOMM MODEL
C        SOLVENT MODELS: EFP, ONSAGER, PCM, OR COSMO
C        SCALAR RELATIVISTIC CORRECTIONS
C        APPLIED EXTERNAL ELECTRIC FIELD
C        SCF-MI
C     ALL OF WHICH HAVE ANALYTIC GRADIENTS PROGRAMMED.
C     IN ADDITION, THE PARTIAL HESSIAN ANALYSIS IS SEMI-NUMERIC
C
      CALL BASCHK(LMAX)
      IF(LMAX.GT.2)                             METHOD=SNUM
      IF(SCFTYP.EQ.UHF)                         METHOD=SNUM
      IF(SCFTYP.EQ.GVB  .AND.  NPAIR.GT.1)      METHOD=SNUM
      IF(SCFTYP.EQ.RMC  .AND.  CISTEP.EQ.GUGA)  METHOD=SNUM
      IF(SCFTYP.EQ.RMC  .AND.  CISTEP.EQ.GENCI) METHOD=SNUM
      IF(MPLEVL.GT.0)                           METHOD=SNUM
      IF(CITYP.NE.RNONE)                        METHOD=SNUM
      IF(DFTYPE.NE.RNONE)                       METHOD=SNUM
      IF(SCFTYP.EQ.RHF  .AND. TDDFTYP.NE.RNONE) METHOD=SNUM
      IF(MPCTYP.NE.NONE)                        METHOD=SNUM
      IF(IECP.EQ.5)                             METHOD=SNUM
      IF(QMMM)                                  METHOD=SNUM
      ISOLV = NFRG + IZRF + IPCM
      IF(ISOLV.GE.1  .OR.  ISEPS)               METHOD=SNUM
      IF(RMETHOD.NE.RNONE)                      METHOD=SNUM
      IF(EFLDL)                                 METHOD=SNUM
      IF(MIFLAG.EQ.1)                           METHOD=SNUM
      IF(RUNTYP.EQ.HSSIAN.AND.IFREEZ(1).NE.0)   METHOD=SNUM
      IF(NEORUN.EQ.1)                           METHOD=SNUM
C
C         IF WE HAVE THE ENERGY, BUT NOT THE ANALYTIC GRADIENTS...
C
      MPGRD = SCFTYP.EQ.RHF  .OR.  SCFTYP.EQ.UHF
     *                       .OR. (SCFTYP.EQ.ROHF  .AND.  OSPT.EQ.ZAPT)
      CIGRD = SCFTYP.EQ.RHF .AND. (CITYP.EQ.GUGA  .OR.  CITYP.EQ.CIS)
      IF(MPLEVL.GT.0  .AND.  .NOT.MPGRD)           METHOD=RNONE
      IF(CITYP.NE.RNONE  .AND.  .NOT.CIGRD)        METHOD=RNONE
      IF(CCTYP.NE.RNONE)                           METHOD=RNONE
      IF(VBTYP.NE.RNONE)                           METHOD=RNONE
      IF(SCFTYP.NE.RHF  .AND. TDDFTYP.NE.RNONE)    METHOD=RNONE
      IF(ISVP.EQ.1)                                METHOD=RNONE
C        NOTE THAT WE ARE LETTING EFP SLIDE HERE,
C        FOR TRADITIONAL REASONS,
C        BUT WE DON'T HAVE MP2/CI+EFP GRADIENTS CORRECTLY CODED.
      IF(MPLEVL.GT.0  .OR.  CITYP.NE.RNONE) THEN
         IF(IZRF.GE.1 .OR.  IPCM.EQ.1  .OR. ISEPS) METHOD=RNONE
      END IF
C
C         REMEMBER THIS DEFAULT FOR ERROR CHECKING LATER
C
      IANAL=0
      ISNUM=0
      IFNUM=0
      IF(METHOD.EQ.ANAL)  IANAL=1
      IF(METHOD.EQ.SNUM)  ISNUM=1
      IF(METHOD.EQ.RNONE) IFNUM=1
C
      FGONLY = NUM.EQ.0  .AND.  NFRG.GT.0
      IF(ISEPS) ICFREQ=1
      RDHESS=.FALSE.
      NVIB = 1
      MPRINT=NPRINT
      VIBSIZ=0.01D+00
      PURIFY=.FALSE.
      PRTIFC=.FALSE.
      VIBANL=.FALSE.
czcz  IF(RUNTYP.EQ.HSSIAN) VIBANL=.TRUE.
      IF(RUNTYP.EQ.FMOHESS) VIBANL=.TRUE.
      DECOMP=.FALSE.
      PROJCT=.FALSE.
      IF(IFREEZ(1).NE.0.AND.RUNTYP.EQ.HSSIAN) PROJCT=.TRUE.
      SCLFAC = 1.0D+00
      DO 100 I=1,10
         TEMP(I) = ZERO
  100 CONTINUE
      TEMP(1) = 298.15D+00
      KQNAM(12) = NCOORD*10+3
      DO 110 I=1,NCOORD
         FREQ(I) = ZERO
  110 CONTINUE
      PRTSCN = .FALSE.
      NPRT = 0
      NPUN = 0
      PULCOR=.FALSE.
      REDOVB=.TRUE.
C
C     "TEST" IS AN UNDOCUMENTED WAY TO AVOID THE CHECK MADE
C     BELOW AS TO WHEN ANALYTIC HESSIANS CAN BE REQUESTED.
C
      TEST=.FALSE.
C
      JRET=0
      CALL NAMEIO(IR,JRET,FORCE,NNAM,QNAM,KQNAM,
     *            NVIB,VIBSIZ,PRTIFC,PURIFY,PROJCT,METHOD,VIBANL,
     *            RDHESS,DECOMP,SCLFAC,TEMP,FREQ,PRTSCN,NPRT,NPUN,
     *            PULCOR,TEST,REDOVB,
     *            0,  0,0,0,0,0,
     *    0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,
     *    0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0)
      NERR=0
      IF(JRET.EQ.2) NERR=NERR+1
C
C       'NUMERIC ' IS TO BE CONSIDERED AN ACCEPTABLE TYPO FOR 'SEMINUM '
      IF(METHOD.EQ.RNUM) METHOD=SNUM
C
      IF(NPRT.LT.0) NPRT=0
      IF(NPRT.GT.1) NPRT=1
      IF(NPUN.LT.0) NPUN=0
      IF(NPUN.GT.2) NPUN=2
C
      IF(SOME) WRITE(IW,9010) METHOD,NVIB,VIBSIZ,
     *                        RDHESS,PURIFY,PRTIFC,
     *                        VIBANL,DECOMP,PROJCT,
     *                        SCLFAC,PRTSCN,NPRT,
     *                        PULCOR,NPUN,REDOVB
C
      NTEMP=0
      DO 200 I=1,10
         IF(TEMP(I).NE.ZERO) NTEMP=NTEMP+1
  200 CONTINUE
      IF(SOME  .AND.  VIBANL) WRITE(IW,9012) NTEMP,(TEMP(I),I=1,NTEMP)
C
      NFREQ=0
      DO 210 I=1,NCOORD
         IF(FREQ(I).NE.ZERO) NFREQ=NFREQ+1
  210 CONTINUE
      IF(NFREQ.GT.0) THEN
         IF (SOME) WRITE(IW,9014) NFREQ,(FREQ(I),I=1,NFREQ)
         GOTFRQ=.TRUE.
      END IF
C
      IF(NVIB.LE.0  .OR.  NVIB.GT.2) NERR=NERR+1
      IF(ABS(VIBSIZ).GT.0.25D+00) NERR=NERR+1
C
      OK=.FALSE.
      IF(METHOD.EQ.ANAL) OK=.TRUE.
      IF(METHOD.EQ.SNUM) OK=.TRUE.
      IF(METHOD.EQ.FNUM) OK=.TRUE.
      IF(.NOT.OK) THEN
         IF(MASWRK) WRITE(IW,*)
     *       '*** ERROR: METHOD = ANALYTIC, SEMINUM, OR FULLNUM ONLY'
         NERR=NERR+1
      END IF
      IF(METHOD.EQ.ANAL) NHLEVL=0
      IF(METHOD.EQ.SNUM) NHLEVL=1
      IF(METHOD.EQ.FNUM) NHLEVL=2
C
      IF(NGLEVL.EQ.1) THEN
         IF(MASWRK) WRITE(IW,9090)
         NERR=NERR+1
      END IF
C
C        CHECK TO SEE IF DIFFERENTIATION METHOD IS REASONABLE
C     THE UNDOCUMENTED KEYWORD -TEST- ALLOWS SKIPPING THESE CHECKS.
C     OF COURSE, -TEST- SHOULD BE CHOSEN ONLY BY SOMEONE WHO IS
C     TRYING TO PROGRAM A MISSING METHOD.
C
      IF(.NOT.TEST) THEN
         IF(METHOD.EQ.ANAL  .AND.  (ISNUM+IFNUM).GT.0) THEN
            IF(MASWRK) WRITE(IW,9100)
            IF(MASWRK) WRITE(IW,9105) METHOD
            NERR=NERR+1
         END IF
         IF(METHOD.EQ.SNUM  .AND.  IFNUM.GT.0) THEN
            IF(MASWRK) WRITE(IW,9100)
            IF(MASWRK) WRITE(IW,9105) METHOD
            NERR=NERR+1
         END IF
      END IF
C
C        PRINT SOME FRIENDLY ADVISE IF A HIGHER METHOD IS FEASIBLE
C
      IF(MASWRK) THEN
         IF(METHOD.EQ.SNUM  .AND.  IANAL.EQ.1) WRITE(IW,9106) ANAL,SNUM
         IF(METHOD.EQ.FNUM  .AND.  IANAL.EQ.1) WRITE(IW,9106) ANAL,FNUM
         IF(METHOD.EQ.FNUM  .AND.  ISNUM.EQ.1) WRITE(IW,9106) SNUM,FNUM
      END IF
C
      IF(NERR.GT.0) THEN
         IF(MASWRK) WRITE(IW,*)
     *      'ERROR IN $FORCE INPUT, PLEASE FIX AND TRY AGAIN.'
         CALL ABRT
      END IF
C
      IF(GOTFRQ) GO TO 800
C
C     ----- READ INTERNALS, GENERATE B MATRIX -----
C     THIS MUST BE DONE AFTER -DECOMP- IS KNOWN, AS THE DECOMPOSITION
C     SOMETIMES USES MORE THAN 3N-6 COORDINATES.  THE Z-MATRIX
C     CODE PERMITS MORE THAN 3N-6 COORDINATES ONLY IF DECOMP=.T.
C
      CARTSN = NZVAR.EQ.0
      IF(NZVAR.GT.0 .AND. RUNTYP.EQ.HSSIAN) THEN
         CALL ZMATIN(CARTSN)
         CALL BANDBI
         CALL PZANDG(F,0)
      END IF
C
C     ----- OBTAIN THE INFORMATION FROM CARD INPUT -----
C
      IF(RDHESS) THEN
         CALL VALFM(LOADFM)
         LFCM   = LOADFM+1
         LDDM   = LFCM   + (NCOORD+NCF)*(NCOORD+NCF)
         LADM   = LDDM   + 3*(NCOORD+NCF)
C
C            NOTE THAT $ALPDR IS NOT SET UP TO WORK WITH ANY
C        --- SOLVATION MODELS, SO ONLY 6*NCOORDS WORDS ARE
C            NEEDED INSTEAD OF 6*(NCOORD+NCF)
C
         LEG    = LADM   + 6*NCOORD
         LAST   = LEG    + NCOORD
         NEED = LAST-LOADFM
         CALL GETFM(NEED)
C
C           LOOK FOR OPTIONAL GRADIENT VECTOR
C           LOOK FOR HESSIAN MATRIX
C           LOOK FOR OPTIONAL DIPOLE DERIVATIVE TENSOR
C           LOOK FOR OPTIONAL ALPHA POLARIZABILITY DERIVATIVE TENSOR
C
         CALL EGIN(X(LEG),NCOORD,GOTEG,' $GRAD  ')
         CALL FCMIN(X(LFCM),NCOORD+NCF,GOTEH)
         CALL DDMIN(X(LDDM),NCOORD+NCF,GOTDDM)
         CALL ADMIN(RAMALF,X(LADM),NCOORD,GOTADM)
         CALL RETFM(NEED)
         IF(GOTEH) THEN
            SCFOK=.TRUE.
            GO TO 700
         ELSE
            IF (MASWRK) WRITE(IW,9030)
            CALL ABRT
         END IF
      END IF
C
C     ----- OTHERWISE, THEY MUST BE COMPUTED -----
C
CZ 
CZ    FMO HESSIAN CALCULATION
CZ
      if (.not.rdhess) then
        GOTDDM=.TRUE.
        if (maswrk) write(6,*) 'HESS CALC IN FMOHESS DRIVER STARTS'
        CALL FMOX(0)
        if (maswrk) write(6,*) 'HESS CALC IN FMOHESS DRIVER ENDS'
        ncoord = natfmo*3
        SCFOK = .TRUE.
      end if
cz
cz    Tricky part: this is just for the vibrational analysis
cz
      nat = natfmo
czcz

cz    IF(METHOD.EQ.ANAL) THEN
cz       IHESSM=2
cz       GOTDDM=.TRUE.
cz       GOTEG =.TRUE.
cz       CALL VALFM(LOADFM)
cz       LDDM = LOADFM+1
cz       LAST = LDDM  + 3*NCOORD
cz       NEED = LAST-LOADFM
cz       CALL GETFM(NEED)
cz       CALL VCLR(X(LDDM),1,3*NCOORD)
cz       CALL DAWRIT(IDAF,IODA,X(LDDM),3*NCOORD,34,0)
cz       CALL RETFM(NEED)
cz       CALL HSSANA(GOTWFN)
cz       SCFOK=.TRUE.
cz    END IF
C
cz    IF(METHOD.EQ.SNUM) THEN
cz       IHESSM=1
cz       GOTDDM=.TRUE.
cz       GOTEG =.TRUE.
cz       CALL VALFM(LOADFM)
cz       LFCM   = LOADFM + 1
cz       LDDM   = LFCM   +   (NCOORD+6*NFRG)**2
cz       LIST   = LDDM   + 3*(NCOORD+6*NFRG)
cz       LSKIP  = LIST   + 6*NFRG*NVIB
cz       LSKIP2 = LSKIP  + NAT+2*NFRG
cz       LWRK   = LSKIP2 + NAT*NAT
cz       LAST   = LWRK   + NUM*NUM
cz       NEED = LAST-LOADFM
cz       CALL GETFM(NEED)
cz       NATM = NAT
cz       CALL HSSNUM(X(LFCM),X(LDDM),X(LSKIP),X(LSKIP2),X(LWRK),
cz   *               X(LIST),NCOORD+6*NFRG,NAT+2*NFRG,NATM,
cz   *               NVIB,VIBSIZ,NPRT,NPUN,SCFOK,GOTWFN,REDOVB)
cz       CALL RETFM(NEED)
cz    END IF
c
cz    IF(METHOD.EQ.FNUM) THEN
cz       IHESSM=0
cz       IF(NFRG.GT.0) THEN
cz          IF(MASWRK) WRITE(IW,*)
cz   *          'FULLY NUMERIC HESSIAN NOT AVAILABLE WITH EFP'
cz          CALL ABRT
cz       END IF
cz       GOTDDM = .FALSE.
cz       GOTEG  = .FALSE.
cz       MYNC1  = 3*NAT
C           THE ACTUAL NUMBER OF POINTS DONE CANNOT EXCEED MXSP
cz       MXSP   = 1 + 24*NAT + 18*NAT*NAT
cz       CALL VALFM(LOADFM)
cz       LFCM   = LOADFM + 1         ! START OF FCM
cz       LDDM   = LFCM   + MYNC1**2  ! START OF DDM
cz       LSKIP  = LDDM   + 3*MYNC1   ! START OF SKIP ARRAY
cz       LATMP  = LSKIP  + NAT       ! START OF ATOM PAIR ARRAY
cz       LWRK   = LATMP  + NAT*NAT   ! STORT OF VIB0 ORBITALS
cz       LESP   = LWRK   + NUM*NUM   ! START OF SINGLE POINT ENERGIES
cz       LEG    = LESP   + MXSP      ! START OF GRADIENT
cz       LAST   = LEG    + NCOORD    ! LAST ADDRESS ON STACK
cz       NEED   = LAST - LOADFM
cz       CALL GETFM(NEED)
cz       CALL HSSFUL(X(LESP),X(LFCM),X(LSKIP),X(LATMP),X(LWRK),
cz   *               NAT,MYNC1,MXSP,VIBSIZ,GOTEG,SCFOK)
cz       CALL RETFM(NEED)
cz    END IF
C
C         THE HESSIAN COMPUTATION IS NOW FINISHED
C
  700 CONTINUE
C
C         HESSIAN MAY BE COMPUTED AS PART OF A GEOMETRY OPTIMIZATION,
C         ETC., AND THOSE RUNS MAY NOW TEST -IHESSM- TO KNOW THEY ARE
C         NO LONGER IN A HESSIAN CALCULATION PHASE...
C
      IHESSM=0
C
C     --- PURIFY THE HESSIAN,DIPOLE DERIVATIVES,ALPHA POLARIZABILITY ---
C
      NPRINT=MPRINT
      IF(NZVAR.GT.0 .AND. (PURIFY.OR.PRTIFC.OR.DECOMP.OR.PULCOR)) THEN
         CALL VALFM(LOADFM)
         LFCM   = LOADFM + 1
         LFCMI  = LFCM  + NCOORD*NCOORD
         LEG    = LFCMI + NROW*NROW
         LDDM   = LEG   + MAX(NCOORD,NROW)
         LDDN   = LDDM  + 3*NCOORD
         LADM   = LDDN  + 3*NVAR
         LADMI  = LADM  + 6*NCOORD
         LBMAT  = LADMI + 6*NVAR
         LBINV  = LBMAT + NVAR*NCOORD
         LWRK   = LBINV + NCOORD*NVAR
         LZMAT  = LWRK  + MAX(NCOORD,NROW)
         LIZMAT = LZMAT + NVAR
         LIWRK  = LIZMAT+ NZMAT
         LAST   = LIWRK + NVAR
         NEED = LAST - LOADFM - 1
         CALL GETFM(NEED)
C
C    PURIFY GRADIENT AND/OR PRINT INTERNAL GRADIENT
C
         IF(PRTIFC.OR.PURIFY) THEN
            CALL DAREAD(IDAF,IODA,X(LEG),NCOORD,3,0)
            CALL TRANG(X(LEG),NVAR,NCOORD)
            IF (PRTIFC) THEN
               CALL PZANDG(X(LEG),1)
               IF (NSYMC .EQ. 0)
     *            CALL PUZMAT(X(LZMAT),X(LIZMAT),X(LIWRK),NVAR,NZMAT)
            END IF
            IF (PURIFY) CALL TRANGB(X(LEG),NVAR,NCOORD)
         END IF
C
         CALL PURFCM(X(LFCM),X(LFCMI),X(LIZMAT),NCOORD,NROW,NVAR,
     *               NZMAT,PURIFY,PRTIFC,DECOMP)
C
         IF (PULCOR) THEN
C---         CALL HSSCOR(X(LFCM),X(LFCMI),X(LBINV),X(LEG),NCOORD,NVAR)
             IF(MASWRK) WRITE(IW,*) 'OPTION -PULCOR- IS INACTIVE'
         END IF
C
         IF(GOTDDM  .AND.  PURIFY)
     *      CALL PURDDM(X(LDDM),X(LDDN),X(LBMAT),X(LBINV),X(LWRK),
     *                  NCOORD,NVAR)
         IF(GOTADM .AND. PURIFY)
     *      CALL PURADM(X(LADM),X(LADMI),X(LBMAT),X(LBINV),X(LWRK),
     *                  NCOORD,NVAR)
         CALL RETFM(NEED)
      END IF
C
C     ----- PRINT/PUNCH GRADIENT, HESSIAN, DIPOLE DERIVATIVES,
C     ----- ALPHA POLARIZABILITY DERIVATIVES.
C
      CALL VALFM(LOADFM)
      LFCM = LOADFM + 1
      LEG  = LFCM   + (NCOORD+6*NFRG)*(NCOORD+6*NFRG)
      LDDM = LEG    + NCOORD
      LADM = LDDM   + 3*(NCOORD+6*NFRG)
      LAST = LADM   + 6*NCOORD
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      IF(NAT.GT.0) CALL DAREAD(IDAF,IODA,X(LEG) ,NCOORD,3,0)
      CALL DAREAD(IDAF,IODA,X(LFCM),(NCOORD+6*NFRG)**2, 4,0)
      IF(GOTDDM) THEN
         CALL DAREAD(IDAF,IODA,X(LDDM),3*(NCOORD+6*NFRG) ,34,0)
      ELSE
         CALL VCLR(X(LDDM),1,3*(NCOORD+6*NFRG))
      END IF
C
      IF(RUNTYP.EQ.GAMMA) CALL FCMSAV(X(LFCM),NCOORD)
C
      IF(GOTEG .AND. .NOT. FGONLY) THEN
         GRMS = DDOT(NCOORD,X(LEG),1,X(LEG),1)
         GRMS = SQRT(GRMS/NCOORD)
         LOCMX = IDAMAX(NCOORD,X(LEG),1)
         GMAX = X(LEG-1+LOCMX)
         STATPT = GMAX.LT.TOLG  .AND.  GRMS.LT.(TOLG/3.0D+00)
      ELSE
         STATPT = .TRUE.
      END IF
C
czcz  IF(RUNTYP.EQ.HSSIAN  .OR.  GOTWFN) THEN
      IF(RUNTYP.EQ.FMOHESS  .OR.  GOTWFN) THEN
         IF(GOTEG.AND.MASWRK) WRITE(IW,9040)
         IF(GOTEG)  CALL  EGOUT(X(LEG) ,NAT)
CZCZ                CALL FCMOUT(X(LFCM),NCOORD+6*NFRG)
                    CALL FMOFCMOUT(X(LFCM),NCOORD+6*NFRG)
         IF(POLAR  .AND.  EXETYP.NE.CHECK) THEN
            IF(IFREEZ(1).EQ.0) THEN
               CALL DAREAD(IDAF,IODA,APOL,6,251,0)
               CALL POLOUT(APOL)
            END IF
         END IF
         IF(GOTDDM .AND. .NOT.FGONLY) THEN
            IF(IFREEZ(1).EQ.0) THEN
               CALL DDMOUT(X(LDDM),NCOORD+6*NFRG)
            END IF
         END IF
         IF(GOTADM .AND. .NOT.FGONLY) THEN
            CALL POLOUT(RAMALF)
            CALL ADMOUT(X(LADM),NCOORD)
         END IF
      END IF
C
      IF(GOTEG)  CALL  EGPUN(X(LEG) ,NAT,' $GRAD  ')
                 CALL FCMPUN(X(LFCM),NCOORD+6*NFRG)
      IF(GOTDDM) CALL DDMPUN(X(LDDM),NCOORD+6*NFRG)
      IF(GOTADM) CALL ADMPUN(E,RAMALF,X(LADM),NCOORD)
      CALL RETFM(NEED)
C
C     ----- NORMAL COORDINATE VIBRATIONAL ANALYSIS -----
C
  800 CONTINUE
      IF(.NOT.VIBANL  .AND.  .NOT.VIBOVR) RETURN
      NC1 = NCOORD+6*NFRG
      NC2 = (NC1**2+NC1)/2
      NC3 = NC1**2
C
      NPART = NAT
      KMASS=0
      DO 820 IFRG=1,NFRG
         DO 810 III=1,NMPTS(IFRG)
            IF(FMASS(III+KMASS).GT.ZERO) NPART=NPART+1
  810    CONTINUE
         KMASS=KMASS+NMPTS(IFRG)
  820 CONTINUE
C
      CALL VALFM(LOADFM)
      LVEC   = LOADFM + 1
      LFCM   = LVEC   + NC3
      LE     = LFCM   + NC2
      LSCR   = LE     + NC1
      LIA    = LSCR   + NC1*8
      LRM    = LIA    + NC1
      LSVT   = LRM    + (NCOORD+21*NFRG)
      LSVR   = LSVT   + NC1*3
      LSVTT  = LSVR   + NC1*3
      LSVRT  = LSVTT  + NC1
      LCC    = LSVRT  + NC1
      LCOM   = LCC    + 3*NPART
      LZMS   = LCOM   + 3*NPART
      LBUF1  = LZMS   +   NPART
      LBUF2  = LBUF1  + NC3
      LDDM   = LBUF2  + NC3
      LADM   = LDDM   + NC1*3
      LAST   = LADM   + NC1*6
      NEED = LAST-LOADFM
      CALL GETFM(NEED)
CZ    NATM = NAT+2*NFRG
      IF(NEORUN.EQ.0) THEN
         CALL FGMTRX(X(LVEC),X(LFCM),X(LE),X(LSCR),X(LIA),X(LRM),
     *               X(LSVT),X(LSVR),X(LSVTT),X(LSVRT),
     *               X(Lfmoc),X(LCOM),X(Lfmomas),X(LBUF1),X(LBUF2),
     *               NC1,NC2,NPART,X(LDDM),GOTDDM,X(LADM),GOTADM,
     *               PROJCT,STATPT,SCFOK,nfg)
      ELSE
         CALL FGMTRX_NEO(X(LVEC),X(LFCM),X(LE),X(LSCR),X(LIA),X(LRM),
     *               X(LSVT),X(LSVR),X(LSVTT),X(LSVRT),
     *               X(Lfmoc),X(LCOM),X(Lfmomas),X(LBUF1),X(LBUF2),
     *               NC1,NC2,NPART,X(LDDM),GOTDDM,X(LADM),GOTADM,
     *               PROJCT,STATPT,SCFOK)
      END IF
C
C        SAVE HARMONIC FREQUENCIES AND NORMAL MODES FOR EXTENDED TDHF
C
      IF(IGETOLI(1).NE.0) THEN
        CALL SVGFNM(FREQ,X(LVEC),NC1,LINEAR)
      END IF
C
      CALL RETFM(NEED)
czcz
      call retfm(needfmo)
czcz
      IF (MASWRK) WRITE(IW,9020)
      CALL TIMIT(1)
      RETURN
C
 9010 FORMAT(/5X,33(1H-)/
     *        5X,'HESSIAN MATRIX CONTROL PARAMETERS'/5X,33(1H-)/
     *        5X,'METHOD=',A8,3X,'NVIB  =',I8,3X,'VIBSIZ=',F8.5/
     *        5X,'RDHESS=',L8,3X,'PURIFY=',L8,3X,'PRTIFC=',L8/
     *        5X,'VIBANL=',L8,3X,'DECOMP=',L8,3X,'PROJCT=',L8/
     *        5X,'SCLFAC=',F8.5,3X,'PRTSCN=',L8,3X,'NPRT  =',I8/
     *        5X,'PULCOR=',L8,3X,'NPUN  =',I8,3X,'REDOVB=',L8)
 9012 FORMAT(5X,'THERMOCHEMISTRY WILL BE PRINTED FOR',I5,
     *          ' TEMPERATURES:'/(3X,5F12.5/))
 9014 FORMAT(5X,'HESSIAN COMPUTATION WILL BE SKIPPED AS'/
     *       5X,'A TOTAL OF',I5,' FREQUENCIES WERE INPUT:'/
     *      (5X,5F12.5/))
 9020 FORMAT(1X,'......END OF NORMAL COORDINATE ANALYSIS......')
 9030 FORMAT(1X,'RDHESS IS TRUE, BUT NO HESSIAN MATRIX WAS FOUND IN',
     *          ' YOUR INPUT FILE.')
 9040 FORMAT(/10X,15(1H-)/10X,'ENERGY GRADIENT'/10X,15(1H-))
 9090 FORMAT(/1X,'PLEASE DO NOT USE NUMGRD=.TRUE. DURING HESSIAN JOBS,'/
     *   1X,'INSTEAD USE METHOD=ANALYTIC, SEMINUM, OR FULLNUM ONLY.'/
     *   1X,'(IF NECESSARY, RUN THE HESSIAN IN A SEPARATE JOB THAN'/
     *   1X,'A GEOMETRY SEARCH (I.E. AVOID HESS=CALC OR HSSEND=.TRUE.)')
 9100 FORMAT(/10X,'**** ERROR IN DIFFERENTIATION METHOD ****'//
     *  1X,'ANALYTIC COMPUTATION OF THE HESSIAN IS IMPLEMENTED'/
     *  5X,'FOR S,P,D BASIS SETS (INCLUDING ECP USAGE) FOR AB INITIO',
     *     ' RHF, ROHF,'/
     *  5X,'GVB (OPEN SHELL OR TCSCF) AND MCSCF (CISTEP=ALDET)',
     *     ' WAVEFUNCTIONS.'//
     *  1X,'SEMI-NUMERIC HESSIANS CAN BE COMPUTED WHEN ANALYTIC',
     *     ' GRADIENTS ARE AVAILABLE:'/
     *  5X,'IF F,G FUNCTIONS ARE IN THE BASIS SET,'/
     *  5X,'IF USING GRID-BASED OR GRID-FREE DFT,'/
     *  5X,'IF UHF, OR IF GVB WITH MORE THAN ONE PERFECT PAIR,'/
     *  5X,'IF MCSCF USES SOME CISTEP OTHER THAN ALDET,'/
     *  5X,'IF MPLEVL=2 FOR RHF OR UHF WAVEFUNCTIONS,'/
     *  5X,'IF EXCITED STATE CIS FOR RHF WAVEFUNCTIONS,'/
     *  5X,'IF GROUND OR EXCITED STATE GUGA CI FOR RHF WAVEFUNCTIONS,'/
     *  5X,'IF SEMI-EMPIRICAL MODELS AM1, PM3, OR MNDO ARE USED,'/
     *  5X,'IF EFP, PCM, ONSAGER, OR COSMO SOLVENT MODELS ARE USED,'/
     *  5X,'IF THERE IS AN APPLIED EXTERNAL ELECTRIC FIELD,'/
     *  5X,'IF SCALAR RELATIVISTIC TRANSFORMATIONS ARE IN USE, OR'/
     *  5X,'IF RUNNING SCF-MI COMPUTATIONS.'//
     *  1X,'FULLY NUMERIC HESSIANS CAN BE COMPUTED WHEN ONLY THE',
     *     ' ENERGY IS AVAILABLE:'/
     *  5X,'WHEN MODEL CORE POTENTIAL INTEGRALS ARE USED,'/
     *  5X,'WHEN MPLEVL=2 FOR SCFTYP=ROHF/OSPT=RMP OR SCFTYP=MCSCF,'/
     *  5X,'WHEN CITYP IS SELECTED AND THE SCFTYP IS NOT RHF,'/
     *  5X,'WHEN THE CITYP SELECTED IS NOT CIS OR GUGA, OR'/
     *  5X,'WHEN ANY CCTYP IS SELECTED'/)
 9105 FORMAT(1X,'YOUR INPUT MISTAKENLY REQUESTED METHOD=',A8)
 9106 FORMAT(/15X,'* * * EFFICIENCY NOTE * * *'/
     *        1X,'THIS CALCULATION CAN BE RUN WITH DIFFERENTIATION',
     *           ' METHOD=',A8/
     *        1X,'THIS MIGHT BE MORE ACCURATE AND/OR FASTER THAN',
     *           ' YOUR CHOICE,'/
     *        1X,'BUT THE REQUESTED CALCULATION METHOD=',A8,
     *           ' IS PROCEEDING.'/)
      END
C*MODULE FMOHSS  *DECK FMOFCMOUT
      SUBROUTINE FMOFCMOUT(FCM,NCOORD)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION FCM(NCOORD,NCOORD)
      DIMENSION CLAB(3)
czcz
      character*4 cdum4(4)
      character*8 cdum8
czcz
C
      PARAMETER (MXATM=2000, MXFRG=1050,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FROZNC/ IFREEZ(3*MXATM),NFRZ
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
Cz    COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
CZ
      COMMON /FMCOM / X(1)
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
czcz
C
      DATA CLAB /4H   X,4H   Y,4H   Z/
      DATA HSSIAN/8HHESSIAN /
C
      IF(.NOT.MASWRK) RETURN
C
      WRITE(IW,9000)
C
      IF(IFREEZ(1).NE.0.AND.RUNTYP.EQ.HSSIAN.AND.MASWRK)
     *  WRITE (IW, 9005)
C
      cdum8 = '        '
      INCR= 2
      IF(NPRINT.EQ.6) INCR=4
      DO 140 MINCOL=1,NATfmo,INCR
         MAXCOL = MINCOL+INCR-1
         IF (MAXCOL .GT. NAT) MAXCOL = NATfmo
         ico = 0
         do ii = mincol, maxcol
           ico = ico + 1
CZ         ztmp = x(lfmomas+ii-1)
           iantmp = int(x(lfmozan+ii-1)+0.1D+00)
           call zsymnum(cdum8,cdum4(ico),iantmp)
         end do
         WRITE(IW,9010) (N,N = MINCOL,MAXCOL)
CZ       WRITE(IW,9020) (ANAM(N),BNAM(N),N = MINCOL,MAXCOL)
         WRITE(IW,9020) (cdum4(N),cdum8,N = 1,ico)
         WRITE(IW,9030) ((CLAB(M),M = 1,3),N = MINCOL,MAXCOL)
         J0 = 3*(MINCOL-1)+1
         J1 = 3*MAXCOL
         IFC=1
         DO 120 IAT = MINCOL,NATfmo+2*NFRG
            I0 = 3*(IAT-1)
            IF(IAT.LE.NATfmo) THEN
CZ             ztmp = x(lfmomas+iat-1)
               iantmp = int(x(lfmozan+iat-1)+0.1D+00)
               call zsymnum(cdum8,cdum4(1),iantmp)
               WRITE(IW,9040) IAT,cdum4(1),cdum8,CLAB(1),
     *                         (FCM(I0+1,J),J = J0,J1)
            ELSE
               IFCT=MOD(IAT-NAT,2)
               IF(IFCT.EQ.1) THEN
                 WRITE(IW,9050) IFC,CLAB(1),
     *                         (FCM(I0+1,J),J = J0,J1)
               ELSE IF(IFCT.EQ.0) THEN
                 WRITE(IW,9060) IFC,CLAB(1),
     *                         (FCM(I0+1,J),J = J0,J1)
               IFC=IFC+1
               END IF
            END IF
            WRITE(IW,9070) CLAB(2),(FCM(I0+2,J),J = J0,J1)
            WRITE(IW,9070) CLAB(3),(FCM(I0+3,J),J = J0,J1)
  120    CONTINUE
  140 CONTINUE
C                    TWO SETS OF COLUMNS (TRANSLATION AND ROTATION)
C                    FOR PRINTING THE FRAGMENT/FRAGMENT BLOCK
      DO 150 IFRG=1,NFRG
         WRITE(IW,9080) IFRG
         WRITE(IW,9030) ((CLAB(M),M = 1,3),N = 1,2)
         J0 = 3*NAT + 6*(IFRG-1) + 1
         J1 = J0 + 5
         DO 130 JFRG = IFRG,NFRG
            I0 = 3*NAT + 6*(JFRG-1)
            WRITE(IW,9050) JFRG,CLAB(1),(FCM(I0+1,J),J = J0,J1)
            WRITE(IW,9070)      CLAB(2),(FCM(I0+2,J),J = J0,J1)
            WRITE(IW,9070)      CLAB(3),(FCM(I0+3,J),J = J0,J1)
            WRITE(IW,9060) JFRG,CLAB(1),(FCM(I0+4,J),J = J0,J1)
            WRITE(IW,9070)      CLAB(2),(FCM(I0+5,J),J = J0,J1)
            WRITE(IW,9070)      CLAB(3),(FCM(I0+6,J),J = J0,J1)
  130    CONTINUE
  150 CONTINUE
      RETURN
C
 9000 FORMAT(/10X,31(1H-)/10X,'CARTESIAN FORCE CONSTANT MATRIX'/
     *        10X,31(1H-))
 9005 FORMAT(//1X,'THERE ARE FROZEN COORDINATES, ',
     *'PARTIAL HESSIAN ANALYSIS WILL BE DONE.'//1X,
     *'FOR THE FROZEN ATOMS AND FRAGMENTS, ',
     *'DIAGONAL MATRIX ELEMENTS ARE '/1X,'SET TO BE 1.0D-08,',
     *' ALL THE OTHER MATRIX ELEMENTS RELATED TO FROZEN '/1X,
     *'ATOMS AND FRAGMENTS ARE SET TO BE ZERO.'//)
 9010 FORMAT(/20X,4(12X,I4,11X))
 9020 FORMAT( 20X,4(11X,A8,A2,6X))
 9030 FORMAT( 20X,4(3X,A4,5X,A4,5X,A4,2X))
 9040 FORMAT(I3,3X,A8,A2,A4,12F9.6)
 9050 FORMAT(1X,'FRAG.',I3,1X,'TRANS.',A4,12F9.6)
 9060 FORMAT(1X,'FRAG.',I3,1X,'ROT.  ',A4,12F9.6)
 9070 FORMAT(16X,A4,12F9.6)
 9080 FORMAT(/20X,'FRAGMENT',I3,3X,'TRANSLATION',13X,'ROTATION ')
      END
C
C*MODULE FMOHSS  *DECK FMOESHSS
C>
C>    @brief ESP in FMO Hessian
C>
C>    @details Add ESP contributions to FMO Hessian. 
C>
C>    @author Hiroya Nakata 
C>     
C>    @param L1 : Number of atomic orbital
C>    @param L2 : Number of triangular matrix
C>    @param DA : For density, molecular orbital, eigen value
C>    @param SCFFRG : SCFTYP for each fragment
C>    @param IDMREC0 : Record for orbital
C>    @param DC :      Work 0
C>    @param WRK1 :    Work 1
C>    @param MAPI :    Orbital mapping for I
C>    @param MAPJ :    Orbital mapping for J
C>    @param MAP3 :    Dummy for FMO3
C>    @param MAXL1D :  Number of orbital
C>    @param IREC00 :  Record for orbital
C>    @param ORBXCH1 : Logic for reading orbital
C>    @param ENEXCH1 : Logic for reading energy
C>    @param KODEXCH : Orbital exchange for K
C>    @param JODEXCH : Orbital exchange for J
C>    @param IODEXCH : Orbital exchange for I
C>    @param NQMTFG  : Molecular orbital for fragment
C>    @param YALAG :   Response term for each I fragment
C>    @param IPTYA :   Pointer for response term
C>    @param YAWRK :   Response term for IJ fragment
C>    @param FCM :     Hessian force constant
C>    @param numfrg :  Number of atomic orbital for each I fragment
C>
      SUBROUTINE FMOESHSS(L1,L2,DA,SCFFRG,IDMREC0,DC,WRK1,
     *                    MAPI,MAPJ,MAP3,MAXL1D,IREC00,
     *                    ORBXCH1,ENEXCH1,KODEXCH,JODEXCH,IODEXCH,
     *                    NQMTFG,
     *                    YALAG,IPTYA,YAWRK,FCM,
     *                    numfrg)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=2000,MXSH=5000,MXGTOT=20000, MXRT=100 )
c     LOGICAL DIRSCF,FDIFF,PACK2E,GOPARR,DSKWRK,MASWRK,QFMM,QOPS
      LOGICAL ORBXCH1,ENEXCH1,KODEXCH,JODEXCH,IODEXCH
      LOGICAL LCFLAG,LRINT,CAMFLAG 
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION DA(*),SCFFRG(*),IDMREC0(*)
      DIMENSION DC(*),WRK1(*),MAPI(*),MAPJ(*),MAP3(MAXL1D,3)
      DIMENSION NQMTFG(*), numfrg(1)
C
      COMMON /DFTCAM/ ALPHAC,BETAC,CAMMU,CAMVWN,CAMLYP,CAMFLAG
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FMCOM / X(1)
c     COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
c     COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
C     COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NLRC  / LCFLAG,LRINT,EMU,EMU2,LRFILE
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
c     COMMON /OPTSCF/ DIRSCF,FDIFF
c     COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
c     COMMON /QMFM  / SIZE,EPS1,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
c    *                ITERMS,QOPS,ISCUT
c     COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
c     COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
c     COMMON /SHLEXC/ NORGSH(3),NORGSP(3),IEXCH,NANGM,NGTH(4)
c     COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
c    *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
c     COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
c    *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
c    *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
c    *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
c    *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
c    *                modlmo,nopden,mofock,modfd,modfmm,ncentm
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo
c     common /ppcpnt/ lddijpot,lzppcpot,lvipot,lgrdtest
c     COMMON /SCZLAG/ LZVLAG,LZVWRK,LYALAG,LYAWRK
c     COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
c    *                MPLEVL,MPCTYP
C
c     COMMON /GRAD  / DE(3,MXATM)
C   
C     FMO second derivative 
C     This subroutine calculate the contribution
C     which come from the Electrostatic Potential
C     For the detail mathmatical equation:  J. Chem. Phys. 138, 164103 (2013)
C      
C
      DIMENSION YALAG(*),IPTYA(*),YAWRK(*),FCM(3*natfmo,*)
C
      CALL TIMIT(1)
      IF(MASWRK) WRITE(IW,*) 'BEGIN FMOESHSS'
C
      LWRKDEN =LFMOBUF(1) ! MAXL1D+MAXL2D+MAXL3D
      LWRKESP =LFMOBUF(2) ! MAXL2D
      IFG=ICURFG
      JFG=JCURFG
      L1IJ=L1
      L2IJ=L2
      IF(IFG.EQ.0) RETURN
      L1I  = IAND(NUMFRG(IFG),65535)
      IF (JFG.NE.0) THEN
        L1J  = IAND(NUMFRG(JFG),65535)
      END IF
      L2I   = (L1I*L1I + L1I)/2
      L2J   = (L1J*L1J + L1J)/2
      NDSIJ = L2  * NAT  * 3
C
      LCFLAG=.FALSE.
      camFLAG=.FALSE.
      LRINT=.FALSE.
C
      CALL DERCHK(NDER)
      if(nder.ne.2) call abrt
C 
      CALL MONBSR(NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,NSHELL,NGAU,ENUCR,
     *            NAT0,ICH0,MUL0,NUM0,NQMT0,NE0,NA0,NB0,
     *            NCURSH,NGAU0,ENUCR0)
C 
      IESDPPC = 1
C    allocate memory 
      CALL VALFM(LOADFM)
      LEG  = LOADFM + 1
      LEH  = LEG    + 3 *  NATFMO
      LFD  = LEH    + 9 * (NATFMO*NATFMO+NATFMO)/2
      LAST = LFD    + 3 *  NATFMO * L2 
      NEED = LAST-LOADFM-1
      CALL GETFM(NEED)
CZ
      NFD  = 3*NATFMO*L2
      NEGH = 3*NATFMO+9*(NATFMO*(NATFMO+1))/2
c
      call vclr(x(leg),1,NEGH)
      call vclr(x(lfd),1,NFD)
C     Get Density ||  S^{a,I} || S^{a,J}
CZ    DA is  Delta DIJ - DI - DJ
      call ESDDVDD(l1,l2,DA,X(LFMODB),DC,X(LWRKDEN),WRK1,
     *     X(LFMOESPA),X(LWRKESP),X(LNUMFRG),MAPI,MAPJ,MAP3,
     *     MAXL1D,IREC00,ORBXCH1,ENEXCH1,
     *     KODEXCH,JODEXCH,IODEXCH,NQMTFG, scffrg,0,
     *     l1i,l1j)
c     Second derivative for one-electron terms
      call esddv1d(DA,LEG,LEH,LFD)
c     Second derivative for two-electron terms
      kfg = 0
      call esddv2d(IFG,JFG,KFG,L1IJ,L1I,L1J,l1k,nak,nbk,natk,
     *     X(LFMOESPA),X(LIAGLOB),X(LEG), X(LEH),l2ij,NQMTFG,
     *     X(LFMODB),X(LWRKDEN),x(LLAYFRG),IDMREC0,DA,x(LFD),FCM)
C     summing up contribution (\Delta D * V^ab)
      call addhss(natfmo,natfmo,x(LEH),FCM,0,x(liaglob))
C
      CALL MONBSR(NAT0,ICH0,MUL0,NUM0,NQMT0,NE0,NA0,NB0,NCURSH,NGAU0,
     *           ENUCR0,NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,NSHELL,NGAU,ENUCR)
C
      NCURSH = 0
C
      CALL VALFM(LOADFM)
      LDSIJ  = LOADFM + 1
      LAST   = LDSIJ  + NDSIJ
      NEEDIJ = LAST-LOADFM-1
      CALL GETFM(NEEDIJ)
C
c     calcualting S^a * V^b terms in ( fmohss1a.src )
      call ESPSDXVD(l1,l2,X(LFMODB),X(LWRKDEN),WRK1,
     *     X(LNUMFRG),MAPI,MAPJ,MAP3, x(liaglob), MAXL1D,IREC00,
     *     ORBXCH1, KODEXCH,JODEXCH,IODEXCH,NQMTFG, scffrg,0,
     *     x(LDSIJ),l1i,l2i,x(LDSIJ),l1j,l2j,x(LDSIJ),l2ij,x(LFD),
     *     NQMT0,FCM,YALAG,IPTYA,YAWRK)
c     
      NQMT = NQMT0
C
      CALL RETFM(NEEDIJ)
      CALL RETFM(NEED)

      IF(MASWRK) WRITE(IW,*) 'DONE FMOESHSS'
      CALL TIMIT(1)
      return
      end

C*MODULE FMOHSS  *DECK ESDDVDD
C>
C>    @brief Density contributions from ESP for FMO Hessian
C>
C>    @details Construct density difference matrix
C>             DIJ - DI - DJ for FMO Hessian.
C>
C>    @author Hiroya Nakata 
C>
C>    @param l1 : Number of atomic orbital
C>    @param l2 : Number of triangular matrix for Density
C>    @param DA : Density, orbital, and eigen value
C>    @param DB : Work 0
C>    @param DC : Work 1
C>    @param WRK : Work 3
C>    @param WRK1 : Work 4
C>    @param ESPA : Electro static potential
C>    @param WRKESP : WRK for ESP terms
C>    @param NUMFRG : Number of atomic orbital for each fragment
C>    @param MAPI :   Mapping for I fragment orbital
C>    @param MAPJ :   Mapping for J fragment orbital
C>    @param MAP3 :   Dummy for K fragment
C>    @param MAXL1D : Maximum atomic orbital 
C>    @param IREC0 :  Record for reading orbital
C>    @param ORBXCH1 : Logic for reading orbital
C>    @param ENEXCH1 : Logic for reading energy
C>    @param KODEXCH : Logic for reading orbital for K
C>    @param JODEXCH : Logic for reading orbital for J
C>    @param IODEXCH : Logic for reading orbital for I
C>    @param NQMTFG  : Number of molecular orbital 
C>    @param scffrg  : SCFTYP for each fragment 
C>    @param IMODE   : Option for job mode
C>    @param l1i :     Number of atomic orbital for I fragment
C>    @param l1j :     Number of atomic orbital for J fragment
      subroutine ESDDVDD(l1,l2,DA,DB,DC,WRK,WRK1,
     *     ESPA,WRKESP,NUMFRG,MAPI,MAPJ,MAP3,
     *     MAXL1D,IREC0,ORBXCH1,ENEXCH1,
     *     KODEXCH,JODEXCH,IODEXCH,NQMTFG,
     *     scffrg,IMODE,l1i,l1j)

      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXATM=2000,ONE=1.0D+00)
C
c     LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL SOME1,ORBXCH1,ENEXCH1
      LOGICAL KODEXCH,JODEXCH,IODEXCH
C
C
      DIMENSION DA(1),DB(1),DC(1)
      DIMENSION ESPA(1),WRK(1),WRK1(1),WRKESP(1)
      DIMENSION NUMFRG(1),NQMTFG(*)
      DIMENSION MAPI(1),MAPJ(1),MAP3(MAXL1D,3) 
      DIMENSION scffrg(*)
c     DIMENSION DSI(l2i,*),DSJ(l2j,*),DSIJ(l2ij,*)
C
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
c     COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
c     COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
c     COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
c    *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
c    *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
c    *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
c    *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
c    *                MODLMO,NOPDEN,MOFOCK,modfd,modfmm,ncentm
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
CZ    COMMON /SCZVEC/ IDFZVEC,LIPTZVEC,LIPTLG
c     COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
c    *                MPLEVL,MPCTYP
c     COMMON /GRAD  / DE(3,MXATM)
      DATA   UHF/8HUHF     / 
CZ
CZ    DENSITY DERIVATIVES OF EXTERNAL ELECTROSTATIC POTENTIALS
CZ
C     dummy argument it is used later implementation
      DC(1)=0.0D+00
      DUM  = ESPA(1)
      if(imode.ne.0) write(*,*) "imode =",
     * imode,map3(1,1),nqmtfg(1),kodexch
C
      IFG=ICURFG
      JFG=JCURFG
      l3 =l1 * l1

C     Notice record number 16 is written by diminid  subroutine
      CALL DAREAD(IDAF,IODA,da(l2+1),L3,15,0)
      call dmtx2(wrkesp,da(l2+1),na,l1,l1,na) 

      L1I  = IAND(NUMFRG(IFG),65535)
      NAI  = ISHFT(NUMFRG(IFG),-16)
c     NATI = IXFTCH(X(LNATFRG),IFG)
      MULI = IXFTCH(X(LMULFG),IFG)
      NBI  = NAI-MULI+1
      NQI  = IAND(NQMTFG(IFG),65535)
      IF (JFG.NE.0) THEN
        L1J  = IAND(NUMFRG(JFG),65535)
        NAJ  = ISHFT(NUMFRG(JFG),-16)
c       NATJ = IXFTCH(X(LNATFRG),JFG)
        MULJ = IXFTCH(X(LMULFG),JFG)
        NBJ  = NAJ-MULJ+1
        NQJ  = IAND(NQMTFG(JFG),65535)
      END IF
c
      some1=.False.
      CALL DIMINID(0,JFG,IFG,L1J,L1I,NQJ,NQI,NAJ,NAI,NBJ,NBI,L1,DA,DB,
     *             WRK,WRK1,X(LIODFMO),IREC0,X(LIABDFG),X(LJABDFG),
     *             X(LINDAT),X(LIAGLOB),X(LLOCFMO),MAPJ,MAPI,
     *             ORBXCH1,ENEXCH1,JODEXCH,IODEXCH,0,DUM,1,
     *             scffrg(jfg).eq.uhf,scffrg(ifg).eq.uhf,some1)

      CALL DAXPY(L2,-ONE,WRKESP,1,DA,1)
      CALL DSCAL(L2,-ONE,DA,1)
c     NCURS  = NCURSH
c     NCURSH = 0
c     write(*,*) "check density"
c     call prtril(DA,L1)
C
C
c     CALL MAKEMOL(IFG,0,0,ILAY,0,0,0,0,0,0,0,.FALSE.)
c     CALL EXTSDER(WRK,DSI,L1I,L2I,.TRUE.,.TRUE.,0)
c     IF(GOPARR) CALL DDI_GSUMF(1501,DSI,L2I*3*NATI)
C
c     CALL MAKEMOL(JFG,0,0,ILAY,0,0,0,0,0,0,0,.FALSE.)
c     CALL EXTSDER(WRK,DSJ,L1J,L2J,.TRUE.,.TRUE.,0)
c     IF(GOPARR) CALL DDI_GSUMF(1501,DSJ,L2J*3*NATJ)
C
c     CALL MAKEMOL(IFG,JFG,0,ILAY,0,0,0,0,0,0,0,.true.)
c     CALL EXTSDER(WRK,DSIJ,L1,L2IJ,.TRUE.,.TRUE.,0)
c     IF(GOPARR) CALL DDI_GSUMF(1501,DSIJ,L2IJ*3*NAT)

c     NCURSH = NCURS  
      return
      end
C
C*MODULE FMOHSS  *DECK YALGMEM1
C>
C>    @brief Measure size of Ya
C>
C>    @details Get total dimension of  U^{a} and max dimension of U^{a,X}.
C>
C>    @author Hiroya Nakata 
C>
C>    @param NYA :   Number of total response term
C>    @param MXYAWK :Maximum number of response term for IJ
C>    @param NFG :   Number of fragment
C>    @param NQMTFG :Number of molecular orbital for each fragment
C>    @param scffrg :SCFTYP for each fragment 
C>    @param mulfg  :Multiplicity for each fragment 
C>    @param natfrg :Number of atom for each fragment 
C>
      SUBROUTINE YALGMEM1(NYA,MXYAWK,NFG,NQMTFG,scffrg,mulfg,natfrg)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION NQMTFG(1),natfrg(1)
C     FOR UHF 
      DIMENSION mulfg(nfg),scffrg(nfg)
      DATA UHF/8HUHF     /
c
C     dummy arguments
      if(scffrg(1).eq.uhf) write(*,*) "mulfg=",mulfg(1)
c
      NYA = 0
      MXYAWK = 0
      DO I = 1, NFG
        NQMT = IAND(NQMTFG(I),65535)
        NAI  = ISHFT(NQMTFG(I),-16)
        NOCV = NAI * (NQMT - NAI)
        NXYZI= natfrg(i) * 3
c       write(*,*) "NXYZI NOCV = ",NXYZI,NOCV
        NYA  = NYA + NOCV * NXYZI
        DO j=1,I-1
           NXYZJ = natfrg(j) * 3
           NATOMT= NXYZI + NXYZJ
           MXYAWK= max(MXYAWK,NATOMT)
c          write(*,*) " NATOMT = " , NATOMT
        END DO
      END DO
C
      RETURN
      END
c
C*MODULE FMOHSS* DECK YALGMEM2 
C>
C>    @brief Mapping for U^a
C>
C>    @details Get point for respective U^{a,X}.
C>
C>    @author Hiroya Nakata 
C>
C>    @param NFG    : Number of fragment
C>    @param IPTLG  : Mapping for response term
C>    @param NQMTFG : Number of molecular orbitlal for each fragment
C>    @param scffrg : SCFTYP for each fragmnets
C>    @param mulfg  : Multiplicity for each fragments
C>    @param natfrg : Number of atom for each fragment
C>
      SUBROUTINE YALGMEM2(NFG,IPTLG,NQMTFG,scffrg,mulfg,natfrg)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION IPTLG(1),NQMTFG(1),natfrg(1)
c     For UHF fragment
      DIMENSION mulfg(nfg),scffrg(nfg)
      DATA UHF/8HUHF     /
c
C     dummy arguments
      if(scffrg(1).eq.uhf) write(*,*) "mulfg=",mulfg(1)
C
      IPT = 1
      DO I = 1, NFG
        IPTLG(I) = IPT
        NQMT =  IAND(NQMTFG(I),65535)
        NAI  = ISHFT(NQMTFG(I),-16)
        NOCV = NAI * (NQMT - NAI)
        NXYZI= natfrg(i) * 3
c       write(*,*) "NXYZI NOCV = ",NXYZI,NOCV
        IPT = IPT + NOCV * NXYZI
      END DO
      IPTLG(NFG+1) = IPT - 1
C
      RETURN
      END
C
C*MODULE FMOHSS  *DECK addhss
C>
C>    @brief   Add V^{ab} contributions to FMO Hessian
C>
C>    @details Add FCMWRK to FCM.
C>
C>    @author Hiroya Nakata 
C>
C>    @param nat    : Number of atom in the fragmet
C>    @param natfmo : Number of atom in the system
C>    @param FCMWRK : Temporaly Force constant
C>    @param FCM    : Total Force constant for ESP
C>    @param imode  : Job type
C>    @param iaglob : global atom label
C>
      subroutine addhss(nat,natfmo,FCMWRK,FCM,imode,iaglob) 
      implicit double precision(A-H,O-Z)
c    
      DIMENSION FCMWRK(9,(nat*nat+nat)/2)
      DIMENSION FCM(natfmo*3,natfmo*3),iaglob(*)
c
      do iatom = 1,nat
         do jatom = 1,iatom
            if(imode.eq.0) then
              ij = (iatom * iatom - iatom)/ 2 + jatom 
              ix = (iatom-1) * 3 + 1
              iy = (iatom-1) * 3 + 2
              iz = (iatom-1) * 3 + 3
              jx = (jatom-1) * 3 + 1
              jy = (jatom-1) * 3 + 2
              jz = (jatom-1) * 3 + 3
            else if(imode.eq.1) then
              ij = (iatom * iatom - iatom)/ 2 + jatom 
              ix = (iaglob(iatom)-1) * 3 + 1
              iy = (iaglob(iatom)-1) * 3 + 2
              iz = (iaglob(iatom)-1) * 3 + 3
              jx = (iaglob(jatom)-1) * 3 + 1
              jy = (iaglob(jatom)-1) * 3 + 2
              jz = (iaglob(jatom)-1) * 3 + 3
            end if
            if(iatom.ne.jatom) then
               FCM(ix,jx) = FCM(ix,jx) + FCMWRK(1,ij) 
               FCM(ix,jy) = FCM(ix,jy) + FCMWRK(2,ij)
               FCM(ix,jz) = FCM(ix,jz) + FCMWRK(3,ij)
               FCM(iy,jx) = FCM(iy,jx) + FCMWRK(4,ij)
               FCM(iy,jy) = FCM(iy,jy) + FCMWRK(5,ij)
               FCM(iy,jz) = FCM(iy,jz) + FCMWRK(6,ij)
               FCM(iz,jx) = FCM(iz,jx) + FCMWRK(7,ij)
               FCM(iz,jy) = FCM(iz,jy) + FCMWRK(8,ij)
               FCM(iz,jz) = FCM(iz,jz) + FCMWRK(9,ij)
C
               FCM(jx,ix) = FCM(jx,ix) + FCMWRK(1,ij) 
               FCM(jy,ix) = FCM(jy,ix) + FCMWRK(2,ij)
               FCM(jz,ix) = FCM(jz,ix) + FCMWRK(3,ij)
               FCM(jx,iy) = FCM(jx,iy) + FCMWRK(4,ij)
               FCM(jy,iy) = FCM(jy,iy) + FCMWRK(5,ij)
               FCM(jz,iy) = FCM(jz,iy) + FCMWRK(6,ij)
               FCM(jx,iz) = FCM(jx,iz) + FCMWRK(7,ij)
               FCM(jy,iz) = FCM(jy,iz) + FCMWRK(8,ij)
               FCM(jz,iz) = FCM(jz,iz) + FCMWRK(9,ij)
            else
               FCM(ix,jx) = FCM(ix,jx) + FCMWRK(1,ij) 
               FCM(ix,jy) = FCM(ix,jy) + FCMWRK(2,ij)
               FCM(ix,jz) = FCM(ix,jz) + FCMWRK(3,ij)
               FCM(iy,jx) = FCM(iy,jx) + FCMWRK(4,ij)
               FCM(iy,jy) = FCM(iy,jy) + FCMWRK(5,ij)
               FCM(iy,jz) = FCM(iy,jz) + FCMWRK(6,ij)
               FCM(iz,jx) = FCM(iz,jx) + FCMWRK(7,ij)
               FCM(iz,jy) = FCM(iz,jy) + FCMWRK(8,ij)
               FCM(iz,jz) = FCM(iz,jz) + FCMWRK(9,ij)
C
            end if 
         end do
      end do
      return
      end
c
C*MODULE FMOHSS  *DECK FMOCPHOP
C>
C>    @brief Add P^a contributions to CPHF equation 
C>
C>    @details Add (S DD S^a) contributions to FMO Hessian.
C>
C>    @author Hiroya Nakata 
C>
C>    @param nocc : Number of occupied orbital
C>    @param nvir : Number of virtual  orbital
C>    @param l1 :   Number of atomic orbital
C>    @param l2 :   Number of triangular orbital
C>    @param nxyz : Number of XYZ for each atom
C>    @param WAX :  Second order derivative of orbital and coordinate
C>    @param nrot : Number of independent pair
C>    @param AA :   Derivative of orbital coefficient
C>    @param nocc2 :Number of triangular matrix for occupied orbital
C>    @param SS :   Superposition integral
C>    @param SDER : Derivative of Superposition integral
C>    @param DD :   Projection matrix
C>    @param NAO :   Number of atomic orbital
C>    @param NMO :   Number of molecular orbital
C>    @param ILOC :  Position of atomic orbital
C>    @param PARRGO :Logic for paralization
C>    @param WRK3 :  Work 1
C>    @param nomit : Number of atomic orbital projected out from variation
C>
      SUBROUTINE FMOCPHOP(nocc,nvir,l1,l2,nxyz,WAX,nrot,AA,nocc2,
     *            SS,  SDER,DD,NAO,NMO,ILOC,PARRGO,WRK3,nomit)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
c     LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL PARRGO
      DIMENSION SDER(L2,3,NAT), DD(1),  SS(L1,*)
      DIMENSION WAX(nocc,nvir,*), AA(nocc2,*),WRK3(*)
C
      PARAMETER (ONE=1.0D+00,TWO=2.0D+00,MXATM=2000,MXAO=8192)
      PARAMETER (ZERO=0.0D+00)
c
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IJPAIR/ IA(MXAO)
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
c
      l3 = l1 * l1
      LC = L3 *  3 + 1
      if(nrot.eq.0) write(*,*) "dumm =",NMO,parrgo,NXYZ,lcrfrg
c     MAXIC = NATFMO
c     call setatz(1,MAXIC,fastvesp,lfvesp,needfv)
c      
      do 30 iatom = 1,nat
c       IAZ=IXFTCH(X(LIAGLOB),iatom)
c       icind=lfvesp+(IAZ-1)*6
c       FRACESPI=x(icind+1)
c       write(*,*) "fracespi =",fracespi,IAZ
        SCAL = TWO * TWO
c       if(fracespi.ge.0.5D+00.and.fracespi.ne.zero) go to 30
c       if(fracespi.ne.zero) go to 30
        do ixyz = 1,3          
          izxyz = (iatom - 1) * 3 + ixyz
          CALL CPYTSQ(SDER(1,ixyz,iatom),WRK3,l1,1)
          CALL CPYTSQ(DD,WRK3(l3+1),NAO,1)
C         S^a(l1,nao) * DD(NAO,NAO) *  S(l1,nao)^T
          CALL DGEMM('N','N',l1,NAO,NAO,ONE,WRK3(iloc*l1-l1+1),L1,
     *                wrk3(l3+1),NAO,ZERO, WRK3(L3*2+1),L1)
          CALL DGEMM('N','T',l1, l1,NAO,ONE,WRK3(l3*2+1),L1,
     *                SS(1,iloc),l1,ZERO, WRK3,L1)
          CALL SQ2TRI(L1,L1,WRK3,WRK3(l3+1),one)
C         C^T *  P * C   ( AO --> MO)
          CALL TFTRI(WRK3,wrk3(l3+1),wrk3(LC),WRK3(2*l3+1),NQMT,l1,l1)
C         summing up contributions
          do 10 iocc = 1,nocc 
            do 20 jocc = 1,iocc
              IJ = IA(IOCC) + JOCC
              AA(ij,izxyz) = AA(ij,izxyz) + WRK3(IJ) * SCAL 
c             if(iatom.eq.3.and.ixyz.eq.3) write(*,*) WRK3(IJ),IJ
 20         continue
 10       continue
c         do 15 ivir = 1,nvir
          do 15 ivir = 1,nvir-nomit
            do 25 iocc = 1,nocc
              ij = IA(nocc+ivir) + iocc
              WAX(iocc,ivir,izxyz)=WAX(iocc,ivir,izxyz)+WRK3(IJ)*SCAL
c             if(iatom.eq.3.and.ixyz.eq.3) write(*,*) "val=",WRK3(IJ),IJ
 25         continue
 15       continue
        end do
 30   continue
c
c     if(fastvesp) call retfm(needfv)
c
      return
      END
C
C*MODULE FMOHSS  *DECK FMOCPHOP2
C>
C>    @brief Add P^a contribution to CPHF equation 
C>
C>    @details Add (S DD^a S) contribution to CPHF equation.
C>
C>    @author Hiroya Nakata 
C>
C>    @param L1 :    Number of atomic orbital
C>    @param IRGHT : Label for detached atom in convalent bond
C>    @param LEFT  : Label for detached atom in convalent bond
C>    @param ILOC :  Position for atomic orbital
C>    @param PARRGO : Logic for paralization
C>    @param JJ :     Integer for convalent bond     
C>    @param JAT :    Atom number for convalent bond
C>    @param NAO :    Number of atomic orbital
C>    @param NMO :    Number of molecular orbital
C>    @param CLCAO :  Lotation for atomic orbital
C>    @param LDC :    Number for CLCAO matrix 
C>    @param ROTLCAO :For the projection of orbital
C>    @param LDR :    Number for ROTLCAO matrix
C>    @param NSHELL : Number of shell
C>    @param KATOM :  Number of atom for K fragment
C>    @param KTYPE :  Matrix for rotation
C>    @param KLOC :   Position for the atomic orbital
C>    @param KMIN :   Matrix for the rotation
C>    @param SHIFTB : Value for project out the BDA 
C>    @param IBDTYP : Type for bond
C>    @param IAPRJO : The Projected orbital for I fragment
C>    @param JAPRJO : The projected orbital for J fragment
C>    @param ISIDE  : Label for projection atom
C>    @param SS :     Matrix for Superposition integral 
C>    @param ZAXIS  : matrix for the rotation
C>    @param BOND   : matrix for the bond  
C>    @param WAX    : Second order derivative for Atom and orbital 
C>    @param AA     : Deriva of orbital
C>    @param WRK3   : Work 
C>    @param nomit  : Number of projected out orbital
C>    @param nocc :   Number of occupied orbital
C>    @param nvir :   Number of virtual orbital
C>    @param nocc2 :  Number of trianguler occupied orbital
C>
      SUBROUTINE FMOCPHOP2(L1,IRGHT,LEFT,ILOC,PARRGO,JJ,JAT,
     *                    NAO,NMO,CLCAO,LDC,ROTLCAO,LDR,NSHELL,
     *                    KATOM,KTYPE,KLOC,KMIN,SHIFTB,IBDTYP,
     *                    IAPRJO,JAPRJO,ISIDE, SS,ZAXIS,BOND,
     *                    WAX,AA,WRK3,nomit,nocc,nvir,nocc2)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXSH=5000, MXATM=2000,MXAO=8192)
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00,TWO=2.0D+00)
C
c     LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL PARRGO
      DIMENSION CLCAO(LDC,NMO),ROTLCAO(LDR,NMO),
     *          KATOM(*),KTYPE(*),KLOC(*),KMIN(*)
      DIMENSION SHIFTB(MAXCAO,*),IAPRJO(MAXCAO,*),JAPRJO(MAXCAO,*)
      DIMENSION SS(L1,*),ZAXIS(3),BOND(3)
      DIMENSION WAX(nocc,nvir,*), AA(nocc2,*),WRK3(*)
C
      COMMON /FMCOM / X(1)
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                TT(432),INVT(48),NT
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C 
C     COMPUTE DERIVATIVES OF HOP COEFFICIENTS
      if(l1.eq.0) write(*,*) "PARRGO =",PARRGO
C 
      CALL VALFM(LOADFM)
      LPTRD  = LOADFM + 1
      LDTRD  = LPTRD  + 3*3
      LFTRD  = LDTRD  + 6*6
      LGTRD  = LFTRD  + 10*10
      LDROT  = LGTRD  + 15*15
      LAST   = LDROT  + LDR*NAO

      NEED  = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
C     wrk1 : LWAX
C     wrk2 : LAA
C     wrk3 : l3 * 4 free space
      l3   = l1 * l1
      lc   = l3 *  3 + 1
      ilin = 0
      irin = 0
      DO iatom = 1, nat
        IAZ=IXFTCH(X(LIAGLOB),iatom)
        if(iaz.eq.LEFT ) ilin = iatom
        if(iaz.eq.IRGHT) irin = iatom
      END DO
c     write(*,*) "in fmohop =",nomit
      DO IC = 1, 3
        CALL VECROTDER(ISKIP,IC,ZAXIS,BOND,TT)
        IF (ISKIP.EQ.0) THEN
          CALL TRMATDER(X(LPTRD),X(LDTRD),X(LFTRD),X(LGTRD))
          CALL VCLR(X(LDROT),1,LDR*NAO)
          ! note that nao is reset here
          CALL ROTCAO(JJ,JAT,X(LPTRD),X(LDTRD),X(LFTRD),X(LGTRD),NAO,
     *                NMO,CLCAO,LDC,X(LDROT),LDR,NSHELL,KATOM,KTYPE,
     *                KLOC,KMIN,.TRUE.)
c
          CALL VCLR(WRK3,1,NAO*NAO+l3)
          DO IMO = 1, NMO
            if(iside.eq.0.and.iaprjo(imo,ibdtyp).ne.0.or.
     *         iside.ne.0.and.japrjo(imo,ibdtyp).ne.0) then

             BSHIFT = SHIFTB(imo,ibdtyp)
             CALL DGEMM('N','T',NAO,NAO,1,BSHIFT,X(LDROT+LDR*(IMO-1)),
     *                   LDR,ROTLCAO(1,IMO),LDR,ZERO,WRK3,NAO)
             CALL DAXPY(NAO*NAO,ONE,WRK3,1,WRK3(l3+1),1)
            end if
          END DO
          CALL SQ2TRI(NAO,NAO,WRK3(l3+1),WRK3(l3*2+1),one)
          CALL TFTRI0(WRK3(l3+1),WRK3(L3*2+1),SS(ILOC,1),WRK3,
     *                L1,NAO,L1)
c       C^T *  P * C   ( AO --> MO)
          CALL TFTRI(WRK3,wrk3(l3+1),wrk3(LC),WRK3(2*l3+1),NQMT,l1,l1)
          do 10 iocc = 1,nocc 
            do 20 jocc = 1,iocc
             IJ = IA(IOCC) + JOCC
             ll = (ilin - 1) * 3 + IC
             kk = (irin - 1) * 3 + IC
c            write(*,*) "IJ =",IJ,nocc2,WRK3(IJ)
             if(ilin.ne.0) AA(IJ,ll) = AA(IJ,ll) - WRK3(IJ) *two*two
             if(irin.ne.0) AA(IJ,kk) = AA(IJ,kk) + WRK3(IJ) *two*two
 20         continue
 10       continue
c         write(*,*) "U-a P^b terms"
c         do 15 mm = 1,nvir
          do 15 mm = 1,nvir - nomit
            do 25 ii = 1,nocc
              ij = IA(nocc+mm) + ii
              ll = (ilin - 1) * 3 + IC
              kk = (irin - 1) * 3 + IC
c             write(*,*) "IJ =",IJ,WRK3(IJ)
             if(ilin.ne.0) 
     *          wax(ii,mm,ll) = wax(ii,mm,ll) - WRK3(IJ) * two * two
             if(irin.ne.0)                                          
     *          wax(ii,mm,kk) = wax(ii,mm,kk) + WRK3(IJ) * two * two
 25         continue
 15       continue
        END IF
      END DO
c
      CALL RETFM(NEED)
      RETURN
      END
C
C*MODULE FMOHSS  *DECK HOPSHSS
C>
C>    @brief Add P^ab contribution to FMO Hessian
C>
C>    @details Add P^ab contribution to FMO Hessian.
C>
C>    @author Hiroya Nakata 
C>
C>    @param L1 :   Number of atomic orbital
C>    @param L2 :   Number of triangular orbital 
C>    @param ILOC : Position of atomic orbital
C>    @param NAO :  Number of orbital for projection
C>    @param PARRGO :Logic for parilization
C>    @param SDER :  Derivative of superpose integral
C>    @param DD :    The projection matrix
C>    @param DENS :  Density matrix
C>    @param SS :    Matrix for Superpose integral
C>    @param WRK1 :  WRK1 
C>    @param WRK2 :  WRK2
C>    @param WRK3 :  WRK3
C>    @param FCM  :  Force constant matrix
C>
      SUBROUTINE HOPSHSS(L1,L2,ILOC,NAO,PARRGO,SDER,DD,DENS,SS,
     *                   WRK1,WRK2,WRK3,FCM)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      PARAMETER (MXATM=2000)
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00,two=2.0D+00)
  
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL PARRGO
      DIMENSION SDER(L2,*), DD(1), DENS(1), SS(L1,*)
      DIMENSION WRK1(L1,*), WRK2(L1,*),WRK3(*)
      DIMENSION FCM(natfmo*3,*)

      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
c     COMMON /SCZLAG/ LZVLAG,LZVWRK,LYALAG,LYAWRK
C
C     SDER is Overlap derivative, DD is projection matrix
C     DENS is Density matrix (density or symmetrized ZVEC)
C     SS   is Overlap matrix in the square form  
      if(l1.eq.0) write(*,*) "jjjjj =",PARRGO
      L3   = l1   * l1
      LC   = l3   * 3   + 1
c     NLOC = ILOC + NAO - 1
c     call vclr(FCM,1,negh)
c     write(*,*) "check01 =",NAO,ILOC
      CALL TFTRI0(WRK1,DD,SS(ILOC,1),WRK3,L1,NAO,L1)
      CALL TFTRI(WRK3(l3+1),wrk1,wrk3(LC),WRK3,NQMT,l1,l1)
      IJ = 0
      DO 130 I = 1,L1
         DO 120 J = 1,I
            IJ = IJ+1
            DUM = ZERO
            DO 110 K = 1,NA
               II  = LC + l1 * (K - 1)  + I - 1
               JJ  = LC + l1 * (K - 1)  + J - 1
               KK  = (K * K  - K)/2 + 1 + L3
               DUM = DUM+WRK3(KK)*WRK3(II)*WRK3(JJ)
  110       CONTINUE
c           WRK3(IJ) = DUM + DUM
            WRK3(IJ) = DUM 
  120    CONTINUE
  130 CONTINUE
C-
      do 200 iat =  1,nat
        IAZ=IXFTCH(X(LIAGLOB),IAT)
        do ixyz = 1,3
          izxyz = (iaz - 1) * 3 + ixyz
          ii    = (iat - 1) * 3 + ixyz 
c         CALL CPYTSQ(DENS,WRK3,L1,1)
          CALL CPYTSQ(SDER(1,ii),WRK2,L1,1)
          CALL CPYTSQ(WRK3,WRK3(L3+1),L1,1)
          CALL DGEMM('N','N',L1,L1,L1,ONE,WRK2,L1,wrk3(l3+1),L1,ZERO,
     *               WRK1,L1)
          do 100 jat = 1,nat
            JAZ=IXFTCH(X(LIAGLOB),JAT)
            do jxyz = 1,3
              jzxyz = (jaz - 1) * 3 + jxyz
              jj    = (jat - 1) * 3 + jxyz
              CALL CPYTSQ(SDER(1,jj),WRK2,L1,1)
              CALL DGEMM('N','N',L1,L1,L1,ONE,WRK1,L1,wrk2,L1,ZERO,
     *               WRK3(l3+1),L1)
              CALL CPYTSQ(DENS,WRK2,L1,1)
              val = ddot(l1*l1,WRK3(L3+1),1,WRK2,1) 
C   
              FCM(izxyz,jzxyz) =  FCM(izxyz,jzxyz) - val  
              FCM(jzxyz,izxyz) =  FCM(jzxyz,izxyz) - val  
c             write(*,*) "val01  =",val,izxyz,jzxyz
            end do
 100      continue          
        end do
 200  continue
C
C
      CALL VALFM(LOADFM)
      NGOTMX=LIMFM-LOADFM
c     
      LSX    = 1     + LOADFM
      LSY    = LSX   + L2
      LSZ    = LSY   + L2
      LDSDX  = LSZ   + L2
      LDSDY  = LDSDX + L3
      LDSDZ  = LDSDY + L3
      LDE    = LDSDZ + L3
      LDH    = LDE   + NAT * 3
      LAST   = LDH   + (NAT+NAT*NAT)*9/2
      NEED   = LAST  - LSX
      IF(NEED.GT.NGOTMX) THEN
         IF (MASWRK) WRITE(*,*) 'IN SD, NEED,NGOT=',NEED,NGOTMX
         CALL ABRT
      END IF
      CALL GETFM(NEED)
c 
      NEGH = 3*NAT+9*(NAT*(NAT+1))/2
      CALL VCLR(X(LDE),1,NEGH)
      CALL VCLR(X(LDSDX),1,L3)
      CALL VCLR(X(LDSDY),1,L3)
      CALL VCLR(X(LDSDZ),1,L3)
C
      CALL DSCAL(L2,two,wrk3,1)
C
      CALL SDSPD(X(LDE),x(LDH),WRK3,X(LSX),X(LSY),X(LSZ),
     *           X(LDSDX),X(LDSDY),X(LDSDZ),.false.,WRK1,.false.)
      IF(GOPARR) CALL DDI_GSUMF(1625,x(LDE),NEGH)
      call addhss(nat,natfmo,x(LDH),FCM,1,x(liaglob))
C
C-
C
      CALL RETFM(NEED)
      RETURN
      END
C
