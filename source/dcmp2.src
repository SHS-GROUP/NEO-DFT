C 30 JAN 12 - SAN - CHANGED /CXTHRM/
C 28 DEC 11 - DGF - ALTER PAROUT 
C 15 APR 11 - MK,MK - ALLOW IMS-MP2, AO/MO CUTOFFS, TRANSPOS. SPEEDUPS
C 11 AUG 10 - DGF - SYNCH COMMON BLOCK ENRGYS
C 25 MAR 10 - MK  - SAVE SCS-MP2 ENERGY IN /ENRGMP/, CODE=DDI NOW WORKS
C 14 OCT 09 - DGF - PAD ENRGMP
C 12 JAN 09 - MK  - IMPLEMENTATION OF DIVIDE-AND-CONQUER MP2
C
C*MODULE DCMP2   *DECK MP2DC
      SUBROUTINE MP2DC
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DOUBLE PRECISION IMS
C
      LOGICAL DBUG,OUTPUT,TDSKWRK
      LOGICAL DODCCR,ONLYOC,RMKORB,FZCORE,DOMP1,HFFRM
      LOGICAL GOPARR,DSKWRK,MASWRK,PACK2E
      LOGICAL DIRSCF,FDIFF,SCHWRZ
C
      PARAMETER (MXRT=100, MXATM=2000, MXAO=8192, MXGTOT=20000,
     *           MXSH=5000, MXGSH=30, MXG2=MXGSH*MXGSH)
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      COMMON /COMPE2/ E2PARA,E2OPOS
      COMMON /DIRMEM/ LPQRJ,IVEC,IDEN,IFCK,NNUM,NNOCC,NNDIM,MINPQ,MAXPQ
      COMMON /ENRGMP/ EMP2,EMP3,EMP4,EMP2A
      COMMON /ENRGYS/ ENUC,EELEC,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FMCOM / X(1)
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOL,METHOD,NWDMP2,MEMPRI,MPPROP,
     *                NACORE,NBCORE,NOA,NOB,NO,NBF,NOMIT,MOCPHF,MAXITC
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      LOGICAL DCFLG
      COMMON /DCCORR/ RBUFCR,WOCC,ISTCOR,ITPART,DODCCR,ONLYOC,RMKORB,
     *                FZCORE,DOMP1,HFFRM
      COMMON /DCFRM / FRMLVA,FRMLVB,FRBETA,FTOL,MXITDC
      COMMON /DCOPT / SUBTYP,BUFTYP,SUBLNG,BUFRAD,NDCPRT,NSUBS,DCFLG
      COMMON /DCQMT / NLQMT(MXATM)
      COMMON /IODC  / IDCSUB,IDCVEC,IDCDM,IDCQ,IDCDMO,IDCEIG,IDCW,IDCEDM
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
      COMMON /SUBSP / ILCST1(MXATM),NLC1,LNUMMX,ILATST(MXATM),NLCAT1
C
C     SCS PARAMETER IN THE LITERATURE
C     (J. CHEM. PHYS. 118, 9095 (2003))
      PARAMETER (FOPOS=1.2D+00, FPARA=1.0D+00/3.0D+00, HALF=0.5D+00)
C
      DATA DBUGME,DEBUG /8HMP2DC   ,8HDEBUG   /
      DATA RHF/8HRHF     /
      DATA DDI/8HDDI     /
      DATA IMS/8HIMS     /
      DATA ANONE/8HNONE    /
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00, UNITS=0.52917724924D+00)
      PARAMETER (TWO=2.0D+00, VLN10=2.30258509299405D+00)
C
C     --------------------------------------------
C     DIVIDE-AND-CONQUER SUBSYSTEM MP2 CALCULATION 
C               CODED BY M. KOBAYASHI (SERIAL/DDI)
C                        M. KATOUDA (IMS)
C     --------------------------------------------
C
      DBUG   = MASWRK .AND. (EXETYP.EQ.DEBUG .OR. EXETYP.EQ.DBUGME)
      OUTPUT = MASWRK
C
      NUM1=NUM
      NUM2=NUM1*(NUM1+1)/2
      NUM3=NUM1*NUM1
      NSH2 = (NSHELL*NSHELL+NSHELL)/2
C
      CALL BASCHK(LMAX)
                    NANGM =  4
      IF(LMAX.EQ.2) NANGM =  6
      IF(LMAX.EQ.3) NANGM = 10
      IF(LMAX.EQ.4) NANGM = 15
      IF(LMAX.EQ.5) NANGM = 21
      IF(LMAX.EQ.6) NANGM = 28
      MAXG = NANGM**4
C
      IF(OUTPUT) WRITE(IW,9000)
      IF(OUTPUT.AND.CODEMP.EQ.DDI) WRITE(IW,9005)
C
C  PREPARE DEFAULT VALUES
C
      IF(RBUFCR.LE.ZERO)          RBUFCR=BUFRAD
      IF(RBUFCR.NE.BUFRAD)        RMKORB=.TRUE.
      IF(.NOT.DCFLG .AND. DODCCR) RMKORB=.TRUE.
      IF(WOCC.NE.ONE)             ONLYOC=.FALSE.
C
      IF(OUTPUT) WRITE(IW,9010) ISTCOR,DOMP1,ONLYOC,WOCC,RMKORB,HFFRM,
     *                          RBUFCR,RBUFCR*UNITS
C
C  MP2 PROPERTIES ARE NOT AVAILABLE IN DC-MP2
C  PRINT WARNING IF MP2PRP=.T. (MPPROP.EQ.1)
C
      IF(MPPROP.EQ.1) THEN
         IF(MASWRK) WRITE(IW,9900)
         MPPROP=0
      END IF
C
C  IMS-MP2 IS AVAILABLE ONLY IN DIRECT CALCULATIONS
C
      IF((.NOT.DIRSCF) .AND. (CODEMP.EQ.IMS)) THEN
         IF(MASWRK) WRITE(IW,9950)
         CALL ABRT
      END IF
C
C  AT PRESENT, IMS-MP2 IS ONLY AVAILABLE WHEN ONLYOC=.TRUE.
C
      IF((.NOT.ONLYOC) .AND. (CODEMP.EQ.IMS)) THEN
         IF(MASWRK) WRITE(IW,9960)
         CALL ABRT
      END IF
C
C  IF RMKORB=.TRUE. RECONSTRUCT DC SUBSYSTEMS
C
      IF(RMKORB) THEN
         IF(.NOT.DCFLG) THEN
           IDCSUB=250
           IDCVEC=251
           IDCDMO=254
           IDCQ  =255
           CALL SEQOPN(IDCSUB,'DCSUB', 'UNKNOWN',.FALSE., 'UNFORMATTED')
           CALL SEQOPN(IDCVEC,'DCVEC', 'UNKNOWN',.FALSE., 'UNFORMATTED')
           CALL SEQOPN(IDCDMO,'DCDMO', 'UNKNOWN',.FALSE., 'UNFORMATTED')
           CALL SEQOPN(IDCQ,  'DCQ',   'UNKNOWN',.FALSE., 'UNFORMATTED')
           CALL VALFM(LOADFM)
           LEIG = LOADFM + 1
           LAST = LEIG   + NUM1
           NEED = LAST   - LOADFM - 1
           CALL GETFM(NEED)
           CALL DAREAD(IDAF,IODA,X(LEIG),NUM1,17,0)
           FRMLVA=(X(LEIG+NA-1)+X(LEIG+NA))/TWO
           CALL RETFM(NEED)
         END IF
         CALL DFLCST(1,.TRUE.)
      END IF
C
      L1SUB=NSUBS
C
C  ALLOCATE TOTAL SYSTEM ARRAYS
C
      CALL VALFM(LOADFM)
      LEIGT = LOADFM + 1
      LST   = LEIGT  + NLC1
      LFT   = LST    + NUM2
      LESUB = LFT    + NUM2
      LESOCC= LESUB  + L1SUB
      LESVIR= LESOCC + L1SUB
      LESSCS= LESVIR + L1SUB
      LASTT = LESSCS + L1SUB
C
      LDT   = LASTT
      LESOC1= LASTT
      LESVI1= LASTT
      LIBUF = LASTT
      LWRK1 = LASTT
      IF(DOMP1) THEN
         LESOC1= LDT    + NUM2
         LESVI1= LESOC1 + L1SUB
         LWRK1 = LESVI1 + L1SUB
         LASTT = LWRK1  + NUM3
         IF(DIRSCF) THEN
            LBUF  = LASTT
            LIBUF = LASTT
            LXINTS= LASTT
            LGHOND= LXINTS + NSH2
            LDSH  = LGHOND + MAXG
            LDDIJ = LDSH   + NSH2
            LWRK2 = LDDIJ  + 49*MXG2
            LASTT = LWRK2  + NUM2
         ELSE
            LXINTS= LASTT
            LGHOND= LASTT
            LDSH  = LASTT
            LDDIJ = LASTT
            LWRK2 = LASTT
            LBUF  = LASTT
            LIBUF = LBUF   + NINTMX
            LASTT = LIBUF  + NINTMX
         END IF
      END IF
C
      NEEDT = LASTT  - LOADFM -1
C
      CALL GETFM(NEEDT)
C
      CALL DAREAD(IDAF,IODA,X(LFT),NUM2,14,0)
      CALL DAREAD(IDAF,IODA,X(LST),NUM2,12,0)
C
      IF(RMKORB) THEN
C
C  RECONSTRUCTION OF SUBSYSTEM ORBITALS 
C
         FRMOLD=FRMLVA
         CALL ORBRMK(X(LST),X(LFT),DUMMY,X(LEIGT),DUMMY,NUM1,NUM2,
     *               NLC1,NSUBS,DBUG,0)
C
         IF(DOMP1) THEN
C     *** CONSTRUCT DENSITY MATRIX IF DOMP1 ***
            CALL SEQREW(IDCDMO)
            CALL SEQREW(IDCVEC)
            DO 200 ISUB=1,NSUBS
C
C           LOAD BALANCER
C
CPA               LTSKDC=ISUB-1
CPA               IF (DLBDC) THEN
CPA                 DTSKDC = LTSKDC.EQ.MTSKDC
CPA               ELSE 
CPA                 DTSKDC = MOD(LTSKDC,NPROC).EQ.ME
CPA               END IF
C
CPA               IF (DTSKDC) THEN
C
               CALL LOCREG(ISUB)
               LSUB1=LNUM
               LSUB3=LSUB1*LSUB1
               LSUB2=(LSUB3+LSUB1)/2
C
               CALL VALFM(LOADFM)
               LEIGLC= LOADFM+1
               LOCCLC= LEIGLC+ LSUB1
               LDALC = LOCCLC+ LSUB1
               LVECLC= LDALC + LSUB2
               LAST  = LVECLC+ LSUB3
C
               NEEDLC = LAST - LOADFM - 1
               CALL GETFM(NEEDLC)
C
               CALL SQREAD(IDCVEC,X(LVECLC),LSUB3)
               CALL DCOPY(LSUB1,X(LEIGT+ILCST1(ISUB)-1),1,X(LEIGLC),1)
C
               CALL VCLR(X(LOCCLC),1,LSUB1)
C
C              --- OCCUPATION NUMBERS IN DC METHOD ---
C                                        DC OCCUPANCIES
               I=1
               VAL=FRMLVA-X(LEIGLC+I-1)
               XFTOL= VLN10*FTOL/FRBETA
C
C              VALUE OF FERMI FUNCTION IS CLOSE TO ONE
               DO WHILE (I.LE.LSUB1 .AND. VAL.GT.XFTOL)
                  X(LOCCLC+I-1) = TWO
                  I=I+1
                  VAL=FRMLVA-X(LEIGLC+I-1)
               END DO
C
C           VALUE OF FERMI FUNCTION IS NOT CLOSE TO EITHER ZERO OR ONE
               DO WHILE (I.LE.LSUB1 .AND. VAL.GE.-XFTOL)
                  X(LOCCLC+I-1) = TWO * FERMIF(VAL,FRBETA)
                  I=I+1
                  VAL=FRMLVA-X(LEIGLC+I-1)
               END DO
C
               NOCDC=I-1
C
C        --- FORM THE NEW DENSITY MATRIX ---
C
               CALL DMTX(X(LDALC),X(LVECLC),X(LOCCLC),NOCDC,LSUB1,LSUB1)
               CALL SQWRIT(IDCDMO,X(LDALC),LSUB2)
C
               CALL RETFM(NEEDLC)
C
CPA               IF (DLBDC) CALL DDI_DLBNEXT( MTSKDC )
CPA               END IF       !  LOAD BALANCER
C
  200       CONTINUE
C
CPA            GOPARR=PRSAVE
C
CPA            IF(GOPARR) THEN
CPA               CALL DDI_GSUMF(11104,X(LDT),NLC2)
CPA            END IF
C
         END IF
      ELSE
         CALL SEQREW(IDCEIG)
         CALL SQREAD(IDCEIG,X(LEIGT),NLC1)
      END IF
C
C CONSTRUCT FOCK MATRIX IF DOMP1
C
      IF(DOMP1) THEN
         IF(RMKORB) THEN
            CALL TRLC2T(IDCDMO,X(LDT),DUMMY,X(LWRK1),NUM1,NUM2,
     *                  'DENSITY ',.TRUE.,.FALSE.)
         ELSE
            CALL TRLC2T(IDCDM,X(LDT),DUMMY,X(LWRK1),NUM1,NUM2,
     *                  'DENSITY ',.TRUE.,.FALSE.)
         ENDIF
C
         CALL DAREAD(IDAF,IODA,X(LWRK1),NUM2,11,0)
C CALCULATE HF ENERGY
         EHF1 = TRACEP(X(LDT),X(LFT),NUM1)
         EHF2 = TRACEP(X(LDT),X(LWRK1),NUM1)
         EHF  = (EHF1+EHF2)/TWO
         IF(MASWRK) WRITE(IW,*)' CORRECTED HF ENERGY(1)=', EHF+ENUC
C
         IF(DIRSCF) THEN
            SCHWRZ=ISCHWZ.GT.0
            IF(SCHWRZ) THEN
               CALL EXCHNG(X(LXINTS),X(LGHOND),X(LDDIJ),
     *                     NSH2,MAXG,INTTYP)
               DUMMY = 0.0D+00
               CALL SHLDEN(RHF,X(LDT),DUMMY,DUMMY,X(LDSH),
     *                     IA,NUM,NUM2,NSH2,1)
            END IF
            CALL DAREAD(IDAF,IODA,X(LWRK2),NUM2,272,1)
            CALL VCLR(X(LFT),1,NUM2)
            CALL TWOEIDC(RHF,DIRSCF,.FALSE.,.FALSE.,.FALSE.,
     *              INTTYP,SCHWRZ,NINT,NSCHWZ,NUM,NUM2,
     *              DUMMY,DUMMY,IDUMMY,1,
     *              X(LXINTS),NSH2,X(LGHOND),MAXG,X(LDDIJ),
     *              IA,X(LDT),X(LFT),DUMMY,DUMMY,X(LDSH),
     *              DUMMY,DUMMY,1,X(LWRK2))
            CALL DSCAL(NUM2,HALF,X(LFT),1)
            II=LFT-1
            DO I=1,NUM
               II = II+I
               X(II) = X(II) + X(II)
            ENDDO
            IF(GOPARR) CALL DDI_GSUMF(1000,X(LFT),NUM2)
         ELSE
            TDSKWRK = DSKWRK
            DSKWRK  = .TRUE.
            CALL SEQREW(IJK)
            CALL HSTAR(X(LDT),X(LFT),X(LBUF),X(LIBUF),
     *                 NINTMX,IA,NOPK,.FALSE.)
            DSKWRK  = TDSKWRK
         END IF
         CALL DAREAD(IDAF,IODA,X(LWRK1),NUM2,11,0)
         CALL VADD(X(LFT),1,X(LWRK1),1,X(LFT),1,NUM2)
      END IF
C
      ECORMP=ZERO
      E2OC=ZERO
      E2VI=ZERO
      E2SG=ZERO
      E2OCSG=ZERO
      E2VISG=ZERO
      E2PARA=ZERO
      E2OPOS=ZERO
C
      NOATMP=NOA
      NACORT=NACORE
C-ADD(YOSHI), BUT THESE ARE NEVER USED.
C     NOBTMP=NOB
C     NBCORT=NBCORE
C-END
      NOTMP=NO
      NBFTMP=NBF
      NQMTTP=NQMT
C
      IDMP=35
      CALL SEQOPN(IDMP,'RESTART','NEW',.FALSE.,'FORMATTED')
      IF(MASWRK) WRITE(IDMP, FMT='(8H $MP2RES)')
C
      IF(ISTCOR.GE.2) THEN
         CALL RDMPDC(X(LESUB),X(LESOCC),X(LESVIR),L1SUB,
     *               ECORMP,E2OC,E2VI,E2SG,ISTCOR,DOMP1,IDMP)
      ENDIF
C
      CALL SEQREW(IDCVEC)
      CALL SEQREW(IDCQ)
C
C  SUBSYSTEM LOOP
C     THIS LOOP SHOULD BE PARALLELIZE BY GDDI
C
      CALL TSECND(TIM1)
      DO ISUB=1, NSUBS
         IF(MASWRK) WRITE(IW,9100) ISUB
         CALL LOCREG(ISUB)
         CALL TOLOC
C
         L1=LNUM
         L3=L1*L1
         L2=(L1+L3)/2
C
         CALL VALFM(LOADFM)
         LCO   = LOADFM + 1
         LEIG  = LCO    + L3
         LQ    = LEIG   + L1
         LS    = LQ     + L3
         LASTA = LS     + L2
C
         LF    = LASTA
         IF(DOMP1) THEN
            LASTA = LF     + L2
         END IF
C
         NEED0 = LASTA - LOADFM -1
C
         CALL GETFM(NEED0)
         IVEC=LCO
C
         CALL SQREAD(IDCVEC,X(LCO),L3)
         CALL SQREAD(IDCQ,X(LQ),L3)
         CALL DCOPY(L1,X(LEIGT+ILCST1(ISUB)-1),1,X(LEIG),1)
C
         IF(ISUB.LT.ISTCOR) GOTO 100
C
         CALL TRT2LC(X(LST),X(LS),NUM,NUM2,L1,L2,'OVERLAP ')
C
         NACORE=0
         IF(FZCORE) NACORE=NUMCORDC()
C
         NQMT=NLQMT(ISUB)
         NO=NQMT
         NBF=L1
         NOA=0
         DO I=1, L1
            IF(X(LEIG+I-1).LE.FRMLVA) NOA=NOA+1
         END DO
C
         IF(DOMP1) THEN
            CALL TRT2LC(X(LFT),X(LF),NUM1,NUM2,L1,L2,'FOCK    ')
            CALL MP2DC1(X(LCO),X(LEIG),X(LF),L1,L2,
     *                  E1SUB,E1OSUB,E1VSUB)
C
            X(LESUB +ISUB-1)=X(LESUB +ISUB-1)+E1SUB
            X(LESOC1+ISUB-1)=E1OSUB
            X(LESVI1+ISUB-1)=E1VSUB
            X(LESSCS+ISUB-1)=X(LESSCS+ISUB-1)+E1SUB
C
            E2OCSG=E2OCSG+E1OSUB
            E2VISG=E2VISG+E1VSUB
            E2SG  =E2SG  +E1SUB
            IF(MASWRK) THEN
               WRITE(IW  ,9510) E1OSUB,E1VSUB,E1SUB
               WRITE(IDMP,9555) E1OSUB,E1VSUB,E1SUB
            END IF
         END IF
C
         E2OOLD=E2OPOS
         E2POLD=E2PARA
         IF(CODEMP.EQ.DDI) THEN
           CALL MP2DDIDC(X(LCO),X(LEIG),X(LQ),X(LS),L1,L2,
     *                   E2SUB,E2OSUB,E2VSUB)
         ELSE IF(CODEMP.EQ.IMS) THEN
           CALL MP2IMSDC(X(LCO),X(LEIG),E2SUB,E2OSUB,E2VSUB)
         ELSE
           CALL MP2NDC(X(LCO),X(LEIG),X(LQ),X(LS),L1,L2,
     *                 E2SUB,E2OSUB,E2VSUB)
         END IF
C
         X(LESUB +ISUB-1)=E2SUB
         X(LESOCC+ISUB-1)=E2OSUB
         X(LESVIR+ISUB-1)=E2VSUB
C
         EPARA=E2PARA-E2POLD
         EOPOS=E2OPOS-E2OOLD
         IF(GOPARR) THEN
            CALL DDI_GSUMF(11011,EPARA,1)
            CALL DDI_GSUMF(11012,EOPOS,1)
         END IF
         E2SSCS=EPARA*FPARA+EOPOS*FOPOS
         X(LESSCS+ISUB-1)=E2SSCS
C
         ECORMP=ECORMP+E2SUB
         E2OC  =E2OC  +E2OSUB
         E2VI  =E2VI  +E2VSUB
         IF(MASWRK) THEN
            WRITE(IW  ,9500) ISUB,E2OSUB,E2VSUB,E2SUB,E2SSCS
            WRITE(IDMP,9550) ISUB,E2OSUB,E2VSUB,E2SUB
         END IF
C
         IF(DOMP1) THEN
            E2SUB =E2SUB +E1SUB
            E2OSUB=E2OSUB+E1OSUB
            E2VSUB=E2VSUB+E1VSUB
            IF(MASWRK) THEN
               WRITE(IW,9520) E2OSUB,E2VSUB,E2SUB
            END IF
         END IF
C
         CALL TSECND(TIM2)
         IF(MASWRK) WRITE(IW,9600) ISUB, TIM2-TIM1
         TIM1=TIM2
C
         NOA=NOATMP
         NACORE=NACORT
         NO=NOTMP
         NBF=NBFTMP
         NQMT=NQMTTP
C
  100    CONTINUE
C
         CALL RETFM(NEED0)
      END DO                    !END SUBSYSTEM LOOP
      IF(MASWRK) WRITE(IDMP, FMT='(5H $END)')
C
      IF(GOPARR) THEN
         CALL DDI_GSUMF(1201,E2PARA,1)
         CALL DDI_GSUMF(1202,E2OPOS,1)
      END IF
C
      ECORMP=ECORMP+E2SG
      E2OC  =E2OC  +E2OCSG
      E2VI  =E2VI  +E2VISG
      E2  =ECORMP
      EHF =ESCF
      EMP2=EHF+E2
      SCSE2=E2PARA*FPARA+E2OPOS*FOPOS
      IF(OUTPUT) THEN
         IF(DOMP1) THEN
            WRITE(IW,9305) EHF,E2,E2-E2SG,E2SG,EMP2
            IF(ONLYOC) THEN
               WRITE(IW,9315) E2OC-E2OCSG,E2OCSG,ONE,
     *                        E2VI-E2VISG,E2VISG,ZERO
            ELSE
               WRITE(IW,9315) E2OC-E2OCSG,E2OCSG,WOCC,
     *                        E2VI-E2VISG,E2VISG,ONE-WOCC
            END IF
         ELSE
            WRITE(IW,9300) EHF,E2,EMP2
            IF(ONLYOC) THEN
               WRITE(IW,9310) E2OC,ONE,E2VI,ZERO
            ELSE
               WRITE(IW,9310) E2OC,WOCC,E2VI,ONE-WOCC
            END IF
         ENDIF
      END IF
      ESCSMP2 = EHF + SCSE2
      IF(MASWRK) WRITE(IW,9350) E2OPOS,E2PARA,SCSE2,ESCSMP2
      EMP2A=ESCSMP2
      IF(SCSPT.NE.ANONE) THEN
         EMP2A=EMP2
         E2=SCSE2
         EMP2=ESCSMP2
      ENDIF
C
      IF(OUTPUT) THEN
         WRITE(IW,9400)
         DO ILOOP=1,NSUBS
           WRITE(IW,9410) ILOOP, X(LESUB+ILOOP-1), X(LESSCS+ILOOP-1)
         END DO
         WRITE(IW,*)   
      END IF
C
C  IF RMKORB=.TRUE. RESTORE DC SUBSYSTEMS
C
      IF(RMKORB .AND. DCFLG) THEN 
         CALL DFLCST(0,.FALSE.)
         CALL ORBRMK(X(LST),X(LFT),DUMMY,X(LEIGT),DUMMY,NUM1,NUM2,
     *               NLC1,NSUBS,DBUG,0)
         FRMLVA = FRMOLD
      ENDIF
C
      CALL RETFM(NEEDT)
C
      RETURN
 9000 FORMAT(/1X,46(1H-)/
     *        1X,'DIVIDE-AND-CONQUER MP2 PROGRAM     M.KOBAYASHI'/
     *        6X,'REF.  J.CHEM.PHYS.127, 074103(2007)'/
     *        1X,46(1H-))
 9005 FORMAT(/5X,'POWERED BY DISTRIBUTED DATA MP2 PROGRAM',
     *        5X,'BY G. FLETCHER'/
     *        5X,39('-'),5X,14('-')/)
 9010 FORMAT(/10X,23(1H-)/10X,'DC-MP2 CONTROL OPTIONS'/10X,23(1H-)/
     *        10X,'ISTCOR = ',I8,2X,'DOMP1  = ',L8/
     *        10X,'ONLYOC = ',L8,2X,'WOCC   = ',F8.6/
     *        10X,'RMKORB = ',L8,2X,'HFFRM  = ',L8/
     *        10X,'RBUFCR = ',F8.4,' BOHR (',F8.4,' ANGS)'/)
 9100 FORMAT(/1X,'---CALCULATING ',I8,'-TH SUBSYSTEM MP2 ENERGY---')
 9300 FORMAT(/1X,'RESULTS OF MOLLER-PLESSET 2ND ORDER CORRECTION ARE'/
     *       13X,'  E(0)=',1X,F20.10/
     *       13X,'  E(1)=',9X,'0.0'/
     *       13X,'  E(2)=',1X,F20.10/
     *       13X,'E(MP2)=',1X,F20.10)
 9305 FORMAT(/1X,'RESULTS OF MOLLER-PLESSET 2ND ORDER CORRECTION ARE'/
     *       13X,'  E(0)=',1X,F20.10/
     *       13X,'  E(1)=',9X,'0.0'/
     *       13X,'  E(2)=',1X,F20.10/
     *       20X          ,'(',F20.10,' DBL +',F20.10,' SGL)'/
     *       13X,'E(MP2)=',1X,F20.10)
 9310 FORMAT(/1X,'CORRELATION ENERGY CONTRIBUTION'/
     *       12X,'E2(OCC)=',1X,F20.10,' X ',F8.6,' (WOCC)'/
     *       12X,'E2(VIR)=',1X,F20.10,' X ',F8.6,' (WVIR)')
 9315 FORMAT(/1X,'CORRELATION ENERGY CONTRIBUTION'/
     *     23X,'(DBL)',18X,'(SGL)'/
     *     13X,'E2(OCC)=( ',F20.10,' + ',F20.10,' ) X ',F8.6,' (WOCC)'/
     *     13X,'E2(VIR)=( ',F20.10,' + ',F20.10,' ) X ',F8.6,' (WVIR)')
 9350 FORMAT(/1X,'SPIN-COMPONENT-SCALED MP2 RESULTS ARE'/
     *       12X,'  E(2S)=',1X,F20.10/
     *       12X,'  E(2T)=',1X,F20.10/
     *       12X,' E(2ST)=',1X,F20.10,' = 6/5 * E(2S) + 1/3 * E(2T)'/
     *       12X,'SCS-MP2=',1X,F20.10)
 9400 FORMAT(/5X,32(1H-)/
     *        5X,'SUBSYSTEM MP2 CORRELATION ENERGY'/
     *        5X,32(1H-)/
     *        3X,'SUBSYSTEM',10X,'MP2 ENERGY',8X,'SCS-MP2 ENERGY')
 9410 FORMAT( 5X,I5,5X,2F20.10)
 9500 FORMAT(1X,'ISUB=',I5,' E2OC=',E15.7,' E2VI=',E15.7,'   E2=',E15.7/
     *       53X,                                        'SCSE2=',E15.7)
 9510 FORMAT(1X,' SINGLES:  E1OC=',E15.7,' E1VI=',E15.7,' E1=',E15.7)
 9520 FORMAT(1X,' TOTAL  :  E2OC=',E15.7,' E2VI=',E15.7,' E2=',E15.7)
 9550 FORMAT(I5,3E21.12)
 9555 FORMAT(5X,3E21.12)
 9600 FORMAT(/1X,I8,'-TH SUBSYSTEM MP2 TOOK ',F10.2,' SECONDS.')
 9900 FORMAT(/1X,'*** WARNING ***'/
     *        1X,'MP2PRP=.T. IS NOT SUPPORTED IN DC. FORCE DISABLED.'/)
 9950 FORMAT(/1X,'ERROR: CODE=IMS MUST BE USED WITH DIRSCF=.TRUE.')
 9960 FORMAT(/1X,'ERROR: CODE=IMS CAN WORK ONLY WITH ONLYOC=.TRUE.')
      END
C
C*MODULE DCMP2   *DECK MP2NDC
C        MODIFIED FROM MP2NRG
      SUBROUTINE MP2NDC(VEC,ENG,Q,S,L1,L2,E2SUB,E2OC,E2VI)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL SOME,OUT,DBUG,DIRSCF,PACK2E,FDIFF,ABEL,ABELPT,
     *        GOPARR,DSKWRK,MASWRK,LMOMP2,DIRTRF
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXGSH=30, MXG2=MXGSH*MXGSH,
     *           MXATM=2000, MXAO=8192)
C
      COMMON /DIRMEM/ LPQRJ,IVEC,IDEN,IFCK,NUM,NOCC,NDIM,MINPQ,MAXPQ
      COMMON /DCMEM2/ LPQRJI,IDCMOD
      COMMON /FMCOM / X(1)
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,MNUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /INT2IC/ NINTIC,ININTIC,NXXIC,LBUFPIC,LIXIC,LABSIX,NINTIX
      COMMON /MP2DAF/ IDAF20,NAV20
      COMMON /MP2LOC/ LMOMP2
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOL,METHOD,NWDMP2,MEMPRI,MPPROP,
     *                NACORE,NBCORE,NOA,NOB,NO,NBF,NOMIT,MOCPHF,MAXITC
      COMMON /MP2PRT/ SOME,OUT,DBUG
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                TSYM(432),INVT(48),NT
      COMMON /TRFOPT/ CUTTRF,NWDTRF,MPTRAN,ITRFAO,NOSYMT,IPURTF,DIRTRF
C
      LOGICAL DODCCR,ONLYOC,RMKORB,FZCORE,DOMP1,HFFRM
      COMMON /DCCORR/ RBUFCR,WOCC,ISTCOR,ITPART,DODCCR,ONLYOC,RMKORB,
     *                FZCORE,DOMP1,HFFRM
C
      DATA CHECK/8HCHECK   /, RDCMP2/8HDCMP2   /
C
      PARAMETER (ONE=1.0D+00)
C
      DIMENSION VEC(*),ENG(L1),Q(L1,L1),S(L2)
C
C VEC     : MATRIX OF MO COEFFICIENTS        NBF  *  NBF
C ENG     : ORBITAL ENERGIES                 NBF
C
C     ----- MAIN CLOSED-SHELL MP2 ENERGY DRIVER -----
C
      SOME=NPRINT.NE.-5 .AND. MASWRK
      OUT =EXETYP.EQ.RDCMP2 .AND. MASWRK
      IF(MASWRK) WRITE(IW,9000) NACORE,NOA,NQMT,NBF
C
      IDCMOD=3
C
      CALL GOTFM(NGOTMX)
      IF(NWDMP2.GT.0) NGOTMX=MIN(NGOTMX,NWDMP2)
C
      NOC  = NOA - NACORE
      NVIR = NO  - NOA
      NORB = NO  - NACORE
      NBF2 = (NBF*NBF+NBF)/2
      NBF3 = NBF * NBF
C
      NUM  = NBF
      IDEN = 0
      IFCK = 0
      NDIM  = MAX(NBF2,NVIR*NOC)
C
C        ---- OPTION TO DEFEAT SYMMETRY USAGE ----
C
      ABEL=ABELPT()
      IF(NOSYMT.EQ.1) CALL SYMOFF
C
C    ----- MEMORY POINTERS FOR MP2 ENERGY -----
C
C IPTR1   : PARTIALLY TRANSFORMED INTEGRAL   NOC  *  NBF
C IPTR2   : PARTIALLY TRANSFORMED INTEGRAL   NVIR *  NBF
C ILAB    : MOSLAB    |                      NBF
C IIRP    : MOSIRP    |---> SEE SYM          NBF
C IDEG    : MOSDEG    |                      NBF
C IWRK    : WORK: S, MO, ETC.                NBF * NBF
C         : HOLDS (PQ|RJ)                    NBF * NBF OR NINTMX
C IWRK3   : TEMP STORAGE OF Q*S*V            NBF
C LEIJ    : PAIR ENERGY                      NOC * NOC
C LEI     : ORBITAL CONTRIBUTION TO E2       NOC
C LMINT   : MO INTEGRAL (IA|JB) (OUT-OF-CORE)NOC * NDIM * LPASS
C LMINT2  : MO INTEGRAL (IA|JB) (OUT-OF-CORE)NOC * NDIM * LPASS
C LPQRJ   : PARTIALLY TRANSFORMED INTEGRAL   NBF * NDIM * LPASS
C LPQRJI  : PARTIALLY TRANSFORMED INTEGRAL   NBF * NDIM * LPASS
C LPQRJA  : PARTIALLY TRANSFORMED INTEGRAL   NBF * NDIM * LPASS
C LIODA   : TEMP STORAGE FOR MO INT FOR IO   NOC * NVIR
C
C  ----- THE FOLLOWING LIST IS FOR DIRECT MP2 -----
C LGHND   : AO INTEGRALS FOR DIRECT METHOD   MAXG --> NANGM**4
C LXINTS  : EXCHANGE INTEGRALS               (NSHELL**2 + NSHELL)/2
C LDDIJ   : WORK SPACE FOR AO INTEGRAL       49*MXG2
C
C
      CALL VALFM(LOADFM)
      IPTR1  = 1    + LOADFM
      IPTR2  = IPTR1+ NOC*NBF
      ILAB   = IPTR2+ NVIR*NBF
      IIRP   = ILAB + NBF
      IDEG   = IIRP + NBF
      LAST   = IDEG + NBF
      NEEDA  = LAST - LOADFM - 1
      CALL GETFM(NEEDA)
C
C    ----- SET UP TRANSPOSE MATRIX OF MO COEFFICIENTS -----
C
      CALL VALFM(LOADFM)
      IWRK   = 1    + LOADFM
      LAST   = IWRK + NBF*NBF
      NEEDB  = LAST - LOADFM - 1
      CALL GETFM(NEEDB)
C
      CALL DCOPY(NBF*NBF,VEC,1,X(IWRK),1)
C
      MAXC = IDAMAX(NBF*NQMT,VEC,1)
      IF(ABS(VEC(MAXC)).GT.1.0D+02) THEN
         MAXM = 1 + MAXC/NUM
         MAXA = MAXC - NUM*(MAXM-1)
         IF(MASWRK) WRITE(IW,9020) ABS(X(IWRK+MAXC-1)),MAXA,MAXM
      END IF
C
C          SUBTRACTING CORE ORBITALS
C
      DO 15 J=1,NORB
         ENG(J)=ENG(J+NACORE)
         DO 10 I=1,NBF
            VEC(I+NBF*(J-1))=X(I+NBF*(J-1+NACORE)+IWRK-1)
  10     CONTINUE
  15  CONTINUE
C
C          TRANSPOSING OCCUPIED SPACE
C
      DO 25 J=1,NOC
         DO 20 I=1,NBF
            X(J+NOC*(I-1)+IPTR1-1)=X(I+NBF*(J-1+NACORE)+IWRK-1)
   20    CONTINUE
   25 CONTINUE
C
C          TRANSPOSING VIRTUAL SPACE
C
      DO 35 J=1,NVIR
         DO 30 I=1,NBF
            X(J+NVIR*(I-1)+IPTR2-1)=X(I+NBF*(J-1+NOA)+IWRK-1)
   30    CONTINUE
   35 CONTINUE
      CALL RETFM(NEEDB)
C
C     ----- ASSIGN -IRREP- LABEL TO MO'S -----
C
      CALL VALFM(LOADFM)
      IWRK3 = 1     + LOADFM
      LAST  = IWRK3 + NBF
      NEEDC = LAST -LOADFM - 1
      CALL GETFM(NEEDC)
      IF(EXETYP.EQ.CHECK) GO TO 50
C
      CALL TRFSYM(X(ILAB),X(IIRP),X(IDEG),Q,S,VEC,
     *            X(IWRK3),IA,NQMT,NBF,NORB,NBF)
C
   50 CONTINUE
      CALL RETFM(NEEDC)
C
      NTSAVE = NT
      IF(DIRSCF  .AND.  .NOT.ABEL) NT=1
C
C     ----- INTEGRAL STORAGE FOR DIRECT OR CONVENTIONAL MP2 -----
C     BEWARE!  THE DIRECT TRANSFORMATIONS PASS STORAGE LOCATIONS
C     FOR THE TRANSFORMED INTEGRAL ARRAY AND THE VECTORS THROUGH
C     THE -LPQRJ- AND -IVEC- VARIABLES IN COMMON.  THE NUMBER OF
C     MO-S IN THE 1ST INDEX TRANSFORM IS -NOCC-, WHICH IS SET LATER.
C
      CALL BASCHK(LMAX)
                    NANGM =  4
      IF(LMAX.EQ.2) NANGM =  6
      IF(LMAX.EQ.3) NANGM = 10
      IF(LMAX.EQ.4) NANGM = 15
      IF(LMAX.EQ.5) NANGM = 21
      IF(LMAX.EQ.6) NANGM = 28
      MAXG = NANGM**4
      NSH2 = (NSHELL*NSHELL+NSHELL)/2
C
      CALL VALFM(LOADFM)
      MINTMX=NINTMX
      IF(NINTIC.NE.0) MINTMX=0
      IF(DIRSCF) THEN
         LGHND  = 1      + LOADFM
         LXINTS = LGHND  + MAXG
         LDDIJ  = LXINTS + NSH2
         LXX    = LDDIJ  + 49*MXG2
         LIX    = LXX    + NINTMX
         LAST   = LIX    + NINTMX
      ELSE
         LGHND  = 1      + LOADFM
         LXINTS = LGHND
         LDDIJ  = LXINTS
         LXX    = LDDIJ
         LIX    = LXX    + MINTMX
         LAST   = LIX    + MINTMX
         IF(NINTIC.NE.0) THEN
            LXX  = LBUFPIC
            LIX  = LIXIC
         ENDIF
      END IF
      NEEDD = LAST - LOADFM - 1
      CALL GETFM(NEEDD)
C
      IF(DIRSCF) THEN
         IF(EXETYP.EQ.CHECK) THEN
            CALL VCLR(X(LXINTS),1,NSH2)
         ELSE
            IF(ISCHWZ.EQ.1) THEN
               CALL DAREAD(IDAF,IODA,X(LXINTS),NSH2,54,0)
            ELSE
               CALL DCOPY(NSH2,1.0D+01,0,X(LXINTS),1)
            END IF
         END IF
      END IF
C
C         THE LAST TWO BRANCHES ARE TO ENABLE TESTING
C
      NGOT = NGOTMX - NEEDA - NEEDD
      IF(DIRSCF  .AND.  SOME) WRITE(IW,9050)
      IF(GOPARR) GO TO 600
      IF(METHOD.EQ.3) GO TO 400
      IF(METHOD.EQ.4) GO TO 600
C
C     ----- SEQUENTIAL SEGMENTED MP2 TRANSFORMATION -----
C     THE "SEGMENTED" TRANSFORMATION USES MORE MEMORY BUT LESS DISK
C     THAN THE "ALTERNATIVE" METHOD IMPLEMENTED BELOW.  IT HAS BOTH
C     DIRECT AND CONVENTIONAL TRANSFORMATIONS.
C
      NEED  = 2*NBF3
      LEFT  = NGOT - NEED
      NMIN  = NDIM*NBF*3
      IF(ONLYOC)  NMIN  = NDIM*NBF*2
      MNMEM = NEEDA + NEEDD + NEED + NMIN*1
      MXMEM = NEEDA + NEEDD + NEED + NMIN*NOC
      IF(SOME) WRITE(IW,9110) MNMEM,MXMEM
C
      IF(NMIN.GT.LEFT) THEN
         NTOT = NEEDA + NEEDD + NEED + NMIN
         IF(MASWRK) WRITE(IW,9120) NTOT,NGOTMX
         IF(DIRSCF) THEN
            IF(MASWRK) WRITE(IW,9130)
            CALL ABRT
         ELSE
            IF(MASWRK) WRITE(IW,9140)
            GO TO 400
         END IF
      END IF
C
      LPASS = MIN(NOC,LEFT/NMIN)
      NPASS = (NOC+LPASS-1)/LPASS
      LPASS = (NOC+NPASS-1)/NPASS
C
      CALL VALFM(LOADFM)
      LWRK1 = 1     + LOADFM
      LWRK2 = LWRK1 + NBF3
      LPQRJ = LWRK2 + NBF3
      LPQRJI= LPQRJ + NDIM*NBF*LPASS
      LPQRJA= LPQRJI+ NDIM*NBF*LPASS
      LAST  = LPQRJA+ NDIM*NBF*LPASS
      IF(ONLYOC) LAST= LPQRJA
      NEEDE = LAST - LOADFM - 1
      CALL GETFM(NEEDE)
C
      MEM = NEEDA + NEEDD + NEEDE
      IF(SOME) WRITE(IW,9150) LPASS,NPASS,MEM
      IF(EXETYP.EQ.CHECK) GO TO 700
C
      CALL MP2SDC(E2SUB,E2OC,E2VI,ENG,VEC,X(LPQRJ),X(LPQRJI),
     *            X(LPQRJA),X(LXX),X(LIX),X(LWRK1),X(LWRK2),X(IIRP),NBF,
     *            NBF3,NOC,NVIR,NDIM,IJK,NPASS,LPASS,X(LGHND),X(LXINTS),
     *            X(LDDIJ),NINTMX,MAXG,NSH2,MXG2)
      GO TO 700
C
C     ----- SEQUENTIAL ALTERNATIVE OUT-OF-CORE MP2 TRANSFORMATION -----
C     THIS METHOD USES LESS MEMORY THAN THE SEGMENTED TRANSFORMATION,
C     BUT BECAUSE OF THIS IT REQUIRES MORE DISK STORAGE.  THERE IS
C     ONLY A CONVENTIONAL DISK STORAGE METHOD IMPLEMENTED.
C
  400 CONTINUE
      IF(DIRSCF) THEN
         IF(MASWRK) WRITE(IW,*) 'DIRECT MP2 REQUIRES SEGMENTED TRANSF.'
         CALL ABRT
      END IF
      NDAR20 = NVIR*NOC*3
C
      NEED = 3*NBF3 + NDAR20 + NOC*NOC + NOC
      LEFT = NGOT - NEED
      NMIN = NDIM*NOC*2
      MNMEM = NEEDA + NEEDD + NEED + NMIN*1
      MXMEM = NEEDA + NEEDD + NEED + NMIN*NBF
      IF(SOME) WRITE(IW,9210) MNMEM,MXMEM
C
      IF(NMIN.GT.LEFT) THEN
         NTOT = NEEDA + NEEDD + NEED + NMIN
         IF(MASWRK) WRITE(IW,9220) NTOT,NGOTMX
         CALL ABRT
      END IF
C
      LPASS  = LEFT/NMIN
      NPASS  = ((NBF-1)/LPASS) + 1
      IF(LPASS.GE.NBF) LPASS=NBF
C
      CALL VALFM(LOADFM)
      LWRK1 = 1     + LOADFM
      LWRK2 = LWRK1 + NBF3
      LWRK3 = LWRK2 + NBF3
      LIODA = LWRK3 + NBF3
      LEIJ  = LIODA + NDAR20
      LMINT = LEIJ  + NOC*NOC
      LMINT2= LMINT + NOC*NDIM*LPASS
      LAST  = LMINT2+ NOC*NDIM*LPASS
      NEEDE = LAST - LOADFM - 1
      CALL GETFM(NEEDE)
C
      MEM = NEEDA + NEEDD + NEEDE
      IF(SOME) WRITE(IW,9250) LPASS,NPASS,MEM
      IF(EXETYP.EQ.CHECK) GO TO 700
C
C     ----- LMOMP2 IS NOT SUPPORTED IN DC CODE -----
C
      IF (LMOMP2) THEN
         WRITE(IW,9900)
         LMOMP2=.FALSE.
      ENDIF
C
C        DIRECT ACCESS FILE 20 IS USED IN THIS METHOD
C
      IDAF20 = 20
      CALL RAOPEN(IDAF20,X(LIODA),0,NDAR20,NBF*NOC,NPRINT)
C
      CALL MP2ODC(VEC,X(IPTR2),X(LMINT),X(LMINT2),X(LXX),
     *            X(LIX),X(LWRK1),X(LWRK2),X(LWRK3),NBF,NOC,
     *            NVIR,NDIM,IJK,LPASS,NPASS,X(LIODA),
     *            NINTMX,NDAR20)
      CALL MP2OSD(X(LMINT),X(IIRP),NBF,NOC,NVIR,X(LIODA))
      CALL MP2OED(ENG,X(LMINT),X(LMINT2),X(LEIJ),
     *            E2SUB,E2OC,E2VI,NBF,NOC,NVIR,X(LIODA))
C
      CALL RACLOS(IDAF20,'DELETE')
      GO TO 700
C
C     ----- PARALLEL -MP2- -----
C
  600 CONTINUE
C
      NEED  = 2*NBF3 + NPROC
      LEFT  = NGOT - NEED
      NMIN  = NDIM*NBF*3
      IF(ONLYOC)  NMIN  = NDIM*NBF*2
      IF(NMIN.GT.LEFT) THEN
         NTOT = NEEDA + NEEDD + NEED + NMIN
         IF(MASWRK) WRITE(IW,9320) NTOT,NGOTMX
         CALL ABRT
      END IF
C
C         -NOCP- ORBITALS WILL BE TRANSFORMED BY EACH NODE,
C         DOING -MOCP- OF THEN IN EACH PASS.  -IOCP- IS THE
C         INDEX OF THE FIRST ORBITAL ASSIGNED TO EACH NODE.
C
      IAP = ME+1
      NOCP = (NOC+NPROC-1)/NPROC
      MOCP = MIN(NOCP,LEFT/NMIN)
      NPASS= (NOCP+MOCP-1)/MOCP
      NOCP = NOCP-1
      NOCL = NOC-NPROC*NOCP
      IF(IAP.LE.NOCL) NOCP=NOCP+1
      IOCP = (IAP-1)*NOCP+1
      IF(IAP.GT.NOCL) IOCP = IOCP+NOCL
      MOCP = MIN(NOCP,MOCP)
C
      MNMEM = NEEDA + NEEDD + NEED + NMIN*1
      MXMEM = NEEDA + NEEDD + NEED + NMIN*NOCP
      IF(SOME) WRITE(IW,9310) MNMEM,MXMEM
C
      CALL VALFM(LOADFM)
      LWRK1 = 1     + LOADFM
      LWRK2 = LWRK1 + NBF3
      LJFLG = LWRK2 + NBF3
      LPQRJ = LJFLG + NPROC
      LPQRJI= LPQRJ + NDIM*NBF*MOCP
      LPQRJA= LPQRJI+ NDIM*NBF*MOCP
      LAST  = LPQRJA+ NDIM*NBF*MOCP
      IF(ONLYOC) LAST= LPQRJA
      NEEDE = LAST - LOADFM - 1
      CALL GETFM(NEEDE)
C
      MEM = NEEDA + NEEDD + NEEDE
      IF(SOME) WRITE(IW,9350) MOCP,NPASS,MEM
      IF(EXETYP.EQ.CHECK) GO TO 700
C
      CALL MP2PDC(E2OC,E2VI,ENG,VEC,X(LPQRJ),X(LPQRJI),X(LPQRJA),
     *            X(LXX),X(LIX),X(LWRK1),X(LWRK2),X(IIRP),NBF,NOC,NVIR,
     *            NDIM,IJK,IOCP,NOCP,MOCP,NPASS,X(LGHND),X(LXINTS),
     *            X(LDDIJ),NINTMX,MAXG,NSH2,MXG2,X(LJFLG),NPROC-1)
      CALL DDI_GSUMF(11001,E2OC,1)
      CALL DDI_GSUMF(11002,E2VI,1)
C
      E2SUB=E2OC*WOCC+E2VI*(ONE-WOCC)
C
  700 CONTINUE
      CALL RETFM(NEEDE)
      CALL RETFM(NEEDD)
      CALL RETFM(NEEDA)
C
      NT = NTSAVE
      IF(NOSYMT.EQ.1) CALL SYMON
      RETURN
C
 9000 FORMAT(/1X,'NCORE=',I5,'   NOCC=',I5,'   NMOS=',I5,'   NAOS=',I5)
 9020 FORMAT(/1X,'*** WARNING: THE MAXIMUM LCAO COEF=',F15.6,
     *           ', FOR AO',I6,' IN MO=',I6,','/
     *        1X,'EXCEEDS 100.  ADDITIONAL INPUTS MAY BE REQUIRED TO',
     *           ' OBTAIN GOOD MP2 ACCURACY:'/
     *        1X,' $CONTRL ICUT=10 (OR 11)'/
     *        1X,' $SCF    CONV=2.5D-7 FDIFF=.FALSE.'/
     *        1X,' $MP2    CUTOFF=1D-10 (OR 11)'/)
 9050 FORMAT(/1X,'**** EFFICIENCY NOTE ****'/
     *        1X,'THE DIRECT MP2 TRANSFORMATION WILL COMPUTE THE AO',
     *           ' INTEGRALS ONCE EVERY PASS.'/
     *        1X,'INCREASING MEMORY TO DECREASE PASSES WILL OBVIOUSLY',
     *           ' SAVE CPU TIME.')
C
 9110 FORMAT(/1X,'MEMORY REQUIREMENTS FOR SEGMENTED MP2 TRANSFORMATION'/
     *       1X,'  MINIMUM=',I15,' WORDS, USING 1 MOLECULAR ORBITAL',
     *          ' PER PASS'/
     *       1X,'  MAXIMUM=',I15,' WORDS, MAKING ONLY 1 INTEGRAL PASS')
 9120 FORMAT(1X,'THERE IS INSUFFICIENT MEMORY TO RUN THE SEGMENTED',
     *       1X,'MP2 TRANSFORMATION.'/
     *       1X,'REQUIRED,AVAILABLE MEMORY=',2I15,' WORDS.')
 9130 FORMAT(1X,'**** ERROR: TOO LITTLE MEMORY TO RUN DIRECT MP2 *****'/
     *       1X,'INCREASE MEMORY TO AT LEAST THE MINIMUM SHOWN.')
 9140 FORMAT(1X,'ABANDONING SEGMENTED TRANSFORMATION,',
     *       1X,'TRYING ALTERNATIVE TRANSFORMATION...')
 9150 FORMAT(1X,'CHOOSING THE SEGMENTED MP2 TRANSFORMATION...'/
     *       1X,'  NUMBER OF MOS/PASS = ',I4/
     *       1X,'  NUMBER OF PASSES   = ',I4/
     *       1X,'  MEMORY USED = ',I15,' WORDS.')
C
 9210 FORMAT(/1X,'MEMORY REQUIREMENTS FOR ALTERNATIVE MP2',
     *          ' TRANSFORMATION'/
     *       1X,'  MINIMUM=',I15,' WORDS, USING 1 ATOMIC ORBITAL',
     *          ' PER PASS'/
     *       1X,'  MAXIMUM=',I15,' WORDS, MAKING ONLY 1 INTEGRAL PASS')
 9220 FORMAT(1X,'THERE IS INSUFFICIENT MEMORY TO RUN THE ALTERNATIVE',
     *       1X,'MP2 TRANSFORMATION.'/
     *       1X,'REQUIRED,AVAILABLE MEMORY=',2I15,' WORDS.'/
     *       1X,'INCREASE MEMORY TO AT LEAST THE MINIMUM SHOWN.')
 9250 FORMAT(1X,'CHOOSING THE ALTERNATIVE MP2 TRANSFORMATION...'/
     *       1X,'  NUMBER OF AOS/PASS = ',I4/
     *       1X,'  NUMBER OF PASSES   = ',I4/
     *       1X,'  MEMORY USED = ',I15,' WORDS.')
C
 9310 FORMAT(/1X,'MEMORY REQUIREMENTS FOR PARALLEL MP2 TRANSFORMATION'/
     *       1X,'  MINIMUM=',I15,' WORDS, USING 1 ORBITAL PER PASS'/
     *       1X,'  MAXIMUM=',I15,' WORDS, MAKING ONLY 1 INTEGRAL PASS')
 9320 FORMAT(1X,'THERE IS INSUFFICIENT MEMORY TO RUN THE PARALLEL',
     *       1X,'MP2 TRANSFORMATION.'/
     *       1X,'REQUIRED,AVAILABLE MEMORY=',2I15,' WORDS.'/
     *       1X,'INCREASE MEMORY TO AT LEAST THE MINIMUM SHOWN.')
 9350 FORMAT(1X,'PARAMETERS FOR THE PARALLEL MP2 TRANSFORMATION'/
     *       1X,'  NUMBER OF MOS/NODE/PASS = ',I4/
     *       1X,'  NUMBER OF PASSES        = ',I4/
     *       1X,'  MEMORY USED = ',I15,' WORDS.')
 9900 FORMAT(/1X,'*** WARNING ***'/
     *        1X,'LMOMP2=.T. IS NOT SUPPORTED IN DC. FORCE DISABLED.'/)
      END
C
C*MODULE DCMP2   *DECK MP2PDC
C        MODIFIED FROM MP2P
      SUBROUTINE MP2PDC(E2OC,E2VI,E,C,XPQRJ,XPQRJI,XPQRJA,XX,IX,X,Y,
     *                  MOSIRP,NUM,NOC,NVIR,NDIM,IJKX,IOCP1,NOCP,MOCP,
     *                  NPASS,GHONDO,XINTS,DDIJ,NINTMX,MAXG,NSH2,MXG2,
     *                  JFLG,NPM1)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL SOME,OUT,DBUG
      LOGICAL GOPARR,DSKWRK,MASWRK,DIRSCF,FDIFF,DSKSAV
C
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      DIMENSION E(*),C(NUM,*),XPQRJ(*),XPQRJI(*),XPQRJA(*),XX(NINTMX),
     *          IX(NINTMX),X(*),Y(*),MOSIRP(*),GHONDO(MAXG),XINTS(NSH2),
     *          DDIJ(MXG2),JFLG(0:NPM1)
C
      COMMON /DIRMEM/ IPQKL,IVEC,IDEN,IFCK,NUMX,NOCC,NDIMX,MINPQ,MAXPQ
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /MP2PRT/ SOME,OUT,DBUG
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      LOGICAL DODCCR,ONLYOC,RMKORB,FZCORE,DOMP1,HFFRM
      COMMON /DCCORR/ RBUFCR,WOCC,ISTCOR,ITPART,DODCCR,ONLYOC,RMKORB,
     *                FZCORE,DOMP1,HFFRM
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
C        ----- MAIN DRIVER FOR PARALLEL MP2 TRANSFORMATION -----
C        THIS NODE IS ASSIGNED OCCUPIED MO-S IN THE RANGE IOCP1-IOCP2
C        ON EACH PASS, IT DOES MO-S IN THE RANGE IOCP-JOCP
C
      E2OC = ZERO
      E2VI = ZERO
      IF(SOME) CALL TSECND(TIM1)
C
      DSKSAV = DSKWRK
      IF(.NOT.DIRSCF) DSKWRK=.TRUE.
C
      IPASS = 0
      IOCP2 = MIN(NOC,IOCP1+NOCP-1)
      IOCP = IOCP1
      IVEC0 = IVEC
  100 CONTINUE
      IPASS = IPASS+1
      JOCP = MIN(IOCP2,IOCP+MOCP-1)
      NOCC = JOCP-IOCP+1
      IVEC = IVEC0 + (IOCP-1)*NUM
      IF(NOCC.GT.0) THEN
C
C           (PQ|RS) --> (PQ|RJ)...DIRECT OR CONVENTIONAL
C           (PQ|RJ) --> (AI|RJ)
C           (AI|RJ) --> (AI|BJ)
C           FORM ENERGY CONTRIBUTION
C
         CALL MP21PD(IJKX,XPQRJ,XPQRJI,XX,IX,C(1,IOCP),NUM,NOCC,NDIM,
     *               GHONDO,XINTS,DDIJ,JFLG,NPM1,MAXG,NSH2,3)
C
         CALL MP2C23(XPQRJ,X,Y,C,NUM,NVIR,NOC,NOCC,NDIM,NUM)
         CALL MP2C23(XPQRJI,X,Y,C,NUM,NVIR,NOC,NOCC,NDIM,NUM)
C
         IF(.NOT.ONLYOC) CALL DCOPY(NOCC*NDIM*NUM,XPQRJ,1,XPQRJA,1)
C
         CALL MP2S4(XPQRJ,X,Y,C(1,NOC+1),MOSIRP,IOCP,NOC,NVIR,NUM,
     *              NOCC,NDIM,NUM)
         CALL MP2S4(XPQRJI,X,Y,C(1,NOC+1),MOSIRP,IOCP,NOC,NVIR,NUM,
     *              NOCC,NDIM,NUM)
         IF(.NOT.ONLYOC)
     *      CALL MP2S4(XPQRJA,X,Y,C(1,NOC+1),MOSIRP,IOCP,NOC,NVIR,NUM,
     *                 NOCC,NDIM,LNUMC)
C
         CALL MP2SED(E,XPQRJ,XPQRJI,E2OC,IOCP,NOC,NVIR,NOCC,NDIM,WOCC)
         IF(.NOT.ONLYOC)
     *      CALL MP2SED(E,XPQRJ,XPQRJA,E2VI,IOCP,NOC,NVIR,NOCC,NDIM,
     *                  ONE-WOCC)
C
C           EVEN IF THERE ARE NO MOS FOR THIS PROCESSOR TO COMPUTE
C           TRANSFORMED INTEGRALS FOR, THIS PROCESSOR MUST STILL
C           PARTICIPATE IN ALL GLOBAL BROADCASTS
C
      ELSE
         CALL TRFBRD(IJKX,XX,IX,NINTMX,JFLG,NPROC)
      END IF
C
      IF(SOME) THEN
         CALL TSECND(TIM2)
         TIME = TIM2 - TIM1
         TIM1 = TIM2
         WRITE(IW,9020) IPASS,TIME
         CALL FLSHBF(IW)
      END IF
C
      IOCP  = JOCP+1
      IF(IPASS.LT.NPASS) GO TO 100
C
      DSKWRK = DSKSAV
      RETURN
C
 9020 FORMAT(1X,'PASS #',I4,' TOOK',F12.2,' SECONDS.')
      END
C
C*MODULE DCMP2   *DECK MP21PD
C        MODIFIED FROM MP2C1P
      SUBROUTINE MP21PD(NFT,XPQRJ,XPQRJI,XX,IX,C,NUM,NOC,NDIM,
     *                  GHONDO,XINTS,DDIJ,JFLG,NPM1,MAXG,NSH2,IDCMOD)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL DIRTRF,DIRSCF,FDIFF,GOPARR,DSKWRK,MASWRK,PACK2E
C
      DIMENSION XPQRJ(NOC,NDIM,*),XPQRJI(NOC,NDIM,*),C(NUM,*),XX(*),
     *          IX(*),JFLG(0:NPM1),GHONDO(MAXG),XINTS(NSH2),DDIJ(*)
C
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /INT2IC/ NINTIC,ININTIC,NXXIC,LBUFPIC,LIXIC,LABSIX,NINTIX
      COMMON /DIRCAS/ I2CASE
      COMMON /DIRMEM/ IPQRJ,IVEC,IDEN,IFCK,NNNUM,NOCC,NNNDIM,MINPQ,MAXPQ
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /TRFOPT/ CUTTRF,NWDTRF,MPTRAN,ITRFAO,NOSYMT,IPURTF,DIRTRF
C
C     ----- FORM (PQ/RJ) = SUM OVER S OF (PQ/RS) * C(S,J) -----
C
      CALL VCLR(XPQRJ,1,NOC*NDIM*NUM)
      CALL VCLR(XPQRJI,1,NOC*NDIM*NUM)
C
C     ----- DIRECT MP2 -----
C
      IF(DIRSCF) THEN
         I2CASE=3
         NOCC = NOC
         DIRTRF=.TRUE.
         NINTICS=NINTIC
         NINTIC=0
         CALL DIRJKDC(GHONDO,XINTS,DDIJ,XX,IX,MAXG,NSH2)
         NINTIC=NINTICS
C
C     ----- CONVENTIONAL MP2 -----
C
      ELSE
C
         DO 100 KAP=0,NPROC-1
            JFLG(KAP)=1
  100    CONTINUE
         KAP = -1
         IFLG=  1
C
         CALL SEQREW(NFT)
C        FIRST, PROCESS IN CORE INTEGRALS
         NPACKIC=0
  300    CONTINUE
C
C           READ DUPLICATED OR DISTRIBUTED AO INTEGRAL LIST
C
         IF(NPACKIC.EQ.0.AND.NINTIC.NE.0) THEN
            NXX=NXXIC
            NINT=NXX
         ELSE
C           IF ALL IN CORE BAIL OUT
            IF(NINTIC.NE.0.AND.NXXIC.LT.NINTIC) RETURN
            IF(ITRFAO.EQ.1) THEN
              CALL PREAD(NFT,XX(NINTIC+1),IX(ININTIC+1),NXX,NINTMX)
            ELSE
              CALL PREADP(NFT,XX(NINTIC+1),IX(ININTIC+1),NXX,NINTMX,
     *                    KAP,IFLG,JFLG,NPROC)
              IF(IFLG.EQ.0) THEN
                 CALL SEQREW(NFT)
                 RETURN
              END IF
            END IF
         ENDIF
C
         IF(NXX.EQ.0) GO TO 400
         NINT=ABS(NXX)
         IF(NINT.GT.NINTMX) CALL ABRT
C
C           CARRY OUT FIRST INDEX TRANSFORMATION
C
         CALL ONETFD(XPQRJ,XPQRJI,C,NDIM,NUM,NOC,XX,IX,NXX,NPACKIC,
     *               IDCMOD)
         IF(NPACKIC.EQ.0) NPACKIC=NINTIC
C
  400    CONTINUE
         IF(ITRFAO.EQ.1  .AND.  NXX.LE.0) THEN
            CALL SEQREW(NFT)
            RETURN
         END IF
         GO TO 300
      END IF
      RETURN
      END
C
C*MODULE DCMP2   *DECK MP2ODC
C        MODIFIED FROM MP2O
      SUBROUTINE MP2ODC(C,CVT,XPQRJ,XPQRJI,XX,IX,X,Y,X2,NBF,
     *                  NOC,NVIR,NDIM,NFT,LPASS,NPASS,IODA20,
     *                  NINTMX,NDAR20)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL SOME,OUT,DBUG
C
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      COMMON /MP2DAF/ IDAF20,NAV20
      COMMON /MP2PRT/ SOME,OUT,DBUG
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
C
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
C
      DIMENSION C(NBF,*),CVT(NVIR,*),XPQRJ(NOC,NDIM,LPASS),
     *          XPQRJI(NOC,NDIM,LPASS),X2(NBF,NBF),
     *          X(NBF,NBF),Y(NBF,NBF),XX(NINTMX),IX(NINTMX),
     *          IODA20(NDAR20)
C
      CALL VCLR(XPQRJ,1,NOC*NDIM*LPASS)
      CALL VCLR(XPQRJI,1,NOC*NDIM*LPASS)
      CALL TSECND(TIM1)
C
C     ----- LOOP OVER PASSES OF -R- -----
C
      DO 100 IPASS=1,NPASS
C
      MINR = LPASS*(IPASS-1) + 1
      MAXR = LPASS*(IPASS-1) + LPASS
      IF(MAXR.GT.NBF) MAXR=NBF
      NUMR = MAXR - MINR + 1
C
C     ----- FORM (PQ/RJ) = SUM OVER S OF (PQ/RS) * C(S,J) -----
C
      CALL MP2O1D(NFT,XPQRJ,XPQRJI,XX,IX,C,NBF,NOC,NDIM,
     *            MINR,MAXR,NUMR)
C
C     ----- FORM (PI/RJ) , AND THEN (AI/RJ) -----
C
      CALL MP2C23(XPQRJ,X,Y,C,NBF,NVIR,NOC,NOC,NDIM,NUMR)
      CALL MP2C23(XPQRJI,X,Y,C,NBF,NVIR,NOC,NOC,NDIM,NUMR)
C
C     ----- FORM (AI/BJ) -----
C
      CALL VCLR(X,1,NOC*NUMR)
      CALL VCLR(X2,1,NOC*NUMR)
      CALL VCLR(Y,1,NOC*NBF)
      MAI=0
      DO 75 MA=1,NVIR
         DO 70 MI=1,NOC
            MAI=MAI+1
            MAI2=MAI+NOC*NVIR
            MAI3=MAI2+NOC*NVIR
C
            DO 15 MR=1,NUMR
               DO 10 MJ=1,NOC
                  X(MR,MJ)=XPQRJ(MJ,MAI,MR)
   10          CONTINUE
   15       CONTINUE
C
C            MATMP = MA
            CALL MRARBR(CVT(1,MINR),NVIR,NVIR,NUMR,X,NBF,NOC,Y,NBF)
C
            IF(IPASS.EQ.1) GO TO 28
            CALL RAREAD(IDAF20,IODA20,X2,NBF*NOC,MAI,0)
C
            DO 25 MJ=1,NOC
               DO 20 MB=1,NVIR
                  Y(MB,MJ)=Y(MB,MJ)+X2(MB,MJ)
   20          CONTINUE
   25       CONTINUE
   28       CONTINUE
C
            CALL RAWRIT(IDAF20,IODA20,Y,NBF*NOC,MAI,0)
            CALL VCLR(Y,1,NOC*NBF)
C
            IF(MINR.GT.LNUMC) GO TO 39
            NUMR2 = MIN(LNUMC,MAXR) - MINR + 1
            CALL MRARBR(CVT(1,MINR),NVIR,NVIR,NUMR2,X,NBF,NOC,Y,NBF)
C
            IF(IPASS.EQ.1) GO TO 38
            CALL RAREAD(IDAF20,IODA20,X2,NBF*NOC,MAI2,0)
C
            DO 35 MJ=1,NOC
               DO 30 MB=1,NVIR
                  Y(MB,MJ)=Y(MB,MJ)+X2(MB,MJ)
   30          CONTINUE
   35       CONTINUE
   38       CONTINUE
C
            CALL RAWRIT(IDAF20,IODA20,Y,NBF*NOC,MAI2,0)
            CALL VCLR(Y,1,NOC*NBF)
   39       CONTINUE
C
            DO 45 MR=1,NUMR
               DO 40 MJ=1,NOC
                  X(MR,MJ)=XPQRJI(MJ,MAI,MR)
   40          CONTINUE
   45       CONTINUE
C
            CALL MRARBR(CVT(1,MINR),NVIR,NVIR,NUMR,X,NBF,NOC,Y,NBF)
C
            IF(IPASS.EQ.1) GO TO 58
            CALL RAREAD(IDAF20,IODA20,X2,NBF*NOC,MAI3,0)
C
            DO 55 MJ=1,NOC
               DO 50 MB=1,NVIR
                  Y(MB,MJ)=Y(MB,MJ)+X2(MB,MJ)
   50          CONTINUE
   55       CONTINUE
   58       CONTINUE
C
            CALL RAWRIT(IDAF20,IODA20,Y,NBF*NOC,MAI3,0)
            CALL VCLR(Y,1,NOC*NBF)
C
   70    CONTINUE
   75 CONTINUE
C
      IF(SOME) THEN
         CALL TSECND(TIM2)
         TIME = TIM2 - TIM1
         TIM1 = TIM2
         WRITE(IW,9020) IPASS,TIME
         CALL FLSHBF(IW)
      END IF
  100 CONTINUE
C
      IF(SOME) WRITE(IW,9030)
      RETURN
C
 9020 FORMAT(1X,'PASS #',I4,' TOOK',F12.2,' SECONDS.')
 9030 FORMAT(1X,'DONE WITH TRANSFORMATION (PQ|RS) TO (IA|JB)')
      END
C
C*MODULE DCMP2   *DECK MP2O1D
C        MODIFIED FROM MP2O1
      SUBROUTINE MP2O1D(NFT,XPQRJ,XPQRJI,XX,IX,CO,NBF,NOC,NDIM,
     *                  MINR,MAXR,NUMR)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL SKIPP,SKIPQ,SKIPR,SKIPS,PACK2E,GOPARR,DSKWRK,MASWRK
C
      DIMENSION CO(NBF,*),XPQRJ(NOC,NDIM,*),XPQRJI(NOC,NDIM,*),
     *          XX(*),IX(*)
C
      PARAMETER (MXAO=8192, MXLATM=200, MXLSHL=700)
C
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /INT2IC/ NINTIC,ININTIC,NXXIC,LBUFPIC,LIXIC,LABSIX,NINTIX
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCKLAB/ LABSIZ
C
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
      COMMON /TO2LC / IT2LOC(MXAO)
C
C     ON ENTRY THE ORBITALS CO IS MULTIPLIED BY THE
C     AO INTEGRAL XX; THE LABELS ARE PACKED IN IX
C     ON RETURN XPQRJ IS FILLED
C
      CALL VCLR(XPQRJ,1,NUMR*NDIM*NOC)
      CALL VCLR(XPQRJI,1,NUMR*NDIM*NOC)
C
C     ----- FORM (PQ/RJ) = SUM OVER S OF (PQ/RS) * C(S,J) -----
C
      CALL SEQREW(NFT)
C     FIRST, PROCESS IN CORE INTEGRALS
      NPACKIC=0
  100 CONTINUE
      IF(NPACKIC.EQ.0.AND.NINTIC.NE.0) THEN
        NXX=NXXIC
        NINT=NXX
      ELSE
C       IF ALL IN CORE BAIL OUT
        IF(NINTIC.NE.0.AND.NXXIC.LT.NINTIC) GO TO 200
        CALL PREAD(NFT,XX(NINTIC+1),IX(ININTIC+1),NXX,NINTMX)
        IF(NXX.EQ.0) GO TO 200
        NINT=IABS(NXX)
        IF(NINT.LE.NINTMX) GO TO 105
      IF(MASWRK) WRITE(IW,9999)
      IF(MASWRK) WRITE(IW,9998)
      CALL ABRT
  105 CONTINUE
      ENDIF
C
      DO 150 M=1,NINT
                       NPACK = NPACKIC+M
      VAL1=XX(NPACK)
      VAL3=VAL1
C
                       IF (LABSIZ .EQ. 2) THEN
*I32                     LABEL = IX( 2*NPACK - 1 )
*I32                     IPACK = ISHFT( LABEL, -16 )
*I32                     JPACK = IAND(  LABEL, 65535 )
*I32                     LABEL = IX( 2*NPACK     )
*I32                     KPACK = ISHFT( LABEL, -16 )
*I32                     LPACK = IAND(  LABEL, 65535 )
*I64                     LABEL = IX(NPACK)
*I64                     IPACK = ISHFT( LABEL, -48 )
*I64                     JPACK = IAND( ISHFT( LABEL, -32 ), 65535 )
*I64                     KPACK = IAND( ISHFT( LABEL, -16 ), 65535 )
*I64                     LPACK = IAND( LABEL, 65535 )
                       ELSE IF (LABSIZ .EQ. 1) THEN
*I32                     LABEL = IX(NPACK)
*I32                     IPACK = ISHFT( LABEL, -24 )
*I32                     JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
*I32                     KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
*I32                     LPACK = IAND( LABEL, 255 )
*I64                     IF ( MOD(NPACK,2) .EQ. 0 ) THEN
*I64                       LABEL = IX( NPACK/2 )
*I64                       IPACK = IAND( ISHFT( LABEL, -24 ), 255 )
*I64                       JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
*I64                       KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
*I64                       LPACK = IAND( LABEL, 255 )
*I64                     ELSE
*I64                       LABEL = IX( (NPACK/2)+1 )
*I64                       IPACK = ISHFT( LABEL, -56 )
*I64                       JPACK = IAND( ISHFT( LABEL, -48 ), 255 )
*I64                       KPACK = IAND( ISHFT( LABEL, -40 ), 255 )
*I64                       LPACK = IAND( ISHFT( LABEL, -32 ), 255 )
*I64                     END IF
                       END IF
                       MPT = IPACK
                       MQT = JPACK
                       MRT = KPACK
                       MST = LPACK
C
      MP=IT2LOC(MPT)
      MQ=IT2LOC(MQT)
      MR=IT2LOC(MRT)
      MS=IT2LOC(MST)
      ITEST=MP*MQ*MR*MS
      IF(ITEST.EQ.0) GO TO 150
C
      IF(MP.LT.MQ) THEN
         ITP=MP
         MP=MQ
         MQ=ITP
      END IF
      IF(MR.LT.MS) THEN
         ITP=MR
         MR=MS
         MS=ITP
      END IF
      IF(MP.LT.MR .OR. (MP.EQ.MR .AND. MQ.LT.MS)) THEN
         ITP=MP
         MP=MR
         MR=ITP
         ITP=MQ
         MQ=MS
         MS=ITP
      END IF
C
      SKIPS=MS.LT.MINR.OR.MS.GT.MAXR
      SKIPR=MR.LT.MINR.OR.MR.GT.MAXR
      SKIPP=MP.LT.MINR.OR.MP.GT.MAXR
      SKIPQ=MQ.LT.MINR.OR.MQ.GT.MAXR
      IF(SKIPS.AND.SKIPR.AND.SKIPQ.AND.SKIPP) GO TO 150
      MPQ=IA(MP)+MQ
      MRS=IA(MR)+MS
      IF(MP.EQ.MQ) VAL1 = VAL1+VAL1
      IF(MR.EQ.MS) VAL3 = VAL3+VAL3
C
      IF(SKIPR) GO TO 141
      DO 140 MJ=1,NOC
         VAL1S=VAL1*CO(MS,MJ)
         XPQRJ(MJ,MPQ,MR-MINR+1)=XPQRJ(MJ,MPQ,MR-MINR+1)+VAL1S
         IF(MS.LE.LNUMC) 
     *      XPQRJI(MJ,MPQ,MR-MINR+1) = XPQRJI(MJ,MPQ,MR-MINR+1) + VAL1S
  140 CONTINUE
  141 IF(SKIPS) GO TO 143
      DO 142 MJ=1,NOC
         VAL1R=VAL1*CO(MR,MJ)
         XPQRJ(MJ,MPQ,MS-MINR+1)=XPQRJ(MJ,MPQ,MS-MINR+1)+VAL1R
         IF(MR.LE.LNUMC) 
     *      XPQRJI(MJ,MPQ,MS-MINR+1) = XPQRJI(MJ,MPQ,MS-MINR+1) + VAL1R
  142 CONTINUE
  143 IF(SKIPP) GO TO 145
      DO 144 MJ=1,NOC
         VAL3Q=VAL3*CO(MQ,MJ)
         XPQRJ(MJ,MRS,MP-MINR+1)=XPQRJ(MJ,MRS,MP-MINR+1)+VAL3Q
         IF(MQ.LE.LNUMC) 
     *      XPQRJI(MJ,MRS,MP-MINR+1) = XPQRJI(MJ,MRS,MP-MINR+1) + VAL3Q
  144 CONTINUE
  145 IF(SKIPQ) GO TO 150
      DO 146 MJ=1,NOC
         VAL3P=VAL3*CO(MP,MJ)
         XPQRJ(MJ,MRS,MQ-MINR+1)=XPQRJ(MJ,MRS,MQ-MINR+1)+VAL3P
         IF(MP.LE.LNUMC) 
     *      XPQRJI(MJ,MRS,MQ-MINR+1) = XPQRJI(MJ,MRS,MQ-MINR+1) + VAL3P
  146 CONTINUE
C
  150 CONTINUE
      IF(NPACKIC.EQ.0) NPACKIC=NINTIC
C     SWITCH TO INTEGRALS ON DISK
      IF(NXX.GT.0) GO TO 100
  200 CONTINUE
      RETURN
 9999 FORMAT(' INCONSISTENT FILE PARAMETERS IN -MP2O1D-. STOP')
 9998 FORMAT(5X,'*** PROGRAM STOP IN -MP2O1D- ***')
      END
C
C*MODULE DCMP2   *DECK MP2OED
C        MODIFIED FROM MP2OE
      SUBROUTINE MP2OED(E,AIBJ,AIBJ2,EIJ,E2,E2OC,E2VI,
     *                  NBF,NOC,NVIR,IODA20)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION E(*),AIBJ(NBF,NOC,NOC),AIBJ2(NBF,NOC,NOC)
      DIMENSION EIJ(NOC,NOC),IODA20(*)
C
      COMMON /COMPE2/ E2PARA,E2OPOS
      COMMON /MP2DAF/ IDAF20,NAV20
C
      LOGICAL DODCCR,ONLYOC,RMKORB,FZCORE,DOMP1,HFFRM
      COMMON /DCCORR/ RBUFCR,WOCC,ISTCOR,ITPART,DODCCR,ONLYOC,RMKORB,
     *                FZCORE,DOMP1,HFFRM
C
      DATA ZERO /0.0D+00/
      DATA PT5  /0.5D+00/
      DATA ONE  /1.0D+00/
C
C     ----- CALCULATE E(2) AND ORBITAL-PAIR CONTRIBUTIONS TO E(2) -----
C
      E2OC=ZERO
      E2VI=ZERO
      DO 15 MJ=1,NOC
         DO 10 MI=1,NOC
            EIJ(MI,MJ)=ZERO
   10    CONTINUE
   15 CONTINUE
C
      DO 690 MA=1,NVIR
         DO 520 MI=1,NOC
            MAI=MI+NOC*(MA-1)
            MAI2=MAI+NVIR*NOC
            CALL RAREAD(IDAF20,IODA20,AIBJ(1,1,MI),NBF*NOC,MAI,0)
            CALL RAREAD(IDAF20,IODA20,AIBJ2(1,1,MI),NBF*NOC,MAI2,0)
  520    CONTINUE
         SUMPAV=ZERO
         SUMOPV=ZERO
         IF(.NOT.ONLYOC) THEN
            DO 580 MI=1,NOC
               DO 570 MB=1,NVIR
                  MAX=NOC
CC                  IF(MB.EQ.MA) MAX=MI
                  DO 560 MJ=1,MAX
                     XAIBJ=AIBJ(MB,MJ,MI)
                     XAIBJ2=AIBJ2(MB,MJ,MI)
                     XAJBI2=AIBJ2(MB,MI,MJ)
                     DAIBJ=XAIBJ/(E(MA+NOC)+E(MB+NOC)-E(MI)-E(MJ))
                     EAIBJP=(XAIBJ2-XAJBI2)*DAIBJ
                     EAIBJO=XAIBJ2*DAIBJ
                     SUMPAV=SUMPAV-EAIBJP
                     SUMOPV=SUMOPV-EAIBJO
                     EAIBJ=EAIBJP+EAIBJO
                     IF(MI.EQ.MJ) EAIBJ=EAIBJ*PT5
                     EIJ(MI,MJ)=EIJ(MI,MJ)-EAIBJ
                     EIJ(MJ,MI)=EIJ(MJ,MI)-EAIBJ
  560             CONTINUE
  570          CONTINUE
  580       CONTINUE
            E2VI=E2VI+SUMPAV+SUMOPV
         END IF
C
         DO 620 MI=1,NOC
            MAI=MI+NOC*(MA-1)
            MAI3=MAI+NVIR*NOC*2
            CALL RAREAD(IDAF20,IODA20,AIBJ2(1,1,MI),NBF*NOC,MAI3,0)
  620    CONTINUE
         SUMPAO=ZERO
         SUMOPO=ZERO
         DO 680 MI=1,NOC
            DO 670 MB=1,NVIR
               MAX=NOC
CC               IF(MB.EQ.MA) MAX=MI
               DO 660 MJ=1,MAX
                  XAIBJ=AIBJ(MB,MJ,MI)
                  XAIBJ2=AIBJ2(MB,MJ,MI)
                  XAJBI2=AIBJ2(MB,MI,MJ)
                  DAIBJ=XAIBJ/(E(MA+NOC)+E(MB+NOC)-E(MI)-E(MJ))
                  EAIBJP=(XAIBJ2-XAJBI2)*DAIBJ
                  EAIBJO=XAIBJ2*DAIBJ
                  SUMPAO=SUMPAO-EAIBJP
                  SUMOPO=SUMOPO-EAIBJO
                  EAIBJ=EAIBJP+EAIBJO
                  IF(MI.EQ.MJ) EAIBJ=EAIBJ*PT5
                  EIJ(MI,MJ)=EIJ(MI,MJ)-EAIBJ
                  EIJ(MJ,MI)=EIJ(MJ,MI)-EAIBJ
  660          CONTINUE
  670       CONTINUE
  680    CONTINUE
         E2OC  =E2OC  +SUMPAO+SUMOPO
C
         E2PARA=E2PARA+SUMPAO*WOCC+SUMPAV*(ONE-WOCC)
         E2OPOS=E2OPOS+SUMOPO*WOCC+SUMOPV*(ONE-WOCC)
  690 CONTINUE
C
      E2=E2OC*WOCC+E2VI*(ONE-WOCC)
C
      RETURN
C
      END
C
C*MODULE DCMP2   *DECK MP2OSD
C        MODIFIED FROM MP2OS
      SUBROUTINE MP2OSD(AIBJ,MOSIRP,NBF,NOC,NVIR,IODA20)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL SYM2EI
C
      COMMON /MP2DAF/ IDAF20,NAV20
      COMMON /SYMBLK/ NIRRED,NSALC,NSALC2,NSALC3,NSAFMO
C
      DIMENSION AIBJ(NBF,NOC,NOC),MOSIRP(*),IODA20(*)
C
      DATA ZERO /0.0D+00/
C
      IF(NIRRED.EQ.1) RETURN
C
C     ----- SIFT INTEGRALS FOR SYMMETRY ZEROES -----
C
      DO 70 LOOP=0,2
      DO 50 MA=1,NVIR
         DO 10 MI=1,NOC
            MAI=MI+NOC*(MA-1)+LOOP*NOC*NVIR
            CALL RAREAD(IDAF20,IODA20,AIBJ(1,1,MI),NBF*NOC,MAI,0)
   10    CONTINUE
         ISYMA = MOSIRP(MA+NOC)
         DO 30 MI=1,NOC
            ISYMI = MOSIRP(MI)
            DO 25 MB=1,MA
               ISYMB = MOSIRP(MB+NOC)
               MAX=NOC
               IF(MB.EQ.MA) MAX=MI
               DO 20 MJ=1,MAX
                  ISYMJ = MOSIRP(MJ)
                  IF(.NOT.SYM2EI(ISYMA,ISYMI,ISYMB,ISYMJ))
     *                 AIBJ(MB,MJ,MI)=ZERO
                  IF(.NOT.SYM2EI(ISYMA,ISYMJ,ISYMB,ISYMI))
     *                 AIBJ(MB,MI,MJ)=ZERO
   20          CONTINUE
   25       CONTINUE
   30    CONTINUE
         DO 40 MI=1,NOC
            MAI=MI+NOC*(MA-1)
            CALL RAWRIT(IDAF20,IODA20,AIBJ(1,1,MI),NBF*NOC,MAI,0)
   40    CONTINUE
   50 CONTINUE
   70 CONTINUE
      RETURN
      END
C
C*MODULE DCMP2   *DECK MP2SDC
C        MODIFIED FROM MP2S
      SUBROUTINE MP2SDC(E2,E2OC,E2VI,E,C,XPQRJ,XPQRJI,XPQRJA,XX,IX,
     *                  X,Y,MOSIRP,NBF,NBF3,NOC,NVIR,NDIM,IJKX,NPASS,
     *                  LPASS,GHONDO,XINTS,DDIJ,NINTMX,MAXG,NSH2,MXG2)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL SOME,OUT,DBUG
C
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      DIMENSION E(*),C(NBF,*),XPQRJ(*),XPQRJI(*),XPQRJA(*),
     *          X(NBF3),Y(NBF3),MOSIRP(*),
     *          GHONDO(MAXG),XINTS(NSH2),DDIJ(MXG2),
     *          XX(NINTMX),IX(NINTMX)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /DIRMEM/ IPQKL,IVEC,IDEN,IFCK,NUM,NOCC,NNNDIM,MINPQ,MAXPQ
      COMMON /MP2PRT/ SOME,OUT,DBUG
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
      LOGICAL DODCCR,ONLYOC,RMKORB,FZCORE,DOMP1,HFFRM
      COMMON /DCCORR/ RBUFCR,WOCC,ISTCOR,ITPART,DODCCR,ONLYOC,RMKORB,
     *                FZCORE,DOMP1,HFFRM
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
      E2OC = ZERO
      E2VI = ZERO
      J0 = 1
      CALL TSECND(TIM1)
C
C     ----- LOOP OVER NUMBER OF PASSES -----
C     ----- FOR ALL  J = J0, ..., J0+NOCC-1 -----
C
      DO 100 IPASS=1,NPASS
         NOCC = MIN(NOC,J0+LPASS-1)-J0+1
C
C     ----- FORM -(PQ/RJ)- -----
C
         CALL MP2C1D(IJKX,XPQRJ,XPQRJI,XX,IX,C(1,J0),
     *               NBF,NOCC,NDIM,GHONDO,XINTS,DDIJ,MAXG,NSH2,3)
C
C     ----- FORM -(AI/RJ)- ALL A,I -----
C
         CALL MP2C23(XPQRJ,X,Y,C,NBF,NVIR,NOC,NOCC,NDIM,NBF)
         CALL MP2C23(XPQRJI,X,Y,C,NBF,NVIR,NOC,NOCC,NDIM,NBF)
C
         IF(.NOT.ONLYOC) CALL DCOPY(NOCC*NDIM*NBF,XPQRJ,1,XPQRJA,1)
C
C     ----- FORM -(AI/BJ)-  ALL B -----
C
         CALL MP2S4(XPQRJ,X,Y,C(1,NOC+1),MOSIRP,J0,NOC,NVIR,NBF,
     *              NOCC,NDIM,NBF)
         CALL MP2S4(XPQRJI,X,Y,C(1,NOC+1),MOSIRP,J0,NOC,NVIR,NBF,
     *              NOCC,NDIM,NBF)
         IF(.NOT.ONLYOC)
     *      CALL MP2S4(XPQRJA,X,Y,C(1,NOC+1),MOSIRP,J0,NOC,NVIR,NBF,
     *                 NOCC,NDIM,LNUMC)
C
C     ------ CALCULATE PARTIAL CONTRIBUTION TO E(2) FROM THIS
C            BATCH -----
C
C     E(2) = SUM (J)  SUM(AIB) (AI/BJ) * ( 2*(AI/BJ)-(BI/AJ) ) /
C                              (E(A)+E(B)-E(I)-E(J))
C
         CALL MP2SED(E,XPQRJ,XPQRJI,E2OC,J0,NOC,NVIR,NOCC,NDIM,WOCC)
         IF(.NOT.ONLYOC)
     *      CALL MP2SED(E,XPQRJ,XPQRJA,E2VI,J0,NOC,NVIR,NOCC,NDIM,
     :                  ONE-WOCC)
C
         J0 = J0+NOCC
         IVEC = IVEC+NOCC*NBF
C
         IF(SOME) THEN
            CALL TSECND(TIM2)
            TIME = TIM2-TIM1
            TIM1 = TIM2
            WRITE(IW,9020) IPASS,TIME
            CALL FLSHBF(IW)
         END IF
  100 CONTINUE
C
      E2=E2OC*WOCC+E2VI*(ONE-WOCC)
      RETURN
C
 9020 FORMAT(1X,'PASS #',I4,' TOOK',F12.2,' SECONDS.')
      END
C
C*MODULE DCMP2   *DECK MP2C1D
C        MODIFIED FROM MP2C1
      SUBROUTINE MP2C1D(NFT8,XPQRJ,XPQRJI,XX,IX,C,NUM,NOC,NDIM,
     *                  GHONDO,XINTS,DDIJ,MAXG,NSH2,IDCMOD)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL DIRSCF,FDIFF,DIRTRF,PACK2E
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION XPQRJ(NOC,NDIM,NUM),C(NUM,*),XX(*),IX(*),
     *          GHONDO(MAXG),XINTS(NSH2),DDIJ(*)
      DIMENSION XPQRJI(NOC,NDIM,NUM)
C
      COMMON /DIRCAS/ I2CASE
      COMMON /DIRMEM/ IPQRJ,IVEC,IDEN,IFCK,NNNUM,NOCC,NNNDIM,MINPQ,MAXPQ
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /INT2IC/ NINTIC,ININTIC,NXXIC,LBUFPIC,LIXIC,LABSIX,NINTIX
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /TRFOPT/ CUTTRF,NWDTRF,MPTRAN,ITRFAO,NOSYMT,IPURTF,DIRTRF
C
C     ----- FORM (PQ/RJ) = SUM OVER S OF (PQ/RS) * C(S,J) -----
C
      CALL VCLR(XPQRJ,1,NOC*NDIM*NUM)
      CALL VCLR(XPQRJI,1,NOC*NDIM*NUM)
C
C     ----- DIRECT MP2 -----
C
      IF(DIRSCF) THEN
         I2CASE=3
         NOCC = NOC
         DIRTRF=.TRUE.
         NINTICS=NINTIC
         NINTIC=0
         CALL DIRJKDC(GHONDO,XINTS,DDIJ,XX,IX,MAXG,NSH2)
         NINTIC=NINTICS
C
C     ----- DISK BASED -----
C
      ELSE
         CALL SEQREW(NFT8)
C        FIRST, PROCESS IN CORE INTEGRALS
         NPACKIC=0
   10    CONTINUE
         IF(NPACKIC.EQ.0.AND.NINTIC.NE.0) THEN
            NXX=NXXIC
            NINT=NXX
         ELSE
C           IF ALL IN CORE BAIL OUT
            IF(NINTIC.NE.0.AND.NXXIC.LT.NINTIC) RETURN
            CALL PREAD(NFT8,XX(NINTIC+1),IX(ININTIC+1),NXX,NINTMX)
            IF(NXX.EQ.0) RETURN
            NINT=IABS(NXX)
            IF(NINT.GT.NINTMX) THEN
               IF(MASWRK) WRITE(IW,9999)
               IF(MASWRK) WRITE(IW,9998)
               CALL ABRT
            END IF
         ENDIF
         CALL ONETFD(XPQRJ,XPQRJI,C,NDIM,NUM,NOC,XX,IX,NXX,NPACKIC,
     *               IDCMOD)
         IF(NPACKIC.EQ.0) NPACKIC=NINTIC
         IF(NXX.GT.0) GO TO 10
      END IF
      RETURN
 9999 FORMAT(' INCONSISTENT FILE PARAMETERS IN -MP2C1D-. STOP')
 9998 FORMAT(5X,'*** PROGRAM STOP IN -MP2C1D- ***')
      END
C
C*MODULE DCMP2   *DECK MP2SED
C        MODIFIED FROM MP2SE
      SUBROUTINE MP2SED(E,AIBJ,AIBJ2,E2,J0,NOC,NVIR,NOCC,NDIM,W)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      COMMON /COMPE2/ E2PARA,E2OPOS
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOL,METHOD,NWDMP2,MEMPRI,MPPROP,
     *                NACORE,NBCORE,NOA,NOB,NORB,NBF,NOMIT,MOCPHF,
     *                MAXITC
C
      PARAMETER (ZERO=0.0D+00)
C
      DIMENSION AIBJ(NOCC,NDIM,NVIR),AIBJ2(NOCC,NDIM,NVIR),E(*)
C
C     ----- FORM PARTIAL CONTRIBUTION TO THE E(2) ENERGY -----
C
      MAI = 0
      EPARA=ZERO
      EOPOS=ZERO
      DO 25 MA=1,NVIR
         DO 20 MI=1,NOC
            MAI = MAI+1
            DO 15 MB=1,NVIR
               MBI = NOC*(MB-1)+MI
               DO 10 MJ=1,NOCC
                  XAIBJ  = AIBJ(MJ,MAI,MB)
                  IF(ABS(XAIBJ).LT.TOL) GO TO 10
                  XAIBJ2 = AIBJ2(MJ,MAI,MB)
                  XAJBI2 = AIBJ2(MJ,MBI,MA)
                  DAIBJ = E(MA+NOC)+E(MB+NOC)-E(MI)-E(MJ+J0-1)
                  TEMP1 = XAIBJ/DAIBJ
                  EPARA = EPARA+TEMP1*(XAIBJ2-XAJBI2)
                  EOPOS = EOPOS+TEMP1*XAIBJ2
   10          CONTINUE
   15       CONTINUE
   20    CONTINUE
   25 CONTINUE
      E2     = E2 - EPARA - EOPOS
      E2PARA = E2PARA - EPARA*W
      E2OPOS = E2OPOS - EOPOS*W
C
      RETURN
      END
C
C*MODULE DCMP2   *DECK NUMCORDC
C        MODIFIED FROM NUMCOR
      INTEGER FUNCTION NUMCORDC()
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXATM=2000)
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      DIMENSION NCORES(103)
C
      DOUBLE PRECISION LMOEDA
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /ECP2  / CLP(400),ZLP(400),NLP(400),KFIRST(MXATM,6),
     *                KLAST(MXATM,6),LMAX(MXATM),LPSKIP(MXATM),
     *                IZCORE(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NEX,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
C
      DATA LMOEDA /8HLMOEDA  /
      DATA NCORES /2*0,
     *             2*1,                     6*1,
     *             2*5,                     6*5,
     *             2*9,          10*9,    9,5*14,
     *             2*18,         10*18,  18,5*23,
     *             2*27,  14*27, 10*34,  34,5*39,
     *             2*43,  14*43,    50/
C
C        RETURN THE NUMBER OF CHEMICAL CORE ORBITALS, OF COURSE
C        OMITTING ANY DROPPED BY USE OF EFFECTIVE CORE POTENTIALS.
C
C     APRIL 2007.
C        THE MAIN GROUP SP BLOCK WAS CHANGED FROM 6*14, 6*23, 6*39 TO
C        REMOVE THE GROUP 13'S D SHELLS FROM BEING DEFINED AS "CORE".
C        RATIONAL IS THE FOLLOWING MINI EIGENDATA (KEEP IN MIND THAT
C        THESE MAY BE OFF BY -0.1 HARTREE OR MORE DUE TO THE SMALL
C        BASIS, E.G. SBKJC'S EIGENVALUE FOR GA'S 5D IS -1.15)
C
C             N=4 ROW    ZN      GA      GE      AS
C             (N-1)S   -5.617  -6.289  -7.097  -7.942
C             (N-1)P   -3.822  -4.379  -5.068  -5.793
C             (N-1)D   -0.765  -1.025  -1.474  -1.956
C               NS     -0.288  -0.407  -0.539  -0.672
C               NP       N/A   -0.201  -0.280  -0.363
C
C             N=5 ROW    CD      IN      SN      SB
C             (N-1)S   -4.424  -4.955  -5.493  -6.043
C             (N-1)P   -3.028  -3.488  -3.752  -4.927
C             (N-1)D   -0.736  -1.047  -1.354  -1.672
C               NS     -0.260  -0.369  -0.474  -0.579
C               NP       N/A   -0.195  -0.263  -0.332
C
C             N=6 ROW    HG      TL      PB      BI
C             (N-1)S   -4.143  -4.585  -5.018  -5.461
C             (N-1)P   -2.820  -3.206  -3.594  -3.966
C             (N-1)D   -0.700  -0.957  -1.210  -1.461
C               NS     -0.260  -0.360  -0.456  -0.551
C               NP       N/A   -0.192  -0.255  -0.320
C
C        SBKJC RETAINS (N-1) S, P, AND D SHELLS IN SEMI-CORE SETS
C        FOR GA, IN, TL, WHOSE EIGEN DATA ARGUE THAT (N-1)D IS
C        MORE LIKE "SUBVALENCE" THAN "CORE".
C
      NCORE = 0
      DO 100 I0=1,NLAT
         I=LOC2TA(I0)
         IZ = INT(ZAN(I)) + IZCORE(I)
         IF(IZ.LE.0) GO TO 100
         IF(RUNTYP.EQ.LMOEDA .AND. INT(ZAN(I)).EQ.0) GO TO 100
         IF((IZ.GT.103) .AND. MASWRK) WRITE(IW,*)
     *          'Z.GT.103 IN SETTING CORE COUNT'
         IF(IZ.GT.103) CALL ABRT
         NCORE = NCORE + NCORES(IZ) - IZCORE(I)/2
  100 CONTINUE
C
      NUMCORDC = NCORE
      RETURN
      END
C
C*MODULE DCMP2   *DECK RDMPDC
      SUBROUTINE RDMPDC(ESUB,ESUBOC,ESUBVI,L1AT,ECORMP,E2OC,E2VI,
     *                  EMP1,ISTCOR,DOMP1,IDMP)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION ESUB(L1AT),ESUBOC(L1AT),ESUBVI(L1AT)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,DOMP1
      CHARACTER*8 STVEC
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     *** READ PARTIAL SUBSYSTEM MP2 ENERGY FOR RESTART ***
C
C
C     POSITION THE INPUT FILE TO $MP2RES
C
      STVEC = ' $MP2RES'
      CALL SEQREW(IR)
      CALL FNDGRP(IR,STVEC,IEOF)
C
      IF (IEOF.NE.0) THEN
C
C        $MP2RES CARD NOT FOUND, KILL JOB
C
         IF (MASWRK) WRITE(IW,9020)
         CALL ABRT
         STOP
C
      ELSE
C
C        $MP2RES CARD FOUND, READ THE CANONICAL DENSITY MATRIX
C
         IF (MASWRK) THEN
            DO I0=1,ISTCOR-1
               READ(IR,9040,END=300,ERR=300) IDUM,E2SOC,E2SVI,E2SUB
               IF(IDUM.NE.I0) WRITE(IW,9300) IDUM,I0
               ESUB(I0)=E2SUB
               ESUBOC(I0)=E2SOC
               ESUBVI(I0)=E2SVI
               ECORMP=ECORMP+E2SUB
               E2OC  =E2OC  +E2SOC
               E2VI  =E2VI  +E2SVI
               WRITE(IW  ,9100) I0,E2SOC,E2SVI,E2SUB
               WRITE(IDMP,9040) I0,E2SOC,E2SVI,E2SUB
               IF(DOMP1) THEN
                  READ(IR,9040,END=300,ERR=300) E1SOC,E1SVI,E1SUB
                  EMP1  =EMP1  +E1SUB
                  E2OC  =E2OC  +E1SOC
                  E2VI  =E2VI  +E1SVI
                  ECORMP=ECORMP+E1SUB
                  E2SOC =E2SOC +E1SOC
                  E2SVI =E2SVI +E1SVI
                  E2SUB =E2SUB +E1SUB
                  WRITE(IW  ,9110) E1SOC,E1SVI,E1SUB
                  WRITE(IW  ,9120) E2SOC,E2SVI,E2SUB
                  WRITE(IDMP,9045) E1SOC,E1SVI,E1SUB
               END IF
            END DO
         END IF
C
         IF (GOPARR) CALL DDI_BCAST(11201,'F',ESUB,  ISTCOR-1,MASTER)
         IF (GOPARR) CALL DDI_BCAST(11202,'F',ESUBOC,ISTCOR-1,MASTER)
         IF (GOPARR) CALL DDI_BCAST(11203,'F',ESUBVI,ISTCOR-1,MASTER)
C
      END IF
C
      RETURN
C
  300 CONTINUE
      IF (MASWRK) WRITE(IW,9200) 
      CALL ABRT
      STOP
C
 9020 FORMAT(31H NO $MP2RES INPUT FOUND - STOP  )
 9040 FORMAT(I5,3E21.12)
 9045 FORMAT(5X,3E21.12)
 9100 FORMAT(1X,'ISUB=',I5,' E2OC=',E15.7,' E2VI=',E15.7,' E2=',E15.7)
 9110 FORMAT(1X,' SINGLES:  E1OC=',E15.7,' E1VI=',E15.7,' E1=',E15.7)
 9120 FORMAT(1X,' TOTAL  :  E2OC=',E15.7,' E2VI=',E15.7,' E2=',E15.7)
 9200 FORMAT(' *** ERROR: PREMATURE END OF $MP2RES')
 9300 FORMAT(' *** WARNING:'/
     *       ' $MP2RES ENCOUNTERED SUBSYSTEM ',I5,' WHEN READING',I5)
      END
C
C*MODULE DCMP2   *DECK MP2DC1
      SUBROUTINE MP2DC1(VEC,ENG,F,L1,L2,E1SUB,E1OC,E1VI)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL SOME,OUT,DBUG,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOL,METHOD,NWDMP2,MEMPRI,MPPROP,
     *                NACORE,NBCORE,NOA,NOB,NO,NBF,NOMIT,MOCPHF,MAXITC
      COMMON /MP2PRT/ SOME,OUT,DBUG
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
C
      LOGICAL DODCCR,ONLYOC,RMKORB,FZCORE,DOMP1,HFFRM
      COMMON /DCCORR/ RBUFCR,WOCC,ISTCOR,ITPART,DODCCR,ONLYOC,RMKORB,
     *                FZCORE,DOMP1,HFFRM
C
      DATA CHECK/8HCHECK   /, RMP2DC/8HMP2DC   /
C
      PARAMETER (ONE=1.0D+00, TWO=2.0D+00, ZERO=0.0D+00)
C
      DIMENSION VEC(L1,L1),ENG(L1),F(L2)
C
C VEC     : MATRIX OF MO COEFFICIENTS        NBF  *  NBF
C ENG     : ORBITAL ENERGIES                 NBF
C
C     ----- MAIN CLOSED-SHELL MP2 SINGLES ENERGY DRIVER -----
C
      SOME=NPRINT.NE.-5 .AND. MASWRK
      OUT =EXETYP.EQ.RMP2DC .AND. MASWRK
C
      NOC  = NOA - NACORE
      NVIR = NO  - NOA
C
C    ----- MEMORY POINTERS FOR MP2 ENERGY -----
C
C IFIA    : F_I-A MATRIX                     NOC * NVIR
C IFIA2   : PARTIALLY TRANSFORMED F_I-A      NOC * NVIR
C IWRK    : WORK HOLDING F_MU-A              NBF * NVIR
C
      CALL VALFM(LOADFM)
      IFIA   = 1    + LOADFM
      IFIA2  = IFIA + NVIR*NOC
      IWRK   = IFIA2+ NVIR*NOC
      LAST   = IWRK + NBF*MAX(NVIR,NOC)
      NEEDA  = LAST - LOADFM - 1
      CALL GETFM(NEEDA)
C
      IF(EXETYP.EQ.CHECK) GO TO 900
C
C     PARALLELL
C
CCC      IF(GOPARR) GO TO 600
      E1OC=ZERO
      E1VI=ZERO
C
C     *** CONFIRM TOTAL F_IA TERM ***
C
      CALL MTARBR(F,L1,VEC(1,NOC+1),NVIR,X(IWRK),L1,1)
      CALL MRTRBR(VEC,L1,L1,NOC,X(IWRK),L1,NVIR,X(IFIA),NOC)
C
      FIAMAX=ZERO
      DO IA=1,NVIR
         DO II=1,NOC
            FIA=X(II+NOC*(IA-1)+IFIA-1)
            FIAMAX=MAX(FIAMAX,ABS(FIA))
         END DO
      END DO
      IF(MASWRK) WRITE(IW,9030) FIAMAX
C
C     *** OCCUPIED F_IA CONTRIBUTION ***
C
      CALL MTARBR(F,L1,VEC(1,NOC+1),NVIR,X(IWRK),L1,1)
      CALL MRTRBR(VEC,L1,LNUMC,NOC,X(IWRK),L1,NVIR,X(IFIA2),NOC)
C
      DO IA=1,NVIR
         EA=ENG(NOC+IA)
         DO II=1,NOC
            EI=ENG(II)
            EDIFF=EA-EI
            FIA=X(II+NOC*(IA-1)+IFIA-1)
            FIA2=X(II+NOC*(IA-1)+IFIA2-1)
            E1OC=E1OC - TWO*FIA*FIA2/EDIFF
         END DO
      END DO
C
C     *** VIRTUAL F_IA CONTRIBUTION ***
C
      IF(.NOT.ONLYOC) THEN
         CALL MTARBR(F,L1,VEC,NOC,X(IWRK),L1,1)
         CALL MRTRBR(VEC(1,NOC+1),L1,LNUMC,NVIR,X(IWRK),L1,NOC,
     *               X(IFIA2),NVIR)
C
         DO II=1,NOC
            EI=ENG(II)
            DO IA=1,NVIR
               EA=ENG(NOC+IA)
               EDIFF=EA-EI
               FIA=X(II+NOC*(IA-1)+IFIA-1)
               FIA2=X(IA+NVIR*(II-1)+IFIA2-1)
               E1VI=E1VI - TWO*FIA*FIA2/EDIFF
            END DO
         END DO
      END IF
C
      E1SUB=E1OC*WOCC+E1VI*(ONE-WOCC)
C
      CALL RETFM(NEEDA)
C
  900 CONTINUE
      RETURN
C
 9030 FORMAT(/1X,'MAXIMUM ABSOLUTE F_IA VALUE=',E15.7/)
C
      END
C
C*MODULE DCMP2   *DECK MP2DDIDC
C        MODIFIED FROM MP2DDI
      SUBROUTINE MP2DDIDC(VEC,ENG,Q,S,L1,L2,E2SUB,E2OC,E2VI)
C
C -----------------------------------------------------------------
C  DRIVING ROUTINE FOR PARALLEL DC-MP2 (GRADIENT)
C -----------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000)
      LOGICAL GOPARR,DSKWRK,MASWRK,OUTPUT,MP2ENG,UMPENG,UMP2GD,ZAPTGD
      LOGICAL MPGRUN,EONLY,DIRTRF,SECONDD
C
      DIMENSION VEC(*),ENG(L1),Q(L1,L1),S(L2)
C
      COMMON /CXTHRM/ CXTHERM(11),CXZPE,METHCX,ICXBAS,ICXPCM,SECONDD
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /FMCOM / XX(1)
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOL,METHOD,NWORD,MEMPRI,MPPROP,
     *                NACORE_MP2PAR,NBCORE_MP2PAR,NOA,NOB,NO,NBF_MP2PAR,
     *                NOMIT,MOCPHF,MAXITC
      COMMON /MP2PTR/ IWMAT,IPMAT,IVECS,IPSCF,IVALS,ILABS,ISCHW,INEED
      COMMON /MP2XTR/ NBF,NACORE,NBSQ,NBTR,NSTR,MXSHL,NACT,NOCC
     *,               NVIR,NOV,NOSQ,NVSQ,NOTR,NVTR,NCP1,NOP1
     *,               NATR,ICHANL,OUTPUT,MP2ENG,IOST,NMOS,UMP2GD
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /TRFOPT/ CUTTRF,NWDTRF,MPTRAN,ITRFAO,NOSYMT,IPURTF,DIRTRF
      COMMON /UMPPTR/ IWMATB,IPMATB,IVECSB,IPSCFB,IVALSB,ILABSB
      COMMON /UMP2XB/ NBCORE,NACTB,NOCCB,NVIRB,NOVB,NOSB,NVSB,NOTB,
     *                NVTB,NCP1B,NOP1B,NATB,IOSTB,NOCCBLD
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      COMMON /ZAPTGR/ NOCD,NOCD1,NOCS,NOCSTR,IXYEXC,ICHIX,ITIA,IZVEC
     *,               ZAPTGD
C
      INTEGER         D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB
      LOGICAL         NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
      COMMON /TRFDMS/ D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB,
     *                NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
C
C FOR DC
      INTEGER         D_VOVOI,D_VOVOA
      COMMON /TRFDDC/ D_VOVOI,D_VOVOA
C
      LOGICAL DODCCR,ONLYOC,RMKORB,FZCORE,DOMP1,HFFRM
      COMMON /DCCORR/ RBUFCR,WOCC,ISTCOR,ITPART,DODCCR,ONLYOC,RMKORB,
     *                FZCORE,DOMP1,HFFRM
C
      DATA CHECK/8HCHECK   /
      DATA ZAPT/8HZAPT    /
      DATA UHF/8HUHF     /
      DATA G3MP2/8HG3MP2   /
C
      OUTPUT = MASWRK
      ICHANL = 6
      MPGRUN = .FALSE.
      UMPENG = .FALSE.
      UMP2GD = .FALSE.
      ZAPTGD = .FALSE.
C
C  CHOOSE THE DESIRED COMBINATION OF VIRTUAL AND OCCUPIED INDICES
C     IN THE TRANSFORMED INTEGRALS...
C  NDVOVO, NDVVOO, NDVOOO, NDOOOO ETC. SWITCH THE TYPES DONE
C     BY THE PARTRAN ROUTINE(S)
C  MP2ENG/UMPENG CAUSES AN ENERGY RUN, ONLY, W/O DENSITY OR GRADIENT
C
C  FIRST, CHOOSE THE APPROPRIATE TYPE(S) OF RUN
C
      CALL DERCHK(NDER)
      IF(RUNTYP.EQ.G3MP2) THEN
         IF(ICXBAS.EQ.1) NDER=1
         IF(ICXBAS.EQ.2) NDER=0
      END IF
      EONLY = NGLEVL.EQ.1  .OR.  NHLEVL.EQ.2
      IF((NDER.EQ.0  .AND.  MPPROP.EQ.0) .OR. EONLY) THEN
        MP2ENG = .TRUE.
        IF (SCFTYP.EQ.UHF) UMPENG = .TRUE.
        IF (OSPT.EQ.ZAPT) THEN
           MP2ENG = .FALSE.
           MPGRUN = .TRUE.
        END IF
      ELSE
        MPGRUN = .TRUE.
        IF (SCFTYP.EQ.UHF) UMP2GD = .TRUE.
        IF (OSPT.EQ.ZAPT)  ZAPTGD = .TRUE.
      END IF
C
C NOW FIGURE OUT WHICH DISTRIBUTED ARRAYS WE NEED
C (INITIALIZE ALL TO FALSE)
C
      NDVOVO   = .FALSE.
      NDVVOO   = .FALSE.
      NDVOOO   = .FALSE.
      NDOOOO   = .FALSE.
      NDVVVO   = .FALSE.
      NDVVVV   = .FALSE.
      NDVVOOBA = .FALSE.
      NDVVOOAB = .FALSE.
      NDVVOOBB = .FALSE.
      NDVOVOAB = .FALSE.
      NDVOVOBB = .FALSE.
      NDVOOOBA = .FALSE.
      NDVOOOAB = .FALSE.
      NDVOOOBB = .FALSE.
      NDOOOOAB = .FALSE.
      NDOOOOBB = .FALSE.
C
                 NDCORE = .TRUE.
      IF(MP2ENG) NDCORE = .FALSE.
C
      IF (MP2ENG) THEN
        NDVOVO   = .TRUE.
      END IF
      IF (UMPENG) THEN
        NDVOVOAB = .TRUE.
        NDVOVOBB = .TRUE.
      END IF
      IF (MPGRUN) THEN
        NDVOVO   = .TRUE.
        NDVVOO   = .TRUE.
        NDVOOO   = .TRUE.
        NDOOOO   = .TRUE.
      END IF
      IF (UMP2GD) THEN
        NDVVOOBA = .TRUE.
        NDVVOOAB = .TRUE.
        NDVVOOBB = .TRUE.
        NDVOVOAB = .TRUE.
        NDVOVOBB = .TRUE.
        NDVOOOBA = .TRUE.
        NDVOOOAB = .TRUE.
        NDVOOOBB = .TRUE.
        NDOOOOAB = .TRUE.
        NDOOOOBB = .TRUE.
      END IF
C
C  TITLE
C
      IF (OUTPUT) THEN
        CALL DERCHK(NDER)
        IF(RUNTYP.EQ.G3MP2) THEN
          IF(ICXBAS.EQ.1) NDER=1
          IF(ICXBAS.EQ.2) NDER=0
        END IF
      END IF
C
C  MAIN PARAMETERS
C
      NACORE= NACORE_MP2PAR  ! SIMPLEST TO COPY
      NBF   = NBF_MP2PAR     !  DIRECT FROM COMMON MP2PAR
      NMOS  = NQMT           !          AND COMMON INFOA
      NOCC  = NOA            ! FOR CLOSED-SHELL MP2
      NVIR  = NMOS-NOCC
      NACT  = NOCC-NACORE
C
      IF(OUTPUT) WRITE(ICHANL,9000) NACORE,NOCC,NMOS,NBF
C
C  USEFUL LENGTHS AND OFFSETS
C
      NBSQ = NBF*NBF
      NBTR = (NBF*NBF+NBF)/2
      NSTR = (NSHELL*NSHELL+NSHELL)/2
      NOV  = NOCC*NVIR
      NOSQ = NOCC*NOCC
      NOP1 = NOCC+1
      NOTR = (NOCC*NOCC+NOCC)/2
      NVSQ = NVIR*NVIR
      NVTR = (NVIR*NVIR+NVIR)/2
      NCP1 = NACORE+1
      NATR = (NACT*NACT+NACT)/2
C
C  RELATED BETA PARAMETERS IF WE ARE DOING UMP2 GRADIENTS
C
      IF (UMPENG.OR.UMP2GD) THEN
        NBCORE = NBCORE_MP2PAR  ! SIMPLEST TO COPY
        NOCCB  = NOB
        NOCCBLD= NOCCB
        IF (NOCCB.EQ.0) NOCCBLD=1
        NVIRB  = NMOS-NOCCB
        NACTB  = NOCCB-NBCORE
        NOVB  = NOCCB*NVIRB
        NOSB  = NOCCB*NOCCB
        NOP1B = NOCCB+1
        NOTB  = (NOCCB*NOCCB+NOCCB)/2
        NVSB  = NVIRB*NVIRB
        NVTB  = (NVIRB*NVIRB+NVIRB)/2
        NCP1B = NBCORE+1
        NATB  = (NACTB*NACTB+NACTB)/2
      END IF
C
C  A FEW PARAMETERS FOR ZAPT GRADIENTS
C
      IF (ZAPTGD) THEN
        NOCD  = NOB
        NOCD1 = NOCD + 1
        NOCS  = NOA - NOB
        NOCSTR= (NOCS*NOCS+NOCS)/2
      END IF
C
C  THIS PARAMETER, USED IN THE TRANSFORMATION ROUTINES,
C  STORES THE START OF THE 'ACTIVE' MO INDICES
C
      IF (MP2ENG) THEN
        IOST = NCP1
      ELSE
        IOST = 1
      END IF
C
      IF (UMPENG) THEN
        IOSTB= NCP1B
      ELSE
        IOSTB= 1
      END IF
C
C  POPLE INTEGRALS NEED SUFFICIENT WORKSPACE FOR SP SHELLS
C
      MXSHL = 4
      DO I = 1, NSHELL
        MXSHL = MAX0(MXSHL,KMAX(I)-KMIN(I)+1)
      END DO
C
C  BOTH CHECK OR REAL RUNS NOW COMPUTE AND PRINT THE MEMORY USAGE
C
      CALL PMP2CHK
      IF (EXETYP.EQ.CHECK) RETURN
C
C  ALLOCATE PRINCIPAL REPLICATED ARRAYS
C
      CALL VALFM(LOADFM)
      IF (MP2ENG.OR.(OSPT.EQ.ZAPT .AND. .NOT.ZAPTGD)) THEN
        ILABS = LOADFM + 1        !  MO LABELS
        ISCHW = ILABS  + NMOS     !  SCHWARZ INTS
        LAST  = ISCHW  + NSTR
        IWMAT = 1
        IPMAT = 1
        IPSCF = 1
        IF (UMPENG) THEN
           IVECSB = LAST          !  BETA MO COEFFICIENTS
           IVALSB = IVECSB + NBSQ !  BETA ORBITAL ENERGIES
           ILABSB = IVALSB + NBF  !  BETA MO LABELS
           LAST   = ILABSB + NMOS
        END IF
        INEED = LAST   - LOADFM
      ELSE IF (UMP2GD) THEN
        IWMAT = LOADFM + 1        !  W(2) MATRIX
        IWMATB= IWMAT  + NBSQ
        IPMAT = IWMATB + NBSQ     !  P(2) MATRIX
        IPMATB= IPMAT  + NBSQ
        IPSCF = IPMATB + NBSQ     !  SCF DENSITY
        IPSCFB= IPSCF  + NBSQ
        IVECS = IPSCFB + NBSQ     !  MO COEFFICIENTS
        IVECSB= IVECS  + NBSQ
        IVALS = IVECSB + NBSQ     !  ORBITAL ENERGIES
        IVALSB= IVALS  + NBF
        ILABS = IVALSB + NBF      !  MO LABELS
        ILABSB= ILABS  + NMOS
        ISCHW = ILABSB + NMOS     !  SCHWARZ INTS
        LAST  = ISCHW  + NSTR
        INEED = LAST   - LOADFM
      ELSE
        IWMAT = LOADFM + 1        !  W(2) MATRIX
        IPMAT = IWMAT  + NBSQ     !  P(2) MATRIX
        IPSCF = IPMAT  + NBSQ     !  SCF DENSITY
        IVECS = IPSCF  + NBSQ     !  MO COEFFICIENTS
        IVALS = IVECS  + NBSQ     !  ORBITAL ENERGIES
        ILABS = IVALS  + NBF      !  MO LABELS
        ISCHW = ILABS  + NMOS     !  SCHWARZ INTS
        LAST  = ISCHW  + NSTR
        IF (ZAPTGD) THEN
          NACD = NACT - NOCS
          NDS = NOCD * NOCS
          NDV = NOCD * NVIR
          NSV = NOCS * NVIR
          IXYEXC = LAST
          ICHIX  = IXYEXC + NOCS           !  ORBITAL ENERGY COMPONENT
          ITIA   = ICHIX  + NOCS           !  CHI X
          IZVEC  = ITIA + NACD*NVIR        !  TIA MATRIX
          LAST   = IZVEC + NDS + NDV + NSV !  Z-VECTOR
        END IF
        INEED = LAST   - LOADFM
      END IF
      CALL GETFM(INEED)
C
C  CREATE THE DISTRIBUTED DATA STRUCTURES
C
      IF (MP2ENG) THEN
C
C  [VO|VO] CLASS - FOR JUST THE ENERGY WE ONLY NEED VOVO CLASS
C                  SPANNING VALENCE/ACTIVE MOS ONLY (NOT CORE)
C  FOR UMP2, WE ALSO NEED THE AABB AND BBBB [VO|VO] INTEGRALS
C
        IF(NDVOVO  ) THEN
          CALL DDI_CREATE(NBSQ,NACT*NACT,D_VOVO)
          CALL DDI_CREATE(NBSQ,NACT*NACT,D_VOVOI)
          IF(.NOT.ONLYOC) CALL DDI_CREATE(NBSQ,NACT*NACT,D_VOVOA)
        END IF
        IF(NDVOVOAB) CALL DDI_CREATE(NBSQ,NACT*NACTB,D_VOVOAB)
        IF(NDVOVOBB) CALL DDI_CREATE(NBSQ,NATB,D_VOVOBB)
C
      ELSE
C
C  [VO|VO] CLASS - HERE INDEX -O- IS RUNNING OVER -ALL- OCCUPIED MOS
C
        IF(NDVOVO)   CALL DDI_CREATE(NBSQ,NOTR,D_VOVO)
        IF(NDVOVOAB) CALL DDI_CREATE(NBSQ,NOCC*NOCCB,D_VOVOAB)
        IF(NDVOVOBB) CALL DDI_CREATE(NBSQ,NOTB,D_VOVOBB)
C
C  [VO|OO] CLASS
C
        IF(NDVOOO)   CALL DDI_CREATE(NVIR, NOTR*NOCC, D_VOOO)
        IF(NDVOOOAB) CALL DDI_CREATE(NVIR, NOCC*NOTB, D_VOOOAB)
        IF(NDVOOOAB) CALL DDI_CREATE(NVIRB,NOCCB*NOTR,D_VOOOBA)
        IF(NDVOOOAB) CALL DDI_CREATE(NVIRB,NOCCB*NOTB,D_VOOOBB)
C
C  [VV|OO] CLASS
C  FOR ZAPT, CREATE THIS CLASS AFTER [OO|OO] INTEGRALS
C
        IF(.NOT.ZAPTGD .AND. NDVVOO) CALL DDI_CREATE(NBTR,NOTR,D_VVOO)
        IF(NDVVOOAB) CALL DDI_CREATE(NBTR,NOTB,D_VVOOAB)
        IF(NDVVOOBA) CALL DDI_CREATE(NBTR,NOTR,D_VVOOBA)
        IF(NDVVOOBB) CALL DDI_CREATE(NBTR,NOTB,D_VVOOBB)
C
C  [OO|OO] CLASS
C
        IF(NDOOOO)   CALL DDI_CREATE(NOTR,NOTR,D_OOOO)
        IF(NDOOOOAB) CALL DDI_CREATE(NOTB,NOTR,D_OOOOAB)
        IF(NDOOOOBB) CALL DDI_CREATE(NOTB,NOTB,D_OOOOBB)
C
C  [VV|OO] CLASS FOR ZAPT
C
        IF(ZAPTGD .AND. NDVVOO) CALL DDI_CREATE(NBTR,NOTR,D_VVOO)
C
      END IF
C
C  SET UMP2GD = TRUE EVEN IF WE ARE ONLY DOING UMP2 ENERGY
C
      IF (UMPENG) UMP2GD = .TRUE.
C
      IF(NOSYMT.EQ.1) CALL SYMOFF
C
C  GET DATA FOR INTEGRALS
C
      CALL PSETUPDC(VEC
     *,             VEC
     *,             XX(ISCHW)
     *,             XX(ILABS)
     *,             XX(ILABSB),Q,S)
C
C  COMPUTE MO INTEGRALS AND MP2 ENERGY CORRECTION
C
      CALL MOINTSDC(VEC
     *,             VEC
     *,             ENG
     *,             ENG
     *,             XX(ISCHW)
     *,             XX(ILABS)
     *,             XX(ILABSB)
     *,             E2SUB
     *,             E2OC
     *,             E2VI)
C
C  FINISHED WITH VOVO INTEGRALS, RETURN V,E,L,S WORKSPACES
C
      IF (MP2ENG) THEN
         IF(NDVOVOBB) CALL DDI_DESTROY( D_VOVOBB)
         IF(NDVOVOAB) CALL DDI_DESTROY( D_VOVOAB)
         IF(NDVOVO)   THEN
           IF(.NOT.ONLYOC) CALL DDI_DESTROY( D_VOVOA )
           CALL DDI_DESTROY( D_VOVOI )
           CALL DDI_DESTROY( D_VOVO )
         END IF
         CALL RETFM(INEED)
         RETURN
      END IF
C
      CALL DERCHK(NDER)
      IF(RUNTYP.EQ.G3MP2) THEN
         IF(ICXBAS.EQ.1) NDER=1
         IF(ICXBAS.EQ.2) NDER=0
      END IF
C
C  FORM SECOND ORDER CORRECTION TO DENSITY MATRIX
C
      IF((NDER.GT.0  .OR.  MPPROP.EQ.1)  .AND.  .NOT.EONLY) THEN
         IF(UMP2GD) THEN
           CALL UPAR1PDM(XX(IVECS),XX(IVECSB),XX(IVALS),XX(IVALSB),
     *                   XX(IPMAT),XX(IPMATB),XX(IPSCF),XX(IPSCFB),
     *                   XX(IWMAT),XX(IWMATB),XX(ISCHW),XX(ILABS),
     *                   XX(ILABSB))
         ELSE IF(ZAPTGD) THEN
           CALL ZPAR1PDM(XX(IVECS),XX(IVALS),XX(IPMAT),XX(IPSCF),
     *                   XX(IWMAT),XX(ISCHW),XX(ILABS),XX(IXYEXC),
     *                   XX(ITIA))
         ELSE
           CALL PAR1PDM(XX(IVECS),XX(IVALS),XX(IPMAT),XX(IPSCF),
     *                  XX(IWMAT),XX(ISCHW),XX(ILABS))
         END IF
         IF(NPRINT.NE.-5) CALL MP2NOS
         IF(MPPROP.EQ.1) THEN
            IF(NDVOVOBB) CALL DDI_DESTROY( D_VOVOBB)
            IF(NDVOVOAB) CALL DDI_DESTROY( D_VOVOAB)
            IF(ZAPTGD)   CALL DDI_DESTROY( D_OOOO  )
            IF(ZAPTGD)   CALL DDI_DESTROY( D_VOOO  )
            IF(NDVOVO)   CALL DDI_DESTROY( D_VOVO  )
            CALL RETFM(INEED)
         END IF
      ELSE
       IF (ZAPTGD) THEN
         IF(NDVVOO)   CALL DDI_DESTROY( D_VVOO)
         IF(NDOOOO)   CALL DDI_DESTROY( D_OOOO)
         IF(NDVOOO)   CALL DDI_DESTROY( D_VOOO)
         IF(NDVOVO)   CALL DDI_DESTROY( D_VOVO)
       ELSE
         IF(NDOOOOBB) CALL DDI_DESTROY( D_OOOOBB)
         IF(NDOOOOAB) CALL DDI_DESTROY( D_OOOOAB)
         IF(NDOOOO)   CALL DDI_DESTROY( D_OOOO)
         IF(NDVVOOBB) CALL DDI_DESTROY( D_VVOOBB)
         IF(NDVVOOBA) CALL DDI_DESTROY( D_VVOOBA)
         IF(NDVVOOAB) CALL DDI_DESTROY( D_VVOOAB)
         IF(NDVVOO)   CALL DDI_DESTROY( D_VVOO)
         IF(NDVOOOBB) CALL DDI_DESTROY( D_VOOOBB)
         IF(NDVOOOBA) CALL DDI_DESTROY( D_VOOOBA)
         IF(NDVOOOAB) CALL DDI_DESTROY( D_VOOOAB)
         IF(NDVOOO)   CALL DDI_DESTROY( D_VOOO)
         IF(NDVOVOBB) CALL DDI_DESTROY( D_VOVOBB)
         IF(NDVOVOAB) CALL DDI_DESTROY( D_VOVOAB)
         IF(NDVOVO)   CALL DDI_DESTROY( D_VOVO)
       END IF
       CALL RETFM(INEED)
      END IF
C
      IF(NOSYMT.EQ.1) CALL SYMON
      RETURN
 9000 FORMAT(/1X,'NCORE=',I5,'   NOCC=',I5,'   NMOS=',I5,'   NAOS=',I5/)
      END
C*MODULE DCMP2   *DECK PSETUPDC
C        MODIFIED FROM PSETUP
      SUBROUTINE PSETUPDC(CMO,CMOB,SCHWA,MOLABS,MOLABSB,Q,S)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000, MXAO=8192)
C
      LOGICAL OUT,OUTPUT,MP2ENG,UMP2GD,GOPARR,DSKWRK,MASWRK
C
      DIMENSION CMO(*),SCHWA(*),MOLABS(*)
      DIMENSION CMOB(*),MOLABSB(*)
      DIMENSION Q(*),S(*)
C
      COMMON /B     / CO(MXSH,3)
      COMMON /FMCOM / XX(1)
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /MP2XTR/ NBF,NACORE,NBSQ,NBTR,NSTR,MXSHL,NACT,NOCC
     *,               NVIR,NOV,NOSQ,NVSQ,NOTR,NVTR,NCP1,NOP1
     *,               NATR,ICHANL,OUTPUT,MP2ENG,IOST,NMOS,UMP2GD
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SHLT  / TOL,CUTOFF,ICOUNT,OUT
C
      PARAMETER (ONE=1.0D+00, TEN=10.0D+00, RLN10=2.30258D+00)
C
      DATA CHECK/8HCHECK   /
C
C -----------------------------------------------------------------
C  SET UP FOR INTEGRAL CODES, SCREENING
C -----------------------------------------------------------------
C
C  INITIALISE ERI COMPUTATION (= RELEVENT PARTS OF DEBUT)
C
      TOL = RLN10*ITOL
      CUTOFF = ONE/(TEN**ICUT)
C
      DO I = 1, NUM
        IA(I) = (I*I-I)/2
      END DO
C
C  INITIALIZATIONS FOR POPLE INTEGRALS
C
      DO I = 1, NSHELL
        ICC = KATOM(I)
        CO(I,1) = C(1,ICC)
        CO(I,2) = C(2,ICC)
        CO(I,3) = C(3,ICC)
      END DO
C
      MAXC = IDAMAX(NUM*NQMT,CMO,1)
      IF(ABS(CMO(MAXC)).GT.1.0D+02) THEN
         MAXM = 1 + MAXC/NUM
         MAXA = MAXC - NUM*(MAXM-1)
         IF(MASWRK) WRITE(IW,9010) ABS(CMO(MAXC)),MAXA,MAXM
      END IF
      IF(UMP2GD) THEN
        MAXC = IDAMAX(NUM*NQMT,CMOB,1)
        IF(ABS(CMOB(MAXC)).GT.1.0D+02) THEN
           MAXM = 1 + MAXC/NUM
           MAXA = MAXC - NUM*(MAXM-1)
           IF(MASWRK) WRITE(IW,9020) ABS(CMOB(MAXC)),MAXA,MAXM
        END IF
      END IF
C
C  READ EXCHANGE INTEGRALS (OVER SHELLS) FOR SCREENING
C
      IF(ISCHWZ.GT.0) THEN
         CALL DAREAD(IDAF,IODA,SCHWA,NSTR,54,0)
      ELSE
         CALL DCOPY(NSTR,ONE,0,SCHWA,1)
      END IF
C
C  GET IRREP NUMBER ASSIGNMENTS
C
      CALL VALFM(LOADFM)
      LWRK   = LOADFM + 1
      LMOSYM = LWRK   + NBF
      LMODEG = LMOSYM + NBF
      LAST   = LMODEG + NBF
      NEED   = LAST   - LOADFM
      CALL GETFM(NEED)
      IF(EXETYP.EQ.CHECK) GO TO 300
C
      CALL TRFSYM(XX(LMOSYM),MOLABS,XX(LMODEG),Q,
     *            S,CMO,XX(LWRK),IA,NQMT,NBF,NQMT,NBF)
      IF(UMP2GD) THEN
        CALL TRFSYM(XX(LMOSYM),MOLABSB,XX(LMODEG),Q,
     *              S,CMOB,XX(LWRK),IA,NQMT,NBF,NQMT,NBF)
      END IF
C
  300 CONTINUE
      CALL RETFM(NEED)
      RETURN
 9010 FORMAT(/1X,'*** WARNING: THE MAXIMUM LCAO COEF=',F15.6,
     *           ', FOR AO',I6,' IN MO=',I6,','/
     *        1X,'EXCEEDS 100.  ADDITIONAL INPUTS MAY BE REQUIRED TO',
     *           ' OBTAIN GOOD MP2 ACCURACY:'/
     *        1X,' $CONTRL ICUT=10 OR 11'/
     *        1X,' $SCF    CONV=2.5D-07 FDIFF=.FALSE.'/)
 9020 FORMAT(/1X,'*** WARNING: THE MAXIMUM LCAO COEF=',F15.6,
     *           ', FOR AO',I6,' IN BETA MO=',I6,','/
     *        1X,'EXCEEDS 100.  ADDITIONAL INPUTS MAY BE REQUIRED TO',
     *           ' OBTAIN GOOD MP2 ACCURACY:'/
     *        1X,' $CONTRL ICUT=10 OR 11'/
     *        1X,' $SCF    CONV=2.5D-07 FDIFF=.FALSE.'/)
      END
C*MODULE DCMP2   *DECK MOINTSDC
C        MODIFIED FROM MOINTS
      SUBROUTINE MOINTSDC(CMO,CMOB,EORB,EORBB,SCHWA,MOLABS,MOLABSB,
     *                    E2SUB,E2OC,E2VI)
C
C -----------------------------------------------------------------
C  DRIVER FOR PARALLEL 4-INDEX TRANSFORMATION USING DDI
C  (PSETUP,MOINTS,PARTRAN,SYMIJ,SYMIJKL,PARSHEL,TRAN1_H,TRAN1_P,
C   TRAN2,TRAN3,TRAN34,PEMP2,ZAPTE)
C -----------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER ( MXSH=5000, MXGSH=30, MXG2=MXGSH*MXGSH, MXATM=2000 )
      LOGICAL OUTPUT,MP2ENG,UMP2GD,ZAPTGD,ABELPT
      INTEGER MOLABS(*),MOLABSB(*)
      DOUBLE PRECISION CMO(NBF,*),EORB(*),SCHWA(*)
      DOUBLE PRECISION CMOB(NBF,*),EORBB(*)
C
      COMMON /FMCOM / XX(1)
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOL,METHOD,NWORD,MEMPRI,MPPROP,
     *                NACORE_MP2PAR,NBCORE_MP2PAR,NOA,NOB,NO,NBF_MP2PAR,
     *                NOMIT,MOCPHF,MAXITC
      COMMON /MP2XTR/ NBF,NACORE,NBSQ,NBTR,NSTR,MXSHL,NACT,NOCC
     *,               NVIR,NOV,NOSQ,NVSQ,NOTR,NVTR,NCP1,NOP1
     *,               NATR,ICHANL,OUTPUT,MP2ENG,IOST,NMOS,UMP2GD
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                TSYM(432),INVT(48),NT
      COMMON /UMP2XB/ NBCORE,NACTB,NOCCB,NVIRB,NOVB,NOSB,NVSB,NOTB,
     *                NVTB,NCP1B,NOP1B,NATB,IOSTB,NOCCBLD
      INTEGER         D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB
      LOGICAL         NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
      COMMON /TRFDMS/ D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB,
     *                NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
      COMMON /ZAPTGR/ NOCD,NOCD1,NOCS,NOCSTR,IXYEXC,ICHIX,ITIA,IZVEC
     *,               ZAPTGD
C
      DATA ZAPT/8HZAPT    /
C
C          NOTE THAT THERE IS ADDITIONAL MEMORY INSIDE -PARTRAN-
C
      CALL VALFM(LOADFM)
      IGOUT = 1     + LOADFM
      ITRAN = IGOUT + MXSHL**4
C
      CALL DDI_DISTRIB( D_VOVO , 0, ILO, IHI, JLO, JHI )
      IF (MP2ENG) THEN
        ITMP1 = ITRAN + MXSHL*MXSHL*NBF*NACT
        ITMP2 = ITMP1 + MAX0(NBSQ,JHI*MXSHL*NVIR)
        ITMP3 = ITMP2 + MAX0(NBSQ,JHI*MXSHL*NVIR)
        IDDIJ = ITMP3 + MAX0(NBSQ,JHI*MXSHL*NVIR)
      ELSE
        ITMP1 = ITRAN + MXSHL*MXSHL*NBF*NOCC
        ITMP2 = ITMP1 + MAX0(JHI*MXSHL*NVIR,
     *                  MAX0(NBSQ,MAX0(NOTR,NOTB)*MXSHL*MXSHL))
        IDDIJ = ITMP2 + MAX0(NBSQ,JHI*MXSHL*NVIR)
        ITMP3 = ITMP1
      END IF
C
      ITRANB  = IDDIJ + 49*MXG2
C
      IF (UMP2GD) THEN
        CALL DDI_DISTRIB( D_VOVOAB, 0, ILO, IHI, JLO, JHI )
        IF (MP2ENG) THEN
          ITMP1B= ITRANB+ MXSHL*MXSHL*NBF*NACTB
          ITMP2B= ITMP1B+ MAX0(NBSQ,JHI*MXSHL*NVIRB)
          LAST  = ITMP2B+ JHI*MXSHL*NVIRB
        ELSE
          ITMP1B= ITRANB+ MXSHL*MXSHL*NBF*NOCCB
          ITMP2B= ITMP1B+ MAX0(NBSQ,JHI*MXSHL*NVIRB)
          LAST  = ITMP2B+ JHI*MXSHL*NVIRB
        END IF
      ELSE
        ITMP1B= ITRANB
        ITMP2B= ITRANB
        LAST  = ITRANB
      END IF
      NEED  = LAST  - LOADFM
      CALL GETFM(NEED)
C
C  IN CASE OF NON-ABELIAN POINT GROUPS
C
      NTSAVE = NT
      IF (.NOT.ABELPT()) NT = 1
      CALL PARTRANDC(SCHWA
     P,              CMO,CMOB
     A,              XX(IGOUT)
     R,              XX(ITRAN),XX(ITRANB)
     T,              XX(ITMP1),XX(ITMP1B)
     R,              XX(ITMP2),XX(ITMP2B),XX(ITMP3)
     A,              XX(IDDIJ)
     N,              MOLABS,MOLABSB)
      NT = NTSAVE
C
C  COMPUTE MP2 ENERGY CORRECTION
C  (FOR ZAPT GRADIENTS, ENERGY WILL BE CALCULATED LATER)
C
      IF (OSPT.EQ.ZAPT) THEN
        IF (.NOT.ZAPTGD) THEN
          CALL ZAPTE(EORB,XX(ITMP1),XX(ITMP2),XX(ITRAN))
        END IF
      ELSE IF (UMP2GD) THEN
        CALL PEUMP2(EORB,EORBB,XX(ITMP1),XX(ITMP2))
      ELSE
        CALL PEMP2DC(EORB,XX(ITMP1),XX(ITMP2),XX(ITMP3),E2SUB,E2OC,E2VI)
        CALL DDI_GSUMF(999,E2SUB,1)
        CALL DDI_GSUMF(998,E2OC ,1)
        CALL DDI_GSUMF(997,E2VI ,1)
      END IF
      CALL RETFM(NEED)
      RETURN
      END
C*MODULE DCMP2   *DECK PARTRANDC
C        MODIFIED FROM PARTRAN
      SUBROUTINE PARTRANDC(SCHWA,CMO,CMOB,GOUT,TRAN,TRANB,TMP1,TMP1B,
     *                     TMP2,TMP2B,TMP3,DDIJ,MOLABS,MOLABSB)
C
C -----------------------------------------------------------------
C  PARALLEL TRANSFORMATION ROUTINE
C -----------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXSH=5000, MXGTOT=20000, MXAO=8192)
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
      DIMENSION GOUT(*),SCHWA(*),CMO(NBF,*),CMOB(NBF,*),
     *          TRAN(NBF,MXSHL*MXSHL,*),TMP1(*),TMP2(*),DDIJ(*),
     *          TRANB(NBF,MXSHL*MXSHL,*),TMP1B(*),TMP2B(*),
     *          MOLABS(*),MOLABSB(*)
C
      LOGICAL POPLE,PACK2E,IANDJ,KANDL,SAME,OUT,GOPARR,DSKWRK,
     *        MASWRK,OUTPUT,MP2ENG,UMP2GD,DLB,DOTASK
C
      INTEGER XDIM,XDIMB
C
      COMMON /FMCOM / XX(1)
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /MISC  / IANDJ,KANDL,SAME
      COMMON /GOUT  / GPOPLE(768),NORG
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /SHLG70/ ISHELL,JSHELL,KSHELL,LSHELL,INEW,JNEW,KNEW,LNEW
      COMMON /SHLNOS/ QQ4,LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,
     *                MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,
     *                NIJ,IJ,KL,IJKL
      COMMON /SHLT  / TOL,CUTOFF,ICOUNT,OUT
      COMMON /MP2XTR/ NBF,NACORE,NBSQ,NBTR,NSTR,MXSHL,NACT,NOCC
     *,               NVIR,NOV,NOSQ,NVSQ,NOTR,NVTR,NCP1,NOP1
     *,               NATR,ICHANL,OUTPUT,MP2ENG,IOST,NMOS,UMP2GD
      COMMON /UMP2XB/ NBCORE,NACTB,NOCCB,NVIRB,NOVB,NOSB,NVSB,NOTB,
     *                NVTB,NCP1B,NOP1B,NATB,IOSTB,NOCCBLD
C
      DOUBLE PRECISION TMP3(*)
C
      PARAMETER (MXLATM=200, MXLSHL=700)
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
C
C        FOR EFFICIENCY, WORK WITH TRANSPOSED ARRAYS, E OR GRAD RUNS.
C            UHF TO THE UPPER CLAUSE, RHF/ZAPT TO THE LOWER CLAUSE
C
      CALL VALFM(LOADFM)
      IF (UMP2GD) THEN
        LCMOT   = LOADFM  + 1
        LCMOBT  = LCMOT   + NBF*NBF
        LTRANT  = LCMOBT  + NBF*NBF
        LTRANBT = LTRANT  + NOCC *NBF*MXSHL*MXSHL
        LAST    = LTRANBT + NOCCB*NBF*MXSHL*MXSHL
        NEED    = LAST    - LOADFM
      ELSE
        LCMOT   = LOADFM  + 1
        LTRANT  = LCMOT   + NBF*NBF
        LAST    = LTRANT  + NOCC*NBF*MXSHL*MXSHL
        NEED    = LAST    - LOADFM
      END IF
      CALL GETFM(NEED)
C
                  CALL TRPOSE(CMO ,XX(LCMOT) ,NBF,NBF,0)
      IF (UMP2GD) CALL TRPOSE(CMOB,XX(LCMOBT),NBF,NBF,0)
C
      IF (OUTPUT) THEN
        WRITE(ICHANL,1)
        CALL FLSHBF(ICHANL)
      END IF
C
C  INITIALIZE PARAMETERS
C
      IF (MP2ENG) THEN
        XDIM =NACT
        XDIMB=NACTB
      ELSE
        XDIM =NOCC
        XDIMB=NOCCB
      END IF
      LTRAN  = XDIM *NBF*MXSHL*MXSHL
      LTRANB = XDIMB*NBF*MXSHL*MXSHL
      MXSHL4  = MXSHL**4
      IANDJ   = .FALSE.
      KANDL   = .FALSE.
      SAME    = .FALSE.
      Q4      = ONE
      QQ4     = Q4
      NORG    = 0
      NSCHWZ  = 0
      NOFFIJ  = 0
      LOCTSK  = 0
C
C  DYNAMIC LOAD BALANCING
C
      DLB = IBTYP.EQ.1
      IF (DLB) THEN
        CALL DDI_DLBRESET()
        CALL DDI_DLBNEXT( MYTASK )
      END IF
C
C  I-SHELL,J-SHELL
C
      DO II = 1, NLSH
       IIT=LOC2TS(II)
       DO JJ = 1, II
         JJT=LOC2TS(JJ)
         ISHL  = KMAX(IIT) - KMIN(IIT) + 1
         JSHL  = KMAX(JJT) - KMIN(JJT) + 1
         IJSHL = ISHL*JSHL
         IF (II.EQ.JJ) IJSHL = (ISHL*ISHL+ISHL)/2
C
C  SYMMETRY (IJ|
C
         CALL SYMIJ(IIT,JJT,Q2)
         IF ( Q2 .GT. ZERO ) THEN
C
C  LOAD BALANCER
C
         IF (DLB) THEN
           DOTASK = LOCTSK.EQ.MYTASK
         ELSE
           DOTASK = MOD(LOCTSK,NPROC).EQ.ME
         END IF
C
         IF (DOTASK) THEN
         IANDJ = II.EQ.JJ
                    CALL VCLR(XX(LTRANT), 1,LTRAN )
         IF(UMP2GD) CALL VCLR(XX(LTRANBT),1,LTRANB)
C
C  K-SHELL,L-SHELL
C
         DO KK = 1, NLSH
          KKT=LOC2TS(KK)
          DO LL = 1, KK
           LLT=LOC2TS(LL)
C
C  SYMMETRY (IJ|KL)
C
           CALL SYMIJKL(IIT,JJT,KKT,LLT,Q4)
           IF ( Q4 .GT. ZERO ) THEN
            QQ4 = Q4
C
C  SCHWARZ INEQUALITY TEST
C
            IIJJ = IA(MAX0(IIT,JJT)) + MIN0(JJT,IIT)
            KKLL = IA(MAX0(LLT,KKT)) + MIN0(LLT,KKT)
            TEST = Q4*SCHWA(IIJJ)*SCHWA(KKLL)
            IF (TEST.LT.CUTOFF) THEN
              NSCHWZ = NSCHWZ + 1
            ELSE
C
C  COMPUTE (IJ|KL) AND FIRST TRANSFORMATION
C
C     USE POPLE CODE FOR ANY PURE SP INTEGRAL BLOCKS,
C     USE HONDO RYS POLYNOMIAL CODE FOR OTHER BLOCKS
C
             POPLE=.TRUE.
             IF(INTTYP.GE.2)    POPLE=.FALSE.
             IF(KTYPE(IIT).GT.2) POPLE=.FALSE.
             IF(KTYPE(JJT).GT.2) POPLE=.FALSE.
             IF(KTYPE(KKT).GT.2) POPLE=.FALSE.
             IF(KTYPE(LLT).GT.2) POPLE=.FALSE.
C
             ISHELL = IIT
             JSHELL = JJT
             KSHELL = KKT
             LSHELL = LLT
C
             IF (POPLE) THEN
              CALL VCLR(GPOPLE,1,256)
              CALL GENR70(1,.FALSE.)
              CALL DCOPY(256,GPOPLE,1,GOUT,1)
              CALL TRAN1DC_P(GOUT,XX(LCMOT),XX(LTRANT),XX(LCMOBT),
     *                       XX(LTRANBT),XDIM,XDIMB)
             ELSE
              CALL VCLR(GOUT,1,MXSHL4)
              KANDL = KK.EQ.LL
              CALL PARSHEL(1,IIT,JJT,IIT,JJT)
              CALL IJPRIM(DDIJ)
              IF (NIJ.EQ.0) GO TO 170
              CALL PARSHEL(2,IIT,JJT,KKT,LLT)
              IF(IJKL.EQ.1) THEN
                CALL S0000(GOUT,DDIJ)
              ELSE
                CALL GENRAL(GOUT,DDIJ)
              END IF
              CALL TRAN1DC_H(GOUT,XX(LCMOT),XX(LTRANT),XX(LCMOBT),
     *                       XX(LTRANBT),XDIM,XDIMB)
             END IF   ! POPLE
             END IF   ! SCHWARZ
           END IF     ! SYM IJKL
C
C  END OF INNER LOOPS
C
          END DO      !  LL-SHELL
         END DO       !  KK-SHELL
         ISHELL = IIT
         JSHELL = JJT
         IF(UMP2GD) THEN
            CALL TRPOS13(XX(LTRANT) ,TRAN ,XDIM ,MXSHL*MXSHL,NBF)
            CALL TRPOS13(XX(LTRANBT),TRANB,XDIMB,MXSHL*MXSHL,NBF)
            CALL UTRAN2(CMO,CMOB,TRAN,TRANB,TMP1,IJSHL,NOFFIJ)
         ELSE
            CALL TRPOS13(XX(LTRANT) ,TRAN ,XDIM ,MXSHL*MXSHL,NBF)
            CALL TRAN2(CMO,TRAN,TMP1,IJSHL,NOFFIJ)
         END IF
         IF(UMP2GD) THEN
            CALL UTRAN3(CMO,CMOB,TRAN,TRANB,TMP1,TMP2,TMP1B,TMP2B,
     *                  ISHL,JSHL)
         ELSE
            CALL TRAN3DC(CMO,TRAN,TMP1,TMP2,ISHL,JSHL)
         END IF
 170     CONTINUE
         IF (DLB) CALL DDI_DLBNEXT( MYTASK )
         END IF       !  LOAD BALANCER
         LOCTSK = LOCTSK + 1
         END IF       !  SYM IJ
         NOFFIJ = NOFFIJ + IJSHL
C
C  END OF OUTER LOOPS
C
       END DO         ! JJ-SHELL
      END DO          ! II-SHELL
      CALL DDI_SYNC(9001)
C
C  (THIRD &) FOURTH TRANSFORMATIONS
C
      IF(UMP2GD) THEN
        CALL UTRAN34(CMO,CMOB,TMP1,TMP2,TMP1B,MOLABS,MOLABSB)
      ELSE
        CALL TRAN34DC(CMO,TMP1,TMP2,TMP3,MOLABS)
      END IF
      CALL DDI_GSUMI(1199,NSCHWZ,1)
      IF (DLB) CALL DDI_DLBRESET
      IF (OUTPUT) THEN
        WRITE(ICHANL,3) NSCHWZ
        CALL FLSHBF(ICHANL)
      END IF
      CALL RETFM(NEED)
      RETURN
1     FORMAT(/,6X,'DIRECT 4-INDEX TRANSFORMATION ')
3     FORMAT(6X,'SCHWARZ INEQUALITY TEST SKIPPED ',I10,
     * ' INTEGRAL BLOCKS')
      END
C*MODULE MP2DDI  *DECK TRAN1DC_H
C        MODIFIED FROM TRAN1_H
      SUBROUTINE TRAN1DC_H(GOUT,CMOT,TRAN,CMOBT,TRANB,XDIM,XDIMB)
C
C -----------------------------------------------------------------
C  FIRST TRANSFORMATION - HONDO INTEGRAL INDEXING
C -----------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER XDIM,XDIMB
      PARAMETER (MXSH=5000, MXGTOT=20000)
      LOGICAL IANDJ,KANDL,SAME,OUTPUT,MP2ENG,UMP2GD
      DOUBLE PRECISION GOUT(*),CMOT(NBF,*),TRAN(XDIM,MXSHL*MXSHL,NBF)
      DOUBLE PRECISION CMOBT(NBF,*),TRANB(XDIMB,MXSHL*MXSHL,NBF)
      COMMON /MISC  / IANDJ,KANDL,SAME
      COMMON /SHLG70/ ISHELL,JSHELL,KSHELL,LSHELL,INEW,JNEW,KNEW,LNEW
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /MP2XTR/ NBF,NACORE,NBSQ,NBTR,NSTR,MXSHL,NACT,NOCC
     *,               NVIR,NOV,NOSQ,NVSQ,NOTR,NVTR,NCP1,NOP1
     *,               NATR,ICHANL,OUTPUT,MP2ENG,IOST,NMOS,UMP2GD
      COMMON /UMP2XB/ NBCORE,NACTB,NOCCB,NVIRB,NOVB,NOSB,NVSB,NOTB,
     *                NVTB,NCP1B,NOP1B,NATB,IOSTB,NOCCBLD
C
      PARAMETER (MXAO=8192)
      COMMON /TO2LC / IT2LOC(MXAO)
C
      MINI = KMIN(ISHELL)
      MAXI = KMAX(ISHELL)
      MINJ = KMIN(JSHELL)
      MAXJ = KMAX(JSHELL)
      MINK = KMIN(KSHELL)
      MAXK = KMAX(KSHELL)
      LOCK = IT2LOC(KLOC(KSHELL)) - MINK
      MINL = KMIN(LSHELL)
      MAXL = KMAX(LSHELL)
      LOCL = IT2LOC(KLOC(LSHELL)) - MINL
      LEN1 = MXSHL**3
      LEN2 = MXSHL**2
      LEN3 = MXSHL
      IJN = 0
      LIMJ = MAXJ
      DO I = MINI, MAXI
        IF (IANDJ) LIMJ = I
        DO J = MINJ, LIMJ
          IJN = IJN + 1
          IJP = LEN1*(I-MINI) + LEN2*(J-MINJ) + 1
          LIML = MAXL
          DO K = MINK, MAXK
            I3 = LOCK + K
            IF (KANDL) LIML = K
            DO L = MINL, LIML
              I4 = LOCL + L
              KLP = LEN3*(K-MINK) + L-MINL
              VAL = GOUT( IJP + KLP )
              IF (I3.EQ.I4) VAL = VAL*0.5D+00
              ICNT = 0
              DO IOCC = IOST, NOCC
                 ICNT = ICNT + 1
                 TRAN(ICNT,IJN,I3) = TRAN(ICNT,IJN,I3)
     *                             + VAL*CMOT(IOCC,I4)
                 TRAN(ICNT,IJN,I4) = TRAN(ICNT,IJN,I4)
     *                             + VAL*CMOT(IOCC,I3)
              END DO
              IF(UMP2GD) THEN
                ICNT = 0
                DO IOCC = IOSTB, NOCCB
                 ICNT = ICNT + 1
                 TRANB(ICNT,IJN,I3) = TRANB(ICNT,IJN,I3)
     *                              + VAL*CMOBT(IOCC,I4)
                 TRANB(ICNT,IJN,I4) = TRANB(ICNT,IJN,I4)
     *                              + VAL*CMOBT(IOCC,I3)
                END DO
              END IF
            END DO
          END DO
        END DO
      END DO
      RETURN
      END
C*MODULE MP2DDI  *DECK TRAN1DC_P
C        MODIFIED FROM TRAN1_P
      SUBROUTINE TRAN1DC_P(GOUT,CMOT,TRAN,CMOBT,TRANB,XDIM,XDIMB)
C
C -----------------------------------------------------------------
C  FIRST TRANSFORMATION - POPLE VERSION
C -----------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER XDIM,XDIMB
      PARAMETER (MXSH=5000, MXGTOT=20000)
      LOGICAL IANDJ,KANDL,OUTPUT,MP2ENG,UMP2GD
      DOUBLE PRECISION GOUT(*),CMOT(NBF,*),TRAN(XDIM,MXSHL*MXSHL,NBF)
      DOUBLE PRECISION CMOBT(NBF,*),TRANB(XDIMB,MXSHL*MXSHL,NBF)
      COMMON /SHLG70/ ISHELL,JSHELL,KSHELL,LSHELL,INEW,JNEW,KNEW,LNEW
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /MP2XTR/ NBF,NACORE,NBSQ,NBTR,NSTR,MXSHL,NACT,NOCC
     *,               NVIR,NOV,NOSQ,NVSQ,NOTR,NVTR,NCP1,NOP1
     *,               NATR,ICHANL,OUTPUT,MP2ENG,IOST,NMOS,UMP2GD
      COMMON /UMP2XB/ NBCORE,NACTB,NOCCB,NVIRB,NOVB,NOSB,NVSB,NOTB,
     *                NVTB,NCP1B,NOP1B,NATB,IOSTB,NOCCBLD
      COMMON/FLIPS /IB1,JB1,KB1,LB1,IB2,JB2,KB2,LB2,IB3,JB3,KB3,LB3
      INTEGER IB(4,4)
      DATA IB/0,0,0,0,64,16,4,1,128,32,8,2,192,48,12,3/
C
      PARAMETER (MXAO=8192)
      COMMON /TO2LC / IT2LOC(MXAO)
C
      MINI = KMIN(ISHELL)
      MAXI = KMAX(ISHELL)
      MINJ = KMIN(JSHELL)
      MAXJ = KMAX(JSHELL)
      MINK = KMIN(KSHELL)
      MAXK = KMAX(KSHELL)
      LOCK = IT2LOC(KLOC(KSHELL)) - MINK
      MINL = KMIN(LSHELL)
      MAXL = KMAX(LSHELL)
      LOCL = IT2LOC(KLOC(LSHELL)) - MINL
      IANDJ = ISHELL.EQ.JSHELL
      KANDL = KSHELL.EQ.LSHELL
      IJN = 0
      JMAX = MAXJ
      DO I = MINI, MAXI
        IF (IANDJ) JMAX = I
        DO J = MINJ, JMAX
          IJN = IJN + 1
          N1 = IB(IB1,I) + IB(JB1,J)+1
          DO K = MINK, MAXK
            LIML = MAXL
            IF (KANDL) LIML = K
            I3 = LOCK + K
            DO L = MINL, LIML
              NN = N1 + IB(KB1,K) + IB(LB1,L)
              I4 = LOCL + L
              VAL = GOUT(NN)
              IF (I3.EQ.I4) VAL = VAL*0.5D+00
              ICNT = 0
              DO IOCC = IOST, NOCC
                 ICNT = ICNT + 1
                 TRAN(ICNT,IJN,I3) = TRAN(ICNT,IJN,I3)
     *                             + VAL*CMOT(IOCC,I4)
                 TRAN(ICNT,IJN,I4) = TRAN(ICNT,IJN,I4)
     *                             + VAL*CMOT(IOCC,I3)
              END DO
              IF(UMP2GD) THEN
                ICNT = 0
                DO IOCC = IOSTB, NOCCB
                 ICNT = ICNT + 1
                 TRANB(ICNT,IJN,I3) = TRANB(ICNT,IJN,I3)
     *                             + VAL*CMOBT(IOCC,I4)
                 TRANB(ICNT,IJN,I4) = TRANB(ICNT,IJN,I4)
     *                             + VAL*CMOBT(IOCC,I3)
                END DO
              END IF
            END DO
          END DO
        END DO
      END DO
      RETURN
      END
C*MODULE DCMP2   *DECK TRAN3DC
C        MODIFIED FROM TRAN3
      SUBROUTINE TRAN3DC(CMO,TRAN,TMP1,TMP2,ISHL,JSHL)
C
C -----------------------------------------------------------------
C  THIRD TRANSFORMATION FOR (VO|VO) INTEGRALS
C -----------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXSH=5000, MXGTOT=20000)
      LOGICAL OUTPUT,MP2ENG,IANJ,UMP2GD
C
      DOUBLE PRECISION CMO(NBF,*),TRAN(NBF,MXSHL*MXSHL,*)
     *,      TMP1(NVIR,ISHL,*),TMP2(NVIR,JSHL,*)
C
      COMMON /MP2XTR/ NBF,NACORE,NBSQ,NBTR,NSTR,MXSHL,NACT,NOCC
     *,               NVIR,NOV,NOSQ,NVSQ,NOTR,NVTR,NCP1,NOP1
     *,               NATR,ICHANL,OUTPUT,MP2ENG,IOST,NMOS,UMP2GD
      COMMON /SHLG70/ ISHELL,JSHELL,KSHELL,LSHELL,INEW,JNEW,KNEW,LNEW
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
C
      INTEGER         D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB
      LOGICAL         NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
      COMMON /TRFDMS/ D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB,
     *                NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
C
      PARAMETER (MXAO=8192)
      PARAMETER (MXLATM=200, MXLSHL=700)
      COMMON /TO2LC / IT2LOC(MXAO)
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
C
      INTEGER         D_VOVOI,D_VOVOA
      COMMON /TRFDDC/ D_VOVOI,D_VOVOA
C
      IF (.NOT.NDVOVO) RETURN
C
      IANJ = ISHELL.EQ.JSHELL
      MINI = KMIN(ISHELL)
      MAXI = KMAX(ISHELL)
      LOCI = IT2LOC(KLOC(ISHELL)) - MINI
      MINJ = KMIN(JSHELL)
      MAXJ = KMAX(JSHELL)
      LOCJ = IT2LOC(KLOC(JSHELL)) - MINJ
C          SOME NUMBER OF OCCUPIED ORBS EXIST
      IF(NDOOOO.OR.NDVOOO.OR.NDVVOO.OR.NDVVVO) THEN
         IF(NDCORE) THEN
            NOFF = NOCC
         ELSE
            NOFF = NACT
         END IF
      ELSE             ! ONLY VIRS IN FIRST INDEX OF TRAN
         NOFF = 0
      END IF
C
C  LOOP OVER NODE PARTITIONS TO SCALE THE ACC BUFFER SIZE
C
      CALL DDI_NPROC( NPROC, ME )
      DO IP = 0, NPROC-1
        CALL DDI_DISTRIB( D_VOVO, IP, ILO, IHI, JLO, JHI )
        CALL VCLR(TMP1,1,NVIR*(JHI-JLO+1)*ISHL)
        CALL VCLR(TMP2,1,NVIR*(JHI-JLO+1)*JSHL)
        IJP  = 0
        IJ   = 0
        ICNT = 0
        DO IOCC = IOST, NOCC
          ICNT = ICNT + 1
          DO JOCC = IOST, NOCC
            IJ = IJ + 1
            IF ( IJ.GE.JLO .AND. IJ.LE.JHI ) THEN
              IJP  = IJP + 1
              IJN  = 0
              JMAX = MAXJ
              II   = 0
              DO I = MINI, MAXI
                II = II + 1
                IF (IANJ) JMAX = I
                JJ = 0
                DO J = MINJ, JMAX
                  JJ  = JJ  + 1
                  IJN = IJN + 1
                  IF ( I+LOCI .NE. J+LOCJ ) THEN
                    DO IVIR = 1, NVIR
                     TMP1(IVIR,II,IJP) = TMP1(IVIR,II,IJP) +
     *               TRAN(NOFF+IVIR,IJN,ICNT)*CMO(J+LOCJ,JOCC)
                     TMP2(IVIR,JJ,IJP) = TMP2(IVIR,JJ,IJP) +
     *               TRAN(NOFF+IVIR,IJN,ICNT)*CMO(I+LOCI,JOCC)
                    END DO
                  ELSE
                    DO IVIR = 1, NVIR
                     TMP1(IVIR,II,IJP) = TMP1(IVIR,II,IJP) +
     *               TRAN(NOFF+IVIR,IJN,ICNT)*CMO(J+LOCJ,JOCC)
                    END DO
                  END IF
                END DO
              END DO
            END IF
          END DO
        END DO
C
C  ACCUMULATE [V*|VO) INTEGRALS
C
        ILO1 = ( LOCI + MINI - 1 )*NVIR + 1
        IHI1 = ILO1 + NVIR*ISHL -1
        CALL DDI_ACC(D_VOVO,ILO1,IHI1,JLO,JHI,TMP1)
        IF((LOCJ+MINJ).LE.LNUMC)
     *     CALL DDI_ACC(D_VOVOI,ILO1,IHI1,JLO,JHI,TMP1)
        ILO2 = ( LOCJ + MINJ - 1 )*NVIR + 1
        IHI2 = ILO2 + NVIR*JSHL -1
        CALL DDI_ACC(D_VOVO,ILO2,IHI2,JLO,JHI,TMP2)
        IF((LOCI+MINI).LE.LNUMC)
     *     CALL DDI_ACC(D_VOVOI,ILO2,IHI2,JLO,JHI,TMP2)
      END DO
C
      RETURN
      END
C*MODULE DCMP2   *DECK TRAN34DC
C        MODIFIED FROM TRAN34
      SUBROUTINE TRAN34DC(CMO,TMP1,TMP2,TMP3,MOLABS)
C
C -----------------------------------------------------------------
C  THIRD AND FOURTH TRANSFORMATIONS FOR (VV|OO), (VO|OO), (OO|OO)
C  FOURTH TRANSFORMATION FOR (VO|VO) INTEGRALS
C  AND SCREEN INTEGRALS VANISHING BY SYMMETRY
C -----------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXSH=5000, MXGTOT=20000, ZERO=0.0D+00, ONE=1.0D+00)
      LOGICAL GOPARR,DSKWRK,MASWRK,OUTPUT,MP2ENG,SYM2EI,NDCOUL
      LOGICAL UMP2GD
      DOUBLE PRECISION CMO(NBF,*),TMP1(*),TMP2(*),TMP3(*)
      INTEGER MOLABS(*)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /MP2XTR/ NBF,NACORE,NBSQ,NBTR,NSTR,MXSHL,NACT,NOCC
     *,               NVIR,NOV,NOSQ,NVSQ,NOTR,NVTR,NCP1,NOP1
     *,               NATR,ICHANL,OUTPUT,MP2ENG,IOST,NMOS,UMP2GD
C
      INTEGER         D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB
      LOGICAL         NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
      COMMON /TRFDMS/ D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB,
     *                NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
C
      PARAMETER (MXLATM=200, MXLSHL=700)
      LOGICAL DODCCR,ONLYOC,RMKORB,FZCORE,DOMP1,HFFRM
      COMMON /DCCORR/ RBUFCR,WOCC,ISTCOR,ITPART,DODCCR,ONLYOC,RMKORB,
     *                FZCORE,DOMP1,HFFRM
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
C
      INTEGER         D_VOVOI,D_VOVOA
      COMMON /TRFDDC/ D_VOVOI,D_VOVOA
C
C LOCAL VARIABLES
C
      INTEGER DDI_NP,DDI_ME
C
      IF(NDVVVO) THEN
C
      CALL DDI_NPROC(DDI_NP,DDI_ME)
      CALL DDI_DISTRIB(D_VVVO,DDI_ME,ILO,IHI,JLO,JHI)
C
      IJ = 0
      DO 1 IOCC = IOST,NOCC
      DO 1 JVIR = 1,NVIR
         IJ  = IJ + 1
         IF(IJ.LT.JLO .OR. IJ.GT.JHI) GOTO 1         ! SKIP WORK
         ISM = MOLABS(IOCC)
         JSM = MOLABS(JVIR+NOCC)
C
C LIKE THE FOLLOWING SECTION, TRAN2 DID NOT SCATTER [**|VO] INTEGRALS
C INTO THE VVVO ARRAY IN STRICT AO-ORDER, RATHER IT WAS SHELL-MAPPED
C
         CALL DDI_GET(D_VVVO,1,NBTR,IJ,IJ,TMP1)
C
         IJN = 0
         DO II = 1, NSHELL
         DO JJ = 1, II
C
C ... NOW THE CORRECT AO-LIST IS RECOVERED
C
            DO I = KLOC(II), KLOC(II) - KMIN(II) + KMAX(II)
               JMAX = KLOC(JJ) - KMIN(JJ) + KMAX(JJ)
               IF (II.EQ.JJ) JMAX = I
               DO J = KLOC(JJ), JMAX
                  IJN = IJN + 1
                  TMP2((I-1)*NBF+J) = TMP1(IJN)
                  TMP2((J-1)*NBF+I) = TMP1(IJN)
               END DO
            END DO
         END DO
         END DO
C
C  THIRD QUARTER-TRANSFORMATION TO VIRTUAL INDICES
C
         CALL DGEMM('N','N',NBF,NVIR,NBF
     *,             ONE,TMP2,NBF
     *,             CMO(1,NOP1),NBF
     *,             ZERO,TMP1,NBF)
C
C  FOURTH QUARTER-TRANSFORMATION TO VIR-VIR INDICES
C  (NOTE SPECIAL MULTIPLY ROUTINE THAT USES SYMMETRY)
C
         CALL ARBRCS('T','N',NVIR,NBF
     *,              ONE,CMO(1,NOP1),NBF
     *,              TMP1,NBF
     *,              ZERO,TMP2,NBF)
C
C  PUT VVVO INTEGRALS IN DISTRIBUTED MEMORY
C
         IJN = 0
         DO I = NOP1, NMOS
         DO J = NOP1, I
            KSM = MOLABS(I)
            LSM = MOLABS(J)
            IJN = IJN + 1
            TMP1(IJN) = TMP2( (I-1-NOCC)*NBF + J-NOCC )
            IF(.NOT.SYM2EI(ISM,JSM,KSM,LSM)) TMP1(IJN) = ZERO
         END DO
         END DO
         CALL DDI_PUT(D_VVVO,1,IJN,IJ,IJ,TMP1)
    1 CONTINUE
      END IF
C
      NDCOUL = NDOOOO.OR.NDVOOO.OR.NDVVOO
      IF (NDCOUL) THEN
         CALL DDI_DISTRIB(D_VVOO,ME,ILO,IHI,JLO,JHI)
      ELSE IF (NDVOVO) THEN
         CALL DDI_DISTRIB(D_VOVO,ME,ILO,IHI,JLO,JHI)
      ELSE
         WRITE(ICHANL,*) 'TRAN34: ERROR, NO INTEGRAL TYPE'
         CALL ABRT()
      END IF
      IF(NDCORE) THEN
         NOFF = NOCC
      ELSE
         NOFF = NACT
      END IF
C
      IJ = 0
      DO IOCC = IOST, NOCC
       ISM = MOLABS(IOCC)
       DO JOCC = IOST, NOCC
         JSM = MOLABS(JOCC)
         IJ = IJ + 1
         IF (IJ.GE.JLO .AND. IJ.LE.JHI) THEN
C
C  DO THE (OO|OO), (VO|OO), AND (VV|OO) CLASSES
C
          IF (NDCOUL) THEN
            CALL DDI_GET(D_VVOO,1,NBTR,IJ,IJ,TMP1)
C
C  NOTICE TRAN2 DID NOT SCATTER THE [**|OO) INTEGRALS
C  INTO THE VVOO ARRAY IN STRICT AO-ORDER...
C
            IJN = 0
            DO II = 1, NSHELL
              DO JJ = 1, II
C
C ... NOW THE CORRECT AO-LIST IS RECOVERED
C
                DO I = KLOC(II), KLOC(II) - KMIN(II) + KMAX(II)
                  JMAX = KLOC(JJ) - KMIN(JJ) + KMAX(JJ)
                  IF (II.EQ.JJ) JMAX = I
                  DO J = KLOC(JJ), JMAX
                    IJN = IJN + 1
                    TMP2((I-1)*NBF+J) = TMP1(IJN)
                    TMP2((J-1)*NBF+I) = TMP1(IJN)
                  END DO
                END DO
              END DO
            END DO
C
C  THIRD QUARTER-TRANSFORMATION TO OCCUPIED INDICES
C
            IF (NDOOOO.OR.NDVOOO) THEN
              CALL DGEMM('N','N',NBF,NOFF,NBF
     *,                  ONE,TMP2,NBF
     *,                  CMO(1,IOST),NBF
     *,                  ZERO,TMP1,NBF)
            END IF
C
C  THIRD QUARTER-TRANSFORMATION TO VIRTUAL INDICES
C
            IF (NDVVOO) THEN
              CALL DGEMM('N','N',NBF,NVIR,NBF
     *,                  ONE,TMP2,NBF
     *,                  CMO(1,NOP1),NBF
     *,                  ZERO,TMP1( (NOFF*NBF)+1 ),NBF)
            END IF
C
C  FOURTH QUARTER-TRANSFORMATION TO OCC-OCC INDICES
C  (NOTE SPECIAL MULTIPLY ROUTINE THAT USES SYMMETRY)
C
            IF (NDOOOO) THEN
              CALL ARBRCS('T','N',NOFF,NBF
     *,                   ONE,CMO(1,IOST),NBF
     *,                   TMP1,NBF
     *,                   ZERO,TMP2,NBF)
            END IF
C
C  FOURTH QUARTER-TRANSFORMATION TO VIR-OCC INDICES
C
            IF (NDVOOO) THEN
              CALL DGEMM('T','N',NVIR,NOFF,NBF
     *,                  ONE,CMO(1,NOP1),NBF
     *,                  TMP1,NBF
     *,                  ZERO,TMP2( NOFF+1 ),NBF)
            END IF
C
C  FOURTH QUARTER-TRANSFORMATION TO VIR-VIR INDICES
C  (NOTE SPECIAL MULTIPLY ROUTINE THAT USES SYMMETRY)
C
           IF (NDVVOO) THEN
             CALL ARBRCS('T','N',NVIR,NBF
     *,                  ONE,CMO(1,NOP1),NBF
     *,                  TMP1( (NOFF*NBF)+1 ),NBF
     *,                  ZERO,TMP2( (NOFF*NBF)+1 ),NBF)
           END IF
C
           IF (NDOOOO) THEN
C
C  PUT (OO|OO) INTEGRALS IN DISTRIBUTED MEMORY
C
             IJN = 0
             DO I = 1, NOFF
               KSM = MOLABS(IOST+I-1)
               DO J = 1, I
                 LSM = MOLABS(IOST+J-1)
                 IJN = IJN + 1
                 TMP1(IJN) = TMP2( (I-1)*NBF + J )
                 IF(.NOT.SYM2EI(ISM,JSM,KSM,LSM)) TMP1(IJN) = ZERO
               END DO
             END DO
             CALL DDI_PUT(D_OOOO,1,IJN,IJ,IJ,TMP1)
           END IF
C
           IF (NDVVOO) THEN
C
C  PUT VVOO INTEGRALS IN DISTRIBUTED MEMORY
C
             IJN = 0
             DO I = 1, NVIR
               KSM = MOLABS(NOCC+I)
               DO J = 1, I
                 LSM = MOLABS(NOCC+J)
                 IJN = IJN + 1
                 TMP1(IJN) = TMP2( (NOFF+I-1)*NBF + J )
                 IF(.NOT.SYM2EI(ISM,JSM,KSM,LSM)) TMP1(IJN) = ZERO
               END DO
             END DO
             CALL DDI_PUT(D_VVOO,1,IJN,IJ,IJ,TMP1)
           END IF
C
           IF (NDVOOO) THEN
C
C  PUT VOOO INTEGRALS IN DISTRIBUTED MEMORY
C
             IJN = 0
             DO J = 1, NOFF
               KSM = MOLABS(IOST+J-1)
               DO I = 1, NVIR
                 LSM = MOLABS(NOCC+I)
                 IJN = IJN + 1
                 TMP1(IJN) = TMP2( (J-1)*NBF + I + NOFF )
                 IF(.NOT.SYM2EI(ISM,JSM,KSM,LSM)) TMP1(IJN) = ZERO
               END DO
             END DO
             CALL DDI_PUT(D_VOOO,1,NVIR,(IJ-1)*NOFF+1,IJ*NOFF,TMP1)
           END IF
         END IF  ! NDCOUL
C
         IF (NDVOVO) THEN
C
C  TRANSFORM REMAINING AO INDEX OF VOVO CLASS
C
           CALL DDI_GET(D_VOVO,1,NBF*NVIR,IJ,IJ,TMP1)
           CALL DGEMM('N','N',NVIR,NVIR,NBF
     *,               ONE,TMP1,NVIR
     *,               CMO(1,NOP1),NBF
     *,               ZERO,TMP2,NVIR)
           IF(.NOT.ONLYOC) THEN
             CALL DGEMM('N','N',NVIR,NVIR,LNUMC
     *,                 ONE,TMP1,NVIR
     *,                 CMO(1,NOP1),NBF
     *,                 ZERO,TMP3,NVIR)
           END IF
           IJN = 0
           DO I = NOP1, NMOS
             KSM = MOLABS(I)
             DO J = NOP1, NMOS
               LSM = MOLABS(J)
               IJN = IJN + 1
               IF(.NOT.SYM2EI(ISM,JSM,KSM,LSM)) THEN
                 TMP2(IJN) = ZERO
                 TMP3(IJN) = ZERO
               END IF
             END DO
           END DO
           CALL DDI_PUT(D_VOVO,1,NVSQ,IJ,IJ,TMP2)
           IF(.NOT.ONLYOC) CALL DDI_PUT(D_VOVOA,1,NVSQ,IJ,IJ,TMP3)
C
           CALL DDI_GET(D_VOVOI,1,NBF*NVIR,IJ,IJ,TMP1)
           CALL DGEMM('N','N',NVIR,NVIR,NBF
     *,               ONE,TMP1,NVIR
     *,               CMO(1,NOP1),NBF
     *,               ZERO,TMP2,NVIR)
           IJN = 0
           DO I = NOP1, NMOS
             KSM = MOLABS(I)
             DO J = NOP1, NMOS
               LSM = MOLABS(J)
               IJN = IJN + 1
               IF(.NOT.SYM2EI(ISM,JSM,KSM,LSM)) THEN
                 TMP2(IJN) = ZERO
               END IF
             END DO
           END DO
           CALL DDI_PUT(D_VOVOI,1,NVSQ,IJ,IJ,TMP2)
          END IF
        END IF  ! IJ-LOCAL
       END DO  ! JOCC
      END DO  ! IOCC
      RETURN
      END
C*MODULE DCMP2   *DECK PEMP2DC
C        MODIFIED FROM PEMP2
      SUBROUTINE PEMP2DC(EORB,TMP1,TMP2,TMP3,E2SUB,E2OC,E2VI)
C
C -----------------------------------------------------------------
C  COMPUTE MP2 ENERGY
C -----------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXRT=100)
      LOGICAL GOPARR,DSKWRK,MASWRK,OUTPUT,MP2ENG,UMP2GD
      INTEGER A,B
      DOUBLE PRECISION EORB(*),TMP1(NVIR,*),TMP2(NVIR,*),TMP3(NVIR,*)
C
      COMMON /COMPE2/ E2PARA,E2OPOS
      COMMON /ENRGYS/ ENUC,EELEC,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /MP2XTR/ NBF,NACORE,NBSQ,NBTR,NSTR,MXSHL,NACT,NOCC
     *,               NVIR,NOV,NOSQ,NVSQ,NOTR,NVTR,NCP1,NOP1
     *,               NATR,ICHANL,OUTPUT,MP2ENG,IOST,NMOS,UMP2GD
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      INTEGER         D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB
      LOGICAL         NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
      COMMON /TRFDMS/ D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB,
     *                NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
C
      PARAMETER (ONE=1.0D+00, ZERO=0.0D+00)
C
      LOGICAL DODCCR,ONLYOC,RMKORB,FZCORE,DOMP1,HFFRM
      COMMON /DCCORR/ RBUFCR,WOCC,ISTCOR,ITPART,DODCCR,ONLYOC,RMKORB,
     *                FZCORE,DOMP1,HFFRM
C
      INTEGER         D_VOVOI,D_VOVOA
      COMMON /TRFDDC/ D_VOVOI,D_VOVOA
C
      CALL DDI_DISTRIB(D_VOVO,ME,IL_VOVO,IH_VOVO,JL_VOVO,JH_VOVO)
      E2    = ZERO
      EOPOS = ZERO
      EPARA = ZERO
      EOPOSA= ZERO
      EPARAA= ZERO
C
      IJN  = 0
      DO I = NCP1, NOCC
        DO J = NCP1, NOCC
          IF (MP2ENG) THEN
            IJN = IJN + 1
          ELSE
            IJN = (I*I-I)/2 + J
          END IF
          IF (IJN.GE.JL_VOVO .AND. IJN.LE.JH_VOVO) THEN
            CALL DDI_GET(D_VOVO , 1, NVSQ, IJN, IJN, TMP1)
            CALL DDI_GET(D_VOVOI, 1, NVSQ, IJN, IJN, TMP2)
            IF(.NOT.ONLYOC) CALL DDI_GET(D_VOVOA,1,NVSQ,IJN,IJN,TMP3)
            DO A = 1, NVIR
              DO B = 1, NVIR
                ED=EORB(I)+EORB(J)-EORB(NOCC+A)-EORB(NOCC+B)
                EPARA = EPARA - TMP2(A,B)*TMP1(B,A)/ED
                EOPOS = EOPOS + TMP2(A,B)*TMP1(A,B)/ED
                IF(.NOT.ONLYOC) THEN
                  EPARAA= EPARAA- TMP3(A,B)*TMP1(B,A)/ED
                  EOPOSA= EOPOSA+ TMP3(A,B)*TMP1(A,B)/ED
                END IF
              END DO
            END DO
          END IF
        END DO
      END DO
C
C  GLOBALLY-SUM THE MP2 ENERGY CONTRIBUTIONS
C
      EPARA   = EPARA + EOPOS
      E2OC    = EOPOS + EPARA
      E2SUB   = E2OC
      IF(ONLYOC) THEN
        E2OPOS = E2OPOS + EOPOS
        E2PARA = E2PARA + EPARA
        E2VI   = ZERO
      ELSE
        EPARAA= EPARAA+ EOPOSA
        E2VI  = EOPOSA+ EPARAA
        E2SUB = E2OC*WOCC + E2VI*(ONE-WOCC)
        E2OPOS= E2OPOS + EOPOS*WOCC + EOPOSA*(ONE-WOCC)
        E2PARA= E2PARA + EPARA*WOCC + EPARAA*(ONE-WOCC)
      END IF
      RETURN
      END
C*MODULE DCMPIM  *DECK MOCHNGDC
      SUBROUTINE MOCHNGDC(VECV,VECV2,NVIR,NLOOP,ILOOP)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXSH=5000, MXGTOT=20000)
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOL,METHOD,NWDMP2,MEMPRI,MPPROP,
     *                NACORE,NBCORE,NOA,NOB,NO,NBF,NOMIT,MOCPHF,MAXITC
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
C
      DIMENSION VECV(NBF,*),VECV2(NBF,*)
      DIMENSION NLOOP(2,NPROC),ILOOP(NLSH,NPROC)
C
C     EXCHANGE VIRTUAL MO COEFFICIENTS BEFORE 4TH TRANSFORMATION
C
      IF(GOPARR.AND.IBTYP.EQ.1) THEN
         N=0
         DO 110 I=1,NPROC
            DO 110 J=1,NLOOP(1,I)
               ISHS= ILOOP(J,I)
               ISH= LOC2TS(ISHS)
               MINI= KMIN(ISH)
               MAXI= KMAX(ISH)
               LCKLOCI= LCKLOC(ISHS)-MINI
               DO 110 K=MINI,MAXI
                  N=N+1
                  DO 110 L=1,NVIR
                     VECV2(N,L)=VECV(K+LCKLOCI,L)
  110    CONTINUE
      ELSE
         CALL DCOPY(NVIR*NBF,VECV,1,VECV2,1)
      ENDIF
      RETURN
      END
C
C
C*MODULE DCMPIM  *DECK MP2E2ACDC
      SUBROUTINE MP2E2ACDC(ENG,PTR4,PTR4I,EIJ,TOL,NOA,NVIR,NBF,E2S,E2T)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION ENG(NBF),PTR4(NVIR,*),PTR4I(NVIR,*)
C
      PARAMETER (ONE=1.0D+00)
C
      DO MOA= 1,NVIR
         EMO1= ENG(MOA+NOA)-EIJ
         DO MOB= 1,NVIR
            XAB= PTR4(MOB,MOA)
            XABI= PTR4I(MOB,MOA)
            IF(ABS(XAB).LT.TOL .OR. ABS(XABI).LT.TOL) GO TO 100
            XBA = PTR4(MOA,MOB)
            EMO2= ONE/(EMO1+ENG(MOB+NOA))
C            WRITE(6,'(2I3,4F15.8)') MOA,MOB,XABI,XAB,XBA,EMO2
            TEMP1= XABI*EMO2
            E2S = E2S-XAB*TEMP1
            E2T = E2T-(XAB-XBA)*TEMP1
C            WRITE(6,*) 'E2S=',E2S,'E2T=',E2T,'EMP2=',EMO2
 100        CONTINUE
         END DO
      END DO
C
      RETURN
      END
C*MODULE DCMPIM  *DECK MP2IMSDC
      SUBROUTINE MP2IMSDC(VEC,ENG,E2SUB,E2OSUB,E2VSUB)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXLATM=200, MXLSHL=700)
      LOGICAL GOPARR,DSKWRK,MASWRK
      COMMON /FMCOM / XX(1)
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DIMENSION VEC(*),ENG(*)
C
      CALL VALFM(LOADFM)
      LNUMP  = LOADFM + 1
      LNLOOP = LNUMP  + NPROC + 1
      LILOOP = LNLOOP + NPROC*2
      LIJEND = LILOOP + NLSH*NPROC
      LILEN  = LIJEND + NPROC
      LIRECV = LILEN  + NPROC
      LAST   = LIRECV + NPROC
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      NCPU = NPROC
      CALL MP2IMSXDC(VEC,ENG,XX(LNUMP),XX(LNLOOP),XX(LILOOP),XX(LIJEND),
     *               XX(LILEN),XX(LIRECV),NCPU,E2SUB,E2OSUB,E2VSUB)
C
      CALL RETFM(NEED)
      RETURN
      END
C*MODULE DCMPIM  *DECK MP2IMSXDC
      SUBROUTINE MP2IMSXDC(VEC,ENG,NUMP,NLOOP,ILOOP,IJEND,ILEN,IRECV,
     *     NCPU,E2SUB,E2OSUB,E2VSUB)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL ISGDDI,PAROUT,INITGDDI,ABEL,ABELPT,
     *        GOPARR,DSKWRK,MASWRK,DSKSAV,DLB,SLB,DIVANG
      LOGICAL DODCCR,ONLYOC,RMKORB,FZCORE,DOMP1,HFFRM
      PARAMETER (MXUNIT=299)
      CHARACTER*1   NULL
      CHARACTER*256 PATHNM,PATHNM2,ENVBUF
C      CHARACTER*256 PATHNM1
      COMMON /ENVIR / ENVBUF(-5:MXUNIT)
      COMMON /OPNNFT/ NFTOPN(MXUNIT),NODEXT(MXUNIT),IOSMP(2)
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000)
      PARAMETER (MXAO=8192)
      PARAMETER (MXLATM=200, MXLSHL=700)
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00, TEN=10.0D+00)
C
C        NOTE THAT -NCPU- IS AN ALIAS FOR -NPROC-
      DIMENSION VEC(*),ENG(*),NUMP(0:NCPU),NLOOP(2,NCPU),
     *          ILOOP(NLSH,NCPU),IJEND(NCPU),ILEN(NCPU),IRECV(NCPU)
C
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
      COMMON /COMPE2/ E2PARA,E2OPOS
      COMMON /DCCORR/ RBUFCR,WOCC,ISTCOR,ITPART,DODCCR,ONLYOC,RMKORB,
     *                FZCORE,DOMP1,HFFRM
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /DIRMEM/ LPQRJ,IVEC,IDEN,IFCK,NUM,NOCC,NDIM,MINPQ,MAXPQ
      COMMON /FMCOM / X(1)
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,NPGLOB,NNGLOB,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI
      COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOL,METHOD,NWDMP2,MEMPRI,MPPROP,
     *                NACORE,NBCORE,NOA,NOB,NO,NBF,NOMIT,MOCPHF,MAXITC
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SHLNOS/ QQ4,LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,
     *                MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,
     *                NIJ,IJ,KL,IJKL
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                TSYM(432),INVT(48),NT
C
      DATA CHECK/8HCHECK   /
C
C     ----- MAIN CLOSED-SHELL SEMI-DIRECT MP2 ENERGY DRIVER -----
C
      DSKSAV= DSKWRK
      DSKWRK= .TRUE.
      DLB = IBTYP.EQ.1
      SLB = .NOT.DLB
C
C        THE INTEGRAL TRANSFORMATION CAN EXPLOIT ABELIAN GROUPS
C
      ABEL=ABELPT()
      IF(.NOT.ABEL) CALL SYMOFF
C
      E2SO= ZERO
      E2TO= ZERO
      E2SV= ZERO
      E2TV= ZERO
      QQ4=ONE
C
C     SUBTRACT FMO PROJECTED OUT ORBITALS.
C
      IF(NFG.NE.0) NO = NO - NORBPROJ
C
      CALL SETFMPI(MEMPRI)
C
C    ----- VARIABLES FOR MP2 ENERGY -----
C
C NO       : NUMBER OF CANONICAL MOLECULAR ORBITALS
C NBF      : NUMBER OF BASIS FUNCTIONS
C NSHELL   : NUMBER OF SHELLS
C NOA      : NUMBER OF OCCUPIED ORBITALS
C NACORE   : NUMBER OF CORE ORBITALS
C NOC      : NUMBER OF CORRELATED ORBITALS
C NVIR     : NUMBER OF VIRTUAL ORBITALS
C NORB     : NUMBER OF ACTIVE ORBITALS
C NOC2     : NUMBER OF IJ PAIR
C NIJ3     : NUMBER OF IJ PAIR IN A BATCH AT 3RD TRANS.
C NIJ4     : NUMBER OF IJ PAIR IN A BATCH AT 4TH TRANS.
C
      NOC  = NOA - NACORE
      NVIR = NO  - NOA
C---  NOC2 =(NOC*NOC+NOC)/2
      NOC3 = NOC*NOC
      NBF2 = NBF*NBF
      NBF3 =(NBF*NBF+NBF)/2
      NSH2 =(NSHELL*NSHELL+NSHELL)/2
C
      NUM  = NBF
      IDEN = 0
      IFCK = 0
C
      CALL BASCHK(LMAX)
                    NANGM =  4
      IF(LMAX.EQ.2) NANGM =  6
      IF(LMAX.EQ.3) NANGM = 10
      IF(LMAX.EQ.4) NANGM = 15
      IF(LMAX.EQ.5) NANGM = 21
      IF(LMAX.EQ.6) NANGM = 28
      MAXG = NANGM**4
C
C    ----- SIZE OF DISK CACHE -----
C
      NCACHE= 1000000
      NIJ3 = NCACHE/NVIR
      IF(NIJ3.GT.NOC3) NIJ3= NOC3
C
C        RUN THROUGH THE PROGRAM AS A SIMULATED 'CHECK' RUN,
C        THEN COME BACK TO THIS POINT IF IT IS A REAL RUN.
C
      EXESAV = EXETYP
      EXETYP = CHECK
      ICHKPASS=0
   50 CONTINUE
      ICHKPASS=ICHKPASS+1
C
C    ----- MEMORY POINTERS FOR MP2 ENERGY -----
C
C IVEC    : MATRIX OF MO COEFFICIENTS        NBF*NBF
C IVECO   : TRANSPOSED MATRIX OF             NOC*NBF
C           OCCUPIED MO COEEFICIENTS
C IVECV   : TRANSPOSED MATRIX OF             NVIR*NBF
C           VIRTUAL MO COEEFICIENTS
C IENG    : ORBITAL ENERGIES                 NBF
C ILAB    : MOSLAB    |                      NBF
C IIRP    : MOSIRP    |---> SEE SYM          NBF
C IDEG    : MOSDEG    |                      NBF
C IGHND   : AO INTEGRALS FOR D,F,G           MAXG --> NANGM**4
C IXINT   : EXCHANGE INTEGRALS               (NSHELL**2 + NSHELL)/2
C
C IINT    : AO INTEGRALS                     (NANGM**3)*NBF
C IPTR1   : PARTIALLY TRANSFORMED INTEGRAL   (NANGM**3)*NOC
C IPTR2   : PARTIALLY TRANSFORMED INTEGRAL   NANGM*NOC2*NBF
C IPTR3   : PARTIALLY TRANSFORMED INTEGRAL   NANGM*NVIR*NIJ3
C
C IDDIS   : WORK SPACE FOR SEND
C                                  NIJ4*NVIR*MXP*NPROC(~=NIJ4*NVIR*NBF)
C JPTR3   : PARTIALLY TRANSFORMED INTEGRAL   NIJ4*NVIR*NBF
C IENGO   : I+J MO ENERGIES                  NOC2
C
      CALL VALFMP(LOADFM)
      IVEC  = 1     + LOADFM
      IVECO = IVEC  + NBF2
      IVECV = IVECO + NOC*NBF
      IVECV2= IVECV + NVIR*NBF
      IENG  = IVECV2+ NVIR*NBF
      ILAB  = IENG  + NBF
      IIRP  = ILAB  + NBF
      IDEG  = IIRP  + NBF
      INSYM = IDEG  + NBF
      IISYM = INSYM + NT
      LAST  = IISYM + NT*NVIR
      NEEDA = LAST  - LOADFM -1
      CALL GETFMP(NEEDA)
C
      CALL VALFMP(LOADFM)
      IGHND = 1     + LOADFM
      IXINT = IGHND + MAXG
      IINT  = IXINT + NSH2
      IPTR1 = IINT  +(NANGM**3)*NBF
      IPTR1I= IPTR1 +(NANGM**3)*NOC
      IPTR3 = IPTR1I+(NANGM**3)*NOC
      IWORK = IPTR3 + NVIR*NIJ3
      LAST  = IWORK + NBF*NIJ3
      NEEDB = LAST  - LOADFM -1
      CALL GETFMP(NEEDB)
C
C     ----- DISTRIBUTE P OF (PQ|RS) -----
C     ----- STATIC LOAD BALANCING -----
C
      MXP=NBF/NPROC
      IF(SLB .AND. GOPARR) THEN
         IPROC= 1
         IFUNC= NBF/NPROC
         NUMP(0)= 0
         DO I=1,NPROC
            NUMP(I)= NLSH
            NLOOP(2,I)= 0
         ENDDO
         DO I=1,NLSH
            IF(LCKLOC(I)-1.GE.IFUNC) THEN
               NUMP(IPROC)= I-1
               IPROC= IPROC+1
               IFUNC= NBF*IPROC/NPROC
            ENDIF
         ENDDO
         IF(NUMP(IPROC-1).NE.NLSH) THEN
            MXP=NBF-LCKLOC(NUMP(IPROC-1)+1)+1
            NLOOP(2,IPROC)=MXP
         ENDIF
         DO I=1,IPROC-1
            IF(NUMP(I).NE.NLSH) THEN
               IMXP= LCKLOC(NUMP(I)+1)-LCKLOC(NUMP(I-1)+1)
               NLOOP(2,I)=IMXP
               IF(IMXP.GT.MXP) MXP= IMXP
            ELSE
               NLOOP(2,I)=0
            ENDIF
         ENDDO
C
C            DYNAMIC LOAD BALANCING SETS REAL NLOOP VALUES IN -MP2SDI-
C            SERIAL DOESN'T SEEM TO NEED TO HAVE NLOOP SET TO ANYTHING
C
      ELSE
         DO IPROC=1,NPROC
            DO I=1,2
               NLOOP(I,IPROC) = 0
            ENDDO
         ENDDO
      ENDIF
C
C     ----- PRINT OUT NEEDED MEMORY AND DISK SPACE -----
C     THE MEMORY REQUIREMENTS JUST BELOW DON'T MATCH THE ACTUAL CODE.
C
C---      MXNEED= NEEDA+NEEDB+NANGM*NOC2*NBF
C---      MINEED= NEEDA+NEEDB+NOC2*NBF
C---      DMXNEED=(NOC2*NVIR)/125000.0D+00
C---      IF(GOPARR) THEN
C---C        MXDISK= REAL(NOC2)*REAL(NVIR)*REAL(MXP)/125000.0
C---         MXDISK= INT(DMXNEED*MXP)
C---      ELSE
C---C        MXDISK= REAL(NOC2)*REAL(NVIR)*REAL(NBF)/125000.0
C---         MXDISK= INT(DMXNEED*NBF)
C---      ENDIF
C---      IF(MASWRK) WRITE(IW,8) MXNEED,MINEED,MXDISK
C---    8 FORMAT(/1X,'MEMORY AND DISK REQUIREMENTS FOR SEMI-
C---     *        'DIRECT MP2 TRANSFORMATION'/
C---     *        '  MAXIMUM MEMORY=',I15,' WORDS'/
C---     *        '  MINIMUM MEMORY=',I15,' WORDS'/
C---     *        '  REQUIRED DISK =',I15,' MBYTES')
C
C        TOTAL DISK SPACE IS NOC * NOC * NVIR * NBF, AVOID OVERFLOWING
C
      DMXNEED = NOC3*NVIR
      DMXNEED = DMXNEED/125000.0D+00
      MXDISK  = INT(2*NBF*DMXNEED)
      MXDISKP = INT(2*NBF*DMXNEED/NPROC)
C
C     ----- READ MO COEFFICIENTS AND MO ENERGIES ------
C
C      CALL DAREAD(IDAF,IODA,X(IVEC),NBF2,15,0)
C      CALL DAREAD(IDAF,IODA,X(IENG),NBF ,17,0)
      CALL DCOPY(NBF2,VEC,1,X(IVEC),1)
      CALL DCOPY(NBF, ENG,1,X(IENG),1)
C
      MAXC = IDAMAX(NBF*NO,X(IVEC),1)
      VMAX = ABS(X(IVEC+MAXC-1))
C
      CUTOFFAO=TEN**(-ICUT)
      IF(VMAX.LT.ONE) VMAX=ONE
      CUTOFFMO=CUTOFFAO/(VMAX*VMAX)
C
      IF(MASWRK  .AND.  ICHKPASS.EQ.1) THEN
         WRITE(IW,9000) NOA,NOA-NACORE,NO-NOA,NBF,NSHELL,
     *                  CUTOFFAO,CUTOFFMO
         IF(NFG.NE.0.AND.NORBPROJ.NE.0) WRITE(IW,9010) NORBPROJ
         WRITE(IW,9020) MXDISK,MXDISKP,NPROC
         IF(VMAX.GT.1.0D+02) THEN
            MAXM = 1 + MAXC/NBF
            MAXA = MAXC - NBF*(MAXM-1)
            IF(MASWRK) WRITE(IW,9030) ABS(X(IVEC+MAXC-1)),MAXA,MAXM
         END IF
      END IF
      IF(ABS(X(IVEC+MAXC-1)).GT.1.0D+02) THEN
         MAXM = 1 + MAXC/NBF
         MAXA = MAXC - NBF*(MAXM-1)
         IF(MASWRK) WRITE(IW,9030) ABS(X(IVEC+MAXC-1)),MAXA,MAXM
      END IF
C
C     ----- READ SCHWARTZ INEQUALITY INFORMATION -----
C
      IF(EXETYP.EQ.CHECK) THEN
         CALL VCLR(X(IXINT),1,NSH2)
      ELSE
         IF(ISCHWZ.EQ.1) THEN
            CALL DAREAD(IDAF,IODA,X(IXINT),NSH2,54,0)
         ELSE
            CALL DCOPY(NSH2,1.0D+01,0,X(IXINT),1)
         END IF
      END IF
C
C     ----- ASSIGN -IRREP- LABEL TO MO'S -----
C
      CALL VALFMP(LOADFM)
      IWRK  = 1     + LOADFM
      IWRK2 = IWRK  + NBF3
      IWRK3 = IWRK2 + NBF2
      LAST  = IWRK3 + NBF
      NEEDC = LAST -LOADFM - 1
      CALL GETFMP(NEEDC)
      IF(ICHKPASS.EQ.1) GO TO 100
C
      CALL DAREAD(IDAF,IODA,X(IWRK),NBF3,12,0)
      CALL DAREAD(IDAF,IODA,X(IWRK2),NBF2,45,0)
      CALL TRFSYM(X(ILAB),X(IIRP),X(IDEG),X(IWRK2),X(IWRK),
     *            X(IVEC),X(IWRK3),IA,NO,NBF,NO,NBF)
C
  100 CONTINUE
      CALL RETFMP(NEEDC)
C
C     ----- TRANSPOSE MO COEFFICIENTS AND REORDER VIRTUAL MOS ------
C
      CALL MOTRN(X(IVEC),X(IVECO),X(IVECV),X(IIRP),X(INSYM),X(IISYM),
     *           NOC,NVIR)
C
C     ----- ALLOCATE MEMORY FOR 2ND TRANSFORMATION -----
C
      CALL GOTFMP(NGOTMX)
C      JPTR2  = NANGM*NOC2*NBF
      JPTR2  = NANGM*NOC3*NBF
      JPTR2I = NANGM*NOC3*NBF
      DIVANG=.FALSE.
      IF(NGOTMX.LT.(JPTR2+JPTR2I)) THEN
         DO 110 I=1, NANGM-1
            MXANGM= NANGM-I
C            JPTR2 = MXANGM*NOC2*NBF
            JPTR2 = MXANGM*NOC3*NBF
            JPTR2I= MXANGM*NOC3*NBF
            IF(NGOTMX.GE.(JPTR2+JPTR2I)) GOTO 120
  110    CONTINUE
         IF(MASWRK) WRITE(IW,9040) NEEDA+JPTR2+JPTR2I
         CALL ABRT
  120    DIVANG=.TRUE.
         IF(MASWRK) WRITE(IW,9050) MXANGM
      ENDIF
      CALL VALFMP(LOADFM)
      IPTR2   = 1       + LOADFM
      IPTR2I  = IPTR2   + JPTR2
      LLBLINT = IPTR2I  + JPTR2I
      LNUMINT = LLBLINT + NBF*NANGM**3
      LAST    = LNUMINT + NANGM**3
      NEEDD = LAST - LOADFM -1
C
      NEED123 = NEEDA + NEEDB + NEEDD
      IF(MASWRK) THEN
         IF(ICHKPASS.EQ.1) WRITE(IW,9060) NEED123
         IF(ICHKPASS.EQ.2) WRITE(IW,9065)
         CALL FLSHBF(6)
      END IF
C
      CALL GETFMP(NEEDD)
      IF(EXETYP.EQ.CHECK) GO TO 130
C
C     ----- OPEN DIRECT ACCESS FILE(S) ON EACH NODE -----
C
      IDAF20= 20
      IDAF21= 301
C      PATHNM1= 'DASORT1.DAT'
      PATHNM2= 'DASORT2.DAT'
      WRITE(UNIT=PATHNM2(12:15),FMT='(1H.,I3.3)') ME
      IF(MASWRK) CALL GMS_GETENV('DASORT',PATHNM)
      IF(ISGDDI) THEN
        PATHNM=ENVBUF(IDAF20)
        IF(NODEXT(IDAF20).EQ.0) 
     *    CALL ADDNANODE(PATHNM,MEGLOB,IDAF20)
      ELSE
         CALL PARENV('DASORT',PATHNM,IOUT)
      ENDIF
      NULL = CHAR(0)
      DO 3 KOL=1,256
         IF(PATHNM(KOL:KOL).EQ.' '  .OR.
     *      PATHNM(KOL:KOL).EQ.NULL) GO TO 4
    3 CONTINUE
      KOL=257
    4 CONTINUE
      IF(KOL.EQ.1) THEN
         WRITE(IW,1) 'DASORT'
         CALL ABRT
    1 FORMAT(1X,'YOU MUST ASSIGN GENERIC NAME ',A,' WITH A SETENV.')
      END IF
      KOL=KOL-1
      OPEN(UNIT=IDAF20,FILE=PATHNM(1:KOL),STATUS='UNKNOWN',
     *     ACCESS='DIRECT', FORM='UNFORMATTED', RECL=8*NVIR)
      DO 5 KOL=1,256
         IF(PATHNM2(KOL:KOL).EQ.' '  .OR.
     *      PATHNM2(KOL:KOL).EQ.NULL) GO TO 6
 5        CONTINUE
      KOL=257
 6     CONTINUE
      IF(KOL.EQ.1) THEN
         WRITE(IW,1) 'DASORT2'
         CALL ABRT
      END IF
      KOL=KOL-1
      OPEN(UNIT=IDAF21,FILE=PATHNM2(1:KOL),STATUS='UNKNOWN',
     *     ACCESS='DIRECT', FORM='UNFORMATTED', RECL=8*NVIR)
C
C     ----- CARRY OUT 1ST, 2ND, AND 3RD INDEX TRANSFORMATIONS -----
C
      CALL MP2SD1DC(X(IVECO),X(IVECV),X(IGHND),
     *              X(IXINT),X(IINT),X(IPTR1),X(IPTR1I),X(IPTR2),
     *              X(IPTR2I),X(IPTR3),X(IWORK),
     *              X(LLBLINT),X(LNUMINT),
     *              NUMP,NOC,NVIR,NOC3,NANGM,CUTOFFAO,CUTOFFMO,
     *              NLOOP,ILOOP,DIVANG,MXANGM,NIJ3,IDAF20,IDAF21)
C
  130 CONTINUE
      CALL RETFMP(NEEDD)
      CALL RETFMP(NEEDB)
C
C     ----- ALLOCATE MEMORY FOR 4TH TRANSFORMATION -----
C
      CALL GOTFMP(NGOTMX)
      NGOTMX = NGOTMX - 2*NVIR*NVIR - NOC3 - NVIR*NBF
      IF(GOPARR) THEN
         IF(ICHKPASS.EQ.1) THEN
            MXP=NBF/NPROC
         ELSE
         IF(DLB) THEN
            MXP=0
            DO I= 1,NPROC
               MXP= MAX(MXP,NLOOP(2,I))
            ENDDO
         ENDIF
         END IF
         MIJ4= NOC3/NPROC
         IF(MOD(NOC3,NPROC).NE.0) MIJ4= MIJ4+1
         NIJ4 = NGOTMX/(NVIR*(2*NBF+MXP*NPROC))
         IF(NIJ4.GT.MIJ4) NIJ4= MIJ4
         IF(NIJ4.EQ.0) THEN
           IF(MASWRK) WRITE(IW,*) 'PARALLEL MP2IMS: NOT ENOUGH MEMORY'
           CALL ABRT
         ENDIF
         JDDIS= NIJ4*NVIR*MXP*NPROC
         NPASS= NOC3/(NIJ4*NPROC)
         IF(MOD(NOC3,(NIJ4*NPROC)).NE.0) NPASS= NPASS+1
      ELSE
         NIJ4 = NGOTMX/(2*NVIR*NBF)
         IF(NIJ4.GT.NOC3) NIJ4= NOC3
         IF(NIJ4.EQ.0) THEN
           WRITE(IW,*) 'SERIAL MP2IMS: NOT ENOUGH MEMORY'
           CALL ABRT
         ENDIF
         JDDIS= 1
         NPASS= NOC3/NIJ4
         IF(MOD(NOC3,NIJ4).NE.0) NPASS= NPASS+1
      ENDIF
C
      CALL VALFMP(LOADFM)
      IDDIS = 1     + LOADFM
      JPTR3 = IDDIS + JDDIS
      JPTR3I= JPTR3 + NIJ4*NVIR*NBF
      IMO1  = JPTR3I+ NIJ4*NVIR*NBF
      IMO2  = IMO1  + NVIR*NVIR
      IENGO = IMO2  + NVIR*NVIR
      IWORK = IENGO + NOC3
      LAST  = IWORK + NVIR*NBF
      NEEDE = LAST  - LOADFM -1
C
      NEED4 = NEEDA + NEEDE
      IF(MASWRK  .AND.  ICHKPASS.EQ.1) WRITE(IW,9070) NEED4
C
      CALL GETFMP(NEEDE)
      IF(EXETYP.EQ.CHECK) GO TO 230
C
C     ----- START 4TH QUARTER TRANSFORMATION -----
C     -----       AND MP2 ENERGY CALCULATION -----
C
C
      CALL MOCHNGDC(X(IVECV),X(IVECV2),NVIR,NLOOP,ILOOP)
      CALL MP2SD2DC(X(IENG),X(IENGO),X(IVECV2),X(IWORK),X(IDDIS),
     *              X(JPTR3),X(JPTR3I),X(IMO1),X(IMO2),X(IIRP),X(INSYM),
     *              X(IISYM),
     *              NVIR,NOC,NOC3,NT,
     *              IJEND,ILEN,IRECV,NLOOP,NCPU,
     *              MXP,NPASS,NIJ4,E2SO,E2TO,IDAF20,IDAF21)
C
C     ----- DELETE THE DIRECT ACCESS FILE(S) ON EACH CORE -----
C
      CLOSE(UNIT=IDAF20, STATUS='DELETE')
      CLOSE(UNIT=IDAF21, STATUS='DELETE')
C
  230 CONTINUE
      CALL RETFMP(NEEDE)
      CALL RETFMP(NEEDA)
C
C     ----- PRINT ENERGY DATA -----
C
      IF(ICHKPASS.EQ.2  .OR.  EXESAV.EQ.CHECK) THEN
         WVIR=ONE-WOCC
         E2OPOS=E2OPOS+E2SO*WOCC+E2SV*WVIR
         E2PARA=E2PARA+E2TO*WOCC+E2TV*WVIR
         IF(GOPARR) THEN
            CALL DDI_GSUMF(1000,E2SO,1)
            CALL DDI_GSUMF(1000,E2TO,1)
            CALL DDI_GSUMF(1000,E2SV,1)
            CALL DDI_GSUMF(1000,E2TV,1)
         END IF
         E2OSUB=E2SO+E2TO
         E2VSUB=E2SV+E2TV
         E2SUB=E2OSUB*WOCC+E2VSUB*WVIR
      END IF
C
C        REAL RUNS NOW BRANCH BACK TO DO THE ACTUAL CALCULATION
C
      EXETYP=EXESAV
      IF(ICHKPASS.EQ.1  .AND.  EXESAV.NE.CHECK) GO TO 50
C
C     SUBTRACTING CORE ORBITALS
C
      DO J=1,NO-NACORE
         ENG(J)=ENG(J+NACORE)
         DO I=1,NBF
            VEC(I+NBF*(J-1))=VEC(I+NBF*(J-1+NACORE))
         END DO
      END DO
C
      DSKWRK= DSKSAV
      IF(.NOT.ABEL) CALL SYMON
      RETURN
C
 9000 FORMAT(/1X,29('-'),3X,43(1H-)/
     *        1X,'RHF-DC MP2 ENERGY CALCULATION',3X,
     *           'PROGRAM WRITTEN BY M.KATOUDA AND K.ISHIMURA'/
     *        1X,29('-'),3X,43(1H-)/
     *        1X,'NUMBER OF OCCUPIED ORBITALS            =',I5,/
     *        1X,'NUMBER OF CORRELATED OCCUPIED ORBITALS =',I5,/
     *        1X,'NUMBER OF VIRTUAL ORBITALS             =',I5,/
     *        1X,'NUMBER OF BASIS FUNCTIONS              =',I5,/
     *        1X,'NUMBER OF BASIS SHELLS                 =',I5,/
     *        1X,'AO-TRANSFORMED INTEGRAL THRESHOLD      =',1P,E9.2/
     *        1X,'HALF-TRANSFORMED INTEGRAL THRESHOLD    =',1P,E9.2)
 9010 FORMAT(/1X,'NUMBER OF REDUNDANT MOS IN FMO         =',I5)
 9020 FORMAT(1X,'TOTAL DISK REQUIRED (ALL PROCESSORS)=',I15,' MBYTES'/
     *       1X,'                 DISK SPACE PER CORE=',I15,
     *          ' MBYTES, USING P=',I5)
 9030 FORMAT(/1X,'*** WARNING: THE MAXIMUM LCAO COEF=',F15.6,
     *           ', FOR AO',I6,' IN MO=',I6,','/
     *        1X,'EXCEEDS 100.  ADDITIONAL INPUTS MAY BE REQUIRED TO',
     *           ' OBTAIN GOOD MP2 ACCURACY:'/
     *        1X,' $CONTRL ICUT=10 OR 11'/
     *        1X,' $SCF    CONV=2.5D-7 FDIFF=.FALSE.'/)
 9040 FORMAT(1X,'**** ERROR: TOO LITTLE MEMORY TO RUN RHF-MP2 *****',/,
     *       1X,'INCREASE MEMORY TO AT LEAST',I15,'WORDS.')
 9050 FORMAT(1X,'MULTIPLE PASSES',
     *      /1X,'MAXIMUM ANGULAR MOMENTUM=',I3)
 9060 FORMAT(1X,'MEMORY REQUIRED FOR TRANSFORMATION OF 1ST THREE',
     *          ' INDICES=',I12)
 9065 FORMAT(1X,'BEGINNING MP2 INTEGRAL TRANSFORMATION...')
 9070 FORMAT(1X,'MEMORY REQUIRED FOR    4TH INDEX TRANSF. AND MP2',
     *          ' ENERGY=',I12)
      END
C
C*MODULE DCMP2IM  *DECK MP2QT1DC
      SUBROUTINE MP2QT1DC(VECO,AOINTS,PTR1,PTR1I,NOC,NUMI,NUMK,NUML,
     *                    NANGM,LBLINT,NUMINT,KSH,LSH)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXLATM=200, MXLSHL=700)
      PARAMETER (ZER=0.0D+00)
C
      LOGICAL KANDL
C
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOL,METHOD,NWDMP2,MEMPRI,MPPROP,
     *                NACORE,NBCORE,NOA,NOB,NO,NBF,NOMIT,MOCPHF,MAXITC
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
C
      DIMENSION VECO(NOC,*),AOINTS(NBF,*),
     *          PTR1(NOC,NANGM,NANGM,NANGM),PTR1I(NOC,NANGM,NANGM,NANGM)
      DIMENSION LBLINT(NBF,*),NUMINT(*)
C
C     1ST QUARTER TRANSFORMATION
C
      KANDL= KSH.EQ.LSH
      LNUML = NUML
C
      IKL= 0
      DO 160 I= 1,NUMI
         DO 150 K= 1,NUMK
            IF(KANDL) LNUML= K
            DO 140 L= 1,LNUML
               IKL= IKL+1
               DO 110 MOI= 1,NOC
                  PTR1(MOI,L,K,I)= ZER
                  PTR1I(MOI,L,K,I)= ZER
  110          CONTINUE
               DO 130 J= 1,NUMINT(IKL)
                  JLABEL= LBLINT(J,IKL)
                  DUM   = AOINTS(J,IKL)
                  IF(JLABEL .LE. LNUMC) THEN
                     DO 120 MOI= 1,NOC
                        PTR1I(MOI,L,K,I)= PTR1I(MOI,L,K,I)
     *                                   +DUM*VECO(MOI,JLABEL)
 120                 CONTINUE
                  ELSE
                     DO 125 MOI= 1,NOC
                        PTR1(MOI,L,K,I)= PTR1(MOI,L,K,I)
     *                                  +DUM*VECO(MOI,JLABEL)
  125                CONTINUE
                  END IF
  130          CONTINUE
               DO 135 MOI= 1,NOC
                  PTR1(MOI,L,K,I) = PTR1(MOI,L,K,I)+PTR1I(MOI,L,K,I)
  135          CONTINUE
  140       CONTINUE
  150    CONTINUE
  160 CONTINUE
C
      RETURN
      END
C*MODULE MPIMDC  *DECK MP2QT2BDC
      SUBROUTINE MP2QT2BDC(VECO,PTR1,PTR2,
     *                     NOC,NOC3,NUMI,NUMK,NUML,NANGM,CUTOFFMO,
     *                     KSH,LSH,MINK,MINL,LOCK,LOCL)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL KNOTL
C
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOL,METHOD,NWDMP2,MEMPRI,MPPROP,
     *                NACORE,NBCORE,NOA,NOB,NO,NBF,NOMIT,MOCPHF,MAXITC
C
      DIMENSION VECO(NOC,*),PTR1(NOC,NANGM,NANGM,NANGM),PTR2(NOC3,NBF,*)
C
C     2ND QUARTER TRANSFORMATION
C
      KNOTL= KSH.NE.LSH
      LOCK2= LOCK+MINK-1
      LOCL2= LOCL+MINL-1
C
C
      IF(KNOTL)THEN
      DO 160 I= 1,NUMI
         DO 140 L= 1,NUML
            LL= LOCL2+L
            DO 150 K= 1,NUMK
               KK= LOCK2+K
               MOIJ= 0
               DO 130 MOI= 1,NOC
                  DUM1= PTR1(MOI,L,K,I)
                  IF(ABS(DUM1).LT.CUTOFFMO) GO TO 120
                  DO 110 MOJ= 1,NOC
                     PTR2(MOIJ+MOJ,LL,I)= PTR2(MOIJ+MOJ,LL,I)
     *                                   +DUM1*VECO(MOJ,KK)
  110             CONTINUE
  120             MOIJ= MOIJ+NOC
  130          CONTINUE
  150       CONTINUE
  140    CONTINUE
  160 CONTINUE
C
      DO 260 I=1,NUMI
         DO 250 K=1,NUMK
            KK= LOCK2+K
            DO 240 L=1,NUML
               LL= LOCL2+L
               MOIJ= 0
               DO 230 MOI=1,NOC
                  DUM1= PTR1(MOI,L,K,I)
                  IF(ABS(DUM1).LT.CUTOFFMO) GO TO 220
                  DO 210 MOJ= 1,NOC
                     PTR2(MOIJ+MOJ,KK,I)= PTR2(MOIJ+MOJ,KK,I)
     *                                   +DUM1*VECO(MOJ,LL)
  210             CONTINUE
  220             MOIJ= MOIJ+NOC
  230          CONTINUE
  240       CONTINUE
  250    CONTINUE
  260 CONTINUE
C
      ELSE
      DO 380 I=1,NUMI
         DO 370 K= 1,NUMK
            LMAX= K
            KK= LOCK2+K
            DO 360 L= 1,LMAX
               LL= LOCL2+L
               MOIJ= 0
               DO 350 MOI= 1,NOC
                  DUM1= PTR1(MOI,L,K,I)
                  DUM3= ABS(DUM1)
                  IF(DUM3.LT.CUTOFFMO) GO TO 320
                  DO 310 MOJ= 1,NOC
                     PTR2(MOIJ+MOJ,LL,I)= PTR2(MOIJ+MOJ,LL,I)
     *                                   +DUM1*VECO(MOJ,KK)
  310             CONTINUE
  320             IF(DUM3.LT.CUTOFFMO) GO TO 340
                  DO 330 MOJ= 1,NOC
                     PTR2(MOIJ+MOJ,KK,I)= PTR2(MOIJ+MOJ,KK,I)
     *                                   +DUM1*VECO(MOJ,LL)
  330             CONTINUE
  340             MOIJ= MOIJ+NOC
  350          CONTINUE
  360       CONTINUE
  370    CONTINUE
  380 CONTINUE
      ENDIF
C
      RETURN
      END
C
C*MODULE MPIMDC  *DECK MP2QT3DC
      SUBROUTINE MP2QT3DC(VECV,PTR2,PTR3,WORK,
     *                    NVIR,NOC2,IREC,NUMI,NIJ3,IDAF20)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER(ZER=0.0D+00, ONE=1.0D+00)
C
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOL,METHOD,NWDMP2,MEMPRI,MPPROP,
     *                NACORE,NBCORE,NOA,NOB,NO,NBF,NOMIT,MOCPHF,MAXITC
C
      DIMENSION VECV(NBF,*),PTR2(NOC2,NBF,*),PTR3(NVIR,NIJ3),
     *          WORK(NBF,*)
C
C     3RD QUARTER TRANSFORMATION
C
      IPASS= NOC2/NIJ3
      MODIJ= MOD(NOC2,NIJ3)
      IF(MODIJ.NE.0) THEN
         IPASS= IPASS+1
      ELSE
         MODIJ= NIJ3
      ENDIF
C
      DO 150 I= 1,NUMI
         MIJ3= NIJ3
         DO 140 IJPASS= 1,IPASS
            IF(IJPASS.EQ.IPASS) MIJ3= MODIJ
            MOIJ2= (IJPASS-1)*NIJ3
            DO 120 K= 1,NBF
               DO 110 MOIJ= 1,MIJ3
                  WORK(K,MOIJ)= PTR2(MOIJ+MOIJ2,K,I)
  110          CONTINUE
  120       CONTINUE
            CALL DGEMM('T','N',NVIR,MIJ3,NBF,ONE,VECV,NBF,
     *                 WORK,NBF,ZER,PTR3,NVIR)
            DO 130 IJWRIT= 1,MIJ3
               IREC= IREC+1
               WRITE(UNIT=IDAF20,REC=IREC)
     *              (PTR3(MOB,IJWRIT),MOB=1,NVIR)
  130       CONTINUE
  140    CONTINUE
  150 CONTINUE
C
      RETURN
      END
C
C
C*MODULE DCMPIM  *DECK MP2QT4DC
      SUBROUTINE MP2QT4DC(PTR3,PTR4,VECV,WORK,NVIR,NBF,NIJ4,MOIJ,INUM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (ZER=0.0D+00, ONE=1.0D+00)
C
      DIMENSION PTR3(NVIR,NIJ4,*),PTR4(NVIR,*),VECV(NBF,*),WORK(INUM,*)
C
      DO MOB= 1,NVIR
         DO I= 1,INUM
            WORK(I,MOB)=PTR3(MOB,MOIJ,I)
C            WRITE(6,'(3I3,F15.8)') I,MOIJ,MOB,WORK(I,MOB)
         END DO
      END DO
      CALL DGEMM('T','N',NVIR,NVIR,INUM,ONE,WORK,INUM,
     *     VECV,NBF,ZER,PTR4,NVIR)
C
      RETURN
      END
C*MODULE MPIMDC  *DECK MP2SD1DC
      SUBROUTINE MP2SD1DC(VECO,VECV,GHONDO,
     *                    XINTS,AOINTS,PTR1,PTR1I,PTR2,PTR2I,PTR3,
     *                    WORK,
     *                    LBLINT,NUMINT,
     *                    NUMP,NOC,NVIR,NOC3,NANGM,
     *                    CUTOFFAO,CUTOFFMO,
     *                    NLOOP,ILOOP,DIVANG,MXANGM,NIJ3,IDAF20,IDAF21)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,SCHSKP
      LOGICAL DIVANG,PASSCH,NXT
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXAO=8192)
      PARAMETER (ZER=0.0D+00)
C
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOL,METHOD,NWDMP2,MEMPRI,MPPROP,
     *                NACORE,NBCORE,NOA,NOB,NO,NBF,NOMIT,MOCPHF,MAXITC
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
      COMMON /SHLEXC/ NORGSH(3),NORGSP(3),IEXCH,MANGM,NGTH(4)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /GOUT  / GPOPLE(768),NORG
      COMMON /SHLG70/ ISH,JSH,KSH,LSH,IJKLXX(4)
      COMMON /SHLNOS/ QQ4,IDUMMY(20)
C
      DIMENSION VECO(NOC,*),VECV(*),
     *          GHONDO(*),XINTS(*),AOINTS(*),PTR1(*),PTR1I(*),PTR2(*),
     *          PTR2I(*),PTR3(*),WORK(*),NUMP(0:NPROC)
      DIMENSION NLOOP(2,0:NPROC-1),ILOOP(NLSH,0:NPROC-1)
      DIMENSION LBLINT(NBF*(NANGM**3)),NUMINT(NANGM**3)
C
C     1ST, 2ND, 3RD QUARTER TRANSFORMATIONS
C
      NXT = IBTYP.EQ.1
      NEXT = -1
      MINE = -1
C
      NORG  = 0
      IEXCH = 1
      ISTART= 1
      IEND  = NLSH
      IREC1 = 0
      IREC2 = 0
C
      TAO=ZER
      TQT1=ZER
      TQT2=ZER
      TQT3=ZER
C
C      DO I=1,NBF
C         DUM=ZER
C         DO J=1,NOC
C            DUM=MAX(DUM,ABS(VECO(J,I)))
C         ENDDO
C         BSMAX(I)=DUM
C      ENDDO
C      JSTART=1
C      DO I=1,NSHELL
C         DUM=ZER
C         DO J= JSTART, KLOC(I)
C            DUM=MAX(DUM,BSMAX(J))
C         ENDDO
C         JSTART= KLOC(I)+1
C      ENDDO
C
C     ----- STATIC PARALLEL -----
C
      IF((.NOT.NXT) .AND. GOPARR) THEN
         ISTART= NUMP(ME)+1
         IEND  = NUMP(ME+1)
      ENDIF
C
C     ----- DYNAMIC PARALLEL -----
C
      IF(NXT .AND. GOPARR) THEN
         NLOOP(1,ME)= 0
         NLOOP(2,ME)= 0
      ENDIF
C
C
C     ----- START I SHELL -----
C
      DO 500 ISHS= ISTART,IEND
         ISH= LOC2TS(ISHS)
C
         IF(MASWRK) THEN
            IF(MOD(ISH,25).EQ.1) THEN
               IF(MOD(ISH,50).EQ. 1) WRITE(IW,9999) ISH,'ST'
               IF(MOD(ISH,50).EQ.26) WRITE(IW,9999) ISH,'TH'
            END IF
            CALL FLSHBF(IW)
         END IF
C
C     ----- GO PARALLEL! -----
C
         IF(NXT.AND.GOPARR) THEN
            MINE = MINE + 1
            IF (MINE.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
            IF (NEXT.NE.MINE) GO TO 500
            NLOOP(1,ME)= NLOOP(1,ME)+1
            ILOOP(NLOOP(1,ME),ME)=ISHS
         END IF
C
         MINI= KMIN(ISH)
         MAXI= KMAX(ISH)
         MINI2= MINI
         MAXI2= MAXI
         ITMP= MAXI2-MINI2+1
         IDIV= 0
  110    IF(DIVANG.AND.ITMP.GT.MXANGM) THEN
            MINI2= MXANGM*IDIV+KMIN(ISH)
            MAXI2= MXANGM+MINI2-1
            IF(MAXI2.GT.KMAX(ISH)) MAXI2=KMAX(ISH)
            IDIV= IDIV+1
         ENDIF
         NUMI= MAXI2-MINI2+1
         IF(NXT.AND.GOPARR) NLOOP(2,ME)=NLOOP(2,ME)+NUMI
C         CALL VCLR(PTR2, 1,NOC2*NBF*NUMI)
         CALL VCLR(PTR2, 1,NOC3*NBF*NUMI)
         CALL VCLR(PTR2I,1,NOC3*NBF*NUMI)
C
C     ----- START K SHELL -----
C
      DO 400 KSHS=1,NLSH
         KSH= LOC2TS(KSHS)
C         CALL SYMIK(ISH,KSH,Q2,NSHELL)
C         IF(Q2.EQ.ZER) GO TO 400
         MINK= KMIN(KSH)
         MAXK= KMAX(KSH)
         NUMK= MAXK-MINK+1
         LCKLOCK= LCKLOC(KSHS)-MINK
C
C     ----- START L SHELL -----
C
      DO 300 LSHS=1,KSHS
         LSH= LOC2TS(LSHS)
         MINL= KMIN(LSH)
         MAXL= KMAX(LSH)
         NUML= MAXL-MINL+1
         LCKLOCL= LCKLOC(LSHS)-MINL
         KLKL= IA(KSH)+LSH
         IF(LSH.GT.KSH) KLKL= IA(LSH)+KSH
         PASSCH=.FALSE.
         DO II=1,NUMI*NUMK*NUML
            NUMINT(II)=0
         ENDDO
C
C     ----- START J SHELL -----
C
      DO 200 JSHS=1,NLSH
         JSH= LOC2TS(JSHS)
         IJIJ= IA(ISH)+JSH
         IF(JSH.GT.ISH) IJIJ= IA(JSH)+ISH
C         CALL SYMIKLJ(ISH,KSH,LSH,JSH,Q4,NSHELL)
C         IF(Q4.EQ.ZER) GO TO 200
C         QQ4=Q4
         TEST= QQ4*XINTS(IJIJ)*XINTS(KLKL)
         SCHSKP= TEST.LT.CUTOFFAO
         MINJ= KMIN(JSH)
         MAXJ= KMAX(JSH)
         LOCJ= KLOC(JSH)-MINJ
C
         IF(.NOT.SCHSKP) THEN
            PASSCH= .TRUE.
            CALL TSECND(TAO0)
            CALL SHELLQUARTMP2(GHONDO)
C
C     ----- SAVE AO INTEGRALS -----
C
            CALL SAVEAODC(AOINTS,GHONDO,CUTOFFAO,
     *                    LBLINT,NUMINT,KSH,LSH,LOCJ,MINI,
     *                    MINI2,MAXI2,MINJ,MAXJ,MINK,MAXK,MINL,MAXL)
            CALL TSECND(TAO1)
            TAO=TAO+(TAO1-TAO0)
C
         ENDIF
  200 CONTINUE
C
C     ----- END J SHELL -----
C
      IF(.NOT.PASSCH) GO TO 300
C
C     ----- 1ST QUARTER TRANSFORMATION -----
C
      CALL TSECND(TQT1S)
      CALL MP2QT1DC(VECO,AOINTS,PTR1,PTR1I,NOC,NUMI,NUMK,NUML,
     *              NANGM,LBLINT,NUMINT,KSH,LSH)
      CALL TSECND(TQT1E)
      TQT1=TQT1+(TQT1E-TQT1S)
C
C     ----- 2ND QUARTER TRANSFORMATION -----
C
      CALL TSECND(TQT2S)
      CALL MP2QT2BDC(VECO,PTR1,PTR2,
     *               NOC,NOC3,NUMI,NUMK,NUML,NANGM,CUTOFFMO,
     *               KSH,LSH,MINK,MINL,LCKLOCK,LCKLOCL)
      CALL MP2QT2BDC(VECO,PTR1I,PTR2I,
     *               NOC,NOC3,NUMI,NUMK,NUML,NANGM,CUTOFFMO,
     *               KSH,LSH,MINK,MINL,LCKLOCK,LCKLOCL)
      CALL TSECND(TQT2E)
      TQT2=TQT2+(TQT2E-TQT2S)
C
  300 CONTINUE
C
C     ----- END L SHELL -----
C
  400 CONTINUE
C
C     ----- END K SHELL -----
C
C
C     ----- 3RD QUARTER TRANSFORMATION -----
C
      CALL TSECND(TQT3S)
      CALL MP2QT3DC(VECV,PTR2,PTR3,WORK,
     *              NVIR,NOC3,IREC1,NUMI,NIJ3,IDAF20)
      CALL MP2QT3DC(VECV,PTR2I,PTR3,WORK,
     *              NVIR,NOC3,IREC2,NUMI,NIJ3,IDAF21)
      CALL TSECND(TQT3E)
      TQT3=TQT3+(TQT3E-TQT3S)
C
      IF(DIVANG.AND.MAXI2.NE.KMAX(ISH)) GO TO 110
C
  500 CONTINUE
C
C     ----- END I SHELL -----
C
C
C     ----- CHECK DYNAMIC PARALLEL INFORMATIONS -----
      IF(NXT.AND.GOPARR) THEN
         CALL DDI_DLBRESET
         INTSIZ=8/NWDVAR
C        INTSIZ=4
CI32     INTSIZ=4
CI64     INTSIZ=8
         DO 600 I=1,NPROC-1
C           IF(MASWRK .AND. I.NE.MASTER) THEN
            IF(MASWRK) THEN
               CALL DDI_RECV(NLOOP(1,I),2*INTSIZ,I)
               CALL DDI_RECV(ILOOP(1,I),NLSH*INTSIZ,I)
            ELSE
               IF(I.EQ.ME)CALL DDI_SEND(NLOOP(1,I),2*INTSIZ,MASTER)
               IF(I.EQ.ME)CALL DDI_SEND(ILOOP(1,I),NLSH*INTSIZ,MASTER)
            ENDIF
  600    CONTINUE
         CALL DDI_BCAST(1012,'I',NLOOP,2*NPROC,MASTER)
         CALL DDI_BCAST(1011,'I',ILOOP,NLSH*NPROC,MASTER)
      ENDIF
C
CTIME WRITE(IW,999)TAO,TQT1,TQT2,TQT3
C 999 FORMAT(/1X,'TIME TO GENERATE AO INTEGRALS=     ',F9.1,
C    *       /1X,'TIME OF 1ST QUARTER TRANSFORMATION=',F9.1,
C    *       /1X,'TIME OF 2ND QUARTER TRANSFORMATION=',F9.1,
C    *       /1X,'TIME OF 3RD QUARTER TRANSFORMATION=',F9.1)
 9999 FORMAT(1X,'BEGINNING',I5,A2,' SHELL LOOP...')
      RETURN
      END
C
C
C*MODULE MPIMDC  *DECK MP2SD2DC
      SUBROUTINE MP2SD2DC(ENG,ENGO,VECV,WORK,DDIS,
     *                    PTR3,PTR3I,PTR4,PTR4I,MOSIRP,NSYM,ISYM,
     *                    NVIR,NOC,NOC2,NT,
     *                    IJEND,ILEN,IRECV,NLOOP,NCPU,
     *                    MXP,NPASS,NIJ4,E2SO,E2TO,IDAF20,IDAF21)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,SYM2EI
C
      PARAMETER (MXAO=8192)
      PARAMETER (ZER=0.0D+00, ONE=1.0D+00)
C
C        NOTE THAT -NCPU- IS AN ALIAS FOR -NPROC-
      DIMENSION IJEND(NCPU),ILEN(NCPU),IRECV(NCPU),NLOOP(2,0:NCPU-1)
C
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOL,METHOD,NWDMP2,MEMPRI,MPPROP,
     *                NACORE,NBCORE,NOA,NOB,NO,NBF,NOMIT,MOCPHF,MAXITC
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DIMENSION ENG(NBF),ENGO(NOC2),VECV(NBF,*),
     *          DDIS(NVIR,NIJ4,MXP,*),PTR3(NVIR,NIJ4,*),PTR4(NVIR,*),
     *          PTR3I(NVIR,NIJ4,*),PTR4I(NVIR,*),
     *          WORK(NBF,*),MOSIRP(*),NSYM(*),ISYM(NVIR,*)
C
C     4TH QUARTER TRANSFORMATION AND MP2 ENERGY CALCULATION
C
C     ----- CALCULATE I+J MO ENERGIES -----
C
      DO 120 I= 1,NOC
         ENGI= ENG(I+NACORE)
         II  = (I-1)*NOC
         DO 110 J= 1,NOC
            ENGO(II+J)= ENGI+ENG(J+NACORE)
  110    CONTINUE
  120 CONTINUE
C
C     ----- 4TH QUARTER TRANSFORMATION -----
C     ----- AND MP2 ENERGY CALCULATION -----
C
C     ----- PARALLEL VERSION -----
C
      IF(GOPARR) THEN
         NUMI=NLOOP(2,ME)
         LENDDI= NVIR*NIJ4*NUMI
         MIJ4  = NIJ4
         MODIJ1= MOD(NOC2,NIJ4*NPROC)
         MODIJ2= MOD(MODIJ1,NPROC)
         MIJTMP= MODIJ1/NPROC
         IF(MIJTMP.EQ.0.AND.MODIJ2.EQ.0) MIJTMP= NIJ4
C
         NSUM=1
         DO 210 IPROC= 1,NPROC
            IJEND(IPROC)= MIJTMP
            IF(IPROC.LE.MODIJ2) IJEND(IPROC)= IJEND(IPROC)+1
            ILEN(IPROC)=NLOOP(2,IPROC-1)*NVIR*NIJ4
            IRECV(IPROC)=NSUM
            NSUM= NSUM+NLOOP(2,IPROC-1)
  210    CONTINUE
C
C     WRITE(6,*) ME,'MP2 CODE REACHED THE DATA EXCHANGE.'
      DO 500 IPASS= 1,NPASS
         IJREC1=(IPASS-1)*NIJ4*NPROC
         MIJ4= NIJ4
         DO I= 1,NUMI
            IJREC2= (I-1)*NOC2+IJREC1
            DO IPROC=1,NPROC
               IF(IPASS.EQ.NPASS) MIJ4= IJEND(IPROC)
               DO MOIJ= 1,MIJ4
                  READ(UNIT=IDAF20,REC=IJREC2+MOIJ)
     *                 (DDIS(MOB,MOIJ,I,IPROC),MOB=1,NVIR)
               END DO
               IJREC2= IJREC2+MIJ4
            END DO
         END DO
C
C     ----- CALL NON-BLOCKING SEND AND RECIEVE ---
C
         JPROC= ME+1
         DO IPROC= ME+2,NPROC
            JPROC= JPROC-1
            IF(JPROC.EQ.0) JPROC= NPROC
            CALL DDI_ISEND(DDIS(1,1,1,IPROC),LENDDI*8,IPROC-1,
     *                        IREQ1)
            CALL DDI_IRECV(PTR3(1,1,IRECV(JPROC)),ILEN(JPROC)*8,
     *                     JPROC-1,IREQ2)
            CALL DDI_WAIT(IREQ2)
            CALL DDI_WAIT(IREQ1)
         END DO
         DO IPROC= 1,ME
            JPROC= JPROC-1
            IF(JPROC.EQ.0) JPROC= NPROC
            CALL DDI_ISEND(DDIS(1,1,1,IPROC),LENDDI*8,IPROC-1,
     *                        IREQ1)
            CALL DDI_IRECV(PTR3(1,1,IRECV(JPROC)),ILEN(JPROC)*8,
     *                     JPROC-1,IREQ2)
            CALL DDI_WAIT(IREQ2)
            CALL DDI_WAIT(IREQ1)
         END DO
         CALL DCOPY(LENDDI,DDIS(1,1,1,ME+1),1,PTR3(1,1,IRECV(ME+1)),1)
C
         IJREC1=(IPASS-1)*NIJ4*NPROC
         MIJ4= NIJ4
         DO I= 1,NUMI
            IJREC2= (I-1)*NOC2+IJREC1
            DO IPROC=1,NPROC
               IF(IPASS.EQ.NPASS) MIJ4= IJEND(IPROC)
               DO MOIJ= 1,MIJ4
                  READ(UNIT=IDAF21,REC=IJREC2+MOIJ)
     *                 (DDIS(MOB,MOIJ,I,IPROC),MOB=1,NVIR)
               END DO
               IJREC2= IJREC2+MIJ4
            END DO
         END DO
C
C     ----- CALL NON-BLOCKING SEND AND RECIEVE ---
C
         JPROC= ME+1
         DO IPROC= ME+2,NPROC
            JPROC= JPROC-1
            IF(JPROC.EQ.0) JPROC= NPROC
            CALL DDI_ISEND(DDIS(1,1,1,IPROC),LENDDI*8,IPROC-1,
     *                        IREQ1)
            CALL DDI_IRECV(PTR3I(1,1,IRECV(JPROC)),ILEN(JPROC)*8,
     *                     JPROC-1,IREQ2)
            CALL DDI_WAIT(IREQ2)
            CALL DDI_WAIT(IREQ1)
         END DO
         DO IPROC= 1,ME
            JPROC= JPROC-1
            IF(JPROC.EQ.0) JPROC= NPROC
            CALL DDI_ISEND(DDIS(1,1,1,IPROC),LENDDI*8,IPROC-1,
     *                        IREQ1)
            CALL DDI_IRECV(PTR3I(1,1,IRECV(JPROC)),ILEN(JPROC)*8,
     *                     JPROC-1,IREQ2)
            CALL DDI_WAIT(IREQ2)
            CALL DDI_WAIT(IREQ1)
         END DO
         CALL DCOPY(LENDDI,DDIS(1,1,1,ME+1),1,PTR3I(1,1,IRECV(ME+1)),1)
C
         MIJ4= NIJ4
         MIJ5= ME*NIJ4
         IF(IPASS.EQ.NPASS) THEN
            MIJ4= IJEND(ME+1)
            MIJ5= 0
            DO 360 IPROC= 1,ME
               MIJ5= MIJ5+ IJEND(IPROC)
  360       CONTINUE
         ENDIF
         IJREC2=MIJ5+(IPASS-1)*NIJ4*NPROC
C
         IF(NT.NE.1) THEN
            DO 370 II= 1,NOC-1
               MOI= II
               IF(IJREC2.LT.IA(II+1)) GO TO 380
  370       CONTINUE
            MOI= NOC
  380       MOJ= IJREC2-IA(MOI)+1
         ENDIF
C
         DO 490 MOIJ=1,MIJ4
C            DO 400 I= 1,NBF
C               DO 390 MOB= 1,NVIR
C                  WORK(I,MOB)= PTR3(MOB,MOIJ,I)
C  390          CONTINUE
C  400       CONTINUE
            EIJ= ENGO(IJREC2+MOIJ)
C
            IF(NT.EQ.1) THEN
               CALL MP2QT4DC(PTR3,PTR4,VECV,WORK,NVIR,NBF,NIJ4,MOIJ,NBF)
               CALL MP2QT4DC(PTR3I,PTR4I,VECV,WORK,NVIR,NBF,NIJ4,MOIJ,
     *              NBF)
               CALL MP2E2ACDC(ENG,PTR4,PTR4I,EIJ,TOL,NOA,NVIR,NBF,
     *              E2SO,E2TO)
C               IF(.NOT. ONLYOC) THEN
C                  CALL MP2QT4DC(PTR3I,PTR4I,VECV,WORK,NVIR,NBF,NIJ4,
C     *                 MOIJ,LNUMC)
C                  CALL MP2E2ACDC(ENG,PTR4,PTR4I,EIJ,TOL,NOA,NVIR,NBF,
C     *                 E2SV,E2TV)
C               END IF
C
            ELSE
               NIT= 1
               DO 440 IT= 1,NT
                  IF(NSYM(IT).EQ.0) GO TO 440
                  NJT= 1
                  DO 430 JT= 1,NT
                     IF(NSYM(JT).EQ.0) GO TO 430
                     MOSA= ISYM(1,IT)+NOA
                     MOSB= ISYM(1,JT)+NOA
                     IF(SYM2EI(MOSIRP(MOI+NACORE),MOSIRP(MOSA),
     *                         MOSIRP(MOJ+NACORE),MOSIRP(MOSB)))
     *                  CALL DGEMM('T','N',NSYM(JT),NSYM(IT),NBF,ONE,
     *                             WORK(1,NJT),NBF,VECV(1,NIT),NBF,ZER,
     *                             PTR4(1,NIT),NVIR)
  430             NJT= NJT+NSYM(JT)
  440          NIT= NIT+NSYM(IT)
               NIT= 0
               DO 480 IT= 1,NT
                  IF(NSYM(IT).EQ.0) GO TO 480
                  NJT= 0
                  DO 470 JT= 1,NT
                     IF(NSYM(JT).EQ.0) GO TO 470
                     MOSA= ISYM(1,IT)+NOA
                     MOSB= ISYM(1,JT)+NOA
                     IF(SYM2EI(MOSIRP(MOI+NACORE),MOSIRP(MOSA),
     *                         MOSIRP(MOJ+NACORE),MOSIRP(MOSB))) THEN
                        DO 460 MOA= 1,NSYM(IT)
                           EMO1= ENG(ISYM(MOA,IT)+NOA)-EIJ
                           DO 450 MOB= 1,NSYM(JT)
                              XAB= PTR4(MOB,MOA+NIT)
                              IF(ABS(XAB).LT.TOL) GO TO 450
                              XBA= PTR4(MOA,MOB+NJT)
                              EMO2= ONE/(EMO1+ENG(ISYM(MOB,JT)+NOA))
                              E2SO= E2SO-XAB*XAB*EMO2
                              E2TO= E2TO-XAB*(XAB-XBA)*EMO2
  450                      CONTINUE
  460                   CONTINUE
                     ENDIF
  470             NJT= NJT+NSYM(JT)
  480          NIT= NIT+NSYM(IT)
               MOJ= MOJ+1
               IF(MOI.LT.MOJ) THEN
                  MOI= MOI+1
                  MOJ= 1
               ENDIF
            ENDIF
  490    CONTINUE
  500 CONTINUE
C
C     ----- SERIAL VERSION -----
C
      ELSE
      MIJ4 = NIJ4
      DO 660 IPASS= 1,NPASS
         IJPASS=(IPASS-1)*NIJ4
         IF(IPASS.EQ.NPASS.AND.(MOD(NOC2,NIJ4).NE.0))
     *      MIJ4= MOD(NOC2,NIJ4)
         DO I= 1,NBF
            IJREC= (I-1)*NOC2+(IPASS-1)*NIJ4
            DO MOIJ= 1,MIJ4
               READ(UNIT=IDAF20,REC=IJREC+MOIJ)
     *             (PTR3(MOB,MOIJ,I),MOB=1,NVIR)
            END DO
         END DO
         DO I=1,NBF
            IJREC= (I-1)*NOC2+(IPASS-1)*NIJ4
            DO MOIJ= 1,MIJ4
               READ(UNIT=IDAF21,REC=IJREC+MOIJ)
     *             (PTR3I(MOB,MOIJ,I),MOB=1,NVIR)
            END DO
         END DO
C
         IF(NT.NE.1) THEN
            DO 530 II= 1,NOC-1
               MOI=II
               IF(IJPASS.LT.IA(II+1)) GO TO 540
  530       CONTINUE
            MOI= NOC
  540       MOJ= IJPASS-IA(MOI)+1
         ENDIF
C
         DO 650 MOIJ= 1,MIJ4
C            DO 560 I= 1,NBF
C               DO 550 MOB= 1,NVIR
C                  WORK(I,MOB)= PTR3(MOB,MOIJ,I)
C  550          CONTINUE
C  560       CONTINUE
            EIJ= ENGO(MOIJ+IJPASS)
C
            IF(NT.EQ.1) THEN
               CALL MP2QT4DC(PTR3,PTR4,VECV,WORK,NVIR,NBF,NIJ4,MOIJ,NBF)
               CALL MP2QT4DC(PTR3I,PTR4I,VECV,WORK,NVIR,NBF,NIJ4,MOIJ,
     *              NBF)
               CALL MP2E2ACDC(ENG,PTR4,PTR4I,EIJ,TOL,NOA,NVIR,NBF,
     *              E2SO,E2TO)
C               IF(.NOT. ONLYOC) THEN
C                  CALL MP2QT4DC(PTR3,PTR4I,VECV,WORK,NVIR,NBF,NIJ4,
C     *                 MOIJ,LNUMC)
C                  CALL MP2E2ACDC(ENG,PTR4,PTR4I,EIJ,TOL,NOA,NVIR,NBF,
C     *                 E2SV,E2TV)
C               END IF
C
            ELSE
               NIT=1
               DO 600 IT=1,NT
                  IF(NSYM(IT).EQ.0) GO TO 600
                  NJT=1
                  DO 590 JT=1,NT
                     IF(NSYM(JT).EQ.0) GO TO 590
                     MOSA= ISYM(1,IT)+NOA
                     MOSB= ISYM(1,JT)+NOA
                     IF(SYM2EI(MOSIRP(MOI+NACORE),MOSIRP(MOSA),
     *                         MOSIRP(MOJ+NACORE),MOSIRP(MOSB)))
     *                  CALL DGEMM('T','N',NSYM(JT),NSYM(IT),NBF,ONE,
     *                             WORK(1,NJT),NBF,VECV(1,NIT),NBF,ZER,
     *                             PTR4(1,NIT),NVIR)
  590             NJT= NJT+NSYM(JT)
  600          NIT= NIT+NSYM(IT)
               NIT= 0
               DO 640 IT= 1,NT
                  IF(NSYM(IT).EQ.0) GO TO 640
                  NJT= 0
                  DO 630 JT= 1,NT
                     IF(NSYM(JT).EQ.0) GO TO 630
                     MOSA= ISYM(1,IT)+NOA
                     MOSB= ISYM(1,JT)+NOA
                     IF(SYM2EI(MOSIRP(MOI+NACORE),MOSIRP(MOSA),
     *                         MOSIRP(MOJ+NACORE),MOSIRP(MOSB))) THEN
                        DO 620 MOA= 1,NSYM(IT)
                           EMO1= ENG(ISYM(MOA,IT)+NOA)-EIJ
                           DO 610 MOB= 1,NSYM(JT)
C                             XAB= PTR4(MOB,MOA)
                              XAB= PTR4(MOB,MOA+NIT)
                              IF(ABS(XAB).LT.TOL) GO TO 610
C                             XBA= PTR4(MOA,MOB)
                              XBA= PTR4(MOA,MOB+NJT)
                              EMO2= ONE/(EMO1+ENG(ISYM(MOB,JT)+NOA))
                              E2SO= E2SO-XAB*XAB*EMO2
                              E2TO= E2TO-XAB*(XAB-XBA)*EMO2
  610                      CONTINUE
  620                   CONTINUE
                     ENDIF
  630             NJT= NJT+NSYM(JT)
  640          NIT= NIT+NSYM(IT)
               MOJ= MOJ+1
               IF(MOI.LT.MOJ) THEN
                  MOI= MOI+1
                  MOJ= 1
               ENDIF
            ENDIF
  650    CONTINUE
  660 CONTINUE
      ENDIF
C
      RETURN
      END
C
C*MODULE DCMPIM  *DECK SAVEAODC
      SUBROUTINE SAVEAODC(AOINTS,GHONDO,CUTOFFAO,
     *                    LBLINT,NUMINT,KSH,LSH,LOCJ,MINI,
     *                    MINI2,MAXI2,MINJ,MAXJ,MINK,MAXK,MINL,MAXL)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL KANDL
C
      PARAMETER (MXAO=8192)
      PARAMETER (HALF=0.5D+00)
C
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOL,METHOD,NWDMP2,MEMPRI,MPPROP,
     *                NACORE,NBCORE,NOA,NOB,NO,NBF,NOMIT,MOCPHF,MAXITC
      COMMON /ERIOUT/ INU,JNU,KNU,LNU,LSTRI,LSTRJ,LSTRK,LSTRL
      COMMON /TO2LC / IT2LOC(MXAO)
C
      DIMENSION AOINTS(NBF,*),GHONDO(*)
      DIMENSION LBLINT(NBF,*),NUMINT(*)
C
C     SAVE AO INTEGRALS
C
      KANDL= KSH.EQ.LSH
      IKL  = 0
      LMAX = MAXL
C
C      WRITE(6,*) 'Q0'
      DO 240 I= MINI2,MAXI2
         I_INDEX = (I-MINI)*LSTRI + 1
         DO 230 K= MINK,MAXK
            IK_INDEX = (K-MINK)*LSTRK + I_INDEX
            IF(KANDL) LMAX= K
            DO 220 L= MINL,LMAX
               IKL_INDEX = (L-MINL)*LSTRL + IK_INDEX
               IKL= IKL+1
               DO 210 J= MINJ,MAXJ
                  JJ= LOCJ+J
                  JJL= IT2LOC(JJ)
                  IJKL_INDEX = (J-MINJ)*LSTRJ + IKL_INDEX
C
                  VAL = GHONDO( IJKL_INDEX)
C                  WRITE(6,'(4I3,F15.8)') I,J,K,L,VAL 
                  IF(ABS(VAL).LT.CUTOFFAO) GO TO 210
                  IF(KANDL.AND.K.EQ.L) VAL= VAL*HALF
                  NUMINT(IKL)= NUMINT(IKL)+1
                  AOINTS(NUMINT(IKL),IKL)= VAL
                  LBLINT(NUMINT(IKL),IKL)= JJL
  210          CONTINUE
  220       CONTINUE
  230    CONTINUE
  240 CONTINUE
C
      RETURN
      END
C
