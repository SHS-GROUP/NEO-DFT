C  1 May 13 - MWS - extend diabatization to MCQDPT level
C  9 Nov 12 - AAW - adjust calling args for DETFCI/DEFCCI
C 19 Oct 12 - MWS - provide missing comma in a format.
C  2 Sep 12 - MWS - port from HONDO-PLUS into GAMESS
C    Sep 06 - RV  - modifications by Valero
C    Feb 02 - HN  - original implementation by Nakamura/Truhlar
C
C*MODULE DIAB    *DECK DIABATX
C>
C> @brief      generate diabatic states
C>
C> @details    adiabatic states from CAS or from MCQDPT are
C>             converted into diabatic states.  Diabatic Molecular
C>             Orbitals (DMOs) are generated at the CAS level only,
C>             by the 3-fold or 4-fold way.
C>
C> @author     Hisao Nakamura, Rosendo Valero, and Donald Truhlar
C>             -2002,2006
C>
C> @date November 09, 2012-Aaron West
C> -Added icimalmq argument to detfci and defcci calls.
C>
      SUBROUTINE DIABATX(NWFNFLG)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION METHOD
C
      CHARACTER*8 DIAVECW,DFRMVECW,DPSVECW,FRDCW,FRVLW,ENDWRD
C
      LOGICAL GOPARR,DSKWRK,MASWRK,SVDSKW,
     *        CANONC,FCORE,FORS,EKT,LINSER,AVGGUGA
      LOGICAL DOCORE,DOOOOO,DOVOOO,DOVVOO,DOVOVO,DOVVVO,DOVVVV,
     *        DOEXCH,DOFOCK,DDITRF
      LOGICAL OFFSYM,STDPHASE
C
      PARAMETER (MXATM=2000, MXRT=100, MXNORO=250)
C
C        effectively remove active space size limit by making it huge.
      PARAMETER (MXDIABACT=30)
C
C        symmetry labels for various orbitals, for active space only.
      DIMENSION MOSLAB_ACTIVE(MXDIABACT)
      DIMENSION MOSLAB_REFDMO(MXDIABACT)
      DIMENSION MOSLAB_REFPS(MXDIABACT)
      DIMENSION MOSLAB_PSEUDO(MXDIABACT)
C        averaged occupation number of the active MOs
      DIMENSION AVOCC_ACT(MXDIABACT)
      DIMENSION ITEMP(MXDIABACT)
C
      DIMENSION ECI_SAV(MXRT)
C
      COMMON /CIFILS/ NFT11,NFT12,NFT13,NFT14,NFT15,NFT16,IDAF20,NEMEMX
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,SDET,SZDET,
     *                GRPDET,STSYM,GLIST,DWPARM,NFLGDM(MXRT),
     *                IWTS(MXRT),NCORSV,NCORDET,NACTDET,NORBDET,
     *                NADET,NBDET,KDET,KSTDET,IROOT,IPURES,MAXW1,NITDET,
     *                MAXP,NCIDET,IGPDET,KSTSYM,NFTGCI,IDWEIGH
      COMMON /DIABAT/ ALPHA_N,ALPHA_R,ALPHA_T,
     *                TH_DOC,TH_VIR,SLCTTH,CONV_TH,WBLOCK(3),
     *                NDFRM,NDMOSYM,NRCSF,NMLAP,NDLAP,NORIENT,
     *                MOSLAB_CHARACT(MXDIABACT),
     *                MAX_ITER,NGRSTATE,NEXSTATE,NSTDIAB,
     *                NSYMBOL_DOC,NSYMBOL_VAL,NSYMBOL_VIR
      COMMON /DM2AVG/ WAVGGUGA(MXRT),IAVGGUGA(MXRT),NAVGGUGA,AVGGUGA
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FMCOM / X(1)
      COMMON /FUNCT / E,EG(3*MXATM)
      COMMON /GUGWFN/ NFZCGUGA,NMCCGUGA,NDOCGUGA,NAOSGUGA,NBOSGUGA,
     *                NALPGUGA,NVALGUGA,NEXTGUGA,NFZVGUGA,IFORSGUGA,
     *                IEXCITGUGA,ICICIGUGA,NOIRRGUGA
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NAINF,NBINF,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWORD,NORBMC,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PSILVL/ IPSI,ISKPRP
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      INTEGER         D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB
      LOGICAL         NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
      COMMON /TRFDMS/ D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB,
     *                NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
C
      DATA GUGA,ALDET/8HGUGA    ,8HALDET   /
      DATA DRTNAM/8HDRT     /
      DATA CHECK/8HCHECK   /
C
      DATA ZERO          /0.0D+00/
      DATA TWO           /2.0D+00/
      DATA LAB_C1       /4HA   /
C
      DATA DIAVECW  /' $DIAVEC'/
      DATA DFRMVECW /' $DFMVEC'/
      DATA DPSVECW  /' $DPSVEC'/
      DATA FRDCW    /' $LCLDC '/
      DATA FRVLW    /' $LCLVL '/
      DATA ENDWRD   /' $END   '/
C
C             program for diabatization by the four-fold way
C       written by Hisao Nakamura, Rosendo Valero, and Donald Truhlar
C             for U. Minnesota's HONDO-PLUS, in 2002 and 2006
C                           inspired by:
C       G.J.Atchity, K.Ruedenberg  Theoret.Chem.Acc. 97, 47-58(1997)
C                   whose basic method is extended by:
C       H.Nakamura, D.G.Truhlar J.Chem.Phys. 115, 10353-10372(2001)
C       H.Nakamura, D.G.Truhlar J.Chem.Phys. 117, 5576-5593(2002)
C                       with certain applications:
C       H.Nakamura, D.G.Truhlar J.Chem.Phys. 118, 6816-6829(2003)
C       R.Valero, D.G.Truhlar   J.Chem.Phys. 125, 194305/1-22(2006)
C       Z.H.Li, R.Valero, D.G.Truhlar Theor.Chem.Acc. 118, 9-24(2007)
C       R.Valero, D.G.Truhlar  J.Phys.Chem.A 111, 8536-8551(2007)
C       R.Valero, D.G.Truhlar  J.Phys.Chem.A 112, 5756-5769(2008)
C
C            ported from HONDO+ to GAMESS in summer 2012
C                     at Iowa State University
C
C            ==============  Start  ============
C
C     NWFNFLG=0 --> CAS-level diabatization, including DMO generation.
C     NWFNFLG=1 --> MCQDPT-level diabatization.
C
      IF (NWFNFLG.EQ.0) THEN
        IF(MASWRK) WRITE(IW,9010)
      ELSE
        IF(MASWRK) WRITE(IW,9020)
      END IF
C
C     Check that the -MC- orbitals are CASSCF type or not
C
      IF (CISTEP.NE.GUGA  .AND.  CISTEP.NE.ALDET) THEN
        IF(MASWRK) WRITE(IW,9040)
        CALL ABRT
      END IF
C
C          ---- Set some orbital parameters ----
C     nbf:    # of AOs
C     ncorbs: # of core (i.e. doubly occupied) orbitals
C     nact:   # of active orbitals
C     norbs:  # of occupied MOs = core + active
C
      NBF=NUM
C
      IF(CISTEP.EQ.ALDET) THEN
         NCORBS = NCORSV
         NACT = NACTDET
      END IF
      IF(CISTEP.EQ.GUGA) THEN
         NCORBS = NMCCGUGA
         NACT = NDOCGUGA + NALPGUGA + NAOSGUGA + NBOSGUGA + NVALGUGA
      END IF
      NORBS=NCORBS+NACT
C
C              ----- count how many states are involved -----
C         NSTATE is number of all states computed, with correct spin.
C         NSTTOP is the "top" state with a non-zero weight, note
C                that states below NSTTOP might have zero weight.
C         NSTDIAB is number of states being diabatized,
C                namely NSTATE excluding NGRSTATE and NEXSTATE.
C         NSTDMO is number of states included during DMO generation,
C                usually NGRSTATE + NSTDIAB = NSTATE - NEXSTATE.
C
      IF(CISTEP.EQ.GUGA) THEN
         NSTATE = INT(STATN+0.1D+00)
         NSTTOP = IAVGGUGA(NAVGGUGA)
      END IF
      IF(CISTEP.EQ.ALDET) THEN
         NSTATE = 0
         DO IST=1,KDET
           IF(ABS(SPINS(IST)-SDET) .LT. 0.03D+00) NSTATE=NSTATE+1
         ENDDO
         NSTTOP=NSTATE
         DO IST=NSTATE,1,-1
           IF(WSTATE(IST).NE.ZERO) THEN
              GO TO 11
           ELSE
              NSTTOP = NSTTOP - 1
           END IF
         ENDDO
 11      CONTINUE
      END IF
C
C       --- set default values of $DIABAT input and other params ---
C
      CALL DIABINP(NACT,NSTATE,NSTTOP)
C
      IF(WBLOCK(3).EQ.ZERO) THEN
         NSTDMO = NSTATE - NEXSTATE
      ELSE
         NSTDMO = NSTATE
      END IF
      IF(MASWRK) WRITE(IW,9050) NCORBS,NACT,NQMT,NBF,
     *                          NSTATE,NSTDMO,NSTDIAB
C
      IF(E.EQ.ZERO  .AND.  EXETYP.NE.CHECK) THEN
         IF(MASWRK) WRITE(IW,9045)
         CALL ABRT
      END IF
C
C        work file used to hold densities and CI vectors
C
      NFT21=21
      CALL SEQOPN(NFT21,'DIABDAT','NEW',.FALSE.,'UNFORMATTED')
C
C        MCQDPT diabatization should completely skip DMO generation.
C        MCQDPT passed through here earlier, after the MCSCF converged,
C        to make CAS-level DMOs, which were then used by the MCQDPT.
C        MCQDPT can therefore go directly to the re-diabatization.
C
      IF(NWFNFLG.EQ.1) GO TO 5000
C
C        Check if -MC- orbitals are averaged Fock orbital or not.
C        if run later, MCQDPT must use canonical orbitals
C        in the inactive and external orbital spaces.
C
      IF (MPLEVL.NE.0) THEN
         IF(CANONC) THEN
            IF(MASWRK) WRITE(IW,9070)
         ELSE
            IF(MASWRK) WRITE(IW,9060)
            CALL ABRT
         END IF
      END IF
C
C        by controlling individual orbital phases at various steps,
C        the number of iterations in -MORMO- maximization is reduced.
C        Also, the -NVAL- type 4-fold step's D3 seemed crisper.
C        This doesn't change the final maximal values very much,
C        but does seem to help systematize D3/MORMO Jacobi steps.
C
      STDPHASE = .TRUE.
C
C Make back up of the canonicalized CAS MO (average Fock orbitals)
C
      CALL VALFM(LOADFM)
      LVEC = LOADFM + 1
      LAST = LVEC   + NBF*NBF
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
      CALL DAREAD(IDAF,IODA,X(LVEC),NBF*NBF, 15,0)
      CALL DAWRIT(IDAF,IODA,X(LVEC),NBF*NBF,541,0)
      CALL RETFM(NEED)
C
C   ======= prepare density and transition density matrices =========
C
C   after the CASSCF converged, there was a canonicalization
C   of the core/active/virtual blocks, as well as regeneration
C   of the CAS-CI vectors for those canonical orbitals.
C
C   Thus we can proceed directly to generation of density matrices
C   and transition density matrices for these CAS-CI canonical orbs.
C
C         prepare symmetry information for the CAS canonical MO-s.
C         active orbital's symmetry strings are saved in memory.
C
      IF(MASWRK) WRITE(IW,9080) NSTDMO
C
      NBF2 = (NBF*NBF+NBF)/2
      NBF3 = NBF*NBF
      CALL VALFM(LOADFM)
      LMOIRP = LOADFM + 1
      LMOLAB = LMOIRP + NBF
      LMODEG = LMOLAB + NBF
      LQ     = LMODEG + NBF
      LS     = LQ     + NBF3
      LV     = LS     + NBF2
      LWRK   = LV     + NBF3
      LAST   = LWRK   + NBF
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
      CALL MOSYMDIAB(CISTEP,X(LMOIRP),X(LMOLAB),X(LMODEG),X(LQ),X(LS),
     *               X(LV),X(LWRK),MOSLAB_ACTIVE,NCORBS,NACT,
     *               NQMT,NBF,NBF2,NBF3)
      CALL DAWRIT(IDAF,IODA,X(LMOLAB),NBF,255,1)
      CALL DAWRIT(IDAF,IODA,X(LMOIRP),NBF,262,1)
      CALL RETFM(NEED)
C
C     ----- prepare CAS-CI density and transition density matrices -----
C     GUGA and determinants share common storage for energy and density.
C     Redundant TDM are prepared, rho-I,J and rho-J,I for states I,J.
C     These obey the relation rho-I,J(k,l) = rho-J,I(l,k), for MO's k,l.
C
      CALL VALFM(LOADFM)
      LENGY  = LOADFM + 1
      LTDM   = LENGY  + NSTDMO
      LAST   = LTDM   + NACT*NACT*NSTDMO*NSTDMO
      NEEDTDM = LAST - LOADFM - 1
      CALL GETFM(NEEDTDM)
C
C           ----- in case the calculation is using CSFs -----
C
      IF(CISTEP.EQ.GUGA) THEN
         IF(MASWRK) THEN
            WRITE(IW,9100)
            IWST=1
            DO IST=1,NSTATE
               IF(IST.EQ.IAVGGUGA(IWST)) THEN
                  WTMCSCF = WAVGGUGA(IWST)
                  IWST=IWST+1
               ELSE
                  WTMCSCF = ZERO
               END IF
               WTDIAB = ZERO
               IF(IST.LE.NGRSTATE)         WTDIAB=WBLOCK(1)/NGRSTATE
               IF(IST.GT.NGRSTATE)         WTDIAB=WBLOCK(2)/NSTDIAB
               IF(IST.GT.NGRSTATE+NSTDIAB .AND. NEXSTATE.NE.0)
     *                                     WTDIAB=WBLOCK(3)/NEXSTATE
               WRITE(IW,9110) IST,ESTATE(IST),WTMCSCF,WTDIAB
            ENDDO
         END IF
C
         CALL GUGTDMX(NCORBS,NACT,NBF,NSTDMO,X(LTDM),X(LENGY),0)
      END IF
C
C        ----- in case the calculation is using determinants -----
C
      IF(CISTEP.EQ.ALDET) THEN
         IF(MASWRK) THEN
            WRITE(IW,9120)
            ISPST = 0
            DO 21 IST=1,KDET
              IF(IPURES.EQ.1) THEN
                 IF(ABS(SPINS(IST)-SDET) .GT. 0.03D+00) GO TO 21
                 ISPST = ISPST + 1
              ELSE
                 ISPST = ISPST + 1
              ENDIF
              WTMCSCF = WSTATE(ISPST)
              WTDIAB = ZERO
              IF(ISPST.LE.NGRSTATE)         WTDIAB=WBLOCK(1)/NGRSTATE
              IF(ISPST.GT.NGRSTATE)         WTDIAB=WBLOCK(2)/NSTDIAB
              IF(ISPST.GT.NGRSTATE+NSTDIAB .AND. NEXSTATE.NE.0)
     *                                      WTDIAB=WBLOCK(3)/NEXSTATE
              WRITE(IW,9130) ISPST,IST,ESTATE(IST),SPINS(IST),
     *                       WTMCSCF,WTDIAB
   21       CONTINUE
         END IF
C
         CALL DETTDMX(NCORBS,NACT,NBF,NSTDMO,X(LTDM),X(LENGY),0)
      END IF
C
C          output these densities to a disk file.
C
      CALL WRITETDM(NFT21,X(LTDM),X(LENGY),NSTDMO,NACT)
C
      CALL RETFM(NEEDTDM)
      IF(MASWRK) WRITE(IW,9140)
      CALL TIMIT(1)
C
C     ======= memory for reading various standard orbitals =======
C     ======= this memory also used for creation of DMO's  =======
C
      N1=NBF*NBF
      N2=(NBF*NBF+NBF)/2
C         no. unique DM and TDM, plus one more for state-averaged DM.
      NDMAT = (NSTDMO*NSTDMO+NSTDMO)/2 + 1
C
      CALL VALFM(LOADFM)
      LDFMO    = LOADFM   + 1
      LSAO     = LDFMO    + NBF*NACT
      LSMO     = LSAO     + (NBF*NBF+NBF)/2
      LWORK    = LSMO     + NACT*NACT
      LACTMO   = LWORK    + NBF*NBF
      LDENS    = LACTMO   + NBF*NACT
      LDPSMO   = LDENS    + NACT*NACT*NDMAT
      LRMOLAB  = LDPSMO   + NBF*NACT
      LTRI     = LRMOLAB  + NACT
      LEVEC    = LTRI     + (NACT*NACT+NACT)/2
      LEVAL    = LEVEC    + NACT*NACT
      LIWRK    = LEVAL    + NACT
      LWRKVEC  = LIWRK    + MAX(NACT,NBF)
      LQ       = LWRKVEC  + NBF
      LTRANS   = LQ       + NBF*NBF
      LU       = LTRANS   + 3*3*NAT
      LAST     = LU       + NACT*NACT
      NEEDDMO = LAST - LOADFM - 1
      CALL GETFM(NEEDDMO)
C
C     Read AO overlap
C
      CALL DAREAD(IDAF,IODA,X(LSAO)  ,N2 ,12 ,0)
C
C        average occupations of active orbitals is set later,
C        clear now before printing with fake zero eigenvalues.
C
      DO I=1,NACT
         AVOCC_ACT(I) = ZERO
      ENDDO
C
C         ---- orbitals of the reference geometry ($DFMVEC) ----
C     Read $DFMVEC, assign its irreps, and check irreps ordering of
C     the $DFMVEC matches the original CAS MOs.
C     If the ordering of irreps is different, stop!
C     Finally $DFMVEC is symmetric orthogonalized and saved for later.
C     When NDFRM=0, these MOs are taken as original av Fock orbitals.
C              -actmo- storage used as scratch space here
C
      IF (NDFRM.NE.0) THEN
        CALL DFMSYMCHK(NBF,NACT,NQMT,MOSLAB_ACTIVE,X(LDFMO),
     *                 X(LWORK),X(LSAO),X(LACTMO),X(LRMOLAB),STDPHASE)
        CALL DFMSYMVEC(NBF,NACT,X(LDFMO),X(LSAO),X(LSMO),X(LTRI),
     *                 X(LEVEC),X(LEVAL),X(LWORK),X(LIWRK))
        IF(MASWRK) WRITE(IW,9150)
        CALL PRSQL(X(LDFMO),NACT,NBF,NBF)
        CALL DAWRIT(IDAF,IODA,X(LDFMO),NBF*NACT,542,0)
      ELSE
        CALL DAREAD(IDAF,IODA,X(LWORK)           ,NBF*NBF ,541,0)
        CALL DAWRIT(IDAF,IODA,X(LWORK+NBF*NCORBS),NBF*NACT,542,0)
      END IF
C
C                ---- resolution orbitals ($DIAVEC) ----
C     Read $DIAVEC (main resolution DMOs), if NMLAP>0 in input.
C     assign irreps of $DIAVEC.
C                -LDFMO- storage is recycled here, $DFMVEC now on disk.
C               -LACTMO- storage is scratch space for this call.
      IF (NMLAP.NE.0) THEN
        CALL REFDMOSYM(NMLAP,NQMT,NBF,
     *                 X(LDFMO),X(LWORK),X(LSAO),X(LACTMO),
     *                 X(LTRANS),MOSLAB_REFDMO,
     *                 DIAVECW,FRVLW,NAT,NORIENT,STDPHASE)
        IF(MASWRK) WRITE(IW,9160)
        CALL PRSQL(X(LDFMO),NMLAP,NBF,NBF)
      END IF
C
C                ---- resolution orbitals ($DPSVEC) ----
C     Read $DPSVEC (pre-4-fold doubly occupied space resolution orbs),
C     if NDLAP>0 in input group.   Assign irreps of $DPSVEC.
C
      IF (NDLAP.NE.0) THEN
        CALL REFDMOSYM(NDLAP,NQMT,NBF,
     *                 X(LDPSMO),X(LWORK),X(LSAO),X(LACTMO),
     *                 X(LTRANS),MOSLAB_REFPS,
     *                 DPSVECW,FRDCW,NAT,NORIENT,STDPHASE)
        IF(MASWRK) WRITE(IW,9170)
        CALL PRSQL(X(LDPSMO),NDLAP,NBF,NBF)
      END IF
C
      IF(EXETYP.EQ.CHECK) THEN
         IF(MASWRK) WRITE(IW,9180)
         GO TO 400
      END IF
C
C         Pick up the active MO coefficients, at -ACTMO-
C
      CALL DAREAD(IDAF,IODA,X(LWORK),N1,15,0)
      CALL DCOPY(NBF*NACT,X(LWORK+NBF*NCORBS),1,X(LACTMO),1)
C
C         Read all DM/TDM, and then add SA-DM at the end
C
      CALL READTDM(NFT21,X(LDENS),NSTDMO,NACT,NDMAT)
C
C               all this setup work has now produced:
C       reference geometry orbitals on disk, at record 542.
C       x(lactmo) ---> active MO's LCAO expansion
C       x(ldens)  ---> all DM + TDM + SA-DM (each of size=NACT*NACT)
C       x(lsao)   ---> AO overlap
C       x(ldfmo)  ---> resolution DMOs (i.e. $DIAVEC)
C       x(ldpsmo) ---> doubly occ. space resolution MO (i.e. $DPSVEC)
C
C     input option to turn off the use of orbital symmetry
C
      IF (NDMOSYM.EQ.0) THEN
        DO I=1,NACT
          MOSLAB_ACTIVE(I)=LAB_C1
        END DO
        DO I=1,NMLAP
          MOSLAB_REFDMO(I)=LAB_C1
        END DO
        DO I=1,NDLAP
          MOSLAB_REFPS(I)=LAB_C1
        END DO
      END IF
C
C   Optimization of Diabatic Molecular Orbitals (DMOs) now begins...
C   (1) The Threefold density criterion
C   (2) Apply the four-fold way to Doc-candidate MOs
C   (3) Separate active space to 3 (or 2 or 1) block as 'doc,val,vir'
C   (3) The four-fold way with (block) MORMO criterion
C   (4) deformation check
C
C   Step (1) Carry out the threefold density criterion
C            and transform MO coefficients.
C            DM's at -LDENS- and MO coefs at -LACTMO- are updated.
C
      CALL THREEFOLD(ALPHA_N,ALPHA_R,ALPHA_T,CONV_TH,MAX_ITER,
     &               NSTDMO,NBF,NACT,MOSLAB_ACTIVE,AVOCC_ACT,
     &               X(LDENS),X(LACTMO),X(LWORK),X(LU),
     &               NDMAT,STDPHASE)
C
C   Step (2) Pick up  Doc block candidate (if necessary)
C
      NDOC=0
      DO I=1,NACT
        IF (MOSLAB_CHARACT(I).EQ.NSYMBOL_DOC) NDOC=NDOC+1
      END DO
C
      NDOC_CAND=0
C
C         decision on performing pre-four-fold way:
C
      IF ((NDFRM.EQ.0).OR.(NDLAP.EQ.0).OR.(NDOC.EQ.0)) GO TO 100
C
      IF(MASWRK) WRITE(IW,9300) (MOSLAB_CHARACT(I),I=1,NACT)
C
C DOC block candidates are treated as target of CR algorithm.
C Thus such MOs are identified "nsymbol_val" because they are
C applied to the fourfold way.
C
      DO I=1,NACT
        IF (TH_DOC.LT.AVOCC_ACT(I)) THEN
          NDOC_CAND=NDOC_CAND+1
          MOSLAB_PSEUDO(I)=NSYMBOL_VAL
        ELSE
          MOSLAB_PSEUDO(I)=NSYMBOL_VIR
        END IF
      END DO
C
C          check
C
      IF (NDOC_CAND.LT.NDOC) THEN
        IF(MASWRK) WRITE(IW,9310) NDOC_CAND,NDOC
        GO TO 100
      ELSE
        IF(MASWRK) WRITE(IW,9320) NDOC_CAND,NDOC_CAND-NDOC
      END IF
C
C     Sort of the "caught" MOs, to accelerate convergence
C
      ICOUNT=0
      DO I=1,NACT
        IF (TH_DOC.LT.AVOCC_ACT(I)) THEN
          ICOUNT=ICOUNT+1
          ITEMP(ICOUNT)=I
        END IF
      END DO
C
      CALL PRESORT(NSTDMO,NBF,NACT,NDOC_CAND,NDLAP,ITEMP,
     &             X(LACTMO),X(LDPSMO),X(LSAO),X(LSMO),X(LWORK),
     &             X(LDENS),NDMAT,AVOCC_ACT,MOSLAB_ACTIVE)
C
C          Apply four-fold way to the DOC-candidates
C
      CALL FOURFOLD(ALPHA_N,ALPHA_R,ALPHA_T,CONV_TH,MAX_ITER,
     &              NSTDMO,NBF,NACT,NDLAP,
     &              MOSLAB_ACTIVE,MOSLAB_REFPS,MOSLAB_PSEUDO,
     &              X(LDENS),NDMAT,X(LACTMO),X(LDPSMO),X(LSAO),
     &              AVOCC_ACT,X(LWORK),X(LU),STDPHASE)
C
C Step (3)  Define the block (DOC/VAL/VIR) by using $DFMVEC,
C           the updated MO, and occupation number etc.
C
  100 CONTINUE
      CALL DETBLOCK(NBF,NACT,NSTDMO,NDOC_CAND,
     &              MOSLAB_ACTIVE,MOSLAB_PSEUDO,AVOCC_ACT,
     &              X(LSMO),X(LACTMO),X(LWORK),X(LSAO),X(LDENS),NDMAT)
C
C Step (4) The fourfold way for Val block as the final determination
C
      IF (NMLAP.NE.0) THEN
         IF(MASWRK) WRITE(IW,9330) (MOSLAB_CHARACT(I),I=1,NACT)
C
C     Sort of MO in the caught part to accelerate convergence
C
        ICOUNT=0
        DO I=1,NACT
          IF (MOSLAB_CHARACT(I).EQ.NSYMBOL_VAL) THEN
            ICOUNT=ICOUNT+1
            ITEMP(ICOUNT)=I
          END IF
        END DO
C
        CALL PRESORT(NSTDMO,NBF,NACT,ICOUNT,NMLAP,ITEMP,
     &               X(LACTMO),X(LDFMO),X(LSAO),X(LSMO),X(LWORK),
     &               X(LDENS),NDMAT,AVOCC_ACT,MOSLAB_ACTIVE)
C
        CALL FOURFOLD(ALPHA_N,ALPHA_R,ALPHA_T,CONV_TH,MAX_ITER,
     &                NSTDMO,NBF,NACT,NMLAP,
     &                MOSLAB_ACTIVE,MOSLAB_REFDMO,MOSLAB_CHARACT,
     &                X(LDENS),NDMAT,X(LACTMO),X(LDFMO),X(LSAO),
     &                AVOCC_ACT,X(LWORK),X(LU),STDPHASE)
      END IF
C
C Step (4) final Ordering of the DMOs
C
      CALL ORDDMO(NBF,NACT,NSTDMO,
     &            MOSLAB_ACTIVE,X(LDENS),NDMAT,AVOCC_ACT,
     &            X(LACTMO),X(LWORK),X(LSAO),X(LSMO))
C
      IF(NWFNFLG.EQ.0  .AND.  NDFRM.EQ.1) THEN
        CALL PRLAPDMO(NBF,NACT,X(LACTMO),X(LWORK),X(LSAO),X(LSMO))
      END IF
C
C  Insert the active DMOs into pristine MCSCF orbs to have
C  the full set: inactive MO, active DMO, and external MO.
C  Write to disk to set up CAS-CI state generation using DMOs.
C  Get symmetry labels for the purpose of printing.
C  Build a full table of electron occupancies for printing.
C
      CALL DAREAD(IDAF,IODA,X(LWORK),NBF*NBF,541,0)
      CALL DCOPY(NBF*NACT,X(LACTMO),1,X(LWORK+NBF*NCORBS),1)
      CALL DAWRIT(IDAF,IODA,X(LWORK),N1,15,0)
C
      CALL DAREAD(IDAF,IODA,X(LQ),NBF*NBF,45,0)
      CALL SYMMOS(X(LIWRK),X(LQ),X(LSAO),X(LWORK),X(LWRKVEC),
     *            NQMT,NBF,NCORBS+NACT,NBF)
C
      DO I=1,NCORBS
         X(LWRKVEC+I-1) = TWO
      ENDDO
      CALL DCOPY(NACT,AVOCC_ACT,1,X(LWRKVEC+NCORBS),1)
C
C      --- Print and Punch the active DMO in the AO basis ---
C  Printing is core+active orbitals, all from temporary storage:
C       diabatized molecular orbitals are at -LWORK-
C       averaged occupancies at -LWRKVEC-
C       symmetry labels at -LIWRK-
C  Punching is active DMO's only,
C       these are potentially candidates for future use as $DFMVEC.
C
      IF (MASWRK  .AND.  NWFNFLG.EQ.0) THEN
         WRITE(IW,9350) NACT,NDLAP,NMLAP,NACT
         CALL PREVS(X(LWORK),X(LWRKVEC),X(LIWRK),NCORBS+NACT,NBF,NBF,1)
C
         WRITE(IP,*) '--- DIABATIC ORBITALS FOR CAS-SCF (ACTIVE) ---'
         WRITE(IP,'(A8)') DFRMVECW
         CALL PUSQL(X(LACTMO),NACT,NBF,NBF)
         WRITE(IP,'(A8)') ENDWRD
      END IF
C
C            this completes DMO generation!
C
  400 CONTINUE
      CALL RETFM(NEEDDMO)
      IF(MASWRK) WRITE(IW,9370)
      CALL TIMIT(1)
C
C   ========== Carry out CAS-CI calculation using new DMOs ============
C   DAF record 15 is now CAS-DMO's, inactive and external are av Fock.
C
      IF(MASWRK) WRITE(IW,9400)
C
C   Save energies of all the adiabatic states.
C
      IF(CISTEP.EQ.GUGA) THEN
         DO I=1,NSTATE
           ECI_SAV(I)=ESTATE(I)
         END DO
      END IF
      IF(CISTEP.EQ.ALDET) THEN
         K=0
         DO IST=1,KDET
           IF(ABS(SPINS(IST)-SDET) .GT. 0.03D+00) THEN
              CONTINUE
           ELSE
              K=K+1
              ECI_SAV(K) = ESTATE(IST)
           END IF
         ENDDO
      ENDIF
C
C   Symmetry turned OFF if requested by input.
C
      IF (NSTATE.GT.1   .AND.   NDMOSYM.EQ.0) THEN
        CALL SYMOFF
        OFFSYM=.TRUE.
      ELSE
        OFFSYM=.FALSE.
      END IF
C
C     ----- Get CAS-CI adiabatic states for the new DMO basis ----
C
C       CSFs and determinants need the same tranny, first.
C       Note: serial CASTRF might be faster but requires resetting
C             the norbs for DRT common /orbset/ to include cores,
C             after GUGA steps run (such as NTNCAN's adiab. states).
C
      IPSI=1
C
      IPRINT=0
      DDITRF=GOPARR
      DOFOCK = .TRUE.
      DOEXCH = .FALSE.
C            CI OFF DDI INTEGRALS DOESN'T KNOW HOW TO SKIP CORES.
      DOCORE = .TRUE.
      DOOOOO = .TRUE.
      DOVOOO = .FALSE.
      DOVVOO = .FALSE.
      DOVOVO = .FALSE.
      DOVVVO = .FALSE.
      DOVVVV = .FALSE.
      CALL TRFMCX(IPRINT,NCORBS,NORBS,NORBS,DOFOCK,DOEXCH,DDITRF,
     *            DOOOOO,DOVOOO,DOVVOO,DOVOVO,DOVVVO,DOVVVV,DOCORE)
C
      IF(CISTEP.EQ.GUGA) THEN
         SVDSKW=DSKWRK
         DSKWRK=.TRUE.
         CALL DRTGEN(IPRINT,DRTNAM)
         CALL GUGSRT(IPRINT,DDITRF)
         CALL GUGAEM(IPRINT)
         CALL ERASCI
         CALL GUGADG(IPRINT)
         DSKWRK=SVDSKW
      END IF
C
      IF(CISTEP.EQ.ALDET) THEN
         IROOTSV=IROOT
         IF(IROOT.LE.0) IROOT=1
         CALL DETFCI(IPRINT,.TRUE.,DDITRF,0)
         IROOT=IROOTSV
      END IF
C
      IF(DDITRF  .AND.  EXETYP.NE.CHECK) THEN
         IF(MASWRK) WRITE(IW,9700)
         CALL DDI_DESTROY(D_OOOO)
      END IF
C
      IPSI=0
C
C     =========== Finally, the diabatization procedure  ===========
C     NWFNFLG tells us what type,
C        (1) for CAS-CI, using GUGA CSFs only.
C        (2) for MCQDPT, using Nakano's GUGA CSF program only.
C
 5000 CONTINUE
      IF(NWFNFLG.EQ.0) THEN
         IF(MASWRK) WRITE(IW,9410)
      ELSE
         IF(MASWRK) WRITE(IW,9420)
      ENDIF
C
      IF(CISTEP.EQ.GUGA) THEN
C              MCQDPT-level needs to regenerate DRT info.
         IF(NWFNFLG.EQ.1) THEN
            SVDSKW=DSKWRK
            DSKWRK=.TRUE.
            IPRINT=-5
            CALL DRTGEN(IPRINT,DRTNAM)
            DSKWRK=SVDSKW
         END IF
         MAXLIST=200
         MAXRT=MXRT
         IF(MASWRK) THEN
            CALL SEQREW(NFT11)
            READ(NFT11) IDUM,IDUM,IDUM,NROWS,NWKS
            CALL SEQREW(NFT11)
            IF(IDUM.NE.0) IDUM=0  ! FOR FTNCHEK
         END IF
         IF(GOPARR) THEN
            CALL DDI_BCAST(2148,'I',NROWS,1,MASTER)
            CALL DDI_BCAST(2148,'I',NWKS,1,MASTER)
         END IF
C
C         dynamic memory allocations for GUGA diabatization
C
                          NCIVEC=1
         IF(NWFNFLG.EQ.1) NCIVEC=NSTDMO
         CALL VALFM(LOADFM)
         LDCI     = LOADFM   +1
         LDCIREF  = LDCI     + MAXLIST*MAXRT
         LDCIRF2  = LDCIREF  + MAXLIST*MAXRT
         LLSTCSF  = LDCIRF2  + MAXLIST*MAXRT
         LLSTGRP  = LLSTCSF  + MAXLIST
         LISTACK  = LLSTGRP  + MAXLIST
         LCIVEC   = LISTACK  + NSTATE
         LLEVIR   = LCIVEC   + NWKS*NCIVEC
         LICASE   = LLEVIR   + NBF
         LIECONF  = LICASE   + NBF
         LIECASE  = LIECONF  + NBF
         LIARC    = LIECASE  + NBF
         LTABCF   = LIARC    + NROWS*4
         LIOUTIV  = LTABCF   + MAXLIST
         LT       = LIOUTIV  + NBF
         LTP      = LT       + NSTDIAB*NSTDIAB
         LS       = LTP      + NSTDIAB*NSTDIAB
         LSTRI    = LS       + NSTDIAB*NSTDIAB
         LIWORK   = LSTRI    + (NSTDIAB*NSTDIAB+NSTDIAB)/2
         LWRKVEC  = LIWORK   + NSTDIAB
         LEIGVAL  = LWRKVEC  + NSTDIAB
         LEIGBUF  = LEIGVAL  + NSTDIAB
         LU       = LEIGBUF  + NSTDIAB*NSTDIAB
         LBUFF    = LU       + NSTDIAB*NSTDIAB
         LWORK    = LBUFF    + NSTDIAB*NSTDIAB
         LQDPTROT = LWORK    + MAXLIST*NSTDIAB
         LWRKROT  = LQDPTROT + NSTDIAB*NSTDIAB
         LCIMXMC  = LWRKROT  + NSTDIAB
         LCIMXPT  = LCIMXMC  + NSTDIAB*10
         LAST     = LCIMXPT  + NSTDIAB*10
         NEEDDIAB = LAST - LOADFM - 1
         CALL GETFM(NEEDDIAB)
C
C  (i) Create lists of dominate CSF groups G_k for each state k,
C      or if the list is specified in the input, use the input.
C
         IF(NRCSF.NE.0) THEN
            CALL RDCSFGRPS(NSTDMO,NLIST,X(LDCIREF),X(LLSTCSF),
     &                     X(LLSTGRP),MAXLIST,MAXRT)
         END IF
C
         IF(EXETYP.EQ.CHECK) THEN
            IF(MASWRK) WRITE(IW,9360)
            GO TO 500
         END IF
C
C (ii) Search CI coefficients of dominant CSFs, and store in DCICOEF.
C      FT21 may be used as scratch CI vector file here.
C
         MODE = NWFNFLG
                       NDIMQD=1
         IF(MODE.EQ.1) NDIMQD=NSTDIAB
         CALL REFADIAB(MODE,NFT21,
     &                 X(LLSTCSF),X(LLSTGRP),X(LDCI),X(LCIVEC),
     &                 X(LLEVIR),X(LICASE),X(LIECONF),X(LIECASE),
     &                 X(LIARC),ECI_SAV,X(LISTACK),X(LTABCF),
     &                 X(LIOUTIV),X(LQDPTROT),X(LWRKROT),
     &                 X(LCIMXMC),X(LCIMXPT),
     &                 NLIST,MAXLIST,MAXRT,NSTDMO,NDIMQD,
     &                 NWKS,NROWS,4*NROWS,NBF,NCIVEC)
C
C (iii) Make adiabatic/diabatic transformation matrix.
C       Print diabatic state's CSF expansions.
C       Print diabatic state's Hamiltonian elements.
C
         CALL MKDIAB(MODE,NRCSF,ECI_SAV,NLIST,X(LLSTGRP),
     &               X(LLSTCSF),X(LDCI),X(LDCIREF),X(LDCIRF2),
     &               X(LT),X(LTP),X(LS),X(LEIGVAL),X(LEIGBUF),
     &               X(LSTRI),X(LIWORK),X(LWRKVEC),X(LU),X(LBUFF),
     &               X(LWORK),NSTDMO,NGRSTATE,NSTDIAB,MAXLIST,MAXRT)
C
C
C (iv) Punch out CSF list,
C      CI coefficients of 'truncated' Diabatic states to $REFCSF
C
         CALL PUCSFGRPS(NSTDMO,NLIST,X(LDCI),X(LLSTCSF),X(LLSTGRP),
     &                  MAXLIST,MAXRT)
C
  500    CONTINUE
         CALL RETFM(NEEDDIAB)
      END IF
C
C           August 2012.
C           MWS believes everything above is OK for determinants,
C           except code for the actual diabatization is missing!
      IF(CISTEP.EQ.ALDET) THEN
         IF(MASWRK) WRITE(IW,9800)
         CALL ABRT
      END IF
C
C  ================= End of diabatization procedure ==================
C  At this point HONDO+ recovered the original canonical orbitals from
C  the MCSCF, then carried out one more CI to regenerate the original
C  MCSCF adiabatic states.  All printing was turned off, so the only
C  point to this must have been a desire to leave the orbitals,
C  CI vectors, density matrices, etc. in the original condition.
C  Right now, this program just leaves the DMO-based data behind,
C  since that does not seem very important.  Note that this includes
C  leaving the CAS-level DMOs as orbital record 15.
C
C          Symmetry turned back ON
C
      IF (OFFSYM) THEN
         CALL SYMON
         OFFSYM=.FALSE.
      END IF
C
      IF(MASWRK) THEN
         IF(NWFNFLG.EQ.0) WRITE(IW,9900) 'CAS'
         IF(NWFNFLG.EQ.1) WRITE(IW,9900) 'MCQDPT'
      END IF
      CALL TIMIT(1)
      RETURN
C
 9010 FORMAT(/1X,'   ******************************************'/
     &        1X,'   DETERMINATION OF DIABATIC STATES BASED ON'/
     &        1X,'             CASSCF WAVE FUNCTIONS'/
     &        1X,'   PROGRAM WRITTEN BY H.NAKAMURA, D.G.TRUHLAR'/
     &        1X,'   ******************************************')
 9020 FORMAT(/1X,'   ******************************************'/
     &        1X,'   DETERMINATION OF DIABATIC STATES BASED ON'/
     &        1X,'             MCQDPT WAVE FUNCTIONS'/
     &        1X,'   PROGRAM WRITTEN BY H.NAKAMURA, D.G.TRUHLAR'/
     &        1X,'   ******************************************')
 9040 FORMAT(1X,'THIS DIABATIZATION PROGRAM ASSUMES CASSCF TYPE.'/
     *       1X,'PLEASE CHOOSE CISTEP=GUGA OR CISTEP=ALDET IN $MCSCF.')
 9045 FORMAT(/1X,'MCSCF DID NOT CONVERGE...NO DIABATIZATION!'/)
 9050 FORMAT(/1X,'ORBITAL AND STATE SIZES FOR DIABATIZATION:'/
     *        1X,'NUMBER OF    FILLED ORBITALS=',I5/
     *        1X,'NUMBER OF    ACTIVE ORBITALS=',I5,
     *           ' (THESE WILL BE TURNED INTO DMOS)'/
     *        1X,'NUMBER OF MOLECULAR ORBITALS=',I5/
     *        1X,'NUMBER OF    ATOMIC ORBITALS=',I5/
     *        1X,'NUMBER OF ELECTRONIC STATES OF CORRECT SPIN:',I3/
     *        1X,'NUMBER OF STATES USED DURING DMO GENERATION:',I3/
     *        1X,'NUMBER OF STATES TO BE DIABATIZED:          ',I3)
 9060 FORMAT(1X,'TO ESTIMATE MCQDPT ADIABATIC ENERGIES, NON-ACTIVE'/
     &       1X,'MO''S SHOULD BE FIXED BY THE STANDARD FOCK OPERATOR.'/
     &       1X,'PLEASE CHOOSE CANONC=.TRUE. IN $MCSCF, AND TRY AGAIN.')
 9070 FORMAT(/1X,'-------------------------------------------------'/
     &        1X,'MCQDPT ADIABATIC ENERGIES WILL BE COMPUTED USING'/
     &        1X,'CANONICALIZED FILLED AND EXTERNAL MO''S (CANONC)'/
     &        1X,'AND CAS-BASED DMO''S FOR THE ACTIVE SPACE.'/
     &        1X,'FIRST STAGE IS CAS DMO GENERATION (PRINTING CAS'/
     &        1X,'DIABATIZATION INFORMATION), THEN MCQDPT WILL RUN,'/
     &        1X,'AND THEN MCQDPT DIABATIZATION WILL BE PERFORMED.'/
     &        1X,'-------------------------------------------------')
 9080 FORMAT(/1X,'CREATING STATE-SPECIFIC DENSITY MATRICES AND',
     *          ' TRANSITION DENSITY MATRICES,'/
     *        1X,'FOR THE',I5,' ELECTRONIC STATES INCLUDED IN THE',
     *          ' DMO GENERATION:')
 9100 FORMAT(/1X,'STATE',12X,'ENERGY',4X,'WEIGHT IN MCSCF', 2X,
     *           ' WEIGHT IN DMO')
 9110 FORMAT(1X,I4,1X,F20.10,5X,F6.3,13X,F6.3)
 9120 FORMAT(/1X,' SPIN',2X,'OVERALL',28X,'WEIGHT IN',3X,'WEIGHT IN'/
     *        1X,'STATE',3X,'STATE',9X,'ENERGY',6X,'SPIN',6X,
     *           'MCSCF',8X,'DMO')
 9130 FORMAT(1X,I4,3X,I4,1X,F20.10,2X,F4.1,5X,F6.3,6X,F6.3)
 9140 FORMAT(1X,'.... DONE WITH SS-1PDM AND TDM ....')
 9150 FORMAT(/1X,'----USER PROVIDED $DFMVEC---')
 9160 FORMAT(/1X,'----TRANSFORMED (STANDARD ORIENTATION) $DIAVEC---')
 9170 FORMAT(/1X,'----TRANSFORMED (STANDARD ORIENTATION) $DPSVEC---')
 9180 FORMAT(/1X,'CHECK RUN HAS NOW FOUND ALL INPUT ORBITAL GROUPS,'/
     *        1X,'AND FINDS SUFFICIENT MEMORY TO GENERATE DMO''S,'/
     *        1X,'SO 3-FOLD AND 4-FOLD WAY STEPS ARE BEING SKIPPED.')
 9300 FORMAT(/1X,53(1H-)/
     *       1X,'  CATCH AND RELEASE (C-R) ALGORITHM IS APPLIED'/
     *       1X,'TO DOC (TYPE 2) CANDIDATES, BY THE',
     *          ' PRE-FOUR-FOLD WAY.'/
     *       1X,53(1H-)/
     *       1X,'DMO CHARACTERIZATION FOR THE MAXIMUM OVERLAP WITH',
     *          ' REFERENCE MO''S (MORMO)'/
     *       1X,'STEP, I.E. ACTIVE SPACE LABELS FOR ALL DMO''S:',
     *           ' (SEE KEYWORD MOSLAB)'/
     *       (5X,15I5))
 9310 FORMAT(1X,'# OF CANDIDATES MO FOR DOC BLOCK IS TOO SMALL'/
     *       1X,'NDOC CANDIDATES=',I4,' NDOC=',I4/
     *       1X,'CATCH & RELEASE ALGORITHM IS NOT APPLIED. CONTINUE')
 9320 FORMAT(1X,I5,' MOS ARE CAUGHT,',I5,' MOS ARE RELEASED.')
 9330 FORMAT(/1X,55(1H-)/
     *       1X,'APPLYING THE FOUR-FOLD WAY FOR VAL (TYPE 1)',
     *          ' CANDIDATES.'/
     *       1X,55(1H-)/
     *       1X,'DMO CHARACTERIZATION FOR THE MAXIMUM OVERLAP WITH',
     *          ' REFERENCE MO''S (MORMO)'/
     *       1X,'STEP, I.E. ACTIVE SPACE LABELS FOR ALL DMO''S:',
     *           ' (SEE KEYWORD MOSLAB)'/
     *       (5X,15I5))
 9350 FORMAT(/7X,'DMO''S HAVE NOW BEEN CREATED FROM',I4,' ACTIVE MOS:'/
     &       7X,' PRE-4-FOLD WAY FIXED',I4,' ACTIVE MOS    ($DPSVEC)'/
     &       7X,'     4-FOLD WAY FIXED',I4,' ACTIVE MOS    ($DIAVEC)'/
     &       7X,'DMO ORDERING FIXED BY',I4,' REFERENCE MOS ($DFMVEC)'/
     &       7X,'DMO''S DO NOT HAVE A DIAGONAL DENSITY MATRIX,',
     &          ' OF COURSE,'/
     &       7X,'BUT THEIR DENSITY''S DIAGONAL ELEMENTS,',
     *          ' PRINTED BELOW,'/
     &       7X,'ARE AN INDICATION OF THEIR OCCUPANCY.'//
     &       5X,36(1H-)/
     &       5X,'CAS-SCF DIABATIC MOLECULAR ORBITALS'/
     &       5X,'STATE AVERAGED "OCCUPANCIES" ARE SHOWN'/
     &       5X,36(1H-))
 9360 FORMAT(/1X,'CHECK RUN HAS NOW FOUND ANY REFERENCE CSF INPUT,'/
     *        1X,'AND FINDS SUFFICIENT MEMORY TO DO DIABATIZATION,'/
     *        1X,'SO THE DIABATIZAITON STEP IS BEING SKIPPED.')
 9370 FORMAT(/1X,'.... DONE PREPARING DIABATIC MOLECULAR ORBITALS ....')
 9400 FORMAT(/3X,'---- REGENERATING CAS-CI STATES OVER DMO''S ----'/)
 9410 FORMAT(/3X,'BEGINNING DIABATIZATION OF CAS-CI ADIABATIC STATES,'/
     *        7X,'WHICH WERE JUST REGENERATED USING THE DMO''S.'/)
 9420 FORMAT(/3X,'BEGINNING DIABATIZATION OF THE MCQDPT',
     *           ' ADIABATIC "STATES",'/
     *        7X,'PREPARED BY ROTATING THE DMO-BASED CAS-CI STATES'/
     *       13X,'BY THE QDPT 2ND ORDER STATE ROTATION.'/)
 9700 FORMAT(1X,'FREEING DISTRIBUTED STORAGE FOR',
     *          ' [OCC OCC|OCC OCC] INTEGRALS')
 9800 FORMAT(//1X,'ALAS, DETERMINANTS DON''T DO FINAL DIABATIZATION')
 9900 FORMAT(/1X,'..... FINISHED WITH ',A,' DIABATIZATION .....')
      END
C
C*MODULE DIAB    *DECK DIABINP
C>
C>    @brief   read $DIABAT input group
C>
C>    @details input reader for diabatic state preparation
C>
      SUBROUTINE DIABINP(NACT,NSTATE,NSTTOP)
C
C--   implicit double precision(a-h,o-z)
      IMPLICIT NONE
      DOUBLE PRECISION ALPHA_N, ALPHA_R, ALPHA_T,
     *                 CONV_TH, FACT, QNAMDIA, RNAMDIA,
     *                 SLCTTH, TH_DOC, TH_VIR, WBLOCK,
     *                 WSUM, ZERO
      INTEGER NACT, NSTATE, NSTTOP
      INTEGER I, IBTYP, IDAF, IJK, IJKT, IODA, IP,
     *        IPTIM, IR, IW, JRET1, KQNAMDIA, MASTER,
     *        MAX_ITER, ME, MOSLAB_CHARACT, MXDIABACT,
     *        NAV, NDFRM, NDLAP, NDMOSYM, NERR,
     *        NEXSTATE, NGRSTATE, NMLAP, NNAMDIA,
     *        NORIENT, NPROC, NRCSF, NSTDIAB,
     *        NSYMBOL_DOC, NSYMBOL_VAL, NSYMBOL_VIR
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL DMOSYM,REFMOS,REFGRP,ORIENT
C
      PARAMETER (MXDIABACT=30)
      COMMON /DIABAT/ ALPHA_N,ALPHA_R,ALPHA_T,
     *                TH_DOC,TH_VIR,SLCTTH,CONV_TH,WBLOCK(3),
     *                NDFRM,NDMOSYM,NRCSF,NMLAP,NDLAP,NORIENT,
     *                MOSLAB_CHARACT(MXDIABACT),
     *                MAX_ITER,NGRSTATE,NEXSTATE,NSTDIAB,
     *                NSYMBOL_DOC,NSYMBOL_VAL,NSYMBOL_VIR
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (NNAMDIA=19)
      DIMENSION QNAMDIA(NNAMDIA),KQNAMDIA(NNAMDIA)
      DATA RNAMDIA/8HDIABAT  /
      DATA QNAMDIA/8HDMOSYM  ,8HREFMOS  ,8HREFGRP  ,
     *             8HALPHAN  ,8HALPHAR  ,8HALPHAT  ,
     *             8HTHDOC   ,8HTHVIR   ,8HCONVTH  ,8HSLCTTH  ,
     *             8HMAXIT   ,8HNGRST   ,8HNDIAST  ,8HNEXST   ,
     *             8HMOSLAB  ,8HWBLOCK  ,
     *             8HNMLAP   ,8HNDLAP   ,8HORIENT  /
      DATA KQNAMDIA/3*0,  3*3,  4*3,  4*1,  -1,33,   1,1,0/
C
      DATA ZERO/0.0D+00/
C
C         --- Default values for $diabat input ---
C
      DMOSYM = .FALSE.
      REFMOS = .FALSE.
      REFGRP = .FALSE.
      ALPHA_N = 2.0D+00
      ALPHA_R = 1.0D+00
      ALPHA_T = 0.5D+00
      SLCTTH = 0.05D+00
      TH_DOC = 1.8D+00
      TH_VIR = 0.2D+00
      CONV_TH = 1.0D-06
      MAX_ITER = 200
C        next ones set silly, so we can apply defaults if not read in.
      NGRSTATE = -27
      NSTDIAB  = -27
      NEXSTATE = -27
      WBLOCK(1) = ZERO
      WBLOCK(2) = ZERO
      WBLOCK(3) = ZERO
C
      DO I=1,MXDIABACT
        MOSLAB_CHARACT(I) = 1
      END DO
C
      NMLAP  = 0
      NDLAP  = 0
      ORIENT = .FALSE.
C
      NSYMBOL_DOC = 2
      NSYMBOL_VAL = 1
      NSYMBOL_VIR = 0
C
C Read namelist $DIABAT
C
      KQNAMDIA(15) = 10*MXDIABACT + 1
C
      CALL NAMEIO(IR,JRET1,RNAMDIA,NNAMDIA,QNAMDIA,KQNAMDIA,
     *            DMOSYM,REFMOS,REFGRP,
     *            ALPHA_N,ALPHA_R,ALPHA_T,
     *            TH_DOC,TH_VIR,CONV_TH,SLCTTH,
     *            MAX_ITER,NGRSTATE,NSTDIAB,NEXSTATE,
     *            MOSLAB_CHARACT,WBLOCK,
     *            NMLAP,NDLAP,ORIENT,
     *                 0,0,0,0,0,
     *    0,0,0,0,0,   0,0,0,0,0,    0,0,0,0,0,   0,0,0,0,0,
     *    0,0,0,0,0,   0,0,0,0,0,    0,0,0,0,0,   0,0,0,0,0)
C
C         set default for block weights
C     there can be as many as three kinds of states,
C     a) NGRST tells how many states lie below those to be diabatized,
C        the default is none
C     b) the middle states are diabatized,
C        these are NSTATE - NGRST - NEXST total states.
C     c) NEXST tells how many states lie above those to be diabatized,
C        the default is states at the top with no weight in the MCSCF.
C
      IF(NGRSTATE.EQ.-27) NGRSTATE = 0
      IF(NSTDIAB .EQ.-27) NSTDIAB  = NSTTOP - NGRSTATE
      IF(NEXSTATE.EQ.-27) NEXSTATE = NSTATE - NGRSTATE - NSTDIAB
C
C        default for block weighting assigns equal weight
C        to every state, not including NEXSTATE.
C        This choice is the original HONDO+ behavior.
      WSUM = WBLOCK(1) + WBLOCK(2) + WBLOCK(3)
      IF(WSUM  .LE.  0.0001D+00) THEN
         FACT = 1.0D+00/(NGRSTATE+NSTDIAB)
         WBLOCK(1) = NGRSTATE*FACT
         WBLOCK(2) = NSTDIAB*FACT
         WBLOCK(3) = ZERO
      ELSE
         WBLOCK(1) = WBLOCK(1)/WSUM
         WBLOCK(2) = WBLOCK(2)/WSUM
         WBLOCK(3) = WBLOCK(3)/WSUM
      END IF
C
C Write all input parameters for diabatization
C
      IF(MASWRK) THEN
         WRITE(IW,9200) DMOSYM,REFMOS,REFGRP,NGRSTATE,WBLOCK(1),
     *                  NSTDIAB,WBLOCK(2),NEXSTATE,WBLOCK(3),
     *                  NSTATE,NSTTOP,
     *                  ALPHA_N,ALPHA_R,ALPHA_T,MAX_ITER,CONV_TH,
     *                  SLCTTH
         WRITE(IW,9210) NDLAP,NMLAP,ORIENT,
     *                  TH_DOC,TH_VIR,
     *                  (MOSLAB_CHARACT(I),I=1,NACT)
      END IF
C
C           Check some of the input parameters
C
      NERR=0
C
      IF(JRET1.EQ.2) THEN
         IF(MASWRK) WRITE(IW,9230)
         NERR=NERR+1
      END IF
C
      IF((NGRSTATE + NSTDIAB + NEXSTATE) .NE.  NSTATE) THEN
         IF(MASWRK) WRITE(IW,9240) NGRSTATE,NSTDIAB,NEXSTATE,
     *                             NSTATE,NSTTOP
         NERR=NERR+1
      END IF
C
      IF (NMLAP.GT.NACT  .OR.  NDLAP.GT.NACT) THEN
         IF(MASWRK) WRITE(IW,9250) NMLAP,NDLAP,NACT
         NERR=NERR+1
      END IF
C
      IF (NACT.GT.MXDIABACT) THEN
         IF(MASWRK) WRITE(IW,*) 'TOO LARGE ACTIVE SPACE. STOP'
         NERR=NERR+1
      END IF
C
      IF(NERR.GT.0) CALL ABRT
C
C          user-friendly F/T input propagates in coding as 0/1
C
                 NORIENT=0
      IF(ORIENT) NORIENT=1
                 NDMOSYM=0
      IF(DMOSYM) NDMOSYM=1
                 NDFRM=0
      IF(REFMOS) NDFRM=1
                 NRCSF=0
      IF(REFGRP) NRCSF=1
      RETURN
C
 9200 FORMAT(/5X,'======= INPUT VALUES OF $DIABAT ======='//
     *        1X,'PARAMETER FOR SYMMETRY OF DMOS:'/
     *        5X,'DMOSYM=',L8/
     *        1X,'PARAMETER FOR REFERENCE GEOMETRY MOS:'/
     *        5X,'REFMOS=',L8,' (IF TRUE, $DFMVEC INPUT REQUIRED)'/
     *        1X,'PARAMETER FOR DOMINANT CSF SELECTION'/
     *        5X,'REFGRP=',L8,' (IF TRUE, $REFCSF INPUT REQUIRED)'/
     *        1X,'PARAMETERS FOR ADIABATIC STATE SELECTION:'/
     *        5X,'  NGRST=',I8,'  WITH BLOCK WEIGHTING',F6.3,
     *           ' IN 3-FOLD''S NO TERM'/
     *        5X,' NDIAST=',I8,'  WITH BLOCK WEIGHTING',F6.3,
     *           ' IN 3-FOLD''S NO TERM'/
     *        5X,'  NEXST=',I8,'  WITH BLOCK WEIGHTING',F6.3,
     *           ' IN 3-FOLD''S NO TERM'/
     *       10X,'NOTE: MCSCF FOUND',I4,' STATES OF DESIRED SPIN.'/
     *       10X,'NOTE: MCSCF WEIGHTED THE FIRST',I4,' STATES.'/
     *        1X,'PARAMETERS FOR 3-FOLD WAY''S D3 FUNCTION'/
     *        6X,'SA-NO TERM',7X,'SS-ON TERM',7X,' TDM TERM'/
     *        5X,'ALPHAN=',F6.2,4X,'ALPHAR=',F6.2,4X,'ALPHAT=',F6.2/
     *        1X,'PARAMETERS FOR 3-FOLD-WAY OR 4-FOLD-WAY ITERS:'/
     *        5X,' MAXIT=',I8/
     *        5X,'CONVTH=',1P,E9.2,0P/
     *        1X,'REFERENCE STATE SELECTION THRESHOLD'/
     *        5X,'SLCTTH=',F5.3)
 9210 FORMAT(/5X,'PARAMETERS FOR FINE TUNING THE 4-FOLD WAY:'//
     *        1X,'NUMBER OF RESOLUTION MOS'/
     *        5X,' NDLAP=',I8,' (PRE-4-FOLD WAY STEP, USING $DPSVEC)'/
     *        5X,' NMLAP=',I8,'  (FOUR-FOLD WAY STEP, USING $DIAVEC)'/
     *        5X,'ORIENT=',L8,' (IF TRUE, PROVIDE $LCLDC IF NDLAP>0,',
     *                          ' $LCLVL IF NMLAP>0)'/
     *        1X,'IN CASE PRE-FOUR-FOLD WAY IS USED (NDLAP>0),'/
     *        1X,'ELECTRON OCCUPANCY THRESHOLDS TO SEPARATE FIL/',
     *           'DIF/VIR ACTIVE SPACE RESOLUTION'/
     *        5X,'> THDOC=',F6.3,'  WILL BE "DOC" PART',
     *           ' OF ACTIVE SPACE (IF PRE-4-FOLD)'/
     *        5X,'< THVIR=',F6.3,'  WILL BE "VIR" PART',
     *           ' OF ACTIVE SPACE (IF 4-FOLD)'/
     *        7X,'BETWEEN THESE IS THE "VAL" PART',
     *           ' OF ACTIVE SPACE.'/
     *        1X,'ACTIVE SPACE CHARACTERIZATION FOR THE FOUR-FOLD WAY:',
     *           ' (KEYWORD MOSLAB)'/
     *       (5X,15I5))
 9230 FORMAT(1X,'**** INPUT ERROR(S) DETECTED ****'/
     *       1X,'PLEASE FIX DIABATIZATION INPUT $DIABAT')
 9240 FORMAT(/1X,'*** ERROR ***'/
     *        1X,'NGRST=',I4,' NDIAST=',I4,' NEXST=',I4/
     *        1X,'SHOULD SUM TO TOTAL AVAILABLE STATES, NSTATE=',I4/
     *        1X,'NOTE THAT HIGHEST WEIGHTED STATE IN MCSCF WAS',I4)
 9250 FORMAT(1X,'*** ERROR ***'/
     *       1X,'# OF RESOLUTION ORBITALS IS TOO LARGE.'/
     *       1X,'NMLAP=',I4,' NDLAP=',I4,' BUT NACT=',I4)
      END
C
C*MODULE DIAB    *DECK MOSYMDIAB
      SUBROUTINE MOSYMDIAB(CISTEP,MOIRP,MOLAB,MODEG,Q,S,V,WRK,
     *                     MOSLAB_ACTIVE,NCORBS,NACT,L0,L1,L2,L3)
C--   implicit double precision(a-h,o-z)
      IMPLICIT NONE
C
      DOUBLE PRECISION CISTEP
      DOUBLE PRECISION ALDET, C1GROUP, CRIT, DWPARM, GLIST,
     *                 GRPDET, GUGA, PRTTOL, SDET, SPINS,
     *                 STSYM, SZDET, WSTATE
      INTEGER MOIRP, MOLAB, MODEG, Q, S, V, WRK, MOSLAB_ACTIVE,
     *        NCORBS, NACT, L0, L1, L2, L3
      INTEGER I, IA, IDAF, IDOCC, IDWEIGH, IEXCT, IGPDET,
     *        IJK, IJKT, IMCC, INTACT, IODA, IOUT, IP,
     *        IPURES, IR, IROOT, ISYM, IVAL, IW, IWTS,
     *        JCODE, KDET, KSTDET, KSTSYM, LEVNR, LEVPT,
     *        MAXP, MAXW1, MCORBS, MSYM, MXAO, MXRT, NA,
     *        NACTDET, NADET, NAV, NB, NBDET, NC, NCIDET,
     *        NCORDET, NCORSV, NFLGDM, NFOCI, NFTGCI,
     *        NITDET, NLCS, NLEVS, NORBDET, NORBMX,
     *        NORBS, NREFS, NSYM
C
      DIMENSION MOIRP(L1),MOLAB(L1),MODEG(L1),MOSLAB_ACTIVE(NACT),
     *          Q(L3),S(L2),V(L3),WRK(L1)
C
      PARAMETER (MXRT=100, MXAO=8192)
      LOGICAL NOSYM
C
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,SDET,SZDET,
     *                GRPDET,STSYM,GLIST,DWPARM,NFLGDM(MXRT),
     *                IWTS(MXRT),NCORSV,NCORDET,NACTDET,NORBDET,
     *                NADET,NBDET,KDET,KSTDET,IROOT,IPURES,MAXW1,NITDET,
     *                MAXP,NCIDET,IGPDET,KSTSYM,NFTGCI,IDWEIGH
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /ORBSET/ NORBMX,NORBS,MCORBS,NLEVS,NA,NB,NC,NSYM,MSYM,
     *                IDOCC,IVAL,IMCC,ISYM(MXAO),JCODE(MXAO),
     *                NLCS(MXAO),LEVPT(MXAO),LEVNR(MXAO),
     *                IOUT(MXAO),NREFS,IEXCT,NFOCI,INTACT
C
      DATA GUGA,ALDET/8HGUGA    ,8HALDET   /
      DATA C1GROUP/8HC1      /
C
C         get determinant code's symmetry numbers for DAF's current MOs
C
      NOSYM=.TRUE.
      IF(CISTEP.EQ.ALDET) NOSYM = GRPDET.EQ.C1GROUP
      IF(CISTEP.EQ.GUGA)  NOSYM = NSYM.EQ.1
C
      IF(NOSYM) THEN
         CALL C1DET(MOIRP,MOLAB,L0)
      ELSE
         CALL DAREAD(IDAF,IODA,V,L3,15,0)
         CALL DAREAD(IDAF,IODA,S,L2,12,0)
         CALL DAREAD(IDAF,IODA,Q,L3,45,0)
         CALL TRFSYM(MOLAB,MOIRP,MODEG,Q,S,V,WRK,IA,L0,L1,L0,L1)
      END IF
C
C  change orbital symmetry labels from GAMESS to JAKAL values
C
      IF(CISTEP.EQ.ALDET) CALL GAJASW(MOIRP,L1,GRPDET)
C
      DO I=1,NACT
         MOSLAB_ACTIVE(I) = MOLAB(I+NCORBS)
      ENDDO
      RETURN
      END
C
C*MODULE DIAB    *DECK GUGTDMX
      SUBROUTINE GUGTDMX(NCORBS,NACT,NBF,NSTATE,TDM,ENGY,IOPT)
C--   implicit double precision(a-h,o-z)
      IMPLICIT NONE
      DOUBLE PRECISION ENGY, TDM
      INTEGER IOPT, NACT, NBF, NCORBS, NSTATE
      DOUBLE PRECISION CHECK, EXETYP, RUNTYP, XX
      INTEGER IBTYP, IDAF20, IPTIM, L1, LACOEF, LAST,
     *        LCIVEC, LEVFRM, LIARC, LIMAIN, LINDX, LISEGM,
     *        LISUB, LISYM, LIUWKMN, LIUWKSB, LIWGHT, LJSEGM,
     *        LLEVNR, LLEVPT, LMAP, LMAPRV, LNABCB, LNLWKS,
     *        LNUWKS, LOADFM, LPUWK, LWORK, MASTER, ME,
     *        NEED, NEMEMX, NEMEMXDRT, NEVALS,
     *        NFT11, NFT12, NFT13, NFT14, NFT15, NFT16,
     *        NGLEVL, NHLEVL, NORBMX, NORBS, NPROC,
     *        NROWS, NROWS4, NSYM, NWKS
C
      DIMENSION TDM(NACT,NACT,NSTATE,NSTATE),ENGY(NSTATE)
C
      LOGICAL HEADER
      LOGICAL GOPARR,DSKWRK,MASWRK,SVDSKW
C
      COMMON /CIFILS/ NFT11,NFT12,NFT13,NFT14,NFT15,NFT16,IDAF20,NEMEMX
      COMMON /FMCOM / XX(1)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      DATA CHECK/8HCHECK   /
C
C        driver to obtain GUGA's DM and TDM matrices
C        If IOPT=0, the first -NSTATE- states are computed,
C                   even if they have no weight assigned.
C        If IOPT=1, states with non-zero weights are skipped,
C                   so the densities are for the first NSTATE
C                   states that actually have a weight.
C
      SVDSKW = DSKWRK
      DSKWRK = .FALSE.
C
      CALL SEQREW(NFT11)
      IF(MASWRK) READ(NFT11) NORBMX,NORBS,NSYM,NROWS,
     *                       NWKS,LEVFRM,NEMEMXDRT
      IF(GOPARR) THEN
         CALL DDI_BCAST(2156,'I',NROWS,1,MASTER)
         CALL DDI_BCAST(2157,'I',NWKS ,1,MASTER)
      END IF
      CALL SEQREW(NFT11)
C
      HEADER=.FALSE.  ! FTNCHEK THING
      IF(HEADER) WRITE(6,*) NORBMX,NORBS,NSYM,NROWS,
     *                      NWKS,LEVFRM,NEMEMXDRT
C
      NROWS4 = NROWS*4
      L1 = NBF
C
      CALL VALFM(LOADFM)
      LWORK   = LOADFM  + 1
      LINDX   = LWORK   + NACT*NACT
      LIARC   = LINDX   + NWKS
      LIWGHT  = LIARC   + NROWS4
      LNABCB  = LIWGHT  + NROWS4
      LNLWKS  = LNABCB  + NROWS
      LNUWKS  = LNLWKS  + NROWS
      LPUWK   = LNUWKS  + NROWS
      LMAP    = LPUWK   + NROWS
      LMAPRV  = LMAP    + L1
      LISYM   = LMAPRV  + L1
      LLEVNR  = LISYM   + L1
      LLEVPT  = LLEVNR  + L1
      LISEGM  = LLEVPT  + L1
      LJSEGM  = LISEGM  + L1
      LIMAIN  = LJSEGM  + L1
      LISUB   = LIMAIN  + L1
      LACOEF  = LISUB   + L1
      LIUWKMN = LACOEF  + L1
      LIUWKSB = LIUWKMN + L1
      LCIVEC  = LIUWKSB + L1
      LAST    = LCIVEC  + NSTATE*NWKS
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      IF(EXETYP.EQ.CHECK) THEN
         CALL VCLR(TDM,1,NACT*NACT*NSTATE*NSTATE)
         CALL VCLR(ENGY,1,NSTATE)
         GO TO 800
      END IF
C
      CALL GUGTDM(TDM,ENGY,IOPT,XX(LWORK),XX(LINDX),XX(LIARC),
     *            XX(LIWGHT),XX(LNABCB),XX(LNLWKS),XX(LNUWKS),
     *            XX(LPUWK),XX(LISYM),XX(LLEVNR),XX(LLEVPT),
     *            XX(LISEGM),XX(LJSEGM),XX(LIMAIN),XX(LISUB),
     *            XX(LACOEF),XX(LIUWKMN),XX(LIUWKSB),
     *            XX(LMAP),XX(LMAPRV),XX(LCIVEC),
     *            NCORBS,NACT,L1,NWKS,NROWS,NROWS4,NSTATE)
C
  800 CONTINUE
      DSKWRK=SVDSKW
      CALL RETFM(NEED)
      RETURN
      END
C
C*MODULE DIAB    *DECK GUGTDM
      SUBROUTINE GUGTDM(FULL_DM,ENGY,IOPT,WORK,INDX,IARC,IWGHT,
     *                  NABCB,NLWKS,NUWKS,PUWK,ISYM,LEVNR,LEVPT,
     *                  ISEGM,JSEGM,IMAIN,ISUB,ACOEF,IUWKMN,IUWKSB,
     *                  MAP,MAP_REV,CIVEC,
     *                  NCORBS,N_ACTIVE,L1,NWKS,NROWS,NROWS4,NSTATE)
C--   implicit double precision(a-h,o-z)
      IMPLICIT NONE
      DOUBLE PRECISION ACOEF, CIVEC, ENGY, FULL_DM, WORK
      INTEGER IARC, IMAIN, INDX, IOPT, ISEGM, ISUB, ISYM,
     *        IUWKMN, IUWKSB, IWGHT, JSEGM, L1, LEVNR,
     *        LEVPT, MAP, MAP_REV, NABCB, NCORBS, NLWKS,
     *        NROWS, NROWS4, NSTATE, NUWKS, NWKS, N_ACTIVE
      DOUBLE PRECISION ACOF, E1, E2, ECORE, EDFT, EDISP,
     *                 EELCT, EERD, EKIN, ENUCR, EPOT, ESCF,
     *                 ESTATE, ETOT, HALF, STATN, SZ, SZZ,
     *                 TITLE, TITLE1, VEE, VEN, WAVGGUGA
      INTEGER I, IAVGGUGA, IB, IBTYP, IDAF, IDAF20, IHAI,
     *        IJK, IJKT, IODA, IP, IPTIM, IR, IST, ISTAT,
     *        ISTATE, IUWK, IW, IWST, J, JB, JUWK, KSTAT,
     *        KSTATE, LDGUGA, LEVFRMDRT, MASTER, ME,
     *        MXRT, NAV, NAVGGUGA, NEMEMX, NEMEMXDRT,
     *        NFT11, NFT12, NFT13, NFT14, NFT15, NFT16,
     *        NLWK, NORBMXDRT, NORBS0, NORBSDRT, NPROC,
     *        NROWSDRT, NSTATECI, NSYMDRT, NUWK, NWKS0,
     *        NWKSCI, NWKSDRT
C
      PARAMETER (MXRT=100)
C
      LOGICAL AVGGUGA,HEADER
      LOGICAL GOPARR,MASWRK,DSKWRK
      INTEGER PUWK
C
      DIMENSION FULL_DM(N_ACTIVE,N_ACTIVE,NSTATE,NSTATE)
      DIMENSION WORK(N_ACTIVE,N_ACTIVE)
      DIMENSION INDX(NWKS)
      DIMENSION IARC(NROWS4),IWGHT(NROWS4)
      DIMENSION NABCB(NROWS),NLWKS(NROWS),NUWKS(NROWS),PUWK(NROWS)
      DIMENSION MAP(L1),ISYM(L1),LEVNR(L1),LEVPT(L1),MAP_REV(L1),
     *          ISEGM(L1),JSEGM(L1),IMAIN(L1),ISUB(L1),
     *          ACOEF(L1),IUWKMN(L1),IUWKSB(L1)
      DIMENSION CIVEC(NWKS,NSTATE),ENGY(NSTATE)
C
      DIMENSION TITLE(10),TITLE1(10)
C
      COMMON /CIFILS/ NFT11,NFT12,NFT13,NFT14,NFT15,NFT16,IDAF20,NEMEMX
      COMMON /DM2AVG/ WAVGGUGA(MXRT),IAVGGUGA(MXRT),NAVGGUGA,AVGGUGA
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /LOOPS1/ ACOF,NWKS0,NORBS0,IB,JB,IUWK,JUWK,NUWK,NLWK,
     *                IHAI,LDGUGA
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA HALF/0.5D+00/
C
C     generate state-specific densities and transition densities.
C
C     ----- READ HEADER RECORD OF CI VECTOR TAPE -----
C
      CALL SEQREW(NFT12)
      IF(MASWRK) READ(NFT12) NSTATECI,NWKSCI,TITLE,TITLE1
      IF(GOPARR) THEN
         CALL DDI_BCAST(2158,'I',NSTATECI,1,MASTER)
         CALL DDI_BCAST(2159,'I',NWKSCI  ,1,MASTER)
      END IF
      IF(NSTATE.GT.NSTATECI) THEN
         IF(MASWRK) WRITE(IW,*) 'GUGTDM: CI VECTOR FILE CONFUSION'
         CALL ABRT
      END IF
C
C     ----- READ -DRT- DATA -----
C
      CALL SEQREW(NFT11)
      IF(MASWRK) THEN
         READ(NFT11) NORBMXDRT,NORBSDRT,NSYMDRT,NROWSDRT,NWKSDRT,
     *               LEVFRMDRT,NEMEMXDRT
         READ(NFT11) TITLE
      END IF
      IF(GOPARR) THEN
         CALL DDI_BCAST(2155,'I',NWKSDRT ,1,MASTER)
         CALL DDI_BCAST(2156,'I',NORBSDRT,1,MASTER)
      END IF
      HEADER=.FALSE.  .AND.  MASWRK  ! FTNCHEK THING.
      IF(HEADER) WRITE(IW,*) NORBMXDRT,NORBSDRT,NSYMDRT,NROWSDRT,
     *                       NWKSDRT,LEVFRMDRT,NEMEMXDRT
C
      IF(NWKSDRT.NE.NWKSCI) GO TO 910
C
C     ----- READ REQUIRED -DRT- INFO -----
C
      IF(MASWRK) THEN
         READ (NFT11) MAP
         READ (NFT11) ISYM
         READ (NFT11) LEVNR
         READ (NFT11) LEVPT
         READ (NFT11)
         READ (NFT11) NABCB
         READ (NFT11)
         READ (NFT11) NLWKS
         READ (NFT11) NUWKS
         READ (NFT11) PUWK
         READ (NFT11) INDX
         READ (NFT11) IARC
         READ (NFT11) IWGHT
      END IF
      IF(GOPARR) THEN
         CALL DDI_BCAST(2161,'I',MAP  ,L1    ,MASTER)
         CALL DDI_BCAST(2162,'I',ISYM ,L1    ,MASTER)
         CALL DDI_BCAST(2163,'I',LEVNR,L1    ,MASTER)
         CALL DDI_BCAST(2164,'I',LEVPT,L1    ,MASTER)
         CALL DDI_BCAST(2165,'I',NABCB,NROWS ,MASTER)
         CALL DDI_BCAST(2166,'I',NLWKS,NROWS ,MASTER)
         CALL DDI_BCAST(2167,'I',NUWKS,NROWS ,MASTER)
         CALL DDI_BCAST(2168,'I',PUWK ,NROWS ,MASTER)
         CALL DDI_BCAST(2161,'I',INDX ,NWKS  ,MASTER)
         CALL DDI_BCAST(2162,'I',IARC ,NROWS4,MASTER)
         CALL DDI_BCAST(2163,'I',IWGHT,NROWS4,MASTER)
      END IF
C
      CALL SEQREW(NFT11)
C
C        ensure loop generator knows these two parameters
C
      NORBS0 = NORBSDRT
      NWKS0  = NWKS
C
C        read first CI vectors into memory, even if not weighted.
      IF(IOPT.EQ.0) THEN
         DO IST=1,NSTATE
            ENGY(IST) = ESTATE(IST)
            CALL SQREAD(NFT12,CIVEC(1,IST),NWKS)
         ENDDO
C
C        read CI vectors into memory, skip roots with no weight.
      ELSE
         IWST=1
         DO IST=1,NSTATECI
            IF(IAVGGUGA(IWST).EQ.IST  .AND.  IWST.LT.NSTATE) THEN
               ENGY(IWST) = ESTATE(IST)
               CALL SQREAD(NFT12,CIVEC(1,IWST),NWKS)
               IWST=IWST+1
            ELSE
               CALL SEQADV(NFT12)
            END IF
         ENDDO
         IF(IWST.LT.NSTATE) THEN
            IF(MASWRK) WRITE(IW,*) 'GUGTDM: TOO FEW ROOTS FROM DISK'
            CALL ABRT
         END IF
      END IF
C
      CALL SEQREW(NFT12)
C
C     learn how to unmap GUGA's orbital reordering.
C           (core orbitals not included)
C
      DO I=1,N_ACTIVE
        MAP_REV(MAP(I+NCORBS))=I
      END DO
C
C     -----           LOOP OVER STATE PAIRS            -----
C     upper triangular loop structure!
C     lower triangle is not computed, as it is the transpose.
C
      DO KSTAT=1,NSTATE
        DO ISTAT=KSTAT,NSTATE
C
C     ----- MAKE THE STATE-SPECIFIC OR TRANSITION DENSITY MATRIX -----
C
           CALL VCLR(WORK,1,N_ACTIVE*N_ACTIVE)
C
           ISTATE = ISTAT
           KSTATE = KSTAT
           CALL LOOPY1TDM(NABCB,IARC,NLWKS,NUWKS,PUWK,IWGHT,INDX,
     *                    ISEGM,JSEGM,IMAIN,ISUB,ACOEF,
     *                    IUWKMN,IUWKSB,ISYM,LEVPT,LEVNR,
     *                    NROWS,NROWS4,L1,
     *                    CIVEC(1,ISTATE),CIVEC(1,KSTATE),ISTATE,KSTATE,
     *                    WORK,NWKS,N_ACTIVE)
C
           CALL DSCAL(N_ACTIVE*N_ACTIVE,HALF,WORK,1)
           IF(ISTAT.NE.KSTAT) THEN
              DO I=1,N_ACTIVE
                 WORK(I,I) = WORK(I,I) + WORK(I,I)
              ENDDO
           END IF
C
C     ----- MAP BACK TO ORIGINAL ORBITAL ORDER -----
C     note that we only write istat<kstat to disk later,
C     storage is inefficient because determinant code
C     stores without exploiting the state symmetry.
C
           DO I=1,N_ACTIVE
              DO J=1,N_ACTIVE
                 FULL_DM(MAP_REV(I),MAP_REV(J),KSTAT,ISTAT)=WORK(I,J)
              ENDDO
           ENDDO
C
C     Generate the lower triangle over states by transposing AO indices.
C
           IF(ISTAT.NE.KSTAT) THEN
             DO I=1,N_ACTIVE
                DO J=1,N_ACTIVE
                   FULL_DM(J,I,ISTAT,KSTAT) = FULL_DM(I,J,KSTAT,ISTAT)
                ENDDO
             ENDDO
          END IF
C
        END DO
      END DO
      RETURN
C
  910 CONTINUE
      IF(MASWRK) WRITE(IW,9800) NWKSCI,NWKSDRT,TITLE,TITLE1
      CALL ABRT
      STOP
 9800 FORMAT(/5X,'GUGTDM: ERROR IN CI VECTOR TAPE AND DRT TAPE'/
     *        1X,'CI FILE HAS NWKS=',I10,' DRT FILE HAS NWKS=',I10/
     *        1X,'CI VECTOR FILE HAS TITLE:'/1X,10A8/
     *        1X,'DRT FILE       HAS TITLE:'/1X,10A8)
      END
C
C*MODULE DIAB    *DECK LOOPY1TDM
      SUBROUTINE LOOPY1TDM(NABC,IARC,NLWKS,NUWKS,PUWK,IWGHT,INDX,
     *                     ISEGM,JSEGM,IMAIN,ISUB,ACOEF,
     *                     IUWKMN,IUWKSB,ISYM,LEVPT,LEVNR,
     *                     NROWS,NROWS4,L1,
     *                     VEC1,VEC2,IST1,IST2,WORK_DM,NWKS,NACT)
C--   IMPLICIT double precision(a-h,o-z)
      IMPLICIT NONE
      DOUBLE PRECISION ACOEF, VEC1, VEC2, WORK_DM
      INTEGER IARC, IMAIN, INDX, ISEGM, IST1, IST2, ISUB,
     *        ISYM, IUWKMN, IUWKSB, IWGHT, JSEGM, L1,
     *        LEVNR, LEVPT, NABC, NACT, NLWKS, NROWS,
     *        NROWS4, NUWKS, NWKS
      DOUBLE PRECISION A, ACOF, CFS, COEFFS,
     *                 ONE, TWO, ZERO
      INTEGER I, IA, IAD, IARCMN, IARCSB, IARPT, IB, IDAF,
     *        IHAI, IJK, IJKT, IMN, IODA, IP, IR, IROW,
     *        ISB, ISEG, ISHIFT, IUWK, IW, J, JARPT, JB,
     *        JMN, JSB, JSEGNR, JSEGPT, JSM, JUWK, JXT,
     *        K, KMN, KSB, KSEG, KSEGMX, LDGUGA, LEV,
     *        LEVI, LEVL, LEVM, NAV, NLEVS, NLWK, NORBS,
     *        NPT, NR, NUWK, NWKS0, NXTSEG
C
C     ----- THIS ROUTINE IS A STRIPPED DOWN VERSION OF LOOPY -----
C     only one electron loops are computed,
C     total density is returned if state vectors are the same,
C     transition density is returned if these differ.
C
      INTEGER PUWK
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /LOOPS1/ ACOF,NWKS0,NORBS,IB,JB,IUWK,JUWK,NUWK,NLWK,
     *                IHAI,LDGUGA
C
      DIMENSION NABC(NROWS),IARC(NROWS4),NLWKS(NROWS),
     *          NUWKS(NROWS),PUWK(NROWS),IWGHT(NROWS4)
      DIMENSION INDX(NWKS)
      DIMENSION ISEGM(L1),JSEGM(L1),IMAIN(L1),ISUB(L1),
     *          ACOEF(L1),IUWKMN(L1),IUWKSB(L1),
     *          ISYM(L1),LEVPT(L1),LEVNR(L1)
      DIMENSION VEC1(NWKS),VEC2(NWKS)
      DIMENSION WORK_DM(NACT,NACT)
C
      DIMENSION ISHIFT(4)
C
      DIMENSION JSEGNR(3),JSEGPT(3),IARCMN(21),IARCSB(21)
      DIMENSION NXTSEG(21),JXT(21),JMN(21),JSB(21)
      DIMENSION COEFFS(20,5),CFS(100)
C
      EQUIVALENCE (COEFFS(1,1),CFS(1))
      EQUIVALENCE (JXT(1),NXTSEG(1))
      EQUIVALENCE (JMN(1),IARCMN(1))
      EQUIVALENCE (JSB(1),IARCSB(1))
C
      DATA JSEGNR /7,14,21/
      DATA JXT    /0,0,0,2,2,3,3,0,0,2,2,2,2,3,0,0,3,3,3,3,2/
      DATA JMN    /2,3,4,3,4,2,4,1,2,1,2,3,4,2,1,3,1,2,3,4,3/
      DATA JSB    /2,3,4,1,2,1,3,3,4,1,2,3,4,3,2,4,1,2,3,4,2/
      DATA ZERO   /0.0D+00/
      DATA ONE    /1.0D+00/
      DATA TWO    /2.0D+00/
C
      JSEGPT(1)=0
      DO 130 I=1,2
 130  JSEGPT(I+1)=JSEGNR(I)
      DO 135 I=1,2
      DO 135 J=1,5
 135  COEFFS(I,J)=ZERO
C
C     ----- THESE ARE THE POSSIBLE SEGMENT COEFFICIENTS -----
C
      DO 140 I=3,20
      A = I-2
      COEFFS(I,1)= ONE/A
      COEFFS(I,2)=-ONE/A
      COEFFS(I,3)=SQRT((A+ONE)/A)
      COEFFS(I,4)=SQRT(A/(A+ONE))
      COEFFS(I,5)=SQRT(A*(A+TWO))/(A+ONE)
 140  CONTINUE
      DO 150 K=1,4
      ISHIFT(K)=(K-1)*NROWS
 150  CONTINUE
      NLEVS=NORBS+1
C
C     ----- START THE MAIN LOOP -----
C
      DO 500 LEVI=2,NLEVS
      LEV=LEVI
      LEVM=LEV-1
      JSM=ISYM(LEVM)
      IAD=LEVM
      NR=LEVNR(LEV)
      NPT=LEVPT(LEV)
      DO 480 IROW=1,NR
      NPT=NPT+1
      ISEGM(LEV)=1
      ISEG=1
      IMN=NPT
      ISB=NPT
      KSEG=0
      KSEGMX=JSEGNR(ISEG)
      IUWKMN(LEV)=PUWK(NPT)
      IUWKSB(LEV)=PUWK(NPT)
      IMAIN(LEV)=NPT
      ISUB(LEV)=NPT
      NUWK=NUWKS(NPT)
      ACOEF(LEV)=ONE
C
C     ----- SEARCH FOR NEXT LOOP SEGMENT -----
C
 200  KSEG = KSEG + 1
      IF(KSEG.GT.KSEGMX) GO TO 440
      KMN = IARCMN(KSEG)
      IARPT = IMN + ISHIFT(KMN)
      KMN = IARC(IARPT)
      IF(KMN.EQ.0) GO TO 200
      KSB = IARCSB(KSEG)
      JARPT = ISB + ISHIFT(KSB)
      KSB = IARC(JARPT)
      IF(KSB.EQ.0) GO TO 200
      JSEGM(LEV) = KSEG
      IUWKMN(LEVM) = IUWKMN(LEV) + IWGHT(IARPT)
      IUWKSB(LEVM) = IUWKSB(LEV) + IWGHT(JARPT)
C
C      -----     HAVING FOUND A VALID SEGMENT    -----
C      ----- UPDATE THE VALUE OF THE COEFFICIENT -----
C
      GO TO (1,1,4,1,12,1,8,1,7,1,17,2,2,3,1,13,1,2,19,2,6), KSEG
C
   1  ACOEF(LEVM) = ACOEF(LEV)
      GO TO 20
   2  ACOEF(LEVM) = -ACOEF(LEV)
      GO TO 20
   3  IA=NABC(IMN)+2
      ACOEF(LEVM)=ACOEF(LEV)*CFS(IA)
      GO TO 20
   4  ACOEF(LEVM)=ACOEF(LEV)+ACOEF(LEV)
      GO TO 20
   6  IA=NABC(IMN)+24
      ACOEF(LEVM)=ACOEF(LEV)*CFS(IA)
      GO TO 20
   7  IA=NABC(IMN)+42
      ACOEF(LEVM)=ACOEF(LEV)*CFS(IA)
      GO TO 20
   8  IA=NABC(IMN)+43
      ACOEF(LEVM)=ACOEF(LEV)*CFS(IA)
      GO TO 20
   12 IA=NABC(IMN)+62
      ACOEF(LEVM)=ACOEF(LEV)*CFS(IA)
      GO TO 20
   13 IA=NABC(IMN)+63
      ACOEF(LEVM)=ACOEF(LEV)*CFS(IA)
      GO TO 20
   17 IA=NABC(IMN)+81
      ACOEF(LEVM)=ACOEF(LEV)*CFS(IA)
      GO TO 20
   19 IA=NABC(IMN)+83
      ACOEF(LEVM)=ACOEF(LEV)*CFS(IA)
      GO TO 20
   20 CONTINUE
      IF(NXTSEG(KSEG).GT.0) GO TO 400
      IF(ISYM(LEVM).NE.JSM)GO TO 200
      IF(KMN-KSB) 300,380,300
C
C     ----- UPDATE ALL VARIABLES FOR THE NEW SEGMENT -----
C
 300  LEVL=LEVM
      KSEGMX=4
 310  LEV=LEVM
      LEVM=LEV-1
      IF(LEVM.GT.0) GO TO 315
C
      WRITE(IW,313)
 313  FORMAT(1X,'LOOPY1TDM: PROBLEMS WITH PARTIAL SPACE')
      CALL ABRT
      STOP
C
 315  CONTINUE
      KSEG=0
      IMN=KMN
      IMAIN(LEV)=KMN
      ISB=KSB
      ISUB(LEV)=KSB
 320  KSEG = KSEG + 1
      IF(KSEG.GT.KSEGMX) GO TO 360
      IARPT = IMN + ISHIFT(KSEG)
      KMN = IARC(IARPT)
      IF(KMN.LE.0) GO TO 320
      JARPT = ISB + ISHIFT(KSEG)
      KSB = IARC(JARPT)
      IF(KSB.LE.0) GO TO 320
      JSEGM(LEV) = KSEG
      IMAIN(LEVM)=KMN
      IUWKMN(LEVM)=IUWKMN(LEV)+IWGHT(IARPT)
      ISUB(LEVM)=KSB
      IUWKSB(LEVM)=IUWKSB(LEV)+IWGHT(JARPT)
      IF(KMN-KSB) 310,340,310
C
C     -----             A LOOP HAS BEEN CONSTRUCTED             -----
C     ----- FIND ITS CONTRIBUTION AND ADD TO THE DENSTIY MATRIX -----
C
 340  IB = IAD
      JB = LEVL
      NLWK = NLWKS(KMN)
      IUWK = IUWKMN(LEVM)
      JUWK = IUWKSB(LEVM)
      ACOF = ACOEF(LEVL)
      CALL MAKETDM(VEC1,VEC2,IST1,IST2,INDX,WORK_DM,NACT,NWKS)
      GO TO 320
 360  IF(LEV.EQ.LEVL) GO TO 440
      LEVM=LEV
      LEV=LEVM+1
      IMN=IMAIN(LEV)
      ISB=ISUB(LEV)
      KSEG=JSEGM(LEV)
      GO TO 320
 380  IB = IAD
      JB = LEVM
      NLWK = NLWKS(KMN)
      IUWK = IUWKMN(LEVM)
      JUWK = IUWKSB(LEVM)
      ACOF = ACOEF(LEVM)
      CALL MAKETDM(VEC1,VEC2,IST1,IST2,INDX,WORK_DM,NACT,NWKS)
      GO TO 200
 400  CONTINUE
      LEV = LEVM
      LEVM = LEV - 1
      ISEG = NXTSEG(KSEG)
      ISEGM(LEV) = ISEG
      KSEG = JSEGPT(ISEG)
      IMN = KMN
      IMAIN(LEV) = KMN
      ISB = KSB
      ISUB(LEV) = KSB
      KSEGMX = JSEGNR(ISEG)
      GO TO 200
 440  CONTINUE
      IF(LEV.EQ.LEVI) GO TO 480
      LEVM = LEV
      LEV = LEVM + 1
      ISEG = ISEGM(LEV)
      IMN = IMAIN(LEV)
      ISB = ISUB(LEV)
      KSEG = JSEGM(LEV)
      KSEGMX = JSEGNR(ISEG)
      GO TO 200
 480  CONTINUE
 500  CONTINUE
      RETURN
      END
C
C*MODULE DIAB    *DECK MAKETDM
      SUBROUTINE MAKETDM(VEC1,VEC2,IST1,IST2,INDX,TEMP_DM,NACT,NWKS)
C--   IMPLICIT double precision(a-h,o-z)
      IMPLICIT NONE
      DOUBLE PRECISION TEMP_DM, VEC1, VEC2
      INTEGER INDX, IST1, IST2, NACT, NWKS
      DOUBLE PRECISION ACOEF, DC, ZERO
      INTEGER I, IB, IHAI, II, IND, IUWK, J, JB, JJ,
     *        JND, JUWK, LDGUGA, NLWK, NORBS, NUWK, NWKS0
C
      DIMENSION VEC1(NWKS),VEC2(NWKS),TEMP_DM(NACT,NACT),INDX(NWKS)
C
      COMMON /LOOPS1/ ACOEF,NWKS0,NORBS,IB,JB,IUWK,JUWK,NUWK,NLWK,
     *                IHAI,LDGUGA
      DATA ZERO/0.0D+00/
C
C     form state specific density or transition density matrix
C
      IND = IUWK
      JND = JUWK
      DC = ZERO
      DO I=1,NLWK
       II = INDX(IND)
       JJ = INDX(JND)
       DO J=1,NUWK
        DC = DC + VEC1(II) * VEC2(JJ)
        II = II + 1
        JJ = JJ + 1
       ENDDO
       IND = IND + 1
       JND = JND + 1
      ENDDO
C
      IF(IUWK.NE.JUWK) DC=DC+DC
C
      IF(IST1.EQ.IST2) THEN
         TEMP_DM(IB,JB) = TEMP_DM(IB,JB) + ACOEF * DC
         TEMP_DM(JB,IB) = TEMP_DM(JB,IB) + ACOEF * DC
         RETURN
      ELSE
         TEMP_DM(IB,JB) = TEMP_DM(IB,JB) + ACOEF * DC
      END IF
C
C         transition density needs to run the other way around,
C         but only for its off-diagonal elements.
C
      IF(IB.EQ.JB) RETURN
C                  ******
      IND=IUWK
      JND=JUWK
      DC=ZERO
C
      DO I=1,NLWK
         II=INDX(IND)
         JJ=INDX(JND)
         DO J=1,NUWK
            DC=DC+VEC2(II)*VEC1(JJ)
            II=II+1
            JJ=JJ+1
         END DO
         IND=IND+1
         JND=JND+1
      END DO
C
      IF (IUWK.NE.JUWK) DC=DC+DC
      TEMP_DM(JB,IB)=TEMP_DM(JB,IB) + ACOEF * DC
      RETURN
      END
C
C*MODULE DIAB    *DECK DETTDMX
      SUBROUTINE DETTDMX(NCORBS,NACT,NBF,NSTATE,TDM,ENGY,IOPT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION TDM(NACT,NACT,NSTATE,NSTATE),ENGY(NSTATE)
C
      PARAMETER (MXRT=100)
C
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,SDET,SZDET,
     *                GRPDET,STSYM,GLIST,DWPARM,NFLGDM(MXRT),
     *                IWTS(MXRT),NCORSV,NCORDET,NACTDET,NORBDET,
     *                NADET,NBDET,KDET,KSTDET,IROOT,IPURES,MAXW1,NITDET,
     *                MAXP,NCIDET,IGPDET,KSTSYM,NFTGCI,IDWEIGH
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      DATA CHECK/8HCHECK   /
C
C         --- driver for density and transition density computation ---
C            CI states must be from the determinant full CI program!
C        If IOPT=0, the first -NSTATE- states are computed,
C                   even if they have no weight assigned.
C        If IOPT=1, states with non-zero weights are skipped,
C                   so the densities are for the first NSTATE
C                   states that actually have a weight.
C        For both options, we filter out the spins we don't want.
C
C         Note that ORMAS-type CI states could be programmed, as a
C         routine akin to MATTD1 exists in the response eqn. code.
C
C         Recall that
C          ncidet      is number of determinants in this run
C          nstate      is number of states included in density calc.
C          nadet/nabet is alpha/beta e- count in this active space
C          ncorbs      is number of inert orbitals (filled)
C          nact        is number of active orbitals
C          nalp/nblp   is binomial value for this active space's dims
C
      NORBS = NCORBS + NACT
      NSYM = 2**IGPDET
      CALL VALFM(LOADFM)
      LIFA    = LOADFM  + 1
      CALL BINOM6(X(LIFA),NACT)
      CALL ASKIFA(X(LIFA),NACT,NADET,NBDET,NALP,NBLP)
      LIOX    = LIFA    + (NACT+1)**2
      LCIVEC  = LIOX    + MAX(NACT,NBF)
      LIACON1 = LCIVEC  + NCIDET*NSTATE
      LIBCON1 = LIACON1 + NADET + 43
      LIACON2 = LIBCON1 + NADET
      LIPOSA  = LIACON2 + NADET
      LIPERA  = LIPOSA  + NADET*(NACT-NADET)
      LIIND1  = LIPERA  + NADET*(NACT-NADET)
      LINDEX  = LIIND1  + NADET*(NACT-NADET)
      LISYMA  = LINDEX  + NACT*NACT
      LISYMB  = LISYMA  + NALP
      LISPA   = LISYMB  + NBLP
      LISPB   = LISPA   + NALP
      LISAS   = LISPB   + NBLP
      LISBS   = LISAS   + NSYM + 1
      LISAC   = LISBS   + NSYM + 1
      LISBC   = LISAC   + NALP
      LICOA   = LISBC   + NBLP
      LICOB   = LICOA   + NSYM
      LITAB   = LICOB   + NSYM
      LIMUL   = LITAB   + NSYM
      LAST    = LIMUL   + NSYM*NSYM
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      IF(EXETYP.EQ.CHECK) THEN
         CALL VCLR(TDM,1,NACT*NACT*NSTATE*NSTATE)
         CALL VCLR(ENGY,1,NSTATE)
         GO TO 800
      END IF
C
C        get CI vectors
C
      CALL RDDETCIVEC(X(LCIVEC),ENGY,NCIDET,NSTATE,IOPT)
C
C           next is prep work to use CAS-type determinant codes
C
      CALL DAREAD(IDAF,IODA,X(LIOX),NBF,262,1)
      CALL CORTRA(X(LIOX),NORBS,NCORBS)
      CALL SYMWRK(IW,X(LIOX),NACT,NADET,NBDET,IGPDET,KSTSYM,
     *            NSYM,NALP,NBLP,X(LIACON1),
     *            X(LISYMA),X(LISYMB),X(LICOA),X(LICOB),X(LITAB),
     *            X(LIMUL),X(LISPA),X(LISPB),X(LISAS),X(LISBS),
     *            X(LISAC),X(LISBC))
C
C          now generate both kinds of densities for determinant CAS-SCF
C
      CALL MATTD1(TDM,X(LCIVEC),NSTATE,NACT,NADET,NBDET,
     *            NCIDET,NALP,NBLP,X(LIFA),X(LIOX),NSYM,
     *            X(LIACON1),X(LIBCON1),X(LIACON2),
     *            X(LIPOSA),X(LIPERA),X(LIIND1),X(LINDEX),
     *            X(LISYMA),X(LISYMB),X(LISPA),X(LISPB),
     *            X(LISAS),X(LISBS),X(LISAC),X(LISBC))
C
  800 CONTINUE
      CALL RETFM(NEED)
      RETURN
      END
C
C*MODULE DIAB    *DEC ASKIFA
      SUBROUTINE ASKIFA(IFA,NACT,NA,NB,NALP,NBLP)
      DIMENSION IFA(0:NACT,0:NACT)
      NALP = IFA(NACT,NA)
      NBLP = IFA(NACT,NB)
      RETURN
      END
C
C*MODULE DIAB    *DECK RDDETCIVEC
      SUBROUTINE RDDETCIVEC(CIVEC,ENGY,NDET,NSTATE,IOPT)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION CIVEC(NDET,NSTATE),ENGY(NSTATE)
      LOGICAL GOPARR,DSKWRK,MASWRK,SVDSKW
      PARAMETER (MXRT=100)
      COMMON /CIFILS/ NFT11,NFT12,NFT13,NFT14,NFT15,NFT16,IDAF20,NEMEMX
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,SDET,SZDET,
     *                GRPDET,STSYM,GLIST,DWPARM,NFLGDM(MXRT),
     *                IWTS(MXRT),NCORSV,NCORDET,NACTDET,NORBDET,
     *                NADET,NBDET,KDET,KSTDET,IROOT,IPURES,MAXW1,NITDET,
     *                MAXP,NCIDET,IGPDET,KSTSYM,NFTGCI,IDWEIGH
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA ZERO/0.0D+00/
C
C     ----- Get CI vectors from file -----
C     We seek only NSTATE states, with an option to ignore those
C     with zero weight.  No more than NSTATE should be returned,
C     even if there are additional states on the vector file.
C     we also return the corresponding energy values.
C
      SVDSKW = DSKWRK
      DSKWRK = .FALSE.
      CALL SEQREW(NFT12)
      IF(MASWRK) READ(NFT12) NSTATES,NDETS
      IF(GOPARR) CALL DDI_BCAST(2150,'I',NSTATES,1,MASTER)
      IF(GOPARR) CALL DDI_BCAST(2151,'I',NDETS,1,MASTER)
C
      IF(NSTATES.LT.NSTATE .OR. NDETS.NE.NDET  .OR.
     *   NSTATES.NE.KDET   .OR. NDETS.NE.NCIDET) THEN
        IF(MASWRK) WRITE(IW,9360) NSTATES,NDETS,NSTATE,NDET,KDET,NCIDET
        CALL ABRT
      END IF
C
C         KDET is the total number of states actually solved for.
C         the logic below filters on spin value,
C         and maybe on state weight, if IOPT=1
C
      IF(IOPT.EQ.0) THEN
         NSTATES=0
         DO 100 IST=1,KDET
           IF(IPURES.EQ.1) THEN
              IF(ABS(SPINS(IST)-SDET) .GT. 0.03D+00) THEN
                CALL SEQADV(NFT12)
                GO TO 100
              END IF
           END IF
           NSTATES=NSTATES+1
           CALL SQREAD(NFT12,CIVEC(1,NSTATES),NDET)
           ENGY(NSTATES) = ESTATE(IST)
           IF(NSTATES.EQ.NSTATE) GO TO 300
  100    CONTINUE
      ELSE
         IWST = 0
         NSTATES = 0
         DO 150 IST=1,KDET
           IF(IPURES.EQ.1) THEN
              IF(ABS(SPINS(IST)-SDET) .GT. 0.03D+00) THEN
                CALL SEQADV(NFT12)
                GO TO 150
              END IF
              IWST = IWST + 1
           ELSE
              IWST = IWST + 1
           ENDIF
C
           IF(WSTATE(IWST).EQ.ZERO) THEN
              CALL SEQADV(NFT12)
           ELSE
              NSTATES = NSTATES + 1
              CALL SQREAD(NFT12,CIVEC(1,NSTATES),NDET)
              ENGY(NSTATES) = ESTATE(IST)
           ENDIF
           IF(NSTATES.EQ.NSTATE) GO TO 300
  150    CONTINUE
      END IF
C
  300 CONTINUE
      CALL SEQREW(NFT12)
      DSKWRK = SVDSKW
      RETURN
 9360 FORMAT(/1X,'***** ERROR IN -RDDETCIVEC- ROUTINE *****'/
     *       1X,'CI EIGENVECTOR FILE HAS DATA FOR NSTATE,NDET=',I3,I10/
     *       1X,'THIS ROUTINE CALLED ASKING FOR   NSTATE,NDET=',I3,I10/
     *       1X,'AND THE PRESENT CALCULATION IS   NSTATE,NDET=',I3,I10)
      END
C
C*MODULE DIAB    *DECK WRITETDM
      SUBROUTINE WRITETDM(NFT21,DEN,ENGY,NSTATE,NACT)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION DEN(NACT,NACT,NSTATE,NSTATE),ENGY(NSTATE)
      LOGICAL GOPARR,DSKWRK,MASWRK,SVDSKW,DEBUG
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C        output density and transition density matrices, as squares.
C            (toggle last part of -debug- to see 1PDM and 1TDM)
C
      DEBUG = MASWRK  .AND.  .FALSE.
C
      SVDSKW = DSKWRK
      DSKWRK = .FALSE.
      CALL SEQREW(NFT21)
C
      DO ISTAT=1,NSTATE
        DO JSTAT=ISTAT,NSTATE
           CALL SQWRIT(NFT21,DEN(1,1,ISTAT,JSTAT),NACT*NACT)
           IF(DEBUG) THEN
              IF(ISTAT.EQ.JSTAT) THEN
                 IF(MASWRK) WRITE(IW,9000) ISTAT,ENGY(ISTAT)
              ELSE
                 IF(MASWRK) WRITE(IW,9010) ISTAT,ENGY(ISTAT),
     *                                     JSTAT,ENGY(JSTAT)
              END IF
              CALL PRSQ(DEN(1,1,ISTAT,JSTAT),NACT,NACT,NACT)
           END IF
        ENDDO
      ENDDO
C
      CALL SEQREW(NFT21)
      DSKWRK = SVDSKW
      RETURN
 9000 FORMAT(1X,'STATE-SPECIFIC DENSITY MATRIX FOR STATE I=',I4,
     *          ' E=',F15.8)
 9010 FORMAT(1X,'TRANSITION DENSITY MATRIX BETWEEN STATE PAIR'/
     *       1X,'STATE I=',I4,' E=',F15.8,'  STATE J=',I4,' E=',F15.8)
      END
C
C*MODULE DIAB    *DECK READTDM
      SUBROUTINE READTDM(NFT,DM1,NSTATE,N_ACTIVE,NDMAT)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION DM1(N_ACTIVE,N_ACTIVE,NDMAT)
      LOGICAL GOPARR,DSKWRK,MASWRK,SVDSKW
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C This routine obtains the density matrices (DMs and TDM),
C reading only the upper triangle of state pair's TDM.
C Finally, a state averaged density is prepared.
C
C         Read the DM/TDM
C
      SVDSKW = DSKWRK
      DSKWRK = .FALSE.
      CALL SEQREW(NFT)
      LENDEN = N_ACTIVE*N_ACTIVE
      DO I=1,NDMAT-1
        CALL SQREAD(NFT,DM1(1,1,I),LENDEN)
      ENDDO
      CALL SEQREW(NFT)
      DSKWRK = SVDSKW
C
      CALL MKSTAVGDM1(DM1,NDMAT,N_ACTIVE,NSTATE)
C
      RETURN
      END
C
C*MODULE DIAB    *DECK MKSTAVGDM1
      SUBROUTINE MKSTAVGDM1(DM1,NDMAT,NACT,NSTATE)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION DM1(NACT,NACT,NDMAT)
      PARAMETER (MXDIABACT=30)
      COMMON /DIABAT/ ALPHA_N,ALPHA_R,ALPHA_T,
     *                TH_DOC,TH_VIR,SLCTTH,CONV_TH,WBLOCK(3),
     *                NDFRM,NDMOSYM,NRCSF,NMLAP,NDLAP,NORIENT,
     *                MOSLAB_CHARACT(MXDIABACT),
     *                MAX_ITER,NGRSTATE,NEXSTATE,NSTDIAB,
     *                NSYMBOL_DOC,NSYMBOL_VAL,NSYMBOL_VIR
      DATA ZERO/0.0D+00/
C
C        Prepare a state averaged density, using DMO's block weights.
C
      CALL VCLR(DM1(1,1,NDMAT),1,NACT*NACT)
C
      ISTDM=1
      DO ISTAT=1,NSTATE
        WTDIAB = ZERO
        IF(ISTAT.LE.NGRSTATE)         WTDIAB=WBLOCK(1)/NGRSTATE
        IF(ISTAT.GT.NGRSTATE)         WTDIAB=WBLOCK(2)/NSTDIAB
        IF(ISTAT.GT.NGRSTATE+NSTDIAB .AND. NEXSTATE.NE.0)
     *                                WTDIAB=WBLOCK(3)/NEXSTATE
        DO I=1,NACT
          DO J=1,NACT
            DM1(J,I,NDMAT) = DM1(J,I,NDMAT) + WTDIAB*DM1(J,I,ISTDM)
          END DO
        END DO
        ISTDM=ISTDM+NSTATE-ISTAT+1
      END DO
      RETURN
      END
C
C*MODULE DIAB    *DECK DFMSYMVEC
      SUBROUTINE DFMSYMVEC(NUM,N_ACTIVE,VEC,S,SMO,
     *                     TRI,EIGVEC,EIGVAL,WORK,IWORK)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,DEBUG
C
      PARAMETER (MXAO=8192)
C
      DIMENSION VEC(NUM,N_ACTIVE)      ! $DFMVEC'S DATA (INPUT)
      DIMENSION S(NUM*(NUM+1)/2)       ! AO OVERLAP (INPUT)
      DIMENSION SMO(N_ACTIVE,N_ACTIVE) ! MO OVERLAP
      DIMENSION TRI(*)                 ! TRIANGLE OF SIZE N_ACTIVE
      DIMENSION EIGVEC(N_ACTIVE,N_ACTIVE)
      DIMENSION EIGVAL(N_ACTIVE)
      DIMENSION WORK(N_ACTIVE,N_ACTIVE)
      DIMENSION IWORK(N_ACTIVE)
C
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA ZERO/0.0D+00/
C
C        This routine transforms the $DFMVEC to the
C            symmetrically orthogonalized one.
C
      DEBUG = MASWRK  .AND.  .FALSE.
C
C Calculate MO overlap matrix smo(j,i)=<j|i>
C
      DO I=1,N_ACTIVE
        DO J=1,N_ACTIVE
          DUM=ZERO
          DO K=1,NUM
            DO L=1,NUM
              IF (L.LE.K) THEN
                IND_KL=IA(K)+L
              ELSE
                IND_KL=IA(L)+K
              END IF
              DUM=DUM+VEC(K,I)*VEC(L,J)*S(IND_KL)
            END DO
          END DO
          SMO(I,J)=DUM
        END DO
      END DO
C
C Symmetric Orthogonalization of vec (by using overlap matrix -smo-)
C
      CALL DFMSYMORTH(VEC,SMO,N_ACTIVE,NUM,TRI,EIGVEC,EIGVAL,WORK,IWORK)
C
      IF(DEBUG) THEN
         IF(MASWRK) WRITE(IW,9700)
         CALL PRSQ(SMO,N_ACTIVE,N_ACTIVE,N_ACTIVE)
      END IF
      RETURN
C
 9700 FORMAT(/1X,'SYMMETRIC ORTHOGONALIZATION TRANSFORMATION OF',
     *       ' $DFMVEC IS:')
      END
C
C*MODULE DIAB    *DECK DFMSYMCHK
      SUBROUTINE DFMSYMCHK(NUM,N_ACTIVE,NQMT,MOSLAB,W,Q,S,TEMP,
     *                     MOSLAB_REF,STDPHASE)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      CHARACTER*8 DFMVEC
      LOGICAL STDPHASE
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION MOSLAB(N_ACTIVE)      ! IRREPS LABEL FOR ACTIVE MOS
      DIMENSION W(NUM*N_ACTIVE)       ! REF DMO/AO COEFFICIENT
      DIMENSION Q(NUM,NUM)            ! CANONICAL VEC
      DIMENSION S(NUM*(NUM+1)/2)      ! AO OVERLAP
      DIMENSION TEMP(NUM)             ! TEMPORARY REGION
      DIMENSION MOSLAB_REF(N_ACTIVE)  ! IRREPS LABELS FOR REF DMOS
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      DATA CHECK/8HCHECK   /
C
C This routine assign the irreps of $DFMVEC and check each irreps
C array component is same with current MOs or not.
C This procedure is necessary when DMO-based CI is carried out.
C
C Read $DFMVEC
C
      DFMVEC = ' $DFMVEC'
      IF(MASWRK) WRITE(IW,9000) DFMVEC
C
      CALL SEQREW(IR)
      CALL FNDGRP(IR,DFMVEC,IEOF)
      IF(IEOF.EQ.0) GO TO 20
C
      IF(MASWRK) WRITE(IW,*) 'CANNOT FIND $DFMVEC INPUT GROUP. STOP'
      CALL ABRT
C
   20 CONTINUE
      IF(MASWRK) THEN
         DO J=1,N_ACTIVE
            MAX=0
   30       CONTINUE
               MIN=MAX+1
               MAX=MAX+5
               IF (MAX.GT.NUM) MAX=NUM
               READ(IR,9810) (W(I+NUM*(J-1)),I=MIN,MAX)
            IF (MAX.LT.NUM) GO TO 30
          END DO
      END IF
      IF(GOPARR) CALL DDI_BCAST(2155,'F',W,NUM*N_ACTIVE,MASTER)
C
C Now all $DFMVEC data stored in w
C
      IF(STDPHASE) THEN
         IF(MASWRK) WRITE(IW,9001) DFMVEC,N_ACTIVE
         CALL STFASE(W,NUM,NUM,N_ACTIVE)
      END IF
C
C   Assign symmetry (irreps) for reference DMOs
C   and sort refernce DMOs by irreps with using moslab_ref
C
      CALL DAREAD(IDAF,IODA,Q,NUM*NUM,45,0)
      CALL SYMMOS(MOSLAB_REF,Q,S,W,TEMP,NQMT,NUM,N_ACTIVE,NUM)
C
      IF(EXETYP.EQ.CHECK) RETURN
C
C    Check symmetry label beween the current MOs and $DFMVEC for
C    active space
C
      DO I=1,N_ACTIVE
        IF (MOSLAB(I).NE.MOSLAB_REF(I)) THEN
          IF(MASWRK) THEN
             WRITE(IW,9200)
             WRITE(IW,9800) (MOSLAB(J),J=1,N_ACTIVE)
             WRITE(IW,9210)
             WRITE(IW,9800) (MOSLAB_REF(J),J=1,N_ACTIVE)
             WRITE(IW,*) 'STOP'
          END IF
          CALL ABRT
        END IF
      END DO
      RETURN
C
 9000 FORMAT(/1X,'READING REFERENCE GEOMETRY''S',A8,
     *           ' ORBITAL INPUT GROUP')
 9001 FORMAT(1X,'ADJUSTING',A8,' TO STANDARD PHASE:',I4,' ORBS.')
 9800 FORMAT(1X,15A5)
 9810 FORMAT(5X,5E15.8)
 9200 FORMAT(/10X,'**** ERROR ****'/
     *        1X,'$DFMVEC IRREP ORDERING IS DIFFERENT FROM THE'/
     *        1X,'THE ORDERING OF MOS FROM THIS RUN''S MCSCF.'/
     *        1X,'SYMMETRY LABELS FOR THE ACTIVE MCSCF ORBITALS:')
 9210 FORMAT(1X,'SYMMETRY LABELS FOR THE ACTIVE $DFMVEC ORBITALS:')
      END
C
C*MODULE DIAB    *DECK DFMSYMORTH
      SUBROUTINE DFMSYMORTH(VEC,S,NVEC,NUM,TRI,EIGVEC,EIGVAL,WORK,IWORK)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION VEC(NUM,NVEC)
      DIMENSION S(NVEC,NVEC)
      DIMENSION TRI(*),EIGVEC(NVEC,NVEC),EIGVAL(NVEC)
      DIMENSION WORK(NVEC,NVEC),IWORK(NVEC)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA  ZERO /0.0D+00/
      DATA  ONE  /1.0D+00/
      DATA  ERR_TH /1.0D-04/
C
C This routine calculate symmetric orthogonal vectors and determine
C sign of vectors as they agree with original vectors.
C
C nvec ....   total number of vectors to orthogonalize
C num  ....   dimension of vector
C s(i,j) .... overlap matrix between i-th vector and j-th.
C             Assumed that full matrix elements are stored. (input)
C             Return as transformation (sym. orthogonalized) matrix
C vec(*,i)... on entry, the $DFMOVEC orbitals.
C             Return as the symmetric orthonormalized vector.
C tri,eigvec,eigval ... diagonalization work spaces
C work,iwork .... scratch spaces
C
C
C          S^{-1/2} = U*diag(s^{-1/2})*U^{t}
C          first, diagonalize S in MO space...
C
      CALL CPYSQT(S,TRI,NVEC,1)
      CALL JACDG(TRI,EIGVEC,EIGVAL,IWORK,WORK,NVEC,NVEC)
      DO I=1,NVEC
        IF (EIGVAL(I).LT.ERR_TH) THEN
          IF(MASWRK) THEN
           WRITE(IW,*) 'DFMSYMORTH: CANNOT SYMMETRIC/ORTHOGONALIZE,'
           WRITE(IW,*) 'OVERLAP MATRIX TURNED OUT TO BE SINGULAR.'
           END IF
          CALL ABRT
        END IF
        EIGVAL(I)=ONE/SQRT(EIGVAL(I))
      END DO
C
C       generate  S^{-1/2} = (T*eigval**(-1/2))*T-dagger
C       S^{-1/2} overwrites array S
C
      DO I=1,NVEC
        DO J=1,NVEC
          WORK(I,J) = EIGVEC(I,J)*EIGVAL(J)
        END DO
      END DO
      CALL DGEMM('N','T',NVEC,NVEC,NVEC,ONE,WORK,NVEC,
     *           EIGVEC,NVEC,ZERO,S,NVEC)
C
C Check phase of each column
C
      DO J=1,NVEC
        IF (S(J,J).LT.ZERO) THEN
          DO I=1,NVEC
            S(I,J)=-S(I,J)
          END DO
        END IF
      END DO
C
C do symmetric orthogonalization of -vec- overwriting orig $DFMOVEC
C       VEC = VEC * S^(-1/2)
C
      CALL DCOPY(NUM*NVEC,VEC,1,EIGVEC,1)
      CALL DGEMM('N','N',NUM,NVEC,NVEC,ONE,EIGVEC,NUM,
     *            S,NVEC,ZERO,VEC,NUM)
      RETURN
      END
C
C*MODULE DIAB    *DECK REFDMOSYM
      SUBROUTINE REFDMOSYM(N_RES,NQMT,NUM,W,Q,S,TEMP,TRANS,MOSLAB_REF,
     *                     VECWRD,FRWRD,NATOM,NORIENT,STDPHASE)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      CHARACTER*8 VECWRD,FRWRD
      CHARACTER*8 CHARATM
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL STDPHASE
C
      DIMENSION W(NUM,N_RES)         ! REF DMO/AO COEFFICIENT
      DIMENSION Q(NUM,NUM)           ! CANONICAL VEC
      DIMENSION S(NUM*(NUM+1)/2)     ! AO OVERLAP
      DIMENSION TEMP(NUM)            ! TEMPORARY REGION
      DIMENSION TRANS(3,3,NATOM)
      DIMENSION MOSLAB_REF(N_RES)
C
      DIMENSION KCART(7)
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXAO=8192, MXATM=2000)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
C
      DATA ZERO,ONE /0.0D+00,1.0D+00/
      DATA TH_ZERO /1.0D-03/
C
C Function: (1) transform ref or pseudo ref MO coef from specified
C               orientation by input to the current standard orientation
C               (i.e. coordinates of $BASIS)  for each atom
C        Then
C           (2) assign the irreps of the reference DMOs and
C               make label (moslab_ref) then return it.
C
C Note: current version transform MO coefs of only p type.
C     : for d,f... type are eliminated!
C
C natom... # of total atoms
C label_type(i,j) ... j-th atom's i-th AO's label
C label2.... data set of labels like s, px,....
C w     .... ref or pseudo ref MO coef of (specific orientation:input)
C                          (current standard orientation:output)
C
C        Read -VECWRD- group (either $DIAVEC or $DPSVEC)
C
      IF(MASWRK) WRITE(IW,9000) VECWRD
C
      CALL SEQREW(IR)
      CALL FNDGRP(IR,VECWRD,IEOF)
C
      IF(IEOF.GT.0) THEN
         IF(MASWRK) WRITE(IW,9020) VECWRD
         CALL ABRT
      END IF
C
      IF(MASWRK) THEN
         DO J=1,N_RES
           MAX=0
   30      CONTINUE
              MIN=MAX+1
              MAX=MAX+5
              IF (MAX.GT.NUM) MAX=NUM
              READ(IR,9810) (W(I,J),I=MIN,MAX)
              IF (MAX.LT.NUM) GO TO 30
         END DO
      END IF
      IF(GOPARR) CALL DDI_BCAST(2156,'F',W,NUM*N_RES,MASTER)
C
C    Now all reference (or pseudo) MO coeffcients are stored in -W-
C
      IF(STDPHASE) THEN
         IF(MASWRK) WRITE(IW,9001) VECWRD,N_RES
         CALL STFASE(W,NUM,NUM,N_RES)
      END IF
C
C    If orienting the coordinates,
C    Read -FRWRD- input group, either $LCLDC or $LCLVL as apprpriate,
C    then transform ref (pseudo ref) MO coeffs sequentially
C
C    if there is no specific orientation, (if norient=0)
C    then use the current standard orientation)
C
      IF (NORIENT.NE.0) THEN
         CALL SEQREW(IR)
         CALL FNDGRP(IR,FRWRD,IEOF)
C
         IF(IEOF.GT.0) THEN
            IF(MASWRK) WRITE(IW,9030) FRWRD
            CALL ABRT
         ELSE
            IF(MASWRK) WRITE(IW,9035) VECWRD,FRWRD
         END IF
C
C                  loop over ref (pseudo ref) MOs
C
         DO IORB=1,N_RES
C                  -- this orbital's desired rotation --
            DO I=1,NATOM
             IF(MASWRK) THEN
               READ(IR,*) CHARATM,TRANS(1,1,I),TRANS(2,1,I),TRANS(3,1,I)
               READ(IR,*)         TRANS(1,2,I),TRANS(2,2,I),TRANS(3,2,I)
               READ(IR,*)         TRANS(1,3,I),TRANS(2,3,I),TRANS(3,3,I)
               READ(UNIT=CHARATM,FMT='(A8)') ANAM_RD
C                      -- check-(1)--
               IF (ANAM_RD.NE.ANAM(I)) THEN
                 WRITE(IW,9040) FRWRD,I,CHARATM,I,FRWRD,ANAM(I)
                 CALL ABRT
               END IF
             END IF
            END DO
            IF(GOPARR) CALL DDI_BCAST(2157,'F',TRANS,3*3*NATOM,MASTER)
C                      -- check (2)--
            DO I=1,NATOM
               DUM1=TRANS(1,1,I)**2+TRANS(2,1,I)**2+TRANS(3,1,I)**2
               DUM2=TRANS(1,2,I)**2+TRANS(2,2,I)**2+TRANS(3,2,I)**2
               DUM3=TRANS(1,3,I)**2+TRANS(2,3,I)**2+TRANS(3,3,I)**2
               DUM12=TRANS(1,1,I)*TRANS(1,2,I)
     &              +TRANS(2,1,I)*TRANS(2,2,I)
     &              +TRANS(3,1,I)*TRANS(3,2,I)
               DUM23=TRANS(1,2,I)*TRANS(1,3,I)
     &              +TRANS(2,2,I)*TRANS(2,3,I)
     &              +TRANS(3,2,I)*TRANS(3,3,I)
               DUM31=TRANS(1,3,I)*TRANS(1,1,I)
     &              +TRANS(2,3,I)*TRANS(2,1,I)
     &              +TRANS(3,3,I)*TRANS(3,1,I)
               DUM1=ABS(ONE-DUM1)
               DUM2=ABS(ONE-DUM2)
               DUM3=ABS(ONE-DUM3)
               DUM12=ABS(DUM12)
               DUM23=ABS(DUM23)
               DUM31=ABS(DUM31)
               IF ((DUM1.GT.TH_ZERO).OR.(DUM2.GT.TH_ZERO).OR.
     &             (DUM3.GT.TH_ZERO).OR.(DUM12.GT.TH_ZERO).OR.
     &             (DUM23.GT.TH_ZERO).OR.(DUM31.GT.TH_ZERO) ) THEN
         IF(MASWRK) THEN
           WRITE(IW,*)'$LCLDC/VL MUST BE ORTHOGONAL UNIT VECTORS'
           WRITE(IW,*) 'ERROR IN ',I,' TH UNIT VECTOR'
           WRITE(IW,*) 'NORM', DUM1,DUM2,DUM3
           WRITE(IW,*) 'ORTHO', DUM12,DUM23,DUM31
         END IF
               CALL ABRT
               END IF
            END DO
C
C   transform MO coef based on the current standard orientation
C   from the specified orientation (p-type only!!)
C
            KCART(1)=1
            DO I=2,7
               KCART(I) = KCART(I-1) + I
            ENDDO
C
            INDAO=0
            DO ISH=1,NSHELL
               IATOM=KATOM(ISH)
               NUMGTO = KCART(KTYPE(ISH))
C                S shells are left alone (no rotation for round stuff)
C                we rotate only the P part of L shells
C                shells higher than P are just wiped out!
               IF(KTYPE(ISH).EQ.2) THEN
                  IF(KMIN(ISH).EQ.1) INDAO=INDAO+1  ! IF L SHELL
                  COEF_X=W(INDAO+1,IORB)
                  COEF_Y=W(INDAO+2,IORB)
                  COEF_Z=W(INDAO+3,IORB)
                  W(INDAO+1,IORB)=TRANS(1,1,IATOM)*COEF_X
     &                           +TRANS(1,2,IATOM)*COEF_Y
     &                           +TRANS(1,3,IATOM)*COEF_Z
                  W(INDAO+2,IORB)=TRANS(2,1,IATOM)*COEF_X
     &                           +TRANS(2,2,IATOM)*COEF_Y
     &                           +TRANS(2,3,IATOM)*COEF_Z
                  W(INDAO+3,IORB)=TRANS(3,1,IATOM)*COEF_X
     &                           +TRANS(3,2,IATOM)*COEF_Y
     &                           +TRANS(3,3,IATOM)*COEF_Z
               END IF
               IF(KTYPE(ISH).GT.2) THEN
                  DO IGTO=1,NUMGTO
                     W(INDAO+IGTO,IORB)=ZERO
                  ENDDO
               END IF
               INDAO = INDAO + NUMGTO
            END DO
         END DO  ! LOOP END OF REF (PSEUDO REF) MOS
      END IF  ! END IF OF ORIENTATION USE
C
C       -- Assign symmetry (irreps) for MOs
C
      CALL DAREAD(IDAF,IODA,Q,NUM*NUM,45,0)
      CALL SYMMOS(MOSLAB_REF,Q,S,W,TEMP,NQMT,NUM,N_RES,NUM)
      RETURN
C
 9000 FORMAT(/1X,'READING',A8,' RESOLUTION ORBITAL INPUT GROUP')
 9001 FORMAT(1X,'ADJUSTING',A8,' TO STANDARD PHASE:',I4,' ORBS.')
 9810 FORMAT(5X,5E15.8)
 9020 FORMAT(1X,'*** ERROR ***'/
     *       1X,'UNABLE TO FIND REQUIRED INPUT ORBITALS IN',A8,
     *          ' GROUP.')
 9030 FORMAT(1X,'*** ERROR ***'/
     *       1X,'UNABLE TO FIND REQUIRED ORIENTATION INFO IN',
     *          A8,' GROUP.')
 9035 FORMAT(1X,'ORIENTATION INPUT FOR',A,
     *          ' IS TAKEN FROM THE',A,' GROUP.')
 9040 FORMAT(1X,'*** ERROR ***'/
     *       1X,'ATOMIC ORDER IS DIFFERENT BETWEEN $DATA AND',A8/
     *       1X,'ATOM',I5,' IN DATA=',A8/
     *       1X,'ATOM',I5,' IN',A8,'=',A8)
      END
C
C*MODULE DIAB    *DECK THREEFOLD
      SUBROUTINE THREEFOLD(ALPHA_N,ALPHA_R,ALPHA_T,CONV_TH,MAX_ITER,
     &                     NSTATE,NUM,N_ACTIVE,MOSLAB_ACTIVE,
     &                     AVOCC_ACT,DM1,V,TEMP,U,NDMAT,STDPHASE)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL STDPHASE
C
      DIMENSION MOSLAB_ACTIVE(N_ACTIVE)
      DIMENSION DM1(N_ACTIVE,N_ACTIVE,NDMAT)
      DIMENSION V(NUM,N_ACTIVE)
      DIMENSION AVOCC_ACT(N_ACTIVE)
      DIMENSION TEMP(NUM,N_ACTIVE)
      DIMENSION U(N_ACTIVE,N_ACTIVE)   ! WORKING STORAGE HERE.
C
      PARAMETER (MXDIABACT=30)
      DIMENSION INDMO_MIX(MXDIABACT)
      DIMENSION MSEGMENT(MXDIABACT)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,DEBUG
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA ZERO,ONE/0.0D+00,1.0D+00/
C
C This routine carry out the threefold density criterion
C and determine the MO/base transformation matrix.
C
C The input MOs are transformed by the threefold density criterion
C and returned as output
C Also all DM are transformed then return.
C
C num  .... number of basis set (AO)
C n_active ... number of the active MOs
C
C v  ... MO vec (active) : return as updated (threefold density's) MO
C dm1 ... Density matrices (including transition DM and SA-DM)
C (DM are stored as (11),(12),...(1 nstate),(22),(23),.... )
C u  ... MO/base transformation matrix
C moslab_active .... irreps label of the active MOs
C
C msegment(i).... number (dimension) of the i-th block to be mixed
C indmo_mix ... indmo_mix(1:msegment(1))=MO index to be mixed for the
C                                        threefold density criterion
C indmo_mix(msegment(1)+1:msegment(1)+msegment(2))=MO index of the
C                                        next block
C               ....
C                       where n_block (<n_active) is total # of block
C                      (defined bellow)
C
C     Toggle last part of -debug- to see 3-fold way orbitals!
C
      DEBUG = MASWRK  .AND.  .FALSE.
C
C Define the block to mixing MOs for the threefold density criterion
C based on irreps (by using moslab_active)
C
      CALL MKMOIND1(N_ACTIVE,MOSLAB_ACTIVE,INDMO_MIX,MSEGMENT,N_BLOCK)
C
C Carry out the threefold density criterion to the all active space
C and determine MO/base transformation matrix U
C The MOs to be applied for the threefold density criterion
C and to be mixed with each others are already defined by indmo_mix
C and msegment.
C
C           Initialization of U (i.e. unit matrix)
C
      DO I=1,N_ACTIVE
        DO J=1,N_ACTIVE
          U(J,I)=ZERO
        END DO
      END DO
      DO I=1,N_ACTIVE
        U(I,I)=ONE
      END DO
C
C           threefold density criterion
C
      CALL MAX_D3(ALPHA_N,ALPHA_R,ALPHA_T,CONV_TH,MAX_ITER,NSTATE,
     &            N_ACTIVE,N_BLOCK,INDMO_MIX,MSEGMENT,DM1,NDMAT,
     &            U,AVOCC_ACT)
C
C Transform the MO coefficients of the new MO by using the matrix U
C
      IF(DEBUG) THEN
         IF(MASWRK) WRITE(IW,*) 'THE COMPLETED THREE-FOLD ROTATION IS'
         CALL PRSQ(U,N_ACTIVE,N_ACTIVE,N_ACTIVE)
      END IF
C
      CALL DGEMM('N','N',NUM,N_ACTIVE,N_ACTIVE,ONE,V,NUM,U,N_ACTIVE,
     &            ZERO,TEMP,NUM)
C
      DO I=1,N_ACTIVE
        DO J=1,NUM
          V(J,I)=TEMP(J,I)
        END DO
      END DO
C
      IF(STDPHASE) THEN
         IF(MASWRK) WRITE(IW,9001) N_ACTIVE
         CALL STFASE(V,NUM,NUM,N_ACTIVE)
      END IF
C
      IF(DEBUG) THEN
         IF(MASWRK) WRITE(IW,*) 'THE THREE-FOLD WAY PRODUCES THESE DMOS'
         CALL PRSQ(V,N_ACTIVE,NUM,NUM)
      END IF
C
      RETURN
 9001 FORMAT(1X,'ADJUSTING',I5,
     *          ' THREE-FOLD WAY ORBITALS TO STANDARD PHASE')
      END
C
C*MODULE DIAB    *DECK MKMOIND1
      SUBROUTINE MKMOIND1(N_ACTIVE,MOSLAB_ACTIVE,INDMO_MIX,MSEGMENT,
     &                    N_BLOCK)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION MOSLAB_ACTIVE(N_ACTIVE)
      DIMENSION INDMO_MIX(N_ACTIVE)
      DIMENSION MSEGMENT(N_ACTIVE)
C
      PARAMETER (MXDIABACT=30)
      DIMENSION ITEMP(MXDIABACT)
C
C This routine makes index arrays that define the "mixing block"
C of the active MOs to apply the simle threefold density criterion,
C i.e., the blocks are defined by only the irreps label.
C
C n_active ... number of the active MOs (input and output)
C n_block  ... number of the blocks (output)
C moslab_active ... irreps label
C
C msegment(i).... number (dimension) of the i-th block to be mixed
C
C indmo_mix ... indmo_mix(1:msegment(1))=MO index to be mixed for the
C                                        threefold density criterion
C indmo_mix(msegment(1)+1:msegment(1)+msegment(2))=MO index of the
C                                        next block
C               ....
C                       where n_block (<n_active) is total # of block
C                      (defined bellow)
C
       DO I=1,N_ACTIVE
         ITEMP(I)=MOSLAB_ACTIVE(I)
       END DO
C
       ICOUNT=0
       ISHIFT=0
       DO I=1,N_ACTIVE ! THIS LOOP IS CORRELATED TO PICKING UP ONE-BLOCK
         IF (ITEMP(I).EQ.0) GO TO 100  ! SKIP 0 IS DUMMY VALUE
         ICOUNT=ICOUNT+1
         IDUMLAB=ITEMP(I)
         JCOUNT=0
         DO J=1,N_ACTIVE ! THIS LOOP IS CORRELATED TO DETERMINATION OF
                         ! THE MEMBERS OF THE ABOVE ONE-BLOCK
           IF (ITEMP(J).EQ.IDUMLAB) THEN
             JCOUNT=JCOUNT+1
             INDMO_MIX(JCOUNT+ISHIFT)=J
             ITEMP(J)=0 ! REPLACE TO NULL VALUE FOR THE LOOP OF I
           END IF
         END DO
         MSEGMENT(ICOUNT)=JCOUNT
         ISHIFT=ISHIFT+MSEGMENT(ICOUNT)
100      CONTINUE
       END DO
C
       N_BLOCK=ICOUNT
C
       RETURN
       END
C
C*MODULE DIAB    *DECK MAX_D3
      SUBROUTINE MAX_D3(ALPHA_N,ALPHA_R,ALPHA_T,CONV_TH,MAX_ITER,
     &         NSTATE,N_ACTIVE,N_BLOCK,INDMO_MIX,MSEGMENT,DM1,NDMAT,
     &         U,AVOCC_ACT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION INDMO_MIX(N_ACTIVE)
      DIMENSION MSEGMENT(N_ACTIVE)
      DIMENSION U(N_ACTIVE,N_ACTIVE)
      DIMENSION DM1(N_ACTIVE,N_ACTIVE,NDMAT)
      DIMENSION AVOCC_ACT(N_ACTIVE)
C
      PARAMETER (MXDIABACT=30)
      DIMENSION TEMP1(MXDIABACT)
      DIMENSION TEMP2(MXDIABACT)
      DIMENSION TEMP3(MXDIABACT)
      DIMENSION TEMP4(MXDIABACT)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA ZERO/0.0D+00/
      DATA PT25/0.25D+00/
C
C This routine maximize the D3 function of the threefold density
C criterion and determine MO/base transformatiom matrix.
C Also density matrices are updated.
C The restriction of MOs to be mixed with are defined by "indmo_mix"
C (as input).
C
      IF(MASWRK) WRITE(IW,9000)
C
C
C Jacobi rotation for Maximization of the D3 function starts.
C The rotation is carried out for each block
C
C
      INDHEAD=1
      DO IBLOCK=1,N_BLOCK  ! LOOP FOR THE BLOCK
        DO ISTEP=1,MAX_ITER ! LOOP FOR THE ONE-CIRCLE OF THE ROTATION
          CALL CALSUM_MAXD3(NSTATE,N_ACTIVE,DM1,NDMAT,
     &                      ALPHA_N,ALPHA_R,ALPHA_T,D_PRE)
          INDTAIL=INDHEAD+MSEGMENT(IBLOCK)-1
C
          DO I=INDHEAD,INDTAIL-1 ! LOOP FOR APPLYING THE ROTATION MATRIX
C The rotation matrix mixes jac1 and jac2-th MOs as J(ij) step
            JAC1=INDMO_MIX(I)
            DO J=I+1,INDTAIL
              JAC2=INDMO_MIX(J)
              CALL CALDEL_MAXD3(NSTATE,N_ACTIVE,DM1,NDMAT,
     &                          ALPHA_N,ALPHA_R,ALPHA_T,
     &                          JAC1,JAC2,A_IJ,B_IJ)
              DEL_D=SQRT(A_IJ**2+B_IJ**2)+A_IJ
              GAMMA_IJ=PT25*ACOS(-A_IJ/SQRT(A_IJ**2+B_IJ**2))
              IF (B_IJ.LT.ZERO) GAMMA_IJ=-GAMMA_IJ
              IF (CONV_TH.LT.DEL_D) THEN
C transform density matrix element
                C=COS(GAMMA_IJ)
                S=SIN(GAMMA_IJ)
C
                DO IDM=1,NDMAT-1
                  TMP_II=DM1(JAC1,JAC1,IDM)*C**2
     &            -DM1(JAC1,JAC2,IDM)*C*S
     &            -DM1(JAC2,JAC1,IDM)*C*S
     &            +DM1(JAC2,JAC2,IDM)*S**2
C
                  TMP_JJ=DM1(JAC1,JAC1,IDM)*S**2
     &            +DM1(JAC1,JAC2,IDM)*C*S
     &            +DM1(JAC2,JAC1,IDM)*C*S
     &            +DM1(JAC2,JAC2,IDM)*C**2
C
                  TMP_IJ=DM1(JAC1,JAC1,IDM)*C*S
     &            -DM1(JAC2,JAC2,IDM)*C*S
     &            +DM1(JAC1,JAC2,IDM)*C**2
     &            -DM1(JAC2,JAC1,IDM)*S**2
C
                  TMP_JI=DM1(JAC1,JAC1,IDM)*C*S
     &            -DM1(JAC2,JAC2,IDM)*C*S
     &            -DM1(JAC1,JAC2,IDM)*S**2
     &            +DM1(JAC2,JAC1,IDM)*C**2
C
                  DO K=1,N_ACTIVE
                    TEMP1(K)=DM1(JAC1,K,IDM)*C
     &              -DM1(JAC2,K,IDM)*S
                    TEMP2(K)=DM1(K,JAC1,IDM)*C
     &              -DM1(K,JAC2,IDM)*S
                    TEMP3(K)=DM1(JAC1,K,IDM)*S
     &              +DM1(JAC2,K,IDM)*C
                    TEMP4(K)=DM1(K,JAC1,IDM)*S
     &              +DM1(K,JAC2,IDM)*C
                  END DO
C
                  DO K=1,N_ACTIVE
                    DM1(JAC1,K,IDM)=TEMP1(K)
                    DM1(K,JAC1,IDM)=TEMP2(K)
                    DM1(JAC2,K,IDM)=TEMP3(K)
                    DM1(K,JAC2,IDM)=TEMP4(K)
                  END DO
C
                  DM1(JAC1,JAC1,IDM)=TMP_II
                  DM1(JAC2,JAC2,IDM)=TMP_JJ
                  DM1(JAC1,JAC2,IDM)=TMP_IJ
                  DM1(JAC2,JAC1,IDM)=TMP_JI
C
                END DO ! END LOOP ON ALL DM/TDM
C
                CALL MKSTAVGDM1(DM1,NDMAT,N_ACTIVE,NSTATE)
C
C Update Unitary MO-trans matrix
C
                DO K=1,N_ACTIVE
                  TEMP2(K)=U(K,JAC1)*C-U(K,JAC2)*S
                  TEMP4(K)=U(K,JAC1)*S+U(K,JAC2)*C
                  U(K,JAC1)=TEMP2(K)
                  U(K,JAC2)=TEMP4(K)
                END DO
C
              END IF
C
            END DO ! END OF LOOP OF J
          END DO   ! END OF LOOP OF I (I.E END OF ONE CIRCLE )
C
          CALL CALSUM_MAXD3(NSTATE,N_ACTIVE,DM1,NDMAT,
     &                      ALPHA_N,ALPHA_R,ALPHA_T,D_AFT)
C
          IF(MASWRK) WRITE(IW,9010) ISTEP,D_AFT,D_AFT-D_PRE
C
          IF (ABS(D_AFT-D_PRE).LT.CONV_TH) THEN
            IF(MASWRK) WRITE(IW,9020) IBLOCK
            GO TO 100
          END IF
C
        END DO ! END OF LOOP OF ISTEP
C
        IF (ABS(D_AFT-D_PRE).GT.CONV_TH) THEN
          IF(MASWRK) WRITE(IW,*) 'JACOBI ROTATION WAS NOT CONVERGED.'
          CALL ABRT
        END IF
C
100   CONTINUE ! DONE OF OPTIMIZATION FOR ONE-BLOCK (IBLOCK LOOP)
C
Cc    to next block...
C
        INDHEAD=INDHEAD+MSEGMENT(IBLOCK)
C
      END DO ! END OF LOOP OF IBLOCK
C
C Store occupation # for state averaged density matrix
C (i.e diagonal elements of SA DM1) for sorting DMOs
C
      DO I=1,N_ACTIVE
        AVOCC_ACT(I)=DM1(I,I,NDMAT)
      END DO
C
 9000 FORMAT(/1X,37(1H-)/
     &       1X,'      MAXIMIZING D3 FUNCTION'/
     &       1X,37(1H-)/
     &       1X,'   ITER   VALUE        PROGRESS')
 9010 FORMAT(1X,I5,2X,F10.5,2X,F13.8)
 9020 FORMAT(1X,'THE ROTATION OF ',I3,'-TH SYMMETRY BLOCK IS DONE')
      RETURN
      END
C
C*MODULE DIAB    *DECK CALSUM_MAXD3
      SUBROUTINE CALSUM_MAXD3(NSTATE,N_ACTIVE,DM1,NDMAT,
     &                       ALPHA_N,ALPHA_R,ALPHA_T,SUM)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION DM1(N_ACTIVE,N_ACTIVE,NDMAT)
      DATA ZERO /0.0D+00/
C
C
C Ruedenberg term
C
C
      SUM_R=ZERO
      KK=1      ! KK IS INDEX OF DM1 BETWEEN KSTAT-KSTAT
      DO KSTAT=1,NSTATE
        DO I=1,N_ACTIVE
          SUM_R=SUM_R+DM1(I,I,KK)*DM1(I,I,KK)
        END DO
        KK=KK+NSTATE+1-KSTAT
      END DO
C
      SUM_R=ALPHA_R*SUM_R !SCALE BY PARAMETER
C
C
C Natural orbital term
C
C
      SUM_N=ZERO
      DO I=1,N_ACTIVE
        SUM_N=SUM_N+DM1(I,I,NDMAT)**2
      END DO
C
      SUM_N=ALPHA_N * NSTATE * SUM_N  !SCALE BY PARAMETER
                                      !AND # OF STATES
C
C
C Transition term (kstat < istat)
C
C
      IF (NSTATE.EQ.1) GO TO 100
C
      SUM_T=ZERO
      KK=1       ! KK IS INDEX OF DM1 BETWEEN KSTAT-KSTAT
      DO KSTAT=1,NSTATE
        DO ISTAT=KSTAT+1,NSTATE
          KISTAT=KK+ISTAT-KSTAT   ! KISTAT IS INDEX OF ONLY TD DM1
          DO I=1,N_ACTIVE
            SUM_T=SUM_T+DM1(I,I,KISTAT)*DM1(I,I,KISTAT)
          END DO
        END DO
        KK=KK+NSTATE+1-KSTAT
      END DO
C
      SUM_T=ALPHA_T * 2.0D+00/(NSTATE-1) * SUM_T  !SCALE BY PARAMETER
                                                  !AND # OF STATES
C
100   CONTINUE
C
C
C Get sum  of all terms. i.e. D=Ruedenberg+Natural+Transition
C
C
      SUM=SUM_R+SUM_N+SUM_T
C
      RETURN
      END
C
C*MODULE DIAB    *DECK CALDEL_MAXD3
      SUBROUTINE CALDEL_MAXD3(NSTATE,N_ACTIVE,DM1,NDMAT,
     &                        ALPHA_N,ALPHA_R,ALPHA_T,
     &                        JAC1,JAC2,A_IJ,B_IJ)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DATA ZERO /0.0D+00/
      DATA PT5,PT25 /0.5D+00,0.25D+00/
C
      DIMENSION DM1(N_ACTIVE,N_ACTIVE,NDMAT)
C
C
C Calculate Ruedenberg term
C
C
      AR_IJ=ZERO
      BR_IJ=ZERO
      KK=1      ! KK IS INDEX OF DM1 BETWEEN KSTAT-KSTAT
      DO KSTAT=1,NSTATE
        D_II=DM1(JAC1,JAC1,KK)
        D_JJ=DM1(JAC2,JAC2,KK)
        D_IJ=DM1(JAC1,JAC2,KK)
        D_JI=DM1(JAC2,JAC1,KK)
        AR_IJ=AR_IJ+PT25*D_IJ*D_IJ+PT25*D_JI*D_JI+PT5*D_IJ*D_JI
     &      +PT5*D_II*D_JJ-PT25*D_II*D_II-PT25*D_JJ*D_JJ
        BR_IJ=BR_IJ+PT5*D_IJ*D_JJ+PT5*D_JI*D_JJ-PT5*D_II*D_IJ
     &       -PT5*D_II*D_JI
        KK=KK+NSTATE+1-KSTAT
      END DO
C
      AR_IJ=ALPHA_R*AR_IJ !SCALE BY PARAMETER
      BR_IJ=ALPHA_R*BR_IJ
C
C
C Calculate Natural orbital term
C
C
      D_II=DM1(JAC1,JAC1,NDMAT)
      D_JJ=DM1(JAC2,JAC2,NDMAT)
      D_IJ=DM1(JAC1,JAC2,NDMAT)
      D_JI=DM1(JAC2,JAC1,NDMAT)
      AN_IJ=PT25*D_IJ*D_IJ+PT25*D_JI*D_JI+PT5*D_IJ*D_JI
     &      +PT5*D_II*D_JJ-PT25*D_II*D_II-PT25*D_JJ*D_JJ
      BN_IJ=PT5*D_IJ*D_JJ+PT5*D_JI*D_JJ-PT5*D_II*D_IJ
     &       -PT5*D_II*D_JI
C
      AN_IJ=ALPHA_N * NSTATE * AN_IJ  !SCALE BY PARAMETER
      BN_IJ=ALPHA_N * NSTATE * BN_IJ  !AND # OF STATES
C
C
C Calculate Transition term (kstat < istat)
C
C
      AT_IJ=ZERO
      BT_IJ=ZERO
C
      IF (NSTATE.EQ.1) GO TO 100
C
      KK=1
      DO KSTAT=1,NSTATE
        DO ISTAT=KSTAT+1,NSTATE
          KISTAT=KK+ISTAT-KSTAT
          D_II=DM1(JAC1,JAC1,KISTAT)
          D_JJ=DM1(JAC2,JAC2,KISTAT)
          D_IJ=DM1(JAC1,JAC2,KISTAT)
          D_JI=DM1(JAC2,JAC1,KISTAT)
          AT_IJ=AT_IJ+PT25*D_IJ*D_IJ+PT25*D_JI*D_JI+PT5*D_IJ*D_JI
     &      +PT5*D_II*D_JJ-PT25*D_II*D_II-PT25*D_JJ*D_JJ
          BT_IJ=BT_IJ+PT5*D_IJ*D_JJ+PT5*D_JI*D_JJ-PT5*D_II*D_IJ
     &       -PT5*D_II*D_JI
        END DO
        KK=KK+NSTATE+1-KSTAT
      END DO
C
      AT_IJ=ALPHA_T * 2.0D+00/(NSTATE-1) * AT_IJ  !SCALE BY PARAMETER
      BT_IJ=ALPHA_T * 2.0D+00/(NSTATE-1) * BT_IJ  !AND # OF STATES
C
100   CONTINUE
C
C Get a_ij and b_ij
C
      A_IJ=AR_IJ+AN_IJ+AT_IJ
      B_IJ=BR_IJ+BN_IJ+BT_IJ
C
      RETURN
      END
C
C*MODULE DIAB    *DECK PRESORT
      SUBROUTINE PRESORT(NSTATE,NUM,N_ACTIVE,NB_CAN,N_REFMO,INDX1,
     &                   V,W,S,SMO,TEMP,DM1,NDMAT,AVOCC,MOSLAB_ACTIVE)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION V(NUM,N_ACTIVE)
      DIMENSION W(NUM,N_REFMO)
      DIMENSION S((NUM*NUM+NUM)/2)
      DIMENSION SMO(N_ACTIVE,N_ACTIVE)
      DIMENSION TEMP(NUM,N_ACTIVE)
      DIMENSION INDX1(NB_CAN)
      DIMENSION DM1(N_ACTIVE,N_ACTIVE,NDMAT)
      DIMENSION AVOCC(N_ACTIVE)
      DIMENSION MOSLAB_ACTIVE(N_ACTIVE)
C
      PARAMETER (MXDIABACT=30)
      DIMENSION ISTACK(MXDIABACT)  ! USED AS NB_CAN AT MOST
      DIMENSION ITEMP(MXDIABACT)
C
C This routine sorts MOs within each (candidate) block,
C based on reference MOs ($DPSVEC or $DIAVEC)
C in order to accelate convergence of the MORMO step
C
C
C
C nb_can ... # of candidate MO of the block
C n_refmo ... # of reference MOs
C
C indx1(i) i-th MO of the specified block is indx1(i)-th
C          stored MO
C istack(i) i-th MO of the spcecified block is sorted
C          to istack(i)-th MO of the specifeid block
C
C temp(num,n_active)
C v(num,n_active) .... active MOs
C w(num,n_refmo)  .... reference MOs
C s(num*(num+1)/2)... AO overlap
C dm1(n_active,n_active,nstate*(nstate+1)/2+1
C avocc(n_active)
C
      CALL DFRMCHECK2(NUM,N_ACTIVE,N_REFMO,NB_CAN,
     &                INDX1,ISTACK,V,W,S,SMO)
C
C         MWS doesn't know how to interpret this output,
C         so it isn't printed any more.
C     if(maswrk) then
C        write(6,*) 'Debug in presort'
C        write(6,*) 'istack'
C        do i=1,nb_can
C          write(6,*) i,istack(i)
C        end do
C        write(6,*) 'actual position sort new <--- old'
C        do i=1,nb_can
C          write(6,*) indx1(istack(i)),indx1(i)
C        end do
C     end if
C
C Sort
C
C             --- MO ----
C
      DO I=1,N_ACTIVE
        DO J=1,NUM
          TEMP(J,I)=V(J,I)
        END DO
      END DO
C
      DO I=1,NB_CAN
        DO J=1,NUM
          V(J,INDX1(ISTACK(I)))=TEMP(J,INDX1(I))
        END DO
      END DO
C
C             --- irreps labela--
C
      DO I=1,N_ACTIVE
        ITEMP(I)=MOSLAB_ACTIVE(I)
      END DO
      DO I=1,NB_CAN
        MOSLAB_ACTIVE(INDX1(ISTACK(I)))=ITEMP(INDX1(I))
      END DO
C
C              --- DMs ---
C
      DO IDM=1,NDMAT-1
        DO I=1,N_ACTIVE
          DO J=1,N_ACTIVE
            TEMP(J,I)=DM1(J,I,IDM)
          END DO
        END DO
        DO I=1,NB_CAN
          IND_A=INDX1(I)
          IND_B=INDX1(ISTACK(I))
          DO J=1,NB_CAN
            JND_A=INDX1(J)
            JND_B=INDX1(ISTACK(J))
            DM1(IND_B,JND_B,IDM)=TEMP(IND_A,JND_A)
          END DO
        END DO
      END DO
C
      CALL MKSTAVGDM1(DM1,NDMAT,N_ACTIVE,NSTATE)
C
C             --- average occ # --
C
      DO I=1,N_ACTIVE
        AVOCC(I)=DM1(I,I,NDMAT)
      END DO
C
      RETURN
      END
C
C*MODULE DIAB    *DECK DFRMCHECK2
      SUBROUTINE DFRMCHECK2(NUM,N_ACTIVE,NB_DET,NB_TEMP,
     &                      INDB_CRRT,ISTACK,V,W,S,STORE_DOT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXAO=8192)
      COMMON /IJPAIR/ IA(MXAO)
C
      DIMENSION INDB_CRRT(NB_TEMP)
      DIMENSION ISTACK(NB_TEMP)
      DIMENSION V(NUM,N_ACTIVE)
      DIMENSION W(NUM,NB_DET)
      DIMENSION S((NUM*NUM+NUM)/2)
      DIMENSION STORE_DOT(NB_TEMP,NB_TEMP)
C
      DATA ZERO/0.0D+00/
C
C This routine make index array to represent one-to-one
C correspondence between some of V and W
C
C Note: DFRMCHECK2 is slightly different with DFRMCHECK
C       The first NB_DET orbital's order is defined by
C       reference MOs. The rest is arbitray, but
C       necessary to be defined !
C
C v  ... MO coefficient of active space at the current geometry
C        return without modification
C
C w  ... reference MOs i.e $DIAVEC or $DPSVEC not $DFMVEC
C
C s  ... AO overlap
C
C n_active   ... # of active orbitals
C
C nb_det     ... # of reference ($DIAVEC or $DPSVEC) MOs
C
C nb_temp    ... # of MOs per the doc or val block
C
C indb_crrt(i) ... i-th MO counted within the block is stored
C                   on indb_crrt(i)-th array
C
C store_dot(i,j): overlap-like quantity <u_i(ref)|u_j(current)>
C
C istack(1:nb_temp): i-th MO counted within the block is reordered
C                     to the istack(i)-th MO counted within the block
C
C This definitiion of ISTACK is different with DFRMCHECK
C
C   --- zero--
C
       DO J=1,NB_TEMP
         DO I=1,NB_DET
           STORE_DOT(I,J)=ZERO
         END DO
       END DO
C
C   --- dummy value to take consistency for the rest
C       of the nb_temp-nb_set MOs
C
       DO J=1,NB_TEMP
         DO I=NB_DET+1,NB_TEMP
           STORE_DOT(I,J)=0.001D+00
         END DO
       END DO
C
C ---- Check of deformation ------
C
C Step(1) Calculate overlap matrix between reference's DMO
C block and current MO block
C
      DO I=1,NB_DET
        DO J=1,NB_TEMP
          DUM=ZERO
          DO K=1,NUM
            DO L=1,NUM
              IF (L.LE.K) THEN
                IND_KL=IA(K)+L
              ELSE
                IND_KL=IA(L)+K
              END IF
              DUM=DUM+W(K,I)*V(L,INDB_CRRT(J))*S(IND_KL)
            END DO
          END DO
          STORE_DOT(I,J)=DUM
        END DO
      END DO
C
C
C Step(2) Search maximum overlaping and determine the one-to-one
C correspondence of nb_det MOs. The rest MO's postion
C is specified arbitratry.
C Thus, scan is performed nb_temp * nb_temp
C
C
      DO I=1,NB_TEMP
C
C Search max element of store_dot : max value = store_dot(i_ref,i_crrt)
C
        DUM_MAX=ZERO
        DO J=1,NB_TEMP
          DO K=1,NB_TEMP
            DUM=ABS(STORE_DOT(K,J))
            IF (DUM_MAX.LT.DUM) THEN
              DUM_MAX=DUM
              I_REF=K
              I_CRRT=J
            END IF
          END DO
        END DO
C
C Now correspondence between i-th reference MO
C indb_crrt(i_crrt)-th MO are defined
C
C Index array
C
C i_crrt th MO counted within block must move to i_ref th.
C the sign of indb_crrt, istack is FIXED.
C The sign is NOT affected by this procedure
C
        ISTACK(I_CRRT)=I_REF
C
C The all values of store_dot(*,i_crrt) and
C store_dot(i_ref,*) are replaced by
C dummy value zero because the above correspondence are determied
C
        DO J=1,NB_TEMP
          STORE_DOT(J,I_CRRT)=ZERO
        END DO
        DO J=1,NB_TEMP
          STORE_DOT(I_REF,J)=ZERO
        END DO
      END DO
C
      RETURN
      END
C
C*MODULE DIAB    *DECK FOURFOLD
      SUBROUTINE FOURFOLD(ALPHA_N,ALPHA_R,ALPHA_T,CONV_TH,MAX_ITER,
     &                    NSTATE,NUM,N_ACTIVE,NMLAP,
     &                    MOSLAB_ACTIVE,MOSLAB_REFDMO,MOSLAB_4FOLD,
     &                    DM1,NDMAT,V,W,S,AVOCC_ACT,TEMP,U,STDPHASE)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL STDPHASE
C
      DIMENSION MOSLAB_ACTIVE(N_ACTIVE)
      DIMENSION MOSLAB_REFDMO(N_ACTIVE)
      DIMENSION MOSLAB_4FOLD(N_ACTIVE)
      DIMENSION DM1(N_ACTIVE,N_ACTIVE,NDMAT)
      DIMENSION V(NUM,N_ACTIVE)
      DIMENSION W(NUM,NMLAP)
      DIMENSION S(NUM*(NUM+1)/2)
      DIMENSION AVOCC_ACT(N_ACTIVE)
      DIMENSION TEMP(NUM,N_ACTIVE)   ! TEMPORARY (MAX) REGION
      DIMENSION U(N_ACTIVE,N_ACTIVE)
C
      PARAMETER (MXDIABACT=30)
      DIMENSION MSEGMENT_REF(MXDIABACT) ! USED UP TO -NMLAP- ELEMENTS
      DIMENSION LABREF_BLOCK(MXDIABACT) ! USED UP TO -NMLAP- ELEMENTS
      DIMENSION LAB_BLOCK(MXDIABACT)
      DIMENSION INDMO_MIX(MXDIABACT)
      DIMENSION MSEGMENT(MXDIABACT)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,DEBUG
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA ZERO,ONE /0.0D+00,1.0D+00/
C
C     This routine carry out the fourfold way
C     and update MOs (categorized as "valence").
C     Also all DM are transformed to match.
C
C Notice: the fourfold way is applied for the MOs of only the
C         valence block. For other block's MOs are not changed from
C         preliminary threefold density criterion's
C
C nstate .... total # of states for diabatization
C num  .... number of basis set (AO)
C n_active ... number of the active MOs
C nmlap ... number of reference DMOs for the MORMO criterion
C v  ... MO vec (active) : return as updated (threefold density's) MO
C w  .... reference MOs for the MORMO criterion
C s  .... AO overlap
C dm1 ... Density matrices (including transition DM and SA-DM)
C (dm are stored as (11),(12),...(1 nstate),(22),(23),.... )
C moslab_active .... irreps label of the active MOs
C moslab_charact
C moslab_refdmo
C
C ---- Index arrays for current MOs ----
C
C lab_block(i) .... irreps label of MOs belong to i-th block
C                  (lab_block(i).NE.lab_block(j) when i.NE.j)
C
C msegment(i).... number (dimension) of the i-th block to be mixed
C
C indmo_mix ... indmo_mix(1:msegment(1))=MO index to be mixed for the
C                                        threefold density criterion
C indmo_mix(msegment(1)+1:msegment(1)+msegment(2))=MO index of the
C                                        next block
C               ....
C                       where n_block (<n_active) is total # of block
C                      (defined bellow)
C
C ---- Index arrays for reference DMOs ($DIAVEC)  ---
C
C labref_block(i)
C megment_ref(i)
C
C        Toggle last part of -debug- to see 4-fold way orbitals!
C
      DEBUG = MASWRK  .AND.  .FALSE.
C
C Define the block to mixing MOs for MORMO criterion
C based on information of irreps (by using moslab_active) and
C valence block (by using moslab_charact)
C
      CALL MKMOIND2(N_ACTIVE,MOSLAB_ACTIVE,MOSLAB_4FOLD,
     &              INDMO_MIX,MSEGMENT,LAB_BLOCK,N_BLOCK)
C
C Preliminary procedure for the MORMO criterion
C Sort data in w ($DIAVEC) to have mach symmetry of block
C to use the routine mormo
C
      CALL SORT_MORMO(NUM,NMLAP,NREF_BLOCK,MOSLAB_REFDMO,LABREF_BLOCK,
     &                MSEGMENT_REF,W,TEMP)
C
C Carry out the MORMO criterion to the valence block.
C The nmlap current MOs are determined at this stage.
C (In the routine mormo, MOs and DMs are updated.)
C
C Also n_block,lab_blcok,indmo_mix,and msegment are updated to be used
C in the next stage i.e. threefold density criterion for the REST MOs
C
      CALL MORMO(CONV_TH,MAX_ITER,NUM,N_ACTIVE,NMLAP,N_BLOCK,
     &           NREF_BLOCK,INDMO_MIX,MSEGMENT,LAB_BLOCK,MSEGMENT_REF,
     &           LABREF_BLOCK,DM1,NDMAT,NSTATE,V,W,S,TEMP)
C
      IF(DEBUG) THEN
         IF(MASWRK) WRITE(IW,*) 'THESE ORBITALS EMERGE FROM MORMO'
         CALL PRSQ(V,N_ACTIVE,NUM,NUM)
      END IF
C
C Carry out the threefold density criterion to the rest valence
C block MOs and determine MO/base transformation matrix U
C
C          Initialization of U (i.e. unit matrix)
C
      DO I=1,N_ACTIVE
        DO J=1,N_ACTIVE
          U(J,I)=ZERO
        END DO
      END DO
      DO I=1,N_ACTIVE
        U(I,I)=ONE
      END DO
C
C          threefold density criterion for the rest MOs
C
      CALL MAX_D3(ALPHA_N,ALPHA_R,ALPHA_T,CONV_TH,MAX_ITER,NSTATE,
     *            N_ACTIVE,N_BLOCK,INDMO_MIX,MSEGMENT,DM1,NDMAT,
     *            U,AVOCC_ACT)
C
C Transform the MO coefficients of the new MO by using the matrix U
C
      IF(DEBUG) THEN
         IF(MASWRK) WRITE(IW,*) 'THE COMPLETED FOUR-FOLD ROTATION IS'
         CALL PRSQ(U,N_ACTIVE,N_ACTIVE,N_ACTIVE)
      END IF
C
      CALL DGEMM('N','N',NUM,N_ACTIVE,N_ACTIVE,ONE,V,NUM,
     &           U,N_ACTIVE,ZERO,TEMP,NUM)
C
      DO I=1,N_ACTIVE
        DO J=1,NUM
          V(J,I)=TEMP(J,I)
        END DO
      END DO
C
      IF(STDPHASE) THEN
         IF(MASWRK) WRITE(IW,9001) N_ACTIVE
         CALL STFASE(V,NUM,NUM,N_ACTIVE)
      END IF
C
      IF(DEBUG) THEN
         IF(MASWRK) WRITE(IW,*) 'THE FOUR-FOLD WAY PRODUCES THESE DMOS'
         CALL PRSQ(V,N_ACTIVE,NUM,NUM)
      END IF
C
      RETURN
 9001 FORMAT(1X,'ADJUSTING',I5,
     *          ' FOUR-FOLD WAY ORBITALS TO STANDARD PHASE')
      END
C
C*MODULE DIAB    *DECK MKMOIND2
      SUBROUTINE MKMOIND2(N_ACTIVE,MOSLAB_ACTIVE,MOSLAB_4FOLD,
     &                    INDMO_MIX,MSEGMENT,LAB_BLOCK,N_BLOCK)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION MOSLAB_ACTIVE(N_ACTIVE)
      DIMENSION MOSLAB_4FOLD(N_ACTIVE)
      DIMENSION INDMO_MIX(N_ACTIVE)
      DIMENSION MSEGMENT(N_ACTIVE)   ! USED UP TO N_BLOCK
      DIMENSION LAB_BLOCK(N_ACTIVE)  ! USED UP TO N_BLOCK
C
      PARAMETER (MXDIABACT=30)
      DIMENSION ITEMP(MXDIABACT)
C
      COMMON /DIABAT/ ALPHA_N,ALPHA_R,ALPHA_T,
     *                TH_DOC,TH_VIR,SLCTTH,CONV_TH,WBLOCK(3),
     *                NDFRM,NDMOSYM,NRCSF,NMLAP,NDLAP,NORIENT,
     *                MOSLAB_CHARACT(MXDIABACT),
     *                MAX_ITER,NGRSTATE,NEXSTATE,NSTDIAB,
     *                NSYMBOL_DOC,NSYMBOL_VAL,NSYMBOL_VIR
C
C This routine makes index arrays that define the "mixing block"
C of the active MOs to apply the MORMO criterion in the fourfold
C way step.
C i.e., the blocks are defined by character (i.e.valence),
C       the irreps label of the current DMO and irreps label of the
C       reference DMO ($DIAVEC)
C
C n_active ... number of the active MOs (input and output)
C n_block  ... number of the blocks (output)
C
C msegment(i).... number (dimension) of the i-th block to be mixed
C
C indmo_mix ... indmo_mix(1:msegment(1))=MO index to be mixed for the
C                                        threefold density criterion
C indmo_mix(msegment(1)+1:msegment(1)+msegment(2))=MO index of the
C                                        next block
C               ....
C                       where n_block (< n_active) is total # of block
C                       (defined bellow)
C
C lab_blok(i) ... irreps label of i-th block
C                 Notice: lab_block(i).NE.lab_block(j) (i.NE.j)
C
      DO I=1,N_ACTIVE
         IF (MOSLAB_4FOLD(I).EQ.NSYMBOL_VAL) THEN
           ITEMP(I)=MOSLAB_ACTIVE(I)
         ELSE
           ITEMP(I)=0 ! NULL (ZERO) DUMMY VALUE
         END IF
      END DO
C
      ICOUNT=0
      ISHIFT=0
      DO I=1,N_ACTIVE ! THIS LOOP IS CORRELATED TO PICKING UP ONE-BLOCK
         IF (ITEMP(I).EQ.0) GO TO 100  ! SKIP. 0 IS DUMMY VALUE
         ICOUNT=ICOUNT+1
         IDUMLAB=ITEMP(I)
         LAB_BLOCK(ICOUNT)=IDUMLAB ! IRREPS OF ICOUNT-TH BLOCK
         JCOUNT=0
C            next loop is correlated to determination of
C            the members of the above one-block
         DO J=1,N_ACTIVE
           IF (ITEMP(J).EQ.IDUMLAB) THEN
             JCOUNT=JCOUNT+1
             INDMO_MIX(JCOUNT+ISHIFT)=J
             ITEMP(J)=0 ! REPLACE TO NULL VALUE FOR THE LOOP OF I
           END IF
         END DO
         MSEGMENT(ICOUNT)=JCOUNT
         ISHIFT=ISHIFT+MSEGMENT(ICOUNT)
100      CONTINUE
      END DO
      N_BLOCK=ICOUNT
      RETURN
      END
C
C*MODULE DIAB    *DECK SORT_MORMO
      SUBROUTINE SORT_MORMO(NUM,NMLAP,NREF_BLOCK,MOSLAB_REFDMO,
     &                      LABREF_BLOCK,MSEGMENT_REF,V,TEMP)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION MOSLAB_REFDMO(NMLAP)
      DIMENSION LABREF_BLOCK(NMLAP)
      DIMENSION MSEGMENT_REF(NMLAP)
      DIMENSION V(NUM,NMLAP)
      DIMENSION TEMP(NUM,NMLAP)
C
      PARAMETER (MXDIABACT=30)
      DIMENSION ITEMP(MXDIABACT)     ! USED UP TO SIZE -NMLAP-
      DIMENSION IND_TEMP(MXDIABACT)  ! USED UP TO SIZE -NMLAP-
C
C This routine sorts the data of reference MO for the MORMO
C criterion (i.e. $DIAVEC) to group block such as the same irreps ref
C DMOs belong to one block.
C
C n_block ... total # of block for mixing (input & output)
C nref_block ... total # of block of reference DMOs (grouped by irreps)
C                (output)
C
C v ... data of the reference MOs ($DIAVEC) (input. Output is updated)
C moslab_refdmo ... irreps label of the reference MOs
C                   (input. output is reordered with v in this routine.)
C labref_block  ... irreps label of each block  (output)
C msegment_ref  ... msegment_ref(i) is number of reference DMOs of
C                   i-th block
C
      DO I=1,NMLAP
        ITEMP(I)=MOSLAB_REFDMO(I)
      END DO
C
      ICOUNT=0
      ISHIFT=0
      DO I=1,NMLAP ! THIS LOOP IS CORRELATING WITH PICKING UP ONE-BLOCK
        IF (ITEMP(I).EQ.0) GO TO 100 ! SKIP IF 0 = DUMMY VALUE
        ICOUNT=ICOUNT+1
        IDUMLAB=ITEMP(I)
        LABREF_BLOCK(ICOUNT)=IDUMLAB  ! IRREPS LABEL OF THIS BLOCK
        JCOUNT=0
        DO J=1,NMLAP ! THIS LOOP IS CORRELATING TO DETERMINATION OF
                     ! THE MEMBERS OF THE ABOVE ONE-BLOCK
          IF (ITEMP(J).EQ.IDUMLAB) THEN
            JCOUNT=JCOUNT+1
            IND_TEMP(JCOUNT+ISHIFT)=J
            ITEMP(J)=0 ! REPLACE TO NULL DUMMY VALUE
          END IF
        END DO
        MSEGMENT_REF(ICOUNT)=JCOUNT
        ISHIFT=ISHIFT+MSEGMENT_REF(ICOUNT)
100     CONTINUE
      END DO
      NREF_BLOCK=ICOUNT
C
C Sort MOs
C
      DO I=1,NMLAP
        DO J=1,NUM
          TEMP(J,I)=V(J,I)
        END DO
      END DO
C
      DO I=1,NMLAP
        DO J=1,NUM
          V(J,I)=TEMP(J,IND_TEMP(I))
        END DO
      END DO
C
C Sort label
C
      DO I=1,NMLAP
        ITEMP(I)=MOSLAB_REFDMO(I)
      END DO
C
      DO I=1,NMLAP
        MOSLAB_REFDMO(I)=ITEMP(IND_TEMP(I))
      END DO
C
      RETURN
      END
C
C*MODULE DIAB    *DECK MORMO
      SUBROUTINE MORMO(CONV_TH,MAX_ITER,NUM,N_ACTIVE,NMLAP,
     &                 N_BLOCK,NREF_BLOCK,INDMO_MIX,MSEGMENT,
     &                 LAB_BLOCK,MSEGMENT_REF,LABREF_BLOCK,
     &                 DM1,NDMAT,NSTATE,V,V_REF,S,TEMP)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION INDMO_MIX(N_ACTIVE)
      DIMENSION MSEGMENT(N_BLOCK)
      DIMENSION LAB_BLOCK(N_BLOCK) ! LAB_BLOCK(N_ACTIVE)
      DIMENSION MSEGMENT_REF(NREF_BLOCK)
      DIMENSION LABREF_BLOCK(NREF_BLOCK)
      DIMENSION DM1(N_ACTIVE,N_ACTIVE,NDMAT)
      DIMENSION V(NUM,N_ACTIVE)
      DIMENSION V_REF(NUM,NMLAP)
      DIMENSION S(NUM*(NUM+1)/2)
      DIMENSION TEMP(NUM,2)
C
      PARAMETER (MXDIABACT=30)
      DIMENSION TEMP1(MXDIABACT)
      DIMENSION TEMP2(MXDIABACT)
      DIMENSION TEMP3(MXDIABACT)
      DIMENSION TEMP4(MXDIABACT)
      DIMENSION ITEMP(MXDIABACT)
      DIMENSION MSEGMENT_TMP(MXDIABACT) ! USED AS SIZE -N_BLOCK-
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA PT5 /0.5D+00/
C
C This routine carries out the MORMO criterion
C All MOs are updated by the criterion, and also
C density matrices are updated in this routine.
C The restriction of MOs to be mixed with are defined by "indmo_mix"
C etc.
C
C
C v ... MOs of current geometry (input). Output is updated in this
C       routine and returned
C
C v_ref ... reference DMO ($DIAVEC) (input & output)
C          (Note: this data is orderd by irreps as MOs of each block are
C                 labeled by unique irreps.)
C
C s ... AO overlap (input & output)
C
C dm1 ... density matrices (input) of the current MOs. Output is updated
C         in this routine and returned.
C
C n_block ... total # of block ( only within each block, Jacobi
C             rotation is done)
C
C msegment(i)... number (dim) of the i-th block to be mixed
C
C indmo_mix ... MO index to be mixed for the MORMO criterion
C
C nref_block ... total # of block to be referenced (blocked by irreps)
C
C msegment_ref(i) ... number (dim) of the i-th block of reference DMO
C
C lab_block
C
C labref_block
C
C                    Set parameters
C ntot_val : total number of "valence" MOs i.e. to be used for MORMO
C
      NTOT_VAL=0
      DO I=1,N_BLOCK
        NTOT_VAL=NTOT_VAL+MSEGMENT(I)
      END DO
C
C Copy
C
      DO I=1,N_BLOCK
        MSEGMENT_TMP(I)=MSEGMENT(I)
      END DO
C
      IF(MASWRK) WRITE(IW,9000)
C
C
C Jacobi rotation for Maximization of the reference overlap
C term (MORMO) starts.
C The rotation is carried out for each block.
C The block to be picked up first is reference DMO's ($DFMVEC) one
C and then suitable block of the current MOs is searched.
C The Jacobi rotation carried out within this current MOs's block
C
C         header index of the reference DMO of the iblock-th block
      IHEAD_REF=1
C
      DO IBLOCK=1,NREF_BLOCK  ! LOOP FOR THE BLOCK OF THE REFERENCE DMOS
        N_OVERLAP=MSEGMENT_REF(IBLOCK) !NUMBER OF REF DMOS IN THIS BLOCK
C
C Pick up corresponding block of current MOs (index=n_search)
C Set up parameters for current MOs block
C
        CALL SRCHMORMO(N_SEARCH,IHEAD,N_MIXMO,N_BLOCK,LAB_BLOCK,
     &                 MSEGMENT,LABREF_BLOCK(IBLOCK))
C
C n_search : index of current MO's block corresponding to the ref DMO
C            block
C n_mixmo  : number of MOs of the above block
C
C ihead    : header index of current MOs (physical address
C                                         indmo_mix(indhead)
C
C                 Jacobi rotation step
C
        DO ISTEP=1,MAX_ITER ! LOOP FOR THE ONE-CIRCLE OF THE ROTATION
C
          CALL CALSUM_MORMO(NUM,N_ACTIVE,N_OVERLAP,INDMO_MIX,
     &                      IHEAD,V_REF(1,IHEAD_REF),V,S,D_PRE)
C
          DO I=1,N_OVERLAP
            JAC1=INDMO_MIX(IHEAD+I-1) ! INDEX OF THE CURRENT MO FOR I
            JAC1_REF=IHEAD_REF+I-1   ! INDEX OF THE REFERENCE DMO FOR I
            DO J=I+1,N_MIXMO
              JAC2=INDMO_MIX(IHEAD+J-1) ! INDEX OF THE CURRENT MO FOR J
              IF (J.LE.N_OVERLAP) THEN
                JAC2_REF=IHEAD_REF+J-1 !INDEX OF THE REFERENCE DMO FOR J
                CALL CALDEL_MORMO1(NUM,V(1,JAC1),V(1,JAC2),
     &              V_REF(1,JAC1_REF),V_REF(1,JAC2_REF),S,A_IJ,B_IJ)
              ELSE
C                  in this case, reference DMO for j is not necessary
                CALL CALDEL_MORMO2(NUM,V(1,JAC1),V(1,JAC2),
     &              V_REF(1,JAC1_REF),S,A_IJ,B_IJ)
              END IF
C
              DEL_D=SQRT(A_IJ**2+B_IJ**2)+A_IJ
C
              GAMMA_IJ=PT5*ACOS(-A_IJ/SQRT(A_IJ**2+B_IJ**2))
C
              IF (CONV_TH.LT.DEL_D) THEN
C
C                     2x2 transform current MO coefficients
C
                CALL MOCOEFMIX(V(1,JAC1),V(1,JAC2),TEMP,NUM,GAMMA_IJ)
C
C                     corresponding update to the DMs
C
                CVAL=COS(GAMMA_IJ)
                SVAL=SIN(GAMMA_IJ)
C
                DO IDM=1,NDMAT-1
                  TMP_II=DM1(JAC1,JAC1,IDM)*CVAL*CVAL
     &                  -DM1(JAC1,JAC2,IDM)*CVAL*SVAL
     &                  -DM1(JAC2,JAC1,IDM)*CVAL*SVAL
     &                  +DM1(JAC2,JAC2,IDM)*SVAL*SVAL
                  TMP_JJ=DM1(JAC1,JAC1,IDM)*SVAL*SVAL
     &                  +DM1(JAC1,JAC2,IDM)*CVAL*SVAL
     &                  +DM1(JAC2,JAC1,IDM)*CVAL*SVAL
     &                  +DM1(JAC2,JAC2,IDM)*CVAL*CVAL
                  TMP_IJ=DM1(JAC1,JAC1,IDM)*CVAL*SVAL
     &                  -DM1(JAC2,JAC2,IDM)*CVAL*SVAL
     &                  +DM1(JAC1,JAC2,IDM)*CVAL*CVAL
     &                  -DM1(JAC2,JAC1,IDM)*SVAL*SVAL
                  TMP_JI=DM1(JAC1,JAC1,IDM)*CVAL*SVAL
     &                  -DM1(JAC2,JAC2,IDM)*CVAL*SVAL
     &                  -DM1(JAC1,JAC2,IDM)*SVAL*SVAL
     &                  +DM1(JAC2,JAC1,IDM)*CVAL*CVAL
C
                  DO K=1,N_ACTIVE ! NOTICE K SHOULD BE RUN ALL ACTIVE
                    TEMP1(K)=DM1(JAC1,K,IDM)*CVAL
     &                      -DM1(JAC2,K,IDM)*SVAL
                    TEMP2(K)=DM1(K,JAC1,IDM)*CVAL
     &                      -DM1(K,JAC2,IDM)*SVAL
                    TEMP3(K)=DM1(JAC1,K,IDM)*SVAL
     &                      +DM1(JAC2,K,IDM)*CVAL
                    TEMP4(K)=DM1(K,JAC1,IDM)*SVAL
     &                      +DM1(K,JAC2,IDM)*CVAL
                  END DO
C
                  DO K=1,N_ACTIVE
                    DM1(JAC1,K,IDM)=TEMP1(K)
                    DM1(K,JAC1,IDM)=TEMP2(K)
                    DM1(JAC2,K,IDM)=TEMP3(K)
                    DM1(K,JAC2,IDM)=TEMP4(K)
                  END DO
C
                  DM1(JAC1,JAC1,IDM)=TMP_II
                  DM1(JAC2,JAC2,IDM)=TMP_JJ
                  DM1(JAC1,JAC2,IDM)=TMP_IJ
                  DM1(JAC2,JAC1,IDM)=TMP_JI
                END DO
C
                CALL MKSTAVGDM1(DM1,NDMAT,N_ACTIVE,NSTATE)
              END IF
            END DO ! END OF LOOP OF J
          END DO   ! END OF LOOP OF I (I.E END OF ONE CIRCLE )
C
          CALL CALSUM_MORMO(NUM,N_ACTIVE,N_OVERLAP,INDMO_MIX,
     &                      IHEAD,V_REF(1,IHEAD_REF),V,S,D_AFT)
C
          IF(MASWRK) WRITE(IW,9010) ISTEP, D_AFT, D_AFT-D_PRE
C
          IF (ABS(D_AFT-D_PRE).LT.CONV_TH) THEN
            IF(MASWRK) WRITE(IW,9020) IBLOCK
            GO TO 100
          END IF
C
        END DO ! END OF LOOP OF ISTEP
C
        IF (ABS(D_AFT-D_PRE).GT.CONV_TH) THEN
          IF(MASWRK) WRITE(IW,*) 'JACOBI ROTATION WAS NOT CONVERGED.'
          CALL ABRT
        END IF
C
C             finished optimization (for IBLOCK loop)
C
  100   CONTINUE
C
C            Define (update) msegment_tmp array to use the final
C            threefold density criterion, i.e, remove MOs determined
C            by this MORMO step
C
        MSEGMENT_TMP(N_SEARCH)=N_MIXMO-N_OVERLAP
C               to next block...
        IHEAD_REF=IHEAD_REF+MSEGMENT_REF(IBLOCK)
      END DO ! END OF LOOP OF IBLOCK
C
C Update indmo_mix, msegment, and n_block by using msegment_tmp array
C
      DO I=1,NTOT_VAL
        ITEMP(I)=INDMO_MIX(I)
      END DO
C
      ISHIFT1=0
      ISHIFT2=0
      DO I=1,N_BLOCK
        IVAL=MSEGMENT(I)
        ID3FREE=MSEGMENT_TMP(I)
        IOVERLAP=IVAL-ID3FREE
        DO J=1,ID3FREE
          INDMO_MIX(J+ISHIFT1)=ITEMP(J+IOVERLAP+ISHIFT2)
        END DO
        ISHIFT1=ISHIFT1+ID3FREE
        ISHIFT2=ISHIFT2+IVAL
      END DO
C
      DO I=1,N_BLOCK
        ITEMP(I)=LAB_BLOCK(I)
      END DO
C
      ICOUNT=0
      DO I=1,N_BLOCK
        IF (MSEGMENT_TMP(I).NE.0) THEN
          ICOUNT=ICOUNT+1
          MSEGMENT(ICOUNT)=MSEGMENT_TMP(I)
          LAB_BLOCK(ICOUNT)=ITEMP(I)
        END IF
      END DO
C
      N_BLOCK=ICOUNT
      RETURN
 9000 FORMAT(/1X,'-------------------------------------------'/
     &       1X,'      MAXIMIZING MORMO OVERLAP TERM        '/
     &       1X,'-------------------------------------------'/
     &       1X,'   ITER    VALUE       PROGRESS')
 9010 FORMAT(1X,I5,2X,F10.5,2X,F13.8)
 9020 FORMAT(1X,'THE ROTATION OF ',I3,'-TH BLOCK IS DONE')
      END
C
C*MODULE DIAB    *DECK SRCHMORMO
      SUBROUTINE SRCHMORMO(N_SEARCH,IHEAD_MO,N_MIXMO,N_BLOCK,LAB_BLOCK,
     &                     MSEGMENT,LAB_REF)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION LAB_BLOCK(N_BLOCK)
      DIMENSION MSEGMENT(N_BLOCK)
C
C This routine search the block of current MOs corresponding
C to the block of the reference DMOs.
C The label of target (reference DMOs) block is identified
C as input "lab_ref"
C
C lab_block .... label array for the current MOs's block for MORMO
C n_block   .... total # of block for the current MOs for MORMO
C lab_ref   .... label of target reference DMOs's block
C n_search  .... n_search-th block of current DMOs's block is
C                corresponding to the target block
C n_mixmo   .... total # of current MOs  in n_search-th block
C ihead_mo  .... header index of MOs in n_search-th block
C                (physical address is identified indmo_mix(ihead_mo))
C
      DO I=1,N_BLOCK
        IF (LAB_REF.EQ.LAB_BLOCK(I)) THEN
          N_SEARCH=I
          GO TO 100
        END IF
      END DO
C
  100 CONTINUE
C
      IHEAD_MO=1
      DO I=1,N_SEARCH-1
        IHEAD_MO=IHEAD_MO+MSEGMENT(I)
      END DO
C
      N_MIXMO=MSEGMENT(N_SEARCH)
      RETURN
      END
C
C*MODULE DIAB    *DECK CALSUM_MORMO
      SUBROUTINE CALSUM_MORMO(NUM,N_ACTIVE,N_OVERLAP,INDMO_MIX,
     &                        IHEAD_MO,VEC_REF,VEC,W,SUM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION INDMO_MIX(N_ACTIVE)
      DIMENSION VEC_REF(NUM,N_OVERLAP)
      DIMENSION VEC(NUM,N_ACTIVE)
      DIMENSION W(NUM*(NUM+1)/2)
C
      PARAMETER (MXAO=8192)
      COMMON /IJPAIR/ IA(MXAO)
C
      DATA ZERO /0.0D+00/
C
C num    .... # of AO (basis set) (input & output)
C n_overlap...# of MOs to be overlaped (input & output)
C n_active
C vec_ref.... reference DMO/AO (input & output)
C vec    .... current MO/AO    (input & output)
C w      .... AO overlap       (input & output)
C indmo_mix
C ihead_mo
C
C Calculate MORMO term
C
      SUM=ZERO
      DO I=1,N_OVERLAP
        IND_V=INDMO_MIX(IHEAD_MO+I-1)
          DUM=ZERO
          DO J=1,NUM
            DO K=1,NUM
              IF (K.LE.J) THEN
                IND_JK=IA(J)+K
              ELSE
                IND_JK=+IA(K)+J
              END IF
              DUM=DUM+VEC_REF(J,I)*VEC(K,IND_V)*W(IND_JK)
          END DO
        END DO
        SUM=SUM+DUM**2
      END DO
C
      RETURN
      END
C
C*MODULE DIAB    *DECK CALDEL_MORMO
      SUBROUTINE CALDEL_MORMO1(NUM,V_I,V_J,VREF_I,VREF_J,W,A_IJ,B_IJ)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION V_I(NUM), V_J(NUM)
      DIMENSION VREF_I(NUM), VREF_J(NUM)
      DIMENSION W(NUM*(NUM+1)/2)
C
      PARAMETER (MXAO=8192)
      COMMON /IJPAIR/ IA(MXAO)
C
      DATA ZERO/0.0D+00/
      DATA  PT5/0.5D+00/
C
C num    .... # of AO (basis set)
C n_overlap...# of reference DMOs
C nmo_mix ... # of current MOs to be mixed with
C vref_i, vref_j.... reference DMO
C v_i, v_j    .... current MOs
C w      .... AO overlap
C
C Calculate a_ij and b_ij correlated with  MO Ovrelap term
C
C jac1 is <i> and jac2 is <j>:-->calculate s_i<i>,s_j<i>,s_i<j>,s_j<j>
C
C            --- s_i<i> and s_j<i> -----
C
Cc s_i<i>
C
      S_II=ZERO
      DO K=1,NUM
        DO L=1,NUM
          IF (L.LE.K) THEN
            IND_KL=IA(K)+L
          ELSE
            IND_KL=IA(L)+K
          END IF
          S_II=S_II+VREF_I(K)*V_I(L)*W(IND_KL)
        END DO
      END DO
C
Cc s_j<i>
C
      S_JI=ZERO
      DO K=1,NUM
        DO L=1,NUM
          IF (L.LE.K) THEN
            IND_KL=IA(K)+L
          ELSE
            IND_KL=IA(L)+K
          END IF
          S_JI=S_JI+VREF_I(K)*V_J(L)*W(IND_KL)
        END DO
      END DO
C
C               --- s_i<j> and s_j<j> -----
C
Cc s_i<j>
C
      S_IJ=ZERO
      DO K=1,NUM
        DO L=1,NUM
          IF (L.LE.K) THEN
            IND_KL=IA(K)+L
          ELSE
            IND_KL=IA(L)+K
          END IF
          S_IJ=S_IJ+VREF_J(K)*V_I(L)*W(IND_KL)
        END DO
      END DO
C
Cc s_j<j>
C
      S_JJ=ZERO
      DO K=1,NUM
        DO L=1,NUM
          IF (L.LE.K) THEN
            IND_KL=IA(K)+L
          ELSE
            IND_KL=IA(L)+K
          END IF
          S_JJ=S_JJ+VREF_J(K)*V_J(L)*W(IND_KL)
        END DO
      END DO
C
Cc Get a_ij and b_ij
C
      A_IJ=-PT5*S_II**2+PT5*S_JI**2+PT5*S_IJ**2-PT5*S_JJ**2
      B_IJ=-S_II*S_JI+S_IJ*S_JJ
      RETURN
      END
C
C*MODULE DIAB    *DECK CALDEL_MORMO2
      SUBROUTINE CALDEL_MORMO2(NUM,V_I,V_J,VREF_I,W,A_IJ,B_IJ)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION V_I(NUM),V_J(NUM)
      DIMENSION VREF_I(NUM)
      DIMENSION W(NUM*(NUM+1)/2)
C
      PARAMETER (MXAO=8192)
      COMMON /IJPAIR/ IA(MXAO)
C
      DATA ZERO/0.0D+00/
      DATA  PT5/0.5D+00/
C
C num    .... # of AO (basis set)
C n_overlap...# of reference DMOs
C nmo_mix ... # of current MOs to be mixed with
C vref_i ... reference DMO
C v_i, v_j   .... current MOs
C w      .... AO overlap
C
C Calculate a_ij and b_ij correlated with  MO Ovrelap term
C
C jac1 is <i>: <> is refernce DMO--> calculate only s_i<i>, s_j<i>
C
C           s_i<i>
C
      S_II=ZERO
      DO K=1,NUM
        DO L=1,NUM
          IF (L.LE.K) THEN
            IND_KL=IA(K)+L
          ELSE
            IND_KL=IA(L)+K
          END IF
          S_II=S_II+VREF_I(K)*V_I(L)*W(IND_KL)
        END DO
      END DO
C
C           s_j<i>
C
      S_JI=ZERO
      DO K=1,NUM
        DO L=1,NUM
          IF (L.LE.K) THEN
            IND_KL=IA(K)+L
          ELSE
            IND_KL=IA(L)+K
          END IF
          S_JI=S_JI+VREF_I(K)*V_J(L)*W(IND_KL)
        END DO
      END DO
C
C           Get  a_ij,b_ij
C
      A_IJ=-PT5*S_II**2+PT5*S_JI**2
      B_IJ=-S_II*S_JI
      RETURN
      END
C
C*MODULE DIAB    *DECK MOCOEFMIX
      SUBROUTINE MOCOEFMIX(V,W,WORK,NUM,GAMMA)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION V(NUM),W(NUM),WORK(NUM,2)
C
C   mix MO coefficients using 2x2 Jacobi matrix represented by GAMMA
C
      C=COS(GAMMA)
      S=SIN(GAMMA)
C
      DO I=1,NUM
        WORK(I,1)=C*V(I)-S*W(I)
        WORK(I,2)=S*V(I)+C*W(I)
      END DO
C
      DO I=1,NUM
        V(I)=WORK(I,1)
        W(I)=WORK(I,2)
      END DO
C
      RETURN
      END
C
C*MODULE DIAB    *DECK DETBLOCK
      SUBROUTINE DETBLOCK(NUM,N_ACTIVE,NSTATE,NDOC_CAND,
     &                    MOSLAB_ACTIVE,MOSLAB_PSEUDO,AVOCC_ACT,
     &                    SDOT,V,W,S,DM1,NDMAT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,MASWRK,DSKWRK
C
      DIMENSION MOSLAB_ACTIVE(N_ACTIVE)
      DIMENSION MOSLAB_PSEUDO(N_ACTIVE)
      DIMENSION AVOCC_ACT(N_ACTIVE)
      DIMENSION V(NUM,N_ACTIVE)
      DIMENSION W(NUM,N_ACTIVE)
      DIMENSION S(NUM*(NUM+1)/2)
      DIMENSION DM1(N_ACTIVE,N_ACTIVE,NDMAT)
C
      PARAMETER (MXDIABACT=30)
      DIMENSION IND_MO(MXDIABACT)
      DIMENSION INDTEMP0(MXDIABACT)
      DIMENSION INDTEMP1(MXDIABACT)
      DIMENSION INDTEMP2(MXDIABACT)
C
      COMMON /DIABAT/ ALPHA_N,ALPHA_R,ALPHA_T,
     *                TH_DOC,TH_VIR,SLCTTH,CONV_TH,WBLOCK(3),
     *                NDFRM,NDMOSYM,NRCSF,NMLAP,NDLAP,NORIENT,
     *                MOSLAB_CHARACT(MXDIABACT),
     *                MAX_ITER,NGRSTATE,NEXSTATE,NSTDIAB,
     *                NSYMBOL_DOC,NSYMBOL_VAL,NSYMBOL_VIR
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C This program classifies the (candidate) active DMOs to the three type,
C doc, valence, and virtual type with referring averaged occupation
C numbers ( and $DFMVEC, if available, i.e. ndfrm.ne.0)
C
C moslab_charact(i).... label to identify the i-th active MO
C                       (detemined by the threefold density criterion)
C                       belongs to
C                       =2  doubly occupied (doc)
C                       =1  valence
C                       =0  virtual
C                       (input & output)
C
C moslab_pseudo(i).... label to identify the i-th active MO belongs to
C                   =1 (not 2!)  target of catch and release as
C                      doc (not Vl!) block
C                   =0 not target (i.e. apparently vl and vir
C                                      or not apply C-R algorithm )
C                      (input & output)
C
C ndoc_cand      ..... # of candidate MO of doc block based on C-R
C                      algorithm. If C-R algorithm is Not applied,
C                      ndoc_cand=0 (input & output)
C
C v     .... MOs of the threefold density criterion (input)
C            output is reordered by taking overlap between $DFMVEC
C            for each block (doc/via/vir)
C
C avocc .... averaged occupation number of MOs of the threefold
C            density criterion (input). Output is reorderd.
C
C dm1   .... density matrices of MOs of the threefold density criterion
C            (input) Output is updated based on the new ordering
C            of the MOs
C
C w     .... temporary region e.g. to store (1) sym. orthogonalized
C            $DFMVEC etc
C
C s     .... AO overlap
C
C ind_mo ... index label to identify one-to-one correspondence
C            between v and w
C            Notice !!  ind_mo > 0----> the same sign
C                              < 0----> different sign
C            i-th current MO is odered to ind_mo(i)-th position
C            (indtemp0 is supported array for ind_mo)
C
      IF (NDFRM.EQ.0) THEN
        IF(MASWRK) WRITE(IW,9000)
        DO I=1,N_ACTIVE
          MOSLAB_CHARACT(I)=NSYMBOL_VAL
        END DO
        RETURN
      END IF
C
C Read (sym. orthogonalized) $DFMVEC from the scrach file
C
      CALL DAREAD(IDAF,IODA,W,NUM*N_ACTIVE,542,0)
C
C Check input of moslab_charact
C
      DO I=1,N_ACTIVE
        IF ((MOSLAB_CHARACT(I).NE.NSYMBOL_DOC).AND.
     &      (MOSLAB_CHARACT(I).NE.NSYMBOL_VAL).AND.
     &      (MOSLAB_CHARACT(I).NE.NSYMBOL_VIR)) THEN
          IF(MASWRK) WRITE(IW,*) '$DIABAT: MOSLAB HAS ILLEGAL VALUES.'
          CALL ABRT
        END IF
      END DO
C
C Initialization of ind_mo array as ) (dummy)
C
      DO I=1,N_ACTIVE
        IND_MO(I)=0
      END DO
C
C ------  Doc block ------
C
C           Pick up doc MO of $DFMVEC
C
      N_DOC=0
      DO I=1,N_ACTIVE
        IF (MOSLAB_CHARACT(I).EQ.NSYMBOL_DOC) THEN
          N_DOC=N_DOC+1
          INDTEMP1(N_DOC)=I
        END IF
      END DO
C
C         -- Select the candidate of doc MOs --
C
C         -- case A -- Catch and Release algorithm was applied
C
      IF (NDOC_CAND.NE.0) THEN
        ICOUNT=0
        DO I=1,N_ACTIVE
          IF (MOSLAB_PSEUDO(I).EQ.NSYMBOL_VAL) THEN
            ICOUNT=ICOUNT+1
            INDTEMP2(ICOUNT)=I
          END IF
        END DO
        NTEMP_DOC=NDOC_CAND
C         -- case B -- Catch and Release algorithm was Not applied
      ELSE IF (N_DOC.NE.0) THEN
        NTEMP_DOC=0
        DO I=1,N_ACTIVE
          IF (TH_DOC.LT.AVOCC_ACT(I)) THEN
            NTEMP_DOC=NTEMP_DOC+1
            INDTEMP2(NTEMP_DOC)=I
          END IF
        END DO
      END IF
C
C    --- in both cases, ntemp_doc is # of candidates MO for Doc block
C
      IF (N_DOC.LE.NTEMP_DOC) THEN
C
C         Determine n_doc MOs as doc MOs from ntemp_doc candidates
C
        DO I=1,N_ACTIVE
          INDTEMP0(I)=0
        END DO
C
        CALL DFRMCHECK(NUM,N_ACTIVE,N_DOC,NTEMP_DOC,
     &                 INDTEMP1,INDTEMP2,INDTEMP0,V,W,S,SDOT)
C
C         Doc part of ind_mo array is determined
C
        DO I=1,N_ACTIVE
          IF (INDTEMP0(I).NE.0) IND_MO(I)=INDTEMP0(I)
        END DO
      ELSE
        IF(MASWRK) THEN
          WRITE(IW,*) '# OF CANDIDATES MO FOR DOC BLOCK IS TOO SMALL,'
          WRITE(IW,*) 'DOC BLOCK IS IGNORED, AND TREATED AS VAL BLOCK'
        END IF
        DO I=1,N_ACTIVE
          IF (MOSLAB_CHARACT(I).EQ.NSYMBOL_DOC)
     &          MOSLAB_CHARACT(I)=NSYMBOL_VAL
        END DO
      END IF
C
C ------  Vir block ------
C
C            Pick up virtual  MO of $DFMVEC
C
      N_VIR=0
      DO I=1,N_ACTIVE
        IF (MOSLAB_CHARACT(I).EQ.NSYMBOL_VIR) THEN
          N_VIR=N_VIR+1
          INDTEMP1(N_VIR)=I
        END IF
      END DO
C
C          Select the candidate of vir MOs
C
      IF (N_VIR.NE.0) THEN
        NTEMP_VIR=0
        DO I=1,N_ACTIVE
          IF (AVOCC_ACT(I).LT.TH_VIR) THEN
            NTEMP_VIR=NTEMP_VIR+1
            INDTEMP2(NTEMP_VIR)=I
          END IF
        END DO
C
        IF (N_VIR.LE.NTEMP_VIR) THEN
C
C          Determine n_vir MOs as vir MOs from ntemp_vir candidates
C
          DO I=1,N_ACTIVE
            INDTEMP0(I)=0
          END DO
C
          CALL DFRMCHECK(NUM,N_ACTIVE,N_VIR,NTEMP_VIR,
     &                   INDTEMP1,INDTEMP2,INDTEMP0,V,W,S,SDOT)
C
C             Vir part of ind_mo is determined
C
          DO I=1,N_ACTIVE
            IF (INDTEMP0(I).NE.0) IND_MO(I)=INDTEMP0(I)
          END DO
        ELSE
          IF(MASWRK) THEN
            WRITE(IW,*) '# OF CANDIDATES MO FOR VIR BLOCK IS TOO SMALL,'
            WRITE(IW,*) 'VIR BLOCK IS IGNORED, AND TREATED AS VAL BLOCK'
          END IF
          DO I=1,N_ACTIVE
            IF (MOSLAB_CHARACT(I).EQ.NSYMBOL_VIR)
     &          MOSLAB_CHARACT(I)=NSYMBOL_VAL
          END DO
        END IF
      END IF
C
C             --- The rest is valence orb. ---
C
C                -- Pick up valence DMOs--
C
      N_VAL=0
      DO I=1,N_ACTIVE
        IF (MOSLAB_CHARACT(I).EQ.NSYMBOL_VAL) THEN
          N_VAL=N_VAL+1
          INDTEMP1(N_VAL)=I
        END IF
      END DO
C
      NTEMP_VAL=0
      DO I=1,N_ACTIVE
        IF (IND_MO(I).EQ.0) THEN
          NTEMP_VAL=NTEMP_VAL+1
          INDTEMP2(NTEMP_VAL)=I
        END IF
      END DO
C
      IF (NTEMP_VAL.NE.N_VAL) THEN
        IF(MASWRK) WRITE(IW,9040) NTEMP_VAL,N_VAL
        CALL ABRT
      END IF
C
      DO I=1,N_ACTIVE
        INDTEMP0(I)=0
      END DO
C
      CALL DFRMCHECK(NUM,N_ACTIVE,N_VAL,NTEMP_VAL,
     &               INDTEMP1,INDTEMP2,INDTEMP0,V,W,S,SDOT)
C
C         Val part of ind_mo is determined
C
      DO I=1,N_ACTIVE
        IF (INDTEMP0(I).NE.0) IND_MO(I)=INDTEMP0(I)
      END DO
C
C  Reorder the MOs
C
      DO  I=1,N_ACTIVE
        IF (IND_MO(I).LT.0) THEN
          DO J=1,NUM
            W(J,-IND_MO(I))=-V(J,I)
          END DO
        ELSE
          DO J=1,NUM
            W(J,IND_MO(I))=V(J,I)
          END DO
        END IF
      END DO
C
      DO I=1,N_ACTIVE
        DO J=1,NUM
          V(J,I)=W(J,I)
        END DO
      END DO
C
C Reorder elements of DMs (Notice: With sign change of MOs, each
C                                  DM elements change)
C
      DO IDM=1,NDMAT-1
C             --- change row and column
        DO I=1,N_ACTIVE
          IF (IND_MO(I).LT.0) THEN
            IND_I=-IND_MO(I)
          ELSE
            IND_I=IND_MO(I)
          END IF
          DO J=1,N_ACTIVE
            IF (IND_MO(J).LT.0) THEN
              IND_J=-IND_MO(J)
            ELSE
              IND_J=IND_MO(J)
            END IF
            W(IND_J,IND_I)=DM1(J,I,IDM)
          END DO
        END DO
C                --- change sign of elements
        DO I=1,N_ACTIVE
          IF (IND_MO(I).LT.0) THEN
            IND_I=-IND_MO(I)
            DO J=1,N_ACTIVE
              W(J,IND_I)=-W(J,IND_I)
            END DO
          END IF
        END DO
        DO I=1,N_ACTIVE
          IF (IND_MO(I).LT.0) THEN
            IND_I=-IND_MO(I)
            DO J=1,N_ACTIVE
              W(IND_I,J)=-W(IND_I,J)
            END DO
          END IF
        END DO
C
C           --- update dm ----
C
        DO I=1,N_ACTIVE
          DO J=1,N_ACTIVE
            DM1(J,I,IDM)=W(J,I)
          END DO
        END DO
      END DO
C
      CALL MKSTAVGDM1(DM1,NDMAT,N_ACTIVE,NSTATE)
C
C           Reorder irreps label
C
      DO I=1,N_ACTIVE
        INDTEMP1(I)=MOSLAB_ACTIVE(I)
      END DO
      DO I=1,N_ACTIVE
        IF (IND_MO(I).LT.0) THEN
          MOSLAB_ACTIVE(-IND_MO(I))=INDTEMP1(I)
        ELSE
          MOSLAB_ACTIVE(IND_MO(I))=INDTEMP1(I)
        END IF
      END DO
C
C            Reorder avocc
C
      DO I=1,N_ACTIVE
         AVOCC_ACT(I)=DM1(I,I,NDMAT)
      END DO
      RETURN
C
 9000 FORMAT(1X,'$DFMVEC IS NOT AVAILABLE.'/
     *       1X,'ALL ACTIVE MOS ARE TREATED AS VALENCE BLOCK,'/
     *       1X,'AND THE FOURFOLD WAY WILL CONTINUE.')
 9040 FORMAT(1X,'DETBLOCK: SOMETHING IS WRONG'/
     *       1X,'NTEMP_VAL=',I5,' DOES NOT MATCH N_VAL=',I5)
      END
C
C*MODULE DIAB    *DECK DFRMCHECK
      SUBROUTINE DFRMCHECK(NUM,N_ACTIVE,NB_DET,NB_TEMP,
     &                     INDB_REF,INDB_CRRT,ISTACK,V,W,S,STORE_DOT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION INDB_REF(NB_DET)
      DIMENSION INDB_CRRT(NB_TEMP)
      DIMENSION ISTACK(N_ACTIVE)
      DIMENSION V(NUM,N_ACTIVE)
      DIMENSION W(NUM,N_ACTIVE)
      DIMENSION S(NUM*(NUM+1)/2)
      DIMENSION STORE_DOT(NB_DET,NB_TEMP)
C
      PARAMETER (MXAO=8192)
      COMMON /IJPAIR/ IA(MXAO)
C
      DATA ZERO/0.0D+00/
C
C This routine make index array to represent one-to-one
C correspondence between some of -V- and -W-
C
C v  ... MO coefficient of active space at the current geometry
C        return without modification
C
C w  ... DMO coefficients at the reference geometry etc.
C
C s  ... AO overlap
C
C n_active   ... # of active orbitals
C
C nb_det     ... # of MOs to be assigned
C
C nb_temp    ... # of MOs of candidates to be assinged
C                i.e. nb_det MO are assigned (nb_det < or = nb_temp)
C
C indb_ref   ... index array to identify the referenced MO to be
C                used to assign nb_det MOs
C
C indb_crrt   ... index array to identify the current nb_det MOs to be
C                assigned
C
C store_dot(i,j): overlap-like quantity <u_i($DFMVEC)|u_j(current)>
C
C istack(1:n_active): i-th stored current DMO is ordered to the
C                     istack(i)-th position
C
C (Notice (1) Also this array shows the sign. if the overlap-like
C             quantity is smaller than 0, the value of istack(i) is <0
C         (2) As dummy value istack(i) is 0 when input.
C             In this routine the nb_det MO's positions are
C             determined; thus nb_det elements of istack array become
C             non 0 (i.e. non dummy) values.)
C
C Zero clear
C
       DO J=1,NB_TEMP
         DO I=1,NB_DET
           STORE_DOT(I,J)=ZERO
         END DO
       END DO
C
C ---- Check of deformation ------
C
C Step(1) Calculate overlap matrix between reference's DMO
C block and current MO block
C
      DO I=1,NB_DET
        DO J=1,NB_TEMP
          DUM=ZERO
          DO K=1,NUM
            DO L=1,NUM
              IF (L.LE.K) THEN
                IND_KL=IA(K)+L
              ELSE
                IND_KL=IA(L)+K
              END IF
              DUM=DUM+W(K,INDB_REF(I))*V(L,INDB_CRRT(J))*S(IND_KL)
            END DO
          END DO
          STORE_DOT(I,J)=DUM
        END DO
      END DO
C
C Step(2) Search maximum overlaping and determine the one-to-one
C correspondence of nb_det MOs
C
      DO I=1,NB_DET
C
C Search max element of store_dot  : maxvalue = store_dot(i_ref,i_crrt)
C
        DUM_MAX=ZERO
        DO J=1,NB_TEMP
          DO K=1,NB_DET
            DUM=ABS(STORE_DOT(K,J))
            IF (DUM_MAX.LT.DUM) THEN
              DUM_MAX=DUM
              I_REF=K
              I_CRRT=J
            END IF
          END DO
        END DO
C
C Now correspondence between indb_ref(i_ref)-th $DFMVEC (i-th MO of the
C block defined by indb_ref) and indb_crrt(i_crrt)-th MO
C are determined
C
C
C Index array
C
        IF (STORE_DOT(I_REF,I_CRRT).LT.ZERO) THEN
          ISTACK(INDB_CRRT(I_CRRT))=-INDB_REF(I_REF)
        ELSE
          ISTACK(INDB_CRRT(I_CRRT))=INDB_REF(I_REF)
        END IF
C
C The all values of store_dot(*,i_crrt) and
C store_dot(i_ref,*) are replaced by
C dummy value zero because the above correspondence are determied
C
        DO J=1,NB_DET
          STORE_DOT(J,I_CRRT)=ZERO
        END DO
        DO J=1,NB_TEMP
          STORE_DOT(I_REF,J)=ZERO
        END DO
      END DO
      RETURN
      END
C
C*MODULE DIAB    *DECK ORDDMO
      SUBROUTINE ORDDMO(NUM,N_ACTIVE,NSTATE,
     &                  MOSLAB_ACTIVE,DM1,NDMAT,AVOCC,V,W,S,SDOT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION MOSLAB_ACTIVE(N_ACTIVE)
      DIMENSION DM1(N_ACTIVE,N_ACTIVE,NDMAT)
      DIMENSION AVOCC(N_ACTIVE)
      DIMENSION V(NUM,N_ACTIVE)
      DIMENSION S(NUM*(NUM+1)/2)
      DIMENSION W(NUM,N_ACTIVE)
      DIMENSION SDOT(N_ACTIVE,N_ACTIVE)
C
      PARAMETER (MXDIABACT=30)
      DIMENSION IND_MO(MXDIABACT)
      DIMENSION INDTEMP0(MXDIABACT)
      DIMENSION INDTEMP1(MXDIABACT)
C
      COMMON /DIABAT/ ALPHA_N,ALPHA_R,ALPHA_T,
     *                TH_DOC,TH_VIR,SLCTTH,CONV_TH,WBLOCK(3),
     *                NDFRM,NDMOSYM,NRCSF,NMLAP,NDLAP,NORIENT,
     *                MOSLAB_CHARACT(MXDIABACT),
     *                MAX_ITER,NGRSTATE,NEXSTATE,NSTDIAB,
     *                NSYMBOL_DOC,NSYMBOL_VAL,NSYMBOL_VIR
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
C
C This routine determine final ordering ( after threefold or
C fourfold way) of DMOs by using $DFMVEC
C The target DMOs for ordering belong to "valence" block.
C The positions of other DMOs (doc, and vir block) are already
C determined before this stage, i.e. in the routine DETBLOCK.
C
C v .... DMOs at current geometry
C w .... $DFMVEC (sym. orthogonalized) to be used for deformation check.
C
C Initializaton of index array ind_mo
C
C Note: The order of Doc and Vir block MOs is already fixed, but
C       to use ind_mo(1:n_active), this initialization is required.
C
      DO I=1,N_ACTIVE
        IND_MO(I)=I
      END DO
C
C             Read sym. orthogonalized $DFMVEC (ndfrm=1) or
C             standard Fock canonical orbitals (ndfrm=0).
C
      CALL DAREAD(IDAF,IODA,W,NUM*N_ACTIVE,542,0)
C
C             Pick up Val block MOs
C
      N_VAL=0
      DO I=1,N_ACTIVE
        IF (MOSLAB_CHARACT(I).EQ.NSYMBOL_VAL) THEN
          N_VAL=N_VAL+1
          INDTEMP1(N_VAL)=I
        END IF
      END DO
C
C             deformation check and sort
C
      DO I=1,N_ACTIVE
        INDTEMP0(I)=0
      END DO
C
      CALL DFRMCHECK(NUM,N_ACTIVE,N_VAL,N_VAL,INDTEMP1,INDTEMP1,
     &               INDTEMP0,V,W,S,SDOT)
C
C             Val part of ind_mo array is determined
C
      DO I=1,N_ACTIVE
        IF (INDTEMP0(I).NE.0) IND_MO(I)=INDTEMP0(I)
      END DO
C
C Now, ind_mo(1:n_active) array is completely determined
C (i.e. All (doc+val+vir) block part DMOs are identified.)
C
C             Reorder the MOs
C
      DO  I=1,N_ACTIVE
        IF (IND_MO(I).LT.0) THEN
          DO J=1,NUM
            W(J,-IND_MO(I))=-V(J,I)
          END DO
        ELSE
          DO J=1,NUM
            W(J,IND_MO(I))=V(J,I)
          END DO
        END IF
      END DO
C
      DO I=1,N_ACTIVE
        DO J=1,NUM
          V(J,I)=W(J,I)
        END DO
      END DO
C
C Reorder elements of DMs (Notice: With sign change of MOs, each
C                                  DM elements change)
C
      DO IDM=1,NDMAT-1
C                     --- change row and column
        DO I=1,N_ACTIVE
          IF (IND_MO(I).LT.0) THEN
            IND_I=-IND_MO(I)
          ELSE
            IND_I=IND_MO(I)
          END IF
          DO J=1,N_ACTIVE
            IF (IND_MO(J).LT.0) THEN
              IND_J=-IND_MO(J)
            ELSE
              IND_J=IND_MO(J)
            END IF
            W(IND_J,IND_I)=DM1(J,I,IDM)
          END DO
        END DO
C                 --- change sign of elements
        DO I=1,N_ACTIVE
          IF (IND_MO(I).LT.0) THEN
            IND_I=-IND_MO(I)
            DO J=1,N_ACTIVE
              W(J,IND_I)=-W(J,IND_I)
            END DO
          END IF
        END DO
        DO I=1,N_ACTIVE
          IF (IND_MO(I).LT.0) THEN
            IND_I=-IND_MO(I)
            DO J=1,N_ACTIVE
              W(IND_I,J)=-W(IND_I,J)
            END DO
          END IF
        END DO
C                 --- update dm
        DO I=1,N_ACTIVE
          DO J=1,N_ACTIVE
            DM1(J,I,IDM)=W(J,I)
          END DO
        END DO
      END DO
C
      CALL MKSTAVGDM1(DM1,NDMAT,N_ACTIVE,NSTATE)
C
C Reorder irreps label
C
      DO I=1,N_ACTIVE
        INDTEMP1(I)=MOSLAB_ACTIVE(I)
      END DO
      DO I=1,N_ACTIVE
        IF (IND_MO(I).LT.0) THEN
          MOSLAB_ACTIVE(-IND_MO(I))=INDTEMP1(I)
        ELSE
          MOSLAB_ACTIVE(IND_MO(I))=INDTEMP1(I)
        END IF
      END DO
C
C Reorder avocc
C
      DO I=1,N_ACTIVE
        AVOCC(I)=DM1(I,I,NDMAT)
      END DO
C
C--- for debug ---
C      write(6,*) 'Debug in orddmo'
C      write(6,*) 'i, ind_mo(i)'
C      do i=1,n_active
C        write(6,*) i,ind_mo(i)
C      end do
C-----------------
      RETURN
      END
C
C*MODULE DIAB    *DECK PRLAPDMO
      SUBROUTINE PRLAPDMO(NUM,N_ACTIVE,V,W,S,SDOT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,MASWRK,DSKWRK
C
      DIMENSION S(NUM*(NUM+1)/2)
      DIMENSION V(NUM,N_ACTIVE)
      DIMENSION W(NUM,N_ACTIVE)
      DIMENSION SDOT(N_ACTIVE,N_ACTIVE)
C
      PARAMETER (MXAO=8192)
C
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA ZERO/0.0D+00/
C
C v ... the current DMO coefficients (input and output)
C w ... sym. orth. $DFMVEC
C s ... AO overlap (input and output)
C sdot(i,j) ... <$DIAVEC_i|DMO_j>
C
C             Read sym. orthogonalized $DFMVEC (ndfrm=1) or
C             standard Fock canonical orbitals (ndfrm=0).
C
      CALL DAREAD(IDAF,IODA,W,NUM*N_ACTIVE,542,0)
C
C Calculate overlap-like quantity
C
      CALL VCLR(SDOT,1,N_ACTIVE*N_ACTIVE)
C
      DO I=1,N_ACTIVE
        DO J=1,N_ACTIVE
          DUM=ZERO
          DO K=1,NUM
            DO L=1,NUM
              IF (L.LE.K) THEN
                IND_KL=IA(K)+L
              ELSE
                IND_KL=IA(L)+K
              END IF
              DUM=DUM+W(K,I)*V(L,J)*S(IND_KL)
            END DO
          END DO
          SDOT(I,J)=DUM
        END DO
      END DO
C
C Print out overlap-like matrix
C
      IF(MASWRK) WRITE(IW,9800)
      CALL PRSQ(SDOT,N_ACTIVE,N_ACTIVE,N_ACTIVE)
      RETURN
 9800 FORMAT(/23X,'OVERLAP MATRIX BETWEEN'/
     *        12X,'SYMMETRICALLY ORTHOGONALIZED REFERENCE ORBITALS'/
     *        20X,'AND DIABATIC MOLECULAR ORBITALS'/
     *        18X,'(ROWS= ORTH. $DFMVEC, COLS= DMO''S)')
      END
C
C*MODULE DIAB    *DECK RDCSFGRPS
      SUBROUTINE RDCSFGRPS(NSTDIAB,NLIST,COEF,LIST_CSF,LIST_GROUP,
     &                     MAXLIST,MAXRT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION COEF(MAXLIST,MAXRT)
      DIMENSION LIST_CSF(MAXLIST)
      DIMENSION LIST_GROUP(MAXLIST)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      CHARACTER*8 REFCSF
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA REFCSF /' $REFCSF'/
C
C Read data of dominant CSFs...input group $REFCSF:
C   LIST_CSF(i): dominant CSF index
C LIST_GROUP(i): Group index  where LIST_CSF(i)-th CSF belongs to
C     COEF(i,j): CI coefficents for diabatic states of LIST_CSF(i)-th
C                CSF for j-th diabatic states
C
      IF(MASWRK) WRITE(IW,9020) REFCSF
      CALL SEQREW(IR)
      CALL FNDGRP(IR,REFCSF,IEOF)
C
      IF(IEOF.GT.0) THEN
         IF(MASWRK) WRITE(IW,9030) REFCSF
         CALL ABRT
      END IF
C
C          -- read dominant CSF list and group --
C
      IF(MASWRK) READ(IR,*) NLIST
      IF(GOPARR) CALL DDI_BCAST(2151,'I',NLIST,1,MASTER)
C
      IF(NLIST.GT.MAXLIST) THEN
         IF(MASWRK) THEN
           WRITE(IW,*) 'STORAGE PROBLEM READING $REFCSF'
           WRITE(IW,*) 'YOUR INPUT IS NLIST=',NLIST
           WRITE(IW,*) 'MAXIMUM ALLOWED IS',MAXLIST
         END IF
         CALL ABRT
      END IF
C
      IF(MASWRK) THEN
         MAX=0
   25    CONTINUE
         MIN=MAX+1
         MAX=MAX+5
         IF (MAX.GT.NLIST) MAX=NLIST
         READ(IR,9910) (LIST_CSF(I),LIST_GROUP(I),I=MIN,MAX)
         IF (MAX.LT.NLIST) GO TO 25
C
C    -- read reference CI coefficients in $REFCSF for each set of DMOs
C
         DO J=1,NSTDIAB
           MAX=0
   30      CONTINUE
           MIN=MAX+1
           MAX=MAX+5
           IF (MAX.GT.NLIST) MAX=NLIST
           IF (NLIST.LE.99) READ(IR,9920) (COEF(I,J),I=MIN,MAX)
           IF (NLIST.GT.99) READ(IR,9920) (COEF(I,J),I=MIN,MAX)
           IF (MAX.LT.NLIST) GO TO 30
         END DO
      END IF
C
      IF(GOPARR) THEN
         CALL DDI_BCAST(2152,'I',LIST_CSF  ,NLIST        ,MASTER)
         CALL DDI_BCAST(2153,'I',LIST_GROUP,NLIST        ,MASTER)
         CALL DDI_BCAST(2154,'F',COEF      ,NLIST*NSTDIAB,MASTER)
      END IF
C
      RETURN
C
 9910 FORMAT(I8,'(',I2,')')
 9920 FORMAT(5X,5E15.8)
 9020 FORMAT(1X,'READING DOMINANT CSF INFORMATION FROM THE',A8,
     *          ' INPUT GROUP.')
 9030 FORMAT(1X,'*** ERROR ***'/
     *       1X,'UNABLE TO FIND REQUIRED DOMINANT CSF INFO IN THE',
     *          A8,' GROUP.')
      END
C
C*MODULE DIAB    *DECK REFADIAB
C>
C>    @brief   reference CAS or QDPT states
C>
C>    @details CAS-level or QDPT-level adiabatic states are read from
C>             disk, the latter are approximated by rotating the CAS
C>             states by the same rotation that diagonalized the
C>             2nd order Hamiltonian.
C>
      SUBROUTINE REFADIAB(MODE,NFT21,LIST_CSF,LIST_GROUP,DCICOEF,
     &                    CIVEC,LEVIR,ICASE,IECONF,IECASE,IARC,
     &                    ECI_SAV,ISTACK,TAB_COEF,IOUTIV,
     &                    QDPTROT,WRKROT,CIMXMC,CIMXPT,
     &                    NLIST,MAXLIST,MAXRT,NSTDMO,NDIMQD,
     &                    NWKS,NROWS,NROWS4,NBF,NCIVEC)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK,SVDSKW
C
      DIMENSION LIST_CSF(MAXLIST)
      DIMENSION LIST_GROUP(MAXLIST)
      DIMENSION DCICOEF(MAXLIST,MAXRT)
      DIMENSION CIVEC(NWKS,NCIVEC)
      DIMENSION LEVIR(NBF)
      DIMENSION ICASE(NBF)
      DIMENSION IECONF(NBF)
      DIMENSION IECASE(NBF)
      DIMENSION IARC(NROWS4)
      DIMENSION ECI_SAV(NSTDMO)
      DIMENSION ISTACK(NSTDMO)  ! STACK ARRAY FOR VARIOUS INDEX
      DIMENSION TAB_COEF(MAXLIST)
      DIMENSION IOUTIV(NBF)
C                  NDIMQD is the same as NSTDIAB if doing MCQDPT,
C                  or is set to 1 if CAS is not using this storage.
      DIMENSION QDPTROT(NDIMQD,NDIMQD),WRKROT(NDIMQD)
      DIMENSION CIMXMC(10,NDIMQD),CIMXPT(10,NDIMQD)
C
      PARAMETER (MXRT=100)
      PARAMETER (MXDIABACT=30)
C
      COMMON /DIABAT/ ALPHA_N,ALPHA_R,ALPHA_T,
     *                TH_DOC,TH_VIR,SLCTTH,CONV_TH,WBLOCK(3),
     *                NDFRM,NDMOSYM,NRCSF,NMLAP,NDLAP,NORIENT,
     *                MOSLAB_CHARACT(MXDIABACT),
     *                MAX_ITER,NGRSTATE,NEXSTATE,NSTDIAB,
     *                NSYMBOL_DOC,NSYMBOL_VAL,NSYMBOL_VIR
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ZERO=0.0D+00)
C
      DATA NFT11  /11/
      DATA NFT12  /12/
      DATA CVGTOL /1.0D-05/
C
C MODE=0 or 1  ... determines if CAS or MCQDPT level call
C LIST_CSF(i)  ... i-th dominant CSF inex
C LIST_GROUP(i)...Group index where i-th dominant CSF belongs to
C NLIST        ... total # of dominant CSFs.
C --->If LIST_CSF,LIST_GROUP, and NLIST are already defined by $REFCSF,
C     they are input and not changed. If not, this routine makes list
C     and return. In the latter case, users should understand that
C     the return is only for dominant CSFs based on DMO set.
C     i.e, not always enough dominant CSFs for global nuclear coordinate
C     region.
C DCICOEF(i,j)...CI coef of j-th adiabatic state of i-th dominant CSF
C NSTDMO... total # of target adiabatic states for diabatization,
C           plus those below ignored below the diabatization range.
C ECI_SAV ... adiabatic CAS-CI or QDPT energies of diabatization targets
C
C             Read header of FT12 (CI vectors)
C
      SVDSKW = DSKWRK
      DSKWRK = .FALSE.
C
      CALL SEQREW(NFT12)
      IF(MASWRK) READ(NFT12) NSTATECI,NWKSCI
      IF(GOPARR) CALL DDI_BCAST(2161,'I',NSTATECI,1,MASTER)
      IF(GOPARR) CALL DDI_BCAST(2162,'I',NWKSCI  ,1,MASTER)
      IF(NWKSCI.NE.NWKS) THEN
         IF(MASWRK) WRITE(IW,*) 'REFDIA: CI VECTOR FILE CONFUSION'
         CALL ABRT
      END IF
C
C              ---- locate CAS-CI target states ----
C
      IF(MODE.EQ.0) THEN
         IF (NDMOSYM.EQ.0) THEN
C
C            Search suitable target states for the case where the DMO's
C            break orbital symmetry, by matching energies to the MCSCF.
C
           IF(MASWRK) WRITE(IW,9010)
           ICOUNT=0
           DO I=1,NSTDMO
             DO J=1,NSTATECI
               DUM=ABS(ESTATE(J)-ECI_SAV(I))
               IF (DUM.LT.CVGTOL) THEN
                 ICOUNT=ICOUNT+1
                 ISTACK(ICOUNT)=J
               END IF
             END DO
           END DO
           IF (ICOUNT.NE.NSTDMO) THEN
             IF(MASWRK) WRITE(IW,9020)
             CALL ABRT
           ELSE
             IF(MASWRK) WRITE(IW,9030)
           END IF
C             copy only target CI vectors to FT21, for PRTADIAB's use.
C             we loop over states here, and again inside PRTADIAB,
C             so only one CI vector storage is needed.
           CALL SEQREW(NFT21)
           ICOUNT=1
           DO I=1,NSTATECI
             CALL SQREAD(NFT12,CIVEC,NWKS)
             IF (I.EQ.ISTACK(ICOUNT)) THEN
               CALL SQWRIT(NFT21,CIVEC,NWKS)
               ICOUNT=ICOUNT+1
             END IF
             IF (NSTDMO.LT.ICOUNT) GO TO 100
           END DO
           CALL SEQREW(NFT12)
           CALL SEQREW(NFT21)
C
C            the more typical path, where DMOs do possess symmetry.
C            the CI vectors in FT12 are used directly, no FT21 file.
C
         ELSE
           DO I=1,NSTDMO
             ISTACK(I)=I
           END DO
           NFT21_SAV=NFT21
           NFT21=NFT12
         END IF
      END IF
C
C              ---- create QDPT-CI target states ----
C     this is of course just an approximation: apply the rotation
C     that diagonalizes the 2nd order Hamiltonian to the 1st order
C     CI vectors, to produce updated CI vectors.
C     The adiabatic state's energy values need to be QDPT as well.
C
      IF(MODE.EQ.1) THEN
C
C            Obtain all CI vectors, for CAS-level DMO-based CI states.
C
         DO IST=1,NSTDMO
            CALL SQREAD(NFT12,CIVEC(1,IST),NWKS)
         ENDDO
         CALL SEQREW(NFT12)
C
C            Apply QDPT state rotation, with a stab at phase control.
C               See inside SIFTADIAB for the reasoning used here!
C
         CALL SIFTADIAB(CIVEC(1,NGRSTATE+1),CIMXMC,NWKS,NSTDIAB)
         CALL DAREAD(IDAF,IODA,CIMXPT,NSTDIAB*10,545,0)
         CALL DAREAD(IDAF,IODA,QDPTROT,NSTDIAB*NSTDIAB,543,0)
C
         DO IST=1,NSTDIAB
            OVLP = DDOT(MIN(10,NWKS),CIMXMC(1,IST),1,CIMXPT(1,IST),1)
            FACT = DDOT(MIN(10,NWKS),CIMXMC(1,IST),1,CIMXMC(1,IST),1)
            OVLP = OVLP/FACT
            IF(ABS(OVLP).GT.0.9D+00) THEN
               IF(OVLP.LT.ZERO) THEN
                  IF(MASWRK) WRITE(IW,9110) IST
                  DO JST=1,NSTDIAB
                     QDPTROT(IST,JST) = -QDPTROT(IST,JST)
                  ENDDO
               END IF
            ELSE
               IF(MASWRK) THEN
                  WRITE(IW,9300)
                  WRITE(IW,9310)
                  CALL PRSQ(CIMXMC,NSTDIAB,MIN(10,NWKS),10)
                  WRITE(IW,9320)
                  CALL PRSQ(CIMXPT,NSTDIAB,MIN(10,NWKS),10)
               END IF
               CALL ABRT
            END IF
         ENDDO
C
         IF(MASWRK) WRITE(IW,9120)
         CALL PRSQ(QDPTROT,NSTDIAB,NSTDIAB,NSTDIAB)
         CALL TRAN(CIVEC(1,NGRSTATE+1),NWKS,NSTDIAB,QDPTROT,NSTDIAB,
     *             WRKROT,NSTDIAB)
C
C            output CI vector file, with no header record
C
         CALL SEQREW(NFT21)
         DO IST=1,NSTDMO
            CALL SQWRIT(NFT21,CIVEC(1,IST),NWKS)
         ENDDO
         CALL SEQREW(NFT21)
C
C            grab the MCQDPT state energies.
C
         DO IST=1,NGRSTATE
            ECI_SAV(IST) = 0.0D+00
         ENDDO
         CALL DAREAD(IDAF,IODA,ECI_SAV(NGRSTATE+1),NSTDIAB,544,0)
C
      END IF
C
C 1. Print the largest -CI- coefficients, and occupancy details.
C 2. Also, generate the CI vector subsets -DCICOEF- which
C    contain coefs for the user input's dominant CSF list.
C
  100 CONTINUE
C
      CALL PRTADIAB(NRCSF,NFT11,NFT12,NFT21,NSTDMO,NWKS,ECI_SAV,
     &              CIVEC,SLCTTH,LEVIR,ICASE,IECONF,IECASE,IARC,
     &              LIST_CSF,LIST_GROUP,DCICOEF,TAB_COEF,IOUTIV,
     &              NLIST,NBF,NROWS4,NROWS,MAXLIST,MAXRT)
C
C Print -CI- coefficients for every CSF in the list of dominant CSFs.
C
      IF(MASWRK) THEN
         IF(MODE.EQ.0) WRITE(IW,9220)
         IF(MODE.EQ.1) WRITE(IW,9225)
         WRITE(IW,9228)
         DO I=1,NSTDMO
           WRITE(IW,9230) I,ECI_SAV(I)
           WTTOT = 0.0D+00
           DO J=1,NLIST
              WRITE(IW,9240) LIST_CSF(J),LIST_GROUP(J),DCICOEF(J,I)
              WTTOT = WTTOT + DCICOEF(J,I)**2
           END DO
           WRITE(IW,9250) WTTOT
         END DO
      END IF
C
C         Back parameter NFT21 to the original value, if necessary
C
      IF(MODE.EQ.0  .AND.  NDMOSYM.NE.0) NFT21=NFT21_SAV
      DSKWRK = SVDSKW
      RETURN
C
 9010 FORMAT(1X,'--- DMOS HAVE BROKEN ORBITAL SYMMETRY ---'/
     *       1X,'TO ENSURE MATCHING STATES ARE USED, COMPARING THE'/
     *       1X,'STATE ENERGIES BETWEEN MCSCF AND DMO-BASED CAS-CI')
 9020 FORMAT(1X,'ERROR: CANNOT FIND SUITABLE STATES.'/
     *       1X,'YOU MAYBE NEED A LARGER VALUE OF NSTATE?  STOP')
 9030 FORMAT(1X,'SUITABLE STATE MATCHES WERE FOUND!')
 9110 FORMAT(1X,'ADJUSTING PHASE OF CAS-CI STATE',I4,
     *          ' TO MATCH MCQDPT STATE''S PHASE')
 9120 FORMAT(1X,'THE PHASE-ADJUSTED ROTATION FROM CAS-CI TO MCQDPT',
     *          ' STATES IS')
 9220 FORMAT(/1X,47(1H-)/
     *       1X,'CI COEFFICIENTS OF DOMINANT CSFS FOR ALL GROUPS'/
     *       1X,47(1H-))
 9225 FORMAT(/1X,49(1H-)/
     *       1X,'CI COEFS OF DOMINANT CSFS IN MCQDPT PSEUDO-STATES'/
     *       1X,49(1H-))
 9228 FORMAT(1X,'ONLY CONFIGURATIONS ENTERED IN $REFCSF WILL BE',
     *          ' PRINTED BELOW.'/
     *       1X,'IF THE TOTAL WEIGHT OF THE DOMINANT CSF LIST IN',
     *          ' ANY ADIABATIC STATE IS SMALL,'/
     *       1X,'THE LIST OF DOMINANT CSF''S GIVEN IN THE INPUT',
     *          ' SHOULD BE RECONSIDERED.'/)
 9230 FORMAT(1X,'ADIABATIC STATE #',I5,' ENERGY =',F18.9/
     *       1X,'     CSF   GROUP #   COEFFICIENT')
 9240 FORMAT(1X,I8,5X,I3,3X,F12.6)
 9250 FORMAT(1X,'TOTAL WEIGHT OF ALL DOMINANT CSFS IN THIS STATE IS',
     *           2P,F5.1,'%'/)
 9300 FORMAT(1X,'REFDIAB: FATAL CAS-CI STATE PHASE PROBLEM DETECTED'/
     *       1X,'CANNOT MATCH UP STATES IN THE NEXT SETS OF STATES:')
 9310 FORMAT(1X,'THE LARGEST COEFS IN THE DMO BASED CAS-CI ARE')
 9320 FORMAT(1X,'THE LARGEST COEFS IN THE MCQDPT CAS-CI STATES ARE')
      END
C
C*MODULE DIAB    *DECK SIFTADIAB
C>
C>    @brief     CAS/QDPT phase adjustment
C>
C>    @details   attempt to assign same phase to CAS and QDPT states.
C>
      SUBROUTINE SIFTADIAB(CIVEC,CIMAX,NCI,NSTATE)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION CIVEC(NCI,NSTATE),CIMAX(10,NSTATE)
      DIMENSION IWORK(10)
      PARAMETER (ZERO=0.0D+00)
C
C         Pick out the largest ten CI coefs, and save in CIMAX.
C         on exit, the original CIVEC states are left unchanged.
C
C         This is called twice,
C         once to extract the largest components of the GUGA program's
C              CAS-CI states evaluated with DMOs,
C         once to extract the largest components of the MCQDPT program's
C              CAS-CI states, also evaluated with DMOs.
C
C         Since both sets of CAS-CI states use the same DMOs, there
C         should not be any ambiguity caused by orbital phase changes.
C
C         Unfortunately comparing the two sets of CI coeficients
C         directly may fail, as the two GUGA-based codes use
C         different spin functions for CSFs with unpaired electrons.
C         The thinking here is best in case of the lead terms being
C         CSFs like 222..22000..000 for singlets, or 22..221100..00
C         with minimum number of alpha spins, for higher multiplicities,
C         where there are no spin-function differences.
C
C         Why save 10 instead of just the largest 1, you might ask?
C         In case of high symmetry, such as half filled pi states,
C         the CI vector might be xx-yy (or xx+yy) where there could
C         be confusion about the "largest" coefficient of the
C         two equal values.
C
C         Saving a bit more of the CI vector should let us detect if
C         either problem happens, but not fix it.
C
      DO IST=1,NSTATE
         DO K=1,MIN(10,NCI)
            L = IDAMAX(NCI,CIVEC(1,IST),1)
            IWORK(K) = L
            CIMAX(K,IST) = CIVEC(L,IST)
            CIVEC(L,IST) = ZERO
         ENDDO
         DO K=1,MIN(10,NCI)
            CIVEC(IWORK(K),IST) = CIMAX(K,IST)
         ENDDO
      ENDDO
      RETURN
      END
C
C*MODULE DIAB    *DECK PRTADIAB
C>
C>    @brief   print adiabatic state information, w/CSF occupancy
C>
C>    @details get coefs of all dominant CSFs in all adiabatic states
C>
      SUBROUTINE PRTADIAB(NRCSF,NFT11,NFT12,NFT21,NST,NWKS,
     &                    EIGVAL,EIGVEC,SLCTTH,
     &                    LEVIR,ICASE,IECONF,IECASE,IARC,
     &                    LIST_CSF,LIST_GROUP,DCICOEF,
     &                    TAB_COEF,IOUTIV,
     &                    NLIST,NBF,NROWS4,NROWS,MAXLIST,MAXRT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION EIGVAL(NST)
      DIMENSION EIGVEC(NWKS)
      DIMENSION LEVIR(NBF),ICASE(NBF),IECONF(NBF),IECASE(NBF)
      DIMENSION IARC(NROWS4)
      DIMENSION LIST_CSF(MAXLIST)
      DIMENSION LIST_GROUP(MAXLIST)
      DIMENSION DCICOEF(MAXLIST,MAXRT)
      DIMENSION TAB_COEF(MAXLIST)
      DIMENSION IOUTIV(NBF)
C
      DIMENSION ISHIFT(4)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXAO=8192)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /ORBSET/ NORBMX,NORBS,NCORBS,NLEVS,NA,NB,NC,NSYM,MSYM,
     *                IDOC,IVAL,IMCC,ISYM(MXAO),ICODE(MXAO),
     *                NLCS(MXAO),LEVPT(MXAO),LEVNR(MXAO),
     *                IOUT(MXAO),NREFS,IEXCT,NFOCI,INTACT
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA ZERO /0.0D+00/
C
C Zero clear (input dummy value) for list array, if list_csf etc
C are not given as input (i.e. nrcsf = 0 )
C
      IF (NRCSF.EQ.0) THEN
        DO I=1,MAXLIST
          LIST_CSF(I)=0
          LIST_GROUP(I)=0
          TAB_COEF(I)=ZERO
        END DO
        CALL VCLR(DCICOEF,1,MAXLIST*MAXRT)
      END IF
C
C     ----- CREATE INVERSE MAPPING OF ORBITALS -----
C
      N=0
      DO I=1,NBF
         IF(IOUT(I).LT.0) N=N+1
      END DO
C
      DO I=1,NBF
         IF(IOUT(I).GT.0) THEN
            IOUTIV(IOUT(I))=I-N
         END IF
      END DO
C
C     ----- PRINT COEFFICIENTS OF CI VECTORS LARGER THAN SLCTTH -----
C           THE ELECTRON OCCUPANCY IS ALSO PRINTED
C
      DO  K = 1,4
        ISHIFT(K) = (K-1)*NROWS
      END DO
C
      CALL SEQREW(NFT11)
      IF(MASWRK) THEN
         DO I=1,13
           READ(NFT11) ! SKIP HEADER ETC
         END DO
         READ(NFT11) IARC
      END IF
      IF(GOPARR) CALL DDI_BCAST(2163,'I',IARC,NROWS4,MASTER)
      CALL SEQREW(NFT11)
C
      NCORB = 0
      DO I=1,NORBMX
        IF(IOUT(I).LT.0) NCORB = NCORB+1
      END DO
C
C Search Domain CSF and make some list for grouping by reading CI
C vectors.  If taken directly from GAMESS' CI vector file,
C skip over the header record.
C
      CALL SEQREW(NFT21)
      IF (NFT21.EQ.NFT12) CALL SEQADV(NFT21)
C
      IF(MASWRK) WRITE(IW,9010) SLCTTH
C
      ICOUNT=0
      DO KSTAT = 1,NST
        CALL SQREAD(NFT21,EIGVEC,NWKS)
        IF(MASWRK) WRITE(IW,9999) KSTAT,EIGVAL(KSTAT)
        IWKS = 0
        LEV = 1
        LEVM = 1
        IR0 = 1
  100   CONTINUE
        IF (LEV .EQ. NLEVS) GO TO 140
        LEVIR(LEV) = IR0
        LEVM = LEV
        LEV = LEVM+1
        LEVIR(LEV) = LEVNR(LEV)+1
  110   CONTINUE
        IR0 = LEVIR(LEV)
        NPTX = LEVPT(LEV)
        NPTM = LEVPT(LEVM)
        IRM = LEVIR(LEVM)
  120   CONTINUE
        IR0 = IR0-1
        IF (IR0 .EQ. 0) GO TO 300
        NPT = IR0+NPTX
        DO 130 K = 1,4
          IARPT = NPT+ISHIFT(K)
          JARC = IARC(IARPT)
          IF (JARC .EQ. 0) GO TO 130
          JARC = JARC-NPTM
          ICASE(LEVM) = K
          IF (IRM .EQ. JARC) GO TO 100
  130   CONTINUE
        GO TO 120
C
  140   CONTINUE
C
        DO 250 ILEV = 1,NORBS
          ICAS = ICASE(ILEV)
          GO TO (200,210,210,220), ICAS
  200     IOCC = 0
          GO TO 230
  210     IOCC = 1
          GO TO 230
  220     IOCC = 2
  230     CONTINUE
          IORB=-2**20
          DO 240 I = 1,NORBMX
            IF (IOUT(I) .EQ. ILEV) IORB = I
  240     CONTINUE
          IECONF(IORB) = IOCC
          IECASE(ILEV) = ICAS
  250   CONTINUE
C
        IWKS = IWKS+1
        DUM = EIGVEC(IWKS)
        IF(ABS(DUM).GE.SLCTTH) THEN
           IF(MASWRK) WRITE(IW,9998) IWKS,DUM,
     1                    (IECONF(NCORB+IORB),IORB=1,NORBS)
C
C         make list array if list_csf etc are not given as input
C
          IF (NRCSF.EQ.0) THEN
            IUPDATE=0
            DO ILIST=1,ICOUNT
              IF (LIST_CSF(ILIST).EQ.IWKS) THEN
                IUPDATE=ILIST ! CHECK DOUBLE COUNT ABOUT THE CSF
              END IF
            END DO
            IF (IUPDATE.EQ.0) THEN
              ICOUNT=ICOUNT+1
              LIST_CSF(ICOUNT)=IWKS
              TAB_COEF(ICOUNT)=ABS(DUM)
              LIST_GROUP(ICOUNT)=KSTAT
            ELSE IF (TAB_COEF(IUPDATE).LT.ABS(DUM)) THEN ! UPDATE LIST
              TAB_COEF(IUPDATE)=ABS(DUM)
              LIST_GROUP(IUPDATE)=KSTAT
            END IF
          END IF
C
        END IF
300     CONTINUE
        LEV=LEVM
        LEVM=LEV-1
        IF (LEVM.GT.0) GO TO 110
      END DO
      NLIST0=ICOUNT
C
      IF (NRCSF.EQ.0) NLIST=NLIST0
C
C Pick up CI coefficents of dominant CSFs for all target states
C and store them to DCICOEF array
C
      CALL SEQREW(NFT21)
      IF (NFT21.EQ.NFT12) CALL SEQADV(NFT21)  ! SKIP HEADER IF FT12
C
      DO I=1,NST
        CALL SQREAD(NFT21,EIGVEC,NWKS)
        DO ICSF=1,NLIST
          DCICOEF(ICSF,I)=EIGVEC(LIST_CSF(ICSF))
        END DO
      END DO
      CALL SEQREW(NFT21)
      RETURN
C
 9010 FORMAT(/1X,51(1H-)/
     &       1X,'CSF EXPANSION BASED ON DMO''S AS THE ACTIVE ORBITALS'/
     &       1X,51(1H-)/
     *       1X,'PRINTING ALL CI COEFFICIENTS LARGER THAN SLCTTH=',
     *           1P,E10.1,0P,','/
     *       1X,'EVEN IF THEY AREN''T IN THE DOMINANT CSF INPUT.')
 9999 FORMAT(/1X,'ADIABATIC STATE #',I5,'  ENERGY =',F18.9/
     2        6X,'CSF',4X,'COEFFICIENT',4X,'OCCUPANCY'/
     3        6X,'---',4X,'-----------',4X,'---------')
 9998 FORMAT(1X,I8,5X,F10.6,4X,60I1/(28X,60I1/))
      END
C
C*MODULE DIAB    *DECK MKDIAB
C>
C>    @brief    make diabatic states
C>
C>    @details  perform diabatization, and print diabatic state info
C>
      SUBROUTINE MKDIAB(MODE,NRCSF,E_ADIABAT,NLIST,
     &                  LIST_GROUP,LIST_CSF,DCICOEF,DCICOEF_REF,
     &                  DCICOEF2,T,TP,S,EIGVAL,EIG_BUFF,
     &                  STRI,IWORK,WRKVEC,U,BUFF,WORK,
     &                  NSTDMO,NGRSTATE,NSTDIAB,MAXLIST,MAXRT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION LIST_GROUP(MAXLIST)
      DIMENSION LIST_CSF(MAXLIST)
      DIMENSION DCICOEF_REF(MAXLIST,MAXRT)
      DIMENSION DCICOEF(MAXLIST,MAXRT)
      DIMENSION DCICOEF2(MAXLIST,MAXRT)
      DIMENSION E_ADIABAT(MAXRT)
      DIMENSION T(NSTDIAB,NSTDIAB)
      DIMENSION TP(NSTDIAB,NSTDIAB)
      DIMENSION S(NSTDIAB,NSTDIAB)
      DIMENSION EIGVAL(NSTDIAB)
      DIMENSION EIG_BUFF(NSTDIAB)
      DIMENSION STRI(*)
      DIMENSION IWORK(NSTDIAB),WRKVEC(NSTDIAB)
      DIMENSION U(NSTDIAB,NSTDIAB)
      DIMENSION BUFF(NSTDIAB,NSTDIAB)
      DIMENSION WORK(MAXLIST,NSTDIAB)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA ZERO /0.0D+00/
      DATA ONE  /1.0D+00/
      DATA ERR_TH/1.0D-04/
C
C        note that -NSTDIAB- is effective number of states, the
C        number of states diabatized skipping past -NGRSTATE- roots.
C        The value -NSTDMO- is number of states being diabatized,
C        and equals NGRSTATE + NSTDMO.
C
      L1=NSTDMO
C
C
C Symmetrized Orthogonalization for truncated CI states
C
C
Cc Make S (approximated overlap) matrix
C
      II = 1 + NGRSTATE
C
      DO ISTAT=II,L1
        DO JSTAT=II,L1
          S(ISTAT-NGRSTATE,JSTAT-NGRSTATE)=ZERO
          DO K=1,NLIST
            S(ISTAT-NGRSTATE,JSTAT-NGRSTATE)=
     &      S(ISTAT-NGRSTATE,JSTAT-NGRSTATE)
     &      + DCICOEF(K,ISTAT)*DCICOEF(K,JSTAT)
          END DO
        END DO
      END DO
C
C               Diagonalize S matrix
C         eigenvectors must be in -descending- order of eigenvalue!
C
      CALL CPYSQT(S,STRI,NSTDIAB,1)
      NTRI = (NSTDIAB*NSTDIAB+NSTDIAB)/2
      CALL DSCAL(NTRI,-ONE,STRI,1)
      CALL JACDG(STRI,U,EIGVAL,IWORK,WRKVEC,NSTDIAB,NSTDIAB)
      CALL DSCAL(NSTDIAB,-ONE,EIGVAL,1)
C
      DO I=II,L1
        IF(EIGVAL(I-NGRSTATE).LT.ERR_TH) THEN
           IF(MASWRK) WRITE(IW,9200)
           CALL ABRT
        END IF
        EIGVAL(I-NGRSTATE)=ONE/SQRT(EIGVAL(I-NGRSTATE))
      END DO
C
C
C Project to each (diabatic) subspace i.e group G_k
C
C
      DO K_GRP=II,L1
C                  Make S_k matrix
        DO ISTAT=II,L1
          DO JSTAT=II,L1
            S(ISTAT-NGRSTATE,JSTAT-NGRSTATE)=ZERO
            DO K=1,NLIST
              IF (LIST_GROUP(K).EQ.K_GRP) THEN
                S(ISTAT-NGRSTATE,JSTAT-NGRSTATE)=S(ISTAT-NGRSTATE,
     $          JSTAT-NGRSTATE) +DCICOEF(K,ISTAT)*DCICOEF(K,JSTAT)
              END IF
            END DO
          END DO
        END DO
C                  Make R_k matrix
        CALL DGEMM('T','N',L1-NGRSTATE,L1-NGRSTATE,L1-NGRSTATE,ONE,U,
     $             L1-NGRSTATE,S,L1-NGRSTATE,ZERO,BUFF,L1-NGRSTATE)
        CALL DGEMM('N','N',L1-NGRSTATE,L1-NGRSTATE,L1-NGRSTATE,ONE,BUFF,
     $             L1-NGRSTATE,U,L1-NGRSTATE,ZERO,S,L1-NGRSTATE)
C                 Now s is Us^{t}*S_k*Us
        DO I=II,L1
          DO J=II,L1
            S(I-NGRSTATE,J-NGRSTATE)=EIGVAL(I-NGRSTATE)
     $      *S(I-NGRSTATE,J-NGRSTATE)
          END DO
        END DO
        DO J=II,L1
          DO I=II,L1
            S(I-NGRSTATE,J-NGRSTATE)=EIGVAL(J-NGRSTATE)*S(I-NGRSTATE,
     $      J-NGRSTATE)
          END DO
        END DO
C
        CALL DGEMM('N','N',L1-NGRSTATE,L1-NGRSTATE,L1-NGRSTATE,ONE,U,
     $             L1-NGRSTATE,S,L1-NGRSTATE,ZERO,BUFF,L1-NGRSTATE)
        CALL DGEMM('N','T',L1-NGRSTATE,L1-NGRSTATE,L1-NGRSTATE,ONE,BUFF,
     $             L1-NGRSTATE,U,L1-NGRSTATE,ZERO,S,L1-NGRSTATE)
C
C            Diagonalize R_k matrix (stored at -s-)
C
        CALL CPYSQT(S,STRI,NSTDIAB,1)
        NTRI = (NSTDIAB*NSTDIAB+NSTDIAB)/2
        CALL DSCAL(NTRI,-ONE,STRI,1)
        CALL JACDG(STRI,BUFF,EIG_BUFF,IWORK,WRKVEC,NSTDIAB,NSTDIAB)
        CALL DSCAL(NSTDIAB,-ONE,EIG_BUFF,1)
C
Cc determine T' matrix 's k_grp-th column
C
        DO I=II,L1
          TP(I-NGRSTATE,K_GRP-NGRSTATE)=BUFF(I-NGRSTATE,1)
        END DO
C
      END DO
C
C
C              Symmetrized Orthogonalization of T' matrix
C         i.e. Make Unitary adiabatic/diabatic transform matrix
C
C
      CALL DGEMM('T','N',L1-NGRSTATE,L1-NGRSTATE,L1-NGRSTATE,ONE,TP,
     $           L1-NGRSTATE,TP,L1-NGRSTATE,ZERO,BUFF,L1-NGRSTATE)
C
      CALL CPYSQT(BUFF,STRI,NSTDIAB,1)
      NTRI = (NSTDIAB*NSTDIAB+NSTDIAB)/2
      CALL DSCAL(NTRI,-ONE,STRI,1)
      CALL JACDG(STRI,U,EIGVAL,IWORK,WRKVEC,NSTDIAB,NSTDIAB)
      CALL DSCAL(NSTDIAB,-ONE,EIGVAL,1)
C
      DO I=II,L1
        IF (EIGVAL(I-NGRSTATE).LT.ERR_TH) THEN
           IF(MASWRK) WRITE(IW,9200)
           CALL ABRT
        END IF
        EIGVAL(I-NGRSTATE)=ONE/SQRT(EIGVAL(I-NGRSTATE))
      END DO
C
      CALL DGEMM('N','N',L1-NGRSTATE,L1-NGRSTATE,L1-NGRSTATE,ONE,TP,
     $           L1-NGRSTATE,U,L1-NGRSTATE,ZERO,S,L1-NGRSTATE)
C
      DO J=II,L1
        DO I=II,L1
          BUFF(I-NGRSTATE,J-NGRSTATE)=EIGVAL(J-NGRSTATE)
     $             * S(I-NGRSTATE,J-NGRSTATE)
        END DO
      END DO
C
      CALL DGEMM('N','T',L1-NGRSTATE,L1-NGRSTATE,L1-NGRSTATE,ONE,BUFF,
     $           L1-NGRSTATE,U,L1-NGRSTATE,ZERO,T,L1-NGRSTATE)
C
C
C     Now -T- is adiabatic/diabatic transformation (not sign arranged)
C
C
C     Make sign arrangement for each column vector of -T- and make
C     CI coefficients for 'truncated' diabatic states
C
      IF (NRCSF.EQ.0) GO TO 100 ! SKIP THIS PROCEDURE
C
C           set matrix shapes
      LDA=MAXLIST
      LDB=NSTDMO-NGRSTATE
      LDC=MAXLIST
C
      DO J=1,NLIST
       DO I=II,NSTDMO
        DCICOEF2(J,I-NGRSTATE)=DCICOEF(J,I)
       END DO
      END DO
C
      CALL DGEMM('N','N',NLIST,NSTDMO-NGRSTATE,NSTDMO-NGRSTATE,ONE,
     &           DCICOEF2,LDA,T,LDB,ZERO,WORK,LDC)
C
      DO K=II,NSTDMO
        DUM=ZERO
        DO J=1,NLIST
          DUM=DUM+WORK(J,K-NGRSTATE)*DCICOEF_REF(J,K)
        END DO
        IF (DUM.LT.ZERO) THEN
          DO J=II,NSTDMO
            T(J-NGRSTATE,K-NGRSTATE)=-T(J-NGRSTATE,K-NGRSTATE)
          END DO
          DO J=1,NLIST
            DCICOEF(J,K)=-WORK(J,K-NGRSTATE)
          END DO
        ELSE
          DO J=1,NLIST
            DCICOEF(J,K)=WORK(J,K-NGRSTATE)
          END DO
        END IF
      END DO
C
C        Now DCICOEF is transformed to the ci coefficients of
C        diabatic states (Diabatic template)
C
  100 CONTINUE
C
C
C          Make diabatic Hamiltonian matrix in TP:
C            TP = [T-dagger * H(adiabatic)] * T
C
C
      DO I=II,L1
        DO J=II,L1
          BUFF(I-NGRSTATE,J-NGRSTATE)=T(J-NGRSTATE,I-NGRSTATE)
        END DO
      END DO
C
      DO J=II,L1
        DO I=II,L1
          BUFF(I-NGRSTATE,J-NGRSTATE) =
     &                BUFF(I-NGRSTATE,J-NGRSTATE) * E_ADIABAT(J)
        END DO
      END DO
C
      CALL DGEMM('N','N',L1-NGRSTATE,L1-NGRSTATE,L1-NGRSTATE,ONE,
     $           BUFF,L1-NGRSTATE,T,L1-NGRSTATE,ZERO,TP,L1-NGRSTATE)
C
C
      IF(MASWRK) THEN
C
C Print out Diabatic Hamiltonian matrix elements
C
         WRITE(IW,9010)
         DO I=II,NSTDMO
           IF(MODE.EQ.0) THEN
              WRITE(IW,9020) I,'CAS',TP(I-NGRSTATE,I-NGRSTATE)
           ELSE
              WRITE(IW,9020) I,'MCQDPT',TP(I-NGRSTATE,I-NGRSTATE)
           END IF
         END DO
C
         WRITE(IW,9030)
         DO I=II,NSTDMO-1
           DO J=I+1,NSTDMO
             IF(MODE.EQ.0) THEN
               WRITE(IW,9040) I,J,'CAS',TP(I-NGRSTATE,J-NGRSTATE)
             ELSE
               WRITE(IW,9040) I,J,'MCQDPT',TP(I-NGRSTATE,J-NGRSTATE)
             END IF
           END DO
         END DO
C
C Print out Diabatic templates
C
         WRITE(IW,9050)
         DO I=II,NSTDMO
           WRITE(IW,9060) I
           DO J=1,NLIST
             IF (LIST_GROUP(J).EQ.I) THEN
               WRITE(IW,9070) LIST_CSF(J),DCICOEF(J,I)
             END IF
           END DO
         END DO
C
C Print out Transformation matrix
C
         WRITE(IW,9080)
         CALL PRSQ(T,NSTDIAB,NSTDIAB,NSTDIAB)
      END IF
      RETURN
C
 9010 FORMAT(/1X,'-------------------------------------------'/
     &        1X,'  - DIABATIC HAMILTONIAN MATRIX ELEMENTS - '/
     &        1X,'-------------------------------------------'/
     &        1X,'                                           '/
     &        1X,'--- DIABATIC ENERGIES (DIAGONAL ELEMENT) ---')
 9020 FORMAT(1X,'STATE #',I3,'''S ',A,'-LEVEL DIABATIC ENERGY=',
     *          F18.9)
 9030 FORMAT(/1X,'--- DIABATIC COUPLINGS (OFF DIAGONAL ELEMENTS)---')
 9040 FORMAT(1X,'STATE #',I3,' &',I3,'''S ',A,'-LEVEL COUPLING  =',
     &          F18.9)
 9050 FORMAT(/1X,'---------------------------------------'/
     &        1X,'         - DIABATIC STATES -           '/
     &        1X,'---------------------------------------')
 9060 FORMAT(1X,'STATE # ',I2/1X,10(1H-)/
     &       1X,'   <CSF>      <COEFFICIENT>')
 9070 FORMAT(1X,I7,5X,F12.6)
 9080 FORMAT(/1X,'---------------------------------------'/
     &        1X,'    - ROTATION TO DIABATIC STATES -    '/
     &        1X,'---------------------------------------'/
     &        1X,'ROWS=ADIABATIC, COLUMNS=DIABATIC STATES')
 9200 FORMAT(1X,'MKDIAB: CANNOT SYMMETRICALLY ORTHOGONALIZE. STOP')
      END
C
C*MODULE DIAB    *DECK PUCSFGRPS
      SUBROUTINE PUCSFGRPS(NSTATE,NLIST,COEF,LIST_CSF,LIST_GROUP,
     &                     MAXLIST,MAXCI)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
C
      DIMENSION LIST_CSF(MAXLIST)
      DIMENSION LIST_GROUP(MAXLIST)
      DIMENSION COEF(MAXLIST,MAXCI)
C
      CHARACTER*8 REFCSF,ENDWRD
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA REFCSF /' $REFCSF'/
      DATA ENDWRD /' $END   '/
C
C        ---- punch out data for dominant CSFs ----
C
      IF(.NOT.MASWRK) RETURN
C
      WRITE(IP,9900) REFCSF
C
      WRITE(IP,*) NLIST
      MAX=0
10    MIN=MAX+1
      MAX=MAX+5
      IF (MAX.GT.NLIST) MAX=NLIST
      WRITE(IP,9910) (LIST_CSF(I),LIST_GROUP(I),I=MIN,MAX)
      IF (MAX.LT.NLIST) GO TO 10
C         -- punch out diabatic CI coefficients for each set of DMOs
      DO J=1,NSTATE
        JCOUNT=0
        MAX=0
20      MIN=MAX+1
        MAX=MAX+5
        JCOUNT=JCOUNT+1
        IF (MAX.GT.NLIST) MAX=NLIST
        IF (NLIST.LE.99) WRITE(IP,9920) J,JCOUNT,
     &                     (COEF(I,J),I=MIN,MAX)
        IF (NLIST.GT.99) WRITE(IP,9930) J,JCOUNT,
     &                     (COEF(I,J),I=MIN,MAX)
        IF (MAX.LT.NLIST) GO TO 20
      END DO
C
      WRITE(IP,9900) ENDWRD
      RETURN
C
9900  FORMAT(A8)
9910  FORMAT(I8,'(',I2,')')
9920  FORMAT(I2,I3,5E15.8)
9930  FORMAT(I3,I2,5E15.8)
C
      END
