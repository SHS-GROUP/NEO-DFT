C 19 Oct 12 - MWS - provide missing comma in a format.
C  2 Sep 12 - MWS - port from HONDO-PLUS into GAMESS
C xx Sep 06 - RV  - modifications by Valero
C xx Feb 02 - HN  - original implementation by Nakamura/Truhlar
C
C*MODULE DIAB    *DECK DIABATX
      SUBROUTINE DIABATX(NWFNFLG)
C
C--   IMPLICIT double precision(A-H,O-Z)
      IMPLICIT NONE
      DOUBLE PRECISION METHOD
      DOUBLE PRECISION ACURCY, ALDET, ALPHA_N, ALPHA_R, ALPHA_T,
     *                 AVOCC_ACT, C, CHECK, CISTEP, CONV_TH,
     *                 CRIT, DAMP, DRTNAM, DWPARM, E, E1, E2,
     *                 ECI_SAV, ECORE, EDFT, EDISP, EELCT, EERD,
     *                 EG, EKIN, ENGTOL, ENUCR, EPOT, ESCF,
     *                 ESTATE, ETOT, EXETYP, FINALCI, GLIST,
     *                 GRPDET, GUGA, PRTTOL, RUNTYP, SDET,
     *                 SLCTTH, SPINS, STATN, STSYM, SZ, SZDET,
     *                 SZZ, TH_DOC, TH_VIR, TWO, VEE, VEN,
     *                 WAVGGUGA, WBLOCK, WSTATE, WTDIAB,
     *                 WTMCSCF, X, ZAN, ZERO
      INTEGER I, IAN, IAVGGUGA, IBTYP, ICH, ICICIGUGA,
     *        ICOUNT, IDAF, IDAF20, IDIABAT, IDUM, IDWEIGH,
     *        IEXCITGUGA, IFORSGUGA, IGPDET, IJK, IJKT,
     *        IODA, IP, IPRINT, IPSI, IPTIM, IPURES, IR,
     *        IROOT, IROOTSV, ISKPRP, ISPST, IST, ITEMP,
     *        IW, IWST, IWTS, K, KDET, KSTDET, KSTSYM,
     *        LAB_C1, LACTMO, LAST, LBUFF, LCIVEC, LDCI,
     *        LDCIREF, LDCIRF2, LDENS, LDFMO, LDPSMO,
     *        LEIGBUF, LEIGVAL, LENGY, LEVAL, LEVEC,
     *        LIARC, LICASE, LIECASE, LIECONF, LIOUTIV,
     *        LISTACK, LIWORK, LIWRK, LLEVIR, LLSTCSF,
     *        LLSTGRP, LMODEG, LMOIRP, LMOLAB, LOADFM,
     *        LQ, LRMOLAB, LS, LSAO, LSMO, LSTRI, LT,
     *        LTABCF, LTDM, LTP, LTRANS, LTRI, LU, LV,
     *        LVEC, LWORK, LWRK, LWRKVEC, MASTER, MAXLIST,
     *        MAXP, MAXRT, MAXW1, MAX_ITER, MCFMO, ME,
     *        MICIT, MOFRZ, MOSLAB_ACTIVE, MOSLAB_CHARACT,
     *        MOSLAB_PSEUDO, MOSLAB_REFDMO, MOSLAB_REFPS,
     *        MUL, MXATM, MXDIABACT, MXNORO, MXRT, N1,
     *        N2, NACT, NACTDET, NADET, NAINF, NALPGUGA,
     *        NAOSGUGA, NAT, NAV, NAVGGUGA, NBDET, NBF,
     *        NBF2, NBF3, NBINF, NBOSGUGA, NCIDET, NCORBS,
     *        NCORDET, NCORSV, NDFRM, NDLAP, NDMAT, NDMOSYM,
     *        NDOC, NDOCGUGA, NDOC_CAND, NE, NEED,
     *        NEEDDIAB, NEEDDMO, NEEDTDM, NEMEMX,
     *        NEVALS, NEXSTATE, NEXTGUGA, NFLGDM,
     *        NFT11, NFT12, NFT13, NFT14, NFT15,
     *        NFT16, NFT21, NFTGCI, NFZCGUGA, NFZVGUGA,
     *        NGLEVL, NGRSTATE, NHLEVL, NITDET, NLIST,
     *        NMCCGUGA, NMLAP, NOFO, NOIRRGUGA, NORBDET,
     *        NORBMC, NORBS, NORIENT, NOROT, NPFLG, NPROC,
     *        NQMT, NRCSF, NROWS, NSTATE, NSTDIAB, NSTDMO,
     *        NSTTOP, NSYMBOL_DOC, NSYMBOL_VAL, NSYMBOL_VIR,
     *        NUM, NVALGUGA, NWKS, NWORD, NWFNFLG
C
      CHARACTER*8 DIAVECW,DFRMVECW,DPSVECW,FRDCW,FRVLW,ENDWRD
C
      LOGICAL GOPARR,DSKWRK,MASWRK,SVDSKW,
     *        CANONC,FCORE,FORS,EKT,LINSER,AVGGUGA
      LOGICAL DOCORE,DOOOOO,DOVOOO,DOVVOO,DOVOVO,DOVVVO,DOVVVV,
     *        DOEXCH,DOFOCK,DDITRF
      LOGICAL OFFSYM,STDPHASE
C
      PARAMETER (MXATM=2000, MXRT=100, MXNORO=250)
C
C        effectively remove active space size limit by making it huge.
      PARAMETER (MXDIABACT=30)
C
C        symmetry labels for various orbitals, for active space only.
      DIMENSION MOSLAB_ACTIVE(MXDIABACT)
      DIMENSION MOSLAB_REFDMO(MXDIABACT)
      DIMENSION MOSLAB_REFPS(MXDIABACT)
      DIMENSION MOSLAB_PSEUDO(MXDIABACT)
C        averaged occupation number of the active MOs
      DIMENSION AVOCC_ACT(MXDIABACT)
      DIMENSION ITEMP(MXDIABACT)
C
      DIMENSION ECI_SAV(MXRT)
C
      COMMON /CIFILS/ NFT11,NFT12,NFT13,NFT14,NFT15,NFT16,IDAF20,NEMEMX
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,SDET,SZDET,
     *                GRPDET,STSYM,GLIST,DWPARM,NFLGDM(MXRT),
     *                IWTS(MXRT),NCORSV,NCORDET,NACTDET,NORBDET,
     *                NADET,NBDET,KDET,KSTDET,IROOT,IPURES,MAXW1,NITDET,
     *                MAXP,NCIDET,IGPDET,KSTSYM,NFTGCI,IDWEIGH
      COMMON /DIABAT/ ALPHA_N,ALPHA_R,ALPHA_T,
     *                TH_DOC,TH_VIR,SLCTTH,CONV_TH,WBLOCK(3),
     *                NDFRM,NDMOSYM,NRCSF,NMLAP,NDLAP,NORIENT,
     *                MOSLAB_CHARACT(MXDIABACT),
     *                MAX_ITER,NGRSTATE,NEXSTATE,NSTDIAB,
     *                NSYMBOL_DOC,NSYMBOL_VAL,NSYMBOL_VIR
      COMMON /DM2AVG/ WAVGGUGA(MXRT),IAVGGUGA(MXRT),NAVGGUGA,AVGGUGA
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FMCOM / X(1)
      COMMON /FUNCT / E,EG(3*MXATM)
      COMMON /GUGWFN/ NFZCGUGA,NMCCGUGA,NDOCGUGA,NAOSGUGA,NBOSGUGA,
     *                NALPGUGA,NVALGUGA,NEXTGUGA,NFZVGUGA,IFORSGUGA,
     *                IEXCITGUGA,ICICIGUGA,NOIRRGUGA
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NAINF,NBINF,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWORD,NORBMC,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PSILVL/ IPSI,ISKPRP
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      INTEGER         D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB
      LOGICAL         NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
      COMMON /TRFDMS/ D_OOOO,D_VOOO,D_VVOO,D_VOVO,D_VVVO,D_VVVV,
     *                D_OOOOAB,D_OOOOBB,D_VOOOAB,D_VOOOBA,D_VOOOBB,
     *                D_VVOOAB,D_VVOOBA,D_VVOOBB,D_VOVOAB,D_VOVOBB,
     *                D_U,D_UB,D_E,D_EB,
     *                NDOOOO,NDVOOO,NDVVOO,NDVOVO,NDVVVO,NDVVVV,NDCORE,
     *                NDVVOOBA,NDVVOOAB,NDVVOOBB,NDVOVOAB,NDVOVOBB,
     *                NDVOOOBA,NDVOOOAB,NDVOOOBB,NDOOOOAB,NDOOOOBB
C
      DATA GUGA,ALDET/8HGUGA    ,8HALDET   /
      DATA DRTNAM/8HDRT     /
      DATA CHECK/8HCHECK   /
C
      DATA ZERO          /0.0D+00/
      DATA TWO           /2.0D+00/
      DATA LAB_C1       /4HA   /
C
      DATA DIAVECW  /' $DIAVEC'/
      DATA DFRMVECW /' $DFMVEC'/
      DATA DPSVECW  /' $DPSVEC'/
      DATA FRDCW    /' $LCLDC '/
      DATA FRVLW    /' $LCLVL '/
      DATA ENDWRD   /' $END   '/
C
C             program for diabatization by the four-fold way
C       written by Hisao Nakamura, Rosendo Valero, and Donald Truhlar
C             for U. Minnesota's HONDO-PLUS, in 2002 and 2006
C                           inspired by:
C       G.J.Atchity, K.Ruedenberg  Theoret.Chem.Acc. 97, 47-58(1997)
C                   whose basic method is extended by:
C       H.Nakamura, D.G.Truhlar J.Chem.Phys. 115, 10353-10372(2001)
C       H.Nakamura, D.G.Truhlar J.Chem.Phys. 117, 5576-5593(2002)
C                       with certain applications:
C       H.Nakamura, D.G.Truhlar J.Chem.Phys. 118, 6816-6829(2003)
C       R.Valero, D.G.Truhlar   J.Chem.Phys. 125, 194305/1-22(2006)
C       Z.H.Li, R.Valero, D.G.Truhlar Theor.Chem.Acc. 118, 9-24(2007)
C       R.Valero, D.G.Truhlar  J.Phys.Chem.A 111, 8536-8551(2007)
C       R.Valero, D.G.Truhlar  J.Phys.Chem.A 112, 5756-5769(2008)
C
C            ported from HONDO+ to GAMESS in summer 2012
C                     at Iowa State University
C
C            ==============  Start  ============
C
C     nwfnflg=0 --> CAS-based diabatization only
C     nwfnflg=1 --> Preconditioner for MC-QDPT diabatization
C
      IF (NWFNFLG.EQ.0) THEN
        IF(MASWRK) WRITE(IW,9010)
      ELSE
        IF(MASWRK) WRITE(IW,9020)
        IF(MASWRK) WRITE(IW,9030)
      END IF
C
C     Check that the -MC- orbitals are CASSCF type or not
C
      IF (CISTEP.NE.GUGA  .AND.  CISTEP.NE.ALDET) THEN
        IF(MASWRK) WRITE(IW,9040)
        CALL ABRT
      END IF
C
C          ---- Set some orbital parameters ----
C     nbf:    # of AOs
C     ncorbs: # of core (i.e. doubly occupied) orbitals
C     nact:   # of active orbitals
C     norbs:  # of occupied MOs = core + active
C
      NBF=NUM
C
      IF(CISTEP.EQ.ALDET) THEN
         NCORBS = NCORSV
         NACT = NACTDET
      END IF
      IF(CISTEP.EQ.GUGA) THEN
         NCORBS = NMCCGUGA
         NACT = NDOCGUGA + NALPGUGA + NAOSGUGA + NBOSGUGA + NVALGUGA
      END IF
      NORBS=NCORBS+NACT
C
C              ----- count how many states are involved -----
C         NSTATE is number of all states computed, with correct spin.
C         NSTTOP is the "top" state with a non-zero weight, note
C                that states below NSTTOP might have zero weight.
C         NSTDIAB is number of states being diabatized,
C                namely NSTATE excluding NGRSTATE and NEXSTATE.
C         NSTDMO is number of states included during DMO generation,
C                usually NGRSTATE + NSTDIAB = NSTATE - NEXSTATE.
C
      IF(CISTEP.EQ.GUGA) THEN
         NSTATE = INT(STATN+0.1D+00)
         NSTTOP = IAVGGUGA(NAVGGUGA)
      END IF
      IF(CISTEP.EQ.ALDET) THEN
         NSTATE = 0
         DO IST=1,KDET
           IF(ABS(SPINS(IST)-SDET) .LT. 0.03D+00) NSTATE=NSTATE+1
         ENDDO
         NSTTOP=NSTATE
         DO IST=NSTATE,1,-1
           IF(WSTATE(IST).NE.ZERO) THEN
              GO TO 11
           ELSE
              NSTTOP = NSTTOP - 1
           END IF
         ENDDO
 11      CONTINUE
      END IF
C
C       --- set default values of $DIABAT input and other params ---
C
      CALL DIABINP(NACT,NSTATE,NSTTOP)
C
      IF(WBLOCK(3).EQ.ZERO) THEN
         NSTDMO = NSTATE - NEXSTATE
      ELSE
         NSTDMO = NSTATE
      END IF
      IF(MASWRK) WRITE(IW,9050) NCORBS,NACT,NQMT,NBF,
     *                          NSTATE,NSTDMO,NSTDIAB
C
      IF(E.EQ.ZERO  .AND.  EXETYP.NE.CHECK) THEN
         IF(MASWRK) WRITE(IW,9045)
         CALL ABRT
      END IF
C
C        by controlling individual orbital phases at various steps,
C        the number of iterations in -MORMO- maximization is reduced.
C        Also, the -NVAL- type 4-fold step's D3 seemed crisper.
C        This doesn't change the final maximal values very much,
C        but does seem to help systematize D3/MORMO Jacobi steps.
C
      STDPHASE = .TRUE.
C
C     Check -MC- orbital is averaged Fock orbital or not.
C     possible MC-QDPT later uses canonical orbitals in the
C     inactive and external orbital spaces.
C
      IF (NWFNFLG.NE.0) THEN
         IF(CANONC) THEN
            IF(MASWRK) WRITE(IW,9070)
         ELSE
            IF(MASWRK) WRITE(IW,9060)
            CALL ABRT
         END IF
      END IF
C
C Make back up of the canonicalized CAS MO (average Fock orbitals)
C
      CALL VALFM(LOADFM)
      LVEC = LOADFM + 1
      LAST = LVEC   + NBF*NBF
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
      CALL DAREAD(IDAF,IODA,X(LVEC),NBF*NBF, 15,0)
      CALL DAWRIT(IDAF,IODA,X(LVEC),NBF*NBF,326,0)
      CALL RETFM(NEED)
C
C   ======= prepare density and transition density matrices =========
C
C   after the CASSCF converged, there was a canonicalization
C   of the core/active/virtual blocks, as well as regeneration
C   of the CAS-CI vectors for those canonical orbitals.
C
C   Thus we can proceed directly to generation of density matrices
C   and transition density matrices for these CAS-CI canonical orbs.
C
C         prepare symmetry information for the CAS canonical MO-s.
C         active orbital's symmetry strings are saved in memory.
C
      IF(MASWRK) WRITE(IW,9080) NSTDMO
C
      NBF2 = (NBF*NBF+NBF)/2
      NBF3 = NBF*NBF
      CALL VALFM(LOADFM)
      LMOIRP = LOADFM + 1
      LMOLAB = LMOIRP + NBF
      LMODEG = LMOLAB + NBF
      LQ     = LMODEG + NBF
      LS     = LQ     + NBF3
      LV     = LS     + NBF2
      LWRK   = LV     + NBF3
      LAST   = LWRK   + NBF
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
      CALL MOSYMDIAB(CISTEP,X(LMOIRP),X(LMOLAB),X(LMODEG),X(LQ),X(LS),
     *               X(LV),X(LWRK),MOSLAB_ACTIVE,NCORBS,NACT,
     *               NQMT,NBF,NBF2,NBF3)
      CALL DAWRIT(IDAF,IODA,X(LMOLAB),NBF,255,1)
      CALL DAWRIT(IDAF,IODA,X(LMOIRP),NBF,262,1)
      CALL RETFM(NEED)
C
C     ----- prepare CAS-CI density and transition density matrices -----
C     GUGA and determinants share common storage for energy and density.
C     Redundant TDM are prepared, rho-I,J and rho-J,I for states I,J.
C     These obey the relation rho-I,J(k,l) = rho-J,I(l,k), for MO's k,l.
C
      CALL VALFM(LOADFM)
      LENGY  = LOADFM + 1
      LTDM   = LENGY  + NSTDMO
      LAST   = LTDM   + NACT*NACT*NSTDMO*NSTDMO
      NEEDTDM = LAST - LOADFM - 1
      CALL GETFM(NEEDTDM)
C
C           ----- in case the calculation is using CSFs -----
C
      IF(CISTEP.EQ.GUGA) THEN
         IF(MASWRK) THEN
            WRITE(IW,9100)
            IWST=1
            DO IST=1,NSTATE
               IF(IST.EQ.IAVGGUGA(IWST)) THEN
                  WTMCSCF = WAVGGUGA(IWST)
                  IWST=IWST+1
               ELSE
                  WTMCSCF = ZERO
               END IF
               WTDIAB = ZERO
               IF(IST.LE.NGRSTATE)         WTDIAB=WBLOCK(1)/NGRSTATE
               IF(IST.GT.NGRSTATE)         WTDIAB=WBLOCK(2)/NSTDIAB
               IF(IST.GT.NGRSTATE+NSTDIAB .AND. NEXSTATE.NE.0)
     *                                     WTDIAB=WBLOCK(3)/NEXSTATE
               WRITE(IW,9110) IST,ESTATE(IST),WTMCSCF,WTDIAB
            ENDDO
         END IF
C
         CALL GUGTDMX(NCORBS,NACT,NBF,NSTDMO,X(LTDM),X(LENGY),0)
      END IF
C
C        ----- in case the calculation is using determinants -----
C
      IF(CISTEP.EQ.ALDET) THEN
         IF(MASWRK) THEN
            WRITE(IW,9120)
            ISPST = 0
            DO 21 IST=1,KDET
              IF(IPURES.EQ.1) THEN
                 IF(ABS(SPINS(IST)-SDET) .GT. 0.03D+00) GO TO 21
                 ISPST = ISPST + 1
              ELSE
                 ISPST = ISPST + 1
              ENDIF
              WTMCSCF = WSTATE(ISPST)
              WTDIAB = ZERO
              IF(ISPST.LE.NGRSTATE)         WTDIAB=WBLOCK(1)/NGRSTATE
              IF(ISPST.GT.NGRSTATE)         WTDIAB=WBLOCK(2)/NSTDIAB
              IF(ISPST.GT.NGRSTATE+NSTDIAB .AND. NEXSTATE.NE.0)
     *                                      WTDIAB=WBLOCK(3)/NEXSTATE
              WRITE(IW,9130) ISPST,IST,ESTATE(IST),SPINS(IST),
     *                       WTMCSCF,WTDIAB
   21       CONTINUE
         END IF
C
         CALL DETTDMX(NCORBS,NACT,NBF,NSTDMO,X(LTDM),X(LENGY),0)
      END IF
C
C          output these densities to a disk file.
C
      NFT21=21
      CALL SEQOPN(NFT21,'DIABDAT','NEW',.FALSE.,'UNFORMATTED')
      CALL WRITETDM(NFT21,X(LTDM),X(LENGY),NSTDMO,NACT)
C
      CALL RETFM(NEEDTDM)
      IF(MASWRK) WRITE(IW,9140)
      CALL TIMIT(1)
C
C     ======= memory for reading various standard orbitals =======
C     ======= this memory also used for creation of DMO's  =======
C
      N1=NBF*NBF
      N2=(NBF*NBF+NBF)/2
C         no. unique DM and TDM, plus one more for state-averaged DM.
      NDMAT = (NSTDMO*NSTDMO+NSTDMO)/2 + 1
C
      CALL VALFM(LOADFM)
      LDFMO    = LOADFM   + 1
      LSAO     = LDFMO    + NBF*NACT
      LSMO     = LSAO     + (NBF*NBF+NBF)/2
      LWORK    = LSMO     + NACT*NACT
      LACTMO   = LWORK    + NBF*NBF
      LDENS    = LACTMO   + NBF*NACT
      LDPSMO   = LDENS    + NACT*NACT*NDMAT
      LRMOLAB  = LDPSMO   + NBF*NACT
      LTRI     = LRMOLAB  + NACT
      LEVEC    = LTRI     + (NACT*NACT+NACT)/2
      LEVAL    = LEVEC    + NACT*NACT
      LIWRK    = LEVAL    + NACT
      LWRKVEC  = LIWRK    + MAX(NACT,NBF)
      LQ       = LWRKVEC  + NBF
      LTRANS   = LQ       + NBF*NBF
      LU       = LTRANS   + 3*3*NAT
      LAST     = LU       + NACT*NACT
      NEEDDMO = LAST - LOADFM - 1
      CALL GETFM(NEEDDMO)
C
C     Read AO overlap
C
      CALL DAREAD(IDAF,IODA,X(LSAO)  ,N2 ,12 ,0)
C
C        average occupations of active orbitals is set later,
C        clear now before printing with fake zero eigenvalues.
C
      DO I=1,NACT
         AVOCC_ACT(I) = ZERO
      ENDDO
C
C         ---- orbitals of the reference geometry ($DFMVEC) ----
C     Read $DFMVEC, assign its irreps, and check irreps ordering of
C     the $DFMVEC matches the original CAS MOs.
C     If the ordering of irreps is different, stop!
C     Finally $DFMVEC is symmetric orthogonalized and saved for later.
C     When NDFRM=0, these MOs are taken as original av Fock orbitals.
C              -actmo- storage used as scratch space here
C
      IF (NDFRM.NE.0) THEN
        CALL DFMSYMCHK(NBF,NACT,NQMT,MOSLAB_ACTIVE,X(LDFMO),
     *                 X(LWORK),X(LSAO),X(LACTMO),X(LRMOLAB),STDPHASE)
        CALL DFMSYMVEC(NBF,NACT,X(LDFMO),X(LSAO),X(LSMO),X(LTRI),
     *                 X(LEVEC),X(LEVAL),X(LWORK),X(LIWRK))
        IF(MASWRK) WRITE(IW,9150)
        CALL PRSQL(X(LDFMO),NACT,NBF,NBF)
        CALL DAWRIT(IDAF,IODA,X(LDFMO),NBF*NACT,327,0)
      ELSE
        CALL DAREAD(IDAF,IODA,X(LWORK)           ,NBF*NBF ,326,0)
        CALL DAWRIT(IDAF,IODA,X(LWORK+NBF*NCORBS),NBF*NACT,327,0)
      END IF
C
C                ---- resolution orbitals ($DIAVEC) ----
C     Read $DIAVEC (main resolution DMOs), if NMLAP>0 in input.
C     assign irreps of $DIAVEC.
C                -LDFMO- storage is recycled here, $DFMVEC now on disk.
C               -LACTMO- storage is scratch space for this call.
      IF (NMLAP.NE.0) THEN
        CALL REFDMOSYM(NMLAP,NQMT,NBF,
     *                 X(LDFMO),X(LWORK),X(LSAO),X(LACTMO),
     *                 X(LTRANS),MOSLAB_REFDMO,
     *                 DIAVECW,FRVLW,NAT,NORIENT,STDPHASE)
        IF(MASWRK) WRITE(IW,9160)
        CALL PRSQL(X(LDFMO),NMLAP,NBF,NBF)
      END IF
C
C                ---- resolution orbitals ($DPSVEC) ----
C     Read $DPSVEC (pre-4-fold doubly occupied space resolution orbs),
C     if NDLAP>0 in input group.   Assign irreps of $DPSVEC.
C
      IF (NDLAP.NE.0) THEN
        CALL REFDMOSYM(NDLAP,NQMT,NBF,
     *                 X(LDPSMO),X(LWORK),X(LSAO),X(LACTMO),
     *                 X(LTRANS),MOSLAB_REFPS,
     *                 DPSVECW,FRDCW,NAT,NORIENT,STDPHASE)
        IF(MASWRK) WRITE(IW,9170)
        CALL PRSQL(X(LDPSMO),NDLAP,NBF,NBF)
      END IF
C
      IF(EXETYP.EQ.CHECK) THEN
         IF(MASWRK) WRITE(IW,9180)
         GO TO 400
      END IF
C
C         Pick up the active MO coefficients, at -ACTMO-
C
      CALL DAREAD(IDAF,IODA,X(LWORK),N1,15,0)
      CALL DCOPY(NBF*NACT,X(LWORK+NBF*NCORBS),1,X(LACTMO),1)
C
C         Read all DM/TDM, and then add SA-DM at the end
C
      CALL READTDM(NFT21,X(LDENS),NSTDMO,NACT,NDMAT)
C
C               all this setup work has now produced:
C       reference geometry orbitals on disk, at record 327.
C       x(lactmo) ---> active MO's LCAO expansion
C       x(ldens)  ---> all DM + TDM + SA-DM (each of size=NACT*NACT)
C       x(lsao)   ---> AO overlap
C       x(ldfmo)  ---> resolution DMOs (i.e. $DIAVEC)
C       x(ldpsmo) ---> doubly occ. space resolution MO (i.e. $DPSVEC)
C
C     input option to turn off the use of orbital symmetry
C
      IF (NDMOSYM.EQ.0) THEN
        DO I=1,NACT
          MOSLAB_ACTIVE(I)=LAB_C1
        END DO
        DO I=1,NMLAP
          MOSLAB_REFDMO(I)=LAB_C1
        END DO
        DO I=1,NDLAP
          MOSLAB_REFPS(I)=LAB_C1
        END DO
      END IF
C
C   Optimization of Diabatic Molecular Orbitals (DMOs) now begins...
C   (1) The Threefold density criterion
C   (2) Apply the four-fold way to Doc-candidate MOs
C   (3) Separate active space to 3 (or 2 or 1) block as 'doc,val,vir'
C   (3) The four-fold way with (block) MORMO criterion
C   (4) deformation check
C
C   Step (1) Carry out the threefold density criterion
C            and transform MO coefficients.
C            DM's at -LDENS- and MO coefs at -LACTMO- are updated.
C
      CALL THREEFOLD(ALPHA_N,ALPHA_R,ALPHA_T,CONV_TH,MAX_ITER,
     &               NSTDMO,NBF,NACT,MOSLAB_ACTIVE,AVOCC_ACT,
     &               X(LDENS),X(LACTMO),X(LWORK),X(LU),
     &               NDMAT,STDPHASE)
C
C   Step (2) Pick up  Doc block candidate (if necessary)
C
      NDOC=0
      DO I=1,NACT
        IF (MOSLAB_CHARACT(I).EQ.NSYMBOL_DOC) NDOC=NDOC+1
      END DO
C
      NDOC_CAND=0
C
C         decision on performing pre-four-fold way:
C
      IF ((NDFRM.EQ.0).OR.(NDLAP.EQ.0).OR.(NDOC.EQ.0)) GO TO 100
C
      IF(MASWRK) WRITE(IW,9300)
C
C DOC block candidates are treated as target of CR algorithm.
C Thus such MOs are identified "nsymbol_val" because they are
C applied to the fourfold way.
C
      DO I=1,NACT
        IF (TH_DOC.LT.AVOCC_ACT(I)) THEN
          NDOC_CAND=NDOC_CAND+1
          MOSLAB_PSEUDO(I)=NSYMBOL_VAL
        ELSE
          MOSLAB_PSEUDO(I)=NSYMBOL_VIR
        END IF
      END DO
C
C          check
C
      IF (NDOC_CAND.LT.NDOC) THEN
        IF(MASWRK) WRITE(IW,9310) NDOC_CAND,NDOC
        GO TO 100
      ELSE
        IF(MASWRK) WRITE(IW,9320) NDOC_CAND,NDOC_CAND-NDOC
      END IF
C
C     Sort of the "caught" MOs, to accelerate convergence
C
      ICOUNT=0
      DO I=1,NACT
        IF (TH_DOC.LT.AVOCC_ACT(I)) THEN
          ICOUNT=ICOUNT+1
          ITEMP(ICOUNT)=I
        END IF
      END DO
C
      CALL PRESORT(NSTDMO,NBF,NACT,NDOC_CAND,NDLAP,ITEMP,
     &             X(LACTMO),X(LDPSMO),X(LSAO),X(LSMO),X(LWORK),
     &             X(LDENS),NDMAT,AVOCC_ACT,MOSLAB_ACTIVE)
C
C          Apply four-fold way to the DOC-candidates
C
      CALL FOURFOLD(ALPHA_N,ALPHA_R,ALPHA_T,CONV_TH,MAX_ITER,
     &              NSTDMO,NBF,NACT,NDLAP,
     &              MOSLAB_ACTIVE,MOSLAB_REFPS,MOSLAB_PSEUDO,
     &              X(LDENS),NDMAT,X(LACTMO),X(LDPSMO),X(LSAO),
     &              AVOCC_ACT,X(LWORK),X(LU),STDPHASE)
C
C Step (3)  Define the block (DOC/VAL/VIR) by using $DFMVEC,
C           the updated MO, and occupation number etc.
C
  100 CONTINUE
      CALL DETBLOCK(NBF,NACT,NSTDMO,NDOC_CAND,
     &              MOSLAB_ACTIVE,MOSLAB_PSEUDO,AVOCC_ACT,
     &              X(LSMO),X(LACTMO),X(LWORK),X(LSAO),X(LDENS),NDMAT)
C
C Step (4) The fourfold way for Val block as the final determination
C
      IF (NMLAP.NE.0) THEN
         IF(MASWRK) WRITE(IW,9330) (MOSLAB_CHARACT(I),I=1,NACT)
C
C     Sort of MO in the caught part to accelerate convergence
C
        ICOUNT=0
        DO I=1,NACT
          IF (MOSLAB_CHARACT(I).EQ.NSYMBOL_VAL) THEN
            ICOUNT=ICOUNT+1
            ITEMP(ICOUNT)=I
          END IF
        END DO
C
        CALL PRESORT(NSTDMO,NBF,NACT,ICOUNT,NMLAP,ITEMP,
     &               X(LACTMO),X(LDFMO),X(LSAO),X(LSMO),X(LWORK),
     &               X(LDENS),NDMAT,AVOCC_ACT,MOSLAB_ACTIVE)
C
        CALL FOURFOLD(ALPHA_N,ALPHA_R,ALPHA_T,CONV_TH,MAX_ITER,
     &                NSTDMO,NBF,NACT,NMLAP,
     &                MOSLAB_ACTIVE,MOSLAB_REFDMO,MOSLAB_CHARACT,
     &                X(LDENS),NDMAT,X(LACTMO),X(LDFMO),X(LSAO),
     &                AVOCC_ACT,X(LWORK),X(LU),STDPHASE)
      END IF
C
C Step (4) final Ordering of the DMOs
C
      CALL ORDDMO(NBF,NACT,NSTDMO,
     &            MOSLAB_ACTIVE,X(LDENS),NDMAT,AVOCC_ACT,
     &            X(LACTMO),X(LWORK),X(LSAO),X(LSMO))
C
      IF(NWFNFLG.EQ.0  .AND.  NDFRM.EQ.1) THEN
        CALL PRLAPDMO(NBF,NACT,X(LACTMO),X(LWORK),X(LSAO),X(LSMO))
      END IF
C
C  Insert the active DMOs into pristine MCSCF orbs to have
C  the full set: inactive MO, active DMO, and external MO.
C  Write to disk to set up CAS-CI state generation using DMOs.
C  Get symmetry labels for the purpose of printing.
C  Build a full table of electron occupancies for printing.
C
      CALL DAREAD(IDAF,IODA,X(LWORK),NBF*NBF,326,0)
      CALL DCOPY(NBF*NACT,X(LACTMO),1,X(LWORK+NBF*NCORBS),1)
      CALL DAWRIT(IDAF,IODA,X(LWORK),N1,15,0)
C
      CALL DAREAD(IDAF,IODA,X(LQ),NBF*NBF,45,0)
      CALL SYMMOS(X(LIWRK),X(LQ),X(LSAO),X(LWORK),X(LWRKVEC),
     *            NQMT,NBF,NCORBS+NACT,NBF)
C
      DO I=1,NCORBS
         X(LWRKVEC+I-1) = TWO
      ENDDO
      CALL DCOPY(NACT,AVOCC_ACT,1,X(LWRKVEC+NCORBS),1)
C
C      --- Print and Punch the active DMO in the AO basis ---
C  Printing is core+active orbitals, all from temporary storage:
C       diabatized molecular orbitals are at -LWORK-
C       averaged occupancies at -LWRKVEC-
C       symmetry labels at -LIWRK-
C  Punching is active DMO's only,
C       these are potentially candidates for future use as $DFMVEC.
C
      IF (MASWRK  .AND.  NWFNFLG.EQ.0) THEN
         WRITE(IW,9350) NACT,NDLAP,NMLAP,NACT
         CALL PREVS(X(LWORK),X(LWRKVEC),X(LIWRK),NCORBS+NACT,NBF,NBF,1)
C
         WRITE(IP,*) '--- DIABATIC ORBITALS FOR CAS-SCF (ACTIVE) ---'
         WRITE(IP,'(A8)') DFRMVECW
         CALL PUSQL(X(LACTMO),NACT,NBF,NBF)
         WRITE(IP,'(A8)') ENDWRD
      END IF
C
C            this completes DMO generation!
C
  400 CONTINUE
      CALL RETFM(NEEDDMO)
      IF(MASWRK) WRITE(IW,9370)
      CALL TIMIT(1)
C
C   ========== Carry out CAS-CI calculation using new DMOs ============
C   DAF record 15 is now CAS-DMO's, inactive and external are av Fock.
C
      IF(MASWRK) WRITE(IW,9400)
C
C   Save energies of all the adiabatic states.
C
      IF(CISTEP.EQ.GUGA) THEN
         DO I=1,NSTATE
           ECI_SAV(I)=ESTATE(I)
         END DO
      END IF
      IF(CISTEP.EQ.ALDET) THEN
         K=0
         DO IST=1,KDET
           IF(ABS(SPINS(IST)-SDET) .GT. 0.03D+00) THEN
              CONTINUE
           ELSE
              K=K+1
              ECI_SAV(K) = ESTATE(IST)
           END IF
         ENDDO
      ENDIF
C
C   Symmetry turned OFF if requested by input.
C
      IF (NSTATE.GT.1   .AND.   NDMOSYM.EQ.0) THEN
        CALL SYMOFF
        OFFSYM=.TRUE.
      ELSE
        OFFSYM=.FALSE.
      END IF
C
C     ----- Get CAS-CI adiabatic states for the new DMO basis ----
C
C       CSFs and determinants need the same tranny, first.
C       Note: serial CASTRF might be faster but requires resetting
C             the norbs for DRT common /orbset/ to include cores,
C             after GUGA steps run (such as NTNCAN's adiab. states).
C
      IPSI=1
C
      IPRINT=0
      DDITRF=GOPARR
      DOFOCK = .TRUE.
      DOEXCH = .FALSE.
C            CI OFF DDI INTEGRALS DOESN'T KNOW HOW TO SKIP CORES.
      DOCORE = .TRUE.
      DOOOOO = .TRUE.
      DOVOOO = .FALSE.
      DOVVOO = .FALSE.
      DOVOVO = .FALSE.
      DOVVVO = .FALSE.
      DOVVVV = .FALSE.
      CALL TRFMCX(IPRINT,NCORBS,NORBS,NORBS,DOFOCK,DOEXCH,DDITRF,
     *            DOOOOO,DOVOOO,DOVVOO,DOVOVO,DOVVVO,DOVVVV,DOCORE)
C
      IF(CISTEP.EQ.GUGA) THEN
         SVDSKW=DSKWRK
         DSKWRK=.TRUE.
         CALL DRTGEN(IPRINT,DRTNAM)
         CALL GUGSRT(IPRINT,DDITRF)
         CALL GUGAEM(IPRINT)
         CALL ERASCI
         CALL GUGADG(IPRINT)
         DSKWRK=SVDSKW
      END IF
C
      IF(CISTEP.EQ.ALDET) THEN
         IROOTSV=IROOT
         IF(IROOT.LE.0) IROOT=1
         CALL DETFCI(IPRINT,.TRUE.,DDITRF)
         IROOT=IROOTSV
      END IF
C
      IF(DDITRF  .AND.  EXETYP.NE.CHECK) THEN
         IF(MASWRK) WRITE(IW,9700)
         CALL DDI_DESTROY(D_OOOO)
      END IF
C
      IPSI=0
C
C     =========== Finally, diabatization procedure  =============
C        (1) Final procedure of CASSCF diabatization
C        (2) Final procedure of prepation of MC-QDPT [commented out]
C
C            for CAS-SCF diabatization...
C
      IF(NWFNFLG.EQ.0) THEN
C
         IF(MASWRK) WRITE(IW,9410)
C
         IF(CISTEP.EQ.GUGA) THEN
            MAXLIST=200
            MAXRT=MXRT
            IF(MASWRK) THEN
               CALL SEQREW(NFT11)
               READ(NFT11) IDUM,IDUM,IDUM,NROWS,NWKS
               CALL SEQREW(NFT11)
               IF(IDUM.NE.0) IDUM=0  ! FOR FTNCHEK
            END IF
            IF(GOPARR) THEN
               CALL DDI_BCAST(2148,'I',NROWS,1,MASTER)
               CALL DDI_BCAST(2148,'I',NWKS,1,MASTER)
            END IF
C
C         dynamic memory allocations for GUGA diabatization
C
            CALL VALFM(LOADFM)
            LDCI    = LOADFM  +1
            LDCIREF = LDCI    + MAXLIST*MAXRT
            LDCIRF2 = LDCIREF + MAXLIST*MAXRT
            LLSTCSF = LDCIRF2 + MAXLIST*MAXRT
            LLSTGRP = LLSTCSF + MAXLIST
            LISTACK = LLSTGRP + MAXLIST
            LCIVEC  = LISTACK + NSTATE
            LLEVIR  = LCIVEC  + NWKS
            LICASE  = LLEVIR  + NBF
            LIECONF = LICASE  + NBF
            LIECASE = LIECONF + NBF
            LIARC   = LIECASE + NBF
            LTABCF  = LIARC   + NROWS*4
            LIOUTIV = LTABCF  + MAXLIST
            LT      = LIOUTIV + NBF
            LTP     = LT      + NSTDIAB*NSTDIAB
            LS      = LTP     + NSTDIAB*NSTDIAB
            LSTRI   = LS      + NSTDIAB*NSTDIAB
            LIWORK  = LSTRI   + (NSTDIAB*NSTDIAB+NSTDIAB)/2
            LWRKVEC = LIWORK  + NSTDIAB
            LEIGVAL = LWRKVEC + NSTDIAB
            LEIGBUF = LEIGVAL + NSTDIAB
            LU      = LEIGBUF + NSTDIAB*NSTDIAB
            LBUFF   = LU      + NSTDIAB*NSTDIAB
            LWORK   = LBUFF   + NSTDIAB*NSTDIAB
            LAST    = LWORK   + MAXLIST*NSTDIAB
            NEEDDIAB = LAST - LOADFM - 1
            CALL GETFM(NEEDDIAB)
C
C  (i) Make some lists of dominate CSF to make group G_k,
C      If the list is specified in the input, use that info.
C
            IF(NRCSF.NE.0) THEN
               CALL RDCSFGRPS(NSTDMO,NLIST,X(LDCIREF),X(LLSTCSF),
     &                        X(LLSTGRP),MAXLIST,MAXRT)
            END IF
C
            IF(EXETYP.EQ.CHECK) THEN
               IF(MASWRK) WRITE(IW,9360)
               GO TO 500
            END IF
C
C (ii) Search CI coefficients of dominant CSFs,
C      and store to the array DCICOEF.
C Note: FT21 may be used as scratch file in routine REFDIA
C
            CALL REFDIA(NFT21,X(LLSTCSF),X(LLSTGRP),X(LDCI),X(LCIVEC),
     &                  X(LLEVIR),X(LICASE),X(LIECONF),X(LIECASE),
     &                  X(LIARC),ECI_SAV,X(LISTACK),X(LTABCF),
     &                  X(LIOUTIV),NLIST,MAXLIST,MAXRT,NSTDMO,
     &                  NWKS,NROWS,4*NROWS,NBF)
C
C (iii) Make adiabatic/diabatic transformation matrix.
C       Print diabatic state's CSF expansions.
C       Print diabatic state's Hamiltonian elements.
C
            CALL GETHDIA(NRCSF,ECI_SAV,NLIST,X(LLSTGRP),
     &                   X(LLSTCSF),X(LDCI),X(LDCIREF),X(LDCIRF2),
     &                   X(LT),X(LTP),X(LS),X(LEIGVAL),X(LEIGBUF),
     &                   X(LSTRI),X(LIWORK),X(LWRKVEC),X(LU),X(LBUFF),
     &                   X(LWORK),NSTDMO,NGRSTATE,NSTDIAB,MAXLIST,MAXRT)
C
C
C (iv) Punch out CSF list,
C      CI coefficients of 'truncated' Diabatic states to $REFCSF
C
            CALL PUCSFGRPS(NSTDMO,NLIST,X(LDCI),X(LLSTCSF),X(LLSTGRP),
     &                     MAXLIST,MAXRT)
C
  500       CONTINUE
            CALL RETFM(NEEDDIAB)
         END IF
C
C           August 2012.
C           MWS believes everything above is OK for determinants,
C           except clearly the diabatization is entirely missing!
         IF(CISTEP.EQ.ALDET) THEN
            IF(MASWRK) WRITE(IW,9800)
            CALL ABRT
         END IF
      END IF
C
C     for MC-QDPT diabatization...
C     code for this is below, also commented out in same fashion.
C-MRMP-   COMMON /CASOPT/ CASHFT,CASDII,NRMCAS,FOCAS,SOSCF,DROPC
C-MRMP-   common/diabmqpar2/coef_max1(20),coef_max2(20),
C-MRMP-  &                  eigvec(400),e_mcqdpt(20)
C-MRMP-   common/diabmqpar1/nstci,nstcas,nstmq,kstci_cas(50),kstci_mq(50),
C-MRMP-  &                  kstcas_mq(50)
C-MRMP-COMMON /CIFILS/ NFT11,NFT12,NFT13,NFT14,NFT15,NFT16,IDAF20,NEMEMX
C-MRMP-      if(nwfnflg.eq.1) then
C-MRMP-c
C-MRMP-c  Target CAS-CI vectors in FT12 is copied to FT21
C-MRMP-c  This data will be used in MC-QDPT diabatization.
C-MRMP-c
C-MRMP-        rewind(nft12)
C-MRMP-        rewind(nft21)
C-MRMP-C
C-MRMP-        read(nft12)  nstry,nwks ! header
C-MRMP-        write(nft21) nstcas,nwks
C-MRMP-c---get core memory
C-MRMP-        ix1=1   ! make FTNCHEK silent
C-MRMP-        last=ix1+nwks
C-MRMP-        call diabmqwr1(nft12,nft21,ndmosym,nstry,
C-MRMP-     &                 eci_sav,estate,nwks,x(ix1))
C-MRMP-c---reset core memory
C-MRMP-C
C-MRMP-      end if
C
C  ================ End of diabatization procedure ==================
C  At this point HONDO+ carried out one more CI to reproduce adiabatic
C  states, but did so with all printing turned off, so why bother?
C  Thus, HONDO+ not only recovered the original MCSCF orbs to record 15,
C  it also recreated the original adiabatic state CI vector file.
C  Right now, this program just leaves the DMO data behind.
C
C          Symmetry turned back ON
C
      IF (OFFSYM) THEN
         CALL SYMON
         OFFSYM=.FALSE.
      END IF
C
      RETURN
C
 9010 FORMAT(/1X,'   ******************************************'/
     &        1X,'   DETERMINATION OF DIABATIC STATES BASED ON'/
     &        1X,'             CASSCF WAVE FUNCTIONS'/
     &        1X,'   PROGRAM WRITTEN BY H.NAKAMURA, D.G.TRUHLAR'/
     &        1X,'   ******************************************')
 9020 FORMAT(/1X,'   ******************************************'/
     &        1X,'   DETERMINATION OF DIABATIC STATES BASED ON'/
     &        1X,'            MC-QDPT WAVE FUNCTIONS'/
     &        1X,'   PROGRAM WRITTEN BY H.NAKAMURA, D.G.TRUHLAR'/
     &        1X,'   ******************************************')
 9030 FORMAT(/1X,'   -----------------------------------------'/
     &        1X,'   PRELIMINARY PROCEDURE, DMOS FOR REFERENCE'/
     &        1X,'   CASSCF WAVE FUNCTIONS, STARTS...'/
     &        1X,'   -----------------------------------------')
 9040 FORMAT(1X,'THIS DIABATIZATION PROGRAM ASSUMES CASSCF TYPE.'/
     *       1X,'PLEASE CHOOSE CISTEP=GUGA OR CISTEP=ALDET IN $MCSCF.')
 9045 FORMAT(/1X,'MCSCF DID NOT CONVERGE...NO DIABATIZATION!'/)
 9050 FORMAT(/1X,'ORBITAL AND STATE SIZES FOR DIABATIZATION:'/
     *        1X,'NUMBER OF    FILLED ORBITALS=',I5/
     *        1X,'NUMBER OF    ACTIVE ORBITALS=',I5,
     *           ' (THESE WILL BE TURNED INTO DMOS)'/
     *        1X,'NUMBER OF MOLECULAR ORBITALS=',I5/
     *        1X,'NUMBER OF    ATOMIC ORBITALS=',I5/
     *        1X,'NUMBER OF ELECTRONIC STATES OF CORRECT SPIN:',I3/
     *        1X,'NUMBER OF STATES USED DURING DMO GENERATION:',I3/
     *        1X,'NUMBER OF STATES TO BE DIABATIZED:          ',I3)
 9060 FORMAT(1X,'TO ESTIMATE MC-QDPT ADIABATIC ENERGIES, THE MOS'/
     &       1X,'SHOULD BE FIXED AS FOCK ORBITAL AT THE FIRST STAGE.'/
     &       1X,'PLEASE CHOOSE CANONC=.TRUE. IN $MCSCF')
 9070 FORMAT(/1X,'   ------------------------------------------------'/
     &        1X,'   MC-QDPT ADIABATIC ENERGIES ARE ESTIMATED BY'/
     &        1X,'   AVERAGED FOCK ORBITALS (INACTIVE,EXTERNAL) AND'/
     &        1X,'   CAS-BASED DMOS (ACTIVE) THEN DIABATIC STATES ARE'/
     &        1X,'   EVALUATED.'/
     &        1X,'   ------------------------------------------------')
 9080 FORMAT(/1X,'CREATING STATE-SPECIFIC DENSITY MATRICES AND',
     *          ' TRANSITION DENSITY MATRICES,'/
     *        1X,'FOR THE',I5,' ELECTRONIC STATES INCLUDED IN THE',
     *          ' DMO GENERATION:')
 9100 FORMAT(/1X,'STATE',12X,'ENERGY',4X,'WEIGHT IN MCSCF', 2X,
     *           ' WEIGHT IN DMO')
 9110 FORMAT(1X,I4,1X,F20.10,5X,F6.3,13X,F6.3)
 9120 FORMAT(/1X,' SPIN',2X,'OVERALL',28X,'WEIGHT IN',3X,'WEIGHT IN'/
     *        1X,'STATE',3X,'STATE',9X,'ENERGY',6X,'SPIN',6X,
     *           'MCSCF',8X,'DMO')
 9130 FORMAT(1X,I4,3X,I4,1X,F20.10,2X,F4.1,5X,F6.3,6X,F6.3)
 9140 FORMAT(1X,'.... DONE WITH SS-1PDM AND TDM ....')
 9150 FORMAT(/1X,'----USER PROVIDED $DFMVEC---')
 9160 FORMAT(/1X,'----TRANSFORMED (STANDARD ORIENTATION) $DIAVEC---')
 9170 FORMAT(/1X,'----TRANSFORMED (STANDARD ORIENTATION) $DPSVEC---')
 9180 FORMAT(/1X,'CHECK RUN HAS NOW FOUND ALL INPUT ORBITAL GROUPS,'/
     *        1X,'AND FINDS SUFFICIENT MEMORY TO GENERATE DMO''S,'/
     *        1X,'SO 3-FOLD AND 4-FOLD WAY STEPS ARE BEING SKIPPED.')
 9300 FORMAT(/1X,48(1H-)/
     *       1X,'  CATCH AND RELEASE (C-R) ALGORITHM IS APPLIED'/
     *       1X,'FOR THE DOC ORBITAL BLOCK, BY THE FOUR-FOLD WAY.'/
     *       1X,48(1H-))
 9310 FORMAT(1X,'# OF CANDIDATES MO FOR DOC BLOCK IS TOO SMALL'/
     *       1X,'NDOC CANDIDATES=',I4,' NDOC=',I4/
     *       1X,'CATCH & RELEASE ALGORITHM IS NOT APPLIED. CONTINUE')
 9320 FORMAT(1X,I5,' MOS ARE CAUGHT',I5,' MOS ARE RELEASED.')
 9330 FORMAT(/1X,50(1H-)/
     *       1X,'  APPLYING THE FOUR-FOLD WAY FOR VAL CANDIDATES.'/
     *       1X,50(1H-)/
     *       1X,'     THE DMO''S USED FOR THE MORMO STEP ARE'/
     *       1X,'(MAY BE CHANGED WITH $DIABAT INPUT KEYWORD MOSLAB)'/
     *       1X,'ACTIVE SPACE LABELS FOR THE FOUR-FOLD WAY(S):',
     *           ' (KEYWORD MOSLAB)'/
     *       (5X,15I5))
 9350 FORMAT(/7X,'DMO''S HAVE NOW BEEN CREATED FROM',I4,' ACTIVE MOS:'/
     &       7X,'PRE-4-FOLD WAY FIXED',I4,' ACTIVE MOS    ($DPSVEC)'/
     &       7X,'    4-FOLD WAY FIXED',I4,' ACTIVE MOS    ($DIAVEC)'/
     &       7X,' OTHER DMOS FIXED BY',I4,' REFERENCE MOS ($DFMVEC)'/
     &       7X,'DMO''S DO NOT HAVE A DIAGONAL DENSITY MATRIX,',
     &          ' OF COURSE, BUT THEIR'/
     &       7X,'DENSITY''S DIAGONAL ELEMENTS ARE AN INDICATION OF',
     &          ' OCCUPANCY.'/
     &      /5X,36(1H-)/
     &       5X,'CAS-SCF DIABATIC MOLECULAR ORBITALS'/
     &       5X,'STATE AVERAGED OCCUPANCIES ARE SHOWN'/
     &       5X,36(1H-))
 9360 FORMAT(/1X,'CHECK RUN HAS NOW FOUND ANY REFERENCE CSF INPUT,'/
     *        1X,'AND FINDS SUFFICIENT MEMORY TO DO DIABATIZATION,'/
     *        1X,'SO THE DIABATIZAITON STEP IS BEING SKIPPED.')
 9370 FORMAT(/1X,'.... DONE PREPARING DIABATIC MOLECULAR ORBITALS ....')
 9400 FORMAT(/3X,'---- REGENERATING CAS-CI STATES OVER DMO''S ----'/)
 9410 FORMAT(/3X,'BEGINNING DIABATIZATION OF CAS-CI ADIABATIC STATES,'/
     *        7X,'WHICH WERE JUST REGENERATED USING THE DMO''S.'/)
 9700 FORMAT(1X,'FREEING DISTRIBUTED STORAGE FOR',
     *          ' [OCC OCC|OCC OCC] INTEGRALS')
 9800 FORMAT(//1X,'ALAS, DETERMINANTS DON''T DO FINAL DIABATIZATION')
      END
C
C*MODULE DIAB    *DECK DIABINP
      SUBROUTINE DIABINP(NACT,NSTATE,NSTTOP)
C
C--   implicit double precision(a-h,o-z)
      IMPLICIT NONE
      DOUBLE PRECISION ALPHA_N, ALPHA_R, ALPHA_T,
     *                 CONV_TH, FACT, QNAMDIA, RNAMDIA,
     *                 SLCTTH, TH_DOC, TH_VIR, WBLOCK,
     *                 WSUM, ZERO
      INTEGER NACT, NSTATE, NSTTOP
      INTEGER I, IBTYP, IDAF, IJK, IJKT, IODA, IP,
     *        IPTIM, IR, IW, JRET1, KQNAMDIA, MASTER,
     *        MAX_ITER, ME, MOSLAB_CHARACT, MXDIABACT,
     *        NAV, NDFRM, NDLAP, NDMOSYM, NERR,
     *        NEXSTATE, NGRSTATE, NMLAP, NNAMDIA,
     *        NORIENT, NPROC, NRCSF, NSTDIAB,
     *        NSYMBOL_DOC, NSYMBOL_VAL, NSYMBOL_VIR
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL DMOSYM,REFMOS,REFGRP,ORIENT
C
      PARAMETER (MXDIABACT=30)
      COMMON /DIABAT/ ALPHA_N,ALPHA_R,ALPHA_T,
     *                TH_DOC,TH_VIR,SLCTTH,CONV_TH,WBLOCK(3),
     *                NDFRM,NDMOSYM,NRCSF,NMLAP,NDLAP,NORIENT,
     *                MOSLAB_CHARACT(MXDIABACT),
     *                MAX_ITER,NGRSTATE,NEXSTATE,NSTDIAB,
     *                NSYMBOL_DOC,NSYMBOL_VAL,NSYMBOL_VIR
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (NNAMDIA=19)
      DIMENSION QNAMDIA(NNAMDIA),KQNAMDIA(NNAMDIA)
      DATA RNAMDIA/8HDIABAT  /
      DATA QNAMDIA/8HDMOSYM  ,8HREFMOS  ,8HREFGRP  ,
     *             8HALPHAN  ,8HALPHAR  ,8HALPHAT  ,
     *             8HTHDOC   ,8HTHVIR   ,8HCONVTH  ,8HSLCTTH  ,
     *             8HMAXIT   ,8HNGRST   ,8HNDIAST  ,8HNEXST   ,
     *             8HMOSLAB  ,8HWBLOCK  ,
     *             8HNMLAP   ,8HNDLAP   ,8HORIENT  /
      DATA KQNAMDIA/3*0,  3*3,  4*3,  4*1,  -1,33,   1,1,0/
C
      DATA ZERO/0.0D+00/
C
C         --- Default values for $diabat input ---
C
      DMOSYM = .FALSE.
      REFMOS = .FALSE.
      REFGRP = .FALSE.
      ALPHA_N = 2.0D+00
      ALPHA_R = 1.0D+00
      ALPHA_T = 0.5D+00
      SLCTTH = 0.05D+00
      TH_DOC = 1.8D+00
      TH_VIR = 0.2D+00
      CONV_TH = 1.0D-06
      MAX_ITER = 200
C        next ones set silly, so we can apply defaults if not read in.
      NGRSTATE = -27
      NSTDIAB  = -27
      NEXSTATE = -27
      WBLOCK(1) = ZERO
      WBLOCK(2) = ZERO
      WBLOCK(3) = ZERO
C
      DO I=1,MXDIABACT
        MOSLAB_CHARACT(I) = 1
      END DO
C
      NMLAP  = 0
      NDLAP  = 0
      ORIENT = .FALSE.
C
      NSYMBOL_DOC = 2
      NSYMBOL_VAL = 1
      NSYMBOL_VIR = 0
C
C Read namelist $DIABAT
C
      KQNAMDIA(15) = 10*MXDIABACT + 1
C
      CALL NAMEIO(IR,JRET1,RNAMDIA,NNAMDIA,QNAMDIA,KQNAMDIA,
     *            DMOSYM,REFMOS,REFGRP,
     *            ALPHA_N,ALPHA_R,ALPHA_T,
     *            TH_DOC,TH_VIR,CONV_TH,SLCTTH,
     *            MAX_ITER,NGRSTATE,NSTDIAB,NEXSTATE,
     *            MOSLAB_CHARACT,WBLOCK,
     *            NMLAP,NDLAP,ORIENT,
     *                 0,0,0,0,0,
     *    0,0,0,0,0,   0,0,0,0,0,    0,0,0,0,0,   0,0,0,0,0,
     *    0,0,0,0,0,   0,0,0,0,0,    0,0,0,0,0,   0,0,0,0,0)
C
C         set default for block weights
C     there can be as many as three kinds of states,
C     a) NGRST tells how many states lie below those to be diabatized,
C        the default is none
C     b) the middle states are diabatized,
C        these are NSTATE - NGRST - NEXST total states.
C     c) NEXST tells how many states lie above those to be diabatized,
C        the default is states at the top with no weight in the MCSCF.
C
      IF(NGRSTATE.EQ.-27) NGRSTATE = 0
      IF(NSTDIAB .EQ.-27) NSTDIAB  = NSTTOP - NGRSTATE
      IF(NEXSTATE.EQ.-27) NEXSTATE = NSTATE - NGRSTATE - NSTDIAB
C
C        default for block weighting assigns equal weight
C        to every state, not including NEXSTATE.
C        This choice is the original HONDO+ behavior.
      WSUM = WBLOCK(1) + WBLOCK(2) + WBLOCK(3)
      IF(WSUM  .LE.  0.0001D+00) THEN
         FACT = 1.0D+00/(NGRSTATE+NSTDIAB)
         WBLOCK(1) = NGRSTATE*FACT
         WBLOCK(2) = NSTDIAB*FACT
         WBLOCK(3) = ZERO
      ELSE
         WBLOCK(1) = WBLOCK(1)/WSUM
         WBLOCK(2) = WBLOCK(2)/WSUM
         WBLOCK(3) = WBLOCK(3)/WSUM
      END IF
C
C Write all input parameters for diabatization
C
      IF(MASWRK) THEN
         WRITE(IW,9200) DMOSYM,REFMOS,REFGRP,NGRSTATE,WBLOCK(1),
     *                  NSTDIAB,WBLOCK(2),NEXSTATE,WBLOCK(3),
     *                  NSTATE,NSTTOP,
     *                  ALPHA_N,ALPHA_R,ALPHA_T,MAX_ITER,CONV_TH,
     *                  SLCTTH
         WRITE(IW,9210) NMLAP,NDLAP,ORIENT,
     *                  TH_DOC,TH_VIR,
     *                  (MOSLAB_CHARACT(I),I=1,NACT)
      END IF
C
C           Check some of the input parameters
C
      NERR=0
C
      IF(JRET1.EQ.2) THEN
         IF(MASWRK) WRITE(IW,9230)
         NERR=NERR+1
      END IF
C
      IF((NGRSTATE + NSTDIAB + NEXSTATE) .NE.  NSTATE) THEN
         IF(MASWRK) WRITE(IW,9240) NGRSTATE,NSTDIAB,NEXSTATE,
     *                             NSTATE,NSTTOP
         NERR=NERR+1
      END IF
C
      IF (NMLAP.GT.NACT  .OR.  NDLAP.GT.NACT) THEN
         IF(MASWRK) WRITE(IW,9250) NMLAP,NDLAP,NACT
         NERR=NERR+1
      END IF
C
      IF (NACT.GT.MXDIABACT) THEN
         IF(MASWRK) WRITE(IW,*) 'TOO LARGE ACTIVE SPACE. STOP'
         NERR=NERR+1
      END IF
C
      IF(NERR.GT.0) CALL ABRT
C
C          user-friendly F/T input propagates in coding as 0/1
C
                 NORIENT=0
      IF(ORIENT) NORIENT=1
                 NDMOSYM=0
      IF(DMOSYM) NDMOSYM=1
                 NDFRM=0
      IF(REFMOS) NDFRM=1
                 NRCSF=0
      IF(REFGRP) NRCSF=1
      RETURN
C
 9200 FORMAT(/5X,'======= INPUT VALUES OF $DIABAT ======='//
     *        1X,'PARAMETER FOR SYMMETRY OF DMOS:'/
     *        5X,'DMOSYM=',L8/
     *        1X,'PARAMETER FOR REFERENCE GEOMETRY MOS:'/
     *        5X,'REFMOS=',L8,' (IF TRUE, $DFMVEC INPUT REQUIRED)'/
     *        1X,'PARAMETER FOR DOMINANT CSF SELECTION'/
     *        5X,'REFGRP=',L8,' (IF TRUE, $REFCSF INPUT REQUIRED)'/
     *        1X,'PARAMETERS FOR ADIABATIC STATE SELECTION:'/
     *        5X,'  NGRST=',I8,'  WITH BLOCK WEIGHTING',F6.3,
     *           ' IN 3-FOLD''S NO TERM'/
     *        5X,' NDIAST=',I8,'  WITH BLOCK WEIGHTING',F6.3,
     *           ' IN 3-FOLD''S NO TERM'/
     *        5X,'  NEXST=',I8,'  WITH BLOCK WEIGHTING',F6.3,
     *           ' IN 3-FOLD''S NO TERM'/
     *       10X,'NOTE: MCSCF FOUND',I4,' STATES OF DESIRED SPIN.'/
     *       10X,'NOTE: MCSCF WEIGHTED THE FIRST',I4,' STATES.'/
     *        1X,'PARAMETERS FOR 3-FOLD WAY''S D3 FUNCTION'/
     *        6X,'SA-NO TERM',7X,'SS-ON TERM',7X,' TDM TERM'/
     *        5X,'ALPHAN=',F6.2,4X,'ALPHAR=',F6.2,4X,'ALPHAT=',F6.2/
     *        1X,'PARAMETERS FOR 3-FOLD-WAY OR 4-FOLD-WAY ITERS:'/
     *        5X,' MAXIT=',I8/
     *        5X,'CONVTH=',1P,E9.2,0P/
     *        1X,'REFERENCE STATE SELECTION THRESHOLD'/
     *        5X,'SLCTTH=',F5.3)
 9210 FORMAT(/5X,'PARAMETERS FOR FINE TUNING THE 4-FOLD WAY:'//
     *        1X,'NUMBER OF RESOLUTION MOS'/
     *        5X,' NMLAP=',I8,'  (FOUR-FOLD WAY STEP, USING $DIAVEC)'/
     *        5X,' NDLAP=',I8,' (PRE-4-FOLD WAY STEP, USING $DPSVEC)'/
     *        5X,'ORIENT=',L8,' (IF TRUE, PROVIDE $LCLDC IF NDLAP>0,',
     *                          ' $LCLVL IF NMLAP>0)'/
     *        1X,'IN CASE PRE-FOUR-FOLD WAY IS USED (NDLAP>0),'/
     *        1X,'ELECTRON OCCUPANCY THRESHOLDS TO SEPARATE FIL/',
     *           'DIF/VIR ACTIVE SPACE RESOLUTION'/
     *        5X,'> THDOC=',F6.3,'  WILL BE "DOC" PART',
     *           ' OF ACTIVE SPACE (IF PRE-4-FOLD)'/
     *        5X,'< THVIR=',F6.3,'  WILL BE "VIR" PART',
     *           ' OF ACTIVE SPACE (IF 4-FOLD)'/
     *        7X,'BETWEEN THESE IS THE "VAL" PART',
     *           ' OF ACTIVE SPACE.'/
     *        1X,'ACTIVE SPACE CHARACTERIZATION FOR THE FOUR-FOLD WAY:',
     *           ' (KEYWORD MOSLAB)'/
     *       (5X,15I5))
 9230 FORMAT(1X,'**** INPUT ERROR(S) DETECTED ****'/
     *       1X,'PLEASE FIX DIABATIZATION INPUT $DIABAT')
 9240 FORMAT(/1X,'*** ERROR ***'/
     *        1X,'NGRST=',I4,' NDIAST=',I4,' NEXST=',I4/
     *        1X,'SHOULD SUM TO TOTAL AVAILABLE STATES, NSTATE=',I4/
     *        1X,'NOTE THAT HIGHEST WEIGHTED STATE IN MCSCF WAS',I4)
 9250 FORMAT(1X,'*** ERROR ***'/
     *       1X,'# OF RESOLUTION ORBITALS IS TOO LARGE.'/
     *       1X,'NMLAP=',I4,' NDLAP=',I4,' BUT NACT=',I4)
      END
C
C*MODULE DIAB    *DECK MOSYMDIAB
      SUBROUTINE MOSYMDIAB(CISTEP,MOIRP,MOLAB,MODEG,Q,S,V,WRK,
     *                     MOSLAB_ACTIVE,NCORBS,NACT,L0,L1,L2,L3)
C--   implicit double precision(a-h,o-z)
      IMPLICIT NONE
C
      DOUBLE PRECISION CISTEP
      DOUBLE PRECISION ALDET, C1GROUP, CRIT, DWPARM, GLIST,
     *                 GRPDET, GUGA, PRTTOL, SDET, SPINS,
     *                 STSYM, SZDET, WSTATE
      INTEGER MOIRP, MOLAB, MODEG, Q, S, V, WRK, MOSLAB_ACTIVE,
     *        NCORBS, NACT, L0, L1, L2, L3
      INTEGER I, IA, IDAF, IDOCC, IDWEIGH, IEXCT, IGPDET,
     *        IJK, IJKT, IMCC, INTACT, IODA, IOUT, IP,
     *        IPURES, IR, IROOT, ISYM, IVAL, IW, IWTS,
     *        JCODE, KDET, KSTDET, KSTSYM, LEVNR, LEVPT,
     *        MAXP, MAXW1, MCORBS, MSYM, MXAO, MXRT, NA,
     *        NACTDET, NADET, NAV, NB, NBDET, NC, NCIDET,
     *        NCORDET, NCORSV, NFLGDM, NFOCI, NFTGCI,
     *        NITDET, NLCS, NLEVS, NORBDET, NORBMX,
     *        NORBS, NREFS, NSYM
C
      DIMENSION MOIRP(L1),MOLAB(L1),MODEG(L1),MOSLAB_ACTIVE(NACT),
     *          Q(L3),S(L2),V(L3),WRK(L1)
C
      PARAMETER (MXRT=100, MXAO=8192)
      LOGICAL NOSYM
C
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,SDET,SZDET,
     *                GRPDET,STSYM,GLIST,DWPARM,NFLGDM(MXRT),
     *                IWTS(MXRT),NCORSV,NCORDET,NACTDET,NORBDET,
     *                NADET,NBDET,KDET,KSTDET,IROOT,IPURES,MAXW1,NITDET,
     *                MAXP,NCIDET,IGPDET,KSTSYM,NFTGCI,IDWEIGH
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /ORBSET/ NORBMX,NORBS,MCORBS,NLEVS,NA,NB,NC,NSYM,MSYM,
     *                IDOCC,IVAL,IMCC,ISYM(MXAO),JCODE(MXAO),
     *                NLCS(MXAO),LEVPT(MXAO),LEVNR(MXAO),
     *                IOUT(MXAO),NREFS,IEXCT,NFOCI,INTACT
C
      DATA GUGA,ALDET/8HGUGA    ,8HALDET   /
      DATA C1GROUP/8HC1      /
C
C         get determinant code's symmetry numbers for DAF's current MOs
C
      NOSYM=.TRUE.
      IF(CISTEP.EQ.ALDET) NOSYM = GRPDET.EQ.C1GROUP
      IF(CISTEP.EQ.GUGA)  NOSYM = NSYM.EQ.1
C
      IF(NOSYM) THEN
         CALL C1DET(MOIRP,MOLAB,L0)
      ELSE
         CALL DAREAD(IDAF,IODA,V,L3,15,0)
         CALL DAREAD(IDAF,IODA,S,L2,12,0)
         CALL DAREAD(IDAF,IODA,Q,L3,45,0)
         CALL TRFSYM(MOLAB,MOIRP,MODEG,Q,S,V,WRK,IA,L0,L1,L0,L1)
      END IF
C
C  change orbital symmetry labels from GAMESS to JAKAL values
C
      IF(CISTEP.EQ.ALDET) CALL GAJASW(MOIRP,L1,GRPDET)
C
      DO I=1,NACT
         MOSLAB_ACTIVE(I) = MOLAB(I+NCORBS)
      ENDDO
      RETURN
      END
C
C*MODULE DIAB    *DECK GUGTDMX
      SUBROUTINE GUGTDMX(NCORBS,NACT,NBF,NSTATE,TDM,ENGY,IOPT)
C--   implicit double precision(a-h,o-z)
      IMPLICIT NONE
      DOUBLE PRECISION ENGY, TDM
      INTEGER IOPT, NACT, NBF, NCORBS, NSTATE
      DOUBLE PRECISION CHECK, EXETYP, RUNTYP, XX
      INTEGER IBTYP, IDAF20, IPTIM, L1, LACOEF, LAST,
     *        LCIVEC, LEVFRM, LIARC, LIMAIN, LINDX, LISEGM,
     *        LISUB, LISYM, LIUWKMN, LIUWKSB, LIWGHT, LJSEGM,
     *        LLEVNR, LLEVPT, LMAP, LMAPRV, LNABCB, LNLWKS,
     *        LNUWKS, LOADFM, LPUWK, LWORK, MASTER, ME,
     *        NEED, NEMEMX, NEMEMXDRT, NEVALS,
     *        NFT11, NFT12, NFT13, NFT14, NFT15, NFT16,
     *        NGLEVL, NHLEVL, NORBMX, NORBS, NPROC,
     *        NROWS, NROWS4, NSYM, NWKS
C
      DIMENSION TDM(NACT,NACT,NSTATE,NSTATE),ENGY(NSTATE)
C
      LOGICAL HEADER
      LOGICAL GOPARR,DSKWRK,MASWRK,SVDSKW
C
      COMMON /CIFILS/ NFT11,NFT12,NFT13,NFT14,NFT15,NFT16,IDAF20,NEMEMX
      COMMON /FMCOM / XX(1)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      DATA CHECK/8HCHECK   /
C
C        driver to obtain GUGA's DM and TDM matrices
C        If IOPT=0, the first -NSTATE- states are computed,
C                   even if they have no weight assigned.
C        If IOPT=1, states with non-zero weights are skipped,
C                   so the densities are for the first NSTATE
C                   states that actually have a weight.
C
      SVDSKW = DSKWRK
      DSKWRK = .FALSE.
C
      CALL SEQREW(NFT11)
      IF(MASWRK) READ(NFT11) NORBMX,NORBS,NSYM,NROWS,
     *                       NWKS,LEVFRM,NEMEMXDRT
      IF(GOPARR) THEN
         CALL DDI_BCAST(2156,'I',NROWS,1,MASTER)
         CALL DDI_BCAST(2157,'I',NWKS ,1,MASTER)
      END IF
      CALL SEQREW(NFT11)
C
      HEADER=.FALSE.  ! FTNCHEK THING
      IF(HEADER) WRITE(6,*) NORBMX,NORBS,NSYM,NROWS,
     *                      NWKS,LEVFRM,NEMEMXDRT
C
      NROWS4 = NROWS*4
      L1 = NBF
C
      CALL VALFM(LOADFM)
      LWORK   = LOADFM  + 1
      LINDX   = LWORK   + NACT*NACT
      LIARC   = LINDX   + NWKS
      LIWGHT  = LIARC   + NROWS4
      LNABCB  = LIWGHT  + NROWS4
      LNLWKS  = LNABCB  + NROWS
      LNUWKS  = LNLWKS  + NROWS
      LPUWK   = LNUWKS  + NROWS
      LMAP    = LPUWK   + NROWS
      LMAPRV  = LMAP    + L1
      LISYM   = LMAPRV  + L1
      LLEVNR  = LISYM   + L1
      LLEVPT  = LLEVNR  + L1
      LISEGM  = LLEVPT  + L1
      LJSEGM  = LISEGM  + L1
      LIMAIN  = LJSEGM  + L1
      LISUB   = LIMAIN  + L1
      LACOEF  = LISUB   + L1
      LIUWKMN = LACOEF  + L1
      LIUWKSB = LIUWKMN + L1
      LCIVEC  = LIUWKSB + L1
      LAST    = LCIVEC  + NSTATE*NWKS
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      IF(EXETYP.EQ.CHECK) THEN
         CALL VCLR(TDM,1,NACT*NACT*NSTATE*NSTATE)
         CALL VCLR(ENGY,1,NSTATE)
         GO TO 800
      END IF
C
      CALL GUGTDM(TDM,ENGY,IOPT,XX(LWORK),XX(LINDX),XX(LIARC),
     *            XX(LIWGHT),XX(LNABCB),XX(LNLWKS),XX(LNUWKS),
     *            XX(LPUWK),XX(LISYM),XX(LLEVNR),XX(LLEVPT),
     *            XX(LISEGM),XX(LJSEGM),XX(LIMAIN),XX(LISUB),
     *            XX(LACOEF),XX(LIUWKMN),XX(LIUWKSB),
     *            XX(LMAP),XX(LMAPRV),XX(LCIVEC),
     *            NCORBS,NACT,L1,NWKS,NROWS,NROWS4,NSTATE)
C
  800 CONTINUE
      DSKWRK=SVDSKW
      CALL RETFM(NEED)
      RETURN
      END
C
C*MODULE DIAB    *DECK GUGTDM
      SUBROUTINE GUGTDM(FULL_DM,ENGY,IOPT,WORK,INDX,IARC,IWGHT,
     *                  NABCB,NLWKS,NUWKS,PUWK,ISYM,LEVNR,LEVPT,
     *                  ISEGM,JSEGM,IMAIN,ISUB,ACOEF,IUWKMN,IUWKSB,
     *                  MAP,MAP_REV,CIVEC,
     *                  NCORBS,N_ACTIVE,L1,NWKS,NROWS,NROWS4,NSTATE)
C--   implicit double precision(a-h,o-z)
      IMPLICIT NONE
      DOUBLE PRECISION ACOEF, CIVEC, ENGY, FULL_DM, WORK
      INTEGER IARC, IMAIN, INDX, IOPT, ISEGM, ISUB, ISYM,
     *        IUWKMN, IUWKSB, IWGHT, JSEGM, L1, LEVNR,
     *        LEVPT, MAP, MAP_REV, NABCB, NCORBS, NLWKS,
     *        NROWS, NROWS4, NSTATE, NUWKS, NWKS, N_ACTIVE
      DOUBLE PRECISION ACOF, E1, E2, ECORE, EDFT, EDISP,
     *                 EELCT, EERD, EKIN, ENUCR, EPOT, ESCF,
     *                 ESTATE, ETOT, HALF, STATN, SZ, SZZ,
     *                 TITLE, TITLE1, VEE, VEN, WAVGGUGA
      INTEGER I, IAVGGUGA, IB, IBTYP, IDAF, IDAF20, IHAI,
     *        IJK, IJKT, IODA, IP, IPTIM, IR, IST, ISTAT,
     *        ISTATE, IUWK, IW, IWST, J, JB, JUWK, KSTAT,
     *        KSTATE, LDGUGA, LEVFRMDRT, MASTER, ME,
     *        MXRT, NAV, NAVGGUGA, NEMEMX, NEMEMXDRT,
     *        NFT11, NFT12, NFT13, NFT14, NFT15, NFT16,
     *        NLWK, NORBMXDRT, NORBS0, NORBSDRT, NPROC,
     *        NROWSDRT, NSTATECI, NSYMDRT, NUWK, NWKS0,
     *        NWKSCI, NWKSDRT
C
      PARAMETER (MXRT=100)
C
      LOGICAL AVGGUGA,HEADER
      LOGICAL GOPARR,MASWRK,DSKWRK
      INTEGER PUWK
C
      DIMENSION FULL_DM(N_ACTIVE,N_ACTIVE,NSTATE,NSTATE)
      DIMENSION WORK(N_ACTIVE,N_ACTIVE)
      DIMENSION INDX(NWKS)
      DIMENSION IARC(NROWS4),IWGHT(NROWS4)
      DIMENSION NABCB(NROWS),NLWKS(NROWS),NUWKS(NROWS),PUWK(NROWS)
      DIMENSION MAP(L1),ISYM(L1),LEVNR(L1),LEVPT(L1),MAP_REV(L1),
     *          ISEGM(L1),JSEGM(L1),IMAIN(L1),ISUB(L1),
     *          ACOEF(L1),IUWKMN(L1),IUWKSB(L1)
      DIMENSION CIVEC(NWKS,NSTATE),ENGY(NSTATE)
C
      DIMENSION TITLE(10),TITLE1(10)
C
      COMMON /CIFILS/ NFT11,NFT12,NFT13,NFT14,NFT15,NFT16,IDAF20,NEMEMX
      COMMON /DM2AVG/ WAVGGUGA(MXRT),IAVGGUGA(MXRT),NAVGGUGA,AVGGUGA
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /LOOPS1/ ACOF,NWKS0,NORBS0,IB,JB,IUWK,JUWK,NUWK,NLWK,
     *                IHAI,LDGUGA
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA HALF/0.5D+00/
C
C     generate state-specific densities and transition densities.
C
C     ----- READ HEADER RECORD OF CI VECTOR TAPE -----
C
      CALL SEQREW(NFT12)
      IF(MASWRK) READ(NFT12) NSTATECI,NWKSCI,TITLE,TITLE1
      IF(GOPARR) THEN
         CALL DDI_BCAST(2158,'I',NSTATECI,1,MASTER)
         CALL DDI_BCAST(2159,'I',NWKSCI  ,1,MASTER)
      END IF
      IF(NSTATE.GT.NSTATECI) THEN
         IF(MASWRK) WRITE(IW,*) 'GUGTDM: CI VECTOR FILE CONFUSION'
         CALL ABRT
      END IF
C
C     ----- READ -DRT- DATA -----
C
      CALL SEQREW(NFT11)
      IF(MASWRK) THEN
         READ(NFT11) NORBMXDRT,NORBSDRT,NSYMDRT,NROWSDRT,NWKSDRT,
     *               LEVFRMDRT,NEMEMXDRT
         READ(NFT11) TITLE
      END IF
      IF(GOPARR) THEN
         CALL DDI_BCAST(2155,'I',NWKSDRT ,1,MASTER)
         CALL DDI_BCAST(2156,'I',NORBSDRT,1,MASTER)
      END IF
      HEADER=.FALSE.  .AND.  MASWRK  ! FTNCHEK THING.
      IF(HEADER) WRITE(IW,*) NORBMXDRT,NORBSDRT,NSYMDRT,NROWSDRT,
     *                       NWKSDRT,LEVFRMDRT,NEMEMXDRT
C
      IF(NWKSDRT.NE.NWKSCI) GO TO 910
C
C     ----- READ REQUIRED -DRT- INFO -----
C
      IF(MASWRK) THEN
         READ (NFT11) MAP
         READ (NFT11) ISYM
         READ (NFT11) LEVNR
         READ (NFT11) LEVPT
         READ (NFT11)
         READ (NFT11) NABCB
         READ (NFT11)
         READ (NFT11) NLWKS
         READ (NFT11) NUWKS
         READ (NFT11) PUWK
         READ (NFT11) INDX
         READ (NFT11) IARC
         READ (NFT11) IWGHT
      END IF
      IF(GOPARR) THEN
         CALL DDI_BCAST(2161,'I',MAP  ,L1    ,MASTER)
         CALL DDI_BCAST(2162,'I',ISYM ,L1    ,MASTER)
         CALL DDI_BCAST(2163,'I',LEVNR,L1    ,MASTER)
         CALL DDI_BCAST(2164,'I',LEVPT,L1    ,MASTER)
         CALL DDI_BCAST(2165,'I',NABCB,NROWS ,MASTER)
         CALL DDI_BCAST(2166,'I',NLWKS,NROWS ,MASTER)
         CALL DDI_BCAST(2167,'I',NUWKS,NROWS ,MASTER)
         CALL DDI_BCAST(2168,'I',PUWK ,NROWS ,MASTER)
         CALL DDI_BCAST(2161,'I',INDX ,NWKS  ,MASTER)
         CALL DDI_BCAST(2162,'I',IARC ,NROWS4,MASTER)
         CALL DDI_BCAST(2163,'I',IWGHT,NROWS4,MASTER)
      END IF
C
      CALL SEQREW(NFT11)
C
C        ensure loop generator knows these two parameters
C
      NORBS0 = NORBSDRT
      NWKS0  = NWKS
C
C        read first CI vectors into memory, even if not weighted.
      IF(IOPT.EQ.0) THEN
         DO IST=1,NSTATE
            ENGY(IST) = ESTATE(IST)
            CALL SQREAD(NFT12,CIVEC(1,IST),NWKS)
         ENDDO
C
C        read CI vectors into memory, skip roots with no weight.
      ELSE
         IWST=1
         DO IST=1,NSTATECI
            IF(IAVGGUGA(IWST).EQ.IST  .AND.  IWST.LT.NSTATE) THEN
               ENGY(IWST) = ESTATE(IST)
               CALL SQREAD(NFT12,CIVEC(1,IWST),NWKS)
               IWST=IWST+1
            ELSE
               CALL SEQADV(NFT12)
            END IF
         ENDDO
         IF(IWST.LT.NSTATE) THEN
            IF(MASWRK) WRITE(IW,*) 'GUGTDM: TOO FEW ROOTS FROM DISK'
            CALL ABRT
         END IF
      END IF
C
      CALL SEQREW(NFT12)
C
C     learn how to unmap GUGA's orbital reordering.
C           (core orbitals not included)
C
      DO I=1,N_ACTIVE
        MAP_REV(MAP(I+NCORBS))=I
      END DO
C
C     -----           LOOP OVER STATE PAIRS            -----
C     upper triangular loop structure!
C     lower triangle is not computed, as it is the transpose.
C
      DO KSTAT=1,NSTATE
        DO ISTAT=KSTAT,NSTATE
C
C     ----- MAKE THE STATE-SPECIFIC OR TRANSITION DENSITY MATRIX -----
C
           CALL VCLR(WORK,1,N_ACTIVE*N_ACTIVE)
C
           ISTATE = ISTAT
           KSTATE = KSTAT
           CALL LOOPY1TDM(NABCB,IARC,NLWKS,NUWKS,PUWK,IWGHT,INDX,
     *                    ISEGM,JSEGM,IMAIN,ISUB,ACOEF,
     *                    IUWKMN,IUWKSB,ISYM,LEVPT,LEVNR,
     *                    NROWS,NROWS4,L1,
     *                    CIVEC(1,ISTATE),CIVEC(1,KSTATE),ISTATE,KSTATE,
     *                    WORK,NWKS,N_ACTIVE)
C
           CALL DSCAL(N_ACTIVE*N_ACTIVE,HALF,WORK,1)
           IF(ISTAT.NE.KSTAT) THEN
              DO I=1,N_ACTIVE
                 WORK(I,I) = WORK(I,I) + WORK(I,I)
              ENDDO
           END IF
C
C     ----- MAP BACK TO ORIGINAL ORBITAL ORDER -----
C     note that we only write istat<kstat to disk later,
C     storage is inefficient because determinant code
C     stores without exploiting the state symmetry.
C
           DO I=1,N_ACTIVE
              DO J=1,N_ACTIVE
                 FULL_DM(MAP_REV(I),MAP_REV(J),KSTAT,ISTAT)=WORK(I,J)
              ENDDO
           ENDDO
C
C     Generate the lower triangle over states by transposing AO indices.
C
           IF(ISTAT.NE.KSTAT) THEN
             DO I=1,N_ACTIVE
                DO J=1,N_ACTIVE
                   FULL_DM(J,I,ISTAT,KSTAT) = FULL_DM(I,J,KSTAT,ISTAT)
                ENDDO
             ENDDO
          END IF
C
        END DO
      END DO
      RETURN
C
  910 CONTINUE
      IF(MASWRK) WRITE(IW,9800) NWKSCI,NWKSDRT,TITLE,TITLE1
      CALL ABRT
      STOP
 9800 FORMAT(/5X,'GUGTDM: ERROR IN CI VECTOR TAPE AND DRT TAPE'/
     *        1X,'CI FILE HAS NWKS=',I10,' DRT FILE HAS NWKS=',I10/
     *        1X,'CI VECTOR FILE HAS TITLE:'/1X,10A8/
     *        1X,'DRT FILE       HAS TITLE:'/1X,10A8)
      END
C
C*MODULE DIAB    *DECK LOOPY1TDM
      SUBROUTINE LOOPY1TDM(NABC,IARC,NLWKS,NUWKS,PUWK,IWGHT,INDX,
     *                     ISEGM,JSEGM,IMAIN,ISUB,ACOEF,
     *                     IUWKMN,IUWKSB,ISYM,LEVPT,LEVNR,
     *                     NROWS,NROWS4,L1,
     *                     VEC1,VEC2,IST1,IST2,WORK_DM,NWKS,NACT)
C--   IMPLICIT double precision(a-h,o-z)
      IMPLICIT NONE
      DOUBLE PRECISION ACOEF, VEC1, VEC2, WORK_DM
      INTEGER IARC, IMAIN, INDX, ISEGM, IST1, IST2, ISUB,
     *        ISYM, IUWKMN, IUWKSB, IWGHT, JSEGM, L1,
     *        LEVNR, LEVPT, NABC, NACT, NLWKS, NROWS,
     *        NROWS4, NUWKS, NWKS
      DOUBLE PRECISION A, ACOF, CFS, COEFFS,
     *                 ONE, TWO, ZERO
      INTEGER I, IA, IAD, IARCMN, IARCSB, IARPT, IB, IDAF,
     *        IHAI, IJK, IJKT, IMN, IODA, IP, IR, IROW,
     *        ISB, ISEG, ISHIFT, IUWK, IW, J, JARPT, JB,
     *        JMN, JSB, JSEGNR, JSEGPT, JSM, JUWK, JXT,
     *        K, KMN, KSB, KSEG, KSEGMX, LDGUGA, LEV,
     *        LEVI, LEVL, LEVM, NAV, NLEVS, NLWK, NORBS,
     *        NPT, NR, NUWK, NWKS0, NXTSEG
C
C     ----- THIS ROUTINE IS A STRIPPED DOWN VERSION OF LOOPY -----
C     only one electron loops are computed,
C     total density is returned if state vectors are the same,
C     transition density is returned if these differ.
C
      INTEGER PUWK
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /LOOPS1/ ACOF,NWKS0,NORBS,IB,JB,IUWK,JUWK,NUWK,NLWK,
     *                IHAI,LDGUGA
C
      DIMENSION NABC(NROWS),IARC(NROWS4),NLWKS(NROWS),
     *          NUWKS(NROWS),PUWK(NROWS),IWGHT(NROWS4)
      DIMENSION INDX(NWKS)
      DIMENSION ISEGM(L1),JSEGM(L1),IMAIN(L1),ISUB(L1),
     *          ACOEF(L1),IUWKMN(L1),IUWKSB(L1),
     *          ISYM(L1),LEVPT(L1),LEVNR(L1)
      DIMENSION VEC1(NWKS),VEC2(NWKS)
      DIMENSION WORK_DM(NACT,NACT)
C
      DIMENSION ISHIFT(4)
C
      DIMENSION JSEGNR(3),JSEGPT(3),IARCMN(21),IARCSB(21)
      DIMENSION NXTSEG(21),JXT(21),JMN(21),JSB(21)
      DIMENSION COEFFS(20,5),CFS(100)
C
      EQUIVALENCE (COEFFS(1,1),CFS(1))
      EQUIVALENCE (JXT(1),NXTSEG(1))
      EQUIVALENCE (JMN(1),IARCMN(1))
      EQUIVALENCE (JSB(1),IARCSB(1))
C
      DATA JSEGNR /7,14,21/
      DATA JXT    /0,0,0,2,2,3,3,0,0,2,2,2,2,3,0,0,3,3,3,3,2/
      DATA JMN    /2,3,4,3,4,2,4,1,2,1,2,3,4,2,1,3,1,2,3,4,3/
      DATA JSB    /2,3,4,1,2,1,3,3,4,1,2,3,4,3,2,4,1,2,3,4,2/
      DATA ZERO   /0.0D+00/
      DATA ONE    /1.0D+00/
      DATA TWO    /2.0D+00/
C
      JSEGPT(1)=0
      DO 130 I=1,2
 130  JSEGPT(I+1)=JSEGNR(I)
      DO 135 I=1,2
      DO 135 J=1,5
 135  COEFFS(I,J)=ZERO
C
C     ----- THESE ARE THE POSSIBLE SEGMENT COEFFICIENTS -----
C
      DO 140 I=3,20
      A = I-2
      COEFFS(I,1)= ONE/A
      COEFFS(I,2)=-ONE/A
      COEFFS(I,3)=SQRT((A+ONE)/A)
      COEFFS(I,4)=SQRT(A/(A+ONE))
      COEFFS(I,5)=SQRT(A*(A+TWO))/(A+ONE)
 140  CONTINUE
      DO 150 K=1,4
      ISHIFT(K)=(K-1)*NROWS
 150  CONTINUE
      NLEVS=NORBS+1
C
C     ----- START THE MAIN LOOP -----
C
      DO 500 LEVI=2,NLEVS
      LEV=LEVI
      LEVM=LEV-1
      JSM=ISYM(LEVM)
      IAD=LEVM
      NR=LEVNR(LEV)
      NPT=LEVPT(LEV)
      DO 480 IROW=1,NR
      NPT=NPT+1
      ISEGM(LEV)=1
      ISEG=1
      IMN=NPT
      ISB=NPT
      KSEG=0
      KSEGMX=JSEGNR(ISEG)
      IUWKMN(LEV)=PUWK(NPT)
      IUWKSB(LEV)=PUWK(NPT)
      IMAIN(LEV)=NPT
      ISUB(LEV)=NPT
      NUWK=NUWKS(NPT)
      ACOEF(LEV)=ONE
C
C     ----- SEARCH FOR NEXT LOOP SEGMENT -----
C
 200  KSEG = KSEG + 1
      IF(KSEG.GT.KSEGMX) GO TO 440
      KMN = IARCMN(KSEG)
      IARPT = IMN + ISHIFT(KMN)
      KMN = IARC(IARPT)
      IF(KMN.EQ.0) GO TO 200
      KSB = IARCSB(KSEG)
      JARPT = ISB + ISHIFT(KSB)
      KSB = IARC(JARPT)
      IF(KSB.EQ.0) GO TO 200
      JSEGM(LEV) = KSEG
      IUWKMN(LEVM) = IUWKMN(LEV) + IWGHT(IARPT)
      IUWKSB(LEVM) = IUWKSB(LEV) + IWGHT(JARPT)
C
C      -----     HAVING FOUND A VALID SEGMENT    -----
C      ----- UPDATE THE VALUE OF THE COEFFICIENT -----
C
      GO TO (1,1,4,1,12,1,8,1,7,1,17,2,2,3,1,13,1,2,19,2,6), KSEG
C
   1  ACOEF(LEVM) = ACOEF(LEV)
      GO TO 20
   2  ACOEF(LEVM) = -ACOEF(LEV)
      GO TO 20
   3  IA=NABC(IMN)+2
      ACOEF(LEVM)=ACOEF(LEV)*CFS(IA)
      GO TO 20
   4  ACOEF(LEVM)=ACOEF(LEV)+ACOEF(LEV)
      GO TO 20
   6  IA=NABC(IMN)+24
      ACOEF(LEVM)=ACOEF(LEV)*CFS(IA)
      GO TO 20
   7  IA=NABC(IMN)+42
      ACOEF(LEVM)=ACOEF(LEV)*CFS(IA)
      GO TO 20
   8  IA=NABC(IMN)+43
      ACOEF(LEVM)=ACOEF(LEV)*CFS(IA)
      GO TO 20
   12 IA=NABC(IMN)+62
      ACOEF(LEVM)=ACOEF(LEV)*CFS(IA)
      GO TO 20
   13 IA=NABC(IMN)+63
      ACOEF(LEVM)=ACOEF(LEV)*CFS(IA)
      GO TO 20
   17 IA=NABC(IMN)+81
      ACOEF(LEVM)=ACOEF(LEV)*CFS(IA)
      GO TO 20
   19 IA=NABC(IMN)+83
      ACOEF(LEVM)=ACOEF(LEV)*CFS(IA)
      GO TO 20
   20 CONTINUE
      IF(NXTSEG(KSEG).GT.0) GO TO 400
      IF(ISYM(LEVM).NE.JSM)GO TO 200
      IF(KMN-KSB) 300,380,300
C
C     ----- UPDATE ALL VARIABLES FOR THE NEW SEGMENT -----
C
 300  LEVL=LEVM
      KSEGMX=4
 310  LEV=LEVM
      LEVM=LEV-1
      IF(LEVM.GT.0) GO TO 315
C
      WRITE(IW,313)
 313  FORMAT(1X,'LOOPY1TDM: PROBLEMS WITH PARTIAL SPACE')
      CALL ABRT
      STOP
C
 315  CONTINUE
      KSEG=0
      IMN=KMN
      IMAIN(LEV)=KMN
      ISB=KSB
      ISUB(LEV)=KSB
 320  KSEG = KSEG + 1
      IF(KSEG.GT.KSEGMX) GO TO 360
      IARPT = IMN + ISHIFT(KSEG)
      KMN = IARC(IARPT)
      IF(KMN.LE.0) GO TO 320
      JARPT = ISB + ISHIFT(KSEG)
      KSB = IARC(JARPT)
      IF(KSB.LE.0) GO TO 320
      JSEGM(LEV) = KSEG
      IMAIN(LEVM)=KMN
      IUWKMN(LEVM)=IUWKMN(LEV)+IWGHT(IARPT)
      ISUB(LEVM)=KSB
      IUWKSB(LEVM)=IUWKSB(LEV)+IWGHT(JARPT)
      IF(KMN-KSB) 310,340,310
C
C     -----             A LOOP HAS BEEN CONSTRUCTED             -----
C     ----- FIND ITS CONTRIBUTION AND ADD TO THE DENSTIY MATRIX -----
C
 340  IB = IAD
      JB = LEVL
      NLWK = NLWKS(KMN)
      IUWK = IUWKMN(LEVM)
      JUWK = IUWKSB(LEVM)
      ACOF = ACOEF(LEVL)
      CALL MAKETDM(VEC1,VEC2,IST1,IST2,INDX,WORK_DM,NACT,NWKS)
      GO TO 320
 360  IF(LEV.EQ.LEVL) GO TO 440
      LEVM=LEV
      LEV=LEVM+1
      IMN=IMAIN(LEV)
      ISB=ISUB(LEV)
      KSEG=JSEGM(LEV)
      GO TO 320
 380  IB = IAD
      JB = LEVM
      NLWK = NLWKS(KMN)
      IUWK = IUWKMN(LEVM)
      JUWK = IUWKSB(LEVM)
      ACOF = ACOEF(LEVM)
      CALL MAKETDM(VEC1,VEC2,IST1,IST2,INDX,WORK_DM,NACT,NWKS)
      GO TO 200
 400  CONTINUE
      LEV = LEVM
      LEVM = LEV - 1
      ISEG = NXTSEG(KSEG)
      ISEGM(LEV) = ISEG
      KSEG = JSEGPT(ISEG)
      IMN = KMN
      IMAIN(LEV) = KMN
      ISB = KSB
      ISUB(LEV) = KSB
      KSEGMX = JSEGNR(ISEG)
      GO TO 200
 440  CONTINUE
      IF(LEV.EQ.LEVI) GO TO 480
      LEVM = LEV
      LEV = LEVM + 1
      ISEG = ISEGM(LEV)
      IMN = IMAIN(LEV)
      ISB = ISUB(LEV)
      KSEG = JSEGM(LEV)
      KSEGMX = JSEGNR(ISEG)
      GO TO 200
 480  CONTINUE
 500  CONTINUE
      RETURN
      END
C
C*MODULE DIAB    *DECK MAKETDM
      SUBROUTINE MAKETDM(VEC1,VEC2,IST1,IST2,INDX,TEMP_DM,NACT,NWKS)
C--   IMPLICIT double precision(a-h,o-z)
      IMPLICIT NONE
      DOUBLE PRECISION TEMP_DM, VEC1, VEC2
      INTEGER INDX, IST1, IST2, NACT, NWKS
      DOUBLE PRECISION ACOEF, DC, ZERO
      INTEGER I, IB, IHAI, II, IND, IUWK, J, JB, JJ,
     *        JND, JUWK, LDGUGA, NLWK, NORBS, NUWK, NWKS0
C
      DIMENSION VEC1(NWKS),VEC2(NWKS),TEMP_DM(NACT,NACT),INDX(NWKS)
C
      COMMON /LOOPS1/ ACOEF,NWKS0,NORBS,IB,JB,IUWK,JUWK,NUWK,NLWK,
     *                IHAI,LDGUGA
      DATA ZERO/0.0D+00/
C
C     form state specific density or transition density matrix
C
      IND = IUWK
      JND = JUWK
      DC = ZERO
      DO I=1,NLWK
       II = INDX(IND)
       JJ = INDX(JND)
       DO J=1,NUWK
        DC = DC + VEC1(II) * VEC2(JJ)
        II = II + 1
        JJ = JJ + 1
       ENDDO
       IND = IND + 1
       JND = JND + 1
      ENDDO
C
      IF(IUWK.NE.JUWK) DC=DC+DC
C
      IF(IST1.EQ.IST2) THEN
         TEMP_DM(IB,JB) = TEMP_DM(IB,JB) + ACOEF * DC
         TEMP_DM(JB,IB) = TEMP_DM(JB,IB) + ACOEF * DC
         RETURN
      ELSE
         TEMP_DM(IB,JB) = TEMP_DM(IB,JB) + ACOEF * DC
      END IF
C
C         transition density needs to run the other way around,
C         but only for its off-diagonal elements.
C
      IF(IB.EQ.JB) RETURN
C                  ******
      IND=IUWK
      JND=JUWK
      DC=ZERO
C
      DO I=1,NLWK
         II=INDX(IND)
         JJ=INDX(JND)
         DO J=1,NUWK
            DC=DC+VEC2(II)*VEC1(JJ)
            II=II+1
            JJ=JJ+1
         END DO
         IND=IND+1
         JND=JND+1
      END DO
C
      IF (IUWK.NE.JUWK) DC=DC+DC
      TEMP_DM(JB,IB)=TEMP_DM(JB,IB) + ACOEF * DC
      RETURN
      END
C
C*MODULE DIAB    *DECK DETTDMX
      SUBROUTINE DETTDMX(NCORBS,NACT,NBF,NSTATE,TDM,ENGY,IOPT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION TDM(NACT,NACT,NSTATE,NSTATE),ENGY(NSTATE)
C
      PARAMETER (MXRT=100)
C
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,SDET,SZDET,
     *                GRPDET,STSYM,GLIST,DWPARM,NFLGDM(MXRT),
     *                IWTS(MXRT),NCORSV,NCORDET,NACTDET,NORBDET,
     *                NADET,NBDET,KDET,KSTDET,IROOT,IPURES,MAXW1,NITDET,
     *                MAXP,NCIDET,IGPDET,KSTSYM,NFTGCI,IDWEIGH
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      DATA CHECK/8HCHECK   /
C
C         --- driver for density and transition density computation ---
C            CI states must be from the determinant full CI program!
C        If IOPT=0, the first -NSTATE- states are computed,
C                   even if they have no weight assigned.
C        If IOPT=1, states with non-zero weights are skipped,
C                   so the densities are for the first NSTATE
C                   states that actually have a weight.
C        For both options, we filter out the spins we don't want.
C
C         Note that ORMAS-type CI states could be programmed, as a
C         routine akin to MATTD1 exists in the response eqn. code.
C
C         Recall that
C          ncidet      is number of determinants in this run
C          nstate      is number of states included in density calc.
C          nadet/nabet is alpha/beta e- count in this active space
C          ncorbs      is number of inert orbitals (filled)
C          nact        is number of active orbitals
C          nalp/nblp   is binomial value for this active space's dims
C
      NORBS = NCORBS + NACT
      NSYM = 2**IGPDET
      CALL VALFM(LOADFM)
      LIFA    = LOADFM  + 1
      CALL BINOM6(X(LIFA),NACT)
      CALL ASKIFA(X(LIFA),NACT,NADET,NBDET,NALP,NBLP)
      LIOX    = LIFA    + (NACT+1)**2
      LCIVEC  = LIOX    + MAX(NACT,NBF)
      LIACON1 = LCIVEC  + NCIDET*NSTATE
      LIBCON1 = LIACON1 + NADET + 43
      LIACON2 = LIBCON1 + NADET
      LIPOSA  = LIACON2 + NADET
      LIPERA  = LIPOSA  + NADET*(NACT-NADET)
      LIIND1  = LIPERA  + NADET*(NACT-NADET)
      LINDEX  = LIIND1  + NADET*(NACT-NADET)
      LISYMA  = LINDEX  + NACT*NACT
      LISYMB  = LISYMA  + NALP
      LISPA   = LISYMB  + NBLP
      LISPB   = LISPA   + NALP
      LISAS   = LISPB   + NBLP
      LISBS   = LISAS   + NSYM + 1
      LISAC   = LISBS   + NSYM + 1
      LISBC   = LISAC   + NALP
      LICOA   = LISBC   + NBLP
      LICOB   = LICOA   + NSYM
      LITAB   = LICOB   + NSYM
      LIMUL   = LITAB   + NSYM
      LAST    = LIMUL   + NSYM*NSYM
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      IF(EXETYP.EQ.CHECK) THEN
         CALL VCLR(TDM,1,NACT*NACT*NSTATE*NSTATE)
         CALL VCLR(ENGY,1,NSTATE)
         GO TO 800
      END IF
C
C        get CI vectors
C
      CALL RDDETCIVEC(X(LCIVEC),ENGY,NCIDET,NSTATE,IOPT)
C
C           next is prep work to use CAS-type determinant codes
C
      CALL DAREAD(IDAF,IODA,X(LIOX),NBF,262,1)
      CALL CORTRA(X(LIOX),NORBS,NCORBS)
      CALL SYMWRK(IW,X(LIOX),NACT,NADET,NBDET,IGPDET,KSTSYM,
     *            NSYM,NALP,NBLP,X(LIACON1),
     *            X(LISYMA),X(LISYMB),X(LICOA),X(LICOB),X(LITAB),
     *            X(LIMUL),X(LISPA),X(LISPB),X(LISAS),X(LISBS),
     *            X(LISAC),X(LISBC))
C
C          now generate both kinds of densities for determinant CAS-SCF
C
      CALL MATTD1(TDM,X(LCIVEC),NSTATE,NACT,NADET,NBDET,
     *            NCIDET,NALP,NBLP,X(LIFA),X(LIOX),NSYM,
     *            X(LIACON1),X(LIBCON1),X(LIACON2),
     *            X(LIPOSA),X(LIPERA),X(LIIND1),X(LINDEX),
     *            X(LISYMA),X(LISYMB),X(LISPA),X(LISPB),
     *            X(LISAS),X(LISBS),X(LISAC),X(LISBC))
C
  800 CONTINUE
      CALL RETFM(NEED)
      RETURN
      END
C
C*MODULE DIAB    *DEC ASKIFA
      SUBROUTINE ASKIFA(IFA,NACT,NA,NB,NALP,NBLP)
      DIMENSION IFA(0:NACT,0:NACT)
      NALP = IFA(NACT,NA)
      NBLP = IFA(NACT,NB)
      RETURN
      END
C
C*MODULE DIAB    *DECK RDDETCIVEC
      SUBROUTINE RDDETCIVEC(CIVEC,ENGY,NDET,NSTATE,IOPT)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION CIVEC(NDET,NSTATE),ENGY(NSTATE)
      LOGICAL GOPARR,DSKWRK,MASWRK,SVDSKW
      PARAMETER (MXRT=100)
      COMMON /CIFILS/ NFT11,NFT12,NFT13,NFT14,NFT15,NFT16,IDAF20,NEMEMX
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,SDET,SZDET,
     *                GRPDET,STSYM,GLIST,DWPARM,NFLGDM(MXRT),
     *                IWTS(MXRT),NCORSV,NCORDET,NACTDET,NORBDET,
     *                NADET,NBDET,KDET,KSTDET,IROOT,IPURES,MAXW1,NITDET,
     *                MAXP,NCIDET,IGPDET,KSTSYM,NFTGCI,IDWEIGH
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA ZERO/0.0D+00/
C
C     ----- Get CI vectors from file -----
C     We seek only NSTATE states, with an option to ignore those
C     with zero weight.  No more than NSTATE should be returned,
C     even if there are additional states on the vector file.
C     we also return the corresponding energy values.
C
      SVDSKW = DSKWRK
      DSKWRK = .FALSE.
      CALL SEQREW(NFT12)
      IF(MASWRK) READ(NFT12) NSTATES,NDETS
      IF(GOPARR) CALL DDI_BCAST(2150,'I',NSTATES,1,MASTER)
      IF(GOPARR) CALL DDI_BCAST(2151,'I',NDETS,1,MASTER)
C
      IF(NSTATES.LT.NSTATE .OR. NDETS.NE.NDET  .OR.
     *   NSTATES.NE.KDET   .OR. NDETS.NE.NCIDET) THEN
        IF(MASWRK) WRITE(IW,9360) NSTATES,NDETS,NSTATE,NDET,KDET,NCIDET
        CALL ABRT
      END IF
C
C         KDET is the total number of states actually solved for.
C         the logic below filters on spin value,
C         and maybe on state weight, if IOPT=1
C
      IF(IOPT.EQ.0) THEN
         NSTATES=0
         DO 100 IST=1,KDET
           IF(IPURES.EQ.1) THEN
              IF(ABS(SPINS(IST)-SDET) .GT. 0.03D+00) THEN
                CALL SEQADV(NFT12)
                GO TO 100
              END IF
           END IF
           NSTATES=NSTATES+1
           CALL SQREAD(NFT12,CIVEC(1,NSTATES),NDET)
           ENGY(NSTATES) = ESTATE(IST)
           IF(NSTATES.EQ.NSTATE) GO TO 300
  100    CONTINUE
      ELSE
         IWST = 0
         NSTATES = 0
         DO 150 IST=1,KDET
           IF(IPURES.EQ.1) THEN
              IF(ABS(SPINS(IST)-SDET) .GT. 0.03D+00) THEN
                CALL SEQADV(NFT12)
                GO TO 150
              END IF
              IWST = IWST + 1
           ELSE
              IWST = IWST + 1
           ENDIF
C
           IF(WSTATE(IWST).EQ.ZERO) THEN
              CALL SEQADV(NFT12)
           ELSE
              NSTATES = NSTATES + 1
              CALL SQREAD(NFT12,CIVEC(1,NSTATES),NDET)
              ENGY(NSTATES) = ESTATE(IST)
           ENDIF
           IF(NSTATES.EQ.NSTATE) GO TO 300
  150    CONTINUE
      END IF
C
  300 CONTINUE
      CALL SEQREW(NFT12)
      DSKWRK = SVDSKW
      RETURN
 9360 FORMAT(/1X,'***** ERROR IN -RDDETCIVEC- ROUTINE *****'/
     *       1X,'CI EIGENVECTOR FILE HAS DATA FOR NSTATE,NDET=',I3,I10/
     *       1X,'THIS ROUTINE CALLED ASKING FOR   NSTATE,NDET=',I3,I10/
     *       1X,'AND THE PRESENT CALCULATION IS   NSTATE,NDET=',I3,I10)
      END
C
C*MODULE DIAB    *DECK WRITETDM
      SUBROUTINE WRITETDM(NFT21,DEN,ENGY,NSTATE,NACT)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION DEN(NACT,NACT,NSTATE,NSTATE),ENGY(NSTATE)
      LOGICAL GOPARR,DSKWRK,MASWRK,SVDSKW,DEBUG
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C        output density and transition density matrices, as squares.
C            (toggle last part of -debug- to see 1PDM and 1TDM)
C
      DEBUG = MASWRK  .AND.  .FALSE.
C
      SVDSKW = DSKWRK
      DSKWRK = .FALSE.
      CALL SEQREW(NFT21)
C
      DO ISTAT=1,NSTATE
        DO JSTAT=ISTAT,NSTATE
           CALL SQWRIT(NFT21,DEN(1,1,ISTAT,JSTAT),NACT*NACT)
           IF(DEBUG) THEN
              IF(ISTAT.EQ.JSTAT) THEN
                 IF(MASWRK) WRITE(IW,9000) ISTAT,ENGY(ISTAT)
              ELSE
                 IF(MASWRK) WRITE(IW,9010) ISTAT,ENGY(ISTAT),
     *                                     JSTAT,ENGY(JSTAT)
              END IF
              CALL PRSQ(DEN(1,1,ISTAT,JSTAT),NACT,NACT,NACT)
           END IF
        ENDDO
      ENDDO
C
      CALL SEQREW(NFT21)
      DSKWRK = SVDSKW
      RETURN
 9000 FORMAT(1X,'STATE-SPECIFIC DENSITY MATRIX FOR STATE I=',I4,
     *          ' E=',F15.8)
 9010 FORMAT(1X,'TRANSITION DENSITY MATRIX BETWEEN STATE PAIR'/
     *       1X,'STATE I=',I4,' E=',F15.8,'  STATE J=',I4,' E=',F15.8)
      END
C
C*MODULE DIAB    *DECK READTDM
      SUBROUTINE READTDM(NFT,DM1,NSTATE,N_ACTIVE,NDMAT)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION DM1(N_ACTIVE,N_ACTIVE,NDMAT)
      LOGICAL GOPARR,DSKWRK,MASWRK,SVDSKW
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C This routine obtains the density matrices (DMs and TDM),
C reading only the upper triangle of state pair's TDM.
C Finally, a state averaged density is prepared.
C
C         Read the DM/TDM
C
      SVDSKW = DSKWRK
      DSKWRK = .FALSE.
      CALL SEQREW(NFT)
      LENDEN = N_ACTIVE*N_ACTIVE
      DO I=1,NDMAT-1
        CALL SQREAD(NFT,DM1(1,1,I),LENDEN)
      ENDDO
      CALL SEQREW(NFT)
      DSKWRK = SVDSKW
C
      CALL MKSTAVGDM1(DM1,NDMAT,N_ACTIVE,NSTATE)
C
      RETURN
      END
C
C*MODULE DIAB    *DECK MKSTAVGDM1
      SUBROUTINE MKSTAVGDM1(DM1,NDMAT,NACT,NSTATE)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION DM1(NACT,NACT,NDMAT)
      PARAMETER (MXDIABACT=30)
      COMMON /DIABAT/ ALPHA_N,ALPHA_R,ALPHA_T,
     *                TH_DOC,TH_VIR,SLCTTH,CONV_TH,WBLOCK(3),
     *                NDFRM,NDMOSYM,NRCSF,NMLAP,NDLAP,NORIENT,
     *                MOSLAB_CHARACT(MXDIABACT),
     *                MAX_ITER,NGRSTATE,NEXSTATE,NSTDIAB,
     *                NSYMBOL_DOC,NSYMBOL_VAL,NSYMBOL_VIR
      DATA ZERO/0.0D+00/
C
C        Prepare a state averaged density, using DMO's block weights.
C
      CALL VCLR(DM1(1,1,NDMAT),1,NACT*NACT)
C
      ISTDM=1
      DO ISTAT=1,NSTATE
        WTDIAB = ZERO
        IF(ISTAT.LE.NGRSTATE)         WTDIAB=WBLOCK(1)/NGRSTATE
        IF(ISTAT.GT.NGRSTATE)         WTDIAB=WBLOCK(2)/NSTDIAB
        IF(ISTAT.GT.NGRSTATE+NSTDIAB .AND. NEXSTATE.NE.0)
     *                                WTDIAB=WBLOCK(3)/NEXSTATE
        DO I=1,NACT
          DO J=1,NACT
            DM1(J,I,NDMAT) = DM1(J,I,NDMAT) + WTDIAB*DM1(J,I,ISTDM)
          END DO
        END DO
        ISTDM=ISTDM+NSTATE-ISTAT+1
      END DO
      RETURN
      END
C
C*MODULE DIAB    *DECK DFMSYMVEC
      SUBROUTINE DFMSYMVEC(NUM,N_ACTIVE,VEC,S,SMO,
     *                     TRI,EIGVEC,EIGVAL,WORK,IWORK)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,DEBUG
C
      PARAMETER (MXAO=8192)
C
      DIMENSION VEC(NUM,N_ACTIVE)      ! $DFMVEC'S DATA (INPUT)
      DIMENSION S(NUM*(NUM+1)/2)       ! AO OVERLAP (INPUT)
      DIMENSION SMO(N_ACTIVE,N_ACTIVE) ! MO OVERLAP
      DIMENSION TRI(*)                 ! TRIANGLE OF SIZE N_ACTIVE
      DIMENSION EIGVEC(N_ACTIVE,N_ACTIVE)
      DIMENSION EIGVAL(N_ACTIVE)
      DIMENSION WORK(N_ACTIVE,N_ACTIVE)
      DIMENSION IWORK(N_ACTIVE)
C
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA ZERO/0.0D+00/
C
C        This routine transforms the $DFMVEC to the
C            symmetrically orthogonalized one.
C
      DEBUG = MASWRK  .AND.  .FALSE.
C
C Calculate MO overlap matrix smo(j,i)=<j|i>
C
      DO I=1,N_ACTIVE
        DO J=1,N_ACTIVE
          DUM=ZERO
          DO K=1,NUM
            DO L=1,NUM
              IF (L.LE.K) THEN
                IND_KL=IA(K)+L
              ELSE
                IND_KL=IA(L)+K
              END IF
              DUM=DUM+VEC(K,I)*VEC(L,J)*S(IND_KL)
            END DO
          END DO
          SMO(I,J)=DUM
        END DO
      END DO
C
C Symmetric Orthogonalization of vec (by using overlap matrix -smo-)
C
      CALL DFMSYMORTH(VEC,SMO,N_ACTIVE,NUM,TRI,EIGVEC,EIGVAL,WORK,IWORK)
C
      IF(DEBUG) THEN
         IF(MASWRK) WRITE(IW,9700)
         CALL PRSQ(SMO,N_ACTIVE,N_ACTIVE,N_ACTIVE)
      END IF
      RETURN
C
 9700 FORMAT(/1X,'SYMMETRIC ORTHOGONALIZATION TRANSFORMATION OF',
     *       ' $DFMVEC IS:')
      END
C
C*MODULE DIAB    *DECK DFMSYMCHK
      SUBROUTINE DFMSYMCHK(NUM,N_ACTIVE,NQMT,MOSLAB,W,Q,S,TEMP,
     *                     MOSLAB_REF,STDPHASE)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      CHARACTER*8 DFMVEC
      LOGICAL STDPHASE
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION MOSLAB(N_ACTIVE)      ! IRREPS LABEL FOR ACTIVE MOS
      DIMENSION W(NUM*N_ACTIVE)       ! REF DMO/AO COEFFICIENT
      DIMENSION Q(NUM,NUM)            ! CANONICAL VEC
      DIMENSION S(NUM*(NUM+1)/2)      ! AO OVERLAP
      DIMENSION TEMP(NUM)             ! TEMPORARY REGION
      DIMENSION MOSLAB_REF(N_ACTIVE)  ! IRREPS LABELS FOR REF DMOS
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      DATA CHECK/8HCHECK   /
C
C This routine assign the irreps of $DFMVEC and check each irreps
C array component is same with current MOs or not.
C This procedure is necessary when DMO-based CI is carried out.
C
C Read $DFMVEC
C
      DFMVEC = ' $DFMVEC'
      IF(MASWRK) WRITE(IW,9000) DFMVEC
C
      CALL SEQREW(IR)
      CALL FNDGRP(IR,DFMVEC,IEOF)
      IF(IEOF.EQ.0) GO TO 20
C
      IF(MASWRK) WRITE(IW,*) 'CANNOT FIND $DFMVEC INPUT GROUP. STOP'
      CALL ABRT
C
   20 CONTINUE
      IF(MASWRK) THEN
         DO J=1,N_ACTIVE
            MAX=0
   30       CONTINUE
               MIN=MAX+1
               MAX=MAX+5
               IF (MAX.GT.NUM) MAX=NUM
               READ(IR,9810) (W(I+NUM*(J-1)),I=MIN,MAX)
            IF (MAX.LT.NUM) GO TO 30
          END DO
      END IF
      IF(GOPARR) CALL DDI_BCAST(2155,'F',W,NUM*N_ACTIVE,MASTER)
C
C Now all $DFMVEC data stored in w
C
      IF(STDPHASE) THEN
         IF(MASWRK) WRITE(IW,9001) DFMVEC,N_ACTIVE
         CALL STFASE(W,NUM,NUM,N_ACTIVE)
      END IF
C
C   Assign symmetry (irreps) for reference DMOs
C   and sort refernce DMOs by irreps with using moslab_ref
C
      CALL DAREAD(IDAF,IODA,Q,NUM*NUM,45,0)
      CALL SYMMOS(MOSLAB_REF,Q,S,W,TEMP,NQMT,NUM,N_ACTIVE,NUM)
C
      IF(EXETYP.EQ.CHECK) RETURN
C
C    Check symmetry label beween the current MOs and $DFMVEC for
C    active space
C
      DO I=1,N_ACTIVE
        IF (MOSLAB(I).NE.MOSLAB_REF(I)) THEN
          IF(MASWRK) THEN
             WRITE(IW,9200)
             WRITE(IW,9800) (MOSLAB(J),J=1,N_ACTIVE)
             WRITE(IW,9210)
             WRITE(IW,9800) (MOSLAB_REF(J),J=1,N_ACTIVE)
             WRITE(IW,*) 'STOP'
          END IF
          CALL ABRT
        END IF
      END DO
      RETURN
C
 9000 FORMAT(/1X,'READING REFERENCE GEOMETRY''S',A8,
     *           ' ORBITAL INPUT GROUP')
 9001 FORMAT(1X,'ADJUSTING',A8,' TO STANDARD PHASE:',I4,' ORBS.')
 9800 FORMAT(1X,15A5)
 9810 FORMAT(5X,5E15.8)
 9200 FORMAT(/10X,'**** ERROR ****'/
     *        1X,'$DFMVEC IRREP ORDERING IS DIFFERENT FROM THE'/
     *        1X,'THE ORDERING OF MOS FROM THIS RUN''S MCSCF.'/
     *        1X,'SYMMETRY LABELS FOR THE ACTIVE MCSCF ORBITALS:')
 9210 FORMAT(1X,'SYMMETRY LABELS FOR THE ACTIVE $DFMVEC ORBITALS:')
      END
C
C*MODULE DIAB    *DECK DFMSYMORTH
      SUBROUTINE DFMSYMORTH(VEC,S,NVEC,NUM,TRI,EIGVEC,EIGVAL,WORK,IWORK)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION VEC(NUM,NVEC)
      DIMENSION S(NVEC,NVEC)
      DIMENSION TRI(*),EIGVEC(NVEC,NVEC),EIGVAL(NVEC)
      DIMENSION WORK(NVEC,NVEC),IWORK(NVEC)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA  ZERO /0.0D+00/
      DATA  ONE  /1.0D+00/
      DATA  ERR_TH /1.0D-04/
C
C This routine calculate symmetric orthogonal vectors and determine
C sign of vectors as they agree with original vectors.
C
C nvec ....   total number of vectors to orthogonalize
C num  ....   dimension of vector
C s(i,j) .... overlap matrix between i-th vector and j-th.
C             Assumed that full matrix elements are stored. (input)
C             Return as transformation (sym. orthogonalized) matrix
C vec(*,i)... on entry, the $DFMOVEC orbitals.
C             Return as the symmetric orthonormalized vector.
C tri,eigvec,eigval ... diagonalization work spaces
C work,iwork .... scratch spaces
C
C
C          S^{-1/2} = U*diag(s^{-1/2})*U^{t}
C          first, diagonalize S in MO space...
C
      CALL CPYSQT(S,TRI,NVEC,1)
      CALL JACDG(TRI,EIGVEC,EIGVAL,IWORK,WORK,NVEC,NVEC)
      DO I=1,NVEC
        IF (EIGVAL(I).LT.ERR_TH) THEN
          IF(MASWRK) THEN
           WRITE(IW,*) 'DFMSYMORTH: CANNOT SYMMETRIC/ORTHOGONALIZE,'
           WRITE(IW,*) 'OVERLAP MATRIX TURNED OUT TO BE SINGULAR.'
           END IF
          CALL ABRT
        END IF
        EIGVAL(I)=ONE/SQRT(EIGVAL(I))
      END DO
C
C       generate  S^{-1/2} = (T*eigval**(-1/2))*T-dagger
C       S^{-1/2} overwrites array S
C
      DO I=1,NVEC
        DO J=1,NVEC
          WORK(I,J) = EIGVEC(I,J)*EIGVAL(J)
        END DO
      END DO
      CALL DGEMM('N','T',NVEC,NVEC,NVEC,ONE,WORK,NVEC,
     *           EIGVEC,NVEC,ZERO,S,NVEC)
C
C Check phase of each column
C
      DO J=1,NVEC
        IF (S(J,J).LT.ZERO) THEN
          DO I=1,NVEC
            S(I,J)=-S(I,J)
          END DO
        END IF
      END DO
C
C do symmetric orthogonalization of -vec- overwriting orig $DFMOVEC
C       VEC = VEC * S^(-1/2)
C
      CALL DCOPY(NUM*NVEC,VEC,1,EIGVEC,1)
      CALL DGEMM('N','N',NUM,NVEC,NVEC,ONE,EIGVEC,NUM,
     *            S,NVEC,ZERO,VEC,NUM)
      RETURN
      END
C
C*MODULE DIAB    *DECK REFDMOSYM
      SUBROUTINE REFDMOSYM(N_RES,NQMT,NUM,W,Q,S,TEMP,TRANS,MOSLAB_REF,
     *                     VECWRD,FRWRD,NATOM,NORIENT,STDPHASE)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      CHARACTER*8 VECWRD,FRWRD
      CHARACTER*8 CHARATM
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL STDPHASE
C
      DIMENSION W(NUM,N_RES)         ! REF DMO/AO COEFFICIENT
      DIMENSION Q(NUM,NUM)           ! CANONICAL VEC
      DIMENSION S(NUM*(NUM+1)/2)     ! AO OVERLAP
      DIMENSION TEMP(NUM)            ! TEMPORARY REGION
      DIMENSION TRANS(3,3,NATOM)
      DIMENSION MOSLAB_REF(N_RES)
C
      DIMENSION KCART(7)
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXAO=8192, MXATM=2000)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
C
      DATA ZERO,ONE /0.0D+00,1.0D+00/
      DATA TH_ZERO /1.0D-03/
C
C Function: (1) transform ref or pseudo ref MO coef from specified
C               orientation by input to the current standard orientation
C               (i.e. coordinates of $BASIS)  for each atom
C        Then
C           (2) assign the irreps of the reference DMOs and
C               make label (moslab_ref) then return it.
C
C Note: current version transform MO coefs of only p type.
C     : for d,f... type are eliminated!
C
C natom... # of total atoms
C label_type(i,j) ... j-th atom's i-th AO's label
C label2.... data set of labels like s, px,....
C w     .... ref or pseudo ref MO coef of (specific orientation:input)
C                          (current standard orientation:output)
C
C        Read -VECWRD- group (either $DIAVEC or $DPSVEC)
C
      IF(MASWRK) WRITE(IW,9000) VECWRD
C
      CALL SEQREW(IR)
      CALL FNDGRP(IR,VECWRD,IEOF)
C
      IF(IEOF.GT.0) THEN
         IF(MASWRK) WRITE(IW,9020) VECWRD
         CALL ABRT
      END IF
C
      IF(MASWRK) THEN
         DO J=1,N_RES
           MAX=0
   30      CONTINUE
              MIN=MAX+1
              MAX=MAX+5
              IF (MAX.GT.NUM) MAX=NUM
              READ(IR,9810) (W(I,J),I=MIN,MAX)
              IF (MAX.LT.NUM) GO TO 30
         END DO
      END IF
      IF(GOPARR) CALL DDI_BCAST(2156,'F',W,NUM*N_RES,MASTER)
C
C    Now all reference (or pseudo) MO coeffcients are stored in -W-
C
      IF(STDPHASE) THEN
         IF(MASWRK) WRITE(IW,9001) VECWRD,N_RES
         CALL STFASE(W,NUM,NUM,N_RES)
      END IF
C
C    If orienting the coordinates,
C    Read -FRWRD- input group, either $LCLDC or $LCLVL as apprpriate,
C    then transform ref (pseudo ref) MO coeffs sequentially
C
C    if there is no specific orientation, (if norient=0)
C    then use the current standard orientation)
C
      IF (NORIENT.NE.0) THEN
         CALL SEQREW(IR)
         CALL FNDGRP(IR,FRWRD,IEOF)
C
         IF(IEOF.GT.0) THEN
            IF(MASWRK) WRITE(IW,9030) FRWRD
            CALL ABRT
         ELSE
            IF(MASWRK) WRITE(IW,9035) VECWRD,FRWRD
         END IF
C
C                  loop over ref (pseudo ref) MOs
C
         DO IORB=1,N_RES
C                  -- this orbital's desired rotation --
            DO I=1,NATOM
             IF(MASWRK) THEN
               READ(IR,*) CHARATM,TRANS(1,1,I),TRANS(2,1,I),TRANS(3,1,I)
               READ(IR,*)         TRANS(1,2,I),TRANS(2,2,I),TRANS(3,2,I)
               READ(IR,*)         TRANS(1,3,I),TRANS(2,3,I),TRANS(3,3,I)
               READ(UNIT=CHARATM,FMT='(A8)') ANAM_RD
C                      -- check-(1)--
               IF (ANAM_RD.NE.ANAM(I)) THEN
                 WRITE(IW,9040) FRWRD,I,CHARATM,I,FRWRD,ANAM(I)
                 CALL ABRT
               END IF
             END IF
            END DO
            IF(GOPARR) CALL DDI_BCAST(2157,'F',TRANS,3*3*NATOM,MASTER)
C                      -- check (2)--
            DO I=1,NATOM
               DUM1=TRANS(1,1,I)**2+TRANS(2,1,I)**2+TRANS(3,1,I)**2
               DUM2=TRANS(1,2,I)**2+TRANS(2,2,I)**2+TRANS(3,2,I)**2
               DUM3=TRANS(1,3,I)**2+TRANS(2,3,I)**2+TRANS(3,3,I)**2
               DUM12=TRANS(1,1,I)*TRANS(1,2,I)
     &              +TRANS(2,1,I)*TRANS(2,2,I)
     &              +TRANS(3,1,I)*TRANS(3,2,I)
               DUM23=TRANS(1,2,I)*TRANS(1,3,I)
     &              +TRANS(2,2,I)*TRANS(2,3,I)
     &              +TRANS(3,2,I)*TRANS(3,3,I)
               DUM31=TRANS(1,3,I)*TRANS(1,1,I)
     &              +TRANS(2,3,I)*TRANS(2,1,I)
     &              +TRANS(3,3,I)*TRANS(3,1,I)
               DUM1=ABS(ONE-DUM1)
               DUM2=ABS(ONE-DUM2)
               DUM3=ABS(ONE-DUM3)
               DUM12=ABS(DUM12)
               DUM23=ABS(DUM23)
               DUM31=ABS(DUM31)
               IF ((DUM1.GT.TH_ZERO).OR.(DUM2.GT.TH_ZERO).OR.
     &             (DUM3.GT.TH_ZERO).OR.(DUM12.GT.TH_ZERO).OR.
     &             (DUM23.GT.TH_ZERO).OR.(DUM31.GT.TH_ZERO) ) THEN
         IF(MASWRK) THEN
           WRITE(IW,*)'$LCLDC/VL MUST BE ORTHOGONAL UNIT VECTORS'
           WRITE(IW,*) 'ERROR IN ',I,' TH UNIT VECTOR'
           WRITE(IW,*) 'NORM', DUM1,DUM2,DUM3
           WRITE(IW,*) 'ORTHO', DUM12,DUM23,DUM31
         END IF
               CALL ABRT
               END IF
            END DO
C
C   transform MO coef based on the current standard orientation
C   from the specified orientation (p-type only!!)
C
            KCART(1)=1
            DO I=2,7
               KCART(I) = KCART(I-1) + I
            ENDDO
C
            INDAO=0
            DO ISH=1,NSHELL
               IATOM=KATOM(ISH)
               NUMGTO = KCART(KTYPE(ISH))
C                S shells are left alone (no rotation for round stuff)
C                we rotate only the P part of L shells
C                shells higher than P are just wiped out!
               IF(KTYPE(ISH).EQ.2) THEN
                  IF(KMIN(ISH).EQ.1) INDAO=INDAO+1  ! IF L SHELL
                  COEF_X=W(INDAO+1,IORB)
                  COEF_Y=W(INDAO+2,IORB)
                  COEF_Z=W(INDAO+3,IORB)
                  W(INDAO+1,IORB)=TRANS(1,1,IATOM)*COEF_X
     &                           +TRANS(1,2,IATOM)*COEF_Y
     &                           +TRANS(1,3,IATOM)*COEF_Z
                  W(INDAO+2,IORB)=TRANS(2,1,IATOM)*COEF_X
     &                           +TRANS(2,2,IATOM)*COEF_Y
     &                           +TRANS(2,3,IATOM)*COEF_Z
                  W(INDAO+3,IORB)=TRANS(3,1,IATOM)*COEF_X
     &                           +TRANS(3,2,IATOM)*COEF_Y
     &                           +TRANS(3,3,IATOM)*COEF_Z
               END IF
               IF(KTYPE(ISH).GT.2) THEN
                  DO IGTO=1,NUMGTO
                     W(INDAO+IGTO,IORB)=ZERO
                  ENDDO
               END IF
               INDAO = INDAO + NUMGTO
            END DO
         END DO  ! LOOP END OF REF (PSEUDO REF) MOS
      END IF  ! END IF OF ORIENTATION USE
C
C       -- Assign symmetry (irreps) for MOs
C
      CALL DAREAD(IDAF,IODA,Q,NUM*NUM,45,0)
      CALL SYMMOS(MOSLAB_REF,Q,S,W,TEMP,NQMT,NUM,N_RES,NUM)
      RETURN
C
 9000 FORMAT(/1X,'READING',A8,' RESOLUTION ORBITAL INPUT GROUP')
 9001 FORMAT(1X,'ADJUSTING',A8,' TO STANDARD PHASE:',I4,' ORBS.')
 9810 FORMAT(5X,5E15.8)
 9020 FORMAT(1X,'*** ERROR ***'/
     *       1X,'UNABLE TO FIND REQUIRED INPUT ORBITALS IN',A8,
     *          ' GROUP.')
 9030 FORMAT(1X,'*** ERROR ***'/
     *       1X,'UNABLE TO FIND REQUIRED ORIENTATION INFO IN',
     *          A8,' GROUP.')
 9035 FORMAT(1X,'ORIENTATION INPUT FOR',A,
     *          ' IS TAKEN FROM THE',A,' GROUP.')
 9040 FORMAT(1X,'*** ERROR ***'/
     *       1X,'ATOMIC ORDER IS DIFFERENT BETWEEN $DATA AND',A8/
     *       1X,'ATOM',I5,' IN DATA=',A8/
     *       1X,'ATOM',I5,' IN',A8,'=',A8)
      END
C
C*MODULE DIAB    *DECK THREEFOLD
      SUBROUTINE THREEFOLD(ALPHA_N,ALPHA_R,ALPHA_T,CONV_TH,MAX_ITER,
     &                     NSTATE,NUM,N_ACTIVE,MOSLAB_ACTIVE,
     &                     AVOCC_ACT,DM1,V,TEMP,U,NDMAT,STDPHASE)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL STDPHASE
C
      DIMENSION MOSLAB_ACTIVE(N_ACTIVE)
      DIMENSION DM1(N_ACTIVE,N_ACTIVE,NDMAT)
      DIMENSION V(NUM,N_ACTIVE)
      DIMENSION AVOCC_ACT(N_ACTIVE)
      DIMENSION TEMP(NUM,N_ACTIVE)
      DIMENSION U(N_ACTIVE,N_ACTIVE)   ! WORKING STORAGE HERE.
C
      PARAMETER (MXDIABACT=30)
      DIMENSION INDMO_MIX(MXDIABACT)
      DIMENSION MSEGMENT(MXDIABACT)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,DEBUG
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA ZERO,ONE/0.0D+00,1.0D+00/
C
C This routine carry out the threefold density criterion
C and determine the MO/base transformation matrix.
C
C The input MOs are transformed by the threefold density criterion
C and returned as output
C Also all DM are transformed then return.
C
C num  .... number of basis set (AO)
C n_active ... number of the active MOs
C
C v  ... MO vec (active) : return as updated (threefold density's) MO
C dm1 ... Density matrices (including transition DM and SA-DM)
C (DM are stored as (11),(12),...(1 nstate),(22),(23),.... )
C u  ... MO/base transformation matrix
C moslab_active .... irreps label of the active MOs
C
C msegment(i).... number (dimension) of the i-th block to be mixed
C indmo_mix ... indmo_mix(1:msegment(1))=MO index to be mixed for the
C                                        threefold density criterion
C indmo_mix(msegment(1)+1:msegment(1)+msegment(2))=MO index of the
C                                        next block
C               ....
C                       where n_block (<n_active) is total # of block
C                      (defined bellow)
C
C     Toggle last part of -debug- to see 3-fold way orbitals!
C
      DEBUG = MASWRK  .AND.  .FALSE.
C
C Define the block to mixing MOs for the threefold density criterion
C based on irreps (by using moslab_active)
C
      CALL MKMOIND1(N_ACTIVE,MOSLAB_ACTIVE,INDMO_MIX,MSEGMENT,N_BLOCK)
C
C Carry out the threefold density criterion to the all active space
C and determine MO/base transformation matrix U
C The MOs to be applied for the threefold density criterion
C and to be mixed with each others are already defined by indmo_mix
C and msegment.
C
C           Initialization of U (i.e. unit matrix)
C
      DO I=1,N_ACTIVE
        DO J=1,N_ACTIVE
          U(J,I)=ZERO
        END DO
      END DO
      DO I=1,N_ACTIVE
        U(I,I)=ONE
      END DO
C
C           threefold density criterion
C
      CALL MAX_D3(ALPHA_N,ALPHA_R,ALPHA_T,CONV_TH,MAX_ITER,NSTATE,
     &            N_ACTIVE,N_BLOCK,INDMO_MIX,MSEGMENT,DM1,NDMAT,
     &            U,AVOCC_ACT)
C
C Transform the MO coefficients of the new MO by using the matrix U
C
      IF(DEBUG) THEN
         IF(MASWRK) WRITE(IW,*) 'THE COMPLETED THREE-FOLD ROTATION IS'
         CALL PRSQ(U,N_ACTIVE,N_ACTIVE,N_ACTIVE)
      END IF
C
      CALL DGEMM('N','N',NUM,N_ACTIVE,N_ACTIVE,ONE,V,NUM,U,N_ACTIVE,
     &            ZERO,TEMP,NUM)
C
      DO I=1,N_ACTIVE
        DO J=1,NUM
          V(J,I)=TEMP(J,I)
        END DO
      END DO
C
      IF(STDPHASE) THEN
         IF(MASWRK) WRITE(IW,9001) N_ACTIVE
         CALL STFASE(V,NUM,NUM,N_ACTIVE)
      END IF
C
      IF(DEBUG) THEN
         IF(MASWRK) WRITE(IW,*) 'THE THREE-FOLD WAY PRODUCES THESE DMOS'
         CALL PRSQ(V,N_ACTIVE,NUM,NUM)
      END IF
C
      RETURN
 9001 FORMAT(1X,'ADJUSTING',I5,
     *          ' THREE-FOLD WAY ORBITALS TO STANDARD PHASE')
      END
C
C*MODULE DIAB    *DECK MKMOIND1
      SUBROUTINE MKMOIND1(N_ACTIVE,MOSLAB_ACTIVE,INDMO_MIX,MSEGMENT,
     &                    N_BLOCK)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION MOSLAB_ACTIVE(N_ACTIVE)
      DIMENSION INDMO_MIX(N_ACTIVE)
      DIMENSION MSEGMENT(N_ACTIVE)
C
      PARAMETER (MXDIABACT=30)
      DIMENSION ITEMP(MXDIABACT)
C
C This routine makes index arrays that define the "mixing block"
C of the active MOs to apply the simle threefold density criterion,
C i.e., the blocks are defined by only the irreps label.
C
C n_active ... number of the active MOs (input and output)
C n_block  ... number of the blocks (output)
C moslab_active ... irreps label
C
C msegment(i).... number (dimension) of the i-th block to be mixed
C
C indmo_mix ... indmo_mix(1:msegment(1))=MO index to be mixed for the
C                                        threefold density criterion
C indmo_mix(msegment(1)+1:msegment(1)+msegment(2))=MO index of the
C                                        next block
C               ....
C                       where n_block (<n_active) is total # of block
C                      (defined bellow)
C
       DO I=1,N_ACTIVE
         ITEMP(I)=MOSLAB_ACTIVE(I)
       END DO
C
       ICOUNT=0
       ISHIFT=0
       DO I=1,N_ACTIVE ! THIS LOOP IS CORRELATED TO PICKING UP ONE-BLOCK
         IF (ITEMP(I).EQ.0) GO TO 100  ! SKIP 0 IS DUMMY VALUE
         ICOUNT=ICOUNT+1
         IDUMLAB=ITEMP(I)
         JCOUNT=0
         DO J=1,N_ACTIVE ! THIS LOOP IS CORRELATED TO DETERMINATION OF
                         ! THE MEMBERS OF THE ABOVE ONE-BLOCK
           IF (ITEMP(J).EQ.IDUMLAB) THEN
             JCOUNT=JCOUNT+1
             INDMO_MIX(JCOUNT+ISHIFT)=J
             ITEMP(J)=0 ! REPLACE TO NULL VALUE FOR THE LOOP OF I
           END IF
         END DO
         MSEGMENT(ICOUNT)=JCOUNT
         ISHIFT=ISHIFT+MSEGMENT(ICOUNT)
100      CONTINUE
       END DO
C
       N_BLOCK=ICOUNT
C
       RETURN
       END
C
C*MODULE DIAB    *DECK MAX_D3
      SUBROUTINE MAX_D3(ALPHA_N,ALPHA_R,ALPHA_T,CONV_TH,MAX_ITER,
     &         NSTATE,N_ACTIVE,N_BLOCK,INDMO_MIX,MSEGMENT,DM1,NDMAT,
     &         U,AVOCC_ACT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION INDMO_MIX(N_ACTIVE)
      DIMENSION MSEGMENT(N_ACTIVE)
      DIMENSION U(N_ACTIVE,N_ACTIVE)
      DIMENSION DM1(N_ACTIVE,N_ACTIVE,NDMAT)
      DIMENSION AVOCC_ACT(N_ACTIVE)
C
      PARAMETER (MXDIABACT=30)
      DIMENSION TEMP1(MXDIABACT)
      DIMENSION TEMP2(MXDIABACT)
      DIMENSION TEMP3(MXDIABACT)
      DIMENSION TEMP4(MXDIABACT)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA ZERO/0.0D+00/
      DATA PT25/0.25D+00/
C
C This routine maximize the D3 function of the threefold density
C criterion and determine MO/base transformatiom matrix.
C Also density matrices are updated.
C The restriction of MOs to be mixed with are defined by "indmo_mix"
C (as input).
C
      IF(MASWRK) WRITE(IW,9000)
C
C
C Jacobi rotation for Maximization of the D3 function starts.
C The rotation is carried out for each block
C
C
      INDHEAD=1
      DO IBLOCK=1,N_BLOCK  ! LOOP FOR THE BLOCK
        DO ISTEP=1,MAX_ITER ! LOOP FOR THE ONE-CIRCLE OF THE ROTATION
          CALL CALSUM_MAXD3(NSTATE,N_ACTIVE,DM1,NDMAT,
     &                      ALPHA_N,ALPHA_R,ALPHA_T,D_PRE)
          INDTAIL=INDHEAD+MSEGMENT(IBLOCK)-1
C
          DO I=INDHEAD,INDTAIL-1 ! LOOP FOR APPLYING THE ROTATION MATRIX
C The rotation matrix mixes jac1 and jac2-th MOs as J(ij) step
            JAC1=INDMO_MIX(I)
            DO J=I+1,INDTAIL
              JAC2=INDMO_MIX(J)
              CALL CALDEL_MAXD3(NSTATE,N_ACTIVE,DM1,NDMAT,
     &                          ALPHA_N,ALPHA_R,ALPHA_T,
     &                          JAC1,JAC2,A_IJ,B_IJ)
              DEL_D=SQRT(A_IJ**2+B_IJ**2)+A_IJ
              GAMMA_IJ=PT25*ACOS(-A_IJ/SQRT(A_IJ**2+B_IJ**2))
              IF (B_IJ.LT.ZERO) GAMMA_IJ=-GAMMA_IJ
              IF (CONV_TH.LT.DEL_D) THEN
C transform density matrix element
                C=COS(GAMMA_IJ)
                S=SIN(GAMMA_IJ)
C
                DO IDM=1,NDMAT-1
                  TMP_II=DM1(JAC1,JAC1,IDM)*C**2
     &            -DM1(JAC1,JAC2,IDM)*C*S
     &            -DM1(JAC2,JAC1,IDM)*C*S
     &            +DM1(JAC2,JAC2,IDM)*S**2
C
                  TMP_JJ=DM1(JAC1,JAC1,IDM)*S**2
     &            +DM1(JAC1,JAC2,IDM)*C*S
     &            +DM1(JAC2,JAC1,IDM)*C*S
     &            +DM1(JAC2,JAC2,IDM)*C**2
C
                  TMP_IJ=DM1(JAC1,JAC1,IDM)*C*S
     &            -DM1(JAC2,JAC2,IDM)*C*S
     &            +DM1(JAC1,JAC2,IDM)*C**2
     &            -DM1(JAC2,JAC1,IDM)*S**2
C
                  TMP_JI=DM1(JAC1,JAC1,IDM)*C*S
     &            -DM1(JAC2,JAC2,IDM)*C*S
     &            -DM1(JAC1,JAC2,IDM)*S**2
     &            +DM1(JAC2,JAC1,IDM)*C**2
C
                  DO K=1,N_ACTIVE
                    TEMP1(K)=DM1(JAC1,K,IDM)*C
     &              -DM1(JAC2,K,IDM)*S
                    TEMP2(K)=DM1(K,JAC1,IDM)*C
     &              -DM1(K,JAC2,IDM)*S
                    TEMP3(K)=DM1(JAC1,K,IDM)*S
     &              +DM1(JAC2,K,IDM)*C
                    TEMP4(K)=DM1(K,JAC1,IDM)*S
     &              +DM1(K,JAC2,IDM)*C
                  END DO
C
                  DO K=1,N_ACTIVE
                    DM1(JAC1,K,IDM)=TEMP1(K)
                    DM1(K,JAC1,IDM)=TEMP2(K)
                    DM1(JAC2,K,IDM)=TEMP3(K)
                    DM1(K,JAC2,IDM)=TEMP4(K)
                  END DO
C
                  DM1(JAC1,JAC1,IDM)=TMP_II
                  DM1(JAC2,JAC2,IDM)=TMP_JJ
                  DM1(JAC1,JAC2,IDM)=TMP_IJ
                  DM1(JAC2,JAC1,IDM)=TMP_JI
C
                END DO ! END LOOP ON ALL DM/TDM
C
                CALL MKSTAVGDM1(DM1,NDMAT,N_ACTIVE,NSTATE)
C
C Update Unitary MO-trans matrix
C
                DO K=1,N_ACTIVE
                  TEMP2(K)=U(K,JAC1)*C-U(K,JAC2)*S
                  TEMP4(K)=U(K,JAC1)*S+U(K,JAC2)*C
                  U(K,JAC1)=TEMP2(K)
                  U(K,JAC2)=TEMP4(K)
                END DO
C
              END IF
C
            END DO ! END OF LOOP OF J
          END DO   ! END OF LOOP OF I (I.E END OF ONE CIRCLE )
C
          CALL CALSUM_MAXD3(NSTATE,N_ACTIVE,DM1,NDMAT,
     &                      ALPHA_N,ALPHA_R,ALPHA_T,D_AFT)
C
          IF(MASWRK) WRITE(IW,9010) ISTEP,D_AFT,D_AFT-D_PRE
C
          IF (ABS(D_AFT-D_PRE).LT.CONV_TH) THEN
            IF(MASWRK) WRITE(IW,9020) IBLOCK
            GO TO 100
          END IF
C
        END DO ! END OF LOOP OF ISTEP
C
        IF (ABS(D_AFT-D_PRE).GT.CONV_TH) THEN
          IF(MASWRK) WRITE(IW,*) 'JACOBI ROTATION WAS NOT CONVERGED.'
          CALL ABRT
        END IF
C
100   CONTINUE ! DONE OF OPTIMIZATION FOR ONE-BLOCK (IBLOCK LOOP)
C
Cc    to next block...
C
        INDHEAD=INDHEAD+MSEGMENT(IBLOCK)
C
      END DO ! END OF LOOP OF IBLOCK
C
C Store occupation # for state averaged density matrix
C (i.e diagonal elements of SA DM1) for sorting DMOs
C
      DO I=1,N_ACTIVE
        AVOCC_ACT(I)=DM1(I,I,NDMAT)
      END DO
C
 9000 FORMAT(/1X,37(1H-)/
     &       1X,'      MAXIMIZING D3 FUNCTION'/
     &       1X,37(1H-)/
     &       1X,'   ITER   VALUE        PROGRESS')
 9010 FORMAT(1X,I5,2X,F10.5,2X,F13.8)
 9020 FORMAT(1X,'THE ROTATION OF ',I3,'-TH SYMMETRY BLOCK IS DONE')
      RETURN
      END
C
C*MODULE DIAB    *DECK CALSUM_MAXD3
      SUBROUTINE CALSUM_MAXD3(NSTATE,N_ACTIVE,DM1,NDMAT,
     &                       ALPHA_N,ALPHA_R,ALPHA_T,SUM)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION DM1(N_ACTIVE,N_ACTIVE,NDMAT)
      DATA ZERO /0.0D+00/
C
C
C Ruedenberg term
C
C
      SUM_R=ZERO
      KK=1      ! KK IS INDEX OF DM1 BETWEEN KSTAT-KSTAT
      DO KSTAT=1,NSTATE
        DO I=1,N_ACTIVE
          SUM_R=SUM_R+DM1(I,I,KK)*DM1(I,I,KK)
        END DO
        KK=KK+NSTATE+1-KSTAT
      END DO
C
      SUM_R=ALPHA_R*SUM_R !SCALE BY PARAMETER
C
C
C Natural orbital term
C
C
      SUM_N=ZERO
      DO I=1,N_ACTIVE
        SUM_N=SUM_N+DM1(I,I,NDMAT)**2
      END DO
C
      SUM_N=ALPHA_N * NSTATE * SUM_N  !SCALE BY PARAMETER
                                      !AND # OF STATES
C
C
C Transition term (kstat < istat)
C
C
      IF (NSTATE.EQ.1) GO TO 100
C
      SUM_T=ZERO
      KK=1       ! KK IS INDEX OF DM1 BETWEEN KSTAT-KSTAT
      DO KSTAT=1,NSTATE
        DO ISTAT=KSTAT+1,NSTATE
          KISTAT=KK+ISTAT-KSTAT   ! KISTAT IS INDEX OF ONLY TD DM1
          DO I=1,N_ACTIVE
            SUM_T=SUM_T+DM1(I,I,KISTAT)*DM1(I,I,KISTAT)
          END DO
        END DO
        KK=KK+NSTATE+1-KSTAT
      END DO
C
      SUM_T=ALPHA_T * 2.0D+00/(NSTATE-1) * SUM_T  !SCALE BY PARAMETER
                                                  !AND # OF STATES
C
100   CONTINUE
C
C
C Get sum  of all terms. i.e. D=Ruedenberg+Natural+Transition
C
C
      SUM=SUM_R+SUM_N+SUM_T
C
      RETURN
      END
C
C*MODULE DIAB    *DECK CALDEL_MAXD3
      SUBROUTINE CALDEL_MAXD3(NSTATE,N_ACTIVE,DM1,NDMAT,
     &                        ALPHA_N,ALPHA_R,ALPHA_T,
     &                        JAC1,JAC2,A_IJ,B_IJ)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DATA ZERO /0.0D+00/
      DATA PT5,PT25 /0.5D+00,0.25D+00/
C
      DIMENSION DM1(N_ACTIVE,N_ACTIVE,NDMAT)
C
C
C Calculate Ruedenberg term
C
C
      AR_IJ=ZERO
      BR_IJ=ZERO
      KK=1      ! KK IS INDEX OF DM1 BETWEEN KSTAT-KSTAT
      DO KSTAT=1,NSTATE
        D_II=DM1(JAC1,JAC1,KK)
        D_JJ=DM1(JAC2,JAC2,KK)
        D_IJ=DM1(JAC1,JAC2,KK)
        D_JI=DM1(JAC2,JAC1,KK)
        AR_IJ=AR_IJ+PT25*D_IJ*D_IJ+PT25*D_JI*D_JI+PT5*D_IJ*D_JI
     &      +PT5*D_II*D_JJ-PT25*D_II*D_II-PT25*D_JJ*D_JJ
        BR_IJ=BR_IJ+PT5*D_IJ*D_JJ+PT5*D_JI*D_JJ-PT5*D_II*D_IJ
     &       -PT5*D_II*D_JI
        KK=KK+NSTATE+1-KSTAT
      END DO
C
      AR_IJ=ALPHA_R*AR_IJ !SCALE BY PARAMETER
      BR_IJ=ALPHA_R*BR_IJ
C
C
C Calculate Natural orbital term
C
C
      D_II=DM1(JAC1,JAC1,NDMAT)
      D_JJ=DM1(JAC2,JAC2,NDMAT)
      D_IJ=DM1(JAC1,JAC2,NDMAT)
      D_JI=DM1(JAC2,JAC1,NDMAT)
      AN_IJ=PT25*D_IJ*D_IJ+PT25*D_JI*D_JI+PT5*D_IJ*D_JI
     &      +PT5*D_II*D_JJ-PT25*D_II*D_II-PT25*D_JJ*D_JJ
      BN_IJ=PT5*D_IJ*D_JJ+PT5*D_JI*D_JJ-PT5*D_II*D_IJ
     &       -PT5*D_II*D_JI
C
      AN_IJ=ALPHA_N * NSTATE * AN_IJ  !SCALE BY PARAMETER
      BN_IJ=ALPHA_N * NSTATE * BN_IJ  !AND # OF STATES
C
C
C Calculate Transition term (kstat < istat)
C
C
      AT_IJ=ZERO
      BT_IJ=ZERO
C
      IF (NSTATE.EQ.1) GO TO 100
C
      KK=1
      DO KSTAT=1,NSTATE
        DO ISTAT=KSTAT+1,NSTATE
          KISTAT=KK+ISTAT-KSTAT
          D_II=DM1(JAC1,JAC1,KISTAT)
          D_JJ=DM1(JAC2,JAC2,KISTAT)
          D_IJ=DM1(JAC1,JAC2,KISTAT)
          D_JI=DM1(JAC2,JAC1,KISTAT)
          AT_IJ=AT_IJ+PT25*D_IJ*D_IJ+PT25*D_JI*D_JI+PT5*D_IJ*D_JI
     &      +PT5*D_II*D_JJ-PT25*D_II*D_II-PT25*D_JJ*D_JJ
          BT_IJ=BT_IJ+PT5*D_IJ*D_JJ+PT5*D_JI*D_JJ-PT5*D_II*D_IJ
     &       -PT5*D_II*D_JI
        END DO
        KK=KK+NSTATE+1-KSTAT
      END DO
C
      AT_IJ=ALPHA_T * 2.0D+00/(NSTATE-1) * AT_IJ  !SCALE BY PARAMETER
      BT_IJ=ALPHA_T * 2.0D+00/(NSTATE-1) * BT_IJ  !AND # OF STATES
C
100   CONTINUE
C
C Get a_ij and b_ij
C
      A_IJ=AR_IJ+AN_IJ+AT_IJ
      B_IJ=BR_IJ+BN_IJ+BT_IJ
C
      RETURN
      END
C
C*MODULE DIAB    *DECK PRESORT
      SUBROUTINE PRESORT(NSTATE,NUM,N_ACTIVE,NB_CAN,N_REFMO,INDX1,
     &                   V,W,S,SMO,TEMP,DM1,NDMAT,AVOCC,MOSLAB_ACTIVE)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION V(NUM,N_ACTIVE)
      DIMENSION W(NUM,N_REFMO)
      DIMENSION S((NUM*NUM+NUM)/2)
      DIMENSION SMO(N_ACTIVE,N_ACTIVE)
      DIMENSION TEMP(NUM,N_ACTIVE)
      DIMENSION INDX1(NB_CAN)
      DIMENSION DM1(N_ACTIVE,N_ACTIVE,NDMAT)
      DIMENSION AVOCC(N_ACTIVE)
      DIMENSION MOSLAB_ACTIVE(N_ACTIVE)
C
      PARAMETER (MXDIABACT=30)
      DIMENSION ISTACK(MXDIABACT)  ! USED AS NB_CAN AT MOST
      DIMENSION ITEMP(MXDIABACT)
C
C This routine sorts MOs within each (candidate) block,
C based on reference MOs ($DPSVEC or $DIAVEC)
C in order to accelate convergence of the MORMO step
C
C
C
C nb_can ... # of candidate MO of the block
C n_refmo ... # of reference MOs
C
C indx1(i) i-th MO of the specified block is indx1(i)-th
C          stored MO
C istack(i) i-th MO of the spcecified block is sorted
C          to istack(i)-th MO of the specifeid block
C
C temp(num,n_active)
C v(num,n_active) .... active MOs
C w(num,n_refmo)  .... reference MOs
C s(num*(num+1)/2)... AO overlap
C dm1(n_active,n_active,nstate*(nstate+1)/2+1
C avocc(n_active)
C
      CALL DFRMCHECK2(NUM,N_ACTIVE,N_REFMO,NB_CAN,
     &                INDX1,ISTACK,V,W,S,SMO)
C
C         MWS doesn't know how to interpret this output,
C         so it isn't printed any more.
C     if(maswrk) then
C        write(6,*) 'Debug in presort'
C        write(6,*) 'istack'
C        do i=1,nb_can
C          write(6,*) i,istack(i)
C        end do
C        write(6,*) 'actual position sort new <--- old'
C        do i=1,nb_can
C          write(6,*) indx1(istack(i)),indx1(i)
C        end do
C     end if
C
C Sort
C
C             --- MO ----
C
      DO I=1,N_ACTIVE
        DO J=1,NUM
          TEMP(J,I)=V(J,I)
        END DO
      END DO
C
      DO I=1,NB_CAN
        DO J=1,NUM
          V(J,INDX1(ISTACK(I)))=TEMP(J,INDX1(I))
        END DO
      END DO
C
C             --- irreps labela--
C
      DO I=1,N_ACTIVE
        ITEMP(I)=MOSLAB_ACTIVE(I)
      END DO
      DO I=1,NB_CAN
        MOSLAB_ACTIVE(INDX1(ISTACK(I)))=ITEMP(INDX1(I))
      END DO
C
C              --- DMs ---
C
      DO IDM=1,NDMAT-1
        DO I=1,N_ACTIVE
          DO J=1,N_ACTIVE
            TEMP(J,I)=DM1(J,I,IDM)
          END DO
        END DO
        DO I=1,NB_CAN
          IND_A=INDX1(I)
          IND_B=INDX1(ISTACK(I))
          DO J=1,NB_CAN
            JND_A=INDX1(J)
            JND_B=INDX1(ISTACK(J))
            DM1(IND_B,JND_B,IDM)=TEMP(IND_A,JND_A)
          END DO
        END DO
      END DO
C
      CALL MKSTAVGDM1(DM1,NDMAT,N_ACTIVE,NSTATE)
C
C             --- average occ # --
C
      DO I=1,N_ACTIVE
        AVOCC(I)=DM1(I,I,NDMAT)
      END DO
C
      RETURN
      END
C
C*MODULE DIAB    *DECK DFRMCHECK2
      SUBROUTINE DFRMCHECK2(NUM,N_ACTIVE,NB_DET,NB_TEMP,
     &                      INDB_CRRT,ISTACK,V,W,S,STORE_DOT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXAO=8192)
      COMMON /IJPAIR/ IA(MXAO)
C
      DIMENSION INDB_CRRT(NB_TEMP)
      DIMENSION ISTACK(NB_TEMP)
      DIMENSION V(NUM,N_ACTIVE)
      DIMENSION W(NUM,NB_DET)
      DIMENSION S((NUM*NUM+NUM)/2)
      DIMENSION STORE_DOT(NB_TEMP,NB_TEMP)
C
      DATA ZERO/0.0D+00/
C
C This routine make index array to represent one-to-one
C correspondence between some of V and W
C
C Note: DFRMCHECK2 is slightly different with DFRMCHECK
C       The first NB_DET orbital's order is defined by
C       reference MOs. The rest is arbitray, but
C       necessary to be defined !
C
C v  ... MO coefficient of active space at the current geometry
C        return without modification
C
C w  ... reference MOs i.e $DIAVEC or $DPSVEC not $DFMVEC
C
C s  ... AO overlap
C
C n_active   ... # of active orbitals
C
C nb_det     ... # of reference ($DIAVEC or $DPSVEC) MOs
C
C nb_temp    ... # of MOs per the doc or val block
C
C indb_crrt(i) ... i-th MO counted within the block is stored
C                   on indb_crrt(i)-th array
C
C store_dot(i,j): overlap-like quantity <u_i(ref)|u_j(current)>
C
C istack(1:nb_temp): i-th MO counted within the block is reordered
C                     to the istack(i)-th MO counted within the block
C
C This definitiion of ISTACK is different with DFRMCHECK
C
C   --- zero--
C
       DO J=1,NB_TEMP
         DO I=1,NB_DET
           STORE_DOT(I,J)=ZERO
         END DO
       END DO
C
C   --- dummy value to take consistency for the rest
C       of the nb_temp-nb_set MOs
C
       DO J=1,NB_TEMP
         DO I=NB_DET+1,NB_TEMP
           STORE_DOT(I,J)=0.001D+00
         END DO
       END DO
C
C ---- Check of deformation ------
C
C Step(1) Calculate overlap matrix between reference's DMO
C block and current MO block
C
      DO I=1,NB_DET
        DO J=1,NB_TEMP
          DUM=ZERO
          DO K=1,NUM
            DO L=1,NUM
              IF (L.LE.K) THEN
                IND_KL=IA(K)+L
              ELSE
                IND_KL=IA(L)+K
              END IF
              DUM=DUM+W(K,I)*V(L,INDB_CRRT(J))*S(IND_KL)
            END DO
          END DO
          STORE_DOT(I,J)=DUM
        END DO
      END DO
C
C
C Step(2) Search maximum overlaping and determine the one-to-one
C correspondence of nb_det MOs. The rest MO's postion
C is specified arbitratry.
C Thus, scan is performed nb_temp * nb_temp
C
C
      DO I=1,NB_TEMP
C
C Search max element of store_dot : max value = store_dot(i_ref,i_crrt)
C
        DUM_MAX=ZERO
        DO J=1,NB_TEMP
          DO K=1,NB_TEMP
            DUM=ABS(STORE_DOT(K,J))
            IF (DUM_MAX.LT.DUM) THEN
              DUM_MAX=DUM
              I_REF=K
              I_CRRT=J
            END IF
          END DO
        END DO
C
C Now correspondence between i-th reference MO
C indb_crrt(i_crrt)-th MO are defined
C
C Index array
C
C i_crrt th MO counted within block must move to i_ref th.
C the sign of indb_crrt, istack is FIXED.
C The sign is NOT affected by this procedure
C
        ISTACK(I_CRRT)=I_REF
C
C The all values of store_dot(*,i_crrt) and
C store_dot(i_ref,*) are replaced by
C dummy value zero because the above correspondence are determied
C
        DO J=1,NB_TEMP
          STORE_DOT(J,I_CRRT)=ZERO
        END DO
        DO J=1,NB_TEMP
          STORE_DOT(I_REF,J)=ZERO
        END DO
      END DO
C
      RETURN
      END
C
C*MODULE DIAB    *DECK FOURFOLD
      SUBROUTINE FOURFOLD(ALPHA_N,ALPHA_R,ALPHA_T,CONV_TH,MAX_ITER,
     &                    NSTATE,NUM,N_ACTIVE,NMLAP,
     &                    MOSLAB_ACTIVE,MOSLAB_REFDMO,MOSLAB_4FOLD,
     &                    DM1,NDMAT,V,W,S,AVOCC_ACT,TEMP,U,STDPHASE)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL STDPHASE
C
      DIMENSION MOSLAB_ACTIVE(N_ACTIVE)
      DIMENSION MOSLAB_REFDMO(N_ACTIVE)
      DIMENSION MOSLAB_4FOLD(N_ACTIVE)
      DIMENSION DM1(N_ACTIVE,N_ACTIVE,NDMAT)
      DIMENSION V(NUM,N_ACTIVE)
      DIMENSION W(NUM,NMLAP)
      DIMENSION S(NUM*(NUM+1)/2)
      DIMENSION AVOCC_ACT(N_ACTIVE)
      DIMENSION TEMP(NUM,N_ACTIVE)   ! TEMPORARY (MAX) REGION
      DIMENSION U(N_ACTIVE,N_ACTIVE)
C
      PARAMETER (MXDIABACT=30)
      DIMENSION MSEGMENT_REF(MXDIABACT) ! USED UP TO -NMLAP- ELEMENTS
      DIMENSION LABREF_BLOCK(MXDIABACT) ! USED UP TO -NMLAP- ELEMENTS
      DIMENSION LAB_BLOCK(MXDIABACT)
      DIMENSION INDMO_MIX(MXDIABACT)
      DIMENSION MSEGMENT(MXDIABACT)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,DEBUG
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA ZERO,ONE /0.0D+00,1.0D+00/
C
C     This routine carry out the fourfold way
C     and update MOs (categorized as "valence").
C     Also all DM are transformed to match.
C
C Notice: the fourfold way is applied for the MOs of only the
C         valence block. For other block's MOs are not changed from
C         preliminary threefold density criterion's
C
C nstate .... total # of states for diabatization
C num  .... number of basis set (AO)
C n_active ... number of the active MOs
C nmlap ... number of reference DMOs for the MORMO criterion
C v  ... MO vec (active) : return as updated (threefold density's) MO
C w  .... reference MOs for the MORMO criterion
C s  .... AO overlap
C dm1 ... Density matrices (including transition DM and SA-DM)
C (dm are stored as (11),(12),...(1 nstate),(22),(23),.... )
C moslab_active .... irreps label of the active MOs
C moslab_charact
C moslab_refdmo
C
C ---- Index arrays for current MOs ----
C
C lab_block(i) .... irreps label of MOs belong to i-th block
C                  (lab_block(i).NE.lab_block(j) when i.NE.j)
C
C msegment(i).... number (dimension) of the i-th block to be mixed
C
C indmo_mix ... indmo_mix(1:msegment(1))=MO index to be mixed for the
C                                        threefold density criterion
C indmo_mix(msegment(1)+1:msegment(1)+msegment(2))=MO index of the
C                                        next block
C               ....
C                       where n_block (<n_active) is total # of block
C                      (defined bellow)
C
C ---- Index arrays for reference DMOs ($DIAVEC)  ---
C
C labref_block(i)
C megment_ref(i)
C
C        Toggle last part of -debug- to see 4-fold way orbitals!
C
      DEBUG = MASWRK  .AND.  .FALSE.
C
C Define the block to mixing MOs for MORMO criterion
C based on information of irreps (by using moslab_active) and
C valence block (by using moslab_charact)
C
      CALL MKMOIND2(N_ACTIVE,MOSLAB_ACTIVE,MOSLAB_4FOLD,
     &              INDMO_MIX,MSEGMENT,LAB_BLOCK,N_BLOCK)
C
C Preliminary procedure for the MORMO criterion
C Sort data in w ($DIAVEC) to have mach symmetry of block
C to use the routine mormo
C
      CALL SORT_MORMO(NUM,NMLAP,NREF_BLOCK,MOSLAB_REFDMO,LABREF_BLOCK,
     &                MSEGMENT_REF,W,TEMP)
C
C Carry out the MORMO criterion to the valence block.
C The nmlap current MOs are determined at this stage.
C (In the routine mormo, MOs and DMs are updated.)
C
C Also n_block,lab_blcok,indmo_mix,and msegment are updated to be used
C in the next stage i.e. threefold density criterion for the REST MOs
C
      CALL MORMO(CONV_TH,MAX_ITER,NUM,N_ACTIVE,NMLAP,N_BLOCK,
     &           NREF_BLOCK,INDMO_MIX,MSEGMENT,LAB_BLOCK,MSEGMENT_REF,
     &           LABREF_BLOCK,DM1,NDMAT,NSTATE,V,W,S,TEMP)
C
      IF(DEBUG) THEN
         IF(MASWRK) WRITE(IW,*) 'THESE ORBITALS EMERGE FROM MORMO'
         CALL PRSQ(V,N_ACTIVE,NUM,NUM)
      END IF
C
C Carry out the threefold density criterion to the rest valence
C block MOs and determine MO/base transformation matrix U
C
C          Initialization of U (i.e. unit matrix)
C
      DO I=1,N_ACTIVE
        DO J=1,N_ACTIVE
          U(J,I)=ZERO
        END DO
      END DO
      DO I=1,N_ACTIVE
        U(I,I)=ONE
      END DO
C
C          threefold density criterion for the rest MOs
C
      CALL MAX_D3(ALPHA_N,ALPHA_R,ALPHA_T,CONV_TH,MAX_ITER,NSTATE,
     *            N_ACTIVE,N_BLOCK,INDMO_MIX,MSEGMENT,DM1,NDMAT,
     *            U,AVOCC_ACT)
C
C Transform the MO coefficients of the new MO by using the matrix U
C
      IF(DEBUG) THEN
         IF(MASWRK) WRITE(IW,*) 'THE COMPLETED FOUR-FOLD ROTATION IS'
         CALL PRSQ(U,N_ACTIVE,N_ACTIVE,N_ACTIVE)
      END IF
C
      CALL DGEMM('N','N',NUM,N_ACTIVE,N_ACTIVE,ONE,V,NUM,
     &           U,N_ACTIVE,ZERO,TEMP,NUM)
C
      DO I=1,N_ACTIVE
        DO J=1,NUM
          V(J,I)=TEMP(J,I)
        END DO
      END DO
C
      IF(STDPHASE) THEN
         IF(MASWRK) WRITE(IW,9001) N_ACTIVE
         CALL STFASE(V,NUM,NUM,N_ACTIVE)
      END IF
C
      IF(DEBUG) THEN
         IF(MASWRK) WRITE(IW,*) 'THE FOUR-FOLD WAY PRODUCES THESE DMOS'
         CALL PRSQ(V,N_ACTIVE,NUM,NUM)
      END IF
C
      RETURN
 9001 FORMAT(1X,'ADJUSTING',I5,
     *          ' FOUR-FOLD WAY ORBITALS TO STANDARD PHASE')
      END
C
C*MODULE DIAB    *DECK MKMOIND2
      SUBROUTINE MKMOIND2(N_ACTIVE,MOSLAB_ACTIVE,MOSLAB_4FOLD,
     &                    INDMO_MIX,MSEGMENT,LAB_BLOCK,N_BLOCK)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION MOSLAB_ACTIVE(N_ACTIVE)
      DIMENSION MOSLAB_4FOLD(N_ACTIVE)
      DIMENSION INDMO_MIX(N_ACTIVE)
      DIMENSION MSEGMENT(N_ACTIVE)   ! USED UP TO N_BLOCK
      DIMENSION LAB_BLOCK(N_ACTIVE)  ! USED UP TO N_BLOCK
C
      PARAMETER (MXDIABACT=30)
      DIMENSION ITEMP(MXDIABACT)
C
      COMMON /DIABAT/ ALPHA_N,ALPHA_R,ALPHA_T,
     *                TH_DOC,TH_VIR,SLCTTH,CONV_TH,WBLOCK(3),
     *                NDFRM,NDMOSYM,NRCSF,NMLAP,NDLAP,NORIENT,
     *                MOSLAB_CHARACT(MXDIABACT),
     *                MAX_ITER,NGRSTATE,NEXSTATE,NSTDIAB,
     *                NSYMBOL_DOC,NSYMBOL_VAL,NSYMBOL_VIR
C
C This routine makes index arrays that define the "mixing block"
C of the active MOs to apply the MORMO criterion in the fourfold
C way step.
C i.e., the blocks are defined by character (i.e.valence),
C       the irreps label of the current DMO and irreps label of the
C       reference DMO ($DIAVEC)
C
C n_active ... number of the active MOs (input and output)
C n_block  ... number of the blocks (output)
C
C msegment(i).... number (dimension) of the i-th block to be mixed
C
C indmo_mix ... indmo_mix(1:msegment(1))=MO index to be mixed for the
C                                        threefold density criterion
C indmo_mix(msegment(1)+1:msegment(1)+msegment(2))=MO index of the
C                                        next block
C               ....
C                       where n_block (< n_active) is total # of block
C                       (defined bellow)
C
C lab_blok(i) ... irreps label of i-th block
C                 Notice: lab_block(i).NE.lab_block(j) (i.NE.j)
C
      DO I=1,N_ACTIVE
         IF (MOSLAB_4FOLD(I).EQ.NSYMBOL_VAL) THEN
           ITEMP(I)=MOSLAB_ACTIVE(I)
         ELSE
           ITEMP(I)=0 ! NULL (ZERO) DUMMY VALUE
         END IF
      END DO
C
      ICOUNT=0
      ISHIFT=0
      DO I=1,N_ACTIVE ! THIS LOOP IS CORRELATED TO PICKING UP ONE-BLOCK
         IF (ITEMP(I).EQ.0) GO TO 100  ! SKIP. 0 IS DUMMY VALUE
         ICOUNT=ICOUNT+1
         IDUMLAB=ITEMP(I)
         LAB_BLOCK(ICOUNT)=IDUMLAB ! IRREPS OF ICOUNT-TH BLOCK
         JCOUNT=0
C            next loop is correlated to determination of
C            the members of the above one-block
         DO J=1,N_ACTIVE
           IF (ITEMP(J).EQ.IDUMLAB) THEN
             JCOUNT=JCOUNT+1
             INDMO_MIX(JCOUNT+ISHIFT)=J
             ITEMP(J)=0 ! REPLACE TO NULL VALUE FOR THE LOOP OF I
           END IF
         END DO
         MSEGMENT(ICOUNT)=JCOUNT
         ISHIFT=ISHIFT+MSEGMENT(ICOUNT)
100      CONTINUE
      END DO
      N_BLOCK=ICOUNT
      RETURN
      END
C
C*MODULE DIAB    *DECK SORT_MORMO
      SUBROUTINE SORT_MORMO(NUM,NMLAP,NREF_BLOCK,MOSLAB_REFDMO,
     &                      LABREF_BLOCK,MSEGMENT_REF,V,TEMP)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION MOSLAB_REFDMO(NMLAP)
      DIMENSION LABREF_BLOCK(NMLAP)
      DIMENSION MSEGMENT_REF(NMLAP)
      DIMENSION V(NUM,NMLAP)
      DIMENSION TEMP(NUM,NMLAP)
C
      PARAMETER (MXDIABACT=30)
      DIMENSION ITEMP(MXDIABACT)     ! USED UP TO SIZE -NMLAP-
      DIMENSION IND_TEMP(MXDIABACT)  ! USED UP TO SIZE -NMLAP-
C
C This routine sorts the data of reference MO for the MORMO
C criterion (i.e. $DIAVEC) to group block such as the same irreps ref
C DMOs belong to one block.
C
C n_block ... total # of block for mixing (input & output)
C nref_block ... total # of block of reference DMOs (grouped by irreps)
C                (output)
C
C v ... data of the reference MOs ($DIAVEC) (input. Output is updated)
C moslab_refdmo ... irreps label of the reference MOs
C                   (input. output is reordered with v in this routine.)
C labref_block  ... irreps label of each block  (output)
C msegment_ref  ... msegment_ref(i) is number of reference DMOs of
C                   i-th block
C
      DO I=1,NMLAP
        ITEMP(I)=MOSLAB_REFDMO(I)
      END DO
C
      ICOUNT=0
      ISHIFT=0
      DO I=1,NMLAP ! THIS LOOP IS CORRELATING WITH PICKING UP ONE-BLOCK
        IF (ITEMP(I).EQ.0) GO TO 100 ! SKIP IF 0 = DUMMY VALUE
        ICOUNT=ICOUNT+1
        IDUMLAB=ITEMP(I)
        LABREF_BLOCK(ICOUNT)=IDUMLAB  ! IRREPS LABEL OF THIS BLOCK
        JCOUNT=0
        DO J=1,NMLAP ! THIS LOOP IS CORRELATING TO DETERMINATION OF
                     ! THE MEMBERS OF THE ABOVE ONE-BLOCK
          IF (ITEMP(J).EQ.IDUMLAB) THEN
            JCOUNT=JCOUNT+1
            IND_TEMP(JCOUNT+ISHIFT)=J
            ITEMP(J)=0 ! REPLACE TO NULL DUMMY VALUE
          END IF
        END DO
        MSEGMENT_REF(ICOUNT)=JCOUNT
        ISHIFT=ISHIFT+MSEGMENT_REF(ICOUNT)
100     CONTINUE
      END DO
      NREF_BLOCK=ICOUNT
C
C Sort MOs
C
      DO I=1,NMLAP
        DO J=1,NUM
          TEMP(J,I)=V(J,I)
        END DO
      END DO
C
      DO I=1,NMLAP
        DO J=1,NUM
          V(J,I)=TEMP(J,IND_TEMP(I))
        END DO
      END DO
C
C Sort label
C
      DO I=1,NMLAP
        ITEMP(I)=MOSLAB_REFDMO(I)
      END DO
C
      DO I=1,NMLAP
        MOSLAB_REFDMO(I)=ITEMP(IND_TEMP(I))
      END DO
C
      RETURN
      END
C
C*MODULE DIAB    *DECK MORMO
      SUBROUTINE MORMO(CONV_TH,MAX_ITER,NUM,N_ACTIVE,NMLAP,
     &                 N_BLOCK,NREF_BLOCK,INDMO_MIX,MSEGMENT,
     &                 LAB_BLOCK,MSEGMENT_REF,LABREF_BLOCK,
     &                 DM1,NDMAT,NSTATE,V,V_REF,S,TEMP)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION INDMO_MIX(N_ACTIVE)
      DIMENSION MSEGMENT(N_BLOCK)
      DIMENSION LAB_BLOCK(N_BLOCK) ! LAB_BLOCK(N_ACTIVE)
      DIMENSION MSEGMENT_REF(NREF_BLOCK)
      DIMENSION LABREF_BLOCK(NREF_BLOCK)
      DIMENSION DM1(N_ACTIVE,N_ACTIVE,NDMAT)
      DIMENSION V(NUM,N_ACTIVE)
      DIMENSION V_REF(NUM,NMLAP)
      DIMENSION S(NUM*(NUM+1)/2)
      DIMENSION TEMP(NUM,2)
C
      PARAMETER (MXDIABACT=30)
      DIMENSION TEMP1(MXDIABACT)
      DIMENSION TEMP2(MXDIABACT)
      DIMENSION TEMP3(MXDIABACT)
      DIMENSION TEMP4(MXDIABACT)
      DIMENSION ITEMP(MXDIABACT)
      DIMENSION MSEGMENT_TMP(MXDIABACT) ! USED AS SIZE -N_BLOCK-
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA PT5 /0.5D+00/
C
C This routine carries out the MORMO criterion
C All MOs are updated by the criterion, and also
C density matrices are updated in this routine.
C The restriction of MOs to be mixed with are defined by "indmo_mix"
C etc.
C
C
C v ... MOs of current geometry (input). Output is updated in this
C       routine and returned
C
C v_ref ... reference DMO ($DIAVEC) (input & output)
C          (Note: this data is orderd by irreps as MOs of each block are
C                 labeled by unique irreps.)
C
C s ... AO overlap (input & output)
C
C dm1 ... density matrices (input) of the current MOs. Output is updated
C         in this routine and returned.
C
C n_block ... total # of block ( only within each block, Jacobi
C             rotation is done)
C
C msegment(i)... number (dim) of the i-th block to be mixed
C
C indmo_mix ... MO index to be mixed for the MORMO criterion
C
C nref_block ... total # of block to be referenced (blocked by irreps)
C
C msegment_ref(i) ... number (dim) of the i-th block of reference DMO
C
C lab_block
C
C labref_block
C
C                    Set parameters
C ntot_val : total number of "valence" MOs i.e. to be used for MORMO
C
      NTOT_VAL=0
      DO I=1,N_BLOCK
        NTOT_VAL=NTOT_VAL+MSEGMENT(I)
      END DO
C
C Copy
C
      DO I=1,N_BLOCK
        MSEGMENT_TMP(I)=MSEGMENT(I)
      END DO
C
      IF(MASWRK) WRITE(IW,9000)
C
C
C Jacobi rotation for Maximization of the reference overlap
C term (MORMO) starts.
C The rotation is carried out for each block.
C The block to be picked up first is reference DMO's ($DFMVEC) one
C and then suitable block of the current MOs is searched.
C The Jacobi rotation carried out within this current MOs's block
C
C         header index of the reference DMO of the iblock-th block
      IHEAD_REF=1
C
      DO IBLOCK=1,NREF_BLOCK  ! LOOP FOR THE BLOCK OF THE REFERENCE DMOS
        N_OVERLAP=MSEGMENT_REF(IBLOCK) !NUMBER OF REF DMOS IN THIS BLOCK
C
C Pick up corresponding block of current MOs (index=n_search)
C Set up parameters for current MOs block
C
        CALL SRCHMORMO(N_SEARCH,IHEAD,N_MIXMO,N_BLOCK,LAB_BLOCK,
     &                 MSEGMENT,LABREF_BLOCK(IBLOCK))
C
C n_search : index of current MO's block corresponding to the ref DMO
C            block
C n_mixmo  : number of MOs of the above block
C
C ihead    : header index of current MOs (physical address
C                                         indmo_mix(indhead)
C
C                 Jacobi rotation step
C
        DO ISTEP=1,MAX_ITER ! LOOP FOR THE ONE-CIRCLE OF THE ROTATION
C
          CALL CALSUM_MORMO(NUM,N_ACTIVE,N_OVERLAP,INDMO_MIX,
     &                      IHEAD,V_REF(1,IHEAD_REF),V,S,D_PRE)
C
          DO I=1,N_OVERLAP
            JAC1=INDMO_MIX(IHEAD+I-1) ! INDEX OF THE CURRENT MO FOR I
            JAC1_REF=IHEAD_REF+I-1   ! INDEX OF THE REFERENCE DMO FOR I
            DO J=I+1,N_MIXMO
              JAC2=INDMO_MIX(IHEAD+J-1) ! INDEX OF THE CURRENT MO FOR J
              IF (J.LE.N_OVERLAP) THEN
                JAC2_REF=IHEAD_REF+J-1 !INDEX OF THE REFERENCE DMO FOR J
                CALL CALDEL_MORMO1(NUM,V(1,JAC1),V(1,JAC2),
     &              V_REF(1,JAC1_REF),V_REF(1,JAC2_REF),S,A_IJ,B_IJ)
              ELSE
C                  in this case, reference DMO for j is not necessary
                CALL CALDEL_MORMO2(NUM,V(1,JAC1),V(1,JAC2),
     &              V_REF(1,JAC1_REF),S,A_IJ,B_IJ)
              END IF
C
              DEL_D=SQRT(A_IJ**2+B_IJ**2)+A_IJ
C
              GAMMA_IJ=PT5*ACOS(-A_IJ/SQRT(A_IJ**2+B_IJ**2))
C
              IF (CONV_TH.LT.DEL_D) THEN
C
C                     2x2 transform current MO coefficients
C
                CALL MOCOEFMIX(V(1,JAC1),V(1,JAC2),TEMP,NUM,GAMMA_IJ)
C
C                     corresponding update to the DMs
C
                CVAL=COS(GAMMA_IJ)
                SVAL=SIN(GAMMA_IJ)
C
                DO IDM=1,NDMAT-1
                  TMP_II=DM1(JAC1,JAC1,IDM)*CVAL*CVAL
     &                  -DM1(JAC1,JAC2,IDM)*CVAL*SVAL
     &                  -DM1(JAC2,JAC1,IDM)*CVAL*SVAL
     &                  +DM1(JAC2,JAC2,IDM)*SVAL*SVAL
                  TMP_JJ=DM1(JAC1,JAC1,IDM)*SVAL*SVAL
     &                  +DM1(JAC1,JAC2,IDM)*CVAL*SVAL
     &                  +DM1(JAC2,JAC1,IDM)*CVAL*SVAL
     &                  +DM1(JAC2,JAC2,IDM)*CVAL*CVAL
                  TMP_IJ=DM1(JAC1,JAC1,IDM)*CVAL*SVAL
     &                  -DM1(JAC2,JAC2,IDM)*CVAL*SVAL
     &                  +DM1(JAC1,JAC2,IDM)*CVAL*CVAL
     &                  -DM1(JAC2,JAC1,IDM)*SVAL*SVAL
                  TMP_JI=DM1(JAC1,JAC1,IDM)*CVAL*SVAL
     &                  -DM1(JAC2,JAC2,IDM)*CVAL*SVAL
     &                  -DM1(JAC1,JAC2,IDM)*SVAL*SVAL
     &                  +DM1(JAC2,JAC1,IDM)*CVAL*CVAL
C
                  DO K=1,N_ACTIVE ! NOTICE K SHOULD BE RUN ALL ACTIVE
                    TEMP1(K)=DM1(JAC1,K,IDM)*CVAL
     &                      -DM1(JAC2,K,IDM)*SVAL
                    TEMP2(K)=DM1(K,JAC1,IDM)*CVAL
     &                      -DM1(K,JAC2,IDM)*SVAL
                    TEMP3(K)=DM1(JAC1,K,IDM)*SVAL
     &                      +DM1(JAC2,K,IDM)*CVAL
                    TEMP4(K)=DM1(K,JAC1,IDM)*SVAL
     &                      +DM1(K,JAC2,IDM)*CVAL
                  END DO
C
                  DO K=1,N_ACTIVE
                    DM1(JAC1,K,IDM)=TEMP1(K)
                    DM1(K,JAC1,IDM)=TEMP2(K)
                    DM1(JAC2,K,IDM)=TEMP3(K)
                    DM1(K,JAC2,IDM)=TEMP4(K)
                  END DO
C
                  DM1(JAC1,JAC1,IDM)=TMP_II
                  DM1(JAC2,JAC2,IDM)=TMP_JJ
                  DM1(JAC1,JAC2,IDM)=TMP_IJ
                  DM1(JAC2,JAC1,IDM)=TMP_JI
                END DO
C
                CALL MKSTAVGDM1(DM1,NDMAT,N_ACTIVE,NSTATE)
              END IF
            END DO ! END OF LOOP OF J
          END DO   ! END OF LOOP OF I (I.E END OF ONE CIRCLE )
C
          CALL CALSUM_MORMO(NUM,N_ACTIVE,N_OVERLAP,INDMO_MIX,
     &                      IHEAD,V_REF(1,IHEAD_REF),V,S,D_AFT)
C
          IF(MASWRK) WRITE(IW,9010) ISTEP, D_AFT, D_AFT-D_PRE
C
          IF (ABS(D_AFT-D_PRE).LT.CONV_TH) THEN
            IF(MASWRK) WRITE(IW,9020) IBLOCK
            GO TO 100
          END IF
C
        END DO ! END OF LOOP OF ISTEP
C
        IF (ABS(D_AFT-D_PRE).GT.CONV_TH) THEN
          IF(MASWRK) WRITE(IW,*) 'JACOBI ROTATION WAS NOT CONVERGED.'
          CALL ABRT
        END IF
C
C             finished optimization (for IBLOCK loop)
C
  100   CONTINUE
C
C            Define (update) msegment_tmp array to use the final
C            threefold density criterion, i.e, remove MOs determined
C            by this MORMO step
C
        MSEGMENT_TMP(N_SEARCH)=N_MIXMO-N_OVERLAP
C               to next block...
        IHEAD_REF=IHEAD_REF+MSEGMENT_REF(IBLOCK)
      END DO ! END OF LOOP OF IBLOCK
C
C Update indmo_mix, msegment, and n_block by using msegment_tmp array
C
      DO I=1,NTOT_VAL
        ITEMP(I)=INDMO_MIX(I)
      END DO
C
      ISHIFT1=0
      ISHIFT2=0
      DO I=1,N_BLOCK
        IVAL=MSEGMENT(I)
        ID3FREE=MSEGMENT_TMP(I)
        IOVERLAP=IVAL-ID3FREE
        DO J=1,ID3FREE
          INDMO_MIX(J+ISHIFT1)=ITEMP(J+IOVERLAP+ISHIFT2)
        END DO
        ISHIFT1=ISHIFT1+ID3FREE
        ISHIFT2=ISHIFT2+IVAL
      END DO
C
      DO I=1,N_BLOCK
        ITEMP(I)=LAB_BLOCK(I)
      END DO
C
      ICOUNT=0
      DO I=1,N_BLOCK
        IF (MSEGMENT_TMP(I).NE.0) THEN
          ICOUNT=ICOUNT+1
          MSEGMENT(ICOUNT)=MSEGMENT_TMP(I)
          LAB_BLOCK(ICOUNT)=ITEMP(I)
        END IF
      END DO
C
      N_BLOCK=ICOUNT
      RETURN
 9000 FORMAT(/1X,'-------------------------------------------'/
     &       1X,'      MAXIMIZING MORMO OVERLAP TERM        '/
     &       1X,'-------------------------------------------'/
     &       1X,'   ITER    VALUE       PROGRESS')
 9010 FORMAT(1X,I5,2X,F10.5,2X,F13.8)
 9020 FORMAT(1X,'THE ROTATION OF ',I3,'-TH BLOCK IS DONE')
      END
C
C*MODULE DIAB    *DECK SRCHMORMO
      SUBROUTINE SRCHMORMO(N_SEARCH,IHEAD_MO,N_MIXMO,N_BLOCK,LAB_BLOCK,
     &                     MSEGMENT,LAB_REF)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION LAB_BLOCK(N_BLOCK)
      DIMENSION MSEGMENT(N_BLOCK)
C
C This routine search the block of current MOs corresponding
C to the block of the reference DMOs.
C The label of target (reference DMOs) block is identified
C as input "lab_ref"
C
C lab_block .... label array for the current MOs's block for MORMO
C n_block   .... total # of block for the current MOs for MORMO
C lab_ref   .... label of target reference DMOs's block
C n_search  .... n_search-th block of current DMOs's block is
C                corresponding to the target block
C n_mixmo   .... total # of current MOs  in n_search-th block
C ihead_mo  .... header index of MOs in n_search-th block
C                (physical address is identified indmo_mix(ihead_mo))
C
      DO I=1,N_BLOCK
        IF (LAB_REF.EQ.LAB_BLOCK(I)) THEN
          N_SEARCH=I
          GO TO 100
        END IF
      END DO
C
  100 CONTINUE
C
      IHEAD_MO=1
      DO I=1,N_SEARCH-1
        IHEAD_MO=IHEAD_MO+MSEGMENT(I)
      END DO
C
      N_MIXMO=MSEGMENT(N_SEARCH)
      RETURN
      END
C
C*MODULE DIAB    *DECK CALSUM_MORMO
      SUBROUTINE CALSUM_MORMO(NUM,N_ACTIVE,N_OVERLAP,INDMO_MIX,
     &                        IHEAD_MO,VEC_REF,VEC,W,SUM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION INDMO_MIX(N_ACTIVE)
      DIMENSION VEC_REF(NUM,N_OVERLAP)
      DIMENSION VEC(NUM,N_ACTIVE)
      DIMENSION W(NUM*(NUM+1)/2)
C
      PARAMETER (MXAO=8192)
      COMMON /IJPAIR/ IA(MXAO)
C
      DATA ZERO /0.0D+00/
C
C num    .... # of AO (basis set) (input & output)
C n_overlap...# of MOs to be overlaped (input & output)
C n_active
C vec_ref.... reference DMO/AO (input & output)
C vec    .... current MO/AO    (input & output)
C w      .... AO overlap       (input & output)
C indmo_mix
C ihead_mo
C
C Calculate MORMO term
C
      SUM=ZERO
      DO I=1,N_OVERLAP
        IND_V=INDMO_MIX(IHEAD_MO+I-1)
          DUM=ZERO
          DO J=1,NUM
            DO K=1,NUM
              IF (K.LE.J) THEN
                IND_JK=IA(J)+K
              ELSE
                IND_JK=+IA(K)+J
              END IF
              DUM=DUM+VEC_REF(J,I)*VEC(K,IND_V)*W(IND_JK)
          END DO
        END DO
        SUM=SUM+DUM**2
      END DO
C
      RETURN
      END
C
C*MODULE DIAB    *DECK CALDEL_MORMO
      SUBROUTINE CALDEL_MORMO1(NUM,V_I,V_J,VREF_I,VREF_J,W,A_IJ,B_IJ)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION V_I(NUM), V_J(NUM)
      DIMENSION VREF_I(NUM), VREF_J(NUM)
      DIMENSION W(NUM*(NUM+1)/2)
C
      PARAMETER (MXAO=8192)
      COMMON /IJPAIR/ IA(MXAO)
C
      DATA ZERO/0.0D+00/
      DATA  PT5/0.5D+00/
C
C num    .... # of AO (basis set)
C n_overlap...# of reference DMOs
C nmo_mix ... # of current MOs to be mixed with
C vref_i, vref_j.... reference DMO
C v_i, v_j    .... current MOs
C w      .... AO overlap
C
C Calculate a_ij and b_ij correlated with  MO Ovrelap term
C
C jac1 is <i> and jac2 is <j>:-->calculate s_i<i>,s_j<i>,s_i<j>,s_j<j>
C
C            --- s_i<i> and s_j<i> -----
C
Cc s_i<i>
C
      S_II=ZERO
      DO K=1,NUM
        DO L=1,NUM
          IF (L.LE.K) THEN
            IND_KL=IA(K)+L
          ELSE
            IND_KL=IA(L)+K
          END IF
          S_II=S_II+VREF_I(K)*V_I(L)*W(IND_KL)
        END DO
      END DO
C
Cc s_j<i>
C
      S_JI=ZERO
      DO K=1,NUM
        DO L=1,NUM
          IF (L.LE.K) THEN
            IND_KL=IA(K)+L
          ELSE
            IND_KL=IA(L)+K
          END IF
          S_JI=S_JI+VREF_I(K)*V_J(L)*W(IND_KL)
        END DO
      END DO
C
C               --- s_i<j> and s_j<j> -----
C
Cc s_i<j>
C
      S_IJ=ZERO
      DO K=1,NUM
        DO L=1,NUM
          IF (L.LE.K) THEN
            IND_KL=IA(K)+L
          ELSE
            IND_KL=IA(L)+K
          END IF
          S_IJ=S_IJ+VREF_J(K)*V_I(L)*W(IND_KL)
        END DO
      END DO
C
Cc s_j<j>
C
      S_JJ=ZERO
      DO K=1,NUM
        DO L=1,NUM
          IF (L.LE.K) THEN
            IND_KL=IA(K)+L
          ELSE
            IND_KL=IA(L)+K
          END IF
          S_JJ=S_JJ+VREF_J(K)*V_J(L)*W(IND_KL)
        END DO
      END DO
C
Cc Get a_ij and b_ij
C
      A_IJ=-PT5*S_II**2+PT5*S_JI**2+PT5*S_IJ**2-PT5*S_JJ**2
      B_IJ=-S_II*S_JI+S_IJ*S_JJ
      RETURN
      END
C
C*MODULE DIAB    *DECK CALDEL_MORMO2
      SUBROUTINE CALDEL_MORMO2(NUM,V_I,V_J,VREF_I,W,A_IJ,B_IJ)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION V_I(NUM),V_J(NUM)
      DIMENSION VREF_I(NUM)
      DIMENSION W(NUM*(NUM+1)/2)
C
      PARAMETER (MXAO=8192)
      COMMON /IJPAIR/ IA(MXAO)
C
      DATA ZERO/0.0D+00/
      DATA  PT5/0.5D+00/
C
C num    .... # of AO (basis set)
C n_overlap...# of reference DMOs
C nmo_mix ... # of current MOs to be mixed with
C vref_i ... reference DMO
C v_i, v_j   .... current MOs
C w      .... AO overlap
C
C Calculate a_ij and b_ij correlated with  MO Ovrelap term
C
C jac1 is <i>: <> is refernce DMO--> calculate only s_i<i>, s_j<i>
C
C           s_i<i>
C
      S_II=ZERO
      DO K=1,NUM
        DO L=1,NUM
          IF (L.LE.K) THEN
            IND_KL=IA(K)+L
          ELSE
            IND_KL=IA(L)+K
          END IF
          S_II=S_II+VREF_I(K)*V_I(L)*W(IND_KL)
        END DO
      END DO
C
C           s_j<i>
C
      S_JI=ZERO
      DO K=1,NUM
        DO L=1,NUM
          IF (L.LE.K) THEN
            IND_KL=IA(K)+L
          ELSE
            IND_KL=IA(L)+K
          END IF
          S_JI=S_JI+VREF_I(K)*V_J(L)*W(IND_KL)
        END DO
      END DO
C
C           Get  a_ij,b_ij
C
      A_IJ=-PT5*S_II**2+PT5*S_JI**2
      B_IJ=-S_II*S_JI
      RETURN
      END
C
C*MODULE DIAB    *DECK MOCOEFMIX
      SUBROUTINE MOCOEFMIX(V,W,WORK,NUM,GAMMA)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION V(NUM),W(NUM),WORK(NUM,2)
C
C   mix MO coefficients using 2x2 Jacobi matrix represented by GAMMA
C
      C=COS(GAMMA)
      S=SIN(GAMMA)
C
      DO I=1,NUM
        WORK(I,1)=C*V(I)-S*W(I)
        WORK(I,2)=S*V(I)+C*W(I)
      END DO
C
      DO I=1,NUM
        V(I)=WORK(I,1)
        W(I)=WORK(I,2)
      END DO
C
      RETURN
      END
C
C*MODULE DIAB    *DECK DETBLOCK
      SUBROUTINE DETBLOCK(NUM,N_ACTIVE,NSTATE,NDOC_CAND,
     &                    MOSLAB_ACTIVE,MOSLAB_PSEUDO,AVOCC_ACT,
     &                    SDOT,V,W,S,DM1,NDMAT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,MASWRK,DSKWRK
C
      DIMENSION MOSLAB_ACTIVE(N_ACTIVE)
      DIMENSION MOSLAB_PSEUDO(N_ACTIVE)
      DIMENSION AVOCC_ACT(N_ACTIVE)
      DIMENSION V(NUM,N_ACTIVE)
      DIMENSION W(NUM,N_ACTIVE)
      DIMENSION S(NUM*(NUM+1)/2)
      DIMENSION DM1(N_ACTIVE,N_ACTIVE,NDMAT)
C
      PARAMETER (MXDIABACT=30)
      DIMENSION IND_MO(MXDIABACT)
      DIMENSION INDTEMP0(MXDIABACT)
      DIMENSION INDTEMP1(MXDIABACT)
      DIMENSION INDTEMP2(MXDIABACT)
C
      COMMON /DIABAT/ ALPHA_N,ALPHA_R,ALPHA_T,
     *                TH_DOC,TH_VIR,SLCTTH,CONV_TH,WBLOCK(3),
     *                NDFRM,NDMOSYM,NRCSF,NMLAP,NDLAP,NORIENT,
     *                MOSLAB_CHARACT(MXDIABACT),
     *                MAX_ITER,NGRSTATE,NEXSTATE,NSTDIAB,
     *                NSYMBOL_DOC,NSYMBOL_VAL,NSYMBOL_VIR
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C This program classifies the (candidate) active DMOs to the three type,
C doc, valence, and virtual type with referring averaged occupation
C numbers ( and $DFMVEC, if available, i.e. ndfrm.ne.0)
C
C moslab_charact(i).... label to identify the i-th active MO
C                       (detemined by the threefold density criterion)
C                       belongs to
C                       =2  doubly occupied (doc)
C                       =1  valence
C                       =0  virtual
C                       (input & output)
C
C moslab_pseudo(i).... label to identify the i-th active MO belongs to
C                   =1 (not 2!)  target of catch and release as
C                      doc (not Vl!) block
C                   =0 not target (i.e. apparently vl and vir
C                                      or not apply C-R algorithm )
C                      (input & output)
C
C ndoc_cand      ..... # of candidate MO of doc block based on C-R
C                      algorithm. If C-R algorithm is Not applied,
C                      ndoc_cand=0 (input & output)
C
C v     .... MOs of the threefold density criterion (input)
C            output is reordered by taking overlap between $DFMVEC
C            for each block (doc/via/vir)
C
C avocc .... averaged occupation number of MOs of the threefold
C            density criterion (input). Output is reorderd.
C
C dm1   .... density matrices of MOs of the threefold density criterion
C            (input) Output is updated based on the new ordering
C            of the MOs
C
C w     .... temporary region e.g. to store (1) sym. orthogonalized
C            $DFMVEC etc
C
C s     .... AO overlap
C
C ind_mo ... index label to identify one-to-one correspondence
C            between v and w
C            Notice !!  ind_mo > 0----> the same sign
C                              < 0----> different sign
C            i-th current MO is odered to ind_mo(i)-th position
C            (indtemp0 is supported array for ind_mo)
C
      IF (NDFRM.EQ.0) THEN
        IF(MASWRK) WRITE(IW,9000)
        DO I=1,N_ACTIVE
          MOSLAB_CHARACT(I)=NSYMBOL_VAL
        END DO
        RETURN
      END IF
C
C Read (sym. orthogonalized) $DFMVEC from the scrach file
C
      CALL DAREAD(IDAF,IODA,W,NUM*N_ACTIVE,327,0)
C
C Check input of moslab_charact
C
      DO I=1,N_ACTIVE
        IF ((MOSLAB_CHARACT(I).NE.NSYMBOL_DOC).AND.
     &      (MOSLAB_CHARACT(I).NE.NSYMBOL_VAL).AND.
     &      (MOSLAB_CHARACT(I).NE.NSYMBOL_VIR)) THEN
          IF(MASWRK) WRITE(IW,*) '$DIABAT: MOSLAB HAS ILLEGAL VALUES.'
          CALL ABRT
        END IF
      END DO
C
C Initialization of ind_mo array as ) (dummy)
C
      DO I=1,N_ACTIVE
        IND_MO(I)=0
      END DO
C
C ------  Doc block ------
C
C           Pick up doc MO of $DFMVEC
C
      N_DOC=0
      DO I=1,N_ACTIVE
        IF (MOSLAB_CHARACT(I).EQ.NSYMBOL_DOC) THEN
          N_DOC=N_DOC+1
          INDTEMP1(N_DOC)=I
        END IF
      END DO
C
C         -- Select the candidate of doc MOs --
C
C         -- case A -- Catch and Release algorithm was applied
C
      IF (NDOC_CAND.NE.0) THEN
        ICOUNT=0
        DO I=1,N_ACTIVE
          IF (MOSLAB_PSEUDO(I).EQ.NSYMBOL_VAL) THEN
            ICOUNT=ICOUNT+1
            INDTEMP2(ICOUNT)=I
          END IF
        END DO
        NTEMP_DOC=NDOC_CAND
C         -- case B -- Catch and Release algorithm was Not applied
      ELSE IF (N_DOC.NE.0) THEN
        NTEMP_DOC=0
        DO I=1,N_ACTIVE
          IF (TH_DOC.LT.AVOCC_ACT(I)) THEN
            NTEMP_DOC=NTEMP_DOC+1
            INDTEMP2(NTEMP_DOC)=I
          END IF
        END DO
      END IF
C
C    --- in both cases, ntemp_doc is # of candidates MO for Doc block
C
      IF (N_DOC.LE.NTEMP_DOC) THEN
C
C         Determine n_doc MOs as doc MOs from ntemp_doc candidates
C
        DO I=1,N_ACTIVE
          INDTEMP0(I)=0
        END DO
C
        CALL DFRMCHECK(NUM,N_ACTIVE,N_DOC,NTEMP_DOC,
     &                 INDTEMP1,INDTEMP2,INDTEMP0,V,W,S,SDOT)
C
C         Doc part of ind_mo array is determined
C
        DO I=1,N_ACTIVE
          IF (INDTEMP0(I).NE.0) IND_MO(I)=INDTEMP0(I)
        END DO
      ELSE
        IF(MASWRK) THEN
          WRITE(IW,*) '# OF CANDIDATES MO FOR DOC BLOCK IS TOO SMALL,'
          WRITE(IW,*) 'DOC BLOCK IS IGNORED, AND TREATED AS VAL BLOCK'
        END IF
        DO I=1,N_ACTIVE
          IF (MOSLAB_CHARACT(I).EQ.NSYMBOL_DOC)
     &          MOSLAB_CHARACT(I)=NSYMBOL_VAL
        END DO
      END IF
C
C ------  Vir block ------
C
C            Pick up virtual  MO of $DFMVEC
C
      N_VIR=0
      DO I=1,N_ACTIVE
        IF (MOSLAB_CHARACT(I).EQ.NSYMBOL_VIR) THEN
          N_VIR=N_VIR+1
          INDTEMP1(N_VIR)=I
        END IF
      END DO
C
C          Select the candidate of vir MOs
C
      IF (N_VIR.NE.0) THEN
        NTEMP_VIR=0
        DO I=1,N_ACTIVE
          IF (AVOCC_ACT(I).LT.TH_VIR) THEN
            NTEMP_VIR=NTEMP_VIR+1
            INDTEMP2(NTEMP_VIR)=I
          END IF
        END DO
C
        IF (N_VIR.LE.NTEMP_VIR) THEN
C
C          Determine n_vir MOs as vir MOs from ntemp_vir candidates
C
          DO I=1,N_ACTIVE
            INDTEMP0(I)=0
          END DO
C
          CALL DFRMCHECK(NUM,N_ACTIVE,N_VIR,NTEMP_VIR,
     &                   INDTEMP1,INDTEMP2,INDTEMP0,V,W,S,SDOT)
C
C             Vir part of ind_mo is determined
C
          DO I=1,N_ACTIVE
            IF (INDTEMP0(I).NE.0) IND_MO(I)=INDTEMP0(I)
          END DO
        ELSE
          IF(MASWRK) THEN
            WRITE(IW,*) '# OF CANDIDATES MO FOR VIR BLOCK IS TOO SMALL,'
            WRITE(IW,*) 'VIR BLOCK IS IGNORED, AND TREATED AS VAL BLOCK'
          END IF
          DO I=1,N_ACTIVE
            IF (MOSLAB_CHARACT(I).EQ.NSYMBOL_VIR)
     &          MOSLAB_CHARACT(I)=NSYMBOL_VAL
          END DO
        END IF
      END IF
C
C             --- The rest is valence orb. ---
C
C                -- Pick up valence DMOs--
C
      N_VAL=0
      DO I=1,N_ACTIVE
        IF (MOSLAB_CHARACT(I).EQ.NSYMBOL_VAL) THEN
          N_VAL=N_VAL+1
          INDTEMP1(N_VAL)=I
        END IF
      END DO
C
      NTEMP_VAL=0
      DO I=1,N_ACTIVE
        IF (IND_MO(I).EQ.0) THEN
          NTEMP_VAL=NTEMP_VAL+1
          INDTEMP2(NTEMP_VAL)=I
        END IF
      END DO
C
      IF (NTEMP_VAL.NE.N_VAL) THEN
        IF(MASWRK) WRITE(IW,9040) NTEMP_VAL,N_VAL
        CALL ABRT
      END IF
C
      DO I=1,N_ACTIVE
        INDTEMP0(I)=0
      END DO
C
      CALL DFRMCHECK(NUM,N_ACTIVE,N_VAL,NTEMP_VAL,
     &               INDTEMP1,INDTEMP2,INDTEMP0,V,W,S,SDOT)
C
C         Val part of ind_mo is determined
C
      DO I=1,N_ACTIVE
        IF (INDTEMP0(I).NE.0) IND_MO(I)=INDTEMP0(I)
      END DO
C
C  Reorder the MOs
C
      DO  I=1,N_ACTIVE
        IF (IND_MO(I).LT.0) THEN
          DO J=1,NUM
            W(J,-IND_MO(I))=-V(J,I)
          END DO
        ELSE
          DO J=1,NUM
            W(J,IND_MO(I))=V(J,I)
          END DO
        END IF
      END DO
C
      DO I=1,N_ACTIVE
        DO J=1,NUM
          V(J,I)=W(J,I)
        END DO
      END DO
C
C Reorder elements of DMs (Notice: With sign change of MOs, each
C                                  DM elements change)
C
      DO IDM=1,NDMAT-1
C             --- change row and column
        DO I=1,N_ACTIVE
          IF (IND_MO(I).LT.0) THEN
            IND_I=-IND_MO(I)
          ELSE
            IND_I=IND_MO(I)
          END IF
          DO J=1,N_ACTIVE
            IF (IND_MO(J).LT.0) THEN
              IND_J=-IND_MO(J)
            ELSE
              IND_J=IND_MO(J)
            END IF
            W(IND_J,IND_I)=DM1(J,I,IDM)
          END DO
        END DO
C                --- change sign of elements
        DO I=1,N_ACTIVE
          IF (IND_MO(I).LT.0) THEN
            IND_I=-IND_MO(I)
            DO J=1,N_ACTIVE
              W(J,IND_I)=-W(J,IND_I)
            END DO
          END IF
        END DO
        DO I=1,N_ACTIVE
          IF (IND_MO(I).LT.0) THEN
            IND_I=-IND_MO(I)
            DO J=1,N_ACTIVE
              W(IND_I,J)=-W(IND_I,J)
            END DO
          END IF
        END DO
C
C           --- update dm ----
C
        DO I=1,N_ACTIVE
          DO J=1,N_ACTIVE
            DM1(J,I,IDM)=W(J,I)
          END DO
        END DO
      END DO
C
      CALL MKSTAVGDM1(DM1,NDMAT,N_ACTIVE,NSTATE)
C
C           Reorder irreps label
C
      DO I=1,N_ACTIVE
        INDTEMP1(I)=MOSLAB_ACTIVE(I)
      END DO
      DO I=1,N_ACTIVE
        IF (IND_MO(I).LT.0) THEN
          MOSLAB_ACTIVE(-IND_MO(I))=INDTEMP1(I)
        ELSE
          MOSLAB_ACTIVE(IND_MO(I))=INDTEMP1(I)
        END IF
      END DO
C
C            Reorder avocc
C
      DO I=1,N_ACTIVE
         AVOCC_ACT(I)=DM1(I,I,NDMAT)
      END DO
      RETURN
C
 9000 FORMAT(1X,'$DFMVEC IS NOT AVAILABLE.'/
     *       1X,'ALL ACTIVE MOS ARE TREATED AS VALENCE BLOCK,'/
     *       1X,'AND THE FOURFOLD WAY WILL CONTINUE.')
 9040 FORMAT(1X,'DETBLOCK: SOMETHING IS WRONG'/
     *       1X,'NTEMP_VAL=',I5,' DOES NOT MATCH N_VAL=',I5)
      END
C
C*MODULE DIAB    *DECK DFRMCHECK
      SUBROUTINE DFRMCHECK(NUM,N_ACTIVE,NB_DET,NB_TEMP,
     &                     INDB_REF,INDB_CRRT,ISTACK,V,W,S,STORE_DOT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION INDB_REF(NB_DET)
      DIMENSION INDB_CRRT(NB_TEMP)
      DIMENSION ISTACK(N_ACTIVE)
      DIMENSION V(NUM,N_ACTIVE)
      DIMENSION W(NUM,N_ACTIVE)
      DIMENSION S(NUM*(NUM+1)/2)
      DIMENSION STORE_DOT(NB_DET,NB_TEMP)
C
      PARAMETER (MXAO=8192)
      COMMON /IJPAIR/ IA(MXAO)
C
      DATA ZERO/0.0D+00/
C
C This routine make index array to represent one-to-one
C correspondence between some of -V- and -W-
C
C v  ... MO coefficient of active space at the current geometry
C        return without modification
C
C w  ... DMO coefficients at the reference geometry etc.
C
C s  ... AO overlap
C
C n_active   ... # of active orbitals
C
C nb_det     ... # of MOs to be assigned
C
C nb_temp    ... # of MOs of candidates to be assinged
C                i.e. nb_det MO are assigned (nb_det < or = nb_temp)
C
C indb_ref   ... index array to identify the referenced MO to be
C                used to assign nb_det MOs
C
C indb_crrt   ... index array to identify the current nb_det MOs to be
C                assigned
C
C store_dot(i,j): overlap-like quantity <u_i($DFMVEC)|u_j(current)>
C
C istack(1:n_active): i-th stored current DMO is ordered to the
C                     istack(i)-th position
C
C (Notice (1) Also this array shows the sign. if the overlap-like
C             quantity is smaller than 0, the value of istack(i) is <0
C         (2) As dummy value istack(i) is 0 when input.
C             In this routine the nb_det MO's positions are
C             determined; thus nb_det elements of istack array become
C             non 0 (i.e. non dummy) values.)
C
C Zero clear
C
       DO J=1,NB_TEMP
         DO I=1,NB_DET
           STORE_DOT(I,J)=ZERO
         END DO
       END DO
C
C ---- Check of deformation ------
C
C Step(1) Calculate overlap matrix between reference's DMO
C block and current MO block
C
      DO I=1,NB_DET
        DO J=1,NB_TEMP
          DUM=ZERO
          DO K=1,NUM
            DO L=1,NUM
              IF (L.LE.K) THEN
                IND_KL=IA(K)+L
              ELSE
                IND_KL=IA(L)+K
              END IF
              DUM=DUM+W(K,INDB_REF(I))*V(L,INDB_CRRT(J))*S(IND_KL)
            END DO
          END DO
          STORE_DOT(I,J)=DUM
        END DO
      END DO
C
C Step(2) Search maximum overlaping and determine the one-to-one
C correspondence of nb_det MOs
C
      DO I=1,NB_DET
C
C Search max element of store_dot  : maxvalue = store_dot(i_ref,i_crrt)
C
        DUM_MAX=ZERO
        DO J=1,NB_TEMP
          DO K=1,NB_DET
            DUM=ABS(STORE_DOT(K,J))
            IF (DUM_MAX.LT.DUM) THEN
              DUM_MAX=DUM
              I_REF=K
              I_CRRT=J
            END IF
          END DO
        END DO
C
C Now correspondence between indb_ref(i_ref)-th $DFMVEC (i-th MO of the
C block defined by indb_ref) and indb_crrt(i_crrt)-th MO
C are determined
C
C
C Index array
C
        IF (STORE_DOT(I_REF,I_CRRT).LT.ZERO) THEN
          ISTACK(INDB_CRRT(I_CRRT))=-INDB_REF(I_REF)
        ELSE
          ISTACK(INDB_CRRT(I_CRRT))=INDB_REF(I_REF)
        END IF
C
C The all values of store_dot(*,i_crrt) and
C store_dot(i_ref,*) are replaced by
C dummy value zero because the above correspondence are determied
C
        DO J=1,NB_DET
          STORE_DOT(J,I_CRRT)=ZERO
        END DO
        DO J=1,NB_TEMP
          STORE_DOT(I_REF,J)=ZERO
        END DO
      END DO
      RETURN
      END
C
C*MODULE DIAB    *DECK ORDDMO
      SUBROUTINE ORDDMO(NUM,N_ACTIVE,NSTATE,
     &                  MOSLAB_ACTIVE,DM1,NDMAT,AVOCC,V,W,S,SDOT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION MOSLAB_ACTIVE(N_ACTIVE)
      DIMENSION DM1(N_ACTIVE,N_ACTIVE,NDMAT)
      DIMENSION AVOCC(N_ACTIVE)
      DIMENSION V(NUM,N_ACTIVE)
      DIMENSION S(NUM*(NUM+1)/2)
      DIMENSION W(NUM,N_ACTIVE)
      DIMENSION SDOT(N_ACTIVE,N_ACTIVE)
C
      PARAMETER (MXDIABACT=30)
      DIMENSION IND_MO(MXDIABACT)
      DIMENSION INDTEMP0(MXDIABACT)
      DIMENSION INDTEMP1(MXDIABACT)
C
      COMMON /DIABAT/ ALPHA_N,ALPHA_R,ALPHA_T,
     *                TH_DOC,TH_VIR,SLCTTH,CONV_TH,WBLOCK(3),
     *                NDFRM,NDMOSYM,NRCSF,NMLAP,NDLAP,NORIENT,
     *                MOSLAB_CHARACT(MXDIABACT),
     *                MAX_ITER,NGRSTATE,NEXSTATE,NSTDIAB,
     *                NSYMBOL_DOC,NSYMBOL_VAL,NSYMBOL_VIR
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
C
C This routine determine final ordering ( after threefold or
C fourfold way) of DMOs by using $DFMVEC
C The target DMOs for ordering belong to "valence" block.
C The positions of other DMOs (doc, and vir block) are already
C determined before this stage, i.e. in the routine DETBLOCK.
C
C v .... DMOs at current geometry
C w .... $DFMVEC (sym. orthogonalized) to be used for deformation check.
C
C Initializaton of index array ind_mo
C
C Note: The order of Doc and Vir block MOs is already fixed, but
C       to use ind_mo(1:n_active), this initialization is required.
C
      DO I=1,N_ACTIVE
        IND_MO(I)=I
      END DO
C
C             Read sym. orthogonalized $DFMVEC (ndfrm=1) or
C             standard Fock canonical orbitals (ndfrm=0).
C
      CALL DAREAD(IDAF,IODA,W,NUM*N_ACTIVE,327,0)
C
C             Pick up Val block MOs
C
      N_VAL=0
      DO I=1,N_ACTIVE
        IF (MOSLAB_CHARACT(I).EQ.NSYMBOL_VAL) THEN
          N_VAL=N_VAL+1
          INDTEMP1(N_VAL)=I
        END IF
      END DO
C
C             deformation check and sort
C
      DO I=1,N_ACTIVE
        INDTEMP0(I)=0
      END DO
C
      CALL DFRMCHECK(NUM,N_ACTIVE,N_VAL,N_VAL,INDTEMP1,INDTEMP1,
     &               INDTEMP0,V,W,S,SDOT)
C
C             Val part of ind_mo array is determined
C
      DO I=1,N_ACTIVE
        IF (INDTEMP0(I).NE.0) IND_MO(I)=INDTEMP0(I)
      END DO
C
C Now, ind_mo(1:n_active) array is completely determined
C (i.e. All (doc+val+vir) block part DMOs are identified.)
C
C             Reorder the MOs
C
      DO  I=1,N_ACTIVE
        IF (IND_MO(I).LT.0) THEN
          DO J=1,NUM
            W(J,-IND_MO(I))=-V(J,I)
          END DO
        ELSE
          DO J=1,NUM
            W(J,IND_MO(I))=V(J,I)
          END DO
        END IF
      END DO
C
      DO I=1,N_ACTIVE
        DO J=1,NUM
          V(J,I)=W(J,I)
        END DO
      END DO
C
C Reorder elements of DMs (Notice: With sign change of MOs, each
C                                  DM elements change)
C
      DO IDM=1,NDMAT-1
C                     --- change row and column
        DO I=1,N_ACTIVE
          IF (IND_MO(I).LT.0) THEN
            IND_I=-IND_MO(I)
          ELSE
            IND_I=IND_MO(I)
          END IF
          DO J=1,N_ACTIVE
            IF (IND_MO(J).LT.0) THEN
              IND_J=-IND_MO(J)
            ELSE
              IND_J=IND_MO(J)
            END IF
            W(IND_J,IND_I)=DM1(J,I,IDM)
          END DO
        END DO
C                 --- change sign of elements
        DO I=1,N_ACTIVE
          IF (IND_MO(I).LT.0) THEN
            IND_I=-IND_MO(I)
            DO J=1,N_ACTIVE
              W(J,IND_I)=-W(J,IND_I)
            END DO
          END IF
        END DO
        DO I=1,N_ACTIVE
          IF (IND_MO(I).LT.0) THEN
            IND_I=-IND_MO(I)
            DO J=1,N_ACTIVE
              W(IND_I,J)=-W(IND_I,J)
            END DO
          END IF
        END DO
C                 --- update dm
        DO I=1,N_ACTIVE
          DO J=1,N_ACTIVE
            DM1(J,I,IDM)=W(J,I)
          END DO
        END DO
      END DO
C
      CALL MKSTAVGDM1(DM1,NDMAT,N_ACTIVE,NSTATE)
C
C Reorder irreps label
C
      DO I=1,N_ACTIVE
        INDTEMP1(I)=MOSLAB_ACTIVE(I)
      END DO
      DO I=1,N_ACTIVE
        IF (IND_MO(I).LT.0) THEN
          MOSLAB_ACTIVE(-IND_MO(I))=INDTEMP1(I)
        ELSE
          MOSLAB_ACTIVE(IND_MO(I))=INDTEMP1(I)
        END IF
      END DO
C
C Reorder avocc
C
      DO I=1,N_ACTIVE
        AVOCC(I)=DM1(I,I,NDMAT)
      END DO
C
C--- for debug ---
C      write(6,*) 'Debug in orddmo'
C      write(6,*) 'i, ind_mo(i)'
C      do i=1,n_active
C        write(6,*) i,ind_mo(i)
C      end do
C-----------------
      RETURN
      END
C
C*MODULE DIAB    *DECK PRLAPDMO
      SUBROUTINE PRLAPDMO(NUM,N_ACTIVE,V,W,S,SDOT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,MASWRK,DSKWRK
C
      DIMENSION S(NUM*(NUM+1)/2)
      DIMENSION V(NUM,N_ACTIVE)
      DIMENSION W(NUM,N_ACTIVE)
      DIMENSION SDOT(N_ACTIVE,N_ACTIVE)
C
      PARAMETER (MXAO=8192)
C
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA ZERO/0.0D+00/
C
C v ... the current DMO coefficients (input and output)
C w ... sym. orth. $DFMVEC
C s ... AO overlap (input and output)
C sdot(i,j) ... <$DIAVEC_i|DMO_j>
C
C             Read sym. orthogonalized $DFMVEC (ndfrm=1) or
C             standard Fock canonical orbitals (ndfrm=0).
C
      CALL DAREAD(IDAF,IODA,W,NUM*N_ACTIVE,327,0)
C
C Calculate overlap-like quantity
C
      CALL VCLR(SDOT,1,N_ACTIVE*N_ACTIVE)
C
      DO I=1,N_ACTIVE
        DO J=1,N_ACTIVE
          DUM=ZERO
          DO K=1,NUM
            DO L=1,NUM
              IF (L.LE.K) THEN
                IND_KL=IA(K)+L
              ELSE
                IND_KL=IA(L)+K
              END IF
              DUM=DUM+W(K,I)*V(L,J)*S(IND_KL)
            END DO
          END DO
          SDOT(I,J)=DUM
        END DO
      END DO
C
C Print out overlap-like matrix
C
      IF(MASWRK) WRITE(IW,9800)
      CALL PRSQ(SDOT,N_ACTIVE,N_ACTIVE,N_ACTIVE)
      RETURN
 9800 FORMAT(/23X,'OVERLAP MATRIX BETWEEN'/
     *        12X,'SYMMETRICALLY ORTHOGONALIZED REFERENCE ORBITALS'/
     *        20X,'AND DIABATIC MOLECULAR ORBITALS'/
     *        18X,'(ROWS= ORTH. $DFMVEC, COLS= DMO''S)')
      END
C
C*MODULE DIAB    *DECK RDCSFGRPS
      SUBROUTINE RDCSFGRPS(NSTDIAB,NLIST,COEF,LIST_CSF,LIST_GROUP,
     &                     MAXLIST,MAXRT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION COEF(MAXLIST,MAXRT)
      DIMENSION LIST_CSF(MAXLIST)
      DIMENSION LIST_GROUP(MAXLIST)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      CHARACTER*8 REFCSF
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA REFCSF /' $REFCSF'/
C
C Read data of dominant CSFs...input group $REFCSF:
C   LIST_CSF(i): dominant CSF index
C LIST_GROUP(i): Group index  where LIST_CSF(i)-th CSF belongs to
C     COEF(i,j): CI coefficents for diabatic states of LIST_CSF(i)-th
C                CSF for j-th diabatic states
C
      IF(MASWRK) WRITE(IW,9020) REFCSF
      CALL SEQREW(IR)
      CALL FNDGRP(IR,REFCSF,IEOF)
C
      IF(IEOF.GT.0) THEN
         IF(MASWRK) WRITE(IW,9030) REFCSF
         CALL ABRT
      END IF
C
C          -- read dominant CSF list and group --
C
      IF(MASWRK) READ(IR,*) NLIST
      IF(GOPARR) CALL DDI_BCAST(2151,'I',NLIST,1,MASTER)
C
      IF(NLIST.GT.MAXLIST) THEN
         IF(MASWRK) THEN
           WRITE(IW,*) 'STORAGE PROBLEM READING $REFCSF'
           WRITE(IW,*) 'YOUR INPUT IS NLIST=',NLIST
           WRITE(IW,*) 'MAXIMUM ALLOWED IS',MAXLIST
         END IF
         CALL ABRT
      END IF
C
      IF(MASWRK) THEN
         MAX=0
   25    CONTINUE
         MIN=MAX+1
         MAX=MAX+5
         IF (MAX.GT.NLIST) MAX=NLIST
         READ(IR,9910) (LIST_CSF(I),LIST_GROUP(I),I=MIN,MAX)
         IF (MAX.LT.NLIST) GO TO 25
C
C    -- read reference CI coefficients in $REFCSF for each set of DMOs
C
         DO J=1,NSTDIAB
           MAX=0
   30      CONTINUE
           MIN=MAX+1
           MAX=MAX+5
           IF (MAX.GT.NLIST) MAX=NLIST
           IF (NLIST.LE.99) READ(IR,9920) (COEF(I,J),I=MIN,MAX)
           IF (NLIST.GT.99) READ(IR,9920) (COEF(I,J),I=MIN,MAX)
           IF (MAX.LT.NLIST) GO TO 30
         END DO
      END IF
C
      IF(GOPARR) THEN
         CALL DDI_BCAST(2152,'I',LIST_CSF  ,NLIST        ,MASTER)
         CALL DDI_BCAST(2153,'I',LIST_GROUP,NLIST        ,MASTER)
         CALL DDI_BCAST(2154,'F',COEF      ,NLIST*NSTDIAB,MASTER)
      END IF
C
      RETURN
C
 9910 FORMAT(I8,'(',I2,')')
 9920 FORMAT(5X,5E15.8)
 9020 FORMAT(1X,'READING DOMINANT CSF INFORMATION FROM THE',A8,
     *          ' INPUT GROUP.')
 9030 FORMAT(1X,'*** ERROR ***'/
     *       1X,'UNABLE TO FIND REQUIRED DOMINANT CSF INFO IN THE',
     *          A8,' GROUP.')
      END
C
C*MODULE DIAB    *DECK REFDIA
      SUBROUTINE REFDIA(NFT21,LIST_CSF,LIST_GROUP,DCICOEF,
     &                  CIVEC,LEVIR,ICASE,IECONF,IECASE,IARC,
     &                  ECI_SAV,ISTACK,TAB_COEF,IOUTIV,
     &                  NLIST,MAXLIST,MAXRT,NSTDMO,
     &                  NWKS,NROWS,NROWS4,NBF)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK,SVDSKW
C
      DIMENSION LIST_CSF(MAXLIST)
      DIMENSION LIST_GROUP(MAXLIST)
      DIMENSION DCICOEF(MAXLIST,MAXRT)
      DIMENSION CIVEC(NWKS)
      DIMENSION LEVIR(NBF)
      DIMENSION ICASE(NBF)
      DIMENSION IECONF(NBF)
      DIMENSION IECASE(NBF)
      DIMENSION IARC(NROWS4)
      DIMENSION ECI_SAV(NSTDMO)
      DIMENSION ISTACK(NSTDMO)  ! STACK ARRAY FOR VARIOUS INDEX
      DIMENSION TAB_COEF(MAXLIST)
      DIMENSION IOUTIV(NBF)
C
      PARAMETER (MXRT=100)
      PARAMETER (MXDIABACT=30)
C
      COMMON /DIABAT/ ALPHA_N,ALPHA_R,ALPHA_T,
     *                TH_DOC,TH_VIR,SLCTTH,CONV_TH,WBLOCK(3),
     *                NDFRM,NDMOSYM,NRCSF,NMLAP,NDLAP,NORIENT,
     *                MOSLAB_CHARACT(MXDIABACT),
     *                MAX_ITER,NGRSTATE,NEXSTATE,NSTDIAB,
     *                NSYMBOL_DOC,NSYMBOL_VAL,NSYMBOL_VIR
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA NFT11  /11/
      DATA NFT12  /12/
      DATA CVGTOL /1.0D-05/
C
C
C LIST_CSF(i)  ... i-th dominant CSF inex
C LIST_GROUP(i)...Group index where i-th dominant CSF belongs to
C NLIST        ... total # of dominant CSFs.
C --->If LIST_CSF,LIST_GROUP, and NLIST are already defined by $REFCSF,
C     they are input and not changed. If not, this routine makes list
C     and return. In the latter case, users should understand that
C     the return is only for dominant CSFs based on DMO set.
C     i.e, not always enough dominant CSFs for global nuclear coordinate
C     region.
C DCICOEF(i,j)...CI coefficent of j-th adiabatic state of i-th
C                      dominant CSF
C NSTDMO... total # of target adiabatic states for diabatization,
C           plus those below ignored below the diabatization range.
C ECI_SAV ... the adiabatic CI energies for diabatization targets
C
C Read header of FT12 (CI vectors)
C
      SVDSKW = DSKWRK
      DSKWRK = .FALSE.
C
      CALL SEQREW(NFT12)
      IF(MASWRK) READ(NFT12) NSTATECI,NWKSCI
      IF(GOPARR) CALL DDI_BCAST(2161,'I',NSTATECI,1,MASTER)
      IF(GOPARR) CALL DDI_BCAST(2162,'I',NWKSCI  ,1,MASTER)
      IF(NWKSCI.NE.NWKS) THEN
         IF(MASWRK) WRITE(IW,*) 'REFDIA: CI VECTOR FILE CONFUSION'
         CALL ABRT
      END IF
C
C Search (suitable) target states if DMO's are determined by
C breaking symmetry
C
      IF (NDMOSYM.EQ.0) THEN
        WRITE(IW,*) '--- SEARCH SUITABLE CI (CAS) STATES ---'
C
        ICOUNT=0
        DO I=1,NSTDMO
          DO J=1,NSTATECI
            DUM=ABS(ESTATE(J)-ECI_SAV(I))
            IF (DUM.LT.CVGTOL) THEN
              ICOUNT=ICOUNT+1
              ISTACK(ICOUNT)=J
            END IF
          END DO
        END DO
        IF (ICOUNT.NE.NSTDMO) THEN
          WRITE(IW,'('' ERROR: CANNOT FIND SUITABLE STATES.''/
     &               '' YOU MAYBE NEED A LARGER VALUE OF NSTATE''/
     &               '' STOP.'')')
          CALL ABRT
        ELSE
          WRITE(IW,FMT='('' ROOT SEARCHING WAS SUCCESSFUL.'')')
        END IF
C
      ELSE
        DO I=1,NSTDMO
          ISTACK(I)=I
        END DO
      END IF
C
C
C If DMOs are obtained by symmetry breaking, write only target CI
C vectors to FT21 and use this file.
C If symmetry are conserved, the CI vectors in FT12 are used
C and FT21 is not created.
C (Reading FT21 or 12 is done in the routine PRMCDIA)
C
C  Pick up target CI vectors from FT12 and write to FT21, if necessary
C
      IF (NDMOSYM.NE.0) THEN
        NFT21_SAV=NFT21
        NFT21=NFT12 ! I.E NOT USE FT21 FILE
      ELSE
        CALL SEQREW(NFT21)
        ICOUNT=1
        DO I=1,NSTATECI ! NSTATE IS READ FROM FT12'S HEADER
          CALL SQREAD(NFT12,CIVEC,NWKS)
          IF (I.EQ.ISTACK(ICOUNT)) THEN
            CALL SQWRIT(NFT21,CIVEC,NWKS)
            ICOUNT=ICOUNT+1
          END IF
          IF (NSTDMO.LT.ICOUNT) GO TO 100
        END DO
        CALL SEQREW(NFT12)
        CALL SEQREW(NFT21)
      END IF
C
C Print -MC- Coefficient using DMOs and get list of domain CSFs
C for only suitable CI sates.
C
  100 CONTINUE
C
      CALL PRMCDIA(NRCSF,NFT11,NFT12,NFT21,NSTDMO,NWKS,ECI_SAV,
     &             CIVEC,SLCTTH,LEVIR,ICASE,IECONF,IECASE,IARC,
     &             LIST_CSF,LIST_GROUP,DCICOEF,TAB_COEF,IOUTIV,
     &             NLIST,NBF,NROWS4,NROWS,MAXLIST,MAXRT)
C
      IF(MASWRK) THEN
         WRITE(IW,9020)
         DO I=1,NSTDMO
           WRITE(IW,9030) I,ECI_SAV(I)
           DO J=1,NLIST
              WRITE(IW,9040) LIST_CSF(J),LIST_GROUP(J),DCICOEF(J,I)
           END DO
         END DO
      END IF
C
C         Back parameter nft21 to the original value, if necessary
C
      IF (NDMOSYM.NE.0) NFT21=NFT21_SAV
      DSKWRK = SVDSKW
      RETURN
 9020 FORMAT(/1X,46(1H-)/
     &       1X,'CI COEFFICIENTS OF DOMINANT CSFS FOR ALL GROUPS'/
     &       1X,46(1H-))
 9030 FORMAT(1X,'ADIABATIC STATE #',I5,' ENERGY =',F18.9/
     &       1X,'     CSF   GROUP #   COEFFICIENT')
 9040 FORMAT(1X,I8,5X,I3,3X,F12.6)
      END
C
C*MODULE DIAB    *DECK PRMCDIA
      SUBROUTINE PRMCDIA(NRCSF,NFT11,NFT12,NFT21,NST,NWKS,
     &                   EIGVAL,EIGVEC,SLCTTH,
     &                   LEVIR,ICASE,IECONF,IECASE,IARC,
     &                   LIST_CSF,LIST_GROUP,DCICOEF,
     &                   TAB_COEF,IOUTIV,
     &                   NLIST,NBF,NROWS4,NROWS,MAXLIST,MAXRT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION EIGVAL(NST)
      DIMENSION EIGVEC(NWKS)
      DIMENSION LEVIR(NBF),ICASE(NBF),IECONF(NBF),IECASE(NBF)
      DIMENSION IARC(NROWS4)
      DIMENSION LIST_CSF(MAXLIST)
      DIMENSION LIST_GROUP(MAXLIST)
      DIMENSION DCICOEF(MAXLIST,MAXRT)
      DIMENSION TAB_COEF(MAXLIST)
      DIMENSION IOUTIV(NBF)
C
      DIMENSION ISHIFT(4)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXAO=8192)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /ORBSET/ NORBMX,NORBS,NCORBS,NLEVS,NA,NB,NC,NSYM,MSYM,
     *                IDOC,IVAL,IMCC,ISYM(MXAO),ICODE(MXAO),
     *                NLCS(MXAO),LEVPT(MXAO),LEVNR(MXAO),
     *                IOUT(MXAO),NREFS,IEXCT,NFOCI,INTACT
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA ZERO /0.0D+00/
C
C
C Zero clear (input dummy value) for list array, if list_csf etc
C are not given as input (i.e. nrcsf = 0 )
C
C
      IF (NRCSF.EQ.0) THEN
        DO I=1,MAXLIST
          LIST_CSF(I)=0
          LIST_GROUP(I)=0
          TAB_COEF(I)=ZERO
        END DO
        CALL VCLR(DCICOEF,1,MAXLIST*MAXRT)
      END IF
C
C     ----- CREATE INVERSE MAPPING OF ORBITALS -----
C
      N=0
      DO I=1,NBF
         IF(IOUT(I).LT.0) N=N+1
      END DO
C
      DO I=1,NBF
         IF(IOUT(I).GT.0) THEN
            IOUTIV(IOUT(I))=I-N
         END IF
      END DO
C
C     ----- PRINT COEFFICIENTS OF CI VECTORS LARGER THAN SLCTTH -----
C           THE ELECTRON OCCUPANCY IS ALSO PRINTED
C
      DO  K = 1,4
        ISHIFT(K) = (K-1)*NROWS
      END DO
C
      CALL SEQREW(NFT11)
      IF(MASWRK) THEN
         DO I=1,13
           READ(NFT11) ! SKIP HEADER ETC
         END DO
         READ(NFT11) IARC
      END IF
      IF(GOPARR) CALL DDI_BCAST(2163,'I',IARC,NROWS4,MASTER)
      CALL SEQREW(NFT11)
C
      NCORB = 0
      DO I=1,NORBMX
        IF(IOUT(I).LT.0) NCORB = NCORB+1
      END DO
C
C
C Search Domain CSF and make some list for grouping by reading CI
C vectors
C
      CALL SEQREW(NFT21)
      IF (NFT21.EQ.NFT12) CALL SEQADV(NFT21) ! FT12 HAS HEADER
C
      IF(MASWRK) WRITE(IW,9010)
C
      ICOUNT=0
      DO KSTAT = 1,NST
        CALL SQREAD(NFT21,EIGVEC,NWKS)
        IF(MASWRK) WRITE(IW,9999) KSTAT,EIGVAL(KSTAT)
        IWKS = 0
        LEV = 1
        LEVM = 1
        IR0 = 1
  100   CONTINUE
        IF (LEV .EQ. NLEVS) GO TO 140
        LEVIR(LEV) = IR0
        LEVM = LEV
        LEV = LEVM+1
        LEVIR(LEV) = LEVNR(LEV)+1
  110   CONTINUE
        IR0 = LEVIR(LEV)
        NPTX = LEVPT(LEV)
        NPTM = LEVPT(LEVM)
        IRM = LEVIR(LEVM)
  120   CONTINUE
        IR0 = IR0-1
        IF (IR0 .EQ. 0) GO TO 300
        NPT = IR0+NPTX
        DO 130 K = 1,4
          IARPT = NPT+ISHIFT(K)
          JARC = IARC(IARPT)
          IF (JARC .EQ. 0) GO TO 130
          JARC = JARC-NPTM
          ICASE(LEVM) = K
          IF (IRM .EQ. JARC) GO TO 100
  130   CONTINUE
        GO TO 120
C
  140   CONTINUE
C
        DO 250 ILEV = 1,NORBS
          ICAS = ICASE(ILEV)
          GO TO (200,210,210,220), ICAS
  200     IOCC = 0
          GO TO 230
  210     IOCC = 1
          GO TO 230
  220     IOCC = 2
  230     CONTINUE
          IORB=-2**20
          DO 240 I = 1,NORBMX
            IF (IOUT(I) .EQ. ILEV) IORB = I
  240     CONTINUE
          IECONF(IORB) = IOCC
          IECASE(ILEV) = ICAS
  250   CONTINUE
C
        IWKS = IWKS+1
        DUM = EIGVEC(IWKS)
        IF(ABS(DUM).GE.SLCTTH) THEN
           IF(MASWRK) WRITE(IW,9998) IWKS,DUM,
     1                    (IECONF(NCORB+IORB),IORB=1,NORBS)
C
C         make list array if list_csf etc are not given as input
C
          IF (NRCSF.EQ.0) THEN
            IUPDATE=0
            DO ILIST=1,ICOUNT
              IF (LIST_CSF(ILIST).EQ.IWKS) THEN
                IUPDATE=ILIST ! CHECK DOUBLE COUNT ABOUT THE CSF
              END IF
            END DO
            IF (IUPDATE.EQ.0) THEN
              ICOUNT=ICOUNT+1
              LIST_CSF(ICOUNT)=IWKS
              TAB_COEF(ICOUNT)=ABS(DUM)
              LIST_GROUP(ICOUNT)=KSTAT
            ELSE IF (TAB_COEF(IUPDATE).LT.ABS(DUM)) THEN ! UPDATE LIST
              TAB_COEF(IUPDATE)=ABS(DUM)
              LIST_GROUP(IUPDATE)=KSTAT
            END IF
          END IF
C
        END IF
300     CONTINUE
        LEV=LEVM
        LEVM=LEV-1
        IF (LEVM.GT.0) GO TO 110
      END DO
      NLIST0=ICOUNT
C
      IF (NRCSF.EQ.0) NLIST=NLIST0
C
C Pick up CI coefficents of dominant CSFs for all target states
C and store them to DCICOEF array
C
      CALL SEQREW(NFT21)
      IF (NFT21.EQ.NFT12) CALL SEQADV(NFT21)  ! SKIP HEADER IF FT12
C
      DO I=1,NST
        CALL SQREAD(NFT21,EIGVEC,NWKS)
        DO ICSF=1,NLIST
          DCICOEF(ICSF,I)=EIGVEC(LIST_CSF(ICSF))
        END DO
      END DO
      CALL SEQREW(NFT21)
      RETURN
C
 9010 FORMAT(/1X,48(1H-)/
     &       1X,'CSF EXPANSION BASED ON DMO''S FOR THE ACTIVE SPACE'/
     &       1X,48(1H-))
 9999 FORMAT(/1X,'ADIABATIC STATE #',I5,'  ENERGY =',F18.9/
     2        6X,'CSF',4X,'COEFFICIENT',4X,'OCCUPANCY'/
     3        6X,'---',4X,'-----------',4X,'---------')
 9998 FORMAT(1X,I8,5X,F10.6,4X,60I1/(28X,60I1/))
      END
C
C*MODULE DIAB    *DECK GETHDIA
      SUBROUTINE GETHDIA(NRCSF,E_ADIA,NLIST,
     &                   LIST_GROUP,LIST_CSF,DCICOEF,DCICOEF_REF,
     &                   DCICOEF2,T,TP,S,EIGVAL,EIG_BUFF,
     &                   STRI,IWORK,WRKVEC,U,BUFF,WORK,
     &                   NSTDMO,NGRSTATE,NSTDIAB,MAXLIST,MAXRT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION LIST_GROUP(MAXLIST)
      DIMENSION LIST_CSF(MAXLIST)
      DIMENSION DCICOEF_REF(MAXLIST,MAXRT)
      DIMENSION DCICOEF(MAXLIST,MAXRT)
      DIMENSION DCICOEF2(MAXLIST,MAXRT)
      DIMENSION E_ADIA(MAXRT)
      DIMENSION T(NSTDIAB,NSTDIAB)
      DIMENSION TP(NSTDIAB,NSTDIAB)
      DIMENSION S(NSTDIAB,NSTDIAB)
      DIMENSION EIGVAL(NSTDIAB)
      DIMENSION EIG_BUFF(NSTDIAB)
      DIMENSION STRI(*)
      DIMENSION IWORK(NSTDIAB),WRKVEC(NSTDIAB)
      DIMENSION U(NSTDIAB,NSTDIAB)
      DIMENSION BUFF(NSTDIAB,NSTDIAB)
      DIMENSION WORK(MAXLIST,NSTDIAB)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA ZERO /0.0D+00/
      DATA ONE  /1.0D+00/
      DATA ERR_TH/1.0D-04/
C
C        note that -NSTDIAB- is effective number of states, the
C        number of states diabatized skipping past -NGRSTATE- roots.
C        The value -NSTDMO- is number of states being diabatized,
C        and equals NGRSTATE + NSTDMO.
C
      L1=NSTDMO
C
C
C Symmetrized Orthogonalization for truncated CI satets
C
C
Cc Make S (approximated overlap) matrix
C
      II = 1 + NGRSTATE
C
      DO ISTAT=II,L1
        DO JSTAT=II,L1
          S(ISTAT-NGRSTATE,JSTAT-NGRSTATE)=ZERO
          DO K=1,NLIST
            S(ISTAT-NGRSTATE,JSTAT-NGRSTATE)=
     &      S(ISTAT-NGRSTATE,JSTAT-NGRSTATE)
     &      + DCICOEF(K,ISTAT)*DCICOEF(K,JSTAT)
          END DO
        END DO
      END DO
C
C               Diagonalize S matrix
C         eigenvectors must be in -descending- order of eigenvalue!
C
      CALL CPYSQT(S,STRI,NSTDIAB,1)
      NTRI = (NSTDIAB*NSTDIAB+NSTDIAB)/2
      CALL DSCAL(NTRI,-ONE,STRI,1)
      CALL JACDG(STRI,U,EIGVAL,IWORK,WRKVEC,NSTDIAB,NSTDIAB)
      CALL DSCAL(NSTDIAB,-ONE,EIGVAL,1)
C
      DO I=II,L1
        IF(EIGVAL(I-NGRSTATE).LT.ERR_TH) THEN
           IF(MASWRK) WRITE(IW,9200)
           CALL ABRT
        END IF
        EIGVAL(I-NGRSTATE)=ONE/SQRT(EIGVAL(I-NGRSTATE))
      END DO
C
C
C Project to each (diabatic) subspace i.e group G_k
C
C
      DO K_GRP=II,L1
C                  Make S_k matrix
        DO ISTAT=II,L1
          DO JSTAT=II,L1
            S(ISTAT-NGRSTATE,JSTAT-NGRSTATE)=ZERO
            DO K=1,NLIST
              IF (LIST_GROUP(K).EQ.K_GRP) THEN
                S(ISTAT-NGRSTATE,JSTAT-NGRSTATE)=S(ISTAT-NGRSTATE,
     $          JSTAT-NGRSTATE) +DCICOEF(K,ISTAT)*DCICOEF(K,JSTAT)
              END IF
            END DO
          END DO
        END DO
C                  Make R_k matrix
        CALL DGEMM('T','N',L1-NGRSTATE,L1-NGRSTATE,L1-NGRSTATE,ONE,U,
     $             L1-NGRSTATE,S,L1-NGRSTATE,ZERO,BUFF,L1-NGRSTATE)
        CALL DGEMM('N','N',L1-NGRSTATE,L1-NGRSTATE,L1-NGRSTATE,ONE,BUFF,
     $             L1-NGRSTATE,U,L1-NGRSTATE,ZERO,S,L1-NGRSTATE)
C                 Now s is Us^{t}*S_k*Us
        DO I=II,L1
          DO J=II,L1
            S(I-NGRSTATE,J-NGRSTATE)=EIGVAL(I-NGRSTATE)
     $      *S(I-NGRSTATE,J-NGRSTATE)
          END DO
        END DO
        DO J=II,L1
          DO I=II,L1
            S(I-NGRSTATE,J-NGRSTATE)=EIGVAL(J-NGRSTATE)*S(I-NGRSTATE,
     $      J-NGRSTATE)
          END DO
        END DO
C
        CALL DGEMM('N','N',L1-NGRSTATE,L1-NGRSTATE,L1-NGRSTATE,ONE,U,
     $             L1-NGRSTATE,S,L1-NGRSTATE,ZERO,BUFF,L1-NGRSTATE)
        CALL DGEMM('N','T',L1-NGRSTATE,L1-NGRSTATE,L1-NGRSTATE,ONE,BUFF,
     $             L1-NGRSTATE,U,L1-NGRSTATE,ZERO,S,L1-NGRSTATE)
C
C            Diagonalize R_k matrix (stored at -s-)
C
        CALL CPYSQT(S,STRI,NSTDIAB,1)
        NTRI = (NSTDIAB*NSTDIAB+NSTDIAB)/2
        CALL DSCAL(NTRI,-ONE,STRI,1)
        CALL JACDG(STRI,BUFF,EIG_BUFF,IWORK,WRKVEC,NSTDIAB,NSTDIAB)
        CALL DSCAL(NSTDIAB,-ONE,EIG_BUFF,1)
C
Cc determine T' matrix 's k_grp-th column
C
        DO I=II,L1
          TP(I-NGRSTATE,K_GRP-NGRSTATE)=BUFF(I-NGRSTATE,1)
        END DO
C
      END DO
C
C
C              Symmetrized Orthogonalization of T' matrix
C         i.e. Make Unitary adiabatic/diabatic transform matrix
C
C
      CALL DGEMM('T','N',L1-NGRSTATE,L1-NGRSTATE,L1-NGRSTATE,ONE,TP,
     $           L1-NGRSTATE,TP,L1-NGRSTATE,ZERO,BUFF,L1-NGRSTATE)
C
      CALL CPYSQT(BUFF,STRI,NSTDIAB,1)
      NTRI = (NSTDIAB*NSTDIAB+NSTDIAB)/2
      CALL DSCAL(NTRI,-ONE,STRI,1)
      CALL JACDG(STRI,U,EIGVAL,IWORK,WRKVEC,NSTDIAB,NSTDIAB)
      CALL DSCAL(NSTDIAB,-ONE,EIGVAL,1)
C
      DO I=II,L1
        IF (EIGVAL(I-NGRSTATE).LT.ERR_TH) THEN
           IF(MASWRK) WRITE(IW,9200)
           CALL ABRT
        END IF
        EIGVAL(I-NGRSTATE)=ONE/SQRT(EIGVAL(I-NGRSTATE))
      END DO
C
      CALL DGEMM('N','N',L1-NGRSTATE,L1-NGRSTATE,L1-NGRSTATE,ONE,TP,
     $           L1-NGRSTATE,U,L1-NGRSTATE,ZERO,S,L1-NGRSTATE)
C
      DO J=II,L1
        DO I=II,L1
          BUFF(I-NGRSTATE,J-NGRSTATE)=EIGVAL(J-NGRSTATE)
     $             * S(I-NGRSTATE,J-NGRSTATE)
        END DO
      END DO
C
      CALL DGEMM('N','T',L1-NGRSTATE,L1-NGRSTATE,L1-NGRSTATE,ONE,BUFF,
     $           L1-NGRSTATE,U,L1-NGRSTATE,ZERO,T,L1-NGRSTATE)
C
C
C     Now -T- is adiabatic/diabatic transformation (not sign arranged)
C
C
C     Make sign arrangement for each column vector of -T- and make
C     CI coefficients for 'truncated' diabatic states
C
      IF (NRCSF.EQ.0) GO TO 100 ! SKIP THIS PROCEDURE
C
C           set matrix shapes
      LDA=MAXLIST
      LDB=NSTDMO-NGRSTATE
      LDC=MAXLIST
C
      DO J=1,NLIST
       DO I=II,NSTDMO
        DCICOEF2(J,I-NGRSTATE)=DCICOEF(J,I)
       END DO
      END DO
C
      CALL DGEMM('N','N',NLIST,NSTDMO-NGRSTATE,NSTDMO-NGRSTATE,ONE,
     &           DCICOEF2,LDA,T,LDB,ZERO,WORK,LDC)
C
      DO K=II,NSTDMO
        DUM=ZERO
        DO J=1,NLIST
          DUM=DUM+WORK(J,K-NGRSTATE)*DCICOEF_REF(J,K)
        END DO
        IF (DUM.LT.ZERO) THEN
          DO J=II,NSTDMO
            T(J-NGRSTATE,K-NGRSTATE)=-T(J-NGRSTATE,K-NGRSTATE)
          END DO
          DO J=1,NLIST
            DCICOEF(J,K)=-WORK(J,K-NGRSTATE)
          END DO
        ELSE
          DO J=1,NLIST
            DCICOEF(J,K)=WORK(J,K-NGRSTATE)
          END DO
        END IF
      END DO
C
C        Now DCICOEF is transformed to the ci coefficients of
C        diabatic states (Diabatic template)
C
  100 CONTINUE
C
C
C          Make diabatic Hamiltonian matrix in TP:
C            TP = [T-dagger * H(adiabatic)] * T
C
C
      DO I=II,L1
        DO J=II,L1
          BUFF(I-NGRSTATE,J-NGRSTATE)=T(J-NGRSTATE,I-NGRSTATE)
        END DO
      END DO
C
      DO J=II,L1
        DO I=II,L1
          BUFF(I-NGRSTATE,J-NGRSTATE) =
     &                BUFF(I-NGRSTATE,J-NGRSTATE) * E_ADIA(J)
        END DO
      END DO
C
      CALL DGEMM('N','N',L1-NGRSTATE,L1-NGRSTATE,L1-NGRSTATE,ONE,
     $           BUFF,L1-NGRSTATE,T,L1-NGRSTATE,ZERO,TP,L1-NGRSTATE)
C
C
      IF(MASWRK) THEN
C
C Print out Diabatic Hamiltonian matrix elements
C
         WRITE(IW,9010)
         DO I=II,NSTDMO
           WRITE(IW,9020) I,TP(I-NGRSTATE,I-NGRSTATE)
         END DO
C
         WRITE(IW,9030)
         DO I=II,NSTDMO-1
           DO J=I+1,NSTDMO
             WRITE(IW,9040) I,J,TP(I-NGRSTATE,J-NGRSTATE)
           END DO
         END DO
C
C Print out Diabatic templates
C
         WRITE(IW,9050)
         DO I=II,NSTDMO
           WRITE(IW,9060) I
           DO J=1,NLIST
             IF (LIST_GROUP(J).EQ.I) THEN
               WRITE(IW,9070) LIST_CSF(J),DCICOEF(J,I)
             END IF
           END DO
         END DO
C
C Print out Transformation matrix
C
         WRITE(IW,9080)
         CALL PRSQ(T,NSTDIAB,NSTDIAB,NSTDIAB)
      END IF
      RETURN
C
 9010 FORMAT(/1X,'-------------------------------------------'/
     &        1X,'  - DIABATIC HAMILTONIAN MATRIX ELEMENTS - '/
     &        1X,'-------------------------------------------'/
     &        1X,'                                           '/
     &        1X,'--- DIABATIC ENERGIES (DIAGONAL ELEMENT) ---')
 9020 FORMAT(1X,'DIABATIC STATE # (GROUP #)',I3,3X,
     &           ' ENERGY=',F18.9)
 9030 FORMAT(/1X,'--- DIABATIC COUPLINGS (OFF DIAGONAL ELEMENTS)---')
 9040 FORMAT(1X,'STATE #''S (',I3,I3,')  COUPLING =',F12.9)
 9050 FORMAT(/1X,'---------------------------------------'/
     &        1X,'         - DIABATIC STATES -           '/
     &        1X,'---------------------------------------')
 9060 FORMAT(1X,'STATE # ',I2/1X,10(1H-)/
     &       1X,'   <CSF>      <COEFFICIENT>')
 9070 FORMAT(1X,I7,5X,F12.6)
 9080 FORMAT(/1X,'---------------------------------------'/
     &        1X,'    - ROTATION TO DIABATIC STATES -    '/
     &        1X,'---------------------------------------'/
     &        1X,'ROWS=ADIABATIC, COLUMNS=DIABATIC STATES')
C9090 format(1x,'element (',i2,i2,') = ',1p,e15.8,0p)
 9200 FORMAT(1X,'GETHDIA: CANNOT SYMMETRICALLY ORTHOGONALIZE. STOP')
      END
C
C*MODULE DIAB    *DECK PUCSFGRPS
      SUBROUTINE PUCSFGRPS(NSTATE,NLIST,COEF,LIST_CSF,LIST_GROUP,
     &                     MAXLIST,MAXCI)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
C
      DIMENSION LIST_CSF(MAXLIST)
      DIMENSION LIST_GROUP(MAXLIST)
      DIMENSION COEF(MAXLIST,MAXCI)
C
      CHARACTER*8 REFCSF,ENDWRD
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA REFCSF /' $REFCSF'/
      DATA ENDWRD /' $END   '/
C
C        ---- punch out data for dominant CSFs ----
C
      IF(.NOT.MASWRK) RETURN
C
      WRITE(IP,9900) REFCSF
C
      WRITE(IP,*) NLIST
      MAX=0
10    MIN=MAX+1
      MAX=MAX+5
      IF (MAX.GT.NLIST) MAX=NLIST
      WRITE(IP,9910) (LIST_CSF(I),LIST_GROUP(I),I=MIN,MAX)
      IF (MAX.LT.NLIST) GO TO 10
C         -- punch out diabatic CI coefficients for each set of DMOs
      DO J=1,NSTATE
        JCOUNT=0
        MAX=0
20      MIN=MAX+1
        MAX=MAX+5
        JCOUNT=JCOUNT+1
        IF (MAX.GT.NLIST) MAX=NLIST
        IF (NLIST.LE.99) WRITE(IP,9920) J,JCOUNT,
     &                     (COEF(I,J),I=MIN,MAX)
        IF (NLIST.GT.99) WRITE(IP,9930) J,JCOUNT,
     &                     (COEF(I,J),I=MIN,MAX)
        IF (MAX.LT.NLIST) GO TO 20
      END DO
C
      WRITE(IP,9900) ENDWRD
      RETURN
C
9900  FORMAT(A8)
9910  FORMAT(I8,'(',I2,')')
9920  FORMAT(I2,I3,5E15.8)
9930  FORMAT(I3,I2,5E15.8)
C
C-MRMP-      end
C-MRMP-C
C-MRMP-C*MODULE DIAB    *DECK WFNDIA_MCQDPT
C-MRMP-      subroutine wfndia_mcqdpt
C-MRMP-
C-MRMP-      implicit double precision(a-h,o-z)
C-MRMP-c
C-MRMP-      logical stdphase
C-MRMP-c
C-MRMP-C--   parameter (mxatom=128)
C-MRMP-C--   parameter (mxioda=255)
C-MRMP-      parameter (maxci=50)
C-MRMP-      parameter (mdiis=19)
C-MRMP-c--
C-MRMP-
C-MRMP-c--   parameter (mxprim=2048)
C-MRMP-      parameter (ndm_size=16)
C-MRMP-      parameter (maxlist=64)
C-MRMP-      parameter (maxtot_orb=1024)
C-MRMP-
C-MRMP-c--
C-MRMP-      parameter (mxn_ref=10) !  Max number of the reference geometry
C-MRMP-                             ! (arrangement)  UNDER CONSTRUCTION
C-MRMP-c--
C-MRMP-      logical focas,soscf,dropc
C-MRMP-      LOGICAL FINAL,MCNOCI,MLMOCI,MCANCI
C-MRMP-      LOGICAL NOTRF
C-MRMP-      LOGICAL FULLCI
C-MRMP-      LOGICAL OFFSYM
C-MRMP-c--   INTEGER FOCAS
C-MRMP-C#g77 ------------------------------------------
C-MRMP-      CHARACTER*8 DIRECT,diavecw,dfrmvecw,dpsvecw,
C-MRMP-     1            frdcw,frvlw,endwrd,hndtyp,typsav
C-MRMP-      CHARACTER*4 lab_c1,moslab_active,moslab_refdmo,
C-MRMP-     1            moslab_refps,mcmoslab
C-MRMP-c--   CHARACTER*4 label2
C-MRMP-C#g77 ------------------------------------------
C-MRMP-      COMMON /IOFILE/ IR,IW,IP,ijk,IJKT,IDAF,NAV,IODA(950)
C-MRMP-c--   COMMON/DAFILE/IDAF,NAV,IODA(MXIODA)
C-MRMP-      parameter (mxatm=2000)
C-MRMP-      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NAinf,NBinf,
C-MRMP-     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C-MRMP-      COMMON/ENRGCI/EN,EC,ECI(MAXCI),NSTATE
C-MRMP-      COMMON /CASOPT/ CASHFT,CASDII,NRMCAS,FOCAS,SOSCF,DROPC
C-MRMP-      COMMON/NTNOPT/ENERGY,ENERG0,DEMAX,SQCDF,ITER,MICRO,
C-MRMP-     1              FINAL,MCNOCI,MLMOCI,MCANCI,
C-MRMP-     2              NOCAN,NOCAS,NOCI,LMOCI,NOTRF
C-MRMP-c---  COMMON/QMTOPT/QMTTOL,NQMT
C-MRMP-      COMMON/TRFOPT/MCTRF,MPTRF
C-MRMP-      COMMON/DRTOPT/FULLCI,IFFULL
C-MRMP-      COMMON/DRTPAR/NCO,NMCCO,NCI,MSYM
C-MRMP-c--   COMMON/TRFPAR/NFRZC,NMCORB,NCORB,NOCC,NORB,NBF
C-MRMP-      COMMON/ MCPAR/NFZC,NCORBS,NACT,NORBS,NORB1,NTOT,NWKS
C-MRMP-      COMMON/DIICAS/NCALL,NDIIS
C-MRMP-      COMMON/DIIFIL/IDAF30,NAV30,IODA30(4*MDIIS+5)
C-MRMP-      COMMON/HNDOPT/HNDTYP,DSKTYP,FILTYP,PCKTYP
C-MRMP-      COMMON/HNDFIL/IFT12,IFT13,IFT14
C-MRMP-      COMMON/SCM   /X(1)
C-MRMP-
C-MRMP-      parameter (MXDIABACT=30)
C-MRMP-      common /diabat/ ndmosym,nstry,ndfrm,nrcsf,
C-MRMP-     *                alpha_n,alpha_r,alpha_t,
C-MRMP-     *                slctth,moslab_charact(MXDIABACT),
C-MRMP-     *                th_doc,th_vir,conv_th,max_iter,ngrstate
C-MRMP-      common/mcmossym/mcmoslab(maxtot_orb)
C-MRMP-      common/prototype/n_ref,nmlap(mxn_ref),ndlap,norient
C-MRMP-      common/diabmqpar1/nstci,nstcas,nstmq,kstci_cas(50),kstci_mq(50),
C-MRMP-     &                  kstcas_mq(50)
C-MRMP-      common/diabmqpar2/coef_max1(20),coef_max2(20),
C-MRMP-     &                  eigvec(400),e_mcqdpt(20)
C-MRMP-      common/symboldmo/nsymbol_doc,nsymbol_val,nsymbol_vir
C-MRMP-      common/diatmpfil/nft21,nft22,nft23,nft24
C-MRMP-c--   common/xyzlabel_ao/label_type(mxprim,mxatom),
C-MRMP-c--  &                   label_shell(mxprim,mxatom),
C-MRMP-c--  &                   num_ao(mxatom),ntot_basis
C-MRMP-C--   common/mollab/anam(mxatom),bnam(mxatom)
C-MRMP-
C-MRMP-c--- labels
C-MRMP-      dimension moslab_active(ndm_size)
C-MRMP-      dimension moslab_refdmo(ndm_size)
C-MRMP-      dimension moslab_refps(ndm_size)
C-MRMP-      dimension moslab_pseudo(ndm_size)
C-MRMP-c--   dimension label2(12)
C-MRMP-c---
C-MRMP-
C-MRMP-      dimension avocc_act(ndm_size)
C-MRMP-      dimension list_csf(maxlist)
C-MRMP-      dimension list_group(maxlist)
C-MRMP-      dimension dcicoef(maxlist,maxci)
C-MRMP-      dimension dcicoef_ref(maxlist,maxci)
C-MRMP-      dimension title(10),title1(10)
C-MRMP-      dimension itemp(ndm_size)                              !HN 2/22/02
C-MRMP-
C-MRMP-
C-MRMP-      DATA DIRECT        /'DIRECT  '/
C-MRMP-      data lab_c1       /4hA   /
C-MRMP-
C-MRMP-C--   data nft11 /11/
C-MRMP-      data nft12 /12/
C-MRMP-
C-MRMP-      data diavecw /' $DIAVEC'/
C-MRMP-      data dfrmvecw /' $DFMVEC'/
C-MRMP-      data dpsvecw /' $DPSVEC'/
C-MRMP-      data frdcw /' $LCLDC'/
C-MRMP-      data frvlw /' $LCLVL'/
C-MRMP-      data endwrd  /' $END   '/
C-MRMP-C
C-MRMP-c--   data label2 /'s','px','py','pz','dxy','dyz','dzx','dxx',
C-MRMP-c--  &             'dyy','dzz','f','g'/
C-MRMP-c
C-MRMP-c avocc_act(i): averaged occupation # of i-th active MOs
C-MRMP-c list_csf(i): dominant CSF index
C-MRMP-c list_group(i): Group index  where list_csf(i)-th CSF belongs to
C-MRMP-c dcicoef_ref(i,j): CI coefficents for diabatic states of list_csf(i)-th
C-MRMP-c                 CSF for j-th diabatic states
C-MRMP-c
C-MRMP-c These three data are read from $REFCSF
C-MRMP-c
C-MRMP-c dcicoef(i,j): CI coefficients of list_csf(i)-th CSF
C-MRMP-c               for j-th adiabatic states
C-MRMP-c
C-MRMP-c
C-MRMP-      stdphase=.true.
C-MRMP-
C-MRMP-c
C-MRMP-c ----- Set some parameters for CI --
C-MRMP-c
C-MRMP-
C-MRMP-      final=.false.
C-MRMP-      mcanci=.false.
C-MRMP-      mcnoci=.false.
C-MRMP-      mlmoci=.false.
C-MRMP-      notrf=.false.
C-MRMP-      fullci=.true.
C-MRMP-
C-MRMP-c
C-MRMP-c ----- Open -DIIS- work file ---
C-MRMP-c
C-MRMP-
C-MRMP-
C-MRMP-      ncall=0
C-MRMP-      ndiis=0
C-MRMP-      idaf30=30
C-MRMP-      nav30=0
C-MRMP-      ndar30=4*mdiis+5
C-MRMP-      if (focas) then
C-MRMP-        call raopen(idaf30,ioda30,nav30,ndar30)
C-MRMP-      end if
C-MRMP-
C-MRMP-c
C-MRMP-c ---- Set parameters for integral transformation ----
C-MRMP-c
C-MRMP-
C-MRMP-!     nco:   # of frozen core
C-MRMP-!     nmcco: # of core orbitals
C-MRMP-!     nocc:  # of active orbitals
C-MRMP-
C-MRMP-c--   mptrf=0
C-MRMP-c--   nfrzc=0
C-MRMP-c--   nmcorb=nco+nmcco
C-MRMP-      ncorb=nco+nmcco
C-MRMP-C--   norb=nqmt-ncorb
C-MRMP-C--   nocc=nci
C-MRMP-      nbf=num
C-MRMP-
C-MRMP-c
C-MRMP-c ---- Set parameters for -NTN- algorithm ----
C-MRMP-c
C-MRMP-
C-MRMP-!     ncorbs: # of (frozen+core) orbitals
C-MRMP-!     norbs:  # of (frozen+core+active) orbitals
C-MRMP-!     norb:   # total of MOs
C-MRMP-!     num:    # total of AOs (i.e. basis size)
C-MRMP-
C-MRMP-      imofzc=0  ! MWS initialized this otherwise undefined value
C-MRMP-      nfzc=imofzc
C-MRMP-      ncorbs=ncorb
C-MRMP-      norbs=ncorb+nci
C-MRMP-      norb1=nqmt
C-MRMP-      nact=nci
C-MRMP-      ntot=num
C-MRMP-
C-MRMP-c
C-MRMP-c ---- Set parameters for other modules
C-MRMP-c
C-MRMP-
C-MRMP-C--   na=norbs
C-MRMP-
C-MRMP-c
C-MRMP-c ---- Set parameters for this module
C-MRMP-c
C-MRMP-
C-MRMP-      n_active=norbs-ncorbs
C-MRMP-
C-MRMP-
C-MRMP-      write(iw,'(''---------------------------------------------''/
C-MRMP-     &       ''     Diabatization of MC-QDPT wave functions starts''/
C-MRMP-     &       ''     -------------------------------------------''/
C-MRMP-     &       ''                                                  '')')
C-MRMP-
C-MRMP-
C-MRMP-c=========== Prepation of 4fold way for MC-QDPT wave function =========
C-MRMP-
C-MRMP-c
C-MRMP-c Notice: (1) Input $DIABAT and $DFMVEC is already done in wfndia_cas
C-MRMP-c             thus skip
C-MRMP-c         (2) By the routine wfndia_cas, the CI vectors of MC-QDPT
C-MRMP-c         are in FT21, and sym. orthogonalized $DFMVEC is stored in FT22
C-MRMP-c         already.
C-MRMP-c         (3) Check of symmetry of was already done
C-MRMP-c         in the wfndia_cas; thus skip.
C-MRMP-c
C-MRMP-
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c Read prepaerd data from scrath files to make projected MC-QDPT
C-MRMP-c wave function
C-MRMP-c
C-MRMP-
C-MRMP-!  Read QDPT target CAS-CI vectors
C-MRMP-
C-MRMP-      rewind(nft21)
C-MRMP-      read(nft21) idum,nwks
C-MRMP-
C-MRMP-cc-- Get core memory ----
C-MRMP-
C-MRMP-      ix1=1                  ! ix1--ix2-1: CI vectors
C-MRMP-      ix2=ix1+nwks*nstmq     ! ix2--ix3-1: temp
C-MRMP-      ix3=ix2+nwks
C-MRMP-      last=ix3
C-MRMP-      call cmem(loadcm)
C-MRMP-      need=last
C-MRMP-      call setc(need)
C-MRMP-
C-MRMP-
C-MRMP-      icount=0
C-MRMP-      do i=1,nstcas
C-MRMP-        if (kstcas_mq(i).eq.0) then
C-MRMP-          call rdfuldia(nft21,nwks,x(ix3))  ! skip
C-MRMP-        else
C-MRMP-          icount=icount+1
C-MRMP-          ihead=ix1+nwks*(icount-1)
C-MRMP-          call rdfuldia(nft21,nwks,x(ihead))
C-MRMP-        end if
C-MRMP-      end do
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c Calculate new CI vectors of projected MC-QDPT wave function
C-MRMP-c and write them to FT12
C-MRMP-c
C-MRMP-
C-MRMP-!-- Change header part of FT12
C-MRMP-      rewind(nft12)
C-MRMP-      read(nft12) idum,idum,title,title1
C-MRMP-      rewind(nft12)
C-MRMP-      write(nft12) nstmq,nwks,title,title1
C-MRMP-!--
C-MRMP-
C-MRMP-      call mkqdptvec(nft12,x(ix1),eigvec,x(ix2),nwks,nstmq,
C-MRMP-     &               coef_max1,coef_max2)
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c Set parameter to calculate DM1 by using gugtdm
C-MRMP-c
C-MRMP-
C-MRMP-      nstate=nstmq
C-MRMP-
C-MRMP-
C-MRMP-cc--- Reset core memory
C-MRMP-
C-MRMP-      call cmem(ngotcm)
C-MRMP-      if (ngotcm.ne.loadcm) call setc(loadcm)
C-MRMP-c
C-MRMP-c ---- Now scratch FT21 is released ----
C-MRMP-c
C-MRMP-
C-MRMP-
C-MRMP-
C-MRMP-cc======== Diabatization procedure start ===========
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c Get MO-basis DM1 and write to FT21 temporary
C-MRMP-c ! n_active= # of active orbitals
C-MRMP-c        'dummy' storage isn't dimensioned yet.
C-MRMP-
C-MRMP-      call gugtdmx(ncorbs,n_active,nbf,nstate,dummy,dummy,idummy,idummy)
C-MRMP-      if (ndm_size.lt.n_active) then
C-MRMP-        write(iw,*) 'Too Large Active Space. Stop'
C-MRMP-        call abrt
C-MRMP-      end if
C-MRMP-
C-MRMP-c
C-MRMP-c Determination DMOs based on MC-QDPT wave functions
C-MRMP-c
C-MRMP-
C-MRMP-      n_sum=nmlap(1)
C-MRMP-
C-MRMP-
C-MRMP-cc --- Get core memory ---
C-MRMP-
C-MRMP-      n0=num*n_active
C-MRMP-      n1=num*num
C-MRMP-      n2=num*(num+1)/2
C-MRMP-      n3=num*n_active
C-MRMP-      n4=n_active*n_active*(nstate*(nstate+1)/2+1) ! +1--> for SA DM1
C-MRMP-
C-MRMP-      ix1=1        ! ix1--ix2-1: store reference DMOs
C-MRMP-      ix2=ix1+n0   ! ix2--ix3-1: store AO overlap
C-MRMP-      ix3=ix2+n2   ! ix3--ix4-1: temp region
C-MRMP-      ix4=ix3+n1   ! ix4--ix5-1: store DMO/AO
C-MRMP-      ix5=ix4+n3   ! ix5--ix6-1: store DM1
C-MRMP-      ix6=ix5+n4   ! ix6--last-1: store pseudo reference DMOs
C-MRMP-      last=ix6+ndlap*num
C-MRMP-
C-MRMP-      call cmem(loadcm)
C-MRMP-      need=last
C-MRMP-      call setc(need)
C-MRMP-
C-MRMP-cc Read AO overlap
C-MRMP-
C-MRMP-      call daread(idaf,ioda,x(ix2),n2,12,0)
C-MRMP-
C-MRMP-cc--- Transform $DIAVEC based on the specified orientation
C-MRMP-cc--- Assign irreps of $DIAVEC (if necessary) and make irreps label
C-MRMP-cc    of $DIAVEC
C-MRMP-
C-MRMP-cc Read $DIAVEC, Symmetry assign (moslab_refdmo)
C-MRMP-c       note, will need dynamic store for 'dummy' and 'moslab_refdmo'
C-MRMP-
C-MRMP-      if (n_sum.ne.0) then
C-MRMP-        call refdmosym(n_sum,nqmt,num,
C-MRMP-     *                 x(ix1),x(ix3),x(ix2),
C-MRMP-     &                 x(ix4),dummy,moslab_refdmo,
C-MRMP-     *                 diavecw,frvlw,nat,norient,stdphase)
C-MRMP-      end if
C-MRMP-
C-MRMP-cc--- Transform $DPSVEC based on the specified orientation.
C-MRMP-cc--- Assign irreps of $DPSVEC (if necessary) and make irreps label
C-MRMP-cc    Symmetry assign (moslab_refps)
C-MRMP-
C-MRMP-      if (ndlap.ne.0) then
C-MRMP-        call refdmosym(ndlap,nqmt,num,
C-MRMP-     *                 x(ix6),x(ix3),x(ix2),
C-MRMP-     &                 x(ix4),dummy,moslab_refps,
C-MRMP-     *                 dpsvecw,frdcw,nat,norient,stdphase)
C-MRMP-      end if
C-MRMP-
C-MRMP-
C-MRMP-cc Pick up the active MO coefficients  (only active part)
C-MRMP-c- (CASSCF-based DMOs)
C-MRMP-
C-MRMP-      call daread(idaf,ioda,x(ix3),n1,15,0)
C-MRMP-      do i=1,n_active
C-MRMP-        ishift1=ix3-1+num*(ncorbs+i-1)
C-MRMP-        ishift2=ix4-1+num*(i-1)
C-MRMP-        do j=1,num
C-MRMP-          x(j+ishift2)=x(j+ishift1)
C-MRMP-        end do
C-MRMP-      end do
C-MRMP-
C-MRMP-!-- Now x(ix1)--> reference DMOs (i.e. $DIAVEC)
C-MRMP-!       x(ix2)--> AO overlap
C-MRMP-!       x(ix4)--> active MO (DA10 #15)
C-MRMP-!       x(ix6)---> pseudo reference MO (i.e. $DPSVEC)
C-MRMP-
C-MRMP-c
C-MRMP-c -- Optimize orbitals to MC-QDPT based Diabatic MOs ---
C-MRMP-c
C-MRMP-
C-MRMP-C--   L1=nstate*(nstate+1)/2
C-MRMP-C--   L2=ndm_size*ndm_size
C-MRMP-C--   L3=n_active*n_active
C-MRMP-
C-MRMP-
C-MRMP-cc  Read all DM1 and also add SA DM1 to data
C-MRMP-
C-MRMP-      call arrange_dm(x(ix5),x(ix3),nstate,n_active,ndm_size,nft21)
C-MRMP-
C-MRMP-
C-MRMP-! Now x(ix5) is all DM1 + SA DM1
C-MRMP-
C-MRMP-c
C-MRMP-c Make irreps label of active MOs. This procedure is completely same
C-MRMP-c with the prepation procedure in the routine wfndia_cas
C-MRMP-c
C-MRMP-
C-MRMP-      do i=1,n_active
C-MRMP-        moslab_active(i)=mcmoslab(ncorbs+i)
C-MRMP-      end do
C-MRMP-
C-MRMP-C         MWS notes -NDMOSYM- meaning was NOT reversed in MCQDPT
C-MRMP-      if (ndmosym.ne.0) then
C-MRMP-        do i=1,n_active
C-MRMP-          moslab_active(i)=lab_c1
C-MRMP-        end do
C-MRMP-        do i=1,n_sum
C-MRMP-          moslab_refdmo(i)=lab_c1
C-MRMP-        end do
C-MRMP-        do i=1,ndlap
C-MRMP-C          moslab_refps(i)=lab_ci                                         !CK1105
C-MRMP-          moslab_refps(i)=lab_c1                                          !CK1105
C-MRMP-        end do
C-MRMP-      end if
C-MRMP-
C-MRMP-c
C-MRMP-c DMO optimization starts. The procedure consists of
C-MRMP-c (1) Threefold density criterion or use ifo of CAS based DMOs
C-MRMP-c (2) Apply the fourfold way to Doc-candidate MOs
C-MRMP-c (2) Separate active space to 3 (or 2 or 1) block
C-MRMP-c (3) The fourfold way with (block) MORMO criterion
C-MRMP-c (4) Deformation check
C-MRMP-c
C-MRMP-
C-MRMP-!------ See this process ------
C-MRMP-c
C-MRMP-c Step (1)
C-MRMP-c         note, need to revisit storage to be like CAS code path.
C-MRMP-c                calling arguemnt order needs to be checked too.
C-MRMP-      if (n_sum.eq.0) then
C-MRMP-        ndmat=1
C-MRMP-        call threefold(alpha_n,alpha_r,alpha_t,conv_th,max_iter,nstate,
C-MRMP-     &                 num,n_active,moslab_active,x(ix5),x(ix4),
C-MRMP-     &                 avocc_act,x(ix3),dummy,ndmat,stdphase)
C-MRMP-
C-MRMP-      else ! use data of wfn_cas
C-MRMP-        idiag=ix5+n_active*n_active*(nstate*(nstate+1)/2)
C-MRMP-        do i=1,n_active
C-MRMP-          avocc_act(i)=x(idiag)
C-MRMP-          idiag=idiag+n_active+1
C-MRMP-        end do
C-MRMP-      end if
C-MRMP-
C-MRMP-c
C-MRMP-c Step (2)
C-MRMP-c
C-MRMP-
C-MRMP-       ndoc=0
C-MRMP-       do i=1,n_active
C-MRMP-         if (moslab_charact(i).eq.nsymbol_doc) ndoc=ndoc+1
C-MRMP-       end do
C-MRMP-
C-MRMP-       ndoc_cand=0
C-MRMP-
C-MRMP-       if ((ndfrm.eq.0).or.(ndlap.eq.0).or.(ndoc.eq.0)) go to 100
C-MRMP-
C-MRMP-       write(iw,*) '-----------------------------------------------'
C-MRMP-       write(iw,*) ' C-R algorithm is applied to Doc block, '
C-MRMP-       write(iw,*) ' for MC-QDPT wave functions                  '
C-MRMP-       write(iw,*) '------------------------------------------------'
C-MRMP-
C-MRMP-       do i=1,n_active
C-MRMP-         if (th_doc.lt.avocc_act(i)) then
C-MRMP-           ndoc_cand=ndoc_cand+1
C-MRMP-           moslab_pseudo(i)=nsymbol_val
C-MRMP-         else
C-MRMP-           moslab_pseudo(i)=nsymbol_vir
C-MRMP-         end if
C-MRMP-       end do
C-MRMP-
C-MRMP-       if (ndoc_cand.lt.ndoc) then
C-MRMP-         write(iw,*) '# of candidate MO for DC block is too small'
C-MRMP-         write(iw,*) 'C-R algorithm is NOT applied. Contine'
C-MRMP-         go to 100
C-MRMP-       else
C-MRMP-         write(iw,*) ndoc_cand,' MOs are caught based on MC-QDPT wf'
C-MRMP-         write(iw,*) 'then ', ndoc_cand-ndoc,' are released.'
C-MRMP-       end if
C-MRMP-
C-MRMP-! Sort of MO in the caught part to accelate convergence
C-MRMP-       icount=0                                              !HN 2/22/02
C-MRMP-       do i=1,n_active                                       !HN 2/22/02
C-MRMP-         if (th_doc.lt.avocc_act(i)) then                    !HN 2/22/02
C-MRMP-           icount=icount+1                                   !HN 2/22/02
C-MRMP-           itemp(icount)=i                                 !HN 2/22/02
C-MRMP-         end if                                              !HN 2/22/02
C-MRMP-       end do                                                !HN 2/22/02
C-MRMP-       ndmat=1  ! MWS, this is not the right value
C-MRMP-       dummy=0.0d+00  ! supposed to be an overlap storage (MWS)
C-MRMP-       call presort(nstate,num,n_active,ndoc_cand,ndlap,itemp,x(ix4),
C-MRMP-     &              x(ix6),x(ix2),dummy,x(ix3),x(ix5),ndmat,
C-MRMP-     &              avocc_act,moslab_active) !HN 2/22/02
C-MRMP-
C-MRMP-
C-MRMP-! Apply fourfold
C-MRMP-       ndmat=-1
C-MRMP-c             note that dummy needs to be the rotation matrix storage
C-MRMP-        ndmat=-1
C-MRMP-        dummy=0.0d+00
C-MRMP-       call fourfold(alpha_n,alpha_r,alpha_t,conv_th,max_iter,
C-MRMP-     &     nstate,num,n_active,ndlap,moslab_active,
C-MRMP-     &     moslab_pseudo,moslab_refps,x(ix5),ndmat,
C-MRMP-     &     x(ix4),x(ix6),x(ix2),
C-MRMP-     &     avocc_act,x(ix3),dummy,stdphase)
C-MRMP-
C-MRMP-100    continue
C-MRMP-
C-MRMP-c
C-MRMP-c Step (3)
C-MRMP-c
C-MRMP-
C-MRMP-       ndmat= -7  ! fix later
C-MRMP-       dummy=0.0d+00  ! needs to be sratch nact x nact space.
C-MRMP-       call detblock(ndfrm,num,n_active,nstate,ndoc_cand,
C-MRMP-     &               moslab_active,moslab_charact,moslab_pseudo,
C-MRMP-     &               avocc_act,th_doc,th_vir,dummy,x(ix4),
C-MRMP-     &               x(ix3),x(ix2),x(ix5),ndmat)
C-MRMP-
C-MRMP-
C-MRMP-c!      if (ndfrm.eq.1) then
C-MRMP-c!        call prlapdmo(num,n_active,x(ix4),x(ix3),x(ix2),dummy)
C-MRMP-c!     &              x(ix2))
C-MRMP-c!      end if
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c Step (4)
C-MRMP-c
C-MRMP-
C-MRMP-      if (n_sum.ne.0) then
C-MRMP-        write(iw,*) '----------------------------------------------'
C-MRMP-        write(iw,*) 'The used DMOs block for the MORMO '
C-MRMP-        write(iw,*) '(may be changed with the input moslab_charact'
C-MRMP-        write(iw,*)  (moslab_charact(i),i=1,n_active)
C-MRMP-        write(iw,*) '----------------------------------------------'
C-MRMP-        write(iw,*) '                                              '
C-MRMP-
C-MRMP-! Sort of MO in the caught part to accelate convergence
C-MRMP-        icount=0                                             !HN 2/22/02
C-MRMP-        do i=1,n_active                                      !HN 2/22/02
C-MRMP-          if (moslab_charact(i).eq.nsymbol_val) then         !HN 2/22/02
C-MRMP-            icount=icount+1                                  !HN 2/22/02
C-MRMP-            itemp(icount)=i                                !HN 2/22/02
C-MRMP-          end if                                             !HN 2/22/02
C-MRMP-        end do                                               !HN 2/22/02
C-MRMP-        ndmat=1  ! MWS: not yet correct value
C-MRMP-        call presort(nstate,num,n_active,icount,n_sum,itemp,x(ix4),
C-MRMP-     &               x(ix1),x(ix2),dummy,x(ix3),x(ix5),
C-MRMP-     &               ndmat,avocc_act,moslab_active) !HN 2/22/02
C-MRMP-
C-MRMP-! Apply the fourfold
C-MRMP-c             note that dummy needs to be the rotation matrix storage
C-MRMP-        ndmat=-1
C-MRMP-        dummy=0.0d+00
C-MRMP-        call fourfold(alpha_n,alpha_r,alpha_t,conv_th,max_iter,
C-MRMP-     &                nstate,num,n_active,n_sum,moslab_active,
C-MRMP-     &                moslab_charact,moslab_refdmo,x(ix5),ndmat,
C-MRMP-     &                x(ix4),x(ix1),x(ix2),avocc_act,x(ix3),
C-MRMP-     &                dummy,stdphase)
C-MRMP-      end if
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c Step (5) Order DMOs finally
C-MRMP-c
C-MRMP-
C-MRMP-      ndmat=-1  ! settle this hash later
C-MRMP-      call orddmo(num,n_active,nstate,moslab_charact,
C-MRMP-     &            moslab_active,x(ix5),ndmat,avocc_act,
C-MRMP-     &            x(ix4),x(ix3),x(ix2),dummy)
C-MRMP-
C-MRMP-      if (ndfrm.eq.1) then
C-MRMP-        write(6,*) 'calling PRLAPDMO with deffective storage'
C-MRMP-        dummy=3  ! this needs to be act x act temp storage
C-MRMP-        call prlapdmo(num,n_active,x(ix4),x(ix3),x(ix2),dummy)
C-MRMP-      end if
C-MRMP-
C-MRMP-c
C-MRMP-c Punch out DMO/AO  ($DFMVEC)
C-MRMP-c
C-MRMP-      write(ip,*) '-- Diabatic Orbitals Based on MC-QDPT (active) -- '
C-MRMP-      write(ip,'(a8)') dfrmvecw
C-MRMP-      call pusql(x(ix4),n_active,num,num)
C-MRMP-      write(ip,'(a8)') endwrd
C-MRMP-
C-MRMP-cc Print out DMO/AO
C-MRMP-      write(iw,'(''(--------------------------------------------''/
C-MRMP-     &       '' - Diabatic Orbitals (DMOs) expanded by AOs - ''/
C-MRMP-     &       ''(DMOs may not satisfy irreps)'')')
C-MRMP-      write(iw,*) '---- DMOs based on MC-QDPT (active) ----'
C-MRMP-
C-MRMP-      write(iw,*) nmlap(1), 'Active MOs are determined by MORMO'
C-MRMP-      call prevls(x(ix4),avocc_act,moslab_active,n_active,num,num)
C-MRMP-
C-MRMP-c
C-MRMP-c Set MC-QDPT based DMOs for carring out CI
C-MRMP-c
C-MRMP-
C-MRMP-      call daread(idaf,ioda,x(ix3),n1,15,0) ! read MOs used by MC-QDPT
C-MRMP-
C-MRMP-cc Convert active part  to MC-QDPT based DMOs
C-MRMP-
C-MRMP-      do i=1,n3
C-MRMP-        ishift1=ix3-1+num*ncorbs
C-MRMP-        x(i+ishift1)=x(i+ix4-1)
C-MRMP-      end do
C-MRMP-
C-MRMP-cc Write MC-QDPT base DMO to #15
C-MRMP-      call dawrit(idaf,ioda,x(ix3),n1,15,nav)
C-MRMP-
C-MRMP-cc -- Reset core memory --
C-MRMP-
C-MRMP-      call cmem(ngotcm)
C-MRMP-      if (ngotcm.ne.loadcm) call setc(loadcm)
C-MRMP-
C-MRMP-
C-MRMP-c========= Calculation of projected MC-QDPT wave fution (CI coeffcient)
C-MRMP-c          in MC-QDPT based DMOs starts =============================
C-MRMP-
C-MRMP-c
C-MRMP-c Symmetry turned OFF  If needed
C-MRMP-c
C-MRMP-
C-MRMP-      offsym=.false.
C-MRMP-      if ((nstate.gt.1).and.(ndmosym.ne.0)) then ! mod 6/22
C-MRMP-        call symoff
C-MRMP-        typsav=hndtyp
C-MRMP-        hndtyp=direct
C-MRMP-        offsym=.true.
C-MRMP-      end if
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c Carry out CI in MC-QDPT based DMOs
C-MRMP-c
C-MRMP-
C-MRMP-
C-MRMP-cc Set parameter
C-MRMP-
C-MRMP-      nstate=nstci
C-MRMP-
C-MRMP-cc Do CI
C-MRMP-
C-MRMP-      final=.true.
C-MRMP-      mcanci=.false.
C-MRMP-      mcnoci=.false.
C-MRMP-      mlmoci=.false.
C-MRMP-
C-MRMP-      ift12=1
C-MRMP-      ift13=1
C-MRMP-      ift14=1
C-MRMP-
C-MRMP-      iprint=0
C-MRMP-      call gugdrt
C-MRMP-
C-MRMP-      if (focas) call castrf
C-MRMP-      if (.not.focas.and.mctrf.eq.1) call trfint
C-MRMP-      if (.not.focas.and.mctrf.ne.1) call trfmcxfake
C-MRMP-
C-MRMP-      call srtgug
C-MRMP-      call gugaem(iprint)
C-MRMP-      call gugadgmod(offsym,nstci)
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c     ----- Get CI coefficient of dominant CSFs in DMO base
C-MRMP-c
C-MRMP-
C-MRMP-c
C-MRMP-c Read data of dominant CSFs if necessary
C-MRMP-c
C-MRMP-
C-MRMP-      if (nrcsf.ne.0) then
C-MRMP-        rewind(ir)
C-MRMP-        call RDCSFGRPS(nstmq,nlist,dcicoef_ref,
C-MRMP-     &                 list_csf,list_group,maxlist,maxci)
C-MRMP-      end if
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c (1) Make CI vectors for projectef MC-QDPT states (QDPT target states
C-MRMP-c     only) in MC-QDPT based DMOs
C-MRMP-c (2) Make some lists for dominat CSF to make group G_k
C-MRMP-c     If the list is specified in the card, use it.
C-MRMP-c (3) Search CI coefficients of dominant CSFs and store to the array
C-MRMP-c     dcicoef
C-MRMP-c Note: FT21 may be used as scratch file in routine refdiamq
C-MRMP-c
C-MRMP-
C-MRMP-      call refdiamq(list_csf,list_group,dcicoef,nlist,nstmq,nstci,
C-MRMP-     &              kstci_mq,coef_max1,e_mcqdpt,eigvec)
C-MRMP-
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c  Make adiabatic/diabatic transformation matrix
C-MRMP-c
C-MRMP-
C-MRMP-cc -- Get core memory
C-MRMP-      ix1=1
C-MRMP-      ix2=ix1+nstmq*nstmq
C-MRMP-      ix3=ix2+nstmq*nstmq
C-MRMP-      need=ix3
C-MRMP-c
C-MRMP-      idummy=0   ! MWS changed this one a lot.
C-MRMP-      dummy=0.0d+00
C-MRMP-      call gethdia(nrcsf,e_mcqdpt,nstmq,nlist,list_group,
C-MRMP-     &             list_csf,dcicoef,dcicoef_ref,dummy,
C-MRMP-     &             x(ix1),x(ix2),dummy,dummy,dummy,
C-MRMP-     &             dummy,idummy,dummy,dummy,dummy,dummy,
C-MRMP-     &             ngrstate,idummy,idummy,idummy)
C-MRMP-c
C-MRMP-c Punch out CSF list, CI coefficients of 'truncated' Diabatic states
C-MRMP-c to $REFCSF (See routine tmset)
C-MRMP-c
C-MRMP-
C-MRMP-      call PUCSFGRPS(nstmq,nlist,dcicoef,list_csf,list_group,
C-MRMP-     &               maxlist,maxci)
C-MRMP-
C-MRMP-
C-MRMP-cc Reset core memory
C-MRMP-
C-MRMP-      call cmem(ngotcm)
C-MRMP-      if (ngotcm.ne.loadcm) call setc(loadcm)
C-MRMP-
C-MRMP-c
C-MRMP-c ============= diabatization procedure was done =============
C-MRMP-c
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c ======= Clearning up of the MC-QDPT diabatization procedure ======
C-MRMP-c
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c Switch back DA10 #125 to #15
C-MRMP-c
C-MRMP-
C-MRMP-cc Get core memory
C-MRMP-
C-MRMP-      n1=num*num
C-MRMP-      ix1=1
C-MRMP-      last=ix1+n1
C-MRMP-
C-MRMP-      call cmem(loadcm)
C-MRMP-      need=last
C-MRMP-      call setc(need)
C-MRMP-
C-MRMP-      call daread(idaf,ioda,x,n1,326,0)
C-MRMP-      call dawrit(idaf,ioda,x,n1,15,nav)
C-MRMP-
C-MRMP-cc Reset core memory
C-MRMP-      call cmem(ngotcm)
C-MRMP-      if (ngotcm.ne.loadcm) call setc(loadcm)
C-MRMP-
C-MRMP-!
C-MRMP-!---- Now av Fock orbitals for original CASSCF calculation
C-MRMP-!     returns to DA10 #15  -----------
C-MRMP-!
C-MRMP-
C-MRMP-c
C-MRMP-c Symmetry turned ON
C-MRMP-c
C-MRMP-      if (offsym) then
C-MRMP-        call symon
C-MRMP-        hndtyp=typsav
C-MRMP-        offsym=.false.
C-MRMP-        nstate=nstcas
C-MRMP-      end if
C-MRMP-
C-MRMP-c
C-MRMP-c One more CI calculation with -MC- orbitals for consistency
C-MRMP-c
C-MRMP-      final=.false.
C-MRMP-      mcanci=.false.
C-MRMP-      mcnoci=.false.
C-MRMP-      mlmoci=.false.
C-MRMP-
C-MRMP-      ift12=1
C-MRMP-      ift13=1
C-MRMP-      ift14=1
C-MRMP-
C-MRMP-      call gugdrt
C-MRMP-
C-MRMP-      if (focas) call castrf
C-MRMP-      if (.not.focas.and.mctrf.eq.1) call trfint
C-MRMP-      if (.not.focas.and.mctrf.ne.1) call trfmcxfake
C-MRMP-
C-MRMP-      call srtgug
C-MRMP-      call gugaem(iprint)
C-MRMP-      call gugadg(iprint)
C-MRMP-      call gug2dm
C-MRMP-
C-MRMP-c
C-MRMP-c Close -DIIS- work file if it was used
C-MRMP-c
C-MRMP-
C-MRMP-      if (focas) then
C-MRMP-        call raclos(idaf30,nav30,iw)
C-MRMP-        call rartrn(idaf30)
C-MRMP-      end if
C-MRMP-c
C-MRMP-      return
C-MRMP-      end
C-MRMP-C
C-MRMP-C*MODULE DIAB    *DECK DIABMQWR1
C-MRMP-      subroutine diabmqwr1(nft12,nft21,ndmosym,
C-MRMP-     &                     nstry,eci_sav,eci,nwks,civec)
C-MRMP-
C-MRMP-      implicit double precision(a-h,o-z)
C-MRMP-
C-MRMP-
C-MRMP-      common/diabmqpar1/nstci,nstcas,nstmq,kstci_cas(50),kstci_mq(50),
C-MRMP-     &                  kstcas_mq(50)
C-MRMP-      common/diabmqpar2/coef_max1(20),coef_max2(20),
C-MRMP-     &                  eigvec(400),e_mcqdpt(20)
C-MRMP-
C-MRMP-      COMMON /IOFILE/ IR,IW,IP,ijk,IJKT,IDAF,NAV,IODA(950)
C-MRMP-      data zero   /0.0d+00/
C-MRMP-      data cvgtol /1.0d-05/
C-MRMP-
C-MRMP-      dimension civec(nwks)
C-MRMP-      dimension eci_sav(nstry)
C-MRMP-      dimension eci(nstry)
C-MRMP-      dimension temp(nstry)
C-MRMP-
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c Copy DMO-based CAS-CI energy to temp
C-MRMP-c
C-MRMP-
C-MRMP-      do i=1,nstry
C-MRMP-        temp(i)=eci(i)
C-MRMP-      end do
C-MRMP-
C-MRMP-c
C-MRMP-c Write parameters to FT scratch file
C-MRMP-c
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c (1) Search the cooresponding states between CASMO CAS-CI states and
C-MRMP-c DMO-based CAS-CI states, and write CI-vector to FT21.
C-MRMP-c This procedure is meaningful only if CAS-CI states are constrained
C-MRMP-c by symmetry but DMOs is not (i.e.ndmosym=1).
C-MRMP-c
C-MRMP-
C-MRMP-
C-MRMP-      do ist=1,nstcas
C-MRMP-        do jst=1,nstry
C-MRMP-          dum=abs(temp(jst)-eci_sav(ist))
C-MRMP-          if (dum.lt.cvgtol) then
C-MRMP-            temp(jst)=zero ! dummy vale
C-MRMP-            nstci=jst
C-MRMP-            go to 10 ! exit loop of jst
C-MRMP-          end if
C-MRMP-        end do
C-MRMP-10      continue
C-MRMP-      end do
C-MRMP-
C-MRMP-
C-MRMP-      icount=0 ! for Debug
C-MRMP-      do ist=1,nstci
C-MRMP-        call rdfuldia(nft12,nwks,civec)
C-MRMP-        if (temp(ist).eq.zero) then
C-MRMP-          icount=icount+1 ! for Debug
C-MRMP-          coef_max=zero
C-MRMP-          do i=1,nwks
C-MRMP-            coef=civec(i)
C-MRMP-            if (abs(coef_max).lt.abs(coef)) coef_max=coef
C-MRMP-          end do
C-MRMP-          coef_max1(icount)=coef_max
C-MRMP-          write(nft21) civec
C-MRMP-        end if
C-MRMP-      end do
C-MRMP-
C-MRMP-      if (icount.ne.nstcas) then
C-MRMP-        write(iw,*) 'Error, Traget CAS-CI states cannot be found.'
C-MRMP-        call abrt
C-MRMP-      end if
C-MRMP-
C-MRMP-c-- total # of DMO-based CAS-CI states
C-MRMP-
C-MRMP-
C-MRMP-c-- kstci_cas=1-->target CAS-CI states. =0---> not
C-MRMP-      do ist=1,nstci
C-MRMP-c!        write(iw,*) 'temp',temp(ist)
C-MRMP-        if (temp(ist).eq.zero) then
C-MRMP-          kstci_cas(ist)=1
C-MRMP-        else
C-MRMP-          kstci_cas(ist)=0
C-MRMP-        end if
C-MRMP-      end do
C-MRMP-
C-MRMP-
C-MRMP-!--- Debug print ----
C-MRMP-c      write(6,*) 'Values in /diabatarget/'
C-MRMP-c      write(6,*)'nstci=',nstci
C-MRMP-c      write(6,*)'nstcas=',nstcas
C-MRMP-c      write(6,*)'nstmq=',nstmq
C-MRMP-c      write(6,*) 'kstci_cas'
C-MRMP-c      do i=1,nstci
C-MRMP-c        write(6,*)kstci_cas(i)
C-MRMP-c      end do
C-MRMP-c      write(6,*) 'kstci_mq'
C-MRMP-c      do i=1,nstci
C-MRMP-c        write(6,*) kstci_mq(i)
C-MRMP-c      end do
C-MRMP-c      write(6,*) 'kstcas_mq'
C-MRMP-c      do i=1,nstcas
C-MRMP-c        write(6,*) kstcas_mq(i)
C-MRMP-c      end do
C-MRMP-c--------------------
C-MRMP-      return
C-MRMP-      end
C-MRMP-C
C-MRMP-C*MODULE DIAB    *DECK DIABMQWR2
C-MRMP-      subroutine diabmqwr2(nstate_mq,nwks,casvec,eigval,diavec)
C-MRMP-
C-MRMP-c
C-MRMP-c This routine is the driver between diabatization procedure
C-MRMP-c and MC-QDPT.
C-MRMP-c Read the information obtained by the previous driver routine
C-MRMP-c diabmqdr from FT scrach file and add information obtained by
C-MRMP-c MC-QDPT calculation. These information is written to FT scrach file
C-MRMP-c
C-MRMP-c If diabatization is not required (i.e. $WFN WFNFLG.ne.16), this
C-MRMP-c program do nothing.
C-MRMP-c
C-MRMP-
C-MRMP-      implicit real*8(a-h,o-z)
C-MRMP-
C-MRMP-      integer wfnflg
C-MRMP-
C-MRMP-      COMMON /IOFILE/ IR,IW,IP,ijk,IJKT,IDAF,NAV,IODA(950)
C-MRMP-c---  common /diatmpfil/nft21,nft22,nft23,nft24
C-MRMP-
C-MRMP-      data zero /0.0d+00/
C-MRMP-      namelist /wfn/wfnflg
C-MRMP-
C-MRMP-      common/diabmqpar1/nstci,nstcas,nstmq,kstci_cas(50),kstci_mq(50),
C-MRMP-     &                  kstcas_mq(50)
C-MRMP-      common/diabmqpar2/coef_max1(20),coef_max2(20),
C-MRMP-     &                  eigvec(400),e_mcqdpt(20)
C-MRMP-
C-MRMP-      dimension casvec(nwks,nstate_mq)!MC-QDPT's CAS-CI vec(QDPT target)
C-MRMP-      dimension eigval(nstate_mq)
C-MRMP-      dimension diavec(nstate_mq,nstate_mq)
C-MRMP-
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c Read namelist -WFN-
C-MRMP-c
C-MRMP-
C-MRMP-      rewind(ir)
C-MRMP-      read(ir,WFN,end=5,err=5)
C-MRMP-5     continue
C-MRMP-
C-MRMP-      if (wfnflg.ne.16) return
C-MRMP-
C-MRMP-
C-MRMP-!--for Debug
C-MRMP-      if (nstmq.ne.nstate_mq) then
C-MRMP-        write(iw,*) 'Error in diabmqwr2'
C-MRMP-        call abrt
C-MRMP-      end if
C-MRMP-!--for Debug
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c Search max CI component of CAS-CI state in MC-QDPT calculation
C-MRMP-c
C-MRMP-
C-MRMP-      do i=1,nstate_mq
C-MRMP-        coef_max=zero
C-MRMP-        do j=1,nwks
C-MRMP-          coef=casvec(j,i)
C-MRMP-          if (abs(coef_max).lt.abs(coef)) then
C-MRMP-            coef_max=coef
C-MRMP-            coef_max2(i)=coef_max
C-MRMP-          end if
C-MRMP-        end do
C-MRMP-      end do
C-MRMP-
C-MRMP-c
C-MRMP-c Set the result values of MC-QDPT calculations
C-MRMP-c
C-MRMP-
C-MRMP-      do i=1,nstate_mq
C-MRMP-        e_mcqdpt(i)=eigval(i)
C-MRMP-      end do
C-MRMP-!--
C-MRMP-      icount=0
C-MRMP-      do i=1,nstate_mq
C-MRMP-        do j=1,nstate_mq
C-MRMP-          icount=icount+1
C-MRMP-          eigvec(icount)=diavec(j,i)
C-MRMP-        end do
C-MRMP-      end do
C-MRMP-
C-MRMP-!--- Debug print ----
C-MRMP-c      write(6,*) 'Values in /diabatarget/'
C-MRMP-c      write(6,*)'nstci=',nstci
C-MRMP-c      write(6,*)'nstcas=',nstcas
C-MRMP-c      write(6,*)'nstmq=',nstmq
C-MRMP-c      write(6,*) 'kstci_cas'
C-MRMP-c      do i=1,nstci
C-MRMP-c        write(6,*)kstci_cas(i)
C-MRMP-c      end do
C-MRMP-c      write(6,*) 'kstci_mq'
C-MRMP-c      do i=1,nstci
C-MRMP-c        write(6,*) kstci_mq(i)
C-MRMP-c      end do
C-MRMP-c      write(6,*) 'kstcas_mq'
C-MRMP-c      do i=1,nstcas
C-MRMP-c        write(6,*) kstcas_mq(i)
C-MRMP-c      end do
C-MRMP-c
C-MRMP-c      do i=1,nstmq
C-MRMP-c        write(6,*) 'coef_max1,2',coef_max1(i),coef_max2(i)
C-MRMP-c      end do
C-MRMP-c
C-MRMP-c      write(6,*) 'Heff eigvec'
C-MRMP-c
C-MRMP-!--------------------
C-MRMP-
C-MRMP-
C-MRMP-
C-MRMP-      return
C-MRMP-      end
C-MRMP-C
C-MRMP-C*MODULE DIAB    *DECK DIABMQDR
C-MRMP-      subroutine diabmqdr
C-MRMP-
C-MRMP-c
C-MRMP-c This routine is the driver between diabatization procedure
C-MRMP-c and MC-QDPT.
C-MRMP-c Read the information from the preliminary CAS-based diabatization
C-MRMP-c from the FT scratch file.
C-MRMP-c Next, check and modify some parameters of the namelist
C-MRMP-c $MCQDPT if necessary.
C-MRMP-c If diabatization is not required (i.e. $WFN WFNFLG.ne.16), this
C-MRMP-c program do nothing.
C-MRMP-c
C-MRMP-
C-MRMP-
C-MRMP-      implicit real*8(a-h,o-z)
C-MRMP-
C-MRMP-      integer wfnflg
C-MRMP-
C-MRMP-      logical kst
C-MRMP-
C-MRMP-      COMMON /IOFILE/ IR,IW,IP,ijk,IJKT,IDAF,NAV,IODA(950)
C-MRMP-c---  common /diatmpfil/nft21,nft22,nft23,nft24
C-MRMP-      common /drtpar/nco,nmcco,nci,msym
C-MRMP-      common /mq2par/dmqpar(200),avecoe(20),
C-MRMP-     &               imqpar(400),maincs(3),lpconf(20),kst(20)
C-MRMP-      parameter (MXDIABACT=30)
C-MRMP-      common /diabat/ ndmosym,nstry,ndfrm,nrcsf,
C-MRMP-     *                alpha_n,alpha_r,alpha_t,
C-MRMP-     *                slctth,moslab_charact(MXDIABACT),
C-MRMP-     *                th_doc,th_vir,conv_th,max_iter,ngrstate
C-MRMP-
C-MRMP-      common/diabmqpar1/nstci,nstcas,nstmq,kstci_cas(50),kstci_mq(50),
C-MRMP-     &                  kstcas_mq(50)
C-MRMP-      common/diabmqpar2/coef_max1(20),coef_max2(20),
C-MRMP-     &                  eigvec(400),e_mcqdpt(20)
C-MRMP-
C-MRMP-
C-MRMP-      namelist /wfn/wfnflg
C-MRMP-
C-MRMP-      dimension temp(20)
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c Read namelist -WFN-
C-MRMP-c
C-MRMP-
C-MRMP-      rewind(ir)
C-MRMP-      read(ir,WFN,end=5,err=5)
C-MRMP-5     continue
C-MRMP-
C-MRMP-      if (wfnflg.ne.16) return
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c Read parameters for diabatization
C-MRMP-c
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c Reset some parameters of namelist -MCQDPT-
C-MRMP-c
C-MRMP-
C-MRMP-c
C-MRMP-c - inorb, iforb -  MOs are read from DA10 (DMOs) and used for MCQDPT
C-MRMP-c
C-MRMP-
C-MRMP-      inorb=0
C-MRMP-      iforb=0
C-MRMP-
C-MRMP-      imqpar(1)=iforb
C-MRMP-      imqpar(3)=inorb
C-MRMP-
C-MRMP-c
C-MRMP-c - arrange # of target states etc.
C-MRMP-c Note: Generally QDPT target states is part of CAS-CI target states
C-MRMP-c       and they are not necessarly equal.
C-MRMP-c       Therefore lofical array 'kst' may be modified.
C-MRMP-c
C-MRMP-
C-MRMP-c-- Save original QDPT target state index (i.e.$MCQDPT 'kstate' input
C-MRMP-c- value)--
C-MRMP-
C-MRMP-      do i=1,imqpar(24)
C-MRMP-        if (kst(i)) then
C-MRMP-          kstcas_mq(i)=1
C-MRMP-        else
C-MRMP-          kstcas_mq(i)=0
C-MRMP-        end if
C-MRMP-      end do
C-MRMP-
C-MRMP-cc--- arrange start ---
C-MRMP-
C-MRMP-c-- case: symmetry is on --
C-MRMP-
C-MRMP-      if (ndmosym.eq.0) then
C-MRMP-        istsym=msym ! set target state symmetry from -NTN- algorithm
C-MRMP-        imqpar(6)=istsym
C-MRMP-        nstci=imqpar(24)
C-MRMP-c        do i=1,nstci
C-MRMP-c          if (kst(i)) then  ! kst(i) is true
C-MRMP-c            kstci_mq(i)=1
C-MRMP-c          else
C-MRMP-c            kstci_mq(i)=0
C-MRMP-c          end if
C-MRMP-c        end do
C-MRMP-c        do i=nstci+1,nstcas
C-MRMP-c          kstci_mq(i)=0
C-MRMP-c        end do
C-MRMP-        do i=1,nstci
C-MRMP-          kstci_mq(i)=kstcas_mq(i)
C-MRMP-        end do
C-MRMP-      end if
C-MRMP-
C-MRMP-
C-MRMP-c-- case: symmetry is off --
C-MRMP-
C-MRMP-      if (ndmosym.ne.0) then
C-MRMP-        istsym=1
C-MRMP-        imqpar(6)=istsym
C-MRMP-        imqpar(24)=nstci
C-MRMP-        icount=0
C-MRMP-        do i=1,nstci
C-MRMP-          if (kstci_cas(i).eq.1) then
C-MRMP-            icount=icount+1
C-MRMP-            if (kst(icount)) then
C-MRMP-              kstci_mq(i)=1
C-MRMP-            else
C-MRMP-              kstci_mq(i)=0
C-MRMP-            end if
C-MRMP-          else
C-MRMP-            kstci_mq(i)=0
C-MRMP-          end if
C-MRMP-        end do
C-MRMP-
C-MRMP-        do i=1,nstci
C-MRMP-          if (kstci_mq(i).eq.0) then
C-MRMP-            kst(i)=.false.
C-MRMP-          else
C-MRMP-            kst(i)=.true.
C-MRMP-          end if
C-MRMP-        end do
C-MRMP-
C-MRMP-      end if
C-MRMP-
C-MRMP-c
C-MRMP-c Set parameter
C-MRMP-c
C-MRMP-
C-MRMP-      nstmq=imqpar(23)
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c CI max coef for CAS-CI is resored for only QDPT-target states
C-MRMP-c
C-MRMP-
C-MRMP-      do i=1,nstcas
C-MRMP-        temp(i)=coef_max1(i)
C-MRMP-      end do
C-MRMP-
C-MRMP-      icount=0
C-MRMP-      do i=1,nstcas
C-MRMP-        if (kstcas_mq(i).ne.0) then
C-MRMP-          icount=icount+1
C-MRMP-          coef_max1(icount)=temp(i)
C-MRMP-        end if
C-MRMP-      end do
C-MRMP-
C-MRMP-
C-MRMP-!---for debug
C-MRMP-      if (icount.ne.nstmq) then
C-MRMP-        write(iw,*) 'Error in diabmqdr. Inconsistent '
C-MRMP-        call abrt
C-MRMP-      end if
C-MRMP-!----
C-MRMP-
C-MRMP-c
C-MRMP-c
C-MRMP-c Warning important message for changing input value etc
C-MRMP-c
C-MRMP-
C-MRMP-      write(iw,*) '********Routine diabmqrd (driver routine) ******'
C-MRMP-      write(iw,*) '                                                  '
C-MRMP-      write(iw,'(''================ Notice ====================''/
C-MRMP-     & ''MC-QDPT calculation is carried out by using ''/
C-MRMP-     & ''Fock orbital for inactive, active, and external orbitals''/
C-MRMP-     & ''that are stored in DA10 #15 at CASSCF step''/
C-MRMP-     & ''==========================================='')')
C-MRMP-      write(iw,*) '                                                  '
C-MRMP-      write(iw,'(''Input parameters iforb and inorb are fixed as ''/
C-MRMP-     &  ''iforb=0, inorb=0'')')
C-MRMP-
C-MRMP-      if (ndmosym.ne.0) then
C-MRMP-        write(iw,*) '                                            '
C-MRMP-        write(iw,'(''=============== Warning ====================''/
C-MRMP-     &  ''The active DMOs have no symmetry, therefore all ''/
C-MRMP-     &  ''calculation of MC-QDPT is carried out without symmetry.''/
C-MRMP-     &  ''To keep the same QDPT target states with the input, ''/
C-MRMP-     &  ''MC-QDPT calculation carried out is equivalent to using''/
C-MRMP-     &  ''the below $MCQDPT parameters.'')')
C-MRMP-        write(iw,*) '------------------------------'
C-MRMP-        write(iw,*) 'istsym=',istsym
C-MRMP-        write(iw,*) 'nstci=',nstci
C-MRMP-        write(iw,*) 'kstate=',(kstci_mq(i),i=1,nstci)
C-MRMP-        write(iw,*) '------------------------------'
C-MRMP-        write(iw,*) '============================================='
C-MRMP-        write(iw,*) '********* End of Routine diabmqrd ***************'
C-MRMP-      end if
C-MRMP-
C-MRMP-
C-MRMP-
C-MRMP-      return
C-MRMP-
C-MRMP-      end
C-MRMP-C
C-MRMP-C*MODULE DIAB    *DECK MKQDPTVEC
C-MRMP-      subroutine mkqdptvec(nft,civec,eigvec,temp,nwks,nst,coef_max1,
C-MRMP-     &                     coef_max2)
C-MRMP-
C-MRMP-      implicit double precision(a-h,o-z)
C-MRMP-
C-MRMP-      dimension civec(nwks,nst)
C-MRMP-      dimension eigvec(nst,nst)
C-MRMP-      dimension temp(nwks)
C-MRMP-      dimension coef_max1(nst) ! max CI coef from HONDO
C-MRMP-      dimension coef_max2(nst) ! max CI coef from MC-QDPT program
C-MRMP-
C-MRMP-      data zero /0.0d+00/
C-MRMP-
C-MRMP-c
C-MRMP-c Take consistencty for total sign of each CI wavefunctions
C-MRMP-c between by the results of two CI programs
C-MRMP-c
C-MRMP-c eigenvector of Heff is updated to the eigenvectors
C-MRMP-c of Hilbert space spaned by the basis set which are -NTN- CAS-CI
C-MRMP-c wavefunctions, not MC-QDPT program's CAS-CI.
C-MRMP-c
C-MRMP-
C-MRMP-
C-MRMP-      do i=1,nst
C-MRMP-        if (coef_max1(i)*coef_max2(i).lt.zero) then
C-MRMP-          do j=1,nst
C-MRMP-            eigvec(i,j)=-eigvec(i,j)
C-MRMP-          end do
C-MRMP-        end if
C-MRMP-      end do
C-MRMP-
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c Calculate new CI vectors of projected MC-QDPT wavefunctions
C-MRMP-c
C-MRMP-
C-MRMP-      do i=1,nst
C-MRMP-        do j=1,nwks
C-MRMP-          temp(j)=zero  ! zero clear
C-MRMP-        end do
C-MRMP-        do j=1,nst
C-MRMP-          do k=1,nwks
C-MRMP-            temp(k)=temp(k)+eigvec(j,i)*civec(k,j)
C-MRMP-          end do
C-MRMP-        end do
C-MRMP-! CI vector of i-th projected MCQDPT wavefunction
C-MRMP-        write(nft) temp
C-MRMP-      end do
C-MRMP-
C-MRMP-
C-MRMP-      return
C-MRMP-      end
C-MRMP-C
C-MRMP-C*MODULE DIAB    *DECK REFDIAMQ
C-MRMP-      subroutine refdiamq(list_csf,list_group,dcicoef,
C-MRMP-     &           nlist,nstmq,nstci,kstci_mq,coef_max_ref,
C-MRMP-     &           e_mcqdpt,eigvec)
C-MRMP-
C-MRMP-      IMPLICIT double precision(a-h,o-z)
C-MRMP-c      PARAMETER (MXIODA=255)
C-MRMP-c      PARAMETER (NUMMX=3072)
C-MRMP-c      PARAMETER (MAXCI=50)
C-MRMP-
C-MRMP-      parameter (maxlist=64)
C-MRMP-
C-MRMP-      parameter (MXDIABACT=30)
C-MRMP-      common /diabat/ ndmosym,nstry,ndfrm,nrcsf,
C-MRMP-     *                alpha_n,alpha_r,alpha_t,
C-MRMP-     *                slctth,moslab_charact(MXDIABACT),
C-MRMP-     *                th_doc,th_vir,conv_th,max_iter,ngrstate
C-MRMP-
C-MRMP-c      COMMON/ MCPRT/CIPRT,MOPRT,PRTSPN
C-MRMP-c      COMMON/ENRGCI/EN,EC,ECI(MAXCI),NSTATE
C-MRMP-      COMMON /IOFILE/ IR,IW,IP,ijk,IJKT,IDAF,NAV,IODA(950)
C-MRMP-c      COMMON/ MCPAR/NFZC,NCORBS,NCI,NORBS,NORB,NUM,NWKS
C-MRMP-c      COMMON/INFOA/NAT,ICH,MUL,NBF,NX,NE
C-MRMP-      COMMON/SCM/X(1)
C-MRMP-      common/diatmpfil/nft21,nft22,nft23,nft24
C-MRMP-
C-MRMP-      DATA NFT11  /11/
C-MRMP-      DATA NFT12  /12/
C-MRMP-c      data nft21  /21/
C-MRMP-c      DATA PT5    /0.5D+00/
C-MRMP-      DATA ZERO   /0.0D+00/
C-MRMP-c      DATA NDIAG  /0/
C-MRMP-c      DATA MXXPAN /50/
C-MRMP-c      DATA MAXDIA /512/
C-MRMP-c      DATA CVGTOL /1.0D-05/
C-MRMP-c      DATA NWORD  /0/
C-MRMP-
C-MRMP-
C-MRMP-      dimension list_csf(maxlist)
C-MRMP-      dimension list_group(maxlist)
C-MRMP-      dimension dcicoef(maxlist,nstmq)
C-MRMP-      dimension eigvec(nstmq,nstmq)
C-MRMP-      dimension e_mcqdpt(nstmq)
C-MRMP-      dimension coef_max(nstmq)
C-MRMP-      dimension coef_max_ref(nstmq)
C-MRMP-      dimension kstci_mq(nstci)
C-MRMP-
C-MRMP-c
C-MRMP-c list_csf(i).... i-th dominant CSF inex
C-MRMP-c list_group(i)...Group index where i-th dominant CSF belongs to
C-MRMP-c nlist.... total # of dominant CSFs.
C-MRMP-c --->If list_csf,list_group, and nlist are already defined by $REFCSF,
C-MRMP-c     they are input and not changed. If not, this routine makes list
C-MRMP-c     and return. In the latter case, users should understand that
C-MRMP-c     the return is only for dominant CSFs based on DMO set.
C-MRMP-c     i.e, not always enough dominant CSFs for global nuclear coordinate
C-MRMP-c     region.
C-MRMP-c dcicoef(i,j)...CI coefficent of j-th adiabatic state of i-th
C-MRMP-c                      dominant CSF
C-MRMP-c nstmq... total # of QDPT target adiabatic states for diabatization
C-MRMP-c    as input.(not necessally equal to total # of CAS-CI target state)
C-MRMP-c
C-MRMP-
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c Read header of FT11 (DRT file) and FT12 (CI vectors)
C-MRMP-c
C-MRMP-
C-MRMP-      REWIND NFT11
C-MRMP-      READ(NFT11) NORBMX,IDUM,IDUM,IDUM,NROWS
C-MRMP-
C-MRMP-      REWIND NFT12
C-MRMP-      READ(NFT12) NSTATE,NWKS
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c Search (suitable) QDPT (i.e. diabatization) target states
C-MRMP-c
C-MRMP-
C-MRMP-      write(iw,*) 'QDPT target states are picked up'
C-MRMP-
C-MRMP-      icount=0
C-MRMP-      do i=1,nstci
C-MRMP-        if (kstci_mq(i).ne.0) then
C-MRMP-          icount=icount+1
C-MRMP-        end if
C-MRMP-      end do
C-MRMP-      if (icount.ne.nstmq) then
C-MRMP-        write(iw,*) 'Error. QDPT target states can not be identified'
C-MRMP-        call abrt
C-MRMP-      end if
C-MRMP-
C-MRMP-c
C-MRMP-c Read CAS-CI vectors and make MC-QDPT projected CI vectors
C-MRMP-c
C-MRMP-c
C-MRMP-
C-MRMP-
C-MRMP-
C-MRMP-cc Get core memory
C-MRMP-
C-MRMP-
C-MRMP-      K10 = 1
C-MRMP-      K20 = K10 + NORBMX
C-MRMP-      K30 = K20 + NORBMX
C-MRMP-      K40 = K30 + NORBMX
C-MRMP-      K50 = K40 + NROWS*4
C-MRMP-      K60 = K50 + NWKS
C-MRMP-      K70 = K60 + NORBMX
C-MRMP-      k80 = k70 +nwks*nstmq
C-MRMP-      need=k80
C-MRMP-
C-MRMP-      call cmem(loadcm)
C-MRMP-      call setc(need)
C-MRMP-
C-MRMP-cc Pick up target CI vectors from FT12 and write to FT21
C-MRMP-
C-MRMP-      icount=1
C-MRMP-      do i=1,nstci
C-MRMP-c!        call diardci(nft12,nwks,x(k50))
C-MRMP-        call rdfuldia(nft12,nwks,x(k50))
C-MRMP-        if (kstci_mq(i).ne.0) then ! this CI root is QDPT target state
C-MRMP-c!          call diawtci(nft21,nwks,x(k50))
C-MRMP-          call wtfuldia(nft21,nwks,x(k50))
C-MRMP-!-- search max CI coef and store all states to memory
C-MRMP-          jshift1=k50-1
C-MRMP-          jshift2=k70-1+(icount-1)*nwks
C-MRMP-          dum=zero
C-MRMP-          do j=1,nwks
C-MRMP-            coef=x(j+jshift1)
C-MRMP-            x(j+jshift2)=coef
C-MRMP-            if (abs(dum).lt.abs(coef)) dum=coef
C-MRMP-          end do
C-MRMP-!---
C-MRMP-          coef_max(icount)=dum
C-MRMP-          icount=icount+1
C-MRMP-        end if
C-MRMP-        if (nstmq.lt.icount) go to 100
C-MRMP-      end do
C-MRMP-100   continue
C-MRMP-
C-MRMP-c
C-MRMP-c Calculate  CI vectors of MC-QDPT projected wavefunction
C-MRMP-c
C-MRMP-
C-MRMP-      rewind(nft21)
C-MRMP-      call mkqdptvec(nft21,x(k70),eigvec,x(k50),nwks,nstmq,coef_max,
C-MRMP-     &               coef_max_ref)
C-MRMP-
C-MRMP-
C-MRMP-c
C-MRMP-c Print -MC-QDPT- Coefficient using DMOs and get list of domain CSFs
C-MRMP-c for only QDPT target states
C-MRMP-c
C-MRMP-
C-MRMP-      write(iw,'(''=============== Notice ========================''/
C-MRMP-     &           '' Adiabatic state # and energies are QDPT target ''/
C-MRMP-     &           '' state # and MC-QDPT energies.''/
C-MRMP-     &           ''================================================'')')
C-MRMP-      write(iw,'(''------------------------------------------------''/
C-MRMP-     &           ''CSF Expansion based on using DMOs As Active Orbs''/
C-MRMP-     &           ''------------------------------------------------'')')
C-MRMP-c
C-MRMP-      idummy=0   ! need to freshen this up...
C-MRMP-      dummy=0.0d+00
C-MRMP-      call prmcdia(nrcsf,NFT11,NFT12,nft21,nstmq,NWKS,
C-MRMP-     1  e_mcqdpt,X(K50),slctth,X(K10),X(K20),X(K30),X(K60),X(K40),
C-MRMP-     2  list_csf,list_group,dcicoef,dummy,idummy,nlist,
C-MRMP-     3  NORBMX,4*NROWS,NROWS,MAXLIST,idummy)
C-MRMP-
C-MRMP-      write(iw,'(''----------------------------------------------''/
C-MRMP-     &           '' CI coefficients of dominant CSFs for all Groups''/
C-MRMP-     &           ''----------------------------------------------'')')
C-MRMP-
C-MRMP-      do i=1,nstmq
C-MRMP-        write(iw,'('' Adiabatic State #'',i5,'' ENERGY ='',f18.9,/
C-MRMP-     &        '' ------------------    ----------------''/
C-MRMP-     &        ''       <CSF>   <Group #>  <Coefficient>'')')
C-MRMP-     &        i,e_mcqdpt(i)
C-MRMP-        do j=1,nlist
C-MRMP-          write(iw,'(2x,i8,4x,i2,f12.6)') list_csf(j),list_group(j),
C-MRMP-     &                              dcicoef(j,i)
C-MRMP-        end do
C-MRMP-      end do
C-MRMP-
C-MRMP-      write(iw,*) '---------------------------'
C-MRMP-
C-MRMP-cc Reset core memory
C-MRMP-
C-MRMP-      call cmem(ngotcm)
C-MRMP-      if (ngotcm.ne.loadcm) call setc(loadcm)
C-MRMP-
C-MRMP-
C-MRMP-
C-MRMP-      return
C-MRMP-
C-MRMP-
C-MRMP-      end
C                ----------dummies to fake HONDO -----------
C-MRMP-      subroutine rdfuldia(nft,L1,w)
C-MRMP-      implicit double precision(a-h,o-z)
C-MRMP-      dimension w(L1)
C-MRMP-      read(nft) w
C-MRMP-      return
C-MRMP-      end
C-MRMP-
C-MRMP-      subroutine wtfuldia(nft,L1,w)
C-MRMP-      implicit double precision(a-h,o-z)
C-MRMP-      dimension w(L1)
C-MRMP-      write(nft) w
C-MRMP-      return
C-MRMP-      end
C-MRMP-      subroutine gugdrt
C-MRMP-      write(6,*) 'death in gugdrt'
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine srtgug
C-MRMP-      write(6,*) 'death in srtgug'
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine prevls(a,b,i,j,k,l)
C-MRMP-      double precision a,b
C-MRMP-      write(6,*) 'death in prevls', a+b+i+j+k+l
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine trfint
C-MRMP-      write(6,*) 'death in trfint'
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine rewfil(lu)
C-MRMP-      write(6,*) 'death in rewfil',lu
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine arrange_dm(a,b,i,j,k,l)
C-MRMP-      double precision a,b
C-MRMP-      write(6,*) 'death in arrange_dm: use simpler -READTDM-'
C-MRMP-      write(6,*)  a+b+i+j+k+l
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine rartrn(i)
C-MRMP-      write(6,*) 'death in rartrn', i
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine dmrdci
C-MRMP-      write(6,*) 'death in dmrdci'
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine dmdrt
C-MRMP-      write(6,*) 'death in dmdrt'
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine diajac(A,V,D,N,NDIM,T)
C-MRMP-      double precision a,v,d,t
C-MRMP-      DIMENSION A(NDIM,NDIM),V(NDIM,NDIM),D(NDIM),T(NDIM,2)
C-MRMP-c     call JACDG(A,VEC,EIG,JBIG,BIG,LDVEC,N)
C-MRMP-c     DIMENSION A(*),VEC(LDVEC,N),EIG(N),JBIG(N),BIG(N)
C-MRMP-      write(6,*) 'death in diajac'
C-MRMP-      d(1) = 12.0d+00
C-MRMP-      v(1,1) = 15.0d+00
C-MRMP-      t(1,1) = 17.0d+00
C-MRMP-      write(6,*) a(1,1)+n+ndim
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine daopen(i,a,j,k)
C-MRMP-      double precision a
C-MRMP-      write(6,*) 'death in daopen',i+a+j+k
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine prtr(a,i)
C-MRMP-      double precision a
C-MRMP-      write(6,*) 'death in prtr',a+i
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine dgdiag
C-MRMP-      write(6,*) 'death in dgdiag'
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine dgwtci(i,j,k,a,b)
C-MRMP-      double precision a,b
C-MRMP-      write(6,*) 'death in dgwtci', i+j+k+a+b
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine dgprci
C-MRMP-      write(6,*) 'death in dgprci'
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine fiflsh(i)
C-MRMP-      write(6,*) 'death in fiflsh', i
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine daclos(i,j,k)
C-MRMP-      write(6,*) 'death in daclos',i+j+k
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine dartrn(i)
C-MRMP-      write(6,*) 'death in dartrn',i
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine dvdson
C-MRMP-      write(6,*) 'death in dvdson'
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine dvdsnc
C-MRMP-      write(6,*) 'death in dvdsnc'
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine gugadgmod(a,i)
C-MRMP-      double precision a
C-MRMP-      write(6,*) 'death in gugadgmod',i+a
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine dgrdci(i,j,k,a,b)
C-MRMP-      double precision a,b
C-MRMP-      write(6,*) 'death in dgrdci',i+j+k+a+b
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine trfmcxfake
C-MRMP-      write(6,*) 'death in trfmcxfake'
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine cmem(i)
C-MRMP-      write(6,*) 'death in cmem'
C-MRMP-      i=12
C-MRMP-      stop
C-MRMP-      end
C-MRMP-      subroutine loccm(a)
C-MRMP-      write(6,*) 'death in loccm',a
C-MRMP-      stop
C-MRMP-      end
      END
