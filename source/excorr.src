C 26 Apr 12 - LBR - add file cleanup for mpqc disk files
C  7 Mar 12 - MWS - align DETWFN common
C  2 Mar 12 - LBR - ADD PT2R12 BSIE CORRECTION
C                     COMPUTE REAL SPIN-FREE 2PDM
C                     GENERATE INPUTS FOR MPQC
C
!*MODULE EXCORR  *DECK R12_F_NAME
      SUBROUTINE R12_F_NAME(FNAME,FILENM2)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      CHARACTER*(*) FNAME,FILENM2
      CHARACTER*256 FILENM
      CHARACTER*3 FILNUM
      CHARACTER*1 NULL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL

! GENERATE UNIQUE FILES NAMES FOR META DATA : GOOD FOR PES SCANS.
!         write geometry counter with leading 0's into FILNUM
!         DO NOT CHANGE THE CASE ON THE FILENAME EXTENSION.
      WRITE(FILNUM,FMT='(I3.3)') NEVALS
      FILENM=' '
      IF (MASWRK) CALL GMS_GETENV(FNAME,FILENM)
!
      NULL = CHAR(0)
      DO 101 KOL=1,256
         IF(FILENM(KOL:KOL).EQ.' '  .OR.
     *      FILENM(KOL:KOL).EQ.NULL) GO TO 102
  101 CONTINUE
      KOL=257
  102 CONTINUE
      KOL=KOL-1
! append file number to filename
      FILENM2=FILENM(1:KOL)//'.'//FILNUM
!         
      RETURN
      END
!------------------------------------------------------------------------
!========================================================================
!------------------------------------------------------------------------
!*MODULE EXCORR  *DECK GET_PT2R12_INFO
C> @BRIEF      THIS ROUTINE SETS UP MPQC INTERFACE
C> 
C> @AUTHOR     LUKE ROSKOP
C>             -2012
C> 
C> @DETAILS    CALL MPQC AND POPULATE ARGV,ARGC
C> 
C> @PARAM NFRZCR12 number of frozen core orbitals
C> @PARAM NINACTR12 number of inactive orbitals
C> @PARAM NACTR12 number or active orbitals
C> @PARAM NFRZVR12 number of frozen valence orbitals
C> @PARAM NCORR_R12 do r12 correlation correction
C> @PARAM DFBS used density fitting
C> @PARAM RUNR12 direct call from gamess to MPQC
C> @PARAM singls perform singles correction
C> @PARAM nthrds number of threads to spawn in MPQC
C> @PARAM f12exp f12 exponent in gemincal function
C> @PARAM set_r12_exp flag to indicate if f12exp is set in input
C>
      SUBROUTINE GET_PT2R12_INFO(NFRZCR12,NINACTR12,NACTR12,NFRZVR12,
     $     NCORR_R12,DFBS,RUNR12,SINGLS,NTHRDS,F12EXP,SET_R12_EXP)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK,DSKSAV,DFBS,RUNR12,SINGLS,
     $     SET_F12_EXP

      PARAMETER (MXATM=2000, MXRT=100, MAXA=103, MAXL=7)

      COMMON /BASISC/ GBASIS,AEX(MAXA,MAXL),ABASIS(MAXA,MAXL),
     *                IAGAUS(MAXA,MAXL),IRDBAS
      COMMON /IOFILE/ IR,IW,IP,IS,IJKT,IDAF,NAV,IODA(950)
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,S,SZ,
     *                GRPDET,STSYMPRINT,GLIST,DWPARM,
     *                NFLGDM(MXRT),IWTS(MXRT),NCORSV,NCOR,NACT,NORB,
     *                NA1,NB1,K,KST,IROOT,IPURES,MAXW1,NITER,MAXP,NCI,
     *                IGPDET,KSTSYM,NFTGCI,IDWEIGH
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      CHARACTER*120 BASISINFO
      CHARACTER*256 FILENM2
      CHARACTER*1 NULL
      DATA C2H/8HC2H     /

      DATA BASACD,BASACT,BASACQ/8HACCD    ,8HACCT    ,8HACCQ    /
      DATA BASAC5,BASAC6/8HACC5    ,8HACC6    /

      CHARACTER*256 BASIS_NAME

!// CURRENTLY: THIS ROUNTINE IS CALLED FROM ORMAS.SRC (ORDET)
!
      DSKSAV=DSKWRK
      DSKWRK=.FALSE.
!
!// MEMORY FOR ORBITALS AND SYMMETRY INFO
!
      L2 = NUM*NUM
      CALL VALFM(LOADFM)
      MO_MEM = LOADFM +1
      ISYM_MEM = MO_MEM + L2 + 1
      LAST = ISYM_MEM + NQMT +1
      NEED = LAST - LOADFM 
      CALL GETFM(NEED)
!
!// ORBITAL SYMMETRIES AND LCAO COEFFICIENTS
      CALL DAREAD(IDAF,IODA,X(MO_MEM),L2,15,0)
      CALL DAREAD(IDAF,IODA,X(ISYM_MEM),NQMT,262,1)
!
      IF(MASWRK)CALL R12_F_NAME('R12INP',FILENM2)
      NULL = CHAR(0)
      DO 101 KOL=1,256
         IF(FILENM2(KOL:KOL).EQ.' '  .OR.
     *      FILENM2(KOL:KOL).EQ.NULL) GO TO 102
  101 CONTINUE
      KOL=257
  102 CONTINUE
      KOL=KOL-1
!
      IF(MASWRK)THEN
         OPEN(UNIT=99,FILE=FILENM2(1:KOL)//'.input.pt2r12.dat',
     $        STATUS='UNKNOWN')
!// WRITE COORDINATES TO FILE 'PT2INT'
      DO I = 1,NAT
         WRITE(99,'(F5.1,3E36.25)')ZAN(I),(C(J,I), J=1,3)
      ENDDO
      WRITE(99,'(F5.1,3F36.25)')-1.,-1.,-1.,-1.
      WRITE(99,'(A8)')GRPDET    !POINT GROUP
!// MUST APPEND THE FOLLOWING IRREP INFO FOR C2H POINT GROUP
      if(GRPDET.EQ.C2H)WRITE(99,'(A11)')'Ag Bg Bu Au'
      WRITE(99,'(I2)')-1        !DELIMITER

!// APPEND BASIS SET FROM FILE PT2BAS TO FILE 'PT2INT'
      CALL SEQOPN(98,'PT2BAS', 'UNKNOWN',.TRUE.,'FORMATTED')
 8080 CONTINUE 
      READ(98,'(a120)',END=8090)BASISINFO
      WRITE(99,'(a120)')BASISINFO
      GOTO 8080
 8090 CONTINUE 

!// APPEND NUMBER OF ORBITALS TO FILE 'PT2INT'
      WRITE(99,'(I6)')NQMT   !TOTAL NUMBER OF VARIATIONAL MOS

!// APPEND LCAO COEFFICIENTS TO FILE 'PT2INT'
      DO I = 1,NQMT
         DO J = 1,NUM
            ISHIFT = (I-1)*NUM +J
            WRITE(99,'(2I6,4X,E36.25)')J,I,X(MO_MEM +ISHIFT-1)
         ENDDO
      ENDDO
      WRITE(99,'(2I6,4X,E36.25)')-1,-1,-1. !DELIMITER

!// APPEND ORBITAL SYMMETRIES TO FILE 'PT2INT'
      CALL ORB_SYM_WRITER(X(ISYM_MEM),NQMT)

!// APPEND SOME MORE INFO TO 'PT2R12'
      WRITE(99,'(I6)')NFRZCR12  ! NUMBER OF FROZEN CORE ORBITALS
      WRITE(99,'(I6)')NINACTR12 ! NUMBER OF CORE ORBITALS THAT ARE NOT FROZEN
      WRITE(99,'(I6)')NACTR12   ! NUMBER OF ACTIVE ORBITALS
      WRITE(99,'(I6)')NCORR_R12 ! NUMBER OF ORBITALS TO BE CORRELATED
      WRITE(99,'(I6)')NFRZVR12  ! NUMBER OF FROZEN VALENCE ORITALS
      WRITE(99,'(I2)')-1        !DELIMITER
!
      REWIND(98)
      CALL SEQCLO(98,'KEEP')
      CLOSE(99,STATUS='KEEP')
      ENDIF                     !IF(MASWRK)
!

!// RETURN MEMORY
      CALL RETFM(NEED)

!// job name and determine name length
      IF(MASWRK)CALL R12_F_NAME('GMSJOBNAME',FILENM2)
      NULL = CHAR(0)
      DO 201 KOL=1,256
         IF(FILENM2(KOL:KOL).EQ.' '  .OR.
     *      FILENM2(KOL:KOL).EQ.NULL) GO TO 202
  201 CONTINUE
      KOL=257
  202 CONTINUE
      KOL=KOL-1

c$$$         CALL SYSINP(MEMORY,MEMDDI)                    
c$$$         write(6,*)MEMORY                              

      if(MASWRK)then
         if(RUNR12.or.SINGLS)then
!// fortran hides arguement length...
!// determined the name of the disk files needed by MPQC
            call add_arg('-prefix')
            call add_arg(FILENM2(1:KOL)//'.input')
         
!// determine the formal basis set name (needed by MPQC)
!// (DO NOT CHANGE CASE IN BASIS SET ASSIGNMENT)
!// for now it is prescribed to use only aug-cc-pVXZ basis sets    
            basis_name = ' '
            if(GBASIS.eq.BASACD)basis_name='aug-cc-pVDZ'
            if(GBASIS.eq.BASACT)basis_name='aug-cc-pVTZ'
            if(GBASIS.eq.BASACQ)basis_name='aug-cc-pVQZ'
            if(GBASIS.eq.BASAC5)basis_name='aug-cc-pV5Z'
            if(GBASIS.eq.BASAC6)basis_name='aug-cc-pV6Z'
            call add_arg('-obs')
            call add_arg(basis_name)                          
            
!// use density fitting
            call add_arg('-dfbs')
            if(DFBS)then
               call add_arg(' ')
            else
               call add_arg('none')
            endif
            
!// compute [2]_r12 with mpqc interface
            call add_arg('-r12')
            if(RUNR12)then
!               call add_arg('true')
!            else
               call add_arg('false')
            endif
            
!// compute [2]_s with MPQC interface
            call add_arg('-singles')
            if(SINGLS)then
               call add_arg('true')
            else
               call add_arg('false')
            endif
         
!// indicate the number of threads desired
            write(basisinfo,'(I3)')nthrds
            call add_arg('-threadgrp')
            call add_arg('<PthreadThreadGrp>:(num_threads='//basisinfo//
     $           ')')


!// F12 exponent
            if(set_f12_exp)then
               write(basisinfo,'(F6.4)')f12exp
               call add_arg('-f12exp')
               call add_arg(basisinfo)
            endif
!// call MPQC interface
            call pt2r12_main()

     
!// delete MPQC interface files
            OPEN(UNIT=99,FILE=FILENM2(1:KOL)//'.input.pt2r12.dat',
     $           STATUS='UNKNOWN')
            CLOSE(99,STATUS='DELETE')

            OPEN(UNIT=99,FILE=FILENM2(1:KOL)//'.input.pt2r12.rdm2.dat',
     $           STATUS='UNKNOWN')
            CLOSE(99,STATUS='DELETE')
!
         endif
!     
      endif
!     
      DSKWRK = DSKSAV
!
      RETURN
      END
!------------------------------------------------------------------------
!========================================================================
!------------------------------------------------------------------------
!*MODULE EXCORR  *DECK ORB_SYM_WRITER
      SUBROUTINE ORB_SYM_WRITER(IOB,NQMT)
      IMPLICIT NONE
      INTEGER IOB(*),NQMT,I
      WRITE(99,'(1000I2)') (IOB(I),I=1,NQMT)
      RETURN
      END
!------------------------------------------------------------------------
!========================================================================
!------------------------------------------------------------------------
!*MODULE EXCORR  *DECK GET_EXCORR_INPUT
C> @BRIEF      THIS ROUTINE GET R12 PARAMETERS
C> 
C> @AUTHOR     LUKE ROSKOP
C>             -2012
C> 
C> @DETAILS    GATHER R12 PARAMETERS FROM INPUT
C> 
C> @PARAM TO_OUTPUT PRINT FLAG
C> @PARAM R12CORR INDICATES WHETHER R12 INPUTS ARE ASKED FOR
C> @PARAM NFRZC_R12 NUMBER OF FROZEN CORE ORBITALS
C> @PARAM NINACT_R12 NUMBER OF INACTIVE ORBITALS
C> @PARAM NACT_R12 NUMBER OR ACTIVE ORBITALS
C> @PARAM NFRZV_R12 NUMBER OF FROZEN VALENCE ORBITALS
C> @PARAM NCORR_R12 DO R12 CORRELATION CORRECTION
C> @PARAM DFBS USED DENSITY FITTING
C> @PARAM RUNR12 DIRECT CALL FROM GAMESS TO MPQC
C> @PARAM SINGLS PERFORM SINGLES CORRECTION
C> @PARAM NTHRDS NUMBER OF THREADS TO SPAWN IN MPQC
C> @PARAM F12EXP F12 EXPONENT IN GEMINCAL FUNCTION
C> @PARAM SET_R12_EXP FLAG TO INDICATE IF F12EXP IS SET IN INPUT
C> @PARAM PUNTOL 2-PDM PUNCH TO DISK TOLERANCE
C>
      SUBROUTINE GET_EXCORR_INPUT(TO_OUTPUT,R12CORR,NFRZC_R12,
     $     NINACT_R12,NACT_R12,NFRZV_R12,PUNTOL,NCORR_R12,
     $     DFBS,RUNR12,SINGLS,NTHRDS,F12EXP,SET_F12_EXP)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXRT=100)
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,S,SZ,
     *                GRPDET,STSYMPRINT,GLIST,DWPARM,
     *                NFLGDM(MXRT),IWTS(MXRT),NCORSV,NCOR,NACT,NORB,
     *                NA1,NB1,K,KST,IROOT,IPURES,MAXW1,NITER,MAXP,NCI,
     *                IGPDET,KSTSYM,NFTGCI,IDWEIGH
      COMMON /IOFILE/ IR,IW,IP,IS,IJKT,IDAF,NAV,IODA(950)
      LOGICAL PT2R12,TO_OUTPUT,CCR12,R12CORR,RUNR12,SINGLS,DFBS,
     $     SET_F12_EXP

      PARAMETER (NNAM=13)
      DIMENSION QNAM(NNAM),KQNAM(NNAM)
      DATA QNAM/8HPT2R12  ,8HNFRZV   ,8HNFRZC   ,8HNINACT  ,8HNACT    ,
     $          8HNCORR   ,8HPUNTOL  ,8HCCR12   ,8HDFBS    ,8HRUNR12  ,
     $          8HSINGLS  ,8HNTHRDS  ,8HF12EXP  /

      DATA KQNAM/0,1,1,1,1,
     $           1,3,0,0,0,
     $           0,1,3/

      DATA EXCORR/8HEXCORR  /
!
      PT2R12 = .FALSE.
      CCR12 = .FALSE.
      R12CORR=.FALSE.
      NFRZC = NCORSV
      NINACT  = 0
      NACT  = NACT
      NFRZV = 0
      NCORR = NACT
      PUNTOL = 1.00D-11
      DFBS = .FALSE.
      RUNR12 = .FALSE.
      SINGLS = .FALSE.
      NTHRDS = 1
      F12EXP = 0.0D+00
      SET_F12_EXP = .FALSE.
!
      CALL NAMEIO(IR,JRET,EXCORR,NNAM,QNAM,KQNAM,
     $     PT2R12,NFRZV,NFRZC,NINACT,NACT,
     $     NCORR,PUNTOL,CCR12,DFBS,RUNR12,
     $     SINGLS,NTHRDS,F12EXP,0,    0,0,0,0,0,    0,0,0,0,0,
     $     0,0,0,0,0,    0,0,0,0,0,    0,0,0,0,0,    0,0,0,0,0,
     $     0,0,0,0,0,    0,0,0,0,0,    0,0,0,0,0,    0,0,0,0,0)
      IF(PT2R12.AND.JRET.NE.0)THEN
         WRITE(6,'("ERROR IN $EXCORR INPUT GROUP")')
         CALL ABRT
      ENDIF 
!
      IF(.NOT.PT2R12)RETURN
!
      NFRZC_R12 = NFRZC
      NINACT_R12 = NINACT
      NACT_R12 = NACT
      NCORR_R12 =  NCORR
      NFRZV_R12 = NFRZV

      IF(PT2R12)R12CORR=.TRUE.
      IF(CCR12)R12CORR=.TRUE.
      IF(F12EXP.GT.1.0D-6)SET_F12_EXP = .TRUE.
      IF(PT2R12.AND.TO_OUTPUT)THEN
         if(RUNR12)THEN
            WRITE(6,1000)RUNR12,SINGLS

            IF(SET_F12_EXP)THEN
               WRITE(6,1010)F12EXP
            ELSE
               WRITE(6,1020)'RECOMMENDED VALUE'
            ENDIF

            WRITE(6,1030)DFBS,NTHRDS,NFRZC_R12,
     $           NINACT_R12, NACT_R12,NFRZV_R12,NCORR_R12,PUNTOL
         ELSE
            WRITE(6,1050)RUNR12,SINGLS,NFRZC_R12,
     $           NINACT_R12, NACT_R12,NFRZV_R12,NCORR_R12,PUNTOL
         ENDIF
      ELSEIF(CCR12.AND.TO_OUTPUT)THEN
         WRITE(6,1100)NFRZC_R12,NINACT_R12,NACT_R12,NFRZV_R12,NCORR_R12,
     $        PUNTOL
      ENDIF  
!     
      RETURN
!
 1000 FORMAT(/5X,60(1H-)/
     $     15X,'CREATING INPUTS FOR MPQC PT2R12 CORRECTION',/
     $     5X,60(1H-)/
     $     /8X,16(1H-),X,'PT2R12 SPECIFICATION',X,16(1H-)/
     $    12X, 'COMPUTE [2]_R12 WITH MPQC INTERFACE:',L8/
     $    12X, 'COMPUTE [2]_S WITH MPQC INTERFACE:  ',L8)
 1010 FORMAT(12X,'F12 EXPONENT:                       ',F8.4)
 1020 FORMAT(12X,'F12 EXPONENT:                    ',A17)
 1030 FORMAT(12X,'USE DENSITY FITTING:                ',L8/
     $      12X, 'NUMBER OF THREADS:                  ',2X,I6/    
     $      12X, 'NUMBER OF FROZEN CORE ORBITALS:     ',2X,I6/
     $      12X, 'NUMBER OF INACTIVE ORBITALS:        ',2X,I6/
     $      12X, 'NUMBER OF ACTIVE ORBITALS:          ',2X,I6/
     $      12X, 'NUMBER OF FROZEN VIRTUAL ORBITALS:  ',2X,I6/
     $      12X, 'TOTAL ORBITALS TO BE CORRELATED:    ',2X,I6//
     $      12X, 'TWO-RDM PUNCH TOLERANCE:            ',2X,D8.2/
     $       8X,54(1H-))
 1050 FORMAT(/5X,60(1H-)/
     $     15X,'CREATING INPUTS FOR MPQC PT2R12 CORRECTION',/
     $     5X,60(1H-)/
     $     /8X,16(1H-),X,'PT2R12 SPECIFICATION',X,16(1H-)/
     $    12X, 'COMPUTE [2]_R12 WITH MPQC INTERFACE:',L8/
     $    12X, 'COMPUTE [2]_S WITH MPQC INTERFACE:  ',L8/
     $    12X, 'NUMBER OF FROZEN CORE ORBITALS:     ',2X,I6/
     $    12X, 'NUMBER OF INACTIVE ORBITALS:        ',2X,I6/
     $    12X, 'NUMBER OF ACTIVE ORBITALS:          ',2X,I6/
     $    12X, 'NUMBER OF FROZEN VIRTUAL ORBITALS:  ',2X,I6/
     $    12X, 'TOTAL ORBITALS TO BE CORRELATED:    ',2X,I6//
     $    12X, 'TWO-RDM PUNCH TOLERANCE:            ',2X,D8.2/
     $     8X,54(1H-))
 1100  FORMAT(/5X,60(1H-)/
     $     12X,'CREATING INPUTS FOR MPQC CCSD(T)-R12 CORRECTION',/
     $     5X,60(1H-)/
     $     /8X,13(1H-),X,'CCSD(T)-R12 SPECIFICATION',X,14(1H-)/
     $    12X, 'NUMBER OF FROZEN CORE ORBITALS:     ',X,I6/
     $    12X, 'NUMBER OF INACTIVE ORBITALS:        ',X,I6/
     $    12X, 'NUMBER OF ACTIVE ORBITALS:          ',X,I6/
     $    12X, 'NUMBER OF FROZEN VIRTUAL ORBITALS:  ',X,I6/
     $    12X, 'TOTAL ORBITALS TO BE CORRELATED:    ',X,I6//
     $    12X, 'T1 AND T2 PUNCH TOLERANCE:          ',2X,D8.2/
     $     8X,54(1H-))
      END
!------------------------------------------------------------------------
!========================================================================
!------------------------------------------------------------------------
!*MODULE EXCORR  *DECK MAKE_PT2R12_2RDM
C> @BRIEF      THIS ROUTINE SET UP CREATION FOR TWO-PARICLE DENSITY MATRIX.
C> 
C> @AUTHOR     LUKE ROSKOP
C>             -2012
C> 
C> @DETAILS    MEMORY AND TABLES ARE CREATED FOR CREATION OF SPIN-FREE DM
C> 
C> @DATE 2/11/13-LUKE ROSKOP
C> -MODIFIED MEMORY MANAGAMENT FOR DISTRIBUTED DM MATRIX
C> @DATE 2/26/13-LUKE ROSKOP
C> -MODIFIED MEMORY MANAGAMENT FOR DISTRIBUTED DM MATRIX
C>
      SUBROUTINE MAKE_PT2R12_2RDM(RDM2TOL)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL SOME,GOPARR,DSKWRK,MASWRK,FDIRCT,QCORR,CEECHK
      PARAMETER (MXRT=100)
      COMMON /CEEIS3/ NEEDCI, CEECHK
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,S,SZ,
     *                GRPDET,STSYM,GLIST,DWPARM,
     *                NFLGDM(MXRT),IWTS(MXRT),NCORSV,NCOR,NACT,NORB,
     *                NA,NB,K,KST,IROOT,IPURES,MAXW1,NITER,MAXP,NCI,
     *                IGPDET,KSTSYM,NFTGCI,IDWEIGH
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIM(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IS,IJKT,IDAF,NAV,IODA(950)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP !temp
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      DATA CHECK/8HCHECK   /
      DATA CIDET /8HCIDET   /
      DATA ORMAS /8HORMAS   /

!        ----- READ INPUT DEFINING THE FULL CLASS CI DIMENSIONS -----

      CALL FCINPUT(-5,CIDET,ORMAS)
!
!     ----- DRIVER FOR FULL CLASS CI COMPUTATION -----
!
      SOME = MASWRK  .AND.  NPRINT.NE.-5
      IF(SOME) WRITE(IW,9000) RDM2TOL
 9000 FORMAT(//1X,'WRITING TWO PARTICLE DENSITY FILE FOR -PT2R12-',
     *            ' PROGRAM'/
     *         1X,'RDM2TOL=',1P,E15.5)
!
      NTOT = NACT + NCORSV
      NTCO = NCORSV
      NORB = NACT
      NCOR = 0
      NSYM = 2**IGPDET
!
!  MODIFY MSTA TO GET RID OF CORE.
!
      DO II=1,NSPACE+1
         MSTA(II) = MSTA(II) - NCORSV
      ENDDO
!
!        COMPUTE THE TOTAL NUMBER OF DETERMINANTS IN THIS FULL CLASS CI.
!        DECIDE NECESSARY DOUBLE/INTEGER WORKING STORAGE -IDS- AND -IIS-
!
!     FIRST NEED TO STORE NSPACE SETS OF BINOMIAL COEFFICIENTS FOR EACH
!     SUB-SPACE.  THERE IS REASON BEHIND THIS, TRUST ME.  JUST ASK ME.
!     LBST(I) WILL STORE WHERE IN X BINOMIAL ARRAYS FOR SPACE I START.
!     IDIM(I) WILL STORE THE MAXIMUM NUMBER OF ALPHA OR BETA ELECTRONS.
!
!
      CALL VALFM(LOADFM)
      LBST(1)  = LOADFM + 1
      DO II=2,NSPACE
         IDIM(II-1) = MAX(IAMA(II-1),IBMA(II-1))
         LBST(II) = LBST(II-1)+((MNUM(II-1)+1)*(IDIM(II-1)+1))
      ENDDO
      IDIM(NSPACE) = MAX(IAMA(NSPACE),IBMA(NSPACE))
      LAST = LBST(NSPACE)+((MNUM(NSPACE)+1)*(IDIM(NSPACE)+1))
      NEED1 = LAST - LOADFM - 1
      CALL GETFM(NEED1)
!
      DO II=1,NSPACE
         CALL BINOM8(X(LBST(II)),MNUM(II),IDIM(II))
      ENDDO
!
!     NOW TO MAKE TABLES FOR THE ORMAS PROBLEM.
!     MAKE MEMORY AVAILABLE FOR TABLE INFO AND
!     TABLES THEMSELVES.
!
      CALL VALFM(LOADFM)
      LBOX1 = LOADFM + 1
      LBOX2 = LBOX1 + NSPACE/NWDVAR + 1
      LBOX3 = LBOX2 + NSPACE/NWDVAR + 1
      LBOX4 = LBOX3 + NSPACE/NWDVAR + 1
      LBOX5 = LBOX4 + NSPACE/NWDVAR + 1
      LIBO = LBOX5 + NSPACE/NWDVAR + 1
      LAST = LIBO + NTOT/NWDVAR + 1
      NEED2 = LAST - LOADFM - 1
      CALL GETFM(NEED2)
!
!    READ ORBITALS LABELS AND GET RID OF THE CORE PART.
!
      CALL DAREAD(IDAF,IODA,X(LIBO),NTOT,262,1)
      CALL CORTRA(X(LIBO),NTOT,NTCO)
!
!    WORK OUT HOW MANY ALPHA AND BETA GROUPS THERE ARE.
!
      CALL TOTALCO(X(LBOX1),NSPACE,NA,IAMA,IAMI,X(LBOX2),ITGA)
      CALL TOTALCO(X(LBOX1),NSPACE,NB,IBMA,IBMI,X(LBOX2),ITGB)
!
!    DETERMINE THE TOTAL NUMBER OF ALPHA AND BETA STRINGS.
!
      CALL RESETCO(X(LBOX1),NSPACE,NA,IAMA,IAMI,X(LBOX2))
      IAST = 0
      DO II=1,ITGA
      CALL TOTDETG(X(LBOX1),NSPACE,LBST,X(LBST(1)),NEED1,
     *    MNUM,IDIM,ITOT)
      IAST = IAST + ITOT
      CALL PUSHCO(X(LBOX1),NSPACE,NA,IAMA,IAMI,X(LBOX2),IEND)
      ENDDO
!
      CALL RESETCO(X(LBOX1),NSPACE,NB,IBMA,IBMI,X(LBOX2))
      IBST = 0
      DO II=1,ITGB
      CALL TOTDETG(X(LBOX1),NSPACE,LBST,X(LBST(1)),NEED1,
     *    MNUM,IDIM,ITOT)
      IBST = IBST + ITOT
      CALL PUSHCO(X(LBOX1),NSPACE,NB,IBMA,IBMI,X(LBOX2),IEND)
      ENDDO
!
!    MAKE STORAGE TO HOLD SYMMETRY INFORMATION OF STRINGS.
!    THE LABELS BELOW APPEAR THE SAME IN ROUTINE MAKTABS
!    AND THIS ROUTINE ALSO EXPLAINS WHAT THEY ARE USED FOR.
!
      CALL VALFM(LOADFM)
      LWRK   = LOADFM + 1
      LCOA   = LWRK   + 43/NWDVAR + 1
      LCOB   = LCOA   + (NSYM*ITGA)/NWDVAR + 1
      LGMUL  = LCOB   + (NSYM*ITGB)/NWDVAR + 1
      LKTAB  = LGMUL  + (NSYM*NSYM)/NWDVAR + 1
      LCON   = LKTAB  + NSYM/NWDVAR + 1
      LCON1  = LCON   + NA/NWDVAR + 1
      LCON2  = LCON1  + NA/NWDVAR + 1
      LCON3  = LCON2  + NA/NWDVAR + 1
      LANDET = LCON3  + NA/NWDVAR + 1
      LBNDET = LANDET + (ITGA*NSPACE)/NWDVAR + 1
      NAST   = LBNDET + (ITGB*NSPACE)/NWDVAR + 1
      NBST   = NAST   + (ITGA+1)/NWDVAR + 1
      LSYMA  = NBST   + (ITGB+1)/NWDVAR + 1
      LSYMB  = LSYMA  + IAST/NWDVAR + 1
      LGCOM  = LSYMB  + IBST/NWDVAR + 1
      LSPA   = LGCOM  + (ITGA*ITGB)/NWDVAR + 1
      LSPB   = LSPA   + IAST/NWDVAR + 1
      LDISB  = LSPB   + IBST/NWDVAR + 1
      LSAS   = LDISB  + (NSYM*ITGB*ITGA)/NWDVAR + 1
      LSBS   = LSAS   + ((NSYM+1)*ITGA)/NWDVAR + 1
      LSAC   = LSBS   + ((NSYM+1)*ITGB)/NWDVAR + 1
      LSBC   = LSAC   + IAST/NWDVAR + 1
      LAST   = LSBC   + IBST/NWDVAR + 1
      NEED3 = LAST - LOADFM - 1

      CALL GETFM(NEED3)
!
!    MAKE INTEGER TABLES FOR ORMAS. GET NUMBER OF DETS, ETC.
!
      IF (SOME) CALL TSECND(E0)
!
      CALL MAKTABS(IW,.FALSE.,X(LBOX1),X(LBOX2),X(LBOX3),NSPACE,
     *             NA,NB,LBST,X(LBST(1)),NEED1,
     *             IAMA,IAMI,IBMA,IBMI,MNUM,IDIM,MSTA,
     *             X(LIBO),IGPDET,KSTSYM,NSYM,
     *             NACT,X(LWRK),X(LKTAB),X(LGMUL),
     *             X(LCON),X(LCOA),X(LCOB),X(LANDET),X(LBNDET),
     *             X(NAST),X(NBST),X(LSYMA),X(LSYMB),X(LGCOM),
     *             MINI,MAXI,X(LSPA),X(LSPB),X(LDISB),
     *             X(LSAS),X(LSBS),X(LSAC),X(LSBC),
     *             ITGA,ITGB,IAST,IBST,NCI,NA1EX,NB1EX,FDIRCT)
!
!   FOR DISTRIBTED DM2 DETERMINE: HOW MUCH MEMORY TO ALLOCATE/PROCESS.
!     MAX NUMBER OF NXN VECTORS ON MY PROCESS [FROM DM2(N,N,:,:)].
      MEM_VEC = (NACT**2/NPROC)
      IF(MOD(NACT**2,NPROC).NE.0)MEM_VEC = MEM_VEC +1 !IF NACT**2 DOES NOT DIVIDE EVENLY
!     MEMORY NEEDED TO STORE MY PROCESSES DM2 VECTORS.      
      MEM_DM2 = MEM_VEC*NACT**2 

!   FOR DISTRIBUTED DM2 STORAGE SEE EXAMPLE BELOW.
!      IF THERE ARE 2 ORBITALS AND 2 PROCESSES THEN 
!          PROCESS 0: STORES DM2(1,1,:,:) AND DM2(1,2,:,:) (VECTORS 1,2)
!          PROCESS 1: STORES DM2(2,1,:,:) AND DM2(2,2,:,:) (VECTORS 3,4)
!             -EACH VECTOR IS OF LENGTH NACT*NACT
!      MY_DM2 INDICATES WHETHER THE PROCESS CONTAINS THE PARTICULAR DM2 VECTORS
!          MY_DM2(I,J) = 1 [CONTAINS DM2 VECTOR (I,J)]      
!          MY_DM2(I,J) = 0 [DOES NOT CONTAIN DM2 VECTOR (I,J)]      
!          PROCESS 0: MY_DM2(1,1)=1 MY_DM2(1,2)=1 MY_DM2(2,1)=0 MY_DM2(2,2)=0
!          PROCESS 1: MY_DM2(1,1)=0 MY_DM2(1,2)=0 MY_DM2(2,1)=1 MY_DM2(2,2)=1

      CALL VALFM(LOADFM)
      KCOEFF = LOADFM +1
      ID_FDM2   = KCOEFF + KST*NCI
      MY_DM2 = ID_FDM2 + (MEM_DM2+1) + 1 
      LAST   = MY_DM2 + NACT**2 +1
!
!   ORMAS INTEGER STORAGE IS LAST.
!
      IPOSA  = LAST
      IPERA  = IPOSA  + (NA*(NACT-NA)*NSYM)/NWDVAR + 1
      IIND1  = IPERA  + (NA*(NACT-NA)*NSYM)/NWDVAR + 1
      IGROA  = IIND1  + (NA*(NACT-NA)*NSYM)/NWDVAR + 1
      INDEX  = IGROA  + (NA*(NACT-NA)*NSYM)/NWDVAR + 1
      IMMC   = INDEX  + ((NACT*(NACT+1))/2+1)/NWDVAR + 1
      IHMCON = IMMC + NSYM
!
!  LEAVE SPACE FOR THE SINGLE EXCITED STORAGE.
!  NOTE, IF FDIRCT = .TRUE. THEN NB1EX = ITGA.
!
      JB1GR = IHMCON + K
      JB1PE = JB1GR + NB1EX/NWDVAR + 1
      JB1IN = JB1PE + NB1EX/NWDVAR + 1
      JB1O1 = JB1IN + NB1EX/NWDVAR + 1
      JB1O2 = JB1O1 + NB1EX/NWDVAR + 1
      IND1O1 = JB1O2 + NB1EX/NWDVAR +1
      IND1O2 =  IND1O1 + (NA*(NACT-NA))*NSYM/NWDVAR +1
!      IFDM2  = IND1O2  + (NA*(NACT-NA))*NSYM/NWDVAR +1
!      JB1PO = IFDM2  + NACT**4 + 1
      JB1PO = IND1O2  + (NA*(NACT-NA))*NSYM/NWDVAR +1
      JB1SY = JB1PO + NB1EX/NWDVAR + 1
      JB1ST = JB1SY + (NB*(NACT-NB))/NWDVAR + 1

!
      IF (.NOT.FDIRCT) THEN
         LAST   = JB1ST + ((IBST+1)*(NSYM+1))/NWDVAR + 1
         IBST2 = (IBST+1)*(NSYM+1)
      ELSE
         LAST = JB1ST + 1
         NB1EX = ITGA
         IBST2 =  1
      ENDIF
!
      NEED4  = LAST - LOADFM - 1
      NEEDCI = NEED1 + NEED2 + NEED3 + NEED4
!
      CALL GETFM(NEED4)
      IF(SOME) WRITE(6,1010)(NEED1+NEED2+NEED3+NEED4)
 1010 FORMAT(/10X,'MEMORY REQUIRED FOR SPIN-FREE DENSITY (WORDS)',
     $     I12)
!
      IF(EXETYP.EQ.CHECK)THEN
         CALL RETFM(NEED4)
         CALL RETFM(NEED3)
         CALL RETFM(NEED2)
         CALL RETFM(NEED1)
         RETURN
      ENDIF
!
!        ----- COMPUTE FULL CLASS CI WAVEFUNCTION -----
!
      CALL GET_CIVECT_TABLES(IW,SOME,NACT,NCI,NA,NB,KST,MAXP,
     $     X(LBST(1)),NEED1,NSYM,X(LBOX1),X(LBOX2),X(LBOX3),X(LBOX4),
     $     X(KCOEFF),X(INDEX),X(LCON),X(LCON1),X(LCON2),X(LBNDET),
     $     X(NBST),X(LSYMB),X(LSPB),ITGB,IBST,NB1EX,IBST2,
     $     X(JB1GR),X(JB1PE),X(JB1IN),X(JB1PO),X(JB1ST),X(JB1SY),
     $     X(JB1O1),X(JB1O2))
!
!  DETERMINE IF STATE AVERAGED 1E- AND 2E- DENSITY MATRICES REQUESTED
!
      IF (.NOT.FDIRCT) THEN
         IDIM1 = NSYM+1
         IDIM2 = IBST+1
      ELSE
         IDIM1 = 1
         IDIM2 = 1
      ENDIF
C
      NPRI6 = NPRINT

c$$$!////////////testing//////////
c$$$!////////////testing//////////
c$$$!////////////testing//////////
c$$$!for testing purposes below....
c$$$      M1 = NACT
c$$$      M2 = (M1*M1+M1)/2
c$$$      M4 = (M2*M2+M2)/2
c$$$      L0 = NQMT
c$$$      L1 = NUM
c$$$      L2 = (L1*L1+L1)/2
c$$$      L3 = L1*L1
c$$$C   INTEGRAL STORAGE REQUIREMENTS FIRST.
c$$$      CALL VALFM(LOADFM)
c$$$      LSINT1   = LOADFM   + 1
c$$$      LSINT2   = LSINT1   + M2
c$$$      LIA      = LSINT2   + M4
c$$$      LXX      = LIA      + M2/NWDVAR + 1
c$$$      LIXX     = LXX      + NINTMX
c$$$      last = lixx + NINTMX
c$$$      NEED10  = LAST - LOADFM - 1
c$$$      write(6,*)need10
c$$$      CALL GETFM(NEED10)
c$$$!!!below is for parallel read                                       
c$$$      CALL SEQREW(IJKT)
c$$$      CALL SQREAD(IJKT,X(LSINT1),k2)
c$$$      mp1 = nact + ncore
c$$$      mp2 = (mp1*(mp1+1))/2
c$$$      mp4 = (mp2*(mp2+1))/2
c$$$      if(.not.goparr)then
c$$$         call m1eghr(ijkt,x(lsint2),x(lxx),x(lixx),x(lia),nintmx,
c$$$     *        m1,0)
c$$$      else
c$$$         call rdoooo(x(lsint2),0,m1,m4,x(lxx))
c$$$      endif
c$$$!for testing purposes.end.....
c$$$      !remember the core part of the dm2 is absent, so energy will not work correctly!!!
c$$$!////////////testing//////////
c$$$!////////////testing//////////
c$$$!////////////testing//////////
      

      CALL SPINFREE_2RDM(IW,NPRI6,IWTS,WSTATE,SPINS,IPURES,S,K,
     *     NACT,NCI,NA,NB,
     *     X(KCOEFF),
     *     X(LBST(1)),NEED1,
     *     X(INDEX),NSYM,X(LIBO),
     *     X(LBOX1),X(LBOX2),X(LBOX3),X(LBOX4),X(LBOX5),
     *     X(LGMUL),X(LKTAB),
     *     X(LCON),X(LCON1),X(LCON2),X(LCON3),
     *     X(LANDET),X(LBNDET),X(NAST),X(NBST),
     *     X(LSYMA),X(LSYMB),X(LGCOM),X(LSPA),X(LSPB),
     *     X(LDISB),X(LSAS),X(LSBS),X(LSAC),X(LSBC),
     *     ITGA,ITGB,IAST,IBST,
     *     X(IPOSA),X(IPERA),X(IIND1),X(IGROA),X(IMMC),
     *     NB1EX,
     *     X(JB1GR),X(JB1PE),X(JB1IN),X(JB1PO),X(JB1ST),
     *     IDIM1,IDIM2,
!     *     X(JB1O1),X(JB1O2),X(IND1O1),X(IND1O2),X(IFDM2),
     *     X(JB1O1),X(JB1O2),X(IND1O1),X(IND1O2),x(id_fdm2),
     *     RDM2TOL,x(MY_DM2))

c$$$!////////////testing//////////
c$$$!////////////testing//////////
c$$$!////////////testing//////////
c$$$
c$$$
c$$$      call retfm(need10)
c$$$!////////////testing//////////
c$$$!////////////testing//////////
c$$$!////////////testing//////////
c$$$!     
      CALL RETFM(NEED4)
      CALL RETFM(NEED3)
      CALL RETFM(NEED2)
      CALL RETFM(NEED1)

! RESET MSTA

      DO II=1,NSPACE+1
         MSTA(II) = MSTA(II) + NCORSV
      ENDDO

      RETURN
      END
!------------------------------------------------------------------------
!========================================================================
!------------------------------------------------------------------------
!*MODULE EXCORR  *DECK SPINFREE_2RDM
C> @BRIEF      THIS ROUTINE CREATES A SPIN-FREE TWO-PARTICLE DENSITY MATRIX
C> 
C> @AUTHOR     LUKE ROSKOP
C>             -2012
C> 
C> @DETAILS    THIS ROUTINE CREATES A SPIN-FREE TWO-PARTICLE DENSITY MATRIX
C> 
C> @DATE 2/11/13-LUKE ROSKOP
C> -DISTRIBUTED THE DENSITY MATRIX ACCROSS NODES. NO LONGER PARALLEL ROUNTINE.
C> @DATE 2/26/13-LUKE ROSKOP
C> -PARITAL RESTORATION OF PARALLELISM
C>
C> @PARAM D_FDM2 DISTRIBUTED DENSITY MATRIX CHUNK
C> @PARAM MY_DM2 ARRAY THAT INDICATES WHICH CHUNK OF DM2 MY PROCESS STORES
      SUBROUTINE SPINFREE_2RDM(IW,NPRINT,IWTS,WSTATE,SPINS,IPURES,S,K,
     *     NACT,NCI,NA,NB,AB,
     *     Y,NX,INDEX,NSYM,IOB,
     *     LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,
     *     LGMUL,KTAB,IACON1,IACON2,IBCON1,IBCON2,
     *     LANDET,LBNDET,NAST,NBST,LSYMA,LSYMB,LGCOM,
     *     LSPA,LSPB,LDISB,LSAS,LSBS,LSAC,LSBC,
     *     ITGA,ITGB,IAST,IBST,
     *     IPOSA,IPERA,IIND1,IGROA,IMMC,
     *     NB1EX,JB1GR,JB1PE,JB1IN,JB1PO,JB1ST,IDIM1,IDIM2,
!     *     JB1O1,JB1O2,IIND1O1,IIND1O2,FDM2,RDM2TOL)
     *     JB1O1,JB1O2,IIND1O1,IIND1O2,D_FDM2,RDM2TOL,MY_DM2) !USE THIS ONE FOR DISTRIBUTED DM2
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
!
      LOGICAL SOME,GOPARR,DSKWRK,MASWRK,FDIRCT,QCORR,DSKSAV
!
      PARAMETER (MXRT=100, MXATM=2000)
      PARAMETER (ZERO=0.0D+00)
!
      COMMON /CIFILS/ NFT11,NFT12,NFT13,NFT14,NFT15,NFT16,IDAF20,NEMEMX
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,STOT,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIM(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /FUNCT / E,EGRAD(3,MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
!
      DIMENSION IWTS(MXRT),WSTATE(MXRT),SPINS(MXRT)
      DIMENSION AB(NCI,K),Y(NX)
      DIMENSION INDEX((NACT*(NACT+1))/2+1),IOB(NACT)
      DIMENSION LBOX1(NSPACE),LBOX2(NSPACE),LBOX3(NSPACE)
      DIMENSION LBOX4(NSPACE),LBOX5(NSPACE)
      DIMENSION LGMUL(NSYM,NSYM),KTAB(NSYM)
      DIMENSION IACON1(NA),IACON2(NA),IBCON1(NA),IBCON2(NA)
      DIMENSION LANDET(NSPACE,ITGA),LBNDET(NSPACE,ITGB)
      DIMENSION NAST(ITGA+1),NBST(ITGB+1)
      DIMENSION LSYMA(IAST),LSYMB(IBST),LGCOM(ITGB,ITGA)
      DIMENSION LSPA(IAST),LSPB(IBST),LDISB(NSYM,ITGB,ITGA)
      DIMENSION LSAS(NSYM+1,ITGA),LSBS(NSYM+1,ITGB)
      DIMENSION LSAC(IAST),LSBC(IBST)
      DIMENSION IPOSA(NA*(NACT-NA),NSYM)
      DIMENSION IPERA(NA*(NACT-NA),NSYM)
      DIMENSION IGROA(NA*(NACT-NA),NSYM)
      DIMENSION IMMC(NSYM)
      DIMENSION JB1GR(NB1EX),JB1PE(NB1EX),JB1IN(NB1EX),JB1PO(NB1EX)
      DIMENSION JB1ST(IDIM1,IDIM2)

!      DOUBLE PRECISION FDM2(NACT,NACT,NACT,NACT)

      INTEGER JB1O1(NB1EX),JB1O2(NB1EX)
      INTEGER IIND1O1(NA*(NACT-NA),NSYM),IIND1O2(NA*(NACT-NA),NSYM)
      CHARACTER*256 FILENM2
      CHARACTER*1 NULL

!// VARIABLES FOR DISTRIBUTED DENSITY MATRIX
      DOUBLE PRECISION D_FDM2(*) !((NACT**4)/NPROC)+1
      INTEGER MIN_R,MAX_R,N1,N2,N3,N4,IPROC,IBIG_BLOCK,ISMALL_BLOCK,
     $     IOFFSET,BLOCK_SIZE,MIN_VEC,MAX_VEC,MY_DM2(NACT,*)

!// PLEASE NOTE FOR DEBUGGING PURPOSES: 
!//    THE 2-PDM OVER ONLY THE ACTIVE ORBTIALS IS COMPUTED.
!//    SO IF YOU ARE TRYING TO COMPUTED A 2-PARTICLE ENERGY, YOU WILL
!//    HAVE TO SET NCORE=0 IN THE INPUT.
!//         I.E. 2-PARTICLE_ENERGY = 2-PDM(:,:,:,:)*SI2(:)

!// INITAILIZE VARIABLES THAT ARE USED TO INDEX D_FDM2 ARRAY

      N1 = NACT                 !NACT    :OFFSET FOR HYPERCUBE INDEX 2
      N2 = N1*NACT              !NACT**2 :OFFSET FOR HYPERCUBE INDEX 3
      N3 = N2*NACT              !NACT**3 :OFFSET FOR HYPERCUBE INDEX 4
      N4 = N3*NACT

      IF(MOD(N4,NPROC).EQ.0)THEN

         IBIG_BLOCK   = (N4)/NPROC
         ISMALL_BLOCK = IBIG_BLOCK
         
         MIN_R = ME*IBIG_BLOCK  !MINIMUM OF RANGE FOR PROCESS ME
         MAX_R = MIN_R +IBIG_BLOCK-1 !MAXIMUM OF RANGE FOR PROCESS ME
         
         MIN_VEC = (ME)*N2/NPROC +1
         MAX_VEC = (ME+1)*N2/NPROC

      ELSE                      !(MOD(N4,NPROC).EQ.0)

         IBIG_BLOCK    = ((N2/NPROC) +1)*(N2)
         ISMALL_BLOCK  = ((N2/NPROC)   )*(N2)

         IF(ME.LT.(MOD(N4,NPROC)))THEN
            
            MIN_R = ME*IBIG_BLOCK !MINIMUM OF RANGE FOR PROCESS ME
            MAX_R = MIN_R + IBIG_BLOCK-1 !MAXIMUM OF RANGE FOR PROCESS ME
            
            MIN_VEC = (ME)*(N2/NPROC) +1 +ME
            MAX_VEC = (ME+1)*(N2/NPROC)+1 +ME
            
         ELSE                   !(ME.LT.(MOD(N4,NPROC))
            
            IOFFSET = IBIG_BLOCK*MOD(N4,NPROC)
            MIN_R = IOFFSET + (ME-(MOD(N4,NPROC)))*ISMALL_BLOCK
            MAX_R = MIN_R + ISMALL_BLOCK-1
            IOFFSET = MOD(N2,NPROC)
            MIN_VEC = IOFFSET + (ME)*(N2/NPROC)+1 
            MAX_VEC = IOFFSET + (ME+1)*(N2/NPROC) 
            
         ENDIF                  !(ME.LT.(MOD(N4,NPROC))
         
      ENDIF                     !(MOD(N4,NPROC).EQ.0)

      BLOCK_SIZE = MAX_R-MIN_R+1

!// INITIALIZE D_FDM2
      CALL VCLR(D_FDM2,1,BLOCK_SIZE)
      DO I = 1,NACT
         DO J =1,NACT
            MY_DM2(I,J) = 0
            IJ_INDEX = (I-1)*NACT+J
            IF(IJ_INDEX.GE.MIN_VEC.AND.IJ_INDEX.LE.MAX_VEC)MY_DM2(I,J)=1
         ENDDO
      ENDDO
!LUKEBR
C$$$! INITIALIZE FDM2...
C$$$      DO I = 1,NACT
C$$$         DO II = 1,NACT
C$$$            DO III = 1,NACT
C$$$               DO IV = 1,NACT
C$$$                  FDM2(I,II,III,IV) = 0.0D+00
C$$$               ENDDO
C$$$            ENDDO
C$$$         ENDDO
C$$$      ENDDO

!
!  ----  STATE-AVERAGED 2E- DENSITY MATRIX  ----
!
      SOME = MASWRK  .AND.  NPRINT.NE.-5
!
      MXSTAT=0
      MXNZW=0
!
      DO 100 I=MXRT,1,-1
         IF(WSTATE(I).GT.ZERO) THEN
            IF(MXSTAT.EQ.0) MXSTAT=I
            MXNZW=MXNZW+1
         END IF
  100 CONTINUE
!
      IF(MXSTAT.EQ.0) THEN
         IF(SOME) THEN
          WRITE(IW,*) 'OOPS, IN -MASDM2-, SOMETHING HAPPENED TO WSTATE'
         END IF
         CALL ABRT
      END IF
!
!
!        SET STATE AVERAGED ENERGY, PRINT ROOT INFORMATION
!
      E = ZERO
      NXTR=0
      DO 310 IST=1,K
         IF(IPURES.EQ.1  .AND.  ABS(SPINS(IST)-S).GT.0.03D+00) GO TO 310
         NXTR=NXTR+1
         IF(WSTATE(NXTR).GT.ZERO) THEN
            E = E + WSTATE(NXTR) * ESTATE(IST)
            IF(SOME) WRITE(IW,9340) IST,ESTATE(IST),
     *                              WSTATE(NXTR),SPINS(IST)
         END IF
         IF(NXTR.GT.MXSTAT) GO TO 320
  310 CONTINUE
!
!        CROAK THE JOB IF WE DIDN'T CALCULATE ENOUGH ROOTS WITH THE
!        DESIRED SPIN MULTIPLICITY DURING THE CI DIAGONALIZATION.
!        IF THIS HAPPENS ON THE 1ST MCSCF ITER, WE'VE ALREADY GOT
!        THE CI EXPANSIONS PRINTED OUT, AND SHOULD NOT REPEAT IT.
!
      IF(NXTR.LT.MXSTAT) THEN
         IF(MASWRK) WRITE(IW,9350) NXTR,S,MXSTAT
         IF(MASWRK  .AND.  .NOT.SOME) CALL ORMPRT(IW,NFT12,MASWRK)
         IF(GOPARR) CALL DDI_SYNC(9205)
         CALL ABRT
      END IF
!
  320 CONTINUE
!
!  COPY CI COEFFICIENTS FOR ALL STATES WITH NON-ZERO WEIGHTS INTO AB
!
      NXTW=1
      NXTR=0
      DO 620 IST=1,K
         IF (IPURES.EQ.1) THEN
            IF (ABS(SPINS(IST)-S).GT.0.03D+00) GO TO 620
            NXTR=NXTR+1
         ELSE
            NXTR=IST
         ENDIF
!
         IF (NXTR.EQ.IWTS(NXTW)) THEN
!$$$            CALL CICOPY(CI(1,IST),AB(1,NXTW),NCI)
            CALL CICOPY(AB(1,IST),AB(1,NXTW),NCI)
            NXTW = NXTW + 1
         ENDIF
  620 CONTINUE
      NXTW = NXTW - 1
!
!  ---------  NOW TO DETERMINE STATE AVERAGED DENSITY MATRICES ---------
!
!  --- BIG LOOP OVER ALL ALPHA STRINGS. ---
!

!//DISABLE      IF (GOPARR) THEN
!//DISABLE         CALL DDI_DLBRESET()
!//DISABLE         CALL DDI_DLBNEXT(MY_TASK)
!//DISABLE      ENDIF
!
      CALL RESETCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX5)

      DO 5000 IGA=1,ITGA
!
         CALL RESETDE(LBOX1,NSPACE,NA,MSTA,IACON1)
!
!  KKA GIVES THE ACTUAL POSITION OF THE ALPHA STRING IACON1 IN
!  THE FULL ALPHA STRING LIST.
!
         DO 4900 KKA=NAST(IGA)+1,NAST(IGA+1)
!//DISABLE            IF (GOPARR.AND.KKA-1.NE.MY_TASK) GOTO 4899
            JPZA1 = LSPA(KKA)
            JASYM = LSYMA(KKA)
            KSYM=KTAB(JASYM)
            DO II=1,NSYM
               IMMC(II)=0
            ENDDO
!
            DO II=1,NSPACE
               LBOX2(II) = LBOX1(II)
            ENDDO
!
!  LOOP OVER SPACES TO EXCITE ELECTRON FROM.
!
            IEAS = NA+1
            DO 4890 ISPA1=NSPACE,1,-1
               IOC1 = LBOX1(ISPA1)
               IEAE = IEAS - 1
               IEAS = IEAS - IOC1
               IF (IOC1.EQ.0) GO TO 4890
               LBOX2(ISPA1) = LBOX2(ISPA1)-1
!
!  LOOP ELECTRONS IN SPACE ISPA1.
!  IEAS, IEAE ARE THE ELECTRONS IN SPACE ISPA1.
!
               DO 4885 IA1=IEAE,IEAS,-1
                  IO1 = IACON1(IA1)
                  IGAE = IEAE - LBOX1(ISPA1)
                  IS1 = IOB(IO1)
!
!  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
!
               DO 4880 ISPA2=ISPA1,NSPACE
!
!  IGAS, IGAE ARE ELECTRONS SPECIFYING ISPA2 SPACE ELECTRON LIMITS.
!
                  IGAS = IGAE + 1
                  IGAE = IGAE + LBOX1(ISPA2)
!
                  LBOX2(ISPA2) = LBOX2(ISPA2) + 1
                  IF (LBOX2(ISPA1).LT.IAMI(ISPA1)) GO TO 4870
!
!  MAKE GAP INFORMATION HERE.
!
                  IGAA = MAX(IA1+1,IGAS)
                  IF (LBOX1(ISPA2).EQ.0) THEN
                     ISTA = MSTA(ISPA2)
                     IEND = MSTA(ISPA2+1)-1
                  ELSEIF (ISPA2.EQ.ISPA1) THEN
                     ISTA = IO1+1
                     IEND = IACON1(IGAA)-1
                     IF (IA1.EQ.IEAE) IEND=MSTA(ISPA1+1)-1
                  ELSE
                     ISTA = MSTA(ISPA2)
                     IEND = IACON1(IGAA)-1
                  ENDIF
!
!  LOOP OVER GAPS
!

                  DO 4860 IGAP=IGAA,IGAE+1
!
                     DO 4850 JJ=ISTA,IEND
                        IS2 = IOB(JJ)
                        IP1 = LGMUL(IS1,IS2)
!
                     IND = INDEX(JJ) + IO1
!
              CALL REDE00(IACON1,IACON2,NA,IA1,IGAP-1,JJ,JPERA)
              IF (LBOX2(ISPA2).GT.IAMA(ISPA2)) GO TO 4800
!
!  GET GROUP NUMBER
!
           CALL POSITCO(LBOX5,NSPACE,NA,IAMA,IAMI,LBOX4,LBOX2,IGA2)
           NIAS = NAST(IGA2)
!
              CALL IDPOST(IACON2,NA,LBOX2,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LANDET(1,IGA2),IBCON1,JPOSA)
              KAPOS = JPOSA + NIAS
              JPZA2 = LSPA(KAPOS)
              KASYM = LSYMA(KAPOS)
              KPER1 = ((-1)**JPERA)*2
              IMMC(KASYM) = IMMC(KASYM) + 1
              JSPO = IMMC(KASYM)
              IPOSA(JSPO,KASYM) = JPZA2
              IPERA(JSPO,KASYM) = KPER1
!              IIND1(JSPO,KASYM) = IND
              IGROA(JSPO,KASYM) = IGA2
!
              IIND1O1(JSPO,KASYM) = IO1
              IIND1O2(JSPO,KASYM) = JJ
!
!   IF DEOCCUPIED AND NEWLY OCCUPIED ORBITALS ARE OF DIFFERENT SYMMETRY,
!   SKIP TO DOUBLES.
!
              IF (IS1.NE.IS2) GO TO 4800
!
!   DETERMINE THE ALPHA STRING CONTRIBUTION TO THE MATRIX ELEMENT.
!
              DO 4712 IK=1,NA
                 IF (IK.EQ.IA1) GO TO 4712
                 ION = IACON1(IK)
!
!  LOOP OVER APPROPRIATE BETA DETS AND UPDATE THE 1E DM2
!

C$$$       DO 1705 IGB=1,ITGB
C$$$         IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB,IGA2).NE.1) GOTO 1705
C$$$         JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
C$$$         JCI2 = JPZA2 + LDISB(KSYM,IGB,IGA2)
!     
C$$$         DO 1685 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
C$$$            JCI1 = JCI1 + 1
C$$$            JCI2 = JCI2 + 1
C$$$            F_FC = 0.0D+00
C$$$            DO KKI=1,NXTW
C$$$               F_FC = F_FC+ WSTATE(IWTS(KKI))*AB(JCI1,KKI)*AB(JCI2,KKI)
C$$$            ENDDO
C$$$!                 F_FC = F_FC*KPER1
C$$$      F_FC = F_FC*KPER1/2.0D+00

C$$$      CALL D_DM2_TERM1(JJ,ION,IO1,N1,N2,N3,MIN_R,MAX_R,D_FDM2,NXTW
C$$$     $    ,IWTS,KPER1,NCI,WSTATE,AB,LSBS,NSYM,KSYM,ITGB,LGCOM,IGA,IGA2,
C$$$     $     JPZA1,JPZA2,LDISB)

C$$$      CALL D_DM2_TERM1(JJ,ION,ION,IO1,N1,N2,N3,MIN_R,MAX_R,D_FDM2,NXTW
C$$$     $    ,IWTS,KPER1,NCI,WSTATE,AB,LSBS,NSYM,KSYM,ITGB,LGCOM,IGA,IGA2,
C$$$     $     JPZA1,JPZA2,LDISB)
C$$$


!JJ,ION,ION,IO1
!JJ,ION,IO1,ION (EXCHANGE)
                 IF(MY_DM2(JJ,ION).EQ.1)THEN
      CALL D_DM2_TERM_1(JJ,ION,ION,IO1,N1,N2,N3,MIN_R,MAX_R,D_FDM2,NXTW
     $    ,IWTS,KPER1,NCI,WSTATE,AB,LSBS,NSYM,KSYM,ITGB,LGCOM,IGA,IGA2,
     $     JPZA1,JPZA2,LDISB)
        ENDIF
!ION,JJ,IO1,ION
!ION,JJ,ION,IO1 (EXCHANGE)
                 IF(MY_DM2(ION,JJ).EQ.1)THEN
       CALL D_DM2_TERM_1(ION,JJ,IO1,ION,N1,N2,N3,MIN_R,MAX_R,D_FDM2,NXTW
     $    ,IWTS,KPER1,NCI,WSTATE,AB,LSBS,NSYM,KSYM,ITGB,LGCOM,IGA,IGA2,
     $     JPZA1,JPZA2,LDISB)
      ENDIF
!IO1,ION,ION,JJ
!IO1,ION,JJ,ION (EXCHANGE)
                 IF(MY_DM2(IO1,ION).EQ.1)THEN
       CALL D_DM2_TERM_1(IO1,ION,ION,JJ,N1,N2,N3,MIN_R,MAX_R,D_FDM2,NXTW
     $    ,IWTS,KPER1,NCI,WSTATE,AB,LSBS,NSYM,KSYM,ITGB,LGCOM,IGA,IGA2,
     $     JPZA1,JPZA2,LDISB)
                 ENDIF
!ION,IO1,JJ,ION
!ION,IO1,ION,JJ (EXCHANGE)

                 IF(MY_DM2(ION,IO1).EQ.1)THEN
       CALL D_DM2_TERM_1(ION,IO1,JJ,ION,N1,N2,N3,MIN_R,MAX_R,D_FDM2,NXTW
     $    ,IWTS,KPER1,NCI,WSTATE,AB,LSBS,NSYM,KSYM,ITGB,LGCOM,IGA,IGA2,
     $     JPZA1,JPZA2,LDISB)
       ENDIF

C$$$ 1685         CONTINUE
C$$$!
C$$$ 1705         CONTINUE


!
 4712         CONTINUE
!
!  LOOP OVER BETA DETS OF THE RIGHT GROUP AND SYMMETRY.
!
              CALL RESETCO(LBOX3,NSPACE,NB,IBMA,IBMI,LBOX4)
!
              DO 4700 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB,IGA2).NE.1) GOTO 4690
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
              JCI2 = JPZA2 + LDISB(KSYM,IGB,IGA2)
!
              CALL RESETDE(LBOX3,NSPACE,NB,MSTA,IBCON1)
              ISTB = 1
              DO 4680 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 IENB = LSBC(KKB)
                 DO IIZ=ISTB,IENB-1
                    CALL MOVEUP2(LBOX3,NSPACE,NB,MSTA,IBCON1)
                 ENDDO
                 ISTB = IENB
                 JCI1 = JCI1 + 1
                 JCI2 = JCI2 + 1
!
                 F_FC = 0.0D+00
                 DO KKI=1,NXTW
              F_FC = F_FC+ WSTATE(IWTS(KKI))*AB(JCI1,KKI)*AB(JCI2,KKI)
                 ENDDO
                 F_FC = F_FC*KPER1/2.0D+00
!
                 DO 4670 IK=1,NB
                    ION = IBCON1(IK)

!A B -> B A'  WHERE: A'.GT.A
C$$$                 FDM2(JJ,ION,ION,IO1) =FDM2(JJ,ION,ION,IO1) +F_FC
C$$$                 FDM2(ION,JJ,IO1,ION) =FDM2(ION,JJ,IO1,ION) +F_FC
C$$$!------------- (DE)EXCITE BELOW
C$$$                 FDM2(IO1,ION,ION,JJ) =FDM2(IO1,ION,ION,JJ) +F_FC
C$$$                 FDM2(ION,IO1,JJ,ION) =FDM2(ION,IO1,JJ,ION) +F_FC
!//NOT MUCH SAVINGS IN DISTRIBUTED/PARALLEL VERSION                    
                    IF(MY_DM2(JJ,ION).EQ.1)THEN
        CALL DIST_DM2_M(JJ,ION,ION,IO1,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
                    ENDIF
                    IF(MY_DM2(ION,JJ).EQ.1)THEN
        CALL DIST_DM2_M(ION,JJ,IO1,ION,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
                    ENDIF         
                    IF(MY_DM2(IO1,ION).EQ.1)THEN
        CALL DIST_DM2_M(IO1,ION,ION,JJ,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
                    ENDIF
                    IF(MY_DM2(ION,IO1).EQ.1)THEN
        CALL DIST_DM2_M(ION,IO1,JJ,ION,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
                    ENDIF

 4670            CONTINUE
!
 4680         CONTINUE
!
 4690         CALL PUSHCO(LBOX3,NSPACE,NB,IBMA,IBMI,LBOX4,IEND)
 4700         CONTINUE
!
! --  DOUBLE ALPHA EXCITATIONS START HERE  ---
!
 4800         CONTINUE
!
            IF (IA1.EQ.NA) GOTO 4850
            IF (JJ.EQ.NACT) GOTO 4850
!
            DO II=1,NSPACE
               LBOX3(II) = LBOX2(II)
            ENDDO
            IAES3 = 1
            DO KK=1,ISPA1-1
               IAES3 = IAES3 + LBOX2(KK)
            ENDDO
!
!  LOOP OVER SPACES TO EXCITE ELECTRONS FROM, MUST BE GE THAN
!  SPACE OF FIRST EXCITATION, ISPA1.
!
            DO 3890 ISPA3 = ISPA1,NSPACE
               IF (LBOX1(ISPA3).EQ.0) GOTO 3887
               IF (ISPA3.EQ.ISPA1.AND.IA1.EQ.IEAE) GOTO 3887
               IOC3 = LBOX2(ISPA3)
               IF (IOC3.EQ.0) GOTO 3887
!
               IAEE3 = IAES3 + LBOX2(ISPA3)-1
               LBOX3(ISPA3) = LBOX3(ISPA3)-1
!
!  LOOP OVER ELECTRONS IN ISPA3, WHICH ARE LARGER THAN IA1,
!  MAKING SURE IT ISN'T THE ALREADY EXCITED ELECTRON.
!
               JSTA3 = IAES3
               IF (ISPA3.EQ.ISPA1) THEN
                  JSTA3=IA1
                  IF (IGAP-1.EQ.IA1) JSTA3=JSTA3+1
               ENDIF
!
               DO 3880 IA3=JSTA3,IAEE3
                  IF (IA3.EQ.IGAP-1) GOTO 3880
                  IO3 = IACON2(IA3)
                  IS3 = IOB(IO3)
!
!  LOOP OVER SPACES TO EXCITE ELECTRON INTO.  MUST BE GE THAN
!  SPACE FIRST ELECTRON WAS EXCITED INTO.
!
                  IGAE3 = 0
                  DO JIK=1,ISPA2-1
                     IGAE3 = IGAE3 + LBOX2(JIK)
                  ENDDO
                  DO 3850 ISPA4=ISPA2,NSPACE
!
!  IGAS3, IGAE3 ARE ELECTRONS SPECIFYING ISPA4 SPACE ELECTRON LIMITS.
!
                  LBOX3(ISPA4) = LBOX3(ISPA4) + 1
                  IGAS3 = IGAE3 + 1
                  IGAE3 = IGAE3 + LBOX2(ISPA4)
                  IF (LBOX3(ISPA3).LT.IAMI(ISPA3)) GOTO 3840
                  IF (LBOX3(ISPA4).GT.IAMA(ISPA4)) GOTO 3840
                  IF (LBOX3(ISPA2).LT.IAMI(ISPA2)) GOTO 3840
                  IF (LBOX3(ISPA2).GT.IAMA(ISPA2)) GOTO 3840
!
             IF (ISPA4.EQ.ISPA2.AND.JJ.EQ.MSTA(ISPA2+1)-1) GOTO 3840
!
!  GET GROUP NUMBER
!
               CALL POSITCO(LBOX5,NSPACE,NA,IAMA,IAMI,LBOX4,LBOX3,IGA3)
               NIAS3 = NAST(IGA3)
!
!  MAKE GAP INFORMATION HERE.
!
                  IGAA3 = MAX(IGAS3,IGAP)
!
                  IF (LBOX2(ISPA4).EQ.0) THEN
                     ISTA3 = MSTA(ISPA4)
                     IEND3 = MSTA(ISPA4+1)-1
                  ELSEIF (ISPA4.EQ.ISPA2) THEN
                     ISTA3 = JJ+1
                     IEND3 = IACON2(IGAA3)-1
!
!  I AM SUSPECT ABOUT THIS NEXT LINE, WE'LL SEE WHAT HAPPENS.......
!
                     IF (IGAP-1.EQ.IGAE3) IEND3=MSTA(ISPA2+1)-1
!
                  ELSE
                     ISTA3 = MSTA(ISPA4)
                     IEND3 = IACON2(IGAA3)-1
                  ENDIF
!
!  LOOP OVER GAPS
!
                  DO 3830 IGAP3=IGAA3,IGAE3+1
!
                     DO 3820 JJ3=ISTA3,IEND3
                        IS4 = IOB(JJ3)
                        IP2 = LGMUL(IS3,IS4)
                        IF (IP1.NE.IP2) GOTO 3820
!
              CALL REDE00(IACON2,IBCON1,NA,IA3,IGAP3-1,JJ3,JPERA3)
              CALL IDPOST(IBCON1,NA,LBOX3,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LANDET(1,IGA3),IBCON2,JPOSA3)
              IPER3 = ((-1)**(JPERA3+JPERA))*2
              KAPOS3 = JPOSA3 + NIAS3
              JPZA3 = LSPA(KAPOS3)
!
!  LOOP OVER BETA STRINGS OF RIGHT SYMMETRY AND GROUP.
!
      IF(MY_DM2(JJ,JJ3).EQ.1)THEN              
         CALL D_DM2_TERM_3(JJ,JJ3,IO3,IO1,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,ITGB,LGCOM,IGA,IGA3,JPZA1,LDISB,NSYM,KSYM,LSBS,NXTW
     $        ,WSTATE,AB,IPER3,IWTS,NCI,JPZA3)
      ENDIF
      
      IF(MY_DM2(JJ3,JJ).EQ.1)THEN
         CALL D_DM2_TERM_3(JJ3,JJ,IO1,IO3,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,ITGB,LGCOM,IGA,IGA3,JPZA1,LDISB,NSYM,KSYM,LSBS,NXTW
     $        ,WSTATE,AB,IPER3,IWTS,NCI,JPZA3)
      ENDIF
      
      IF(MY_DM2(IO1,IO3).EQ.1)THEN
         CALL D_DM2_TERM_3(IO1,IO3,JJ3,JJ,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,ITGB,LGCOM,IGA,IGA3,JPZA1,LDISB,NSYM,KSYM,LSBS,NXTW
     $        ,WSTATE,AB,IPER3,IWTS,NCI,JPZA3)
      ENDIF

      IF(MY_DM2(IO3,IO1).EQ.1)THEN
         CALL D_DM2_TERM_3(IO3,IO1,JJ,JJ3,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,ITGB,LGCOM,IGA,IGA3,JPZA1,LDISB,NSYM,KSYM,LSBS,NXTW
     $        ,WSTATE,AB,IPER3,IWTS,NCI,JPZA3)
      ENDIF

!
 3820                CONTINUE
!
                     ISTA3 = IACON2(IGAP3)+1
                     IEND3 = IACON2(IGAP3+1)-1
                     IF (IGAP3.EQ.IGAE3) IEND3=MSTA(ISPA4+1)-1
 3830             CONTINUE
!
 3840             LBOX3(ISPA4) = LBOX3(ISPA4) - 1
 3850             CONTINUE
!
 3880          CONTINUE
!
               LBOX3(ISPA3) = LBOX3(ISPA3)+1
 3887          IAES3 = IAES3 + LBOX3(ISPA3)
 3890       CONTINUE
!
 4850                CONTINUE
!
                  ISTA = IACON1(IGAP)+1
                  IEND = IACON1(IGAP+1)-1
                  IF (IGAP.EQ.IGAE) IEND=MSTA(ISPA2+1)-1
 4860             CONTINUE
!
 4870             LBOX2(ISPA2) = LBOX2(ISPA2) - 1
 4880          CONTINUE
!
 4885          CONTINUE
!
               LBOX2(ISPA1) = LBOX2(ISPA1)+1
 4890       CONTINUE
!
!  DIAGONAL ELEMENTS HERE
!
            DO 67 II=1,NA
               I1 = IACON1(II)
!
!  LOOP OVER BETA STRINGS OF RIGHT SYMMETRY AND GROUP.
!
              DO 64 JJ=II+1,NA
                 I2 = IACON1(JJ)
!
      IF(MY_DM2(I2,I1).EQ.1)THEN
         CALL D_DM2_TERM_4(I2,I1,I1,I2,N1,N2,N3,MIN_R,MAX_R,D_FDM2,
     $        WSTATE,IWTS,AB,NCI,NXTW,JCI1,ITGB,LGCOM,IGA,KSYM,LDISB,
     $        JPZA1,LSBS,NSYM)
      ENDIF

      IF(MY_DM2(I1,I2).EQ.1)THEN
         CALL D_DM2_TERM_4(I1,I2,I2,I1,N1,N2,N3,MIN_R,MAX_R,D_FDM2,
     $        WSTATE,IWTS,AB,NCI,NXTW,JCI1,ITGB,LGCOM,IGA,KSYM,LDISB,
     $        JPZA1,LSBS,NSYM)
      ENDIF
!
   64         CONTINUE
!
!  LOOP OVER BETA DETS OF THE RIGHT GROUP AND SYMMETRY.
!
              CALL RESETCO(LBOX3,NSPACE,NB,IBMA,IBMI,LBOX4)
!
              DO 4709 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1) GOTO 4699
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
!
              CALL RESETDE(LBOX3,NSPACE,NB,MSTA,IBCON1)
              ISTB = 1
              DO 4689 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 IENB = LSBC(KKB)
                 DO IIZ=ISTB,IENB-1
                    CALL MOVEUP2(LBOX3,NSPACE,NB,MSTA,IBCON1)
                 ENDDO
                 ISTB = IENB
                 JCI1 = JCI1 + 1
!
                 F_FC = 0.0D+00
                 DO KKI=1,NXTW
              F_FC = F_FC + WSTATE(IWTS(KKI))*AB(JCI1,KKI)*AB(JCI1,KKI)
                 ENDDO
!
                 DO 4679 IK=1,NB
                    I2 = IBCON1(IK)
! A B -> B A
C$$$                 FDM2(I1,I2,I2,I1) =FDM2(I1,I2,I2,I1) +F_FC
C$$$                 FDM2(I2,I1,I1,I2) =FDM2(I2,I1,I1,I2) +F_FC

      IF(MY_DM2(I1,I2).EQ.1)THEN
         CALL DIST_DM2_M(I1,I2,I2,I1,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
      ENDIF

      IF(MY_DM2(I2,I1).EQ.1)THEN
         CALL DIST_DM2_M(I2,I1,I1,I2,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
      ENDIF

 4679            CONTINUE
!
 4689         CONTINUE
!
 4699         CALL PUSHCO(LBOX3,NSPACE,NB,IBMA,IBMI,LBOX4,IEND)
 4709         CONTINUE
!
   67       CONTINUE
!
!  --- END OF LOOP OVER SINGLE ALPHA EXCITATIONS. ---
!      NOW TO SORT THEM BY POSITIONS WITHIN SYMMETRIES.
!
            DO II=1,NSYM
               CALL FCCSRT4(IGROA(1,II),IPERA(1,II),
     *              IPOSA(1,II),IMMC(II),IIND1O1(1,II),IIND1O2(1,II))
            ENDDO

!
!  --- END OF LOOP OVER PURE ALPHA EXCITATIONS.
!  NOW TO LOOP OVER ALL SIMULTANEOUS AB -> A'B' EXCITATIONS.
!

      IF (NSPACE.EQ.1) GOTO 3400
!
!  ***** GENERAL CASE OF MORE THAN ONE SPACE !!!!! *******
!

      IF (.NOT.FDIRCT) THEN
!
!  LOOP OVER SINGLE ALPHA EXCITES WITHIN EACH SYMMETRY.
!
      DO 3000 ISAE=1,NSYM
         KBSYM=KTAB(ISAE)
         DO 2900 JSAE=1,IMMC(ISAE)
            JPOSAE=IPOSA(JSAE,ISAE)
            JPERAE=IPERA(JSAE,ISAE)
!            JINDAE=IIND1(JSAE,ISAE)
            JGROAE=IGROA(JSAE,ISAE)
!
!  IF ISAE.EQ.JASYM THEN SPECIAL CASE.
!
       IF (ISAE.EQ.JASYM.AND.IGA.EQ.JGROAE) THEN
!
!  LOOP OVER ALL RELEVANT BETAS
!
            LABPOS = JPZA1
            LABPOS2 = JPOSAE
            DO 2813 IGB=1,ITGB
               IF (LGCOM(IGB,IGA).NE.1) GOTO 2813
               NIBS = NBST(IGB)
               DO 2763 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                  LABPOS = LABPOS + 1
                  LABPOS2 = LABPOS2 + 1
                  IBPOS = NIBS + LSBC(KKB)
!
!  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
!
               DO 2613 JBINDX=JB1ST(KBSYM,IBPOS),JB1ST(KBSYM+1,IBPOS)-1
                  IGB2=JB1GR(JBINDX)
                  IF (LGCOM(IGB2,JGROAE).NE.1) GOTO 2613
!
C$$$                  JCIB=JPOSAE+LDISB(KBSYM,IGB2,JGROAE)+JB1PO(JBINDX)
C$$$                  JCIB2=JPZA1+LDISB(KBSYM,IGB2,JGROAE)+JB1PO(JBINDX)
C$$$
C$$$                  F_FC = 0.0D+00
C$$$                  F_FC1 = 0.0D+00
C$$$                 DO KKI=1,NXTW
C$$$           F_FC = F_FC + WSTATE(IWTS(KKI))*AB(LABPOS,KKI)*AB(JCIB,KKI)
C$$$           F_FC1 =F_FC1+ WSTATE(IWTS(KKI))*AB(LABPOS2,KKI)*AB(JCIB2,KKI)
C$$$                 ENDDO
C$$$                 F_FC = F_FC*JPERAE*JB1PE(JBINDX)/2.0D+00
C$$$                 F_FC1 = F_FC1*JPERAE*JB1PE(JBINDX)/2.0D+00
                 
! NEEDED FOR SPIN-FREE 2RDM
                  I1_1=IIND1O1(JSAE,ISAE)
                  I2_1=JB1O1(JBINDX)
                  I2_2=JB1O2(JBINDX)
                  I1_2=IIND1O2(JSAE,ISAE)

!A1 B2 -> A'1 B'2  WHERE: A'1 > A1    B'2 > B2
C$$$                  FDM2(I1_2,I2_2,I2_1,I1_1) = 
C$$$     $                 FDM2(I1_2,I2_2,I2_1,I1_1) + F_FC
C$$$                  FDM2(I2_2,I1_2,I1_1,I2_1) = 
C$$$     $                 FDM2(I2_2,I1_2,I1_1,I2_1) + F_FC
C$$$                  FDM2(I2_1,I1_1,I1_2,I2_2) = 
C$$$     $                 FDM2(I2_1,I1_1,I1_2,I2_2) + F_FC
C$$$                  FDM2(I1_1,I2_1,I2_2,I1_2) = 
C$$$     $                 FDM2(I1_1,I2_1,I2_2,I1_2) + F_FC
C$$$!EXCHANGE
C$$$                  FDM2(I1_2,I2_1,I2_2,I1_1) = 
C$$$     $                 FDM2(I1_2,I2_1,I2_2,I1_1) + F_FC1
C$$$                  FDM2(I2_1,I1_2,I1_1,I2_2) = 
C$$$     $                 FDM2(I2_1,I1_2,I1_1,I2_2) + F_FC1
C$$$                  FDM2(I2_2,I1_1,I1_2,I2_1) = 
C$$$     $                 FDM2(I2_2,I1_1,I1_2,I2_1) + F_FC1
C$$$                  FDM2(I1_1,I2_2,I2_1,I1_2) = 
C$$$     $                 FDM2(I1_1,I2_2,I2_1,I1_2) + F_FC1

      IF(MY_DM2(I1_2,I2_2).EQ.1)THEN
      CALL D_DM2_TERM_10(I1_2,I2_2,I2_1,I1_1,N1,N2,N3,MIN_R,MAX_R,D_FDM2
     $     ,JPOSAE,LDISB,NSYM,ITGB,IGB2,JB1PO,JBINDX,JGROAE,
     $     NXTW,WSTATE,IWTS,AB,LABPOS,JPERAE,JB1PE,NCI,KBSYM)
      ENDIF
      IF(MY_DM2(I2_2,I1_2).EQ.1)THEN
      CALL D_DM2_TERM_10(I2_2,I1_2,I1_1,I2_1,N1,N2,N3,MIN_R,MAX_R,D_FDM2
     $     ,JPOSAE,LDISB,NSYM,ITGB,IGB2,JB1PO,JBINDX,JGROAE,
     $     NXTW,WSTATE,IWTS,AB,LABPOS,JPERAE,JB1PE,NCI,KBSYM)
      ENDIF
      IF(MY_DM2(I2_1,I1_1).EQ.1)THEN
      CALL D_DM2_TERM_10(I2_1,I1_1,I1_2,I2_2,N1,N2,N3,MIN_R,MAX_R,D_FDM2
     $     ,JPOSAE,LDISB,NSYM,ITGB,IGB2,JB1PO,JBINDX,JGROAE,
     $     NXTW,WSTATE,IWTS,AB,LABPOS,JPERAE,JB1PE,NCI,KBSYM)
      ENDIF
      IF(MY_DM2(I1_1,I2_1).EQ.1)THEN
      CALL D_DM2_TERM_10(I1_1,I2_1,I2_2,I1_2,N1,N2,N3,MIN_R,MAX_R,D_FDM2
     $     ,JPOSAE,LDISB,NSYM,ITGB,IGB2,JB1PO,JBINDX,JGROAE,
     $     NXTW,WSTATE,IWTS,AB,LABPOS,JPERAE,JB1PE,NCI,KBSYM)
      ENDIF

      IF(MY_DM2(I1_2,I2_1).EQ.1)THEN
      CALL D_DM2_TERM_10(I1_2,I2_1,I2_2,I1_1,N1,N2,N3,MIN_R,MAX_R,D_FDM2
     $     ,JPZA1,LDISB,NSYM,ITGB,IGB2,JB1PO,JBINDX,JGROAE,
     $     NXTW,WSTATE,IWTS,AB,LABPOS2,JPERAE,JB1PE,NCI,KBSYM)
      ENDIF
      IF(MY_DM2(I2_1,I1_2).EQ.1)THEN
      CALL D_DM2_TERM_10(I2_1,I1_2,I1_1,I2_2,N1,N2,N3,MIN_R,MAX_R,D_FDM2
     $     ,JPZA1,LDISB,NSYM,ITGB,IGB2,JB1PO,JBINDX,JGROAE,
     $     NXTW,WSTATE,IWTS,AB,LABPOS2,JPERAE,JB1PE,NCI,KBSYM)
      ENDIF
      IF(MY_DM2(I2_2,I1_1).EQ.1)THEN
      CALL D_DM2_TERM_10(I2_2,I1_1,I1_2,I2_1,N1,N2,N3,MIN_R,MAX_R,D_FDM2
     $     ,JPZA1,LDISB,NSYM,ITGB,IGB2,JB1PO,JBINDX,JGROAE,
     $     NXTW,WSTATE,IWTS,AB,LABPOS2,JPERAE,JB1PE,NCI,KBSYM)
      ENDIF
      IF(MY_DM2(I1_1,I2_2).EQ.1)THEN
      CALL D_DM2_TERM_10(I1_1,I2_2,I2_1,I1_2,N1,N2,N3,MIN_R,MAX_R,D_FDM2
     $     ,JPZA1,LDISB,NSYM,ITGB,IGB2,JB1PO,JBINDX,JGROAE,
     $     NXTW,WSTATE,IWTS,AB,LABPOS2,JPERAE,JB1PE,NCI,KBSYM)
      ENDIF
              

 2613          CONTINUE
!
 2763          CONTINUE
 2813       CONTINUE
!
       ELSE !(ISAE.EQ.JASYM.AND.IGA.EQ.JGROAE)

!
!  LOOP OVER ALL RELEVANT (A-)BETA DETS.
!
            LABPOS = JPZA1
            DO 2800 IGB=1,ITGB
               IF (LGCOM(IGB,IGA).NE.1) GOTO 2800
               NIBS = NBST(IGB)
               DO 2750 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                  LABPOS = LABPOS + 1
                  IBPOS = NIBS + LSBC(KKB)
!
!  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
!
               DO 2600 JBINDX=JB1ST(KBSYM,IBPOS),JB1ST(KBSYM+1,IBPOS)-1
                  IGB2=JB1GR(JBINDX)
                  IF (LGCOM(IGB2,JGROAE).NE.1) GOTO 2600
!
C$$$                  JCIB=JPOSAE+LDISB(KBSYM,IGB2,JGROAE)+JB1PO(JBINDX)
C$$$
C$$$                  F_FC = 0.0D+00
C$$$                 DO KKI=1,NXTW
C$$$            F_FC = F_FC + WSTATE(IWTS(KKI))*AB(LABPOS,KKI)*AB(JCIB,KKI)
C$$$                 ENDDO
C$$$                  F_FC = F_FC*JPERAE*JB1PE(JBINDX)/2.0D+00

!B1 12 -> B'1 1'2  WHERE: A'1 > A1    B'2 > B2
                  I1_1=IIND1O1(JSAE,ISAE)
                  I2_1=JB1O1(JBINDX)
                  I2_2=JB1O2(JBINDX)
                  I1_2=IIND1O2(JSAE,ISAE)

!DN,DN->UP,UP
C$$$                  FDM2(I1_2,I2_2,I2_1,I1_1) = 
C$$$     $                 FDM2(I1_2,I2_2,I2_1,I1_1) + F_FC
C$$$                  FDM2(I2_2,I1_2,I1_1,I2_1) = 
C$$$     $                 FDM2(I2_2,I1_2,I1_1,I2_1) + F_FC
C$$$                  FDM2(I2_1,I1_1,I1_2,I2_2) = 
C$$$     $                 FDM2(I2_1,I1_1,I1_2,I2_2) + F_FC
C$$$                  FDM2(I1_1,I2_1,I2_2,I1_2) = 
C$$$     $                 FDM2(I1_1,I2_1,I2_2,I1_2) + F_FC

      IF(MY_DM2(I1_2,I2_2).EQ.1)THEN
      CALL D_DM2_TERM_10(I1_2,I2_2,I2_1,I1_1,N1,N2,N3,MIN_R,MAX_R,D_FDM2
     $     ,JPOSAE,LDISB,NSYM,ITGB,IGB2,JB1PO,JBINDX,JGROAE,
     $     NXTW,WSTATE,IWTS,AB,LABPOS,JPERAE,JB1PE,NCI,KBSYM)
      ENDIF
      IF(MY_DM2(I2_2,I1_2).EQ.1)THEN
      CALL D_DM2_TERM_10(I2_2,I1_2,I1_1,I2_1,N1,N2,N3,MIN_R,MAX_R,D_FDM2
     $     ,JPOSAE,LDISB,NSYM,ITGB,IGB2,JB1PO,JBINDX,JGROAE,
     $     NXTW,WSTATE,IWTS,AB,LABPOS,JPERAE,JB1PE,NCI,KBSYM)
      ENDIF
      IF(MY_DM2(I2_1,I1_1).EQ.1)THEN
      CALL D_DM2_TERM_10(I2_1,I1_1,I1_2,I2_2,N1,N2,N3,MIN_R,MAX_R,D_FDM2
     $     ,JPOSAE,LDISB,NSYM,ITGB,IGB2,JB1PO,JBINDX,JGROAE,
     $     NXTW,WSTATE,IWTS,AB,LABPOS,JPERAE,JB1PE,NCI,KBSYM)
      ENDIF
      IF(MY_DM2(I1_1,I2_1).EQ.1)THEN
      CALL D_DM2_TERM_10(I1_1,I2_1,I2_2,I1_2,N1,N2,N3,MIN_R,MAX_R,D_FDM2
     $     ,JPOSAE,LDISB,NSYM,ITGB,IGB2,JB1PO,JBINDX,JGROAE,
     $     NXTW,WSTATE,IWTS,AB,LABPOS,JPERAE,JB1PE,NCI,KBSYM)
      ENDIF


 2600          CONTINUE
!
 2750          CONTINUE
 2800       CONTINUE
!
!  LOOP OVER ALL RELEVANT (A'-)BETA DETS.
!
            LABPOS = JPOSAE
            DO 2803 IGB=1,ITGB
               IF (LGCOM(IGB,JGROAE).NE.1) GOTO 2803
               NIBS = NBST(IGB)
               DO 2753 KKB=LSBS(KBSYM,IGB),LSBS(KBSYM+1,IGB)-1
                  LABPOS = LABPOS + 1
                  IBPOS = NIBS + LSBC(KKB)
!
!  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
!
               DO 2603 JBINDX=JB1ST(KSYM,IBPOS),JB1ST(KSYM+1,IBPOS)-1
                  IGB2=JB1GR(JBINDX)
                  IF (LGCOM(IGB2,IGA).NE.1) GOTO 2603
!
C$$$                  JCIB=JPZA1+LDISB(KSYM,IGB2,IGA)+JB1PO(JBINDX)
C$$$                  F_FC = 0.0D+00
C$$$                 DO KKI=1,NXTW
C$$$            F_FC = F_FC + WSTATE(IWTS(KKI))*AB(LABPOS,KKI)*AB(JCIB,KKI)
C$$$                 ENDDO
C$$$                  F_FC = F_FC*JPERAE*JB1PE(JBINDX)/2.0D+00

!B1 A2 -> A'1 B'2  WHERE: A'1 > A1    B'2 > B2
                  I1_1=IIND1O1(JSAE,ISAE)
                  I2_1=JB1O1(JBINDX)
                  I2_2=JB1O2(JBINDX)
                  I1_2=IIND1O2(JSAE,ISAE)

!UP,DN->DN,UP
C$$$                  FDM2(I1_2,I2_1,I2_2,I1_1) = 
C$$$     $                 FDM2(I1_2,I2_1,I2_2,I1_1) + F_FC
C$$$                  FDM2(I2_1,I1_2,I1_1,I2_2) = 
C$$$     $                 FDM2(I2_1,I1_2,I1_1,I2_2) + F_FC
C$$$                  FDM2(I2_2,I1_1,I1_2,I2_1) = 
C$$$     $                 FDM2(I2_2,I1_1,I1_2,I2_1) + F_FC
C$$$                  FDM2(I1_1,I2_2,I2_1,I1_2) = 
C$$$     $                 FDM2(I1_1,I2_2,I2_1,I1_2) + F_FC

      IF(MY_DM2(I1_2,I2_1).EQ.1)THEN
      CALL D_DM2_TERM_10(I1_2,I2_1,I2_2,I1_1,N1,N2,N3,MIN_R,MAX_R,D_FDM2
     $     ,JPZA1,LDISB,NSYM,ITGB,IGB2,JB1PO,JBINDX,IGA,
     $     NXTW,WSTATE,IWTS,AB,LABPOS,JPERAE,JB1PE,NCI,KSYM)
      ENDIF
      IF(MY_DM2(I2_1,I1_2).EQ.1)THEN
      CALL D_DM2_TERM_10(I2_1,I1_2,I1_1,I2_2,N1,N2,N3,MIN_R,MAX_R,D_FDM2
     $     ,JPZA1,LDISB,NSYM,ITGB,IGB2,JB1PO,JBINDX,IGA,
     $     NXTW,WSTATE,IWTS,AB,LABPOS,JPERAE,JB1PE,NCI,KSYM)
      ENDIF
      IF(MY_DM2(I2_2,I1_1).EQ.1)THEN
      CALL D_DM2_TERM_10(I2_2,I1_1,I1_2,I2_1,N1,N2,N3,MIN_R,MAX_R,D_FDM2
     $     ,JPZA1,LDISB,NSYM,ITGB,IGB2,JB1PO,JBINDX,IGA,
     $     NXTW,WSTATE,IWTS,AB,LABPOS,JPERAE,JB1PE,NCI,KSYM)
      ENDIF
      IF(MY_DM2(I1_1,I2_2).EQ.1)THEN
      CALL D_DM2_TERM_10(I1_1,I2_2,I2_1,I1_2,N1,N2,N3,MIN_R,MAX_R,D_FDM2
     $     ,JPZA1,LDISB,NSYM,ITGB,IGB2,JB1PO,JBINDX,IGA,
     $     NXTW,WSTATE,IWTS,AB,LABPOS,JPERAE,JB1PE,NCI,KSYM)
      ENDIF

 2603          CONTINUE
!
 2753          CONTINUE
 2803       CONTINUE
!
      ENDIF !(ISAE.EQ.JASYM.AND.IGA.EQ.JGROAE)
!
 2900    CONTINUE
 3000 CONTINUE
!
      ELSE !(.NOT.FDIRCT)
!
!  ***** DIRECT METHOD BELOW *****
!

      DO 4000 ISAE=1,NSYM
         KBSYM = KTAB(ISAE)
!
!  ANALYSE EXCITED A' GROUPS FOR COMPATIBILITY WITH B.
!
      NGRPS = 0
      DO 1976 II=1,IMMC(ISAE)
         ICGR = IGROA(II,ISAE)
         DO JJ=1,NGRPS
            IF (JB1GR(JJ).EQ.ICGR) GOTO 1976
         ENDDO
         NGRPS = NGRPS + 1
         JB1GR(NGRPS) = ICGR
 1976 CONTINUE
!
! FIRST TYPE OF BETAS, KSYM -> KBSYM
!
          CALL RESETCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3)
          DO 7400 IGB=1,ITGB
             IF (LGCOM(IGB,IGA).NE.1) GOTO 7399
             LAB1 = JPZA1 + LDISB(KSYM,IGB,IGA)
!
             CALL RESETDE(LBOX2,NSPACE,NB,MSTA,IBCON1)
             NIBS = NBST(IGB)
             ISTB = 1
             DO 7300 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                IENB = LSBC(KKB)
                DO IIZ=ISTB,IENB-1
                   CALL MOVEUP2(LBOX2,NSPACE,NB,MSTA,IBCON1)
                ENDDO
                ISTB = IENB
!
                IBPOS = NIBS + LSBC(KKB)
                LABPOS = LAB1 + LSPB(IBPOS)
!
! LOOP OVER SINGLE BETA EXCITES FROM IBPOS WHICH ARE OF SYMMETRY KBSYM
!
                MESYM1 = LGMUL(KSYM,KBSYM)
                DO II=1,NSPACE
                   LBOX3(II) = LBOX2(II)
                ENDDO
                IEBS = NB + 1
                DO 7290 ISPB1=NSPACE,1,-1
                   IOC1 = LBOX2(ISPB1)
                   IEBE = IEBS - 1
                   IEBS = IEBS - IOC1
                   IF (IOC1.EQ.0) GO TO 7290
                   LBOX3(ISPB1) = LBOX3(ISPB1)-1
!
!  LOOP ELECTRONS IN SPACE ISPB1
!  IEBS, IEBE ARE THE ELECTRONS IN SPACE ISPB1
!
                DO 7285 IB1 = IEBE,IEBS,-1
                   IO1 = IBCON1(IB1)
                   MESYM2 = LGMUL(MESYM1,IOB(IO1))
                   IGBE = IEBE - LBOX2(ISPB1)
!
!  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
!
                DO 7280 ISPB2=ISPB1,NSPACE
!
!  IGBS,IGBE ARE ELECTRONS SPECIFYING ISPB2 SPACE ELECTRON LIMITS.
!
                   IGBS = IGBE + 1
                   IGBE = IGBE + LBOX2(ISPB2)
!
                   LBOX3(ISPB2) = LBOX3(ISPB2) + 1
                   IF (LBOX3(ISPB1).LT.IBMI(ISPB1)) GO TO 7270
                   IF (LBOX3(ISPB2).GT.IBMA(ISPB2)) GO TO 7270
!
!  GET GROUP NUMBER
!
          CALL POSITCO(LBOX5,NSPACE,NB,IBMA,IBMI,LBOX4,LBOX3,IGB2)
          NIAS = NBST(IGB2)
!
! CHECK FOR A' GROUP COMPATIBILITY
!
             DO II=1,NGRPS
                IAGRP = JB1GR(II)
                IF (LGCOM(IGB2,IAGRP).EQ.1) GOTO 7555
             ENDDO
             GOTO 7270
 7555        CONTINUE
!
!  MAKE GAP INFORMATION HERE.
!
                  IGBA = MAX(IB1+1,IGBS)
                  IF (LBOX2(ISPB2).EQ.0) THEN
                     ISTA = MSTA(ISPB2)
                     IEND = MSTA(ISPB2+1)-1
                  ELSEIF (ISPB2.EQ.ISPB1) THEN
                     ISTA = IO1+1
                     IEND = IBCON1(IGBA)-1
                     IF (IB1.EQ.IEBE) IEND=MSTA(ISPB1+1)-1
                  ELSE
                     ISTA = MSTA(ISPB2)
                     IEND = IBCON1(IGBA)-1
                  ENDIF
!
!  LOOP OVER GAPS
!
                  DO 7260 IGAP=IGBA,IGBE+1
!
                     DO 7250 JJ=ISTA,IEND
!
! CHECK TO SEE IF EXCITED BETA IS OF RIGHT SYMMETRY (KBSYM)
!
            IF (IOB(JJ).NE.MESYM2) GOTO 7250
!
            IND1 = INDEX(JJ) + IO1
            CALL REDE00(IBCON1,IBCON2,NB,IB1,IGAP-1,JJ,IPER)
            CALL IDPOST(IBCON2,NB,LBOX3,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LBNDET(1,IGB2),IACON2,IPOSB)
            QJPER = ((-1)**IPER)
            JB1P = LSPB(IPOSB + NIAS)
!
            DO 3900 JSAE=1,IMMC(ISAE)
               JGROAE=IGROA(JSAE,ISAE)
               IF (LGCOM(IGB2,JGROAE).NE.1) GOTO 3900
!
               JPOSAE=IPOSA(JSAE,ISAE)
               JCIB = JB1P + JPOSAE + LDISB(KBSYM,IGB2,JGROAE)
!
!               JINDAE=IIND1(JSAE,ISAE)
!
               JPERAE=IPERA(JSAE,ISAE)
!
!B1 12 -> B'1 1'2  WHERE: A'1 > A1    B'2 > B2
                  I1_1=IO1
                  I2_1=IIND1O1(JSAE,ISAE)
                  I2_2=IIND1O2(JSAE,ISAE)
                  I1_2=JJ

!DN,DN->UP,UP
C$$$                  FDM2(I1_2,I2_2,I2_1,I1_1) = 
C$$$     $                 FDM2(I1_2,I2_2,I2_1,I1_1) + F_FC
C$$$                  FDM2(I2_2,I1_2,I1_1,I2_1) = 
C$$$     $                 FDM2(I2_2,I1_2,I1_1,I2_1) + F_FC
C$$$                  FDM2(I2_1,I1_1,I1_2,I2_2) = 
C$$$     $                 FDM2(I2_1,I1_1,I1_2,I2_2) + F_FC
C$$$                  FDM2(I1_1,I2_1,I2_2,I1_2) = 
C$$$     $                 FDM2(I1_1,I2_1,I2_2,I1_2) + F_FC

      IF(MY_DM2(I1_2,I2_2).EQ.1)THEN
         CALL D_DM2_TERM_5(I1_2,I2_2,I2_1,I1_1,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,NXTW,WSTATE,IWTS,AB,LABPOS,JPERAE,QJPER,NCI,JCIB)
      ENDIF

      IF(MY_DM2(I2_2,I1_2).EQ.1)THEN
         CALL D_DM2_TERM_5(I2_2,I1_2,I1_1,I2_1,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,NXTW,WSTATE,IWTS,AB,LABPOS,JPERAE,QJPER,NCI,JCIB)
      ENDIF

      IF(MY_DM2(I2_1,I1_1).EQ.1)THEN
         CALL D_DM2_TERM_5(I2_1,I1_1,I1_2,I2_2,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,NXTW,WSTATE,IWTS,AB,LABPOS,JPERAE,QJPER,NCI,JCIB)
      ENDIF

      IF(MY_DM2(I1_1,I2_1).EQ.1)THEN
         CALL D_DM2_TERM_5(I1_1,I2_1,I2_2,I1_2,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,NXTW,WSTATE,IWTS,AB,LABPOS,JPERAE,QJPER,NCI,JCIB)
      ENDIF

!
 3900       CONTINUE
!
 7250                CONTINUE
!
                  ISTA = IBCON1(IGAP)+1
                  IEND = IBCON1(IGAP+1)-1
                  IF (IGAP.EQ.IGBE) IEND=MSTA(ISPB2+1)-1
 7260             CONTINUE
!
 7270              LBOX3(ISPB2) = LBOX3(ISPB2) - 1
 7280           CONTINUE
!
 7285           CONTINUE
!
                   LBOX3(ISPB1) = LBOX3(ISPB1) + 1
 7290           CONTINUE
!
 7300        CONTINUE
!
 7399        CALL PUSHCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3,IEND)
 7400     CONTINUE
!
!
! SECOND TYPE OF BETAS, KBSYM -> KSYM
!
          CALL RESETCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3)
          DO 7801 IGB=1,ITGB
!
! CHECK FOR A' GROUP COMPATIBILITY
!
             DO II=1,NGRPS
                IAGRP = JB1GR(II)
                IF (LGCOM(IGB,IAGRP).EQ.1) GOTO 7655
             ENDDO
             GOTO 7799
 7655        CONTINUE
!
             CALL RESETDE(LBOX2,NSPACE,NB,MSTA,IBCON1)
             NIBS = NBST(IGB)
             ISTB = 1
!
             DO 7701 KKB=LSBS(KBSYM,IGB),LSBS(KBSYM+1,IGB)-1
                IENB = LSBC(KKB)
                DO IIZ=ISTB,IENB-1
                   CALL MOVEUP2(LBOX2,NSPACE,NB,MSTA,IBCON1)
                ENDDO
                ISTB = IENB
!
                IBPOS = NIBS + LSBC(KKB)
                LAB1 = LSPB(IBPOS)
!
! LOOP OVER SINGLE BETA EXCITES FROM IBPOS WHICH ARE OF SYMMETRY KSYM
!
                MESYM1 = LGMUL(KSYM,KBSYM)
                DO II=1,NSPACE
                   LBOX3(II) = LBOX2(II)
                ENDDO
                IEBS = NB + 1
                DO 7691 ISPB1=NSPACE,1,-1
                   IOC1 = LBOX2(ISPB1)
                   IEBE = IEBS - 1
                   IEBS = IEBS - IOC1
                   IF (IOC1.EQ.0) GO TO 7691
                   LBOX3(ISPB1) = LBOX3(ISPB1)-1
!
!  LOOP ELECTRONS IN SPACE ISPB1
!  IEBS, IEBE ARE THE ELECTRONS IN SPACE ISPB1
!
                DO 7686 IB1 = IEBE,IEBS,-1
                   IO1 = IBCON1(IB1)
                   MESYM2 = LGMUL(MESYM1,IOB(IO1))
                   IGBE = IEBE - LBOX2(ISPB1)
!
!  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
!
                DO 7681 ISPB2=ISPB1,NSPACE
!
!  IGBS,IGBE ARE ELECTRONS SPECIFYING ISPB2 SPACE ELECTRON LIMITS.
!
                   IGBS = IGBE + 1
                   IGBE = IGBE + LBOX2(ISPB2)
!
                   LBOX3(ISPB2) = LBOX3(ISPB2) + 1
                   IF (LBOX3(ISPB1).LT.IBMI(ISPB1)) GO TO 7671
                   IF (LBOX3(ISPB2).GT.IBMA(ISPB2)) GO TO 7671
!
          CALL POSITCO(LBOX5,NSPACE,NB,IBMA,IBMI,LBOX4,LBOX3,IGB2)
          IF (LGCOM(IGB2,IGA).NE.1) GOTO 7671
          JCIBS = JPZA1 + LDISB(KSYM,IGB2,IGA)
          NIAS = NBST(IGB2)
!
!  MAKE GAP INFORMATION HERE.
!
                  IGBA = MAX(IB1+1,IGBS)
                  IF (LBOX2(ISPB2).EQ.0) THEN
                     ISTA = MSTA(ISPB2)
                     IEND = MSTA(ISPB2+1)-1
                  ELSEIF (ISPB2.EQ.ISPB1) THEN
                     ISTA = IO1+1
                     IEND = IBCON1(IGBA)-1
                     IF (IB1.EQ.IEBE) IEND=MSTA(ISPB1+1)-1
                  ELSE
                     ISTA = MSTA(ISPB2)
                     IEND = IBCON1(IGBA)-1
                  ENDIF
!
!  LOOP OVER GAPS
!
                  DO 7660 IGAP=IGBA,IGBE+1
!
                     DO 7650 JJ=ISTA,IEND
!
! CHECK TO SEE IF EXCITED BETA IS OF RIGHT SYMMETRY (KBSYM)
!
            IF (IOB(JJ).NE.MESYM2) GOTO 7650
!
            IND1 = INDEX(JJ) + IO1
            CALL REDE00(IBCON1,IBCON2,NB,IB1,IGAP-1,JJ,IPER)
            CALL IDPOST(IBCON2,NB,LBOX3,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LBNDET(1,IGB2),IACON2,IPOSB)
            QJPER = ((-1)**IPER)
            JCIB= JCIBS + LSPB(IPOSB + NIAS)
!
            DO 4300 JSAE=1,IMMC(ISAE)
               JGROAE=IGROA(JSAE,ISAE)
               IF (LGCOM(IGB,JGROAE).NE.1) GOTO 4300
!
               JPOSAE=IPOSA(JSAE,ISAE)
               LABPOS = LAB1 + JPOSAE + LDISB(KBSYM,IGB,JGROAE)
!
!               JINDAE=IIND1(JSAE,ISAE)
!
               JPERAE=IPERA(JSAE,ISAE)
               F_FC = 0.0D+00
               DO KKI=1,NXTW
            F_FC = F_FC + WSTATE(IWTS(KKI))*AB(LABPOS,KKI)*AB(JCIB,KKI)
               ENDDO
               F_FC = F_FC*JPERAE*QJPER/2.0D+00

!B1 A2 -> A'1 B'2  WHERE: A'1 > A1    B'2 > B2
                  I1_1=IO1
                  I2_1=IIND1O1(JSAE,ISAE)
                  I2_2=IIND1O2(JSAE,ISAE)
                  I1_2=JJ

!UP,DN->DN,UP
C$$$                  FDM2(I1_2,I2_1,I2_2,I1_1) = 
C$$$     $                 FDM2(I1_2,I2_1,I2_2,I1_1) + F_FC
C$$$                  FDM2(I2_1,I1_2,I1_1,I2_2) = 
C$$$     $                 FDM2(I2_1,I1_2,I1_1,I2_2) + F_FC
C$$$                  FDM2(I2_2,I1_1,I1_2,I2_1) = 
C$$$     $                 FDM2(I2_2,I1_1,I1_2,I2_1) + F_FC
C$$$                  FDM2(I1_1,I2_2,I2_1,I1_2) = 
C$$$     $                 FDM2(I1_1,I2_2,I2_1,I1_2) + F_FC

      IF(MY_DM2(I1_2,I2_2).EQ.1)THEN
         CALL D_DM2_TERM_5(I1_2,I2_2,I2_1,I1_1,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,NXTW,WSTATE,IWTS,AB,LABPOS,JPERAE,QJPER,NCI,JCIB)
      ENDIF

      IF(MY_DM2(I2_2,I1_2).EQ.1)THEN
         CALL D_DM2_TERM_5(I2_2,I1_2,I1_1,I2_1,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,NXTW,WSTATE,IWTS,AB,LABPOS,JPERAE,QJPER,NCI,JCIB)
      ENDIF

      IF(MY_DM2(I2_1,I1_1).EQ.1)THEN
         CALL D_DM2_TERM_5(I2_1,I1_1,I1_2,I2_2,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,NXTW,WSTATE,IWTS,AB,LABPOS,JPERAE,QJPER,NCI,JCIB)
      ENDIF

      IF(MY_DM2(I1_1,I2_1).EQ.1)THEN
         CALL D_DM2_TERM_5(I1_1,I2_1,I2_2,I1_2,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,NXTW,WSTATE,IWTS,AB,LABPOS,JPERAE,QJPER,NCI,JCIB)
      ENDIF

!
 4300       CONTINUE
!
 7650                CONTINUE
!
                  ISTA = IBCON1(IGAP)+1
                  IEND = IBCON1(IGAP+1)-1
                  IF (IGAP.EQ.IGBE) IEND=MSTA(ISPB2+1)-1
 7660             CONTINUE
!
 7671              LBOX3(ISPB2) = LBOX3(ISPB2) - 1
 7681           CONTINUE
!
 7686           CONTINUE
!
                   LBOX3(ISPB1) = LBOX3(ISPB1) + 1
 7691           CONTINUE
!
 7701        CONTINUE
!
 7799        CALL PUSHCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3,IEND)
 7801     CONTINUE
!
 4000 CONTINUE
!     
      ENDIF !(.NOT.FDIRCT)
!
!  ***** END OF DIRECT OPTION *****
!
!  **** END OF GENERAL CASE OF MORE THAN ONE SPACE ******
!
      GOTO 4898
!
 3400 CONTINUE

!
! ***** SPECIAL CASE OF ONE SPACE !!!!! ******
!
!  LOOP OVER SINGLE ALPHA EXCITES WITHIN EACH SYMMETRY.
!
       DO 2901 ISAE=1,NSYM
          KBSYM=KTAB(ISAE)
          DO 2801 JSAE=1,IMMC(ISAE)
                JPOSAE=IPOSA(JSAE,ISAE)
                JPERAE=IPERA(JSAE,ISAE)
!                JINDAE=IIND1(JSAE,ISAE)
                JGROAE=IGROA(JSAE,ISAE)
!
!  IF ISAE.EQ.JASYM THEN SPECIAL CASE.
!
       IF (ISAE.EQ.JASYM) THEN
!
!  LOOP OVER ALL RELEVANT BETAS
!
             LABPOS=JPZA1    !0 ALPHA STRING
             LABPOS2=JPOSAE  !A->A' STRING
                DO 2721 KKB=LSBS(KSYM,1),LSBS(KSYM+1,1)-1
                    LABPOS = LABPOS + 1
                    LABPOS2 = LABPOS2 + 1
                    IBPOS =  LSBC(KKB)  !BETA OF CORRECT SYMMETRY
!
!  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
!
               DO 2621 JBINDX=JB1ST(KSYM,IBPOS),JB1ST(KSYM+1,IBPOS)-1

                  I1_1=IIND1O1(JSAE,ISAE)
                  I2_1=JB1O1(JBINDX)
                  I2_2=JB1O2(JBINDX)
                  I1_2=IIND1O2(JSAE,ISAE)

!A1 B2 -> A'1 B'2  WHERE: A'1 > A1    B'2 > B2
C$$$                  FDM2(I1_2,I2_2,I2_1,I1_1) = 
C$$$     $                 FDM2(I1_2,I2_2,I2_1,I1_1) + F_FC
C$$$                  FDM2(I2_2,I1_2,I1_1,I2_1) = 
C$$$     $                 FDM2(I2_2,I1_2,I1_1,I2_1) + F_FC
C$$$                  FDM2(I2_1,I1_1,I1_2,I2_2) = 
C$$$     $                 FDM2(I2_1,I1_1,I1_2,I2_2) + F_FC
C$$$                  FDM2(I1_1,I2_1,I2_2,I1_2) = 
C$$$     $                 FDM2(I1_1,I2_1,I2_2,I1_2) + F_FC
C$$$!EXCHANGE
C$$$                  FDM2(I1_2,I2_1,I2_2,I1_1) = 
C$$$     $                 FDM2(I1_2,I2_1,I2_2,I1_1) + F_FC1
C$$$                  FDM2(I2_1,I1_2,I1_1,I2_2) = 
C$$$     $                 FDM2(I2_1,I1_2,I1_1,I2_2) + F_FC1
C$$$                  FDM2(I2_2,I1_1,I1_2,I2_1) = 
C$$$     $                 FDM2(I2_2,I1_1,I1_2,I2_1) + F_FC1
C$$$                  FDM2(I1_1,I2_2,I2_1,I1_2) = 
C$$$     $                 FDM2(I1_1,I2_2,I2_1,I1_2) + F_FC1

      IF(MY_DM2(I1_2,I2_2).EQ.1)THEN
         CALL D_DM2_TERM_6(I1_2,I2_2,I2_1,I1_1,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,JPOSAE,JB1PO,JBINDX,NXTW,IWTS,WSTATE,AB,LABPOS,
     $        JPERAE,NCI,JB1PE)
      ENDIF
      IF(MY_DM2(I2_2,I1_2).EQ.1)THEN
         CALL D_DM2_TERM_6(I2_2,I1_2,I1_1,I2_1,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,JPOSAE,JB1PO,JBINDX,NXTW,IWTS,WSTATE,AB,LABPOS,
     $        JPERAE,NCI,JB1PE)
      ENDIF
      IF(MY_DM2(I2_1,I1_1).EQ.1)THEN
         CALL D_DM2_TERM_6(I2_1,I1_1,I1_2,I2_2,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,JPOSAE,JB1PO,JBINDX,NXTW,IWTS,WSTATE,AB,LABPOS,
     $        JPERAE,NCI,JB1PE)
      ENDIF
      IF(MY_DM2(I1_1,I2_1).EQ.1)THEN
         CALL D_DM2_TERM_6(I1_1,I2_1,I2_2,I1_2,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,JPOSAE,JB1PO,JBINDX,NXTW,IWTS,WSTATE,AB,LABPOS,
     $        JPERAE,NCI,JB1PE)
      ENDIF

      IF(MY_DM2(I1_2,I2_1).EQ.1)THEN
         CALL D_DM2_TERM_6(I1_2,I2_1,I2_2,I1_1,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,JPZA1,JB1PO,JBINDX,NXTW,IWTS,WSTATE,AB,LABPOS2,
     $        JPERAE,NCI,JB1PE)
      ENDIF
      IF(MY_DM2(I2_1,I1_2).EQ.1)THEN
         CALL D_DM2_TERM_6(I2_1,I1_2,I1_1,I2_2,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,JPZA1,JB1PO,JBINDX,NXTW,IWTS,WSTATE,AB,LABPOS2,
     $        JPERAE,NCI,JB1PE)
      ENDIF
      IF(MY_DM2(I2_2,I1_1).EQ.1)THEN
         CALL D_DM2_TERM_6(I2_2,I1_1,I1_2,I2_1,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,JPZA1,JB1PO,JBINDX,NXTW,IWTS,WSTATE,AB,LABPOS2,
     $        JPERAE,NCI,JB1PE)
      ENDIF
      IF(MY_DM2(I1_1,I2_2).EQ.1)THEN
         CALL D_DM2_TERM_6(I1_1,I2_2,I2_1,I1_2,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,JPZA1,JB1PO,JBINDX,NXTW,IWTS,WSTATE,AB,LABPOS2,
     $        JPERAE,NCI,JB1PE)
      ENDIF
!
 2621          CONTINUE
!
 2721          CONTINUE
!
      ELSE
!
!  LOOP OVER ALL RELEVANT (A-)BETA DETS.
!
                LABPOS = JPZA1
                DO 2751 KKB=LSBS(KSYM,1),LSBS(KSYM+1,1)-1
                    LABPOS = LABPOS + 1
                    IBPOS =  LSBC(KKB)
!
!  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
!
               DO 2601 JBINDX=JB1ST(KBSYM,IBPOS),JB1ST(KBSYM+1,IBPOS)-1
!
!$$$  <IIND1O1(JSAE,ISAE) JB1O1(JBINDX)|IIND1O2(JSAE,ISAE) JB1O2(JBINDX)>

C$$$                  JCIB=JPOSAE+JB1PO(JBINDX)
C$$$                  F_FC = 0.0D+00
C$$$                 DO KKI=1,NXTW
C$$$              F_FC = F_FC +WSTATE(IWTS(KKI))*AB(LABPOS,KKI)*AB(JCIB,KKI)
C$$$                 ENDDO
C$$$                  F_FC = F_FC*JPERAE*JB1PE(JBINDX)/2.0D+00

                  I1_1=IIND1O1(JSAE,ISAE)
                  I2_1=JB1O1(JBINDX)
                  I2_2=JB1O2(JBINDX)
                  I1_2=IIND1O2(JSAE,ISAE)

!A B A' B'  WHERE: A' > A    B' > B
!DN,DN->UP,UP
C$$$                  FDM2(I1_2,I2_2,I2_1,I1_1) = 
C$$$     $                 FDM2(I1_2,I2_2,I2_1,I1_1) + F_FC
C$$$                  FDM2(I2_2,I1_2,I1_1,I2_1) = 
C$$$     $                 FDM2(I2_2,I1_2,I1_1,I2_1) + F_FC
C$$$                  FDM2(I2_1,I1_1,I1_2,I2_2) = 
C$$$     $                 FDM2(I2_1,I1_1,I1_2,I2_2) + F_FC
C$$$                  FDM2(I1_1,I2_1,I2_2,I1_2) = 
C$$$     $                 FDM2(I1_1,I2_1,I2_2,I1_2) + F_FC

      IF(MY_DM2(I1_2,I2_2).EQ.1)THEN
         CALL D_DM2_TERM_6(I1_2,I2_2,I2_1,I1_1,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,JPOSAE,JB1PO,JBINDX,NXTW,IWTS,WSTATE,AB,LABPOS,
     $        JPERAE,NCI,JB1PE)
      ENDIF
      IF(MY_DM2(I2_2,I1_2).EQ.1)THEN
         CALL D_DM2_TERM_6(I2_2,I1_2,I1_1,I2_1,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,JPOSAE,JB1PO,JBINDX,NXTW,IWTS,WSTATE,AB,LABPOS,
     $        JPERAE,NCI,JB1PE)
      ENDIF
      IF(MY_DM2(I2_1,I1_1).EQ.1)THEN
         CALL D_DM2_TERM_6(I2_1,I1_1,I1_2,I2_2,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,JPOSAE,JB1PO,JBINDX,NXTW,IWTS,WSTATE,AB,LABPOS,
     $        JPERAE,NCI,JB1PE)
      ENDIF
      IF(MY_DM2(I1_1,I2_1).EQ.1)THEN
         CALL D_DM2_TERM_6(I1_1,I2_1,I2_2,I1_2,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,JPOSAE,JB1PO,JBINDX,NXTW,IWTS,WSTATE,AB,LABPOS,
     $        JPERAE,NCI,JB1PE)
      ENDIF

!
 2601          CONTINUE
!
 2751          CONTINUE
!
!  LOOP OVER ALL RELEVANT (A'-)BETA DETS.
!
               LABPOS = JPOSAE
               DO 2761 KKB=LSBS(KBSYM,1),LSBS(KBSYM+1,1)-1
                  LABPOS = LABPOS + 1
                  IBPOS = LSBC(KKB)
!
!  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
!
               DO 2611 JBINDX=JB1ST(KSYM,IBPOS),JB1ST(KSYM+1,IBPOS)-1
!
!$$$  <IIND1O1(JSAE,ISAE) JB1O1(JBINDX)|IIND1O2(JSAE,ISAE) JB1O2(JBINDX)>

C$$$                  JCIB=JPZA1+JB1PO(JBINDX)
C$$$                  F_FC = 0.0D+00
C$$$                 DO KKI=1,NXTW
C$$$           F_FC = F_FC + WSTATE(IWTS(KKI))*AB(LABPOS,KKI)*AB(JCIB,KKI)
C$$$                 ENDDO
C$$$                  F_FC = F_FC*JPERAE*JB1PE(JBINDX)/2.0D+00

                  I1_1=IIND1O1(JSAE,ISAE)
                  I2_1=JB1O1(JBINDX)
                  I2_2=JB1O2(JBINDX)
                  I1_2=IIND1O2(JSAE,ISAE)

!A B A' B'  WHERE: A' > A    B' > B
!UP,DN->DN,UP
C$$$                  FDM2(I1_2,I2_1,I2_2,I1_1) = 
C$$$     $                 FDM2(I1_2,I2_1,I2_2,I1_1) + F_FC
C$$$                  FDM2(I2_1,I1_2,I1_1,I2_2) = 
C$$$     $                 FDM2(I2_1,I1_2,I1_1,I2_2) + F_FC
C$$$                  FDM2(I2_2,I1_1,I1_2,I2_1) = 
C$$$     $                 FDM2(I2_2,I1_1,I1_2,I2_1) + F_FC
C$$$                  FDM2(I1_1,I2_2,I2_1,I1_2) = 
C$$$     $                 FDM2(I1_1,I2_2,I2_1,I1_2) + F_FC

      IF(MY_DM2(I1_2,I2_1).EQ.1)THEN
         CALL D_DM2_TERM_6(I1_2,I2_1,I2_2,I1_1,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,JPZA1,JB1PO,JBINDX,NXTW,IWTS,WSTATE,AB,LABPOS,
     $        JPERAE,NCI,JB1PE)
      ENDIF
      IF(MY_DM2(I2_1,I1_2).EQ.1)THEN
         CALL D_DM2_TERM_6(I2_1,I1_2,I1_1,I2_2,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,JPZA1,JB1PO,JBINDX,NXTW,IWTS,WSTATE,AB,LABPOS,
     $        JPERAE,NCI,JB1PE)
      ENDIF
      IF(MY_DM2(I2_2,I1_1).EQ.1)THEN
         CALL D_DM2_TERM_6(I2_2,I1_1,I1_2,I2_1,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,JPZA1,JB1PO,JBINDX,NXTW,IWTS,WSTATE,AB,LABPOS,
     $        JPERAE,NCI,JB1PE)
      ENDIF
      IF(MY_DM2(I1_1,I2_2).EQ.1)THEN
         CALL D_DM2_TERM_6(I1_1,I2_2,I2_1,I1_2,N1,N2,N3,MIN_R,MAX_R,
     $        D_FDM2,JPZA1,JB1PO,JBINDX,NXTW,IWTS,WSTATE,AB,LABPOS,
     $        JPERAE,NCI,JB1PE)
      ENDIF

!
 2611          CONTINUE
!
 2761          CONTINUE
!
      ENDIF
!
 2801       CONTINUE
 2901   CONTINUE
!
!  **** END OF SPECIAL CASE OF ONE SPACE *******
!
 4898       CONTINUE
!//DISABLE            IF (GOPARR) CALL DDI_DLBNEXT(MY_TASK)
 4899       CONTINUE
            CALL MOVEUP2(LBOX1,NSPACE,NA,MSTA,IACON1)
 4900    CONTINUE
!
         CALL PUSHCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX5,IEND)
 5000 CONTINUE
!
!           --- THIS ENDS LOOP OVER ALPHA STRINGS ---
!          --- NOW LOOP OVER PURE BETA EXCITATIONS ---
!
!//DISABLE      IF (GOPARR) THEN
!//DISABLE         CALL DDI_DLBRESET()
!//DISABLE         CALL DDI_DLBNEXT(MY_TASK)
!//DISABLE      ENDIF
!
      CALL RESETCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX5)
!
      DO 8000 IGB=1,ITGB
!
         CALL RESETDE(LBOX1,NSPACE,NB,MSTA,IBCON1)
!
!  KKB GIVES THE ACTUAL POSITION OF THE BETA STRING IBCON1 IN
!  THE FULL BETA STRING LIST.
!
         DO 7900 KKB=NBST(IGB)+1,NBST(IGB+1)
!//DISABLE            IF (GOPARR.AND.KKB-1.NE.MY_TASK) GOTO 7899
            JPZB1 = LSPB(KKB)
            KBSYM = LSYMB(KKB)
            KSYM=KTAB(KBSYM)
!
            DO II=1,NSPACE
               LBOX2(II) = LBOX1(II)
            ENDDO
!
!  LOOP OVER SPACES TO EXCITE ELECTRON FROM.
!
            IEBS = NB+1
            DO 7890 ISPB1=NSPACE,1,-1
               IOC1 = LBOX1(ISPB1)
               IEBE = IEBS - 1
               IEBS = IEBS - IOC1
               IF (IOC1.EQ.0) GOTO 7890
               LBOX2(ISPB1) = LBOX2(ISPB1)-1
!
!  LOOP ELECTRONS IN SPACE ISPB1.
!  IEBS, IEBE ARE THE ELECTRONS IN SPACE ISPB1.
!
               DO 7885 IB1=IEBE,IEBS,-1
                  IO1 = IBCON1(IB1)
                  IGBE = IEBE - LBOX1(ISPB1)
                  IS1 = IOB(IO1)
!
!  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
!
               DO 7880 ISPB2=ISPB1,NSPACE
!
!  IGBS, IGBE ARE ELECTRONS SPECIFYING ISPB2 SPACE ELECTRON LIMITS.
!
                  IGBS = IGBE + 1
                  IGBE = IGBE + LBOX1(ISPB2)
!
                  LBOX2(ISPB2) = LBOX2(ISPB2) + 1
                  IF (LBOX2(ISPB1).LT.IBMI(ISPB1)) GOTO 7870
!
!  MAKE GAP INFORMATION HERE.
!
                  IGBB = MAX(IB1+1,IGBS)
                  IF (LBOX1(ISPB2).EQ.0) THEN
                     ISTA = MSTA(ISPB2)
                     IEND = MSTA(ISPB2+1)-1
                  ELSEIF (ISPB2.EQ.ISPB1) THEN
                     ISTA = IO1+1
                     IEND = IBCON1(IGBB)-1
                     IF (IB1.EQ.IEBE) IEND=MSTA(ISPB1+1)-1
                  ELSE
                     ISTA = MSTA(ISPB2)
                     IEND = IBCON1(IGBB)-1
                  ENDIF
!
!  LOOP OVER GAPS
!
                  DO 7860 IGAP=IGBB,IGBE+1
!
                     DO 7850 JJ=ISTA,IEND
                        IS2 = IOB(JJ)
                        IP1 = LGMUL(IS1,IS2)
!
              CALL REDE00(IBCON1,IBCON2,NB,IB1,IGAP-1,JJ,JPERB)
                  IF (LBOX2(ISPB2).GT.IBMA(ISPB2)) GOTO 7800
!
!   IF DEOCCUPIED AND NEWLY OCCUPIED ORBITALS ARE OF DIFFERENT SYMMETRY,
!   SKIP TO DOUBLES.
!
              IF (IS1.NE.IS2) GOTO 7800
!
!  GET GROUP NUMBER
!
           CALL POSITCO(LBOX5,NSPACE,NB,IBMA,IBMI,LBOX4,LBOX2,IGB2)
           NIBS = NBST(IGB2)
!
              CALL IDPOST(IBCON2,NB,LBOX2,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LBNDET(1,IGB2),IACON1,JPOSB)
              KBPOS = JPOSB + NIBS
              JPZB2 = LSPB(KBPOS)
              KPER1 = ((-1)**JPERB)*2
!
!  LOOP OVER ALPHA AND UPDATE DM2
!
              DO 7712 IK=1,NB
                 IF (IK.EQ.IB1) GOTO 7712
                 ION = IBCON1(IK)
!


!B,B2,B2,B' WHERE : B' > B 
C$$$                 FDM2(JJ,ION,ION,IO1) = FDM2(JJ,ION,ION,IO1) + F_FC
C$$$                 FDM2(ION,JJ,IO1,ION) = FDM2(ION,JJ,IO1,ION) + F_FC
C$$$                 FDM2(JJ,ION,IO1,ION) = FDM2(JJ,ION,IO1,ION) - F_FC
C$$$                 FDM2(ION,JJ,ION,IO1) = FDM2(ION,JJ,ION,IO1) - F_FC
C$$$!$$$ (DE)EXCITE BELOW
C$$$                 FDM2(IO1,ION,ION,JJ) = FDM2(IO1,ION,ION,JJ) + F_FC
C$$$                 FDM2(ION,IO1,JJ,ION) = FDM2(ION,IO1,JJ,ION) + F_FC
C$$$                 FDM2(IO1,ION,JJ,ION) = FDM2(IO1,ION,JJ,ION) - F_FC
C$$$                 FDM2(ION,IO1,ION,JJ) = FDM2(ION,IO1,ION,JJ) - F_FC

      IF(MY_DM2(JJ,ION).EQ.1)THEN
      CALL D_DM2_TERM_7(JJ,ION,ION,IO1,N1,N2,N3,MIN_R,MAX_R,D_FDM2,NXTW,
     $     WSTATE,IWTS,AB,KPER1,NCI,ITGA,LGCOM,LDISB,NSYM,KBSYM,IGB,
     $     IGB2,JPZB1,JPZB2,NAST,LSAS,KSYM,LSAC,LSPA,ITGB)
      ENDIF
      IF(MY_DM2(ION,JJ).EQ.1)THEN
      CALL D_DM2_TERM_7(ION,JJ,IO1,ION,N1,N2,N3,MIN_R,MAX_R,D_FDM2,NXTW,
     $     WSTATE,IWTS,AB,KPER1,NCI,ITGA,LGCOM,LDISB,NSYM,KBSYM,IGB,
     $     IGB2,JPZB1,JPZB2,NAST,LSAS,KSYM,LSAC,LSPA,ITGB)
      ENDIF
      IF(MY_DM2(IO1,ION).EQ.1)THEN
      CALL D_DM2_TERM_7(IO1,ION,ION,JJ,N1,N2,N3,MIN_R,MAX_R,D_FDM2,NXTW,
     $     WSTATE,IWTS,AB,KPER1,NCI,ITGA,LGCOM,LDISB,NSYM,KBSYM,IGB,
     $     IGB2,JPZB1,JPZB2,NAST,LSAS,KSYM,LSAC,LSPA,ITGB)
      ENDIF
      IF(MY_DM2(ION,IO1).EQ.1)THEN
      CALL D_DM2_TERM_7(ION,IO1,JJ,ION,N1,N2,N3,MIN_R,MAX_R,D_FDM2,NXTW,
     $     WSTATE,IWTS,AB,KPER1,NCI,ITGA,LGCOM,LDISB,NSYM,KBSYM,IGB,
     $     IGB2,JPZB1,JPZB2,NAST,LSAS,KSYM,LSAC,LSPA,ITGB)
      ENDIF

!
 7712         CONTINUE
!
!  LOOP OVER ALPHA STRINGS OF THE RIGHT GROUP AND SYMMETRY.
!
              CALL RESETCO(LBOX3,NSPACE,NA,IAMA,IAMI,LBOX4)
!
              DO 7700 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB2,IGA).NE.1) GOTO 7690
                 JCIB1 = LDISB(KBSYM,IGB,IGA) + JPZB1
                 JCIB2 = LDISB(KBSYM,IGB2,IGA) + JPZB2
                 NIAS = NAST(IGA)
!
              CALL RESETDE(LBOX3,NSPACE,NA,MSTA,IACON1)
              ISTA1 = 1
              DO 7680 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA1 = LSAC(KKA)
                 DO IIZ=ISTA1,IENA1-1
                    CALL MOVEUP2(LBOX3,NSPACE,NA,MSTA,IACON1)
                 ENDDO
                 ISTA1 = IENA1
                 JCIA = LSPA(NIAS+IENA1)
                 JCI1 = JCIA + JCIB1
                 JCI2 = JCIA + JCIB2
                 F_FC = 0.0D+00
                 DO KKI=1,NXTW
              F_FC = F_FC + WSTATE(IWTS(KKI))*AB(JCI1,KKI)*AB(JCI2,KKI)
                 ENDDO
                 F_FC = F_FC*KPER1/2.0D+00
!
                 DO 7670 IK=1,NA
                    ION = IACON1(IK)

!$$$ <IO1 ION |JJ ION>
!B,A,A,B'    WHERE: B' > B
C$$$                 FDM2(JJ,ION,ION,IO1) = FDM2(JJ,ION,ION,IO1) + F_FC
C$$$                 FDM2(ION,JJ,IO1,ION) = FDM2(ION,JJ,IO1,ION) + F_FC
C$$$                 FDM2(IO1,ION,ION,JJ) = FDM2(IO1,ION,ION,JJ) + F_FC
C$$$                 FDM2(ION,IO1,JJ,ION) = FDM2(ION,IO1,JJ,ION) + F_FC

      IF(MY_DM2(JJ,ION).EQ.1)THEN              
      CALL D_DM2_TERM_8(JJ,ION,ION,IO1,N1,N2,N3,MIN_R,MAX_R,D_FDM2,F_FC)
      ENDIF
      IF(MY_DM2(ION,JJ).EQ.1)THEN              
      CALL D_DM2_TERM_8(ION,JJ,IO1,ION,N1,N2,N3,MIN_R,MAX_R,D_FDM2,F_FC)
      ENDIF
      IF(MY_DM2(IO1,ION).EQ.1)THEN              
      CALL D_DM2_TERM_8(IO1,ION,ION,JJ,N1,N2,N3,MIN_R,MAX_R,D_FDM2,F_FC)
      ENDIF
      IF(MY_DM2(ION,IO1).EQ.1)THEN              
      CALL D_DM2_TERM_8(ION,IO1,JJ,ION,N1,N2,N3,MIN_R,MAX_R,D_FDM2,F_FC)
      ENDIF

 7670            CONTINUE
!
 7680         CONTINUE
!
 7690         CALL PUSHCO(LBOX3,NSPACE,NA,IAMA,IAMI,LBOX4,IEND)
 7700         CONTINUE
!
!  --- DOUBLE EXCITATIONS START HERE
!
 7800         CONTINUE
!
           IF (IB1.EQ.NB) GOTO 7850
           IF (JJ.EQ.NACT) GOTO 7850
!
            DO II=1,NSPACE
               LBOX3(II) = LBOX2(II)
            ENDDO
            IBES3 = 1
            DO KK=1,ISPB1-1
               IBES3 = IBES3 + LBOX2(KK)
            ENDDO
!
!  LOOP OVER SPACES TO EXCITE ELECTRONS FROM, MUST BE GE THAN
!  SPACE OF FIRST EXCITATION, ISPB1.
!
            DO 6890 ISPB3 = ISPB1,NSPACE
               IF (LBOX1(ISPB3).EQ.0) GOTO 6887
               IF (ISPB3.EQ.ISPB1.AND.IB1.EQ.IEBE) GOTO 6887
               IOC3 = LBOX2(ISPB3)
               IF (IOC3.EQ.0) GOTO 6887
!
               IBEE3 = IBES3 + LBOX2(ISPB3)-1
               LBOX3(ISPB3) = LBOX3(ISPB3)-1
!
!  LOOP OVER ELECTRONS IN ISPB3, WHICH ARE LARGER THAN IB1,
!  MAKING SURE IT ISN'T THE ALREADY EXCITED ELECTRON.
!
               JSTB3 = IBES3
               IF (ISPB3.EQ.ISPB1) THEN
                  JSTB3=IB1
                  IF (IGAP-1.EQ.IB1) JSTB3=JSTB3+1
               ENDIF
!
               DO 6880 IB3=JSTB3,IBEE3
                  IF (IB3.EQ.IGAP-1) GOTO 6880
                  IO3 = IBCON2(IB3)
                  IS3 = IOB(IO3)
!
!  LOOP OVER SPACES TO EXCITE ELECTRON INTO.  MUST BE GE THAN
!  SPACE FIRST ELECTRON WAS EXCITED INTO.
!
                  IGBE3 = 0
                  DO JIK=1,ISPB2-1
                     IGBE3 = IGBE3 + LBOX2(JIK)
                  ENDDO
                  DO 6850 ISPB4=ISPB2,NSPACE
!
!  IGBS3, IGBE3 ARE ELECTRONS SPECIFYING ISPB4 SPACE ELECTRON LIMITS.
!
                  LBOX3(ISPB4) = LBOX3(ISPB4) + 1
                  IGBS3 = IGBE3 + 1
                  IGBE3 = IGBE3 + LBOX2(ISPB4)
                  IF (LBOX3(ISPB3).LT.IBMI(ISPB3)) GOTO 6840
                  IF (LBOX3(ISPB4).GT.IBMA(ISPB4)) GOTO 6840
                  IF (LBOX3(ISPB2).LT.IBMI(ISPB2)) GOTO 6840
                  IF (LBOX3(ISPB2).GT.IBMA(ISPB2)) GOTO 6840
!
             IF (ISPB4.EQ.ISPB2.AND.JJ.EQ.MSTA(ISPB2+1)-1) GOTO 6840
!
!  GET GROUP NUMBER
!
               CALL POSITCO(LBOX5,NSPACE,NB,IBMA,IBMI,LBOX4,LBOX3,IGB3)
               NIBS3 = NBST(IGB3)
!
!  MAKE GAP INFORMATION HERE.
!
                  IGBB3 = MAX(IGBS3,IGAP)
!
                  IF (LBOX2(ISPB4).EQ.0) THEN
                     ISTA3 = MSTA(ISPB4)
                     IEND3 = MSTA(ISPB4+1)-1
                  ELSEIF (ISPB4.EQ.ISPB2) THEN
                     ISTA3 = JJ+1
                     IEND3 = IBCON2(IGBB3)-1
!
!  I AM SUSPECT ABOUT THIS NEXT LINE, WE'LL SEE WHAT HAPPENS.......
!
                     IF (IGAP-1.EQ.IGBE3) IEND3=MSTA(ISPB2+1)-1
!
                  ELSE
                     ISTA3 = MSTA(ISPB4)
                     IEND3 = IBCON2(IGBB3)-1
                  ENDIF
!
!  LOOP OVER GAPS
!
                  DO 6830 IGAP3=IGBB3,IGBE3+1
!
                     DO 6820 JJ3=ISTA3,IEND3
                        IS4 = IOB(JJ3)
                        IP2 = LGMUL(IS3,IS4)
                        IF (IP1.NE.IP2) GOTO 6820
!
              CALL REDE00(IBCON2,IACON1,NB,IB3,IGAP3-1,JJ3,JPERB3)
              CALL IDPOST(IACON1,NB,LBOX3,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LBNDET(1,IGB3),IACON2,JPOSB3)
              IPER3 = ((-1)**(JPERB3+JPERB))*2
              KBPOS3 = JPOSB3 + NIBS3
              JPZB3 = LSPB(KBPOS3)
!
!  LOOP OVER ALPHA STRINGS OF RIGHT SYMMETRY AND GROUP.
!
C$$$              DO 6700 IGA=1,ITGA
C$$$              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB3,IGA).NE.1) GOTO 6700
C$$$              JCIB1 = JPZB1 + LDISB(KBSYM,IGB,IGA)
C$$$              JCIB3 = JPZB3 + LDISB(KBSYM,IGB3,IGA)
C$$$              NIAS = NAST(IGA)
C$$$!
C$$$              DO 6680 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
C$$$                 IENA3 = LSAC(KKA)
C$$$                 JCIA = LSPA(NIAS+IENA3)
C$$$                 JCI1 = JCIA + JCIB1
C$$$                 JCI3 = JCIA + JCIB3
C$$$                 F_FC = 0.0D+00
C$$$                 DO KKI=1,NXTW
C$$$              F_FC = F_FC + WSTATE(IWTS(KKI))*AB(JCI1,KKI)*AB(JCI3,KKI)
C$$$                 ENDDO
C$$$                 F_FC = F_FC*IPER3/2.0D+00

!B B2 -> B'2 B' WHERE: B'2 > B2  B' > B     B2 > B     B'2 > B2' 
C$$$                 FDM2(JJ,JJ3,IO3,IO1) = FDM2(JJ,JJ3,IO3,IO1) + F_FC
C$$$                 FDM2(JJ3,JJ,IO1,IO3) = FDM2(JJ3,JJ,IO1,IO3) + F_FC
C$$$                 FDM2(JJ,JJ3,IO1,IO3) = FDM2(JJ,JJ3,IO1,IO3) - F_FC
C$$$                 FDM2(JJ3,JJ,IO3,IO1) = FDM2(JJ3,JJ,IO3,IO1) - F_FC
C$$$!$$$!----(DE)EXCITE BELOW
C$$$                 FDM2(IO1,IO3,JJ3,JJ) = FDM2(IO1,IO3,JJ3,JJ) + F_FC
C$$$                 FDM2(IO3,IO1,JJ,JJ3) = FDM2(IO3,IO1,JJ,JJ3) + F_FC
C$$$                 FDM2(IO1,IO3,JJ,JJ3) = FDM2(IO1,IO3,JJ,JJ3) - F_FC
C$$$                 FDM2(IO3,IO1,JJ3,JJ) = FDM2(IO3,IO1,JJ3,JJ) - F_FC

      IF(MY_DM2(JJ,JJ3).EQ.1)THEN                                       
      CALL D_DM2_TERM_7(JJ,JJ3,IO3,IO1,N1,N2,N3,MIN_R,MAX_R,D_FDM2,NXTW,
     $     WSTATE,IWTS,AB,IPER3,NCI,ITGA,LGCOM,LDISB,NSYM,KBSYM,IGB,    
     $     IGB3,JPZB1,JPZB3,NAST,LSAS,KSYM,LSAC,LSPA,ITGB)              
      ENDIF                                                             
      IF(MY_DM2(JJ3,JJ).EQ.1)THEN                                       
      CALL D_DM2_TERM_7(JJ3,JJ,IO1,IO3,N1,N2,N3,MIN_R,MAX_R,D_FDM2,NXTW,
     $     WSTATE,IWTS,AB,IPER3,NCI,ITGA,LGCOM,LDISB,NSYM,KBSYM,IGB,    
     $     IGB3,JPZB1,JPZB3,NAST,LSAS,KSYM,LSAC,LSPA,ITGB)              
      ENDIF                                                             
      IF(MY_DM2(IO1,IO3).EQ.1)THEN                                      
      CALL D_DM2_TERM_7(IO1,IO3,JJ3,JJ,N1,N2,N3,MIN_R,MAX_R,D_FDM2,NXTW,
     $     WSTATE,IWTS,AB,IPER3,NCI,ITGA,LGCOM,LDISB,NSYM,KBSYM,IGB,    
     $     IGB3,JPZB1,JPZB3,NAST,LSAS,KSYM,LSAC,LSPA,ITGB)              
      ENDIF                                                             
      IF(MY_DM2(IO3,IO1).EQ.1)THEN                                      
      CALL D_DM2_TERM_7(IO3,IO1,JJ,JJ3,N1,N2,N3,MIN_R,MAX_R,D_FDM2,NXTW,
     $     WSTATE,IWTS,AB,IPER3,NCI,ITGA,LGCOM,LDISB,NSYM,KBSYM,IGB,    
     $     IGB3,JPZB1,JPZB3,NAST,LSAS,KSYM,LSAC,LSPA,ITGB)              
      ENDIF                                                             

C$$$ 6680         CONTINUE
C$$$!
C$$$ 6700         CONTINUE
!
 6820                CONTINUE
!
                     ISTA3 = IBCON2(IGAP3)+1
                     IEND3 = IBCON2(IGAP3+1)-1
                     IF (IGAP3.EQ.IGBE3) IEND3=MSTA(ISPB4+1)-1
 6830             CONTINUE
!
 6840             LBOX3(ISPB4) = LBOX3(ISPB4) - 1
 6850             CONTINUE
!
 6880          CONTINUE
!
               LBOX3(ISPB3) = LBOX3(ISPB3)+1
 6887          IBES3 = IBES3 + LBOX3(ISPB3)
 6890       CONTINUE
!
!  --- END OF LOOP OVER DOUBLE BETA EXCITATIONS.
!
 7850                CONTINUE
!
                  ISTA = IBCON1(IGAP)+1
                  IEND = IBCON1(IGAP+1)-1
                  IF (IGAP.EQ.IGBE) IEND=MSTA(ISPB2+1)-1
 7860             CONTINUE
!
 7870             LBOX2(ISPB2) = LBOX2(ISPB2) - 1
 7880          CONTINUE
!
 7885          CONTINUE
!
               LBOX2(ISPB1) = LBOX2(ISPB1)+1
 7890       CONTINUE
!
! REMAINING DIAGONAL CONTRIBUTIONS HERE
!
            DO 69 II=1,NB
               I1 = IBCON1(II)
!
              DO 74 JJ=II+1,NB
                 I2 = IBCON1(JJ)
!

!B1 B'2 -> B'2 B1   WHERE: B'2 > B1
C$$$                 FDM2(I1,I2,I2,I1) = FDM2(I1,I2,I2,I1) + F_FC
C$$$                 FDM2(I1,I2,I1,I2) = FDM2(I1,I2,I1,I2) - F_FC
C$$$                 FDM2(I2,I1,I1,I2) = FDM2(I2,I1,I1,I2) + F_FC
C$$$                 FDM2(I2,I1,I2,I1) = FDM2(I2,I1,I2,I1) - F_FC
      IF(MY_DM2(I1,I2).EQ.1)THEN
         CALL D_DM2_TERM_9(I1,I2,I2,I1,N1,N2,N3,MIN_R,MAX_R,D_FDM2,
     $        ITGA,LGCOM,ITGB,JPZB1,LDISB,NSYM,KBSYM,IGB,NAST,LSAS,KSYM,
     $        LSAC,LSPA,NXTW,WSTATE,IWTS,AB,NCI)
      ENDIF
      IF(MY_DM2(I2,I1).EQ.1)THEN
         CALL D_DM2_TERM_9(I2,I1,I1,I2,N1,N2,N3,MIN_R,MAX_R,D_FDM2,
     $        ITGA,LGCOM,ITGB,JPZB1,LDISB,NSYM,KBSYM,IGB,NAST,LSAS,KSYM,
     $        LSAC,LSPA,NXTW,WSTATE,IWTS,AB,NCI)
      ENDIF
!
   74         CONTINUE
!
   69         CONTINUE
!
!//DISABLE            IF (GOPARR) CALL DDI_DLBNEXT(MY_TASK)
 7899       CONTINUE
            CALL MOVEUP2(LBOX1,NSPACE,NB,MSTA,IBCON1)
 7900    CONTINUE
!
         CALL PUSHCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX5,IEND)
 8000 CONTINUE
!
!//DISABLE      IF (GOPARR) THEN
!//DISABLE         CALL DDI_DLBRESET()
!//DISABLE         CALL DDI_GSUMF(2901,FDM2,NACT**4)
!//DISABLE      ENDIF
!
      IF(SOME) WRITE(IW,9390)
      IF(SOME) CALL TIMIT(1)
      IF(SOME)CALL FLSHBF(6)
!
C$$$      CALL R12_F_NAME('R12INP',FILENM2)
C$$$!
C$$$      NULL = CHAR(0)
C$$$      DO 101 KOL=1,256
C$$$         IF(FILENM2(KOL:KOL).EQ.' '  .OR.
C$$$     *      FILENM2(KOL:KOL).EQ.NULL) GO TO 102
C$$$  101 CONTINUE
C$$$      KOL=257
C$$$  102 CONTINUE
C$$$      KOL=KOL-1
C$$$!
C$$$! WRITE THE 2PDM TO DISK FILE 'PT2RDM'
C$$$      DSKSAV=DSKWRK
C$$$      DSKWRK=.FALSE.
C$$$      IF(MASWRK)THEN
C$$$      OPEN(UNIT=99,FILE=FILENM2(1:KOL)//'.INPUT.PT2R12.RDM2.DAT',
C$$$     $        STATUS='UNKNOWN')
C$$$      DO I = 1,NACT
C$$$         DO II = 1,NACT
C$$$            DO III = 1,NACT
C$$$               DO 110 IV = 1,NACT
C$$$!                  IF(ABS(FDM2(I,II,III,IV)).LT.RDM2TOL) GO TO 110
C$$$                  WRITE(99,'(4I8,F22.16)')I,II,IV,III,FDM2(I,II,III,IV)
C$$$  110          CONTINUE
C$$$            ENDDO
C$$$         ENDDO
C$$$      ENDDO
C$$$      WRITE(99,'(4I8,F22.16)')-1,-1,-1,-1,-1.0D+00
C$$$      REWIND(99)
C$$$      CLOSE(UNIT=99,STATUS='KEEP')
C$$$
C$$$      ENDIF                     !IF(MASWRK)
C$$$      DSKWRK=DSKSAV

!///////////////
!//
!//   NOW FOR SOME 'RING-AROUND-THE-ROSEY' STYLE DATA PASSING
!//
!///////////////
      IF(ME.EQ.MASTER)THEN
         CALL R12_F_NAME('R12INP',FILENM2)
         NULL = CHAR(0)
         DO KOL=1,256
            IF(FILENM2(KOL:KOL).EQ.' '.OR.FILENM2(KOL:KOL).EQ.NULL)
     $           GOTO 103
         ENDDO
         KOL=257
  103 CONTINUE
      KOL=KOL-1
!// KEEP THE BELOW FILENAME EXTENSION LOWER CASE!!!!
      OPEN(UNIT=99,FILE=FILENM2(1:KOL)//'.input.pt2r12.rdm2.dat',
     $     STATUS='REPLACE')
      ENDIF  !(ME.EQ.MASTER)


!// LETS SYNCHONIZE FOR FUN
      IF(GOPARR) CALL DDI_SYNC(9205)

!// FIGURE OUT HOW MUCH OF THE HYPERCUBE IS STORED ON PROCESS IPROC
      DO IPROC = 0,NPROC-1
         
         IF(MOD(N4,NPROC).EQ.0)THEN
            
            IBIG_BLOCK   = (N4)/NPROC
            ISMALL_BLOCK = IBIG_BLOCK
            
            MIN_R = IPROC*IBIG_BLOCK !MINIMUM OF RANGE FOR PROCESS ME
            MAX_R = MIN_R + IBIG_BLOCK-1 !MAXIMUM OF RANGE FOR PROCESS ME

         ELSE

            IBIG_BLOCK    = ((N2/NPROC) +1)*(N2)
            ISMALL_BLOCK  = ((N2/NPROC)   )*(N2)
         
            IF(IPROC.LT.(MOD(N4,NPROC)))THEN
               
               MIN_R = (IPROC)*IBIG_BLOCK !MINIMUM OF RANGE FOR PROCESS ME
               MAX_R = MIN_R +IBIG_BLOCK-1 !MAXIMUM OF RANGE FOR PROCESS ME

            ELSE

               IOFFSET = IBIG_BLOCK*MOD(N4,NPROC)
               MIN_R = IOFFSET+(IPROC-(MOD(N4,NPROC)))*ISMALL_BLOCK
               MAX_R = MIN_R + ISMALL_BLOCK-1

            ENDIF
            
         ENDIF
         BLOCK_SIZE = MAX_R-MIN_R+1
         
         IF(ME.EQ.MASTER)THEN

!// IF IPROC IS MASTER ID, THEN WE DO NOT HAVE TO RECIEVE ANYTHING, WRITE MASTER INFO FIRST.
!//    IF MASTER ID IS NOT ZERO, THIS WILL NOT END WELL...THE BELOW ASSUMS MASTER ID = 0
            IF(IPROC.NE.MASTER)THEN
               CALL VCLR(D_FDM2  ,1,BLOCK_SIZE)
               CALL DDI_RECV(D_FDM2(1),BLOCK_SIZE*8,IPROC)
            ENDIF
            JJ = 0
            DO I = 1,NACT
               DO II = 1,NACT
                  DO III = 1,NACT
                     DO IV = 1,NACT
                        JJ = JJ +1
                        IF(JJ.LT.MIN_R+1.OR.JJ.GT.MAX_R+1)CYCLE
                        IF(ABS(D_FDM2(JJ-MIN_R)).LT.RDM2TOL)CYCLE
                        WRITE(99,'(4I8,F22.16)')I,II,IV,III,
     $                       D_FDM2(JJ-MIN_R)
C$$$                        WRITE(6,'(4I8,F22.16,2I8)')I,II,IV,III,
C$$$     $                       D_FDM2(JJ-MIN_R),JJ-MIN_R,BLOCK_SIZE
                     ENDDO      !IV
                  ENDDO         !III
               ENDDO            !II
            ENDDO               !I
            
         ELSEIF(ME.EQ.IPROC)THEN
!// EVERYONE (BUT MASTER) SENDS THERE D_FDM2 TO MASTER
            CALL DDI_SEND(D_FDM2(1),BLOCK_SIZE*8,MASTER)            
            
         ENDIF                  !(ME.EQ.MASTER)

!// WE HAVE TO SYNCHONIZE PROCESSES
         IF(GOPARR) CALL DDI_SYNC(9206)
         
      ENDDO                     !IPROC

!// WRITE THE TERMINATION STRING TO OUR DM2 FILE      
      IF(ME.EQ.MASTER)THEN
         WRITE(99,'(4I8,F22.16)')-1,-1,-1,-1,-1.0D+00
         CLOSE(99,STATUS='KEEP')
      ENDIF

!// PUBLISH TIMING INFO
      IF(SOME) WRITE(IW,9395)
      IF(SOME) CALL TIMIT(1)
      IF(SOME)CALL FLSHBF(6)

!//
      RETURN
!//
 9340 FORMAT(1X,'STATE=',I4,'   ENERGY=',F20.10,'   WEIGHT=',F8.5,
     *           '   S=',F6.2/)
 9350 FORMAT(/1X,'***** ERROR *****'/
     *       1X,'THIS RUN FOUND',I5,' CI EIGENVECTORS WITH S=',F5.2,','/
     *       1X,'BUT YOU REQUESTED STATE AVERAGING OF',I5,' ROOTS.'/
     *       1X,'PLEASE EXAMINE YOUR CHOICE OF -NSTATE- INPUT DATA.'/)
 9390 FORMAT(10X,'...DONE WITH 2 PARTICLE SPIN-FREE DENSITY MATRIX...'/)
 9395 FORMAT(/3X,'...FINISHED WRITING 2 PARTICLE SPIN-FREE ',
     $      'DENSITY MATRIX TO DISK...'/)
!
      END
!------------------------------------------------------------------------
!========================================================================
!------------------------------------------------------------------------
!*MODULE EXCORR  *DECK GET_CIVECT_TABLES
      SUBROUTINE GET_CIVECT_TABLES(IW,SOME,NACT,NCI,NA,NB,KST,MAXP,X,NX,
     *     NSYM,LBOX1,LBOX2,LBOX3,LBOX4,CI,INDEX,IACON1,IBCON1,IBCON2,
     $     LBNDET,NBST,LSYMB,LSPB,ITGB,IBST,NB1EX,IBST2,
     $     JB1GR,JB1PE,JB1IN,JB1PO,JB1ST,JB1SY,JB1O1,JB1O2)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL SOME,GOPARR,DSKWRK,MASWRK,FDIRCT,QCORR
      COMMON /CIFILS/ NFT11,NFT12,NFT13,NFT14,NFT15,NFT16,IDAF20,NEMEMX
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIM(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      DIMENSION X(NX)
      DIMENSION LBOX1(NSPACE),LBOX2(NSPACE),LBOX3(NSPACE),LBOX4(NSPACE)
      DIMENSION CI(NCI,MAXP)
      DIMENSION INDEX((NACT*(NACT+1))/2+1)
      DIMENSION IACON1(NA),IBCON1(NA),IBCON2(NA)
      DIMENSION LBNDET(NSPACE,ITGB)
      DIMENSION NBST(ITGB+1)
      DIMENSION LSYMB(IBST)
      DIMENSION LSPB(IBST)
      DIMENSION JB1GR(NB1EX),JB1PE(NB1EX),JB1IN(NB1EX),JB1ST(IBST2)
      DIMENSION JB1PO(NB1EX),JB1SY(NB*(NACT-NB))
      DIMENSION JB1O1(NB1EX),JB1O2(NB1EX)

      DO 7 I=1,(NACT*(NACT+1))/2 + 1
         INDEX(I) = (I*(I-1))/2
    7 CONTINUE

      DO 20 II=1,KST
         DO 30 JJ=1,NCI
            CI(JJ,II) = 0.0D+00
   30    CONTINUE
   20 CONTINUE

!   SEE IF WE HAVE INITIAL GUESS VECTORS ON DISK.

      NSTATE=0
      NVECS =0

      CALL SEQOPN(NFT12,'CIVECTR','UNKNOWN',.FALSE.,'UNFORMATTED')
      CALL SEQREW(NFT12)
      IF(MASWRK) READ(NFT12,ERR=2343,END=2343) NSTATE,NVECS
      GO TO 2344

 2343 CONTINUE
      WRITE(6,'("DAFCCI_2.SRC ERROR, NO USABLE CI VECTORS ON DISK")')
      CALL ABRT
      STOP

!         LET OTHER NODES KNOW WHAT WAS WAS READ

 2344 CONTINUE
      IF (GOPARR) CALL DDI_BCAST(2507,'I',NSTATE,1,MASTER)
      IF (GOPARR) CALL DDI_BCAST(2508,'I',NVECS ,1,MASTER)

!         IF INCONSISTENCY WITH THE DISK FILE, WE MUST TERMINATE

      IF (NVECS.NE.NCI) THEN
         IF (SOME) WRITE(IW,9005) NVECS,NCI
         CALL ABRT
      ENDIF

!        READ CI EIGENVECTORS

      IF (SOME) WRITE(IW,9007)
      DO 100 ISTATE = 1,NSTATE
         CALL SQREAD(NFT12,CI(1,ISTATE),NVECS)
         IF(NVECS.EQ.0) THEN
            IF (SOME) WRITE(IW,*)
     *         'UNEXPECTED END OF FILE ON UNIT',NFT12
            CALL ABRT
            STOP
         END IF
  100 CONTINUE

! DET UP B->B' INFORMATION IF ORMAS IS SET FDIRCT
         IF (.NOT.FDIRCT) THEN
         CALL FCCSUP2(IW,NA,NB,NACT,IACON1,IBCON1,IBCON2,
     *           INDEX,NBST,LSPB,
     *           LBOX1,LBOX2,LBOX3,LBOX4,
     *           X,NX,LBNDET,LSYMB,NSYM,
     *           ITGB,IBST,
     *           NB1EX,JB1GR,JB1PE,JB1IN,JB1PO,JB1ST,JB1SY,
     $           JB1O1,JB1O2)
         ENDIF
!
      RETURN
!
 9005 FORMAT(/1X,'ERROR, NUMBER OF VECTORS STORED=',I5,
     *           ' NOT EQUAL TO NCI=',I5/
     *        1X,'THIS MAY BE DUE TO A GARBAGE -CIVECTR- FILE',
     *           ' LEFT OVER FROM AN EARLIER RUN.')
 9007 FORMAT(/1X,'ORMAS VECTORS READ FROM DISK'/)
      END
!------------------------------------------------------------------------
!========================================================================
!------------------------------------------------------------------------
!*MODULE EXCORR  *DECK FCCSRT4
      SUBROUTINE FCCSRT4(JB1GR,JB1PE,JB1SY,N,IIND1O1,IIND1O2)
      IMPLICIT INTEGER(A-Z)
      DIMENSION JB1GR(N),JB1PE(N),JB1SY(N),IIND1O1(N),
     $     IIND1O2(N)
!
!    SORTING GARBAGE.
!
      IF (N.LT.2) RETURN
      L=N/2+1
      IR=N
!
   10 CONTINUE
         IF (L.GT.1) THEN
            L=L-1
            IRRA=JB1SY(L)
            IRRB=JB1GR(L)
            IRRC=JB1PE(L)
            IRRE = IIND1O1(L)
            IRRF = IIND1O2(L)
         ELSE
            IRRA=JB1SY(IR)
            IRRB=JB1GR(IR)
            IRRC=JB1PE(IR)
            IRRE = IIND1O1(IR)
            IRRF = IIND1O2(IR)
            JB1SY(IR)=JB1SY(1)
            JB1GR(IR)=JB1GR(1)
            JB1PE(IR)=JB1PE(1)
            IIND1O1(IR) = IIND1O1(1)
            IIND1O2(IR) = IIND1O2(1)
!
            IR=IR-1
            IF (IR.EQ.1) THEN
               JB1SY(1)=IRRA
               JB1GR(1)=IRRB
               JB1PE(1)=IRRC
               IIND1O1(1) = IRRE
               IIND1O2(1) = IRRF
!
               GO TO 122
            ENDIF
         ENDIF
         I=L
         J=L+L
   20    IF (J.LE.IR) THEN
            IF (J.LT.IR) THEN
                   IF (JB1SY(J).LT.JB1SY(J+1)) J=J+1
            ENDIF
            IF (IRRA.LT.JB1SY(J)) THEN
               JB1SY(I)=JB1SY(J)
               JB1GR(I)=JB1GR(J)
               JB1PE(I)=JB1PE(J)
               IIND1O1(I) = IIND1O1(J)
               IIND1O2(I) = IIND1O2(J)
               I=J
               J=J+J
            ELSE
               J=IR+1
            ENDIF
         GO TO 20
         ENDIF
         JB1SY(I)=IRRA
         JB1GR(I)=IRRB
         JB1PE(I)=IRRC
         IIND1O1(I) = IRRE
         IIND1O2(I) = IRRF
      GO TO 10
!
  122 CONTINUE
!
      RETURN
      END
!------------------------------------------------------------------------
!========================================================================
!------------------------------------------------------------------------
!*MODULE EXCORR  *DECK FCCSUP2
      SUBROUTINE FCCSUP2(IW,NA,NB,NACT,IACON1,IBCON1,IBCON2,
     *           INDEX,NBST,LSPB,
     *           LBOX1,LBOX2,LBOX3,LBOX4,
     *           X,NX,LBNDET,LSYMB,NSYM,ITGB,IBST,
     *           NB1EX,JB1GR,JB1PE,JB1IN,JB1PO,JB1ST,JB1SY,
     $           JB1O1,JB1O2)

!     ------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
!
      LOGICAL FDIRCT,QCORR
!
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIM(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
!
      DIMENSION IACON1(NA),IBCON1(NB),IBCON2(NB)
      DIMENSION INDEX((NACT*(NACT+1))/2+1)
      DIMENSION LBOX1(NSPACE),LBOX2(NSPACE),LBOX3(NSPACE)
      DIMENSION LBOX4(NSPACE)
      DIMENSION NBST(ITGB+1),LSPB(IBST)
      DIMENSION X(NX)
      DIMENSION LBNDET(NSPACE,ITGB),LSYMB(IBST)
      DIMENSION JB1GR(NB1EX),JB1PE(NB1EX),JB1IN(NB1EX),JB1PO(NB1EX)
      DIMENSION JB1ST(NSYM+1,IBST+1),JB1SY(NB*(NACT-NB))

      DIMENSION JB1O1(NB1EX),JB1O2(NB1EX)

!
!  MAKE AND STORE ALL B -> B' DATA, WHERE B' > B.
!
      NB1CH = 0
      INB = 0
!
!  LOOP THROUGH ALL BETA GROUPS
!
      CALL RESETCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX3)
!
      DO 1000 IIB = 1,ITGB
!
         CALL RESETDE(LBOX1,NSPACE,NB,MSTA,IBCON1)
!
         DO 900 KKB=NBST(IIB)+1,NBST(IIB+1)
            INB = INB + 1
            DO II=1,NSPACE
               LBOX2(II) = LBOX1(II)
            ENDDO
            JB1ST(1,INB) = NB1CH+1
            KBST = NB1CH+1
!
!  LOOP OVER ALL SINGLE EXCITATIONS, CHECKING TO SEE IF IT IS VALID.
!
!  LOOP OVER SPACES TO EXCITE ELECTRON FROM.
!
            IEBS = NB+1
            DO 890 ISPB1=NSPACE,1,-1
               IOC1 = LBOX1(ISPB1)
               IEBE = IEBS - 1
               IEBS = IEBS - IOC1
               IF (IOC1.EQ.0) GO TO 890
               LBOX2(ISPB1) = LBOX2(ISPB1)-1
!
!  LOOP ELECTRONS IN SPACE ISPB1
!  IEBS, IEBE ARE THE ELECTRONS IN SPACE ISPB1
!
               DO 885 IB1 = IEBE,IEBS,-1
                  IO1 = IBCON1(IB1)
                  IGBE = IEBE - LBOX1(ISPB1)
!
!  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
!
               DO 880 ISPB2=ISPB1,NSPACE
!
!  IGBS,IGBE ARE ELECTRONS SPECIFYING ISPB2 SPACE ELECTRON LIMITS.
!
                  IGBS = IGBE + 1
                  IGBE = IGBE + LBOX1(ISPB2)
!
                  LBOX2(ISPB2) = LBOX2(ISPB2) + 1
                  IF (LBOX2(ISPB1).LT.IBMI(ISPB1)) GO TO 870
                  IF (LBOX2(ISPB2).GT.IBMA(ISPB2)) GO TO 870
!
!  GET GROUP NUMBER
!
          CALL POSITCO(LBOX4,NSPACE,NB,IBMA,IBMI,LBOX3,LBOX2,IGB)
          NIAS = NBST(IGB)
!
!  MAKE GAP INFORMATION HERE.
!
                  IGBA = MAX(IB1+1,IGBS)
                  IF (LBOX1(ISPB2).EQ.0) THEN
                     ISTA = MSTA(ISPB2)
                     IEND = MSTA(ISPB2+1)-1
                  ELSEIF (ISPB2.EQ.ISPB1) THEN
                     ISTA = IO1+1
                     IEND = IBCON1(IGBA)-1
                     IF (IB1.EQ.IEBE) IEND=MSTA(ISPB1+1)-1
                  ELSE
                     ISTA = MSTA(ISPB2)
                     IEND = IBCON1(IGBA)-1
                  ENDIF
!
!  LOOP OVER GAPS
!
                  DO 860 IGAP=IGBA,IGBE+1
!
                     DO 850 JJ=ISTA,IEND
!
                        NB1CH = NB1CH + 1
                        JB1GR(NB1CH) = IGB
                        JB1IN(NB1CH) = INDEX(JJ)+IO1
                        JB1O1(NB1CH) = IO1
                        JB1O2(NB1CH) = JJ
!
            CALL REDE00(IBCON1,IBCON2,NB,IB1,IGAP-1,JJ,IPER)
            CALL IDPOST(IBCON2,NB,LBOX2,NSPACE,MSTA,IDIM,X,NX,LBST,
     *                  LBNDET(1,IGB),IACON1,IPOSB)
!
                        JB1PE(NB1CH) = (-1)**IPER
                        JB1PO(NB1CH) = LSPB(IPOSB+NIAS)
                        JB1SY(NB1CH-KBST+1) = LSYMB(IPOSB+NIAS)
!
  850                CONTINUE
!
                  ISTA = IBCON1(IGAP)+1
                  IEND = IBCON1(IGAP+1)-1
                  IF (IGAP.EQ.IGBE) IEND=MSTA(ISPB2+1)-1
  860             CONTINUE
!
  870             LBOX2(ISPB2) = LBOX2(ISPB2) - 1
  880          CONTINUE
!
  885          CONTINUE
!
               LBOX2(ISPB1) = LBOX2(ISPB1) + 1
  890       CONTINUE
!
!  ORDER THESE EXCITATIONS FOR BETA INB ACCORDING TO SYMMETRY.
!
            KNUM = NB1CH - KBST + 1
            CALL FCCSRT22(JB1GR(KBST),JB1PE(KBST),JB1IN(KBST),
     *           JB1PO(KBST),JB1SY,KNUM,
     *           JB1O1(KBST),JB1O2(KBST))
!
!  MAKE THE SYMMETRY STARTING POINTS
! ----
            IST=1
            DO 100 II=1,NSYM
               DO 200 JJ=IST,KNUM
                  IF (JB1SY(JJ).NE.II) GO TO 180
  200          CONTINUE
  180          JB1ST(II+1,INB) = JJ+KBST-1
               IST = JJ
  100       CONTINUE
! ----
!
!  REORDER WITHIN EACH SYMMETRY BY POSITION.
!
            IJST=JB1ST(1,INB)
            DO 300 II=1,NSYM
               JSTA=JB1ST(II,INB)
               JEND=JB1ST(II+1,INB)
               JNUM=JEND-JSTA
               IF (JNUM.LE.1) GO TO 300
               CALL FCCSRT22(JB1GR(JSTA),JB1PE(JSTA),JB1IN(JSTA),
     *              JB1SY(JSTA-IJST+1),JB1PO(JSTA),JNUM,
     *              JB1O1(JSTA),JB1O2(JSTA))
 
  300       CONTINUE
!
            CALL MOVEUP2(LBOX1,NSPACE,NB,MSTA,IBCON1)
  900    CONTINUE
!
         CALL PUSHCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX3,IEND)
!
 1000 CONTINUE
!
      IF (NB1CH.NE.NB1EX) THEN
         WRITE(IW,9000)
         CALL ABRT
         STOP
      ENDIF
      JB1ST(1,IBST+1) = NB1CH+1
!
      RETURN
!
 9000 FORMAT(/1X,'ERROR IN CALCULATION OF SINGLE BETA EXCITES !!! ',
     *           'PANIC !!!!!!'/1X,'CALL JOE AND TELL HIM OFF.')
!
      END
!
!------------------------------------------------------------------------
!========================================================================
!------------------------------------------------------------------------
!*MODULE EXCORR  *DECK FCCSRT22
      SUBROUTINE FCCSRT22(JB1GR,JB1PE,JB1IN,JB1PO,JB1SY,N,
     $     JB1O1,JB1O2)          
      IMPLICIT INTEGER(A-Z)
      DIMENSION JB1GR(N),JB1PE(N),JB1IN(N),JB1PO(N),JB1SY(N),
     $     JB1O1(N),JB1O2(N) 
!
!    SORTING GARBAGE.
!
      IF (N.LT.2) RETURN
      L=N/2+1
      IR=N
!
   10 CONTINUE
         IF (L.GT.1) THEN
            L=L-1
            IRRA=JB1SY(L)
            IRRB=JB1GR(L)
            IRRC=JB1PE(L)
!            IRRD=JB1IN(L)
            IRRE=JB1PO(L)
            IRRF = JB1O1(L)
            IRRG = JB1O2(L)
         ELSE
            IRRA=JB1SY(IR)
            IRRB=JB1GR(IR)
            IRRC=JB1PE(IR)
!            IRRD=JB1IN(IR)
            IRRE=JB1PO(IR)
            IRRF = JB1O1(IR)
            IRRG = JB1O2(IR)

            JB1SY(IR)=JB1SY(1)
            JB1GR(IR)=JB1GR(1)
            JB1PE(IR)=JB1PE(1)
!            JB1IN(IR)=JB1IN(1)
            JB1PO(IR)=JB1PO(1)
            JB1O1(IR) = JB1O1(1)
            JB1O2(IR) = JB1O2(1)
!
            IR=IR-1
            IF (IR.EQ.1) THEN
               JB1SY(1)=IRRA
               JB1GR(1)=IRRB
               JB1PE(1)=IRRC
!               JB1IN(1)=IRRD
               JB1PO(1)=IRRE
               JB1O1(1) = IRRF
               JB1O2(1) = IRRG
!
               GO TO 122
            ENDIF
         ENDIF
         I=L
         J=L+L
   20    IF (J.LE.IR) THEN
            IF (J.LT.IR) THEN
                   IF (JB1SY(J).LT.JB1SY(J+1)) J=J+1
            ENDIF
            IF (IRRA.LT.JB1SY(J)) THEN
               JB1SY(I)=JB1SY(J)
               JB1GR(I)=JB1GR(J)
               JB1PE(I)=JB1PE(J)
!               JB1IN(I)=JB1IN(J)
               JB1PO(I)=JB1PO(J)

           JB1O1(I) = JB1O1(J)
           JB1O2(I) = JB1O2(J)

               I=J
               J=J+J
            ELSE
               J=IR+1
            ENDIF
         GO TO 20
         ENDIF
         JB1SY(I)=IRRA
         JB1GR(I)=IRRB
         JB1PE(I)=IRRC
!         JB1IN(I)=IRRD
         JB1PO(I)=IRRE

         JB1O1(I) = IRRF                                                                
         JB1O2(I) = IRRG

      GO TO 10
!
  122 CONTINUE
!
      RETURN
      END
!------------------------------------------------------------------------
!========================================================================
!------------------------------------------------------------------------
!*MODULE EXCORR  *DECK DIST_DM2
C> @BRIEF      THIS ROUTINE ADDES DM2 ELEMNT TO SPIN-FREE DM2 VECTOR
C> 
C> @AUTHOR     LUKE ROSKOP
C>             -2013
C> 
C> @DETAILS    THIS ROUTINE ADDS DM2 ELEMNT TO DM2 VECTOR
C> 
C> @DATE 2/11/13-LUKE ROSKOP
C> -NEW ROUNTINE TO ADDED DM ELEMENT TO VECTOR DM2
C>
C> @PARAM I ORBITAL INDEX
C> @PARAM J ORBITAL INDEX
C> @PARAM K ORBITAL INDEX
C> @PARAM L ORBITAL INDEX
C> @PARAM N1 HYPERCUBE OFFSET
C> @PARAM N2 HYPERCUBE OFFSET
C> @PARAM N3 HYPERCUBE OFFSET
C> @PARAM MIN MINIMUM RANGE OF PROCESSED DM2
C> @PARAM MAX MAXIMUM RANGE OF PROCESSES DM2
C> @PARAM ELEMENT ELEMENT TO BE ADDED TO DM2
C> @PARAM DM2 SPIN-FREE TWO-PARTICLE DENSITY MATRIX
      SUBROUTINE DIST_DM2(I,J,K,L,N1,N2,N3,MIN,MAX,ELEMENT,DM2)
      IMPLICIT NONE
!// PASSED IN
      INTEGER I,J,K,L,N1,N2,N3,MIN,MAX
      DOUBLE PRECISION ELEMENT,DM2(*)
!// LOCAL
      INTEGER POS
!//      
!// FIGURE OUT GLOBAL POSTION (-1) OF DM ELEMENT IN HYPERCUBE
      POS = I-1 + (J-1)*N1 + (K-1)*N2 + (L-1)*N3
!//
!// FIGURE OUT WHEATHER POS IS IN THE RANGE OF THE PROCESSES DM2 CHUNK
      IF(POS.LT.MIN.OR.POS.GT.MAX)RETURN
!//
!// GET POSITION RELATIVE TO PROCESSES LOCAL CHUNK AND ADD ELEMENT TO DM2      
      POS = POS -MIN +1
      DM2(POS) = DM2(POS) + ELEMENT
!//
      RETURN
!//
      END SUBROUTINE DIST_DM2
!------------------------------------------------------------------------
!========================================================================
!------------------------------------------------------------------------
!*MODULE EXCORR  *DECK DIST_DM2_M
C> @BRIEF      THIS ROUTINE ADDES DM2 ELEMNT TO SPIN-FREE DM2 VECTOR
C> 
C> @AUTHOR     LUKE ROSKOP
C>             -2013
C> 
C> @DETAILS    THIS ROUTINE ADDS DM2 ELEMNT TO DM2 VECTOR
C> 
C> @DATE 2/26/13-LUKE ROSKOP
C> -NEW ROUNTINE TO ADDED DM ELEMENT TO VECTOR DM2
C>
C> @PARAM I ORBITAL INDEX
C> @PARAM J ORBITAL INDEX
C> @PARAM K ORBITAL INDEX
C> @PARAM L ORBITAL INDEX
C> @PARAM N1 HYPERCUBE OFFSET
C> @PARAM N2 HYPERCUBE OFFSET
C> @PARAM N3 HYPERCUBE OFFSET
C> @PARAM MIN MINIMUM RANGE OF PROCESSED DM2
C> @PARAM MAX MAXIMUM RANGE OF PROCESSES DM2
C> @PARAM ELEMENT ELEMENT TO BE ADDED TO DM2
C> @PARAM DM2 SPIN-FREE TWO-PARTICLE DENSITY MATRIX
      SUBROUTINE DIST_DM2_M(I,J,K,L,N1,N2,N3,MIN,MAX,ELEMENT,DM2)
      IMPLICIT NONE
!// PASSED IN
      INTEGER I,J,K,L,N1,N2,N3,MIN,MAX
      DOUBLE PRECISION ELEMENT,DM2(*)
!// LOCAL
      INTEGER POS
!//      
!// FIGURE OUT GLOBAL POSTION (-1) OF DM ELEMENT IN HYPERCUBE
!      POS = I-1 + (J-1)*N1 + (K-1)*N2 + (L-1)*N3
      POS = (I-1)*N3 + (J-1)*N2 + (K-1)*N1 + (L-1)
!//
!// GET POSITION RELATIVE TO PROCESSES LOCAL CHUNK AND ADD ELEMENT TO DM2      
      POS = POS -MIN +1
      DM2(POS) = DM2(POS) + ELEMENT
!//
      RETURN
!//
      END SUBROUTINE DIST_DM2_M
!------------------------------------------------------------------------
!========================================================================
!------------------------------------------------------------------------
!*MODULE EXCORR  *DECK D_DM2_TERM_1
C> @BRIEF      THIS ROUTINE ADDES DM2 ELEMNT TO SPIN-FREE DM2 VECTOR
C> 
C> @AUTHOR     LUKE ROSKOP
C>             -2013
C> 
C> @DETAILS    THIS ROUTINE ADDS DM2 ELEMNT TO DM2 VECTOR
C> 
C> @DATE 2/26/13-LUKE ROSKOP
C> -NEW ROUNTINE TO ADDED DM ELEMENT TO VECTOR DM2
C>
C> @PARAM I ORBITAL INDEX
C> @PARAM J ORBITAL INDEX
C> @PARAM K ORBITAL INDEX
C> @PARAM L ORBITAL INDEX
C> @PARAM N1 HYPERCUBE OFFSET
C> @PARAM N2 HYPERCUBE OFFSET
C> @PARAM N3 HYPERCUBE OFFSET
C> @PARAM MIN_R MINIMUM RANGE OF PROCESSED DM2
C> @PARAM MAX_R MAXIMUM RANGE OF PROCESSES DM2
C> @PARAM D_FDM2 SPIN-FREE TWO-PARTICLE DENSITY MATRIX
C> @PARAM ITGB TOTAL NUMBER OF BETA GROUPS
C> @PARAM LGCOM ALLOW ALPHA/BETA GROUP COMPBINATIONS
C> @PARAM IGA ALPHA GROUP INDEX
C> @PARAM IGA2 ALPHA' GROUP INDEX
C> @PARAM JPZA1 STARTING POSITION OF ALPHA STRING
C> @PARAM JPZA2 STARTING POSITION OF ALPHA STRING
C> @PARAM LDISB DISPLACEMENT POSITION ARRAY
C> @PARAM NSYM NUMBER OF IRREPS
C> @PARAM KSYM IRREP OF CURRENT STRING
C> @PARAM LSBS SYMMETRY ARRAY
C> @PARAM NXTW NUMBER OF STATES TO WEIGHT
C> @PARAM WSTATE STATE WEIGHT
C> @PARAM AB CI VECTOR
C> @PARAM IPER3 PERMUTATION SYMMETRY
C> @PARAM IWTS WHICH STATES TO WEIGHT ARRAY
C> @PARAM NCI NUMBER DETERMINANTS
      SUBROUTINE D_DM2_TERM_1(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,D_FDM2,NXTW
     $     ,IWTS,KPER1,NCI,WSTATE,AB,LSBS,NSYM,KSYM,ITGB,LGCOM,IGA,IGA2,
     $     JPZA1,JPZA2,LDISB)
      IMPLICIT NONE      
!PASSED IN VARIABLES
      INTEGER I,J,K,L,N1,N2,N3,MIN_R,MAX_R,NXTW,IWTS(*),KPER1,NCI,
     $     LSBS(NSYM+1,*),NSYM,KSYM,ITGB,LGCOM(ITGB,*),IGA,IGA2,JPZA1,
     $     JPZA2,LDISB(NSYM,ITGB,*)
      DOUBLE PRECISION D_FDM2(*),WSTATE(*),AB(NCI,*)
!LOCAL VARIABLES
      INTEGER IGB,JCI1,JCI2,KKB,KKI
      DOUBLE PRECISION F_FC

      DO IGB=1,ITGB
         IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB,IGA2).NE.1)CYCLE
         JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
         JCI2 = JPZA2 + LDISB(KSYM,IGB,IGA2)
!     
         DO KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
            JCI1 = JCI1 + 1
            JCI2 = JCI2 + 1
            F_FC = 0.0D+00
            DO KKI=1,NXTW
               F_FC = F_FC+ WSTATE(IWTS(KKI))*AB(JCI1,KKI)*AB(JCI2,KKI)
            ENDDO
!     F_FC = F_FC*KPER1
            F_FC = F_FC*KPER1/2.0D+00
            
!A A2 -> A2 A'  WHERE: A'.GT.A    A2.NE.A
C$$$                 FDM2(JJ,ION,ION,IO1) =FDM2(JJ,ION,ION,IO1) +F_FC
C$$$                 FDM2(ION,JJ,IO1,ION) =FDM2(ION,JJ,IO1,ION) +F_FC
C$$$                 FDM2(JJ,ION,IO1,ION) =FDM2(JJ,ION,IO1,ION) -F_FC
C$$$                 FDM2(ION,JJ,ION,IO1) =FDM2(ION,JJ,ION,IO1) -F_FC
C$$$!------------ (DE)EXITE BELOW
C$$$                 FDM2(IO1,ION,ION,JJ) =FDM2(IO1,ION,ION,JJ) +F_FC
C$$$                 FDM2(ION,IO1,JJ,ION) =FDM2(ION,IO1,JJ,ION) +F_FC
C$$$                 FDM2(IO1,ION,JJ,ION) =FDM2(IO1,ION,JJ,ION) -F_FC
C$$$                 FDM2(ION,IO1,ION,JJ) =FDM2(ION,IO1,ION,JJ) -F_FC

C$$$!      CALL DIST_DM2_M(JJ,ION,ION,IO1,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$      CALL DIST_DM2_M(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$
C$$$!      CALL DIST_DM2_M(ION,JJ,IO1,ION,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$      CALL DIST_DM2_M(J,I,L,K,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$
C$$$!      CALL DIST_DM2_M(JJ,ION,IO1,ION,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)
C$$$      CALL DIST_DM2_M(I,J,L,K,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)
C$$$
C$$$!      CALL DIST_DM2_M(ION,JJ,ION,IO1,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)
C$$$      CALL DIST_DM2_M(J,I,K,L,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)
C$$$
C$$$
C$$$            
C$$$!      CALL DIST_DM2_M(IO1,ION,ION,JJ,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$      CALL DIST_DM2_M(L,K,J,I,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$
C$$$!      CALL DIST_DM2_M(ION,IO1,JJ,ION,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$      CALL DIST_DM2_M(K,L,I,J,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$
C$$$!      CALL DIST_DM2_M(IO1,ION,JJ,ION,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)
C$$$      CALL DIST_DM2_M(L,K,I,J,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)
C$$$
C$$$!      CALL DIST_DM2_M(ION,IO1,ION,JJ,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)
C$$$      CALL DIST_DM2_M(K,L,J,I,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)

      CALL DIST_DM2_M(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)            
      CALL DIST_DM2_M(I,J,L,K,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)
         ENDDO                  !KKB
!     
      ENDDO                     !IGB
      RETURN
      END SUBROUTINE D_DM2_TERM_1
!------------------------------------------------------------------------
!========================================================================
!------------------------------------------------------------------------
!*MODULE EXCORR  *DECK D_DM2_TERM_3
C> @BRIEF      THIS ROUTINE ADDES DM2 ELEMNT TO SPIN-FREE DM2 VECTOR
C> 
C> @AUTHOR     LUKE ROSKOP
C>             -2013
C> 
C> @DETAILS    THIS ROUTINE ADDS DM2 ELEMNT TO DM2 VECTOR
C> 
C> @DATE 2/26/13-LUKE ROSKOP
C> -NEW ROUNTINE TO ADDED DM ELEMENT TO VECTOR DM2
C>
C> @PARAM I ORBITAL INDEX
C> @PARAM J ORBITAL INDEX
C> @PARAM K ORBITAL INDEX
C> @PARAM L ORBITAL INDEX
C> @PARAM N1 HYPERCUBE OFFSET
C> @PARAM N2 HYPERCUBE OFFSET
C> @PARAM N3 HYPERCUBE OFFSET
C> @PARAM MIN_R MINIMUM RANGE OF PROCESSED DM2
C> @PARAM MAX_R MAXIMUM RANGE OF PROCESSES DM2
C> @PARAM D_FDM2 SPIN-FREE TWO-PARTICLE DENSITY MATRIX
C> @PARAM ITGB TOTAL NUMBER OF BETA GROUPS
C> @PARAM LGCOM ALLOW ALPHA/BETA GROUP COMPBINATIONS
C> @PARAM IGA ALPHA GROUP INDEX
C> @PARAM IGA3 ALPHA' GROUP INDEX
C> @PARAM JPZA1 STARTING POSITION OF ALPHA STRING
C> @PARAM LDISB DISPLACEMENT POSITION ARRAY
C> @PARAM NSYM NUMBER OF IRREPS
C> @PARAM KSYM IRREP OF CURRENT STRING
C> @PARAM LSBS SYMMETRY ARRAY
C> @PARAM NXTW NUMBER OF STATES TO WEIGHT
C> @PARAM WSTATE STATE WEIGHT
C> @PARAM AB CI VECTOR
C> @PARAM IPER3 PERMUTATION SYMMETRY
C> @PARAM IWTS WHICH STATES TO WEIGHT ARRAY
C> @PARAM NCI NUMBER DETERMINANTS
C> @PARAM JPZA3 STARTING POSITION OF STRING
      SUBROUTINE D_DM2_TERM_3(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,
     $     D_FDM2,ITGB,LGCOM,IGA,IGA3,JPZA1,LDISB,NSYM,KSYM,LSBS,NXTW,
     $     WSTATE,AB,IPER3,IWTS,NCI,JPZA3)
      IMPLICIT NONE      
!PASSED IN VARIABLES/ARRAYS
      INTEGER I,J,K,L,N1,N2,N3,MIN_R,MAX_R,ITGB,LGCOM(ITGB,*),IGA,IGA3,
     $     JPZA1,JPZA3,LDISB(NSYM,ITGB,*),KSYM,LSBS(NSYM+1,*),NXTW,
     $     IWTS(*),IPER3,NSYM,NCI
      DOUBLE PRECISION D_FDM2(*),WSTATE(*),AB(NCI,*)
!LOCAL VAIABLES
      INTEGER IGB,JCI1,JCI3,KKB,KKI
      DOUBLE PRECISION F_FC

      DO IGB=1,ITGB
         IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB,IGA3).NE.1) CYCLE
         JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
         JCI3 = JPZA3 + LDISB(KSYM,IGB,IGA3) !

         DO KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
            JCI1 = JCI1 + 1
            JCI3 = JCI3 + 1
     
            F_FC = 0.0D+00
            DO KKI=1,NXTW
               F_FC = F_FC + WSTATE(IWTS(KKI))*AB(JCI1,KKI)*AB(JCI3,KKI)
            ENDDO
            F_FC = F_FC*IPER3/2.0D+00
            
! A A2 --> A'2 A'    A' > A    A'2 > A2    A2 > A    A'2 > A'
C$$$                 FDM2(JJ,JJ3,IO3,IO1) =FDM2(JJ,JJ3,IO3,IO1) +F_FC
C$$$                 FDM2(JJ3,JJ,IO1,IO3) =FDM2(JJ3,JJ,IO1,IO3) +F_FC
C$$$                 FDM2(JJ,JJ3,IO1,IO3) =FDM2(JJ,JJ3,IO1,IO3) -F_FC
C$$$                 FDM2(JJ3,JJ,IO3,IO1) =FDM2(JJ3,JJ,IO3,IO1) -F_FC
C$$$!--------------- (DE)DOWN BELOW
C$$$                 FDM2(IO1,IO3,JJ3,JJ) =FDM2(IO1,IO3,JJ3,JJ) +F_FC
C$$$                 FDM2(IO3,IO1,JJ,JJ3) =FDM2(IO3,IO1,JJ,JJ3) +F_FC
C$$$                 FDM2(IO1,IO3,JJ,JJ3) =FDM2(IO1,IO3,JJ,JJ3) -F_FC
C$$$                 FDM2(IO3,IO1,JJ3,JJ) =FDM2(IO3,IO1,JJ3,JJ) -F_FC

C$$$       CALL DIST_DM2(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$       CALL DIST_DM2(J,I,L,K,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$       CALL DIST_DM2(I,J,L,K,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)
C$$$       CALL DIST_DM2(J,I,K,L,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)
C$$$
C$$$       CALL DIST_DM2(L,K,J,I,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$       CALL DIST_DM2(K,L,I,J,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$       CALL DIST_DM2(L,K,I,J,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)
C$$$       CALL DIST_DM2(K,L,J,I,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)

            CALL DIST_DM2_M(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
            CALL DIST_DM2_M(I,J,L,K,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)

         ENDDO !KKB

      ENDDO !IGB

      RETURN
      END SUBROUTINE D_DM2_TERM_3
!------------------------------------------------------------------------
!========================================================================
!------------------------------------------------------------------------
!*MODULE EXCORR  *DECK D_DM2_TERM_4
C> @BRIEF      THIS ROUTINE ADDES DM2 ELEMNT TO SPIN-FREE DM2 VECTOR
C> 
C> @AUTHOR     LUKE ROSKOP
C>             -2013
C> 
C> @DETAILS    THIS ROUTINE ADDS DM2 ELEMNT TO DM2 VECTOR
C> 
C> @DATE 2/26/13-LUKE ROSKOP
C> -NEW ROUNTINE TO ADDED DM ELEMENT TO VECTOR DM2
C>
C> @PARAM I ORBITAL INDEX
C> @PARAM J ORBITAL INDEX
C> @PARAM K ORBITAL INDEX
C> @PARAM L ORBITAL INDEX
C> @PARAM N1 HYPERCUBE OFFSET
C> @PARAM N2 HYPERCUBE OFFSET
C> @PARAM N3 HYPERCUBE OFFSET
C> @PARAM MIN_R MINIMUM RANGE OF PROCESSED DM2
C> @PARAM MAX_R MAXIMUM RANGE OF PROCESSES DM2
C> @PARAM D_FDM2 SPIN-FREE TWO-PARTICLE DENSITY MATRIX
C> @PARAM ITGB TOTAL NUMBER OF BETA GROUPS
C> @PARAM LGCOM ALLOW ALPHA/BETA GROUP COMPBINATIONS
C> @PARAM IGA ALPHA GROUP INDEX
C> @PARAM JCI1 STARTING POSITION OF ALPHA STRING
C> @PARAM LDISB DISPLACEMENT POSITION ARRAY
C> @PARAM NSYM NUMBER OF IRREPS
C> @PARAM KSYM IRREP OF CURRENT STRING
C> @PARAM LSBS SYMMETRY ARRAY
C> @PARAM NXTW NUMBER OF STATES TO WEIGHT
C> @PARAM WSTATE STATE WEIGHT
C> @PARAM AB CI VECTOR
C> @PARAM IWTS WHICH STATES TO WEIGHT ARRAY
C> @PARAM NCI NUMBER DETERMINANTS
C> @PARAM JPZA1 STARTING POSITION OF STRING
      SUBROUTINE D_DM2_TERM_4(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,D_FDM2,
     $     WSTATE,IWTS,AB,NCI,NXTW,JCI1,ITGB,LGCOM,IGA,KSYM,LDISB,
     $     JPZA1,LSBS,NSYM)
      IMPLICIT NONE
!PASSED IN VARIABLE/ARRAYS
      INTEGER I,J,K,L,N1,N2,N3,MIN_R,MAX_R,NXTW,IWTS(*),NCI,ITGB,
     $     LGCOM(ITGB,*),IGA,KSYM,LDISB(NSYM,ITGB,*),JPZA1,
     $     LSBS(NSYM+1,*),NSYM,KKB
      DOUBLE PRECISION D_FDM2(*),WSTATE(*),AB(NCI,*)
!LOCAL VARIABLE
      INTEGER IGB,JCI1,KKI
      DOUBLE PRECISION F_FC

      DO IGB=1,ITGB
         IF (LGCOM(IGB,IGA).NE.1) CYCLE
         JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)

         DO KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
            JCI1 = JCI1 + 1
            
            F_FC = 0.0D+00
            DO KKI=1,NXTW
               F_FC = F_FC + WSTATE(IWTS(KKI))*AB(JCI1,KKI)*AB(JCI1,KKI)
            ENDDO

!A A2 -> A A2
C$$$                 FDM2(I2,I1,I1,I2) =FDM2(I2,I1,I1,I2) +F_FC
C$$$                 FDM2(I2,I1,I2,I1) =FDM2(I2,I1,I2,I1) -F_FC
C$$$                 FDM2(I1,I2,I2,I1) =FDM2(I1,I2,I2,I1) +F_FC
C$$$                 FDM2(I1,I2,I1,I2) =FDM2(I1,I2,I1,I2) -F_FC

C$$$            CALL DIST_DM2(I2,I1,I1,I2,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$            CALL DIST_DM2(I2,I1,I2,I1,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)
C$$$
C$$$            CALL DIST_DM2(I1,I2,I2,I1,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$            CALL DIST_DM2(I1,I2,I1,I2,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)

C$$$            CALL DIST_DM2(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$            CALL DIST_DM2(I,J,L,K,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)
C$$$
C$$$            CALL DIST_DM2(J,I,L,K,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$            CALL DIST_DM2(J,I,K,L,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)

            CALL DIST_DM2_M(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
            CALL DIST_DM2_M(I,J,L,K,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)

         ENDDO !KKB
!
      ENDDO !IGB

      RETURN

      END SUBROUTINE D_DM2_TERM_4
!------------------------------------------------------------------------
!========================================================================
!------------------------------------------------------------------------
!*MODULE EXCORR  *DECK D_DM2_TERM_5
C> @BRIEF      THIS ROUTINE ADDES DM2 ELEMNT TO SPIN-FREE DM2 VECTOR
C> 
C> @AUTHOR     LUKE ROSKOP
C>             -2013
C> 
C> @DETAILS    THIS ROUTINE ADDS DM2 ELEMNT TO DM2 VECTOR
C> 
C> @DATE 2/26/13-LUKE ROSKOP
C> -NEW ROUNTINE TO ADDED DM ELEMENT TO VECTOR DM2
C>
C> @PARAM I ORBITAL INDEX
C> @PARAM J ORBITAL INDEX
C> @PARAM K ORBITAL INDEX
C> @PARAM L ORBITAL INDEX
C> @PARAM N1 HYPERCUBE OFFSET
C> @PARAM N2 HYPERCUBE OFFSET
C> @PARAM N3 HYPERCUBE OFFSET
C> @PARAM MIN_R MINIMUM RANGE OF PROCESSED DM2
C> @PARAM MAX_R MAXIMUM RANGE OF PROCESSES DM2
C> @PARAM D_FDM2 SPIN-FREE TWO-PARTICLE DENSITY MATRIX
C> @PARAM NXTW NUMBER OF STATES TO WEIGHT
C> @PARAM WSTATE STATE WEIGHT
C> @PARAM AB CI VECTOR
C> @PARAM IWTS WHICH STATES TO WEIGHT ARRAY
C> @PARAM NCI NUMBER DETERMINANTS
C> @PARAM LABPOS START POSITION
C> @PARAM JCIB STRING POSITON
C> @PARAM QJPER PERMUTATION SYMMETRY
C> @PARAM JPERAE PERMUTATION SYMMETRY
      SUBROUTINE D_DM2_TERM_5(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,D_FDM2,
     $     NXTW,WSTATE,IWTS,AB,LABPOS,JPERAE,QJPER,NCI,JCIB)
      IMPLICIT NONE
!PASSED IN VARIABLE/ARRAYS
      INTEGER I,J,K,L,N1,N2,N3,MIN_R,MAX_R,NXTW,IWTS(*),LABPOS,JPERAE,
     $     NCI,JCIB
      DOUBLE PRECISION D_FDM2(*),WSTATE(*),AB(NCI,*),QJPER
!LOCAL VARIABLES
      INTEGER KKI
      DOUBLE PRECISION F_FC

      F_FC = 0.0D+00
      DO KKI=1,NXTW
         F_FC = F_FC + WSTATE(IWTS(KKI))*AB(LABPOS,KKI)*AB(JCIB,KKI)
      ENDDO
      F_FC = F_FC*JPERAE*QJPER/2.0D+00

C$$$      CALL DIST_DM2(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$      CALL DIST_DM2(J,I,L,K,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$      CALL DIST_DM2(K,L,I,J,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$      CALL DIST_DM2(L,K,J,I,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)

      CALL DIST_DM2_M(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)

      RETURN
      END SUBROUTINE D_DM2_TERM_5
!------------------------------------------------------------------------
!========================================================================
!------------------------------------------------------------------------
!*MODULE EXCORR  *DECK D_DM2_TERM_6
C> @BRIEF      THIS ROUTINE ADDES DM2 ELEMNT TO SPIN-FREE DM2 VECTOR
C> 
C> @AUTHOR     LUKE ROSKOP
C>             -2013
C> 
C> @DETAILS    THIS ROUTINE ADDS DM2 ELEMNT TO DM2 VECTOR
C> 
C> @DATE 2/26/13-LUKE ROSKOP
C> -NEW ROUNTINE TO ADDED DM ELEMENT TO VECTOR DM2
C>
C> @PARAM I ORBITAL INDEX
C> @PARAM J ORBITAL INDEX
C> @PARAM K ORBITAL INDEX
C> @PARAM L ORBITAL INDEX
C> @PARAM N1 HYPERCUBE OFFSET
C> @PARAM N2 HYPERCUBE OFFSET
C> @PARAM N3 HYPERCUBE OFFSET
C> @PARAM MIN_R MINIMUM RANGE OF PROCESSED DM2
C> @PARAM MAX_R MAXIMUM RANGE OF PROCESSES DM2
C> @PARAM D_FDM2 SPIN-FREE TWO-PARTICLE DENSITY MATRIX
C> @PARAM NXTW NUMBER OF STATES TO WEIGHT
C> @PARAM WSTATE STATE WEIGHT
C> @PARAM AB CI VECTOR
C> @PARAM IWTS WHICH STATES TO WEIGHT ARRAY
C> @PARAM JBINDX BETA STRING INDEX
C> @PARAM JB1P0 POSITON MATRIX
C> @PARAM NCI NUMBER DETERMINANTS
C> @PARAM JPOSAE START POSITION
C> @PARAM LABPOS STRING POSITON
C> @PARAM JPERAE PERMUTATION SYMMETRY
C> @PARAM JP1PE PERMUTATION SYMMETRY
      SUBROUTINE D_DM2_TERM_6(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,D_FDM2,
     $     JPOSAE,JB1PO,JBINDX,NXTW,IWTS,WSTATE,AB,LABPOS,
     $     JPERAE,NCI,JB1PE)
      IMPLICIT NONE
!PASSED IN VARIABLES/ARRAYS
      INTEGER I,J,K,L,N1,N2,N3,MIN_R,MAX_R,JPOSAE,JB1PO(*),
     $     NXTW,IWTS(*),LABPOS,JPERAE,NCI,JB1PE(*),JBINDX
      DOUBLE PRECISION D_FDM2(*),AB(NCI,*),WSTATE(*)
!LOCAL INTEGERS
      INTEGER JCIB,KKI
      DOUBLE PRECISION F_FC

      JCIB = JPOSAE+JB1PO(JBINDX)
!                  JCIB2 = JPZA1+JB1PO(JBINDX)
      F_FC = 0.0D+00
!                  F_FC1 = 0.0D+00
      DO KKI=1,NXTW
         F_FC = F_FC + WSTATE(IWTS(KKI))*AB(LABPOS,KKI)*AB(JCIB,KKI)
!          F_FC1 =F_FC1+ WSTATE(IWTS(KKI))*AB(LABPOS2,KKI)*AB(JCIB2,KKI)
      ENDDO
      F_FC = F_FC*JPERAE*JB1PE(JBINDX)/2.0D+00
!                  F_FC1 = F_FC1*JPERAE*JB1PE(JBINDX)/2.0D+00

C$$$      CALL DIST_DM2(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,F_FC,
C$$$     $                 D_FDM2)
C$$$      CALL DIST_DM2(J,I,L,K,N1,N2,N3,MIN_R,MAX_R,F_FC,
C$$$     $     D_FDM2)
C$$$      CALL DIST_DM2(K,L,I,J,N1,N2,N3,MIN_R,MAX_R,F_FC,
C$$$     $     D_FDM2)
C$$$      CALL DIST_DM2(L,K,J,I,N1,N2,N3,MIN_R,MAX_R,F_FC,
C$$$     $     D_FDM2)
C$$$
C$$$      CALL DIST_DM2(I,K,J,L,N1,N2,N3,MIN_R,MAX_R,F_FC1,
C$$$     $     D_FDM2)
C$$$      CALL DIST_DM2(K,I,L,J,N1,N2,N3,MIN_R,MAX_R,F_FC1,
C$$$     $     D_FDM2)
C$$$      CALL DIST_DM2(J,L,I,K,N1,N2,N3,MIN_R,MAX_R,F_FC1,
C$$$     $     D_FDM2)
C$$$      CALL DIST_DM2(L,J,K,I,N1,N2,N3,MIN_R,MAX_R,F_FC1,
C$$$     $     D_FDM2)

      CALL DIST_DM2_M(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)

      RETURN
      END SUBROUTINE D_DM2_TERM_6
!------------------------------------------------------------------------
!========================================================================
!------------------------------------------------------------------------
!*MODULE EXCORR  *DECK D_DM2_TERM_7
C> @BRIEF      THIS ROUTINE ADDES DM2 ELEMNT TO SPIN-FREE DM2 VECTOR
C> 
C> @AUTHOR     LUKE ROSKOP
C>             -2013
C> 
C> @DETAILS    THIS ROUTINE ADDS DM2 ELEMNT TO DM2 VECTOR
C> 
C> @DATE 2/26/13-LUKE ROSKOP
C> -NEW ROUNTINE TO ADDED DM ELEMENT TO VECTOR DM2
C>
C> @PARAM I ORBITAL INDEX
C> @PARAM J ORBITAL INDEX
C> @PARAM K ORBITAL INDEX
C> @PARAM L ORBITAL INDEX
C> @PARAM N1 HYPERCUBE OFFSET
C> @PARAM N2 HYPERCUBE OFFSET
C> @PARAM N3 HYPERCUBE OFFSET
C> @PARAM MIN_R MINIMUM RANGE OF PROCESSED DM2
C> @PARAM MAX_R MAXIMUM RANGE OF PROCESSES DM2
C> @PARAM D_FDM2 SPIN-FREE TWO-PARTICLE DENSITY MATRIX
C> @PARAM NXTW NUMBER OF STATES TO WEIGHT
C> @PARAM WSTATE STATE WEIGHT
C> @PARAM AB CI VECTOR
C> @PARAM IWTS WHICH STATES TO WEIGHT ARRAY
C> @PARAM JPZB2 OFFSET
C> @PARAM JPZB1 OFFSET
C> @PARAM NCI NUMBER DETERMINANTS
C> @PARAM IGB2 BETA GROUP
C> @PARAM LSAS SYMMETRY INFORMATION
C> @PARAM LSAC SYMMETRY INFORMATION
C> @PARAM JPERAE PERMUTATION SYMMETRY
C> @PARAM JP1PE PERMUTATION SYMMETRY
C> @PARAM KPER1 PERMUTATION SYMMETRY
C> @PARAM ITGB NUMBER OF ALPHA GROUPS
C> @PARAM NYSM NUMBER OF IRREPS
C> @PARAM LSPA STARTING POSITON OF ALPHA STRING
C> @PARAM LGCOM ALPHA/BETA GROUP COMBINATION MATRIX
C> @PARAM KBSYM SYMMETRY OF STRING
C> @PARAM IGB BETA GROUP
C> @PARAM NAST NUMBOER OF ALPHA STRING IN ALPHA GROUP
      SUBROUTINE D_DM2_TERM_7(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,D_FDM2,NXTW,
     $     WSTATE,IWTS,AB,KPER1,NCI,ITGA,LGCOM,LDISB,NSYM,KBSYM,IGB,
     $     IGB2,JPZB1,JPZB2,NAST,LSAS,KSYM,LSAC,LSPA,ITGB)
      IMPLICIT NONE
!PASSED IN VARIABLE/ARRAYS
      INTEGER I,J,K,L,N1,N2,N3,MIN_R,MAX_R,NXTW,IWTS(*),KPER1,NCI,ITGA,
     $     ITGB,LGCOM(ITGB,*),LDISB(NSYM,ITGB,*),KBSYM,IGB,IGB2,JPZB1,
     $     JPZB2,NAST(*),LSAS(NSYM+1,*),LSAC(*),LSPA(*),NSYM,KSYM
      DOUBLE PRECISION D_FDM2(*),WSTATE(*),AB(NCI,*)
!LOCAL VARIABLES
      INTEGER KKI,IGA,JCIB1,JCIB2,NIAS,KKA,IENA1,JCIA,JCI1,JCI2
      DOUBLE PRECISION F_FC

      DO 7710 IGA=1,ITGA
         IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB2,IGA).NE.1) GOTO 7710
         JCIB1 = LDISB(KBSYM,IGB,IGA) + JPZB1
         JCIB2 = LDISB(KBSYM,IGB2,IGA) + JPZB2
         NIAS = NAST(IGA)
!     
         DO 7695 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
            IENA1 = LSAC(KKA)
            JCIA = LSPA(NIAS+IENA1)
            JCI1 = JCIA + JCIB1
            JCI2 = JCIA + JCIB2
            
            F_FC = 0.0D+00
            DO KKI=1,NXTW
               F_FC = F_FC + WSTATE(IWTS(KKI))*AB(JCI1,KKI)*AB(JCI2,KKI)
            ENDDO
            F_FC = F_FC*KPER1/2.0D+00
            
C$$$            CALL DIST_DM2(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$            CALL DIST_DM2(J,I,L,K,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$            CALL DIST_DM2(I,J,L,K,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)
C$$$            CALL DIST_DM2(J,I,K,L,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)
C$$$            
C$$$            CALL DIST_DM2(L,K,J,I,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$            CALL DIST_DM2(K,L,I,J,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$            CALL DIST_DM2(L,K,I,J,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)
C$$$            CALL DIST_DM2(K,L,J,I,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)

            CALL DIST_DM2_M(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)            
            CALL DIST_DM2_M(I,J,L,K,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)

 7695         CONTINUE
!     
 7710         CONTINUE


      RETURN
      END SUBROUTINE D_DM2_TERM_7
!------------------------------------------------------------------------
!========================================================================
!------------------------------------------------------------------------
!*MODULE EXCORR  *DECK D_DM2_TERM_8
C> @BRIEF      THIS ROUTINE ADDES DM2 ELEMNT TO SPIN-FREE DM2 VECTOR
C> 
C> @AUTHOR     LUKE ROSKOP
C>             -2013
C> 
C> @DETAILS    THIS ROUTINE ADDS DM2 ELEMNT TO DM2 VECTOR
C> 
C> @DATE 2/26/13-LUKE ROSKOP
C> -NEW ROUNTINE TO ADDED DM ELEMENT TO VECTOR DM2
C>
C> @PARAM I ORBITAL INDEX
C> @PARAM J ORBITAL INDEX
C> @PARAM K ORBITAL INDEX
C> @PARAM L ORBITAL INDEX
C> @PARAM N1 HYPERCUBE OFFSET
C> @PARAM N2 HYPERCUBE OFFSET
C> @PARAM N3 HYPERCUBE OFFSET
C> @PARAM MIN_R MINIMUM RANGE OF PROCESSED DM2
C> @PARAM MAX_R MAXIMUM RANGE OF PROCESSES DM2
C> @PARAM D_FDM2 SPIN-FREE TWO-PARTICLE DENSITY MATRIX
      SUBROUTINE D_DM2_TERM_8(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,D_FDM2,F_FC)
      IMPLICIT NONE
!PASSED IN VARIABLE/ARRAYS
      INTEGER I,J,K,L,N1,N2,N3,MIN_R,MAX_R
      DOUBLE PRECISION F_FC,D_FDM2(*)

C$$$      CALL DIST_DM2(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$      CALL DIST_DM2(J,I,L,K,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$      CALL DIST_DM2(L,K,J,I,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
C$$$      CALL DIST_DM2(K,L,I,J,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)

      CALL DIST_DM2_M(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)

      RETURN
      END SUBROUTINE D_DM2_TERM_8
!------------------------------------------------------------------------
!========================================================================
!------------------------------------------------------------------------
!*MODULE EXCORR  *DECK D_DM2_TERM_9
C> @BRIEF      THIS ROUTINE ADDES DM2 ELEMNT TO SPIN-FREE DM2 VECTOR
C> 
C> @AUTHOR     LUKE ROSKOP
C>             -2013
C> 
C> @DETAILS    THIS ROUTINE ADDS DM2 ELEMNT TO DM2 VECTOR
C> 
C> @DATE 2/26/13-LUKE ROSKOP
C> -NEW ROUNTINE TO ADDED DM ELEMENT TO VECTOR DM2
C>
C> @PARAM I ORBITAL INDEX
C> @PARAM J ORBITAL INDEX
C> @PARAM K ORBITAL INDEX
C> @PARAM L ORBITAL INDEX
C> @PARAM N1 HYPERCUBE OFFSET
C> @PARAM N2 HYPERCUBE OFFSET
C> @PARAM N3 HYPERCUBE OFFSET
C> @PARAM MIN_R MINIMUM RANGE OF PROCESSED DM2
C> @PARAM MAX_R MAXIMUM RANGE OF PROCESSES DM2
C> @PARAM D_FDM2 SPIN-FREE TWO-PARTICLE DENSITY MATRIX
C> @PARAM NXTW NUMBER OF STATES TO WEIGHT
C> @PARAM WSTATE STATE WEIGHT
C> @PARAM AB CI VECTOR
C> @PARAM IWTS WHICH STATES TO WEIGHT ARRAY
C> @PARAM JPZB2 OFFSET
C> @PARAM JPZB1 OFFSET
C> @PARAM NCI NUMBER DETERMINANTS
C> @PARAM IGB2 BETA GROUP
C> @PARAM LSAS SYMMETRY INFORMATION
C> @PARAM LSAC SYMMETRY INFORMATION
C> @PARAM JPERAE PERMUTATION SYMMETRY
C> @PARAM JP1PE PERMUTATION SYMMETRY
C> @PARAM KPER1 PERMUTATION SYMMETRY
C> @PARAM ITGB NUMBER OF ALPHA GROUPS
C> @PARAM NYSM NUMBER OF IRREPS
C> @PARAM LSPA STARTING POSITON OF ALPHA STRING
C> @PARAM LGCOM ALPHA/BETA GROUP COMBINATION MATRIX
C> @PARAM KBSYM SYMMETRY OF STRING
C> @PARAM IGB BETA GROUP
C> @PARAM NAST NUMBOER OF ALPHA STRING IN ALPHA GROUP
      SUBROUTINE D_DM2_TERM_9(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,D_FDM2,
     $     ITGA,LGCOM,ITGB,JPZB1,LDISB,NSYM,KBSYM,IGB,NAST,LSAS,KSYM,
     $     LSAC,LSPA,NXTW,WSTATE,IWTS,AB,NCI)
      IMPLICIT NONE
!PASSED IN VARIABLE/ARRAYS
      INTEGER I,J,K,L,N1,N2,N3,MIN_R,MAX_R,ITGA,LGCOM(ITGB,*),JPZB1,
     $     LDISB(NSYM,ITGB,*),KBSYM,IGB,NAST(*),LSAS(NSYM+1,*),NSYM,
     $     LSAC(*),KCIA,LSPA(*),NXTW,IWTS(*),NCI,KSYM,ITGB
      DOUBLE PRECISION D_FDM2(*),WSTATE(*),AB(NCI,*)

!LOCAL VARIABLES     
      DOUBLE PRECISION F_FC
      INTEGER IGA,JCIB1,NIAS,KKA,IENA3,JCIA,JCI1,KKI

      DO IGA=1,ITGA
         IF (LGCOM(IGB,IGA).NE.1)CYCLE
         JCIB1 = JPZB1 + LDISB(KBSYM,IGB,IGA)
         NIAS = NAST(IGA)
!     
         DO KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
            IENA3 = LSAC(KKA)
            JCIA = LSPA(NIAS+IENA3)
            JCI1 = JCIA + JCIB1
            F_FC = 0.0D+00
            DO KKI=1,NXTW
               F_FC = F_FC + WSTATE(IWTS(KKI))*AB(JCI1,KKI)*AB(JCI1,KKI)
            ENDDO
            
            CALL DIST_DM2_M(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)
            CALL DIST_DM2_M(I,J,L,K,N1,N2,N3,MIN_R,MAX_R,-F_FC,D_FDM2)
            
         ENDDO !KKA

      ENDDO !IGA

      RETURN
      END SUBROUTINE D_DM2_TERM_9
!------------------------------------------------------------------------
!========================================================================
!------------------------------------------------------------------------
!*MODULE EXCORR  *DECK D_DM2_TERM_10
C> @BRIEF      THIS ROUTINE ADDES DM2 ELEMNT TO SPIN-FREE DM2 VECTOR
C> 
C> @AUTHOR     LUKE ROSKOP
C>             -2013
C> 
C> @DETAILS    THIS ROUTINE ADDS DM2 ELEMNT TO DM2 VECTOR
C> 
C> @DATE 2/26/13-LUKE ROSKOP
C> -NEW ROUNTINE TO ADDED DM ELEMENT TO VECTOR DM2
C>
C> @PARAM I ORBITAL INDEX
C> @PARAM J ORBITAL INDEX
C> @PARAM K ORBITAL INDEX
C> @PARAM L ORBITAL INDEX
C> @PARAM N1 HYPERCUBE OFFSET
C> @PARAM N2 HYPERCUBE OFFSET
C> @PARAM N3 HYPERCUBE OFFSET
C> @PARAM MIN_R MINIMUM RANGE OF PROCESSED DM2
C> @PARAM MAX_R MAXIMUM RANGE OF PROCESSES DM2
C> @PARAM D_FDM2 SPIN-FREE TWO-PARTICLE DENSITY MATRIX
C> @PARAM NXTW NUMBER OF STATES TO WEIGHT
C> @PARAM WSTATE STATE WEIGHT
C> @PARAM AB CI VECTOR
C> @PARAM IWTS WHICH STATES TO WEIGHT ARRAY
C> @PARAM JPOSAE POSITION OF STRING
C> @PARAM LDISB DISPLACEMENT ARRAY
C> @PARAM NSYM NUMBER OF IRREPS
C> @PARAM ITGB NUMBER OF BETA GROUPS
C> @PARAM IGB2 BETA GROUP
C> @PARAM JB1PO POSTION ARRAY
C> @PARAM JBINDX INDEX OF BETA STRING
C> @PARAM JGROAE GROUP INDEX
C> @PARAM LABPOS STRING POSTION
C> @PARAM JPERAE PERMUTATION SYMMETRY
C> @PARAM JB1PE PERMUTATION SYMMETRY
C> @PARAM KBSYM SYMMETRY OF STRING
      SUBROUTINE D_DM2_TERM_10(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,D_FDM2,
     $     JPOSAE,LDISB,NSYM,ITGB,IGB2,JB1PO,JBINDX,JGROAE,
     $     NXTW,WSTATE,IWTS,AB,LABPOS,JPERAE,JB1PE,NCI,KBSYM)
      IMPLICIT NONE
!PASSED IN VARIABLE/ARRAYS
      INTEGER I,J,K,L,N1,N2,N3,MIN_R,MAX_R,JPOSAE,LDISB(NSYM,ITGB,*),
     $     JB1PO(*),NXTW,IWTS(*),LABPOS,JPERAE,JB1PE(*),JBINDX,KBSYM,
     $     IGB2,JGROAE,NSYM,ITGB,NCI
      DOUBLE PRECISION D_FDM2(*),WSTATE(*),AB(NCI,*)
!LOCAL VARIABLES
      INTEGER KKI,JCIB
      DOUBLE PRECISION F_FC

      JCIB=JPOSAE+LDISB(KBSYM,IGB2,JGROAE)+JB1PO(JBINDX)
!     JCIB2=JPZA1+LDISB(KBSYM,IGB2,JGROAE)+JB1PO(JBINDX)

      F_FC = 0.0D+00
!     F_FC1 = 0.0D+00
      DO KKI=1,NXTW
         F_FC = F_FC + WSTATE(IWTS(KKI))*AB(LABPOS,KKI)*AB(JCIB,KKI)
!     F_FC1 =F_FC1+ WSTATE(IWTS(KKI))*AB(LABPOS2,KKI)*AB(JCIB2,KKI)
      ENDDO
      F_FC = F_FC*JPERAE*JB1PE(JBINDX)/2.0D+00
!     F_FC1 = F_FC1*JPERAE*JB1PE(JBINDX)/2.0D+00

      CALL DIST_DM2_M(I,J,K,L,N1,N2,N3,MIN_R,MAX_R,F_FC,D_FDM2)

      RETURN
      END SUBROUTINE D_DM2_TERM_10
!------------------------------------------------------------------------
!========================================================================
!------------------------------------------------------------------------

