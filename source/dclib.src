C 19 Oct 12 - MWS - synchronize FRGINF common
C 15 APR 11 - MK,TY - COMPATIBLE WITH DC-UHF
C 15 APR 11 - MK  - COMPATIBLE WITH DC-SCF GRADIENT
C                   ACCELERATE DC-DFT, FIX TYPE-(B) LBSUBS INPUT
C                   DELETE GDENDC ROUTINE, FIX MRPMTX
C 10 MAY 10 - MWS - ADD NEW ARGUMENT TO SETCONI
C 25 MAR 10 - MK  - SEVERAL IMPROVEMENTS IN DC METHOD
C 14 OCT 09 - MWS - PAD GAUSS-HERMITE QUADRATURE COMMON
C 22 MAY 09 - DMC - MINIMIZE SVP MODEL'S COMMON BLOCK FOOTPRINT
C  1 MAY 09 - MK  - DCINP,DCCRIN: PREVENT USE OF SPHER.HARM. OR SOLVENTS
C 12 JAN 09 -  TA,MK - IMPLEMENTATION OF DIVIDE-AND-CONQUER METHOD
C
C*MODULE DCLIB   *DECK COVRAD
      DOUBLE PRECISION FUNCTION COVRAD(IATM,JATM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION COVR(103)
C
C     COVALENT RADII
C     ORIGINALLY FROM
C       B. CORDERO ET AL., DALTON TRANS. 2008, 2832.
C
C     SOME MODIFICATIONS WERE MADE
C      -VAN DER WAALS RADII FOR HE,NE,AR,KR FROM
C       J. EMSLEY, "THE ELEMENTS" 2ND EDITION, 1991.
C      -FOR SOME TYPICAL ELEMENTS, THE VALUES ARE CHANGED
C
      DATA  COVR  /0.31,                                     1.22,
     *             1.28, 0.96, 0.84, 0.76, 0.71, 0.66, 0.57, 1.60,
     *             1.66, 1.41, 1.21, 1.11, 1.07, 1.05, 1.02, 1.91,
     *             2.03, 1.76,
     *       1.70, 1.60, 1.53, 1.39, 1.61, 1.52, 1.50, 1.24, 1.32, 1.22,
     *                         1.22, 1.20, 1.19, 1.20, 1.20, 1.98,
     *             2.20, 1.95,
     *       1.90, 1.75, 1.64, 1.54, 1.47, 1.46, 1.42, 1.39, 1.45, 1.44,
     *                         1.42, 1.39, 1.39, 1.38, 1.39, 1.40,
     *             2.44, 2.15,
     * 2.07, 2.04, 2.03, 2.01, 1.99, 1.98, 1.98,
     * 1.96, 1.94, 1.92, 1.92, 1.89, 1.90, 1.87,
     *       1.87, 1.75, 1.70, 1.62, 1.51, 1.44, 1.41, 1.36, 1.36, 1.32,
     *                         1.45, 1.46, 1.48, 1.40, 1.50, 1.50,
     *             2.60, 2.21,
     * 2.15, 2.06, 2.00, 1.96, 1.90, 1.87, 1.80,
     * 1.69, 1.50, 1.50, 1.50, 1.50, 1.50, 1.50, 1.50/
C
C     OBTAIN SUM OF COVALENT RADII IN ANGSTROM
C
      COVRAD=COVR(IATM)+COVR(JATM)
C
      RETURN
      END
C
C*MODULE DCLIB   *DECK DCCRIN
      SUBROUTINE DCCRIN(IUNTRD)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /BASSPH/ QMTTOL,ISPHER
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C          NEXT IS TO TEST REQUEST FOR THE SOLVENT MODELS
      LOGICAL ISEPS,USEPS
      PARAMETER (MXFRG=1050, MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /ISEPS / ISEPS,USEPS
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IRPPCM,IEFPCM,IP_F,NFMOPCM
      COMMON /SVPOPT/ ISVP,NSVP,MTHSVP,NCAV,NVLPL,IQP
      COMMON /ZRFPAR/ GZRF,FIND(3),GNUCF,EBORN,DIELEC,IZRF,ICALC
C
      LOGICAL DODCCR,ONLYOC,RMKORB,FZCORE,DOMP1,HFFRM
      COMMON /DCCORR/ RBUFCR,WOCC,ISTCOR,ITPART,DODCCR,ONLYOC,RMKORB,
     *                FZCORE,DOMP1,HFFRM
      LOGICAL DCFLG
      COMMON /DCOPT / SUBTYP,BUFTYP,SUBLNG,BUFRAD,NDCPRT,NSUBS,DCFLG
      COMMON /SOOPT / NOSO
C
      PARAMETER (NNAM=10)
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00,UNITS=ONE/0.52917724924D+00)
      DIMENSION QNAM(NNAM),KQNAM(NNAM)
C
C      ----- SET UP NAMELIST $DCCORR TABLES -----
C
      DATA GROUP/8HDCCORR  /
      DATA QNAM/8HDODCCR  ,8HRBUFCR  ,8HISTCOR  ,8HRMKORB  ,
     *          8HWOCC    ,8HONLYOC  ,8HFZCORE  ,8HDOMP1   ,
     *          8HHFFRM   ,8HITPART  /
      DATA KQNAM/0,3,1,0,  3,0,0,0,  0,1/
C
C     ----- INITIALIZE VARIABLES FOR NAMELIST $DCCORR -----
C
      DODCCR = .FALSE.
      RBUFCR = ZERO
      ISTCOR = 0
      RMKORB = .FALSE.
      WOCC   = ONE
      ONLYOC = .TRUE.
      FZCORE = .TRUE.
      DOMP1  = .FALSE.
      HFFRM  = .FALSE.
      ITPART = 0
C
      CALL NAMEIO(IR,JRET,GROUP,NNAM,QNAM,KQNAM,
     *            DODCCR,RBUFCR,ISTCOR,RMKORB,WOCC,ONLYOC,FZCORE,DOMP1,
     *            HFFRM,ITPART,
     *                  0,0,0,0,   0,0,0,0,0,  0,0,0,0,0,
     *    0,0,0,0,0,  0,0,0,0,0,   0,0,0,0,0,  0,0,0,0,0,
     *    0,0,0,0,0,  0,0,0,0,0,   0,0,0,0,0,  0,0,0,0,0)
C
      IF(JRET.EQ.2) THEN
        IF(MASWRK) WRITE(IW,*) 'BAD $DCCORR READ'
        CALL ABRT
      END IF
      IF(ISPHER.EQ.1 .AND. DODCCR) THEN
        IF(MASWRK) WRITE(IW,9120)
        CALL ABRT
      END IF
C
      IF(ISTCOR.LE.0) ISTCOR=1
      IF(IUNTRD.EQ.1) RBUFCR=RBUFCR*UNITS
      IF(DCFLG) DODCCR=.TRUE.
      IF(DODCCR) NOSO=1
C
      IF(.NOT.(DCFLG.OR.DODCCR)) RETURN
C
C     MAKE SURE NO SOLVENT MODEL IS REQUESTED
C
      NSOLV = 0
      IF(IZRF.EQ.1) NSOLV=NSOLV+1
      IF(IPCM.EQ.1) NSOLV=NSOLV+1
      IF(NFRG.NE.0) NSOLV=NSOLV+1
      IF(ISEPS)     NSOLV=NSOLV+1
      IF(ISVP.EQ.1) NSOLV=NSOLV+1
      IF(NSOLV.GT.1) THEN
         IF(MASWRK) WRITE(IW,9130)
         CALL ABRT
      END IF
C
      RETURN
 9120 FORMAT(1X,'*** ERROR! DIVIDE-&-CONQUER CANNOT MANAGE ISPHER=1')
 9130 FORMAT(1X,'*** ERROR! DIVIDE-&-CONQUER DOES NOT SUPPORT ANY',
     *          ' SOLVATION MODELS')
      END
C*MODULE DCLIB   *DECK DCINP
      SUBROUTINE DCINP(IUNTRD)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL DCFLG,DIIDCF
      LOGICAL OK
      LOGICAL DIIQTR
C
      PARAMETER (NNAM=26)
      PARAMETER (MXATM=2000)
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00,UNITS=ONE/0.52917724924D+00)
C
      DIMENSION QNAM(NNAM),KQNAM(NNAM)
C
      COMMON /BASSPH/ QMTTOL,ISPHER
      COMMON /DCDIIS/ EXTDII,PEXDII,ETHRDC,DIITYP,NDCDIS,IRAFDC,DIIDCF,
     *                DIIQTR
      COMMON /DCDOS / DOSRGL,DOSRGR,DOSITV,BDOS
      COMMON /DCFRM / FRMLVA,FRMLVB,FRBETA,FTOL,MXITDC
      COMMON /DCOPT / SUBTYP,BUFTYP,SUBLNG,BUFRAD,NDCPRT,NSUBS,DCFLG
      COMMON /DCPRP / IORBD
      COMMON /DCSUB / LBSUBS(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SOOPT / NOSO
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      COMMON /DCGRD / NDCGRD,IDCRSP
      COMMON /FONOPT/ FONTYP,BETINI,BETFIN,FONSTA,FONEND
C
      DATA RHF    /8HRHF     /, UHF    /8HUHF     /
C
      DOUBLE PRECISION MD
      DATA ENERGY /8HENERGY  /, FFIELD /8HFFIELD  /, SURF   /8HSURFACE /
      DATA GRAD   /8HGRADIENT/, OPTMIZ /8HOPTIMIZE/, SADPT  /8HSADPOINT/
      DATA AIRC   /8HIRC     /, DRC    /8HDRC     /, TRNSTN /8HTRANSITN/
      DATA TDHF   /8HTDHF    /, MD     /8HMD      /, GLOBOP /8HGLOBOP  /
      DATA GRDXTR /8HGRADEXTR/, TRUDGE /8HTRUDGE  /
C
C      ----- SET UP NAMELIST $DANDC TABLES -----
C
      DATA QNAM/8HDCFLG   ,8HBUFRAD  ,8HFRBETA  ,8HMXITDC  ,8HFTOL    ,
     *          8HNDCPRT  ,8HEXTDII  ,8HPEXDII  ,8HDIIDCF  ,8HETHRDC  ,
     *          8HNSUBS   ,8HLBSUBS  ,8HBUFTYP  ,8HSUBTYP  ,8HSUBLNG  ,
     *          8HIORBD   ,8HDOSRGL  ,8HDOSRGR  ,8HDOSITV  ,8HDIITYP  ,
     *          8HNDCGRD  ,8HFONTYP  ,8HBETINI  ,8HFONSTA  ,8HFONEND  ,
     *          8HDIIQTR  /
      DATA KQNAM /0,3,3,1,3,  1,3,3,0,3,  1,11,5,5,3,  1,3,3,3,5,
     *            1,5,3,3,3,  0/
C
      DATA DANDC  /8HDANDC   /
      DATA RADIUS /8HRADIUS  /, RADSUB /8HRADSUB  /, RADBND /8HRADBND  /
      DATA AUTO   /8HAUTO    /, AMANAL /8HMANUAL  /, ATOM   /8HATOM    /
      DATA CARD   /8HCARD    /, AUTBND /8HAUTBND  /
      DATA FDS    /8HFDS     /, DELTAF /8HDELTAF  /
      DATA RNONE  /8HNONE    /, DIIER  /8HDIIER   /, ADUMMY /8HDUMMY   /
      PARAMETER (FOUR=4.0D+00)
C
C     ----- INITIALIZE VARIABLES FOR NAMELIST $DANDC -----
C
      KQNAM(12)=MXATM*10+1
C
      DCFLG=.FALSE.
      SUBTYP=AMANAL
      BUFTYP=RADIUS
      SUBLNG=2.0D+00
      BUFRAD=ZERO
      NDCPRT=0
C
      FRBETA=ZERO
      MXITDC=0
      FTOL=ZERO
C
      DIIDCF=.FALSE.
      EXTDII=ZERO
      PEXDII=ZERO
      ETHRDC=1.0D-04
      IORBD=0
      DOSRGL=-2.0D+00
      DOSRGR= 2.0D+00
      DOSITV=ZERO
      BDOS  =ZERO
      DIITYP=DELTAF
      NDCGRD=1
      DIIQTR=.FALSE.
      FONTYP=ADUMMY
      BETINI=ZERO
      FONSTA=ZERO
      FONEND=ZERO
C
      NSUBS=0
      CALL VICLR(LBSUBS,1,MXATM)
C
C        ----- READ NAMELIST $DANDC -----
C
      JRET = 0
      CALL NAMEIO(IR,JRET,DANDC,NNAM,QNAM,KQNAM,DCFLG,BUFRAD,FRBETA,
     *            MXITDC,FTOL,NDCPRT,EXTDII,PEXDII,DIIDCF,ETHRDC,
     *            NSUBS,LBSUBS,BUFTYP,SUBTYP,SUBLNG,
     *            IORBD,DOSRGL,DOSRGR,DOSITV,DIITYP,NDCGRD,FONTYP,
     *            BETINI,FONSTA,FONEND,DIIQTR,     0,0,0,
     *                 0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,
     *     0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0)
      IF(JRET .EQ. 2) THEN
         IF (MASWRK) WRITE (IW,9008)
         CALL ABRT
      END IF
C
      IF(IUNTRD.EQ.1) THEN
         BUFRAD=BUFRAD*UNITS
         SUBLNG=SUBLNG*UNITS
      END IF
C
C          CHECK $DANDC INPUT
C
      IF (DCFLG) NOSO=1
      NERR = 0
C
      IF (BUFRAD.EQ.ZERO) BUFRAD=5.0D+00
      IF (BUFRAD.LT.ZERO) THEN
         IF (MASWRK) WRITE(IW,9010)
         NERR = NERR+1
      END IF
C
      IF (FRBETA.EQ.ZERO) FRBETA=200.0D+00
      IF (FRBETA.LT.ZERO) THEN
         IF (MASWRK) WRITE(IW,9015)
         NERR = NERR+1
      END IF
C
      IF (MXITDC.EQ.0) MXITDC=100
      IF (MXITDC.LE.0) THEN
         IF (MASWRK) WRITE(IW,9020)
         NERR = NERR+1
      END IF
C
      IF (FTOL.EQ.ZERO) FTOL=15.0D+00
      IF (FTOL.LT.ZERO) THEN
         IF (MASWRK) WRITE(IW,9025)
         NERR = NERR+1
      END IF
C
C     NDCPRT = PRINTOUT OPTION. SUM OF FOLLOWINGS:
C              +1 : (RESERVED)
C              +2 : DENSITY MATRIX ($DM GROUP) ON PUNCH
C              +4 : CALCULATE SUBSYSTEM ENERGY ON OUTPUT
C              +8 : SUBSYSTEM MO AND ORBITAL ENERGY ON OUTPUT
C
      IF (NDCPRT.LT.0 .OR. NDCPRT.GT.15) THEN
         IF (MASWRK) WRITE(IW,9035) NDCPRT
         NERR = NERR+1
      END IF
C
C         NON-DIVIDE&CONQUER WILL ALWAYS DO DIIS IN THE O.N.B.,
C         WHEREAS -NDCDIS- DETERMINES WHAT D&C RUNS WILL DO
C
      IF(.NOT.DCFLG) DIIQTR=.TRUE.
      NDCDIS=0
      IF (DCFLG) NDCDIS=2
      IF (EXTDII.EQ.ZERO .OR. PEXDII.EQ.ZERO) NDCDIS=0
      IF (EXTDII.GT.ZERO) NDCDIS=1
      IF (PEXDII.GT.ZERO) NDCDIS=2
      IF (EXTDII.LT.ZERO .AND. PEXDII.LT.ZERO) THEN
         PEXDII=1.0D+00
         EXTDII=0.0D+00
      END IF
C
      IF (DIITYP.NE.FDS .AND. DIITYP.NE.DELTAF) THEN
         IF (MASWRK) WRITE(IW,9050)
         NERR = NERR+1
      END IF
C
      IF (SUBTYP.EQ.AMANAL .AND. NSUBS.EQ.0) SUBTYP=ATOM
C
      IF (NSUBS.LT.0) THEN
         IF (MASWRK) WRITE(IW,9060)
         NERR = NERR+1
      END IF
C
      OK=.FALSE.
      IF (BUFTYP.EQ.RADIUS) OK=.TRUE.
      IF (BUFTYP.EQ.RADSUB) OK=.TRUE.
      IF (BUFTYP.EQ.RADBND) OK=.TRUE.
      IF (BUFTYP.EQ.CARD)   OK=.TRUE.
      IF (.NOT.OK) THEN
         IF (MASWRK) WRITE(IW,9070) BUFTYP
         NERR = NERR+1
      END IF
C
      OK=.FALSE.
      IF (SUBTYP.EQ.ATOM)   OK=.TRUE.
      IF (SUBTYP.EQ.AMANAL) OK=.TRUE.
      IF (SUBTYP.EQ.AUTO)   OK=.TRUE.
      IF (SUBTYP.EQ.AUTBND) OK=.TRUE.
      IF (SUBTYP.EQ.CARD)   OK=.TRUE.
      IF (.NOT.OK) THEN
         IF (MASWRK) WRITE(IW,9080) SUBTYP
         NERR = NERR+1
      END IF
C
      IF (BUFTYP.EQ.CARD .AND. SUBTYP.NE.CARD) THEN
         IF (MASWRK) WRITE(IW,9090)
         NERR = NERR+1
      END IF
C
      IF (DCFLG) THEN
         IF(SCFTYP.NE.RHF .AND. SCFTYP.NE.UHF) THEN
            IF (MASWRK) WRITE(IW,9100) SCFTYP
            NERR = NERR+1
         ENDIF
      ENDIF
C
      IF (FONTYP.EQ.ADUMMY) FONTYP=RNONE
C
      BETFIN=FRBETA
      IF(BETINI.GT.FRBETA) BETINI=FRBETA
      IF(BETINI.EQ.ZERO) THEN
         IF(FONTYP.EQ.DIIER) THEN
            BETINI=FRBETA/FOUR
         ELSE
            BETINI=FRBETA
         END IF
      END IF
      IF(BETINI.LT.ZERO) THEN
         IF(MASWRK) WRITE(IW,9200)
         NERR = NERR+1
      END IF
C
      IF (FONSTA.EQ.ZERO) FONSTA=1.0D+00
      IF (FONEND.EQ.ZERO) FONEND=1.0D-04
      IF (FONSTA.LT.ZERO .OR. FONEND.LT.ZERO) THEN
         IF(MASWRK) WRITE(IW,9210)
         NERR = NERR+1
      END IF
      IF (FONEND.GT.FONSTA) FONEND=FONSTA
C
      IF (NDCGRD.LT.0 .AND. NDCGRD.GT.1) THEN
         IF(MASWRK) WRITE(IW,9220) NDCGRD
         NERR = NERR+1
      END IF
C
      IF (DCFLG) THEN
         OK=.FALSE.
         IF(RUNTYP.EQ.ENERGY) OK=.TRUE.
         IF(RUNTYP.EQ.FFIELD) OK=.TRUE.
         IF(RUNTYP.EQ.SURF)   OK=.TRUE.
C
         IF(RUNTYP.EQ.TDHF)   OK=.TRUE.
         IF(RUNTYP.EQ.GRAD)   OK=.TRUE.
         IF(RUNTYP.EQ.OPTMIZ) OK=.TRUE.
         IF(RUNTYP.EQ.SADPT)  OK=.TRUE.
         IF(RUNTYP.EQ.AIRC)   OK=.TRUE.
         IF(RUNTYP.EQ.DRC)    OK=.TRUE.
         IF(RUNTYP.EQ.TRNSTN) OK=.TRUE.
         IF(RUNTYP.EQ.MD)     OK=.TRUE.
         IF(RUNTYP.EQ.GLOBOP) OK=.TRUE.
         IF(RUNTYP.EQ.GRDXTR) OK=.TRUE.
         IF(RUNTYP.EQ.TRUDGE) OK=.TRUE.
C
         IF(.NOT.OK) THEN
            IF (MASWRK) WRITE(IW,9110) RUNTYP
            NERR = NERR+1
         ENDIF
      ENDIF
C
      IF(ISPHER.EQ.1 .AND. DCFLG) THEN
        IF(MASWRK) WRITE(IW,9120)
        NERR = NERR+1
      END IF
C
      IF(.NOT.DIIDCF) ETHRDC=ZERO
C
      BDOS=FRBETA
C
      IF(NERR.GT.0) THEN
         IF (MASWRK) THEN
         WRITE(IW,*) 'THE JOB IS HALTING SO YOU CAN FIX IT.'
         END IF
         CALL ABRT
      END IF
C
      RETURN
C
 9008 FORMAT(1X,'ERROR IN $DANDC INPUT')
 9010 FORMAT(1X,'*** ERROR! BUFRAD HAS NEGATIVE VALUE.')
 9015 FORMAT(1X,'*** ERROR! FRBETA HAS NEGATIVE VALUE.')
 9020 FORMAT(1X,'*** ERROR! MXITDC HAS NEGATIVE VALUE.')
 9025 FORMAT(1X,'*** ERROR! FTOL HAS NEGATIVE VALUE.')
 9035 FORMAT(1X,'*** ERROR! NUMBER OF DC PRINT OPTION IS NOT CORRECT.'
     *         /12X,'NDCPRT = ',I3,' DOSE NOT EXIST.')
 9050 FORMAT(1X,'*** ERROR! INVALID DIITYP.')
 9060 FORMAT(1X,'*** ERROR! NSUBS HAS NEGATIVE VALUE.')
 9070 FORMAT(1X,'*** ERROR! INCORRECT BUFTYP.'
     *         /12X,'BUFTYP=',A8,' IS NOT SUPPORTED.')
 9080 FORMAT(1X,'*** ERROR! INCORRECT SUBTYP.'
     *         /12X,'SUBTYP=',A8,' IS NOT SUPPORTED.')
 9090 FORMAT(1X,'*** ERROR! SUBTYP SHOULD BE CARD IF BUFTYP=CARD.')
 9100 FORMAT(1X,'*** ERROR! DCSCF DOES NOT SUPPORT SCFTYP=',A8)
 9110 FORMAT(1X,'*** ERROR! DCSCF DOES NOT SUPPORT RUNTYP=',A8)
 9120 FORMAT(1X,'*** ERROR! DIVIDE-&-CONQUER CANNOT MANAGE ISPHER=1')
 9200 FORMAT(1X,'*** ERROR! BETINI HAS NEGATIVE VALUE')
 9210 FORMAT(1X,'*** ERROR! FONSTA OR FONEND HAS NEGATIVE VALUE')
 9220 FORMAT(1X,'*** ERROR! NDCGRD=',I4,' IS INCORRECT.')
      END
C*MODULE DCLIB   *DECK DCWCAL
      SUBROUTINE DCWCAL(VEC,S,DCW,L1,L2,LNUMC)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION VEC(L1,L1),S(L2),DCW(L1)
C
      COMMON /DCEGG / NLATE,NLSHE,LNUME
C
      PARAMETER (TWO=2.0D+00)
C
C      *** CALCULATE ORBITAL WEIGHT ***
C         (IN THE LOCALIZATION REGION)
C       DCW(I) : WEITGT OF I-TH ORBITAL IN THE LOCALIZATION REGION,
C                 CONTRIBUTION TO POPULATION
C       DCW(I) = SUM (P_(MU,NU)*C_(MU,I)*C_(NU,I)*S_(MU,NU)) OVER MU, NU
C
C       P : PARTITION MATRIX
C         P_(MU,NU) = 1   (BOTH MU AND NU INCLUDED IN CENTRAL REGION)
C                     0.5 (EITHER MU OR NU INCLUDED IN CENTRAL REGION
C                             AND THE OTHER INCLUDED IN BUFFER REGION)
C                     0   (BOTH MU AND NU INCLUDED IN BUFFER REGION)
C
      CALL VCLR(DCW,1,L1)
C
C       SUM UP CENTRAL-CENTRAL PART, P_(MU,NU) = 1
C
      DO MU=1,LNUMC
         DO NU=1,MU-1
            K=MU*(MU-1)/2+NU
            TMPW=S(K)*TWO
            DO I=1,L1
               DCW(I)=DCW(I)+TMPW*VEC(MU,I)*VEC(NU,I)
            END DO
         END DO
C
C       --- MU=NU CASE ---
C
         K=MU*(MU+1)/2
         TMPW=S(K)
         DO I=1,L1
            DCW(I)=DCW(I)+TMPW*VEC(MU,I)*VEC(MU,I)
         END DO
      END DO
C
C       SUM UP CENTRAL-BUFFER PART, P_(MU,NU) = 0.5
C
      DO MU=LNUMC+1,L1-LNUME
         DO NU=1,LNUMC
            K=MU*(MU-1)/2+NU
            TMPW=S(K)
            DO I=1,L1
               DCW(I)=DCW(I)+TMPW*VEC(MU,I)*VEC(NU,I)
            END DO
         END DO
      END DO
C
      RETURN
C
      END
C
C*MODULE DCLIB   *DECK DENT2L
      SUBROUTINE DENT2L(D,DB,L1,L2,IDCDM,UHF,DBG)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL DBG
C
      DIMENSION D(L2),DB(L2)
      LOGICAL UHF
C
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      LOGICAL DCFLG
      COMMON /DCOPT / SUBTYP,BUFTYP,SUBLNG,BUFRAD,NDCPRT,NSUBS,DCFLG
      COMMON /FMCOM / X(1)
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
C     ----- GENERATE PSEUDO LOCAL DENSITY MATRIX
C                      FROM TOTAL DENSITY MATRIX -----
C       DENSITY MATRIX FOR EACH LOCALIZATION REGION
C            IS NEEDED IN SUBROUTINE DCSCF( )
C      ( THIS SUBROUTINE IS MUST BE NEEDED FOR
C          GUESS IS HUCKEL, MOREAD, RDMINI, OR MOSAVED )
C
      CALL SEQREW(IDCDM)
      DO ISUB=1,NSUBS
C
C        --- IN THE ISUB-TH LOCALIZATION REGION
         IF(DBG) WRITE(IW,9000) ISUB
C
         CALL LOCREG(ISUB)
C
         LSUB1=LNUM
         LSUB3=LSUB1*LSUB1
         LSUB2=(LSUB3+LSUB1)/2
C
         CALL VALFM(LOADFM)
         LDLC  = LOADFM+ 1
         LAST  = LDLC  + LSUB2
C
         NEEDLC= LAST - LOADFM - 1
         CALL GETFM(NEEDLC)
C
C        --- TRANSFORM TOTAL DENSITY MATRIX INTO LOCAL REGION MATRIX
C
         CALL TRT2LC(D,X(LDLC),L1,L2,LSUB1,LSUB2,'P-DENST ')
C
         CALL SQWRIT(IDCDM,X(LDLC),LSUB2)
C
         IF(UHF) THEN
            CALL TRT2LC(DB,X(LDLC),L1,L2,LSUB1,LSUB2,'P-DENSTB')
            CALL SQWRIT(IDCDM,X(LDLC),LSUB2)
         END IF
         CALL RETFM(NEEDLC)
C
         IF(DBG) THEN
            WRITE(IW,*) 'PSEUDO LOCAL DENSITY MATRIX'
            CALL PRTRILDC(ISUB,X(LDLC),LSUB1)
         END IF
C
      END DO
C
      RETURN
C
 9000 FORMAT(/5X,'*** IN THE ',I3,' TH LOCALIZATION REGION  ***')
      END
C
C*MODULE DCLIB   *DECK DFLCST
      SUBROUTINE DFLCST(IFLG,PRTFLG)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL DCFLG
      LOGICAL DODCCR,ONLYOC,RMKORB,FZCORE,DOMP1,HFFRM
      LOGICAL DBUG,GOPARR,DSKWRK,MASWRK
      LOGICAL PRTFLG,OUT
C
      PARAMETER (MXATM=2000, MXLATM=200, MXLSHL=700)
      PARAMETER (RADMX2=1.0D+10)
      PARAMETER (UNITBA=0.52917724924D+00)
C
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      COMMON /DCCORR/ RBUFCR,WOCC,ISTCOR,ITPART,DODCCR,ONLYOC,RMKORB,
     *                FZCORE,DOMP1,HFFRM
      COMMON /DCEGG / NLATE,NLSHE,LNUME
      COMMON /DCOPT / SUBTYP,BUFTYP,SUBLNG,BUFRAD,NDCPRT,NSUBS,DCFLG
      COMMON /DCSUB / LBSUBS(MXATM)
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
      COMMON /IODC  / IDCSUB,IDCVEC,IDCDM,IDCQ,IDCDMO,IDCEIG,IDCW,IDCEDM
      COMMON /SUBSP / ILCST1(MXATM),NLC1,LNUMMX,ILATST(MXATM),NLCAT1
C
      DIMENSION FLGNAM(0:1),FLGPNC(0:1)
      DIMENSION CCENT(3)
C
      DATA DEBUG  /8HDEBUG   /
      DATA RADIUS /8HRADIUS  /, RADSUB /8HRADSUB  /, RADBND /8HRADBND  /
      DATA AUTO   /8HAUTO    /, AMANAL /8HMANUAL  /, ATOM   /8HATOM    /
      DATA CARD   /8HCARD    /, AUTBND /8HAUTBND  /
      DATA FLGNAM /8HSCF     ,8HCORREL. /
      DATA FLGPNC /8H $SUBSCF,8H $SUBCOR/
C
C     *** DEFINE LOCALIZAION REGION (SUBSYSTEM) ***
C
C     -- INPUT --
C          IFLG = 0  : CONSTRUCT SUBSYSTEMS FOR SCF
C               = 1  : CONSTRUCT SUBSYSTEMS FOR CORRELATION
C
C          PRTFLG    : SWITCH TO PRINT OUT SUBSYSTEM INFORMATION
C
C     -- OUTPUT IN COMMON --
C          ILCST1(I) : STARTING POSITION OF I-TH LOCALIZATION REGION
C          NLC1      : TOTAL NUMBER OF BASIS FUNCTIONS IN DC
C          LNUMMX    : MAXIMUM NUMBER OF BASIS FUNCTIONS IN A SUBSYSTEM
C
C     *** SET THE MARKER OF LOCALIZATION REGION ***
C        (CONTAINS WHAT THIS ELEMENT IS REQUIRED FOR)
C          -LNLCT- : MARKER OF LOCALIZATION REGION IN TOTAL MATRIX
C                    ( LENGTH : NUM*(NUM+1)/2 = L2, INTEGER )
C               = 1 ... REQUIRED FOR DC FOCK MATRIX
C               = 0 ... REQUIRED NEITHER FOR FOCK NOR DENSITY MATRIX
C               =-1 ... REQUIRED FOR DC DENSITY MATRIX AS WELL AS FOCK
C
      DBUG = MASWRK .AND. EXETYP.EQ.DEBUG
      OUT  = MASWRK .AND. PRTFLG
C
      IF(OUT) WRITE(IW,9000) FLGNAM(IFLG)
      IF(OUT) WRITE(IP,'(A8)') FLGPNC(IFLG)
C
C     === DEFINE CENTRAL REGION ===
C
      IF (SUBTYP.EQ.ATOM) THEN
         DO I=1,NAT
            LBSUBS(I)=I
         END DO
         NSUBS=NAT
      ELSE IF (SUBTYP.EQ.AMANAL) THEN
         ITMP=1
         IF(LBSUBS(1).EQ.0) THEN
C
C           LBSUBS HAS SUBSYSTEM ATOMS SPLITTED BY 0
C           (FMO-LIKE INPUT)
C
            DO I=2,MXATM
               ILCST1(I)=LBSUBS(I)
            ENDDO
            CALL VICLR(LBSUBS,1,NAT)
C
            IPRE=0
            DO I=2,MXATM
               INEW=ILCST1(I)
               IF(INEW.GT.0) THEN
                  IF(LBSUBS(INEW).EQ.0) THEN
                     LBSUBS(INEW)=ITMP
                  ELSE
                     IF(MASWRK) WRITE(IW,9800) INEW
                     CALL ABRT
                  ENDIF
               ELSE IF(INEW.LT.0) THEN
                  IF(IPRE.GT.0 .AND. IPRE.LT.-INEW) THEN
                     DO J=IPRE+1,-INEW
                        IF(LBSUBS(J).EQ.0) THEN
                           LBSUBS(J)=ITMP
                        ELSE
                           IF(MASWRK) WRITE(IW,9800) J
                           CALL ABRT
                        ENDIF
                     ENDDO
                  ELSE
                     IF(MASWRK) WRITE(IW,9810) I
                     CALL ABRT
                  ENDIF
               ELSE
                  IF(IPRE.EQ.0) GOTO 50
                  ITMP=ITMP+1
               ENDIF
               IPRE=INEW
            END DO
   50       CONTINUE
            IF(IPRE.EQ.0) THEN
               ITMP=ITMP-1
            ELSE
               IF(MASWRK) WRITE(IW,9815)
               CALL ABRT
 9815 FORMAT(' *** ERROR WHEN READING LBSUBS.')
            END IF
C
            DO I=1,NAT
               IF(LBSUBS(I).EQ.0) THEN
                  IF(MASWRK) WRITE(IW,9820) I
                  CALL ABRT
               ENDIF
            ENDDO
         ELSE
C
C           LBSUBS(I)=SUBSYSTEM THAT ATOM I BELOGNS
C
            DO I=1,NAT
               IF(LBSUBS(I).LE.0) THEN
                  IF(MASWRK) WRITE(IW,9900) I
                  CALL ABRT
               ELSE
                  IF(LBSUBS(I).GT.ITMP) ITMP=LBSUBS(I)
               END IF
            END DO
         ENDIF
         IF(ITMP.NE.NSUBS) THEN
            IF(MASWRK) WRITE(IW,9910)
            CALL ABRT
         END IF
      ELSE IF (SUBTYP.EQ.AUTBND .OR. SUBTYP.EQ.AUTO) THEN
         CALL SUBAUT(SUBTYP,SUBLNG,NSUBS)
      ELSE IF (SUBTYP.EQ.CARD) THEN
C        IF BUFTYP IS ALSO CARD, BUFFER IS ALSO CONSTRUCTED
         CALL SUBCRD(BUFTYP,IFLG,NSUBS,OUT)
      END IF
C
      IF(OUT) THEN
         WRITE(IW,9200) SUBTYP,NSUBS
         IF(SUBTYP.EQ.AUTBND .OR. SUBTYP.EQ.AUTO) THEN
            WRITE(IW,9210) SUBLNG,SUBLNG*UNITBA
         ENDIF
      ENDIF
C
C     === DEFINE BUFFER REGION ===
C
      IF(IFLG.EQ.0) THEN
         RAD1=BUFRAD
      ELSE IF(IFLG.EQ.1) THEN
         RAD1=RBUFCR
      ELSE
         IF(MASWRK) WRITE(IW,*) ' IFLG IS INCORRECT'
         CALL ABRT
      ENDIF
      RAD2=RAD1*RAD1
C
      IF (BUFTYP.NE.CARD) THEN
C
         IF(OUT) WRITE(IW,9250) BUFTYP,RAD1,RAD1*UNITBA
C
         CALL SEQREW(IDCSUB)
         DO ISUB=1,NSUBS
C
            NLAT=0
            DO IATM=1,NAT
               IF(LBSUBS(IATM).EQ.ISUB) THEN
                  NLAT=NLAT+1
                  LOC2TA(NLAT)=IATM
               ENDIF
            ENDDO
            NLATC=NLAT
C
            IF(BUFTYP.EQ.RADIUS) THEN
               DO IATM=1,NAT
                  IF(LBSUBS(IATM).EQ.ISUB) GOTO 70
C
                  DIST=RADMX2
                  DO IATMC=1,NLATC
                     DO J=1,3
                        CCENT(J)=C(J,LOC2TA(IATMC))
                     ENDDO
                     TMP = (CCENT(1)-C(1,IATM))**2
     *                    +(CCENT(2)-C(2,IATM))**2
     *                    +(CCENT(3)-C(3,IATM))**2
                     IF (TMP.LT.DIST) DIST=TMP
                     IF(DIST.LE.RAD2) GOTO 65
                  ENDDO
C
   65             CONTINUE
                  IF (DIST.LE.RAD2) THEN
                     NLAT=NLAT+1
                     IF(NLAT.GT.MXLATM) THEN
                        IF(MASWRK) WRITE(IW,9700) MXLATM
                        CALL ABRT
                     END IF
                     LOC2TA(NLAT)=IATM
                  END IF
   70             CONTINUE
               ENDDO
C
            ELSE IF(BUFTYP.EQ.RADSUB) THEN
               DO JSUB=1,NSUBS
                  IF(JSUB.EQ.ISUB) GO TO 80
                  NLATSB=0
                  DO IATM=1,NAT
                     IF (JSUB.EQ.LBSUBS(IATM)) THEN
                        NLATSB=NLATSB+1
                        ILCST1(NLATSB)=IATM
                     END IF
                  ENDDO
C
                  DIST=RADMX2
                  DO K=1,NLATC
                     DO J=1,3
                        CCENT(J)=C(J,LOC2TA(K))
                     ENDDO
                     DO L=1,NLATSB
                        TMP= (CCENT(1)-C(1,ILCST1(L)))**2
     *                      +(CCENT(2)-C(2,ILCST1(L)))**2
     *                      +(CCENT(3)-C(3,ILCST1(L)))**2
                        IF (TMP.LT.DIST) DIST=TMP
                     ENDDO
                     IF(DIST.LE.RAD2) GOTO 75
                  ENDDO
C
   75             CONTINUE
C
                  IF (DIST.LE.RAD2) THEN
                     DO L=1,NLATSB
                        NLAT=NLAT+1
                        IF(NLAT.GT.MXLATM) THEN
                           IF(MASWRK) WRITE(IW,9700) MXLATM
                           CALL ABRT
                        END IF
                        LOC2TA(NLAT)=ILCST1(L)
                     ENDDO
                  END IF
   80             CONTINUE
               ENDDO
C
            ELSE IF(BUFTYP.EQ.RADBND) THEN
               IF(MASWRK) WRITE(IW,*) ' NOT IMPLEMENTED'
               CALL ABRT
            ENDIF
C
C           PUNCH OUT SUBSYSTEM INFORMATION
C
            IF(OUT) CALL SUBPRT(IP,LOC2TA,NLATC,NLAT,NLAT,ISUB)
C
C     LOC2TA(NLATC) AND LOC2TA(NLAT) SHOULD BE SAVED IN NEGATIVE
C
            LOC2TA(NLATC)=-LOC2TA(NLATC)
            IF(NLAT.NE.NLATC) LOC2TA(NLAT) =-LOC2TA(NLAT)
            IF(NLAT.LT.MXLATM) LOC2TA(NLAT+1)=0
C
C     WRITE SUBSYSTEM INFORMATIONS TO IDCSUB
C
            IF (DSKWRK.OR.MASWRK) WRITE(IDCSUB) ISUB,LOC2TA
C
         ENDDO
      ELSE
         IF(OUT) WRITE(IW,9260) BUFTYP
      ENDIF
      IF(OUT) WRITE(IP,7100)
C
      CALL SEQREW(IDCSUB)
C
      L1=NUM
      L2=(L1*L1+L1)/2
      NLC1=0
      NLCAT1=0
C
      CALL VALFM(LOADFM)
      LNLCT = LOADFM + 1
      LAST  = LNLCT  + L2
      NEED = LAST-LOADFM-1
      CALL GETFM(NEED)
C
      CALL VICLR(X(LNLCT),1,L2)
C
      LNUMMX=0
      IF(OUT) THEN
         WRITE(IP,*) '  --- NUMBER OF ATOMS AND BASIS FUNCTIONS ',
     *               'IN EACH LOCALIZATION REGION ---'
         WRITE(IP,*) '    ISUB  NLATC   NLAT  NLATE   NLSH   LNUM'
      END IF
      DO 100 ISUB=1,NSUBS
         ILCST1(ISUB)=NLC1+1
         ILATST(ISUB)=NLCAT1+1
         CALL LOCREG(ISUB)
         NLC1=NLC1+LNUM
         NLCAT1=NLCAT1+NLAT+1
         IF(OUT) WRITE(IP,'(1X,6I7)') ISUB,NLATC,NLAT,NLATE,NLSH,LNUM
C
         IF(LNUMMX .LT. LNUM) LNUMMX=LNUM
C
         CALL LCRMRK(X(LNLCT),L2)
C
  100 CONTINUE
C
      CALL DAWRIT(IDAF,IODA,X(LNLCT),L2,272,1)
C
      CALL RETFM(NEED)
C
      IF(OUT) WRITE(IW,9100)
C
      IF(DBUG) THEN
         CALL DAREAD(IDAF,IODA,X(LNLCT),L2,272,1)
         IF(MASWRK) THEN
            WRITE(IW,9110)
            WRITE(IW,9115)
         END IF
C
         CALL PRITRL(X(LNLCT),L1)
      END IF
C
      RETURN
 7100 FORMAT(' $END')
 9000 FORMAT(/' --- CONSTRUCTING SUBSYSTEMS FOR ',A8,'---')
 9100 FORMAT(' === DONE. SUBSYSTEM INFORMATION IS PRINTED IN PUNCH ===')
 9110 FORMAT(/9X,'--------------------------'
     *       /9X,'GLOBAL MATRIX IN DC METHOD'
     *       /9X,'--------------------------')
 9115 FORMAT(' 1 : AN ELEMENT AT THIS POSITION IS INCLUDED.'
     *      /' 0 : AN ELEMENT AT THIS POSITION IS NOT INCLUDED.')
 9200 FORMAT(/5X,'SUBSYSTEM CONSTRUCTION OPTIONS'/5X,30(1H-)/
     * 1X,'SUBTYP=',A8  ,5X,'NSUBS =',I8)
 9210 FORMAT(
     * 1X,'SUBLNG=',F8.4,' BOHR (',F8.4,' ANGS)')
 9250 FORMAT(
     * 1X,'BUFTYP=',A8  ,5X,'BUFRAD=',F8.4,' BOHR (',F8.4,' ANGS)',0P)
 9260 FORMAT(1X,'BUFTYP=',A8  ,0P)
 9700 FORMAT (/1X,'***ERROR***'/
     *         1X,'NUMBER OF ATOMS IN A SUBSYSTEM EXCEEDS MAX',I5)
 9800 FORMAT(' *** ERROR! ATOM ',I5,' IS ASSIGNED TO ',
     *       'MULTIPLE SUBSYSTEMS.')
 9810 FORMAT(' *** ERROR WHEN READING LBSUBS(',I5,').')
 9820 FORMAT(' *** ERROR! ATOM ',I5,' IS ASSIGNED TO NO SUBSYSTEMS.')
 9900 FORMAT(' *** ERROR! LBSUBS(',I5,') IS ZERO OR NEGATIVE.')
 9910 FORMAT(' *** ERROR! -NSUBS- AND -LBSUBS- ARE INCONSISTENT.')
      END
C
C*MODULE DANDC   *DECK DFTTRFDM
      SUBROUTINE DFTTRFDM(UROHF,L1,DA,DB,AOX,DENXA,DENXB,TOL,NLCT,NELM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL UROHF
      DIMENSION DA(*),DB(*),AOX(L1),DENXA(L1),DENXB(L1)
      DIMENSION NLCT(L1,L1),NELM(2,L1)
C
C        (THIS CODE IS BASED ON "DECK DFTTRF")
C     AO->MO TRANSFORMATION * BY USING DENSITY MATRIX *
C     (FOR SPEED, RUN ONE RATHER THAN TWO LOOPS, SO ZERO EXTRA -MOXB-)
C     ALL THIS CAN BE COMPRESSED INTO A SINGLE LINE:
C     CALL MRARBR(AOX,1,1,L1,COEFFB,L1,NOB,VMOB,1)
C
                CALL VCLR(DENXA,1,L1)
      IF(UROHF) CALL VCLR(DENXB,1,L1)
C
C     NLCT(1)=-1000 MEANS NON-DC CALCULATION
      IF(NLCT(1,1).EQ.-1000) GOTO 300
C
      IJ=0
      IF(UROHF) THEN
        DO I=1, L1
          AOI=AOX(I)
          IF(ABS(AOI).GT.TOL) THEN
            DO JT=1, NELM(1,I)
              J=NLCT(JT,I)
              IJPT=IJ+J
              DENXA(J)=DENXA(J)+AOI*DA(IJPT)
              DENXB(J)=DENXB(J)+AOI*DB(IJPT)
            END DO
            DO JT=NELM(1,I)+1, NELM(2,I)
              J=NLCT(JT,I)
              JIPT=J*(J-1)/2+I
              DENXA(J)=DENXA(J)+AOI*DA(JIPT)
              DENXB(J)=DENXB(J)+AOI*DB(JIPT)
            END DO
          END IF
          IJ=IJ+I
        END DO
      ELSE
        DO I=1, L1
          AOI=AOX(I)
          IF(ABS(AOI).GT.TOL) THEN
            DO JT=1, NELM(1,I)
              J=NLCT(JT,I)
              IJPT=IJ+J
              DENXA(J)=DENXA(J)+AOI*DA(IJPT)
            END DO
            DO JT=NELM(1,I)+1, NELM(2,I)
              J=NLCT(JT,I)
              JIPT=J*(J-1)/2+I
              DENXA(J)=DENXA(J)+AOI*DA(JIPT)
            END DO
          END IF
          IJ=IJ+I
        END DO
      END IF
      RETURN
C
C     FOLLOWINGS ARE THE OLD PROGRAM
  300 CONTINUE
      IIM1=0
      IF(UROHF) THEN
        DO I=1,L1
          AO=AOX(I)
          IIM1=IIM1+I-1
          IF(ABS(AO).GT.TOL) THEN
            DO J=1,I-1
              IJ=IIM1+J
              DENXA(J)=DENXA(J)+AO*DA(IJ)
              DENXB(J)=DENXB(J)+AO*DB(IJ)
            ENDDO
            DENXA(I)=DENXA(I)+AO*DA(IIM1+I)
            DENXB(I)=DENXB(I)+AO*DB(IIM1+I)
            DO J=I+1,L1
              JI=J*(J-1)/2+I
              DENXA(J)=DENXA(J)+AO*DA(JI)
              DENXB(J)=DENXB(J)+AO*DB(JI)
            END DO
          ENDIF
        ENDDO
      ELSE
        DO I=1,L1
          AO=AOX(I)
          IIM1=IIM1+I-1
          IF(ABS(AO).GT.TOL) THEN
            DO J=1,I-1
              IJ=IIM1+J
              DENXA(J)=DENXA(J)+AO*DA(IJ)
            ENDDO
            DENXA(I)=DENXA(I)+AO*DA(IIM1+I)
            DO J=I+1,L1
              JI=J*(J-1)/2+I
              DENXA(J)=DENXA(J)+AO*DA(JI)
            END DO
          ENDIF
        ENDDO
      END IF
C--   IF(.NOT.UROHF) CALL DCOPY(NB,MOXA,1,MOXB,1)
      RETURN
C
      END
C
C*MODULE DCLIB   *DECK DOSPLT
      SUBROUTINE DOSPLT(EIG,W,DOSRGL,DOSRGR,DOSITV,BDOS,NE,NL1)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION EIG(NL1),W(NL1)
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
C     ***** CALCULATE VALUE OF DENSITY OF STATES (DOS) ******
C             (THE VALUE AT EACH PLOT POINT)
C             ---> PRINTED ON PUNCH FILE
C
C           DOS(X) = W_I * (DERIVERTIVE OF FERMIF(X-EIG_I,BDOS))
C                  = W_I * B * EXP(B*(X-EIG_I))
C                                  / ((1 + EXP(B*(X-EIG_I)))^2)
C
C             EIG_I  : I-TH EIGENVALUE (ORBITAL ENERGY)
C             W_I    : I-TH ORBITAL WEIGHT
C             BDOS   : INVERSE TEMPERATURE OF FERMI FUNCTION (FERMIF())
C                 (IF IN THE DC METHOD, BDOS SHOULD BE EQUAL TO FRBETA)
C
C             DOSRGL : LEFT END OF PLOTRANGE
C             DOSRGR : RIGHT END OF PLOTRANGE
C             DOSITV : INTERVAL BETWEEN PLOTPOINTS
C
C     ----- CALUCULATE VALUE OF DOS AT EACH PLOT POINT -----
C
      WRITE(IW,9010)
C
      ELECNR=ONE/NE
      NPLOT=NINT((DOSRGR-DOSRGL)/DOSITV)
      X = DOSRGL
      DO IPLOT=1,NPLOT
         VDOS = ZERO
C        --- SUM UP OVER ALL EIGENVALUES
         DO I=1,NL1
            TMP = -BDOS*(X-EIG(I))
C
C           IF |TMP| > 50 (VAL < 10^(-20) OR VAL > 10^20),
C             DO NOT SUM UP IN ORDER TO AVOID OVERFLOW OF VAL.
            IF (ABS(TMP).LE.5.0D+01) THEN
               VAL = EXP(TMP)
               VDOS = VDOS + W(I)*BDOS*VAL/((1+VAL)**2)
            END IF
         END DO
         VDOS = VDOS * ELECNR
         WRITE(IW,9020) X, VDOS
         X = X + DOSITV
      END DO
C
C     --- AT THE LAST POINT (X=DOSRGR)
C
      VDOS = ZERO
      DO I=1,NL1
         TMP = -BDOS*(DOSRGR-EIG(I))
         IF (ABS(TMP).LE.5.0D+01) THEN
            VAL = EXP(TMP)
            VDOS = VDOS + W(I)*BDOS*VAL/((1+VAL)**2)
         END IF
      END DO
C
      VDOS = VDOS * ELECNR
      WRITE(IW,9020) DOSRGR,VDOS
C
      RETURN
C
 9010 FORMAT (/1X,3X,'X (PLOTPOINT)',3X,'Y (VALUE OF DOS)')
 9020 FORMAT (1X,F16.9,3X,F16.9)
      END
C
C*MODULE DCLIB   *DECK ELDNDC
      SUBROUTINE ELDNDC(IDAFNO,IORBD)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL PAPER,PUNCH,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXATM=2000)
C
      DIMENSION ELDEN(1)
C
      COMMON /ELPROP/ ELDLOC,ELMLOC,ELPLOC,ELFLOC,
     *                IEDEN,IEMOM,IEPOT,IEFLD,MODENS,
     *                IEDOUT,IEMOUT,IEPOUT,IEFOUT,
     *                IEDINT,IEMINT,IEPINT,IEFINT
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /XYZPRP/ XP,YP,ZP
     *               ,DMX,DMY,DMZ
     *               ,QXX,QYY,QZZ,QXY,QXZ,QYZ
     *               ,QMXX,QMYY,QMZZ,QMXY,QMXZ,QMYZ
     *               ,OXXX,OXXY,OXXZ,OXYY,OYYY,OYYZ
     *               ,OXZZ,OYZZ,OZZZ,OXYZ
     *               ,OMXXX,OMXXY,OMXXZ,OMXYY,OMYYY
     *               ,OMYYZ,OMXZZ,OMYZZ,OMZZZ,OMXYZ
C
      PARAMETER (ONE=1.0D+00)
C
      DATA CHECK/8HCHECK   /, DEBUG/8HDEBUG   /, DBUGME/8HELDNDC  /
      DATA ELDEN/8HELDEN   /, DUMMY/8H        /
      DATA GRID /8HGRID    /
      LOGICAL GCUBE
C
C       CALCULATE ELECTRON DENSITY FOR MOLECULAR ORBITAL
C       AT SPECIFIED POINTS.
C
      PAPER = IEDOUT.GE.0 .AND. MASWRK
      IF(EXETYP.EQ.DEBUG)  PAPER=.TRUE.
      IF(EXETYP.EQ.DBUGME) PAPER=.TRUE.
      PAPER = PAPER .AND. MASWRK
C
      PUNCH = IEDOUT.NE.0
      PUNCH = PUNCH .AND. MASWRK
C
      IF(PAPER) THEN
         WRITE(IW,920)
         IF(IORBD.LT.0) WRITE(IW,925) IABS(IORBD+1)
         IF(IORBD.GT.0) WRITE(IW,927) IORBD-1
         WRITE(IW,930)
      END IF
      IF(PUNCH) WRITE(IP,940) IORBD
C
C               SET POINTERS FOR PARTITIONING OF MEMORY
C
      L1 = NUM
      L2 = (L1*L1+L1)/2
      NVAL = 1
C
      LOADFM = 0
      CALL VALFM(LOADFM)
      IELD   = LOADFM + 1
      IEDW   = IELD   + L2
C
      IDENSA = IEDW   + 784
      IDENSB = IDENSA + L2
      LAST   = IDENSB + L2
C
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      IF (EXETYP.EQ.CHECK) THEN
         CALL RETFM(NEED)
         RETURN
      END IF
C
C        OBTAIN PARTIAL DENSITY MATRIX
C
      CALL DAREAD(IDAF,IODA,X(IDENSA),L2,IDAFNO,0)
C
C        INITIALIZE CUBE OUTPUT
C
      GCUBE=.FALSE.
      IF(PUNCH .AND. (ELDLOC.EQ.GRID)) THEN
         IMOV=IORBD+NE/2
         IVAL=IMOV
         CALL CUBOUT(0,ELDEN,IVAL)
         IF(IVAL.EQ.IMOV) THEN
            GCUBE=.TRUE.
         END IF
      END IF
C
C              LOOP OVER POINTS TO BE EVALUATED
C
      IPOINT = 0
  210 CONTINUE
      IPOINT = IPOINT + 1
      ISTAT = 0
      CALL POINT(ELDLOC,IPOINT,XP,YP,ZP,ISTAT)
      IF(ISTAT.LT.0) CALL ABRT
      IF(ISTAT.GT.0) THEN
         IF(PUNCH .AND. GCUBE) CALL CUBOUT(2,DUMMY,IPOINT)
         CALL RETFM(NEED)
         RETURN
C        ******
      END IF
C
C          CALCULATE DELTA FUNCTION INTEGRALS
C
      CALL PRCALC(ELDEN,X(IELD),X(IEDW),NVAL,L2,GOPARR)
C
      IF(IEDINT.NE.0) THEN
         IF(GOPARR) CALL DDI_GSUMF(910,X(IELD),L2)
         IF(MASWRK) WRITE(IW,950)
         CALL PRTRIL(X(IELD),L1)
         IF(GOPARR) CALL DSCAL(L2,ONE/NPROC,X(IELD),1)
      END IF
C
C        CALCULATE ELECTRON DENSITY FOR ORBITAL OR WAVEFUNCTION
C
      EDENS = TRACEP(X(IDENSA),X(IELD),L1)
      IF(GOPARR) CALL DDI_GSUMF(911,EDENS,1)
C
C        OUTPUT THE RESULTS
C
      IF(PAPER) WRITE(IW,970) IPOINT,XP,YP,ZP,EDENS
      IF(PUNCH) THEN
         IF(GCUBE) THEN
            CALL CUBOUT(1,EDENS,IPOINT)
         ELSE
            WRITE(IP,980) IPOINT,XP,YP,ZP,EDENS
         END IF
      END IF
      GO TO 210
C
  920 FORMAT(/10X,26('-')/
     *        10X,'1 ELECTRON ORBITAL DENSITY'/
     *        10X,26('-'))
  925 FORMAT( 5X,'ORBITAL: HOMO - ',I3/)
  927 FORMAT( 5X,'ORBITAL: LUMO + ',I3/)
  930 FORMAT(2X,'POINT',6X,'X',9X,'Y',9X,'Z',13X,'DENSITY',
     *        /1H ,20X,'(BOHR)',20X,'(A.U.)')
  940 FORMAT(1X,'ORBITAL ELECTRON DENSITY(',I3,'), IPOINT,X,Y,Z,EDENS')
  950 FORMAT(1H ,10X,22('-'),/11X,'ELECTRON DENSITY INTEGRALS')
  970 FORMAT(1X,I5,2X,3F10.5,F17.6)
  980 FORMAT(1X,I3,2X,3F10.5,E15.6)
      END
C
C*MODULE DCLIB   *DECK FERMIF
      DOUBLE PRECISION FUNCTION FERMIF(X,FRBETA)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (ONE=1.0D+00)
C
C     RETURN VALUE OF FERMI FUNCTION
C
      FERMIF=ONE/(ONE+EXP(-FRBETA*X))
C
      RETURN
      END
C
C*MODULE DCLIB   *DECK FRMLEV
      SUBROUTINE FRMLEV(EIGT,DCWT,KEIGTS,KTP,NLC,ELENDC,NEL,FRMLV,DBUG)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION EIGT(NLC),DCWT(NLC)
      DIMENSION KEIGTS(NLC),KTP(NLC)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL DCFLG,DBUG,DBG
C
      LOGICAL SSTART
C
      PARAMETER (MXATM=2000)
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00, TWO=2.0D+00, TEN=10.0D+00)
      PARAMETER (HALF=0.5D+00, THREE=3.0D+00)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      COMMON /DCFRM / FRMLVA,FRMLVB,FRBETA,FTOL,MXITDC
      COMMON /DCOPT / SUBTYP,BUFTYP,SUBLNG,BUFRAD,NDCPRT,NSUBS,DCFLG
      COMMON /SUBSP / ILCST1(MXATM),NLC1,LNUMMX,ILATST(MXATM),NLCAT1
C
      DBG=DBUG.AND.MASWRK
C
      XACC=TEN**(-FTOL)
C
C     *** DETERMINATION OF FERMI LEVEL ***
C         (FOR -NEL- ELECTRONS)
C
C          FRMLV : ALPHA OR BETA FERMI LEVEL FOR (NEL) ELECTRONS
C                  NEL SHOULD BE NUMBER OF ELECTRONS IN ALPHA OR BETA
C                  IN CLOSED-SHELL CASE, NEL SHOULD BE NE/2
C
C       STEP(1): SORT EIGENVALUES IN ORDER OF SIZE
C                (MERGE SORT)
C
      IF(DBG) WRITE (IW,9000)
C
      DO I=1, NLC
         KEIGTS(I)=I
      END DO
      NBLK=NSUBS
      NJMP=1
      DO WHILE (NJMP.LE.NSUBS)
         DO IBLK=1,NBLK-1,2
            ISTATM=NJMP*(IBLK-1)+1
            JSTATM=ISTATM+NJMP
            NEXT=JSTATM+NJMP
            IPOS=ILCST1(ISTATM)
            JPOS=ILCST1(JSTATM)
            IED=JPOS-1
            JED=NLC
            IF (NEXT.LE.NSUBS) JED=ILCST1(NEXT)-1
            DO I=IPOS,JED
               KTP(I)=KEIGTS(I)
            END DO
            IP0=KTP(IPOS)
            JP0=KTP(JPOS)
            KPOS=IPOS
            DO WHILE (IPOS.LE.IED .AND. JPOS.LE.JED)
               IF (EIGT(IP0).GT.EIGT(JP0)) THEN
                  KEIGTS(KPOS)=JP0
                  JPOS=JPOS+1
                  JP0=KTP(JPOS)
               ELSE
                  KEIGTS(KPOS)=IP0
                  IPOS=IPOS+1
                  IP0=KTP(IPOS)
               END IF
               KPOS=KPOS+1
            END DO
            IF (IPOS.LE.IED) THEN
               DO I=IPOS, IED
                  KEIGTS(KPOS)=KTP(I)
                  KPOS=KPOS+1
               END DO
            ELSE
               DO J=JPOS, JED
                  KEIGTS(KPOS)=KTP(J)
                  KPOS=KPOS+1
               END DO
            END IF
         END DO
         NJMP=NJMP*2
         NBLK=(NBLK+1)/2
      END DO
C
C     --- DEBUG PRINT
      IF(DBG) THEN
         DO I=1,NLC
            WRITE(IW,9020) I, KEIGTS(I), I, EIGT(KEIGTS(I))
         END DO
      END IF
C
C       STEP(2): ESTIMATE APPROXIMATE VALUE OF FERMI LEVEL
C                  (AROUND EIGENVALUES)
C
      ELECN=NEL*ONE
      IEIGT=0
C
      XFRDLT=TWO/FRBETA
      XFRDT2=XFRDLT*64.0D+00
      EPSF=FRMLV
      SSTART=.FALSE.
      VLOLD=ZERO
C
100   CONTINUE
         VLEFT = FUNCDC(EPSF-XFRDLT,KEIGTS,EIGT,DCWT,NLC)-ELECN
         VRIGHT= FUNCDC(EPSF+XFRDLT,KEIGTS,EIGT,DCWT,NLC)-ELECN
         IF(VLEFT*VRIGHT.LE.ZERO) GO TO 120
         IF(VLEFT.GT.ZERO) THEN
            EPSF=EPSF-XFRDT2
         ELSE
            EPSF=EPSF+XFRDT2
         END IF
         IF(VLOLD*VLEFT.LT.ZERO) SSTART=.TRUE.
         IF(SSTART) XFRDT2=XFRDT2/TWO
         VLOLD=VLEFT
      GO TO 100
120   CONTINUE
C
C     --- DEBUG PRINT
      IF(DBG) WRITE(IW,9060) KEIGTS(IEIGT),EIGT(KEIGTS(IEIGT))
C
C       STEP(3): FIND FERMI LEVEL BY BRENT METHOD
C
      X1=EPSF-XFRDLT
      X2=EPSF+XFRDLT
      FL=VLEFT
      F =VRIGHT
C
      F1=FL
      F2=F
      X3=X2
      F3=F2
C
      DO J=1,MXITDC
         IF(F2*F3.GT.ZERO) THEN
            X3=X1
            F3=F1
            DD=X2-X1
            EE=DD
         END IF
         IF(ABS(F3).LT.ABS(F2)) THEN
            X1=X2
            X2=X3
            X3=X1
            F1=F2
            F2=F3
            F3=F1
         END IF
C
         TOL1=HALF*XACC
         XM=HALF*(X3-X2)
         IF(ABS(XM).LE.TOL1 .OR. F2.EQ.ZERO) THEN
            FRMLV=X2
            ELENDC=ELECN+F2
            IF(DBG) THEN
               WRITE(IW,*) 'ITERATION OF FERMIF = ',J
               WRITE(IW,9100) FRMLV
            END IF
            RETURN
C           ******
         END IF
C
         IF(ABS(EE).GE.TOL1 .AND. ABS(F1).GT.ABS(F2)) THEN
            SS=F2/F1
            IF(X1.EQ.X3) THEN
               PP=TWO*XM*SS
               QQ=ONE-SS
            ELSE
               QQ=F1/F3
               RR=F2/F3
               PP=SS*(TWO*XM*QQ*(QQ-RR)-(X2-X1)*(RR-ONE))
               QQ=(QQ-ONE)*(RR-ONE)*(SS-ONE)
            END IF
            IF(PP.GT.ZERO) QQ=-QQ
            PP=ABS(PP)
            IF(TWO*PP.LT.MIN(THREE*XM*QQ-ABS(TOL1*QQ),ABS(EE*QQ))) THEN
               EE=DD
               DD=PP/QQ
            ELSE
               DD=XM
               EE=DD
            END IF
         ELSE
            DD=XM
            EE=DD
         END IF
         X1=X2
         F1=F2
         IF(ABS(DD).GT.TOL1) THEN
            X2=X2+DD
         ELSE
            X2=X2+SIGN(TOL1,XM)
         END IF
         F2=FUNCDC(X2,KEIGTS,EIGT,DCWT,NLC)-ELECN
      END DO
C
C     --- IF FERMI LEVEL IS NOT CONVERGED, USE SECANT METHOD ---
C
      IF (MASWRK) WRITE (IW,9200) MXITDC
C
      X1=EPSF-XFRDLT
      X2=EPSF+XFRDLT
      FL=VLEFT
      F =VRIGHT
C
      IF (ABS(FL).LT.ABS(F)) THEN
         FRMLV=X1
         XL=X2
         SWAP=FL
         FL=F
         F=SWAP
      ELSE
         XL=X1
         FRMLV=X2
      END IF
C
      IF (ABS(F).LT.XACC) THEN
C
         IF(DBG) THEN
            WRITE(IW,*) 'ITERATION OF FERMIF = 0'
            WRITE(IW,9100) FRMLV
         END IF
C
         RETURN
C        ******
      END IF
C
      DO J=1,MXITDC
         DX=(XL-FRMLV)*F/(F-FL)
         XL=FRMLV
         FL=F
         FRMLV=FRMLV+DX
         F=FUNCDC(FRMLV,KEIGTS,EIGT,DCWT,NLC)-ELECN
         IF (ABS(F).LT.XACC .OR. F-FL.EQ.ZERO) THEN
            ELENDC=ELECN+F
C
            IF(DBG) THEN
               WRITE(IW,*) 'ITERATION OF FERMIF = ',J
               WRITE(IW,9100) FRMLV
            END IF
C
            RETURN
         END IF
      END DO
C
C     --- FERMI LEVEL IS NOT CONVERGED ---
C
      IF (MASWRK) WRITE (IW,9210) MXITDC
      CALL ABRT
C
 9000 FORMAT (/1X,'----- DETARMINE THE FERMI LEVEL -----')
 9020 FORMAT (1X,'KEIGTS(',I5,')=',I5,
     *        ',   EIGT(KEIGTS(',I5,'))=',F15.7)
 9060 FORMAT (1X,'   APPROXIMATE VALUE OF FERMI LEVEL'
     *        /'EIGT(',I5,')=',F15.7)
 9100 FORMAT (1X,' DONE.  FERMI LEVEL =',F15.7)
 9200 FORMAT (1X,'FERMI LEVEL IS NOT CONVERGED AFTER ',I5,
     *        ' CYCLE WITH BRENT METHOD'
     *       /1X,'TRY SECANT METHOD')
 9210 FORMAT (1X,'***ERROR! FERMI LEVEL IS NOT CONVERGED AFTER ',I5,
     *        ' CYCLE EVEN WITH SECANT METHOD. ABORT.')
      END
C
C*MODULE DCLIB   *DECK FUNCDC
      DOUBLE PRECISION FUNCTION FUNCDC(EPSF,KEIGTS,EIGT,DCWT,NLC1)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION EIGT(NLC1),KEIGTS(NLC1),DCWT(NLC1)
C
      PARAMETER (ZERO=0.0D+00)
      PARAMETER (VLN10=2.30258509299405D+00)
C
      COMMON /DCFRM / FRMLVA,FRMLVB,FRBETA,FTOL,MXITDC
C
C     *** FUNCTION FUNCDC( ) IS  ***
C
C       NORMALIZATION CONSTRAINT IN DC
C         FUNCDC = SUM (DCWT(I)*FERMIF(EPSF-EIG_(I,A))) OVER I, A
C           NE        : NUMBER OF ELECTRONS
C           EPSF      : FERMI LEVEL
C           EIG_(I,A) : I-TH EIGENVALUE OF A-TH LOCALIZATION REGION
C           DCWT(I)   : WEITGT OF I-TH ORBITAL (IN A-TH LOCLZ. REGION)
C
C      (USING THIS CONDITION, FUNCDC=NE, FERMI LEVEL IS DETERMINED)
C
C       FTOL : THRESHOLD OF FERMI FUNCTION
C         FERMI FUNCTION WHOSE VALUE IS LESS THAN 10**(-FTOL)
C           ARE SKIPPED
C         FERMI FUNCTION WHOSE VALUE IS MORE THAN 1-10**(-FTOL)
C           ARE NOT EXPLICITLY CALCULATED
C
      J=1
      VAL=EPSF-EIGT(KEIGTS(J))
      XFTOL= VLN10*FTOL/FRBETA
      TMPPOP=ZERO
C
C        VALUE OF FERMI FUNCTION IS CLOSE TO ZERO,
C
      DO WHILE (J.LT.NLC1 .AND. VAL.GT.XFTOL)
         TMPPOP=TMPPOP+DCWT(KEIGTS(J))
C
         J=J+1
         VAL=EPSF-EIGT(KEIGTS(J))
      END DO
C
C        VALUE OF FERMI FUNCTION IS NOT CLOSE TO EITHER ZERO OR ONE,
C
      DO WHILE (J.LT.NLC1 .AND. VAL.GE.-XFTOL)
         TMPPOP=TMPPOP+DCWT(KEIGTS(J))*FERMIF(VAL,FRBETA)
C
         J=J+1
         VAL=EPSF-EIGT(KEIGTS(J))
      END DO
      IF(J.EQ.NLC1 .AND. VAL.GE.-XFTOL)
     *   TMPPOP=TMPPOP+DCWT(KEIGTS(J))*FERMIF(VAL,FRBETA)
C
C      VALUE OF FUNCTION FUNCDC( )
C
      FUNCDC=TMPPOP
C
      RETURN
      END
C
C*MODULE MTHLIB  *DECK INTRNEW
      SUBROUTINE INTRNEW
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXAO=8192)
      PARAMETER (UNIT=0.52917724924D+00, CLOSE=0.1D+00)
      PARAMETER (ONE=1.00D+00, TWO=2.00D+00)
      PARAMETER (ZERO=0.0D+00)
C
      LOGICAL CROWD,GOPARR,DSKWRK,MASWRK
C
      COMMON /ECP2  / CLP(400),ZLP(400),NLP(400),KFIRST(MXATM,6),
     *                KLAST(MXATM,6),LMAX(MXATM),LPSKIP(MXATM),
     *                IZCORE(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUN,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
      COMMON /ZRFPAR/ GZRF,FIND(3),GNUCF,EBORN,DIELEC,IZRF,ICALC
C
C     SCALING FACTOR USED FOR FEAR OF MISSING BONDS
      PARAMETER(RSCALE=1.5D+00)
C
C     ----- CALCULATE ATOM-ATOM DISTANCES -----
C
      IF (MASWRK) WRITE (IW,9008)
      FAC = UNIT
      CROWD = .FALSE.
C
      RRMAX = ZERO
      IMAX  = 0
      JMAX  = 0
      DO JAT=1, NAT
         NUCJ = INT(ZAN(JAT)) + IZCORE(JAT)
         DO IAT=1, JAT-1
            NUCI = INT(ZAN(IAT)) + IZCORE(IAT)
            RCOV=RSCALE*COVRAD(NUCJ,NUCI)
            RR = (C(1,IAT)-C(1,JAT))**2
     *         + (C(2,IAT)-C(2,JAT))**2
     *         + (C(3,IAT)-C(3,JAT))**2
            RR = SQRT(RR) * FAC
            IF (RR.GT.RRMAX) THEN
               IMAX=IAT
               JMAX=JAT
               RRMAX=RR
            ENDIF
            IF (RR.LE.CLOSE  .AND.  IAT.NE.JAT) CROWD=.TRUE.
            IF (RR.LT.RCOV .AND. MASWRK)
     *         WRITE(IW,9088) IAT,ANAM(IAT),BNAM(IAT),
     *                        JAT,ANAM(JAT),BNAM(JAT),RR
         ENDDO
      ENDDO
      IF(MASWRK) WRITE(IW,9098) IMAX,ANAM(IMAX),BNAM(IMAX),
     *                          JMAX,ANAM(JMAX),BNAM(JMAX),RRMAX
C
      IF(CROWD) THEN
         IF (MASWRK) WRITE(IW,9100) CLOSE
C
C           FMO RUNS ARE ALLOWED TO HAVE ATOMS AT THE SAME PLACE
C           (CROWDED) (DUE TO GHOST ATOMS IN ESPS).
C
      END IF
C
      IF(IZRF*ICALC.EQ.1)THEN
        CALL ACALC(RADIUS)
        IF (MASWRK) WRITE(IW,9110)RADIUS
        RADIUS = RADIUS/UNIT
        GZRF=TWO*(DIELEC-ONE)/((TWO*DIELEC+ONE)*RADIUS**3)
        EBORN=(1-DIELEC)*ICH**2/(TWO*DIELEC*RADIUS)
      END IF
C
      RETURN
C
 9008 FORMAT(/,8X,'INTERNUCLEAR DISTANCES (ANGS.)'
     *       /,1X,45(1H-),
     *       /,2X,'CENTER ONE',7X,'CENTER TWO',7X,'DISTANCE',
     *       /,1X,45(1H-))
 9088 FORMAT(  I5,1X,A8,A2,1X,I5,1X,A8,A2,2X,F11.7)
 9098 FORMAT(  1X,45(1H-),
     *       /,8X,'MAXIMUM INTERNUCLEAR DISTANCE',
     *       /,I5,1X,A8,A2,1X,I5,1X,A8,A2,2X,F11.7
     *       /,1X,45(1H-))
 9100 FORMAT(1X,'**** THERE ARE ATOMS LESS THAN',F8.3,
     *          ' APART, QUITTING... ****')
 9110 FORMAT(/,1X,'ADJUSTED CAVITY RADIUS = ',F5.2)
      END
C
C*MODULE DCLIB   *DECK LCRMRK
      SUBROUTINE LCRMRK(IA,LA2)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION IA(LA2)
C
      PARAMETER (MXSH=5000, MXGTOT=20000)
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
C
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
C
C     *** SET MARKER OF LOCALIZATION REGION IN TOTAL REGION ***
C        IA(I) = 1 : REQUIRED FOR DC FOCK MATRIX
C              = 0 : REQUIRED NEITHER FOR FOCK NOR DENSITY MATRIX
C              =-1 : REQUIRED FOR DC DENSITY MATRIX AS WELL AS FOCK
C
      DO IBSHL=1,NLSH
         IASHL=LOC2TS(IBSHL)
         IALOCT=KLOC(IASHL)
         DO IBBSFN=1,KMAX(IASHL)-KMIN(IASHL)+1
            IALOC=IALOCT+IBBSFN-1
            LOCAI=IALOC*(IALOC-1)/2
            JBSHLE = MIN(IBSHL,NLSHC)
            DO JBSHL=1,JBSHLE
               JASHL=LOC2TS(JBSHL)
               JALOCT=KLOC(JASHL)
               JBEND=KMAX(JASHL)-KMIN(JASHL)+1
               IF (IBSHL.EQ.JBSHL) JBEND=IBBSFN
               DO JBBSFN=1,JBEND
                  JALOC=JALOCT+JBBSFN-1
                  IF (IALOC .GE. JALOC) THEN
                     KA=LOCAI+JALOC
                  ELSE
                     KA=JALOC*(JALOC-1)/2+IALOC
                  END IF
                  IA(KA)=-1
               END DO
            END DO
            DO JBSHL=JBSHLE+1,IBSHL
               JASHL=LOC2TS(JBSHL)
               JALOCT=KLOC(JASHL)
               JBEND=KMAX(JASHL)-KMIN(JASHL)+1
               IF (IBSHL.EQ.JBSHL) JBEND=IBBSFN
               DO JBBSFN=1,JBEND
                  JALOC=JALOCT+JBBSFN-1
                  IF (IALOC .GE. JALOC) THEN
                     KA=LOCAI+JALOC
                  ELSE
                     KA=JALOC*(JALOC-1)/2+IALOC
                  END IF
                  IF(IA(KA).EQ.0) IA(KA)=1
               END DO
            END DO
         END DO
      END DO
C
      RETURN
C
      END
C
C*MODULE DCLIB   *DECK LOCREG
      SUBROUTINE LOCREG(ISUB)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL LAST
C
      PARAMETER (MXSH=5000, MXGTOT=20000)
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
      COMMON /DCEGG / NLATE,NLSHE,LNUME
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
      COMMON /IODC  / IDCSUB,IDCVEC,IDCDM,IDCQ,IDCDMO,IDCEIG,IDCW,IDCEDM
C
C     *** CONSTRUCTION OF LOCALIZATION-REGION OF -ISUB- SUBSYSTEM***
C
C     --INPUT--
C       ISUB      : CENTRAL REGION (SUBSYSTEM)
C
C     --OUTPUT IN COMMON /INFOLC/--
C       LOC2TA(N) : THE ATOM NUMBER IN TOTAL SYSTEM OF N-TH ATOM
C                   IN THE LOCALIZATION REGION
C       LOC2TS(N) : THE SHELL NUMBER IN TOTAL SYSTEM OF N-TH SHELL
C                   IN THE LOCALIZATION REGION
C       LCKLOC(N) : KLOC IN THE LOCALIZATION REGION
C       NLAT      : # OF ATOMS IN THE LOCALIZATION REGION
C       NLATC     : # OF ATOMS IN THE CENTRAL REGION (SUBSYSTEM)
C       NLSH      : # OF SHELLS IN THE LOCALIZATION REGION
C       NLSHC     : # OF SHELLS IN THE CENTRAL REGION (SUBSYSTEM)
C       LNUM      : # OF BASIS FUNCTIONS IN THE LOCALIZATION REGION
C       LNUMC     : # OF BASIS FUNCTIONS IN CENTRAL REGION (SUBSYSTEM)
C
C     --OUTPUT IN COMMON /DCEGG /--
C       NLATE     : # OF ATOMS IN THE EGG-SHELL REGION
C       NLSHE     : # OF SHELLS IN THE EGG-SHELL REGION
C       LNUME     : # OF BASIS FUNCTIONS IN THE EGG-SHELL REGION
C
      NLAT=0
      NLATC=0
      NLATE=0
      NLSHE=0
      LNUME=0
      NLATL=0
      NLSH=0
      LNUM=0
      LAST=.FALSE.
C
      IF(ISUB.EQ.1) CALL SEQREW(IDCSUB)
C
      IF (DSKWRK.OR.MASWRK) THEN
        READ(IDCSUB) JSUB,LOC2TA
        IF(ISUB.NE.JSUB) THEN
          IF(MASWRK) WRITE(IW,9800)
          CALL ABRT
        ENDIF
      ENDIF
      IF (GOPARR.AND.(.NOT.DSKWRK)) THEN
         CALL DDI_BCAST(230,'I',LOC2TA,MXLATM,MASTER)
      END IF
C
C     NEGATIVE NUMBERS INDICATE THE END OF CENTRAL OR BUFFER REGIONS
C
      DO 20 ILATM=1,MXLATM
         IATM=IABS(LOC2TA(ILATM))
         IF(IATM.EQ.0) THEN
            LAST=.TRUE.
            GOTO 25
         ENDIF
         NLAT=NLAT+1
C        COUNT THE SHELLS AND BASIS FUNCTIONS IN THE SUBSYSTEM
         DO 10 J=1,NSHELL
            IF (KATOM(J).EQ.IATM) THEN
               NLSH=NLSH+1
               IF(NLSH.GT.MXLSHL) THEN
                  IF(MASWRK) WRITE(IW,9910) MXLSHL
                  CALL ABRT
               END IF
               LOC2TS(NLSH)=J
               LCKLOC(NLSH)=LNUM+1
               LNUM=LNUM+KMAX(J)-KMIN(J)+1
            END IF
   10    CONTINUE
         IF(LOC2TA(ILATM).LT.0) THEN
            LOC2TA(ILATM)=IATM
            IF(NLATC.EQ.0) THEN
               NLATC=NLAT
               NLSHC=NLSH
               LNUMC=LNUM
            ELSE IF(NLATL.EQ.0) THEN
               NLATL=NLAT
               NLSHL=NLSH
               LNUML=LNUM
            ELSE
               NLATE=NLAT-NLATL
               NLSHE=NLSH-NLSHL
               LNUME=LNUM-LNUML
               LAST=.TRUE.
               GOTO 25
            END IF
         END IF
   20 CONTINUE
   25 CONTINUE
C
      IF(.NOT.LAST) THEN
         IF(MASWRK) WRITE(IW,9920)
         CALL ABRT
      END IF
C
      RETURN
C
 9800 FORMAT (/1X,'***ERROR***'/
     *         1X,'SUBSYSTEM IS INCORRECT WHEN READING FROM DCSUB')
 9910 FORMAT (/1X,'***ERROR***'/
     *         1X,'NUMBER OF SHELLS IN A SUBSYSTEM EXCEEDS MAX',I5)
 9920 FORMAT (/1X,'***ERROR***'/
     *         1X,'SUBSYSTEM READ ERROR')
      END
C
C*MODULE DCLIB   *DECK MRPMTX
      SUBROUTINE MRPMTX(D,N,NC)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION D(*)
C
      COMMON /DCEGG / NLATE,NLSHE,LNUME
C
      PARAMETER (ZERO=0.0D+00,HALF=0.5D+00)
C
C     ***** MULTIPLY PARTITION MATRIX TO DC DENSITY MATRIX *****
C
C        D(I,J) = P(I,J) * D(I,J)
C
C          P : PARTITION MATRIX
C             P(I,J) = 1   (BOTH I AND J INCLUDED IN CENTRAL REGION)
C                      0.5 (EITHER I OR J INCLUDED IN CENTRAL REGION
C                              AND THE OTHER INCLUDED IN BUFFER REGION)
C                      0   (BOTH I AND J INCLUDED IN BUFFER REGION)
C
C     - ON ENTRY, -D-  IS LOCAL DENSITY MATRIX WITHOUT P(I,J)
C                 -N-  IS NUMBER OF BASIS IN LOCALIZATION REGION
C                 -NC- IS NUMBER OF BASIS IN CENTRAL REGION
C     - ON EXIT,  -D-  IS LOCAL DC DENSITY MATRIX MULTIPLIED BY P(I,J)
C
C     CENTRAL-CENTRAL PART, P(I,J) = 1,
C         DO NOT NEED TO CALCULATE
C
      DO I = NC+1,N-LNUME
         ICAN = I*(I-1)/2
C
C        CENTRAL-BUFFER PART, P(I,J) = 0.5
         DO J = 1,NC
            D(ICAN+J) = D(ICAN+J)*HALF
         END DO
C
C        BUFFER-BUFFER PART, P(I,J) = 0
         DO J = NC+1,I
            D(ICAN+J) = ZERO
         END DO
      END DO
C     EGG-SHELL PART, P(I,J) = 0
      DO I=N+1-LNUME, N
         ICAN = I*(I-1)/2
         DO J=1,I
            D(ICAN+J)=ZERO
         ENDDO
      ENDDO
C
      RETURN
      END
C
C*MODULE DCLIB   *DECK ORBDEN
      SUBROUTINE ORBDEN(EIGT,WT,KEIGTS,KTP,D,L1,L2,IORBD,DBG)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION EIGT(NLC1),WT(NLC1),KEIGTS(NLC1),KTP(NLC1),D(L2)
C
      LOGICAL DBG
      LOGICAL DCFLG
C
      PARAMETER (MXATM=2000,MXLATM=200,MXLSHL=700)
      PARAMETER (ZERO=0.0D+00, VLN10=2.30258509299405D+00)
C
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
      COMMON /DCFRM / FRMLVA,FRMLVB,FRBETA,FTOL,MXITDC
      COMMON /DCOPT / SUBTYP,BUFTYP,SUBLNG,BUFRAD,NDCPRT,NSUBS,DCFLG
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
      COMMON /SUBSP / ILCST1(MXATM),NLC1,LNUMMX,ILATST(MXATM),NLCAT1
      COMMON /IODC  / IDCSUB,IDCVEC,IDCDM,IDCQ,IDCDMO,IDCEIG,IDCW,IDCEDM
C
C     --- GENERATE IORBD-TH ORBITAL'S DENSITY MATRIX ---
C           IORBD : ORBITAL NUMBER (FROM THE FERMI LEVEL)
C                   NEGATIVE NUMBER FOR OCCUPIED ORBITAL
C                   POSITIVE NUMBER FOR UNOCCUPIED ORBITAL
C                    EX. HOMO: -1, LUMO: 1, ... ETC.
C
C         ON EXIT, DENSITY MATRIX OF IORBD-TH ORBITAL IS WRITTEN ON -D-
C
C --- STEP(1):
C       DETERMINE UPPER AND LOWER THRESHOLD OF IORBD-TH ORBITAL,
C       -VFLVUP- AND -VFLVLW-
C       (EVALUATED IN THE SAME WAY OF FERMI LEVEL)
C
      VFRLVP=FRMLVA
C
      NELE=NA+IORBD
      CALL FRMLEV(EIGT,WT,KEIGTS,KTP,NLC1,ELENDC,NELE,VFRLVP,DBG)
C
      IF(IORBD.LE.-1) THEN
         VFLVLW=VFRLVP
         IF(IORBD.EQ.-1) THEN
            VFLVUP=FRMLVA
         ELSE
            NELE=NA+IORBD+1
            CALL FRMLEV(EIGT,WT,KEIGTS,KTP,NLC1,ELENDC,NELE,VFRLVP,DBG)
            VFLVUP=VFRLVP
         END IF
      ELSE IF(IORBD.GE.1) THEN
         VFLVUP=VFRLVP
         IF(IORBD.EQ.1) THEN
            VFLVLW=FRMLVA
         ELSE
            NELE=NA+IORBD-1
            CALL FRMLEV(EIGT,WT,KEIGTS,KTP,NLC1,ELENDC,NELE,VFRLVP,DBG)
            VFLVLW=VFRLVP
         END IF
      END IF
C
C --- STEP(2):
C       DETERMINE OCCUPATION NUMBER OF AOS INCLUDED IN IORBD-TH ORBITAL
C       AND GENERATE LOCAL DENSITY MATRIX
C
C     *** LOCALIZATION REGION LOOP ***
      CALL SEQREW(IDCVEC)
      CALL VCLR(D,1,L2)
      DO ISUB=1,NSUBS
C
C        --- IN THE I-SUB TH LOCALIZATION REGION
         IF(DBG) WRITE(IW,9500) ISUB
C
         CALL LOCREG(ISUB)
         LSUB1=LNUM
         LSUB3=LSUB1*LSUB1
         LSUB2=(LSUB3+LSUB1)/2
C
         CALL VALFM(LOADFM)
         LEIGLC= LOADFM+1
         LOCCLC= LEIGLC+ LSUB1
         LDALC = LOCCLC+ LSUB1
         LDBLC = LDALC + LSUB2
         LVECLC= LDBLC + LSUB2
         LAST  = LVECLC+ LSUB3
C
         NEEDLC = LAST - LOADFM - 1
         CALL GETFM(NEEDLC)
C
         CALL SQREAD(IDCVEC,X(LVECLC),LSUB3)
         CALL DCOPY(LSUB1,EIGT(ILCST1(ISUB)),1,X(LEIGLC),1)
C
         CALL VCLR(X(LOCCLC),1,LSUB1)
C
C        --- OCCUPATION NUMBER IN DC METHOD ---
C                                 DC OCCUPANCIES OF IORBD-TH ORBITAL
C                                 BETWEEN -VFLVLW- AND -VFLVUP-
C
         I=1
         VAL1=VFLVLW-X(LEIGLC+I-1)
         XFTOL= VLN10*FTOL/FRBETA
C
C        VALUE OF FERMI FUNCTION IS CLOSE TO ZERO,
C          THAT IS, THE EIGENVALUES ARE LESS THAN (VFLVLW-XFTOL)
         DO WHILE (I.LE.LSUB1 .AND. VAL1.GT.XFTOL)
            X(LOCCLC+I-1) = ZERO
            I=I+1
            VAL1=VFLVLW-X(LEIGLC+I-1)
         END DO
C
C        VALUE OF FERMI FUNCTION IS NOT CLOSE TO EITHER ZERO OR ONE,
C          THAT IS, THE EIGENVALUES ARE BETWEEN
C          (VFLVLW-XFTOL) AND (VFLVUP+XFTOL)
         VAL2=VFLVUP-X(LEIGLC+I-1)
         DO WHILE (I.LE.LSUB1 .AND. VAL2.GE.-XFTOL)
            X(LOCCLC+I-1) = FERMIF(VAL2,FRBETA)-FERMIF(VAL1,FRBETA)
            I=I+1
            VAL1=VFLVLW-X(LEIGLC+I-1)
            VAL2=VFLVUP-X(LEIGLC+I-1)
         END DO
C
         NOCDC=I-1
C
C        VALUE OF FERMI FUNCTION IS CLOSE TO ZERO,
C          THAT IS, THE EIGENVALUES ARE MORE THAN (VFLVUP+XFTOL)
C
C        DEBUG PRINT
         IF(DBG) THEN
            WRITE (IW,9546)
            WRITE (IW,9548) (X(LOCCLC+I-1),I = 1,LSUB1)
         END IF
C
C        --- FORM THE NEW LOCAL DENSITY MATRIX ---
C
         CALL DMTX(X(LDALC),X(LVECLC),X(LOCCLC),NOCDC,LSUB1,LSUB1)
         CALL STLC2T(D,L2,X(LDALC),LSUB2,.TRUE.)
C
         CALL RETFM(NEEDLC)
C
      END DO
C
C     ---PRINT DENSITY MATRIX ON PUNCH FILE
      IF (DBG) THEN
         WRITE(IP,*)
         WRITE(IP,*) '     ----------------------'
         WRITE(IP,*) '     ORBITAL DENSITY MATRIX'
         WRITE(IP,*) '     ----------------------'
         WRITE(IP,*) '       ',IORBD,' TH ORBITAL'
         DO I0=1,L1,5
            IL = MIN(L1,I0+4)
            WRITE(IP,*)
            WRITE(IP,'(I4,A3,I4)') I0,' - ',IL
            WRITE(IP,*)
            IL = -1
            DO I=I0,L1
               IL=IL+1
               J0=I0+(I*I-I)/2
               JL=J0+MIN(IL,4)
               WRITE(IP,'(6X,I5,1X,10F12.7)') I,(D(J),J=J0,JL)
            END DO
         END DO
         WRITE(IP,*) '..... END OF ORBITAL DENSITY MATRIX OUTPUT .....'
         WRITE(IP,*)
      END IF
C
      RETURN
C
 9500 FORMAT(/5X,'*** IN THE ',I3,' TH LOCALIZATION REGION  ***')
 9546 FORMAT(/30X,'ASSIGNED OCCUPANCIES'/)
 9548 FORMAT(15X,5F11.6)
      END
C
C*MODULE DCLIB   *DECK ORBRMK
      SUBROUTINE ORBRMK(ST,FT,FTB,EIGT,EIGTB,NUM1,NUM2,NLC,NSUBS,
     *                  DBUG,UHF)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXLATM=200, MXLSHL=700)
C
      LOGICAL DBUG
      LOGICAL GOPARR,DSKWRK,MASWRK
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      COMMON /DCFRM / FRMLVA,FRMLVB,FRBETA,FTOL,MXITDC
      COMMON /DCQMT / NLQMT(MXATM)
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
      COMMON /IODC  / IDCSUB,IDCVEC,IDCDM,IDCQ,IDCDMO,IDCEIG,IDCW,IDCEDM
      COMMON /SUBSP / ILCST1(MXATM),NLC1,LNUMMX,ILATST(MXATM),NLCAT1
      LOGICAL DODCCR,ONLYOC,RMKORB,FZCORE,DOMP1,HFFRM
      COMMON /DCCORR/ RBUFCR,WOCC,ISTCOR,ITPART,DODCCR,ONLYOC,RMKORB,
     *                FZCORE,DOMP1,HFFRM
C
      DIMENSION ST(NUM2), FT(NUM2), EIGT(NLC)
      DIMENSION FTB(NUM2), EIGTB(NLC)
      LOGICAL UHF
C
C  RECONSTRUCTION OF SUBSYSTEM ORBITALS
C
C       NUM1   : NUMBER OF BASIS FUNCTIONS IN TOTAL REGION (INPUT)
C       NSUBS  : NUMBER OF SUBSYSTEMS
C       DBUG   : DEBUG OPTION
C       UHF    : =.T. (OPEN-SHELL UHF) OR =.F. (CLOSED-SHELL RHF)
C
      IF(MASWRK) WRITE(IW, 9200)
C
      CALL VALFM(LOADFM)
      LWT   = LOADFM + 1
      LKTP  = LWT    + NLC1
      LKEGTS= LKTP   + NLC1
      LASTT2= LKEGTS + NLC1
      LWTB   = LASTT2 
      IF(UHF) THEN
         LASTT2 = LWTB   + NLC1
      END IF
C
      NEEDT2= LASTT2 - LOADFM - 1
      CALL GETFM(NEEDT2)
C
      CALL SEQREW(IDCQ)
      CALL SEQREW(IDCVEC)
      DO 4000 ISUB=1,NSUBS
C
C     LOAD BALANCER
C
CPA      LTSKDC=ISUB-1
CPA      IF (DLBDC) THEN
CPA        DTSKDC = LTSKDC.EQ.MTSKDC
CPA      ELSE
CPA        DTSKDC = MOD(LTSKDC,NPROC).EQ.ME
CPA      END IF
C
CPA      IF (DTSKDC) THEN
C
C     *** DETERMINE LOCALIZATION REGION ***
C
         CALL LOCREG(ISUB)
C
         LSUB1=LNUM
         LSUB3=LSUB1*LSUB1
         LSUB2=(LSUB3+LSUB1)/2
C
         LSUB0=LSUB1
C
         LLSUB1=LSUB1
         LLSUB2=LSUB2
         LLSUB3=LSUB3
C
C     --- ALLOCATE MEMORY FOR THE ORBITALS
C            OF ISUB-TH LOCALIZATION REGION ---
C
         CALL VALFM(LOADFM)
         LEIGLC= LOADFM + 1
         LFAOLC= LEIGLC + LLSUB1
         LVECLC= LFAOLC + LLSUB2
         LQLC  = LVECLC + LLSUB3
         LSLC  = LQLC   + LLSUB3
         LWLC  = LSLC   + LLSUB2
         LWRKLC= LWLC   + LLSUB1
         LIWRKL= LWRKLC + LLSUB3
         LAST  = LIWRKL + LLSUB1
C
         LSCR  = LAST
         LAST  = LSCR   + 8*LSUB1
C
         NEEDLC= LAST - LOADFM - 1
         CALL GETFM(NEEDLC)
C
C     ----- TRANSFORM FOCK OPERATOR TO THE -Q- MATRIX BASIS -----
C     ----- DIAGONALIZE THE CURRENT FOCK MATRIX -----
C     ----- BACK-TRANSFORM THE EIGENVECTORS TO AO BASIS -----
C     FOCK OPERATOR IN ONB FOR DIAGONALIZATION MUST BE AT -LWRK1-
C
C     ----- CONSTRUCT SUBSYSTEM -Q- MATRIX -----
C
         CALL TRT2LC(ST,X(LSLC),NUM1,NUM2,LSUB1,LSUB2,
     *               'OVERLAP ')
         CALL QMTSYM(X(LSLC),X(LVECLC),X(LQLC),X(LEIGLC),X(LSCR),
     *               X(LIWRKL),LSUB0,LSUB1,LSUB2,LSUB3,DBUG)
         CALL SQWRIT(IDCQ,X(LQLC),LLSUB3)
         NLQMT(ISUB)=LSUB0
C
C     ----- READ SUBSYSTEM FOCK AND OVERLAP MATRIX -----
C
         CALL TRT2LC(FT,X(LFAOLC),NUM1,NUM2,LLSUB1,LLSUB2,
     *               'FOCK    ')
         CALL TRT2LC(ST,X(LSLC),NUM1,NUM2,LSUB1,LSUB2,
     *               'OVERLAP ')
C
C     ----- SOLVE EIGENPROBLEM -----
C
         CALL TFTRI(X(LWRKLC),X(LFAOLC),X(LQLC),X(LIWRKL),
     *              LSUB0,LSUB1,LSUB1)
         CALL SYMDIA(X(LWRKLC),X(LVECLC),X(LEIGLC),X(LSCR),
     *               X(LIWRKL),LSUB0,LSUB2,LSUB1)
         CALL TFSQB(X(LVECLC),X(LQLC),X(LIWRKL),LSUB0,LSUB1,LSUB1)
C
         CALL DCOPY(LLSUB1,X(LEIGLC),1,EIGT(ILCST1(ISUB)),1)
         CALL SQWRIT(IDCVEC,X(LVECLC),LLSUB3)
C
C     *** CALCULATE ORBITAL WEIGHT ***
C        W = SUM (P_(MU,NU)*C_(MU,I)*C_(NU,I)*S_(MU,NU)) OVER MU, NU
C
         CALL DCWCAL(X(LVECLC),X(LSLC),X(LWLC),LSUB1,LSUB2,LNUMC)
         CALL DCOPY(LLSUB1,X(LWLC),1,X(LWT+ILCST1(ISUB)-1),1)
C
         IF(UHF) THEN
            CALL TRT2LC(FTB,X(LFAOLC),NUM1,NUM2,LLSUB1,LLSUB2,
     *                  'FOCKB    ')
            CALL TFTRI(X(LWRKLC),X(LFAOLC),X(LQLC),X(LIWRKL),
     *                 LSUB0,LSUB1,LSUB1)
            CALL SYMDIA(X(LWRKLC),X(LVECLC),X(LEIGLC),X(LSCR),
     *                  X(LIWRKL),LSUB0,LSUB2,LSUB1)
            CALL TFSQB(X(LVECLC),X(LQLC),X(LIWRKL),LSUB0,LSUB1,LSUB1)
            CALL DCOPY(LLSUB1,X(LEIGLC),1,EIGTB(ILCST1(ISUB)),1)
            CALL SQWRIT(IDCVEC,X(LVECLC),LLSUB3)
            CALL DCWCAL(X(LVECLC),X(LSLC),X(LWLC),LSUB1,LSUB2,LNUMC)
            CALL DCOPY(LLSUB1,X(LWLC),1,X(LWTB+ILCST1(ISUB)-1),1)
         END IF
C
         CALL RETFM(NEEDLC)
C
CPA      IF (DLBDC) CALL DDI_DLBNEXT( MTSKDC )
CPA      END IF       !  LOAD BALANCER
C
 4000 CONTINUE
C
C     *** DETERMINATION OF FERMI LEVEL ***
C
      IF(HFFRM) THEN
        IF(MASWRK) WRITE(IW,9220) 'ALPHA',FRMLVA
      ELSE
        FRMOLD=FRMLVA
        FRMLV =FRMOLD
        CALL FRMLEV(EIGT,X(LWT),X(LKEGTS),X(LKTP),NLC1,ELENDC,
     *              NA,FRMLV,DBUG)
        FRMLVA=FRMLV
        IF(MASWRK) WRITE(IW, 9210) 'ALPHA',FRMOLD, FRMLVA
      END IF
      IF(UHF) THEN
        IF(HFFRM) THEN
          IF(MASWRK) WRITE(IW,9220) ' BETA',FRMLVB
        ELSE
          FRMOLD=FRMLVB
          FRMLV =FRMOLD
          CALL FRMLEV(EIGTB,X(LWTB),X(LKEGTS),X(LKTP),NLC1,ELENDC,
     *                NB,FRMLV,DBUG)
          FRMLVB=FRMLV
          IF(MASWRK) WRITE(IW, 9210) ' BETA',FRMOLD, FRMLVB
        END IF
      END IF
C
      CALL RETFM(NEEDT2)
C
      RETURN
C
 9200 FORMAT(/1X,'** RECONSTRUCTING SUBSYSTEM ORBITALS **')
 9210 FORMAT( 5X,A5,' FERMI LEVEL: OLD =',F15.7/
     *        10X,  '              NEW =',F15.7/)
 9220 FORMAT( 5X,'USE ',A5,' FERMI LEVEL DETERMINED BY HF CALCULATION'/
     *        5X,'    FERMI LEVEL =',F15.7)
      END
C
C*MODULE DCLIB   *DECK PREVSDC
C        MODIFIED FROM PREVS
      SUBROUTINE PREVSDC(ISUB,V,E,LABMO,NMO,NAO,LDV,ISTMO)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXATM=2000, MXAO=8192, MXSH=5000, MXGTOT=20000)
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      DIMENSION V(LDV,NMO),E(NMO),LABMO(NMO)
C
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
C
C     ----- PRINT OUT EIGENDATA, WITH MO SYMMETRY LABELS -----
C     THE ROWS ARE LABELED WITH THE BASIS FUNCTION NAMES.
C
      IF (MASWRK) THEN
      IF(ISUB.NE.0) WRITE (IW,9000) ISUB
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      IMAX = ISTMO-1
C
  100 IMIN = IMAX+1
      IMAX = IMAX+MAX
      IF (IMAX .GT. NMO) IMAX = NMO
      WRITE (IW,9008)
      WRITE (IW,9028) (I,       I=IMIN,IMAX)
      WRITE (IW,9068) (E(I),    I=IMIN,IMAX)
      WRITE (IW,9078) (LABMO(I),I=IMIN,IMAX)
      JSH=1
      JSHT=LOC2TS(JSH)
      JNMX=KMAX(JSHT)-KMIN(JSHT)
      JNUM=-1
      DO 120 J = 1,NAO
         JNUM=JNUM+1
         JT=KLOC(JSHT)+JNUM
         WRITE (IW,9048) JT,BFLAB(JT),(V(J,I),I = IMIN,IMAX)
         IF(JNUM.GE.JNMX) THEN
            JNUM=-1
            JSH=JSH+1
            JSHT=LOC2TS(JSH)
            JNMX=KMAX(JSHT)-KMIN(JSHT)
         END IF
  120 CONTINUE
      IF (IMAX .LT. NMO) GO TO 100
      END IF
      RETURN
C
 9000 FORMAT(/10X,'SUBSYSTEM ',I5/10X,15(1H=))
 9008 FORMAT(1X)
 9028 FORMAT(15X,10(4X,I4,3X))
 9048 FORMAT(I5,2X,A8,10F11.6)
 9068 FORMAT(15X,10F11.4)
 9078 FORMAT(16X,10(5X,A4,2X))
      END
C
C*MODULE DCLIB   *DECK PRSQLDC
C        MODIFIED FROM PRSQL
      SUBROUTINE PRSQLDC(ISUB,V,M,N,NDIM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXATM=2000, MXAO=8192, MXSH=5000, MXGTOT=20000)
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      DIMENSION V(NDIM,M)
C
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
C
C     ----- PRINT OUT A SQUARE MATRIX WITH BASIS SET LABELS -----
C     -V- IS -N- ROWS BY -M- COLUMNS, WITH LEADING DIMENSION -NDIM-
C
      IF (MASWRK) THEN
      IF(ISUB.NE.0) WRITE (IW,9000) ISUB
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      IMAX = 0
  100 IMIN = IMAX+1
      IMAX = IMAX+MAX
      IF (IMAX .GT. M) IMAX = M
      WRITE (IW,9008)
      WRITE (IW,9028) (I,I = IMIN,IMAX)
      WRITE (IW,9008)
      JSH=1
      JSHT=LOC2TS(JSH)
      JNMX=KMAX(JSHT)-KMIN(JSHT)
      JNUM=-1
      DO 120 J = 1,N
         JNUM=JNUM+1
         JT=KLOC(JSHT)+JNUM
         WRITE (IW,9048) JT,BFLAB(JT),(V(J,I),I = IMIN,IMAX)
         IF(JNUM.GE.JNMX) THEN
            JNUM=-1
            JSH=JSH+1
            JSHT=LOC2TS(JSH)
            JNMX=KMAX(JSHT)-KMIN(JSHT)
         END IF
  120 CONTINUE
      IF (IMAX .LT. M) GO TO 100
      END IF
      RETURN
 9000 FORMAT(/10X,'SUBSYSTEM ',I5/10X,15(1H=))
 9008 FORMAT(1X)
 9028 FORMAT(15X,10(4X,I4,3X))
 9048 FORMAT(I5,2X,A8,10F11.6)
      END
C
C*MODULE DCLIB   *DECK PRTRILDC
C        MODIFIED FROM PRTRIL
      SUBROUTINE PRTRILDC(ISUB,D,N)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXATM=2000, MXAO=8192, MXSH=5000, MXGTOT=20000)
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      DIMENSION D(*)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
C
C     ----- PRINT SYMMETRIC MATRIX -D- OF DIMENSION -N- -----
C     THE ROWS WILL BE LABELED WITH BASIS FUNCTION TAGS.
C
      IF (MASWRK) THEN
      IF(ISUB.NE.0) WRITE (IW,9000) ISUB
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      MM1 = MAX - 1
      ISH=1
      ISHT=LOC2TS(ISH)
      INMX=KMAX(ISHT)-KMIN(ISHT)
      INUM=-1
      DO 120 I0=1,N,MAX
         IL = MIN(N,I0+MM1)
         WRITE(IW,9008)
         WRITE(IW,9028) (I,I=I0,IL)
         WRITE(IW,9008)
         IL = -1
         JSH=ISH
         JSHT=ISHT
         JNMX=INMX
         JNUM=INUM
         DO 100 I=I0,N
            JNUM=JNUM+1
            JT=KLOC(JSHT)+JNUM
            IL=IL+1
            J0=I0+(I*I-I)/2
            JL=J0+MIN(IL,MM1)
            WRITE(IW,9048) JT,BFLAB(JT),(D(J),J=J0,JL)
            IF(JNUM.GE.JNMX) THEN
               JNUM=-1
               JSH=JSH+1
               JSHT=LOC2TS(JSH)
               JNMX=KMAX(JSHT)-KMIN(JSHT)
            END IF
  100    CONTINUE
         DO I00=1,MAX
            INUM=INUM+1
            IF(INUM.GE.INMX) THEN
               INUM=-1
               ISH=ISH+1
               ISHT=LOC2TS(ISH)
               INMX=KMAX(ISHT)-KMIN(ISHT)
            END IF
         END DO
  120 CONTINUE
      END IF
      RETURN
 9000 FORMAT(/10X,'SUBSYSTEM ',I5/10X,15(1H=))
 9008 FORMAT(1X)
 9028 FORMAT(15X,10(4X,I4,3X))
 9048 FORMAT(I5,2X,A8,10F11.6)
      END
C
C*MODULE DCLIB   *DECK PRITRL
      SUBROUTINE PRITRL(ID,N)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXATM=2000, MXAO=8192)
C
      DIMENSION ID(*)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
C
C     ----- PRINT SYMMETRIC INTEGER MATRIX -ID- OF DIMENSION -N- -----
C     THE ROWS WILL BE LABELED WITH BASIS FUNCTION TAGS.
C
      IF (MASWRK) THEN
         MAX = 10
         MM1 = MAX - 1
         DO 120 I0=1,N,MAX
            IL = MIN(N,I0+MM1)
            WRITE(IW,9008)
            WRITE(IW,9028) (I,I=I0,IL)
            WRITE(IW,9008)
            IL = -1
            DO 100 I=I0,N
               IL=IL+1
               J0=I0+(I*I-I)/2
               JL=J0+MIN(IL,MM1)
               WRITE(IW,9048) I,BFLAB(I),(ID(J),J=J0,JL)
  100       CONTINUE
  120    CONTINUE
      END IF
C
      RETURN
C
 9008 FORMAT(1X)
 9028 FORMAT(15X,10(1X,I4,1X))
 9048 FORMAT(I5,2X,A8,10I6)
      END
C
C*MODULE DCLIB   *DECK QMATDC
      SUBROUTINE QMATDC(NUM,DBG)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL DBG
C
      PARAMETER (MXATM=2000,MXLATM=200,MXLSHL=700)
C
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
      LOGICAL DCFLG
      COMMON /DCOPT / SUBTYP,BUFTYP,SUBLNG,BUFRAD,NDCPRT,NSUBS,DCFLG
      COMMON /DCQMT / NLQMT(MXATM)
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
      COMMON /IODC  / IDCSUB,IDCVEC,IDCDM,IDCQ,IDCDMO,IDCEIG,IDCW,IDCEDM
C
C     ----- GENERATE LOCAL Q-MATRIX -----
C       Q-MATRIX FOR EACH LOCALIZATION REGION
C            IS NEEDED FOR DIVIDE-AND-CONQUER METHOD
C      ( THIS SUBROUTINE MUST BE CALLED
C          IF GUESS IS HUCKEL, MOREAD, RDMINI, OR MOSAVED )
C
      LT1=NUM
      LT3=LT1*LT1
      LT2=(LT1+LT3)/2
C
      CALL VALFM(LOADFM)
      LST   = LOADFM+ 1
      LAST  = LST   + LT2
C
      NEED0 = LAST - LOADFM - 1
      CALL GETFM(NEED0)
C
      CALL DAREAD(IDAF,IODA,X(LST),LT2,12,0)
      CALL SEQREW(IDCQ)
C
      DO ISUB=1,NSUBS
C
C        --- IN THE ISUB-TH LOCALIZATION REGION
         IF(DBG) WRITE(IW,9000) ISUB
C
         CALL LOCREG(ISUB)
C
         L1=LNUM
         L3=L1*L1
         L2=(L3+L1)/2
C
         CALL VALFM(LOADFM)
         LEIG  = LOADFM+1
         LS    = LEIG  + L1
         LQ    = LS    + L2
         LVEC  = LQ    + L3
         LSCR  = LVEC  + L3
         LIWRK = LSCR  + 8*L1
         LAST  = LIWRK + L1
C
         NEED1 = LAST - LOADFM - 1
         CALL GETFM(NEED1)
C
         CALL TRT2LC(X(LST),X(LS),LT1,LT2,L1,L2,'OVERLAP ')
         CALL QMTSYM(X(LS),X(LVEC),X(LQ),X(LEIG),
     *               X(LSCR),X(LIWRK),L0,L1,L2,L3,DBG)
C
         CALL SQWRIT(IDCQ,X(LQ),L3)
         NLQMT(ISUB)=L0
C
         CALL RETFM(NEED1)
C
      END DO
C
      CALL RETFM(NEED0)
C
      IF(DBG) WRITE(IW,9100)
C
      RETURN
C
 9000 FORMAT(/5X,'*** IN THE ',I3,' TH LOCALIZATION REGION  ***')
 9100 FORMAT(/1X,'END OF GENERATING LOCAL Q MATRICES')
      END
C
C*MODULE DCLIB   *DECK STLC2T
      SUBROUTINE STLC2T(A,LA2,SUB,LSUB2,PARTMX)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION A(LA2), SUB(LSUB2)
C
      LOGICAL PARTMX
C
      PARAMETER (MXSH=5000, MXGTOT=20000)
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
C
      COMMON /DCEGG / NLATE,NLSHE,LNUME
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
C
      PARAMETER (HALF=0.5D+00, ZERO=0.0D+00, ONE=1.0D+00)
C
C     *** MATRIX TRANSFORMATION FROM LOCAL ORDER TO GLOBAL ORDER ***
C        (ONLY 1 LOCALIZATION)
C
C     ### THIS SUBROUTINE SHOULD BE CALLED AFTER CALLING LOCREG ###
C
C     INPUT
C         SUB: LSUB1*LSUB1 CANONICAL MATRIX ORDERED BY SUBSYSTEM INDICES
C     OUTPUT
C           A: LA1*LA1 CANONICAL MATRIX ORDERED BY TOTAL SYSTEM INDICES
C
      K=0
      IF(PARTMX) THEN
        DO IBSHL=1,NLSH-NLSHE
          IASHL=LOC2TS(IBSHL)
          IALOCT=KLOC(IASHL)
          FISHL=ZERO
          IF(IBSHL.LE.NLSHC) FISHL=ONE
          DO IBBSFN=1,KMAX(IASHL)-KMIN(IASHL)+1
             IALOC=IALOCT+IBBSFN-1
             LOCAI=IALOC*(IALOC-1)/2
             DO JBSHL=1,IBSHL
                JASHL=LOC2TS(JBSHL)
                JALOCT=KLOC(JASHL)
                FIJSHL=FISHL
                IF(JBSHL.LE.NLSHC) FIJSHL=MAX(FISHL,HALF)
                JBEND=KMAX(JASHL)-KMIN(JASHL)+1
                IF (IBSHL.EQ.JBSHL) JBEND=IBBSFN
                DO JBBSFN=1,JBEND
                   JALOC=JALOCT+JBBSFN-1
                   K=K+1
                   IF (IALOC .GE. JALOC) THEN
                      KA=LOCAI+JALOC
                   ELSE
                      KA=JALOC*(JALOC-1)/2+IALOC
                   END IF
                   A(KA)=A(KA)+SUB(K)*FIJSHL
                END DO
             END DO
          END DO
        END DO
      ELSE
        DO IBSHL=1,NLSH
          IASHL=LOC2TS(IBSHL)
          IALOCT=KLOC(IASHL)
          DO IBBSFN=1,KMAX(IASHL)-KMIN(IASHL)+1
             IALOC=IALOCT+IBBSFN-1
             LOCAI=IALOC*(IALOC-1)/2
             DO JBSHL=1,IBSHL
                JASHL=LOC2TS(JBSHL)
                JALOCT=KLOC(JASHL)
                JBEND=KMAX(JASHL)-KMIN(JASHL)+1
                IF (IBSHL.EQ.JBSHL) JBEND=IBBSFN
                DO JBBSFN=1,JBEND
                   JALOC=JALOCT+JBBSFN-1
                   K=K+1
                   IF (IALOC .GE. JALOC) THEN
                      KA=LOCAI+JALOC
                   ELSE
                      KA=JALOC*(JALOC-1)/2+IALOC
                   END IF
                   A(KA)=A(KA)+SUB(K)
                END DO
             END DO
          END DO
        END DO
      END IF
C
      RETURN
C
      END
C
C*MODULE DCLIB   *DECK SUBAUT
      SUBROUTINE SUBAUT(SUBTYP,SUBLNG,NSUBS)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXATM=2000)
      PARAMETER (ZERO=0.0D+00, HALF=0.5D+00, ONE=1.0D+00)
      PARAMETER (UNITAB=ONE/0.52917724924D+00)
      PARAMETER (CVTHR=0.95D+00)
C
      COMMON /ECP2  / CLP(400),ZLP(400),NLP(400),KFIRST(MXATM,6),
     *                KLAST(MXATM,6),LMAX(MXATM),LPSKIP(MXATM),
     *                IZCORE(MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C
      COMMON /DCSUB / LBSUBS(MXATM)
C
      DATA AUTBND/8HAUTBND  /
C
      DIMENSION CNEW(3,MXATM)
C
      PI = ACOS(-ONE)
C
C     ### FORM APPROPRIATE CARTESIAN COORDINATE ###
C
      CALL CALCOM(COMX,COMY,COMZ)
C
C     ROTATE AXIS 1
C
      DSTMAX=ZERO
      IMAX  =0
      DO I=1,NAT
         CNEW(1,I) = C(1,I)-COMX
         CNEW(2,I) = C(2,I)-COMY
         CNEW(3,I) = C(3,I)-COMZ
         DIST=CNEW(1,I)*CNEW(1,I) +
     *        CNEW(2,I)*CNEW(2,I) +
     *        CNEW(3,I)*CNEW(3,I)
         IF((DIST.GT.DSTMAX) .AND. (ZAN(I).GT.ONE)) THEN
            IMAX  =I
            DSTMAX=DIST
         ENDIF
      ENDDO
      RMAX=SQRT(DSTMAX)
C
C     = Z =
      IF(CNEW(2,IMAX).NE.ZERO) THEN
         THETA=ATAN(CNEW(1,IMAX)/CNEW(2,IMAX))
      ELSE
         THETA=PI*HALF
      ENDIF
C
      DO I=1, NAT
         CX=CNEW(1,I)
         CY=CNEW(2,I)
         CNEW(1,I)=CX*COS(THETA) - CY*SIN(THETA)
         CNEW(2,I)=CX*SIN(THETA) + CY*COS(THETA)
      ENDDO
C
C     = X =
      IF(CNEW(3,IMAX).NE.ZERO) THEN
         THETA=ATAN(CNEW(2,IMAX)/CNEW(3,IMAX))
      ELSE
         THETA=PI*HALF
      ENDIF
C
      DO I=1, NAT
         CY=CNEW(2,I)
         CZ=CNEW(3,I)
         CNEW(2,I)=CY*COS(THETA) - CZ*SIN(THETA)
         CNEW(3,I)=CY*SIN(THETA) + CZ*COS(THETA)
      ENDDO
C
C     ROTATE AXIS 2
C
      DSTMAX=ZERO
      IMAX  =0
      DO I=1,NAT
         DIST=CNEW(1,I)*CNEW(1,I) + CNEW(2,I)*CNEW(2,I)
         IF((DIST.GT.DSTMAX) .AND. (ZAN(I).GT.ONE)) THEN
            IMAX  =I
            DSTMAX=DIST
         ENDIF
      ENDDO
C
C     = Z =
      IF(CNEW(2,IMAX).NE.ZERO) THEN
         THETA=ATAN(CNEW(1,IMAX)/CNEW(2,IMAX))
      ELSE
         THETA=PI*HALF
      ENDIF
C
      DO I=1, NAT
         CX=CNEW(1,I)
         CY=CNEW(2,I)
         CNEW(1,I)=CX*COS(THETA) - CY*SIN(THETA)
         CNEW(2,I)=CX*SIN(THETA) + CY*COS(THETA)
      ENDDO
C
C     SEPARATE BY GRID
C
      NUMSID=INT(RMAX/SUBLNG)+1
      DISLOG=NUMSID*SUBLNG
      NUMS1 =NUMSID*2
      NUMS2 =NUMS1*NUMS1
C
      DO I=1, NAT
         CX=CNEW(1,I) + DISLOG
         CY=CNEW(2,I) + DISLOG
         CZ=CNEW(3,I) + DISLOG
         IPTX=INT(CX/SUBLNG) + 1
         IPTY=INT(CY/SUBLNG) + 1
         IPTZ=INT(CZ/SUBLNG) + 1
         LBSUBS(I)=-(IPTX*NUMS2 + IPTY*NUMS1 + IPTZ)
      ENDDO
C
C     CHECK BOND LENGTH IF SUBTYP=AUTBND
C
      IF(SUBTYP.EQ.AUTBND) THEN
C
C        NON-HYDROGEN ATOMS
         DO I=1, NAT
            IATM=IABS(INT(ZAN(I))) + IZCORE(I)
            ISUBNO=LBSUBS(I)
            IF(IATM.GT.1) THEN
               DO J=1, I-1
                  JATM=IABS(INT(ZAN(J))) + IZCORE(J)
                  IF(JATM.GT.1) THEN
                     TESTCV=COVRAD(IATM,JATM)*UNITAB*CVTHR
                     TESTCV=TESTCV*TESTCV
                     CX=CNEW(1,I)-CNEW(1,J)
                     CY=CNEW(2,I)-CNEW(2,J)
                     CZ=CNEW(3,I)-CNEW(3,J)
                     DIST=CX*CX + CY*CY + CZ*CZ
                     IF(DIST.LE.TESTCV) THEN
                        JSUBNO=LBSUBS(J)
                        DO K=1, I-1
                          IF(LBSUBS(K).EQ.JSUBNO) LBSUBS(K)=ISUBNO
                        ENDDO
                     ENDIF
                  ENDIF
               ENDDO
            ENDIF
         ENDDO
C
C        HYDROGEN ATOMS
         DO I=1, NAT
            IATM=IABS(INT(ZAN(I)))
            IF(IATM.LE.1) THEN
               IMIN=0
               DSTMIN=RMAX*RMAX*4
               DO J=1, NAT
                  CX=CNEW(1,I)-CNEW(1,J)
                  CY=CNEW(2,I)-CNEW(2,J)
                  CZ=CNEW(3,I)-CNEW(3,J)
                  DIST=CX*CX + CY*CY + CZ*CZ
                  IF((DIST.LT.DSTMIN) .AND. (ZAN(J).GT.ONE)) THEN
                     IMIN  =J
                     DSTMIN=DIST
                  ENDIF
               ENDDO
               LBSUBS(I)=LBSUBS(IMIN)
            ENDIF
         ENDDO
      ENDIF
C
C     ASSIGN APPROPRIATE SUBSYSTEM NUMBER
C
      NSUBS=0
      DO I=1, NAT
         ISUBNO=LBSUBS(I)
         IF(ISUBNO.LT.0) THEN
            NSUBS=NSUBS+1
            LBSUBS(I)=NSUBS
            DO J=I+1, NAT
               IF(LBSUBS(J).EQ.ISUBNO) LBSUBS(J)=NSUBS
            ENDDO
         ENDIF
      ENDDO
C
      RETURN
C
      END
C
C*MODULE DCLIB   *DECK SUBCRD
      SUBROUTINE SUBCRD(BUFTYP,IFLG,NSUBS,OUT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      CHARACTER*8 FLGPNC(0:1),ENDWRD,ENDCHK
C
      PARAMETER (MXATM=2000)
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      LOGICAL OUT
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      COMMON /DCSUB / LBSUBS(MXATM)
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
      COMMON /IODC  / IDCSUB,IDCVEC,IDCDM,IDCQ,IDCDMO,IDCEIG,IDCW,IDCEDM
C
      LOGICAL NUMERC
C
      DATA CARD   /8HCARD    /
      DATA FLGPNC /' $SUBSCF',' $SUBCOR'/
      DATA ENDWRD /'$END    '/
C
      EXTERNAL REREAD
C
      CALL VICLR(LOC2TA,1,MXLATM)
      CALL VICLR(LBSUBS,1,MXATM)
      NLAT=0
      IPRE=0
      ISUB=1
      NPHASE=1
C
      CALL SEQREW(IDCSUB)
      CALL SEQREW(IR)
      CALL FNDGRP(IR,FLGPNC(IFLG),JEOF)
      IF (JEOF.EQ.1 .AND. MASWRK) THEN
         WRITE(IW,*) ' NO ',FLGPNC(IFLG),' GROUP FOUND !!!'
         CALL ABRT
      END IF
      CALL OPNCRD(IR,-IW)
C
C     --- OBTAIN NEXT CARD
C     --- IF IT IS NAMED "$END" THEN WE ARE DONE.
C
C     --- FIND LABEL OF THE ATOM WITH THE NUMBER ICNTR
  100 CONTINUE
      IEOF=0
      CALL RDCARD(FLGPNC(IFLG),IEOF)
      ENDCHK = '        '
      LENGST = -8
      CALL GSTRNG(ENDCHK,LENGST)
      IF(ENDCHK.EQ.ENDWRD) GOTO 500
      CALL REREAD
  110 CONTINUE
         IERR=0
         ENDCHK = '        '
         LENGST = -8
         CALL GSTRNG(ENDCHK,LENGST)
         IF(NUMERC(ENDCHK)) THEN
            CALL REREAD
            IATM = IFIND('IATM    ',IERR)
            IF(IERR.EQ.1) CALL ABRT
         ELSE
            GOTO 100
         ENDIF
C         IF(NCOL.GT.MAXCOL) GOTO 100
         IF(IATM.EQ.0) THEN
            IF(NPHASE.EQ.1) THEN
               LOC2TA(NLAT)=-LOC2TA(NLAT)
               IF(IPRE.EQ.0) THEN
                  IF(MASWRK) WRITE(IW,9510) ISUB
                  CALL ABRT
               ELSE
                  NLATC=NLAT
                  NPHASE=2
               ENDIF
            ELSE IF(NPHASE.EQ.2) THEN
C     (THIS PHASE IS RESERVED FOR FUTURE EXTENSION)
               IF(NLAT.NE.NLATC) LOC2TA(NLAT)=-LOC2TA(NLAT)
               NLATL=NLAT
               NPHASE=3
            ELSE
               IF(NLAT.NE.NLATL) LOC2TA(NLAT)=-LOC2TA(NLAT)
               DO I=1,NLAT
                  DO J=1, I-1
                     IF(LOC2TA(I).EQ.LOC2TA(J)) THEN
                        IF(MASWRK) WRITE(IW,9550) ISUB
                        CALL ABRT
                     ENDIF
                  ENDDO
               ENDDO
               IF ((BUFTYP.EQ.CARD).AND.(DSKWRK.OR.MASWRK))
     *            WRITE(IDCSUB) ISUB,LOC2TA
C
C              PUNCH OUT SUBSYSTEM INFORMATION
C
               LOC2TA(NLAT)=-LOC2TA(NLAT)
               IF(NLAT .NE.NLATL) LOC2TA(NLATL)=-LOC2TA(NLATL)
               IF(NLATL.NE.NLATC) LOC2TA(NLATC)=-LOC2TA(NLATC)
               IF(OUT) CALL SUBPRT(IP,LOC2TA,NLATC,NLATL,NLAT,ISUB)
C
               NLAT=0
               ISUB=ISUB+1
               CALL VICLR(LOC2TA,1,MXLATM)
               NPHASE=1
            ENDIF
C
         ELSE IF(IATM.GT.0) THEN
            NLAT=NLAT+1
            IF(NLAT.GT.MXLATM) THEN
               IF(MASWRK) WRITE(IW,9500) MXLATM
               CALL ABRT
            ENDIF
            LOC2TA(NLAT)=IATM
            IF(NPHASE.EQ.1) LBSUBS(IATM)=ISUB
C
         ELSE IF(IPRE.GT.0 .AND. IPRE.LT.-IATM) THEN
            DO J=IPRE+1,-IATM
               NLAT=NLAT+1
               IF(NLAT.GT.MXLATM) THEN
                  IF(MASWRK) WRITE(IW,9500) MXLATM
                  CALL ABRT
               ENDIF
               IF(LOC2TA(NLAT).EQ.0) THEN
                  LOC2TA(NLAT)=J
                  IF(NPHASE.EQ.1) LBSUBS(J)=ISUB
               ELSE
                  IF(MASWRK) WRITE(IW,9520) J
                  CALL ABRT
               ENDIF
            ENDDO
         ELSE
            IF(MASWRK) WRITE(IW,9530)
            CALL ABRT
         ENDIF
         IPRE=IATM
      GOTO 110
C
  500 CONTINUE
C
C     CHECK LBSUBS
C
      IF(NPHASE.NE.1) THEN
         IF(MASWRK) WRITE(IW,9530)
         CALL ABRT
      ENDIF
C
      NSUBS=ISUB-1
C
      DO I=1,NAT
         IF(LBSUBS(I).EQ.0) THEN
            IF(MASWRK) WRITE(IW,9560) I
            CALL ABRT
         ENDIF
      ENDDO
C
      RETURN
C
 9500 FORMAT (/1X,'***ERROR***'/
     *         1X,'NUMBER OF ATOMS IN A SUBSYSTEM EXCEEDS MAX',I5)
 9510 FORMAT (/1X,'***ERROR***'/
     *         1X,'THERE IS NO ATOM IN SUBSYSTEM ',I5,'.')
 9520 FORMAT(' *** ERROR! ATOM ',I5,' IS ASSIGNED TO ',
     *       'MULTIPLE SUBSYSTEMS.')
 9530 FORMAT(' *** ERROR WHEN READING SUBSYSTEMS.')
 9550 FORMAT (/1X,'***ERROR***'/
     *         1X,'THERE ARE TWO OR MORE SAME ATOMS IN SUBSYSTEM ',I5)
 9560 FORMAT(' *** ERROR! ATOM ',I5,' IS ASSIGNED TO NO SUBSYSTEMS.')
      END
C
C*MODULE DCLIB   *DECK SUBPRT
      SUBROUTINE SUBPRT(IP,LOC2TA,NLATC,NLATL,NLAT,ISUB)
C
C     PRINT OUT SUBSYSTEM INFORMATION ON PUNCH
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION LOC2TA(NLAT)
      DIMENSION IPRATM(27)
      CHARACTER*6 PRTFMT
C
      WRITE(IP,7000) ISUB
C
C     CHECK MAXIMUM OF LOC2TA
C
      MXLOC2=0
      DO I=1, NLAT
         MXLOC2=MAX(LOC2TA(I),MXLOC2)
      ENDDO
      IF     (MXLOC2.LT.10   ) THEN
                              PRTFMT='(26I3)'
                              IDIG=3
      ELSE IF(MXLOC2.LT.100  ) THEN
                              PRTFMT='(26I4)'
                              IDIG=4
      ELSE IF(MXLOC2.LT.1000 ) THEN
                              PRTFMT='(26I5)'
                              IDIG=5
      ELSE IF(MXLOC2.LT.10000) THEN
                              PRTFMT='(26I6)'
                              IDIG=6
      ELSE
                              PRTFMT='(26I7)'
                              IDIG=7
      ENDIF
C
C     PRINT CENTRAL REGION
C
      IPNT=1
      IPRE=-1
      IPRE2=-1
      DO I=1,NLATC
         INEW=LOC2TA(I)
         IF(INEW.EQ.(IPRE+1)) THEN
            IPRATM(IPNT)=-INEW
         ELSE
            IF(IPRE.EQ.(IPRE2+1)) IPNT=IPNT+1
            IPRATM(IPNT)=INEW
            IPNT=IPNT+1
         ENDIF
         MAXPRT=80/IDIG-1
         IF(IPNT.GT.MAXPRT) THEN
            WRITE(IP,FMT=PRTFMT) (IPRATM(J), J=1,MAXPRT)
            DO JPNT=1, IPNT-MAXPRT-1
               INEW=IPRATM(JPNT+MAXPRT)
               IPRATM(JPNT)=INEW
            ENDDO
            IPNT=IPNT-MAXPRT
         ENDIF
         IPRE2=IPRE
         IPRE=INEW
      END DO
      IF(IPRE.EQ.(IPRE2+1)) IPNT=IPNT+1
      IPRATM(IPNT)=0
      WRITE(IP,FMT=PRTFMT) (IPRATM(J), J=1,IPNT)
C
C     PRINT BUFFER REGION
C
      IPNT=1
      IPRE=-1
      IPRE2=-1
      DO I=NLATC+1,NLATL
         INEW=LOC2TA(I)
         IF(INEW.EQ.(IPRE+1)) THEN
            IPRATM(IPNT)=-INEW
         ELSE
            IF(IPRE.EQ.(IPRE2+1)) IPNT=IPNT+1
            IPRATM(IPNT)=INEW
            IPNT=IPNT+1
         ENDIF
         MAXPRT=80/IDIG-1
         IF(IPNT.GT.MAXPRT) THEN
            WRITE(IP,FMT=PRTFMT) (IPRATM(J), J=1,MAXPRT)
            DO JPNT=1, IPNT-MAXPRT-1
               INEW=IPRATM(JPNT+MAXPRT)
               IPRATM(JPNT)=INEW
            ENDDO
            IPNT=IPNT-MAXPRT
         ENDIF
         IPRE2=IPRE
         IPRE=INEW
      END DO
      IF(IPRE.EQ.(IPRE2+1)) IPNT=IPNT+1
      IPRATM(IPNT)=0
      WRITE(IP,FMT=PRTFMT) (IPRATM(J), J=1,IPNT)
C
C     PRINT EGG-SHELL REGION
C
      IPNT=1
      IPRE=-1
      IPRE2=-1
      DO I=NLATL+1,NLAT
         INEW=LOC2TA(I)
         IF(INEW.EQ.(IPRE+1)) THEN
            IPRATM(IPNT)=-INEW
         ELSE
            IF(IPRE.EQ.(IPRE2+1)) IPNT=IPNT+1
            IPRATM(IPNT)=INEW
            IPNT=IPNT+1
         ENDIF
         MAXPRT=80/IDIG-1
         IF(IPNT.GT.MAXPRT) THEN
            WRITE(IP,FMT=PRTFMT) (IPRATM(J), J=1,MAXPRT)
            DO JPNT=1, IPNT-MAXPRT-1
               INEW=IPRATM(JPNT+MAXPRT)
               IPRATM(JPNT)=INEW
            ENDDO
            IPNT=IPNT-MAXPRT
         ENDIF
         IPRE2=IPRE
         IPRE=INEW
      END DO
      IF(IPRE.EQ.(IPRE2+1)) IPNT=IPNT+1
      IPRATM(IPNT)=0
      WRITE(IP,FMT=PRTFMT) (IPRATM(J), J=1,IPNT)
C
      RETURN
C
 7000 FORMAT('! SUBSYSTEM ',I5)
      END
C
C*MODULE DCLIB   *DECK TOLOC
      SUBROUTINE TOLOC
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXSH=5000, MXGTOT=20000, MXAO=8192,
     *           MXLATM=200, MXLSHL=700)
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
C
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
      COMMON /TO2LC / IT2LOC(MXAO)
C
C     *** BASIS RENUMBERING FROM TOTAL REGION TO SUBSYSTEM ***
C
      DO I=1,NUM
         IT2LOC(I)=0
      END DO
C
      DO I=1,NLSH
         ISHT=LOC2TS(I)
         IKLT=LCKLOC(I)
         KMN=KMIN(ISHT)
         KMX=KMAX(ISHT)
         KLC=KLOC(ISHT)
         DO K=KMN,KMX
            IT2LOC(KLC+K-KMN)=IKLT+K-KMN
         END DO
      END DO
C
      RETURN
      END
C
C*MODULE DCLIB   *DECK TRLC2T
      SUBROUTINE TRLC2T(IDCDM,A,B,WRK,LA1,LA2,STRNG,PARTMX,UHF)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      CHARACTER*8 STRNG
      DIMENSION A(LA2), WRK(*)
      DIMENSION B(LA2)
      LOGICAL UHF
C
      LOGICAL DBUG,GOPARR,DSKWRK,MASWRK,PARTMX
C
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
      LOGICAL DCFLG
      COMMON /DCOPT / SUBTYP,BUFTYP,SUBLNG,BUFRAD,NDCPRT,NSUBS,DCFLG
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
C
      DATA DEBUG/8HDEBUG   /
C
C     *** MATRIX TRANSFORMATION FROM LOCAL ORDER TO GLOBAL ORDER ***
C        (IN THE LOCALIZATION OR LSO REGION)
C
C     INPUT
C       IDCDM : FILE NO. CONTAINING SUBSYSTEM MATRIX IN CANONICAL ORDER
C         RAD : BUFRAD (-> LOCALIZATN REGION) OR RADLSO (-> LSO REGION)
C      PARTMX : MULTIPLY PARTITION MATRIX OR NOT
C     OUTPUT
C           A : LA1*LA1 CANONICAL MATRIX ORDERED BY TOTAL SYSTEM INDICES
C
      DBUG = MASWRK .AND. EXETYP.EQ.DEBUG
C
      LA2CHK=LA1*(LA1+1)/2
      IF(LA2CHK .NE. LA2) THEN
         IF(MASWRK) WRITE(IW,9100) LA1,LA2CHK,LA2
         CALL ABRT
      END IF
C
      CALL VCLR(A,1,LA2)
      IF(UHF) CALL VCLR(B,1,LA2)
C
      IF(DBUG) WRITE(IW,9010) STRNG
      CALL SEQREW(IDCDM)
      DO ISUB=1,NSUBS
C
         IF(DBUG) WRITE(IW,9140) ISUB
         CALL LOCREG(ISUB)
C
         LNUM2=LNUM*(LNUM+1)/2
         CALL SQREAD(IDCDM,WRK,LNUM2)
C
         IF(DBUG) CALL PRTRILDC(ISUB,WRK,LNUM)
C
         CALL STLC2T(A,LA2,WRK,LNUM2,PARTMX)
         IF(UHF) THEN
            CALL SQREAD(IDCDM,WRK,LNUM2)
            IF(DBUG) CALL PRTRILDC(ISUB,WRK,LNUM)
            CALL STLC2T(B,LA2,WRK,LNUM2,PARTMX)
         END IF
      END DO
      CALL SEQREW(IDCDM)
C
      IF (STRNG.EQ.'DENSITY ') THEN
         CALL DAWRIT(IDAF,IODA,A,LA2,16,0)
         IF(UHF) CALL DAWRIT(IDAF,IODA,B,LA2,20,0)
      END IF
C
      IF(DBUG) THEN
         IF(MASWRK) WRITE(IW,9000) STRNG
         CALL PRTRIL(A,LA1)
         IF(UHF) THEN
            IF(MASWRK) WRITE(IW,9005) STRNG
            CALL PRTRIL(B,LA1)
         END IF
      END IF
C
      RETURN
C
 9000 FORMAT (/1X,A8,' MATRIX IN TOTAL REGION')
 9005 FORMAT (/1X,A8,' MATRIX IN TOTAL REGION (BETA)')
 9010 FORMAT (/1X,A8,' MATRIX IN THE LOCALIZATION REGION')
 9100 FORMAT (1X,'***** ERROR! SIZE OF MATRIX A IS NOT CORRECT. LA1=',
     *        I8,' (',I8,' IN CANONICAL ORDER), LA2=',I8)
 9140 FORMAT (/1X,I5,' TH LOCALIZATION REGION')
      END
C
C*MODULE DCLIB   *DECK TRT2LC
      SUBROUTINE TRT2LC(A,B,LA1,LA2,LB1,LB2,STRNG)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      CHARACTER*8 STRNG
      DIMENSION A(LA2),B(LB2)
C
      LOGICAL DBUG,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXSH=5000, MXGTOT=20000)
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
C
      DATA DEBUG/8HDEBUG   /
C
C     *** MATRIX TRANSFORMATION FROM GLOBAL ORDER TO LOCAL ORDER ***
C        (IN THE LOCALIZATION REGION)
C
C      INPUT
C        A : LA1*LA1 CANONICAL MATRIX ORDERED BY TOTAL SYSTEM INDICES
C      OUTPUT
C        B : LB1*LB1 CANONICAL MATRIX ORDERED BY LOCAL SYSTEM INDICES
C
      DBUG = MASWRK .AND. EXETYP.EQ.DEBUG
C
      LA2CHK=LA1*(LA1+1)/2
      LB2CHK=LB1*(LB1+1)/2
C
      IF(LA2CHK .NE. LA2) THEN
         IF(MASWRK) WRITE(IW,9100) LA1,LA2CHK,LA2
         CALL ABRT
      END IF
      IF(LB2CHK .NE. LB2) THEN
         IF(MASWRK) WRITE(IW,9110) LB1,LB2CHK,LB2
         CALL ABRT
      END IF
C
      IF(DBUG) THEN
         IF(MASWRK) WRITE(IW,9000) STRNG
         CALL PRTRIL(A,LA1)
      END IF
C
      K=0
      DO IBSHL=1,NLSH
         IASHL=LOC2TS(IBSHL)
         IALOCT=KLOC(IASHL)
         DO IBBSFN=1,KMAX(IASHL)-KMIN(IASHL)+1
            IALOC=IALOCT+IBBSFN-1
            LOCAI=IALOC*(IALOC-1)/2
            DO JBSHL=1,IBSHL
               JASHL=LOC2TS(JBSHL)
               JALOCT=KLOC(JASHL)
               JBEND=KMAX(JASHL)-KMIN(JASHL)+1
               IF (IBSHL.EQ.JBSHL) JBEND=IBBSFN
               DO JBBSFN=1,JBEND
                  JALOC=JALOCT+JBBSFN-1
                  K=K+1
                  IF (IALOC .GE. JALOC) THEN
                     KA=LOCAI+JALOC
                  ELSE
                     KA=JALOC*(JALOC-1)/2+IALOC
                  END IF
                  B(K)=A(KA)
               END DO
            END DO
         END DO
      END DO
C
      IF(DBUG) THEN
         IF(MASWRK) WRITE(IW,9010) STRNG
         CALL PRTRILDC(0,B,LB1)
      END IF
C
      RETURN
C
 9000 FORMAT (/1X,A8,' MATRIX IN TOTAL REGION')
 9010 FORMAT (/1X,A8,' MATRIX IN THE LOCALIZATION REGION')
 9100 FORMAT (1X,'***** ERROR! SIZE OF MATRIX A IS NOT CORRECT. LA1=',
     *        I8,' (',I8,' IN CANONICAL ORDER), LA2=',I8)
 9110 FORMAT (1X,'***** ERROR! SIZE OF MATRIX B IS NOT CORRECT. LB1=',
     *        I8,' (',I8,' IN CANONICAL ORDER), LB2=',I8)
      END
C
C*MODULE DCLIB   *DECK TRTOSQ
      SUBROUTINE TRTOSQ(A,LDA)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION A(LDA,LDA)
C
C        TRANSFORM TRIANGULAR MATRIX TO SQUARE MATRIX
C
      DO 120 J=1,LDA
         JM1=J-1
         DO 110 I=1,JM1
            A(J,I) = A(I,J)
  110    CONTINUE
  120 CONTINUE
      RETURN
C
      END
C
C*MODULE DCLIB   *DECK TSUB
C        MODIFIED FROM HSANDT
      SUBROUTINE TSUB(V,NLCT,LL2,DBUG,DCCUT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION MOROKM
C
      LOGICAL DBUG,UNCON,DCCUT
      LOGICAL IANDJ,DOUBLE,GOPARR,DSKWRK,MASWRK,SCREEN
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000, MAXSH=84)
C
      DIMENSION V(LL2)
      DIMENSION VBLK(784),
     *          DIJ(784),IJX(784),IJY(784),IJZ(784),
     *          XIN(343),YIN(343),ZIN(343),CONI(MAXSH),CONJ(MAXSH),
     *          IX(84),IY(84),IZ(84),JX(84),JY(84),JZ(84)
C
C       IF TX,TY,TZ NEEDED, THESE FIRST THREE MUST:
C            A) BE ALLOCATED DYNAMICALLY,
C            B) BE GLOBAL SUMMMED,
C            C) BE SAVED TO THE DIRECT ACCESS FILE AT UNUSED RECORDS
C-XYZ-DIMENSION TX(LL2),TY(LL2),TZ(LL2)
C-XYZ-DIMENSION TXBLK(784),TYBLK(784),TZBLK(784)
C-XYZ-DIMENSION FTX(784),FTY(784),FTZ(784)
C
      PARAMETER (MXCHRM=1)
C
      COMMON /CHMGMS/ XCHM(MXCHRM),YCHM(MXCHRM),ZCHM(MXCHRM),
     *                DXELMM(MXCHRM),DYELMM(MXCHRM),DZELMM(MXCHRM),
     *                QCHM(MXCHRM),NCHMAT,KCHRMM
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /ROOT  / XX,U(13),W(13),NROOTS
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SCINP / VLAMB,SCREEN
      COMMON /STV   / XINT,YINT,ZINT,TAA,X0,Y0,Z0,
     *                XI,YI,ZI,XJ,YJ,ZJ,NI,NJ
      COMMON /WERMIT/ W1,W2(2),W3(3),W4(4),W5(5),W6(6),W7(7),
     *                W8(8),W9(9),W10(10),
     *                W11(11),W12(12),W13(13),W14(14),W15(15)
      COMMON /SHLNRM/ PNRM(84)
      COMMON /SYMIND/ TOL,II,JJ,LIT,LJT,MINI,MINJ,MAXI,MAXJ,IANDJ
      COMMON /RELWFN/ RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,IQRORD,MODQR,NESOC,
     *                NRATOM,NUMU,NQMTR,NQRDAF,MORDA,NDARELB
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      LOGICAL DCFLG
      LOGICAL DCFSKP
      DIMENSION NLCT(LL2)
C
      COMMON /DCOPT / SUBTYP,BUFTYP,SUBLNG,BUFRAD,NDCPRT,NSUBS,DCFLG
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
C
      PARAMETER (ZERO=0.0D+00, PT5=0.5D+00, ONE=1.0D+00, TWO=2.0D+00,
     *           PI212=1.1283791670955D+00, RLN10=2.30258D+00)
C
      DATA JX / 0, 1, 0, 0, 2, 0, 0, 1, 1, 0,
     *          3, 0, 0, 2, 2, 1, 0, 1, 0, 1,
     *          4, 0, 0, 3, 3, 1, 0, 1, 0, 2,
     *          2, 0, 2, 1, 1,
     *          5, 0, 0, 4, 4, 1, 0, 1, 0, 3,
     *          3, 2, 0, 2, 0, 3, 1, 1, 2, 2,
     *          1,
     *          6, 0, 0, 5, 5, 1, 0, 1, 0, 4,
     *          4, 2, 0, 2, 0, 4, 1, 1, 3, 3,
     *          0, 3, 3, 2, 1, 2, 1, 2/
      DATA IX / 1, 8, 1, 1,15, 1, 1, 8, 8, 1,
     *         22, 1, 1,15,15, 8, 1, 8, 1, 8,
     *         29, 1, 1,22,22, 8, 1, 8, 1,15,
     *         15, 1,15, 8, 8,
     *         36, 1, 1,29,29, 8, 1, 8, 1,22,
     *         22,15, 1,15, 1,22, 8, 8,15,15,
     *          8,
     *         43, 1, 1,36,36, 8, 1, 8, 1,29,
     *         29,15, 1,15, 1,29, 8, 8,22,22,
     *          1,22,22,15, 8,15, 8,15/
      DATA JY / 0, 0, 1, 0, 0, 2, 0, 1, 0, 1,
     *          0, 3, 0, 1, 0, 2, 2, 0, 1, 1,
     *          0, 4, 0, 1, 0, 3, 3, 0, 1, 2,
     *          0, 2, 1, 2, 1,
     *          0, 5, 0, 1, 0, 4, 4, 0, 1, 2,
     *          0, 3, 3, 0, 2, 1, 3, 1, 2, 1,
     *          2,
     *          0, 6, 0, 1, 0, 5, 5, 0, 1, 2,
     *          0, 4, 4, 0, 2, 1, 4, 1, 3, 0,
     *          3, 2, 1, 3, 3, 1, 2, 2/
      DATA IY / 1, 1, 8, 1, 1,15, 1, 8, 1, 8,
     *          1,22, 1, 8, 1,15,15, 1, 8, 8,
     *          1,29, 1, 8, 1,22,22, 1, 8,15,
     *          1,15, 8,15, 8,
     *          1,36, 1, 8, 1,29,29, 1, 8,15,
     *          1,22,22, 1,15, 8,22, 8,15, 8,
     *         15,
     *          1,43, 1, 8, 1,36,36, 1, 8,15,
     *          1,29,29, 1,15, 8,29, 8,22, 1,
     *         22,15, 8,22,22, 8,15,15/
      DATA JZ / 0, 0, 0, 1, 0, 0, 2, 0, 1, 1,
     *          0, 0, 3, 0, 1, 0, 1, 2, 2, 1,
     *          0, 0, 4, 0, 1, 0, 1, 3, 3, 0,
     *          2, 2, 1, 1, 2,
     *          0, 0, 5, 0, 1, 0, 1, 4, 4, 0,
     *          2, 0, 2, 3, 3, 1, 1, 3, 1, 2,
     *          2,
     *          0, 0, 6, 0, 1, 0, 1, 5, 5, 0,
     *          2, 0, 2, 4, 4, 1, 1, 4, 0, 3,
     *          3, 1, 2, 1, 2, 3, 3, 2/
      DATA IZ / 1, 1, 1, 8, 1, 1,15, 1, 8, 8,
     *          1, 1,22, 1, 8, 1, 8,15,15, 8,
     *          1, 1,29, 1, 8, 1, 8,22,22, 1,
     *         15,15, 8, 8,15,
     *          1, 1,36, 1, 8, 1, 8,29,29, 1,
     *         15, 1,15,22,22, 8, 8,22, 8,15,
     *         15,
     *          1, 1,43, 1, 8, 1, 8,36,36, 1,
     *         15, 1,15,29,29, 8, 8,29, 1,22,
     *         22, 8,15, 8,15,22,22,15/
C
      DATA MOROKM/8HMOROKUMA/
      DATA NONE,RNONE/4HNONE,8HNONE    /
C
C     ----- COMPUTE PARTIAL V INTEGRALS -----
C
      UNCON=RMETHOD.NE.RNONE.AND.MOD(MODQR,2).EQ.1
      TOL = RLN10*ITOL
C     NORM = NORMF .NE. 1 .OR. NORMP .NE. 1
C
C     ----- MOPAC INTEGRALS ARE DONE ELSEWHERE -----
C
      IF(MPCTYP.NE.NONE) THEN
         CALL MPCINT
         RETURN
      END IF
C
C     ----- RESET SOME PARAMETERS FOR MOROKUMA DECOMPOSITIONS -----
C     ISAVE .EQ. 0 : SAVE S, H, AND T TO DAF 12, 11, AND 13
C     ISAVE .EQ. 1 : SAVE S, H, AND T TO DAF 12, 11, AND 13
C                    AND SAVE S AND H TO DAF 312 AND 311
C     NOTE THAT LL2 IS ALWAYS (NUM*NUM+NUM)/2,
C     L1,L2 MAY BE SMALLER THAN USUAL FOR A MONOMER IN A MOROKUMA RUN
C
      IF (RUNTYP.EQ.MOROKM) THEN
         CALL STINT1(ISTART,IEND,JSTART,LOCIJ,NATST,NATED,ISAVE,L1,L2)
      ELSE
         ISTART = 1
         IEND   = NSHELL
         JSTART = 1
         LOCIJ  = 0
         NATST  = 1
         NATED  = NAT+NCHMAT
         ISAVE  = 0
         L1 = NUM
         IF(UNCON) L1=NUMU
         L2 = (L1*(L1+1))/2
      END IF
C
      IF(GOPARR) THEN
         CALL VCLR(V,1,LL2)
      END IF
      IF(DCFLG) CALL DAREAD(IDAF,IODA,NLCT,LL2,272,1)
C
C     ----- INTIALIZE PARALLEL -----
C
      IPCOUNT = ME - 1
C
C     ----- I SHELL -----
C
      DO 720 II = ISTART,IEND
         I = KATOM(II)
         XI = C(1,I)
         YI = C(2,I)
         ZI = C(3,I)
         I1 = KSTART(II)
         I2 = I1+KNG(II)-1
         LIT = KTYPE(II)
         MINI = KMIN(II)
         MAXI = KMAX(II)
         LOCI = KLOC(II)-MINI-LOCIJ
         IPOS = (KLOC(II)*(KLOC(II)-1))/2
C
C     ----- J SHELL -----
C
         DO 700 JJ = JSTART,II
C
C     ----- GO PARALLEL! (STATIC LOAD BALANCING) -----
C
            IF (GOPARR) THEN
               IPCOUNT = IPCOUNT + 1
               IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 700
            END IF
C
            J = KATOM(JJ)
            XJ = C(1,J)
            YJ = C(2,J)
            ZJ = C(3,J)
            J1 = KSTART(JJ)
            J2 = J1+KNG(JJ)-1
            LJT = KTYPE(JJ)
            MINJ = KMIN(JJ)
            MAXJ = KMAX(JJ)
            LOCJ = KLOC(JJ)-MINJ-LOCIJ
            NROOTS = (LIT+LJT-2)/2+1
            RR = (XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
            IANDJ = II .EQ. JJ
            DCFSKP = DCCUT.AND.(NLCT(IPOS+KLOC(JJ)).EQ.0)
C
C     ----- PREPARE INDICES FOR PAIRS OF (I,J) FUNCTIONS
C
            IJ = 0
            MAX = MAXJ
            DO 160 I = MINI,MAXI
               NX = IX(I)
               NY = IY(I)
               NZ = IZ(I)
               IF (IANDJ) MAX = I
               DO 140 J = MINJ,MAX
                  IJ = IJ+1
                  IJX(IJ) = NX+JX(J)
                  IJY(IJ) = NY+JY(J)
                  IJZ(IJ) = NZ+JZ(J)
C-XYZ-            FTX(IJ) = 2* JX(J)              + 1
C-XYZ-            FTY(IJ) = 2*       JY(J)        + 1
C-XYZ-            FTZ(IJ) = 2*             JZ(J)  + 1
  140          CONTINUE
  160       CONTINUE
C
            CALL VCLR( VBLK,1,IJ)
C
C     ----- I PRIMITIVE
C
            JGMAX = J2
            DO 520 IG = I1,I2
               AI = EX(IG)
               ARRI = AI*RR
               AXI = AI*XI
               AYI = AI*YI
               AZI = AI*ZI
               CALL SETCONI(CONI,IG,0)
C
C     ----- J PRIMITIVE
C
               IF (IANDJ) JGMAX = IG
               DO 500 JG = J1,JGMAX
                  AJ = EX(JG)
                  AA = AI+AJ
                  AA1 = ONE/AA
                  DUM = AJ*ARRI*AA1
                  IF (DUM .GT. TOL) GO TO 500
                  FAC = EXP(-DUM)
                  CALL SETCONI(CONJ,JG,0)
                  AX = (AXI+AJ*XJ)*AA1
                  AY = (AYI+AJ*YJ)*AA1
                  AZ = (AZI+AJ*ZJ)*AA1
C
C     ----- DENSITY FACTOR
C
C     THE ONLY REASON WHY -ILZ WORKS WITH THIS DENSITY THAT ASSUMES
C     HERMITICITY IS BECAUSE <I|-ILZ|I>=0 (MOMENTUM QUENCHING).
C
                  DOUBLE=IANDJ.AND.IG.NE.JG
                  MAX = MAXJ
                  NN = 0
                  DTWO=ONE
                  IF(DOUBLE) DTWO=TWO
C                 NOTE THAT PNRM FACTORS FOR S AND P SHELLS ARE 1.
                  SPDIJ=CS(IG)*CP(JG)*FAC
                  DO 220 I = MINI,MAXI
                     IF (IANDJ) MAX = I
                     FACI=FAC*CONI(I)*PNRM(I)*DTWO
                     NN1=NN+1
                     DO 200 J = MINJ,MAX
                        NN = NN+1
                        DIJ(NN)=FACI*CONJ(J)*PNRM(J)
C                    WRITE(6,*) 'WWWDIJ',NN,I,J,II,JJ,DIJ(NN)
  200                CONTINUE
C            CORRECT FOR L-SHELL DOUBLE COUNTING OF THE SP
C            OFF-DIAGONAL TERMS (FOR NON-L SHELLS CSI*CPJ IS ZERO).
C            NN1 POINTS TO THE APPROPRIATE DENSITY ELEMENT
                     IF(MINJ.LE.1.AND.I.GT.1.AND.DOUBLE)
     *                 DIJ(NN1)=DIJ(NN1)*PT5+SPDIJ
  220             CONTINUE
C
C     ----- NUCLEAR ATTRACTION
C     EL SIGUIENTE DO SOLO EN CASO NO SCREEN.
C
C            --- SKIP CALCULATION OF ELEMENTS
C                WHICH ARE NOT INCLUDED IN DC-FOCK (T AND V)
C
                 IF(.NOT.DCFSKP) THEN
                  IF (.NOT.SCREEN) THEN
                     DUM = PI212*AA1
                     DO 400 I = 1,IJ
                        DIJ(I) = DIJ(I)*DUM
  400                CONTINUE
                  END IF
C
                  AAX = AA*AX
                  AAY = AA*AY
                  AAZ = AA*AZ
C
C     -NCHMAT- IS NONZERO IF THERE ARE EXTERNAL CHARGES WHICH
C     PERTURB THE SYSTEM, SUCH AS IF CHARMM IS IN USE.  NOTE
C     THAT THERE IS ALSO A NUCLEAR REPULSION TERM WHICH IS NOT
C     INCLUDED HERE, IT IS IN THE CHARMM INTERFACE CODE.
C
                  DO 460 ICL = 1,NLATC
                   IC = LOC2TA(ICL)
C
                   ZNUC = -ZAN(IC)
                   CX = C(1,IC)
                   CY = C(2,IC)
                   CZ = C(3,IC)
C
C         CHECKING IF IT IS AN SCREENED CALCULATION, IF SO CALL SCR1,
C         OTHERWISE, FOLLOW THE GAMESS CODE.
C
                  IF (SCREEN) THEN
                      NN=0
                      DO 425 I=MINI,MAXI
                         L1A=JX(I)
                         M1A=JY(I)
                         N1A=JZ(I)
                         MAX=MAXJ
                         IF(IANDJ) MAX=I
                         DO 415 J=MINJ,MAX
                            NN=NN+1
                            L2B=JX(J)
                            M2B=JY(J)
                            N2B=JZ(J)
                            VAL=FDNAI(VLAMB,AI,AJ,
     *                                L1A,M1A,N1A,L2B,M2B,N2B,
     *                                XI,YI,ZI,XJ,YJ,ZJ,CX,CY,CZ)
                            VBLK(NN) = VBLK(NN) + DIJ(NN)*VAL*ZNUC
C
  415                    CONTINUE
  425                 CONTINUE
                  ELSE
                     XX = AA*((AX-CX)**2+(AY-CY)**2+(AZ-CZ)**2)
                     IF (NROOTS.LE.3) CALL RT123
                     IF (NROOTS.EQ.4) CALL ROOT4
                     IF (NROOTS.EQ.5) CALL ROOT5
                     IF (NROOTS.GE.6) CALL ROOT6
                     MM = 0
                     DO 430 K = 1,NROOTS
                        UU = AA*U(K)
                        WW = W(K)*ZNUC
                        TT = ONE/(AA+UU)
                        TAA = SQRT(TT)
                        X0 = (AAX+UU*CX)*TT
                        Y0 = (AAY+UU*CY)*TT
                        Z0 = (AAZ+UU*CZ)*TT
                        IN = -7+MM
                        J0 = 2
C
C                       J0 SKIPS THE TRIVIAL COMBINATION NI=NJ=1
C                       THAT IS DONE EXPLICITLY NOW
C
                        XIN(IN+8) = W1
                        YIN(IN+8) = W1
                        ZIN(IN+8) = W1*WW
                        DO 420 I = 1,LIT
                           IN = IN+7
                           NI = I
                           DO 410 J = J0,LJT
                              JN = IN+J
                              NJ = J
                              CALL STVINT
                              XIN(JN) = XINT
                              YIN(JN) = YINT
                              ZIN(JN) = ZINT*WW
  410                      CONTINUE
                           J0 = 1
  420                   CONTINUE
                        MM = MM+49
  430                CONTINUE
                     DO 450 I = 1,IJ
                        NX = IJX(I)
                        NY = IJY(I)
                        NZ = IJZ(I)
                        DUM = ZERO
                        MM = 0
                        DO 440 K = 1,NROOTS
                           DUM = DUM+XIN(NX+MM)*YIN(NY+MM)*ZIN(NZ+MM)
                           MM = MM+49
  440                   CONTINUE
                        VBLK(I) = VBLK(I) + DUM*DIJ(I)
  450                CONTINUE
                   END IF
C
  460             CONTINUE
C
C     ----- END OF PRIMITIVE LOOPS -----
C
                END IF
  500          CONTINUE
  520       CONTINUE
C
C     ----- COPY BLOCK INTO H-CORE, OVERLAP, AND KINETIC ENERGY MATRICES
C
            MAX = MAXJ
            NN = 0
            DO 620 I = MINI,MAXI
               LI = LOCI+I
               IN = (LI*(LI-1))/2
               IF (IANDJ) MAX = I
               DO 600 J = MINJ,MAX
                  LJ = LOCJ+J
                  JN = LJ+IN
                  NN = NN+1
C
                IF(DCFSKP) THEN
                  V(JN) = ZERO
                ELSE
                  V(JN) = VBLK(NN)
                END IF
  600          CONTINUE
  620       CONTINUE
C
C     ----- END OF SHELL LOOPS -----
C
  700    CONTINUE
  720 CONTINUE
C
C     ----- SUM UP PARTIAL CONTRIBUTIONS IF PARALLEL -----
C
      IF (GOPARR) THEN
         CALL DDI_GSUMF(910,V,L2)
      END IF
C
C     ----- OPTIONAL DEBUG PRINTOUT -----
C
      IF(DBUG) THEN
         WRITE(IW,*) IC,'-TH NUCLEAR ATTRACTION INTEGRAL MATRIX'
         CALL PRTRIL(V,L1)
      END IF
      RETURN
C
      END
C
C*MODULE DCLIB   *DECK SQLC2T
      SUBROUTINE SQLC2T(IDCDM,A,WRK,LA1,STRNG,PARTMX)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      CHARACTER*8 STRNG
      DIMENSION A(LA1,LA1), WRK(*)
C
      LOGICAL DBUG,GOPARR,DSKWRK,MASWRK,PARTMX
C
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
      LOGICAL DCFLG
      COMMON /DCOPT / SUBTYP,BUFTYP,SUBLNG,BUFRAD,NDCPRT,NSUBS,DCFLG
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
C
      DATA DEBUG/8HDEBUG   /
C
C     *** MATRIX TRANSFORMATION FROM LOCAL ORDER TO GLOBAL ORDER ***
C        (IN THE LOCALIZATION OR LSO REGION)
C
C     INPUT
C       IDCDM : FILE NO. CONTAINING SUBSYSTEM MATRIX IN SQUARE ORDER
C         RAD : BUFRAD (-> LOCALIZATION REGION) OR
C               RADLSO (-> LSO REGION)
C      PARTMX : MULTIPLY PARTITION MATRIX OR NOT
C     OUTPUT
C           A : LA1*LA1 SQUARE MATRIX ORDERED BY TOTAL SYSTEM INDICES
C
      DBUG = MASWRK .AND. EXETYP.EQ.DEBUG
C
      CALL VCLR(A,1,LA1*LA1)
C
      IF(DBUG) WRITE(IW,9010) STRNG
      CALL SEQREW(IDCDM)
      DO ISUB=1,NSUBS
C
         IF(DBUG) WRITE(IW,9140) ISUB
         CALL LOCREG(ISUB)
C
         LENG=LNUM*LNUM
         CALL SQREAD(IDCDM,WRK,LENG)
C
         IF(DBUG) CALL PRSQLDC(ISUB,WRK,LNUM,LNUM,LNUM)
C
         CALL SSLC2T(A,LA1,WRK,LNUM,PARTMX)
      END DO
      CALL SEQREW(IDCDM)
C
      IF(DBUG) THEN
         IF(MASWRK) WRITE(IW,9000) STRNG
         CALL PRSQL(A,LA1,LA1,LA1)
      END IF
C
      RETURN
C
 9000 FORMAT (/1X,A8,' MATRIX IN TOTAL REGION')
 9010 FORMAT (/1X,A8,' MATRIX IN THE LOCALIZATION REGION')
 9140 FORMAT (/1X,I5,' TH LOCALIZATION REGION')
      END
C
C*MODULE DCLIB   *DECK SQT2LC
      SUBROUTINE SQT2LC(A,B,LA1,LB1,STRNG)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      CHARACTER*8 STRNG
      DIMENSION A(LA1,LA1),B(LB1,LB1)
C
      LOGICAL DBUG,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXSH=5000, MXGTOT=20000)
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
C
      DATA DEBUG/8HDEBUG   /
C
C     *** MATRIX TRANSFORMATION FROM GLOBAL ORDER TO LOCAL ORDER ***
C        (IN THE LOCALIZATION REGION)
C
C      INPUT
C        A : LA1*LA1 SQUARE MATRIX ORDERED BY TOTAL SYSTEM INDICES
C      OUTPUT
C        B : LB1*LB1 SQUARE MATRIX ORDERED BY LOCAL SYSTEM INDICES
C
      DBUG = MASWRK .AND. EXETYP.EQ.DEBUG
C
      IF(DBUG) THEN
         IF(MASWRK) WRITE(IW,9000) STRNG
         CALL PRSQL(A,LA1,LA1,LA1)
      END IF
C
      IBLOC=0
      DO IBSHL=1,NLSH
         IASHL=LOC2TS(IBSHL)
         IALOCT=KLOC(IASHL)
         DO IBBSFN=1,KMAX(IASHL)-KMIN(IASHL)+1
            IALOC=IALOCT+IBBSFN-1
            IBLOC=IBLOC+1
            JBLOC=0
            DO JBSHL=1,NLSH
               JASHL=LOC2TS(JBSHL)
               JALOCT=KLOC(JASHL)
               DO JBBSFN=1,KMAX(JASHL)-KMIN(JASHL)+1
                  JALOC=JALOCT+JBBSFN-1
                  JBLOC=JBLOC+1
                  B(JBLOC,IBLOC)=A(JALOC,IALOC)
               END DO
            END DO
         END DO
      END DO
C
      IF(DBUG) THEN
         IF(MASWRK) WRITE(IW,9010) STRNG
         CALL PRSQLDC(0,B,LB1,LB1,LB1)
      END IF
C
      RETURN
C
 9000 FORMAT (/1X,A8,' MATRIX IN TOTAL REGION')
 9010 FORMAT (/1X,A8,' MATRIX IN THE LOCALIZATION REGION')
      END
C
C*MODULE DCLIB   *DECK SSLC2T
      SUBROUTINE SSLC2T(A,LA1,SUB,LSUB1,PARTMX)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION A(LA1,LA1), SUB(LSUB1,LSUB1)
C
      LOGICAL PARTMX
C
      PARAMETER (MXSH=5000, MXGTOT=20000)
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
C
      COMMON /DCEGG / NLATE,NLSHE,LNUME
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
C
      PARAMETER (HALF=0.5D+00, ZERO=0.0D+00)
C
C     *** MATRIX TRANSFORMATION FROM LOCAL ORDER TO GLOBAL ORDER ***
C        (ONLY 1 LOCALIZATION)
C
C     ### THIS SUBROUTINE SHOULD BE CALLED AFTER CALLING LOCREG ###
C
C     INPUT
C         SUB : LSUB1*LSUB1 SQUARE MATRIX ORDERED BY SUBSYSTEM INDICES
C     OUTPUT
C           A : LA1*LA1 SQUARE MATRIX ORDERED BY TOTAL SYSTEM INDICES
C
      IBLOC=0
      IF(PARTMX) THEN
        DO IBSHL=1,NLSH-NLSHE
          IASHL=LOC2TS(IBSHL)
          IALOCT=KLOC(IASHL)
          FISHL=ZERO
          IF(IBSHL.LE.NLSHC) FISHL=HALF
          DO IBBSFN=1,KMAX(IASHL)-KMIN(IASHL)+1
             IALOC=IALOCT+IBBSFN-1
             IBLOC=IBLOC+1
             JBLOC=0
             DO JBSHL=1,NLSH-NLSHE
                JASHL=LOC2TS(JBSHL)
                JALOCT=KLOC(JASHL)
                FJSHL=ZERO
                IF(JBSHL.LE.NLSHC) FJSHL=HALF
                FIJSHL=FISHL+FJSHL
                DO JBBSFN=1,KMAX(JASHL)-KMIN(JASHL)+1
                   JALOC=JALOCT+JBBSFN-1
                   JBLOC=JBLOC+1
                   A(JALOC,IALOC)=A(JALOC,IALOC)+SUB(JBLOC,IBLOC)*FIJSHL
                END DO
             END DO
          END DO
        END DO
      ELSE
        DO IBSHL=1,NLSH
          IASHL=LOC2TS(IBSHL)
          IALOCT=KLOC(IASHL)
          DO IBBSFN=1,KMAX(IASHL)-KMIN(IASHL)+1
             IALOC=IALOCT+IBBSFN-1
             IBLOC=IBLOC+1
             JBLOC=0
             DO JBSHL=1,NLSH
                JASHL=LOC2TS(JBSHL)
                JALOCT=KLOC(JASHL)
                DO JBBSFN=1,KMAX(JASHL)-KMIN(JASHL)+1
                   JALOC=JALOCT+JBBSFN-1
                   JBLOC=JBLOC+1
                   A(JALOC,IALOC)=A(JALOC,IALOC)+SUB(JBLOC,IBLOC)
                END DO
             END DO
          END DO
        END DO
      END IF
C
      RETURN
C
      END
C
C*MODULE DCLIB   *DECK LCMAT
      SUBROUTINE LCMAT(A,B,L1,L2,LNUMC)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C     MAKE (LOCALIZATION REGION)*(CENTRAL REGION) MATRIX FROM
C     SYMMETRIC MATRIX
C
      DIMENSION A(L2), B(L1,LNUMC)
C
      DO I=1, LNUMC
        IA=I*(I-1)/2
        DO J=1, I
          B(I,J)=A(IA+J)
          B(J,I)=A(IA+J)
        END DO
      END DO
      DO I=LNUMC+1, L1
        IA=I*(I-1)/2
        DO J=1, LNUMC
          B(I,J)=A(IA+J)
        END DO
      END DO
C
      RETURN
      END
C
C*MODULE DCLIB   *DECK PREVDC
C        MODIFIED FROM PREV
      SUBROUTINE PREVDC(ISUB,V,E,M,N,LDV)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXATM=2000, MXAO=8192, MXSH=5000, MXGTOT=20000)
      PARAMETER (MXLATM=200, MXLSHL=700)
C
      DIMENSION V(LDV,M),E(M)
C
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
C
C     ----- PRINT OUT EIGENDATA (VECTORS AND VALUES) -----
C     THE ROWS WILL BE LABELED WITH THE BASIS FUNCTION TAGS.
C     -V- IS N X M, WITH TRUE LEADING DIMENSION -LDV-
C
      IF (MASWRK) THEN
      IF(ISUB.NE.0) WRITE (IW,9000) ISUB
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      IMAX = 0
C
  100 IMIN = IMAX+1
      IMAX = IMAX+MAX
      IF (IMAX .GT. M) IMAX = M
      WRITE (IW,9008)
      WRITE (IW,9028) (I,I = IMIN,IMAX)
      WRITE (IW,9008)
      WRITE (IW,9068) (E(I),I = IMIN,IMAX)
      WRITE (IW,9008)
      JSH=1
      JSHT=LOC2TS(JSH)
      JNMX=KMAX(JSHT)-KMIN(JSHT)
      JNUM=-1
      DO 120 J = 1,N
         JNUM=JNUM+1
         JT=KLOC(JSHT)+JNUM
         WRITE (IW,9048) JT,BFLAB(JT),(V(J,I),I = IMIN,IMAX)
         IF(JNUM.GE.JNMX) THEN
            JNUM=-1
            JSH=JSH+1
            JSHT=LOC2TS(JSH)
            JNMX=KMAX(JSHT)-KMIN(JSHT)
         END IF
  120 CONTINUE
      IF (IMAX .LT. M) GO TO 100
      END IF
      RETURN
C
 9000 FORMAT(/10X,'SUBSYSTEM ',I5/10X,15(1H=))
 9008 FORMAT(1X)
 9028 FORMAT(15X,10(4X,I4,3X))
 9048 FORMAT(I5,2X,A8,10F11.6)
 9068 FORMAT(15X,10F11.4)
      END
C
C*MODULE DCLIB   *DECK DFTNLC
      SUBROUTINE DFTNLC(NLCT,NELM,L1)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION NLCT(*),NELM(2,L1)
C
      IF(L1.LE.3) THEN
        NLCT(1)=-1000
        RETURN
      END IF
C
      L3=L1*L1
      IPT=L3
      IJ=(L1+L3)/2
      DO I=L1,1,-1
        IPT=IPT-L1
        JPT=L3
        DO J=L1,I+1,-1
          JPT=JPT-L1
          NLCT(IPT+J)=NLCT(JPT+I)
        END DO
        DO J=I,1,-1
          JPT=(J-1)*L1
          NLCT(IPT+J)=NLCT(IJ)
          IJ=IJ-1
        END DO
      END DO
C
      IPT=0
      DO I=1,L1
        JPT=1
        DO J=1,I
          IF(NLCT(IPT+J).EQ.-1) THEN
            NLCT(IPT+JPT)=J
            JPT=JPT+1
          END IF
        END DO
        NELM(1,I)=JPT-1
        DO J=I+1,L1
          IF(NLCT(IPT+J).EQ.-1) THEN
            NLCT(IPT+JPT)=J
            JPT=JPT+1
          END IF
        END DO
        NELM(2,I)=JPT-1
        IPT=IPT+L1
      END DO
      RETURN
C
      END
C
