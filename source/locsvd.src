C
C*MODULE LOCAL   *DECK LOCAL_LMOSVD
c> @brief      Local_lmosvd calls local_ppasvd routines.
c>
c> @author     Aaron West and Klaus Ruedenberg
c>             -November 4, 2012
c> @details    Local_lmosvd grabs memory and calls svd routines.
c>             For VVOS, IORBF1 can only be DAF file 15 right now.
c>             Otherwise, we need to re-visit some file definitions.
c>
c> @date December 13, 2012-Aaron West
c> -Added ORMAS svd localization.
c>
c> @date December 20, 2012-Aaron West
c> -Stripped out the use of LVNACT.   We do not need to do all
c>  confusing sorting in LOCAL_PPASVDCORE and LOCAL_PPASVD.
c>  We can just grab out the orbital transformation and use its
c>  block-diagonal form to get the LMOs at the end in one matvec.
c>  We still keep core and valence manipulations separate.
C>
C> @date January 16, 2013-Aaron West
C> -Added VVOS option.
C>
C> @date January 30, 2013-Aaron West
C> -Added ISVDOP to ORNTMO common block.
C> This run gives special option for SVD runs.
C>
C> @date February 23, 2013-Aaron West
C> -Enable MO overlaps with MOs from VVOS i.e. ISVDOP=10
C> This run gives special option for SVD runs.
C>
C> @date March 13, 2013-Aaron West
C> -Allowed for RHF wave functions.
C>
C> @date April 01, 2013-Aaron West
C> -Adapt for extloc runs.
C>
C> @date April 01, 2013-Aaron West
C> -Adapt for spherical harmonics.
C>
C> @date May 17, 2013-Aaron West
C> -For extloc=atmnos, force out the valence density matrix.
C>  Some new dimensioning is required.
C>  I forced the extloc option through the routine.
C>  Results were re-checked for this difficult option.
C>
C> @date May 18, 2013-Aaron West
C> -For MCSCF-type runs and externalizing runs,
C>  the MCSCF SVD orbitals are now requested.
C>  Right now, MCSCF+extloc=atmnos result in
C>  ER localized orbitals and ext. nos.
C>  that preserve the waveFxN invariance.
C>  However, MCSCF+extloc=atmnos runs mix
C>  all orbitals in the MBS valence for the SVD orbitals.
C>
C> @param IORBF1 indicates daf dict file with starting orbitals
C>               from which the localized orbitals are formed.
      SUBROUTINE LOCAL_LMOSVD(IORBF1)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C
C     VARS
C     MASWRK LINE PLACED BELOW TO MATCH...
      LOGICAL KEEPER,KEEPER_ISVMOR,COMBO
      LOGICAL SVDEXTORBSNUM,SVDAOS,SVDPRJ,SVDMBSNUM,
     *        SVD_INVAR,SVD_INVAR2,SVD_INVAR3,SVD_AOSCF
      DOUBLE PRECISION :: X
      DOUBLE PRECISION :: RMC,RHF,SVD,RNONE
      INTEGER NGOTMX,LAST,LOADFM,NDAWN1,
     *        LEIG1,LIWRK,LS,LS2,LSAOMO,LSV,LSVMBS,LUVEC,LVOLD,LVSAV,
     *        LEIG1SAV,LVTVECSAV,LIPOSMBS,LILENMBS,LVTMP,LVTVEC,LWRKSVD,
     *        LWSPHER
      INTEGER ISIZE_FCCWFN
      INTEGER NERR,I,ITMP,IORBF1,ISIZSVD,ISIZSVD2,
     *        L0,L0MBS,L1,L2,L3,NCORTOT,NACT
      INTEGER NSKIP,NSKIP2,NVIR2,NCOR_GET,NACT_GET,NACTSV,NCORSV,
     *        NACT_EXTLOC_SAV
      INTEGER ISWMBS
      INTEGER LOCAL_NUMVAL
      INTEGER NVVOS_NUMCOR
C
C     NEW CODING STANDARDS VARS
C
      DOUBLE PRECISION :: C
      DOUBLE PRECISION :: ZAN
      INTEGER ICH,NQMT,NUM,MUL,NA,NAT,NB,NE,IAN
C
      INTEGER LIMLOW,LIMSUP,LIATMSTA,LIATMSTA2
C
      DOUBLE PRECISION :: QMTTOL
      INTEGER ISPHER
C
      INTEGER IW,IDAF,IODA,IP,IPK,IR,IS,NAV
C
      LOGICAL FDIRCT,QCORR
      DOUBLE PRECISION ::
     *       C0SQ
      INTEGER LMSTA_SAV,NSPACE_SAV,NSPACE,NSPACE2,
     *        MSTA,MNUM,MINI,MAXI,IAMI,IAMA,IBMI,IBMA,
     *        IDIMFCC,LBST,NREF0
C
      LOGICAL CANONC,FCORE,FORS,EKT,LINSER
      DOUBLE PRECISION ::
     *       FINALCI,METHOD,CISTEP,ORMAS,ACURCY,ENGTOL,DAMP
      INTEGER MICIT,NWRDMC,NORBMC,NOROT,MOFRZ,
     *        NPFLG,NOFO,MCFMO,IDIABAT
C
      DOUBLE PRECISION ::
     *       EX,CS,CP,CD,CF,CG,CH,CI
      INTEGER KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL
C
      LOGICAL ORIENT,ORIKIN,ORMFUL
      INTEGER NATMOR,ISVMOR,ISVDOP
      DOUBLE PRECISION :: EXTLOC,EREFATM
C
      DOUBLE PRECISION ::
     *       RUNTYP,EXETYP,CHECK
      INTEGER NEVALS,NGLEVL,NHLEVL
C
      LOGICAL SOME
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION :: ETOLLZ
      INTEGER ILOCAL,IAHARD
C
      INTEGER IVVOS,NVVOS
      DOUBLE PRECISION ::
     *       BNDDEN
C
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C-----------------------------------------------------------------------
      INTEGER MXAO,MXATM,MXNORO,MXSH,MXGTOT
      PARAMETER (MXAO=8192, MXATM=2000, MXNORO=250,
     *           MXSH=5000, MXGTOT=20000)
C-----------------------------------------------------------------------
      COMMON /ATLIM / LIMLOW(MXATM),LIMSUP(MXATM)
      COMMON /BASSPH/ QMTTOL,ISPHER
C                            SPECIAL NOTE:
C                            IF CHANGE SIZE OF MSTA ARRAY HERE,
C                            ALSO CHANGE ISIZE_FCCWFN VARIABLE BELOW
C                            IN A SINGLE PLACE.
C
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIMFCC(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWRDMC,NORBMC,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /ORNTMO/ EXTLOC,EREFATM,
     *                NATMOR(MXAO),ISVMOR(MXATM),ISVDOP,
     *                ORIENT,ORIKIN,ORMFUL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /VVOPAR/ IVVOS,NVVOS,BNDDEN
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C-----------------------------------------------------------------------
C
C     DATA STUFF
      DATA CHECK/8HCHECK   /
      DATA ORMAS/8HORMAS   /
      DATA RMC/8HMCSCF   /
      DATA RHF/8HRHF     /
      DATA RNONE/8HNONE    /
      DATA SVD/8HSVD     /
C
C     DEFINE PRINT STUFF
      SOME = NPRINT.NE.-5 .AND. MASWRK
C
C     PRINT STUFF
      IF(SOME) WRITE(IW,9000)
C
C
C     MEMORY FOR ATOMIC-LIKE ORBITALS.
C
C     SET UP SOME DIMENSIONS
      L0 = NQMT
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
      ISIZE_FCCWFN=51
C
      IF(SCFTYP.EQ.RMC) THEN
        CALL LOCAL_SVDVVOS_RMC_SETUP1(NCOR_GET,NACT_GET)
        NSPACE2=1
        IF(CISTEP.EQ.ORMAS) NSPACE2=NSPACE
      ELSEIF(SCFTYP.EQ.RHF) THEN
        IF(EXTLOC.NE.RNONE) THEN
          NSPACE=1
          NSPACE2=1
        ENDIF
        NCOR_GET=NVVOS_NUMCOR(0,0)
        NACT_GET=L0-NCOR_GET
      ELSE
        IF(MASWRK) WRITE(IW,9049)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      NCORSV=NCOR_GET
      NCORTOT=NCOR_GET
      NACT=NACT_GET
      NACTSV=NACT_GET
C
C
C----------------------------------------------------
C----------------------------------------------------
C     MAKE SOME ERROR OUTS
      NERR=0
      COMBO=CISTEP.EQ.ORMAS.OR.SCFTYP.EQ.RHF
      IF(.NOT.COMBO.AND.IVVOS.NE.0) THEN
        IF(MASWRK) WRITE(IW,9050)
        NERR=NERR+1
      ENDIF
C     NOTE:  THIS ERROR IS AN 'ABSOLUTIST'S' ERROR.
      ITMP=ISIZE_FCCWFN
      IF(IVVOS.NE.0) ITMP=ISIZE_FCCWFN-2
      IF(NSPACE.GT.ITMP) THEN
        IF(MASWRK) WRITE(IW,9051)
        NERR=NERR+1
      ENDIF
      IF(IVVOS.NE.0.AND.IORBF1.NE.15) THEN
        IF(MASWRK) WRITE(IW,9052)
        NERR=NERR+1
      ENDIF
      IF(EXTLOC.EQ.SVD.AND.IVVOS.EQ.0) THEN
        IF(MASWRK) WRITE(IW,9053)
        NERR=NERR+1
      ENDIF
      IF(EXTLOC.NE.RNONE.AND.ILOCAL.EQ.4) THEN
        IF(MASWRK) WRITE(IW,9054)
        NERR=NERR+1
      ENDIF
      IF(NERR.GT.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C----------------------------------------------------
C----------------------------------------------------
C
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C     SETUP ANY VARIABLES THAT USE ISDVOP.
C     NOTE: THE DEFAULT COMES FROM LMOINP ROUTINE.
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C----------------------------------------------------------------------
      SVDEXTORBSNUM=.FALSE.
      SVDAOS=.FALSE.
      SVDPRJ=.FALSE.
      SVDMBSNUM=.FALSE.
      SVD_INVAR=.FALSE.
      SVD_INVAR2=.FALSE.
      SVD_INVAR3=.FALSE.
      SVD_AOSCF=.FALSE.
      IF(SOME) WRITE(IW,9070)
C
      IF(SCFTYP.EQ.RMC) THEN
        IF(ISVDOP.EQ.0) THEN
C         RUN A 'REGULAR' SVD.
          IF(SOME) WRITE(IW,9071)
        ELSEIF(ISVDOP.EQ.1) THEN
C         USE THE SPECIAL SVDEXTORBSNUM OPTION.
C         YES, THIS NOTE IS VAGUE ON PURPOSE.
          SVDEXTORBSNUM=.TRUE.
          IF(SOME) WRITE(IW,9072)
        ELSEIF(ISVDOP.EQ.2) THEN
C         USE NONORTHOGONAL AOS IN THE SVD.
          SVDAOS=.TRUE.
          IF(SOME) WRITE(IW,9073)
        ELSEIF(ISVDOP.EQ.3) THEN
C         USE THE NON-SVD PROJECTION FORMULA FROM KR.
C         IT IS ACTUALLY EQUIVALENT TO USING ORTHOGONAL AOS IN SVD.
          SVDPRJ=.TRUE.
          IF(SOME) WRITE(IW,9074)
        ELSEIF(ISVDOP.EQ.4) THEN
          SVD_INVAR=.TRUE.
          IF(SOME) WRITE(IW,9077)
CKEEP          SVDMBSNUM=.TRUE.
CKEEP          IF(SOME) WRITE(IW,9076)
        ELSEIF(ISVDOP.EQ.5) THEN
          SVD_INVAR2=.TRUE.
          IF(SOME) WRITE(IW,9078)
        ELSEIF(ISVDOP.EQ.6) THEN
C         IF POSSIBLE, AUTOMATICALLY FORCE MBS NUMBER OF ORBITALS.
C         NOTES:
C         -----CANNOT USE THIS OPTION FOR MORE THAN MBS ORBITAL NUMBERS.
C         -----MUST ENTER NATMOR WITH THIS OPTION.
C         -----ELEMENTS IN NATMOR GET COUNTED UP TO LIMIT ORBITAL CHOICES.
          SVDMBSNUM=.TRUE.
C         ---IF DELETE SVDMBSNUM, PLEASE CHANGE LOCAL_PPAERR STUFF.
          IF(SOME) WRITE(IW,9076)
        ELSEIF(ISVDOP.EQ.8) THEN
C         OPTIONS 2 AND 6.
          SVDAOS=.TRUE.
          SVDMBSNUM=.TRUE.
C         ---IF DELETE SVDMBSNUM, PLEASE CHANGE LOCAL_PPAERR STUFF.
          IF(SOME) WRITE(IW,9073)
          IF(SOME) WRITE(IW,9076)
        ELSEIF(ISVDOP.EQ.10) THEN
C         USE THE TRUE AOS THAT MIKE HAS STORED UP FOR VVOS.
          SVD_AOSCF=.TRUE.
          IF(SOME) WRITE(IW,9080)
CNOTE-----
          IF(NSPACE.EQ.2.AND.IVVOS.EQ.0) THEN
            SVDEXTORBSNUM=.TRUE.
            IF(SOME) WRITE(IW,9072)
          ENDIF
CNOTE-----
        ELSEIF(ISVDOP.EQ.15) THEN
          SVD_INVAR3=.TRUE.
          IF(SOME) WRITE(IW,9085)
        ELSE
          IF(MASWRK) WRITE(IW,9090)
          CALL FLSHBF(IW)
          CALL ABRT
        ENDIF
      ELSEIF(SCFTYP.EQ.RHF.AND.ISVDOP.EQ.0) THEN
        SVD_AOSCF=.TRUE.
        IF(SOME) WRITE(IW,9081)
        SVDEXTORBSNUM=.TRUE.
        IF(SOME) WRITE(IW,9072)
CGARBRHF      ELSEIF(SCFTYP.EQ.RHF.AND.ISVDOP.EQ.1) THEN
CGARBRHFC       KEEP THE ORIGINAL CLOSED-SHELL AND VIRTUALS.
CGARBRHF        SVD_AOSCF=.TRUE.
CGARBRHF        IF(SOME) WRITE(IW,9081)
      ELSE
        IF(MASWRK) WRITE(IW,9090)
        CALL FLSHBF(IW)
        CALL ABRT
      ENDIF
      CALL FLSHBF(IW)
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C     SVD-VVOS OVERHAUL:  STEP 1
C     RESET DIMENSIONS
C     NOTE:  THIS IS NOT A TRUE RE-DIMENSIONING.
C            IT IS JUST MORE USE OF A COMMON BLOCK, WHICH MUST BE DONE.
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C
C     SVD-VVOS LENGTHS OF BLOCKS
C     ACTUAL CORE BLOCK:  NCORTOT
C     FILLED CORE BLOCK:  NSKIP
C       NEW EMPTY BLOCK:  NSKIP2
C     OLD ACTIVE BLOCK:   NACTSV
C     NEW ACTIVE BLOCK:   NACT-NACTSV
C     NEW ACTIVE TOTAL:   NACTSV+NSKIP+NSKIP2
C
      IF(IVVOS.NE.0) THEN
        CALL LOCAL_SVDVVOS_REDIM_STEP1(
     *       SCFTYP,ISVDOP,
     *       NAT,NCORSV,NACTSV,L0,
     *       NSPACE,NSPACE_SAV,
     *       NCORTOT,NSKIP,NACT,NSKIP2,NVIR2,
     *       MASWRK,IW)
        NSPACE2=NSPACE
        IF(SOME) WRITE(IW,9100) NCORTOT,NSKIP,NACTSV,NSKIP2,NVIR2
      ENDIF
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C     END OF SVD-VVOS OVERHAUL:  STEP 1
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C
C----------------------------------------------------
C----------------------------------------------------
C     SETUP ISVDOP=10 DIMENSION AFTER VVOS INFO.
C     NOTE:  GO BACK TO THE BASIC NVVOS_NUMCOR INFO HERE
C            SINCE VVOS IS IN MBS NUMBERS.
      L0MBS=NVVOS_NUMCOR(0,0)
      ISWMBS=1
      DO I=1,NAT
        L0MBS=L0MBS+LOCAL_NUMVAL(I,ISWMBS)
      ENDDO
C----------------------------------------------------
C----------------------------------------------------
C
C     BEFOREHAND, DETERMINE SIZES OF ANY EXTRA WORK ARRAYS
C     NOTE:  EXPLICITLY DETERMINE LARGEST WORKSPACE
C            AND
C            FORCE INTO 1 VARIABLE.
      ISIZSVD  = MAX(3*MIN(L1,L0)+MAX(L1,L0),5*MIN(L1,L0))
      ISIZSVD2 = 5*L0
C     NEXT LINE GIVES SVD
      ISIZSVD  = MAX(ISIZSVD,ISIZSVD2)
      ISIZSVD2 = 8*L1
C     NEXT LINE GIVES GLDIAG
      ISIZSVD  = MAX(ISIZSVD,ISIZSVD2)
C     NEXT LINE GIVES A BIT MORE WORKSPACE
      ISIZSVD  = 40*ISIZSVD
C
C
C     GET ALL MEMORY FOR LOCAL_PPASVD.
      CALL GOTFM(NGOTMX)
      CALL VALFM(LOADFM)
      LS = LOADFM + 1
C     A BUNCH OF ORBITAL MEMORY.
      LUVEC = LS + L2
      LEIG1 = LUVEC + L3
      LVTVEC = LEIG1 + L1
      LWRKSVD = LVTVEC + L0*L0
      LSV = LWRKSVD + ISIZSVD
      LVOLD = LSV + L3
      LVTMP = LVOLD + L3
      LVSAV = LVTMP + L3
      LSAOMO = LVSAV + L3
      LS2 = LSAOMO + L3
      LIWRK = LS2 + L2
      LSVMBS = LIWRK + L2
      LIPOSMBS = LSVMBS + L1*L0MBS
C     MORE MEMORY FOR INDEXING.
      LILENMBS = LIPOSMBS + (NAT+1)
      LIATMSTA2 = LILENMBS + NAT
C     MORE MEMORY FOR ATOM ASSIGNMENTS.
      LIATMSTA = LIATMSTA2  + NSPACE2*NAT
      LEIG1SAV = LIATMSTA + NSPACE2*NAT
C     MORE ORBITAL MEMORY FOR CHANGE IN SVD EVALUE SELECTION.
      LVTVECSAV = LEIG1SAV  + NACT*NAT*NSPACE2
      LMSTA_SAV = LVTVECSAV + NACT*NACT*NAT*NSPACE2
C     COPY THE MSTA ARRAY FOR VVOS STUFF
      LWSPHER   = LMSTA_SAV + ISIZE_FCCWFN
C     ORBITAL MEMORY FOR SPHERICAL TRANSFORM
      LAST      = LWSPHER   + L3
      NDAWN1 = LAST - LOADFM - 1
      CALL GETFM(NDAWN1)
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C     SVD-VVOS OVERHAUL:  STEP 2
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C     MAKE A COPY OF THE ORIGINAL MSTA ARRAY.
C     TEMPORARILY RESET THE MSTA ARRAY.
C     FOREVER RESET IORBF1 ORDERINGS.
C
      IF(IVVOS.NE.0) THEN
        CALL LOCAL_SVDVVOS_REDIM_STEP2(
     *       SCFTYP,ISVDOP,NAT,L0,
     *       ISIZE_FCCWFN,NSPACE,MSTA,X(LMSTA_SAV),
     *       NCORTOT,NSKIP2,MASWRK,IW)
C       NOTE:  SEE NOTES IN LOCAL_SVDVVOS_MOS
C              ON POSSIBLE IORBF1 OVER-WRITES.
        IF(SCFTYP.EQ.RMC.AND.CISTEP.EQ.ORMAS) THEN
          CALL LOCAL_SVDVVOS_MOS(X(LVOLD),X(LVTMP),IORBF1,
     *         L0,L1,L3,NCORSV,NCORTOT,NACTSV,NSKIP,NSKIP2,MASWRK)
        ENDIF
      ENDIF
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C     END OF SVD-VVOS OVERHAUL:  STEP 2
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C
CKEEPIVVOSC
CKEEPIVVOSC     IF NEEDED, PRINT OUT CANONICAL MCSCF OCCUPIEDS + VVOS
CKEEPIVVOS      IF(IVVOS.NE.0) THEN
CKEEPIVVOS        CALL DAREAD(IDAF,IODA,X(LVTMP),L3,15,0)
CKEEPIVVOS        WRITE(IW,9060)
CKEEPIVVOS        CALL PRSQL(X(LVTMP),L0,L1,L1)
CKEEPIVVOS        GO TO 8999
CKEEPIVVOS      ENDIF
C
C     SETUP THE 'KEEPER' VAR
      CALL LOCAL_KEEPER_SETUP(KEEPER)
C
C     SETUP LIMLOW AND LIMSUP ARRAYS BY CALLING AOLIM.
C     LIMLOW CONTAINS INITIAL BASIS FXN INDEX FOR EACH ATOM.
C     LIMSUP CONTAINS FINAL BASIS FXN INDEX FOR EACH ATOM.
C     E.G. TRIATOMIC
C     LIMLOW LIMSUP
C     1      33
C     34     57
C     58     93 = NUM IN INFOA BLOCK
      CALL AOLIM
C
C     SETUP KEEPER_ISVMOR.
      KEEPER_ISVMOR=.FALSE.
      DO I=NCORTOT+1,NCORTOT+NACT
        IF(NATMOR(I).NE.0) KEEPER_ISVMOR=.TRUE.
      ENDDO
      IF(.NOT.KEEPER) THEN
        DO I=1,NAT
          IF(ISVMOR(I).NE.0) KEEPER_ISVMOR=.TRUE.
        ENDDO
      ENDIF
C
C     SETUP VVOS AOS IF NEEDED.
C     NOTE:  IF DIMENSION ISSUE, THEN THE WRITE STATEMENT MIGHT HELP.
      IF(SVD_AOSCF) THEN
C       READ IN THE REDUCED SV OVERLAP MATRIX FROM VVOS RUN.
        IF(SOME) WRITE(IW,9200)
        CALL FLSHBF(IW)
        IF(EXETYP.NE.CHECK)
     *  CALL DAREAD(IDAF,IODA,X(LSVMBS),L1*L0MBS,533,0)
      ENDIF
C
C     MAKE THE CALLS FOR SVD-BASED ORBITALS.
      CALL LOCAL_PPAERR(
     *     ZAN,IAN,NAT,NCORTOT,NACT,NATMOR,L0,L0MBS,
     *     MSTA,ISIZE_FCCWFN,NSPACE2,CISTEP,
     *     X(LIATMSTA),X(LIATMSTA2),KEEPER,ORMFUL,
     *     KEEPER_ISVMOR,ISVMOR,IVVOS,SVDEXTORBSNUM,ISVDOP,
     *     SCFTYP,
     *     MASWRK,IW)
      IF(EXETYP.EQ.CHECK) GO TO 8999
      CALL LOCAL_PPASVDCORE(
     *     NCORTOT,IORBF1,X(LS2),
     *     X(LS),X(LUVEC),X(LEIG1),X(LVTVEC),
     *     X(LWRKSVD),X(LIWRK),
     *     X(LVOLD),X(LVTMP),X(LVSAV),
     *     X(LSV),X(LSAOMO),
     *     ISIZSVD,L0,L1,L2,L3,
     *     LIMLOW,LIMSUP,NAT,SVDAOS,
     *     ISPHER,KTYPE,KATOM,KMIN,KMAX,NSHELL,X(LWSPHER),
     *     SOME,MASWRK)
      CALL LOCAL_PPASVD(
     *     NCORTOT,IORBF1,X(LS2),
     *     X(LS),X(LUVEC),X(LEIG1),X(LVTVEC),
     *     X(LWRKSVD),X(LIWRK),
     *     X(LVOLD),X(LVTMP),X(LVSAV),
     *     X(LSV),X(LSAOMO),
     *     ISIZSVD,NACT,L0,L1,L2,L3,
     *     MSTA,ISIZE_FCCWFN,NSPACE2,
     *     LIMLOW,LIMSUP,NAT,X(LIATMSTA),X(LIATMSTA2),KEEPER,
     *     X(LEIG1SAV),X(LVTVECSAV),ISVMOR,
     *     X(LIPOSMBS),X(LILENMBS),X(LSVMBS),L0MBS,
     *     KEEPER_ISVMOR,SVDEXTORBSNUM,SVDAOS,
     *     SVDPRJ,SVDMBSNUM,SVD_INVAR,SVD_INVAR2,SVD_INVAR3,
     *     SVD_AOSCF,SCFTYP,
     *     ISPHER,KTYPE,KATOM,KMIN,KMAX,NSHELL,X(LWSPHER),
     *     NATMOR,MASWRK,SOME)
C
C     STASH A COPY OF THE 'TRUE' NACT.
      NACT_EXTLOC_SAV=NACT
C
C     USE SCFTYP AND SETUP FOR LOCAL_PPADEN
      IF(SCFTYP.EQ.RMC) THEN
C       DO NOTHING.  KEEP IN THE LIST THOUGH.
      ELSEIF(SCFTYP.EQ.RHF.AND.EXTLOC.EQ.RNONE) THEN
C       WORKS FOR RHF AND ISVDOP=0.
        NSKIP =NA-NCORTOT
        NSKIP2=0
      ELSEIF(SCFTYP.EQ.RHF.AND.EXTLOC.NE.RNONE) THEN
        NSKIP=NA-NCORTOT
        NSKIP2=0
        NACT=0
        ISWMBS=1
        DO I=1,NAT
          NACT=NACT+LOCAL_NUMVAL(I,ISWMBS)
        ENDDO
      ELSE
        IF(MASWRK) WRITE(IW,9090)
        CALL FLSHBF(IW)
        CALL ABRT
      ENDIF
C
C     FORM THE SVD DENSITY MATRIX.
C     ----LATER, MIGHT PROVIDE CHOICES IF DOING NONORTHOGONAL ORBITALS.
C     ----THE EXTLOC STATEMENTS ARE IMPORTANT
C         AND ELIMINATE FILE CONFLICTS EVERYWHERE...
      CALL LOCAL_PPADEN(
     *     X(LVTMP),X(LVSAV),X(LVOLD),X(LSV),
     *     NSKIP,NSKIP2,NCORTOT,NCORSV,NACT,NACTSV,L1,L3,
     *     NATMOR,NAT,KEEPER,SCFTYP,EXTLOC,
     *     IVVOS,IORBF1,MASWRK)
      NACT=NACT_EXTLOC_SAV
C
C     FOR ORIENTATION DILRMO ROUTINE:
C     LOCAL_PPADEN PUTS DENSITY ON DAF FILE 285.
C     PUT ORTHOGONAL SVD-ORBITALS INTO FILE 71.
C     ----THE EXTLOC STATEMENTS ARE IMPORTANT
C         AND ELIMINATE FILE CONFLICTS EVERYWHERE...
      IF(EXTLOC.EQ.RNONE) THEN
        CALL DAREAD(IDAF,IODA,X(LVTMP),L3,521,0)
        CALL DAWRIT(IDAF,IODA,X(LVTMP),L3,71,0)
      ENDIF
C
C     1. FINAL ORBITAL ORDER ==> FILE 527
C     2. FINAL ATOM ORDER    ==> FILE 531
      CALL MALMQ_REORDER1(NAT,L1,X(LEIG1),NATMOR,
     *                    NACT,NCORTOT,KEEPER,
     *                    SOME)
C
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C     SVD-VVOS OVERHAUL:  STEP LAST
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C     RESET DIMENSIONS
C     RESET THE MSTA ARRAY
C
      IF(IVVOS.NE.0) THEN
        CALL LOCAL_SVDVVOS_REDIM_STEPLAST(
     *       SCFTYP,NACT,NACTSV,NSPACE,NSPACE_SAV,ISIZE_FCCWFN,
     *       MSTA,X(LMSTA_SAV),MASWRK,IW)
      ENDIF
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C     END OF SVD-VVOS OVERHAUL:  STEP LAST
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C
C     RELEASE ALL MEMORY FOR ATOMIC-LIKE ORBITALS.
 8999 CONTINUE
      CALL RETFM(NDAWN1)
C
      IF(MASWRK) WRITE(IW,9300)
      CALL TIMIT(1)
      RETURN
 9000 FORMAT(/5X,60(1H-)/
     *   5X,'LOCAL_LMOSVD NOW LOCALIZES ATOMIC BASIS ONTO MO SPACE.'/
     *   5X,60(1H-))
 9049 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *       /1X,'SCFTYP DOES NOT EXIST YET.')
 9050 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *       /1X,'VVOS MCSCF CAN ONLY RUN THROUGH LOCAL_LMOSVD',
     *        1X,'WITH THE ORMAS CISTEP.')
 9051 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *       /1X,'VVOS-SVD MCSCF RUNS MUST BE ALLOWED TO USE MORE',
     *        1X,'OF THE MSTA ARRAY.',
     *       /1X,'MSTA IS IN A COMMON WITH FIXED DIMENSION.',
     *        1X,'YOU NEED TO INCREASE FIXED DIMENSION OF MSTA',
     *        1X,'EVERYWHERE.')
 9052 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *        1X,'RIGHT NOW, VVOS ARE FORMED FROM THE OPERATOR',
     *        1X,'IN THE AO BASIS EARLIER IN THE CODE.',
     *       /1X,'SO, NATURAL ORBITALS CANNOT BE USED.')
 9053 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *        1X,'EXTLOC=SVD RUNS MUST RUN WITH VVOS=.T.',
     *       /1X,'SET VVOS TO TRUE IN SCF OR MCSCF GROUP.')
 9054 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *        1X,'LOCAL=SVD AND EXTLOC DO NOT WORK TOGETHER.')
CKEEPIVVOS 9060 FORMAT(//10X,'MCSCF OCCUPIEDS+VVOS LOCALIZED ORBITALS')
 9070 FORMAT(/1X,'CHECKING OUT ISVDOP OPTIONS.')
 9071 FORMAT(1X,'USING REGULAR SVD OPTION.')
 9072 FORMAT(1X,'USING SVDEXTORBSNUM OPTION:',
     *      /1X,'RIGHT NOW, SVDEXTORBSNUM IS POSSIBLE FOR NSPACE=2.')
 9073 FORMAT(1X,'USING SVDAOS OPTION:  NONORTHOGONAL AOS IN SVD.')
 9074 FORMAT(1X,'USING SVDPRJ OPTION:  KR NON-SVD PROJECTION.',
     *      /1X,'THIS OPTION WAS MADE EARLY ON BEFORE SPHERICAL FIX.',
     *      /1X,'IT SHOULD ONLY BE USED FOR MBS.',
     *       1X,'CODE MIGHT NEED SOME FIXING....')
 9076 FORMAT(1X,'USING SVDMBSNUM OPTION:  ',
     *      /1X,'FORCE MBS ORBITALS THROUGH NATMOR INPUT FOR VVOS.',
     *      /1x,'PLEASE THINK ABOUT ORBITAL RANGES FOR NEW GROUP.')
 9077 FORMAT(1X,'USING SVD_INVAR OPTION:  ',
     *      /1X,'ATOMIC MO OVERLAPS ON ATOM A WITH SVD BASIS.')
 9078 FORMAT(1X,'USING SVD_INVAR2 OPTION:  ',
     *      /1X,'ATOMIC MO OVERLAPS ON ALL BUT',
     *       1X,'ATOM A WITH SVD BASIS.',
     *      /1X,'HERE, THE SMALLEST EVALUES ARE TAKEN INSTEAD.')
 9080 FORMAT(1X,'USING SVD_AOSCF OPTION:  ',
     *      /1X,'FOR MBS ORBITALS, USE THE TRUE AOS FROM VVOS.',
     *      /1X,'FOR MORE THAN MBS ORBITALS,',
     *       1X,'USE SVD TO AO BASIS SET FOR THE EXTRA ORBITALS.')
 9081 FORMAT(1X,'USING SVD_AOSCF OPTION:  ',
     *      /1X,'FOR RHF OCCUPIEDS, USE THE TRUE AOS FROM VVOS.',
     *      /1X,'FOR RHF EXTERNALS,',
     *       1X,'USE SVD TO AO BASIS SET FOR THE EXTRA ORBITALS.')
 9085 FORMAT(1X,'USING SVD AOS AWAY FROM OTHER ATOMS OPTION:  ')
 9090 FORMAT(1X,'THIS OPTION DOES NOT EXIST IN THE CODE.')
 9100 FORMAT(/1X,'RE-DEFINING ORBITAL SIZES FOR VVOS RUN...'/
     *       /1X,'CHEMICAL     CORE    ORBTIALS =',I5,
     *       /1X,'ORIG. FILLED VALENCE ORBITALS =',I5,
     *       /1X,'ORIG. ACTIVE VALENCE ORBITALS =',I5,
     *       /1X,'ORIG. EMPTY  VALENCE ORIBTALS =',I5,
     *       /1X,'NEW   VIRTUAL        ORBITALS =',I5)
 9200 FORMAT(/1X,'READING L1,L0MBS SV MATRIX FOR AOS',
     *        1X,'FROM THE VVOS RUN.',
     *       /1X,'NOTES FOR SCFTYP=MCSCF:',
     *       /1X,'1. IF VVOS IN MCSCF IS FALSE,',
     *       /1X,'DO NOT INSERT',
     *        1X,'VVOS INTO CANONICAL MCSCF ORBITALS.',
     *       /1X,'2. IF RUN BOMBS, CHECK FOR DIMENSION ISSUE',
     *        1x,'WITH DAF FILE 533.')
 9300 FORMAT(1X,'... DONE WITH SVD LOCALIZATION ...')
      END
C*MODULE LOCAL   *DECK LOCAL_PPAERR
c> @brief      Routine checks basis set for SVD-localization.
c>
c> @author     Aaron West and Klaus Ruedenberg
c>             -November 4, 2012
c> @details    Routine checks basis set for SVD-localization.
c>
c> @param ZAN          is from INFOA common.
c> @param IAN          is from INFOA common.
c> @param NAT          is the number of atoms.
c> @param NCORSV       is number of core orbitals.
c>                     For VVOS run, it is adjusted.
c> @param NACT         is the number of active orbitals.
c> @param NATMOR       is an integer array of atom numbers for each
c>                     orbital in the ORMAS subpsaces.
c>                     It restricts the localization by user input.
c> @param L0           is the length of the MO variational space.
C> @param L0MBS        is the dimension of the minimal basis set number of
C>                     orbitals.  L0MBS is derived from NCORTOT + LOCAL_NUMVAL.
c> @param MSTA         contains the starting orbitals for each
c>                     ORMAS group, or subspace.
c> @param ISIZE_FCCWFN is current size of fccwfn integer arrays.
c> @param NSPACE       is the number ORMAS groups.
c> @param CISTEP       is the kind of CI performed e.g. ormas,aldet.
c> @param IATMSTA      is an array that defines sets of atoms and
c>                     orbitals to localized based on natmor input.
c> @param IATMSTA2     is for catching bugs across to local_ppasvd.
C> @param KEEPER       is a logical that equals true when
C>                     cistep=ormas and nspace>1 and ormful=false.
C> @param ORMFUL       is the local input that allows for full localization
C>                     across ORMAS groups.  Thus, it destroys ORMAS wavefunction
C>                     invariance for less than full excitations.
C> @param KEEPER_ISVMOR   is true if the user input the number of orbitals
C>                        desired on each atom.
C>                        If false, we let the SVD figure out
C>                        atom-orbital assignments.
C> @param ISVMOR       is ISVMOR from ORNTMO common block.
C> @param IVVOS        equals 1 indicates a VVOS run.
C>                     At this point, running VVOS orbitals through SVD.
C> @param SVDEXTORBSNUM
C>                     is a logical that allows for a special selection
C>                     orbitals on each atom not based on SVD evalues.
C> @param ISVDOP       is a switch for various extra options.
C>                     I made this item so that I do not have to keep
C>                     taking up space to the nameio call for local group.
C> @param SCFTYP       is SCF type for the wave function.
c> @param MASWRK       indicates the master process.
c> @param IW           indicates write out to the log file.
      SUBROUTINE LOCAL_PPAERR(ZAN,IAN,NAT,NCORSV,NACT,NATMOR,L0,L0MBS,
     *                  MSTA,ISIZE_FCCWFN,NSPACE,CISTEP,
     *                  IATMSTA,IATMSTA2,KEEPER,ORMFUL,
     *                  KEEPER_ISVMOR,ISVMOR,IVVOS,SVDEXTORBSNUM,ISVDOP,
     *                  SCFTYP,
     *                  MASWRK,IW)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL MASWRK,KEEPER,KEEPER_ISVMOR,ORMFUL,SVDEXTORBSNUM
      LOGICAL FILL_NATMOR,FILL_ISVMOR,FILL_ALL,COMBO
      INTEGER MXATM,NSPACE,ISVDOP
      PARAMETER (MXATM=2000)
      DOUBLE PRECISION :: ZAN(MXATM),CISTEP,ORMAS,SCFTYP,RHF
      INTEGER NAT,IW,I,J,II,NERR,IERR,ILAST,NUCZ,ITMP,NCORSV,NACT,
     *        ISIZE_FCCWFN,L0,L0MBS,L,K
      INTEGER IVVOS
      INTEGER ICOUNT,NUMVAL1,LOCAL_NUMVAL
      INTEGER IAN(MXATM),MSTA(ISIZE_FCCWFN),NATMOR(L0),
     *        IATMSTA(NSPACE*NAT),IATMSTA2(NSPACE*NAT),
     *        ISVMOR(NAT)
C-----------------------------------------------------------------------
C
      DATA ORMAS /8HORMAS   /
      DATA RHF/8HRHF     /
C
C     INITIALIZE NERR
      NERR=0
C
C     MAKE SOME MAIN ERROR OUTS FIRST.
C     --FOR NOW, ABORT IF BASIS IS NOT ALL ELECTRON BASIS.
      IERR=0
      ILAST=55
      DO I=1,NAT
        NUCZ = INT(ZAN(I) + 1.0D-03)
        IF(NUCZ.NE.IAN(I).OR.IAN(I).GE.ILAST) IERR=IERR+1
      ENDDO
      NERR=NERR+IERR
      IF(MASWRK) WRITE(IW,9001)
      IF(MASWRK.AND.IERR.GT.0) WRITE(IW,9002)
C
C     CHECK OUT THE NATMOR AND ISVMOR ARRAYS
      FILL_NATMOR=.FALSE.
      FILL_ISVMOR=.FALSE.
      DO I=NCORSV+1,NCORSV+NACT
        IF(NATMOR(I).NE.0) FILL_NATMOR=.TRUE.
      ENDDO
      DO I=1,NAT
        IF(ISVMOR(I).NE.0) FILL_ISVMOR=.TRUE.
      ENDDO
C
C
C     NEW SECTION FOR NEW KINDS OF ERROR OUT OPTIONS.
C
C
C     SOME ERROR OUTS FOR ISVDOP=10.
C     MORE CRAZY SORTING ARRRAYS WOULD BE REQUIRED TO REMOVE
C     THE ERRORS BELOW....
C     THE USER WILL CERTAINLY NEED TO PUT IN VALUES... BIAS.
C     SO, LET'S MAKE THEM ERROR OUTS.
      IF(ISVDOP.EQ.10) THEN
        IF(MASWRK
     *    .AND.NSPACE.EQ.2
     *    .AND.NACT.GT.L0MBS-NCORSV) WRITE(IW,9031)
        IF(NACT.GT.L0MBS-NCORSV.AND.NSPACE.NE.2) THEN
          IF(MASWRK) WRITE(IW,9032)
          NERR=NERR+1
        ENDIF
C       NOTE:  NSPACE2 WAS FED IN AND SET TO 1 FOR ALDET.
      ENDIF
C
C     MAKE SVDEXTORBSNUM MUTUALLY EXCLUSIVE TO FILL_NATMOR OR FILL_ISVMOR.
C     ALSO, THIS OPTION REQUIRES NSPACE=2 FOR RIGHT NOW.
      FILL_ALL=FILL_NATMOR.OR.FILL_ISVMOR
      COMBO=ISVDOP.EQ.1
      IF(FILL_ALL.AND.COMBO) THEN
        IF(MASWRK) WRITE(IW,9033)
        NERR=NERR+1
      ENDIF
      IF(SVDEXTORBSNUM.AND.NSPACE.NE.2) THEN
        IF(MASWRK) WRITE(IW,9034)
        NERR=NERR+1
      ENDIF
      IF(SVDEXTORBSNUM.AND..NOT.KEEPER) THEN
        IF(MASWRK) WRITE(IW,9035)
        NERR=NERR+1
      ENDIF
C
C     ALLOW NATMOR WITH VVOS UNDER CERTAIN CONDITIONS.
      COMBO=ISVDOP.NE.6.AND.ISVDOP.NE.8
     *                 .AND.ISVDOP.NE.11
     *                 .AND.ISVDOP.NE.4
     *                 .AND.ISVDOP.NE.10
     *                 .AND.ISVDOP.NE.15
      COMBO=COMBO.AND.SCFTYP.NE.RHF
      COMBO=COMBO.AND.FILL_NATMOR.AND.IVVOS.NE.0
      IF(COMBO) THEN
        IF(MASWRK) WRITE(IW,9040)
        NERR=NERR+1
      ENDIF
C
C     MAKE CONDITIONS FOR USING SOME ISVDOP OPTIONS.
      COMBO=ISVDOP.EQ.6.OR.ISVDOP.EQ.8
      IF(KEEPER) THEN
        IF(COMBO.AND..NOT.FILL_NATMOR) THEN
          IF(MASWRK) WRITE(IW,9041)
        ENDIF
      ELSE
        IF(COMBO.AND..NOT.FILL_ISVMOR) THEN
          IF(MASWRK) WRITE(IW,9042)
        ENDIF
      ENDIF
C
C     ERROR OUT IF CISTEP=ORMAS AND ISVMOR ARRAY IS FILLED IN.
      IF(MASWRK.AND.CISTEP.EQ.ORMAS) WRITE(IW,9050)
      IF(CISTEP.EQ.ORMAS.AND.FILL_ISVMOR) THEN
        NERR=NERR+1
        IF(MASWRK) WRITE(IW,9051)
      ENDIF
C
C     SKIP REST OF THE ERROR OUTS IF KEEPER + NO NATMOR ARRAY.
      IF(KEEPER .OR. ORMFUL) THEN
        IF(.NOT.FILL_NATMOR) THEN
          CALL VICLR(IATMSTA,1,NSPACE*NAT)
          CALL VICLR(IATMSTA2,1,NSPACE*NAT)
          GO TO 8000
        ELSE
C         NOW, AUTO-FILL IN ISVMOR ARRAY FOR ITS DEFS IN LOCAL_NUMVAL.
          DO I=NCORSV+1,NCORSV+NACT
            ITMP=NATMOR(I)
            ISVMOR(ITMP)=ISVMOR(ITMP)+1
          ENDDO
        ENDIF
      ENDIF
C
C     END OF NEW SECTION FOR NEW KINDS OF ERROR OUT OPTIONS.
C
C
C     ERROR OUT IF ACTIVE ORBITALS ARE NOT THE LENGTH NACT.
C     NOTE:  THIS VAR TRUE IF NATMOR OR ISVMOR IS FILLED HERE.
      IF(KEEPER_ISVMOR) THEN
      ITMP=0
      DO I=1,NAT
        NUMVAL1=LOCAL_NUMVAL(I,0)
        ITMP=ITMP+NUMVAL1
      ENDDO
      IERR=0
      IF(ITMP.NE.NACT) IERR=1
      NERR=NERR+IERR
      IF(MASWRK) WRITE(IW,9003)
      IF(MASWRK.AND.IERR.GT.0) WRITE(IW,9004)
      ENDIF
C
C     MAKE CHECKS ON NATMOR FOR ORMAS NSPACE>1.
C     --CHECK THAT NSPACE IS ACTUALLY GREATER THAN 0.
C     --CHECK THAT ALL ACTIVE ORBITALS ARE ASSIGNED ATOM NUMBERS.
C     --ATOM NUMBERS IN NATMOR MUST BE LESS THAN NAT.
C     --OCCURENCES OF ATOM NUMBERS IN NATMOR
C       CANNOT EXCEED NUMBER OF VALENCE ORBITALS ON EACH ATOM.
C
      IF(CISTEP.NE.ORMAS.OR.NSPACE.EQ.1) GO TO 8000
      IERR=0
      IF(NSPACE.EQ.0) IERR=IERR+1
      NERR=NERR+IERR
      IF(MASWRK) WRITE(IW,9005)
      IF(NSPACE.EQ.0) WRITE(IW,9006)
C
C     AT THIS POINT, MSTA ORBITAL INDICES CONTAIN CORES.
      IERR=0
      DO I=MSTA(1),MSTA(NSPACE+1)-1
        IF(NATMOR(I).EQ.0) IERR=IERR+1
      ENDDO
      NERR=NERR+IERR
      IF(MASWRK) WRITE(IW,9007)
      IF(IERR.GT.0.AND.MASWRK) WRITE(IW,9008)
C
      IERR=0
      DO I=1,NAT
        ITMP=0
        DO II=MSTA(1),MSTA(NSPACE+1)-1
          IF(NATMOR(II).EQ.I) ITMP=ITMP+1
        ENDDO
        NUMVAL1=LOCAL_NUMVAL(I,0)
        IF(ITMP.GT.NUMVAL1) IERR=IERR+1
      ENDDO
      NERR=NERR+IERR
      IF(MASWRK) WRITE(IW,9009)
      IF(MASWRK.AND.IERR.GT.0) WRITE(IW,9010)
C
C     NOW, USE NATMOR TO CREATE THE IATMSTA ARRAY.
C          THE IATMSTA ARRAY WILL SOON DEFINE THE
C          THE SVD SIZES IN THE SUBSEQUENT ROUTINES.
C          THE IATMSTA2 ARRAY IS CATCHING BUGS IN -LOCAL_PPASVD-.
C          IATMSTA2 WILL THEN CHANGE TO DEFINE STARTING ORBITAL NUMBER.
      CALL VICLR(IATMSTA,1,NSPACE*NAT)
      CALL VICLR(IATMSTA2,1,NSPACE*NAT)
      DO II=1,NSPACE
        DO I=MSTA(II),MSTA(II+1)-1
          DO J=1,NAT
            ITMP=(J-1)*NSPACE+II
            IF(NATMOR(I).EQ.J) IATMSTA(ITMP)=IATMSTA(ITMP)+1
            IF(NATMOR(I).EQ.J) IATMSTA2(ITMP)=1
          ENDDO
        ENDDO
      ENDDO
      IF(MASWRK) THEN
        WRITE(IW,9012)
        DO II=1,NSPACE
          WRITE(IW,9013) II
          DO J=1,NAT
            ITMP=(J-1)*NSPACE+II
            IF(IATMSTA2(ITMP).EQ.1) WRITE(IW,9014) J
          ENDDO
        ENDDO
        WRITE(IW,9015)
        WRITE(IW,9016)
        DO II=1,NSPACE
          DO J=1,NAT
            ITMP=(J-1)*NSPACE+II
            IF(IATMSTA(ITMP).NE.0)
     *        WRITE(IW,9017) II,J,IATMSTA(ITMP)
          ENDDO
        ENDDO
        WRITE(IW,9015)
      ENDIF
C
C     KEY PIECE:
C     --JUST LIKE IN LOCAL_PPASVD FOR THE AUTOMATED VERSION,
C       NOW RESET THE NATMOR ARRAY.
C     --IF THE CANONICAL ORBITALS ARE LOCALIZED ENOUGH THAT
C       THE ATOM-ORBITAL CORRESPONDENCE REMAINS THE SAME,
C       THEN ALL IS WELL.
C     --OTHERWISE:
C     1)  TOTAL ATOMIC VALENCE POPULATIONS IN LOCAL_NATMOR WRONG.
C     2)  NATMOR ASSIGMENT IN MALMQ_REORDER1 WRONG.
C         SO, NATMOR IS THEN WRONG FOR ORIENTED ORBITALS.
C
      DO I=1,NSPACE
        ICOUNT=0
        DO J=1,NAT
          K=MSTA(I)+ICOUNT
          ITMP=(J-1)*NSPACE+I
          DO L=K,K+IATMSTA(ITMP)
              NATMOR(L)=J
          ENDDO
          ICOUNT=ICOUNT+IATMSTA(ITMP)
        ENDDO
      ENDDO
C
C     ACTUALLY ERROR OUT.
 8000 CONTINUE
      IF(NERR.GT.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9001 FORMAT(/1X,'BASIS SET CHECK IS DONE.')
 9002 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.'/
     *       1X,'ERROR OCCURS FOR USING BASIS SET.')
 9003 FORMAT(1X,'ACTIVE VALENCE ORBITAL CHECK IS DONE.')
 9004 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.'/
     *       1X,'NACT MUST EQUAL NUMBER OF MBS',
     *       1X,'OR USER SELECTED VALENCE ORBITALS.')
 9005 FORMAT(1X,'FCCWFN CHECK IS DONE.')
 9006 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.'/
     *       1X,'FCCWFN COMMON IS NOT YET DEFINED.'/)
 9007 FORMAT(1X,'NATMOR ARRAY CHECK IS DONE.')
 9008 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.'/
     *  /1X,'SVD ORMAS IS ASKING FOR',
     *   1X,'NATMOR ARRAY BE FILLED IN.',
     *  /1X,'IF USER FILLED, IT WILL NOT BE RESET.',
     *  /1X,'ISVMOR ARRAY CAN NEVER BE USER DEFINED',
     *   1X,'WITH ORMAS HERE.')
 9009 FORMAT(1X,'ATOM OCCURENCES IN NATMOR ARRAY CHECK IS DONE.')
 9010 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.'/
     *       1X,'SVD ORMAS REQUIRES NATMOR ARRAY VALUE OCCURENCES',
     *       1X,'MAX OUT WITH THE'/,
     *       1X,'MAXIMUM NUMBER OF VALENCE ORBITALS',
     *       1X,'ALLOWED ON EACH ATOM.'/)
 9012 FORMAT(/1X,'*** DEFINING SVD ATOM ASSIGNEMENTS',
     *        1X,'BASED ON USER INPUT. ***',
     *       /1X,'NSPACE',4X,'ATOM')
 9013 FORMAT(/I3,4X,' ',$)
 9014 FORMAT(1X,I3,$)
 9015 FORMAT(/)
 9016 FORMAT(/1X,'*** DEFINING SVD OUTPUTS BASED ON USER INPUT. ***',
     *       /1X,'NSPACE',4X,'ATOM',4X,'NUMBER OF MOs')
 9017 FORMAT(1X,I3,4X,I3,4X,I3)
 9031 FORMAT(1X,'ISVDOP=10 + NSPACE=2 RUNS MUST HAVE',
     *       1X,'MBS NUMBER OF ORBITALS IN GROUP 1.')
 9032 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.',
     *        1X,'ISVDOP=10 CANNOT BE USED WHEN',
     *        1X,'NACT>L0MBS-NCORTOT AND NSPACE NE 2.')
 9033 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.',
     *        1X,'THIS ISVDOP OPTION CANNOT BE USED WHEN',
     *        1X,'ISVMOR OR NATMOR ARRAYS ARE FILLED.')
 9034 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.',
     *        1X,'SVDEXTORBSNUM OPTION MUST HAVE NSPACE=2 RIGHT NOW.')
 9035 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.',
     *        1X,'SVDEXTORBSNUM OPTION MUST HAVE KEEPER VAR TRUE.')
 9040 FORMAT(1X,'THE USER CANNOT CHOOSE NATMOR',
     *       1X,'IN VVOS-SVD RUNS WITHOUT ISVDOP=6,8,11.')
 9041 FORMAT(1X,'ERROR:  PLEASE FILL IN NATMOR ARRAY.')
 9042 FORMAT(1X,'ERROR:  PLEASE FILL IN ISVMOR ARRAY.')
 9050 FORMAT(1X,'ORMAS ISVMOR ARRAY CHECK IS DONE.')
 9051 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.'
     *       /1X,'SVD ORMAS CANNOT HAVE ISVMOR FILLED IN.')
      END
C*MODULE LOCAL   *DECK LOCAL_NUMVAL
c> @brief      Routine returns number of valences orbitals.
c>
c> @author     Aaron West and Klaus Ruedenberg
c>             -November 4, 2012
c> @details    Routine returns number of valence orbitals for
c>             atom ITMP2.
c>
c> @date January 12, 2013-Aaron West
c> -This routine has now moved beyond the minimal basis set.
c>
c> @param ITMP2 is the atom number.
C>
C> @date January 30, 2013-Aaron West
C> -Added ISVDOP to ORNTMO common block.
C> This run gives special option for SVD runs.
C>
C> @date March 20, 2013-Aaron West
C> -Added ISWMBS to integer function.
C> ISWMBS allows for the output of MBS numbers of orbitals.
C>
      INTEGER FUNCTION LOCAL_NUMVAL(ITMP2,ISWMBS)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      INTEGER IWX,ITEST,I,ITMP,ITMP2,NVALAT,ISWMBS,NERR
C---------------------------------------------------
      LOGICAL ORIENT,ORIKIN,ORMFUL
      DOUBLE PRECISION :: ZAN,C,BNDDEN
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
      INTEGER MXATM,NAT,ICH,MUL,NUM,NQMT,NEX,NA,NB,IAN
      INTEGER NATMOR,ISVMOR,ISVDOP,MXAO
      DOUBLE PRECISION :: EXTLOC,EREFATM
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
      INTEGER IVVOS,NVVOS
C---------------------------------------------------
      PARAMETER (MXATM=2000, MXAO=8192)
C---------------------------------------------------
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NEX,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /ORNTMO/ EXTLOC,EREFATM,
     *                NATMOR(MXAO),ISVMOR(MXATM),ISVDOP,
     *                ORIENT,ORIKIN,ORMFUL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /VVOPAR/ IVVOS,NVVOS,BNDDEN
C-----------------------------------------------------------------------
C
C     RETURN THE NUMBER OF VALENCE ORBITALS ON A GIVEN ATOM.
C     ALSO SEE NUMCOR,NVVOS_NUMCOR,AND VVOS ROUTINES.
C     STILL NEED TO ADDRESS ECPs,ETC.
C     STILL NEED TO ADDRESS SEMI-CORE ORBS.
C
      NERR=0
      ITEST=0
      DO I=1,NAT
        IF(ISVMOR(I).NE.0) ITEST=1
      ENDDO
C
C     HERE, WE WILL ENFORCE MBS NUMBERS OF ORBITALS FOR CERTAIN OPTIONS.
      IF(IVVOS.NE.0) ITEST=0
C
C     GRAB ATOM NUMBER
      I=ITMP2
C
C     ASSIGN NUMBER OF VALENCE ORBITALS
      IF(ITEST.EQ.0.OR.ISWMBS.EQ.1) THEN
        ITMP=IAN(I)
        IF(ITMP.LT.1.OR.ITMP.GT.54) THEN
          NERR=NERR+1
          IF(MASWRK) WRITE(IW,9000)
        ENDIF
        IF(               ITMP.LE. 2) NVALAT=1
        IF(ITMP.GE. 3.AND.ITMP.LE. 4) NVALAT=1
        IF(ITMP.GE. 5.AND.ITMP.LE.10) NVALAT=4
        IF(ITMP.GE.11.AND.ITMP.LE.12) NVALAT=1
        IF(ITMP.GE.13.AND.ITMP.LE.18) NVALAT=4
        IF(ITMP.GE.19.AND.ITMP.LE.20) NVALAT=1
        IF(ITMP.GE.21.AND.ITMP.LE.30) NVALAT=6
        IF(ITMP.GE.31.AND.ITMP.LE.36) NVALAT=4
        IF(ITMP.GE.37.AND.ITMP.LE.38) NVALAT=1
        IF(ITMP.GE.39.AND.ITMP.LE.48) NVALAT=6
        IF(ITMP.GE.49.AND.ITMP.LE.54) NVALAT=4
      ELSE
        NVALAT=ISVMOR(I)
      ENDIF
C
      IF(NERR.GT.0) THEN
        IWX=IW
        CALL FLSHBF(IWX)
        CALL ABRT
        STOP
      ENDIF
C
      LOCAL_NUMVAL=NVALAT
C
      RETURN
 9000 FORMAT(1X,'LOCAL_NUMVAL ERROR:',
     *      /1X,'THERE IS A PROBLEM WITH THE INTEGER ARRAY IAN.')
      END
C*MODULE LOCAL   *DECK LOCAL_ATM_CH
C> @brief      This routine return integer value of nuclear charge.
C>
C> @author     Aaron West
C>             -November 15, 2012
C>
C> @details    This routine return integer value of nuclear charge.
C>             Using function avoids any conflict of variables very
C>             easily.  e.g. in Davidson routines for Malmqvist items
C>
C> @param IAT is the atom number.
      INTEGER FUNCTION LOCAL_ATM_CH(IAT)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      INTEGER IAT
C     NEW CODING STANDARDS VARS
      DOUBLE PRECISION :: ZAN,C
      INTEGER MXATM,NAT,ICH,MUL,NUM,NQMT,NEX,NA,NB,IAN
      PARAMETER (MXATM=2000)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NEX,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C-----------------------------------------------------------------------
C
      LOCAL_ATM_CH=INT(ZAN(IAT))
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_PPASVDCORE
c> @brief      Routine makes SVD-localized core orbitals.
c>
c> @author     Aaron West and Klaus Ruedenberg
c>             -November 4, 2012
c>
c> @details    Routine makes SVD-localized core orbitals.
c>             LOCAL_PPASVD contains equivalent and
c>             better comments in the routine itself.
c>
c> @date November 16, 2012-Aaron West
c> -Removed some error outs for vtvec.  Symmetric molecules
c>  can have zeros here even in C1 point group.
c>  This error out was mainly for debugging bad code.
c>
c> @param NCORTOT is total number of MCSCF core orbitals.
c>        For VVOS run, it is adjusted.
c> @param IORBF1 is the dat dict file for initial orbitals.
c> @param S2 stores AO basis overlaps on each atom.
c> @param S stores all the AO basis overlaps.
c> @param UVEC is the u matrix in SVD.
c> @param EIG holds eigenvalues from SVD.
c> @param VTVEC is the V-transpose matrix in SVD.
c> @param WRKSVD is the work array designed for gldiag and svd calls.
c> @param IWRK is the integer work array used
c>                    -- for symmetric matrix indices
c>                    -- for gldiag calls
c> @param VOLD contains the AO coefficients from IORBF1 daf dict file.
c> @param VTMP is temporary storage.
c> @param VSAV is temporary storage.
c> @param SV holds the AO basis overlap times AO coefficients matvec.
c> @param SAOMO is often S_IATM1**(-1/2) * SV on each IATM1 atom.
c> @param ISIZSVD is the workspace size for WRKSVD array.
c> @param L0 is the length of the MO variational space.
c> @param L1 is the length of the AO coefficients.
c> @param L2 is the triangular length of L1.
c> @param L3 is the square of L1.
c> @param LIMLOW array contains the lower basis function on an atom.
c> @param LIMSUP array contains the upper basis function on an atom.
c> @param NAT is the number of atoms.
c> @param SVDAOS is a toggle option for orthogonalizing the input AOs.
C> @param ISPHER       indicates treatment of basis functions
C>                     in terms of spherical or Cartesians.
C> @param KTYPE        is 1,2,3,4,5,6,7 for S,P,D,F,G,H,I.
C>                     L and P require more to be distinguished.
C>                     See 'documentation' in inputa.src for more info.
C> @param KATOM        indicates which atom the give shell
C>                     is centered on.
C> @param KMIN         contains the starting indices of the shells.
C> @param KMAX         contains the ending   indices of the shells.
C> @param NSHELL       is the total number of shells.
C>                     e.g. f is a shell.
C> @param WSPHER       will hold the atomic Cartesian-to-Spherical
C>                     transformation matrix.
C>                     It is not normalized at the start.
C> @param SOME   is true for master process with nprint not equal -5.
c> @param MASWRK indicates the master process.
c> @see   LOCAL_PPASVD
      SUBROUTINE LOCAL_PPASVDCORE(
     *           NCORTOT,IORBF1,S2,
     *           S,UVEC,EIG,VTVEC,WRKSVD,IWRK,
     *           VOLD,VTMP,VSAV,
     *           SV,SAOMO,
     *           ISIZSVD,L0,L1,L2,L3,
     *           LIMLOW,LIMSUP,NAT,SVDAOS,
     *           ISPHER,KTYPE,KATOM,KMIN,KMAX,NSHELL,WSPHER,
     *           SOME,MASWRK)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL SOME,MASWRK,SVDAOS
      INTEGER MXATM
      PARAMETER (MXATM=2000)
      DOUBLE PRECISION :: ONE,TOL
      INTEGER NAT,LIMLOW(MXATM),LIMSUP(MXATM),
     *        NVVOS_NUMCOR
      PARAMETER (ONE=1.0D+00, TOL=1.0D-06)
      INTEGER I,IATM1,IBAS1,IBAS2,IERR2,IERR3,IHACT,
     *        ILTH_FIX,ILTH,IMO,IORBF1,ISIZSVD,J,L0,L1,L2,L3,
     *        NCORTOT,NUMCOR1,IJ2,ITMP
C---------SPHERICAL HARMONIC STUFF---------------------
      LOGICAL IGNORE_SPHER
      INTEGER ISPHER,NSHELL
      INTEGER KTYPE(NSHELL),KATOM(NSHELL),KMIN(NSHELL),KMAX(NSHELL)
      DOUBLE PRECISION :: WSPHER(L1,L1)
C------------------------------------------------------
C     NEW CODING STANDARDS VARS
      INTEGER INFO
      INTEGER IDAF,IODA,IP,IPK,IR,IS,IW,NAV
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C-----------------------------------------------------------------------
      DOUBLE PRECISION ::
     *       S2(L2),S(L2),
     *       UVEC(L1,L1),EIG(L1),VTVEC(L0,L0),
     *       WRKSVD(ISIZSVD),
     *       VOLD(L1,L1),VTMP(L1,L1),VSAV(L1,L1),
     *       SV(L1,L1),SAOMO(L1,L1)
      INTEGER IWRK(L2)
C
C     -------------------------------------------------------
C     SEE LOCAL_PPASVD ROUTINE FOR ANALOGOUS COMMENTS.
C     -------------------------------------------------------
C
C
C     READ IN THE DESIRED ORBITALS.
      CALL DAREAD(IDAF,IODA,VOLD,L3,IORBF1,0)
C
C     SV=S*V=AO BASIS OVERLAP*AO COEFFS WITH INNER CONTRACTIN OVER ALL ATOMS.
C     GET AND SAVE SV FOR ALL ATOMS
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL MTARBR(S,L1,VOLD,L0,SV,L1,1)
C
C     VCLR (CORE) NONROTHOGONAL QUASI-ATOMIC ORBITAL TRANSFORMATION.
      CALL VCLR(VSAV,1,L3)
C
C     LOOP OVER ALL ATOMS
      DO 100 IATM1=1,NAT
C
C       SKIP IF NUMCOR1=0.
        NUMCOR1=NVVOS_NUMCOR(IATM1,1)
        IF(NUMCOR1.EQ.0) GO TO 100
C
C       SET UP BASIS DIMENSIONS AND OVERLAP.
        CALL LOCAL_GRAB_BASIS_FXNS_ON_ATOM(
     *       LIMLOW,LIMSUP,IATM1,NAT,L2,
     *       S2,S,
     *       IBAS1,IBAS2,ILTH)
C
C-------------BEGIN: DEAL WITH SPHERICAL ISSUES1-------------------
        IGNORE_SPHER=.FALSE.
        IF(SVDAOS) IGNORE_SPHER=.TRUE.
        ILTH_FIX=ILTH
        IF(ISPHER.GT.0.AND..NOT.IGNORE_SPHER) THEN
          ITMP=ILTH
          CALL LOCAL_ATOMIC_SPH_HARM(
     *         0,S2,ITMP,ILTH_FIX,IATM1,
     *         KTYPE,KATOM,KMIN,KMAX,NSHELL,
     *         ISIZSVD,L1,L2,L3,WSPHER,UVEC,VTMP,S,
     *         WRKSVD,EIG,SAOMO,IWRK,TOL,
     *         SOME,MASWRK,IW)
C         S WAS DESTROYED.
C         SO, READ BACK IN THE TRUE AO OVERLAP.
          CALL DAREAD(IDAF,IODA,S,L2,12,0)
C-------------END: DEAL WITH SPHERICAL ISSUES1---------------------
        ELSE
        IERR2=0
        CALL VCLR(VTMP,1,L3)
        CALL GLDIAG(L1,ILTH_FIX,ILTH_FIX,
     *              S2,WRKSVD,EIG,VTMP,IERR2,IWRK)
        IF(IERR2.GT.0) GO TO 8999
        IERR3=0
        DO I=1,ILTH_FIX
          IF(EIG(I).LT.TOL) IERR3=IERR3+1
          EIG(I)=ONE/SQRT(EIG(I))
C          WRITE(IW,*) "IATM1,I,EIG=",IATM1,I,EIG(I)
        ENDDO
        IF(IERR3.GT.0) GO TO 8999
        CALL VCLR(UVEC,1,L3)
        DO I=1,ILTH_FIX
          DO J=1,ILTH_FIX
            UVEC(I,J)=VTMP(J,I)
            UVEC(J,I)=VTMP(I,J)
          ENDDO
        ENDDO
        DO I=1,ILTH_FIX
          CALL DSCAL(ILTH_FIX,EIG(I),VTMP(1,I),1)
        ENDDO
C       DO MATVEC TO S_IATM1**(-1/2)
        CALL VCLR(SAOMO,1,L3)
        CALL MRARBR(VTMP,L1,ILTH_FIX,ILTH_FIX,
     *              UVEC,L1,ILTH,SAOMO,L1)
        CALL DCOPY(L3,SAOMO,1,VTMP,1)
        ENDIF
C-------------END: ELSE FROM DEAL WITH SPHERICAL ISSUES1---------------------
C
C       SAOMO= OVERLAP MATRIX B/T CORE MO AND AOS ON IATM1.
        CALL VCLR(UVEC,1,L3)
        DO IMO=1,NCORTOT
          CALL DCOPY(ILTH,SV(IBAS1,IMO),1,UVEC(1,IMO),1)
        ENDDO
        CALL VCLR(SAOMO,1,L3)
        CALL MRARBR(VTMP,L1,ILTH_FIX,ILTH,UVEC,L1,NCORTOT,SAOMO,L1)
C
C---------------------------------------------------------------
C       IMPLEMENT SVDAOS OR SVDPRJ OPTIONS.
C---------------------------------------------------------------
        IF(SVDAOS) THEN
          DO IMO=1,NCORTOT
            CALL DCOPY(ILTH,SV(IBAS1,IMO),1,SAOMO(1,IMO),1)
          ENDDO
        ENDIF
C---------------------------------------------------------------
C       END OF IMPLEMENT SVDAOS OR SVDPRJ OPTIONS.
C---------------------------------------------------------------
C
C       PERFORM SVD FOR IATM1
        CALL VCLR(UVEC,1,L3)
        CALL VCLR(VTVEC,1,L0*L0)
        CALL VCLR(EIG,1,L1)
        CALL DGESVD('A','A',
     *              ILTH_FIX,NCORTOT,SAOMO,L1,EIG,
     *              UVEC,L1,VTVEC,L0,
     *              WRKSVD,ISIZSVD,INFO)
C
C       FORM TRANSFORMATION MATRIX VTVEC-TRANS FOR THE NEWLY PROJECTED MOS.
        CALL TRPOSQ(VTVEC,L0)
C
C       DEFINE THE NUMBER OF CORE ORBITALS TO SAVE.
        NUMCOR1=NVVOS_NUMCOR(IATM1,1)
C
C       GRAB OUT THE (CORE) NONORTHOGONAL QUASI-ATOMIC ORBITAL TRANSFORMATION.
        IHACT=0
        DO I=1,IATM1-1
          IHACT=IHACT+NVVOS_NUMCOR(I,1)
        ENDDO
        DO I=1,NUMCOR1
          IHACT=IHACT+1
          CALL DCOPY(NCORTOT,VTVEC(1,I),1,VSAV(1,IHACT),1)
        ENDDO
C
C     END LOOP OVER ALL ATOMS
  100 CONTINUE
C
C
C
C     SAVE THE (CORE) NONORTHOGONAL QUASI-ATOMIC ORBITAL TRANSFORMATION.
      CALL DAWRIT(IDAF,IODA,VSAV,L3,523,0)
C
C     HAVE THE NONORTHOGONAL ORBITAL TRANSFORMATION.
C     ---CONSTRUCT NONORTHOG. CORE ORBITALS IN DIRECT FASHION
      CALL VCLR(UVEC,1,L3)
      CALL MRARBR(VOLD,L1,L1,NCORTOT,VSAV,L1,NCORTOT,UVEC,L1)
      CALL DAWRIT(IDAF,IODA,UVEC,L3,522,0)
C
C     FORM SV=NEW OVERLAP B/T NEW MO ORBITALS.
C     --UVEC CONTAINS THE NONORTHOG. CORE ORBITALS.
      CALL VCLR(SV,1,L3)
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL MTARBR(S,L1,UVEC,NCORTOT,SV,L1,1)
      CALL MRTRBR(UVEC,L1,L1,NCORTOT,SV,L1,NCORTOT,VTMP,L1)
C
C     FORM VTMP=[ NEW SMO**(-1/2) ] VIA SYM. ORTHOGONALIZATION.
C     HERE INITIAL VTMP=NEW MO OVERLAPS.
      CALL VCLR(S2,1,L2)
      IJ2=1
      DO I=1,NCORTOT
        DO J=1,I
          S2(IJ2)=VTMP(I,J)
          IJ2=IJ2+1
        ENDDO
      ENDDO
      IERR2=0
      CALL VCLR(VTMP,1,L3)
ccccccc
      IF(NCORTOT.NE.0)
     * CALL GLDIAG(L1,NCORTOT,NCORTOT,S2,WRKSVD,EIG,VTMP,IERR2,IWRK)
ccccccc
      IF(IERR2.GT.0) GO TO 8999
      IERR3=0
      DO I=1,NCORTOT
        IF(EIG(I).LT.TOL) IERR3=IERR3+1
        EIG(I)=ONE/SQRT(EIG(I))
C       WRITE(IW,*) "IATM1,I,EIG=",IATM1,I,EIG(I)
      ENDDO
      IF(IERR3.GT.0) GO TO 8999
      DO I=1,NCORTOT
        DO J=1,NCORTOT
          SV(I,J)=VTMP(J,I)
          SV(J,I)=VTMP(I,J)
        ENDDO
      ENDDO
      DO I=1,NCORTOT
        CALL DSCAL(NCORTOT,EIG(I),VTMP(1,I),1)
      ENDDO
C     DO MATVEC TO S_IATM1**(-1/2)
      CALL VCLR(SAOMO,1,L3)
      CALL MRARBR(VTMP,L1,NCORTOT,NCORTOT,SV,L1,NCORTOT,SAOMO,L1)
      CALL DCOPY(L3,SAOMO,1,VTMP,1)
C
C     FORM UVEC * [VTMP = NEW SMO**(-1/2)] MATVEC
C     THIS NEXT PIECE ORTHOGONALIZES THE ALREADY PROJECTED MOS.
      CALL VCLR(SV,1,L3)
      CALL MRARBR(UVEC,L1,L1,NCORTOT,VTMP,L1,NCORTOT,SV,L1)
C     SAVE THE ORTHOGONAL QUASI-ATOMIC ORBITAL TRANSFORMATION NOW.
      CALL DAWRIT(IDAF,IODA,VTMP,L3,524,0)
      CALL DAREAD(IDAF,IODA,VTMP,L3,IORBF1,0)
      DO I=1,NCORTOT
        CALL DCOPY(L1,SV(1,I),1,VTMP(1,I),1)
      ENDDO
C     SAVE THE (CORE) ORTHOGONAL QUASI-ATOMIC ORBITALS.
      CALL DAWRIT(IDAF,IODA,VTMP,L3,521,0)
C
C
C
C
C     PERFORM FINAL ERROR OUTS.
 8999 CONTINUE
      IF(MASWRK) THEN
        IF(IERR2.GT.0) THEN
          WRITE(IW,9003)
        ELSEIF(IERR3.GT.0) THEN
          WRITE(IW,9004) IERR3
        ENDIF
      ENDIF
      IF(IERR2.GT.0
     *  .OR.IERR3.GT.0
     *  ) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9003 FORMAT(1X,'*** ERROR IN LOCAL_PPASVDCORE ROUTINE.'/
     *       1X,'ERROR OCCURS FOR GLDIAG CALL.')
 9004 FORMAT(1X,'*** ERROR IN LOCAL_PPASVDCORE ROUTINE.'/
     *       1X,'IN SYMMETRIC ORTHOG.,'/
     *       1X,I4,' EIGENVALUES ARE BELOW TOL.')
      END
C*MODULE LOCAL   *DECK LOCAL_PPASVD
c> @brief      Routine makes SVD-localized valence orbitals.
c>
c> @author     Aaron West and Klaus Ruedenberg
c>             -November 4, 2012
c>
c> @details    Routine makes SVD-localized core orbitals.
c>             Please see note about VTMP array within
c>             the 100 do loop if you plan to muck.
c>
c> @date November 16, 2012-Aaron West
c> -Removed some error outs for vtvec.  Symmetric molecules
c>  can have zeros here even in C1 point group.
c>  This error out was mainly for debugging bad code.
c>
c> @date December 20, 2012-Aaron West
c> -Add ormas check on orbital transformation
c>  to sort out issues earlier than MALMQ_CIDRIV.
C>
C> @date December 28, 2012-Aaron West
C> -Re-work orbital extraction to use only the orbital transformation
C>  to define the final orbital sets by transforming the orbitals
C>  in the IORBF1 file.
C>
C> @date January 09, 2013-Aaron West
C> -Re-work scheme for the number of orbitals to take from each SVD.
C>  Use ALL maximum SVD values from ALL atoms.
C>
C> @date January 12, 2013-Aaron West
C> -Re-worked large section of this routine.
C>  ORMAS runs should be able to auto-assign orbitals to atoms now.
C>
c> @param NCORTOT is total number of MCSCF core orbitals.
c>        For VVOS run, it is adjusted.
c> @param IORBF1 is the dat dict file for initial orbitals.
c> @param S2 stores AO basis overlaps on each atom.
c> @param S stores all the AO basis overlaps.
c> @param UVEC is the u matrix in SVD.
c> @param EIG holds eigenvalues from SVD.
c> @param VTVEC is the V-transpose matrix in SVD.
c> @param WRKSVD is the work array designed for gldiag and svd calls.
c> @param IWRK is the integer work array used
c>                    -- for symmetric matrix indices
c>                    -- for gldiag calls
c> @param VOLD contains the AO coefficients from IORBF1 daf dict file.
c> @param VTMP is temporary storage.
c> @param VSAV is temporary storage.
c> @param SV holds the AO basis overlap times AO coefficients matvec.
c> @param SAOMO is often S_IATM1**(-1/2) * SV on each IATM1 atom.
c> @param ISIZSVD is the workspace size for WRKSVD array.
c> @param NACT is the total number of active orbitals.
c> @param L0 is the length of the MO variational space.
c> @param L1 is the length of the AO coefficients.
c> @param L2 is the triangular length of L1.
c> @param L3 is the square of L1.
c> @param MSTA         contains the starting orbitals for each
c>                     ORMAS group, or subspace.
c> @param ISIZE_FCCWFN is current size of fccwfn integer arrays.
c> @param NSPACE       is the number ORMAS groups.
c> @param LIMLOW array contains the lower basis function on an atom.
c> @param LIMSUP array contains the upper basis function on an atom.
c> @param NAT is the number of atoms.
c> @param IATMSTA      is an array that defines sets of atoms and
c>                     orbitals to localized based on natmor input.
c> @param IATMSTA2     is for catching bugs across to local_ppasvd.
C> @param KEEPER       is a logical that equals true when
C>                     cistep=ormas and nspace>1 and ormful=false.
C> @param EIGSAV       saves the SVD evalues from ALL SVDs.
C>                     For each atom, an SVD is done.
C> @param VTVECSAV     temporarily saves orbital transformations
C>                     for ALL SVDs from which transform elements
C>                     are selected.
C> @param ISVMOR       is ISVMOR from ORNTMO common block.
C> @param KEEPER_ISVMOR   is true if the user input the number of orbitals
C>                        desired on each atom.
C>                        If false, we let the SVD figure out
C>                        atom-orbital assignments.
C> @param SVDEXTORBSNUM   is a logical that allows for a special selection
C>                     orbitals on each atom not based on SVD evalues.
C>                     It is only for nspace=2 right now.
C> @param SVMBS        is an array that holds the overlap to the true AOs
C>                     from the VVOS run.
C>                     This overlap has a dimension of L1xL0MBS.
C> @param L0MBS        is the dimension of the minimal basis set number of
C>                     orbitals.  L0MBS is derived from NCORTOT+LOCAL_NUMVAL.
C> @param SVDAOS       is a toggle option for orthogonalizing the input AOs.
C> @param SVDPRJ       is the new AO-MO projection option.
C> @param IPOSMBS      denotes the integer array that holds the starting
C>                     position for the 1st MBS AO on a given atom.
C>                     These are in atomic order from the input
C>                     as usual.
C>                     I emphasize the CORE+VALENCE part.
C> @param ILENMBS      gives the length of the VALENCE MBS number of orbitals
C>                     on each atom.  I emphasize the VALENCE + MBS part.
C> @param SVDMBSNUM    is an option for ORMAS to obtain the MBS orbitals
C>                     on each atom when the total orbital number equals
C>                     the total number of atomic valence orbitals.
C>                     i.e. NACT makes sense in the above context.
C>                     This option requires the input of the NATMOR array.
C>                     If the canonical orbitals are blurry, that is OK.
C>                     Only the atomic orbital totals must be identified
C>                     between the ORMAS groups.
C> @param SVD_INVAR    is a possible trial for invariant option.
C> @param SVD_INVAR2   is a possible trial for invariant option.
C> @param SVD_INVAR3   is a possible trial for invariant option.
C> @param SVD_AOSCF    is an option to use the AOs from VVOS
C>                     with high basis set quality.
C> @param SCFTYP       is the scftyp from common.
C> @param ISPHER       indicates treatment of basis functions
C>                     in terms of spherical or Cartesians.
C> @param KTYPE        is 1,2,3,4,5,6,7 for S,P,D,F,G,H,I.
C>                     L and P require more to be distinguished.
C>                     See 'documentation' in inputa.src for more info.
C> @param KATOM        indicates which atom the give shell
C>                     is centered on.
C> @param KMIN         contains the starting indices of the shells.
C> @param KMAX         contains the ending   indices of the shells.
C> @param NSHELL       is the total number of shells.
C>                     e.g. f is a shell.
C> @param WSPHER       will hold the atomic Cartesian-to-Spherical
C>                     transformation matrix.
C>                     It is not normalized at the start.
C> @param NATMOR       is array for atom-orbital correspondence.
C> @param MASWRK       indicates the master process.
C> @param SOME   is true for master process with nprint not equal -5.
C>
      SUBROUTINE LOCAL_PPASVD(
     *     NCORTOT,IORBF1,S2,
     *     S,UVEC,EIG,VTVEC,
     *     WRKSVD,IWRK,
     *     VOLD,VTMP,VSAV,
     *     SV,SAOMO,
     *     ISIZSVD,NACT,L0,L1,L2,L3,
     *     MSTA,ISIZE_FCCWFN,NSPACE,
     *     LIMLOW,LIMSUP,NAT,IATMSTA,IATMSTA2,KEEPER,
     *     EIGSAV,VTVECSAV,ISVMOR,
     *     IPOSMBS,ILENMBS,SVMBS,L0MBS,
     *     KEEPER_ISVMOR,SVDEXTORBSNUM,SVDAOS,
     *     SVDPRJ,SVDMBSNUM,SVD_INVAR,SVD_INVAR2,SVD_INVAR3,
     *     SVD_AOSCF,SCFTYP,
     *     ISPHER,KTYPE,KATOM,KMIN,KMAX,NSHELL,WSPHER,
     *     NATMOR,MASWRK,SOME)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL SOME,MASWRK,KEEPER,KEEPER_ISVMOR,SVDEXTORBSNUM,SVDAOS,
     *        SVDPRJ,SVDMBSNUM,SVD_INVAR,SVD_INVAR2,SVD_INVAR3,
     *        SVD_AOSCF,COMBO,COMBO2
      INTEGER MXATM
      PARAMETER (MXATM=2000)
      DOUBLE PRECISION :: ONE,TOL,TOL2,TMP,TMP2,
     *                    SCFTYP,RHF,RMC
      PARAMETER (ONE=1.0D+00)
      PARAMETER (TOL=1.0D-06, TOL2=1.0D-08)
      INTEGER NAT,LIMLOW(MXATM),LIMSUP(MXATM)
      INTEGER ICOUNT,L,K,I,IATM1,IBAS1,IBAS2,IHACT,
     *        ILTH,ILTH_FIX,ILTH_SAV,ILTH_FIX_SAV,ILTH2,
     *        IORBF1,ISIZSVD,J,JHACT,L0,L0MBS,L1,L2,L3,
     *        NACT,NCORTOT,NUMVAL1,IJ,IJ2,II,JJ,
     *        IERR0,IERR2,IERR3,IERR4,IERR5,IERR6,IERR7,IERR8,IERR9,
     *        IERR10,IERR11
      INTEGER IPOS,IPOSMBS(NAT+1),ILENMBS(NAT)
      INTEGER LOCAL_NUMVAL
      INTEGER IDAMAX,IXAMAX
      INTEGER ICOL1,IROW,JORB1,JORB2,IDUM,ITMP,ITMP2,III,JJJ
      INTEGER NSPACE_LIMIT,NSPACE,ISPACE,NACTFIN,ISIZE_FCCWFN
      INTEGER ISWMBS,NAOCART,NAOSPH
C---------SPHERICAL HARMONIC STUFF---------------------
      LOGICAL IGNORE_SPHER
      INTEGER ISPHER,NSHELL
      INTEGER KTYPE(NSHELL),KATOM(NSHELL),KMIN(NSHELL),KMAX(NSHELL)
      DOUBLE PRECISION :: WSPHER(L1,L1)
C------------------------------------------------------
C     NEW CODING STANDARDS VARS
      INTEGER IDAF,INFO,IODA,IP,IPK,IR,IS,IW,NAV
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C-----------------------------------------------------------------------
      DOUBLE PRECISION ::
     *       S2(L2),S(L2),
     *       WRKSVD(ISIZSVD),
     *       UVEC(L1,L1),EIG(L1),VTVEC(L0,L0),
     *       VOLD(L1,L1),VTMP(L1,L1),VSAV(L1,L1),
     *       SV(L1,L1),SAOMO(L1,L1),SVMBS(L1,L0MBS)
      DOUBLE PRECISION ::
     *       EIGSAV(NAT*NACT,NSPACE),VTVECSAV(NACT,NACT,NAT*NSPACE)
      INTEGER NATMOR(L0),IWRK(L2),ISVMOR(NAT),
     *        IATMSTA2(NSPACE,NAT),IATMSTA(NSPACE,NAT),
     *        MSTA(ISIZE_FCCWFN)
C
C     DEFINE SOME DATA STUFF
      DATA RMC/8HMCSCF   /
      DATA RHF/8HRHF     /
C
C     INITIALIZE ALL POSSIBLE IERR VARS.
      IERR0=0
      IERR2=0
      IERR3=0
      IERR4=0
      IERR5=0
      IERR6=0
      IERR7=0
      IERR8=0
      IERR9=0
      IERR10=0
      IERR11=0
C
C     CLEAR OUT THE VTVECSAV VAR.
C     THIS ACTION EASILY SHOWS US ANY ISSUES
C     BY PREVENTING GARBAGE FROM GOING INTO
C     THE SYM. ORTHOGS, WHICH THEN ERROR OUT.
      CALL VCLR(VTVECSAV,1,NACT*NACT*NAT*NSPACE)
      CALL VCLR(EIGSAV,1,NAT*NACT*NSPACE)
C
C     SETUP NSPACE_LIMIT BASED ON KEEPER.
C     NSPACE_LIMIT CAN BE 1 WHEN NSPACE>1.  THIS IS THE POINT OF NSPACE_LIMIT.
      IF(KEEPER) THEN
        NSPACE_LIMIT=NSPACE
      ELSE
        NSPACE_LIMIT=1
      ENDIF
C
C     SETUP THE IPOSMBS AND ILENMBS ARRAYS
      CALL LOCAL_VVOS_ORB_RANGE(IPOSMBS,ILENMBS,NAT)
C
C------------------------------------------------------------
C------------------------------------------------------------
C
C     A FEW LAST CHECKS JUST TO BE SURE.
C     NOTE:  THIS NEXT CHECK IS IMPORTANT.  PLEASE KEEP IT.
      IF(KEEPER) THEN
        IF(MASWRK) WRITE(IW,9000)
        IERR0=0
        DO I=1,NSPACE_LIMIT
          DO J=1,NAT
            ITMP=IATMSTA2(I,J)
            IF(ITMP.NE.0.AND.ITMP.NE.1) IERR0=IERR0+1
          ENDDO
        ENDDO
        IF(IERR0.GT.0) GO TO 8999
      ENDIF
C
C     ALLRIGHT.  LAST CHECKS DONE.
C     FIRST CHECK HAS A GOOD CHANCE OF FINDING ANY FUTURE MEMORY ISSUES.
C------------------------------------------------------------
C------------------------------------------------------------
C
C     RE-DEFINE IATMSTA2 ARRAY.
C     IATMSTA2 = STARTING ORBITAL ON PARTICULAR ATOM.
C     IATMSTA  = ALREADY CONTAINS NUMBER OF SVD ORBITALS TO EXTRACT.
C                ...NOT THE SIZE OF THE SVD MATRIX...
      IF(KEEPER) THEN
        CALL VICLR(IATMSTA2,1,NSPACE*NAT)
        DO I=1,NSPACE_LIMIT
          JHACT=MSTA(I)
          DO J=1,NAT
            IF(IATMSTA(I,J).NE.0) THEN
              IATMSTA2(I,J)=JHACT
              JHACT=JHACT+IATMSTA(I,J)
            ENDIF
          ENDDO
        ENDDO
      ENDIF
C------------------------------------------------------------
C     CONTINUE WITH CHUNKS OF ORIGINALLY INTENDED ROUTINE...
C------------------------------------------------------------
C
C
C     READ IN THE DESIRED ORBITALS.
      CALL DAREAD(IDAF,IODA,VOLD,L3,IORBF1,0)
C
C     SV=S*V=AO BASIS OVERLAP*AO COEFFS WITH INNER CONTRACTION OVER ALL ATOMS.
C     GET AND SAVE SV FOR ALL ATOMS
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL MTARBR(S,L1,VOLD,L0,SV,L1,1)
C
C     LOOP OVER ALL ATOMS
C     NOTE:  SEPARATE CASES WITH 1 DIM.
      DO 100 IATM1=1,NAT
C
C       SET UP BASIS DIMENSIONS AND OVERLAP.
C       --FORM SYM ARRAY
C       --COPY OUT TO POS 1--> 'L2'
C       --SEND OFF TO LOCAL_ATOMIC_SPH_HARM
C         FOR ISPHER>0 CASES.
C       --GLDIAG CALL
C       --SQRT AND INVERT EIG ARRAY
C       --MAKE TRANSPOSE OF EVECTORS
C       --SCALE ORIG. MATRIX
C       --PERFORM NEEDED MATVEC TO INVERSE
        CALL LOCAL_GRAB_BASIS_FXNS_ON_ATOM(
     *       LIMLOW,LIMSUP,IATM1,NAT,L2,
     *       S2,S,
     *       IBAS1,IBAS2,ILTH)
        ILTH_SAV=ILTH
C
C       CHECK THAT AO LENGTHS FROM LOCAL_COUNTAOS MATCH.
        ITMP=IATM1
        CALL LOCAL_COUNTAOS(ITMP,NAOCART,NAOSPH)
        IERR10=0
        IF(NAOCART.NE.ILTH) IERR10=1
        IF(IERR10.GT.0) GO TO 8999
C
C-------------BEGIN: DEAL WITH SPHERICAL ISSUES1-------------------
        IGNORE_SPHER=.FALSE.
ccccccccc
C       NEXT OPTION DOES NOT NEED ILTH_FIX STUFF.
        IF(SVDPRJ) IGNORE_SPHER=.TRUE.
C       NEXT OPTION NEEDS EXTRA WORK FOR ILTH_FIX STUFF.
        IF(SVD_INVAR3) IGNORE_SPHER=.TRUE.
C       NEXT OPTION NEEDS EXTRA WORK FOR ILTH_FIX STUFF
C       IF EVEN POSSIBLE...
        IF(SVDAOS) IGNORE_SPHER=.TRUE.
ccccccccc
C       INITIALIZE ILTH_FIX.
        ILTH_FIX=ILTH
        IF(ISPHER.GT.0.AND..NOT.IGNORE_SPHER) THEN
          ITMP=ILTH
          CALL LOCAL_ATOMIC_SPH_HARM(
     *         1,S2,ITMP,ILTH_FIX,IATM1,
     *         KTYPE,KATOM,KMIN,KMAX,NSHELL,
     *         ISIZSVD,L1,L2,L3,WSPHER,UVEC,VTMP,S,
     *         WRKSVD,EIG,SAOMO,IWRK,TOL,
     *         SOME,MASWRK,IW)
C         S WAS DESTROYED.
C         SO, READ BACK IN THE TRUE AO OVERLAP.
          CALL DAREAD(IDAF,IODA,S,L2,12,0)
          ILTH_FIX_SAV=ILTH_FIX
C-------------END: DEAL WITH SPHERICAL ISSUES1---------------------
        ELSE
          ILTH_FIX=ILTH
          ILTH_FIX_SAV=ILTH
C         PROCEED TO DIAGONALIZE.
          IERR2=0
          CALL VCLR(VTMP,1,L3)
          CALL GLDIAG(L1,ILTH_FIX,ILTH_FIX,S2,
     *                WRKSVD,EIG,VTMP,IERR2,IWRK)
          IF(IERR2.GT.0) GO TO 8999
          IERR3=0
          DO I=1,ILTH_FIX
            IF(EIG(I).LT.TOL) IERR3=IERR3+1
            IF(.NOT.SVDPRJ) THEN
              EIG(I)=ONE/SQRT(EIG(I))
            ELSE
              EIG(I)=ONE/EIG(I)
            ENDIF
C           WRITE(IW,*) "IATM1,I,EIG=",IATM1,I,EIG(I)
          ENDDO
          IF(IERR3.GT.0) GO TO 8999
          CALL VCLR(UVEC,1,L3)
          DO I=1,ILTH_FIX
            DO J=1,ILTH_FIX
              UVEC(I,J)=VTMP(J,I)
              UVEC(J,I)=VTMP(I,J)
            ENDDO
          ENDDO
          DO I=1,ILTH_FIX
            CALL DSCAL(ILTH_FIX,EIG(I),VTMP(1,I),1)
          ENDDO
C         DO MATVEC TO S_IATM1**(-1/2)
          CALL VCLR(SAOMO,1,L3)
          CALL MRARBR(VTMP,L1,ILTH_FIX,ILTH_FIX,
     *                UVEC,L1,ILTH_FIX,
     *                SAOMO,L1)
          CALL DCOPY(L3,SAOMO,1,VTMP,1)
        ENDIF
C-------------END: ELSE FROM DEAL WITH SPHERICAL ISSUES1---------------------
C
C
C       *****************************************************
C       *****************************************************
C       FOR EACH ROUND OF 100 LOOP, VTMP CANNOT BE DISTURBED.
C       NOTES:
C       VTMP=S**(-1/2) ON ATOM IATM1.
C       FOR SPHERICALS...
C       VTMP=[W*S**(-1/2)]-TRANS
C       VTMP HAS DIMENSION OF (ILTH_FIX,ILTH) AS NEEDED FOR
C       THE SVDS BELOW.  THIS PIECE IS CORRECT.
C       *****************************************************
C       *****************************************************
C
C------------------------------------------------------------
C       INITIALIZE NSPACE FOR ALDET TO AVOID COMPLAINTS
C       NOTE: EVEN THOUGH THE DIM WAS ALREADY DEFINED TO BE 1.
C       THE ORMAS LOOP
        DO 90 ISPACE=1,NSPACE_LIMIT
C         NO KEEPER LINE HERE BECAUSE WE WANT TO LOOK (NOT USE)
C         ALL POSSIBLE SVD VALUES.
C------------------------------------------------------------
C         DEFINE NACTFIN
C         DEFINE ITEMS NEEDED FOR UVEC COPY
C         RESET ILTH HERE FOR FIRST PART OF THE LOOP.
          IF(KEEPER) THEN
            NACTFIN=MSTA(ISPACE+1)-MSTA(ISPACE)
            JORB1=MSTA(ISPACE)
            JORB2=MSTA(ISPACE+1)-1
          ELSE
            NACTFIN=NACT
            JORB1=NCORTOT+1
            JORB2=NCORTOT+NACT
          ENDIF
          ILTH=ILTH_SAV
          ILTH_FIX=ILTH_FIX_SAV
C
C---------------------------------------------------------------
C         FINISH FORMING THE SAOMO OVERLAP MATRIX.
C---------------------------------------------------------------
          CALL VCLR(SAOMO,1,L3)
          CALL VCLR(UVEC,1,L3)
          IF(SVDAOS) THEN
            III=1
            DO JJJ=JORB1,JORB2
              CALL DCOPY(ILTH,SV(IBAS1,JJJ),1,SAOMO(1,III),1)
              III=III+1
            ENDDO
          ELSEIF(SVDPRJ) THEN
C           ABOVE, S^(-1) RATHER THAN S^(-1/2) WAS CONSTRUCTED.
C
C           MAKE P = (SV)-TRANS * S^(-1) * SV... BUT STARTING AT IBAS1.
            CALL MRTRBR(SV(IBAS1,JORB1),L1,
     *                  ILTH,NACTFIN,VTMP,L1,ILTH,UVEC,L1)
            CALL VCLR(SAOMO,1,L3)
            CALL MRARBR(UVEC,L1,NACTFIN,ILTH,
     *                  SV(IBAS1,JORB1),L1,NACTFIN,SAOMO,L1)
C
C           NOTE:  THE USE OF ILTH_SAV ABOVE.
            ILTH=NACTFIN
            ILTH_FIX=NACTFIN
C
C           NOTES:
C           THIS PART WINDS UP EQUIVALENT TO USING ORTHO. AOS.
C           THE SVD CALL BELOW IS JUST LIKE A GLDIAG CALL, WHICH MAKES SENSE.
C           I ALSO CHECKED IT WITH GLDIAG FOR WHATEVER REASON.
          ELSEIF(SVD_INVAR) THEN
C           MAKE P_INVAR = (V)-TRANS * SV
            CALL MRTRBR(VOLD(IBAS1,JORB1),L1,ILTH,NACTFIN,
     *                    SV(IBAS1,JORB1),L1,NACTFIN,SAOMO,L1)
C
C           NOTE:  THE USE OF ILTH_SAV ABOVE.
            ILTH=NACTFIN
            ILTH_FIX=NACTFIN
          ELSEIF(SVD_INVAR2) THEN
            CALL DCOPY(L3,VOLD,1,UVEC,1)
            DO I=IBAS1,IBAS2
              DO J=JORB1,JORB2
                UVEC(I,J)=0.0D+00
              ENDDO
            ENDDO
            CALL MRTRBR(UVEC(1,JORB1),L1,L1,NACTFIN,
     *                    SV(1,JORB1),L1,NACTFIN,SAOMO,L1)
C
C           NOTE:  THE USE OF ILTH_SAV ABOVE.
            ILTH=NACTFIN
          ELSEIF(SVD_INVAR3) THEN
C           NOTES:
C           1.  IT IS OK TO USE VSAV RIGHT NOW.
C               LATER ON, WE CANNOT USE ONCE WE HAVE
C                         READ THE CORE PART OFF OF FILE.
C           2.  I AM AGRESSIVE WITH THE VCLRS TO PREVENT
C               GARBAGE ARRAYS FROM GETTING AN SVD
C               THAT LEAD TO GARABAGE RESULTS.
C           3.  FOR CASSCF, THIS WILL ALL BE FINE.
C               FOR ORMAS, THE USER WILL PROBABLY HAVE TO ENTER
C                          IN NATMOR ARRAY SINCE THE SORTING
C                          ALGORITHM FOR THE 2ND SVD
C                          USES MAX VALUES.
C                          EASIER TO INPUT THE TOTAL NUMBERS
C                          OF ORBITALS IN A GIVEN SPACE THEN.
C
C           ORTHOGONALIZE THE SQUARE AO OVERLAP MATRIX
C           ON ALL ATOMS OTHER THAN ATOM IATM1.
C           NOTE:  ILTH2 GIVES THE LENGTH OF THE SQUARE.
            CALL VCLR(S2,1,L2)
            IJ2=1
            ILTH2=0
            DO 557 I=1,L1
              IF(I.GE.IBAS1.AND.I.LE.IBAS2) GO TO 557
              ILTH2=ILTH2+1
              DO 556 J=1,I
                IF(J.GE.IBAS1.AND.J.LE.IBAS2) GO TO 556
                ITMP =MAX(I,J)
                ITMP2=MIN(I,J)
                IJ=(ITMP*ITMP-ITMP)/2 + ITMP2
                S2(IJ2)=S(IJ)
                IJ2=IJ2+1
  556         CONTINUE
  557       CONTINUE
            IERR2=0
            CALL VCLR(UVEC,1,L3)
            CALL GLDIAG(L1,ILTH2,ILTH2,S2,
     *                  WRKSVD,EIG,UVEC,IERR2,IWRK)
            IF(IERR2.GT.0) GO TO 8999
            IERR3=0
            DO I=1,ILTH2
              IF(EIG(I).LT.TOL) IERR3=IERR3+1
              EIG(I)=ONE/SQRT(EIG(I))
            ENDDO
            IF(IERR3.GT.0) GO TO 8999
            CALL VCLR(VSAV,1,L3)
            DO I=1,ILTH2
              DO J=1,ILTH2
                VSAV(I,J)=UVEC(J,I)
                VSAV(J,I)=UVEC(I,J)
              ENDDO
            ENDDO
            DO I=1,ILTH2
              CALL DSCAL(ILTH2,EIG(I),UVEC(1,I),1)
            ENDDO
C           DO MATVEC TO S_IATM1**(-1/2)
            CALL VCLR(SAOMO,1,L3)
            CALL MRARBR(UVEC,L1,ILTH2,ILTH2,
     *                  VSAV,L1,ILTH2,SAOMO,L1)
            CALL DCOPY(L3,SAOMO,1,UVEC,1)
            CALL VCLR(SAOMO,1,L3)
C
C           COPY OUT THE RECTANGULAR PIECE OF THE AO OVERLAP
C           WITH ATOM IATM1 AND ALL OTHER ATOMS.
            CALL VCLR(VSAV,1,L3)
            II=0
            DO I=IBAS1,IBAS2
              II=II+1
              JJ=0
              DO 555 J=1,L1
                IF(J.GE.IBAS1.AND.J.LE.IBAS2) GO TO 555
                JJ=JJ+1
                ITMP =MAX(I,J)
                ITMP2=MIN(I,J)
                IJ=(ITMP*ITMP-ITMP)/2 + ITMP2
                VSAV(II,JJ)=S(IJ)
  555         CONTINUE
            ENDDO
C
C           CHECK THAT DIMENSIONS WORK OUT.
            IERR8=0
            JJ=L1-ILTH
            IF(JJ.NE.ILTH2) IERR8=1
            IF(IERR8.GT.0) GO TO 8999
            IERR8=0
            IF(II.NE.ILTH) IERR8=1
            IF(IERR8.GT.0) GO TO 8999
C
C           APPLY THE 2 ORTHOG. MATRICES TO THE
C           RECTANGULAR OVERLAP MATRIX.
C           I.E. FORM VTMP * VSAV * UVEC
C                (ILTH,ILTH)*(ILTH,ILTH2)*(ILTH2,ILTH2)
            CALL VCLR(SAOMO,1,L3)
            CALL MRARBR(VTMP,L1,ILTH,ILTH,
     *                  VSAV,L1,ILTH2,SAOMO,L1)
            CALL DCOPY(L3,SAOMO,1,VSAV,1)
            CALL VCLR(SAOMO,1,L3)
            CALL MRARBR(VSAV,L1,ILTH,ILTH2,
     *                  UVEC,L1,ILTH2,SAOMO,L1)
C
C           PERFORM SVD ON THE RECTANGULAR AO OVERLAP.
            CALL VCLR(UVEC,1,L3)
            CALL VCLR(VSAV,1,L3)
            CALL VCLR(EIG,1,L1)
            CALL DGESVD('A','A',
     *                  ILTH,ILTH2,SAOMO,L1,EIG,
     *                  VSAV,L1,UVEC,L1,
     *                  WRKSVD,ISIZSVD,INFO)
            CALL VCLR(SAOMO,1,L3)
            CALL VCLR(UVEC,1,L3)
C
C           COPY IN THE SV MATRIX FOR THE WAVEFXN MOS.
            III=1
            DO JJJ=JORB1,JORB2
              CALL DCOPY(ILTH,SV(IBAS1,JJJ),1,UVEC(1,III),1)
              III=III+1
            ENDDO
cccccccc            CALL MRARBR(VSAV,L1,ILTH,ILTH,
cccccccc     *                  UVEC,L1,NACTFIN,SAOMO,L1)
C-----------NEXT SECTION DRAWS OUT THE AOS WITH MIN. OVERLAP------
C
C           REORDER IF ONE WANTS THE MINIMUM VECTORS.
C           I.E. WANT ATOM IATM1 ORBITALS WITH THE LEAST AMOUNT
C                OF AO OVERLAP TO ORBITALS ON ALL OTHER ATOMS.
            II=1
            DO I=ILTH,1,-1
              IWRK(II)=I
              II=II+1
            ENDDO
            CALL REORDR(VSAV,IWRK,ILTH,L1)
C
C           WANT ONLY THE VALENCE MBS NUMBER OF ORBITALS.
            ISWMBS=1
            ITMP=LOCAL_NUMVAL(IATM1,ISWMBS)
            CALL MRTRBR(VSAV,L1,ILTH,ITMP,
     *                  UVEC,L1,NACTFIN,SAOMO,L1)
C
C           NOTES:
C           THE USE OF ILTH_SAV ABOVE.
C           SO, WE MIMIC AS IF WE HAD 4 VAL ORBS FOR CARBON.
            ILTH=ITMP
            ILTH_FIX=ITMP
C-----------END OF NEXT SECTION -----------------------------------
          ELSEIF(SVD_AOSCF) THEN
            COMBO =NACT.EQ.L0-NCORTOT
            COMBO2=NACT.EQ.L0MBS-NCORTOT
            IF(COMBO.AND.ISPACE.EQ.1.OR.COMBO2) THEN
              IF(MASWRK.AND.IATM1.EQ.1) WRITE(IW,9038) ISPACE
C
C             E.G. FOR CARBON... FORM (4,L1)*(L1,NACTFIN) MATRIX.
C             THE INNER CONTRACTION IS NOW ACROSS ALL AO FXNS.
C             EARLIER, WE STOLE OUT S_BAS1*S_BAS2*V OF THE ATOMIC MOS
C                      FROM THE VVOS RUN INTO DAF FILE 533.
C             IN THIS EXAMPLE, OUR NULL SPACE IS NACTFIN-4.
C             SO, WE SHOULD SEE ONLY 4 NON-ZERO EIGENVALUES...
C
              IPOS=IPOSMBS(IATM1)
              ITMP=ILENMBS(IATM1)
              CALL MRTRBR(SVMBS(1,IPOS),L1,L1,ITMP,
     *                    VOLD(1,JORB1),L1,NACTFIN,SAOMO,L1)
C             NOTE:  THE USE OF ILTH_SAV ABOVE.
              ILTH=ITMP
              ILTH_FIX=ITMP
            ELSEIF(COMBO.AND.ISPACE.EQ.2) THEN
              IF(MASWRK.AND.IATM1.EQ.1) WRITE(IW,9039) ISPACE
              III=1
              DO JJJ=JORB1,JORB2
                CALL DCOPY(ILTH,SV(IBAS1,JJJ),1,UVEC(1,III),1)
                III=III+1
              ENDDO
              CALL MRARBR(VTMP,L1,ILTH_FIX,ILTH,
     *                    UVEC,L1,NACTFIN,SAOMO,L1)
            ELSE
              IF(MASWRK) WRITE(IW,9040)
              CALL FLSHBF(IW)
              CALL ABRT
              STOP
            ENDIF
C
          ELSE
C           PROCEED WITH SVD WITH ORTHOG. AOS.
            III=1
            DO JJJ=JORB1,JORB2
              CALL DCOPY(ILTH,SV(IBAS1,JJJ),1,UVEC(1,III),1)
              III=III+1
            ENDDO
            CALL MRARBR(VTMP,L1,ILTH_FIX,ILTH,UVEC,L1,NACTFIN,SAOMO,L1)
          ENDIF
C---------------------------------------------------------------
C         END OF FINISH FORMING THE SAOMO OVERLAP MATRIX.
C---------------------------------------------------------------
C
C         PERFORM SVD FOR IATM1
          CALL VCLR(UVEC,1,L3)
          CALL VCLR(VTVEC,1,L0*L0)
          CALL VCLR(EIG,1,L1)
          CALL DGESVD('A','A',
     *                ILTH_FIX,NACTFIN,SAOMO,L1,EIG,
     *                UVEC,L1,VTVEC,L0,
     *                WRKSVD,ISIZSVD,INFO)
C
C         PRINT EVALUES FOR EACH SVD.
C         NOTE:  FOR SVDEXTORBSNUM OPTION, THIS PIECE WILL BE MEANINGLESS
C                FOR THE TOP-MOST EVALUES.
          IF(MASWRK) THEN
            IF(ISPACE.EQ.1) WRITE(IW,9045) IATM1
            DO I=1,NACTFIN
              WRITE(IW,9050) ISPACE,I,EIG(I)
            ENDDO
          ENDIF
C-------------------------------------------------------------
C
C         FORM (NACTFIN,NACTFIN) VTVEC-TRANS MATRIX
C         EVEN IF ILTH<NACTFIN.
          CALL TRPOSQ(VTVEC,L0)
          IF(SVD_INVAR2) THEN
C           --REORDER EIG AND VTVEC ARRAYS FOR THIS OPTION.
            II=1
            DO I=NACTFIN,1,-1
              IWRK(II)=I
              II=II+1
            ENDDO
            CALL REORDR(VTVEC,IWRK,NACTFIN,L0)
            II=1
            DO I=NACTFIN,1,-1
              IWRK(II)=I
              II=II+1
            ENDDO
            CALL REORDR(EIG,IWRK,NACTFIN,1)
C           --WANT THE SMALLEST ELEMENTS HERE, BUT USE MAX BELOW.
C           --USE TOL TO GET RID OF TRUE ZEROS.
C           --THEN, INVERT THE NUMBERS TO KEEP THE MAX STATEMENT BELOW.
            DO I=1,NACTFIN
              EIG(I)=1.0D+00/EIG(I)
            ENDDO
          ENDIF
C-------------------------------------------------------------
C
C         SAVE COLLECTIVE EVALUES AND ORBITAL TRANSFORMS (TEMPORARILY)
C         NOTE:  THE NEXT VCLR IS NOT FOR SHOW FOR ORMAS.
          IF(IATM1.EQ.1.AND.ISPACE.EQ.1) THEN
            IF(.NOT.SVD_INVAR2) THEN
              CALL VCLR(EIGSAV,1,NACT*NAT*NSPACE)
            ELSE
              DO II=1,NAT*NACT
              DO JJ=1,NSPACE
                 EIGSAV(II,JJ)=1.0D+00
              ENDDO
              ENDDO
            ENDIF
          ENDIF
          DO I=1,NACTFIN
            ITMP=(IATM1-1)*NACT + I
            EIGSAV(ITMP,ISPACE)=EIG(I)
          ENDDO
          ITMP = (IATM1-1)*NSPACE_LIMIT + ISPACE
          DO I=1,NACTFIN
            CALL DCOPY(NACTFIN,VTVEC(1,I),1,
     *                         VTVECSAV(1,I,ITMP),1)
          ENDDO
C------------------------------------------------------------
C
C       END LOOP OVER ORMAS GROUPS
   90   CONTINUE
C------------------------------------------------------------
C
C     END LOOP OVER ALL ATOMS
  100 CONTINUE


C
C
C------------------------------------------------------------
C     OBTAIN POSITIONS OF THE MAXIMUM SVD VALUES
C     AMONG ALL ATOMS.... THAT IS THE KEY PART.
C     ---RESET IATMSTA AND IATMSTA2 ARRAYS.
C     ---IF KEEPER_ISVMOR, THEN KEEP USER INPUTS.
C     ---IF SVDEXTORBSNUM, THEN DO NOT DESTROY THE EIGSAV ARRAY.
C------------------------------------------------------------
C
C
      COMBO=KEEPER_ISVMOR
     *      .AND..NOT.SVDEXTORBSNUM
C     THE NEXT LINE FORCES US TO USE IATMSTA AND IATMSTA2
C     BASED ON THE USER INPUT FOR SURE.
      COMBO=COMBO.OR.SVDMBSNUM
      IF(COMBO) GO TO 199
      IF(SVDEXTORBSNUM) GO TO 150
C
C
C--------------------
C--------------------
C--------------------
C--------------------
      IF(KEEPER) CALL VICLR(IATMSTA,1,NSPACE*NAT)
      IERR11=0
      DO ISPACE=NSPACE_LIMIT,1,-1
        IF(KEEPER) THEN
          NACTFIN=MSTA(ISPACE+1)-MSTA(ISPACE)
        ELSE
          NACTFIN=NACT
        ENDIF
        DO I=1,NACTFIN
           IDUM=IDAMAX(NAT*NACT,EIGSAV(1,ISPACE),1)
           IF(EIGSAV(IDUM,ISPACE).LT.0.0D+00) IERR11=IERR11+1
           EIGSAV(IDUM,ISPACE)=0.0D+00
                 DO IATM1=1,NAT
                 DO J=1,NACTFIN
                    ITMP=(IATM1-1)*NACT + J
                    IF(ITMP.EQ.IDUM) THEN
                       IF(KEEPER) THEN
                         IATMSTA(ISPACE,IATM1)
     *                   =IATMSTA(ISPACE,IATM1)+1
                       ENDIF
                       ISVMOR(IATM1)=ISVMOR(IATM1)+1
                    ENDIF
                 ENDDO
                 ENDDO
        ENDDO
      ENDDO
      IF(IERR11.NE.0) GO TO 8999
C--------------------
C--------------------
C--------------------
C--------------------
C
C     TAKE CARE OF SPECIAL CASE WHERE SVDEXTORBSNUM IS TRUE.
C     PLEASE SEE THE VARIOUS RESTRICTIONS IN LOCAL_PPAERR.
  150 CONTINUE
      IF(SVDEXTORBSNUM) THEN
        CALL VICLR(NATMOR,1,L0)
        CALL LOCAL_SVDEXTORBSNUM_CASE(
     *       NACT,L0,NSPACE,NAT,
     *       NATMOR,IATMSTA,ISVMOR,EIGSAV,VTVECSAV,
     *       MASWRK,IW)
      ENDIF

C
C     RE-DEFINE SOME ORMAS ITEMS HERE IF WE DID NOT SKIP THIS SECTION.
      IF(KEEPER) THEN
C       RE-DEFINE IATMSTA2 ARRAY.
        CALL VICLR(IATMSTA2,1,NSPACE*NAT)
        DO I=1,NSPACE_LIMIT
          JHACT=MSTA(I)
          DO J=1,NAT
            IF(IATMSTA(I,J).NE.0) THEN
              IATMSTA2(I,J)=JHACT
              JHACT=JHACT+IATMSTA(I,J)
            ENDIF
          ENDDO
        ENDDO
C       RE-DEFINE NATMOR ARRAY.
        DO I=1,NSPACE_LIMIT
          ICOUNT=0
          DO J=1,NAT
            K=MSTA(I)+ICOUNT
            DO L=K,K+IATMSTA(I,J)
                NATMOR(L)=J
            ENDDO
            ICOUNT=ICOUNT+IATMSTA(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     PRINT OFF NEW ORBITAL NUMBERS ON EACH ATOM.
      IF(MASWRK) THEN
        WRITE(IW,9054)
        IF(SVDEXTORBSNUM) WRITE(IW,9055)
        DO IATM1=1,NAT
          WRITE(IW,9056) IATM1,ISVMOR(IATM1)
        ENDDO
      ENDIF
C------------------------------------------------------------
C------------------------------------------------------------
C     NICE ERROR CHECKING SECTION.
C------------------------------------------------------------
C------------------------------------------------------------
C
C     RECHECK THAT ISVMOR HAS NACT LENGTH.
  199 CONTINUE
      ITMP=0
      DO I=1,NAT
        ITMP = ITMP + ISVMOR(I)
      ENDDO
      IERR5=0
      IF(ITMP.NE.NACT) IERR5=1
      IF(IERR5.GT.0) GO TO 8999
C
C     RECHECK ISVMOR THROUGH LOCAL_NUMVAL INTEGER FUNCTION.
      IERR9=0
      IF(SCFTYP.EQ.RMC) THEN
        ITMP=0
        DO I=1,NAT
          NUMVAL1=LOCAL_NUMVAL(I,0)
          ITMP=ITMP+NUMVAL1
        ENDDO
        IERR5=0
        IF(ITMP.NE.NACT) IERR5=1
        IF(IERR5.GT.0) GO TO 8999
      ELSEIF(SCFTYP.EQ.RHF) THEN
C       NO CHECK HERE.
C       IF CHECK IS DESIRED, ADD NEW ARGUMENTS TO LOCAL_NUMVAL.
      ELSE
        IERR9=1
        GO TO 8999
      ENDIF
C
C     CHECK THAT ISVMOR AND NATMOR 'JIVE'.
      IF(KEEPER) THEN
        IERR6=0
        DO J=1,NAT
          ITMP=0
          DO I=NCORTOT+1,NCORTOT+NACT
            IF(NATMOR(I).EQ.J) ITMP=ITMP+1
          ENDDO
          IF(ITMP.NE.ISVMOR(J)) IERR6=IERR6+1
        ENDDO
        IF(IERR6.GT.0) GO TO 8999
      ENDIF
C
C     CHECK THAT ALL ENTRIES IN ISVMOR ARE GREATER THAN 0.
      IERR7=0
      DO J=1,NAT
        IF(ISVMOR(J).LE.0) IERR7=IERR7+1
      ENDDO
      IF(IERR7.GT.0) GO TO 8999
C
C
C------------------------------------------------------------
C------------------------------------------------------------
C     END OF NICE ERROR CHECKING SECTION.
C------------------------------------------------------------
C------------------------------------------------------------
C     RE-LOOP OVER ALL ATOMS WITH THE KNOWLEDGE
C     OF THE MAXIMUM SVD VALUES.
C     NOTE:  THE ALTERNATIVE TO SAVING
C            NACT*NACT*NSPACE*NAT WORTH OF DATA
C            IS TO SIMPLY RE-DO THE SVD ONCE WE HAVE ASSIGNED
C            THE APPROPRIATE NUMBER OF ORBITALS FOR EACH ATOM.
C------------------------------------------------------------
C
C     FORM AND SAVE VNEW
C     --> (L1,NACTFIN)*(NACTFIN,NUMVAL1)
C     --> HERE WE USE ONLY THE COLUMNS WITH THE LARGEST EIGS FROM SVD.
C     --> NUMVAL1 IS THE NUMBER OF ALLOWED VALENCE ORBITALS ON A GIVEN ATOM.
C     --> GRAB OUT THE (VALENCE) NONORTHOGONAL QUASI-ATOMIC
C                                ORBITAL TRANSFORMATION.
C
C
C     READ IN THE (CORE) NONORTHOGONAL QUASI-ATOMIC ORBITAL TRANSFORMATION.
      CALL DAREAD(IDAF,IODA,VSAV,L3,523,0)

      DO 200 IATM1=1,NAT
C
C       THE ORMAS LOOP
        DO 190 ISPACE=1,NSPACE_LIMIT
          IF(KEEPER.AND.IATMSTA(ISPACE,IATM1).EQ.0) GO TO 190
C
          ITMP = (IATM1-1)*NSPACE_LIMIT + ISPACE
          IF(KEEPER) THEN
            NACTFIN=MSTA(ISPACE+1)-MSTA(ISPACE)
            NUMVAL1=IATMSTA(ISPACE,IATM1)
            DO I=1,NUMVAL1
              IROW =MSTA(ISPACE)
              ICOL1=IATMSTA2(ISPACE,IATM1)+I-1
              CALL DCOPY(NACTFIN,VTVECSAV(1,I,ITMP),1,
     *                           VSAV(IROW,ICOL1),1)
            ENDDO
          ELSE
            NACTFIN=NACT
            NUMVAL1=LOCAL_NUMVAL(IATM1,0)
            IHACT=NCORTOT
            DO I=1,IATM1-1
              IHACT=IHACT+LOCAL_NUMVAL(I,0)
            ENDDO
            NUMVAL1=LOCAL_NUMVAL(IATM1,0)
            DO I=1,NUMVAL1
              IHACT=IHACT+1
              CALL DCOPY(NACTFIN,VTVECSAV(1,I,ITMP),1,
     *                           VSAV(NCORTOT+1,IHACT),1)
            ENDDO
          ENDIF
C
  190   CONTINUE
  200 CONTINUE



C
C     AT THIS POINT, WE ARE ALL DONE WITH ATOMIC-LIKE ORBITAL
C                    REORDERING IN THIS ROUTINE.



C
C     HAVE THE NONORTHOGONAL ORBITAL TRANSFORMATION.
C     ---------ANY BLOCK DIAGONAL FORM SIMPLIFIES ALL OPERATIONS BELOW.
C     --FILL IN THE VIRTUAL SPACE.
C     --PERFORM ORMAS CHECKS ON ORBITAL TRANSFORMATION.
C     --WRITE NONORTHOG. ORBITAL TRANSFORMATION OUT TO FILE 523.
C     --GET THE NONORTHOG. ORBITALS.
C     --WRITE NONORTHOG. ORBITALS OUT TO FILE 522
      IF(KEEPER.AND.MASWRK) WRITE(IW,9060)
      DO I=NCORTOT+NACT+1,L0
        VSAV(I,I)=1.0D+00
      ENDDO
      IF(KEEPER) THEN
        IERR4=0
        DO II=1,NSPACE-1
          DO JJ=II+1,NSPACE
            DO I=MSTA(II),MSTA(II+1)-1
              DO J=MSTA(JJ),MSTA(JJ+1)-1
                TMP =ABS(VSAV(I,J))
                TMP2=ABS(VSAV(J,I))
                IF(TMP.GT.TOL2.OR.TMP2.GT.TOL2) IERR4=IERR4+1
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        IF(IERR4.GT.0) GO TO 8999
      ENDIF
      CALL DAWRIT(IDAF,IODA,VSAV,L3,523,0)
      CALL VCLR(VTMP,1,L3)
      CALL MRARBR(VOLD,L1,L1,L0,VSAV,L1,L0,VTMP,L1)
      CALL DAWRIT(IDAF,IODA,VTMP,L3,522,0)
C
C     PRINT OFF THE NONORTHOGONAL ORBITALS TO .LOG FILE NOW.
      IF(MASWRK) THEN
        WRITE(IW,9069)
        CALL PRSQL(VTMP,NCORTOT+NACT,L1,L1)
      ENDIF


C
C     ORTHOGONALIZE THE ORBITALS.
C     NOTE:  DO NOT ALTER THE CORE ORBITALS IN THIS SECTION.
C     --PUT NACT ORBITALS INTO VTMP INTO UVEC STARTING.
C     --READ IN OVERLAP S.
C     --FORM SMO OVERLAP = UVEC-TRANS*S*UVEC.
      CALL VCLR(UVEC,1,L3)
      DO I=1,NACT
        CALL DCOPY(L1,VTMP(1,NCORTOT+I),1,UVEC(1,I),1)
      ENDDO
      CALL VCLR(SV,1,L3)
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL MTARBR(S,L1,UVEC,NACT,SV,L1,1)
      CALL MRTRBR(UVEC,L1,L1,NACT,SV,L1,NACT,VTMP,L1)
C
C     FORM VTMP=[ NEW SMO**(-1/2) ] VIA SYM. ORTHOGONALIZATION.
C     HERE INITIAL VTMP=NEW MO OVERLAPS.
C     --UVEC REMAINS UNTOUCHED AS THE AO COEFFS OF THE NACT ACTIVE MOS
C     --PUT VTMP INTO SYM. FORM INTO S2
C     --TRASH VTMP AND REPLACE WITH EVECTORS.
C     --TRASH SV AND REPLACE WITH VTMP-TRANS
      CALL VCLR(S2,1,L2)
      IJ2=1
      DO I=1,NACT
        DO J=1,I
          S2(IJ2)=VTMP(I,J)
          IJ2=IJ2+1
        ENDDO
      ENDDO
      IERR2=0
      CALL VCLR(VTMP,1,L3)
      CALL GLDIAG(L1,NACT,NACT,S2,WRKSVD,EIG,VTMP,IERR2,IWRK)
      IF(IERR2.GT.0) GO TO 8999
      IERR3=0
      DO I=1,NACT
        IF(EIG(I).LT.TOL) IERR3=IERR3+1
        EIG(I)=ONE/SQRT(EIG(I))
C       WRITE(IW,*) "IATM1,I,EIG=",IATM1,I,EIG(I)
      ENDDO
      IF(IERR3.GT.0) GO TO 8999
      DO I=1,NACT
        DO J=1,NACT
          SV(I,J)=VTMP(J,I)
          SV(J,I)=VTMP(I,J)
        ENDDO
      ENDDO
      DO I=1,NACT
        CALL DSCAL(NACT,EIG(I),VTMP(1,I),1)
      ENDDO
C     DO MATVEC TO S_IATM1**(-1/2)
      CALL VCLR(SAOMO,1,L3)
      CALL MRARBR(VTMP,L1,NACT,NACT,SV,L1,NACT,SAOMO,L1)
      CALL DCOPY(L3,SAOMO,1,VTMP,1)
C
C     SAVE THE ORTHOGONAL QUASI-ATOMIC ORBITAL TRANSFORMATION NOW.
      CALL DAREAD(IDAF,IODA,SAOMO,L3,524,0)
      DO I=1,NACT
        CALL DCOPY(NACT,VTMP(1,I),1,SAOMO(NCORTOT+1,NCORTOT+I),1)
      ENDDO
      DO I=NCORTOT+NACT+1,L0
        SAOMO(I,I)=1.0D+00
      ENDDO
      CALL DAWRIT(IDAF,IODA,SAOMO,L3,524,0)
C
C     PERFORM ORMAS CHECKS ON
C     ORTHOGONAL QUASI-ATOMIC ORBITAL TRANSFORMATION.
      IF(KEEPER) THEN
        IERR4=0
        DO II=1,NSPACE-1
          DO JJ=II+1,NSPACE
            DO I=MSTA(II),MSTA(II+1)-1
              DO J=MSTA(JJ),MSTA(JJ+1)-1
                TMP =ABS(SAOMO(I,J))
                TMP2=ABS(SAOMO(J,I))
                IF(TMP.GT.TOL2.OR.TMP2.GT.TOL2) IERR4=IERR4+1
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        IF(IERR4.GT.0) GO TO 8999
      ENDIF
C
C     FORM UVEC * [VTMP = NEW SMO**(-1/2)] MATVEC
C     THIS NEXT PIECE ORTHOGONALIZES THE ALREADY PROJECTED MOS.
C     --UVEC REMAINS UNTOUCHED AS THE AO COEFFS OF THE NACT ACTIVE MOS
C     --VTMP IS THE (NACT,NACT) ORTHOGONALIZING TRANSFORMATION.
C     --PERFORM MATVEC AND PUT RESULT INTO SV
C     --REPLACE THE OLD NACT IORBF1 MOS BY THE NEW MOS IN SV
C     --READ IN THE ORTHOGONAL CORE ORBITALS INTO VTMP.
C     --COPY NACT PIECE INTO NACT POSITIONS OF VTMP.
C     --SAVE THE NEW ORTHOGONAL QUASI-ATOMIC ORBITALS TO FILE 521
      CALL VCLR(SV,1,L3)
      CALL MRARBR(UVEC,L1,L1,NACT,VTMP,L1,NACT,SV,L1)
      CALL DAREAD(IDAF,IODA,VTMP,L3,521,0)
      DO I=1,NACT
        J=NCORTOT+I
        CALL DCOPY(L1,SV(1,I),1,VTMP(1,J),1)
      ENDDO
      CALL DAWRIT(IDAF,IODA,VTMP,L3,521,0)
C
C
C
C     PRINT OUT FINAL ORIENTED ORBITALS TO GAMESS .LOG FILE.
C-----PRINT OUT CORES+VALENCE ORBITALS ONLY.
      IF(MASWRK) THEN
        WRITE(IW,9070)
        CALL PRSQL(VTMP,NCORTOT+NACT,L1,L1)
      ENDIF
C
C     PRINT OUT ORBITALS TO .DAT FILE.
C-----PRINT OUT CORES+VALENCE ORBITALS ONLY.
      IF(MASWRK) THEN
        WRITE(IP,9080)
        CALL PUSQL(VTMP,NCORTOT+NACT,L1,L1)
        WRITE(IP,9085)
      ENDIF
C
C
C
C
C     CONSTRUCT AND SAVE THE OVERALL ORBITAL TRANSFORMATION
C     FROM IORBF1 ORBITALS TO ORTHOGONAL PPASVD ORBITALS.
      CALL VCLR(VOLD,1,L3)
      CALL DAREAD(IDAF,IODA,VTMP,L3,523,0)
      CALL DAREAD(IDAF,IODA,VSAV,L3,524,0)
      CALL MRARBR(VTMP,L1,L0,L0,VSAV,L1,L0,VOLD,L1)
      CALL DAWRIT(IDAF,IODA,VOLD,L3,525,0)
C
C     PERFORM ORMAS CHECKS ON OVERALL ORBITAL TRANSFORMATION
C     BETWEEN IORBF1 ORBITALS AND NOW.
      IF(KEEPER) THEN
        IERR4=0
        DO II=1,NSPACE-1
          DO JJ=II+1,NSPACE
            DO I=MSTA(II),MSTA(II+1)-1
              DO J=MSTA(JJ),MSTA(JJ+1)-1
                TMP =ABS(VOLD(I,J))
                TMP2=ABS(VOLD(J,I))
                IF(TMP.GT.TOL2.OR.TMP2.GT.TOL2) IERR4=IERR4+1
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        IF(IERR4.GT.0) GO TO 8999
      ENDIF
C
C
C
C
C     PERFORM FINAL ERROR OUTS.
 8999 CONTINUE
      IF(MASWRK) THEN
        IF(IERR0.GT.0) THEN
          WRITE(IW,9001)
        ELSEIF(IERR2.GT.0) THEN
          WRITE(IW,9003)
        ELSEIF(IERR3.GT.0) THEN
          WRITE(IW,9004) IERR3
        ELSEIF(IERR4.GT.0) THEN
          WRITE(IW,9005)
        ELSEIF(IERR5.GT.0) THEN
          WRITE(IW,9006)
        ELSEIF(IERR6.GT.0) THEN
          WRITE(IW,9007)
        ELSEIF(IERR7.GT.0) THEN
          WRITE(IW,9008)
        ELSEIF(IERR8.GT.0) THEN
          WRITE(IW,9009)
        ELSEIF(IERR9.GT.0) THEN
          WRITE(IW,9010)
        ELSEIF(IERR10.GT.0) THEN
          WRITE(IW,9011)
        ELSEIF(IERR11.GT.0) THEN
          WRITE(IW,9012)
        ENDIF
      ENDIF
      IF(IERR0.GT.0
     *  .OR.IERR2.GT.0
     *  .OR.IERR3.GT.0
     *  .OR.IERR4.GT.0
     *  .OR.IERR5.GT.0
     *  .OR.IERR6.GT.0
     *  .OR.IERR7.GT.0
     *  .OR.IERR8.GT.0
     *  .OR.IERR9.GT.0
     *  .OR.IERR10.GT.0
     *  .OR.IERR11.GT.0
     *  ) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9000 FORMAT(1X,'LAST IATMSTA CHECK IS DONE.')
 9001 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'SOME ISSUE WITH IATMSTA ARRAY VALUES.  FIX IT.')
 9003 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'ERROR OCCURS FOR GLDIAG CALL.')
 9004 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'IN SYMMETRIC ORTHOG., ',
     *       1X,I4,' EIGENVALUES ARE BELOW TOL.',
     *       1X,I4,' IF USING SVDEXTORBSNUM OPTION,.',
     *       1X,I4,' PROBLEM MIGHT BE RELATED WITH QMTTOL.')
 9005 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'ERROR OCCURS FOR SOME ORBITAL TRANSFORM',
     *       1X,'IN ORMAS INTER-SUBSPACE BLOCKS.')
 9006 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'
     *       /1X,'ISVMOR WAS RESET AND NO LONGER EQUALS NACT.',
     *       /1X,'CHECK IF MOS WERE DROPPED FOR LINEAR DEPENDENCE..')
 9007 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'ISVMOR AND NATMOR DO NOT AGREE.')
 9008 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'ISVMOR HAS VALUES LESS THAN 1.',
     *      /1X,'YOU MIGHT WANT TO CHECK OUT THE SVD EVALUES,',
     *       1X,'AND USE THE NATMOR OR ISVMOR ARRAYS FOR INPUT.')
 9009 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'JJ DOES NOT EQUAL ITLH2.')
 9010 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'PLEASE CODE IN LOCAL_NUMVAL CHECK FOR',
     *       1X,'A NEW SCFTYP OPTION.')
 9011 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'LENGTHS FROM LOCAL_COUNTAOS VS. LIMLOW AND LIMSUP',
     *       1X,'DO MATCH UP.')
 9012 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'SVD EVALUES CANNOT BE LESS THAN ZERO.',
     *       1X,'ALSO, THEN IDAMAX SORTING DOES NOT WORK.')
 9038 FORMAT(/1X,'---CHECKING SVD--- VVOS ARE USED FOR GROUP=',I4)
 9039 FORMAT(/1X,'---CHECKING SVD--- ORTHOGONALIZED SV',
     *       1X,'IS USED FOR GROUP=',I4)
 9040 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *      /1X,'ISVDOP=10 IS NOT SACTIONED FOR USE OF',
     *       1X,' NSPACE>2 AND MORE THAN MBS ORBITALS.',
     *      /1X,'YOU ARE LOST.  TURN BACK NOW.')
 9045 FORMAT(/1X,'SVD EIGENVALUES NOW FOLLOW FOR ATOM NUMBER=',I4)
 9050 FORMAT(1X,'GROUP=',I4,
     *       5X,'ACTIVE ORBITAL=',I4,5X,'SVD EIGENVALUE=',F12.7)
 9054 FORMAT(/1X,'SVD HAS DEFINED THE NUMBER OF ORBITALS ON EACH ATOM.'
     *       /1X,'THE SAME ORBITAL FROM A SMALLER SVD VALUE MAY',
     *        1X,'HAVE A SLIGHTLY DIFFERENT SHAPE.',
     *       /1X,'LOCAL_ORDERS:  OVERWRITING NATMOR ARRAY.')
 9055 FORMAT(/1X,'SVDEXTORBSNUM OPTION HAS IMPACT ON ASSIGNMENTS HERE.')
 9056 FORMAT( 1X,'ATOM =',I4,5X,'ACTIVE ORBITALS NUMBER=',I4)
 9060 FORMAT(/1X,'LOCAL_PPASVD KEEPS ORBITALS WITHIN',
     *        1X,'ORMAS SUBSPACES.')
 9069 FORMAT(//10X,'PPASVDNON LOCALIZED ORBITALS')
 9070 FORMAT(//10X,'PPASVD LOCALIZED ORBITALS')
 9080 FORMAT('PPASVD LOCALIZED ORBITALS'/' $VEC')
 9085 FORMAT(' $END')
      END
C*MODULE LOCAL   *DECK LOCAL_PPADEN
c> @brief      Routine forms density in orthogonal quasi-atomic MO basis.
c>
c> @author     Aaron West and Klaus Ruedenberg
c>             -November 4, 2012
c>
c> @details    Routine forms density in orthogonal quasi-atomic MO basis.
c>             The density of the canonical orbitals in daf dict. file 15
c>             is transformed over to the orthogonal quasi-atomic MO basis.
c>             Please also see MALMQ_DEN for any information
c>             on orbital re-ordering.
c>             Special note:  NATMOR array must be correct to get out
c>                            the right atomic valence orbital populations.
c>                            I've finally nailed the automatic versus hand-select
c>                            orbitals issue here.
c>                            If you care, take a look at the bottom of
c>                            local_ppaerr routine.
C>
C> @date January 19, 2013-Aaron West
C> -Re-worked for VVOS runs.
C>
c> @param VTMP holds the overall orthogonal orbital transformation.
c> @param DEN contains the original density in the canonical MO basis.
c> @param DEN2 will hold the transformed density.
c> @param SCR is workspace for the transformation.
c> @param NSKIP  indicates how many doubly occupieds to skip over
c>               for VVOS run.
c> @param NSKIP2 indicates how many virtuals to re-assign to active orbitals
c>               for VVOS run.
c> @param NCORTOT is the total number of MCSCF core orbitals.
c>        For VVOS run, it is adjusted.
c> @param NCORSV is the total number of MCSCF core orbitals used
c>        for initial mcscf calculation.
c> @param NACT is the total number of MCSCF active oribtals.
c> @param NACTSV is the total number of MCSCF active orbitals
c>               before VVOS dimensional changes.
c> @param L1 is the length of the AO coefficients.
c> @param L3 is the square of L1.
C> @param NATMOR is the user input array that creates a correspondence
C>               between an oribital and which atom it resides on.
C> @param NAT    is the number of atoms.
C> @param KEEPER is a logical that equals true when
C>               cistep=ormas and nspace>1 and ormful=false.
C> @param SCFTYP is wave function type from the common.
C> @param EXTLOC defines the external orbital procedure (if any).
C>               Here, ext. orbs. means outside of the typical
C>                     mcscf starting active orbitals.
C> @param IVVOS        equals 1 indicates a VVOS run.
C>                     At this point, running VVOS orbitals through SVD.
c> @param IORBF1 indicates daf dict file with starting orbitals
c>               from which the localized orbitals are formed.
c> @param MASWRK indicates master process.
      SUBROUTINE LOCAL_PPADEN(
     *           VTMP,DEN,DEN2,SCR,
     *           NSKIP,NSKIP2,NCORTOT,NCORSV,NACT,NACTSV,L1,L3,
     *           NATMOR,NAT,KEEPER,SCFTYP,EXTLOC,
     *           IVVOS,IORBF1,MASWRK)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL KEEPER,MASWRK
      DOUBLE PRECISION ::
     *       TWO,ATSUM,ATSUM2,TOLDEN,TMP,
     *       SCFTYP,EXTLOC,RHF,RMC,SVD,RNONE
      PARAMETER (TWO=2.0D+00,TOLDEN=0.1D+00)
      INTEGER L1,L3,NCORTOT,NCORSV,
     *              NACT,NACT2,
     *              NACTSV,NACTSV2,NSKIP,NSKIP2,
     *        IPOS,IJ,IJ2,I,J,I2,J2,IVVOS,IORBF1,NAT,
     *        ITMP1,ITMP2
      INTEGER LOCAL_NUMVAL,NATMOR(L1)
C     NEW CODING STANDARDS VARS
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C----------------------------------------------------------------------
      DOUBLE PRECISION ::
     *       VTMP(L1,L1),DEN(L3),DEN2(L3),SCR(L3)
C----------------------------------------------------------------------
      DATA RMC/8HMCSCF   /
      DATA RHF/8HRHF     /
      DATA SVD/8HSVD     /
      DATA RNONE/8HNONE    /
C----------------------------------------------------------------------
C
C     DAF FILE  68 CONTAINS THE DENSITY IN THE CANONICAL MO BASIS.
C     DAF FILE 320 CONTAINS THE DENSITY IN THE CANONICAL MO BASIS
C                  OVER ACTIVE ORBITALS
C     DAF FILE  21 CONTAINS NO DENSITIES IN THE ACT BLOCK.
C
C     NOTES:  NACTSV IS THE DIMENSION OF ACTIVE SPACE ON DAF FILES.
C             FOR NO VVOS, NACT IS THE SAME DIMENSION.
C             FOR VVOS,    NACT IS A LARGER DIMENSION.
C
C     DEFINE SOME NEEDED DIMENSIONS.
      NACT2 = (NACT*NACT+NACT)/2
      NACTSV2=(NACTSV*NACTSV+NACTSV)/2
C
C     CLEAR OUT SOME ARRAYS
      CALL VCLR(DEN,1,L3)
      CALL VCLR(DEN2,1,L3)
      CALL VCLR(SCR,1,L3)
C
C     READ IN THE DENSITY
      IF(EXTLOC.EQ.RNONE) THEN
ccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      IF(SCFTYP.EQ.RMC.AND.IORBF1.EQ.15) THEN
        IF(MASWRK) WRITE(IW,9001)
        CALL DAREAD(IDAF,IODA,DEN,NACTSV2,320,0)
      ELSEIF(SCFTYP.EQ.RMC.AND.IORBF1.EQ.19) THEN
        IF(MASWRK) WRITE(IW,9002)
        CALL DAREAD(IDAF,IODA,SCR,L1,21,0)
        DO I=1,NACTSV
          SCR(I)=SCR(I+NCORSV)
        ENDDO
        DO I=1,NACTSV
          IJ=(I*I-I)/2 + I
          DEN(IJ)=SCR(I)
        ENDDO
      ELSEIF(SCFTYP.EQ.RHF.AND.IORBF1.EQ.15) THEN
        IF(MASWRK) WRITE(IW,9007)
        CALL VCLR(DEN,1,L3)
      ELSE
        IF(MASWRK) WRITE(IW,9003)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
ccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      ELSEIF(EXTLOC.EQ.SVD) THEN
        IF(MASWRK) WRITE(IW,9101)
        CALL VCLR(DEN,1,L3)
      ELSE
        IF(MASWRK) WRITE(IW,9100)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      IF(IVVOS.NE.0) THEN
        CALL VCLR(DEN2,1,L3)
        CALL DCOPY(NACTSV2,DEN,1,DEN2,1)
        CALL VCLR(DEN,1,L3)
        DO I=1,NSKIP
          IJ=(I*I-I)/2 + I
          DEN(IJ)=TWO
        ENDDO
C
        IPOS=NSKIP+NSKIP2
        DO I=1,NACTSV
          DO J=1,I
            IJ =(I*I-I)/2 + J
            I2=I+IPOS
            J2=J+IPOS
            IJ2=(I2*I2-I2)/2 + J2
            DEN(IJ2)=DEN2(IJ)
          ENDDO
        ENDDO
C
        IF(SCFTYP.EQ.RMC) THEN
          IF(MASWRK) WRITE(IW,9005)
        ENDIF
C
        IF(MASWRK) WRITE(IW,9006)
        CALL PRTRI(DEN,NACT)
      ENDIF
C
C     READ IN THE OVERALL ORTHOGONAL QUASI-ATOMIC ORBITAL TRANSFORMATION.
      CALL DAREAD(IDAF,IODA,VTMP,L3,525,0)
C
C     TRANSFORM THE DENSITY BY BLOCK-DIAGONAL TRANFORMATION:
C     NEW ORBS = ORIG ORBS * VTMP
C     NEW DENSITY = VTMP-TRANS * DEN * VTMP
C     --SAVE DENSITY MATRIX
C     ----FILE 526 FOR KEEPS
C     ----FILE 285 FOR ORIENTATION
      CALL TFTRI(DEN2,DEN,VTMP(NCORTOT+1,NCORTOT+1),SCR,
     *           NACT,NACT,L1)
      IF(EXTLOC.EQ.RNONE) THEN
        CALL DAWRIT(IDAF,IODA,DEN2,NACT2,526,0)
        CALL DAWRIT(IDAF,IODA,DEN2,NACT2,285,0)
      ELSE
        CALL DAWRIT(IDAF,IODA,DEN2,NACT2,536,0)
      ENDIF
C
C     PRINT OUT THE DENSITY.
      IF(MASWRK) WRITE(IW,9000)
      CALL PRTRI(DEN2,NACT)
C
C     PRINT OUT ATOMIC POPULATIONS.
      IF(KEEPER) THEN
        DO J=1,NAT
          ATSUM =0.0D+00
          ATSUM2=0.0D+00
          DO I=1,NACT
            IF(NATMOR(NCORTOT+I).EQ.J) THEN
              IJ=(I*I-I)/2 + I
              TMP=DEN2(IJ)
              ATSUM=ATSUM+TMP
              IF(TMP.GT.TOLDEN) ATSUM2=ATSUM2+TMP
            ENDIF
          ENDDO
          IF(MASWRK) WRITE(IW,9020) J,ATSUM,TOLDEN,ATSUM2
        ENDDO
      ELSE
        ITMP1=0
        ITMP2=0
        DO J=1,NAT
          ATSUM =0.0D+00
          ATSUM2=0.0D+00
          ITMP2=ITMP2+LOCAL_NUMVAL(J,0)
          DO I=ITMP1,ITMP2
            IJ=(I*I-I)/2 + I
            TMP=DEN2(IJ)
            ATSUM=ATSUM+TMP
            IF(TMP.GT.TOLDEN) ATSUM2=ATSUM2+TMP
          ENDDO
          ITMP1=ITMP2+1
C
          IF(MASWRK) WRITE(IW,9020) J,ATSUM,TOLDEN,ATSUM2
C
        ENDDO
      ENDIF
C
C     FINAL CHECK ON CORRECT DENSITY.
      IF(IVVOS.NE.0.AND.IORBF1.NE.15) THEN
        IF(MASWRK) WRITE(IW,9004)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9000 FORMAT(/1X,'DENSITY MATRIX IN THE',
     *        1X,'ORTHOGONAL QUASI-ATOMIC SVD MO BASIS',
     *       /1X,'OVER ACTIVE ORBITALS IS')
 9001 FORMAT(/1X,'LOCAL_PPADEN:  STARTING WITH CANONICAL ORBITAL',
     *        1X,'DENSITY FROM DAF FILE 320.')
 9002 FORMAT(/1X,'LOCAL_PPADEN:  STARTING WITH NATURAL ORBITAL',
     *        1X,'DENSITY FROM DAF FILE 21.')
 9003 FORMAT(/1X,'LOCAL_PPADEN:  IORBF1 ORBITAL CHOICE HAS NO',
     *        1X,'DENSITY FILE PROGRAMED.  PLEASE ADD ONE.')
 9004 FORMAT(/1X,'LOCAL_PPADEN:  YOUR DENSITY IS PROBABLY WRONG!',
     *       /1X,'VVOS WAS PROGRAMMED TO WORK WITH DAF FILE 15.',
     *        1X,'RE-RERUN OR RE-PROGRAM WITH FAO FOR NOS',
     *        1X,'AND REMOVE ERROR.')
 9005 FORMAT(/1X,'NOTE:  PREVIOUS PRINT OFF FOR DENSITY DOES NOT',
     *       /1X,'       MATCH HERE BECAUSE IT IS',
     *        1X,'NOT CANONICAL DENSITY.')
 9006 FORMAT(/1X,'DENSITY MATRIX FOR VVOS BEFORE ORTHORGONAL',
     *       /1X,'QUASI-ATOMIC SVD MO ORBITAL TRANSFORMATION.')
 9007 FORMAT(/1X,'LOCAL_PPADEN:  STARTING WITH RHF DENSITY.')
 9020 FORMAT(/1X,'ATOM',I5,3X,'SVD POPULATION=',F5.3,
     *        3X,'GREATER THAN ',F5.3,' CONTRIBUTIONS=',F5.3)
 9100 FORMAT(/1X,'LOCAL_PPADEN ERROR:',
     *       /1X,'THIS EXTLOC OPTION IS NOT DEFINED.')
 9101 FORMAT(/1X,'LOCAL_PPADEN:',
     *        1X,'STARTING WITH RHF DENSITY BUT ONLY IN VALENCE.')
      END
C*MODULE LOCAL   *DECK MALMQ_REORDER1
C> @brief      This routine initializes daf files 527,528,531 after SVD.
C>
C> @author     Aaron West
C>             -December 17, 2012
C>
C> @details    This routine initializes daf files 527,528,531 after SVD.
C>             It accounts for differences in orbital orderings
C>             between CASSCF and ORMAS SVD.
C>
C> @see        MALMQ_REORDER,MALMQ_REORDER2,MALMQ_REORDER_FINAL
C>             MALMQ_GETORB
C>
C> @param NAT    is the number of atoms.
C> @param L1     denotes the length of the AO coefficients.
C> @param IAT    is an integer scratch array of length L1.
C> @param NATMOR is the user input array that creates a correspondence
C>               between an oribital and which atom it resides on.
C> @param NACT   is the number of active orbitals.
C> @param NCORSV is the number of chemical core orbitals.
c>               For VVOS run, it might be adjusted.
C> @param KEEPER is a logical that equals true when
C>               cistep=ormas and nspace>1 and ormful=false.
C> @param SOME   is true for master process with nprint not equal -5.
C>
      SUBROUTINE MALMQ_REORDER1(NAT,L1,IAT,NATMOR,
     *                          NACT,NCORSV,KEEPER,
     *                          SOME)
      IMPLICIT NONE
      LOGICAL KEEPER,SOME
      INTEGER J,LOCAL_NUMVAL,NAT,IHACT,NUMVAL1
      INTEGER I,L1,NCORSV,NACT,NATMOR(L1),IAT(L1)
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
      CALL VICLR(IAT,1,L1)
      IF(KEEPER) THEN
C       ORMAS NSPACE>1
        DO I=1,NACT
          IAT(I)=NATMOR(I+NCORSV)
        ENDDO
      ELSE
C       ORMAS NSPACE=1 + CASSCF
        IHACT=0
        DO I=1,NAT
          NUMVAL1=LOCAL_NUMVAL(I,0)
          DO J=1,NUMVAL1
            IHACT=IHACT+1
            IAT(IHACT)=I
          ENDDO
        ENDDO
      ENDIF
C
C
      CALL DAWRIT(IDAF,IODA,IAT,NACT,528,1)
      CALL DAWRIT(IDAF,IODA,IAT,NACT,531,1)
C
C     INITIALIZE FILE 527 HERE TO HAVE A 527 FOR DA READS.
      DO I=1,L1
        IAT(I)=I
      ENDDO
      CALL DAWRIT(IDAF,IODA,IAT,L1,527,1)
C
      IF(SOME) WRITE(IW,9000)
C
      RETURN
 9000 FORMAT(/1X,'LOCAL_ORDERS:',
     *        1X,'MALMQ_REORDER1 ROUTINE NOW ALTERS',
     *        1X,'DAF FILES 527,528, AND 531.')
      END
C*MODULE LOCAL   *DECK MALMQ_REORDER2
C> @brief      This routine updates daf files 527 after orientation.
C>
C> @author     Aaron West
C>             -December 17, 2012
C>
C> @details    After orbital orientation, this routine keeps file 527
C>             updated.
C>
C> @see        MALMQ_REORDER,MALMQ_REORDER2,MALMQ_REORDER_FINAL
C>             MALMQ_GETORB
C>
C> @param MAPT   holds orbital swaps from DIMOID
C>               from atomic reorderings.
C> @param MAPT2  holds orbital swaps from ORIEN
C>               from occupation reorderings.
C> @param MAPT3  is integer scratch array of length L1.
C> @param MCORE  is the number of chemical core orbitals.
c> @param NACT   is the number of active orbitals.
c> @param L1     is the length of the AO coefficients.
c> @param MASWRK indicates the master process.
      SUBROUTINE MALMQ_REORDER2(MAPT,MAPT2,MAPT3,MCORE,NACT,L1,
     *                          MASWRK)
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER I,MCORE,NACT,L1
      INTEGER MAPT(NACT),MAPT2(NACT),MAPT3(L1)
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
C
C     INITIALIZE MAPT3
      DO I=1,L1
        MAPT3(I)=I
      ENDDO
C
C     APPLY THE OCCUPATION REORDERINGS IN MAPT2 TO MAPT.
      CALL IREORDR(MAPT,MAPT2,NACT,1)
C
C     NOW, TO GET ORIENTED 2ND--> SVD, BACK MAP IT.
      CALL ICOPY(NACT,MAPT,1,MAPT2,1)
      DO I=1,NACT
        MAPT(MAPT2(I))=I
      ENDDO
C
C     MOVE FROM ACTIVE INDICES AND ACTIVE VALUES.
C     AND
C     MOVE MAPT INTO INTO MAPT3.
      DO I=1,NACT
        MAPT3(I+MCORE)=MAPT(I)+MCORE
      ENDDO
C
      CALL DAWRIT(IDAF,IODA,MAPT3,L1,527,1)
C
      IF(MASWRK) WRITE(IW,9000)
C
      RETURN
 9000 FORMAT(/1X,'LOCAL_ORDERS:',
     *        1X,'MALMQ_REORDER2 ROUTINE NOW ALTERS',
     *        1X,'DAF FILE 527.')
      END
C*MODULE LOCAL   *DECK LOCAL_KEEPER_SETUP
C> @brief      This routine sets up ORMAS KEEPER variable anywhere.
C>
C> @author     Aaron West
C>             -January 12, 2013
C>
C> @details    This routine sets up the ORMAS KEEPER variable anywhere.
C>             Here, anywhere means without having to add in all the common
C>             blocks to set up a single variable.
C>             Later, we might also fold in KEEPER_ISVMOR variable if things
C>                    get complicated.
C>
C> @date January 30, 2013-Aaron West
C> -Added ISVDOP to ORNTMO common block.
C> This run gives special option for SVD runs.
C>
C> @param KEEPER     is a logical and is true when
C>                   CISTEP=ORMAS + NSPACE>1 + ORMFUL=.FALSE.
C>                   SCFTYP=RHF
C>
      SUBROUTINE LOCAL_KEEPER_SETUP(KEEPER)
      IMPLICIT NONE
      LOGICAL KEEPER
      DOUBLE PRECISION :: ORMAS,RMC,RHF
C
C----------------------------------------------------------------
      INTEGER MXNORO
      PARAMETER (MXNORO=250)
      INTEGER MXAO,MXATM
      PARAMETER (MXAO=8192, MXATM=2000)
C----------------------------------------------------------------
      LOGICAL FDIRCT,QCORR
      INTEGER NSPACE,MSTA,MNUM,MINI,MAXI,IAMI,IAMA,IBMI,IBMA,IDIMFCC,
     *        LBST,NREF0
      DOUBLE PRECISION ::
     *       C0SQ
C
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
C
      LOGICAL CANONC,FCORE,FORS,EKT,LINSER
      DOUBLE PRECISION ::
     *       FINALCI,METHOD,CISTEP,ACURCY,ENGTOL,DAMP
      INTEGER MICIT,NWRDMC,NORBMC,NOROT,MOFRZ,
     *        NPFLG,NOFO,MCFMO,IDIABAT
C
      LOGICAL ORIENT,ORIKIN,ORMFUL
      INTEGER NATMOR,ISVMOR,ISVDOP
      DOUBLE PRECISION :: EXTLOC,EREFATM
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C----------------------------------------------------------------
C
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIMFCC(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWRDMC,NORBMC,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /ORNTMO/ EXTLOC,EREFATM,
     *                NATMOR(MXAO),ISVMOR(MXATM),ISVDOP,
     *                ORIENT,ORIKIN,ORMFUL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C----------------------------------------------------------------
C
      DATA ORMAS/8HORMAS   /
      DATA RMC/8HMCSCF   /
      DATA RHF/8HRHF     /
C
C     SETUP THE 'KEEPER' VAR
      IF(SCFTYP.EQ.RMC) THEN
        KEEPER=CISTEP.EQ.ORMAS.AND.NSPACE.GT.1.AND..NOT.ORMFUL
      ELSEIF(SCFTYP.EQ.RHF) THEN
        KEEPER=.TRUE.
      ELSE
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9000 FORMAT(/1X,'LOCAL_KEEPER_SETUP ERROR:',
     *        1X,'PLEASE CODE A NEW KEEPER VAR OPTION.')
      END
C*MODULE LOCAL   *DECK LOCAL_SVDVVOS_MOS
C> @brief      Routine moves around orbital file for VVOS-SVD.
C>
C> @author     Aaron West and Mike Schmidt
C>             -January 21, 2013
C>
C> @details    Routine moves around orbital file for VVOS-SVD.
C>
C> @see LOCAL_SVDVVOS_REDIM_STEP1
C>      LOCAL_SVDVVOS_REDIM_STEP2
C>      LOCAL_SVDVVOS_REDIM_STEPLAST
C>      LOCAL_SVDVVOS_MOS
C>
C> @param VOLD    is scratch space of L3 size.
C> @param VTMP    is scratch space of L3 size.
C> @param IORBF1  indicates daf dict file with starting orbitals
C>                from which the localized orbitals are formed.
C> @param L0      is the length of the MO variational space.
C> @param L1      is the length of the AO coefficients.
C> @param L3      is the square of L1.
C> @param NCORSV  denotes the original MCSCF run doubly occupied size.
C> @param NCORTOT denotes the chemical cores as defined by NVVOS_NUMCOR.
C> @param NACTSV  denotes the original MCSCF run active space size.
C> @param NSKIP   denotes the number of filled doubly occupieds i.e. MDOC.
C> @param NSKIP2  denotes the now filled but previously empty virutals.
C> @param MASWRK       indicates the master process.
      SUBROUTINE LOCAL_SVDVVOS_MOS(VOLD,VTMP,IORBF1,
     *           L0,L1,L3,NCORSV,NCORTOT,NACTSV,NSKIP,NSKIP2,MASWRK)

      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER IORBF1,L0,L1,L3,NCORSV,NCORTOT,NACTSV,NSKIP,NSKIP2,
     *        I,ITOT
      DOUBLE PRECISION ::
     *       VOLD(L1,L1),VTMP(L1,L1)
C
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
      CALL DAREAD(IDAF,IODA,VOLD,L3,IORBF1,0)
      CALL VCLR(VTMP,1,L3)
C
      ITOT=0
C
      DO I=1,NCORTOT+NSKIP
        ITOT=ITOT+1
        CALL DCOPY(L1,VOLD(1,I),1,VTMP(1,I),1)
      ENDDO
C
      DO I=1,NSKIP2
        ITOT=ITOT+1
        CALL DCOPY(L1,VOLD(1,NCORSV+NACTSV+I),1,
     *                VTMP(1,NCORTOT+NSKIP+I),1)
      ENDDO
C
      DO I=1,NACTSV
        ITOT=ITOT+1
        CALL DCOPY(L1,VOLD(1,NCORSV+I),1,
     *                VTMP(1,NCORTOT+NSKIP+NSKIP2+I),1)
      ENDDO
C
      DO I=NCORSV+NACTSV+NSKIP2+1,L0
        ITOT=ITOT+1
        CALL DCOPY(L1,VOLD(1,I),1,VTMP(1,I),1)
      ENDDO
C
C     WRITE RE-ORDERED ORBITALS BACK OUT TO FILE 15
C     NOTE:  SO, DAF 15 GETS OVERWROTE HERE IF IORBF1=15.
C                CAN. MOS WERE ALREADY OVERWROTE WITH VVOS MOS.
C                IF WANT CHANGED, BOTH NEED TO BE RE-VISITED.
      CALL DAWRIT(IDAF,IODA,VTMP,L3,15,0)
C
C     CHECK NUMBER OF ORBITALS COPIED OVER MAKES SENSE.
      IF(ITOT.NE.L0) THEN
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9000 FORMAT(/1X,'LOCAL_SVDVVOS_MOS ERROR:',
     *        1X,'VVOS DIMENSIONS MUST BE WRONG.',
     *        1X,'ORBITALS COPIED DOES NOT TOTAL UP TO L0 MOS.')
      END
C*MODULE LOCAL   *DECK LOCAL_SVDVVOS_REDIM_STEP1
C> @brief      Routine sets up VVOS ormas nspace and orbital sizes.
C>
C> @author     Aaron West and Mike Schmidt
C>             -January 21, 2013
C>
C> @details    Routine sets up VVOS ormas nspace and orbital sizes.
C>
C> @see LOCAL_SVDVVOS_REDIM_STEP1
C>      LOCAL_SVDVVOS_REDIM_STEP2
C>      LOCAL_SVDVVOS_REDIM_STEPLAST
C>      LOCAL_SVDVVOS_MOS
C>
C> @param SCFTYP     indicates MCSCF,RHF,etc.
C> @param ISVDOP     is the SVD option.
C> @param NAT        is the number of atoms.
C> @param NCORSV     is the original MCSCF doubly occupied space.
C> @param NACTDT     is the original MCSCF active space size.
C> @param L0         is the size of the MO variational space.
C> @param NSPACE     indicates the number of ORMAS groups.
C> @param NSPACE_SAV saves the original ORMAS group size.
C> @param NCORTOT    is the chemical cores as defined by NVVOS_NUMCOR.
C> @param NSKIP      denotes the number of filled doubly occupieds i.e. MDOC.
C> @param NACT       denotes the number of VVOS active space orbitals.
C> @param NSKIP2     denotes the now filled but previously empty virutals.
C> @param NVIR2      denotes the number of VVOS virtual orbitals.
C> @param MASWRK     indicates the master process.
C> @param IW         indicates write out to the log file.
C>
      SUBROUTINE LOCAL_SVDVVOS_REDIM_STEP1(
     *           SCFTYP,ISVDOP,
     *           NAT,NCORSV,NACTDT,L0,
     *           NSPACE,NSPACE_SAV,
     *           NCORTOT,NSKIP,NACT,NSKIP2,NVIR2,
     *           MASWRK,IW)
C
      IMPLICIT NONE
      LOGICAL MASWRK
C
      DOUBLE PRECISION :: RMC,RHF
      DATA RMC/8HMCSCF   /
      DATA RHF/8HRHF     /
C
      DOUBLE PRECISION :: SCFTYP
      INTEGER ISVDOP,NAT,NCORSV,NACTDT,L0,
     *        NSPACE,NSPACE_SAV,
     *        NCORTOT,NSKIP,NACT,NSKIP2,NVIR2
      INTEGER IW,I,IMBS
      INTEGER LOCAL_NUMVAL,NVVOS_NUMCOR
C
      IF(SCFTYP.EQ.RMC) THEN
        NSPACE_SAV=NSPACE
        NSPACE=NSPACE_SAV+1
C       NOTES:  VVOS IS RESTRICTED INSIDE OF LOCAL_NUMVAL
C                    TO MBS NUMBERS OF ORBITALS.
        IMBS=0
        DO I=1,NAT
          IMBS=IMBS+LOCAL_NUMVAL(I,0)
        ENDDO
C       NOTES:  SEE VVOS ROUTINE FOR SIMILAR VARS.
        NCORTOT=NVVOS_NUMCOR(0,0)
        NSKIP  =NCORSV-NCORTOT
        NSKIP2 =IMBS-NSKIP-NACTDT
        NACT   =NACTDT+NSKIP+NSKIP2
        NVIR2  =L0-NCORTOT-NSKIP-NSKIP2-NACTDT
      ELSEIF(SCFTYP.EQ.RHF) THEN
        IF(ISVDOP.EQ.0) THEN
          NSPACE_SAV=NSPACE
          NSPACE=2
          NCORTOT=NVVOS_NUMCOR(0,0)
          NSKIP  =NCORSV-NCORTOT
          NSKIP2 =0
          NACT   =NACTDT+NSKIP+NSKIP2
          NVIR2  =L0-NCORTOT-NSKIP-NSKIP2-NACTDT
        ENDIF
      ELSE
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9000 FORMAT(//1X,'LOCAL_SVDVVOS_REDIM_STEP1 ERROR:',
     *        /1X,'THIS ISVDOP OPTION DOES NOT EXIST.')
      END
C*MODULE LOCAL   *DECK LOCAL_SVDVVOS_REDIM_STEP2
C> @brief      Routine saves and sets up VVOS ORMAS MSTA.
C>
C> @author     Aaron West and Mike Schmidt
C>             -January 21, 2013
C>
C> @details    Routine saves and sets up VVOS ORMAS MSTA.
C>             This routine sets up the new VVOS orbital ranges
C>             and saves the old ones.
C>
C> @see LOCAL_SVDVVOS_REDIM_STEP1
C>      LOCAL_SVDVVOS_REDIM_STEP2
C>      LOCAL_SVDVVOS_REDIM_STEPLAST
C>      LOCAL_SVDVVOS_MOS
C>
C> @param SCFTYP         indicates MCSCF,RHF,etc.

C> @param ISIZE_FCCWFN   is the current size of the MSTA array
C> @param ISVDOP         is the SVD option.
C> @param NAT            is the number of atoms.
C> @param NSPACE         is the number of ORMAS groups.
C> @param MSTA           contains the ORMAS orbital ranges.
C> @param MSTA_SAV       saves the original MCSCF orbital ranges.
C> @param NCORTOT        is the number of chemical cores from NVVOS_NUMCOR.
C> @param NSKIP2         is the number of newly occupied VVOS orbitals
C>                       that are virtual orbitals in the original MCSCF.
C> @param MASWRK         indicates the master process.
C> @param IW             indicates write out to the log file.
C>
      SUBROUTINE LOCAL_SVDVVOS_REDIM_STEP2(
     *           SCFTYP,ISVDOP,NAT,L0,
     *           ISIZE_FCCWFN,NSPACE,MSTA,MSTA_SAV,
     *           NCORTOT,NSKIP2,MASWRK,IW)
C
      IMPLICIT NONE
C
      DOUBLE PRECISION :: RMC,RHF
      DATA RMC/8HMCSCF   /
      DATA RHF/8HRHF     /
C
      LOGICAL MASWRK
      DOUBLE PRECISION :: SCFTYP
      INTEGER ISVDOP,NAT,L0,ISWMBS,ITMP
      INTEGER I,NSKIP2,NCORTOT,IW,ISIZE_FCCWFN,NSPACE
      INTEGER MSTA(ISIZE_FCCWFN),MSTA_SAV(ISIZE_FCCWFN)
      INTEGER LOCAL_NUMVAL
C
      CALL ICOPY(ISIZE_FCCWFN,MSTA,1,MSTA_SAV,1)
C
      IF(SCFTYP.EQ.RMC) THEN
        DO I=NSPACE,1,-1
          MSTA(I+1)=MSTA(I)+NSKIP2
        ENDDO
        MSTA(1)=NCORTOT+1
      ELSEIF(SCFTYP.EQ.RHF) THEN
        IF(ISVDOP.EQ.0) THEN
          ISWMBS=1
          ITMP=0
          DO I=1,NAT
            ITMP=ITMP+LOCAL_NUMVAL(I,ISWMBS)
          ENDDO
          MSTA(1)=NCORTOT+1
          MSTA(2)=NCORTOT+ITMP+1
          MSTA(3)=L0+1
CGARBRHF          MSTA(1)=NCORTOT+1
CGARBRHF          MSTA(2)=NA+1
CGARBRHF          MSTA(3)=L0+1
        ENDIF
      ELSE
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      IF(MASWRK) WRITE(IW,9001) NSPACE,(MSTA(I),I=1,NSPACE)
C
      RETURN
 9000 FORMAT(//1X,'LOCAL_SVDVVOS_REDIM_STEP2 ERROR:',
     *        /1X,'THIS SCFTYP,ISVDOP OPTION DOES NOT EXIST.')
 9001 FORMAT(//1X,'VVOS TEMPORARILY RE-DEFINES ORMAS GROUPS.',
     *        /1X,'THE NUMBER OF SPACES             =',I4,
     *        /1X,'EACH SPACE STARTS AT ORBITAL     =',50I4//)
      END
C*MODULE LOCAL   *DECK LOCAL_SVDVVOS_REDIM_STEPLAST
C> @brief      Routine resets MSTA,NSPACE,orbitals for VVOS-ORMAS.
C>
C> @author     Aaron West and Mike Schmidt
C>             -January 21, 2013
C>
C> @details    Routine resets MSTA,NSPACE, and orbital variables
C>             for VVOS-ORMAS runs.
C>
C> @see LOCAL_SVDVVOS_REDIM_STEP1
C>      LOCAL_SVDVVOS_REDIM_STEP2
C>      LOCAL_SVDVVOS_REDIM_STEPLAST
C>      LOCAL_SVDVVOS_MOS
C>
C> @param SCFTYP       indicates MCSCF,RHF,etc.
C> @param NACT         is the current number of active orbitals.
C> @param NACTDT       is the original number of active orbitals.
C> @param NSPACE       is the current number of ORMAS groups.
C> @param NSPACE_SAV   is the original number of ORMAS groups.
C> @param ISIZE_FCCWFN is the common block size of MSTA.
C> @param MSTA         holds the orbital ranges for ORMAS groups.
C> @param MSTA_SAV     is the original orbital ORMAS group ranges.
C> @param MASWRK       indicates the master process.
C> @param IW           indicates write out to the log file.
C>
      SUBROUTINE LOCAL_SVDVVOS_REDIM_STEPLAST(
     *           SCFTYP,NACT,NACTDT,NSPACE,NSPACE_SAV,ISIZE_FCCWFN,
     *           MSTA,MSTA_SAV,MASWRK,IW)
C
      IMPLICIT NONE
C
      DOUBLE PRECISION :: RMC,RHF
      DATA RMC/8HMCSCF   /
      DATA RHF/8HRHF     /
C
      LOGICAL MASWRK,OK
      DOUBLE PRECISION :: SCFTYP
      INTEGER I,IW,NACT,NACTDT,NSPACE,NSPACE_SAV,ISIZE_FCCWFN
      INTEGER MSTA(ISIZE_FCCWFN),MSTA_SAV(ISIZE_FCCWFN)
C
      OK=.FALSE.
      IF(SCFTYP.EQ.RMC) OK=.TRUE.
      IF(SCFTYP.EQ.RHF) OK=.TRUE.
C
      IF(OK) THEN
        NACT=NACTDT
        NSPACE=NSPACE_SAV
        CALL ICOPY(ISIZE_FCCWFN,MSTA_SAV,1,MSTA,1)
        IF(MASWRK) WRITE(IW,9001) NSPACE,(MSTA(I),I=1,NSPACE)
      ELSE
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9000 FORMAT(//1X,'LOCAL_SVDVVOS_REDIM_STEPLAST ERROR:',
     *        /1X,'THIS SCFTYP,ISVDOP OPTION DOES NOT EXIST.')
 9001 FORMAT(//1X,'VVOS RESETS BACK TO ORIGINAL ORMAS GROUPS.',
     *        /1X,'THE NUMBER OF SPACES             =',I4,
     *        /1X,'EACH SPACE STARTS AT ORBITAL     =',50I4//)
      END
C*MODULE LOCAL   *DECK LOCAL_SVDEXTORBSNUM_CASE
C> @brief      Corrects degeneracy issue in the external space.
C>
C> @author     Aaron West
C>             -January 31, 2013
C>
C> @details    Corrects degeneracy issue in the external space.
C>             Any ORMAS SVD run has one SVD per atom per group.
C>             As the SVD evalues get smaller and smaller,
C>             the evalues for e.g. 2 carbons might result in
C>             linear dependence in the last group i.e. the externals.
C>             So, we max out the number of degenerate evalues kept
C>                 for each atom.
C>
C> @note       Only works for NSPACE=2 right now.
C>             As we get more examples,
C>             there might be more bug fixing here...
C>
C> @param NACT    is the number of active orbitals.
C> @param L0      is the number of variational molecular orbitals.
C> @param NSPACE  is the number of ORMAS groups.
C> @param NAT     is the number of atoms for the chemical system.
C> @param NATMOR  is just some scratch space right here.
C> @param IATMSTA      is an array that defines sets of atoms and
C>                     orbitals to localized based on natmor input.
C> @param ISVMOR       is ISVMOR from ORNTMO common block.
C> @param EIGSAV       saves the SVD evalues from ALL SVDs.
C>                     For each atom, an SVD is done.
C> @param VTVECSAV     temporarily saves orbital transformations
C>                     for ALL SVDs from which transform elements
C>                     are selected.
C> @param MASWRK       indicates the master process.
C> @param IW           indicates write out to the log file.
C>
      SUBROUTINE LOCAL_SVDEXTORBSNUM_CASE(
     *           NACT,L0,NSPACE,NAT,
     *           NATMOR,IATMSTA,ISVMOR,EIGSAV,VTVECSAV,
     *           MASWRK,IW)
C
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER IHOLD,IMARK,J,ISPACE,NACTFIN,IATM1,ITMP,ISWMBS,
     *        III,K,IPOS,JPOS
      INTEGER NAOCART,NAOSPH,NAOSPH_VAL
      INTEGER NACT,L0,NSPACE_LIMIT,NSPACE,NAT,IW,IDEGEN
      INTEGER NATMOR(L0),IATMSTA(NSPACE,NAT),ISVMOR(NAT)
C
      INTEGER LOCAL_NUMVAL
      INTEGER NVVOS_NUMCOR
C
      DOUBLE PRECISION ::
     *       TMP,TMPSAV,TOL,
     *       EIGSAV(NAT*NACT,NSPACE),VTVECSAV(NACT,NACT,NAT*NSPACE)
C
      PARAMETER (TOL=1.0D-05,IDEGEN=6)
C
C     CLEAR NEEDED INTEGER ARRAYS.
      CALL VICLR(ISVMOR,1,NAT)
      CALL VICLR(IATMSTA,1,NSPACE*NAT)
C
C     GET THE NUMBER OF valence SPHERICAL AOS ON EACH ATOM.
C     RE-DEFINE ISVMOR BY THIS.
      DO IATM1=1,NAT
        CALL LOCAL_COUNTAOS(IATM1,NAOCART,NAOSPH)
        ITMP=NVVOS_NUMCOR(IATM1,1)
        NAOSPH_VAL=NAOSPH-ITMP
C       SAVE THE NUMBER OF VALENCE ORBITALS ON ATOM IATM1.
        ISVMOR(IATM1)=NAOSPH_VAL
        ISWMBS=1
        ITMP=LOCAL_NUMVAL(IATM1,ISWMBS)
C       SAVE THE NUMBER OF MBS VALENCE ORBITALS ON ATOM IATM1.
        IATMSTA(1,IATM1)=ITMP
        IATMSTA(2,IATM1)=NAOSPH_VAL-ITMP
      ENDDO
C
C     RIGHT NOW, LET'S TRY CORRECTING FOR EXTERNAL SPACE ONLY.
      NSPACE_LIMIT=NSPACE
      ISPACE      =NSPACE
C
C     REARRANGE VTVECSAV SUCH THAT
C     NON-DEGENERATE EVALUE'D ORBITAL TRANSFORM
C     ARE DISCARDED TOWARDS THE END.
C     THIS ACTION EFFECTIVELY KEEPS THE DEGENERATE EVALUE'D TRANSFORM VECTORS.
C     PLEASE SEE RESTRICTIONS IN LOCAL_PPAERR.
C     ---NATMOR ARRAY IS USED TO HOLD THE NON-DEGENERATE EVALUE'D POSITIONS
C        OF NSPACE=2 RIGHT NOW.... WHOLE 'NOTHER DEAL FOR MORE NSPACES B/C
C                                  REPEATED COUNTS.
C------------------------------------------------------------
C------------------------------------------------------------
      DO 101 IATM1=1,NAT
C       note:  this nactfin is less than the usual nactfin...
C              but this var is not returned...
        NACTFIN=IATMSTA(ISPACE,IATM1)
        IMARK=0
        ITMP=(IATM1-1)*NACT + NACTFIN
        TMPSAV=EIGSAV(ITMP,ISPACE)
        DO J=NACTFIN+1,NACTFIN+IDEGEN
          ITMP=(IATM1-1)*NACT + J
          TMP=ABS(EIGSAV(ITMP,ISPACE)-TMPSAV)
          IF(TMP.LE.TOL) IMARK=J
        ENDDO
C--------------------------
        IF(IMARK.NE.0) THEN
          CALL VICLR(NATMOR,1,L0)
          III=0
          DO J=NACTFIN+IDEGEN,1,-1
            IHOLD=0
            ITMP=(IATM1-1)*NACT + J
            TMPSAV=EIGSAV(ITMP,ISPACE)
            DO 55 K=NACTFIN+IDEGEN,1,-1
              IF(K.EQ.J) GO TO 55
cccccccccccccc
              ITMP=(IATM1-1)*NACT + K
              TMP=ABS(EIGSAV(ITMP,ISPACE)-TMPSAV)
              IF(TMP.LE.TOL) IHOLD=1
cccccccccccccc
   55         CONTINUE
C           IHOLD=0 --> INDICATES NON-DEGENERATE EVALUE.
            IF(IHOLD.EQ.0.AND.J.LE.NACTFIN) THEN
              III=III+1
              NATMOR(III)=J
            ENDIF
          ENDDO
        ENDIF
C--------------------------
C       THE FOLLOWING INFO IS NOW ACCESSIBLE:
C       1)  THE LARGEST DEGENERATE VALUE ASSUMING 3X DEGENERATE
C           I.E. DEGENERATE UP TO NACTFIN+IDEGEN
C       2)  NON-DEGENERATE POSITIONS GOING DOWN FROM NACTFIN.
C       NOW SWAP OUT SOME VECTORS.
        IF(IMARK.NE.0) THEN
          IF(MASWRK) WRITE(IW,9002) IATM1
          III=0
          DO JPOS=NACTFIN+1,IMARK
            ITMP = (IATM1-1)*NSPACE_LIMIT + ISPACE
            III=III+1
            IPOS=NATMOR(III)
            CALL DSWAP(NACTFIN,VTVECSAV(1,IPOS,ITMP),1,
     *                         VTVECSAV(1,JPOS,ITMP),1)
C
            IF(MASWRK) WRITE(IW,9003) IATM1,ISPACE,JPOS,IPOS
C
          ENDDO
        ENDIF
C------------------------------------------------------------
  101 CONTINUE
C------------------------------------------------------------
C
C     NATMOR IS TRASH RIGHT NOW.  IT WILL GET FILLED BACK UP.
C     HOWEVER, WE DON'T WANT TO USE OUR TRASH...
      CALL VICLR(NATMOR,1,L0)
C
      RETURN
 9002 FORMAT(/1X,'SVDEXTORBSNUM OPTION NOW SWITCHES',
     *        1X,'SOME ORBITAL TRANSFORM',
     *       /1X,'VECTORS TO KEEP THE TOP-MOST DEGENERATE VECTORS',
     *        1X,'FOR ATOM NUMBER=',I4)
 9003 FORMAT(1X,'ATOM NUMBER=',I4,1X,'GROUP=',I4,
     *       1X,'ACTIVE ORBITALS SWAPPING=',I4,I4)
      END
C*MODULE LOCAL   *DECK LOCAL_SVDVVOS_RMC_SETUP1
C> @brief      Returns MCSCF core and active orbital numbers.
C>
C> @author     Aaron West
C>             -March 16, 2013
C>
C> @details    This is a wrapper to avoid variable conflicts
C>             since I introduced new wave function types,etc.
C>             It will get used again.
C>
C> @param NCOR_GET denotes the number of MCSCF core orbitals.
C> @param NACT_GET denotes the number of MCSCF active orbitals.
C>
      SUBROUTINE LOCAL_SVDVVOS_RMC_SETUP1(NCOR_GET,NACT_GET)
      IMPLICIT NONE
C
      INTEGER NCOR_GET,NACT_GET
C
      DOUBLE PRECISION ::
     *       CRIT,DWPARM,GLIST,GRPDET,PRTTOL,SDET,SPINS,SZDET,
     *       WSTATE,STSYM
      INTEGER MXRT,IDWEIGH,IGPDET,IPURES,IROOT,IWTS,KDET,KSTDET,
     *        KSTSYM,MAXP,MAXW1,NACTDT,NADET,NBDET,NCI,NCOR,NCORSV,
     *        NFLGDM,NFTGCI,NITDET,NORBDT
C
      PARAMETER( MXRT=100 )
C
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,SDET,SZDET,
     *                GRPDET,STSYM,GLIST,DWPARM,
     *                NFLGDM(MXRT),IWTS(MXRT),NCORSV,NCOR,NACTDT,NORBDT,
     *                NADET,NBDET,KDET,KSTDET,IROOT,IPURES,MAXW1,NITDET,
     *                MAXP,NCI,IGPDET,KSTSYM,NFTGCI,IDWEIGH
C
C
      NCOR_GET=NCORSV
      NACT_GET=NACTDT
C
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_LMOEXT
C> @brief      Forms external LMOs.
C>
C> @author     Aaron West
C>             -March 14, 2013
C> @details    Forms external LMOs.
C>
C> @brief      This sub. combines LMOs.
C>
C> @author     Aaron West
C>             -March 16, 2013
C>
C> @details    This sub. involves the use of several
C>             localized orbitals.
C>             It then combines two sets of localized orbitals
C>             and outputs the VEC group into .log and .dat files.
C>
      SUBROUTINE LOCAL_LMOEXT
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL SOME,COMBO
      INTEGER IORBF1,IORBF52x,ISAV_ISVDOP,NERR
      INTEGER L0,L1,L3
      INTEGER NGOTMX,LOADFM,LAST,NEED_EXTLOC,LVEC1,LVEC2,LVEC3
      INTEGER L0MBS,I,ITMP,ISWMBS
      INTEGER NVVOS_NUMCOR
      INTEGER LOCAL_NUMVAL
      DOUBLE PRECISION :: SCFTYP_SAV,RHF,SVD,ATMNOS
      DOUBLE PRECISION :: EXTLOC_SAV
C-----------------------------------------------------------------------
      DOUBLE PRECISION :: X
C
      DOUBLE PRECISION :: C
      DOUBLE PRECISION :: ZAN
      INTEGER ICH,NQMT,NUM,MUL,NA,NAT,NB,NE,IAN
C
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
C
      LOGICAL ORIENT,ORIKIN,ORMFUL
      INTEGER NATMOR,ISVMOR,ISVDOP
      DOUBLE PRECISION :: EXTLOC,EREFATM
C
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION :: ETOLLZ
      INTEGER ILOCAL,IAHARD
C
      DOUBLE PRECISION ::
     *       RUNTYP,EXETYP,CHECK
      INTEGER NEVALS,NGLEVL,NHLEVL
C
      INTEGER IVVOS,NVVOS
      DOUBLE PRECISION ::
     *       BNDDEN
C
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C-----------------------------------------------------------------------
      INTEGER MXAO,MXATM
      PARAMETER (MXAO=8192, MXATM=2000)
C-----------------------------------------------------------------------
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /ORNTMO/ EXTLOC,EREFATM,
     *                NATMOR(MXAO),ISVMOR(MXATM),ISVDOP,
     *                ORIENT,ORIKIN,ORMFUL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /VVOPAR/ IVVOS,NVVOS,BNDDEN
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C-----------------------------------------------------------------------
C
C     DEFINE PRINT STUFF
      SOME = NPRINT.NE.-5 .AND. MASWRK
C
C     DATA STUFF
      DATA CHECK/8HCHECK   /
      DATA RHF/8HRHF     /
      DATA SVD/8HSVD     /
      DATA ATMNOS/8HATMNOS  /
C
C     DETERMINE IF ANALYSIS IS POSSIBLE.
C     IF NOT, EXIT OUT.
      COMBO=.FALSE.
      IF(EXTLOC.EQ.SVD) COMBO=.TRUE.
      IF(EXTLOC.EQ.ATMNOS) COMBO=.TRUE.
      IF(.NOT.COMBO) RETURN
C
C     PRINT BANNER
      IF(SOME) WRITE(IW,9000)
      CALL FLSHBF(IW)
C
C     CALCULATE L0MBS,ETC,FOR FUTURE USE.
      ISWMBS=1
      L0MBS=NVVOS_NUMCOR(0,0)
      DO I=1,NAT
        L0MBS=L0MBS+LOCAL_NUMVAL(I,ISWMBS)
      ENDDO
C
      ITMP=NVVOS_NUMCOR(0,0)
      DO I=1,NAT
        ITMP=ITMP+LOCAL_NUMVAL(I,0)
      ENDDO
C
C     ERROR OUTS
      NERR=0
      IF(ITMP.NE.L0MBS.AND.IVVOS.EQ.0) THEN
        IF(MASWRK) WRITE(IW,9002)
        NERR=NERR+1
      ENDIF
      IF(ILOCAL.EQ.4) THEN
        IF(MASWRK) WRITE(IW,9004)
        NERR=NERR+1
      ENDIF
C
      IF(NERR.GT.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     SKIP FOR EXETYP
      IF(EXETYP.EQ.CHECK) GO TO 8999
C
C     FORM EXTERNAL LOCALIZED ORBITALS.
C     NOTE1:  THE NEXT CALL REPLACES DAF FILE 71
C             ONLY IF NOT EXTLOC=SVD.
C     NOTE2:  THE RHF IS SETUP TO GRAB OUT THE EXTERNAL VIRTUALS.
C             SO, FAKE THE RHF SCFTYP.
      ISAV_ISVDOP=ISVDOP
      ISVDOP=0
      SCFTYP_SAV=SCFTYP
      SCFTYP=RHF
      EXTLOC_SAV=EXTLOC
      EXTLOC=SVD
      IORBF1=15 ! ,15,
      CALL LOCAL_LMOSVD(IORBF1)
      ISVDOP=ISAV_ISVDOP
      SCFTYP=SCFTYP_SAV
      EXTLOC=EXTLOC_SAV
C
C     PRINT OFF SECOND BANNER
      IF(SOME) WRITE(IW,9001)
      CALL FLSHBF(IW)
C
C     SET UP SOME DIMENSIONS
      L0 = NQMT
      L1 = NUM
      L3 = L1*L1
C
C     ALLOCATE MEMORY.
      CALL GOTFM(NGOTMX)
      CALL VALFM(LOADFM)
      LVEC1 = LOADFM + 1
      LVEC2 = LVEC1 + L3
      LVEC3 = LVEC2 + L3
      LAST  = LVEC3 + L3
      NEED_EXTLOC = LAST - LOADFM - 1
      CALL GETFM(NEED_EXTLOC)
C
C     COMBINE ORBITAL PIECES FROM 2 ORBITAL SETS
C     NOTE:  EXTERNALS MUST BE ORTHOGONAL TO INTERNALS AT THIS POINT.
C     DAF FILE 71  --> CONTAINS MBS LOCALIZED ORBITALS
C     DAF FILE 522 --> CONTAINS THE NEEDED EXTERNAL VIRTUALS.
C                  --> WANT THE NON-ORTHOGONAL VERSION
C                      WHERE THE MOS ARE ORTHOGONAL ONLY
C                      ON EACH ATOM.
C     ORBITAL PIECE 1 = CORE + OCCUPIEDS + VVOS
C     ORBITAL PIECE 2 = EXTERNALS
C     NOTE1:  FOR RHF, VVOS ARE SEPARATELY LOCALIZED.
C     NOTE2:  CORE ARE NOT LOCALIZED.
C             COULD EASILY BE DONE IN SEVERAL WAYS...
      CALL DAREAD(IDAF,IODA,X(LVEC1),L3,71,0)
      IORBF52x=522 ! ,522,
      CALL DAREAD(IDAF,IODA,X(LVEC2),L3,IORBF52x,0) ! ,522,521,
      CALL VCLR(X(LVEC3),1,L3)
C
C
      IF(IORBF52x.EQ.522) THEN
        IF(SOME) WRITE(IW,9020)
      ELSEIF(IORBF52x.EQ.521) THEN
        IF(SOME) WRITE(IW,9021)
      ELSE
        IF(SOME) WRITE(IW,9022)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
      CALL FLSHBF(IW)
C
C     ADD 'ER' INTERNALS TO 'SVD' EXTERNALS.
      CALL DCOPY(L1*L0,X(LVEC2),1,X(LVEC3),1)
      CALL DCOPY(L1*L0MBS,X(LVEC1),1,X(LVEC3),1)
      CALL VCLR(X(LVEC1),1,L3)
      CALL VCLR(X(LVEC2),1,L3)
C
C     SAVE ORBITALS OFF TO DAF FILE 534
      CALL DAWRIT(IDAF,IODA,X(LVEC3),L3,534,0)
C
C     PRINT OUT FINAL ER+EXT ORBITALS TO GAMESS .LOG FILE.
      IF(SOME) THEN
        WRITE(IW,9070)
        CALL PRSQL(X(LVEC3),L0,L1,L1)
      ENDIF
C
C     PRINT OUT ER+EXT ORBITALS TO .DAT FILE.
      IF(MASWRK) THEN
        WRITE(IP,9080)
        CALL PUSQL(X(LVEC3),L0,L1,L1)
        WRITE(IP,9085)
      ENDIF
C
C     DEALLOCATE MEMORY.
      CALL RETFM(NEED_EXTLOC)
C
C
 8999 CONTINUE
      IF(MASWRK) WRITE(IW,9300)
      CALL TIMIT(1)
      RETURN
 9000 FORMAT(/5X,60(1H-)/
     *   5X,'LOCAL_LMOEXT NOW FORMS LOCALIZED EXTERNAL ORBITALS.'/
     *   5X,'LOCAL_LMOEXT CALLS UPON LOCAL_LMOSVD.'/
     *   5X,60(1H-))
 9001 FORMAT(/5X,60(1H-)/
     *   5X,'LOCAL_LMOEXT COMBINES TWO ORBITAL SETS.'/
     *   5X,60(1H-))
 9002 FORMAT(//1X,'LOCAL_LMOEXT ERROR:',
     *        /1X,'EXT=SVD OPTION REQUIRES EITHER:',
     *        /1X,'1. FULL VALENCE ORBITAL SPACE',
     *        /1X,'2. VVOS RUN.')
 9004 FORMAT(//1X,'LOCAL_LMOEXT ERROR:',
     *        /1X,'ILOCAL=4 HAS FILE CONFLICTS FOR',
     *         1X,'EXTLMO=SVD OPTION.')
 9020 FORMAT(1X,'USING NONORTHOGONAL ORBITALS FROM FILE 522...')
 9021 FORMAT(1X,'USING ORTHOGONAL ORBITALS FROM FILE 521...')
 9022 FORMAT(//1X,'LOCAL_LMOEXT ERROR:',
     *        /1X,'IORBF52x FILE IS NOT APPROPRIATE.')
 9070 FORMAT(//10X,'OCCUPIED+SVD EXTERNAL LOCALIZED ORBITALS')
 9080 FORMAT('OCCUPIED+SVD EXTERNAL LOCALIZED ORBITALS'/' $VEC')
 9085 FORMAT(' $END')
 9300 FORMAT(1X,'... DONE WITH LOCAL_LMOEXT ...')
      END
C
C*MODULE LOCAL   *DECK LOCAL_COUNTAOS
C> @brief      return no. Cartesian and spherical AOs on atom IAT
C>
C> @author     Mike Schmidt
C>             -March 16, 2013
C>
C> @details    return no. Cartesian and spherical AOs on atom IAT
C>
C> @param IAT      is the atom number from the input file.
C> @param NAOCART  is the number of Cartesian AOs on atom IAT.
C> @param NAOSPH   is the number of spherical AOs on atom IAT.
C>
      SUBROUTINE LOCAL_COUNTAOS(IAT,NAOCART,NAOSPH)
      IMPLICIT NONE
C
      INTEGER NUMCART(8),NUMSPH(8)
      INTEGER I,IAT,ISH,KT,NAOCART,NAOSPH
C--------------------------------------------------------------------------
      DOUBLE PRECISION :: QMTTOL
      INTEGER ISPHER
C
      DOUBLE PRECISION :: EX,CS,CP,CD,CF,CG,CH,CI
      INTEGER KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL
C--------------------------------------------------------------------------
      INTEGER MXSH,MXGTOT
      PARAMETER (MXSH=5000, MXGTOT=20000)
C--------------------------------------------------------------------------
      COMMON /BASSPH/ QMTTOL,ISPHER
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
C--------------------------------------------------------------------------
C
C         s,p,d,f,g,h,i corresponds to KTYPE=1,2,3,4,5,6,7.
C
      NUMCART(1)=1
      DO I=2,7
        NUMCART(I) = NUMCART(I-1) + I
      ENDDO
      IF(ISPHER.EQ.1) THEN
        DO I=1,7
           NUMSPH(I)=2*I-1
        ENDDO
      ELSE
        DO I=1,7
           NUMSPH(I)=NUMCART(I)
        ENDDO
      END IF
C
C           L=SP shell is arbitrarily numbered 8.
C
      NUMCART(8)=4
      NUMSPH(8) =4
C
      NAOCART = 0
      NAOSPH  = 0
C
      DO 100 ISH=1,NSHELL
         IF(KATOM(ISH).LT.IAT) GO TO 100
         IF(KATOM(ISH).GT.IAT) RETURN
         KT = KTYPE(ISH)
         IF(KMIN(ISH).EQ.1  .AND.  KMAX(ISH).EQ.4) KT=8
         NAOCART = NAOCART + NUMCART(KT)
         NAOSPH  = NAOSPH  + NUMSPH(KT)
  100 CONTINUE
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_LCAO_WGHTS
C> @brief      Driver for lcao weight squared.
C>
C> @author     Aaron West and Klaus Ruedenberg
C>             -March 16, 2013
C>
C> @details    Driver for lcao weight squared.
C>             These weightings identify
C>             atom-orbital correspondence.
C>
      SUBROUTINE LOCAL_LCAO_WGHTS
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL SOME,COMBO
      INTEGER IORBF1,IORBF52x,NUML0,ITMPORB,I
      INTEGER L0,L1,L2,L3
      INTEGER NGOTMX,LOADFM,LAST,NEED_LCAO,
     *        LVEC1,LWGT,LWGT2,LWGTDUP,LIATORB,LIATORB2,LSUMORB,
     *        LIATSCR,LWGTSCR
      INTEGER NVVOS_NUMCOR
      INTEGER LOCAL_NUMVAL
      DOUBLE PRECISION :: CUTOFF_IATORB
      DOUBLE PRECISION :: ATMNOS,SVD,RNONE
      INTEGER NERR
C
      INTEGER IKIND
      INTEGER LVEC2,LVTORB,LSBAR,LSHAT,LVMAT,LWRKINV,LS,LIPVT,LIATSVD
C-----------------------------------------------------------------------
C
      INTEGER LIMLOW,LIMSUP
C
      DOUBLE PRECISION :: X
C
      DOUBLE PRECISION :: C
      DOUBLE PRECISION :: ZAN
      INTEGER ICH,NQMT,NUM,MUL,NA,NAT,NB,NE,IAN
C
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
C
      LOGICAL ORIENT,ORIKIN,ORMFUL
      INTEGER NATMOR,ISVMOR,ISVDOP
      DOUBLE PRECISION :: EXTLOC,EREFATM
C
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION :: ETOLLZ
      INTEGER ILOCAL,IAHARD
C
      DOUBLE PRECISION ::
     *       RUNTYP,EXETYP,CHECK
      INTEGER NEVALS,NGLEVL,NHLEVL
C
C-----------------------------------------------------------------------
      INTEGER MXAO,MXATM
      PARAMETER (MXAO=8192, MXATM=2000)
C-----------------------------------------------------------------------
      COMMON /ATLIM / LIMLOW(MXATM),LIMSUP(MXATM)
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /ORNTMO/ EXTLOC,EREFATM,
     *                NATMOR(MXAO),ISVMOR(MXATM),ISVDOP,
     *                ORIENT,ORIKIN,ORMFUL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C-----------------------------------------------------------------------
      PARAMETER (CUTOFF_IATORB=0.9D+00)
C-----------------------------------------------------------------------
C
C     DEFINE PRINT STUFF
      SOME = NPRINT.NE.-5 .AND. MASWRK
C
C     DATA STUFF
      DATA ATMNOS/8HATMNOS  /
      DATA CHECK/8HCHECK   /
      DATA SVD/8HSVD     /
      DATA RNONE/8HNONE    /
C
C     DETERMINE IF ANALYSIS IS POSSIBLE.
C     IF NOT, EXIT OUT.
      COMBO=.FALSE.
      IF(EXTLOC.EQ.SVD) COMBO=.TRUE.
      IF(EXTLOC.EQ.ATMNOS) COMBO=.TRUE.
      IF(ILOCAL.EQ.4) COMBO=.TRUE.
      IF(.NOT.COMBO) RETURN
C
C     PRINT BANNER
      IF(SOME) WRITE(IW,9001)
      CALL FLSHBF(IW)
C
C     SKIP FOR EXETYP
      IF(EXETYP.EQ.CHECK) GO TO 8999
C
C     SET UP SOME DIMENSIONS
      L0 = NQMT
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
C
C     JUST IN CASE, QUICK SETUP OF LIMLOW AND LIMSUP
      CALL AOLIM
C
C     CALCULATE A COMMON ORBITAL NUMBER
C     FOR POSSIBLE USE BELOW.
      ITMPORB=NVVOS_NUMCOR(0,0)
      DO I=1,NAT
        ITMPORB=ITMPORB+LOCAL_NUMVAL(I,0)
      ENDDO
C
C     FOR EACH CASE:
C     --SET SOME VARS.
C     --OBTAIN ORBITALS
C     NOTE:  DAF 521 SERVES TO DEFINE THE ATOM-ORBITAL CORRESPONDENCE.
C            OTHER ORBITALS SETS ARE RELATED TO DAF 521.
      IORBF1=0
      IORBF52x=521 ! ,521,
      IF(EXTLOC.EQ.SVD.OR.EXTLOC.EQ.ATMNOS) THEN
        NUML0=L0
        IORBF1=534 ! ,534,
      ELSEIF(ILOCAL.EQ.4) THEN
        NUML0=ITMPORB
        IORBF1=521 ! ,521,
        IF(ORIENT) IORBF1=286 ! ,286,
      ELSE
        IF(MASWRK) WRITE(IW,9002)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     ERROR OUT FOR IORBF1=0
      NERR=0
      IF(IORBF1.EQ.0) THEN
        IF(MASWRK) WRITE(IW,9110)
        NERR=NERR+1
      ENDIF
      IF(ORIENT.AND.EXTLOC.NE.RNONE) THEN
        IF(MASWRK) WRITE(IW,9111)
        NERR=NERR+1
      ENDIF
      IF(NERR.NE.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     ALLOCATE MEMORY.
      CALL GOTFM(NGOTMX)
      CALL VALFM(LOADFM)
      LVEC1     = LOADFM + 1
C     MEMORY FOR LACO WEIGHTS STUFF.
      LWGT      = LVEC1 + L3
      LWGT2     = LWGT  + NAT*NUML0
      LWGTDUP   = LWGT2 + NUML0
C     MEMORY FOR GETTING ATOM-ORBITAL CORRESPONDENCE
C            FOR LCAO STUFF.
      LIATORB   = LWGTDUP + NAT*NUML0
      LSUMORB   = LIATORB + NAT*NUML0
      LIATORB2  = LSUMORB + NUML0
C     MEMORY FOR GETTING ATOM-ORBITAL CORRESPONDENCE
C            FOR MO OVERLAP B/T QUASI-ATOMIC AND ER LOC. ORBITALS.
      LVEC2     = LIATORB2 + NAT*NUML0
C     MEMORY FOR OBTAINING ORBITAL TRANSFORMATION.
C            THIS SHOULD WORK FOR NON-ORTHOGONAL ORBITALS.
      LVTORB    = LVEC2   + L3
      LSBAR     = LVTORB  + L3
      LSHAT     = LSBAR   + L3
      LVMAT     = LSHAT   + L3
      LWRKINV   = LVMAT   + L3
      LS        = LWRKINV + L1
      LIPVT     = LS      + L2
      LIATSVD   = LIPVT   + L1
      LIATSCR   = LIATSVD + NUML0
C     MEMORY FOR INTEGER SCRATCH ARRAY FOR PRINT OFF.
      LWGTSCR   = LIATSCR + NAT
      LAST      = LWGTSCR + NAT
      NEED_LCAO = LAST - LOADFM - 1
      CALL GETFM(NEED_LCAO)
C
C
      CALL VCLR(X(LVEC1),1,L3)
      CALL VCLR(X(LWGT),1,NAT*NUML0)
      CALL VCLR(X(LWGT2),1,NUML0)
      CALL VICLR(X(LIATSVD),1,NUML0)
C
C     READ IN CHOSEN ORBITALS
      CALL DAREAD(IDAF,IODA,X(LVEC1),L3,IORBF1,0)
C
C----------LCAO SECTION----------------------------
C
C     OBTAIN THE RELATIVE LCAO WEIGHTINGS PER ATOM.
C     NOTE:  IKIND=0 --> LIATSVD IS NOT USED IN NEXT CALL.
      IKIND=0
      CALL LOCAL_LCAO_WGHTS2(
     *     X(LWGT),X(LWGT2),X(LVEC1),X(LIATSVD),
     *     LIMSUP,LIMLOW,
     *     NAT,NUML0,L1,MXATM,IKIND,IW,MASWRK)
C
C     PRINT ORBITAL ATOMIC WEIGHTS OFF TO THE LOG FILE.
      IF(SOME) THEN
        WRITE(IW,9005)
        WRITE(IW,9003) IORBF1,NAT,NUML0
        CALL PRSQ(X(LWGT),NUML0,NAT,NAT)
      ENDIF
C
C     OBTAIN THE ATOM LABEL(S) FOR EACH MO.
C     PRINT OFF THESE LABELS.
      CALL DCOPY(NAT*NUML0,X(LWGT),1,X(LWGTDUP),1)
      IF(SOME) WRITE(IW,9005)
      CALL LOCAL_LCAO_ATOM_LABELS(
     *     X(LWGT),X(LWGTDUP),X(LIATORB),X(LSUMORB),X(LIATSCR),
     *     X(LWGTSCR),CUTOFF_IATORB,NAT,NUML0,IW,SOME,MASWRK)
C
C----------MO OVERLAP SECTION------------------------
C
C     READ IN THE ORBITALS.
      CALL DAREAD(IDAF,IODA,X(LVEC1),L3,IORBF1,0)
      CALL DAREAD(IDAF,IODA,X(LVEC2),L3,IORBF52x,0)
C
C
      IF(SOME) WRITE(IW,9099)
      IF(IORBF52x.EQ.522) THEN
        IF(SOME) WRITE(IW,9100)
      ELSEIF(IORBF52x.EQ.521) THEN
        IF(SOME) WRITE(IW,9101)
      ELSE
        IF(SOME) WRITE(IW,9102)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
      CALL FLSHBF(IW)
C
C     GET THE ATOM NUMBERS FOR THE CHEMICAL CORE ORBITALS.
C     READ IN THE ATOM NUMBERS FOR FILE 528.
C     COMBINE THESE IN A DISJUNCT WAY.
C     ---NOTE:  WE DO NOT WANT TO DISTURB HOW FILE 528 WORKS.
C               THAT WOULD BE IDIOTIC AND A LOT OF WORK.
      CALL LOCAL_READ_FILE528_WITH_CORES(X(LIATSVD),NAT,NUML0,MASWRK)
C
C     CONSTRUCT THE MO OVERLAP BETWEEN
C     COLUMNS FROM QUASI-ATOMIC ORBITAL ON DAF FILE 521
C     AND
C     ROWS FROM ...
C     E.G.  ER SEP. LOC. 'OCCUPIED' ON DAF FILE 534
C     E.G.  DAF FILE 521 AGAIN
C     NOTE:  VEC1,VEC2 RATHER THAN VEC2,VEC1 MATTERS HERE.
C     NOTE:  NEXT CALL GIVES PRISTINE MATRIX.
C            I.E. NO GARBAGE OUTSIDE THE L0XL0 BLOCK.
      CALL MALMQ_TORB(
     *     X(LVEC1),X(LVEC2),X(LVTORB),X(LSBAR),X(LSHAT),
     *     X(LVMAT),X(LWRKINV),X(LIPVT),X(LS),L0,L1,L2,L3,
     *     0,L0,MASWRK)
C
C     PERFORM WEIGHTS ANALYSIS NOW ON MO OVERLAP RATHER THAN LCAO.
      IKIND=1
      CALL LOCAL_LCAO_WGHTS2(
     *     X(LWGT),X(LWGT2),X(LVTORB),X(LIATSVD),
     *     LIMSUP,LIMLOW,
     *     NAT,NUML0,L1,MXATM,IKIND,IW,MASWRK)
      IF(SOME) THEN
        WRITE(IW,9006)
        WRITE(IW,9003) IORBF1,NAT,NUML0
        CALL PRSQ(X(LWGT),NUML0,NAT,NAT)
      ENDIF
      CALL DCOPY(NAT*NUML0,X(LWGT),1,X(LWGTDUP),1)
      IF(SOME) WRITE(IW,9006)
      CALL LOCAL_LCAO_ATOM_LABELS(
     *     X(LWGT),X(LWGTDUP),X(LIATORB2),X(LSUMORB),X(LIATSCR),
     *     X(LWGTSCR),CUTOFF_IATORB,NAT,NUML0,IW,SOME,MASWRK)
C
C
C------------------------------------------------------
C----------END OF MO OVERLAP SECTION-------------------
C
C     DEALLOCATE MEMORY.
      CALL RETFM(NEED_LCAO)
C
C
 8999 CONTINUE
      IF(MASWRK) WRITE(IW,9300)
      CALL TIMIT(1)
      RETURN
C 9000 FORMAT(/1X,'SKIPPING LOCAL_LCAO_WGHTS:',
C     *       /1X,'LOCAL_LCAO_WGHTS CANNOT DETERMINE',
C     *        1X,'ORBITAL DAF FILE.')
 9001 FORMAT(/5X,60(1H-)/
     *   5X,'LOCAL_LCAO_WGHTS NOW ANALYZES',
     *   1X,'ATOMIC WEIGHTS SQUARED'/
     *   5X,'OF LCAO AND MO OVERLAP OF ORBITAL SET DEFINED BELOW.'/
     *   5X,60(1H-))
 9002 FORMAT(/1X,'ERROR IN LOCAL_LCAO_WGHTS:',
     *       /1X,'LOCAL_LCAO_WGHTS CANNOT DETERMINE',
     *        1X,'ORBITAL DAF FILE.')
 9003 FORMAT(/1X,'THE RELATIVE WEIGHTS SQUARED NOW FOLLOW.',
     *       /1X,'ORBITAL DAF FILE =',I5,
     *       /1X,'ROWS=ATOMS,COLUMNS=MOS',
     *       /1X,'INCLUDES CORE ORBITALS ON UP...',
     *       /1X,'NUMBER OF ATOMS =',I5,
     *       /1X,'NUMBER OF MOS   =',I5)
 9005 FORMAT(/1X,'NOW USING LCAO COEFFICIENTS',
     *        1X,'IN THE ANALYSIS... ')
 9006 FORMAT(/1X,'NOW USING MO OVERLAP COEFFICIENTS',
     *        1X,'IN THE ANALYSIS... ')
 9099 FORMAT(/1X,'A SET OF ATOMIC-LIKE MOLECULAR ORBITALS MUST',
     *        1X,'FOR A RELATIVE COMPARISON...')
 9100 FORMAT( 1X,'USING NONORTHOGONAL ORBITALS FROM FILE 522...')
 9101 FORMAT( 1X,'USING ORTHOGONAL ORBITALS FROM FILE 521...')
 9102 FORMAT(//1X,'ERROR IN LOCAL_LCAO_WGHTS:',
     *        /1X,'IORBF52x FILE IS NOT APPROPRIATE.')
 9110 FORMAT(/1X,'ERROR IN LOCAL_LCAO_WGHTS:',
     *       /1X,'IORBF1 DAF FILE EQUALS 0.  NO FILE SELECTED.')
 9111 FORMAT(/1X,'ERROR IN LOCAL_LCAO_WGHTS:',
     *       /1X,'NO NO. THIS WILL BE A SEPARATE RUN.',
     *       /1X,'THE LOCAL INPUT SHOULD HAVE PREVENTED US',
     *        1X,'US FROM REACHING HERE. PLEASE RE-THINK.')
 9300 FORMAT(1X,'... DONE WITH LCAO RELATIVE',
     *       1X,'ATOMIC WEIGHTS SQUARED ...')
      END
C*MODULE LOCAL   *DECK LOCAL_LCAO_WGHTS2
C> @brief      FORMS RELATIVE LCAO WEIGHTS SQUARED
C>
C> @author     Aaron West and Klaus Ruedenberg
C>             -March 16, 2013
C>
C> @details    FORMS RELATIVE LCAO WEIGHTS SQUARED.
C>             1.  LCAO COEFFICIENTS ARE SQUARED.
C>             2.  FOR EACH MO FOR EACH ATOM A,
C>                 THE LCAO**2 VALUES ARE SUMMED.
C>             3.  FOR EACH MO,
C>                 THESE VALUES ARE THEN NORMALIZED.
C>
C>
C> @param WGT    will contain the LCAO summed over one atom
C>               for each MO.
C>               i.e. NATxNUML0 array
C> @param WGT2   will contain the LCAO summed over all atoms
C>               per MO.
C>               i.e. NUML0 array
C> @param VEC    contains the LCAO for the MOs of interest.
C> @param IATSVD is an array from the SVD run itself
C>               that contains atom-orbital correspondences.
C> @param LIMSUP array contains the upper basis function on an atom.
C> @param LIMLOW array contains the lower basis function on an atom.
C> @param NAT    denotes number of atoms.
C> @param NUML0  denotes number of orbitals to be used in
C>               the LCAO weights squared analysis.
C> @param L1     is length of the AO basis.
C> @param MXATM  is max. number of atoms.
C> @param IKIND  is an integer to switch between using
C>               LCAO and MO OVERLAP.
C>               IKIND=0 --> USE LCAO ATOMS LIMITS
C>               IKIND=1 --> CONVERT SVD MO TO ATOMS
C> @param IW     indicates write out to the log file.
C> @param MASWRK is true for master process.
      SUBROUTINE LOCAL_LCAO_WGHTS2(
     *     WGT,WGT2,VEC,IATSVD,
     *     LIMSUP,LIMLOW,
     *     NAT,NUML0,L1,MXATM,IKIND,IW,MASWRK)
C
      IMPLICIT NONE
C     VARS
      LOGICAL MASWRK
      INTEGER L1,NUML0,NAT,MXATM,IKIND,IW
      INTEGER IATM1,IBAS1,IBAS2,I,K
      INTEGER LIMLOW(MXATM)
      INTEGER LIMSUP(MXATM)
      INTEGER IATSVD(NUML0)
      DOUBLE PRECISION :: SUM,TOTSUM,TMP
      DOUBLE PRECISION :: WGT(NAT,NUML0),WGT2(NUML0),VEC(L1,L1)
C
      CALL VCLR(WGT,1,NAT*NUML0)
      CALL VCLR(WGT2,1,NUML0)
C
C     SUM UP THE RELATIVE LCAO WEIGHTS ON EACH ATOM FOR EACH ORBITAL.
      IF(IKIND.EQ.0) THEN
        DO I=1,NUML0
          TOTSUM=0.0D+00
          DO IATM1=1,NAT
            IBAS1=LIMLOW(IATM1)
            IBAS2=LIMSUP(IATM1)
            SUM=0.0D+00
            DO K=IBAS1,IBAS2
              SUM=SUM+VEC(K,I)**2
            ENDDO
            WGT(IATM1,I)=SUM
            TOTSUM=TOTSUM+SUM
          ENDDO
          WGT2(I)=TOTSUM
        ENDDO
      ELSEIF(IKIND.EQ.1) THEN
        DO I=1,NUML0
          TOTSUM=0.0D+00
          DO K=1,NUML0
            IATM1=IATSVD(K)
            TMP=VEC(K,I)**2
            WGT(IATM1,I)=WGT(IATM1,I)+TMP
            WGT2(I)=WGT2(I)+TMP
          ENDDO
        ENDDO
      ENDIF
C
C     NORMALIZE ALL WEIGHTS ON EACH ORBITAL.
      DO I=1,NUML0
        DO IATM1=1,NAT
          WGT(IATM1,I)=WGT(IATM1,I)/WGT2(I)
        ENDDO
      ENDDO
C
C
      IF(IKIND.NE.0.AND.IKIND.NE.1) THEN
        IF(MASWRK) WRITE(IW,9001)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9001 FORMAT(//1X,'LOCAL_LCAO_WGHTS2 ERROR:',
     *        /1X,'IKIND=0 OR IKIND=1 ARE ONLY OPTIONS.')
      END
C*MODULE LOCAL   *DECK LOCAL_LCAO_ATOM_LABELS
C> @brief      Determines atom-orbital correspondence for LOCAL_LCAO.
C>
C> @author     Aaron West and Klaus Ruedenberg
C>             -March 19, 2013
C>
C> @details    The atom-orbital correspondence is determined
C>             based on summing the largest overlap coefficients
C>             up to a specified cutoff.
C>             These overlap coefficients might be
C>             LCAO coefficients or MO overlap for a particular
C>             reference set of orbitals.
C>
C> @param WGT           is the the relative weights squared array.
C>                      Dimensions are NATxNUML0.
C>                      i.e. number of atoms x some MOs.
C> @param WGTDUP        is a copy of the relative weights squared array.
C>                      Dimensions are NATxNUML0.
C>                      i.e. number of atoms x some MOs.
C> @param IATORB        is the integer array that will hold the
C>                      atom or atoms for a particular orbital.
C> @param SUMORB        is an integer array used to sum up the coefficients
C>                      from WGTDUP.
C> @param IATSCR        is an scratch integer array that is used for printing.
C> @param WGTSCR        is a scratch array that is used for printing.
C> @param CUTOFF_IATORB is the tolerance cut-off for assigning
C>                      the atoms to MOs.
C> @param NAT           is the total number of atoms.
C> @param NUML0         is the number of molecular orbital used.
C>                      It is based on the kind of localization.
C> @param IW            indicates write out to the log file.
C> @param SOME          is true for master process with nprint not equal -5.
C> @param MASWRK        indicates the master process.
      SUBROUTINE LOCAL_LCAO_ATOM_LABELS(
     *           WGT,WGTDUP,IATORB,SUMORB,IATSCR,
     *           WGTSCR,CUTOFF_IATORB,NAT,NUML0,IW,SOME,MASWRK)
C
      IMPLICIT NONE
C     VARS
      LOGICAL SOME,MASWRK
      INTEGER NAT,NUML0,JPOS,I,J,II,IW,IERR
      INTEGER IDAMAX,IXAMAX
      DOUBLE PRECISION :: TMP,CUTOFF_IATORB
C
      INTEGER IATORB(NAT,NUML0)
      INTEGER IATSCR(NAT)
      DOUBLE PRECISION :: WGT(NAT,NUML0),WGTDUP(NAT,NUML0),
     *                    SUMORB(NUML0),WGTSCR(NAT)
C
C     DO REQUIRED VCLR AND VICLR.
      CALL VCLR(SUMORB,1,NUML0)
      CALL VICLR(IATORB,1,NAT*NUML0)
C
C     GET THE ATOM LABELS.
      IERR=0
      DO 100 I=1,NUML0
        DO J=1,NAT
          IF(SUMORB(I).GT.CUTOFF_IATORB) GO TO 100
          JPOS=IDAMAX(NAT,WGTDUP(1,I),1)
          TMP=WGTDUP(JPOS,I)
          IF(TMP.LT.0.0D+00) IERR=IERR+1
          WGTDUP(JPOS,I)=0.0D+00
          SUMORB(I)=SUMORB(I)+TMP
          IATORB(JPOS,I)=1
        ENDDO
  100 CONTINUE
C
C     PRINT THE ATOM LABELS.
      IF(SOME) WRITE(IW,9000) CUTOFF_IATORB
      DO I=1,NUML0
        CALL VICLR(IATSCR,1,NAT)
        CALL VCLR(WGTSCR,1,NAT)
        II=0
        DO J=1,NAT
          IF(IATORB(J,I).EQ.1) THEN
            II=II+1
            IATSCR(II)=J
            WGTSCR(II)=WGT(J,I)
          ENDIF
        ENDDO
        IF(SOME) THEN
          WRITE(IW,9001) I,(IATSCR(J),J=1,II)
          WRITE(IW,9002) (WGTSCR(J),J=1,II)
        ENDIF
      ENDDO
C
C     ERROR OUT
      IF(IERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9003)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9000 FORMAT(//1X,'FOR EACH MOLECULAR ORBITAL,',
     *      /1X,'1. THE MAXIMUM RELATIVE COEFFICIENT',
     *       1X,'SQUARES ARE LOCATED.',
     *      /1X,'2. THESE MAXIMUM COEFFICIENTS ARE SUMMED UP.',
     *      /1X,'3. WHEN THE SUM IN POINT 2 REACHES THE CUTOFF,',
     *      /1X,'   THE ATOM LABELS ARE NO LONGER ASSIGNED.',
     *      /1X,'   CUTOFF=',1P,E10.2,
     *      /1X,'4. FOR MO OVERLAPS,',
     *      /1X,'   VALUES OF 1 DO NOT NECCESARILY INDICATE',
     *      /1X,'   ORBITAL OVERLAPS OF 1... QUITE THE CONTRARY.',
     *      /1X,'5. THE DISPLAYED ATOM LABELS ARE READ FROM',
     *      /1X,'   THE SVD ITSELF.  FOR DAF534, THE MO OVERLAPS',
     *      /1X,'   ARE STILL FORMED WITH SVD ORBITALS.',
     *      /1X,'   SO SVD ATOM LABELS ARE SUFFICIENT FOR NOW.',
     *      /1X,'6. DO NOT APPLY TO MALMQ_CIDRIV RESULTS.')

 9001 FORMAT(1X,'MO=',I5,1X,'HAS ATOM(S)=',100I5//)
 9002 FORMAT(10X,'WITH WEIGHT(S)=',100F5.2//)
 9003 FORMAT(/1X,'LOCAL_LCAO_ATOM_LABELS ERROR:',
     *       /1X,'IDAMAX SORTING DOES NOT WORK',
     *        1X,'WITH NEGATIVE VALUES.')
      END
C*MODULE LOCAL   *DECK LOCAL_READ_FILE528_WITH_CORES
C> @brief      Reads DAF file 528 and adds cores to it.
C>
C> @author     Aaron West
C>             -March 21, 2013
C>
C> @details    Reads DAF file 528 and adds cores to it.
C>             File 528 was designed to deal with general
C>             atom-orbital correspondence.
C>             Chemical core orbital atom-orbital correspondence
C>             is calculated from NVVOS_NUMCOR.
C>
C> @param IATSVD is the integer array that will hold the
C>               SVD-based atoms labels.
C> @param NAT    is the number of atoms.
C> @param NUML0  is the length of the 'active' orbitals.
C>               This is a bit varied based on the run.
C> @param MASWRK indicates the master process.
      SUBROUTINE LOCAL_READ_FILE528_WITH_CORES(IATSVD,NAT,NUML0,MASWRK)
C
      LOGICAL MASWRK
      INTEGER ITOT,IDUM,NAT,ITMP
      INTEGER IATSVD(NUML0)
      INTEGER NVVOS_NUMCOR
C
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
      CALL VICLR(IATSVD,1,NUML0)
C
      ITOT=0
      IDUM=1
      DO I=1,NAT
        ITMP=NVVOS_NUMCOR(I,1)
        ITOT=ITOT+ITMP
        IF(ITMP.NE.0) THEN
          DO J=IDUM,ITOT
            IATSVD(J)=I
          ENDDO
        ENDIF
        IDUM=ITOT+1
      ENDDO
      IDUM=IDUM-1
      ITMP=NUML0-IDUM
C
C     READ IN NON-CORES FROM FILE 528.
      CALL DAREAD(IDAF,IODA,IATSVD(IDUM+1),ITMP,528,1)
C
C     THE ARRAY SHOULD NOT HAVE ANY 0S.  TEST FOR THIS.
      ITMP=0
      DO I=1,NUML0
        IF(IATSVD(I).EQ.0) ITMP=1
      ENDDO
      IF(ITMP.GT.0) THEN
        IF(MASWRK) WRITE(IW,9001)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9001 FORMAT(//1X,'LOCAL_READ_FILE528_WITH_CORES ERROR:',
     *        /1X,'IATSVD ARRAY HAS 0S.  WRONG...')
      END
C*MODULE LOCAL   *DECK LOCAL_VVOS_ORB_RANGE
C> @brief      Automatically finds atom numbers for VVOS orbitals.
C>
C> @author     Aaron West
C>             -March 21, 2013
C>
C> @details    Finds atom numbers for VVOS orbitals.
C>             This is handy for determining which atoms
C>             are on which orbital and how many.
C>             In VVOS, the chemical core orbitals
C>             start at the beginning of each atom...
C>             i.e. all chem. cores are not at the beginning...
C>             This sub. deals with it.
C>
C> @param IPOSMBS takes an atom number and returns the
C>                very first VALENCE MBS-type orbital number.
C> @param ILENMBS takes an atom and returns the number
C>                of VALENCE MBS-type orbitals.
C> @param NAT     is the number of atoms.
      SUBROUTINE LOCAL_VVOS_ORB_RANGE(IPOSMBS,ILENMBS,NAT)
      IMPLICIT NONE
C
      INTEGER I,ITYPE,NCOR_NEVER,ITMP,NVAL,ISWMBS
      INTEGER LOCAL_NUMVAL
      INTEGER NVVOS_NUMCOR
      INTEGER NAT
      INTEGER IPOSMBS(NAT+1)
      INTEGER ILENMBS(NAT)
C
C     NOTES:
C     1.  GO BACK TO THE BASIC NVVOS_NUMCOR INFO HERE
C         SINCE VVOS IS IN MBS NUMBERS.
C     2.  GO BACK TO NVVOS_NUMCOR ATOM-BY-ATOM.
C         THIS PART TOOK ME A BIT TO REALIZE... AND DANCE.
C
      ITMP=1
      DO I=1,NAT
C
        ITYPE=1
        NCOR_NEVER=NVVOS_NUMCOR(I,ITYPE)
        ISWMBS=1
        NVAL=LOCAL_NUMVAL(I,ISWMBS)
C
        ILENMBS(I)=NVAL
C
        ITMP=ITMP+NCOR_NEVER
        IPOSMBS(I)=ITMP
        ITMP=ITMP+NVAL
C
      ENDDO
      IPOSMBS(NAT+1)=ITMP
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_ATOMIC_SPH_HARM
C> @brief      Makes atomic Q-matrix.
C>
C> @author     Mike Schmidt and Aaron West
C>             -April 08, 2013
C>
C> @details    Makes atomic Q-matrix.
C>             This is useful for avoiding diffuse
C>             orbital issues in the SVD.
C>
C> @param iiival     prints off if in core or valence orbital
C>                   code.
C>                   A 0 indicates core.
C>                   A 1 indicates valence.
C> @param S2         as input, this symmetric array contains
C>                   basis function overlap on atom IATM1.
C> @param ILTH       is the number of Cartesian basis functions
C>                   on atom IATM1.
C> @param ILTH_FIX   on exit, this integer denotes the number
C>                   of the spherical basis functions on atom IATM1.
C> @param IATM1      denotes the atom number.
C> @param KTYPE      is 1,2,3,4,5,6,7 for S,P,D,F,G,H,I.
C>                   L and P require more to be distinguished.
C>                   See 'documentation' in inputa.src for more info.
C> @param KATOM      indicates which atom the give shell
C>                   is centered on.
C> @param KMIN         contains the starting indices of the shells.
C> @param KMAX         contains the ending   indices of the shells.
C> @param NSHELL     is the total number of shells.
C>                   e.g. f is a shell.
C> @param ISIZSVD    is the workspace size for WRKSVD array.
C> @param L1         is the length of the AO basis.
C> @param L2         is the triangular length of L1.
C> @param L3         is L1xL1.
C> @param WSPHER     will hold the atomic Cartesian-to-Spherical
C>                   transformation matrix.
C>                   It is not normalized at the start.
C> @param UVEC       is a L1xL1 scratch array.
C> @param VTMP       is a L1xL1 scratch array.
C> @param S          is a L2 scratch array.
C> @param WRKSVD     is the work array designed for gldiag and
C>                   svd calls.
C> @param EIG        is a scratch array of length L1.
C> @param SAOMO      is a L1xL1 scratch array.
C> @param IWRK       is an integer scratch array of length L1.
C> @param TOL        is the tolerance for small eigenvalues
C>                   as input from the original tol parameter.
C> @param SOME       is true for master process
C>                   with nprint not equal -5.
C> @param MASWRK     indicates the master process.
C> @param IW         indicates write out to the log file.
C>
      SUBROUTINE LOCAL_ATOMIC_SPH_HARM(
     *           iiival,S2,ILTH,ILTH_FIX,IATM1,
     *           KTYPE,KATOM,KMIN,KMAX,NSHELL,
     *           ISIZSVD,L1,L2,L3,WSPHER,UVEC,VTMP,S,
     *           WRKSVD,EIG,SAOMO,IWRK,TOL,
     *           SOME,MASWRK,IW)
      IMPLICIT NONE
      LOGICAL SOME,MASWRK
      INTEGER iiival,IW,ISIZSVD,L1,L2,L3,ILTH,IATM1,ILTH_FIX,NSHELL,
     *        IKDIFF
      INTEGER I,J,N,NCONT_CART,NCONT_SPHER,I_CART,I_SPHER
      INTEGER KTYPE(NSHELL),KATOM(NSHELL),KMIN(NSHELL),KMAX(NSHELL)
      INTEGER IWRK(L2)
      DOUBLE PRECISION ::
     *       TOL,S2(L2),S(L2),WSPHER(L1,L1),VTMP(L1,L1),UVEC(L1,L1),
     *       WRKSVD(ISIZSVD),EIG(L1),SAOMO(L1,L1)
      INTEGER IERR2,IERR3
C
C-------------------------------------------------------------------
C-------------------------------------------------------------------
C      SPHERICAL HARMONIC LINEAR COMBINATION COEFFICIENTS
C      TAKEN FROM SPHMAK SUB. ON 4/5/2013
C      NOTE:  I'VE TAKEN OUT THE COMMENT LINES IN ORDER TO
C             STOP FTNCHK FROM COMPLAINING.
C-------------------------------------------------------------------
C-------------------------------------------------------------------
      INTEGER ISSPH(1,1),IPSPH(3,3),ILSPH(4,4),IDSPH(6,6),IFSPH(10,10),
     *        IGSPH(15,15),IHSPH(21,21),IISPH(28,28)

C
      DATA ISSPH/
     1  1/
C
      DATA IPSPH/
     1  1,  0,  0,
     2  0,  1,  0,
     3  0,  0,  1/
C
      DATA ILSPH/
     1  1,  0,  0,  0,
     2  0,  1,  0,  0,
     3  0,  0,  1,  0,
     4  0,  0,  0,  1/
C
      DATA IDSPH/
     1 -1, -1,  2,  0,  0,  0,
     2  1, -1,  0,  0,  0,  0,
     3  0,  0,  0,  1,  0,  0,
     4  0,  0,  0,  0,  1,  0,
     5  0,  0,  0,  0,  0,  1,
     6  1,  1,  1,  0,  0,  0/
C
      DATA IFSPH/
     1   1,  0,  0,  0,  0, -3,  0,  0,  0,  0,
     2   0,  0,  0,  0,  1,  0, -1,  0,  0,  0,
     3  -1,  0,  0,  0,  0, -1,  0,  4,  0,  0,
     4   0,  0,  2,  0, -3,  0, -3,  0,  0,  0,
     5   0, -1,  0, -1,  0,  0,  0,  0,  4,  0,
     6   0,  0,  0,  0,  0,  0,  0,  0,  0,  1,
     7   0, -1,  0,  3,  0,  0,  0,  0,  0,  0,
     8   1,  0,  0,  0,  0,  1,  0,  1,  0,  0,
     9   0,  1,  0,  1,  0,  0,  0,  0,  1,  0,
     1   0,  0,  1,  0,  1,  0,  1,  0,  0,  0/
C
      DATA IGSPH/
     1  1,  1,  0,  0,  0,  0,  0,  0,  0, -6,  0,  0,  0,  0,  0,
     2  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0, -3,  0,
     3 -1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  6, -6,  0,  0,  0,
     4  0,  0,  0,  0, -3,  0,  0,  4,  0,  0,  0,  0,  0, -3,  0,
     5  3,  3,  8,  0,  0,  0,  0,  0,  0,  6,-24,-24,  0,  0,  0,
     6  0,  0,  0,  0,  0,  0, -3,  0,  4,  0,  0,  0, -3,  0,  0,
     7  0,  0,  0, -1,  0, -1,  0,  0,  0,  0,  0,  0,  0,  0,  6,
     8  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0, -3,  0,  0,
     9  0,  0,  0,  1,  0, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     1  1,  1,  1,  0,  0,  0,  0,  0,  0,  2,  2,  2,  0,  0,  0,
     2 -1, -1,  2,  0,  0,  0,  0,  0,  0, -2,  1,  1,  0,  0,  0,
     3  1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  1, -1,  0,  0,  0,
     4  0,  0,  0,  1,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  1,
     5  0,  0,  0,  0,  1,  0,  0,  1,  0,  0,  0,  0,  0,  1,  0,
     6  0,  0,  0,  0,  0,  0,  1,  0,  1,  0,  0,  0,  1,  0,  0/
C
      data ihsph/
     1  1,  0,  0,  0,  0,  5,  0,  0,  0,-10,  0,  0,  0,  0,  0,    !  +5
     1  0,  0,  0,  0,  0,  0,
     2  0,  0,  0,  0,  1,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,    !  +4
     2  0,  0,  0, -6,  0,  0,
     3 -1,  0,  0,  0,  0,  3,  0,  0,  0,  2,  8,  0,  0,  0,  0,    !  +3
     3  0,  0,  0,  0,  0,-24,
     4  0,  0,  0,  0, -1,  0,  1,  0,  0,  0,  0,  0,  0,  2, -2,    !  +2
     4  0,  0,  0,  0,  0,  0,
     5  1,  0,  0,  0,  0,  1,  0,  8,  0,  2,-12,  0,  0,  0,  0,    !  +1
     5  0,  0,  0,  0,  0,-12,
     6  0,  0,  8,  0, 15,  0, 15,  0,  0,  0,  0,  0,  0,-40,-40,    !   0
     6  0,  0,  0, 30,  0,  0,
     7  0,  1,  0,  1,  0,  0,  0,  0,  8,  0,  0,  2,-12,  0,  0,    !  -1
     7  0,  0,  0,  0,-12,  0,
     8  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,    !  -2
     8 -1, -1,  2,  0,  0,  0,
     9  0,  1,  0, -3,  0,  0,  0,  0,  0,  0,  0, -2, -8,  0,  0,    !  -3
     9  0,  0,  0,  0, 24,  0,
     *  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,    !  -4
     *  1, -1,  0,  0,  0,  0,
     1  0,  1,  0,  5,  0,  0,  0,  0,  0,  0,  0,-10,  0,  0,  0,    !  -5
     1  0,  0,  0,  0,  0,  0,
     2  1,  0,  0,  0,  0,  1,  0,  1,  0,  2,  2,  0,  0,  0,  0,    !   1
     2  0,  0,  0,  0,  0,  2,
     3  0,  1,  0,  1,  0,  0,  0,  0,  1,  0,  0,  2,  2,  0,  0,    !   1
     3  0,  0,  0,  0,  2,  0,
     4  0,  0,  1,  0,  1,  0,  1,  0,  0,  0,  0,  0,  0,  2,  2,    !   0
     4  0,  0,  0,  2,  0,  0,
     5  1,  0,  0,  0,  0, -3,  0,  0,  0, -2,  1,  0,  0,  0,  0,    !   3
     5  0,  0,  0,  0,  0, -3,
     6  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,    !   2
     6  1,  1,  1,  0,  0,  0,
     7 -1,  0,  0,  0,  0, -1,  0,  4,  0, -2,  3,  0,  0,  0,  0,    !   1
     7  0,  0,  0,  0,  0,  3,
     8  0,  0,  2,  0, -3,  0, -3,  0,  0,  0,  0,  0,  0, -1, -1,    !   0
     8  0,  0,  0, -6,  0,  0,
     9  0, -1,  0, -1,  0,  0,  0,  0,  4,  0,  0, -2,  3,  0,  0,    !   1
     9  0,  0,  0,  0,  3,  0,
     *  0,  0,  0,  0,  1,  0, -1,  0,  0,  0,  0,  0,  0,  1, -1,    !   2
     *  0,  0,  0,  0,  0,  0,
     1  0, -1,  0,  3,  0,  0,  0,  0,  0,  0,  0,  2, -1,  0,  0,    !   3
     1  0,  0,  0,  0,  3,  0/
C
      data iisph/
     1   1,  -1,   0,   0,   0,   0,   0,   0,   0, -15,    !  +6
     1   0,  15,   0,   0,   0,   0,   0,   0,   0,   0,
     1   0,   0,   0,   0,   0,   0,   0,   0,
     2   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,    !  +5
     2   0,   0,   0,   0,   0,   0,   5,   0,   0,   0,
     2   0, -10,   0,   0,   0,   0,   0,   0,
     3  -1,  -1,   0,   0,   0,   0,   0,   0,   0,   5,    !  +4
     3  10,   5,  10,   0,   0,   0,   0,   0,   0,   0,
     3   0,   0,   0,   0,   0,   0,   0, -60,
     4   0,   0,   0,   0,  -3,   0,   0,   0,   0,   0,    !  +3
     4   0,   0,   0,   0,   0,   0,   9,   0,   0,   8,
     4   0,   6,   0,   0,   0,   0, -24,   0,
     5   1,  -1,   0,   0,   0,   0,   0,   0,   0,   1,    !  +2
     5 -16,  -1,  16,  16, -16,   0,   0,   0,   0,   0,
     5   0,   0,   0,   0,   0,   0,   0,   0,
     6   0,   0,   0,   0,  10,   0,   0,  16,   0,   0,    !  +1
     6   0,   0,   0,   0,   0,   0,  10,   0,   0, -40,
     6   0,  20,   0,   0,   0,   0, -40,   0,
     7  -5,  -5,  16,   0,   0,   0,   0,   0,   0, -15,    !   0
     7  90, -15,  90,-120,-120,   0,   0,   0,   0,   0,
     7   0,   0,   0,   0,   0,   0,   0, 180,
     8   0,   0,   0,   0,   0,   0,  10,   0,  16,   0,    !  -1
     8   0,   0,   0,   0,   0,  10,   0,   0,   0,   0,
     8 -40,   0,   0,  20,   0, -40,   0,   0,
     9   0,   0,   0,   1,   0,   1,   0,   0,   0,   0,    !  -2
     9   0,   0,   0,   0,   0,   0,   0,  16,   2,   0,
     9   0,   0, -16,   0, -16,   0,   0,   0,
     *   0,   0,   0,   0,   0,   0,   3,   0,   0,   0,    !  -3
     *   0,   0,   0,   0,   0,  -9,   0,   0,   0,   0,
     *  -8,   0,   0,  -6,   0,  24,   0,   0,
     1   0,   0,   0,  -4,   0,   4,   0,   0,   0,   0,    !  -4
     1   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
     1   0,   0,  40,   0, -40,   0,   0,   0,
     2   0,   0,   0,   0,   0,   0,   1,   0,   0,   0,    !  -5
     2   0,   0,   0,   0,   0,   5,   0,   0,   0,   0,
     2   0,   0,   0, -10,   0,   0,   0,   0,
     3   0,   0,   0,   6,   0,   6,   0,   0,   0,   0,    !  -6
     3   0,   0,   0,   0,   0,   0,   0,   0, -20,   0,
     3   0,   0,   0,   0,   0,   0,   0,   0,
     4   1,   1,   1,   0,   0,   0,   0,   0,   0,   3,    !   0
     4   3,   3,   3,   3,   3,   0,   0,   0,   0,   0,
     4   0,   0,   0,   0,   0,   0,   0,   6,
     5  -1,  -1,   2,   0,   0,   0,   0,   0,   0,  -3,    !   0
     5   0,  -3,   0,   3,   3,   0,   0,   0,   0,   0,
     5   0,   0,   0,   0,   0,   0,   0,   0,
     6   0,   0,   0,   1,   0,   1,   0,   0,   0,   0,    !   2
     6   0,   0,   0,   0,   0,   0,   0,   1,   2,   0,
     6   0,   0,   2,   0,   2,   0,   0,   0,
     7   1,  -1,   0,   0,   0,   0,   0,   0,   0,   1,    !   2
     7   2,  -1,  -2,   1,  -1,   0,   0,   0,   0,   0,
     7   0,   0,   0,   0,   0,   0,   0,   0,
     8   0,   0,   0,   0,   1,   0,   0,   1,   0,   0,    !   1
     8   0,   0,   0,   0,   0,   0,   1,   0,   0,   2,
     8   0,   2,   0,   0,   0,   0,   2,   0,
     9   0,   0,   0,   0,   0,   0,   1,   0,   1,   0,    !   1
     9   0,   0,   0,   0,   0,   1,   0,   0,   0,   0,
     9   2,   0,   0,   2,   0,   2,   0,   0,
     *   1,   1,   0,   0,   0,   0,   0,   0,   0,  -5,    !   4
     *   1,  -5,   1,   0,   0,   0,   0,   0,   0,   0,
     *   0,   0,   0,   0,   0,   0,   0,  -6,
     1   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,    !   3
     1   0,   0,   0,   0,   0,   0,  -3,   0,   0,   1,
     1   0,  -2,   0,   0,   0,   0,  -3,   0,
     2  -1,   1,   0,   0,   0,   0,   0,   0,   0,  -1,    !   2
     2   5,   1,  -5,   6,  -6,   0,   0,   0,   0,   0,
     2   0,   0,   0,   0,   0,   0,   0,   0,
     3   0,   0,   0,   0,  -3,   0,   0,   4,   0,   0,    !   1
     3   0,   0,   0,   0,   0,   0,  -3,   0,   0,   1,
     3   0,  -6,   0,   0,   0,   0,   1,   0,
     4   3,   3,   8,   0,   0,   0,   0,   0,   0,   9,    !   0
     4 -21,   9, -21, -16, -16,   0,   0,   0,   0,   0,
     4   0,   0,   0,   0,   0,   0,   0, -42,
     5   0,   0,   0,   0,   0,   0,  -3,   0,   4,   0,    !   1
     5   0,   0,   0,   0,   0,  -3,   0,   0,   0,   0,
     5   1,   0,   0,  -6,   0,   1,   0,   0,
     6   0,   0,   0,  -1,   0,  -1,   0,   0,   0,   0,    !   2
     6   0,   0,   0,   0,   0,   0,   0,   6,  -2,   0,
     6   0,   0,   5,   0,   5,   0,   0,   0,
     7   0,   0,   0,   0,   0,   0,  -1,   0,   0,   0,    !   3
     7   0,   0,   0,   0,   0,   3,   0,   0,   0,   0,
     7  -1,   0,   0,   2,   0,   3,   0,   0,
     8   0,   0,   0,   1,   0,  -1,   0,   0,   0,   0,    !   4
     8   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
     8   0,   0,   1,   0,  -1,   0,   0,   0/
C-------------------------------------------------------------------
C-------------------------------------------------------------------
C     END OF SPHERICAL HARMONIC LINEAR COMBINATION COEFFICIENTS
C-------------------------------------------------------------------
C-------------------------------------------------------------------
C
C     CLEAR OUT THE NEEDED ARRAYS.
      CALL VCLR(WSPHER,1,L3)
C
C     GRAB OUT THE NON-NORMALIZED LINEAR TRANSFORMATION
C     FROM SPHERICAL-TO-CARTESIANS.
      NCONT_CART =0
      NCONT_SPHER=0
      DO 100 N=1,NSHELL
C---------------------------------------
         IF(KATOM(N).NE.IATM1) GO TO 100
C---------------------------------------
C        S SHELL: L=0
         IF(KTYPE(N).EQ.1) THEN
            I_CART=1
            I_SPHER=1
            DO I=1,I_CART
               DO J=1,I_SPHER
                  WSPHER(NCONT_CART+I,NCONT_SPHER+J)
     *            =DBLE(ISSPH(I,J))
               ENDDO
            ENDDO
            NCONT_CART=NCONT_CART+I_CART
            NCONT_SPHER=NCONT_SPHER+I_SPHER
         ENDIF
C---------------------------------------
C        P SHELL: L=1
         IKDIFF=KMAX(N)-KMIN(N)+1
         IF(KTYPE(N).EQ.2.AND.IKDIFF.NE.4) THEN
            I_CART=3
            I_SPHER=3
            DO I=1,I_CART
               DO J=1,I_SPHER
                  WSPHER(NCONT_CART+I,NCONT_SPHER+J)
     *            =DBLE(IPSPH(I,J))
               ENDDO
            ENDDO
            NCONT_CART=NCONT_CART+I_CART
            NCONT_SPHER=NCONT_SPHER+I_SPHER
         ENDIF
C---------------------------------------
C        L=SP SHELL: L=1
         IKDIFF=KMAX(N)-KMIN(N)+1
         IF(KTYPE(N).EQ.2.AND.IKDIFF.EQ.4) THEN
            I_CART=4
            I_SPHER=4
            DO I=1,I_CART
               DO J=1,I_SPHER
                  WSPHER(NCONT_CART+I,NCONT_SPHER+J)
     *            =DBLE(ILSPH(I,J))
               ENDDO
            ENDDO
            NCONT_CART=NCONT_CART+I_CART
            NCONT_SPHER=NCONT_SPHER+I_SPHER
         ENDIF
C---------------------------------------
C        D SHELL: L=2
         IF(KTYPE(N).EQ.3) THEN
            I_CART=6
            I_SPHER=5
            DO I=1,I_CART
               DO J=1,I_SPHER
                  WSPHER(NCONT_CART+I,NCONT_SPHER+J)
     *            =DBLE(IDSPH(I,J))
               ENDDO
            ENDDO
            NCONT_CART=NCONT_CART+I_CART
            NCONT_SPHER=NCONT_SPHER+I_SPHER
         ENDIF
C---------------------------------------
C        F SHELL: L=3
         IF(KTYPE(N).EQ.4) THEN
            I_CART=10
            I_SPHER=7
            DO I=1,I_CART
               DO J=1,I_SPHER
                  WSPHER(NCONT_CART+I,NCONT_SPHER+J)
     *            =DBLE(IFSPH(I,J))
               ENDDO
            ENDDO
            NCONT_CART=NCONT_CART+I_CART
            NCONT_SPHER=NCONT_SPHER+I_SPHER
         ENDIF
C---------------------------------------
C        G SHELL: L=4
         IF(KTYPE(N).EQ.5) THEN
            I_CART=15
            I_SPHER=9
            DO I=1,I_CART
               DO J=1,I_SPHER
                  WSPHER(NCONT_CART+I,NCONT_SPHER+J)
     *            =DBLE(IGSPH(I,J))
               ENDDO
            ENDDO
            NCONT_CART=NCONT_CART+I_CART
            NCONT_SPHER=NCONT_SPHER+I_SPHER
         ENDIF
C---------------------------------------
C        H SHELL: L=5
         IF(KTYPE(N).EQ.6) THEN
            I_CART=21
            I_SPHER=11
            DO I=1,I_CART
               DO J=1,I_SPHER
                  WSPHER(NCONT_CART+I,NCONT_SPHER+J)
     *            =DBLE(IHSPH(I,J))
               ENDDO
            ENDDO
            NCONT_CART=NCONT_CART+I_CART
            NCONT_SPHER=NCONT_SPHER+I_SPHER
         ENDIF
C---------------------------------------
C        I SHELL: L=6
         IF(KTYPE(N).EQ.7) THEN
            I_CART=28
            I_SPHER=13
            DO I=1,I_CART
               DO J=1,I_SPHER
                  WSPHER(NCONT_CART+I,NCONT_SPHER+J)
     *            =DBLE(IISPH(I,J))
               ENDDO
            ENDDO
            NCONT_CART=NCONT_CART+I_CART
            NCONT_SPHER=NCONT_SPHER+I_SPHER
         ENDIF
C---------------------------------------
  100 CONTINUE
C
C     CHECK THAT NCONT_CART MATCHES THE ILTH VARIABLE.
      IF(NCONT_CART.NE.ILTH) THEN
         IF(MASWRK) WRITE(IW,9000)
         CALL FLSHBF(IW)
         CALL ABRT
         STOP
      ENDIF
C
C     SET ILTH_FIX
      ILTH_FIX=NCONT_SPHER
C
C     CONSTRUCT THE (ILTH_FIX,ILTH_FIX) W-TRANS*S_ATOMIC*W MATRIX
C     THANKS MIKE SCHMIDT!
      CALL DCOPY(L2,S2,1,S,1)
      CALL VCLR(S2,1,L2)
      CALL TFTRI(S2,S,WSPHER,UVEC,ILTH_FIX,ILTH,L1)
C
C     DIAGONALIZE THIS MATRIX.
      IERR2=0
      CALL VCLR(VTMP,1,L3)
      CALL GLDIAG(L1,ILTH_FIX,ILTH_FIX,S2,WRKSVD,EIG,VTMP,IERR2,IWRK)
      IF(IERR2.GT.0) GO TO 8999
      IERR3=0
      DO I=1,ILTH_FIX
        IF(EIG(I).LT.TOL) IERR3=IERR3+1
        EIG(I)=1.0D+00/SQRT(EIG(I))
C       WRITE(IW,*) "IATM1,I,EIG=",IATM1,I,EIG(I)
      ENDDO
      IF(IERR3.GT.0) GO TO 8999
      CALL VCLR(UVEC,1,L3)
      DO I=1,ILTH_FIX
        DO J=1,ILTH_FIX
          UVEC(I,J)=VTMP(J,I)
          UVEC(J,I)=VTMP(I,J)
        ENDDO
      ENDDO
      DO I=1,ILTH_FIX
        CALL DSCAL(ILTH_FIX,EIG(I),VTMP(1,I),1)
      ENDDO
C     DO MATVEC TO S_IATM1**(-1/2)
      CALL VCLR(SAOMO,1,L3)
      CALL MRARBR(VTMP,L1,ILTH_FIX,ILTH_FIX,
     *            UVEC,L1,ILTH_FIX,
     *            SAOMO,L1)
      CALL DCOPY(L3,SAOMO,1,VTMP,1)
C
C     VTMP NOW CONTAINS THE CORRECT [W*S**(-1/2)]-TRANSPOSE
C     OF THE ORTHOGONALIZING MATRIX.
C     NOTES:
C     --THE TRANSPOSE IS DONE B/C IN THE ORIGINAL VERSION,
C       THE AOS ARE KEPT ON THE LEFT HAND SIDE.
C       THEN, THE DIMENSIONS WORK OUT AS
C             (ILTH_FIX,ILTH)*(ILTH,ILTH)*(ILTH,NACT)
C       IN ORDER TO VIEW THE UNIT MATRIX ON EACH ATOM, DO THE FOLLOWING:
C       --UN-DO THE TRANSPOSE ABOVE.
C       --RE-LOAD THE AO OVERLAPS ON THE GIVEN ATOM INTO S2
C       --PERFORM TFTRI OF VTMP-TRANS*S2*VTMP...CAREFUL OF YOUR DIMENSIONS HERE!
C       --USE PRTRI TO VIEW THE UNIT MATRIX.
C       AND SEE THE UNIT MATRIX,
      CALL VCLR(UVEC,1,L3)
      CALL MRARBR(WSPHER,L1,ILTH,ILTH_FIX,VTMP,L1,ILTH_FIX,UVEC,L1)
      CALL DCOPY(L3,UVEC,1,VTMP,1)
      CALL VCLR(UVEC,1,L3)
      CALL TRPOSQ(VTMP,L1)
C
C     PRINT IN .LOG FILE THAT WE GO INTO THIS ROUTINE.
      IF(IATM1.EQ.1.AND.SOME.AND.iiival.eq.0) WRITE(IW,9010)
      IF(IATM1.EQ.1.AND.SOME.AND.iiival.eq.1) WRITE(IW,9011)
C
C     PERFORM ANY ERROR OUTS AND EXIT OUT.
 8999 CONTINUE
      IF(MASWRK) THEN
        IF(IERR2.GT.0) THEN
          WRITE(IW,9003)
        ELSEIF(IERR3.GT.0) THEN
          WRITE(IW,9004) IERR3
        ENDIF
      ENDIF
      IF(IERR2.GT.0
     *  .OR.IERR3.GT.0
     *  ) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9000 FORMAT(//1X,'LOCAL_ATOMIC_SPH_HARM ERROR:',
     *        /1X,'NCONT_CART DOES NOT MATCH ILTH.',
     *         1X,'IT SHOULD MATCH ILTH...')
 9003 FORMAT(//1X,'LOCAL_ATOMIC_SPH_HARM ERROR:',
     *        /1X,'ERROR OCCURS FOR GLDIAG CALL.')
 9004 FORMAT(//1X,'LOCAL_ATOMIC_SPH_HARM ERROR:',
     *       1X,'IN SYMMETRIC ORTHOG., ',
     *       1X,I4,' EIGENVALUES ARE BELOW TOL.',
     *       1X,I4,' IF USING SVDEXTORBSNUM OPTION,.',
     *       1X,I4,' PROBLEM MIGHT BE RELATED WITH QMTTOL.')
 9010 FORMAT(1X,'FORMING ATOMIC SPHERICAL HARMONICS',
     *       1X,'FOR CORE ORBITALS.')
 9011 FORMAT(1X,'FORMING ATOMIC SPHERICAL HARMONICS',
     *       1X,'FOR VALENCE ORBITALS.')
      END
C*MODULE LOCAL   *DECK LOCAL_NOS_EXT
C> @brief      Forms atomic external NOs.
C>
C> @author     Aaron West
C>             -March 21, 2013
C>
C> @details    Forms atomic external NOs.
C>             There are three similar NOS_EXT routines.
C>             Some parts must remain the identical.
C>             I will add more later.
C>
      SUBROUTINE LOCAL_NOS_EXT
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL SOME,OK,COMBO
C
      INTEGER MCORE,NERR,IMOPROJ,IEXTORB,ISIZE_FCCWFN
      INTEGER NHIGH,NELS,III_NEXT,III_OCC_ORB,III_DIRECT,IEXCIT
C
      DOUBLE PRECISION :: ATMNOS,ORMAS,RMC,RHF,RNONE
C
      INTEGER I,J,IJ,ISAV_NOS,ICOUNT_NOS,IOPTION
C
      INTEGER L0,L1,L2,L3,L0MBS,L0TRI
      INTEGER ITOTOCC,MAX_NACT_ORBS,MAX_NACT_ORBS_TRI
C
      INTEGER IATM1,ISWMBS
      INTEGER LOCAL_NUMVAL
      INTEGER NVVOS_NUMCOR
C-----MEMORY VARIABLES
      INTEGER NGOTMX,LOADFM,LAST,NEED_NOS_EXT,NEED_NOS_EXT2
c     persistent mem vars
      INTEGER LS,LVECF15SAV,LVECCOL,LVEC,LIPOSMBS,LILENMBS,LIATSVD,
     *        LIPOSEXT
      INTEGER LEIGHLD
c     mini-mem #1 mem vars
      INTEGER LMOIRP,LMOLAB
c     mini-mem #2 - #4 mem vars
      INTEGER LVEC2,LVEC3,LVEC534,LSVMBS,LEIG
      INTEGER LWRK,LIWRK,LDEN
      INTEGER LSTRI,LIWRKP,LRADWGT,LSAVWGT
C-----END OF MEMORY VARIABLES
      CHARACTER*5 CICODE
      DOUBLE PRECISION :: FANT,GANT
      INTEGER LFANT
      INTEGER NRNFG(10),NPFLG2(10)
C
      DOUBLE PRECISION :: TMP,ENUC
      INTEGER II,ITMP,ITMP2,IERR,ICHK,ICHK2,IKIND
C-----------------------------------------------------------------------
C
      LOGICAL ANALYS,SAFLG
      INTEGER ICLBBR,IPRTSA
C
      DOUBLE PRECISION ::
     *       CRIT,DWPARM,GLIST,GRPDET,PRTTOL,S,SPINS,SZ,
     *       WSTATE,STSYM
      INTEGER IDWEIGH,IGPDET,IPURES,IROOT,IWTS,KDET,KSTDET,
     *        KSTSYM,MAXP,MAXW1,NACTDT,NADET,NBDET,NCI,NCOR,NCORSV,
     *        NFLGDM,NFTGCI,NITDET,NORBDT
C
      DOUBLE PRECISION ::
     *       ENUCR,EELCT,ETOT,STOT,SZZ,ECORE,ESCF,EERD,E1,E2,
     *       VEN,VEE,EPOT,EKIN,ESTATE,STATN,EDFT,EDISP
C
      LOGICAL FDIRCT,QCORR
      INTEGER NSPACE,MSTA,MNUM,MINI,MAXI,IAMI,IAMA,IBMI,IBMA,IDIMFCC,
     *        LBST,NREF0
      DOUBLE PRECISION :: C0SQ
C
      LOGICAL BLOCK
C
      DOUBLE PRECISION :: X
C
      DOUBLE PRECISION :: C
      DOUBLE PRECISION :: ZAN
      INTEGER ICH,NQMT,NUM,MUL,NA,NAT,NB,NE,IAN
C
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
C
      LOGICAL CANONC,FCORE,FORS,EKT,LINSER
      DOUBLE PRECISION ::
     *       FINALCI,METHOD,CISTEP,ACURCY,ENGTOL,DAMP
      INTEGER MICIT,NWRDMC,NORBMC,NOROT,MOFRZ,
     *        NPFLG,NOFO,MCFMO,IDIABAT
C
      LOGICAL ORIENT,ORIKIN,ORMFUL
      INTEGER NATMOR,ISVMOR,ISVDOP
      DOUBLE PRECISION :: EXTLOC,EREFATM
C
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION ::
     *       RUNTYP,EXETYP,CHECK
      INTEGER NEVALS,NGLEVL,NHLEVL
C
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C
      INTEGER IVVOS,NVVOS
      DOUBLE PRECISION ::
     *       BNDDEN
C
C-----------------------------------------------------------------------
      INTEGER MXAO,MXATM,MXRT,MXNORO
      PARAMETER (MXAO=8192, MXATM=2000, MXRT=100, MXNORO=250)
      INTEGER ISIZE_EDFT
      PARAMETER (ISIZE_EDFT=2)
C-----------------------------------------------------------------------

C-----------------------------------------------------------------------
C     EXTENSIVE LIST OF CLONED VARS.
C-----------------------------------------------------------------------
C
      LOGICAL ANALYS_SAV,SAFLG_SAV
      INTEGER ICLBBR_SAV,IPRTSA_SAV
C
      DOUBLE PRECISION ::
     *       WSTATE_SAV(MXRT),SPINS_SAV(MXRT),CRIT_SAV,PRTTOL_SAV,
     *       S_SAV,SZ_SAV,GRPDET_SAV,STSYM_SAV,GLIST_SAV,DWPARM_SAV
      INTEGER NFLGDM_SAV(MXRT),IWTS_SAV(MXRT),NCORSV_SAV,NCOR_SAV,
     *        NACTDT_SAV,NORBDT_SAV,NADET_SAV,NBDET_SAV,KDET_SAV,
     *        KSTDET_SAV,IROOT_SAV,IPURES_SAV,MAXW1_SAV,NITDET_SAV,
     *        MAXP_SAV,NCI_SAV,IGPDET_SAV,KSTSYM_SAV,NFTGCI_SAV,
     *        IDWEIGH_SAV
C
      DOUBLE PRECISION ::
     *       ENUCR_SAV,EELCT_SAV,ETOT_SAV,STOT_SAV,SZZ_SAV,
     *       ECORE_SAV,ESCF_SAV,EERD_SAV,E1_SAV,E2_SAV,
     *       VEN_SAV,VEE_SAV,EPOT_SAV,EKIN_SAV,ESTATE_SAV(MXRT),
     *       STATN_SAV,EDFT_SAV(ISIZE_EDFT),EDISP_SAV
C
      LOGICAL FDIRCT_SAV,QCORR_SAV
      DOUBLE PRECISION :: C0SQ_SAV
      INTEGER NSPACE_SAV,
     *        MSTA_SAV(51),MNUM_SAV(51),MINI_SAV(51),MAXI_SAV(51),
     *        IAMI_SAV(51),IAMA_SAV(51),IBMI_SAV(51),IBMA_SAV(51),
     *        IDIMFCC_SAV(51),LBST_SAV(51),NREF0_SAV
C
      LOGICAL BLOCK_SAV
C
      DOUBLE PRECISION :: SCFTYP_SAV,CITYP_SAV
C
      DOUBLE PRECISION :: ZAN_SAV(MXATM)
      INTEGER ICH_SAV,MUL_SAV,IAN_SAV(MXATM)
C
C-----------------------------------------------------------------------
C     END OF EXTENSIVE LIST OF CLONED VARS.
C-----------------------------------------------------------------------
C     NOTES:
C     IF ANY ARGUMENTS ARE ADDED TO THESE COMMONS,
C     PLEASE SET UP THE SAVING VARS IN THIS ROUTINE
C     OR
C     NOTIFY AARON SO THAT HE MAY DO SO...
C
      COMMON /DETPAR/ ICLBBR,ANALYS,SAFLG,IPRTSA
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,S,SZ,
     *                GRPDET,STSYM,GLIST,DWPARM,
     *                NFLGDM(MXRT),IWTS(MXRT),NCORSV,NCOR,NACTDT,NORBDT,
     *                NADET,NBDET,KDET,KSTDET,IROOT,IPURES,MAXW1,NITDET,
     *                MAXP,NCI,IGPDET,KSTSYM,NFTGCI,IDWEIGH
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,STOT,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIMFCC(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /FCCWFO/ BLOCK
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWRDMC,NORBMC,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /ORNTMO/ EXTLOC,EREFATM,
     *                NATMOR(MXAO),ISVMOR(MXATM),ISVDOP,
     *                ORIENT,ORIKIN,ORMFUL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      COMMON /VVOPAR/ IVVOS,NVVOS,BNDDEN
C-----------------------------------------------------------------------
      DOUBLE PRECISION :: ONE,TWO,TOL_NOS_EXT,TOL_CUTDEN
      PARAMETER (ONE=1.0D+00, TWO=2.0D+00)
      PARAMETER (TOL_NOS_EXT=1.0D-08) ! part. int. gave 1.2d-10 error diff
      PARAMETER (TOL_CUTDEN=1.0D-03)
C-----------------------------------------------------------------------
C
C     DEFINE PRINT STUFF
      SOME  = NPRINT.NE.-5 .AND. MASWRK
C
C     DATA STUFF
      DATA ATMNOS/8HATMNOS  /
      DATA CHECK/8HCHECK   /
      DATA RMC,ORMAS/8HMCSCF   ,8HORMAS   /
      DATA RHF/8HRHF     /
      DATA RNONE/8HNONE    /
      DATA FANT/8HC1      /
      DATA LFANT/1/
      DATA GANT/8HA       /
C      DATA LGANT/0/
      DATA NRNFG /1,1,1,0,1,0,0,0,0,0/
      DATA NPFLG2 /0,0,0,0,0,0,0,0,0,0/
C
C     DETERMINE IF ANALYSIS IS POSSIBLE.
C     IF NOT, EXIT OUT.
      COMBO=.FALSE.
      IF(EXTLOC.EQ.ATMNOS) COMBO=.TRUE.
      IF(.NOT.COMBO) RETURN
C
C     PRINT BANNER
      IF(SOME) WRITE(IW,9000)
      CALL FLSHBF(IW)
C
C------------------------------------------
C     SET UP SOME DIMENSIONS
      L0 = NQMT
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
      L0TRI = (L0*L0+L0)/2
C     SET UP L0MBS DIMENSION
      ISWMBS=1
      L0MBS=NVVOS_NUMCOR(0,0)
      DO I=1,NAT
        L0MBS=L0MBS+LOCAL_NUMVAL(I,ISWMBS)
      ENDDO
C     SET UP ISIZE_FCCWFN
      ISIZE_FCCWFN=51
C------------------------------------------
C
C     ERROR OUTS
C     NOTE:  CONSIDER ADDING SCFTYP=ORMAS HERE LATER.
      NERR=0
      OK=.FALSE.
      IF(SCFTYP.EQ.RHF) OK=.TRUE.
      IF(SCFTYP.EQ.RMC.AND.CISTEP.EQ.ORMAS) OK=.TRUE.
      IF(.NOT.OK) THEN
        IF(MASWRK) WRITE(IW,9002)
        NERR=NERR+1
      ENDIF
      IF(IVVOS.EQ.0.AND.ISVDOP.NE.10) THEN
        IF(MASWRK) WRITE(IW,9003)
        NERR=NERR+1
      ENDIF
      IF(L0.EQ.L0MBS) THEN
        IF(MASWRK) WRITE(IW,9004)
        NERR=NERR+1
      ENDIF
C
      IF(NERR.GT.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     SKIP FOR EXETYP
      IF(EXETYP.EQ.CHECK) GO TO 8999
C
C     ALLOCATE MEMORY.
C     THIS MEM IS SAVED THROUGHOUT THE ROUTINE
C     UNLIKE THE MINI-MEM IN THE LOOP BELOW.
      CALL GOTFM(NGOTMX)
      CALL VALFM(LOADFM)
      LS         = LOADFM     + 1
      LVECF15SAV = LS         + L2
      LVECCOL    = LVECF15SAV + L3
      LVEC       = LVECCOL    + L3
      LIPOSMBS   = LVEC       + L3
      LILENMBS   = LIPOSMBS   + (NAT+1)
      LIATSVD    = LILENMBS   + NAT
      LIPOSEXT   = LIATSVD    + L1
      LEIGHLD    = LIPOSEXT   + (NAT+1)
      LAST      = LEIGHLD    + L1*NAT
      NEED_NOS_EXT = LAST - LOADFM - 1
      CALL GETFM(NEED_NOS_EXT)
C
C--------------------------------------------------------------
C     SAVE IMPORTANT VARS
C     NOTE:  ORMAS-CI IS SET UP AT SAME TIME BELOW.
C--------------------------------------------------------------
      CALL DAREAD(IDAF,IODA,X(LVECF15SAV),L3,15,0)
C     TYP VARS
      SCFTYP_SAV=SCFTYP
      CITYP_SAV=CITYP
C     DET PAR VARS
      ANALYS_SAV=ANALYS
      ICLBBR_SAV=ICLBBR
      IPRTSA_SAV=IPRTSA
      SAFLG_SAV=SAFLG
C     DET VARS
      CRIT_SAV=CRIT
      PRTTOL_SAV=PRTTOL
      S_SAV=S
      SZ_SAV=SZ
      GRPDET_SAV=GRPDET
      STSYM_SAV=STSYM
      GLIST_SAV=GLIST
      DWPARM_SAV=DWPARM
      NCORSV_SAV=NCORSV
      NCOR_SAV=NCOR
      NACTDT_SAV=NACTDT
      NORBDT_SAV=NORBDT
      NADET_SAV=NADET
      NBDET_SAV=NBDET
      KDET_SAV=KDET
      KSTDET_SAV=KSTDET
      IROOT_SAV=IROOT
      IPURES_SAV=IPURES
      MAXW1_SAV=MAXW1
      NITDET_SAV=NITDET
      MAXP_SAV=MAXP
      NCI_SAV=NCI
      IGPDET_SAV=IGPDET
      KSTSYM_SAV=KSTSYM
      NFTGCI_SAV=NFTGCI
      IDWEIGH_SAV=IDWEIGH
C     ENGRYS VARS
      ENUCR_SAV=ENUCR
      EELCT_SAV=EELCT
      ETOT_SAV=ETOT
      STOT_SAV=STOT
      SZZ_SAV=SZZ
      ECORE_SAV=ECORE
      ESCF_SAV=ESCF
      EERD_SAV=EERD
      E1_SAV=E1
      E2_SAV=E2
      VEN_SAV=VEN
      VEE_SAV=VEE
      EPOT_SAV=EPOT
      EKIN_SAV=EKIN
      DO I=1,MXRT
        ESTATE_SAV(I)=ESTATE(I)
      ENDDO
      STATN_SAV=STATN
      DO I=1,ISIZE_EDFT
        EDFT_SAV(I)=EDFT(I)
      ENDDO
      EDISP_SAV=EDISP
C     DET ARRAY VARS
      DO I=1,MXRT
        WSTATE_SAV(I)=WSTATE(I)
        SPINS_SAV(I)=SPINS(I)
        NFLGDM_SAV(I)=NFLGDM(I)
        IWTS_SAV(I)=IWTS(I)
      ENDDO
C     ORMAS VARS
      NSPACE_SAV=NSPACE
      NREF0_SAV=NREF0
      C0SQ_SAV=C0SQ
      FDIRCT_SAV=FDIRCT
      QCORR_SAV=QCORR
      BLOCK_SAV=BLOCK
C     ORMAS ARRAY VARS
      DO I=1,ISIZE_FCCWFN
        MSTA_SAV(I)=MSTA(I)
        MNUM_SAV(I)=MNUM(I)
        MINI_SAV(I)=MINI(I)
        MAXI_SAV(I)=MAXI(I)
        IAMI_SAV(I)=IAMI(I)
        IAMA_SAV(I)=IAMA(I)
        IBMI_SAV(I)=IBMI(I)
        IBMA_SAV(I)=IBMA(I)
        IDIMFCC_SAV(I)=IDIMFCC(I)
        LBST_SAV(I)=LBST(I)
      ENDDO
C     INFOA VARS NEEDED.
      ICH_SAV=ICH
      MUL_SAV=MUL
      DO I=1,NAT
        ZAN_SAV(I)=ZAN(I)
        IAN_SAV(I)=IAN(I)
      ENDDO
C--------------------------------------------------------------
C     END OF SAVE IMPORTANT VARS
C--------------------------------------------------------------
C
C--------------------------------------------------------------
C     SET UP FOR ORMAS-CI
C--------------------------------------------------------------
C
C     SET UP SOME ORMAS DIMS.
C     ----USE A SINGLE 2S ORBITAL AS THE OCCUPIED,VALENCE ORBITAL
      III_OCC_ORB=1
      IEXCIT=2
C
C     TYP VARS
      SCFTYP=RNONE
      CITYP=ORMAS
C
C     WANT THE NOS TO BE 'BLOCKED'
C     NOTE:  FOR NOW, BLOCK OPTION IS JUST FOR SHOW.
      BLOCK=.TRUE.
C
C     DET PAR VARS
      ICLBBR=0
      ANALYS=.FALSE.
C
C     INFOA VARS
C     NOTE:  ZAN,IAN ARE CONSTANTLY RESET IN THE LOOP OVER ATOMS.
      MUL=1
      ICH=0
C     THE CHANGE IN ZAN,IAN IS NOT SO SIMPLE.  SEE BELOW.
C
C     DET VARS
C     NOTE:  REGARDLESS OF MOLECULAR SPIN, ALWAYS USE THE
C            THE SINGLET SPIN FOR THESE ATOMIC CI RUNS.
      SZ = (MUL-1)/TWO
      S = 0
      IPURES = 1
      MCORE = 0
      NCOR = MCORE
      NCORSV = MCORE
C
C     DET ARRAY VARS
      CICODE='ORMAS'
      NHIGH=INT(SZ+SZ+0.0001D+00)
      NELS=2
      NBDET=(NELS-NHIGH)/2
      NADET=NBDET+NHIGH
C
C     MOS ON INDIVIDUAL ATOMS NEVER HAVE MOLECULAR SYMMETRY.
C     NOTE:  INTEGRAL EXPENSE MIGHT BE AVOIDED
C            FOR STARTING GROUP=C1, BUT THIS IS MINOR.
      KSTSYM=1
      GRPDET=FANT
      IGPDET=LFANT
      STSYM=GANT
c
c     mini-mem #1
      call gotfm(ngotmx)
      call valfm(loadfm)
      lmoirp = loadfm + 1
      lmolab = lmoirp + L1
      last   = lmolab + L1
      need_nos_ext2 = last - loadfm - 1
      call getfm(need_nos_ext2)
c
      CALL C1DET(X(LMOIRP),X(LMOLAB),L0)
      CALL GAJASW(X(LMOIRP),NUM,GRPDET)
      CALL DAWRIT(IDAF,IODA,X(LMOIRP),L1,262,1)
c
c     end of mini-mem #1
      call retfm(need_nos_ext2)
c
      CALL SYMOFF
      CALL JANDK
      CALL SYMON
      CALL SEQREW(IS)
C
C     SET UP CI ROOTS
      IROOT=1
      CALL VCLR(WSTATE,1,MXRT)
      WSTATE(1) = ONE
      CALL VICLR(NFLGDM,1,MXRT)
      NFLGDM(1) = 1
      CALL VICLR(IWTS,1,MXRT)
      IWTS(1)=1
C
C     SET UP CONVERGENCE ITEMS.
C     --WANT TO CRANK UP INPUTS FOR CONVERGING OUT THE LOWEST STATES.
C     ...BUT SINGLET DAVIDSON HAS SPIN ISSUES FOR DET. CODE.
C     ...SO  LEAVE NSTATE=3 FOR NOW.
      MAXW1  = 300    ! NHGSS
      CRIT   = 1D-06  ! CVGTOL
      NITDET = 300    ! ITERMX
      KDET   = 3      ! NSTATE
      KSTDET = 1      ! NSTGSS
      MAXP   = 10     ! MXXPAN
      PRTTOL = 0.05D+00
C
C--------------------------------------------------------------
C     END OF SET UP FOR ORMAS-CI
C--------------------------------------------------------------
C
C
C     TASK 1: GET INFO ON ATOM POSITIONS NOW.
C             GET MAX. # OF ACTIVE ORBITALS FOR LOOPS OVER ATOMS.
C             CLEAR OUT LVECCOL FOR EASY VIEWING.
      CALL LOCAL_VVOS_ORB_RANGE(X(LIPOSMBS),X(LILENMBS),NAT)
      MAX_NACT_ORBS=0
      CALL LOCAL_READ_FILE528_WITH_CORES(X(LIATSVD),NAT,L0,MASWRK)
      CALL LOCAL_MAXNACT(X(LIATSVD),X(LIPOSEXT),
     *                   NAT,L0MBS,L0,MAX_NACT_ORBS,
     *                   MASWRK,IW)
      MAX_NACT_ORBS=MAX_NACT_ORBS+III_OCC_ORB
      ITMP=MAX_NACT_ORBS
      ITMP2=(ITMP*ITMP+ITMP)/2
      MAX_NACT_ORBS_TRI=ITMP2
      CALL VCLR(X(LVECCOL),1,L3)
C
C
C
C
C     TASK 2: RESET IDAF FILES IN ORDER TO DO MORE RUNS.
C             E.G. (2,2)ORMAS + THEN THIS LOCALIZING RUN.
C
C     THESE 3 ARE ESSENTIAL.
      IODA(320)= -1 ! ,320,
      IODA(68) = -1 ! ,68,
C     ERASCI IS CALLED BELOW.
C     THESE 3 ARE SO NO ONE CONFUSES WHAT IS ACTUALLY ON FILE OR NOT...
      IODA(19) = -1 ! ,19,
      IODA(20) = -1 ! ,20,
      IODA(21) = -1 ! ,21,
C
C
C
C
C     TASK 3: LOOP OVER ATOMS
C     --------ACTUALLY SEVERAL TASKS WITH THE LOOP.
C     --------INTEGRALS HAVE GRADM-SCHMIDT.
C     --------SO, DON'T NEED TO WORRY ABOUT DSWAPING ORBITALS.
      DO IATM1=1,NAT
C
C       RESET ZAN,IAN FOR NVVOS_NUMCOR STUFF.
        DO I=1,NAT
          ZAN(I)=ZAN_SAV(I)
          IAN(I)=IAN_SAV(I)
        ENDDO

C
C
C
C
C       PREPARE DAF FILE 15 FOR THE NEXT ROUND.
C       NOTE:  2S ORBITAL IS FROM ANOTHER MO SET.
C              IT IS NOT ORTHOGONAL TO THE EXTERNALS.
        IF(SOME) WRITE(IW,9050) IATM1
c
c       mini-mem #2
        call gotfm(ngotmx)
        call valfm(loadfm)
        lvec2   = loadfm  + 1
        lvec3   = lvec2   + l3
        lvec534 = lvec3   + l3
        lsvmbs  = lvec534 + l3
        leig    = lsvmbs  + l1*l0mbs
        last    = leig    + l1
        need_nos_ext2 = last - loadfm - 1
        call getfm(need_nos_ext2)
c
c
        CALL DAREAD(IDAF,IODA,X(LVEC534),L3,522,0) !yes 522 right now.
        CALL DAREAD(IDAF,IODA,X(LSVMBS),L1*L0MBS,533,0)
        IEXTORB=0
        IMOPROJ=1
        CALL LOCAL_NOS__PREP15(
     *       IEXTORB,X(LVEC),X(LVEC534),X(LSVMBS),
     *       X(LIPOSMBS),X(LIPOSEXT),
     *       IATM1,NAT,L0MBS,L0,L1,L3,III_OCC_ORB,
     *       IMOPROJ,X(LVEC3),X(LEIG),
     *       IW,MASWRK)
C
C       AT THIS POINT, WE DEFINE ITOTOCC RIGHT AWAY.
        ITOTOCC=III_OCC_ORB+IEXTORB
C
C       PRESERVE THE LVEC FOR COMPARISON PURPOSES LATER ON.
        CALL DCOPY(L3,X(LVEC),1,X(LVEC2),1)
C
C       CANNOT USE G.S. IN TRFMCX WITHOUT MORE ARGUMENTS.
C       --THIS OCCURS B/C DIFFERENT ATOMS HAVE VARYING OCCUPIED MOS.
C       --WE ALREADY DEAL WITH THIS BY IDAF -1 RESET... ONE TIME DEAL.
        CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
        CALL DAREAD(IDAF,IODA,X(LVEC3),L3,45,0)
        CALL ORTHO(X(LVEC3),X(LS),X(LVEC2),X(LEIG),ITOTOCC,L0,L1,L2,L1)
        CALL TFSQB(X(LVEC2),X(LVEC3),X(LEIG),L0,L1,L1)
C
C       WRITE OUT VECTORS DAF FILE 15 FOR INTEGRALS.
        CALL DAWRIT(IDAF,IODA,X(LVEC2),L3,15,0)
c
c       end of mini-mem #2
        call retfm(need_nos_ext2)
C
C-------------------------------------------------
C       SETUP EFFECTIVE NUCLEAR CHARGES.
C-------------------------------------------------
C       ZAN,IAN RESET IN NEXT ROUTINE.
        ITMP=ICH_SAV
        CALL LOCAL_NOS__NUCLEAR_CHARGES(
     *       ZAN,IAN,IAN_SAV,IATM1,NAT,ITMP,
     *       IW,SOME,MASWRK)
        ENUCR=ENUC(NAT,ZAN,C)
        EELCT=0.0D+00
        ETOT=0.0D+00
        CALL ONEEI
C-------------------------------------------------
C       END OF SETUP EFFECTIVE NUCLEAR CHARGES.
C-------------------------------------------------
C
C-------------------------------------------------
C       PERFORM CI
C-------------------------------------------------
C       DET ARRAY VARS
        NACTDT=MAX_NACT_ORBS
        NORBDT=MAX_NACT_ORBS
C       ORMAS AND ORMAS ARRAY VARS
C       NOTE:  FAKE AN EXTRA SPACE TO AVOID FILE SIZE CONFLICTS.
C              RE-VISIT THIS POINT FOR MEM. LATER.
C
        CALL VICLR(MSTA,1,ISIZE_FCCWFN)
        CALL VICLR(MNUM,1,ISIZE_FCCWFN)
        CALL VICLR(MINI,1,ISIZE_FCCWFN)
        CALL VICLR(MAXI,1,ISIZE_FCCWFN)
        CALL VICLR(IAMI,1,ISIZE_FCCWFN)
        CALL VICLR(IAMA,1,ISIZE_FCCWFN)
        CALL VICLR(IBMI,1,ISIZE_FCCWFN)
        CALL VICLR(IBMA,1,ISIZE_FCCWFN)
        CALL VICLR(IDIMFCC,1,ISIZE_FCCWFN)
        CALL VICLR(LBST,1,ISIZE_FCCWFN)
C
        IF(ITOTOCC.EQ.MAX_NACT_ORBS) THEN
          NSPACE  = 2
          MSTA(1) = NCORSV+1
          MSTA(2) = III_OCC_ORB+1
          MSTA(3) = ITOTOCC+1
          MSTA(4) = 0
          MNUM(3) = 0
        ELSE
          NSPACE  = 3
          MSTA(1) = NCORSV+1
          MSTA(2) = III_OCC_ORB+1
          MSTA(3) = ITOTOCC+1
          MSTA(4) = MAX_NACT_ORBS+1
          MNUM(3) = MAX_NACT_ORBS-IEXTORB-III_OCC_ORB
        ENDIF
        MNUM(1) = III_OCC_ORB-NCORSV
        MNUM(2) = IEXTORB
        MINI(1) = NELS-IEXCIT
        MINI(2) = 0
        MAXI(1) = NELS
        MAXI(2) = IEXCIT
        FDIRCT  = .TRUE.
        QCORR   = .FALSE.
        CALL FCCHECK(IW,SOME,NSPACE,MNUM,MINI,MAXI,
     *               IAMI,IAMA,IBMI,IBMA,NADET,NBDET)
C
C       PRINT OFF INFO THAT THE CI WILL DO.
        IF(SOME) WRITE(IW,9060)
     *             IEXCIT,CICODE,NCORSV,
     *             III_OCC_ORB+IEXTORB,
     *             III_OCC_ORB,IEXTORB,NELS
C
C       ACTUALLY RUN THE CI
C       NOTE1:  NEVER READ $CIDET INPUT INSIDE OF ORDET.
C               THIS ITEM IS NOW CODED IN ORDET.
C       NOTE2:  BASED ON CURRENT CODE,
C               SYMOFF INFO SHOULD NOT BE LOST.
        IF(IATM1.EQ.1) CALL ERASCI
        CALL SYMOFF
        CALL ORDET(NRNFG,NPFLG2)
        CALL SYMON
        CALL ERASCI
C
C       CHECK THAT NELS REMAINED 2 ELECTRONS.
C       I.E. NO CHANGES TO NELS BY ROUNDING ZAN.
        IF(NELS.NE.2) THEN
          IF(MASWRK) WRITE(IW,9061)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
C
C-------------------------------------------------
C       END OF PERFORM CI
C-------------------------------------------------
C

C
C       CHECK INTEGRAL ROUTINES DID NOT CHANGE DAF FILE 15 MOS.
C       --THE INPUT MOS WERE SYM. ORTHOG. UP TO ITOTOCC.
C       --TRFMCX WANTS TO DO G.S. ORTHOG. UP TO L0.
C       --NEED TO GENERATE COMPLEMENT SPACE HERE
C         RATHER THAN INSIDE OF TRFMCX.... TRUST ME.
C       --THE FIRST 2S ORBITAL IS NOT NORMALIZED IN THE PROJECTION PREP.
C         SO, IT'S LCAO COEFF PROBABLY CHANGE.
c
c       mini-mem #3
        call gotfm(ngotmx)
        call valfm(loadfm)
        lvec2   = loadfm  + 1
        lvec3   = lvec2   + l3
        lwrk    = lvec3   + l3
        liwrk   = lwrk    + l1*8
        leig    = liwrk   + l1
        lden    = leig    + l1
        last    = lden    + l2
        need_nos_ext2 = last - loadfm - 1
        call getfm(need_nos_ext2)
c
c
C
C       RECOVER DAF FILE 15 MOS.
C       NOTE:  FOR NOW, BLOCK OPTION IS JUST FOR SHOW.
        CALL DAREAD(IDAF,IODA,X(LVEC2),L3,15,0)
CKEEP        IF(MASWRK) THEN
CKEEP          WRITE(IW,*) 'LOCAL_NOS_EXT ATOM=',IATM1
CKEEP          WRITE(IW,9900)
CKEEP          CALL PRSQL(X(LVEC2),L0,L1,L1)
CKEEP          WRITE(IP,*) 'LOCAL_NOS_EXT ATOM=',IATM1
CKEEP          WRITE(IP,*) ' $VEC'
CKEEP          CALL PUSQL(X(LVEC2),L0,L1,L1)
CKEEP          WRITE(IP,9085)
CKEEP        ENDIF
        ICHK=1
        III_NEXT=III_OCC_ORB+1
        DO I=III_NEXT,ITOTOCC
          DO J=1,L1
            IJ=J+(I-1)*L1
            IJ=IJ-1
            TMP=X(LVEC2+IJ)-X(LVEC+IJ)
            TMP=ABS(TMP)
            IF(TMP.GT.TOL_NOS_EXT) ICHK=0
          ENDDO
        ENDDO
        CALL DCOPY(L3,X(LVEC2),1,X(LVEC),1)
C
C       RECOVER CANONICAL DENSITY MATRIX
C       CHECK THAT EXTRA DENSITY ELEMENTS (IF ANY) ARE ZEROS.
        ICHK2=0
        CALL DAREAD(IDAF,IODA,X(LDEN),MAX_NACT_ORBS_TRI,320,0)
        IF(NSPACE.EQ.2) ICHK2=1
        IF(NSPACE.EQ.3) THEN
          ICHK2=1
          DO I=ITOTOCC+1,MAX_NACT_ORBS
            DO J=ITOTOCC+1,I
              IJ=(I*I-I)/2 + J
              IJ=IJ-1
              TMP=X(LDEN+IJ)
              TMP=ABS(TMP)
              IF(TMP.GT.1.0D-12) ICHK2=0
            ENDDO
          ENDDO
          IF(MAX_NACT_ORBS.LE.ITOTOCC) ICHK2=0
        ENDIF
        IF(ICHK.EQ.0.OR.ICHK2.EQ.0) THEN
          IF(MASWRK) THEN
            IF(ICHK.EQ.0) WRITE(IW,9065)
            IF(ICHK2.EQ.0) WRITE(IW,9066)
          ENDIF
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
C
C       DIAGONALIZE DENSITY MATRIX BUT ONLY IN EXTERNAL SPACE
C       AND
C       FORM EXTERNAL NOS ON ATOM IATM1
        CALL VCLR(X(LEIG),1,L1)
        CALL LOCAL_NOS__PREPDEN(
     *       X(LDEN),X(LS),
     *       L2,III_OCC_ORB+1,ITOTOCC,
     *       L1,X(LWRK),X(LEIG),X(LIWRK),X(LVEC3),X(LVEC2),
     *       X(LVEC),
     *       SOME,IW)
C       NOTE1:  LEIG CONTAINS ONLY EXTERNAL DENSITIES.
C       NOTE2:  SCALED OCCUPATION NUMBERS
        TMP=ETOT-EREFATM
        TMP=ABS(TMP)
        CALL DSCAL(L1,TMP,X(LEIG),1)
        IF(IATM1.EQ.1) CALL VCLR(X(LEIGHLD),1,L1*NAT)
        CALL DCOPY(L1,X(LEIG),1,X(LEIGHLD+L1*(IATM1-1)),1)
c
c       end of mini-mem #3
        call retfm(need_nos_ext2)
C
C       SAVE NOS INTO COLLECTIVE SET LVECCOL.
        III_DIRECT=1
        CALL LOCAL_NOS__PREP534(
     *       X(LVEC),X(LVECCOL),X(LIPOSEXT),
     *       IATM1,NAT,L1,III_OCC_ORB,III_DIRECT)

C
C
C
C
C     TASK 3:  END THE LOOP OVER ATOMS
      ENDDO
C
      CALL ONEEI
C
C     IMMEDIATELY RESET ZAN,IAN FOR OTHER ROUTINES.
C     THIS RESET IS IMPORTANT.
      DO I=1,NAT
        ZAN(I)=ZAN_SAV(I)
        IAN(I)=IAN_SAV(I)
      ENDDO
C
C
C
C
c
c       mini-mem #4
c       note:  re-define l0tri just to be paranoid...
        l0tri=(l0*l0+l0)/2
        call gotfm(ngotmx)
        call valfm(loadfm)
        lstri         = loadfm   + 1
        lvec2         = lstri    + l0tri
        lvec534       = lvec2    + l3
        leig          = lvec534  + l3
        liwrk         = leig     + l1
        lwrk          = liwrk    + l1
        liwrkp        = lwrk     + l1*8
        lradwgt       = liwrkp   + (l0+1)
        lsavwgt       = lradwgt  + l0*nat
        last          = lsavwgt  + l0
        need_nos_ext2 = last - loadfm - 1
        call getfm(need_nos_ext2)
C
C     SAVE THE L0MBS MOS INTO COLLECTIVE SET LVECCOL.
C     NOTE:  KEEP THE ER OR BOYS ORBITALS.
C            DON'T TAKE THE OCCUPIED FROM SVD OR WHATEVER.
      CALL DAREAD(IDAF,IODA,X(LVEC534),L3,534,0)
      CALL DCOPY(L1*L0MBS,X(LVEC534),1,X(LVECCOL),1)
C
C
C
C------------------------------------------------------------------
C------------------------------------------------------------------
C     WEIGHTED SYMMETRIC ORTHOGONALIZATION
C     FOR COLLECTIVE ORBITAL SET LVECCOL
C------------------------------------------------------------------
C------------------------------------------------------------------
C     --NOTE:  DON'T LET INTEGRAL G.S. DESTROY ORBITALS LATER.
C     FOR THE WEIGHTS, CALCULATE THE FOLLOWING:
C     --ATOMIC RADIAL EXPECTATION VALUE
C       I.E. V_RAD_uv = INTEGRAL OF AO_u*AO_v/|r-R_A| FOR ATOM A.
C     --FORM MO VERSION V_RAD_ii = C_iu * V_NUC_uv * C_vi
C     THEN...
C     BASED ON THE CUT-OFF TOL_CUTDEN,
C     --REORDER EXTERNAL ORBITALS FROM BIG-TO-SMALL OCCUPATION.
C     --PUT REORDERING INSTRUCTIONS INTO LIWRKP ARRAY.
      CALL DCOPY(L3,X(LVECCOL),1,X(LVEC),1)
      DO IATM1=1,NAT
        CALL LOCAL_ATOMIC_HSANDT(X(LS),L2,2,IATM1,0)
        CALL TFTRI(X(LSTRI),X(LS),X(LVEC),X(LEIG),L0,L1,L1)
        DO I=1,L0
          II=(I*I-I)/2+I
          II=II-1
          ITMP=I+L0*(IATM1-1)
          ITMP=ITMP-1
          X(LRADWGT+ITMP)=X(LSTRI+II)
        ENDDO
      ENDDO
C
C     PREPARE SAVWGT AND IWRKP ARRAYS.
      ICOUNT_NOS=0
      ISAV_NOS=0
      TMP=TOL_CUTDEN
      IOPTION=0
      CALL LOCAL_NOS__PREPWGTSANDORDER(
     *     X(LIPOSEXT),X(LIWRKP),X(LRADWGT),X(LSAVWGT),
     *     X(LEIGHLD),IOPTION,
     *     L0,L1,NAT,L0MBS,ISAV_NOS,ICOUNT_NOS,TMP,
     *     MASWRK,IW)
C     DO NOT TAKE NON-FINAL REORDERINGS.  DELETE TO BE SURE.
      CALL VICLR(X(LIWRKP),1,L0+1)
      CALL VCLR(X(LRADWGT),1,L0*NAT)
C     BEGIN THE LINES FOR THE ACTUAL OVERLAP AND THEN ORTHOG...
C     WE ONLY NEED AND EVEN WANT TO ORTHOG. THE EXTERNALS HERE...
C     SINCE EXTERNALS ARE ALREADY ORTHOGONAL TO THE INTERNALS.
C
C
C     SHIFT OUT EXTERNAL ORBITALS INTO LVEC AT 1ST POSITION.
      CALL VCLR(X(LVEC),1,L3)
      II=0
      DO I=L0MBS+1,L0
        II=II+1
        X(LSAVWGT+II-1)=X(LSAVWGT+I-1)
      ENDDO
      CALL DCOPY(L1*(L0-L0MBS),
     *           X(LVECCOL+L1*L0MBS),1,
     *           X(LVEC),1)
C
C     PERFORM THE W.S.O.
      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      CALL VCLR(X(LSTRI),1,L0TRI)
      CALL TFTRI(X(LSTRI),X(LS),X(LVEC),X(LEIG),L0-L0MBS,L1,L1)
C     WANT S ** -1/2 HERE...
      IKIND=1
C     ONLY WANT AND NEED TO ORTHOG. EXTERNALS...
C     INPUTS VECTORS=LSTRI,LSAVWGT
C     OUTPUT VECTORS=LVEC
      CALL LOCAL_WEIGHTED_SYM_ORTHOG(
     *     IKIND,L0-L0MBS,X(LSTRI),X(LSAVWGT),
     *     X(LVEC),X(LVEC2),X(LVEC534),X(LEIG),X(LIWRK),X(LWRK),
     *     L1,L3,L0TRI,
     *     IW,MASWRK,SOME)
C
C     PREPARE MBS+EXTERNAL ORBITAL TRANSFORMATION.
      CALL VCLR(X(LVEC2),1,L3)
      DO I=1,L0MBS
        II=L1*(I-1)+I
        II=II-1
        X(LVEC2+II)=1.0D+00
      ENDDO
      DO I=1,L0-L0MBS
        IJ=L1*(I-1)+1
        IJ=IJ-1
        CALL DCOPY(L1,
     *             X(LVEC+IJ),1,
     *             X(LVEC2+L1*L0MBS+IJ+L0MBS),1)
      ENDDO
      CALL DCOPY(L3,X(LVEC2),1,X(LVEC),1)
C
C     APPLY ORBITAL TRANSFORMATION AND REPLACE LVECCOL ORBITALS.
      CALL VCLR(X(LVEC2),1,L3)
      CALL DCOPY(L3,X(LVECCOL),1,X(LVEC2),1)
      CALL VCLR(X(LVECCOL),1,L3)
      CALL MRARBR(X(LVEC2),L1,L1,L0,
     *            X(LVEC),L1,L0,X(LVECCOL),L1)
C------------------------------------------------------------------
C------------------------------------------------------------------
C     END OF WEIGHTED SYMMETRIC ORTHOGONALIZATION.
C------------------------------------------------------------------
C------------------------------------------------------------------
C
C     NOW, RE-DO WEIGHTS FOR PURPOSE OF ASSIGNING A LEVEL OF
C     COMPACTNESS OR DIFFUSENESS TO THE FINAL ORBITALS.
C     NOTE:  WE COULD HAVE SAVED THESE IF LS IS REPLACED BY VAR
C            WITH MORE MEMORY IN LOCAL_ATOMIC_HSANDT,
C            BUT THESE SEEM CHEAP RIGHT NOW.
      CALL DCOPY(L3,X(LVECCOL),1,X(LVEC),1)
      DO IATM1=1,NAT
        CALL LOCAL_ATOMIC_HSANDT(X(LS),L2,2,IATM1,0)
        CALL TFTRI(X(LSTRI),X(LS),X(LVEC),X(LEIG),L0,L1,L1)
        DO I=1,L0
          II=(I*I-I)/2+I
          II=II-1
          ITMP=I+L0*(IATM1-1)
          ITMP=ITMP-1
          X(LRADWGT+ITMP)=X(LSTRI+II)
        ENDDO
      ENDDO
C
C     PREPARE SAVWGT AND IWRKP ARRAYS.
      ICOUNT_NOS=0
      ISAV_NOS=0
      TMP=TOL_CUTDEN
      IOPTION=0
      CALL LOCAL_NOS__PREPWGTSANDORDER(
     *     X(LIPOSEXT),X(LIWRKP),X(LRADWGT),X(LSAVWGT),
     *     X(LEIGHLD),IOPTION,
     *     L0,L1,NAT,L0MBS,ISAV_NOS,ICOUNT_NOS,TMP,
     *     MASWRK,IW)
C
C     REORDER THE ATOM LABELS AND ORBITALS.
C     --NOTE1:  NEVER-EVER-EVER OVER-WRITE DAF 528.
C               528 IS FOR A DIFFERENT PROJECT.
C     --NOTE2:  FILE 535 WILL CONTAIN ONLY EXTERNAL ATOM LABELS.
C               WE MUST THROW OUT THE MBS SVD ATOM LABELS.
C               LATER, WE LEARN THE ATOM LABELS FOR ER,BOYS,ETC...
C     --NOTE3:  BECAREFUL TO PRESERVE THE L0+1 VALUE FOR FILE 535...
CSORT_BY_EVALUE
CSORT_BY_EVALUE   this next line overides all previous sorting
CSORT_BY_EVALUE   it takes orbital order from diagonalization
CSORT_BY_EVALUE
      IF(ISVDOP.EQ.100) GO TO 789
      CALL VICLR(X(LIWRK),1,L1)
      CALL ICOPY(L0,X(LIWRKP),1,X(LIWRK),1)
      CALL REORDR(X(LVECCOL),X(LIWRK),L0,L1)
      CALL LOCAL_READ_FILE528_WITH_CORES(X(LIATSVD),NAT,L0,MASWRK)
      CALL ICOPY(L0,X(LIWRKP),1,X(LIWRK),1)
      CALL IREORDR(X(LIATSVD),X(LIWRK),L0,1)
      CALL ICOPY(L0,X(LIWRKP),1,X(LIWRK),1)
      CALL REORDR(X(LSAVWGT),X(LIWRK),L0,1)
      CALL ICOPY(L0,X(LIATSVD),1,X(LIWRKP),1)
  789 CONTINUE
      CALL DAWRIT(IDAF,IODA,X(LVECCOL),L3,534,0)
      CALL DAWRIT(IDAF,IODA,X(LIWRKP),L0+1,535,1)
C
C     FINAL CHECK THAT ORBITALS ARE INDEED ORTHONORMAL
      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      CALL VCLR(X(LSTRI),1,L0TRI)
      CALL TFTRI(X(LSTRI),X(LS),X(LVECCOL),X(LEIG),L0,L1,L1)
      IERR=0
      DO I=1,L0
        DO J=1,I
          II=(I*I-I)/2+J
          II=II-1
ccccccccccc
          IF(I.EQ.J) THEN
            TMP=ABS(X(LSTRI+II)-1.0D+00)
          ELSE
            TMP=ABS(X(LSTRI+II))
          ENDIF
ccccccccccc
          IF(TMP.GT.TOL_NOS_EXT) IERR=IERR+1
        ENDDO
      ENDDO
      IF(IERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9068)
        CALL PRTRI(X(LSTRI),L0)
        IF(MASWRK) WRITE(IW,9068)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
c
c       end of mini-mem #4
        call retfm(need_nos_ext2)
c
C
C     WRITE STUFF OUT TO EVERYWHERE.
      IF(SOME) THEN
        WRITE(IW,9069) TOL_CUTDEN,L0MBS+ISAV_NOS
        WRITE(IW,9070)
        CALL PRSQL(X(LVECCOL),L0MBS+ICOUNT_NOS,L1,L1)
      ENDIF
      IF(MASWRK) THEN
        WRITE(IP,9080)
        CALL PUSQL(X(LVECCOL),L0MBS+ICOUNT_NOS,L1,L1)
        WRITE(IP,9085)
      ENDIF
C
C--------------------------------------------------------------
C     RESTORE IMPORTANT VARS
C--------------------------------------------------------------
      CALL DAWRIT(IDAF,IODA,X(LVECF15SAV),L3,15,0)
      SCFTYP=SCFTYP_SAV
      CITYP=CITYP_SAV
C     DET PAR VARS
      ANALYS=ANALYS_SAV
      ICLBBR=ICLBBR_SAV
      IPRTSA=IPRTSA_SAV
      SAFLG=SAFLG_SAV
C     DET VARS
      CRIT=CRIT_SAV
      PRTTOL=PRTTOL_SAV
      S=S_SAV
      SZ=SZ_SAV
      GRPDET=GRPDET_SAV
      STSYM=STSYM_SAV
      GLIST=GLIST_SAV
      DWPARM=DWPARM_SAV
      NCORSV=NCORSV_SAV
      NCOR=NCOR_SAV
      NACTDT=NACTDT_SAV
      NORBDT=NORBDT_SAV
      NADET=NADET_SAV
      NBDET=NBDET_SAV
      KDET=KDET_SAV
      KSTDET=KSTDET_SAV
      IROOT=IROOT_SAV
      IPURES=IPURES_SAV
      MAXW1=MAXW1_SAV
      NITDET=NITDET_SAV
      MAXP=MAXP_SAV
      NCI=NCI_SAV
      IGPDET=IGPDET_SAV
      KSTSYM=KSTSYM_SAV
      NFTGCI=NFTGCI_SAV
      IDWEIGH=IDWEIGH_SAV
C     ENGRYS VARS
      ENUCR=ENUCR_SAV
      EELCT=EELCT_SAV
      ETOT=ETOT_SAV
      STOT=STOT_SAV
      SZZ=SZZ_SAV
      ECORE=ECORE_SAV
      ESCF=ESCF_SAV
      EERD=EERD_SAV
      E1=E1_SAV
      E2=E2_SAV
      VEN=VEN_SAV
      VEE=VEE_SAV
      EPOT=EPOT_SAV
      EKIN=EKIN_SAV
      DO I=1,MXRT
        ESTATE(I)=ESTATE_SAV(I)
      ENDDO
      STATN=STATN_SAV
      DO I=1,ISIZE_EDFT
        EDFT(I)=EDFT_SAV(I)
      ENDDO
      EDISP=EDISP_SAV
ccccccc put back file 2!!!!
      CALL DAWRIT(IDAF,IODA,ENUCR,MXRT+15,2,0)
ccccccc
C     DET ARRAY VARS
      DO I=1,MXRT
        WSTATE(I)=WSTATE_SAV(I)
        SPINS(I)=SPINS_SAV(I)
        NFLGDM(I)=NFLGDM_SAV(I)
        IWTS(I)=IWTS_SAV(I)
      ENDDO
C     ORMAS VARS
      NSPACE=NSPACE_SAV
      NREF0=NREF0_SAV
      C0SQ=C0SQ_SAV
      BLOCK=BLOCK_SAV
      FDIRCT=FDIRCT_SAV
      QCORR=QCORR_SAV
C     ORMAS ARRAY VARS
      DO I=1,ISIZE_FCCWFN
        MSTA(I)=MSTA_SAV(I)
        MNUM(I)=MNUM_SAV(I)
        MINI(I)=MINI_SAV(I)
        MAXI(I)=MAXI_SAV(I)
        IAMI(I)=IAMI_SAV(I)
        IAMA(I)=IAMA_SAV(I)
        IBMI(I)=IBMI_SAV(I)
        IBMA(I)=IBMA_SAV(I)
        IDIMFCC(I)=IDIMFCC_SAV(I)
        LBST(I)=LBST_SAV(I)
      ENDDO
C     INFOA VARS NEEDED.
      ICH=ICH_SAV
      MUL=MUL_SAV
C     ZAN,IAN,C ARE ALREADY RESET ABOVE
C     E.G. THIS RESET IS NEEDED FOR NVVOS_NUMCOR.
C
C--------------------------------------------------------------
C     END OF RESTORE IMPORTANT VARS
C--------------------------------------------------------------
C
C     DEALLOCATE MEMORY.
      CALL RETFM(NEED_NOS_EXT)
C
C     FINISH UP.
 8999 CONTINUE
      IF(MASWRK) WRITE(IW,9300)
      CALL TIMIT(1)
      RETURN
 9000 FORMAT(/5X,60(1H-)/
     *   5X,'LOCAL_NOS_EXT NOW FORMS EXTERNAL LOCALIZED NOS.'/
     *   5X,60(1H-))
 9002 FORMAT(//1X,'LOCAL_NOS_EXT ERROR:',
     *        /1X,'EXT=ATMNOS OPTION IS ONLY FOR RHF,ORMAS.')
 9003 FORMAT(//1X,'LOCAL_NOS_EXT ERROR:',
     *        /1X,'DID NOT RUN THROUGH VVOS ROUTINE.',
     *        /1X,'NEED ISVDOP=10 OR IVVOS.NE.0 OR BOTH.')
 9004 FORMAT(//1X,'LOCAL_NOS_EXT ERROR:',
     *      /1X,'EXTLOC=ATMNOS REQUIRES EXTERNAL ORBITALS.')
 9050 FORMAT(/1X,'LOCAL_NOS_EXT PREPARES ORBITALS FOR ORMAS-CI',
     *        1X,'ON ATOM NUMBER=',I5)
 9060 FORMAT(/1X,'PERFORMING THE CI CALCULATION AT EXCITATION',
     *           ' LEVEL',I2,', USING ',A,','/
     *        1X,'WITH',I5,' CHEMICAL CORE AND',I5,' VALENCE ORBITALS',
     *           ' (OCC=',I5,', VIRT=',I5,'),'/
     *        1X,'CORRELATING ALL',I5,' VALENCE ELECTRONS.')
 9061 FORMAT(//1X,'LOCAL_NOS_EXT ERROR:',
     *        /1X,'SOMEWHERE OFF IN GAMESS LAND,',
     *         1X,'NELS WAS WRONGLY CHANGED TO NOT EQUAL 2.',
     *        /1X,'NELS NO LONGER EQUALS 2.')
 9065 FORMAT(//1X,'LOCAL_NOS_EXT ERROR:',
     *        /1X,'INTEGRAL ORTHOG. HAS CHANGED FILE 15 ORBITALS.',
     *        /1X,'POSSIBLE ISSUES:',
     *        /1X,'1. IN LOCAL_NOS_EXT ROUTINE SOMEWHERE',
     *        /1X,'2. IN TRFMCX ROUTINE FOR CALL TO ORTHO',
     *        /1X,'   DO NOT REMOVE THIS ERROR OUT.')
 9066 FORMAT(//1X,'LOCAL_NOS_EXT ERROR:',
     *        /1X,'SOME DENSITY ELEMENTS SHOULD BE ZERO AND ARE NOT.',
     *        /1X,'     DO NOT REMOVE THIS ERROR OUT.')
 9068 FORMAT(//1X,'LOCAL_NOS_EXT ERROR:',
     *        /1X,'FINAL ORBITALS INTO DAF FILE 534 ARE NOT',
     *         1X,'ORTHONORMAL.  THE CODE HAS BEEN CHANGED.')
 9069 FORMAT(//1X,'BASED ON SOME CUTOFF=',F20.10,
     *        /1X, I5,' ORBITALS SHOULD BE KEPT FOR FUTURE CI RUNS.')
 9070 FORMAT(//10X,'OCCUPIED+EXTERNAL-ATOMIC-NOS LOCALIZED ORBITALS')
 9080 FORMAT('OCCUPIED+EXTERNAL-ATOMIC-NOS LOCALIZED ORBITALS'/' $VEC')
 9085 FORMAT(' $END')
 9300 FORMAT(1X,'... DONE WITH LOCAL_NOS_EXT ...')
CKEEP 9900 FORMAT(//10X,'ATOM-SET LOCALIZED ORBITALS')
      END
C*MODULE LOCAL   *DECK LOCAL_NOS_EXT_RADIAL_VERSION
C> @brief      Forms atomic external NOs.
C>
C> @author     Aaron West
C>             -March 21, 2013
C>
C> @details    Forms atomic external NOs.
C>             There are three similar NOS_EXT routines.
C>             Some parts must remain the identical.
C>             I will add more later.
C>
      SUBROUTINE LOCAL_NOS_EXT_RADIAL_VERSION
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL SOME,COMBO
      DOUBLE PRECISION :: ATMNOS
      INTEGER L0,L1,L2,L3,L0MBS,L0TRI
      INTEGER IATM1,ISWMBS,LOCAL_NUMVAL,NVVOS_NUMCOR
      INTEGER III_DIRECT,ITMP,IEXTORB,MAX_NACT_ORBS
      INTEGER LOADFM,NGOTMX,NEED_NOS_EXT,LAST,
     *        LS,LS2,LSTRI,LVEC,LVECSAV,LVECCOL,
     *        LIPOSMBS,LILENMBS,LIATSVD,LIPOSEXT,LEIG,LEIGHLD,LRADTRI,
     *        LWRK,LIWRK,LVEC2,LVEC3,LRADWGT,LIWRKP,LSAVWGT
      INTEGER ICOUNT_NOS,ISAV_NOS,IOPTION
      DOUBLE PRECISION :: TMP
      INTEGER I,J,II,IJ,IKIND,NERR,IERR
C
      DOUBLE PRECISION :: TOL_CUTDEN,TOL_NOS_EXT
      PARAMETER (TOL_CUTDEN=1.0D-03)
      PARAMETER (TOL_NOS_EXT=1.0D-08) ! part. int. gave 1.2d-10 error diff
C-----------------------------------------------------------------------
      INTEGER MXAO,MXATM
      PARAMETER (MXAO=8192, MXATM=2000)
C-----------------------------------------------------------------------
C
      DOUBLE PRECISION :: X
C
      DOUBLE PRECISION :: C,ZAN
      INTEGER ICH,NQMT,NUM,MUL,NA,NAT,NB,NE,IAN
C
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      LOGICAL ORIENT,ORIKIN,ORMFUL
      INTEGER NATMOR,ISVMOR,ISVDOP
      DOUBLE PRECISION :: EXTLOC,EREFATM
C
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      DOUBLE PRECISION :: RUNTYP,EXETYP,CHECK
      INTEGER NEVALS,NGLEVL,NHLEVL
C
      INTEGER IVVOS,NVVOS
      DOUBLE PRECISION :: BNDDEN
C-----------------------------------------------------------------------
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /ORNTMO/ EXTLOC,EREFATM,
     *                NATMOR(MXAO),ISVMOR(MXATM),ISVDOP,
     *                ORIENT,ORIKIN,ORMFUL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /VVOPAR/ IVVOS,NVVOS,BNDDEN
C-----------------------------------------------------------------------
C
C     DEFINE PRINT STUFF
      SOME  = NPRINT.NE.-5 .AND. MASWRK
C
C     DATA STUFF
      DATA ATMNOS/8HATMNOS  /
      DATA CHECK/8HCHECK   /
C
C     DETERMINE IF ANALYSIS IS POSSIBLE.
C     IF NOT, EXIT OUT.
      COMBO=.FALSE.
      IF(EXTLOC.EQ.ATMNOS) COMBO=.TRUE.
      IF(.NOT.COMBO) RETURN
C
C     PRINT BANNER
      IF(SOME) WRITE(IW,9000)
      CALL FLSHBF(IW)
C
C------------------------------------------
C     SET UP SOME DIMENSIONS
      L0 = NQMT
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
      L0TRI = (L0*L0+L0)/2
C     SET UP L0MBS DIMENSION
      ISWMBS=1
      L0MBS=NVVOS_NUMCOR(0,0)
      DO I=1,NAT
        L0MBS=L0MBS+LOCAL_NUMVAL(I,ISWMBS)
      ENDDO
C------------------------------------------
C
C     ERROR OUTS
      NERR=0
      IF(IVVOS.EQ.0.AND.ISVDOP.NE.10) THEN
        IF(MASWRK) WRITE(IW,9003)
        NERR=NERR+1
      ENDIF
      IF(L0.EQ.L0MBS) THEN
        IF(MASWRK) WRITE(IW,9004)
        NERR=NERR+1
      ENDIF
C
      IF(NERR.GT.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     SKIP FOR EXETYP
      IF(EXETYP.EQ.CHECK) GO TO 8999
C
C     RE-DO INTEGRALS
      CALL SYMOFF
      CALL JANDK
      CALL SYMON
      CALL SEQREW(IS)
C
C     ALLOCATE MEMORY.
      CALL GOTFM(NGOTMX)
      CALL VALFM(LOADFM)
      LS           = LOADFM     + 1
      LS2          = LS         + L2
      LSTRI        = LS2        + L2
      LVEC         = LSTRI      + L0TRI
      LVECSAV      = LVEC       + L3
      LVECCOL      = LVECSAV    + L3
      LIPOSMBS     = LVECCOL    + L3
      LILENMBS     = LIPOSMBS   + (NAT+1)
      LIATSVD      = LILENMBS   + NAT
      LIPOSEXT     = LIATSVD    + L1
      LEIG         = LIPOSEXT   + (NAT+1)
      LEIGHLD      = LEIG       + L1
      LRADTRI      = LEIGHLD    + L1*NAT
      LWRK         = LRADTRI    + L0TRI*NAT
      LIWRK        = LWRK       + L1*8
      LVEC2        = LIWRK      + L1
      LVEC3        = LVEC2      + L3
      LRADWGT      = LVEC3      + L3
      LIWRKP       = LRADWGT    + L0*NAT
      LSAVWGT      = LIWRKP     + (L0+1)
      LAST        = LSAVWGT    + L0*NAT
      NEED_NOS_EXT = LAST - LOADFM - 1
      CALL GETFM(NEED_NOS_EXT)
C
C     SETUP SOME ATOM INTEGER ARRAYS.
      CALL LOCAL_VVOS_ORB_RANGE(X(LIPOSMBS),X(LILENMBS),NAT)
      CALL LOCAL_READ_FILE528_WITH_CORES(X(LIATSVD),NAT,L0,MASWRK)
      CALL LOCAL_MAXNACT(
     *     X(LIATSVD),X(LIPOSEXT),
     *     NAT,L0MBS,L0,MAX_NACT_ORBS,
     *     MASWRK,IW)
C
C     READ IN AND SAVE ER+EXTERNAL VECTORS
C     NOTE:  EXTERNAL VECTORS CAN BE FROM 521 OR 522 AT THIS TIME.
C     NOTE:  DAF534 COMES FROM ONE OF THE ABOVE... AT THIS POINT...
      CALL DAREAD(IDAF,IODA,X(LVECSAV),L3,534,0)
C
C     CONTRUCT THE <1/R> SYMMETRIC MATRIX FOR LVECSAV VECTORS.
      CALL DCOPY(L3,X(LVECSAV),1,X(LVEC),1)
      CALL VCLR(X(LRADTRI),1,L0TRI*NAT)
      CALL LOCAL_ATOMIC_TOTAL_INVRAD(
     *     X(LRADTRI),X(LVEC),X(LIPOSEXT),
     *     X(LSTRI),X(LS),X(LEIG),NAT,L0,L0TRI,L1,L2)
C
C     CLEAR OUT ANY ARRAYS TO BE FILLED IN THE LOOP OVER ATOMS
      CALL VCLR(X(LVECCOL),1,L3)
C
C     LOOP OVER ATOMS
      DO IATM1=1,NAT
        IF(SOME) WRITE(IW,9050) IATM1
        CALL LOCAL_GET_IEXTORB(
     *       IEXTORB,X(LIPOSEXT),IATM1,NAT,L0,MASWRK,IW)
C
C       COPY ORBITALS ON IATM1 INTO LVEC IN PREP. FOR NEXT CALL.
        III_DIRECT=0
        CALL LOCAL_NOS__PREP534(
     *       X(LVEC),X(LVECSAV),X(LIPOSEXT),
     *       IATM1,NAT,L1,0,III_DIRECT)
C
C       DIAGONALIZE RADTRI MATRICES ON EACH ATOM.
C       TRANSFORM THE ORBITALS.
        CALL VCLR(X(LEIG),1,L1)
        CALL VCLR(X(LS2),1,L2)
        ITMP=(IEXTORB*IEXTORB+IEXTORB)/2
        CALL DCOPY(ITMP,X(LRADTRI+(IATM1-1)*L0TRI),1,X(LS2),1)
        CALL LOCAL_NOS__PREPDEN(
     *       X(LS2),X(LS),
     *       L2,1,IEXTORB,
     *       L1,X(LWRK),X(LEIG),X(LIWRK),X(LVEC3),X(LVEC2),
     *       X(LVEC),
     *       SOME,IW)
C
C       SAVE THE NEW WEIGHTINGS FOR LATER.
        IF(IATM1.EQ.1) CALL VCLR(X(LEIGHLD),1,L1*NAT)
        CALL DCOPY(L1,X(LEIG),1,X(LEIGHLD+L1*(IATM1-1)),1)
C
C       SAVE THE NEW ORBITALS FOR LATER.
        III_DIRECT=1
        CALL LOCAL_NOS__PREP534(
     *       X(LVEC),X(LVECCOL),X(LIPOSEXT),
     *       IATM1,NAT,L1,0,III_DIRECT)
C
C     END OF LOOP OVER ATOMS
      ENDDO
C
C     FINISH MAKING LVECCOL.
      CALL DAREAD(IDAF,IODA,X(LVEC),L3,534,0)
      CALL DCOPY(L1*L0MBS,X(LVEC),1,X(LVECCOL),1)
C
C------------------------------------------------------------------
C------------------------------------------------------------------
C     WEIGHTED SYMMETRIC ORTHOGONALIZATION
C     FOR COLLECTIVE ORBITAL SET LVECCOL
C------------------------------------------------------------------
C------------------------------------------------------------------
C
C     PREPARE WEIGHTS
      CALL DCOPY(L3,X(LVECCOL),1,X(LVEC),1)
      DO IATM1=1,NAT
        CALL LOCAL_ATOMIC_HSANDT(X(LS),L2,2,IATM1,0)
        CALL TFTRI(X(LSTRI),X(LS),X(LVEC),X(LEIG),L0,L1,L1)
        DO I=1,L0
          II=(I*I-I)/2+I
          II=II-1
          ITMP=I+L0*(IATM1-1)
          ITMP=ITMP-1
          X(LRADWGT+ITMP)=X(LSTRI+II)
        ENDDO
      ENDDO
C
C     PREPARE SAVWGT AND IWRKP ARRAYS.
      ICOUNT_NOS=0
      ISAV_NOS=0
      TMP=TOL_CUTDEN
      IOPTION=0
      CALL LOCAL_NOS__PREPWGTSANDORDER(
     *     X(LIPOSEXT),X(LIWRKP),X(LRADWGT),X(LSAVWGT),
     *     X(LEIGHLD),IOPTION,
     *     L0,L1,NAT,L0MBS,ISAV_NOS,ICOUNT_NOS,TMP,
     *     MASWRK,IW)
C     DO NOT TAKE NON-FINAL REORDERINGS.  DELETE TO BE SURE.
      CALL VICLR(X(LIWRKP),1,L0+1)
      CALL VCLR(X(LRADWGT),1,L0*NAT)
C
C     SHIFT OUT EXTERNAL ORBITALS INTO LVEC AT 1ST POSITION.
      CALL VCLR(X(LVEC),1,L3)
      II=0
      DO I=L0MBS+1,L0
        II=II+1
        X(LSAVWGT+II-1)=X(LSAVWGT+I-1)
      ENDDO
      CALL DCOPY(L1*(L0-L0MBS),
     *           X(LVECCOL+L1*L0MBS),1,
     *           X(LVEC),1)
C
C     PERFORM THE W.S.O.
      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      CALL VCLR(X(LSTRI),1,L0TRI)
      CALL TFTRI(X(LSTRI),X(LS),X(LVEC),X(LEIG),L0-L0MBS,L1,L1)
C     WANT S ** -1/2 HERE...
      IKIND=1
      CALL LOCAL_WEIGHTED_SYM_ORTHOG(
     *     IKIND,L0-L0MBS,X(LSTRI),X(LSAVWGT),
     *     X(LVEC),X(LVEC2),X(LVEC3),X(LEIG),X(LIWRK),X(LWRK),
     *     L1,L3,L0TRI,
     *     IW,MASWRK,SOME)
C
C     PREPARE MBS+EXTERNAL ORBITAL TRANSFORMATION.
      CALL VCLR(X(LVEC2),1,L3)
      DO I=1,L0MBS
        II=L1*(I-1)+I
        II=II-1
        X(LVEC2+II)=1.0D+00
      ENDDO
      DO I=1,L0-L0MBS
        IJ=L1*(I-1)+1
        IJ=IJ-1
        CALL DCOPY(L1,
     *             X(LVEC+IJ),1,
     *             X(LVEC2+L1*L0MBS+IJ+L0MBS),1)
      ENDDO
      CALL DCOPY(L3,X(LVEC2),1,X(LVEC),1)
C
C     APPLY ORBITAL TRANSFORMATION AND REPLACE LVECCOL ORBITALS.
      CALL VCLR(X(LVEC2),1,L3)
      CALL DCOPY(L3,X(LVECCOL),1,X(LVEC2),1)
      CALL VCLR(X(LVECCOL),1,L3)
      CALL MRARBR(X(LVEC2),L1,L1,L0,
     *            X(LVEC),L1,L0,X(LVECCOL),L1)
C------------------------------------------------------------------
C------------------------------------------------------------------
C     END OF WEIGHTED SYMMETRIC ORTHOGONALIZATION
C------------------------------------------------------------------
C------------------------------------------------------------------
C
C     NOW, RE-DO WEIGHTS FOR PURPOSE OF ASSIGNING A LEVEL OF
C     COMPACTNESS OR DIFFUSENESS TO THE FINAL ORBITALS.
      CALL DCOPY(L3,X(LVECCOL),1,X(LVEC),1)
      DO IATM1=1,NAT
        CALL LOCAL_ATOMIC_HSANDT(X(LS),L2,2,IATM1,0)
        CALL TFTRI(X(LSTRI),X(LS),X(LVEC),X(LEIG),L0,L1,L1)
        DO I=1,L0
          II=(I*I-I)/2+I
          II=II-1
          ITMP=I+L0*(IATM1-1)
          ITMP=ITMP-1
          X(LRADWGT+ITMP)=X(LSTRI+II)
        ENDDO
      ENDDO
C
C     PREPARE SAVWGT AND IWRKP ARRAYS.
      ICOUNT_NOS=0
      ISAV_NOS=0
      TMP=TOL_CUTDEN
      IOPTION=0
      CALL LOCAL_NOS__PREPWGTSANDORDER(
     *     X(LIPOSEXT),X(LIWRKP),X(LRADWGT),X(LSAVWGT),
     *     X(LEIGHLD),IOPTION,
     *     L0,L1,NAT,L0MBS,ISAV_NOS,ICOUNT_NOS,TMP,
     *     MASWRK,IW)
C
C     REORDER THE ATOM LABELS AND ORBITALS.
C     --NOTE1:  NEVER-EVER-EVER OVER-WRITE DAF 528.
C               528 IS FOR A DIFFERENT PROJECT.
C     --NOTE2:  FILE 535 WILL CONTAIN ONLY EXTERNAL ATOM LABELS.
C               WE MUST THROW OUT THE MBS SVD ATOM LABELS.
C               LATER, WE LEARN THE ATOM LABELS FOR ER,BOYS,ETC...
C     --NOTE3:  BECAREFUL TO PRESERVE THE L0+1 VALUE FOR FILE 535...
CSORT_BY_EVALUE
CSORT_BY_EVALUE   this next line overides all previous sorting
CSORT_BY_EVALUE   it takes orbital order from diagonalization
CSORT_BY_EVALUE
      IF(ISVDOP.EQ.100) GO TO 789
      CALL VICLR(X(LIWRK),1,L1)
      CALL ICOPY(L0,X(LIWRKP),1,X(LIWRK),1)
      CALL REORDR(X(LVECCOL),X(LIWRK),L0,L1)
      CALL LOCAL_READ_FILE528_WITH_CORES(X(LIATSVD),NAT,L0,MASWRK)
      CALL ICOPY(L0,X(LIWRKP),1,X(LIWRK),1)
      CALL IREORDR(X(LIATSVD),X(LIWRK),L0,1)
      CALL ICOPY(L0,X(LIWRKP),1,X(LIWRK),1)
      CALL REORDR(X(LSAVWGT),X(LIWRK),L0,1)
      CALL ICOPY(L0,X(LIATSVD),1,X(LIWRKP),1)
  789 CONTINUE
      CALL DAWRIT(IDAF,IODA,X(LVECCOL),L3,534,0)
      CALL DAWRIT(IDAF,IODA,X(LIWRKP),L0+1,535,1)
C
C     FINAL CHECK THAT ORBITALS ARE INDEED ORTHONORMAL
      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      CALL VCLR(X(LSTRI),1,L0TRI)
      CALL TFTRI(X(LSTRI),X(LS),X(LVECCOL),X(LEIG),L0,L1,L1)
      IERR=0
      DO I=1,L0
        DO J=1,I
          II=(I*I-I)/2+J
          II=II-1
ccccccccccc
          IF(I.EQ.J) THEN
            TMP=ABS(X(LSTRI+II)-1.0D+00)
          ELSE
            TMP=ABS(X(LSTRI+II))
          ENDIF
ccccccccccc
          IF(TMP.GT.TOL_NOS_EXT) IERR=IERR+1
        ENDDO
      ENDDO
      IF(IERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9068)
        CALL PRTRI(X(LSTRI),L0)
        IF(MASWRK) WRITE(IW,9068)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     WRITE STUFF OUT TO EVERYWHERE.
      IF(SOME) THEN
        WRITE(IW,9069) TOL_CUTDEN,L0MBS+ISAV_NOS
        WRITE(IW,9070)
        CALL PRSQL(X(LVECCOL),L0MBS+ICOUNT_NOS,L1,L1)
      ENDIF
      IF(MASWRK) THEN
        WRITE(IP,9080)
        CALL PUSQL(X(LVECCOL),L0MBS+ICOUNT_NOS,L1,L1)
        WRITE(IP,9085)
      ENDIF




C
C     DEALLOCATE MEMORY.
      CALL RETFM(NEED_NOS_EXT)
C
C     FINISH UP.
 8999 CONTINUE
      IF(MASWRK) WRITE(IW,9300)
      CALL TIMIT(1)
      RETURN
 9000 FORMAT(/5X,60(1H-)/
     *   5X,'LOCAL_NOS_EXT NOW FORMS EXTERNAL LOCALIZED NOS.'/
     *   5X,60(1H-))
 9003 FORMAT(//1X,'LOCAL_NOS_EXT ERROR:',
     *        /1X,'DID NOT RUN THROUGH VVOS ROUTINE.',
     *        /1X,'NEED ISVDOP=10 OR IVVOS.NE.0 OR BOTH.')
 9004 FORMAT(//1X,'LOCAL_NOS_EXT ERROR:',
     *      /1X,'EXTLOC=ATMNOS REQUIRES EXTERNAL ORBITALS.')
 9050 FORMAT(/1X,'LOCAL_NOS_EXT PREPARES ORBITALS ',
     *        1X,'ON ATOM NUMBER=',I5)
 9068 FORMAT(//1X,'LOCAL_NOS_EXT ERROR:',
     *        /1X,'FINAL ORBITALS INTO DAF FILE 534 ARE NOT',
     *         1X,'ORTHONORMAL.  THE CODE HAS BEEN CHANGED.')
 9069 FORMAT(//1X,'BASED ON SOME CUTOFF=',F20.10,
     *        /1X, I5,' ORBITALS SHOULD BE KEPT FOR FUTURE CI RUNS.')
 9070 FORMAT(//10X,'OCCUPIED+EXTERNAL-ATOMIC-NOS LOCALIZED ORBITALS')
 9080 FORMAT('OCCUPIED+EXTERNAL-ATOMIC-NOS LOCALIZED ORBITALS'/' $VEC')
 9085 FORMAT(' $END')
 9300 FORMAT(1X,'... DONE WITH LOCAL_NOS_EXT ...')
      END
C*MODULE LOCAL   *DECK LOCAL_NOS_EXT_EXCHANGE_VERSION
C> @brief      Forms atomic external NOs.
C>
C> @author     Aaron West
C>             -March 21, 2013
C>
C> @details    Forms atomic external NOs.
C>             There are three similar NOS_EXT routines.
C>             Some parts must remain the identical.
C>             I will add more later.
C>
      SUBROUTINE LOCAL_NOS_EXT_EXCHANGE_VERSION
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL SOME,ATWGT,COMBO,SAVDSKWRK
      DOUBLE PRECISION :: ATMNOS
      INTEGER L0,L1,L2,L3,L0MBS,NVALORBS,NVALTRI,L0TRI
      INTEGER IATM1,ISWMBS,LOCAL_NUMVAL,NVVOS_NUMCOR
      INTEGER III_DIRECT,III_OCC_ORB,IMOPROJ,IEXTORB,ITOTOCC,
     *        MAX_NACT_ORBS
      INTEGER LOADFM,NGOTMX,NEED_NOS_EXT,LAST,
     *        LS,LS2,LOCCIMO,LSTRI,LVEC,LVECCOL,LSVMBS,LVORBIMO,
     *        LIPOSMBS,LILENMBS,LIATSVD,LIPOSEXT,LEIG,LEIGHLD,
     *        LWRK,LIWRK,LVEC2,LVEC3,LRADWGT,LIWRKP,LSAVWGT,
     *        LJCORE,LJVAL,LKCORE,LKVAL,LBUFFX,LBUFFI,LVEC66
      INTEGER ICOUNT_NOS,ISAV_NOS,IOPTION
      DOUBLE PRECISION :: TMP
      INTEGER I,J,II,IJ,IKIND,NERR,IERR
C
      INTEGER ILOOP,NLOOP
C
      INTEGER IBAS1,IBAS2,ILTH
C
      DOUBLE PRECISION :: TOL_CUTDEN,TOL_NOS_EXT
      PARAMETER (TOL_CUTDEN=1.0D-03)
      PARAMETER (TOL_NOS_EXT=1.0D-08) ! part. int. gave 1.2d-10 error diff
C-----------------------------------------------------------------------
      INTEGER MXAO,MXATM
      PARAMETER (MXAO=8192, MXATM=2000)
C-----------------------------------------------------------------------
C
      INTEGER LIMLOW,LIMSUP
C
      DOUBLE PRECISION :: X
C
      DOUBLE PRECISION :: C,ZAN
      INTEGER ICH,NQMT,NUM,MUL,NA,NAT,NB,NE,IAN
C
      INTEGER NINTMX,NHEX,NTUPL,INTTYP,IGRDTYP
      LOGICAL PACK2E
C
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      LOGICAL ORIENT,ORIKIN,ORMFUL
      INTEGER NATMOR,ISVMOR,ISVDOP
      DOUBLE PRECISION :: EXTLOC,EREFATM
C
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      DOUBLE PRECISION :: RUNTYP,EXETYP,CHECK
      INTEGER NEVALS,NGLEVL,NHLEVL
C
      INTEGER IVVOS,NVVOS
      DOUBLE PRECISION :: BNDDEN
C-----------------------------------------------------------------------
      COMMON /ATLIM / LIMLOW(MXATM),LIMSUP(MXATM)
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /ORNTMO/ EXTLOC,EREFATM,
     *                NATMOR(MXAO),ISVMOR(MXATM),ISVDOP,
     *                ORIENT,ORIKIN,ORMFUL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /VVOPAR/ IVVOS,NVVOS,BNDDEN
C-----------------------------------------------------------------------
C
C     DEFINE PRINT STUFF
      SOME  = NPRINT.NE.-5 .AND. MASWRK
C
C     DATA STUFF
      DATA ATMNOS/8HATMNOS  /
      DATA CHECK/8HCHECK   /
C
C     DETERMINE IF ANALYSIS IS POSSIBLE.
C     IF NOT, EXIT OUT.
      COMBO=.FALSE.
      IF(EXTLOC.EQ.ATMNOS) COMBO=.TRUE.
      IF(.NOT.COMBO) RETURN
C
C     PRINT BANNER
      IF(SOME) WRITE(IW,9000)
      CALL FLSHBF(IW)
C
C------------------------------------------
C     SET UP SOME DIMENSIONS
      L0 = NQMT
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
      L0TRI = (L0*L0+L0)/2
C     SET UP L0MBS DIMENSION
      ISWMBS=1
      L0MBS=NVVOS_NUMCOR(0,0)
      DO I=1,NAT
        L0MBS=L0MBS+LOCAL_NUMVAL(I,ISWMBS)
      ENDDO
C     SET UP NVALORBS DIMENSION
      ISWMBS=1
      NVALORBS=0
      DO I=1,NAT
        NVALORBS=NVALORBS+LOCAL_NUMVAL(I,ISWMBS)
      ENDDO
      NVALTRI=(NVALORBS*NVALORBS+NVALORBS)/2
C------------------------------------------
C
C     ERROR OUTS
      NERR=0
      IF(IVVOS.EQ.0.AND.ISVDOP.NE.10) THEN
        IF(MASWRK) WRITE(IW,9003)
        NERR=NERR+1
      ENDIF
      IF(L0.EQ.L0MBS) THEN
        IF(MASWRK) WRITE(IW,9004)
        NERR=NERR+1
      ENDIF
C
      IF(NERR.GT.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     SKIP FOR EXETYP
      IF(EXETYP.EQ.CHECK) GO TO 8999
C
C     REMOVE MOLECULAR SYMMETRY FOR ENTIRE ROUTINE.
      CALL SYMOFF
C
C     RE-DO INTEGRALS
      CALL JANDK
      CALL SEQREW(IS)
C
C     ALLOCATE MEMORY.
      CALL GOTFM(NGOTMX)
      CALL VALFM(LOADFM)
      LS           = LOADFM     + 1
      LS2          = LS         + L2
      LSTRI        = LS2        + L2
      LOCCIMO      = LSTRI      + L0TRI
      LVEC         = LOCCIMO    + L0MBS
      LVECCOL      = LVEC       + L3
      LSVMBS       = LVECCOL    + L3
      LVORBIMO     = LSVMBS     + L1*L0MBS
      LIPOSMBS     = LVORBIMO   + L3
      LILENMBS     = LIPOSMBS   + (NAT+1)
      LIATSVD      = LILENMBS   + NAT
      LIPOSEXT     = LIATSVD    + L1
      LEIG         = LIPOSEXT   + (NAT+1)
      LEIGHLD      = LEIG       + L1
      LWRK         = LEIGHLD    + L1*NAT
      LIWRK        = LWRK       + L1*8
      LVEC2        = LIWRK      + L1
      LVEC3        = LVEC2      + L3
      LRADWGT      = LVEC3      + L3
      LIWRKP       = LRADWGT    + L0*NAT
      LSAVWGT      = LIWRKP     + (L0+1)
      LJCORE       = LSAVWGT    + L0*NAT
      LJVAL        = LJCORE     + L2
      LKCORE       = LJVAL      + L2
      LKVAL        = LKCORE     + L2
      LBUFFX       = LKVAL      + L2
      LBUFFI       = LBUFFX     + NINTMX
      LVEC66       = LBUFFI     + NINTMX
      LAST         = LVEC66     + L3
      NEED_NOS_EXT = LAST - LOADFM - 1
      CALL GETFM(NEED_NOS_EXT)
C
C     SETUP SOME ATOM INTEGER ARRAYS.
      CALL LOCAL_VVOS_ORB_RANGE(X(LIPOSMBS),X(LILENMBS),NAT)
      CALL LOCAL_READ_FILE528_WITH_CORES(X(LIATSVD),NAT,L0,MASWRK)
      CALL LOCAL_MAXNACT(
     *     X(LIATSVD),X(LIPOSEXT),
     *     NAT,L0MBS,L0,MAX_NACT_ORBS,
     *     MASWRK,IW)
C
C     SET THE IMPROJ OPTION HERE... ONE SINGLE TIME.
      IMOPROJ=2
C
C     PUT ...ALL... THE WAVE FXN ORBITALS IN THE ORDER OF
C     THE SCF FREE-ATOM ORBITALS.
      IF(SOME) WRITE(IW,9055)
      CALL LOCAL_PREP1_FOR_ACAVO(
     *     L0,L1,L2,L3,L0MBS,NVALORBS,NVALTRI,NAT,
     *     X(LIWRK),X(LWRK),X(LSTRI),
     *     X(LIPOSMBS),X(LILENMBS),X(LIATSVD),
     *     X(LSVMBS),X(LVEC3),X(LVEC2),X(LS),X(LEIG),
     *     X(LVORBIMO),X(LOCCIMO),
     *     MASWRK)
C
C     CLEAR OUT ANY ARRAYS TO BE FILLED IN THE LOOP OVER ATOMS
      CALL VCLR(X(LVECCOL),1,L3)
C
C     LOOP OVER ATOMS
      DO IATM1=1,NAT
        IF(SOME) WRITE(IW,9050) IATM1
C
C       SOME INITIALIZATIONS.
        IEXTORB=0
        III_OCC_ORB=1
C
C       FORM S**(-1) ON IATM1.
        CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
        CALL LOCAL_GRAB_BASIS_FXNS_ON_ATOM(
     *       LIMLOW,LIMSUP,IATM1,NAT,L2,
     *       X(LS2),X(LS),
     *       IBAS1,IBAS2,ILTH)
        IKIND=2
        DO I=1,L2
          X(LJCORE+I-1)=1.0D+00
        ENDDO
C       NOTE:  THE NEXT FALSE REPRESSES PRINTING POINTLESS 1S
C              UNLESS WE ARE DEBUGGING.
        CALL LOCAL_WEIGHTED_SYM_ORTHOG(
     *       IKIND,ILTH,X(LS2),X(LJCORE),
     *       X(LVEC66),X(LVEC2),X(LVEC3),X(LEIG),X(LIWRK),X(LWRK),
     *       L1,L3,L2,
     *       IW,MASWRK,.FALSE.)
C
C       LOAD UP ALL THE ORIGINAL ORBITALS.        
C       NOTE:  THIS STEP DELAYED TO USE UP LESS MEMORY.
        CALL DAREAD(IDAF,IODA,X(LVEC2),L3,522,0) !yes 522 right now.
C
C       GET THE ORBITALS FOR IATM1.
C       NOTE:  FOR THIS VERSION, ABOVE ITOTOCC IS GARBAGE ORBITALS.
C       NOTE:  FOR THIS VERSION, ANY IMOPROJ DOES NOTHING IN PREP15.
        CALL DAREAD(IDAF,IODA,X(LVEC3),L3,45,0)
        CALL DAREAD(IDAF,IODA,X(LSVMBS),L1*L0MBS,533,0)
        CALL LOCAL_NOS__PREP15(
     *       IEXTORB,X(LVEC),X(LVEC2),X(LSVMBS),
     *       X(LIPOSMBS),X(LIPOSEXT),
     *       IATM1,NAT,L0MBS,L0,L1,L3,III_OCC_ORB,
     *       IMOPROJ,X(LVEC3),X(LEIG),
     *       IW,MASWRK)
        ITOTOCC=III_OCC_ORB+IEXTORB
C--------------------------------------
C--------------------------------------
C
C       PREPARE VALENCE ORBITALS LVEC3 AND DENSITY LEIG.
        CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
        CALL DAREAD(IDAF,IODA,X(LSVMBS),L1*L0MBS,533,0)
        NLOOP=1
        ISWMBS=1
        IF(IMOPROJ.EQ.2) NLOOP=LOCAL_NUMVAL(IATM1,ISWMBS)
        DO ILOOP=1,NLOOP
          CALL LOCAL_PREP2_FOR_ACAVO(
     *         X(LIPOSMBS),X(LOCCIMO),ILOOP,
     *         L1,L0MBS,NAT,IATM1,L2,IBAS1,ILTH,
     *         X(LVEC66),X(LSVMBS),X(LIWRK),X(LS2),X(LS),
     *         X(LEIG),X(LVEC3),
     *         MASWRK,IW)
        ENDDO
CKEEPC
CKEEPC       VIEW THE INTERNAL ORBITALS ON EACH ATOM.
CKEEP        IF(MASWRK) THEN
CKEEP          WRITE(IW,*) 'INT LOCAL_NOS_EXT ATOM=',IATM1
CKEEP          WRITE(IW,9900)
CKEEP          CALL PRSQL(X(LVEC3),NLOOP,L1,L1)
CKEEP          WRITE(IP,*) 'INT LOCAL_NOS_EXT ATOM=',IATM1
CKEEP          WRITE(IP,*) ' $VEC'
CKEEP          CALL PUSQL(X(LVEC3),NLOOP,L1,L1)
CKEEP          WRITE(IP,9085)
CKEEP        ENDIF
CKEEPC
CKEEPC       VIEW THE EXTERNAL NONORTHOGONAL COMBO ORBITALS ON EACH ATOM.
CKEEP        IF(MASWRK) THEN
CKEEP          WRITE(IW,*) 'EXT LOCAL_NOS_EXT ATOM=',IATM1
CKEEP          WRITE(IW,9900)
CKEEP          CALL PRSQL(X(LVEC),L0,L1,L1)
CKEEP          WRITE(IP,*) 'EXT LOCAL_NOS_EXT ATOM=',IATM1
CKEEP          WRITE(IP,*) ' $VEC'
CKEEP          CALL PUSQL(X(LVEC),L0,L1,L1)
CKEEP          WRITE(IP,9085)
CKEEP        ENDIF
C
C       CONSTRUCT THE DENSITY FOR ATOM IATM1 IN THE AO BASIS.
        IF(SOME) WRITE(IW,9060) NLOOP
        CALL VCLR(X(LS2),1,L2)
        CALL DMTX(X(LS2),X(LVEC3),X(LEIG),NLOOP,L1,L1)
C
C       FORM 2 EL EXCHANGE INTEGRALS FOR MOS ON IATM1
C       NOTE:  INPUT, OUTPUT=LS2
        SAVDSKWRK=DSKWRK
        DSKWRK=.TRUE.
        CALL VCLR(X(LVEC),1,L1)
        CALL LOCAL_NOS_ACAVO(
     *       X(LVEC),X(LS),X(LS2),
     *       X(LJCORE),X(LJVAL),X(LKCORE),X(LKVAL),
     *       X(LWRK),X(LBUFFX),X(LBUFFI),
     *       NOPK,NINTMX,L1,L2,
     *       ITOTOCC)
        DSKWRK=SAVDSKWRK
C--------------------------------------
C--------------------------------------
C
C       DIAGONALIZE 'EXTERNALS' MATRIX ON EACH ATOM.
C       TRANSFORM THE ORBITALS.
        CALL VCLR(X(LEIG),1,L1)
        CALL LOCAL_NOS__PREPDEN(
     *       X(LS2),X(LS),
     *       L2,III_OCC_ORB+1,ITOTOCC,
     *       L1,X(LWRK),X(LEIG),X(LIWRK),X(LVEC3),X(LVEC2),
     *       X(LVEC),
     *       SOME,IW)
C
C       THE WEIGHTS IN LEIG-->LEIGHLD ARE NOT COMPARABLE ACROSS ATOMS.
C       FOR EACH ATOM, RESET LEIG TO RANGE FROM 0 TO 1.
C       NOTE:
C       FOR EACH ATOM,
C       SET 2ND FALSE BELOW TO TRUE TO PRINT THE NEW WEIGHTS.
        IF(SOME) WRITE(IW,9063)
        ATWGT=.TRUE.
        CALL LOCAL_WSO_PREP(
     *       X(LEIG),IEXTORB,X(LWRK),X(LIWRK),
     *       ATWGT,.FALSE.,MASWRK,.FALSE.,IW)
C
C       SAVE THE NEW WEIGHTINGS FOR LATER.
        IF(IATM1.EQ.1) CALL VCLR(X(LEIGHLD),1,L1*NAT)
        CALL DCOPY(L1,X(LEIG),1,X(LEIGHLD+L1*(IATM1-1)),1)
C
C       SAVE THE NEW ORBITALS FOR LATER.
        III_DIRECT=1
        CALL LOCAL_NOS__PREP534(
     *       X(LVEC),X(LVECCOL),X(LIPOSEXT),
     *       IATM1,NAT,L1,III_OCC_ORB,III_DIRECT)
C
C     END OF LOOP OVER ATOMS
      ENDDO
C
C     FINISH MAKING LVECCOL.
      CALL DAREAD(IDAF,IODA,X(LVEC),L3,534,0)
      CALL DCOPY(L1*L0MBS,X(LVEC),1,X(LVECCOL),1)
C
C------------------------------------------------------------------
C------------------------------------------------------------------
C     WEIGHTED SYMMETRIC ORTHOGONALIZATION
C     FOR COLLECTIVE ORBITAL SET LVECCOL
C------------------------------------------------------------------
C------------------------------------------------------------------
CKEEPC
CKEEPC     PREPARE INVERSE RADIAL WEIGHTS
CKEEP      CALL DCOPY(L3,X(LVECCOL),1,X(LVEC),1)
CKEEP      DO IATM1=1,NAT
CKEEP        CALL LOCAL_ATOMIC_HSANDT(X(LS),L2,2,IATM1,0)
CKEEP        CALL TFTRI(X(LSTRI),X(LS),X(LVEC),X(LEIG),L0,L1,L1)
CKEEP        DO I=1,L0
CKEEP          II=(I*I-I)/2+I
CKEEP          II=II-1
CKEEP          ITMP=I+L0*(IATM1-1)
CKEEP          ITMP=ITMP-1
CKEEP          X(LRADWGT+ITMP)=X(LSTRI+II)
CKEEP        ENDDO
CKEEP      ENDDO
C
C     PREPARE SAVWGT AND IWRKP ARRAYS.
      ICOUNT_NOS=0
      ISAV_NOS=0
      TMP=TOL_CUTDEN
      IOPTION=1
      CALL LOCAL_NOS__PREPWGTSANDORDER(
     *     X(LIPOSEXT),X(LIWRKP),X(LRADWGT),X(LSAVWGT),
     *     X(LEIGHLD),IOPTION,
     *     L0,L1,NAT,L0MBS,ISAV_NOS,ICOUNT_NOS,TMP,
     *     MASWRK,IW)
C     DO NOT TAKE NON-FINAL REORDERINGS.  DELETE TO BE SURE.
      CALL VICLR(X(LIWRKP),1,L0+1)
      CALL VCLR(X(LRADWGT),1,L0*NAT)
C
C     SHIFT OUT EXTERNAL ORBITALS INTO LVEC AT 1ST POSITION.
      CALL VCLR(X(LVEC),1,L3)
      II=0
      DO I=L0MBS+1,L0
        II=II+1
        X(LSAVWGT+II-1)=X(LSAVWGT+I-1)
      ENDDO
      CALL DCOPY(L1*(L0-L0MBS),
     *           X(LVECCOL+L1*L0MBS),1,
     *           X(LVEC),1)
C
C     PERFORM THE W.S.O.
      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      CALL VCLR(X(LSTRI),1,L0TRI)
      CALL TFTRI(X(LSTRI),X(LS),X(LVEC),X(LEIG),L0-L0MBS,L1,L1)
C     WANT S ** -1/2 HERE...
      IKIND=1
      CALL LOCAL_WEIGHTED_SYM_ORTHOG(
     *     IKIND,L0-L0MBS,X(LSTRI),X(LSAVWGT),
     *     X(LVEC),X(LVEC2),X(LVEC3),X(LEIG),X(LIWRK),X(LWRK),
     *     L1,L3,L0TRI,
     *     IW,MASWRK,SOME)
C
C     PREPARE MBS+EXTERNAL ORBITAL TRANSFORMATION.
      CALL VCLR(X(LVEC2),1,L3)
      DO I=1,L0MBS
        II=L1*(I-1)+I
        II=II-1
        X(LVEC2+II)=1.0D+00
      ENDDO
      DO I=1,L0-L0MBS
        IJ=L1*(I-1)+1
        IJ=IJ-1
        CALL DCOPY(L1,
     *             X(LVEC+IJ),1,
     *             X(LVEC2+L1*L0MBS+IJ+L0MBS),1)
      ENDDO
      CALL DCOPY(L3,X(LVEC2),1,X(LVEC),1)
C
C     APPLY ORBITAL TRANSFORMATION AND REPLACE LVECCOL ORBITALS.
      CALL VCLR(X(LVEC2),1,L3)
      CALL DCOPY(L3,X(LVECCOL),1,X(LVEC2),1)
      CALL VCLR(X(LVECCOL),1,L3)
      CALL MRARBR(X(LVEC2),L1,L1,L0,
     *            X(LVEC),L1,L0,X(LVECCOL),L1)
C------------------------------------------------------------------
C------------------------------------------------------------------
C     END OF WEIGHTED SYMMETRIC ORTHOGONALIZATION
C------------------------------------------------------------------
C------------------------------------------------------------------
CKEEPC
CKEEPC     NOW, RE-DO WEIGHTS FOR PURPOSE OF ASSIGNING A LEVEL OF
CKEEPC     COMPACTNESS OR DIFFUSENESS TO THE FINAL ORBITALS.
CKEEP      CALL DCOPY(L3,X(LVECCOL),1,X(LVEC),1)
CKEEP      DO IATM1=1,NAT
CKEEP        CALL LOCAL_ATOMIC_HSANDT(X(LS),L2,2,IATM1,0)
CKEEP        CALL TFTRI(X(LSTRI),X(LS),X(LVEC),X(LEIG),L0,L1,L1)
CKEEP        DO I=1,L0
CKEEP          II=(I*I-I)/2+I
CKEEP          II=II-1
CKEEP          ITMP=I+L0*(IATM1-1)
CKEEP          ITMP=ITMP-1
CKEEP          X(LRADWGT+ITMP)=X(LSTRI+II)
CKEEP        ENDDO
CKEEP      ENDDO
C
C     PREPARE SAVWGT AND IWRKP ARRAYS.
      ICOUNT_NOS=0
      ISAV_NOS=0
      TMP=TOL_CUTDEN
      IOPTION=1
      CALL LOCAL_NOS__PREPWGTSANDORDER(
     *     X(LIPOSEXT),X(LIWRKP),X(LRADWGT),X(LSAVWGT),
     *     X(LEIGHLD),IOPTION,
     *     L0,L1,NAT,L0MBS,ISAV_NOS,ICOUNT_NOS,TMP,
     *     MASWRK,IW)
C
C     REORDER THE ATOM LABELS AND ORBITALS.
C     --NOTE1:  NEVER-EVER-EVER OVER-WRITE DAF 528.
C               528 IS FOR A DIFFERENT PROJECT.
C     --NOTE2:  FILE 535 WILL CONTAIN ONLY EXTERNAL ATOM LABELS.
C               WE MUST THROW OUT THE MBS SVD ATOM LABELS.
C               LATER, WE LEARN THE ATOM LABELS FOR ER,BOYS,ETC...
C     --NOTE3:  BECAREFUL TO PRESERVE THE L0+1 VALUE FOR FILE 535...
CSORT_BY_EVALUE
CSORT_BY_EVALUE   this next line overides all previous sorting
CSORT_BY_EVALUE   it takes orbital order from diagonalization
CSORT_BY_EVALUE
      IF(ISVDOP.EQ.100) GO TO 789
      CALL VICLR(X(LIWRK),1,L1)
      CALL ICOPY(L0,X(LIWRKP),1,X(LIWRK),1)
      CALL REORDR(X(LVECCOL),X(LIWRK),L0,L1)
      CALL LOCAL_READ_FILE528_WITH_CORES(X(LIATSVD),NAT,L0,MASWRK)
      CALL ICOPY(L0,X(LIWRKP),1,X(LIWRK),1)
      CALL IREORDR(X(LIATSVD),X(LIWRK),L0,1)
      CALL ICOPY(L0,X(LIWRKP),1,X(LIWRK),1)
      CALL REORDR(X(LSAVWGT),X(LIWRK),L0,1)
      CALL ICOPY(L0,X(LIATSVD),1,X(LIWRKP),1)
  789 CONTINUE
      CALL DAWRIT(IDAF,IODA,X(LVECCOL),L3,534,0)
      CALL DAWRIT(IDAF,IODA,X(LIWRKP),L0+1,535,1)
C
C     FINAL CHECK THAT ORBITALS ARE INDEED ORTHONORMAL
      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      CALL VCLR(X(LSTRI),1,L0TRI)
      CALL TFTRI(X(LSTRI),X(LS),X(LVECCOL),X(LEIG),L0,L1,L1)
      IERR=0
      DO I=1,L0
        DO J=1,I
          II=(I*I-I)/2+J
          II=II-1
ccccccccccc
          IF(I.EQ.J) THEN
            TMP=ABS(X(LSTRI+II)-1.0D+00)
          ELSE
            TMP=ABS(X(LSTRI+II))
          ENDIF
ccccccccccc
          IF(TMP.GT.TOL_NOS_EXT) IERR=IERR+1
        ENDDO
      ENDDO
      IF(IERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9068)
        CALL PRTRI(X(LSTRI),L0)
        IF(MASWRK) WRITE(IW,9068)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     WRITE STUFF OUT TO EVERYWHERE.
      IF(SOME) THEN
        WRITE(IW,9069) TOL_CUTDEN,L0MBS+ISAV_NOS
        WRITE(IW,9070)
        CALL PRSQL(X(LVECCOL),L0MBS+ICOUNT_NOS,L1,L1)
      ENDIF
      IF(MASWRK) THEN
        WRITE(IP,9080)
        CALL PUSQL(X(LVECCOL),L0MBS+ICOUNT_NOS,L1,L1)
        WRITE(IP,9085)
      ENDIF
C
C     DEALLOCATE MEMORY.
      CALL RETFM(NEED_NOS_EXT)
C
C     RESTORE MOLECULAR SYMMETRY NOW.
      CALL SYMON
C
C     FINISH UP.
 8999 CONTINUE
      IF(MASWRK) WRITE(IW,9300)
      CALL TIMIT(1)
      RETURN
 9000 FORMAT(/5X,60(1H-)/
     *   5X,'LOCAL_NOS_EXT NOW FORMS EXTERNAL LOCALIZED NOS.'/
     *   5X,60(1H-))
 9003 FORMAT(//1X,'LOCAL_NOS_EXT ERROR:',
     *        /1X,'DID NOT RUN THROUGH VVOS ROUTINE.',
     *        /1X,'NEED ISVDOP=10 OR IVVOS.NE.0 OR BOTH.')
 9004 FORMAT(//1X,'LOCAL_NOS_EXT ERROR:',
     *      /1X,'EXTLOC=ATMNOS REQUIRES EXTERNAL ORBITALS.')
 9050 FORMAT(/1X,'LOCAL_NOS_EXT PREPARES ORBITALS ',
     *        1X,'ON ATOM NUMBER=',I5)
 9055 FORMAT(/1X,'LOCAL_PREP1_FOR_ACAVO',
     *        1X,'LOCATES ALL VALENCE SVD ORBITALS.',
     *       /1X,'LOCAL_PREP1_FOR_ACAVO',
     *        1X,'ORDERS SVD ORBITALS AND DENSITIES INTO',
     *       /1X,'THE ORDER OF THE HIGH QUALITY VVOS AOS.')
 9060 FORMAT(/1X,'PREPARING AO DENSITY FROM',I5,' ORBITALS.')
 9063 FORMAT(/1X,'LOCAL_WSO_PREP NOW SCALES THE WEIGHTS',
     *        1X,'ON THE GIVEN ATOM.')
 9068 FORMAT(//1X,'LOCAL_NOS_EXT ERROR:',
     *        /1X,'FINAL ORBITALS INTO DAF FILE 534 ARE NOT',
     *         1X,'ORTHONORMAL.  THE CODE HAS BEEN CHANGED.')
 9069 FORMAT(//1X,'BASED ON SOME CUTOFF=',F20.10,
     *        /1X, I5,' ORBITALS SHOULD BE KEPT FOR FUTURE CI RUNS.')
 9070 FORMAT(//10X,'OCCUPIED+EXTERNAL-ATOMIC-NOS LOCALIZED ORBITALS')
 9080 FORMAT('OCCUPIED+EXTERNAL-ATOMIC-NOS LOCALIZED ORBITALS'/' $VEC')
 9085 FORMAT(' $END')
 9300 FORMAT(1X,'... DONE WITH LOCAL_NOS_EXT ...')
CKEEP 9900 FORMAT(//10X,'ATOM-SET LOCALIZED ORBITALS')
      END
C*MODULE LOCAL   *DECK LOCAL_WEIGHTED_SYM_ORTHOG
C> @brief      Forms (half-)inverse of matrix but with weights.
C>
C> @author     Aaron West and Klaus Ruedenberg
C>             -March 21, 2013
C>
C> @details    Forms inverse or half-inverse of an overlap matrix.
C>             This routine has extra dimensions to deal with
C>             variable lengths of the matrix and fixed length in
C>             the memory of the matrix.
C>             Weighting or not weighting the
C>             symmetric orthog. is also possible.
C>             FOR THE WEIGHTED VERSION,
C>             S**-1/2  --> W * (WSW)**-1/2
C>             where the weights W cannot be zero.
C>
C> @param IKIND  is for inverse or -1/2 power.
C>               IKIND=1 --> -1/2 power
C>               IKIND=2 --> inverse
C> @param ILTH   is the length of the matrix that is actually diagonaled.
C> @param VTMP   is a scratch array of L1xL1.
C> @param WGT    is the array of weights for the symmetric orthogonalization.
C> @param S      is the overlap matrix of interest in symmetric form.
C>               This needs to be fed in.
C> @param VTMP2  is a scratch array of L1xL1.
C> @param UVEC   is a scratch array of L1xL1.
C> @param EIG    is a scratch array of length L1 for the eigenvalues.
C> @param IWRK   is a integer scratch array of length L1.
C> @param WRK    is a work array of length L1x8.
C> @param L1     is the length of the AO basis.
C> @param L3     is L1xL1.
C> @param L2     is the triangular length of L1.
C> @param IW     indicates write out to the log file.
C> @param MASWRK is true for master process.
C> @param SOME   is true for master process with nprint not equal -5.
C>
      SUBROUTINE LOCAL_WEIGHTED_SYM_ORTHOG(
     *           IKIND,ILTH,S,WGT,
     *           VTMP,VTMP2,UVEC,EIG,IWRK,WRK,
     *           L1,L3,L2,
     *           IW,MASWRK,SOME)
      IMPLICIT NONE
      LOGICAL MASWRK,SOME,ATWGT,DEBUG
      INTEGER IW
      INTEGER ILTH,L1,L2,L3,IKIND,I,J,IJ,IERR2,IERR3
C
      DOUBLE PRECISION ::
     *       S(L2),VTMP(L1,L1),WGT(ILTH),
     *       VTMP2(L1,L1),UVEC(L1,L1),EIG(L1),WRK(L1,8)
      INTEGER IWRK(L1)
      DOUBLE PRECISION :: TMP
C
      DOUBLE PRECISION :: ONE,TOL
      PARAMETER (ONE=1.0D+00,TOL=1.0D-06)
C
C     WEIGHT FALLS BELOW TOL--> SET TO TOL.
C     SCALE THE ALL THE WEIGHTS BY SMALLEST WEIGHT.
C     NOTE:  I COULD EASILY SEE A BUG HERE FOR TRUE ZEROS.
C            I.E. INPUT ERROR...
      IF(IKIND.EQ.3) GO TO 100
C----------------------------------------------------------
C----------------------------------------------------------
C     SCALE THE WEIGHTINGS TO AVOID O.N. ORBITAL ISSUES LATER.
C     IT IS JUST A SCALING OF RELATIVE IMPORTANCE ANYWAYS.
      ATWGT=.FALSE.
      DEBUG=.FALSE.
      CALL LOCAL_WSO_PREP(
     *     WGT,ILTH,EIG,IWRK,
     *     ATWGT,DEBUG,MASWRK,SOME,IW)
C----------------------------------------------------------
C----------------------------------------------------------
C
C     FORM WSW WITH THE WEIGHTS.
      DO I=1,ILTH
        DO J=1,I
          IJ=(I*I-I)/2+J
          TMP=WGT(J)*WGT(I)
          S(IJ)=TMP*S(IJ)
        ENDDO
      ENDDO
C
C     NOW, DIAGONALIZE THE MATRIX.
  100 CONTINUE
      CALL GLDIAG(L1,ILTH,ILTH,S,WRK,EIG,VTMP,IERR2,IWRK)
      IERR3=0
      DO I=1,ILTH
        IF(EIG(I).LT.TOL) IERR3=IERR3+1
        IF(IKIND.EQ.1.OR.IKIND.EQ.3) THEN
          EIG(I)=ONE/SQRT(EIG(I))
        ELSEIF(IKIND.EQ.2) THEN
          EIG(I)=ONE/EIG(I)
        ELSE
          IF(MASWRK) WRITE(IW,9003)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
      ENDDO
      IF(IERR2.GT.0.OR.IERR3.GT.0) THEN
        IF(MASWRK.AND.IERR2.GT.0) WRITE(IW,9004)
        IF(MASWRK.AND.IERR3.GT.0) WRITE(IW,9005)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      CALL VCLR(UVEC,1,L3)
      DO I=1,ILTH
        DO J=1,ILTH
          UVEC(I,J)=VTMP(J,I)
          UVEC(J,I)=VTMP(I,J)
        ENDDO
      ENDDO
      DO I=1,ILTH
        CALL DSCAL(ILTH,EIG(I),VTMP(1,I),1)
      ENDDO
      CALL VCLR(VTMP2,1,L3)
      CALL MRARBR(VTMP,L1,ILTH,ILTH,UVEC,L1,ILTH,VTMP2,L1)
      CALL DCOPY(L3,VTMP2,1,VTMP,1)
C
C     FORM W * (WSW)**-1/2.
      IF(IKIND.EQ.3) RETURN
      DO I=1,ILTH
        DO J=1,ILTH
          TMP=WGT(I)
          VTMP(I,J)=TMP*VTMP(I,J)
        ENDDO
      ENDDO
C
      RETURN
 9003 FORMAT(//1X,'LOCAL_WEIGHTED_SYM_ORTHOG ERROR:',
     *        /1X,'YOU REQUESTED AN IKIND THAT DOES NOT EXIST.')
 9004 FORMAT(//1X,'LOCAL_WEIGHTED_SYM_ORTHOG ERROR:',
     *        /1X,'PROBLEM IN GLDIAG.')
 9005 FORMAT(//1X,'LOCAL_WEIGHTED_SYM_ORTHOG ERROR:',
     *        /1X,'SYMMETRIC ORTHOGONALIZATION',
     *         1X,'EVALUES ARE TOO SMALL.')
      END
C*MODULE LOCAL   *DECK LOCAL_NOS__PREP15
C> @brief      Prepares file 15 for external nos run.
C>
C> @author     Aaron West
C>             -March 22, 2013
C>
C> @details    Prepares file 15 for external nos run.
C>
C> @param IEXTORB counts up the until the total number
C>                of external orbitals on atom IATM1.
C> @param VEC     will hold the 2s+external orbitals.
C> @param VECEXT  holds the non-orthogonal external
C>                orbitals at this point.
C>                Orbitals gave intra-atomic orthog.
C> @param SVMBS   holds the SV product of the MBS orbitals
C>                from the VVOS but in the current
C>                basis set.
C>                SVMBS DOES GET DESTROYED IN THIS ROUTINE.
C> @param IPOSMBS holds the starting position for
C>                the 1st valence orbital for MBS orbitals.
C> @param IPOSEXT indicates the orbital index for the first external
C>                orbital on a given atom in the 1st column.
C>                In the 2nd column, this integer array indicates
C>                the total number of external orbitals on a given atom.
C>                The orbitals are contiguous so that a L0*NAT array
C>                does not have to given at this time...
C> @param IATM1   is the current atom in the loop.
C> @param NAT     is the number of atoms.
C> @param L0MBS   is the length of the MO variational space
C>                for the minimal basis set orbitals.
C> @param L0      is the length of the MO variational space.
C> @param L1      is the length of the AO coefficients.
C> @param L3      is the square of L1.
C> @param III_OCC_ORB is the number of occupieds.
C>                    This integer is used for the shift
C>                    in case it is made more general later.
C> @param IMOPROJ chooses an MO or AO projection.
C> @param QMAT    is the orthogonalizing Q matrix
C>                but only when IMOPROJ=0.
C> @param EMAT    is a scratch array of length L1.
C> @param IW      indicates write out to the log file.
C> @param MASWRK  is true for master process.
C>
      SUBROUTINE LOCAL_NOS__PREP15(
     *           IEXTORB,VEC,VECEXT,SVMBS,
     *           IPOSMBS,IPOSEXT,
     *           IATM1,NAT,L0MBS,L0,L1,L3,III_OCC_ORB,
     *           IMOPROJ,QMAT,EMAT,
     *           IW,MASWRK)
C
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER IERR,IW,I,IEXTORB,ITMP,IATM1,NAT,L0MBS,L0,L1,L3,
     *        III_OCC_ORB,IMOPROJ
      INTEGER ITMPBEG,ITMPLEN,ISWMBS,LOCAL_NUMVAL,NVVOS_NUMCOR
      DOUBLE PRECISION :: VEC(L1,L1),VECEXT(L1,L1),
     *                    SVMBS(L1,L0MBS),QMAT(L1,L1),EMAT(L1)
      INTEGER ITAKE,IBEG,IEND
      INTEGER IPOSMBS(NAT+1)
      INTEGER IPOSEXT(NAT+1)
C
C     RE-POSITION THE SV PRODUCT FOR THE VERY FIRST VALENCE FREE-ATOM MO
C     ON ATOM IATM1
C     E.G. 1S FOR H,HE
C     E.G. 2S FOR >HE FOR NOW...
C     IF IT CHANGES, IT WILL CHANGE IN LOCAL_VVOS_ORB_RANGE TO BE CERTAIN.
      ITMP=IPOSMBS(IATM1)
      CALL DCOPY(L1,SVMBS(1,ITMP),1,VEC(1,1),1)
      CALL VCLR(SVMBS,1,L1*L0MBS)
      CALL DCOPY(L1,VEC(1,1),1,SVMBS(1,1),1)
C
C     CLEAR OUT FOR THE ORTHOG. IN THE INTEGRALS.
      CALL VCLR(VEC,1,L3)
C--------------------------------------------------------
C     BEGIN:  AO PROJECTION SECTION.
      IF(IMOPROJ.EQ.0) THEN
C--------------------------------------------------------
C
C     FORM [QMAT-TRANS*SV]
      CALL MRTRBR(QMAT,L1,L1,L0,
     *            SVMBS(1,1),L1,1,
     *            VEC(1,1),L1)
C
C     FORM QMAT * [QMAT-TRANS*SV]
      CALL DCOPY(L1,VEC(1,1),1,EMAT,1)
      CALL VCLR(VEC,1,L3)
      CALL MRARBR(QMAT,L1,L1,L0,
     *            EMAT,L1,1,
     *            VEC(1,1),L1)
C--------------------------------------------------------
C     END:  AO PROJECTION SECTION.
C--------------------------------------------------------
C
C--------------------------------------------------------
C     BEGIN:  MO PROJECTION SECTION.
      ELSEIF(IMOPROJ.EQ.1) THEN
C--------------------------------------------------------
C
C     SET UP RANGES FOR THE TRUE 2S PROJECTION BELOW.
      ISWMBS=1
      ITMPBEG=NVVOS_NUMCOR(0,0)
      DO I=1,IATM1-1
        ITMPBEG=ITMPBEG+LOCAL_NUMVAL(I,ISWMBS)
      ENDDO
      ITMPBEG=ITMPBEG+1
      ITMPLEN=LOCAL_NUMVAL(IATM1,ISWMBS)
C
C     TRUELY PROJECT 2S ONTO L0MBS ORBITALS.
ccccccc      ITMPBEG=1
ccccccc      ITMPLEN=L0MBS
      CALL MRTRBR(VECEXT(1,ITMPBEG),L1,L1,ITMPLEN,
     *            SVMBS(1,1),L1,1,
     *            VEC(1,1),L1)
      CALL DCOPY(L1,VEC(1,1),1,SVMBS(1,1),1)
      CALL MRARBR(VECEXT(1,ITMPBEG),L1,L1,ITMPLEN,
     *            SVMBS(1,1),L1,1,
     *            VEC(1,1),L1)
C--------------------------------------------------------
C     END:  MO PROJECTION SECTION.
C--------------------------------------------------------
C
C--------------------------------------------------------
      ELSEIF(IMOPROJ.EQ.2) THEN
C       DO NOTHING.
C       FOR THIS OPTION,
C       THE FIRST ORBITAL IS REPEATEDLY FILLED LATER ON
C       IN ANOTHER LOOP.
C--------------------------------------------------------
      ELSE
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
      ENDIF
C--------------------------------------------------------
C
C     DEFINE ORBITALS AND ORBITAL NUMS
C     GET THE EXTERNAL ORBITALS ON ATOM IATM1
      IEXTORB=IPOSEXT(IATM1+1)-IPOSEXT(IATM1)
      IBEG=IPOSEXT(IATM1)
      IEND=IPOSEXT(IATM1+1)-1
      ITAKE=III_OCC_ORB
      DO I=IBEG,IEND
        ITAKE=ITAKE+1
        CALL DCOPY(L1,VECEXT(1,I),1,VEC(1,ITAKE),1)
      ENDDO
C
C
      IERR=0
      IF(IEXTORB.LE.0) THEN
        IF(MASWRK) WRITE(IW,9001)
        IERR=IERR+1
      ENDIF
      IF(IEND.GT.L0.OR.IEXTORB.GT.L0.OR.ITAKE.GT.L0) THEN
        IF(MASWRK) WRITE(IW,9002)
        IERR=IERR+1
      ENDIF
      IF(IERR.NE.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C
      RETURN
 9000 FORMAT(//1X,'LOCAL_NOS__PREP15 ERROR:',
     *        /1X,'THIS IMOPROJ OPTION DOES NOT EXIST.')
 9001 FORMAT(//1X,'LOCAL_NOS__PREP15 ERROR:',
     *        /1X,'IEXTORB IS NOT GREATER THAN 0.  WRONG...')
 9002 FORMAT(//1X,'LOCAL_NOS__PREP15 ERROR:',
     *        /1X,'CODE TRIES TO COPY VECTORS OUTSIDE OF L0 RANGE.',
     *         1X,'WRONG...')
      END
C*MODULE LOCAL   *DECK LOCAL_NOS__PREP534
C> @brief      Prepares file 534 for external nos results.
C>
C> @author     Aaron West
C>             -March 22, 2013
C>
C> @details    Prepares file 534 for external nos results.
C>
C> @param VEC     holds the resultant ext.nos.
C> @param VECCOL  will hold the resultant ext.nos
C>                in proper position.
C> @param IPOSEXT indicates the orbital index for the first external
C>                orbital on a given atom in the 1st column.
C>                In the 2nd column, this integer array indicates
C>                the total number of external orbitals on a given atom.
C>                The orbitals are contiguous so that a L0*NAT array
C>                does not have to given at this time...
C> @param IATM1   is the current atom in the loop.
C> @param NAT     is the number of atoms.
C> @param L1      is the length of the AO coefficients.
C> @param III_OCC_ORB is the number of occupieds.
C>                    This integer is used for the shift
C>                    in case it is made more general later.
C> @param III_DIRECT  decides which way to copy the vectors.
C>
      SUBROUTINE LOCAL_NOS__PREP534(
     *           VEC,VECCOL,IPOSEXT,
     *           IATM1,NAT,L1,III_OCC_ORB,III_DIRECT)
C
      IMPLICIT NONE
      INTEGER IBEG,IEND,ITAKE,I,IATM1,NAT,L1,III_OCC_ORB,III_DIRECT
      DOUBLE PRECISION :: VEC(L1,L1),VECCOL(L1,L1)
      INTEGER IPOSEXT(NAT+1)
C
      IBEG=IPOSEXT(IATM1)
      IEND=IPOSEXT(IATM1+1)-1
      ITAKE=III_OCC_ORB
      IF(III_DIRECT.EQ.0) THEN
        DO I=IBEG,IEND
          ITAKE=ITAKE+1
          CALL DCOPY(L1,VECCOL(1,I),1,VEC(1,ITAKE),1)
        ENDDO
      ELSEIF(III_DIRECT.EQ.1) THEN
        DO I=IBEG,IEND
          ITAKE=ITAKE+1
          CALL DCOPY(L1,VEC(1,ITAKE),1,VECCOL(1,I),1)
        ENDDO
      ELSE
      ENDIF
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_MAXNACT
C> @brief      Determines the max. num. of atomic ext. orbitals.
C>
C> @author     Aaron West
C>             -March 23, 2013
C>
C> @details    Determines the maximum number of atomic external
C>             orbitals.  This routine helps to avoid reseting
C>             idaf file sizes in this kind of run.
C>
C> @param IATSVD  holds the atom labels for all
C>                svd orbitals.
C> @param IPOSEXT indicates the orbital index for the first external
C>                orbital on a given atom in the 1st column.
C>                In the 2nd column, this integer array indicates
C>                the total number of external orbitals on a given atom.
C>                The orbitals are contiguous so that a L0*NAT array
C>                does not have to given at this time...
C> @param NAT     is the number of atoms.
C> @param L0MBS   is the dimension of the minimal basis set number of
C>                orbitals.  L0MBS is derived from NCORTOT + LOCAL_NUMVAL.
C> @param L0             is the length of the MO variational space.
C> @param MAX_NACT_ORBS  will hold the max. size of the single
C>                       2s and ext. orbitals on an atom.
C> @param MASWRK       indicates the master process.
C> @param IW           indicates write out to the log file.
C>
      SUBROUTINE LOCAL_MAXNACT(IATSVD,IPOSEXT,
     *                         NAT,L0MBS,L0,MAX_NACT_ORBS,
     *                         MASWRK,IW)
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER IERR,IOFF,IOFF2,IW,IMAX,I,J
      INTEGER MAX_NACT_ORBS,NAT,L0,L0MBS
      INTEGER IATSVD(L0)
      INTEGER IPOSEXT(NAT+1)
C
      IERR=0
      IMAX=0
      DO I=1,NAT
        IOFF=0
        IOFF2=0
        DO J=L0MBS+1,L0
          IF(IATSVD(J).EQ.I.AND.IOFF.EQ.0) IPOSEXT(I)=J
          IF(IATSVD(J).EQ.I) IOFF=IOFF+1
C-----------------------------------
C         SMALL CHECK ON INDEXING...
          IF(IOFF.GT.0.AND.IATSVD(J).NE.I) IOFF2=1
          IF(IOFF2.GT.0.AND.IATSVD(J).EQ.I) IERR=IERR+1
C-----------------------------------
        ENDDO
C       SAVE THE MAX VALUE ACROSS ALL ATOMS.
        IF(IOFF.GT.IMAX) IMAX=IOFF
      ENDDO
      IPOSEXT(NAT+1)=L0+1
C
C
      IF(IERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C
      MAX_NACT_ORBS=IMAX
C
      RETURN
 9000 FORMAT(//1X,'LOCAL_MAXNACT ERROR:',
     *        /1X,'EXTERNAL ORBITAL ATOM LABELS ARE NOT',
     *         1X,'CONTIGUOUS FOR SOME REASON.',
     *        /1X,'INTEGER ARRAYS WERE SET UP FOR THAT...')
      END
C*MODULE LOCAL   *DECK LOCAL_NOS__PREPDEN
C> @brief      Makes natural orbitals for orbital subset.
C>
C> @author     Aaron West
C>             -March 26, 2013
C>
C> @details    Given input orbital subset, the following occurs:
C>             -Density subset is extracted.
C>             -Diagonalizes density for orbital subset.
C>             -Makes natural orbitals for orbital subset.
C>             -Orbital subset is defined by input.
C>             -Reorders occupations from biggest to smallest.
C>             -Repeated calls should be able to do
C>              split-localization but only for C1 symmetry.
C>
C> @param DEN         is an array of length L2.
C>                    This contains the density even though L2 is a larger dim.
C> @param DEN2        is a scratch array.
C> @param L2          equals (L1*L1+L1)/2.
C> @param ISTORB      equals the starting orbital for the density.
C> @param IENDORB     equals the ending orbital for the density.
C>                    ISTORB and IENDORB must be contiguous of course.
C> @param L1          is the length of the AO coefficients.
C> @param WRK         is a scratch array of length L1*8.
C> @param EIG         is a scratch array of length L1.
C>                    DON'T MODIFY EIG IN THIS ROUTINE.
C>                    DON'T EVEN THINK ABOUT IT...
C> @param IWRK        is an integer scratch array of length L1.
C> @param VTMP        is a scratch array of length L1*L1.
C> @param VTMP2       is a scratch array of length L1*L1.
C> @param VEC         contains the L1*L1 storage for the L1*L0
C>                    orbital set.  It is both input and output here.
C> @param SOME        is true for master process with nprint not equal -5.
C> @param IW          indicates write out to the log file.
      SUBROUTINE LOCAL_NOS__PREPDEN(
     *           DEN,DEN2,
     *           L2,ISTORB,IENDORB,
     *           L1,WRK,EIG,IWRK,VTMP,VTMP2,
     *           VEC,
     *           SOME,IW)
C
      IMPLICIT NONE
C
      LOGICAL SOME
      INTEGER IW
C
      INTEGER L2,L1,L3,ISTORB,IENDORB
      DOUBLE PRECISION :: DEN(L2),DEN2(L2),
     *                    WRK(L1,8),EIG(L1),VTMP(L1,L1),VTMP2(L1,L1),
     *                    VEC(L1,L1)
      INTEGER IWRK(L1)
C
      INTEGER ILEN,I,II,J,IJ,IJ2
      INTEGER ISTOP,IERR2
C
      L3=L1*L1
C
      CALL VCLR(DEN2,1,L2)
C
      IJ2=0
      DO I=ISTORB,IENDORB
        DO J=ISTORB,I
          IJ =(I*I-I)/2+J
          IJ2=IJ2+1
          DEN2(IJ2)=DEN(IJ)
        ENDDO
      ENDDO
C
      ILEN=IENDORB-ISTORB+1
C
      CALL DCOPY(L2,DEN2,1,DEN,1)
      CALL VCLR(DEN2,1,L2)
C
C     DIAGONALIZE THE EXTERNAL DENSITY
      CALL VCLR(VTMP,1,L1*L1)
      CALL GLDIAG(L1,ILEN,ILEN,DEN,WRK,EIG,VTMP,IERR2,IWRK)
C
C     REORDER THE EVALUES FROM BIG TO SMALL.
      CALL VICLR(IWRK,1,L1)
      II=1
      DO I=ILEN,1,-1
        IWRK(II)=I
        II=II+1
      ENDDO
      CALL REORDR(EIG,IWRK,ILEN,1)
C
C     PRINT OFF THE OCCUPATIONS.
C     --DON'T MODIFY EIG IN THIS ROUTINE.
C     --DON'T EVEN THINK ABOUT IT...
      ISTOP=5
      IF(ILEN.LE.5) ISTOP=ILEN
      IF(SOME) WRITE(IW,9010) (EIG(I),I=1,ISTOP)
      IF(ILEN.GT.5) THEN
        DO J=6,ILEN,5
          ISTOP=J+4
          IF(ISTOP.GT.ILEN) ISTOP=ILEN
          IF(SOME) WRITE(IW,9011) (EIG(I),I=J,ISTOP)
        ENDDO
      ENDIF
C
C     REORDER TRANSFORMATION ELEMENTS.
      CALL VICLR(IWRK,1,L1)
      II=1
      DO I=ILEN,1,-1
        IWRK(II)=I
        II=II+1
      ENDDO
      CALL REORDR(VTMP,IWRK,ILEN,L1)
C
C     FORM THE NOS
      CALL DCOPY(L3,VEC,1,VTMP2,1)
      CALL VCLR(VEC,1,L3)
      CALL MRARBR(VTMP2(1,ISTORB),L1,L1,ILEN,
     *            VTMP,L1,ILEN,
     *            VEC(1,ISTORB),L1)
C
C
      RETURN
 9010 FORMAT(//1X,'LOCAL_NOS_EXT YIELDS EVALUES =',10F6.3//)
 9011 FORMAT(35X,10F6.3)
      END
C*MODULE LOCAL   *DECK LOCAL_NOS__PREPWGTSANDORDER
C> @brief      Locates most important atomic NOs.
C>
C> @author     Aaron West
C>             -March 26, 2013
C>
C> @details    Locates most important atomic NOs based on atomic-like
C>             molecular orbital nuclear attraction weighting terms.
C>             This routine prepares the integer reordering array.
C>             However, this routine does not apply that array.
C>             That array is selectively applied to several items.
C>             i.e. orbitals, atom labels, the weights themselves,etc.
C>
C> @param IPOSEXT indicates the orbital index for the first external
C>                orbital on a given atom in the 1st column.
C>                In the 2nd column, this integer array indicates
C>                the total number of external orbitals on a given atom.
C>                The orbitals are contiguous so that a L0*NAT array
C>                does not have to given at this time...
C> @param IPOSNOS      is integer scratch array of L1+1 length.
C> @param RADWGT       holds the atomic inverse MO radial weights
C>                     for all MOs for all atoms.
C> @param SAVWGT       holds the final atomic inverse MO radial weights.
C> @param EIGHLD       holds atomic densities for the externals.
C> @param IOPTION      =0 uses values stored in RADWGT for the weights.
C>                     =1 uses the eigenvalues stored in EIGHLD from
C>                        the separate atomic diagonalizations.
C> @param L0           is the length of the MO variational space.
C> @param L1           is the length of the basis set.
C> @param NAT          is the number of atoms.
C> @param L0MBS        is the dimension of the minimal basis set number of
C>                     orbitals.  L0MBS is derived from NCORTOT + LOCAL_NUMVAL.
C> @param ISAV_NOS     counts up the number of NOs that have weightings above
C>                     the cut-off TOL_CUTDEN.
C> @param ICOUNT_NOS   gives the number of NOs printed off to the .log file.
C>                     This might be different from ISAV_NOS.
C>                     the cut-off TOL_CUTDEN.
C> @param TOL_CUTDEN   is the cut-off for keeping the NOs that get printed off
C>                     as well as reordered for the various write outs.
C>                     This tolerance is for compactness but was originally
C>                     for occupation cut-off only... hence the name...
C> @param MASWRK       indicates the master process.
C> @param IW           indicates write out to the log file.
      SUBROUTINE LOCAL_NOS__PREPWGTSANDORDER(
     *           IPOSEXT,IPOSNOS,RADWGT,SAVWGT,
     *           EIGHLD,IOPTION,
     *           L0,L1,NAT,L0MBS,ISAV_NOS,ICOUNT_NOS,TOL_CUTDEN,
     *           MASWRK,IW)
C
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER IERR,IW,L0,L1,NAT,L0MBS,
     *        ISAV_NOS,ICOUNT_NOS,ICOUNT_OUTS,ICOUNT_INS
      DOUBLE PRECISION :: EIGHLD(L1,NAT),RADWGT(L0,NAT),SAVWGT(L0)
      INTEGER IPOSNOS(L0+1),IPOSEXT(NAT+1)
      INTEGER IPOS,IPOS1,IOPTION
C
      DOUBLE PRECISION :: TOL_CUTDEN
C
      INTEGER IATM1,I,IBEG,IEND
      DOUBLE PRECISION :: TMP
C
C     INIT. THE ERROR CHECKING
      IERR=0
C
C     LOCATE THE ORBITALS WITH THE MOST COMPACT CHARACTER...
C     FOR NOW...
C     ASSUME SVD DEFINES ATOMS.
C     I.E. USE ONLY THE RADWGTS WITHIN SVD ORBITAL RANGE.
C     THUS... THE HEIRARCHY IS...
C     FIRST,  THESE ARE ORDERED BY ATOM.
C     SECOND, THESE ARE ORDERED BY RADWGT
C             WITHIN EACH ATOM GROUPING.
C
C     NOTE:
C     IN ORDER TO USE IDAMAX ON SAVWGT ARRAY, WE CANNOT USE
C     RELATIVE WEIGHTS FROM LOCAL_WEIGHTED_SYM_ORTHOG.
C     IN THAT ROUTINE, WE HAVE THE SMALLEST WEIGHT OF ZERO.
C     THEN, IDAMAX HAS NO IDEA WHERE TO FIND THE 'SMALLEST' INDEX.
      CALL VICLR(IPOSNOS,1,L0+1)
      CALL VCLR(SAVWGT,1,L0)
      ICOUNT_NOS=0
      ICOUNT_INS=L0MBS+1
      ICOUNT_OUTS=L0
      IF(IOPTION.EQ.1) THEN
        DO I=1,NAT
          CALL DCOPY(L0,EIGHLD(1,I),1,RADWGT(1,I),1)
        ENDDO
      ENDIF
      DO IATM1=1,NAT
C
         IBEG=IPOSEXT(IATM1)
         IEND=IPOSEXT(IATM1+1)-1
C
         IPOS1=0
         DO I=IBEG,IEND
            IPOS1=IPOS1+1
            IPOS=I
C           NEXT LINE DOWNSHIFTS AND STARTS FROM 1 WHEN IOPTION=1.
            IF(IOPTION.EQ.1) IPOS=IPOS1
            TMP=RADWGT(IPOS,IATM1)
            SAVWGT(I)=TMP
CSORT_BY_ATOM_AND_WEIGHT
CSORT_BY_ATOM_AND_WEIGHT
CSORT_BY_ATOM_AND_WEIGHT
            IF(TMP.GE.TOL_CUTDEN) THEN
               IPOSNOS(ICOUNT_INS)=I
               ICOUNT_INS=ICOUNT_INS+1
               ICOUNT_NOS=ICOUNT_NOS+1
            ELSE
               IPOSNOS(ICOUNT_OUTS)=I
               ICOUNT_OUTS=ICOUNT_OUTS-1
            ENDIF
CSORT_BY_ATOM_AND_WEIGHT
CSORT_BY_ATOM_AND_WEIGHT
CSORT_BY_ATOM_AND_WEIGHT
         ENDDO
      ENDDO
      ISAV_NOS=ICOUNT_NOS
C
CSORT_BY_WEIGHT_ONLY
CSORT_BY_WEIGHT_ONLY this next piece overides the last sort.
CSORT_BY_WEIGHT_ONLY
      CALL VICLR(IPOSNOS,1,L0+1)
      CALL DCOPY(L0,SAVWGT,1,RADWGT(1,1),1)
      CALL LOCAL_SORT_EVALS(L0MBS+1,L0,L0,IPOSNOS,RADWGT(1,1))
      CALL VCLR(RADWGT,1,L0*NAT)
      ICOUNT_NOS=L0-L0MBS
      ICOUNT_OUTS=0
CSORT_BY_WEIGHT_ONLY
CSORT_BY_WEIGHT_ONLY
CSORT_BY_WEIGHT_ONLY
CSORT_BY_WEIGHT_ONLY
C
C     PUT IN THE MBS NUMBERS
      DO I=1,L0MBS
         IPOSNOS(I)=I
      ENDDO
C
C     TACK ON THE TOTAL NOS TO KEEP AT THE END OF IPOSNOS ARRAY.
      IPOSNOS(L0+1)=ISAV_NOS
C
C     IF ICOUNT_NOS=0, ERROR OUT.
      IF(ICOUNT_NOS.EQ.0) THEN
        IF(MASWRK) WRITE(IW,9001)
        IERR=IERR+1
      ENDIF
C
C     SMALL ERROR CHECKING ON INDICES...
      IF(L0MBS+ICOUNT_NOS.GT.L0) THEN
        IF(MASWRK) WRITE(IW,9002)
        IERR=IERR+1
      ENDIF
C
C     ERROR OUT IF IERR>0...
      IF(IERR.GT.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9001 FORMAT(//1X,'LOCAL_NOS__PREPWGTSANDORDER ERROR:',
     *        /1X,'ICOUNT_NOS EQUALS ZERO.  WRONG...',
     *        /1X,'PLEASE INSPECT TOL_CUTDEN FOR WHY.')
 9002 FORMAT(//1X,'LOCAL_NOS__PREPWGTSANDORDER ERROR:',
     *        /1X,'L0MBS+ICOUNT_NOS BIGGER THAN L0...',
     *         1X,'WRONG...')
      END
C*MODULE LOCAL   *DECK LOCAL_ATOMIC_HSANDT
C> @brief      Calculate atomic inverse radial expect. value
C>
C> @author     Aaron West
C>             -April 02, 2013
C>
C> @details    Calculate atomic nuclear attraction integrals
C>             but without the nuclear factor.
C>             i.e.  radial expectation values for the
C>                   atomic orbitals
C>             In order to compare with regular HSANDT code,
C>             I've put in a switch the nuc. attraction
C>             as summed over all atoms e.g. like in HSANDT.
C>             It is always good to check and verify.
C>
C> @note       I was told to make a separate routine.
C>             I can try to combine later if needed.
C>             This code is checked by reproducing the results
C>             from the original HSANDT routine by summing over atoms.
C>
C> @param H            will contain the nuclear attraction integrals
C>                     or atomic inverse radial expectation values
C>                     as chosen by ISVD_NUCINT and ISVD_ATOM with exit.
C> @param LL2          is the triangular dimesion of the 'working' NUM
C>                     from the INFOA.
C> @param ISVD_NUCINT  =1 gives original result from HSANDT
C>                      for the nuclear attraction integrals only
C>                      as summed over all atoms.
C>                     =2 gives the atomic radial expectation value
C>                      for the atomic orbitals relative to
C>                      atom ISVD_ATOM.
C> @param ISVD_ATOM     is the atom used in evaluating the integral.
C>
      SUBROUTINE LOCAL_ATOMIC_HSANDT(H,LL2,ISVD_NUCINT,ISVD_ATOM,
     *                               ISW_RADIAL)
      IMPLICIT NONE
C-----------------------------------------------------------------------
      INTEGER NONE
      DOUBLE PRECISION :: RNONE
      DATA NONE,RNONE/4HNONE,8HNONE    /
C-----------------------------------------------------------------------
      LOGICAL DOUBLE2
      DOUBLE PRECISION ::
     *       AA,AA1,AAX,AAY,AAZ,AI,AJ,ARRI,AX,AXI,AY,
     *       AYI,AZ,AZI,CX,CY,CZ,DTWO,DUM,FAC,FACI,RR,
     *       SPDIJ,TT,UU,WW,ZNUC
      INTEGER ISVD_NUCINT,ISVD_ATOM,ISW_RADIAL
      INTEGER IG,JG,I,I1,I2,IC,IEND,IJ,IN,IPCOUNT,ISTART,J,J0,
     *        J1,J2,JGMAX,JN,JSTART,K,L1,L2,LI,LJ,LL2,
     *        LOCI,LOCIJ,LOCJ,MAX,MM,NATED,NATST,NERR,
     *        NN,NN1,NX,NY,NZ
C-----------------------------------------------------------------------
      INTEGER MXSH,MXGTOT,MXATM,MAXSH
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000, MAXSH=84)
C-----------------------------------------------------------------------
C     VARS FOR COMMON BLOCKS NOW FOLLOW IN THE COMMON BLOCK ORDER.
C
      INTEGER NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
C
      INTEGER NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,IAN
      DOUBLE PRECISION :: ZAN,C
C
      INTEGER IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA
C
      LOGICAL ISEPS,USEPS
C
      DOUBLE PRECISION :: EX,CS,CP,CD,
     *                    CF,CG,CH,CI
      INTEGER KSTART,KATOM,KTYPE,KNG,
     *        KLOC,KMIN,KMAX,NSHELL
C
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION :: XX,U,W
      INTEGER NROOTS
C
      LOGICAL SCREEN
      DOUBLE PRECISION :: VLAMB
C
      DOUBLE PRECISION :: PNRM
C
      DOUBLE PRECISION :: XINT,YINT,ZINT,TAA,X0,Y0,Z0,
     *                    XI,YI,ZI,XJ,YJ,ZJ
      INTEGER NI,NJ
C
      DOUBLE PRECISION :: TOL
      INTEGER II,JJ,LIT,LJT,MINI,MINJ,MAXI,MAXJ
      LOGICAL IANDJ
C
      DOUBLE PRECISION :: RMETHOD,QRQMT,CLIG,CLIG2,QRTOL
      INTEGER IQRORD,MODQR,NESOC,NRATOM,NUMU,NQMTR,NQRDAF,MORDA,
     *        NDARELB
C
      DOUBLE PRECISION :: W1,W2,W3,W4,W5,W6,W7,
     *                    W8,W9,W10,
     *                    W11,W12,W13,W14,W15
C
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C-----------------------------------------------------------------------
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /ISEPS / ISEPS,USEPS
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /ROOT  / XX,U(13),W(13),NROOTS
      COMMON /SCINP / VLAMB,SCREEN
      COMMON /SHLNRM/ PNRM(84)
      COMMON /STV   / XINT,YINT,ZINT,TAA,X0,Y0,Z0,
     *                XI,YI,ZI,XJ,YJ,ZJ,NI,NJ
      COMMON /SYMIND/ TOL,II,JJ,LIT,LJT,MINI,MINJ,MAXI,MAXJ,IANDJ
      COMMON /RELWFN/ RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,IQRORD,MODQR,NESOC,
     *                NRATOM,NUMU,NQMTR,NQRDAF,MORDA,NDARELB
C                          JUST THE 1ST ELEMENT IS USED, W/O /HERMIT/
      COMMON /WERMIT/ W1,W2(2),W3(3),W4(4),W5(5),W6(6),W7(7),
     *                W8(8),W9(9),W10(10),
     *                W11(11),W12(12),W13(13),W14(14),W15(15)
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C-----------------------------------------------------------------------
      DOUBLE PRECISION :: ZERO,PT5,ONE,TWO,PI212,RLN10
      PARAMETER (ZERO=0.0D+00, PT5=0.5D+00, ONE=1.0D+00, TWO=2.0D+00,
     *           PI212=1.1283791670955D+00, RLN10=2.30258D+00)
C-----------------------------------------------------------------------
C     SOME ORIGINAL VARS GO HERE.
      DOUBLE PRECISION :: H(LL2),VBLK(784),DIJ(784),
     *                    XIN(343),YIN(343),ZIN(343),
     *                    CONI(MAXSH),CONJ(MAXSH)
      INTEGER IJX(784),IJY(784),IJZ(784),
     *        IX(84),IY(84),IZ(84),JX(84),JY(84),JZ(84)
C-----------------------------------------------------------------------
C
      DATA JX / 0, 1, 0, 0, 2, 0, 0, 1, 1, 0,
     *          3, 0, 0, 2, 2, 1, 0, 1, 0, 1,
     *          4, 0, 0, 3, 3, 1, 0, 1, 0, 2,
     *          2, 0, 2, 1, 1,
     *          5, 0, 0, 4, 4, 1, 0, 1, 0, 3,
     *          3, 2, 0, 2, 0, 3, 1, 1, 2, 2,
     *          1,
     *          6, 0, 0, 5, 5, 1, 0, 1, 0, 4,
     *          4, 2, 0, 2, 0, 4, 1, 1, 3, 3,
     *          0, 3, 3, 2, 1, 2, 1, 2/
      DATA IX / 1, 8, 1, 1,15, 1, 1, 8, 8, 1,
     *         22, 1, 1,15,15, 8, 1, 8, 1, 8,
     *         29, 1, 1,22,22, 8, 1, 8, 1,15,
     *         15, 1,15, 8, 8,
     *         36, 1, 1,29,29, 8, 1, 8, 1,22,
     *         22,15, 1,15, 1,22, 8, 8,15,15,
     *          8,
     *         43, 1, 1,36,36, 8, 1, 8, 1,29,
     *         29,15, 1,15, 1,29, 8, 8,22,22,
     *          1,22,22,15, 8,15, 8,15/
      DATA JY / 0, 0, 1, 0, 0, 2, 0, 1, 0, 1,
     *          0, 3, 0, 1, 0, 2, 2, 0, 1, 1,
     *          0, 4, 0, 1, 0, 3, 3, 0, 1, 2,
     *          0, 2, 1, 2, 1,
     *          0, 5, 0, 1, 0, 4, 4, 0, 1, 2,
     *          0, 3, 3, 0, 2, 1, 3, 1, 2, 1,
     *          2,
     *          0, 6, 0, 1, 0, 5, 5, 0, 1, 2,
     *          0, 4, 4, 0, 2, 1, 4, 1, 3, 0,
     *          3, 2, 1, 3, 3, 1, 2, 2/
      DATA IY / 1, 1, 8, 1, 1,15, 1, 8, 1, 8,
     *          1,22, 1, 8, 1,15,15, 1, 8, 8,
     *          1,29, 1, 8, 1,22,22, 1, 8,15,
     *          1,15, 8,15, 8,
     *          1,36, 1, 8, 1,29,29, 1, 8,15,
     *          1,22,22, 1,15, 8,22, 8,15, 8,
     *         15,
     *          1,43, 1, 8, 1,36,36, 1, 8,15,
     *          1,29,29, 1,15, 8,29, 8,22, 1,
     *         22,15, 8,22,22, 8,15,15/
      DATA JZ / 0, 0, 0, 1, 0, 0, 2, 0, 1, 1,
     *          0, 0, 3, 0, 1, 0, 1, 2, 2, 1,
     *          0, 0, 4, 0, 1, 0, 1, 3, 3, 0,
     *          2, 2, 1, 1, 2,
     *          0, 0, 5, 0, 1, 0, 1, 4, 4, 0,
     *          2, 0, 2, 3, 3, 1, 1, 3, 1, 2,
     *          2,
     *          0, 0, 6, 0, 1, 0, 1, 5, 5, 0,
     *          2, 0, 2, 4, 4, 1, 1, 4, 0, 3,
     *          3, 1, 2, 1, 2, 3, 3, 2/
      DATA IZ / 1, 1, 1, 8, 1, 1,15, 1, 8, 8,
     *          1, 1,22, 1, 8, 1, 8,15,15, 8,
     *          1, 1,29, 1, 8, 1, 8,22,22, 1,
     *         15,15, 8, 8,15,
     *          1, 1,36, 1, 8, 1, 8,29,29, 1,
     *         15, 1,15,22,22, 8, 8,22, 8,15,
     *         15,
     *          1, 1,43, 1, 8, 1, 8,36,36, 1,
     *         15, 1,15,29,29, 8, 8,29, 1,22,
     *         22, 8,15, 8,15,22,22,15/
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C     ----- COMPUTE CONVENTIONAL H, S, AND T INTEGRALS -----
C     NOTES:
C     --HSANDT ROUTINE WAS CHOPPED DOWN FOR THE
C       THE BARE NUCLEAR INTEGRALS... BUT SOME UN-SUMMED VERSIONS OF THEM.
C     --INDENTED WAS NOT FIXED DURING CHOPPING.
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C
C     ----- SET TOLERANCE TOL -----
C
      TOL = RLN10*ITOL
C
C     NOTE THAT LL2 IS ALWAYS (NUM*NUM+NUM)/2,
C
      ISTART = 1
      IEND   = NSHELL
      JSTART = 1
      LOCIJ  = 0
      IF(ISVD_NUCINT.EQ.1) THEN
        NATST  = 1
        NATED  = NAT
      ELSEIF(ISVD_NUCINT.EQ.2) THEN
        NATST=ISVD_ATOM
        NATED=ISVD_ATOM
      ELSE
      ENDIF
      L1 = NUM
      L2 = (L1*(L1+1))/2
C
C     ----- ERROR OUTS -----
C
      NERR=0
      IF(MPCTYP.NE.NONE) THEN
        IF (MASWRK) WRITE(IW,9010)
        NERR=NERR+1
      END IF
      IF(RMETHOD.NE.RNONE) THEN
        IF (MASWRK) WRITE(IW,9011)
        NERR=NERR+1
      END IF
      IF(LL2.NE.L2) THEN
        IF (MASWRK) WRITE(IW,9012)
        NERR=NERR+1
      END IF
      IF(NFG.NE.0) THEN
        IF (MASWRK) WRITE(IW,9013)
        NERR=NERR+1
      END IF
      IF(SCREEN) THEN
        IF (MASWRK) WRITE(IW,9014)
        NERR=NERR+1
      END IF
      IF(ISEPS) THEN
        IF (MASWRK) WRITE(IW,9015)
        NERR=NERR+1
      END IF
      IF(ISVD_NUCINT.NE.1.AND.ISVD_NUCINT.NE.2) THEN
        IF (MASWRK) WRITE(IW,9016)
        NERR=NERR+1
      ENDIF
      IF(ISVD_NUCINT.EQ.2) THEN
      IF(ISVD_ATOM.LT.1.OR.ISVD_ATOM.GT.NAT) THEN
        IF (MASWRK) WRITE(IW,9017)
        NERR=NERR+1
      ENDIF
      ENDIF
      IF(ISVD_NUCINT.EQ.1) THEN
      IF(ISVD_ATOM.NE.0) THEN
        IF (MASWRK) WRITE(IW,9018)
        NERR=NERR+1
      ENDIF
      ENDIF
      IF(NERR.GT.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
      ENDIF
C
C
C     DO WHEN PARALLEL OR NOT.
      CALL VCLR(H ,1,LL2)
C
C     ----- INTIALIZE PARALLEL -----
C
      IPCOUNT = ME - 1
C
C     ----- I SHELL -----
C
      DO 720 II = ISTART,IEND
         I = KATOM(II)
         XI = C(1,I)
         YI = C(2,I)
         ZI = C(3,I)
         I1 = KSTART(II)
         I2 = I1+KNG(II)-1
         LIT = KTYPE(II)
         MINI = KMIN(II)
         MAXI = KMAX(II)
         LOCI = KLOC(II)-MINI-LOCIJ
C
C     ----- J SHELL -----
C
         DO 700 JJ = JSTART,II
C
C     ----- GO PARALLEL! (STATIC LOAD BALANCING) -----
C
            IF (GOPARR) THEN
               IPCOUNT = IPCOUNT + 1
               IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 700
            END IF
C
            J = KATOM(JJ)
            XJ = C(1,J)
            YJ = C(2,J)
            ZJ = C(3,J)
            J1 = KSTART(JJ)
            J2 = J1+KNG(JJ)-1
            LJT = KTYPE(JJ)
            MINJ = KMIN(JJ)
            MAXJ = KMAX(JJ)
            LOCJ = KLOC(JJ)-MINJ-LOCIJ
            NROOTS = (LIT+LJT-2)/2+1
            RR = (XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
            IANDJ = II .EQ. JJ
C
C
C     ----- PREPARE INDICES FOR PAIRS OF (I,J) FUNCTIONS
C
            IJ = 0
            MAX = MAXJ
            DO 160 I = MINI,MAXI
               NX = IX(I)
               NY = IY(I)
               NZ = IZ(I)
               IF (IANDJ) MAX = I
               DO 140 J = MINJ,MAX
                  IJ = IJ+1
                  IJX(IJ) = NX+JX(J)
                  IJY(IJ) = NY+JY(J)
                  IJZ(IJ) = NZ+JZ(J)
  140          CONTINUE
  160       CONTINUE
C
            CALL VCLR( VBLK,1,IJ)
C
C     ----- I PRIMITIVE
C
            JGMAX = J2
            DO 520 IG = I1,I2
               AI = EX(IG)
               ARRI = AI*RR
               AXI = AI*XI
               AYI = AI*YI
               AZI = AI*ZI
               CALL SETCONI(CONI,IG,0)
C
C     ----- J PRIMITIVE
C
               IF (IANDJ) JGMAX = IG
               DO 500 JG = J1,JGMAX
                  AJ = EX(JG)
                  AA = AI+AJ
                  AA1 = ONE/AA
                  DUM = AJ*ARRI*AA1
                  IF (DUM .GT. TOL) GO TO 500
                  FAC = EXP(-DUM)
                  CALL SETCONI(CONJ,JG,0)
                  AX = (AXI+AJ*XJ)*AA1
                  AY = (AYI+AJ*YJ)*AA1
                  AZ = (AZI+AJ*ZJ)*AA1
C
C     ----- DENSITY FACTOR
C
C     THE ONLY REASON WHY -ILZ WORKS WITH THIS DENSITY THAT ASSUMES
C     HERMITICITY IS BECAUSE <I|-ILZ|I>=0 (MOMENTUM QUENCHING).
C
                  DOUBLE2=IANDJ.AND.IG.NE.JG
                  MAX = MAXJ
                  NN = 0
                  DTWO=ONE
                  IF(DOUBLE2) DTWO=TWO
C                 NOTE THAT PNRM FACTORS FOR S AND P SHELLS ARE 1.
                  SPDIJ=CS(IG)*CP(JG)*FAC
                  DO 220 I = MINI,MAXI
                     IF (IANDJ) MAX = I
                     FACI=FAC*CONI(I)*PNRM(I)*DTWO
                     NN1=NN+1
                     DO 200 J = MINJ,MAX
                        NN = NN+1
                        DIJ(NN)=FACI*CONJ(J)*PNRM(J)
C                    WRITE(6,*) 'WWWDIJ',NN,I,J,II,JJ,DIJ(NN)
  200                CONTINUE
C            CORRECT FOR L-SHELL DOUBLE COUNTING OF THE SP
C            OFF-DIAGONAL TERMS (FOR NON-L SHELLS CSI*CPJ IS ZERO).
C            NN1 POINTS TO THE APPROPRIATE DENSITY ELEMENT
                     IF(MINJ.LE.1.AND.I.GT.1.AND.DOUBLE2)
     *                 DIJ(NN1)=DIJ(NN1)*PT5+SPDIJ
  220             CONTINUE
C
C     ----- NUCLEAR ATTRACTION -----
C
                     DUM = PI212*AA1
                     DO 400 I = 1,IJ
                        DIJ(I) = DIJ(I)*DUM
  400                CONTINUE
C
                  AAX = AA*AX
                  AAY = AA*AY
                  AAZ = AA*AZ
C
                  AAX = AA*AX
                  AAY = AA*AY
                  AAZ = AA*AZ
                  DO 460 IC = NATST,NATED
                     ZNUC=1.0D+00
                     IF(ISVD_NUCINT.EQ.1) ZNUC = -ZAN(IC)
                     IF(ISW_RADIAL.EQ.1) THEN
                        ZNUC=1.0D+00
ccccc                        ZNUC=3.217D+00
ccccc                        ZNUC=4.492D+00
                     ENDIF
C
                     CX = C(1,IC)
                     CY = C(2,IC)
                     CZ = C(3,IC)
C
                     XX = AA*((AX-CX)**2+(AY-CY)**2+(AZ-CZ)**2)
                     IF (NROOTS.LE.3) CALL RT123
                     IF (NROOTS.EQ.4) CALL ROOT4
                     IF (NROOTS.EQ.5) CALL ROOT5
                     IF (NROOTS.GE.6) CALL ROOT6
                     MM = 0
                     DO 430 K = 1,NROOTS
                        UU = AA*U(K)
                        WW = W(K)*ZNUC
                        TT = ONE/(AA+UU)
                        TAA = SQRT(TT)
                        X0 = (AAX+UU*CX)*TT
                        Y0 = (AAY+UU*CY)*TT
                        Z0 = (AAZ+UU*CZ)*TT
                        IN = -7+MM
                        J0 = 2
C
C                       J0 SKIPS THE TRIVIAL COMBINATION NI=NJ=1
C                       THAT IS DONE EXPLICITLY NOW
C
                        XIN(IN+8) = W1
                        YIN(IN+8) = W1
                        ZIN(IN+8) = W1*WW
                        DO 420 I = 1,LIT
                           IN = IN+7
                           NI = I
                           DO 410 J = J0,LJT
                              JN = IN+J
                              NJ = J
                              CALL STVINT
                              XIN(JN) = XINT
                              YIN(JN) = YINT
                              ZIN(JN) = ZINT*WW
  410                      CONTINUE
                           J0 = 1
  420                   CONTINUE
                        MM = MM+49
  430                CONTINUE
                     DO 450 I = 1,IJ
                        NX = IJX(I)
                        NY = IJY(I)
                        NZ = IJZ(I)
                        DUM = ZERO
                        MM = 0
                        DO 440 K = 1,NROOTS
                           DUM = DUM+XIN(NX+MM)*YIN(NY+MM)*ZIN(NZ+MM)
                           MM = MM+49
  440                   CONTINUE
                        VBLK(I) = VBLK(I) + DUM*DIJ(I)
  450                CONTINUE
C
  460              CONTINUE
C
C     ----- END OF PRIMITIVE LOOPS -----
C
  500          CONTINUE
  520       CONTINUE
C
C     ----- SET BLOCK OF NUCLEAR ATTRACTION
C
            MAX = MAXJ
            NN = 0
            DO 620 I = MINI,MAXI
               LI = LOCI+I
               IN = (LI*(LI-1))/2
               IF (IANDJ) MAX = I
               DO 600 J = MINJ,MAX
                  LJ = LOCJ+J
                  JN = LJ+IN
                  NN = NN+1
                  H(JN) =  VBLK(NN)
  600          CONTINUE
  620       CONTINUE
C
C     ----- END OF SHELL LOOPS -----
C
  700    CONTINUE
  720 CONTINUE
C
C     ----- SUM UP PARTIAL CONTRIBUTIONS IF PARALLEL -----
C
      IF (GOPARR) THEN
         CALL DDI_GSUMF(910,H,L2)
      END IF
C
C     ----- H MATRIX IS NOW COMPLETE AND RETURNED.
C



      RETURN
 9010 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT IS NOT PROGRAMMED FOR MCPS.')
 9011 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT',
     *        1X,'IS NOT PROGRAMMED FOR RELATIVITY.')
 9012 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT IS NOT PROGRAMMED FOR',
     *        1X,'LL2 NE L2 CONDITIONS.')
 9013 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT IS NOT PROGRAMMED FOR FMO.')
 9014 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT',
     *        1X,'IS NOT PROGRAMMED FOR SCREEN=.TRUE.')
 9015 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT',
     *        1X,'IS NOT PROGRAMMED FOR ISEPS=.TRUE.')
 9016 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT MUST HAVE ISVD_NUCINT=1 OR 2.')
 9017 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT HAS ISVD_ATOM OUT OF RANGE.')
 9018 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT',
     *        1X,'HAS ISVD_ATOM NE 0 FOR ISVD_NUCINT.',
     *       /1X,'ISVD_ATOM HAS USE HERE... AND SHOULD BE 0.')
      END
C*MODULE LOCAL   *DECK LOCAL_NOS__NUCLEAR_CHARGES
C> @brief      Sets effective nuclear charge for nos_ext runs.
C>
C> @author     Aaron West
C>             -April 20, 2013
C>
C> @details    Sets effective nuclear charge for nos_ext runs.
C>             These values are based off of using Slater's
C>             rules.  However, these values are for
C>             2 electrons rather than the usual rules.
C>
C> @param ZAN      is nuclear charge for each atom.
C> @param IAN      is the atomic number for each atom.
C> @param IAN_SAV  is the atomic number saved.
C> @param IATM1    is the current atom number in the do loop.
C> @param NAT      is the total number of atoms.
C> @param ICH_SAV  is the charge of the molecule.
C> @param IW       indicates unit for write out to .log file.
C> @param SOME     is true for master process with nprint not equal -5.
C> @param MASWRK   indicates the master process.
C>
      SUBROUTINE LOCAL_NOS__NUCLEAR_CHARGES(
     *           ZAN,IAN,IAN_SAV,IATM1,NAT,ICH_SAV,
     *           IW,SOME,MASWRK)
      IMPLICIT NONE
      LOGICAL SOME,MASWRK
      INTEGER IATM1,NAT,ICH_SAV,IW,NERR
      DOUBLE PRECISION :: ZNUC,ZAN(NAT)
      INTEGER INUC,IAN(NAT),IAN_SAV(NAT)
C
      DOUBLE PRECISION :: FACT0,FACT1,FACT2
      INTEGER IELSCT
      PARAMETER (FACT0=1.0D+00,FACT1=0.85D+00,FACT2=0.35D+00)
      PARAMETER (IELSCT=2)
C
C     INITIALIZE THE NEEDED ARRAYS
      CALL VCLR(ZAN,1,NAT)
      CALL VICLR(IAN,1,NAT)
      IAN(IATM1)=IAN_SAV(IATM1)
      INUC=IAN_SAV(IATM1)
C
C     SETUP THE EFFECTIVE CHARGES TABLE.
      NERR=0
      ZNUC=DBLE(INUC)
      IF(INUC.EQ.1) THEN
C       ZNUC IS SET TO 1 ALREADY FOR H.
C       AARON HAS NO INTEREST RIGHT NOW IN HE.
      ELSEIF(INUC.GE.3.AND.INUC.LE.10   ) THEN
        ZNUC=ZNUC
     *      -(2)*FACT1
     *      -((INUC-3+1)-IELSCT)*FACT2
      ELSEIF(INUC.GE.11.AND.INUC.LE.18  ) THEN
        ZNUC=ZNUC
     *      -(2)*FACT0-(8)*FACT1
     *      -((INUC-11+1)-IELSCT)*FACT2
      ELSEIF(INUC.GE.19.AND.INUC.LE.20  ) THEN
        ZNUC=ZNUC
     *      -(10)*FACT0-(8)*FACT1
     *      -((INUC-11+1)-IELSCT)*FACT2
      ELSEIF(INUC.GE.21.AND.INUC.LE.30  ) THEN
        ZNUC=ZNUC
     *      -(18)*FACT0            ! d get all +1.
     *      -((INUC-21+1)-IELSCT)*FACT2 ! Start at 21. Skip lower s block.
      ELSEIF(INUC.GE.31.AND.INUC.LE.36  ) THEN
        ZNUC=ZNUC
     *      -(10)*FACT0-(8)*FACT1
     *      -(10)*FACT1            ! the lower d shell counts here.
     *      -(2)*FACT2             ! count the s shell here
     *      -((INUC-31+1)-IELSCT)*FACT2
      ELSE
        NERR=NERR+1
        IF(MASWRK) WRITE(IW,9002)
      ENDIF
C
C     SET THE FINAL EFFECTIVE CHARGE
      IF(SOME) WRITE(IW,9001) ZNUC
      ZAN(IATM1)=ZNUC
C
C     PERFORM ANY MORE ERROR OUTS.
      IF(ICH_SAV.NE.0) THEN
        NERR=NERR+1
        IF(MASWRK) WRITE(IW,9003)
      ENDIF
      IF(ZAN(IATM1).LE.0.0D+00) THEN
        NERR=NERR+1
        IF(MASWRK) WRITE(IW,9004)
      ENDIF
      IF(NERR.GT.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
      ENDIF
C
      RETURN
 9001 FORMAT(1X,'EFFECTIVE NUCLEAR CHARGE=',F10.3)
 9002 FORMAT(//1X,'LOCAL_NOS__NUCLEAR_CHARGES ERROR:',
     *        /1X,'YOU REQUESTED AN EFECTIVE CHARGE',
     *         1X,'THAT IS NOT PROGRAMMED YET.',
     *        /1X,'PLEASE ADD IT TO THE ROUTINE.',
     *        /1X,'THIS TABLE WAS NOT COMPLETED ON PURPOSE',
     *         1X,'BECAUSE OF TRANSITION METAL ISSUES.')
 9003 FORMAT(//1X,'LOCAL_NOS__NUCLEAR_CHARGES ERROR:',
     *        /1X,'WHAT IS THE EFFECTIVE CHARGE FOR A',
     *         1X,'NON-NEUTRAL MOLECULE?')
 9004 FORMAT(//1X,'LOCAL_NOS__NUCLEAR_CHARGES ERROR:',
     *        /1X,'NUCLEAR CHARGES CANNOT BE LESS THAN 0!')
      END
C*MODULE LOCAL   *DECK LOCAL_ATOMIC_TOTAL_INVRAD
C> @brief      Create the atomic <1/r> matrices.
C>
C> @author     Aaron West
C>             -May 07, 2013
C>
C> @details    This routine creates the atomic <1/r> matrices
C>             in the MO basis.
C>             The MOs should be from file 522.
C>             This routine pulls out all of the arrays required
C>             to do this item.
C>             Sometimes, if already embedded in an atom loop,
C>             I might avoid this routine and do from scratch
C>             for other reasons... such as if I wanted
C>             to conveniently change the definition of the
C>             <1/r> matrix to <T+1/r> or whatever.
C>             Remember that if you sub. in this routine to
C>             other locations, you will need to deal with
C>             all new reordering issues.
C>             So, unless you understand what you are doing,
C>             only use this routine a-new rather than
C>             fixing up old code.
C>
C> @param RADTRI  contains the NON-SHIFTED symmetric <1/r> matrices.
C>                The matrix is L0TRIxNAT.
C>                Each symmetric matrix starts at position 1 of the
C>                given atom.
C>                Later, we read out the variable by skipping over
C>                however many atoms have preceeded the current atom.
C> @param VEC     the MOs that get used to contruct the <1/r> in the
C>                given MO basis.
C>                If you have not already figured it out,
C>                this variable contains internals+externals.
C>                KEEP TRACK OF THE INDICES... ROUND AND ROUND...
C> @param IPOSEXT indicates the orbital index for the first external
C>                orbital on a given atom in the 1st column.
C>                In the 2nd column, this integer array indicates
C>                the total number of external orbitals on a given atom.
C>                The orbitals are contiguous so that a L0*NAT array
C>                does not have to given at this time...
C> @param STRI    is a scratch array of L0TRI length.
C> @param S       is a scratch array of L2 length.
C> @param EIG     is a scratch array of L1 length.
C> @param NAT     is the number of atoms.
C> @param L0      is the length of the MO variational space.
C> @param L0TRI   is the triangular length of L0.
C> @param L1      is the length of the AO coefficients.
C> @param L2      is the triangular length of L1.
      SUBROUTINE LOCAL_ATOMIC_TOTAL_INVRAD(
     *           RADTRI,VEC,IPOSEXT,
     *           STRI,S,EIG,NAT,L0,L0TRI,L1,L2)
C
      IMPLICIT NONE
      INTEGER IATM1,IBEG,IEND,ICT,I,J,IJ
      INTEGER NAT,L0,L0TRI,L1,L2,IPOSEXT(NAT+1)
      DOUBLE PRECISION :: RADTRI(L0TRI,NAT),VEC(L1,L1),
     *                    STRI(L0TRI),S(L2),EIG(L1)
C
      DO IATM1=1,NAT
        CALL LOCAL_ATOMIC_HSANDT(S,L2,2,IATM1,1)
CKEEP        call daread(idaf,ioda,s2,l2,13,0)
CKEEP        call daxpy(l2,-1.0d+00,s2,1,s,1)
        CALL TFTRI(STRI,S,VEC,EIG,L0,L1,L1)
        IBEG=IPOSEXT(IATM1)
        IEND=IPOSEXT(IATM1+1)-1
        ICT=0
        DO I=IBEG,IEND
          DO J=IBEG,I
            IJ=(I*I-I)/2+J
            ICT=ICT+1
            RADTRI(ICT,IATM1)=STRI(IJ)
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_GET_IEXTORB
C> @brief      Returns the num. of externals on atom.
C>
C> @author     Aaron West
C>             -May 07, 2013
C>
C> @details    Returns the number of external orbitals
C>             on a given atom.
C>             It is used when convenient.
C>             This number might already be calculated in
C>             more complex routines or NOT...
C>
C> @param IEXTORB is returned as the total number of external
C>                orbitals on a given atom.
C> @param IPOSEXT indicates the orbital index for the first external
C>                orbital on a given atom in the 1st column.
C>                In the 2nd column, this integer array indicates
C>                the total number of external orbitals on a given atom.
C>                The orbitals are contiguous so that a L0*NAT array
C>                does not have to given at this time...
C> @param IATM1   is the current atom in the do loop.
C> @param NAT     is the number of atoms.
C> @param L0      is the length of the MO variational space.
C> @param MASWRK  indicates the master process.
C> @param IW      indicates write out to the log file.
      SUBROUTINE LOCAL_GET_IEXTORB(
     *           IEXTORB,IPOSEXT,IATM1,NAT,L0,MASWRK,IW)
C
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER NAT,IW,IEXTORB,IERR,IATM1,L0,IPOSEXT(NAT+1)
C
      IEXTORB=IPOSEXT(IATM1+1)-IPOSEXT(IATM1)
C
      IERR=0
      IF(IEXTORB.LE.0) THEN
        IF(MASWRK) WRITE(IW,9001)
        IERR=IERR+1
      ENDIF
      IF(IEXTORB.GT.L0) THEN
        IF(MASWRK) WRITE(IW,9002)
        IERR=IERR+1
      ENDIF
      IF(IERR.NE.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9001 FORMAT(//1X,'LOCAL_GET_IEXTORB ERROR:',
     *        /1X,'IEXTORB CANNOT BE LESS THAN 0.')
 9002 FORMAT(//1X,'LOCAL_GET_IEXTORB ERROR:',
     *        /1X,'IEXTORB CANNOT BE GREATER THAN L0.')
      END
C*MODULE LOCAL   *DECK LOCAL_SORT_EVALS
C> @brief      Generally forms reorder array.
C>
C> @author     Aaron West
C>             -May 07, 2013
C>
C> @details    This routine generally forms an array
C>             with integer reordering instructions.
C>             The use of IDAMAX has a few limitations:
C>             1.  It only works with positive values.
C>             2.  Under specific conditions, shifting
C>                 can lead to some buggy code.
C>             In the atomic loc. code, we often need
C>             flexible indices in the arrays.
C>             This routine is similar to JACORD, but
C>             here we track and form an integer
C>             reordering array.
C>
C> @param IBEGn    is the starting index.
C>                 It does not have to 1.
C> @param IENDn    is the ending index.
C> @param LDIM     is the dimension which is often different.
C> @param IPOSNOS  is the integer sorting array.
C> @param EIG      contains the values that are used in the
C>                 sorting e.g. eigenvalues.
      SUBROUTINE LOCAL_SORT_EVALS(IBEGn,IENDn,LDIM,IPOSNOS,EIG)
      IMPLICIT NONE
      INTEGER IDUM,I,J,ITMP
      INTEGER IBEGn,IENDn,LDIM,IPOSNOS(LDIM)
      DOUBLE PRECISION :: TMP,EIG(LDIM)
C
      DO I=IBEGn,IENDn
        IPOSNOS(I)=I
      ENDDO
C
      DO I=IBEGn,IENDn
        IDUM=I
        DO J=I,IENDn
          IF(EIG(J).gt.EIG(IDUM)) IDUM=J
        ENDDO
C
        TMP=EIG(IDUM)
        EIG(IDUM) = EIG(I)
        EIG(I) = TMP
C
        ITMP=IPOSNOS(IDUM)
        IPOSNOS(IDUM)=IPOSNOS(I)
        IPOSNOS(I)=ITMP
      ENDDO
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_NOS_ACAVO
C> @brief      Calculate (s2**2)*i,j 2 el matrices for local nos.
C>
C> @author     Aaron West and Mike Schmidt
C>             -May 07, 2013
C>
C> @details    Calculate (s2**2)*i,j 2 el matrices for local nos.
C>             Right now, only exchange matrices are calculated.
C>             THIS ROUTINE IS BASED ON MIKE SCHMIDT'S AVACO ROUTINE.
C>             THIS ROUTINE IS AN EXTREMELY SPECIALIZED VERSION OF
C>             THE AVACO ROUTINE.
C>             PLEASE SEE AVACO ROUTINE FOR ADDITIONAL NOTES.
C>
C> @param VEC     contains the atomic-like orbitals for a given atom.
C> @param DCORE   is scratch of length L2.
C> @param DVAL    contains the needed AO density of length L2 on entry.
C> @param JCORE   is scratch of length L2.
C> @param JVAL    is scratch of length L2.
C> @param KCORE   is scratch of length L2.
C> @param KVAL    is scratch of length L2.
C> @param SCR     is scratch of length L1*8.
C> @param BUFFX   is scratch of length NINTMX.
C> @param BUFFI   is scratch of length NINTMX.
C> @param NOPK    indicates supermatrix form or not for
C>                the AO integrals.
C> @param NINTMX  should be NTINMX from intfil common.
C> @param L1      is the length of the AO coefficients.
C> @param L2      is the triangular length of L1.
C> @param ITOTOCC is 1 + number of external orbitals on given atom.
      SUBROUTINE LOCAL_NOS_ACAVO(
     *           VEC,DCORE,DVAL,
     *           JCORE,JVAL,KCORE,KVAL,
     *           SCR,BUFFX,BUFFI,
     *           NOPK,NINTMX,L1,L2,
     *           ITOTOCC)
C
      IMPLICIT NONE
C-----------------------------------------------------------------------
      INTEGER L1,L2
      DOUBLE PRECISION :: FJC,FJV,FKC,FKV
      INTEGER NCORE,NINTMX,NOPK,NVAL,ITOTOCC
C-----------------------------------------------------------------------
      DOUBLE PRECISION :: JCORE(L2),JVAL(L2),KCORE(L2),KVAL(L2)
      DOUBLE PRECISION :: PACAVO(6)
      DOUBLE PRECISION :: DCORE(L2),DVAL(L2),VEC(L1,L1),
     *                    SCR(L1,8),BUFFX(NINTMX),
     *                    BUFFI(NINTMX)
C-----------------------------------------------------------------------
C
      INTEGER IA
C
      INTEGER IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
C-----------------------------------------------------------------------
      INTEGER MXAO
      PARAMETER (MXAO=8192)
C-----------------------------------------------------------------------
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C-----------------------------------------------------------------------
C
C     ----- CONSTRUCT GENERAL CORRELATION ADAPTED VIRTUAL ORBITALS -----
C     THIS ROUTINE IS A VERY SPECIALIZED VERSION OF THE ORIGINAL ROUTINE.
C     PLEASE SEE AVACO ROUTINE FOR ADDITIONAL NOTES.
C
C----------------------
      NCORE = 0
      NVAL  = 1
C----------------------
C     4-->columb terms
C     6-->exchange terms
C      -->put to 1 rather than -1 for convenience
C         when only non-zero term is term 6.
      PACAVO(1)=0.0D+00
      PACAVO(2)=0.0D+00
      PACAVO(3)=0.0D+00
      PACAVO(4)=0.0D+00
      PACAVO(5)=0.0D+00
      PACAVO(6)=1.0D+00
C----------------------
      IF (MASWRK) WRITE(IW,9000) ITOTOCC-1,NCORE,NVAL,PACAVO
C
C         VALENCE DENSITY IS ALREADY BUILT AND FED IN.
C         CORE DENSITY IS ZERO.
C
      CALL VCLR(DCORE,1,L2)
C
C         MAKE CORE AND VALENCE COULOMB AND EXCHANGE OPERATORS.
C         THIS IS CODED FOR INTEGRALS ON DISK ONLY, AT PRESENT.
C
      IF(NOPK.NE.1) THEN
         IF(MASWRK) WRITE(IW,9010)
         CALL ABRT
      END IF
      CALL SEQREW(IJK)
      CALL HSTARJK(DCORE,DVAL,JCORE,JVAL,KCORE,KVAL,
     *             BUFFX,BUFFI,NINTMX,IA,NOPK,L1,L2)
C
C         CONSTRUCT THE OPERATOR IN THE AO BASIS IN -DCORE-,
C         USING MATRIX -DVAL- AS SCRATCH STORAGE.
C
cccccc      FT  = PACAVO(1)
cccccc      FV  = PACAVO(2)
      FJC = PACAVO(3)
      FJV = PACAVO(4)
      FKC = PACAVO(5)
      FKV = PACAVO(6)
C
      CALL VCLR(DCORE,1,L2)
cccccc      CALL DAREAD(IDAF,IODA,DVAL ,L2,11,0)
cccccc      CALL DAREAD(IDAF,IODA,DCORE,L2,13,0)
cccccc      CALL VSUB(DCORE,1,DVAL,1,DVAL,1,L2)
cccccc
cccccc      CALL DSCAL(L2,FT ,        DCORE,1)
cccccc      CALL DAXPY(L2,FV ,DVAL ,1,DCORE,1)
      CALL DAXPY(L2,FJC,JCORE,1,DCORE,1)
      CALL DAXPY(L2,FJV,JVAL ,1,DCORE,1)
      CALL DAXPY(L2,FKC,KCORE,1,DCORE,1)
      CALL DAXPY(L2,FKV,KVAL ,1,DCORE,1)

C
C     ----- TRANSFORM INTO MO BASIS -----
C
C     NOTE:  DO NOT SHIFT LIKE THE ORIG. ROUTINE.
C     NOTE:  FIRST ORBITAL IS GARBAGE.  LEAVE IT.
      CALL VCLR(DVAL,1,L2)
      CALL TFTRI(DVAL,DCORE,VEC,SCR,ITOTOCC,L1,L1)
C
      RETURN
C
 9000 FORMAT(/1X,'LOCAL_NOS_ACAVO:',
     *       /1X,'GENERATING',I5,' GENERAL CORRELATION ADAPTED',
     *           ' VIRTUAL ORBITALS...'/
     *        1X,'THERE ARE',I5,' FROZEN CORE ORBITALS, AND',I5,
     *           ' FROZEN VALENCE ORBITALS'/
     *        1X,'ACAVO PARAMETERS=',6F10.5)
 9010 FORMAT(1X,'LOCAL_NOS_ACAVO:',
     *      /1X,'CANNOT FORM J,K MATRICES USING SUPERMATRIX INTEGRALS'/
     *       1X,'PLEASE RESUBMIT WITH NOPK=1')
      END
C*MODULE LOCAL   *DECK LOCAL_MINI_DEN
C> @brief      Forms a mini density matrix of interest.
C>
C> @author     Aaron West
C>             -May 14, 2013
C>
C> @details    This routine forms a mini density matrix.
C>             It allows one to define the orbitals of interest
C>             within the routine itself.
C>             One could run the integer orbital array
C>             through the input at some point,
C>             but I do not see a reason for it right now.
C>
C> @param DENOLD is the original density matrix.
C> @param DENNEW is the new density matrix.
C> @param IWRK   is an integer work array.
C> @param M1     is the total number of active orbitals.
C>               I believe that these are the non-frozen orbitals.
C> @param M2     is the triangular length of the M1xM1 matrix.
C> @param SOME   is true for master process with nprint not equal -5.
C> @param IW     indicates write out to the log file.
C>
      SUBROUTINE LOCAL_MINI_DEN(DENOLD,DENNEW,IWRK,M1,M2,SOME,IW)
      IMPLICIT NONE
      LOGICAL SOME
      INTEGER IW,M1,M2,IWRK(M1),
     *        ISIZ,I,J,IJ,I2,J2,IJ2
      DOUBLE PRECISION :: DENOLD(M2),DENNEW(M2)
C
C     HERE, CHOOSE THE MINI-MATRIX.
C     NOTE:  AN EXAMPLE IS GIVEN.
      CALL VICLR(IWRK,1,M1)
      ISIZ=17
      IWRK(1)=5
      IWRK(2)=6
      IWRK(3)=7
      IWRK(4)=8
      IWRK(5)=16
      IWRK(6)=15
      IWRK(7)=13
      IWRK(8)=14
      IWRK(9)=24
      IWRK(10)=22
      IWRK(11)=21
      IWRK(12)=23
      IWRK(13)=20
      IWRK(14)=19
      IWRK(15)=17
      IWRK(16)=18
      IWRK(17)=36
C
C     MAKE MINI-DEN MATRIX
      CALL VCLR(DENNEW,1,M2)
      DO I2=1,ISIZ
         DO J2=1,I2
            IJ2=(I2*I2-I2)/2+J2
C
            I=MAX(IWRK(I2),IWRK(J2))
            J=MIN(IWRK(I2),IWRK(J2))
            IJ=(I*I-I)/2+J
C
            DENNEW(IJ2)=DENOLD(IJ)
         ENDDO
      ENDDO
C
C     PRINT OFF MINI-DENSITY MATRIX.
      IF(SOME) WRITE(IW,9000)
      CALL PRTRI(DENNEW,ISIZ)
C
      RETURN
 9000 FORMAT(/1X,'MINI DENSITY MATRIX=')
      END
C*MODULE LOCAL   *DECK LOCAL_PREP1_FOR_ACAVO
C> @brief      Prepares occs. for 2 el. exch. integrals.
C>
C> @author     Aaron West and Klaus Ruedenberg
C>             -May 19, 2013
C>
C> @details    This routine prepares occupations for 2 electron
C>             2 electron exchange integral run.
C>             Outputs are OCCIMO and VORBIMO.
C>             These arrays are reordered into VVOS order.
C>             Routine is used in external nos runs.
C>
C> @param L0       is the length of the MO variational space.
C> @param L1       is the length of the AO coefficients.
C> @param L2       is the triangular length of L1.
C> @param L3       is the square of L1.
C> @param L0MBS    is the dimension of the minimal basis set number of
C>                 orbitals.  L0MBS is derived from NCORTOT + LOCAL_NUMVAL.
C> @param NVALORBS is the total number of valence orbitals.
C> @param NVALTRI  is the triangular size of NVALORBS.
C> @param NAT      is the number of atoms.
C> @param IWRK     is an integer scratch array with size L1.
C> @param IWRK2    is an integer scratch array with size L1x8.
C> @param DEN      is scrach to hold a density matrix.
C> @param IPOSMBS  denotes the integer array that holds the starting
C>                 position for the 1st VALENCE MBS AO on a given atom.
C>                 These are in atomic order from the input
C>                 as usual.
C>                 I emphasize the CORE+VALENCE part.
C> @param ILENMBS  gives the length of the VALENCE MBS number of orbitals
C>                 on each atom.  I emphasize the VALENCE + MBS part.
C> @param IATSVD   is an array from the SVD run itself
C>                 that contains atom-orbital correspondences.
C> @param SVMBS    holds the SV product of the MBS orbitals
C>                 from the VVOS but in the current
C>                 basis set.
C> @param VEC3     is a scratch array with size of L3.
C> @param VEC4     is a scratch array with size of L3.
C> @param S        is a scratch array of length L2.
C> @param EIG      is a scratch array of length L1.
C> @param VORBIMO  will hold reordered SVD orbitals
C>                 in the order of the VVOS.
C> @param OCCIMO   will hold reorder SVD densities
C>                 in the order of the VVOS.
C> @param MASWRK   indicates the master process.
C>
      SUBROUTINE LOCAL_PREP1_FOR_ACAVO(
     *           L0,L1,L2,L3,L0MBS,NVALORBS,NVALTRI,NAT,
     *           IWRK,IWRK2,DEN,
     *           IPOSMBS,ILENMBS,IATSVD,
     *           SVMBS,VEC3,VEC4,S,EIG,
     *           VORBIMO,OCCIMO,
     *           MASWRK)
      IMPLICIT NONE
C
      LOGICAL MASWRK
      INTEGER L0,L1,L2,L3,L0MBS,NVALORBS,NVALTRI,NAT
      INTEGER IWRK(L1),IWRK2(L1*8),
     *        IPOSMBS(NAT+1),ILENMBS(NAT),IATSVD(L0)
      DOUBLE PRECISION ::
     *       OCCIMO(L0MBS),DEN(NVALTRI),
     *       SVMBS(L1,L0MBS),VORBIMO(L1,L1),
     *       VEC3(L1,L1),VEC4(L1,L1),S(L2),EIG(L1)
      INTEGER IDUM,L0LIM,I,II,ICOUNT
      INTEGER IST,ILAST,ICOR,NERR,IERR,J,III,JJJ,ITMP,IVAL,
     *        NVVOS_NUMCOR
C------------------------------------------------------
      INTEGER IDAF,IODA,IP,IPK,IR,IS,IW,NAV
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C-----------------------------------------------------------------------
C
C     READ IN THE NEEDED DAF FILES.
C     NOTE:  NEVER BELIEVE SVMBS IS STILL SVMBS...
      CALL DAREAD(IDAF,IODA,DEN,NVALTRI,536,0) ! special orth. orb. density
      CALL DAREAD(IDAF,IODA,SVMBS,L1*L0MBS,533,0)
      CALL DAREAD(IDAF,IODA,VORBIMO,L3,522,0) ! ,522, nonorthog. orbitals
C
C     USE OF OVLSEL REQUIRES CERTAIN DIMENSIONS.
C     WE MUST BE STRICT...
      CALL VCLR(VEC4,1,L3)
      CALL DCOPY(L1*L0MBS,SVMBS,1,VEC4,1)
C
C     FORM THE ORBITAL OVERLAP.
C     AND
C     OBTAIN THE REORDERING ARRAY.
      CALL VICLR(IWRK2,1,L1)
C     MAKE S A SYM. UNIT MATRIX.
      CALL VCLR(S,1,L2)
      DO I=1,L1
        II=(I*I+I)/2
        S(II)=1.0D+00
      ENDDO
      CALL VCLR(VEC3,1,L3)
      IDUM=0
      L0LIM=L0MBS
      CALL OVLSEL(VORBIMO,EIG,VEC4,S,
     *            VEC3,IWRK2,IWRK,IWRK2,
     *            IDUM,IDUM,L0,L1,L2,.FALSE.,L0LIM)
C
C     RELOAD WITHOUT THE TRASH ORBITAL PHASES.
      CALL DAREAD(IDAF,IODA,VORBIMO,L3,522,0)
C
C     REORDER THE ORBITALS.
C     NOTE:  SCF FREE-ATOM LABELS WILL LIE IN THE 'CORE'
C            WAVEFUNCTION MOS.
      CALL VICLR(IWRK,1,L1)
      CALL ICOPY(L0LIM,IWRK2,1,IWRK,1)
      CALL REORDR(VORBIMO,IWRK,L0LIM,L1)
      CALL ICOPY(L0LIM,IWRK2,1,IWRK,1)
C
C-----------------------------------------
C     WELCOME TO THE GATHERING OF CHAOS.
C-----------------------------------------
C
C     --INITIALIZE THE OCCIMO ROUTINE TO ALL -1
C     --CHECK THAT SVD AND VVOS ATOM ASSIGNMENTS AGREE
C       AFTER OVLSEL REORDERING.
C     --PUT THE OCCUPATIONS IN THE ORDER OF VVOS.
C     NOTE:  ITMP ALWAYS LAGS BEHIND HERE.
C     NOTE:  NEVER CHANGE IWRK2.
      DO I=1,L0MBS
        OCCIMO(I)=-1.0D+00
      ENDDO
      NERR=0
      IERR=0
      ICOUNT=0
      ICOR=NVVOS_NUMCOR(0,0)
ccccccc
      DO III=1,NAT
        IST=IPOSMBS(III)
        ILAST= -1+IST+ILENMBS(III)
        DO J=IST,ILAST
          ITMP=IWRK2(J)
          IF(ITMP.LE.ICOR) IERR=IERR+1
          JJJ=IATSVD(ITMP)
          IF(JJJ.NE.III) IERR=IERR+1
ccccccccccc
ccccccccccc itmp contains cores.  convert itmp to val only.
ccccccccccc
          IVAL=ITMP-ICOR
          II=(IVAL*IVAL+IVAL)/2
          OCCIMO(J)=DEN(II)
          ICOUNT=ICOUNT+1
ccccccccccc
ccccccccccc
ccccccccccc
        ENDDO
      ENDDO
ccccccc
      IF(IERR.GT.0) THEN
        NERR=NERR+1
        IF(MASWRK) WRITE(IW,9000)
      ENDIF
      IF(ICOUNT.NE.NVALORBS) THEN
        NERR=NERR+1
        IF(MASWRK) WRITE(IW,9001)
      ENDIF
C
C     PERFORM ANY ERROR OUTS.
      IF(NERR.GT.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9000 FORMAT(/1X,'LOCAL_PREP1_FOR_ACAVO ERROR:',
     *       /1X,'IWRK ARRAY HAS ORBITAL NUMBERS',
     *        1X,'THAT DO NOT MAKE SENSE...')
 9001 FORMAT(/1X,'LOCAL_PREP1_FOR_ACAVO ERROR:',
     *       /1X,'ICOUNT DOES NOT EQUAL NVALORBS.')
      END
C*MODULE LOCAL   *DECK LOCAL_PREP2_FOR_ACAVO
C> @brief      Prepares several items for 2 el. exch. integrals.
C>
C> @author     Aaron West and Klaus Ruedenberg
C>             -May 19, 2013
C>
C> @details    Prepares several items for 2 el. exch. integrals.
C>             Main outputs are WGTORB and first vector in VEC.
C>
C> @param IPOSMBS  denotes the integer array that holds the starting
C>                 position for the 1st VALENCE MBS AO on a given atom.
C>                 These are in atomic order from the input
C>                 as usual.
C> @param OCCIMO   contains the occupations on entry in VVOS order.
C> @param ILOOP    counts up the valence orbital of a given atom.
C> @param L1       is the length of the AO coefficients.
C> @param L0MBS    is the total number of MBS orbitals.
C> @param NAT      is the number of atoms.
C> @param IATM1    is the current atom in the current do loop.
C> @param L2       is the triangular length of L1.
C> @param IBAS1    equals the starting index of the first AO
C>                 on current atom IATM1.
C> @param ILTH     is the length of the AO overlap matrix on IATM1.
C> @param VEC66    holds S**(-1) on the current atom IATM1.
C> @param SVMBS    holds the SV product for the VVOS orbitals.
C> @param IWRK     is scratch array of length L1.
C> @param S2       is a scratch array of length L2.
C> @param S        holds AO overlap matrix for all AOs on entry.
C> @param EIG      is a scratch array of length L1.
C> @param VEC3     is the array that accumulate valence orbitals.
C> @param MASWRK   indicates the master process.
C> @param IW       indicates write out to the log file.
      SUBROUTINE LOCAL_PREP2_FOR_ACAVO(
     *           IPOSMBS,OCCIMO,ILOOP,
     *           L1,L0MBS,NAT,IATM1,L2,IBAS1,ILTH,
     *           VEC66,SVMBS,IWRK,S2,S,
     *           EIG,VEC3,
     *           MASWRK,IW)
      IMPLICIT NONE
C
      LOGICAL MASWRK
      INTEGER IW,ILOOP,L1,L0MBS,NAT,IATM1,L2,IBAS1,ILTH
      INTEGER IWRK(L1),IPOSMBS(NAT+1)
      DOUBLE PRECISION ::
     *       OCCIMO(L0MBS),S2(L2),S(L2),
     *       VEC3(L1,L1),VEC66(L1,L1),SVMBS(L1,L0MBS),
     *       EIG(L1)
C
      INTEGER IORB
      DOUBLE PRECISION :: TMP
C
C     FIND THE POSITION OF THE DESIRED VALENCE ORBITAL.
      IORB=IPOSMBS(IATM1)
      IORB=IORB+(ILOOP-1)
C
C     OBTAIN THE ORBITAL TO BE USED IN THE 2 EL. EXCHANGE INTEGRALS.
C     --PERFORM PROJECTION ONTO IATM1 BASIS FXNS
C     --NORMALIZE VECTOR.
C     --COPY OVER THE DESIRED ORBITAL TO THE FIRST COL.
      IF(ILOOP.EQ.1) THEN
        CALL VCLR(VEC3,1,L1*L1)
        CALL VCLR(EIG,1,L1)
      ENDIF
      CALL MRARBR(VEC66,L1,ILTH,ILTH,
     *            SVMBS(IBAS1,IORB),L1,1,
     *            VEC3(IBAS1,ILOOP),L1)
      CALL TFTRI(S2,S,VEC3(1,ILOOP),IWRK,1,L1,L1)
      TMP=S2(1)
      TMP=1.0D+00/SQRT(TMP)
      CALL DSCAL(L1,TMP,VEC3(1,ILOOP),1)
CKEEP
CKEEP
CKEEPC     USE THE REORDERED NONORTHOGONAL QUASI-ATOMIC ORBITALS.
CKEEP      CALL DCOPY(L1,VORBIMO(1,IORB),1,VEC3(1,ILOOP),1)
CKEEP
CKEEP
C
C     SET THE OCCUPATION FOR THE DESIRED VALENCE ORBITAL.
C     NOTE:
C     THE DENSITY ON FILE 526 IS NOT IN THE DESIRED ORDER...
C     OCCIMO IS ALREADY REARRANGED TO DEAL WITH THIS SITUATION.
      EIG(ILOOP)=OCCIMO(IORB)
      IF(EIG(ILOOP).LT.0.0D+00) THEN
        IF(MASWRK) WRITE(IW,9010)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
CKEEPC
CKEEPC     NEED TO FORM AN AVERAGE OVER THE S,P,D,ETC. ORBITALS.
CKEEPC     RIGHT NOW, LOCAL_NUMVAL ONLY EVALUATES FOR S,P,D.
CKEEP      WGTORB2=1.0D+00
CKEEP      IF(NLOOP.EQ.1) THEN
CKEEP        WGTORB2=1.0D+00
CKEEP      ELSEIF(NLOOP.EQ.4) THEN
CKEEP        IF(ILOOP.GE.2) WGTORB2=3.0D+00 ! set up for 3 p orbitals.
CKEEP      ELSEIF(NLOOP.EQ.6) THEN
CKEEP        IF(ILOOP.GE.2) WGTORB2=5.0D+00 ! set up for 5 d orbitals.
CKEEP      ELSE
CKEEP        IF(MASWRK) WRITE(IW,9050)
CKEEP        CALL FLSHBF(IW)
CKEEP        CALL ABRT
CKEEP        STOP
CKEEP      ENDIF
CKEEP      EIG(ILOOP)=EIG(ILOOP)/WGTORB2
C
      RETURN
 9010 FORMAT(/1X,'LOCAL_PREP2_FOR_ACAVO ERROR:',
     *       /1X,'OCCDEN IS LESS THAN ZERO.',
     *       /1X,'ATOMIC INDEXING INSIDE OF',
     *        1X,'LOCAL_PREP1_FOR_ACAVO HAS BROKEN DOWN.')
CKEEP 9050 FORMAT(/1X,'LOCAL_PREP2_FOR_ACAVO ERROR:',
CKEEP     *       /1X,'THE AVERAGING PROCEDURE FOR THE 2 ELECTRON',
CKEEP     *        1X,'INTEGRALS HAS BROKEN DOWN.',
CKEEP     *       /1X,'CHECK FOR NEW RANGE ADDITION TO LOCAL_NUMVAL',
CKEEP     *        1X,' INTEGER ROUTINE.',
CKEEP     *       /1X,'ALSO, NOTE THAT IF YOU DECIDE SOMETHING LIKE',
CKEEP     *        1X,'Be ATOM CAN HAVE S AND P OCCUPIED,',
CKEEP     *       /1X,'THEN YOU NEED TO CREATE A NEW TYPE',
CKEEP     *        1X,'OUT OF NUMVAL FUNCTION',
CKEEP     *       /1X,'INSTEAD OF JUST ADDING NEW NUMBERS ABOVE.')
      END
C*MODULE LOCAL   *DECK LOCAL_GRAB_BASIS_FXNS_ON_ATOM
C> @brief      Grabs out AO overlaps on a given atom.
C>
C> @author     Aaron West
C>             -May 19, 2013
C>
C> @details    Grabs out basis functions on a given atom.
C>             AO overlaps on a given atom are grabbed out of
C>             the general AO overlap matrix and placed
C>             starting at index 1 in a symmetric matrix.
C>
C> @param LIMLOW array contains the lower basis function on an atom.
C> @param LIMSUP array contains the upper basis function on an atom.
C> @param IATM1  is the current atom.
C> @param NAT    is the number of atoms.
C> @param L2     is the triangular length of the number of
C>               basis functions, which is typically L1=NUM.
C> @param S2     S2 holds the AO overlaps for IATM1 on exit.
C> @param S      holds the AO overlap matrix for all atoms on entry.
C> @param IBAS1  equals the starting index of the first AO
C>               on current atom IATM1.
C> @param IBAS2  equals the ending index of the last AO
C>               on current atom IATM1.
C> @param ILTH   equals the total number of basis functions
C>               on current atom IATM1.
      SUBROUTINE LOCAL_GRAB_BASIS_FXNS_ON_ATOM(
     *           LIMLOW,LIMSUP,IATM1,NAT,L2,
     *           S2,S,
     *           IBAS1,IBAS2,ILTH)
      IMPLICIT NONE
      INTEGER IATM1,NAT,L2
      INTEGER LIMLOW(NAT),LIMSUP(NAT)
      DOUBLE PRECISION :: S(L2),S2(L2)
C
      INTEGER IBAS1,IBAS2,ILTH,I,J,IJ,IJ2
C
      IBAS1=LIMLOW(IATM1)
      IBAS2=LIMSUP(IATM1)
      ILTH=IBAS2-IBAS1+1
C
      CALL VCLR(S2,1,L2)
      IJ2=1
      DO I=IBAS1,IBAS2
        DO J=IBAS1,I
          IJ=(I*I-I)/2 + J
          S2(IJ2)=S(IJ)
          IJ2=IJ2+1
        ENDDO
      ENDDO
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_WSO_PREP
C> @brief      Forms relative weights for weighted sym. orthog.
C> 
C> @author     Aaron West
C>             -May 24, 2013
C> 
C> @details    This routine forms relative weights
C>             for weighted symmetric orthogonalization.
C>             It scales the true weights from 1 to 100.
C>             This scaling preserves the difference in weightings
C>             and avoids issues with orbital orthonormality.
C> 
C> @param WGT      array contains the true weights on entry.
C>                 On exit, this array contains the scaled weights.
C> @param ILTH     is the number of weights.
C> @param EIG      is a scratch array for debugging of length L1.
C>                 EIG does get destroyed if DEBUG is true.
C> @param WRK      is a scratch work array.
C>                 In DEBUG mode, we CANNOT use EIG to sort
C>                 with the ida_max function.
C> @param ATWGT    is a logical that chooses a different relative
C>                 weight.  It is appropriate when this call
C>                 is placed in a loop over atoms and creates
C>                 comparative weights between atoms.
C>                 The weight range for this option is 0 to 1
C>                 rather than 1 to 100.
C> @param DEBUG    is a logical for turning on some extra print off.
C> @param MASWRK   indicates the master process.
C> @param SOME   is true for master process with nprint not equal -5.
C> @param IW       indicates write out to the log file.
      SUBROUTINE LOCAL_WSO_PREP(
     *           WGT,ILTH,EIG,WRK,
     *           ATWGT,DEBUG,MASWRK,SOME,IW)
      IMPLICIT NONE
      LOGICAL MASWRK,ATWGT,DEBUG,SOME
C     NEXT LINE IS FOR THE DEBUG ONLY.
      INTEGER ITMP,IMIN,IDAMAX,IXAMAX
C
      INTEGER ILTH,I,IW
      DOUBLE PRECISION :: WGT(ILTH),EIG(ILTH),WRK(ILTH)
      DOUBLE PRECISION :: TMP,WMIN,WMAX,RATIO,RATIOSV,
     *                    ONE,WSPREAD,POWER,BBB
      PARAMETER (ONE=1.0D+00)
      PARAMETER (WSPREAD=99.0D+00,POWER=3.00D+00,BBB=70.0D+00)
C
C     SCALE THE ALL THE WEIGHTS BY SMALLEST WEIGHT.
C     NOTE:  I COULD EASILY SEE A BUG HERE FOR TRUE ZEROS.
C            I.E. INPUT ERROR...
      TMP=ABS(WGT(1))
      WMIN=TMP
      WMAX=TMP
      IF(DEBUG) THEN
        IMIN=1
        CALL VCLR(EIG,1,ILTH)
      ENDIF
      DO I=1,ILTH
        TMP=ABS(WGT(I))
        IF(DEBUG.AND.TMP.LT.WMIN) IMIN=I
        IF(TMP.LT.WMIN) WMIN=TMP
        IF(TMP.GT.WMAX) WMAX=TMP
      ENDDO
C
C     FIX FOR NUMERICAL ISSUE IN DIVISOR BELOW.
C     NOTE:  WEIGHTS ARE A SCALAR IN THIS CASE...NOTHING TO DIAG.
      TMP=WMAX-WMIN
      IF(TMP.LT.1.0D-10.AND.ILTH.GT.1) THEN
        DO I=1,ILTH
          WGT(I)=1.0D+00
        ENDDO
        GO TO 777 ! avoid the division by zero right below here.
      ENDIF
C----------------------------------------------------------------
CORIG      RATIO=1.0D+00
CORIG      DO I=1,ILTH
CORIG        IF(ILTH.GT.1) RATIO=(WGT(I)-WMIN)/(WMAX-WMIN)
CORIG        RATIOSV=RATIO
CORIG        IF(DEBUG) EIG(I)=RATIO
CORIG        RATIO=RATIO**POWER
CORIG        RATIO=(ONE+BBB)*RATIO/(ONE+BBB*RATIO)
CORIG        WGT(I)=ONE + WSPREAD*RATIO
CORIG        IF(ATWGT) WGT(I)=RATIOSV
CORIG      ENDDO
      RATIO=1.0D+00
      DO I=1,ILTH
        RATIO=WGT(I)/WMAX
        RATIOSV=RATIO
        IF(DEBUG) EIG(I)=RATIO
        RATIO=RATIO**POWER
        RATIO=(ONE+BBB)*RATIO/(ONE+BBB*RATIO)
        WGT(I)=ONE + WSPREAD*RATIO
        IF(ATWGT) WGT(I)=RATIOSV
      ENDDO
C
C----------------------------------------------------------------
  777 CONTINUE
      IF(DEBUG.AND.MASWRK) THEN
        CALL DCOPY(ILTH,WGT,1,WRK,1)
        DO I=1,ILTH-1
          ITMP=IDAMAX(ILTH,WRK,1)
          WRITE(IW,*) "wso i,wgts = ",I,EIG(ITMP),WGT(ITMP)
          WRK(ITMP)=0.0D+00
        ENDDO
        WRITE(IW,*) "wso i,wgts = ",I,EIG(IMIN),WGT(IMIN)
      ENDIF
C
C     PRINT OFF THE NEW RELATIVE WEIGHTS.
      IF(SOME) THEN
        WRITE(IW,9003)
        DO I=1,ILTH
          WRITE(IW,9004) I,WGT(I)
        ENDDO
      ENDIF
C
      RETURN
 9003 FORMAT(//1X,'LOCAL_WSO_PREP OBTAINS THE RELATIVE WEIGHTS.')
 9004 FORMAT(1X,'ORBITAL',I5,' HAS WSO WEIGHT = ',F12.7)
      END
