C
C*MODULE LOCAL   *DECK LOCAL_LMOSVD
c> @brief      Local_lmosvd calls local_ppasvd routines.
c>
c> @author     Aaron West and Klaus Ruedenberg
c>             -November 4, 2012
c> @details    Local_lmosvd grabs memory and calls svd routines.
c>             For VVOS, IORBF1 can only be DAF file 15 right now.
c>             Otherwise, we need to re-visit some file definitions.
c>
c> @date December 13, 2012-Aaron West
c> -Added ORMAS svd localization.
c>
c> @date December 20, 2012-Aaron West
c> -Stripped out the use of LVNACT.   We do not need to do all
c>  confusing sorting in LOCAL_PPASVDCORE and LOCAL_PPASVD.
c>  We can just grab out the orbital transformation and use its
c>  block-diagonal form to get the LMOs at the end in one matvec.
c>  We still keep core and valence manipulations separate.
C>
C> @date January 16, 2013-Aaron West
C> -Added VVOS option.
C>
C> @date January 30, 2013-Aaron West
C> -Added ISVDOP to ORNTMO common block.
C> This run gives special option for SVD runs.
C>
C> @date February 23, 2013-Aaron West
C> -Enable MO overlaps with MOs from VVOS i.e. ISVDOP=10
C> This run gives special option for SVD runs.
C>
C> @date March 13, 2013-Aaron West
C> -Allowed for RHF wave functions.
C>
C> @date April 01, 2013-Aaron West
C> -Adapt for extloc runs.
C>
C> @date April 01, 2013-Aaron West
C> -Adapt for spherical harmonics.
C>
C> @date May 17, 2013-Aaron West
C> -For extloc=atmnos, force out the valence density matrix.
C>  Some new dimensioning is required.
C>  I forced the extloc option through the routine.
C>  Results were re-checked for this difficult option.
C>
C> @date May 18, 2013-Aaron West
C> -For MCSCF-type runs and externalizing runs,
C>  the MCSCF SVD orbitals are now requested.
C>  Right now, MCSCF+extloc=atmnos result in
C>  ER localized orbitals and ext. nos.
C>  that preserve the waveFxN invariance.
C>  However, MCSCF+extloc=atmnos runs mix
C>  all orbitals in the MBS valence for the SVD orbitals.
C>
C> @date July 12, 2013-Aaron West
C> -Small correction for EXTLOC runs with MCSCF.
C>  Density matrix is now handled with care.
C>  This fix does not affect:
C>  non-EXTLOC runs or Hartree-Fock EXTLOC runs.
C>
C> @date August 12, 2013-Aaron West
C> -Create new degeneracy sorting routine for external orbitals.
C>
C> @param IORBF1 indicates daf dict file with starting orbitals
C>               from which the localized orbitals are formed.
C> @param SCFTYP_TRUTH should be fed in as the true SCFTYP.
      SUBROUTINE LOCAL_LMOSVD(IORBF1,SCFTYP_TRUTH)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C
C     VARS
C     MASWRK LINE PLACED BELOW TO MATCH...
      LOGICAL KEEPER,KEEPER_ISVMOR,COMBO,SWITCH_ORBS,SVDEXTOPT,
     *        SVDAOS,SVD_INVAR,SVD_AOSCF
      DOUBLE PRECISION :: X
      DOUBLE PRECISION :: RMC,RHF,ROHF,RNONE
      DOUBLE PRECISION :: SCFTYP_TRUTH
      INTEGER NGOTMX,LAST,LOADFM,NDAWN1,
     *        LEIG1,LIWRK,LS,LS2,LSAOMO,LSV,LSVMBS,LUVEC,LVOLD,LVSAV,
     *        LEIGSAV,LEIGTMP,LVTVECSAV,LIGRPLAB,LIATLAB,
     *        LIORDBIG,LIORDBIG2,
     *        LIPOSMBS,LILENMBS,LIPOSCOR,LILENCOR,
     *        LVTMP,LVTVEC,LWRKSVD,LWSPHER,
     *        IEXTSPACE,LIATEXT,NATEXT
      INTEGER ISIZE_FCCWFN
      INTEGER NERR,I,ITMP,IORBF1,ISIZSVD,ISIZSVD2,
     *        L0,L0MBS,IMBS,L1,L2,L3,NCORTOT,NACT
      INTEGER NSKIP,NSKIP2,NSKIP_SING,
     *        NVIR2,NCOR_GET,NACT_GET,NACTSV,NCORSV,
     *        NACT_EXTLOC_SAV,NACTSV_EXTLOC_SAV
      INTEGER ISWMBS,IDENFIL,IDENSIZ
      INTEGER LOCAL_NUMVAL,NVVOS_NUMCOR
      INTEGER NACTBS,NAOTOT,NAOCART,NAOSPH
C-----------------------------------------------------------------------
C     NEW CODING STANDARDS VARS
C
      DOUBLE PRECISION :: C
      DOUBLE PRECISION :: ZAN
      INTEGER ICH,NQMT,NUM,MUL,NA,NAT,NB,NE,IAN
C
      INTEGER LIMLOW,LIMSUP,LIATMSTA,LIATMSTA2
C
      DOUBLE PRECISION :: QMTTOL
      INTEGER ISPHER
C
      INTEGER IW,IDAF,IODA,IP,IPK,IR,IS,NAV
C
      LOGICAL FDIRCT,QCORR
      DOUBLE PRECISION ::
     *       C0SQ
      INTEGER LMSTA_SAV,NSPACE_SAV,NSPACE,NSPACE2,
     *        MSTA,MNUM,MINI,MAXI,IAMI,IAMA,IBMI,IBMA,
     *        IDIMFCC,LBST,NREF0
C
      LOGICAL CANONC,FCORE,FORS,EKT,LINSER
      DOUBLE PRECISION ::
     *       FINALCI,METHOD,CISTEP,ORMAS,ACURCY,ENGTOL,DAMP
      INTEGER MICIT,NWRDMC,NORBMC,NOROT,MOFRZ,
     *        NPFLG,NOFO,MCFMO,IDIABAT
C
      LOGICAL ORIENT,ORIKIN,ORMFUL
      INTEGER NATMOR,ISVMOR,ISVDOP,L0DEP0
      DOUBLE PRECISION :: EXTLOC,EREFATM,COUP_NT_VVO
C
      DOUBLE PRECISION ::
     *       RUNTYP,EXETYP,CHECK
      INTEGER NEVALS,NGLEVL,NHLEVL
C
      LOGICAL SOME
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION :: ETOLLZ
      INTEGER ILOCAL,IAHARD
C
      INTEGER IVVOS,NVVOS
      DOUBLE PRECISION :: BNDDEN
C
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C-----------------------------------------------------------------------
      INTEGER MXAO,MXATM,MXNORO
      PARAMETER (MXAO=8192, MXATM=2000, MXNORO=250)
C-----------------------------------------------------------------------
      COMMON /ATLIM / LIMLOW(MXATM),LIMSUP(MXATM)
      COMMON /BASSPH/ QMTTOL,ISPHER
C                            SPECIAL NOTE:
C                            IF CHANGE SIZE OF MSTA ARRAY HERE,
C                            ALSO CHANGE ISIZE_FCCWFN VARIABLE BELOW
C                            IN A SINGLE PLACE.
C
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIMFCC(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWRDMC,NORBMC,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /ORNTMO/ EXTLOC,EREFATM,COUP_NT_VVO(MXATM),
     *                NATMOR(MXAO),ISVMOR(MXATM),ISVDOP,L0DEP0,
     *                ORIENT,ORIKIN,ORMFUL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /VVOPAR/ IVVOS,NVVOS,BNDDEN
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C-----------------------------------------------------------------------
C
C     DATA STUFF
      DATA CHECK/8HCHECK   /
      DATA ORMAS/8HORMAS   /
      DATA RHF/8HRHF     /
      DATA RMC/8HMCSCF   /
      DATA ROHF/8HROHF    /
      DATA RNONE/8HNONE    /
C
C     DEFINE PRINT STUFF
      SOME = NPRINT.NE.-5 .AND. MASWRK
C
C     PRINT STUFF
      IF(SOME) WRITE(IW,9000)
C
C
C     MEMORY FOR ATOMIC-LIKE ORBITALS.
C
C     SET UP SOME DIMENSIONS
      L0 = NQMT
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
      ISIZE_FCCWFN=51
      IMBS=0
      ISWMBS=1
      DO I=1,NAT
        IMBS=IMBS+LOCAL_NUMVAL(I,ISWMBS)
      ENDDO
      L0MBS=IMBS+NVVOS_NUMCOR(0,0)
C
C     ALWAYS INITIALIZE NSPACE2 HERE REGARDLESS OF OPTIONS.
      NSPACE2=1
C
      IF(SCFTYP.EQ.RMC) THEN
        CALL LOCAL_SVDVVOS_RMC_SETUP1(NCOR_GET,NACT_GET)
        NSPACE2=1
        IF(CISTEP.EQ.ORMAS) NSPACE2=NSPACE
      ELSEIF(SCFTYP.EQ.RHF.OR.SCFTYP.EQ.ROHF) THEN
        IF(EXTLOC.NE.RNONE) NSPACE=1
        NCOR_GET=NVVOS_NUMCOR(0,0)
        NACT_GET=L0-NCOR_GET
      ELSE
        IF(MASWRK) WRITE(IW,9049)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     NOTE:
C     SOME OF THESE GET PERMANENTLY CHANGED
C          FOR VVOS IN ROUTINES BELOW...
C     SO, BECAREFUL.
      NCORSV=NCOR_GET
      NCORTOT=NCOR_GET
      NACT=NACT_GET
      NACTSV=NACT_GET
C
C
C----------------------------------------------------
C----------------------------------------------------
C     MAKE SOME ERROR OUTS
      NERR=0
      COMBO=CISTEP.EQ.ORMAS.OR.SCFTYP.EQ.RHF.OR.SCFTYP.EQ.ROHF
      IF(.NOT.COMBO.AND.IVVOS.NE.0) THEN
        IF(MASWRK) WRITE(IW,9050)
        NERR=NERR+1
      ENDIF
C     NOTE:  THIS ERROR IS AN 'ABSOLUTIST'S' ERROR.
      ITMP=ISIZE_FCCWFN
      IF(IVVOS.NE.0) ITMP=ISIZE_FCCWFN-2
      IF(NSPACE.GT.ITMP) THEN
        IF(MASWRK) WRITE(IW,9051)
        NERR=NERR+1
      ENDIF
      IF(IVVOS.NE.0.AND.IORBF1.NE.15) THEN
        IF(MASWRK) WRITE(IW,9052)
        NERR=NERR+1
      ENDIF
      IF(EXTLOC.NE.RNONE.AND.IVVOS.EQ.0) THEN
        IF(MASWRK) WRITE(IW,9053)
        NERR=NERR+1
      ENDIF
      IF(EXTLOC.NE.RNONE.AND.ILOCAL.EQ.4) THEN
        IF(MASWRK) WRITE(IW,9054)
        NERR=NERR+1
      ENDIF
      IF(SCFTYP.EQ.RHF.OR.SCFTYP.EQ.ROHF) THEN
        IF(IVVOS.EQ.0) THEN
          IF(MASWRK) WRITE(IW,9055)
          NERR=NERR+1
        ENDIF
      ENDIF
      IF(NERR.GT.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C----------------------------------------------------
C----------------------------------------------------
C
C--------------------------------------------------------------------
C--------------------------------------------------------------------
C--------------------------------------------------------------------
C--------------------------------------------------------------------
C     SETUP ANY VARIABLES THAT USE ISDVOP.
C     NOTE: THE DEFAULT COMES FROM LMOINP ROUTINE.
C--------------------------------------------------------------------
C--------------------------------------------------------------------
C--------------------------------------------------------------------
C--------------------------------------------------------------------
      SVDEXTOPT=.FALSE.
      SVDAOS=.FALSE.
      SVD_INVAR=.FALSE.
      SVD_AOSCF=.FALSE.
      IF(SOME) WRITE(IW,9070)
C
      IF(SCFTYP.EQ.RMC) THEN
        IF(ISVDOP.EQ.0) THEN
C         RUN A 'REGULAR' SVD.
          IF(SOME) WRITE(IW,9071)
        ELSEIF(ISVDOP.EQ.4) THEN
          SVD_INVAR=.TRUE.
          IF(SOME) WRITE(IW,9077)
        ELSEIF(ISVDOP.EQ.10) THEN
C         USE THE TRUE AOS THAT MIKE HAS STORED UP FOR VVOS.
          SVD_AOSCF=.TRUE.
          IF(SOME) WRITE(IW,9080)
        ELSE
          IF(MASWRK) WRITE(IW,9090)
          CALL FLSHBF(IW)
          CALL ABRT
        ENDIF
      ELSEIF(SCFTYP.EQ.RHF.AND.ISVDOP.EQ.0) THEN
        SVD_AOSCF=.TRUE.
        IF(SOME) WRITE(IW,9081)
CGARBRHF      ELSEIF(SCFTYP.EQ.RHF.AND.ISVDOP.EQ.1) THEN
CGARBRHFC       KEEP THE ORIGINAL CLOSED-SHELL AND VIRTUALS.
CGARBRHF        SVD_AOSCF=.TRUE.
CGARBRHF        IF(SOME) WRITE(IW,9081)
      ELSEIF(SCFTYP.EQ.ROHF.AND.ISVDOP.EQ.0) THEN
        SVD_AOSCF=.TRUE.
        IF(SOME) WRITE(IW,9081)
      ELSE
        IF(MASWRK) WRITE(IW,9090)
        CALL FLSHBF(IW)
        CALL ABRT
      ENDIF
C
C---------------------------------------------------
C     PRINT ANY OTHER POSSIBLE OPTIONS HERE.
C---------------------------------------------------
      IF(SVDAOS) THEN
        IF(SOME) WRITE(IW,9073)
      ENDIF
      CALL FLSHBF(IW)
C---------------------------------------------------
C     END OF PRINT ANY OTHER POSSIBLE OPTIONS HERE.
C---------------------------------------------------
C
C--------------------------------------------------------------------
C--------------------------------------------------------------------
C     END OF SETUP ANY VARIABLES THAT USE ISDVOP.
C--------------------------------------------------------------------
C--------------------------------------------------------------------




C
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C     SVD-VVOS OVERHAUL:  STEP 1
C     RESET DIMENSIONS
C     NOTE:  THIS IS NOT A TRUE RE-DIMENSIONING.
C            IT IS JUST MORE USE OF A COMMON BLOCK, WHICH MUST BE DONE.
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C
C     SVD-VVOS LENGTHS OF BLOCKS
C     ACTUAL CORE BLOCK:  NCORTOT
C     FILLED CORE BLOCK:  NSKIP
C       NEW EMPTY BLOCK:  NSKIP2
C     OLD ACTIVE BLOCK:   NACTSV
C     NEW ACTIVE BLOCK:   NACT-NACTSV
C     NEW ACTIVE TOTAL:   NACTSV+NSKIP+NSKIP2
C
      NSKIP=0
      NSKIP2=0
      IF(IVVOS.NE.0) THEN
        CALL LOCAL_SVDVVOS_REDIM_STEP1(
     *       SCFTYP,ISVDOP,
     *       NAT,NCORSV,NACTSV,L0,
     *       NSPACE,NSPACE_SAV,
     *       NCORTOT,NSKIP,NACT,NSKIP2,NVIR2,
     *       NA,NB,
     *       MASWRK,IW)
        NSPACE2=NSPACE
        IF(SOME) WRITE(IW,9100) NCORTOT,NSKIP,NACTSV,NSKIP2,NVIR2
      ENDIF
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C     END OF SVD-VVOS OVERHAUL:  STEP 1
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C
C
C------------------------------------------------------
C------------------------------------------------------
C------------------------------------------------------
C     CALCULATE NACTBS.
      NAOTOT=0
      DO I=1,NAT
        CALL LOCAL_COUNTAOS(I,NAOCART,NAOSPH)
        NAOTOT=NAOTOT+NAOSPH
      ENDDO
      IF(NACT.GT.L0MBS-NCORTOT) THEN
        NACTBS=NAOTOT-NCORTOT
      ELSE
        NACTBS=NACT
      ENDIF
C------------------------------------------------------
C------------------------------------------------------
C------------------------------------------------------
C
C
C     BEFOREHAND, DETERMINE SIZES OF ANY EXTRA WORK ARRAYS
C     NOTE:  EXPLICITLY DETERMINE LARGEST WORKSPACE
C            AND
C            FORCE INTO 1 VARIABLE.
      ISIZSVD  = MAX(3*MIN(L1,L0)+MAX(L1,L0),5*MIN(L1,L0))
      ISIZSVD2 = 5*L0
C     NEXT LINE GIVES SVD
      ISIZSVD  = MAX(ISIZSVD,ISIZSVD2)
      ISIZSVD2 = 8*L1
C     NEXT LINE GIVES GLDIAG
      ISIZSVD  = MAX(ISIZSVD,ISIZSVD2)
C     NEXT LINE GIVES A BIT MORE WORKSPACE
      ISIZSVD  = 40*ISIZSVD
C
C
C     GET ALL MEMORY FOR LOCAL_PPASVD.
      CALL GOTFM(NGOTMX)
      CALL VALFM(LOADFM)
      LS = LOADFM + 1
C     A BUNCH OF ORBITAL MEMORY.
      LUVEC = LS + L2
      LEIG1 = LUVEC + L3
      LVTVEC = LEIG1 + L1
      LWRKSVD = LVTVEC + L3
      LSV = LWRKSVD + ISIZSVD
      LVOLD = LSV + L3
      LVTMP = LVOLD + L3
      LVSAV = LVTMP + L3
      LSAOMO = LVSAV + L3
      LS2 = LSAOMO + L3
      LIWRK = LS2 + L2
      LSVMBS = LIWRK + L3
      LIPOSMBS = LSVMBS + L1*L0MBS
C     MORE MEMORY FOR INDEXING.
      LILENMBS  = LIPOSMBS + (NAT+1)
      LIPOSCOR  = LILENMBS + NAT
      LILENCOR  = LIPOSCOR + (NAT+1)
      LIATMSTA2 = LILENCOR + NAT
C     MORE MEMORY FOR ATOM ASSIGNMENTS.
      LIATMSTA = LIATMSTA2  + NSPACE2*NAT
      LEIGSAV = LIATMSTA + NSPACE2*NAT
C     MORE ORBITAL MEMORY FOR CHANGE IN SVD EVALUE SELECTION.
      LEIGTMP   = LEIGSAV  + NACTBS*NAT
      LVTVECSAV = LEIGTMP  + NACTBS*NAT
      LIGRPLAB  = LVTVECSAV + NACT*NACTBS*NAT
      LIATLAB   = LIGRPLAB   + NACTBS*NAT
      LIORDBIG  = LIATLAB + NACTBS*NAT
      LIORDBIG2 = LIORDBIG + NACTBS*NAT
      LMSTA_SAV = LIORDBIG2 + NACTBS*NAT
C     COPY THE MSTA ARRAY FOR VVOS STUFF
      LWSPHER   = LMSTA_SAV + ISIZE_FCCWFN
C     ORBITAL MEMORY FOR SPHERICAL TRANSFORM
      LAST      = LWSPHER   + L3
C---------------
C     INTEGER ARRAY MEMORY FOR VIRTUAL DEGENERACY SORTING.
      NATEXT=5
      LIATEXT=LAST
      LAST=LIATEXT+NAT*NATEXT
C---------------
      NDAWN1 = LAST - LOADFM - 1
      CALL GETFM(NDAWN1)
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C     SVD-VVOS OVERHAUL:  STEP 2
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C
C     INITIALIZE SWITCH_ORBS VARIABLE.
      SWITCH_ORBS=.FALSE.
C
C     MAKE A COPY OF THE ORIGINAL MSTA ARRAY.
C     TEMPORARILY RESET THE MSTA ARRAY.
C     FOREVER RESET IORBF1 ORDERINGS.
C
      IF(IVVOS.NE.0) THEN
        CALL LOCAL_SVDVVOS_REDIM_STEP2(
     *       SCFTYP,ISVDOP,NAT,L0,
     *       ISIZE_FCCWFN,NSPACE,MSTA,X(LMSTA_SAV),
     *       NCORTOT,NSKIP,NSKIP2,MASWRK,SOME,IW)
C       NOTE:  SEE NOTES IN LOCAL_SVDVVOS_MOS
C              ON POSSIBLE IORBF1 OVER-WRITES.
        COMBO=SCFTYP.EQ.RMC.AND.CISTEP.EQ.ORMAS
        COMBO=COMBO.OR.SCFTYP.EQ.ROHF
        IF(COMBO) THEN
          CALL VICLR(X(LIWRK),1,L2)
          CALL LOCAL_SVDVVOS_MOS(
     *         SWITCH_ORBS,X(LIWRK),SCFTYP,IMBS,
     *         L0,NCORSV,NCORTOT,NACTSV,NSKIP,NSKIP2,MASWRK,IW)
          CALL DAREAD(IDAF,IODA,X(LVTMP),L3,15,0)
          CALL REORDR(X(LVTMP),X(LIWRK),L0,L1)
          CALL DAWRIT(IDAF,IODA,X(LVTMP),L3,15,0)
        ENDIF
      ENDIF
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C     END OF SVD-VVOS OVERHAUL:  STEP 2
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C
CKEEPIVVOSC
CKEEPIVVOSC     IF NEEDED, PRINT OUT CANONICAL MCSCF OCCUPIEDS + VVOS
CKEEPIVVOS      IF(IVVOS.NE.0) THEN
CKEEPIVVOS        CALL DAREAD(IDAF,IODA,X(LVTMP),L3,15,0)
CKEEPIVVOS        IF(MASWRK) WRITE(IW,9060)
CKEEPIVVOS        CALL PRSQL(X(LVTMP),L0,L1,L1)
CKEEPIVVOS        GO TO 8999
CKEEPIVVOS      ENDIF
C
C------------------------------------------------------
C------------------------------------------------------
C------------------------------------------------------
C     SETUP THE 'KEEPER' VAR
C     SETUP KEEPER_ISVMOR.
      CALL LOCAL_KEEPER_SETUP(KEEPER,0,L1,X(LIWRK))
      KEEPER_ISVMOR=.FALSE.
      DO I=NCORTOT+1,NCORTOT+NACT
        IF(NATMOR(I).NE.0) KEEPER_ISVMOR=.TRUE.
      ENDDO
      IF(.NOT.KEEPER) THEN
        DO I=1,NAT
          IF(ISVMOR(I).NE.0) KEEPER_ISVMOR=.TRUE.
        ENDDO
      ENDIF
C------------------------------------------------------
C------------------------------------------------------
C------------------------------------------------------
C     SETUP THE SVDEXTOPT VARIABLE.
C     NOTE:  VAR ALREADY INITIALIZED TO FALSE EARLY ON.
      IF(KEEPER) THEN
        IEXTSPACE=0
        DO I=1,NSPACE
          IF(MSTA(I).GT.L0MBS) IEXTSPACE=IEXTSPACE+1
        ENDDO
        IF(IEXTSPACE.EQ.1) SVDEXTOPT=.TRUE.
      ENDIF
      IF(SVDEXTOPT) THEN
        IF(SOME) WRITE(IW,9072)
      ENDIF
C------------------------------------------------------
C------------------------------------------------------
C------------------------------------------------------
C     SETUP LIMLOW AND LIMSUP ARRAYS BY CALLING AOLIM.
C     LIMLOW CONTAINS INITIAL BASIS FXN INDEX FOR EACH ATOM.
C     LIMSUP CONTAINS FINAL BASIS FXN INDEX FOR EACH ATOM.
C     E.G. TRIATOMIC
C     LIMLOW LIMSUP
C     1      33
C     34     57
C     58     93 = NUM IN INFOA BLOCK
      CALL AOLIM
C------------------------------------------------------
C------------------------------------------------------
C------------------------------------------------------
C     SETUP VVOS AOS IF NEEDED.
C     NOTE:  IF DIMENSION ISSUE, THEN THE WRITE STATEMENT MIGHT HELP.
      COMBO=SVD_AOSCF.OR.IVVOS.NE.0
      IF(COMBO) THEN
C       READ IN THE REDUCED SV OVERLAP MATRIX FROM VVOS RUN.
        IF(SOME) WRITE(IW,9200)
        CALL FLSHBF(IW)
        IF(EXETYP.NE.CHECK)
     *  CALL DAREAD(IDAF,IODA,X(LSVMBS),L1*L0MBS,533,0)
      ENDIF
C------------------------------------------------------
C------------------------------------------------------
C------------------------------------------------------
C     CHECK FOR ERROR OUTS.
      CALL LOCAL_PPAERR(
     *     ZAN,IAN,NAT,NCORTOT,NACT,NATMOR,L0,L0MBS,
     *     MSTA,ISIZE_FCCWFN,NSPACE2,CISTEP,
     *     X(LIATMSTA),X(LIATMSTA2),KEEPER,ORMFUL,
     *     KEEPER_ISVMOR,ISVMOR,IVVOS,SVDEXTOPT,ISVDOP,
     *     SCFTYP,
     *     MASWRK,IW)
      IF(EXETYP.EQ.CHECK) GO TO 8999
C
C     ENSURE THAT ORBITALS ARE ORTHONORMAL
C            BEFORE THE SVD IS PERFORMED.
      CALL DAREAD(IDAF,IODA,X(LVTMP),L3,IORBF1,0)
      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      CALL LOCAL_CHECK_ORTHOG(
     *     L0,L1,L2,
     *     X(LS2),X(LS),X(LVTMP),X(LWRKSVD),
     *     MASWRK,IW)
C
C     MAKE THE CALLS FOR SVD-BASED ORBITALS.
      CALL LOCAL_PPASVDCORE(
     *     NCORTOT,IORBF1,X(LS2),
     *     X(LS),X(LUVEC),X(LEIG1),X(LVTVEC),
     *     X(LWRKSVD),X(LIWRK),
     *     X(LVOLD),X(LVTMP),X(LVSAV),
     *     X(LSV),X(LSAOMO),
     *     ISIZSVD,L0,L1,L2,L3,
     *     LIMLOW,LIMSUP,NAT,SVDAOS,
     *     ISPHER,
     *     L0MBS,SVD_AOSCF,X(LIPOSCOR),X(LILENCOR),X(LSVMBS),
     *     QMTTOL,NAOTOT,
     *     SOME,MASWRK)
      CALL LOCAL_PPASVD(
     *     NCORTOT,IORBF1,X(LS2),
     *     X(LS),X(LUVEC),X(LEIG1),X(LVTVEC),
     *     X(LWRKSVD),X(LIWRK),
     *     X(LVOLD),X(LVTMP),X(LVSAV),
     *     X(LSV),X(LSAOMO),
     *     ISIZSVD,NACT,NACTBS,L0,L1,L2,L3,
     *     MSTA,ISIZE_FCCWFN,NSPACE2,
     *     LIMLOW,LIMSUP,NAT,X(LIATMSTA),X(LIATMSTA2),KEEPER,
     *     X(LEIGSAV),X(LEIGTMP),X(LVTVECSAV),X(LIGRPLAB),
     *     X(LIATLAB),X(LIORDBIG),X(LIORDBIG2),ISVMOR,
     *     X(LIPOSMBS),X(LILENMBS),X(LIPOSCOR),X(LILENCOR),
     *     X(LSVMBS),L0MBS,
     *     KEEPER_ISVMOR,SVDEXTOPT,SVDAOS,SVD_INVAR,
     *     SVD_AOSCF,SCFTYP,
     *     ISPHER,
     *     IEXTSPACE,NATEXT,X(LIATEXT),NATMOR,
     *     QMTTOL,NAOTOT,L0DEP0,
     *     MASWRK,SOME)
C
C     1. FINAL ATOM ORDER    ==> FILE 531
C     2. FINAL GROUP LABEL   ==> FILE 546
      CALL VICLR(X(LIWRK),1,L1)
      CALL ICOPY(NACT,NATMOR(NCORTOT+1),1,X(LIWRK),1)
      CALL DAWRIT(IDAF,IODA,X(LIWRK),L1,528,1)
      CALL DAWRIT(IDAF,IODA,X(LIGRPLAB),L1,546,1)
C
C     STASH A COPY OF THE 'TRUE' NACT.
C     STASH A COPY OF THE 'TRUE' NACTSV FOR COMPLICATED EXTLOC RUNS.
      NACT_EXTLOC_SAV=NACT
      NACTSV_EXTLOC_SAV=NACTSV
C
C     OBTAIN SVD DENSITY.
C     --NSKIP_SING MUST ALWAYS BE INITIALIZED AT THIS POINT.
C     --ONLY ORTHOGONAL ORBITALS AT THIS POINT FOR DENSITY.
C     --EXTLOC STATEMENTS ARE IMPORANT
C       AND ELIMINATE FILE CONFLICTS EVERYWHERE.
      NSKIP_SING=0
      CALL LOCAL_SETUP_PPADEN(
     *     IORBF1,SCFTYP,SCFTYP_TRUTH,EXTLOC,SWITCH_ORBS,
     *     NSKIP,NSKIP2,NSKIP_SING,NACT,NACTSV,
     *     NCORTOT,NA,NB,IMBS,L1,IDENFIL,IDENSIZ,
     *     SOME,MASWRK,IW)
      CALL LOCAL_PPADEN(
     *     X(LVTMP),X(LVSAV),X(LVOLD),X(LSV),X(LIWRK),
     *     NSKIP,NSKIP2,NSKIP_SING,
     *     NCORTOT,NCORSV,NACT,NACTSV,L1,L3,
     *     NAT,SCFTYP,EXTLOC,
     *     IVVOS,IORBF1,IDENFIL,IDENSIZ,
     *     SOME,MASWRK)
      ITMP=(NACT*NACT+NACT)/2
      CALL LOCAL_CHECK_DENS(
     *     X(LVOLD),ITMP,NACT,NCORTOT,NE,
     *     MASWRK,IW)
C
C     RIGHT AFTER SVD DENSITY,
C     RESTORE NACT AND NACTSV BEFORE PROCEEDING.
      NACT=NACT_EXTLOC_SAV
      NACTSV=NACTSV_EXTLOC_SAV
C
C     FOR ORIENTATION DILRMO ROUTINE:
C     LOCAL_PPADEN PUTS DENSITY ON DAF FILE 285.
C     PUT ORTHOGONAL SVD-ORBITALS INTO FILE 71.
C     ----THE EXTLOC STATEMENTS ARE IMPORTANT
C         AND ELIMINATE FILE CONFLICTS EVERYWHERE...
      IF(EXTLOC.EQ.RNONE) THEN
        CALL DAREAD(IDAF,IODA,X(LVTMP),L3,521,0)
        CALL DAWRIT(IDAF,IODA,X(LVTMP),L3,71,0)
      ENDIF
C
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C     SVD-VVOS OVERHAUL:  STEP LAST
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C     RESET DIMENSIONS
C     RESET THE MSTA ARRAY
C
      IF(IVVOS.NE.0) THEN
        CALL LOCAL_SVDVVOS_REDIM_STEPLAST(
     *       SCFTYP,NACT,NACTSV,NSPACE,NSPACE_SAV,ISIZE_FCCWFN,
     *       MSTA,X(LMSTA_SAV),MASWRK,SOME,IW)
      ENDIF
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C     END OF SVD-VVOS OVERHAUL:  STEP LAST
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C
C     RELEASE ALL MEMORY FOR ATOMIC-LIKE ORBITALS.
 8999 CONTINUE
      CALL RETFM(NDAWN1)
C
      IF(SOME) THEN
        WRITE(IW,9300)
        CALL TIMIT(1)
      ENDIF
      RETURN
 9000 FORMAT(/5X,60(1H-)/
     *   5X,'LOCAL_LMOSVD NOW LOCALIZES ATOMIC BASIS ONTO MO SPACE.'/
     *   5X,60(1H-))
 9049 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *       /1X,'SCFTYP DOES NOT EXIST YET.')
 9050 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *       /1X,'VVOS MCSCF CAN ONLY RUN THROUGH LOCAL_LMOSVD',
     *        1X,'WITH THE ORMAS CISTEP.')
 9051 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *       /1X,'VVOS-SVD MCSCF RUNS MUST BE ALLOWED TO USE MORE',
     *        1X,'OF THE MSTA ARRAY.',
     *       /1X,'MSTA IS IN A COMMON WITH FIXED DIMENSION.',
     *        1X,'YOU NEED TO INCREASE FIXED DIMENSION OF MSTA',
     *        1X,'EVERYWHERE.')
 9052 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *        1X,'RIGHT NOW, VVOS ARE FORMED FROM THE OPERATOR',
     *        1X,'IN THE AO BASIS EARLIER IN THE CODE.',
     *       /1X,'SO, NATURAL ORBITALS CANNOT BE USED.')
 9053 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *        1X,'EXTLOC RUNS MUST RUN WITH VVOS=.T.',
     *       /1X,'SET VVOS TO TRUE IN SCF OR MCSCF GROUP.')
 9054 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *        1X,'LOCAL=SVD AND EXTLOC DO NOT WORK TOGETHER.')
 9055 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *        1X,'RHF AND ROHF ALWAYS NEED VVOS=TRUE.')
CKEEPIVVOS 9060 FORMAT(//10X,'MCSCF OCCUPIEDS+VVOS LOCALIZED ORBITALS')
 9070 FORMAT(/1X,'CHECKING OUT ISVDOP OPTIONS.')
 9071 FORMAT(1X,'USING REGULAR SVD OPTION.')
 9072 FORMAT(1X,'USING SVDEXTOPT OPTION:',
     *      /1X,'RIGHT NOW, SVDEXTOPT IS POSSIBLE WHEN THE',
     *       1X,'NSPACE GROUP IS',
     *       1X,'THE ENTIRE EXTERNAL SPACE.')
 9073 FORMAT(1X,'USING SVDAOS OPTION:  NONORTHOGONAL AOS IN SVD.')
 9077 FORMAT(1X,'USING SVD_INVAR OPTION:  ',
     *      /1X,'ATOMIC MO OVERLAPS ON ATOM A WITH SVD BASIS.')
 9080 FORMAT(1X,'USING SVD_AOSCF OPTION:  ',
     *      /1X,'FOR MBS ORBITALS, USE THE TRUE AOS FROM VVOS.',
     *      /1X,'FOR MORE THAN MBS ORBITALS,',
     *       1X,'USE SVD TO AO BASIS SET FOR THE EXTRA ORBITALS.')
 9081 FORMAT(1X,'USING SVD_AOSCF OPTION:  ',
     *      /1X,'FOR OCCUPIEDS, USE THE TRUE AOS FROM VVOS.',
     *      /1X,'FOR EXTERNALS,',
     *       1X,'USE SVD TO AO BASIS SET FOR THE EXTRA ORBITALS.')
 9090 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *       /1X,'THIS OPTION DOES NOT EXIST IN THE CODE.')
 9100 FORMAT(/1X,'RE-DEFINING ORBITAL SIZES FOR VVOS RUN...'/
     *       /1X,'CHEMICAL     CORE    ORBTIALS =',I5,
     *       /1X,'ORIG. FILLED VALENCE ORBITALS =',I5,
     *       /1X,'ORIG. ACTIVE VALENCE ORBITALS =',I5,
     *       /1X,'ORIG. EMPTY  VALENCE ORIBTALS =',I5,
     *       /1X,'NEW   VIRTUAL        ORBITALS =',I5)
 9200 FORMAT(/1X,'READING L1,L0MBS SV MATRIX FOR AOS',
     *        1X,'FROM THE VVOS RUN.',
     *       /1X,'NOTES FOR SCFTYP=MCSCF:',
     *       /1X,'1. IF VVOS IN MCSCF IS FALSE,',
     *       /1X,'DO NOT INSERT',
     *        1X,'VVOS INTO CANONICAL MCSCF ORBITALS.',
     *       /1X,'2. IF RUN BOMBS, CHECK FOR DIMENSION ISSUE',
     *        1x,'WITH DAF FILE 533.')
 9300 FORMAT(1X,'... DONE WITH SVD LOCALIZATION ...')
      END
C*MODULE LOCAL   *DECK LOCAL_PPAERR
c> @brief      Routine checks basis set for SVD-localization.
c>
c> @author     Aaron West and Klaus Ruedenberg
c>             -November 4, 2012
c>
c> @param ZAN          is from INFOA common.
c> @param IAN          is from INFOA common.
c> @param NAT          is the number of atoms.
c> @param NCORSV       is number of core orbitals.
c>                     For VVOS run, it is adjusted.
c> @param NACT         is the number of active orbitals.
c> @param NATMOR       is an integer array of atom numbers for each
c>                     orbital in the ORMAS subpsaces.
c>                     It restricts the localization by user input.
c> @param L0           is the length of the MO variational space.
C> @param L0MBS        is the dimension of the minimal basis set number of
C>                     orbitals.
C>                     L0MBS is derived from NCORTOT+LOCAL_NUMVAL.
c> @param MSTA         contains the starting orbitals for each
c>                     ORMAS group, or subspace.
c> @param ISIZE_FCCWFN is current size of fccwfn integer arrays.
c> @param NSPACE       is the number ORMAS groups.
c> @param CISTEP       is the kind of CI performed e.g. ormas,aldet.
c> @param IATMSTA      is an array that defines sets of atoms and
c>                     orbitals to localized based on natmor input.
c> @param IATMSTA2     is for catching bugs across to local_ppasvd.
C> @param KEEPER       is a logical that equals true when
C>                     cistep=ormas and nspace>1 and ormful=false.
C> @param ORMFUL       is the local input that allows for
C>                     full localization
C>                     across ORMAS groups.
C>                     Thus, it destroys ORMAS wavefunction
C>                     invariance for less than full excitations.
C> @param KEEPER_ISVMOR   is true if the user input the number of
C>                        orbitals
C>                        desired on each atom.
C>                        If false, we let the SVD figure out
C>                        atom-orbital assignments.
C> @param ISVMOR       is ISVMOR from ORNTMO common block.
C> @param IVVOS        equals 1 indicates a VVOS run.
C>                     At this point, running VVOS orbitals through SVD.
C> @param SVDEXTOPT    preserves degenerate external orbitals
C>                     in the external orbital space by
C>                     discarding only orbitals with non-degenerate
C>                     SVD values on each atom.
C>                     However, this option must not allow any more
C>                     sperical externals than are allowed on a given
C>                     atom.
C>                     So, one should not loop over and look for
C>                     the smallest eigenvalues across atoms here.
C> @param ISVDOP       is a switch for various extra options.
C>                     I made this item so that I do not have to keep
C>                     taking up space to the nameio call for
C>                     local group.
C> @param SCFTYP       is SCF type for the wave function.
c> @param MASWRK       indicates the master process.
c> @param IW           indicates write out to the log file.
      SUBROUTINE LOCAL_PPAERR(ZAN,IAN,NAT,NCORSV,NACT,NATMOR,L0,L0MBS,
     *                  MSTA,ISIZE_FCCWFN,NSPACE,CISTEP,
     *                  IATMSTA,IATMSTA2,KEEPER,ORMFUL,
     *                  KEEPER_ISVMOR,ISVMOR,IVVOS,SVDEXTOPT,ISVDOP,
     *                  SCFTYP,
     *                  MASWRK,IW)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL MASWRK,KEEPER,KEEPER_ISVMOR,ORMFUL
      LOGICAL FILL_NATMOR,FILL_ISVMOR,SVDEXTOPT,COMBO
      INTEGER MXATM,NSPACE,ISVDOP
      PARAMETER (MXATM=2000)
      DOUBLE PRECISION :: ZAN(MXATM),CISTEP,ORMAS,SCFTYP,RHF
      INTEGER NAT,IW,I,J,II,NERR,IERR,ILAST,NUCZ,ITMP,NCORSV,NACT,
     *        ISIZE_FCCWFN,L0,L0MBS,L,K
      INTEGER IVVOS
      INTEGER ICOUNT,NUMVAL1,LOCAL_NUMVAL
      INTEGER IAN(MXATM),MSTA(ISIZE_FCCWFN),NATMOR(L0),
     *        IATMSTA(NSPACE*NAT),IATMSTA2(NSPACE*NAT),
     *        ISVMOR(NAT)
C-----------------------------------------------------------------------
C
      DATA ORMAS /8HORMAS   /
      DATA RHF/8HRHF     /
C
C     INITIALIZE NERR
      NERR=0
C
C     MAKE SOME MAIN ERROR OUTS FIRST.
C     --FOR NOW, ABORT IF BASIS IS NOT ALL ELECTRON BASIS.
      IERR=0
      ILAST=55
      DO I=1,NAT
        NUCZ = INT(ZAN(I) + 1.0D-03)
        IF(NUCZ.NE.IAN(I).OR.IAN(I).GE.ILAST) IERR=IERR+1
      ENDDO
      NERR=NERR+IERR
      IF(MASWRK) WRITE(IW,9001)
      IF(MASWRK.AND.IERR.GT.0) WRITE(IW,9002)
C
C     CHECK OUT THE NATMOR AND ISVMOR ARRAYS
      FILL_NATMOR=.FALSE.
      FILL_ISVMOR=.FALSE.
      DO I=NCORSV+1,NCORSV+NACT
        IF(NATMOR(I).NE.0) FILL_NATMOR=.TRUE.
      ENDDO
      DO I=1,NAT
        IF(ISVMOR(I).NE.0) FILL_ISVMOR=.TRUE.
      ENDDO
C
C
C     NEW SECTION FOR NEW KINDS OF ERROR OUT OPTIONS.
C
C
C     SOME ERROR OUTS FOR ISVDOP=10.
C     IF THE FOLLOWING IS NOT MET,
C     MORE CHECKING IS REQUIRED BEFORE PROCEEDING...
      IF(ISVDOP.EQ.10) THEN
        IF(MASWRK
     *    .AND.NSPACE.EQ.2
     *    .AND.NACT.GT.L0MBS-NCORSV) WRITE(IW,9031)
        IF(NACT.GT.L0MBS-NCORSV.AND.NSPACE.NE.2) THEN
          IF(MASWRK) WRITE(IW,9032)
          NERR=NERR+1
        ENDIF
C       NOTE:  NSPACE2 WAS FED IN AND SET TO 1 FOR ALDET.
      ENDIF
C
C     MAKE ANY EXCLUSIONS FOR SVDEXTOPT
      IF(SVDEXTOPT) THEN
        IF(FILL_NATMOR.OR.FILL_ISVMOR) THEN
          IF(MASWRK) WRITE(IW,9033)
          NERR=NERR+1
        ENDIF
        IF(NSPACE.EQ.1) THEN
          IF(MASWRK) WRITE(IW,9034)
          NERR=NERR+1
        ENDIF
        IF(.NOT.KEEPER) THEN
          IF(MASWRK) WRITE(IW,9035)
          NERR=NERR+1
        ENDIF
      ENDIF
C
C     ALLOW NATMOR WITH VVOS UNDER CERTAIN CONDITIONS.
      COMBO=ISVDOP.NE.6
     *      .AND.ISVDOP.NE.4
     *      .AND.ISVDOP.NE.10
      COMBO=COMBO.AND.SCFTYP.NE.RHF
      COMBO=COMBO.AND.FILL_NATMOR.AND.IVVOS.NE.0
      IF(COMBO) THEN
        IF(MASWRK) WRITE(IW,9040)
        NERR=NERR+1
      ENDIF
C
C     MAKE CONDITIONS FOR USING SOME ISVDOP OPTIONS.
      COMBO=ISVDOP.EQ.6
      IF(KEEPER) THEN
        IF(COMBO.AND..NOT.FILL_NATMOR) THEN
          IF(MASWRK) WRITE(IW,9041)
        ENDIF
      ELSE
        IF(COMBO.AND..NOT.FILL_ISVMOR) THEN
          IF(MASWRK) WRITE(IW,9042)
        ENDIF
      ENDIF
C
C     ERROR OUT IF CISTEP=ORMAS AND ISVMOR ARRAY IS FILLED IN.
      IF(MASWRK.AND.CISTEP.EQ.ORMAS) WRITE(IW,9050)
      IF(CISTEP.EQ.ORMAS.AND.FILL_ISVMOR) THEN
        NERR=NERR+1
        IF(MASWRK) WRITE(IW,9051)
      ENDIF
C
C     SKIP REST OF THE ERROR OUTS IF KEEPER + NO NATMOR ARRAY.
      IF(KEEPER .OR. ORMFUL) THEN
        IF(.NOT.FILL_NATMOR) THEN
          CALL VICLR(IATMSTA,1,NSPACE*NAT)
          CALL VICLR(IATMSTA2,1,NSPACE*NAT)
          GO TO 8000
        ELSE
C         NOW, AUTO-FILL IN ISVMOR ARRAY FOR ITS DEFS IN LOCAL_NUMVAL.
          DO I=NCORSV+1,NCORSV+NACT
            ITMP=NATMOR(I)
            ISVMOR(ITMP)=ISVMOR(ITMP)+1
          ENDDO
        ENDIF
      ENDIF
C
C     END OF NEW SECTION FOR NEW KINDS OF ERROR OUT OPTIONS.
C
C
C     ERROR OUT IF ACTIVE ORBITALS ARE NOT THE LENGTH NACT.
C     NOTE:  THIS VAR TRUE IF NATMOR OR ISVMOR IS FILLED HERE.
      IF(KEEPER_ISVMOR) THEN
      ITMP=0
      DO I=1,NAT
        NUMVAL1=LOCAL_NUMVAL(I,0)
        ITMP=ITMP+NUMVAL1
      ENDDO
      IERR=0
      IF(ITMP.NE.NACT) IERR=1
      NERR=NERR+IERR
      IF(MASWRK) WRITE(IW,9003)
      IF(MASWRK.AND.IERR.GT.0) WRITE(IW,9004)
      ENDIF
C
C     MAKE CHECKS ON NATMOR FOR ORMAS NSPACE>1.
C     --CHECK THAT NSPACE IS ACTUALLY GREATER THAN 0.
C     --CHECK THAT ALL ACTIVE ORBITALS ARE ASSIGNED ATOM NUMBERS.
C     --ATOM NUMBERS IN NATMOR MUST BE LESS THAN NAT.
C     --OCCURENCES OF ATOM NUMBERS IN NATMOR
C       CANNOT EXCEED NUMBER OF VALENCE ORBITALS ON EACH ATOM.
C
      IF(CISTEP.NE.ORMAS.OR.NSPACE.EQ.1) GO TO 8000
      IERR=0
      IF(NSPACE.EQ.0) IERR=IERR+1
      NERR=NERR+IERR
      IF(MASWRK) WRITE(IW,9005)
      IF(NSPACE.EQ.0) WRITE(IW,9006)
C
C     AT THIS POINT, MSTA ORBITAL INDICES CONTAIN CORES.
      IERR=0
      DO I=MSTA(1),MSTA(NSPACE+1)-1
        IF(NATMOR(I).EQ.0) IERR=IERR+1
      ENDDO
      NERR=NERR+IERR
      IF(MASWRK) WRITE(IW,9007)
      IF(IERR.GT.0.AND.MASWRK) WRITE(IW,9008)
C
      IERR=0
      DO I=1,NAT
        ITMP=0
        DO II=MSTA(1),MSTA(NSPACE+1)-1
          IF(NATMOR(II).EQ.I) ITMP=ITMP+1
        ENDDO
        NUMVAL1=LOCAL_NUMVAL(I,0)
        IF(ITMP.GT.NUMVAL1) IERR=IERR+1
      ENDDO
      NERR=NERR+IERR
      IF(MASWRK) WRITE(IW,9009)
      IF(MASWRK.AND.IERR.GT.0) WRITE(IW,9010)
C
C     NOW, USE NATMOR TO CREATE THE IATMSTA ARRAY.
C          THE IATMSTA ARRAY WILL SOON DEFINE THE
C          THE SVD SIZES IN THE SUBSEQUENT ROUTINES.
C          THE IATMSTA2 ARRAY IS CATCHING BUGS IN -LOCAL_PPASVD-.
C          IATMSTA2 WILL THEN CHANGE TO DEFINE STARTING ORBITAL NUMBER.
      CALL VICLR(IATMSTA,1,NSPACE*NAT)
      CALL VICLR(IATMSTA2,1,NSPACE*NAT)
      DO II=1,NSPACE
        DO I=MSTA(II),MSTA(II+1)-1
          DO J=1,NAT
            ITMP=(J-1)*NSPACE+II
            IF(NATMOR(I).EQ.J) IATMSTA(ITMP)=IATMSTA(ITMP)+1
            IF(NATMOR(I).EQ.J) IATMSTA2(ITMP)=1
          ENDDO
        ENDDO
      ENDDO
      IF(MASWRK) THEN
        WRITE(IW,9012)
        DO II=1,NSPACE
          WRITE(IW,9013) II
          DO J=1,NAT
            ITMP=(J-1)*NSPACE+II
            IF(IATMSTA2(ITMP).EQ.1) WRITE(IW,9014) J
          ENDDO
        ENDDO
        WRITE(IW,9015)
        WRITE(IW,9016)
        DO II=1,NSPACE
          DO J=1,NAT
            ITMP=(J-1)*NSPACE+II
            IF(IATMSTA(ITMP).NE.0)
     *        WRITE(IW,9017) II,J,IATMSTA(ITMP)
          ENDDO
        ENDDO
        WRITE(IW,9015)
      ENDIF
C
C     KEY PIECE:
C     --JUST LIKE IN LOCAL_PPASVD FOR THE AUTOMATED VERSION,
C       NOW RESET THE NATMOR ARRAY.
C     --IF THE CANONICAL ORBITALS ARE LOCALIZED ENOUGH THAT
C       THE ATOM-ORBITAL CORRESPONDENCE REMAINS THE SAME,
C       THEN ALL IS WELL.
C     --OTHERWISE:
C     1)  TOTAL ATOMIC VALENCE POPULATIONS COULD BE WRONG LATER.
C
      DO I=1,NSPACE
        ICOUNT=0
        DO J=1,NAT
          K=MSTA(I)+ICOUNT
          ITMP=(J-1)*NSPACE+I
          DO L=K,K+IATMSTA(ITMP)
              NATMOR(L)=J
          ENDDO
          ICOUNT=ICOUNT+IATMSTA(ITMP)
        ENDDO
      ENDDO
C
C     ACTUALLY ERROR OUT.
 8000 CONTINUE
      IF(NERR.GT.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9001 FORMAT(/1X,'BASIS SET CHECK IS DONE.')
 9002 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.'/
     *       1X,'ERROR OCCURS FOR USING BASIS SET.')
 9003 FORMAT(1X,'ACTIVE VALENCE ORBITAL CHECK IS DONE.')
 9004 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.'/
     *       1X,'NACT MUST EQUAL NUMBER OF MBS',
     *       1X,'OR USER SELECTED VALENCE ORBITALS.')
 9005 FORMAT(1X,'FCCWFN CHECK IS DONE.')
 9006 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.'/
     *       1X,'FCCWFN COMMON IS NOT YET DEFINED.'/)
 9007 FORMAT(1X,'NATMOR ARRAY CHECK IS DONE.')
 9008 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.'/
     *  /1X,'SVD ORMAS IS ASKING FOR',
     *   1X,'NATMOR ARRAY BE FILLED IN.',
     *  /1X,'IF USER FILLED, IT WILL NOT BE RESET.',
     *  /1X,'ISVMOR ARRAY CAN NEVER BE USER DEFINED',
     *   1X,'WITH ORMAS HERE.')
 9009 FORMAT(1X,'ATOM OCCURENCES IN NATMOR ARRAY CHECK IS DONE.')
 9010 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.'/
     *       1X,'SVD ORMAS REQUIRES NATMOR ARRAY VALUE OCCURENCES',
     *       1X,'MAX OUT WITH THE'/,
     *       1X,'MAXIMUM NUMBER OF VALENCE ORBITALS',
     *       1X,'ALLOWED ON EACH ATOM.'/)
 9012 FORMAT(/1X,'*** DEFINING SVD ATOM ASSIGNEMENTS',
     *        1X,'BASED ON USER INPUT. ***',
     *       /1X,'NSPACE',4X,'ATOM')
 9013 FORMAT(/I3,4X,' ',$)
 9014 FORMAT(1X,I3,$)
 9015 FORMAT(/)
 9016 FORMAT(/1X,'*** DEFINING SVD OUTPUTS BASED ON USER INPUT. ***',
     *       /1X,'NSPACE',4X,'ATOM',4X,'NUMBER OF MOs')
 9017 FORMAT(1X,I3,4X,I3,4X,I3)
 9031 FORMAT(1X,'ISVDOP=10 + NSPACE=2 RUNS MUST HAVE',
     *       1X,'MBS NUMBER OF ORBITALS IN GROUP 1.')
 9032 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.',
     *        1X,'ISVDOP=10 CANNOT BE USED WHEN',
     *        1X,'NACT>L0MBS-NCORTOT AND NSPACE NE 2.')
 9033 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.',
     *        1X,'THIS ISVDOP OPTION CANNOT BE USED WHEN',
     *        1X,'ISVMOR OR NATMOR ARRAYS ARE FILLED.')
 9034 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.',
     *        1X,'SVDEXTOPT OPTION MUST HAVE NSPACE>1.')
 9035 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.',
     *        1X,'SVDEXTOPT OPTION MUST HAVE KEEPER VAR TRUE.')
 9040 FORMAT(1X,'THE USER CANNOT CHOOSE NATMOR',
     *       1X,'IN VVOS-SVD RUNS WITHOUT ISVDOP=6,8,11.')
 9041 FORMAT(1X,'ERROR:  PLEASE FILL IN NATMOR ARRAY.')
 9042 FORMAT(1X,'ERROR:  PLEASE FILL IN ISVMOR ARRAY.')
 9050 FORMAT(1X,'ORMAS ISVMOR ARRAY CHECK IS DONE.')
 9051 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.'
     *       /1X,'SVD ORMAS CANNOT HAVE ISVMOR FILLED IN.')
      END
C*MODULE LOCAL   *DECK LOCAL_NUMVAL
c> @brief      Routine returns number of valences orbitals.
c>
c> @author     Aaron West and Klaus Ruedenberg
c>             -November 4, 2012
c>
c> @date January 12, 2013-Aaron West
c> -This routine has now moved beyond the minimal basis set.
c>
c> @param ITMP2 is the atom number.
C>
C> @date January 30, 2013-Aaron West
C> -Added ISVDOP to ORNTMO common block.
C> This run gives special option for SVD runs.
C>
C> @date March 20, 2013-Aaron West
C> -Added ISWMBS to integer function.
C> ISWMBS allows for the output of MBS numbers of orbitals.
C>
      INTEGER FUNCTION LOCAL_NUMVAL(ITMP2,ISWMBS)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      INTEGER IWX,ITEST,I,ITMP,ITMP2,NVALAT,ISWMBS,NERR
C---------------------------------------------------
      LOGICAL ORIENT,ORIKIN,ORMFUL
      DOUBLE PRECISION :: ZAN,C,BNDDEN
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
      INTEGER NAT,ICH,MUL,NUM,NQMT,NEX,NA,NB,IAN
      INTEGER NATMOR,ISVMOR,ISVDOP,L0DEP0
      DOUBLE PRECISION :: EXTLOC,EREFATM,COUP_NT_VVO
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
      INTEGER IVVOS,NVVOS
C---------------------------------------------------
      INTEGER MXATM,MXAO
      PARAMETER (MXATM=2000, MXAO=8192)
C---------------------------------------------------
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NEX,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /ORNTMO/ EXTLOC,EREFATM,COUP_NT_VVO(MXATM),
     *                NATMOR(MXAO),ISVMOR(MXATM),ISVDOP,L0DEP0,
     *                ORIENT,ORIKIN,ORMFUL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /VVOPAR/ IVVOS,NVVOS,BNDDEN
C-----------------------------------------------------------------------
C
C     RETURN THE NUMBER OF VALENCE ORBITALS ON A GIVEN ATOM.
C     ALSO SEE NUMCOR,NVVOS_NUMCOR,AND VVOS ROUTINES.
C     STILL NEED TO ADDRESS ECPs,ETC.
C     STILL NEED TO ADDRESS SEMI-CORE ORBS.
C
      NERR=0
      ITEST=0
      DO I=1,NAT
        IF(ISVMOR(I).NE.0) ITEST=1
      ENDDO
C
C     HERE, WE WILL ENFORCE MBS NUMBERS OF ORBITALS FOR CERTAIN OPTIONS.
      IF(IVVOS.NE.0) ITEST=0
C
C     GRAB ATOM NUMBER
      I=ITMP2
C
C     ASSIGN NUMBER OF VALENCE ORBITALS
      IF(ITEST.EQ.0.OR.ISWMBS.EQ.1) THEN
        ITMP=IAN(I)
        IF(ITMP.LT.1.OR.ITMP.GT.54) THEN
          NERR=NERR+1
          IF(MASWRK) WRITE(IW,9000)
        ENDIF
        IF(               ITMP.LE. 2) NVALAT=1
        IF(ITMP.GE. 3.AND.ITMP.LE. 4) NVALAT=1
        IF(ITMP.GE. 5.AND.ITMP.LE.10) NVALAT=4
        IF(ITMP.GE.11.AND.ITMP.LE.12) NVALAT=1
        IF(ITMP.GE.13.AND.ITMP.LE.18) NVALAT=4
        IF(ITMP.GE.19.AND.ITMP.LE.20) NVALAT=1
        IF(ITMP.GE.21.AND.ITMP.LE.30) NVALAT=6
        IF(ITMP.GE.31.AND.ITMP.LE.36) NVALAT=4
        IF(ITMP.GE.37.AND.ITMP.LE.38) NVALAT=1
        IF(ITMP.GE.39.AND.ITMP.LE.48) NVALAT=6
        IF(ITMP.GE.49.AND.ITMP.LE.54) NVALAT=4
      ELSE
        NVALAT=ISVMOR(I)
      ENDIF
C
      IF(NERR.GT.0) THEN
        IWX=IW
        CALL FLSHBF(IWX)
        CALL ABRT
        STOP
      ENDIF
C
      LOCAL_NUMVAL=NVALAT
C
      RETURN
 9000 FORMAT(1X,'LOCAL_NUMVAL ERROR:',
     *      /1X,'THERE IS A PROBLEM WITH THE INTEGER ARRAY IAN.')
      END
C*MODULE LOCAL   *DECK LOCAL_ATM_CH
C> @brief      This routine return integer value of nuclear charge.
C>
C> @author     Aaron West
C>             -November 15, 2012
C>
C> @details    Using function avoids any conflict of variables very
C>             easily.  e.g. in Davidson routines for Malmqvist items
C>
C> @param IAT is the atom number.
      INTEGER FUNCTION LOCAL_ATM_CH(IAT)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      INTEGER IAT
C     NEW CODING STANDARDS VARS
      DOUBLE PRECISION :: ZAN,C
      INTEGER MXATM,NAT,ICH,MUL,NUM,NQMT,NEX,NA,NB,IAN
      PARAMETER (MXATM=2000)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NEX,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C-----------------------------------------------------------------------
C
      LOCAL_ATM_CH=INT(ZAN(IAT))
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_PPASVDCORE
c> @brief      Routine makes SVD-localized core orbitals.
c>
c> @author     Aaron West and Klaus Ruedenberg
c>             -November 4, 2012
c>
c> @details    LOCAL_PPASVD contains equivalent and
c>             better comments in the routine itself.
c>
c> @date November 16, 2012-Aaron West
c> -Removed some error outs for vtvec.  Symmetric molecules
c>  can have zeros here even in C1 point group.
c>  This error out was mainly for debugging bad code.
c>
c> @param NCORTOT is total number of MCSCF core orbitals.
c>        For VVOS run, it is adjusted.
c> @param IORBF1 is the dat dict file for initial orbitals.
c> @param S2 stores AO basis overlaps on each atom.
c> @param S stores all the AO basis overlaps.
c> @param UVEC is the u matrix in SVD.
c> @param EIG holds eigenvalues from SVD.
c> @param VTVEC is the V-transpose matrix in SVD.
c> @param WRKSVD is the work array designed for gldiag and svd calls.
c> @param IWRK is the integer work array used
c>                    -- for symmetric matrix indices
c>                    -- for gldiag calls
c> @param VOLD contains the AO coefficients from IORBF1 daf dict file.
c> @param VTMP is temporary storage.
c> @param VSAV is temporary storage.
c> @param SV holds the AO basis overlap times AO coefficients matvec.
c> @param SAOMO is often S_IATM1**(-1/2) * SV on each IATM1 atom.
c> @param ISIZSVD is the workspace size for WRKSVD array.
c> @param L0 is the length of the MO variational space.
c> @param L1 is the length of the AO coefficients.
c> @param L2 is the triangular length of L1.
c> @param L3 is the square of L1.
c> @param LIMLOW array contains the lower basis function on an atom.
c> @param LIMSUP array contains the upper basis function on an atom.
c> @param NAT is the number of atoms.
c> @param SVDAOS is a toggle option for orthogonalizing the input AOs.
C> @param ISPHER       indicates treatment of basis functions
C>                     in terms of spherical or Cartesians.
C> @param L0MBS        is the dimension of the minimal basis set number of
C>                     orbitals.
C>                     L0MBS is derived from NCORTOT+LOCAL_NUMVAL.
C> @param SVD_AOSCF    is an option to use the AOs from VVOS
C>                     with high basis set quality.
C> @param IPOSCOR      denotes the integer array that holds the starting
C>                     position for the 1st CORE AO on a given atom.
C> @param ILENCOR      denotes the integer array that holds the
C>                     number of CORE orbitals on a given atom.
C> @param SVMBS        is an array that holds the overlap to the true AOs
C>                     from the VVOS run.
C>                     This overlap has a dimension of L1xL0MBS.
C> @param QMTTOL is the linear dependence threshold.
C> @param NAOTOT is the true number of sphericals.
C> @param SOME   is true for master process with nprint not equal -5.
c> @param MASWRK indicates the master process.
c> @see   LOCAL_PPASVD
      SUBROUTINE LOCAL_PPASVDCORE(
     *           NCORTOT,IORBF1,S2,
     *           S,UVEC,EIG,VTVEC,WRKSVD,IWRK,
     *           VOLD,VTMP,VSAV,
     *           SV,SAOMO,
     *           ISIZSVD,L0,L1,L2,L3,
     *           LIMLOW,LIMSUP,NAT,SVDAOS,
     *           ISPHER,
     *           L0MBS,SVD_AOSCF,IPOSCOR,ILENCOR,SVMBS,
     *           QMTTOL,NAOTOT,
     *           SOME,MASWRK)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL SOME,MASWRK,SVDAOS,SVD_AOSCF,COMBOSPHER
      INTEGER MXATM
      PARAMETER (MXATM=2000)
      DOUBLE PRECISION :: ONE,TOL,QMTTOL
      INTEGER NAT,LIMLOW(MXATM),LIMSUP(MXATM),
     *        NVVOS_NUMCOR
      PARAMETER (ONE=1.0D+00)
      INTEGER I,IATM1,IBAS1,IBAS2,IBASSPH1,IBASSPH2,IBASPOS,
     *        IERR2,IERR3,IHACT,
     *        ILTH_FIX,ILTH_FIX_SAV,ILTH_SAV,ILTH,ILTHSPH,
     *        ILTH_FOR_SV,
     *        IMO,IORBF1,ISIZSVD,J,L0,L1,L2,L3,
     *        L0MBS,NCORTOT,NUMCOR1,IJ2,ITMP,IPOS,
     *        INFO,IKIND
      INTEGER NAOTOT
C---------SPHERICAL HARMONIC STUFF---------------------
      LOGICAL IGNORE_SPHER
      INTEGER ISPHER
C------------------------------------------------------
C     NEW CODING STANDARDS VARS
      INTEGER IDAF,IODA,IP,IPK,IR,IS,IW,NAV
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C-----------------------------------------------------------------------
      DOUBLE PRECISION ::
     *       S2(L2),S(L2),
     *       UVEC(L1,L1),EIG(L1),VTVEC(L1,L1),
     *       WRKSVD(ISIZSVD),
     *       VOLD(L1,L1),VTMP(L1,L1),VSAV(L1,L1),
     *       SV(L1,L1),SAOMO(L1,L1),SVMBS(L1,L0MBS)
      INTEGER IPOSCOR(NAT+1),ILENCOR(NAT),IWRK(L2)
C
C     -------------------------------------------------------
C     SEE LOCAL_PPASVD ROUTINE FOR ANALOGOUS COMMENTS.
C     -------------------------------------------------------
C
C
C     SET UP TOL=QMTTOL
      TOL=ABS(QMTTOL)
C
C     SET UP THE IPOSCOR AND ILENCOR ARRAYS.
      CALL LOCAL_VVOS_ORB_RANGE_CORE(IPOSCOR,ILENCOR,NAT)
C
C     READ IN THE DESIRED ORBITALS.
      CALL DAREAD(IDAF,IODA,VOLD,L3,IORBF1,0)
C
C     SV=S*V=AO BASIS OVERLAP*AO COEFFS
C               WITH INNER CONTRACTION OVER ALL ATOMS.
C     GET AND SAVE SV FOR ALL ATOMS
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL MTARBR(S,L1,VOLD,L0,SV,L1,1)
C
C     CONVERT S AND SV OVER TO SPHERICALS IF NEEDED.
      IGNORE_SPHER=.FALSE.
      COMBOSPHER=ISPHER.GE.0
     *           .AND..NOT.SVDAOS
     *           .AND..NOT.IGNORE_SPHER
      IF(COMBOSPHER) THEN
        CALL SPHBCKU(UVEC,L1,L1,ITMP)
        IF(ITMP.NE.NAOTOT) THEN
          IF(MASWRK) WRITE(IW,*)
          IF(MASWRK) WRITE(IW,*) "LOCSVD ERROR FOR SPHBCKU"
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
        CALL VCLR(S2,1,L2)
        CALL TFTRI(S2,S,UVEC,WRKSVD,NAOTOT,L1,L1)
        CALL DCOPY(L2,S2,1,S,1)
        CALL VCLR(VTMP,1,L3)
        CALL MRTRBR(UVEC,L1,L1,NAOTOT,SV,L1,L0,VTMP,L1)
        CALL DCOPY(L3,VTMP,1,SV,1)
      ENDIF
C
C     VCLR (CORE) NONROTHOGONAL QUASI-ATOMIC ORBITAL TRANSFORMATION.
      CALL VCLR(VSAV,1,L3)
C
C     LOOP OVER ALL ATOMS
      DO 100 IATM1=1,NAT
C
C       SKIP IF NUMCOR1=0.
        NUMCOR1=NVVOS_NUMCOR(IATM1,1)
        IF(NUMCOR1.EQ.0) GO TO 100
C
C       SET UP BASIS DIMENSIONS AND OVERLAP.
        CALL LOCAL_GRAB_BASIS_FXNS_ON_ATOM(
     *       LIMLOW,LIMSUP,IATM1,NAT,L2,
     *       S2,S,
     *       IBAS1,IBAS2,ILTH,
     *       IBASSPH1,IBASSPH2,ILTHSPH,
     *       COMBOSPHER)
        ILTH_SAV=ILTH
        ILTH_FIX=ILTH
        IBASPOS=IBAS1
        IF(COMBOSPHER) THEN
          ILTH_FIX=ILTHSPH
          IBASPOS=IBASSPH1
        ENDIF
        ILTH_FIX_SAV=ILTH_FIX
        ILTH_FOR_SV=ILTH_FIX
C
C       PERFORM S**(-1/2) ORTHOG.
C       NOTE:  SAOMO,VTVEC,UVEC,WRKSVD,IWRK ARE ALL SCRATCH.
        IKIND=3
        CALL LOCAL_WEIGHTED_SYM_ORTHOG(
     *       IKIND,ILTH_FIX,S2,WRKSVD,
     *       VTMP,VTVEC,UVEC,EIG,IWRK,WRKSVD,
     *       L1,L3,L2,.TRUE.,
     *       IW,MASWRK)
C
C       SAOMO= OVERLAP MATRIX B/T CORE MO AND AOS ON IATM1.
        CALL VCLR(SAOMO,1,L3)
C
C---------------------------------------------------------------
C       IMPLEMENT SAOMO OPTIONS.
C---------------------------------------------------------------
        IF(SVD_AOSCF) THEN
          IPOS=IPOSCOR(IATM1)
          ITMP=ILENCOR(IATM1)
          CALL MRTRBR(SVMBS(1,IPOS),L1,L1,ITMP,
     *                VOLD(1,1),L1,NCORTOT,SAOMO,L1)
          ILTH_FIX=ITMP
C
          IF(SOME) WRITE(IW,9002) ILTH_FIX,IATM1
        ELSEIF(SVDAOS) THEN
          DO IMO=1,NCORTOT
            CALL DCOPY(ILTH_FOR_SV,SV(IBASPOS,IMO),1,SAOMO(1,IMO),1)
          ENDDO
        ELSE
          CALL VCLR(UVEC,1,L3)
          DO IMO=1,NCORTOT
            CALL DCOPY(ILTH_FOR_SV,SV(IBASPOS,IMO),1,UVEC(1,IMO),1)
          ENDDO
          CALL VCLR(SAOMO,1,L3)
          CALL MRARBR(VTMP,L1,ILTH_FIX,ILTH_FOR_SV,
     *                UVEC,L1,NCORTOT,SAOMO,L1)
        ENDIF
C---------------------------------------------------------------
C       END OF IMPLEMENT SAOMO OPTIONS.
C---------------------------------------------------------------
C
C       PERFORM SVD FOR IATM1
        CALL VCLR(UVEC,1,L3)
        CALL VCLR(VTVEC,1,L3)
        CALL VCLR(EIG,1,L1)
        CALL DGESVD('A','A',
     *              ILTH_FIX,NCORTOT,SAOMO,L1,EIG,
     *              UVEC,L1,VTVEC,L1,
     *              WRKSVD,ISIZSVD,INFO)
C
C       IMMEDIATELY RESET ILTH_FIX
        ILTH=ILTH_SAV
        ILTH_FIX=ILTH_FIX_SAV
C
C       FORM TRANSFORMATION MATRIX VTVEC-TRANS
C            FOR THE NEWLY PROJECTED MOS.
        CALL TRPOSQ(VTVEC,L1)
C
C       DEFINE THE NUMBER OF CORE ORBITALS TO SAVE.
        NUMCOR1=NVVOS_NUMCOR(IATM1,1)
C
C       GRAB OUT THE (CORE) NONORTHOGONAL
C                QUASI-ATOMIC ORBITAL TRANSFORMATION.
        IHACT=0
        DO I=1,IATM1-1
          IHACT=IHACT+NVVOS_NUMCOR(I,1)
        ENDDO
        DO I=1,NUMCOR1
          IHACT=IHACT+1
          CALL DCOPY(NCORTOT,VTVEC(1,I),1,VSAV(1,IHACT),1)
        ENDDO
C
C     END LOOP OVER ALL ATOMS
  100 CONTINUE
C
C
C
C     SAVE THE (CORE) NONORTHOGONAL QUASI-ATOMIC ORBITAL TRANSFORMATION.
      CALL DAWRIT(IDAF,IODA,VSAV,L3,523,0)
C
C     HAVE THE NONORTHOGONAL ORBITAL TRANSFORMATION.
C     ---CONSTRUCT NONORTHOG. CORE ORBITALS IN DIRECT FASHION
      CALL VCLR(UVEC,1,L3)
      CALL MRARBR(VOLD,L1,L1,NCORTOT,VSAV,L1,NCORTOT,UVEC,L1)
      CALL DAWRIT(IDAF,IODA,UVEC,L3,522,0)
C
C     FORM SV=NEW OVERLAP B/T NEW MO ORBITALS.
C     --UVEC CONTAINS THE NONORTHOG. CORE ORBITALS.
      CALL VCLR(SV,1,L3)
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL MTARBR(S,L1,UVEC,NCORTOT,SV,L1,1)
      CALL MRTRBR(UVEC,L1,L1,NCORTOT,SV,L1,NCORTOT,VTMP,L1)
C
C     FORM VTMP=[ NEW SMO**(-1/2) ] VIA SYM. ORTHOGONALIZATION.
C     HERE INITIAL VTMP=NEW MO OVERLAPS.
      CALL VCLR(S2,1,L2)
      IJ2=1
      DO I=1,NCORTOT
        DO J=1,I
          S2(IJ2)=VTMP(I,J)
          IJ2=IJ2+1
        ENDDO
      ENDDO
      IERR2=0
      CALL VCLR(VTMP,1,L3)
ccccccc
      IF(NCORTOT.NE.0)
     * CALL GLDIAG(L1,NCORTOT,NCORTOT,S2,WRKSVD,EIG,VTMP,IERR2,IWRK)
ccccccc
      IF(IERR2.GT.0) GO TO 8999
      IERR3=0
      DO I=1,NCORTOT
        IF(EIG(I).LT.TOL) IERR3=IERR3+1
        EIG(I)=ONE/SQRT(EIG(I))
C       WRITE(IW,*) "IATM1,I,EIG=",IATM1,I,EIG(I)
      ENDDO
      IF(IERR3.GT.0) GO TO 8999
      DO I=1,NCORTOT
        DO J=1,NCORTOT
          SV(I,J)=VTMP(J,I)
          SV(J,I)=VTMP(I,J)
        ENDDO
      ENDDO
      DO I=1,NCORTOT
        CALL DSCAL(NCORTOT,EIG(I),VTMP(1,I),1)
      ENDDO
C     DO MATVEC TO S_IATM1**(-1/2)
      CALL VCLR(SAOMO,1,L3)
      CALL MRARBR(VTMP,L1,NCORTOT,NCORTOT,SV,L1,NCORTOT,SAOMO,L1)
      CALL DCOPY(L3,SAOMO,1,VTMP,1)
C
C     FORM UVEC * [VTMP = NEW SMO**(-1/2)] MATVEC
C     THIS NEXT PIECE ORTHOGONALIZES THE ALREADY PROJECTED MOS.
      CALL VCLR(SV,1,L3)
      CALL MRARBR(UVEC,L1,L1,NCORTOT,VTMP,L1,NCORTOT,SV,L1)
C     SAVE THE ORTHOGONAL QUASI-ATOMIC ORBITAL TRANSFORMATION NOW.
      CALL DAWRIT(IDAF,IODA,VTMP,L3,524,0)
      CALL DAREAD(IDAF,IODA,VTMP,L3,IORBF1,0)
      DO I=1,NCORTOT
        CALL DCOPY(L1,SV(1,I),1,VTMP(1,I),1)
      ENDDO
C     SAVE THE (CORE) ORTHOGONAL QUASI-ATOMIC ORBITALS.
      CALL DAWRIT(IDAF,IODA,VTMP,L3,521,0)
C
C
C
C
C     PERFORM FINAL ERROR OUTS.
 8999 CONTINUE
      IF(MASWRK) THEN
        IF(IERR2.GT.0) THEN
          WRITE(IW,9003)
        ELSEIF(IERR3.GT.0) THEN
          WRITE(IW,9004) IERR3
        ENDIF
      ENDIF
      IF(IERR2.GT.0
     *  .OR.IERR3.GT.0
     *  ) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9002 FORMAT(1X,'SVD_AOSCF OPTION FINDS',I4,' CORE ORBITALS',
     *       1X,'FOR ATOM NUMBER=',I4)
 9003 FORMAT(1X,'*** ERROR IN LOCAL_PPASVDCORE ROUTINE.'/
     *       1X,'ERROR OCCURS FOR GLDIAG CALL.')
 9004 FORMAT(1X,'*** ERROR IN LOCAL_PPASVDCORE ROUTINE.'/
     *       1X,'IN SYMMETRIC ORTHOG.,'/
     *       1X,I4,' EIGENVALUES ARE BELOW TOL.')
      END
C*MODULE LOCAL   *DECK LOCAL_PPASVD
c> @brief      Routine makes SVD-localized valence orbitals.
c>
c> @author     Aaron West and Klaus Ruedenberg
c>             -November 4, 2012
c>
c> @details    Please see note about VTMP array within
c>             the 100 do loop if you plan to muck.
c>
c> @date November 16, 2012-Aaron West
c> -Removed some error outs for vtvec.  Symmetric molecules
c>  can have zeros here even in C1 point group.
c>  This error out was mainly for debugging bad code.
c>
c> @date December 20, 2012-Aaron West
c> -Add ormas check on orbital transformation
c>  to sort out issues earlier than MALMQ_CIDRIV.
C>
C> @date December 28, 2012-Aaron West
C> -Re-work orbital extraction to use only the orbital transformation
C>  to define the final orbital sets by transforming the orbitals
C>  in the IORBF1 file.
C>
C> @date January 09, 2013-Aaron West
C> -Re-work scheme for the number of orbitals to take from each SVD.
C>  Use ALL maximum SVD values from ALL atoms.
C>
C> @date January 12, 2013-Aaron West
C> -Re-worked large section of this routine.
C>  ORMAS runs should be able to auto-assign orbitals to atoms now.
C>
C> @date August 16, 2013-Aaron West
C> -Turned evalue sorting into a totally different beast.
C>  This effort began from trying to deal with dropped MOs
C>  in larger basis sets.
C>  From this change, future modifications should be easier.
C>
c> @param NCORTOT is total number of MCSCF core orbitals.
c>        For VVOS run, it is adjusted.
c> @param IORBF1 is the dat dict file for initial orbitals.
c> @param S2 stores AO basis overlaps on each atom.
c> @param S stores all the AO basis overlaps.
c> @param UVEC is the u matrix in SVD.
c> @param EIG holds eigenvalues from SVD.
c> @param VTVEC is the V-transpose matrix in SVD.
c> @param WRKSVD is the work array designed for gldiag and svd calls.
c> @param IWRK is the integer work array used
c>                    -- for symmetric matrix indices
c>                    -- for gldiag calls
c> @param VOLD contains the AO coefficients from IORBF1 daf dict file.
c> @param VTMP is temporary storage.
c> @param VSAV is temporary storage.
c> @param SV holds the AO basis overlap times AO coefficients matvec.
c> @param SAOMO is often S_IATM1**(-1/2) * SV on each IATM1 atom.
c> @param ISIZSVD is the workspace size for WRKSVD array.
c> @param NACT is the total number of active orbitals.
c> @param NACTBS is the total number of active orbitals and ignores
c>               any orbitals that are dropped for linear dependence.
c> @param L0 is the length of the MO variational space.
c> @param L1 is the length of the AO coefficients.
c> @param L2 is the triangular length of L1.
c> @param L3 is the square of L1.
c> @param MSTA         contains the starting orbitals for each
c>                     ORMAS group, or subspace.
c> @param ISIZE_FCCWFN is current size of fccwfn integer arrays.
c> @param NSPACE       is the number ORMAS groups.
c> @param LIMLOW array contains the lower basis function on an atom.
c> @param LIMSUP array contains the upper basis function on an atom.
c> @param NAT is the number of atoms.
c> @param IATMSTA      is an array that defines sets of atoms and
c>                     orbitals to localized based on natmor input.
c> @param IATMSTA2     is for catching bugs across to local_ppasvd.
C> @param KEEPER       is a logical that equals true when
C>                     cistep=ormas and nspace>1 and ormful=false.
C> @param EIGSAV       saves the SVD evalues from ALL SVDs.
C>                     For each atom, an SVD is done.
C> @param EIGTMP       is scratch space to save EIGSAV array.
C> @param VTVECSAV     temporarily saves orbital transformations
C>                     for ALL SVDs from which transform elements
C>                     are selected.
C> @param IGRPLAB      is for ORMAS group labels with length of
C>                     NACTBS*NAT.
C> @param IATLAB       is for atom labels with length of
C>                     NACTBS*NAT.
C> @param IORDBIG      is integer scratch with length of
C>                     NACTBS*NAT.
C> @param IORDBIG2     is integer scratch with length of
C>                     NACTBS*NAT.
C> @param ISVMOR       is ISVMOR from ORNTMO common block.
C> @param KEEPER_ISVMOR   is true if the user input the number of
C>                        orbitals desired on each atom.
C>                        If false, we let the SVD figure out
C>                        atom-orbital assignments.
C> @param SVDEXTOPT    preserves degenerate external orbitals
C>                     in the external orbital space by
C>                     discarding only orbitals with non-degenerate
C>                     SVD values on each atom.
C>                     However, this option must not allow any more
C>                     sperical externals than are allowed on a given
C>                     atom.
C> @param SVMBS        is an array that holds the overlap to the true AOs
C>                     from the VVOS run.
C>                     This overlap has a dimension of L1xL0MBS.
C> @param L0MBS        is the dimension of the minimal basis set
C>                     number of orbitals.
C>                     L0MBS is derived from NCORTOT+LOCAL_NUMVAL.
C> @param SVDAOS       is a toggle option for orthogonalizing
C>                     the input AOs.
C> @param IPOSMBS      denotes the integer array that holds the starting
C>                     position for the 1st MBS AO on a given atom.
C>                     These are in atomic order from the input
C>                     as usual.
C>                     I emphasize the CORE+VALENCE part.
C> @param ILENMBS      gives the number of VALANEC MBS orbitals.
C> @param IPOSCOR      denotes the integer array that holds the starting
C>                     position for the 1st CORE AO on a given atom.
C> @param ILENCOR      denotes the integer array that holds the number of
C>                     CORE orbitals on a given atom.
C> @param SVD_INVAR    is a possible trial for invariant option.
C> @param SVD_AOSCF    is an option to use the AOs from VVOS
C>                     with high basis set quality.
C> @param SCFTYP       is the scftyp from common.
C> @param ISPHER       indicates treatment of basis functions
C>                     in terms of spherical or Cartesians.
C> @param IEXTSPACE    indicates the number of ORMAS groups that
C>                     begin above the L0MBS number of orbitals.
C> @param NATEXT       is an integer of chosen length.
C>                     Error outs are given for the length.
C> @param IATEXT       is integer scratch of length NAT*NATEXT.
C> @param NATMOR       is array for atom-orbital correspondence.
C> @param QMTTOL       is the threshold for linear dependence.
C> @param NAOTOT       is the true number of sphericals.
C> @param L0DEP0       is the current number of final spherical MOs.
C> @param MASWRK       indicates the master process.
C> @param SOME         is true for master process with nprint
C>                     not equal -5.
C>
      SUBROUTINE LOCAL_PPASVD(
     *     NCORTOT,IORBF1,S2,
     *     S,UVEC,EIG,VTVEC,
     *     WRKSVD,IWRK,
     *     VOLD,VTMP,VSAV,
     *     SV,SAOMO,
     *     ISIZSVD,NACT,NACTBS,L0,L1,L2,L3,
     *     MSTA,ISIZE_FCCWFN,NSPACE,
     *     LIMLOW,LIMSUP,NAT,IATMSTA,IATMSTA2,KEEPER,
     *     EIGSAV,EIGTMP,VTVECSAV,IGRPLAB,
     *     IATLAB,IORDBIG,IORDBIG2,ISVMOR,
     *     IPOSMBS,ILENMBS,IPOSCOR,ILENCOR,SVMBS,L0MBS,
     *     KEEPER_ISVMOR,SVDEXTOPT,SVDAOS,SVD_INVAR,
     *     SVD_AOSCF,SCFTYP,
     *     ISPHER,
     *     IEXTSPACE,NATEXT,IATEXT,NATMOR,
     *     QMTTOL,NAOTOT,L0DEP0,
     *     MASWRK,SOME)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL SOME,MASWRK,KEEPER,KEEPER_ISVMOR,SVDEXTOPT,SVDAOS,
     *        SVD_INVAR,SVD_AOSCF,COMBO,COMBO2,COMBOSPHER
      INTEGER MXATM
      PARAMETER (MXATM=2000)
      DOUBLE PRECISION :: TMP,ONE,TOL,QMTTOL,
     *                    SCFTYP,RHF,ROHF,RMC
      PARAMETER (ONE=1.0D+00)
      INTEGER NAT,LIMLOW(MXATM),LIMSUP(MXATM)
      INTEGER I,IATM1,IBAS1,IBAS2,IBASSPH1,IBASSPH2,IBASPOS,
     *        ILTH,ILTHSPH,ILTH_FIX,ILTH_SAV,ILTH_FIX_SAV,
     *        ILTH_FOR_SV,
     *        IORBF1,ISIZSVD,J,L0,L0BS,L0MBS,L1,L2,L3,
     *        NACT,NACTBS,NCORTOT,NUMVAL1,
     *        IERR0,IERR2,IERR3,IERR4,IERR5,IERR6,IERR7,IERR8,IERR9,
     *        IERR10,IERR11,IERR
      INTEGER JPOS,IPOS,IPOSMBS(NAT+1),ILENMBS(NAT),
     *             IPOSCOR(NAT+1),ILENCOR(NAT)
      INTEGER LOCAL_NUMVAL
      INTEGER IDAMAX,IXAMAX
      INTEGER IROW,JORB1,JORB2,JORBLEN,IDUM,ITMP,III,JJJ
      INTEGER NSPACE_LIMIT,NSPACE,ISPACE,NACTFIN,ISIZE_FCCWFN
      INTEGER NAOCART,NAOSPH,NAOTOT
      INTEGER ITMPNACT,ICT_ORB,NERR,IEND,IEXTORB,IEXTORBF,
     *        NACTTMP,NACTDEP,L0DEP,L0DEP0
      INTEGER INFO,IKIND
C---------SPHERICAL HARMONIC STUFF---------------------
      LOGICAL IGNORE_SPHER
      INTEGER ISPHER
C------------------------------------------------------
C     NEW CODING STANDARDS VARS
      INTEGER IDAF,IODA,IP,IPK,IR,IS,IW,NAV
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C-----------------------------------------------------------------------
      DOUBLE PRECISION ::
     *       S2(L2),S(L2),
     *       WRKSVD(ISIZSVD),
     *       UVEC(L1,L1),EIG(L1),VTVEC(L1,L1),
     *       VOLD(L1,L1),VTMP(L1,L1),VSAV(L1,L1),
     *       SV(L1,L1),SAOMO(L1,L1),SVMBS(L1,L0MBS)
      DOUBLE PRECISION ::
     *       EIGSAV(NACTBS*NAT),EIGTMP(NACTBS*NAT),
     *       VTVECSAV(NACT,NACTBS*NAT)
      INTEGER NATMOR(L0),IWRK(L1,L1),
     *        IGRPLAB(NACTBS*NAT),IATLAB(NACTBS*NAT),
     *        IORDBIG(NACTBS*NAT),IORDBIG2(NACTBS*NAT),ISVMOR(NAT),
     *        IATMSTA2(NSPACE,NAT),IATMSTA(NSPACE,NAT),
     *        MSTA(ISIZE_FCCWFN)
      INTEGER IEXTSPACE,NATEXT,IATEXT(NAT,NATEXT)
C
C     DEFINE SOME DATA STUFF
      DATA RMC/8HMCSCF   /
      DATA RHF/8HRHF     /
      DATA ROHF/8HROHF    /
C
C     SET UP TOL=QMTTOL
      TOL=ABS(QMTTOL)
C
C     INITIALIZE ALL POSSIBLE IERR VARS.
      IERR0=0
      IERR2=0
      IERR3=0
      IERR4=0
      IERR5=0
      IERR6=0
      IERR7=0
      IERR8=0
      IERR9=0
      IERR10=0
      IERR11=0
C
C     SETUP NSPACE_LIMIT.
C     --FOR ORMFUL, NSPACE_LIMIT CAN BE 1 WHEN NSPACE>1.
C     --FOR ALDET,  NSPACE_LIMIT IS SET TO 1.
      IF(KEEPER) THEN
        NSPACE_LIMIT=NSPACE
      ELSE
        NSPACE_LIMIT=1
      ENDIF
C
C     SETUP THE MBS ORBITAL POSITION AND LENGTH ARRAYS.
      CALL LOCAL_VVOS_ORB_RANGE_CORE(IPOSCOR,ILENCOR,NAT)
      CALL LOCAL_VVOS_ORB_RANGE(IPOSMBS,ILENMBS,NAT)
C
C------------------------------------------------------------
C------------------------------------------------------------
C
C     A FEW LAST CHECKS JUST TO BE SURE.
C     NOTE:  THIS NEXT CHECK IS IMPORTANT.  PLEASE KEEP IT.
      IF(KEEPER) THEN
        IF(SOME) WRITE(IW,9000)
        IERR0=0
        DO I=1,NSPACE_LIMIT
          DO J=1,NAT
            ITMP=IATMSTA2(I,J)
            IF(ITMP.NE.0.AND.ITMP.NE.1) IERR0=IERR0+1
          ENDDO
        ENDDO
        IF(IERR0.GT.0) GO TO 8999
      ENDIF
C
C     ALLRIGHT.  LAST CHECKS DONE.
C     FIRST CHECK HAS A GOOD CHANCE OF FINDING ANY FUTURE MEMORY ISSUES.
C------------------------------------------------------------
C------------------------------------------------------------
C
C------------------------------------------------------------
C     CONTINUE WITH CHUNKS OF ORIGINALLY INTENDED ROUTINE...
C------------------------------------------------------------
C
C
C     READ IN THE DESIRED ORBITALS.
      CALL DAREAD(IDAF,IODA,VOLD,L3,IORBF1,0)
C
C     SETUP SV=S*V=AO BASIS OVERLAP*AO COEFFS
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL MTARBR(S,L1,VOLD,L0,SV,L1,1)
C
C     CONVERT S AND SV OVER TO SPHERICALS IF NEEDED.
      IGNORE_SPHER=.FALSE.
      COMBOSPHER=ISPHER.GE.0
     *           .AND..NOT.SVDAOS
     *           .AND..NOT.IGNORE_SPHER
      IF(COMBOSPHER) THEN
        CALL SPHBCKU(UVEC,L1,L1,ITMP)
        IF(ITMP.NE.NAOTOT) THEN
          IF(MASWRK) WRITE(IW,*)
          IF(MASWRK) WRITE(IW,*) "LOCSVD ERROR FOR SPHBCKU"
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
        CALL VCLR(S2,1,L2)
        CALL TFTRI(S2,S,UVEC,WRKSVD,NAOTOT,L1,L1)
        CALL DCOPY(L2,S2,1,S,1)
        CALL VCLR(VTMP,1,L3)
        CALL MRTRBR(UVEC,L1,L1,NAOTOT,SV,L1,L0,VTMP,L1)
        CALL DCOPY(L3,VTMP,1,SV,1)
      ENDIF
C------------------------------------------------------------
C------------------------------------------------------------
C------------------------------------------------------------
C     LOOP OVER ALL ATOMS
C     NOTE:  SEPARATE CASES WITH 1 DIM.
      DO 100 IATM1=1,NAT
C------------------------------------------------------------
C------------------------------------------------------------
C------------------------------------------------------------
C
C       SET UP ATOMIC BASIS SET AND ITS DIMENSIONS.
        CALL LOCAL_GRAB_BASIS_FXNS_ON_ATOM(
     *       LIMLOW,LIMSUP,IATM1,NAT,L2,
     *       S2,S,
     *       IBAS1,IBAS2,ILTH,
     *       IBASSPH1,IBASSPH2,ILTHSPH,
     *       COMBOSPHER)
        ILTH_SAV=ILTH
        ILTH_FIX=ILTH
        IBASPOS=IBAS1
        IF(COMBOSPHER) THEN
          ILTH_FIX=ILTHSPH
          IBASPOS=IBASSPH1
        ENDIF
        ILTH_FIX_SAV=ILTH_FIX
        ILTH_FOR_SV=ILTH_FIX
C
C       CHECK THAT AO LENGTHS FROM LOCAL_COUNTAOS MATCH.
        ITMP=IATM1
        CALL LOCAL_COUNTAOS(ITMP,NAOCART,NAOSPH)
        IERR10=0
        IF(NAOCART.NE.ILTH) IERR10=1
        IF(IERR10.GT.0) GO TO 8999
C
C       PERFORM S**(-1/2) ORTHOG.
C       NOTE:  SAOMO,VTVEC,UVEC,WRKSVD,IWRK ARE ALL SCRATCH.
        IKIND=3
        CALL LOCAL_WEIGHTED_SYM_ORTHOG(
     *       IKIND,ILTH_FIX,S2,WRKSVD,
     *       VTMP,VTVEC,UVEC,EIG,IWRK,WRKSVD,
     *       L1,L3,L2,.TRUE.,
     *       IW,MASWRK)
C
C
C       *****************************************************
C       *****************************************************
C       FOR EACH ROUND OF 100 LOOP, VTMP CANNOT BE DISTURBED.
C       NOTES:
C       VTMP=S**(-1/2) ON ATOM IATM1.
C       FOR SPHERICALS...
C       VTMP=[W*S**(-1/2)]-TRANS
C       VTMP HAS DIMENSION OF (ILTH_FIX,ILTH) AS NEEDED FOR
C       THE SVDS BELOW.  THIS PIECE IS CORRECT.
C       *****************************************************
C       *****************************************************
C
C------------------------------------------------------------
C       INITIALIZE NSPACE FOR ALDET TO AVOID COMPLAINTS
C       NOTE: EVEN THOUGH THE DIM WAS ALREADY DEFINED TO BE 1.
C       THE ORMAS LOOP
        DO 90 ISPACE=1,NSPACE_LIMIT
C         NO KEEPER LINE HERE BECAUSE WE WANT TO LOOK (NOT USE)
C         ALL POSSIBLE SVD VALUES.
C------------------------------------------------------------
C         DEFINE NACTFIN
C         DEFINE ITEMS NEEDED FOR UVEC COPY
C         RESET ILTH HERE FOR FIRST PART OF THE LOOP.
          IF(KEEPER) THEN
            NACTFIN=MSTA(ISPACE+1)-MSTA(ISPACE)
            JORB1=MSTA(ISPACE)
            JORB2=MSTA(ISPACE+1)-1
          ELSE
            NACTFIN=NACT
            JORB1=NCORTOT+1
            JORB2=NCORTOT+NACT
          ENDIF
          ILTH=ILTH_SAV
          ILTH_FIX=ILTH_FIX_SAV
C
C---------------------------------------------------------------
C---------------------------------------------------------------
C         FINISH FORMING THE SAOMO OVERLAP MATRIX.
C---------------------------------------------------------------
C---------------------------------------------------------------
          CALL VCLR(SAOMO,1,L3)
          CALL VCLR(UVEC,1,L3)
          IF(SVDAOS) THEN
            III=1
            DO JJJ=JORB1,JORB2
              CALL DCOPY(ILTH_FOR_SV,SV(IBASPOS,JJJ),1,SAOMO(1,III),1)
              III=III+1
            ENDDO
          ELSEIF(SVD_INVAR) THEN
            IF(ILTH_FOR_SV.NE.ILTH) THEN
              IF(MASWRK) WRITE(IW,*)
              IF(MASWRK) WRITE(IW,*) "SVD_INVAR ILTH_FOR_SV PROBLEM."
              CALL FLSHBF(IW)
              CALL ABRT
              STOP
            ENDIF
C           MAKE P_INVAR = (V)-TRANS * SV
            CALL MRTRBR(VOLD(IBASPOS,JORB1),L1,ILTH,NACTFIN,
     *                    SV(IBASPOS,JORB1),L1,NACTFIN,SAOMO,L1)
C
C           NOTE:  THE USE OF ILTH_SAV ABOVE.
            ILTH=NACTFIN
            ILTH_FIX=NACTFIN
          ELSEIF(SVD_AOSCF) THEN
            COMBO =NACT.EQ.L0-NCORTOT.AND.ISPACE.EQ.1
            COMBO =COMBO.OR.NACT.EQ.L0MBS-NCORTOT
            COMBO2=NACT.EQ.L0-NCORTOT.AND.ISPACE.EQ.2
ccccccccccccc
CKEEPROHF        uncomment these lines in order to
CKEEPROHF        make the singly occupied space
CKEEPROHF        a separate 'active' ormas group.
CKEEPROHF        search on this for other places to uncomment...
CKEEPROHF            IF(SCFTYP.EQ.ROHF) THEN
CKEEPROHF              COMBO =ISPACE.EQ.1.OR.ISPACE.EQ.2
CKEEPROHF              COMBO2=ISPACE.EQ.3
CKEEPROHF            ENDIF
ccccccccccccc
            IF(COMBO) THEN
              IF(SOME.AND.IATM1.EQ.1) WRITE(IW,9038) ISPACE
C
C             E.G. FOR CARBON... FORM (4,L1)*(L1,NACTFIN) MATRIX.
C             THE INNER CONTRACTION IS NOW ACROSS ALL AO FXNS.
C             EARLIER, WE STOLE OUT S_BAS1*S_BAS2*V OF THE ATOMIC MOS
C                      FROM THE VVOS RUN INTO DAF FILE 533.
C             IN THIS EXAMPLE, OUR NULL SPACE IS NACTFIN-4.
C             SO, WE SHOULD SEE ONLY 4 NON-ZERO EIGENVALUES...
C
              IPOS=IPOSMBS(IATM1)
              ITMP=ILENMBS(IATM1)
              CALL MRTRBR(SVMBS(1,IPOS),L1,L1,ITMP,
     *                    VOLD(1,JORB1),L1,NACTFIN,SAOMO,L1)
C             NOTE:  THE USE OF ILTH_SAV ABOVE.
              ILTH=ITMP
              ILTH_FIX=ITMP
            ELSEIF(COMBO2) THEN
              IF(SOME.AND.IATM1.EQ.1) WRITE(IW,9039) ISPACE
              III=1
              DO JJJ=JORB1,JORB2
                CALL DCOPY(ILTH_FOR_SV,SV(IBASPOS,JJJ),1,UVEC(1,III),1)
                III=III+1
              ENDDO
              CALL MRARBR(VTMP,L1,ILTH_FIX,ILTH_FOR_SV,
     *                    UVEC,L1,NACTFIN,SAOMO,L1)
            ELSE
              IF(MASWRK) WRITE(IW,9040)
              CALL FLSHBF(IW)
              CALL ABRT
              STOP
            ENDIF
C
          ELSE
C           PROCEED WITH SVD WITH ORTHOG. AOS.
            III=1
            DO JJJ=JORB1,JORB2
              CALL DCOPY(ILTH_FOR_SV,SV(IBASPOS,JJJ),1,UVEC(1,III),1)
              III=III+1
            ENDDO
            CALL MRARBR(VTMP,L1,ILTH_FIX,ILTH_FOR_SV,
     *                  UVEC,L1,NACTFIN,SAOMO,L1)
          ENDIF
C---------------------------------------------------------------
C---------------------------------------------------------------
C         END OF FINISH FORMING THE SAOMO OVERLAP MATRIX.
C---------------------------------------------------------------
C---------------------------------------------------------------
C
C
C---------------------------------------------------------------
C---------------------------------------------------------------
C         PERFORM SVD FOR IATM1, AND SAVE VARIOUS ITEMS
C---------------------------------------------------------------
C---------------------------------------------------------------
C
C         PERFORM THE SVD.
          CALL VCLR(UVEC,1,L3)
          CALL VCLR(VTVEC,1,L3)
          CALL VCLR(EIG,1,L1)
          CALL DGESVD('A','A',
     *                ILTH_FIX,NACTFIN,SAOMO,L1,EIG,
     *                UVEC,L1,VTVEC,L1,
     *                WRKSVD,ISIZSVD,INFO)
C
C         DEFINE THE NUMBER OF NON-ZERO VALUES.
C         PRINT OFF INITIAL EVALUES.
          ITMPNACT=MIN(ILTH_FIX,NACTFIN)
          IF(SOME) THEN
            IF(ISPACE.EQ.1) WRITE(IW,9045) IATM1
            DO I=1,ITMPNACT
              WRITE(IW,9050) ISPACE,I,EIG(I)
            ENDDO
          ENDIF
C
C         FORM(NACTFIN,ITMPNACT) VTVEC-TRANS MATRIX.
          CALL TRPOSQ(VTVEC,L1)
C
C         TEMPORARILY SAVE COLLECTIVE ITEMS E.G. EVALUES.
          IF(IATM1.EQ.1.AND.ISPACE.EQ.1) THEN
            ICT_ORB=0
            CALL VICLR(IGRPLAB,1,NACTBS*NAT)
            CALL VICLR(IATLAB,1,NACTBS*NAT)
            CALL VCLR(EIGSAV,1,NACTBS*NAT)
            CALL VCLR(VTVECSAV,1,NACT*NACTBS*NAT)
          ENDIF
          IF(KEEPER) THEN
            IROW=MSTA(ISPACE)-NCORTOT
          ELSE
            IROW=1
          ENDIF
          DO I=1,ITMPNACT
            ICT_ORB=ICT_ORB+1
            IGRPLAB(ICT_ORB)=ISPACE
            IATLAB(ICT_ORB)=IATM1
            EIGSAV(ICT_ORB)=EIG(I)
            CALL DCOPY(NACTFIN,VTVEC(1,I),1,
     *                         VTVECSAV(IROW,ICT_ORB),1)
          ENDDO
C---------------------------------------------------------------
C---------------------------------------------------------------
C     END OF PERFORM SVD FOR IATM1, AND SAVE VARIOUS ITEMS
C---------------------------------------------------------------
C---------------------------------------------------------------
C
C------------------------------------------------------------
C------------------------------------------------------------
C------------------------------------------------------------
C       END LOOP OVER ORMAS GROUPS
   90   CONTINUE
C     END LOOP OVER ALL ATOMS
  100 CONTINUE
C
C     CHECK ON ICT_ORB NOW.
      IF(ICT_ORB.GT.NACTBS*NAT) THEN
        IF(MASWRK) WRITE(IW,9052)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C------------------------------------------------------------
C------------------------------------------------------------
C------------------------------------------------------------
C
C
C
C
C------------------------------------------------------------
C------------------------------------------------------------
C     SORTING PASSAGE TO OBTAIN ORBITALS.
C     NOTES:
C     --EACH STEP ORDERS A GIVEN NUMBER OF OBJECTS.
C     --HOW MANY OBJECTS REQUIRES SOME THOUGHT.
C------------------------------------------------------------
C------------------------------------------------------------
C     1.  SET THE NACTTMP VAR.
      NACTTMP=NACTBS
C
C     2.  AMONG ICT_ORB ORBITALS, SORT EVERYTHING BY SVD VALUE.
      CALL VICLR(IORDBIG,1,NACTBS*NAT)
      CALL VCLR(EIGTMP,1,NACTBS*NAT)
      CALL DCOPY(ICT_ORB,EIGSAV,1,EIGTMP,1)
      IERR11=0
      DO I=1,ICT_ORB
        IDUM=IDAMAX(ICT_ORB,EIGTMP,1)
        IF(EIGTMP(IDUM).LE.0.0D+00) IERR11=IERR11+1
        IORDBIG(I)=IDUM
        EIGTMP(IDUM)=0.0D+00
      ENDDO
      IF(IERR11.NE.0) GO TO 8999
      CALL LOCAL_SORT_SVDEIG(
     *     NACT,ICT_ORB,
     *     NACTBS,NAT,EIGSAV,VTVECSAV,
     *     IORDBIG,IORDBIG2,IGRPLAB,IATLAB)
C
C     3.  AMONG ICT_ORB ORBITALS, SORT BY GROUP.
      CALL VICLR(IORDBIG2,1,NACTBS*NAT)
      CALL VICLR(IORDBIG,1,NACTBS*NAT)
      CALL ICOPY(ICT_ORB,IGRPLAB,1,IORDBIG2,1)
      ITMP=0
      DO ISPACE=1,NSPACE
        DO I=1,ICT_ORB
          IF(ISPACE.EQ.IORDBIG2(I)) THEN
            IORDBIG2(I)=-1
            ITMP=ITMP+1
            IORDBIG(ITMP)=I
          ENDIF
        ENDDO
      ENDDO
      IF(ITMP.NE.ICT_ORB) THEN
        IF(MASWRK) WRITE(IW,9058)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
      CALL LOCAL_SORT_SVDEIG(
     *     NACT,ICT_ORB,
     *     NACTBS,NAT,EIGSAV,VTVECSAV,
     *     IORDBIG,IORDBIG2,IGRPLAB,IATLAB)
C
C     4.  CREATE IATMSTA ARRAY.
C     NOTE:  AT THIS POINT, ACCOUNT FOR ALLOWED ORMAS GROUP ORBITALS.
C            THIS STEP IS IMPORTANT.
      IF(.NOT.KEEPER_ISVMOR) THEN
        CALL VICLR(IATMSTA,1,NSPACE*NAT)
        CALL VICLR(ISVMOR,1,NAT)
        DO ISPACE=1,NSPACE
          IF(KEEPER) THEN
            JORB1=MSTA(ISPACE)
            JORB2=MSTA(ISPACE+1)-1
            IF(JORB2.EQ.L0) JORB2=L0+(NACTTMP-NACT)
            JORBLEN=JORB2-JORB1+1
          ELSE
            JORB1=NCORTOT+1
            JORB2=NCORTOT+NACTTMP
            JORBLEN=JORB2-JORB1+1
          ENDIF
          CALL VCLR(EIGTMP,1,NACTBS*NAT)
          CALL DCOPY(ICT_ORB,EIGSAV,1,EIGTMP,1)
          DO I=1,ICT_ORB
            IF(IGRPLAB(I).NE.ISPACE) EIGTMP(I)=0.0D+00
          ENDDO
          DO I=1,JORBLEN
            IDUM=IDAMAX(ICT_ORB,EIGTMP,1)
            EIGTMP(IDUM)=0.0D+00
            IATM1=IATLAB(IDUM)
            IATMSTA(ISPACE,IATM1)=IATMSTA(ISPACE,IATM1)+1
            ISVMOR(IATM1)=ISVMOR(IATM1)+1
          ENDDO
        ENDDO
      ENDIF
C
C     5.  AMONG ICT_ORB ORBITALS, SORT BY IATMSTA LIMIT.
      CALL VICLR(IATMSTA2,1,NSPACE*NAT)
      CALL VICLR(IORDBIG,1,NACTBS*NAT)
      ITMP=0
      IEND=ICT_ORB+1
      DO I=1,ICT_ORB
        ISPACE=IGRPLAB(I)
        IATM1=IATLAB(I)
        IF(IATMSTA2(ISPACE,IATM1).LT.IATMSTA(ISPACE,IATM1)) THEN
          IATMSTA2(ISPACE,IATM1)=IATMSTA2(ISPACE,IATM1)+1
          ITMP=ITMP+1
          IORDBIG(ITMP)=I
        ELSE
          IEND=IEND-1
          IORDBIG(IEND)=I
        ENDIF
      ENDDO
      CALL LOCAL_SORT_SVDEIG(
     *     NACT,ICT_ORB,
     *     NACTBS,NAT,EIGSAV,VTVECSAV,
     *     IORDBIG,IORDBIG2,IGRPLAB,IATLAB)
C
C     6.  IF AN EXTERNAL SPACE IS PRESENT,
C         SORT DEGENERACY AMONG EXTERNAL ORBITALS.
C         NOTES:
C         --USER INPUT OF EXTERNAL ATOM LABELS IS CURRENTLY HOPELESS.
C         --IATMSTA IS NOW POSSIBLY LOST.
C           I ACCOUNT FOR THIS LOSS LATER.
C         --IN LOCAL_SVDEXTOPT_ACROSSATOMS,
C           SEE HOW LIMORB IS DEFINED.
      IF(SVDEXTOPT) THEN
        IF(NACT.NE.L0-L0MBS.AND.SOME) WRITE(IW,9800)
        ITMP=ICT_ORB
        CALL LOCAL_SVDEXTOPT_ACROSSATOMS(
     *       ITMP,IGRPLAB,IATLAB,IORDBIG,
     *       IEXTSPACE,L1,L0,L0MBS,NCORTOT,NATEXT,
     *       IATEXT(1,1),IATEXT(1,2),IATEXT(1,3),
     *       IATEXT(1,4),IATEXT(1,5),
     *       NAT,NACTBS,NACT,NSPACE,MSTA,
     *       EIGSAV,EIGTMP,
     *       ILENCOR,ILENMBS,
     *       SOME,MASWRK,IW)
        CALL LOCAL_SORT_SVDEIG(
     *       NACT,ICT_ORB,
     *       NACTBS,NAT,EIGSAV,VTVECSAV,
     *       IORDBIG,IORDBIG2,IGRPLAB,IATLAB)
        IERR=0
        DO I=1,L0MBS-NCORTOT
          IF(IORDBIG(I).NE.I) IERR=IERR+1
        ENDDO
        DO I=L0MBS-NCORTOT+1,NACTTMP
          IF(IGRPLAB(I).NE.NSPACE) IERR=IERR+1
        ENDDO
        IF(IERR.NE.0) THEN
          IF(MASWRK) WRITE(IW,9805)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
      ENDIF
C
C     7.  AMONG NACTTMP ORBITALS,
C         SORT BY ATOM WITHIN EACH ORMAS GROUP.
C         NOTE:  SVD VALUE ORDER IS DESTROYED WITHIN GROUP,ATOM.
      CALL VICLR(IORDBIG,1,NACTBS*NAT)
      CALL VICLR(IORDBIG2,1,NACTBS*NAT)
      CALL ICOPY(NACTTMP,IATLAB,1,IORDBIG2,1)
      DO ISPACE=1,NSPACE
        IF(KEEPER) THEN
          JORB1=MSTA(ISPACE)
          JORB2=MSTA(ISPACE+1)-1
          IF(JORB2.EQ.L0) JORB2=L0+(NACTTMP-NACT)
          JORB1=JORB1-MSTA(1)+1
          JORB2=JORB2-MSTA(1)+1
        ELSE
          JORB1=1
          JORB2=NACTTMP
        ENDIF
        NERR=0
        DO I=JORB2,JORB1,-1
          IF(IGRPLAB(I).NE.ISPACE) NERR=NERR+1
          CALL LOCAL_INTMAX(IDUM,IORDBIG2,ICT_ORB,JORB1,JORB2)
          IORDBIG2(IDUM)=0
          IORDBIG(I)=IDUM
        ENDDO
        IF(NERR.NE.0) THEN
          IF(MASWRK) WRITE(IW,9059)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
      ENDDO
      CALL LOCAL_SORT_SVDEIG(
     *     NACT,NACTTMP,
     *     NACTBS,NAT,EIGSAV,VTVECSAV,
     *     IORDBIG,IORDBIG2,IGRPLAB,IATLAB)
C
C     8.  AMONG NACTTMP ORBITALS,
C         RESORT WITHIN GROUP,ATOM BY SVD VALUE SIZE.
C         NOTE:  AT THIS POINT, THE GROUP,ATOM STUFF IS CONTIGUOUS
C                DO NOT CHANGE THE PREVIOUS SORTS WITHOUT CHECKING.
      CALL VICLR(IORDBIG,1,NACTBS*NAT)
      IPOS=1
      DO 500 I=1,NACTTMP
        IF(IPOS.GT.NACTTMP) GO TO 501
        ITMP=IGRPLAB(IPOS)
        IATM1=IATLAB(IPOS)
        DO 510 JPOS=IPOS+1,NACTTMP
          IF(IGRPLAB(JPOS).NE.ITMP
     *       .OR.
     *       IATLAB(JPOS).NE.IATM1) GO TO 511
  510   CONTINUE
  511   CONTINUE
        JPOS=JPOS-1
        ITMP=JPOS-IPOS+1
        DO J=1,ITMP
          IORDBIG(IPOS+J-1)=JPOS-J+1
        ENDDO
        IPOS=IPOS+ITMP
  500 CONTINUE
  501 CONTINUE
      CALL LOCAL_SORT_SVDEIG(
     *     NACT,NACTTMP,
     *     NACTBS,NAT,EIGSAV,VTVECSAV,
     *     IORDBIG,IORDBIG2,IGRPLAB,IATLAB)
C
C------------------------------------------------------------
C------------------------------------------------------------
C     END OF SORTING PASSAGE TO OBTAIN ORBITALS.
C------------------------------------------------------------
C------------------------------------------------------------
C
C
C------------------------------------------------------------
C------------------------------------------------------------
C     SAVE NONORTHOG. INFO.
C------------------------------------------------------------
C------------------------------------------------------------
C
      L0BS=L0+NACTBS-NACT
      CALL DAREAD(IDAF,IODA,VSAV,L3,523,0)
      DO I=1,NACTBS
        CALL DCOPY(NACT,VTVECSAV(1,I),1,
     *                  VSAV(NCORTOT+1,NCORTOT+I),1)
      ENDDO
      DO I=NCORTOT+NACTBS+1,L0BS
        VSAV(I,I)=1.0D+00
      ENDDO
      IF(KEEPER) THEN
        CALL LOCAL_BLOCK_ORMAS(
     *       L1,NSPACE,MSTA,VSAV,
     *       MASWRK,IW)
      ENDIF
C
C     SAVE SOME INFORMATION NOW
      CALL VCLR(VTMP,1,L3)
      CALL MRARBR(VOLD,L1,L1,L0,VSAV,L1,L0BS,VTMP,L1)
      CALL DAWRIT(IDAF,IODA,VTMP,L3,539,0)
      CALL VICLR(IWRK,1,L3) ! increased for this routine.
      CALL DCOPY(NACTBS,IATLAB,1,IWRK,1)
      CALL DAWRIT(IDAF,IODA,IWRK,L1,540,1)
C
C     SAVE OTHER INFORMATION NOW
      CALL DAWRIT(IDAF,IODA,VTMP,L3,522,0)
      CALL DAWRIT(IDAF,IODA,VSAV,L3,523,0)
C
C------------------------------------------------------------
C------------------------------------------------------------
C     END OF SAVE NONORTHOG. INFO.
C------------------------------------------------------------
C------------------------------------------------------------
C
C------------------------------------------------------------
C------------------------------------------------------------
CLINDEP      LINEAR DEPENDENCE PASSAGE TO OBTAIN ORBITALS.
C------------------------------------------------------------
C------------------------------------------------------------
C     SHRINK ORBITAL TRANSFORMATION:  PART 1
C     ---INITIALIZE IEXTORBF.
C     ---ENTER FOR NACTBS DIFFERENT THAN NACT.
      IF(NCORTOT+NACT.EQ.L0) THEN
        IEXTORBF=L0-L0MBS
      ELSE
        IEXTORBF=0
      ENDIF
      IF(NACTBS.EQ.NACT) GO TO 911
C
C     SHRINK ORBITAL TRANSFORMATION:  PART 2
C     ---COPY OUT THE EXTERNAL ORBITALS ONLY.
C     ---COPY OUT SVD VALUES FOR THE EXTERNAL ORBITALS.
      CALL DAREAD(IDAF,IODA,VTMP,L3,522,0)
      CALL VCLR(VTVEC,1,L3)
      CALL VCLR(EIGTMP,1,NACTBS*NAT)
      IEXTORB=0
      DO 555 I=1,L0BS-NCORTOT
        IF(IGRPLAB(I).NE.NSPACE) GO TO 555
        IEXTORB=IEXTORB+1
C     -----------------------TRICKY TRICKY SAID THE INDEXY.
        CALL DCOPY(L1,VTMP(1,NCORTOT+I),1,VTVEC(1,IEXTORB),1)
        EIGTMP(IEXTORB)=EIGSAV(I)
  555 CONTINUE
C
C     SHRINK ORBITAL TRANSFORMATION:  PART 3
C     ---PERFORM KR'S CRITERION WITH THE DISJUNCT SUMMATION.
C     ---IF CRITERION FAILS, ALSO PERFORM REMOVAL OF SMALL SVD EVALUES.
      CALL VCLR(VTMP,1,L3)
      CALL VICLR(IORDBIG,1,NACTBS*NAT)
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      IEXTORBF=0
      CALL LOCAL_CLINDEP(
     *     IEXTORB,IEXTORBF,NAOTOT,L0MBS,L0,L1,L2,L3,
     *     VTVEC,EIGTMP,TOL,
     *     S,S2,VTMP,WRKSVD,EIG,IWRK(1,1),IWRK(1,2),
     *     SOME,MASWRK,IW)
C
C     SHRINK ORBITAL TRANSFORMATION:  PART 4
C     ---PREPARE FOR CLINDEP REORDERING.
C        I.E. SETUP EVERYTHING IN TERMS OF NACTBS.
      ITMP=L0MBS-NCORTOT
      CALL VCLR(UVEC,1,L3)
      CALL DCOPY(L1*(NAOTOT-L0MBS),VTVEC,1,UVEC(1,ITMP+1),1)
      CALL DCOPY(L3,UVEC,1,VTVEC,1)
      CALL DAREAD(IDAF,IODA,UVEC,L3,539,0)
      CALL DCOPY(L1*ITMP,UVEC(1,NCORTOT+1),1,VTVEC,1)
      CALL VCLR(VTMP,1,L3)
      CALL DCOPY(L1*NACTBS,UVEC(1,NCORTOT+1),1,VTMP,1)
C
C     SHRINK ORBITAL TRANSFORMATION:  PART 5
C     ---PERFORM CLINDEP REORDERING.
      IDUM=0
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL OVLSEL(VTMP,EIG,VTVEC,S,
     *            UVEC,IORDBIG,WRKSVD,IORDBIG,
     *            IDUM,IDUM,L0,L1,L2,.FALSE.,NACTBS)
      CALL VCLR(VTMP,1,L3)
      CALL VCLR(VTVEC,1,L3)
      CALL LOCAL_SORT_SVDEIG(
     *     NACT,NACTBS,
     *     NACTBS,NAT,EIGSAV,VTVECSAV,
     *     IORDBIG,IORDBIG2,IGRPLAB,IATLAB)
C
C------------------------------------------------------------
C------------------------------------------------------------
CLINDEP       END OF LINEAR DEPENDENCE PASSAGE TO OBTAIN ORBITALS.
C------------------------------------------------------------
C------------------------------------------------------------
C
C
C     FORM NONORTHOG. TRANSFORM AND ORBITALS.
C     --SET UP THE NACTDEP VAR.
C     --GET AT NONORTHOG. TRANSFORM AS IT IS CURRENTLY ORDERED.
C     --CHECK ORMAS BLOCK-DIAGONAL FORM.
  911 CONTINUE
CLINDEP       NACTDEP VAR.
      NACTDEP=L0MBS-NCORTOT+IEXTORBF
CLINDEP     L0DEP
      IF(NCORTOT+NACT.EQ.L0) THEN
        L0DEP=NCORTOT+NACTDEP
      ELSE
        L0DEP=L0
      ENDIF
C
      IF(KEEPER.AND.SOME) WRITE(IW,9060)
      CALL DAREAD(IDAF,IODA,VSAV,L3,523,0)
      DO I=1,NACTDEP
C     -----------------------TRICKY TRICKY SAID THE INDEXY.
        CALL DCOPY(NACT,VTVECSAV(1,I),1,
     *                  VSAV(NCORTOT+1,NCORTOT+I),1)
      ENDDO
      DO I=NCORTOT+NACTDEP+1,L0DEP
        VSAV(I,I)=1.0D+00
      ENDDO
      IF(KEEPER) THEN
        CALL LOCAL_BLOCK_ORMAS(
     *       L1,NSPACE,MSTA,VSAV,
     *       MASWRK,IW)
      ENDIF
      CALL DAWRIT(IDAF,IODA,VSAV,L3,523,0)
      CALL VCLR(VTMP,1,L3)
C     -----------------------TRICKY TRICKY SAID THE INDEXY.
      CALL MRARBR(VOLD,L1,L1,L0,VSAV,L1,L0DEP,VTMP,L1)
      CALL DAWRIT(IDAF,IODA,VTMP,L3,522,0)
C
C     PERFORM SYMMETRIC ORTHOGONALIZATION
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL DAREAD(IDAF,IODA,VTMP,L3,522,0)
      CALL VCLR(S2,1,L2)
      CALL TFTRI(S2,S,VTMP(1,NCORTOT+1),WRKSVD,NACTDEP,L1,L1)
      IERR2=0
      CALL VCLR(VTMP,1,L3)
      CALL GLDIAG(L1,NACTDEP,NACTDEP,S2,WRKSVD,EIG,VTMP,IERR2,IWRK)
      IF(IERR2.GT.0) GO TO 8999
      IERR3=0
      DO I=1,NACTDEP
        IF(EIG(I).LT.TOL) IERR3=IERR3+1
        EIG(I)=ONE/SQRT(EIG(I))
      ENDDO
      IF(IERR3.GT.0) GO TO 8999
      CALL VCLR(SV,1,L3)
      DO I=1,NACTDEP
        DO J=1,NACTDEP
          SV(I,J)=VTMP(J,I)
        ENDDO
      ENDDO
      DO I=1,NACTDEP
        CALL DSCAL(NACTDEP,EIG(I),VTMP(1,I),1)
      ENDDO
      CALL VCLR(SAOMO,1,L3)
      CALL MRARBR(VTMP,L1,NACTDEP,NACTDEP,SV,L1,NACTDEP,SAOMO,L1)
      CALL DCOPY(L3,SAOMO,1,VTMP,1)
C
C     FORM ORTHOGONAL TRANSFORM AND ORBITALS.
      CALL DAREAD(IDAF,IODA,VSAV,L3,524,0)
      DO I=1,NACTDEP
C     -----------------------TRICKY TRICKY SAID THE INDEXY.
        CALL DCOPY(NACT,VTMP(1,I),1,
     *                  VSAV(NCORTOT+1,NCORTOT+I),1)
      ENDDO
      DO I=NCORTOT+NACTDEP+1,L0DEP
        VSAV(I,I)=1.0D+00
      ENDDO
      IF(KEEPER) THEN
        CALL LOCAL_BLOCK_ORMAS(
     *       L1,NSPACE,MSTA,VSAV,
     *       MASWRK,IW)
      ENDIF
      CALL DAWRIT(IDAF,IODA,VSAV,L3,524,0)
      CALL DAREAD(IDAF,IODA,SV,L3,522,0)
      CALL VCLR(VTMP,1,L3)
      CALL MRARBR(SV,L1,L1,L0,VSAV,L1,L0DEP,VTMP,L1)
      CALL DAWRIT(IDAF,IODA,VTMP,L3,521,0)
C
C     CONSTRUCT AND SAVE OVERALL TRANSFORM.
      CALL VCLR(SV,1,L3)
      CALL DAREAD(IDAF,IODA,VTMP,L3,523,0)
      CALL DAREAD(IDAF,IODA,VSAV,L3,524,0)
      CALL MRARBR(VTMP,L1,L0DEP,L0DEP,VSAV,L1,L0DEP,SV,L1)
      CALL DAWRIT(IDAF,IODA,SV,L3,525,0)
      IF(KEEPER) THEN
        CALL LOCAL_BLOCK_ORMAS(
     *       L1,NSPACE,MSTA,SV,
     *       MASWRK,IW)
      ENDIF
C
C     DETERMINE GOODNESS OF MO OVERLAP.
      IDUM=0
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL DAREAD(IDAF,IODA,SV,L3,522,0)
      CALL DAREAD(IDAF,IODA,VTMP,L3,521,0)
      CALL OVLSEL(VTMP,EIG,SV,S,
     *            UVEC,IWRK,WRKSVD,IWRK,
     *            IDUM,IDUM,L0,L1,L2,.FALSE.,L0DEP)
C     REORDER THE NONORTHOGONAL ORBITAL OVERLAPS.
      CALL REORDR(UVEC,IWRK,L0DEP,L1)
C     NEVER TAKE THE REORDERED ORTHOGONAL ORBITALS.
      CALL VCLR(VTMP,1,L3)
C     PRINT OFF THE ABS. VALUE OF THE DIAGONAL OVERLAPS.
      IF(SOME) THEN
        WRITE(IW,9830)
        DO I=1,NCORTOT+NACTDEP
          TMP=ABS(UVEC(I,I))
          WRITE(IW,9831) I,TMP
        ENDDO
      ENDIF
C
C     ENSURE THAT ORBITALS ARE ORTHONORMAL NOW.
      CALL DAREAD(IDAF,IODA,VTMP,L3,521,0)
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL LOCAL_CHECK_ORTHOG(
     *     L0DEP,L1,L2,
     *     S2,S,VTMP,WRKSVD,
     *     MASWRK,IW)
C
C------------------------------------------------------------
C------------------------------------------------------------
C     FINAL RESET OF ATOMIC-BASED INDEXING FOR TRUTH.
C------------------------------------------------------------
C------------------------------------------------------------
      CALL VICLR(IATMSTA2,1,NSPACE*NAT)
      CALL VICLR(NATMOR,1,L0)
      IF(.NOT.KEEPER_ISVMOR) THEN
C       NO USER INPUTS.
        CALL VICLR(IATMSTA,1,NSPACE*NAT)
        CALL VICLR(ISVMOR,1,NAT)
        DO I=1,NACTDEP
          IATM1=IATLAB(I)
          ISPACE=IGRPLAB(I)
          IATMSTA(ISPACE,IATM1)=IATMSTA(ISPACE,IATM1)+1
          ISVMOR(IATM1)=ISVMOR(IATM1)+1
          NATMOR(NCORTOT+I)=IATM1
        ENDDO
      ELSE
C       PRESERVE USER INPUTS.
        DO I=1,NACTDEP
          IATM1=IATLAB(I)
          NATMOR(NCORTOT+I)=IATM1
        ENDDO
      ENDIF
C------------------------------------------------------------
C------------------------------------------------------------
C     END OF FINAL RESET OF ATOMIC-BASED INDEXING FOR TRUTH.
C------------------------------------------------------------
C------------------------------------------------------------
C
C
C------------------------------------------------------------
C------------------------------------------------------------
C     NICE ERROR CHECKING SECTION.
C------------------------------------------------------------
C------------------------------------------------------------
C
C     RECHECK THAT ISVMOR HAS NACT LENGTH.
      ITMP=0
      DO I=1,NAT
        ITMP = ITMP + ISVMOR(I)
      ENDDO
      IERR5=0
      IF(ITMP.NE.NACTDEP) IERR5=1
      IF(IERR5.GT.0) GO TO 8999
C
C     RECHECK ISVMOR THROUGH LOCAL_NUMVAL INTEGER FUNCTION.
      IERR9=0
      IF(SCFTYP.EQ.RMC) THEN
        ITMP=0
        DO I=1,NAT
          NUMVAL1=LOCAL_NUMVAL(I,0)
          ITMP=ITMP+NUMVAL1
        ENDDO
        IERR5=0
        IF(ITMP.NE.NACTDEP) IERR5=1
        IF(IERR5.GT.0) GO TO 8999
      ELSEIF(SCFTYP.EQ.RHF.OR.SCFTYP.EQ.ROHF) THEN
C       NO CHECK HERE.
C       IF CHECK IS DESIRED, ADD NEW ARGUMENTS TO LOCAL_NUMVAL.
      ELSE
        IERR9=1
        GO TO 8999
      ENDIF
C
C     CHECK THAT ISVMOR AND NATMOR 'JIVE'.
      IF(KEEPER) THEN
        IERR6=0
        DO J=1,NAT
          ITMP=0
          DO I=NCORTOT+1,NCORTOT+NACTDEP
            IF(NATMOR(I).EQ.J) ITMP=ITMP+1
          ENDDO
          IF(ITMP.NE.ISVMOR(J)) IERR6=IERR6+1
        ENDDO
        IF(IERR6.GT.0) GO TO 8999
      ENDIF
C
C     CHECK THAT ALL ENTRIES IN ISVMOR ARE GREATER THAN 0.
      IERR7=0
      DO J=1,NAT
        IF(ISVMOR(J).LE.0) IERR7=IERR7+1
      ENDDO
      IF(IERR7.GT.0) GO TO 8999
C
C
C------------------------------------------------------------
C------------------------------------------------------------
C     END OF NICE ERROR CHECKING SECTION.
C------------------------------------------------------------
C------------------------------------------------------------
C
C
C------------------------------------------------------------
C------------------------------------------------------------
C     FINAL PRINT SECTION FOR TRUTH.
C------------------------------------------------------------
C------------------------------------------------------------
C
C     PRINT FINAL ORGANIZATION OF SVD VALUES.
      IF(SOME) THEN
        WRITE(IW,9810)
        DO I=1,NACTDEP
          WRITE(IW,9820) I,IGRPLAB(I),IATLAB(I),EIGSAV(I)
        ENDDO
      ENDIF
C
C     PRINT OFF NEW ORBITAL NUMBERS ON EACH ATOM.
      IF(SOME) THEN
        WRITE(IW,9054)
        DO IATM1=1,NAT
          WRITE(IW,9056) IATM1,ISVMOR(IATM1)
        ENDDO
      ENDIF
C------------------------------------------------------------
C------------------------------------------------------------
C     END OF FINAL PRINT SECTION FOR TRUTH.
C------------------------------------------------------------
C------------------------------------------------------------
C
C
C------------------------------------------------------------
C------------------------------------------------------------
C     PRINT OFF ORBITAL SETS LAST.
C------------------------------------------------------------
C------------------------------------------------------------
C     PRINT NONOROTHOG. ORBITALS INTO .LOG FILE.
      CALL DAREAD(IDAF,IODA,VTMP,L3,522,0)
      IF(SOME) THEN
        WRITE(IW,9069)
        WRITE(IW,9071) NCORTOT+NACTDEP
        CALL PRSQL(VTMP,NCORTOT+NACTDEP,L1,L1)
      ENDIF
C     PRINT ORTHOG. ORBITALS INTO .LOG FILE.
      CALL DAREAD(IDAF,IODA,VTMP,L3,521,0)
      IF(SOME) THEN
        WRITE(IW,9070)
        WRITE(IW,9071) NCORTOT+NACTDEP
        CALL PRSQL(VTMP,NCORTOT+NACTDEP,L1,L1)
      ENDIF
C     PRINT ORTHOG. ORBITALS INTO .DAT FILE.
      IF(MASWRK) THEN
        WRITE(IP,9080)
        CALL PUSQL(VTMP,NCORTOT+NACTDEP,L1,L1)
        WRITE(IP,9085)
      ENDIF
C------------------------------------------------------------
C------------------------------------------------------------
C     END OF PRINT OFF ORBITAL SETS LAST.
C------------------------------------------------------------
C------------------------------------------------------------
C
C     SAVE THE ALL-MIGHTY L0DEP0.
      L0DEP0=L0DEP
C
C
C
C
C     PERFORM FINAL ERROR OUTS.
 8999 CONTINUE
      IF(MASWRK) THEN
        IF(IERR0.GT.0) THEN
          WRITE(IW,9001)
        ELSEIF(IERR2.GT.0) THEN
          WRITE(IW,9003)
        ELSEIF(IERR3.GT.0) THEN
          WRITE(IW,9004) IERR3
        ELSEIF(IERR4.GT.0) THEN
          WRITE(IW,9005)
        ELSEIF(IERR5.GT.0) THEN
          WRITE(IW,9006)
        ELSEIF(IERR6.GT.0) THEN
          WRITE(IW,9007)
        ELSEIF(IERR7.GT.0) THEN
          WRITE(IW,9008)
        ELSEIF(IERR8.GT.0) THEN
          WRITE(IW,9009)
        ELSEIF(IERR9.GT.0) THEN
          WRITE(IW,9010)
        ELSEIF(IERR10.GT.0) THEN
          WRITE(IW,9011)
        ELSEIF(IERR11.GT.0) THEN
          WRITE(IW,9012)
        ENDIF
      ENDIF
      IF(IERR0.GT.0
     *  .OR.IERR2.GT.0
     *  .OR.IERR3.GT.0
     *  .OR.IERR4.GT.0
     *  .OR.IERR5.GT.0
     *  .OR.IERR6.GT.0
     *  .OR.IERR7.GT.0
     *  .OR.IERR8.GT.0
     *  .OR.IERR9.GT.0
     *  .OR.IERR10.GT.0
     *  .OR.IERR11.GT.0
     *  ) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9000 FORMAT(1X,'LAST IATMSTA CHECK IS DONE.')
 9001 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'SOME ISSUE WITH IATMSTA ARRAY VALUES.  FIX IT.')
 9003 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'ERROR OCCURS FOR GLDIAG CALL.')
 9004 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'IN SYMMETRIC ORTHOG., ',
     *       1X,I4,' EIGENVALUES ARE BELOW TOL.',
     *       1X,I4,' IF USING SVDEXTOPT OPTION,.',
     *       1X,I4,' PROBLEM MIGHT BE RELATED WITH QMTTOL.')
 9005 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'ERROR OCCURS FOR SOME ORBITAL TRANSFORM',
     *       1X,'IN ORMAS INTER-SUBSPACE BLOCKS.')
 9006 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'
     *       /1X,'ISVMOR WAS RESET AND NO LONGER EQUALS NACT.',
     *       /1X,'CHECK IF MOS WERE DROPPED FOR LINEAR DEPENDENCE..')
 9007 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'ISVMOR AND NATMOR DO NOT AGREE.')
 9008 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'ISVMOR HAS VALUES LESS THAN 1.',
     *      /1X,'YOU MIGHT WANT TO CHECK OUT THE SVD EVALUES,',
     *       1X,'AND USE THE NATMOR OR ISVMOR ARRAYS FOR INPUT.')
 9009 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'JJ DOES NOT EQUAL ITLH2.')
 9010 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'PLEASE CODE IN LOCAL_NUMVAL CHECK FOR',
     *       1X,'A NEW SCFTYP OPTION.')
 9011 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'LENGTHS FROM LOCAL_COUNTAOS VS. LIMLOW AND LIMSUP',
     *       1X,'DO MATCH UP.')
 9012 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'SVD EVALUES CANNOT BE LESS THAN OR EQUAL TO ZERO.',
     *       1X,'ALSO, THEN IDAMAX SORTING DOES NOT WORK.')
 9038 FORMAT(/1X,'---CHECKING SVD--- AAMBS ARE USED FOR GROUP=',I4)
 9039 FORMAT(/1X,'---CHECKING SVD--- ORTHOGONALIZED SV',
     *       1X,'IS USED FOR GROUP=',I4)
 9040 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *      /1X,'ISVDOP=10 IS NOT SACTIONED FOR USE OF',
     *       1X,' NSPACE>2 AND MORE THAN MBS ORBITALS.',
     *      /1X,'YOU ARE LOST.  TURN BACK NOW.')
 9045 FORMAT(/1X,'SVD EIGENVALUES NOW FOLLOW FOR ATOM NUMBER=',I4)
 9050 FORMAT(1X,'GROUP=',I4,
     *       5X,'ACTIVE ORBITAL=',I4,5X,'SVD EIGENVALUE=',F12.7)
 9052 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *      /1X,'ICT_ORB EXCEEDS ALLOWED MEMORY.')
 9054 FORMAT(/1X,'FINAL ATOM NUMBERS:')
 9056 FORMAT( 1X,'ATOM =',I4,5X,'ACTIVE ORBITALS NUMBER=',I4)
 9058 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *      /1X,'IN GROUP LABELS SORTING,',
     *       1X,'NACT ORBITALS ARE NOT OBTAINED.')
 9059 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *      /1X,'IN ATOM LABELS SORTING,',
     *       1X,'IGRPLAB DOES NOT MAKE ANY SENSE.')
 9060 FORMAT(/1X,'LOCAL_PPASVD KEEPS ORBITALS WITHIN',
     *        1X,'ORMAS SUBSPACES.')
 9069 FORMAT(//10X,'NONORTHOGONAL PPA SVD LOCALIZED ORBITALS')
 9070 FORMAT(//10X,'PPA SVD LOCALIZED ORBITALS')
 9071 FORMAT(10X,I5,1X,'ORBITALS ARE LOCALIZED BY',
     *        1X,'SINGULAR VALUE DECOMPOSITION',
     *      /16X,'INTO PURE PROJECTED ATOMIC ORBITALS.')
 9080 FORMAT('PPA SVD LOCALIZED ORBITALS'/' $VEC')
 9085 FORMAT(' $END')
 9800 FORMAT(//1X,'DEALING WITH QMTTOL ISSUES FOR SVD.')
 9805 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *      /1X,'SVDEXTOPT HAS ISSUES WITH REORDERING ARRAY.')
 9810 FORMAT(/1X,'FINAL SVD ORDERING SCHEME:')
 9820 FORMAT(1X,'COUNT,ORMAS GROUP,ATOM,SVD VALUE=',
     *       1X,5X,I4,2X,I4,2X,I4,2X,F12.7)
 9830 FORMAT(/1X,'MO OVERLAP COMPARISON:',
     *       /1X,'COMPARE NONORTHOGONAL AND ORTHOGONAL ORBITAL',
     *        1X,'OVERLAPS')
 9831 FORMAT(1X,'ORBITAL,MO OVERLAP=',I4,F12.7)
      END
C*MODULE LOCAL   *DECK LOCAL_SETUP_PPADEN
C> @brief      Sets up SVD densities for different runs.
C>
C> @author     Aaron West
C>             -July 13, 2013
C>
C> @details    The set up depends on many options:
C>             VVOs,orbital swappings,scftyp,extloc,etc.
C>
C> @date October 18, 2013-Aaron West
C> -Reset some density sizes.
C>  Checked all other parts of log files by script.
C>  Checked density matrices for examples by hand.
C>
C> @param IORBF1        denotes the initial orbital file.
C> @param SCFTYP        denotes RHF,RMC,ROHF,etc.
C> @param SCFTYP_TRUTH  denotes the initial SCFTYP setting.
C> @param EXTLOC        defines the external orbital procedure (if any).
C> @param SWITCH_ORBS   indicates if the VVOs orbital group was moved.
C> @param NSKIP         denotes the number of valence doubly occupieds.
C> @param NSKIP2        denotes the number of orbitals to skip over
C>                      (if any) when the VVOs were shifted.
C> @param NSKIP_SING    denotes the number of singly occupied orbitals
C>                      (if any).
C> @param NACT          denotes the number of localized valence orbitals.
C>                      This variable controls resultant file sizes
C>                      for different kinds of runs.
C> @param NACTSV        is often the total number of MCSCF active orbitals
C>                      before VVOS dimensional changes.
C> @param NCORTOT       denotes the total number of chemical core orbitals.
C> @param NA            denotes the core+valence occupieds for some runs.
C>                      e.g. RHF,ROHF
C> @param NB            denotes the total core+valence doubly occupieds.
C> @param IMBS          is the total number of MBS valence orbitals.
C> @param L1            is the total number of AOs for the molecule.
C> @param IDENFIL       indicates the DAF file that holds the density.
C> @param IDENSIZ       indicates the size of the file read.
C> @param SOME          is true for master process with nprint not equal -5.
C> @param MASWRK        indicates the master process.
C> @param IW            indicates write out to the log file.
      SUBROUTINE LOCAL_SETUP_PPADEN(
     *           IORBF1,SCFTYP,SCFTYP_TRUTH,EXTLOC,SWITCH_ORBS,
     *           NSKIP,NSKIP2,NSKIP_SING,NACT,NACTSV,
     *           NCORTOT,NA,NB,IMBS,L1,IDENFIL,IDENSIZ,
     *           SOME,MASWRK,IW)
      IMPLICIT NONE
      LOGICAL SOME,MASWRK,SWITCH_ORBS
      DOUBLE PRECISION :: SCFTYP,SCFTYP_TRUTH,EXTLOC
      INTEGER IORBF1,NSKIP,NSKIP2,NSKIP_SING,NACT,NACTSV,
     *        NCORTOT,NA,NB,IMBS,L1,
     *        IW
C
      DOUBLE PRECISION :: RHF,RMC,ROHF,RNONE,SVD
      INTEGER IDENFIL,IDENSIZ,NACTSV2,ITMP,ITMP2
C
C     DATA STUFF
      DATA RHF/8HRHF     /
      DATA RMC/8HMCSCF   /
      DATA ROHF/8HROHF    /
      DATA RNONE/8HNONE    /
      DATA SVD/8HSVD     /
C
C     INITIALIZE IDENSIZ AND IDENFIL
      IDENFIL=0
      IDENSIZ=0
C
C     ALL EXTLOC RUNS FAKED OUT TO BE SVD RUNS.
      IF(EXTLOC.NE.RNONE.AND.EXTLOC.NE.SVD) THEN
        IF(MASWRK) WRITE(IW,9001)
        CALL FLSHBF(IW)
        CALL ABRT
      ENDIF
C
C     LONG PASSAGE TO SET UP DENSITY,ETC, FOR DIFFERENT KIND OF RUNS.
      IF(SCFTYP.EQ.RMC.AND.EXTLOC.EQ.RNONE) THEN
C       DO NOTHING FOR NSKIP STUFF.
        IF(IORBF1.EQ.15) THEN
          IF(SOME) WRITE(IW,9010)
C         ALWAYS PUT FILE DEFS LAST.
          IDENFIL=320
          NACTSV2=(NACTSV*NACTSV+NACTSV)/2
          IDENSIZ=NACTSV2
        ELSEIF(IORBF1.EQ.19) THEN
          IF(SOME) WRITE(IW,9020)
C         ALWAYS PUT FILE DEFS LAST.
          IDENFIL=19
          IDENSIZ=L1
        ELSE
          IF(MASWRK) WRITE(IW,9030)
          IF(MASWRK) WRITE(IW,9500)
          CALL FLSHBF(IW)
          CALL ABRT
        ENDIF
      ELSEIF(SCFTYP.EQ.RHF.AND.EXTLOC.EQ.RNONE.AND.IORBF1.EQ.15) THEN
        IF(SOME) WRITE(IW,9040)
C       WORKS FOR RHF AND ISVDOP=0.
        NSKIP =NA-NCORTOT
        NSKIP2=0
        NACT=IMBS
      ELSEIF(SCFTYP.EQ.RHF.AND.EXTLOC.NE.RNONE.AND.IORBF1.EQ.15) THEN
        IF(SCFTYP_TRUTH.EQ.RHF) THEN
          IF(SOME) WRITE(IW,9040)
          NSKIP=NA-NCORTOT
          NSKIP2=0
          NACT=IMBS
        ELSEIF(SCFTYP_TRUTH.EQ.RMC) THEN
          IF(SOME) WRITE(IW,9050)
          CALL LOCAL_SVDVVOS_RMC_SETUP1(ITMP,ITMP2)
          NSKIP=ITMP-NCORTOT
          NACTSV=ITMP2
          NSKIP2=0
C         ALWAYS PUT FILE DEFS LAST.
          IDENFIL=320
          NACTSV2=(NACTSV*NACTSV+NACTSV)/2
          IDENSIZ=NACTSV2
        ELSE
          IF(MASWRK) WRITE(IW,9500)
          CALL FLSHBF(IW)
          CALL ABRT
        ENDIF
      ELSEIF(SCFTYP.EQ.ROHF.AND.EXTLOC.EQ.RNONE.AND.IORBF1.EQ.15) THEN
        IF(SOME) WRITE(IW,9060)
        NSKIP=NB-NCORTOT
        NSKIP2 =IMBS-(NA-NCORTOT)
        NSKIP_SING=IMBS-NSKIP-NSKIP2
        NACT=IMBS
      ELSEIF(SCFTYP.EQ.ROHF.AND.EXTLOC.NE.RNONE.AND.IORBF1.EQ.15) THEN
        IF(SOME) WRITE(IW,9060)
        NSKIP=NB-NCORTOT
        NSKIP2 =IMBS-(NA-NCORTOT)
        NSKIP_SING=IMBS-NSKIP-NSKIP2
        NACT=IMBS
      ELSE
        IF(MASWRK) WRITE(IW,9500)
        CALL FLSHBF(IW)
        CALL ABRT
      ENDIF
C     END OF LONG PASSAGE TO SET UP DENSITY FOR DIFFERENT KINDS OF RUNS.
C
C
C
C     ERROR OUT FOR SWITCH_ORBS
C     --IF SWITCH_ORBS IS TRUE,
C       THE THE VVOS ORBITALS WERE RE-POSITIONED.
      IF(SWITCH_ORBS.AND.NSKIP2.EQ.0) THEN
        IF(MASWRK) WRITE(IW,9200)
        CALL FLSHBF(IW)
        CALL ABRT
      ENDIF
      IF(.NOT.SWITCH_ORBS.AND.NSKIP2.NE.0) THEN
        IF(MASWRK) WRITE(IW,9210)
        CALL FLSHBF(IW)
        CALL ABRT
      ENDIF
C
      RETURN
 9001 FORMAT(/1X,'LOCAL_SETUP_PPADEN ERROR:',
     *       /1X,'RE-WORK EXTLOC FOR NO FAKING SVD...')
 9010 FORMAT(/1X,'LOCAL_SETUP_PPADEN:  STARTING WITH CANONICAL ORBITAL',
     *        1X,'DENSITY FROM DAF FILE 320.')
 9020 FORMAT(/1X,'LOCAL_SETUP_PPADEN:  STARTING WITH NATURAL ORBITAL',
     *        1X,'DENSITY FROM DAF FILE 21.')
 9030 FORMAT(/1X,'LOCAL_SETUP_PPADEN:  IORBF1 ORBITAL CHOICE HAS NO',
     *        1X,'DENSITY FILE PROGRAMED.  PLEASE ADD ONE.')
 9040 FORMAT(/1X,'LOCAL_SETUP_PPADEN:  STARTING WITH RHF DENSITY.')
 9050 FORMAT(/1X,'LOCAL_SETUP_PPADEN:',
     *       /1X,'THIS RHF EXTLOC RUN STARTED WITH MCSCF.',
     *       /1X,'SO, A DENSITY MATRIX MUST BE PICKED UP.')
 9060 FORMAT(/1X,'LOCAL_SETUP_PPADEN:  STARTING WITH ROHF DENSITY.')
 9200 FORMAT(/1X,'LOCAL_SETUP_PPADEN ERROR:',
     *       /1X,'THIS RUN MOVED THE VVOS ORBITAL GROUP.',
     *        1X,'HOWEVER, NSKIP2 EQUALS 0.',
     *       /1X,'THIS COMBINATION IS PROBABLY NOT POSSIBLE.')
 9210 FORMAT(/1X,'LOCAL_SETUP_PPADEN ERROR:',
     *       /1X,'THIS RUN DID NOT MOVE THE VVOS ORBITAL GROUP.',
     *        1X,'HOWEVER, NSKIP2 IS GREATER THAN 0.',
     *       /1X,'THIS COMBINATION IS PROBABLY NOT POSSIBLE.')
 9500 FORMAT(/1X,'LOCAL_SETUP_PPADEN ERROR:',
     *       /1X,'THIS OPTION DOES NOT EXIST IN THE CODE.')
      END
C*MODULE LOCAL   *DECK LOCAL_PPADEN
C> @brief      Routine forms density in orthogonal quasi-atomic MO basis.
C>
C> @author     Aaron West and Klaus Ruedenberg
C>             -November 4, 2012
C>
C> @details    The density of the canonical orbitals in daf dict. file 15
C>             is transformed over to the orthogonal quasi-atomic MO basis.
C>             Please also see MALMQ_DEN for any information
C>             on orbital re-ordering.
C>             Special note:
C>             NATMOR array must be correct to get out
C>             the right atomic valence orbital populations.
C>             I've finally nailed the automatic versus hand-select
C>             orbitals issue here.
C>             If you care, take a look at the bottom of
C>             local_ppaerr routine.
C>
C> @date January 19, 2013-Aaron West
C> -Re-worked for VVOS runs.
C>
C> @date July 13, 2013-Aaron West
C> -Re-worked with the addition of setup_ppaden.
C>  Also, made some simplifications after more experience.
C>
C> @param VTMP       holds the overall orthogonal
C>                   orbital transformation.
C> @param DEN        contains the original density in the
C>                   canonical MO basis.
C> @param DEN2       will hold the transformed density.
C> @param SCR        is workspace for the transformation.
C> @param IWRK       is integer scratch space.
C> @param NSKIP      indicates how many doubly occupieds to
C>                   skip over for VVOS run.
C> @param NSKIP2     indicates how many virtuals to re-assign to
C>                   active orbitals for VVOS run.
C> @param NSKIP_SING indicates how many singly occupieds. e.g. ROHF.
C> @param NCORTOT    is the total number of MCSCF core orbitals.
C>                   For VVOS run, it is adjusted.
C> @param NCORSV     is the total number of MCSCF core orbitals used
C>                   for initial mcscf calculation.
C> @param NACT       is the total number of MCSCF active oribtals.
C> @param NACTSV     is often the total number of MCSCF active orbitals
C>                   before VVOS dimensional changes.
C> @param L1         is the length of the AO coefficients.
C> @param L3         is the square of L1.
C> @param NAT        is the number of atoms.
C> @param SCFTYP     is wave function type from the common.
C> @param EXTLOC     defines the external orbital procedure (if any).
C> @param IVVOS      equals 1 indicates a VVOS run.
C>                   At this point, running VVOS orbitals through SVD.
C> @param IORBF1     indicates daf dict file with starting orbitals
C> @param IDENFIL    indicates the DAF file that holds the density.
C> @param IDENSIZ    indicates the size of the file read.
C>                   from which the localized orbitals are formed.
C> @param SOME       is true for master process with
C>                   nprint not equal -5.
C> @param MASWRK     indicates master process.
      SUBROUTINE LOCAL_PPADEN(
     *           VTMP,DEN,DEN2,SCR,IWRK,
     *           NSKIP,NSKIP2,NSKIP_SING,
     *           NCORTOT,NCORSV,NACT,NACTSV,L1,L3,
     *           NAT,SCFTYP,EXTLOC,
     *           IVVOS,IORBF1,IDENFIL,IDENSIZ,
     *           SOME,MASWRK)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL SOME,MASWRK
      DOUBLE PRECISION ::
     *       ONE,TWO,ATSUM,ATSUM2,TOLDEN,TMP,
     *       SCFTYP,EXTLOC,RMC,RNONE
      PARAMETER (ONE=1.0D+00,TWO=2.0D+00,TOLDEN=0.1D+00)
      INTEGER L1,L3,NCORTOT,NCORSV,
     *              NACT,NACT2,
     *              NACTSV,NACTSV2,NSKIP,NSKIP2,NSKIP_SING,
     *        IPOS,IJ,IJ2,I,J,I2,J2,IVVOS,IORBF1,NAT,
     *        IDENFIL,IDENSIZ
      INTEGER IWRK(L1)
C     NEW CODING STANDARDS VARS
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C----------------------------------------------------------------------
      DOUBLE PRECISION ::
     *       VTMP(L1,L1),DEN(L3),DEN2(L3),SCR(L3)
C----------------------------------------------------------------------
      DATA RMC/8HMCSCF   /
      DATA RNONE/8HNONE    /
C----------------------------------------------------------------------
C
C     DAF FILE  68 CONTAINS THE DENSITY IN THE CANONICAL MO BASIS.
C     DAF FILE 320 CONTAINS THE DENSITY IN THE CANONICAL MO BASIS
C                  OVER ACTIVE ORBITALS
C     DAF FILE  21 CONTAINS NO DENSITIES IN THE ACT BLOCK.
C
C     DEFINE SOME NEEDED DIMENSIONS.
      NACT2 = (NACT*NACT+NACT)/2
      NACTSV2=(NACTSV*NACTSV+NACTSV)/2
C
C     CLEAR OUT SOME ARRAYS
      CALL VCLR(DEN,1,L3)
      CALL VCLR(DEN2,1,L3)
      CALL VCLR(SCR,1,L3)
C
C     READ IN THE DENSITY
      IF(IDENSIZ.NE.0.AND.IDENFIL.NE.0) THEN
        CALL DAREAD(IDAF,IODA,DEN,IDENSIZ,IDENFIL,0)
      ENDIF
C
C     PERFORM ANY NON-VVOS EXTRA OPERATIONS TO REORDER DENSITY
      IF(SCFTYP.EQ.RMC.AND.IORBF1.EQ.19) THEN
        IF(SOME) WRITE(IW,9002)
        IF(IDENSIZ.EQ.0.OR.IDENFIL.EQ.0) THEN
          IF(MASWRK) WRITE(IW,9003)
          CALL FLSHBF(IW)
          CALL ABRT
        ENDIF
        CALL DCOPY(L1,DEN,1,SCR,1)
        CALL VCLR(DEN,1,L3)
        DO I=1,NACTSV
          SCR(I)=SCR(I+NCORSV)
        ENDDO
        DO I=1,NACTSV
          IJ=(I*I-I)/2 + I
          DEN(IJ)=SCR(I)
        ENDDO
      ENDIF
C
C     DEAL OUT ANY OCCUPATIONS FROM THE VVOS STUFF.
      IF(IVVOS.NE.0) THEN
        CALL VCLR(DEN2,1,L3)
        CALL DCOPY(NACTSV2,DEN,1,DEN2,1)
        CALL VCLR(DEN,1,L3)
        DO I=1,NSKIP
          IJ=(I*I-I)/2 + I
          DEN(IJ)=TWO
        ENDDO
C
        DO I=NSKIP+NSKIP2+1,NSKIP+NSKIP2+NSKIP_SING
          IJ=(I*I-I)/2 + I
          DEN(IJ)=ONE
        ENDDO
C
        IPOS=NSKIP+NSKIP_SING+NSKIP2
        DO I=1,NACTSV
          DO J=1,I
            IJ =(I*I-I)/2 + J
            I2=I+IPOS
            J2=J+IPOS
            IJ2=(I2*I2-I2)/2 + J2
            DEN(IJ2)=DEN2(IJ)
          ENDDO
        ENDDO
C
        IF(SCFTYP.EQ.RMC) THEN
          IF(SOME) WRITE(IW,9005)
        ENDIF
C
        IF(SOME) WRITE(IW,9006)
        CALL PRTRI(DEN,NACT)
      ENDIF
C
C     READ IN THE OVERALL ORTHOGONAL QUASI-ATOMIC ORBITAL TRANSFORMATION.
      CALL DAREAD(IDAF,IODA,VTMP,L3,525,0)
C
C     TRANSFORM THE DENSITY BY BLOCK-DIAGONAL TRANFORMATION:
C     NEW ORBS = ORIG ORBS * VTMP
C     NEW DENSITY = VTMP-TRANS * DEN * VTMP
C     --SAVE DENSITY MATRIX
C     ----FILE 526 FOR KEEPS
C     ----FILE 285 FOR ORIENTATION
      CALL TFTRI(DEN2,DEN,VTMP(NCORTOT+1,NCORTOT+1),SCR,
     *           NACT,NACT,L1)
      IF(EXTLOC.EQ.RNONE) THEN
        CALL DAWRIT(IDAF,IODA,DEN2,NACT2,526,0)
        CALL DAWRIT(IDAF,IODA,DEN2,NACT2,285,0)
      ELSE
        CALL DAWRIT(IDAF,IODA,DEN2,NACT2,536,0)
      ENDIF
C
C     PRINT OUT THE DENSITY.
      IF(SOME) WRITE(IW,9000)
      CALL PRTRI(DEN2,NACT)
C
C     GRAB ATOM-ORBITAL CORRESPONDENCE.
      CALL VCLR(IWRK,1,L1)
      CALL DAREAD(IDAF,IODA,IWRK,L1,528,1)
C
C     PRINT OUT ATOMIC POPULATIONS.
      DO J=1,NAT
        ATSUM =0.0D+00
        ATSUM2=0.0D+00
        DO I=1,NACT
          IF(IWRK(I).EQ.J) THEN
            IJ=(I*I-I)/2 + I
            TMP=DEN2(IJ)
            ATSUM=ATSUM+TMP
            IF(TMP.GT.TOLDEN) ATSUM2=ATSUM2+TMP
          ENDIF
        ENDDO
        IF(SOME) WRITE(IW,9020) J,ATSUM,TOLDEN,ATSUM2
      ENDDO
C
C     FINAL CHECK ON CORRECT DENSITY.
      IF(IVVOS.NE.0.AND.IORBF1.NE.15) THEN
        IF(MASWRK) WRITE(IW,9004)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9000 FORMAT(/1X,'DENSITY MATRIX IN THE',
     *        1X,'ORTHOGONAL QUASI-ATOMIC SVD MO BASIS',
     *       /1X,'OVER ACTIVE ORBITALS IS')
 9002 FORMAT(/1X,'LOCAL_PPADEN:  STARTING WITH NATURAL ORBITAL',
     *        1X,'DENSITY FROM DAF FILE 21.')
 9003 FORMAT(/1X,'LOCAL_PPADEN ERROR:',
     *       /1X,'DAF FILE 19 REQUIRES NON-ZERO VALUES FOR,'
     *        1X,'IDENFIL,IDENSIZE.')
 9004 FORMAT(/1X,'LOCAL_PPADEN:  YOUR DENSITY IS PROBABLY WRONG!',
     *       /1X,'VVOS WAS PROGRAMMED TO WORK WITH DAF FILE 15.',
     *        1X,'RE-RERUN OR RE-PROGRAM WITH FAO FOR NOS',
     *        1X,'AND REMOVE ERROR.')
 9005 FORMAT(/1X,'NOTE:  PREVIOUS PRINT OFF FOR DENSITY DOES NOT',
     *       /1X,'       MATCH HERE BECAUSE IT IS',
     *        1X,'NOT CANONICAL DENSITY.')
 9006 FORMAT(/1X,'DENSITY MATRIX FOR VVOS BEFORE ORTHORGONAL',
     *       /1X,'QUASI-ATOMIC SVD MO ORBITAL TRANSFORMATION.')
 9020 FORMAT(/1X,'ATOM',I5,3X,'SVD POPULATION=',F5.3,
     *        3X,'GREATER THAN ',F5.3,' CONTRIBUTIONS=',F5.3)
      END
C*MODULE LOCAL   *DECK LOCAL_KEEPER_SETUP
C> @brief      Set up variables for ilocal=4 runs.
C>
C> @author     Aaron West
C>             -January 12, 2013
C>
C> @date January 30, 2013-Aaron West
C> -Added ISVDOP to ORNTMO common block.
C> This run gives special option for SVD runs.
C>
C> @param KEEPER     is a logical and is true when
C>                   CISTEP=ORMAS + NSPACE>1 + ORMFUL=.FALSE.
C>                   SCFTYP=RHF
C> @param IMODE      resets part of the MSTA array.
C> @param L1         is the length of LCAO coefficients.
C> @param IGRP       is integer array of length L1.
C>
      SUBROUTINE LOCAL_KEEPER_SETUP(KEEPER,IMODE,L1,IGRP)
      IMPLICIT NONE
      LOGICAL KEEPER
      DOUBLE PRECISION :: ORMAS,RMC,RHF,ROHF
      INTEGER I,ISPACE,IMODE,L1,IGRP(L1)
      INTEGER NCORSV,NACTSV
C----------------------------------------------------------------
      INTEGER MXNORO
      PARAMETER (MXNORO=250)
      INTEGER MXAO,MXATM
      PARAMETER (MXAO=8192, MXATM=2000)
C----------------------------------------------------------------
      LOGICAL FDIRCT,QCORR
      INTEGER NSPACE,MSTA,MNUM,MINI,MAXI,IAMI,IAMA,IBMI,IBMA,IDIMFCC,
     *        LBST,NREF0
      DOUBLE PRECISION ::
     *       C0SQ
C
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
C
      LOGICAL CANONC,FCORE,FORS,EKT,LINSER
      DOUBLE PRECISION ::
     *       FINALCI,METHOD,CISTEP,ACURCY,ENGTOL,DAMP
      INTEGER MICIT,NWRDMC,NORBMC,NOROT,MOFRZ,
     *        NPFLG,NOFO,MCFMO,IDIABAT
C
      LOGICAL ORIENT,ORIKIN,ORMFUL
      INTEGER NATMOR,ISVMOR,ISVDOP,L0DEP0
      DOUBLE PRECISION :: EXTLOC,EREFATM,COUP_NT_VVO
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C----------------------------------------------------------------
C
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIMFCC(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWRDMC,NORBMC,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /ORNTMO/ EXTLOC,EREFATM,COUP_NT_VVO(MXATM),
     *                NATMOR(MXAO),ISVMOR(MXATM),ISVDOP,L0DEP0,
     *                ORIENT,ORIKIN,ORMFUL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C----------------------------------------------------------------
C
C     DATA STUFF
      DATA ORMAS/8HORMAS   /
      DATA RMC/8HMCSCF   /
      DATA RHF/8HRHF     /
      DATA ROHF/8HROHF    /
C
C     SETUP THE 'KEEPER' VAR
      IF(SCFTYP.EQ.RMC) THEN
        KEEPER=CISTEP.EQ.ORMAS.AND.NSPACE.GT.1.AND..NOT.ORMFUL
      ELSEIF(SCFTYP.EQ.RHF.OR.SCFTYP.EQ.ROHF) THEN
        KEEPER=.TRUE.
      ELSE
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     SETUP WAVEFXN ORMAS GROUP LABELS.
      CALL LOCAL_SVDVVOS_RMC_SETUP1(NCORSV,NACTSV)
      CALL VICLR(IGRP,1,L1)
      DO I=NCORSV+1,NCORSV+NACTSV
        IGRP(I)=1
      ENDDO
      IF(CISTEP.EQ.ORMAS) THEN
        DO ISPACE=1,NSPACE
          IF(IMODE.EQ.1) MSTA(NSPACE+1)=NCORSV+NACTSV+1
          DO I=MSTA(ISPACE),MSTA(ISPACE+1)-1
            IGRP(I)=ISPACE
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
 9000 FORMAT(/1X,'LOCAL_KEEPER_SETUP ERROR:',
     *        1X,'PLEASE CODE A NEW KEEPER VAR OPTION.')
      END
C*MODULE LOCAL   *DECK LOCAL_SVDVVOS_MOS
C> @brief      Routine moves around orbital file for VVOS-SVD.
C>
C> @author     Aaron West and Mike Schmidt
C>             -January 21, 2013
C>
C> @see LOCAL_SVDVVOS_REDIM_STEP1
C>      LOCAL_SVDVVOS_REDIM_STEP2
C>      LOCAL_SVDVVOS_REDIM_STEPLAST
C>      LOCAL_SVDVVOS_MOS
C>
C> @param SWITCH_ORBS is an array that determines if any orbital
C>                    switchings actually occur.
C> @param IWRK    is scratch array for integers that will
C>                reorder MOs.
C> @param SCFTYP  gives the wave function type e.g. mcscf,rhf,etc.
C> @param IMBS    is the minimal basis valence number of orbitals.
C> @param L0      is the length of the MO variational space.
C> @param NCORSV  denotes the original MCSCF run doubly occupied size.
C> @param NCORTOT denotes the chemical cores as defined by NVVOS_NUMCOR.
C> @param NACTSV  denotes the original MCSCF run active space size.
C> @param NSKIP   denotes the number of filled doubly occupieds i.e. MDOC.
C> @param NSKIP2  denotes the now filled but previously empty virutals.
C> @param MASWRK  indicates the master process.
C> @param IW      indicates write out to the log file.
      SUBROUTINE LOCAL_SVDVVOS_MOS(
     *           SWITCH_ORBS,IWRK,SCFTYP,IMBS,
     *           L0,NCORSV,NCORTOT,NACTSV,NSKIP,NSKIP2,MASWRK,IW)

      IMPLICIT NONE
      LOGICAL MASWRK,SWITCH_ORBS
      INTEGER IMBS,L0,NCORSV,NCORTOT,NACTSV,NSKIP,NSKIP2,IW
      INTEGER IWRK(L0)
      INTEGER I,NERR,ISING,ITOT
      DOUBLE PRECISION :: SCFTYP,RMC,ROHF
C
      DATA RMC/8HMCSCF   /
      DATA ROHF/8HROHF    /
C
C
      NERR=0
      CALL VICLR(IWRK,1,L0)
C
      IF(SCFTYP.EQ.RMC) THEN
      ITOT=0
      DO I=1,NCORTOT+NSKIP
        ITOT=ITOT+1
        IWRK(I)=I
      ENDDO
      DO I=1,NSKIP2
        ITOT=ITOT+1
        IWRK(NCORTOT+NSKIP+I)=NCORSV+NACTSV+I
      ENDDO
      DO I=1,NACTSV
        ITOT=ITOT+1
        IWRK(NCORTOT+NSKIP+NSKIP2+I)=NCORSV+I
      ENDDO
      DO I=NCORSV+NACTSV+NSKIP2+1,L0
        ITOT=ITOT+1
        IWRK(I)=I
      ENDDO
C
      ELSEIF(SCFTYP.EQ.ROHF) THEN
      ISING=IMBS-NSKIP-NSKIP2
      ITOT=0
      DO I=1,NCORTOT+NSKIP
        ITOT=ITOT+1
        IWRK(I)=I
      ENDDO
      DO I=1,NSKIP2
        ITOT=ITOT+1
        IWRK(NCORTOT+NSKIP+I)=NCORTOT+NSKIP+ISING+I
      ENDDO
      DO I=1,ISING
        ITOT=ITOT+1
        IWRK(NCORTOT+NSKIP+NSKIP2+I)=NCORTOT+NSKIP+I
      ENDDO
      DO I=NCORTOT+NSKIP+NSKIP2+ISING+1,L0
        ITOT=ITOT+1
        IWRK(I)=I
      ENDDO
C
      ELSE
        IF(MASWRK) WRITE(IW,9000)
        NERR=NERR+1
      ENDIF
C
C     POSSIBLY SET SWITCH_ORBS TO TRUE.
      DO I=1,L0
        IF(IWRK(I).NE.I) SWITCH_ORBS=.TRUE.
      ENDDO
C
C     CHECK NUMBER OF ORBITALS COPIED OVER MAKES SENSE.
      IF(ITOT.NE.L0) THEN
        IF(MASWRK) WRITE(IW,9001)
        NERR=NERR+1
      ENDIF
C
      IF(NERR.NE.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9000 FORMAT(/1X,'LOCAL_SVDVVOS_MOS ERROR:',
     *        1X,'SCFTYP WAS NOT PROGRAMED FOR ORBITAL REORDERING.')
 9001 FORMAT(/1X,'LOCAL_SVDVVOS_MOS ERROR:',
     *        1X,'VVOS DIMENSIONS MUST BE WRONG.',
     *        1X,'ORBITALS COPIED DOES NOT TOTAL UP TO L0 MOS.')
      END
C*MODULE LOCAL   *DECK LOCAL_SVDVVOS_REDIM_STEP1
C> @brief      Routine sets up VVOS ormas nspace and orbital sizes.
C>
C> @author     Aaron West and Mike Schmidt
C>             -January 21, 2013
C>
C> @see LOCAL_SVDVVOS_REDIM_STEP1
C>      LOCAL_SVDVVOS_REDIM_STEP2
C>      LOCAL_SVDVVOS_REDIM_STEPLAST
C>      LOCAL_SVDVVOS_MOS
C>
C> @param SCFTYP     indicates MCSCF,RHF,etc.
C> @param ISVDOP     is the SVD option.
C> @param NAT        is the number of atoms.
C> @param NCORSV     is the original MCSCF doubly occupied space.
C> @param NACTDT     is the original MCSCF active space size.
C> @param L0         is the size of the MO variational space.
C> @param NSPACE     indicates the number of ORMAS groups.
C> @param NSPACE_SAV saves the original ORMAS group size.
C> @param NCORTOT    is the chemical cores as defined by NVVOS_NUMCOR.
C> @param NSKIP      denotes the number of filled doubly occupieds i.e. MDOC.
C> @param NACT       denotes the number of VVOS active space orbitals.
C> @param NSKIP2     denotes the now filled but previously empty virutals.
C> @param NVIR2      denotes the number of VVOS virtual orbitals.
C> @param NA         is total occupieds for RHF,ROHF.
C>                   Here, it is only used for ROHF.
C> @param NB         is total doubly occupieds for ROHF.
C> @param MASWRK     indicates the master process.
C> @param IW         indicates write out to the log file.
C>
      SUBROUTINE LOCAL_SVDVVOS_REDIM_STEP1(
     *           SCFTYP,ISVDOP,
     *           NAT,NCORSV,NACTDT,L0,
     *           NSPACE,NSPACE_SAV,
     *           NCORTOT,NSKIP,NACT,NSKIP2,NVIR2,
     *           NA,NB,
     *           MASWRK,IW)
C
      IMPLICIT NONE
      LOGICAL MASWRK
C
      DOUBLE PRECISION :: RMC,RHF,ROHF
      DATA RMC/8HMCSCF   /
      DATA RHF/8HRHF     /
      DATA ROHF/8HROHF    /
C
      DOUBLE PRECISION :: SCFTYP
      INTEGER ISVDOP,NAT,NCORSV,NACTDT,L0,
     *        NSPACE,NSPACE_SAV,
     *        NCORTOT,NSKIP,NACT,NSKIP2,NVIR2,
     *        NA,NB
      INTEGER IW,I,IMBS,ISWMBS
      INTEGER LOCAL_NUMVAL,NVVOS_NUMCOR
C
      IF(SCFTYP.EQ.RMC) THEN
        NSPACE_SAV=NSPACE
        NSPACE=NSPACE_SAV+1
C       NOTES:  VVOS IS RESTRICTED INSIDE OF LOCAL_NUMVAL
C                    TO MBS NUMBERS OF ORBITALS.
        IMBS=0
        DO I=1,NAT
          IMBS=IMBS+LOCAL_NUMVAL(I,0)
        ENDDO
C       NOTES:  SEE VVOS ROUTINE FOR SIMILAR VARS.
        NCORTOT=NVVOS_NUMCOR(0,0)
        NSKIP  =NCORSV-NCORTOT
        NSKIP2 =IMBS-NSKIP-NACTDT
        NACT   =NACTDT+NSKIP+NSKIP2
        NVIR2  =L0-NCORTOT-NSKIP-NSKIP2-NACTDT
        IF(NACT.EQ.NACTDT.AND.NSPACE_SAV.EQ.1) NSPACE=1
      ELSEIF(SCFTYP.EQ.RHF.AND.ISVDOP.EQ.0) THEN
        NSPACE_SAV=NSPACE
        NSPACE=2
        NCORTOT=NVVOS_NUMCOR(0,0)
        NSKIP  =NCORSV-NCORTOT
        NSKIP2 =0
        NACT   =NACTDT
        NVIR2  =L0-NCORTOT-NSKIP-NSKIP2-NACTDT
      ELSEIF(SCFTYP.EQ.ROHF.AND.ISVDOP.EQ.0) THEN
CKEEPROHF        uncomment these lines in order to
CKEEPROHF        make the singly occupied space
CKEEPROHF        a separate 'active' ormas group.
CKEEPROHF        search on this for other places to uncomment...
CKEEPROHF        the singly occupied are copied out in a later routine.
CKEEPROHF        so, nskip,nskip2 must still be defined in correct manner
CKEEPROHF            for rohf.
        ISWMBS=1
        IMBS=0
        DO I=1,NAT
          IMBS=IMBS+LOCAL_NUMVAL(I,ISWMBS)
        ENDDO
        NSPACE_SAV=NSPACE
        NSPACE=2
CKEEPROHF        NSPACE=3
        NCORTOT=NVVOS_NUMCOR(0,0)
        NSKIP  =NB-NCORTOT
        NSKIP2 =IMBS-(NA-NCORTOT)
        NACT   =NACTDT
        NVIR2  =L0-NCORTOT-NACTDT
      ELSE
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9000 FORMAT(//1X,'LOCAL_SVDVVOS_REDIM_STEP1 ERROR:',
     *        /1X,'THIS ISVDOP OPTION DOES NOT EXIST.')
      END
C*MODULE LOCAL   *DECK LOCAL_SVDVVOS_REDIM_STEP2
C> @brief      Routine saves and sets up VVOS ORMAS MSTA.
C>
C> @author     Aaron West and Mike Schmidt
C>             -January 21, 2013
C>
C> @details    This routine sets up the new VVOS orbital ranges
C>             and saves the old ones.
C>
C> @see LOCAL_SVDVVOS_REDIM_STEP1
C>      LOCAL_SVDVVOS_REDIM_STEP2
C>      LOCAL_SVDVVOS_REDIM_STEPLAST
C>      LOCAL_SVDVVOS_MOS
C>
C> @param SCFTYP         indicates MCSCF,RHF,etc.

C> @param ISIZE_FCCWFN   is the current size of the MSTA array
C> @param ISVDOP         is the SVD option.
C> @param NAT            is the number of atoms.
C> @param NSPACE         is the number of ORMAS groups.
C> @param MSTA           contains the ORMAS orbital ranges.
C> @param MSTA_SAV       saves the original MCSCF orbital ranges.
C> @param NCORTOT        is the number of chemical cores from NVVOS_NUMCOR.
C> @param NSKIP          is the number of doubly occupied valence orbitals.
C> @param NSKIP2         is the number of newly occupied VVOS orbitals
C>                       that are virtual orbitals in the original MCSCF.
C> @param MASWRK         indicates the master process.
C> @param SOME          is true for master process with nprint not equal -5.
C> @param IW             indicates write out to the log file.
C>
      SUBROUTINE LOCAL_SVDVVOS_REDIM_STEP2(
     *           SCFTYP,ISVDOP,NAT,L0,
     *           ISIZE_FCCWFN,NSPACE,MSTA,MSTA_SAV,
     *           NCORTOT,NSKIP,NSKIP2,MASWRK,SOME,IW)
C
      IMPLICIT NONE
C
      DOUBLE PRECISION :: RMC,RHF,ROHF
      DATA RMC/8HMCSCF   /
      DATA RHF/8HRHF     /
      DATA ROHF/8HROHF    /
C
      LOGICAL MASWRK,SOME
      DOUBLE PRECISION :: SCFTYP
      INTEGER ISVDOP,NAT,L0,ISWMBS,IMBS,ITRASH
      INTEGER I,NSKIP,NSKIP2,NCORTOT,IW,ISIZE_FCCWFN,NSPACE
      INTEGER MSTA(ISIZE_FCCWFN),MSTA_SAV(ISIZE_FCCWFN)
      INTEGER LOCAL_NUMVAL
C
      CALL ICOPY(ISIZE_FCCWFN,MSTA,1,MSTA_SAV,1)
C
      ISWMBS=1
      IMBS=0
      DO I=1,NAT
        IMBS=IMBS+LOCAL_NUMVAL(I,ISWMBS)
      ENDDO
C
      IF(SCFTYP.EQ.RMC) THEN
        DO I=NSPACE,1,-1
          MSTA(I+1)=MSTA(I)+NSKIP2
        ENDDO
        MSTA(1)=NCORTOT+1
      ELSEIF(SCFTYP.EQ.RHF.AND.ISVDOP.EQ.0) THEN
        MSTA(1)=NCORTOT+1
        MSTA(2)=NCORTOT+IMBS+1
        MSTA(3)=L0+1
CGARBRHF          MSTA(1)=NCORTOT+1
CGARBRHF          MSTA(2)=NA+1
CGARBRHF          MSTA(3)=L0+1
      ELSEIF(SCFTYP.EQ.ROHF.AND.ISVDOP.EQ.0) THEN
        MSTA(1)=NCORTOT+1
        MSTA(2)=NCORTOT+IMBS+1
        MSTA(3)=L0+1
CKEEPROHF        uncomment these lines in order to
CKEEPROHF        make the singly occupied space
CKEEPROHF        a separate 'active' ormas group.
CKEEPROHF         search on this for other places to uncomment...
CKEEPROHF        MSTA(1)=NCORTOT+1
CKEEPROHF        MSTA(2)=NCORTOT+NSKIP+NSKIP2+1
CKEEPROHF        MSTA(3)=NCORTOT+IMBS+1
CKEEPROHF        MSTA(4)=L0+1
      ELSE
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      IF(SOME) WRITE(IW,9001) NSPACE,(MSTA(I),I=1,NSPACE)
C
      ITRASH=NSKIP
      ITRASH=ITRASH-ITRASH
C
      RETURN
 9000 FORMAT(//1X,'LOCAL_SVDVVOS_REDIM_STEP2 ERROR:',
     *        /1X,'THIS SCFTYP,ISVDOP OPTION DOES NOT EXIST.')
 9001 FORMAT(//1X,'VVOS TEMPORARILY RE-DEFINES ORMAS GROUPS.',
     *        /1X,'THE NUMBER OF SPACES             =',I4,
     *        /1X,'EACH SPACE STARTS AT ORBITAL     =',50I4//)
      END
C*MODULE LOCAL   *DECK LOCAL_SVDVVOS_REDIM_STEPLAST
C> @brief      Routine resets MSTA,NSPACE,orbitals for VVOS-ORMAS.
C>
C> @author     Aaron West and Mike Schmidt
C>             -January 21, 2013
C>
C> @see LOCAL_SVDVVOS_REDIM_STEP1
C>      LOCAL_SVDVVOS_REDIM_STEP2
C>      LOCAL_SVDVVOS_REDIM_STEPLAST
C>      LOCAL_SVDVVOS_MOS
C>
C> @param SCFTYP       indicates MCSCF,RHF,etc.
C> @param NACT         is the current number of active orbitals.
C> @param NACTDT       is the original number of active orbitals.
C> @param NSPACE       is the current number of ORMAS groups.
C> @param NSPACE_SAV   is the original number of ORMAS groups.
C> @param ISIZE_FCCWFN is the common block size of MSTA.
C> @param MSTA         holds the orbital ranges for ORMAS groups.
C> @param MSTA_SAV     is the original orbital ORMAS group ranges.
C> @param MASWRK       indicates the master process.
C> @param SOME          is true for master process with nprint not equal -5.
C> @param IW           indicates write out to the log file.
C>
      SUBROUTINE LOCAL_SVDVVOS_REDIM_STEPLAST(
     *           SCFTYP,NACT,NACTDT,NSPACE,NSPACE_SAV,ISIZE_FCCWFN,
     *           MSTA,MSTA_SAV,MASWRK,SOME,IW)
C
      IMPLICIT NONE
C
      DOUBLE PRECISION :: RMC,RHF,ROHF
      DATA RMC/8HMCSCF   /
      DATA RHF/8HRHF     /
      DATA ROHF/8HROHF    /
C
      LOGICAL MASWRK,SOME,OK
      DOUBLE PRECISION :: SCFTYP
      INTEGER I,IW,NACT,NACTDT,NSPACE,NSPACE_SAV,ISIZE_FCCWFN
      INTEGER MSTA(ISIZE_FCCWFN),MSTA_SAV(ISIZE_FCCWFN)
C
      OK=.FALSE.
      IF(SCFTYP.EQ.RMC) OK=.TRUE.
      IF(SCFTYP.EQ.RHF.OR.SCFTYP.EQ.ROHF) OK=.TRUE.
C
      IF(OK) THEN
        NACT=NACTDT
        NSPACE=NSPACE_SAV
        CALL ICOPY(ISIZE_FCCWFN,MSTA_SAV,1,MSTA,1)
        IF(SOME) WRITE(IW,9001) NSPACE,(MSTA(I),I=1,NSPACE)
      ELSE
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9000 FORMAT(//1X,'LOCAL_SVDVVOS_REDIM_STEPLAST ERROR:',
     *        /1X,'THIS SCFTYP,ISVDOP OPTION DOES NOT EXIST.')
 9001 FORMAT(//1X,'VVOS RESETS BACK TO ORIGINAL ORMAS GROUPS.',
     *        /1X,'THE NUMBER OF SPACES             =',I4,
     *        /1X,'EACH SPACE STARTS AT ORBITAL     =',50I4//)
      END
C*MODULE LOCAL   *DECK LOCAL_SVDVVOS_RMC_SETUP1
C> @brief      Returns MCSCF core and active orbital numbers.
C>
C> @author     Aaron West
C>             -March 16, 2013
C>
C> @details    This is a wrapper to avoid variable conflicts
C>             since I introduced new wave function types,etc.
C>             It will get used again.
C>
C> @param NCOR_GET denotes the number of MCSCF core orbitals.
C> @param NACT_GET denotes the number of MCSCF active orbitals.
C>
      SUBROUTINE LOCAL_SVDVVOS_RMC_SETUP1(NCOR_GET,NACT_GET)
      IMPLICIT NONE
C
      INTEGER NCOR_GET,NACT_GET
C
      DOUBLE PRECISION ::
     *       CRIT,DWPARM,GLIST,GRPDET,PRTTOL,SDET,SPINS,SZDET,
     *       WSTATE,STSYM
      INTEGER MXRT,IDWEIGH,IGPDET,IPURES,IROOT,IWTS,KDET,KSTDET,
     *        KSTSYM,MAXP,MAXW1,NACTDT,NADET,NBDET,NCI,NCOR,NCORSV,
     *        NFLGDM,NFTGCI,NITDET,NORBDT
C
      PARAMETER( MXRT=100 )
C
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,SDET,SZDET,
     *                GRPDET,STSYM,GLIST,DWPARM,
     *                NFLGDM(MXRT),IWTS(MXRT),NCORSV,NCOR,NACTDT,NORBDT,
     *                NADET,NBDET,KDET,KSTDET,IROOT,IPURES,MAXW1,NITDET,
     *                MAXP,NCI,IGPDET,KSTSYM,NFTGCI,IDWEIGH
C
C
      NCOR_GET=NCORSV
      NACT_GET=NACTDT
C
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_LMOEXT
C> @brief      This sub. combines LMOs.
C>
C> @author     Aaron West
C>             -March 16, 2013
C>
C> @details    This sub. involves the use of several
C>             localized orbitals.
C>             It then combines two sets of localized orbitals
C>             and outputs the VEC group into .log and .dat files.
C>
C> @param IMODE=1 runs through the entire routine.
C>             =2 just creates a new DAF534 file.
      SUBROUTINE LOCAL_LMOEXT(IMODE)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL SOME,COMBO
      INTEGER IMODE
      INTEGER IORBF1,IORBF52x,ISAV_ISVDOP,NERR
      INTEGER L0,L1,L3
      INTEGER NGOTMX,LOADFM,LAST,NEED_EXTLOC,LDEN,LVEC1,LVEC2,LVEC3
      INTEGER IMBS,IMBSTRI,L0MBS,I,ITMP,ISWMBS
      INTEGER NVVOS_NUMCOR
      INTEGER LOCAL_NUMVAL
      DOUBLE PRECISION :: SCFTYP_TRUTH,SCFTYP_SAV,RMC,RHF,ROHF,SVD,
     *                    ATMNOS,SPLITQA,SPLITQ2
      DOUBLE PRECISION :: EXTLOC_SAV
C-----------------------------------------------------------------------
      DOUBLE PRECISION :: X
C
      DOUBLE PRECISION :: C
      DOUBLE PRECISION :: ZAN
      INTEGER ICH,NQMT,NUM,MUL,NA,NAT,NB,NE,IAN
C
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
C
      LOGICAL ORIENT,ORIKIN,ORMFUL
      INTEGER NATMOR,ISVMOR,ISVDOP,L0DEP0
      DOUBLE PRECISION :: EXTLOC,EREFATM,COUP_NT_VVO
C
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION :: ETOLLZ
      INTEGER ILOCAL,IAHARD
C
      DOUBLE PRECISION ::
     *       RUNTYP,EXETYP,CHECK
      INTEGER NEVALS,NGLEVL,NHLEVL
C
      INTEGER IVVOS,NVVOS
      DOUBLE PRECISION :: BNDDEN
C
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C-----------------------------------------------------------------------
      INTEGER MXAO,MXATM
      PARAMETER (MXAO=8192, MXATM=2000)
C-----------------------------------------------------------------------
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /ORNTMO/ EXTLOC,EREFATM,COUP_NT_VVO(MXATM),
     *                NATMOR(MXAO),ISVMOR(MXATM),ISVDOP,L0DEP0,
     *                ORIENT,ORIKIN,ORMFUL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /VVOPAR/ IVVOS,NVVOS,BNDDEN
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C-----------------------------------------------------------------------
C
C     DEFINE PRINT STUFF
      SOME = NPRINT.NE.-5 .AND. MASWRK
C
C     DATA STUFF
      DATA ATMNOS/8HATMNOS  /
      DATA CHECK/8HCHECK   /
      DATA RHF/8HRHF     /
      DATA RMC/8HMCSCF   /
      DATA ROHF/8HROHF    /
      DATA SPLITQA/8HSPLITQA /
      DATA SPLITQ2/8HSPLITQ2 /
      DATA SVD/8HSVD     /
C
C     DETERMINE IF ANALYSIS IS POSSIBLE.
C     IF NOT, EXIT OUT.
      COMBO=.FALSE.
      IF(EXTLOC.EQ.SVD) COMBO=.TRUE.
      IF(EXTLOC.EQ.ATMNOS) COMBO=.TRUE.
      IF(EXTLOC.EQ.SPLITQA) COMBO=.TRUE.
      IF(EXTLOC.EQ.SPLITQ2) COMBO=.TRUE.
      IF(.NOT.COMBO) RETURN
C
C     PRINT BANNER
      IF(SOME.AND.IMODE.EQ.1) WRITE(IW,9000)
      CALL FLSHBF(IW)
C
C     CALCULATE L0MBS,ETC,FOR FUTURE USE.
      ISWMBS=1
      IMBS=0
      DO I=1,NAT
        IMBS=IMBS+LOCAL_NUMVAL(I,ISWMBS)
      ENDDO
      IMBSTRI=(IMBS*IMBS+IMBS)/2
      L0MBS=IMBS+NVVOS_NUMCOR(0,0)
C
      ITMP=NVVOS_NUMCOR(0,0)
      DO I=1,NAT
        ITMP=ITMP+LOCAL_NUMVAL(I,0)
      ENDDO
C
C     ERROR OUTS
      NERR=0
      IF(ITMP.NE.L0MBS.AND.IVVOS.EQ.0) THEN
        IF(MASWRK) WRITE(IW,9002)
        NERR=NERR+1
      ENDIF
      IF(ILOCAL.EQ.4) THEN
        IF(MASWRK) WRITE(IW,9004)
        NERR=NERR+1
      ENDIF
C
      IF(NERR.GT.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     SKIP FOR EXETYP
      IF(EXETYP.EQ.CHECK) GO TO 8999
C
C     SKIP FOR IMODE=2
      IF(IMODE.EQ.2) GO TO 7999
C
C     FORM EXTERNAL LOCALIZED ORBITALS.
C     NOTE1:  THE NEXT CALL REPLACES DAF FILE 71
C             ONLY IF NOT EXTLOC=RNONE.
C     NOTE2:  THE RHF IS SETUP TO GRAB OUT THE EXTERNAL VIRTUALS.
C             SO, FAKE THE RHF SCFTYP.
C     NOTE3:  SPLITQA WAS THE VERY LAST ADDITION TO POSSIBILITIES.
C             AS SUCH, THINGS GOT MORE COMPLICATED.
C             THE PREVIOUS EXTLOC EXAMPLE RESULTS WERE PRESERVED
C             VIA OLD TEST CASES.
      ISAV_ISVDOP=ISVDOP
      ISVDOP=0
      SCFTYP_SAV=SCFTYP
ccccccc
      IF(SCFTYP.EQ.RMC) THEN
        SCFTYP=RHF
      ELSEIF(SCFTYP.EQ.RHF) THEN
      ELSEIF(SCFTYP.EQ.ROHF) THEN
      ELSE
        IF(MASWRK) WRITE(IW,9010)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
ccccccc
      EXTLOC_SAV=EXTLOC
      EXTLOC=SVD
      IORBF1=15 ! ,15,
      SCFTYP_TRUTH=SCFTYP_SAV
      CALL LOCAL_LMOSVD(IORBF1,SCFTYP_TRUTH)
      ISVDOP=ISAV_ISVDOP
      SCFTYP=SCFTYP_SAV
      EXTLOC=EXTLOC_SAV
C
C     PRINT OFF SECOND BANNER
 7999 CONTINUE
      IF(SOME) WRITE(IW,9001)
      CALL FLSHBF(IW)
C
C     SET UP SOME DIMENSIONS
      L0 = NQMT
      L1 = NUM
      L3 = L1*L1
C
C     ALLOCATE MEMORY.
      CALL GOTFM(NGOTMX)
      CALL VALFM(LOADFM)
      LDEN  = LOADFM + 1
      LVEC1 = LDEN   + IMBSTRI
      LVEC2 = LVEC1  + L3
      LVEC3 = LVEC2  + L3
      LAST  = LVEC3  + L3
      NEED_EXTLOC = LAST - LOADFM - 1
      CALL GETFM(NEED_EXTLOC)
C
C     PREPARE SOME SUPER-SPECIAL PIECES FOR SPLITQA RUNS.
C     NOTE1:  CHANGING THE EXTLOC GUTS OF LOCAL_LMOSVD IS MADNESS.
C     NOTE2:  DIRLMO REQUIRES ORTHOGONAL VALENCE-INTERNAL ORBITALS.
C             I.E. DAF521
      COMBO=EXTLOC.EQ.SPLITQA.OR.EXTLOC.EQ.SPLITQ2
      IF(COMBO.AND.IMODE.EQ.1) THEN
        CALL DAREAD(IDAF,IODA,X(LVEC1),L3,521,0)
        CALL DAWRIT(IDAF,IODA,X(LVEC1),L3,71,0)
        CALL VCLR(X(LVEC1),1,L3)
        CALL DAREAD(IDAF,IODA,X(LDEN),IMBSTRI,536,0)
        CALL DAWRIT(IDAF,IODA,X(LDEN),IMBSTRI,285,0)
      ENDIF
C
C     COMBINE ORBITAL PIECES FROM 2 ORBITAL SETS
C     NOTE:  EXTERNALS MUST BE ORTHOGONAL TO INTERNALS AT THIS POINT.
C     DAF FILE 71  --> CONTAINS MBS LOCALIZED ORBITALS
C     DAF FILE 522 --> CONTAINS THE NEEDED EXTERNAL VIRTUALS.
C                  --> WANT THE NON-ORTHOGONAL VERSION
C                      WHERE THE MOS ARE ORTHOGONAL ONLY
C                      ON EACH ATOM.
C     ORBITAL PIECE 1 = CORE + OCCUPIEDS + VVOS
C     ORBITAL PIECE 2 = EXTERNALS
      CALL DAREAD(IDAF,IODA,X(LVEC1),L3,71,0)
      IORBF52x=522 ! ,522,
      CALL DAREAD(IDAF,IODA,X(LVEC2),L3,IORBF52x,0) ! ,522,521,
      CALL VCLR(X(LVEC3),1,L3)
C
C
      IF(IORBF52x.EQ.522) THEN
        IF(SOME) WRITE(IW,9020)
      ELSEIF(IORBF52x.EQ.521) THEN
        IF(SOME) WRITE(IW,9021)
      ELSE
        IF(SOME) WRITE(IW,9022)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
      CALL FLSHBF(IW)
C
C     ADD INTERNALS TO 'SVD' EXTERNALS.
      CALL DCOPY(L1*L0,X(LVEC2),1,X(LVEC3),1)
      CALL DCOPY(L1*L0MBS,X(LVEC1),1,X(LVEC3),1)
      CALL VCLR(X(LVEC1),1,L3)
      CALL VCLR(X(LVEC2),1,L3)
C
C     SAVE ORBITALS OFF TO DAF FILE 534
      CALL DAWRIT(IDAF,IODA,X(LVEC3),L3,534,0)
C
C     PRINT OUT FINAL INTERNAL+EXT ORBITALS TO GAMESS .LOG FILE.
      IF(SOME.AND.IMODE.EQ.1) THEN
        WRITE(IW,9070)
        WRITE(IW,9071) L0
        CALL PRSQL(X(LVEC3),L0,L1,L1)
      ENDIF
C
C     PRINT OUT ER+EXT ORBITALS TO .DAT FILE.
      IF(MASWRK.AND.IMODE.EQ.1) THEN
        WRITE(IP,9080)
        CALL PUSQL(X(LVEC3),L0,L1,L1)
        WRITE(IP,9085)
      ENDIF
C
C     DEALLOCATE MEMORY.
      CALL RETFM(NEED_EXTLOC)
C
C
 8999 CONTINUE
      IF(SOME) THEN
        WRITE(IW,9300)
        CALL TIMIT(1)
      ENDIF
      RETURN
 9000 FORMAT(/5X,60(1H-)/
     *   5X,'LOCAL_LMOEXT NOW FORMS LOCALIZED EXTERNAL ORBITALS.'/
     *   5X,'LOCAL_LMOEXT CALLS UPON LOCAL_LMOSVD.'/
     *   5X,60(1H-))
 9001 FORMAT(/5X,60(1H-)/
     *   5X,'LOCAL_LMOEXT COMBINES TWO ORBITAL SETS.'/
     *   5X,60(1H-))
 9002 FORMAT(//1X,'LOCAL_LMOEXT ERROR:',
     *        /1X,'EXT=SVD OPTION REQUIRES EITHER:',
     *        /1X,'1. FULL VALENCE ORBITAL SPACE',
     *        /1X,'2. VVOS RUN.')
 9004 FORMAT(//1X,'LOCAL_LMOEXT ERROR:',
     *        /1X,'ILOCAL=4 HAS FILE CONFLICTS FOR',
     *         1X,'EXTLMO=SVD OPTION.')
 9010 FORMAT(//1X,'LOCAL_LMOEXT ERROR:',
     *        /1X,'LOCAL_LMOEXT REQUIRES AN EXPLICIT SCFTYP CHOICE',
     *         1X,'WHAT IN ORDER TO RUN THROUGH LOCAL_LMOSVD.')
 9020 FORMAT(1X,'USING NONORTHOGONAL ORBITALS FROM FILE 522...')
 9021 FORMAT(1X,'USING ORTHOGONAL ORBITALS FROM FILE 521...')
 9022 FORMAT(//1X,'LOCAL_LMOEXT ERROR:',
     *        /1X,'IORBF52x FILE IS NOT APPROPRIATE.')
 9070 FORMAT(//10X,'OCCUPIED + SVD EXTERNAL LOCALIZED ORBITALS')
 9071 FORMAT(10X,I5,1X,'ORBITALS ARE SHOWN.')
 9080 FORMAT('OCCUPIED + SVD EXTERNAL LOCALIZED ORBITALS'/' $VEC')
 9085 FORMAT(' $END')
 9300 FORMAT(1X,'... DONE WITH LOCAL_LMOEXT ...')
      END
C
C*MODULE LOCAL   *DECK LOCAL_COUNTAOS
C> @brief      return no. Cartesian and spherical AOs on atom IAT
C>
C> @author     Mike Schmidt
C>             -March 16, 2013
C>
C> @param IAT      is the atom number from the input file.
C> @param NAOCART  is the number of Cartesian AOs on atom IAT.
C> @param NAOSPH   is the number of spherical AOs on atom IAT.
C>
      SUBROUTINE LOCAL_COUNTAOS(IAT,NAOCART,NAOSPH)
      IMPLICIT NONE
C
      INTEGER NUMCART(8),NUMSPH(8)
      INTEGER I,IAT,ISH,KT,NAOCART,NAOSPH
C--------------------------------------------------------------------------
      DOUBLE PRECISION :: QMTTOL
      INTEGER ISPHER
C
      DOUBLE PRECISION :: EX,CS,CP,CD,CF,CG,CH,CI
      INTEGER KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL
C--------------------------------------------------------------------------
      INTEGER MXSH,MXGTOT
      PARAMETER (MXSH=5000, MXGTOT=20000)
C--------------------------------------------------------------------------
      COMMON /BASSPH/ QMTTOL,ISPHER
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
C--------------------------------------------------------------------------
C
C         s,p,d,f,g,h,i corresponds to KTYPE=1,2,3,4,5,6,7.
C
      NUMCART(1)=1
      DO I=2,7
        NUMCART(I) = NUMCART(I-1) + I
      ENDDO
      IF(ISPHER.EQ.1) THEN
        DO I=1,7
           NUMSPH(I)=2*I-1
        ENDDO
      ELSE
        DO I=1,7
           NUMSPH(I)=NUMCART(I)
        ENDDO
      END IF
C
C           L=SP shell is arbitrarily numbered 8.
C
      NUMCART(8)=4
      NUMSPH(8) =4
C
      NAOCART = 0
      NAOSPH  = 0
C
      DO 100 ISH=1,NSHELL
         IF(KATOM(ISH).LT.IAT) GO TO 100
         IF(KATOM(ISH).GT.IAT) RETURN
         KT = KTYPE(ISH)
         IF(KMIN(ISH).EQ.1  .AND.  KMAX(ISH).EQ.4) KT=8
         NAOCART = NAOCART + NUMCART(KT)
         NAOSPH  = NAOSPH  + NUMSPH(KT)
  100 CONTINUE
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_LCAO_WGHTS
C> @brief      Driver for lcao weight squared.
C>
C> @author     Aaron West and Klaus Ruedenberg
C>             -March 16, 2013
C>
C> @details    These weightings identify atom-orbital correspondence.
C>             For atom identification, one should use nonorthogonal
C>             orbitals as the reference orbitals.
C>             However, many options can be modified as needed.
C>
C> @date September 26, 2013-Aaron West
C> -For linear dependence cases,
C>  one should just use the reordered nonorthogonal orbitals.
C>  So, any extloc runs are now modified to do so here.
C>  Previous results are easily recovered by changing IORBF52x.
C>  Please keep this item in mind when trying to reproduce results.
C>
C>
      SUBROUTINE LOCAL_LCAO_WGHTS
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL SOME,COMBO,OK
      INTEGER IORBF1,IORBF52x,IFILAT,NUML0,ITMPORB,I
      INTEGER L0,L1,L2,L3
      INTEGER NGOTMX,LOADFM,LAST,NEED_LCAO,
     *        LVEC1,LWGT,LWGT2,LWGTDUP,LIATORB,LIATORB2,LSUMORB,
     *        LIATSCR,LWGTSCR
      INTEGER NVVOS_NUMCOR
      INTEGER LOCAL_NUMVAL
      DOUBLE PRECISION :: CUTOFF_IATORB
      DOUBLE PRECISION :: ATMNOS,SVD,SPLITQA,SPLITQ2,RNONE
      INTEGER NERR
C
      INTEGER IKIND
      INTEGER LVEC2,LVTORB,LVMAT,LS,LIATSVD
C-----------------------------------------------------------------------
C
      INTEGER LIMLOW,LIMSUP
C
      DOUBLE PRECISION :: X
C
      DOUBLE PRECISION :: C
      DOUBLE PRECISION :: ZAN
      INTEGER ICH,NQMT,NUM,MUL,NA,NAT,NB,NE,IAN
C
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
C
      LOGICAL ORIENT,ORIKIN,ORMFUL
      INTEGER NATMOR,ISVMOR,ISVDOP,L0DEP0
      DOUBLE PRECISION :: EXTLOC,EREFATM,COUP_NT_VVO
C
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION :: ETOLLZ
      INTEGER ILOCAL,IAHARD
C
      DOUBLE PRECISION ::
     *       RUNTYP,EXETYP,CHECK
      INTEGER NEVALS,NGLEVL,NHLEVL
C
C-----------------------------------------------------------------------
      INTEGER MXAO,MXATM
      PARAMETER (MXAO=8192, MXATM=2000)
C-----------------------------------------------------------------------
      COMMON /ATLIM / LIMLOW(MXATM),LIMSUP(MXATM)
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /ORNTMO/ EXTLOC,EREFATM,COUP_NT_VVO(MXATM),
     *                NATMOR(MXAO),ISVMOR(MXATM),ISVDOP,L0DEP0,
     *                ORIENT,ORIKIN,ORMFUL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C-----------------------------------------------------------------------
      PARAMETER (CUTOFF_IATORB=0.9D+00)
C-----------------------------------------------------------------------
C
C     DEFINE PRINT STUFF
      SOME = NPRINT.NE.-5 .AND. MASWRK
C
C     DATA STUFF
      DATA ATMNOS/8HATMNOS  /
      DATA CHECK/8HCHECK   /
      DATA RNONE/8HNONE    /
      DATA SPLITQA/8HSPLITQA /
      DATA SPLITQ2/8HSPLITQ2 /
      DATA SVD/8HSVD     /
C
C     DETERMINE IF ANALYSIS IS POSSIBLE.
C     IF NOT, EXIT OUT.
      COMBO=.FALSE.
      IF(EXTLOC.EQ.SVD) COMBO=.TRUE.
      IF(EXTLOC.EQ.ATMNOS) COMBO=.TRUE.
      IF(EXTLOC.EQ.SPLITQA) COMBO=.TRUE.
      IF(EXTLOC.EQ.SPLITQ2) COMBO=.TRUE.
      IF(ILOCAL.EQ.4) COMBO=.TRUE.
      IF(.NOT.COMBO) RETURN
C
C     PRINT BANNER
      IF(SOME) WRITE(IW,9001)
      CALL FLSHBF(IW)
C
C     SKIP FOR EXETYP
      IF(EXETYP.EQ.CHECK) GO TO 8999
C
C     SET UP SOME DIMENSIONS
      L0 = NQMT
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
C
C     JUST IN CASE, QUICK SETUP OF LIMLOW AND LIMSUP
      CALL AOLIM
C
C     CALCULATE A COMMON ORBITAL NUMBER
C     FOR POSSIBLE USE BELOW.
      ITMPORB=NVVOS_NUMCOR(0,0)
      DO I=1,NAT
        ITMPORB=ITMPORB+LOCAL_NUMVAL(I,0)
      ENDDO
C
C     FOR EACH CASE:
C     --SET SOME VARS.
C     --OBTAIN ORBITALS
C     NOTE:  DAF 521 SERVES TO DEFINE THE ATOM-ORBITAL CORRESPONDENCE.
C            OTHER ORBITALS SETS ARE RELATED TO DAF 521.
      NUML0=0
      IORBF1=0
      IORBF52x=0
      IFILAT=0
      IORBF52x=521 ! ,521,
      IF(EXTLOC.NE.RNONE.AND.EXTLOC.NE.SPLITQ2) THEN
        NUML0=L0
        IORBF1=534   ! ,534,
        IORBF52x=539 ! ,539,
        IFILAT=540   ! ,540,
      ELSEIF(EXTLOC.EQ.SPLITQ2) THEN
        NUML0=ITMPORB
        IORBF1=534   ! ,521,
        IORBF52x=521 ! ,521,
        IFILAT=528   ! ,528,
      ELSEIF(ILOCAL.EQ.4) THEN
        NUML0=ITMPORB
        IORBF1=521   ! ,521,
        IF(ORIENT) IORBF1=286 ! ,286,
        IORBF52x=521 ! ,521,
        IFILAT=528   ! ,528,
      ELSE
        IF(MASWRK) WRITE(IW,9002)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     CHECK ON ALL-MIGHTY L0DEP0 VAR.
      IF(L0DEP0.NE.L0) THEN
        OK=.FALSE.
        OK=EXTLOC.EQ.ATMNOS.OR.EXTLOC.EQ.SPLITQA  ! splitq2 is ok.
        IF(.NOT.OK) THEN
          IF(MASWRK) WRITE(IW,9200)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
C       IN THIS CASE, ALWAYS SEVERELY RESTRICT THE FILES.
C       NOTE:  NOT NECCESSARILY A REPEAT FROM ABOVE.
        NUML0=L0DEP0
        IORBF1=534   ! ,534,
        IORBF52x=539 ! ,539,
        IFILAT=540   ! ,540,
      ENDIF
C
C     ERROR OUT FOR IORBF1=0
      NERR=0
      IF(IORBF1.EQ.0) THEN
        IF(MASWRK) WRITE(IW,9110)
        NERR=NERR+1
      ENDIF
      IF(EXTLOC.NE.SPLITQA.AND.EXTLOC.NE.SPLITQ2) THEN
        IF(ORIENT.AND.EXTLOC.NE.RNONE) THEN
          IF(MASWRK) WRITE(IW,9111)
          NERR=NERR+1
        ENDIF
      ENDIF
      IF(EXTLOC.NE.RNONE.AND.ILOCAL.EQ.4) THEN
        IF(MASWRK) WRITE(IW,9112)
        NERR=NERR+1
      ENDIF
      IF(NERR.NE.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     ALLOCATE MEMORY.
      CALL GOTFM(NGOTMX)
      CALL VALFM(LOADFM)
      LVEC1     = LOADFM + 1
C     MEMORY FOR LACO WEIGHTS STUFF.
      LWGT      = LVEC1 + L3
      LWGT2     = LWGT  + NAT*NUML0
      LWGTDUP   = LWGT2 + NUML0
C     MEMORY FOR GETTING ATOM-ORBITAL CORRESPONDENCE
C            FOR LCAO STUFF.
      LIATORB   = LWGTDUP + NAT*NUML0
      LSUMORB   = LIATORB + NAT*NUML0
      LIATORB2  = LSUMORB + NUML0
C     MEMORY FOR GETTING ATOM-ORBITAL CORRESPONDENCE
C            FOR MO OVERLAP B/T QUASI-ATOMIC AND ER LOC. ORBITALS.
      LVEC2     = LIATORB2 + NAT*NUML0
C     MEMORY FOR OBTAINING ORBITAL TRANSFORMATION.
      LVTORB    = LVEC2   + L3
      LVMAT     = LVTORB  + L3
      LS        = LVMAT   + L3
      LIATSVD   = LS      + L2
      LIATSCR   = LIATSVD + NUML0
C     MEMORY FOR INTEGER SCRATCH ARRAY FOR PRINT OFF.
      LWGTSCR   = LIATSCR + NAT
      LAST      = LWGTSCR + NAT
      NEED_LCAO = LAST - LOADFM - 1
      CALL GETFM(NEED_LCAO)
C
C
      CALL VCLR(X(LVEC1),1,L3)
      CALL VCLR(X(LWGT),1,NAT*NUML0)
      CALL VCLR(X(LWGT2),1,NUML0)
      CALL VICLR(X(LIATSVD),1,NUML0)
C
C     READ IN CHOSEN ORBITALS
      CALL DAREAD(IDAF,IODA,X(LVEC1),L3,IORBF1,0)
C
C----------LCAO SECTION----------------------------
C
C     OBTAIN THE RELATIVE LCAO WEIGHTINGS PER ATOM.
C     NOTE:  IKIND=0 --> LIATSVD IS NOT USED IN NEXT CALL.
      IKIND=0
      CALL LOCAL_LCAO_WGHTS2(
     *     X(LWGT),X(LWGT2),X(LVEC1),X(LIATSVD),
     *     LIMSUP,LIMLOW,
     *     NAT,NUML0,L1,MXATM,IKIND,IW,MASWRK)
C
C     PRINT ORBITAL ATOMIC WEIGHTS OFF TO THE LOG FILE.
      IF(SOME) THEN
        WRITE(IW,9005)
        WRITE(IW,9003) IORBF1,NAT,NUML0
        CALL PRSQ(X(LWGT),NUML0,NAT,NAT)
      ENDIF
C
C     OBTAIN THE ATOM LABEL(S) FOR EACH MO.
C     PRINT OFF THESE LABELS.
      CALL DCOPY(NAT*NUML0,X(LWGT),1,X(LWGTDUP),1)
      IF(SOME) WRITE(IW,9005)
      CALL LOCAL_LCAO_ATOM_LABELS(
     *     X(LWGT),X(LWGTDUP),X(LIATORB),X(LSUMORB),X(LIATSCR),
     *     X(LWGTSCR),CUTOFF_IATORB,NAT,NUML0,IW,SOME,MASWRK)
C
C----------MO OVERLAP SECTION------------------------
C
C     READ IN THE ORBITALS.
      CALL DAREAD(IDAF,IODA,X(LVEC1),L3,IORBF1,0)
      CALL DAREAD(IDAF,IODA,X(LVEC2),L3,IORBF52x,0)
C
C
      IF(SOME) WRITE(IW,9099)
      IF(SOME) WRITE(IW,9100) IORBF52x
      OK=.FALSE.
      IF(IORBF52x.EQ.522) OK=.TRUE.
      IF(IORBF52x.EQ.521) OK=.TRUE.
      IF(IORBF52x.EQ.539) OK=.TRUE.
      IF(.NOT.OK) THEN
        IF(SOME) WRITE(IW,9105)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
      CALL FLSHBF(IW)
C
C     READ IN ATOM LABELS FOR ALL ORBITALS.
C     ---NOTE:  WE DO NOT WANT TO DISTURB HOW FILE 528 WORKS.
C               THAT WOULD BE IDIOTIC AND A LOT OF WORK.
C     ---NOTE:  IFILAT IS CREATED DUE TO CLINDEP ISSUES.
      CALL LOCAL_READ_FILE528_WITH_CORES(IFILAT,
     *                                   X(LIATSVD),NAT,NUML0,MASWRK)
C
C     CONSTRUCT THE MO OVERLAP BETWEEN
C     COLUMNS FROM QUASI-ATOMIC ORBITAL ON DAF FILE 521
C     AND
C     ROWS FROM ...
C     E.G.  ER SEP. LOC. 'OCCUPIED' ON DAF FILE 534
C     E.G.  DAF FILE 521 AGAIN
      CALL VCLR(X(LVTORB),1,L3)
      CALL VCLR(X(LVMAT),1,L3)
      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      CALL MTARBR(X(LS),L1,X(LVEC1),NUML0,X(LVMAT),L1,1)
      CALL MRTRBR(X(LVEC2),L1,L1,NUML0,X(LVMAT),L1,NUML0,X(LVTORB),L1)
CKEEP
CKEEP      another clindep issue...
CKEEP      put down L3 for any removed memory here.
CKEEPC     NOTE:  VEC1,VEC2 ==> (VEC2,VEC1) DIMS.
CKEEPC     NOTE:  NEXT CALL GIVES PRISTINE MATRIX.
CKEEPC            I.E. NO GARBAGE OUTSIDE THE L0XL0 BLOCK.
CKEEP      CALL MALMQ_TORB(
CKEEP     *     X(LVEC1),X(LVEC2),X(LVTORB),X(LSBAR),X(LSHAT),
CKEEP     *     X(LVMAT),X(LWRKINV),X(LIPVT),X(LS),L0,L1,L2,L3,
CKEEP     *     0,L0,MASWRK)
CKEEP
C
C     PERFORM WEIGHTS ANALYSIS NOW ON MO OVERLAP RATHER THAN LCAO.
      IKIND=1
      CALL LOCAL_LCAO_WGHTS2(
     *     X(LWGT),X(LWGT2),X(LVTORB),X(LIATSVD),
     *     LIMSUP,LIMLOW,
     *     NAT,NUML0,L1,MXATM,IKIND,IW,MASWRK)
      IF(SOME) THEN
        WRITE(IW,9006)
        WRITE(IW,9003) IORBF1,NAT,NUML0
        CALL PRSQ(X(LWGT),NUML0,NAT,NAT)
      ENDIF
      CALL DCOPY(NAT*NUML0,X(LWGT),1,X(LWGTDUP),1)
      IF(SOME) WRITE(IW,9006)
      CALL LOCAL_LCAO_ATOM_LABELS(
     *     X(LWGT),X(LWGTDUP),X(LIATORB2),X(LSUMORB),X(LIATSCR),
     *     X(LWGTSCR),CUTOFF_IATORB,NAT,NUML0,IW,SOME,MASWRK)
C
C
C------------------------------------------------------
C----------END OF MO OVERLAP SECTION-------------------
C
C     DEALLOCATE MEMORY.
      CALL RETFM(NEED_LCAO)
C
C
 8999 CONTINUE
      IF(SOME) THEN
        WRITE(IW,9300)
        CALL TIMIT(1)
      ENDIF
      RETURN
C 9000 FORMAT(/1X,'SKIPPING LOCAL_LCAO_WGHTS:',
C     *       /1X,'LOCAL_LCAO_WGHTS CANNOT DETERMINE',
C     *        1X,'ORBITAL DAF FILE.')
 9001 FORMAT(/5X,60(1H-)/
     *   5X,'LOCAL_LCAO_WGHTS NOW ANALYZES',
     *   1X,'ATOMIC WEIGHTS SQUARED'/
     *   5X,'OF LCAO AND MO OVERLAP OF ORBITAL SET DEFINED BELOW.'/
     *   5X,60(1H-))
 9002 FORMAT(/1X,'ERROR IN LOCAL_LCAO_WGHTS:',
     *       /1X,'LOCAL_LCAO_WGHTS CANNOT DETERMINE',
     *        1X,'ORBITAL DAF FILE.')
 9003 FORMAT(/1X,'THE RELATIVE WEIGHTS SQUARED NOW FOLLOW.',
     *       /1X,'ORBITAL DAF FILE =',I5,
     *       /1X,'ROWS=ATOMS,COLUMNS=MOS',
     *       /1X,'INCLUDES CORE ORBITALS ON UP...',
     *       /1X,'NUMBER OF ATOMS =',I5,
     *       /1X,'NUMBER OF MOS   =',I5)
 9005 FORMAT(/1X,'NOW USING LCAO COEFFICIENTS',
     *        1X,'IN THE ANALYSIS... ')
 9006 FORMAT(/1X,'NOW USING MO OVERLAP COEFFICIENTS',
     *        1X,'IN THE ANALYSIS... ')
 9099 FORMAT(/1X,'A SET OF ATOMIC-LIKE MOLECULAR ORBITALS MUST',
     *        1X,'BE CHOSEN FOR A RELATIVE COMPARISON...')
 9100 FORMAT( 1X,'USING NONORTHOGONAL ORBITALS FROM DAF FILE=',I4)
 9105 FORMAT(//1X,'ERROR IN LOCAL_LCAO_WGHTS:',
     *        /1X,'IORBF52x FILE IS NOT APPROPRIATE.')
 9110 FORMAT(/1X,'ERROR IN LOCAL_LCAO_WGHTS:',
     *       /1X,'IORBF1 DAF FILE EQUALS 0.  NO FILE SELECTED.')
 9111 FORMAT(/1X,'ERROR IN LOCAL_LCAO_WGHTS:',
     *       /1X,'NO NO. THIS WILL BE A SEPARATE RUN.',
     *       /1X,'THE LOCAL INPUT SHOULD HAVE PREVENTED US',
     *        1X,'US FROM REACHING HERE. PLEASE RE-THINK.')
 9112 FORMAT(/1X,'LOCAL_LCAO_WGHTS ERROR:',
     *       /1X,'ANY GIVEN EXTLOC OPTION CANNOT HAVE',
     *        1X,'ILOCAL=4.')
 9200 FORMAT(/1X,'LOCAL_LCAO_WGHTS ERROR:',
     *       /1X,'L0DEP0 DIFFERS FROM L0.',
     *       /1X,'IN THIS CASE, ATMNOS AND SPLITQA ARE ALLOWED.',
     *        1X,'OTHER EXTLOC KINDS ARE NOT ALLOWED.',
     *       /1X,'FURTHERMORE, OTHER KINDS ARE NOT AS GOOD.')
 9300 FORMAT(1X,'... DONE WITH LCAO RELATIVE',
     *       1X,'ATOMIC WEIGHTS SQUARED ...')
      END
C*MODULE LOCAL   *DECK LOCAL_LCAO_WGHTS2
C> @brief      FORMS RELATIVE LCAO WEIGHTS SQUARED
C>
C> @author     Aaron West and Klaus Ruedenberg
C>             -March 16, 2013
C>
C> @details    1.  LCAO COEFFICIENTS ARE SQUARED.
C>             2.  FOR EACH MO FOR EACH ATOM A,
C>                 THE LCAO**2 VALUES ARE SUMMED.
C>             3.  FOR EACH MO,
C>                 THESE VALUES ARE THEN NORMALIZED.
C>
C>
C> @param WGT    will contain the LCAO summed over one atom
C>               for each MO.
C>               i.e. NATxNUML0 array
C> @param WGT2   will contain the LCAO summed over all atoms
C>               per MO.
C>               i.e. NUML0 array
C> @param VEC    contains the LCAO for the MOs of interest.
C> @param IATSVD is an array from the SVD run itself
C>               that contains atom-orbital correspondences.
C> @param LIMSUP array contains the upper basis function on an atom.
C> @param LIMLOW array contains the lower basis function on an atom.
C> @param NAT    denotes number of atoms.
C> @param NUML0  denotes number of orbitals to be used in
C>               the LCAO weights squared analysis.
C> @param L1     is length of the AO basis.
C> @param MXATM  is max. number of atoms.
C> @param IKIND  is an integer to switch between using
C>               LCAO and MO OVERLAP.
C>               IKIND=0 --> USE LCAO ATOMS LIMITS
C>               IKIND=1 --> CONVERT SVD MO TO ATOMS
C> @param IW     indicates write out to the log file.
C> @param MASWRK is true for master process.
      SUBROUTINE LOCAL_LCAO_WGHTS2(
     *     WGT,WGT2,VEC,IATSVD,
     *     LIMSUP,LIMLOW,
     *     NAT,NUML0,L1,MXATM,IKIND,IW,MASWRK)
C
      IMPLICIT NONE
C     VARS
      LOGICAL MASWRK
      INTEGER L1,NUML0,NAT,MXATM,IKIND,IW
      INTEGER IATM1,IBAS1,IBAS2,I,K
      INTEGER LIMLOW(MXATM)
      INTEGER LIMSUP(MXATM)
      INTEGER IATSVD(NUML0)
      DOUBLE PRECISION :: SUM,TOTSUM,TMP
      DOUBLE PRECISION :: WGT(NAT,NUML0),WGT2(NUML0),VEC(L1,L1)
C
      CALL VCLR(WGT,1,NAT*NUML0)
      CALL VCLR(WGT2,1,NUML0)
C
C     SUM UP THE RELATIVE LCAO WEIGHTS ON EACH ATOM FOR EACH ORBITAL.
      IF(IKIND.EQ.0) THEN
        DO I=1,NUML0
          TOTSUM=0.0D+00
          DO IATM1=1,NAT
            IBAS1=LIMLOW(IATM1)
            IBAS2=LIMSUP(IATM1)
            SUM=0.0D+00
            DO K=IBAS1,IBAS2
              SUM=SUM+VEC(K,I)**2
            ENDDO
            WGT(IATM1,I)=SUM
            TOTSUM=TOTSUM+SUM
          ENDDO
          WGT2(I)=TOTSUM
        ENDDO
      ELSEIF(IKIND.EQ.1) THEN
        DO I=1,NUML0
          TOTSUM=0.0D+00
          DO K=1,NUML0
            IATM1=IATSVD(K)
            TMP=VEC(K,I)**2
            WGT(IATM1,I)=WGT(IATM1,I)+TMP
            WGT2(I)=WGT2(I)+TMP
          ENDDO
        ENDDO
      ENDIF
C
C     NORMALIZE ALL WEIGHTS ON EACH ORBITAL.
      DO I=1,NUML0
        DO IATM1=1,NAT
          WGT(IATM1,I)=WGT(IATM1,I)/WGT2(I)
        ENDDO
      ENDDO
C
C
      IF(IKIND.NE.0.AND.IKIND.NE.1) THEN
        IF(MASWRK) WRITE(IW,9001)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9001 FORMAT(//1X,'LOCAL_LCAO_WGHTS2 ERROR:',
     *        /1X,'IKIND=0 OR IKIND=1 ARE ONLY OPTIONS.')
      END
C*MODULE LOCAL   *DECK LOCAL_LCAO_ATOM_LABELS
C> @brief      Determines atom-orbital correspondence for LOCAL_LCAO.
C>
C> @author     Aaron West and Klaus Ruedenberg
C>             -March 19, 2013
C>
C> @details    The atom-orbital correspondence is determined
C>             based on summing the largest overlap coefficients
C>             up to a specified cutoff.
C>             These overlap coefficients might be
C>             LCAO coefficients or MO overlap for a particular
C>             reference set of orbitals.
C>
C> @param WGT           is the the relative weights squared array.
C>                      Dimensions are NATxNUML0.
C>                      i.e. number of atoms x some MOs.
C> @param WGTDUP        is a copy of the relative weights squared array.
C>                      Dimensions are NATxNUML0.
C>                      i.e. number of atoms x some MOs.
C> @param IATORB        is the integer array that will hold the
C>                      atom or atoms for a particular orbital.
C> @param SUMORB        is an integer array used to sum up the coefficients
C>                      from WGTDUP.
C> @param IATSCR        is an scratch integer array that is used for printing.
C> @param WGTSCR        is a scratch array that is used for printing.
C> @param CUTOFF_IATORB is the tolerance cut-off for assigning
C>                      the atoms to MOs.
C> @param NAT           is the total number of atoms.
C> @param NUML0         is the number of molecular orbital used.
C>                      It is based on the kind of localization.
C> @param IW            indicates write out to the log file.
C> @param SOME          is true for master process with nprint not equal -5.
C> @param MASWRK        indicates the master process.
      SUBROUTINE LOCAL_LCAO_ATOM_LABELS(
     *           WGT,WGTDUP,IATORB,SUMORB,IATSCR,
     *           WGTSCR,CUTOFF_IATORB,NAT,NUML0,IW,SOME,MASWRK)
C
      IMPLICIT NONE
C     VARS
      LOGICAL SOME,MASWRK
      INTEGER NAT,NUML0,JPOS,I,J,II,IW,IERR
      INTEGER IDAMAX,IXAMAX
      DOUBLE PRECISION :: TMP,CUTOFF_IATORB
C
      INTEGER IATORB(NAT,NUML0)
      INTEGER IATSCR(NAT)
      DOUBLE PRECISION :: WGT(NAT,NUML0),WGTDUP(NAT,NUML0),
     *                    SUMORB(NUML0),WGTSCR(NAT)
C
C     DO REQUIRED VCLR AND VICLR.
      CALL VCLR(SUMORB,1,NUML0)
      CALL VICLR(IATORB,1,NAT*NUML0)
C
C     GET THE ATOM LABELS.
      IERR=0
      DO 100 I=1,NUML0
        DO J=1,NAT
          IF(SUMORB(I).GT.CUTOFF_IATORB) GO TO 100
          JPOS=IDAMAX(NAT,WGTDUP(1,I),1)
          TMP=WGTDUP(JPOS,I)
          IF(TMP.LT.0.0D+00) IERR=IERR+1
          WGTDUP(JPOS,I)=0.0D+00
          SUMORB(I)=SUMORB(I)+TMP
          IATORB(JPOS,I)=1
        ENDDO
  100 CONTINUE
C
C     PRINT THE ATOM LABELS.
      IF(SOME) WRITE(IW,9000) CUTOFF_IATORB
      DO I=1,NUML0
        CALL VICLR(IATSCR,1,NAT)
        CALL VCLR(WGTSCR,1,NAT)
        II=0
        DO J=1,NAT
          IF(IATORB(J,I).EQ.1) THEN
            II=II+1
            IATSCR(II)=J
            WGTSCR(II)=WGT(J,I)
          ENDIF
        ENDDO
        IF(SOME) THEN
          WRITE(IW,9001) I,(IATSCR(J),J=1,II)
          WRITE(IW,9002) (WGTSCR(J),J=1,II)
        ENDIF
      ENDDO
C
C     ERROR OUT
      IF(IERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9003)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9000 FORMAT(//1X,'FOR EACH MOLECULAR ORBITAL,',
     *      /1X,'1. THE MAXIMUM RELATIVE COEFFICIENT',
     *       1X,'SQUARES ARE LOCATED.',
     *      /1X,'2. THESE MAXIMUM COEFFICIENTS ARE SUMMED UP.',
     *      /1X,'3. WHEN THE SUM IN POINT 2 REACHES THE CUTOFF,',
     *      /1X,'   THE ATOM LABELS ARE NO LONGER ASSIGNED.',
     *      /1X,'   CUTOFF=',1P,E10.2,
     *      /1X,'4. FOR MO OVERLAPS,',
     *      /1X,'   VALUES OF 1 DO NOT NECCESARILY INDICATE',
     *      /1X,'   ORBITAL OVERLAPS OF 1... QUITE THE CONTRARY.',
     *      /1X,'5. THE DISPLAYED ATOM LABELS ARE READ FROM',
     *      /1X,'   THE SVD ITSELF.  FOR DAF534, THE MO OVERLAPS',
     *      /1X,'   ARE STILL FORMED WITH SVD ORBITALS.',
     *      /1X,'   SO SVD ATOM LABELS ARE SUFFICIENT FOR NOW.',
     *      /1X,'6. DO NOT APPLY TO MALMQ_CIDRIV RESULTS.')

 9001 FORMAT(1X,'MO=',I5,1X,'HAS ATOM(S)=',100I5//)
 9002 FORMAT(10X,'WITH WEIGHT(S)=',100F5.2//)
 9003 FORMAT(/1X,'LOCAL_LCAO_ATOM_LABELS ERROR:',
     *       /1X,'IDAMAX SORTING DOES NOT WORK',
     *        1X,'WITH NEGATIVE VALUES.')
      END
C*MODULE LOCAL   *DECK LOCAL_READ_FILE528_WITH_CORES
C> @brief      Reads DAF file 528 or 540 and adds cores to it.
C>
C> @author     Aaron West
C>             -March 21, 2013
C>
C> @details    Reads DAF file 528 or 540 and adds cores to it.
C>             File 528 was designed to deal with general
C>             atom-orbital correspondence.
C>             Chemical core orbital atom-orbital correspondence
C>             is calculated from NVVOS_NUMCOR.
C>             Testing for 0s in the read out was very useful
C>             in the long run.
C>
C> @param IFILE  is currently either 528 or 540.
C> @param IATSVD is the integer array that will hold the
C>               SVD-based atoms labels.
C> @param NAT    is the number of atoms.
C> @param NUML0  is the length of the 'active' orbitals.
C>               This is a bit varied based on the run.
C> @param MASWRK indicates the master process.
      SUBROUTINE LOCAL_READ_FILE528_WITH_CORES(
     *           IFILE,IATSVD,NAT,NUML0,MASWRK)
C
      LOGICAL MASWRK
      INTEGER IFILE,ITOT,IDUM,NAT,ITMP
      INTEGER IATSVD(NUML0)
      INTEGER NVVOS_NUMCOR
C
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
      CALL VICLR(IATSVD,1,NUML0)
C
      ITOT=0
      IDUM=1
      DO I=1,NAT
        ITMP=NVVOS_NUMCOR(I,1)
        ITOT=ITOT+ITMP
        IF(ITMP.NE.0) THEN
          DO J=IDUM,ITOT
            IATSVD(J)=I
          ENDDO
        ENDIF
        IDUM=ITOT+1
      ENDDO
      IDUM=IDUM-1
      ITMP=NUML0-IDUM
C
C     READ IN NON-CORES FROM FILE 528.
      CALL DAREAD(IDAF,IODA,IATSVD(IDUM+1),ITMP,IFILE,1) ! ,528, ,540,
C
C     THE ARRAY SHOULD NOT HAVE ANY 0S.  TEST FOR THIS.
C     THIS IS MY INANIMATE SAVIOR.
      ITMP=0
      DO I=1,NUML0
        IF(IATSVD(I).EQ.0) ITMP=1
      ENDDO
      IF(ITMP.GT.0) THEN
        IF(MASWRK) WRITE(IW,9001)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9001 FORMAT(//1X,'LOCAL_READ_FILE528_WITH_CORES ERROR:',
     *        /1X,'IATSVD ARRAY HAS 0S.  WRONG...')
      END
C*MODULE LOCAL   *DECK LOCAL_VVOS_ORB_RANGE
C> @brief      Automatically finds atom numbers for VVOS orbitals.
C>
C> @author     Aaron West
C>             -March 21, 2013
C>
C> @details    Finds atom numbers for VVOS orbitals.
C>             This is handy for determining which atoms
C>             are on which orbital and how many.
C>             In VVOS, the chemical core orbitals
C>             start at the beginning of each atom...
C>             i.e. all chem. cores are not at the beginning...
C>             This sub. deals with it.
C>
C> @param IPOSMBS takes an atom number and returns the
C>                very first VALENCE MBS-type orbital number.
C> @param ILENMBS gives the number of VALANEC MBS orbitals.
C> @param NAT     is the number of atoms.
      SUBROUTINE LOCAL_VVOS_ORB_RANGE(IPOSMBS,ILENMBS,NAT)
      IMPLICIT NONE
C
      INTEGER I,ITYPE,NCOR_NEVER,ITMP,NVAL,ISWMBS
      INTEGER LOCAL_NUMVAL
      INTEGER NVVOS_NUMCOR
      INTEGER NAT
      INTEGER IPOSMBS(NAT+1)
      INTEGER ILENMBS(NAT)
C
C     NOTES:
C     1.  GO BACK TO THE BASIC NVVOS_NUMCOR INFO HERE
C         SINCE VVOS IS IN MBS NUMBERS.
C     2.  GO BACK TO NVVOS_NUMCOR ATOM-BY-ATOM.
C         THIS PART TOOK ME A BIT TO REALIZE... AND DANCE.
C
      ITMP=1
      DO I=1,NAT
C
        ITYPE=1
        NCOR_NEVER=NVVOS_NUMCOR(I,ITYPE)
        ISWMBS=1
        NVAL=LOCAL_NUMVAL(I,ISWMBS)
C
        ILENMBS(I)=NVAL
C
        ITMP=ITMP+NCOR_NEVER
        IPOSMBS(I)=ITMP
        ITMP=ITMP+NVAL
C
      ENDDO
      IPOSMBS(NAT+1)=ITMP
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_NOS_EXT
C> @brief      Driver for atomic external NOs.
C>
C> @author     Aaron West
C>             -March 21, 2013
C>
C> @details    This driver forms external canonical
C>             quasi-atomic orbitals from the
C>             current basis set and Whitten exchange integrals.
C>
      SUBROUTINE LOCAL_NOS_EXT
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL SOME,COMBO,REDO_INT
      DOUBLE PRECISION :: ATMNOS,SPLITQA,SPLITQ2,RMC,RNONE
      INTEGER L0,L1,L2,L3,L0MBS,NVALORBS,NVALTRI
      INTEGER ISWMBS,LOCAL_NUMVAL,NVVOS_NUMCOR
      INTEGER LOADFM,NGOTMX,NEED_NOS_EXT,LAST,
     *        LS,LS2,LSWRK,LSTRI,LSVMBS,
     *        LIPOSCOR,LILENCOR,LIPOSMBS,LILENMBS,LIATSVD,
     *        LIPOSEXT,LOCCIMO,LVECCOL,LVEC539,LVEC,
     *        LVWRK1,LVWRK2,LVWRK3,LVWRK4,LBUFFX,LBUFFI,
     *        LWRK,LIWRK,LEIG,LSAVWGT,LSAVWGT2,LIWRKP,LIWRK3
      INTEGER I,IDUM,NERR,ITMP,ITMP2
      INTEGER NCORTOT,NAOCART,NAOSPH,NAOTOT,NAOTRI,L0FIN,IFILE
C
C-----------------------------------------------------------------------
      INTEGER MXAO,MXATM
      PARAMETER (MXAO=8192, MXATM=2000)
C-----------------------------------------------------------------------
C
      INTEGER LIMLOW,LIMSUP
C
      DOUBLE PRECISION :: X
C
      DOUBLE PRECISION :: C,ZAN
      INTEGER ICH,NQMT,NUM,MUL,NA,NAT,NB,NE,IAN
C
      INTEGER NINTMX,NHEX,NTUPL,INTTYP,IGRDTYP
      LOGICAL PACK2E
C
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      LOGICAL ORIENT,ORIKIN,ORMFUL
      INTEGER NATMOR,ISVMOR,ISVDOP,L0DEP0
      DOUBLE PRECISION :: EXTLOC,EREFATM,COUP_NT_VVO
C
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      DOUBLE PRECISION :: ETOLLZ
      INTEGER ILOCAL,IAHARD
C
      DOUBLE PRECISION :: RUNTYP,EXETYP,CHECK
      INTEGER NEVALS,NGLEVL,NHLEVL
C
      INTEGER NIRRED,NSALC,NSALC2,NSALC3,NSAFMO
C
      INTEGER IVVOS,NVVOS
      DOUBLE PRECISION :: BNDDEN
C
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C-----------------------------------------------------------------------
      COMMON /ATLIM / LIMLOW(MXATM),LIMSUP(MXATM)
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /ORNTMO/ EXTLOC,EREFATM,COUP_NT_VVO(MXATM),
     *                NATMOR(MXAO),ISVMOR(MXATM),ISVDOP,L0DEP0,
     *                ORIENT,ORIKIN,ORMFUL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SYMBLK/ NIRRED,NSALC,NSALC2,NSALC3,NSAFMO
      COMMON /VVOPAR/ IVVOS,NVVOS,BNDDEN
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C-----------------------------------------------------------------------
C
C     DEFINE PRINT STUFF
      SOME  = NPRINT.NE.-5 .AND. MASWRK
C
C     DATA STUFF
      DATA ATMNOS/8HATMNOS  /
      DATA CHECK/8HCHECK   /
      DATA RMC/8HMCSCF   /
      DATA RNONE/8HNONE    /
      DATA SPLITQA/8HSPLITQA /
      DATA SPLITQ2/8HSPLITQ2 /
C
C     DETERMINE IF ANALYSIS IS POSSIBLE.
C     IF NOT, EXIT OUT.
      COMBO=.FALSE.
      IF(EXTLOC.EQ.ATMNOS) COMBO=.TRUE.
      IF(EXTLOC.EQ.SPLITQA) COMBO=.TRUE.
      IF(EXTLOC.EQ.SPLITQ2) COMBO=.FALSE.
      IF(.NOT.COMBO) RETURN
C
C     PRINT BANNER
      IF(SOME) WRITE(IW,9000)
      CALL FLSHBF(IW)
C
C------------------------------------------
C     SET UP SOME DIMENSIONS
      L0 = NQMT
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
CLINDEP
CKEEP      L0TRI = (L0*L0+L0)/2
C     SET UP NAOTOT
      NAOTOT=0
      DO I=1,NAT
        CALL LOCAL_COUNTAOS(I,NAOCART,NAOSPH)
        NAOTOT=NAOTOT+NAOSPH
      ENDDO
      NAOTRI=(NAOTOT*NAOTOT+NAOTOT)/2
C     SET UP NCORTOT
      NCORTOT=NVVOS_NUMCOR(0,0)
CLINDEP
C     SET UP L0MBS DIMENSION
      ISWMBS=1
      L0MBS=0
      L0MBS=L0MBS+NCORTOT
      DO I=1,NAT
        L0MBS=L0MBS+LOCAL_NUMVAL(I,ISWMBS)
      ENDDO
C     SET UP NVALORBS DIMENSION
      ISWMBS=1
      NVALORBS=0
      DO I=1,NAT
        NVALORBS=NVALORBS+LOCAL_NUMVAL(I,ISWMBS)
      ENDDO
      NVALTRI=(NVALORBS*NVALORBS+NVALORBS)/2
C------------------------------------------
C
C     PERFORM SOME MORE EXITS.
      IF(SCFTYP.EQ.RMC) THEN
        CALL LOCAL_SVDVVOS_RMC_SETUP1(ITMP,ITMP2)
        ITMP=ITMP+ITMP2
        IF(ITMP.EQ.L0) RETURN
      ENDIF
C------------------------------------------
C
C     ERROR OUTS
      NERR=0
      IF(IVVOS.EQ.0.AND.ISVDOP.NE.10) THEN
        IF(MASWRK) WRITE(IW,9003)
        NERR=NERR+1
      ENDIF
      IF(L0.EQ.L0MBS) THEN
        IF(MASWRK) WRITE(IW,9004)
        NERR=NERR+1
      ENDIF
      IF(EXTLOC.NE.RNONE.AND.ILOCAL.EQ.4) THEN
        IF(MASWRK) WRITE(IW,9005)
        NERR=NERR+1
      ENDIF
C
      IF(NERR.GT.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     SKIP FOR EXETYP
      IF(EXETYP.EQ.CHECK) GO TO 8999
C
C     REMOVE MOLECULAR SYMMETRY FOR ENTIRE ROUTINE.
      REDO_INT=.FALSE.
      IF(NIRRED.NE.1) REDO_INT=.TRUE.
      CALL SYMOFF
C
C     RE-DO INTEGRALS
      IF(REDO_INT) CALL JANDK
      CALL SEQREW(IS)
C
C     ALLOCATE MEMORY.
      CALL GOTFM(NGOTMX)
      CALL VALFM(LOADFM)
      LS           = LOADFM     + 1
      LS2          = LS         + L2
      LSWRK        = LS2        + L2
      LSTRI        = LSWRK      + L2
      LSVMBS       = LSTRI      + NAOTRI
      LIPOSCOR     = LSVMBS     + L1*L0MBS
      LILENCOR     = LIPOSCOR   + (NAT+1)
      LIPOSMBS     = LILENCOR   + NAT
      LILENMBS     = LIPOSMBS   + (NAT+1)
      LIATSVD      = LILENMBS   + NAT
      LIPOSEXT     = LIATSVD    + L1
      LOCCIMO      = LIPOSEXT   + (NAT+1)
      LVECCOL      = LOCCIMO    + L0MBS
      LVEC539      = LVECCOL    + L3
      LVEC         = LVEC539    + L3
      LVWRK1       = LVEC       + L3
      LVWRK2       = LVWRK1     + L3
      LVWRK3       = LVWRK2     + L3
      LVWRK4       = LVWRK3     + L3
      LBUFFX       = LVWRK4     + L3
      LBUFFI       = LBUFFX     + NINTMX
      LWRK         = LBUFFI     + NINTMX
      LIWRK        = LWRK       + L1*8
      LEIG         = LIWRK      + L1
      LSAVWGT      = LEIG       + L1
      LSAVWGT2     = LSAVWGT    + NAOTOT
      LIWRKP       = LSAVWGT2   + NAOTOT
      LIWRK3       = LIWRKP     + L1
      LAST         = LIWRK3     + L3
      NEED_NOS_EXT = LAST - LOADFM - 1
      CALL GETFM(NEED_NOS_EXT)
C
C     NEED TO KEEP THE ROUTINES FOR LATER.
C     FAKE SOME CALLS.
      IF(IW.NE.6) THEN
        IDUM=1
        CALL LOCAL_ATOMIC_HSANDT(X(LS),L2,2,IDUM,0)
        CALL LOCAL_SORT_EVALS(IDUM,IDUM,IDUM,X(LIWRK),X(LEIG))
      ENDIF
C
C     SETUP SOME ATOM INTEGER ARRAYS.
      CALL LOCAL_VVOS_ORB_RANGE_CORE(X(LIPOSCOR),X(LILENCOR),NAT)
      CALL LOCAL_VVOS_ORB_RANGE(X(LIPOSMBS),X(LILENMBS),NAT)
      IFILE=540
      CALL LOCAL_READ_FILE528_WITH_CORES(IFILE,
     *                                   X(LIATSVD),NAT,NAOTOT,MASWRK)
C
C     PUT ALL THE WAVE FXN ORBITALS IN THE ORDER OF
C     THE SCF FREE-ATOM ORBITALS.
C     --ONLY CURRENT OUTPUT:  LOCCIMO
      IF(SOME) WRITE(IW,9055)
      CALL DAREAD(IDAF,IODA,X(LSTRI),NVALTRI,536,0)
      CALL DAREAD(IDAF,IODA,X(LSVMBS),L1*L0MBS,533,0)
      CALL DAREAD(IDAF,IODA,X(LVWRK3),L3,539,0) ! clindep 522 before
      CALL DCOPY(L3,X(LVWRK3),1,X(LVWRK4),1)
      CALL LOCAL_NOS_EXTSVD1(
     *     NAOTOT,L1,L2,L3,L0MBS,NVALORBS,NVALTRI,NAT,
     *     X(LIPOSCOR),X(LILENCOR),X(LIPOSMBS),X(LILENMBS),X(LIATSVD),
     *     X(LS),X(LSVMBS),
     *     X(LIWRK),X(LWRK),X(LSTRI),X(LEIG),
     *     X(LVWRK1),X(LVWRK2),X(LVWRK3),X(LVWRK4),
     *     X(LIWRKP),X(LSAVWGT),X(LSAVWGT2),
     *     X(LOCCIMO),SOME,MASWRK,IW)
C
C     FORM "ORDERED" EXTERNAL QUAOS
      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      CALL DAREAD(IDAF,IODA,X(LSVMBS),L1*L0MBS,533,0)
      CALL DAREAD(IDAF,IODA,X(LVEC539),L3,539,0) ! clindep 522 before
      L0FIN=0
      CALL LOCAL_NOS_EXTSVD2(
     *     NAOTOT,L0,L0FIN,L1,L2,L3,L0MBS,NAT,NINTMX,
     *     X(LIPOSMBS),X(LILENMBS),X(LIATSVD),X(LIPOSEXT),
     *     LIMSUP,LIMLOW,
     *     X(LOCCIMO),
     *     X(LS),X(LS2),X(LSWRK),X(LSVMBS),
     *     X(LVEC539),X(LVECCOL),X(LVEC),
     *     X(LEIG),X(LSAVWGT),X(LSAVWGT2),
     *     X(LIWRK),X(LWRK),X(LVWRK1),X(LVWRK2),X(LVWRK3),X(LVWRK4),
     *     NOPK,X(LBUFFX),X(LBUFFI),
     *     X(LIWRKP),
     *     X(LIWRK3),
     *     SOME,IW)
CLINDEP
C     ENJOY... SUFFER... ENDURE... PERISH...
      CALL DAWRIT(IDAF,IODA,X(LVEC539),L3,539,0)
      CALL VICLR(X(LIWRK3),1,L3)
      CALL ICOPY(L1-NCORTOT,X(LIATSVD+NCORTOT),1,X(LIWRK3),1)
      CALL DAWRIT(IDAF,IODA,X(LIWRK3),L1,540,1)
CLINDEP
C
C     ADD THE INTERNAL ORBITALS FOR THE LVECCOL.
      CALL DAREAD(IDAF,IODA,X(LVEC),L3,534,0)
      CALL DCOPY(L1*L0MBS,X(LVEC),1,X(LVECCOL),1)
C
C     FINISH EXTERNAL ORBITAL FILES.
C     --NOTE1:  NEVER-EVER-EVER OVER-WRITE DAF 528.
C               528 IS FOR THE "INTERNALS" PROJECT.
C     --NOTE2:  FILE 535 WILL CONTAIN ONLY EXTERNAL ATOM LABELS.
C               WE MUST THROW OUT THE MBS SVD ATOM LABELS.
C               LATER, WE LEARN THE ATOM LABELS FOR ER,BOYS,ETC...
      IF(ISVDOP.EQ.100) THEN
        IFILE=540
        CALL LOCAL_READ_FILE528_WITH_CORES(IFILE,
     *                                     X(LIATSVD),NAT,NAOTOT,MASWRK)
        CALL VICLR(X(LIWRKP),1,L1)
        CALL ICOPY(L0FIN,X(LIATSVD),1,X(LIWRKP),1)
        GO TO 789
      ENDIF
      CALL VICLR(X(LIWRK),1,L1)
      CALL ICOPY(L0FIN,X(LIWRKP),1,X(LIWRK),1)
      CALL REORDR(X(LVECCOL),X(LIWRK),L0FIN,L1)
      IFILE=540
      CALL LOCAL_READ_FILE528_WITH_CORES(IFILE,
     *                                   X(LIATSVD),NAT,NAOTOT,MASWRK)
      CALL ICOPY(L0FIN,X(LIWRKP),1,X(LIWRK),1)
      CALL IREORDR(X(LIATSVD),X(LIWRK),L0FIN,1)
      CALL ICOPY(L0FIN,X(LIWRKP),1,X(LIWRK),1)
      CALL REORDR(X(LSAVWGT2),X(LIWRK),L0FIN,1)
      CALL VICLR(X(LIWRKP),1,L1)
      CALL ICOPY(L0FIN,X(LIATSVD),1,X(LIWRKP),1)
  789 CONTINUE
      CALL DAWRIT(IDAF,IODA,X(LVECCOL),L3,534,0)
      CALL DAWRIT(IDAF,IODA,X(LIWRKP),L1,535,1)
C
C     CHECK FOR ORTHONORMAL FINAL ORBITALS.
      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      CALL LOCAL_CHECK_ORTHOG(
     *           L0FIN,L1,L2,
     *           X(LS2),X(LS),X(LVECCOL),X(LWRK),
     *           MASWRK,IW)
C
C     WRITE ATOM LABELS OFF TO .DAT FILE.
      CALL DAREAD(IDAF,IODA,X(LIWRKP),L1,535,1)
      CALL LOCAL_DAT_ATOMS(
     *     L1,L0FIN,L0MBS+1,X(LIWRKP),IP,MASWRK,IW)
C
C     SAVE THE ALL-MIGHTY L0DEP0.
      L0DEP0=L0FIN
C
C     WRITE ORBITALS OUT TO EVERYWHERE.
      IF(SOME) THEN
        WRITE(IW,9070)
        WRITE(IW,9071) L0FIN
        CALL PRSQL(X(LVECCOL),L0FIN,L1,L1)
      ENDIF
      IF(MASWRK) THEN
        WRITE(IP,9080)
        CALL PUSQL(X(LVECCOL),L0FIN,L1,L1)
        WRITE(IP,9085)
      ENDIF
C
C
C
C     DEALLOCATE MEMORY.
      CALL RETFM(NEED_NOS_EXT)
C
C     RESTORE MOLECULAR SYMMETRY NOW.
      CALL SYMON
C
C     FINISH UP.
 8999 CONTINUE
      IF(SOME) THEN
        WRITE(IW,9300)
        CALL TIMIT(1)
      ENDIF
      RETURN
 9000 FORMAT(/5X,60(1H-)/
     *   5X,'LOCAL_NOS_EXT NOW FORMS EXTERNAL LOCALIZED NOS.'/
     *   5X,60(1H-))
 9003 FORMAT(//1X,'LOCAL_NOS_EXT ERROR:',
     *        /1X,'DID NOT RUN THROUGH VVOS ROUTINE.',
     *        /1X,'NEED ISVDOP=10 OR IVVOS.NE.0 OR BOTH.')
 9004 FORMAT(//1X,'LOCAL_NOS_EXT ERROR:',
     *      /1X,'EXTLOC=ATMNOS REQUIRES EXTERNAL ORBITALS.')
 9005 FORMAT(//1X,'LOCAL_NOS_EXT ERROR:',
     *       /1X,'ANY GIVEN EXTLOC OPTION CANNOT HAVE ILOCAL=4.')
 9055 FORMAT(/1X,'LOCAL_NOS_EXTSVD1:',
     *        1X,'LOCATES ALL VALENCE SVD ORBITALS.',
     *       /1X,'LOCAL_NOS_EXTSVD1:',
     *        1X,'ORDERS SVD ORBITALS AND DENSITIES INTO',
     *      /20X,'THE ORDER OF THE HIGH QUALITY VVOS AOS.')
 9070 FORMAT(//10X,'ORDERED EXTERNAL LOCALIZED ORBITALS')
 9071 FORMAT(10X,I5,1X,'ORBITALS ARE SHOWN.')
 9080 FORMAT('ORDERED EXTERNAL LOCALIZED ORBITALS'/' $VEC')
 9085 FORMAT(' $END')
 9300 FORMAT(1X,'... DONE WITH LOCAL_NOS_EXT ...')
      END
C*MODULE LOCAL   *DECK LOCAL_NOS_EXTSVD2
C> @brief      Forms ordered externals.
C>
C> @author     Aaron West
C>             -August 02, 2013
C>
C> @note       This routine is a major re-write for
C>             forming ordered external orbitals.
C>             Now, the method is decided on, and many
C>             extraneous items are stripped out.
C>             Various tests show that results do not change.
C>
C> @param NAOTOT   is the length of the MO spherical space.
C>                 ...unless it was changed again.
C> @param L0       is the length of the MO VARIATIONAL spherical space.
C> @param L0FIN    is the length of the reduced MO spherical space.
C> @param L1       is the length of the AO coefficients.
C> @param L2       is the triangular length of L1.
C> @param L3       is the square of L1.
C> @param L0MBS    is the dimension of the minimal basis set number of
C>                 orbitals.
C>                 L0MBS is derived from NCORTOT+LOCAL_NUMVAL.
C> @param NAT      is the number of atoms.
C> @param NINTMX   should be NTINMX from intfil common.
C> @param IPOSMBS  denotes the integer array that holds the starting
C>                 position for the 1st VALENCE MBS AO on a given atom.
C>                 These are in atomic order from the input
C>                 as usual.
C>                 I emphasize the CORE+VALENCE part.
C> @param ILENMBS  gives the number of VALANEC MBS orbitals.
C> @param IATSVD   is an array from the SVD run itself
C>                 that contains atom-orbital correspondences.
C>                 In runs that experience linear dependence,
C>                 IATSVD must be reordered in this routine.
C>                 Then, DAF540 must be re-written outside right
C>                 outside of this but only into the 'valence'.
C> @param IPOSEXT  indicates the orbital index for the first external
C>                 orbital on a given atom in the 1st column.
C>                 In the 2nd column, this integer array indicates
C>                 the total number of external orbitals on a given atom.
C>                 The orbitals are contiguous so that a L0*NAT array
C>                 does not have to given at this time...
C> @param LIMSUP   array contains the upper basis function on an atom.
C> @param LIMLOW   array contains the lower basis function on an atom.

C> @param OCCIMO   contains the occupations of the internal valence
C>                 canonical quasi-atomic orbitals in DAF521.
C> @param S        contains the AO overlaps of length L2.
C> @param S2       is scratch of length L2.
C> @param SWRK     is scratch of length L2.
C> @param SVMBS    holds the SV product of the MBS orbitals
C>                 from the VVOS but in the current
C>                 basis set.
C> @param VEC539   contains the orbitals from DAF539.
C> @param VECCOL   will contain the final ordered external orbitals.
C> @param VEC      is scratch of length L1xL1.
C> @param EIG      is scratch of length L1.
C> @param SAVWGT   will hold the atom-by-atom weights.
C> @param SAVWGT2  will hold the resultant, final weights.
C> @param IWRK     is integer scratch of length L1.
C> @param WRK      is scratch array of length L1*8.
C> @param VWRK1    is scratch array of L1xL1 length.
C> @param VWRK2    is scratch array of L1xL1 length.
C> @param VWRK3    is scratch array of L1xL1 length.
C> @param VWRK4    is scratch array of L1xL1 length.
C> @param NOPK     indicates supermatrix form or not for
C>                 the AO integrals.
C> @param BUFFX    is scratch of length NINTMX.
C> @param BUFFI    is scratch of length NINTMX.
C> @param IWRKP    is an integer array of L1 length.
C>                 This array might hold orbital
C>                 reordering instructions.
C> @param IWRK3    is an integer array of L3 length.
C> @param SOME     is true for master process
C>                 with nprint not equal -5.
C> @param IW       indicates write out to the log file.
      SUBROUTINE LOCAL_NOS_EXTSVD2(
     *     NAOTOT,L0,L0FIN,L1,L2,L3,L0MBS,NAT,NINTMX,
     *     IPOSMBS,ILENMBS,IATSVD,IPOSEXT,
     *     LIMSUP,LIMLOW,
     *     OCCIMO,
     *     S,S2,SWRK,SVMBS,
     *     VEC539,VECCOL,VEC,
     *     EIG,SAVWGT,SAVWGT2,
     *     IWRK,WRK,VWRK1,VWRK2,VWRK3,VWRK4,
     *     NOPK,BUFFX,BUFFI,
     *     IWRKP,
     *     IWRK3,
     *     SOME,IW)
      IMPLICIT NONE
      LOGICAL SOME,ATWGT,EXTRA_PRINT,ALINDEP
      INTEGER IW,
     *        NAOTOT,L0,L0FIN,L1,L2,L3,L0MBS,NAT,NINTMX,
     *        NOPK
      INTEGER IPOSMBS(NAT+1),ILENMBS(NAT),IATSVD(L1),
     *        IPOSEXT(NAT+1),
     *        LIMSUP(NAT),LIMLOW(NAT),
     *        IWRK(L1),IWRKP(L1),IWRK3(L3)
      DOUBLE PRECISION ::
     *       OCCIMO(L0MBS),
     *       S(L2),S2(L2),SWRK(L2),SVMBS(L1,L0MBS),
     *       VEC539(L1,L1),VECCOL(L1,L1),VEC(L1,L1),
     *       EIG(L1),SAVWGT(NAOTOT),SAVWGT2(NAOTOT),WRK(L1*8),
     *       VWRK1(L1,L1),VWRK2(L1,L1),VWRK3(L1,L1),VWRK4(L1,L1),
     *       BUFFX(NINTMX),BUFFI(NINTMX)
C
C
C---------------------------------------------------------------------
      DOUBLE PRECISION :: QMTTOL
      INTEGER ISPHER
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /BASSPH/ QMTTOL,ISPHER
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C----------------------------------------------------------------------
C
C
C     NON-FED-IN VARS NOW FOLLOW.
      LOGICAL SAVDSKWRK
      INTEGER IATM1,MAX_EXT_ORBS,
     *        IEXTORB,IEXTBEG,IEXTEND,IEXTTOT,IEXTORBF,
     *        IBAS1,IBAS2,ILTH,IBASSPH1,IBASSPH2,ILTHSPH,
     *        IKIND,
     *        ILOOP,NLOOP,ITMP,IDUM,
     *        I,J,ILEN,ISTOP,ILEN2,
     *        IEXTRI,IERR
      INTEGER IDAMAX,IXAMAX
      DOUBLE PRECISION :: TMP,TOL
C
C     SET UP TOL=QMTTOL
      TOL=ABS(QMTTOL)
C
C
C     FIND THE FIRST EXTERNAL ORBITAL ON EACH ATOM.
C     SAVE THE FIRST EXTERNAL ORBITAL POSITION INTO IPOSEXT.
      CALL LOCAL_IPOSEXT(
     *     IATSVD,IPOSEXT,
     *     NAT,L0MBS,NAOTOT,MAX_EXT_ORBS,
     *     MASWRK,IW)
C
C     CLEAR OUT ANY ARRAYS TO BE FILLED IN THE LOOP OVER ATOMS
      CALL VCLR(VECCOL,1,L3)
C
C     INITIALIZE IEXTTOT
      IEXTTOT=0
C
C
C
C     LOOP OVER ATOMS
      DO IATM1=1,NAT
        IF(SOME) WRITE(IW,9050) IATM1
C
C       GET NUMBER OF EXTERNALS.
C       GET EXTERNAL START POSITION.
        IEXTORB=0
        IEXTBEG=0
        IEXTEND=0
        CALL LOCAL_GET_IEXTORB(
     *       IEXTORB,IEXTBEG,IEXTEND,
     *       IPOSEXT,IATM1,NAT,NAOTOT,L0MBS,MASWRK,IW)
        IEXTTOT=IEXTTOT+IEXTORB
C
C       FORM S**(-1) FOR IATM1 FOR THE PROJECTION BELOW.
        CALL LOCAL_GRAB_BASIS_FXNS_ON_ATOM(
     *       LIMLOW,LIMSUP,IATM1,NAT,L2,
     *       S2,S,
     *       IBAS1,IBAS2,ILTH,
     *       IBASSPH1,IBASSPH2,ILTHSPH,
     *       .FALSE.)
        ALINDEP=.FALSE.
        IF(TOL.LE.1.0D-06) ALINDEP=.TRUE.
        IKIND=4
        CALL LOCAL_WEIGHTED_SYM_ORTHOG(
     *       IKIND,ILTH,S2,VWRK4,
     *       VWRK1,VWRK2,VWRK3,EIG,IWRK,WRK,
     *       L1,L3,L2,ALINDEP,
     *       IW,MASWRK)
C
C       FOR EACH ATOM,
C       FORM THE NORMALIZED PROJECTION OF THE AAMBS ORBITALS
C       ONTO THE CURRENT BASIS FUNCTIONS.
C       NOTE:  NEED THE RESULT IN VWRK1 FOR A BIT IN THIS SECTION.
        CALL VCLR(VWRK2,1,L3)
        CALL VCLR(EIG,1,L1)
        CALL VCLR(S2,1,L2)
        NLOOP=0
        NLOOP=ILENMBS(IATM1)
        IF(NLOOP.LE.0) THEN
          IF(MASWRK) WRITE(IW,9070)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
C--------
        DO ILOOP=1,NLOOP
          ITMP=IPOSMBS(IATM1)
          ITMP=ITMP+(ILOOP-1)
          CALL MRARBR(VWRK1,L1,ILTH,ILTH,
     *                SVMBS(IBAS1,ITMP),L1,1,
     *                VWRK2(IBAS1,ILOOP),L1)
C----------
          EIG(ILOOP)=OCCIMO(ITMP)
          IF(EIG(ILOOP).LT.0.0D+00) THEN
            IF(MASWRK) WRITE(IW,9080)
            CALL FLSHBF(IW)
            CALL ABRT
            STOP
          ENDIF
C----------
          CALL TFTRI(S2,S,VWRK2(1,ILOOP),IWRK,1,L1,L1)
          TMP=S2(1)
          TMP=1.0D+00/SQRT(TMP)
          CALL DSCAL(L1,TMP,VWRK2(1,ILOOP),1)
C----------
        ENDDO
C--------
CKEEPC
CKEEPC       VIEW THE INTERNAL ORBITALS ON EACH ATOM.
CKEEP        IF(MASWRK) THEN
CKEEP          WRITE(IW,*) 'INT LOCAL_NOS_EXT ATOM=',IATM1
CKEEP          WRITE(IW,9900)
CKEEP          CALL PRSQL(VWRK2,NLOOP,L1,L1)
CKEEP        ENDIF
C
C       FOR THE PROJECTED NORMALIZED AAMBS ORBITALS,
C       CONSTRUCT THE DENSITY IN THE AO BASIS.
C       NOTE:  NEED THE RESULT IN VWRK2 FOR A BIT IN THIS SECTION.
        IF(SOME) WRITE(IW,9090) NLOOP
        CALL VCLR(S2,1,L2)
        CALL DMTX(S2,VWRK2,EIG,NLOOP,L1,L1)
C
C       GRAB OUT THE EXTERNALS ON A GIVEN ATOM.
        CALL VCLR(VEC,1,L3)
        DO I=1,IEXTORB
          ITMP=IEXTBEG+I-1
          CALL DCOPY(L1,VEC539(1,ITMP),1,VEC(1,I),1)
        ENDDO
C
C       FORM 2 EL EXCHANGE INTEGRALS FOR EXTERNALS ON IATM1.
C       NOTES:  INPUTS=VEC,S2
C               OUTPUTS=S2
        SAVDSKWRK=DSKWRK
        DSKWRK=.TRUE.
        CALL LOCAL_NOS_ACAVO(
     *       VEC,SWRK,S2,
     *       VWRK1,VWRK2,VWRK3,VWRK4,
     *       WRK,BUFFX,BUFFI,
     *       NOPK,NINTMX,L1,L2,
     *       NLOOP,IEXTORB)
        DSKWRK=SAVDSKWRK
C
C       FOR EACH ATOM:
C       --ARRANGE FROM HIGHEST TO LOWEST EIGENVALUE.
C       --DIAGONALIZE EXTERNAL EXCHANGE MATRIX
C       --REVERSE THE SIGN CHANGE.
C       --TRANSFORM THE ORBITALS.
        CALL VCLR(EIG,1,L1)
        CALL VCLR(VWRK1,1,L3)
        CALL VCLR(VWRK2,1,L3)
        IERR=0
        ILEN=IEXTORB
        ILEN2=(ILEN*ILEN+ILEN)/2
        DO I=1,ILEN2
          S2(I)=-S2(I)
        ENDDO
        CALL GLDIAG(L1,ILEN,ILEN,S2,WRK,EIG,VWRK1,IERR,IWRK)
        IF(IERR.GT.0) THEN
          IF(MASWRK) WRITE(IW,9100)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
        IERR=0
        DO I=1,ILEN
          EIG(I)=-EIG(I)
          IF(EIG(I).LT.0.0D+00) IERR=IERR+1
        ENDDO
        IF(IERR.NE.0) THEN
          IF(MASWRK) WRITE(IW,9110)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
        DO I=1,IEXTORB
          CALL DCOPY(L1,VEC(1,I),1,VWRK2(1,I),1)
        ENDDO
        CALL MRARBR(VWRK2,L1,L1,ILEN,
     *              VWRK1,L1,ILEN,
     *              VEC,L1)
C
C       PRINT OFF THE OCCUPATIONS.
C       --DON'T TRY TO MODIFY THIS NEXT PIECE...
        ILEN=IEXTORB
        ISTOP=5
        IF(ILEN.LE.5) ISTOP=ILEN
        IF(SOME) WRITE(IW,9120) (EIG(I),I=1,ISTOP)
        IF(ILEN.GT.5) THEN
          DO J=6,ILEN,5
            ISTOP=J+4
            IF(ISTOP.GT.ILEN) ISTOP=ILEN
            IF(SOME) WRITE(IW,9121) (EIG(I),I=J,ISTOP)
          ENDDO
        ENDIF
C
C       THE WEIGHTS IN EIG ARE NOT COMPARABLE ACROSS ATOMS.
C       FOR EACH ATOM, RESET EIG TO RANGE FROM 0 TO 1.
C       NOTE:
C       FOR EACH ATOM,
C       SET 2ND FALSE BELOW TO TRUE TO PRINT THE NEW WEIGHTS.
        IF(SOME) WRITE(IW,9150)
        ATWGT=.TRUE.
        CALL LOCAL_WSO_PREP(
     *       EIG,IEXTORB,ATWGT,.FALSE.,IW)
C
C       SAVE THE NEW WEIGHTINGS FOR LATER.
        IF(IATM1.EQ.1) CALL VCLR(SAVWGT,1,NAOTOT)
        ITMP=IEXTTOT
        ITMP=ITMP-IEXTORB+1
        CALL DCOPY(IEXTORB,EIG,1,SAVWGT(ITMP),1)
C
C       SAVE OUT THE NEW EXTERNAL ORBITALS.
        ITMP=IEXTTOT
        ITMP=ITMP-IEXTORB
        DO I=1,IEXTORB
          ITMP=ITMP+1
          CALL DCOPY(L1,VEC(1,I),1,VECCOL(1,ITMP),1)
        ENDDO
C
C
C
C     END LOOP OVER ATOMS
      ENDDO
C
CLINDEP
CLINDEP
CLINDEP
CLINDEP
C
C     SHRINK ORBITAL TRANSFORMATION:  PART 6
C     ---SKIP IF L0=NAOTOT
C     ---PERFORM KR'S CRITERION WITH THE DISJUNCT SUMMATION.
C     ---IF CRITERION FAILS, ALSO PERFORM REMOVAL OF SMALL SVD EVALUES.
      L0FIN=L0
      IF(L0.EQ.NAOTOT) GO TO 1000
      CALL DCOPY(L3,VECCOL,1,VWRK1,1)
      IF(IEXTTOT.NE.NAOTOT-L0MBS) THEN
        IF(MASWRK) WRITE(IW,9160)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
      IEXTORBF=0
      L0FIN=0
      CALL LOCAL_CLINDEP(
     *     IEXTTOT,IEXTORBF,NAOTOT,L0MBS,L0,L1,L2,L3,
     *     VWRK1,VWRK2,TOL,
     *     S,S2,VWRK3,WRK,EIG,IWRK,IWRK3,
     *     SOME,MASWRK,IW)
C
C     SHRINK ORBITAL TRANSFORMATION:  PART 7
C     ---CREATE A BRAND NEW SUPER AWESOME "L0"s.
      L0FIN=L0MBS+IEXTORBF
C
C     SHRINK ORBITAL TRANSFORMATION:  PART 8
C     ---PERFORM CLINDEP REORDERING.
C     NOTE:  NOT YET THE REDUCED SPACE...
      IDUM=0
      CALL DCOPY(L3,VECCOL,1,VWRK2,1)
      CALL OVLSEL(VWRK2,EIG,VWRK1,S,
     *            VWRK3,IWRK,VWRK4,IWRK,
     *            IDUM,IDUM,NAOTOT,L1,L2,.FALSE.,IEXTTOT)
      CALL VCLR(VWRK1,1,L3)
      CALL VCLR(VWRK2,1,L3)
CLINDEP    similar to local_sort_svdeig
C     SORT OVER EXTERNAL ORBITALS ONLY.
      CALL ICOPY(L1,IWRK,1,IWRKP,1)
      CALL REORDR(VECCOL,IWRKP,IEXTTOT,L1)
      CALL ICOPY(L1,IWRK,1,IWRKP,1)
      CALL REORDR(SAVWGT,IWRKP,IEXTTOT,1)
      CALL ICOPY(L1,IWRK,1,IWRKP,1)
      CALL REORDR(SAVWGT2,IWRKP,IEXTTOT,1)
C     SORT OVER ALL ORBITALS.
      CALL ICOPY(L1,IWRK,1,IWRKP,1)
      CALL VICLR(IWRK,1,L1)
      DO I=1,IEXTTOT
        IWRK(L0MBS+I)=L0MBS+IWRKP(I)
      ENDDO
      DO I=1,L0MBS
        IWRK(I)=I
      ENDDO
      CALL ICOPY(L1,IWRK,1,IWRKP,1)
      CALL IREORDR(IATSVD,IWRKP,NAOTOT,1)
      CALL ICOPY(L1,IWRK,1,IWRKP,1)
      CALL IREORDR(VEC539,IWRKP,NAOTOT,L1)
CLINDEP
      CALL VICLR(IWRK,1,L1)
      CALL VICLR(IWRKP,1,L1)
C
C     SHRINK ORBITAL TRANSFORMATION:  PART 9
C     ---THE ORDERING SCHEME IS COMPLEX AND CONFUSING.
C        IN ORDER TO ELIMINATE ERRORS,
C        E.G. IN OUTSIDE SORTING ROUTINES,
C        WE NOW DESTROY UPPER ORBITALS AND WEIGHTS.
      DO I=IEXTORBF+1,IEXTTOT
        CALL VCLR(VEC539(1,I),1,L1)
        CALL VCLR(VECCOL(1,I),1,L1)
        SAVWGT(I)=0.0D+00
        SAVWGT2(I)=0.0D+00
      ENDDO
CLINDEP
CLINDEP
CLINDEP
CLINDEP
C
C------------------------------------------------
C     PRINT WEIGHTS STUFF.
 1000 CONTINUE
C------------------------------------------------
C
C     CONVERT THE WEIGHTS IN SAVWGT ARRAY.
C     STORE RESULTS IN SAVWGT2 ARRAY.
      CALL DCOPY(L0FIN,SAVWGT,1,SAVWGT2,1)
      ATWGT=.FALSE.
      CALL LOCAL_WSO_PREP(
     *     SAVWGT2,L0FIN-L0MBS,ATWGT,SOME,IW)
C
C     GIVE AN EXTRA PRINTING WHEN MORE GRAPHS ARE NEEDED.
      EXTRA_PRINT=.FALSE.
      IF(EXTRA_PRINT) THEN
        IF(SOME) WRITE(IW,9170)
        DO I=1,L0FIN-L0MBS
          IF(SOME)
     *    WRITE(IW,*) "WSO I,SAV1,SAV2 =",I,SAVWGT(I),SAVWGT2(I)
        ENDDO
        IF(SOME) WRITE(IW,9180)
        CALL DCOPY(L0FIN-L0MBS,SAVWGT2,1,WRK,1)
        DO I=1,L0FIN-L0MBS
          ITMP=IDAMAX(L0FIN-L0MBS,WRK,1)
          IF(SOME)
     *    WRITE(IW,*) "WSO I,SAV1,SAV2 =",I,SAVWGT(ITMP),SAVWGT2(ITMP)
          WRK(ITMP)=0.0D+00
        ENDDO
      ENDIF
C
C------------------------------------------------
C     END OF PRINT WEIGHTS STUFF.
C------------------------------------------------
C
C     PERFORM WEIGHTED SYMMETRIC ORTHOGONALIZATION.
C     --COPY VECCOL INTO VEC.
C     --FORM THE OVERLAP BETWEEN THE EXTERNAL ORBITALS.
C     --COPY THE WEIGHTS OUT FROM SAVWGT2 TO BE SAFE.
C     --FIND THE SIZE OF THE NEEDED MATRIX.
C     --OBTAIN THE TRANSFORMATION MATRIX.
C     --TRANSFORM THE EXTERNAL ORBITALS.
C     --REPLACE VECCOL BY THE NEW ORBITALS.
      CALL DCOPY(L3,VECCOL,1,VEC,1)
      CALL VCLR(S2,1,L2)
      CALL TFTRI(S2,S,VEC,WRK,L0FIN-L0MBS,L1,L1)
      CALL VCLR(WRK,1,L1*8)
      CALL DCOPY(L0FIN,SAVWGT2,1,WRK,1)
      IEXTRI=L0FIN-L0MBS
      IEXTRI=(IEXTRI*IEXTRI+IEXTRI)/2
C     WANT WEIGHTED S ** -1/2 HERE...
      IKIND=1
      CALL LOCAL_WEIGHTED_SYM_ORTHOG(
     *     IKIND,L0FIN-L0MBS,S2,WRK,
     *     VWRK1,VWRK2,VWRK3,EIG,IWRK,VWRK4,
     *     L1,L3,IEXTRI,.TRUE.,
     *     IW,MASWRK)
      CALL MRARBR(VEC,L1,L1,L0FIN-L0MBS,
     *            VWRK1,L1,L0FIN-L0MBS,
     *            VECCOL,L1)
C
C     NOW, SHIFT THE VECCOL VECTORS TO THE CORRECT EXTERNAL POSITIONS.
      CALL DCOPY(L3,VECCOL,1,VEC,1)
      CALL VCLR(VECCOL,1,L3)
      ITMP=0
      DO I=L0MBS+1,L0FIN
        ITMP=ITMP+1
        CALL DCOPY(L1,VEC(1,ITMP),1,VECCOL(1,I),1)
      ENDDO
C
C     CONSTRUCT THE IWRKP ARRAY BEFORE LEAVING.
      CALL VCLR(WRK,1,L1*8)
      DO I=1,L0FIN-L0MBS
        WRK(L0MBS+I)=SAVWGT2(I)
      ENDDO
      CALL VICLR(IWRKP,1,L1)
      DO I=L0MBS+1,L0FIN
        ITMP=IDAMAX(L0FIN,WRK,1)
        WRK(ITMP)=0.0D+00
        IWRKP(I)=ITMP
      ENDDO
      DO I=1,L0MBS
        IWRKP(I)=I
      ENDDO
C
C-------------------------------------------------------------
C     NEED TO FINISH MAKING VECCOL RIGHT AFTER THIS ROUTINE...
C-------------------------------------------------------------
C
      RETURN
 9050 FORMAT(/1X,'LOCAL_NOS_EXTSVD2 PREPARES ORBITALS',
     *        1X,'ON ATOM NUMBER=',I5)
 9070 FORMAT(/1X,'LOCAL_NOS_EXTSVD2 ERROR:',
     *       /1X,'NLOOP CANNOT BE 0.')
 9080 FORMAT(/1X,'LOCAL_NOS_EXTSVD2 ERROR:',
     *       /1X,'OCCIMO IS LESS THAN ZERO.',
     *       /1X,'ATOMIC INDEXING INSIDE OF',
     *        1X,'LOCAL_NOS_EXTSVD1 HAS BROKEN DOWN.')
 9090 FORMAT(/1X,'LOCAL_NOS_EXTSVD2:',
     *        1X,'PREPARING AO DENSITY FROM',I5,
     *        1X,'VALENCE ORBITALS.')
 9100 FORMAT(/1X,'LOCAL_NOS_EXTSVD2 ERROR:',
     *       /1X,'DIAGONALIZATION OF THE EXCHANGE FAILED.')
 9110 FORMAT(/1X,'LOCAL_NOS_EXTSVD2 ERROR:',
     *       /1X,'ALL EXCHANGE EVALUES SHOULD BE POSITIVE.')
 9120 FORMAT(//1X,'LOCAL_NOS_EXT YIELDS EVALUES =',10F6.3//)
 9121 FORMAT(31X,10F6.3)
 9150 FORMAT(/1X,'LOCAL_WSO_PREP NOW SCALES THE WEIGHTS',
     *        1X,'ON THE GIVEN ATOM.')
 9160 FORMAT(/1X,'LOCAL_NOS_EXTSVD2 ERROR:',
     *        1X,'IEXTTOT DOES NOT EQUAL NAOTOT MINUS L0MBS.')
 9170 FORMAT(/1X,'LOCAL_NOS_EXTSVD2:',
     *       /1X,'THE 2 SETS OF WEIGHTS ARE NOW PRINTED',
     *        1X,'TOGETHER IN ATOM ORDER.')
 9180 FORMAT(/1X,'LOCAL_NOS_EXTSVD2:',
     *       /1X,'THE 2 SETS OF WEIGHTS ARE NOW PRINTED',
     *        1X,'TOGETHER IN INCREASING ORDER.')
CKEEP 9900 FORMAT(//10X,'ATOM-SET LOCALIZED ORBITALS')
      END
C*MODULE LOCAL   *DECK LOCAL_WEIGHTED_SYM_ORTHOG
C> @brief      Forms (half-)inverse of matrix but with weights.
C>
C> @author     Aaron West and Klaus Ruedenberg
C>             -March 21, 2013
C>
C> @details    FOR THE WEIGHTED VERSION,
C>             S**-1/2  --> W * (WSW)**-1/2
C>             where the weights W cannot be zero.
C>             It is the user's responsibility to make
C>             sure that the weights being fed into this
C>             routine make sense.
C>
C> @param IKIND   is for inverse or -1/2 power.
C>                IKIND=1 --> -1/2 power with possible weightings
C>                IKIND=2 --> inverse with possible weightings
C>                IKIND=3 --> -1/2 power with no possible weightings
C>                IKIND=4 --> -1 power with no possible weightings
C> @param ILTH    is the length of the matrix to be diagonalized.
C> @param VTMP    is a scratch array of L1xL1.
C> @param WGT     is the array of weights for the
C>                symmetric orthogonalization.
C> @param S       is the overlap matrix of interest in symmetric form.
C>                This needs to be fed in.
C> @param VTMP2   is a scratch array of L1xL1.
C> @param UVEC    is a scratch array of L1xL1.
C> @param EIG     is a scratch array of length L1 for the eigenvalues.
C> @param IWRK    is a integer scratch array of length L1.
C> @param WRK     is a work array of length L1x8.
C> @param L1      is the length of the AO basis.
C> @param L3      is L1xL1.
C> @param L2      is the triangular length of L1.
C> @param ALINDEP is a logical that controls errors
C>                for small eigenvalues.
C> @param IW      indicates write out to the log file.
C> @param MASWRK  is true for master process.
C> @param SOME    is true for master process with nprint not equal -5.
C>
      SUBROUTINE LOCAL_WEIGHTED_SYM_ORTHOG(
     *           IKIND,ILTH,S,WGT,
     *           VTMP,VTMP2,UVEC,EIG,IWRK,WRK,
     *           L1,L3,L2,ALINDEP,
     *           IW,MASWRK)
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER IW,ILTH,L1,L2,L3,IKIND
      DOUBLE PRECISION ::
     *       S(L2),VTMP(L1,L1),WGT(ILTH),
     *       VTMP2(L1,L1),UVEC(L1,L1),EIG(L1),WRK(L1,8)
      INTEGER IWRK(L1)
C----------------------------------------------------------
      LOGICAL ALINDEP
      INTEGER I,J,IJ,IERR2,IERR3
      DOUBLE PRECISION :: TMP,TOL,ONE
      PARAMETER (ONE=1.0D+00)
C----------------------------------------------------------
      DOUBLE PRECISION :: QMTTOL
      INTEGER ISPHER
      COMMON /BASSPH/ QMTTOL,ISPHER
C----------------------------------------------------------
C     SET THE TOLERANCE
      TOL=ABS(QMTTOL)
C----------------------------------------------------------
C----------------------------------------------------------
      IF(IKIND.EQ.3) GO TO 100
      IF(IKIND.EQ.4) GO TO 100
C----------------------------------------------------------
C----------------------------------------------------------
C
C     FORM WSW WITH THE WEIGHTS.
      DO I=1,ILTH
        DO J=1,I
          IJ=(I*I-I)/2+J
          TMP=WGT(J)*WGT(I)
          S(IJ)=TMP*S(IJ)
        ENDDO
      ENDDO
C
C     NOW, DIAGONALIZE THE MATRIX.
  100 CONTINUE
      CALL GLDIAG(L1,ILTH,ILTH,S,WRK,EIG,VTMP,IERR2,IWRK)
      IERR3=0
      DO I=1,ILTH
        IF(ALINDEP.AND.EIG(I).LT.TOL) IERR3=IERR3+1
        IF(IKIND.EQ.1.OR.IKIND.EQ.3) THEN
          EIG(I)=ONE/SQRT(EIG(I))
        ELSEIF(IKIND.EQ.2.OR.IKIND.EQ.4) THEN
          EIG(I)=ONE/EIG(I)
        ELSE
          IF(MASWRK) WRITE(IW,9003)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
      ENDDO
      IF(IERR2.GT.0.OR.IERR3.GT.0) THEN
        IF(MASWRK.AND.IERR2.GT.0) WRITE(IW,9004)
        IF(MASWRK.AND.IERR3.GT.0) WRITE(IW,9005)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      CALL VCLR(UVEC,1,L3)
      DO I=1,ILTH
        DO J=1,ILTH
          UVEC(I,J)=VTMP(J,I)
          UVEC(J,I)=VTMP(I,J)
        ENDDO
      ENDDO
      DO I=1,ILTH
        CALL DSCAL(ILTH,EIG(I),VTMP(1,I),1)
      ENDDO
      CALL VCLR(VTMP2,1,L3)
      CALL MRARBR(VTMP,L1,ILTH,ILTH,UVEC,L1,ILTH,VTMP2,L1)
      CALL DCOPY(L3,VTMP2,1,VTMP,1)
C----------------------------------------------------------
C----------------------------------------------------------
      IF(IKIND.EQ.3) RETURN
      IF(IKIND.EQ.4) RETURN
C----------------------------------------------------------
C----------------------------------------------------------
C     FORM W * (WSW)**-1/2.
      DO I=1,ILTH
        DO J=1,ILTH
          TMP=WGT(I)
          VTMP(I,J)=TMP*VTMP(I,J)
        ENDDO
      ENDDO
C
      RETURN
 9003 FORMAT(//1X,'LOCAL_WEIGHTED_SYM_ORTHOG ERROR:',
     *        /1X,'YOU REQUESTED AN IKIND THAT DOES NOT EXIST.')
 9004 FORMAT(//1X,'LOCAL_WEIGHTED_SYM_ORTHOG ERROR:',
     *        /1X,'PROBLEM IN GLDIAG.')
 9005 FORMAT(//1X,'LOCAL_WEIGHTED_SYM_ORTHOG ERROR:',
     *        /1X,'SYMMETRIC ORTHOGONALIZATION',
     *         1X,'EVALUES ARE TOO SMALL.')
      END
C*MODULE LOCAL   *DECK LOCAL_IPOSEXT
C> @brief      Determines the max. num. of atomic ext. orbitals.
C>
C> @author     Aaron West
C>             -March 23, 2013
C>
C> @details    Determines the maximum number of atomic external
C>             orbitals.  This routine helps to avoid reseting
C>             idaf file sizes in this kind of run.
C>
C> @param IATSVD  holds the atom labels for all
C>                svd orbitals.
C> @param IPOSEXT indicates the orbital index for the first external
C>                orbital on a given atom in the 1st column.
C>                In the 2nd column, this integer array indicates
C>                the total number of external orbitals on a given atom.
C>                The orbitals are contiguous so that a L0*NAT array
C>                does not have to given at this time...
C> @param NAT     is the number of atoms.
C> @param L0MBS   is the dimension of the minimal basis set number of
C>                orbitals.
C>                L0MBS is derived from NCORTOT+LOCAL_NUMVAL.
C> @param L0             is the length of the MO variational space.
C> @param MAX_EXT_ORBS  will hold the max. size of the single
C>                       2s and ext. orbitals on an atom.
C> @param MASWRK       indicates the master process.
C> @param IW           indicates write out to the log file.
C>
      SUBROUTINE LOCAL_IPOSEXT(IATSVD,IPOSEXT,
     *                         NAT,L0MBS,L0,MAX_EXT_ORBS,
     *                         MASWRK,IW)
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER IERR,IOFF,IOFF2,IW,IMAX,I,J
      INTEGER MAX_EXT_ORBS,NAT,L0,L0MBS
      INTEGER IATSVD(L0)
      INTEGER IPOSEXT(NAT+1)
C
      IERR=0
      IMAX=0
      DO I=1,NAT
        IOFF=0
        IOFF2=0
        DO J=L0MBS+1,L0
          IF(IATSVD(J).EQ.I.AND.IOFF.EQ.0) IPOSEXT(I)=J
          IF(IATSVD(J).EQ.I) IOFF=IOFF+1
C-----------------------------------
C         SMALL CHECK ON INDEXING...
          IF(IOFF.GT.0.AND.IATSVD(J).NE.I) IOFF2=1
          IF(IOFF2.GT.0.AND.IATSVD(J).EQ.I) IERR=IERR+1
C-----------------------------------
        ENDDO
C       SAVE THE MAX VALUE ACROSS ALL ATOMS.
        IF(IOFF.GT.IMAX) IMAX=IOFF
      ENDDO
      IPOSEXT(NAT+1)=L0+1
C
C
      IF(IERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C
      MAX_EXT_ORBS=IMAX
C
      RETURN
 9000 FORMAT(//1X,'LOCAL_MAXNACT ERROR:',
     *        /1X,'EXTERNAL ORBITAL ATOM LABELS ARE NOT',
     *         1X,'CONTIGUOUS FOR SOME REASON.',
     *        /1X,'INTEGER ARRAYS WERE SET UP FOR THAT...')
      END
C*MODULE LOCAL   *DECK LOCAL_ATOMIC_HSANDT
C> @brief      Calculate atomic inverse radial expect. value
C>
C> @author     Aaron West
C>             -April 02, 2013
C>
C> @details    Calculate atomic nuclear attraction integrals
C>             but without the nuclear factor.
C>             i.e.  radial expectation values for the
C>                   atomic orbitals
C>             In order to compare with regular HSANDT code,
C>             I've put in a switch the nuc. attraction
C>             as summed over all atoms e.g. like in HSANDT.
C>             It is always good to check and verify.
C>
C> @note       I was told to make a separate routine.
C>             I can try to combine later if needed.
C>             This code is checked by reproducing the results
C>             from the original HSANDT routine by summing over atoms.
C>
C> @param H            will contain the nuclear attraction integrals
C>                     or atomic inverse radial expectation values
C>                     as chosen by ISVD_NUCINT and ISVD_ATOM with exit.
C> @param LL2          is the triangular dimesion of the 'working' NUM
C>                     from the INFOA.
C> @param ISVD_NUCINT  =1 gives original result from HSANDT
C>                      for the nuclear attraction integrals only
C>                      as summed over all atoms.
C>                     =2 gives the atomic radial expectation value
C>                      for the atomic orbitals relative to
C>                      atom ISVD_ATOM.
C> @param ISVD_ATOM     is the atom used in evaluating the integral.
C>
      SUBROUTINE LOCAL_ATOMIC_HSANDT(H,LL2,ISVD_NUCINT,ISVD_ATOM,
     *                               ISW_RADIAL)
      IMPLICIT NONE
C-----------------------------------------------------------------------
      INTEGER NONE
      DOUBLE PRECISION :: RNONE
      DATA NONE,RNONE/4HNONE,8HNONE    /
C-----------------------------------------------------------------------
      LOGICAL DOUBLE2
      DOUBLE PRECISION ::
     *       AA,AA1,AAX,AAY,AAZ,AI,AJ,ARRI,AX,AXI,AY,
     *       AYI,AZ,AZI,CX,CY,CZ,DTWO,DUM,FAC,FACI,RR,
     *       SPDIJ,TT,UU,WW,ZNUC
      INTEGER ISVD_NUCINT,ISVD_ATOM,ISW_RADIAL
      INTEGER IG,JG,I,I1,I2,IC,IEND,IJ,IN,IPCOUNT,ISTART,J,J0,
     *        J1,J2,JGMAX,JN,JSTART,K,L1,L2,LI,LJ,LL2,
     *        LOCI,LOCIJ,LOCJ,MAX,MM,NATED,NATST,NERR,
     *        NN,NN1,NX,NY,NZ
C-----------------------------------------------------------------------
      INTEGER MXSH,MXGTOT,MXATM,MAXSH
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000, MAXSH=84)
C-----------------------------------------------------------------------
C     VARS FOR COMMON BLOCKS NOW FOLLOW IN THE COMMON BLOCK ORDER.
C
      INTEGER NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
C
      INTEGER NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,IAN
      DOUBLE PRECISION :: ZAN,C
C
      INTEGER IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA
C
      LOGICAL ISEPS,USEPS
C
      DOUBLE PRECISION :: EX,CS,CP,CD,
     *                    CF,CG,CH,CI
      INTEGER KSTART,KATOM,KTYPE,KNG,
     *        KLOC,KMIN,KMAX,NSHELL
C
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION :: XX,U,W
      INTEGER NROOTS
C
      LOGICAL SCREEN
      DOUBLE PRECISION :: VLAMB
C
      DOUBLE PRECISION :: PNRM
C
      DOUBLE PRECISION :: XINT,YINT,ZINT,TAA,X0,Y0,Z0,
     *                    XI,YI,ZI,XJ,YJ,ZJ
      INTEGER NI,NJ
C
      DOUBLE PRECISION :: TOL
      INTEGER II,JJ,LIT,LJT,MINI,MINJ,MAXI,MAXJ
      LOGICAL IANDJ
C
      DOUBLE PRECISION :: RMETHOD,QRQMT,CLIG,CLIG2,QRTOL
      INTEGER IQRORD,MODQR,NESOC,NRATOM,NUMU,NQMTR,NQRDAF,MORDA,
     *        NDARELB
C
      DOUBLE PRECISION :: W1,W2,W3,W4,W5,W6,W7,
     *                    W8,W9,W10,
     *                    W11,W12,W13,W14,W15
C
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C-----------------------------------------------------------------------
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /ISEPS / ISEPS,USEPS
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /ROOT  / XX,U(13),W(13),NROOTS
      COMMON /SCINP / VLAMB,SCREEN
      COMMON /SHLNRM/ PNRM(84)
      COMMON /STV   / XINT,YINT,ZINT,TAA,X0,Y0,Z0,
     *                XI,YI,ZI,XJ,YJ,ZJ,NI,NJ
      COMMON /SYMIND/ TOL,II,JJ,LIT,LJT,MINI,MINJ,MAXI,MAXJ,IANDJ
      COMMON /RELWFN/ RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,IQRORD,MODQR,NESOC,
     *                NRATOM,NUMU,NQMTR,NQRDAF,MORDA,NDARELB
C                          JUST THE 1ST ELEMENT IS USED, W/O /HERMIT/
      COMMON /WERMIT/ W1,W2(2),W3(3),W4(4),W5(5),W6(6),W7(7),
     *                W8(8),W9(9),W10(10),
     *                W11(11),W12(12),W13(13),W14(14),W15(15)
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C-----------------------------------------------------------------------
      DOUBLE PRECISION :: ZERO,PT5,ONE,TWO,PI212,RLN10
      PARAMETER (ZERO=0.0D+00, PT5=0.5D+00, ONE=1.0D+00, TWO=2.0D+00,
     *           PI212=1.1283791670955D+00, RLN10=2.30258D+00)
C-----------------------------------------------------------------------
C     SOME ORIGINAL VARS GO HERE.
      DOUBLE PRECISION :: H(LL2),VBLK(784),DIJ(784),
     *                    XIN(343),YIN(343),ZIN(343),
     *                    CONI(MAXSH),CONJ(MAXSH)
      INTEGER IJX(784),IJY(784),IJZ(784),
     *        IX(84),IY(84),IZ(84),JX(84),JY(84),JZ(84)
C-----------------------------------------------------------------------
C
      DATA JX / 0, 1, 0, 0, 2, 0, 0, 1, 1, 0,
     *          3, 0, 0, 2, 2, 1, 0, 1, 0, 1,
     *          4, 0, 0, 3, 3, 1, 0, 1, 0, 2,
     *          2, 0, 2, 1, 1,
     *          5, 0, 0, 4, 4, 1, 0, 1, 0, 3,
     *          3, 2, 0, 2, 0, 3, 1, 1, 2, 2,
     *          1,
     *          6, 0, 0, 5, 5, 1, 0, 1, 0, 4,
     *          4, 2, 0, 2, 0, 4, 1, 1, 3, 3,
     *          0, 3, 3, 2, 1, 2, 1, 2/
      DATA IX / 1, 8, 1, 1,15, 1, 1, 8, 8, 1,
     *         22, 1, 1,15,15, 8, 1, 8, 1, 8,
     *         29, 1, 1,22,22, 8, 1, 8, 1,15,
     *         15, 1,15, 8, 8,
     *         36, 1, 1,29,29, 8, 1, 8, 1,22,
     *         22,15, 1,15, 1,22, 8, 8,15,15,
     *          8,
     *         43, 1, 1,36,36, 8, 1, 8, 1,29,
     *         29,15, 1,15, 1,29, 8, 8,22,22,
     *          1,22,22,15, 8,15, 8,15/
      DATA JY / 0, 0, 1, 0, 0, 2, 0, 1, 0, 1,
     *          0, 3, 0, 1, 0, 2, 2, 0, 1, 1,
     *          0, 4, 0, 1, 0, 3, 3, 0, 1, 2,
     *          0, 2, 1, 2, 1,
     *          0, 5, 0, 1, 0, 4, 4, 0, 1, 2,
     *          0, 3, 3, 0, 2, 1, 3, 1, 2, 1,
     *          2,
     *          0, 6, 0, 1, 0, 5, 5, 0, 1, 2,
     *          0, 4, 4, 0, 2, 1, 4, 1, 3, 0,
     *          3, 2, 1, 3, 3, 1, 2, 2/
      DATA IY / 1, 1, 8, 1, 1,15, 1, 8, 1, 8,
     *          1,22, 1, 8, 1,15,15, 1, 8, 8,
     *          1,29, 1, 8, 1,22,22, 1, 8,15,
     *          1,15, 8,15, 8,
     *          1,36, 1, 8, 1,29,29, 1, 8,15,
     *          1,22,22, 1,15, 8,22, 8,15, 8,
     *         15,
     *          1,43, 1, 8, 1,36,36, 1, 8,15,
     *          1,29,29, 1,15, 8,29, 8,22, 1,
     *         22,15, 8,22,22, 8,15,15/
      DATA JZ / 0, 0, 0, 1, 0, 0, 2, 0, 1, 1,
     *          0, 0, 3, 0, 1, 0, 1, 2, 2, 1,
     *          0, 0, 4, 0, 1, 0, 1, 3, 3, 0,
     *          2, 2, 1, 1, 2,
     *          0, 0, 5, 0, 1, 0, 1, 4, 4, 0,
     *          2, 0, 2, 3, 3, 1, 1, 3, 1, 2,
     *          2,
     *          0, 0, 6, 0, 1, 0, 1, 5, 5, 0,
     *          2, 0, 2, 4, 4, 1, 1, 4, 0, 3,
     *          3, 1, 2, 1, 2, 3, 3, 2/
      DATA IZ / 1, 1, 1, 8, 1, 1,15, 1, 8, 8,
     *          1, 1,22, 1, 8, 1, 8,15,15, 8,
     *          1, 1,29, 1, 8, 1, 8,22,22, 1,
     *         15,15, 8, 8,15,
     *          1, 1,36, 1, 8, 1, 8,29,29, 1,
     *         15, 1,15,22,22, 8, 8,22, 8,15,
     *         15,
     *          1, 1,43, 1, 8, 1, 8,36,36, 1,
     *         15, 1,15,29,29, 8, 8,29, 1,22,
     *         22, 8,15, 8,15,22,22,15/
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C     ----- COMPUTE CONVENTIONAL H, S, AND T INTEGRALS -----
C     NOTES:
C     --HSANDT ROUTINE WAS CHOPPED DOWN FOR THE
C       THE BARE NUCLEAR INTEGRALS... BUT SOME UN-SUMMED VERSIONS OF THEM.
C     --INDENTED WAS NOT FIXED DURING CHOPPING.
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C
C     ----- SET TOLERANCE TOL -----
C
      TOL = RLN10*ITOL
C
C     NOTE THAT LL2 IS ALWAYS (NUM*NUM+NUM)/2,
C
      ISTART = 1
      IEND   = NSHELL
      JSTART = 1
      LOCIJ  = 0
      IF(ISVD_NUCINT.EQ.1) THEN
        NATST  = 1
        NATED  = NAT
      ELSEIF(ISVD_NUCINT.EQ.2) THEN
        NATST=ISVD_ATOM
        NATED=ISVD_ATOM
      ELSE
      ENDIF
      L1 = NUM
      L2 = (L1*(L1+1))/2
C
C     ----- ERROR OUTS -----
C
      NERR=0
      IF(MPCTYP.NE.NONE) THEN
        IF (MASWRK) WRITE(IW,9010)
        NERR=NERR+1
      END IF
      IF(RMETHOD.NE.RNONE) THEN
        IF (MASWRK) WRITE(IW,9011)
        NERR=NERR+1
      END IF
      IF(LL2.NE.L2) THEN
        IF (MASWRK) WRITE(IW,9012)
        NERR=NERR+1
      END IF
      IF(NFG.NE.0) THEN
        IF (MASWRK) WRITE(IW,9013)
        NERR=NERR+1
      END IF
      IF(SCREEN) THEN
        IF (MASWRK) WRITE(IW,9014)
        NERR=NERR+1
      END IF
      IF(ISEPS) THEN
        IF (MASWRK) WRITE(IW,9015)
        NERR=NERR+1
      END IF
      IF(ISVD_NUCINT.NE.1.AND.ISVD_NUCINT.NE.2) THEN
        IF (MASWRK) WRITE(IW,9016)
        NERR=NERR+1
      ENDIF
      IF(ISVD_NUCINT.EQ.2) THEN
      IF(ISVD_ATOM.LT.1.OR.ISVD_ATOM.GT.NAT) THEN
        IF (MASWRK) WRITE(IW,9017)
        NERR=NERR+1
      ENDIF
      ENDIF
      IF(ISVD_NUCINT.EQ.1) THEN
      IF(ISVD_ATOM.NE.0) THEN
        IF (MASWRK) WRITE(IW,9018)
        NERR=NERR+1
      ENDIF
      ENDIF
      IF(NERR.GT.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
      ENDIF
C
C
C     DO WHEN PARALLEL OR NOT.
      CALL VCLR(H ,1,LL2)
C
C     ----- INTIALIZE PARALLEL -----
C
      IPCOUNT = ME - 1
C
C     ----- I SHELL -----
C
      DO 720 II = ISTART,IEND
         I = KATOM(II)
         XI = C(1,I)
         YI = C(2,I)
         ZI = C(3,I)
         I1 = KSTART(II)
         I2 = I1+KNG(II)-1
         LIT = KTYPE(II)
         MINI = KMIN(II)
         MAXI = KMAX(II)
         LOCI = KLOC(II)-MINI-LOCIJ
C
C     ----- J SHELL -----
C
         DO 700 JJ = JSTART,II
C
C     ----- GO PARALLEL! (STATIC LOAD BALANCING) -----
C
            IF (GOPARR) THEN
               IPCOUNT = IPCOUNT + 1
               IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 700
            END IF
C
            J = KATOM(JJ)
            XJ = C(1,J)
            YJ = C(2,J)
            ZJ = C(3,J)
            J1 = KSTART(JJ)
            J2 = J1+KNG(JJ)-1
            LJT = KTYPE(JJ)
            MINJ = KMIN(JJ)
            MAXJ = KMAX(JJ)
            LOCJ = KLOC(JJ)-MINJ-LOCIJ
            NROOTS = (LIT+LJT-2)/2+1
            RR = (XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
            IANDJ = II .EQ. JJ
C
C
C     ----- PREPARE INDICES FOR PAIRS OF (I,J) FUNCTIONS
C
            IJ = 0
            MAX = MAXJ
            DO 160 I = MINI,MAXI
               NX = IX(I)
               NY = IY(I)
               NZ = IZ(I)
               IF (IANDJ) MAX = I
               DO 140 J = MINJ,MAX
                  IJ = IJ+1
                  IJX(IJ) = NX+JX(J)
                  IJY(IJ) = NY+JY(J)
                  IJZ(IJ) = NZ+JZ(J)
  140          CONTINUE
  160       CONTINUE
C
            CALL VCLR( VBLK,1,IJ)
C
C     ----- I PRIMITIVE
C
            JGMAX = J2
            DO 520 IG = I1,I2
               AI = EX(IG)
               ARRI = AI*RR
               AXI = AI*XI
               AYI = AI*YI
               AZI = AI*ZI
               CALL SETCONI(CONI,IG,0)
C
C     ----- J PRIMITIVE
C
               IF (IANDJ) JGMAX = IG
               DO 500 JG = J1,JGMAX
                  AJ = EX(JG)
                  AA = AI+AJ
                  AA1 = ONE/AA
                  DUM = AJ*ARRI*AA1
                  IF (DUM .GT. TOL) GO TO 500
                  FAC = EXP(-DUM)
                  CALL SETCONI(CONJ,JG,0)
                  AX = (AXI+AJ*XJ)*AA1
                  AY = (AYI+AJ*YJ)*AA1
                  AZ = (AZI+AJ*ZJ)*AA1
C
C     ----- DENSITY FACTOR
C
C     THE ONLY REASON WHY -ILZ WORKS WITH THIS DENSITY THAT ASSUMES
C     HERMITICITY IS BECAUSE <I|-ILZ|I>=0 (MOMENTUM QUENCHING).
C
                  DOUBLE2=IANDJ.AND.IG.NE.JG
                  MAX = MAXJ
                  NN = 0
                  DTWO=ONE
                  IF(DOUBLE2) DTWO=TWO
C                 NOTE THAT PNRM FACTORS FOR S AND P SHELLS ARE 1.
                  SPDIJ=CS(IG)*CP(JG)*FAC
                  DO 220 I = MINI,MAXI
                     IF (IANDJ) MAX = I
                     FACI=FAC*CONI(I)*PNRM(I)*DTWO
                     NN1=NN+1
                     DO 200 J = MINJ,MAX
                        NN = NN+1
                        DIJ(NN)=FACI*CONJ(J)*PNRM(J)
C                    WRITE(6,*) 'WWWDIJ',NN,I,J,II,JJ,DIJ(NN)
  200                CONTINUE
C            CORRECT FOR L-SHELL DOUBLE COUNTING OF THE SP
C            OFF-DIAGONAL TERMS (FOR NON-L SHELLS CSI*CPJ IS ZERO).
C            NN1 POINTS TO THE APPROPRIATE DENSITY ELEMENT
                     IF(MINJ.LE.1.AND.I.GT.1.AND.DOUBLE2)
     *                 DIJ(NN1)=DIJ(NN1)*PT5+SPDIJ
  220             CONTINUE
C
C     ----- NUCLEAR ATTRACTION -----
C
                     DUM = PI212*AA1
                     DO 400 I = 1,IJ
                        DIJ(I) = DIJ(I)*DUM
  400                CONTINUE
C
                  AAX = AA*AX
                  AAY = AA*AY
                  AAZ = AA*AZ
C
                  AAX = AA*AX
                  AAY = AA*AY
                  AAZ = AA*AZ
                  DO 460 IC = NATST,NATED
                     ZNUC=1.0D+00
                     IF(ISVD_NUCINT.EQ.1) ZNUC = -ZAN(IC)
                     IF(ISW_RADIAL.EQ.1) THEN
                        ZNUC=1.0D+00
ccccc                        ZNUC=3.217D+00
ccccc                        ZNUC=4.492D+00
                     ENDIF
C
                     CX = C(1,IC)
                     CY = C(2,IC)
                     CZ = C(3,IC)
C
                     XX = AA*((AX-CX)**2+(AY-CY)**2+(AZ-CZ)**2)
                     IF (NROOTS.LE.3) CALL RT123
                     IF (NROOTS.EQ.4) CALL ROOT4
                     IF (NROOTS.EQ.5) CALL ROOT5
                     IF (NROOTS.GE.6) CALL ROOT6
                     MM = 0
                     DO 430 K = 1,NROOTS
                        UU = AA*U(K)
                        WW = W(K)*ZNUC
                        TT = ONE/(AA+UU)
                        TAA = SQRT(TT)
                        X0 = (AAX+UU*CX)*TT
                        Y0 = (AAY+UU*CY)*TT
                        Z0 = (AAZ+UU*CZ)*TT
                        IN = -7+MM
                        J0 = 2
C
C                       J0 SKIPS THE TRIVIAL COMBINATION NI=NJ=1
C                       THAT IS DONE EXPLICITLY NOW
C
                        XIN(IN+8) = W1
                        YIN(IN+8) = W1
                        ZIN(IN+8) = W1*WW
                        DO 420 I = 1,LIT
                           IN = IN+7
                           NI = I
                           DO 410 J = J0,LJT
                              JN = IN+J
                              NJ = J
                              CALL STVINT
                              XIN(JN) = XINT
                              YIN(JN) = YINT
                              ZIN(JN) = ZINT*WW
  410                      CONTINUE
                           J0 = 1
  420                   CONTINUE
                        MM = MM+49
  430                CONTINUE
                     DO 450 I = 1,IJ
                        NX = IJX(I)
                        NY = IJY(I)
                        NZ = IJZ(I)
                        DUM = ZERO
                        MM = 0
                        DO 440 K = 1,NROOTS
                           DUM = DUM+XIN(NX+MM)*YIN(NY+MM)*ZIN(NZ+MM)
                           MM = MM+49
  440                   CONTINUE
                        VBLK(I) = VBLK(I) + DUM*DIJ(I)
  450                CONTINUE
C
  460              CONTINUE
C
C     ----- END OF PRIMITIVE LOOPS -----
C
  500          CONTINUE
  520       CONTINUE
C
C     ----- SET BLOCK OF NUCLEAR ATTRACTION
C
            MAX = MAXJ
            NN = 0
            DO 620 I = MINI,MAXI
               LI = LOCI+I
               IN = (LI*(LI-1))/2
               IF (IANDJ) MAX = I
               DO 600 J = MINJ,MAX
                  LJ = LOCJ+J
                  JN = LJ+IN
                  NN = NN+1
                  H(JN) =  VBLK(NN)
  600          CONTINUE
  620       CONTINUE
C
C     ----- END OF SHELL LOOPS -----
C
  700    CONTINUE
  720 CONTINUE
C
C     ----- SUM UP PARTIAL CONTRIBUTIONS IF PARALLEL -----
C
      IF (GOPARR) THEN
         CALL DDI_GSUMF(910,H,L2)
      END IF
C
C     ----- H MATRIX IS NOW COMPLETE AND RETURNED.
C



      RETURN
 9010 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT IS NOT PROGRAMMED FOR MCPS.')
 9011 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT',
     *        1X,'IS NOT PROGRAMMED FOR RELATIVITY.')
 9012 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT IS NOT PROGRAMMED FOR',
     *        1X,'LL2 NE L2 CONDITIONS.')
 9013 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT IS NOT PROGRAMMED FOR FMO.')
 9014 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT',
     *        1X,'IS NOT PROGRAMMED FOR SCREEN=.TRUE.')
 9015 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT',
     *        1X,'IS NOT PROGRAMMED FOR ISEPS=.TRUE.')
 9016 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT MUST HAVE ISVD_NUCINT=1 OR 2.')
 9017 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT HAS ISVD_ATOM OUT OF RANGE.')
 9018 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT',
     *        1X,'HAS ISVD_ATOM NE 0 FOR ISVD_NUCINT.',
     *       /1X,'ISVD_ATOM HAS USE HERE... AND SHOULD BE 0.')
      END
C*MODULE LOCAL   *DECK LOCAL_GET_IEXTORB
C> @brief      Returns the num. of externals on atom.
C>
C> @author     Aaron West
C>             -May 07, 2013
C>
C> @details    This number might already be calculated in
C>             more complex routines or NOT...
C>
C> @param IEXTORB is returned as the total number of external
C>                orbitals on a given atom.
C> @param IPOSEXT indicates the orbital index for the first external
C>                orbital on a given atom in the 1st column.
C>                In the 2nd column, this integer array indicates
C>                the total number of external orbitals on a given atom.
C>                The orbitals are contiguous so that a L0*NAT array
C>                does not have to given at this time...
C> @param IEXTBEG gives the starting orbital number for externals
C>                on a given atom.
C> @param IEXTEND gives the ending orbital number for externals
C>                on a given atom.
C> @param IATM1   is the current atom in the do loop.
C> @param NAT     is the number of atoms.
C> @param L0      is the length of the MO variational space.
C> @param L0MBS   is the number of core+val minimal basis orbitals.
C> @param MASWRK  indicates the master process.
C> @param IW      indicates write out to the log file.
      SUBROUTINE LOCAL_GET_IEXTORB(
     *           IEXTORB,IEXTBEG,IEXTEND,
     *           IPOSEXT,IATM1,NAT,L0,L0MBS,MASWRK,IW)
C
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER NAT,IW,IEXTORB,IEXTBEG,IEXTEND,
     *        IERR,IATM1,L0,L0MBS,IPOSEXT(NAT+1)
C
      IEXTORB=IPOSEXT(IATM1+1)-IPOSEXT(IATM1)
      IEXTBEG=IPOSEXT(IATM1)
      IEXTEND=IPOSEXT(IATM1+1)-1
C
      IERR=0
      IF(IEXTORB.LE.0) THEN
        IF(MASWRK) WRITE(IW,9001)
        IERR=IERR+1
      ENDIF
      IF(IEXTORB.GT.L0) THEN
        IF(MASWRK) WRITE(IW,9002)
        IERR=IERR+1
      ENDIF
      IF(IEXTBEG.LE.L0MBS
     *   .OR.IEXTBEG.GT.L0
     *   .OR.IEXTEND.LE.L0MBS
     *   .OR.IEXTEND.GT.L0) THEN
        IF(MASWRK) WRITE(IW,9003)
        IERR=IERR+1
      ENDIF
      IF(IERR.NE.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9001 FORMAT(//1X,'LOCAL_IPOSEXT ERROR:',
     *        /1X,'IEXTORB CANNOT BE LESS THAN 0.')
 9002 FORMAT(//1X,'LOCAL_IPOSEXT ERROR:',
     *        /1X,'IEXTORB CANNOT BE GREATER THAN L0.')
 9003 FORMAT(//1X,'LOCAL_IPOSEXT ERROR:',
     *        /1X,'PROBLEM WITH IEXTBEG OR IEXTEND.')
      END
C*MODULE LOCAL   *DECK LOCAL_SORT_EVALS
C> @brief      Generally forms reorder array.
C>
C> @author     Aaron West
C>             -May 07, 2013
C>
C> @details    This routine generally forms an array
C>             with integer reordering instructions.
C>             The use of IDAMAX has a few limitations:
C>             1.  It only works with positive values.
C>             2.  Under specific conditions, shifting
C>                 can lead to some buggy code.
C>             In the atomic loc. code, we often need
C>             flexible indices in the arrays.
C>             This routine is similar to JACORD, but
C>             here we track and form an integer
C>             reordering array.
C>
C> @param IBEGn    is the starting index.
C>                 It does not have to 1.
C> @param IENDn    is the ending index.
C> @param LDIM     is the dimension which is often different.
C> @param IPOSNOS  is the integer sorting array.
C> @param EIG      contains the values that are used in the
C>                 sorting e.g. eigenvalues.
      SUBROUTINE LOCAL_SORT_EVALS(IBEGn,IENDn,LDIM,IPOSNOS,EIG)
      IMPLICIT NONE
      INTEGER IDUM,I,J,ITMP
      INTEGER IBEGn,IENDn,LDIM,IPOSNOS(LDIM)
      DOUBLE PRECISION :: TMP,EIG(LDIM)
C
      DO I=IBEGn,IENDn
        IPOSNOS(I)=I
      ENDDO
C
      DO I=IBEGn,IENDn
        IDUM=I
        DO J=I,IENDn
          IF(EIG(J).gt.EIG(IDUM)) IDUM=J
        ENDDO
C
        TMP=EIG(IDUM)
        EIG(IDUM) = EIG(I)
        EIG(I) = TMP
C
        ITMP=IPOSNOS(IDUM)
        IPOSNOS(IDUM)=IPOSNOS(I)
        IPOSNOS(I)=ITMP
      ENDDO
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_NOS_ACAVO
C> @brief      Calculate (s2**2)*i,j 2 el matrices for local nos.
C>
C> @author     Aaron West and Mike Schmidt
C>             -May 07, 2013
C>
C> @details    Right now, only exchange matrices are calculated.
C>             THIS ROUTINE IS BASED ON MIKE SCHMIDT'S AVACO ROUTINE.
C>             THIS ROUTINE IS AN EXTREMELY SPECIALIZED VERSION OF
C>             THE AVACO ROUTINE.
C>             PLEASE SEE AVACO ROUTINE FOR ADDITIONAL NOTES.
C>
C> @param VEC     contains the atomic-like orbitals for a given atom.
C> @param DCORE   is scratch of length L2.
C> @param DVAL    contains the needed AO density of length L2 on entry.
C> @param JCORE   is scratch of length L2.
C> @param JVAL    is scratch of length L2.
C> @param KCORE   is scratch of length L2.
C> @param KVAL    is scratch of length L2.
C> @param SCR     is scratch of length L1*8.
C> @param BUFFX   is scratch of length NINTMX.
C> @param BUFFI   is scratch of length NINTMX.
C> @param NOPK    indicates supermatrix form or not for
C>                the AO integrals.
C> @param NINTMX  should be NTINMX from intfil common.
C> @param L1      is the length of the AO coefficients.
C> @param L2      is the triangular length of L1.
C> @param NVAL    is the number of valence orbitals on a given atom.
C> @param IEXTORB is number of external orbitals on given atom.
      SUBROUTINE LOCAL_NOS_ACAVO(
     *           VEC,DCORE,DVAL,
     *           JCORE,JVAL,KCORE,KVAL,
     *           SCR,BUFFX,BUFFI,
     *           NOPK,NINTMX,L1,L2,
     *           NVAL,IEXTORB)
C
      IMPLICIT NONE
C-----------------------------------------------------------------------
      INTEGER L1,L2
      DOUBLE PRECISION :: FJC,FJV,FKC,FKV
      INTEGER NINTMX,NOPK,NVAL,IEXTORB
C-----------------------------------------------------------------------
      DOUBLE PRECISION :: JCORE(L2),JVAL(L2),KCORE(L2),KVAL(L2)
      DOUBLE PRECISION :: PACAVO(6)
      DOUBLE PRECISION :: DCORE(L2),DVAL(L2),VEC(L1,L1),
     *                    SCR(L1,8),BUFFX(NINTMX),
     *                    BUFFI(NINTMX)
C-----------------------------------------------------------------------
C
      INTEGER IA
C
      INTEGER IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
C-----------------------------------------------------------------------
      INTEGER MXAO
      PARAMETER (MXAO=8192)
C-----------------------------------------------------------------------
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C-----------------------------------------------------------------------
C
C     ----- CONSTRUCT GENERAL CORRELATION ADAPTED VIRTUAL ORBITALS -----
C     THIS ROUTINE IS A VERY SPECIALIZED VERSION OF THE ORIGINAL ROUTINE.
C     PLEASE SEE AVACO ROUTINE FOR ADDITIONAL NOTES.
C
C----------------------
C     4-->columb terms
C     6-->exchange terms
C      -->put to 1 rather than -1 for convenience
C         when only non-zero term is term 6.
      PACAVO(1)=0.0D+00
      PACAVO(2)=0.0D+00
      PACAVO(3)=0.0D+00
      PACAVO(4)=0.0D+00
      PACAVO(5)=0.0D+00
      PACAVO(6)=1.0D+00
C----------------------
      IF (MASWRK) WRITE(IW,9000) IEXTORB,NVAL,PACAVO
C
C         VALENCE DENSITY IS ALREADY BUILT AND FED IN.
C         CORE DENSITY IS ZERO.
C
      CALL VCLR(DCORE,1,L2)
C
C         MAKE CORE AND VALENCE COULOMB AND EXCHANGE OPERATORS.
C         THIS IS CODED FOR INTEGRALS ON DISK ONLY, AT PRESENT.
C
      IF(NOPK.NE.1) THEN
         IF(MASWRK) WRITE(IW,9010)
         CALL ABRT
      END IF
      CALL SEQREW(IJK)
      CALL HSTARJK(DCORE,DVAL,JCORE,JVAL,KCORE,KVAL,
     *             BUFFX,BUFFI,NINTMX,IA,NOPK,L1,L2)
C
C         CONSTRUCT THE OPERATOR IN THE AO BASIS IN -DCORE-,
C         USING MATRIX -DVAL- AS SCRATCH STORAGE.
C
cccccc      FT  = PACAVO(1)
cccccc      FV  = PACAVO(2)
      FJC = PACAVO(3)
      FJV = PACAVO(4)
      FKC = PACAVO(5)
      FKV = PACAVO(6)
C
      CALL VCLR(DCORE,1,L2)
cccccc      CALL DAREAD(IDAF,IODA,DVAL ,L2,11,0)
cccccc      CALL DAREAD(IDAF,IODA,DCORE,L2,13,0)
cccccc      CALL VSUB(DCORE,1,DVAL,1,DVAL,1,L2)
cccccc
cccccc      CALL DSCAL(L2,FT ,        DCORE,1)
cccccc      CALL DAXPY(L2,FV ,DVAL ,1,DCORE,1)
      CALL DAXPY(L2,FJC,JCORE,1,DCORE,1)
      CALL DAXPY(L2,FJV,JVAL ,1,DCORE,1)
      CALL DAXPY(L2,FKC,KCORE,1,DCORE,1)
      CALL DAXPY(L2,FKV,KVAL ,1,DCORE,1)

C
C     ----- TRANSFORM INTO MO BASIS -----
C
C     NOTE:  DO NOT SHIFT LIKE THE ORIG. ROUTINE.
      CALL VCLR(DVAL,1,L2)
      CALL TFTRI(DVAL,DCORE,VEC,SCR,IEXTORB,L1,L1)
C
      RETURN
C
 9000 FORMAT(/1X,'LOCAL_NOS_ACAVO:',
     *       /1X,'GENERATING',I5,' GENERAL CORRELATION ADAPTED',
     *        1X,'VIRTUAL ORBITALS...'/
     *        1X,'THERE ARE',I5,' FROZEN VALENCE ORBITALS'/
     *        1X,'ACAVO PARAMETERS=',6F10.5)
 9010 FORMAT(1X,'LOCAL_NOS_ACAVO:',
     *      /1X,'CANNOT FORM J,K MATRICES USING SUPERMATRIX INTEGRALS'/
     *       1X,'PLEASE RESUBMIT WITH NOPK=1')
      END
C*MODULE LOCAL   *DECK LOCAL_MINI_DEN
C> @brief      Forms a mini density matrix of interest.
C>
C> @author     Aaron West
C>             -May 14, 2013
C>
C> @details    This routine
C>             allows one to define the orbitals of interest
C>             within the routine itself.
C>             One could run the integer orbital array
C>             through the input at some point,
C>             but I do not see a reason for it right now.
C>
C> @param DENOLD is the original density matrix.
C> @param DENNEW is the new density matrix.
C> @param IWRK   is an integer work array.
C> @param M1     is the total number of active orbitals.
C>               I believe that these are the non-frozen orbitals.
C> @param M2     is the triangular length of the M1xM1 matrix.
C> @param SOME   is true for master process with nprint not equal -5.
C> @param IW     indicates write out to the log file.
C>
      SUBROUTINE LOCAL_MINI_DEN(DENOLD,DENNEW,IWRK,M1,M2,SOME,IW)
      IMPLICIT NONE
      LOGICAL SOME
      INTEGER IW,M1,M2,ISIZ,IWRK(M1)
      DOUBLE PRECISION :: DENOLD(M2),DENNEW(M2)
C
C     HERE, CHOOSE THE MINI-MATRIX.
C     NOTE:  AN EXAMPLE IS GIVEN.
      CALL VICLR(IWRK,1,M1)
      ISIZ=17
      IWRK(1)=5
      IWRK(2)=6
      IWRK(3)=7
      IWRK(4)=8
      IWRK(5)=16
      IWRK(6)=15
      IWRK(7)=13
      IWRK(8)=14
      IWRK(9)=24
      IWRK(10)=22
      IWRK(11)=21
      IWRK(12)=23
      IWRK(13)=20
      IWRK(14)=19
      IWRK(15)=17
      IWRK(16)=18
      IWRK(17)=36
C
C     MAKE MINI-DEN MATRIX
      CALL LOCAL_RESIZE_DEN(DENOLD,DENNEW,IWRK,M1,M2,ISIZ)
C
C     PRINT OFF MINI-DENSITY MATRIX.
      IF(SOME) WRITE(IW,9000)
      CALL PRTRI(DENNEW,ISIZ)
C
      RETURN
 9000 FORMAT(/1X,'MINI DENSITY MATRIX=')
      END
C*MODULE LOCAL   *DECK LOCAL_NOS_EXTSVD1
C> @brief      Prepares occs. for 2 el. exch. integrals.
C>
C> @author     Aaron West and Klaus Ruedenberg
C>             -May 19, 2013
C>
C> @details    This routine prepares occupations for
C>             2 electron exchange integral run.
C>             Output is currently only OCCIMO
C>             VORBIMO might also be output someday,
C>             but VORBIMO has no current use.
C>             These arrays are reordered into VVOS order.
C>             Routine is used in external nos runs.
C>
C> @param L0       is the length of the MO spherical space.
C>                 It may or may not be the variational length
C>                 for this given occurence.
C> @param L1       is the length of the AO coefficients.
C> @param L2       is the triangular length of L1.
C> @param L3       is the square of L1.
C> @param L0MBS    is the dimension of the minimal basis set number of
C>                 orbitals.
C>                 L0MBS is derived from NCORTOT+LOCAL_NUMVAL.
C> @param NVALORBS is the total number of valence orbitals.
C> @param NVALTRI  is the triangular size of NVALORBS.
C> @param NAT      is the number of atoms.
C> @param IPOSCOR  denotes the integer array that holds the starting
C>                 position for the 1st CORE AO on a given atom.
C> @param ILENCOR  denotes the integer array that holds the number of
C>                 CORE orbitals on a given atom.
C> @param IPOSMBS  denotes the integer array that holds the starting
C>                 position for the 1st VALENCE MBS AO on a given atom.
C>                 These are in atomic order from the input
C>                 as usual.
C>                 I emphasize the CORE+VALENCE part.
C> @param ILENMBS  gives the number of VALANEC MBS orbitals.
C> @param IATSVD   is an array from the SVD run itself
C>                 that contains atom-orbital correspondences.
C> @param S        is a scratch array of length L2.
C> @param SVMBS    holds the SV product of the MBS orbitals
C>                 from the VVOS but in the current basis set.
C> @param IWRK     is an integer scratch array with size L1.
C> @param IWRK2    is an integer scratch array with size L1x8.
C> @param DEN      is scrach to hold a density matrix.
C> @param EIG      is a scratch array of length L1.
C> @param VEC3     is a scratch array with size of L3.
C> @param VEC4     is a scratch array with size of L3.
C> @param VORBIMO  will hold reordered SVD orbitals
C>                 in the order of the VVOS.
C> @param VCOPY    holds the copy of wave function orbitals
C>                 for this routine and should not change
C>                 for this routine.
C> @param IORD     is an integer scratch of length L0.
C> @param IORDVVO  is an integer scratch of length L0.
C> @param IORDTOT  is an integer scratch of length L0.
C> @param OCCIMO   will hold reorder SVD densities
C>                 in the order of the VVOS.
C> @param SOME     is true for master process with nprint not equal -5.
C> @param MASWRK   indicates the master process.
C> @param IW       indicates write out to the log file.
C>
      SUBROUTINE LOCAL_NOS_EXTSVD1(
     *           L0,L1,L2,L3,L0MBS,NVALORBS,NVALTRI,NAT,
     *           IPOSCOR,ILENCOR,IPOSMBS,ILENMBS,IATSVD,
     *           S,SVMBS,
     *           IWRK,IWRK2,DEN,EIG,
     *           VEC3,VEC4,VORBIMO,VCOPY,
     *           IORD,IORDVVO,IORDTOT,
     *           OCCIMO,SOME,MASWRK,IW)
      IMPLICIT NONE
C
      LOGICAL SOME,MASWRK
      INTEGER IW,
     *        L0,L1,L2,L3,L0MBS,NVALORBS,NVALTRI,NAT
      INTEGER IWRK(L1),IWRK2(L1*8),
     *        IPOSCOR(NAT+1),ILENCOR(NAT),IPOSMBS(NAT+1),ILENMBS(NAT),
     *        IATSVD(L0),IORD(L0),IORDVVO(L0),IORDTOT(L0)
      DOUBLE PRECISION ::
     *       OCCIMO(L0MBS),DEN(NVALTRI),
     *       SVMBS(L1,L0MBS),VORBIMO(L1,L1),
     *       VCOPY(L1,L1),
     *       VEC3(L1,L1),VEC4(L1,L1),S(L2),EIG(L1)
      INTEGER IDUM,L0LIM,I,II,ICOUNT,ITRIG
      INTEGER IST,ILAST,ICOR,NERR,IERR,IERR2,J,III,JJJ,ITMP,IVAL,
     *        IORB,ICT,ICT2,
     *        NVVOS_NUMCOR
C
C     USE OF OVLSEL REQUIRES CERTAIN DIMENSIONS.
C     WE MUST BE STRICT...
      CALL VCLR(VEC4,1,L3)
      CALL DCOPY(L1*L0MBS,SVMBS,1,VEC4,1)
C
C     MAKE S A SYM. UNIT MATRIX AND DO NOT CHANGE IT.
      CALL VCLR(S,1,L2)
      DO I=1,L1
        II=(I*I+I)/2
        S(II)=1.0D+00
      ENDDO
C
C     FORM THE ORBITAL OVERLAP.
C     AND
C     OBTAIN THE REORDERING ARRAY.
      CALL VICLR(IWRK2,1,L1*8)
      CALL VCLR(VEC3,1,L3)
      IDUM=0
      L0LIM=L0MBS
C     NOTE:  S SHOULD BE 1 FOR THIS NEXT CALL.
      CALL OVLSEL(VORBIMO,EIG,VEC4,S,
     *            VEC3,IWRK2,IWRK,IWRK2,
     *            IDUM,IDUM,L0,L1,L2,.FALSE.,L0LIM)
C
C     RELOAD WITHOUT THE TRASH ORBITAL PHASES.
      CALL DCOPY(L3,VCOPY,1,VORBIMO,1)
C
C     REORDER THE ORBITALS.
C     NOTE:  SCF FREE-ATOM LABELS WILL LIE IN THE 'CORE'
C            WAVEFUNCTION MOS.
      CALL VICLR(IWRK,1,L1)
      CALL ICOPY(L0LIM,IWRK2,1,IWRK,1)
      CALL REORDR(VORBIMO,IWRK,L0LIM,L1)
      CALL ICOPY(L0LIM,IWRK2,1,IWRK,1)
C
C-----------------------------------------
C     WELCOME TO THE GATHERING OF CHAOS.
C-----------------------------------------
C
C     --INITIALIZE THE OCCIMO ROUTINE TO ALL -1
C     --CHECK THAT SVD AND VVOS ATOM ASSIGNMENTS AGREE
C       AFTER OVLSEL REORDERING.
C     --PUT THE OCCUPATIONS IN THE ORDER OF VVOS.
C     NOTE:  ITMP ALWAYS LAGS BEHIND HERE.
C     NOTE:  NEVER CHANGE IWRK2.
C     NOTE:  AFTER THE CHANGE IN THE VVOS TO ORTHOGONALIZE
C            AFTER WRITING TO DAF533, WE NOW SEE ISSUES HERE
C            FOR THE OVERLAP.
C            THE AAMBS ORBITALS ARE PROBABLY BLURRED NOW
C            AS A RESULT OF THAT ORTHOG.
C            FOR BIGGER SYSTEMS, ONE NEEDS TO FURTHER RESTRICT
C            THE ORBITAL REORDER BASED ON ATOM LABELS AS WELL.
      DO I=1,L0MBS
        OCCIMO(I)=-1.0D+00
      ENDDO
      NERR=0
      IERR=0
      IERR2=0
      ITRIG=0
      ICOUNT=0
      ICOR=NVVOS_NUMCOR(0,0)
ccccccc
      DO III=1,NAT
        IST=IPOSMBS(III)
        ILAST= -1+IST+ILENMBS(III)
        DO J=IST,ILAST
          ITMP=IWRK2(J)
          IF(ITMP.LE.ICOR) IERR=IERR+1
          JJJ=IATSVD(ITMP)
CKEEP          IF(JJJ.NE.III) IERR2=IERR2+1
          IF(JJJ.NE.III) ITRIG=1
ccccccccccc
ccccccccccc itmp contains cores.  convert itmp to val only.
ccccccccccc
          IVAL=ITMP-ICOR
          II=(IVAL*IVAL+IVAL)/2
          OCCIMO(J)=DEN(II)
          ICOUNT=ICOUNT+1
ccccccccccc
ccccccccccc
ccccccccccc
        ENDDO
      ENDDO
ccccccc
      IF(IERR.GT.0) THEN
        NERR=NERR+1
        IF(MASWRK) WRITE(IW,9000)
      ENDIF
      IF(IERR2.GT.0) THEN
        NERR=NERR+1
        IF(MASWRK) WRITE(IW,9001)
      ENDIF
      IF(ICOUNT.NE.NVALORBS) THEN
        NERR=NERR+1
        IF(MASWRK) WRITE(IW,9002)
      ENDIF
C
C     PERFORM ANY ERROR OUTS.
      IF(NERR.GT.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     CHECK FOR "ALL ATOM" OVLSEL FAILURE.
C     IF NO FAILURE, RETURN.
      IF(ITRIG.EQ.0) RETURN
C
C
C
C------------------------------------------------
C     WELCOME TO THE GATHERING OF CHAOS PART 2.
C     IF FAILURE OCCURS, PERFORM OVLSEL PER ATOM.
C     NOTE:  THE ITRIG STATE ABOVE WAS REMOVED,
C            AND THIS SECTION WAS TESTED AGAINST
C            EXISTING EXAMPLES.
C------------------------------------------------
      IF(SOME) WRITE(IW,9010)
C
C     DEFINE THE NUMBER OF CORES.
      ICOR=NVVOS_NUMCOR(0,0)
C
C     INITIALIZE IORDTOT TO ALL 0S.
      CALL VICLR(IORDTOT,1,L0)
C
C     CORE LOOP OVER THE ATOMS.
      IF(SOME) WRITE(IW,9011)
      DO 300 III=1,NAT
C
C       WAVE FUNCTION CORE ORBITAL STUFF
        CALL VCLR(VORBIMO,1,L3)
        CALL VICLR(IORD,1,L0)
        ICT=0
        DO IORB=1,ICOR
          JJJ=IATSVD(IORB)
          IF(JJJ.EQ.III) THEN
            ICT=ICT+1
            CALL DCOPY(L1,VCOPY(1,IORB),1,VORBIMO(1,ICT),1)
            IORD(ICT)=IORB
          ENDIF
        ENDDO
C
C       AAMBS CORE ORBITAL STUFF
        CALL VCLR(VEC4,1,L3)
        CALL VICLR(IORDVVO,1,L0)
        ICT2=0
        IST=IPOSCOR(III)
        ILAST= -1+IST+ILENCOR(III)
        DO J=IST,ILAST
          ICT2=ICT2+1
          CALL DCOPY(L1,SVMBS(1,J),1,VEC4(1,ICT2),1)
          IORDVVO(ICT2)=J
        ENDDO
C
C       COMPARE NUMBERS OF ORBITALS COPIED.
C       NOTE:  CORE CAN BE 0 VALUES FOR H ATOM FOR INSTANCE.
        IF(ICT.NE.ICT2) THEN
          IF(MASWRK) WRITE(IW,9020) ICT,ICT2
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
        IF(ICT.EQ.0) GO TO 300
C
C       PERFORM OVERLAP ON AN ATOM.
        IDUM=0
        L0LIM=ICT
C       NOTE:  S SHOULD BE 1 FOR THIS NEXT CALL.
        CALL OVLSEL(VORBIMO,EIG,VEC4,S,
     *              VEC3,IWRK2,IWRK,IWRK2,
     *              IDUM,IDUM,L0,L1,L2,.FALSE.,L0LIM)
C
C       VORBIMO PHASES ARE TRASHED.  DON'T USE.
C       IWRK2 CONTAINS THE REORDERING INSTRUCTIONS.
C
C       COPY IORD TO IWRK.
C       REORDER THE IORD ELEMENTS.
C       CONTRIBUTE IORD TO IORDTOT VIA POSITION IWRK.
        CALL IREORDR(IORD,IWRK2,L0LIM,1)
        DO I=1,L0LIM
          IORDTOT(IORDVVO(I))=IORD(I)
        ENDDO
C
C     END CORE LOOP OVER ATOMS
  300 CONTINUE
C
C
C
C
C     VALENCE LOOP OVER THE ATOMS.
      IF(SOME) WRITE(IW,9021)
      DO 400 III=1,NAT
C
C       WAVE FUNCTION VALENCE ORBITAL STUFF
        CALL VCLR(VORBIMO,1,L3)
        CALL VICLR(IORD,1,L0)
        ICT=0
        DO IORB=ICOR+1,L0MBS
          JJJ=IATSVD(IORB)
          IF(JJJ.EQ.III) THEN
            ICT=ICT+1
            CALL DCOPY(L1,VCOPY(1,IORB),1,VORBIMO(1,ICT),1)
            IORD(ICT)=IORB
          ENDIF
        ENDDO
C
C       AAMBS VALENCE ORBITAL STUFF
        CALL VCLR(VEC4,1,L3)
        CALL VICLR(IORDVVO,1,L0)
        ICT2=0
        IST=IPOSMBS(III)
        ILAST= -1+IST+ILENMBS(III)
        DO J=IST,ILAST
          ICT2=ICT2+1
          CALL DCOPY(L1,SVMBS(1,J),1,VEC4(1,ICT2),1)
          IORDVVO(ICT2)=J
        ENDDO
C
C       COMPARE NUMBERS OF ORBITALS COPIED.
C       NOTE:  VALENCE CANNOT BE 0 EVER.
        IF(ICT.NE.ICT2.OR.ICT.EQ.0) THEN
          IF(MASWRK) WRITE(IW,9020) ICT,ICT2
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
C
C       PERFORM OVERLAP ON AN ATOM.
        IDUM=0
        L0LIM=ICT
C       NOTE:  S SHOULD BE 1 FOR THIS NEXT CALL.
        CALL OVLSEL(VORBIMO,EIG,VEC4,S,
     *              VEC3,IWRK2,IWRK,IWRK2,
     *              IDUM,IDUM,L0,L1,L2,.FALSE.,L0LIM)
C
C       VORBIMO PHASES ARE TRASHED.  DON'T USE.
C       IWRK2 CONTAINS THE REORDERING INSTRUCTIONS.
C
C       COPY IORD TO IWRK.
C       REORDER THE IORD ELEMENTS.
C       CONTRIBUTE IORD TO IORDTOT VIA POSITION IWRK.
        CALL IREORDR(IORD,IWRK2,L0LIM,1)
        DO I=1,L0LIM
          IORDTOT(IORDVVO(I))=IORD(I)
        ENDDO
C
C     END VALENCE LOOP OVER ATOMS
  400 CONTINUE
C
C     SOMEDAY, MAYBE WE WANT THESE ORBITALS.
C     PLUS, THE REORDR CALL WILL ERROR US OUT...
      CALL VICLR(IWRK,1,L1)
      CALL ICOPY(L0MBS,IORDTOT,1,IWRK,1)
      CALL DCOPY(L3,VCOPY,1,VORBIMO,1)
      CALL REORDR(VORBIMO,IWRK,L0MBS,L1)
C
C     REPLACE IWRK AND IWRK2 FOR GETTING THE OCCUPATIONS BELOW...
      CALL VICLR(IWRK,1,L1)
      CALL VICLR(IWRK2,1,L1*8)
      CALL ICOPY(L0MBS,IORDTOT,1,IWRK,1)
      CALL ICOPY(L0MBS,IORDTOT,1,IWRK2,1)
C
C----------------------------------------------
C     WELCOME TO THE GATHERING OF CHAOS PART 3.
C----------------------------------------------
C
      DO I=1,L0MBS
        OCCIMO(I)=-1.0D+00
      ENDDO
      NERR=0
      IERR=0
      IERR2=0
      ICOUNT=0
      ICOR=NVVOS_NUMCOR(0,0)
      DO III=1,NAT
        IST=IPOSMBS(III)
        ILAST= -1+IST+ILENMBS(III)
        DO J=IST,ILAST
          ITMP=IWRK2(J)
          IF(ITMP.LE.ICOR) IERR=IERR+1
          JJJ=IATSVD(ITMP)
          IF(JJJ.NE.III) IERR2=IERR2+1
          IVAL=ITMP-ICOR
          II=(IVAL*IVAL+IVAL)/2
          OCCIMO(J)=DEN(II)
          ICOUNT=ICOUNT+1
        ENDDO
      ENDDO
      IF(IERR.GT.0) THEN
        NERR=NERR+1
        IF(MASWRK) WRITE(IW,9000)
      ENDIF
      IF(IERR2.GT.0) THEN
        NERR=NERR+1
        IF(MASWRK) WRITE(IW,9001)
      ENDIF
      IF(ICOUNT.NE.NVALORBS) THEN
        NERR=NERR+1
        IF(MASWRK) WRITE(IW,9002)
      ENDIF
      IF(NERR.GT.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF

C
      RETURN
 9000 FORMAT(/1X,'LOCAL_NOS_EXTSVD1 ERROR:',
     *       /1X,'IWRK ARRAY HAS ORBITAL NUMBERS',
     *        1X,'THAT DO NOT MAKE SENSE...')
 9001 FORMAT(/1X,'LOCAL_NOS_EXTSVD1 ERROR:',
     *       /1X,'ATOM NUMBERS DO NOT MATCH UP.')
 9002 FORMAT(/1X,'LOCAL_NOS_EXTSVD1 ERROR:',
     *       /1X,'ICOUNT DOES NOT EQUAL NVALORBS.')
 9010 FORMAT(/1X,'LOCAL_NOS_EXTSVD1 WARNING:',
     *       /1X,'OVLSEL ACROSS ALL L0MBS ORBITALS FAILED.',
     *       /1X,'PERFORM OVLSEL FOR ORBITALS PER ATOM.')
 9011 FORMAT(/1X,'WORKING ON CORE INTEGER REORDERING...')
 9020 FORMAT(/1X,'LOCAL_NOS_EXTSVD1 ERROR:',
     *       /1X,'THE NUMBER OF AAMBS AND SVD ORBITALS',
     *        1X,'DOES NOT MATCH.',I4,I4)
 9021 FORMAT(/1X,'WORKING ON VALENCE INTEGER REORDERING...')
      END
C*MODULE LOCAL   *DECK LOCAL_GRAB_BASIS_FXNS_ON_ATOM
C> @brief      Grabs out AO overlaps on a given atom.
C>
C> @author     Aaron West
C>             -May 19, 2013
C>
C> @details    AO overlaps on a given atom are grabbed out of
C>             the general AO overlap matrix and placed
C>             starting at index 1 in a symmetric matrix.
C>
C> @param LIMLOW  array contains the lower basis function on an atom.
C> @param LIMSUP  array contains the upper basis function on an atom.
C> @param IATM1   is the current atom.
C> @param NAT     is the number of atoms.
C> @param L2      is the triangular length of the number of
C>                basis functions, which is typically L1=NUM.
C> @param S2      S2 holds the AO overlaps for IATM1 on exit.
C> @param S       holds the AO overlap matrix for all atoms on entry.
C> @param IBAS1   equals the starting index of the first AO
C>                on current atom IATM1.
C> @param IBAS2   equals the ending index of the last AO
C>                on current atom IATM1.
C> @param ILTH    equals the total number of basis functions
C>                on current atom IATM1.
C> @param IBASSPH1   equals the starting index of the first AO
C>                on current atom IATM1.
C> @param IBASSPH2   equals the ending index of the last AO
C>                on current atom IATM1.
C> @param ILTHSPH    equals the total number of basis functions
C>                on current atom IATM1.
C> @param COMBOSPHER indicates if using sphericals.
C> @param ILTH_FIX   sets the AO size in the SVD.
      SUBROUTINE LOCAL_GRAB_BASIS_FXNS_ON_ATOM(
     *           LIMLOW,LIMSUP,IATM1,NAT,L2,
     *           S2,S,
     *           IBAS1,IBAS2,ILTH,
     *           IBASSPH1,IBASSPH2,ILTHSPH,
     *           COMBOSPHER)
      IMPLICIT NONE
      LOGICAL COMBOSPHER
      INTEGER IATM1,NAT,L2
      INTEGER LIMLOW(NAT),LIMSUP(NAT)
      DOUBLE PRECISION :: S(L2),S2(L2)
C
      INTEGER IBAS1,IBAS2,ILTH,IBASSPH1,IBASSPH2,ILTHSPH,
     *        NAOCART,NAOSPH,IFIND1,IFIND2,
     *        I,J,IJ,IJ2
C
      IBAS1=LIMLOW(IATM1)
      IBAS2=LIMSUP(IATM1)
      ILTH=IBAS2-IBAS1+1
      IBASSPH1=0
      DO I=1,IATM1-1
        CALL LOCAL_COUNTAOS(I,NAOCART,NAOSPH)
        IBASSPH1=IBASSPH1+NAOSPH
      ENDDO
      IBASSPH1=IBASSPH1+1
      I=IATM1
      CALL LOCAL_COUNTAOS(I,NAOCART,NAOSPH)
      IBASSPH2=IBASSPH1-1+NAOSPH
      ILTHSPH=IBASSPH2-IBASSPH1+1
C
C     ASSIGN PROPER LIMITS FOR GRABBING OUT BASIS
      IFIND1=IBAS1
      IFIND2=IBAS2
      IF(COMBOSPHER) THEN
        IFIND1=IBASSPH1
        IFIND2=IBASSPH2
      ENDIF
C
C     GRAB OUT CORRECT BASIS FUNCTIONS.
      CALL VCLR(S2,1,L2)
      IJ2=1
      DO I=IFIND1,IFIND2
        DO J=IFIND1,I
          IJ=(I*I-I)/2 + J
          S2(IJ2)=S(IJ)
          IJ2=IJ2+1
        ENDDO
      ENDDO
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_WSO_PREP
C> @brief      Forms relative weights for weighted sym. orthog.
C>
C> @author     Aaron West
C>             -May 24, 2013
C>
C> @details    Routine scales the true weights from 1 to 100.
C>             This scaling preserves the difference in weightings
C>             and avoids issues with orbital orthonormality.
C>
C> @param WGT      array contains the true weights on entry.
C>                 On exit, this array contains the scaled weights.
C> @param ILTH     is the number of weights.
C> @param WRK      is a scratch work array.
C> @param ATWGT    is a logical that chooses a different relative
C>                 weight.  It is appropriate when this call
C>                 is placed in a loop over atoms and creates
C>                 comparative weights between atoms.
C>                 The weight range for this option is 0 to 1
C>                 rather than 1 to 100.
C> @param SOME   is true for master process with nprint not equal -5.
C> @param IW       indicates write out to the log file.
      SUBROUTINE LOCAL_WSO_PREP(
     *           WGT,ILTH,ATWGT,SOME,IW)
      IMPLICIT NONE
      LOGICAL ATWGT,SOME
C
      INTEGER ILTH,I,IW
      DOUBLE PRECISION :: WGT(ILTH)
      DOUBLE PRECISION :: TMP,WMIN,WMAX,RATIO,RATIOSV,
     *                    ONE,WSPREAD,POWER,BBB
      PARAMETER (ONE=1.0D+00)
      PARAMETER (WSPREAD=99.0D+00,POWER=3.00D+00,BBB=70.0D+00)
C
C     FIND THE BIGGEST AND SMALLEST WEIGHTS.
      TMP=ABS(WGT(1))
      WMIN=TMP
      WMAX=TMP
      DO I=1,ILTH
        TMP=ABS(WGT(I))
        IF(TMP.LT.WMIN) WMIN=TMP
        IF(TMP.GT.WMAX) WMAX=TMP
      ENDDO
C
C     FOR CASES WHERE WMIN,WMAX AS ESSENTIALLY THE SAME,
C     SKIP OVER NUMERICAL ISSUES.
      TMP=WMAX-WMIN
      IF(TMP.LT.1.0D-10.AND.ILTH.GT.1) THEN
        DO I=1,ILTH
          WGT(I)=1.0D+00
        ENDDO
        GO TO 777 ! avoid the division by zero right below here.
      ENDIF
C----------------------------------------------------------------
CORIG      RATIO=1.0D+00
CORIG      DO I=1,ILTH
CORIG        IF(ILTH.GT.1) RATIO=(WGT(I)-WMIN)/(WMAX-WMIN)
CORIG        RATIOSV=RATIO
CORIG        RATIO=RATIO**POWER
CORIG        RATIO=(ONE+BBB)*RATIO/(ONE+BBB*RATIO)
CORIG        WGT(I)=ONE + WSPREAD*RATIO
CORIG        IF(ATWGT) WGT(I)=RATIOSV
CORIG      ENDDO
      RATIO=1.0D+00
      DO I=1,ILTH
        RATIO=WGT(I)/WMAX
        RATIOSV=RATIO
        RATIO=RATIO**POWER
        RATIO=(ONE+BBB)*RATIO/(ONE+BBB*RATIO)
        WGT(I)=ONE + WSPREAD*RATIO
        IF(ATWGT) WGT(I)=RATIOSV
      ENDDO
C
C----------------------------------------------------------------
  777 CONTINUE
C
C     PRINT OFF THE NEW RELATIVE WEIGHTS.
      IF(SOME) THEN
        WRITE(IW,9003)
        DO I=1,ILTH
          WRITE(IW,9004) I,WGT(I)
        ENDDO
      ENDIF
C
      RETURN
 9003 FORMAT(//1X,'LOCAL_WSO_PREP OBTAINS THE RELATIVE WEIGHTS.')
 9004 FORMAT(1X,'ORBITAL',I5,' HAS WSO WEIGHT = ',F12.7)
      END
C*MODULE LOCAL   *DECK LOCAL_RESIZE_DEN
C> @brief      Forms any mini-density matrix.
C>
C> @author     Aaron West
C>             -June 15, 2013
C>
C> @details    Given reordering instructions, the routine
C>             put any combination of the original density
C>             matrix into a reduced-size density matrix.
C>
C> @param DENOLD  is the original density matrix.
C> @param DENNEW  is the reduced  density matrix.
C> @param IWRK    contains the reordering instructions.
C> @param M1      is the number of active orbitals.
C> @param M2      is the triangular size of M1 and the dimension
C>                of the original density matrix.
C> @param ISIZ    is the size of the reduced density matrix.
      SUBROUTINE LOCAL_RESIZE_DEN(DENOLD,DENNEW,IWRK,M1,M2,ISIZ)
      IMPLICIT NONE
      INTEGER M1,M2,IWRK(M1),
     *        ISIZ,I,J,IJ,I2,J2,IJ2
      DOUBLE PRECISION :: DENOLD(M2),DENNEW(M2)

      CALL VCLR(DENNEW,1,M2)
C
      DO I2=1,ISIZ
         DO J2=1,I2
            IJ2=(I2*I2-I2)/2+J2
C
            I=MAX(IWRK(I2),IWRK(J2))
            J=MIN(IWRK(I2),IWRK(J2))
            IJ=(I*I-I)/2+J
C
            DENNEW(IJ2)=DENOLD(IJ)
         ENDDO
      ENDDO
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_PRINTDEN
C> @brief      Corrects phase signs for density matrix.
C>
C> @author     Aaron West and Klaus Ruedenberg
C>             -July 03, 2013
C>
C> @details    This item is only called for orientation right now.
C>             It might be called for other orbital densities
C>             in the future.
C>             As a result,
C>             plus signs always indicate bonding interactions.
C>
C> @param STRI    is the kinetic energy matrix over the MOs
C>                on entry.
C> @param DENCP   is a scratch array of M2 length.
C> @param DEN     is the density matrix of M2 length on entry.
C> @param CLMO    are the L1xL0 orbitals for this density matrix.
C> @param WRK     is a scratch array of L1 length.
C> @param WRKMIN  is a scratch array of M2 length.
C> @param L1      is the length of the AO coefficients.
C> @param L2      is the triangular length of the number of
C>                basis functions, which is typically L1=NUM.
C> @param M1      denotes the number of orbitals that make up
C>                the density matrix.
C> @param M2      is the triangular length of M1.
C> @param NOUTA   denotes the number of frozen orbitals
C>                in the localization on entry.
C> @param SOME    is true for master process with nprint not equal -5.
C> @param MASWRK  indicates the master process.
C> @param IW      indicates write out to log file.
      SUBROUTINE LOCAL_PRINTDEN(
     *           STRI,DENCP,DEN,CLMO,WRK,WRKMIN,
     *           L1,L2,M1,M2,NOUTA,SOME,MASWRK,IW)
      IMPLICIT NONE
      LOGICAL SOME,MASWRK
      INTEGER L1,L2,M1,M2,NOUTA,IW
      DOUBLE PRECISION :: STRI(L2),DENCP(M2),DEN(M2),
     *                    CLMO(L1,L1),WRK(L1),WRKMIN(M2)
      INTEGER I,J,IJ,ILOOP
      DOUBLE PRECISION :: TMP,DUM
C
C  PRINT OUT NON-ROUNDED ORIENTED DENSITY TO .LOG FILE
C  --THIS PRINT OFF IS MODIFIED TO GIVE BOND ORDER SIGNS
C    REGARDLESS OF ORBITAL PHASES THAT ARE SHOWN IN MACMOLPLOT.
C    I.E. + SIGNS ALWAYS INDICATE BONDING INTERACTIONS.
C  --THE ORIGINAL DENSITY ON FILE IS NOT MODIFIED AS THE SIGN
C    CORRESPONDENCE TO THE ORBITALS ON FILE MATTERS
C    FOR OTHER PROGRAMS E.G. CHARGE TRANSFER.
C
      CALL VCLR(DENCP,1,M2)
      CALL TFTRI(DENCP,STRI,CLMO(1,NOUTA+1),
     *           WRK,M1,L1,L1)
      CALL VCLR(STRI,1,L2)
      CALL DCOPY(M2,DENCP,1,STRI,1)
      CALL VCLR(DENCP,1,M2)
C     FORM DENSITY WITH CORRECT PHASE SIGN.
      DO I=1,M1
         DO J=1,I
            IJ=(I*I-I)/2+J
            DUM = 1.0D+00
            IF(I.NE.J) THEN
               TMP=STRI(IJ)*DEN(IJ)
               IF(ABS(TMP).GT.1.0D-06) DUM = -TMP/ABS(TMP)
            ENDIF
C           EVALUATE FOR ILOOP=1.
            DENCP(IJ)=ABS(DEN(IJ))*DUM
C           DONE WITH TRUE STRI=K.E. INTEGRAL FOR IJ ELEMENT.
C           EVALUATE FOR ILOOP=2.
            STRI(IJ)=STRI(IJ)*DEN(IJ)
         ENDDO
      ENDDO
C     MAKE THE PRINT OUTS.
      DO ILOOP=1,2
         IF(ILOOP.EQ.1.AND.MASWRK) WRITE(IW,9090)
         IF(ILOOP.EQ.2.AND.MASWRK) WRITE(IW,9091)
         IF(ILOOP.EQ.2) CALL DCOPY(M2,STRI,1,DENCP,1)
         CALL PRTRI(DENCP,M1)
C        PRINT MINI-DENSITY MATRIX IF NEEDED...
         IF(IW.NE.6) THEN
            CALL LOCAL_MINI_DEN(
     *           DENCP,WRKMIN,WRK,
     *           M1,M2,SOME,IW)
        ENDIF
      ENDDO
C
      RETURN
 9090 FORMAT(///1X,'BOND ORDER SIGNS ARE NOW CORRECTED',
     *          1X,'FOR PRINT OUT ONLY.',
     *         /1X,'FULL PRINT OUT OF ORIENTED DENSITY MATRIX'/)
 9091 FORMAT(///1X,'MULTIPLY DENSITY ELEMENTS BY',
     *          1X,'KINETIC ENERGY INTEGRALS FOR NOVEL DENSITY MATRIX.',
     *         /1X,'FULL PRINT OUT OF NOVEL ORIENTED DENSITY'/)
      END
C*MODULE LOCAL   *DECK LOCAL_VVOS_ORB_RANGE_CORE
C> @brief      Automatically finds atom numbers for VVOS orbitals.
C>
C> @author     Aaron West
C>             -July 11, 2013
C>
C> @details    All chem. cores are not at the beginning...
C>
C> @param IPOSCOR denotes the integer array that holds the starting
C>                position for the 1st CORE AO on a given atom.
C> @param ILENCOR denotes the integer array that holds the number of
C>                CORE orbitals on a given atom.
C> @param NAT     is the total number of atoms.
      SUBROUTINE LOCAL_VVOS_ORB_RANGE_CORE(IPOSCOR,ILENCOR,NAT)
      IMPLICIT NONE
C
      INTEGER IPOSCOR(NAT+1),ILENCOR(NAT),NAT
      INTEGER I,ITYPE,NCOR_NEVER,ITMP,NVAL,ISWMBS
      INTEGER LOCAL_NUMVAL,NVVOS_NUMCOR
C
C     NOTES:
C     1.  GO BACK TO THE BASIC NVVOS_NUMCOR INFO HERE
C         SINCE VVOS IS IN MBS NUMBERS.
C     2.  GO BACK TO NVVOS_NUMCOR ATOM-BY-ATOM.
C         THIS PART TOOK ME A BIT TO REALIZE... AND DANCE.
C
      ITMP=1
      DO I=1,NAT
C
        ITYPE=1
        NCOR_NEVER=NVVOS_NUMCOR(I,ITYPE)
        ISWMBS=1
        NVAL=LOCAL_NUMVAL(I,ISWMBS)
C
        IPOSCOR(I)=ITMP
        ILENCOR(I)=NCOR_NEVER
C
        ITMP=ITMP+NCOR_NEVER
        ITMP=ITMP+NVAL
      ENDDO
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_CHECK_DENS
C> @brief      Checks density matrix occupations.
C>
C> @author     Aaron West
C>             -July 18, 2013
C>
C> @details    This item checks the occupations
C>             against the total number of electrons.
C>             For ilocal=4 type runs, the NCOROT below
C>             is probably always the chemical core orbitals.
C>
C> @date October 19, 2013-Aaron West
C> -Fix some silly mistakes.
C>  Test cases checked out by script.
C>
C> @param DEN     equals the density matrix.
C> @param NACT2   equals the dimension of the density matrix.
C> @param NACT    equals the number of active orbitals.
C> @param NCORTOT equals the number of core orbitals.
C> @param NE      equals the number of electrons.
C> @param MASWRK  indicates the master process.
C> @param IW      indicates write out to log file.
      SUBROUTINE LOCAL_CHECK_DENS(
     *           DEN,NACT2,NACT,NCORTOT,NE,
     *           MASWRK,IW)
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER NACT,NACT2,NCORTOT,NE,IW
      DOUBLE PRECISION :: TMP,TOT,TOL,TWO,DEN(NACT2)
      PARAMETER (TOL=1.0D-06,TWO=2.0D+00)
      INTEGER I,II
C
C     OBTAIN CONTRIBUTIONS FROM DENSITY.
      TOT=0
      DO I=1,NACT
        II=(I*I+I)/2
        TOT=TOT+DEN(II)
      ENDDO
C
C     OBTAIN CONTRIBUTIONS FROM CHEMICAL CORE ORBITALS.
      TOT=TOT+TWO*NCORTOT
C
C     COMPARE TO THE NUMBER OF ELECTRONS.
      TMP=DBLE(NE)
      TMP=ABS(TMP-TOT)
      IF(TMP.GT.TOL) THEN
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
      ENDIF
C
      RETURN
 9000 FORMAT(/1X,'LOCAL_CHECK_DENS ERROR:',
     *       /1X,'THE DENSITY DOES NOT ADD UP',
     *        1X,'TO THE NUMBER OF ELECTRONS.')
      END
C*MODULE LOCAL   *DECK LOCAL_CHECK_ORTHOG
C> @brief      Checks if orbitals are orthonormal.
C>
C> @author     Aaron West
C>             -August 02, 2013
C>
C> @param L0       is the length of the MO variational space.
C> @param L1       is the length of the AO coefficients.
C> @param L2       is the triangular length of L1.
C> @param S2       is scratch space of length L2.
C> @param S        contains the AO overlap matrix of length L2.
C> @param VECCOL   contains the orbitals to be checked.
C> @param WRK      is scratch of length L1*8.
C> @param MASWRK  indicates the master process.
C> @param IW      indicates write out to log file.
      SUBROUTINE LOCAL_CHECK_ORTHOG(
     *           L0,L1,L2,
     *           S2,S,VECCOL,WRK,
     *           MASWRK,IW)
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER IW,L0,L1,L2
      DOUBLE PRECISION ::
     *       S2(L2),S(L2),VECCOL(L1,L1),WRK(L1*8)
C
C
      INTEGER IERR,I,J,IJ
      DOUBLE PRECISION :: TMP,TOL_NOS_EXT
      PARAMETER (TOL_NOS_EXT=1.0D-08)
      ! part. int. gave 1.2d-10 error diff
C
C
      CALL TFTRI(S2,S,VECCOL,WRK,L0,L1,L1)
      IERR=0
      DO I=1,L0
        DO J=1,I
          IJ=(I*I-I)/2+J
          IF(I.EQ.J) THEN
            TMP=ABS(S2(IJ)-1.0D+00)
          ELSE
            TMP=ABS(S2(IJ))
          ENDIF
          IF(TMP.GT.TOL_NOS_EXT) THEN
            IERR=IERR+1
            IF(MASWRK) WRITE(IW,9010) I,J,TMP
          ENDIF
        ENDDO
      ENDDO
      IF(IERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9068)
        CALL PRTRI(S2,L0)
        IF(MASWRK) WRITE(IW,9068)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9010 FORMAT(//1X,'LOCAL_CHECK_ORTHOG_ERROR:',
     *        /1X,'ORBITAL I,J,DIFFERENCE VALUE=',
     *         1X,I4,I4,F6.10)
 9068 FORMAT(//1X,'LOCAL_CHECK_ORTHOG ERROR:',
     *        /1X,'FINAL ORBITALS ARE NOT ORTHONORMAL.')
      END
C*MODULE LOCAL   *DECK LOCAL_INTMAX
C> @brief      Find the index with the largest absolute value.
C>
C> @author     Aaron West
C>             -August 17, 2013
C>
C> @details    Starting and ending indices
C>             are input rather than inputing a shifted value.
C>             In other words, IORD should never be input with
C>             a shifted index.
C>
C> @param IDUM is returned as the index of the largest integer.
C> @param IORD is the index array that is examined.
C> @param NLEN is the dimension of IORD.
C> @param IST  is where to start looking for the largest
C>             absolute valued index.
C> @param IEND is where to stop looking for the largest
C>             absolute valued index.
      SUBROUTINE LOCAL_INTMAX(IDUM,IORD,NLEN,IST,IEND)
      IMPLICIT NONE
      INTEGER IDUM,NLEN,IORD(NLEN),IST,IEND,J,JSAV,NERR
C-----------------------------------------------------------------------
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      INTEGER IW,IDAF,IODA,IP,IPK,IR,IS,NAV
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C-----------------------------------------------------------------------
      NERR=0
      IF(IST.LE.0.OR.IEND.LE.0) THEN
        IF(MASWRK) WRITE(IW,9010)
        NERR=NERR+1
      ENDIF
      IF(IST.GT.IEND) THEN
        IF(MASWRK) WRITE(IW,9020)
        NERR=NERR+1
      ENDIF
      IF(IEND.GT.NLEN) THEN
        IF(MASWRK) WRITE(IW,9030)
        NERR=NERR+1
      ENDIF
      IF(NERR.NE.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
          IDUM=IST
          JSAV=IABS(IORD(IST))
          DO 100 J=IST,IEND
            IF(IABS(IORD(J)).LE.JSAV) GO TO 100
            IDUM=J
            JSAV=IABS(IORD(J))
  100     CONTINUE
C
      RETURN
 9010 FORMAT(//1X,'LOCAL_INTMAX ERROR:',
     *        /1X,'IST AND IEND MUST BE BIGGER THAN 0.')
 9020 FORMAT(//1X,'LOCAL_INTMAX ERROR:',
     *        /1X,'IST CANNOT BE BIGGER THAN IEND.')
 9030 FORMAT(//1X,'LOCAL_INTMAX ERROR:',
     *        /1X,'IEND CANNOT BE BIGGER THAN NLEN.')
      END
C*MODULE LOCAL   *DECK LOCAL_SVDEXTOPT_ACROSSATOMS
C> @brief      Preserves degenerate values ACROSS atoms.
C>
C> @author     Aaron West
C>             -September 12, 2013
C>
C> @details    The SVD values must be cut off at some point.
C>             The cut must have non-degenerate values across it.
C>
C> @param ICT_ORB   is the total orbitals out of the SVD.
C> @param IGRPLAB   contains the group labels.
C> @param IATLAB    contains the atom labels.
C> @param IORDBIG   is integer scratch with length of
C>                  NACTBS*NAT.
C> @param IEXTSPACE is the total number of external groups.
C>                  It can only be 1 here.
C> @param L1        is the number of atomic orbitals.
C> @param L0        is the number of molecular orbitals.
C> @param L0MBS     is the number of internal orbitals.
C> @param NCORTOT   is the number of core orbitals.
C> @param NATEXT    is a check on memory allocation.
C> @param IAOSPH    is integer scratch for atom counting.
C> @param IAOMAX    is integer scratch for atom counting.
C> @param IAOFIN    is integer scratch for atom counting.
C> @param IAODEG    is integer scratch for atom counting.
C> @param IAODEGTOT is integer scratch for atom counting.
C> @param NAT       is the number of atoms.
C> @param NACTBS    is used in the leading dimension.
C> @param NACT      is the number of active orbitals.
C> @param NSPACE    is the number ORMAS groups.
C> @param MSTA      holds the orbital ranges for ORMAS groups.
C> @param EIGSAV    saves the SVD evalues from ALL SVDs.
C>                  For each atom, an SVD is done.
C> @param EIGTMP    is scratch space to save EIGSAV array.
C> @param ILENCOR   denotes the integer array that holds the
C>                  number of CORE orbitals on a given atom.
C> @param ILENMBS   gives the number of VALANEC MBS orbitals.
C> @param SOME      is true for master process with nprint
C>                  not equal -5.
C> @param MASWRK    indicates the master process.
C> @param IW        indicates write out to log file.
      SUBROUTINE LOCAL_SVDEXTOPT_ACROSSATOMS(
     *           ICT_ORB,IGRPLAB,IATLAB,IORDBIG,
     *           IEXTSPACE,L1,L0,L0MBS,NCORTOT,NATEXT,
     *           IAOSPH,IAOMAX,IAOFIN,
     *           IAODEG,IAODEGTOT,
     *           NAT,NACTBS,NACT,NSPACE,MSTA,
     *           EIGSAV,EIGTMP,
     *           ILENCOR,ILENMBS,
     *           SOME,MASWRK,IW)
      IMPLICIT NONE
C
C     VARS THAT ENTER.
      LOGICAL SOME,MASWRK
      INTEGER IW,
     *        ICT_ORB,IEXTSPACE,L1,L0,L0MBS,NCORTOT,NATEXT,
     *        NAT,NACTBS,NACT,NSPACE
      INTEGER IGRPLAB(NACTBS*NAT),IATLAB(NACTBS*NAT),
     *        IORDBIG(NACTBS*NAT),
     *        IAOSPH(NAT),IAOMAX(NAT),IAOFIN(NAT),
     *        IAODEG(NAT),IAODEGTOT(NAT),
     *        MSTA(NSPACE),ILENCOR(NAT),ILENMBS(NAT)
      DOUBLE PRECISION ::
     *       EIGSAV(NACTBS*NAT),EIGTMP(NACTBS*NAT)
C
C     VARS MADE HERE.
      INTEGER ISPACE,NERR,LIMORB,IATM1,
     *        NAOCART,NAOSPH,NAOTOT,
     *        ILEN,ITMP,IMARK,IPOS,JPOS,IPOSHLD,IDUM,ITOT,
     *        ICTDEG,IATI,IATJ,IFIND
      DOUBLE PRECISION :: TMP,TMPSAV,TOL
      PARAMETER (TOL=1.0D-05)
C
C     OVERALL GOAL:
C     OBTAIN LIMORB "SELECT" ORBITALS WITH THE FOLLOWING CONDITIONS:
C     --MAX. SVD EVALUES
C     --ACCEPT OR REJECT DEGENERATE ORBITALS ACROSS ATOMS
C     --ACCEPT ORBITALS BELOW IAOMAX LIMIT ON EACH ATOM
C     --DO NOT LOOK AT ONE ATOM WHEN YOU THINK ABOUT THIS PROCEDURE
C     --TOLERANCE WAS SELECTED BASED ON VALUES FROM PARA-QUINONE
C       THAT WAS RUN IN SYMMETRY FOR RHF ENERGY OPTIMIZATION.
C
C
C     CHECK NATEXT FOR GIVEN VALUE.
      IF(NATEXT.NE.5) THEN
        IF(MASWRK) WRITE(IW,9005) NATEXT
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     CHECK THAT ONLY THE LAST GROUP IS IN THE EXTERNALS.
      NERR=0
      IF(IEXTSPACE.NE.1) NERR=NERR+1
      DO ISPACE=1,NSPACE-1
        IF(MSTA(ISPACE).GT.L0MBS) NERR=NERR+1
      ENDDO
      IF(NERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9010)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     DEFINE IAOSPH,IAOMAX,NAOTOT
      NERR=0
      NAOTOT=0
      CALL VICLR(IAOSPH,1,NAT)
      CALL VICLR(IAOMAX,1,NAT)
      DO IATM1=1,NAT
        CALL LOCAL_COUNTAOS(IATM1,NAOCART,NAOSPH)
        IAOMAX(IATM1)=NAOSPH-ILENMBS(IATM1)-ILENCOR(IATM1)
        IAOSPH(IATM1)=NAOSPH
        NAOTOT=NAOTOT+NAOSPH
      ENDDO
      IF(NAOTOT.GT.L1) NERR=NERR+1
      IF(NERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9020)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C
C     DEFINE LIMORB
      LIMORB=NAOTOT-L0MBS
      IF(SOME) WRITE(IW,9025) LIMORB
C
C     CHECK LIMITS
      IF(NACT+NCORTOT.LT.L0) THEN
        IF(MASWRK) WRITE(IW,9030)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     LOCATE IPOS FOR THE EXTERNAL ORBITALS.
      CALL VICLR(IORDBIG,1,NACTBS*NAT)
      IPOS=0
      DO 150 ILEN=1,NACT
        IF(IGRPLAB(ILEN).EQ.NSPACE) GO TO 151
        IORDBIG(ILEN)=ILEN
        IPOS=ILEN
  150 CONTINUE
  151 CONTINUE
C
C     LOCATE THE "SELECT" EVALUES.
      CALL DCOPY(NACTBS*NAT,EIGSAV,1,EIGTMP,1)
      CALL VICLR(IAOFIN,1,NAT)
      CALL VICLR(IAODEGTOT,1,NAT)
C     --IPOS IS ALREADY SET.
      IMARK=IPOS+1
      ITOT=0
      DO 200 ILEN=IMARK,ICT_ORB
        IPOS=IPOS+1
        IPOSHLD=IPOS
        IF(IPOS.GT.ICT_ORB) GO TO 201
        IATI=IATLAB(IPOS)
        TMPSAV=EIGTMP(IPOS)
C
        CALL VICLR(IAODEG,1,NAT)
        IAODEG(IATI)=IAODEG(IATI)+1
        IAODEGTOT(IATI)=IAODEGTOT(IATI)+1
        ICTDEG=1
        DO 300 JPOS=IPOSHLD+1,ICT_ORB
          IATJ=IATLAB(JPOS)
          TMP=ABS(EIGTMP(JPOS)-TMPSAV)
          IF(TMP.GE.TOL) GO TO 301
          IAODEG(IATJ)=IAODEG(IATJ)+1
          IAODEGTOT(IATJ)=IAODEGTOT(IATJ)+1
          ICTDEG=ICTDEG+1
          IPOS=IPOS+1
  300   CONTINUE
  301   CONTINUE
        IF(IPOS.GT.ICT_ORB) GO TO 201
        ITMP=ITOT+ICTDEG
        IF(ITMP.GT.LIMORB) GO TO 200
        DO IATM1=1,NAT
          ITMP=IAOFIN(IATM1)+IAODEG(IATM1)
          IF(ITMP.GT.IAOMAX(IATM1)) GO TO 200
        ENDDO
C
        DO JPOS=1,ICTDEG
          ITMP=IPOSHLD-1+JPOS
          IDUM=IMARK-1+ITOT+JPOS
          IORDBIG(IDUM)=ITMP
        ENDDO
C
        DO IATM1=1,NAT
          IAOFIN(IATM1)=IAOFIN(IATM1)+IAODEG(IATM1)
        ENDDO
        ITOT=ITOT+ICTDEG
        IF(ITOT.EQ.LIMORB) GO TO 201
  200 CONTINUE
  201 CONTINUE
      IF(ITOT.EQ.LIMORB) THEN
        IF(SOME) WRITE(IW,9100)
        CALL FLSHBF(IW)
        GO TO 1000
      ENDIF
C--------------------------------------------------------------------
C     SKIP DESCENDING EIGENVALUE SORT
C     SINCE NO TEST CASES NEED IT SO FAR.
C--------------------------------------------------------------------
C     PERFORM FINAL CHECKS AND SORT THE INTEGER ARRAYS.
C--------------------------------------------------------------------
 1000 CONTINUE
      IF(ITOT.EQ.LIMORB) THEN
        IF(SOME) THEN
          WRITE(IW,9500) TOL
          DO IATM1=1,NAT
            WRITE(IW,9510) IATM1,IAODEGTOT(IATM1)
          ENDDO
        ENDIF
      ELSE
        IF(MASWRK) WRITE(IW,9550)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C--------------------------------------------------------------------
C--------------------------------------------------------------------
C
C     FINISH THE CONSTRUCTION OF IORDBIG ARRAY.
C     --FIND FIRST 0 IN IORDBIG.
C     --FIND MISSING POSITIONS.
C     --ADD MISSING POSITIONS ONTO IORDBIG.
      IFIND=0
      DO 1005 ILEN=IMARK,NACTBS*NAT
        IF(IORDBIG(ILEN).NE.0) GO TO 1005
        IFIND=ILEN
        GO TO 1006
 1005 CONTINUE
 1006 CONTINUE
      ITMP=IFIND-1
      DO 1010 ILEN=IMARK,ICT_ORB
        IDUM=0
        DO 1020 JPOS=IMARK,ICT_ORB
          IF(ILEN.EQ.IORDBIG(JPOS)) THEN
            IDUM=1
            GO TO 1021
          ENDIF
 1020   CONTINUE
 1021   CONTINUE
        IF(IDUM.EQ.1) GO TO 1010
        ITMP=ITMP+1
        IORDBIG(ITMP)=ILEN
 1010 CONTINUE
C
C     PRINT OUT ANY DIFFERENCE.
      DO ILEN=1,ICT_ORB
        IF(SOME.AND.IORDBIG(ILEN).NE.ILEN) THEN
          WRITE(IW,9600) ILEN,IATLAB(ILEN),IORDBIG(ILEN),EIGSAV(ILEN)
        ENDIF
      ENDDO
C
C
C
C     REORDER ALL ARRAYS RIGHT AFTER THIS VERY CALL.
C
C
C
      RETURN
 9005 FORMAT(//1X,'LOCAL_SVDEXTOPT_ACROSSATOMS ERROR:',
     *        /1X,'NATEXT MUST BE THE WRONG VALUE=,I4')
 9010 FORMAT(//1X,'LOCAL_SVDEXTOPT_ACROSSATOMS ERROR:',
     *        /1X,'ONLY LAST GROUP CAN BE ABOVE L0MBS RIGHT NOW.')
 9020 FORMAT(//1X,'LOCAL_SVDEXTOPT_ACROSSATOMS ERROR:',
     *        /1X,'MEMORY ERROR RELATIVE TO NAOSPH FOR SOME ATOM.')
 9025 FORMAT(1X,'LOCAL_SVDEXTOPT_ACROSSATOMS:',
     *       2X,'SEEKING EXTERNAL ORBITALS LIMORB=',I4)
 9030 FORMAT(//1X,'LOCAL_SVDEXTOPT_ACROSSATOMS ERROR:',
     *        /1X,'USING LESS THAN ALL EXTERNALS REQUIRES',
     *         1X,'MORE CODING HERE.')
 9100 FORMAT(1X,'LOCAL_SVDEXTOPT_ACROSSATOMS:',
     *       2X,'ASCENDING EIGENVALUE SORT WAS SUCCESSFUL.')
 9550 FORMAT(//1X,'LOCAL_SVDEXTOPT_ACROSSATOMS ERROR:',
     *        /1X,'ITOT DOES NOT EQUAL LIMORB AT THE END.')
CKEEP 9560 FORMAT(1X,'IPOSHLD GREATER THAN ZERO.')
 9500 FORMAT(1X,'LOCAL_SVDEXTOPT_ACROSSATOMS:',
     *      /1X,'BASED ON TOL=',1P,E10.2,',',
     *      /1X,'THE DEGENERATE EVALUES INFORMATION NOW FOLLOWS.',
     *      /1X,'NOTE:  THIS TOTAL DEG. ACROSS ATOMS...')
 9510 FORMAT(1X,'ATOM,NUM. OF DEGENERATE OVERLAP EVALUES',I4,I4)
 9600 FORMAT(1X,'DEGENERACY DIFFERENCE OCCURS FOR',
     *       1X,'COUNT,ATOM,IORDBIG,SVD VALUE=',I4,I4,I4,F12.7)
      END
C*MODULE LOCAL   *DECK LOCAL_BLOCK_ORMAS
C> @brief      Checks block-diagonal form of orbital transform.
C>
C> @author     Aaron West
C>             -August 22, 2013
C>
C> @details    This routine can catch problems with the
C>             extensive sorting in local_ppasvd.
C> @param L1     is the length of the AO coefficients.
c> @param NSPACE is the number ORMAS groups.
C> @param MSTA   holds the orbital ranges for ORMAS groups.
C> @param TRANS  is the orbital transformation of interest.
C> @param MASWRK indicates the master process.
C> @param IW     indicates write out to log file.
      SUBROUTINE LOCAL_BLOCK_ORMAS(
     *           L1,NSPACE,MSTA,TRANS,
     *           MASWRK,IW)
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER L1,NSPACE,MSTA(NSPACE),IW
      DOUBLE PRECISION :: TRANS(L1,L1)
C
      INTEGER I,J,II,JJ,IERR
      DOUBLE PRECISION :: TMP,TMP2,TOL
      PARAMETER (TOL=1.0D-08)
C
      IERR=0
      DO II=1,NSPACE-1
        DO JJ=II+1,NSPACE
          DO I=MSTA(II),MSTA(II+1)-1
            DO J=MSTA(JJ),MSTA(JJ+1)-1
              TMP =ABS(TRANS(I,J))
              TMP2=ABS(TRANS(J,I))
              IF(TMP.GT.TOL.OR.TMP2.GT.TOL) IERR=IERR+1
            ENDDO
          ENDDO
        ENDDO
      ENDDO
      IF(IERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9000 FORMAT(//1X,'LOCAL_BLOCK_ORMAS ERROR:',
     *        /1X,'NO ORMAS BLOCK DIGAONAL FORM.')
      END
C*MODULE LOCAL   *DECK LOCAL_SORT_SVDEIG
C> @brief      Sorts atom arrays for local_ppasvd.
C>
C> @author     Aaron West
C>             -August 27, 2013
C>
C> @details    Here, the eigenvalue, transforms, ormas groups, and
C>             atom labels are all sorted at one time.
C>
C> @param IROW      is the number of rows in the orbital transform.
C> @param ICOL      is the number of columns to be sorted.
C> @param NACTBS    is used in the leading dimension.
C> @param NAT       is used in the leading dimension.
C> @param EIGSAV    contains the eigenvalues.
C> @param VTVECSAV  contains the orbital transforms.
C> @param IORDBIG   contains the reordering instructions.
C> @param IORDBIG2  is for copying the reordering instructions.
C> @param IGRPLAB   contains the ORMAS group labels.
C> @param IATLAB    contains the atom labels.
C>
      SUBROUTINE LOCAL_SORT_SVDEIG(
     *           IROW,ICOL,
     *           NACTBS,NAT,EIGSAV,VTVECSAV,
     *           IORDBIG,IORDBIG2,IGRPLAB,IATLAB)
      IMPLICIT NONE
C
      INTEGER IROW,ICOL,NACTBS,NAT
      INTEGER IORDBIG(NACTBS*NAT),IORDBIG2(NACTBS*NAT),
     *        IGRPLAB(NACTBS*NAT),IATLAB(NACTBS*NAT)
      DOUBLE PRECISION :: EIGSAV(NACTBS*NAT),
     *                    VTVECSAV(IROW,NACTBS*NAT)
C
      CALL VICLR(IORDBIG2,1,NACTBS*NAT)
      CALL ICOPY(ICOL,IORDBIG,1,IORDBIG2,1)
      CALL REORDR(EIGSAV,IORDBIG2,ICOL,1)
      CALL ICOPY(ICOL,IORDBIG,1,IORDBIG2,1)
      CALL REORDR(VTVECSAV,IORDBIG2,ICOL,IROW)
      CALL ICOPY(ICOL,IORDBIG,1,IORDBIG2,1)
      CALL IREORDR(IGRPLAB,IORDBIG2,ICOL,1)
      CALL ICOPY(ICOL,IORDBIG,1,IORDBIG2,1)
      CALL IREORDR(IATLAB,IORDBIG2,ICOL,1)
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_CLINDEP
C> @brief      Finds linearly independent orbitals.
C>
C> @author     Aaron West
C>             -September 27, 2013
C>
C> @details    A given set of orbitals are cycled over.
C>             Any linearly dependent orbitals are removed
C>             in two steps:
C>             Step 1:  Diagonalize the orbital overlap.
C>                      Take the number of 0 eigenvalues.
C>                      Sum over eigenvector components.
C>                      Do this action for ALL eigenvectors.
C>                      Remove the eigenvectors with
C>                             biggest contribution.
C>             Step 2:  On entry into the routine,
C>                      different evalues are given that
C>                                indicate compactness.
C>                      Repeatedly form and diagonalize
C>                                 the orbital overlap.
C>                      Check for linear dependence.
C>                      If present, remove diffuse orbital.
C>                      Repeat process.
C>
C> @param IEXTORB  is the total spherical external orbitals.
C> @param IEXTORBF is the final spherical external orbitals.
C>                 Ater testing for linear dependence,
C>                 IEXTORBF external orbitals are left.
C> @param NAOTOT   denotes the total spherical MOs.
C> @param L0MBS    denotes the minimal basis MOs.
C> @param L0       denotes the variational spherical MOs.
C> @param L1       is the length of the AO coefficients.
C> @param L2       is the triangular length of L1.
C> @param L3       is the square of L1.
C> @param VTVEC    contains the external orbitals on entry.
C> @param EIGTMP   contains eigenvalues that denote
C>                 orbital compactness on entry.
C> @param TOL      is the linear dependence tolerance.
C> @param S        is the AO overlap of L2 size on entry.
C> @param S2       is scratch of L2 size.
C> @param VTMP     is scratch of L3 size.
C> @param WRK      is scratch of L1x8 size.
C> @param EIG      is scratch of L1 size.
C> @param IWRK     is scratch of L1 size.
C> @param IWRK2    is scratch of L1 size.
C> @param SOME     is true for master process with nprint not equal -5.
C> @param MASWRK   indicates the master process.
C> @param IW       indicates write out to log file.
C>
      SUBROUTINE LOCAL_CLINDEP(
     *           IEXTORB,IEXTORBF,NAOTOT,L0MBS,L0,L1,L2,L3,
     *           VTVEC,EIGTMP,TOL,
     *           S,S2,VTMP,WRK,EIG,IWRK,IWRK2,
     *           SOME,MASWRK,IW)
      IMPLICIT NONE
C     INPUT VARS.
      LOGICAL SOME,MASWRK
      INTEGER IW,
     *        IEXTORB,IEXTORBF,NAOTOT,L0MBS,L0,L1,L2,L3
      DOUBLE PRECISION ::
     *       TOL,DASUM,
     *       EIGTMP(IEXTORB),VTVEC(L1,IEXTORB),
     *       S(L2),S2(L2),VTMP(L1,L1),WRK(L1*8),EIG(L1)
      INTEGER IWRK(L1),IWRK2(L1)
C     MORE VARS.
      INTEGER IDAMAX,IXAMAX,
     *        ICT,ICTF,IDUM,ITMP,I,J,
     *        IERR2,IERR3
      DOUBLE PRECISION :: TMP,ONE
      PARAMETER (ONE=1.0D+00)
C
C
C
C
C
C     PRINT OUT THE BANNER.
      IF(SOME) WRITE(IW,9000)
C
C     ERROR OUTS
      IF(IEXTORB.NE.NAOTOT-L0MBS) THEN
        IF(MASWRK) WRITE(IW,9010)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     INITIALIZE SOME ITEMS.
      ICT=0
      IEXTORBF=IEXTORB
C
C--------------------------------
C     PERFORM KR'S CRITERION.
C--------------------------------
C
C     PREPARE FOR DISJUNCT DASUM.
      CALL VCLR(S2,1,L2)
      CALL TFTRI(S2,S,VTVEC,WRK,IEXTORB,L1,L1)
      IERR2=0
      CALL VCLR(VTMP,1,L3)
      CALL GLDIAG(L1,IEXTORB,IEXTORB,S2,WRK,EIG,VTMP,IERR2,IWRK)
      IF(IERR2.GT.0) THEN
        IF(MASWRK) WRITE(IW,9020)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     DO SOME MORE CHECKING AND PRINTING.
      ICT=0
      IERR3=0
      DO I=1,IEXTORB
        IF(EIG(I).LT.-1.0D-06) IERR3=IERR3+1
        IF(EIG(I).LT.TOL) THEN
          IF(MASWRK) WRITE(IW,9030) TOL,EIG(I)
          ICT=ICT+1
        ENDIF
      ENDDO
      IF(IERR3.GT.0) THEN
        IF(MASWRK) WRITE(IW,9040)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
      IF(ICT.NE.NAOTOT-L0) THEN
        IF(MASWRK) WRITE(IW,9050)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     PERFORM DISJUNCT DASUM OVER EIGENVECTOR
C     --ROWS==>COLUMNS WITH ZERO EVALUES
      CALL VCLR(EIG,1,L1)
      CALL TRPOSQ(VTMP,L1)
      DO I=1,IEXTORB
        EIG(I)=DASUM(ICT,VTMP(1,I),1)
      ENDDO
      CALL VCLR(VTMP,1,L3)
      CALL VICLR(IWRK,1,L1)
      DO I=IEXTORB,IEXTORB-ICT+1,-1
        IDUM=IDAMAX(IEXTORB,EIG,1)
        EIG(IDUM)=0.0D+00
        IWRK(I)=IDUM
        IF(SOME) WRITE(IW,9060) L0MBS+IDUM
      ENDDO
      ITMP=0
      DO 50 I=1,IEXTORB
        DO J=IEXTORB-ICT+1,IEXTORB
          IF(IWRK(J).EQ.I) GO TO 50
        ENDDO
        ITMP=ITMP+1
        IWRK(ITMP)=I
   50 CONTINUE
C
C     APPLY ORDERINGS TO MY MASTER,ETC.
      CALL ICOPY(L1,IWRK,1,IWRK2,1)
      CALL REORDR(EIGTMP,IWRK2,IEXTORB,1)
      CALL ICOPY(L1,IWRK,1,IWRK2,1)
      CALL REORDR(VTVEC,IWRK2,IEXTORB,L1)
C
C     INITIALIZE IEXTORBF VARIABLE.
      IEXTORBF=IEXTORB-ICT
C
C--------------------------------
C     PERFORM REMOVE SMALL EVALUE.
C--------------------------------
C
C     NOW, INVERT THE EIGTMP EVALUES.
      DO I=1,IEXTORB
        TMP=EIGTMP(I)
        EIGTMP(I)=ONE/TMP
      ENDDO
C
C     CYCLE OVER A DIAG. PROCEDURE.
      DO I=1,IEXTORB-ICT
        IF(SOME) WRITE(IW,9070) I
        CALL VCLR(S2,1,L2)
        CALL TFTRI(S2,S,VTVEC,WRK,IEXTORBF,L1,L1)
        IERR2=0
        CALL GLDIAG(L1,IEXTORBF,IEXTORBF,S2,WRK,EIG,VTMP,IERR2,IWRK)
        IF(IERR2.GT.0) THEN
          IF(MASWRK) WRITE(IW,9020)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
C
C       IF POSSIBLE, BREAK THE CYCLE.
        ICTF=0
        DO J=1,IEXTORBF
          IF(EIG(J).LT.TOL) ICTF=ICTF+1
        ENDDO
        IF(ICTF.EQ.0) GO TO 200
C
C       FIND THE SMALLEST==>NOW BIGGEST EVALUE.
        IDUM=IDAMAX(IEXTORBF,EIGTMP,1)
        EIGTMP(IDUM)=0.0D+00
        CALL VICLR(IWRK,1,L1)
        ITMP=0
        DO 100 J=1,IEXTORBF
          IF(J.EQ.IDUM) GO TO 100
          ITMP=ITMP+1
          IWRK(ITMP)=J
  100   CONTINUE
        IWRK(IEXTORBF)=IDUM
C
C       APPLY ORDERINGS TO MY MASTER,ETC.
        CALL ICOPY(L1,IWRK,1,IWRK2,1)
        CALL REORDR(EIGTMP,IWRK2,IEXTORBF,1)
        CALL ICOPY(L1,IWRK,1,IWRK2,1)
        CALL REORDR(VTVEC,IWRK2,IEXTORBF,L1)
C
C       RESET IEXTORBF.
        IEXTORBF=IEXTORBF-1
      ENDDO
C     THE EXIT LINE.
  200 CONTINUE
C
      RETURN
 9000 FORMAT(//1X,'LOCAL_CLINDEP HAS BEGUN...')
 9010 FORMAT(//1X,'LOCAL_CLINDEP ERROR:',
     *        /1X,'IEXTORB DOES NOT MAKE SENSE.')
 9020 FORMAT(//1X,'LOCAL_CLINDEP ERROR:',
     *        /1X,'DIAGONALIZATION FAILED.')
 9030 FORMAT(1X,'SVDEXTOPT DIAGONALIZATION WARNING:',
     *       2X,'TOL,SMALL EVALUE=',1X,1P,E10.2,', ',1P,E10.2)
 9040 FORMAT(//1X,'LOCAL_CLINDEP ERROR:',
     *        /1X,'THESE EVALUES CANNOT BE LESS THAN ZERO.')
 9050 FORMAT(//1X,'LOCAL_CLINDEP ERROR:',
     *        /1X,'NUMBER OF BAD EIGENVALUES DOES NOT EQUAL',
     *        /1X,'NAOTOT MINUS L0.')
 9060 FORMAT(1X,'QMTTOL SETTING DROPS QUAO NUMBER=',I4)
 9070 FORMAT(1X,'CLINDEP ITERATION=',I4)
      END
C*MODULE LOCAL   *DECK LOCAL_DAT_ATOMS
C> @brief      Atom label group for external orbitals.
C>
C> @author     Aaron West
C>             -September 27, 2013
C>
C> @details    The group can be written out
C>             at any starting orbital.
C>
C> @param L1       is the length of the AO coefficients.
C> @param L0FIN    in the final spherical MOs.
C> @param ISTART   is the start orbital for writing out atom labels.
C> @param IATLAB   is the integer array that holds the atom labels.
C> @param IP       indicates write out to the dat file.
C> @param MASWRK  indicates the master process.
C> @param IW       indicates write out to the log file.
C>
      SUBROUTINE LOCAL_DAT_ATOMS(
     *           L1,L0FIN,ISTART,IATLAB,IP,MASWRK,IW)
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER IP,IW,
     *        L1,L0FIN,ISTART
      INTEGER IATLAB(L1)
C
      INTEGER IERR,I
C
C     CHECK FOR NON-ZERO LABELS IN L0FIN+1 --> L1
C     IF SO, BOMB OUT.  TRUST ME.  PRECISE IS BETTER NOW.
      IERR=0
      DO I=L0FIN+1,L1
        IF(IATLAB(I).NE.0) IERR=IERR+1
      ENDDO
      IF(IERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     PRINT OFF ATOM LABELS TO .DAT FILE.
      IF(MASWRK) THEN
        WRITE(IP,9010)
        WRITE(IP,9015) ISTART
        DO I=ISTART,L0FIN-1
          WRITE(IP,9020) IATLAB(I)
          IF(MOD(I,10).EQ.0) WRITE(IP,9030)
        ENDDO
        WRITE(IP,9040) IATLAB(L0FIN)
        WRITE(IP,9050)
      ENDIF
C
      RETURN
 9000 FORMAT(//1X,'LOCAL_DAT_ATOMS ERROR',
     *        /1X,'AFTER L0FIN NEEDS TO BE ALL 0S.')
 9010 FORMAT(//1X,'$IATLAB')
 9015 FORMAT(1X,'IATLAB(',I4,')=')
 9020 FORMAT(I4',',$)
 9030 FORMAT(1X)
 9040 FORMAT(I4,$)
 9050 FORMAT(/1X'$END'//)
      END
C*MODULE LOCAL   *DECK LOCAL_SPLITQA
C> @brief      Driver for q.a. split-localized orbitals.
C>
C> @author     Aaron West
C>             -June 28, 2013
C>
C> @details    Given oriented q.a. orbitals,
C>             routine forms split-localized orbitals.
C>             Unlike ER orbitals, process only involves Jacobi
C>             rotations and is more efficient for larger
C>             systems.
C>             The same algorithm is used as in the orientation
C>             code but the Jacobi rotations are not restricted
C>             to be intra-atomic.
C>
      SUBROUTINE LOCAL_SPLITQA
      IMPLICIT NONE
      LOGICAL SOME,ORMFUL_SAV
      INTEGER L0,L1,L2,L3,ISIZE_FCCWFN
      INTEGER I,ITMP,ITMP2
      INTEGER IMBS,L0MBS,L3MBS,ISWMBS,NCORTOT,
     *        NVVOS_NUMCOR,LOCAL_NUMVAL
      INTEGER NGOTMX,LOADFM,LAST,NEED,
     *        LNOROT,LIIR,LVTORB,LVEC,LVEC2,LVMAT,LMSTA_SAV,LTRANS,
     *        LS,LS2
      INTEGER NOUT,IPASS,MCORE,MDOC,N1,
     *        NSPACE_SAV,IVVOS_SAV
      DOUBLE PRECISION :: SCFTYP_SAV,CISTEP_SAV,
     *                    RHF,ROHF,RMC,ORMAS
C
      INTEGER MXITER,IADDINC,ISKIP
      DOUBLE PRECISION :: CRIT
C-----------------------------------------------------------------------
      INTEGER NSPACE,MSTA,MNUM,MINI,MAXI,
     *        IAMI,IAMA,IBMI,IBMA,IDIMFCC,
     *        LBST,NREF0
      LOGICAL FDIRCT,QCORR
      DOUBLE PRECISION :: C0SQ
C
      DOUBLE PRECISION :: X
C
      DOUBLE PRECISION :: C,ZAN
      INTEGER ICH,NQMT,NUM,MUL,NA,NAT,NB,NE,IAN
C
      INTEGER IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA
C
      LOGICAL CANONC,FCORE,FORS,EKT,LINSER
      DOUBLE PRECISION ::
     *       FINALCI,METHOD,CISTEP,ACURCY,ENGTOL,DAMP
      INTEGER MICIT,NWRDMC,NORBMC,NOROT,MOFRZ,
     *        NPFLG,NOFO,MCFMO,IDIABAT
C
      DOUBLE PRECISION :: CVGLOC
      INTEGER MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,
     *        MOOUTA,MOOUTB
C
      LOGICAL ORIENT,ORIKIN,ORMFUL
      INTEGER NATMOR,ISVMOR,ISVDOP,L0DEP0
      DOUBLE PRECISION :: EXTLOC,EREFATM,COUP_NT_VVO
C
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION :: RUNTYP,EXETYP,CHECK
      INTEGER NEVALS,NGLEVL,NHLEVL
C
      INTEGER IVVOS,NVVOS
      DOUBLE PRECISION :: BNDDEN
C
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C
C-----------------------------------------------------------------------
      INTEGER MXATM,MXNORO,MXAO
      PARAMETER (MXATM=2000, MXNORO=250, MXAO=8192)
C-----------------------------------------------------------------------
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIMFCC(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWRDMC,NORBMC,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /OPTLOC/ CVGLOC,MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,
     *                MOOUTA(MXAO),MOOUTB(MXAO)
      COMMON /ORNTMO/ EXTLOC,EREFATM,COUP_NT_VVO(MXATM),
     *                NATMOR(MXAO),ISVMOR(MXATM),ISVDOP,L0DEP0,
     *                ORIENT,ORIKIN,ORMFUL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /VVOPAR/ IVVOS,NVVOS,BNDDEN
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C-----------------------------------------------------------------------
C
C     DATA STUFF
      DATA CHECK/8HCHECK   /
      DATA ORMAS/8HORMAS   /
      DATA RHF/8HRHF     /
      DATA RMC/8HMCSCF   /
      DATA ROHF/8HROHF    /
C
C     DEFINE PRINT STUFF
      SOME = NPRINT.NE.-5 .AND. MASWRK
C
C     PRINT STUFF
      IF(SOME) WRITE(IW,9000)
C
C     SKIP FOR EXETYP
      IF(EXETYP.EQ.CHECK) GO TO 8999
C
C     SET UP SOME ORBITAL DIMENSIONS
      L0 = NQMT
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
      ISIZE_FCCWFN=51
C
C     CALCULATE IMBS,NCORTOT, AND L0MBS.
      IMBS=0
      ISWMBS=1
      DO I=1,NAT
        IMBS=IMBS+LOCAL_NUMVAL(I,ISWMBS)
      ENDDO
      NCORTOT=NVVOS_NUMCOR(0,0)
      L0MBS=NCORTOT+IMBS
      L3MBS=L0MBS*L0MBS
C
C     ALLOCATE MAIN MEMORY.
      CALL GOTFM(NGOTMX)
      CALL VALFM(LOADFM)
      LNOROT    = LOADFM + 1
      LIIR      = LNOROT + L3MBS
      LVTORB    = LIIR   + L1
      LVEC      = LVTORB + L3
      LVEC2     = LVEC   + L3
      LVMAT     = LVEC2  + L3
      LMSTA_SAV = LVMAT  + L3
      LTRANS    = LMSTA_SAV + ISIZE_FCCWFN
      LS        = LTRANS + L3MBS
      LS2       = LS     + L2
      LAST      = LS2    + L2
      NEED      = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
C     GRAB THE NEEDED ORBITAL TRANSFORMATION.
      CALL DAREAD(IDAF,IODA,X(LVEC),L3,538,0)
      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      CALL LOCAL_CHECK_ORTHOG(
     *     L0,L1,L2,
     *     X(LS2),X(LS),X(LVEC),X(LVTORB),
     *     MASWRK,IW)
C
      CALL VCLR(X(LVTORB),1,L3)
      CALL VCLR(X(LVMAT),1,L3)
      CALL DAREAD(IDAF,IODA,X(LVEC),L3,538,0)
      CALL DAREAD(IDAF,IODA,X(LVEC2),L3,286,0)
      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      CALL MTARBR(X(LS),L1,X(LVEC),L0MBS,X(LVMAT),L1,1)
      CALL MRTRBR(X(LVEC2),L1,L1,L0MBS,X(LVMAT),L1,L0MBS,X(LVTORB),L1)
CKEEP      CALL MALMQ_TORB(
CKEEP     *     X(LVEC),X(LVEC2),X(LVTORB),X(LSBAR),X(LSHAT),
CKEEP     *     X(LVMAT),X(LWRKINV),X(LIPVT),X(LS),L0,L1,L2,L3,
CKEEP     *     0,L0,MASWRK)
C
C     READ THE INITIAL OCCUPIED+VVOS ORBITALS.
      CALL DAREAD(IDAF,IODA,X(LVEC),L3,538,0)
C
C     SAVE THE ORIGINAL MSTA ARRAY.
      CALL ICOPY(ISIZE_FCCWFN,MSTA,1,X(LMSTA_SAV),1)
      NSPACE_SAV=NSPACE
C
C     SETUP RHF,ROHF,RMC ORBITAL DIMENSIONS.
C     NOTE:
C     --RIGHT AWAY, SET UP THE CORE TO BE LOCALIZED.
C       THIS ACTION WILL PAY OFF WITH BIGGER MOLECULES.
C       CORE ORBITALS PROBABLY ONLY HAVE SVD DONE.
C     --SVD ALREADY HAS ERRORS OUT FOR ACCESSING OUTSIDE
C       THE ACTUAL SIZE OF THE MSTA ARRAY.
C       SO, THOSE ERROR OUTS ARE NOT REPEATED HERE.
      IF(SCFTYP.EQ.RHF) THEN
        CALL VICLR(MSTA,1,ISIZE_FCCWFN)
        NSPACE=3
        MSTA(1)=1
        MSTA(2)=NCORTOT+1
        MSTA(3)=NA+1
        MSTA(4)=L0MBS+1
      ELSEIF(SCFTYP.EQ.ROHF) THEN
        CALL VICLR(MSTA,1,ISIZE_FCCWFN)
        NSPACE=4
        MSTA(1)=1
        MSTA(2)=NCORTOT+1
        MSTA(3)=NB+1
        MSTA(4)=NA+1
        MSTA(5)=L0MBS+1
      ELSEIF(SCFTYP.EQ.RMC) THEN
        IF(SOME) WRITE(IW,9040) NSPACE,(MSTA(I),I=1,NSPACE)
        IF(SOME) WRITE(IW,9045)
C       ACCOUNT FOR THE ADDITION OF THE CORE TO NSPACE RIGHT AWAY.
        IADDINC=1
        IF(MSTA(1).NE.NCORTOT+1) THEN
          IADDINC=IADDINC+1
        ENDIF
C       SHIFT THE ORGINAL MSTA VALUES NOW.
        DO I=NSPACE,1,-1
          MSTA(I+IADDINC)=MSTA(I)
        ENDDO
C       DETERMINE IF ANOTHER GROUP IS NEEDED FOR VVOS.
C       --DEAL WITH IT NOW.
        CALL LOCAL_SVDVVOS_RMC_SETUP1(ITMP,ITMP2)
        ITMP=ITMP+ITMP2+1
        IF(ITMP.NE.L0MBS+1) THEN
          IADDINC=IADDINC+1
          MSTA(NSPACE+IADDINC)=ITMP
        ENDIF
C       RE-DEFINE THE SIZE OF THE MSTA SPACE.
        NSPACE=NSPACE+IADDINC
C       ADD THE REQUIRED NEW ORBITAL STARTING RANGES.
        MSTA(1)=1
        MSTA(2)=NCORTOT+1
        MSTA(NSPACE+1)=L0MBS+1
        IF(SOME) WRITE(IW,9040) NSPACE,(MSTA(I),I=1,NSPACE)
      ELSE
        IF(MASWRK) WRITE(IW,9050)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     SETUP VARIABLES FOR THE LMOFRZ USAGE.
C     NOTES:
C     --FOR ILOCAL=4,    LMOPSI DOES NOT LEAVE WAVEFXN INVARIANT.
C       FOR HATREE-FOCK, LMOPSI IS SETUP FOR QUASI-ATOMIC ORBITALS.
C     --IVVOS REDIM. IS ALSO TRICKY.
C       LOCAL_SVDVVOS REDIM. ROUTINES DO NOT LEAVE WAVEFXN INVARIANT.
C     --JUST USE ORMAS GROUPS FOR EVERYTHING IN LMOFRZ TO BE SAFE.
      NOUT=0
      IPASS=1
      MCORE=0
      MDOC=0
      N1=L0MBS
C
C     SETUP LNOROT ARRAY THROUGH LMOFRZ IN ORMAS-LIKE FASHION.
C     NOTE:  IF SYMLOC=.T., SYMMETRY WILL WORK.
      SCFTYP_SAV=SCFTYP
      SCFTYP=RMC
      CISTEP_SAV=CISTEP
      CISTEP=ORMAS
      IVVOS_SAV=IVVOS
      IVVOS=0
      ORMFUL_SAV=ORMFUL
      ORMFUL=.FALSE.
      CALL LMOFRZ(NOUT,IPASS,MCORE,MDOC,N1,X(LNOROT),X(LIIR),L1)
      SCFTYP=SCFTYP_SAV
      CISTEP=CISTEP_SAV
      IVVOS=IVVOS_SAV
      ORMFUL=ORMFUL_SAV
C
C     RESTORE THE TRUE MSTA ARRAY.
      CALL ICOPY(ISIZE_FCCWFN,X(LMSTA_SAV),1,MSTA,1)
      NSPACE=NSPACE_SAV
C
C     SETUP THE MAX. ITERS INSIDE OF NEXT JACOBI CALL.
C     SETUP THE TOLERANCE = CRIT.
      IF(MAXLOC.EQ.250) THEN
        MXITER=100000
      ELSE
        MXITER=MAXLOC
      ENDIF
      CRIT=CVGLOC
C
C     PERFORM JACOBI ROTATIONS
      ISKIP=0
      CALL LOCAL_SPLITQA_JACOBI(
     *     X(LTRANS),X(LVTORB),X(LNOROT),
     *     L1,L0MBS,L0MBS,NCORTOT,CRIT,MXITER,ISKIP,
     *     SOME,MASWRK,IW)
C
C     FORM QA SPLIT LOCALIZED ORBITALS.
      CALL DAREAD(IDAF,IODA,X(LVTORB),L3,538,0)
      CALL MRARBR(
     *     X(LVTORB),L1,L1,L0MBS,
     *     X(LTRANS),L0MBS,L0MBS,
     *     X(LVEC),L1)
      CALL DCOPY(L3,X(LVEC),1,X(LVTORB),1)
      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      CALL LOCAL_CHECK_ORTHOG(
     *     L0,L1,L2,
     *     X(LS2),X(LS),X(LVEC),X(LVTORB),
     *     MASWRK,IW)
C
C     PRINT ORBITALS.
      IF(SOME) THEN
        WRITE(IW,9070)
        WRITE(IW,9071) L0MBS
        CALL PRSQL(X(LVEC),L0MBS,L1,L1)
      ENDIF
      IF(MASWRK) THEN
        WRITE(IP,9080)
        CALL PUSQL(X(LVEC),L0MBS,L1,L1)
        WRITE(IP,9085)
      ENDIF
C
C     NOW, WRITE TO DAF71.
C     --LOCAL_NOS_EXT VERSIONS PICK UP DAF534.
C     --LOCAL_EXT_LMO(2) PUTS ORBITALS FROM DAF71 INTO DAF534.
C     --LOCAL_LCAO_WGTS USES DAF534 FOR EXTLOC SITUATIONS.
      CALL DAWRIT(IDAF,IODA,X(LVEC),L3,71,0)
C
C     CLEAR OUT THE DENSITY FOR LMOS ON DAF71.
      CALL VCLR(X(LVTORB),1,L3)
      ITMP=(IMBS*IMBS+IMBS)/2
      CALL DAWRIT(IDAF,IODA,X(LVTORB),ITMP,285,0)
C
C     DEALLOCATE MEMORY.
      CALL RETFM(NEED)
C
C     FINISH UP.
 8999 CONTINUE
      IF(SOME) THEN
        WRITE(IW,9300)
        CALL TIMIT(1)
      ENDIF
      RETURN
 9000 FORMAT(/5X,60(1H-)/
     *   5X,'LOCAL_SPLITQA NOW LOCALIZES ORBITALS ONTO'/
     *   5X,'AS FEW QUAOS AS POSSIBLE.'/
     *   5X,60(1H-))
 9040 FORMAT(/1X,'THE NUMBER OF SPACES             =',I4/
     *        1X,'EACH SPACE STARTS AT ORBITAL     =',50I4)
 9045 FORMAT(/1X,'LOCAL_SPLITQA CHANGES NUMBER OF ORMAS GROUPS.')
 9050 FORMAT(/1X,'LOCAL_SPLITQA ERROR:',
     *       /1X,'SCFTYP DOES NOT EXIST YET.')
 9070 FORMAT(//10X,'SPLITQA LOCALIZED ORBITALS')
 9071 FORMAT(10X,I5,1X,'ORBITALS ARE SHOWN.')
 9080 FORMAT('SPLITQA LOCALIZED ORBITALS'/' $VEC')
 9085 FORMAT(' $END')
 9300 FORMAT(1X,'... DONE WITH LOCAL_SPLITQA ...')
      END
C*MODULE LOCAL   *DECK LOCAL_SPLITQA_JACOBI
C> @brief      Forms q.a. split-localized orbitals.
C>
C> @author     Aaron West
C>             -June 28, 2013
C>
C> @details    The canonical orbitals can be expressed in terms of
C>             the oriented q.a. orbitals.  A transformation is developed
C>             that expresses the canonical orbitals in terms of fewest
C>             oriented q.a. orbitals that are of course as large as possible.
C>
C> @param TRANS   will hold the final orbital transformation.
C> @param VTORB   is the orbital transformation between
C>                the oriented q.a. and canonical orbitals from DAF538.
C> @param NOROT   is the index array that holds allowed Jacobi rotations.
C>                =0 means the rotation is permitted.
C>                =1 means the rotation is not permitted.
C> @param L1      is the length of the AO coefficients.
C> @param LDMORB  is leading dimension for TRANS and NOROT
C>                and depends on memory.
C> @param MORB    is the total number of orbitals that might
C>                be used in the rotations.
C> @param NCORTOT is the total number of chemical core orbitals.
C> @param CRIT    is the tolerance for convergence.
C> @param MXITER  is allowed maximum iterations.
C> @param ISKIP   skips the block-diagonal form analysis for the orbitals.
C>                ISKIP=0 does NOT skip.
C>                ISKIP=1 does skip.
C> @param SOME    is true for master process with nprint not equal -5.
C> @param MASWRK  indicates the master process.
C> @param IW      indicates write out to log file.
C>
      SUBROUTINE LOCAL_SPLITQA_JACOBI(
     *           TRANS,VTORB,NOROT,
     *           L1,LDMORB,MORB,NCORTOT,CRIT,MXITER,ISKIP,
     *           SOME,MASWRK,IW)
      IMPLICIT NONE
C-----------------------------------------
      LOGICAL SOME,MASWRK
      DOUBLE PRECISION :: CRIT
      INTEGER L1,LDMORB,MORB,NCORTOT,MXITER,ISKIP,IW
      DOUBLE PRECISION :: VTORB(L1,L1),TRANS(LDMORB,LDMORB)
      INTEGER NOROT(LDMORB,LDMORB)
C-----------------------------------------
      INTEGER I,J,ITER,NUMROT,IERR,IK
      DOUBLE PRECISION ::
     *       Q,QTOL,R2,R3,PIKI,PIKJ,PIKJ2,PIKI2,PIKIJ,
     *       ATAN2,THETA,A,B,TMP,TMP2
C-----------------------------------------
      DOUBLE PRECISION :: ZERO,ONE,TOL2
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00, TOL2=1.0D-08)
C-----------------------------------------
C
C     DEFINE THE Q VAR.
      QTOL=CRIT*1.0D-02
C
C     MODIFY NOROT TO SKIP I=J ROTATIONS.
      DO I=1,MORB
        NOROT(I,I)=1
      ENDDO
C
C     INTIALIZE ITER AND THE ORBITAL TRANSFORM HERE.
      ITER=0
      CALL VCLR(TRANS,1,LDMORB*LDMORB)
      DO I=1,MORB
        TRANS(I,I)=ONE
      ENDDO
C
C     AT THIS POINT, VTORB MUST BE BLOCK-DIAGONAL.
C     NOTE:  THIS RESULT ACTUALLY MEANS THAT THE SUM
C            OVER IK BELOW IS LEGAL.
      IF(ISKIP.NE.0) GO TO 90
      IERR=0
      DO I=1,NCORTOT
        DO J=NCORTOT+1,L1
          TMP =ABS(VTORB(I,J))
          TMP2=ABS(VTORB(J,I))
          IF(TMP.GT.TOL2.OR.TMP2.GT.TOL2) IERR=IERR+1
          VTORB(I,J)=ZERO
          VTORB(J,I)=ZERO
        ENDDO
      ENDDO
      DO I=NCORTOT+1,MORB
        DO J=MORB+1,L1
          TMP =ABS(VTORB(I,J))
          TMP2=ABS(VTORB(J,I))
          IF(TMP.GT.TOL2.OR.TMP2.GT.TOL2) IERR=IERR+1
          VTORB(I,J)=ZERO
          VTORB(J,I)=ZERO
        ENDDO
      ENDDO
      IF(IERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9020)
        IF(MASWRK) WRITE(IW,9100)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     PRINT START OF JACOBI ROTATIONS.
   90 CONTINUE
      IF(SOME) WRITE(IW,9000)
      IF(SOME) WRITE(IW,9010)
C
C     LOOP OVER PAIRS OF ORBITALS.
  100 CONTINUE
      NUMROT=0
      ITER = ITER + 1
C----------------------------------------------
C----------------------------------------------
      DO 8000 I=1,MORB
        DO 7000 J=I+1,MORB
          IF(NOROT(I,J).EQ.1) GO TO 7000
C----------------------------------------------
C----------------------------------------------
C
C         OBTAIN ROTATION ANGLE.
          R2=ZERO
          R3=ZERO
          DO 6000 IK=1,MORB
            PIKI=VTORB(IK,I)
            PIKJ=VTORB(IK,J)
            PIKI2 = PIKI*PIKI
            PIKJ2 = PIKJ*PIKJ
            PIKIJ = PIKI*PIKJ
C
            R2 = R2 + PIKI2*PIKI2
     *              - 6.0D+00*PIKI2*PIKJ2
     *              + PIKJ2*PIKJ2
            R3 = R3 + PIKI2*PIKIJ - PIKJ2*PIKIJ
C
 6000          CONTINUE
C
          R2 = (R2/4.0D+00)
          Q = SQRT(R2*R2 + R3*R3)
          IF (Q.LT.QTOL) GO TO 7000
          THETA = (ATAN2((R3/Q),(R2/Q)))/4.0D+00
C
C         CHECK IF THE ROTATION IS WORTH EXECUTING.
          IF(ABS(THETA).LT.CRIT) GOTO 7000
C
C         UPDATE TRANSFORMATION.
C         UPDATE D COEFFICIENTS. I.E. VTORB.
          NUMROT = NUMROT + 1
          A = COS(THETA)
          B = -SIN(THETA)
          CALL ADJTR(I,J,L1,A,B,VTORB)
          CALL ADJTR(I,J,LDMORB,A,B,TRANS)
C
C----------------------------------------------
C----------------------------------------------
 7000     CONTINUE
 8000   CONTINUE
C----------------------------------------------
C----------------------------------------------
C
      IF(ITER.GT.MXITER) THEN
        IF(MASWRK) THEN
          WRITE(IW,9020)
          WRITE(IW,9030) MXITER
        ENDIF
         CALL FLSHBF(IW)
         CALL ABRT
      ENDIF
C
C  IF THERE WERE ANY ROTATIONS, DO ANOTHER SWEEP.
C
      IF (NUMROT.GT.0) GOTO 100
C
      IF(MASWRK) THEN
        WRITE(IW,9000)
        WRITE(IW,9040) ITER
      ENDIF
C
      RETURN
 9000 FORMAT(/1X,'LOCAL_SPLITQA_JACOBI:')
 9010 FORMAT(1X,'BEGIN SPLITQA JACOBI ROTATIONS.')
 9020 FORMAT(/1X,'LOCAL_SPLITQA_JACOBI ERROR:')
 9030 FORMAT(1X,'ORBITALS NOT CONVERGED AFTER ',I10,' ITERS.')
 9040 FORMAT(1X,' -- NUMBER OF SWEEPS REQUIRED FOR CONVERGENCE =',I5)
 9100 FORMAT(1X,'BLOCK DIAGONAL FORM OF VTORB IS INCORRECT.')
      END
C*MODULE LOCAL   *DECK LOCAL_LINEQ_ATOM
C> @brief      Reorders atomic linear equations.
C>
C> @author     Aaron West
C>             -October 22, 2013
C>
C> @param NAT     is the number of atoms.
C> @param IORDAT  holds the reordering instructions.
C> @param DMAT    is the matrix with dimension of NATxNAT.
C> @param FRHS    is the right hand side of NATx1.
C> @param ATSCR   is a scratch array of dimensions NATx(NAT+1)
C> @param RESID   will hold the solution to solving linear equation.
C> @param MASWRK  indicates the master process.
C> @param IW      indicates write out to log file.
      SUBROUTINE LOCAL_LINEQ_ATOM(
     *           NAT,IORDAT,
     *           DMAT,FRHS,ATSCR,RESID,
     *           MASWRK,IW)
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER IW,
     *        NAT
      INTEGER IORDAT(NAT)
      DOUBLE PRECISION ::
     *       DMAT(NAT,NAT),FRHS(NAT),ATSCR(NAT,NAT+1),
     *       RESID
C
      INTEGER I,J,IERR
      DOUBLE PRECISION :: TMP
C
C     CHECK ATOM LABELS.
C     NOTE1:  RUN HAS ALREADY BOMBED IF LESS THAN 2 ATOMS.
C     NOTE2:  VAR TYPES ARE NOT VIOLATED INSIDE OF ROUTINES.
      CALL ICOPY(NAT,IORDAT,1,ATSCR,1)
      CALL ICOPY(NAT,IORDAT,1,ATSCR(1,2),1)
      CALL IREORDR(ATSCR,ATSCR(1,2),NAT,1)
C
C     SHIFT EQUATION.
      CALL VCLR(ATSCR,1,NAT*(NAT+1))
      CALL DCOPY(NAT,FRHS,1,ATSCR(1,NAT+1),1)
      CALL DCOPY(NAT*NAT,DMAT,1,ATSCR,1)
      DO I=1,NAT
        FRHS(I)=ATSCR(IORDAT(I),NAT+1)
        DO J=1,NAT
          DMAT(I,J)=ATSCR(IORDAT(I),IORDAT(J))
        ENDDO
      ENDDO
      CALL VCLR(ATSCR,1,NAT*(NAT+1))
C
C     GRAB MAX RESIDUAL AND CHECK CONVERGENCE.
      RESID=ABS(FRHS(1))
      DO I=1,NAT-1
        TMP=ABS(FRHS(I))
        RESID=MAX(RESID,TMP)
      ENDDO
C
C     SOLVE DMAT * X = FRHS LINEAR EQUATION.
      IERR=0
      CALL SLVLEQ(DMAT,FRHS,ATSCR,NAT-1,NAT,0,IERR)
      IF(IERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9005)
        CALL FLSHBF(IW)
        CALL ABRT
         STOP
      ENDIF
C
C     SHIFT RESULTS BACK.
      CALL VCLR(ATSCR,1,NAT*(NAT+1))
      CALL DCOPY(NAT,FRHS,1,ATSCR(1,NAT+1),1)
      CALL DCOPY(NAT*NAT,DMAT,1,ATSCR,1)
      DO I=1,NAT
        FRHS(IORDAT(I))=ATSCR(I,NAT+1)
        DO J=1,NAT
          DMAT(IORDAT(I),IORDAT(J))=ATSCR(I,J)
        ENDDO
      ENDDO
      CALL VCLR(ATSCR,1,NAT*(NAT+1))
C
      RETURN
 9005 FORMAT(/1X,'LOCAL_ATOM_LINEQ ERROR:',
     *       /1X,'ERROR IN SMALL LINEAR EQUATION.')
      END
