C 23 MAR 12 - DGF - PAD COMMON BLOCKS
C 28 DEC 11 - CS  - CHANGES AND ADDITIONS TO EFMO, INCLUDING
C                   SCREENING FROM INPUT, COVALENT BONDS,
C                   CORRELATION, SCREENING OF BOND POLARIZATION
C                   TENSORS ALONG WITH SYNC OF COMMON BLOCKS
C                   REVERT HLs CHANGE AS THEY MEAN NOTHING TO EFMO
C 15 APR 11 - MWS - SYNCH FMOPNT COMMON
C 12 DEC 10 - HL  - ADD CALLS TO INDCHG,INDDPL,INDQUA,INDIND
C  1 OCT 10 - CS  - EFMO FUNCTIONS AND UTILITIES
C
C*MODULE EFMO     *DECK EFMOGFRG
      SUBROUTINE EFMOGFRG(iaglob,indat)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER(MXATM=2000,MXAO=8192,MXIFRQ=12,NMO=500)
C
      DIMENSION iaglob(*),indat(*)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL MOIDON,EDCOMP,DIPDCM,QADDCM,DEPRNT,ZDO,POLDCM,POLANG,
     *        POLNUM,POLAPP,KMIDPT,POLDYN
      LOGICAL OPOLNUM, OPOLDYN, OPOLDCM,DODENMUL
      INTEGER OILOCAL,ONPTSTN
      LOGICAL POLAR,DISPER,EXREP,CHGTRN,MFRZ,CTVVO
      
C
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,IEFMORUN,
     *                IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,IEFMODIM(2),
     *                IMODEFE,NATEFMO,IMODEFD
      COMMON /EFMOPO/ LNEFMOPTS,LEFMOPTS,LEFMOPPTS,LEFMODPTS,LEFMODIMG,
     *                LEFMOTOTG,LEFMOIPT,LEFMOIGLOB
      COMMON /EFPFMO/ RUNEFP,REFFMO,REPNUCEFP,IEFPFMO,ISWENUC,EFPEFP
      COMMON /EDCMP / ZIJ(NMO),ZMO(5,NMO),OCCUP(NMO),DPFREQ(50),
     *                MOIDNO(5,NMO),IJMO(2,NMO),MOIJ(NMO),NMOIJ(NMO),
     *                NMOAT(NMO),NDPFREQ,IPROT(5),NPROT,
     *                MOIDON,EDCOMP,DIPDCM,DEPRNT,QADDCM,ZDO,POLDCM,
     *                POLANG,POLAPP,KMIDPT,POLDYN
      COMMON /FMCOM / X(1)
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MFRPAR/ MFRZ,NUMFRZ,NORFRZ,IFRZ(MXAO)
      COMMON /OPTLOC/ CVGLOC,MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,
     *                MOOUTA(MXAO),MOOUTB(MXAO)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PDCPAR/ CENTER(3),DPOLE(3),QPOLE(6),RMAX,DELR,CONSTR,
     *                PTSEL,VDWSCL,PTDENS,VDWINC,NFREQ,LAYER,NPDC,ilayh
      COMMON /POLNMP/ POLNUM
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /STNBUF/ STNPNT(4,2*MXATM),BIGEXP,NPTSTN,NBUFFM
C
      DATA ZERO/0.0D+00/
C
C     --- GENERATES EFP-STATS FOR THE CURRENT FMO FRAGMENT ---
C
      IF( MASWRK ) WRITE(IW,9000) IEFMOCFRG
C      POLAR =.NOT.IAND(IMODEFP,1).NE.0
      POLAR =.TRUE.
      DISPER=IAND(IMODEFD,1).NE.0
      EXREP =.FALSE.
      CHGTRN=.FALSE.
      VDWSCL=ZERO
C
C     THE FORMAT IS OVARNAME FOR OLD VALUES
      OILOCAL = ILOCAL
      OPOLDYN = POLDYN
      OPOLDCM = POLDCM
      OPOLNUM = POLNUM
      ONPTSTN = NPTSTN
C
C     GENERATE ELECTROSTATICS, EITHER BY
C     GOOD'OL'STONE OR HUI LI's DENSITY BASED
      DODENMUL = IAND(IMODEFE,4).NE.0
      if(DODENMUL) THEN
        CALL DENMUL
      ELSE
        CALL STONE(1,'FRAGNAME',0)
      ENDIF
      
C
C     INITIALIZE LMO CALCULATIONS
      IEFMORT=0
      ILOCAL = 1
      IF(IAND(IMODEFP,128).NE.0) ILOCAL = 2
      CALL LMOINP
      CALL LMOX
      ILOCAL = 0
      IEFMORT=1
C
C     ALLOCATE MEMORY FOR PAULIX ROUTINE
      LNA = NA - NOUTA
      LNA2 = (LNA*LNA+LNA)/2
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
C
      CALL VALFM(LOADFM)
      LVEC    = 1       + LOADFM
      LARRAY  = LVEC    + L1*NA
      LFMO    = LARRAY  + L2
      LCCHG   = LFMO    + LNA2
      LWRK2   = LCCHG   + 3*NA
      LDLPOL  = LWRK2   + L1
      LIDMYP  = LDLPOL  + 9*LNA
      LNNOPRT = LIDMYP  + L1
      LPOL    = LNNOPRT + L1
      LCANVEC = LPOL    + 9*LNA*MXIFRQ
      LCANFOK = LCANVEC + L3
      LAST    = LCANFOK + L2
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
C     STORE RESULTS IN COMMON
      CTVVO = .TRUE.
c     Nota bene. CTVVO is hardwired but should be used from EFPX.
      CALL EFP2X(X(LVEC),X(LARRAY),X(LFMO),X(LCCHG),X(LWRK2),
     *            X(LDLPOL),X(LIDMYP),X(LNNOPRT),X(LPOL),X(LCANVEC),
     *            X(LCANFOK),LNA,LNA2,L1,L2,
     *            POLAR,DISPER,EXREP,CHGTRN,CTVVO,1)
      CALL RETFM(NEED)
C
      ILOCAL = OILOCAL
      POLDYN = OPOLDYN
      POLDCM = OPOLDCM
      POLNUM = OPOLNUM
      NPTSTN = ONPTSTN
C
      IEFPFMO = 0
C
C     FIND THE SPECIAL POLARIZATION TENSOR
C     SO WE CAN SCREEN IT IF WE NEED TO
      IF ( NUMFRZ.GT.0 ) THEN
        DO I=1,NA
          ICN=MIN(5,NMOAT(I))
          IF( ICN.EQ.2 ) THEN
            IAT1 = MOIDNO(1,I)
            IAT2 = MOIDNO(2,I)
            IFRG = INDAT(IAGLOB(IAT1))
            JFRG = INDAT(IAGLOB(IAT2))
c            WRITE(6,'(a,5i5)') "css: check",i,iat1,iat2,
c     *      indat(iaglob(iat1)),indat(iaglob(iat2))
            IF(IFRG.NE.JFRG)THEN
              ITENS=I-NOUTA+NUMFRZ
              IF(MASWRK) WRITE(IW,9010) IFRG, JFRG
              IF(MASWRK)
     *        CALL EFMOPOLTSAV(X(LEFMOIPT),IEFMONFRG,IEFMOCFRG,ITENS)
              GOTO 100
            ENDIF
          ENDIF
        ENDDO
C       IF WE MADE IT HERE, THE BOND TENSOR COULD NOT BE FOUND EVEN
C       EVEN THOUGH IT SHOULD BE THERE. WE CANNOT SCREEN IT. ABORT?
        IF(MASWRK) WRITE(IW,9015)
C        CALL ABRT
      ENDIF
  100 CONTINUE
C
C     GENERATE SCREENING STATISTICS
      IF(IAND(imodefe,1).ne.0.and.ascreen(1).eq.-1)THEN
        CALL INPPDC
        CALL CGPX(1)
      endif
C
 9000 FORMAT (/5X,50(1H-)/
     *         5X,'GENERATING EFMO PARAMETERS FOR FMO MONOMER #',I5/
     *         5X,50(1H-))
      RETURN
 9010 FORMAT (/5x,'LOCATED BOND TENSOR BETWEEN FRAGMENTS',I4,
     *            ' AND',I4)
 9015 FORMAT (/5x,'COULD NOT LOCATE BOND TENSOR. ABORTING.')
      END
C
C
C*MODULE EFMO     *DECK EFMOTOT
      SUBROUTINE EFMOTOT(FMODE,FRGNAM)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER(MXFRG=1050,MXDFG=5,
     *          MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (MXEFMOPTS=50,MXEFMOPPTS=60,MXNEFMOPTS=27,
     *           MXNEFMOPPTS=15)
C
      INTEGER DDI_WORLD,DDI_GROUP
      LOGICAL GOPARR,DSKWRK,MASWRK,ISGDDI,PAROUT,INITGDDI,wasgddi
      PARAMETER(DDI_WORLD=0,DDI_GROUP=1)
      INTEGER OILOCAL,OICOORD
      
      DIMENSION FMODE(3,NATFMO,*),FRGNAM(*)
C
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,IEFMORUN,
     *                IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,IEFMODIM(2),
     *                IMODEFE,NATEFMO,IMODEFD
      COMMON /EFMOPO/ LNEFMOPTS,LEFMOPTS,LEFMOPPTS,LEFMODPTS,LEFMODIMG,
     *                LEFMOTOTG,LEFMOIPT,LEFMOIGLOB
      COMMON /FMCOM / X(1)
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,LIACTFG,lcrfrg,
     *                lzlmfrgv
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG)
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,NPGLOB,NNGLOB,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /ZMTALT/ NZMAT2,NZVAR2,NVAR2,NZMTRD,ICOORD
C
      DATA OPTMIZ /8HOPTIMIZE/, SADPT  /8HSADPOINT/
      DATA GRAD  /8HGRADIENT/
C
C     --- CALCULATE TOTAL EFP POLARIZATION ENERGY ---
C
      IF(IAND(IMODEFP,1).NE.0) RETURN
      NFRG  = IEFMONFRG
      CALL VCLR(X(LEFMODIMG),1,3*NATFMO+3*NBDFG)
      L1 = 3*NFRG
      L2 = NFRG*MXEFMOPTS*MXNEFMOPTS
      L3 = NFRG*MXEFMOPPTS*MXNEFMOPPTS
      L4 = NFRG*MXEFMOPPTS*MXNEFMOPPTS*12

C
      IF( ISGDDI )
     *  CALL EFMOEXCH(NFRG,X(LNEFMOPTS),X(LEFMOPTS),X(LEFMOPPTS),
     *                X(LEFMODPTS),X(LEFMOIPT),
     *                L1,L2,L3,L4)
C
      IF( GOPARR ) THEN
        CALL DDI_BCAST(2614,'I',X(LNEFMOPTS),L1,MASTER)
        CALL DDI_BCAST(2615,'F',X(LEFMOPTS),L2,MASTER)
        CALL DDI_BCAST(2616,'F',X(LEFMOPPTS),L3,MASTER)
        CALL DDI_BCAST(2617,'F',X(LEFMODPTS),L4,MASTER)
        CALL DDI_BCAST(2618,'I',X(LEFMOIPT),NFRG,MASTER)
      ENDIF
      IF(MASWRK) WRITE(IW,9000)
C
      OILOCAL = ILOCAL
      OICOORD = ICOORD
C
      CALL EFMOPOPEFP(IEFMONFRG,X(LNEFMOPTS),X(LEFMOPTS),X(LEFMOPPTS),
     *                X(LEFMODPTS),X(LEFMOIPT),FRGNAM)
      IEFP = 1
      IEFDP = 0
      IEFC = 1
      IF( ISGDDI ) CALL GDDI_SCOPE( DDI_WORLD )
      CALL EFSP
      IEFP = 0
      IEFDP = 0
      IEFC = 0
C
C     GET THE GRADIENTS. NOTICE THAT THIS IS SLIGHTLY MODIFIED
C     FROM WHAT IS DONE ELSEWHERE WITH REGULAR FMO-EFP.
C     ALSO, WE USE EFMODIMG COMMON STORAGE TEMPORARILY HERE.
      IF( RUNTYP.EQ.OPTMIZ .OR. RUNTYP.EQ.SADPT
     * .OR. RUNTYP.EQ.GRAD ) THEN
        CALL VALFM(LOADFM)
        LDIP1 = LOADFM + 1
        LDIP2 = LOADFM + 1
        LDFRG = LOADFM + 1
        LWORK = LDFRG + 1
        LGFIX = LWORK + MAX(1,10*NMTTPT)
        LAST = LGFIX + 3*NMTTPT
        NEED = LAST - LOADFM - 1
        CALL GETFM(NEED)
        CALL DCHIND(LDIP1,LDIP2,LDFRG,0)
        CALL DININ(LDIP1,LDIP2,LDFRG,0)
        CALL DDPIND(LDIP1,LDIP2,LDFRG,0)
        CALL DQDIND(X(LWORK),LDIP1,LDIP2,LDFRG,0)
        CALL INDCHG(0)
        CALL INDIND(0)
        CALL INDDPL(0)
        CALL INDQUA(0)
        CALL RETFM(NEED)
      ENDIF
      IF( ISGDDI ) CALL GDDI_SCOPE( DDI_GROUP )
      IF( GOPARR ) CALL DDI_GSUMF(2405,X(LEFMODIMG),3*NATFMO+3*NBDFG)
      IF( MASWRK ) CALL EFMODEG(1,FMODE(1,1,2),X(LIATFRG),X(LEFMODIMG))
      EFMOETOT = EFMOPOLERG
C
C AND RESTORE VALUES
      ILOCAL = OILOCAL
      ICOORD = OICOORD
C
      CALL EFMORESET
      IF(MASWRK) WRITE(IW,9010) EFMOETOT
      IF(MASWRK) WRITE(IW,9021)
      IF(MASWRK)CALL TIMIT(1)
C
 9000 FORMAT (/5X,38(1H-)/
     *         5X,'EFP TOTAL POLARIZATION CALCULATION'/
     *         5X,38(1H-))
 9010 FORMAT (/10X,'TOTAL POLARIZATION ENERGY =',F16.9/)
 9021 FORMAT(/,'..... END OF TOTAL POLARIZATION ENERGY .....')
      RETURN
      END
C
C
C
C*MODULE EFMO     *DECK EFMOFRGS
      SUBROUTINE EFMOFRGS(IFG,JFG,ECHNRG,EPOLNRG,EDISNRG,FRGNAM)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER(MXFRG=1050,MXDFG=5,MXATM=1050,
     *          MXDPPT=MXFRG*MXDFG*12)

C      CHARACTER*8 POLNAM,DPOLNAM,FRGNME
      LOGICAL DSKWRK,MASWRK,GOPARR
      LOGICAL EFMODOEFPC
      INTEGER OILOCAL,OICOORD
      
      DIMENSION FRGNAM(*)
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,IEFMORUN,
     *                IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,IEFMODIM(2),
     *                IMODEFE,NATEFMO,IMODEFD
      COMMON /EFMOPO/ LNEFMOPTS,LEFMOPTS,LEFMOPPTS,LEFMODPTS,LEFMODIMG,
     *                LEFMOTOTG,LEFMOIPT,LEFMOIGLOB
      COMMON /FMCOM / X(1)
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG)
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /ZMTALT/ NZMAT2,NZVAR2,NVAR2,NZMTRD,ICOORD
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      DATA OPTMIZ /8HOPTIMIZE/, SADPT  /8HSADPOINT/
      DATA GRAD  /8HGRADIENT/

C
C     --- CALCULATE EFP DIMER INTERACTION ENERGY ---
C
      IEFMODIM(1) = IFG
      IEFMODIM(2) = JFG
      CALL VICLR(X(LEFMOIGLOB),1,MXATM)
      CALL EFMODIMERGLOB(IFG,JFG,X(LEFMOIGLOB))
C
C     THE FORMAT IS OVARNAME FOR OLD VALUES
      OILOCAL = ILOCAL
      OICOORD = ICOORD
C
C     SETUP DEFAULT VALUES FOR EFP RUN. (TAKEN FROM SUBROUTINE START)
      NFRG  = 2
      CALL VCLR(X(LEFMODIMG),1,3*NATFMO+3*NBDFG)
      CALL EFMOPOPEFP(IEFMONFRG,X(LNEFMOPTS),X(LEFMOPTS),X(LEFMOPPTS),
     *                X(LEFMODPTS),X(LEFMOIPT),FRGNAM)
      IEFP = 0
      IEFC = 0
      IEFDP = 0
      IF(.NOT.EFMODOEFPC(IFG,JFG)) IEFP = 1
      IF(.NOT.EFMODOEFPC(IFG,JFG)) IEFC = 1
      IF(EFMODOEFPC(IFG,JFG)) IEFDP = 1
      IF(IEFP.EQ.1 .AND. IAND(IMODEFP,1).NE.0) IEFP = 0
      CALL EFSP
      IEFP = 0
      IEFC = 0
      IEFDP = 0
C
C     GET THE GRADIENTS OF THE INDUCED DIPOLES FOR FRAGMENTS
C     I AND J, BUT ONLY IF WE ARE DOING QM     
      IF( RUNTYP.EQ.OPTMIZ .OR. RUNTYP.EQ.SADPT
     * .OR. RUNTYP.EQ.GRAD ) THEN
        IF(.NOT.EFMODOEFPC(IFG,JFG)) THEN
C
          IF(IAND(IMODEFP,1).NE.0) GOTO 20
C
          CALL VALFM(LOADFM)
          LDIP1 = LOADFM + 1
          LDIP2 = LOADFM + 1
          LDFRG = LOADFM + 1
          LWORK = LDFRG + 1
          LAST = LWORK + MAX(1,10*NMTTPT)
          NEED = LAST - LOADFM - 1
          CALL GETFM(NEED)
          CALL DCHIND(LDIP1,LDIP2,LDFRG,0)
          CALL DININ(LDIP1,LDIP2,LDFRG,0)
          CALL DDPIND(LDIP1,LDIP2,LDFRG,0)
          CALL DQDIND(X(LWORK),LDIP1,LDIP2,LDFRG,0)
          CALL INDCHG(0)
          CALL INDIND(0)
          CALL INDDPL(0)
          CALL INDQUA(0)
          CALL RETFM(NEED)
   20     CONTINUE
        ENDIF
      ENDIF
      IF( GOPARR ) CALL DDI_GSUMF(2406,X(LEFMODIMG),3*NATFMO+3*NBDFG)
C
      ECHNRG  = EFMOESERG
      EPOLNRG = EFMOPOLERG
      EDISNRG = EFMODISERG

C     RESTORE VALUES
      ILOCAL = OILOCAL
      ICOORD = OICOORD
C
      CALL EFMORESET
C
      RETURN
      END
C
C
C*MODULE EFMO     *DECK EFMODOEFPC
      LOGICAL FUNCTION EFMODOEFPC(IFRG,JFRG)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER IFRG,JFRG
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                MODLMO,NOPDEN,MOFOCK,MODFD,modfmm
C
C     --- RETURNS TRUE/FALSE WHETHER TO DO EFP CALCULATION ---
C
      R = FMODIST(IFRG,0,0,JFRG)
      EFMODOEFPC = R.GT.RESDIM
      RETURN
      END
C
      SUBROUTINE EFMOESGM(IFRG,JFRG,IC1,IC2,DX,DY,DZ,
     * TIX,TIY,TIZ,TJX,TJY,TJZ,F1,F2,IMODE)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      COMMON /EFMOPO/ LNEFMOPTS,LEFMOPTS,LEFMOPPTS,LEFMODPTS,LEFMODIMG,
     *                LEFMOTOTG,LEFMOIPT,LEFMOIGLOB
      COMMON /FMCOM / X(1)
C
C     --- SIMPLE WRAPPER FOR EFMOESG ---
C
      CALL EFMOESG(IFRG,JFRG,IC1,IC2,DX,DY,DZ,TIX,TIY,TIZ,
     *             TJX,TJY,TJZ,F1,F2,X(LEFMODIMG),IMODE)

      RETURN
      END
C
C*MODULE EFMO     *DECK EFMOESG
      SUBROUTINE EFMOESG(IFRG,JFRG,IC1,IC2,DX,DY,DZ,
     * TIX,TIY,TIZ,TJX,TJY,TJZ,F1,F2,EFMODIMG,IMODE)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER IFRG,JFRG,IC1,IC2, IP,JP,ATMI,ATMJ,ATMA,ATMC,
     *        ATMIP,ATMJP
      LOGICAL DOTORQ
      DIMENSION ATMS(3,3),DA(3),DI(3),DJ(3),DC(3),EFMODIMG(3,*)
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,IEFMORUN,
     *                IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,IEFMODIM(2),
     *                IMODEFE,NATEFMO,IMODEFD
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      DATA OPTMIZ /8HOPTIMIZE/, SADPT  /8HSADPOINT/
      DATA GRAD  /8HGRADIENT/
C
C     --- CALCULATE GRADIENT CONTRIBUTION FROM MULTIPOLES
C         AND POLARIZABLE POINTS
C
C     IMODE = 1 ELECTROSTATIC
C     IMODE = 2 INDUCED DIPOLE
C

      IF( RUNTYP.EQ.OPTMIZ .OR. RUNTYP.EQ.SADPT
     * .OR. RUNTYP.EQ.GRAD ) THEN
C
        DOTORQ = .NOT. ( (IAND(IMODEFE,8).NE.0 .AND. IMODE.EQ.1) .OR.
     *                   (IAND(IMODEFP,8).NE.0 .AND. IMODE.EQ.2) )
C
C       GET INTERACTING MULTIPOLES
        IP = IC1
        JP = IC2
C  
        ATMI = IP
        ATMIP = IP
        ATMJ = JP
        ATMJP = JP
C  
C       DO TORQUE CONTRIBUTION ON NEIGHBOURS FROM TORQUE ON I
C  
        CALL VCLR(DI,1,3)
        CALL VCLR(DA,1,3)
        CALL VCLR(DC,1,3)
        IF( DOTORQ ) THEN
          CALL EFMOGCMPMP(IFRG,ATMI,ATMS)
          ATMA = INT(ATMS(1,1))
          ATMC = INT(ATMS(2,1))
          CALL EFMOTRQTOG(ATMA,ATMI,ATMC,TIX,TIY,TIZ,DA,DI,DC)
          EFMODIMG(1,ATMA) = EFMODIMG(1,ATMA) + DA(1)
          EFMODIMG(2,ATMA) = EFMODIMG(2,ATMA) + DA(2)
          EFMODIMG(3,ATMA) = EFMODIMG(3,ATMA) + DA(3)
          EFMODIMG(1,ATMC) = EFMODIMG(1,ATMC) + DC(1)
          EFMODIMG(2,ATMC) = EFMODIMG(2,ATMC) + DC(2)
          EFMODIMG(3,ATMC) = EFMODIMG(3,ATMC) + DC(3)
        ENDIF
C
C  
C       DO TORQUE CONTRIBUTION ON NEIGHBOURS FROM TORQUE ON J
C  
        CALL VCLR(DJ,1,3)
        CALL VCLR(DA,1,3)
        CALL VCLR(DC,1,3)
        IF( DOTORQ ) THEN
          CALL EFMOGCMPMP(JFRG,ATMJ,ATMS)
          ATMA = INT(ATMS(1,1))
          ATMC = INT(ATMS(2,1))
          CALL EFMOTRQTOG(ATMA,ATMJ,ATMC,TJX,TJY,TJZ,DA,DJ,DC)
          EFMODIMG(1,ATMA) = EFMODIMG(1,ATMA) + DA(1)
          EFMODIMG(2,ATMA) = EFMODIMG(2,ATMA) + DA(2)
          EFMODIMG(3,ATMA) = EFMODIMG(3,ATMA) + DA(3)
          EFMODIMG(1,ATMC) = EFMODIMG(1,ATMC) + DC(1)
          EFMODIMG(2,ATMC) = EFMODIMG(2,ATMC) + DC(2)
          EFMODIMG(3,ATMC) = EFMODIMG(3,ATMC) + DC(3)
        ENDIF
C  
C       DO RESULTING ROTATION ON I AND J AS WELL AS REGULAR GRADIENTS
C
        EFMODIMG(1,ATMIP) = EFMODIMG(1,ATMIP) - F1*DX + DI(1)
        EFMODIMG(1,ATMJP) = EFMODIMG(1,ATMJP) + F2*DX + DJ(1)
        EFMODIMG(2,ATMIP) = EFMODIMG(2,ATMIP) - F1*DY + DI(2)
        EFMODIMG(2,ATMJP) = EFMODIMG(2,ATMJP) + F2*DY + DJ(2)
        EFMODIMG(3,ATMIP) = EFMODIMG(3,ATMIP) - F1*DZ + DI(3)
        EFMODIMG(3,ATMJP) = EFMODIMG(3,ATMJP) + F2*DZ + DJ(3)
      ENDIF
      RETURN
      END
C
C
C
*MODULE EFMO     *DECK EFMOGCMPMP
      SUBROUTINE EFMOGCMPMP(IFRG,IP,ATMS)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER(MXFGPT=12000,MXFRG=1050,MXDFG=5,
     *          MXDPPT=MXFRG*MXDFG*12)
C
      CHARACTER*8 FRGNME
      
C
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,IEFMORUN,
     *                IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,IEFMODIM(2),
     *                IMODEFE,NATEFMO,IMODEFD
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG)
C
      INTEGER I,IFRG,IP,OFFSET
      DIMENSION ATMS(3,3)
C
C     --- GET NEAREST MULTIPOLES FROM MULTIPOLE IP IN IFRG ---
C
      IF( IEFMORUN.EQ.0 ) RETURN 
C
      ATMS(1,1)=-1
      ATMS(1,2)=-1
      ATMS(1,3)=1.0D+30
      ATMS(2,1)=-1
      ATMS(2,2)=-1
      ATMS(2,3)=1.0D+30
      ATMS(3,1)=-1
      ATMS(3,2)=-1
      ATMS(3,3)=1.0D+30
C
      OFFSET = 0
      IF( IEFMORT.EQ.4 ) THEN
C       WE KNOW THAT IFRG IS THE TRUE FRAGMENT
C       SO WE CAN COUNT USING THE NUMBER OF
C       MULTIPOLES
        DO I=1,NFRG
          IF(I.EQ.IFRG) GOTO 10
          OFFSET = OFFSET + NMPTS(I)
        ENDDO
      ELSEIF( IEFMORT.EQ.3 ) THEN
C
        DO I=1,NFRG
          IF(I.EQ.IFRG) GOTO 10
          OFFSET = OFFSET + NMPTS(I)
        ENDDO
      ENDIF
   10 CONTINUE
C
C     GET COORDINATES OF IP'TH MULTIPOLE
      BX = EFC(1,IP)
      BY = EFC(2,IP)
      BZ = EFC(3,IP)

C     LOOP OVER EACH MULTIPOLE IN THE CURRENT FRAGMENT
      DO 20 I=1,NMPTS(IFRG)
C
C       IF IT IS AN ATOM, THEN CHECK THE DISTANCE
        IF(EFCHG(2,I).GT.0.0D+00) THEN
          AX = EFC(1,OFFSET+I)
          AY = EFC(2,OFFSET+I)
          AZ = EFC(3,OFFSET+I)
          R  = (AX-BX)**2 + (AY-BY)**2 + (AZ-BZ)**2
C         JUST SOME SMALL "IMPOSSIBLE" VALUE
          IF( R.LT.1.0D-02 ) GOTO 20
C         IF THE ATOM DISTANCE IS THE SHORTEST ONE, INSERT IT
          IF(R.LT.ATMS(1,3)) THEN
C         COPY DOWN STUFF FIRST
            ATMS(3,1) = ATMS(2,1)
            ATMS(3,2) = ATMS(2,2)
            ATMS(3,3) = ATMS(2,3)
            ATMS(2,1) = ATMS(1,1)
            ATMS(2,2) = ATMS(1,2)
            ATMS(2,3) = ATMS(1,3)
C           THEN INSERT LOWER VALUES
            ATMS(1,1) = OFFSET +I
            ATMS(1,2) = -1
            ATMS(1,3) = R
C           AVOID TO INSERT THE LOWEST VALUE
C           FIRST AT BOTH PLACES
            GOTO 20
          ENDIF

C         IF THE ATOM DISTANCE IS THE SECOND SHORTEST, INSERT IT
          IF(R.LT.ATMS(2,3)) THEN
C           COPY DOWN STUFF FIRST
            ATMS(3,1) = ATMS(2,1)
            ATMS(3,2) = ATMS(2,2)
            ATMS(3,3) = ATMS(2,3)
            ATMS(2,1) = OFFSET +I
            ATMS(2,2) = -1
            ATMS(2,3) = R
C           AVOID TO INSERT THE LOWEST VALUE
C           FIRST AT BOTH PLACES
            GOTO 20
          ENDIF

          IF(R.LT.ATMS(3,3)) THEN
            ATMS(3,1) = OFFSET +I
            ATMS(3,2) = -1
            ATMS(3,3) = R
          ENDIF
        ENDIF
   20 CONTINUE
      RETURN
      END
C
C
C
C
C*MODULE EFMO     *DECK EFMOGCMPPOL
      SUBROUTINE EFMOGCMPPOL(IFRG,IP,ATMS)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER(MXIFRQ=12,
     *          MXFGPT=12000,MXFRG=1050,MXDFG=5,
     *          MXDPPT=MXFRG*MXDFG*12)
C
      CHARACTER*8 POLNAM,DPOLNAM,FRGNME
C
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,IEFMORUN,
     *                IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,IEFMODIM(2),
     *                IMODEFE,NATEFMO,IMODEFD
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG)
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ*MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
C
      INTEGER I,IFRG,IP,OFFSET
      DIMENSION ATMS(3,3)
C
C     --- GET NEAREST MULTIPOLES FROM MULTIPOLE IP IN IFRG ---
C
      IF( IEFMORUN.EQ.0 ) RETURN 
C
C INITIALIZATION
C
      ATMS(1,1)=-1
      ATMS(1,2)=-1
      ATMS(1,3)=1.0D+30
      ATMS(2,1)=-1
      ATMS(2,2)=-1
      ATMS(2,3)=1.0D+30
      ATMS(3,1)=-1
      ATMS(3,2)=-1
      ATMS(3,3)=1.0D+30
C
C
      OFFSET = 0
      IF( IEFMORT.EQ.4 ) THEN
C       WE KNOW THAT IFRG IS THE TRUE FRAGMENT
C       SO WE CAN COUNT USING THE NUMBER OF
C       MULTIPOLES SINCE THEY ARE ONLY ON ATOMS
        DO I=1,NFRG
          IF(I.EQ.IFRG) GOTO 10
          OFFSET = OFFSET + NMPTS(I)
        ENDDO
      ELSEIF( IEFMORT.EQ.3 ) THEN
C
        DO I=1,NFRG
          IF(I.EQ.IFRG) GOTO 10
          OFFSET = OFFSET + NMPTS(I)
        ENDDO
      ENDIF
   10 CONTINUE
C
C     GET COORDINATES OF IP'TH POLARIZABLE POINT
      BX = EFP(1,IP)
      BY = EFP(2,IP)
      BZ = EFP(3,IP)

C     LOOP OVER EACH MULTIPOLE IN THE CURRENT FRAGMENT
      DO 20 I=1,NMPTS(IFRG)
C
C       IF IT IS AN ATOM, THEN CHECK THE DISTANCE
        IF(EFCHG(2,I).GT.0.0D+00) THEN
          AX = EFC(1,OFFSET+I)
          AY = EFC(2,OFFSET+I)
          AZ = EFC(3,OFFSET+I)
          R  = (AX-BX)**2 + (AY-BY)**2 + (AZ-BZ)**2
C
C         IF THE ATOM DISTANCE IS THE SHORTEST ONE, INSERT IT
          IF(R.LT.ATMS(1,3)) THEN
C           COPY DOWN STUFF FIRST
            ATMS(3,1) = ATMS(2,1)
            ATMS(3,2) = ATMS(2,2)
            ATMS(3,3) = ATMS(2,3)
            ATMS(2,1) = ATMS(1,1)
            ATMS(2,2) = ATMS(1,2)
            ATMS(2,3) = ATMS(1,3)
C           THEN INSERT LOWER VALUES
            ATMS(1,1) = OFFSET +I
            ATMS(1,2) = -1
            ATMS(1,3) = R
C           AVOID TO INSERT THE LOWEST VALUE
C           FIRST AT BOTH PLACES
            GOTO 20
          ENDIF

C         IF THE ATOM DISTANCE IS THE SECOND SHORTEST, INSERT IT
          IF(R.LT.ATMS(2,3)) THEN
C           COPY DOWN STUFF FIRST
            ATMS(3,1) = ATMS(2,1)
            ATMS(3,2) = ATMS(2,2)
            ATMS(3,3) = ATMS(2,3)
            ATMS(2,1) = OFFSET +I
            ATMS(2,2) = -1
            ATMS(2,3) = R
C           AVOID TO INSERT THE LOWEST VALUE
C           FIRST AT BOTH PLACES
            GOTO 20
          ENDIF

          IF(R.LT.ATMS(3,3)) THEN
            ATMS(3,1) = OFFSET +I
            ATMS(3,2) = -1
            ATMS(3,3) = R
          ENDIF
        ENDIF
   20 CONTINUE
      RETURN
      END
C
C
C
C*MODULE EFMO     *DECK EFMOTRQTOG
      SUBROUTINE EFMOTRQTOG(IA,IB,IC,TBX,TBY,TBZ,DA,DB,DC)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER(MXFGPT=12000)
C
      INTEGER IA,IB,IC,I
      CHARACTER*8 FRGNME
      DIMENSION U(3),V(3),W(3),DA(3),DB(3),DC(3),UV(3),UW(3)
C
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
C
C     --- GET GRADIENT(ROTATION) DUE TO TORQUES. ---
C
C         THIS SUBROUTINE ASSUMES THAT A,B AND C ARE ATOMS!
C
C     CREATE LOCAL COORDINATE SYSTEM
      U(1) = EFC(1,IA) - EFC(1,IB)
      U(2) = EFC(2,IA) - EFC(2,IB)
      U(3) = EFC(3,IA) - EFC(3,IB)
      UNRM = SQRT(U(1)*U(1) + U(2)*U(2) + U(3)*U(3))
      V(1) = EFC(1,IC) - EFC(1,IB)
      V(2) = EFC(2,IC) - EFC(2,IB)
      V(3) = EFC(3,IC) - EFC(3,IB)
      VNRM = SQRT(V(1)*V(1) + V(2)*V(2) + V(3)*V(3))
      W(1) = U(2)*V(3) - U(3)*V(2)
      W(2) = U(3)*V(1) - U(1)*V(3)
      W(3) = U(1)*V(2) - U(2)*V(1)
      WNRM = SQRT(W(1)*W(1) + W(2)*W(2) + W(3)*W(3))
C
      DO I = 1,3
        U(I) = U(I) / UNRM
        V(I) = V(I) / VNRM
        W(I) = W(I) / WNRM
      ENDDO
C
C     GET PERPENDICULARS TO U AND V I.E. THE DIRECTION
C     OF ROTATION
C
      UV(1) = U(2)*V(3) - U(3)*V(2)
      UV(2) = U(3)*V(1) - U(1)*V(3)
      UV(3) = U(1)*V(2) - U(2)*V(1)
      UW(1) = U(2)*W(3) - U(3)*W(2)
      UW(2) = U(3)*W(1) - U(1)*W(3)
      UW(3) = U(1)*W(2) - U(2)*W(1)
C
C     NEGATIVE OF DOT PRODUCT OF TORQUE AND UNIT VECTORS GIVE
C     INFINETISMAL ROTATION.
C
      DPHIDU = -TBX*U(1) - TBY*U(2) - TBZ*U(3)
      DPHIDV = -TBX*V(1) - TBY*V(2) - TBZ*V(3)
      DPHIDW = -TBX*W(1) - TBY*W(2) - TBZ*W(3)
C
C      PROJECTED DISTANCES BETWEEN U AND V
C
C      C = U(1)*V(1) + U(2)*V(2) + U(3)*V(3)
C      S = SQRT(1.0D+00 - C*C)
C      UVDIS = UNRM*S
C      VUDIS = VNRM*S
C
C     DISTRIBUTE FORCE TO GRADIENT
      DO I = 1,3
        DA(I) = 0.0D+00
        DB(I) = 0.0D+00
        DC(I) = 0.0D+00
      ENDDO
      DO I = 1,3
C       NOTICE THAT U AND V ARE UNIT VECTORS SO WE
C       MUST DIVIDE BY THE LENGTH OF THE ORIGINAL ONES
C       TO GET THE REAL SIZE OF THE ROTATION
        DU =  (UV(I)*DPHIDV + UW(I)*DPHIDW) / UNRM
        DV = -(UW(I)*DPHIDU + UW(I)*DPHIDW) / VNRM
        DA(I) = DA(I) + DU
        DC(I) = DC(I) + DV
        DB(I) = DB(I) - DV - DU
      ENDDO
      RETURN
      END
C
C
C
C*MODULE EFMO     *DECK EFMOM
      SUBROUTINE EFMOOUT(IREQMEM)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
C      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,IEFMORUN,
     *                IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,IEFMODIM(2),
     *                IMODEFE,NATEFMO,IMODEFD
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm
C
C     --- EFMO BANNER ---
C
      IF( MASWRK ) THEN
        WRITE(IW,9000)
        WRITE(IW,9005) IREQMEM
        WRITE(IW,9010)
        IF(IAND(IMODEFE,1).NE.0) THEN
          IF(ASCREEN(1).NE.-1) WRITE(IW,9016) ASCREEN(3)
          IF(ASCREEN(1).EQ.-1) WRITE(IW,9017)
          WRITE(IW,9036) 1.5D+00,ascreen(2)
        ELSE
          WRITE(IW,9015)
          WRITE(IW,9035) ascreen(1),ascreen(2)
        ENDIF
        IF(IAND(IMODEFE,2).NE.0) WRITE(IW,9032)
        IF(IAND(IMODEFE,4).NE.0) WRITE(IW,9042)
        IF(IAND(IMODEFE,8).NE.0) WRITE(IW,9039)
        IF(IAND(IMODEFE,16).EQ.0) WRITE(IW,9043)
        IF(IAND(IMODEFE,16).NE.0) WRITE(IW,9044)
        WRITE(IW,9030)
        IF(IAND(IMODEFP,1).NE.0) WRITE(IW,9038)
        IF(IAND(IMODEFP,2).NE.0) WRITE(IW,9046)
        IF(IAND(IMODEFP,4).NE.0) WRITE(IW,9047)
        IF(IAND(IMODEFP,8).NE.0) WRITE(IW,9039)
        IF(IAND(IMODEFP,16).NE.0) WRITE(IW,9040)
        IF(IAND(IMODEFP,32).NE.0) WRITE(IW,9045)
        IF(IAND(IMODEFP,64).NE.0) WRITE(IW,9041)
        WRITE(IW,9050)
        IF(IAND(IMODEFD,1).NE.0) THEN
          WRITE(IW,9051)
        ELSE
          WRITE(IW,9052)
        ENDIF
        WRITE(IW,9100)
      ENDIF
C
 9000 FORMAT (/1X,70(1H-)/
     * 1X,'THIS IS AN EFFECTIVE FRAGMENT MOLECULAR ORBITAL (EFMO)',
     * ' RUN.',/3X,'USING EFP MODELS',
     *            ' FOR MANY-BODY INTERACTIONS.',//,3X,
     *            'ALL PUBLICATIONS USING EFMO SHOULD REFERENCE:'/,
     *            5X,'C. STEINMANN, D.G. FEDOROV, J.H. JENSEN, ',
     *            'J. CHEM. PHYS. A 114, 8705 (2010)')
 9005 FORMAT (/5X,'EFMO STORAGE REQUIRES',I10,' WORDS.')
C 9010 FORMAT (/5X,'ELECTROSTATIC SCREENING OPTIONS:')
 9010 FORMAT (/5X,'EFP Electrostatic Options')
 9015 FORMAT (5X,'  No screening of electrostaic moments')
 9016 FORMAT (5X,'  Exponential screening = ',F9.4)
 9017 FORMAT (5X,'  Exponential screening = FITTED')
 9032 FORMAT (5X,'  Add octupole interaction')
 9042 FORMAT (5X,'  Using density based multipole expansion by Hui Li')
 9043 FORMAT (5X,'  Multipole expansion on atoms only')
 9044 FORMAT (5X,'  Multipole expansion on atoms and bond midpoints')
 9030 FORMAT (/5X,'EFP Polarization Options')
C 9031 FORMAT (/5X,'OTHER OPTIONS:')
 9035 FORMAT (5X,'  Tang-Toennis style screening',2F9.4)
 9036 FORMAT (5X,'  Exponential screening',2F9.4)
 9038 FORMAT (5X,'  Disable many-body (polarization) contributions')
 9039 FORMAT (5X,'  Ignore torque contribution on gradient')
 9040 FORMAT (5X,'  Use CPHF alpha-polarizability tensors')
 9041 FORMAT (5X,'  Ignore field from neighbour fragments')
 9045 FORMAT (5X,'  Move polarizable points to nearest atoms')
 9046 FORMAT (5X,'  Distribute gradient equally between close atoms.')
 9047 FORMAT (5X,'  Distribute gradient by percentage ',
     *              'between close atoms')
 9050 FORMAT (/5X,'EFP Dispersion Options')
 9051 FORMAT (5X,'  Dispersion interaction for separated pairs')
 9052 FORMAT (5X,'  No dispersion')
 9100 FORMAT(/1X,70(1H-))
 
      RETURN
      END
C
C
C
C*MODULE EFMO     *DECK EFMOSTOR
      SUBROUTINE EFMOSTOR(I,K,IDX,EFMOPTS,N,VALUE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXEFMOPTS=50,MXNEFMOPTS=27)
      DIMENSION EFMOPTS(N,MXEFMOPTS,MXNEFMOPTS)
      LOGICAL GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     --- STORE EFP-MULTIPOLE INFORMATION IN DYNAMIC STORAGE ---
C
      IERR = 0
      IF( I.GT.N ) IERR = IERR + 1
      IF( K.GT.MXEFMOPTS ) IERR = IERR + 1
      IF( IDX.GT.MXNEFMOPTS ) IERR = IERR + 1
      IF( IERR.GT.0 ) THEN
        IF( MASWRK ) WRITE(IW,9000)
        CALL ABRT
      ENDIF
C
C     NO ERRORS, STORE THE VALUE
      EFMOPTS(I,K,IDX) = VALUE
C
 9000 FORMAT (/5X,"EFMO STORAGE FAILED.",/)
      RETURN
      END
C
C
C
C*MODULE EFMO     *DECK EFMOSTORP
      SUBROUTINE EFMOSTORP(I,K,IDX,EFMOPPTS,N,VALUE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXEFMOPPTS=60,MXNEFMOPPTS=15)
      DIMENSION EFMOPPTS(N,MXEFMOPPTS,MXNEFMOPPTS)
      LOGICAL GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     --- STORE EFP-POLARIZABLE POINT INFORMATION IN DYNAMIC STORAGE ---
C
      IERR = 0
      IF( I.GT.N ) IERR = IERR + 1
      IF( K.GT.MXEFMOPPTS ) IERR = IERR + 1
      IF( IDX.GT.MXNEFMOPPTS ) IERR = IERR + 1
      IF( IERR.GT.0 ) THEN
        IF( MASWRK ) WRITE(IW,9000)
        CALL ABRT
      ENDIF
C
C     NO ERRORS, STORE THE VALUE
      EFMOPPTS(I,K,IDX) = VALUE
C
 9000 FORMAT (/5X,"EFMO STORAGE FAILED.",/)
      RETURN
      END
C
C*MODULE EFMO     *DECK EFMOSTORDP
      SUBROUTINE EFMOSTORDP(I,K,J,IDX,EFMODPTS,N,VALUE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXEFMOPPTS=60,MXNEFMOPPTS=15)
      DIMENSION EFMODPTS(N,MXEFMOPPTS,12,MXNEFMOPPTS)
      LOGICAL GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     --- STORE EFP-DYNAMIC-POLARIZABLE POINT INFORMATION IN DYNAMIC STORAGE ---
C
      IERR = 0
      IF( I.GT.N ) IERR = IERR + 1
      IF ( J.GT.12 ) IERR = IERR +1
      IF( K.GT.MXEFMOPPTS ) IERR = IERR + 1
      IF( IDX.GT.MXNEFMOPPTS ) IERR = IERR + 1
      IF( IERR.GT.0 ) THEN
        IF( MASWRK ) WRITE(IW,9000)
        CALL ABRT
      ENDIF
C
C     NO ERRORS, STORE THE VALUE
      EFMODPTS(I,K,J,IDX) = VALUE
C
 9000 FORMAT (/5X,"EFMO STORAGE FAILED.",/)
      RETURN
      END
C
C
C
C*MODULE EFMO     *DECK EFMOPNTSAV
      SUBROUTINE EFMOPTNSAV(NEFMOPTS,NFG,N,MODE,IVALUE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NEFMOPTS(3,NFG)
C
C     --- STORE NUMBER OF MULTIPOLE/POLARIZABLE POINTS ---
C
C        MODE = 1  :        STATIC MULTIPOLE POINT
C        MODE = 2  :        POLARIZABLE POINT
C        MODE = 3  :        DYNAMIC POLARIZABILITY POINTS
C
      NEFMOPTS(MODE,N) = IVALUE
C
      RETURN
      END
C
C
C
C*MODULE EFMO     *DECK EFMOPOLTSAV
      SUBROUTINE EFMOPOLTSAV(NEFMOIPT,NFG,N,I)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NEFMOIPT(NFG)
C
C     --- STORE INDEX OF SPECIAL POLARIZATION TENSOR IN BOND ---
C
      NEFMOIPT(N) = I
      RETURN
      END
C
C
C*MODULE EFMO     *DECK EFMOPOPEFP
      SUBROUTINE EFMOPOPEFP(NFG,NEFMOPTS,EFMOPTS,EFMOPPTS,EFMODPTS,
     *           NEFMOIPT,FMOFRGNAM)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      
      CHARACTER*8 POLNAM,DPOLNAM,FRGNME,FMOFRGNAM
      CHARACTER*6 FRGNAM
      CHARACTER*8 PTNAM
      LOGICAL DOMONO,DODIPO,DOQUAD,DOOCTU,DOEXPDAM
C
      PARAMETER(MXFGPT=12000,MXFRG=1050,MXDFG=5,
     *          MXDPPT=MXFRG*MXDFG*12,MXIFRQ=12,MXPT=2000)
      PARAMETER (MXEFMOPTS=50,MXEFMOPPTS=60,MXNEFMOPTS=27,
     *           MXNEFMOPPTS=15)
C
      DIMENSION EFMOPTS(NFG,MXEFMOPTS,MXNEFMOPTS),
     *          EFMOPPTS(NFG,MXEFMOPPTS,MXNEFMOPPTS),
     *          NEFMOPTS(3,NFG),NEFMOIPT(NFG),FMOFRGNAM(*),
     *          EFMODPTS(NFG,MXEFMOPPTS,12,MXNEFMOPPTS)
C
      COMMON /DOMULT/ DOMONO(MXFGPT),DODIPO(MXFGPT),DOQUAD(MXFGPT),
     *                DOOCTU(MXFGPT)
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,IEFMORUN,
     *                IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,IEFMODIM(2),
     *                IMODEFE,NATEFMO,IMODEFD
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ*MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /EFPSCR/ POLAB(MXFRG),B,SCROFF,IELECS,IDISPS,NEW_POL
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /ZMTALT/ NZMAT2,NZVAR2,NVAR2,NZMTRD,ICOORD
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG)
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      DATA ZERO/0.0D+00/
C
C     --- POPULATE EFP COMMON BLOCKS WITH EFMO DATA ---
C
C         WARNING, NFG IS USED ONLY FOR DIMENSIONING
C
      DOEXPDAM = IAND(IMODEFE,1).NE.0
C
C     SETUP DEFAULT VALUES FOR EFP RUN. (TAKEN FROM ROUTINE START/EFPX)
      ILOCAL = 2
      ICOORD = 4
      SCROFF= 1.0D+04
      IDISPS = 0
      IELECS = 0
      INDSCR = 0
      NEW_POL = 1
      IPLSCR = 0
      ICHGP = 0
      IF(DOEXPDAM) THEN
        new_pol = -1
        iplscr = 1
        ichgp = 7
      endif
C
C     IN EFMO, THE NUMBER OF ATOMS IS
C     ALWAYS THE NUMBER OF MULTIPOLE POINTS
C     WHICH IS NOT A BOND MIDPOINT
      NATEFMO = 0
      LSTMPTS(1) = 1
      IMULPOL = 0
      IPOLPOL = 0
      IDYNPOL = 0
      NDFRG = NFRG
      NMTTPT = 0
      NPTTPT = 0
      NDPTTPT = 0
      NDPST = 0
      DO IDX=1,NFRG
        I=IDX
        IF( NFRG.EQ.2 .AND. IEFMORT.EQ.3 ) I = IEFMODIM(IDX)
        NMPTS(IDX) = NEFMOPTS(1,I)
        NPPTS(IDX) = NEFMOPTS(2,I)
        NDPPTS(IDX) = 12*NEFMOPTS(3,I)
        NMTTPT = NMTTPT + NMPTS(IDX)
        NPTTPT = NPTTPT + NPPTS(IDX)
        NDPTTPT = NDPTTPT + NDPPTS(IDX)
        LSTMPTS(IDX+1) = LSTMPTS(IDX) + NMPTS(IDX)
        POLAB(IDX) = ascreen(1)
        FRGNAM(IDX) = FMOFRGNAM(I)(1:6)
        DO J=1,NMPTS(IDX)
          IMULPOL = IMULPOL +1
          FRGNME(IMULPOL) = FMOFRGNAM(I)
          EFC(1,IMULPOL)   = EFMOPTS(I,J,1)
          EFC(2,IMULPOL)   = EFMOPTS(I,J,2)
          EFC(3,IMULPOL)   = EFMOPTS(I,J,3)
          FMASS(IMULPOL) =   EFMOPTS(I,J,4)
          EFCHG(1,IMULPOL) = EFMOPTS(I,J,6)
          EFCHG(2,IMULPOL) = EFMOPTS(I,J,5)
          IF(EFCHG(2,IMULPOL).NE.ZERO) NATEFMO=NATEFMO+1
          EFDIP(1,IMULPOL) = EFMOPTS(I,J,7)
          EFDIP(2,IMULPOL) = EFMOPTS(I,J,8)
          EFDIP(3,IMULPOL) = EFMOPTS(I,J,9)
          EFQAD(1,IMULPOL) = EFMOPTS(I,J,10)
          EFQAD(2,IMULPOL) = EFMOPTS(I,J,11)
          EFQAD(3,IMULPOL) = EFMOPTS(I,J,12)
          EFQAD(4,IMULPOL) = EFMOPTS(I,J,13)
          EFQAD(5,IMULPOL) = EFMOPTS(I,J,14)
          EFQAD(6,IMULPOL) = EFMOPTS(I,J,15)
          EFOCT(1,IMULPOL) = EFMOPTS(I,J,16)
          EFOCT(2,IMULPOL) = EFMOPTS(I,J,17)
          EFOCT(3,IMULPOL) = EFMOPTS(I,J,18)
          EFOCT(4,IMULPOL) = EFMOPTS(I,J,19)
          EFOCT(5,IMULPOL) = EFMOPTS(I,J,20)
          EFOCT(6,IMULPOL) = EFMOPTS(I,J,21)
          EFOCT(7,IMULPOL) = EFMOPTS(I,J,22)
          EFOCT(8,IMULPOL) = EFMOPTS(I,J,23)
          EFOCT(9,IMULPOL) = EFMOPTS(I,J,24)
          EFOCT(10,IMULPOL) = EFMOPTS(I,J,25)
          IF(DOEXPDAM) THEN
            IF(ASCREEN(1).NE.-1) THEN
              EFBTRM2(IMULPOL) = 1.0D+00
              EFATRM2(IMULPOL) = ascreen(3)
            ELSE
              EFBTRM2(IMULPOL) = EFMOPTS(I,J,16)
              EFATRM2(IMULPOL) = EFMOPTS(I,J,17)
            ENDIF
          ENDIF
          DOMONO(IMULPOL)  = .TRUE.
          DODIPO(IMULPOL)  = .TRUE.
          DOQUAD(IMULPOL)  = .TRUE.
          DOOCTU(IMULPOL)  = .FALSE.
          IF( IAND(IMODEFE,2).NE.0 ) DOOCTU(IMULPOL)  = .TRUE.
        ENDDO
        DO J=1,NPPTS(IDX)
          IPOLPOL = IPOLPOL + 1
          IOFFSET = 3
          POLNAM(IPOLPOL) = FMOFRGNAM(I)
          IF(IAND(IMODEFP,32).EQ.0) THEN
            EFP(1,IPOLPOL)   = EFMOPPTS(I,J,1)
            EFP(2,IPOLPOL)   = EFMOPPTS(I,J,2)
            EFP(3,IPOLPOL)   = EFMOPPTS(I,J,3)
          ELSE
            JJ=-1
            CALL EFMOGCA(NFG,EFMOPPTS,EFMOPTS,I,NMPTS(IDX),J,JJ)
            IF(JJ.EQ.-1) CALL ABRT
            EFP(1,IPOLPOL)   = EFMOPTS(I,JJ,1)
            EFP(2,IPOLPOL)   = EFMOPTS(I,JJ,2)
            EFP(3,IPOLPOL)   = EFMOPTS(I,JJ,3)
          ENDIF
          EFPOL(1,IPOLPOL) = EFMOPPTS(I,J,IOFFSET + 1)
          EFPOL(2,IPOLPOL) = EFMOPPTS(I,J,IOFFSET + 5)
          EFPOL(3,IPOLPOL) = EFMOPPTS(I,J,IOFFSET + 9)
          EFPOL(4,IPOLPOL) = EFMOPPTS(I,J,IOFFSET + 2)
          EFPOL(5,IPOLPOL) = EFMOPPTS(I,J,IOFFSET + 3)
          EFPOL(6,IPOLPOL) = EFMOPPTS(I,J,IOFFSET + 6)
          EFPOL(7,IPOLPOL) = EFMOPPTS(I,J,IOFFSET + 4)
          EFPOL(8,IPOLPOL) = EFMOPPTS(I,J,IOFFSET + 7)
          EFPOL(9,IPOLPOL) = EFMOPPTS(I,J,IOFFSET + 8)
C         screen induced dipoles with screen(1)
          POLSCR(IPOLPOL) = ascreen(1)
          IF(POLSCR(IPOLPOL) .EQ. -1 ) POLSCR(IPOLPOL) = 1.5D+00
c         special bond dipoles, however, are screened with
c         the screen(2) parameter
          IF(J.EQ.NEFMOIPT(I)) THEN
            print *, "CSS: MATCH", J,NEFMOIPT(I),IPOLPOL,ascreen(2)
            POLSCR(IPOLPOL) = ascreen(2)
            POLAB(IDX) = ascreen(2)
          ENDIF
        ENDDO
C       SRP: TRANSFERRING DYNAMIC POINTS FROM EFP TO EFMO
       DO  IDYNPOL=1,12 
        DO J=1,NPPTS(IDX)
           IOFFSET = 3
           NDPST = NDPST + 1
           DPOLNAM(NDPST)  = FMOFRGNAM(I)
           EFDP(1,NDPST)   = J
           EFDP(2,NDPST)   = EFMODPTS(I,J,IDYNPOL,1)
           EFDP(3,NDPST)   = EFMODPTS(I,J,IDYNPOL,2)
           EFDPOL(1,NDPST) = EFMODPTS(I,J,IDYNPOL,IOFFSET + 1)
           EFDPOL(2,NDPST) = EFMODPTS(I,J,IDYNPOL,IOFFSET + 5)
           EFDPOL(3,NDPST) = EFMODPTS(I,J,IDYNPOL,IOFFSET + 9)
           EFDPOL(4,NDPST) = EFMODPTS(I,J,IDYNPOL,IOFFSET + 2)
           EFDPOL(5,NDPST) = EFMODPTS(I,J,IDYNPOL,IOFFSET + 3)
           EFDPOL(6,NDPST) = EFMODPTS(I,J,IDYNPOL,IOFFSET + 6)
           EFDPOL(7,NDPST) = EFMODPTS(I,J,IDYNPOL,IOFFSET + 4)
           EFDPOL(8,NDPST) = EFMODPTS(I,J,IDYNPOL,IOFFSET + 7)
           EFDPOL(9,NDPST) = EFMODPTS(I,J,IDYNPOL,IOFFSET + 8)
         ENDDO
        ENDDO
      ENDDO
C
C     PUNCH OUT INFORMATION
C
      IF(IAND(NPRFMO,32).NE.0) THEN
        IDUM=1
        CALL PRTFRG(IDUM,IDUM,IDUM,IDUM)
      ENDIF
      RETURN
      END
C
C
C
C*MODULE EFMO     *DECK EFMODEG
      SUBROUTINE EFMODEG(IDA,FMODE,IAGLOB,EFMOG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION FMODE(3,*),IAGLOB(*),EFMOG(3,*)
C      PARAMETER (MXATM=2000)
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,IEFMORUN,
     *                IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,IEFMODIM(2),
     *                IMODEFE,NATEFMO,IMODEFD
C      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
C     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
C
C     --- EFMO GRADIENT UPDATER ---
C
      DA = IDA
      DO I=1,NATEFMO
        IG=IAGLOB(I)
        DO J=1,3
          FMODE(J,IG) = FMODE(J,IG)+DA*EFMOG(J,I)
        ENDDO
      ENDDO
      RETURN
      END
C
C
C*MODULE EFMO     *DECK EFMOEXCH
      SUBROUTINE EFMOEXCH(NFG,NEFMOPTS,EFMOPTS,EFMOPPTS,
     *                    EFMODPTS,NEFMOIPT,L1,L2,L3,L4)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER DDI_WORLD,DDI_GROUP
      PARAMETER(DDI_WORLD=0,DDI_GROUP=1)
C      DIMENSION EFMOPTS(NFG,MXEFMOPTS,MXNEFMOPTS),
C     *          EFMOPPTS(NFG,MXEFMOPPTS,MXNEFMOPPTS),
C     *          NEFMOPTS(2,NFG),NEFMOIPT(NFG)
C
C     --- BROADCAST AND ACCUMULATE EFMO DATA ACROSS NODES ---
C
C     SUM UP ACROSS GROUPS IF GDDI
      CALL GDDI_SCOPE(DDI_WORLD)
      CALL DDI_GSUMI(2601,NEFMOPTS,L1)
      CALL DDI_GSUMI(2602,NEFMOIPT,NFG)
      CALL DDI_GSUMF(2603,EFMOPTS,L2)
      CALL DDI_GSUMF(2604,EFMOPPTS,L3)
      CALL DDI_GSUMF(2605,EFMODPTS,L4)
      CALL GDDI_SCOPE(DDI_GROUP)
      RETURN
      END
C
C
C
*MODULE EFMO     *DECK EFMODIMERGLOB
      SUBROUTINE EFMODIMERGLOB(IFG,JFG,IGLOB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /FMCOM / X(1)
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv
C
C     --- DRIVER FOR ALTERNATIVE IAGLOB ---
C
      CALL EFMODIMGLOB(IFG,JFG,X(LNATFRG),X(LINDFRG),
     *     X(LIATFRG),IGLOB)
      RETURN
      END
C
C
C
*MODULE EFMO     *DECK EFMODIMGLOB
      SUBROUTINE EFMODIMGLOB(IFG,JFG,NATFRG,INDFRG,
     *     IATFRG,IGLOB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NATFRG(*),INDFRG(*),IATFRG(*),IGLOB(*)
C      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
C
C     --- MAKE ALTERNATIVE IAGLOB SO IT IS CORRECT FOR ---
C     --- DIMERS IN EFMO, THIS IS GREATLY INSPIRED BY  ---
C     --- MAKMOL IN FMOLIB.SRC ---
C
      NATI = NATFRG(IFG)
      NATJ = NATFRG(JFG)
      INDI = INDFRG(IFG)
      INDJ = INDFRG(JFG)
C
      CALL EFMOADD(NATI,IATFRG,INDI,1,IGLOB)
      CALL EFMOADD(NATJ,IATFRG,INDJ,NATI+1,IGLOB)
C
      RETURN
      END
C
C
C
*MODULE EFMO     *DECK EFMOADD
      SUBROUTINE EFMOADD(NATI,IATFRG,INDI,IOFFSET,IGLOB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IATFRG(*),IGLOB(*)
C
C     -- ADDS ATOMS TO IGLOB --
C
      CALL ICOPY(NATI,IATFRG(INDI),1,IGLOB(IOFFSET),1)
      RETURN
      END
C
C
C
*MODULE EFMO     *DECK EFMORESET
      SUBROUTINE EFMORESET
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      CHARACTER*8 POLNAM,DPOLNAM,FRGNME
C
      PARAMETER(MXFGPT=12000,MXFRG=1050,MXDFG=5,
     *          MXDPPT=MXFRG*MXDFG*12,MXIFRQ=12,MXPT=2000)
C
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ*MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /EFPSCR/ POLAB(MXFRG),B,SCROFF,IELECS,IDISPS,NEW_POL
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG)
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      NMTTPT = 0
      NPTTPT = 0
      NDPTTPT = 0
C      IEFPFMO = 0
      NFRG = 0
      CALL VICLR(NMPTS,1,MXFRG)
      CALL VICLR(NPPTS,1,MXFRG)
      CALL VICLR(LSTMPTS,1,MXFRG)
      CALL VICLR(NDPPTS,1,MXFRG)
      CALL VCLR(POLAB,1,MXFRG)
      CALL VCLR(EFC,1,3*MXFGPT)
      CALL VCLR(FMASS,1,MXFGPT)
      CALL VCLR(EFCHG,1,2*MXFGPT)
      CALL VCLR(EFDIP,1,3*MXFGPT)
      CALL VCLR(EFQAD,1,6*MXFGPT)
      CALL VCLR(EFOCT,1,10*MXFGPT)
      CALL VCLR(EFP,1,3*MXFGPT)
      CALL VCLR(EFPOL,1,9*MXFGPT)
      CALL VCLR(EFDPOL,1,9*MXIFRQ*MXFGPT)
      RETURN
      END
C
C
C
*MODULE EFMO     *DECK EFMOGCA
      SUBROUTINE EFMOGCA(NFG,EFMOPPTS,EFMOPTS,I,NPTS,J,JJ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXEFMOPTS=50,MXEFMOPPTS=60,MXNEFMOPTS=27,
     *           MXNEFMOPPTS=15)
C
      DIMENSION EFMOPTS(NFG,MXEFMOPTS,MXNEFMOPTS),
     *          EFMOPPTS(NFG,MXEFMOPPTS,MXNEFMOPPTS)
C
C     --- RETURNS CLOSEST ATOMS IN JJ ---
C
      AXDIST=1.0D+10
      ITMPIDX=JJ
      DO II=1,NPTS
        R2 = 0.0D+00
        DO KK=1,3
          R2 = R2+(EFMOPTS(I,II,KK) - EFMOPPTS(I,J,KK))**2
        ENDDO
        IF(R2.LT.AXDIST) THEN
          ITMPIDX=II
          AXDIST=R2
        ENDIF
      ENDDO
      IF(ITMPIDX.NE.JJ) JJ=ITMPIDX
      RETURN
      END
C
C
C
*MODULE EFMO     *DECK EFMOGETF
      SUBROUTINE EFMOGETF(IC1,IC1P,IC1P2,F1,F2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXFGPT=12000, MXIFRQ=12)
      CHARACTER*8 FRGNME,POLNAM,DPOLNAM
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ,MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
C
      DATA ZERO,ONE/0.0D+00,1.0D+00/
C
C  --- GET SCALING COEFFICIENTS FOR PERCENTAGE ---
C  --- BASED DISTRIBUTION OF THE GRADIENT      ---
C
      F1 = ONE
      F2 = ZERO
C
      RX = EFC(1,IC1P2) - EFC(1,IC1P)
      RY = EFC(2,IC1P2) - EFC(2,IC1P)
      RZ = EFC(3,IC1P2) - EFC(3,IC1P)
      RD2 = RX*RX+RY*RY+RZ*RZ
      R1AX = EFC(1,IC1P) - EFP(1,IC1)
      R1AY = EFC(2,IC1P) - EFP(2,IC1)
      R1AZ = EFC(3,IC1P) - EFP(3,IC1)
      R2AX = EFC(1,IC1P2) - EFP(1,IC1)
      R2AY = EFC(2,IC1P2) - EFP(2,IC1)
      R2AZ = EFC(3,IC1P2) - EFP(3,IC1)
      D1   = (R1AX*RX + R1AY*RY + R1AZ*RZ)/RD2
      D2   = (R2AX*RX + R2AY*RY + R2AZ*RZ)/RD2
      IF(D1.LT.ZERO) THEN
        F1 = ONE + D1
        F2 = ONE - D2
      ENDIF
      RETURN
      END

*MODULE EFMO     *DECK EFMOSCREENSETUP
      SUBROUTINE EFMOSCREENSETUP(NBDFG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,IEFMORUN,
     *                IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,IEFMODIM(2),
     *                IMODEFE,NATEFMO,IMODEFD
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm
C
C --- SETS UP THE SCREENING IN EFMO
C
      IF(IAND(IMODEFE,1).NE.0) THEN
        IF( ascreen(1).EQ.0) THEN
          ascreen(1) = 1.5D+00
        ENDIF
        ascreen(2) = 1.5D+00
        ascreen(3) = 2.0D+00
      ELSE
        IF(NBDFG.NE.0) THEN
          IF( ascreen(1).EQ.0 ) ascreen(1) = 0.1D+00
          IF( ascreen(2).EQ.0 ) ascreen(2) = 0.1D+00
        ELSE
          IF( ascreen(1).EQ.0 ) ascreen(1) = 0.6D+00
          IF( ascreen(2).EQ.0 ) ascreen(2) = 0.6D+00
        ENDIF
      ENDIF
      RETURN
      END
