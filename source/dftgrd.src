C 19 DEC 12 - JI  - Add h/i functionality. Modified routines are:
C                   DFTAO,DFTGAO,DFTG2AO,DMATD,GRDDFT,GRDGAO,GRDGGAO,INPBAS,DEREXC 
C 18 Oct 12 - MWS - allow ghost atom grids for DFT counterpoise
C 28 DEC 11 - DGF - ALLOW TO CONTROL GRID FILE USAGE IN DFT
C 11 AUG 11 - NM  - GRDDFT: UWGTGRAD ENTRY POINT ADDED
C 15 APR 11 - YI  - CHANGES FOR LOCAL RESPONSE DISPERSION METHOD
C 15 APR 11 - MK  - ACCELERATE DC-DFT GRID EVALUATION
C 15 APR 11 - DGF - GRDDFT,PRUNEOCT: FIX DLB PARALLELISM IN SG1/JANSSEN
C 12 DEC 10 - MWS - OCT: SIMPLIFY STORAGE SPECIFICATION
C 23 JUN 10 - MK  - SG1/JANSSEN FIX NUMBER OF GRID POINTS IN PARALLEL
C 25 MAR 10 - MK,MWS  - DMATD,DEREXC: DC-UHF, SECRET BRAGG INPUT
C 14 OCT 09 - FZ  - GRDDFT: PROVIDE PRINTABLE FUNCTIONAL FOR DFTTYP=NONE
C 14 AUG 09 - KAN - COULOMB ATTENUATED METHODS (CAM) FOR DFT & TDDFT
C 22 MAY 09 - STB - ADDED JANSSEN PRUNED GRIDS TO DFT PROCEDURES
C 22 MAY 09 - HPTI- DFTGDV: OPTIMIZED MEMORY-STRIDE ACCESS FOR META-GGA
C                   GRDDFT: CHANGES TO ALLOW SLB PARALLELIZATION
C  1 MAY 09 - PFS - CHANGES FOR LMOEDA METHOD
C 20 NOV 08 - MK  - CHANGES TO ADD THE DIVIDE-AND-CONQUER METHOD
C 23 OCT 08 - SS  - SYNCRONIZE THE DFTEXC COMMON
C 18 JUL 08 - TK  - PRINT RADIAL OVERLAP FOR LARGEST/SMALLEST GTO ZETA'S
C 11 APR 08 - HPTI - IMPLEMENT LEBEDEV AND SG1 ANGULAR GRIDS
C  4 MAR 08 - SS  - META-GGA CONTRIBUTIONS TO FOCK AND NUCLEAR GRADIENTS
C  4 MAR 08 - MWS - STOP REPEATED FUNCTIONAL PRINTING, EXETYP=CHECK
C 20 AUG 07 - MC  - MODIFICATION FOR TDDFT GRADIENT CALCULATION
C  6 NOV 06 - MC  - ADD GRDCALC,GRDWT,GRDRD,GRDGAO,DCHXYZ,CHIXYZ: TDDFT
C 14 NOV 05 - DGF - PAD COMMON BLOCK SCFOPT
C 19 SEP 05 - GDF - PAD SHLNRM COMMON FOR H AND I FUNCTIONS
C  5 JUL 05 - MWS - SELECT NEW ATOM,BASIS,EFP,PCM,DAF DIMENSIONS
C 13 FEB 05 - MWS - PAD COMMON BLOCK NSHEL
C 16 JAN 04 - DGF - NEW DFT GRADIENT THRESHOLDS
C  9 DEC 03 - MWS - SYNCH COMMON BLOCK RUNOPT
C 26 MAR 02 - DGF - ATMVEC: FIX FOR DUMMY ATOMS
C 24 JAN 02 - RMO - GRDPT,
C  5 DEC 01 - DGF - FIX FOR CASE OF NO BETA ELECTRONS
C 25 JUN 01 - MWS - ALTER COMMON BLOCK SCFOPT AND WFNOPT
C 13 JUN 01 - DGF,MK ADD WEIGHT DERIVATIVES TO COMPLETE THE DFT GRADIENT
C 30 APR 01 - TT,SY,MK,DGF IMPLEMENT GRID-BASED DFT
C
C     POSSIBLE OPTIMIZATION: SOME ARRAYS LIKE ATMXVEC ARE ADDRESSED
C                            AS COLUMNS RATHER THAN ROWS.
C
C*MODULE DFTGRD  *DECK ATMVEC
C>    @brief Calculates atomic distance and vectors
C>
C>    @details THIS ROUTINE CALCULATES THE ATOMIC DISTANCE AND ATOMIC VECTORS FOR
C>    USE IN THE BECKE'S FUZZY CELL METHOD.
C>
      SUBROUTINE ATMVEC(ATMXVEC,ATMYVEC,ATMZVEC,RIJ)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000,ZERO=0.0D+00)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C
      DIMENSION ATMXVEC(NAT,NAT),ATMYVEC(NAT,NAT),ATMZVEC(NAT,NAT),
     *          RIJ(NAT,NAT)
C
      DO 10 IATM=1,NAT
         XCNTR=C(1,IATM)
         YCNTR=C(2,IATM)
         ZCNTR=C(3,IATM)
         ATMXVEC(IATM,IATM)=ZERO
         ATMYVEC(IATM,IATM)=ZERO
         ATMZVEC(IATM,IATM)=ZERO
         RIJ(IATM,IATM)=ZERO
         DO 20 JATM=1,IATM-1
            ATMXVEC(IATM,JATM)= XCNTR-C(1,JATM)
            ATMYVEC(IATM,JATM)= YCNTR-C(2,JATM)
            ATMZVEC(IATM,JATM)= ZCNTR-C(3,JATM)
            ATMXVEC(JATM,IATM)=-ATMXVEC(IATM,JATM)
            ATMYVEC(JATM,IATM)=-ATMYVEC(IATM,JATM)
            ATMZVEC(JATM,IATM)=-ATMZVEC(IATM,JATM)
            RIJ(IATM,JATM)=SQRT(
     *            ATMXVEC(IATM,JATM)*ATMXVEC(IATM,JATM)
     *           +ATMYVEC(IATM,JATM)*ATMYVEC(IATM,JATM)
     *           +ATMZVEC(IATM,JATM)*ATMZVEC(IATM,JATM))
            RIJ(JATM,IATM)=RIJ(IATM,JATM)
 20      CONTINUE
 10   CONTINUE
      RETURN
      END
C*MODULE DFTGRD  *DECK DFTAO
C
C>    @brief Computes values of all AOs for a grid point
C>
C>    @date : December 21, 2012 - Joe Ivanic 
C>            Modify IJX,IJY,IJZ to have dimension 84 for h,i cartesians        
C
      SUBROUTINE DFTAO(IJX,IJY,IJZ,VALMOA,ANGXVL,ANGYVL,ANGZVL,CL,EXPS,
     *                 RSQRD,NAT,L1)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXSH=5000, MXGTOT=20000, TWO=2.0D+00,RLN10=2.30258D+00)
C
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /SHLNRM/ PNRM(84)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      DIMENSION VALMOA(*),EXPS(*),ANGXVL(NAT,*),ANGYVL(NAT,*),
     *          ANGZVL(NAT,*),CL(*),RSQRD(NAT)
      DIMENSION IJX(84),IJY(84),IJZ(84)
C
      TOL = RLN10*ITOL/TWO
C
C     ITOL SETS THRESHOLD FOR INTEGRALS. HERE IT IS APPLIED TO
C     WAVEFUNCTION, THUS IT IS HALVED. IT IS FOUND THAT THIS IS A
C     RATHER CONSERVATIVE SETTING AND ONE GETS ABOUT 11 SIG. FIGURES
C     OF ACCURACY IN THE TOTAL ENERGY WITH THE DEFAULT ITOL=20.
C     SEE DFTGAO AND DFTG2AO.
C
      IFCT=0
      CALL VCLR(VALMOA,1,L1)
      DO 40 ISHELL = 1, NSHELL
         IATM = KATOM(ISHELL)
C***********************************************************************
C     ANGULAR INTERMEDIATES FOR THE DENSITY AND GRADIENT
C***********************************************************************
         K1 = KSTART(ISHELL)
         K2 = K1 + KNG(ISHELL) - 1
         MINI=KMIN(ISHELL)
         MAXI=KMAX(ISHELL)
         LOCI = KLOC(ISHELL)-MINI
         LOCI0= KLOC(ISHELL)
         DO 60 IMOMFCT = K1, K2
            IFCT=IFCT+1
            DUM=EX(IMOMFCT)*RSQRD(IATM)
            IF(DUM.GT.TOL) GOTO 60
            VEXP=EXP(-DUM)
            EXPS(IFCT)=VEXP
C           SAVE EXP FOR THE GRADIENT
            CC=CL(IMOMFCT)
            LOCI1=LOCI0
            IF(MINI.EQ.1) THEN
C
C           SPECIAL FAST CODE FOR S FUNCTIONS (INCLUDING L SHELLS)
C
               VALMOA(LOCI1)=VALMOA(LOCI1)+CC*VEXP
C              FOR L-SHELLS
               LOCI1=LOCI1+1
               CC=CP(IMOMFCT)
            ENDIF
            IF(MAXI.EQ.4) THEN
C
C           SPECIAL FAST CODE FOR P FUNCTIONS (INCLUDING L SHELLS)
C
               VALMOA(LOCI1  )=VALMOA(LOCI1  )+CC*VEXP*ANGXVL(IATM,3)
               VALMOA(LOCI1+1)=VALMOA(LOCI1+1)+CC*VEXP*ANGYVL(IATM,3)
               VALMOA(LOCI1+2)=VALMOA(LOCI1+2)+CC*VEXP*ANGZVL(IATM,3)
               LOCI1=LOCI1+3
            ENDIF
            IF(LOCI1.NE.LOCI0) GOTO 60
C
C           GENERAL CODE (WORKS FOR S,P,L FUNCTIONS AS WELL)
C           TO USE FOR L-FUNCTIONS, UNCOMMENT THE "C     L-SHELL" LINE
C
            DO 50 ITYP = MINI,MAXI
               IX=IJX(ITYP)-1
               IY=IJY(ITYP)-1
               IZ=IJZ(ITYP)-1
C
C              COMPUTE AO VALUE AT A GRID POINT
C
               DUM=CC*PNRM(ITYP)*VEXP
               VALMOA(LOCI+ITYP)=VALMOA(LOCI+ITYP)+ANGXVL(IATM,IX+2)*
     *            ANGYVL(IATM,IY+2)*ANGZVL(IATM,IZ+2)*DUM
C              UNCOMMENT FOR L-SHELL
C              IF(ITYP.EQ.1) CC=CP(IMOMFCT)
C              THIS IS THE DREADED L-SHELL CASE, FOR S-SHELLS THE LOOP
C              IS OVER, OTHERWISE USE P COEFFICIENT IN THE FOLLOWING
 50         CONTINUE
 60      CONTINUE
 40   CONTINUE
C
      RETURN
      END
C*MODULE DFTGRD  *DECK DFTGAO
C>    @brief Computes values of gradient at grid point
C>
C>    @details THIS ROUTINE COMPUTES VALUES OF GRADIENT (DERIVATIVE BY THE
C>    ELECTRON COORDINATE) OF ALL AOS FOR A GRID POINT.
C>
C>    @date : December 21, 2012 - Joe Ivanic
C>            Modify IJX,IJY,IJZ to have dimension 84 for h,i cartesians
C
      SUBROUTINE DFTGAO(IJX,IJY,IJZ,GVALAX,GVALAY,GVALAZ,ANGXVL,ANGYVL,
     *                  ANGZVL,CL,EXPS,RSQRD,NAT,L1)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXSH=5000, MXGTOT=20000, TWO=2.0D+00,RLN10=2.30258D+00)
C
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /SHLNRM/ PNRM(84)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      DIMENSION GVALAX(L1),GVALAY(L1),GVALAZ(L1),ANGXVL(NAT,*),
     *          ANGYVL(NAT,*),ANGZVL(NAT,*),CL(*),RSQRD(NAT),EXPS(*)
      DIMENSION IJX(84),IJY(84),IJZ(84)

C
      TOL = RLN10*ITOL/TWO
C     THE SAME AS IN DFTAO.
C
      IFCT=0
      CALL VCLR(GVALAX,1,L1)
      CALL VCLR(GVALAY,1,L1)
      CALL VCLR(GVALAZ,1,L1)
      DO 40 ISHELL = 1, NSHELL
         IATM = KATOM(ISHELL)
C***********************************************************************
C     ANGULAR INTERMEDIATES FOR THE DENSITY AND GRADIENT
C***********************************************************************
         K1 = KSTART(ISHELL)
         K2 = K1 + KNG(ISHELL) - 1
         MINI=KMIN(ISHELL)
         MAXI=KMAX(ISHELL)
         LOCI = KLOC(ISHELL)-MINI
         LOCI0= KLOC(ISHELL)
         DO 60 IMOMFCT = K1, K2
            IFCT=IFCT+1
            TWOALP = EX(IMOMFCT)*TWO
            DUM=EX(IMOMFCT)*RSQRD(IATM)
            IF(DUM.GT.TOL) GOTO 60
C           VEXP=EXP(-DUM)
            VEXP=EXPS(IFCT)
            CC=CL(IMOMFCT)
            LOCI1=LOCI0
            IF(MINI.EQ.1) THEN
C
C           SPECIAL FAST CODE FOR S FUNCTIONS (INCLUDING L SHELLS)
C
              DUM=CC*VEXP*TWOALP
              GVALAX(LOCI1)=GVALAX(LOCI1)-DUM*ANGXVL(IATM,3)
              GVALAY(LOCI1)=GVALAY(LOCI1)-DUM*ANGYVL(IATM,3)
              GVALAZ(LOCI1)=GVALAZ(LOCI1)-DUM*ANGZVL(IATM,3)
C             FOR L-SHELLS
              LOCI1=LOCI1+1
              CC=CP(IMOMFCT)
            ENDIF
            IF(MAXI.EQ.4) THEN
C
C           SPECIAL FAST CODE FOR P FUNCTIONS (INCLUDING L SHELLS)
C
               DUM=CC*TWOALP*VEXP
               DUM1=CC*VEXP
               XY=DUM*ANGXVL(IATM,3)*ANGYVL(IATM,3)
               XZ=DUM*ANGXVL(IATM,3)*ANGZVL(IATM,3)
               YZ=DUM*ANGYVL(IATM,3)*ANGZVL(IATM,3)
               GVALAX(LOCI1)=GVALAX(LOCI1)+DUM1-DUM*ANGXVL(IATM,4)
               GVALAY(LOCI1)=GVALAY(LOCI1)-XY
               GVALAZ(LOCI1)=GVALAZ(LOCI1)-XZ
               LOCI1=LOCI1+1
               GVALAX(LOCI1)=GVALAX(LOCI1)-XY
               GVALAY(LOCI1)=GVALAY(LOCI1)+DUM1-DUM*ANGYVL(IATM,4)
               GVALAZ(LOCI1)=GVALAZ(LOCI1)-YZ
               LOCI1=LOCI1+1
               GVALAX(LOCI1)=GVALAX(LOCI1)-XZ
               GVALAY(LOCI1)=GVALAY(LOCI1)-YZ
               GVALAZ(LOCI1)=GVALAZ(LOCI1)+DUM1-DUM*ANGZVL(IATM,4)
               LOCI1=LOCI1+1
            ENDIF
            IF(LOCI1.NE.LOCI0) GOTO 60
C
C           GENERAL CODE (WORKS FOR S,P,L FUNCTIONS AS WELL)
C           TO USE FOR L-FUNCTIONS, UNCOMMENT THE "C     L-SHELL" LINE
C
            DO 50 ITYP = MINI,MAXI
               IX=IJX(ITYP)-1
               IY=IJY(ITYP)-1
               IZ=IJZ(ITYP)-1
               DUM=CC*PNRM(ITYP)*VEXP
C
C              COMPUTE GRADIENT AO VALUE AT A GRID POINT
C              GRADIENT IS BY THE ELECTRON (NOT NUCLEAR) COORDINATES
C
               ANGYZVL=ANGYVL(IATM,IY+2)*ANGZVL(IATM,IZ+2)
               ANGZXVL=ANGZVL(IATM,IZ+2)*ANGXVL(IATM,IX+2)
               ANGXYVL=ANGXVL(IATM,IX+2)*ANGYVL(IATM,IY+2)
C***********************************************************************
C     GRADIENT MINUS ONE COMPONENT
C***********************************************************************
               ANGXM= IX*ANGXVL(IATM,IX+1)*ANGYZVL
               ANGYM= IY*ANGYVL(IATM,IY+1)*ANGZXVL
               ANGZM= IZ*ANGZVL(IATM,IZ+1)*ANGXYVL
C***********************************************************************
C     GRADIENT PLUS ONE COMPONENT
C***********************************************************************
               ANGXP= ANGXVL(IATM,IX+3)*ANGYZVL
               ANGYP= ANGYVL(IATM,IY+3)*ANGZXVL
               ANGZP= ANGZVL(IATM,IZ+3)*ANGXYVL
C
               LOCI0=LOCI+ITYP
               GVALAX(LOCI0) = GVALAX(LOCI0)+DUM*(ANGXM-TWOALP*ANGXP)
               GVALAY(LOCI0) = GVALAY(LOCI0)+DUM*(ANGYM-TWOALP*ANGYP)
               GVALAZ(LOCI0) = GVALAZ(LOCI0)+DUM*(ANGZM-TWOALP*ANGZP)
C              UNCOMMENT FOR L-SHELLS
C              IF(ITYP.EQ.1) CC=CP(IMOMFCT)
C              THIS IS THE DREADED L-SHELL CASE, FOR S-SHELLS THE LOOP
C              IS OVER, OTHERWISE USE P COEFFICIENT IN THE FOLLOWING.
 50         CONTINUE
 60      CONTINUE
 40   CONTINUE
C
      RETURN
      END
C*MODULE DFTGRD  *DECK DFTG2AO
C>    @brief Computes second derivatives of basis function
C>
C>    @date : December 21, 2012 - Joe Ivanic
C>            Modify IJX,IJY,IJZ to have dimension 84 for h,i cartesians
C
      SUBROUTINE DFTG2AO(IJX,IJY,IJZ,G2AOXX,G2AOYY,G2AOZZ,G2AOXY,G2AOYZ,
     *                 G2AOXZ,ANGXVL,ANGYVL,ANGZVL,CL,EXPS,RSQRD,NAT,L1)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXSH=5000, MXGTOT=20000, ONE=1.0D+00,
     *             TWO=2.0D+00,THREE=3.0D+00,RLN10=2.30258D+00)
C
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /SHLNRM/ PNRM(84)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      DIMENSION CL(*),RSQRD(NAT),G2AOXX(*),G2AOYY(*),G2AOZZ(*),
     *          G2AOXY(*),G2AOYZ(*),G2AOXZ(*),EXPS(*),
     *          ANGXVL(NAT,*),ANGYVL(NAT,*),ANGZVL(NAT,*)
      DIMENSION IJX(84),IJY(84),IJZ(84)
C
      TOL = RLN10*ITOL/TWO
C     THE SAME AS IN DFTAO.
C
      IFCT=0
      CALL VCLR(G2AOXX,1,L1)
      CALL VCLR(G2AOYY,1,L1)
      CALL VCLR(G2AOZZ,1,L1)
      CALL VCLR(G2AOXY,1,L1)
      CALL VCLR(G2AOYZ,1,L1)
      CALL VCLR(G2AOXZ,1,L1)
      DO 40 ISHELL = 1, NSHELL
         IATM = KATOM(ISHELL)
C
C     ANGULAR INTERMEDIATES FOR THE DENSITY AND GRADIENT
C
         K1 = KSTART(ISHELL)
         K2 = K1 + KNG(ISHELL) - 1
         MINI=KMIN(ISHELL)
         MAXI=KMAX(ISHELL)
         LOCI = KLOC(ISHELL)-MINI
         LOCI0= KLOC(ISHELL)
         DO 60 IMOMFCT = K1, K2
           IFCT=IFCT+1
           TWOALP = EX(IMOMFCT)*TWO
           DUM=EX(IMOMFCT)*RSQRD(IATM)
           IF(DUM.GT.TOL) GOTO 60
           VEXP=EXPS(IFCT)
           CC=CL(IMOMFCT)
           LOCI1=LOCI0
           IF(MINI.EQ.1) THEN
C
C     SPECIAL FAST CODE FOR S FUNCTIONS (INCLUDING L SHELLS)
C
             DUM=CC*VEXP*TWOALP
C
             XY=DUM*ANGXVL(IATM,3)*ANGYVL(IATM,3)
             XZ=DUM*ANGXVL(IATM,3)*ANGZVL(IATM,3)
             YZ=DUM*ANGYVL(IATM,3)*ANGZVL(IATM,3)
C
             G2AOXX(LOCI1)=G2AOXX(LOCI1)-DUM*(ONE-TWOALP*ANGXVL(IATM,4))
             G2AOYY(LOCI1)=G2AOYY(LOCI1)-DUM*(ONE-TWOALP*ANGYVL(IATM,4))
             G2AOZZ(LOCI1)=G2AOZZ(LOCI1)-DUM*(ONE-TWOALP*ANGZVL(IATM,4))
             G2AOXY(LOCI1)=G2AOXY(LOCI1)+XY*TWOALP
             G2AOYZ(LOCI1)=G2AOYZ(LOCI1)+YZ*TWOALP
             G2AOXZ(LOCI1)=G2AOXZ(LOCI1)+XZ*TWOALP
C
C     FOR L-SHELLS
C
             LOCI1=LOCI1+1
             CC=CP(IMOMFCT)
           ENDIF
           IF(MAXI.EQ.4) THEN
C
C     SPECIAL FAST CODE FOR P FUNCTIONS (INCLUDING L SHELLS)
C
             DUM=CC*TWOALP*VEXP
             DUMX=ONE-TWOALP*ANGXVL(IATM,4)
             DUMY=ONE-TWOALP*ANGYVL(IATM,4)
             DUMZ=ONE-TWOALP*ANGZVL(IATM,4)
             DUMXYZ=TWOALP*DUM*ANGXVL(IATM,3)*ANGYVL(IATM,3)*
     *                         ANGZVL(IATM,3)
             TWOALP2=TWOALP*TWOALP
C
C     PX
C     ----
             G2AOXX(LOCI1)=G2AOXX(LOCI1)
     >                 -DUM*(THREE*ANGXVL(IATM,3)-TWOALP*ANGXVL(IATM,5))
             G2AOYY(LOCI1)=G2AOYY(LOCI1)-DUM*DUMY*ANGXVL(IATM,3)
             G2AOZZ(LOCI1)=G2AOZZ(LOCI1)-DUM*DUMZ*ANGXVL(IATM,3)
C
             G2AOXY(LOCI1)=G2AOXY(LOCI1)-DUM*DUMX*ANGYVL(IATM,3)
             G2AOYZ(LOCI1)=G2AOYZ(LOCI1)+DUMXYZ
             G2AOXZ(LOCI1)=G2AOXZ(LOCI1)-DUM*DUMX*ANGZVL(IATM,3)
             LOCI1=LOCI1+1
C
C     PY
C     ----
             G2AOXX(LOCI1)=G2AOXX(LOCI1)-DUM*DUMX*ANGYVL(IATM,3)
             G2AOYY(LOCI1)=G2AOYY(LOCI1)
     >                 -DUM*(THREE*ANGYVL(IATM,3)-TWOALP*ANGYVL(IATM,5))
             G2AOZZ(LOCI1)=G2AOZZ(LOCI1)-DUM*DUMZ*ANGYVL(IATM,3)
C
             G2AOXY(LOCI1)=G2AOXY(LOCI1)-DUM*DUMY*ANGXVL(IATM,3)
             G2AOYZ(LOCI1)=G2AOYZ(LOCI1)-DUM*DUMY*ANGZVL(IATM,3)
             G2AOXZ(LOCI1)=G2AOXZ(LOCI1)+DUMXYZ
             LOCI1=LOCI1+1
C
C     PZ
C     ----
             G2AOXX(LOCI1)=G2AOXX(LOCI1)-DUM*DUMX*ANGZVL(IATM,3)
             G2AOYY(LOCI1)=G2AOYY(LOCI1)-DUM*DUMY*ANGZVL(IATM,3)
             G2AOZZ(LOCI1)=G2AOZZ(LOCI1)
     >                 -DUM*(THREE*ANGZVL(IATM,3)-TWOALP*ANGZVL(IATM,5))
C
             G2AOXY(LOCI1)=G2AOXY(LOCI1)+DUMXYZ
             G2AOYZ(LOCI1)=G2AOYZ(LOCI1)-DUM*DUMZ*ANGYVL(IATM,3)
             G2AOXZ(LOCI1)=G2AOXZ(LOCI1)-DUM*DUMZ*ANGXVL(IATM,3)
             LOCI1=LOCI1+1
C
           ENDIF
           IF(LOCI1.NE.LOCI0) GOTO 60
C
C     GENERAL CODE (WORKS FOR S,P,L FUNCTIONS AS WELL)
C     TO USE FOR L-FUNCTIONS, UNCOMMENT THE "C     L-SHELL" LINE
C
           DO 50 ITYP = MINI,MAXI
             IX=IJX(ITYP)-1
             IY=IJY(ITYP)-1
             IZ=IJZ(ITYP)-1
             DUM=CC*PNRM(ITYP)*VEXP
C
C            COMPUTE 2ND DERIVATIVE OF AO VALUE AT A GRID POINT
C            GRADIENT IS BY THE ELECTRON (NOT NUCLEAR) COORDINATES
C
             ANGYZVL=ANGYVL(IATM,IY+2)*ANGZVL(IATM,IZ+2)
             ANGZXVL=ANGZVL(IATM,IZ+2)*ANGXVL(IATM,IX+2)
             ANGXYVL=ANGXVL(IATM,IX+2)*ANGYVL(IATM,IY+2)
C
C     GRADIENT MINUS TWO COMPONENT
C     ---------------------------
             ANGXMM= IX*(IX-1)*ANGXVL(IATM,IX)*ANGYZVL
             ANGYMM= IY*(IY-1)*ANGYVL(IATM,IY)*ANGZXVL
             ANGZMM= IZ*(IZ-1)*ANGZVL(IATM,IZ)*ANGXYVL
             ANGXYM= IX*IY*ANGXVL(IATM,IX+1)
     >                    *ANGYVL(IATM,IY+1)*ANGZVL(IATM,IZ+2)
             ANGXZM= IX*IZ*ANGXVL(IATM,IX+1)
     >                    *ANGYVL(IATM,IY+2)*ANGZVL(IATM,IZ+1)
             ANGYZM= IY*IZ*ANGXVL(IATM,IX+2)
     >                    *ANGYVL(IATM,IY+1)*ANGZVL(IATM,IZ+1)
C
C     GRADIENT PLUS TWO COMPONENT
C     --------------------------
           ANGXPP= ANGXVL(IATM,IX+4)*ANGYZVL
           ANGYPP= ANGYVL(IATM,IY+4)*ANGZXVL
           ANGZPP= ANGZVL(IATM,IZ+4)*ANGXYVL
           ANGXYP= ANGXVL(IATM,IX+3)*ANGYVL(IATM,IY+3)*ANGZVL(IATM,IZ+2)
           ANGXZP= ANGXVL(IATM,IX+3)*ANGYVL(IATM,IY+2)*ANGZVL(IATM,IZ+3)
           ANGYZP= ANGXVL(IATM,IX+2)*ANGYVL(IATM,IY+3)*ANGZVL(IATM,IZ+3)
C
C     OTHERS
C     ------
          ANGXY=IY*ANGXVL(IATM,IX+3)*ANGYVL(IATM,IY+1)*ANGZVL(IATM,IZ+2)
          ANGYX=IX*ANGXVL(IATM,IX+1)*ANGYVL(IATM,IY+3)*ANGZVL(IATM,IZ+2)
          ANGXZ=IZ*ANGXVL(IATM,IX+3)*ANGYVL(IATM,IY+2)*ANGZVL(IATM,IZ+1)
          ANGZX=IX*ANGXVL(IATM,IX+1)*ANGYVL(IATM,IY+2)*ANGZVL(IATM,IZ+3)
          ANGYZ=IZ*ANGXVL(IATM,IX+2)*ANGYVL(IATM,IY+3)*ANGZVL(IATM,IZ+1)
          ANGZY=IY*ANGXVL(IATM,IX+2)*ANGYVL(IATM,IY+1)*ANGZVL(IATM,IZ+3)
C
C
          ANGDEN=ANGXVL(IATM,IX+2)*ANGYVL(IATM,IY+2)*ANGZVL(IATM,IZ+2)
C
          TWOALP2= TWOALP * TWOALP
C
          LOCI0=LOCI+ITYP
          G2AOXX(LOCI0)=G2AOXX(LOCI0)+DUM*(ANGXMM-TWOALP*(IX*2+1)*ANGDEN
     *                                   + TWOALP2*ANGXPP)
          G2AOYY(LOCI0)=G2AOYY(LOCI0)+DUM*(ANGYMM-TWOALP*(IY*2+1)*ANGDEN
     >                                   + TWOALP2*ANGYPP)
          G2AOZZ(LOCI0)=G2AOZZ(LOCI0)+DUM*(ANGZMM-TWOALP*(IZ*2+1)*ANGDEN
     >                                   + TWOALP2*ANGZPP)
          G2AOXY(LOCI0)=G2AOXY(LOCI0)+DUM*(ANGXYM-TWOALP*(ANGXY+ANGYX)
     >                                   + TWOALP2*ANGXYP)
          G2AOYZ(LOCI0)=G2AOYZ(LOCI0)+DUM*(ANGYZM-TWOALP*(ANGYZ+ANGZY)
     >                                   + TWOALP2*ANGYZP)
          G2AOXZ(LOCI0)=G2AOXZ(LOCI0)+DUM*(ANGXZM-TWOALP*(ANGXZ+ANGZX)
     >                                   + TWOALP2*ANGXZP)
C
C          L-SHELL
C          IF(ITYP.EQ.1) CC=CP(IMOMFCT)
C          THIS IS THE DREADED L-SHELL CASE, FOR S-SHELLS THE LOOP IS
C          OVER AND OTHERWISE USE THE P COEFFICIENT IN THE FOLLOWING.
 50        CONTINUE
 60      CONTINUE
 40   CONTINUE
      RETURN
      END
C*MODULE DFTGRD  *DECK DFTFOCK
C>    @brief Adds DFT exchange/correlation to Fock Matrix (alpha and beta)
C
      SUBROUTINE DFTFOCK(NEEDGR,UROHF,FTOTWT,DUMA,DUMB,DUMAX,DUMAY,
     *                   DUMAZ,DUMBX,DUMBY,DUMBZ,VALGA,VALGB,AOX,GAOX,
     *                   GAOY,GAOZ,FA,FB,CUTOFF,L1,DMGGA,DMGGB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL UROHF,NEEDGR
      PARAMETER (TWO=2.0D+00,ZERO=0.0D+00)
      DIMENSION AOX(*),GAOX(*),GAOY(*),GAOZ(*),FA(*),FB(*),VALGA(*),
     *          VALGB(*)
C
      IF(.NOT.NEEDGR) THEN
        IND=1
        DO I=1,L1
          FFA=FTOTWT*DUMA*AOX(I)
          IF(UROHF) THEN
            FFB=FTOTWT*DUMB*AOX(I)
            IF(ABS(FFA)+ABS(FFB).LT.CUTOFF*TWO) THEN
              IND=IND+I
              GOTO 100
            ENDIF
            DO J=1,I
              FA(IND)=FA(IND)+FFA*AOX(J)
              FB(IND)=FB(IND)+FFB*AOX(J)
              IND=IND+1
            ENDDO
  100       CONTINUE
C           CALL DAXPY(I,FFA,AOX,1,FA(IND),1)
C           CALL DAXPY(I,FFB,AOX,1,FB(IND),1)
C           IND=IND+I
          ELSE
            IF(ABS(FFA).LT.CUTOFF) THEN
              IND=IND+I
              GOTO 200
            ENDIF
            DO J=1,I
              FA(IND)=FA(IND)+FFA*AOX(J)
              IND=IND+1
            ENDDO
  200       CONTINUE
          ENDIF
        ENDDO
      ELSE
C       META-GGA BELONGS HERE FOR THE -ELSE- CASE
        IND=1
        AOMAX=ZERO
        AMAXVAL=ZERO
        BMAXVAL=ZERO
        DO I=1,L1
          VALGA(I)=(DUMA/TWO*AOX(I)+DUMAX*GAOX(I)+DUMAY*GAOY(I)+
     *              DUMAZ*GAOZ(I))*FTOTWT
          C1=AOX(I)
          C2A=VALGA(I)
          AOMAX=MAX(AOMAX,ABS(C1))
          AMAXVAL=MAX(AMAXVAL,ABS(C2A))
          IF(UROHF) THEN
           VALGB(I)=(DUMB/TWO*AOX(I)+DUMBX*GAOX(I)+DUMBY*GAOY(I)
     *              +DUMBZ*GAOZ(I))*FTOTWT
            C2B=VALGB(I)
            BMAXVAL=MAX(BMAXVAL,ABS(C2B))
            IF(ABS(C1*(AMAXVAL+BMAXVAL))+(ABS(C2A)+ABS(C2B))*AOMAX.LT.
     *         CUTOFF*TWO) THEN
              IND=IND+I
              GOTO 300
            ENDIF
            DO J=1,I
              FA(IND)=FA(IND)+C1*VALGA(J)+C2A*AOX(J)
     >               +DMGGA*(GAOX(I)*GAOX(J)
     >                      +GAOY(I)*GAOY(J)
     >                      +GAOZ(I)*GAOZ(J))*FTOTWT
              FB(IND)=FB(IND)+C1*VALGB(J)+C2B*AOX(J)
     >               +DMGGB*(GAOX(I)*GAOX(J)
     >                      +GAOY(I)*GAOY(J)
     >                      +GAOZ(I)*GAOZ(J))*FTOTWT
              IND=IND+1
            ENDDO
  300       CONTINUE
          ELSE
            IF(ABS(C1*AMAXVAL)+ABS(C2A*AOMAX).LT.CUTOFF) THEN
              IND=IND+I
              GOTO 400
            ENDIF
            DO J=1,I
              FA(IND)=FA(IND)+C1*VALGA(J)+C2A*AOX(J)
     >               +DMGGA*(GAOX(I)*GAOX(J)
     >                      +GAOY(I)*GAOY(J)
     >                      +GAOZ(I)*GAOZ(J))*FTOTWT
              IND=IND+1
            ENDDO
  400       CONTINUE
          ENDIF
        ENDDO
      ENDIF
      RETURN
C
C     THE NON META-GGA CASE DOES NOT NEED TO BE CAPTURED WITH AN -IF-
C     STATEMENT SINCE THE META-GGA VARIABLES THAT PARTICIPATE IN THE
C     FOCK BUILD HAS BEEN INITIALIZED TO ZERO (-DMCA-,-DMCB-).
C
      END
C*MODULE DFTGRD  *DECK DMATD
C>    @brief Integration of <I|V|A>
C>
C>    @details THIS ROUTINE DOES A NUMERICAL INTEGRATION TO YIELD THE <I|V|A>
C>     MATRIX WHERE V=D_E(XC)/D_RHO.  IN C1 SYMMETRY FOR NOW.
C>     THE RADIAL QUADRATURE FORMULA IS TAKEN FROM
C>     P.M.W.GILL, B.G.JOHNSON, J.A.POPLE AND M.J.FRISCH,
C>     CHEM. PHYS. LETT. 197, 499 (1992).
C>     THE ANGULAR QUADRATURE FORMULA IS TAKEN FROM V.I.LEBEDEV,
C>     ZH. VYCHISL. MAT. FIZ. 15, 48 (1975) AND 16, 293 (1976),
C>     (ENGLISH TRANSLATION IN U.S.S.R. COMPUT. MATH AND MATH PHYS).
C>     EXCHANGE AND CORRELATION ENERGY CONTRIBUTION DUE TO INTEGRATION
C>     OVER GRID POINTS SURROUNDING ATOM NCNTR IS COMPUTED.
C>
C>    @date : December 21, 2012 - Joe Ivanic
C>            Modify IJX,IJY,IJZ to have dimension 84 for h,i cartesians
C
      SUBROUTINE DMATD(TOTWT,IIFACT,NAPTS,COEFFA,COEFFB,IANGN,IFACTR,
     *                 INC0,VMOA,DVMOXA,DVMOYA,DVMOZA,VALGA,VMOB,DVMOXB,
     *                 DVMOYB,DVMOZB,VALGB,FA,FB,NCNTR,EEXC,TOTELE,NANG,
     *                 PTRAD,XDAT,YDAT,ZDAT,ATMXVEC,ATMYVEC,ATMZVEC,
     *                 ANGXVL,ANGYVL,ANGZVL,RSQRD,PCOEFF,EXPS,
     *                 AOX,GAOX,GAOY,GAOZ,NLCT,NELM,IJX,IJY,IJZ,L1,
     *                 NEEDGR,UROHF,TOTKIN,ATMPOL,ATPPOL,EFPOL,
     *                 WTAB,DRSPH,MAXL,MAXM,NFREQ)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL UROHF,OUT,NEEDGR,GOPARR,DSKWRK,MASWRK,DLB,NEEDTAU,
     *        PRTTAU,SG1,FUNCL,FUNFL
C
      PARAMETER (MXATM=2000,ZERO=0.0D+00,ONE=1.0D+00,TWO=2.0D+00)
      PARAMETER (MXGRID=10,MXGRIDTYP=10)
C
      COMMON /DFGRID/ DFTTHR,DFTGTHR,SWOFF,SW0,BSLRD(137),NDFTFG,
     *                NRAD,NTHE,NPHI,NRAD0,NTHE0,NPHI0,
     *                NANGPT(MXGRID),NANGPT0(MXGRID),SG1,JANS
      COMMON /DFPRUN/ PRUNERADS(MXGRID,MXGRIDTYP),
     *                PRUNEATOMS(2,MXGRIDTYP),
     *                IPRUNECUTS(MXATM),NTOTGRIDPOINTS(MXATM),
     *                NGRIDS,MAXANG,NGRIDTYPS
      COMMON /DNSAO / IDENAO
      COMMON /FUNLIB/ FUNCL,FUNFL
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /LMOEDA/ GDTOLA,GJTOLA,GKTOLA,TKTOLA,VTOLA,
     *                GDTOLB,GJTOLB,GKTOLB,TKTOLB,VTOLB,
     *                ECORL,EXCOR
      COMMON /METGGA/ NEEDTAU,PRTTAU
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SCFOPT/ CONVHF,MAXIT,MCONV,NPUNCH,NPREO(4)
C
      PARAMETER (HALF=0.5D+00)
C
      DIMENSION NLCT(*),NELM(*)
      DIMENSION TOTWT(NAT,*),COEFFA(L1,*),COEFFB(L1,*),VMOA(L1),
     *          DVMOXA(L1),DVMOYA(L1),DVMOZA(L1),VMOB(L1),DVMOXB(L1),
     *          DVMOYB(L1),DVMOZB(L1),VALGA(L1),VALGB(L1)
      DIMENSION NAPTS(NAT),IANGN(NAT,2,*),IIFACT(NAT),IFACTR(NAT)
      DIMENSION FA(*),FB(*),AOX(L1),GAOX(L1),GAOY(L1),GAOZ(L1),
     *          PTRAD(*),XDAT(NAT,MAXANG,*),YDAT(NAT,MAXANG,*),
     *          ZDAT(NAT,MAXANG,*),RSQRD(*),PCOEFF(*),
     *          ATMXVEC(NAT,NAT),ATMYVEC(NAT,NAT),ATMZVEC(NAT,NAT),
     *          ANGXVL(NAT,*),ANGYVL(NAT,*),ANGZVL(NAT,*),EXPS(*)
      DIMENSION IJX(84),IJY(84),IJZ(84)
      DATA DEBUG/8HDEBUG   /, DFTGRD/8HDERDFT  /
C
      LOGICAL LRDFLG,MLTINT,DOLRD
      COMMON /LRDISP/ ELRD6,ELRD8,ELRD10,EMULT,LRDFLG,MLTINT,DOLRD
      DIMENSION WTAB(NAT,NAT,*),ATMPOL(NAT,MAXL,MAXM,MAXM,NFREQ),
     *          ATPPOL(NAT,NAT,NFREQ),EFPOL(NAT),DRSPH(3,MAXL,MAXM)
C-END
C
C     IDENAO=0 MEANS REGULAR DFT
C     IDENAO=1 MEANS DIVIDE AND CONQUER DFT
C
      OUT = EXETYP.EQ.DFTGRD  .OR.  EXETYP.EQ.DEBUG
      RAD = BRAGGRAD(NCNTR)
      EXEC = ZERO
      ECORL1 = ZERO
      TOTGRADX = ZERO
      TOTGRADY = ZERO
      TOTGRADZ = ZERO
C                 LDA WILL NOT ASSIGN ANY VALUES TO DENSITY GRADIENTS
      GRDAA = ZERO
      GRDBB = ZERO
      GRDAB = ZERO
      NOA = NA
      NOB = NB
      NPT = NRAD*MAXANG
C
C     SET CUT-OFFS FOR THE DENSITY RCUTOFF AND WEIGHT WCUTOFF
C     RCUTOFF IS SET TO DEPEND UPON SCF DENSITY CONV. AND THE GRID SIZE
C     WCUTOFF IS A CELL VOLUME AND WE SET IT TO A FIXED VALUE.
C     MOST CELLS HAVE LARGE VOLUME (ABOUT 97% HAVE VOLUME .GT. 1E-14)
C
      DFTTHRS=DFTTHR
      IF(DFTTHR.EQ.ZERO) DFTTHR=1.0D-04/(NPT*NAT)
      WCUTOFF=1.0D-08/(NPT*NAT)
      RCUTOFF=CONVHF/(NPT*NAT)
      CCUTOFF=1.0D-03/(NPT*NAT)
      IF(DFTTHR.LT.1.1D-15) THEN
         WCUTOFF=1.0D-15
         RCUTOFF=1.0D-15
         CCUTOFF=1.0D-15
      ENDIF
C
C     ANGXVL=X**I, ANGYVL=Y**J, ANGZVL=Z**K, FOR NEEDED VALUES OF I,J,K
C     WHERE (X,Y,Z) IS THE CENTRE OF A DFT GRID POINT RI
C     MINUS AN ATOMIC CENTRE RA: XYZ= (RI - RA)
C
      CALL VCLR(ANGXVL(1,1),1,NAT)
      CALL VCLR(ANGYVL(1,1),1,NAT)
      CALL VCLR(ANGZVL(1,1),1,NAT)
      CALL DACOPY(NAT,ONE,ANGXVL(1,2),1)
      CALL DACOPY(NAT,ONE,ANGYVL(1,2),1)
      CALL DACOPY(NAT,ONE,ANGZVL(1,2),1)
C
C     ---- SYMMETRY MULTIPLICATION FACTOR ----
C
      FACT = IIFACT(NCNTR)*IFACTR(INC0)
C
C     NAPTS   + (NAT-1)/NWDVAR+1
C     DYNAMIC LOAD BALANCING: DIVIDE ALL POINTS INTO NGRAN*NPROC CHUNKS.
C     NGRAN CANNOT BE SET IN THE INPUT FILE. THEN EACH NODE GETS A CHUNK
C     AND TOILS IT OVER UNTIL READY TO ASK FOR MORE.
C
      LOOP=0
      NGRAN=20
      IF(NGRIDS.EQ.1) THEN
         NLOOP=NRAD*(IANGN(NCNTR,2,1)-IANGN(NCNTR,1,1)+1)
      ELSE
         NLOOP=NTOTGRIDPOINTS(NCNTR)
      ENDIF
      MCHUNK=(NLOOP-1)/(NGRAN*NPROC)+1
      NEXT  = -1
      DLB = IBTYP.EQ.1
C***********************************************************************
C     LOOP OVER RADIAL GRIDS
C     LOOP OVER ANGULAR GRIDS
C***********************************************************************
C STB MODIFIED FOR PRUNING
      IGRID = 1
      DO 20 IRADPT = 1, NRAD
C
        R1= RAD*PTRAD(IRADPT)
        IF(R1.GE.(PRUNERADS(IGRID,IPRUNECUTS(NCNTR))*RAD)) THEN
           IGRID = IGRID + 1
        ENDIF
        DO 10 IANGPT = IANGN(NCNTR,1,IGRID), IANGN(NCNTR,2,IGRID)
C         STB - FOR NOW THIS SHOULD BE OK AS I USED THE MAX ANGULAR
C               POINTS SO AS TO SIMPLIFY
          IPT=(IRADPT-1)*NAPTS(NCNTR)+IANGPT
C
          IF(GOPARR) THEN
            IF(DLB) THEN
              LOOP=LOOP+1
              ICHUNK=(LOOP-1)/MCHUNK
              IF(ICHUNK.GT.NEXT) THEN
                CALL DDI_DLBNEXT(NEXT)
              ENDIF
              IF(NEXT.NE.ICHUNK) GOTO 10
            ELSE
              IF(MOD(IPT,NPROC).NE.ME) GOTO 10
            ENDIF
          ENDIF
          IPTME=(IPT-1)/NPROC+1
          IF(DLB) IPTME=IPT
C
          FTOTWT = TOTWT(NCNTR,IPTME)*FACT
          IF(ABS(FTOTWT).LT.WCUTOFF) THEN
             GOTO 10
          ENDIF
C
          XD=R1*XDAT(NCNTR,IANGPT,IGRID)
          YD=R1*YDAT(NCNTR,IANGPT,IGRID)
          ZD=R1*ZDAT(NCNTR,IANGPT,IGRID)
          DO 610 IATM=1,NAT
            XCDNT=ATMXVEC(NCNTR,IATM)+XD
            YCDNT=ATMYVEC(NCNTR,IATM)+YD
            ZCDNT=ATMZVEC(NCNTR,IATM)+ZD
            RSQRD(IATM)=XCDNT**2+YCDNT**2+ZCDNT**2
            ANGXVL(IATM,3)=XCDNT
            ANGYVL(IATM,3)=YCDNT
            ANGZVL(IATM,3)=ZCDNT
            DO 35 IANG=3,NANG
               ANGXVL(IATM,IANG+1)=ANGXVL(IATM,IANG)*XCDNT
               ANGYVL(IATM,IANG+1)=ANGYVL(IATM,IANG)*YCDNT
               ANGZVL(IATM,IANG+1)=ANGZVL(IATM,IANG)*ZCDNT
 35         CONTINUE
  610     CONTINUE
          CALL DFTAO(IJX,IJY,IJZ,AOX,ANGXVL,ANGYVL,ANGZVL,PCOEFF,EXPS,
     *               RSQRD,NAT,L1)
C***********************************************************************
C     FORM DENSITY AT THIS POINT
C***********************************************************************
          IF(IDENAO.EQ.0) THEN
             CALL DFTTRFA(UROHF,L1,NOA,COEFFA,COEFFB,AOX,VMOA,VMOB,
     *                    CCUTOFF)
             ROA=DDOT(NOA,VMOA,1,VMOA,1)
             IF(UROHF) THEN
               ROB=DDOT(NOB,VMOB,1,VMOB,1)
             ELSE
               ROB=ROA
             ENDIF
          ELSE
             CALL DFTTRFDM(UROHF,L1,COEFFA,COEFFB,AOX,VMOA,VMOB,CCUTOFF,
     *                     NLCT,NELM)
             ROA=DDOT(L1,AOX,1,VMOA,1)
             IF(UROHF) THEN
                ROB=DDOT(L1,AOX,1,VMOB,1)
             ELSE
                ROA=ROA*HALF
                ROB=ROA
             END IF
C
C            FOR SOME REASON, DENSITY MIGHT BE NEGATIVE... (MK)
             IF(ROA.LT.ZERO) ROA=ZERO
             IF(ROB.LT.ZERO) ROB=ZERO
          END IF
          IF(ABS(ROA+ROB).LT.RCUTOFF) THEN
             GOTO 10
          ENDIF
C
          IF(NEEDGR) THEN
C***********************************************************************
C     FORM DENSITY GRADIENT AT THIS POINT
C***********************************************************************
            CALL DFTGAO(IJX,IJY,IJZ,GAOX,GAOY,GAOZ,ANGXVL,ANGYVL,ANGZVL,
     *                  PCOEFF,EXPS,RSQRD,NAT,L1)
            IF(IDENAO.EQ.0) THEN
              CALL DFTTRFG(UROHF,L1,NOA,COEFFA,COEFFB,GAOX,GAOY,GAOZ,
     *                     DVMOXA,DVMOYA,DVMOZA,DVMOXB,DVMOYB,DVMOZB,
     *                     CCUTOFF)
              GRADXA=TWO*DDOT(NOA,VMOA,1,DVMOXA,1)
              GRADYA=TWO*DDOT(NOA,VMOA,1,DVMOYA,1)
              GRADZA=TWO*DDOT(NOA,VMOA,1,DVMOZA,1)
              IF(UROHF) THEN
                GRADXB=TWO*DDOT(NOB,VMOB,1,DVMOXB,1)
                GRADYB=TWO*DDOT(NOB,VMOB,1,DVMOYB,1)
                GRADZB=TWO*DDOT(NOB,VMOB,1,DVMOZB,1)
              ELSE
                GRADXB=GRADXA
                GRADYB=GRADYA
                GRADZB=GRADZA
              ENDIF
            ELSE
               GRADXA=DDOT(L1,GAOX,1,VMOA,1)
               GRADYA=DDOT(L1,GAOY,1,VMOA,1)
               GRADZA=DDOT(L1,GAOZ,1,VMOA,1)
               IF(UROHF) THEN
                  GRADXA=GRADXA*TWO
                  GRADYA=GRADYA*TWO
                  GRADZA=GRADZA*TWO
                  GRADXB=DDOT(L1,GAOX,1,VMOB,1)*TWO
                  GRADYB=DDOT(L1,GAOY,1,VMOB,1)*TWO
                  GRADZB=DDOT(L1,GAOZ,1,VMOB,1)*TWO
               ELSE
                  GRADXB=GRADXA
                  GRADYB=GRADYA
                  GRADZB=GRADZA
               END IF
            END IF
C***********************************************************************
C      FORM GRADIENT INVARIANT (GRAD DOT GRAD)
C***********************************************************************
            GRDAA  = GRADXA*GRADXA+GRADYA*GRADYA+GRADZA*GRADZA
            GRDBB  = GRADXB*GRADXB+GRADYB*GRADYB+GRADZB*GRADZB
            GRDAB  = GRADXA*GRADXB+GRADYA*GRADYB+GRADZA*GRADZB
C
            IF(NEEDTAU) THEN
C***********************************************************************
C     FORM X, Y, Z COMPONENTS OF KINETIC DENISTY AT THIS POINT
C***********************************************************************
              IF(IDENAO.EQ.0) THEN
                TAUXA =DDOT(NOA,DVMOXA,1,DVMOXA,1)
                TAUYA =DDOT(NOA,DVMOYA,1,DVMOYA,1)
                TAUZA =DDOT(NOA,DVMOZA,1,DVMOZA,1)
                IF(UROHF) THEN
                  TAUXB =DDOT(NOB,DVMOXB,1,DVMOXB,1)
                  TAUYB =DDOT(NOB,DVMOYB,1,DVMOYB,1)
                  TAUZB =DDOT(NOB,DVMOZB,1,DVMOZB,1)
                ELSE
                  TAUXB =TAUXA
                  TAUYB =TAUYA
                  TAUZB =TAUZA
                ENDIF
              ELSE
                CALL DFTTRFDM(UROHF,L1,COEFFA,COEFFB,GAOX,DVMOXA,DVMOXB,
     *                        CCUTOFF,NLCT,NELM)
                CALL DFTTRFDM(UROHF,L1,COEFFA,COEFFB,GAOY,DVMOYA,DVMOYB,
     *                        CCUTOFF,NLCT,NELM)
                CALL DFTTRFDM(UROHF,L1,COEFFA,COEFFB,GAOZ,DVMOZA,DVMOZB,
     *                        CCUTOFF,NLCT,NELM)
                TAUXA=DDOT(L1,GAOX,1,DVMOXA,1)
                TAUYA=DDOT(L1,GAOY,1,DVMOYA,1)
                TAUZA=DDOT(L1,GAOZ,1,DVMOZA,1)
                IF(UROHF) THEN
                  TAUXB=DDOT(L1,GAOX,1,DVMOXB,1)
                  TAUYB=DDOT(L1,GAOY,1,DVMOYB,1)
                  TAUZB=DDOT(L1,GAOZ,1,DVMOZB,1)
                ELSE
                  TAUXA =TAUXA*HALF
                  TAUYA =TAUYA*HALF
                  TAUZA =TAUZA*HALF
                  TAUXB =TAUXA
                  TAUYB =TAUYA
                  TAUZB =TAUZA
                ENDIF
              ENDIF
C         THE FORMATION OF TAU# IS DONE WITHIN THE META-GGA FUNCTIONAL.
C         SPECIFICALLY, TAU# = (ONE/TWO)*(TAUX#+TAUY#+TAUZ#)
C         WHERE #=A (ALPHA) OR B (BETA)
C     ----- THE TOTAL KINETIC DENSITY -----
            TOTKIN=TOTKIN+FTOTWT*
     >                 (ONE/TWO)*(TAUXA+TAUYA+TAUZA+TAUXB+TAUYB+TAUZB)
            ENDIF
          ELSE
C
C     THIS ELSE CASE WILL ALLOW USERS TO PRINT OUT THE TOTAL KINETIC
C     ENERGY DENSITY FOR LDA TYPE FUNCTIONALS.
C     KEEP IN MIND THAT IF THE FUNCTIONAL DOES NOT CONTAIN A TAU
C     DEPENDENCE THEN ONE CAN NOT EXPECT THE TOTAL KINETIC ENERGY
C     DENSITY TO BE EXACTLY EQUAL TO THE EXPECTATION VALUE OF THE
C     KINETIC ENERGY OPERATOR.
C
            IF(NEEDTAU) THEN
C***********************************************************************
C     FORM X, Y, Z COMPONENTS OF KINETIC DENISTY AT THIS POINT
C***********************************************************************
              CALL DFTGAO(IJX,IJY,IJZ,GAOX,GAOY,GAOZ,ANGXVL,ANGYVL,
     *                    ANGZVL,PCOEFF,EXPS,RSQRD,NAT,L1)
              IF(IDENAO.EQ.0) THEN
                CALL DFTTRFG(UROHF,L1,NOA,COEFFA,COEFFB,GAOX,GAOY,GAOZ,
     *                       DVMOXA,DVMOYA,DVMOZA,DVMOXB,DVMOYB,DVMOZB,
     *                       CCUTOFF)
                TAUXA =DDOT(NOA,DVMOXA,1,DVMOXA,1)
                TAUYA =DDOT(NOA,DVMOYA,1,DVMOYA,1)
                TAUZA =DDOT(NOA,DVMOZA,1,DVMOZA,1)
                IF(UROHF) THEN
                  TAUXB =DDOT(NOB,DVMOXB,1,DVMOXB,1)
                  TAUYB =DDOT(NOB,DVMOYB,1,DVMOYB,1)
                  TAUZB =DDOT(NOB,DVMOZB,1,DVMOZB,1)
                ELSE
                  TAUXB =TAUXA
                  TAUYB =TAUYA
                  TAUZB =TAUZA
                ENDIF
              ELSE
                CALL DFTTRFDM(UROHF,L1,COEFFA,COEFFB,GAOX,DVMOXA,DVMOXB,
     *                        CCUTOFF,NLCT,NELM)
                CALL DFTTRFDM(UROHF,L1,COEFFA,COEFFB,GAOY,DVMOYA,DVMOYB,
     *                        CCUTOFF,NLCT,NELM)
                CALL DFTTRFDM(UROHF,L1,COEFFA,COEFFB,GAOZ,DVMOZA,DVMOZB,
     *                        CCUTOFF,NLCT,NELM)
                TAUXA=DDOT(L1,GAOX,1,DVMOXA,1)
                TAUYA=DDOT(L1,GAOY,1,DVMOYA,1)
                TAUZA=DDOT(L1,GAOZ,1,DVMOZA,1)
                IF(UROHF) THEN
                  TAUXB=DDOT(L1,GAOX,1,DVMOXB,1)
                  TAUYB=DDOT(L1,GAOY,1,DVMOYB,1)
                  TAUZB=DDOT(L1,GAOZ,1,DVMOZB,1)
                ELSE
                  TAUXA =TAUXA*HALF
                  TAUYA =TAUYA*HALF
                  TAUZA =TAUZA*HALF
                  TAUXB =TAUXA
                  TAUYB =TAUYA
                  TAUZB =TAUZA
                ENDIF
              ENDIF
C             THE FORMATION OF TAU# IS DONE WITHIN THE META-GGA FUNCT.
C             SPECIFICALLY, TAU# = (ONE/TWO)*(TAUX#+TAUY#+TAUZ#)
C             WHERE #=A (ALPHA) OR B (BETA)
C     ----- THE TOTAL KINETIC DENSITY -----
            TOTKIN=TOTKIN+FTOTWT*
     >                 (ONE/TWO)*(TAUXA+TAUYA+TAUZA+TAUXB+TAUYB+TAUZB)
            ENDIF
          ENDIF
C***********************************************************************
C     THE EXCHANGE-CORRELATION FUNCTIONAL CALCULATION
C***********************************************************************
          VXCA1=ZERO
          VXCB1=ZERO
          DUMAX=ZERO
          DUMAY=ZERO
          DUMAZ=ZERO
          DUMBX=ZERO
          DUMBY=ZERO
          DUMBZ=ZERO
          XALPHA=ZERO
          XGRD=ZERO
          ECF=ZERO
C
C         STORES THE DERIVATIVE OF THE FUNCTIONAL WITH RESPECT TO THE
C         KINETIC ENERGY DENSITY.
C         ALPHA SPIN
          DMGGA=ZERO
          DMGA =ZERO
C         BETA SPIN
          DMGGB=ZERO
          DMGB =ZERO
          IF(FUNCL) THEN
            CALL CCALCEXC(ROA,ROB,FTOTWT,GRDAA,GRDBB,GRDAB,
     >                    GRADXA,GRADYA,GRADZA,GRADXB,GRADYB,GRADZB,
     >                    XALPHA,XGRD,VXCA1,DUMAX,DUMAY,DUMAZ,
     >                    VXCB1,DUMBX,DUMBY,DUMBZ,ECF)
          ELSE IF(FUNFL) THEN
            CALL FCALCEXC(ROA,ROB,FTOTWT,GRDAA,GRDBB,GRDAB,
     >                    GRADXA,GRADYA,GRADZA,GRADXB,GRADYB,GRADZB,
     >                    XALPHA,XGRD,VXCA1,DUMAX,DUMAY,DUMAZ,
     >                    VXCB1,DUMBX,DUMBY,DUMBZ,ECF)
          ELSE
            CALL CALCEXC(ROA,ROB,FTOTWT,GRDAA,GRDBB,GRDAB,
     >                   GRADXA,GRADYA,GRADZA,GRADXB,GRADYB,GRADZB,
     >                   XALPHA,XGRD,VXCA1,DUMAX,DUMAY,DUMAZ,
     >                   VXCB1,DUMBX,DUMBY,DUMBZ,ECF,
     >                   TAUXA,TAUYA,TAUZA,DMGGA,
     >                   TAUXB,TAUYB,TAUZB,DMGGB)
          END IF
          DUMA = VXCA1
          DUMB = VXCB1
C
          DMGA = DMGGA
          DMGB = DMGGB
C
          EXEC1= XALPHA + XGRD + ECF
          EXEC = EXEC + EXEC1
          ECORL1= ECORL1 + ECF
          IF(NOB.EQ.0) THEN
             DUMB=ZERO
             GRADXB=ZERO
             GRADYB=ZERO
             GRADZB=ZERO
          ENDIF
C***********************************************************************
C      CONSTRUCT FOCK MATRIX
C***********************************************************************
          CALL DFTFOCK(NEEDGR,UROHF,FTOTWT,DUMA,DUMB,DUMAX,DUMAY,DUMAZ,
     *                 DUMBX,DUMBY,DUMBZ,VALGA,VALGB,AOX,GAOX,GAOY,GAOZ,
     *                 FA,FB,DFTTHR,L1,DMGA,DMGB)
C
C     ----- THE TOTAL ELECTRON DENSITY -----
C
          TOTELE  =  TOTELE+FTOTWT*(ROA+ROB)
          TOTGRADX=TOTGRADX+FTOTWT*GRDAA
          TOTGRADY=TOTGRADY+FTOTWT*GRDBB
          TOTGRADZ=TOTGRADZ+FTOTWT*GRDAB
C
          IF (DOLRD) THEN
            CALL LRDPOL(ATMPOL,ATPPOL,EFPOL,FTOTWT,WTAB,FACT,
     *                  NCNTR,IPTME,ROA,ROB,GRDAA,GRDBB,GRDAB,DRSPH,
     *                  XD,YD,ZD,MAXL,MAXM,NFREQ)
          END IF
C
   10   CONTINUE
C
C     ----- NEXT RADIAL POINT -----
C
   20 CONTINUE
C
C     ----- NEXT ATOM -----
C
      IF(GOPARR.AND.DLB) CALL DDI_DLBRESET
      EEXC = EEXC+EXEC
      ECORL= ECORL+ECORL1
      DFTTHR=DFTTHRS
      IF (OUT) WRITE(IW,9999) NCNTR,EEXC,TOTELE,TOTKIN
      RETURN
C
 9999 FORMAT(/5X,'ATM',I8,' EXC=',F20.10,5X,'TOTELE=',F20.10,'TOTKIN=',
     >        F20.10)
      END
C*MODULE DFTGRD  *DECK GLGQUD
C>    @brief Calculates the Gauss-Legendre quadrature
C
      SUBROUTINE GLGQUD(X1,X2,X,W,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (EPS =3.0D-14)
      PARAMETER (ZERO=0.0D+00)
      PARAMETER (ONE =1.0D+00)
      PARAMETER (TWO =2.0D+00)
      PARAMETER (FOUR=4.0D+00)
      PARAMETER (PT5 =0.5D+00)
      DIMENSION X(*),W(*)
C
      PI=FOUR*ATAN(ONE)
      NR=(N+1)/2
      XM=PT5*(X2+X1)
      XL=PT5*(X2-X1)
      PIN=(PI/TWO)/(2*N+1)
      DO I=1,NR
         Z=COS(PIN*(4*I-1))
    1    CONTINUE
            P1=ONE
            P2=ZERO
            DO J=1,N
               P3=P2
               P2=P1
               P1=((J+J-1)*Z*P2-(J-1)*P3)/J
            ENDDO
            PP=N*(Z*P1-P2)/(Z*Z-ONE)
            Z1=Z
            Z =Z1-P1/PP
            IF(ABS(Z-Z1).GT.EPS) GO TO 1
         X(    I)=XM+XL*Z
         X(N+1-I)=XM-XL*Z
         W(    I)=TWO*XL/((ONE-Z*Z)*PP*PP)
         W(N+1-I)=W(I)
      ENDDO
      RETURN
      END
C*MODULE DFTGRD  *DECK GRDDFT
C>    @brief Sets up grid for DFT
C>
C>    @details THIS PROGRAM UTILIZES AN ARBITRARY DENSITY TO CALCULATE
C>     THE CORRELATION CORRECTION TO SCF WITH AN ARBITRARY
C>     SET OF DENSITY FUNCTIONALS.
C>
C>     THE ORIGINAL PROGRAM WAS WRITTEN BY
C>     NEVIN OLIPHANT, QUANTUM THEORY PROJECT, UNIVERSITY OF FLORIDA
C>     HIDEO SEKINO, QUANTUM THEORY PROJECT, UNIVERSITY OF FLORIDA
C>     THIS ROUTINE CONSISTS OF 6 PARTS, THE LAST 5 ARE -ENTRY- POINTS
C>       1. MEMORY ALLOCATION
C>       2. GEOMETRY AND SYMMETRY SETTING                (DFTSET)
C>       3. CALCULATING EXCHANGE CORRELATION ENERGY      (DFTEXCOR)
C>       4. CALCULATING EXCHANGE CORRELATION GRADIENT    (DFTGRAD)
C>       5. TD-DFT EXCHANGE CORRELATION ENERGY           (MGRDMNG)
C>       6. TD-DFT EXCHANGE CORRELATION GRADIENT         (WGTGRAD)
C>
C>    @author MUNEAKI KAMIYA, TAKAO TSUNEDA, SUSUMU YANAGISAWA, DMITRI FEDOROV
C>
C>    @date : December 21, 2012 - Joe Ivanic
C>            Modify IJX,IJY,IJZ to have dimension 84 for h,i cartesians and 
C>            also include h,i cartesian power data in associated DATA statments
C
      SUBROUTINE GRDDFT(L2,LAST)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*10 XCHNG,CRRN,PFCHR
      CHARACTER*3 AGROUP
C
      LOGICAL UROHF,OPTGRD,GOPARR,DSKWRK,MASWRK,GPSAVE,DLB,
     *        NEEDGR,SAVEGRID,SVDSKW,ABELPT,GRDOUT,FIRST,SG1
C
C     ---- MEMORY ADDRESS -----
      SAVE ISTART,IPCOEFF,IEXPS,IWGHT,IXDAT,
     *     IYDAT,IZDAT,ITXYZ, IUXYZ,ITWGHT,
     *     IATMXVC,IATMYVC,IATMZVC,IRI,IRIJ,IWTINTR,IAOX,IGAOX,IGAOY,
     *     IGAOZ,ITOTWT,IRSQRD,IAIJ,IGLROOT,IGLWGHT,IANGXV,IANGYV,IANGZV
     *    ,IPTRAD,IWTRAD,IVMOA,IDVMOXA,IDVMOYA,IDVMOZA,IVALGA,IVMOB,
     *     IDVMOXB,IDVMOYB,IDVMOZB,IVALGB,IFACTR,INATM,IFACT,NAPTS,
     *     IANGN,INEQATM,INDEG,IUNIQUE
      SAVE ISYMXY,ISYMXZ,ISYMYZ,ISYMRX,ISYMRY,ISYMRZ,ISYMI,
     *     ISYMC1,NSYMAT,NANG,NDER,NEEDGR,NDFTEN,UROHF,FIRST
      SAVE INLCT,INELM
C
      SAVE IWTAB,IATMPOL,IATPPOL,IEFPOL,IDRSPH,
     *     ISMATC,ISMATP,IWIGD,ICOEF6,ICOEF8,ICOEF10,IATMPE,LRDMEM
      PARAMETER (MAXL=3,MAXM=7,MAXS=9,NFREQ=12)
C
      PARAMETER (MXATM=2000,MXGTOT=20000)
      PARAMETER (MXGRID=10,MXGRIDTYP=10)
      PARAMETER (ZERO=0.0D+00)
C
C        SET UP NAMELIST SIMULATION FOR UNDOCUMENTED $BRAGG INPUT GROUP
      PARAMETER (NNAM=1)
      DIMENSION QNAM(NNAM),KQNAM(NNAM)
      DIMENSION BRAGGINP(137)
      DATA BRAGGWD/8HBRAGG   /
      DATA  QNAM/8HBRAGG   /
      DATA KQNAM/1373/
C
      COMMON /DFGRID/ DFTTHR,DFTGTHR,SWOFF,SW0,BSLRD(137),NDFTFG,
     *                NRAD,NTHE,NPHI,NRAD0,NTHE0,NPHI0,
     *                NANGPT(MXGRID),NANGPT0(MXGRID),SG1,JANS
      COMMON /DFLEB/  NLEB(MXGRID),NLEB0(MXGRID)
      COMMON /DFPRUN/ PRUNERADS(MXGRID,MXGRIDTYP),
     *                PRUNEATOMS(2,MXGRIDTYP),
     *                IPRUNECUTS(MXATM),NTOTGRIDPOINTS(MXATM),
     *                NGRIDS,MAXANG,NGRIDTYPS
      COMMON /DFTEXC/ PI,CSLT,CB88,CLYP,CVWN,QOP,NEXFG,NCORFG,NPFFG,
     *                NXCFG
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /LMOEDA/ GDTOLA,GJTOLA,GKTOLA,TKTOLA,VTOLA,
     *                GDTOLB,GJTOLB,GKTOLB,TKTOLB,VTOLB,
     *                ECORL,EXCOR
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /MACHSW/ KDIAG,ICORFL,IXDR,MODIO
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      COMMON /ZANDAT/ ZANINP(MXATM)
C
      LOGICAL DCFLG
      COMMON /DCOPT / SUBTYP,BUFTYP,SUBLNG,BUFRAD,NDCPRT,NSUBS,DCFLG
      COMMON /DNSAO / IDENAO
C
      LOGICAL LRDFLG,MLTINT,DOLRD
      COMMON /LRDISP/ ELRD6,ELRD8,ELRD10,EMULT,LRDFLG,MLTINT,DOLRD
C
C         THE ADJUSTABLE ARRAYS IN THE NEXT STATEMENT ARE USED ONLY
C         BY THE VARIOUS ENTRY POINTS, WHERE THEY ARE CALLING ARGS.
      DIMENSION X(1),FA(1),FB(1),DA(1),DB(1),COEFFA(1),COEFFB(1),
     *          G2AXX(1),G2AYY(1),G2AZZ(1),G2AXY(1),G2AYZ(1),G2AXZ(1),
     *          DEDFT(1),UVEC(1),DWTINT(1),DWTTOT(1),DTOTWT(1)
C
      DIMENSION IJX(84),IJY(84),IJZ(84),GMSBSLRD(137)
      INTEGER SG1ATOMS(2,4),SG1GRIDS(5),JANSATOMS(2,4),JANSGRIDS(5,2)
      DIMENSION SG1RADS(5,4),SG1BSLRD(137),JANSRADS(5,4)
C
      DATA FIRST/.TRUE./
      DATA UHF,ROHF/8HUHF     ,8HROHF    /
C***********************************************************************
C     BRAGG-SLATER RADII FOR DETERMINING THE RELATIVE SIZE OF THE
C     POLYHEDRA IN THE POLYATOMIC INTEGRATION SCHEME
C***********************************************************************
C     THESE NUMBERS CAN BE FOUND AT THE START OF CHAPTER 3 OF
C         QUANTUM THEORY OF MOLECULES AND SOLIDS, VOLUME 2
C                       J.C.SLATER
C     EXCEPT THAT HYDROGEN IS CHANGED FROM 0.25 -> BOHR RADIUS,
C     AND MISSING VALUES SUCH AS INERT GASSES ARE FILLED IN WITH
C     REASONABLE LOOKING DATA (SOURCE UNKNOWN).  SLATER'S TABLE
C     STOPS AT THE ELEMENT AMERICIUM, THE EXTENSION IS PROBABLY
C     REASONABLE FOR ACTINIDES BUT NOT ALL THE WAY TO Z=137!
C
      DATA (GMSBSLRD(III),III=1,10)/
     *          0.52917D+00, 0.31D+00,
     *             1.45D+00, 1.05D+00,
     *   0.85D+00, 0.70D+00, 0.65D+00, 0.60D+00, 0.50D+00, 0.38D+00/
      DATA (GMSBSLRD(III),III=11,18)/
     *             1.80D+00, 1.50D+00,
     *   1.25D+00, 1.10D+00, 1.00D+00, 1.00D+00, 1.00D+00, 0.71D+00/
      DATA (GMSBSLRD(III),III=19,36)/
     *             2.20D+00, 1.80D+00,
     *             1.60D+00, 1.40D+00, 1.35D+00, 1.40D+00, 1.40D+00,
     *             1.40D+00, 1.35D+00, 1.35D+00, 1.35D+00, 1.35D+00,
     *   1.30D+00, 1.25D+00, 1.15D+00, 1.15D+00, 1.15D+00, 0.88D+00/
      DATA (GMSBSLRD(III),III=37,54)/
     *             2.35D+00, 2.00D+00,
     *             1.80D+00, 1.55D+00, 1.45D+00, 1.45D+00, 1.35D+00,
     *             1.30D+00, 1.35D+00, 1.40D+00, 1.60D+00, 1.55D+00,
     *   1.55D+00, 1.45D+00, 1.45D+00, 1.40D+00, 1.40D+00, 1.08D+00/
      DATA (GMSBSLRD(III),III=55,86)/
     *             2.60D+00, 2.15D+00,
     *             1.95D+00, 1.85D+00, 1.85D+00, 1.85D+00, 1.85D+00,
     *             1.85D+00, 1.85D+00, 1.80D+00, 1.75D+00, 1.75D+00,
     *             1.75D+00, 1.75D+00, 1.75D+00, 1.75D+00, 1.75D+00,
     *             1.55D+00, 1.45D+00, 1.35D+00, 1.35D+00, 1.30D+00,
     *             1.35D+00, 1.35D+00, 1.35D+00, 1.50D+00,
     *   1.90D+00, 1.80D+00, 1.60D+00, 1.90D+00, 1.27D+00, 1.20D+00/
      DATA (GMSBSLRD(III),III=87,94)/
     *             2.60D+00, 2.15D+00,
     *             1.95D+00, 1.80D+00,
     *             1.75D+00, 1.75D+00, 1.75D+00, 1.75D+00/
C        AND WE JUST FILL IN ALL THE OTHER ELEMENTS WITH A GUESS.
      DATA (GMSBSLRD(III),III=95,137)/43*1.75D+00/
C
      DATA IJX    / 1, 2, 1, 1, 3, 1, 1, 2, 2, 1,
     1              4, 1, 1, 3, 3, 2, 1, 2, 1, 2,
     2              5, 1, 1, 4, 4, 2, 1, 2, 1, 3,
     3              3, 1, 3, 2, 2,
     4              6, 1, 1, 5, 5, 2, 1, 2, 1, 4,
     5              4, 3, 1, 3, 1, 4, 2, 2, 3, 3,
     6              2,
     7              7, 1, 1, 6, 6, 2, 1, 2, 1, 5,
     8              5, 3, 1, 3, 1, 5, 2, 2, 4, 4,
     9              1, 4, 4, 3, 2, 3, 2, 3/

      DATA IJY    / 1, 1, 2, 1, 1, 3, 1, 2, 1, 2,
     1              1, 4, 1, 2, 1, 3, 3, 1, 2, 2,
     2              1, 5, 1, 2, 1, 4, 4, 1, 2, 3,
     3              1, 3, 2, 3, 2,
     4              1, 6, 1, 2, 1, 5, 5, 1, 2, 3,
     5              1, 4, 4, 1, 3, 2, 4, 2, 3, 2,
     6              3,
     7              1, 7, 1, 2, 1, 6, 6, 1, 2, 3,
     8              1, 5, 5, 1, 3, 2, 5, 2, 4, 1,
     9              4, 3, 2, 4, 4, 2, 3, 3/

      DATA IJZ    / 1, 1, 1, 2, 1, 1, 3, 1, 2, 2,
     1              1, 1, 4, 1, 2, 1, 2, 3, 3, 2,
     2              1, 1, 5, 1, 2, 1, 2, 4, 4, 1,
     3              3, 3, 2, 2, 3,
     4              1, 1, 6, 1, 2, 1, 2, 5, 5, 1,
     5              3, 1, 3, 4, 4, 2, 2, 4, 2, 3,
     6              3,
     7              1, 1, 7, 1, 2, 1, 2, 6, 6, 1,
     8              3, 1, 3, 5, 5, 2, 2, 5, 1, 4,
     9              4, 2, 3, 2, 3, 4, 4, 3/
C
C     THESE ARE THE TABULATED VALUES FOR THE SG-1 GRID PUBLISHED
C     IN GILL ET AL., CPL,209, 506 (1993).
      DATA SG1BSLRD /0.52918D+00, 0.31126D+00, 1.62822D+00, 1.08550D+00,
     *               0.81414D+00, 0.65131D+00, 0.54272D+00, 0.46520D+00,
     *               0.40704D+00, 0.36185D+00, 2.16481D+00, 1.67109D+00,
     *               1.36073D+00, 1.14763D+00, 0.99221D+00, 0.87388D+00,
     *               0.78075D+00, 0.70555D+00, 2.20D+00,    1.80D+00,
     *               1.60D+00, 1.40D+00, 1.35D+00, 1.40D+00, 1.40D+00,
     *               1.40D+00, 1.35D+00, 1.35D+00, 1.35D+00, 1.35D+00,
     *               1.30D+00, 1.25D+00, 1.15D+00, 1.15D+00, 1.15D+00,
     *               0.88D+00, 2.35D+00, 2.00D+00, 1.80D+00, 1.55D+00,
     *               1.45D+00, 1.45D+00, 1.35D+00, 1.30D+00, 1.35D+00,
     *               1.40D+00, 1.60D+00, 1.55D+00, 1.55D+00, 1.45D+00,
     *               1.45D+00, 1.40D+00, 1.40D+00, 1.08D+00, 2.60D+00,
     *               2.15D+00, 1.95D+00, 1.85D+00, 1.85D+00, 1.85D+00,
     *               1.85D+00, 1.85D+00, 1.85D+00, 1.80D+00, 1.75D+00,
     *               1.75D+00, 1.75D+00, 1.75D+00, 1.75D+00, 1.75D+00,
     *               1.75D+00, 1.55D+00, 1.45D+00, 1.35D+00, 1.35D+00,
     *               1.30D+00, 1.35D+00, 1.35D+00, 1.35D+00, 1.50D+00,
     *               1.90D+00, 1.80D+00, 1.60D+00, 1.90D+00, 1.27D+00,
     *               1.20D+00, 2.60D+00, 2.15D+00, 1.95D+00, 1.80D+00,
     *               1.75D+00, 1.75D+00, 1.75D+00, 1.75D+00, 1.75D+00,
     *               1.75D+00, 1.75D+00, 1.75D+00, 1.75D+00, 1.75D+00,
     *               1.75D+00, 1.75D+00, 1.75D+00, 1.75D+00, 1.75D+00,
     *               1.75D+00, 1.75D+00, 1.75D+00, 1.75D+00, 1.75D+00,
     *               1.75D+00, 1.75D+00, 1.75D+00, 1.75D+00, 1.75D+00,
     *               1.75D+00, 1.75D+00, 1.75D+00, 1.75D+00, 1.75D+00,
     *               1.75D+00, 1.75D+00, 1.75D+00, 1.75D+00, 1.75D+00,
     *               1.75D+00, 1.75D+00, 1.75D+00, 1.75D+00, 1.75D+00,
     *               1.75D+00, 1.75D+00, 1.75D+00, 1.75D+00, 1.75D+00,
     *               1.75D+00, 1.75D+00/
      DATA SG1ATOMS  / 1,2,
     *                 3,10,
     *                11,18,
     *                19,137/
      DATA SG1RADS  / 0.2500D0, 0.500D0, 1.0D00, 4.50D0, 9999999.9D0,
     *                0.1667D0, 0.500D0, 0.90D0, 3.50D0, 9999999.9D0,
     *                0.1000D0, 0.400D0, 0.80D0, 2.5D0,  9999999.9D0,
     *         1.0E-30, 999999.9D0, 999999.9D0, 999999.9D0, 999999.9D0/
C
      DATA SG1GRIDS / 6, 38, 86, 194, 86 /
C
C     THESE ARE THE TABULATED VALUES FOR PRUNED GRIDS DEVELOPED
C     BY CURTIS JANSSEN FROM SANDIA NATIONAL LABS, AND DERIVED
C     FROM THE MPQC CODE, FREELY AVAILABLE AT HTTP://WWW.MPQC.ORG
C
C     THIS IS A FIRST IMPLEMENTATION OF THESE GRIDS, AND GAMESS HAS
C     A FEW LIMITATIONS, SO ONLY A SUBSET OF THESE GRIDS WILL BE
C     IMPLEMENTED HERE, WITH THE FULL GRIDS TO BE IMPLEMENTED IN THE
C     FUTURE :
C       1) TWO OF THE GRIDS WILL BE IMPLEMENTED WITH 110 AND 155 RADIAL
C          SHELLS, WHICH IS THE NUMBER OF RADIAL SHELLS FOR SECOND ROW
C          ATOMS.
C       2) THE GRIDS HERE SLIGHTLY DIFFER AT THE MOMENT FROM THE GRIDS
C          IN MPQC AS I AM ONLY USING THE MAXIMUM GRID POINT SET FOR
C          EACH ATOM, TO SIMPLIFY THINGS.
C       3) THIRD ROW AND BEYOND ARE NOT PROPERLY IMPLEMENTED AT THE
C          MOMENT, TO IMPLEMENT THIS WE NEED TO LET EACH ATOM HAVE
C          ITS OWN GRID, WHICH REQUIRES QUITE A REWRITE OF THE CODE.
C
      DATA JANSATOMS  / 1,2,
     *                  3,10,
     *                  11,18,
     *                  19,137/
C
      DATA JANSRADS / 0.2500D0, 0.500D0, 0.9D00, 4.50D0, 9999999.9D0,
     *                0.1667D0, 0.500D0, 0.80D0, 3.50D0, 9999999.9D0,
     *                0.1000D0, 0.400D0, 0.70D0, 2.5D0,  9999999.9D0,
     *          1.0E-30, 999999.9D0, 999999.9D0, 999999.9D0, 999999.9D0/
C
C
      DATA JANSGRIDS / 6,86,170,434,170,
     *                 86,194,590,974,590/
C
C
      UROHF = SCFTYP.EQ.UHF  .OR.  SCFTYP.EQ.ROHF
C
C     FOR SLATER EXHANGE AND LDA OR NO CORRELATION DO NOT NEED
C     TO HANDLE THE GRADIENT TERMS
C
      NEEDGR=.NOT.(NEXFG.EQ.1.AND.(NCORFG.EQ.0.OR.NCORFG.EQ.1))
      PI=ATAN(1.0D+00)*4.0D+00
C
C     ===================
C     GET GRID DFT MEMORY
C     ===================
C     IN THE FOLLOWING, ARRAYS ARE ALLOCATED AS NAT, WHEREAS SOME ARE
C     IN FACT USED AS NSYMAT. THIS MAY SAVE MEMORY BUT REQUIRES SMALL
C     CHANGES IN THE CODE.
C
      DLB = IBTYP.EQ.1
C
      IF(SG1) THEN
         NRAD = 50
         NGRIDS = 5
         MAXANG = 194
         NGRIDTYPS = 4
         DO I = 1,137
            BSLRD(I) = SG1BSLRD(I)
         ENDDO
C        DEFINE THE ANGULAR GRIDS AVAILABLE
         DO IGRID = 1,NGRIDS
            NLEB(IGRID) = SG1GRIDS(IGRID)
         ENDDO
C        FILL IN SOME GENERIC DATA
         DO ITYPE = 1,NGRIDTYPS
            PRUNEATOMS(1,ITYPE) = SG1ATOMS(1,ITYPE)
            PRUNEATOMS(2,ITYPE) = SG1ATOMS(2,ITYPE)
            DO IGRID = 1,NGRIDS
               PRUNERADS(IGRID,ITYPE) = SG1RADS(IGRID,ITYPE)
            ENDDO
         ENDDO
C        DEFINE WHICH SET OF RADII TO MEASURE THE ATOM BY
         DO IATM = 1,NAT
            ZNUC = ABS(ZANINP(IATM))
            NUCZ = INT(ZNUC + 0.001D+00)
C               sparkles/bond functions to be ignored:
            IF(ABS(ZNUC-NUCZ).GT.0.00001D+00) ZNUC = 0.0D+00
            IF(NFG.NE.0) ZNUC=IAN(IATM)
            DO ITYPE = 1,NGRIDTYPS
C               WRITE(IW,*)'ZAN,PA: ',ZNUC,PRUNEATOMS(1,ITYPE),
C     *              PRUNEATOMS(2,ITYPE)
               IF((ZNUC.GE.PRUNEATOMS(1,ITYPE)).AND.
     *            (ZNUC.LE.PRUNEATOMS(2,ITYPE))) THEN
                  IPRUNECUTS(IATM) = ITYPE
                  GOTO 11111
               ENDIF
            ENDDO
11111       CONTINUE
         ENDDO
         NPT = NRAD*MAXANG
      ELSE IF(JANS.GT.0) THEN
         IF(JANS.EQ.1) THEN
            NRAD = 95
            MAXANG = 434
            NGRIDS = 5
         ELSE IF(JANS.GE.2) THEN
            NRAD = 155
            MAXANG = 974
            NGRIDS = 5
            JANS=2
         ENDIF
         NGRIDTYPS = 4
         DO I = 1,137
            BSLRD(I) = SG1BSLRD(I)
         ENDDO
C        DEFINE THE ANGULAR GRIDS AVAILABLE
         DO IGRID = 1,NGRIDS
            NLEB(IGRID) = JANSGRIDS(IGRID,JANS)
C            WRITE(IW,*)'NLEB(',IGRID,') = ',NLEB(IGRID)
         ENDDO
C        FILL IN SOME GENERIC DATA
         DO ITYPE = 1,NGRIDTYPS
            PRUNEATOMS(1,ITYPE) = JANSATOMS(1,ITYPE)
            PRUNEATOMS(2,ITYPE) = JANSATOMS(2,ITYPE)
            DO IGRID = 1,NGRIDS
               PRUNERADS(IGRID,ITYPE) = JANSRADS(IGRID,ITYPE)
C               WRITE(IW,*)'PRUNERADS = ',ITYPE,IGRID,
C     *                   PRUNERADS(IGRID,ITYPE)
            ENDDO
         ENDDO
C        DEFINE WHICH SET OF RADII TO MEASURE THE ATOM BY
         DO IATM = 1,NAT
            ZNUC = ABS(ZANINP(IATM))
            NUCZ = INT(ZNUC + 0.001D+00)
C               sparkles/bond functions to be ignored:
            IF(ABS(ZNUC-NUCZ).GT.0.00001D+00) ZNUC = 0.0D+00
            IF(NFG.NE.0) ZNUC=IAN(IATM)
            DO ITYPE = 1,NGRIDTYPS
C               WRITE(IW,*)'ZAN,PA: ',ZNUC,PRUNEATOMS(1,ITYPE),
C     *              PRUNEATOMS(2,ITYPE)
               IF((ZNUC.GE.PRUNEATOMS(1,ITYPE)).AND.
     *            (ZNUC.LE.PRUNEATOMS(2,ITYPE))) THEN
                  IPRUNECUTS(IATM) = ITYPE
                  GOTO 11112
               ENDIF
            ENDDO
11112       CONTINUE
         ENDDO
         NPT = NRAD*MAXANG
      ELSE
C
C            UNDOCUMENTED $BRAGG GROUP TO READ IN BRAGG/SLATER RADII.
C
         CALL NAMEIO(IR,JRET,BRAGGWD,NNAM,QNAM,KQNAM,
     *               BRAGGINP,   0,0,0,
     *   0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,
     *   0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,
     *   0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0)
         IF (JRET.EQ.2) THEN
            IF(MASWRK) WRITE(IW,*) 'ERROR IN $BRAGG INPUT'
            CALL ABRT
         END IF
         IF (JRET.EQ.0) THEN
            DO I=1,137
               IF(BRAGGINP(I).GT.ZERO) THEN
                  GMSBSLRD(I) = BRAGGINP(I)
                  SG1BSLRD(I) = BRAGGINP(I)
               END IF
            END DO
         END IF
C
         NGRIDS = 1
         IF(NLEB(1).EQ.0) THEN
            DO I = 1,137
               BSLRD(I) = GMSBSLRD(I)
            ENDDO
            NANGPT(1) = NTHE*NPHI
            NANGPT0(1) = NTHE0*NPHI0
         ELSE
            DO I = 1,137
               BSLRD(I) = SG1BSLRD(I)
            ENDDO
            NANGPT(1)  = NLEB(1)
            NANGPT0(1) = NLEB0(1)
         ENDIF
         PRUNERADS(1,1) = 1.0D+30
         DO IATM = 1,NAT
            IPRUNECUTS(IATM) = 1
         ENDDO
         MAXANG = NANGPT(1)
      ENDIF
C
C     TOTWT CANNOT BE DIVIDED FOR DYNAMIC LOAD BALANCING SINCE WEIGHTS
C     WILL BE REQUIRED AT "RANDOM" (DDI ARRAYS MAY WORK).
C
      NPT = NRAD*MAXANG
      NPTME=(NPT-1)/NPROC+1
      IF(DLB) NPTME=NPT
C
      CALL BASCHK(MAXLL)
      CALL DERCHK(NDER)
      NANG=MAXLL+1+1
C     1 FOR GRADIENT TERMS
      NANG1=NANG+1+NDER
C
C     ----- FOR ROUTINE INPBAS -----
C
      IPCOEFF = 1
      IEXPS   = IPCOEFF + MXGTOT
      ISTART  = IEXPS   + MXGTOT
C
      INDEG   = ISTART
      INEQATM = INDEG   + (NAT-1)/NWDVAR+1
      IUNIQUE = INEQATM + (NAT*NAT-1)/NWDVAR+1
      ISTART  = IUNIQUE + (NAT-1)/NWDVAR+1
C
C     ----- FOR ROUTINE GRDPT -----
C
C     SPECIAL MEMORY ALLOCATION FOR PRUNED GRIDS
C
      IF(NGRIDS.GT.1) THEN
         IWGHT   = ISTART
         IXDAT   = IWGHT + MAXANG*NAT*NGRIDS
         IYDAT   = IXDAT + MAXANG*NAT*NGRIDS
         IZDAT   = IYDAT + MAXANG*NAT*NGRIDS
         IUXYZ   = IZDAT + MAXANG*NAT*NGRIDS
         ITXYZ   = IUXYZ   + 3*MAXANG
         ITWGHT  = ITXYZ   + 3*MAXANG
         IATMXVC = ITWGHT  + MAXANG
         IATMYVC = IATMXVC + NAT*NAT
         IATMZVC = IATMYVC + NAT*NAT
         IRI     = IATMZVC + NAT*NAT
         IRIJ    = IRI     + NAT
         IWTINTR = IRIJ    + NAT*NAT
         IRSQRD  = IWTINTR + NAT
         IAIJ    = IRSQRD  + NAT
         IGLROOT = IAIJ    + NAT*NAT
         IGLWGHT = IGLROOT + MAXANG
         IPTRAD  = IGLWGHT + NTHE*NTHE
         IWTRAD  = IPTRAD  + NRAD
         IANGXV  = IWTRAD  + NRAD
         IANGYV  = IANGXV  + NAT*NANG1
         IANGZV  = IANGYV  + NAT*NANG1
         IFACTR  = IANGZV  + NAT*NANG1
         INATM   = IFACTR  + (NAT-1)/NWDVAR+1
         IFACT   = INATM   + (NAT-1)/NWDVAR+1
         NAPTS   = IFACT   + (NAT-1)/NWDVAR+1
         IANGN   = NAPTS   + (NAT-1)/NWDVAR+1
         LAST    = IANGN   + ((NAT*2-1)/NWDVAR+1)*NGRIDS
C     WRITE(IW,"(A,6I10)")'MEMORY: ',IWGHT,IXDAT,IYDAT,IZDAT,IUXYZ,
C     *                                  ITXYZ
C     WRITE(IW,"(A,6I10)")'MEMORY: ',ITWGHT,IATMXVC,IATMYVC,IATMZVC
C     *                                 ,IRI,IRIJ
      ELSE
         IF(NLEB(1).NE.0) THEN
            IWGHT   = ISTART
            IXDAT   = IWGHT   + NANGPT(1)*NAT
            IYDAT   = IXDAT   + NANGPT(1)*NAT
            IZDAT   = IYDAT   + NANGPT(1)*NAT
            IUXYZ   = IZDAT   + NANGPT(1)*NAT
            ITXYZ   = IUXYZ   + 3*NANGPT(1)
            ITWGHT  = ITXYZ   + 3*NANGPT(1)
            IATMXVC = ITWGHT  + NANGPT(1)
            IATMYVC = IATMXVC + NAT*NAT
            IATMZVC = IATMYVC + NAT*NAT
            IRI     = IATMZVC + NAT*NAT
            IRIJ    = IRI     + NAT
            IWTINTR = IRIJ    + NAT*NAT
            IRSQRD  = IWTINTR + NAT
            IAIJ    = IRSQRD  + NAT
            IPTRAD  = IAIJ    + NAT*NAT
            IWTRAD  = IPTRAD  + NRAD
            IANGXV  = IWTRAD  + NRAD
            IANGYV  = IANGXV  + NAT*NANG1
            IANGZV  = IANGYV  + NAT*NANG1
            IFACTR  = IANGZV  + NAT*NANG1
            INATM   = IFACTR  + (NAT-1)/NWDVAR+1
            IFACT   = INATM   + (NAT-1)/NWDVAR+1
            NAPTS   = IFACT   + (NAT-1)/NWDVAR+1
            IANGN   = NAPTS   + (NAT-1)/NWDVAR+1
            LAST    = IANGN   + (NAT*2-1)/NWDVAR+1
C
         ELSE
            IWGHT   = ISTART
            IXDAT   = IWGHT   + NANGPT(1)*NAT
            IYDAT  =  IXDAT   + NANGPT(1)*NAT
            IZDAT   = IYDAT   + NANGPT(1)*NAT
            IATMXVC = IZDAT   + NANGPT(1)*NAT
            IATMYVC = IATMXVC + NAT*NAT
            IATMZVC = IATMYVC + NAT*NAT
            IRI     = IATMZVC + NAT*NAT
            IRIJ    = IRI     + NAT
            IWTINTR = IRIJ    + NAT*NAT
            IRSQRD  = IWTINTR + NAT
            IAIJ    = IRSQRD  + NAT
            IGLROOT = IAIJ    + NAT*NAT
            IGLWGHT = IGLROOT + NTHE*NTHE
            IPTRAD  = IGLWGHT + NTHE*NTHE
            IWTRAD  = IPTRAD  + NRAD
            IANGXV  = IWTRAD  + NRAD
            IANGYV  = IANGXV  + NAT*NANG1
            IANGZV  = IANGYV  + NAT*NANG1
            IFACTR  = IANGZV  + NAT*NANG1
            INATM   = IFACTR  + (NAT-1)/NWDVAR+1
            IFACT   = INATM   + (NAT-1)/NWDVAR+1
            NAPTS   = IFACT   + (NAT-1)/NWDVAR+1
            IANGN   = NAPTS   + (NAT-1)/NWDVAR+1
            LAST    = IANGN   + (NAT*2-1)/NWDVAR+1
         ENDIF
      ENDIF
C
C     ----- FOR ROUTINE DMATD ------
C
      IVMOA  = LAST
      IDVMOXA= IVMOA  + NUM
      IDVMOYA= IDVMOXA+ NUM
      IDVMOZA= IDVMOYA+ NUM
      IVMOB  = IDVMOZA+ NUM
      IDVMOXB= IVMOB  + NUM
      IDVMOYB= IDVMOXB+ NUM
      IDVMOZB= IDVMOYB+ NUM
      IVALGA = IDVMOZB+ NUM
      IVALGB = IVALGA + NUM
      LAST   = IVALGB + NUM
C
      ITOTWT  = LAST
      IAOX    = ITOTWT  + NAT*NPTME
      IGAOX   = IAOX    + NUM
      IGAOY   = IGAOX   + NUM
      IGAOZ   = IGAOY   + NUM
      LAST    = IGAOZ   + NUM
C
      INLCT   = LAST
      INELM   = LAST
      IF(IDENAO.NE.0) THEN
        INELM = INLCT + NUM*NUM
        LAST  = INELM + NUM*2
      END IF
C
C     FOR LOCAL RESPONSE DISPERSION METHOD
C
      IF(LRDFLG) THEN
         IWTAB   = LAST
         IATMPOL = IWTAB   + NAT*NAT*NPTME
         IATPPOL = IATMPOL + NAT*MAXL*MAXM*MAXM*NFREQ
         IEFPOL  = IATPPOL + NAT*NAT*NFREQ
         IDRSPH  = IEFPOL  + NAT
         ISMATC  = IDRSPH  + 3*MAXL*MAXM
         ISMATP  = ISMATC  + MAXS*MAXS
         IWIGD   = ISMATP  + MAXS*MAXS
         ICOEF6  = IWIGD   + MAXS
         ICOEF8  = ICOEF6  + NAT*(NAT+1)/2
         ICOEF10 = ICOEF8  + NAT*(NAT+1)/2
         IATMPE  = ICOEF10 + NAT*(NAT+1)/2
         LAST    = IATMPE  + NAT*(NAT+1)/2
         LRDMEM  = LAST    - IATMPOL
      ELSE
         IWTAB   = LAST
         IATMPOL = LAST
         IATPPOL = LAST
         IEFPOL  = LAST
         IDRSPH  = LAST
         ISMATC  = LAST
         ISMATP  = LAST
         IWIGD   = LAST
         ICOEF6  = LAST
         ICOEF8  = LAST
         ICOEF10 = LAST
         IATMPE  = LAST
         LAST    = LAST
         LRDMEM  = 0
      END IF
C
      NDFTEN=LAST
      RETURN
C
C     ===========================
      ENTRY DFTSET(X,NPRT,OPTGRD)
C     ===========================
C     GEOMETRY AND SYMMETRY SETTING.
C
      DLB = IBTYP.EQ.1
C
      NFTDFT=22
      IF(OPTGRD) THEN
C
C       ISYMC1 WILL HAVE BEEN SET DURING A PRECEDING ENERGY CALCULATION
C       FTNCHEK WILL GIVE A WARNING, DON'T ATTEMPT TO FIX IT!  IT IS OK.
C
        SAVEGRID=ISYMC1.EQ.1.AND.NDER.GT.0.AND.IAND(MODIO,8).EQ.0
        IF(SAVEGRID) THEN
          SVDSKW=DSKWRK
          DSKWRK=.TRUE.
          CALL SEQOPN(NFTDFT,'DFTGRID','UNKNOWN',.FALSE.,'UNFORMATTED')
          READ(NFTDFT) (X(I),I=1,NDFTEN)
          CALL SEQCLO(NFTDFT,'KEEP')
          DSKWRK=SVDSKW
          RETURN
C         READ THE GRID AND RETURN
        ENDIF
      ENDIF
C
C     WRITE FUNCTIONAL NAME AND OTHER INFO, ON FIRST ENTRANCE
C
      NPT=NRAD*MAXANG
      IF(FIRST  .AND.  NPRT.NE.0  .AND.  MASWRK) THEN
        FIRST=.FALSE.
        IF(NDFTFG.EQ.0) THEN
           XCHNG='HFX       '
           CRRN ='NONE      '
        ELSE
           CALL RNAMEXC(XCHNG,CRRN)
        END IF
        WRITE(IW,1010) XCHNG
        WRITE(IW,1020) CRRN
        IF (NEXFG.EQ.6) THEN
          CALL REFPFREE (PFCHR)
          WRITE(IW,1030) PFCHR
        ENDIF
        DFTTHR0=1.0D-03/(NPT*NAT)
        IF(DFTTHR.NE.ZERO) DFTTHR0=DFTTHR
        IF(DFTTHR0.LT.1.1D-15) THEN
          WRITE(IW,1060)
        ELSE
          WRITE(IW,1040) DFTTHR0
        ENDIF
        IF(NGRIDS.EQ.1) THEN
           IF(NRAD*NANGPT(1).NE.NRAD0*NANGPT0(1)) WRITE(IW,1050) SW0
        ENDIF
C          COARSE/FINE GRID WITCHING INTERCHANGES THESE TWO VARIABLES
        NRADPTS=MAX(NRAD,NRAD0)
        CALL CHKRGRID(NRADPTS)
      ENDIF
 1010 FORMAT(/5X,'EXCHANGE FUNCTIONAL   =',A10)
 1020 FORMAT(5X, 'CORRELATION FUNCTIONAL=',A10)
 1030 FORMAT(5X, 'KINETIC FUNCTIONAL    =',A10)
 1040 FORMAT(5X, 'DFT THRESHOLD         =',E8.3)
 1050 FORMAT(5X, 'GRID CHANGE THRESHOLD =',E8.3)
 1060 FORMAT(5X, 'ALL DFT THRESHOLDS ARE TURNED OFF.')
 1070 FORMAT(5X, 'USING ',A3,' ABELIAN SUBGROUP FOR OCTANTS,',
     *           ' AND FULL SYMMETRY FOR ATOMS.'/)
 1075 FORMAT(5X, 'USING FULL ABELIAN GROUP SYMMETRY',
     *           ' FOR BOTH ATOMS AND OCTANTS.'/)
 1080 FORMAT(5X, 'USING FULL SYMMETRY FOR ATOMS,',
     *           ' BUT NO OCTANT SYMMETRY,'/
     *       5X, 'SINCE LEBEDEV ANGULAR GRIDS ARE BEING USED.'/)
C
C     ---------------------------------------------------------
C           GET SYMMETRY AND INITIAL SYMMETRY INFORMATION
C     ---------------------------------------------------------
C
      CALL INPINF(ISYMXY,ISYMXZ,ISYMYZ,ISYMRX,ISYMRY,ISYMRZ,ISYMI,
     >            ISYMC1,AGROUP)
C
      IF(FIRST  .AND.  MASWRK  .AND.  NPRT.NE.0) THEN
         IF(NLEB(1).NE.0   .OR.  SG1  .OR.  JANS.GT.0) THEN
            WRITE(IW,1080)
         ELSE
            IF(AGROUP.NE.'C1'.AND.ABELPT()) THEN
                WRITE(IW,1075)
            ELSE
                WRITE(IW,1070) AGROUP
            END IF
         END IF
      END IF
C
C     THERE IS A SUBTLE DIFFERENCE BETWEEN RUNNING GRADIENT AND LOCAL
C     FRAME, BOTH WITHOUT OCTANT SYMMETRY.
C     FOR THE GRADIENT, WE GENERATE GRID WITH THE OCTANT SYMMETRY AND
C     USE IT FOR THE ENERGY, BUT NOT FOR THE GRADIENT.
C     FOR THE LOCAL FRAME RUNS, DO NOT USE THE OCTANT SYMMETRY.
C     THIS IS WHY LOCFRAME IS PROVIDED AS AN ARGUMENT TO INPINF.
C
C     ------------------------------------------------
C           SET UP PRIMITIVE COEFFICIENT VECTORS
C     ------------------------------------------------
C
      CALL SETPNRM
      CALL INPBAS(X(IPCOEFF))
C
C     --------------------------------------------------------------
C                 THE SETUP OF THE FACTOR IFACTR
C           FOR THE SYMMETRY-UNIQUE ATOM TO BE MULTIPLIED BY.
C     --------------------------------------------------------------
C
      CALL SYMUNQ(X(IFACTR),X(INATM),NSYMAT,X(INDEG),X(INEQATM),
     *            X(IUNIQUE))
C
      CALL ATMVEC(X(IATMXVC),X(IATMYVC),X(IATMZVC),X(IRIJ))
C
      CALL RADPT(X(IPTRAD),X(IWTRAD),NRAD)
      IF(DLB) CALL VCLR(X(ITOTWT),1,NAT*NPT)
      IF(DLB .AND. LRDFLG) THEN
        CALL VCLR(X(IWTAB),1,NAT*NAT*NPT)
      END IF
C
      DO 30 NCNTR = 1, NAT
C
C     ---- DUMMY, GHOST AND SYMMETRY NON-UNIQUE ATOMS ARE SKEPT. ----
C
        IF (IXFTCH(X(IUNIQUE),NCNTR).EQ.0) GOTO 30
C
C     ------------------------------------------------
C           DETERMINE WHICH QUADRANTS ARE UNIQUE
C                 AND THE SYMMETRY FACTOR
C              TO MULTIPLY FINAL INTEGRAL BY.
C     ------------------------------------------------
C
        CALL SYMFCT(ISYMYZ,ISYMXZ,ISYMXY,ISYMRX,ISYMRY,
     >              ISYMRZ,ISYMI,NCNTR,
     >              IQ1,IQ2,IQ3,IQ4,IQ5,IQ6,IQ7,IQ8,
     >              X(IFACT),ISYMC1)
C
C     ----------------------------------------------------
C            DETERMINE THE GRID POINTS FOR NCNTR
C                THE FUZZY CELL METHOD OF BECKE
C           ( A.D.BECKE, J.CHEM.PHYS.,88,2547,1988).
C     ----------------------------------------------------
C         THERE ARE THREE TYPES OF GRIDS TO DEAL WITH
C
        NCNX = NCNTR
        IF(NGRIDS.GT.1) THEN
C              WRITE(IW,*) 'SETTING UP STANDARD GRID-1'
           CALL PRUNEPT(NCNX,X(IWGHT),X(IXDAT),X(IYDAT),X(IZDAT),
     *          X(ITXYZ),X(IUXYZ),X(ITWGHT),
     *          X(IATMXVC),X(IATMYVC),X(IATMZVC),
     *          X(IRI),X(IRIJ),X(IWTINTR),
     *          X(ITOTWT),X(IAIJ),
     *          X(IANGN),X(NAPTS),X(IPTRAD),X(IWTRAD),
     *          NRAD,NLEB,MAXANG,NGRIDS,X(IWTAB))
        ELSE
           IF(NLEB(1).NE.0) THEN
C              WRITE(IW,*) 'SETTING UP AN EM/LEBEDEV GRID'
              CALL LEBPT(NCNX,X(IWGHT),X(IXDAT),X(IYDAT),X(IZDAT),
     *             X(ITXYZ),X(IUXYZ),X(ITWGHT),
     *             X(IATMXVC),X(IATMYVC),X(IATMZVC),
     *             X(IRI),X(IRIJ),X(IWTINTR),
     *             X(ITOTWT),X(IAIJ),
     *             X(IANGN),X(NAPTS),X(IPTRAD),X(IWTRAD),
     *             NRAD,NLEB(1),X(IWTAB))
           ELSE
C              WRITE(IW,*) 'SETTING UP AN EM/POLAR COORD GRID'
              CALL GRDPT(NCNX,X(IWGHT),X(IXDAT),X(IYDAT),X(IZDAT),
     *             X(IATMXVC),X(IATMYVC),X(IATMZVC),X(IRI),X(IRIJ),
     *             X(IWTINTR),X(ITOTWT),X(IAIJ),X(IGLROOT),X(IGLWGHT),
     *             X(IANGN),X(IFACT),X(NAPTS),X(IPTRAD),X(IWTRAD),
     *             IQ2,IQ3,IQ4,IQ5,IQ6,IQ7,NRAD,NTHE,NPHI,OPTGRD,
     *             X(IWTAB))
           ENDIF
        ENDIF
 30   CONTINUE
C
      IF(GOPARR.AND.DLB) CALL DDI_GSUMF(2314,X(ITOTWT),NAT*NPT)
      IF(GOPARR.AND.DLB.AND.LRDFLG) THEN
        CALL DDI_GSUMF(2350,X(IWTAB),NAT*NAT*NPT)
      END IF
C
C     POSSIBLY SAVE GRID FOR THE GRADIENT AND HOPEFULLY THE HESSIAN
C     THE LATTER CONDITION SAVES SOME TIME BY NOT WRITING THE COARSER
C     GRID TO DISK, SINCE WE SHALL LATER DEFINE A FINER GRID.
C
      SAVEGRID=ISYMC1.EQ.1.AND.NDER.GT.0.AND.IAND(MODIO,8).EQ.0.AND.
     *         NRAD*NANGPT(1).GE.NRAD0*NANGPT0(1)
      IF(SAVEGRID) THEN
         SVDSKW=DSKWRK
         DSKWRK=.TRUE.
         CALL SEQOPN(NFTDFT,'DFTGRID','UNKNOWN',.FALSE.,'UNFORMATTED')
         WRITE(NFTDFT) (X(I),I=1,NDFTEN)
         CALL SEQCLO(NFTDFT,'KEEP')
         DSKWRK=SVDSKW
      ENDIF
      RETURN
C
C     ==============================================================
      ENTRY DFTEXCOR(X,FA,FB,COEFFA,COEFFB,L1,L2,EEXC,TOTELE,TOTKIN)
C     ==============================================================
C     COMPUTE THE EXCHANGE-CORRELATION ENERGY FUNCTIONAL
C
      CALL VCLR(FA,1,L2)
      IF (UROHF) CALL VCLR(FB,1,L2)
C
      IF(IDENAO.NE.0) THEN
         IF(DCFLG) THEN
            CALL DAREAD(IDAF,IODA,X(INLCT),L2,272,1)
            CALL DFTNLC(X(INLCT),X(INELM),L1)
         ELSE
C           NLCT(1)=-1000 MEANS NON-DC CALCULATION
            CALL IXSTOR(X(INLCT),1,-1000)
C            IONE=-1
C            CALL ICOPY(L2,IONE,0,X(INLCT),1)
         END IF
      END IF
C
C     ----- LOOP FOR ATOMS -----
C
      TOTELE = ZERO
      TOTKIN = ZERO
      EEXC   = ZERO
      ECORL  = ZERO
      IF(DOLRD) THEN
        CALL VCLR(X(IATMPOL),1,LRDMEM)
        IF (MASWRK) WRITE (IW,2000)
      END IF
      DO 930 NCNTR = 1, NAT
        INC0=IXFTCH(X(IUNIQUE),NCNTR)
        IF(INC0.EQ.0) GOTO 930
C
C***********************************************************************
C
C     ----------------------------------------------------------------
C            CALCULATE THE EXCHANGE-CORRELATION ENERGY FUNCTIONAL
C     ----------------------------------------------------------------
C
        NCNTRX = NCNTR
        CALL DMATD(X(ITOTWT),X(IFACT),X(NAPTS),COEFFA,COEFFB,X(IANGN),
     *             X(IFACTR),INC0,X(IVMOA),X(IDVMOXA),X(IDVMOYA),
     *             X(IDVMOZA),X(IVALGA),X(IVMOB),X(IDVMOXB),X(IDVMOYB),
     *             X(IDVMOZB),X(IVALGB),FA,FB,NCNTRX,EEXC,TOTELE,NANG,
     *             X(IPTRAD),X(IXDAT),X(IYDAT),X(IZDAT),X(IATMXVC),
     *             X(IATMYVC),X(IATMZVC),X(IANGXV),X(IANGYV),X(IANGZV),
     *             X(IRSQRD),X(IPCOEFF),X(IEXPS),X(IAOX),X(IGAOX),
     *             X(IGAOY),X(IGAOZ),X(INLCT),X(INELM),IJX,IJY,IJZ,L1,
     *             NEEDGR,UROHF,TOTKIN,
     *             X(IATMPOL),X(IATPPOL),X(IEFPOL),X(IWTAB),
     *             X(IDRSPH),MAXL,MAXM,NFREQ)
C
 930  CONTINUE
C
C     CALCULATE LRD ENERGY
C
      IF(DOLRD) THEN
        IF (GOPARR) THEN
          CALL DDI_GSUMF(2351,X(IATMPOL),NAT*MAXL*MAXM*MAXM*NFREQ)
          CALL DDI_GSUMF(2352,X(IATPPOL),NAT*NAT*NFREQ)
          CALL DDI_GSUMF(2353,X(IEFPOL),NAT)
          CALL LRDENEG(X(IATMPOL),X(IEFPOL),
     *                 X(ISMATC),X(ISMATP),X(IWIGD),
     *                 X(ICOEF6),X(ICOEF8),X(ICOEF10),X(IATMPE),
     *                 MAXL,MAXM,MAXS,NFREQ,ELRD6,ELRD8,ELRD10,
     *                 X(IATMXVC),X(IATMYVC),X(IATMZVC),X(IRIJ),
     *                 X(IUNIQUE))
          IF (MLTINT)
     *    CALL LRDMULT(X(IATPPOL),X(IEFPOL),NFREQ,EMULT,
     *                 X(IATMXVC),X(IATMYVC),X(IATMZVC),X(IRIJ),
     *                 X(IUNIQUE))
        ELSE
          CALL LRDENEG(X(IATMPOL),X(IEFPOL),
     *                 X(ISMATC),X(ISMATP),X(IWIGD),
     *                 X(ICOEF6),X(ICOEF8),X(ICOEF10),X(IATMPE),
     *                 MAXL,MAXM,MAXS,NFREQ,ELRD6,ELRD8,ELRD10,
     *                 X(IATMXVC),X(IATMYVC),X(IATMZVC),X(IRIJ),
     *                 X(IUNIQUE))
          IF (MLTINT)
     *    CALL LRDMULT(X(IATPPOL),X(IEFPOL),NFREQ,EMULT,
     *                 X(IATMXVC),X(IATMYVC),X(IATMZVC),X(IRIJ),
     *                 X(IUNIQUE))
        END IF
      END IF
C
      RETURN
 2000 FORMAT(10X,'--- CALCULATING LOCAL RESPONSE DISPERSION ENERGY ---')
C
C     ==================================================================
      ENTRY DFTGRAD(X,G2AXX,G2AYY,G2AZZ,G2AXY,G2AYZ,G2AXZ,
     *              COEFFA,COEFFB,DA,DB,DEDFT,UVEC,DWTINT,DWTTOT,DTOTWT,
     *              L1,TOTELE,GRDOUT)
C     ==================================================================
C     DFT CONTRIBUTIONS TO THE NUCLEAR GRADIENT.
C
      LL2=L1*(L1+1)/2
      IF(IDENAO.NE.0) THEN
         IF(DCFLG) THEN
            CALL DAREAD(IDAF,IODA,X(INLCT),LL2,272,1)
            CALL DFTNLC(X(INLCT),X(INELM),L1)
         ELSE
C           NLCT(1)=-1000 MEANS NON-DC CALCULATION
            CALL IXSTOR(X(INLCT),1,-1000)
C            IONE=-1
C            CALL ICOPY(LL2,IONE,0,X(INLCT),1)
         END IF
      END IF
C
C     ----- LOOP FOR ATOMS -----
C
      TOTELE = ZERO
      DO 940 NCNTR = 1, NAT
        INC0=IXFTCH(X(IUNIQUE),NCNTR)
        IF (INC0.EQ.0) GOTO 940
        NCNX = NCNTR
        CALL DEREXC(X(ITOTWT),X(NAPTS),COEFFA,COEFFB,DA,DB,X(IANGN),
     *              X(IFACTR),INC0,X(IVMOA),X(IDVMOXA),X(IDVMOYA),
     *              X(IDVMOZA),X(IVMOB),X(IDVMOXB),X(IDVMOYB),X(IDVMOZB)
     *             ,X(IWGHT),X(IRI),X(IRIJ),X(IWTINTR),X(IAIJ),X(IWTRAD)
     *             ,NCNX,L1,TOTELE,NANG+NDER,X(IPTRAD),X(IXDAT),
     *              X(IYDAT),X(IZDAT),X(IATMXVC),X(IATMYVC),X(IATMZVC),
     *              X(IANGXV),X(IANGYV),X(IANGZV),X(IRSQRD),
     *              X(IPCOEFF),X(IEXPS),X(IAOX),X(IGAOX),X(IGAOY),
     *              X(IGAOZ),G2AXX,G2AYY,G2AZZ,G2AXY,G2AYZ,G2AXZ,
     *              X(INLCT),X(INELM),IJX,IJY,IJZ,NEEDGR,DEDFT,
     *              UVEC,DWTINT,DWTTOT,DTOTWT,GRDOUT)
 940  CONTINUE
      RETURN
C1193 FORMAT(/'TOTAL EXC ENERGY',F20.10,'TOTAL ELECTRON',F20.10)
C
C     ==============================================
      ENTRY MGRDMNG(X,XYZGRD,XYZWGT,KCP,NPTGRD,ITYP)
C     ==============================================
C     USED BY TD-DFT, FOR EXCHANGE/CORRELATION.
C     ITYP=0 COUNTS POINTS, SO STORAGE CAN BE ALLOCATED FOR THE
C     ITYP=1 CALL WHICH WILL ACTUALLY SET GRID POINT/WEIGHT DATA.
C
C     ----- LOOP FOR ATOMS -----
C
      DLB = IBTYP.EQ.1
C
      IGPT=0
      DO 950 NCNTR = 1, NAT
        INC0=IXFTCH(X(IUNIQUE),NCNTR)
        IF(INC0.EQ.0) GOTO 950
C
        IF(ITYP.EQ.0) THEN
           CALL GRDCNT(IGPT,X(ITOTWT),X(IFACT),X(NAPTS),X(IANGN),
     *                 X(IFACTR),INC0,NCNTR,X(IPTRAD))
        ELSE
C
C              CANNOT PARALLELIZE GRDCALC WITHOUT REWRITE DUE TO CUTOFF
C                 DLB RUNS IN SERIAL MODE, SLB RUNS IN PARALLEL.
C
           GPSAVE=GOPARR
           NPRCSV=NPROC
           IF(DLB) THEN
              GOPARR=.FALSE.
              NPROC=1
           END IF
           CALL GRDCALC(XYZGRD,XYZWGT,KCP,IGPT,X(ITOTWT),X(IFACT),
     *                  X(NAPTS),X(IANGN),X(IFACTR),INC0,NCNTR,
     *                  X(IPTRAD),X(IXDAT),X(IYDAT),X(IZDAT))
           GOPARR=GPSAVE
           NPROC =NPRCSV
        ENDIF
C
  950 CONTINUE
C
      IF(GOPARR) THEN
C-MWS-IF(GOPARR  .AND.  .NOT.DLB) THEN
         IF(ITYP.EQ.0) THEN
            CALL DDI_GSUMI(2320,IGPT,1)
C---     ELSE
C---        CALL DDI_GSUMI(2321,IGPT,1)
C---        CALL DDI_GSUMF(2322,XYZGRD,NPTGRD*3)
C---        CALL DDI_GSUMF(2323,XYZWGT,NPTGRD)
C---        CALL DDI_GSUMF(2324,KCP,NPTGRD)
         END IF
      END IF
C
      NPTGRD=IGPT
      RETURN
C
C     ===============================================================
      ENTRY WGTGRAD(X,UVEC,DWTINT,DWTTOT,DTOTWT,TOTELE,DRHOI_,GRDFUN,
     *              NPTGRD,IIGPT)
C     ===============================================================
C     USED BY TDDFT, FOR NUCLEAR GRADIENTS
C
      DLB = IBTYP.EQ.1
C
C     ----- LOOP FOR ATOMS -----
C
      TOTELE = ZERO
      IGPT   = 0
C
C                 DLB RUNS IN SERIAL MODE, SLB RUNS IN PARALLEL.
C
      GPSAVE=GOPARR
      NPRCSV=NPROC
      IF(DLB) THEN
         GOPARR=.FALSE.
         NPROC=1
      END IF
C
      DO 960 NCNTR = 1, NAT
        INC0=IXFTCH(X(IUNIQUE),NCNTR)
        IF (INC0.EQ.0) GOTO 960
        NCNX = NCNTR
        CALL DERWGT(X(ITOTWT),X(NAPTS),X(IANGN),X(IFACTR),INC0,X(IWGHT),
     *              X(IRI),X(IRIJ),X(IWTINTR),X(IAIJ),X(IWTRAD),
     *              NCNX,TOTELE,X(IPTRAD),X(IXDAT),X(IYDAT),X(IZDAT),
     *              X(IATMXVC),X(IATMYVC),X(IATMZVC),
     *              X(IRSQRD),UVEC,DWTINT,DWTTOT,DTOTWT,
     *              DRHOI_,GRDFUN,NPTGRD,IGPT)
 960  CONTINUE
      IIGPT=IGPT
C
      GOPARR=GPSAVE
      NPROC =NPRCSV
      RETURN
C     ===============================================================
      ENTRY UWGTGRAD(X,UVEC,DWTINT,DWTTOT,DTOTWT,TOTELE,DRHOI_,GRDFUN,
     *               NPTGRD,IIGPT)
C     ===============================================================
C     USED BY SFDFT, FOR NUCLEAR GRADIENTS
C
      DLB = IBTYP.EQ.1
C
C     ----- LOOP FOR ATOMS -----
C
      TOTELE = ZERO
      IGPT   = 0
C
C                 DLB RUNS IN SERIAL MODE, SLB RUNS IN PARALLEL.
C
      GPSAVE=GOPARR
      NPRCSV=NPROC
      IF(DLB) THEN
         GOPARR=.FALSE.
         NPROC=1
      END IF
C
      DO 970 NCNTR = 1, NAT
        INC0=IXFTCH(X(IUNIQUE),NCNTR)
        IF (INC0.EQ.0) GOTO 970
        NCNX = NCNTR
        CALL UDERWGT(X(ITOTWT),X(NAPTS),X(IANGN),X(IFACTR),INC0,
     *               X(IWGHT),X(IRI),X(IRIJ),X(IWTINTR),X(IAIJ),
     *               X(IWTRAD),NCNX,TOTELE,X(IPTRAD),X(IXDAT),X(IYDAT),
     *               X(IZDAT),X(IATMXVC),X(IATMYVC),X(IATMZVC),
     *               X(IRSQRD),UVEC,DWTINT,DWTTOT,DTOTWT,
     *               DRHOI_,GRDFUN,NPTGRD,IGPT)
 970  CONTINUE
      IIGPT=IGPT
C
      GOPARR=GPSAVE
      NPROC =NPRCSV
      RETURN
      END
C*MODULE DFTGRD  *DECK CHKRGRID
C>    @brief Check density of grid points
C>
C>    @details CHECK DENSITY OF RADIAL POINTS VERSUS BASIS SET'S EXPONENTS
C>     A.A.JARECKI AND E.R.DAVIDSON, CHEM.PHYS.LETT. 300, 44-52(1999)
C>     THIS ROUTINE APPLIES ONLY TO EULER/MACLAURIN RADIAL QUADRATURE.
C>     PRINT A WARNING, AS OPPOSED TO BOMBING THE JOB, IF THE
C>     SELF-OVERLAP INTEGRAL'S ACCURACY IS LESS THAN 4 DIGITS.
C
      SUBROUTINE CHKRGRID(NRADPTS)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL SG1
      CHARACTER*1 TYPES(0:6)
      PARAMETER (MXGRID=10, MXATM=2000)
      COMMON /DFGRID/ DFTTHR,DFTGTHR,SWOFF,SW0,BSLRD(137),NDFTFG,
     *                NRAD,NTHE,NPHI,NRAD0,NTHE0,NPHI0,
     *                NANGPT(MXGRID),NANGPT0(MXGRID),SG1,JANS
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      DATA TYPES/'S','P','D','F','G','H','I'/
      DATA ONE/1.0D+00/
C
      CALL SIFTZETA(ZMIN,IATMIN,LMNMIN,ZMAX,IATMAX,LMNMAX)
      BRAGGMIN = BSLRD(IAN(IATMIN))
      BRAGGMAX = BSLRD(IAN(IATMAX))
C
      WRITE(IW,9000) NRADPTS
      CALL EMOVLP(NRADPTS,LMNMIN,ZMIN,BRAGGMIN,SMIN)
      WRITE(IW,9010) 'SMALLEST',ZMIN,TYPES(LMNMIN),IATMIN,SMIN
      CALL EMOVLP(NRADPTS,LMNMAX,ZMAX,BRAGGMAX,SMAX)
      WRITE(IW,9010) ' LARGEST',ZMAX,TYPES(LMNMAX),IATMAX,SMAX
C
      NWARNMIN = 0
      NWARNMAX = 0
      IF(ABS(ONE-SMIN).GT.1.0D-04) NWARNMIN=NWARNMIN+1
      IF(ABS(ONE-SMAX).GT.1.0D-04) NWARNMAX=NWARNMAX+1
C
      IF(NWARNMIN+NWARNMAX.GT.0) WRITE(IW,9011) NRADPTS
      IF(NWARNMAX.GT.0)          WRITE(IW,9012) IATMAX,ZMAX
      IF(NWARNMIN.GT.0)          WRITE(IW,9013) IATMIN,ZMIN
      RETURN
C
 9000 FORMAT(1X,'FOR AN EULER-MACLAURIN QUADRATURE USING',I4,
     *   ' RADIAL POINTS:')
 9010 FORMAT(1X,A,' GAUSSIAN PRIMITIVE EXPONENT=',F20.10,
     *            ' OF TYPE -',A1,'-'/
     *       1X,'ON ATOM NUMBER',I4,' HAS RADIAL NORMALIZATION=',F10.6)
 9011 FORMAT(/10X,50(1H*)/10X,'*',48X,'*'/
     *       10X,'* WARNING: QUESTIONABLE SELECTION OF RADIAL GRID *'/
     *       10X,'*',48X,'*'/10X,50(1H*)//
     *       1X,'THIS RUN HAS REQUESTED NRAD=',I4,' IN $DFT OR $TDDFT')
 9012 FORMAT(1X,'ATOM=',I5,' HAS LARGE EXPONENT=',F30.15/
     *       1X,'RECOMMEND NRAD ABOVE  50 FOR ZETA''S ABOVE 1E+4'/
     *       1X,'RECOMMEND NRAD ABOVE  75 FOR ZETA''S ABOVE 1E+5'/
     *       1X,'RECOMMEND NRAD ABOVE 125 FOR ZETA''S ABOVE 1E+6')
 9013 FORMAT(1X,'ATOM=',I5,' HAS SMALL EXPONENT=',F30.15/
     *       1X,'RECOMMEND NRAD ABOVE  75 FOR ZETA''S BELOW 1E-3'/
     *       1X,'RECOMMEND NRAD ABOVE 100 FOR ZETA''S BELOW 1E-4'/
     *       1X,'RECOMMEND NRAD ABOVE 125 FOR ZETA''S BELOW 1E-5')
      END
C*MODULE DFTGRD  *DECK SIFTZETA
C>    @brief Return atom(s) containing the largest and smallest exponents
C>    that occur in Gaussian basis set
C
      SUBROUTINE SIFTZETA(ZMIN,IATMIN,LMNMIN,ZMAX,IATMAX,LMNMAX)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXSH=5000, MXGTOT=20000)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
C
      ZMIN = 1.0D+20
      ZMAX = 0.0D+00
C
      IGMAX = 0
      DO ISH=1,NSHELL
         IAT = KATOM(ISH)
         IGMIN=KSTART(ISH)
         IGMAX=IGMIN+KNG(ISH)-1
C            KTYPE=2 IS EITHER -P- OR -L-, JUST REPORT IT AS A -P-.
         ITYPE=KTYPE(ISH)
         DO IG=IGMIN,IGMAX
            ZETA = EX(IG)
            IF(ZETA.GT.ZMAX) THEN
               IATMAX = IAT
               ZMAX = ZETA
               LMNMAX = ITYPE - 1
            END IF
            IF(ZETA.LT.ZMIN) THEN
               IATMIN = IAT
               ZMIN = ZETA
               LMNMIN = ITYPE - 1
            END IF
         ENDDO
      ENDDO
      RETURN
      END
C
C*MODULE DFTGRD  *DECK EMOVLP
      SUBROUTINE EMOVLP(NRAD,LMN,ZETA,BRAGG,S)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      ZERO = 0.0D+00
      ONE  = 1.0D+00
      TWO  = 2.0D+00
      FOUR = 4.0D+00
      PI = FOUR*ATAN(ONE)
      IDF=1
      DO I=0, LMN
       IDF=IDF*(2*I+1)
      ENDDO
      GNORM = ZETA**(2*LMN+3)*TWO**(4*LMN+7)
      GNORM = GNORM/(PI*IDF**2)
      GNORM = GNORM**(0.25D+00)
C
      S = ZERO
      DO I=1,NRAD
         X = I
         Y = NRAD+1-I
         R = (BRAGG*X*X)/(Y*Y)
         W = ((BRAGG**3)*TWO*(NRAD+1)*(X**5))/(Y**7)
         GTO = GNORM*R**LMN*EXP(-ZETA*R*R)
         S = S + W*(GTO*GTO)
      ENDDO
      END
C*MODULE DFTGRD  *DECK GRDCNT
C>    @brief Accumulates the grid weights (FTOTWT)
C
      SUBROUTINE GRDCNT(IGPT,TOTWT,IIFACT,NAPTS,IANGN,IFACTR,INC0,
     *                 NCNTR,PTRAD)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,DLB,SG1
C
      PARAMETER (MXATM=2000,MXGRID=10,MXGRIDTYP=10)
C
      COMMON /DFGRID/ DFTTHR,DFTGTHR,SWOFF,SW0,BSLRD(137),NDFTFG,
     *                NRAD,NTHE,NPHI,NRAD0,NTHE0,NPHI0,
     *                NANGPT(MXGRID),NANGPT0(MXGRID),SG1,JANS
      COMMON /DFPRUN/ PRUNERADS(MXGRID,MXGRIDTYP),
     *                PRUNEATOMS(2,MXGRIDTYP),
     *                IPRUNECUTS(MXATM),NTOTGRIDPOINTS(MXATM),
     *                NGRIDS,MAXANG,NGRIDTYPS
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DIMENSION TOTWT(NAT,*),PTRAD(*)
      DIMENSION NAPTS(NAT),IANGN(NAT,2,*),IIFACT(NAT),IFACTR(NAT)
C
      NPT=NRAD*MAXANG
      RAD = BRAGGRAD(NCNTR)
      WCUTOFF=1.0D-08/(NPT*NAT)
C
C     ---- SYMMETRY MULTIPLICATION FACTOR ----
C
      FACT = IIFACT(NCNTR)*IFACTR(INC0)
C
      LOOP=0
      NGRAN=20
      IF(NGRIDS.EQ.1) THEN
         NLOOP=NRAD*(IANGN(NCNTR,2,1)-IANGN(NCNTR,1,1)+1)
      ELSE
         NLOOP=NTOTGRIDPOINTS(NCNTR)
      ENDIF
      MCHUNK=(NLOOP-1)/(NGRAN*NPROC)+1
      NEXT  = -1
      DLB = IBTYP.EQ.1
C***********************************************************************
C     LOOP OVER RADIAL GRIDS
C     LOOP OVER ANGULAR GRIDS
C***********************************************************************
      IGRID = 1
      DO 20 IRADPT = 1, NRAD
C
         R1= RAD*PTRAD(IRADPT)
         IF(R1.GE.PRUNERADS(IGRID,IPRUNECUTS(NCNTR))*RAD) THEN
            IGRID = IGRID + 1
         ENDIF
C         WRITE(IW,'(A,I5,2F20.10,I5)')'RAD,PT,IGRID = ',IRADPT,RAD,
C     *        PTRAD(IRADPT),IGRID
        DO 10 IANGPT = IANGN(NCNTR,1,IGRID), IANGN(NCNTR,2,IGRID)
           IPT=(IRADPT-1)*NAPTS(NCNTR)+IANGPT
C
           IF(GOPARR) THEN
              IF(DLB) THEN
                 LOOP=LOOP+1
                 ICHUNK=(LOOP-1)/MCHUNK
                 IF(ICHUNK.GT.NEXT) THEN
                    CALL DDI_DLBNEXT(NEXT)
                 ENDIF
                 IF(NEXT.NE.ICHUNK) GOTO 10
              ELSE
                 IF(MOD(IPT,NPROC).NE.ME) GOTO 10
              ENDIF
           ENDIF
           IPTME=(IPT-1)/NPROC+1
           IF(DLB) IPTME=IPT
C
           FTOTWT = TOTWT(NCNTR,IPTME)*FACT
           IF(FTOTWT.LT.WCUTOFF) THEN
              GOTO 10
           ELSE
              IGPT=IGPT+1
           ENDIF
C
 10     CONTINUE
C
C     ----- NEXT RADIAL POINT -----
C
 20   CONTINUE
C
C     ----- NEXT ATOM -----
C
      IF(GOPARR.AND.DLB) CALL DDI_DLBRESET
      RETURN
      END
C*MODULE DFTGRD  *DECK GRDCALC
C>    @brief  CALCULATES THE GRID POINTS AND WEIGHTS AND STORES THEM INTO
C>     (XYZGRD, XYZWGT).
C
      SUBROUTINE GRDCALC(XYZGRD,XYZWGT,KCP,IGPT,TOTWT,IIFACT,NAPTS,
     *                   IANGN,IFACTR,INC0,NCNTR,PTRAD,XDAT,YDAT,ZDAT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,DLB,SG1
C
      PARAMETER (MXATM=2000)
      PARAMETER (MXGRID=10,MXGRIDTYP=10)
C
      COMMON /DFGRID/ DFTTHR,DFTGTHR,SWOFF,SW0,BSLRD(137),NDFTFG,
     *                NRAD,NTHE,NPHI,NRAD0,NTHE0,NPHI0,
     *                NANGPT(MXGRID),NANGPT0(MXGRID),SG1,JANS
      COMMON /DFPRUN/ PRUNERADS(MXGRID,MXGRIDTYP),
     *                PRUNEATOMS(2,MXGRIDTYP),
     *                IPRUNECUTS(MXATM),NTOTGRIDPOINTS(MXATM),
     *                NGRIDS,MAXANG,NGRIDTYPS
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DIMENSION TOTWT(NAT,*)
      DIMENSION NAPTS(NAT),IANGN(NAT,2,MXGRID),IIFACT(NAT),IFACTR(NAT)
      DIMENSION PTRAD(*),XDAT(NAT,MAXANG,NGRIDS),
     *          YDAT(NAT,MAXANG,NGRIDS),ZDAT(NAT,MAXANG,NGRIDS)
      DIMENSION XYZGRD(3,*),XYZWGT(*),KCP(*)
C
      RAD = BRAGGRAD(NCNTR)
      NPT=NRAD*MAXANG
C
      WCUTOFF=1.0D-08/(NPT*NAT)
C
C     ---- SYMMETRY MULTIPLICATION FACTOR ----
C
      FACT = IIFACT(NCNTR)*IFACTR(INC0)
C
      LOOP=0
      NGRAN=20
      IF(NGRIDS.EQ.1) THEN
         NLOOP=NRAD*(IANGN(NCNTR,2,1)-IANGN(NCNTR,1,1)+1)
      ELSE
         NLOOP=NTOTGRIDPOINTS(NCNTR)
      ENDIF
      MCHUNK=(NLOOP-1)/(NGRAN*NPROC)+1
      NEXT  = -1
      DLB = IBTYP.EQ.1
C***********************************************************************
C     LOOP OVER RADIAL GRIDS
C     LOOP OVER ANGULAR GRIDS
C***********************************************************************
      IGRID=1
      DO 20 IRADPT = 1, NRAD
C
         R1= RAD*PTRAD(IRADPT)
         IF(R1.GE.PRUNERADS(IGRID,IPRUNECUTS(NCNTR))*RAD) THEN
            IGRID = IGRID + 1
         ENDIF
C
C     IF(IRADPT.EQ.1) WRITE(IW,2) IRADPT,RAD,PTRAD(IRADPT),IGRID
C   2 FORMAT('GRDCALC: RAD,PT,IGRID = ',I5,2F15.10,I5)
C
         DO 10 IANGPT = IANGN(NCNTR,1,IGRID), IANGN(NCNTR,2,IGRID)
            IPT=(IRADPT-1)*NAPTS(NCNTR)+IANGPT
C
            IF(GOPARR) THEN
               IF(DLB) THEN
                  LOOP=LOOP+1
                  ICHUNK=(LOOP-1)/MCHUNK
                  IF(ICHUNK.GT.NEXT) THEN
                     CALL DDI_DLBNEXT(NEXT)
                  ENDIF
                  IF(NEXT.NE.ICHUNK) GOTO 10
               ELSE
                  IF(MOD(IPT,NPROC).NE.ME) GOTO 10
               ENDIF
            ENDIF
            IPTME=(IPT-1)/NPROC+1
            IF(DLB) IPTME=IPT
C
            FTOTWT = TOTWT(NCNTR,IPTME)*FACT
            IF(FTOTWT.LT.WCUTOFF) THEN
               GOTO 10
            ELSE
               IGPT=IGPT+1
               XYZWGT(IGPT)=FTOTWT
               KCP(IGPT)=NCNTR
               XD=R1*XDAT(NCNTR,IANGPT,IGRID)
               YD=R1*YDAT(NCNTR,IANGPT,IGRID)
               ZD=R1*ZDAT(NCNTR,IANGPT,IGRID)
               XYZGRD(1,IGPT)=XD+C(1,NCNTR)
               XYZGRD(2,IGPT)=YD+C(2,NCNTR)
               XYZGRD(3,IGPT)=ZD+C(3,NCNTR)
           ENDIF
C
 10      CONTINUE
 20   CONTINUE
      IF(GOPARR.AND.DLB) CALL DDI_DLBRESET
      RETURN
      END
C*MODULE DFTGRD  *DECK DERWGT
C>    @brief Clone of DMATD
C>
C>    @details THIS ROUTINE IS A CLONE OF DMATD, SEE ADDITIONAL REFERENCES THERE.
C>     HERE A CONTRIBUTION TO THE ENERGY GRADIENT DUE TO INTEGRATION OVER
C>     GRID POINTS SURROUNDING ATOM NCNTR IS COMPUTED.
C>
C>     CAN'T USE DLB PARALLELIZATION WITH THE COMMONLY USED APPROACH
C>     BECAUSE THE VALUE OF IGPT IS USED TO ACCESS AN ARRAY.
C>     CONSEQUENTLY, CALLS IN DLB RUNS SHOULD SET PARALLEL OFF.
C>     HOWEVER, DLB LOGIC IS LEFT BELOW, IN CASE SOMEONE WANTS TO
C>     COME BACK TO THIS POINT.  SLB DOES RUN IN PARALLEL.
C
      SUBROUTINE DERWGT(TOTWT,NAPTS,IANGN,IFACTR,
     *                  INC0,WGHT,RI,RIJ,WTINTR,AIJ,WTRAD,
     *                  NCNTR,TOTELE,PTRAD,XDAT,YDAT,ZDAT,
     *                  ATMXVEC,ATMYVEC,ATMZVEC,RSQRD,
     *                  UVEC,DWTINT,DWTTOT,DTOTWT,
     *                  DRHOI_,GRDFUN,NPTGRD,IGPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK,DLB,SG1
      PARAMETER (MXATM=2000,ZERO=0.0D+00,TWO=2.0D+00)
      PARAMETER (MXGRID=10,MXGRIDTYP=10)
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /DFGRID/ DFTTHR,DFTGTHR,SWOFF,SW0,BSLRD(137),NDFTFG,
     *                NRAD,NTHE,NPHI,NRAD0,NTHE0,NPHI0,
     *                NANGPT(MXGRID),NANGPT0(MXGRID),SG1,JANS
      COMMON /DFPRUN/ PRUNERADS(MXGRID,MXGRIDTYP),
     *                PRUNEATOMS(2,MXGRIDTYP),
     *                IPRUNECUTS(MXATM),NTOTGRIDPOINTS(MXATM),
     *                NGRIDS,MAXANG,NGRIDTYPS
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /SCFOPT/ CONVHF,MAXIT,MCONV,NPUNCH,NPREO(4)
C
      DIMENSION DRHOI_(NPTGRD,*),GRDFUN(*)
      DIMENSION TOTWT(NAT,*),NAPTS(NAT),IANGN(NAT,2,MXGRID),IFACTR(NAT)
      DIMENSION PTRAD(*),XDAT(NAT,MAXANG,MXGRID),
     *          YDAT(NAT,MAXANG,MXGRID),ZDAT(NAT,MAXANG,MXGRID),
     *          RSQRD(*),
     *          ATMXVEC(NAT,NAT),ATMYVEC(NAT,NAT),ATMZVEC(NAT,NAT),
     *          WGHT(NAT,MAXANG,MXGRID),RI(NAT),RIJ(NAT,NAT),
     *          WTINTR(NAT), AIJ(NAT,NAT),WTRAD(*),UVEC(3,NAT),
     *          DWTINT(3,NAT,NAT), DWTTOT(3,NAT),DTOTWT(3,NAT)
C
      RAD = BRAGGRAD(NCNTR)
      NPT=NRAD*MAXANG
C
      THRV1=ZERO
      THRV2=1.0D+00
      IF(DFTGTHR.GT.1.01D+00) THEN
        THRV2=DFTGTHR
      ELSE IF(DFTGTHR.LT.0.99D+00) THEN
        THRV1=DFTGTHR
      ENDIF
      IF(DFTTHR.LT.1.1D-15.AND.DFTTHR.NE.ZERO) THRV1=1.0D-15
C     WCUTOFF=3.0D-05/NPT/THRV2
      RCUTOFF=1.0D-02/NPT/THRV2
      IF(THRV1.NE.ZERO) THEN
C        THRV1=1.0D-15
C        WCUTOFF=THRV1
         RCUTOFF=THRV1
      ENDIF
      WCUTOFF=1.0D-08/(NPT*NAT)
      RCUTOFF=CONVHF/(NPT*NAT)
C
C     ---- SYMMETRY MULTIPLICATION FACTOR ----
C
C      FACT = IIFACT(NCNTR)*IFACTR(INC0)
      FACT=IFACTR(INC0)
C      FACT=1
C
C     DYNAMIC LOAD BALANCING: DIVIDE ALL POINTS INTO NGRAN*NPROC CHUNKS.
C     NGRAN CANNOT BE SET IN THE INPUT FILE. THEN EACH NODE GETS A CHUNK
C     AND TOILS IT OVER UNTIL READY TO ASK FOR MORE.
C
      LOOP=0
      IGRID=1
      NGRAN=20
      IF(NGRIDS.EQ.1) THEN
         NLOOP=NRAD*(IANGN(NCNTR,2,1)-IANGN(NCNTR,1,1)+1)
      ELSE
         NLOOP=NTOTGRIDPOINTS(NCNTR)
      ENDIF
      MCHUNK=(NLOOP-1)/(NGRAN*NPROC)+1
      NEXT  = -1
      DLB = IBTYP.EQ.1
C***********************************************************************
C     LOOP OVER RADIAL GRIDS
C     LOOP OVER ANGULAR GRIDS
C***********************************************************************
      DO 20 IRADPT = 1, NRAD
C
        RADWT=RAD*RAD*RAD*WTRAD(IRADPT)
        R1= RAD*PTRAD(IRADPT)
        IF(R1.GE.PRUNERADS(IGRID,IPRUNECUTS(NCNTR))*RAD) THEN
           IGRID = IGRID + 1
        ENDIF
C        WRITE(IW,'(A,I5,2F20.10,I5)')'RAD,PT,IGRID = ',IRADPT,RAD,
C     *       PTRAD(IRADPT),IGRID
        DO 10 IANGPT = IANGN(NCNTR,1,IGRID), IANGN(NCNTR,2,IGRID)
           IPT=(IRADPT-1)*NAPTS(NCNTR)+IANGPT
C
          IF(GOPARR) THEN
            IF(DLB) THEN
              LOOP=LOOP+1
              ICHUNK=(LOOP-1)/MCHUNK
              IF(ICHUNK.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
              IF(NEXT.NE.ICHUNK) GOTO 10
            ELSE
              IF(MOD(IPT,NPROC).NE.ME) GOTO 10
            ENDIF
          ENDIF
          IPTME=(IPT-1)/NPROC+1
          IF(DLB) IPTME=IPT
C
          FTOTWT = TOTWT(NCNTR,IPTME)*FACT
          FTOTWT0=FTOTWT/FACT
          IF(FTOTWT0.LT.WCUTOFF) THEN
             GOTO 10
          ELSE
             IGPT=IGPT+1
          ENDIF
C
C         THIS NEEDS TO BE INVERTED
          XD=R1*XDAT(NCNTR,IANGPT,IGRID)
          YD=R1*YDAT(NCNTR,IANGPT,IGRID)
          ZD=R1*ZDAT(NCNTR,IANGPT,IGRID)
          DO 610 IATM=1,NAT
            XCDNT=ATMXVEC(NCNTR,IATM)+XD
            YCDNT=ATMYVEC(NCNTR,IATM)+YD
            ZCDNT=ATMZVEC(NCNTR,IATM)+ZD
            RSQRD(IATM)=XCDNT**2+YCDNT**2+ZCDNT**2
C
C           NORMALISE THE R(A) VECTOR, = R(I)-R(A)
C
            RI(IATM)=SQRT(RSQRD(IATM))
            UVEC(1,IATM) = XCDNT / RI(IATM)
            UVEC(2,IATM) = YCDNT / RI(IATM)
            UVEC(3,IATM) = ZCDNT / RI(IATM)
C
  610     CONTINUE
          IF(DRHOI_(IGPT,1).LT.RCUTOFF) THEN
             GOTO 10
          ENDIF
C
C         COMPUTE THE WEIGHT DERIVATIVE.
C
          WGHTNOW=WGHT(NCNTR,IANGPT,IGRID)
          NITR=4
          CALL GRDOCT(NAT,NITR,NCNTR,ATMXVEC,ATMYVEC,ATMZVEC,RI,RIJ,AIJ,
     *          WGHTNOW,RADWT,WTINTR,UVEC,DWTINT,DWTTOT,DTOTWT)
C
C         ADD THE WEIGHT DERIVATIVE CONTRIBUTION
C
C         NOT NECESSARY TO DO THE MULTIPLICATION
C         MULTIPLY BY DSCALE TO DIVIDE BY THE NUMBER OF PROCESSORS
C          ENER=GRDFUN(IGPT)*FACT*DSCALE
C
          ENER=GRDFUN(IGPT)*FACT
C         ENER=DRHOI_(IGPT,1)
          CALL DAXPY(3*NAT,ENER,DTOTWT,1,DE,1)
C
C     ----- THE TOTAL ELCTRON DENSITY -----
C
          TOTELE=TOTELE+FTOTWT*TWO*DRHOI_(IGPT,1)
C
C     ----- END LOOP 10 OVER ANGULAR POINT -----
C     ----- END LOOP 20 OVER RADIAL POINT -----
C
   10   CONTINUE
   20 CONTINUE
      RETURN
      END
C
C*MODULE DFTGRD   *DECK UDERWGT
C>    @brief Clone of DMATD
C>
C>    @details THIS ROUTINE IS A CLONE OF DMATD, SEE ADDITIONAL REFERENCES THERE.
C>     HERE A CONTRIBUTION TO THE ENERGY GRADIENT DUE TO INTEGRATION OVER
C>     GRID POINTS SURROUNDING ATOM NCNTR IS COMPUTED.
C>
C>     CAN'T USE DLB PARALLELIZATION WITH THE COMMONLY USED APPROACH
C>     BECAUSE THE VALUE OF IGPT IS USED TO ACCESS AN ARRAY.
C>     CONSEQUENTLY, CALLS IN DLB RUNS SHOULD SET PARALLEL OFF.
C>     HOWEVER, DLB LOGIC IS LEFT BELOW, IN CASE SOMEONE WANTS TO
C>     COME BACK TO THIS POINT.  SLB DOES RUN IN PARALLEL.
C
      SUBROUTINE UDERWGT(TOTWT,NAPTS,IANGN,IFACTR,
     *                   INC0,WGHT,RI,RIJ,WTINTR,AIJ,WTRAD,
     *                   NCNTR,TOTELE,PTRAD,XDAT,YDAT,ZDAT,
     *                   ATMXVEC,ATMYVEC,ATMZVEC,RSQRD,
     *                   UVEC,DWTINT,DWTTOT,DTOTWT,
     *                   DRHOI_,GRDFUN,NPTGRD,IGPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK,DLB,SG1
      PARAMETER (MXATM=2000,ZERO=0.0D+00)
      PARAMETER (MXGRID=10,MXGRIDTYP=10)
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /DFGRID/ DFTTHR,DFTGTHR,SWOFF,SW0,BSLRD(137),NDFTFG,
     *                NRAD,NTHE,NPHI,NRAD0,NTHE0,NPHI0,
     *                NANGPT(MXGRID),NANGPT0(MXGRID),SG1,JANS
      COMMON /DFPRUN/ PRUNERADS(MXGRID,MXGRIDTYP),
     *                PRUNEATOMS(2,MXGRIDTYP),
     *                IPRUNECUTS(MXATM),NTOTGRIDPOINTS(MXATM),
     *                NGRIDS,MAXANG,NGRIDTYPS
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /SCFOPT/ CONVHF,MAXIT,MCONV,NPUNCH,NPREO(4)
C
      DIMENSION DRHOI_(NPTGRD,4,2),GRDFUN(*)
      DIMENSION TOTWT(NAT,*),NAPTS(NAT),IANGN(NAT,2,MXGRID),IFACTR(NAT)
      DIMENSION PTRAD(*),XDAT(NAT,MAXANG,MXGRID),
     *          YDAT(NAT,MAXANG,MXGRID),ZDAT(NAT,MAXANG,MXGRID),
     *          RSQRD(*),
     *          ATMXVEC(NAT,NAT),ATMYVEC(NAT,NAT),ATMZVEC(NAT,NAT),
     *          WGHT(NAT,MAXANG,MXGRID),RI(NAT),RIJ(NAT,NAT),
     *          WTINTR(NAT), AIJ(NAT,NAT),WTRAD(*),UVEC(3,NAT),
     *          DWTINT(3,NAT,NAT), DWTTOT(3,NAT),DTOTWT(3,NAT)
C
      RAD = BRAGGRAD(NCNTR)
      NPT=NRAD*MAXANG
C
      THRV1=ZERO
      THRV2=1.0D+00
      IF(DFTGTHR.GT.1.01D+00) THEN
        THRV2=DFTGTHR
      ELSE IF(DFTGTHR.LT.0.99D+00) THEN
        THRV1=DFTGTHR
      ENDIF
      IF(DFTTHR.LT.1.1D-15.AND.DFTTHR.NE.ZERO) THRV1=1.0D-15
C     WCUTOFF=3.0D-05/NPT/THRV2
      RCUTOFF=1.0D-02/NPT/THRV2
      IF(THRV1.NE.ZERO) THEN
C        THRV1=1.0D-15
C        WCUTOFF=THRV1
         RCUTOFF=THRV1
      ENDIF
      WCUTOFF=1.0D-08/(NPT*NAT)
      RCUTOFF=CONVHF/(NPT*NAT)
C
C     ---- SYMMETRY MULTIPLICATION FACTOR ----
C
C      FACT = IIFACT(NCNTR)*IFACTR(INC0)
      FACT=IFACTR(INC0)
C      FACT=1
C
C     DYNAMIC LOAD BALANCING: DIVIDE ALL POINTS INTO NGRAN*NPROC CHUNKS.
C     NGRAN CANNOT BE SET IN THE INPUT FILE. THEN EACH NODE GETS A CHUNK
C     AND TOILS IT OVER UNTIL READY TO ASK FOR MORE.
C
      LOOP=0
      IGRID=1
      NGRAN=20
      IF(NGRIDS.EQ.1) THEN
         NLOOP=NRAD*(IANGN(NCNTR,2,1)-IANGN(NCNTR,1,1)+1)
      ELSE
         NLOOP=NRAD*NTOTGRIDPOINTS(NCNTR)
      ENDIF
      MCHUNK=(NLOOP-1)/(NGRAN*NPROC)+1
      NEXT  = -1
      DLB = IBTYP.EQ.1
C***********************************************************************
C     LOOP OVER RADIAL GRIDS
C     LOOP OVER ANGULAR GRIDS
C***********************************************************************
      DO 20 IRADPT = 1, NRAD
C
        RADWT=RAD*RAD*RAD*WTRAD(IRADPT)
        R1= RAD*PTRAD(IRADPT)
        IF(R1.GE.PRUNERADS(IGRID,IPRUNECUTS(NCNTR))*RAD) THEN
           IGRID = IGRID + 1
        ENDIF
C        WRITE(IW,'(A,I5,2F20.10,I5)')'RAD,PT,IGRID = ',IRADPT,RAD,
C     *       PTRAD(IRADPT),IGRID
        DO 10 IANGPT = IANGN(NCNTR,1,IGRID), IANGN(NCNTR,2,IGRID)
           IPT=(IRADPT-1)*NAPTS(NCNTR)+IANGPT
C
          IF(GOPARR) THEN
            IF(DLB) THEN
              LOOP=LOOP+1
              ICHUNK=(LOOP-1)/MCHUNK
              IF(ICHUNK.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
              IF(NEXT.NE.ICHUNK) GOTO 10
            ELSE
              IF(MOD(IPT,NPROC).NE.ME) GOTO 10
            ENDIF
          ENDIF
          IPTME=(IPT-1)/NPROC+1
          IF(DLB) IPTME=IPT
C
          FTOTWT = TOTWT(NCNTR,IPTME)*FACT
          FTOTWT0=FTOTWT/FACT
          IF(FTOTWT0.LT.WCUTOFF) THEN
             GOTO 10
          ELSE
             IGPT=IGPT+1
          ENDIF
C
C         THIS NEEDS TO BE INVERTED
          XD=R1*XDAT(NCNTR,IANGPT,IGRID)
          YD=R1*YDAT(NCNTR,IANGPT,IGRID)
          ZD=R1*ZDAT(NCNTR,IANGPT,IGRID)
          DO 610 IATM=1,NAT
            XCDNT=ATMXVEC(NCNTR,IATM)+XD
            YCDNT=ATMYVEC(NCNTR,IATM)+YD
            ZCDNT=ATMZVEC(NCNTR,IATM)+ZD
            RSQRD(IATM)=XCDNT**2+YCDNT**2+ZCDNT**2
C
C           NORMALISE THE R(A) VECTOR, = R(I)-R(A)
C
            RI(IATM)=SQRT(RSQRD(IATM))
            UVEC(1,IATM) = XCDNT / RI(IATM)
            UVEC(2,IATM) = YCDNT / RI(IATM)
            UVEC(3,IATM) = ZCDNT / RI(IATM)
C
  610     CONTINUE
C
          IF(DRHOI_(IGPT,1,1).LT.RCUTOFF .AND.
     *       DRHOI_(IGPT,1,2).LT.RCUTOFF) GO TO 10
C
C         COMPUTE THE WEIGHT DERIVATIVE.
C
          WGHTNOW=WGHT(NCNTR,IANGPT,IGRID)
          NITR=4
          CALL GRDOCT(NAT,NITR,NCNTR,ATMXVEC,ATMYVEC,ATMZVEC,RI,RIJ,AIJ,
     *          WGHTNOW,RADWT,WTINTR,UVEC,DWTINT,DWTTOT,DTOTWT)
C
C         ADD THE WEIGHT DERIVATIVE CONTRIBUTION
C
          ENER=GRDFUN(IGPT)*FACT
          CALL DAXPY(3*NAT,ENER,DTOTWT,1,DE,1)
C
C     ----- THE TOTAL ELCTRON DENSITY -----
C
          TOTELE=TOTELE+FTOTWT*(DRHOI_(IGPT,1,1)+DRHOI_(IGPT,1,2))
C
C     ----- END LOOP 10 OVER ANGULAR POINT -----
C     ----- END LOOP 20 OVER RADIAL POINT -----
C
   10   CONTINUE
   20 CONTINUE
      RETURN
      END
C*MODULE DFTGRD  *DECK GRDWT
C>    @brief Writes grid information to disk
C
      SUBROUTINE GRDWT(NFT,XYZ,WGT,IATM,NPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION XYZ(3,NPT),WGT(NPT),IATM(NPT)
      LOGICAL GOPARR,DSKWRK,MASWRK,DSKSAV
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DSKSAV=DSKWRK
      DSKWRK=.TRUE.
      CALL SEQOPN(NFT,'DFTGRID','UNKNOWN',.FALSE.,'UNFORMATTED')
      WRITE(NFT) NPT
      IF(NPT.GT.0) THEN
         WRITE(NFT) XYZ
         WRITE(NFT) WGT
         WRITE(NFT) IATM
      ENDIF
      CALL SEQCLO(NFT,'KEEP')
      DSKWRK=DSKSAV
      RETURN
      END
C*MODULE DFTGRD  *DECK GRDRD
C>    @brief Reads grid information from disk
C
      SUBROUTINE GRDRD(NFT,XYZ,WGT,IATM,NPT,MODE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION XYZ(3,*),WGT(*),IATM(*)
      LOGICAL GOPARR,DSKWRK,MASWRK,DSKSAV
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DSKSAV=DSKWRK
      DSKWRK=.TRUE.
      CALL SEQOPN(NFT,'DFTGRID','UNKNOWN',.FALSE.,'UNFORMATTED')
      READ(NFT) NPT
      IF(NPT.GT.0) THEN
         READ(NFT) (XYZ(1,IPT),XYZ(2,IPT),XYZ(3,IPT),IPT=1,NPT)
         READ(NFT) (WGT(  IPT),IPT=1,NPT)
         IF(MODE.GT.0) READ(NFT) (IATM( IPT),IPT=1,NPT)
      ENDIF
      CALL SEQCLO(NFT,'KEEP')
      DSKWRK=DSKSAV
      RETURN
      END
C*MODULE DFTGRD  *DECK GRDGAO
C
C>    @brief : Determine gradient density
C>
C>    @date  : December 21, 2012 - Joe Ivanic
C>             Modify to work with h,i functions in basis sets
C
      SUBROUTINE GRDGAO(IST,IEND,XYZGRD,XYZCHI,AOMAX,NDIM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=2000)
      PARAMETER (MXSH=5000, MXGTOT=20000)
      LOGICAL NORM
      LOGICAL DBUG
      LOGICAL OUT
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /XYZCHI/ XCHI,YCHI,ZCHI,X0,Y0,Z0,XI,YI,ZI,NI
      DIMENSION XYZGRD(3,*),XYZCHI(4,NDIM,*)
      DIMENSION AOMAX(NDIM)
      DIMENSION DI(28)
      DIMENSION   XG(9),  YG(9),  ZG(9)
      DIMENSION  DXG(7), DYG(7), DZG(7)
      DIMENSION DDXG(7),DDYG(7),DDZG(7)
      DIMENSION IJX(84),IJY(84),IJZ(84)
      DATA ZERO  /0.0D+00/
      DATA RLN10 /2.30258D+00/
      DATA SQRT3 /1.73205080756888D+00/
      DATA SQRT5 /2.23606797749979D+00/
      DATA SQRT7 /2.64575131106459D+00/
      DATA sqrt9 /3.0d+00/
      DATA sqrt11 /3.3166247903553998d+00/
C
      DATA IJX    / 1, 2, 1, 1, 3, 1, 1, 2, 2, 1,
     1              4, 1, 1, 3, 3, 2, 1, 2, 1, 2,
     2              5, 1, 1, 4, 4, 2, 1, 2, 1, 3,
     3              3, 1, 3, 2, 2,
     4              6, 1, 1, 5, 5, 2, 1, 2, 1, 4,
     5              4, 3, 1, 3, 1, 4, 2, 2, 3, 3,
     6              2,
     7              7, 1, 1, 6, 6, 2, 1, 2, 1, 5,
     8              5, 3, 1, 3, 1, 5, 2, 2, 4, 4,
     9              1, 4, 4, 3, 2, 3, 2, 3/

      DATA IJY    / 1, 1, 2, 1, 1, 3, 1, 2, 1, 2,
     1              1, 4, 1, 2, 1, 3, 3, 1, 2, 2,
     2              1, 5, 1, 2, 1, 4, 4, 1, 2, 3,
     3              1, 3, 2, 3, 2,
     4              1, 6, 1, 2, 1, 5, 5, 1, 2, 3,
     5              1, 4, 4, 1, 3, 2, 4, 2, 3, 2,
     6              3,
     7              1, 7, 1, 2, 1, 6, 6, 1, 2, 3,
     8              1, 5, 5, 1, 3, 2, 5, 2, 4, 1,
     9              4, 3, 2, 4, 4, 2, 3, 3/

      DATA IJZ    / 1, 1, 1, 2, 1, 1, 3, 1, 2, 2,
     1              1, 1, 4, 1, 2, 1, 2, 3, 3, 2,
     2              1, 1, 5, 1, 2, 1, 2, 4, 4, 1,
     3              3, 3, 2, 2, 3,
     4              1, 1, 6, 1, 2, 1, 2, 5, 5, 1,
     5              3, 1, 3, 4, 4, 2, 2, 4, 2, 3,
     6              3,
     7              1, 1, 7, 1, 2, 1, 2, 6, 6, 1,
     8              3, 1, 3, 5, 5, 2, 2, 5, 1, 4,
     9              4, 2, 3, 2, 3, 4, 4, 3/
C
      DBUG=.FALSE.
      OUT =.FALSE.
      OUT =OUT.OR.DBUG
      OUT =OUT.OR.NPRINT.EQ.6
C
      NDER=1
C
      TOL =RLN10*ITOL
      NORM=NORMF.NE.1.OR.NORMP.NE.1
C
      IMAX=IEND-IST+1
      DO IIPT=1,IMAX
         DO ICHI=1,NUM
            DO I=1,4
               XYZCHI(I,ICHI,IIPT)=ZERO
            ENDDO
         END DO
      END DO
C
C     ----- ISHELL -----
C
      DO 9000 II=1,NSHELL
      I=KATOM(II)
      XI=C(1,I)
      YI=C(2,I)
      ZI=C(3,I)
      I1=KSTART(II)
      I2=I1+KNG(II)-1
      LIT=KTYPE(II)
      MINI=KMIN(II)
      MAXI=KMAX(II)
      LOCI=KLOC(II)-MINI
C
C     ----- I PRIMITIVE -----
C
      DO 7000 IG=I1,I2
      AI=EX(IG)
      CSI=CS(IG)
      CPI=CP(IG)
      CDI=CD(IG)
      CFI=CF(IG)
      CGI=CG(IG)
      CHI=CH(IG)
      CII=CI(IG)
C
C     ----- DENSITY FACTOR -----
C
      INUM=0
      DO I=MINI,MAXI
      GO TO (110,120,220,220,130,220,220,140,220,220,
     1       150,220,220,160,220,220,220,220,220,170,
     2       180,220,220,190,220,220,220,220,220,200,
     3       220,220,210,220,220,
c h
     4       310,220,220,
     4       320,220,220,220,220,220,
     4       330,220,220,220,220,220,
     4       340,220,220,
     4       350,220,220,
c i
     5       410,220,220,
     5       420,220,220,220,220,220,
     5       430,220,220,220,220,220,  
     5       440,220,220,
     5       450,220,220,
     5       460,220,220,220,220,220,
     5       470),I
c
  110 DUM1=CSI
      GO TO 220
  120 DUM1=CPI
      GO TO 220
  130 DUM1=CDI
      GO TO 220
  140 IF(NORM) DUM1=DUM1*SQRT3
      GO TO 220
  150 DUM1=CFI
      GO TO 220
  160 IF(NORM) DUM1=DUM1*SQRT5
      GO TO 220
  170 IF(NORM) DUM1=DUM1*SQRT3
      GO TO 220
  180 DUM1=CGI
      GO TO 220
  190 IF(NORM) DUM1=DUM1*SQRT7
      GO TO 220
  200 IF(NORM) DUM1=DUM1*SQRT5/SQRT3
      GO TO 220
  210 IF(NORM) DUM1=DUM1*SQRT3
      GOTO 220
c h
  310 DUM1=CHI
      GOTO 220 
  320 IF(NORM) DUM1=DUM1*SQRT9 
      GOTO 220
  330 IF(NORM) DUM1=DUM1*SQRT7/SQRT3
      GOTO 220
  340 IF(NORM) DUM1=DUM1*SQRT3
      GOTO 220
  350 IF(NORM) DUM1=DUM1*SQRT5/SQRT3
      GOTO 220
c i
  410 DUM1=CII
      GOTO 220 
  420 IF(NORM) DUM1=DUM1*SQRT11
      GOTO 220
  430 IF(NORM) DUM1=DUM1*SQRT9/SQRT3
      GOTO 220
  440 IF(NORM) DUM1=DUM1*SQRT3
      GOTO 220
  450 IF(NORM) DUM1=DUM1*SQRT7/(SQRT3*SQRT5)
      GOTO 220
  460 IF(NORM) DUM1=DUM1*SQRT5
      GOTO 220
  470 IF(NORM) DUM1=DUM1*SQRT5/SQRT3
  220 CONTINUE
C
         INUM=INUM+1
         DI(INUM)=DUM1
      ENDDO
C
C     ----- LOOP OVER POINTS TO BE EVALUATED -----
C
      DO IPT=IST,IEND
      IIPT=IPT-IST+1
         X0 = XYZGRD(1,IPT)
         Y0 = XYZGRD(2,IPT)
         Z0 = XYZGRD(3,IPT)
C
         DUM = AI*((X0-XI)**2+(Y0-YI)**2+(Z0-ZI)**2)
         IF(DUM.LE.TOL) THEN
            FAC = EXP(-DUM)
C
C     ----- BASIS FUNCTIONS VALUES -----
C
            DO I=1,LIT+NDER
               NI=I
               CALL CHIXYZ
               XG(I)=XCHI
               YG(I)=YCHI
               ZG(I)=ZCHI
            ENDDO
            CALL DCHXYZ(AI,XG,YG,ZG,DXG,DYG,DZG,DDXG,DDYG,DDZG,
     1                  LIT,NDER)
            INUM=0
            DO I=MINI,MAXI
               IX=IJX(I)
               IY=IJY(I)
               IZ=IJZ(I)
               INUM=INUM+1
               BAS =FAC*DI(INUM)* XG(IX)* YG(IY)* ZG(IZ)
               BASX=FAC*DI(INUM)*DXG(IX)* YG(IY)* ZG(IZ)
               BASY=FAC*DI(INUM)* XG(IX)*DYG(IY)* ZG(IZ)
               BASZ=FAC*DI(INUM)* XG(IX)* YG(IY)*DZG(IZ)
               XYZCHI(1,LOCI+I,IIPT)=XYZCHI(1,LOCI+I,IIPT)+BAS
               XYZCHI(2,LOCI+I,IIPT)=XYZCHI(2,LOCI+I,IIPT)+BASX
               XYZCHI(3,LOCI+I,IIPT)=XYZCHI(3,LOCI+I,IIPT)+BASY
               XYZCHI(4,LOCI+I,IIPT)=XYZCHI(4,LOCI+I,IIPT)+BASZ
            ENDDO
         ENDIF
      ENDDO
C
 7000 CONTINUE
 9000 CONTINUE
C
C     -- CLEAR
      CALL VCLR(AOMAX,1,NDIM)
C     -- GRID LOOP
      DO 10 I=1,NDIM
      DO 10 IPT=IST,IEND
       IIPT=IPT-IST+1
       DUM=ABS(XYZCHI(1,I,IIPT))
       IF(DUM.GT.AOMAX(I)) AOMAX(I)=DUM
   10 CONTINUE
C     -- GRID LOOP END
C
      RETURN
      END
C*MODULE DFTGRD  *DECK GRDGGAO
C
C>    @brief : Determine gradient density
C>
C>    @date  : December 21, 2012 - Joe Ivanic
C>             Modify to work with h,i functions in basis sets
C
      SUBROUTINE GRDGGAO(IST,IEND,XYZGRD,XYZCHI,AOMAX,NDIM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=2000)
      PARAMETER (MXSH=5000, MXGTOT=20000)
      LOGICAL NORM
      LOGICAL DBUG
      LOGICAL OUT
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON/XYZCHI/XCHI,YCHI,ZCHI,X0,Y0,Z0,XI,YI,ZI,NI
      DIMENSION XYZGRD(3,*),XYZCHI(10,NDIM,*)
      DIMENSION AOMAX(NDIM)
      DIMENSION DI(28)
      DIMENSION   XG(9),  YG(9),  ZG(9)
      DIMENSION  DXG(7), DYG(7), DZG(7)
      DIMENSION DDXG(7),DDYG(7),DDZG(7)
      DIMENSION IJX(84),IJY(84),IJZ(84)
C
      DATA ZERO  /0.0D+00/
      DATA RLN10 /2.30258D+00/
      DATA SQRT3 /1.73205080756888D+00/
      DATA SQRT5 /2.23606797749979D+00/
      DATA SQRT7 /2.64575131106459D+00/
      DATA sqrt9 /3.0d+00/
      DATA sqrt11 /3.3166247903553998d+00/
C
      DATA IJX    / 1, 2, 1, 1, 3, 1, 1, 2, 2, 1,
     1              4, 1, 1, 3, 3, 2, 1, 2, 1, 2,
     2              5, 1, 1, 4, 4, 2, 1, 2, 1, 3,
     3              3, 1, 3, 2, 2,
     4              6, 1, 1, 5, 5, 2, 1, 2, 1, 4,
     5              4, 3, 1, 3, 1, 4, 2, 2, 3, 3,
     6              2,
     7              7, 1, 1, 6, 6, 2, 1, 2, 1, 5,
     8              5, 3, 1, 3, 1, 5, 2, 2, 4, 4,
     9              1, 4, 4, 3, 2, 3, 2, 3/
      DATA IJY    / 1, 1, 2, 1, 1, 3, 1, 2, 1, 2,
     1              1, 4, 1, 2, 1, 3, 3, 1, 2, 2,
     2              1, 5, 1, 2, 1, 4, 4, 1, 2, 3,
     3              1, 3, 2, 3, 2,
     4              1, 6, 1, 2, 1, 5, 5, 1, 2, 3,
     5              1, 4, 4, 1, 3, 2, 4, 2, 3, 2,
     6              3,
     7              1, 7, 1, 2, 1, 6, 6, 1, 2, 3,
     8              1, 5, 5, 1, 3, 2, 5, 2, 4, 1,
     9              4, 3, 2, 4, 4, 2, 3, 3/
      DATA IJZ    / 1, 1, 1, 2, 1, 1, 3, 1, 2, 2,
     1              1, 1, 4, 1, 2, 1, 2, 3, 3, 2,
     2              1, 1, 5, 1, 2, 1, 2, 4, 4, 1,
     3              3, 3, 2, 2, 3,
     4              1, 1, 6, 1, 2, 1, 2, 5, 5, 1,
     5              3, 1, 3, 4, 4, 2, 2, 4, 2, 3,
     6              3,
     7              1, 1, 7, 1, 2, 1, 2, 6, 6, 1,
     8              3, 1, 3, 5, 5, 2, 2, 5, 1, 4,
     9              4, 2, 3, 2, 3, 4, 4, 3/
C
      DBUG=.FALSE.
      OUT =.FALSE.
      OUT =OUT.OR.DBUG
      OUT =OUT.OR.NPRINT.EQ.6
C
      NDER=2
C
      TOL =RLN10*ITOL
      NORM=NORMF.NE.1.OR.NORMP.NE.1
C
      IMAX=IEND-IST+1
      DO IIPT=1,IMAX
         DO ICHI=1,NUM
            DO I=1,10
               XYZCHI(I,ICHI,IIPT)=ZERO
            ENDDO
         ENDDO
      ENDDO
C
C     ----- ISHELL -----
C
      DO 9000 II=1,NSHELL
      I=KATOM(II)
      XI=C(1,I)
      YI=C(2,I)
      ZI=C(3,I)
      I1=KSTART(II)
      I2=I1+KNG(II)-1
      LIT=KTYPE(II)
      MINI=KMIN(II)
      MAXI=KMAX(II)
      LOCI=KLOC(II)-MINI
C
C     ----- I PRIMITIVE -----
C
      DO 7000 IG=I1,I2
      AI=EX(IG)
      CSI=CS(IG)
      CPI=CP(IG)
      CDI=CD(IG)
      CFI=CF(IG)
      CGI=CG(IG)
      CHI=CH(IG)
      CII=CI(IG)
C
C     ----- DENSITY FACTOR -----
C
      INUM=0
      DO I=MINI,MAXI
      GO TO (110,120,220,220,130,220,220,140,220,220,
     1       150,220,220,160,220,220,220,220,220,170,
     2       180,220,220,190,220,220,220,220,220,200,
     3       220,220,210,220,220,
c h
     4       310,220,220,
     4       320,220,220,220,220,220,
     4       330,220,220,220,220,220,
     4       340,220,220,
     4       350,220,220,
c i
     5       410,220,220,
     5       420,220,220,220,220,220,
     5       430,220,220,220,220,220,
     5       440,220,220,
     5       450,220,220,
     5       460,220,220,220,220,220,
     5       470),I
c
  110 DUM1=CSI
      GO TO 220
  120 DUM1=CPI
      GO TO 220
  130 DUM1=CDI
      GO TO 220
  140 IF(NORM) DUM1=DUM1*SQRT3
      GO TO 220
  150 DUM1=CFI
      GO TO 220
  160 IF(NORM) DUM1=DUM1*SQRT5
      GO TO 220
  170 IF(NORM) DUM1=DUM1*SQRT3
      GO TO 220
  180 DUM1=CGI
C
      GO TO 220
  190 IF(NORM) DUM1=DUM1*SQRT7
      GO TO 220
  200 IF(NORM) DUM1=DUM1*SQRT5/SQRT3
      GO TO 220
  210 IF(NORM) DUM1=DUM1*SQRT3
      GOTO 220
c h
  310 DUM1=CHI
      GOTO 220
  320 IF(NORM) DUM1=DUM1*SQRT9
      GOTO 220
  330 IF(NORM) DUM1=DUM1*SQRT7/SQRT3
      GOTO 220
  340 IF(NORM) DUM1=DUM1*SQRT3
      GOTO 220
  350 IF(NORM) DUM1=DUM1*SQRT5/SQRT3
      GOTO 220
c i
  410 DUM1=CII
      GOTO 220
  420 IF(NORM) DUM1=DUM1*SQRT11
      GOTO 220
  430 IF(NORM) DUM1=DUM1*SQRT9/SQRT3
      GOTO 220
  440 IF(NORM) DUM1=DUM1*SQRT3
      GOTO 220
  450 IF(NORM) DUM1=DUM1*SQRT7/(SQRT3*SQRT5)
      GOTO 220
  460 IF(NORM) DUM1=DUM1*SQRT5
      GOTO 220
  470 IF(NORM) DUM1=DUM1*SQRT5/SQRT3
  220 CONTINUE
C
         INUM=INUM+1
         DI(INUM)=DUM1
      ENDDO
C
C     ----- LOOP OVER POINTS TO BE EVALUATED -----
C
      DO IPT=IST,IEND
      IIPT=IPT-IST+1
         X0 = XYZGRD(1,IPT)
         Y0 = XYZGRD(2,IPT)
         Z0 = XYZGRD(3,IPT)
C
         DUM = AI*((X0-XI)**2+(Y0-YI)**2+(Z0-ZI)**2)
         IF(DUM.LE.TOL) THEN
            FAC = EXP(-DUM)
C
C     ----- BASIS FUNCTIONS VALUES -----
C
            DO I=1,LIT+NDER
               NI=I
               CALL CHIXYZ
               XG(I)=XCHI
               YG(I)=YCHI
               ZG(I)=ZCHI
            ENDDO
            CALL DCHXYZ(AI,XG,YG,ZG,DXG,DYG,DZG,DDXG,DDYG,DDZG,
     1                  LIT,NDER)
            INUM=0
            DO I=MINI,MAXI
               IX=IJX(I)
               IY=IJY(I)
               IZ=IJZ(I)
               INUM=INUM+1
               BAS  =FAC*DI(INUM)*  XG(IX)*  YG(IY)*  ZG(IZ)
               BASX =FAC*DI(INUM)* DXG(IX)*  YG(IY)*  ZG(IZ)
               BASY =FAC*DI(INUM)*  XG(IX)* DYG(IY)*  ZG(IZ)
               BASZ =FAC*DI(INUM)*  XG(IX)*  YG(IY)* DZG(IZ)
               BASXX=FAC*DI(INUM)*DDXG(IX)*  YG(IY)*  ZG(IZ)
               BASYY=FAC*DI(INUM)*  XG(IX)*DDYG(IY)*  ZG(IZ)
               BASZZ=FAC*DI(INUM)*  XG(IX)*  YG(IY)*DDZG(IZ)
               BASXY=FAC*DI(INUM)* DXG(IX)* DYG(IY)*  ZG(IZ)
               BASXZ=FAC*DI(INUM)* DXG(IX)*  YG(IY)* DZG(IZ)
               BASYZ=FAC*DI(INUM)*  XG(IX)* DYG(IY)* DZG(IZ)
               XYZCHI( 1,LOCI+I,IIPT)=XYZCHI( 1,LOCI+I,IIPT)+BAS
               XYZCHI( 2,LOCI+I,IIPT)=XYZCHI( 2,LOCI+I,IIPT)+BASX
               XYZCHI( 3,LOCI+I,IIPT)=XYZCHI( 3,LOCI+I,IIPT)+BASY
               XYZCHI( 4,LOCI+I,IIPT)=XYZCHI( 4,LOCI+I,IIPT)+BASZ
               XYZCHI( 5,LOCI+I,IIPT)=XYZCHI( 5,LOCI+I,IIPT)+BASXX
               XYZCHI( 6,LOCI+I,IIPT)=XYZCHI( 6,LOCI+I,IIPT)+BASYY
               XYZCHI( 7,LOCI+I,IIPT)=XYZCHI( 7,LOCI+I,IIPT)+BASZZ
               XYZCHI( 8,LOCI+I,IIPT)=XYZCHI( 8,LOCI+I,IIPT)+BASXY
               XYZCHI( 9,LOCI+I,IIPT)=XYZCHI( 9,LOCI+I,IIPT)+BASXZ
               XYZCHI(10,LOCI+I,IIPT)=XYZCHI(10,LOCI+I,IIPT)+BASYZ
            ENDDO
         ENDIF
      ENDDO
C
 7000 CONTINUE
 9000 CONTINUE
C
C     -- CLEAR
      CALL VCLR(AOMAX,1,NDIM)
C     -- GRID LOOP
      DO 10 I=1,NDIM
      DO 10 IPT=IST,IEND
       IIPT=IPT-IST+1
       DUM=ABS(XYZCHI(1,I,IIPT))
       IF(DUM.GT.AOMAX(I)) AOMAX(I)=DUM
   10 CONTINUE
C     -- GRID LOOP END
C
      RETURN
      END
C*MODULE DFTGRD  *DECK DCHXYZ
      SUBROUTINE DCHXYZ(A,XG,YG,ZG,DXG,DYG,DZG,DDXG,DDYG,DDZG,
     1                  N,NDER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION   XG(*),  YG(*),  ZG(*)
      DIMENSION  DXG(*), DYG(*), DZG(*)
      DIMENSION DDXG(*),DDYG(*),DDZG(*)
      DATA TWO   /2.0D+00/
      DATA THREE /3.0D+00/
      DATA FOUR  /4.0D+00/
      A2=TWO*A
      DXG(1)=-A2*XG(2)
      DYG(1)=-A2*YG(2)
      DZG(1)=-A2*ZG(2)
      IF(N.GT.1) THEN
         DO I=2,N
            DXG(I)=(I-1)*XG(I-1)-A2*XG(I+1)
            DYG(I)=(I-1)*YG(I-1)-A2*YG(I+1)
            DZG(I)=(I-1)*ZG(I-1)-A2*ZG(I+1)
         ENDDO
      ENDIF
      IF(NDER.EQ.2) THEN
         A4=FOUR*A*A
         DDXG(1)=-A2*XG(1)+A4*XG(3)
         DDYG(1)=-A2*YG(1)+A4*YG(3)
         DDZG(1)=-A2*ZG(1)+A4*ZG(3)
         IF(N.GT.1) THEN
            DDXG(2)=-THREE*A2*XG(2)+A4*XG(4)
            DDYG(2)=-THREE*A2*YG(2)+A4*YG(4)
            DDZG(2)=-THREE*A2*ZG(2)+A4*ZG(4)
            IF(N.GT.2) THEN
               DO I=3,N
                  DDXG(I)=((I-1)*(I-2))   *XG(I-2)
     1                   -( I-1 + I   )*A2*XG(I  )
     2                   +              A4*XG(I+2)
                  DDYG(I)=((I-1)*(I-2))   *YG(I-2)
     1                   -( I-1 + I   )*A2*YG(I  )
     2                   +              A4*YG(I+2)
                  DDZG(I)=((I-1)*(I-2))   *ZG(I-2)
     1                   -( I-1 + I   )*A2*ZG(I  )
     2                   +              A4*ZG(I+2)
               ENDDO
            ENDIF
         ENDIF
      ENDIF
      RETURN
      END
C*MODULE DFTGRD  *DECK CHIXYZ
      SUBROUTINE CHIXYZ
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/XYZCHI/XCHI,YCHI,ZCHI,X0,Y0,Z0,XI,YI,ZI,NI
      DATA ONE /1.0D+00/
C
      XCHI=ONE
      YCHI=ONE
      ZCHI=ONE
      PTXI=X0-XI
      PTYI=Y0-YI
      PTZI=Z0-ZI
      GO TO (7,6,5,4,3,2,1),NI
    1 XCHI=XCHI*PTXI
      YCHI=YCHI*PTYI
      ZCHI=ZCHI*PTZI
    2 XCHI=XCHI*PTXI
      YCHI=YCHI*PTYI
      ZCHI=ZCHI*PTZI
    3 XCHI=XCHI*PTXI
      YCHI=YCHI*PTYI
      ZCHI=ZCHI*PTZI
    4 XCHI=XCHI*PTXI
      YCHI=YCHI*PTYI
      ZCHI=ZCHI*PTZI
    5 XCHI=XCHI*PTXI
      YCHI=YCHI*PTYI
      ZCHI=ZCHI*PTZI
    6 XCHI=XCHI*PTXI
      YCHI=YCHI*PTYI
      ZCHI=ZCHI*PTZI
    7 CONTINUE
      RETURN
      END
C*MODULE DFTGRD  *DECK GRDOCT
C>    @brief Compute weight (cell volume) derivatives
C>
C>    @details THE FORMULAE AND NOTATION ARE TAKEN FROM
C>     JOHNSON ET AL, JCP 98, 5612 (1993)
C>
C>     THE RESULS ARE PUT INTO DW.
C>
C>     THRESHOLDS FOR THE REMARK 62 IN THE ABOVE REFERENCE. IT
C>     CORRESPONDS TO A*B/B, WHEN B IS ZERO. DIVISION BY B IS AVOIDED
C>     FOR B LESS THAN THRETH (AND THUS ASSIGNING A THE VALUE OF ZERO).
C>     THIS RELIES ON A BEING ZERO WHENEVER B IS ZERO, WHICH APPEARS TO
C>     BE TRUE ALGEBRAICALLY. IF |A|>THRETH1, THEN THE CODE ABORTS.
C>     IF IT IS FOUND THAT THIS HAPPENS, IT WOULD BE NECESSARY TO
C>     CALCULATE A EXPLICITLY AND AVOID *B/B, WHICH, HOWEVER, IS A BIT
C>     OF WORK.  (NOTE G4 BELOW IS NOT A, BUT A IS PROPORTIONAL TO G4)
C
      SUBROUTINE GRDOCT(NAT,NITR,NCNTR,ATMXVEC,ATMYVEC,ATMZVEC,RI,RIJ,
     *                  AIJ,WGHT,RADWT,P,UVEC,DP,DZ,DW)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00,TWO=2.0D+00)
C
      DIMENSION ATMXVEC(NAT,NAT),ATMYVEC(NAT,NAT),ATMZVEC(NAT,NAT),
     *          RI(NAT),RIJ(NAT,NAT),P(NAT),AIJ(NAT,NAT),
     *          UVEC(3,NAT),DMUJI(3),DP(3,NAT,NAT),DZ(3,NAT),DW(3,NAT)
C
      THRETH=1.0D-12
      THRETH1=1.0D-08
C
      CALL DACOPY(NAT,ONE,P,1)
      CALL VCLR(DP,1,3*NAT*NAT)
      CALL VCLR(DZ,1,3*NAT)
      CALL VCLR(DW,1,3*NAT)
C
C        LOOP JATM RUNS OVER THE DERIVATIVE COORDINATES B
C        LOOP IATM RUNS OVER CENTRES A
C
         DO 611 JATM=1,NAT
            IF (ABS(AIJ(JATM,1)+1.0D+00).LT.1.0D-05) THEN
              P(JATM) = 0.0D+00
              GOTO 611
            ENDIF
            DO 612 IATM=1,NAT
               IF(IATM.EQ.JATM) GOTO 612
               IF(ABS(AIJ(JATM,IATM)-1.0D+00).LT.1.0D-05) GOTO 612
               RBA=RIJ(JATM,IATM)
C
C     COMPUTE HYPERBOLIC COORDINATES MU(B,A) (XMUJI)
C     AND MU'(B,A)=MU(B,A)+A(B,A)*(1-MU(B,A)**2)
C
               ZMUJI=(RI(JATM)-RI(IATM))/RBA
               XMUJI=ZMUJI+AIJ(JATM,IATM)*(ONE-ZMUJI*ZMUJI)
C              XMUJI=ZMUJI
C
C     BECKE'S FUZZY CELL METHOD FOR MOLECULAR GRID QUADRATURE
C       P1(MU)=P(MU)=3/2*MU-1/2*MU**3, PN(MU)=P(P{N-1}(MU))
C       CUTIJ=S(MUJI)=1/2*(1-PN(MU))
C
               F4=XMUJI
               G4=ONE
C
               DO K=1,NITR
                  G4= G4*(ONE-F4*F4)
                  F4= F4*(1.5D+00-0.5D+00*F4*F4)
               END DO
C
C              COMPUTE S(MU(A,B)) AND S(MU(B,A))
C
               F2   = 0.5D+00*F4
               CUTIJ= 0.5D+00+F2
               CUTJI= 0.5D+00-F2
               P(JATM)=P(JATM)*CUTJI
C
               IF(JATM.EQ.NCNTR) GOTO 612
C
C              THE CODE BELOW DOES NOT WORK FOR GRAD(B) X, FOR SOME X,
C              IN CASE OF B==NCNTR, DUE TO A MORE COMPLEX DERIVATIVE,
C              SO WE USE TRANSLATIONAL INVARIANCE INSTEAD
C              (X IS MU(B,A), P(B), W(A)).
C              THE LINES ASSIGNING ID WILL MAKE GRAD(B) MU(B,A) CORRECT
C              EVEN FOR B==NCNTR (WHICH WE DO NOT NORMALLY NEED).
C              GRAD(B) P(A) WILL HOWEVER STILL BE INCORRECT (B==NCNTR).
C              IF(JATM.EQ.NCNTR) THEN
C                 ID=IATM
C              ELSE
C                 ID=JATM
C              ENDIF
               ID=JATM
C
C              COMPUTE GRAD(B) MU'(B,A) = A * GRAD(B) MU(B,A)
C                      A = 1-2*A(B,A)*MU(B,A)
C
               A=ONE-TWO*AIJ(JATM,IATM)*ZMUJI
               B=ZMUJI/(RBA**2)
               DMUJI(1)=A*(-UVEC(1,ID)/RBA-B*ATMXVEC(JATM,IATM))
               DMUJI(2)=A*(-UVEC(2,ID)/RBA-B*ATMYVEC(JATM,IATM))
               DMUJI(3)=A*(-UVEC(3,ID)/RBA-B*ATMZVEC(JATM,IATM))
C              WRITE(6,*) 'MU=BA',XMUJI,'GRAD(B) MU(B,A)=',JATM,IATM,
C    >                    DMUJI(1),DMUJI(2),DMUJI(3)
C
C              COMPUTE D S(MU(B,A))/D MU(B,A)
C              THE COEFFICIENT IN DCOEFF=-1/2*(3/2)**NITR
C
               DCOEFF = -81.0D+00/32.0D+00*G4
C              DCOEFF = -27.0D+00/16.0D+00*G4
C
C              COMPUTE 1/P(A)*GRAD(B) P(A) (DP(1,IATM,JATM))
C
               IF (ABS(CUTIJ).GT.THRETH) THEN
                  DCUTIJ = DCOEFF/CUTIJ
                  DP(1,IATM,JATM)= -DCUTIJ*DMUJI(1)
                  DP(2,IATM,JATM)= -DCUTIJ*DMUJI(2)
                  DP(3,IATM,JATM)= -DCUTIJ*DMUJI(3)
              ELSE
                 IF(ABS(G4).GT.THRETH1) THEN
                    WRITE(6,*) 'G4',G4
                    CALL ABRT
                 ENDIF
              ENDIF
              IF (ABS(CUTJI).GT.THRETH) THEN
                 DCUTJI = DCOEFF/CUTJI
                 DP(1,JATM,JATM)=DP(1,JATM,JATM)+DCUTJI*DMUJI(1)
                 DP(2,JATM,JATM)=DP(2,JATM,JATM)+DCUTJI*DMUJI(2)
                 DP(3,JATM,JATM)=DP(3,JATM,JATM)+DCUTJI*DMUJI(3)
              ELSE
                 IF(ABS(G4).GT.THRETH1) THEN
                    WRITE(6,*) 'G4',G4
                    CALL ABRT
                 ENDIF
              ENDIF
 612       CONTINUE
 611    CONTINUE
C
C       COMPUTE Z (TOTAL WEIGHT)
C
        Z=ZERO
        DO IATM=1,NAT
          Z=Z+P(IATM)
        ENDDO
C       WRITE(6,*) '=Z',Z
C       ATMWT=P(NCNTR)/Z
        SPHWT=RADWT*WGHT
C       TOTWT=ATMWT*SPHWT
C       WRITE(6,*) 'W(A)',NCNTR,TOTWT
C       DO IATM=1,NAT
C         WRITE(6,*) 'P(A)',IATM,P(IATM)
C          DO JATM=1,NAT
C           WRITE(6,*) NCNTR,'=GRAD(B) P(A)',JATM,IATM,DP(1,IATM,JATM)
C    *        *P(IATM),DP(2,IATM,JATM)*P(IATM),DP(3,IATM,JATM)*P(IATM)
C         ENDDO
C       ENDDO
        WTC=P(NCNTR)/Z*SPHWT
C       IF(ABS(WTC).GT.WDCUTOFF) THEN
        DO 690 JATM=1,NAT
           IF (JATM.EQ.NCNTR) GOTO 690
C
C          COMPUTE GRAD(B) Z (DZ(*,JATM))
C
           DO IATM=1,NAT
              DZ(1,JATM)=DZ(1,JATM)+DP(1,IATM,JATM)*P(IATM)
              DZ(2,JATM)=DZ(2,JATM)+DP(2,IATM,JATM)*P(IATM)
              DZ(3,JATM)=DZ(3,JATM)+DP(3,IATM,JATM)*P(IATM)
           ENDDO
C          WRITE(6,*) '=GRAD(B) Z',JATM,DZ(1,JATM),DZ(2,JATM),
C    *                 DZ(3,JATM)
C
C          COMPUTE GRAD(B) W(NCNTR) (DW(*,JATM))
C          DERIVATIVE OF CELL VOLUMES
C
           DW(1,JATM)=WTC*(DP(1,NCNTR,JATM)-DZ(1,JATM)/Z)
           DW(2,JATM)=WTC*(DP(2,NCNTR,JATM)-DZ(2,JATM)/Z)
           DW(3,JATM)=WTC*(DP(3,NCNTR,JATM)-DZ(3,JATM)/Z)
C          WRITE(6,*) '==GRAD(B) W(A)',JATM,NCNTR,DW(1,JATM),
C    *                 DW(2,JATM),DW(3,JATM)
           DW(1,NCNTR)=DW(1,NCNTR)-DW(1,JATM)
           DW(2,NCNTR)=DW(2,NCNTR)-DW(2,JATM)
           DW(3,NCNTR)=DW(3,NCNTR)-DW(3,JATM)
 690    CONTINUE
C       ENDIF
C       DO JATM=1,NAT
C          WRITE(6,*) '==GRAD(B) W(A)',JATM,NCNTR,DW(1,JATM),
C    *                 DW(2,JATM),DW(3,JATM)
C       ENDDO
C
      RETURN
      END
C
C*MODULE DFTGRD  *DECK PRUNEPT
C>    @brief Sets up numerical grid
C>
C>    @details THIS ROUTINE SETS UP THE NUMERICAL LEBEDEV BASED GRID FOR
C>     DIFFERENT ABELIAN SYMMETRIES.
C>     CURRENTLY IMPLEMENTED WITHOUT OCTANT SYMMETRY
C>     EULER-MACLAURIN SCHEME, RADIAL INTEGRATION
C>     GAUSS-MARKOV QUADRATURE, ANGULAR INTEGRATION
C>     BECKE POLYATOMIC SCHEME
C
      SUBROUTINE PRUNEPT(NCNTR,WGHT,XDAT,YDAT,ZDAT,TXYZ,UXYZ,
     *                   TWGHT,ATMXVEC,ATMYVEC,ATMZVEC,
     *                   RI,RIJ,WTINTR,TOTWT,AIJ,
     *                   IANGN,NAPTS,PTRAD,WTRAD,
     *                   NRADPT,NLEBPT,MAXPTS,NGRIDS,WTAB)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000)
      PARAMETER (ONE=1.0D+00)
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /DFTEXC/ PI,CSLT,CB88,CLYP,CVWN,QOP,NEXFG,NCORFG,NPFFG,
     *                NXCFG
C
      DIMENSION WGHT(NAT,MAXPTS,NGRIDS),XDAT(NAT,MAXPTS,NGRIDS),
     *          YDAT(NAT,MAXPTS,NGRIDS),ZDAT(NAT,MAXPTS,NGRIDS),
     *          TXYZ(MAXPTS,3),NLEBPT(NGRIDS),
     *          UXYZ(3,MAXPTS),TWGHT(MAXPTS),
     *          ATMXVEC(NAT,NAT),ATMYVEC(NAT,NAT),ATMZVEC(NAT,NAT),
     *          RI(NAT),RIJ(NAT,NAT),WTINTR(NAT),
     *          TOTWT(NAT,*),AIJ(NAT,NAT),
     *          IANGN(NAT,2,NGRIDS),NAPTS(NAT),
     *          PTRAD(NRADPT),WTRAD(NRADPT),WTAB(NAT,NAT,*)
C
C     SET UP ATOMIC VECTORS AND THE SURFACE SHIFTING PARAMETER AIJ
C
      DO 6010 IATM=1,NAT
         AIJ(IATM,IATM) = 0.0D+00
         RADI = BRAGGRAD(IATM)
         IF(RADI.LT.0.001D+00) THEN
           AIJ(IATM,1)=-1.0D+00
           GOTO 6010
         ENDIF
         DO 6020 JATM=1,IATM-1
            RADJ = BRAGGRAD(JATM)
            IF(RADJ.LT.0.001D+00) THEN
              AIJ(IATM,JATM)= 1.0D+00
              GOTO 6020
            ENDIF
            CHI = RADI/RADJ
            CHI2=(CHI-ONE)/(CHI+ONE)
            AIJ(IATM,JATM)=CHI2/(CHI2*CHI2-ONE)
            IF(AIJ(IATM,JATM).GT. 0.5D+00) AIJ(IATM,JATM)= 0.5D+00
            IF(AIJ(IATM,JATM).LT.-0.5D+00) AIJ(IATM,JATM)=-0.5D+00
 6020 CONTINUE
         DO 6030 JATM=IATM+1,NAT
            RADJ = BRAGGRAD(JATM)
            IF(RADJ.LT.0.001D+00) THEN
              AIJ(IATM,JATM)= 1.0D+00
              GOTO 6030
            ENDIF
            CHI = RADI/RADJ
            CHI2=(CHI-ONE)/(CHI+ONE)
            AIJ(IATM,JATM)=CHI2/(CHI2*CHI2-ONE)
            IF(AIJ(IATM,JATM).GT. 0.5D+00) AIJ(IATM,JATM)= 0.5D+00
            IF(AIJ(IATM,JATM).LT.-0.5D+00) AIJ(IATM,JATM)=-0.5D+00
 6030 CONTINUE
 6010 CONTINUE
C***********************************************************************
C
C     NUMBER OF RADIAL POINTS
C
C***********************************************************************
      ITMP=NRADPT
C***********************************************************************
C
C     SET RADIAL GRID SCALING USING BRAGG-SLATER RADII
C
C***********************************************************************
      RAD = BRAGGRAD(NCNTR)
C
C**********************************************************************
C
C    GET THE UNIT LEBEDEV SPHERE
C
C*********************************************************************
C
      DO IGRID = 1,NGRIDS
         CALL LEBPTW(TXYZ, UXYZ, TWGHT, NLEBPT(IGRID), NLEBPT(IGRID))
         DO I = 1,NLEBPT(IGRID)
            XDAT(NCNTR,I,IGRID) = UXYZ(1,I)
            YDAT(NCNTR,I,IGRID) = UXYZ(2,I)
            ZDAT(NCNTR,I,IGRID) = UXYZ(3,I)
            WGHT(NCNTR,I,IGRID) = 4.0D0*PI*TWGHT(I)
            NAPTS(NCNTR) = MAXPTS
         ENDDO
         IANGN(NCNTR,1,IGRID) = 1
         IANGN(NCNTR,2,IGRID) = NLEBPT(IGRID)
      ENDDO
C
      CALL PRUNEOCT(ITMP,XDAT,YDAT,
     *     ZDAT,ATMXVEC,ATMYVEC,ATMZVEC,RI,RIJ,NAT,
     *     AIJ,WTINTR,TOTWT,WGHT,IANGN,
     *     NCNTR,RAD,PTRAD,WTRAD,WTAB)
C
      RETURN
      END
C
C*MODULE DFTGRD  *DECK LEBPT
      SUBROUTINE LEBPT(NCNTR,WGHT,XDAT,YDAT,ZDAT,TXYZ,UXYZ,
     *                 TWGHT,ATMXVEC,ATMYVEC,ATMZVEC,
     *                 RI,RIJ,WTINTR,TOTWT,AIJ,
     *                 IANGN,NAPTS,PTRAD,WTRAD,
     *                 NRADPT,NLEBPT,WTAB)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000)
      PARAMETER (ONE=1.0D+00)
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /DFTEXC/ PI,CSLT,CB88,CLYP,CVWN,QOP,NEXFG,NCORFG,NPFFG,
     *                NXCFG
C
      DIMENSION WGHT(NAT,NLEBPT),XDAT(NAT,NLEBPT),
     *          YDAT(NAT,NLEBPT),ZDAT(NAT,NLEBPT),TXYZ(NLEBPT,3),
     *          UXYZ(3,NLEBPT),TWGHT(NLEBPT),
     *          ATMXVEC(NAT,NAT),ATMYVEC(NAT,NAT),ATMZVEC(NAT,NAT),
     *          RI(NAT),RIJ(NAT,NAT),WTINTR(NAT),TOTWT(NAT,*),
     *          AIJ(NAT,NAT),IANGN(NAT,2),NAPTS(NAT),
     *          PTRAD(NRADPT),WTRAD(NRADPT),WTAB(NAT,NAT,*)
C
C=======================================================================
C     THIS ROUTINE SETS UP THE NUMERICAL LEBEDEV GRID FOR DIFFERENT
C     ABELIAN SYMMETRIES.
C     CURRENTLY IMPLEMENTED WITHOUT OCTANT SYMMETRY
C=======================================================================
C     EULER-MACLAURIN SCHEME, RADIAL INTEGRATION
C     GAUSS-MARKOV QUADRATURE, ANGULAR INTEGRATION
C     BECKE POLYATOMIC SCHEME
C
C     SET UP ATOMIC VECTORS AND CALCULATE THE SURFACE SHIFTING
C     PARAMETER AIJ
C
      DO 6010 IATM=1,NAT
         AIJ(IATM,IATM) = 0.0D+00
         RADI = BRAGGRAD(IATM)
         IF(RADI.LT.0.001D+00) THEN
           AIJ(IATM,1)=-1.0D+00
           GOTO 6010
         ENDIF
         DO 6020 JATM=1,IATM-1
            RADJ = BRAGGRAD(JATM)
            IF(RADJ.LT.0.001D+00) THEN
              AIJ(IATM,JATM)= 1.0D+00
              GOTO 6020
            ENDIF
            CHI = RADI/RADJ
            CHI2=(CHI-ONE)/(CHI+ONE)
            AIJ(IATM,JATM)=CHI2/(CHI2*CHI2-ONE)
            IF(AIJ(IATM,JATM).GT.0.5D+00) AIJ(IATM,JATM)=0.5D+00
            IF(AIJ(IATM,JATM).LT.-0.5D+00) AIJ(IATM,JATM)=-0.5D+00
 6020    CONTINUE
         DO 6030 JATM=IATM+1,NAT
            RADJ = BRAGGRAD(JATM)
            IF(RADJ.LT.0.001D+00) THEN
              AIJ(IATM,JATM)= 1.0D+00
              GOTO 6030
            ENDIF
            CHI = RADI/RADJ
            CHI2=(CHI-ONE)/(CHI+ONE)
            AIJ(IATM,JATM)=CHI2/(CHI2*CHI2-ONE)
            IF(AIJ(IATM,JATM).GT.0.5D+00) AIJ(IATM,JATM)=0.5D+00
            IF(AIJ(IATM,JATM).LT.-0.5D+00) AIJ(IATM,JATM)=-0.5D+00
 6030    CONTINUE
 6010 CONTINUE
C***********************************************************************
C
C     NUMBER OF RADIAL POINTS
C
C***********************************************************************
      ITMP=NRADPT
C***********************************************************************
C
C     SET RADIAL GRID SCALING USING BRAGG-SLATER RADII
C
C***********************************************************************
      RAD = BRAGGRAD(NCNTR)
C
C**********************************************************************
C
C    GET THE UNIT LEBEDEV SPHERE
C
C*********************************************************************
      CALL LEBPTW(TXYZ, UXYZ, TWGHT, NLEBPT, NLEBPT)
      DO I = 1,NLEBPT
         XDAT(NCNTR,I) = UXYZ(1,I)
         YDAT(NCNTR,I) = UXYZ(2,I)
         ZDAT(NCNTR,I) = UXYZ(3,I)
         WGHT(NCNTR,I) = 4.0D+00*PI*TWGHT(I)
      ENDDO
      NAPTS(NCNTR) = NLEBPT
      IANGN(NCNTR,1) = 1
      IANGN(NCNTR,2) = NLEBPT
C
      CALL OCT(ITMP,XDAT,YDAT,ZDAT,ATMXVEC,ATMYVEC,ATMZVEC,RI,RIJ,NAT,
     *         AIJ,WTINTR,TOTWT,WGHT,IANGN,NCNTR,RAD,NAPTS,PTRAD,WTRAD,
     *         WTAB)
      RETURN
      END
C
C*MODULE DFTGRD  *DECK GRDPT
C>    @brief Sets up numerical grid
C>
C>    @details THIS ROUTINE SETS UP THE NUMERICAL LEBEDEV BASED GRID FOR
C>     DIFFERENT ABELIAN SYMMETRIES.
C>     CURRENTLY IMPLEMENTED WITHOUT OCTANT SYMMETRY
C>     EULER-MACLAURIN SCHEME, RADIAL INTEGRATION
C>     GAUSS-MARKOV QUADRATURE, ANGULAR INTEGRATION
C>     BECKE POLYATOMIC SCHEME
C
      SUBROUTINE GRDPT(NCNTR,WGHT,XDAT,YDAT,ZDAT,
     *                 ATMXVEC,ATMYVEC,ATMZVEC,RI,RIJ,WTINTR,
     *                 TOTWT,AIJ,GLROOT,GLWGHT,
     *                 IANGN,IIFACT,NAPTS,PTRAD,WTRAD,
     *                 IQ2,IQ3,IQ4,IQ5,IQ6,IQ7,
     *                 NRADPT,NTHE,NPHI,OPTGRD,WTAB)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION WGHT(NAT,NTHE*NPHI),XDAT(NAT,NTHE*NPHI),
     >          YDAT(NAT,NTHE*NPHI),ZDAT(NAT,NTHE*NPHI),
     >          ATMXVEC(NAT,NAT),ATMYVEC(NAT,NAT),ATMZVEC(NAT,NAT),
     >          RI(NAT),RIJ(NAT,NAT),WTINTR(NAT),TOTWT(NAT,*),
     >          AIJ(NAT,NAT),GLROOT(NTHE,NTHE),GLWGHT(NTHE,NTHE),
     *          IANGN(NAT,2),IIFACT(NAT),NAPTS(NAT),
     *          PTRAD(NRADPT),WTRAD(NRADPT),
     *          WTAB(NAT,NAT,*)
C
      LOGICAL   OPTGRD,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXATM=2000,ONE=1.0D+00,TWO=2.0D+00,HALF=0.5D+00)
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /DFTEXC/ PI,CSLT,CB88,CLYP,CVWN,QOP,NEXFG,NCORFG,NPFFG,
     *                NXCFG
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      DATA CHECK/8HCHECK   /
C
      IF(EXETYP.EQ.CHECK) THEN
         CALL VCLR(AIJ,1,NAT*NAT)
         GO TO 810
      ENDIF
C
C     SET UP ATOMIC VECTORS AND CALCULATE THE SURFACE SHIFTING
C     PARAMETER AIJ
C
      IFACT = IIFACT(NCNTR)
      DO 6010 IATM=1,NAT
         AIJ(IATM,IATM) = 0.0D+00
         RADI = BRAGGRAD(IATM)
         IF(RADI.LT.0.001D+00) THEN
           AIJ(IATM,1)=-1.0D+00
           GOTO 6010
         ENDIF
         DO 6020 JATM=1,IATM-1
            RADJ = BRAGGRAD(JATM)
            IF(RADJ.LT.0.001D+00) THEN
              AIJ(IATM,JATM)= 1.0D+00
              GOTO 6020
            ENDIF
            CHI = RADI/RADJ
            CHI2=(CHI-ONE)/(CHI+ONE)
            AIJ(IATM,JATM)=CHI2/(CHI2*CHI2-ONE)
            IF(AIJ(IATM,JATM).GT.0.5D+00) AIJ(IATM,JATM)=0.5D+00
            IF(AIJ(IATM,JATM).LT.-0.5D+00) AIJ(IATM,JATM)=-0.5D+00
 6020    CONTINUE
         DO 6030 JATM=IATM+1,NAT
            RADJ = BRAGGRAD(JATM)
            IF(RADJ.LT.0.001D+00) THEN
              AIJ(IATM,JATM)= 1.0D+00
              GOTO 6030
            ENDIF
            CHI = RADI/RADJ
            CHI2=(CHI-ONE)/(CHI+ONE)
            AIJ(IATM,JATM)=CHI2/(CHI2*CHI2-ONE)
            IF(AIJ(IATM,JATM).GT.0.5D+00) AIJ(IATM,JATM)=0.5D+00
            IF(AIJ(IATM,JATM).LT.-0.5D+00) AIJ(IATM,JATM)=-0.5D+00
 6030    CONTINUE
 6010 CONTINUE
C***********************************************************************
C
C     NUMBER OF RADIAL POINTS
C
C***********************************************************************
  810 CONTINUE
      ITMP=NRADPT
C***********************************************************************
C
C     SET RADIAL GRID SCALING USING SLATERS RULES
C
C***********************************************************************
      RAD = BRAGGRAD(NCNTR)
C
C***********************************************************************
C
C     WEIGHTS FOR THE ANGULAR QUADRATURE ON PRUNE GRID
C
C     GAUSS-LEGENDRE ROOTS AND WEIGHTS FOR THETA GRID
C
C***********************************************************************
      DO ITHE=1,NTHE
      CALL GLGQUD(-ONE,+ONE,GLROOT(1,ITHE),GLWGHT(1,ITHE),ITHE)
      ENDDO
      NTHE=MAX(NTHE,2)
      IF(OPTGRD) IFACT=1
      IF(IFACT.EQ.8)THEN
        ITHEA=1
        ITHEB=NTHE/2
        IPHIA=1
        IPHIB=NPHI/4
        NAPTS(NCNTR)=(NTHE*NPHI)/8
        LTHE=2
        LPHI=4
      ELSE IF(IFACT.EQ.4)THEN
        IF(IQ2.EQ.1)THEN
          ITHEA=1
          ITHEB=NTHE
          IPHIA=1
          IPHIB=NPHI/4
          NAPTS(NCNTR)=(NTHE*NPHI)/4
          LTHE=1
          LPHI=4
        ELSE IF(IQ3.EQ.1)THEN
          ITHEA=1
          ITHEB=NTHE/2
          IPHIA=1
          IPHIA2=3*NPHI/4+1
          IPHIB=NPHI/4
          IPHIB2=NPHI
          NAPTS(NCNTR)=(NTHE*NPHI)/4
          LTHE=2
          LPHI=4
        ELSE IF(IQ5.EQ.1)THEN
          ITHEA=1
          ITHEB=NTHE/2
          IPHIA=1
          IPHIB=NPHI/2
          NAPTS(NCNTR)=(NTHE*NPHI)/4
          LTHE=2
          LPHI=2
        ENDIF
      ELSE IF(IFACT.EQ.2)THEN
        IF(IQ4.EQ.1)THEN
          ITHEA=1
          ITHEB=NTHE
          IPHIA=1
          IPHIA2=3*NPHI/4+1
          IPHIB=NPHI/4
          IPHIB2=NPHI
          NAPTS(NCNTR)=(NTHE*NPHI)/2
          LTHE=1
          LPHI=4
        ELSE IF(IQ6.EQ.1)THEN
          ITHEA=1
          ITHEB=NTHE
          IPHIA=1
          IPHIB=NPHI/2
          NAPTS(NCNTR)=(NTHE*NPHI)/2
          LTHE=1
          LPHI=2
        ELSE IF(IQ7.EQ.1)THEN
          ITHEA=1
          ITHEB=NTHE/2
          IPHIA=1
          IPHIB=NPHI
          NAPTS(NCNTR)=(NTHE*NPHI)/2
          LTHE=2
          LPHI=1
        ENDIF
      ELSE
C       IFACT=1
        ITHEA=1
        ITHEB=NTHE
        IPHIA=1
        IPHIB=NPHI
        NAPTS(NCNTR)=NTHE*NPHI
        LTHE=1
        LPHI=1
      ENDIF
      IF(MOD(NTHE,LTHE).NE.0.OR.MOD(NPHI,LPHI).NE.0) THEN
        IF(MASWRK) WRITE(IW,1000) LTHE,LPHI
C     THIS IS A DOUBLE CHECK.
C     NTHE AND NPHI MUST HAVE ALREADY BEEN ADJUSTED
        CALL ABRT
      ENDIF
      DO ITHE=ITHEA,ITHEB
        WTHE=GLWGHT(ITHE,NTHE)
        COST=GLROOT(ITHE,NTHE)
        SINT=SQRT(ONE-COST**2)
        DO IPHI=IPHIA,IPHIB
          I=(ITHE-ITHEA)*(IPHIB-IPHIA+1)+IPHI
          DPHI=TWO*PI/NPHI
          PHII=DPHI*(IPHI-HALF)
          WPHI=DPHI
          COSP=COS(PHII)
          SINP=SIN(PHII)
          XDAT(NCNTR,I) =SINT*COSP
          YDAT(NCNTR,I) =SINT*SINP
          ZDAT(NCNTR,I) =COST
          WGHT(NCNTR,I) =WTHE*WPHI
        ENDDO
      ENDDO
      LASTI = I
C**********************************************************************
C
C     INTEGRATE OVER ONE OCTANT OF ANGULAR POINTS
C
C**********************************************************************
      IANGN(NCNTR,1)=IPHIA
      IANGN(NCNTR,2)=(ITHEB-ITHEA)*(IPHIB-IPHIA+1)+IPHIB
C
      CALL OCT(ITMP,XDAT,YDAT,ZDAT,ATMXVEC,ATMYVEC,ATMZVEC,RI,RIJ,NAT,
     *         AIJ,WTINTR,TOTWT,WGHT,IANGN,NCNTR,RAD,NAPTS,PTRAD,WTRAD,
     *         WTAB)
C
C**********************************************************************
C     EXTRA DO LOOP WITH REGARD TO IPHI
C                         IN THE CASE OF CI, C2, AND C2H
C**********************************************************************
      IF((IFACT.EQ.4.AND.IQ3.EQ.1).OR.((IFACT.EQ.2.AND.IQ4.EQ.1))) THEN
        GOTO 6050
      ELSE
        RETURN
      ENDIF
C
 6050 CONTINUE
      DO ITHE=ITHEA,ITHEB
        WTHE=GLWGHT(ITHE,NTHE)
        COST=GLROOT(ITHE,NTHE)
        SINT=SQRT(ONE-COST**2)
        DO IPHI=IPHIA2,IPHIB2
          I=(ITHE-ITHEA)*(IPHIB2-IPHIA2+1)+IPHI+LASTI-(IPHIA2-1)
          DPHI=TWO*PI/NPHI
          PHII=DPHI*(IPHI-HALF)
          WPHI=DPHI
          COSP=COS(PHII)
          SINP=SIN(PHII)
          XDAT(NCNTR,I) =SINT*COSP
          YDAT(NCNTR,I) =SINT*SINP
          ZDAT(NCNTR,I) =COST
          WGHT(NCNTR,I) =WTHE*WPHI
        ENDDO
      ENDDO
      IANGN(NCNTR,1)=LASTI+1
      IANGN(NCNTR,2)=(ITHEB-ITHEA)*(IPHIB2-IPHIA2+1)+IPHIB2+LASTI
     >    -(IPHIA2-1)
C
      CALL OCT(ITMP,XDAT,YDAT,ZDAT,ATMXVEC,ATMYVEC,ATMZVEC,RI,RIJ,NAT,
     *         AIJ,WTINTR,TOTWT,WGHT,IANGN,NCNTR,RAD,NAPTS,PTRAD,WTRAD,
     *         WTAB)
      IANGN(NCNTR,1)=1
      RETURN
 1000 FORMAT(1X,'NTHE HAS TO BE A MULTIPLE OF ',I1,' AND NPHI OF ',I1/,
     *       1X,'IF YOU MUST USE THIS GRID, SET $CONTRL NOSYM=1',/)
      END
C*MODULE DFTGRD  *DECK INPBAS
C>    @brief Form a single primitive coefficient array
C>
C>    @details Use S and L-shells and treat P separately
C>
C>    @date  : December 21, 2012 - Joe Ivanic
C>             Modify for h,i functions in basis sets
C
      SUBROUTINE INPBAS(PCOEFF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXSH=5000, MXGTOT=20000)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      DIMENSION PCOEFF(*)
C
      DO I = 1, NSHELL
        DO IK = KSTART(I),KSTART(I)+KNG(I)-1
          IF(KTYPE(I).EQ.1) PCOEFF(IK)=CS(IK)
          IF(KTYPE(I).EQ.2) PCOEFF(IK)=CP(IK)
          IF(KTYPE(I).EQ.2.AND.KMIN(I).EQ.1) PCOEFF(IK)=CS(IK)
          IF(KTYPE(I).EQ.3) PCOEFF(IK)=CD(IK)
          IF(KTYPE(I).EQ.4) PCOEFF(IK)=CF(IK)
          IF(KTYPE(I).EQ.5) PCOEFF(IK)=CG(IK)
          IF(KTYPE(I).EQ.6) PCOEFF(IK)=CH(IK)
          IF(KTYPE(I).EQ.7) PCOEFF(IK)=CI(IK)
        ENDDO
      ENDDO
C
      RETURN
      END
C*MODULE DFTGRD  *DECK INPINF
C>    @brief Gets symmetry and initial symmetry information for
C>    computational point group
C>    @details NON-ABELIAN GROUPS ARE HANDLED AS THE HIGHEST ABELIAN SUBGROUPS
C>     WHICH HAVE THE SAME MASTER FRAME. E.G. D3 -> C1, NOT C2.
C>     PATHETIC AS IT IS, SOME NON-ABELIAN GROUPS ARE DEFILED TO C1.
C>     CHECK IF THE USER TRIED TO FIDDLE WITH THE LOCAL FRAME.
C>     IF THAT IS CORRECT THEN WE CANNOT USE OCTANT SYMMETRY SINCE
C>     THEN IT MUST BE REDEFINED APPROPRIATELY (NOT IMPOSSIBLE THOUGH).
C
      SUBROUTINE INPINF(ISYMXY,ISYMXZ,ISYMYZ,ISYMRX,ISYMRY,
     >                  ISYMRZ,ISYMI,ISYMC1,AGROUP)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION GRP(19)
C
      PARAMETER (MXSH=5000, MXATM=2000, MXGRID=10)
      PARAMETER (ONE=1.0D+00, TM6=1.0D-06)
C
      LOGICAL ABEL,LOCFRAME,GOPARR,DSKWRK,MASWRK,SG1
C
      CHARACTER*3 AGROUP
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /SYMMOL/ GROUP,COMPLEX,IGROUP,NAXIS,ILABMO,ABEL
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     >                T(432),INVT(48),NT
      COMMON /DFGRID/ DFTTHR,DFTGTHR,SWOFF,SW0,BSLRD(137),NDFTFG,
     *                NRAD,NTHE,NPHI,NRAD0,NTHE0,NPHI0,
     *                NANGPT(MXGRID),NANGPT0(MXGRID),SG1,JANS
      COMMON /DFLEB / NLEB(MXGRID),NLEB0(MXGRID)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /FRAME / U1,U2,U3,V1,V2,V3,W1,W2,W3,X0,Y0,Z0
C
      DATA GRP /5HC1   ,5HCS   ,5HCI   ,5HCN   ,5HS2N  ,5HCNH  ,
     >          5HCNV  ,5HDN   ,5HDNH  ,5HDND  ,5HCINFV,5HDINFH,5HT    ,
     >          5HTH   ,5HTD   ,5HO    ,5HOH   ,5HI    ,5HIH   /
C
      IF(ABS(U1-ONE).LT.TM6.AND.ABS(U2).LT.TM6.AND.ABS(U3).LT.TM6.AND.
     *   ABS(V1).LT.TM6.AND.ABS(V2-ONE).LT.TM6.AND.ABS(V3).LT.TM6.AND.
     *   ABS(W1).LT.TM6.AND.ABS(W2).LT.TM6.AND.ABS(W3-ONE).LT.TM6) THEN
         LOCFRAME=.FALSE.
      ELSE
         LOCFRAME=.TRUE.
         IF(MASWRK) WRITE(IW,1010)
      ENDIF
C
C     READ ATOMIC COORDINATES AS 'COORD'
C
      ISYMXY=0
      ISYMXZ=0
      ISYMYZ=0
      ISYMRX=0
      ISYMRY=0
      ISYMRZ=0
      ISYMI =0
C
C     ----- C1 SYMMETRY ; READ ONLY IIII -----
C           CN  FOR ODD N
C           CNV FOR ODD N
C           DN  FOR ODD N
C
      ISYMC1=0
      IF(SG1.OR.(JANS.GT.0).OR.NLEB(1).NE.0       .OR.
     *    GROUP.EQ.GRP(1).OR.NT.EQ.1.OR.LOCFRAME  .OR.
     *   (GROUP.EQ.GRP(4).AND.MOD(NAXIS,2).EQ.1)  .OR.
     *   (GROUP.EQ.GRP(7).AND.MOD(NAXIS,2).EQ.1)  .OR.
     *   (GROUP.EQ.GRP(8).AND.MOD(NAXIS,2).EQ.1)) THEN
         AGROUP='C1'
         ISYMC1=1
         LTHE=1
         LPHI=1
C
C     ISYMC1 IS USED ONLY FOR THE OCTANT SYMMETRY.
C
C     ----- D2H SYMMETRY -----
C           DNH FOR EVEN N
C           TH
C           OH
C
      ELSEIF(GROUP.EQ.GRP(9).AND.NAXIS.EQ.2.OR.
     *       GROUP.EQ.GRP(9).AND.MOD(NAXIS,2).EQ.0.OR.
     *       GROUP.EQ.GRP(14).OR.
     *       GROUP.EQ.GRP(17))THEN
         AGROUP='D2H'
         ISYMXY=1
         ISYMXZ=1
         ISYMYZ=1
         ISYMRX=1
         ISYMRY=1
         ISYMRZ=1
         ISYMI =1
         LTHE=2
         LPHI=4
C
C     ----- C2H SYMMETRY -----
C           CNH FOR EVEN N
C
      ELSEIF(GROUP.EQ.GRP(6).AND.NAXIS.EQ.2.OR.
     *       GROUP.EQ.GRP(6).AND.MOD(NAXIS,2).EQ.0) THEN
         AGROUP='C2H'
         ISYMXY=1
         ISYMRZ=1
         ISYMI =1
         LTHE=2
         LPHI=4
C        SINCE PHI IS DIVIDED INTO 4 PARTS AND ONLY TWO ARE USED.
C
C     ----- C2V SYMMETRY ------
C           CNV FOR EVEN N
C
      ELSEIF(GROUP.EQ.GRP(7).AND.NAXIS.EQ.2.OR.
     *       GROUP.EQ.GRP(7).AND.MOD(NAXIS,2).EQ.0) THEN
         AGROUP='C2V'
         ISYMXZ=1
         ISYMYZ=1
         ISYMRZ=1
         LTHE=1
         LPHI=4
C
C     ----- D2 SYMMETRY -----
C           DN FOR EVEN N
C           D2D FOR EVEN N
C           T
C           TD
C           O
C
      ELSEIF(GROUP.EQ.GRP(8).AND.NAXIS.EQ.2.OR.
     *       GROUP.EQ.GRP(8).AND.MOD(NAXIS,2).EQ.0.OR.
     *       GROUP.EQ.GRP(10).AND.MOD(NAXIS,2).EQ.0.OR.
     *       GROUP.EQ.GRP(13).OR.
     *       GROUP.EQ.GRP(15).OR.
     *       GROUP.EQ.GRP(16))THEN
         AGROUP='D2'
         ISYMRX=1
         ISYMRY=1
         ISYMRZ=1
         LTHE=2
         LPHI=2
C
C     ----- C2 SYMMETRY -----
C           CN FOR EVEN N
C           S2N FOR EVEN N
C
      ELSEIF(GROUP.EQ.GRP(4).AND.NAXIS.EQ.2.OR.
     *       GROUP.EQ.GRP(4).AND.MOD(NAXIS,2).EQ.0.OR.
     *       GROUP.EQ.GRP(5).AND.MOD(NAXIS,2).EQ.0) THEN
         AGROUP='C2'
         ISYMRZ=1
         LTHE=1
         LPHI=2
C
C     ----- CI SYMMETRY -----
C           S2N FOR ODD N
C           DND FOR ODD N
C
      ELSEIF(GROUP.EQ.GRP(3).OR.
     *       GROUP.EQ.GRP(5).AND.MOD(NAXIS,2).EQ.1.OR.
     *       GROUP.EQ.GRP(10).AND.MOD(NAXIS,2).EQ.1) THEN
         AGROUP='CI'
         ISYMI =1
         LTHE=1
         LPHI=4
C
C     ----- CS SYMMETRY -----
C           CNH FOR ODD N
C           DNH FOR ODD N
C
      ELSEIF(GROUP.EQ.GRP(2).OR.
     *       GROUP.EQ.GRP(6).AND.MOD(NAXIS,2).EQ.1.OR.
     *       GROUP.EQ.GRP(9).AND.MOD(NAXIS,2).EQ.1) THEN
         AGROUP='CS'
         ISYMXY=1
         LTHE=2
         LPHI=1
      ELSE
        IF(MASWRK) WRITE(IW,1007) GROUP,NAXIS
        CALL ABRT
      ENDIF
C     CHECK IF THE OCTANT SYMMETRY IS CONSISTENT WITH NTHE AND NPHI.
C     THIS IS BECAUSE WE DIVIDE NTHE AND/OR NPHI BY 2 OR 4.
      IF(MOD(NTHE,LTHE).NE.0.OR.MOD(NPHI,LPHI).NE.0.OR.
     *   MOD(NTHE0,LTHE).NE.0.OR.MOD(NPHI0,LPHI).NE.0) THEN
        IF(MASWRK) WRITE(IW,1000) LTHE,LPHI
        ISYMC1=1
      ENDIF
      RETURN
 1000 FORMAT(1X,'FOR GREATER EFFICIENCY, NTHE HAS TO BE A MULTIPLE OF ',
     *       I1,' AND NPHI OF ',I1/1X,'SIMILARLY, NTHE0 AND NPHI0.')
 1007 FORMAT(/'CANNOT USE POINT GROUP ',A8,I2)
 1010 FORMAT(//5X,'WARNING: LOCAL FRAME CHANGE IS DETECTED!',
     *       /5X,'THIS IS LIKELY TO MAKE THE DFT CODE SLOWER.',/)
      END
C*MODULE DFTGRD  *DECK RADPT
C>    @brief Determine the radial points and weights
C
      SUBROUTINE RADPT(PTRAD,WTRAD,NRAD)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION PTRAD(NRAD),WTRAD(NRAD)
C
      PARAMETER (ONE=1.0D+00,TWO=2.0D+00)
C
      XTMP=NRAD
      XNP1=XTMP+ONE
      DO 10 IRAD=1,NRAD
         XI=IRAD
C
C     ----- DETERMINE RADIAL POINT -----
C
         PTRAD(IRAD)=(XI*XI)/((XNP1-XI)*(XNP1-XI))
C
C     ----- CALCULATE WEIGHT FOR RADIAL QUADRATURE -----
C
         DEN=(XNP1-XI)*(XNP1-XI)*(XNP1-XI)*(XNP1-XI)
     >        *(XNP1-XI)*(XNP1-XI)*(XNP1-XI)
         WTRAD(IRAD)=(TWO*XNP1*XI*XI*XI*XI*XI)/DEN
C
 10   CONTINUE
      RETURN
      END
C*MODULE DFTGRD  *DECK SYMFCT
C>    @brief THIS ROUTINE DETERMINES WHICH QUADRANTS TO INTEGRATE OVER AND THE
C>     FACTOR TO MULTIPLY THE SYMMETRY INTEGRATION BY.
C>    @details ATOMS THAT LIE IN SYMMETRY PLANES OR ARE ON THE SYMMETRY AXES
C>     (IN THE ABELIAN SUBGROUP) CAN HAVE ONLY A FRACTION OF THE GRID PTS
C>     EXPLICITLY COMPUTED AND THE REST DUPLICATED WITH SYMMETRY FACTORS.
C>     THIS IS CALLED "OCTANT SYMMETRY" AND IS TREATED HERE.
C>     ATOMS THAT ARE CONNECTED TO A SYMMETRY UNIQUE ATOM BY SYMMETRY
C>     OPERATIONS (IN THE FULL GROUP) ARE ALSO NOT COMPUTED AND THE GRID
C>     INTEGRATION OVER A SYMMETRY UNIQUE ATOM IS MULTIPLIED BY A FACTOR.
C>     THIS IS HANDLED IN SYMUNQ.
C

      SUBROUTINE SYMFCT(ISYMYZ,ISYMXZ,ISYMXY,ISYMRX,ISYMRY,
     >                  ISYMRZ,ISYMI,NCNTR,
     >                  IQ1,IQ2,IQ3,IQ4,IQ5,IQ6,IQ7,IQ8,
     >                  IFACT,ISYMC1)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION IFACT(NAT)
C
      PARAMETER (MXATM=2000, THRSH=1.0D-10)
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),COORD(3,MXATM),IAN(MXATM)
C
C     QUADRANTS ARE LABELED
C     XYZ=1, XY(-Z)=2, X(-Y)Z=3, X(-Y)(-Z)=4
C     (-X)YX=5, (-X)Y(-Z)=6, (-X)(-Y)Z=7, (-X)(-Y)(-Z)=8
C
C     DETERMINE WHICH SYMMETRY ELEMENTS APPLY TO SYMMETRY-UNIQUE
C     ATOM NCNTR
C
      IYZ=ISYMYZ
      IXZ=ISYMXZ
      IXY=ISYMXY
      IRX=ISYMRX
      IRY=ISYMRY
      IRZ=ISYMRZ
      IMI=ISYMI
C***********************************************************************
C     C1 SYMMETRY
C***********************************************************************
      IF(ISYMC1.EQ.1) THEN
        IFACT(NCNTR) = 1
        GOTO 300
      ENDIF
C***********************************************************************
C
C     SET SYMMETRICAL FACTORS
C
C***********************************************************************
      IF(ABS(COORD(1,NCNTR)).GT.THRSH.AND.
     >   ABS(COORD(2,NCNTR)).GT.THRSH.AND.
     >   ABS(COORD(3,NCNTR)).GT.THRSH)THEN
         ISYMYZ=0
         ISYMXZ=0
         ISYMXY=0
         ISYMRX=0
         ISYMRY=0
         ISYMRZ=0
         ISYMI=0
C***********************************************************************
      ELSE IF(ABS(COORD(1,NCNTR)).LE.THRSH.AND.
     >   ABS(COORD(2,NCNTR)).GT.THRSH.AND.
     >   ABS(COORD(3,NCNTR)).GT.THRSH)THEN
         ISYMXZ=0
         ISYMXY=0
         ISYMRX=0
         ISYMRY=0
         ISYMRZ=0
         ISYMI=0
C***********************************************************************
      ELSE IF(ABS(COORD(1,NCNTR)).GT.THRSH.AND.
     >   ABS(COORD(2,NCNTR)).LE.THRSH.AND.
     >   ABS(COORD(3,NCNTR)).GT.THRSH)THEN
         ISYMYZ=0
         ISYMXY=0
         ISYMRX=0
         ISYMRY=0
         ISYMRZ=0
         ISYMI=0
C***********************************************************************
      ELSE IF(ABS(COORD(1,NCNTR)).GT.THRSH.AND.
     >   ABS(COORD(2,NCNTR)).GT.THRSH.AND.
     >   ABS(COORD(3,NCNTR)).LE.THRSH)THEN
         ISYMYZ=0
         ISYMXZ=0
         ISYMRX=0
         ISYMRY=0
         ISYMRZ=0
         ISYMI=0
C***********************************************************************
      ELSE IF(ABS(COORD(1,NCNTR)).LE.THRSH.AND.
     >   ABS(COORD(2,NCNTR)).LE.THRSH.AND.
     >   ABS(COORD(3,NCNTR)).GT.THRSH)THEN
         ISYMXY=0
         ISYMRX=0
         ISYMRY=0
         ISYMI=0
C***********************************************************************
      ELSE IF(ABS(COORD(1,NCNTR)).LE.THRSH.AND.
     >   ABS(COORD(2,NCNTR)).GT.THRSH.AND.
     >   ABS(COORD(3,NCNTR)).LE.THRSH)THEN
         ISYMXZ=0
         ISYMRX=0
         ISYMRZ=0
         ISYMI=0
C***********************************************************************
      ELSE IF(ABS(COORD(1,NCNTR)).GT.THRSH.AND.
     >   ABS(COORD(2,NCNTR)).LE.THRSH.AND.
     >   ABS(COORD(3,NCNTR)).LE.THRSH)THEN
         ISYMYZ=0
         ISYMRY=0
         ISYMRZ=0
         ISYMI=0
      ENDIF
C***********************************************************************
C
C     INITIAL SYMMETRY FACTOR
C
C***********************************************************************
      IFACT(NCNTR)=1
C***********************************************************************
C
C     DETERMINE WHICH QUADRANTS ARE EQUIVALENT
C
C***********************************************************************
      IQ1=1
      IQ2=1
      IQ3=1
      IQ4=1
      IQ5=1
      IQ6=1
      IQ7=1
      IQ8=1
C***********************************************************************
      IF(ISYMYZ.EQ.1.OR.ISYMRY.EQ.1.OR.ISYMRZ.EQ.1.OR.ISYMI.EQ.1)THEN
         IQ5=0
         IQ6=0
         IQ7=0
         IQ8=0
         IF(ISYMXZ.EQ.1.OR.ISYMRX.EQ.1)THEN
            IQ3=0
            IQ4=0
            IF(ISYMXY.EQ.1)THEN
               IQ2=0
               IFACT(NCNTR)=8
               GOTO 300
            ENDIF
         IFACT(NCNTR)=4
         GO TO 300
         ENDIF
         IF(ISYMXY.EQ.1)THEN
            IQ2=0
            IQ4=0
            IFACT(NCNTR)=4
            GOTO 300
         ENDIF
         IFACT(NCNTR)=2
      ENDIF
      IF(ISYMXZ.EQ.1.OR.ISYMRX.EQ.1)THEN
            IQ3=0
            IQ4=0
            IQ7=0
            IQ8=0
            IF(ISYMXY.EQ.1)THEN
               IQ2=0
               IQ6=0
               IFACT(NCNTR)=4
               GOTO 300
            ENDIF
      IFACT(NCNTR)=2
      GOTO 300
      ENDIF
      IF(ISYMXY.EQ.1)THEN
         IQ2=0
         IQ4=0
         IQ6=0
         IQ8=0
         IFACT(NCNTR)=2
      ENDIF
  300 CONTINUE
      ISYMYZ=IYZ
      ISYMXZ=IXZ
      ISYMXY=IXY
      ISYMRX=IRX
      ISYMRY=IRY
      ISYMRZ=IRZ
      ISYMI=IMI
      RETURN
      END
C*MODULE DFTGRD  *DECK SYMUNQ
C>    @brief Sets up the factor for symmetry-unique atom to be multiplied by
C
      SUBROUTINE SYMUNQ(IFACTR,INATM,NSYMAT,NDEG,NEQATM,IUNIQUE)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXSH=5000,MXATM=2000)
C
      DIMENSION IFACTR(NAT),INATM(NAT),NDEG(NAT),NEQATM(NAT,NAT),
     *          IUNIQUE(NAT)
C
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                T(432),INVT(48),NT
      COMMON /ZANDAT/ ZANINP(MXATM)
C
C     DETERMINE SYMMETRY UNIQUE ATOMS AND SYMMETRY FACTORS
C
      IF (NT.EQ.1) THEN
         TINY = 0.00001D+00
         DO 5 I=1,NAT
            IFACTR(I) =1
            INATM(I)  =I
            IUNIQUE(I)=I
            ZNUC = ABS(ZANINP(I))
            NUCZ = INT(ZNUC+0.001D+00)
            IF(ABS(ZNUC-NUCZ).LT.TINY) THEN
              INUC = NUCZ
            ELSE
              INUC = 0
            END IF
            IF(NFG.NE.0) INUC=IAN(I)
            IF(INUC.EQ.0) IUNIQUE(I)=0
 5       CONTINUE
         NSYMAT=NAT
         RETURN
      ENDIF
C
      NSYMAT=0
      CALL VICLR(IFACTR,1,NAT)
      CALL VICLR(INATM,1,NAT)
      CALL VICLR(NDEG,1,NAT)
      CALL VICLR(NEQATM,1,NAT*NAT)
      CALL VICLR(IUNIQUE,1,NAT)
      JATM=1
 10   CONTINUE
      IF (JATM.GT.NAT) THEN
         GOTO 90
      ELSEIF (JATM.NE.1) THEN
         DO 20 KATM=1,JATM-1
            IF (NDEG(KATM).EQ.0) GOTO 20
            DO 30 IDEG=1,NDEG(KATM)
               IF (JATM.EQ.NEQATM(KATM,IDEG)) THEN
                  JATM=JATM+1
                  GOTO 10
               ENDIF
 30         CONTINUE
 20      CONTINUE
      ENDIF
C
      NSYMAT=NSYMAT+1
      NDEG(JATM)=1
      INATM(NSYMAT)=JATM
C
      DO 40 IOPER=1,NT-1
         DO 50 JOPER=1,IOPER
           IF (MAPCTR(JATM,JOPER).EQ.MAPCTR(JATM,IOPER+1)) GOTO 40
 50      CONTINUE
         NEQATM(JATM,NDEG(JATM))=MAPCTR(JATM,IOPER+1)
         NDEG(JATM)=NDEG(JATM)+1
C
 40   CONTINUE
      IFACTR(NSYMAT)=NDEG(JATM)
C
      JATM=JATM+1
      GOTO 10
C
 90   CONTINUE
      TINY = 0.00001D+00
      DO INC = 1, NSYMAT
        IUNIQUE(INATM(INC))=INC
        I=INATM(INC)
C          sparkles and bond functions are to be ignored,
C          as Bragg radii will be assigned as zero.
        ZNUC = ABS(ZANINP(I))
        NUCZ = INT(ZNUC+0.001D+00)
        IF(ABS(ZNUC-NUCZ).LT.TINY) THEN
          INUC = NUCZ
        ELSE
          INUC = 0
        END IF
        IF(NFG.NE.0) INUC=IAN(I)
        IF(INUC.EQ.0) IUNIQUE(I)=0
      ENDDO
      RETURN
      END
C*MODULE DFTGRD  *DECK DFTTRF
      SUBROUTINE DFTTRFA(UROHF,L1,NA,CA,CB,AOX,MOXA,MOXB,TOL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION MOXA,MOXB
      LOGICAL UROHF
      DIMENSION CA(L1,L1),CB(L1,L1),AOX(L1),MOXA(L1),MOXB(L1)
C
C     AO->MO TRANSFORMATION
C     (FOR SPEED, RUN ONE RATHER THAN TWO LOOPS, SO ZERO EXTRA -MOXB-)
C     ALL THIS CAN BE COMPRESSED INTO A SINGLE LINE:
C     CALL MRARBR(AOX,1,1,L1,COEFFB,L1,NOB,VMOB,1)
C
      CALL VCLR(MOXA,1,NA)
C
      IF(UROHF) THEN
        CALL VCLR(MOXB,1,NA)
        DO I=1,L1
          AO=AOX(I)
          IF(ABS(AO).GT.TOL) THEN
          DO J=1,NA
            MOXA(J)=MOXA(J)+AO*CA(J,I)
            MOXB(J)=MOXB(J)+AO*CB(J,I)
          ENDDO
          ENDIF
        ENDDO
      ELSE
        DO I=1,L1
          AO=AOX(I)
          IF(ABS(AO).GT.TOL) THEN
          DO J=1,NA
            MOXA(J)=MOXA(J)+AO*CA(J,I)
          ENDDO
          ENDIF
        ENDDO
      ENDIF
C--   IF(.NOT.UROHF) CALL DCOPY(NB,MOXA,1,MOXB,1)
      RETURN
      END
C*MODULE DFTGRD  *DECK DFTTRFG
      SUBROUTINE DFTTRFG(UROHF,L1,NA,CA,CB,
     *                   GAOX,GAOY,GAOZ,
     *                   GMOXA,GMOYA,GMOZA,
     *                   GMOXB,GMOYB,GMOZB,TOL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL UROHF
      DIMENSION CA(L1,L1),CB(L1,L1),
     *          GAOX(L1),GAOY(L1),GAOZ(L1),
     *          GMOXA(L1),GMOYA(L1),GMOZA(L1),
     *          GMOXB(L1),GMOYB(L1),GMOZB(L1)
C
C     AO->MO TRANSFORMATION FOR THE GRADIENT TERMS.
C     SIMILARLY, A SINGLE CALL TO MRARBR WOULD DO THE TRICK.
C     THIS ROUTINE ASSUMES THAT CB (BETA-LCAO COEFFICIENTS) ARE ZERO
C     FOR "MISSING" ORBITALS, THAT IS, LAST NA-NB ORBITALS, FOR UROHF.
C
C
C     STB - THIS THRESHOLD IS NOT VALID
C     STB - IF THE VALUE OF A BASIS FUNCTION IS SMALL
C     STB - IT DOESN'T FOLLOW THAT ITS GRADIENT WILL BE.
C     STB - THIS DOES NOT SEEM TO EFFECT THE E-M GRIDS AS BAD
C           AS THE LEBEDEV GRIDS, AND I HAVE NO IDEA WHY
C
      CALL VCLR(GMOXA,1,NA)
      CALL VCLR(GMOYA,1,NA)
      CALL VCLR(GMOZA,1,NA)
C
      IF(UROHF) THEN
C        SHOULD BE NB IN PRINCIPLE
         CALL VCLR(GMOXB,1,NA)
         CALL VCLR(GMOYB,1,NA)
         CALL VCLR(GMOZB,1,NA)
         DO I=1,L1
C          IF(ABS(AOX(I)).GT.TOL) THEN
C            NN=NC(I)
           GX=GAOX(I)
           GY=GAOY(I)
           GZ=GAOZ(I)
           IF(ABS(GX)+ABS(GY)+ABS(GZ).GT.TOL) THEN
           DO J=1,NA
             COA=CA(J,I)
             COB=CB(J,I)
             GMOXA(J)=GMOXA(J)+GX*COA
             GMOYA(J)=GMOYA(J)+GY*COA
             GMOZA(J)=GMOZA(J)+GZ*COA
             GMOXB(J)=GMOXB(J)+GX*COB
             GMOYB(J)=GMOYB(J)+GY*COB
             GMOZB(J)=GMOZB(J)+GZ*COB
           ENDDO
           ENDIF
         ENDDO
      ELSE
        DO I=1,L1
C         IF(ABS(AOX(I)).GT.TOL) THEN
C           NN=NC(I)
          GX=GAOX(I)
          GY=GAOY(I)
          GZ=GAOZ(I)
          IF(ABS(GX)+ABS(GY)+ABS(GZ).GT.TOL) THEN
          DO J=1,NA
            COA=CA(J,I)
            GMOXA(J)=GMOXA(J)+GX*COA
            GMOYA(J)=GMOYA(J)+GY*COA
            GMOZA(J)=GMOZA(J)+GZ*COA
          ENDDO
          ENDIF
        ENDDO
      ENDIF
C
CNB   THIS PART CAN PROBABLY BE NEGLECTED
C     IF(.NOT.UROHF) THEN
C       CALL DCOPY(NB,GMOXA,1,GMOXB,1)
C       CALL DCOPY(NB,GMOXA,1,GMOXB,1)
C       CALL DCOPY(NB,GMOXA,1,GMOXB,1)
C     ENDIF
      RETURN
      END
C*MODULE DFTGRD  *DECK SWGRID
C>    @brief SWITCH THE FINE AND COARSE GRID SIZES
C
      SUBROUTINE SWGRID
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=2000,MXGRID=10,MXGRIDTYP=10)
      LOGICAL SG1
      COMMON /DFGRID/ DFTTHR,DFTGTHR,SWOFF,SW0,BSLRD(137),NDFTFG,
     *                NRAD,NTHE,NPHI,NRAD0,NTHE0,NPHI0,
     *                NANGPT(MXGRID),NANGPT0(MXGRID),SG1,JANS
      COMMON /DFLEB/  NLEB(MXGRID),NLEB0(MXGRID)
      COMMON /DFPRUN/ PRUNERADS(MXGRID,MXGRIDTYP),
     *                PRUNEATOMS(2,MXGRIDTYP),
     *                IPRUNECUTS(MXATM),NTOTGRIDPOINTS(MXATM),
     *                NGRIDS,MAXANG,NGRIDTYPS
C
      IF(NGRIDS.EQ.1) THEN
         IF(NLEB(1).EQ.0) THEN
            NRADT=NRAD
            NTHET=NTHE
            NPHIT=NPHI
            NRAD=NRAD0
            NTHE=NTHE0
            NPHI=NPHI0
            NRAD0=NRADT
            NTHE0=NTHET
            NPHI0=NPHIT
            NANGPT(1)=NTHE*NPHI
            NANGPT0(1)=NTHE0*NPHI0
         ELSE
            NRADT=NRAD
            NRAD=NRAD0
            NRAD0=NRADT
            NLEBT=NLEB(1)
            NLEB(1)=NLEB0(1)
            NLEB0(1)=NLEBT
            NANGPT(1)=NLEB(1)
            NANGPT0(1)=NLEB0(1)
         ENDIF
      ENDIF
C
C
      RETURN
      END
C*MODULE DFTGRD  *DECK DEREXC
C>    @brief Clone of DMATD
C>
C>    @details SEE ADDITIONAL REFERENCES THERE.
C>     HERE A CONTRIBUTION TO THE ENERGY GRADIENT DUE TO INTEGRATION OVER
C>     GRID POINTS SURROUNDING ATOM NCNTR IS COMPUTED.
C>
C>
C>    @date : December 21, 2012 - Joe Ivanic
C>            Modify IJX,IJY,IJZ to have dimension 84 for h,i cartesians
C
      SUBROUTINE DEREXC(TOTWT,NAPTS,COEFFA,COEFFB,DA,DB,IANGN,IFACTR,
     *                  INC0,VMOA,DVMOXA,DVMOYA,DVMOZA,VMOB,DVMOXB,
     *                  DVMOYB,DVMOZB,WGHT,RI,RIJ,WTINTR,AIJ,WTRAD,
     *                  NCNTR,L1,TOTELE,NANG,PTRAD,XDAT,YDAT,ZDAT,
     *                  ATMXVEC,ATMYVEC,ATMZVEC,ANGXVL,ANGYVL,ANGZVL,
     *                  RSQRD,PCOEFF,EXPS,AOX,GAOX,GAOY,GAOZ,
     *                  G2AOXX,G2AOYY,G2AOZZ,G2AOXY,G2AOYZ,G2AOXZ,NLCT,
     *                  NELM,IJX,IJY,IJZ,NEEDGR,DEDFT,UVEC,
     *                  DWTINT,DWTTOT,DTOTWT,OUT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL UROHF,OUT,NEEDGR,GOPARR,DSKWRK,MASWRK,DLB,NEEDTAU,
     *        PRTTAU,SG1,FUNCL,FUNFL
C
      PARAMETER (MXATM=2000,ZERO=0.0D+00,ONE=1.0D+00,TWO=2.0D+00)
      PARAMETER (MXGRID=10,MXGRIDTYP=10)
C
      COMMON /DFGRID/ DFTTHR,DFTGTHR,SWOFF,SW0,BSLRD(137),NDFTFG,
     *                NRAD,NTHE,NPHI,NRAD0,NTHE0,NPHI0,
     *                NANGPT(MXGRID),NANGPT0(MXGRID),SG1,JANS
      COMMON /DFPRUN/ PRUNERADS(MXGRID,MXGRIDTYP),
     *                PRUNEATOMS(2,MXGRIDTYP),
     *                IPRUNECUTS(MXATM),NTOTGRIDPOINTS(MXATM),
     *                NGRIDS,MAXANG,NGRIDTYPS
      COMMON /FUNLIB/ FUNCL,FUNFL
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /METGGA/ NEEDTAU,PRTTAU
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      COMMON /DNSAO / IDENAO
      PARAMETER (HALF=0.5D+00)
C
      DIMENSION TOTWT(NAT,*),COEFFA(L1,*),COEFFB(L1,*),
     >          VMOA(NUM),DVMOXA(NUM),DVMOYA(NUM),DVMOZA(NUM),
     >          VMOB(NUM),DVMOXB(NUM),DVMOYB(NUM),DVMOZB(NUM),
     *          DA(NUM,NUM),DB(NUM,NUM)
      DIMENSION NAPTS(NAT),IANGN(NAT,2,MXGRID),IFACTR(NAT)
      DIMENSION AOX(NUM),GAOX(NUM),GAOY(NUM),GAOZ(NUM),
     *          G2AOXX(NUM),G2AOYY(NUM),G2AOZZ(NUM),
     *          G2AOXY(NUM),G2AOYZ(NUM),G2AOXZ(NUM),
     *          DEDFT(3,NAT),EXPS(*),PTRAD(*),
     *          XDAT(NAT,MAXANG,MXGRID),YDAT(NAT,MAXANG,MXGRID),
     *          ZDAT(NAT,MAXANG,MXGRID),RSQRD(*),PCOEFF(*),
     *          ATMXVEC(NAT,NAT),ATMYVEC(NAT,NAT),ATMZVEC(NAT,NAT),
     *          ANGXVL(NAT,*),ANGYVL(NAT,*),ANGZVL(NAT,*),
     *          WGHT(NAT,MAXANG,MXGRID),RI(NAT),RIJ(NAT,NAT),
     *          WTINTR(NAT),AIJ(NAT,NAT),WTRAD(*),UVEC(3,NAT),
     *          DWTINT(3,NAT,NAT),DWTTOT(3,NAT),DTOTWT(3,NAT)
      DIMENSION IJX(84),IJY(84),IJZ(84)
      DIMENSION NLCT(*),NELM(*)
C
      DATA DEBUG/8HDEBUG   /, DFTDER/8HDFTDER  /
      DATA UHF,ROHF/8HUHF     ,8HROHF    /
C
      UROHF = SCFTYP.EQ.UHF  .OR.  SCFTYP.EQ.ROHF
      OUT = EXETYP.EQ.DFTDER  .OR.  EXETYP.EQ.DEBUG
C
      TOTEXC=ZERO
C
      RAD = BRAGGRAD(NCNTR)
      EXEC = ZERO
      NOA = NA
      NOB = NB
      NPT=NRAD*MAXANG
C
C     SET CUT-OFFS FOR DFT GRADIENT:
C     WCUTOFF - CELL VOLUME (WEIGHT)
C     RCUTOFF - ELECTRON DENSITY
C     CCUTOFF - LCAO COEFFICIENTS (AS USED FOR AO -> MO TRANSFORMATION)
C     FCUTOFF - FUNCTIONAL DERIVATIVE
C     AT PRESENT WEIGHT DERIVATIVE CUTOFF IS FOUND UNUSEFUL.
C
C     DFTTHR IS NOT USED IN THE GRADIENT.
C     INSTEAD, DFTGTHR IS USED AS FOLLOWS:
C     DFTGTHR=1 USE DEFAULT THRESHOLDS
C     DFTGTHR<1 SET ALL THRESHOLDS TO DFTGTHR
C     DFTGTHR>1 DIVIDE DEFAULT THRESHOLDS BY DFTGTHR (MAKE TIGHTER).
C     DFTTHR SET TO 1E-15 AS BEFORE SETS ALL GRAD THRESHOLDS TO 1E-15.
C
C     IF HIGHER ACCURACY IN GRADIENT DUE TO THRESHOLDS IS THOUGHT THE
C     RECOMMENDED WAY IS TO SET DFTGTHR=10 (WHICH MEANS ADD ABOUT
C     1 DIGIT OF ACCURACY, RELATIVE TO NO THRESHOLDS; DFT GRID
C     INTEGRATION HAS ITS OWN ERRORS, FINALLY, 2E INTEGRALS ALSO HAVE
C     CERTAIN ERROR BARS ON THEM).
C
      THRV1=ZERO
      THRV2=1.0D+00
      IF(DFTGTHR.GT.1.01D+00) THEN
        THRV2=DFTGTHR
      ELSE IF(DFTGTHR.LT.0.99D+00) THEN
        THRV1=DFTGTHR
      ENDIF
      IF(DFTTHR.LT.1.1D-15.AND.DFTTHR.NE.ZERO) THRV1=1.0D-15
C     THRV2=1.0D+00
      WCUTOFF=3.0D-05/NPT/THRV2
      RCUTOFF=1.0D-02/NPT/THRV2
      CCUTOFF=1.0D-01/NPT/THRV2
      FCUTOFF=3.0D-04/NPT/THRV2
C     WDCUTOFF=1.0D+01*WCUTOFF
C     IF(DFTTHR.LT.1.1D-15.AND.DFTTHR.NE.ZERO) THEN
      IF(THRV1.NE.ZERO) THEN
C        THRV1=1.0D-15
         WCUTOFF=THRV1
         RCUTOFF=THRV1
         CCUTOFF=THRV1
         FCUTOFF=THRV1
C        WCUTOFF=WCUTOFF*1D-1
C        RCUTOFF=RCUTOFF*1D-1
C        CCUTOFF=CCUTOFF*1D-1
C        FCUTOFF=FCUTOFF*1D-1
C        WDCUTOFF=WDCUTOFF*1D-1
      ENDIF
C     WRITE(6,*) 'WWWG',WCUTOFF,RCUTOFF,CCUTOFF,FCUTOFF,DFTGTHR
C
C     ANGXVL=X**I, ANGYVL=Y**J, ANGZVL=Z**K, FOR ALL VALUES OF I,J,K
C     WHERE (X,Y,Z) IS THE CENTRE OF A DFT GRID POINT RI
C     MINUS AN ATOMIC CENTRE RA: XYZ= (RI - RA)
C
      CALL VCLR(ANGXVL(1,1),1,NAT)
      CALL VCLR(ANGYVL(1,1),1,NAT)
      CALL VCLR(ANGZVL(1,1),1,NAT)
      CALL DACOPY(NAT,ONE,ANGXVL(1,2),1)
      CALL DACOPY(NAT,ONE,ANGYVL(1,2),1)
      CALL DACOPY(NAT,ONE,ANGZVL(1,2),1)
C
C     ---- SYMMETRY MULTIPLICATION FACTOR ----
C
C      FACT = IIFACT(NCNTR)*IFACTR(INC0)
      FACT=IFACTR(INC0)
C      FACT=1
C
C     DYNAMIC LOAD BALANCING: DIVIDE ALL POINTS INTO NGRAN*NPROC CHUNKS.
C     NGRAN CANNOT BE SET IN THE INPUT FILE. THEN EACH NODE GETS A CHUNK
C     AND TOILS IT OVER UNTIL READY TO ASK FOR MORE.
C
      LOOP=0
      NGRAN=20
      IGRID = 1
      IF(NGRIDS.EQ.1) THEN
         NLOOP=NRAD*(IANGN(NCNTR,2,1)-IANGN(NCNTR,1,1)+1)
      ELSE
         NLOOP=NTOTGRIDPOINTS(NCNTR)
      ENDIF
      MCHUNK=(NLOOP-1)/(NGRAN*NPROC)+1
      NEXT  = -1
      DLB = IBTYP.EQ.1
C     WRITE(6,*) 'WWWAA',DLB
C***********************************************************************
C     LOOP OVER RADIAL GRIDS
C     LOOP OVER ANGULAR GRIDS
C***********************************************************************
      DO 20 IRADPT = 1, NRAD
C
        RADWT=RAD*RAD*RAD*WTRAD(IRADPT)
        R1= RAD*PTRAD(IRADPT)
        IF(R1.GE.PRUNERADS(IGRID,IPRUNECUTS(NCNTR))*RAD) THEN
           IGRID = IGRID + 1
        ENDIF
C     WRITE(IW,'(A,I5,2F20.10,I5)')'RAD,PT,IGRID = ',IRADPT,RAD,
C     *       PTRAD(IRADPT),IGRID
        DO 10 IANGPT = IANGN(NCNTR,1,IGRID), IANGN(NCNTR,2,IGRID)
           IPT=(IRADPT-1)*NAPTS(NCNTR)+IANGPT
C
          IF(GOPARR) THEN
            IF(DLB) THEN
              LOOP=LOOP+1
              ICHUNK=(LOOP-1)/MCHUNK
              IF(ICHUNK.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
              IF(NEXT.NE.ICHUNK) GOTO 10
            ELSE
              IF(MOD(IPT,NPROC).NE.ME) GOTO 10
            ENDIF
          ENDIF
          IPTME=(IPT-1)/NPROC+1
          IF(DLB) IPTME=IPT
C
          FTOTWT = TOTWT(NCNTR,IPTME)*FACT
          FTOTWT0=FTOTWT/FACT
          IF(FTOTWT0.LT.WCUTOFF) THEN
             GOTO 10
          ENDIF
C
          XD=R1*XDAT(NCNTR,IANGPT,IGRID)
          YD=R1*YDAT(NCNTR,IANGPT,IGRID)
          ZD=R1*ZDAT(NCNTR,IANGPT,IGRID)
          DO 610 IATM=1,NAT
            XCDNT=ATMXVEC(NCNTR,IATM)+XD
            YCDNT=ATMYVEC(NCNTR,IATM)+YD
            ZCDNT=ATMZVEC(NCNTR,IATM)+ZD
            RSQRD(IATM)=XCDNT**2+YCDNT**2+ZCDNT**2
C
C           NORMALISE THE R(A) VECTOR, = R(I)-R(A)
C
            RI(IATM)=SQRT(RSQRD(IATM))
            UVEC(1,IATM) = XCDNT / RI(IATM)
            UVEC(2,IATM) = YCDNT / RI(IATM)
            UVEC(3,IATM) = ZCDNT / RI(IATM)
C
            ANGXVL(IATM,3)=XCDNT
            ANGYVL(IATM,3)=YCDNT
            ANGZVL(IATM,3)=ZCDNT
            DO 35 IANG=3,NANG
               ANGXVL(IATM,IANG+1)=ANGXVL(IATM,IANG)*XCDNT
               ANGYVL(IATM,IANG+1)=ANGYVL(IATM,IANG)*YCDNT
               ANGZVL(IATM,IANG+1)=ANGZVL(IATM,IANG)*ZCDNT
 35         CONTINUE
  610     CONTINUE
C
          CALL DFTAO(IJX,IJY,IJZ,AOX,ANGXVL,ANGYVL,ANGZVL,PCOEFF,EXPS,
     *               RSQRD,NAT,L1)
C***********************************************************************
C     FORM DENSITY AT THIS POINT
C***********************************************************************
          IF(IDENAO.EQ.0) THEN
             CALL DFTTRFA(UROHF,L1,NOA,COEFFA,COEFFB,AOX,VMOA,VMOB,
     *                    CCUTOFF)
             ROA=DDOT(NOA,VMOA,1,VMOA,1)
             IF(UROHF) THEN
               ROB=DDOT(NOB,VMOB,1,VMOB,1)
             ELSE
               ROB=ROA
             ENDIF
          ELSE
             CALL DFTTRFDM(UROHF,L1,COEFFA,COEFFB,AOX,VMOA,VMOB,CCUTOFF,
     *                     NLCT,NELM)
             ROA=DDOT(L1,AOX,1,VMOA,1)
             IF(UROHF) THEN
                ROB=DDOT(L1,AOX,1,VMOB,1)
             ELSE
                ROA=ROA*HALF
                ROB=ROA
             END IF
          END IF
          IF(ROA+ROB.LT.RCUTOFF) THEN
             GOTO 10
          ENDIF
C
C         COMPUTE THE WEIGHT DERIVATIVE.
C
          WGHTNOW=WGHT(NCNTR,IANGPT,IGRID)
          NITR=4
          CALL GRDOCT(NAT,NITR,NCNTR,ATMXVEC,ATMYVEC,ATMZVEC,RI,RIJ,AIJ,
     *          WGHTNOW,RADWT,WTINTR,UVEC,DWTINT,DWTTOT,DTOTWT)
C         ELSE
C           CALL VCLR(DTOTWT,1,3*NAT)
C         ENDIF
C
          CALL DFTGAO(IJX,IJY,IJZ,GAOX,GAOY,GAOZ,ANGXVL,ANGYVL,ANGZVL,
     *                PCOEFF,EXPS,RSQRD,NAT,L1)
C         ---------------
          IF(NEEDGR) THEN
C         ----------------
          CALL DFTG2AO(IJX,IJY,IJZ,G2AOXX,G2AOYY,G2AOZZ,G2AOXY,G2AOYZ,
     *          G2AOXZ,ANGXVL,ANGYVL,ANGZVL,PCOEFF,EXPS,RSQRD,NAT,L1)
C***********************************************************************
C     FORM DENSITY GRADIENT AT THIS POINT
C***********************************************************************
            IF(IDENAO.EQ.0) THEN
              CALL DFTTRFG(UROHF,L1,NOA,COEFFA,COEFFB,GAOX,GAOY,GAOZ,
     *                     DVMOXA,DVMOYA,DVMOZA,DVMOXB,DVMOYB,DVMOZB,
     *                     CCUTOFF)
              GRADXA=TWO*DDOT(NOA,VMOA,1,DVMOXA,1)
              GRADYA=TWO*DDOT(NOA,VMOA,1,DVMOYA,1)
              GRADZA=TWO*DDOT(NOA,VMOA,1,DVMOZA,1)
              IF(UROHF) THEN
                GRADXB=TWO*DDOT(NOB,VMOB,1,DVMOXB,1)
                GRADYB=TWO*DDOT(NOB,VMOB,1,DVMOYB,1)
                GRADZB=TWO*DDOT(NOB,VMOB,1,DVMOZB,1)
              ELSE
                GRADXB=GRADXA
                GRADYB=GRADYA
                GRADZB=GRADZA
              ENDIF
            ELSE
               GRADXA=DDOT(L1,GAOX,1,VMOA,1)
               GRADYA=DDOT(L1,GAOY,1,VMOA,1)
               GRADZA=DDOT(L1,GAOZ,1,VMOA,1)
               IF(UROHF) THEN
                  GRADXA=GRADXA*TWO
                  GRADYA=GRADYA*TWO
                  GRADZA=GRADZA*TWO
                  GRADXB=DDOT(L1,GAOX,1,VMOB,1)*TWO
                  GRADYB=DDOT(L1,GAOY,1,VMOB,1)*TWO
                  GRADZB=DDOT(L1,GAOZ,1,VMOB,1)*TWO
               ELSE
                  GRADXB=GRADXA
                  GRADYB=GRADYA
                  GRADZB=GRADZA
               END IF
            END IF
C***********************************************************************
C      FORM GRADIENT INVARIENT (GRAD DOT GRAD)
C***********************************************************************
            GRDAA  = GRADXA*GRADXA+GRADYA*GRADYA+GRADZA*GRADZA
            GRDBB  = GRADXB*GRADXB+GRADYB*GRADYB+GRADZB*GRADZB
            GRDAB  = GRADXA*GRADXB+GRADYA*GRADYB+GRADZA*GRADZB
            IF(NEEDTAU) THEN
C***********************************************************************
C     FORM X, Y, Z COMPONENTS OF KINETIC DENISTY AT THIS POINT
C***********************************************************************
              IF(IDENAO.EQ.0) THEN
                TAUXA =DDOT(NOA,DVMOXA,1,DVMOXA,1)
                TAUYA =DDOT(NOA,DVMOYA,1,DVMOYA,1)
                TAUZA =DDOT(NOA,DVMOZA,1,DVMOZA,1)
                IF(UROHF) THEN
                  TAUXB =DDOT(NOB,DVMOXB,1,DVMOXB,1)
                  TAUYB =DDOT(NOB,DVMOYB,1,DVMOYB,1)
                  TAUZB =DDOT(NOB,DVMOZB,1,DVMOZB,1)
                ELSE
                  TAUXB =TAUXA
                  TAUYB =TAUYA
                  TAUZB =TAUZA
                ENDIF
              ELSE
                CALL DFTTRFDM(UROHF,L1,COEFFA,COEFFB,GAOX,DVMOXA,DVMOXB,
     *                        CCUTOFF,NLCT,NELM)
                CALL DFTTRFDM(UROHF,L1,COEFFA,COEFFB,GAOY,DVMOYA,DVMOYB,
     *                        CCUTOFF,NLCT,NELM)
                CALL DFTTRFDM(UROHF,L1,COEFFA,COEFFB,GAOZ,DVMOZA,DVMOZB,
     *                        CCUTOFF,NLCT,NELM)
                TAUXA=DDOT(L1,GAOX,1,DVMOXA,1)
                TAUYA=DDOT(L1,GAOY,1,DVMOYA,1)
                TAUZA=DDOT(L1,GAOZ,1,DVMOZA,1)
                IF(UROHF) THEN
                  TAUXB=DDOT(L1,GAOX,1,DVMOXB,1)
                  TAUYB=DDOT(L1,GAOY,1,DVMOYB,1)
                  TAUZB=DDOT(L1,GAOZ,1,DVMOZB,1)
                ELSE
                  TAUXA =TAUXA*HALF
                  TAUYA =TAUYA*HALF
                  TAUZA =TAUZA*HALF
                  TAUXB =TAUXA
                  TAUYB =TAUYA
                  TAUZB =TAUZA
                ENDIF
              ENDIF
C         THE FORMATION OF TAU# IS DONE WITHIN THE META-GGA FUNCTIONAL.
C         SPECIFICALLY, TAU# = (ONE/TWO)*(TAUX#+TAUY#+TAUZ#)
C         WHERE #=A (ALPHA) OR B (BETA)
C     ----- THE TOTAL KINETIC DENSITY -----
            ENDIF
          ELSE
C
C     THIS ELSE CASE WILL ALLOW USERS TO PRINT OUT THE TOTAL KINETIC
C     ENERGY DENSITY FOR LDA TYPE FUNCTIONALS.
C     KEEP IN MIND THAT IF THE FUNCTIONAL DOES NOT CONTAIN A TAU
C     DEPENDENCE THEN ONE CAN NOT EXPECT THE TOTAL KINETIC ENERGY
C     DENSITY TO BE EXACTLY EQUAL TO THE EXPECTATION VALUE OF THE
C     KINETIC ENERGY OPERATOR.
            IF(PRTTAU) THEN
C***********************************************************************
C     FORM X, Y, Z COMPONENTS OF KINETIC DENISTY AT THIS POINT
C***********************************************************************
              CALL DFTGAO(IJX,IJY,IJZ,GAOX,GAOY,GAOZ,ANGXVL,ANGYVL,
     *                    ANGZVL,PCOEFF,EXPS,RSQRD,NAT,L1)
              IF(IDENAO.EQ.0) THEN
                CALL DFTTRFG(UROHF,L1,NOA,COEFFA,COEFFB,GAOX,GAOY,GAOZ,
     *                       DVMOXA,DVMOYA,DVMOZA,DVMOXB,DVMOYB,DVMOZB,
     *                       CCUTOFF)
                TAUXA =DDOT(NOA,DVMOXA,1,DVMOXA,1)
                TAUYA =DDOT(NOA,DVMOYA,1,DVMOYA,1)
                TAUZA =DDOT(NOA,DVMOZA,1,DVMOZA,1)
                IF(UROHF) THEN
                  TAUXB =DDOT(NOB,DVMOXB,1,DVMOXB,1)
                  TAUYB =DDOT(NOB,DVMOYB,1,DVMOYB,1)
                  TAUZB =DDOT(NOB,DVMOZB,1,DVMOZB,1)
                ELSE
                  TAUXB =TAUXA
                  TAUYB =TAUYA
                  TAUZB =TAUZA
                ENDIF
              ELSE
                CALL DFTTRFDM(UROHF,L1,COEFFA,COEFFB,GAOX,DVMOXA,DVMOXB,
     *                        CCUTOFF,NLCT,NELM)
                CALL DFTTRFDM(UROHF,L1,COEFFA,COEFFB,GAOY,DVMOYA,DVMOYB,
     *                        CCUTOFF,NLCT,NELM)
                CALL DFTTRFDM(UROHF,L1,COEFFA,COEFFB,GAOZ,DVMOZA,DVMOZB,
     *                        CCUTOFF,NLCT,NELM)
                TAUXA=DDOT(L1,GAOX,1,DVMOXA,1)*HALF
                TAUYA=DDOT(L1,GAOY,1,DVMOYA,1)*HALF
                TAUZA=DDOT(L1,GAOZ,1,DVMOZA,1)*HALF
                IF(UROHF) THEN
                  TAUXB=DDOT(L1,GAOX,1,DVMOXB,1)*HALF
                  TAUYB=DDOT(L1,GAOY,1,DVMOYB,1)*HALF
                  TAUZB=DDOT(L1,GAOZ,1,DVMOZB,1)*HALF
                ELSE
                  TAUXB =TAUXA
                  TAUYB =TAUYA
                  TAUZB =TAUZA
                ENDIF
              ENDIF
C         THE FORMATION OF TAU# IS DONE WITHIN THE META-GGA FUNCTIONAL.
C         SPECIFICALLY, TAU# = (ONE/TWO)*(TAUX#+TAUY#+TAUZ#)
C         WHERE #=A (ALPHA) OR B (BETA)
C     ----- THE TOTAL KINETIC DENSITY -----
            ENDIF
          ENDIF
C
C***********************************************************************
C     THE EXCHANGE-CORRELATION FUNCTIONAL CALCULATION
C***********************************************************************
          VXCA1=ZERO
          VXCB1=ZERO
          DUMAX=ZERO
          DUMAY=ZERO
          DUMAZ=ZERO
          DUMBX=ZERO
          DUMBY=ZERO
          DUMBZ=ZERO
          XALPHA=ZERO
          XGRD=ZERO
          ECF=ZERO
C
C         STORES THE DERIVATIVE OF THE FUNCTIONAL WITH RESPECT TO THE
C         KINETIC ENERGY DENSITY.
C
C         ALPHA SPIN
          DMGGA=ZERO
          DMGA =ZERO
C         BETA SPIN
          DMGGB=ZERO
          DMGB =ZERO
          IF(FUNCL) THEN
            CALL CCALCEXC (ROA,ROB,FTOTWT,GRDAA,GRDBB,GRDAB,
     >                     GRADXA,GRADYA,GRADZA,GRADXB,GRADYB,GRADZB,
     >                     XALPHA,XGRD,VXCA1,DUMAX,DUMAY,DUMAZ,
     >                     VXCB1,DUMBX,DUMBY,DUMBZ,ECF)
          ELSE IF(FUNFL) THEN
            CALL FCALCEXC (ROA,ROB,FTOTWT,GRDAA,GRDBB,GRDAB,
     >                     GRADXA,GRADYA,GRADZA,GRADXB,GRADYB,GRADZB,
     >                     XALPHA,XGRD,VXCA1,DUMAX,DUMAY,DUMAZ,
     >                     VXCB1,DUMBX,DUMBY,DUMBZ,ECF)
          ELSE
            CALL CALCEXC(ROA,ROB,FTOTWT,GRDAA,GRDBB,GRDAB,
     >                   GRADXA,GRADYA,GRADZA,GRADXB,GRADYB,GRADZB,
     >                   XALPHA,XGRD,VXCA1,DUMAX,DUMAY,DUMAZ,
     >                   VXCB1,DUMBX,DUMBY,DUMBZ,ECF,
     >                   TAUXA,TAUYA,TAUZA,DMGGA,
     >                   TAUXB,TAUYB,TAUZB,DMGGB)
          END IF
C
          DUMA = VXCA1
          DUMB = VXCB1
          DMGA = DMGGA
          DMGB = DMGGB
          EXEC1= XALPHA + XGRD + ECF
          EXEC = EXEC + EXEC1
          IF(NOB.EQ.0) THEN
             DUMB=ZERO
             GRADXB=ZERO
             GRADYB=ZERO
             GRADZB=ZERO
             DMGB=ZERO
          ENDIF
          UPBOW=ABS(DUMA)*TWO
          IF(UROHF) UPBOW=ABS(DUMA)+ABS(DUMB)
C         IF(NEEDGR) THEN
C           UPBOW=UPBOW+ABS(DUMAX)+ABS(DUMAY)+ABS(DUMAZ)
C           IF(UROHF) UPBOW=UPBOW+ABS(DUMBX)+ABS(DUMBY)+ABS(DUMBZ)
C         ENDIF
          UPBOW=UPBOW*TWO*FTOTWT0
          IF(UPBOW.GT.FCUTOFF) THEN
C         XGRD1=XGRD1+XGRD
C***********************************************************************
C      COMPUTE DFT GRADIENT
C***********************************************************************
          CALL DFTGDV(NCNTR,DEDFT,FTOTWT,NUM,DUMA,DUMAX,DUMAY,DUMAZ,
     >         DUMB,DUMBX,DUMBY,DUMBZ,AOX,GAOX,GAOY,GAOZ,
     >         G2AOXX,G2AOYY,G2AOZZ,G2AOXY,G2AOYZ,G2AOXZ,
     >         DA,DB,NEEDGR,UROHF,DMGA,DMGB,NEEDTAU)
          ENDIF
C
C         ADD THE WEIGHT DERIVATIVE CONTRIBUTION
C         (WEIGHT DERIVATIVE ITSELF TIMES THE FUNCTIONAL VALUE).
C
          EXEC2=EXEC1/FTOTWT*FACT
C         WRITE(6,*) 'WWWWEIGHT',EXEC2,DTOTWT(1,1),DEDFT(1,1)
          CALL DAXPY(3*NAT,EXEC2,DTOTWT,1,DEDFT,1)
C
C     ----- THE TOTAL ELECTRON DENSITY -----
C
          TOTELE=TOTELE+FTOTWT*(ROA+ROB)
C
   10   CONTINUE
C
C     ----- NEXT RADIAL POINT -----
C
   20 CONTINUE
C
      TOTEXC = TOTEXC+EXEC
C
      IF(GOPARR.AND.DLB) CALL DDI_DLBRESET
      IF (OUT) THEN
         WRITE(IW,9999)NCNTR,TOTEXC,TOTELE
         DO INAT=1,NAT
            WRITE(IW,9998) DEDFT(1,INAT),DEDFT(2,INAT),DEDFT(3,INAT)
         ENDDO
      ENDIF
      RETURN
 9998 FORMAT(/F20.10,F20.10,F20.10)
 9999 FORMAT(/5X,'ATM',I8,'EXC=',F20.10,5X,'TOTELE=',F20.10)
      END
C*MODULE DFTGRD  *DECK OCT
C>    @brief Sets up numerical grid for the XYZ octant
C
      SUBROUTINE OCT(ITMP,XDAT,YDAT,ZDAT,ATMXVEC,ATMYVEC,ATMZVEC,RI,
     *               RIJ,NAT,AIJ,WTINTR,TOTWT,WGHT,IANGN,NCNTR,RAD,
     *               NAPTS,PTRAD,WTRAD,WTAB)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,DLB
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
C          UGH, -NANGPT- PASSED THROUGH COMMON, NOT ARGUMENTS:
C--   DIMENSION WGHT(NAT,NANGPT(1)),XDAT(NAT,NANGPT(1)),
C--  *          YDAT(NAT,NANGPT(1)),ZDAT(NAT,NANGPT(1)),
C          OCT. 2010: CALLED ONCE WITH LEBEDEV, TWICE WITH POLAR COORD
C              DIMENSIONS, STORAGE SEEMS OK ELSEWHERE, SO WHY CONFUSE
C              OLD G77 COMPILERS WITH INDEXED DIMS FROM COMMON?
      DIMENSION WGHT(NAT,*),XDAT(NAT,*),
     *          YDAT(NAT,*),ZDAT(NAT,*),
     *          ATMXVEC(NAT,NAT),ATMYVEC(NAT,NAT),ATMZVEC(NAT,NAT),
     *          RI(NAT),RIJ(NAT,NAT),WTINTR(NAT),TOTWT(NAT,*),
     *          AIJ(NAT,NAT),IANGN(NAT,2),NAPTS(NAT),PTRAD(ITMP),
     *          WTRAD(ITMP)
C
      LOGICAL LRDFLG,MLTINT,DOLRD
      COMMON /LRDISP/ ELRD6,ELRD8,ELRD10,EMULT,LRDFLG,MLTINT,DOLRD
      DIMENSION WTAB(NAT,NAT,*)
C
      DATA CHECK/8HCHECK   /
C
C---  WRITE(6,1) NAT,NANGPT(1),ITMP,NCNTR,NRAD,NTHE,NPHI
C---1 FORMAT(1X,'ENTERED OCT: NAT=',I2,' NANGPT=',I5,' ITMP=',I5/
C--- *       1X,'NCNTR=',I3,' NRAD=',I5,' NTHE=',I5,' NPHI=',I5)
C
C        THIS DEFEATS GRID PRUNING, BY GIVING ALL POINTS A LARGE WEIGHT,
C        BUT IT IS VERY MUCH FASTER THAN RUNNING THE COMPUTATIONS BELOW.
C        IT LEADS TO AN OVERESTIMATED NUMBER OF GRID POINTS, AND THUS
C        WILL GIVE MEMORY ESTIMATES IN CHECK JOBS THAT ARE TOO HIGH.
C
      IF(EXETYP.EQ.CHECK) THEN
         NUMR = ITMP
         NUMA = IANGN(NCNTR,2) - IANGN(NCNTR,1)
         DO J=1,NUMR*NUMA
            TOTWT(NCNTR,J) = 0.1D+00
         ENDDO
         RETURN
      END IF
C
      DLB = IBTYP.EQ.1
C
C     DETERMINE GRID POINT VOLUMES (=WEIGHTS) FOR ONE OCTANT.
C     XCDNT ETC CONTAIN COORDINATES OF THE CENTRE OF A GRID POINT
C
      DO 600 IRAD=1,ITMP
         RADWT=RAD*RAD*RAD*WTRAD(IRAD)
         R1= RAD*PTRAD(IRAD)
C
C---  IF(IRAD.EQ.1) WRITE(6,2) IRAD,RADWT,R1
C---2 FORMAT(1X,'IRAD=',I3,' RADWT=',F15.10,' R1=',F15.10)
C
         DO 605 I=IANGN(NCNTR,1),IANGN(NCNTR,2)
            IPT=(IRAD-1)*NAPTS(NCNTR)+I
C
C---  IF(IRAD.EQ.1 .AND. I.LE.5) WRITE(6,3) I,IPT,NAPTS(NCNTR),NPROC,ME
C---3 FORMAT(1X,'I=',I4,' IPT=',I5,' NAPTS=',I5,' NPROC,ME=',2I4)
C
            IF(MOD(IPT,NPROC).NE.ME) GOTO 605
            IPTME=(IPT-1)/NPROC+1
            IF(DLB) IPTME=IPT
C
            XD=R1*XDAT(NCNTR,I)
            YD=R1*YDAT(NCNTR,I)
            ZD=R1*ZDAT(NCNTR,I)
            DO 610 IATM=1,NAT
               XCDNT=ATMXVEC(NCNTR,IATM)+XD
               YCDNT=ATMYVEC(NCNTR,IATM)+YD
               ZCDNT=ATMZVEC(NCNTR,IATM)+ZD
               RSQRD=XCDNT**2+YCDNT**2+ZCDNT**2
               RI(IATM)=SQRT(RSQRD)
  610       CONTINUE
            WTTOT=ZERO
C
            CALL DACOPY(NAT,ONE,WTINTR,1)
C
            DO 611 IATM=1,NAT
C            WTINTR(IATM)=ONE
               IF(ABS(AIJ(IATM,1)+1.0D+00).LT.1.0D-05) THEN
                 WTINTR(IATM) = 0.0D+00
                 GOTO 611
               ENDIF
               DO 612 JATM=1,IATM-1
                  IF (ABS(AIJ(IATM,JATM)-1.0D+00).LT.1.0D-05) THEN
                     CUTIJ = 1.0D+00
                     GOTO 620
                  ENDIF
C                            ZMUIJ -> UIJ
                  ZMUIJ=(RI(IATM)-RI(JATM))/RIJ(IATM,JATM)
                  XMUIJ=ZMUIJ + AIJ(IATM,JATM)*(ONE-ZMUIJ*ZMUIJ)
C***********************************************************************
C
C     BECKE'S FUZZY CELL METHOD FOR MOLECULAR GRID QUADRATURE
C
C***********************************************************************
                  F4=XMUIJ
C
C             NITR=4
C             DO K=1,NITR
C               F4=F4*(1.5D+00-0.5D+00*F4*F4)
C             END DO
C
C     THE ABOVE LOOP IS UNROLLED BELOW
C
                  F41 = F4 *(1.5D+00-0.5D+00*F4 *F4 )
                  F42 = F41*(1.5D+00-0.5D+00*F41*F41)
                  F43 = F42*(1.5D+00-0.5D+00*F42*F42)
                  F4  = F43*(1.5D+00-0.5D+00*F43*F43)
C
                  F2=0.5D+00*F4
                  CUTIJ=0.5D+00-F2
                  CUTJI=0.5D+00+F2
  620             CONTINUE
                  WTINTR(IATM)=WTINTR(IATM)*CUTIJ
                  WTINTR(JATM)=WTINTR(JATM)*CUTJI
  612          CONTINUE
  611       CONTINUE
            DO IATM=1,NAT
               WTTOT=WTTOT+WTINTR(IATM)
            ENDDO
C
            ATMWT=WTINTR(NCNTR)/WTTOT
C
C---  IF(IRAD.EQ.1 .AND. I.LE.5) WRITE(6,4) I,RADWT,ATMWT,WGHT(NCNTR,I)
C---4 FORMAT(1X,'WEIGHTS IN OCT:',I5,3F15.10)
C
            TOTWT(NCNTR,IPTME)=ATMWT*RADWT*WGHT(NCNTR,I)
C
            IF(LRDFLG) THEN
              DO IATM=1,NAT
                WTAB(NCNTR,IATM,IPTME)=WTINTR(IATM)/WTTOT
              END DO
            END IF
C
  605    CONTINUE
  600 CONTINUE
      RETURN
      END
C*MODULE DFTGRD  *DECK PRUNEOCT
      SUBROUTINE PRUNEOCT(ITMP,XDAT,YDAT,ZDAT,ATMXVEC,ATMYVEC,ATMZVEC,
     *                    RI,RIJ,NAT,AIJ,WTINTR,TOTWT,WGHT,IANGN,
     *                    NCNTR,RAD,PTRAD,WTRAD,WTAB)
C**********************************************************************
C
C     THIS ROUTINE SETS UP THE NUMERICAL GRID FOR THE XYZ OCTANT
C
C**********************************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER ( ZERO=0.0D+00, ONE=1.0D+00)
      PARAMETER ( MXATM=2000,MXGRID=10,MXGRIDTYP=10 )
C
      LOGICAL GOPARR,DSKWRK,MASWRK,DLB
C
      COMMON /DFPRUN/ PRUNERADS(MXGRID,MXGRIDTYP),
     *                PRUNEATOMS(2,MXGRIDTYP),
     *                IPRUNECUTS(MXATM),NTOTGRIDPOINTS(MXATM),
     *                NGRIDS,MAXANG,NGRIDTYPS
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DIMENSION WGHT(NAT,MAXANG,NGRIDS),XDAT(NAT,MAXANG,NGRIDS),
     >          YDAT(NAT,MAXANG,NGRIDS),ZDAT(NAT,MAXANG,NGRIDS),
     >          ATMXVEC(NAT,NAT),ATMYVEC(NAT,NAT),ATMZVEC(NAT,NAT),
     *          RI(NAT),RIJ(NAT,NAT),WTINTR(NAT),TOTWT(NAT,*),
     *          AIJ(NAT,NAT),IANGN(NAT,2,NGRIDS),
     *          PTRAD(ITMP),WTRAD(ITMP)
C
      LOGICAL LRDFLG,MLTINT,DOLRD
      COMMON /LRDISP/ ELRD6,ELRD8,ELRD10,EMULT,LRDFLG,MLTINT,DOLRD
      DIMENSION WTAB(NAT,NAT,*)
C
C**********************************************************************
C
C     DETERMINE GRID POINT VOLUMES (=WEIGHTS) FOR ONE OCTANT.
C     XCDNT ETC CONTAIN COORDINATES OF THE CENTRE OF A GRID POINT
C
C**********************************************************************
C
      DLB = IBTYP.EQ.1
C     WRITE(IW,*)'ITMP,IANGS:',ITMP,IANGN(NCNTR,1),IANGN(NCNTR,2)
C     WRITE(IW,*)'ZDAT: ',NCNTR,ZDAT(NCNTR,5)
C     WRITE(IW,*)'RAD: ',RAD
      IGRID = 1
C
      NTOTGRIDPOINTS(NCNTR)=0
C
      DO 600 IRAD=1,ITMP
         RADWT=RAD*RAD*RAD*WTRAD(IRAD)
         R1= RAD*PTRAD(IRAD)
C         WRITE(IW,'(A,I5,3F20.10)')'R1,PRUNERAD: ',NCNTR,
C     *        IPRUNECUTS(NCNTR),R1,PRUNERADS(IGRID,IPRUNECUTS(NCNTR))
         IF(R1.GE.PRUNERADS(IGRID,IPRUNECUTS(NCNTR))*RAD) THEN
            IGRID = IGRID + 1
         ENDIF
         NTOTGRIDPOINTS(NCNTR) = NTOTGRIDPOINTS(NCNTR) +
     *        IANGN(NCNTR,2,IGRID)-IANGN(NCNTR,1,IGRID)+1
C
         DO 605 I=IANGN(NCNTR,1,IGRID),IANGN(NCNTR,2,IGRID)
C            WRITE(IW,'(A,3I5)')'IRAD,IANGS: ',IRAD,
C     *                   IANGN(NCNTR,1,IGRID),IANGN(NCNTR,2,IGRID)
            IPT=(IRAD-1)*MAXANG+I
C
            IF(MOD(IPT,NPROC).NE.ME) GOTO 605
            IPTME=(IPT-1)/NPROC+1
            IF(DLB) IPTME=IPT
C
            XD=R1*XDAT(NCNTR,I,IGRID)
            YD=R1*YDAT(NCNTR,I,IGRID)
            ZD=R1*ZDAT(NCNTR,I,IGRID)
         DO 610 IATM=1,NAT
            XCDNT=ATMXVEC(NCNTR,IATM)+XD
            YCDNT=ATMYVEC(NCNTR,IATM)+YD
            ZCDNT=ATMZVEC(NCNTR,IATM)+ZD
            RSQRD=XCDNT**2+YCDNT**2+ZCDNT**2
            RI(IATM)=SQRT(RSQRD)
  610    CONTINUE
         WTTOT=ZERO
C
         CALL DACOPY(NAT,ONE,WTINTR,1)
C
         DO 611 IATM=1,NAT
C            WTINTR(IATM)=ONE
            IF (ABS(AIJ(IATM,1)+1.0D+00).LT.1.0D-05) THEN
              WTINTR(IATM) = 0.0D+00
              GOTO 614
            ENDIF
            DO 612 JATM=1,IATM-1
              IF (ABS(AIJ(IATM,JATM)-1.0D+00).LT.1.0D-05) THEN
                CUTIJ = 1.0D+00
                GOTO 620
              ENDIF
              ZMUIJ=(RI(IATM)-RI(JATM))/RIJ(IATM,JATM)
              XMUIJ=ZMUIJ
     >           +AIJ(IATM,JATM)*(ONE-ZMUIJ*ZMUIJ)
C***********************************************************************
C
C     BECKE'S FUZZY CELL METHOD FOR MOLECULAR GRID QUADRATURE
C
C***********************************************************************
C             F4=FUZZY(NITR,XMUIJ)
              F4=XMUIJ
C
C             DO K=1,NITR
C               F4=F4*(1.5D+00-0.5D+00*F4*F4)
C             END DO
C
C     THE ABOVE LOOP IS UNROLLED BELOW
C
C
              F41 = F4 *(1.5D+00-0.5D+00*F4 *F4 )
              F42 = F41*(1.5D+00-0.5D+00*F41*F41)
              F43 = F42*(1.5D+00-0.5D+00*F42*F42)
              F4  = F43*(1.5D+00-0.5D+00*F43*F43)
C
              F2=0.5D+00*F4
              CUTIJ=0.5D+00-F2
              CUTJI=0.5D+00+F2
  620       CONTINUE
              WTINTR(IATM)=WTINTR(IATM)*CUTIJ
              WTINTR(JATM)=WTINTR(JATM)*CUTJI
  612       CONTINUE
  614       CONTINUE
  611    CONTINUE
         DO IATM=1,NAT
            WTTOT=WTTOT+WTINTR(IATM)
         ENDDO
C
         ATMWT=WTINTR(NCNTR)/WTTOT
C         WRITE(6,'(A,2I5,3F30.10)')'WEIGHTS (OCT):',I,IGRID,
C     *        RADWT,ATMWT,WGHT(NCNTR,I,IGRID)
         TOTWT(NCNTR,IPTME)=ATMWT*RADWT*WGHT(NCNTR,I,IGRID)
C
         IF(LRDFLG) THEN
           DO IATM=1,NAT
             WTAB(NCNTR,IATM,IPTME)=WTINTR(IATM)/WTTOT
           END DO
         END IF
C
  605    CONTINUE
  600 CONTINUE
C      WRITE(IW,*)'TOTAL NUMBER OF POINTS FOR ',NCNTR,' = ',
C     *     NTOTGRIDPOINTS(NCNTR)
      RETURN
      END
C*MODULE DFTGRD  *DECK DFTGDV
C>    @brief Compute DFT energy gradient (functional part only)
C>
C>    @details FOR A FUNCTIONAL FXC[RO,DELTA_RO] WHERE DELTA_RO IS GRADIENT OF
C>     DENSITY TOTAL EXCHANGE-CORRELATION ENERGY E=INTEGRAL FXC DR
C>     BY TAKING DERIVATIVE OVER SOME NUCLEAR COORDINATE R,
C>     DE/DR =
C>       INTEGRAL DF/D(RO)*D(RO)/DR   DF/D(DELTA_RO)*D(DELTA_RO)/DR DR
C>     D(RO)/DR = - D(RO)/DR AND D(DELTA_RO)/DR = - D(DELTA_RO)/DR
C>     (WHERE R IS ELECTRON COORDINATE)
C>     DF/D(RO) AND DF/D(DELTA_RO) ARE STORED IN DUMA,DUMAX,DUMAY,DUMAZ
C>     FOR ALPHA DENSITY AND IN DUMB, DUMBX, DUMBY, DUMBZ FOR BETA.
C>     ALPHA + BETA DENSITY FORM ADDITIVE CONTRIBUTIONS TO THE GRADIENT.
C>     NEXT,   D(RO)/DR(L) = 2 * SUM(I,J) D(I,J) DF(I)/DR(L) * F(J)
C>     D(DELTA(K)_RO)/DR(L)= 2 * SUM(I,J) D(I,J)(DG[K](I)/DR[L]*F(J)
C>                             +G[K](I)*G[L](J))
C>     WHERE F(I) IS AO NUMBER I AND G[K](I) IS DF(I)/DR[K],
C>     AND D(I,J) IS DENSITY, STORED IN DA AND DB, FOR ALPHA AND BETA.
C>     F(I) IS STORED IN AOX, G[K](I) IN GAOX, GAOY, GAOZ,
C>     DG[K](I)/DR[L] IN G2AOXX,G2AOYY,G2AOZZ,G2AOXY,G2AOYZ,G2AOXZ.
C
      SUBROUTINE DFTGDV(NCNTR,DEDFT,FTOTWT,NUM,DUMA,DUMAX,DUMAY,DUMAZ,
     *                  DUMB,DUMBX,DUMBY,DUMBZ,AOX,GAOX,GAOY,GAOZ,
     *                  G2AOXX,G2AOYY,G2AOZZ,G2AOXY,G2AOYZ,G2AOXZ,
     *                  DA,DB,NEEDGR,UROHF,DMGA,DMGB,NEEDTAU)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION AOX(*),GAOX(*),GAOY(*),GAOZ(*),
     >     G2AOXX(*),G2AOYY(*),G2AOZZ(*),G2AOXY(*),G2AOYZ(*),G2AOXZ(*),
     >     DEDFT(3,*),DA(NUM,*),DB(NUM,*)
C
      LOGICAL NEEDGR,UROHF,NEEDTAU
C
      PARAMETER(TWO=2.0D+00,ZERO=0.0D+00)
      PARAMETER (MXSH=5000, MXGTOT=20000)
C
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
C
C
      IF (NEEDTAU.AND.(.NOT.UROHF))THEN
        DO ISHELL=1,NSHELL
          IAT =KATOM(ISHELL)
          IF(IAT.NE.NCNTR) THEN
          MINI=KMIN (ISHELL)
          MAXI=KMAX (ISHELL)
          LOCI=KLOC (ISHELL)-MINI
          GRADX=ZERO
          GRADY=ZERO
          GRADZ=ZERO
          DO IBFN=MINI,MAXI
            ICHI=LOCI+IBFN
            DRA=ZERO
            DRXA=ZERO
            DRYA=ZERO
            DRZA=ZERO
            DO JCHI=1,NUM
              DIJA=DA(JCHI,ICHI)
C
C             COMPUTE SUM(J) D(I,J) F(J)
C
              DRA= DRA+ DIJA*AOX(JCHI)
C
C             COMPUTE SUM(J) D(I,J) G[K](J)
C
              DRXA=DRXA+DIJA*GAOX(JCHI)
              DRYA=DRYA+DIJA*GAOY(JCHI)
              DRZA=DRZA+DIJA*GAOZ(JCHI)
C
            ENDDO
            GAOXI=GAOX(ICHI)
            GAOYI=GAOY(ICHI)
            GAOZI=GAOZ(ICHI)
C
C           COMPUTE -1/2*DF/D(RO)*D(RO)/DR
C                   = DF/D(RO)*SUM(I,J)D(I,J)DF(I)/DR*F(J)
C
            GRADX=GRADX+GAOXI*DRA*DUMA
            GRADY=GRADY+GAOYI*DRA*DUMA
            GRADZ=GRADZ+GAOZI*DRA*DUMA
C
C           COMPUTE -1/2* SUM(K) DF/D(DELTA[K]_RO)*D(DELTA[K]_RO)/DR[L]
C                    =    SUM(K) DF/D(DELTA[K]_RO)*SUM(I,J)D(I,J)
C    *                   (DG[K](I)/DR[L]*F(J)+G[K](I)*G[L](J))
C
            GRADX=GRADX+(G2AOXX(ICHI)*DRA + GAOXI*DRXA)*DUMAX +
     *                  (G2AOXY(ICHI)*DRA + GAOXI*DRYA)*DUMAY +
     *                  (G2AOXZ(ICHI)*DRA + GAOXI*DRZA)*DUMAZ
            GRADY=GRADY+(G2AOXY(ICHI)*DRA + GAOYI*DRXA)*DUMAX +
     *                  (G2AOYY(ICHI)*DRA + GAOYI*DRYA)*DUMAY +
     *                  (G2AOYZ(ICHI)*DRA + GAOYI*DRZA)*DUMAZ
            GRADZ=GRADZ+(G2AOXZ(ICHI)*DRA + GAOZI*DRXA)*DUMAX +
     *                  (G2AOYZ(ICHI)*DRA + GAOZI*DRYA)*DUMAY +
     *                  (G2AOZZ(ICHI)*DRA + GAOZI*DRZA)*DUMAZ
C
C     AT THIS POINT WE HAVE COMPLETED THE NUCLEAR GRADIENT CONTRIBUTIONS
C     FOR GGA TYPE FUNCTIONALS
C
            DO JCHI=1,NUM
              GRADX=GRADX+(G2AOXX(ICHI)*GAOX(JCHI)+
     >                     G2AOXY(ICHI)*GAOY(JCHI)+
     >                     G2AOXZ(ICHI)*GAOZ(JCHI))*DA(JCHI,ICHI)*DMGA
              GRADY=GRADY+(G2AOXY(ICHI)*GAOX(JCHI)+
     >                     G2AOYY(ICHI)*GAOY(JCHI)+
     >                     G2AOYZ(ICHI)*GAOZ(JCHI))*DA(JCHI,ICHI)*DMGA
              GRADZ=GRADZ+(G2AOXZ(ICHI)*GAOX(JCHI)+
     >                     G2AOYZ(ICHI)*GAOY(JCHI)+
     >                     G2AOZZ(ICHI)*GAOZ(JCHI))*DA(JCHI,ICHI)*DMGA
            ENDDO
C
C     AT THIS POINT WE HAVE COMPLETED THE NUCLEAR GRADIENT CONTRIBUTIONS
C     FOR META-GGA TYPE FUNCTIONALS
C
          ENDDO
C
          DEDFTGRADX = TWO*FTOTWT*GRADX
          DEDFTGRADY = TWO*FTOTWT*GRADY
          DEDFTGRADZ = TWO*FTOTWT*GRADZ
C
          DEDFT(1,IAT)=DEDFT(1,IAT)-DEDFTGRADX
          DEDFT(2,IAT)=DEDFT(2,IAT)-DEDFTGRADY
          DEDFT(3,IAT)=DEDFT(3,IAT)-DEDFTGRADZ
C
C         USING TRANSLATIONAL INVARIANCE SUM(B) GRAD(B) EXC = 0
C         TO GET GRAD(A) E = - SUM(B.NE.A) GRAD(B) EXC
C         FOR A=NCNTR, SINCE THE ABOVE CODE IS NOT CORRECT IN THIS CASE.
C
          DEDFT(1,NCNTR)=DEDFT(1,NCNTR)+DEDFTGRADX
          DEDFT(2,NCNTR)=DEDFT(2,NCNTR)+DEDFTGRADY
          DEDFT(3,NCNTR)=DEDFT(3,NCNTR)+DEDFTGRADZ
          ENDIF
        ENDDO
C
        RETURN
C
C       THE ABOVE RETURN IS NEEDED SINCE NEEDGR IS USUALLY TRUE WHEN
C       NEEDTAU IS TRUE.  MEANING THAT A META-GGA FUNCTIONAL WILL
C       USUALLY CONSIST OF A GGA FUNCTIONAL.
C
      END IF
C
      IF (NEEDTAU.AND.UROHF)THEN
        DO ISHELL=1,NSHELL
          IAT =KATOM(ISHELL)
          IF(IAT.NE.NCNTR) THEN
          MINI=KMIN (ISHELL)
          MAXI=KMAX (ISHELL)
          LOCI=KLOC (ISHELL)-MINI
          GRADX=ZERO
          GRADY=ZERO
          GRADZ=ZERO
          DO IBFN=MINI,MAXI
            ICHI=LOCI+IBFN
            DRA=ZERO
            DRB=ZERO
            DRXA=ZERO
            DRYA=ZERO
            DRZA=ZERO
            DRXB=ZERO
            DRYB=ZERO
            DRZB=ZERO
            DO JCHI=1,NUM
              DIJA=DA(JCHI,ICHI)
              DIJB=DB(JCHI,ICHI)
C
C             COMPUTE SUM(J) D(I,J) F(J)
C
              DRA= DRA+ DIJA*AOX(JCHI)
              DRB= DRB+ DIJB*AOX(JCHI)
C
C             COMPUTE SUM(J) D(I,J) G[K](J)
C
              DRXA=DRXA+DIJA*GAOX(JCHI)
              DRYA=DRYA+DIJA*GAOY(JCHI)
              DRZA=DRZA+DIJA*GAOZ(JCHI)
              DRXB=DRXB+DIJB*GAOX(JCHI)
              DRYB=DRYB+DIJB*GAOY(JCHI)
              DRZB=DRZB+DIJB*GAOZ(JCHI)
C
            ENDDO
            GAOXI=GAOX(ICHI)
            GAOYI=GAOY(ICHI)
            GAOZI=GAOZ(ICHI)
C
C           COMPUTE -1/2*DF/D(RO)*D(RO)/DR
C                   = DF/D(RO)*SUM(I,J)D(I,J)DF(I)/DR*F(J)
C
            GRADX=GRADX+GAOXI*DRA*DUMA
            GRADY=GRADY+GAOYI*DRA*DUMA
            GRADZ=GRADZ+GAOZI*DRA*DUMA
            GRADX=GRADX+GAOXI*DRB*DUMB
            GRADY=GRADY+GAOYI*DRB*DUMB
            GRADZ=GRADZ+GAOZI*DRB*DUMB
C
C           COMPUTE -1/2* SUM(K) DF/D(DELTA[K]_RO)*D(DELTA[K]_RO)/DR[L]
C                    =    SUM(K)DF/D(DELTA[K]_RO)*SUM(I,J)D(I,J)
C    *                   (DG[K](I)/DR[L]*F(J)+G[K](I)*G[L](J))
C
            GRADX=GRADX+(G2AOXX(ICHI)*DRA + GAOXI*DRXA)*DUMAX +
     *                  (G2AOXY(ICHI)*DRA + GAOXI*DRYA)*DUMAY +
     *                  (G2AOXZ(ICHI)*DRA + GAOXI*DRZA)*DUMAZ
            GRADY=GRADY+(G2AOXY(ICHI)*DRA + GAOYI*DRXA)*DUMAX +
     *                  (G2AOYY(ICHI)*DRA + GAOYI*DRYA)*DUMAY +
     *                  (G2AOYZ(ICHI)*DRA + GAOYI*DRZA)*DUMAZ
            GRADZ=GRADZ+(G2AOXZ(ICHI)*DRA + GAOZI*DRXA)*DUMAX +
     *                  (G2AOYZ(ICHI)*DRA + GAOZI*DRYA)*DUMAY +
     *                  (G2AOZZ(ICHI)*DRA + GAOZI*DRZA)*DUMAZ
            GRADX=GRADX+(G2AOXX(ICHI)*DRB + GAOXI*DRXB)*DUMBX +
     *                  (G2AOXY(ICHI)*DRB + GAOXI*DRYB)*DUMBY +
     *                  (G2AOXZ(ICHI)*DRB + GAOXI*DRZB)*DUMBZ
            GRADY=GRADY+(G2AOXY(ICHI)*DRB + GAOYI*DRXB)*DUMBX +
     *                  (G2AOYY(ICHI)*DRB + GAOYI*DRYB)*DUMBY +
     *                  (G2AOYZ(ICHI)*DRB + GAOYI*DRZB)*DUMBZ
            GRADZ=GRADZ+(G2AOXZ(ICHI)*DRB + GAOZI*DRXB)*DUMBX +
     *                  (G2AOYZ(ICHI)*DRB + GAOZI*DRYB)*DUMBY +
     *                  (G2AOZZ(ICHI)*DRB + GAOZI*DRZB)*DUMBZ
C
C     AT THIS POINT WE HAVE COMPLETED THE NUCLEAR GRADIENT CONTRIBUTIONS
C     FOR GGA TYPE FUNCTIONALS
C
            DO JCHI=1,NUM
              GRADX=GRADX+(G2AOXX(ICHI)*GAOX(JCHI)+
     >                     G2AOXY(ICHI)*GAOY(JCHI)+
     >                     G2AOXZ(ICHI)*GAOZ(JCHI))*DA(JCHI,ICHI)*DMGA
              GRADY=GRADY+(G2AOXY(ICHI)*GAOX(JCHI)+
     >                     G2AOYY(ICHI)*GAOY(JCHI)+
     >                     G2AOYZ(ICHI)*GAOZ(JCHI))*DA(JCHI,ICHI)*DMGA
              GRADZ=GRADZ+(G2AOXZ(ICHI)*GAOX(JCHI)+
     >                     G2AOYZ(ICHI)*GAOY(JCHI)+
     >                     G2AOZZ(ICHI)*GAOZ(JCHI))*DA(JCHI,ICHI)*DMGA
              GRADX=GRADX+(G2AOXX(ICHI)*GAOX(JCHI)+
     >                     G2AOXY(ICHI)*GAOY(JCHI)+
     >                     G2AOXZ(ICHI)*GAOZ(JCHI))*DB(JCHI,ICHI)*DMGB
              GRADY=GRADY+(G2AOXY(ICHI)*GAOX(JCHI)+
     >                     G2AOYY(ICHI)*GAOY(JCHI)+
     >                     G2AOYZ(ICHI)*GAOZ(JCHI))*DB(JCHI,ICHI)*DMGB
              GRADZ=GRADZ+(G2AOXZ(ICHI)*GAOX(JCHI)+
     >                     G2AOYZ(ICHI)*GAOY(JCHI)+
     >                     G2AOZZ(ICHI)*GAOZ(JCHI))*DB(JCHI,ICHI)*DMGB
            ENDDO
C
C     AT THIS POINT WE HAVE COMPLETED THE NUCLEAR GRADIENT CONTRIBUTIONS
C     FOR META-GGA TYPE FUNCTIONALS
C
          ENDDO
C
          DEDFTGRADX = TWO*FTOTWT*GRADX
          DEDFTGRADY = TWO*FTOTWT*GRADY
          DEDFTGRADZ = TWO*FTOTWT*GRADZ
C
          DEDFT(1,IAT)=DEDFT(1,IAT)-DEDFTGRADX
          DEDFT(2,IAT)=DEDFT(2,IAT)-DEDFTGRADY
          DEDFT(3,IAT)=DEDFT(3,IAT)-DEDFTGRADZ
C
C         USING TRANSLATIONAL INVARIANCE SUM(B) GRAD(B) EXC = 0
C         TO GET GRAD(A) E = - SUM(B.NE.A) GRAD(B) EXC
C         FOR A=NCNTR, SINCE THE ABOVE CODE IS NOT CORRECT IN THIS CASE.
C
          DEDFT(1,NCNTR)=DEDFT(1,NCNTR)+DEDFTGRADX
          DEDFT(2,NCNTR)=DEDFT(2,NCNTR)+DEDFTGRADY
          DEDFT(3,NCNTR)=DEDFT(3,NCNTR)+DEDFTGRADZ
          ENDIF
        ENDDO
C
        RETURN
C
C       THE ABOVE RETURN IS NEEDED SINCE NEEDGR IS USUALLY TRUE WHEN
C       NEEDTAU IS TRUE.  MEANING THAT A META-GGA FUNCTIONAL WILL
C       USUALLY CONSIST OF A GGA FUNCTIONAL.
C
      END IF
C
      IF (NEEDGR.AND.(.NOT.UROHF)) THEN
        DO ISHELL=1,NSHELL
          IAT =KATOM(ISHELL)
          IF(IAT.NE.NCNTR) THEN
          MINI=KMIN (ISHELL)
          MAXI=KMAX (ISHELL)
          LOCI=KLOC (ISHELL)-MINI
          GRADX=ZERO
          GRADY=ZERO
          GRADZ=ZERO
          DO IBFN=MINI,MAXI
            ICHI=LOCI+IBFN
            DRA=ZERO
            DRXA=ZERO
            DRYA=ZERO
            DRZA=ZERO
            DO JCHI=1,NUM
              DIJA=DA(JCHI,ICHI)
C
C             COMPUTE SUM(J) D(I,J) F(J)
C
              DRA= DRA+ DIJA*AOX(JCHI)
C
C             COMPUTE SUM(J) D(I,J) G[K](J)
C
              DRXA=DRXA+DIJA*GAOX(JCHI)
              DRYA=DRYA+DIJA*GAOY(JCHI)
              DRZA=DRZA+DIJA*GAOZ(JCHI)
C
            ENDDO
            GAOXI=GAOX(ICHI)
            GAOYI=GAOY(ICHI)
            GAOZI=GAOZ(ICHI)
C
C           COMPUTE -1/2*DF/D(RO)*D(RO)/DR
C                   = DF/D(RO)*SUM(I,J)D(I,J)DF(I)/DR*F(J)
C
            GRADX=GRADX+GAOXI*DRA*DUMA
            GRADY=GRADY+GAOYI*DRA*DUMA
            GRADZ=GRADZ+GAOZI*DRA*DUMA
C
C           COMPUTE -1/2* SUM(K) DF/D(DELTA[K]_RO)*D(DELTA[K]_RO)/DR[L]
C                     =   SUM(K) DF/D(DELTA[K]_RO)*SUM(I,J)D(I,J)
C    *                   (DG[K](I)/DR[L]*F(J)+G[K](I)*G[L](J))
C
            GRADX=GRADX+(G2AOXX(ICHI)*DRA + GAOXI*DRXA)*DUMAX +
     *                  (G2AOXY(ICHI)*DRA + GAOXI*DRYA)*DUMAY +
     *                  (G2AOXZ(ICHI)*DRA + GAOXI*DRZA)*DUMAZ
            GRADY=GRADY+(G2AOXY(ICHI)*DRA + GAOYI*DRXA)*DUMAX +
     *                  (G2AOYY(ICHI)*DRA + GAOYI*DRYA)*DUMAY +
     *                  (G2AOYZ(ICHI)*DRA + GAOYI*DRZA)*DUMAZ
            GRADZ=GRADZ+(G2AOXZ(ICHI)*DRA + GAOZI*DRXA)*DUMAX +
     *                  (G2AOYZ(ICHI)*DRA + GAOZI*DRYA)*DUMAY +
     *                  (G2AOZZ(ICHI)*DRA + GAOZI*DRZA)*DUMAZ
C
C     AT THIS POINT WE HAVE COMPLETED THE NUCLEAR GRADIENT CONTRIBUTIONS
C     FOR GGA TYPE FUNCTIONALS
C
          ENDDO
C
          DEDFTGRADX = TWO*FTOTWT*GRADX
          DEDFTGRADY = TWO*FTOTWT*GRADY
          DEDFTGRADZ = TWO*FTOTWT*GRADZ
C
          DEDFT(1,IAT)=DEDFT(1,IAT)-DEDFTGRADX
          DEDFT(2,IAT)=DEDFT(2,IAT)-DEDFTGRADY
          DEDFT(3,IAT)=DEDFT(3,IAT)-DEDFTGRADZ
C
C         USING TRANSLATIONAL INVARIANCE SUM(B) GRAD(B) EXC = 0
C         TO GET GRAD(A) E = - SUM(B.NE.A) GRAD(B) EXC
C         FOR A=NCNTR, SINCE THE ABOVE CODE IS NOT CORRECT IN THIS CASE.
C
          DEDFT(1,NCNTR)=DEDFT(1,NCNTR)+DEDFTGRADX
          DEDFT(2,NCNTR)=DEDFT(2,NCNTR)+DEDFTGRADY
          DEDFT(3,NCNTR)=DEDFT(3,NCNTR)+DEDFTGRADZ
          ENDIF
        ENDDO
      ENDIF
C
      IF (NEEDGR.AND.UROHF) THEN
        DO ISHELL=1,NSHELL
          IAT =KATOM(ISHELL)
          IF(IAT.NE.NCNTR) THEN
          MINI=KMIN (ISHELL)
          MAXI=KMAX (ISHELL)
          LOCI=KLOC (ISHELL)-MINI
          GRADX=ZERO
          GRADY=ZERO
          GRADZ=ZERO
          DO IBFN=MINI,MAXI
            ICHI=LOCI+IBFN
            DRA=ZERO
            DRB=ZERO
            DRXA=ZERO
            DRYA=ZERO
            DRZA=ZERO
            DRXB=ZERO
            DRYB=ZERO
            DRZB=ZERO
            DO JCHI=1,NUM
              DIJA=DA(JCHI,ICHI)
              DIJB=DB(JCHI,ICHI)
C
C             COMPUTE SUM(J) D(I,J) F(J)
C
              DRA= DRA+ DIJA*AOX(JCHI)
              DRB= DRB+ DIJB*AOX(JCHI)
C
C             COMPUTE SUM(J) D(I,J) G[K](J)
C
              DRXA=DRXA+DIJA*GAOX(JCHI)
              DRYA=DRYA+DIJA*GAOY(JCHI)
              DRZA=DRZA+DIJA*GAOZ(JCHI)
              DRXB=DRXB+DIJB*GAOX(JCHI)
              DRYB=DRYB+DIJB*GAOY(JCHI)
              DRZB=DRZB+DIJB*GAOZ(JCHI)
C
            ENDDO
            GAOXI=GAOX(ICHI)
            GAOYI=GAOY(ICHI)
            GAOZI=GAOZ(ICHI)
C
C           COMPUTE -1/2*DF/D(RO)*D(RO)/DR
C                   = DF/D(RO)*SUM(I,J)D(I,J)DF(I)/DR*F(J)
C
            GRADX=GRADX+GAOXI*DRA*DUMA
            GRADY=GRADY+GAOYI*DRA*DUMA
            GRADZ=GRADZ+GAOZI*DRA*DUMA
            GRADX=GRADX+GAOXI*DRB*DUMB
            GRADY=GRADY+GAOYI*DRB*DUMB
            GRADZ=GRADZ+GAOZI*DRB*DUMB
C
C           COMPUTE -1/2* SUM(K) DF/D(DELTA[K]_RO)*D(DELTA[K]_RO)/DR[L]
C                     =   SUM(K) DF/D(DELTA[K]_RO)*SUM(I,J)D(I,J)
C                        (DG[K](I)/DR[L]*F(J)+G[K](I)*G[L](J))
C
            GRADX=GRADX+(G2AOXX(ICHI)*DRA + GAOXI*DRXA)*DUMAX +
     *                  (G2AOXY(ICHI)*DRA + GAOXI*DRYA)*DUMAY +
     *                  (G2AOXZ(ICHI)*DRA + GAOXI*DRZA)*DUMAZ
            GRADY=GRADY+(G2AOXY(ICHI)*DRA + GAOYI*DRXA)*DUMAX +
     *                  (G2AOYY(ICHI)*DRA + GAOYI*DRYA)*DUMAY +
     *                  (G2AOYZ(ICHI)*DRA + GAOYI*DRZA)*DUMAZ
            GRADZ=GRADZ+(G2AOXZ(ICHI)*DRA + GAOZI*DRXA)*DUMAX +
     *                  (G2AOYZ(ICHI)*DRA + GAOZI*DRYA)*DUMAY +
     *                  (G2AOZZ(ICHI)*DRA + GAOZI*DRZA)*DUMAZ
            GRADX=GRADX+(G2AOXX(ICHI)*DRB + GAOXI*DRXB)*DUMBX +
     *                  (G2AOXY(ICHI)*DRB + GAOXI*DRYB)*DUMBY +
     *                  (G2AOXZ(ICHI)*DRB + GAOXI*DRZB)*DUMBZ
            GRADY=GRADY+(G2AOXY(ICHI)*DRB + GAOYI*DRXB)*DUMBX +
     *                  (G2AOYY(ICHI)*DRB + GAOYI*DRYB)*DUMBY +
     *                  (G2AOYZ(ICHI)*DRB + GAOYI*DRZB)*DUMBZ
            GRADZ=GRADZ+(G2AOXZ(ICHI)*DRB + GAOZI*DRXB)*DUMBX +
     *                  (G2AOYZ(ICHI)*DRB + GAOZI*DRYB)*DUMBY +
     *                  (G2AOZZ(ICHI)*DRB + GAOZI*DRZB)*DUMBZ
          ENDDO
C
          DEDFTGRADX = TWO*FTOTWT*GRADX
          DEDFTGRADY = TWO*FTOTWT*GRADY
          DEDFTGRADZ = TWO*FTOTWT*GRADZ
C
          DEDFT(1,IAT)=DEDFT(1,IAT)-DEDFTGRADX
          DEDFT(2,IAT)=DEDFT(2,IAT)-DEDFTGRADY
          DEDFT(3,IAT)=DEDFT(3,IAT)-DEDFTGRADZ
C
C         USING TRANSLATIONAL INVARIANCE SUM(B) GRAD(B) EXC = 0
C         TO GET GRAD(A) E = - SUM(B.NE.A) GRAD(B) EXC
C         FOR A=NCNTR, SINCE THE ABOVE CODE IS NOT CORRECT IN THIS CASE.
C
          DEDFT(1,NCNTR)=DEDFT(1,NCNTR)+DEDFTGRADX
          DEDFT(2,NCNTR)=DEDFT(2,NCNTR)+DEDFTGRADY
          DEDFT(3,NCNTR)=DEDFT(3,NCNTR)+DEDFTGRADZ
          ENDIF
        ENDDO
      ENDIF
C
      IF ((.NOT.NEEDGR).AND.(.NOT.UROHF)) THEN
        DO ISHELL=1,NSHELL
          IAT =KATOM(ISHELL)
          IF(IAT.NE.NCNTR) THEN
          MINI=KMIN (ISHELL)
          MAXI=KMAX (ISHELL)
          LOCI=KLOC (ISHELL)-MINI
          GRADX=ZERO
          GRADY=ZERO
          GRADZ=ZERO
          DO IBFN=MINI,MAXI
            ICHI=LOCI+IBFN
            DRA=ZERO
            DO JCHI=1,NUM
              DIJA=DA(JCHI,ICHI)
C
C             COMPUTE SUM(J) D(I,J) F(J)
C
              DRA= DRA+ DIJA*AOX(JCHI)
            ENDDO
            GAOXI=GAOX(ICHI)
            GAOYI=GAOY(ICHI)
            GAOZI=GAOZ(ICHI)
C
C           COMPUTE -1/2*DF/D(RO)*D(RO)/DR
C                   = DF/D(RO)*SUM(I,J)D(I,J)DF(I)/DR*F(J)
C
            GRADX=GRADX+GAOXI*DRA*DUMA
            GRADY=GRADY+GAOYI*DRA*DUMA
            GRADZ=GRADZ+GAOZI*DRA*DUMA
          ENDDO
C
C     AT THIS POINT WE HAVE COMPLETED THE NUCLEAR GRADIENT CONTRIBUTIONS
C     FOR LDA TYPE FUNCTIONALS
C
          DEDFTGRADX = TWO*FTOTWT*GRADX
          DEDFTGRADY = TWO*FTOTWT*GRADY
          DEDFTGRADZ = TWO*FTOTWT*GRADZ
C
          DEDFT(1,IAT)=DEDFT(1,IAT)-DEDFTGRADX
          DEDFT(2,IAT)=DEDFT(2,IAT)-DEDFTGRADY
          DEDFT(3,IAT)=DEDFT(3,IAT)-DEDFTGRADZ
C
C         USING TRANSLATIONAL INVARIANCE SUM(B) GRAD(B) EXC = 0
C         TO GET GRAD(A) E = - SUM(B.NE.A) GRAD(B) EXC
C         FOR A=NCNTR, SINCE THE ABOVE CODE IS NOT CORRECT IN THIS CASE.
C
          DEDFT(1,NCNTR)=DEDFT(1,NCNTR)+DEDFTGRADX
          DEDFT(2,NCNTR)=DEDFT(2,NCNTR)+DEDFTGRADY
          DEDFT(3,NCNTR)=DEDFT(3,NCNTR)+DEDFTGRADZ
          ENDIF
        ENDDO
      ENDIF
C
      IF ((.NOT.NEEDGR).AND.UROHF) THEN
        DO ISHELL=1,NSHELL
          IAT =KATOM(ISHELL)
          IF(IAT.NE.NCNTR) THEN
          MINI=KMIN (ISHELL)
          MAXI=KMAX (ISHELL)
          LOCI=KLOC (ISHELL)-MINI
          GRADX=ZERO
          GRADY=ZERO
          GRADZ=ZERO
          DO IBFN=MINI,MAXI
            ICHI=LOCI+IBFN
            DRA=ZERO
            DRB=ZERO
            DO JCHI=1,NUM
              DIJA=DA(JCHI,ICHI)
              DIJB=DB(JCHI,ICHI)
C
C             COMPUTE SUM(J) D(I,J) F(J)
C
              DRA= DRA+ DIJA*AOX(JCHI)
              DRB= DRB+ DIJB*AOX(JCHI)
            ENDDO
            GAOXI=GAOX(ICHI)
            GAOYI=GAOY(ICHI)
            GAOZI=GAOZ(ICHI)
C
C           COMPUTE -1/2*DF/D(RO)*D(RO)/DR
C                   = DF/D(RO)*SUM(I,J)D(I,J)DF(I)/DR*F(J)
C
            GRADX=GRADX+GAOXI*DRA*DUMA
            GRADY=GRADY+GAOYI*DRA*DUMA
            GRADZ=GRADZ+GAOZI*DRA*DUMA
            GRADX=GRADX+GAOXI*DRB*DUMB
            GRADY=GRADY+GAOYI*DRB*DUMB
            GRADZ=GRADZ+GAOZI*DRB*DUMB
          ENDDO
C
C     AT THIS POINT WE HAVE COMPLETED THE NUCLEAR GRADIENT CONTRIBUTIONS
C     FOR LDA TYPE FUNCTIONALS
C
          DEDFTGRADX = TWO*FTOTWT*GRADX
          DEDFTGRADY = TWO*FTOTWT*GRADY
          DEDFTGRADZ = TWO*FTOTWT*GRADZ
C
          DEDFT(1,IAT)=DEDFT(1,IAT)-DEDFTGRADX
          DEDFT(2,IAT)=DEDFT(2,IAT)-DEDFTGRADY
          DEDFT(3,IAT)=DEDFT(3,IAT)-DEDFTGRADZ
C
C         USING TRANSLATIONAL INVARIANCE SUM(B) GRAD(B) EXC = 0
C         TO GET GRAD(A) E = - SUM(B.NE.A) GRAD(B) EXC
C         FOR A=NCNTR, SINCE THE ABOVE CODE IS NOT CORRECT IN THIS CASE.
C
          DEDFT(1,NCNTR)=DEDFT(1,NCNTR)+DEDFTGRADX
          DEDFT(2,NCNTR)=DEDFT(2,NCNTR)+DEDFTGRADY
          DEDFT(3,NCNTR)=DEDFT(3,NCNTR)+DEDFTGRADZ
          ENDIF
        ENDDO
      ENDIF
C
      RETURN
      END
C*MODULE DFTGRD  *DECK DFTDER
C>    @brief Analytical DFT gradient
C>
C>    @author MUNEAKI KAMIYA, TAKAO TSUNEDA, SUSUMU YANAGISAWA, DMITRI FEDOROV
C
      SUBROUTINE DFTDER
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000)
C
      LOGICAL UROHF,OUT,GOPARR,DSKWRK,MASWRK
C
      COMMON /FMCOM / X(1)
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      COMMON /DNSAO / IDENAO
C
      DATA UHF,ROHF/8HUHF     ,8HROHF    /
      DATA DEBUG/8HDEBUG   /, DFTGRD/8HDERDFT  /,GRD1/8HGRD1    /
      DATA CHECK/8HCHECK   /
C
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3=L1*L1
C
      UROHF = SCFTYP.EQ.UHF  .OR.  SCFTYP.EQ.ROHF
      OUT=(EXETYP.EQ.DFTGRD.OR.EXETYP.EQ.DEBUG.OR.EXETYP.EQ.GRD1).AND.
     *     MASWRK
C
      CALL GRDDFT(L2,NDFTEN)
C
      CALL VALFM(LOADFM)
C
      IDFTEN  = LOADFM  + 1
      IG2AXX  = IDFTEN  + NDFTEN
      IG2AYY  = IG2AXX  + NUM
      IG2AZZ  = IG2AYY  + NUM
      IG2AXY  = IG2AZZ  + NUM
      IG2AYZ  = IG2AXY  + NUM
      IG2AXZ  = IG2AYZ  + NUM
      ICOEFFA = IG2AXZ  + NUM
      ICOEFFB = ICOEFFA + NUM*NUM
      LDA     = ICOEFFB + NUM*NUM
      LDB     = LDA     + L2
      LDDA    = LDB     + L2
      LDDB    = LDDA    + L3
      LDEDFT  = LDDB    + L3
      IUVEC   = LDEDFT  + NAT*3
      IDWTINT = IUVEC   + NAT*3
      IDWTTOT = IDWTINT + 3*NAT*NAT
      IDTOTWT = IDWTTOT + 3*NAT
      LAST    = IDTOTWT + 3*NAT
C
      NEED = LAST - LOADFM - 1
C
C     ---- GET MEMORY ----
C
      CALL GETFM(NEED)
C     WRITE(6,*) 'WWWAHAHAA',NDFTEN,NUM,L2,L3,NAT
      IF(MASWRK) WRITE(IW,9000) NEED
      IF(EXETYP.EQ.CHECK) GO TO 800
C
C     READ OR GENERATE DFT GRID. NOTE THAT THIS CAN BE A DIFFERENT GRID
C     COMPARED TO THE DFT ENERGY, BECAUSE THE SYMMETRY OF THE GRADIENT
C     COMPONENTS IS NOT THE SAME AS OF THE ENERGY, SO WE IN FACT TURN
C     OFF USING OCTANT SYMMETRY, BUT KEEP ATOMIC CENTRE SYMMETRY.
C     IN CASE OF C1 AND NON-ABELIAN GROUPS, OCTANT SYMMETRY IS NOT USED
C     SO THE GRID INFORMATIONS CAN BE READ.
C
      CALL DFTSET(X(IDFTEN),0,.TRUE.)
C
      IF(IDENAO.EQ.0) THEN
         CALL DAREAD(IDAF,IODA,X(ICOEFFA),NUM*NUM,15,0)
C     ----- TRANSPOSE X(ICOEFFA) FOR EFFICIENCY -----
C     ----- USE X(LDDA) FOR TEMPORARY STORAGE   -----
         CALL TRPOSE(X(ICOEFFA),X(LDDA),L1,L1,1)
      END IF
      CALL DAREAD(IDAF,IODA,X(LDA),L2,16,0)
      CALL EXPND(X(LDA),X(LDDA),L1,0)
      IF(IDENAO.EQ.1) THEN
         CALL DCOPY(L2,X(LDA),1,X(ICOEFFA),1)
      ENDIF
      IF (UROHF) THEN
         IF(IDENAO.EQ.0) THEN
            CALL DAREAD(IDAF,IODA,X(ICOEFFB),NUM*NUM,19,0)
C     ----- TRANSPOSE X(ICOEFFB) FOR EFFICIENCY -----
C     ----- USE X(LDDB) FOR TEMPORARY STORAGE   -----
            CALL TRPOSE(X(ICOEFFB),X(LDDB),L1,L1,1)
         ENDIF
         CALL DAREAD(IDAF,IODA,X(LDB),L2,20,0)
         CALL EXPND(X(LDB),X(LDDB),L1,0)
         IF(IDENAO.EQ.1) THEN
            CALL DCOPY(L2,X(LDB),1,X(ICOEFFB),1)
         ENDIF
      ENDIF
      CALL VCLR(X(LDEDFT),1,NAT*3)
      CALL DFTGRAD(X(IDFTEN),X(IG2AXX),X(IG2AYY),X(IG2AZZ),X(IG2AXY),
     *             X(IG2AYZ),X(IG2AXZ),X(ICOEFFA),X(ICOEFFB),X(LDDA),
     *             X(LDDB),X(LDEDFT),X(IUVEC),X(IDWTINT),X(IDWTTOT),
     *             X(IDTOTWT),L1,TOTELE,OUT)
C
      IF(OUT) WRITE(IW,9100)
      IF(OUT) CALL EGOUT(X(LDEDFT),NAT)
      CALL VADD(DE,1,X(LDEDFT),1,DE,1,3*NAT)
C
  800 CONTINUE
      CALL RETFM(NEED)
      CALL TIMIT(1)
      RETURN
C
 9000 FORMAT(1X,'MEMORY FOR GRID POINT CONTRIBUTIONS TO THE',
     *          ' DFT GRADIENT=',I10,' WORDS.')
 9100 FORMAT(/1X,'TOTAL DFT GRADIENT TERMS')
      END
C
C*MODULE DFTGRD  *DECK BRAGGRAD
C> @brief   Return Bragg/Slater radius, in atomic units.
C>
C> @details  Bragg/Slater radius determines the radial extent
C>          of the Euler/McLaurin radial quadratures.
C>          Standard values are known for all elements.
C>          Ghost atoms receive the correct radius for use in
C>          BSSE runs.  Bond functions receive no grid at all,
C>          through a zero radius, since the grid on adjacent
C>          atoms should adequately integrate the bond center.
C>          Sparkles are also given zero radius, based in part
C>          on their complete lack of any chemical identity.
C>
C> @param   IATOM = the atom's position in the molecule
C>
C> @author  Mike Schmidt: 10/2012
C
      DOUBLE PRECISION FUNCTION BRAGGRAD(IATOM)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXATM=2000)
      PARAMETER (MXGRID=10)
      LOGICAL SG1
C
      COMMON /DFGRID/ DFTTHR,DFTGTHR,SWOFF,SW0,BSLRD(137),NDFTFG,
     *                NRAD,NTHE,NPHI,NRAD0,NTHE0,NPHI0,
     *                NANGPT(MXGRID),NANGPT0(MXGRID),SG1,JANS
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /ZANDAT/ ZANINP(MXATM)
C
      PARAMETER (ZERO=0.0D+00,BOHR=0.52917715D+00)
C
C        purpose:
C        return a reasonable Bragg/Slater radius for atom -IATOM-
C
C        if -IATOM- is a ghost atom in counterpoise corrected DFT,
C        the original input negative nuclear charge lets us look
C        up the true radius of that element.
C
C        bond functions and/or sparkles assign zero radius,
C        which is equivalent to no grid at all.
C
      TINY = 0.00001D+00
C
C        Fragment MO is presumed not to be worried about counterpoise,
C        and to have its IAN array set appropriately, for simple lookup.
C
      IF(NFG.NE.0) THEN
         NUCZ=IAN(IATOM)
         IF(NUCZ.GT.0) THEN
            BRAGGRAD = BSLRD(NUCZ)
         ELSE
            BRAGGRAD = ZERO
         END IF
         BRAGGRAD = BRAGGRAD/BOHR
         RETURN
      END IF
C
      ZNUC = ZANINP(IATOM)
C
      IF(ZNUC.GT.ZERO) THEN
        NUCZ = INT(ZNUC+TINY)
        IF(ABS(ZNUC-NUCZ).LE.TINY) THEN
           BRAGGRAD = BSLRD(NUCZ)
        ELSE
           BRAGGRAD = ZERO
        END IF
      ELSE
        NUCZ = INT(-ZNUC+TINY)
        IF(ABS(-ZNUC-NUCZ).LE.TINY) THEN
           BRAGGRAD = BSLRD(NUCZ)
        ELSE
           BRAGGRAD = ZERO
        END IF
      END IF
C
      BRAGGRAD = BRAGGRAD/BOHR
C
      RETURN
      END
