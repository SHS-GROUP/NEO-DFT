C 18 Feb 13 - MWS - EFGRAD: project gradient if PBC is being used
C 19 Oct 12 - MWS - synchronize FRGINF common
C 21 MAR 12 - TLW,ACW,MWS - REMOVED CALL VNNDER
C                           ADDED CALL EFPDERCOM
C 28 DEC 11 - CS  - EFMO CHANGES FOR COVALENT BONDS
C  2 NOV 11 - MWS - ENABLE FRAGMENT ONLY NUMERICAL GRADIENT PATHWAY
C 11 AUG 11 - AAD - QM/EFP ENERGY DECOMPOSITION ANALYSIS
C 12 DEC 10 - HL  - ADD ARTIFICIAL FORCES ON ATOMS/FRAGMENTS
C  1 OCT 10 - CS  - ADDED EFMO CHANGES
C 11 AUG 10 - DGF - ALLOCATE NEEDED STORAGE FOR PRJGRD
C 25 MAR 10 - HL  - CHANGES FOR CORRECT EFP(NO POL)+PCM JOBS
C 25 MAR 10 - DJS,DGF - PAD COMMON BLOCK PCMPNT, ARGS FOR GRADIENT PROJ.
C  1 MAY 09 - LVS - CHANGES TO ALLOW FOR FORCE POINTS
C  1 MAY 09 - NMT - NEW DIMENSION FOR EFPBAS AND FRAGMT
C 12 JAN 09 - DGF - SYNCHRONISE PCMPNT, AGAIN
C 20 NOV 08 - HL  - POLPCM: REMOVE CHARGE PENETRATION FOR EFP/PCM,
C                   USE AVERAGED INDUCED DIPOLES FOR EFP/PCM
C 23 OCT 08 - LVS - DISPERSION DAMPING, CLEAN UP JIE'S CODE
C 20 AUG 07 - LVS - PBC-EFP CLEANED
C 24 MAR 07 - LVS - PAD FRGINF,EFPPAR; PRINT FUNCTION PREFP ADDED
C 17 JAN 06 - HL  - MD SWITCHING FUNCTIONS, CHANGES TO IND.DIP.,EFP/PCM
C 14 NOV 05 - HL  - POLPCM ADDED TO ALLOW FOR EFP+PCM COMPUTATIONS
C 19 SEP 05 - HMN,IA - CHANGES FOR MOLECULAR DYNAMICS
C 15 JUL 05 - MWS - EFPPOL,EFPPOL2: RESTRICT VCLR RANGES
C 13 JUL 05 - MWS - CHANGE DYN.STORE FOR CHGTRN,EFPPOL
C  5 JUL 05 - MWS - ALLOCATE DYNAMIC MEMORY FOR DIPIT
C 27 JUN 05 - HL  - PERIODIC BOUNDARY COND, PARALLEL EFP2 DISPERSION
C  1 JUN 05 - MWS - EFSP: SUM ALL ES TERMS IN PARALLEL RUN
C 30 APR 05 - DGF - SYNCHRONISE OPTGRD COMMON BLOCK
C 14 MAR 05 - HL  - EFP CHARGE TRANSFER ENERGY, PAULI CHANGES
C  7 MAR 05 - IA  - EFP2 DISPERSION AND DYNAMIC POLARIZABILITY
C 22 FEB 05 - MWS - EFSP: CHANGE ENERGY PRINTING (AND DEBUG OUTPUTS)
C 13 FEB 05 - HMN - ADD DUMMY EFP MD HOOKS INTO EFSP,
C                   ADD EFP PARALLELIZATION INTO EFSP AND EFPPOL
C 13 FEB 05 - JS  - ADD EFP MP2 CALLS TO EFSP AND EFPPOL, ADD EFPPOL2
C 23 JUL 04 - HL  - EFSP: DO FORMAL MEMORY ALLOCATION FOR EFPPOL CALL
C  9 DEC 03 - MWS - EFGRAD: KILL NUMERICAL HESSIAN REQUEST
C  3 JUL 03 - JMM - SUPPRESS PRINTING FOR MONTE CARLO JOBS
C  7 AUG 02 - HT  - USE DYNAMIC MEMORY FOR EFP PAULI REPULSION
C 17 APR 02 - MWS - SYNCH UP FRGINF COMMON
C 13 JUN 01 - MAF - EFSP: COMPUTE CHARGE PENETRATION ENERGY
C 20 FEB 01 - PND - EFSP,EFPPOL: DIP.CONV. AND PRINTING CHANGES
C 25 MAR 00 - MWS - CHANGE ARGUMENTS TO VNNDER
C 20 NOV 97 - MWS - EFSP: USE JAN'S PAULI EXCHANGE ROUTINE
C  2 SEP 97 - MWS - EFSP: CHANGE WORDING OF ENERGY OUTPUT
C 16 MAY 97 - GNM - EFFECTIVE FRAGMENT DRIVER MODULE CREATED
C
C*MODULE EFDRVR  *DECK EFSP
C>
C>     @brief Main EFP energy driver
C>
C>     @details This routine calculates fragment-fragment interaction
C>     energies in the absence of an ab initio molecule
C>
C>     @date 10/5/12 - Spencer Pruitt
C>     - Added EFMOCHTNRG, EFMOREPNRG andD EFMOEPEN to transfer relevant
C>       energies to EFMO code.
C>     @date March, 2013 - Colleen Bertoni
C>     - Cleared LSABSAVE and LSABGRAD so they won't cause
C>       memory errors when different EFMO terms are turned on
C>       and off.
C>
C>     @param EFMOCHTNRG: EFMO charge transfer energy
C>
C>     @param EFMOREPNRG: EFMO repulsion energy
C>
C>     @param EFMOEPEN: EFMO charge penetration energy
C
      SUBROUTINE EFSP
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL IFGRAD
      LOGICAL IFEWLD,TNFOIL,EWLDPL,DEBUGOPT
      LOGICAL IFRCPNT
C
      LOGICAL EFMODOEFPC
      PARAMETER (MXAO=8192, MXATM=2000, MXDFG=5, MXFRG=1050,
     *           MXPT=2000, MXFGPT=12000, MXIFRQ=12,
     *           MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (ZERO = 0.0D+00, HALF=0.50D+00, FACT=1.593601268D-03)
C
      CHARACTER*8 FRCNME,LJNAME,ELJNAM
      DOUBLE PRECISION MD
C
      COMMON /CENTRL/ RQM,XQM,YQM,ZQM,RMM,XMM,YMM,ZMM,ICENFD
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,
     *                EFMOREPNRG,EFMOCHTNRG,EFMOEPEN,EFMOPCMG,
     *                IEFMORUN,IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,
     *                IEFMODIM(2),IMODEFE,NATEFMO,IMODEFD,IMODEFER,
     *                IMODEFCT,IDIMTYP
      COMMON /EFPCT / NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CTFOK(MXAO,MXDFG),NCTMO(MXDFG),NTCTMO
      COMMON /EFPIO / MULMAT(MXFRG)
      COMMON /EFPFRC/ IFRCPNT,NTFRCPN,NFRCPNT(MXFRG),LSTFPTS(MXFRG),
     *                FRCCRD(3,MXFGPT),FRCNME(MXFGPT),FRCTRQ(6,MXFGPT)
     *                ,FRCTRQX(6,MXFGPT)
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FMCOM / XX(1)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGLJP/ CORDLJ(3,MXPT),ELJCRD(3,MXFGPT),
     *                POTLJ(2,MXPT),ELJPOT(2,MXFGPT),
     *                LJNAME(MXPT),ELJNAM(MXFGPT),
     *                NLJPTS(MXFRG),NLJTTPT,ILJP,NMLJ(2)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /FRGNRG/ CCNRG,CDNRG,CQNRG,CONRG,DDNRG,DQNRG,QQNRG,
     *                ESNRG,REPNRG,POLNRG,DISNRG,DISNRG8,
     *                EDISD,CHTNRG
      COMMON /FUNCT / E,EG(3*MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /OPTGRD/ Q(3*MXATM),ES,QQ(20),
     *                CONVF,FMAXT,DXMAXT,RMAX,RMIN,RLIM,
     *                EIGMAX,EIGMIN,GRDERR,FRMS,FMAX,TRMAX,TRMIN,
     *                IC(20),NSTEP,NSERCH,NPMAX,NP,IFOLOW,
     *                NNEG,IUPHSS,IEXIT,ITRUPD,IPAD,KDIAGH
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SIMDAT/ NACC,NREJ,IGOMIN,NRPA,IBWM,NACCT,NREJT,NRPAT,
     *                NPRTGO,IDPUNC,IGOFLG
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCMDIM/ MXSP,MXTS,MEMPCM1,MEMPCM2,NTS
      COMMON /PCMOPT/ RABI,RASC,REFPOL,THRSLS,DENSLS,WB,WA,ETA2,GD,EVAC,
     *                RHOW,PM,AREATL,AREAKP,BONDRY,OMEGA,RET,FRO,EPSINF,
     *                EPS,DR,RSOLV,VMOL,TCE,STEN,DSTEN,CMF,TABS,IDIRCT,
     *                IPCDER,IDP,ICOMP,IFIELD,ICAV,IDISP,IPRINT,IRETCAV,
     *                ICENT,IFAST,NEVAL,KEFPOL,KEEPSM,IMGABI,IMGASC,NADD
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IRPPCM,IEF,IP_F,NFMOPCM
      COMMON /PCMPNT/ LXYZRE,LSSFE,LLIST,LALPCM,LRINPCM,LINAPCM,LINFPCM,
     *                LINIPCM,LMEPCM,LAXYZCT,LXYZCT2,LNVERT,LQSN,LQSE,
     *                LQFS,LQIND,LISPHE,LVAD,LQOR,LVECMUL,LAIPRJ,LFIPRJ,
     *                LPEL,LPCMCDR,LDAI,LIDDAI,LQSND,LQSED
      COMMON /PCMPRT/ GCAVP,GCAVS,GDISP,GREP,EHFGAS
      COMMON /PCMEFP/ PB_MUL,PC_MUL,PB_POL,PC_POL,P_FF,P_NF,P_FN,P_I,
     *                P_IBIS,P_J,P_NUCC,P_NUCCBIS,ENPCM
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
      COMMON /EWALD / IFEWLD,TNFOIL,BETA,ELCNST,EPSLN,CUTOFF,CUTLST,
     *                KMAX,NKVEC,LEVEL,EWLDPL
      COMMON /SELFE / ESELFCC, ESELFDD, EEXCLCC, EEXCLCD, EEXCLDD,
     *                EEXCLCQ
      COMMON /EFPMP2/ MP2TYP
C
      DATA HSSIAN/8HHESSIAN /, SADPT/8HSADPOINT/
      DATA AIRC/8HIRC     /
      DATA MD /8HMD      /
C
C     -------------------------------------------------------------
C     --- THIS ROUTINE CALCULATES FRAGMENT-FRAGMENT INTERACTION ---
C     --- ENERGIES IN THE ABSENCE OF AN AB INITIO MOLECULE      ---
C     -------------------------------------------------------------
C
C     FIRST, INITIALIZE SOME PARALLELIZATION INFORMATION.
C
      CALL EFPPARL
C
C     CCNRG  = CHARGE-CHARGE INTERACTION ENERGY
C     CDNRG  = CHARGE-DIPOLE INTERACTION ENERGY
C     CQNRG  = CHARGE-QUADRUPOLE INTERACTION ENERGY
C     CONRG  = CHARGE-OCTUPOLE INTERACTION ENERGY
C     DDNRG  = DIPOLE-DIPOLE INTERACTION ENERGY
C     DQNRG  = DIPOLE-QUADRUPOLE INTERACTION ENERGY
C     QQNRG  = QUADRUPOLE-QUADRUPOLE INTERACTION ENERGY
C     ESNRG  = TOTAL ELECTROSTATIC INTERACTION ENERGY
C     REPNRG = EXCHANGE-REPULSION ENERGY
C     POLNRG = POLARIZATION ENERGY
C     DISNRG = MP2/EFP1 C6 DISPERSION ENERGY
C     DISNRG8= MP2/EFP1 C8 DISPERSION ENERGY
C     EDISD  = EFP2 DAMPED DISPERSION ENERGY
C     CHTNRG = EFP2 CHARGE TRANSFER ENERGY
C     ENPCM  = PCM ELECTROSTATIC SOLVATION ENERGY
C     GCAVP  = PCM CAVITATION ENERGY
C     GDISP  = PCM DISPERSION ENERGY
C     GREP   = PCM REPULSION ENERGY
C
      E      = ZERO
      CCNRG  = ZERO
      CDNRG  = ZERO
      CQNRG  = ZERO
      CONRG  = ZERO
      DDNRG  = ZERO
      DQNRG  = ZERO
      QQNRG  = ZERO
      ESNRG  = ZERO
      REPNRG = ZERO
      POLNRG = ZERO
      DISNRG = ZERO
      DISNRG8= ZERO
      EDISD  = ZERO
      EDISD0  = ZERO
      CHTNRG = ZERO
      ENPCM  = ZERO
      GCAVP  = ZERO
      GDISP  = ZERO
      GREP   = ZERO
      EPEN   = ZERO
C
C     -- EFP CENTER OF MASS --
C
      CALL EFCM
C
C     -- ELECTROSTATIC ENERGIES --
C     ELECTROSTATIC ENERGIES (AND GRADIENTS) ARE DONE IN FFELEC NOW,
C     REPLACING THE SMALL ARMY OF ROUTINES CHGCHG, ETC. ETC.
C
      MAXDER = 0
      CALL DERCHK(MAXDER)
                                          IFGRAD = .FALSE.
      IF(MAXDER.GT.0)                     IFGRAD = .TRUE.
      IF(MAXDER.EQ.1  .AND.  NGLEVL.EQ.1) IFGRAD=.FALSE.
      IF(MAXDER.EQ.2  .AND.  NHLEVL.EQ.2) IFGRAD=.FALSE.
C
      IF(IEFMORUN.GT.0) THEN
        IF(IEFMORT.NE.3) GOTO 10
        IF(IEFMORT.EQ.3.AND.IDIMTYP.EQ.-1) GOTO 10
      ENDIF
C
      CALL FFELEC(ESNRG,CCNRG,CDNRG,CQNRG,CONRG,DDNRG,DQNRG,QQNRG,
     *                  IFGRAD,.FALSE.)
 10   CONTINUE
C
      IF (IFEWLD) THEN
C  ---- EWALD SUMS: DIRECT TERM IS CALCULATED WITHIN FFELEC
C  ---- HERE WE CALCULATE OTHER TERMS:
C  ---- SELF-ENERGY & EXCLUSION ENERGY, RECIPROCAL, AND TIN-FOIL PART
C
         ESNRG = ESNRG + ESELFCC + ESELFDD + EEXCLCC + EEXCLCD
     *         + EEXCLDD + EEXCLCQ
C
         CALL RECIPR(ERCPRCC,ERCPRCD,ERCPRDD,ERCPRCQ,ERCPRDQ,
     *                    ERCPRQQ,ERCPRCO,IFGRAD)
C         WRITE(6,988) ERCPRCC,ERCPRCD,ERCPRDD,ERCPRCQ
C  988  FORMAT(/1X,'ERCPRCC = ',F18.14/
C     *        1X,'ERCPRCD = ',F18.14/
C     *        1X,'ERCPRDD = ',F18.14/
C     *        1X,'ERCPRCQ = ',F18.14)
         ESNRG = ESNRG +
     *           ERCPRCC + ERCPRCD + ERCPRDD  + ERCPRCQ
C
         CALL TINFOIL(ETFCC,ETFCD,ETFDD, IFGRAD)
C        WRITE(6,989) ETFCC,ETFCD,ETFDD
C  989  FORMAT(/1X,'ETFCC = ',F18.14/
C     *        1X,'ETFCD = ',F18.14/
C     *        1X,'ETFDD = ',F18.14)
         ESNRG = ESNRG + ETFCC + ETFCD + ETFDD
C         WRITE(6,*) 'TOTAL CHARGE-CHARGE: ',CCNRG + ESELFCC +
C     *               EEXCLCC + ERCPRCC + ETINFOIL
C
C  ---- THIS IS DEBUGGING OPTION WHICH CALCULATES ELECTROSTATIC SUM
C  ---- DIRECTLY. FOR UNCLEAR REASON, WORKS PROPERLY ONLY FOR ATOMS NOT
C  ---- FOR MOLECULES
         DEBUGOPT=.FALSE.
         IF (DEBUGOPT) CALL DIRECTSUM
      END IF
C
C     -- EXCHANGE-REPULSION ENERGY ---
C
C      MEMORY FOR SAB MATRIX: NEED TO KEEP IT FOR DISPERSION DAMPING
C
      LSABSAVE = 0
      LSABGRAD = 0
      IF (NTMO.GT.0) THEN
         MXMO=0
         MXBF=0
         DO I = 1, NFRG
            MXMO=MAX(MXMO,NORB(I))
            MXBF=MAX(MXBF,NPBF(I))
         END DO
C
         CALL VALFM(LOADFM1)
         LSABSAVE = LOADFM1 + 1
         LSABGRAD = LSABSAVE + NFRG*NFRG*MXMO*MXMO
         IF (IFGRAD) THEN
            MEMGRAD = NFRG*NFRG*MXMO*MXMO*6
         ELSE
            MEMGRAD = 0
         END IF
         LAST1 = LSABGRAD + MEMGRAD
         NEEDSAB = LAST1 - LOADFM1 -1
         CALL GETFM(NEEDSAB)
      END IF
C
      IF(IREP.EQ.1 .AND. ILJP.EQ.1) THEN
         CALL ENRGLJ(REPNRG)
      ELSE IF(IREP.EQ.1 .AND. ILJP.EQ.0) THEN
         MXRPTS = 0
         DO IFRG = 1,NFRG
            MXRPTS = MAX(NRPTS(IFRG),MXRPTS)
         ENDDO
         MXRPTS = MXRPTS+1
         NDFRG2 = (NDFRG*NDFRG+NDFRG)/2
         LEN = MXRPTS*MXRPTS*NDFRG2
         CALL VALFM(LOADFM)
         LAREL = LOADFM + 1
         LCREL = LAREL + LEN
         LEFLD = LCREL + LEN
         LEFAD = LEFLD + 3*NPTTPT
         LAST  = LEFAD + 3*NPTTPT
         NEED = LAST - LOADFM - 1
         CALL GETFM(NEED)
         CALL DAREAD(IDAF,IODA,XX(LAREL),2*LEN,75,0)
C
         CALL EREPUL(REPNRG,XX(LAREL),XX(LCREL),MXRPTS,NDFRG2)
         CALL RETFM(NEED)
      ELSE IF (NTMO.GT.0) THEN
         MXMO2=(MXMO*MXMO+MXMO)/2
         LENPV=MXBF*NTMO
         LENFM=MXMO2*NFRG
C
C        IF GRADIENT IS NOT NEEDED
         IF(IFGRAD .EQV. .FALSE.) THEN
           CALL VALFM(LOADFM)
           LPROVEC = LOADFM  + 1
           LFOCKMA = LPROVEC + MXBF*NTMO
           LSMAT   = LFOCKMA + MXMO2*NFRG
           LTMAT   = LSMAT   + MXBF*MXBF
           LWRK    = LTMAT   + MXBF*MXBF
           LSIJ    = LWRK    + MXBF
           LTIJ    = LSIJ    + MXMO*MXMO
           LFASQ   = LTIJ    + MXMO*MXMO
           LFBSQ   = LFASQ   + MXMO*MXMO
           LAST    = LFBSQ   + MXMO*MXMO
           NEED=LAST-LOADFM-1
           CALL GETFM(NEED)
           CALL DAREAD(IDAF,IODA,XX(LPROVEC),LENPV,267,0)
           CALL DAREAD(IDAF,IODA,XX(LFOCKMA),LENFM,268,0)
           CALL EXREP(REPNRG,XX(LPROVEC),XX(LFOCKMA),XX(LSMAT),
     *                XX(LTMAT),XX(LWRK),XX(LSIJ),XX(LTIJ),
     *                XX(LFASQ),XX(LFBSQ),XX(LSABSAVE),MXBF,MXMO,EPEN)
           CALL RETFM(NEED)
         ELSE
C          - CALCULATE ENERGY & GRADIENTS TOGETHER
           CALL VALFM(LOADFM)
           LPROVEC = LOADFM  + 1
           LDPVEC  = LPROVEC + MXBF*NTMO
           LFOCKMA = LDPVEC  + MXBF*NTMO*3
           LSMAT   = LFOCKMA + MXMO2*NFRG
           LTMAT   = LSMAT   + MXBF*MXBF
           LWRK    = LTMAT   + MXBF*MXBF
           LSAB    = LWRK    + MXBF
           LTAB    = LSAB    + MXMO*MXMO
           LFASQ   = LTAB    + MXMO*MXMO
           LFBSQ   = LFASQ   + MXMO*MXMO
           LDSINT  = LFBSQ   + MXMO*MXMO
           LDTINT  = LDSINT  + MXBF*MXBF*6
           LDSAB   = LDTINT  + MXBF*MXBF*6
           LDTAB   = LDSAB   + MXMO*MXMO*6
           LWRK2   = LDTAB   + MXMO*MXMO*6
           LGXRFRG = LWRK2   + MXMO*MXMO
           LXRFRG  = LGXRFRG + NFRG*NFRG*6
           LAST    = LXRFRG  + NFRG*NFRG*6*4
           NEED=LAST-LOADFM-1
           CALL GETFM(NEED)
           CALL DAREAD(IDAF,IODA,XX(LPROVEC),LENPV,267,0)
           CALL DAREAD(IDAF,IODA,XX(LFOCKMA),LENFM,268,0)
           CALL DERVEC(1,XX(LDPVEC),XX(LPROVEC),MXBF,NTMO)
C  DIFFERENT SUBROUTINE IF NEED TO GATHER EFP FORCES AT FORCE POINTS
           IF (IFRCPNT) THEN
           CALL GEXREP_FP(REPNRG,XX(LPROVEC),XX(LFOCKMA),XX(LSMAT),
     *                 XX(LTMAT),XX(LWRK),XX(LSAB),XX(LTAB),
     *                 XX(LFASQ),XX(LFBSQ),XX(LDPVEC),XX(LDSINT),
     *                 XX(LDTINT),XX(LDSAB),XX(LDTAB),XX(LWRK2),
     *                 XX(LGXRFRG),XX(LSABSAVE),XX(LSABGRAD),
     *                 MXBF,MXMO,XX(LXRFRG),EPEN)
           ELSE
           CALL GEXREP(REPNRG,XX(LPROVEC),XX(LFOCKMA),XX(LSMAT),
     *                 XX(LTMAT),XX(LWRK),XX(LSAB),XX(LTAB),
     *                 XX(LFASQ),XX(LFBSQ),XX(LDPVEC),XX(LDSINT),
     *                 XX(LDTINT),XX(LDSAB),XX(LDTAB),XX(LWRK2),
     *                 XX(LGXRFRG),XX(LSABSAVE),XX(LSABGRAD),
     *                 MXBF,MXMO,XX(LXRFRG),EPEN)
           END IF
           CALL RETFM(NEED)
         END IF
C
      END IF
C
C     -- ARTIFICIAL FORCE ON FRAGMENTS --
C        WATER RADIUS = 1.928 A, INPUT RMM=13.072 FOR R = 15.0
C        ONLY ENERGY IS DONE HERE, GRADIENT IS IN DECK VNNDER
C
      IF(ICENFD.EQ.1) THEN
         ECENT = ZERO
         R0    = RMM
         RX    = XMM
         RY    = YMM
         RZ    = ZMM
         POWER = 2.0D+00
         DO IFRG = 1, NFRG
            COMX  = EFCENT(1,IFRG)
            COMY  = EFCENT(2,IFRG)
            COMZ  = EFCENT(3,IFRG)
            XABS  = ABS(COMX)
            YABS  = ABS(COMY)
            ZABS  = ABS(COMZ)
            COMR2 = COMX*COMX + COMY*COMY + COMZ*COMZ
            COMR  = SQRT(COMR2)
            IF(COMR.GT.R0) THEN
               ECENT= ECENT + (COMR-R0)**POWER
            END IF
            IF(XABS.GT.RX) THEN
               ECENT= ECENT + (XABS-RX)**POWER
            END IF
            IF(YABS.GT.RY) THEN
               ECENT= ECENT + (YABS-RY)**POWER
            END IF
            IF(ZABS.GT.RZ) THEN
               ECENT= ECENT + (ZABS-RZ)**POWER
            END IF
         ENDDO
C        - THE BEST IS TO ADD ECENT TO EFP-EFP REPULSION -
         REPNRG = REPNRG + ECENT
      END IF
C
C
C     -- MP2/EFP1 DISPERSION ENERGY --
C
      IF(MP2TYP.EQ.1) THEN
         MXDPTS = 0
         DO IFRG = 1,NFRG
            MXDPTS = MAX(NDPTS(IFRG),MXDPTS)
         ENDDO
         MXDPTS = MXDPTS+1
         NDFRG2 = (NDFRG*NDFRG+NDFRG)/2
         LEN = MXDPTS*MXDPTS*NDFRG2
         DISNRG = ZERO
         DISNRG8= ZERO
C
         CALL VALFM(LOADFM)
         LAREL = LOADFM + 1
         LDREL = LAREL + LEN
         LCREL = LDREL + LEN
         LAST  = LCREL + LEN
         LBREL = LAST  + LEN
         LEREL = LBREL + LEN
         LAST1 = LEREL + LEN
         NEED  = LAST1 - LOADFM - 1
         CALL GETFM(NEED)
         CALL DAREAD(IDAF,IODA,XX(LAREL),6*LEN,81,0)
         CN=6.0D+00
         CALL EDISPR(DISNRG,XX(LAREL),XX(LDREL),XX(LCREL),
     *               MXDPTS,NDFRG2,CN)
         CN=8.0D+00
         CALL EDISPR(DISNRG8,XX(LAST),XX(LBREL),XX(LEREL),
     *               MXDPTS,NDFRG2,CN)
         CALL RETFM(NEED)
      END IF
C
C     -- POLARIZATION ENERGY ---
C     -- PCM SOLVATION ENERGY --
C
      MXPPT = 0
      DO IFRG = 1,NFRG
         MXPPT = MAX(NPPTS(IFRG),MXPPT)
      ENDDO
C
      IF(IPCM.EQ.1) THEN
          NPRTBK=NPRINT
          NPRINT=817
          IF(ICAV.EQ.1) CALL CAVITM
          IF(IDISP.EQ.1) CALL DISRPM
          NPRINT=NPRTBK
C
          CALL VALFM(LOADFM)
          LEFLD = LOADFM + 1
          LEFAD = LEFLD  + 3*NPTTPT
          LAST  = LEFAD  + 3*NPTTPT
          NEED=LAST - LOADFM -1
          CALL GETFM(NEED)
          CALL POLPCM(XX(LEFLD),XX(LEFAD),XX(LQSE),XX(LQSED),
     *                XX(LQSN),XX(LAXYZCT),XX(LAXYZCT+MXTS),
     *                XX(LAXYZCT+MXTS*2),XX(LAXYZCT+MXTS*3),
     *                XX(LXYZRE),XX(LXYZRE+MXSP),XX(LXYZRE+MXSP*2),
     *                XX(LXYZRE+MXSP*3),XX(LISPHE),XX(LLIST),POLNRG)
          CALL RETFM(NEED)
      ELSE IF (IEFP.EQ.1) THEN
          CALL VALFM(LOADFM)
          LEFLD = LOADFM + 1
          LEFAD = LEFLD + 3*NPTTPT
          LAST  = LEFAD + 3*NPTTPT
          NEED=LAST-LOADFM-1
          CALL GETFM(NEED)
          CALL EFPPOL(XX(LEFLD),XX(LEFAD),POLNRG)
          CALL RETFM(NEED)
      END IF
C
C     -- EFP2 CHARGE TRANSFER ENERGY --
C
C EFP2 CHARGE TRANSFER NOT YET DERIVED FOR OPEN SHELL (ROHF) METHOD
C
C CHECK TO SEE IF ANY MULTIPLICITIES ARE GREATER THAN 1
C IF SO, SKIP CT CALCULATIONS ALTOGETHER
C
C THIS SKIPS ANY CT CALCULATION BETWEEN
C CLOSED-SHELL MOLECULES AS WELL
C
      DO I=1,NFRG
       IF (MULMAT(I) .GT. 1)  GOTO 100
      END DO
C
      IF(NTCTMO.GT.0)THEN
         MXAOEFP=0
         MXBFEFP=0
         MXCTMOEFP=0
         DO I = 1, NFRG
            MXAOEFP=MAX(MXAOEFP,NAO(ISET(I)))
            MXBFEFP=MAX(MXBFEFP,NPBF(I))
            MXCTMOEFP=MAX(MXCTMOEFP,NCTMO(ISET(I)))
         END DO
         LENCV=MXBFEFP*NTCTMO
C
C        IF NO GRADIENTS
         IF(IFGRAD .EQV. .FALSE.) THEN
           CALL VALFM(LOADFM)
           LCTVEC  = LOADFM  + 1
           LSMAT   = LCTVEC  + MXBFEFP*NTCTMO
           LTFRG   = LSMAT   + MXBFEFP*MXBFEFP
           LTMAT   = LTFRG   + MXCTMOEFP*MXCTMOEFP*MXDFG
           LWRK    = LTMAT   + MXBFEFP*MXBFEFP
           LSAB    = LWRK    + MXBFEFP
           LTAB    = LSAB    + MXCTMOEFP*MXCTMOEFP
           LVEFP   = LTAB    + MXCTMOEFP*MXCTMOEFP
           LVABEFB = LVEFP   + MXBFEFP*MXBFEFP
           LVABEFA = LVABEFB + MXCTMOEFP*MXCTMOEFP
           LVAAEFB = LVABEFA + MXCTMOEFP*MXCTMOEFP
           LVBBEFA = LVAAEFB + MXCTMOEFP*MXCTMOEFP
           LECTFRG = LVBBEFA + MXCTMOEFP*MXCTMOEFP
           LIDOIT  = LECTFRG + NFRG*NFRG
           LQUAD   = LIDOIT  + NMTTPT
           LAST    = LQUAD   + 6*NMTTPT
           NEED=LAST-LOADFM-1
           CALL GETFM(NEED)
           CALL DAREAD(IDAF,IODA,XX(LCTVEC),LENCV,269,0)
           CALL CHGTRN(CHTNRG,XX(LCTVEC),XX(LSMAT),XX(LTFRG),
     *                 XX(LTMAT),XX(LWRK),XX(LSAB),XX(LTAB),
     *                 XX(LVEFP),XX(LVABEFB),XX(LVABEFA),
     *                 XX(LVAAEFB),XX(LVBBEFA),XX(LECTFRG),
     *                 XX(LIDOIT),XX(LQUAD),MXBFEFP,MXCTMOEFP)
           CALL RETFM(NEED)
         ELSE
C          RUN ENERGY & GRADIENTS TOGETHER
           CALL VALFM(LOADFM)
           LCTVEC  = LOADFM  + 1
           LDCVEC  = LCTVEC  + MXBFEFP*NTCTMO
           LSMAT   = LDCVEC  + MXBFEFP*NTCTMO*3
           LTFRG   = LSMAT   + MXBFEFP*MXBFEFP
           LTMAT   = LTFRG   + MXCTMOEFP*MXCTMOEFP*MXDFG
           LWRK    = LTMAT   + MXBFEFP*MXBFEFP
           LSAB    = LWRK    + MXBFEFP
           LTAB    = LSAB    + MXCTMOEFP*MXCTMOEFP
           LVEFP   = LTAB    + MXCTMOEFP*MXCTMOEFP
           LVABEFB = LVEFP   + MXBFEFP*MXBFEFP
           LVABEFA = LVABEFB + MXCTMOEFP*MXCTMOEFP
           LVAAEFB = LVABEFA + MXCTMOEFP*MXCTMOEFP
           LVBBEFA = LVAAEFB + MXCTMOEFP*MXCTMOEFP
           LDSINT  = LVBBEFA + MXCTMOEFP*MXCTMOEFP
           LDTINT  = LDSINT  + MXBFEFP*MXBFEFP*6
           LDSAB   = LDTINT  + MXBFEFP*MXBFEFP*6
           LDTAB   = LDSAB   + MXCTMOEFP*MXCTMOEFP*6
           LWRK2   = LDTAB   + MXCTMOEFP*MXCTMOEFP*6
           LDABEFB = LWRK2   + MXCTMOEFP*MXCTMOEFP
           LDABEFA = LDABEFB + MXCTMOEFP*MXCTMOEFP*6
           LDAAEFB = LDABEFA + MXCTMOEFP*MXCTMOEFP*6
           LDBBEFA = LDAAEFB + MXCTMOEFP*MXCTMOEFP*6
           LDVEFP  = LDBBEFA + MXCTMOEFP*MXCTMOEFP*6
           LGCTFRG = LDVEFP  + MXBFEFP*MXBFEFP*6
           LIDOIT  = LGCTFRG + NFRG*NFRG*6
           LQUAD   = LIDOIT  + NMTTPT
           LAST    = LQUAD   + 6*NMTTPT
           NEED=LAST-LOADFM-1
           CALL GETFM(NEED)
           CALL DAREAD(IDAF,IODA,XX(LCTVEC),LENCV,269,0)
           CALL DERVEC(2,XX(LDCVEC),XX(LCTVEC),MXBFEFP,NTCTMO)
           CALL GCTANA(CHTNRG,XX(LCTVEC),XX(LSMAT),XX(LTFRG),
     *                 XX(LTMAT),XX(LWRK),XX(LSAB),XX(LTAB),
     *                 XX(LVEFP),XX(LVABEFB),XX(LVABEFA),
     *                 XX(LVAAEFB),XX(LVBBEFA),XX(LDCVEC),
     *                 XX(LDSINT),XX(LDTINT),XX(LDSAB),XX(LDTAB),
     *                 XX(LWRK2),XX(LDABEFB),XX(LDABEFA),
     *                 XX(LDAAEFB),XX(LDBBEFA),XX(LDVEFP),
     *                 XX(LGCTFRG),XX(LIDOIT),XX(LQUAD),MXBFEFP,
     *                 MXCTMOEFP)
           CALL RETFM(NEED)
         END IF
      END IF
C
C     -- EFP2 DYNAMIC POLARIZATION ENERGY/GRADIENTS ---
C
C DDK
C EFP2 DISPERSION NOT YET DERIVED FOR  OPEN SHELL (ROHF) METHOD
C
C CHECK TO SEE IF ANY MULTIPLICITIES ARE GREATER THAN 1
C IF SO, SKIP DISPERSION CALCULATIONS ALTOGETHER
C
C THIS SKIPS ANY DISPERSION CALCULATION BETWEEN
C CLOSED-SHELL MOLECULES AS WELL
C
      DO I=1,NFRG
       IF (MULMAT(I) .GT. 1)  GOTO 100
      END DO
      IF (NDPTTPT.GT.0) THEN
         CALL VALFM(LOADFM)
         LDYNTR = LOADFM + 1
         LAST   = LDYNTR + NFRG*MXIFRQ*MXPPT
         NEED   = LAST -LOADFM -1
         CALL GETFM(NEED)
         CALL EFPDYN(EDISD,EDISD0,XX(LDYNTR),XX(LSABSAVE),
     *        XX(LSABGRAD),MXPPT)
         CALL RETFM(NEED)
      END IF
C
 100  CONTINUE
C
C       RETURN SAB MEMORY HERE
      IF(IREP.NE.1 .AND. NTMO.GT.0) CALL RETFM(NEEDSAB)
C
C     ******************
C     -- TOTAL ENERGY --
C     ******************
C         ESNRG = CCNRG + CDNRG + CQNRG + CONRG + DDNRG + DQNRG + QQNRG
C
      E = ESNRG+REPNRG+POLNRG+EDISD+CHTNRG+DISNRG+DISNRG8
     *  + HALF*ENPCM + FACT*(GCAVP+GDISP+GREP) + EPEN
C
C
      NEVALS = NEVALS + 1
C
C     -- PRINT OUT ENERGIES --
C
C     IF EFMO, TRANSFER ENERGIES TO COMMON AND SKIP PRINTOUT
      IF(IEFMORUN.GT.0) THEN
        EFMOESERG = ESNRG
        EFMOPOLERG = POLNRG
        EFMODISERG = EDISD
        EFMOREPNRG = REPNRG
        EFMOCHTNRG = CHTNRG
        EFMOEPEN = EPEN
C        GOTO 800
        IF(IPCM.EQ.1.AND.IEFMORT.EQ.4) EFMOPCMG=ENPCM*HALF
      ENDIF
      IF(RUNTYP.EQ.MD) GOTO 800
C
C         IF YOU ASSIGN IGOFLG=2 HERE, YOU WILL GET FULL ENERGY OUTPUT
C         FOR ALL GEOMETRIES COMPUTED, GOOD FOR DEBUGGING TERM BY TERM.
C
C      IGOFLG=2
C
      IF(MASWRK  .AND.  IGOFLG.EQ.2) WRITE(IW,9010)
C
C         NOTE THAT THE TOTAL ENERGY IS INSIDE THE IGOFLG=2 PORTION
C         OF THE ELSE CLAUSE, TO SUPPRESS MONTE CARLO ENERGIES,
C         BUT THE MORE BASIC RUNS ALWAYS PRODUCE TOTAL ENERGY OUTPUT.
C
C     IF((RUNTYP.EQ.OPTIMIZ .AND. NSERCH.NE.0) .OR.
      IF(
     *   (RUNTYP.EQ.SADPT   .AND. NSERCH.NE.0) .OR.
     *   (RUNTYP.EQ.AIRC)                      .OR.
     *   (RUNTYP.EQ.HSSIAN)) THEN
         IF(MASWRK  .AND.  IGOFLG.EQ.2) THEN
            WRITE(IW,9090) ESNRG
            WRITE(IW,9100) REPNRG
            WRITE(IW,9110) POLNRG
            IF(IEFDP.EQ.1) WRITE(IW,9111) EDISD
            IF(NTCTMO.GT.0) WRITE(IW,9112) CHTNRG
            IF(MP2TYP.EQ.1) THEN
              WRITE(IW,9130) DISNRG
              WRITE(IW,9140) DISNRG8
            END IF
            WRITE(IW,9210)
         END IF
         IF(MASWRK) THEN
           IF(IPCM.EQ.1) THEN
              WRITE(IW,9300) E
           ELSE
              WRITE(IW,9200) E
           END IF
         END IF
         IGOFLG=1
      ELSE
         IF(MASWRK.AND.  IGOFLG.EQ.2) THEN
            WRITE(IW,9020) CCNRG
            WRITE(IW,9030) CDNRG
            WRITE(IW,9040) CQNRG
            WRITE(IW,9050) CONRG
            WRITE(IW,9060) DDNRG
            WRITE(IW,9070) DQNRG
            WRITE(IW,9080) QQNRG
            WRITE(IW,9089) EPEN
           WRITE(IW,9220)
C            WRITE(IW,9090) ESNRG
            WRITE(IW,9090) ESNRG+EPEN
            WRITE(IW,9100) REPNRG
            WRITE(IW,9110) POLNRG
            IF(IEFDP.EQ.1) WRITE(IW,9111) EDISD
C            IF(IEFDP.EQ.1) WRITE(IW,9113) EDISD0
            IF(NTCTMO.GT.0) WRITE(IW,9112) CHTNRG
            IF(MP2TYP.EQ.1) THEN
              WRITE(IW,9130) DISNRG
              WRITE(IW,9140) DISNRG8
            END IF
            WRITE(IW,9210)
            IF(IPCM.EQ.1) THEN
               WRITE(IW,9300) E
            ELSE
               WRITE(IW,9200) E
            END IF
         END IF
C        IGOFLG=1
         WRITE(IW,*)
         CALL EFDIPOLE
         WRITE(IW,*)
      END IF
C
 800  CONTINUE
C
      RETURN
C
 9010 FORMAT(/17X,38('-')/
     *       17X,'FRAGMENT-FRAGMENT INTERACTION ENERGIES'/
     *       17X,38('-')/)
 9020 FORMAT(17X,'CHARGE-CHARGE         = ',F14.10)
 9030 FORMAT(17X,'CHARGE-DIPOLE         = ',F14.10)
 9040 FORMAT(17X,'CHARGE-QUADRUPOLE     = ',F14.10)
 9050 FORMAT(17X,'CHARGE-OCTUPOLE       = ',F14.10)
 9060 FORMAT(17X,'DIPOLE-DIPOLE         = ',F14.10)
 9070 FORMAT(17X,'DIPOLE-QUADRUPOLE     = ',F14.10)
 9080 FORMAT(17X,'QUADRUPOLE-QUADRUPOLE = ',F14.10)
 9089 FORMAT(17X,'OVERLAP PEN. ENERGY   = ',F14.10)
 9090 FORMAT(17X,'ELECTROSTATIC ENERGY  = ',F14.10)
C 9091 FORMAT(17X,'ELECTR + PEN ENERGY   = ',F14.10)
 9100 FORMAT(17X,'REPULSION ENERGY      = ',F14.10)
 9110 FORMAT(17X,'POLARIZATION ENERGY   = ',F14.10)
 9111 FORMAT(17X,'DISPERSION ENERGY     = ',F14.10)
C 9113 FORMAT(17X,'DISPERSION ZERO ENERGY= ',F14.10)
 9112 FORMAT(17X,'CHARGE TRANSFER ENRGY = ',F14.10)
 9130 FORMAT(17X,'C6 DISPERSION ENERGY  = ',F14.10)
 9140 FORMAT(17X,'C8 DISPERSION ENERGY  = ',F14.10)
 9200 FORMAT(17X,'FINAL EFP ENERGY      = ',F14.10)
 9210 FORMAT(17X,38('-'))
 9220 FORMAT(41X,14('-'))
 9300 FORMAT(17X,'FINAL EFPPCM ENERGY   = ',F14.10)
C
      END
C*MODULE EFDRVR  *DECK EFPPOL
      SUBROUTINE EFPPOL(EFLD,EFADD,POLNRG)
C
C --------------------------------------------------------------
C --- THIS ROUTINE CALCULATES FRAGMENT-FRAGMENT POLARIZATION ---
C ---   ENERGIES IN THE ABSENCE OF AN AB INITO MOLECULE      ---
C --------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXFRG=1050, MXFGPT=12000, MXIFRQ=12,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (ZERO=0.0D+00, DEBYE=2.541766D+00)
C
      CHARACTER*8 POLNAM,DPOLNAM
C
      LOGICAL MINMEM
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL IFEWLD,TNFOIL,EWLDPL,DEBUGOPT
C
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ*MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,
     *                EFMOREPNRG,EFMOCHTNRG,EFMOEPEN,EFMOPCMG,
     *                IEFMORUN,IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,
     *                IEFMODIM(2),IMODEFE,NATEFMO,IMODEFD,IMODEFER,
     *                IMODEFCT,IDIMTYP
      COMMON /FMCOM/  XX(1)
      COMMON /FRFD  / PPEFX(MXFGPT), PPEFY(MXFGPT), PPEFZ(MXFGPT)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INDDIP/ TMUX,TMUY,TMUZ,TMUXD,TMUYD,TMUZD,MINMEM
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SIMDAT/ NACC,NREJ,IGOMIN,NRPA,IBWM,NACCT,NREJT,NRPAT,
     *                NPRTGO,IDPUNC,IGOFLG
      COMMON /EWALD / IFEWLD,TNFOIL,BETA,ELCNST,EPSLN,CUTOFF,CUTLST,
     *                KMAX,NKVEC,LEVEL,EWLDPL
      COMMON /EWFLD / RCPFLD(3,MXFGPT),RCPIIFLD1(3,MXFGPT),
     *                RCPIIFLD2(3,MXFGPT), TNFLD(3),
     *                TNIIFLD1(3),TNIIFLD2(3),
     *                SELFFLD1(3,MXFGPT),SELFFLD2(3,MXFGPT),
     *                EXCLFLD(3,MXFGPT),
     *                EXCLIIFLD1(3,MXFGPT),EXCLIIFLD2(3,MXFGPT)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /EFPAR / LOCNFG,NLOW,NUP
C
      DIMENSION EFLD(3,NPTTPT),EFADD(3,NPTTPT)
C
      DATA ENERGY  /8HENERGY  /,GRADIENT/8HGRADIENT/
C
C     BE VERY CAREFUL ABOUT THE DATA UNDER COMMON FRFD, INDDIP,
C     AND EFPPAR (DIND AND DINDD), SINCE THEY ARE WRITTEN WHEN EPOL
C     IS CALCULATED!!!
C
      CALL FRGFLD
      IF (IFEWLD .AND. EWLDPL) THEN
C   ----  DEBUG: CALCULATES STATIC FIELD EXPLICITELY
         DEBUGOPT=.FALSE.
         IF (DEBUGOPT) CALL DIRECTSUM_POL
C   ---- TINFOIL CONTRIBUTION TO THE FIELD IS CALCULATED IN TNFOIL,
C   ---- TOGETHER WITH ELECTROSTATIC TINFOIL ENERGIES
C   ---- EXCLUSION CONTRIBUTION IS CALCULATED IN EXCL_FIELD AND CALLED
C   ---- ONCE IN EWALDX
C   ---- SELF CONTRIBUTION TO THE FIELD IS 0
C   ---- DIRECT CONTRIBUTION WAS CALCULATED IN FRGFLD
C
C      WRITE(6,*)'FRGFLD1 ',PPEFX(1),PPEFY(1),PPEFZ(1)
C      WRITE(6,*)'FRGFLD2 ',PPEFX(2),PPEFY(2),PPEFZ(2)
C      WRITE(6,*)'FRGFLD3 ',PPEFX(3),PPEFY(3),PPEFZ(3)
C
         CALL RECIPR_FIELD
      END IF
      DO LEFP = 1, NPTTPT
         EFLD(1,LEFP) = PPEFX(LEFP)
         EFLD(2,LEFP) = PPEFY(LEFP)
         EFLD(3,LEFP) = PPEFZ(LEFP)
         IF (IFEWLD .AND. EWLDPL) THEN
            DO I=1,3
               EFLD(I,LEFP) = EFLD(I,LEFP)+RCPFLD(I,LEFP)
     *                      +TNFLD(I)
     *                      +EXCLFLD(I,LEFP)
            END DO
C
C   ---- DIRTY THINGS
            PPEFX(LEFP) = EFLD(1,LEFP)
            PPEFY(LEFP) = EFLD(2,LEFP)
            PPEFZ(LEFP) = EFLD(3,LEFP)
         END IF
      ENDDO
C
C      WRITE(6,*)'TOTAL STATIC FIELD ',(EFLD(I,1),I=1,3),
C     *           (EFLD(I,2),I=1,3),(EFLD(I,3),I=1,3)
C
      CALL VALFM(LOADFM)
      LDIPNEW  = LOADFM   + 1
      LDIPNWD  = LDIPNEW  + NFRG
      LDINDC   = LDIPNWD  + NFRG
      LDINDDC  = LDINDC   + 3*NPTTPT
      LDIND_W  = LDINDDC  + 3*NPTTPT
      LDIND_C  = LDIND_W  + 6*NPTTPT
      LEWLD1   = LDIND_C  + 6*NPTTPT
      LEWLD2   = LEWLD1   + 3*NPTTPT
      LAST     = LEWLD2   + 3*NPTTPT
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
      CALL DIPIT(EFLD,EFADD,XX(LDINDC),XX(LDINDDC),
     *           XX(LDIND_W),XX(LDIND_C),
     *           NPTTPT,XX(LDIPNEW),XX(LDIPNWD),
     *           XX(LEWLD1),XX(LEWLD2),NFRG)
      CALL RETFM(NEED)
      IF(IDPUNC.EQ.1) RETURN
C
C     --- CALCULATE POLARIZATION ENERGY ---
C
      IUP=0
      DO I=1,NUP
         IUP = IUP + NPPTS(I)
      ENDDO
      ILOW=1
      DO I=1,NLOW-1
         ILOW = ILOW + NPPTS(I)
      ENDDO
      POLNRG = ZERO
      DO II=ILOW,IUP
         POLNRG = POLNRG + DIND(1,II)*PPEFX(II)
     *                   + DIND(2,II)*PPEFY(II)
     *                   + DIND(3,II)*PPEFZ(II)
      ENDDO
      POLNRG = -0.5D+00*POLNRG
      IF(GOPARR) CALL DDI_GSUMF(677,POLNRG,1)
C
C     --- GRAND INDUCED DIPOLE ---
C
      IF( IEFMORUN.GT.0 .AND. IEFMORT.NE.4 ) GOTO 800
      IF (RUNTYP.EQ.ENERGY .OR. RUNTYP.EQ.GRADIENT) THEN
         TMUX = ZERO
         TMUY = ZERO
         TMUZ = ZERO
         DO LEFP=1, NPTTPT
           TMUX = TMUX + DIND(1,LEFP)
           TMUY = TMUY + DIND(2,LEFP)
           TMUZ = TMUZ + DIND(3,LEFP)
         ENDDO
         TMUXD = TMUX*DEBYE
         TMUYD = TMUY*DEBYE
         TMUZD = TMUZ*DEBYE
         IF(MASWRK)
     *   WRITE(IW,9000) TMUX, TMUXD, TMUY, TMUYD, TMUZ, TMUZD
      ENDIF
C
  800 CONTINUE
C
      RETURN
C
 9000 FORMAT(/,17X,'INDUCED DIPOLE',4X,'ATOMIC UNITS',3X,'DEBYE'/
     *       17X,14('-'),4X,12('-'),3X,5('-')/
     *       21X,'X(IND)',9X,F8.5,3X,F8.5/
     *       21X,'Y(IND)',9X,F8.5,3X,F8.5/
     *       21X,'Z(IND)',9X,F8.5,3X,F8.5)
C
      END
C
C*MODULE EFDRVR  *DECK EFGRAD
C>
C> @brief   compute gradient for EFP-only runs
C>
C> @details compute gradient when only EFP particles are present,
C>          possibly enclosed in a PCM layer.
C>
C> @author  perhaps Paul Day
C>
C
      SUBROUTINE EFGRAD
C
C ---------------------------------------------------------------
C --- THIS ROUTINE CALCULATES THE GRADIENT ASSOCIATED WITH    ---
C --- A FRAGMENT ONLY RUN, I.E., FRAGMENTS IN THE ABSENCE OF  ---
C ---                  AN AB INITIO MOLECULE                  ---
C ---------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (ONE=1.0D+00)
      PARAMETER (MXATM=2000, MXSHEF=1000, MXGEFP=4000,
     *           MXPT=2000, MXFRG=1050, MXFGPT=12000,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      LOGICAL PROJGRAD,PBC
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION MD
C
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,
     *                EFMOREPNRG,EFMOCHTNRG,EFMOEPEN,EFMOPCMG,
     *                IEFMORUN,IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,
     *                IEFMODIM(2),IMODEFE,NATEFMO,IMODEFD,IMODEFER,
     *                IMODEFCT,IDIMTYP
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NATEF(MXDFG),NUMEF(MXDFG),NTPATM
      COMMON /EFPPBC/ XBOX,YBOX,ZBOX,XCUT,YCUT,ZCUT,RCUT,
     *                SWR1,SWR2,ISWF
      COMMON /FMCOM / X(1)
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IKREP,IEF,IP_F,NFMOPCM
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /EFPMP2/ MP2TYP
C
      DATA MD/8HMD      /
C
      IF( IEFMORUN.GT.0 ) RETURN
C
C          NUMERICAL GRADIENT IS DONE ELSEWHERE...
C
      IF(NGLEVL.NE.0) THEN
         CALL NUMGRDX
         RETURN
      END IF
C
C          THE REST OF THIS ROUTINE DRIVES ANALYTICAL GRADIENTS.
C
      IF(MP2TYP.EQ.1) THEN
        NFRPTS=NMTTPT+NPTTPT+NRTTPT+NTPATM+NTMO+NDTTPT
      ELSE
        NFRPTS=NMTTPT+NPTTPT+NRTTPT+NTPATM+NTMO
      END IF
C
      CALL VALFM(LOADFM)
      LEF3    = LOADFM  + 1
      LWORK   = LEF3    + MAX(1,3*NFRPTS)
      LATORQN = LWORK   + MAX(1,10*NMTTPT)
      LAST    = LATORQN + MAX(1,3*NFRG)
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      CALL VCLR(DEF,1,3*MXFGPT)
      CALL VCLR(ATORQ,1,3*NFRG)
      CALL EFPDERCOM(DEF,X(LEF3),NFRPTS,X(LWORK),X(LATORQN))
C     (NEXT CALL WAS PULLED OUT OF OLD COLLECTIVE VNNDER+EFP ROUTINE)
      IF(GOPARR) CALL DSCAL(3*NAT,ONE/NPROC,DEF,1)
      CALL EFFT
C
C       AS A BAND-AID, PROJECT RESIDUAL TORQUE/DRIFT FROM THE GRADIENT.
C       THIS EXISTS WHEN USING A FINITE PCM GRID FOR EFP+PCM,
C       AND SEEMINGLY WHEN PERIODIC BOUNDARY CONDITIONS EXIST.
C       THE THINKING IS THAT MD RUNS ARE SUPPOSED TO CONSERVE ENERGY,
C       SO THEY SHOULD AVOID ANY MANIPULATION OF THE GRADIENT HERE.
C
C       NOTE THAT NAT=0, SO THERE IS A DUMMY QM GRADIENT VECTOR,
C       WITH NO QM COORDINATES OR QM NUCLEAR MASSES.
C
      PBC = (XBOX+YBOX+ZBOX) .GT. 0.0D+00
      PROJGRAD = (IPCM.EQ.1 .OR.  PBC)  .AND. RUNTYP.NE.MD
      IF(PROJGRAD) THEN
         NCCF = 3*NAT + 6*NFRG
         CALL VALFM(LOADFM)
         LGTOT  = LOADFM + 1
         LRM    = LGTOT  + 3*NAT +  6*NFRG
         LX     = LRM    + 3*NAT + 21*NFRG
         LP     = LX     + 3*NAT +  6*NFRG
         LAST   = LP     + 3*NAT +  6*NFRG
         NEEDP  = LAST-LOADFM-1
         CALL GETFM(NEEDP)
         DUMMY =0.0D+00
         DUMMYC=0.0D+00
         DUMMYZ=0.0D+00
C---     CALL RAMS(X(LRM),1)
         CALL PRJGRD(DUMMY,DUMMYC,X(LX),X(LGTOT),X(LRM),X(LP),DUMMYZ,
     *               NAT,NAT*3,NCCF,.FALSE.)
         CALL RETFM(NEEDP)
      END IF
C
      CALL RETFM(NEED)
      RETURN
      END
C
C*MODULE EFDRVR  *DECK EFPDYN
      SUBROUTINE EFPDYN(EDISC8,EDISC80,DYNTR,SABSAVE,SABGRAD,MXPPTS)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXFRG=1050, MXIFRQ=12, MXFGPT=12000,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      PARAMETER (ZERO=0.0D+00)
      PARAMETER (THREE=3.0D+00, FOUR=4.0D+00, ONE=1.0D+00, TWO=2.0D+00)
      PARAMETER (SIX=6.0D+00)
C      PARAMETER (B=1.5D+00)
      PARAMETER (FACT1= 0.72086099022968040154D-02)
      PARAMETER (FACT2= 0.17697067815034886394D-01)
      PARAMETER (FACT3= 0.30660908596251749739D-01)
      PARAMETER (FACT4= 0.48381293256249884995D-01)
      PARAMETER (FACT5= 0.74878830420650517080D-01)
      PARAMETER (FACT6= 0.11806515901361630228D+00)
      PARAMETER (FACT7= 0.19535413832209084204D+00)
      PARAMETER (FACT8= 0.35055692324483221824D+00)
      PARAMETER (FACT9= 0.71577113554429568336D+00)
      PARAMETER (FACT10=1.81409759976323969729D+00)
      PARAMETER (FACT11=6.97923445114870823247D+00)
      PARAMETER (FACT12=83.2480938829658453917D+00)
C
      CHARACTER*8 POLNAM,DPOLNAM,FRCNME
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL IFRCPNT
C
      COMMON /EFPAR / LOCNFG,NLOW,NUP
      COMMON /EFPFRC/ IFRCPNT,NTFRCPN,NFRCPNT(MXFRG),LSTFPTS(MXFRG),
     *                FRCCRD(3,MXFGPT),FRCNME(MXFGPT),FRCTRQ(6,MXFGPT)
     *                ,FRCTRQX(6,MXFGPT)
      COMMON /EFPPBC/ XBOX,YBOX,ZBOX,XCUT,YCUT,ZCUT,RCUT,
     *                SWR1,SWR2,ISWF
      COMMON /EFPGES/ DESFRG(6,MXFRG)
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ*MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /EFPSCR/ POLAB(MXFRG),B,SCROFF,IELECS,IDISPS,NEW_POL
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DIMENSION  DYNTR(MXIFRQ*MXPPTS,NFRG),
     *           SABSAVE(NFRG,NFRG,MXPPTS,MXPPTS),
     *           SABGRAD(NFRG,NFRG,MXPPTS,MXPPTS,6),DSAB(6),
     *           IFP1(10),IFP2(10)
C
C
C     ------------------------------------------------------------------
C        THIS ROUTINE CALCULATES FRAGMENT-FRAGMENT DISPERSION (EFP2)
C        ENERGY AND GRADIENTS IN THE ABSENCE OF AN AB INITO MOLECULE
C     ------------------------------------------------------------------
C
      EDISC8 = ZERO
      EDISD  = ZERO
      EDISC80  = ZERO
      EDISD0  = ZERO
      CALL VCLR(DSAB,1,6)
C
C     -- TRACE OF DYNAMIC ALPHA IN THE FORM ALPHA(NDPPTS,NFRG) ---
C
      ID=0
      DO I=1,NFRG
        DO J=1,NDPPTS(I)
           ID=ID+1
           DYNTR(J,I) = (ONE/THREE)*(EFDPOL(1,ID) + EFDPOL(2,ID) +
     *                   EFDPOL(3,ID))
        ENDDO
      ENDDO
C
      ID1=0
      IF (GOPARR) THEN
         DO I=1,NLOW-1
            ID1 = ID1 + NPPTS(I)
         ENDDO
      ENDIF
C
      DO 280 IM = NLOW,NUP
         INPPTS=NPPTS(IM)
         COMX1 = EFCENT(1,IM)
         COMY1 = EFCENT(2,IM)
         COMZ1 = EFCENT(3,IM)
         DO 270 IN=1,NPPTS(IM)
            ID1=ID1+1
            ALP1=DYNTR(IN,IM)
            ALP2=DYNTR(IN+INPPTS,IM)
            ALP3=DYNTR(IN+2*INPPTS,IM)
            ALP4=DYNTR(IN+3*INPPTS,IM)
            ALP5=DYNTR(IN+4*INPPTS,IM)
            ALP6=DYNTR(IN+5*INPPTS,IM)
            ALP7=DYNTR(IN+6*INPPTS,IM)
            ALP8=DYNTR(IN+7*INPPTS,IM)
            ALP9=DYNTR(IN+8*INPPTS,IM)
            ALP10=DYNTR(IN+9*INPPTS,IM)
            ALP11=DYNTR(IN+10*INPPTS,IM)
            ALP12=DYNTR(IN+11*INPPTS,IM)
            X1 = EFP(1,ID1)
            Y1 = EFP(2,ID1)
            Z1 = EFP(3,ID1)
C                IF FORCE POINTS ARE ACTIVE
            IF(IFRCPNT) THEN
               CALL NEARFP(IM,X1,Y1,Z1,IFP1,IFP1_COM,NEQUAL1)
            ENDIF
C
            ID2=0
            DO 260 JM = 1,NFRG
               IF (IM.GE.JM)THEN
                 ID2=ID2+NPPTS(JM)
                 GO TO 260
               END IF
C
               COMX2 = EFCENT(1,JM)
               COMY2 = EFCENT(2,JM)
               COMZ2 = EFCENT(3,JM)
               COMX = COMX1 - COMX2
               COMY = COMY1 - COMY2
               COMZ = COMZ1 - COMZ2
               PBCX = ZERO
               PBCY = ZERO
               PBCZ = ZERO
               IF (XBOX .NE. ZERO) PBCX = XBOX * ANINT(COMX/XBOX)
               IF (YBOX .NE. ZERO) PBCY = YBOX * ANINT(COMY/YBOX)
               IF (ZBOX .NE. ZERO) PBCZ = ZBOX * ANINT(COMZ/ZBOX)
C
C   ----  DISTANCE BETWEEN FRAGMENTS
               X12  = ABS(COMX - PBCX)
               Y12  = ABS(COMY - PBCY)
               Z12  = ABS(COMZ - PBCZ)
               R12  = X12*X12+Y12*Y12+Z12*Z12
C
               SWF   = 1.0D+00
               SWFDX = 0.0D+00
               SWFDY = 0.0D+00
               SWFDZ = 0.0D+00
C
               IF(X12.GT.XCUT.OR.Y12.GT.YCUT.OR.Z12.GT.ZCUT)THEN
                 ID2=ID2+NPPTS(JM)
                 GOTO 260
               END IF
               R12  = X12*X12+Y12*Y12+Z12*Z12
               IF(R12.GT.RCUT)THEN
                 ID2=ID2+NPPTS(JM)
                 GOTO 260
               END IF
C
               IF(R12.GT.SWR2*SWR2) THEN
                 ID2=ID2+NPPTS(JM)
                 GOTO 260
               ELSE IF(R12.GT.SWR1*SWR1) THEN
                 IF(ISWF.EQ.1) THEN
                    DUMY1 = 1.0D+00/(SWR2*SWR2 - SWR1*SWR1)
                    DUMY2 = DUMY1*DUMY1
                    DUMY3 = DUMY2*DUMY1
                    DUMY4 = DUMY2*DUMY2
                    DUMY5 = DUMY2*DUMY3
                    VUMY1 = R12 - SWR1*SWR1
                    VUMY2 = VUMY1*VUMY1
                    VUMY3 = VUMY2*VUMY1
                    VUMY4 = VUMY2*VUMY2
                    VUMY5 = VUMY2*VUMY3
                    DSWF  = -30.0D+00*DUMY3*VUMY2
     *                      +60.0D+00*DUMY4*VUMY3
     *                      -30.0D+00*DUMY5*VUMY4
                    DSWF  = 2.0D+00*DSWF
                    SWF   = 1.0D+00 - 10.0D+00*DUMY3*VUMY3
     *                              + 15.0D+00*DUMY4*VUMY4
     *                              -  6.0D+00*DUMY5*VUMY5
                    SWFDX = DSWF*(EFCENT(1,IM)-EFCENT(1,JM)-PBCX)
                    SWFDY = DSWF*(EFCENT(2,IM)-EFCENT(2,JM)-PBCY)
                    SWFDZ = DSWF*(EFCENT(3,IM)-EFCENT(3,JM)-PBCZ)
                 ELSE IF(ISWF.EQ.2) THEN
                    R12   = SQRT(R12)
                    PIL   = 3.1415926535897932D+00/(SWR2-SWR1)
                    DUMY  = (R12 - SWR1) * PIL
                    SWF   = 0.50D+00 * (COS(DUMY) + 1.0D+00)
                    DUMY2 =-0.50D+00 * SIN(DUMY) * PIL / R12
                    SWFDX = DUMY2*(EFCENT(1,IM)-EFCENT(1,JM)-PBCX)
                    SWFDY = DUMY2*(EFCENT(2,IM)-EFCENT(2,JM)-PBCY)
                    SWFDZ = DUMY2*(EFCENT(3,IM)-EFCENT(3,JM)-PBCZ)
                 END IF
               END IF
C
               JNPPTS=NPPTS(JM)
               DO 250 JP = 1,NPPTS(JM)
                  ID2=ID2+1
                  ALPN1=DYNTR(JP,JM)
                  ALPN2=DYNTR(JP+JNPPTS,JM)
                  ALPN3=DYNTR(JP+2*JNPPTS,JM)
                  ALPN4=DYNTR(JP+3*JNPPTS,JM)
                  ALPN5=DYNTR(JP+4*JNPPTS,JM)
                  ALPN6=DYNTR(JP+5*JNPPTS,JM)
                  ALPN7=DYNTR(JP+6*JNPPTS,JM)
                  ALPN8=DYNTR(JP+7*JNPPTS,JM)
                  ALPN9=DYNTR(JP+8*JNPPTS,JM)
                  ALPN10=DYNTR(JP+9*JNPPTS,JM)
                  ALPN11=DYNTR(JP+10*JNPPTS,JM)
                  ALPN12=DYNTR(JP+11*JNPPTS,JM)
C
                  X2 = EFP(1,ID2)
                  Y2 = EFP(2,ID2)
                  Z2 = EFP(3,ID2)
C                   IF FORCE POINTS ARE ACTIVE
                  IF(IFRCPNT) THEN
                    CALL NEARFP(JM,X2,Y2,Z2,IFP2,IFP2_COM,NEQUAL2)
                  ENDIF
C
                  X = X1 - X2
                  Y = Y1 - Y2
                  Z = Z1 - Z2
                  X = X - PBCX
                  Y = Y - PBCY
                  Z = Z - PBCZ
C
                  R2 = X*X + Y*Y + Z*Z
                  R = SQRT(R2)
                  R4 = R2*R2
                  R6 = R4*R2
C
                  F6 = ONE
                  IF (IDISPS .EQ. 1) THEN
C                    THE OVERLAP BASED DAMPING FOR DISPERSION
                     SAB = SABSAVE(IM,JM,IN,JP)
                     IF (ABS(SAB) .GT. 1.0D-05) THEN
                        DO ICRD = 1,6
                            DSAB(ICRD) = SABGRAD(IM,JM,IN,JP,ICRD)
                        END DO
                        RB = -2.0D+00*LOG(ABS(SAB))
                        EX1 = SAB*SAB
                        RB2 = RB*RB
                        F6 = ONE-(EX1*(ONE + RB + RB2/TWO ))
                     ELSE
                        F6 = ONE
                        RB = ZERO
                        SAB = ZERO
                        DO ICRD = 1,6
                            DSAB(ICRD) = ZERO
                        END DO
                     END IF
                  ELSE
C                 - F6 IS DAMPING FUNCTION FOR DISPERSION BASED ON
C                   TANG AND TOENNIES FORMULA
                     RB =  B*R
                     EX1 = EXP(-RB)
                     RB2 = RB*RB
                     RB3 = RB*RB2
                     RB4 = RB2*RB2
                     RB5 = RB*RB4
                     RB6 = RB*RB5
C
                     F6 = ONE-(EX1*(ONE + RB + RB2/TWO +
     *                           RB3/SIX + RB4/24.0D+00 +
     *                           RB5/120.0D+00 +RB6/720.0D+00))
                  END IF
C
                  C6=
     *             + FACT1*ALP1*ALPN1
     *             + FACT2*ALP2*ALPN2
     *             + FACT3*ALP3*ALPN3
     *             + FACT4*ALP4*ALPN4
     *             + FACT5*ALP5*ALPN5
     *             + FACT6*ALP6*ALPN6
     *             + FACT7*ALP7*ALPN7
     *             + FACT8*ALP8*ALPN8
     *             + FACT9*ALP9*ALPN9
     *             + FACT10*ALP10*ALPN10
     *             + FACT11*ALP11*ALPN11
     *             + FACT12*ALP12*ALPN12
C
C                 - EDISD IS DAMPED DISPERSION ENERGY
C
                  EPAIR = - F6*C6/R6
                  EPAIR0 = - C6/R6
                  EDISD = EDISD + SWF*EPAIR
                  EDISD0 = EDISD0 + SWF*EPAIR0
                  EPAIR=EPAIR*FOUR/THREE
                  EPAIR0=EPAIR0*FOUR/THREE
C
C                 - GRADIENT OF THE DISPERSION ENERGY
C                 DE/DR=FOUR/THREE*(-6*C6*F6/R**7 + DF6/DR * C6/R**6)
C
                  IF (IDISPS .EQ. 1) THEN
                     CON1=-(FOUR/THREE)*(C6/R6)*(SIX*F6/R2)
                     CON2=-(FOUR/THREE)*(C6/R6)*(RB2*SAB)
                  ELSE
                     CON1=-(FOUR/THREE)*(C6/R6)*
     *                     ((SIX*F6/R2)-(B*RB6*EX1)/(R*720.0D+00))
                     CON2 = ZERO
                  END IF
C
                  CONX=CON1*X
                  CONY=CON1*Y
                  CONZ=CON1*Z
C
C
                  DESFRG(1,JM) = DESFRG(1,JM) - EPAIR*SWFDX
                  DESFRG(2,JM) = DESFRG(2,JM) - EPAIR*SWFDY
                  DESFRG(3,JM) = DESFRG(3,JM) - EPAIR*SWFDZ
                  DESFRG(1,IM) = DESFRG(1,IM) + EPAIR*SWFDX
                  DESFRG(2,IM) = DESFRG(2,IM) + EPAIR*SWFDY
                  DESFRG(3,IM) = DESFRG(3,IM) + EPAIR*SWFDZ
C
                  DESFRG(1,JM) = DESFRG(1,JM) + SWF*(CONX+CON2*DSAB(1))
                  DESFRG(2,JM) = DESFRG(2,JM) + SWF*(CONY+CON2*DSAB(2))
                  DESFRG(3,JM) = DESFRG(3,JM) + SWF*(CONZ+CON2*DSAB(3))
                  DESFRG(4,JM) = DESFRG(4,JM) + SWF*
     *                      (CONZ*(EFP(2,ID2)-EFCENT(2,JM))
     *                      -CONY*(EFP(3,ID2)-EFCENT(3,JM))
     *                      -CON2*DSAB(4)
     *                      +CON2*DSAB(3)*(COMY - PBCY)
     *                      -CON2*DSAB(2)*(COMZ - PBCZ))
                  DESFRG(5,JM) = DESFRG(5,JM) + SWF*
     *                      (CONX*(EFP(3,ID2)-EFCENT(3,JM))
     *                      -CONZ*(EFP(1,ID2)-EFCENT(1,JM))
     *                      -CON2*DSAB(5)
     *                      +CON2*DSAB(1)*(COMZ - PBCZ)
     *                      -CON2*DSAB(3)*(COMX - PBCX))
                  DESFRG(6,JM) = DESFRG(6,JM) + SWF*
     *                      (CONY*(EFP(1,ID2)-EFCENT(1,JM))
     *                      -CONX*(EFP(2,ID2)-EFCENT(2,JM))
     *                      -CON2*DSAB(6)
     *                      +CON2*DSAB(2)*(COMX - PBCX)
     *                      -CON2*DSAB(1)*(COMY - PBCY))
                  DESFRG(1,IM) = DESFRG(1,IM) - SWF*(CONX+CON2*DSAB(1))
                  DESFRG(2,IM) = DESFRG(2,IM) - SWF*(CONY+CON2*DSAB(2))
                  DESFRG(3,IM) = DESFRG(3,IM) - SWF*(CONZ+CON2*DSAB(3))
                  DESFRG(4,IM) = DESFRG(4,IM) - SWF*
     *                      (CONZ*(EFP(2,ID1)-EFCENT(2,IM))
     *                      -CONY*(EFP(3,ID1)-EFCENT(3,IM))
     *                      -CON2*DSAB(4))
                  DESFRG(5,IM) = DESFRG(5,IM) - SWF*
     *                      (CONX*(EFP(3,ID1)-EFCENT(3,IM))
     *                      -CONZ*(EFP(1,ID1)-EFCENT(1,IM))
     *                      -CON2*DSAB(5))
                  DESFRG(6,IM) = DESFRG(6,IM) - SWF*
     *                      (CONY*(EFP(1,ID1)-EFCENT(1,IM))
     *                      -CONX*(EFP(2,ID1)-EFCENT(2,IM))
     *                      -CON2*DSAB(6))
C
C  ---- GATHER GRADS AND TORQUES IN FORCE POINTS
             IF(IFRCPNT) THEN
                  FRCTRQ(1,IFP2_COM) = FRCTRQ(1,IFP2_COM)-EPAIR*SWFDX
                  FRCTRQ(2,IFP2_COM) = FRCTRQ(2,IFP2_COM)-EPAIR*SWFDY
                  FRCTRQ(3,IFP2_COM) = FRCTRQ(3,IFP2_COM)-EPAIR*SWFDZ
                  FRCTRQ(1,IFP1_COM) = FRCTRQ(1,IFP1_COM)+EPAIR*SWFDX
                  FRCTRQ(2,IFP1_COM) = FRCTRQ(2,IFP1_COM)+EPAIR*SWFDY
                  FRCTRQ(3,IFP1_COM) = FRCTRQ(3,IFP1_COM)+EPAIR*SWFDZ
C
                  DO I=1,NEQUAL2
                  IFP = IFP2(I)
                  COEF=ONE/NEQUAL2
                  FRCTRQ(1,IFP) = FRCTRQ(1,IFP)+
     *                            SWF*(CONX+CON2*DSAB(1))*COEF
                  FRCTRQ(2,IFP) = FRCTRQ(2,IFP)+
     *                            SWF*(CONY+CON2*DSAB(2))*COEF
                  FRCTRQ(3,IFP) = FRCTRQ(3,IFP)+
     *                            SWF*(CONZ+CON2*DSAB(3))*COEF
                  FRCTRQ(4,IFP) = FRCTRQ(4,IFP)+SWF*COEF*
     *                      (CONZ*(EFP(2,ID2)-FRCCRD(2,IFP))
     *                      -CONY*(EFP(3,ID2)-FRCCRD(3,IFP))
     *                      -CON2*DSAB(4)
     *                      +CON2*DSAB(3)*(COMY - PBCY)
     *                      -CON2*DSAB(2)*(COMZ - PBCZ))
                  FRCTRQ(5,IFP) = FRCTRQ(5,IFP)+SWF*COEF*
     *                      (CONX*(EFP(3,ID2)-FRCCRD(3,IFP))-
     *                       CONZ*(EFP(1,ID2)-FRCCRD(1,IFP))
     *                      -CON2*DSAB(5)
     *                      +CON2*DSAB(1)*(COMZ - PBCZ)
     *                      -CON2*DSAB(3)*(COMX - PBCX))
                  FRCTRQ(6,IFP) = FRCTRQ(6,IFP)+SWF*COEF*
     *                      (CONY*(EFP(1,ID2)-FRCCRD(1,IFP))
     *                      -CONX*(EFP(2,ID2)-FRCCRD(2,IFP))
     *                      -CON2*DSAB(6)
     *                      +CON2*DSAB(2)*(COMX - PBCX)
     *                      -CON2*DSAB(1)*(COMY - PBCY))
                END DO
                  DO I=1,NEQUAL1
                  IFP = IFP1(I)
                  COEF=ONE/NEQUAL1
                  FRCTRQ(1,IFP) = FRCTRQ(1,IFP)-
     *                            SWF*(CONX+CON2*DSAB(1))*COEF
                  FRCTRQ(2,IFP) = FRCTRQ(2,IFP)-
     *                            SWF*(CONY+CON2*DSAB(2))*COEF
                  FRCTRQ(3,IFP) = FRCTRQ(3,IFP)-
     *                            SWF*(CONZ+CON2*DSAB(3))*COEF
                  FRCTRQ(4,IFP) = FRCTRQ(4,IFP) - SWF*COEF*
     *                      (CONZ*(EFP(2,ID1)-FRCCRD(2,IFP))
     *                      -CONY*(EFP(3,ID1)-FRCCRD(3,IFP))
     *                      -CON2*DSAB(4))
                  FRCTRQ(5,IFP) = FRCTRQ(5,IFP) - SWF*COEF*
     *                      (CONX*(EFP(3,ID1)-FRCCRD(3,IFP))-
     *                       CONZ*(EFP(1,ID1)-FRCCRD(1,IFP))
     *                      -CON2*DSAB(5))
                  FRCTRQ(6,IFP) = FRCTRQ(6,IFP) - SWF*COEF*
     *                      (CONY*(EFP(1,ID1)-FRCCRD(1,IFP))
     *                      -CONX*(EFP(2,ID1)-FRCCRD(2,IFP))
     *                      -CON2*DSAB(6))
                END DO
              END IF
C
 250           CONTINUE
 260        CONTINUE
 270     CONTINUE
 280  CONTINUE
C
      IF(GOPARR) THEN
         CALL DDI_GSUMF(677,EDISD,1)
         CALL DDI_GSUMF(677,EDISD0,1)
      END IF
      EDISC8=EDISD+EDISD/THREE
      EDISC80=EDISD0+EDISD0/THREE
C
C
      RETURN
      END
C*MODULE EFDRVR  *DECK POLPCM
      SUBROUTINE POLPCM(EFLD,EFADD,QSE,QSED,QSN,
     *                  XCTS,YCTS,ZCTS,AS,
     *                  XE,YE,ZE,RE,ISPHE,LIST,POLNRG)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      CHARACTER*8 FRGNME,POLNAM,DPOLNAM
C
      PARAMETER (MXATM=2000, MXFRG=1050, MXFGPT=12000, MXIFRQ=12,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      LOGICAL GOPARR, DSKWRK, MASWRK
C
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ*MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /FMCOM / X(1)
      COMMON /FRFD  / PPEFX(MXFGPT), PPEFY(MXFGPT), PPEFZ(MXFGPT)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCMDIM/ MXSP,MXTS,MEMPCM1,MEMPCM2,NTS
      COMMON /PCMEFP/ PB_MUL,PC_MUL,PB_POL,PC_POL,P_FF,P_NF,P_FN,P_I,
     *                P_IBIS,P_J,P_NUCC,P_NUCCBIS,ENPCM
      COMMON /PCMEPS/ EPSHET(MXATM),IHET
      COMMON /PCMITR/ RCUT(2),THRES,IPCMIT,IMUL,MXDIIS,NREG,MXITR1,
     *                MXITR2,MODPAP
      COMMON /PCMOPT/ RABI,RASC,REFPOL,THRSLS,DENSLS,WB,WA,ETA2,GD,EVAC,
     *                RHOW,PM,AREATL,AREAKP,BONDRY,OMEGA,RET,FRO,EPSINF,
     *                EPS,DR,RSOLV,VMOL,TCE,STEN,DSTEN,CMF,TABS,IDIRCT,
     *                IPCDER,IDP,ICOMP,IFIELD,ICAV,IDISP,IPRINT,IRETCAV,
     *                ICENT,IFAST,NEVAL,IEFPOL,KEEPSM,IMGABI,IMGASC,NADD
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IKREP,IEF,IP_F,NFMOPCM
      COMMON /PCMPRT/ GCAVP,GCAVS,GDISP,GREP,EHFGAS
      COMMON /SIMDAT/ NACC,NREJ,IGOMIN,NRPA,IBWM,NACCT,NREJT,NRPAT,
     *                NPRTGO,IDPUNC,IGOFLG
C
      DIMENSION  EFLD(3,NPTTPT),EFADD(3,NPTTPT),
     *           QSE(*),QSED(*),QSN(*),XCTS(*),YCTS(*),ZCTS(*),
     *           AS(*),XE(*),YE(*),
     *           ZE(*),RE(*),ISPHE(*),LIST(*)
C
      PARAMETER (ZERO = 0.00D+00, ONE = 1.00D+00,
     *           TOANGS=0.52917724924D+00, ANTOAU=1.0D+00/TOANGS)
      PARAMETER (GLIM=1.0D-03)
C
C     -------------------------------------------
C       -- EFP/PCM (NO QM ATOM) CALCULATION --
C       EFP INDUCED DIPOLE AND PCM ASC ARE
C       ITERATED TO SELF-CONSISTENCY
C       HUI LI
C       IOWA STATE UNIVERSITY
C       JULY 25TH, 2005
C     -------------------------------------------
C
      NPRTBK = NPRINT
      NPRINT = 817
      CALL MAKCVM
      CALL PEDRAM
      NPRINT = NPRTBK
C
      MXDII1 = MXDIIS + 1
C
      CALL VALFM(LOADFM)
      LQPOT1 = LOADFM + 1
      LQPOT2 = LQPOT1 + NTS
      LQ0    = LQPOT2 + NTS
      LQ1    = LQ0    + NTS
      LQ2    = LQ1    + NTS
      LQ3    = LQ2    + NTS
      LD0    = LQ3    + NTS
      LQA    = LD0    + NTS
      LDIMAT = LQA    + NTS
      LQREP  = LDIMAT + MXDII1*MXDII1
      LTMP0  = LQREP  + 2*NTS*MXDII1
      LTMP1  = LTMP0  + NTS*3
      LTMP2  = LTMP1  + MXDII1
      LIPVT  = LTMP2  + MXDII1*MXDII1
      LPOTTMP= LIPVT  + MXDII1
      LRMUL  = LPOTTMP+ NTS
      LAST   = LRMUL  + MXSP*10
      NEED   = LAST   - LOADFM -1
      CALL GETFM(NEED)
C
C
C     -- EFP STATIC MULTIPOLE POTENTIAL AT EACH TESSERA
C
      IF(IEFC+IEFD+IEFQ.GT.0) THEN
         DO ITS=1,NTS
            XI=XCTS(ITS)
            YI=YCTS(ITS)
            ZI=ZCTS(ITS)
            QADD=ZERO
            DO I=1,NMTTPT
               XX=EFQAD(1,I)
               YY=EFQAD(2,I)
               ZZ=EFQAD(3,I)
               XY=EFQAD(4,I)
               XZ=EFQAD(5,I)
               YZ=EFQAD(6,I)
               DUM=XX+YY+ZZ
               QXX=(3.0D+00*XX-DUM)/2.0D+00
               QYY=(3.0D+00*YY-DUM)/2.0D+00
               QZZ=(3.0D+00*ZZ-DUM)/2.0D+00
               QXY=1.50D+00*XY
               QXZ=1.50D+00*XZ
               QYZ=1.50D+00*YZ
               DX = XCTS(ITS)-EFC(1,I)
               DY = YCTS(ITS)-EFC(2,I)
               DZ = ZCTS(ITS)-EFC(3,I)
               R2 =  (EFC(1,I)-XI)**2
     *              +(EFC(2,I)-YI)**2
     *              +(EFC(3,I)-ZI)**2
               R  = SQRT(R2)
               QADD = QADD + EFCHG(1,I)/R + EFCHG(2,I)/R
     *                       +(EFDIP(1,I)*DX
     *                       +EFDIP(2,I)*DY
     *                       +EFDIP(3,I)*DZ)/(R*R2)
     *                      +(QXX*3.0D+00*DX*DX
     *                       +QYY*3.0D+00*DY*DY
     *                       +QZZ*3.0D+00*DZ*DZ
     *                       +QXY*6.0D+00*DX*DY
     *                       +QXZ*6.0D+00*DX*DZ
     *                       +QYZ*6.0D+00*DY*DZ)
     *                       /(3.0D+00*R2*R2*R)
            ENDDO
            X(LQPOT1+ITS-1)=-QADD
         ENDDO
      END IF
C
C
      CALL REGINI(ISPHE,LIST)
C
C
C     -- FIELD AT POLARIZABILITY POINTS DUE TO
C        MULTIPOLE POINTS IN OTHER FRAGMENTS
C        NOTE: THIS IS DONE ONCE AND REPEATEDLY
C              USED TO INDUCE EFP DIPOLES
C
      IF(IEFP.GT.0) CALL FRGFLD
C
C
C     IF THERE IS NO DIPOLE POLARIZABILITY TENSOR,
C     NO ITERATION IS NEEDED.
C
      MXCALL = 1
      IF(IEFP.GT.0) MXCALL = 40
C
      DO 600 ICALL = 1, MXCALL
C        USUALLY 10~15 ITERATIONS ARE REQUIRED.
C
C        -- 1. ADD INDUCED DIPOLE POTENTIAL TO EACH TESSERA
         DO ITS=1,NTS
            XI=XCTS(ITS)
            YI=YCTS(ITS)
            ZI=ZCTS(ITS)
            QADD=ZERO
            DO LEFP=1,NPTTPT
               XL=EFP(1,LEFP)
               YL=EFP(2,LEFP)
               ZL=EFP(3,LEFP)
               X1 = XI - XL
               Y1 = YI - YL
               Z1 = ZI - ZL
               R2=X1*X1 + Y1*Y1 + Z1*Z1
               R = SQRT(R2)
               R3 = R*R2
               QADD= QADD + (DIND(1,LEFP)*X1
     *                    +  DIND(2,LEFP)*Y1
     *                    +  DIND(3,LEFP)*Z1)/R3/2.0D+00
     *                    + (DINDD(1,LEFP)*X1
     *                    +  DINDD(2,LEFP)*Y1
     *                    +  DINDD(3,LEFP)*Z1)/R3/2.0D+00
            ENDDO
            X(LQPOT2+ITS-1)=X(LQPOT1+ITS-1)-QADD
         ENDDO
C
C        -- 2. COMPUTE PCM SURFACE CHARGE ON EACH TESSERA
C
C        ITERATIVE CYCLE (STEP 1)
         NTSPAR=(NTS-1)/NPROC+1
         CALL ASCCYC(1,ICALL,X(LQPOT2),X(LQ0),X(LQ1),X(LD0),
     *              X(LQA),X(LDIMAT),X(LQREP),X(LTMP0),X(LTMP1),
     *              X(LTMP2),X(LIPVT),X(LRMUL),
     *              MXDII1,NTSPAR,XCTS,YCTS,ZCTS,AS,
     *              XE,YE,ZE,RE,ISPHE,LIST)
C
C        C-PCM ONLY NEEDS STEP 1.
         IF(IEF.EQ.10) THEN
           DO ITS=1,NTS
              QSE(ITS)    =X(LQ1+ITS-1)
              X(LQ0+ITS-1)=X(LQ1+ITS-1)
           ENDDO
           GOTO 500
         END IF
C
C        ITERATIVE CYCLE (STEP 2)
C
C        WRITE THE INTERMEDIATE POTENTIAL, THE STEP 2 INITIAL GUESS
C        AND COPY THE INTERMEDIATE CHARGES
C
         FACIP=-1.0D+00/(EPS-1.0D+00)
         FACIG=-1.0D+00/EPS
         DO ITS=1,NTS
            X(LQ0+ITS-1)=      X(LQ2+ITS-1)
            X(LQ2+ITS-1)=FACIP*X(LQ1+ITS-1)
            X(LQ3+ITS-1)=      X(LQ1+ITS-1)
            IF(ICALL.EQ.1) X(LQ0+ITS-1)=FACIG*X(LQ1+ITS-1)
         ENDDO
C
         CALL ASCCYC(2,ICALL,X(LQ2),X(LQ0),X(LQ1),X(LD0),
     *              X(LQA),X(LDIMAT),X(LQREP),X(LTMP0),X(LTMP1),
     *              X(LTMP2),X(LIPVT),X(LRMUL),
     *              MXDII1,NTSPAR,XCTS,YCTS,ZCTS,AS,
     *              XE,YE,ZE,RE,ISPHE,LIST)
C
C        COPY THE CHARGES
C
         DO ITS=1,NTS
            QSE(ITS)=X(LQ3+ITS-1)+X(LQ1+ITS-1)
         ENDDO
C
C        USE Q1 AND Q3 FOR NEXT GUESSES
C
         DO ITS=1,NTS
            X(LQ0+ITS-1)=X(LQ3+ITS-1)
            X(LQ2+ITS-1)=X(LQ1+ITS-1)
         ENDDO
C
 500     CONTINUE
C
C        -- SCALE C-PCM CHARGE BY (EPS-1)/EPS
         IF(IEF.EQ.10) THEN
           DO ITS = 1, NTS
              QSE(ITS) = QSE(ITS)*(EPS-ONE)/EPS
           END DO
         END IF
C
C        TEST PCM ASC FOR CONVERGENCY
C        NOTE: WE USE QSN TO SAVE THE OLD QSE
C              MAKE SURE TO CLEAR QSN AFTERMATH
C
         SDEV=ZERO
         DO ITS=1,NTS
            SDEV=SDEV+(QSE(ITS)-QSN(ITS))**2
            QSN(ITS) = QSE(ITS)
         ENDDO
         SDEV=SQRT(SDEV/NTS)
C           IF(MASWRK) WRITE(IW,*) ' THRES=',THRES,
C    *      ' SDEV=', SDEV
         IF (SDEV.EQ.ZERO) THEN
C           IF(MASWRK) WRITE(IW,*)
C    *      'POLPCM CONVERGED AFTER ',ICALL,'ITERATIONS'
            GO TO 700
         END IF
C
C
C        **********************
C        UPDATE INDUCED DIPOLES
C        **********************
C
         IF(IEFP.GT.0) THEN
C
C           -- TOTAL FIELDS AT POL-TENSORS
C
            IPCOUNT = ME-1
            DO 200 LEFP = 1, NPTTPT
C              -- GO PARALLEL!
               IF(GOPARR) THEN
                  EFLD(1,LEFP) = ZERO
                  EFLD(2,LEFP) = ZERO
                  EFLD(3,LEFP) = ZERO
                  IPCOUNT = IPCOUNT + 1
                  IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 200
               END IF
C              -- SOLVENT APPARENT CHARGE FIELD AT THE POINT --
               PQ_X=ZERO
               PQ_Y=ZERO
               PQ_Z=ZERO
               IF(IEFPOL.EQ.1) THEN
                  DO 330 ITS = 1,NTS
                     RR = (EFP(1,LEFP)-XCTS(ITS))**2 +
     *                    (EFP(2,LEFP)-YCTS(ITS))**2 +
     *                    (EFP(3,LEFP)-ZCTS(ITS))**2
                     IF(RR.LT.GLIM .OR. RR.LT.(REFPOL*ANTOAU))GOTO 330
                     RR3 = RR * SQRT(RR)
                     PQ_X = PQ_X + QSE(ITS)*(EFP(1,LEFP)-XCTS(ITS))/RR3
                     PQ_Y = PQ_Y + QSE(ITS)*(EFP(2,LEFP)-YCTS(ITS))/RR3
                     PQ_Z = PQ_Z + QSE(ITS)*(EFP(3,LEFP)-ZCTS(ITS))/RR3
 330              CONTINUE
               END IF
C              -- TOTAL FIELD: EFP+PCM --
               EFLD(1,LEFP) = PQ_X+PPEFX(LEFP)
               EFLD(2,LEFP) = PQ_Y+PPEFY(LEFP)
               EFLD(3,LEFP) = PQ_Z+PPEFZ(LEFP)
 200        CONTINUE
            IF(GOPARR) THEN
               CALL DDI_GSUMF(667,EFLD, 3*NPTTPT)
            END IF
C
C           -- COMPUTE DIND/DINDD
C
            CALL VALFM(LOADFM)
            LDIPNEW  = LOADFM   + 1
            LDIPNWD  = LDIPNEW  + NFRG
            LDINDC   = LDIPNWD  + NFRG
            LDINDDC  = LDINDC   + 3*NPTTPT
            LDIND_W  = LDINDDC  + 3*NPTTPT
            LDIND_C  = LDIND_W  + 6*NPTTPT
            LEWLD1   = LDIND_C  + 6*NPTTPT
            LEWLD2   = LEWLD1   + 3*NPTTPT
            LAST     = LEWLD2   + 3*NPTTPT
            NEEED    = LAST - LOADFM - 1
            CALL GETFM(NEEED)
            CALL DIPIT(EFLD,EFADD,X(LDINDC),X(LDINDDC),
     *                 X(LDIND_W),X(LDIND_C),
     *                 NPTTPT,X(LDIPNEW),X(LDIPNWD),
     *                 X(LEWLD1),X(LEWLD2),NFRG)
            CALL RETFM(NEEED)
            IF(IDPUNC.EQ.1) RETURN
         END IF
C
 600  CONTINUE
 700  CONTINUE
      CALL VCLR(QSN,1,NTS)
C
C
C     -- COMPUTE PCM INTERACTION
C
      ENPCM  = ZERO
      QET    = ZERO
      DO ITS = 1,NTS
         QET    = QET+QSE(ITS)
         ENPCM  = ENPCM - X(LQPOT1+ITS-1) * QSE(ITS)
      ENDDO
C
C     -- COMPUTE EFP POLARIZATION ENERGY
C
      POLNRG = ZERO
      DO II=1,NPTTPT
         POLNRG = POLNRG - DIND(1,II)*PPEFX(II)
     *                   - DIND(2,II)*PPEFY(II)
     *                   - DIND(3,II)*PPEFZ(II)
     *                   - DINDD(1,II)*PPEFX(II)
     *                   - DINDD(2,II)*PPEFY(II)
     *                   - DINDD(3,II)*PPEFZ(II)
      END DO
      POLNRG = POLNRG/4.0D+00
C
C     SOLVATION OUTPUT FOR PCM MODEL
C
      IF(MASWRK) THEN
        WRITE(IW,*) ' '
        WRITE(IW,*) ' NTS    =', NTS
        WRITE(IW,'(A10,F18.10)') 'PCM ASC=',QET
        WRITE(IW,'(A10,F18.10)') 'GELEC  =',ENPCM/2.0D+00
        IF(ICAV.EQ.1)
     *  WRITE(IW,'(A10,F18.10)') 'GCAVP  =',GCAVP/627.509541D+00
        IF(IDISP.EQ.1)THEN
        WRITE(IW,'(A10,F18.10)') 'GDISP  =',GDISP/627.509541D+00
        WRITE(IW,'(A10,F18.10)') 'GREP   =', GREP/627.509541D+00
        END IF
      END IF
C
C     - QSED IS REQUIRED EVERYWHERE EVEN IF IHET=0 -
C     - QSED = QSE WHEN IHET=0
      IF(IHET.EQ.0) CALL DCOPY(NTS,QSE,1,QSED,1)
      IF(IHET.NE.0) THEN
         IF(MASWRK) WRITE(IW,*)
     *         ' ONLY HOMOGENEOUS PCM CAN BE USED FOR EFP-PCM'
         CALL ABRT
      END IF
C
      CALL RETFM(NEED)
      RETURN
      END
C
C
C*MODULE EFDRVR  *DECK PREFP
      SUBROUTINE PREFP(LU)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXFRG=1050, MXFGPT=12000,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      CHARACTER*6 FRGNAM
      CHARACTER*8 PTNAM
C
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
C
C   ---- LVS 2007: ROUTINE FOR PRINTING IN MD AND MC
C
      DO 30 I=1,NFRG
       IF (MASWRK) THEN
          WRITE(LU,35) I, FRGNAM(I)
          WRITE(LU,34) EFCENT(1,I),EFCENT(2,I),EFCENT(3,I)
          WRITE(LU,33) DEFT(1,I),DEFT(2,I),DEFT(3,I)
          WRITE(LU,31) TORQ(1,I),TORQ(2,I),TORQ(3,I)
          WRITE(LU,36)
       END IF
 30   CONTINUE
C
 35   FORMAT('FRAGMENT #',I6,'  ',A6)
 31   FORMAT('      TORQ',3F16.10)
 33   FORMAT('     FORCE',3F16.10)
 34   FORMAT('    EFCENT',3F16.10)
 36   FORMAT('    ')
C
      RETURN
      END
C
C*MODULE EFDRVR  *DECK EFPPARL
      SUBROUTINE EFPPARL
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXFRG=1050, MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (MXCPUEFP=1024)
C
      COMMON /EFPAR / LOCNFG,NLOW,NUP
      COMMON /EFPAR2/ NFRGAL(MXCPUEFP),NLOWAL(MXCPUEFP),NUPAL(MXCPUEFP),
     *                NPPTAL(MXCPUEFP)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      INTEGER DDI_NP,DDI_ME,FLO,CEIL,DIFF
C
C     PARTITION EFP'S OVER PROCESSORS
C
C     THIS SETS UP THE PARAMETERS FOR EFP PARALLELIZATION SCHEME.
C     WHEN ONE USES GDDI COMMUNICATER, THE PARALLELIZATION PARAMETER
C     FOR EFP MUST BE RESET, IN THE CORRECT COMMUNICATOR.
C
      IF(NFRG.GT.0) THEN
        DDI_ME = ME
        DDI_NP = NPROC
        IF (MOD(NFRG,DDI_NP) .EQ. 0) THEN
          LOCNFG = NFRG / DDI_NP
          NLOW = DDI_ME * LOCNFG + 1
        ELSE
          CEIL = NFRG/DDI_NP + 1
          FLO = NFRG/DDI_NP
          DIFF = NFRG - DDI_NP*FLO
C
          IF (DDI_ME .GT. (DDI_NP-1-DIFF)) THEN
            LOCNFG = CEIL
            NLOW = DDI_ME * LOCNFG - (DDI_NP-1-DIFF)
          ELSE
            LOCNFG = FLO
            NLOW = DDI_ME * LOCNFG + 1
          END IF
        END IF
C
        NUP =  NLOW + LOCNFG - 1
        IF(GOPARR) THEN
C    THERE IS AN UNFORTUNATE COMMON BLOCK DIMENSION USED HERE.
          IF(DDI_NP.GT.MXCPUEFP) THEN
             IF(MASWRK) WRITE(IW,*)
     *          'ERROR IN PARALLEL EFP, MXCPUEFP,NPROC=',MXCPUEFP,DDI_NP
             CALL ABRT
          END IF
          CALL VICLR(NFRGAL,1,MXCPUEFP)
          CALL VICLR(NLOWAL,1,MXCPUEFP)
          CALL VICLR( NUPAL,1,MXCPUEFP)
          NFRGAL(DDI_ME+1) = LOCNFG
          NLOWAL(DDI_ME+1) = NLOW
           NUPAL(DDI_ME+1) = NUP
          CALL DDI_GSUMI(660,NFRGAL,DDI_NP)
          CALL DDI_GSUMI(661,NLOWAL,DDI_NP)
          CALL DDI_GSUMI(662, NUPAL,DDI_NP)
        ELSE
          NFRGAL(1) = NFRG
          NLOWAL(1) = 1
           NUPAL(1) = NFRG
        END IF
      END IF
      RETURN
      END
C
      MODULE EFAIDIS
!> @brief This module contains global variables necessary for
!>         computing the EFP-ab initio dispersion energy
!>
!> @author Tony Smith
!> - Jan 10, 2013
!> @details
!>    SABEFPAI : THREE-DIMENSIONAL ARRAY OF DOUBLE PRECISION VALUES,
!>              allocated in SUBROUTINE EFPAIE in source file EFPAUL,
!>              deallocated in SUBROUTINE EFAIDISP in this module.
!>              Stores values of EFP-AI overlap integrals. Dimensions
!>              are (NFRG,NA-MMCORE,MMXMO), where NFRG = number of EFPs,
!>              NA-MMCORE = number of AI valence orbitals, MMXMO =
!>              number of dispersion points (centroids) per EFP
!>    IQMDISP : flag to turn on EFP-AI dispersion calculation
!>              POSSIBLE VALUES: 0 = off, non-zero = on.
!>              Set in SUBROUTINE EFINP in source file EFINP.
!>    IDISDMP : flag to specify type of damping function
!>              POSSIBLE VALUES: -1 = no damping, 1 = overlap-based,
!>                    all other values (usually 0) = Tang-Toennies
!>              Set in SUBROUTINE EFINP in source file EFINP.
!>    IDSGRD  : flag to skip the dispersion gradient calculation
!>              POSSIBLE VALUES: 0 = gradient off, non-zero = on.
!>              Set in SUBROUTINE EFINP in source file EFINP.
!>    MMCORE : number of core orbitals. Set in RHFCL in source
!>             file RHFUHF.
!>    DISPENRG : value of the EFP-AI dispersion energy
!>    MMXMO  :  number of dispersion points (centroids) per EFP
!>    MMXBF  :  number of basis functions
!
      DOUBLE PRECISION, ALLOCATABLE, SAVE :: SABEFPAI(:,:,:)
      INTEGER, SAVE :: IQMDISP,IDISDMP,IDSGRD,MMCORE
      DOUBLE PRECISION, SAVE :: DISPENRG,MMXMO,MMXBF
      END MODULE EFAIDIS
C
C *MODULE EFDRVR  *DECK EFAIDISP
!> @brief   Calculates EFP-ab initio (EFP-AI/EFP-QM) dispersion energy
!>          and gradients
!>
!> @author  Tony Smith
!> - Jan 10, 2013
!> @param   EORBS: Array of orbital energies
!> @details see Q. Smith et al, J. Chem. Phys. 136, 244107 (2012);
!>          http://dx.doi.org/10.1063/1.4729535
!> @note    Gradient code for overlap-based damping (IDISDMP=1) is
!>          incomplete!
!> @todo    Get derivatives of overlap integrals between EFP and AI
!>          orbitals to complete the overlap-based damping gradients
      SUBROUTINE EFAIDISP(EORBS)
      USE EFAIDIS
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      CHARACTER*8 POLNAM,DPOLNAM
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000,
     *           MXFRG=1050, MXFGPT=12000, MXIFRQ=12,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12,
     *           MXGEFP=4000, MXSHEF=1000)
      PARAMETER (NMO=500, MXAO=8192)
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ,MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /EFPSCR/ POLAB(MXFRG),B,SCROFF,IELECS,IDISPS,NEW_POL
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /EFPGES/ DESFRG(6,MXFRG)
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /MASSES/ ZMASS(MXATM)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORBFP(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /EFPBAS/ EXEF(MXGEFP,MXDFG),CSEF(MXGEFP,MXDFG),
     *                CPEF(MXGEFP,MXDFG),CDEF(MXGEFP,MXDFG),
     *                CFEF(MXGEFP,MXDFG),CGEF(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTREF(MXSHEF,MXDFG),KATMEF(MXSHEF,MXDFG),
     *                KTYPEF(MXSHEF,MXDFG),KNGEF(MXSHEF,MXDFG),
     *                KLOCEF(MXSHEF,MXDFG),KMINEF(MXSHEF,MXDFG),
     *                KMAXEF(MXSHEF,MXDFG),NSHLEF(MXDFG),NGSSEF(MXDFG),
     *                NATEF(MXDFG),NUMEF(MXDFG),NTPATM
C
      DIMENSION EORBS(NUM)
      DIMENSION WRKTR(12)
      DIMENSION DYNTR(MXDPPT,NFRG)
      DIMENSION FUM1(NA-MMCORE,NQMT-NA),FUM2(NA-MMCORE,NQMT-NA),
     *			FUM3(NA-MMCORE,NQMT-NA)
      DIMENSION SQ1(NA-MMCORE,NA-MMCORE),
     *          SQ2(NA-MMCORE,NA-MMCORE),
     *			SQ3(NA-MMCORE,NA-MMCORE),
     *          AVG(NA-MMCORE,NA-MMCORE),WORK(NA),
     *          H(NA-MMCORE,NA-MMCORE),H1(NA-MMCORE)
      DIMENSION UM1(NQMT-NA,NA-MMCORE),UM2(NQMT-NA,NA-MMCORE),
     *          UM3(NQMT-NA,NA-MMCORE)
      DIMENSION UM(NA-MMCORE,NQMT-NA,3),
     *          HF((NUM*NUM+NUM)/2),
     * 			TRAN(NA-MMCORE,NA-MMCORE),
     *          E(NUM),HFP(NUM,NUM),CXM(NUM,NUM),TM(NUM),
     *          D((NUM*NUM+NUM)/2)
      DIMENSION VEC(NUM,NA),XYZP(3),CCHG(3,NA-MMCORE),DIST(3)
      DIMENSION CEE(NAT,3),CEF(NFRG,3),ZNU(NAT),ZEF(MXATM)
      DIMENSION DEE(3),DEETORQ(6),AROT(3,NAT),
     *          ATRAN(3),ATOTAL(3,NAT),FTOTAL(3,NAT)
C
      DATA ZERO,ONE,TWO,THREE /0.0D+00,1.0D+00,2.0D+00,3.0D+00/
      DATA FOUR,SIX           /4.0D+00,6.0D+00/
C
      THIRD=ONE/THREE
      FOURTHIRD=FOUR*THIRD
      MAXDER = 0
      CALL DERCHK(MAXDER)
      IF (MAXDER.NE.1) IDSGRD = 0
      NXYZ = 3
      NORB = NQMT
      NOCC = NA
      NLOC = NA - MMCORE
      NVIR = NORB - NA
      NUM2 =(NUM*NUM+NUM)/2
      NUM3 = NUM*NUM
      DO I=1,3
         DEE(I)=ZERO
         DEETORQ(I)=ZERO
         DEETORQ(I+3)=ZERO
      ENDDO
      CALL DAREAD(IDAF,IODA,VEC,NUM*NA,71,0)
      IF(NVIR .EQ. 0) RETURN
      CALL DAREAD(IDAF,IODA,TRAN,NLOC*NLOC,73,0)
      ID = 0
      DO I=1,NFRG
        DO J=1,NDPPTS(I)
           ID=ID+1
           DYNTR(J,I) = THIRD*(EFDPOL(1,ID) + EFDPOL(2,ID) +
     *                   EFDPOL(3,ID))
        ENDDO
      ENDDO
C
C  TRANSFORM DIPOLE INTEGRALS TO MO BASIS
C
      CALL DAREAD(IDAF,IODA,CXM,NUM3,15,0)
      IF (MMCORE.GT.0) THEN
         DO I = 1,NLOC
            CALL DCOPY(NUM,VEC(1,MMCORE+I),1,VEC(1,I),1)
         END DO
      END IF
      CALL CALCOM(XCOM,YCOM,ZCOM)
      XYZP(1) = XCOM
      XYZP(2) = YCOM
      XYZP(3) = ZCOM
      CALL DIPINT(XCOM,YCOM,ZCOM,.FALSE.)
      DO 300 IXYZ=1,3
         CALL DAREAD(IDAF,IODA,D,NUM2,94+IXYZ,0)
         CALL TFTRI(HF,D,CXM,TM,NORB,NUM,NUM)
C GET (OCC-CORE) x VIR BLOCK
         CALL CPYTSQ(HF,HFP,NUM,1)
         IL=0
         DO 320 IVIR=1,NVIR
            IM=0
            DO 340 IOCC=MMCORE+1,NA
               IM=IM+1
               UM(IM,IVIR,IXYZ)=HFP(IOCC,NA+IVIR)
  340       CONTINUE
  320    CONTINUE
C GET LMO CENTROIDS
         DO 360 J=1,NLOC
            CALL TFTRI(CCHG(IXYZ,J),D,VEC(1,J),TM,1,NUM,NUM)
            CCHG(IXYZ,J) = CCHG(IXYZ,J) + XYZP(IXYZ)
  360    CONTINUE
  300 CONTINUE
      IE=0
      SUM=0.0D+00
      DISP=0.0D+00
      JAY=0
C BEGIN LOOP OVER EFP POINTS
      DO 801 IEFP=1,NFRG
      INPPTS=NPPTS(IEFP)
      DO 800 JEFP=1,INPPTS
      IE=IE+1
      DO IT=1,12
C CONSTRUCT ALPHA TENSOR (DYNAMIC POLARIZABILITY VALUES FOR EFP)
         WRKTR(IT)=DYNTR(JEFP+(IT-1)*INPPTS,IEFP)
      ENDDO
      DO 411 IOCC=1,NLOC
         DO 421 IVIR=1,NVIR
C ENERGY DIFF BETWEEN A VIRTUAL AND AN OCCUPIED AI ORBITAL
            ENRGDF=EORBS(NA+IVIR)-EORBS(MMCORE+IOCC)
C GET VALUE OF INTEGRAL OVER IMAG FREQ RANGE FOR THIS PAIR OF AI ORBITALS
C AND SET OF ALPHA VALUES
            CALL EFAIMF(FR,WRKTR,ENRGDF)
C MULTIPLY IMAG FREQ INTEGRAL WITH CORRESPONDING DIPOLE INTEGRAL
            FUM1(IOCC,IVIR)=UM(IOCC,IVIR,1)*FR
            FUM2(IOCC,IVIR)=UM(IOCC,IVIR,2)*FR
            FUM3(IOCC,IVIR)=UM(IOCC,IVIR,3)*FR
C TRANSPOSE OF DIPOLE INTEGRAL MATRICES
            UM1(IVIR,IOCC)=UM(IOCC,IVIR,1)
            UM2(IVIR,IOCC)=UM(IOCC,IVIR,2)
            UM3(IVIR,IOCC)=UM(IOCC,IVIR,3)
  421    CONTINUE
  411 CONTINUE
C MULTIPLY (IMAG FREQ*DIPOLE) BY (TRANSPOSE OF DIPOLE), OBTAINING SQUARE
C MATRICES INDEXED BY OCCUPIED (VALENCE) ORBITALS ONLY
      CALL MRARBR(FUM1,NLOC,NLOC,NVIR,UM1,NVIR,NLOC,SQ1,NLOC)
      CALL MRARBR(FUM2,NLOC,NLOC,NVIR,UM2,NVIR,NLOC,SQ2,NLOC)
      CALL MRARBR(FUM3,NLOC,NLOC,NVIR,UM3,NVIR,NLOC,SQ3,NLOC)
C  AVERAGE THE MATRICES OVER DIRECTIONAL COMPONENTS: (1/3)(Dx+Dy+Dz)
C  (The FOUR is somehow part of the integration scheme; see SUROUTINE LAPOL
C  in source file LOCPOL, from which this subroutine was adapted.)
      DO I=1,NLOC
         DO J=1,NLOC
            AVG(I,J)=SQ1(I,J)+SQ2(I,J)+SQ3(I,J)
            AVG(I,J)=AVG(I,J)*FOUR*THIRD
         ENDDO
      ENDDO
C TRANSFORM TO LOCALIZED MO BASIS
      CALL TFSQU(H,AVG,TRAN,WORK,NLOC,NLOC)
C DIAGONAL ELEMENTS OF H MATRIX NOW CORRESPOND TO C6 VALUES.
C USE THEM WITH C6*F6/R6 FORMULA:
      DO 790 I=1,NLOC
         C6=H(I,I)
         F6=ONE
         DO IXYZ=1,3
            DIST(IXYZ)=EFP(IXYZ,IE)-CCHG(IXYZ,I)
         ENDDO
         X = DIST(1)
         Y = DIST(2)
         Z = DIST(3)
C         RR=DIST(1)*DIST(1)+DIST(2)*DIST(2)+DIST(3)*DIST(3)
         R2 = X*X + Y*Y + Z*Z
         R=SQRT(R2)
         R6=R2*R2*R2
         IF (IDISDMP.EQ.1) THEN
C           OVERLAP-BASED DAMPING
            SAB=SABEFPAI(IEFP,I,JEFP)
            IF (ABS(SAB) .GT. 1.0D-05) THEN
               RB = -2.0D+00*LOG(ABS(SAB))
               RB2 = RB*RB
               EX1 = SAB*SAB
               F6 = ONE-(EX1*(ONE + RB + RB2/TWO ))
            ELSE
               F6 = ONE
               RB = ZERO
               RB2 = ZERO
               SAB = ZERO
            END IF
         ELSE IF (IDISDMP.EQ.-1) THEN
C           NO DAMPING
            F6=ONE
            RB=ZERO
            RB2 = ZERO
            SAB=ZERO
         ELSE
C           TANG-TOENNIES DAMPING
            RB =  B*R
            EX1 = EXP(-RB)
            RB2 = RB*RB
            RB3 = RB*RB2
            RB4 = RB2*RB2
            RB5 = RB*RB4
            RB6 = RB*RB5
C
            F6 = ONE-(EX1*(ONE + RB + RB2/TWO +
     *               RB3/SIX + RB4/24.0D+00 +
     *               RB5/120.0D+00 +RB6/720.0D+00))
         END IF
         SUM=SUM+C6*F6
         DISP=DISP - C6*F6/R6
C   GRADIENT
C   DE/DR=FOUR/THREE*(-6*C6*F6/R**7 + DF6/DR * C6/R**6)
         IF (IDSGRD.EQ.0) GOTO 790
         IF (IDISDMP .EQ. 1) THEN
C   NOTE: GRADIENT NOT FULLY IMPLEMENTED FOR OVERLAP-BASED
C         DAMPING. NEED "DF6" TERMS, I.E. DSAB (DERIVATIVE
C         OF OVERLAP INTEGRALS TAKEN BTWN EFP&QM ORBITALS)
            CON1=-FOURTHIRD*(C6/R6)*(SIX*F6/R2)
            CON2=-FOURTHIRD*(C6/R6)*(RB2*SAB)
         ELSE
            CON1=-FOURTHIRD*(C6/R6)*
     *           ((SIX*F6/R2)-(B*RB6*EX1)/(R*720.0D+00))
            CON2 = ZERO
         END IF
C
         CONX=CON1*X
         CONY=CON1*Y
         CONZ=CON1*Z
         DEE(1) = DEE(1) + CONX
C     *            + CON2*DSAB(1)
         DEE(2) = DEE(2) + CONY
C     *            + CON2*DSAB(2)
         DEE(3) = DEE(3) + CONZ
C     *            + CON2*DSAB(3)
         DEETORQ(1) = DEETORQ(1)+CONZ*(EFP(2,JEFP)-EFCENT(2,IEFP))
     *                      -CONY*(EFP(3,JEFP)-EFCENT(3,IEFP))
         DEETORQ(2) = DEETORQ(2)+CONX*(EFP(3,JEFP)-EFCENT(3,IEFP))
     *                      -CONZ*(EFP(1,JEFP)-EFCENT(1,IEFP))
         DEETORQ(3) = DEETORQ(3)+CONY*(EFP(1,JEFP)-EFCENT(1,IEFP))
     *                      -CONX*(EFP(2,JEFP)-EFCENT(2,IEFP))
         DEETORQ(4) = DEETORQ(4)+CONZ*(CCHG(2,I)-YCOM)
     *                      -CONY*(CCHG(3,I)-ZCOM)
         DEETORQ(5) = DEETORQ(5)+CONX*(CCHG(3,I)-ZCOM)
     *                      -CONZ*(CCHG(1,I)-XCOM)
         DEETORQ(6) = DEETORQ(6)+CONY*(CCHG(1,I)-XCOM)
     *                      -CONX*(CCHG(2,I)-YCOM)
C
C END LOOP OVER VALENCE LMOs
  790 CONTINUE
C  END LOOP OVER EFP POINTS
  800 CONTINUE
      IF (IDSGRD.EQ.0) GOTO 801
      DO J=1,3
         DESFRG(J,IEFP) = DESFRG(J,IEFP) + DEE(J)
         DESFRG(J+3,IEFP) = DESFRG(J+3,IEFP) + DEETORQ(J)
      ENDDO
C END LOOP OVER NUMBER OF FRAGMENTS
  801 CONTINUE
      IF (IDSGRD.EQ.0) GOTO 999
C     GET MOMENTS OF INERTIA AND TOTAL MASS FOR AI
      TMASS=ZERO
      DO I=1,NAT
         CEE(I,1)=C(1,I)
         CEE(I,2)=C(2,I)
         CEE(I,3)=C(3,I)
         ZNU(I)=ZAN(I)
         TMASS = TMASS + ZMASS(I)
      ENDDO
      CALL PRAXIS(CEE,ZNU,NAT,NAT,AIX,AIY,AIZ)
C     CALCULATE ROTATIONAL ACCELERATION AT ATOMS
      IF (NAT.EQ.1) THEN
         AROT(1,1)=ZERO
         AROT(2,1)=ZERO
         AROT(3,1)=ZERO
         GOTO 390
      END IF
      IF (AIX.GT.1.0D-05) THEN
         ALX=DEETORQ(4)/AIX
      ELSE
         ALX=ZERO
      END IF
      IF (AIY.GT.1.0D-05) THEN
         ALY=DEETORQ(5)/AIY
      ELSE
         ALY=ZERO
      END IF
      IF (AIZ.GT.1.0D-05) THEN
         ALZ=DEETORQ(6)/AIZ
      ELSE
         ALZ=ZERO
      END IF
      DO I=1,NAT
        AROT(1,I)=ALZ*(C(2,I)-YCOM)-ALY*(C(3,I)-ZCOM)
        AROT(2,I)=ALX*(C(3,I)-ZCOM)-ALZ*(C(1,I)-XCOM)
        AROT(3,I)=ALY*(C(1,I)-XCOM)-ALX*(C(2,I)-YCOM)
      ENDDO
C     CALCULATE TRANSLATIONAL ACCELERATION
 390  DO I=1,3
         ATRAN(I)=DEE(I)/TMASS
      ENDDO
C     CALCULATE TOTAL ACCELERATION AND TOTAL FORCE,
C     ADD TO GRADIENT "DE"
      DO I=1,NAT
         DO J=1,3
            ATOTAL(J,I)=AROT(J,I)+ATRAN(J)
            FTOTAL(J,I)=ATOTAL(J,I)*ZMASS(I)
            DE(J,I) = DE(J,I) + FTOTAL(J,I)
         ENDDO
      ENDDO
C
C  APPROXIMATE THE HIGHER ORDER TERMS IN DISPERSION ENERGY
C  EXPANSION AS 1/3 OF THE C6 CONTRIBUTION
  999 DISPENRG = DISP*FOURTHIRD
C     WRITE(IW,1000) DISPENRG
      IF (ALLOCATED(SABEFPAI)) DEALLOCATE(SABEFPAI)
      RETURN
C1000 FORMAT(1X,'EFP-AI DISPERSION ENERGY =',F20.10)
      END SUBROUTINE EFAIDISP
C
C *MODULE EFDRVR  *DECK EFAIMF
!> @brief Calculates imaginary frequency integral between
!>        pairs of AI orbitals; for use with EFAIDISP code
!>
!> @author Tony Smith
!> - Jan 10, 2013
!> @param FR : the final calculated value of the integral
!> @param ALP : alpha tensor; array of 12 values
!> @param ENRGDF : energy difference between two AI orbitals
      SUBROUTINE EFAIMF(FR,ALP,ENRGDF)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXFRG=1050, MXIFRQ=12, MXFGPT=12000,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00)
C THE 12 GAUSS-LEGENDRE WEIGHTS
      PARAMETER (FACT1= 0.72086099022968040154D-02)
      PARAMETER (FACT2= 0.17697067815034886394D-01)
      PARAMETER (FACT3= 0.30660908596251749739D-01)
      PARAMETER (FACT4= 0.48381293256249884995D-01)
      PARAMETER (FACT5= 0.74878830420650517080D-01)
      PARAMETER (FACT6= 0.11806515901361630228D+00)
      PARAMETER (FACT7= 0.19535413832209084204D+00)
      PARAMETER (FACT8= 0.35055692324483221824D+00)
      PARAMETER (FACT9= 0.71577113554429568336D+00)
      PARAMETER (FACT10=1.81409759976323969729D+00)
      PARAMETER (FACT11=6.97923445114870823247D+00)
      PARAMETER (FACT12=83.2480938829658453917D+00)
C THE 12 GAUSS-LEGENDRE ABSCISSAS A.K.A. IMAGINARY FREQ VALUES
C (THE FOLLOWING ARE ACTUALLY THE FREQUENCIES *SQUARED*)
      PARAMETER (FREQ1=0.779327022332536710825D-05)
      PARAMETER (FREQ2=0.228210717737242978745D-03)
      PARAMETER (FREQ3=0.152113192477780750688D-02)
      PARAMETER (FREQ4=0.608339199058554610325D-02)
      PARAMETER (FREQ5=0.192239670393041989464D-01)
      PARAMETER (FREQ6=0.543928293635942075334D-01)
      PARAMETER (FREQ7=0.148916688004125595980D+00)
      PARAMETER (FREQ8=0.421349037034822917794D+00)
      PARAMETER (FREQ9=1.331494010666300803437D+00)
      PARAMETER (FREQ10=5.32498192172462030801D+00)
      PARAMETER (FREQ11=3.54935126637048206534D+01)
      PARAMETER (FREQ12=1.03935828835455831714D+03)
C
      CHARACTER*8 POLNAM,DPOLNAM
      LOGICAL GOPARR,DSKWRK,MASWRK
      DIMENSION  ALP(12)
C
      ENRGSQ=ENRGDF*ENRGDF
C
      FR= ALP(1)*FACT1/(ENRGSQ+FREQ1)
     *  + ALP(2)*FACT2/(ENRGSQ+FREQ2)
     *  + ALP(3)*FACT3/(ENRGSQ+FREQ3)
     *  + ALP(4)*FACT4/(ENRGSQ+FREQ4)
     *  + ALP(5)*FACT5/(ENRGSQ+FREQ5)
     *  + ALP(6)*FACT6/(ENRGSQ+FREQ6)
     *  + ALP(7)*FACT7/(ENRGSQ+FREQ7)
     *  + ALP(8)*FACT8/(ENRGSQ+FREQ8)
     *  + ALP(9)*FACT9/(ENRGSQ+FREQ9)
     *  + ALP(10)*FACT10/(ENRGSQ+FREQ10)
     *  + ALP(11)*FACT11/(ENRGSQ+FREQ11)
     *  + ALP(12)*FACT12/(ENRGSQ+FREQ12)
      FR=FR*ENRGDF
      RETURN
      END SUBROUTINE EFAIMF
