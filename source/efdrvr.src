C 30 SEP 13 - NDS - EFP1 EMPIRICAL DISPERSION CORRECTION (EFP1-D)
C 18 Feb 13 - MWS - EFGRAD: project gradient if PBC is being used
C 19 Oct 12 - MWS - synchronize FRGINF common
C 21 MAR 12 - TLW,ACW,MWS - REMOVED CALL VNNDER
C                           ADDED CALL EFPDERCOM
C 28 DEC 11 - CS  - EFMO CHANGES FOR COVALENT BONDS
C  2 NOV 11 - MWS - ENABLE FRAGMENT ONLY NUMERICAL GRADIENT PATHWAY
C 11 AUG 11 - AAD - QM/EFP ENERGY DECOMPOSITION ANALYSIS
C 12 DEC 10 - HL  - ADD ARTIFICIAL FORCES ON ATOMS/FRAGMENTS
C  1 OCT 10 - CS  - ADDED EFMO CHANGES
C 11 AUG 10 - DGF - ALLOCATE NEEDED STORAGE FOR PRJGRD
C 25 MAR 10 - HL  - CHANGES FOR CORRECT EFP(NO POL)+PCM JOBS
C 25 MAR 10 - DJS,DGF - PAD COMMON BLOCK PCMPNT, ARGS FOR GRADIENT PROJ.
C  1 MAY 09 - LVS - CHANGES TO ALLOW FOR FORCE POINTS
C  1 MAY 09 - NMT - NEW DIMENSION FOR EFPBAS AND FRAGMT
C 12 JAN 09 - DGF - SYNCHRONISE PCMPNT, AGAIN
C 20 NOV 08 - HL  - POLPCM: REMOVE CHARGE PENETRATION FOR EFP/PCM,
C                   USE AVERAGED INDUCED DIPOLES FOR EFP/PCM
C 23 OCT 08 - LVS - DISPERSION DAMPING, CLEAN UP JIE'S CODE
C 20 AUG 07 - LVS - PBC-EFP CLEANED
C 24 MAR 07 - LVS - PAD FRGINF,EFPPAR; PRINT FUNCTION PREFP ADDED
C 17 JAN 06 - HL  - MD SWITCHING FUNCTIONS, CHANGES TO IND.DIP.,EFP/PCM
C 14 NOV 05 - HL  - POLPCM ADDED TO ALLOW FOR EFP+PCM COMPUTATIONS
C 19 SEP 05 - HMN,IA - CHANGES FOR MOLECULAR DYNAMICS
C 15 JUL 05 - MWS - EFPPOL,EFPPOL2: RESTRICT VCLR RANGES
C 13 JUL 05 - MWS - CHANGE DYN.STORE FOR CHGTRN,EFPPOL
C  5 JUL 05 - MWS - ALLOCATE DYNAMIC MEMORY FOR DIPIT
C 27 JUN 05 - HL  - PERIODIC BOUNDARY COND, PARALLEL EFP2 DISPERSION
C  1 JUN 05 - MWS - EFSP: SUM ALL ES TERMS IN PARALLEL RUN
C 30 APR 05 - DGF - SYNCHRONISE OPTGRD COMMON BLOCK
C 14 MAR 05 - HL  - EFP CHARGE TRANSFER ENERGY, PAULI CHANGES
C  7 MAR 05 - IA  - EFP2 DISPERSION AND DYNAMIC POLARIZABILITY
C 22 FEB 05 - MWS - EFSP: CHANGE ENERGY PRINTING (AND DEBUG OUTPUTS)
C 13 FEB 05 - HMN - ADD DUMMY EFP MD HOOKS INTO EFSP,
C                   ADD EFP PARALLELIZATION INTO EFSP AND EFPPOL
C 13 FEB 05 - JS  - ADD EFP MP2 CALLS TO EFSP AND EFPPOL, ADD EFPPOL2
C 23 JUL 04 - HL  - EFSP: DO FORMAL MEMORY ALLOCATION FOR EFPPOL CALL
C  9 DEC 03 - MWS - EFGRAD: KILL NUMERICAL HESSIAN REQUEST
C  3 JUL 03 - JMM - SUPPRESS PRINTING FOR MONTE CARLO JOBS
C  7 AUG 02 - HT  - USE DYNAMIC MEMORY FOR EFP PAULI REPULSION
C 17 APR 02 - MWS - SYNCH UP FRGINF COMMON
C 13 JUN 01 - MAF - EFSP: COMPUTE CHARGE PENETRATION ENERGY
C 20 FEB 01 - PND - EFSP,EFPPOL: DIP.CONV. AND PRINTING CHANGES
C 25 MAR 00 - MWS - CHANGE ARGUMENTS TO VNNDER
C 20 NOV 97 - MWS - EFSP: USE JAN'S PAULI EXCHANGE ROUTINE
C  2 SEP 97 - MWS - EFSP: CHANGE WORDING OF ENERGY OUTPUT
C 16 MAY 97 - GNM - EFFECTIVE FRAGMENT DRIVER MODULE CREATED
C
C*MODULE EFDRVR  *DECK EFSP
C>
C>     @brief Main EFP energy driver
C>
C>     @details This routine calculates fragment-fragment interaction
C>     energies in the absence of an ab initio molecule
C>
C>     @date 10/5/12 - Spencer Pruitt
C>     - Added EFMOCHTNRG, EFMOREPNRG andD EFMOEPEN to transfer relevant
C>       energies to EFMO code.
C>     @date March, 2013 - Colleen Bertoni
C>     - Cleared LSABSAVE and LSABGRAD so they won't cause
C>       memory errors when different EFMO terms are turned on
C>       and off.
C>
C> @date    September, 2013 - Nuwan De Silva
C>          EFP1 dispersion correction:
C>          The dispersion could be introduced into the EFP1 method
C>          in a manner that is analogous to the Grimme's dispersion
C>          correction to DFT (DFT-D) or HF (HF-D). Such a method
C>          can be called EFP1-D.
C>
C>     @param EFMOCHTNRG: EFMO charge transfer energy
C>
C>     @param EFMOREPNRG: EFMO repulsion energy
C>
C>     @param EFMOEPEN: EFMO charge penetration energy
C
      SUBROUTINE EFSP
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL DC,DCCHG,DCABC
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL IFGRAD
      LOGICAL IFEWLD,TNFOIL,EWLDPL,DEBUGOPT
      LOGICAL IFRCPNT
C
      LOGICAL EFMODOEFPC
      PARAMETER (MXAO=8192, MXATM=2000, MXDFG=5, MXFRG=1050,
     *           MXPT=2000, MXFGPT=12000, MXIFRQ=12,
     *           MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (ZERO = 0.0D+00, HALF=0.50D+00, FACT=1.593601268D-03)
C
      CHARACTER*8 FRCNME,LJNAME,ELJNAM
      DOUBLE PRECISION MD
C
      COMMON /CENTRL/ RQM,XQM,YQM,ZQM,RMM,XMM,YMM,ZMM,ICENFD
      COMMON /DFTDC / DC,IDCVER,DCCHG,DCABC,DCSR,DCS6,DCS8,DCALP
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,
     *                EFMOREPNRG,EFMOCHTNRG,EFMOEPEN,EFMOPCMG,
     *                IEFMORUN,IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,
     *                IEFMODIM(2),IMODEFE,NATEFMO,IMODEFD,IMODEFER,
     *                IMODEFCT,IDIMTYP
      COMMON /EFPCT / NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CTFOK(MXAO,MXDFG),NCTMO(MXDFG),NTCTMO
      COMMON /EFPIO / MULMAT(MXFRG)
      COMMON /EFPFRC/ IFRCPNT,NTFRCPN,NFRCPNT(MXFRG),LSTFPTS(MXFRG),
     *                FRCCRD(3,MXFGPT),FRCNME(MXFGPT),FRCTRQ(6,MXFGPT)
     *                ,FRCTRQX(6,MXFGPT)
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FMCOM / XX(1)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGLJP/ CORDLJ(3,MXPT),ELJCRD(3,MXFGPT),
     *                POTLJ(2,MXPT),ELJPOT(2,MXFGPT),
     *                LJNAME(MXPT),ELJNAM(MXFGPT),
     *                NLJPTS(MXFRG),NLJTTPT,ILJP,NMLJ(2)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /FRGNRG/ CCNRG,CDNRG,CQNRG,CONRG,DDNRG,DQNRG,QQNRG,
     *                ESNRG,REPNRG,POLNRG,DISNRG,DISNRG8,
     *                EDISD,CHTNRG
      COMMON /FUNCT / E,EG(3*MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /OPTGRD/ Q(3*MXATM),ES,QQ(20),
     *                CONVF,FMAXT,DXMAXT,RMAX,RMIN,RLIM,
     *                EIGMAX,EIGMIN,GRDERR,FRMS,FMAX,TRMAX,TRMIN,
     *                IC(20),NSTEP,NSERCH,NPMAX,NP,IFOLOW,
     *                NNEG,IUPHSS,IEXIT,ITRUPD,IPAD,KDIAGH
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SIMDAT/ NACC,NREJ,IGOMIN,NRPA,IBWM,NACCT,NREJT,NRPAT,
     *                NPRTGO,IDPUNC,IGOFLG
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCMDIM/ MXSP,MXTS,MEMPCM1,MEMPCM2,NTS
      COMMON /PCMOPT/ RABI,RASC,REFPOL,THRSLS,DENSLS,WB,WA,ETA2,GD,EVAC,
     *                RHOW,PM,AREATL,AREAKP,BONDRY,OMEGA,RET,FRO,EPSINF,
     *                EPS,DR,RSOLV,VMOL,TCE,STEN,DSTEN,CMF,TABS,IDIRCT,
     *                IPCDER,IDP,ICOMP,IFIELD,ICAV,IDISP,IPRINT,IRETCAV,
     *                ICENT,IFAST,NEVAL,KEFPOL,KEEPSM,IMGABI,IMGASC,NADD
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IRPPCM,IEF,IP_F,NFMOPCM
      COMMON /PCMPNT/ LXYZRE,LSSFE,LLIST,LALPCM,LRINPCM,LINAPCM,LINFPCM,
     *                LINIPCM,LMEPCM,LAXYZCT,LXYZCT2,LNVERT,LQSN,LQSE,
     *                LQFS,LQIND,LISPHE,LVAD,LQOR,LVECMUL,LAIPRJ,LFIPRJ,
     *                LPEL,LPCMCDR,LDAI,LIDDAI,LQSND,LQSED
      COMMON /PCMPRT/ GCAVP,GCAVS,GDISP,GREP,EHFGAS
      COMMON /PCMEFP/ PB_MUL,PC_MUL,PB_POL,PC_POL,P_FF,P_NF,P_FN,P_I,
     *                P_IBIS,P_J,P_NUCC,P_NUCCBIS,ENPCM
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
      COMMON /EWALD / IFEWLD,TNFOIL,BETA,ELCNST,EPSLN,CUTOFF,CUTLST,
     *                KMAX,NKVEC,LEVEL,EWLDPL
      COMMON /SELFE / ESELFCC, ESELFDD, EEXCLCC, EEXCLCD, EEXCLDD,
     *                EEXCLCQ
      COMMON /EFPMP2/ MP2TYP
C
      DATA HSSIAN/8HHESSIAN /, SADPT/8HSADPOINT/
      DATA AIRC/8HIRC     /
      DATA MD /8HMD      /
C
C     -------------------------------------------------------------
C     --- THIS ROUTINE CALCULATES FRAGMENT-FRAGMENT INTERACTION ---
C     --- ENERGIES IN THE ABSENCE OF AN AB INITIO MOLECULE      ---
C     -------------------------------------------------------------
C
C     FIRST, INITIALIZE SOME PARALLELIZATION INFORMATION.
C
      CALL EFPPARL
C
C     CCNRG  = CHARGE-CHARGE INTERACTION ENERGY
C     CDNRG  = CHARGE-DIPOLE INTERACTION ENERGY
C     CQNRG  = CHARGE-QUADRUPOLE INTERACTION ENERGY
C     CONRG  = CHARGE-OCTUPOLE INTERACTION ENERGY
C     DDNRG  = DIPOLE-DIPOLE INTERACTION ENERGY
C     DQNRG  = DIPOLE-QUADRUPOLE INTERACTION ENERGY
C     QQNRG  = QUADRUPOLE-QUADRUPOLE INTERACTION ENERGY
C     ESNRG  = TOTAL ELECTROSTATIC INTERACTION ENERGY
C     REPNRG = EXCHANGE-REPULSION ENERGY
C     POLNRG = POLARIZATION ENERGY
C     DISNRG = MP2/EFP1 C6 DISPERSION ENERGY
C     DISNRG8= MP2/EFP1 C8 DISPERSION ENERGY
C     EDISD  = EFP2 DAMPED DISPERSION ENERGY
C     CHTNRG = EFP2 CHARGE TRANSFER ENERGY
C     ENPCM  = PCM ELECTROSTATIC SOLVATION ENERGY
C     GCAVP  = PCM CAVITATION ENERGY
C     GDISP  = PCM DISPERSION ENERGY
C     GREP   = PCM REPULSION ENERGY
C
      E      = ZERO
      CCNRG  = ZERO
      CDNRG  = ZERO
      CQNRG  = ZERO
      CONRG  = ZERO
      DDNRG  = ZERO
      DQNRG  = ZERO
      QQNRG  = ZERO
      ESNRG  = ZERO
      REPNRG = ZERO
      POLNRG = ZERO
      DISNRG = ZERO
      DISNRG8= ZERO
      EDISD  = ZERO
      EDISD0  = ZERO
      CHTNRG = ZERO
      ENPCM  = ZERO
      GCAVP  = ZERO
      GDISP  = ZERO
      GREP   = ZERO
      EPEN   = ZERO
C
C     -- EFP CENTER OF MASS --
C
      CALL EFCM
C
C     -- ELECTROSTATIC ENERGIES --
C     ELECTROSTATIC ENERGIES (AND GRADIENTS) ARE DONE IN FFELEC NOW,
C     REPLACING THE SMALL ARMY OF ROUTINES CHGCHG, ETC. ETC.
C
      MAXDER = 0
      CALL DERCHK(MAXDER)
                                          IFGRAD = .FALSE.
      IF(MAXDER.GT.0)                     IFGRAD = .TRUE.
      IF(MAXDER.EQ.1  .AND.  NGLEVL.EQ.1) IFGRAD=.FALSE.
      IF(MAXDER.EQ.2  .AND.  NHLEVL.EQ.2) IFGRAD=.FALSE.
C
      IF(IEFMORUN.GT.0) THEN
        IF(IEFMORT.NE.3) GOTO 10
        IF(IEFMORT.EQ.3.AND.IDIMTYP.EQ.-1) GOTO 10
      ENDIF
C
      CALL FFELEC(ESNRG,CCNRG,CDNRG,CQNRG,CONRG,DDNRG,DQNRG,QQNRG,
     *                  IFGRAD,.FALSE.)
 10   CONTINUE
C
      IF (IFEWLD) THEN
C  ---- EWALD SUMS: DIRECT TERM IS CALCULATED WITHIN FFELEC
C  ---- HERE WE CALCULATE OTHER TERMS:
C  ---- SELF-ENERGY & EXCLUSION ENERGY, RECIPROCAL, AND TIN-FOIL PART
C
         ESNRG = ESNRG + ESELFCC + ESELFDD + EEXCLCC + EEXCLCD
     *         + EEXCLDD + EEXCLCQ
C
         CALL RECIPR(ERCPRCC,ERCPRCD,ERCPRDD,ERCPRCQ,ERCPRDQ,
     *                    ERCPRQQ,ERCPRCO,IFGRAD)
C         WRITE(6,988) ERCPRCC,ERCPRCD,ERCPRDD,ERCPRCQ
C  988  FORMAT(/1X,'ERCPRCC = ',F18.14/
C     *        1X,'ERCPRCD = ',F18.14/
C     *        1X,'ERCPRDD = ',F18.14/
C     *        1X,'ERCPRCQ = ',F18.14)
         ESNRG = ESNRG +
     *           ERCPRCC + ERCPRCD + ERCPRDD  + ERCPRCQ
C
         CALL TINFOIL(ETFCC,ETFCD,ETFDD, IFGRAD)
C        WRITE(6,989) ETFCC,ETFCD,ETFDD
C  989  FORMAT(/1X,'ETFCC = ',F18.14/
C     *        1X,'ETFCD = ',F18.14/
C     *        1X,'ETFDD = ',F18.14)
         ESNRG = ESNRG + ETFCC + ETFCD + ETFDD
C         WRITE(6,*) 'TOTAL CHARGE-CHARGE: ',CCNRG + ESELFCC +
C     *               EEXCLCC + ERCPRCC + ETINFOIL
C
C  ---- THIS IS DEBUGGING OPTION WHICH CALCULATES ELECTROSTATIC SUM
C  ---- DIRECTLY. FOR UNCLEAR REASON, WORKS PROPERLY ONLY FOR ATOMS NOT
C  ---- FOR MOLECULES
         DEBUGOPT=.FALSE.
         IF (DEBUGOPT) CALL DIRECTSUM
      END IF
C
C     -- EXCHANGE-REPULSION ENERGY ---
C
C      MEMORY FOR SAB MATRIX: NEED TO KEEP IT FOR DISPERSION DAMPING
C
      LSABSAVE = 0
      LSABGRAD = 0
      IF (NTMO.GT.0) THEN
         MXMO=0
         MXBF=0
         DO I = 1, NFRG
            MXMO=MAX(MXMO,NORB(I))
            MXBF=MAX(MXBF,NPBF(I))
         END DO
C
         CALL VALFM(LOADFM1)
         LSABSAVE = LOADFM1 + 1
         LSABGRAD = LSABSAVE + NFRG*NFRG*MXMO*MXMO
         IF (IFGRAD) THEN
            MEMGRAD = NFRG*NFRG*MXMO*MXMO*6
         ELSE
            MEMGRAD = 0
         END IF
         LAST1 = LSABGRAD + MEMGRAD
         NEEDSAB = LAST1 - LOADFM1 -1
         CALL GETFM(NEEDSAB)
      END IF
C
      IF(IREP.EQ.1 .AND. ILJP.EQ.1) THEN
         CALL ENRGLJ(REPNRG)
      ELSE IF(IREP.EQ.1 .AND. ILJP.EQ.0) THEN
         MXRPTS = 0
         DO IFRG = 1,NFRG
            MXRPTS = MAX(NRPTS(IFRG),MXRPTS)
         ENDDO
         MXRPTS = MXRPTS+1
         NDFRG2 = (NDFRG*NDFRG+NDFRG)/2
         LEN = MXRPTS*MXRPTS*NDFRG2
         CALL VALFM(LOADFM)
         LAREL = LOADFM + 1
         LCREL = LAREL + LEN
         LEFLD = LCREL + LEN
         LEFAD = LEFLD + 3*NPTTPT
         LAST  = LEFAD + 3*NPTTPT
         NEED = LAST - LOADFM - 1
         CALL GETFM(NEED)
         CALL DAREAD(IDAF,IODA,XX(LAREL),2*LEN,75,0)
C
         CALL EREPUL(REPNRG,XX(LAREL),XX(LCREL),MXRPTS,NDFRG2)
         CALL RETFM(NEED)
      ELSE IF (NTMO.GT.0) THEN
         MXMO2=(MXMO*MXMO+MXMO)/2
         LENPV=MXBF*NTMO
         LENFM=MXMO2*NFRG
C
C        IF GRADIENT IS NOT NEEDED
         IF(IFGRAD .EQV. .FALSE.) THEN
           CALL VALFM(LOADFM)
           LPROVEC = LOADFM  + 1
           LFOCKMA = LPROVEC + MXBF*NTMO
           LSMAT   = LFOCKMA + MXMO2*NFRG
           LTMAT   = LSMAT   + MXBF*MXBF
           LWRK    = LTMAT   + MXBF*MXBF
           LSIJ    = LWRK    + MXBF
           LTIJ    = LSIJ    + MXMO*MXMO
           LFASQ   = LTIJ    + MXMO*MXMO
           LFBSQ   = LFASQ   + MXMO*MXMO
           LAST    = LFBSQ   + MXMO*MXMO
           NEED=LAST-LOADFM-1
           CALL GETFM(NEED)
           CALL DAREAD(IDAF,IODA,XX(LPROVEC),LENPV,267,0)
           CALL DAREAD(IDAF,IODA,XX(LFOCKMA),LENFM,268,0)
           CALL EXREP(REPNRG,XX(LPROVEC),XX(LFOCKMA),XX(LSMAT),
     *                XX(LTMAT),XX(LWRK),XX(LSIJ),XX(LTIJ),
     *                XX(LFASQ),XX(LFBSQ),XX(LSABSAVE),MXBF,MXMO,EPEN)
           CALL RETFM(NEED)
         ELSE
C          - CALCULATE ENERGY & GRADIENTS TOGETHER
           CALL VALFM(LOADFM)
           LPROVEC = LOADFM  + 1
           LDPVEC  = LPROVEC + MXBF*NTMO
           LFOCKMA = LDPVEC  + MXBF*NTMO*3
           LSMAT   = LFOCKMA + MXMO2*NFRG
           LTMAT   = LSMAT   + MXBF*MXBF
           LWRK    = LTMAT   + MXBF*MXBF
           LSAB    = LWRK    + MXBF
           LTAB    = LSAB    + MXMO*MXMO
           LFASQ   = LTAB    + MXMO*MXMO
           LFBSQ   = LFASQ   + MXMO*MXMO
           LDSINT  = LFBSQ   + MXMO*MXMO
           LDTINT  = LDSINT  + MXBF*MXBF*6
           LDSAB   = LDTINT  + MXBF*MXBF*6
           LDTAB   = LDSAB   + MXMO*MXMO*6
           LWRK2   = LDTAB   + MXMO*MXMO*6
           LGXRFRG = LWRK2   + MXMO*MXMO
           LXRFRG  = LGXRFRG + NFRG*NFRG*6
           LAST    = LXRFRG  + NFRG*NFRG*6*4
           NEED=LAST-LOADFM-1
           CALL GETFM(NEED)
           CALL DAREAD(IDAF,IODA,XX(LPROVEC),LENPV,267,0)
           CALL DAREAD(IDAF,IODA,XX(LFOCKMA),LENFM,268,0)
           CALL DERVEC(1,XX(LDPVEC),XX(LPROVEC),MXBF,NTMO)
C  DIFFERENT SUBROUTINE IF NEED TO GATHER EFP FORCES AT FORCE POINTS
           IF (IFRCPNT) THEN
           CALL GEXREP_FP(REPNRG,XX(LPROVEC),XX(LFOCKMA),XX(LSMAT),
     *                 XX(LTMAT),XX(LWRK),XX(LSAB),XX(LTAB),
     *                 XX(LFASQ),XX(LFBSQ),XX(LDPVEC),XX(LDSINT),
     *                 XX(LDTINT),XX(LDSAB),XX(LDTAB),XX(LWRK2),
     *                 XX(LGXRFRG),XX(LSABSAVE),XX(LSABGRAD),
     *                 MXBF,MXMO,XX(LXRFRG),EPEN)
           ELSE
           CALL GEXREP(REPNRG,XX(LPROVEC),XX(LFOCKMA),XX(LSMAT),
     *                 XX(LTMAT),XX(LWRK),XX(LSAB),XX(LTAB),
     *                 XX(LFASQ),XX(LFBSQ),XX(LDPVEC),XX(LDSINT),
     *                 XX(LDTINT),XX(LDSAB),XX(LDTAB),XX(LWRK2),
     *                 XX(LGXRFRG),XX(LSABSAVE),XX(LSABGRAD),
     *                 MXBF,MXMO,XX(LXRFRG),EPEN)
           END IF
           CALL RETFM(NEED)
         END IF
C
      END IF
C
C     -- ARTIFICIAL FORCE ON FRAGMENTS --
C        WATER RADIUS = 1.928 A, INPUT RMM=13.072 FOR R = 15.0
C        ONLY ENERGY IS DONE HERE, GRADIENT IS IN DECK VNNDER
C
      IF(ICENFD.EQ.1) THEN
         ECENT = ZERO
         R0    = RMM
         RX    = XMM
         RY    = YMM
         RZ    = ZMM
         POWER = 2.0D+00
         DO IFRG = 1, NFRG
            COMX  = EFCENT(1,IFRG)
            COMY  = EFCENT(2,IFRG)
            COMZ  = EFCENT(3,IFRG)
            XABS  = ABS(COMX)
            YABS  = ABS(COMY)
            ZABS  = ABS(COMZ)
            COMR2 = COMX*COMX + COMY*COMY + COMZ*COMZ
            COMR  = SQRT(COMR2)
            IF(COMR.GT.R0) THEN
               ECENT= ECENT + (COMR-R0)**POWER
            END IF
            IF(XABS.GT.RX) THEN
               ECENT= ECENT + (XABS-RX)**POWER
            END IF
            IF(YABS.GT.RY) THEN
               ECENT= ECENT + (YABS-RY)**POWER
            END IF
            IF(ZABS.GT.RZ) THEN
               ECENT= ECENT + (ZABS-RZ)**POWER
            END IF
         ENDDO
C        - THE BEST IS TO ADD ECENT TO EFP-EFP REPULSION -
         REPNRG = REPNRG + ECENT
      END IF
C
C
C     -- MP2/EFP1 DISPERSION ENERGY --
C
      IF(MP2TYP.EQ.1) THEN
         MXDPTS = 0
         DO IFRG = 1,NFRG
            MXDPTS = MAX(NDPTS(IFRG),MXDPTS)
         ENDDO
         MXDPTS = MXDPTS+1
         NDFRG2 = (NDFRG*NDFRG+NDFRG)/2
         LEN = MXDPTS*MXDPTS*NDFRG2
         DISNRG = ZERO
         DISNRG8= ZERO
C
         CALL VALFM(LOADFM)
         LAREL = LOADFM + 1
         LDREL = LAREL + LEN
         LCREL = LDREL + LEN
         LAST  = LCREL + LEN
         LBREL = LAST  + LEN
         LEREL = LBREL + LEN
         LAST1 = LEREL + LEN
         NEED  = LAST1 - LOADFM - 1
         CALL GETFM(NEED)
         CALL DAREAD(IDAF,IODA,XX(LAREL),6*LEN,81,0)
         CN=6.0D+00
         CALL EDISPR(DISNRG,XX(LAREL),XX(LDREL),XX(LCREL),
     *               MXDPTS,NDFRG2,CN)
         CN=8.0D+00
         CALL EDISPR(DISNRG8,XX(LAST),XX(LBREL),XX(LEREL),
     *               MXDPTS,NDFRG2,CN)
         CALL RETFM(NEED)
      END IF
C
C     -- POLARIZATION ENERGY ---
C     -- PCM SOLVATION ENERGY --
C
      MXPPT = 0
      DO IFRG = 1,NFRG
         MXPPT = MAX(NPPTS(IFRG),MXPPT)
      ENDDO
C
      IF(IPCM.EQ.1) THEN
          NPRTBK=NPRINT
          NPRINT=817
          IF(ICAV.EQ.1) CALL CAVITM
          IF(IDISP.EQ.1) CALL DISRPM
          NPRINT=NPRTBK
C
          CALL VALFM(LOADFM)
          LEFLD = LOADFM + 1
          LEFAD = LEFLD  + 3*NPTTPT
          LAST  = LEFAD  + 3*NPTTPT
          NEED=LAST - LOADFM -1
          CALL GETFM(NEED)
          CALL POLPCM(XX(LEFLD),XX(LEFAD),XX(LQSE),XX(LQSED),
     *                XX(LQSN),XX(LAXYZCT),XX(LAXYZCT+MXTS),
     *                XX(LAXYZCT+MXTS*2),XX(LAXYZCT+MXTS*3),
     *                XX(LXYZRE),XX(LXYZRE+MXSP),XX(LXYZRE+MXSP*2),
     *                XX(LXYZRE+MXSP*3),XX(LISPHE),XX(LLIST),POLNRG)
          CALL RETFM(NEED)
      ELSE IF (IEFP.EQ.1) THEN
          CALL VALFM(LOADFM)
          LEFLD = LOADFM + 1
          LEFAD = LEFLD + 3*NPTTPT
          LAST  = LEFAD + 3*NPTTPT
          NEED=LAST-LOADFM-1
          CALL GETFM(NEED)
          CALL EFPPOL(XX(LEFLD),XX(LEFAD),POLNRG)
          CALL RETFM(NEED)
      END IF
C
C     -- EFP2 CHARGE TRANSFER ENERGY --
C
C EFP2 CHARGE TRANSFER NOT YET DERIVED FOR OPEN SHELL (ROHF) METHOD
C
C CHECK TO SEE IF ANY MULTIPLICITIES ARE GREATER THAN 1
C IF SO, SKIP CT CALCULATIONS ALTOGETHER
C
C THIS SKIPS ANY CT CALCULATION BETWEEN
C CLOSED-SHELL MOLECULES AS WELL
C
      DO I=1,NFRG
       IF (MULMAT(I) .GT. 1)  GOTO 100
      END DO
C
      IF(NTCTMO.GT.0)THEN
         MXAOEFP=0
         MXBFEFP=0
         MXCTMOEFP=0
         DO I = 1, NFRG
            MXAOEFP=MAX(MXAOEFP,NAO(ISET(I)))
            MXBFEFP=MAX(MXBFEFP,NPBF(I))
            MXCTMOEFP=MAX(MXCTMOEFP,NCTMO(ISET(I)))
         END DO
         LENCV=MXBFEFP*NTCTMO
C
C        IF NO GRADIENTS
         IF(IFGRAD .EQV. .FALSE.) THEN
           CALL VALFM(LOADFM)
           LCTVEC  = LOADFM  + 1
           LSMAT   = LCTVEC  + MXBFEFP*NTCTMO
           LTFRG   = LSMAT   + MXBFEFP*MXBFEFP
           LTMAT   = LTFRG   + MXCTMOEFP*MXCTMOEFP*MXDFG
           LWRK    = LTMAT   + MXBFEFP*MXBFEFP
           LSAB    = LWRK    + MXBFEFP
           LTAB    = LSAB    + MXCTMOEFP*MXCTMOEFP
           LVEFP   = LTAB    + MXCTMOEFP*MXCTMOEFP
           LVABEFB = LVEFP   + MXBFEFP*MXBFEFP
           LVABEFA = LVABEFB + MXCTMOEFP*MXCTMOEFP
           LVAAEFB = LVABEFA + MXCTMOEFP*MXCTMOEFP
           LVBBEFA = LVAAEFB + MXCTMOEFP*MXCTMOEFP
           LECTFRG = LVBBEFA + MXCTMOEFP*MXCTMOEFP
           LIDOIT  = LECTFRG + NFRG*NFRG
           LQUAD   = LIDOIT  + NMTTPT
           LAST    = LQUAD   + 6*NMTTPT
           NEED=LAST-LOADFM-1
           CALL GETFM(NEED)
           CALL DAREAD(IDAF,IODA,XX(LCTVEC),LENCV,269,0)
           CALL CHGTRN(CHTNRG,XX(LCTVEC),XX(LSMAT),XX(LTFRG),
     *                 XX(LTMAT),XX(LWRK),XX(LSAB),XX(LTAB),
     *                 XX(LVEFP),XX(LVABEFB),XX(LVABEFA),
     *                 XX(LVAAEFB),XX(LVBBEFA),XX(LECTFRG),
     *                 XX(LIDOIT),XX(LQUAD),MXBFEFP,MXCTMOEFP)
           CALL RETFM(NEED)
         ELSE
C          RUN ENERGY & GRADIENTS TOGETHER
           CALL VALFM(LOADFM)
           LCTVEC  = LOADFM  + 1
           LDCVEC  = LCTVEC  + MXBFEFP*NTCTMO
           LSMAT   = LDCVEC  + MXBFEFP*NTCTMO*3
           LTFRG   = LSMAT   + MXBFEFP*MXBFEFP
           LTMAT   = LTFRG   + MXCTMOEFP*MXCTMOEFP*MXDFG
           LWRK    = LTMAT   + MXBFEFP*MXBFEFP
           LSAB    = LWRK    + MXBFEFP
           LTAB    = LSAB    + MXCTMOEFP*MXCTMOEFP
           LVEFP   = LTAB    + MXCTMOEFP*MXCTMOEFP
           LVABEFB = LVEFP   + MXBFEFP*MXBFEFP
           LVABEFA = LVABEFB + MXCTMOEFP*MXCTMOEFP
           LVAAEFB = LVABEFA + MXCTMOEFP*MXCTMOEFP
           LVBBEFA = LVAAEFB + MXCTMOEFP*MXCTMOEFP
           LDSINT  = LVBBEFA + MXCTMOEFP*MXCTMOEFP
           LDTINT  = LDSINT  + MXBFEFP*MXBFEFP*6
           LDSAB   = LDTINT  + MXBFEFP*MXBFEFP*6
           LDTAB   = LDSAB   + MXCTMOEFP*MXCTMOEFP*6
           LWRK2   = LDTAB   + MXCTMOEFP*MXCTMOEFP*6
           LDABEFB = LWRK2   + MXCTMOEFP*MXCTMOEFP
           LDABEFA = LDABEFB + MXCTMOEFP*MXCTMOEFP*6
           LDAAEFB = LDABEFA + MXCTMOEFP*MXCTMOEFP*6
           LDBBEFA = LDAAEFB + MXCTMOEFP*MXCTMOEFP*6
           LDVEFP  = LDBBEFA + MXCTMOEFP*MXCTMOEFP*6
           LGCTFRG = LDVEFP  + MXBFEFP*MXBFEFP*6
           LIDOIT  = LGCTFRG + NFRG*NFRG*6
           LQUAD   = LIDOIT  + NMTTPT
           LAST    = LQUAD   + 6*NMTTPT
           NEED=LAST-LOADFM-1
           CALL GETFM(NEED)
           CALL DAREAD(IDAF,IODA,XX(LCTVEC),LENCV,269,0)
           CALL DERVEC(2,XX(LDCVEC),XX(LCTVEC),MXBFEFP,NTCTMO)
           CALL GCTANA(CHTNRG,XX(LCTVEC),XX(LSMAT),XX(LTFRG),
     *                 XX(LTMAT),XX(LWRK),XX(LSAB),XX(LTAB),
     *                 XX(LVEFP),XX(LVABEFB),XX(LVABEFA),
     *                 XX(LVAAEFB),XX(LVBBEFA),XX(LDCVEC),
     *                 XX(LDSINT),XX(LDTINT),XX(LDSAB),XX(LDTAB),
     *                 XX(LWRK2),XX(LDABEFB),XX(LDABEFA),
     *                 XX(LDAAEFB),XX(LDBBEFA),XX(LDVEFP),
     *                 XX(LGCTFRG),XX(LIDOIT),XX(LQUAD),MXBFEFP,
     *                 MXCTMOEFP)
           CALL RETFM(NEED)
         END IF
      END IF
C
C --- EFP1 GRIMME'S DISPERSION CORRECTION ---
      IF(DC) THEN
         CALL DFTD3(1,EDISD,DUMMY)
      END IF
C     -- EFP2 DYNAMIC POLARIZATION ENERGY/GRADIENTS ---
C
C DDK
C EFP2 DISPERSION NOT YET DERIVED FOR  OPEN SHELL (ROHF) METHOD
C
C CHECK TO SEE IF ANY MULTIPLICITIES ARE GREATER THAN 1
C IF SO, SKIP DISPERSION CALCULATIONS ALTOGETHER
C
C THIS SKIPS ANY DISPERSION CALCULATION BETWEEN
C CLOSED-SHELL MOLECULES AS WELL
C
      DO I=1,NFRG
       IF (MULMAT(I) .GT. 1)  GOTO 100
      END DO
      IF (NDPTTPT.GT.0) THEN
         CALL VALFM(LOADFM)
         LDYNTR = LOADFM + 1
         LAST   = LDYNTR + NFRG*MXIFRQ*MXPPT
         NEED   = LAST -LOADFM -1
         CALL GETFM(NEED)
         CALL EFPDYN(EDISD,EDISD0,XX(LDYNTR),XX(LSABSAVE),
     *        XX(LSABGRAD),MXPPT)
         CALL RETFM(NEED)
      END IF
C
 100  CONTINUE
C
C       RETURN SAB MEMORY HERE
      IF(IREP.NE.1 .AND. NTMO.GT.0) CALL RETFM(NEEDSAB)
C
C     ******************
C     -- TOTAL ENERGY --
C     ******************
C         ESNRG = CCNRG + CDNRG + CQNRG + CONRG + DDNRG + DQNRG + QQNRG
C
      E = ESNRG+REPNRG+POLNRG+EDISD+CHTNRG+DISNRG+DISNRG8
     *  + HALF*ENPCM + FACT*(GCAVP+GDISP+GREP) + EPEN
C
C
      NEVALS = NEVALS + 1
C
C     -- PRINT OUT ENERGIES --
C
C     IF EFMO, TRANSFER ENERGIES TO COMMON AND SKIP PRINTOUT
      IF(IEFMORUN.GT.0) THEN
        EFMOESERG = ESNRG
        EFMOPOLERG = POLNRG
        EFMODISERG = EDISD
        EFMOREPNRG = REPNRG
        EFMOCHTNRG = CHTNRG
        EFMOEPEN = EPEN
C        GOTO 800
        IF(IPCM.EQ.1.AND.IEFMORT.EQ.4) EFMOPCMG=ENPCM*HALF
      ENDIF
      IF(RUNTYP.EQ.MD) GOTO 800
C
C         IF YOU ASSIGN IGOFLG=2 HERE, YOU WILL GET FULL ENERGY OUTPUT
C         FOR ALL GEOMETRIES COMPUTED, GOOD FOR DEBUGGING TERM BY TERM.
C
C      IGOFLG=2
C
      IF(MASWRK  .AND.  IGOFLG.EQ.2) WRITE(IW,9010)
C
C         NOTE THAT THE TOTAL ENERGY IS INSIDE THE IGOFLG=2 PORTION
C         OF THE ELSE CLAUSE, TO SUPPRESS MONTE CARLO ENERGIES,
C         BUT THE MORE BASIC RUNS ALWAYS PRODUCE TOTAL ENERGY OUTPUT.
C
C     IF((RUNTYP.EQ.OPTIMIZ .AND. NSERCH.NE.0) .OR.
      IF(
     *   (RUNTYP.EQ.SADPT   .AND. NSERCH.NE.0) .OR.
     *   (RUNTYP.EQ.AIRC)                      .OR.
     *   (RUNTYP.EQ.HSSIAN)) THEN
         IF(MASWRK  .AND.  IGOFLG.EQ.2) THEN
            WRITE(IW,9090) ESNRG
            WRITE(IW,9100) REPNRG
            WRITE(IW,9110) POLNRG
            IF(IEFDP.EQ.1) WRITE(IW,9111) EDISD
C --- EFP1 GRIMME'S DISPERSION CORRECTION ---
            IF(IEFDP.NE.1 .AND. DC) WRITE(IW,9310) EDISD
            IF(NTCTMO.GT.0) WRITE(IW,9112) CHTNRG
            IF(MP2TYP.EQ.1) THEN
              WRITE(IW,9130) DISNRG
              WRITE(IW,9140) DISNRG8
            END IF
            WRITE(IW,9210)
         END IF
         IF(MASWRK) THEN
           IF(IPCM.EQ.1) THEN
              WRITE(IW,9300) E
           ELSE
              WRITE(IW,9200) E
           END IF
         END IF
         IGOFLG=1
      ELSE
         IF(MASWRK.AND.  IGOFLG.EQ.2) THEN
            WRITE(IW,9020) CCNRG
            WRITE(IW,9030) CDNRG
            WRITE(IW,9040) CQNRG
            WRITE(IW,9050) CONRG
            WRITE(IW,9060) DDNRG
            WRITE(IW,9070) DQNRG
            WRITE(IW,9080) QQNRG
            WRITE(IW,9089) EPEN
           WRITE(IW,9220)
C            WRITE(IW,9090) ESNRG
            WRITE(IW,9090) ESNRG+EPEN
            WRITE(IW,9100) REPNRG
            WRITE(IW,9110) POLNRG
            IF(IEFDP.EQ.1) WRITE(IW,9111) EDISD
C --- EFP1 GRIMME'S DISPERSION CORRECTION ---
            IF(IEFDP.NE.1 .AND. DC) WRITE(IW,9310) EDISD
C            IF(IEFDP.EQ.1) WRITE(IW,9113) EDISD0
            IF(NTCTMO.GT.0) WRITE(IW,9112) CHTNRG
            IF(MP2TYP.EQ.1) THEN
              WRITE(IW,9130) DISNRG
              WRITE(IW,9140) DISNRG8
            END IF
            WRITE(IW,9210)
            IF(IPCM.EQ.1) THEN
               WRITE(IW,9300) E
            ELSE
               WRITE(IW,9200) E
            END IF
         END IF
C        IGOFLG=1
         WRITE(IW,*)
         CALL EFDIPOLE
         WRITE(IW,*)
      END IF
C
 800  CONTINUE
C
      RETURN
C
 9010 FORMAT(/17X,38('-')/
     *       17X,'FRAGMENT-FRAGMENT INTERACTION ENERGIES'/
     *       17X,38('-')/)
 9020 FORMAT(17X,'CHARGE-CHARGE         = ',F14.10)
 9030 FORMAT(17X,'CHARGE-DIPOLE         = ',F14.10)
 9040 FORMAT(17X,'CHARGE-QUADRUPOLE     = ',F14.10)
 9050 FORMAT(17X,'CHARGE-OCTUPOLE       = ',F14.10)
 9060 FORMAT(17X,'DIPOLE-DIPOLE         = ',F14.10)
 9070 FORMAT(17X,'DIPOLE-QUADRUPOLE     = ',F14.10)
 9080 FORMAT(17X,'QUADRUPOLE-QUADRUPOLE = ',F14.10)
 9089 FORMAT(17X,'OVERLAP PEN. ENERGY   = ',F14.10)
 9090 FORMAT(17X,'ELECTROSTATIC ENERGY  = ',F14.10)
C 9091 FORMAT(17X,'ELECTR + PEN ENERGY   = ',F14.10)
 9100 FORMAT(17X,'REPULSION ENERGY      = ',F14.10)
 9110 FORMAT(17X,'POLARIZATION ENERGY   = ',F14.10)
 9111 FORMAT(17X,'DISPERSION ENERGY     = ',F14.10)
C 9113 FORMAT(17X,'DISPERSION ZERO ENERGY= ',F14.10)
 9112 FORMAT(17X,'CHARGE TRANSFER ENRGY = ',F14.10)
 9130 FORMAT(17X,'C6 DISPERSION ENERGY  = ',F14.10)
 9140 FORMAT(17X,'C8 DISPERSION ENERGY  = ',F14.10)
 9200 FORMAT(17X,'FINAL EFP ENERGY      = ',F14.10)
 9210 FORMAT(17X,38('-'))
 9220 FORMAT(41X,14('-'))
 9300 FORMAT(17X,'FINAL EFPPCM ENERGY   = ',F14.10)
 9310 FORMAT(17X,'GRIMME''S DISP. ENERGY = ',F14.10)
C
      END
C*MODULE EFDRVR  *DECK EFPPOL
      SUBROUTINE EFPPOL(EFLD,EFADD,POLNRG)
C
C --------------------------------------------------------------
C --- THIS ROUTINE CALCULATES FRAGMENT-FRAGMENT POLARIZATION ---
C ---   ENERGIES IN THE ABSENCE OF AN AB INITO MOLECULE      ---
C --------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXFRG=1050, MXFGPT=12000, MXIFRQ=12,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (ZERO=0.0D+00, DEBYE=2.541766D+00)
C
      CHARACTER*8 POLNAM,DPOLNAM
C
      LOGICAL MINMEM
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL IFEWLD,TNFOIL,EWLDPL,DEBUGOPT
C
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ*MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,
     *                EFMOREPNRG,EFMOCHTNRG,EFMOEPEN,EFMOPCMG,
     *                IEFMORUN,IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,
     *                IEFMODIM(2),IMODEFE,NATEFMO,IMODEFD,IMODEFER,
     *                IMODEFCT,IDIMTYP
      COMMON /FMCOM/  XX(1)
      COMMON /FRFD  / PPEFX(MXFGPT), PPEFY(MXFGPT), PPEFZ(MXFGPT)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INDDIP/ TMUX,TMUY,TMUZ,TMUXD,TMUYD,TMUZD,MINMEM
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SIMDAT/ NACC,NREJ,IGOMIN,NRPA,IBWM,NACCT,NREJT,NRPAT,
     *                NPRTGO,IDPUNC,IGOFLG
      COMMON /EWALD / IFEWLD,TNFOIL,BETA,ELCNST,EPSLN,CUTOFF,CUTLST,
     *                KMAX,NKVEC,LEVEL,EWLDPL
      COMMON /EWFLD / RCPFLD(3,MXFGPT),RCPIIFLD1(3,MXFGPT),
     *                RCPIIFLD2(3,MXFGPT), TNFLD(3),
     *                TNIIFLD1(3),TNIIFLD2(3),
     *                SELFFLD1(3,MXFGPT),SELFFLD2(3,MXFGPT),
     *                EXCLFLD(3,MXFGPT),
     *                EXCLIIFLD1(3,MXFGPT),EXCLIIFLD2(3,MXFGPT)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /EFPAR / LOCNFG,NLOW,NUP
C
      DIMENSION EFLD(3,NPTTPT),EFADD(3,NPTTPT)
C
      DATA ENERGY  /8HENERGY  /,GRADIENT/8HGRADIENT/
C
C     BE VERY CAREFUL ABOUT THE DATA UNDER COMMON FRFD, INDDIP,
C     AND EFPPAR (DIND AND DINDD), SINCE THEY ARE WRITTEN WHEN EPOL
C     IS CALCULATED!!!
C
      CALL FRGFLD
      IF (IFEWLD .AND. EWLDPL) THEN
C   ----  DEBUG: CALCULATES STATIC FIELD EXPLICITELY
         DEBUGOPT=.FALSE.
         IF (DEBUGOPT) CALL DIRECTSUM_POL
C   ---- TINFOIL CONTRIBUTION TO THE FIELD IS CALCULATED IN TNFOIL,
C   ---- TOGETHER WITH ELECTROSTATIC TINFOIL ENERGIES
C   ---- EXCLUSION CONTRIBUTION IS CALCULATED IN EXCL_FIELD AND CALLED
C   ---- ONCE IN EWALDX
C   ---- SELF CONTRIBUTION TO THE FIELD IS 0
C   ---- DIRECT CONTRIBUTION WAS CALCULATED IN FRGFLD
C
C      WRITE(6,*)'FRGFLD1 ',PPEFX(1),PPEFY(1),PPEFZ(1)
C      WRITE(6,*)'FRGFLD2 ',PPEFX(2),PPEFY(2),PPEFZ(2)
C      WRITE(6,*)'FRGFLD3 ',PPEFX(3),PPEFY(3),PPEFZ(3)
C
         CALL RECIPR_FIELD
      END IF
      DO LEFP = 1, NPTTPT
         EFLD(1,LEFP) = PPEFX(LEFP)
         EFLD(2,LEFP) = PPEFY(LEFP)
         EFLD(3,LEFP) = PPEFZ(LEFP)
         IF (IFEWLD .AND. EWLDPL) THEN
            DO I=1,3
               EFLD(I,LEFP) = EFLD(I,LEFP)+RCPFLD(I,LEFP)
     *                      +TNFLD(I)
     *                      +EXCLFLD(I,LEFP)
            END DO
C
C   ---- DIRTY THINGS
            PPEFX(LEFP) = EFLD(1,LEFP)
            PPEFY(LEFP) = EFLD(2,LEFP)
            PPEFZ(LEFP) = EFLD(3,LEFP)
         END IF
      ENDDO
C
C      WRITE(6,*)'TOTAL STATIC FIELD ',(EFLD(I,1),I=1,3),
C     *           (EFLD(I,2),I=1,3),(EFLD(I,3),I=1,3)
C
      CALL VALFM(LOADFM)
      LDIPNEW  = LOADFM   + 1
      LDIPNWD  = LDIPNEW  + NFRG
      LDINDC   = LDIPNWD  + NFRG
      LDINDDC  = LDINDC   + 3*NPTTPT
      LDIND_W  = LDINDDC  + 3*NPTTPT
      LDIND_C  = LDIND_W  + 6*NPTTPT
      LEWLD1   = LDIND_C  + 6*NPTTPT
      LEWLD2   = LEWLD1   + 3*NPTTPT
      LAST     = LEWLD2   + 3*NPTTPT
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
      CALL DIPIT(EFLD,EFADD,XX(LDINDC),XX(LDINDDC),
     *           XX(LDIND_W),XX(LDIND_C),
     *           NPTTPT,XX(LDIPNEW),XX(LDIPNWD),
     *           XX(LEWLD1),XX(LEWLD2),NFRG)
      CALL RETFM(NEED)
      IF(IDPUNC.EQ.1) RETURN
C
C     --- CALCULATE POLARIZATION ENERGY ---
C
      IUP=0
      DO I=1,NUP
         IUP = IUP + NPPTS(I)
      ENDDO
      ILOW=1
      DO I=1,NLOW-1
         ILOW = ILOW + NPPTS(I)
      ENDDO
      POLNRG = ZERO
      DO II=ILOW,IUP
         POLNRG = POLNRG + DIND(1,II)*PPEFX(II)
     *                   + DIND(2,II)*PPEFY(II)
     *                   + DIND(3,II)*PPEFZ(II)
      ENDDO
      POLNRG = -0.5D+00*POLNRG
      IF(GOPARR) CALL DDI_GSUMF(677,POLNRG,1)
C
C     --- GRAND INDUCED DIPOLE ---
C
      IF( IEFMORUN.GT.0 .AND. IEFMORT.NE.4 ) GOTO 800
      IF (RUNTYP.EQ.ENERGY .OR. RUNTYP.EQ.GRADIENT) THEN
         TMUX = ZERO
         TMUY = ZERO
         TMUZ = ZERO
         DO LEFP=1, NPTTPT
           TMUX = TMUX + DIND(1,LEFP)
           TMUY = TMUY + DIND(2,LEFP)
           TMUZ = TMUZ + DIND(3,LEFP)
         ENDDO
         TMUXD = TMUX*DEBYE
         TMUYD = TMUY*DEBYE
         TMUZD = TMUZ*DEBYE
         IF(MASWRK)
     *   WRITE(IW,9000) TMUX, TMUXD, TMUY, TMUYD, TMUZ, TMUZD
      ENDIF
C
  800 CONTINUE
C
      RETURN
C
 9000 FORMAT(/,17X,'INDUCED DIPOLE',4X,'ATOMIC UNITS',3X,'DEBYE'/
     *       17X,14('-'),4X,12('-'),3X,5('-')/
     *       21X,'X(IND)',9X,F8.5,3X,F8.5/
     *       21X,'Y(IND)',9X,F8.5,3X,F8.5/
     *       21X,'Z(IND)',9X,F8.5,3X,F8.5)
C
      END
C
C*MODULE EFDRVR  *DECK EFGRAD
C>
C> @brief   compute gradient for EFP-only runs
C>
C> @details compute gradient when only EFP particles are present,
C>          possibly enclosed in a PCM layer.
C>
C> @author  perhaps Paul Day
C>
C
      SUBROUTINE EFGRAD
C
C ---------------------------------------------------------------
C --- THIS ROUTINE CALCULATES THE GRADIENT ASSOCIATED WITH    ---
C --- A FRAGMENT ONLY RUN, I.E., FRAGMENTS IN THE ABSENCE OF  ---
C ---                  AN AB INITIO MOLECULE                  ---
C ---------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (ONE=1.0D+00)
      PARAMETER (MXATM=2000, MXSHEF=1000, MXGEFP=4000,
     *           MXPT=2000, MXFRG=1050, MXFGPT=12000,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      LOGICAL PROJGRAD,PBC
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION MD
C
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,
     *                EFMOREPNRG,EFMOCHTNRG,EFMOEPEN,EFMOPCMG,
     *                IEFMORUN,IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,
     *                IEFMODIM(2),IMODEFE,NATEFMO,IMODEFD,IMODEFER,
     *                IMODEFCT,IDIMTYP
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NATEF(MXDFG),NUMEF(MXDFG),NTPATM
      COMMON /EFPPBC/ XBOX,YBOX,ZBOX,XCUT,YCUT,ZCUT,RCUT,
     *                SWR1,SWR2,ISWF
      COMMON /FMCOM / X(1)
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IKREP,IEF,IP_F,NFMOPCM
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /EFPMP2/ MP2TYP
C
      DATA MD/8HMD      /
C
      IF( IEFMORUN.GT.0 ) RETURN
C
C          NUMERICAL GRADIENT IS DONE ELSEWHERE...
C
      IF(NGLEVL.NE.0) THEN
         CALL NUMGRDX
         RETURN
      END IF
C
C          THE REST OF THIS ROUTINE DRIVES ANALYTICAL GRADIENTS.
C
      IF(MP2TYP.EQ.1) THEN
        NFRPTS=NMTTPT+NPTTPT+NRTTPT+NTPATM+NTMO+NDTTPT
      ELSE
        NFRPTS=NMTTPT+NPTTPT+NRTTPT+NTPATM+NTMO
      END IF
C
      CALL VALFM(LOADFM)
      LEF3    = LOADFM  + 1
      LWORK   = LEF3    + MAX(1,3*NFRPTS)
      LATORQN = LWORK   + MAX(1,10*NMTTPT)
      LAST    = LATORQN + MAX(1,3*NFRG)
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      CALL VCLR(DEF,1,3*MXFGPT)
      CALL VCLR(ATORQ,1,3*NFRG)
      CALL EFPDERCOM(DEF,X(LEF3),NFRPTS,X(LWORK),X(LATORQN))
C     (NEXT CALL WAS PULLED OUT OF OLD COLLECTIVE VNNDER+EFP ROUTINE)
      IF(GOPARR) CALL DSCAL(3*NAT,ONE/NPROC,DEF,1)
      CALL EFFT
C
C       AS A BAND-AID, PROJECT RESIDUAL TORQUE/DRIFT FROM THE GRADIENT.
C       THIS EXISTS WHEN USING A FINITE PCM GRID FOR EFP+PCM,
C       AND SEEMINGLY WHEN PERIODIC BOUNDARY CONDITIONS EXIST.
C       THE THINKING IS THAT MD RUNS ARE SUPPOSED TO CONSERVE ENERGY,
C       SO THEY SHOULD AVOID ANY MANIPULATION OF THE GRADIENT HERE.
C
C       NOTE THAT NAT=0, SO THERE IS A DUMMY QM GRADIENT VECTOR,
C       WITH NO QM COORDINATES OR QM NUCLEAR MASSES.
C
      PBC = (XBOX+YBOX+ZBOX) .GT. 0.0D+00
      PROJGRAD = (IPCM.EQ.1 .OR.  PBC)  .AND. RUNTYP.NE.MD
      IF(PROJGRAD) THEN
         NCCF = 3*NAT + 6*NFRG
         CALL VALFM(LOADFM)
         LGTOT  = LOADFM + 1
         LRM    = LGTOT  + 3*NAT +  6*NFRG
         LX     = LRM    + 3*NAT + 21*NFRG
         LP     = LX     + 3*NAT +  6*NFRG
         LAST   = LP     + 3*NAT +  6*NFRG
         NEEDP  = LAST-LOADFM-1
         CALL GETFM(NEEDP)
         DUMMY =0.0D+00
         DUMMYC=0.0D+00
         DUMMYZ=0.0D+00
C---     CALL RAMS(X(LRM),1)
         CALL PRJGRD(DUMMY,DUMMYC,X(LX),X(LGTOT),X(LRM),X(LP),DUMMYZ,
     *               NAT,NAT*3,NCCF,.FALSE.)
         CALL RETFM(NEEDP)
      END IF
C
      CALL RETFM(NEED)
      RETURN
      END
C
C*MODULE EFDRVR  *DECK EFPDYN
      SUBROUTINE EFPDYN(EDISC8,EDISC80,DYNTR,SABSAVE,SABGRAD,MXPPTS)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXFRG=1050, MXIFRQ=12, MXFGPT=12000,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      PARAMETER (ZERO=0.0D+00)
      PARAMETER (THREE=3.0D+00, FOUR=4.0D+00, ONE=1.0D+00, TWO=2.0D+00)
      PARAMETER (SIX=6.0D+00)
C      PARAMETER (B=1.5D+00)
      PARAMETER (FACT1= 0.72086099022968040154D-02)
      PARAMETER (FACT2= 0.17697067815034886394D-01)
      PARAMETER (FACT3= 0.30660908596251749739D-01)
      PARAMETER (FACT4= 0.48381293256249884995D-01)
      PARAMETER (FACT5= 0.74878830420650517080D-01)
      PARAMETER (FACT6= 0.11806515901361630228D+00)
      PARAMETER (FACT7= 0.19535413832209084204D+00)
      PARAMETER (FACT8= 0.35055692324483221824D+00)
      PARAMETER (FACT9= 0.71577113554429568336D+00)
      PARAMETER (FACT10=1.81409759976323969729D+00)
      PARAMETER (FACT11=6.97923445114870823247D+00)
      PARAMETER (FACT12=83.2480938829658453917D+00)
C
      CHARACTER*8 POLNAM,DPOLNAM,FRCNME
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL IFRCPNT
C
      COMMON /EFPAR / LOCNFG,NLOW,NUP
      COMMON /EFPFRC/ IFRCPNT,NTFRCPN,NFRCPNT(MXFRG),LSTFPTS(MXFRG),
     *                FRCCRD(3,MXFGPT),FRCNME(MXFGPT),FRCTRQ(6,MXFGPT)
     *                ,FRCTRQX(6,MXFGPT)
      COMMON /EFPPBC/ XBOX,YBOX,ZBOX,XCUT,YCUT,ZCUT,RCUT,
     *                SWR1,SWR2,ISWF
      COMMON /EFPGES/ DESFRG(6,MXFRG)
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ*MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /EFPSCR/ POLAB(MXFRG),B,SCROFF,IELECS,IDISPS,NEW_POL
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DIMENSION  DYNTR(MXIFRQ*MXPPTS,NFRG),
     *           SABSAVE(NFRG,NFRG,MXPPTS,MXPPTS),
     *           SABGRAD(NFRG,NFRG,MXPPTS,MXPPTS,6),DSAB(6),
     *           IFP1(10),IFP2(10)
C
C
C     ------------------------------------------------------------------
C        THIS ROUTINE CALCULATES FRAGMENT-FRAGMENT DISPERSION (EFP2)
C        ENERGY AND GRADIENTS IN THE ABSENCE OF AN AB INITO MOLECULE
C     ------------------------------------------------------------------
C
      EDISC8 = ZERO
      EDISD  = ZERO
      EDISC80  = ZERO
      EDISD0  = ZERO
      CALL VCLR(DSAB,1,6)
C
C     -- TRACE OF DYNAMIC ALPHA IN THE FORM ALPHA(NDPPTS,NFRG) ---
C
      ID=0
      DO I=1,NFRG
        DO J=1,NDPPTS(I)
           ID=ID+1
           DYNTR(J,I) = (ONE/THREE)*(EFDPOL(1,ID) + EFDPOL(2,ID) +
     *                   EFDPOL(3,ID))
        ENDDO
      ENDDO
C
      ID1=0
      IF (GOPARR) THEN
         DO I=1,NLOW-1
            ID1 = ID1 + NPPTS(I)
         ENDDO
      ENDIF
C
      DO 280 IM = NLOW,NUP
         INPPTS=NPPTS(IM)
         COMX1 = EFCENT(1,IM)
         COMY1 = EFCENT(2,IM)
         COMZ1 = EFCENT(3,IM)
         DO 270 IN=1,NPPTS(IM)
            ID1=ID1+1
            ALP1=DYNTR(IN,IM)
            ALP2=DYNTR(IN+INPPTS,IM)
            ALP3=DYNTR(IN+2*INPPTS,IM)
            ALP4=DYNTR(IN+3*INPPTS,IM)
            ALP5=DYNTR(IN+4*INPPTS,IM)
            ALP6=DYNTR(IN+5*INPPTS,IM)
            ALP7=DYNTR(IN+6*INPPTS,IM)
            ALP8=DYNTR(IN+7*INPPTS,IM)
            ALP9=DYNTR(IN+8*INPPTS,IM)
            ALP10=DYNTR(IN+9*INPPTS,IM)
            ALP11=DYNTR(IN+10*INPPTS,IM)
            ALP12=DYNTR(IN+11*INPPTS,IM)
            X1 = EFP(1,ID1)
            Y1 = EFP(2,ID1)
            Z1 = EFP(3,ID1)
C                IF FORCE POINTS ARE ACTIVE
            IF(IFRCPNT) THEN
               CALL NEARFP(IM,X1,Y1,Z1,IFP1,IFP1_COM,NEQUAL1)
            ENDIF
C
            ID2=0
            DO 260 JM = 1,NFRG
               IF (IM.GE.JM)THEN
                 ID2=ID2+NPPTS(JM)
                 GO TO 260
               END IF
C
               COMX2 = EFCENT(1,JM)
               COMY2 = EFCENT(2,JM)
               COMZ2 = EFCENT(3,JM)
               COMX = COMX1 - COMX2
               COMY = COMY1 - COMY2
               COMZ = COMZ1 - COMZ2
               PBCX = ZERO
               PBCY = ZERO
               PBCZ = ZERO
               IF (XBOX .NE. ZERO) PBCX = XBOX * ANINT(COMX/XBOX)
               IF (YBOX .NE. ZERO) PBCY = YBOX * ANINT(COMY/YBOX)
               IF (ZBOX .NE. ZERO) PBCZ = ZBOX * ANINT(COMZ/ZBOX)
C
C   ----  DISTANCE BETWEEN FRAGMENTS
               X12  = ABS(COMX - PBCX)
               Y12  = ABS(COMY - PBCY)
               Z12  = ABS(COMZ - PBCZ)
               R12  = X12*X12+Y12*Y12+Z12*Z12
C
               SWF   = 1.0D+00
               SWFDX = 0.0D+00
               SWFDY = 0.0D+00
               SWFDZ = 0.0D+00
C
               IF(X12.GT.XCUT.OR.Y12.GT.YCUT.OR.Z12.GT.ZCUT)THEN
                 ID2=ID2+NPPTS(JM)
                 GOTO 260
               END IF
               R12  = X12*X12+Y12*Y12+Z12*Z12
               IF(R12.GT.RCUT)THEN
                 ID2=ID2+NPPTS(JM)
                 GOTO 260
               END IF
C
               IF(R12.GT.SWR2*SWR2) THEN
                 ID2=ID2+NPPTS(JM)
                 GOTO 260
               ELSE IF(R12.GT.SWR1*SWR1) THEN
                 IF(ISWF.EQ.1) THEN
                    DUMY1 = 1.0D+00/(SWR2*SWR2 - SWR1*SWR1)
                    DUMY2 = DUMY1*DUMY1
                    DUMY3 = DUMY2*DUMY1
                    DUMY4 = DUMY2*DUMY2
                    DUMY5 = DUMY2*DUMY3
                    VUMY1 = R12 - SWR1*SWR1
                    VUMY2 = VUMY1*VUMY1
                    VUMY3 = VUMY2*VUMY1
                    VUMY4 = VUMY2*VUMY2
                    VUMY5 = VUMY2*VUMY3
                    DSWF  = -30.0D+00*DUMY3*VUMY2
     *                      +60.0D+00*DUMY4*VUMY3
     *                      -30.0D+00*DUMY5*VUMY4
                    DSWF  = 2.0D+00*DSWF
                    SWF   = 1.0D+00 - 10.0D+00*DUMY3*VUMY3
     *                              + 15.0D+00*DUMY4*VUMY4
     *                              -  6.0D+00*DUMY5*VUMY5
                    SWFDX = DSWF*(EFCENT(1,IM)-EFCENT(1,JM)-PBCX)
                    SWFDY = DSWF*(EFCENT(2,IM)-EFCENT(2,JM)-PBCY)
                    SWFDZ = DSWF*(EFCENT(3,IM)-EFCENT(3,JM)-PBCZ)
                 ELSE IF(ISWF.EQ.2) THEN
                    R12   = SQRT(R12)
                    PIL   = 3.1415926535897932D+00/(SWR2-SWR1)
                    DUMY  = (R12 - SWR1) * PIL
                    SWF   = 0.50D+00 * (COS(DUMY) + 1.0D+00)
                    DUMY2 =-0.50D+00 * SIN(DUMY) * PIL / R12
                    SWFDX = DUMY2*(EFCENT(1,IM)-EFCENT(1,JM)-PBCX)
                    SWFDY = DUMY2*(EFCENT(2,IM)-EFCENT(2,JM)-PBCY)
                    SWFDZ = DUMY2*(EFCENT(3,IM)-EFCENT(3,JM)-PBCZ)
                 END IF
               END IF
C
               JNPPTS=NPPTS(JM)
               DO 250 JP = 1,NPPTS(JM)
                  ID2=ID2+1
                  ALPN1=DYNTR(JP,JM)
                  ALPN2=DYNTR(JP+JNPPTS,JM)
                  ALPN3=DYNTR(JP+2*JNPPTS,JM)
                  ALPN4=DYNTR(JP+3*JNPPTS,JM)
                  ALPN5=DYNTR(JP+4*JNPPTS,JM)
                  ALPN6=DYNTR(JP+5*JNPPTS,JM)
                  ALPN7=DYNTR(JP+6*JNPPTS,JM)
                  ALPN8=DYNTR(JP+7*JNPPTS,JM)
                  ALPN9=DYNTR(JP+8*JNPPTS,JM)
                  ALPN10=DYNTR(JP+9*JNPPTS,JM)
                  ALPN11=DYNTR(JP+10*JNPPTS,JM)
                  ALPN12=DYNTR(JP+11*JNPPTS,JM)
C
                  X2 = EFP(1,ID2)
                  Y2 = EFP(2,ID2)
                  Z2 = EFP(3,ID2)
C                   IF FORCE POINTS ARE ACTIVE
                  IF(IFRCPNT) THEN
                    CALL NEARFP(JM,X2,Y2,Z2,IFP2,IFP2_COM,NEQUAL2)
                  ENDIF
C
                  X = X1 - X2
                  Y = Y1 - Y2
                  Z = Z1 - Z2
                  X = X - PBCX
                  Y = Y - PBCY
                  Z = Z - PBCZ
C
                  R2 = X*X + Y*Y + Z*Z
                  R = SQRT(R2)
                  R4 = R2*R2
                  R6 = R4*R2
C
                  F6 = ONE
                  IF (IDISPS .EQ. 1) THEN
C                    THE OVERLAP BASED DAMPING FOR DISPERSION
                     SAB = SABSAVE(IM,JM,IN,JP)
                     IF (ABS(SAB) .GT. 1.0D-05) THEN
                        DO ICRD = 1,6
                            DSAB(ICRD) = SABGRAD(IM,JM,IN,JP,ICRD)
                        END DO
                        RB = -2.0D+00*LOG(ABS(SAB))
                        EX1 = SAB*SAB
                        RB2 = RB*RB
                        F6 = ONE-(EX1*(ONE + RB + RB2/TWO ))
                     ELSE
                        F6 = ONE
                        RB = ZERO
                        SAB = ZERO
                        DO ICRD = 1,6
                            DSAB(ICRD) = ZERO
                        END DO
                     END IF
                  ELSE
C                 - F6 IS DAMPING FUNCTION FOR DISPERSION BASED ON
C                   TANG AND TOENNIES FORMULA
                     RB =  B*R
                     EX1 = EXP(-RB)
                     RB2 = RB*RB
                     RB3 = RB*RB2
                     RB4 = RB2*RB2
                     RB5 = RB*RB4
                     RB6 = RB*RB5
C
                     F6 = ONE-(EX1*(ONE + RB + RB2/TWO +
     *                           RB3/SIX + RB4/24.0D+00 +
     *                           RB5/120.0D+00 +RB6/720.0D+00))
                  END IF
C
                  C6=
     *             + FACT1*ALP1*ALPN1
     *             + FACT2*ALP2*ALPN2
     *             + FACT3*ALP3*ALPN3
     *             + FACT4*ALP4*ALPN4
     *             + FACT5*ALP5*ALPN5
     *             + FACT6*ALP6*ALPN6
     *             + FACT7*ALP7*ALPN7
     *             + FACT8*ALP8*ALPN8
     *             + FACT9*ALP9*ALPN9
     *             + FACT10*ALP10*ALPN10
     *             + FACT11*ALP11*ALPN11
     *             + FACT12*ALP12*ALPN12
C
C                 - EDISD IS DAMPED DISPERSION ENERGY
C
                  EPAIR = - F6*C6/R6
                  EPAIR0 = - C6/R6
                  EDISD = EDISD + SWF*EPAIR
                  EDISD0 = EDISD0 + SWF*EPAIR0
                  EPAIR=EPAIR*FOUR/THREE
                  EPAIR0=EPAIR0*FOUR/THREE
C
C                 - GRADIENT OF THE DISPERSION ENERGY
C                 DE/DR=FOUR/THREE*(-6*C6*F6/R**7 + DF6/DR * C6/R**6)
C
                  IF (IDISPS .EQ. 1) THEN
                     CON1=-(FOUR/THREE)*(C6/R6)*(SIX*F6/R2)
                     CON2=-(FOUR/THREE)*(C6/R6)*(RB2*SAB)
                  ELSE
                     CON1=-(FOUR/THREE)*(C6/R6)*
     *                     ((SIX*F6/R2)-(B*RB6*EX1)/(R*720.0D+00))
                     CON2 = ZERO
                  END IF
C
                  CONX=CON1*X
                  CONY=CON1*Y
                  CONZ=CON1*Z
C
C
                  DESFRG(1,JM) = DESFRG(1,JM) - EPAIR*SWFDX
                  DESFRG(2,JM) = DESFRG(2,JM) - EPAIR*SWFDY
                  DESFRG(3,JM) = DESFRG(3,JM) - EPAIR*SWFDZ
                  DESFRG(1,IM) = DESFRG(1,IM) + EPAIR*SWFDX
                  DESFRG(2,IM) = DESFRG(2,IM) + EPAIR*SWFDY
                  DESFRG(3,IM) = DESFRG(3,IM) + EPAIR*SWFDZ
C
                  DESFRG(1,JM) = DESFRG(1,JM) + SWF*(CONX+CON2*DSAB(1))
                  DESFRG(2,JM) = DESFRG(2,JM) + SWF*(CONY+CON2*DSAB(2))
                  DESFRG(3,JM) = DESFRG(3,JM) + SWF*(CONZ+CON2*DSAB(3))
                  DESFRG(4,JM) = DESFRG(4,JM) + SWF*
     *                      (CONZ*(EFP(2,ID2)-EFCENT(2,JM))
     *                      -CONY*(EFP(3,ID2)-EFCENT(3,JM))
     *                      -CON2*DSAB(4)
     *                      +CON2*DSAB(3)*(COMY - PBCY)
     *                      -CON2*DSAB(2)*(COMZ - PBCZ))
                  DESFRG(5,JM) = DESFRG(5,JM) + SWF*
     *                      (CONX*(EFP(3,ID2)-EFCENT(3,JM))
     *                      -CONZ*(EFP(1,ID2)-EFCENT(1,JM))
     *                      -CON2*DSAB(5)
     *                      +CON2*DSAB(1)*(COMZ - PBCZ)
     *                      -CON2*DSAB(3)*(COMX - PBCX))
                  DESFRG(6,JM) = DESFRG(6,JM) + SWF*
     *                      (CONY*(EFP(1,ID2)-EFCENT(1,JM))
     *                      -CONX*(EFP(2,ID2)-EFCENT(2,JM))
     *                      -CON2*DSAB(6)
     *                      +CON2*DSAB(2)*(COMX - PBCX)
     *                      -CON2*DSAB(1)*(COMY - PBCY))
                  DESFRG(1,IM) = DESFRG(1,IM) - SWF*(CONX+CON2*DSAB(1))
                  DESFRG(2,IM) = DESFRG(2,IM) - SWF*(CONY+CON2*DSAB(2))
                  DESFRG(3,IM) = DESFRG(3,IM) - SWF*(CONZ+CON2*DSAB(3))
                  DESFRG(4,IM) = DESFRG(4,IM) - SWF*
     *                      (CONZ*(EFP(2,ID1)-EFCENT(2,IM))
     *                      -CONY*(EFP(3,ID1)-EFCENT(3,IM))
     *                      -CON2*DSAB(4))
                  DESFRG(5,IM) = DESFRG(5,IM) - SWF*
     *                      (CONX*(EFP(3,ID1)-EFCENT(3,IM))
     *                      -CONZ*(EFP(1,ID1)-EFCENT(1,IM))
     *                      -CON2*DSAB(5))
                  DESFRG(6,IM) = DESFRG(6,IM) - SWF*
     *                      (CONY*(EFP(1,ID1)-EFCENT(1,IM))
     *                      -CONX*(EFP(2,ID1)-EFCENT(2,IM))
     *                      -CON2*DSAB(6))
C
C  ---- GATHER GRADS AND TORQUES IN FORCE POINTS
             IF(IFRCPNT) THEN
                  FRCTRQ(1,IFP2_COM) = FRCTRQ(1,IFP2_COM)-EPAIR*SWFDX
                  FRCTRQ(2,IFP2_COM) = FRCTRQ(2,IFP2_COM)-EPAIR*SWFDY
                  FRCTRQ(3,IFP2_COM) = FRCTRQ(3,IFP2_COM)-EPAIR*SWFDZ
                  FRCTRQ(1,IFP1_COM) = FRCTRQ(1,IFP1_COM)+EPAIR*SWFDX
                  FRCTRQ(2,IFP1_COM) = FRCTRQ(2,IFP1_COM)+EPAIR*SWFDY
                  FRCTRQ(3,IFP1_COM) = FRCTRQ(3,IFP1_COM)+EPAIR*SWFDZ
C
                  DO I=1,NEQUAL2
                  IFP = IFP2(I)
                  COEF=ONE/NEQUAL2
                  FRCTRQ(1,IFP) = FRCTRQ(1,IFP)+
     *                            SWF*(CONX+CON2*DSAB(1))*COEF
                  FRCTRQ(2,IFP) = FRCTRQ(2,IFP)+
     *                            SWF*(CONY+CON2*DSAB(2))*COEF
                  FRCTRQ(3,IFP) = FRCTRQ(3,IFP)+
     *                            SWF*(CONZ+CON2*DSAB(3))*COEF
                  FRCTRQ(4,IFP) = FRCTRQ(4,IFP)+SWF*COEF*
     *                      (CONZ*(EFP(2,ID2)-FRCCRD(2,IFP))
     *                      -CONY*(EFP(3,ID2)-FRCCRD(3,IFP))
     *                      -CON2*DSAB(4)
     *                      +CON2*DSAB(3)*(COMY - PBCY)
     *                      -CON2*DSAB(2)*(COMZ - PBCZ))
                  FRCTRQ(5,IFP) = FRCTRQ(5,IFP)+SWF*COEF*
     *                      (CONX*(EFP(3,ID2)-FRCCRD(3,IFP))-
     *                       CONZ*(EFP(1,ID2)-FRCCRD(1,IFP))
     *                      -CON2*DSAB(5)
     *                      +CON2*DSAB(1)*(COMZ - PBCZ)
     *                      -CON2*DSAB(3)*(COMX - PBCX))
                  FRCTRQ(6,IFP) = FRCTRQ(6,IFP)+SWF*COEF*
     *                      (CONY*(EFP(1,ID2)-FRCCRD(1,IFP))
     *                      -CONX*(EFP(2,ID2)-FRCCRD(2,IFP))
     *                      -CON2*DSAB(6)
     *                      +CON2*DSAB(2)*(COMX - PBCX)
     *                      -CON2*DSAB(1)*(COMY - PBCY))
                END DO
                  DO I=1,NEQUAL1
                  IFP = IFP1(I)
                  COEF=ONE/NEQUAL1
                  FRCTRQ(1,IFP) = FRCTRQ(1,IFP)-
     *                            SWF*(CONX+CON2*DSAB(1))*COEF
                  FRCTRQ(2,IFP) = FRCTRQ(2,IFP)-
     *                            SWF*(CONY+CON2*DSAB(2))*COEF
                  FRCTRQ(3,IFP) = FRCTRQ(3,IFP)-
     *                            SWF*(CONZ+CON2*DSAB(3))*COEF
                  FRCTRQ(4,IFP) = FRCTRQ(4,IFP) - SWF*COEF*
     *                      (CONZ*(EFP(2,ID1)-FRCCRD(2,IFP))
     *                      -CONY*(EFP(3,ID1)-FRCCRD(3,IFP))
     *                      -CON2*DSAB(4))
                  FRCTRQ(5,IFP) = FRCTRQ(5,IFP) - SWF*COEF*
     *                      (CONX*(EFP(3,ID1)-FRCCRD(3,IFP))-
     *                       CONZ*(EFP(1,ID1)-FRCCRD(1,IFP))
     *                      -CON2*DSAB(5))
                  FRCTRQ(6,IFP) = FRCTRQ(6,IFP) - SWF*COEF*
     *                      (CONY*(EFP(1,ID1)-FRCCRD(1,IFP))
     *                      -CONX*(EFP(2,ID1)-FRCCRD(2,IFP))
     *                      -CON2*DSAB(6))
                END DO
              END IF
C
 250           CONTINUE
 260        CONTINUE
 270     CONTINUE
 280  CONTINUE
C
      IF(GOPARR) THEN
         CALL DDI_GSUMF(677,EDISD,1)
         CALL DDI_GSUMF(677,EDISD0,1)
      END IF
      EDISC8=EDISD+EDISD/THREE
      EDISC80=EDISD0+EDISD0/THREE
C
C
      RETURN
      END
C*MODULE EFDRVR  *DECK POLPCM
      SUBROUTINE POLPCM(EFLD,EFADD,QSE,QSED,QSN,
     *                  XCTS,YCTS,ZCTS,AS,
     *                  XE,YE,ZE,RE,ISPHE,LIST,POLNRG)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      CHARACTER*8 FRGNME,POLNAM,DPOLNAM
C
      PARAMETER (MXATM=2000, MXFRG=1050, MXFGPT=12000, MXIFRQ=12,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      LOGICAL GOPARR, DSKWRK, MASWRK
C
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ*MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /FMCOM / X(1)
      COMMON /FRFD  / PPEFX(MXFGPT), PPEFY(MXFGPT), PPEFZ(MXFGPT)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCMDIM/ MXSP,MXTS,MEMPCM1,MEMPCM2,NTS
      COMMON /PCMEFP/ PB_MUL,PC_MUL,PB_POL,PC_POL,P_FF,P_NF,P_FN,P_I,
     *                P_IBIS,P_J,P_NUCC,P_NUCCBIS,ENPCM
      COMMON /PCMEPS/ EPSHET(MXATM),IHET
      COMMON /PCMITR/ RCUT(2),THRES,IPCMIT,IMUL,MXDIIS,NREG,MXITR1,
     *                MXITR2,MODPAP
      COMMON /PCMOPT/ RABI,RASC,REFPOL,THRSLS,DENSLS,WB,WA,ETA2,GD,EVAC,
     *                RHOW,PM,AREATL,AREAKP,BONDRY,OMEGA,RET,FRO,EPSINF,
     *                EPS,DR,RSOLV,VMOL,TCE,STEN,DSTEN,CMF,TABS,IDIRCT,
     *                IPCDER,IDP,ICOMP,IFIELD,ICAV,IDISP,IPRINT,IRETCAV,
     *                ICENT,IFAST,NEVAL,IEFPOL,KEEPSM,IMGABI,IMGASC,NADD
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IKREP,IEF,IP_F,NFMOPCM
      COMMON /PCMPRT/ GCAVP,GCAVS,GDISP,GREP,EHFGAS
      COMMON /SIMDAT/ NACC,NREJ,IGOMIN,NRPA,IBWM,NACCT,NREJT,NRPAT,
     *                NPRTGO,IDPUNC,IGOFLG
C
      DIMENSION  EFLD(3,NPTTPT),EFADD(3,NPTTPT),
     *           QSE(*),QSED(*),QSN(*),XCTS(*),YCTS(*),ZCTS(*),
     *           AS(*),XE(*),YE(*),
     *           ZE(*),RE(*),ISPHE(*),LIST(*)
C
      PARAMETER (ZERO = 0.00D+00, ONE = 1.00D+00,
     *           TOANGS=0.52917724924D+00, ANTOAU=1.0D+00/TOANGS)
      PARAMETER (GLIM=1.0D-03)
C
C     -------------------------------------------
C       -- EFP/PCM (NO QM ATOM) CALCULATION --
C       EFP INDUCED DIPOLE AND PCM ASC ARE
C       ITERATED TO SELF-CONSISTENCY
C       HUI LI
C       IOWA STATE UNIVERSITY
C       JULY 25TH, 2005
C     -------------------------------------------
C
      NPRTBK = NPRINT
      NPRINT = 817
      CALL MAKCVM
      CALL PEDRAM
      NPRINT = NPRTBK
C
      MXDII1 = MXDIIS + 1
C
      CALL VALFM(LOADFM)
      LQPOT1 = LOADFM + 1
      LQPOT2 = LQPOT1 + NTS
      LQ0    = LQPOT2 + NTS
      LQ1    = LQ0    + NTS
      LQ2    = LQ1    + NTS
      LQ3    = LQ2    + NTS
      LD0    = LQ3    + NTS
      LQA    = LD0    + NTS
      LDIMAT = LQA    + NTS
      LQREP  = LDIMAT + MXDII1*MXDII1
      LTMP0  = LQREP  + 2*NTS*MXDII1
      LTMP1  = LTMP0  + NTS*3
      LTMP2  = LTMP1  + MXDII1
      LIPVT  = LTMP2  + MXDII1*MXDII1
      LPOTTMP= LIPVT  + MXDII1
      LRMUL  = LPOTTMP+ NTS
      LAST   = LRMUL  + MXSP*10
      NEED   = LAST   - LOADFM -1
      CALL GETFM(NEED)
C
C
C     -- EFP STATIC MULTIPOLE POTENTIAL AT EACH TESSERA
C
      IF(IEFC+IEFD+IEFQ.GT.0) THEN
         DO ITS=1,NTS
            XI=XCTS(ITS)
            YI=YCTS(ITS)
            ZI=ZCTS(ITS)
            QADD=ZERO
            DO I=1,NMTTPT
               XX=EFQAD(1,I)
               YY=EFQAD(2,I)
               ZZ=EFQAD(3,I)
               XY=EFQAD(4,I)
               XZ=EFQAD(5,I)
               YZ=EFQAD(6,I)
               DUM=XX+YY+ZZ
               QXX=(3.0D+00*XX-DUM)/2.0D+00
               QYY=(3.0D+00*YY-DUM)/2.0D+00
               QZZ=(3.0D+00*ZZ-DUM)/2.0D+00
               QXY=1.50D+00*XY
               QXZ=1.50D+00*XZ
               QYZ=1.50D+00*YZ
               DX = XCTS(ITS)-EFC(1,I)
               DY = YCTS(ITS)-EFC(2,I)
               DZ = ZCTS(ITS)-EFC(3,I)
               R2 =  (EFC(1,I)-XI)**2
     *              +(EFC(2,I)-YI)**2
     *              +(EFC(3,I)-ZI)**2
               R  = SQRT(R2)
               QADD = QADD + EFCHG(1,I)/R + EFCHG(2,I)/R
     *                       +(EFDIP(1,I)*DX
     *                       +EFDIP(2,I)*DY
     *                       +EFDIP(3,I)*DZ)/(R*R2)
     *                      +(QXX*3.0D+00*DX*DX
     *                       +QYY*3.0D+00*DY*DY
     *                       +QZZ*3.0D+00*DZ*DZ
     *                       +QXY*6.0D+00*DX*DY
     *                       +QXZ*6.0D+00*DX*DZ
     *                       +QYZ*6.0D+00*DY*DZ)
     *                       /(3.0D+00*R2*R2*R)
            ENDDO
            X(LQPOT1+ITS-1)=-QADD
         ENDDO
      END IF
C
C
      CALL REGINI(ISPHE,LIST)
C
C
C     -- FIELD AT POLARIZABILITY POINTS DUE TO
C        MULTIPOLE POINTS IN OTHER FRAGMENTS
C        NOTE: THIS IS DONE ONCE AND REPEATEDLY
C              USED TO INDUCE EFP DIPOLES
C
      IF(IEFP.GT.0) CALL FRGFLD
C
C
C     IF THERE IS NO DIPOLE POLARIZABILITY TENSOR,
C     NO ITERATION IS NEEDED.
C
      MXCALL = 1
      IF(IEFP.GT.0) MXCALL = 40
C
      DO 600 ICALL = 1, MXCALL
C        USUALLY 10~15 ITERATIONS ARE REQUIRED.
C
C        -- 1. ADD INDUCED DIPOLE POTENTIAL TO EACH TESSERA
         DO ITS=1,NTS
            XI=XCTS(ITS)
            YI=YCTS(ITS)
            ZI=ZCTS(ITS)
            QADD=ZERO
            DO LEFP=1,NPTTPT
               XL=EFP(1,LEFP)
               YL=EFP(2,LEFP)
               ZL=EFP(3,LEFP)
               X1 = XI - XL
               Y1 = YI - YL
               Z1 = ZI - ZL
               R2=X1*X1 + Y1*Y1 + Z1*Z1
               R = SQRT(R2)
               R3 = R*R2
               QADD= QADD + (DIND(1,LEFP)*X1
     *                    +  DIND(2,LEFP)*Y1
     *                    +  DIND(3,LEFP)*Z1)/R3/2.0D+00
     *                    + (DINDD(1,LEFP)*X1
     *                    +  DINDD(2,LEFP)*Y1
     *                    +  DINDD(3,LEFP)*Z1)/R3/2.0D+00
            ENDDO
            X(LQPOT2+ITS-1)=X(LQPOT1+ITS-1)-QADD
         ENDDO
C
C        -- 2. COMPUTE PCM SURFACE CHARGE ON EACH TESSERA
C
C        ITERATIVE CYCLE (STEP 1)
         NTSPAR=(NTS-1)/NPROC+1
         CALL ASCCYC(1,ICALL,X(LQPOT2),X(LQ0),X(LQ1),X(LD0),
     *              X(LQA),X(LDIMAT),X(LQREP),X(LTMP0),X(LTMP1),
     *              X(LTMP2),X(LIPVT),X(LRMUL),
     *              MXDII1,NTSPAR,XCTS,YCTS,ZCTS,AS,
     *              XE,YE,ZE,RE,ISPHE,LIST)
C
C        C-PCM ONLY NEEDS STEP 1.
         IF(IEF.EQ.10) THEN
           DO ITS=1,NTS
              QSE(ITS)    =X(LQ1+ITS-1)
              X(LQ0+ITS-1)=X(LQ1+ITS-1)
           ENDDO
           GOTO 500
         END IF
C
C        ITERATIVE CYCLE (STEP 2)
C
C        WRITE THE INTERMEDIATE POTENTIAL, THE STEP 2 INITIAL GUESS
C        AND COPY THE INTERMEDIATE CHARGES
C
         FACIP=-1.0D+00/(EPS-1.0D+00)
         FACIG=-1.0D+00/EPS
         DO ITS=1,NTS
            X(LQ0+ITS-1)=      X(LQ2+ITS-1)
            X(LQ2+ITS-1)=FACIP*X(LQ1+ITS-1)
            X(LQ3+ITS-1)=      X(LQ1+ITS-1)
            IF(ICALL.EQ.1) X(LQ0+ITS-1)=FACIG*X(LQ1+ITS-1)
         ENDDO
C
         CALL ASCCYC(2,ICALL,X(LQ2),X(LQ0),X(LQ1),X(LD0),
     *              X(LQA),X(LDIMAT),X(LQREP),X(LTMP0),X(LTMP1),
     *              X(LTMP2),X(LIPVT),X(LRMUL),
     *              MXDII1,NTSPAR,XCTS,YCTS,ZCTS,AS,
     *              XE,YE,ZE,RE,ISPHE,LIST)
C
C        COPY THE CHARGES
C
         DO ITS=1,NTS
            QSE(ITS)=X(LQ3+ITS-1)+X(LQ1+ITS-1)
         ENDDO
C
C        USE Q1 AND Q3 FOR NEXT GUESSES
C
         DO ITS=1,NTS
            X(LQ0+ITS-1)=X(LQ3+ITS-1)
            X(LQ2+ITS-1)=X(LQ1+ITS-1)
         ENDDO
C
 500     CONTINUE
C
C        -- SCALE C-PCM CHARGE BY (EPS-1)/EPS
         IF(IEF.EQ.10) THEN
           DO ITS = 1, NTS
              QSE(ITS) = QSE(ITS)*(EPS-ONE)/EPS
           END DO
         END IF
C
C        TEST PCM ASC FOR CONVERGENCY
C        NOTE: WE USE QSN TO SAVE THE OLD QSE
C              MAKE SURE TO CLEAR QSN AFTERMATH
C
         SDEV=ZERO
         DO ITS=1,NTS
            SDEV=SDEV+(QSE(ITS)-QSN(ITS))**2
            QSN(ITS) = QSE(ITS)
         ENDDO
         SDEV=SQRT(SDEV/NTS)
C           IF(MASWRK) WRITE(IW,*) ' THRES=',THRES,
C    *      ' SDEV=', SDEV
         IF (SDEV.EQ.ZERO) THEN
C           IF(MASWRK) WRITE(IW,*)
C    *      'POLPCM CONVERGED AFTER ',ICALL,'ITERATIONS'
            GO TO 700
         END IF
C
C
C        **********************
C        UPDATE INDUCED DIPOLES
C        **********************
C
         IF(IEFP.GT.0) THEN
C
C           -- TOTAL FIELDS AT POL-TENSORS
C
            IPCOUNT = ME-1
            DO 200 LEFP = 1, NPTTPT
C              -- GO PARALLEL!
               IF(GOPARR) THEN
                  EFLD(1,LEFP) = ZERO
                  EFLD(2,LEFP) = ZERO
                  EFLD(3,LEFP) = ZERO
                  IPCOUNT = IPCOUNT + 1
                  IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 200
               END IF
C              -- SOLVENT APPARENT CHARGE FIELD AT THE POINT --
               PQ_X=ZERO
               PQ_Y=ZERO
               PQ_Z=ZERO
               IF(IEFPOL.EQ.1) THEN
                  DO 330 ITS = 1,NTS
                     RR = (EFP(1,LEFP)-XCTS(ITS))**2 +
     *                    (EFP(2,LEFP)-YCTS(ITS))**2 +
     *                    (EFP(3,LEFP)-ZCTS(ITS))**2
                     IF(RR.LT.GLIM .OR. RR.LT.(REFPOL*ANTOAU))GOTO 330
                     RR3 = RR * SQRT(RR)
                     PQ_X = PQ_X + QSE(ITS)*(EFP(1,LEFP)-XCTS(ITS))/RR3
                     PQ_Y = PQ_Y + QSE(ITS)*(EFP(2,LEFP)-YCTS(ITS))/RR3
                     PQ_Z = PQ_Z + QSE(ITS)*(EFP(3,LEFP)-ZCTS(ITS))/RR3
 330              CONTINUE
               END IF
C              -- TOTAL FIELD: EFP+PCM --
               EFLD(1,LEFP) = PQ_X+PPEFX(LEFP)
               EFLD(2,LEFP) = PQ_Y+PPEFY(LEFP)
               EFLD(3,LEFP) = PQ_Z+PPEFZ(LEFP)
 200        CONTINUE
            IF(GOPARR) THEN
               CALL DDI_GSUMF(667,EFLD, 3*NPTTPT)
            END IF
C
C           -- COMPUTE DIND/DINDD
C
            CALL VALFM(LOADFM)
            LDIPNEW  = LOADFM   + 1
            LDIPNWD  = LDIPNEW  + NFRG
            LDINDC   = LDIPNWD  + NFRG
            LDINDDC  = LDINDC   + 3*NPTTPT
            LDIND_W  = LDINDDC  + 3*NPTTPT
            LDIND_C  = LDIND_W  + 6*NPTTPT
            LEWLD1   = LDIND_C  + 6*NPTTPT
            LEWLD2   = LEWLD1   + 3*NPTTPT
            LAST     = LEWLD2   + 3*NPTTPT
            NEEED    = LAST - LOADFM - 1
            CALL GETFM(NEEED)
            CALL DIPIT(EFLD,EFADD,X(LDINDC),X(LDINDDC),
     *                 X(LDIND_W),X(LDIND_C),
     *                 NPTTPT,X(LDIPNEW),X(LDIPNWD),
     *                 X(LEWLD1),X(LEWLD2),NFRG)
            CALL RETFM(NEEED)
            IF(IDPUNC.EQ.1) RETURN
         END IF
C
 600  CONTINUE
 700  CONTINUE
      CALL VCLR(QSN,1,NTS)
C
C
C     -- COMPUTE PCM INTERACTION
C
      ENPCM  = ZERO
      QET    = ZERO
      DO ITS = 1,NTS
         QET    = QET+QSE(ITS)
         ENPCM  = ENPCM - X(LQPOT1+ITS-1) * QSE(ITS)
      ENDDO
C
C     -- COMPUTE EFP POLARIZATION ENERGY
C
      POLNRG = ZERO
      DO II=1,NPTTPT
         POLNRG = POLNRG - DIND(1,II)*PPEFX(II)
     *                   - DIND(2,II)*PPEFY(II)
     *                   - DIND(3,II)*PPEFZ(II)
     *                   - DINDD(1,II)*PPEFX(II)
     *                   - DINDD(2,II)*PPEFY(II)
     *                   - DINDD(3,II)*PPEFZ(II)
      END DO
      POLNRG = POLNRG/4.0D+00
C
C     SOLVATION OUTPUT FOR PCM MODEL
C
      IF(MASWRK) THEN
        WRITE(IW,*) ' '
        WRITE(IW,*) ' NTS    =', NTS
        WRITE(IW,'(A10,F18.10)') 'PCM ASC=',QET
        WRITE(IW,'(A10,F18.10)') 'GELEC  =',ENPCM/2.0D+00
        IF(ICAV.EQ.1)
     *  WRITE(IW,'(A10,F18.10)') 'GCAVP  =',GCAVP/627.509541D+00
        IF(IDISP.EQ.1)THEN
        WRITE(IW,'(A10,F18.10)') 'GDISP  =',GDISP/627.509541D+00
        WRITE(IW,'(A10,F18.10)') 'GREP   =', GREP/627.509541D+00
        END IF
      END IF
C
C     - QSED IS REQUIRED EVERYWHERE EVEN IF IHET=0 -
C     - QSED = QSE WHEN IHET=0
      IF(IHET.EQ.0) CALL DCOPY(NTS,QSE,1,QSED,1)
      IF(IHET.NE.0) THEN
         IF(MASWRK) WRITE(IW,*)
     *         ' ONLY HOMOGENEOUS PCM CAN BE USED FOR EFP-PCM'
         CALL ABRT
      END IF
C
      CALL RETFM(NEED)
      RETURN
      END
C
C
C*MODULE EFDRVR  *DECK PREFP
      SUBROUTINE PREFP(LU)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXFRG=1050, MXFGPT=12000,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      CHARACTER*6 FRGNAM
      CHARACTER*8 PTNAM
C
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
C
C   ---- LVS 2007: ROUTINE FOR PRINTING IN MD AND MC
C
      DO 30 I=1,NFRG
       IF (MASWRK) THEN
          WRITE(LU,35) I, FRGNAM(I)
          WRITE(LU,34) EFCENT(1,I),EFCENT(2,I),EFCENT(3,I)
          WRITE(LU,33) DEFT(1,I),DEFT(2,I),DEFT(3,I)
          WRITE(LU,31) TORQ(1,I),TORQ(2,I),TORQ(3,I)
          WRITE(LU,36)
       END IF
 30   CONTINUE
C
 35   FORMAT('FRAGMENT #',I6,'  ',A6)
 31   FORMAT('      TORQ',3F16.10)
 33   FORMAT('     FORCE',3F16.10)
 34   FORMAT('    EFCENT',3F16.10)
 36   FORMAT('    ')
C
      RETURN
      END
C
C*MODULE EFDRVR  *DECK EFPPARL
      SUBROUTINE EFPPARL
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXFRG=1050, MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (MXCPUEFP=1024)
C
      COMMON /EFPAR / LOCNFG,NLOW,NUP
      COMMON /EFPAR2/ NFRGAL(MXCPUEFP),NLOWAL(MXCPUEFP),NUPAL(MXCPUEFP),
     *                NPPTAL(MXCPUEFP)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      INTEGER DDI_NP,DDI_ME,FLO,CEIL,DIFF
C
C     PARTITION EFP'S OVER PROCESSORS
C
C     THIS SETS UP THE PARAMETERS FOR EFP PARALLELIZATION SCHEME.
C     WHEN ONE USES GDDI COMMUNICATER, THE PARALLELIZATION PARAMETER
C     FOR EFP MUST BE RESET, IN THE CORRECT COMMUNICATOR.
C
      IF(NFRG.GT.0) THEN
        DDI_ME = ME
        DDI_NP = NPROC
        IF (MOD(NFRG,DDI_NP) .EQ. 0) THEN
          LOCNFG = NFRG / DDI_NP
          NLOW = DDI_ME * LOCNFG + 1
        ELSE
          CEIL = NFRG/DDI_NP + 1
          FLO = NFRG/DDI_NP
          DIFF = NFRG - DDI_NP*FLO
C
          IF (DDI_ME .GT. (DDI_NP-1-DIFF)) THEN
            LOCNFG = CEIL
            NLOW = DDI_ME * LOCNFG - (DDI_NP-1-DIFF)
          ELSE
            LOCNFG = FLO
            NLOW = DDI_ME * LOCNFG + 1
          END IF
        END IF
C
        NUP =  NLOW + LOCNFG - 1
        IF(GOPARR) THEN
C    THERE IS AN UNFORTUNATE COMMON BLOCK DIMENSION USED HERE.
          IF(DDI_NP.GT.MXCPUEFP) THEN
             IF(MASWRK) WRITE(IW,*)
     *          'ERROR IN PARALLEL EFP, MXCPUEFP,NPROC=',MXCPUEFP,DDI_NP
             CALL ABRT
          END IF
          CALL VICLR(NFRGAL,1,MXCPUEFP)
          CALL VICLR(NLOWAL,1,MXCPUEFP)
          CALL VICLR( NUPAL,1,MXCPUEFP)
          NFRGAL(DDI_ME+1) = LOCNFG
          NLOWAL(DDI_ME+1) = NLOW
           NUPAL(DDI_ME+1) = NUP
          CALL DDI_GSUMI(660,NFRGAL,DDI_NP)
          CALL DDI_GSUMI(661,NLOWAL,DDI_NP)
          CALL DDI_GSUMI(662, NUPAL,DDI_NP)
        ELSE
          NFRGAL(1) = NFRG
          NLOWAL(1) = 1
           NUPAL(1) = NFRG
        END IF
      END IF
      RETURN
      END
C
      MODULE EFAIDIS
!> @brief This module contains global variables necessary for
!>         computing the EFP-ab initio dispersion energy
!>
!> @author Tony Smith
!> - Jan 10, 2013
!> @details
!>    SABEFPAI : THREE-DIMENSIONAL ARRAY OF DOUBLE PRECISION VALUES,
!>              allocated in SUBROUTINE EFPAIE in source file EFPAUL,
!>              deallocated in SUBROUTINE EFAIDISP in this module.
!>              Stores values of EFP-AI overlap integrals. Dimensions
!>              are (NFRG,NA-MMCORE,MMXMO), where NFRG = number of EFPs,
!>              NA-MMCORE = number of AI valence orbitals, MMXMO =
!>              number of dispersion points (centroids) per EFP
!>    IQMDISP : flag to turn on EFP-AI dispersion calculation
!>              POSSIBLE VALUES: 0 = off, non-zero = on.
!>              Set in SUBROUTINE EFINP in source file EFINP.
!>    IDISDMP : flag to specify type of damping function
!>              POSSIBLE VALUES: -1 = no damping, 1 = overlap-based,
!>                    all other values (usually 0) = Tang-Toennies
!>              Set in SUBROUTINE EFINP in source file EFINP.
!>    IDSGRD  : flag to skip the dispersion gradient calculation
!>              POSSIBLE VALUES: 0 = gradient off, non-zero = on.
!>              Set in SUBROUTINE EFINP in source file EFINP.
!>    MMCORE : number of core orbitals. Set in RHFCL in source
!>             file RHFUHF.
!>    DISPENRG : value of the EFP-AI dispersion energy
!>    MMXMO  :  number of dispersion points (centroids) per EFP
!>    MMXBF  :  number of basis functions
!
      DOUBLE PRECISION, ALLOCATABLE, SAVE :: SABEFPAI(:,:,:)
      INTEGER, SAVE :: IQMDISP,IDISDMP,IDSGRD,MMCORE
      DOUBLE PRECISION, SAVE :: DISPENRG,MMXMO,MMXBF
      END MODULE EFAIDIS
C
C *MODULE EFDRVR  *DECK EFAIDISP
!> @brief   Calculates EFP-ab initio (EFP-AI/EFP-QM) dispersion energy
!>          and gradients
!>
!> @author  Tony Smith
!> - Jan 10, 2013
!> @param   EORBS: Array of orbital energies
!> @details see Q. Smith et al, J. Chem. Phys. 136, 244107 (2012);
!>          http://dx.doi.org/10.1063/1.4729535
!> @note    Gradient code for overlap-based damping (IDISDMP=1) is
!>          incomplete!
!> @todo    Get derivatives of overlap integrals between EFP and AI
!>          orbitals to complete the overlap-based damping gradients
      SUBROUTINE EFAIDISP(EORBS)
      USE EFAIDIS
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      CHARACTER*8 POLNAM,DPOLNAM
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000,
     *           MXFRG=1050, MXFGPT=12000, MXIFRQ=12,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12,
     *           MXGEFP=4000, MXSHEF=1000)
      PARAMETER (NMO=500, MXAO=8192)
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ,MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /EFPSCR/ POLAB(MXFRG),B,SCROFF,IELECS,IDISPS,NEW_POL
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /EFPGES/ DESFRG(6,MXFRG)
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /MASSES/ ZMASS(MXATM)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORBFP(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /EFPBAS/ EXEF(MXGEFP,MXDFG),CSEF(MXGEFP,MXDFG),
     *                CPEF(MXGEFP,MXDFG),CDEF(MXGEFP,MXDFG),
     *                CFEF(MXGEFP,MXDFG),CGEF(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTREF(MXSHEF,MXDFG),KATMEF(MXSHEF,MXDFG),
     *                KTYPEF(MXSHEF,MXDFG),KNGEF(MXSHEF,MXDFG),
     *                KLOCEF(MXSHEF,MXDFG),KMINEF(MXSHEF,MXDFG),
     *                KMAXEF(MXSHEF,MXDFG),NSHLEF(MXDFG),NGSSEF(MXDFG),
     *                NATEF(MXDFG),NUMEF(MXDFG),NTPATM
C
      DIMENSION EORBS(NUM)
      DIMENSION WRKTR(12)
      DIMENSION DYNTR(MXDPPT,NFRG)
      DIMENSION FUM1(NA-MMCORE,NQMT-NA),FUM2(NA-MMCORE,NQMT-NA),
     *			FUM3(NA-MMCORE,NQMT-NA)
      DIMENSION SQ1(NA-MMCORE,NA-MMCORE),
     *          SQ2(NA-MMCORE,NA-MMCORE),
     *			SQ3(NA-MMCORE,NA-MMCORE),
     *          AVG(NA-MMCORE,NA-MMCORE),WORK(NA),
     *          H(NA-MMCORE,NA-MMCORE),H1(NA-MMCORE)
      DIMENSION UM1(NQMT-NA,NA-MMCORE),UM2(NQMT-NA,NA-MMCORE),
     *          UM3(NQMT-NA,NA-MMCORE)
      DIMENSION UM(NA-MMCORE,NQMT-NA,3),
     *          HF((NUM*NUM+NUM)/2),
     * 			TRAN(NA-MMCORE,NA-MMCORE),
     *          E(NUM),HFP(NUM,NUM),CXM(NUM,NUM),TM(NUM),
     *          D((NUM*NUM+NUM)/2)
      DIMENSION VEC(NUM,NA),XYZP(3),CCHG(3,NA-MMCORE),DIST(3)
      DIMENSION CEE(NAT,3),CEF(NFRG,3),ZNU(NAT),ZEF(MXATM)
      DIMENSION DEE(3),DEETORQ(6),AROT(3,NAT),
     *          ATRAN(3),ATOTAL(3,NAT),FTOTAL(3,NAT)
C
      DATA ZERO,ONE,TWO,THREE /0.0D+00,1.0D+00,2.0D+00,3.0D+00/
      DATA FOUR,SIX           /4.0D+00,6.0D+00/
C
      THIRD=ONE/THREE
      FOURTHIRD=FOUR*THIRD
      MAXDER = 0
      CALL DERCHK(MAXDER)
      IF (MAXDER.NE.1) IDSGRD = 0
      NXYZ = 3
      NORB = NQMT
      NOCC = NA
      NLOC = NA - MMCORE
      NVIR = NORB - NA
      NUM2 =(NUM*NUM+NUM)/2
      NUM3 = NUM*NUM
      DO I=1,3
         DEE(I)=ZERO
         DEETORQ(I)=ZERO
         DEETORQ(I+3)=ZERO
      ENDDO
      CALL DAREAD(IDAF,IODA,VEC,NUM*NA,71,0)
      IF(NVIR .EQ. 0) RETURN
      CALL DAREAD(IDAF,IODA,TRAN,NLOC*NLOC,73,0)
      ID = 0
      DO I=1,NFRG
        DO J=1,NDPPTS(I)
           ID=ID+1
           DYNTR(J,I) = THIRD*(EFDPOL(1,ID) + EFDPOL(2,ID) +
     *                   EFDPOL(3,ID))
        ENDDO
      ENDDO
C
C  TRANSFORM DIPOLE INTEGRALS TO MO BASIS
C
      CALL DAREAD(IDAF,IODA,CXM,NUM3,15,0)
      IF (MMCORE.GT.0) THEN
         DO I = 1,NLOC
            CALL DCOPY(NUM,VEC(1,MMCORE+I),1,VEC(1,I),1)
         END DO
      END IF
      CALL CALCOM(XCOM,YCOM,ZCOM)
      XYZP(1) = XCOM
      XYZP(2) = YCOM
      XYZP(3) = ZCOM
      CALL DIPINT(XCOM,YCOM,ZCOM,.FALSE.)
      DO 300 IXYZ=1,3
         CALL DAREAD(IDAF,IODA,D,NUM2,94+IXYZ,0)
         CALL TFTRI(HF,D,CXM,TM,NORB,NUM,NUM)
C GET (OCC-CORE) x VIR BLOCK
         CALL CPYTSQ(HF,HFP,NUM,1)
         IL=0
         DO 320 IVIR=1,NVIR
            IM=0
            DO 340 IOCC=MMCORE+1,NA
               IM=IM+1
               UM(IM,IVIR,IXYZ)=HFP(IOCC,NA+IVIR)
  340       CONTINUE
  320    CONTINUE
C GET LMO CENTROIDS
         DO 360 J=1,NLOC
            CALL TFTRI(CCHG(IXYZ,J),D,VEC(1,J),TM,1,NUM,NUM)
            CCHG(IXYZ,J) = CCHG(IXYZ,J) + XYZP(IXYZ)
  360    CONTINUE
  300 CONTINUE
      IE=0
      SUM=0.0D+00
      DISP=0.0D+00
      JAY=0
C BEGIN LOOP OVER EFP POINTS
      DO 801 IEFP=1,NFRG
      INPPTS=NPPTS(IEFP)
      DO 800 JEFP=1,INPPTS
      IE=IE+1
      DO IT=1,12
C CONSTRUCT ALPHA TENSOR (DYNAMIC POLARIZABILITY VALUES FOR EFP)
         WRKTR(IT)=DYNTR(JEFP+(IT-1)*INPPTS,IEFP)
      ENDDO
      DO 411 IOCC=1,NLOC
         DO 421 IVIR=1,NVIR
C ENERGY DIFF BETWEEN A VIRTUAL AND AN OCCUPIED AI ORBITAL
            ENRGDF=EORBS(NA+IVIR)-EORBS(MMCORE+IOCC)
C GET VALUE OF INTEGRAL OVER IMAG FREQ RANGE FOR THIS PAIR OF AI ORBITALS
C AND SET OF ALPHA VALUES
            CALL EFAIMF(FR,WRKTR,ENRGDF)
C MULTIPLY IMAG FREQ INTEGRAL WITH CORRESPONDING DIPOLE INTEGRAL
            FUM1(IOCC,IVIR)=UM(IOCC,IVIR,1)*FR
            FUM2(IOCC,IVIR)=UM(IOCC,IVIR,2)*FR
            FUM3(IOCC,IVIR)=UM(IOCC,IVIR,3)*FR
C TRANSPOSE OF DIPOLE INTEGRAL MATRICES
            UM1(IVIR,IOCC)=UM(IOCC,IVIR,1)
            UM2(IVIR,IOCC)=UM(IOCC,IVIR,2)
            UM3(IVIR,IOCC)=UM(IOCC,IVIR,3)
  421    CONTINUE
  411 CONTINUE
C MULTIPLY (IMAG FREQ*DIPOLE) BY (TRANSPOSE OF DIPOLE), OBTAINING SQUARE
C MATRICES INDEXED BY OCCUPIED (VALENCE) ORBITALS ONLY
      CALL MRARBR(FUM1,NLOC,NLOC,NVIR,UM1,NVIR,NLOC,SQ1,NLOC)
      CALL MRARBR(FUM2,NLOC,NLOC,NVIR,UM2,NVIR,NLOC,SQ2,NLOC)
      CALL MRARBR(FUM3,NLOC,NLOC,NVIR,UM3,NVIR,NLOC,SQ3,NLOC)
C  AVERAGE THE MATRICES OVER DIRECTIONAL COMPONENTS: (1/3)(Dx+Dy+Dz)
C  (The FOUR is somehow part of the integration scheme; see SUROUTINE LAPOL
C  in source file LOCPOL, from which this subroutine was adapted.)
      DO I=1,NLOC
         DO J=1,NLOC
            AVG(I,J)=SQ1(I,J)+SQ2(I,J)+SQ3(I,J)
            AVG(I,J)=AVG(I,J)*FOUR*THIRD
         ENDDO
      ENDDO
C TRANSFORM TO LOCALIZED MO BASIS
      CALL TFSQU(H,AVG,TRAN,WORK,NLOC,NLOC)
C DIAGONAL ELEMENTS OF H MATRIX NOW CORRESPOND TO C6 VALUES.
C USE THEM WITH C6*F6/R6 FORMULA:
      DO 790 I=1,NLOC
         C6=H(I,I)
         F6=ONE
         DO IXYZ=1,3
            DIST(IXYZ)=EFP(IXYZ,IE)-CCHG(IXYZ,I)
         ENDDO
         X = DIST(1)
         Y = DIST(2)
         Z = DIST(3)
C         RR=DIST(1)*DIST(1)+DIST(2)*DIST(2)+DIST(3)*DIST(3)
         R2 = X*X + Y*Y + Z*Z
         R=SQRT(R2)
         R6=R2*R2*R2
         IF (IDISDMP.EQ.1) THEN
C           OVERLAP-BASED DAMPING
            SAB=SABEFPAI(IEFP,I,JEFP)
            IF (ABS(SAB) .GT. 1.0D-05) THEN
               RB = -2.0D+00*LOG(ABS(SAB))
               RB2 = RB*RB
               EX1 = SAB*SAB
               F6 = ONE-(EX1*(ONE + RB + RB2/TWO ))
            ELSE
               F6 = ONE
               RB = ZERO
               RB2 = ZERO
               SAB = ZERO
            END IF
         ELSE IF (IDISDMP.EQ.-1) THEN
C           NO DAMPING
            F6=ONE
            RB=ZERO
            RB2 = ZERO
            SAB=ZERO
         ELSE
C           TANG-TOENNIES DAMPING
            RB =  B*R
            EX1 = EXP(-RB)
            RB2 = RB*RB
            RB3 = RB*RB2
            RB4 = RB2*RB2
            RB5 = RB*RB4
            RB6 = RB*RB5
C
            F6 = ONE-(EX1*(ONE + RB + RB2/TWO +
     *               RB3/SIX + RB4/24.0D+00 +
     *               RB5/120.0D+00 +RB6/720.0D+00))
         END IF
         SUM=SUM+C6*F6
         DISP=DISP - C6*F6/R6
C   GRADIENT
C   DE/DR=FOUR/THREE*(-6*C6*F6/R**7 + DF6/DR * C6/R**6)
         IF (IDSGRD.EQ.0) GOTO 790
         IF (IDISDMP .EQ. 1) THEN
C   NOTE: GRADIENT NOT FULLY IMPLEMENTED FOR OVERLAP-BASED
C         DAMPING. NEED "DF6" TERMS, I.E. DSAB (DERIVATIVE
C         OF OVERLAP INTEGRALS TAKEN BTWN EFP&QM ORBITALS)
            CON1=-FOURTHIRD*(C6/R6)*(SIX*F6/R2)
            CON2=-FOURTHIRD*(C6/R6)*(RB2*SAB)
         ELSE
            CON1=-FOURTHIRD*(C6/R6)*
     *           ((SIX*F6/R2)-(B*RB6*EX1)/(R*720.0D+00))
            CON2 = ZERO
         END IF
C
         CONX=CON1*X
         CONY=CON1*Y
         CONZ=CON1*Z
         DEE(1) = DEE(1) + CONX
C     *            + CON2*DSAB(1)
         DEE(2) = DEE(2) + CONY
C     *            + CON2*DSAB(2)
         DEE(3) = DEE(3) + CONZ
C     *            + CON2*DSAB(3)
         DEETORQ(1) = DEETORQ(1)+CONZ*(EFP(2,JEFP)-EFCENT(2,IEFP))
     *                      -CONY*(EFP(3,JEFP)-EFCENT(3,IEFP))
         DEETORQ(2) = DEETORQ(2)+CONX*(EFP(3,JEFP)-EFCENT(3,IEFP))
     *                      -CONZ*(EFP(1,JEFP)-EFCENT(1,IEFP))
         DEETORQ(3) = DEETORQ(3)+CONY*(EFP(1,JEFP)-EFCENT(1,IEFP))
     *                      -CONX*(EFP(2,JEFP)-EFCENT(2,IEFP))
         DEETORQ(4) = DEETORQ(4)+CONZ*(CCHG(2,I)-YCOM)
     *                      -CONY*(CCHG(3,I)-ZCOM)
         DEETORQ(5) = DEETORQ(5)+CONX*(CCHG(3,I)-ZCOM)
     *                      -CONZ*(CCHG(1,I)-XCOM)
         DEETORQ(6) = DEETORQ(6)+CONY*(CCHG(1,I)-XCOM)
     *                      -CONX*(CCHG(2,I)-YCOM)
C
C END LOOP OVER VALENCE LMOs
  790 CONTINUE
C  END LOOP OVER EFP POINTS
  800 CONTINUE
      IF (IDSGRD.EQ.0) GOTO 801
      DO J=1,3
         DESFRG(J,IEFP) = DESFRG(J,IEFP) + DEE(J)
         DESFRG(J+3,IEFP) = DESFRG(J+3,IEFP) + DEETORQ(J)
      ENDDO
C END LOOP OVER NUMBER OF FRAGMENTS
  801 CONTINUE
      IF (IDSGRD.EQ.0) GOTO 999
C     GET MOMENTS OF INERTIA AND TOTAL MASS FOR AI
      TMASS=ZERO
      DO I=1,NAT
         CEE(I,1)=C(1,I)
         CEE(I,2)=C(2,I)
         CEE(I,3)=C(3,I)
         ZNU(I)=ZAN(I)
         TMASS = TMASS + ZMASS(I)
      ENDDO
      CALL PRAXIS(CEE,ZNU,NAT,NAT,AIX,AIY,AIZ)
C     CALCULATE ROTATIONAL ACCELERATION AT ATOMS
      IF (NAT.EQ.1) THEN
         AROT(1,1)=ZERO
         AROT(2,1)=ZERO
         AROT(3,1)=ZERO
         GOTO 390
      END IF
      IF (AIX.GT.1.0D-05) THEN
         ALX=DEETORQ(4)/AIX
      ELSE
         ALX=ZERO
      END IF
      IF (AIY.GT.1.0D-05) THEN
         ALY=DEETORQ(5)/AIY
      ELSE
         ALY=ZERO
      END IF
      IF (AIZ.GT.1.0D-05) THEN
         ALZ=DEETORQ(6)/AIZ
      ELSE
         ALZ=ZERO
      END IF
      DO I=1,NAT
        AROT(1,I)=ALZ*(C(2,I)-YCOM)-ALY*(C(3,I)-ZCOM)
        AROT(2,I)=ALX*(C(3,I)-ZCOM)-ALZ*(C(1,I)-XCOM)
        AROT(3,I)=ALY*(C(1,I)-XCOM)-ALX*(C(2,I)-YCOM)
      ENDDO
C     CALCULATE TRANSLATIONAL ACCELERATION
 390  DO I=1,3
         ATRAN(I)=DEE(I)/TMASS
      ENDDO
C     CALCULATE TOTAL ACCELERATION AND TOTAL FORCE,
C     ADD TO GRADIENT "DE"
      DO I=1,NAT
         DO J=1,3
            ATOTAL(J,I)=AROT(J,I)+ATRAN(J)
            FTOTAL(J,I)=ATOTAL(J,I)*ZMASS(I)
            DE(J,I) = DE(J,I) + FTOTAL(J,I)
         ENDDO
      ENDDO
C
C  APPROXIMATE THE HIGHER ORDER TERMS IN DISPERSION ENERGY
C  EXPANSION AS 1/3 OF THE C6 CONTRIBUTION
  999 DISPENRG = DISP*FOURTHIRD
C     WRITE(IW,1000) DISPENRG
      IF (ALLOCATED(SABEFPAI)) DEALLOCATE(SABEFPAI)
      RETURN
C1000 FORMAT(1X,'EFP-AI DISPERSION ENERGY =',F20.10)
      END SUBROUTINE EFAIDISP
C
C *MODULE EFDRVR  *DECK EFAIMF
!> @brief Calculates imaginary frequency integral between
!>        pairs of AI orbitals; for use with EFAIDISP code
!>
!> @author Tony Smith
!> - Jan 10, 2013
!> @param FR : the final calculated value of the integral
!> @param ALP : alpha tensor; array of 12 values
!> @param ENRGDF : energy difference between two AI orbitals
      SUBROUTINE EFAIMF(FR,ALP,ENRGDF)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXFRG=1050, MXIFRQ=12, MXFGPT=12000,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00)
C THE 12 GAUSS-LEGENDRE WEIGHTS
      PARAMETER (FACT1= 0.72086099022968040154D-02)
      PARAMETER (FACT2= 0.17697067815034886394D-01)
      PARAMETER (FACT3= 0.30660908596251749739D-01)
      PARAMETER (FACT4= 0.48381293256249884995D-01)
      PARAMETER (FACT5= 0.74878830420650517080D-01)
      PARAMETER (FACT6= 0.11806515901361630228D+00)
      PARAMETER (FACT7= 0.19535413832209084204D+00)
      PARAMETER (FACT8= 0.35055692324483221824D+00)
      PARAMETER (FACT9= 0.71577113554429568336D+00)
      PARAMETER (FACT10=1.81409759976323969729D+00)
      PARAMETER (FACT11=6.97923445114870823247D+00)
      PARAMETER (FACT12=83.2480938829658453917D+00)
C THE 12 GAUSS-LEGENDRE ABSCISSAS A.K.A. IMAGINARY FREQ VALUES
C (THE FOLLOWING ARE ACTUALLY THE FREQUENCIES *SQUARED*)
      PARAMETER (FREQ1=0.779327022332536710825D-05)
      PARAMETER (FREQ2=0.228210717737242978745D-03)
      PARAMETER (FREQ3=0.152113192477780750688D-02)
      PARAMETER (FREQ4=0.608339199058554610325D-02)
      PARAMETER (FREQ5=0.192239670393041989464D-01)
      PARAMETER (FREQ6=0.543928293635942075334D-01)
      PARAMETER (FREQ7=0.148916688004125595980D+00)
      PARAMETER (FREQ8=0.421349037034822917794D+00)
      PARAMETER (FREQ9=1.331494010666300803437D+00)
      PARAMETER (FREQ10=5.32498192172462030801D+00)
      PARAMETER (FREQ11=3.54935126637048206534D+01)
      PARAMETER (FREQ12=1.03935828835455831714D+03)
C
      CHARACTER*8 POLNAM,DPOLNAM
      LOGICAL GOPARR,DSKWRK,MASWRK
      DIMENSION  ALP(12)
C
      ENRGSQ=ENRGDF*ENRGDF
C
      FR= ALP(1)*FACT1/(ENRGSQ+FREQ1)
     *  + ALP(2)*FACT2/(ENRGSQ+FREQ2)
     *  + ALP(3)*FACT3/(ENRGSQ+FREQ3)
     *  + ALP(4)*FACT4/(ENRGSQ+FREQ4)
     *  + ALP(5)*FACT5/(ENRGSQ+FREQ5)
     *  + ALP(6)*FACT6/(ENRGSQ+FREQ6)
     *  + ALP(7)*FACT7/(ENRGSQ+FREQ7)
     *  + ALP(8)*FACT8/(ENRGSQ+FREQ8)
     *  + ALP(9)*FACT9/(ENRGSQ+FREQ9)
     *  + ALP(10)*FACT10/(ENRGSQ+FREQ10)
     *  + ALP(11)*FACT11/(ENRGSQ+FREQ11)
     *  + ALP(12)*FACT12/(ENRGSQ+FREQ12)
      FR=FR*ENRGDF
      RETURN
      END SUBROUTINE EFAIMF
