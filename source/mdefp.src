C 15 Aug 13 - CHC - Add RESTART file for MD
C 12 Aug 13 - THC - Add the QM boundary, DROFF(2) cf) DROFF(1) is the 
C                   total boundary
C  6 Aug 13 - MWS - avoid divisions by zero box lengths
c 21 May 13 - TN  - minor changes for SSBP without EFP
C 28 Dec 12 - CHC - Inter center of mass coordinate
C 14 Dec 12 - CHC,DGF - CCMS option added, parallel umbrella samping and
C                   other minor fixes
C 19 Oct 12 - MWS - synchronize FRGINF common
C 05 Sep 12 - THC - Add the flexible atomic pair umbrella sampling to the 
C                   asymmetric coord
C 04 Sep 12 - THC - Add the flexible atomic pair umbrella sampling to the 
C                   normal constrain
C 22 Aug 12 - CHC - Bug of torsion fixed
C 27 Jul 12 - CHC - Asymmetric umbrella sampling error and others fixed
C  3 Jul 12 - CHC - Fixed REMD(F44) file open for non REMD run
C 16 Jun 12 - JJ  - Added missing potential energy in cstssbp
C 27 Apr 12 - MWS - fix alignment of the CSTPOT common
C 23 MAR 12 - CHC,DGF - MD improvements and PAD commons
C 29 Dec 11 - CHC - Add SSBP and umbrellla sampling technique
C 28 DEc 11 - DGF - PAD COMMONS FOR FMO 4.2
C 15 Apr 11 - TN  - changes for the FMO analytic gradient
C 15 Apr 11 - YK  - MDPRTCORVEL: correct printing EFCENT/TORQ
C 12 Dec 10 - HL  - allow periodic boundary condition for qmmm
C 11 Aug 10 - TN  - changes for FMO/MD
C  1 May 09 - LVS - GATHER EFP FORCES AT FORCE POINTS
C  1 May 09 - NMT - new dimension for EFPBAS and FRAGMT
C  1 May 09 - SHY - add the pressure calculation (bug fix)
C 15 Dec 08 - MWS - fix restart information, change some input keywords
C 23 Oct 08 - LVS - RDF computation changed
C 23 Oct 08 - JMM - added internal virial calc and properties,
C                   added NVTp ensemble changes to MDX/ENEDAB/ENEDEF
C  4 Mar 08 - SS  - MDX: skip velocity scaling if velocity input read
C  4 Mar 08 - SHY - MDNOSEVV1,2: combined in one routine
C  7 Dec 07 - MWS - RDFX: fix parallel printing
C 20 Aug 07 - SHY - ALLOW MD for QM/EFP1, implement Nose thermostat
C 20 Aug 07 - LVS - general RDFs, BOXL removed from MDSIM, printout
C 24 Mar 07 - LVS - pad common FRGINF,EFPPAR; printing in MDPRTCORVEL
C 10 Jul 06 - HL  - MDX: fix reading rotational velocities
C 22 Feb 06 - HL  - fix parallel print out
C 14 Nov 05 - HMN - NVT MD run with temperature reassignment
C 19 Sep 05 - HMN,IA - implement EFP minimum image convention MD
C
C*MODULE MDEFP   *DECK MDX
      SUBROUTINE MDX
C>
C>     @brief Main MD driver
C>
C>     @details Setup and perform MD calculations
C>
C>     @author unknown 
C>
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXFRG=1050,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (NBIN=1000, MAXRDF=100, MXPAIR=50,NRepca=100)
      PARAMETER (ZERO=0.0D+00)
C
      CHARACTER*6 FRGNAM, FRAG1, FRAG2
      CHARACTER*8 PTNAM, RDFNAME
C
      LOGICAL READ,NVT,MBT,MBR,QRAND,RSRAND,RSTEMP,PBCOUT,PROD,
     *        PBCWRI,IWATER,LVELSET,AXEQ,NVTP,OK,
     *        PRESSR,DIFUSN,DIPOLEP,HTVAP,COORDN,RRELAX,HBLFE,
     *        GOPARR,DSKWRK,MASWRK,ssbp,usamp,ccms
      LOGICAL LSCZVFLG
      logical ISGDDI,PAROUT,INITGDDI,wasgddi
C
      DOUBLE PRECISION MD,MDTYP, MDINT
      INTEGER TYPMD,RNDSTEP
C
C        next group used only in this routine, to hold input values
      DIMENSION TVELQM(3,MXATM), TVEL(3,MXFRG), RVEL(3,MXFRG),
     *          QUAT(4,MXFRG), QUAT1D(4,MXFRG), QUAT2D(4,MXFRG),
     *          RMOM(3,MXFRG)
C
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi
      COMMON /ATMDAT/ VX(MXFRG), VY(MXFRG), VZ(MXFRG),
     *                QW(MXFRG), QX(MXFRG), QY(MXFRG), QZ(MXFRG),
     *                OX(MXFRG), OY(MXFRG), OZ(MXFRG), QW1(MXFRG),
     *                QX1(MXFRG),QY1(MXFRG),QZ1(MXFRG),QW2(MXFRG),
     *                QX2(MXFRG),QY2(MXFRG),QZ2(MXFRG),
     *                VXQM(MXATM), VYQM(MXATM), VZQM(MXATM)
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      common /cstpot/ DROFF(2),SFORCE,uforce(10),rzero(10),dtemp,
     *                rzeroC(3,MXATM),Tmin,uV,batht(NRepca),mdint,
     *                ipair(50),iustyp,ncst,nrand,nvtoff,
     *                jevery,kevery,levery,mremd,
     *                rstemp,rsrand,prod,SSBP,ccms,Usamp,IndexOH(50),
     *                movemm(200),nefpmv,cforce,tmass(3)
      COMMON /EFPPBC/ XBOX,YBOX,ZBOX,XCUT,YCUT,ZCUT,RCUT,
     *                SWR1,SWR2,ISWF
      COMMON /FMCOM / XX(1)
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                MODLMO,NOPDEN,MOFOCK,MODFD,modfmm,ncentm
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,LIACTFG,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /FUNCT / E, EG(3*MXATM)
      COMMON /GOFR  / GOFR(NBIN,3), GENFR(NBIN,MAXRDF), CCRDF(NBIN),
     *                GEN2FR(NBIN,2),
     *                DELR, NUMG, NUMSAM1,NUMSAM2,NUMSAM3
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /MDSIM / DT, BATHTmp, EKINT, EKINR, MDTYP
      COMMON /MDSIM2/ READ
      COMMON /MDSIM3/ NVT,NVTP
      COMMON /MDSIM4/ NSTEPS
      COMMON /MDSIM5/ MBT,MBR,QRAND
      COMMON /MDSIM7/ VXO(MXFRG), VYO(MXFRG), VZO(MXFRG),
     *                WXO(MXFRG), WYO(MXFRG), WZO(MXFRG)
      COMMON /MDSIM8/ PRESSR,DIFUSN,DIPOLEP,HTVAP,COORDN,
     *                RRELAX,HBLFE
      COMMON /MDVEL / WX(MXFRG),WY(MXFRG),WZ(MXFRG),TQI(3,MXFRG)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PBC/    PBCOUT,PBCWRI
      COMMON /RDFPAR/ NRDF,RDFNAME(MAXRDF),FRAG1(MAXRDF),FRAG2(MAXRDF),
     *                KOEFF(MAXRDF), NPAIR(MAXRDF),
     *                NATOM1(MXPAIR,MAXRDF),NATOM2(MXPAIR,MAXRDF),
     *                AXEQ, INFO_AXEQ(2),NFRG_RDF(MAXRDF,2)
      COMMON /NOSEHO/ GNH(2),VNH(2),XNH(2),QNH(2),EKT0,GFREE0,NVTNH
      COMMON /SCZVEC/ IDFZVEC,LIPTZVEC,LIPTLG
      COMMON /MASSES/ ZMASS(MXATM)
c
      dimension Repca_E(NRepca), Repca_T(NRepca),MyAccept(NRepca),
     *          MyTPos(NRepca)
CHC   For REMD
      Integer ddi_world,ddi_group
      Parameter(ddi_world=0,ddi_group=1)
C
C
C         set up $MD namelist simulation
      PARAMETER (NNAM=43)
      DIMENSION QNAM(NNAM),KQNAM(NNAM)
      DATA MD/8HMD      /
      DATA QNAM /8HMDINT   ,8HNSTEPS  ,8HTTOTAL  ,8HBATHT   ,
     *           8HDELR    ,8HDT      ,8HJEVERY  ,8HKEVERY  ,
     *           8HRSTEMP  ,8HDTEMP   ,8HRSRAND  ,8HNRAND   ,
     *           8HREAD    ,8HMBT     ,8HMBR     ,8HQRAND   ,
     *           8HPROD    ,8HPBCOUT  ,8HNVTOFF  ,8HNVTNH   ,
     *           8HTVELQM  ,8HTVEL    ,8HRMOM    ,8HRVEL    ,
     *           8HQUAT    ,8HQUAT1D  ,8HQUAT2D  ,8HNPROP   ,
     *           8HNVTP    ,8HSSBP    ,8HDROFF   ,8HSFORCE  ,
     *           8HUSAMP   ,8HIPAIR   ,8HUFORCE  ,8HRZERO   ,
     *           8HIUSTYP  ,8HLEVERY  ,8HMREMD   ,8HINDEXOH ,
     *           8HMOVEMM  ,8HCCMS    ,8HCFORCE  /
      DATA KQNAM/5, 1, 3, 1003,
     *           3, 3, 1, 1,
     *           0, 3, 0, 1,
     *           0, 0, 0, 0,
     *           0, 0, 1, 1,
     *           -3, -3, -3, -3,
     *           -3, -3, -3,  1,
     *           0, 0, 103, 3,
     *           0, 501, 103, 103,
     *           1, 1, 1, 501,
     *           2001, 0, 3/
C
      DATA EFP,ABINIT /8HEFP     ,8HABINIT  /
      DATA FROG,VVERL,VVERLET /8HFROG    ,8HVVERL   ,8HVVERLET /
C
C**********************************************************************
C   DRIVER FOR MD SIMULATIONS USING EFFECTIVE FRAGMENTS
C             Jon Sorenson, 12/7/99
C         Heather Netzloff, up to 2005 when included in GAMESS
C             Soohaeng Yoo, 2007-2008
C    (DRIVER CODE BORROWED HEAVILY FROM GRANT MERRILL)
C   property calculations due to Lyuda Slipchenko and Jon Mullin
C   REMD Extension by Cheol Ho Choi and Dmitri Fedorov, 2012
C**********************************************************************
      if(isgddi.and.nfg.eq.0) call gddi_scope(ddi_group)
c     For FMO, parallelisation is done elsewhere.
      CALL DDI_OUTPUT(0) 
c     Stop voluminous DDI messages.
C
c     Initial REMD setup
c
      IEOREMD=1
      IExchCnt=0
c     Temperature exchange at LEVERY steps.
      LEVERY=1000
cc      if(isgddi) call gddi_scope(ddi_group)
c     Repca_Factor = J/Eh *1/kB
      Repca_Factor=4.35974434d-18/1.3806504d-23
c     MREMD : Set REMD Type
c     MREMD = 0  : no REMD
c     MREMD = 1  : 1 Dimension REMD
c     MREMD = 2  : 2 Dimension REMD
      MREMD = 0
c     MyRepca
      do i=1,NRepca
         MyTPos(i)=i
      enddo
      iseed=7234567
c
CHC
      NQMMM = NQMMMATOMS()
      IF(NQMMM.GT.0) THEN
         IF(MASWRK) WRITE(IW,5070)
         CALL ABRT
      END IF
C
C         MDTYP is no longer an input variable, since it is easy to set.
C         TYPMD=1: only EFP particles are present
C         TYPMD=2: there are QM atoms, and possibly also EFP particles
C
       IF(NAT.EQ.0) THEN
          TYPMD = 1
          MDTYP = EFP
       ELSE
          TYPMD = 2
          MDTYP = ABINIT
       ENDIF
C
C         initialize some conversion factors
C
      CALL MDCONV
C
C  Insert another parameter into input: septol = separation
C  tolerance between atoms of different molecules--used in
C  polarization and exchange repulsion calculations.
C
C   *** set default variable values for $md group ***
C
      MDINT = VVERLET
C       Verlet stepper option: 0=NVE, 1=NVT, 2=NOSE_HOOVER CHAIN NVT
      NVTNH = -1   ! WHICH MUST BE CHANGED BELOW
C       step data, dt is time step in seconds (1d-15 is a femtosecond)
      DT = 1.0D-15
      NSTEPS = 10000
C       total time completed in previous MD runs, units=seconds
      TTOTAL = 0.0D+00
C       output frequency
      JEVERY = 10
      KEVERY = 100
c
C       bath temperature, for possible NVT (also used by MBR/MBT flag)
c       Now for REMD, we should have multiple temperatures.
c
chc
      do i=1,NRepca
         batht(i)=300.00d+00
      enddo
c      BATHT = 300.00D+00
C       velocities set in random directions, to BATHT
      RSRAND = .FALSE.
      NRAND = 1000
C       velocities are rescaled if T<(BATHT-DTEMP) or T>(BATHT+DTEMP)
      RSTEMP = .FALSE.
      DTEMP = 100.0D+00
C       turn off either rescaling after so many steps, to do NVE
      NVTOFF = 0
C       step number at which to begin computing properties
      NPROP  = 0
C       this is probably meant to provide a NPT ensemble, at least,
C       a non-boxed constant pressure droplet type of run.
C       It is not documented, or printed.
      NVTP    = .FALSE.
C       options for the initial conditions, no default is selected
      READ    = .FALSE.
      MBT     = .FALSE.
      MBR     = .FALSE.
      QRAND   = .FALSE.
C       final output if PBC is used.
      PBCOUT  = .FALSE.
      PBCWRI  = .FALSE.   ! NOT AN INPUT
C       these two relate to RDF data collection
      PROD    = .FALSE.
      DELR = 0.02D+00
c
c     SSBP and CCMS Option
c     SSBP stands for Spherical Solvent Boundary Potential and the SSBP
c     potential corresponds to a constant temperature and constant pressure
c     system.
c     CCMS stands for constraint of center of mass (QM). It is used to keep
c     QM atoms near the center of Spherical Solvent Boundary Potential
      ssbp=.false.
      ccms=.false.
      droff(1)=1.0D+10
      droff(2)=1.0D+10
      sforce=zero
      cforce=zero
      tmass(1)=zero
      tmass(2)=zero
      tmass(3)=zero
c     Umbrella sampling options.
      usamp=.false.
      iustyp=0
      do i=1,10
         uforce(i)=0
         ipair(5*i-4)=0
         ipair(5*i-3)=0
         ipair(5*i-2)=0
         ipair(5*i-1)=0
         ipair(5*i)=0
         rzero(i)=0
      enddo
c     Note that we only allow upto 50 movemm EFP/MM
      do i=1,50
         INDEXOH(i)=0
         movemm(i)=0
      enddo     
C
C       zero out initial velocity data items, set their dimensions
      IBASE=20
      KQNAM(IBASE+1)= 100*3*NAT + 3
      IF(NAT.GT.0) CALL VCLR(TVELQM,1,3*NAT)
      KQNAM(IBASE+2)= 100*3*NFRG + 3
      KQNAM(IBASE+3)= 100*3*NFRG + 3
      KQNAM(IBASE+4)= 100*3*NFRG + 3
      KQNAM(IBASE+5)= 100*4*NFRG + 3
      KQNAM(IBASE+6)= 100*4*NFRG + 3
      KQNAM(IBASE+7)= 100*4*NFRG + 3
      IF(NFRG.GT.0) THEN
         CALL VCLR(TVEL  ,1,3*NFRG)
         CALL VCLR(RVEL  ,1,3*NFRG)
         CALL VCLR(RMOM  ,1,3*NFRG)
         CALL VCLR(QUAT  ,1,4*NFRG)
         CALL VCLR(QUAT1D,1,4*NFRG)
         CALL VCLR(QUAT2D,1,4*NFRG)
      END IF
      DO I=1,NFRG
         QUAT(1,I) = 1.0D+00
      ENDDO
C
C       *** read user-defined variables from $md group
C
      IRET = 0
      CALL NAMEIO(IR,IRET,MD,NNAM,QNAM,KQNAM,
     *            MDINT,NSTEPS,TTOTAL,BATHT,  DELR,DT,JEVERY,KEVERY,
     *            RSTEMP,DTEMP,RSRAND,NRAND,
     *            READ,MBT,MBR,QRAND,  PROD,PBCOUT,NVTOFF,NVTNH,
     *            TVELQM,TVEL,RMOM,RVEL,QUAT,QUAT1D,QUAT2D,
     *            NPROP,NVTP,SSBP,DROFF,sforce,usamp,ipair,uforce,
     *            rzero,iustyp,LEVERY,mremd, indexOH,movemm,CCMS,
     *            cforce,0, 
     *            0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0)
      IF ( IRET .EQ. 1 .OR. IRET .EQ. 2 ) THEN
         IF(MASWRK) WRITE(IW,*) 'ERROR READING $MD GROUP'
         CALL ABRT
      ENDIF
C
C        *** check some variable values ***
C
      IF(NVTNH.EQ.-1) THEN
         IF(RSTEMP .OR. RSRAND) THEN
            NVTNH=2
         ELSE
            NVTNH=0
         END IF
      END IF
C
C     open the trajectory file, this contains the md trajectory basics:
C        coordinates, velocities, energies
C
      if (MREMD.EQ.0) then
         IPTRAJ = 4
         CALL SEQOPN( IPTRAJ, 'TRAJECT', 'NEW', .FALSE., 'FORMATTED')
         IPRST=35
         CALL SEQOPN( IPRST, 'RESTART', 'NEW', .FALSE., 'FORMATTED')
      ENDIF
C
c
c     For REMD, open files in the group scope.
c     We use GDDI for REMD. Therefore, if ngroups.le.1, we do
c     regular MD.
c     Also current REMD is only for NVT runs,
c     so IF NVTNH is not 2, abort.
c     Also we override JEVERY, if JEVERY.gt.LEVERY.
c
      if(mremd.ne.0.and.nfg.ne.0) call abrt
c
c     if(isgddi.and.(mremd.ne.0.or.usamp)) call gddi_scope(ddi_group)
      Tmin=batht(1)
      if(isgddi.and.mremd.ne.0) then
c
         IPTRAJ = 4
         CALL SEQOPN( IPTRAJ, 'TRAJECT', 'NEW', .FALSE., 'FORMATTED')
c        RESTART FILE
         IPRST=35
         CALL SEQOPN( IPRST, 'RESTART', 'NEW', .FALSE., 'FORMATTED')
c        REMD FILE
         IPREMD=44
         CALL SEQOPN( IPREMD, 'REMD', 'NEW', .FALSE., 'FORMATTED')
c
         if (NVTNH.ne.2) then
            if (maswrk) then
            WRITE(IW,*)
            WRITE(IW,*)'ERROR! Current REMD only supports NVT.'
            WRITE(IW,*)
            endif
            CALL ABRT
         endif
         if (Ngroups.gt.Nrepca) then
            if (maswrk) then
            WRITE(IW,*)
            WRITE(IW,*)'ERROR! Your ngroups is greater than Nrepca.'
            WRITE(IW,*)
            endif
            CALL ABRT
         endif
         bathtmp=batht(mygroup+1)
c        We override JEVERY, if JEVERY.gt.LEVERY
         if (JEVERY.gt.LEVERY) JEVERY=LEVERY
      else
         bathtmp=batht(1)
         Levery=nsteps
      endif
C
      NERR = 0
C
      OK=.FALSE.
      IF(MDINT.EQ.VVERL) MDINT=VVERLET   ! PREVIOUSLY ALLOWED SPELLING
      IF(MDINT.EQ.FROG)    OK=.TRUE.
      IF(MDINT.EQ.VVERLET) OK=.TRUE.
      IF(.NOT.OK) THEN
         IF(MASWRK) WRITE(IW,5005) MDINT
         NERR=NERR+1
      END IF
      IF(MDINT.EQ.FROG)    INTMD = 1
      IF(MDINT.EQ.VVERLET) INTMD = 2
C
C        we should be a restart, or a clean initial guess, make sure
C        the user selected one, as the default for both is .FALSE.
      IF(READ .OR. (MBT.OR.MBR)) THEN
         CONTINUE
      ELSE
         IF(MASWRK) WRITE(IW,5010)
         NERR=NERR+1
      END IF
C
      IF(RSTEMP .AND. RSRAND) THEN
         IF(MASWRK) WRITE(IW,5020)
         NERR=NERR+1
      END IF
C
      IF(DT.GT.5.0D-14) THEN
         IF(MASWRK) WRITE(IW,5030)
         NERR = NERR + 1
      ENDIF
C
C  ---- check for PBC
C
      IF (XBOX.LT.ZERO .OR. YBOX.LT.ZERO .OR. ZBOX.LT.ZERO) THEN
         IF(MASWRK) WRITE(IW,5040) XBOX,YBOX,ZBOX
         NERR=NERR+1
      END IF
C
      IF(NERR.GT.0) THEN
         IF(MASWRK) WRITE(IW,5050) NERR
         CALL ABRT
      ENDIF
C
C        *** output $md variable values ***
C
      IF (MASWRK) THEN
         if (isgddi.and.usamp) WRITE(IW,6005) mygroup
         if (isgddi.and.mremd.ne.0) then
         WRITE(IW,6100) MDINT, NVTNH, DT, NSTEPS, TTOTAL,
     *                  JEVERY, KEVERY,LEVERY,
     *                  READ, MBT, MBR, QRAND, PROD, DELR, PBCOUT,
     *         NVTOFF, NPROP,ssbp,sforce,droff(1),droff(2),ccms,cforce,
     *                  usamp,uforce(1),uforce(2),uforce(3),uforce(4),
     *                  iustyp,rzero(1),rzero(2),rzero(3),rzero(4)
         WRITE(IW,6101)
         do i=1,ngroups
            WRITE(IW,6102) i,batht(i)
         enddo
            WRITE(IW,*) '  '
            WRITE(IW,*) '        Replica Exchange MD is turned on...'
            WRITE(IW,*) '  '
         else
         WRITE(IW,6000) MDINT, NVTNH, DT, NSTEPS, TTOTAL, BATHTmp,
     *                  JEVERY, KEVERY,
     *                  READ, MBT, MBR, QRAND, PROD, DELR, PBCOUT,
     *         NVTOFF, NPROP,ssbp,sforce,droff(1),droff(2),ccms,cforce,
     *                  usamp,uforce(1),uforce(2),uforce(3),uforce(4),
     *                  iustyp,rzero(1),rzero(2),rzero(3),rzero(4)
         endif
         IF(RSTEMP) WRITE(IW,6001) RSTEMP, DTEMP
         IF(RSRAND) WRITE(IW,6002) RSRAND, NRAND
         IF(.NOT.RSTEMP .AND. .NOT.RSRAND) WRITE(IW,6003)
         WRITE(IW,6010) NAT, NFRG
      ENDIF
c     
c     Initializations for umbrella sampling, SSBP or CCMS.
      if (usamp.or.ssbp.or.ccms) call initconstmd
C
      CALL MDNOSEINIT
C
      IWATER = .FALSE.
      IF(NDFRG.EQ.1 .AND. (FRGNAM(1).EQ.'H2OSPC' .OR.
     *                     FRGNAM(1).EQ.'H2ORHF' .OR.
     *                     FRGNAM(1).EQ.'H2ODFT' .OR.
     *                     FRGNAM(1).EQ.'WATER ')) IWATER = .TRUE.
C
C        read $RDF group, if any
C
      CALL RDFX
C
C        READ PROPERTy input group, if any, and Initialize
C
      CALL RDMDPRP(PROD)
      CALL INIPRP
C
      NPRINT= -5
C
      IF (NFG.NE.0) THEN
        NDPNT=0
        IF(IAND(NGUESS,8).NE.0) NDPNT=(NFG*NFG-NFG)/2
        NDAR30=0
        IF(IAND(MODPAR,512+1024).NE.0) NDAR30=1+NFG*2*2
C
        CALL VALFM(LOADFM)
        LIDMPNT = LOADFM + 1
        LIDDPNT = LIDMPNT + (NDAR30-1)/NWDVAR+1
        LAST    = LIDDPNT + (NDPNT-1)/NWDVAR+1
C
        LSCZVFLG = IAND(MODGRD,32).NE.0.AND.IAND(MODPAR,512).NE.0
        IF (LSCZVFLG) THEN
          LIPTZVEC = LAST
C         LAST     = LIPTZVEC + 2*NFG/NWDVAR + 1
          LIPTLG   = LIPTZVEC + 2*NFG/NWDVAR + 1
          LAST     = LIPTLG   +   NFG/NWDVAR + 1
        END IF
        NDFMO = LAST-LOADFM-1
        CALL GETFM(NDFMO)
      END IF
C
C
C        *** calculate initial energy and forces ***
C
      IF (TYPMD.EQ.1) THEN
         CALL EFCM
         CALL TIMIT(1)
         CALL ENEDEF
         CALL TIMIT(1)
      ELSE
         CALL ENEDAB
      ENDIF
C
      LENSET=3*NFRG+3*NAT
      CALL VALFM(LOADFM)
      LSET = LOADFM + 1
      LAST = LSET   + LENSET
      NEED = LAST-LOADFM-1
      CALL GETFM(NEED)
C
C        *** initialize various quantities, convert to quaternions ***
C              set for atoms follows setting up the efp particles.
C
      IF(NFRG.GT.0) THEN
         CALL MODSET
C
C         if reading md trajectory restart information...
C
         IF(READ) THEN
            FACTOR = 1.0D+00 / 1.0D-12
            DO I = 1,NFRG
               VX(I) = TVEL(1,I)*FACTOR
               VY(I) = TVEL(2,I)*FACTOR
               VZ(I) = TVEL(3,I)*FACTOR
               VXO(I)= TVEL(1,I)*FACTOR
               VYO(I)= TVEL(2,I)*FACTOR
               VZO(I)= TVEL(3,I)*FACTOR
               QW(I) = QUAT(1,I)
               QX(I) = QUAT(2,I)
               QY(I) = QUAT(3,I)
               QZ(I) = QUAT(4,I)
            ENDDO
C
C  For frog, setup ang. mom.
C  for verl, set w and qdots..
C
            IF(MDINT.EQ.FROG) THEN
               DO I=1,NFRG
                 OX(I) = RMOM(1,I)*FACTOR
                 OY(I) = RMOM(2,I)*FACTOR
                 OZ(I) = RMOM(3,I)*FACTOR
               ENDDO
            ELSE
               DO I=1,NFRG
                 WX(I) = RVEL(1,I)*FACTOR
                 WY(I) = RVEL(2,I)*FACTOR
                 WZ(I) = RVEL(3,I)*FACTOR
                 QW1(I) = QUAT1D(1,I)
                 QX1(I) = QUAT1D(2,I)
                 QY1(I) = QUAT1D(3,I)
                 QZ1(I) = QUAT1D(4,I)
                 QW2(I) = QUAT2D(1,I)
                 QX2(I) = QUAT2D(2,I)
                 QY2(I) = QUAT2D(3,I)
                 QZ2(I) = QUAT2D(4,I)
               ENDDO
            ENDIF
         ELSE
C
C         ...otherwise we must generate initial conditions
C         random Maxwell/Boltzmann trans. vel. distribution, or zero
            IF(MBT) THEN
               CALL NORMT(BATHTmp,NAT,XX(LSET),LENSET)
            ELSE
               CALL CLRTVE(NAT,NFRG)
            ENDIF
C
C         random Maxwell/Boltzmann   rot. vel. distribution, or zero
            IF(MBR) THEN
               CALL NORMW(BATHTmp,XX(LSET),LENSET)
            ELSE
               CALL CLRVEL(NFRG)
            ENDIF
C
C                  generate the quaternions at random, or
C                  evaluate them from the EFP particle coordinates
            IF(QRAND) THEN
               CALL RANDQ
            ELSE
               CALL EU2QUT
            ENDIF
C
C        INQDOT sets quaternion derivatives from rotational velocity
            IF(MDINT.EQ.FROG) THEN
               CALL CLRMOM(NFRG)
            ELSE
               CALL INQDOT
            ENDIF
C
         ENDIF  ! END READ RESTART/INITIALIZE BLOCK
      END IF
C
      IF (NAT.GT.0) THEN
         IF(READ) THEN
            FACTOR = 1.0D+00 / 1.0D-12
            DO I = 1,NAT
               VXQM(I) = TVELQM(1,I)*FACTOR
               VYQM(I) = TVELQM(2,I)*FACTOR
               VZQM(I) = TVELQM(3,I)*FACTOR
            ENDDO
         ELSE
C              next call is repetive and redundant if NFRG>0,
C              but invoke it anyway, in case this is a purely QM run.
            IF(MBT) CALL NORMT(BATHTmp,NAT,XX(LSET),LENSET)
         ENDIF
      ENDIF
C
      IF(PROD) CALL INITGR
c
C         output initial coords and velocities
C
      IF(MASWRK) THEN
         WRITE(IW,7010) E
         WRITE(IW,7020) E*AU2KCAL
      ENDIF
      if ((isgddi.and.mremd.ne.0).and.(bathtmp.eq.tmin))
     *       CALL MDPRTCORVEL(0,TTOTAL,INTMD,ipremd)
      CALL MDPRTCORVEL(0,TTOTAL,INTMD,iptraj)
      if (maswrk) CALL SEQREW(IPRST)
      CALL MDPRTCORVEL(0,TTOTAL,INTMD,iprst)
      IF(TYPMD.EQ.1) THEN
            CALL MDRPREF(0,TTOTAL,JEVERY)
      ELSE
            CALL MDRPRAB(0,TTOTAL,JEVERY)
      ENDIF
      CALL TIMIT(1)
C
      LT = 1
      JT = 1
      KT = 1
      RNDSTEP=1
      KOUNT=0
C
C  Translational and Rotational KE at time 0
C
      CALL MDKIN
C
C          ekint = half * ek2kcal * totmas * ekint
c     Ekint : Kinetic energy
c
      EKINT = EK2KCAL * EKINT
      EKINR = EK2KCAL * EKINR
C
C          main loop, computing NSTEPS points on the MD trajectory
C       note that ISTEP does not include the previous trajectory runs!
C
c
      DO 2000 ISTEP=1,NSTEPS
        TTOTAL = TTOTAL + DT
C
        IF(PBCOUT.AND.ISTEP.EQ.NSTEPS) PBCWRI=.TRUE.
C
C          switch to NVE production run if this step is NVTOFF'th step
C
        IF(ISTEP.EQ.NVTOFF) THEN
           IF (MASWRK) WRITE(IW,7030)
           NVTNH  = 0
           RSTEMP = .FALSE.
           RSRAND = .FALSE.
           NVTP   = .FALSE.
           PROD   = .TRUE.
           CALL INITGR
        END IF
C
C   Integrate equations of motion to take this MD step.
C
C   Only calculate energy/grad in this outside loop if doing leapfrog;
C   energy/grad calculation done within integration for vverlet...
C
C   Leapfrog stepper:
C
        IF(MDINT.EQ.FROG) THEN
           IF (TYPMD.EQ.1) THEN
              CALL ENEDEF
           ELSE
              CALL ENEDAB
           END IF
           CALL FROGMOVE(INTMD,ISTEP,NPROP)
        ENDIF
C
C   Velocity verlet stepper:
C   need to change torque to torque/inertia on first time through
C
        IF(MDINT.EQ.VVERLET) THEN
           IF(ISTEP.EQ.1.AND.NFRG.GT.0) CALL TORQMO
           CALL VVERMOVE(INTMD,ISTEP,NPROP)
        ENDIF
C
c----------------------------------------------------------------------
c                  QM/EFP-REMD(Replica-Exchange MD)
c                        by Choi and Fedorov
c----------------------------------------------------------------------
c     If (ngroups.gt.1.and.mremd.ne.0) we are doing REMD.
c     If it is not, we set LEVERY=NSTEPS.
c     If (LEVERY.eq.NSTEPS), we don't do REMD.
c     So if you want to turn on the REMD, you should have at least two groups
c     of GDDI and set proper LEVERY.
c     Default LEVERY=1000. However, if (ngroups.le.1) LEVERY=NSTEPS.
c
c     We First need to go to the world, then exchange temperatures
c     if conditions are met. Then we come back to groups.
c
      if ((lt.eq.LEVERY).and.(isgddi.and.mremd.ne.0)) then
         IexchCnt=IexchCnt+1
c        From now on, we are doing REMD by exchanging Temperature.
C        Also one should know current REMD is only for NVT runs!
c        Put My group's Energy and Temperature to arrays.
         call vclr(Repca_E,1,Ngroups)
         call vclr(Repca_T,1,Ngroups)
         do i=1,ngroups
            MyAccept(i)=0
         enddo
         Repca_E(mygroup+1)=E/nproc
         Repca_T(mygroup+1)=Bathtmp/nproc
c        Then we go to the world.
         call gddi_scope(ddi_world)
         call ddi_gsumf(3000,Repca_E,ngroups)
         call ddi_gsumf(3001,Repca_T,ngroups)
c
c        Now we compute exp(-Repca_D)
c
         do iexch=1,ngroups/2
c          We have to make sure randoms are syncronized across
c          all nodes.
           call ranbs(iseed,Repca_rand)
           if (ieoremd.eq.1) then
              mT=iexch*2-1
              nT=iexch*2
              mR=MyTPos(mT)
              nR=MyTPos(nT)
           else
              mT=iexch*2
              if (iexch.eq.ngroups/2) then
                 nT=1
              else
                 nT=iexch*2+1
              endif
              mR=MyTPos(mT)
              nR=MyTPos(nT)
           endif
c          The condition.
           Repca_D=Repca_Factor
     *         *(1/Repca_T(nR)-1/Repca_T(mR))
     *         *(  Repca_E(mR) - Repca_E(nR))
c       write(IW,*) 'me,mygroup,exp(-D),Rand',mygroup,
c     *  exp(-Repca_D),Repca_rand
c
           if (Repca_D.le.0) then
              Myaccept(mR)=nR
              Myaccept(nR)=mR
              MyTPos(mT)=nR
              MyTPos(nT)=mR
           else
c              Rep_crit=exp(-Repca_D)
              if (exp(-Repca_D).gt.Repca_rand) then
                 Myaccept(mR)=nR
                 Myaccept(nR)=mR
                 MyTPos(mT)=nR
                 MyTPos(nT)=mR
              endif
           endif
c
         enddo
         IEOREMD=-ieoremd
c
c        Print out the exchange results.
c
         if(maswrk) then
           write(iw,8000) IexchCnt
           NExch=0
           do i=1,ngroups
             if (MyAccept(i).ne.0) then 
               Write(iw,8100) i,Repca_E(i),Repca_T(i),
     *                        Repca_T(MyAccept(i))
             else if (MyAccept(i).eq.0) then 
               Write(iw,8100) i,Repca_E(i),Repca_T(i),
     *                        Repca_T(i)
             endif
             if (Myaccept(i).ne.0) NExch=NExch+1
           enddo
           write(IW,8110) real(NExch)/real(ngroups)*100
         endif
c
c        Now MyAccept has the exchange information!
c        We go back to group now.
c
         call gddi_scope(ddi_group)
c
c        Before exit, we should do temperature exchange and rescaling
c
         if (Myaccept(mygroup+1).gt.0) then
             T_New=Repca_T(MyAccept(mygroup+1))
c            We rescale the valocity.
             CALL REMD_V_RESCALE(T_new)
c            Set new EKT0 and BathTmp
             EKT0 = 1.987216D-03 * T_New / EK2KCAL
             BATHTmp=T_New
         endif
         lt=0
      endif
c
      Lt=lt+1
c----------------------------------------------------------------------
c                              End of REMD
c----------------------------------------------------------------------
C
C       next comes two types of output, JEVERY and KEVERY.
C
C        *** every JEVERY timesteps:            ***
C        ***     report simulation quantities   ***
C        ***     collect g(r)s                  ***
C             use calcgr only if water
C             use c2gr only if $RDF group was read
C             always use ccomgr (COM-COM)
C
        IF (JT.EQ.JEVERY) THEN
           IF(PROD) THEN
              IF (IWATER) CALL CALCGR
              IF (NRDF.GT.0) CALL C2GR
              CALL CCOMGR
           END IF
C
C             CALCULATE PROPERTIES, if we are far enough into the run
           IF(ISTEP.GE.NPROP) THEN
              KOUNT = KOUNT + 1
              IF (PRESSR)  CALL PRESUR(KOUNT)
              IF (DIFUSN)  CALL DIFFSN(KOUNT)
              IF (DIPOLEP) CALL DIPPRP(KOUNT)
              IF (HTVAP)   CALL HVAP(KOUNT)
              IF (COORDN)  CALL CRDNMB(KOUNT)
              IF (RRELAX)  CALL ROTRELAX(KOUNT)
              IF (HBLFE)   CALL HBLIFE(KOUNT)
           ENDIF
C                    output md energies, etc. to .dat
           IF(TYPMD.EQ.1) THEN
              CALL MDRPREF(ISTEP,TTOTAL,KOUNT)
           ELSE
              CALL MDRPRAB(ISTEP,TTOTAL,KOUNT)
           ENDIF
C
           IF(TYPMD.EQ.1) THEN
              IF(MASWRK) WRITE(IW,7070) '  ROT.KE TEMP = ',TEMPTR(EKINR)
              IF(MASWRK) WRITE(IW,7070) 'TRANS.KE TEMP = ',TEMPTR(EKINT)
           ENDIF
           JT = 0
        ENDIF
        JT = JT + 1
C
C        *** every KEVERY timesteps: ***
C        ***    output configuration ***
C        ***    output g(r)s         ***
C
c
        IF (KT.EQ.KEVERY) THEN
C          output md configurations, velocities, grad, torq, com
           if ((isgddi.and.mremd.ne.0).and.(bathtmp.eq.tmin))
     *         CALL MDPRTCORVEL(ISTEP,TTOTAL,INTMD,ipremd)
           CALL MDPRTCORVEL(ISTEP,TTOTAL,INTMD,iptraj)
           if (maswrk) CALL SEQREW(IPRST)
           CALL MDPRTCORVEL(0,TTOTAL,INTMD,iprst)
           IF(PROD) THEN
              IF (IWATER) CALL WRIGR
              IF (NRDF.GT.0) CALL WRIG2GR
              CALL WRICOMGR
            END IF
            KT = 0
        ENDIF
        KT = KT + 1
C
C       MD loop ends with two different ways of creating an NVT ensemble
C
C       first option is Maxwell-Boltzmann rescaling, using
C       the same routines as for MBR/MBT initial conditions.
C       note that these assign velocity directions at random,
C       from the current particle positions.
C
        IF (RSRAND) THEN
           IF (RNDSTEP.EQ.NRAND) THEN
              IF(MASWRK) WRITE(IW,7040) ISTEP
              CALL NORMT(BATHTmp,NAT,XX(LSET),LENSET)
              CALL NORMW(BATHTmp,XX(LSET),LENSET)
              CALL EU2QUT
              CALL INQDOT
              RNDSTEP=0
           ENDIF
           RNDSTEP=RNDSTEP+1
        ENDIF
C
C       the other option is a rescaling of the current velocities,
C       but only if we've drifted more than DTEMP degrees away from
C       the desired bath temperature.
C
        IF(RSTEMP) THEN
           EKIN=EKINT+EKINR
           TEMPT=TEMPMD(EKIN)
           LVELSET = TEMPT .GT. BATHTmp+DTEMP .OR.
     *               TEMPT .LT. BATHTmp-DTEMP
           IF (ISTEP.EQ.1) THEN
              IF(READ) THEN
                 IF(MASWRK) WRITE(IW,7051)
              ELSE
                 IF(MASWRK) WRITE(IW,7050) ISTEP
                 CALL VELOCITY_RESCALE
              END IF
           ELSE
              IF (LVELSET) THEN
                 IF(MASWRK) WRITE(IW,7050) ISTEP
                 CALL VELOCITY_RESCALE
              END IF
           END IF
        END IF
C
 2000 CONTINUE
C
      CALL RETFM(NEED)
C
      IF (NFG.NE.0) THEN
        CALL RETFM(NDFMO)
        IF (LSCZVFLG) CALL RETZVEC
        CALL RETDD
      END IF
C
      IF(MASWRK) WRITE(IW,9010)
      CALL TIMIT(1)
c     if(isgddi.and.(mremd.ne.0.or.usamp)) call gddi_scope(ddi_world)
      if(isgddi.and.nfg.eq.0) call gddi_scope(ddi_world)
      RETURN
C
C          error messages for input variables
 5005 FORMAT(1X,'ERROR, UNKNOWN MD INTEGRATOR CHOSEN: ',A8)
 5010 FORMAT(1X,'*** ERROR SPECIFYING INITIAL CONDITIONS ***'/
     *       1X,'SET READ=.TRUE. FOR RESTARTING A MD TRAJECTORY, OR'/
     *       1X,'SET BOTH MBT AND MBR TO .TRUE. TO INITIALIZE A MD',
     *          ' TRAJECTORY')
 5020 FORMAT(1X,'ERROR: BOTH NVT OPTIONS SELECTED (RSRAND AND RSTEMP)')
 5030 FORMAT(1X,'ERROR: TIMESTEP (DT) TOO LARGE FOR STABLE',
     *               ' INTEGRATION')
 5040 FORMAT(1X,'ERROR: PBC BOX SIZE = ',3F14.6,' BOHR'/)
 5050 FORMAT(/1X,'***** ',I2,' ERROR(S) HAVE BEEN DETECTED',
     *               ' IN $MD. *****',/)
 5070 FORMAT(1X,'RUNTYP=MD SUPPORTS QM AND/OR EFP PARTICLES,'/
     *       1X,'BUT DOES NOT WORK WITH QM/MM ATOMS IN SIMOMM MODEL')
C
C          printing of options selected
 6000 FORMAT(/10X,'$MD INPUT OPTIONS'/10X,17('-')/
     *        5X,'MDINT = ',A8,9X,'NVTNH =',I8/
     *        5X,'DT    = ',1P,E8.2,0P,9X,'NSTEPS=',I8,
     *            9X,'TTOTAL=',1P,E12.2,0P,' SEC.'/
     *        5X,'BATHT = ',F8.2/
     *        5X,'JEVERY= ',I8,9X,'KEVERY=',I8/
     *        5X,'READ  = ',L8/
     *        5X,'MBT   = ',L8,9X,'MBR   =',L8,9X,'QRAND =',L8/
     *        5X,'PROD  = ',L8,9X,'DELR  =',F8.2,9X,'PBCOUT=',L8/
     *        5X,'NVTOFF= ',I8,9X,'NPROP =',I8/
     *        5X,'SSBP  = ',L8,9X,'SForce=',F8.2,9X,'DROFF =',2F8.2/
     *        5X,'CCMS  = ',L8,9X,'CForce=',F8.2,9X/
     *        5X,'USAMP = ',L8,9X,'UForce=',4F8.2/
     *        5X,'IUSTYP= ',I8,9X,'Rzero =',4F8.2)
 6001 FORMAT(5X,'TEMPERATURE RANGE NVT ENSEMBLE CHOSEN: RSTEMP=',L2,
     *          ', DTEMP=',F8.2,' DEGREES')
 6002 FORMAT(5X,'RANDOM NVT ENSEMBLE CHOSEN: RSRAND=',L2,
     *          ' EVERY NRAND=',I8,' STEPS')
 6003 FORMAT(5X,'NVE ENSEMBLE CHOSEN')
 6005 FORMAT(/5X,'Using GDDI parallelisation of umbrella sampling.',
     *       /5x,'This simulation is done on group',I8/)
 6010 FORMAT(5X,'THIS MD SIMULATION HAS ',I5,' QM ATOMS, AND',
     *       I5,' EFFECTIVE FRAGMENTS')
 6100 FORMAT(/10X,'$MD INPUT OPTIONS'/10X,17('-')/
     *        5X,'MDINT = ',A8,9X,'NVTNH =',I8/
     *        5X,'DT    = ',1P,E8.2,0P,9X,'NSTEPS=',I8,
     *            9X,'TTOTAL=',1P,E12.2,0P,' SEC.'/
     *        5X,'JEVERY= ',I8,9X,'KEVERY=',I8,9x,'LEVERY=',I8/
     *        5X,'READ  = ',L8/
     *        5X,'MBT   = ',L8,9X,'MBR   =',L8,9X,'QRAND =',L8/
     *        5X,'PROD  = ',L8,9X,'DELR  =',F8.2,9X,'PBCOUT=',L8/
     *        5X,'NVTOFF= ',I8,9X,'NPROP =',I8/
     *        5X,'SSBP  = ',L8,9X,'SForce=',F8.2,9X,'DROFF =',2F8.2/
     *        5X,'CCMS  = ',L8,9X,'CForce=',F8.2,9X/
     *        5X,'USAMP = ',L8,9X,'UForce=',4F8.2/
     *        5X,'IUSTYP= ',I8,9X,'Rzero =',4F8.2/)
 6101 FORMAT(10X,'*** Replica-Exchange MD Stats ***'/
     *       10x,'---------------------------------'/
     *       10x,'     Replica     Temperature     '/
     *       10x,'---------------------------------')
 6102 FORMAT(13X,I5,7X,F10.2,' K')
C
 7010 FORMAT(5X,'INITIAL POTENTIAL ENERGY = ',F18.10,' AU')
 7020 FORMAT(5X,'INITIAL POTENTIAL ENERGY = ',F18.10,' KCAL/MOL',/)
 7030 FORMAT(1X,'===== END OF EQUILIBRATION ===== '/
     *       1X,'   NVE PRODUCTION RUN STARTED')
 7040 FORMAT(1X,'*** RESETTING RANDOM MAXWELL/BOLTZMANN VELOCITIES',
     *          ' AT MD STEP',I8)
 7050 FORMAT(1X,'*** RESCALING VELOCITIES AFTER MD STEP NO.',I8,' ***')
 7051 FORMAT(1X,'*** RESTARTING WITH UN-RESCALED VELOCITIES ***')
 7070 FORMAT(5X,A,F10.2)
 8000 FORMAT(5X,'******** Replica Temperature Exchange Results *******'/
     *       5x,'      The number of Replica Exchanges = ',I5/
     *       5x,' Replica      Energy      Before       After (Kelvin)'/
     *       5x,'-----------------------------------------------------')
 8100 FORMAT(8X,I5,3X,F11.6,3x,F7.2,2x,'--->',2x,F7.2)
 8110 FORMAT(/12X,'REMD Exchange Ratio(%) = ',F7.2/)
C
 9010 FORMAT(1X,'.... DONE WITH THIS PORTION OF THE MD TRAJECTORY ....')
      END
C
C*MODULE MDEFP   *DECK TEMPTR
      DOUBLE PRECISION FUNCTION TEMPTR(EK)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXFRG=1050, MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
C
C       tempmd = 2.0d+00 * ek / (6.0d+00*nfrg-3.0d+00)
C     *                 / 1.987216d-03
C--pre-IBM
C        temptr = 2.0d+00 * ek / (3.0d+00*nfrg-3.0d+00)
C     *                 / 1.987216d-03
C
      TEMPTR = 2.0D+00 * EK / (3.0D+00*NFRG) / 1.987216D-03
      RETURN
      END
C
C*MODULE MDEFP   *DECK ENEDAB
C>
C>     @brief energy and forces for MD 
C>
C>     @details Calculate energy and forces for one step during MD. 
C>
C>     @author unknown 
C>
      SUBROUTINE ENEDAB
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000)
      PARAMETER (MXFGPT=12000, MXFRG=1050,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (NRepca=100)
      double precision mdint
      logical ccms,ssbp,usamp,rstemp,rsrand,prod
      LOGICAL GOPARR, DSKWRK, MASWRK
      logical ISGDDI,PAROUT,INITGDDI, ISGDDIs,wasgddi,wasgddis
C
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FUNCT / E, EG(3*MXATM)
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /VIRPR / VIR(3), PRXX, PRYY, PRZZ
      common /cstpot/ DROFF(2),SFORCE,uforce(10),rzero(10),dtemp,
     *                rzeroC(3,MXATM),Tmin,uV,batht(NRepca),mdint,
     *                ipair(50),iustyp,ncst,nrand,nvtoff,
     *                jevery,kevery,levery,mremd,
     *                rstemp,rsrand,prod,SSBP,ccms,Usamp,IndexOH(50),
     *                movemm(200),nefpmv,cforce,tmass(3)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /EFPOTD/ METHPOL,INABIO,MOVE,nfrag
      DATA GRDKWD/8HGRADIENT/
C
C        ***************************************
C        *** Calculate energy and forces     ***
C        ***************************************
C
C     CALL GRADX
      IF (NFG.NE.0) THEN
        RUNTYPS = RUNTYP
        RUNTYP  = GRDKWD
        isgddis = isgddi
        wasgddis = wasgddi
        if(mremd.ne.0.and.isgddi) then
          isgddi = .false.
          wasgddi = .true.
        endif
c       pretend no GDDI for FMO/REMD.
        CALL FMOX(1)
        isgddi = isgddis
        wasgddi= wasgddis
        RUNTYP  = RUNTYPS
      ELSE
        CALL GRADX
      END IF
C
      F2F = -AU2KCAL / EK2KCAL
      DO I = 1, NAT*3
         EG(I) = EG(I)*F2F
      ENDDO

c
c     Constraining quantum atoms for umbrella sampling.
c     iustyp = 0 : Normal constraining for upto 2 bonds
c     iustyp = 1 : Asymmetric coordinate requires three values in ipair
c     iustyp = 2 : Angle constrain.
c     iustyp = 3 : Torsional constrain.
c     iustyp = 4 : Asymmetric + bond coordinates
c     iustyp = 5 : Asymmtric coordinate + Restraint
c          Restraint coordinate for asymmetric coordinates of umbrella 
c          sampling technique. IPAIR contains three atoms, where atom 1
c          is moving from atom 2 to 3. Current restraint coordinate forces 
c          atom 1 to stay in between atom 2 and 3.     
c     iustyp = 6 : Normal constraining for upto 2 bonds 
c                  based on the minimal energy atomic pair(OH)
c     iustyp = 7 : Asymmtric coordinate  
c                  based on the minimal energy atomic pair(OH)
c     iustyp = 8 : The center of mass coordinates of two parts
c     iustyp = 9 : The center of mass coordinates w.r.t. center of sphere(0,0,0)
c
c     uV is the harmonic potential energy that should be added to total
c     potential energy
      uV=0.0d+00
c
      if (Usamp) then
        if (maswrk) write(iw,1500)
c       Asymmetric coordinate of atom shift reaction.
c       Atom 1 is moving from atom 2 to 3.
        if (iustyp.eq.1) then
           do i=1,ncst
              call asymcor(ipair(i*3-2),uforce(i),f2f,rzero(i),uVt)
              uV=uV+uVt
           enddo
c       Bond constraints
        elseif (iustyp.eq.0) then
           do icst=1,ncst
              call cstbond(ipair(icst*2-1),uforce(icst),
     *            rzero(icst),f2f,uVt)
              uV=uV+uVt
           enddo
c       Angle constraints
        elseif (iustyp.eq.2) then
           do i=1,ncst
              call cstang(ipair(3*i-2),uforce(i),rzero(i),f2f,uVt)
              uV=uV+uVt
           enddo
c       Torsional constraint
c       Journal of Computational Chemistry, Vol. 17, No. 9, 1132-1141 (1996)
        elseif (iustyp.eq.3) then
           do i=1,ncst
              call csttor(ipair(4*i-3),uforce(i),rzero(i),f2f,uVt)
              uV=uV+uVt
           enddo
c
        elseif (iustyp.eq.4) then
c          This section is for 2 dimensional umbrella sampling
c          of atom shift reaction (atom 1 is moving from atom 2 to 3)
c          and bond distance between atom 4 and 5.
c          We first adopt the asymmetric stretching coordinates of
           call asymcor(ipair(1),uforce(1),f2f,rzero(1),uVt)
           uV=uV+uVt
           call cstbond(ipair(4),uforce(2),rzero(2),f2f,uVt)
           uV=uV+uVt
c
        elseif (iustyp.eq.5) then
c          Asymmtric coordinate + Restraint
c          atom 1 is moving from atom 2 to 3.
           call asymcor(ipair(1),uforce(1),f2f,rzero(1),uVt)
           uV=uV+uVt
           call rccor(ipair(1),uforce(2),f2f,uVt)
           uV=uV+uVt
        elseif (iustyp.eq.6) then
c          Flexible atomic pair + Bond constraints
           call rearrangeIPAIR
           do icst=1,ncst
              call cstbond(ipair(icst*2-1),uforce(icst),
     *            rzero(icst),f2f,uVt)
           enddo
        elseif (iustyp.eq.7) then
c          Flexible atomic pair + Asymmtric coordinate + Restraint
c          atom 1 is moving from atom 2 to 3.
           call rearrangeIPAIR
           do i=1,ncst
              call asymcor(ipair(i*3-2),uforce(i),f2f,rzero(i),uVt)
              uV=uV+uVt 
           enddo
        elseif (iustyp.eq.8) then
           call cstcms(f2f,uVt)
           uV=uV+uVt
        elseif (iustyp.eq.9) then
c          Center of Mass Position
           call cstpos(f2f,uVt)
           uV=uV+uVt
        endif
c       Adding Constraint Potential Energy to the total energy
        E=E+uV
c       uV=uV*au2kcal
      endif
C     a.u. ---> K
      VIR(1) = F2F*VIR(1)
      VIR(2) = F2F*VIR(2)
      VIR(3) = F2F*VIR(3)
c
      IF(NFRG.NE.0) THEN 
        if (move.ne.0) then
          DO I = 1, NFRG
            DEFT(1,I) = F2F * DEFT(1,I)
            DEFT(2,I) = F2F * DEFT(2,I)
            DEFT(3,I) = F2F * DEFT(3,I)
            TORQ(1,I) = F2F * TORQ(1,I)
            TORQ(2,I) = F2F * TORQ(2,I)
            TORQ(3,I) = F2F * TORQ(3,I)
          ENDDO
        else
          DO I = 1, NFRG
            DEFT(1,I) = 0
            DEFT(2,I) = 0
            DEFT(3,I) = 0
            TORQ(1,I) = 0
            TORQ(2,I) = 0
            TORQ(3,I) = 0
          ENDDO
        endif
      endif
c
      if (ssbp) call cstssbp(f2f)
      if (ccms) call cstccms(f2f)
C
      RETURN
 1500 format(/5x,'Applying Umbrella Sampling Constraints ...')
      END
C*MODULE MDEFP   *DECK initconstmd
C>
C>     @brief umbrella sampling 
C>
C>     @details Initialise umbrella sampling.  
C>
C>     @author Cheol Ho Choi 
C>
      SUBROUTINE initconstmd
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(NRepca=100, MXATM=2000)
      PARAMETER (PI=3.14159265358979323D+00,zero=0.0d+00)
      logical ccms,ssbp,usamp,rstemp,rsrand,prod
      double precision mdint
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      common /cstpot/ DROFF(2),SFORCE,uforce(10),rzero(10),dtemp,
     *                rzeroC(3,MXATM),Tmin,uV,batht(NRepca),mdint,
     *                ipair(50),iustyp,ncst,nrand,nvtoff,
     *                jevery,kevery,levery,mremd,
     *                rstemp,rsrand,prod,SSBP,ccms,Usamp,IndexOH(50),
     *                movemm(200),nefpmv,cforce,tmass(3)
      COMMON /MASSES/ ZMASS(MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
c
      if (usamp) then
      ncst=0
      if (iustyp.eq.0) then
         do while (uforce(ncst+1).gt.0)
            ncst=ncst+1
            if (ncst.gt.10) then
               WRITE(IW,9020)
               CALL ABRT
            endif
            uforce(ncst)=uforce(ncst)*au2ang**2/au2kcal
            rzero(ncst)=rzero(ncst)/au2ang
         enddo
      elseif (iustyp.eq.1) then
         do while (ipair(3*(ncst+1)).gt.0)
            ncst=ncst+1
            if (ncst.gt.10) then
               WRITE(IW,9020)
               CALL ABRT
            endif
            uforce(ncst)=uforce(ncst)*au2ang**2/au2kcal
            rzero(ncst)=rzero(ncst)/au2ang
         enddo
      elseif (iustyp.eq.2) then
         do while (ipair(3*(ncst+1)).gt.0)
            ncst=ncst+1
            if (ncst.gt.10) then
               WRITE(IW,9020)
               CALL ABRT
            endif
            uforce(ncst)=uforce(ncst)/au2kcal
            rzero(ncst)=rzero(ncst)*pi/180.0d+00
         enddo
      elseif (iustyp.eq.3) then
         do while (ipair(4*(ncst+1)).gt.0)
            ncst=ncst+1
            if (ncst.gt.10) then
               WRITE(IW,9020)
               CALL ABRT
            endif
            uforce(ncst)=uforce(ncst)/au2kcal
            rzero(ncst)=rzero(ncst)*pi/180.0d+00
         enddo
      elseif (iustyp.eq.4) then
         do while (ipair(5*(ncst+1)).gt.0)
            ncst=ncst+1
            if (ncst.gt.10) then
               WRITE(IW,9020)
               CALL ABRT
            endif
            uforce(ncst)=uforce(ncst)*au2ang**2/au2kcal
            rzero(ncst)=rzero(ncst)/au2ang
            uforce(ncst+1)=uforce(ncst+1)*au2ang**2/au2kcal
            rzero(ncst+1)=rzero(ncst+1)/au2ang
         enddo
      elseif (iustyp.eq.5) then
         do while (ipair(3*(ncst+1)).gt.0)
            ncst=ncst+1
            if (ncst.gt.10) then
               WRITE(IW,9020)
               CALL ABRT
            endif
            uforce(ncst)=uforce(ncst)*au2ang**2/au2kcal
            rzero(ncst)=rzero(ncst)/au2ang
            uforce(ncst+1)=uforce(ncst+1)*au2ang**2/au2kcal
         enddo
      elseif (iustyp.eq.6) then
         do while (uforce(ncst+1).gt.0)
            ncst=ncst+1
            if (ncst.gt.10) then
               WRITE(IW,9020)
               CALL ABRT
            endif
            uforce(ncst)=uforce(ncst)*au2ang**2/au2kcal
            rzero(ncst)=rzero(ncst)/au2ang
         enddo
         IndexOH(1) = ipair(1)
         IndexOH(2) = ipair(2)
         IndexOH(3) = ipair(3)
         IndexOH(4) = ipair(4)
         IndexOH(5) = ipair(5)
         IndexOH(6) = ipair(6)
      elseif (iustyp.eq.7) then
         do while (ipair(3*(ncst+2)).gt.0)
            ncst=ncst+1
            if (ncst.gt.10) then
               WRITE(IW,9020)
               CALL ABRT
            endif
            uforce(ncst)=uforce(ncst)*au2ang**2/au2kcal
            rzero(ncst)=rzero(ncst)/au2ang
         enddo
         IndexOH(1) = ipair(1)
         IndexOH(2) = ipair(2)
         IndexOH(3) = ipair(3)
         IndexOH(4) = ipair(4)
         IndexOH(5) = ipair(5)
         IndexOH(6) = ipair(6)
      elseif (iustyp.eq.8) then
         ncst=ncst+1
         uforce(ncst)=uforce(ncst)*au2ang**2/au2kcal
         rzero(ncst)=rzero(ncst)/au2ang
         tmass(2)=zero
         tmass(3)=zero
         do i=1,nat
            if (i.eq.ipair(i)) then
               tmass(2)=tmass(2)+zmass(i)
            else
               tmass(3)=tmass(3)+zmass(i)
            endif
         enddo
      elseif (iustyp.eq.9) then
         ncst=ncst+1
         uforce(ncst)=uforce(ncst)*au2ang**2/au2kcal
         rzero(ncst)=rzero(ncst)/au2ang
         tmass(2)=zero
         do i=1,nat
            tmass(2)=tmass(2)+zmass(i)
         enddo
      endif
      endif
c
      if (ssbp) then
c        force constant : kcal/mol-A^2 to Eh/Bohr^2, distance : Angstrom to Bohr
         droff(1)=droff(1)/au2ang
         droff(2)=droff(2)/au2ang
         sforce=sforce*au2ang**2/au2kcal
      endif
      if (ccms) then
c        force constant : kcal/mol-A^2 to Eh/Bohr^2, distance : Angstrom to Bohr
         cforce=cforce*au2ang**2/au2kcal
         do i=1,nat
            tmass(1)=tmass(1)+zmass(i)
         enddo
      endif
c
      RETURN
 9020 FORMAT(/,1X,'*** Too many umbrella sampling constraints! ***',/)
      END
C*MODULE MDEFP   *DECK cang
      SUBROUTINE cang(rijk,gijk,theta)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
c
      dimension rijk(3,3), gijk(3,3)
      dimension R12(3),R13(3)
C
      DR12=0.0d+00
      DR13=0.0d+00
      dot=0.0d+00
      do i=1,3
         R12(i)=rijk(i,2)-rijk(i,1)
         R13(i)=rijk(i,3)-rijk(i,1)
         DR12=DR12+R12(i)**2
         DR13=DR13+R13(i)**2
         dot=dot+r12(i)*r13(i)
      enddo
      DR12=sqrt(DR12)
      DR13=sqrt(DR13)
      ctheta=dot/(DR12*DR13)
      theta=dacos(ctheta)
      DS=1.0d+00/dsin(theta)
      Dp=1.0d+00/DR12*DR13
c
      do i=1,3
         gijk(i,1)=DS*Dp*(R13(i)+R12(i))
         gijk(i,2)=-DS*Dp*R13(i)
         gijk(i,2)=-DS*Dp*R12(i)
      enddo
c
      RETURN
      END
C*MODULE MDEFP   *DECK asymcor
      SUBROUTINE asymcor(ipair,uforce,f2f,rzero,uV)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
c
c     Asymmetric coordinates for umbrella sampling technique.
c     ipair contains three atoms, where atom 1 is moving from atom 2 to 3.
c     The potential due to constraint (uV) will be returned.
c
      PARAMETER (SQRT21=.70710678118654746172D+00,HALF=0.5d+00)
      PARAMETER (MXATM=2000)
      LOGICAL GOPARR, DSKWRK, MASWRK
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /FUNCT / E, EG(3*MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      dimension ipair(*),rij(3,2), A(3)
c
      ia1=ipair(1)
      ia2=ipair(2)
      ia3=ipair(3)
      r21=0
      r31=0
      do j=1,3
         rij(j,1)=c(j,ia2)-c(j,ia1)
         rij(j,2)=c(j,ia3)-c(j,ia1)
         r21=r21+rij(j,1)**2
         r31=r31+rij(j,2)**2
      enddo
      r21=sqrt(r21)
      r31=sqrt(r31)
      if (maswrk) write(iw,2001) ia1,ia2,ia3,r21*au2ang,r31*au2ang
      rasym=r21-r31
      do j=1,3
         rij(j,1)=rij(j,1)/r21
         rij(j,2)=rij(j,2)/r31
      enddo
      rasym=rasym*sqrt21
c     construct (rasym-rzero), and ufactor
      rdisp=rasym-rzero
      ufactor=uforce*f2f*rdisp
      uV=uforce*rdisp**2*half
c     applying constraints
      ia1=3*(ipair(1)-1)
      ia2=3*(ipair(2)-1)
      ia3=3*(ipair(3)-1)
c
      A(1)=eg(ia1+1)/f2f
      A(2)=eg(ia1+2)/f2f
      A(3)=eg(ia1+3)/f2f
      if (maswrk) write(iw,2003) A(1),A(2),A(3)
      do j=1,3
         eg(ia1+j)=eg(ia1+j)+ufactor*(rij(j,2)-rij(j,1))
         eg(ia2+j)=eg(ia2+j)+ufactor*rij(j,1)
         eg(ia3+j)=eg(ia3+j)-ufactor*rij(j,2)
      enddo
      if (maswrk) write(iw,2004) eg(ia1+1)/f2f,eg(ia1+2)/f2f,
     *   eg(ia1+3)/f2f
      if (maswrk) write(iw,2002) rasym*au2ang
c
      return
 2001 format(5x,'Atoms',3i5/
     *       ,5x,'R21= ',F15.10,5x,'R31=',F15.10)
 2002 format(5x,'Current Distance (Ang.) = ',F15.10)
 2003 format(5x,'Gradient on Moving Atom = '/
     *      ,5x,3ES20.10)
 2004 format(5x,'Gradient on Moving Atom with Uforce = '/
     *      ,5x,3ES20.10)
      end
C*MODULE MDEFP   *DECK rccor
      SUBROUTINE rccor(ipair,uforce,f2f,uV)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
c
c     Restraint coordinte for asymmetric coordinates of umbrella
c     sampling technique. IPAIR contains three atoms, where atom 1
c     is moving from atom 2 to 3. Current restraint coordinate forces
c     atom 1 to stay in between atom 2 and 3.
c     The potential due to constraint (uV) will be returned.
c
      PARAMETER (one=1.0d+00)
      PARAMETER (MXATM=2000,zero=0.0d+00,half=0.5d+00)
      LOGICAL GOPARR, DSKWRK, MASWRK
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /FUNCT / E, EG(3*MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      dimension ipair(*),r(3,3),g(3,3)
c
      ia1=ipair(1)
      ia2=ipair(2)
      ia3=ipair(3)
      r21=zero
      r31=zero
      r32=zero
      do j=1,3
         r(j,1)=c(j,ia2)-c(j,ia1)
         r(j,2)=c(j,ia3)-c(j,ia1)
         r(j,3)=c(j,ia3)-c(j,ia2)
         r21=r21+r(j,1)**2
         r31=r31+r(j,2)**2
         r32=r32+r(j,3)**2
      enddo
      r21=sqrt(r21)
      r31=sqrt(r31)
      r32=sqrt(r32)
      r2131=r21+r31
      rc=zero
      if (maswrk) write(iw,2001) ia1,ia2,ia3,r21*au2ang,r31*au2ang
c
      do i=1,3
        g(i,1)=(one+r(i,3)/r2131**2*(r(i,1)*r31/r21-r(i,2)*r21/r31))
        g(i,2)=(one-one/r2131**2*(-r21*r2131+r(i,3)*r(i,1)*r31/r21))
        g(i,3)=-r21/r2131**2*(r2131-r(i,3)*r(i,2)/r31)
        rc=rc+(r(i,1)+r(i,3)*r21/r2131)**2
      enddo
      ufactor=uforce*f2f
      uV=uforce*rc*half
      ia1=3*(ipair(1)-1)
      ia2=3*(ipair(2)-1)
      ia3=3*(ipair(3)-1)
c
      do j=1,3
         eg(ia1+j)=eg(ia1+j)-ufactor*g(j,1)
         eg(ia2+j)=eg(ia2+j)-ufactor*g(j,2)
         eg(ia3+j)=eg(ia3+j)-ufactor*g(j,3)
      enddo
      if (maswrk) write(iw,2002) sqrt(rc)*au2ang
c
      return
 2001 format(5x,'Atoms',3i5/
     *       ,5x,'R21= ',F15.10,5x,'R31=',F15.10)
 2002 format(5x,'Off-axis Distance (Ang.) = ',F15.10)
      end
C*MODULE MDEFP   *DECK cstbond
      SUBROUTINE cstbond(ipair,uforce,rzero,f2f,uV)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
c
c     Restraint coordinte for asymmetric coordinates of umbrella
c     sampling technique. IPAIR contains three atoms, where atom 1
c     is moving from atom 2 to 3. Current restraint coordinate forces
c     atom 1 to stay in between atom 2 and 3.
c     The potential due to constraint (uV) will be returned.
c
      PARAMETER (half=0.5d+00, MXATM=2000)
      LOGICAL GOPARR, DSKWRK, MASWRK
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /FUNCT / E, EG(3*MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      dimension ipair(*),uvec(3)
c
      uvecn=0
      do i=1,3
         uvec(i)=c(i,ipair(2))-c(i,ipair(1))
         uvecn=uvecn+uvec(i)**2
      enddo
c
      vecn=sqrt(uvecn)
      rdisp=vecn-rzero
      ufactor=-uforce*rdisp*f2f/vecn
      uV=uforce*rdisp**2*half
c
      do i=1,3
         uvec(i)=ufactor*uvec(i)
      enddo
c
      i1=3*(ipair(1)-1)
      i2=3*(ipair(2)-1)
c
      do i=1,3
         eg(i1+i)=eg(i1+i)+uvec(i)
         eg(i2+i)=eg(i2+i)-uvec(i)
      enddo
      if (maswrk) write(iw,2000) ipair(1),ipair(2)
     *   ,vecn*au2ang
c
      return
 2000 format(5x,'Between Atoms',2i5/
     *       ,5x,'Current Distance (Ang.) = ',F15.10)
      end
C*MODULE MDEFP   *DECK csttor
C>
C>     @brief constraint potential for torsion 
C>
C>     @details Add constraint potential for torsion. 
C>
C>     @author Cheol Ho Choi 
C>
      SUBROUTINE csttor(ipair,uforce,rzero,f2f,uV)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
c
c     Constraint potential for torsion
c
      PARAMETER (half=0.5d+00, MXATM=2000)
      PARAMETER (PI=3.14159265358979323D+00)
      LOGICAL GOPARR, DSKWRK, MASWRK
      COMMON /FUNCT / E, EG(3*MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      dimension ipair(*),rijkl(3,4),gijkl(3,4)
c
      do i=1,3
         rijkl(i,1)=c(i,ipair(1))
         rijkl(i,2)=c(i,ipair(2))
         rijkl(i,3)=c(i,ipair(3))
         rijkl(i,4)=c(i,ipair(4))
      enddo
c
      call ctor(rijkl,gijkl,theta)
c     if(abs(theta).gt.pi.and.maswrk) 
c    *  write(iw,*) 'too large angle',theta 
c
      rdisp=theta-rzero
      if (abs(rdisp).gt.pi) then
         if (rdisp.lt.-pi) then
            rdisp=rdisp+2*pi
         elseif (rdisp.gt.pi) then
            rdisp=rdisp-2*pi
         endif
      endif
      ufactor=uforce*rdisp*f2f
      uV=uforce*rdisp**2*half
c
      i1=3*(ipair(1)-1)
      i2=3*(ipair(2)-1)
      i3=3*(ipair(3)-1)
      i4=3*(ipair(4)-1)
c
      do i=1,3
         eg(i1+i)=eg(i1+i)+ufactor*gijkl(i,1)
         eg(i2+i)=eg(i2+i)+ufactor*gijkl(i,2)
         eg(i3+i)=eg(i3+i)+ufactor*gijkl(i,3)
         eg(i4+i)=eg(i4+i)+ufactor*gijkl(i,4)
      enddo
      if (maswrk) write(iw,2004) ipair(1),
     *   ipair(2),ipair(3),ipair(4),theta*180.0d+00/pi
      return
 2004 format(5x,'Atoms',4i5/
     *       ,5x,'Current Angle (Deg.) = ',F15.10)
      end
C*MODULE MDEFP   *DECK cstang
      SUBROUTINE cstang(ipair,uforce,rzero,f2f,uV)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
c
c     Constraint potential for angle.
c
      PARAMETER (half=0.5d+00, MXATM=2000)
      PARAMETER (PI=3.14159265358979323D+00)
      LOGICAL GOPARR, DSKWRK, MASWRK
      COMMON /FUNCT / E, EG(3*MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      dimension ipair(*),rijk(3,3),gijk(3,3)
c
      do i=1,3
         rijk(i,1)=c(i,ipair(1))
         rijk(i,2)=c(i,ipair(2))
         rijk(i,3)=c(i,ipair(3))
      enddo
c
      call cang(rijk,gijk,theta)
c
      rdisp=theta-rzero
      ufactor=uforce*rdisp*f2f/dsin(theta)
      uV=uV+uforce*rdisp**2*half
c
      i1=3*(ipair(1)-1)
      i2=3*(ipair(2)-1)
      i3=3*(ipair(3)-1)
c
      do i=1,3
         eg(i1+i)=eg(i1+i)+ufactor*gijk(i,1)
         eg(i2+i)=eg(i2+i)+ufactor*gijk(i,2)
         eg(i3+i)=eg(i3+i)+ufactor*gijk(i,3)
      enddo
      if (maswrk) write(iw,2004) ipair(1),
     *   ipair(2),ipair(3),theta*180.0d+00/pi
      return
 2004 format(5x,'Atoms',3i5/
     *       ,5x,'Current Angle (Deg.) = ',F15.10)
      end
C*MODULE MDEFP   *DECK ctor
      SUBROUTINE ctor(rijkl,gijkl,theta)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
c
      dimension rijkl(3,4), gijkl(3,4)
      dimension F(3),G(3),H(3),A(3),B(3)
C
      do i=1,3
         F(i)=rijkl(i,1)-rijkl(i,2)
         G(i)=rijkl(i,2)-rijkl(i,3)
         H(i)=rijkl(i,4)-rijkl(i,3)
      enddo
      A(1)=F(2)*G(3)-F(3)*G(2)
      A(2)=F(3)*G(1)-F(1)*G(3)
      A(3)=F(1)*G(2)-F(2)*G(1)
      B(1)=H(2)*G(3)-H(3)*G(2)
      B(2)=H(3)*G(1)-H(1)*G(3)
      B(3)=H(1)*G(2)-H(2)*G(1)
c
      FG=F(1)*G(1)+F(2)*G(2)+F(3)*G(3)
      HG=H(1)*G(1)+H(2)*G(2)+H(3)*G(3)
c     AB=A(1)*B(1)+A(2)*B(2)+A(3)*B(3)
      Gn=sqrt(G(1)**2+G(2)**2+G(3)**2)
      As=A(1)**2+A(2)**2+A(3)**2
      Bs=B(1)**2+B(2)**2+B(3)**2
c
      f1=Gn/As
      f2=FG/(As*Gn)
      f3=HG/(Bs*Gn)
      f4=Gn/Bs
c
c      theta=acos(AB/(sqrt(As*Bs)))
      FGH=-(F(1)*B(1)+F(2)*B(2)+F(3)*B(3))
      FGGH=-(A(1)*B(1)+A(2)*B(2)+A(3)*B(3))
      theta=datan2(Gn*FGH,-FGGH)
c
      do i=1,3
         gijkl(i,1)=-f1*A(i)
         gijkl(i,2)=(f1+f2)*A(i)-f3*B(i)
         gijkl(i,3)=(f3-f4)*B(i)-f2*A(i)
         gijkl(i,4)=f4*B(i)
      enddo
c
      RETURN
      END
C*MODULE MDEFP   *DECK ENEDEF
      SUBROUTINE ENEDEF
C       *********************************************************
C       *** Calculate energy and forces                       ***
C       *********************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (NRepca=100, MXFGPT=12000, MXFRG=1050, MXATM=2000,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      DOUBLE PRECISION MDINT
      logical ccms,ssbp,usamp,rstemp,rsrand,prod
      common /cstpot/ DROFF(2),SFORCE,uforce(10),rzero(10),dtemp,
     *                rzeroC(3,MXATM),Tmin,uV,batht(NRepca),mdint,
     *                ipair(50),iustyp,ncst,nrand,nvtoff,
     *                jevery,kevery,levery,mremd,
     *                rstemp,rsrand,prod,SSBP,ccms,Usamp,IndexOH(50),
     *                movemm(200),nefpmv,cforce,tmass(3)
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /VIRPR / VIR(3), PRXX, PRYY, PRZZ
C
      CALL EFSP
      CALL EFGRAD
C
      F2F = -AU2KCAL / EK2KCAL
      DO I = 1, NFRG
         DEFT(1,I) = F2F * DEFT(1,I)
         DEFT(2,I) = F2F * DEFT(2,I)
         DEFT(3,I) = F2F * DEFT(3,I)
         TORQ(1,I) = F2F * TORQ(1,I)
         TORQ(2,I) = F2F * TORQ(2,I)
         TORQ(3,I) = F2F * TORQ(3,I)
      ENDDO
C
      VIR(1) = F2F*VIR(1)
      VIR(2) = F2F*VIR(2)
      VIR(3) = F2F*VIR(3)
c
      if (ssbp) call cstssbp(f2f)
C
      RETURN
      END
C
C*MODULE MDEFP   *DECK FROGMOVE
      SUBROUTINE FROGMOVE(INTMD,ISTEP,NPROP)
C        *********************************************************
C        *** Integrate equations of motion using a leap-frog   ***
C        *** algorithm and quaternion                          ***
C        *********************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXPT=2000, MXFGPT=12000, MXFRG=1050,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (MXAO=8192, MXSHEF=1000, MXGEFP=4000)
      PARAMETER (MXATM=2000)
      DOUBLE PRECISION MDTYP
      INTEGER INTMD
      CHARACTER*8 LJNAME,ELJNAM
C
      COMMON /ATMDAT/ VX(MXFRG), VY(MXFRG), VZ(MXFRG),
     *                QW(MXFRG), QX(MXFRG), QY(MXFRG), QZ(MXFRG),
     *                OX(MXFRG), OY(MXFRG), OZ(MXFRG), QW1(MXFRG),
     *                QX1(MXFRG),QY1(MXFRG),QZ1(MXFRG),QW2(MXFRG),
     *                QX2(MXFRG),QY2(MXFRG),QZ2(MXFRG),
     *                VXQM(MXATM), VYQM(MXATM), VZQM(MXATM)
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NATEF(MXDFG),NUMEF(MXDFG),NTPATM
      COMMON /EFPCT / NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CTFOK(MXAO,MXDFG),NCTMO(MXDFG),NTCTMO
      COMMON /FMCOM / XX(1)
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGLJP/ CORDLJ(3,MXPT),ELJCRD(3,MXFGPT),
     *                POTLJ(2,MXPT),ELJPOT(2,MXFGPT),
     *                LJNAME(MXPT),ELJNAM(MXFGPT),
     *                NLJPTS(MXFRG),NLJTTPT,ILJP,NMLJ(2)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /FUNCT / E, EG(3,MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MASSES/ ZMASS(MXATM)
      COMMON /MDSIM / DT, BATHT, EKINT, EKINR, MDTYP
      COMMON /MDSIM7/ VXO(MXFRG), VYO(MXFRG), VZO(MXFRG),
     *                WXO(MXFRG), WYO(MXFRG), WZO(MXFRG)
      COMMON /MODDAT/ AMOM(3,MXDFG), TOTMAS(MXDFG), TOTMAI(MXDFG),
     *                DRX(MXFGPT), DRY(MXFGPT), DRZ(MXFGPT)
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
C
C        write(6,*) 'vx(1) = ',vx(1)
C        call mdwrit(1)
        EKINT = 0.0D+00
        EKINR = 0.0D+00
        NMST = 0
        NPST = 0
        NDPST = 0
        NLJST = 0
        NRST = 0
        NATST = 0
        NORST = 0
        NCTMOST = 0
        NDST = 0
C     FOR QM PART
      DO I = 1, NAT
         ZMASSI = 1.0D+00/ZMASS(I)
         VXI = VXQM(I)
         VYI = VYQM(I)
         VZI = VZQM(I)
C   Move linear vel. from t-1/2dt to t+1/2dt and save-->
C   vx(i)(t+1/2dt) = vxi(t-1/2dt) + dt*force(t)/mass
         VXQM(I) = VXI + DT*EG(1,I) * ZMASSI
         VYQM(I) = VYI + DT*EG(2,I) * ZMASSI
         VZQM(I) = VZI + DT*EG(3,I) * ZMASSI
C
C   Calc. current velocity (at t) to evaluate energy, etc.-->
C   vxi(t) = 1/2*(vxi(t-1/2dt)+vx(i)(t+1/2dt))
         VXI = 0.5D+00 * ( VXI + VXQM(I) )
         VYI = 0.5D+00 * ( VYI + VYQM(I) )
         VZI = 0.5D+00 * ( VZI + VZQM(I) )
C
C   Calc. KEt at time t
         EKINT = EKINT + ZMASS(I)*(VXI**2 + VYI**2 + VZI**2)
C
C     Save new vel. at t+1/2dt; note that new positions at t+dt-->
C   r(t+dt) = r(t) + dt*v(t+1/2dt)
         C(1,I) = C(1,I) + DT*VXQM(I)
         C(2,I) = C(2,I) + DT*VYQM(I)
         C(3,I) = C(3,I) + DT*VZQM(I)
      ENDDO
C
      IF (NFRG.EQ.0) THEN
         EKINT = 0.5D+00 * EK2KCAL * EKINT
         RETURN
      END IF
C
C
      MXBF=0
      DO I=1,NFRG
         MXBF=MAX(MXBF,NPBF(I))
      END DO
      CALL VALFM(LOADFM)
      LPROVEC = LOADFM  + 1
      LCTVEC  = LPROVEC + MXBF*NTMO
      LAST    = LCTVEC  + MXBF*NTCTMO
      NEED=LAST-LOADFM-1
      CALL GETFM(NEED)
      LENPV=MXBF*NTMO
      IF (NFRG.GT.0.AND.NTMO.GT.0)
     *   CALL DAREAD(IDAF,IODA,XX(LPROVEC),LENPV,267,0)
      LENCV=MXBF*NTCTMO
      IF (NFRG.GT.0.AND.NTCTMO.GT.0)
     *   CALL DAREAD(IDAF,IODA,XX(LCTVEC),LENCV,269,0)
C
        DT2 = 0.5D+00*DT
        DEL = 0.0D+00
        DO I = 1, NFRG
C
C          write(6,*) 'torq(1,i),(2,i),(3,i) = ',torq(1,i),
C     *                torq(2,i),torq(3,i)
C   Move angular momentum to time t-->
C             oxi(t)= ox(i)(t-1/2dt) + 1/2dt*torq(t)
C
          OXI = OX(I) + DT2 * TORQ(1,I)
          OYI = OY(I) + DT2 * TORQ(2,I)
          OZI = OZ(I) + DT2 * TORQ(3,I)
C
C   Get rotation matrix at time t--> A(t) from quat(i)(t)
          AXX = QW(I) ** 2 + QX(I) ** 2 - QY(I) ** 2 - QZ(I) ** 2
          AXY = 2.0D+00 * ( QX(I) * QY(I) + QW(I) * QZ(I) )
          AXZ = 2.0D+00 * ( QX(I) * QZ(I) - QW(I) * QY(I) )
          AYX = 2.0D+00 * ( QX(I) * QY(I) - QW(I) * QZ(I) )
          AYY = QW(I) ** 2 - QX(I) ** 2 + QY(I) ** 2 - QZ(I) ** 2
          AYZ = 2.0D+00 * ( QY(I) * QZ(I) + QW(I) * QX(I) )
          AZX = 2.0D+00 * ( QX(I) * QZ(I) + QW(I) * QY(I) )
          AZY = 2.0D+00 * ( QY(I) * QZ(I) - QW(I) * QX(I) )
          AZZ = QW(I) ** 2 - QX(I) ** 2 - QY(I) ** 2 + QZ(I) ** 2
C
C   Save quaternions at time t
          QWSAV = QW(I)
          QXSAV = QX(I)
          QYSAV = QY(I)
          QZSAV = QZ(I)
C
C   Convert angular mom to body-fixed form--to angular vel-->
C   omxi(t) = A(t) * ang mom oxi(t)
          OMXI = ( AXX * OXI + AXY * OYI + AXZ * OZI ) / AMOM(1,ISET(I))
          OMYI = ( AYX * OXI + AYY * OYI + AYZ * OZI ) / AMOM(2,ISET(I))
          OMZI = ( AZX * OXI + AZY * OYI + AZZ * OZI ) / AMOM(3,ISET(I))
C
C          write(6,*) 'i, ang vel = ',omxi*1.0d-12,omyi*1.0d-12,
C     *                               omzi*1.0d-12
C   Kinetic energy at time t
      EKINR = EKINR + AMOM(1,ISET(I)) * OMXI**2 +
     *        AMOM(2,ISET(I)) * OMYI**2 + AMOM(3,ISET(I)) * OMZI**2
C
C   Obtain time-deriv of quat. and advance to time t+1/2dt-->
C   qwli-q'(t) = 1/2*q(t)*ang. vel omxi(t)
C   Guess at q(t+1/2dt)=q(t) + 1/2dt*q'(t)
          QW1I = ( - QX(I)*OMXI - QY(I)*OMYI - QZ(I)*OMZI )*0.5D+00
          QX1I = (   QW(I)*OMXI - QZ(I)*OMYI + QY(I)*OMZI )*0.5D+00
          QY1I = (   QZ(I)*OMXI + QW(I)*OMYI - QX(I)*OMZI )*0.5D+00
          QZ1I = ( - QY(I)*OMXI + QX(I)*OMYI + QW(I)*OMZI )*0.5D+00
C
C          write(6,*) '1st time deriv; ',qw1i,qx1i,qy1i,qz1i
C--derivative constraint?
          DEL = QW(I)*QW1I+QX(I)*QX1I+QY(I)*QY1I+QZ(I)*QZ1I
          QW1I = QW1I - DEL*QW(I)
          QX1I = QX1I - DEL*QX(I)
          QY1I = QY1I - DEL*QY(I)
          QZ1I = QZ1I - DEL*QZ(I)
C
          QWI = QW(I) + DT2 * QW1I
          QXI = QX(I) + DT2 * QX1I
          QYI = QY(I) + DT2 * QY1I
          QZI = QZ(I) + DT2 * QZ1I
C
C        the following gives a little (just a little) more stability
C
C   Renormalize new quat. at t+1/2dt
          QLI = 1.0D+00/SQRT(QWI**2 + QXI**2 + QYI**2 + QZI**2)
          QWI = QWI * QLI
          QXI = QXI * QLI
          QYI = QYI * QLI
          QZI = QZI * QLI
C
C   Form new rotation matrix at t+1/2dt
          AXX = QWI ** 2 + QXI ** 2 - QYI ** 2 - QZI ** 2
          AXY = 2.0D+00 * ( QXI * QYI + QWI * QZI )
          AXZ = 2.0D+00 * ( QXI * QZI - QWI * QYI )
          AYX = 2.0D+00 * ( QXI * QYI - QWI * QZI )
          AYY = QWI ** 2 - QXI ** 2 + QYI ** 2 - QZI ** 2
          AYZ = 2.0D+00 * ( QYI * QZI + QWI * QXI )
          AZX = 2.0D+00 * ( QXI * QZI + QWI * QYI )
          AZY = 2.0D+00 * ( QYI * QZI - QWI * QXI )
          AZZ = QWI ** 2 - QXI ** 2 - QYI ** 2 + QZI ** 2
C
C   Move ang. mom from t-1/2dt to t+1/2dt and store-->
C   ox(i)(t+1/2dt) = ox(i)(t-1/2dt) + dt*torq(t)
          OX(I) = OX(I) + DT*TORQ(1,I)
          OY(I) = OY(I) + DT*TORQ(2,I)
          OZ(I) = OZ(I) + DT*TORQ(3,I)
C
C   Convert ang. mom to body-fixed form to get ang. vel at time
C   t+1/2dt-->    omxi(t+1/2dt) = A(t+1/2dt)*ox(i)(t+1/2dt)
C
       OMXI=(AXX*OX(I) + AXY*OY(I) + AXZ*OZ(I))/AMOM(1,ISET(I))
       OMYI=(AYX*OX(I) + AYY*OY(I) + AYZ*OZ(I))/AMOM(2,ISET(I))
       OMZI=(AZX*OX(I) + AZY*OY(I) + AZZ*OZ(I))/AMOM(3,ISET(I))
C
C          write(6,*) 'i, ang vel = ',omxi*1.0d-12,omyi*1.0d-12,
C     *                               omzi*1.0d-12
C   Obtain time-deriv of quat. at t+1/2dt and advance to time t+dt-->
C   qwli-q'(t+1/2dt) = 1/2*q(t+1/2dt)*ang. vel omxi(t+1/2dt)
C   Guess at q(t+dt)=q(t) + dt*q'(t+1/2dt)
C
       QW1I=(-QXI*OMXI - QYI*OMYI - QZI*OMZI )*0.5D+00
       QX1I=( QWI*OMXI - QZI*OMYI + QYI*OMZI )*0.5D+00
       QY1I=( QZI*OMXI + QWI*OMYI - QXI*OMZI )*0.5D+00
       QZ1I=(-QYI*OMXI + QXI*OMYI + QWI*OMZI )*0.5D+00
C
          WRITE(6,*) 'I,TIME DERIV = ',QW1I,QX1I,QY1I,QZ1I
C
          QW(I) = QW(I) + DT*QW1I
          QX(I) = QX(I) + DT*QX1I
          QY(I) = QY(I) + DT*QY1I
          QZ(I) = QZ(I) + DT*QZ1I
C
C   Renormalize new quat. at t+dt
          QLI = 1.0D+00/SQRT(QW(I)**2 + QX(I)**2 + QY(I)**2 + QZ(I)**2)
C          write(6,*) 'renorm factor ',qli
C
          QW(I) = QW(I) * QLI
          QX(I) = QX(I) * QLI
          QY(I) = QY(I) * QLI
          QZ(I) = QZ(I) * QLI
C
C          write(6,*) 'qw,x,y,z = ',qw(i),qx(i),qy(i),qz(i)
C   Set inital velocities for Diffusion
      IF(ISTEP.EQ.1 .OR. ISTEP.EQ.NPROP-1)THEN
       DO J=1,NFRG
           VXO(J) = VX(J)
           VYO(J) = VY(J)
           VZO(J) = VZ(J)
       ENDDO
      ENDIF
C   Save vel. at time t-1/2dt
          VXI = VX(I)
          VYI = VY(I)
          VZI = VZ(I)
C
C   Move linear vel. from t-1/2dt to t+1/2dt and save-->
C   vx(i)(t+1/2dt) = vxi(t-1/2dt) + dt*force(t)/mass
          VX(I) = VXI + DT*DEFT(1,I) * TOTMAI(ISET(I))
          VY(I) = VYI + DT*DEFT(2,I) * TOTMAI(ISET(I))
          VZ(I) = VZI + DT*DEFT(3,I) * TOTMAI(ISET(I))
C
C   Calc. current velocity (at t) to evaluate energy, etc.-->
C   vxi(t) = 1/2*(vxi(t-1/2dt)+vx(i)(t+1/2dt))
          VXI = 0.5D+00 * ( VXI + VX(I) )
          VYI = 0.5D+00 * ( VYI + VY(I) )
          VZI = 0.5D+00 * ( VZI + VZ(I) )
C
C   Calc. KEt at time t
      EKINT = EKINT + TOTMAS(ISET(I))*(VXI**2 + VYI**2 + VZI**2)
C
C   Save new vel. at t+1/2dt; note that new positions at t+dt-->
C   r(t+dt) = r(t) + dt*v(t+1/2dt)
          CENTDX = DT*VX(I)
          CENTDY = DT*VY(I)
          CENTDZ = DT*VZ(I)
C
C          write(6,*) 'centdx,y,z = ',centdx,centdy,centdz
C  Do rotation and translation to get ecp to t+dt
C  Note: we need to call efcm before coming back
C        here to get newest COM coords
C
          CALL MDDSPQ(I,CENTDX,CENTDY,CENTDZ,QWSAV,QXSAV,QYSAV,QZSAV,
     *                QW(I),QX(I),QY(I),QZ(I),
     *                NMST,NPST,NLJST,NDPST,NRST,NDST,NATST,NORST,
     *                XX(LPROVEC),NCTMOST,XX(LCTVEC),MXBF,INTMD)
C
          NMST  = NMST  + NMPTS(I)
          NPST  = NPST  + NPPTS(I)
          NLJST = NLJST + NLJPTS(I)
          NDPST = NDPST + NDPPTS(I)
          NRST  = NRST  + NRPTS(I)
          NDST  = NDST  + NDPTS(I)
          NATST = NATST + NATEF(ISET(I))
          NORST = NORST + NORB(I)
          NCTMOST = NCTMOST + NCTMO(ISET(I))
C
        ENDDO
C
      IF (NFRG.GT.0.AND.NTMO.GT.0)
     *   CALL DAWRIT(IDAF,IODA,XX(LPROVEC),LENPV,267,0)
      IF (NFRG.GT.0.AND.NTCTMO.GT.0)
     *   CALL DAWRIT(IDAF,IODA,XX(LCTVEC),LENCV,269,0)
C
      CALL RETFM(NEED)
C
        EKINT = 0.5D+00 * EK2KCAL * EKINT
        EKINR = 0.5D+00 * EK2KCAL * EKINR
C      CALL RETFM(NEED)
        RETURN
        END
C
C*MODULE MDEFP   *DECK MDCONV
      SUBROUTINE MDCONV
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
C
C        *********************************************************
C        *** setup convenient conversion factors for MD        ***
C        *********************************************************
C        conversion factors taken (where possible) from NIST 1986 values
C     Hartree/Joule           = 4.3597443400E-18
C     Boltzman Constant (J/K) = 1.3806488000E-23
C     Kelvin/kcal/mol         = 1.9871700000E-03
C     Bohr/Angstrom           = 0.52917721092
C
      AU2KCAL = 4.359816D-18 / 1.380658D-23 * 1.98721984D-03
      AU2ANG = 0.52917724924D+00
      EK2KCAL = 2.39005738055577D-27 * AU2ANG * AU2ANG
      AU2SEC = 2.41889D-17
C--hmn (au--kg--amu)
C     Electron Rest Mass (me)   =9.1093826(16)E31 kg
C     Atomic Mass Constant (mu) =1.66053886E-27 kg
      AU2AMU = 9.1091D-31 / 1.6605402D-27
C     PRESSURE = Eh/Bohr^3 = 2.942 D+13 Pa = 2.942 D+8 Bar
C     1 BAR    = 1.0D5 PA  = 1.0D5 *  J/M^3
C                          = 1.0D5 * 1.0D-30  J/A^3
C     Au2J = Hartree/Joule
      AU2J   = 4.35974394D-18   ! A.U. ---> J
      AU2BAR = 1.0D-5 * AU2J/(AU2ANG*1.0D-10)**3   !  A.U. ---> BAR
C     EK2KCAL/AU2KCAL : K ---> a.u.
      EK2BAR = (EK2KCAL/AU2KCAL)*AU2BAR    !  K ---> BAR
      RETURN
      END
C
C*MODULE MDEFP   *DECK MODSET
C>
C>     @brief   setup water model parameters or other EFP for MD
C>
C>     @details setup water model parameters or other EFP for MD
C>
C>     @author  unknown
C>
      SUBROUTINE MODSET
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL GOPARR, DSKWRK, MASWRK
C
      PARAMETER (MXPT=2000, MXFGPT=12000,MXFRG=1050,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (AVOGAD=6.022045D+23,ZERO=0.0D+00)
C
      CHARACTER*8 FRGNME
C
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /EFPPBC/ XBOX,YBOX,ZBOX,XCUT,YCUT,ZCUT,RCUT
     *                ,SWR1,SWR2,ISWF
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MODDAT/ AMOM(3,MXDFG), TOTMAS(MXDFG), TOTMAI(MXDFG),
     *                DRX(MXFGPT), DRY(MXFGPT), DRZ(MXFGPT)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C        *******************************************
C        *** setup water model parameters for MD ***
C        *******************************************
C        body-fixed moments of inertia are derived from fragment #1
C        body-fixed frame is as follows:
C               z-axis is C2 axis (pointing away from hydrogens)
C               x-axis is pointing out of plane of hydrogens
C               y-axis points in plane towards H2
C        (forming a right-handed coordinate system)
C
        ROH1X = EFC(1,2) - EFC(1,1)
        ROH1Y = EFC(2,2) - EFC(2,1)
        ROH1Z = EFC(3,2) - EFC(3,1)
        ROH2X = EFC(1,3) - EFC(1,1)
        ROH2Y = EFC(2,3) - EFC(2,1)
        ROH2Z = EFC(3,3) - EFC(3,1)
        ZX = -(ROH1X + ROH2X)
        ZY = -(ROH1Y + ROH2Y)
        ZZ = -(ROH1Z + ROH2Z)
        ZL = SQRT(ZX*ZX+ZY*ZY+ZZ*ZZ)
        ZX = ZX / ZL
        ZY = ZY / ZL
        ZZ = ZZ / ZL
        XX = ZY * ROH1Z - ZZ * ROH1Y
        XY = ZZ * ROH1X - ZX * ROH1Z
        XZ = ZX * ROH1Y - ZY * ROH1X
        XL = SQRT(XX*XX+XY*XY+XZ*XZ)
        XX = XX / XL
        XY = XY / XL
        XZ = XZ / XL
        YX = ZY * XZ - ZZ * XY
        YY = ZZ * XX - ZX * XZ
        YZ = ZX * XY - ZY * XX
        YL = SQRT(YX*YX+YY*YY+YZ*YZ)
        YX = YX / YL
        YY = YY / YL
        YZ = YZ / YL
C
           L=0
C
       FMASAL=ZERO
      DO 5 K=1,NFRG
        MASSFF=0
        TOTMAS(ISET(K)) = FRGMAS(K)
        TOTMAI(ISET(K)) = 1.0D+00 / TOTMAS(ISET(K))
        AMOM(1,ISET(K)) = 0.0D+00
        AMOM(2,ISET(K)) = 0.0D+00
        AMOM(3,ISET(K)) = 0.0D+00
C
       DO I = 1, NMPTS(K)
         DRX(I+L) = (EFC(1,I) - EFCENT(1,1))*XX
     *          + (EFC(2,I) - EFCENT(2,1))*XY
     *          + (EFC(3,I) - EFCENT(3,1))*XZ
          DRY(I+L) = (EFC(1,I) - EFCENT(1,1))*YX
     *          + (EFC(2,I) - EFCENT(2,1))*YY
     *          + (EFC(3,I) - EFCENT(3,1))*YZ
          DRZ(I+L) = (EFC(1,I) - EFCENT(1,1))*ZX
     *          + (EFC(2,I) - EFCENT(2,1))*ZY
     *          + (EFC(3,I) - EFCENT(3,1))*ZZ
C
          AMOM(1,ISET(K)) = AMOM(1,ISET(K)) + FMASS(I+L) *
     *                      (DRY(I+L)**2 + DRZ(I+L)**2)
          AMOM(2,ISET(K)) = AMOM(2,ISET(K)) + FMASS(I+L) *
     *                      (DRX(I+L)**2 + DRZ(I+L)**2)
          AMOM(3,ISET(K)) = AMOM(3,ISET(K)) + FMASS(I+L) *
     *                     (DRX(I+L)**2 + DRY(I+L)**2)
C
          IF(FMASS(I+L) .GT. ZERO) MASSFF=MASSFF+1
C
        ENDDO
C
C          MASSFF has counted EFP points with a non-zero mass,
C          which means it counts the nuclei in the fragment.
C          monatomic EFP should have unit moments of inertia set
        IF (MASSFF.EQ.1) THEN
          AMOM(1,ISET(K)) = 1.0D+00
          AMOM(2,ISET(K)) = 1.0D+00
          AMOM(3,ISET(K)) = 1.0D+00
        ENDIF
C
         FMASAL=FMASAL+FRGMAS(K)
C
          L = L + NMPTS(K)
    5       CONTINUE
C
C
         WMAS=18.01056D+00
C
      IF(NDFRG.EQ.1 .AND. FRGMAS(1).EQ.WMAS) THEN
C
C          this is the water-only case
C       Note that watmas = mass of water molecule in g/mol, simden =
C       density of simulation system assuming all molecules are like
C       molecule #1. Must change volume from Bohr^3 to Ang^3 to cm^3.
C
        WATMAS = ZERO
        SIMDEN = ZERO
        SIMDEN1 = ZERO
        DO I = 1,3
         WATMAS = WATMAS + FMASS(I)
        ENDDO
C
        IF(XBOX*YBOX*ZBOX.GT.1.0D-06) THEN
           SIMDEN=(NFRG/AVOGAD*WATMAS)/(XBOX*YBOX*ZBOX*AU2ANG**3
     *                                   *1.0D-8*1.0D-8*1.0D-8)
           IF(MASWRK) WRITE(IW,2000) NFRG,XBOX*AU2ANG,YBOX*AU2ANG,
     *                                    ZBOX*AU2ANG,SIMDEN
        ELSE
           SIMDEN=0.0d+00
        END IF
C
        VOL1 = ZERO
        BOXL1 = ZERO
        VOL1 = (NFRG/AVOGAD*WATMAS)/(1.0D-8)**3/0.99697D+00
        CUBERT=1.0D+00/3.0D+00
        BOXL1 = VOL1**CUBERT
        IF(MASWRK) WRITE(IW,2010) NFRG,BOXL1
C
C          this is the non-water case
C
      ELSE
C
        IF(XBOX*YBOX*ZBOX.GT.1.0D-06) THEN
           SIMDEN1=(FMASAL/AVOGAD)/(XBOX*YBOX*ZBOX*AU2ANG**3
     *                               *1.0D-8*1.0D-8*1.0D-8)
           IF(MASWRK) WRITE(IW,2001) NFRG,XBOX*AU2ANG,YBOX*AU2ANG,
     *                                    ZBOX*AU2ANG,SIMDEN1
        ELSE
           SIMDEN=0.0d+00
        END IF
C
      END IF
      RETURN
C
 2000 FORMAT(/1X,'*** MD SIMULATION WITH ',I5,' WATER MOLECULES'/
     *       1X,'*** BOX LENGTHS = ',3F12.4,' ANGSTROMS'/
     *       1X,'*** NVT DENSITY = ',F8.4,' G/ML')
 2001 FORMAT(/1X,'*** MD SIMULATION WITH ',I5,' MOLECULES'/
     *       1X,'*** BOX LENGTHS = ',3F8.4,' ANGSTROMS'/
     *       1X,'*** NVT DENSITY = ',F8.4,' G/ML')
 2010 FORMAT(1X,'*** FOR DENSITY OF 0.997 G/ML (300K EXPT) WITH ',I5,
     *         ' WATER MOLECULES'/
     *       5X,'THEORETICAL BOXLENGTH = ',F8.4,' ANGSTROMS'/)
C
      END
C
C*MODULE MDEFP   *DECK CLRTVE
      SUBROUTINE CLRTVE(NAT,NFRG)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXFRG=1050)
      PARAMETER (ZERO=0.0D+00)
C
      COMMON /ATMDAT/ VX(MXFRG), VY(MXFRG), VZ(MXFRG),
     *                QW(MXFRG), QX(MXFRG), QY(MXFRG), QZ(MXFRG),
     *                OX(MXFRG), OY(MXFRG), OZ(MXFRG), QW1(MXFRG),
     *                QX1(MXFRG),QY1(MXFRG),QZ1(MXFRG),QW2(MXFRG),
     *                QX2(MXFRG),QY2(MXFRG),QZ2(MXFRG),
     *                VXQM(MXATM), VYQM(MXATM), VZQM(MXATM)
      COMMON /MDSIM7/ VXO(MXFRG), VYO(MXFRG), VZO(MXFRG),
     *                WXO(MXFRG), WYO(MXFRG), WZO(MXFRG)
C
C        ****************************
C        *** setup arrays for MD  ***
C        ****************************
C
      DO I=1,NFRG
         VX(I) = ZERO
         VY(I) = ZERO
         VZ(I) = ZERO
         VXO(I) = ZERO
         VYO(I) = ZERO
         VZO(I) = ZERO
      ENDDO
C
      DO I=1,NAT
         VXQM(I) = ZERO
         VYQM(I) = ZERO
         VZQM(I) = ZERO
      ENDDO
      RETURN
      END
C
C*MODULE MDEFP   *DECK CLRMOM
      SUBROUTINE CLRMOM(NFRG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXFRG=1050)
      PARAMETER (ZERO=0.0D+00)
C
      COMMON /ATMDAT/ VX(MXFRG), VY(MXFRG), VZ(MXFRG),
     *                QW(MXFRG), QX(MXFRG), QY(MXFRG), QZ(MXFRG),
     *                OX(MXFRG), OY(MXFRG), OZ(MXFRG), QW1(MXFRG),
     *                QX1(MXFRG),QY1(MXFRG),QZ1(MXFRG),QW2(MXFRG),
     *                QX2(MXFRG),QY2(MXFRG),QZ2(MXFRG),
     *                VXQM(MXATM), VYQM(MXATM), VZQM(MXATM)
C
C       *********************************************************
C       *** setup rotational arrays for MD                    ***
C       *********************************************************
C
      DO I=1,NFRG
         OX(I) = ZERO
         OY(I) = ZERO
         OZ(I) = ZERO
      ENDDO
      RETURN
      END
C
C*MODULE MDEFP   *DECK CLRVEL
      SUBROUTINE CLRVEL(NFRG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXFRG=1050)
      PARAMETER (ZERO=0.0D+00)
      COMMON /MDVEL / WX(MXFRG),WY(MXFRG),WZ(MXFRG),TQI(3,MXFRG)
C
C       *********************************************************
C       *** setup rotational arrays for MD                    ***
C       *********************************************************
C
      DO I = 1, NFRG
         WX(I) = ZERO
         WY(I) = ZERO
         WZ(I) = ZERO
      ENDDO
      RETURN
      END
C
C*MODULE MDEFP   *DECK INITGR
      SUBROUTINE INITGR
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (NBIN=1000, ZERO=0.0D+00)
      PARAMETER (MAXRDF=100)
C
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /EFPPBC/ XBOX,YBOX,ZBOX,XCUT,YCUT,ZCUT,RCUT
     *                ,SWR1,SWR2,ISWF
      COMMON /GOFR  / GOFR(NBIN,3), GENFR(NBIN,MAXRDF), CCRDF(NBIN),
     *                GEN2FR(NBIN,2),
     *                DELR, NUMG, NUMSAM1,NUMSAM2,NUMSAM3
C
C        *********************************************************
C        *** initialize g(r) arrays, g(r) parameters      ***
C        *********************************************************
C
      BOX = MIN(XBOX,YBOX,ZBOX)
      NUMG = INT( BOX * AU2ANG * 0.5D+00 / DELR ) + 1
      IF ( NUMG .GT. NBIN ) THEN
        NUMG = NBIN
      ENDIF
      DO I = 1, 3
        DO J = 1, NUMG
          GOFR(J, I) = ZERO
        ENDDO
      ENDDO
      DO I = 1, MAXRDF
        DO J = 1, NUMG
          GENFR(J, I) = ZERO
        ENDDO
        DO K = 1,2
          GEN2FR(J, K) = ZERO
        ENDDO
      ENDDO
      DO J = 1, NUMG
        CCRDF(J) = ZERO
      ENDDO
      NUMSAM1 = 0
      NUMSAM2 = 0
      NUMSAM3 = 0
C
      CALL CALCDFRG
C
      RETURN
      END
C
C*MODULE MDEFP   *DECK RANDQ
      SUBROUTINE RANDQ
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXFRG=1050, MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (MXATM=2000)
C
      LOGICAL DEBUG
C
      DIMENSION ITIMST(6)
C
      COMMON /ATMDAT/ VX(MXFRG), VY(MXFRG), VZ(MXFRG),
     *                QW(MXFRG), QX(MXFRG), QY(MXFRG), QZ(MXFRG),
     *                OX(MXFRG), OY(MXFRG), OZ(MXFRG), QW1(MXFRG),
     *                QX1(MXFRG),QY1(MXFRG),QZ1(MXFRG),QW2(MXFRG),
     *                QX2(MXFRG),QY2(MXFRG),QZ2(MXFRG),
     *                VXQM(MXATM), VYQM(MXATM), VZQM(MXATM)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
C
      DEBUG=.TRUE.
      IF (DEBUG) THEN
         IX = 666000666
      ELSE
      CALL TMDATE(ITIMST)
      IX=0
      LENTIM=6
      IF(NWDVAR.EQ.1) LENTIM=3
      DO I=1,LENTIM
        IX=IX+ITIMST(I)
      ENDDO
      IX = IABS(IX)
      ENDIF
      IDUM = -IX
C
      DO I = 1, NFRG
C
         CALL RAND3(IDUM, RANM1)
         CALL RAND3(IDUM, RANM2)
         CALL RAND3(IDUM, RANM3)
         CALL RAND3(IDUM, RANM4)
          WX = 2.0D+00*RANM1-1.0D+00
          WY = 2.0D+00*RANM2-1.0D+00
          WZ = 2.0D+00*RANM3-1.0D+00
          WW = 2.0D+00*RANM4-1.0D+00
          RAT = SQRT(WX*WX + WY*WY + WZ*WZ + WW*WW)
          WXN = WX / RAT
          WYN = WY / RAT
          WZN = WZ / RAT
          WWN = WW / RAT
C
          QW(I) = WWN
          QX(I) = WXN
          QY(I) = WYN
          QZ(I) = WZN
      ENDDO
      RETURN
      END
C
C*MODULE MDEFP   *DECK VVERMOVE
       SUBROUTINE VVERMOVE(INTMD,ISTEP,NPROP)
C       *********************************************************
C       *** Integrate equations of motion using a velocity    ***
C       *** verlet algorithm and quaternions                  ***
C       *********************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION MDTYP,IRATYZ,IRATZX,IRATXY
      CHARACTER*8 FRCNME,LJNAME,ELJNAM
      LOGICAL IFRCPNT
C
      PARAMETER (MXFGPT=12000, MXFRG=1050,
     *           MXPT=2000, MXDFG=5, MXDPPT=MXFRG*MXDFG*12,
     *           MXAO=8192, MXSHEF=1000, MXGEFP=4000)
      PARAMETER (MXATM=2000)
C
      PARAMETER (TWO=2.0D+00)
C
      DIMENSION WX0(MXFRG),WY0(MXFRG),WZ0(MXFRG)
      DIMENSION IRATYZ(MXDFG),IRATZX(MXDFG),IRATXY(MXDFG)
      DIMENSION CL(MXFRG),PX(MXFRG),PY(MXFRG),PZ(MXFRG),QQQ(MXFRG)
      DIMENSION PWB(MXFRG),PXB(MXFRG),PYB(MXFRG),PZB(MXFRG)
C
      COMMON /ATMDAT/ VX(MXFRG), VY(MXFRG), VZ(MXFRG),
     *                QW(MXFRG), QX(MXFRG), QY(MXFRG), QZ(MXFRG),
     *                OX(MXFRG), OY(MXFRG), OZ(MXFRG), QW1(MXFRG),
     *                QX1(MXFRG),QY1(MXFRG),QZ1(MXFRG),QW2(MXFRG),
     *                QX2(MXFRG),QY2(MXFRG),QZ2(MXFRG),
     *                VXQM(MXATM), VYQM(MXATM), VZQM(MXATM)
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NATEF(MXDFG),NUMEF(MXDFG),NTPATM
      COMMON /EFPFRC/ IFRCPNT,NTFRCPN,NFRCPNT(MXFRG),LSTFPTS(MXFRG),
     *                FRCCRD(3,MXFGPT),FRCNME(MXFGPT),FRCTRQ(6,MXFGPT),
     *                FRCTRQX(6,MXFGPT)
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FMCOM / XX(1)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGLJP/ CORDLJ(3,MXPT),ELJCRD(3,MXFGPT),
     *                POTLJ(2,MXPT),ELJPOT(2,MXFGPT),
     *                LJNAME(MXPT),ELJNAM(MXFGPT),
     *                NLJPTS(MXFRG),NLJTTPT,ILJP,NMLJ(2)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /EFPCT / NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CTFOK(MXAO,MXDFG),NCTMO(MXDFG),NTCTMO
      COMMON /FUNCT / E, EG(3,MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MASSES/ ZMASS(MXATM)
      COMMON /MDSIM / DT, BATHT, EKINT, EKINR, MDTYP
      COMMON /MDSIM7/ VXO(MXFRG), VYO(MXFRG), VZO(MXFRG),
     *                WXO(MXFRG), WYO(MXFRG), WZO(MXFRG)
      COMMON /MDVEL / WX(MXFRG),WY(MXFRG),WZ(MXFRG),TQI(3,MXFRG)
      COMMON /MODDAT/ AMOM(3,MXDFG), TOTMAS(MXDFG), TOTMAI(MXDFG),
     *                DRX(MXFGPT), DRY(MXFGPT), DRZ(MXFGPT)
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
C
      NMST = 0
      NPST = 0
      NLJST = 0
      NDPST = 0
      NRST = 0
      NATST = 0
      NORST = 0
      NDST = 0
      NCTMOST = 0
      NTFRCPN = 0
C
      CALL MDNOSEVV
C
      DT6=DT*DT/TWO
      DT2=DT/TWO
C          FOR QM PART
      DO I = 1, NAT
         ZMASSI = 1.0D+00/ZMASS(I)
C     r(t+dt) = r(t) + dt * v(t) + 0.5*dt*dt a(t)
         C(1,I) = C(1,I) + DT*VXQM(I) + DT6*EG(1,I)*ZMASSI
         C(2,I) = C(2,I) + DT*VYQM(I) + DT6*EG(2,I)*ZMASSI
         C(3,I) = C(3,I) + DT*VZQM(I) + DT6*EG(3,I)*ZMASSI
C     velocities at mid-step  (v(t+dt/2))
C     v(t+dt/2) = v(t) + dt/2 * a(t)
         VXQM(I)=VXQM(I) + DT2*EG(1,I)*ZMASSI
         VYQM(I)=VYQM(I) + DT2*EG(2,I)*ZMASSI
         VZQM(I)=VZQM(I) + DT2*EG(3,I)*ZMASSI
      END DO
C
      MXBF=0
C
      DO I=1,NFRG
         MXBF=MAX(MXBF,NPBF(I))
      END DO
      CALL VALFM(LOADFM)
      LPROVEC = LOADFM  + 1
      LCTVEC  = LPROVEC + MXBF*NTMO
      LAST    = LCTVEC  + MXBF*NTCTMO
C
      NEED=LAST-LOADFM-1
      CALL GETFM(NEED)
      LENPV=MXBF*NTMO
      IF (NFRG.GT.0.AND.NTMO.GT.0)
     *   CALL DAREAD(IDAF,IODA,XX(LPROVEC),LENPV,267,0)
      LENCV=MXBF*NTCTMO
      IF (NFRG.GT.0.AND.NTCTMO.GT.0)
     *     CALL DAREAD(IDAF,IODA,XX(LCTVEC),LENCV,269,0)
C
      DO 4001 J=1,NFRG
C
C
      IRATYZ(ISET(J))=(AMOM(2,ISET(J))-
     *                AMOM(3,ISET(J)))/AMOM(1,ISET(J))
      IRATZX(ISET(J))=(AMOM(3,ISET(J))-
     *                 AMOM(1,ISET(J)))/AMOM(2,ISET(J))
      IRATXY(ISET(J))=(AMOM(1,ISET(J))-
     *                 AMOM(2,ISET(J)))/AMOM(3,ISET(J))
C       generate the correction coefficients
           S1=QW1(J)**2+QX1(J)**2+QY1(J)**2+QZ1(J)**2
           S2=QW1(J)*QW2(J)+QX1(J)*QX2(J)+QY1(J)*QY2(J)+QZ1(J)*QZ2(J)
           S3=QW2(J)**2+QX2(J)**2+QY2(J)**2+QZ2(J)**2
           S4=1-DT*DT*S1-DT*DT*DT*S2-DT6*DT6*(S3-S1*S1)
           CL(J)=1.0D+00-DT6*S1-SQRT(S4)
4001    CONTINUE
C Set Inital Velocities for Diffusion
      IF(ISTEP.EQ.1 .OR. ISTEP.EQ.NPROP-1) THEN
       DO J=1,NFRG
           VXO(J) = VX(J)
           VYO(J) = VY(J)
           VZO(J) = VZ(J)
       ENDDO
      ENDIF
C
      DO 40 J=1,NFRG
C     Move positions to t+dt. Note
C     r(t+dt) = r(t)+dt*v(t)+1/2*dt^2*a(t)
C     AND r(t) is included in mddspq.src
        CENTDX=(VX(J)*DT+DT6*DEFT(1,J)*TOTMAI(ISET(J)))
        CENTDY=(VY(J)*DT+DT6*DEFT(2,J)*TOTMAI(ISET(J)))
        CENTDZ=(VZ(J)*DT+DT6*DEFT(3,J)*TOTMAI(ISET(J)))
C
        VX(J)=VX(J)+DT2*DEFT(1,J)*TOTMAI(ISET(J))
        VY(J)=VY(J)+DT2*DEFT(2,J)*TOTMAI(ISET(J))
        VZ(J)=VZ(J)+DT2*DEFT(3,J)*TOTMAI(ISET(J))
C
C   Save quaternions at time t
        QWSAV = QW(J)
        QXSAV = QX(J)
        QYSAV = QY(J)
        QZSAV = QZ(J)
C      write(6,*) 'Frag ',j,' Old Q: ',qwsav,qxsav,qysav,qzsav
C     Integrate quaternions, form Q(t+dt), add corrections:
C     Q(t+dt) = Q(t) + Q1d(t)*dt + 1/2*dt^2*Q2d(t) - c1*Q(t)
       QW(J)=QW(J)+DT*QW1(J)+DT6*QW2(J)-CL(J)*QW(J)
       QX(J)=QX(J)+DT*QX1(J)+DT6*QX2(J)-CL(J)*QX(J)
       QY(J)=QY(J)+DT*QY1(J)+DT6*QY2(J)-CL(J)*QY(J)
       QZ(J)=QZ(J)+DT*QZ1(J)+DT6*QZ2(J)-CL(J)*QZ(J)
C       write(6,*) 'Frag ',j,' New Q: ',qw(j),qx(j),qy(j),qz(j)
C
C  Do rotation and translation to get ecp to t+dt
C  Note: we need to call efcm before coming back
C        here to get newest COM coords
C
       CALL MDDSPQ(J,CENTDX,CENTDY,CENTDZ,QWSAV,QXSAV,QYSAV,QZSAV,
     *             QW(J),QX(J),QY(J),QZ(J),
     *             NMST,NPST,NLJST,NDPST,NRST,NDST,
     *             NATST,NORST,XX(LPROVEC),
     *             NCTMOST,XX(LCTVEC),MXBF,INTMD)
C
      NMST  = NMST  + NMPTS(J)
      NPST  = NPST  + NPPTS(J)
      NLJST = NLJST + NLJPTS(J)
      NDPST = NDPST + NDPPTS(J)
      NRST  = NRST  + NRPTS(J)
      NDST  = NDST  + NDPTS(J)
      NATST = NATST + NATEF(ISET(J))
      NORST = NORST + NORB(J)
      NCTMOST = NCTMOST + NCTMO(ISET(J))
      NTFRCPN=NTFRCPN + NFRCPNT(I)
      LSTFPTS(I+1) = LSTFPTS(I)+NFRCPNT(I)
C
   40 CONTINUE
C
C
      IF (NFRG.GT.0.AND.NTMO.GT.0)
     *     CALL DAWRIT(IDAF,IODA,XX(LPROVEC),LENPV,267,0)
      IF (NFRG.GT.0.AND.NTCTMO.GT.0)
     *     CALL DAWRIT(IDAF,IODA,XX(LCTVEC),LENCV,269,0)
      CALL RETFM(NEED)
C
C     Form inertia ratio, part of zeroth est. of w0:
C     w0 = w(t) + 1/2*dt*w1d(t)
C     where w1d(t) = torq/imom + irat*w*w
      DO 60 I=1,NFRG
       PX(I)=IRATYZ(ISET(I))*WY(I)*WZ(I)
       PY(I)=IRATZX(ISET(I))*WZ(I)*WX(I)
       PZ(I)=IRATXY(ISET(I))*WX(I)*WY(I)
       WX0(I)=WX(I)+DT2*(TQI(1,I)+PX(I))
       WY0(I)=WY(I)+DT2*(TQI(2,I)+PY(I))
       WZ0(I)=WZ(I)+DT2*(TQI(3,I)+PZ(I))
   60 CONTINUE
C
C        Calculate energy and forces at new t+dt
C
       IF (NAT.EQ.0) THEN !MDTYP.EQ.EFP) THEN
           CALL ENEDEF
           CALL TORQMO
        ELSE
           CALL ENEDAB
           IF(NFRG.GT.0) CALL TORQMO
        END IF
C
C          QM PART
      DO I = 1, NAT
C     Move velocity from t+1/2dt to t+dt:
C     v(t+dt) = v(t+1/2dt) + 1/2*dt*a(t+dt)
         ZMASSI  = 1.0D+00/ZMASS(I)
         VXQM(I) = VXQM(I) + DT2*EG(1,I)*ZMASSI
         VYQM(I) = VYQM(I) + DT2*EG(2,I)*ZMASSI
         VZQM(I) = VZQM(I) + DT2*EG(3,I)*ZMASSI
      END DO
C
C
       DO 80 I=1,NFRG
C
C      Move velocity from t+1/2dt to t+dt:
C      v(t+dt) = v(t+1/2dt) + 1/2*dt*a(t+dt)
        VX(I) = VX(I)+DT2*DEFT(1,I)*TOTMAI(ISET(I))
        VY(I) = VY(I)+DT2*DEFT(2,I)*TOTMAI(ISET(I))
        VZ(I) = VZ(I)+DT2*DEFT(3,I)*TOTMAI(ISET(I))
C
C      Change torq(t+dt) --> torq(t+dt)/amom
C        tqi(1,i)=torq(1,i)/amom(1)
C        tqi(2,i)=torq(2,i)/amom(2)
C        tqi(3,i)=torq(3,i)/amom(3)
C
C      Form first part of quat 2nd derivative:
C      Qd2(t+dt) = 1/2 * M * (torq/amom)
         QW2(I)=0.5D+00*(-QY(I)*TQI(1,I)-QZ(I)*TQI(2,I)+
     1         QX(I)*TQI(3,I))
         QX2(I)=0.5D+00*( QZ(I)*TQI(1,I)-QY(I)*TQI(2,I)-
     2         QW(I)*TQI(3,I))
         QY2(I)=0.5D+00*(QW(I)*TQI(1,I)+QX(I)*TQI(2,I)+
     3         QZ(I)*TQI(3,I))
         QZ2(I)=0.5D+00*(-QX(I)*TQI(1,I)+QW(I)*TQI(2,I)-
     4         QY(I)*TQI(3,I))
C
C      Form zeroth est. for w0 at t+dt:
C      w0(t+dt) = w0 + 1/2 * dt * tqi(t+dt)/amom
        WX0(I)=WX0(I)+DT2*TQI(1,I)
        WY0(I)=WY0(I)+DT2*TQI(2,I)
        WZ0(I)=WZ0(I)+DT2*TQI(3,I)
C
C      New px, py, pz with w0(t+dt) estimates
        PX(I)=IRATYZ(ISET(I))*WY0(I)*WZ0(I)
        PY(I)=IRATZX(ISET(I))*WZ0(I)*WX0(I)
        PZ(I)=IRATXY(ISET(I))*WX0(I)*WY0(I)
C
C      Form new angular velocity and p:
C      w(t+dt) = w0(t+dt) + 1/2 * dt * irat*w*w
        DO 350 L=1,3
           WX(I)=WX0(I)+PX(I)*DT2
           WY(I)=WY0(I)+PY(I)*DT2
           WZ(I)=WZ0(I)+PZ(I)*DT2
           PX(I)=IRATYZ(ISET(I))*WY(I)*WZ(I)
           PY(I)=IRATZX(ISET(I))*WZ(I)*WX(I)
           PZ(I)=IRATXY(ISET(I))*WX(I)*WY(I)
  350   CONTINUE
   80 CONTINUE
C
C
        DO 4005 I=1,NFRG
C      Generate the first time derivatives of the Q's.
         QW1(I)=(-QY(I)*WX(I)-QZ(I)*WY(I)+QX(I)*WZ(I) )*0.5D+00
         QX1(I)=( QZ(I)*WX(I)-QY(I)*WY(I)-QW(I)*WZ(I) )*0.5D+00
         QY1(I)=( QW(I)*WX(I)+QX(I)*WY(I)+QZ(I)*WZ(I) )*0.5D+00
         QZ1(I)=(-QX(I)*WX(I)+QW(I)*WY(I)-QY(I)*WZ(I) )*0.5D+00
          QQQ(I)=QW1(I)*QW1(I)+QX1(I)*QX1(I)+
     Q            QY1(I)*QY1(I)+QZ1(I)*QZ1(I)
         PX(I)=IRATYZ(ISET(I))*WY(I)*WZ(I)
         PY(I)=IRATZX(ISET(I))*WZ(I)*WX(I)
         PZ(I)=IRATXY(ISET(I))*WX(I)*WY(I)
            PWB(I)=0.5D+00*(-QY(I)*PX(I)-QZ(I)*PY(I)+
     1       QX(I)*PZ(I))
            PXB(I)=0.5D+00*( QZ(I)*PX(I)-QY(I)*PY(I)-
     2       QW(I)*PZ(I))
            PYB(I)=0.5D+00*( QW(I)*PX(I)+QX(I)*PY(I)+
     3       QZ(I)*PZ(I))
            PZB(I)=0.5D+00*(-QX(I)*PX(I)+QW(I)*PY(I)-
     4       QY(I)*PZ(I))
C        Complete the second time derivatives of the Q's
         QW2(I)=QW2(I)-QW(I)*QQQ(I)+PWB(I)
         QX2(I)=QX2(I)-QX(I)*QQQ(I)+PXB(I)
         QY2(I)=QY2(I)-QY(I)*QQQ(I)+PYB(I)
         QZ2(I)=QZ2(I)-QZ(I)*QQQ(I)+PZB(I)
C       qchk(i)=qw(i)**2+qx(i)**2+qy(i)**2+qz(i)**2
C       qchk2(i)=qw(i)*qw1(i)+qx(i)*qx1(i)+qy(i)*qy1(i)+
C     *            qz(i)*qz1(i)
C        if(i.le.5) then
C       write(6,*) 'i,qchk,qchk2 = ',i,qchk(i),qchk2(i)
C        endif
4005   CONTINUE
C     MDNOSEVV included Kinetic energy calculation
       CALL MDNOSEVV
C
C
C      Translational and Rotational KE at t+dt
C
C                ekint = half * ek2kcal * TOTMAS * ekint
       EKINT = EK2KCAL * EKINT
       EKINR = EK2KCAL * EKINR
       RETURN
       END
C*MODULE MDEFP   *DECK TORQMO
      SUBROUTINE TORQMO
C        *********************************************************
C        *** torque to torque/moment of inertia  ***
C        *********************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXFGPT=12000,MXFRG=1050,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (MXATM=2000)
C
      COMMON /ATMDAT/ VX(MXFRG), VY(MXFRG), VZ(MXFRG),
     *                QW(MXFRG), QX(MXFRG), QY(MXFRG), QZ(MXFRG),
     *                OX(MXFRG), OY(MXFRG), OZ(MXFRG), QW1(MXFRG),
     *                QX1(MXFRG),QY1(MXFRG),QZ1(MXFRG),QW2(MXFRG),
     *                QX2(MXFRG),QY2(MXFRG),QZ2(MXFRG),
     *                VXQM(MXATM), VYQM(MXATM), VZQM(MXATM)
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /MDVEL / WX(MXFRG),WY(MXFRG),WZ(MXFRG),TQI(3,MXFRG)
      COMMON /MODDAT/ AMOM(3,MXDFG), TOTMAS(MXDFG), TOTMAI(MXDFG),
     *                DRX(MXFGPT), DRY(MXFGPT), DRZ(MXFGPT)
C
C      Change torq(t+dt) --> torq(t+dt)/amom
C
       DO I=1,NFRG
         AXX=-QW(I)**2+QX(I)**2-QY(I)**2+QZ(I)**2
         AXY= 2.0D+00*(QY(I)*QZ(I)-QW(I)*QX(I))
         AXZ= 2.0D+00*(QX(I)*QY(I)+QW(I)*QZ(I))
C
         AYX=-2.0D+00*(QW(I)*QX(I)+QY(I)*QZ(I))
         AYY= QW(I)**2-QX(I)**2-QY(I)**2+QZ(I)**2
         AYZ= 2.0D+00*(QX(I)*QZ(I)-QW(I)*QY(I))
C
         AZX= 2.0D+00*(QX(I)*QY(I)-QW(I)*QZ(I))
         AZY=-2.0D+00*(QW(I)*QY(I)+QX(I)*QZ(I))
         AZZ=-QW(I)**2-QX(I)**2+QY(I)**2+QZ(I)**2
C
        TQI(1,I)=AXX*TORQ(1,I)+AXY*TORQ(2,I)+AXZ*TORQ(3,I)
        TQI(2,I)=AYX*TORQ(1,I)+AYY*TORQ(2,I)+AYZ*TORQ(3,I)
        TQI(3,I)=AZX*TORQ(1,I)+AZY*TORQ(2,I)+AZZ*TORQ(3,I)
C
C
        TQI(1,I)=TQI(1,I)/AMOM(1,ISET(I))
        TQI(2,I)=TQI(2,I)/AMOM(2,ISET(I))
        TQI(3,I)=TQI(3,I)/AMOM(3,ISET(I))
       ENDDO
      RETURN
      END
C
C*MODULE MDEFP   *DECK RANBS
      SUBROUTINE RANBS(ISEED,RANDOM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER*4 I,I1,I2,I3,I4,I5,I6,I7,I8,I9
      DATA I2/16807/,I4/32768/,I5/65536/,I3/2147483647/
C
C           algorithm is based on 4-byte values, but the
C           seed's data type is left to compiler flags.
C
      I=ISEED
C
      I6=I/I5
      I7=(I-I6*I5)*I2
      I8=I7/I5
      I9=I6*I2+I8
      I1=I9/I4
      I=(((I7-I8*I5)-I3)+(I9-I1*I4)*I5)+I1
      IF(I.LT.0) I=I+I3
C
      RANDOM=(4.656613D-10)*I
      ISEED=I
      RETURN
      END
C
C*MODULE MDEFP   *DECK NORMT
      SUBROUTINE NORMT(TEMP,NAT,SET,LENSET)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXFGPT=12000,MXFRG=1050,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      LOGICAL FIRST
C
      DIMENSION SET(LENSET)
C
      COMMON /ATMDAT/ VX(MXFRG), VY(MXFRG), VZ(MXFRG),
     *                QW(MXFRG), QX(MXFRG), QY(MXFRG), QZ(MXFRG),
     *                OX(MXFRG), OY(MXFRG), OZ(MXFRG), QW1(MXFRG),
     *                QX1(MXFRG),QY1(MXFRG),QZ1(MXFRG),QW2(MXFRG),
     *                QX2(MXFRG),QY2(MXFRG),QZ2(MXFRG),
     *                VXQM(MXATM), VYQM(MXATM), VZQM(MXATM)
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /MASSES/ ZMASS(MXATM)
C
      SAVE ISEED,FIRST
C
      DATA FIRST/.TRUE./
C
      BOLTZK = 0.83112120D+00/1.0D-12/1.0D-12/AU2ANG/AU2ANG
C
C     for u1,u2 uniformly distrib on (0,1)
C     x = sqrt(-2*ln(u1)) * cos(2*pi*u2)
C     gives normally distrib x on (-inf,+inf)
C
      IF(FIRST) ISEED=1234567
      FIRST=.FALSE.
C
      PI=4.0D+00*ATAN(1.0D+00)
      NTEST=(NFRG+NAT)*3
      XMEAN=0.0D+00
C
      DO I=1,NTEST
        CALL RANBS(ISEED,U1)
        CALL RANBS(ISEED,U2)
        SET(I) = SQRT(-2.0D+00*LOG(U1)) * COS(2.0D+00*PI*U2)
        XMEAN=XMEAN+SET(I)
      ENDDO
      XMEAN=XMEAN/NTEST
C
      XMSD =0.0D+00
      DO I=1,NTEST
        XMSD=XMSD+(SET(I)-XMEAN)**2
      ENDDO
      XMSD=XMSD/NTEST
C
C      write(*,'('' Mean and RMSD = '',2f10.5)') xmean,sqrt(xmsd)
C
C     we multiply the random number by sqrt(kT/m) to
C     get a velocity in units of sqrt(kcal/(mole-amu))
C     this is our internal velocity unit so that
C     sum over m*v**2 has units of kcal/mole
C
C
C      energy=0.0d+00
      J=0
      DO I=1,NFRG
        SIGMA=SQRT(BOLTZK*TEMP/FRGMAS(I))
        VX(I)=SIGMA*SET(J+1)
        VY(I)=SIGMA*SET(J+2)
        VZ(I)=SIGMA*SET(J+3)
        J=J+3
C        energy=energy+0.5d+00*hmass*veloc**2
      ENDDO
C
      DO I=1,NAT
        SIGMA=SQRT(BOLTZK*TEMP/ZMASS(I))
        VXQM(I)=SIGMA*SET(J+1)
        VYQM(I)=SIGMA*SET(J+2)
        VZQM(I)=SIGMA*SET(J+3)
        J=J+3
      ENDDO
C
C
C     compute temperature from this KE
C     corresponds to ntest degrees of freedom
C      temp = energy/(0.5d+00*boltz*ntest)
C      write(*,'('' Temperature = '',f10.5)') temp
C
C
      RETURN
      END
C
C*MODULE MDEFP   *DECK NORMW
      SUBROUTINE NORMW(TEMP,SET,LENSET)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXFGPT=12000,MXFRG=1050,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      LOGICAL FIRST
C
      DIMENSION SET(LENSET)
C
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /MDVEL / WX(MXFRG),WY(MXFRG),WZ(MXFRG),TQI(3,MXFRG)
      COMMON /MODDAT/ AMOM(3,MXDFG), TOTMAS(MXDFG), TOTMAI(MXDFG),
     *                  DRX(MXFGPT), DRY(MXFGPT), DRZ(MXFGPT)
C
      SAVE ISEED,FIRST
C
      DATA FIRST/.TRUE./
C
      BOLTZK = 0.83112120D+00/1.0D-12/1.0D-12/AU2ANG/AU2ANG
C
C     for u1,u2 uniformly distrib on (0,1)
C     x = sqrt(-2*ln(u1)) * cos(2*pi*u2)
C     gives normally distrib x on (-inf,+inf)
C
      IF(FIRST) ISEED=7654321
      FIRST=.FALSE.
C
      PI=4.0D+00*ATAN(1.0D+00)
      NTEST=NFRG*3
      XMEAN=0.0D+00
C
      DO I=1,NTEST
        CALL RANBS(ISEED,U1)
        CALL RANBS(ISEED,U2)
        SET(I) = SQRT(-2.0D+00*LOG(U1)) * COS(2.0D+00*PI*U2)
        XMEAN=XMEAN+SET(I)
      ENDDO
      XMEAN=XMEAN/NTEST
C
      XMSD =0.0D+00
      DO I=1,NTEST
        XMSD=XMSD+(SET(I)-XMEAN)**2
      ENDDO
      XMSD=XMSD/NTEST
C
C      write(*,'('' Mean and RMSD = '',2f10.5)') xmean,sqrt(xmsd)
C
C     we multiply the random number by sqrt(kT/m) to
C     get a velocity in units of sqrt(kcal/(mole-amu))
C     this is our internal velocity unit so that
C     sum over m*v**2 has units of kcal/mole
C
C
C      energy=0.0d+00
      J=0
      DO I=1,NFRG
         SIGMAX=SQRT(BOLTZK*TEMP/AMOM(1,ISET(I)))
         SIGMAY=SQRT(BOLTZK*TEMP/AMOM(2,ISET(I)))
         SIGMAZ=SQRT(BOLTZK*TEMP/AMOM(3,ISET(I)))
         WX(I)=SIGMAX*SET(J+1)
         WY(I)=SIGMAY*SET(J+2)
         WZ(I)=SIGMAZ*SET(J+3)
         J=J+3
C        energy=energy+0.5d+00*hmass*veloc**2
      ENDDO
C
C     compute temperature from this KE
C     corresponds to ntest degrees of freedom
C      temp = energy/(0.5d+00*boltz*ntest)
C      write(*,'('' Temperature = '',f10.5)') temp
C
C
      RETURN
      END
C
C*MODULE MDEFP   *DECK EU2QUT
      SUBROUTINE EU2QUT
C       *********************************************************
C       *** get correct quaternions from coordinates and    *****
C       *** Euler angles.                                     ***
C       *********************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXFGPT=12000, MXFRG=1050,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (MXATM=2000)
      CHARACTER*8 FRGNME
      DIMENSION R(3,3),VSCRATCH(9),COORD(3,3)
C---  dimension rt(3,3)
C
      COMMON /ATMDAT/ VX(MXFRG), VY(MXFRG), VZ(MXFRG),
     *                QW(MXFRG), QX(MXFRG), QY(MXFRG), QZ(MXFRG),
     *                OX(MXFRG), OY(MXFRG), OZ(MXFRG), QW1(MXFRG),
     *                QX1(MXFRG),QY1(MXFRG),QZ1(MXFRG),QW2(MXFRG),
     *                QX2(MXFRG),QY2(MXFRG),QZ2(MXFRG),
     *                VXQM(MXATM), VYQM(MXATM), VZQM(MXATM)
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
C
      IC1 = 0
      DO I = 1,NFRG
         IC1 = IC1 + 1
C       first get rotation matrix from molecule frame to lab frame
C
C       Compute the Euler angles between lab frame and molecule frame
C
C       get unit vector parallel to dipole moment
         COORD(1,1) = EFC(1,IC1) - EFCENT(1,I)
        COORD(1,2) = EFC(2,IC1) - EFCENT(2,I)
        COORD(1,3) = EFC(3,IC1) - EFCENT(3,I)
        COORD(2,1) = EFC(1,IC1+1) - EFCENT(1,I)
        COORD(2,2) = EFC(2,IC1+1) - EFCENT(2,I)
        COORD(2,3) = EFC(3,IC1+1) - EFCENT(3,I)
        COORD(3,1) = EFC(1,IC1+2) - EFCENT(1,I)
        COORD(3,2) = EFC(2,IC1+2) - EFCENT(2,I)
        COORD(3,3) = EFC(3,IC1+2) - EFCENT(3,I)
C
        UX=COORD(2,1)+COORD(3,1)-2.0D+00*COORD(1,1)
        UY=COORD(2,2)+COORD(3,2)-2.0D+00*COORD(1,2)
        UZ=COORD(2,3)+COORD(3,3)-2.0D+00*COORD(1,3)
C
C
C
C        ux=efc(1,ic1+1)+efc(1,ic1+2)-2.0d+00*efc(1,ic1)
C        uy=efc(2,ic1+1)+efc(2,ic1+2)-2.0d+00*efc(2,ic1)
C        uz=efc(3,ic1+1)+efc(3,ic1+2)-2.0d+00*efc(3,ic1)
        U=SQRT(UX**2+UY**2+UZ**2)
        UX=-UX/U
        UY=-UY/U
        UZ=-UZ/U
C       vector (ux,uy,uz) is now in direction of principle +z axis
C       (this is opposite in direction to dipole moment)
C
C       theta is angle in range 0 to pi between principle axis
C       and +z lab axis,
C       cos(theta)=uz; sin(theta)=sqrt(ux**2+uy**2)
C
        THETA=ATAN2(SQRT(UX**2+UY**2),UZ)
C
C       phi is angle in range -pi to pi about the lab frame z axis
C       between the lab frame x axis and the projection of the molecule
C       frame z axis onto the xy lab frame plane
C---    phix=atan2(uy,ux)
C       phi is angle in range -pi to pi about the lab frame z axis
C       between the lab frame y axis and the projection of the molecule
C       frame z axis onto the xy lab frame plane
        PHIY=-ATAN2(UX,UY)
C
C       following computes chi by applying a pair of rotations designed
C       to orient the molecule dipole along the lab frame z axis
C       first rotate by -phiy about z; then rotate by theta about x
        PHI=PHIY
        R(1,1)= COS(PHI)
        R(2,1)=-COS(THETA)*SIN(PHI)
        R(3,1)=-SIN(THETA)*SIN(PHI)
        R(1,2)= SIN(PHI)
        R(2,2)= COS(THETA)*COS(PHI)
        R(3,2)= SIN(THETA)*COS(PHI)
        R(1,3)= 0.0D+00
        R(2,3)=-SIN(THETA)
        R(3,3)= COS(THETA)
C       translate the molecule so its COM is at origin,
C       actually, the data in coord is ALREADY reletive to COM
C       apply rotation matrix
        VSCRATCH(1)=COORD(1,1)
        VSCRATCH(2)=COORD(1,2)
        VSCRATCH(3)=COORD(1,3)
        VSCRATCH(4)=COORD(2,1)
        VSCRATCH(5)=COORD(2,2)
        VSCRATCH(6)=COORD(2,3)
        VSCRATCH(7)=COORD(3,1)
        VSCRATCH(8)=COORD(3,2)
        VSCRATCH(9)=COORD(3,3)
C
C
        CALL ROTBILL(R,VSCRATCH)
C
C       now determine the chi angle to rotate about the z axis
C       to put H2 in the y-z plane of the molecule frame
C
        CHI=-ATAN2( VSCRATCH(7),VSCRATCH(8))
C       following matrix rotates by -chi about +z
        R(1,1)= COS(CHI)
        R(2,1)=-SIN(CHI)
        R(3,1)= 0.0D+00
        R(1,2)= SIN(CHI)
        R(2,2)= COS(CHI)
        R(3,2)= 0.0D+00
        R(1,3)= 0.0D+00
        R(2,3)= 0.0D+00
        R(3,3)= 1.0D+00
        CALL ROTBILL(R,VSCRATCH)
C
C       using the computed theta, phi, chi angles, construct
C       the matrix that rotates from the molecule frame to lab frame
C       the matrix that changes a vector from the lab basis to the
C       principle axis basis
C
C        Use zxz convention
          PHI=PHIY
          THETA=-THETA
C         following matrix rotates by phi about +z axis
C         then by theta about the new +x axis
C         then by chi about the new +z axis
          R(1,1)=-COS(THETA)*SIN(PHI)*SIN(CHI)+COS(PHI)*COS(CHI)
          R(2,1)=-COS(THETA)*SIN(PHI)*COS(CHI)-COS(PHI)*SIN(CHI)
          R(3,1)= SIN(THETA)*SIN(PHI)
          R(1,2)=+COS(THETA)*COS(PHI)*SIN(CHI)+SIN(PHI)*COS(CHI)
          R(2,2)=+COS(THETA)*COS(PHI)*COS(CHI)-SIN(PHI)*SIN(CHI)
          R(3,2)=-SIN(THETA)*COS(PHI)
          R(1,3)= SIN(THETA)*SIN(CHI)
          R(2,3)= SIN(THETA)*COS(CHI)
          R(3,3)= COS(THETA)
C
C       the rotation matrices constructed should transform the lab
C       frame displacement vectors into the principle molecule frame
C
C       use this matrix to rotate from molecule frame to lab frame
C---    do j=1,3
C---      do k=1,3
C---         rt(j,k)=r(k,j)
C---      enddo
C---    enddo
C
C       evaluate quaternions
C
C       following relationships are in Mountain's and Evans' papers
C       CONFIRMED that the Euler angles to use in these exPRESSions
C       are those from the zxz convention.
        QCHI =COS(THETA/2.0D+00)*COS((CHI+PHI)/2.0D+00)
        QETA =SIN(THETA/2.0D+00)*COS((CHI-PHI)/2.0D+00)
        QXI  =SIN(THETA/2.0D+00)*SIN((CHI-PHI)/2.0D+00)
        QZETA=COS(THETA/2.0D+00)*SIN((CHI+PHI)/2.0D+00)
C
C       following are in Mountain's and Evan's papers
        QW(I)=QXI
        QX(I)=QETA
        QY(I)=QZETA
        QZ(I)=QCHI
C
C        if(i.le.6) then
C       following is from Evans
C        rq(1,1) =-qxi**2+qeta**2-qzeta**2+qchi**2
C        rq(2,1) = -2*(qxi*qeta+qzeta*qchi)
C        rq(3,1) =  2*(qeta*qzeta-qxi*qchi)
C
C        rq(1,2) =  2*(qzeta*qchi-qxi*qeta)
C        rq(2,2) =+qxi**2-qeta**2-qzeta**2+qchi**2
C        rq(3,2) = -2*(qxi*qzeta+qeta*qchi)
C
C        rq(1,3) =  2*(qeta*qzeta+qxi*qchi)
C        rq(2,3) =  2*(qeta*qchi-qxi*qzeta)
C        rq(3,3) =-qxi**2-qeta**2+qzeta**2+qchi**2
C
        IC1 = IC1+NMPTS(I)-1
        ENDDO
C
        RETURN
        END
C
C*MODULE MDEFP   *DECK ROTBILL
      SUBROUTINE ROTBILL(R,C)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION R(3,3),C(9),CDUM(3)
C
C        ********************************************************
C        *** utility routine to apply 3-by-3 rotation matrix  ***
C        ***  to three vectors                                ***
C        ********************************************************
C
      DO I=1,3
        SUM=0.0D+00
        DO J=1,3
          SUM=SUM+R(I,J)*C(J)
        ENDDO
        CDUM(I)=SUM
      ENDDO
      DO I=1,3
        C(I)=CDUM(I)
      ENDDO
C
      DO I=1,3
        SUM=0.0D+00
        DO J=1,3
          SUM=SUM+R(I,J)*C(3+J)
        ENDDO
        CDUM(I)=SUM
      ENDDO
      DO I=1,3
        C(3+I)=CDUM(I)
      ENDDO
C
      DO I=1,3
        SUM=0.0D+00
        DO J=1,3
          SUM=SUM+R(I,J)*C(6+J)
        ENDDO
        CDUM(I)=SUM
      ENDDO
      DO I=1,3
        C(6+I)=CDUM(I)
      ENDDO
C
      RETURN
      END
C
C*MODULE MDEFP   *DECK INQDOT
      SUBROUTINE INQDOT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DOUBLE PRECISION IRATYZ,IRATZX,IRATXY
C
      PARAMETER (MXFGPT=12000, MXFRG=1050,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (MXATM=2000)
C
      DIMENSION PX(MXFRG),PY(MXFRG),PZ(MXFRG),QQQ(MXFRG)
      DIMENSION PWB(MXFRG),PXB(MXFRG),PYB(MXFRG),PZB(MXFRG)
      DIMENSION IRATYZ(MXDFG),IRATZX(MXDFG),IRATXY(MXDFG)
C
      COMMON /ATMDAT/ VX(MXFRG), VY(MXFRG), VZ(MXFRG),
     *                QW(MXFRG), QX(MXFRG), QY(MXFRG), QZ(MXFRG),
     *                OX(MXFRG), OY(MXFRG), OZ(MXFRG), QW1(MXFRG),
     *                QX1(MXFRG),QY1(MXFRG),QZ1(MXFRG),QW2(MXFRG),
     *                QX2(MXFRG),QY2(MXFRG),QZ2(MXFRG),
     *                VXQM(MXATM), VYQM(MXATM), VZQM(MXATM)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /MDVEL / WX(MXFRG),WY(MXFRG),WZ(MXFRG),TQI(3,MXFRG)
      COMMON /MODDAT/ AMOM(3,MXDFG), TOTMAS(MXDFG), TOTMAI(MXDFG),
     *                DRX(MXFGPT), DRY(MXFGPT), DRZ(MXFGPT)
C
C       *********************************************************
C       *** get initial qdot and qdot2 from quats calculated  ***
C       *** from euler angles.                                ***
C       *********************************************************
C
      CALL TORQMO
C
      DO I = 1,NFRG
         IRATYZ(ISET(I))=(AMOM(2,ISET(I))-
     *                    AMOM(3,ISET(I)))/AMOM(1,ISET(I))
         IRATZX(ISET(I))=(AMOM(3,ISET(I))-
     *                    AMOM(1,ISET(I)))/AMOM(2,ISET(I))
         IRATXY(ISET(I))=(AMOM(1,ISET(I))-
     *                    AMOM(2,ISET(I)))/AMOM(3,ISET(I))
C
C      Generate the first time derivatives of the Q's.
C
         QW1(I)=(-QY(I)*WX(I)-QZ(I)*WY(I)+QX(I)*WZ(I) )*0.5D+00
         QX1(I)=( QZ(I)*WX(I)-QY(I)*WY(I)-QW(I)*WZ(I) )*0.5D+00
         QY1(I)=( QW(I)*WX(I)+QX(I)*WY(I)+QZ(I)*WZ(I) )*0.5D+00
         QZ1(I)=(-QX(I)*WX(I)+QW(I)*WY(I)-QY(I)*WZ(I) )*0.5D+00
C
         QQQ(I)=QW1(I)*QW1(I)+QX1(I)*QX1(I)+
     *          QY1(I)*QY1(I)+QZ1(I)*QZ1(I)
C
         PX(I)=IRATYZ(ISET(I))*WY(I)*WZ(I)
         PY(I)=IRATZX(ISET(I))*WZ(I)*WX(I)
         PZ(I)=IRATXY(ISET(I))*WX(I)*WY(I)
         PWB(I)=0.5D+00*(-QY(I)*PX(I)-QZ(I)*PY(I)+QX(I)*PZ(I))
         PXB(I)=0.5D+00*( QZ(I)*PX(I)-QY(I)*PY(I)-QW(I)*PZ(I))
         PYB(I)=0.5D+00*( QW(I)*PX(I)+QX(I)*PY(I)+QZ(I)*PZ(I))
         PZB(I)=0.5D+00*(-QX(I)*PX(I)+QW(I)*PY(I)-QY(I)*PZ(I))
C
C            Form first part of quat 2nd derivative:
C            Qd2(t+dt) = 1/2 * M * (torq/amom)
C
         QW2(I)=0.5D+00*(-QY(I)*TQI(1,I)-QZ(I)*TQI(2,I)+QX(I)*TQI(3,I))
         QX2(I)=0.5D+00*( QZ(I)*TQI(1,I)-QY(I)*TQI(2,I)-QW(I)*TQI(3,I))
         QY2(I)=0.5D+00*( QW(I)*TQI(1,I)+QX(I)*TQI(2,I)+QZ(I)*TQI(3,I))
         QZ2(I)=0.5D+00*(-QX(I)*TQI(1,I)+QW(I)*TQI(2,I)-QY(I)*TQI(3,I))
C
C        Complete the second time derivatives of the Q's
C
         QW2(I)=QW2(I)-QW(I)*QQQ(I)+PWB(I)
         QX2(I)=QX2(I)-QX(I)*QQQ(I)+PXB(I)
         QY2(I)=QY2(I)-QY(I)*QQQ(I)+PYB(I)
         QZ2(I)=QZ2(I)-QZ(I)*QQQ(I)+PZB(I)
      ENDDO
C
      RETURN
      END
C
C*MODULE MDEFP   *DECK MDDSPQ
      SUBROUTINE MDDSPQ(N,XDEL,YDEL,ZDEL,QWOLD,QXOLD,QYOLD,QZOLD,
     *                  QW,QX,QY,QZ,NMST,NPST,NLJST,
     *                  NDPST,NRST,NDST,NATST,
     *                  NORST,PROVEC,NCTMOST,CTVEC,MXBF,INTMD)
C
C    ****************************************************************
C    ** modification of efdspl to take quaternions for generating  **
C    ** rotation matrix         (JMS)                              **
C    ****************************************************************
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      PARAMETER (MXPT=2000, MXFRG=1050, MXFGPT=12000,
     *           MXDFG=5, MXAO=8192, MXSHEF=1000, MXGEFP=4000,
     *           MXDPPT=MXFRG*MXDFG*12, MXIFRQ=12)
C
      PARAMETER (SQRT3=1.732050808D+00,SQRT5=2.236067978D+00)
      PARAMETER (SQRT7=2.645751311D+00)
      PARAMETER (TWO=2.0D+00,THREE=3.0D+00,FOUR=4.0D+00,SIX=6.0D+00)
      PARAMETER (TWELVE=12.0D+00)
      PARAMETER (CONST=2.0D+00/1.7320508D+00)
C
      CHARACTER*8 FRGNME,POLNAM,REPNAM,DPOLNAM,FRCNME
      CHARACTER*8 DNAME,DPSNAM,LJNAME,ELJNAM
C
      DIMENSION T3(3,3),T3T(3,3)
      DIMENSION T1(3,3), T2(3,3)
      DIMENSION TEMP(3,MXPT),TEMP2(6),TEMP3(3),TEMP4(6,3),TEMP5(6,3)
      DIMENSION DTEMP(3,MXIFRQ*MXPT)
      DIMENSION TPXX(6),TPXY(6),TPYY(6),TPXZ(6),TPYZ(6),TPZZ(6)
      DIMENSION TPXX2(6),TPXY2(6),TPYY2(6),TPXZ2(6),TPYZ2(6),TPZZ2(6)
C
C      dimension prcopb(3,mxfgpt),centpb(3,mxfgpt)
      INTEGER INTMD
      LOGICAL PBCOUT,PBCWRI
      LOGICAL IFRCPNT
C
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NATEF(MXDFG),NUMEF(MXDFG),NTPATM
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /EFPCT / NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CTFOK(MXAO,MXDFG),NCTMO(MXDFG),NTCTMO
      COMMON /EFPFRC/ IFRCPNT,NTFRCPN,NFRCPNT(MXFRG),LSTFPTS(MXFRG),
     *                FRCCRD(3,MXFGPT),FRCNME(MXFGPT),FRCTRQ(6,MXFGPT),
     *                FRCTRQX(6,MXFGPT)
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ*MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /EFPPBC/ XBOX,YBOX,ZBOX,XCUT,YCUT,ZCUT,RCUT
     *                ,SWR1,SWR2,ISWF
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGLJP/ CORDLJ(3,MXPT),ELJCRD(3,MXFGPT),
     *                POTLJ(2,MXPT),ELJPOT(2,MXFGPT),
     *                LJNAME(MXPT),ELJNAM(MXFGPT),
     *                NLJPTS(MXFRG),NLJTTPT,ILJP,NMLJ(2)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /PBCCO/  FRGCPB(3,MXFGPT),EFPPB(3,MXFGPT),
     *                EFDPPB(3,MXFGPT),CREPPB(3,MXFGPT)
      COMMON /PBC/    PBCOUT,PBCWRI
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
      COMMON /POL2  / DCORD(3,MXPT),CDIS(3,MXFGPT),
     *                CLPD(4*MXFGPT),ZLPD(4*MXFGPT),
     *                NLPD(4*MXFGPT),KFD(MXFGPT),KLD(MXFGPT),
     *                DNAME(MXPT),DPSNAM(MXFGPT)
      COMMON /REPPAR/ CREP(3,MXFGPT),CLPR(4*MXFGPT),ZLPR(4*MXFGPT),
     *                NLPR(4*MXFGPT),KFR(MXFGPT),KLR(MXFGPT),
     *                REPNAM(MXFGPT)
      COMMON /EFPMP2/ MP2TYP
C
      DIMENSION PROVEC(MXBF,NTMO),CTVEC(MXBF,NTCTMO)
C
C     ----- rotate EFP data -----
C
C     note to programmers:
C        MDDSPQ is a modified version of EFDSPL, found in statpt.src!
C        any change necessary to the MDDSPQ routine is likely to be
C        needed in the original EFDSPL as well, so please check it too.
C
C     this copy includes quaternion rotations in the calculations.
C
      NPTS = NMPTS(N)
C
      CALL MDROTT(QWOLD,QXOLD,QYOLD,QZOLD,QW,QX,QY,QZ,T3,INTMD)
C
C      if(N.le.6) then
C      write(6,*) 'fragment ',N,'  UPDATE RTN MATRIX'
C      do i=1,3
C       write(6,*) t3(i,1), t3(i,2), t3(i,3)
C      enddo
C      endif
C
C      write(6,*) 't3(1,2,3) = ',t3(1,1),t3(2,1),t3(3,1)
C      CALL EFROTT(THETAX,THETAY,THETAZ,T3)
C
C  COMPUTE TRANSPOSE
C
      CALL TRPOSE(T3,T3T,3,3,0)
C
C   5.  ROTATE AND TRANSLATE STANDARD FRAGMENT TO COINCIDE WITH FRAG N
C
C  FIND FRAGMENT COORDINATES RELATIVE TO POINT OF ROTATION
C
C  find fragment coordinates relative to point of rotation
C  get BODY-FIXED coordinates--> COM = origin
C  Note that efcent and efc are at time t here...
C
      DO 505 I=1,NPTS
        DO 504 J=1,3
          TEMP(J,I) = EFC(J,I+NMST) - EFCENT(J,N)
  504   CONTINUE
  505 CONTINUE
C
C  NOW ROTATE FRAGMENT; rotate based on COM/body-fixed coordinates
C
      CALL MRARBR(T3,3,3,3,TEMP,3,NPTS,EFC(1,NMST+1),3)
C
C CHANGE COORDINATES RELATIVE TO EFCENT BACK TO OLD COORDINATE SYSTEM
C change back to SPACE-FIXED coordinates; note that efcent is at time t
C here
      DO 605 I=1,NPTS
        DO 604 J=1,3
          EFC(J,I+NMST) = EFC(J,I+NMST) + EFCENT(J,N)
  604   CONTINUE
  605 CONTINUE
C
C      write(6,*) 'xdel,y,z = ',xdel,ydel,zdel
C      write(6,*) 'efcent = ',efcent(1,n),efcent(2,n),efcent(3,n)
C  PBC??
      IF(PBCWRI) THEN
        XDELPB = XDEL - XBOX*ANINT(( XDEL + EFCENT(1,N) )/XBOX)
        YDELPB = YDEL - YBOX*ANINT(( YDEL + EFCENT(2,N) )/YBOX)
        ZDELPB = ZDEL - ZBOX*ANINT(( ZDEL + EFCENT(3,N) )/ZBOX)
        IF(XDELPB.NE.XDEL.OR.YDELPB.NE.YDEL.OR.ZDELPB.NE.ZDEL) THEN
C          write(6,*) 'PBC!'
C          write(6,*) 'xdelpb,y,z =',xdelpb,ydelpb,zdelpb
        ENDIF
      ENDIF
C
C  FEED IN INFORMATION INTO FINAL ARRAYS AFTER ROTATION
C
C DO TRANSLATION
C so xdel is dt*v(t+1/2dt) from FROGMOVE--we want to be moving the
C COM (since FROGMOVE is in terms of COM motion)
C new efcent(t+dt) = efcent(t) + dt*v(t+1/2dt)
C new efc(t+dt) = efcent(t+dt) + rotated body-fixed atom positions,
C        AT*efc-bf(t)
C new efc(t+dt) = efcent(t) + dt*v(t+1/2dt) + rotated stuff
C We have added efcent(t) and rotated stuff above,
C so we just need to add in info from FROGMOVE...
C
      IF (PBCWRI) THEN
      DO 449 I = 1,NPTS
        FRGCPB(1,NMST+I) = EFC(1,NMST+I) + XDELPB
        FRGCPB(2,NMST+I) = EFC(2,NMST+I) + YDELPB
        FRGCPB(3,NMST+I) = EFC(3,NMST+I) + ZDELPB
  449 CONTINUE
      ENDIF
C
C     WRITE(6,*)'ROTATED COORDINATES,ME,NSERCH',ME,NSERCH
      DO 550 I = 1,NPTS
        EFC(1,NMST+I) = EFC(1,NMST+I) + XDEL
        EFC(2,NMST+I) = EFC(2,NMST+I) + YDEL
        EFC(3,NMST+I) = EFC(3,NMST+I) + ZDEL
C       WRITE(6,FMT='(3F9.5)') (EFC(J,I+NMST), J=1,3)
  550 CONTINUE
C
C ROTATING DIPOLE MOMENTS
C
      CALL MRARBR(T3,3,3,3,EFDIP(1,NMST+1),3,NPTS,TEMP,3)
      DO 555 I=1,NPTS
      DO 555 J=1,3
      EFDIP(J,NMST+I)=TEMP(J,I)
 555  CONTINUE
C
C ROTATING QUADRUPOLE MOMENTS
C
      TEMP3(1) = 0.0D+00
      TEMP3(2) = 0.0D+00
      TEMP3(3) = 0.0D+00
      DO 600 I=1,NPTS
        TEMP2(1)=EFQAD(1,I+NMST)
        TEMP2(2)=EFQAD(4,I+NMST)
        TEMP2(3)=EFQAD(2,I+NMST)
        TEMP2(4)=EFQAD(5,I+NMST)
        TEMP2(5)=EFQAD(6,I+NMST)
        TEMP2(6)=EFQAD(3,I+NMST)
        CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
        EFQAD(1,NMST+I)=TEMP4(1,1)
        EFQAD(4,NMST+I)=TEMP4(2,1)
        EFQAD(2,NMST+I)=TEMP4(3,1)
        EFQAD(5,NMST+I)=TEMP4(4,1)
        EFQAD(6,NMST+I)=TEMP4(5,1)
        EFQAD(3,NMST+I)=TEMP4(6,1)
  600 CONTINUE
C
C
C ROTATING OCTUPOLE MOMENTS
C
      DO 650 I=1,NPTS
        TEMP2(1) = EFOCT(1,I+NMST)
        TEMP2(2) = EFOCT(4,I+NMST)
        TEMP2(3) = EFOCT(6,I+NMST)
        TEMP2(4) = EFOCT(5,I+NMST)
        TEMP2(5) = EFOCT(10,I+NMST)
        TEMP2(6) = EFOCT(8,I+NMST)
        CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
C
        TEMP2(1)=EFOCT(4,I+NMST)
        TEMP2(2)=EFOCT(6,I+NMST)
        TEMP2(3)=EFOCT(2,I+NMST)
        TEMP2(4)=EFOCT(10,I+NMST)
        TEMP2(5)=EFOCT(7,I+NMST)
        TEMP2(6)=EFOCT(9,I+NMST)
        CALL TFTRI(TEMP4(1,2),TEMP2,T3T,TEMP3,3,3,3)
C
        TEMP2(1)=EFOCT(5,I+NMST)
        TEMP2(2)=EFOCT(10,I+NMST)
        TEMP2(3)=EFOCT(7,I+NMST)
        TEMP2(4)=EFOCT(8,I+NMST)
        TEMP2(5)=EFOCT(9,I+NMST)
        TEMP2(6)=EFOCT(3,I+NMST)
        CALL TFTRI(TEMP4(1,3),TEMP2,T3T,TEMP3,3,3,3)
C
        CALL MRARBR(TEMP4,6,6,3,T3T,3,3,TEMP5,6)
        EFOCT(1,NMST+I)=TEMP5(1,1)
        EFOCT(2,NMST+I)=TEMP5(3,2)
        EFOCT(3,NMST+I)=TEMP5(6,3)
        EFOCT(4,NMST+I)=TEMP5(2,1)
        EFOCT(5,NMST+I)=TEMP5(4,1)
        EFOCT(6,NMST+I)=TEMP5(3,1)
        EFOCT(7,NMST+I)=TEMP5(5,2)
        EFOCT(8,NMST+I)=TEMP5(6,1)
        EFOCT(9,NMST+I)=TEMP5(6,2)
        EFOCT(10,NMST+I)=TEMP5(5,1)
  650 CONTINUE
C
C  ROTATING FORCE POINTS IF ANY
       IF (IFRCPNT) THEN
          ISTART=LSTFPTS(N)
          IFPTS = NFRCPNT(N)
          DO I=1,IFPTS
            DO J=1,3
              TEMP(J,I) = FRCCRD(J,I+ISTART-1) - EFCENT(J,N)
            END DO
          END DO
C
          CALL MRARBR(T3,3,3,3,TEMP,3,IFPTS,FRCCRD(1,ISTART),3)
C
          DO I=1,IFPTS
             DO J=1,3
                FRCCRD(J,I+ISTART-1)=FRCCRD(J,I+ISTART-1) + EFCENT(J,N)
             END DO
          END DO
C
          DO I = 1,IFPTS
            FRCCRD(1,I+ISTART-1) = FRCCRD(1,I+ISTART-1) + XDEL
            FRCCRD(2,I+ISTART-1) = FRCCRD(2,I+ISTART-1) + YDEL
            FRCCRD(3,I+ISTART-1) = FRCCRD(3,I+ISTART-1) + ZDEL
          END DO
       END IF
C
C  ROTATING POLARIZABILITY-COORDINATES AND TENSOR
C
      IPPTS=NPPTS(N)
      DO 670 I=1,IPPTS
        DO 660 J=1,3
          TEMP(J,I) = EFP(J,I+NPST) - EFCENT(J,N)
  660   CONTINUE
  670 CONTINUE
C
      CALL MRARBR(T3,3,3,3,TEMP,3,IPPTS,EFP(1,NPST+1),3)
C
      DO 770 I=1,IPPTS
        DO 760 J=1,3
          EFP(J,I+NPST) = EFP(J,I+NPST) + EFCENT(J,N)
  760   CONTINUE
  770 CONTINUE
C
      IF(PBCWRI) THEN
      DO 679 I = 1,IPPTS
        EFPPB(1,I+NPST) = EFP(1,I+NPST) + XDELPB
        EFPPB(2,I+NPST) = EFP(2,I+NPST) + YDELPB
        EFPPB(3,I+NPST) = EFP(3,I+NPST) + ZDELPB
  679 CONTINUE
      ENDIF
C
      DO 680 I = 1,IPPTS
        EFP(1,I+NPST) = EFP(1,I+NPST) + XDEL
        EFP(2,I+NPST) = EFP(2,I+NPST) + YDEL
        EFP(3,I+NPST) = EFP(3,I+NPST) + ZDEL
  680 CONTINUE
C
      CALL VCLR(TEMP3,1,3)
      DO 690 I=1,IPPTS
        T1(1,1) = EFPOL(1,I+NPST)
        T1(1,2) = EFPOL(4,I+NPST)
        T1(1,3) = EFPOL(5,I+NPST)
        T1(2,1) = EFPOL(7,I+NPST)
        T1(2,2) = EFPOL(2,I+NPST)
        T1(2,3) = EFPOL(6,I+NPST)
        T1(3,1) = EFPOL(8,I+NPST)
        T1(3,2) = EFPOL(9,I+NPST)
        T1(3,3) = EFPOL(3,I+NPST)
        CALL MRARBR(T3,3,3,3,T1,3,3,T2,3)
        CALL VCLR(T1,1,9)
        CALL MRARBR(T2,3,3,3,T3T,3,3,T1,3)
        EFPOL(1,NPST+I) = T1(1,1)
        EFPOL(4,NPST+I) = T1(1,2)
        EFPOL(5,NPST+I) = T1(1,3)
        EFPOL(7,NPST+I) = T1(2,1)
        EFPOL(2,NPST+I) = T1(2,2)
        EFPOL(6,NPST+I) = T1(2,3)
        EFPOL(8,NPST+I) = T1(3,1)
        EFPOL(9,NPST+I) = T1(3,2)
        EFPOL(3,NPST+I) = T1(3,3)
  690 CONTINUE
C
C  ROTATING LENNARD-JONES POTENTIAL
C
      ILJPTS = NLJPTS(N)
      DO I=1,ILJPTS
         DO J=1,3
            TEMP(J,I) = ELJCRD(J,I+NLJST) - EFCENT(J,N)
         ENDDO
      ENDDO
      CALL MRARBR(T3,3,3,3,TEMP,3,ILJPTS,ELJCRD(1,NLJST+1),3)
      DO I = 1,ILJPTS
         ELJCRD(1,I+NLJST)=ELJCRD(1,I+NLJST)+EFCENT(1,N)+XDEL
         ELJCRD(2,I+NLJST)=ELJCRD(2,I+NLJST)+EFCENT(2,N)+YDEL
         ELJCRD(3,I+NLJST)=ELJCRD(3,I+NLJST)+EFCENT(3,N)+ZDEL
      ENDDO
C
C IVANA ADDING DYNAMIC POLARIZABILITY
C  ROTATING DYNAMIC POLARIZABILITY-COORDINATES AND TENSOR
C
      IDPPTS=NDPPTS(N)
      DO 671 I=1,IDPPTS
        DO 661 J=1,3
          DTEMP(J,I) = EFDP(J,I+NDPST) - EFCENT(J,N)
  661   CONTINUE
  671 CONTINUE
C
C         bug, JMM/MWS changed next line spelled as uninitialized -DT3-
C         since September 2005 to correct rotation -T3- in October 2008
      CALL MRARBR(T3,3,3,3,DTEMP,3,IDPPTS,EFDP(1,NDPST+1),3)
C
      DO 771 I=1,IDPPTS
        DO 761 J=1,3
          EFDP(J,I+NDPST) = EFDP(J,I+NDPST) + EFCENT(J,N)
  761   CONTINUE
  771 CONTINUE
C
      IF(PBCWRI) THEN
      DO 678 I = 1,IDPPTS
        EFDPPB(1,I+NDPST) = EFDP(1,I+NDPST) + XDELPB
        EFDPPB(2,I+NDPST) = EFDP(2,I+NDPST) + YDELPB
        EFDPPB(3,I+NDPST) = EFDP(3,I+NDPST) + ZDELPB
  678 CONTINUE
      ENDIF
C
      DO 681 I = 1,IDPPTS
        EFDP(1,I+NDPST) = EFDP(1,I+NDPST) + XDEL
        EFDP(2,I+NDPST) = EFDP(2,I+NDPST) + YDEL
        EFDP(3,I+NDPST) = EFDP(3,I+NDPST) + ZDEL
  681 CONTINUE
C
      CALL VCLR(TEMP3,1,3)
C
      DO 692 I=1,IDPPTS
        T1(1,1) = EFDPOL(1,I+NDPST)
        T1(1,2) = EFDPOL(4,I+NDPST)
        T1(1,3) = EFDPOL(5,I+NDPST)
        T1(2,1) = EFDPOL(7,I+NDPST)
        T1(2,2) = EFDPOL(2,I+NDPST)
        T1(2,3) = EFDPOL(6,I+NDPST)
        T1(3,1) = EFDPOL(8,I+NDPST)
        T1(3,2) = EFDPOL(9,I+NDPST)
        T1(3,3) = EFDPOL(3,I+NDPST)
        CALL MRARBR(T3,3,3,3,T1,3,3,T2,3)
        CALL MRARBR(T2,3,3,3,T3T,3,3,T1,3)
        EFDPOL(1,NDPST+I) = T1(1,1)
        EFDPOL(4,NDPST+I) = T1(1,2)
        EFDPOL(5,NDPST+I) = T1(1,3)
        EFDPOL(7,NDPST+I) = T1(2,1)
        EFDPOL(2,NDPST+I) = T1(2,2)
        EFDPOL(6,NDPST+I) = T1(2,3)
        EFDPOL(8,NDPST+I) = T1(3,1)
        EFDPOL(9,NDPST+I) = T1(3,2)
        EFDPOL(3,NDPST+I) = T1(3,3)
  692 CONTINUE
C
C
      IRPTS = NRPTS(N)
      DO 720 I=1,IRPTS
        DO 710 J=1,3
          TEMP(J,I) = CREP(J,I+NRST) - EFCENT(J,N)
  710   CONTINUE
  720 CONTINUE
C
      CALL MRARBR(T3,3,3,3,TEMP,3,IRPTS,CREP(1,NRST+1),3)
C
      DO 820 I=1,IRPTS
        DO 810 J=1,3
          CREP(J,I+NRST) = CREP(J,I+NRST) + EFCENT(J,N)
  810   CONTINUE
  820 CONTINUE
C
      IF(PBCWRI) THEN
      DO 739 I = 1,IRPTS
        CREPPB(1,I+NRST) = CREP(1,I+NRST) + XDELPB
        CREPPB(2,I+NRST) = CREP(2,I+NRST) + YDELPB
        CREPPB(3,I+NRST) = CREP(3,I+NRST) + ZDELPB
  739 CONTINUE
      ENDIF
C
      DO 740 I = 1,IRPTS
        CREP(1,I+NRST) = CREP(1,I+NRST) + XDEL
        CREP(2,I+NRST) = CREP(2,I+NRST) + YDEL
        CREP(3,I+NRST) = CREP(3,I+NRST) + ZDEL
C        WRITE(6,FMT='(3F9.5)') (CREP(J,I+NRST), J=1,3)
  740 CONTINUE
C
C
      IF(MP2TYP.EQ.1) THEN
        IDPTS = NDPTS(N)
        DO 830 I=1,IDPTS
          DO 825 J=1,3
            TEMP(J,I) = CDIS(J,I+NDST) - EFCENT(J,N)
  825     CONTINUE
  830   CONTINUE
C
        CALL MRARBR(T3,3,3,3,TEMP,3,IDPTS,CDIS(1,NDST+1),3)
C
        DO 840 I=1,IDPTS
          DO 835 J=1,3
            CDIS(J,I+NDST) = CDIS(J,I+NDST) + EFCENT(J,N)
  835     CONTINUE
  840   CONTINUE
C
        DO 845 I = 1,IDPTS
          CDIS(1,I+NDST) = CDIS(1,I+NDST) + XDEL
          CDIS(2,I+NDST) = CDIS(2,I+NDST) + YDEL
          CDIS(3,I+NDST) = CDIS(3,I+NDST) + ZDEL
C          WRITE(6,FMT='(3F9.5)') (CDIS(J,I+NDST), J=1,3)
  845   CONTINUE
C
      END IF
C
C
C  PAULI REPULSION INFORMATION
C
      INAT = NATEF(ISET(N))
      DO I=1,INAT
         DO J=1,3
            TEMP(J,I) = PRCORD(J,I+NATST) - EFCENT(J,N)
         END DO
      END DO
      CALL MRARBR(T3,3,3,3,TEMP,3,INAT,PRCORD(1,NATST+1),3)
C
C     if(pbcwri) then
C      do i=1,inat
C         prcopb(1,i+natst) = prcord(1,i+natst) + xdelpb + efcent(1,n)
C         prcopb(2,i+natst) = prcord(2,i+natst) + ydelpb + efcent(2,n)
C         prcopb(3,i+natst) = prcord(3,i+natst) + zdelpb + efcent(3,n)
C      end do
C      endif
C
      DO I=1,INAT
         PRCORD(1,I+NATST) = PRCORD(1,I+NATST) + XDEL + EFCENT(1,N)
         PRCORD(2,I+NATST) = PRCORD(2,I+NATST) + YDEL + EFCENT(2,N)
         PRCORD(3,I+NATST) = PRCORD(3,I+NATST) + ZDEL + EFCENT(3,N)
      END DO
C
      IMO = NORB(N)
      DO NSHL = 1,NSHELL(ISET(N))
         ITYP = KMAX(NSHL,ISET(N)) - KMIN(NSHL,ISET(N)) + 1
         LOC = KLOC(NSHL,ISET(N))
C
C
C  S: DO NOTHING
C
C  P:
C
         IF(ITYP.EQ.3) THEN
            DO I = 1,IMO
               TEMP3(1) = PROVEC(LOC,NORST+I)
               TEMP3(2) = PROVEC(LOC+1,NORST+I)
               TEMP3(3) = PROVEC(LOC+2,NORST+I)
               CALL MRARBR(T3,3,3,3,TEMP3,3,1,TEMP4(1,1),3)
               PROVEC(LOC,NORST+I) = TEMP4(1,1)
               PROVEC(LOC+1,NORST+I) = TEMP4(2,1)
               PROVEC(LOC+2,NORST+I) = TEMP4(3,1)
            END DO
         END IF
C  L:
         IF(ITYP.EQ.4) THEN
            DO I = 1,IMO
               TEMP3(1) = PROVEC(LOC+1,NORST+I)
               TEMP3(2) = PROVEC(LOC+2,NORST+I)
               TEMP3(3) = PROVEC(LOC+3,NORST+I)
               CALL MRARBR(T3,3,3,3,TEMP3,3,1,TEMP4(1,1),3)
               PROVEC(LOC+1,NORST+I) = TEMP4(1,1)
               PROVEC(LOC+2,NORST+I) = TEMP4(2,1)
               PROVEC(LOC+3,NORST+I) = TEMP4(3,1)
            END DO
         END IF
C  D:
C              THE NORMALIZATION FOR XY,XZ,YZ GAUSSIANS IS SQRT(3)
C              LARGER THAN XX,YY,ZZ. FACTOR OF TWO ALLOWS SUMMATION
C              OVER ALL INDICES RATHER THAN I,J<=I
C
         IF(ITYP.EQ.6) THEN
            DO I = 1,IMO
               TEMP2(1) = PROVEC(LOC,NORST+I)
               TEMP2(2) = PROVEC(LOC+3,NORST+I)/CONST
               TEMP2(3) = PROVEC(LOC+1,NORST+I)
               TEMP2(4) = PROVEC(LOC+4,NORST+I)/CONST
               TEMP2(5) = PROVEC(LOC+5,NORST+I)/CONST
               TEMP2(6) = PROVEC(LOC+2,NORST+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               PROVEC(LOC,NORST+I) = TEMP4(1,1)
               PROVEC(LOC+3,NORST+I) = TEMP4(2,1)*CONST
               PROVEC(LOC+1,NORST+I) = TEMP4(3,1)
               PROVEC(LOC+4,NORST+I) = TEMP4(4,1)*CONST
               PROVEC(LOC+5,NORST+I) = TEMP4(5,1)*CONST
               PROVEC(LOC+2,NORST+I) = TEMP4(6,1)
            END DO
         END IF
C  F:
         IF(ITYP.EQ.10) THEN
            DO I = 1,IMO
               PROVEC(LOC+3,NORST+I) = PROVEC(LOC+3,NORST+I)*
     *                                 SQRT5/THREE
               PROVEC(LOC+4,NORST+I) = PROVEC(LOC+4,NORST+I)*
     *                                 SQRT5/THREE
               PROVEC(LOC+5,NORST+I) = PROVEC(LOC+5,NORST+I)*
     *                                 SQRT5/THREE
               PROVEC(LOC+6,NORST+I) = PROVEC(LOC+6,NORST+I)*
     *                                 SQRT5/THREE
               PROVEC(LOC+7,NORST+I) = PROVEC(LOC+7,NORST+I)*
     *                                 SQRT5/THREE
               PROVEC(LOC+8,NORST+I) = PROVEC(LOC+8,NORST+I)*
     *                                 SQRT5/THREE
               PROVEC(LOC+9,NORST+I) = PROVEC(LOC+9,NORST+I)*
     *                                 SQRT5/THREE
               PROVEC(LOC+9,NORST+I) = PROVEC(LOC+9,NORST+I)*
     *                                 SQRT3/TWO
C
               TEMP2(1) = PROVEC(LOC  ,NORST+I)
               TEMP2(2) = PROVEC(LOC+3,NORST+I)
               TEMP2(3) = PROVEC(LOC+5,NORST+I)
               TEMP2(4) = PROVEC(LOC+4,NORST+I)
               TEMP2(5) = PROVEC(LOC+9,NORST+I)
               TEMP2(6) = PROVEC(LOC+7,NORST+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
C
               TEMP2(1) = PROVEC(LOC+3,NORST+I)
               TEMP2(2) = PROVEC(LOC+5,NORST+I)
               TEMP2(3) = PROVEC(LOC+1,NORST+I)
               TEMP2(4) = PROVEC(LOC+9,NORST+I)
               TEMP2(5) = PROVEC(LOC+6,NORST+I)
               TEMP2(6) = PROVEC(LOC+8,NORST+I)
               CALL TFTRI(TEMP4(1,2),TEMP2,T3T,TEMP3,3,3,3)
C
               TEMP2(1) = PROVEC(LOC+4,NORST+I)
               TEMP2(2) = PROVEC(LOC+9,NORST+I)
               TEMP2(3) = PROVEC(LOC+6,NORST+I)
               TEMP2(4) = PROVEC(LOC+7,NORST+I)
               TEMP2(5) = PROVEC(LOC+8,NORST+I)
               TEMP2(6) = PROVEC(LOC+2,NORST+I)
               CALL TFTRI(TEMP4(1,3),TEMP2,T3T,TEMP3,3,3,3)
C
               CALL MRARBR(TEMP4,6,6,3,T3T,3,3,TEMP5,6)
C
               PROVEC(LOC  ,NORST+I) = TEMP5(1,1)
               PROVEC(LOC+1,NORST+I) = TEMP5(3,2)
               PROVEC(LOC+2,NORST+I) = TEMP5(6,3)
               PROVEC(LOC+3,NORST+I) = TEMP5(2,1)/SQRT5*THREE
               PROVEC(LOC+4,NORST+I) = TEMP5(4,1)/SQRT5*THREE
               PROVEC(LOC+5,NORST+I) = TEMP5(3,1)/SQRT5*THREE
               PROVEC(LOC+6,NORST+I) = TEMP5(5,2)/SQRT5*THREE
               PROVEC(LOC+7,NORST+I) = TEMP5(6,1)/SQRT5*THREE
               PROVEC(LOC+8,NORST+I) = TEMP5(6,2)/SQRT5*THREE
               PROVEC(LOC+9,NORST+I) = TEMP5(5,1)/SQRT5*THREE/
     *                                 SQRT3*TWO
C
            END DO
         END IF
C  G:
C
         IF(ITYP.EQ.15) THEN
            DO I = 1,IMO
               PROVEC(LOC+ 3,NORST+I) = PROVEC(LOC+ 3,NORST+I)*
     *                                  SQRT7/FOUR
               PROVEC(LOC+ 4,NORST+I) = PROVEC(LOC+ 4,NORST+I)*
     *                                  SQRT7/FOUR
               PROVEC(LOC+ 5,NORST+I) = PROVEC(LOC+ 5,NORST+I)*
     *                                  SQRT7/FOUR
               PROVEC(LOC+ 6,NORST+I) = PROVEC(LOC+ 6,NORST+I)*
     *                                  SQRT7/FOUR
               PROVEC(LOC+ 7,NORST+I) = PROVEC(LOC+ 7,NORST+I)*
     *                                  SQRT7/FOUR
               PROVEC(LOC+ 8,NORST+I) = PROVEC(LOC+ 8,NORST+I)*
     *                                  SQRT7/FOUR
               PROVEC(LOC+ 9,NORST+I) = PROVEC(LOC+ 9,NORST+I)*SQRT7*
     *                                  SQRT5/SQRT3/SIX
               PROVEC(LOC+10,NORST+I) = PROVEC(LOC+10,NORST+I)*SQRT7*
     *                                  SQRT5/SQRT3/SIX
               PROVEC(LOC+11,NORST+I) = PROVEC(LOC+11,NORST+I)*SQRT7*
     *                                  SQRT5/SQRT3/SIX
               PROVEC(LOC+12,NORST+I) = PROVEC(LOC+12,NORST+I)*SQRT7*
     *                                  SQRT5/TWELVE
               PROVEC(LOC+13,NORST+I) = PROVEC(LOC+13,NORST+I)*SQRT7*
     *                                  SQRT5/TWELVE
               PROVEC(LOC+14,NORST+I) = PROVEC(LOC+14,NORST+I)*SQRT7*
     *                                  SQRT5/TWELVE
C
C              PERFORM THE FIRST AND SECOND ROTATION
C
               TEMP2(1) = PROVEC(LOC   ,NORST+I)
               TEMP2(2) = PROVEC(LOC+ 3,NORST+I)
               TEMP2(3) = PROVEC(LOC+ 9,NORST+I)
               TEMP2(4) = PROVEC(LOC+ 4,NORST+I)
               TEMP2(5) = PROVEC(LOC+12,NORST+I)
               TEMP2(6) = PROVEC(LOC+10,NORST+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXX(1) = TEMP4(1,1)
               TPXX(2) = TEMP4(2,1)
               TPXX(3) = TEMP4(3,1)
               TPXX(4) = TEMP4(4,1)
               TPXX(5) = TEMP4(5,1)
               TPXX(6) = TEMP4(6,1)
C
               TEMP2(1) = PROVEC(LOC+ 3,NORST+I)
               TEMP2(2) = PROVEC(LOC+ 9,NORST+I)
               TEMP2(3) = PROVEC(LOC+ 5,NORST+I)
               TEMP2(4) = PROVEC(LOC+12,NORST+I)
               TEMP2(5) = PROVEC(LOC+13,NORST+I)
               TEMP2(6) = PROVEC(LOC+14,NORST+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXY(1) = TEMP4(1,1)
               TPXY(2) = TEMP4(2,1)
               TPXY(3) = TEMP4(3,1)
               TPXY(4) = TEMP4(4,1)
               TPXY(5) = TEMP4(5,1)
               TPXY(6) = TEMP4(6,1)
C
               TEMP2(1) = PROVEC(LOC+ 9,NORST+I)
               TEMP2(2) = PROVEC(LOC+ 5,NORST+I)
               TEMP2(3) = PROVEC(LOC+ 1,NORST+I)
               TEMP2(4) = PROVEC(LOC+13,NORST+I)
               TEMP2(5) = PROVEC(LOC+ 6,NORST+I)
               TEMP2(6) = PROVEC(LOC+11,NORST+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYY(1) = TEMP4(1,1)
               TPYY(2) = TEMP4(2,1)
               TPYY(3) = TEMP4(3,1)
               TPYY(4) = TEMP4(4,1)
               TPYY(5) = TEMP4(5,1)
               TPYY(6) = TEMP4(6,1)
C
               TEMP2(1) = PROVEC(LOC+ 4,NORST+I)
               TEMP2(2) = PROVEC(LOC+12,NORST+I)
               TEMP2(3) = PROVEC(LOC+13,NORST+I)
               TEMP2(4) = PROVEC(LOC+10,NORST+I)
               TEMP2(5) = PROVEC(LOC+14,NORST+I)
               TEMP2(6) = PROVEC(LOC+ 7,NORST+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXZ(1) = TEMP4(1,1)
               TPXZ(2) = TEMP4(2,1)
               TPXZ(3) = TEMP4(3,1)
               TPXZ(4) = TEMP4(4,1)
               TPXZ(5) = TEMP4(5,1)
               TPXZ(6) = TEMP4(6,1)
C
               TEMP2(1) = PROVEC(LOC+12,NORST+I)
               TEMP2(2) = PROVEC(LOC+13,NORST+I)
               TEMP2(3) = PROVEC(LOC+ 6,NORST+I)
               TEMP2(4) = PROVEC(LOC+14,NORST+I)
               TEMP2(5) = PROVEC(LOC+11,NORST+I)
               TEMP2(6) = PROVEC(LOC+ 8,NORST+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYZ(1) = TEMP4(1,1)
               TPYZ(2) = TEMP4(2,1)
               TPYZ(3) = TEMP4(3,1)
               TPYZ(4) = TEMP4(4,1)
               TPYZ(5) = TEMP4(5,1)
               TPYZ(6) = TEMP4(6,1)
C
               TEMP2(1) = PROVEC(LOC+10,NORST+I)
               TEMP2(2) = PROVEC(LOC+14,NORST+I)
               TEMP2(3) = PROVEC(LOC+11,NORST+I)
               TEMP2(4) = PROVEC(LOC+ 7,NORST+I)
               TEMP2(5) = PROVEC(LOC+ 8,NORST+I)
               TEMP2(6) = PROVEC(LOC+ 2,NORST+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPZZ(1) = TEMP4(1,1)
               TPZZ(2) = TEMP4(2,1)
               TPZZ(3) = TEMP4(3,1)
               TPZZ(4) = TEMP4(4,1)
               TPZZ(5) = TEMP4(5,1)
               TPZZ(6) = TEMP4(6,1)
C
C              PERFORM THE THIRD AND FOURTH ROTATION
C              PERFORM THE THIRD AND FOURTH ROTATION
C
               TEMP2(1) = TPXX(1)
               TEMP2(2) = TPXY(1)
               TEMP2(3) = TPYY(1)
               TEMP2(4) = TPXZ(1)
               TEMP2(5) = TPYZ(1)
               TEMP2(6) = TPZZ(1)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXX2(1) = TEMP4(1,1)
               TPXX2(2) = TEMP4(2,1)
               TPXX2(3) = TEMP4(3,1)
               TPXX2(4) = TEMP4(4,1)
               TPXX2(5) = TEMP4(5,1)
               TPXX2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(2)
               TEMP2(2) = TPXY(2)
               TEMP2(3) = TPYY(2)
               TEMP2(4) = TPXZ(2)
               TEMP2(5) = TPYZ(2)
               TEMP2(6) = TPZZ(2)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXY2(1) = TEMP4(1,1)
               TPXY2(2) = TEMP4(2,1)
               TPXY2(3) = TEMP4(3,1)
               TPXY2(4) = TEMP4(4,1)
               TPXY2(5) = TEMP4(5,1)
               TPXY2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(3)
               TEMP2(2) = TPXY(3)
               TEMP2(3) = TPYY(3)
               TEMP2(4) = TPXZ(3)
               TEMP2(5) = TPYZ(3)
               TEMP2(6) = TPZZ(3)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYY2(1) = TEMP4(1,1)
               TPYY2(2) = TEMP4(2,1)
               TPYY2(3) = TEMP4(3,1)
               TPYY2(4) = TEMP4(4,1)
               TPYY2(5) = TEMP4(5,1)
               TPYY2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(4)
               TEMP2(2) = TPXY(4)
               TEMP2(3) = TPYY(4)
               TEMP2(4) = TPXZ(4)
               TEMP2(5) = TPYZ(4)
               TEMP2(6) = TPZZ(4)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXZ2(1) = TEMP4(1,1)
               TPXZ2(2) = TEMP4(2,1)
               TPXZ2(3) = TEMP4(3,1)
               TPXZ2(4) = TEMP4(4,1)
               TPXZ2(5) = TEMP4(5,1)
               TPXZ2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(5)
               TEMP2(2) = TPXY(5)
               TEMP2(3) = TPYY(5)
               TEMP2(4) = TPXZ(5)
               TEMP2(5) = TPYZ(5)
               TEMP2(6) = TPZZ(5)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYZ2(1) = TEMP4(1,1)
               TPYZ2(2) = TEMP4(2,1)
               TPYZ2(3) = TEMP4(3,1)
               TPYZ2(4) = TEMP4(4,1)
               TPYZ2(5) = TEMP4(5,1)
               TPYZ2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(6)
               TEMP2(2) = TPXY(6)
               TEMP2(3) = TPYY(6)
               TEMP2(4) = TPXZ(6)
               TEMP2(5) = TPYZ(6)
               TEMP2(6) = TPZZ(6)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPZZ2(1) = TEMP4(1,1)
               TPZZ2(2) = TEMP4(2,1)
               TPZZ2(3) = TEMP4(3,1)
               TPZZ2(4) = TEMP4(4,1)
               TPZZ2(5) = TEMP4(5,1)
               TPZZ2(6) = TEMP4(6,1)
C
               PROVEC(LOC   ,NORST+I) = TPXX2(1)
               PROVEC(LOC+ 1,NORST+I) = TPYY2(3)
               PROVEC(LOC+ 2,NORST+I) = TPZZ2(6)
               PROVEC(LOC+ 3,NORST+I) = TPXY2(1)/SQRT7*FOUR
               PROVEC(LOC+ 4,NORST+I) = TPXZ2(1)/SQRT7*FOUR
               PROVEC(LOC+ 5,NORST+I) = TPYY2(2)/SQRT7*FOUR
               PROVEC(LOC+ 6,NORST+I) = TPYZ2(3)/SQRT7*FOUR
               PROVEC(LOC+ 7,NORST+I) = TPXZ2(6)/SQRT7*FOUR
               PROVEC(LOC+ 8,NORST+I) = TPYZ2(6)/SQRT7*FOUR
               PROVEC(LOC+ 9,NORST+I) = TPYY2(1)/SQRT7/SQRT5*
     *                                  SQRT3*SIX
               PROVEC(LOC+10,NORST+I) = TPZZ2(1)/SQRT7/SQRT5*
     *                                  SQRT3*SIX
               PROVEC(LOC+11,NORST+I) = TPZZ2(3)/SQRT7/SQRT5*
     *                                  SQRT3*SIX
               PROVEC(LOC+12,NORST+I) = TPYZ2(1)/SQRT7/SQRT5*
     *                                  TWELVE
               PROVEC(LOC+13,NORST+I) = TPYZ2(2)/SQRT7/SQRT5*
     *                                  TWELVE
               PROVEC(LOC+14,NORST+I) = TPZZ2(2)/SQRT7/SQRT5*
     *                                  TWELVE
            END DO
         END IF
      END DO
C
C      if(pbcwri) then
C      do i=1,imo
C         centpb(1,i+norst) = centcd(1,i+norst) + xdelpb + efcent(1,n)
C         centpb(2,i+norst) = centcd(2,i+norst) + ydelpb + efcent(2,n)
C         centpb(3,i+norst) = centcd(3,i+norst) + zdelpb + efcent(3,n)
C      end do
C      endif
C
      DO I=1,IMO
         DO J=1,3
            TEMP(J,I) = CENTCD(J,I+NORST) - EFCENT(J,N)
         END DO
      END DO
      CALL MRARBR(T3,3,3,3,TEMP,3,IMO,CENTCD(1,NORST+1),3)
      DO I=1,IMO
         CENTCD(1,I+NORST) = CENTCD(1,I+NORST) + XDEL + EFCENT(1,N)
         CENTCD(2,I+NORST) = CENTCD(2,I+NORST) + YDEL + EFCENT(2,N)
         CENTCD(3,I+NORST) = CENTCD(3,I+NORST) + ZDEL + EFCENT(3,N)
      END DO
C  ROTATE CANONICAL VEC
C
C      IAO = NPBF(N)
      ICTMO = NCTMO(ISET(N))
      DO NSHL = 1,NSHELL(ISET(N))
         ITYP = KMAX(NSHL,ISET(N)) - KMIN(NSHL,ISET(N)) + 1
         LOC = KLOC(NSHL,ISET(N))
C
C  S: DO NOTHING
C
C  P:
C
         IF(ITYP.EQ.3) THEN
            DO I = 1,ICTMO
               TEMP3(1) = CTVEC(LOC,NCTMOST+I)
               TEMP3(2) = CTVEC(LOC+1,NCTMOST+I)
               TEMP3(3) = CTVEC(LOC+2,NCTMOST+I)
               CALL MRARBR(T3,3,3,3,TEMP3,3,1,TEMP4(1,1),3)
               CTVEC(LOC,NCTMOST+I) = TEMP4(1,1)
               CTVEC(LOC+1,NCTMOST+I) = TEMP4(2,1)
               CTVEC(LOC+2,NCTMOST+I) = TEMP4(3,1)
            END DO
         END IF
C  L:
         IF(ITYP.EQ.4) THEN
            DO I = 1,ICTMO
               TEMP3(1) = CTVEC(LOC+1,NCTMOST+I)
               TEMP3(2) = CTVEC(LOC+2,NCTMOST+I)
               TEMP3(3) = CTVEC(LOC+3,NCTMOST+I)
               CALL MRARBR(T3,3,3,3,TEMP3,3,1,TEMP4(1,1),3)
               CTVEC(LOC+1,NCTMOST+I) = TEMP4(1,1)
               CTVEC(LOC+2,NCTMOST+I) = TEMP4(2,1)
               CTVEC(LOC+3,NCTMOST+I) = TEMP4(3,1)
            END DO
         END IF
C  D:
C              THE NORMALIZATION FOR XY,XZ,YZ GAUSSIANS IS SQRT(3)
C              LARGER THAN XX,YY,ZZ. FACTOR OF TWO ALLOWS SUMMATION
C              OVER ALL INDICES RATHER THAN I,J<=I
C
         IF(ITYP.EQ.6) THEN
            DO I = 1,ICTMO
               TEMP2(1) = CTVEC(LOC,NCTMOST+I)
               TEMP2(2) = CTVEC(LOC+3,NCTMOST+I)/CONST
               TEMP2(3) = CTVEC(LOC+1,NCTMOST+I)
               TEMP2(4) = CTVEC(LOC+4,NCTMOST+I)/CONST
               TEMP2(5) = CTVEC(LOC+5,NCTMOST+I)/CONST
               TEMP2(6) = CTVEC(LOC+2,NCTMOST+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               CTVEC(LOC,NCTMOST+I) = TEMP4(1,1)
               CTVEC(LOC+3,NCTMOST+I) = TEMP4(2,1)*CONST
               CTVEC(LOC+1,NCTMOST+I) = TEMP4(3,1)
               CTVEC(LOC+4,NCTMOST+I) = TEMP4(4,1)*CONST
               CTVEC(LOC+5,NCTMOST+I) = TEMP4(5,1)*CONST
               CTVEC(LOC+2,NCTMOST+I) = TEMP4(6,1)
            END DO
         END IF
C  F:
         IF(ITYP.EQ.10) THEN
            DO I = 1,ICTMO
               CTVEC(LOC+3,NCTMOST+I) = CTVEC(LOC+3,NCTMOST+I)*
     *                                 SQRT5/THREE
               CTVEC(LOC+4,NCTMOST+I) = CTVEC(LOC+4,NCTMOST+I)*
     *                                 SQRT5/THREE
               CTVEC(LOC+5,NCTMOST+I) = CTVEC(LOC+5,NCTMOST+I)*
     *                                 SQRT5/THREE
               CTVEC(LOC+6,NCTMOST+I) = CTVEC(LOC+6,NCTMOST+I)*
     *                                 SQRT5/THREE
               CTVEC(LOC+7,NCTMOST+I) = CTVEC(LOC+7,NCTMOST+I)*
     *                                 SQRT5/THREE
               CTVEC(LOC+8,NCTMOST+I) = CTVEC(LOC+8,NCTMOST+I)*
     *                                 SQRT5/THREE
               CTVEC(LOC+9,NCTMOST+I) = CTVEC(LOC+9,NCTMOST+I)*
     *                                 SQRT5/THREE
               CTVEC(LOC+9,NCTMOST+I) = CTVEC(LOC+9,NCTMOST+I)*
     *                                 SQRT3/TWO
C
               TEMP2(1) = CTVEC(LOC  ,NCTMOST+I)
               TEMP2(2) = CTVEC(LOC+3,NCTMOST+I)
               TEMP2(3) = CTVEC(LOC+5,NCTMOST+I)
               TEMP2(4) = CTVEC(LOC+4,NCTMOST+I)
               TEMP2(5) = CTVEC(LOC+9,NCTMOST+I)
               TEMP2(6) = CTVEC(LOC+7,NCTMOST+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
C
               TEMP2(1) = CTVEC(LOC+3,NCTMOST+I)
               TEMP2(2) = CTVEC(LOC+5,NCTMOST+I)
               TEMP2(3) = CTVEC(LOC+1,NCTMOST+I)
               TEMP2(4) = CTVEC(LOC+9,NCTMOST+I)
               TEMP2(5) = CTVEC(LOC+6,NCTMOST+I)
               TEMP2(6) = CTVEC(LOC+8,NCTMOST+I)
               CALL TFTRI(TEMP4(1,2),TEMP2,T3T,TEMP3,3,3,3)
C
               TEMP2(1) = CTVEC(LOC+4,NCTMOST+I)
               TEMP2(2) = CTVEC(LOC+9,NCTMOST+I)
               TEMP2(3) = CTVEC(LOC+6,NCTMOST+I)
               TEMP2(4) = CTVEC(LOC+7,NCTMOST+I)
               TEMP2(5) = CTVEC(LOC+8,NCTMOST+I)
               TEMP2(6) = CTVEC(LOC+2,NCTMOST+I)
               CALL TFTRI(TEMP4(1,3),TEMP2,T3T,TEMP3,3,3,3)
C
               CALL MRARBR(TEMP4,6,6,3,T3T,3,3,TEMP5,6)
C
               CTVEC(LOC  ,NCTMOST+I) = TEMP5(1,1)
               CTVEC(LOC+1,NCTMOST+I) = TEMP5(3,2)
               CTVEC(LOC+2,NCTMOST+I) = TEMP5(6,3)
               CTVEC(LOC+3,NCTMOST+I) = TEMP5(2,1)/SQRT5*THREE
               CTVEC(LOC+4,NCTMOST+I) = TEMP5(4,1)/SQRT5*THREE
               CTVEC(LOC+5,NCTMOST+I) = TEMP5(3,1)/SQRT5*THREE
               CTVEC(LOC+6,NCTMOST+I) = TEMP5(5,2)/SQRT5*THREE
               CTVEC(LOC+7,NCTMOST+I) = TEMP5(6,1)/SQRT5*THREE
               CTVEC(LOC+8,NCTMOST+I) = TEMP5(6,2)/SQRT5*THREE
               CTVEC(LOC+9,NCTMOST+I) = TEMP5(5,1)/SQRT5*THREE/
     *                                 SQRT3*TWO
C
            END DO
         END IF
C  G:
C
         IF(ITYP.EQ.15) THEN
            DO I = 1,ICTMO
               CTVEC(LOC+ 3,NCTMOST+I) = CTVEC(LOC+ 3,NCTMOST+I)*
     *                                  SQRT7/FOUR
               CTVEC(LOC+ 4,NCTMOST+I) = CTVEC(LOC+ 4,NCTMOST+I)*
     *                                  SQRT7/FOUR
               CTVEC(LOC+ 5,NCTMOST+I) = CTVEC(LOC+ 5,NCTMOST+I)*
     *                                  SQRT7/FOUR
               CTVEC(LOC+ 6,NCTMOST+I) = CTVEC(LOC+ 6,NCTMOST+I)*
     *                                  SQRT7/FOUR
               CTVEC(LOC+ 7,NCTMOST+I) = CTVEC(LOC+ 7,NCTMOST+I)*
     *                                  SQRT7/FOUR
               CTVEC(LOC+ 8,NCTMOST+I) = CTVEC(LOC+ 8,NCTMOST+I)*
     *                                  SQRT7/FOUR
               CTVEC(LOC+ 9,NCTMOST+I) = CTVEC(LOC+ 9,NCTMOST+I)*
     *                                  SQRT7*SQRT5/SQRT3/SIX
               CTVEC(LOC+10,NCTMOST+I) = CTVEC(LOC+10,NCTMOST+I)*
     *                                  SQRT7*SQRT5/SQRT3/SIX
               CTVEC(LOC+11,NCTMOST+I) = CTVEC(LOC+11,NCTMOST+I)*
     *                                  SQRT7*SQRT5/SQRT3/SIX
               CTVEC(LOC+12,NCTMOST+I) = CTVEC(LOC+12,NCTMOST+I)*
     *                                  SQRT7*SQRT5/TWELVE
               CTVEC(LOC+13,NCTMOST+I) = CTVEC(LOC+13,NCTMOST+I)*
     *                                  SQRT7*SQRT5/TWELVE
               CTVEC(LOC+14,NCTMOST+I) = CTVEC(LOC+14,NCTMOST+I)*
     *                                  SQRT7*SQRT5/TWELVE
C
C              PERFORM THE FIRST AND SECOND ROTATION
C
               TEMP2(1) = CTVEC(LOC   ,NCTMOST+I)
               TEMP2(2) = CTVEC(LOC+ 3,NCTMOST+I)
               TEMP2(3) = CTVEC(LOC+ 9,NCTMOST+I)
               TEMP2(4) = CTVEC(LOC+ 4,NCTMOST+I)
               TEMP2(5) = CTVEC(LOC+12,NCTMOST+I)
               TEMP2(6) = CTVEC(LOC+10,NCTMOST+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXX(1) = TEMP4(1,1)
               TPXX(2) = TEMP4(2,1)
               TPXX(3) = TEMP4(3,1)
               TPXX(4) = TEMP4(4,1)
               TPXX(5) = TEMP4(5,1)
               TPXX(6) = TEMP4(6,1)
C
               TEMP2(1) = CTVEC(LOC+ 3,NCTMOST+I)
               TEMP2(2) = CTVEC(LOC+ 9,NCTMOST+I)
               TEMP2(3) = CTVEC(LOC+ 5,NCTMOST+I)
               TEMP2(4) = CTVEC(LOC+12,NCTMOST+I)
               TEMP2(5) = CTVEC(LOC+13,NCTMOST+I)
               TEMP2(6) = CTVEC(LOC+14,NCTMOST+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXY(1) = TEMP4(1,1)
               TPXY(2) = TEMP4(2,1)
               TPXY(3) = TEMP4(3,1)
               TPXY(4) = TEMP4(4,1)
               TPXY(5) = TEMP4(5,1)
               TPXY(6) = TEMP4(6,1)
               TEMP2(1) = CTVEC(LOC+ 9,NCTMOST+I)
               TEMP2(2) = CTVEC(LOC+ 5,NCTMOST+I)
               TEMP2(3) = CTVEC(LOC+ 1,NCTMOST+I)
               TEMP2(4) = CTVEC(LOC+13,NCTMOST+I)
               TEMP2(5) = CTVEC(LOC+ 6,NCTMOST+I)
               TEMP2(6) = CTVEC(LOC+11,NCTMOST+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYY(1) = TEMP4(1,1)
               TPYY(2) = TEMP4(2,1)
               TPYY(3) = TEMP4(3,1)
               TPYY(4) = TEMP4(4,1)
               TPYY(5) = TEMP4(5,1)
               TPYY(6) = TEMP4(6,1)
C
               TEMP2(1) = CTVEC(LOC+ 4,NCTMOST+I)
               TEMP2(2) = CTVEC(LOC+12,NCTMOST+I)
               TEMP2(3) = CTVEC(LOC+13,NCTMOST+I)
               TEMP2(4) = CTVEC(LOC+10,NCTMOST+I)
               TEMP2(5) = CTVEC(LOC+14,NCTMOST+I)
               TEMP2(6) = CTVEC(LOC+ 7,NCTMOST+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXZ(1) = TEMP4(1,1)
               TPXZ(2) = TEMP4(2,1)
               TPXZ(3) = TEMP4(3,1)
               TPXZ(4) = TEMP4(4,1)
               TPXZ(5) = TEMP4(5,1)
               TPXZ(6) = TEMP4(6,1)
C
               TEMP2(1) = CTVEC(LOC+12,NCTMOST+I)
               TEMP2(2) = CTVEC(LOC+13,NCTMOST+I)
               TEMP2(3) = CTVEC(LOC+ 6,NCTMOST+I)
               TEMP2(4) = CTVEC(LOC+14,NCTMOST+I)
               TEMP2(5) = CTVEC(LOC+11,NCTMOST+I)
               TEMP2(6) = CTVEC(LOC+ 8,NCTMOST+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYZ(1) = TEMP4(1,1)
               TPYZ(2) = TEMP4(2,1)
               TPYZ(3) = TEMP4(3,1)
               TPYZ(4) = TEMP4(4,1)
               TPYZ(5) = TEMP4(5,1)
               TPYZ(6) = TEMP4(6,1)
C
               TEMP2(1) = CTVEC(LOC+10,NCTMOST+I)
               TEMP2(2) = CTVEC(LOC+14,NCTMOST+I)
               TEMP2(3) = CTVEC(LOC+11,NCTMOST+I)
               TEMP2(4) = CTVEC(LOC+ 7,NCTMOST+I)
               TEMP2(5) = CTVEC(LOC+ 8,NCTMOST+I)
               TEMP2(6) = CTVEC(LOC+ 2,NCTMOST+I)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPZZ(1) = TEMP4(1,1)
               TPZZ(2) = TEMP4(2,1)
               TPZZ(3) = TEMP4(3,1)
               TPZZ(4) = TEMP4(4,1)
               TPZZ(5) = TEMP4(5,1)
               TPZZ(6) = TEMP4(6,1)
C
C              PERFORM THE THIRD AND FOURTH ROTATION
C
               TEMP2(1) = TPXX(1)
               TEMP2(2) = TPXY(1)
               TEMP2(3) = TPYY(1)
               TEMP2(4) = TPXZ(1)
               TEMP2(5) = TPYZ(1)
               TEMP2(6) = TPZZ(1)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXX2(1) = TEMP4(1,1)
               TPXX2(2) = TEMP4(2,1)
               TPXX2(3) = TEMP4(3,1)
               TPXX2(4) = TEMP4(4,1)
               TPXX2(5) = TEMP4(5,1)
               TPXX2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(2)
               TEMP2(2) = TPXY(2)
               TEMP2(3) = TPYY(2)
               TEMP2(4) = TPXZ(2)
               TEMP2(5) = TPYZ(2)
               TEMP2(6) = TPZZ(2)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXY2(1) = TEMP4(1,1)
               TPXY2(2) = TEMP4(2,1)
               TPXY2(3) = TEMP4(3,1)
               TPXY2(4) = TEMP4(4,1)
               TPXY2(5) = TEMP4(5,1)
               TPXY2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(3)
               TEMP2(2) = TPXY(3)
               TEMP2(3) = TPYY(3)
               TEMP2(4) = TPXZ(3)
               TEMP2(5) = TPYZ(3)
               TEMP2(6) = TPZZ(3)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYY2(1) = TEMP4(1,1)
               TPYY2(2) = TEMP4(2,1)
               TPYY2(3) = TEMP4(3,1)
               TPYY2(4) = TEMP4(4,1)
               TPYY2(5) = TEMP4(5,1)
               TPYY2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(4)
               TEMP2(2) = TPXY(4)
               TEMP2(3) = TPYY(4)
               TEMP2(4) = TPXZ(4)
               TEMP2(5) = TPYZ(4)
               TEMP2(6) = TPZZ(4)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPXZ2(1) = TEMP4(1,1)
               TPXZ2(2) = TEMP4(2,1)
               TPXZ2(3) = TEMP4(3,1)
               TPXZ2(4) = TEMP4(4,1)
               TPXZ2(5) = TEMP4(5,1)
               TPXZ2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(5)
               TEMP2(2) = TPXY(5)
               TEMP2(3) = TPYY(5)
               TEMP2(4) = TPXZ(5)
               TEMP2(5) = TPYZ(5)
               TEMP2(6) = TPZZ(5)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPYZ2(1) = TEMP4(1,1)
               TPYZ2(2) = TEMP4(2,1)
               TPYZ2(3) = TEMP4(3,1)
               TPYZ2(4) = TEMP4(4,1)
               TPYZ2(5) = TEMP4(5,1)
               TPYZ2(6) = TEMP4(6,1)
C
               TEMP2(1) = TPXX(6)
               TEMP2(2) = TPXY(6)
               TEMP2(3) = TPYY(6)
               TEMP2(4) = TPXZ(6)
               TEMP2(5) = TPYZ(6)
               TEMP2(6) = TPZZ(6)
               CALL TFTRI(TEMP4(1,1),TEMP2,T3T,TEMP3,3,3,3)
               TPZZ2(1) = TEMP4(1,1)
               TPZZ2(2) = TEMP4(2,1)
               TPZZ2(3) = TEMP4(3,1)
               TPZZ2(4) = TEMP4(4,1)
               TPZZ2(5) = TEMP4(5,1)
               TPZZ2(6) = TEMP4(6,1)
C
               CTVEC(LOC   ,NCTMOST+I) = TPXX2(1)
               CTVEC(LOC+ 1,NCTMOST+I) = TPYY2(3)
               CTVEC(LOC+ 2,NCTMOST+I) = TPZZ2(6)
               CTVEC(LOC+ 3,NCTMOST+I) = TPXY2(1)/SQRT7*FOUR
               CTVEC(LOC+ 4,NCTMOST+I) = TPXZ2(1)/SQRT7*FOUR
               CTVEC(LOC+ 5,NCTMOST+I) = TPYY2(2)/SQRT7*FOUR
               CTVEC(LOC+ 6,NCTMOST+I) = TPYZ2(3)/SQRT7*FOUR
               CTVEC(LOC+ 7,NCTMOST+I) = TPXZ2(6)/SQRT7*FOUR
               CTVEC(LOC+ 8,NCTMOST+I) = TPYZ2(6)/SQRT7*FOUR
               CTVEC(LOC+ 9,NCTMOST+I) = TPYY2(1)/SQRT7/SQRT5*
     *                                  SQRT3*SIX
               CTVEC(LOC+10,NCTMOST+I) = TPZZ2(1)/SQRT7/SQRT5*
     *                                  SQRT3*SIX
               CTVEC(LOC+11,NCTMOST+I) = TPZZ2(3)/SQRT7/SQRT5*
     *                                  SQRT3*SIX
               CTVEC(LOC+12,NCTMOST+I) = TPYZ2(1)/SQRT7/SQRT5*
     *                                  TWELVE
               CTVEC(LOC+13,NCTMOST+I) = TPYZ2(2)/SQRT7/SQRT5*
     *                                  TWELVE
               CTVEC(LOC+14,NCTMOST+I) = TPZZ2(2)/SQRT7/SQRT5*
     *                                  TWELVE
            END DO
         END IF
      END DO
C
      CALL EFCM
C
      RETURN
      END
C
C*MODULE MDEFP   *DECK MDROTT
      SUBROUTINE MDROTT(QW1,QX1,QY1,QZ1,QW2,QX2,QY2,QZ2,T,INTMD)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      INTEGER INTMD
      DIMENSION T(3,3)
C
C        write(6,*) 'in mdrott:'
C        write(6,*) 'q1 = ',qw1,qx1,qy1,qz1
C        write(6,*) 'q2 = ',qw2,qx2,qy2,qz2
C
       IF(INTMD.EQ.1) THEN
        AXX1 = QW1 ** 2 + QX1 ** 2 - QY1 ** 2 - QZ1 ** 2
        AXY1 = 2.0D+00 * ( QX1 * QY1 + QW1 * QZ1 )
        AXZ1 = 2.0D+00 * ( QX1 * QZ1 - QW1 * QY1 )
        AYX1 = 2.0D+00 * ( QX1 * QY1 - QW1 * QZ1 )
        AYY1 = QW1 ** 2 - QX1 ** 2 + QY1 ** 2 - QZ1 ** 2
        AYZ1 = 2.0D+00 * ( QY1 * QZ1 + QW1 * QX1 )
        AZX1 = 2.0D+00 * ( QX1 * QZ1 + QW1 * QY1 )
        AZY1 = 2.0D+00 * ( QY1 * QZ1 - QW1 * QX1 )
        AZZ1 = QW1 ** 2 - QX1 ** 2 - QY1 ** 2 + QZ1 ** 2
C
        AXX2 = QW2 ** 2 + QX2 ** 2 - QY2 ** 2 - QZ2 ** 2
        AXY2 = 2.0D+00 * ( QX2 * QY2 + QW2 * QZ2 )
        AXZ2 = 2.0D+00 * ( QX2 * QZ2 - QW2 * QY2 )
        AYX2 = 2.0D+00 * ( QX2 * QY2 - QW2 * QZ2 )
        AYY2 = QW2 ** 2 - QX2 ** 2 + QY2 ** 2 - QZ2 ** 2
        AYZ2 = 2.0D+00 * ( QY2 * QZ2 + QW2 * QX2 )
        AZX2 = 2.0D+00 * ( QX2 * QZ2 + QW2 * QY2 )
        AZY2 = 2.0D+00 * ( QY2 * QZ2 - QW2 * QX2 )
        AZZ2 = QW2 ** 2 - QX2 ** 2 - QY2 ** 2 + QZ2 ** 2
       ELSE
         AXX1=-QW1**2+QX1**2-QY1**2+QZ1**2
         AXY1= 2.0D+00*(QY1*QZ1-QW1*QX1)
         AXZ1= 2.0D+00*(QX1*QY1+QW1*QZ1)
C
         AYX1=-2.0D+00*(QW1*QX1+QY1*QZ1)
         AYY1= QW1**2-QX1**2-QY1**2+QZ1**2
         AYZ1= 2.0D+00*(QX1*QZ1-QW1*QY1)
C
         AZX1= 2.0D+00*(QX1*QY1-QW1*QZ1)
         AZY1=-2.0D+00*(QW1*QY1+QX1*QZ1)
         AZZ1=-QW1**2-QX1**2+QY1**2+QZ1**2
C
         AXX2=-QW2**2+QX2**2-QY2**2+QZ2**2
         AXY2= 2.0D+00*(QY2*QZ2-QW2*QX2)
         AXZ2= 2.0D+00*(QX2*QY2+QW2*QZ2)
C
         AYX2=-2.0D+00*(QW2*QX2+QY2*QZ2)
         AYY2= QW2**2-QX2**2-QY2**2+QZ2**2
         AYZ2= 2.0D+00*(QX2*QZ2-QW2*QY2)
C
         AZX2= 2.0D+00*(QX2*QY2-QW2*QZ2)
         AZY2=-2.0D+00*(QW2*QY2+QX2*QZ2)
         AZZ2=-QW2**2-QX2**2+QY2**2+QZ2**2
       ENDIF
C
C
C
C        t should be a2 * a1^T
C
C        t(1,1) = axx2*axx1 + axy2*axy1 + axz2*axz1
C        t(1,2) = axx2*ayx1 + axy2*ayy1 + axz2*ayz1
C        t(1,3) = axx2*azx1 + axy2*azy1 + axz2*azz1
C        t(2,1) = ayx2*axx1 + ayy2*axy1 + ayz2*axz1
C        t(2,2) = ayx2*ayx1 + ayy2*ayy1 + ayz2*ayz1
C        t(2,3) = ayx2*azx1 + ayy2*azy1 + ayz2*azz1
C        t(3,1) = azx2*axx1 + azy2*axy1 + azz2*axz1
C        t(3,2) = azx2*ayx1 + azy2*ayy1 + azz2*ayz1
C        t(3,3) = azx2*azx1 + azy2*azy1 + azz2*azz1
C
C        a2^T * a1
C
        T(1,1) = AXX2*AXX1 + AYX2*AYX1 + AZX2*AZX1
        T(1,2) = AXX2*AXY1 + AYX2*AYY1 + AZX2*AZY1
        T(1,3) = AXX2*AXZ1 + AYX2*AYZ1 + AZX2*AZZ1
        T(2,1) = AXY2*AXX1 + AYY2*AYX1 + AZY2*AZX1
        T(2,2) = AXY2*AXY1 + AYY2*AYY1 + AZY2*AZY1
        T(2,3) = AXY2*AXZ1 + AYY2*AYZ1 + AZY2*AZZ1
        T(3,1) = AXZ2*AXX1 + AYZ2*AYX1 + AZZ2*AZX1
        T(3,2) = AXZ2*AXY1 + AYZ2*AYY1 + AZZ2*AZY1
        T(3,3) = AXZ2*AXZ1 + AYZ2*AYZ1 + AZZ2*AZZ1
C
        RETURN
        END
C
C*MODULE MDEFP   *DECK MDRPREF
      SUBROUTINE MDRPREF(ISTEP,TTOTAL,KOUNT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000)
C
      DOUBLE PRECISION MDTYP
C
      LOGICAL PRESSR,DIFUSN,DIPOLEP,HTVAP,COORDN,RRELAX,HBLFE
      LOGICAL GOPARR, DSKWRK, MASWRK
      LOGICAL         NVT,NVTP
C
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /FRGNRG/ CCNRG,CDNRG,CQNRG,CONRG,DDNRG,DQNRG,QQNRG,
     *                ESNRG,REPNRG,POLNRG,DISNRG,DISNRG8,
     *                EDISD,CHTNRG
      COMMON /FUNCT / E, EG(3*MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MDSIM / DT, BATHT, EKINT, EKINR, MDTYP
      COMMON /MDSIM3/ NVT,NVTP
      COMMON /MDSIM6/ DIFFU,PRESSA,DBT,GK,E0,DHV,HM0,HM20,
     *                HMU2,HMT,HM0T,VECX,P2,P3,P4,P5,P6,ANC,EX,
     *                HB,HC,HN,HDCDT,CT,ANT,DCDT,HBLIFT,GGK,HM2TT2,
     *                VIRA,EKA,HMU,MGR,MH0
      COMMON /MDSIM8/ PRESSR,DIFUSN,DIPOLEP,HTVAP,COORDN,
     *                RRELAX,HBLFE
      COMMON /NOSEHO/ GNH(2),VNH(2),XNH(2),QNH(2),EKT0,GFREE0,NVTNH
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /ECONV/  ETOT0
      COMMON /EFPMP2/ MP2TYP
      COMMON /VIRPR / VIR(3), PRXX, PRYY, PRZZ
C
C          output energy and property values to log file.
C     this is used when QM atoms are absent, see also MDRPRAB.
C
      IF(.NOT.MASWRK) RETURN
C
      IF(NVT) WRITE(IW,3999)
      WRITE(IW,4000) TTOTAL*1.0D+15,ISTEP
      WRITE(IW,4012) ESNRG*AU2KCAL
      WRITE(IW,4013) POLNRG*AU2KCAL
      IF(MP2TYP.EQ.1) THEN
         WRITE(IW,4031) DISNRG*AU2KCAL
         WRITE(IW,4032) DISNRG8*AU2KCAL
      ENDIF
      WRITE(IW,4016) EDISD*AU2KCAL
      WRITE(IW,4017) CHTNRG*AU2KCAL
      WRITE(IW,4014) REPNRG*AU2KCAL
      WRITE(IW,4015) E*AU2KCAL
      IF (ISTEP.NE.0) THEN
         EKIN = EKINT + EKINR
         WRITE(IW,4027) EKINT
         WRITE(IW,4028) EKINR
         WRITE(IW,4029) EKIN
         IF (NVTNH.EQ.0) THEN
            ETOT = EKIN+E*AU2KCAL
            IF (ISTEP.LE.10) ETOT0 = ETOT
            WRITE(IW,4039) ETOT, ETOT-ETOT0
         ELSE IF (NVTNH.EQ.1) THEN
            QKIN = QNH(1) * VNH(1) * VNH(1) / 2.0D+00 * EK2KCAL
            QPOT = GFREE0 * EKT0 * XNH(1) * EK2KCAL
            ETOT = EKIN+E*AU2KCAL+QKIN+QPOT
            IF (ISTEP.LE.10) ETOT0 = ETOT
            WRITE(IW,4040) ETOT, ETOT-ETOT0
         ELSE IF (NVTNH.EQ.2) THEN
            QKIN1 = QNH(1) * VNH(1) * VNH(1) / 2.0D+00 * EK2KCAL
            QKIN2 = QNH(2) * VNH(2) * VNH(2) / 2.0D+00 * EK2KCAL
            QPOT1 = GFREE0 * EKT0 * XNH(1) * EK2KCAL
            QPOT2 = EKT0 * XNH(2) * EK2KCAL
            QKIN  = QKIN1 + QKIN2
            QPOT  = QPOT1 + QPOT2
            ETOT = EKIN+E*AU2KCAL+QKIN+QPOT
            IF (ISTEP.LE.10) ETOT0 = ETOT
            WRITE(IW,4040) ETOT, ETOT-ETOT0
         END IF
         WRITE(IW,4050) TEMPMD(EKIN)
C
         IF (PRESSR) THEN
            PINT = (PRXX + PRYY + PRZZ)/3.0D+00
            WRITE(IW,4117) PINT*EK2BAR, PRESSA*EK2BAR/KOUNT
         END IF
         IF (DIFUSN) WRITE(IW,4118) DIFFU/KOUNT
         IF (DIPOLEP) THEN
            WRITE(IW,4119) DBT
            WRITE(IW,4120) E0
            WRITE(IW,4121) GK
            WRITE(IW,4122) GGK
         ENDIF
         IF (COORDN) WRITE(IW,4123) ANC/KOUNT
         IF (HTVAP)  WRITE(IW,4124) DHV
      ENDIF
C
      CALL FLSHBF(IW)
      RETURN
C
C       *** report formats
 3999 FORMAT(/,1X,'NVT RUN!!!')
 4000 FORMAT(/,1X,'*** AT T=',F14.2,' FSEC, THIS RUN''S STEP NO.=',I8)
 4012 FORMAT(  5X,'ELEC ENERGY      = ',F20.8,' KCAL/MOL')
 4013 FORMAT(  5X,'POLZ ENERGY      = ',F20.8,' KCAL/MOL')
 4016 FORMAT(  5X,'DISP ENERGY      = ',F20.8,' KCAL/MOL')
 4017 FORMAT(  5X,'CH-TR ENRGY      = ',F20.8,' KCAL/MOL')
 4014 FORMAT(  5X,'REP  ENERGY      = ',F20.8,' KCAL/MOL')
 4015 FORMAT(  5X,'POT  ENERGY      = ',F20.8,' KCAL/MOL')
 4027 FORMAT(/,5X,'TRANS    KE      = ',F20.8,' KCAL/MOL')
 4028 FORMAT(  5X,'ROT      KE      = ',F20.8,' KCAL/MOL')
 4029 FORMAT(  5X,'TOT      KE      = ',F20.8,' KCAL/MOL')
 4031 FORMAT(  5X,'DISP ENERGY      = ',F20.8,' KCAL/MOL')
 4032 FORMAT(  5X,'DISP8ENERGY      = ',F20.8,' KCAL/MOL')
 4039 FORMAT(/,5X,'TOTAL ENERGY     = ',F20.8,' KCAL/MOL',F12.8)
 4040 FORMAT(/,5X,'TOT. HAM. ENERGY = ',E14.8,' KCAL/MOL',F14.8)
 4050 FORMAT(/,5X,'TEMPERATURE      = ',F20.8,' K'       )
 4117 FORMAT(  5X,'PRESSURE(AVERAGE)= ',F20.4,' BAR    (',F20.4,' BAR)')
 4118 FORMAT(  5X,'DIFFUSION        = ',F20.8,' ANG^2/PS')
 4119 FORMAT(  5X,'DIPOLE CORR.FUNC.= ',F20.8,'         ')
 4120 FORMAT(  5X,'REL. PERMATRIVITY= ',F20.8,'         ')
 4121 FORMAT(  5X,'FINITE KIRKWOOD  = ',F20.8,'         ')
 4122 FORMAT(  5X,'INFINITE KIRKWOOD= ',F20.8,'         ')
 4123 FORMAT(  5X,'COORDINATION #   = ',F20.8,'         ')
 4124 FORMAT(  5X,'HEAT OF VAP      = ',F20.8,' KCAL/MOL*K')
      END
C
C*MODULE MDEFP   *DECK MDRPRAB
      SUBROUTINE MDRPRAB(ISTEP,TTOTAL,KOUNT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000)
C
      DOUBLE PRECISION MDTYP
      LOGICAL GOPARR, DSKWRK, MASWRK
      LOGICAL PRESSR,DIFUSN,DIPOLEP,HTVAP,COORDN,RRELAX,HBLFE
      LOGICAL NVT,NVTP
C
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /FUNCT / E, EG(3*MXATM)
      COMMON /MDSIM / DT, BATHT, EKINT, EKINR, MDTYP
      COMMON /MDSIM3/ NVT,NVTP
      COMMON /MDSIM6/ DIFFU,PRESSA,DBT,GK,E0,DHV,HM0,HM20,
     *                HMU2,HMT,HM0T,VECX,P2,P3,P4,P5,P6,ANC,EX,
     *                HB,HC,HN,HDCDT,CT,ANT,DCDT,HBLIFT,GGK,HM2TT2,
     *                VIRA,EKA,HMU,MGR,MH0
      COMMON /MDSIM8/ PRESSR,DIFUSN,DIPOLEP,HTVAP,COORDN,
     *                RRELAX,HBLFE
      COMMON /NOSEHO/ GNH(2),VNH(2),XNH(2),QNH(2),EKT0,GFREE0,NVTNH
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /ECONV/  ETOT0
      COMMON /VIRPR / VIR(3), PRXX, PRYY, PRZZ
C
C          output energy and property values to log file.
C     this is used when QM atoms are present, see also MDRPREF.
C
      IF (.NOT.MASWRK ) RETURN
C
      IF(NVT) WRITE(IW,3999)
      WRITE(IW,4000) TTOTAL*1.0D+15,ISTEP
      WRITE(IW,4015) E*AU2KCAL
      IF(ISTEP.NE.0) THEN
         EKIN = EKINT+EKINR
         WRITE(IW,4027) EKINT
         WRITE(IW,4028) EKINR
         WRITE(IW,4029) EKIN
         IF (NVTNH.EQ.0) THEN
            ETOT = (EKIN+E*AU2KCAL)
            IF (ISTEP.LE.10) ETOT0 = ETOT
            WRITE(IW,4039) ETOT, ETOT-ETOT0
         ELSE IF (NVTNH.EQ.1) THEN
            QKIN = QNH(1) * VNH(1) * VNH(1) / 2.0D+00 * EK2KCAL
            QPOT = GFREE0 * EKT0 * XNH(1) * EK2KCAL
            ETOT = (EKIN+E*AU2KCAL+QKIN+QPOT)
            IF (ISTEP.LE.10) ETOT0 = ETOT
            WRITE(IW,4040) ETOT, ETOT-ETOT0
         ELSE IF (NVTNH.EQ.2) THEN
            QKIN1 = QNH(1) * VNH(1) * VNH(1) / 2.0D+00 * EK2KCAL
            QKIN2 = QNH(2) * VNH(2) * VNH(2) / 2.0D+00 * EK2KCAL
            QPOT1 = GFREE0 * EKT0 * XNH(1) * EK2KCAL
            QPOT2 = EKT0 * XNH(2) * EK2KCAL
            QKIN  = QKIN1 + QKIN2
            QPOT  = QPOT1 + QPOT2
            ETOT = EKIN+E*AU2KCAL+QKIN+QPOT
            IF (ISTEP.LE.10) ETOT0 = ETOT
            WRITE(IW,4040) ETOT, ETOT-ETOT0
         END IF
         WRITE(IW,4050) TEMPMD(EKIN)
C
         IF (PRESSR) THEN
            PINT = (PRXX + PRYY + PRZZ)/3.0D+00
            WRITE(IW,4117) PINT*EK2BAR,PRESSA*EK2BAR/KOUNT
         END IF
         IF (DIFUSN) WRITE(IW,4118) DIFFU/KOUNT
         IF (DIPOLEP) THEN
            WRITE(IW,4119) DBT
            WRITE(IW,4120) E0
            WRITE(IW,4121) GK
            WRITE(IW,4122) GGK
         ENDIF
         IF (COORDN) WRITE(IW,4123) ANC/KOUNT
         IF (HTVAP) WRITE(IW,4124) DHV
      END IF
C
C        *** report formats
 3999 FORMAT(/,1X,'NVT RUN!!!')
 4000 FORMAT(/,1X,'*** AT T=',F14.2,' FSEC, THIS RUN''S STEP NO.=',I8)
 4015 FORMAT(  5X,'POT  ENERGY      = ',1P,E20.9,0P,' KCAL/MOL')
 4027 FORMAT(/,5X,'TRANS    KE      = ',F20.8,' KCAL/MOL')
 4028 FORMAT(  5X,'ROT      KE      = ',F20.8,' KCAL/MOL')
 4029 FORMAT(  5X,'TOT      KE      = ',F20.8,' KCAL/MOL')
 4039 FORMAT(/,5X,'TOT  ENERGY      = ',1P,E20.9,0P,
     *        ' KCAL/MOL', F12.8)
 4040 FORMAT(/,5X,'TOT. HAM. ENERGY = ',1P,E20.9,0P,
     *        ' KCAL/MOL', F14.8)
 4050 FORMAT(/,5X,'TEMPERATURE      = ',F20.8,' K'       )
 4117 FORMAT(  5X,'PRESSURE(AVERAGE)= ',F20.4,' BAR    (',F20.4,' BAR)')
 4118 FORMAT(  5X,'DIFFUSION        = ',F20.8,' ANG^2/PS')
 4119 FORMAT(  5X,'DIPOLE CORR.FUNC.= ',F20.8,'         ')
 4120 FORMAT(  5X,'REL. PERMATRIVITY= ',F20.8,'         ')
 4121 FORMAT(  5X,'FINITE KIRKWOOD  = ',F20.8,'         ')
 4122 FORMAT(  5X,'INFINITE KIRKWOOD= ',F20.8,'         ')
 4123 FORMAT(  5X,'COORDINATION #   = ',F20.8,'         ')
 4124 FORMAT(  5X,'HEAT OF VAP      = ',F20.8,' KCAL/MOL*K')
      END
C
C*MODULE MDEFP   *DECK MDPRTCORVEL
C>
C>     @brief output data for MD
C>
C>     @details Output particle coordinates and velocity information.
C>
C>     @author unknown 
C>
      SUBROUTINE MDPRTCORVEL(ISTEP,TTOTAL,INTMD,iptraj)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXAO=8192, NRepca=100,
     *           MXFRG=1050, MXPT=2000, MXFGPT=12000,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (ZERO=0.0D+00)
      PARAMETER (NBIN=1000,MAXRDF=100)
C
      DOUBLE PRECISION MDTYP
C
      CHARACTER*6 FRGNAM
      CHARACTER*8 PTNAM,FRGNME,FRCNME
      character*3 chrout
C
      LOGICAL PBCOUT,PBCWRI
      LOGICAL GOPARR, DSKWRK, MASWRK
      LOGICAL IFRCPNT
      double precision mdint
      logical ccms,ssbp,usamp,rstemp,rsrand,prod
      logical ISGDDI,PAROUT,INITGDDI,wasgddi
      COMMON /ATMDAT/ VX(MXFRG), VY(MXFRG), VZ(MXFRG),
     *                QW(MXFRG), QX(MXFRG), QY(MXFRG), QZ(MXFRG),
     *                OX(MXFRG), OY(MXFRG), OZ(MXFRG), QW1(MXFRG),
     *                QX1(MXFRG),QY1(MXFRG),QZ1(MXFRG),QW2(MXFRG),
     *                QX2(MXFRG),QY2(MXFRG),QZ2(MXFRG),
     *                VXQM(MXATM), VYQM(MXATM), VZQM(MXATM)
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /EFPFRC/ IFRCPNT,NTFRCPN,NFRCPNT(MXFRG),LSTFPTS(MXFRG),
     *                FRCCRD(3,MXFGPT),FRCNME(MXFGPT),FRCTRQ(6,MXFGPT),
     *                FRCTRQX(6,MXFGPT)
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      COMMON /FUNCT / E, EG(3*MXATM)
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /MDSIM / DT, BATHT, EKINT, EKINR, MDTYP
      COMMON /MDSIM4/ NSTEPS
      COMMON /MDVEL / WX(MXFRG),WY(MXFRG),WZ(MXFRG),TQI(3,MXFRG)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PBCCO/  FRGCPB(3,MXFGPT),EFPPB(3,MXFGPT),
     *                EFDPPB(3,MXFGPT),CREPPB(3,MXFGPT)
      COMMON /PBC/    PBCOUT,PBCWRI
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
      COMMON /NOSEHO/ GNH(2),VNH(2),XNH(2),QNH(2),EKT0,GFREE0,NVTNH
      common /cstpot/ DROFF(2),SFORCE,uforce(10),rzero(10),dtemp,
     *                rzeroC(3,MXATM),Tmin,uV,abatht(NRepca),mdint,
     *                ipair(50),iustyp,ncst,nrand,nvtoff,
     *                jevery,kevery,levery,mremd,
     *                rstemp,rsrand,prod,SSBP,ccms,Usamp,IndexOH(50),
     *                movemm(200),nefpmv,cforce,tmass(3)
      COMMON /GOFR  / GOFR(NBIN,3), GENFR(NBIN,MAXRDF), CCRDF(NBIN),
     *                GEN2FR(NBIN,2),
     *                DELR, NUMG, NUMSAM1,NUMSAM2,NUMSAM3
C
C        output particle coordinates and velocity information
C                 used for QM, QM/EFP, or EFP runs
C
      IF(.NOT.MASWRK) RETURN
      IPRST=35
      IPREMD=44
      if (iptraj.ne.ipremd) then
C
C        first section is printing particle coordinates to log file
C
      IF(NAT.GT.0) WRITE(IW,1000)
      DO IAT=1,NAT
         ZNUC = IAN(IAT)
         X = AU2ANG * C(1,IAT)
         Y = AU2ANG * C(2,IAT)
         Z = AU2ANG * C(3,IAT)
         WRITE(IW,1005) ANAM(IAT),BNAM(IAT),ZNUC,X,Y,Z
      ENDDO
C
      IF(NFRG.GT.0) WRITE(IW,1009)
      IAT=0
      KMASS=0
      DO I = 1,NFRG
         WRITE(IW,1010) FRGNAM(I), I
         DO III=1,NMPTS(I)
            IAT=IAT+1
            IF(FMASS(III+KMASS).GT.ZERO) THEN
               XF = EFC(1,IAT)*AU2ANG
               YF = EFC(2,IAT)*AU2ANG
               ZF = EFC(3,IAT)*AU2ANG
               WRITE(IW,1020) FRGNME(IAT),XF,YF,ZF
            END IF
         END DO
         KMASS=KMASS+NMPTS(I)
      ENDDO
C
C         option to report EFP particles shifted inside a single box
C
      IF (ISTEP.EQ.NSTEPS  .AND.  PBCWRI) THEN
         IF(NFRG.GT.0) WRITE(IW,1011)
         IAT=0
         KMASS=0
         DO I= 1,NFRG
            WRITE(IW,1010) FRGNAM(I), I
            DO III=1,NMPTS(I)
               IAT=IAT+1
               IF(FMASS(III+KMASS).GT.ZERO) THEN
                  XF =FRGCPB(1,IAT)*AU2ANG
                  YF =FRGCPB(2,IAT)*AU2ANG
                  ZF =FRGCPB(3,IAT)*AU2ANG
                  WRITE(IW,1020) FRGNME(IAT),XF,YF,ZF
               END IF
            END DO
            KMASS=KMASS+NMPTS(I)
         ENDDO
      END IF
c
      endif
C
C        second section is coordinate output, to the trajectory file
C
      EPOT = E*AU2KCAL
      EKIN = EKINT+EKINR
      ETOT = EPOT+EKIN
      NQMMM=0
      WRITE(IPTRAJ,2000) NAT,NFRG,NQMMM,1.0D+15*TTOTAL,ETOT,
     *                  EPOT,batht,EKIN,EKINT,EKINR
C
      IF(NAT.GT.0) WRITE(IPTRAJ,2001)
      DO I=1,NAT
         ZNUC = IAN(I)
         WRITE(IPTRAJ,2010) ANAM(I),BNAM(I),ZNUC,(AU2ANG*C(J,I),J=1,3)
      ENDDO
C
      IAT=0
      KMASS=0
      IF(NFRG.GT.0) WRITE(IPTRAJ,2002)
      write(IPTRAJ,2012)
      DO I=1,NFRG
         WRITE(IPTRAJ,2020) FRGNAM(I),I
         DO III=1,NMPTS(I)
            IAT=IAT+1
            IF(FMASS(III+KMASS).GT.ZERO) THEN
               WRITE(IPTRAJ,2030) FRGNME(IAT),(AU2ANG*EFC(J,IAT),J=1,3)
            END IF
         END DO
         KMASS=KMASS+NMPTS(I)
      ENDDO
c
      write(IPTRAJ,2013)
C
C         third section is gradient data, to the trajectory file
C     EFP gradient output is needed for EFP coarse graining.
C
      F2F = -AU2KCAL / EK2KCAL
      IF(NFRG.GT.0) WRITE(IPTRAJ,2050)
      N=0
      DO I = 1, NFRG
         WRITE(IPTRAJ,2051) I, FRGNAM(I)
         WRITE(IPTRAJ,2052) EFCENT(1,I),EFCENT(2,I),EFCENT(3,I)
         WRITE(IPTRAJ,2053) DEFT(1,I)/F2F,DEFT(2,I)/F2F,DEFT(3,I)/F2F
         WRITE(IPTRAJ,2054) TORQ(1,I)/F2F,TORQ(2,I)/F2F,TORQ(3,I)/F2F
         IF (IFRCPNT) THEN
           DO K=1, NFRCPNT(I)
             N=N+1
             WRITE(IPTRAJ,2055)I,K,FRCCRD(1,N),FRCCRD(2,N),FRCCRD(3,N),
     *                (FRCTRQ(IN,N),IN=1,6)
           END DO
          END IF
      ENDDO
 2050 FORMAT(5X,'GRADIENT DATA (NOT USED BY RESTARTS)...')
 2051 FORMAT('FRAGMENT #',I6,'  ',A6)
 2052 FORMAT('    EFCENT',3F16.10)
 2053 FORMAT('     FORCE',3F16.10)
 2054 FORMAT('      TORQ',3F16.10)
 2055 FORMAT(1X,2I4,9F16.10)
C
C         4th section is velocity restart data, to the trajectory file
C
      WRITE(IPTRAJ,3000) TTOTAL
      WRITE(IPTRAJ,3001) MDINT,DT,NVTNH,NSTEPS-int(TTOTAL*1.0D+15)
      write(chrout,'(A3)') '.F.'
      if (rstemp) write(chrout,'(A3)') '.T.'
      WRITE(IPTRAJ,3002) chrout,dtemp,levery
      write(chrout,'(A3)') '.F.'
      if (rsrand) write(chrout,'(A3)') '.T.'
      WRITE(IPTRAJ,3003) chrout,nrand,nvtoff,jevery
      write(chrout,'(A3)') '.F.'
      if (prod) write(chrout,'(A3)') '.T.'
      WRITE(IPTRAJ,3004) chrout,kevery,delr
c
      if (isgddi) then
         write(iptraj,'(A,$)') " BathT(1)="
         do i=1,ngroups
            if (mod(i,5).ne.0) then
               if (i.eq.ngroups) then
                  WRITE(IPTRAJ,"(1x,F6.2)") abatht(i)
               else
                  WRITE(IPTRAJ,"(1x,F6.2,$)") abatht(i)
               endif
            else
               WRITE(IPTRAJ,"(1x,F6.2)") abatht(i)
            endif
         enddo
      else
         WRITE(IPTRAJ,3005) BATHT
      endif
C
      convfac=au2kcal/au2ang**2
      if(ssbp) write(IPTRAJ,3010) sforce*convfac,droff(1)*au2ang,
     *                            droff(2)*au2ang    
      if(ccms) write(IPTRAJ,3019) cforce*convfac
      if(usamp) then
         write(IPTRAJ,3011) uforce(1)*convfac,uforce(2)*convfac,
     *    uforce(3)*convfac,rzero(1)*au2ang,rzero(2)*au2ang,
     *    rzero(3)*au2ang
         write(IPTRAJ,3018) iustyp
          if (iustyp.eq.0) then
             if (ncst.eq.1) then
                WRITE(IPTRAJ,3012) ipair(1),ipair(2)
             elseif (ncst.eq.2) then
                WRITE(IPTRAJ,3013) ipair(1),ipair(2),ipair(3),ipair(4)
             endif
          elseif (iustyp.eq.1) then
             if (ncst.eq.1) then
                WRITE(IPTRAJ,3014) ipair(1),ipair(2),ipair(3)
             elseif (ncst.eq.2) then
                WRITE(IPTRAJ,3015) ipair(1),ipair(2),ipair(3),ipair(4),
     *             ipair(5),ipair(6)
             elseif (ncst.eq.3) then
                WRITE(IPTRAJ,3016) ipair(1),ipair(2),ipair(3),ipair(4),
     *             ipair(5),ipair(6),ipair(7),ipair(8),ipair(9)
             elseif (ncst.eq.4) then
                WRITE(IPTRAJ,3017) ipair(1),ipair(2),ipair(3),ipair(4),
     *             ipair(5),ipair(6),ipair(7),ipair(8),ipair(9),
     *             ipair(10),ipair(11),ipair(12)
             endif
         endif
      endif
c
      VFACT = 1.0D-12
      IF(NAT.GT.0) THEN
         WRITE(IPTRAJ,3020)
         DO I=1,NAT
            WRITE(IPTRAJ,3030) VXQM(I)*VFACT,VYQM(I)*VFACT,VZQM(I)*VFACT
         ENDDO
      END IF
      IF(NFRG.GT.0) THEN
         WRITE(IPTRAJ,3050)
         DO I=1,NFRG
            WRITE(IPTRAJ,3030) VX(I)*VFACT, VY(I)*VFACT, VZ(I)*VFACT
         ENDDO
         WRITE(IPTRAJ,3060)
         DO I=1,NFRG
            WRITE(IPTRAJ,3040) QW(I),QX(I),QY(I),QZ(I)
         ENDDO
C
C           Distinguish between leapfrog and velocity verlet...
C
         IF(INTMD.EQ.1) THEN
            WRITE(IPTRAJ,3070)
            DO I=1,NFRG
               WRITE(IPTRAJ,3040) OX(I)*VFACT, OY(I)*VFACT, OZ(I)*VFACT
            ENDDO
         ELSE
            WRITE(IPTRAJ,3075)
            DO I=1,NFRG
               WRITE(IPTRAJ,3030) WX(I)*VFACT, WY(I)*VFACT, WZ(I)*VFACT
            ENDDO
            WRITE(IPTRAJ,3080)
            DO I=1,NFRG
               WRITE(IPTRAJ,3040) QW1(I),QX1(I),QY1(I),QZ1(I)
            ENDDO
            WRITE(IPTRAJ,3090)
            DO I=1,NFRG
               WRITE(IPTRAJ,3040) QW2(I),QX2(I),QY2(I),QZ2(I)
            ENDDO
         ENDIF
      END IF
      WRITE(IPTRAJ,3095)
C
C        ask unix to flush its buffers to disk
C
      CALL FLSHBF(IW)
      CALL FLSHBF(IPTRAJ)
      RETURN
C
 1000 FORMAT(1X,'QM ATOM COORDINATES (ANG)')
 1005 FORMAT(1X,A8,A2,F5.1,3F15.10)
 1009 FORMAT(11X,'CARTESIAN COORDINATES (ANG)')
 1010 FORMAT(1X,'FRAGNAME=',A6,'  !',I4)
 1011 FORMAT(11X,'PBC CARTESIAN COORDINATES (ANG)')
 1020 FORMAT(1X,A8,7X,3F18.12)
C
 2000 FORMAT('===== MD DATA PACKET ====='/
     *       'NAT=',I8,' NFRG=',I8,' NQMMM=',I8/
     *       'TTOTAL=',F12.2,' FS    TOT. E=',F20.6,' KCAL/MOL'/
     *       'POT. E= ',F20.6,' KCAL/MOL  BATHT= ',F20.6/
     *       'KIN. E= ',F20.6,'  TRANS KE=',F11.6,
     *       '  ROT KE=',F11.6,' KCAL/MOL')
 2001 FORMAT('----- QM PARTICLE COORDINATES FOR $DATA GROUP -----')
 2002 FORMAT('----- EFP PARTICLE COORDINATES FOR $EFRAG GROUP -----')
 2010 FORMAT(A8,A2,F5.1,3F20.10)
 2012 FORMAT(' $EFRAG'/
     *       'COORD=CART ','POSITION=OPTIMIZE')
 2013 FORMAT(' $END')
 2020 FORMAT('FRAGNAME=',A6,'  !',I4)
 2030 FORMAT(A8,7X,3F20.10)
C
 3000 FORMAT('----- RESTART VELOCITIES FOR $MD GROUP -----'/
     *       ' $MD READ=.TRUE. MBT=.FALSE. MBR=.FALSE.',
     *       ' TTOTAL=',1P,E12.2,0P)
 3001 FORMAT(' MDINT= ',A8,4x,'DT= ',E8.2,' NVTNH= ',I1,2x,'NSTEPS=',I8)
 3002 FORMAT(' RSTEMP=',A3,1x,'DTEMP= ',F8.2, ' LEVERY=',I6)
 3003 FORMAT(' RSRAND=',A3,1x,'NRAND=',I6,1x,'NVTOFF=',I3,1x,
     *      'JEVERY=',I6)
 3004 FORMAT(' PROD=',A3,3x,'KEVERY=',I6,1x,'DELR=',F8.3)
 3005 format('Batht(1)=',F6.2)
 3010 FORMAT(' SSBP=.T.   SFORCE= ',F5.1,' DROFF=',2F5.1)
 3011 FORMAT(' USAMP=.T.  UFORCE(1)=',3F5.1/
     *     10x,'  RZERO(1)= ',3F5.1)
 3012 FORMAT(' ipair(1)=',2I3)
 3013 FORMAT(' ipair(1)=',4I3)
 3014 FORMAT(' ipair(1)=',3I3)
 3015 FORMAT(' ipair(1)=',6I3)
 3016 FORMAT(' ipair(1)=',9I3)
 3017 FORMAT(' ipair(1)=',12I3)
 3018 FORMAT(' IUSTYP=',I3)
 3019 FORMAT(' CCMS=.T.   CFORCE= ',F5.1)
 3020 FORMAT('TVELQM(1)=',5X,'! QM ATOM TRANS. VELOCITIES (BOHR/PS) !')
 3030 FORMAT(2X,1P,E16.9,2X,E16.9,2X,E16.9)
 3040 FORMAT(2X,1P,E16.9,2X,E16.9,2X,E16.9,2X,E16.9)
 3050 FORMAT('TVEL(1)=',5X,'! EFP TRANSLATIONAL VELOCITIES (BOHR/PS) !')
 3060 FORMAT('QUAT(1)=',5X,'! EFP QUATERNIONS !')
 3070 FORMAT('RMOM(1)=',5X,'! EFP ANGULAR MOMENTA (RAD/PS) !')
 3075 FORMAT('RVEL(1)=',5X,'! EFP ANGULAR VELOCITY (RAD/PS) !')
 3080 FORMAT('QUAT1D(1)=',5X,'! EFP QUATERNION 1ST DERIV. !')
 3090 FORMAT('QUAT2D(1)=',5X,'! EFP QUATERNION 2ND DERIV. !')
 3095 FORMAT(' $END')
      END
C
C*MODULE MDEFP   *DECK TEMPMD
      DOUBLE PRECISION FUNCTION TEMPMD(EK)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION MDTYP
C
      PARAMETER (MXFRG=1050, MXATM=2000,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /MDSIM / DT, BATHT, EKINT, EKINR, MDTYP
C
      DATA EFP /8HEFP     /
C
C        tempmd = 2.0d+00 * ek / (6.0d+00*nfrg-3.0d+00)
C     *          / 1.987216d-03
C--pre-IBM
C         tempmd = 2.0d+00 * ek / (6.0d+00*nfrg-6.0d+00)
C     *                 / 1.987216d-03
C
      IF(MDTYP.EQ.EFP) THEN
         TEMPMD = 2.0D+00 * EK / (6.0D+00*NFRG) / 1.987216D-03
      ELSE
         GFREE = 3.0D+00*NAT + 6.0D+00*NFRG
         TEMPMD = 2.0D+00 * EK / GFREE  / 1.987216D-03
      ENDIF
      RETURN
      END
C
C*MODULE MDEFP   *DECK CALCGR
      SUBROUTINE CALCGR
C        *********************************************************
C        *** calculate goo(r), goh(r), ghh(r) (for one pass)   ***
C        *********************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXFRG=1050, MXFGPT=12000,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (NBIN=1000,MAXRDF=100)
C
      DIMENSION INDG(3,3)
C
      CHARACTER*8 FRGNME
C
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /EFPPBC/ XBOX,YBOX,ZBOX,XCUT,YCUT,ZCUT,RCUT
     *                ,SWR1,SWR2,ISWF
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /GOFR  / GOFR(NBIN,3), GENFR(NBIN,MAXRDF), CCRDF(NBIN),
     *                GEN2FR(NBIN,2),
     *                DELR, NUMG, NUMSAM1,NUMSAM2,NUMSAM3
C
      DATA INDG/1, 2, 2, 2, 3, 3, 2, 3, 3 /
C
C        write(6,*) ' in calcgr'
C        write(6,*) ' delr=',delr
C---hmn
C        call efcm
C---hmn
        N = 0
         DO I = 1, NFRG
C          comx1=efcent(1,i)
C          comy1=efcent(2,i)
C          comz1 = efcent(3,i)
          M = 0
          DO J = 1, I
            M = M + NMPTS(J)
          ENDDO
          DO J = I+1, NFRG
C            comx2 = efcent(1,J)
C            comy2 = efcent(2,J)
C            comz2 = efcent(3,J)
C            comx = comx1 - comx2
C            comy = comy1 - comy2
C            comz = comz1 - comz2
C            pbcx = boxl * anint(comx * boxli)
C            pbcy = boxl * anint(comy * boxli)
C            pbcz = boxl * anint(comz * boxli)
C
            DO K = 1, 3
              DO L = 1, 3
                GRX = EFC( 1, N+K ) - EFC( 1, M+L )
                GRY = EFC( 2, N+K ) - EFC( 2, M+L )
                GRZ = EFC( 3, N+K ) - EFC( 3, M+L )
                GRX = GRX - XBOX * ANINT( GRX /XBOX )
                GRY = GRY - YBOX * ANINT( GRY /YBOX )
                GRZ = GRZ - ZBOX * ANINT( GRZ /ZBOX )
C                grx = grx - pbcx
C                gry = gry - pbcy
C                grz = grz - pbcz
                GRL = SQRT(GRX*GRX + GRY*GRY + GRZ*GRZ) * AU2ANG
C                if ( grl .le. 1.0d+00 ) then
C                  write(6,*) ' grl = ',grl
C                  write(6,*) ' i = ',i
C                  write(6,*) ' j = ',j
C                  write(6,*) ' n+k = ',n+k
C                  write(6,*) ' m+l = ',m+l
C                  call abrt
C                endif
                IBIN = INT ( GRL / DELR ) + 1
                IF ( IBIN .LE. NUMG ) THEN
                  INDEX = INDG( L, K )
                  GOFR( IBIN, INDEX ) = GOFR( IBIN, INDEX ) + 1.0D+00
                ENDIF
              ENDDO
            ENDDO
            M = M + NMPTS(J)
          ENDDO
          N = N + NMPTS(I)
        ENDDO
C
        NUMSAM1 = NUMSAM1 + 1
C
C        write(6,*) ' leaving calcgr'
C
        RETURN
        END
C
C*MODULE MDEFP   *DECK WRIGR
      SUBROUTINE WRIGR
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXFRG=1050, MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (NBIN=1000,MAXRDF=100)
C
      LOGICAL GOPARR, DSKWRK, MASWRK
C
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /EFPPBC/ XBOX,YBOX,ZBOX,XCUT,YCUT,ZCUT,RCUT
     *                ,SWR1,SWR2,ISWF
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /GOFR  / GOFR(NBIN,3), GENFR(NBIN,MAXRDF), CCRDF(NBIN),
     *                GEN2FR(NBIN,2),
     *                DELR, NUMG, NUMSAM1,NUMSAM2,NUMSAM3
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C        **************************
C        *** writes g(r)s to iw ***
C        **************************
C
      IF ( .NOT. MASWRK ) RETURN
C
      IF ( NUMSAM1 .EQ. 0 ) THEN
          WRITE(IW,3000)
          CALL ABRT
      ENDIF
C
      PI = ACOS(-1.0D+00)
      PREFAC = XBOX*YBOX*ZBOX/(2.0D+00*PI/3.0D+00)
      PREFAC = PREFAC / (NFRG*NFRG*NUMSAM1)
      PREFAC = PREFAC * AU2ANG * AU2ANG * AU2ANG
C
      DO I = 1, 3
          IF ( I .EQ. 1 ) THEN
            FAC2 = PREFAC
            WRITE(IW,4000)
          ELSE IF ( I .EQ. 2 ) THEN
            FAC2 = 0.25D+00 * PREFAC
            WRITE(IW,4010)
          ELSE
            FAC2 = 0.25D+00 * PREFAC
            WRITE(IW,4020)
          ENDIF
          R = 0.0D+00
          RUPPER = R + DELR
          DO J = 1, NUMG
            DIFF = RUPPER * RUPPER * RUPPER - R * R * R
            WRITE(IW,4030) R+DELR*0.5D+00, GOFR(J,I)*FAC2/DIFF
            R = RUPPER
            RUPPER = RUPPER + DELR
          ENDDO
      ENDDO
C
      CALL FLSHBF(IW)
      RETURN
C
 3000 FORMAT(/,1X,'*** TRYING TO WRITE G(R) WITH NUMSAM1=0! ***',/)
 4000 FORMAT(/,5X,'GOO(R)')
 4010 FORMAT(/,5X,'GOH(R)')
 4020 FORMAT(/,5X,'GHH(R)')
 4030 FORMAT(1X,F10.3,5X,E16.10)
      END
C
C
C*MODULE MDEFP   *DECK CCOMGR
      SUBROUTINE CCOMGR
C        *********************************************************
C        *** calculate g(COM-COM)(r)  ***
C        *********************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXFRG=1050, MXFGPT=12000,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (NBIN=1000,MAXRDF=100)
C
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /EFPPBC/ XBOX,YBOX,ZBOX,XCUT,YCUT,ZCUT,RCUT
     *                ,SWR1,SWR2,ISWF
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /GOFR  / GOFR(NBIN,3), GENFR(NBIN,MAXRDF), CCRDF(NBIN),
     *                GEN2FR(NBIN,2),
     *                DELR, NUMG, NUMSAM1,NUMSAM2,NUMSAM3
C
        CALL EFCM
        DO I = 1, NFRG
           COMX1=EFCENT(1,I)
           COMY1=EFCENT(2,I)
           COMZ1 = EFCENT(3,I)
           DO J = I+1, NFRG
              COMX2 = EFCENT(1,J)
              COMY2 = EFCENT(2,J)
              COMZ2 = EFCENT(3,J)
              COMX = COMX1 - COMX2
              COMY = COMY1 - COMY2
              COMZ = COMZ1 - COMZ2
C
              PBCX = XBOX * ANINT(COMX /XBOX)
              PBCY = YBOX * ANINT(COMY /YBOX)
              PBCZ = ZBOX * ANINT(COMZ /ZBOX)
C
              COMX = COMX - PBCX
              COMY = COMY - PBCY
              COMZ = COMZ - PBCZ
              COML = SQRT(COMX*COMX + COMY*COMY + COMZ*COMZ)*AU2ANG
C
              IBIN = INT ( COML / DELR ) + 1
              IF ( IBIN .LE. NUMG ) THEN
                CCRDF( IBIN ) = CCRDF( IBIN ) + 1.0D+00
              ENDIF
          ENDDO
        ENDDO
C
        NUMSAM2 = NUMSAM2 + 1
C
C        write(6,*) ' leaving calcgr'
C
        RETURN
        END
C
C*MODULE MDEFP   *DECK WRICOMGR
      SUBROUTINE WRICOMGR
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXFRG=1050, MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (NBIN=1000,MAXRDF=100)
C
      LOGICAL GOPARR, DSKWRK, MASWRK
C
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /EFPPBC/ XBOX,YBOX,ZBOX,XCUT,YCUT,ZCUT,RCUT
     *                ,SWR1,SWR2,ISWF
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /GOFR  / GOFR(NBIN,3), GENFR(NBIN,MAXRDF), CCRDF(NBIN),
     *                GEN2FR(NBIN,2),
     *                DELR, NUMG, NUMSAM1,NUMSAM2,NUMSAM3
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C        **************************
C        *** writes g(r)s to iw ***
C        **************************
C
      IF ( .NOT. MASWRK ) RETURN
C
      IF ( NUMSAM2 .EQ. 0 ) THEN
          WRITE(IW,3000)
          CALL ABRT
      ENDIF
C
      PI = ACOS(-1.0D+00)
      PREFAC = XBOX*YBOX*ZBOX/(2.0D+00*PI/3.0D+00)
      PREFAC = PREFAC / (NFRG*NFRG*NUMSAM2)
      PREFAC = PREFAC * AU2ANG * AU2ANG * AU2ANG
C
      WRITE(IW,4000)
      R = 0.0D+00
      RUPPER = R + DELR
      DO J = 1, NUMG
        DIFF = RUPPER * RUPPER * RUPPER - R * R * R
        WRITE(IW,4030) R+DELR*0.5D+00, CCRDF(J)*PREFAC/DIFF
        R = RUPPER
        RUPPER = RUPPER + DELR
      ENDDO
C
      CALL FLSHBF(IW)
      RETURN
C
 3000 FORMAT(/,1X,'*** TRYING TO WRITE G(R) WITH NUMSAM2=0! ***',/)
 4000 FORMAT(/,5X,'G(COM-COM)(R)')
 4030 FORMAT(1X,F10.3,5X,E16.10)
      END
C
C*MODULE MDEFP   *DECK RDFX
      SUBROUTINE RDFX
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL   AXEQ
      CHARACTER*6 FRGNAM, FRAG1, FRAG2
      CHARACTER*8 PTNAM
      CHARACTER*8 RDFNAME, WORD2, NAME
      PARAMETER (MAXRDF=100, MXPAIR=50)
      PARAMETER (MXFRG=1050, MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /RDFPAR/ NRDF,RDFNAME(MAXRDF),FRAG1(MAXRDF),FRAG2(MAXRDF),
     *                KOEFF(MAXRDF), NPAIR(MAXRDF),
     *                NATOM1(MXPAIR,MAXRDF),NATOM2(MXPAIR,MAXRDF),
     *                AXEQ, INFO_AXEQ(2),NFRG_RDF(MAXRDF,2)
C
C     things for printing axial and equatorial RDFs
      AXEQ = .FALSE.
      CALL VCLR(INFO_AXEQ,1,2)
C
C                  READS INPUT FOR $RDF GROUP
C
      IERR = 0
      IEOF = 0
      NRDF = 0
      CALL SEQREW(IR)
      CALL FNDGRP(IR,' $RDF   ',IEOF)
      IF(IEOF.NE.0) THEN
         IF(MASWRK) WRITE(IW,1000)
         RETURN
      ELSE
         IF(MASWRK) WRITE(IW,1010)
      END IF
C
      CALL RDCARD('$RDF    ',IEOF)
      IF(IEOF.EQ.1) THEN
         IF(MASWRK) WRITE(IW,*) 'END OF FILE LOOKING FOR $RDF GROUP'
         CALL ABRT
      END IF
 140  CONTINUE
      WORD2='        '
      LGSTR=-8
      CALL GSTRNG(WORD2,LGSTR)
      IF(WORD2.EQ.'        ') GO TO 145
C
      IF(WORD2.EQ.'NRDF    ') THEN
        NRDF = IFIND('NRDF    ',IERR)
        GO TO 140
      END IF
C
 145  CONTINUE
C
      DO I=1,NRDF
         IERR = 0
         IEOF = 0
C
         CALL RDCARD('RDRDFX  ',IEOF)
         IF(IEOF.EQ.1) THEN
            IF(MASWRK) WRITE(IW,*) 'END OF FILE READING RDF PARAMETERS'
            CALL ABRT
         END IF
C
         RDFNAME(I)='        '
         LGSTR=-8
         CALL GSTRNG(RDFNAME(I),LGSTR)
         IF(RDFNAME(I).EQ.'$END     ') THEN
            IF(MASWRK) WRITE(IW,*) 'PREMATURE END OF RDF GROUP'
            CALL ABRT
         END IF
C
         FRAG1(I)='      '
         LGSTR=-6
         CALL GSTRNG(FRAG1(I),LGSTR)
         ICHECK = 0
         DO J=1,NFRG
           IF (FRAG1(I).EQ.FRGNAM(J)) ICHECK = 1
         END DO
         IF (ICHECK .NE. 1) THEN
            IF(MASWRK) WRITE(IW,1050) FRAG1
            CALL ABRT
         END IF
C
         FRAG2(I)='      '
         LGSTR=-6
         CALL GSTRNG(FRAG2(I),LGSTR)
         ICHECK = 0
         DO J=1,NFRG
           IF (FRAG2(I).EQ.FRGNAM(J)) ICHECK = 1
         END DO
        IF (ICHECK .NE. 1) THEN
           IF(MASWRK) WRITE(IW,1050) FRAG2
            CALL ABRT
         END IF
C
         KOEFF(I) = IFIND('COEFF  ',IERR)
         IF(IERR.NE.0) THEN
            IF(MASWRK) WRITE(IW,*) 'RDRDFX: ERROR READING KOEFF'
            CALL ABRT
         END IF
C
C   ---- now reading pairs of atoms
         K = 1
  200    CONTINUE
         CALL RDCARD('RDRDFX2 ',IEOF)
         IF(IEOF.EQ.1) THEN
            IF(MASWRK) WRITE(IW,*) 'END OF FILE READING RDF ATOMS'
            CALL ABRT
         END IF
C
         NAME='        '
         LGSTR=-8
         CALL GSTRNG(NAME,LGSTR)
         IF (NAME.EQ. 'SPEC    ')  AXEQ = .TRUE.
         IF(NAME.EQ.'STOP    ') THEN
            NPAIR(I) = K-1
            GO TO 100
         END IF
C
         NATOM1(K,I) = IFIND('ATOM1  ',IERR)
         IF(IERR.NE.0) THEN
            IF(MASWRK) WRITE(IW,*) 'RDRDFX2: ERROR READING RDF ATOM1'
            CALL ABRT
         END IF
C
         NATOM2(K,I) = IFIND('ATOM2  ',IERR)
         IF(IERR.NE.0) THEN
            IF(MASWRK) WRITE(IW,*) 'RDRDFX2: ERROR READING RDF ATOM2'
            CALL ABRT
         END IF
C
         IF (AXEQ) THEN
            INFO_AXEQ(1)=I
            INFO_AXEQ(2)=K
         END IF
C
         K = K+1
         GO TO 200
C
  100    CONTINUE
       END DO
C
C   ---- now printing what we've read
C
      IF(MASWRK) THEN
       WRITE(IW,2000) NRDF
       DO I=1,NRDF
          WRITE(IW,2010) RDFNAME(I),FRAG1(I),FRAG2(I),KOEFF(I),NPAIR(I)
          DO K=1,NPAIR(I)
             WRITE(IW,2020) NATOM1(K,I),NATOM2(K,I)
          END DO
       END DO
       IF (AXEQ) WRITE(IW, 3000) INFO_AXEQ(1),INFO_AXEQ(2)
       END IF
C
 1000 FORMAT(/1X,'*** NO $RDF GROUP FOUND. CONTINUE...***')
 1010 FORMAT(/1X,'*** READING $RDF GROUP...***')
 1050 FORMAT(/1X,'*** IN $RDF GROUP: ',A8,' UNKNOWN NAME***')
C
 2000 FORMAT(/,1X,'PARAMETERS FOR RDFS: NRDF = ',I3)
 2010 FORMAT(/,1X,A8,' BETWEEN ',A6,' AND ',A6,
     *         1X,', SCALING COEFF = ',I3,' NPAIRS = ',I3)
 2020 FORMAT(1X,'RDF BETWEEN ATOMS ',I3,' AND ',I3)
 3000 FORMAT(1X,'EQUATORIAL AND AXIAL RDFS ARE REQUESTED IN GROUP ',I3,
     *         1X,' PAIR ',I3)
C
      RETURN
      END
C
C*MODULE MDEFP   *DECK C2GR
      SUBROUTINE C2GR
C        *********************************************************
C        *** calculate g(r) in general case  ***
C        *********************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXFRG=1050, MXFGPT=12000,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (MAXRDF=100, MXPAIR=50)
      PARAMETER (NBIN=1000)
C
      LOGICAL   AXEQ
      CHARACTER*6 FRGNAM, FRAG1, FRAG2
      CHARACTER*8 PTNAM,FRGNME,RDFNAME
C
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /EFPPBC/ XBOX,YBOX,ZBOX,XCUT,YCUT,ZCUT,RCUT
     *                ,SWR1,SWR2,ISWF
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /GOFR  / GOFR(NBIN,3), GENFR(NBIN,MAXRDF), CCRDF(NBIN),
     *                GEN2FR(NBIN,2),
     *                DELR, NUMG, NUMSAM1,NUMSAM2,NUMSAM3
      COMMON /RDFPAR/ NRDF,RDFNAME(MAXRDF),FRAG1(MAXRDF),FRAG2(MAXRDF),
     *                KOEFF(MAXRDF), NPAIR(MAXRDF),
     *                NATOM1(MXPAIR,MAXRDF),NATOM2(MXPAIR,MAXRDF),
     *                AXEQ, INFO_AXEQ(2),NFRG_RDF(MAXRDF,2)
C
       DIMENSION VEC1(3),VEC2(3),VEC3(3),PNORM(3)
C
       CALL EFCM
       DO 100 IRDF = 1,NRDF
       DO I = 1, NFRG
C          COMX1 = EFCENT(1,I)
C          COMY1 = EFCENT(2,I)
C          COMZ1 = EFCENT(3,I)
          ISWITCH = 0
          IF (FRGNAM(I) .NE. FRAG1(IRDF)) THEN
            IF  (FRGNAM(I) .NE. FRAG2(IRDF)) THEN
               GOTO 200
             ELSE
               ISWITCH = 1
             END IF
          END IF
C
          DO J = I+1, NFRG
             IF (ISWITCH .EQ. 1) THEN
                IF (FRGNAM(J) .NE. FRAG1(IRDF)) GOTO 300
             ELSE
                IF (FRGNAM(J) .NE. FRAG2(IRDF)) GOTO 300
             END IF
C
C
C            COMX2 = EFCENT(1,J)
C            COMY2 = EFCENT(2,J)
C            COMZ2 = EFCENT(3,J)
C
C            if (iswitch .eq. 0) then
C              COMX = COMX1 - COMX2
C              COMY = COMY1 - COMY2
C              COMZ = COMZ1 - COMZ2
C            else
C              COMX = -COMX1 + COMX2
C              COMY = -COMY1 + COMY2
C              COMZ = -COMZ1 + COMZ2
C            end if
C
C            PBCX = xbox * ANINT(COMX / xbox)
C            PBCY = ybox * ANINT(COMY / ybox)
C            PBCZ = zbox * ANINT(COMZ / zbox)
C
             IF (ISWITCH .EQ. 0) THEN
                 II = I
                 JJ = J
             ELSE
                 II = J
                 JJ = I
             END IF
C
             IC1 = LSTMPTS(II)-1
             IC2 = LSTMPTS(JJ)-1
C
C   -----  NATOM = 0 means COM
             DO IPAIR = 1,NPAIR(IRDF)
                IF (ISWITCH .EQ. 0) THEN
                   IF (NATOM1(IPAIR,IRDF) .GT. 0) THEN
                      IM = NATOM1(IPAIR,IRDF)
                   ELSE
                      IM = 0
                   END IF
                   IF (NATOM2(IPAIR,IRDF) .GT. 0) THEN
                      JM = NATOM2(IPAIR,IRDF)
                   ELSE
                      JM = 0
                   END IF
                ELSE
                   IF (NATOM1(IPAIR,IRDF) .GT. 0) THEN
                      JM = NATOM1(IPAIR,IRDF)
                   ELSE
                      JM = 0
                   END IF
                   IF (NATOM2(IPAIR,IRDF) .GT. 0) THEN
                      IM = NATOM2(IPAIR,IRDF)
                   ELSE
                      IM = 0
                   END IF
                END IF
C
                IF (IM.GT.0 .AND. JM.GT.0) THEN
                   GRX = EFC(1,IC1+IM) - EFC(1,IC2+JM)
                   GRY = EFC(2,IC1+IM) - EFC(2,IC2+JM)
                   GRZ = EFC(3,IC1+IM) - EFC(3,IC2+JM)
                ELSE
                   IF (IM.GT.0) THEN
                   GRX = EFC(1,IC1+IM) - EFCENT(1,JJ)
                   GRY = EFC(2,IC1+IM) - EFCENT(2,JJ)
                   GRZ = EFC(3,IC1+IM) - EFCENT(3,JJ)
                   END IF
                   IF (JM.GT.0) THEN
                   GRX = EFCENT(1,II) - EFC(1,IC2+JM)
                   GRY = EFCENT(2,II) - EFC(2,IC2+JM)
                   GRZ = EFCENT(3,II) - EFC(3,IC2+JM)
                   END IF
                   IF (IM.EQ.0 .AND. JM.EQ.0) THEN
                   GRX = EFCENT(1,II) - EFCENT(1,JJ)
                   GRY = EFCENT(2,II) - EFCENT(2,JJ)
                   GRZ = EFCENT(3,II) - EFCENT(3,JJ)
                   END IF
                END IF
                PBCX = XBOX * ANINT(GRX / XBOX)
                PBCY = YBOX * ANINT(GRY / YBOX)
                PBCZ = ZBOX * ANINT(GRZ / ZBOX)
                GRX = GRX - PBCX
                GRY = GRY - PBCY
                GRZ = GRZ - PBCZ
                GRL = SQRT(GRX*GRX + GRY*GRY + GRZ*GRZ) * AU2ANG
                IBIN = INT ( GRL / DELR ) + 1
                IF ( IBIN .LE. NUMG ) THEN
                   GENFR( IBIN, IRDF ) = GENFR( IBIN, IRDF )+1.0D+00
                END IF
C
C   ---- if want to separate into two regions: axial and equatorial
                IF (AXEQ .AND. INFO_AXEQ(1) .EQ. IRDF .AND.
     *              INFO_AXEQ(2) .EQ. IPAIR) THEN
                IF (ISWITCH.EQ.1) THEN
                   IX = IC2
                ELSE
                   IX = IC1
                END IF
                VEC1(1) = EFC(1,IX+3) - EFC(1,IX+1)
                VEC1(2) = EFC(2,IX+3) - EFC(2,IX+1)
                VEC1(3) = EFC(3,IX+3) - EFC(3,IX+1)
                VEC2(1) = EFCENT(1,II) - EFC(1,IX+1)
                VEC2(2) = EFCENT(2,II) - EFC(2,IX+1)
                VEC2(3) = EFCENT(3,II) - EFC(3,IX+1)
C
                CALL VECPRD(PNORM,VEC1,VEC2)
                SCALE = 1.0D+00/SQRT(DDOT(3,PNORM,1,PNORM,1))
                CALL DSCAL(3,SCALE,PNORM,1)
C
                VEC3(1)=EFCENT(1,JJ) - EFCENT(1,II)
                VEC3(2)=EFCENT(2,JJ) - EFCENT(2,II)
                VEC3(3)=EFCENT(3,JJ) - EFCENT(3,II)
                PBCX = XBOX * ANINT(VEC3(1) / XBOX)
                PBCY = YBOX * ANINT(VEC3(2) / YBOX)
                PBCZ = ZBOX * ANINT(VEC3(3) / ZBOX)
                VEC3(1)= VEC3(1) - PBCX
                VEC3(2)= VEC3(2) - PBCY
                VEC3(3)= VEC3(3) - PBCZ
                DIST = ABS(DDOT(3,PNORM,1,VEC3,1)) * AU2ANG
C
C                alpha = dasind(dist/GRL)
                ALPHA = ASIN(DIST/GRL)
                ALPHA = 180.0D+00/3.1415926535897932D+00
                ANGLE1 = 60.0D+00
                IF ( IBIN .LE. NUMG ) THEN
                IF (ALPHA.GT.ANGLE1) THEN
                   GEN2FR( IBIN, 1 ) = GEN2FR( IBIN, 1 )+1.0D+00
C                   KOUNT1 = KOUNT1 + 1
                ELSE
                   GEN2FR( IBIN, 2 ) = GEN2FR( IBIN, 2 )+1.0D+00
C                   KOUNT2 = KOUNT2 + 1
                END IF
                END IF
                ENDIF
C
              ENDDO
  300       CONTINUE
          ENDDO
  200     CONTINUE
        ENDDO
  100   CONTINUE
C
        NUMSAM3 = NUMSAM3 + 1
C
        RETURN
        END
C
C*MODULE MDEFP   *DECK WRIG2GR
      SUBROUTINE WRIG2GR
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (NBIN=1000)
      PARAMETER (MAXRDF=100, MXPAIR=50)
C
      CHARACTER*6 FRAG1, FRAG2
      CHARACTER*8 RDFNAME
C
      LOGICAL GOPARR, DSKWRK, MASWRK
      LOGICAL   AXEQ
C
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /EFPPBC/ XBOX,YBOX,ZBOX,XCUT,YCUT,ZCUT,RCUT
     *                ,SWR1,SWR2,ISWF
      COMMON /GOFR  / GOFR(NBIN,3), GENFR(NBIN,MAXRDF), CCRDF(NBIN),
     *                GEN2FR(NBIN,2),
     *                DELR, NUMG, NUMSAM1,NUMSAM2,NUMSAM3
      COMMON /RDFPAR/ NRDF,RDFNAME(MAXRDF),FRAG1(MAXRDF),FRAG2(MAXRDF),
     *                KOEFF(MAXRDF), NPAIR(MAXRDF),
     *                NATOM1(MXPAIR,MAXRDF),NATOM2(MXPAIR,MAXRDF),
     *                AXEQ, INFO_AXEQ(2),NFRG_RDF(MAXRDF,2)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C        **********************************
C        *** writes general g(r)s to iw ***
C        **********************************
C
      IF ( .NOT. MASWRK ) RETURN
C
      IF ( NUMSAM3 .EQ. 0 ) THEN
         WRITE(IW,3000)
         CALL ABRT
      ENDIF
C
      PI = ACOS(-1.0D+00)
      PREFAC = AU2ANG * AU2ANG * AU2ANG / NUMSAM3
      PREFAC2 = PREFAC * XBOX*YBOX*ZBOX/(2.0D+00*PI/3.0D+00)
C
C      angle1 = 60.0d+00
C      tang = tan((90.0d+00 - angle1)*pi/180)
C      VOL0 = XBOX*YBOX*ZBOX
C      VOL1 = XBOX*XBOX*XBOX*tang*tang*pi/12.0D+00
C
      DO IRDF = 1, NRDF
         FAC1 = KOEFF(IRDF)*NFRG_RDF(IRDF,1)*NFRG_RDF(IRDF,2)
         FAC2 =PREFAC2/FAC1
         WRITE(IW,4000) RDFNAME(IRDF)
         R = 0.0D+00
         RUPPER = R + DELR
         DO J = 1, NUMG
            DIFF = RUPPER * RUPPER * RUPPER - R * R * R
            WRITE(IW,4030) R+DELR*0.5D+00, GENFR(J,IRDF)*FAC2/DIFF
            R = RUPPER
            RUPPER = RUPPER + DELR
         ENDDO
C
         IF (AXEQ .AND. INFO_AXEQ(1) .EQ. IRDF) THEN
C             FAC2 = PREFAC2/FAC1*(vol1/vol0)
            WRITE(IW,4000) 'AXIAL'
            R = 0.0D+00
            RUPPER = R + DELR
            DO J = 1, NUMG
               DIFF = RUPPER * RUPPER * RUPPER - R * R * R
               WRITE(IW,4030) R+DELR*0.5D+00, GEN2FR(J,1)*FAC2/DIFF
               R = RUPPER
               RUPPER = RUPPER + DELR
            ENDDO
C
C             FAC2 = PREFAC2/FAC1*(vol0-vol1/vol0)
            WRITE(IW,4000) 'EQUATORIAL'
            R = 0.0D+00
            RUPPER = R + DELR
            DO J = 1, NUMG
               DIFF = RUPPER * RUPPER * RUPPER - R * R * R
C                DIFF = DIFF*(1.0d+00 - tang*tang/4.0d+00)
               WRITE(IW,4030) R+DELR*0.5D+00, GEN2FR(J,2)*FAC2/DIFF
               R = RUPPER
               RUPPER = RUPPER + DELR
            ENDDO
         END IF
      ENDDO
C
      CALL FLSHBF(IW)
      RETURN
C
 3000 FORMAT(/1X,'*** TRYING TO WRITE G(R) WITH NUMSAM3=0! ***',/)
 4000 FORMAT(/5X,'RDF FOR ',A8)
 4030 FORMAT(1X,F10.3,5X,F16.10)
      END
C
C*MODULE MDEFP   *DECK CALCDFRG
      SUBROUTINE CALCDFRG
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXFRG=1050, MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (MAXRDF=100, MXPAIR=50)
C
      LOGICAL   AXEQ
      CHARACTER*6 FRGNAM, FRAG1, FRAG2
      CHARACTER*8 PTNAM, RDFNAME
C
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /RDFPAR/ NRDF,RDFNAME(MAXRDF),FRAG1(MAXRDF),FRAG2(MAXRDF),
     *                KOEFF(MAXRDF), NPAIR(MAXRDF),
     *                NATOM1(MXPAIR,MAXRDF),NATOM2(MXPAIR,MAXRDF),
     *                AXEQ, INFO_AXEQ(2),NFRG_RDF(MAXRDF,2)
C
C        **************************
C        *** calculates number of different fragments for RDF count ***
C        **************************
C
      CALL VCLR(NFRG_RDF,1,MAXRDF*2)
      DO IRDF = 1, NRDF
          K1 = 0
          K2 = 0
          DO I = 1, NFRG
            IF (FRGNAM(I) .EQ. FRAG1(IRDF)) K1 = K1 + 1
            IF (FRGNAM(I) .EQ. FRAG2(IRDF)) K2 = K2 + 1
          END DO
          NFRG_RDF(IRDF,1)=K1
          NFRG_RDF(IRDF,2)=K2
      ENDDO
C
      RETURN
      END
C
C
C*MODULE MDEFP   *DECK MDNOSEINIT
      SUBROUTINE MDNOSEINIT
C     *********************
C     NVT NOSE HOOVER METHOD FOR VERLET VELOCITY METHOD
C     *********************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION MDTYP
C
      PARAMETER (MXFRG=1050, MXATM=2000,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /MDSIM / DT, BATHT, EKINT, EKINR, MDTYP
      COMMON /NOSEHO/ GNH(2),VNH(2),XNH(2),QNH(2),EKT0,GFREE0,NVTNH
C     EKT0 = k_B * TEMP
      EKT0 = 1.987216D-03 * BATHT / EK2KCAL
      GFREE0 = 3.0D+00 * NAT + 6.0D+00 * NFRG
C
      XNH(1) = 0.0D+00
      GNH(1) = 0.0D+00
      VNH(1) = 0.0D+00
      QNH(1) = GFREE0 * 10.0D+00 ! QMASS
      XNH(2) = 0.0D+00
      GNH(2) = 0.0D+00
      VNH(2) = 0.0D+00
      QNH(2) = GFREE0 * 10.0D+00 ! QMASS
C
C          0 : NVE, 1: NVT, 2: NOSE_HOOVER CHAIN NVT(?)
C      NVTNH = 2
      END
C
C*MODULE MDEFP   *DECK MDNOSEVV
      SUBROUTINE MDNOSEVV
C     *********************
C     NVT NOSE HOOVER METHOD FOR VERLET VELOCITY METHOD
C     HALF/FULL-STEP VELOCITY CORRECTION
C     *********************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION MDTYP
C
      PARAMETER (MXFRG=1050, MXATM=2000,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      COMMON /ATMDAT/ VX(MXFRG), VY(MXFRG), VZ(MXFRG),
     *                QW(MXFRG), QX(MXFRG), QY(MXFRG), QZ(MXFRG),
     *                OX(MXFRG), OY(MXFRG), OZ(MXFRG), QW1(MXFRG),
     *                QX1(MXFRG),QY1(MXFRG),QZ1(MXFRG),QW2(MXFRG),
     *                QX2(MXFRG),QY2(MXFRG),QZ2(MXFRG),
     *                VXQM(MXATM), VYQM(MXATM), VZQM(MXATM)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /MDSIM / DT, BATHT, EKINT, EKINR, MDTYP
      COMMON /MDVEL / WX(MXFRG),WY(MXFRG),WZ(MXFRG),TQI(3,MXFRG)
      COMMON /NOSEHO/ GNH(2),VNH(2),XNH(2),QNH(2),EKT0,GFREE0,NVTNH
C
      CALL MDKIN
C
      EKIN = EKINT + EKINR
C
C     =============
C
      IF (NVTNH.EQ.0) RETURN
C
      DT2 = DT / 2.0D+00
      DT4 = DT / 4.0D+00
      DT8 = DT / 8.0D+00
      SCALE = 1.0D+00
      IF (NVTNH.EQ.1) THEN
C     d VNH(t)/ dt = GNH(t) = (2 EKIN - GFREE * TEMP)/ QMASS
         GNH(1) = (2.0D+00*EKIN - GFREE0 * EKT0)/QNH(1)
C     VNT(t + dt/4) = VNT(t) + GNT(t) * dt/4
         VNH(1) = VNH(1) + GNH(1) * DT4
C     XNH(t+dt/2) = XNH(t) + VNT(t+dt/4)*dt/2
         XNH(1) = XNH(1) + VNH(1)*DT2
C     V(t) <= V(t) EXP(-VNH(t+dt/4)*dt/2)
         SCALE = EXP (-VNH(1)*DT2)
C
         EKIN  = EKIN  * SCALE*SCALE
         EKINT = EKINT * SCALE*SCALE
         EKINR = EKINR * SCALE*SCALE
C     GNH(t)
         GNH(1) = (2.0D+00*EKIN - GFREE0 * EKT0)/QNH(1)
C     VNH(t + dt/2) = VNH(t + dt/4) + GNH(t) * dt/4
         VNH(1) = VNH(1) + GNH(1) * DT4
      ELSE IF (NVTNH.EQ.2) THEN
C
         GNH(2) = (QNH(1)*VNH(1)*VNH(1)-EKT0)/QNH(2)
         VNH(2) = VNH(2) + GNH(2)*DT4
         VNH(1) = VNH(1) * EXP(-VNH(2)*DT8)
C     d VNH(t)/ dt = GNH(t) = (2 EKIN - GFREE * TEMP)/ QMASS
         GNH(1) = (2.0D+00*EKIN - GFREE0 * EKT0)/QNH(1)
C     VNT(t + dt/4) = VNT(t) + GNT(t) * dt/4
         VNH(1) = VNH(1) + GNH(1) * DT4
         VNH(1) = VNH(1) * EXP(-VNH(2)*DT8)
C     XNH(t+dt/2) = XNH(t) + VNT(t+dt/4)*dt/2
         XNH(1) = XNH(1) + VNH(1)*DT2
         XNH(2) = XNH(2) + VNH(2)*DT2
C     V(t) <= V(t) EXP(-VNH(t+dt/4)*dt/2)
         SCALE = EXP (-VNH(1)*DT2)
C
         EKIN = EKIN * SCALE * SCALE
         EKINT= EKINT* SCALE * SCALE
         EKINR= EKINR* SCALE * SCALE
C
         VNH(1) = VNH(1)*EXP(-VNH(2)*DT8)
C     GNH(t)
         GNH(1) = (2.0D+00*EKIN - GFREE0 * EKT0)/QNH(1)
C     VNH(t + dt/2) = VNH(t + dt/4) + GNH(t) * dt/4
         VNH(1) = VNH(1) + GNH(1) * DT4
         VNH(1) = VNH(1)*EXP(-VNH(2)*DT8)
C
         GNH(2) = (QNH(1)*VNH(1)*VNH(1)-EKT0)/QNH(2)
         VNH(2) = VNH(2) + GNH(2)*DT4
      END IF
C
      DO I = 1, NAT
         VXQM(I) = VXQM(I) * SCALE
         VYQM(I) = VYQM(I) * SCALE
         VZQM(I) = VZQM(I) * SCALE
      END DO
C
      DO I = 1, NFRG
         VX(I) = VX(I) * SCALE
         VY(I) = VY(I) * SCALE
         VZ(I) = VZ(I) * SCALE
         WX(I) = WX(I) * SCALE
         WY(I) = WY(I) * SCALE
         WZ(I) = WZ(I) * SCALE
      END DO
C
      RETURN
C
      END
C
C*MODULE MDEFP   *DECK VELOCITY_RESCALE
      SUBROUTINE VELOCITY_RESCALE
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION MDTYP
C
      PARAMETER (MXFGPT=12000, MXFRG=1050, MXATM=2000,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      COMMON /ATMDAT/ VX(MXFRG), VY(MXFRG), VZ(MXFRG),
     *                QW(MXFRG), QX(MXFRG), QY(MXFRG), QZ(MXFRG),
     *                OX(MXFRG), OY(MXFRG), OZ(MXFRG), QW1(MXFRG),
     *                QX1(MXFRG),QY1(MXFRG),QZ1(MXFRG),QW2(MXFRG),
     *                QX2(MXFRG),QY2(MXFRG),QZ2(MXFRG),
     *                VXQM(MXATM), VYQM(MXATM), VZQM(MXATM)
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /MASSES/ ZMASS(MXATM)
      COMMON /MDSIM / DT, BATHT, EKINT, EKINR, MDTYP
      COMMON /MDVEL / WX(MXFRG),WY(MXFRG),WZ(MXFRG),TQI(3,MXFRG)
      COMMON /MODDAT/ AMOM(3,MXDFG), TOTMAS(MXDFG), TOTMAI(MXDFG),
     *                DRX(MXFGPT), DRY(MXFGPT), DRZ(MXFGPT)
      COMMON /NOSEHO/ GNH(2),VNH(2),XNH(2),QNH(2),EKT0,GFREE0,NVTNH
C
      EKINT = 0.0D+00
      EKINR = 0.0D+00
      PX    = 0.0D+00 ! LINEAR MOMENTUM OF TRANSLATIONAL MOTIONS.
      PY    = 0.0D+00
      PZ    = 0.0D+00
      DO I = 1, NAT
         PX    = PX + ZMASS(I)*VXQM(I)
         PY    = PY + ZMASS(I)*VYQM(I)
         PZ    = PZ + ZMASS(I)*VZQM(I)
      ENDDO
C
      DO I=1,NFRG
         PX    = PX + TOTMAS(ISET(I))*VX(I)
         PY    = PY + TOTMAS(ISET(I))*VY(I)
         PZ    = PZ + TOTMAS(ISET(I))*VZ(I)
      ENDDO
C
      GFREE = NAT + NFRG
C
      PX = PX / GFREE
      PY = PY / GFREE
      PZ = PZ / GFREE
C     SET TOTAL LINEAR MOMENTUM TO BE ZERO
      DO I = 1, NAT
         ZMASSI = 1.0D+00 / ZMASS(I)
         VXQM(I) = VXQM(I) - PX * ZMASSI
         VYQM(I) = VYQM(I) - PY * ZMASSI
         VZQM(I) = VZQM(I) - PZ * ZMASSI
         EKINT = EKINT + ZMASS(I)*(VXQM(I)**2 + VYQM(I)**2 + VZQM(I)**2)
      END DO
C
      DO I=1,NFRG
        ZMASSI = 1.0D+00/TOTMAS(ISET(I))
        VX(I) = VX(I) - PX * ZMASSI
        VY(I) = VY(I) - PY * ZMASSI
        VZ(I) = VZ(I) - PZ * ZMASSI
        EKINT = EKINT + TOTMAS(ISET(I))*(VX(I)**2 + VY(I)**2 + VZ(I)**2)
        EKINR = EKINR + AMOM(1,ISET(I))* WX(I)**2 + AMOM(2,ISET(I))
     *       * WY(I)**2 + AMOM(3,ISET(I)) * WZ(I)**2
      END DO
C
      GFREE = 3.0D+00 * NAT + 3.0D+00 * NFRG
      SCALE1 = SQRT(GFREE*EKT0/EKINT)
      IF(NFRG.GT.0) SCALE2 = SQRT(3.0D+00*NFRG*EKT0/EKINR)
C
      EKINT = 0.0D+00
      EKINR = 0.0D+00
C
      DO I = 1, NAT
         VXQM(I) = VXQM(I)*SCALE1
         VYQM(I) = VYQM(I)*SCALE1
         VZQM(I) = VZQM(I)*SCALE1
         EKINT = EKINT + ZMASS(I)*(VXQM(I)**2 + VYQM(I)**2 + VZQM(I)**2)
      END DO
C
      DO I = 1, NFRG
         VX(I) = VX(I)*SCALE1
         VY(I) = VY(I)*SCALE1
         VZ(I) = VZ(I)*SCALE1
         WX(I) = WX(I)*SCALE2
         WY(I) = WY(I)*SCALE2
         WZ(I) = WZ(I)*SCALE2
        EKINT = EKINT + TOTMAS(ISET(I))*(VX(I)**2 + VY(I)**2 + VZ(I)**2)
        EKINR = EKINR + AMOM(1,ISET(I))* WX(I)**2 + AMOM(2,ISET(I))
     *       * WY(I)**2 + AMOM(3,ISET(I)) * WZ(I)**2
      END DO
C
      EKINT = 0.5D+00 * EK2KCAL * EKINT
      EKINR = 0.5D+00 * EK2KCAL * EKINR
C
      RETURN
      END
C
C*MODULE MDEFP   *DECK DIFFSN
       SUBROUTINE DIFFSN(KOUNT)
C********************************************************************
C Calculates the Diffusion, using a time correlation function
C********************************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXFRG=1050, MXDFG=5,
     *           MXDPPT=MXFRG*MXDFG*12, MXATM=2000 )
C
      COMMON /ATMDAT/ VX(MXFRG), VY(MXFRG), VZ(MXFRG),
     *                QW(MXFRG), QX(MXFRG), QY(MXFRG), QZ(MXFRG),
     *                OX(MXFRG), OY(MXFRG), OZ(MXFRG), QW1(MXFRG),
     *                QX1(MXFRG),QY1(MXFRG),QZ1(MXFRG),QW2(MXFRG),
     *                QX2(MXFRG),QY2(MXFRG),QZ2(MXFRG),
     *                VXQM(MXATM), VYQM(MXATM), VZQM(MXATM)
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /MDSIM6/ DIFFU,PRESSA,DBT,GK,E0,DHV,HM0,HM20,
     *                HMU2,HMT,HM0T,VECX,P2,P3,P4,P5,P6,ANC,EX,
     *                HB,HC,HN,HDCDT,CT,ANT,DCDT,HBLIFT,GGK,HM2TT2,
     *                VIRA,EKA,HMU,MGR,MH0
      COMMON /MDSIM7/ VXO(MXFRG), VYO(MXFRG), VZO(MXFRG),
     *                WXO(MXFRG), WYO(MXFRG), WZO(MXFRG)
C
      IF( KOUNT.EQ.1 ) THEN
      DIFFU = 0.00D+00
      ENDIF
      DIFFUJ = 0.00D+00
      DFACT = AU2ANG * 1.00D-12
      B = 0.333333D+00
C
       DO 200 N = 1, NFRG
        DIFFUJ =  DIFFUJ + (
     *               ( ((VX(N)*DFACT)*(VXO(N)*DFACT)) ) +
     *               ( ((VY(N)*DFACT)*(VYO(N)*DFACT)) ) +
     *               ( ((VZ(N)*DFACT)*(VZO(N)*DFACT)) ) )
 200   CONTINUE
C            DIFFU  =  DIFFU + (DIFFUJ / NFRG)*B
             DIFFU  =  DIFFU + DIFFUJ *B
      END
C
C*MODULE MDEFP   *DECK PRESUR
       SUBROUTINE PRESUR(KOUNT)
C********************************************************************
C Calculates the Pressure.
C See Computer Simulations of Liquids. M.P. Allen, D.J. Tildesley.
C ISBN 0198556454  pg.47
C********************************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      COMMON /MDSIM6/ DIFFU,PRESSA,DBT,GK,E0,DHV,HM0,HM20,
     *                HMU2,HMT,HM0T,VECX,P2,P3,P4,P5,P6,ANC,EX,
     *                HB,HC,HN,HDCDT,CT,ANT,DCDT,HBLIFT,GGK,HM2TT2,
     *                VIRA,EKA,HMU,MGR,MH0
      COMMON /VIRPR / VIR(3), PRXX, PRYY, PRZZ
C
      IF(KOUNT.EQ.1) THEN
         PRESSA = 0.00D+00
         EKA  = 0.00D+00
         VIRA  = 0.00D+00
      ENDIF
C
      PINT = (PRXX+PRYY+PRZZ)/3.0D+00
      PRESSA = PRESSA + PINT
C
      RETURN
      END
C
C*MODULE MDEFP   *DECK DIPPRP
       SUBROUTINE DIPPRP(KOUNT)
C********************************************************************
C*** CALCULATES VARIOUS DIPOLE/QUADRAPOLAR AND OCTAPOLE PROPERTIES***
C********************************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXFRG=1050, MXFGPT=12000,
     *           MXDFG=5,
     *           MXDPPT=MXFRG*MXDFG*12, MXIFRQ=12)
C
      CHARACTER*8 POLNAM,DPOLNAM,FRGNME
      DOUBLE PRECISION MDTYP
C
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ*MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /EFPPBC/ XBOX,YBOX,ZBOX,XCUT,YCUT,ZCUT,RCUT
     *                ,SWR1,SWR2,ISWF
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /MDSIM / DT, BATHT, EKINT, EKINR, MDTYP
      COMMON /MDSIM6/ DIFFU,PRESSA,DBT,GK,E0,DHV,HM0,HM20,
     *                HMU2,HMT,HM0T,VECX,P2,P3,P4,P5,P6,ANC,EX,
     *                HB,HC,HN,HDCDT,CT,ANT,DCDT,HBLIFT,GGK,HM2TT2,
     *                VIRA,EKA,HMU,MGR,MH0
C      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
C     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
C     *                NDPTS(MXFRG),NDTTPT
C
C      MU      identity if 
C      DM       of the system
C      HMU2   <^2> of MU
C      HM0    M(0)   SUM of Dipoles @ Time=0
C      HM20   <M^2(0)>
C      HMT    M(t)   SUM of Dipoles @ Time=t
C      HM2T   <M^2(t)>
C      HMT2   <M(t)>^2
C      NFRAG NUMBER OF FRAGMENTS
C      hpi    3.14159
C      HKB  Boltzmann constant        1.380 6504 e-23        J K^-1
C      boxl  box length
C      E    potential energy
C
      AU2M = 5.29177249D-11
C  DEBEYE to Coulumb*Meter
      D2CM = 3.335640D-30
C Free Permativity
      E0V = 8.854187817D-12
C Atomic Dipole to Coulumb*Meter
C      AUEDM2CM = 8.47835309D-30
C      HM2B=1.889725989D+10
C   FARADAY's CONSTANT
C      FARC = 96485.341D+00
      PI = ACOS(-1.0D+00)
      HKB = 1.3806504D-23
      EKIN = EKINT + EKINR
      DMX = 0.00D+00
      DMY = 0.00D+00
      DMZ = 0.00D+00
      DMUX = 0.00D+00
      DMUY = 0.00D+00
      DMUZ = 0.00D+00
      HMUI = 0.00D+00
      HMTI = 0.00D+00
      IF (KOUNT.EQ.1) THEN
          HM0    = 0.00D+00
          HM20   = 0.00D+00
          HM0T   = 0.00D+00
          HMU    = 0.00D+00
          HMU2   = 0.00D+00
          HM2TT2 = 0.00D+00
      ENDIF
C
      L=1
      LL=1
      DO M = 1,NFRG
       DO J = L , L + NMPTS(M) - 1
       DMX = DMX + EFDIP(1,J) + DIND(1,J) + DINDD(1,J)
       DMY = DMY + EFDIP(2,J) + DIND(2,J) + DINDD(2,J)
       DMZ = DMZ + EFDIP(3,J) + DIND(3,J) + DINDD(3,J)
       ENDDO
       L= L + NMPTS(M)
      ENDDO
      DO I = 1,NMPTS(LL)
       DMUX = DMUX + EFDIP(1,I) + DIND(1,I) + DINDD(1,I)
       DMUY = DMUY + EFDIP(2,I) + DIND(2,I) + DINDD(2,I)
       DMUZ = DMUZ + EFDIP(3,I) + DIND(3,I) + DINDD(3,I)
      ENDDO
      IF (KOUNT.EQ.1) THEN
      HM20  = (DMX**2+DMY**2+DMZ**2)
      HM0   = HM20**0.50D+00
      ELSE
       HMTI = (DMX**2+DMY**2+DMZ**2)**0.50D+00
       HMUI = (DMUX**2+DMUY**2+DMUZ**2)**0.50D+00
C COLLECT AND Average OVER TIME
C       HMU =  ( HMU + (HMT/NFRG) ) / KOUNT
       HMU  = HMU + HMUI
       HMU2 = HMU2 + HMUI*HMUI
       HMT  = HMT + HMTI
       HM0T = HM0T + HMT*HM0
       HM2TT2 =   (HMT**2/KOUNT) - (HMT/KOUNT)**2
C       E0M = E0M + (HM2T/KOUNT)*AUEDM2CM - ((HMT2/KOUNT)**2)*AUEDM2CM
      ENDIF
C  ONLY CALC THESE FOR AFTER KOUNT=1
      IF (KOUNT.GT.1) THEN
C Total Dipole Moment Correlation function for
C  Debeye Relaxation Time Calculation
      DBT = ( ( (HM0T/KOUNT) - (HMT/KOUNT)**2) /
     *             ( HM20 - (HMT/KOUNT)**2) )
C Finite Kirwood Systems
      GK =  HM2TT2 / (NFRG*(HMU2/KOUNT))
C relative permativity
C      E0=( 1+( (4*PI)/(3*(XBOX*YBOX*ZBOX*AU2M*AU2M*AU2M)*Hkb
C     *      *TEMPMD(EKIN)) )*(HMTT2*AUEDM2CM*AUEDM2CM) )/E0V
C       TEMP1=HM2TT2*AUEDM2CM*AUEDM2CM
       TEMP1=HM2TT2*D2CM*D2CM
C      TEMP3=(HMTT2/KOUNT)*AUEDM2CM*AUEDM2CM
      TEMP2=1+( (4*PI)/(3*(XBOX*YBOX*ZBOX*AU2M*AU2M*AU2M)*HKB
     *      *TEMPMD(EKIN)) )
      E0=(TEMP1*TEMP2)/E0V
C
C INFINITE KIRKWOOD FACTOR
      GGK = ( (2* E0 +1) / (3* E0) ) * GK
C
      ENDIF
C
C      WRITE(6,*)'D1=',EFDIP(1,7),'D2=',DIND(1,1),'D3=',DINDD(1,1)
C      WRITE(6,*)'DMX=',DMX,'DMY=',DMY,'DMZ=',DMZ,'ZBOX=',ZBOX
C      WRITE(6,*)'DMUX=',DMUX,'DMUY=',DMUY,'DMUZ=',DMUZ
C      WRITE(6,*)'HM20=',HM20,'HM0=',HM0,'HMUI',HMUI,'HMT',HMT
C      WRITE(6,*)'HMU=',HMU/KOUNT,'HMU2=',HMU2/KOUNT,'E0TEMP',E0TEMP
C      WRITE(6,*)'HM2T=',HM2T/KOUNT,'HMT2',(HMT2/KOUNT)**2,'E0M',E0M
C      WRITE(6,*)'ZBOX=',ZBOX,'AU2M=',AU2M,'AUEDM2CM=',AUEDM2CM
C      WRITE(6,*)'HMT=',HMT,'HMT=',HMT/KOUNT,'KOUNT',KOUNT
C      WRITE(6,*)'HM2TT2=',HM2TT2,'HM2TT2=',HM2TT2/KOUNT,'KOUNT',KOUNT
C      WRITE(6,*)'PI=',PI,'TEMP=',TEMPMD(EKIN),'Hkb=',Hkb
C      WRITE(6,*)'TEMP1=',TEMP1,'TEMP2=',TEMP2,'TEMP3=',TEMP3,'K',KOUNT
C      WRITE(6,*)'TEMP4=',TEMP4,'TEMP5=',TEMP5,'E0V',E0V,'KOUNT',KOUNT
C      WRITE(6,*)'GGK=',GGK,'E0=',E0,'GK=',GK,'DBT=',DBT,'KOUNT',KOUNT
      END
C*MODULE MDEFP   *DECK HVAP
       SUBROUTINE HVAP(KOUNT)
C********************************************************************
C***      CALCULATES THE APPROXIMATE HEAT OF VAPORIZATION         ***
C********************************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXFRG=1050,MXDFG=5,
     *           MXDPPT=MXFRG*MXDFG*12  )
C
      DOUBLE PRECISION MDTYP
C
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /MDSIM / DT, BATHT, EKINT, EKINR, MDTYP
      COMMON /MDSIM6/ DIFFU,PRESSA,DBT,GK,E0,DHV,HM0,HM20,
     *                HMU2,HMT,HM0T,VECX,P2,P3,P4,P5,P6,ANC,EX,
     *                HB,HC,HN,HDCDT,CT,ANT,DCDT,HBLIFT,GGK,HM2TT2,
     *                VIRA,EKA,HMU,MGR,MH0
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FUNCT / E, EG(3*MXATM)
C
C delta H vap ~ -<E>+RT
C
C  DHV = delta H vap | E = potential energy in hartree
C  R = gas constant 8.314 472(15) J mol-1 K-1
C  T = Temperature (Kelvin)
C  EX = pot. energy in J | AU2JOULE 1 hartree = 4.35974394(22)D-18 J
C
      R = 0.00198588D+00 ! KCAL / MOLE
      EKIN = EKINT + EKINR
      EX = EX + E
C
      DHV = -1.00D+00 *( EX*AU2KCAL / (KOUNT*NFRG))+ R*TEMPMD(EKIN)
C      WRITE(6,*)'E',E,'EX',EX,'DHV',DHV,'TEMP',TEMPMD(EKIN)
C
      END
C*MODULE MDEFP   *DECK INIPRP
       SUBROUTINE INIPRP
C ********************************************************************
C ***   Initialize Property Terms                                  ***
C ********************************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      COMMON /MDSIM6/ DIFFU,PRESSA,DBT,GK,E0,DHV,HM0,HM20,
     *                HMU2,HMT,HM0T,VECX,P2,P3,P4,P5,P6,ANC,EX,
     *                HB,HC,HN,HDCDT,CT,ANT,DCDT,HBLIFT,GGK,HM2TT2,
     *                VIRA,EKA,HMU,MGR,MH0
C
      DIFFU  = 0.00D+00
      PRESSA = 0.00D+00
      DBT    = 0.00D+00
      GK     = 0.00D+00
      E0     = 0.00D+00
      DHV    = 0.00D+00
      VECX   = 0.00D+00
      P2     = 0.00D+00
      P3     = 0.00D+00
      P4     = 0.00D+00
      P5     = 0.00D+00
      P6     = 0.00D+00
      ANC    = 0.00D+00
      EX    = 0.00D+00
      HB    = 0.00D+00
      HC    = 0.00D+00
      HN    = 0.00D+00
      HDCDT  = 0.00D+00
      CT     = 0.00D+00
      ANT    = 0.00D+00
      DCDT   = 0.00D+00
      HM0     = 0.00D+00
      HM20    = 0.00D+00
      HMT     = 0.00D+00
      HMU2    = 0.00D+00
      HM0T    = 0.00D+00
      HM2TT2    = 0.00D+00
      HBLIFT    = 0.00D+00
      GGK     = 0.00D+00
C JMM 2
C      VIR(1) = 0.00D+00
C      VIR(2) = 0.00D+00
C      VIR(3) = 0.00D+00
C JMM 2
      END
C*MODULE MDEFP   *DECK ROTRELAX
       SUBROUTINE ROTRELAX(KOUNT)
C        SUBROUTINE ROTRELAX
C ********************************************************************
C ***   Calculate the Rotation Relaxation time                     ***
C ***   AT THIS TIME THIS ROUTINE COULD USE SOME TLC               ***
C ********************************************************************
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXFRG=1050)
      PARAMETER (MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /MDSIM6/ DIFFU,PRESSA,DBT,GK,E0,DHV,HM0,HM20,
     *                HMU2,HMT,HM0T,VECX,P2,P3,P4,P5,P6,ANC,EX,
     *                HB,HC,HN,HDCDT,CT,ANT,DCDT,HBLIFT,GGK,HM2TT2,
     *                VIRA,EKA,HMU,MGR,MH0
      COMMON /MDVEL / WX(MXFRG),WY(MXFRG),WZ(MXFRG),TQI(3,MXFRG)
      COMMON /MDSIM7/ VXO(MXFRG), VYO(MXFRG), VZO(MXFRG),
     *                WXO(MXFRG), WYO(MXFRG), WZO(MXFRG)
C
C    The legendra polynomials are listed as P1-6
C    ANGULAR VECLOCITY at time T is VECT
C    ANGULAR VECLOCITY at time 0 is VEC0
C    VECX is the X in the legendre polynomial definitions.
C
       VECI  = 0.00D+00
       VECIX = 0.00D+00
       VECIY = 0.00D+00
       VECIZ = 0.00D+00
       VECIXO = 0.00D+00
       VECIYO = 0.00D+00
       VECIZO = 0.00D+00
C
      DO 100 I=1,NFRG
C            VECI = VECI + (VECT*VEC0)/(ABS(VECT)*ABS(VEC0))
C       VECI = VECI + ( ((WX(I)**2+ WY(I)**2+ WZ(I)**2)**0.50D+00)*
C     *                 ((WXO(I)**2+WYO(I)**2+WZO(I)**2)**0.50D+00) )/
C     *            (ABS ((WX(I)**2+ WY(I)**2+ WZ(I)**2)**0.50D+00)*
C     *             ABS ((WXO(I)**2+WYO(I)**2+WZO(I)**2)**0.50D+00) )
      VECIX = VECIX + WX(I)
      VECIY = VECIY + WY(I)
      VECIZ = VECIZ + WZ(I)
      VECIXO = VECIX + WXO(I)
      VECIYO = VECIY + WYO(I)
      VECIZO = VECIZ + WZO(I)
C      WRITE(6,*)'WX=',WX(I),'WY=',WY(I),'WZ=',WZ(I)
C      WRITE(6,*)'WX0=',WXO(I),'WY0=',WYO(I),'WZ0=',WZO(I)
 100  CONTINUE
C      WRITE(6,*)'VECIX=',VECIX,'VECIY=',VECIY,'VECIZ=',VECIZ
C      WRITE(6,*)'VECIXO=',VECIXO,'VECIYO=',VECIYO,'VECIZO=',VECIZO
      VECI = (VECIX+VECIY+VECIZ)*(VECIXO+VECIYO+VECIZO) /
     *       (ABS(VECIX+VECIY+VECIZ)*ABS(VECIXO+VECIYO+VECIZO))
      VECX = VECX + VECI
      VECXX= VECX / KOUNT
C  P0(x) = 1
C  P1(x) = X
C  P2(x) = (3*X^2 - 1)/2
      P2 = (3*VECXX*VECXX-1)/2
C  P3(x) = (5*X^3 - 3*X)/2
      P3= (5*VECXX*VECXX*VECXX - 3*VECXX)/2
C  P4(x) = (35*X^4 - 30*X^2 + 3)/8
      P4 = (35*VECXX*VECXX*VECXX*VECXX - 30*VECXX*VECXX + 3) / 8
C  P5(x) = (63*X^5 - 70*X^3 + 15*X)/8
      P5 = (63*VECXX*VECXX*VECXX*VECXX*VECXX -
     *       70*VECXX*VECXX*VECXX + 15*VECXX)/8
C  P6(x) = (231*X^6 - 315*X^4 + 10*X^2 - 5 )/16
      P6 = (231*VECXX*VECXX*VECXX*VECXX*VECXX*VECXX -
     *      315*VECXX*VECXX*VECXX*VECXX + 10*VECXX*VECXX - 5)/16
C
C      WRITE(6,*)'VECX=',VECX,'P2=',P2,'P3=',P3,'KOUNT',KOUNT
C      WRITE(6,*)'P4=',P4,'P5=',P5,'P6=',P6
      END
C*MODULE MDEFP   *DECK CRDNMB
C>
C>     @brief   Calculate the Coordination Number from g(r)
C>
C>     @details Calculate the Coordination Number from g(r)
C>
C>     @author  unknown
C>
      SUBROUTINE CRDNMB(KOUNT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (NBIN=1000)
      PARAMETER (MXFRG=1050)
      PARAMETER (MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (MAXRDF=100, MXPAIR=50)
C
      LOGICAL   AXEQ
      LOGICAL PRESSR,DIFUSN,DIPOLEP,HTVAP,COORDN,RRELAX,HBLFE
C
      CHARACTER*6  FRAG1, FRAG2
      CHARACTER*8  RDFNAME
C
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /EFPPBC/ XBOX,YBOX,ZBOX,XCUT,YCUT,ZCUT,RCUT
     *                ,SWR1,SWR2,ISWF
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /GOFR  / GOFR(NBIN,3), GENFR(NBIN,MAXRDF), CCRDF(NBIN),
     *                GEN2FR(NBIN,2),
     *                DELR, NUMG, NUMSAM1,NUMSAM2,NUMSAM3
      COMMON /MDSIM6/ DIFFU,PRESSA,DBT,GK,E0,DHV,HM0,HM20,
     *                HMU2,HMT,HM0T,VECX,P2,P3,P4,P5,P6,ANC,EX,
     *                HB,HC,HN,HDCDT,CT,ANT,DCDT,HBLIFT,GGK,HM2TT2,
     *                VIRA,EKA,HMU,MGR,MH0
      COMMON /MDSIM8/ PRESSR,DIFUSN,DIPOLEP,HTVAP,COORDN,
     *                RRELAX,HBLFE
      COMMON /RDFPAR/ NRDF,RDFNAME(MAXRDF),FRAG1(MAXRDF),FRAG2(MAXRDF),
     *                KOEFF(MAXRDF), NPAIR(MAXRDF),
     *                NATOM1(MXPAIR,MAXRDF),NATOM2(MXPAIR,MAXRDF),
     *                AXEQ, INFO_AXEQ(2),NFRG_RDF(MAXRDF,2)
C
C *******************************************************
C ***   Calculate the Coordination Number from g(r)   ***
C *******************************************************
C
C     RCORD IS IN ANGSTROMS
      RCOORD=3.30D+00
      ANCI=0.00D+00
      FAC2=0.00D+00
      DIFF=0.00D+00
      PI = ACOS(-1.0D+00)
C
      PREFAC = XBOX*YBOX*ZBOX/(2.0D+00*PI/3.0D+00)
      PREFAC = PREFAC / (NFRG*NFRG*NUMSAM1)
      PREFAC = PREFAC * AU2ANG * AU2ANG * AU2ANG
C
      NCOUNT = INT (RCOORD/DELR) + 1
C
      KKOUNT=0
      R = 0.0D+00
      RUPPER = R + DELR
C DECIDE WHICH GR WE ARE USING
      IF ( NUMSAM1 .GT. 0 ) THEN
         FAC2 =  PREFAC
C              GO TO 90
           IF( MGR.GE.2) THEN
              FAC2 =0.25D+00 * PREFAC
              GO TO 90
           ENDIF
      ELSE IF ( NUMSAM2 .GT. 0 ) THEN
          GO TO 110
      ELSE IF ( NUMSAM3 .GT. 0 ) THEN
          FAC2 = PREFAC/KOEFF(MGR)
       GO TO 210
       ELSE
        WRITE(6,*)"CALCULATION OF THE COORDINATION # REQUIRES A G(R)"
C         CALL ABRT
          COORDN = .FALSE.
          RETURN
       ENDIF
 90   CONTINUE
      DO 100 I=1,NCOUNT
       DIFF = RUPPER * RUPPER * RUPPER - R * R * R
       ANCI = ANCI + (R+DELR*0.50D+00)**2*GOFR(I,MGR)*FAC2/DIFF
        IF (GOFR(I,MGR)*FAC2/DIFF.NE.0.0D+00) THEN
          KKOUNT = KKOUNT + 1
        ENDIF
       R = RUPPER
       RUPPER = RUPPER + DELR
 100  CONTINUE
       GO TO 310
 110  CONTINUE
      PREFAC = AU2ANG * AU2ANG * AU2ANG / NUMSAM3
C---      PREFAC2 = PREFAC * XBOX*YBOX*ZBOX/(2.0D+00*PI/3.0D+00)
      DO 200 II=1,NUMG
       DIFF = RUPPER * RUPPER * RUPPER - R * R * R
C          ANCI = ANCI + (R+DELR*0.50D+00)**2*GENFR(II,MGR)*
C     *           CCRDF(MGR)*PREFAC/DIFF
           ANCI = ANCI + (R+DELR*0.50D+00)**2*GENFR(II,MGR)*
     *           PREFAC/DIFF
        R = RUPPER
        RUPPER = RUPPER + DELR
 200  CONTINUE
       GO TO 310
 210  CONTINUE
      DO 300 III=1,NCOUNT
       DIFF = RUPPER * RUPPER * RUPPER - R * R * R
          ANCI = ANCI + (R+DELR*0.50D+00)**2*CCRDF(III)
        R = RUPPER
        RUPPER = RUPPER + DELR
 300  CONTINUE
 310  CONTINUE
      IF(XBOX*YBOX*ZBOX.GT.1.0D-06) THEN
         ANC = ANC + (4*PI*NFRG/(XBOX*YBOX*ZBOX*AU2ANG**3))*(ANCI/KOUNT)
      ELSE
         ANC = 0.0D+00
      END IF
C      WRITE(6,*)"ANCI=",ANCI,'ANC=',ANC/KOUNT,'KOUNT=',KOUNT,'MGR',MGR
C      WRITE(6,*)'NUMSAM1=',NUMSAM1,'NUMSAM2',NUMSAM2,'NUMSAM3',NUMSAM3
      RETURN
      END
C*MODULE MDEFP   *DECK HBLIFE
       SUBROUTINE HBLIFE(KOUNT)
C ********************************************************************
C ***   Calculates Hydrogen Bond Lifetimes                         ***
C ********************************************************************
C I think this needs NVE ensemble
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXFRG=1050, MXDFG=5)
      PARAMETER (MXFGPT=12000, MXDPPT=MXFRG*MXDFG*12)
      CHARACTER*8 FRGNME
C
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /MDSIM6/ DIFFU,PRESSA,DBT,GK,E0,DHV,HM0,HM20,
     *                HMU2,HMT,HM0T,VECX,P2,P3,P4,P5,P6,ANC,EX,
     *                HB,HC,HN,HDCDT,CT,ANT,DCDT,HBLIFT,GGK,HM2TT2,
     *                VIRA,EKA,HMU,MGR,MH0
C
C   MH0 <h(0)>
C   HT <h(T)>
C   HB  <h>
C   HHT <H(T)>
C
      IF (KOUNT.EQ.1) THEN
         HB = 0.00D+00
         HC = 0.00D+00
         HN = 0.00D+00
         HDCDT = 0.00D+00
         MH0 = 0
      ENDIF
C
      DSTNC = 0.00D+00
      CT    = 0.00D+00
      ANT    = 0.00D+00
      DCDT  = 0.00D+00
      MHT    = 0
      MHHT   = 0
C DUSE is 3.5 Angstroms
      DUSE  = 6.61404096D+00
C
      DSTNC = ( (EFC(1,1)-EFC(1,6))*(EFC(1,1)-EFC(1,6)) +
     *        (EFC(2,1)-EFC(2,6))*(EFC(2,1)-EFC(2,6))  +
     *        (EFC(3,1)-EFC(3,6))*(EFC(3,1)-EFC(3,6)) )**0.50D+00
C
      IF ( DSTNC .LE. DUSE ) THEN
        MHHT=1
      ELSE
        MHHT=0
        WRITE(6,*)"WARNING: INITAL COORDINATES OF THE TAGGED WATERS"
C       "ARE NOT WITHIN THE DISTANCE CONSTRAINTS FOR A HYDROGEN BOND."
        GO TO 260
      ENDIF
C  ARE WE IN BETWEEN Oxygens or not?
C      I=1
      K=1
      N=1
      DO 250 M=1,2
      DO 200 J=N+1,N+2
      IF      ( EFC(1,J) .LT. EFC(1,K)   .AND.
     *          EFC(1,J) .GT. EFC(1,K+NMPTS(M)) .OR.
     *          EFC(1,J) .GT. EFC(1,K)   .AND.
     *          EFC(1,J) .LT. EFC(1,K+NMPTS(M)) ) THEN
           GO TO 100
      ELSE IF ( EFC(2,J) .LT. EFC(2,K)   .AND.
     *          EFC(2,J) .GT. EFC(2,K+NMPTS(M)) .OR.
     *          EFC(2,J) .GT. EFC(2,K)   .AND.
     *          EFC(2,J) .LT. EFC(2,K+NMPTS(M)) ) THEN
           GO TO 100
      ELSE IF ( EFC(3,J) .LT. EFC(3,K)   .AND.
     *          EFC(3,J) .GT. EFC(3,K+NMPTS(M)) .OR.
     *          EFC(3,J) .GT. EFC(3,K)   .AND.
     *          EFC(3,J) .LT. EFC(3,K+NMPTS(M)) ) THEN
           GO TO 100
      ELSE
            GO TO 200
      ENDIF
C
 100   CONTINUE
C IF WE ARE BETWEEN OXYGENS THEN WE NEED TO CALULATE AN ANGLE
      DSTNC1= ((EFC(1,J)-EFC(1,K))*(EFC(1,J)-EFC(1,K)) +
     *         (EFC(2,J)-EFC(2,K))*(EFC(2,J)-EFC(2,K)) +
     *         (EFC(3,J)-EFC(3,K))*(EFC(3,J)-EFC(3,K)) )
     *          **0.50D+00
C
      DSTNC2= ((EFC(1,J)-EFC(1,K+NMPTS(M)))*(EFC(1,J)-
     *            EFC(1,K+NMPTS(M))) +
     *         (EFC(2,J)-EFC(2,K+NMPTS(M)))*(EFC(2,J)-
     *            EFC(2,K+NMPTS(M))) +
     *         (EFC(3,J)-EFC(3,K+NMPTS(M)))*(EFC(3,J)-
     *            EFC(3,K+NMPTS(M))) )
     *          **0.50D+00
C      ANGLE:  A = COS-1 ((-a^2+b^2+c^2) / 2bc)
       ANGLE = ACOS ( (-1.00D+00*DSTNC**2+DSTNC1**2+DSTNC2**2)
     *            / (2.00D+00*DSTNC1*DSTNC2) )
C  The Criteria is 150 degrees.
        IF (ANGLE.GE.2.61800D+00) THEN
         IF (KOUNT.GT.1) THEN
                MHT=1
                GO TO 260
         ELSE
                MH0=1
         ENDIF
        ELSE IF  (KOUNT.GT.1) THEN
                MHT=0
        ELSE
C just testing.        MH0=0
               MH0=1
        ENDIF
 200  CONTINUE
        N=N+NMPTS(M)
 250  CONTINUE
 260  CONTINUE
C
CC      HB = ( (HB + MHT) / KOUNT )
       HB = HB + MHT
C      HC = ( (HC + (MH0*MHT) ) / KOUNT )
C      HN = ( (HN + (MH0*(1-MHT)*MHHT) ) / KOUNT )
C      HDCDT =  ( (DCDT + (MH0*(1-MHT)) ) / KOUNT )
C WHY AM I MULTIPLING? IF MH0=0 then all values are always 0???
CC      HC = ( (HC + (MH0*MHT) ) / KOUNT )
CC      HN = ( (HN + (MH0*(1-MHT)*MHHT) ) / KOUNT )
CC      HDCDT =  ( (DCDT + (MH0*(1-MHT)) ) / KOUNT )
      HC = HC + (MH0*MHT)
      HN = HN + (MH0*(1-MHT)*MHHT)
      HDCDT = HDCDT + (MH0*(1-MHT))
C
      CT = (HC/KOUNT) / (HB/KOUNT)
      ANT = (HN/KOUNT) / (HB/KOUNT)
      DCDT = (HDCDT/KOUNT) / (HB/KOUNT)
C      WRITE(6,*)'DSTNC=',DSTNC,'DSTNC1=',DSTNC1,'DSTNC2=',DSTNC2
C      WRITE(6,*)'MH0=',MH0,'MHT=',MHT,'MHHT=',MHHT,'ANGLE',ANGLE
C      WRITE(6,*)'HC=',HC/KOUNT,'HN=',HN/KOUNT,'HB=',HB/KOUNT
C      WRITE(6,*)'HDCDT=',HDCDT/KOUNT,'CT=',CT,'ANT=',ANT,'DCDT=',DCDT
C NEED TO FIND K IN -DCDT= K*CT - K'*ANT : 1/K = HBLIFT
      END
C*MODULE MDEFP   *DECK RDMDPRP
       SUBROUTINE RDMDPRP(PROD)
C ********************************************************************
C ***   READ INPUTS FOR MD PROPERTIES NOT GR's THOUGH              ***
C ********************************************************************
C
C   Rotation Relaxation time : routine ROTRELAX  : RRELAX
C   Coordination Number      : routine CRDNMB    : COORDN
C   HEAT OF VAPORIZATION     : routine HVAP      : HTVAP
C   DIPOLE PROPERTIES        : routine DIPPRP    : DIPOLEP
C           - Debeye Relaxation Time Calculation
C           - Finite Kirwood Systems
C           - relative permativity
C   PRESSURE                 : routine PRESUR    : PRESSR
C   DIFFUSION                : routine DIFFSN    : DIFUSN
C   THE  no. of the RDX to use for RRELAX       : MGR
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=2000)
      DOUBLE PRECISION MDPRP
      LOGICAL PRESSR,DIFUSN,DIPOLEP,HTVAP,COORDN,RRELAX,HBLFE
      LOGICAL GOPARR,DSKWRK,MASWRK,PROD,IFEWLD,TNFOIL,EWLDPL,EXECPROP
C
      COMMON /EWALD / IFEWLD,TNFOIL,BETA,ELCNST,EPSLN,CUTOFF,CUTLST,
     *                KMAX,NKVEC,LEVEL,EWLDPL
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MDSIM6/ DIFFU,PRESSA,DBT,GK,E0,DHV,HM0,HM20,
     *                HMU2,HMT,HM0T,VECX,P2,P3,P4,P5,P6,ANC,EX,
     *                HB,HC,HN,HDCDT,CT,ANT,DCDT,HBLIFT,GGK,HM2TT2,
     *                VIRA,EKA,HMU,MGR,MH0
      COMMON /MDSIM8/ PRESSR,DIFUSN,DIPOLEP,HTVAP,COORDN,
     *                RRELAX,HBLFE
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C         set up namelist simulation
      PARAMETER (NNAM=8)
      DIMENSION QNAM( NNAM )
      DIMENSION KQNAM( NNAM )
      DATA MDPRP/8HMDPRP   /
      DATA QNAM /8HPRESSR  ,8HDIFUSN  ,8HDIPOLE  ,
     *           8HHTVAP   ,8HCOORDN  ,8HRRELAX  ,
     *           8HMGR     ,8HHBLFE   /
      DATA KQNAM/0, 0, 0, 0, 0, 0, 1, 0/
C
C             properties for MD have not been well tested!
C     PRESSR,DIFUSN,HTVAP execute on AXP, but others crash out on AXP.
C     only the master process (which prints) should bother to compute
C     MD with a QM piece has no properties
C     Soohaeng thinks Ewald sums don't compute virial correctly
C     Mike thinks none of these have been properly tested, so he
C          has put in the final choice below, as of April 2009.
C     Hui fixed the virial calculation in December 2010, but
C         only one Ewald sum test changed its property printing.
C
                       EXECPROP=.TRUE.
      IF (.NOT.MASWRK) EXECPROP=.FALSE.
      IF (NAT.GT.0)    EXECPROP=.FALSE.
      IF (IFEWLD)      EXECPROP=.FALSE.
C
                       EXECPROP=.FALSE.    ! UNTIL SOMEONE VERIFIES THIS
C
      IF (EXECPROP) THEN
         PRESSR  = .TRUE.
         DIFUSN  = .TRUE.
         DIPOLEP = .FALSE.
         HTVAP   = .TRUE.
         COORDN  = .FALSE.    ! THIS HAS BUGS IF USED IN AXP RUNS.
         RRELAX  = .FALSE.
         HBLFE   = .FALSE.
         MGR     = 1
      ELSE
         PRESSR  = .FALSE.
         DIFUSN  = .FALSE.
         DIPOLEP = .FALSE.
         HTVAP   = .FALSE.
         COORDN  = .FALSE.
         RRELAX  = .FALSE.
         HBLFE   = .FALSE.
         MGR     = 0
      ENDIF
C
      IRET = 0
      CALL NAMEIO(IR,IRET,MDPRP,NNAM,QNAM,KQNAM,
     *     PRESSR,DIFUSN,DIPOLE,HTVAP,COORDN,RRELAX,MGR,HBLFE,
     *                    0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,
     *            0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,
     *            0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0)
      IF(IRET.EQ.2) THEN
        IF(MASWRK) WRITE(IW,*) 'ERROR READING $MDPRP GROUP'
        CALL ABRT
      ENDIF
C
      IF (.NOT.PROD) THEN
         COORDN  = .FALSE.
         MGR     = 0
      ENDIF
C    WRITE OUT WHICH PROPERtiES WE ARE GOING TO USE
      IF(MASWRK) WRITE(IW,9000) PRESSR,DIFUSN,DIPOLEP,
     *                          RRELAX,HTVAP,COORDN,MGR
C
 9000 FORMAT(/5X,'PROPERTY EVALUATIONS IN MOLECULAR DYNAMICS',/
     *       5X,42(1H-),/
     *       5X,'PRESSURE=',L2,10X,'DIFFUSION=',L2,/
     *       5X,'DIPOLE PROPERTIES=',L2,6X,'ROT. RELAXATION=',L2,/
     *       5X,'HEAT OF VAPORIZATION=',L2,/
     *       5X,'COORDINATION # / G(R)#=',L2,'/',I2)
      END
C
C*MODULE MDEFP   *DECK MDKIN
C>
C>    @brief    computes current kinetic energy
C>
C>    @details  computes current kinetic energy
C>
C>    @author   unknown
C>
      SUBROUTINE MDKIN
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DOUBLE PRECISION MDTYP
      PARAMETER (MXFGPT=12000,MXFRG=1050,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (MXATM=2000)
C
      COMMON /ATMDAT/ VX(MXFRG), VY(MXFRG), VZ(MXFRG),
     *                QW(MXFRG), QX(MXFRG), QY(MXFRG), QZ(MXFRG),
     *                OX(MXFRG), OY(MXFRG), OZ(MXFRG), QW1(MXFRG),
     *                QX1(MXFRG),QY1(MXFRG),QZ1(MXFRG),QW2(MXFRG),
     *                QX2(MXFRG),QY2(MXFRG),QZ2(MXFRG),
     *                VXQM(MXATM), VYQM(MXATM), VZQM(MXATM)
      COMMON /EFPPBC/ XBOX,YBOX,ZBOX,XCUT,YCUT,ZCUT,RCUT
     *                ,SWR1,SWR2,ISWF
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /MASSES/ ZMASS(MXATM)
      COMMON /MDSIM / DT, BATHT, EKINT, EKINR, MDTYP
      COMMON /MDVEL / WX(MXFRG),WY(MXFRG),WZ(MXFRG),TQI(3,MXFRG)
      COMMON /MODDAT/ AMOM(3,MXDFG), TOTMAS(MXDFG), TOTMAI(MXDFG),
     *                DRX(MXFGPT), DRY(MXFGPT), DRZ(MXFGPT)
      COMMON /VIRPR / VIR(3), PRXX, PRYY, PRZZ
C
      EKINT = 0.0D+00
      EKINR = 0.0D+00
      PX    = 0.0D+00
      PY    = 0.0D+00
      PZ    = 0.0D+00
C
      DO I = 1, NAT
         ZMAS  = ZMASS(I)
         PX    = PX    + ZMAS*VXQM(I)**2
         PY    = PY    + ZMAS*VYQM(I)**2
         PZ    = PZ    + ZMAS*VZQM(I)**2
      ENDDO
C
      DO I=1,NFRG
         IST = ISET(I)
         TMAS = TOTMAS(IST)
         PX = PX + TMAS * VX(I)**2
         PY = PY + TMAS * VY(I)**2
         PZ = PZ + TMAS * VZ(I)**2
         EKINR = EKINR + AMOM(1,IST) * WX(I)**2 +
     *        AMOM(2,ISET(I)) * WY(I)**2 + AMOM(3,ISET(I)) * WZ(I)**2
      ENDDO
C
      VOL   = XBOX*YBOX*ZBOX
      IF(VOL.GT.1.0D-06) THEN
         PRXX  = (PX + VIR(1))/VOL
         PRYY  = (PY + VIR(2))/VOL
         PRZZ  = (PZ + VIR(3))/VOL
      ELSE
         PRXX = 0.0D+00
         PRYY = 0.0D+00
         PRZZ = 0.0D+00
      END IF
C
      EKINT = 0.5D+00*(PX+PY+PZ)
      EKINR = 0.5D+00*EKINR
C--   EKIN  = EKINT + EKINR
C--   WINT  = (VIR(1) + VIR(2) + VIR(3))/(3.0D+00*VOL)
      RETURN
      END
C*MODULE MDEFP   *DECK cstssbp
C>
C>     @brief spherical boundary energy 
C>
C>     @details Add spherical boundary energy.
C>
C>     @author Cheol Ho Choi 
C>
      SUBROUTINE cstssbp(f2f)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      double precision mdint
      PARAMETER (MXATM=2000,NRepca=100)
      PARAMETER (MXFGPT=12000, MXFRG=1050,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      logical goparr,maswrk,dskwrk,ccms,ssbp,usamp,rstemp,rsrand,prod
c     COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
c     COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FUNCT / E, EG(3*MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
c     COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
c     COMMON /VIRPR / VIR(3), PRXX, PRYY, PRZZ
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      common /cstpot/ DROFF(2),SFORCE,uforce(10),rzero(10),dtemp,
     *                rzeroC(3,MXATM),Tmin,uV,batht(NRepca),mdint,
     *                ipair(50),iustyp,ncst,nrand,nvtoff,
     *                jevery,kevery,levery,mremd,
     *                rstemp,rsrand,prod,SSBP,ccms,Usamp,IndexOH(50),
     *                movemm(200),nefpmv,cforce,tmass(3)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
c     DATA GRDKWD/8HGRADIENT/
c
c     Note that we do not support FMO for the moment!
C
C     QM : apply QM boundary, droff(2)
c
C JMODB: Added essbp (spherical boundary potential energy)
      essbp=0.0D+00
      ntotala=0
      do i=1,Nat
          r=sqrt(c(1,i)**2+c(2,i)**2+c(3,i)**2)
          rflag=r-droff(2)
          if(rflag.gt.0) then
             essbp=essbp+0.5D+00*sforce*rflag**2
             sfactor=-f2f*sforce*rflag/r
             idx=3*(i-1)
             do j=1,3
                eg(idx+j) =  eg(idx+j) - sfactor*c(j,i)
             enddo
             ntotala=ntotala+1
          endif
      enddo
c
c     EFP :  apply MM or total boundary, droff(1)
c
      ntotalf=0
      DO I = 1, NFRG
          r=sqrt(efcent(1,i)**2+efcent(2,i)**2+efcent(3,i)**2)
          rflag=r-droff(1)
          if(rflag.gt.0) then
             essbp=essbp+0.5D+00*sforce*rflag**2
             sfactor=-f2f*sforce*rflag/r
             do j=1,3
                DEFT(j,I) =  DEFT(j,I) - sfactor*efcent(j,i)
             enddo
             ntotalf=ntotalf+1
          endif
      ENDDO
      if (maswrk) write(IW,1000) ntotala,ntotalf
      E=E+essbp
C
C JMODE
      RETURN
 1000 format(/5x,'Applying Solvent Boundary Conditions ...'/
     *       ,5x,'Number of ab initio atoms and solvent molecules'
     *          ,' affected = ',2i6/)
      END
C*MODULE MDEFP   *DECK cstccms
C>
C>     @brief center potential for MD
C>
C>     @details Add spherical potential to push atoms towards the center.
C>
C>     @param f2f : conversion constant
C>
C>     @author Cheol Ho Choi 
C>
      SUBROUTINE cstccms(f2f)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      double precision mdint
      PARAMETER (MXATM=2000,NRepca=100)
C
      logical goparr,maswrk,dskwrk,ccms,ssbp,usamp,rstemp,rsrand,prod
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
c     COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FUNCT / E, EG(3*MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
c     COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
c     COMMON /VIRPR / VIR(3), PRXX, PRYY, PRZZ
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      common /cstpot/ DROFF(2),SFORCE,uforce(10),rzero(10),dtemp,
     *                rzeroC(3,MXATM),Tmin,uV,batht(NRepca),mdint,
     *                ipair(50),iustyp,ncst,nrand,nvtoff,
     *                jevery,kevery,levery,mremd,
     *                rstemp,rsrand,prod,SSBP,ccms,Usamp,IndexOH(50),
     *                movemm(200),nefpmv,cforce,tmass(3)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MASSES/ ZMASS(MXATM)
      dimension cR(3)
c
c     Keeping QM atoms to the center of Spherical Boundary Potential.
c
      eccms=0.0D+00
      cR(1)=0.0d+00
      cR(2)=0.0d+00
      cR(3)=0.0d+00
      do i=1,nat
         cR(1)=cR(1) + zmass(i)*c(1,i)
         cR(2)=cR(2) + zmass(i)*c(2,i)
         cR(3)=cR(3) + zmass(i)*c(3,i)
      enddo
      cR(1)=cR(1)/Tmass(1)
      cR(2)=cR(2)/Tmass(1)
      cR(3)=cR(3)/Tmass(1)
      eccms=0.5D+00*cforce*(cR(1)**2+cR(2)**2+cR(3)**2)
      cfactor=f2f*cforce/Tmass(1)
      do i=1,Nat
         idx=3*(i-1)
         eg(idx+1) = eg(idx+1) + cfactor*cR(1)*zmass(i)
         eg(idx+2) = eg(idx+2) + cfactor*cR(2)*zmass(i)
         eg(idx+3) = eg(idx+3) + cfactor*cR(3)*zmass(i)
      enddo
c
      if (maswrk) write(IW,1000) cR(1)*au2ang,cR(2)*au2ang,
     *            cR(3)*au2ang 
      E=E+eccms
C
      RETURN
 1000 format(/5x,'Applying CCMS on the QM Center of Mass of'/
     *       ,5x,' = (',3F10.5,')'/)
      END
C*MODULE MDEFP   *DECK cstcms
C>
C>     @brief Constraint for Center of Mass Coordinate
C>
C>     @details Center of Mass coordinate for Umbrella Sampling
C>
C>     @param f2f : conversion constant
C>
C>     @param uVt : potential energy of umbrella constraint
C>
C>     @author Cheol Ho Choi 
C>
      SUBROUTINE cstcms(f2f,uVt)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      double precision mdint
      PARAMETER (MXATM=2000,NRepca=100)
      PARAMETER (zero=0.0d+00)
      logical goparr,maswrk,dskwrk,ccms,ssbp,usamp,rstemp,rsrand,prod
      COMMON /FUNCT / E, EG(3*MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      common /cstpot/ DROFF(2),SFORCE,uforce(10),rzero(10),dtemp,
     *                rzeroC(3,MXATM),Tmin,uV,batht(NRepca),mdint,
     *                ipair(50),iustyp,ncst,nrand,nvtoff,
     *                jevery,kevery,levery,mremd,
     *                rstemp,rsrand,prod,SSBP,ccms,Usamp,IndexOH(50),
     *                movemm(200),nefpmv,cforce,tmass(3)
      COMMON /MASSES/ ZMASS(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      dimension cRa(3),cRb(3),cRab(3)
c
c     Inter center of mass coordinate
c
      do i=1,3
         cRa(i)=zero
         cRb(i)=zero
         cRab(i)=zero
      enddo
c
      do i=1,nat
         if (i.eq.ipair(i)) then
            do j=1,3
               cRa(j)=cRa(j) + zmass(i)*c(j,i)
            enddo
         else
            do j=1,3
               cRb(j)=cRb(j) + zmass(i)*c(j,i)
            enddo
         endif
      enddo
c
      do i=1,3
         cRa(i)=cRa(i)/tmass(2)
         cRb(i)=cRb(i)/tmass(3)
      enddo
c
      do i=1,3
         cRab(i)=cRa(i) - cRb(i)
      enddo
c
      Rab=cRab(1)**2+cRab(2)**2+cRab(3)**2
      Rab=sqrt(Rab)
      uVt=0.5D+00*uforce(1)*(Rab-rzero(1))**2
      cfactora=f2f*uforce(1)*(Rab-rzero(1))/(Rab*Tmass(2))
      cfactorb=-f2f*uforce(1)*(Rab-rzero(1))/(Rab*Tmass(3))
c
      do i=1,Nat
         idx=3*(i-1)
         if (i.eq.ipair(i)) then
            eg(idx+1) = eg(idx+1) + cfactora*cRab(1)*zmass(i)
            eg(idx+2) = eg(idx+2) + cfactora*cRab(2)*zmass(i)
            eg(idx+3) = eg(idx+3) + cfactora*cRab(3)*zmass(i)
         else
            eg(idx+1) = eg(idx+1) + cfactorb*cRab(1)*zmass(i)
            eg(idx+2) = eg(idx+2) + cfactorb*cRab(2)*zmass(i)
            eg(idx+3) = eg(idx+3) + cfactorb*cRab(3)*zmass(i)
         endif
      enddo
c
      if (maswrk) write(IW,2000) Rab*au2ang
c
      RETURN
 2000 format(5x,'Inter center of mass'/
     *      ,5x,'Current Distance (Ang.) = ',F15.10)
      END
C*MODULE MDEFP   *DECK cstpos
C>
C>     @brief Constraint for Center of Mass Coordinate of Position
C>
C>     @details Center of Mass coordinate for Umbrella Sampling
C>      with respect to the center of sphere
C>
C>     @param f2f : conversion constant
C>
C>     @param uVt : potential energy of umbrella constraint
C>
C>     @author Cheol Ho Choi 
C>
      SUBROUTINE cstpos(f2f,uVt)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      double precision mdint
      PARAMETER (MXATM=2000,NRepca=100)
      PARAMETER (zero=0.0d+00)
      logical goparr,maswrk,dskwrk,ccms,ssbp,usamp,rstemp,rsrand,prod
      COMMON /FUNCT / E, EG(3*MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      common /cstpot/ DROFF(2),SFORCE,uforce(10),rzero(10),dtemp,
     *                rzeroC(3,MXATM),Tmin,uV,batht(NRepca),mdint,
     *                ipair(50),iustyp,ncst,nrand,nvtoff,
     *                jevery,kevery,levery,mremd,
     *                rstemp,rsrand,prod,SSBP,ccms,Usamp,IndexOH(50),
     *                movemm(200),nefpmv,cforce,tmass(3)
      COMMON /MASSES/ ZMASS(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      dimension cRab(3)
c
c     This routine is for umbrella sampling constraint of
c     position of a particular atom.
c
      do i=1,3
         cRab(i)=zero
      enddo
c
      do i=1,nat
        do j=1,3
           cRab(j)=cRab(j) + zmass(i)*c(j,i)
        enddo
      enddo
c
      do i=1,3
         cRab(i)=cRab(i)/tmass(2)
      enddo
c
      Rab=cRab(1)**2+cRab(2)**2+cRab(3)**2
      Rab=sqrt(Rab)
      uVt=0.5D+00*uforce(1)*(Rab-rzero(1))**2
      cfactora=f2f*uforce(1)*(Rab-rzero(1))/(Rab*Tmass(2))
c
      do i=1,Nat
         idx=3*(i-1)
         eg(idx+1) = eg(idx+1) + cfactora*cRab(1)*zmass(i)
         eg(idx+2) = eg(idx+2) + cfactora*cRab(2)*zmass(i)
         eg(idx+3) = eg(idx+3) + cfactora*cRab(3)*zmass(i)
      enddo
c
      if (maswrk) write(IW,2000) Rab*au2ang
c
      RETURN
 2000 format(5x,'Center of Mass Position'/
     *      ,5x,'Current Radius (Ang.) = ',F15.10)
      END
C*MODULE MDEFP   *DECK REMD_V_RESCALE
      SUBROUTINE REMD_V_RESCALE(T_New)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION MDTYP
C
      PARAMETER (MXFGPT=12000, MXFRG=1050, MXATM=2000,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      COMMON /ATMDAT/ VX(MXFRG), VY(MXFRG), VZ(MXFRG),
     *                QW(MXFRG), QX(MXFRG), QY(MXFRG), QZ(MXFRG),
     *                OX(MXFRG), OY(MXFRG), OZ(MXFRG), QW1(MXFRG),
     *                QX1(MXFRG),QY1(MXFRG),QZ1(MXFRG),QW2(MXFRG),
     *                QX2(MXFRG),QY2(MXFRG),QZ2(MXFRG),
     *                VXQM(MXATM), VYQM(MXATM), VZQM(MXATM)
      COMMON /CONVMD/ AU2KCAL, EK2KCAL, AU2ANG, AU2SEC, AU2AMU, EK2BAR
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /MASSES/ ZMASS(MXATM)
      COMMON /MDSIM / DT, BATHT, EKINT, EKINR, MDTYP
      COMMON /MDVEL / WX(MXFRG),WY(MXFRG),WZ(MXFRG),TQI(3,MXFRG)
      COMMON /MODDAT/ AMOM(3,MXDFG), TOTMAS(MXDFG), TOTMAI(MXDFG),
     *                DRX(MXFGPT), DRY(MXFGPT), DRZ(MXFGPT)
      COMMON /NOSEHO/ GNH(2),VNH(2),XNH(2),QNH(2),EKT0,GFREE0,NVTNH
c     COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
c
      EKT_New = 1.987216D-03 * T_New / EK2KCAL
      scale1=sqrt(EKT_New/Ekt0)
c      scale2=scale1
c      write(IW,*) 'V_Scale scale1',scale1
c
c     We need to scale the velocity of Nose-Hoover Thermostat
c
      VNH(1)=scale1*VNH(1)
      VNH(2)=scale1*VNH(2)
C
      EKINT = 0.0D+00
      EKINR = 0.0D+00
C
      DO I = 1, NAT
         VXQM(I) = VXQM(I)*SCALE1
         VYQM(I) = VYQM(I)*SCALE1
         VZQM(I) = VZQM(I)*SCALE1
         EKINT = EKINT + ZMASS(I)*(VXQM(I)**2 + VYQM(I)**2 + VZQM(I)**2)
      END DO
C
      DO I = 1, NFRG
         VX(I) = VX(I)*SCALE1
         VY(I) = VY(I)*SCALE1
         VZ(I) = VZ(I)*SCALE1
         WX(I) = WX(I)*SCALE1
         WY(I) = WY(I)*SCALE1
         WZ(I) = WZ(I)*SCALE1
        EKINT = EKINT + TOTMAS(ISET(I))*(VX(I)**2 + VY(I)**2 + VZ(I)**2)
        EKINR = EKINR + AMOM(1,ISET(I))* WX(I)**2 + AMOM(2,ISET(I))
     *       * WY(I)**2 + AMOM(3,ISET(I)) * WZ(I)**2
      END DO
C
      EKINT = 0.5D+00 * EK2KCAL * EKINT
      EKINR = 0.5D+00 * EK2KCAL * EKINR
C
      RETURN
      END
C*MODULE MDEFP   *DECK rearrangeIPAIR
C>
C>     @brief rearrange atomic pairs 
C>
C>     @details Rearrange atomic pairs. 
c>     Rearrange the ipair based on the minimum energy of uV for 
c>     the atomic pair (OH) distance.
c>
c>      IndexOH: 1 2 3 Oxygen index
c>               4 5 6 Hydrogen index
c>
c>       1                 5
c>       O                 H
c>       |                 |  
c>     C-C=O  ---------- H-O-H 6 
c>         2             4 3
c>
c>    There are total 2x3=6 combination.  
c>    And atomic pair 4 2 and 4 3 should result in minimal energy.
C>
C>     @author Tae Hoon Choi
C>
c
      SUBROUTINE rearrangeIPAIR
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=2000, NRepca=100)
      LOGICAL ccms,ssbp,usamp,rstemp,rsrand,prod
      double precision mdint
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      common /cstpot/ DROFF(2),SFORCE,uforce(10),rzero(10),dtemp,
     *                rzeroC(3,MXATM),Tmin,uV,batht(NRepca),mdint,
     *                ipair(50),iustyp,ncst,nrand,nvtoff,
     *                jevery,kevery,levery,mremd,
     *                rstemp,rsrand,prod,SSBP,ccms,Usamp,IndexOH(50),
     *                movemm(200),nefpmv,cforce,tmass(3)
      dimension uvec1(3),IndexO(3),IndexH(3),ISave(3)
c
      NumO =3
      NumH =3
      IndexO(1)=IndexOH(1)
      IndexO(2)=IndexOH(2)
      IndexO(3)=IndexOH(3)
      IndexH(1)=IndexOH(4)
      IndexH(2)=IndexOH(5)
      IndexH(3)=IndexOH(6)
      vecn_save = 1000000.0d+00
      do iO=1, NumO-1
        do iH=1, NumH
          uvecn1=0
          do i=1,3
             uvec1(i)=c(i,IndexO(iO))-c(i,IndexH(iH))
             uvecn1=uvecn1+uvec1(i)**2
          enddo
c
          vecn1=sqrt(uvecn1)
          if ( vecn1 .lt. vecn_save) then
            vecn_save = vecn1
            ISave(1)=IndexO(iO)
            ISave(2)=IndexH(iH)
            ISave(3)=IndexO(3)
          endif
        enddo
      enddo
c
c  rearrange ipair
      if (iustyp .eq. 6) then
        ipair(1)=ISave(2)
        ipair(2)=Isave(1)
        ipair(3)=ISave(2)
        ipair(4)=Isave(3)
      else if (iustyp .eq. 7) then
        ipair(1)=ISave(2)
        ipair(2)=Isave(1)
        ipair(3)=Isave(3)
      endif
      return
      end
