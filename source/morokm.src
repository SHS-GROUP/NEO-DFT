C 11 AUG 11 - HL  - ALLOW LMOEDA TO USE MCP
C 11 AUG 10 - DGF - SYNCH COMMON BLOCK ENRGYS
C 23 JUN 10 - HL  - FIX TO ECP USAGE TO ERASE ECP ON OTHER MONOMERS
C 15 MAY 10 - HL  - CHANGES IN LMOEDA METHOD, AND ALLOW ECP USAGE
C 14 OCT 09 - DGF - PAD ENRGMP
C  1 MAY 09 - PFS,HL - ADD LMOEDA METHOD
C  6 NOV 06 - MWS - ADJUST WAVEFUNCTION COMMON BLOCK
C 10 JUL 06 - MWS - MOROX: IMPROVE THE RVS PRINTOUT
C 17 JAN 06 - HL  - CORRECT NAME OF RESTART GROUP
C 14 NOV 05 - DGF - PAD COMMON BLOCK SCFOPT, WIDEN FORMATS
C 19 SEP 05 - MWS - MOROST: IMPROVE QUALITY OF ERROR MESSAGES
C  5 JUL 05 - MWS - SELECT NEW ATOM,BASIS,EFP,PCM,DAF DIMENSIONS
C 13 FEB 05 - MWS - PAD COMMON BLOCK NSHEL
C  7 SEP 04 - MWS - PAD COMMON BLOCK INTFIL
C  9 DEC 03 - MWS - SYNCH COMMON BLOCK RUNOPT
C  6 SEP 01 - MWS - ADD DUMMY ARGUMENTS TO NAMEIO CALL
C 25 JUN 01 - MWS - ALTER COMMON BLOCK SCFOPT
C 26 OCT 00 - MWS - STOP JOB IF SPHERICAL HARMONICS ARE ATTEMPTED
C 28 JUL 00 - MWS - ADD NEW ARGS TO CALLS TO INIDEN
C 21 DEC 99 - DGF - ADD NEW ARGS TO CALLS TO INIDEN
C 13 MAR 99 - MWS - ADD NEW ARGS TO CALLS TO INIDEN
C 12 NOV 98 - GDF - CHANGE BIT PACKING TO ISHIFT
C 12 SEP 98 - CGP - MOROST: FIX COUNTING FOR 10 MONOMERS
C  6 MAY 98 - MWS - CHANGE -UPCASE- TO -UPRCAS-
C 28 SEP 97 - MWS - CONVERT PARALLEL CALLS FROM TCGMSG TO DDI
C 13 JUN 96 - VAG - ADD VARIABLE FOR CI TYPE TO SCFOPT COMMON
C  5 MAR 96 - MWS - CHANGE SHELL SYMMETRY PACKING COMMONS
C  9 JAN 96 - MWS - MOMEM,ZRMEM: FIX EXETYP=CHECK RUNS
C  5 JAN 96 - WC  - ADD OPTION FOR MORE THAN TWO MONOMERS, CTPLX OPTION,
C                   BSSE OPTION, AND RVS OPTION.
C  3 JAN 96 - MWS - MOROX: CALL NEW ONE ELECTRON INTEGRAL DRIVER
C 26 JAN 95 - WC  - NEW MODULE FOR MOROKUMA ENERGY DECOMPOSITION
C
C*MODULE MOROKM  *DECK CHGODB
      SUBROUTINE CHGODB(V,WRK,L1,NN,NE,NMOL,NBAS,NEM)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION NBAS(*),NEM(*),V(*),WRK(*)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
      L3 = L1**2
      NOTOT = NE/2*L1
      IF (NN .EQ. NMOL) GO TO 300
      NSHFT1 = 1
      DO 100 IM = 1, NMOL-1
         NO = NEM(IM)/2
         IF (NN.EQ.IM) THEN
            NOLEN1 = NSHFT1 - 1
            NOLEN2 = NO*L1
            NOLEN3 = NOTOT - NOLEN1 -NOLEN2
            NOST2 = NOTOT - NOLEN2 + 1
            NOST3 = NSHFT1
            GO TO 200
         END IF
         NSHFT1 = NSHFT1 + NO*L1
  100 CONTINUE
C
  200 CALL DCOPY(NOLEN2,V(NOST2),1,WRK(1),1)
      CALL DCOPY(NOLEN3,V(NOST3),1,WRK(NOLEN2+1),1)
      CALL DCOPY(NOTOT-NOLEN1,WRK(1),1,V(NOST3),1)
C
  300 IF (NN.EQ.1) GO TO 600
      NSHFT1 = 0
      DO 400 IM = 1, NMOL
         NV = NBAS(IM) - NEM(IM)/2
         IF (NN.EQ.IM) THEN
            NVST2 = NOTOT + 1
            NVLEN2 = NV*L1
            NVST1 = NVST2 + NVLEN2
            NVLEN1 = NSHFT1
            GO TO 500
         END IF
         NSHFT1 = NSHFT1 + NV*L1
  400 CONTINUE
C
  500 CALL DCOPY(NVLEN1,V(NVST1),1,WRK(1),1)
      CALL DCOPY(NVLEN2,V(NVST2),1,WRK(NVLEN1+1),1)
      CALL DCOPY(NVLEN1+NVLEN2,WRK(1),1,V(NVST2),1)
C
  600 CALL DAWRIT(IDAF,IODA,V,L3,314,0)
C
      RETURN
      END
C*MODULE MOROKM  *DECK CHGODF
      SUBROUTINE CHGODF(V,WRK,L1,NN,NE,NMOL,NBAS,NEM)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION NBAS(*),NEM(*),V(*),WRK(*)
C
      NOTOT = NE/2*L1
      IF (NN .EQ. NMOL) GO TO 300
      NSHFT1 = 1
      DO 100 IM = 1, NMOL-1
         NO = NEM(IM)/2
         IF (NN.EQ.IM) THEN
            NOLEN1 = NSHFT1 - 1
            NOLEN2 = NO*L1
            NOLEN3 = NOTOT - NOLEN1 -NOLEN2
            NOST2 = NSHFT1
            NOST3 = NSHFT1 + NOLEN2
            GO TO 200
         END IF
         NSHFT1 = NSHFT1 + NO*L1
  100 CONTINUE
C
  200 CALL DCOPY(NOLEN3,V(NOST3),1,WRK(1),1)
      CALL DCOPY(NOLEN2,V(NOST2),1,WRK(NOLEN3+1),1)
      CALL DCOPY(NOTOT-NOLEN1,WRK(1),1,V(NOST2),1)
C
  300 IF (NN.EQ.1) GO TO 600
      NSHFT1 = NOTOT + 1
      DO 400 IM = 1, NMOL
         NV = NBAS(IM) - NEM(IM)/2
         IF (NN.EQ.IM) THEN
            NVST1 = NOTOT + 1
            NVST2 = NSHFT1
            NVLEN1 = NVST2 - NVST1
            NVLEN2 = NV*L1
            GO TO 500
         END IF
         NSHFT1 = NSHFT1 + NV*L1
  400 CONTINUE
C
  500 CALL DCOPY(NVLEN2,V(NVST2),1,WRK(1),1)
      CALL DCOPY(NVLEN1,V(NVST1),1,WRK(NVLEN2+1),1)
      CALL DCOPY(NVLEN1+NVLEN2,WRK(1),1,V(NVST1),1)
C
  600 CONTINUE
      RETURN
      END
C*MODULE MOROKM  *DECK CTINT1
      SUBROUTINE CTINT1
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXMOL=10)
C
      COMMON /FMCOM / XX(1)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
C
      L1 = NUM
      L3 = L1 * L1
      L2 = ( L3 + L1 ) / 2
      L5 = 0
      DO 50 IM = 1, NMOL
         L5 = L5 + NBAS(IM)**2
   50 CONTINUE
      CALL VALFM(LOADFM)
C
      LH = LOADFM + 1
      LF = LH     + L2
      LW = LF     + L2
      LS = LW     + L3
C     LS = LW     + L5
      LAST = LS   + L1
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      CALL DAREAD(IDAF,IODA,XX(LH),L2,11,0)
      CALL CTMOTR(XX(LF),XX(LH),XX(LW),XX(LS),L1)
      CALL DAWRIT(IDAF,IODA,XX(LH),L2,11,0)
C
      CALL RETFM(NEED)
      RETURN
      END
C*MODULE MOROKM  *DECK CTMOT1
      SUBROUTINE CTMOT1(H,F,W,SCR,NUM,NE)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL DOALLO, DOALLV
C
      DIMENSION H(*), F(*), W(*),SCR(*)
C
      PARAMETER (MXMOL=10)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
C
      NN = NMORO - 1000
      L1 = NUM
      L2 = L1*(L1+1)/2
      L5 = 0
      DO 50 IM = 1, NMOL
         L5 = L5 + NBAS(IM)**2
   50 CONTINUE
C
      CALL DAREAD(IDAF,IODA,W,L5,315,0)
C
C     INITIALIZE H
C
      CALL VCLR(H,1,L2)
C
C     TRANSFORM S TO ZEROTH ORDER MO BASIS
C
C     OX-OX AND VX-VX BLOCKS
C
      IWS = 1
      DO 100 IM = 1, NMOL
         IWS = IWS + NBAS(IM)*NEM(IM)/2
  100 CONTINUE
C
      NSFTO = 0
      NSFTV = NE/2
      NOT = 1
      NVT = NSFTV + 1
      IWSO = 1
      IWSV = IWS
      DO 200 IM = 1, NMOL
         NT = NBAS(IM)
         NO = NEM(IM)/2
         NV = NT - NO
         NSFTS = NLOC(IM)
         IFS = (NSFTS+1)*(NSFTS+2)/2
         IHSO = NOT*(NOT+1)/2
         IHSV = NVT*(NVT+1)/2
         DOALLO = IM.EQ.NN
         DOALLV = IM.NE.NN
C
         CALL TFTRI1(F(IFS),H(IHSO),W(IWSO),SCR,NO,NT,NSFTS,NSFTO,
     *               DOALLO)
         CALL TFTRI1(F(IFS),H(IHSV),W(IWSV),SCR,NV,NT,NSFTS,NSFTV,
     *               DOALLV)
         NSFTO = NSFTO + NO
         NSFTV = NSFTV + NV
         NOT = NOT + NO
         NVT = NVT + NV
         IWSO = IWSO + NO*NT
         IWSV = IWSV + NV*NT
  200 CONTINUE
C
C     VX-OY BLOCK
C
      MH = NE/2
      IWS1 = IWS
      DO 700 IV = 1, NMOL
         NOT = 1
         NVT = NE/2 + 1
         IWS2 = 1
         IWS3 = IWS
         MT = NBAS(IV)
         MV = MT - NEM(IV)/2
         MF = NLOC(IV)
         MSFTF = MF*(MF+1)/2
         MSFTH = MH*(MH+1)/2
         DO 600 IO = 1, NMOL
            NT = NBAS(IO)
            NO = NEM(IO)/2
            NV = NT - NO
            NF = NLOC(IO)
            IHS = MSFTH + NOT
            IF (IO.NE.NN) GO TO 450
            IF (IV-IO) 400, 450, 300
C
  300       IFS = MSFTF + NF + 1
            CALL TFSQU1(F(IFS),H(IHS),W(IWS1),W(IWS2),SCR,MT,NT,MV,NO,
     *                  MF,MH)
            GO TO 450
C
  400       IFS = NF*(NF+1)/2 + MF + 1
            NSFT = MH - NO
            CALL TFSQU2(F(IFS),H(IHS),W(IWS1),W(IWS2),SCR,MT,NT,MV,NO,
     *                  NF,NSFT)
C
  450       IF (IV.LE.IO.OR.IV.EQ.NN.OR.IO.EQ.NN) GO TO 500
            IFS = MSFTF + NF + 1
            IHS = MSFTH + NVT
            CALL TFSQU1(F(IFS),H(IHS),W(IWS1),W(IWS3),SCR,MT,NT,MV,NV,
     *                  MF,MH)
  500       NOT = NOT + NO
            NVT = NVT + NV
            IWS2 = IWS2 + NO*NT
            IWS3 = IWS3 + NV*NT
  600    CONTINUE
         MH = MH + MV
         IWS1 = IWS1 + MV*MT
  700 CONTINUE
C
      CALL DCOPY(L2,H,1,F,1)
C
      RETURN
      END
C*MODULE MOROKM  *DECK CTMOT2
      SUBROUTINE CTMOT2(H,F,W,SCR,NUM,NE)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL DOALL
C
      DIMENSION H(*), F(*), W(*),SCR(*)
C
      PARAMETER (MXMOL=10)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
C
      NN = NMORO - 1200
      L1 = NUM
      L2 = L1*(L1+1)/2
      L5 = 0
      DO 50 IM = 1, NMOL
         L5 = L5 + NBAS(IM)**2
   50 CONTINUE
C
      CALL DAREAD(IDAF,IODA,W,L5,315,0)
C
C     INITIALIZE H
C
      CALL VCLR(H,1,L2)
C
C     TRANSFORM S TO ZEROTH ORDER MO BASIS
C
C     OX-OX AND VX-OX BLOCKS
C
      IWS = 1
      DO 100 IM = 1, NMOL
         IWS = IWS + NBAS(IM)*NEM(IM)/2
  100 CONTINUE
C
      NSFTO = 0
      NSFTV = NE/2
      NOT = 1
      NVT = NSFTV + 1
      NVTO = NE/2
      IWSO = 1
      IWSV = IWS
      DO 200 IM = 1, NMOL
         NT = NBAS(IM)
         NO = NEM(IM)/2
         NV = NT - NO
         NSFTS = NLOC(IM)
         IFS = (NSFTS+1)*(NSFTS+2)/2
         IHSO = NOT*(NOT+1)/2
         IHSV = NVT*(NVT+1)/2
         IHSVO = NVTO*(NVTO+1)/2 + NOT
         DOALL = IM.EQ.NN.OR.NN.EQ.0
C
         CALL TFTRI1(F(IFS),H(IHSO),W(IWSO),SCR,NO,NT,NSFTS,NSFTO,
     *               DOALL)
         CALL TFTRI1(F(IFS),H(IHSV),W(IWSV),SCR,NV,NT,NSFTS,NSFTV,
     *               DOALL)
         IF (DOALL) CALL TFTRI2(F(IFS),H(IHSVO),W(IWSV),W(IWSO),
     *               SCR,NV,NO,NT,NSFTS,NSFTV)
         NSFTO = NSFTO + NO
         NSFTV = NSFTV + NV
         NOT = NOT + NO
         NVT = NVT + NV
         NVTO = NVTO + NV
         IWSO = IWSO + NO*NT
         IWSV = IWSV + NV*NT
  200 CONTINUE
C
      CALL DCOPY(L2,H,1,F,1)
C
      RETURN
      END
C*MODULE MOROKM  *DECK CTMOT3
      SUBROUTINE CTMOT3(H,F,W,SCR,NUM)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION H(*), F(*), W(*),SCR(*)
C
      PARAMETER (MXMOL=10)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
C
      ZERO=0.0D+00
      L1 = NUM
      L2 = NUM*(NUM+1)/2
      L3 =NUM**2
      CALL DAREAD(IDAF,IODA,W,L3,316,0)
      CALL TFTRI(H,F,W,SCR,L1,L1,L1)
C
      IJ=0
      IM=1
      IQ=1
      II=NEM(1)/2
      DO 111 I=1,L1
      IF (I.GT.II) THEN
      IM=IM+1
      IF (IM.GT.NMOL) THEN
      IM=1
      IQ=2
      END IF
      IF (IQ.EQ.1) THEN
      II=II+NEM(IM)/2
      ELSE
      II=II+NBAS(IM)-NEM(IM)/2
      END IF
      END IF
      JM=1
      JQ=1
      JJ=NEM(1)/2
      DO 112 J=1,I
      IF (J.GT.JJ) THEN
      JM=JM+1
      IF (JM.GT.NMOL) THEN
      JM=1
      JQ=2
      END IF
      IF (JQ.EQ.1) THEN
      JJ=JJ+NEM(JM)/2
      ELSE
      JJ=JJ+NBAS(JM)-NEM(JM)/2
      END IF
      END IF
      IJ=IJ+1
      IF (IQ.EQ.JQ) THEN
      IF (IM.EQ.JM) GO TO 112
      IF (IQ.EQ.2) THEN
C     GO TO 112
      IF (IM.NE.NMORO-2*NMOL.AND.JM.NE.NMORO-2*NMOL) GO TO 112
      END IF
      ELSE
C     IF (NMORO.EQ.NMOL*2+JM) GO TO 112
      IF (NMORO.EQ.NMOL*2+JM.AND.IM.NE.JM) GO TO 112
      END IF
      H(IJ)=ZERO
  112 CONTINUE
  111 CONTINUE
      CALL DCOPY(L2,H,1,F,1)
C
      RETURN
      END
C*MODULE MOROKM  *DECK CTMOT4
      SUBROUTINE CTMOT4(H,F,W,SCR,NUM)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION H(*), F(*), W(*),SCR(*)
C
      PARAMETER (MXMOL=10)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
C
      ZERO=0.0D+00
      L1 = NUM
      L2 = NUM*(NUM+1)/2
      L3 =NUM**2
      CALL DAREAD(IDAF,IODA,W,L3,316,0)
      CALL TFTRI(H,F,W,SCR,L1,L1,L1)
C
      IJ=0
      IM=1
      IQ=1
      II=NEM(1)/2
      DO 111 I=1,L1
      IF (I.GT.II) THEN
      IM=IM+1
      IF (IM.GT.NMOL) THEN
      IM=1
      IQ=2
      END IF
      IF (IQ.EQ.1) THEN
      II=II+NEM(IM)/2
      ELSE
      II=II+NBAS(IM)-NEM(IM)/2
      END IF
      END IF
      JM=1
      JQ=1
      JJ=NEM(1)/2
      DO 112 J=1,I
      IF (J.GT.JJ) THEN
      JM=JM+1
      IF (JM.GT.NMOL) THEN
      JM=1
      JQ=2
      END IF
      IF (JQ.EQ.1) THEN
      JJ=JJ+NEM(JM)/2
      ELSE
      JJ=JJ+NBAS(JM)-NEM(JM)/2
      END IF
      END IF
      IJ=IJ+1
      IF (IQ.EQ.JQ) THEN
      IF (IQ.EQ.1) GO TO 112
      IF (I.EQ.J) GO TO 112
      END IF
      H(IJ)=ZERO
  112 CONTINUE
  111 CONTINUE
      CALL DCOPY(L2,H,1,F,1)
C
      RETURN
      END
C*MODULE MOROKM  *DECK CTMOT5
      SUBROUTINE CTMOT5(H,F,W,SCR,NUM)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION H(*), F(*), W(*),SCR(*)
C
      PARAMETER (MXMOL=10)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
C
      ZERO=0.0D+00
      L1 = NUM
      L2 = NUM*(NUM+1)/2
      L3 =NUM**2
      CALL DAREAD(IDAF,IODA,W,L3,316,0)
      CALL TFTRI(H,F,W,SCR,L1,L1,L1)
C
      IJ=0
      IM=1
      IQ=1
      II=NEM(1)/2
      DO 111 I=1,L1
      IF (I.GT.II) THEN
      IM=IM+1
      IF (IM.GT.NMOL) THEN
      IM=1
      IQ=2
      END IF
      IF (IQ.EQ.1) THEN
      II=II+NEM(IM)/2
      ELSE
      II=II+NBAS(IM)-NEM(IM)/2
      END IF
      END IF
      JM=1
      JQ=1
      JJ=NEM(1)/2
      DO 112 J=1,I
      IF (J.GT.JJ) THEN
      JM=JM+1
      IF (JM.GT.NMOL) THEN
      JM=1
      JQ=2
      END IF
      IF (JQ.EQ.1) THEN
      JJ=JJ+NEM(JM)/2
      ELSE
      JJ=JJ+NBAS(JM)-NEM(JM)/2
      END IF
      END IF
      IJ=IJ+1
      IF (IQ.EQ.JQ.AND.IQ.EQ.1) THEN
      GO TO 112
      ELSE IF (IQ.EQ.JQ.AND.IQ.EQ.2) THEN
      IF (J.EQ.I) GO TO 112
      IF (IM.EQ.NMORO-1000-NMOL.AND.JM.EQ.IM) GO TO 112
      ELSE
      IF (NMORO.EQ.1000+NMOL+IM) GO TO 112
      END IF
      H(IJ)=ZERO
  112 CONTINUE
  111 CONTINUE
      CALL DCOPY(L2,H,1,F,1)
C
      RETURN
      END
C*MODULE MOROKM  *DECK CTMOT6
      SUBROUTINE CTMOT6(H,F,W,SCR,NUM)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION H(*), F(*), W(*),SCR(*)
C
      PARAMETER (MXMOL=10)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
C
      ZERO=0.0D+00
      L1 = NUM
      L2 = NUM*(NUM+1)/2
      L3 =NUM**2
      CALL DAREAD(IDAF,IODA,W,L3,316,0)
      CALL TFTRI(H,F,W,SCR,L1,L1,L1)
C
      IJ=0
      IM=1
      IQ=1
      II=NEM(1)/2
      DO 111 I=1,L1
      IF (I.GT.II) THEN
      IM=IM+1
      IF (IM.GT.NMOL) THEN
      IM=1
      IQ=2
      END IF
      IF (IQ.EQ.1) THEN
      II=II+NEM(IM)/2
      ELSE
      II=II+NBAS(IM)-NEM(IM)/2
      END IF
      END IF
      JM=1
      JQ=1
      JJ=NEM(1)/2
      DO 112 J=1,I
      IF (J.GT.JJ) THEN
      JM=JM+1
      IF (JM.GT.NMOL) THEN
      JM=1
      JQ=2
      END IF
      IF (JQ.EQ.1) THEN
      JJ=JJ+NEM(JM)/2
      ELSE
      JJ=JJ+NBAS(JM)-NEM(JM)/2
      END IF
      END IF
      IJ=IJ+1
      IF (IQ.EQ.JQ) THEN
      IF (IM.EQ.JM) GO TO 112
      IF (IQ.EQ.2) THEN
      GO TO 112
C     IF (IM.NE.NMORO-4*NMOL.AND.JM.NE.NMORO-4*NMOL) GO TO 112
      END IF
      ELSE
      IF (NMORO.EQ.NMOL*4+JM) GO TO 112
C     IF (NMORO.EQ.NMOL*4+JM.AND.IM.NE.JM) GO TO 112
      END IF
      H(IJ)=ZERO
  112 CONTINUE
  111 CONTINUE
      CALL DCOPY(L2,H,1,F,1)
C
      RETURN
      END
C*MODULE MOROKM  *DECK CTMOT7
      SUBROUTINE CTMOT7(H,F,W,SCR,NUM)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION H(*), F(*), W(*),SCR(*)
C
      PARAMETER (MXMOL=10)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
C
      ZERO=0.0D+00
      L1 = NUM
      L2 = NUM*(NUM+1)/2
      L3 =NUM**2
      CALL DAREAD(IDAF,IODA,W,L3,314,0)
      CALL TFTRI(H,F,W,SCR,L1,L1,L1)
C
      NN=NMORO-1200-NMOL
      IJ=0
      IM=1
      IQ=1
      II=NEM(1)/2
      DO 111 I=1,L1
      IF (I.GT.II) THEN
      IM=IM+1
      IF (IM.GT.NMOL) THEN
      IM=1
      IQ=2
      END IF
      IF (IQ.EQ.1) THEN
      II=II+NEM(IM)/2
      ELSE
      II=II+NBAS(IM)-NEM(IM)/2
      END IF
      END IF
      JM=1
      JQ=1
      JJ=NEM(1)/2
      DO 112 J=1,I
      IF (J.GT.JJ) THEN
      JM=JM+1
      IF (JM.GT.NMOL) THEN
      JM=1
      JQ=2
      END IF
      IF (JQ.EQ.1) THEN
      JJ=JJ+NEM(JM)/2
      ELSE
      JJ=JJ+NBAS(JM)-NEM(JM)/2
      END IF
      END IF
      IJ=IJ+1
      IF (IQ.EQ.JQ.AND.IQ.EQ.1) THEN
C     IF (IM.EQ.JM) GO TO 112
C
      IF (I.EQ.J) GO TO 112
      IF (IM.EQ.JM.AND.IM.EQ.NN) GO TO 112
C
C     IF (IM.NE.NN.AND.JM.NE.NN) GO TO 112
      ELSE IF (IQ.EQ.JQ.AND.IQ.EQ.2) THEN
      IF (I.EQ.J) GO TO 112
      IF (IM.EQ.JM.AND.IM.EQ.NN) GO TO 112
      ELSE
      IF (IM.EQ.JM.AND.IM.EQ.NN) GO TO 112
      END IF
      H(IJ)=ZERO
  112 CONTINUE
  111 CONTINUE
      CALL DCOPY(L2,H,1,F,1)
C
      RETURN
      END
C*MODULE MOROKM  *DECK CTMOT8
      SUBROUTINE CTMOT8(H,F,W,SCR,NUM)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION H(*), F(*), W(*),SCR(*)
C
      PARAMETER (MXMOL=10)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
C
      ZERO=0.0D+00
      L1 = NUM
      L2 = NUM*(NUM+1)/2
      L3 =NUM**2
      CALL DAREAD(IDAF,IODA,W,L3,314,0)
      CALL TFTRI(H,F,W,SCR,L1,L1,L1)
C
      NN=NMORO-1000-2*NMOL
      IJ=0
      IM=1
      IQ=1
      II=NEM(1)/2
      DO 111 I=1,L1
      IF (I.GT.II) THEN
      IM=IM+1
      IF (IM.GT.NMOL) THEN
      IM=1
      IQ=2
      END IF
      IF (IQ.EQ.1) THEN
      II=II+NEM(IM)/2
      ELSE
      II=II+NBAS(IM)-NEM(IM)/2
      END IF
      END IF
      JM=1
      JQ=1
      JJ=NEM(1)/2
      DO 112 J=1,I
      IF (J.GT.JJ) THEN
      JM=JM+1
      IF (JM.GT.NMOL) THEN
      JM=1
      JQ=2
      END IF
      IF (JQ.EQ.1) THEN
      JJ=JJ+NEM(JM)/2
      ELSE
      JJ=JJ+NBAS(JM)-NEM(JM)/2
      END IF
      END IF
      IJ=IJ+1
      IF (IQ.EQ.JQ.AND.IQ.EQ.1) THEN
C     IF (IM.EQ.JM) GO TO 112
C
      IF (I.EQ.J) GO TO 112
      IF (IM.EQ.JM.AND.IM.EQ.NN) GO TO 112
C
C     IF (IM.NE.NN.AND.JM.NE.NN) GO TO 112
      ELSE IF (IQ.EQ.JQ.AND.IQ.EQ.2) THEN
      GO TO 112
      ELSE
      IF (JM.EQ.NN) GO TO 112
      END IF
      H(IJ)=ZERO
  112 CONTINUE
  111 CONTINUE
      CALL DCOPY(L2,H,1,F,1)
C
      RETURN
      END
C*MODULE MOROKM  *DECK CTMOTR
      SUBROUTINE CTMOTR(H,F,W,SCR,L1)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION H(*), F(*), W(*),SCR(*)
C
      PARAMETER (MXATM=2000, MXMOL=10)
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
C
      IF (NMORO.GT.1000.AND.NMORO.LE.1000+NMOL)
     *    CALL CTMOT1(H,F,W,SCR,L1,NE)
      IF (NMORO.GT.1200.AND.NMORO.LE.1200+NMOL)
     *    CALL CTMOT2(H,F,W,SCR,L1,NE)
      IF (NMORO.GT.NMOL*2.AND.NMORO.LE.NMOL*3)
     *    CALL CTMOT3(H,F,W,SCR,L1)
      IF (NMORO.GT.NMOL*3.AND.NMORO.LE.NMOL*4)
     *    CALL CTMOT4(H,F,W,SCR,L1)
      IF (NMORO.GT.1000+NMOL.AND.NMORO.LE.1000+2*NMOL)
     *    CALL CTMOT5(H,F,W,SCR,L1)
      IF (NMORO.GT.NMOL*4.AND.NMORO.LE.NMOL*5)
     *    CALL CTMOT6(H,F,W,SCR,L1)
      IF (NMORO.GT.1200+NMOL.AND.NMORO.LE.1200+2*NMOL)
     *    CALL CTMOT7(H,F,W,SCR,L1)
      IF (NMORO.GT.1000+2*NMOL.AND.NMORO.LE.1000+3*NMOL)
     *    CALL CTMOT8(H,F,W,SCR,L1)
C
      RETURN
      END
C*MODULE MOROKM  *DECK DNMOAO
      SUBROUTINE DNMOAO(D,W,V,VN,OCC,NA,L1,L2)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION D(L2),W(L2),V(L1,L1),VN(L1,L1),OCC(L1)
C
      CALL TRMOAO(W,V,VN,D,L1)
      CALL DMTX(D,VN,OCC,NA,L1,L1)
C     CALL DMTX(W,VN,OCC,NA,L1,L1)
C     CALL DCOPY(L2,W,1,D,1)
C
      RETURN
      END
C*MODULE MOROKM  *DECK EDRHF
      SUBROUTINE EDRHF(NUM,NA,NB,NE,E0)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXMOL=10)
C
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
      COMMON /SVINFO/ NAT0,ICH0,MUL0,NUM0,NE0,NA0,NB0,NDUM,EF
C
      IF (NMORO.NE.0) THEN
         NUM=NUM0
         NA=NA0
         NB=NB0
         NE=NE0
      END IF
      EF = E0
      RETURN
      END
C*MODULE MOROKM  *DECK GESSMO
      SUBROUTINE GESSMO
C
C     **********************
C     ROUTINE FOR INITIAL MO
C     **********************
C     MONOMER AND MONOMER BSSE NOT CALL THIS ROUTINE (1<=NMORO<=2*NMOL)
C     NMORO = 100 FOR E3 AND E4
C     NMORO = 200 FOR E1 AND E2 (TOTAL)
C     NMORO: 2*NMOL+1 -> 3*NMOL BSSE VIR
C     NMORO: 3*NMOL+1 -> 4*NMOL BSSE OCC
C     NMORO: 4*NMOL+1 -> 5*NMOL BSSE OCC (ORTHO FOR RVS)
C     NMORO: 1001 -> 1000+NMOL E6(IM) (ALSO E5) (CT)
C     NMORO: 1001+NMOL -> 1000+2*NMOL E7(IM) (CTPLX)
C     NMORO: 1201 -> 1200+NMOL E2(IM) (PL)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL DOQAO,DOQMO,DOMOR,DOOTH,DOREO
C
      PARAMETER (MXATM=2000, MXMOL=10)
C
      COMMON /FMCOM / XX(1)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
C
      DATA SAVDMO/8HMOSAVED /
      DATA ZERO,ONE/0.0D+00,1.0D+00/
C
      L0 = 0
      L1 = NUM
      L3 = L1 * L1
      L2 = ( L3 + L1 ) / 2
      L5 = 0
      DO 50 IM = 1, NMOL
         NDUM = NBAS(IM)**2
         L5 = L5 + NDUM
   50 CONTINUE
C
      CALL VALFM(LOADFM)
C
      LIWRK = LOADFM+1
      LS     = LIWRK  + L1
      LQ     = LS     + L2
      LV     = LQ     + L3
      LE     = LV     + L3
      LSCR   = LE     + L1
      LH     = LSCR   + 8*L1
C     LWRK   = LH     + MAX0(L5, L2)
      LWRK   = LH     + L3
C     LAST   = LWRK   + L5
      LAST   = LWRK   + L3
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      DOQAO = .FALSE.
      DOQMO = .FALSE.
      DOMOR = .FALSE.
      DOOTH = .FALSE.
      DOREO = .FALSE.
      IF ((NMORO.GT.1000+2*NMOL.AND.NMORO.LE.1000+3*NMOL).OR.
     *    (NMORO.GT.1200+NMOL.AND.NMORO.LE.1200+2*NMOL)) THEN
         DOQAO = .TRUE.
         DOREO = .TRUE.
         DOOTH = .TRUE.
         NN = NMORO-NMOL-1200
         IF (NN.LT.0) NN = NMORO-1000-2*NMOL
         GO TO 99
      END IF
C
      IF (NMORO.GT.2*NMOL.AND.NMORO.LE.5*NMOL) THEN
         DOQMO = .TRUE.
         DOMOR = .TRUE.
         GO TO 99
      END IF
C
      IF (NMORO.LT.1000) THEN
         DOQAO = .TRUE.
         IF (NMORO.EQ.100) DOOTH = .TRUE.
         GO TO 99
      END IF
C
      IF (NMORO.GT.1000) THEN
         DOQMO = .TRUE.
      END IF
C
C     FIND THE Q MATRIX IN AO BASIS
C     (FOR ORTHO BSSE, Q IN AO IS NEEDED FOR ORTHONORMAL)
C
   99 IF (.NOT.DOQAO) GO TO 100
      CALL DAREAD(IDAF,IODA,XX(LS),L2,12,0)
      CALL QMTSYM(XX(LS),XX(LV),XX(LQ),XX(LE),XX(LSCR),XX(LIWRK),
     *            L0,L1,L2,L3,.FALSE.)
      IF (NMORO.EQ.100.OR.NMORO.EQ.200)
     *   CALL DAWRIT(IDAF,IODA,XX(LQ),L3,45,0)
C
C     GET INITIAL MO'S
C
  100 CALL MOINIT(XX(LV),XX(LH),XX(LWRK),NE,L1,L3)
C
C     REORDER TO PARTICULAR ORDER
C
      IF (DOREO) CALL CHGODF(XX(LV),XX(LH),L1,NN,NE,NMOL,NBAS,NEM)
C
C     OTHORGONIZATION
C     NMORO = 200 DOES NOT REQUIRE ORTHOGONIZATION
C     NMORO = 1000 VEC IS A UNIT MATRIX UNDER MO(0) BASIS
C
      IF (.NOT.DOOTH) GO TO 300
      CALL DAREAD(IDAF,IODA,XX(LS),L2,12,0)
      CALL ORTHO(XX(LQ),XX(LS),XX(LV),XX(LSCR),L0,L0,L1,L2,L1)
      CALL TFSQB(XX(LV),XX(LQ),XX(LSCR),L0,L1,L1)
C
C     PUT BACK TO ORIGINAL ORDER
C     IN THIS CASE S IN MO IS ALREADY DIAGNAL
C
  300 IF (DOREO) THEN
         CALL CHGODB(XX(LV),XX(LH),L1,NN,NE,NMOL,NBAS,NEM)
         IJ = LS - 1
         DO 299 I = 1, L1
         DO 299 J = 1, I
            IJ = IJ + 1
            IF (I.EQ.J) XX(IJ) = ONE
            IF (I.NE.J) XX(IJ) = ZERO
  299    CONTINUE
         CALL DAWRIT(IDAF,IODA,XX(LS),L2,12,0)
         CALL RUNITV(L1,L1,XX(LQ))
         CALL DAWRIT(IDAF,IODA,XX(LQ),L3,45,0)
      END IF
C
C     INITIAL MO UNDER AO'S IS SAVED IN FILE 15 IN ORDER
C     TO GET INITIAL DENSITY UNDER AO'S BASIS.
C
      CALL DAWRIT(IDAF,IODA,XX(LV),L3,15,0)
C
C     FIND THE Q MATRIX IN MO BASIS
C     FOR NMORO => 1000 OR NMOL*2 < NMORO <= NMOL*5
C
      IF (.NOT.DOQMO) GO TO 310
      CALL DAREAD(IDAF,IODA,XX(LS),L2,12,0)
      CALL CTMOTR(XX(LH),XX(LS),XX(LWRK),XX(LSCR),L1)
      CALL DAWRIT(IDAF,IODA,XX(LS),L2,12,0)
      CALL QMTSYM(XX(LS),XX(LV),XX(LQ),XX(LE),XX(LSCR),XX(LIWRK),
     *            L0,L1,L2,L3,.FALSE.)
      CALL DAWRIT(IDAF,IODA,XX(LQ),L3,45,0)
C
  310 CALL RETFM(NEED)
C
C     GENERATE INITIAL DENSITY MATRIX
C
      LDA = LOADFM+1
      LV  = LDA + L2
      LE  = LV  + L3
      LOCC= LE  + L1
      NEED = LAST - LDA
      CALL GETFM(NEED)
      IDUMMY=0
      DUMMY=0.0D+00
      IF (DOMOR) THEN
         NN = NMORO - 2*NMOL
  449    IF (NN.LE.NMOL) GO TO 450
         NN = NN - NMOL
         GO TO 449
  450    NET = NEM(NN)/2
         NST = 1
         DO 500 I = 1, NN - 1
            NST = NST + NEM(I)/2
  500    CONTINUE
      ELSE
         NET = NA
         NST = 1
      END IF
      CALL INIDEN(SAVDMO,XX(LV),XX(LDA),XX(LDA),XX(LE),
     *            XX(LOCC),DUMMY,DUMMY,DUMMY,DUMMY,IDUMMY,0,
     *            IDUMMY,IDUMMY,L1,L2,L3,.FALSE.,.FALSE.,.FALSE.,
     *            .FALSE.,.FALSE.,NET,NST,L1,L2,L3)
      CALL RETFM(NEED)
C
      RETURN
      END
C*MODULE MOROKM  *DECK INDDEN
      SUBROUTINE INDDEN(NUM,NA,NST)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      COMMON /FMCOM / XX(1)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
      DATA SAVDMO/8HMOSAVED /
C
      L1 = NUM
      L3 = L1 * L1
      L2 = ( L3 + L1 ) / 2
      CALL VALFM(LOADFM)
C
      LDA = LOADFM+1
      LV  = LDA + L2
      LE  = LV  + L3
      LOCC= LE  + L1
      LAST = LOCC+ L1
      NEED = LAST - LDA
      CALL GETFM(NEED)
      IDUMMY=0
      DUMMY=0.0D+00
      CALL RUNITV(L1,L1,XX(LV))
      CALL DAWRIT(IDAF,IODA,XX(LV),L3,15,0)
      CALL INIDEN(SAVDMO,XX(LV),XX(LDA),XX(LDA),XX(LE),
     *            XX(LOCC),DUMMY,DUMMY,DUMMY,DUMMY,IDUMMY,0,
     *            IDUMMY,IDUMMY,L1,L2,L3,.FALSE.,.FALSE.,.FALSE.,
     *            .FALSE.,.FALSE.,NA,NST,L1,L2,L3)
C
      CALL RETFM(NEED)
C
      RETURN
      END
C*MODULE MOROKM  *DECK MOIJKL
      SUBROUTINE MOIJKL(XX,IX,YY,IY,NINTMX,NOPK)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXMOL=10)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCKLAB/ LABSIZ
C
      DIMENSION XX(NINTMX),IX(*),YY(NINTMX),IY(*)
C
      DATA IJKO/24/
C
      NREC = 0
      NINTO = 0
      IF(MASWRK) WRITE(IW,3000) NMORO,IJKO
C
C     CHECK OPTION
C
      IF (NMORO.LT.1.OR.NMORO.GT.NMOL) THEN
         IF (MASWRK) WRITE(IW,1000) NMORO
         CALL ABRT
      END IF
C
      NXX = 0
      MN = 1
C
      IF (IS.EQ.IJKO) IS = 8
      CALL SEQREW(IS)
      CALL SEQREW(IJKO)
      IF (NOPK .NE. 1) GO TO 300
C
C     ----- INTEGRALS ARE NOT IN SUPERMATRIX FORM (NOPK=.TRUE.) -----
C
  120 CONTINUE
      CALL PREAD(IJKO,XX,IX,NXX,NINTMX)
      IF (NXX .EQ. 0) GO TO 400
      NINT = IABS(NXX)
      IF (NINT .GT. NINTMX) CALL ABRT
      DO 200 M = 1,NINT
C
                       NPACK = M
                       IF (LABSIZ .EQ. 2) THEN
*I32                     LABEL = IX( 2*NPACK - 1 )
*I32                     IPACK = ISHFT( LABEL, -16 )
*I32                     JPACK = IAND(  LABEL, 65535 )
*I32                     LABEL = IX( 2*NPACK     )
*I32                     KPACK = ISHFT( LABEL, -16 )
*I32                     LPACK = IAND(  LABEL, 65535 )
*I64                     LABEL = IX(NPACK)
*I64                     IPACK = ISHFT( LABEL, -48 )
*I64                     JPACK = IAND( ISHFT( LABEL, -32 ), 65535 )
*I64                     KPACK = IAND( ISHFT( LABEL, -16 ), 65535 )
*I64                     LPACK = IAND( LABEL, 65535 )
                       ELSE IF (LABSIZ .EQ. 1) THEN
*I32                     LABEL = IX(NPACK)
*I32                     IPACK = ISHFT( LABEL, -24 )
*I32                     JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
*I32                     KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
*I32                     LPACK = IAND( LABEL, 255 )
*I64                     IF ( MOD(NPACK,2) .EQ. 0 ) THEN
*I64                       LABEL = IX( NPACK/2 )
*I64                       IPACK = IAND( ISHFT( LABEL, -24 ), 255 )
*I64                       JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
*I64                       KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
*I64                       LPACK = IAND( LABEL, 255 )
*I64                     ELSE
*I64                       LABEL = IX( (NPACK/2)+1 )
*I64                       IPACK = ISHFT( LABEL, -56 )
*I64                       JPACK = IAND( ISHFT( LABEL, -48 ), 255 )
*I64                       KPACK = IAND( ISHFT( LABEL, -40 ), 255 )
*I64                       LPACK = IAND( ISHFT( LABEL, -32 ), 255 )
*I64                     END IF
                       END IF
                       I = IPACK
                       J = JPACK
                       K = KPACK
                       L = LPACK
C
         IF (NMORO.EQ.1) THEN
            IF (I.GT.NBAS(1)) GO TO 200
            IF (LABSIZ.EQ.1) THEN
              IY(MN)=IX(M)
            ELSE
              IY(2*MN-1) = IX(2*M-1)
              IY(2*MN  ) = IX(2*M  )
            END IF
         ELSE
            IF (L.LE.NLOC(NMORO)) GO TO 200
            IF (J.LE.NLOC(NMORO)) GO TO 200
            IF (NMORO.LT.NMOL) THEN
               IF (I.GT.NLOC(NMORO+1)) GO TO 200
               IF (K.GT.NLOC(NMORO+1)) GO TO 200
            END IF
            I = I-NLOC(NMORO)
            J = J-NLOC(NMORO)
            K = K-NLOC(NMORO)
            L = L-NLOC(NMORO)
C
               NPACK = MN
               IPACK = I
               JPACK = J
               KPACK = K
               LPACK = L
               IF (LABSIZ .EQ. 2) THEN
*I32             IY( 2*NPACK-1 ) = ISHFT( IPACK, 16 ) + JPACK
*I32             IY( 2*NPACK   ) = ISHFT( KPACK, 16 ) + LPACK
*I64             LABEL = ISHFT( IPACK, 48 ) + ISHFT( JPACK, 32 ) +
*I64 *                   ISHFT( KPACK, 16 ) + LPACK
*I64             IY(NPACK) = LABEL
               ELSE IF (LABSIZ .EQ. 1) THEN
*I32             LABEL = ISHFT( IPACK, 24 ) + ISHFT( JPACK, 16 ) +
*I32 *                   ISHFT( KPACK,  8 ) + LPACK
*I32             IY(NPACK) = LABEL
*I64             IF ( MOD(NPACK,2) .EQ. 0 ) THEN
*I64               LABEL = ISHFT( IPACK, 24 ) + ISHFT( JPACK, 16 ) +
*I64 *                     ISHFT( KPACK,  8 ) + LPACK
*I64               IY( NPACK/2 ) = IY( NPACK/2 ) + LABEL
*I64             ELSE
*I64               LABEL = ISHFT( IPACK, 56 ) + ISHFT( JPACK, 48 ) +
*I64 *                     ISHFT( KPACK, 40 ) + ISHFT( LPACK, 32 )
*I64               IY( (NPACK/2)+1 ) = LABEL
*I64             END IF
               END IF
C
         END IF
C
         YY(MN)=XX(M)
         MN=MN+1
         IF (MN.GT.NINTMX) THEN
            NREC=NREC+1
            NINTO = NINTO+MN
            CALL PWRIT(IS,YY,IY,NINTMX,NINTMX)
            MN=1
         END IF
C
  200 CONTINUE
C
      IF (NXX .GT. 0) GO TO 120
C
C     DONE CONSTRUCTING MATRIX, OFF DIAGONAL ELEMENTS NEED HALVING
C
      GO TO 400
C
C     ----- INTEGRALS ARE IN SUPERMATRIX FORM (NOPK=.FALSE.) -----
C
  300 CONTINUE
      WRITE(IW,*)' CANNOT SORT INT2 WITH NOPK=.FALSE.'
      CALL ABRT
C
C     ----- FINAL CLEANING UP -----
C
  400 CONTINUE
      MN=MN-1
      NINTO = NINTO+MN
      NREC=NREC+1
      MN=-MN
      CALL PWRIT(IS,YY,IY,MN,NINTMX)
      CALL SEQREW(IS)
      IF (MASWRK) WRITE(IW,2000) NINTO,NREC,NINTMX,IS
C
      CALL SEQREW(IJKO)
      RETURN
C
 1000 FORMAT(1X,'OPTION IN MOIJKL IS NOT CORRECT, NMORO = ',I2)
 2000 FORMAT(1X,I10,' INTEGRALS IN',I7,' RECORDS OF',I6,
     *       ' INTEGRALS WRITTEN ON UNIT',I3)
 3000 FORMAT(//1X,'SIFTING INTEGRALS FOR MONOMER',I4,' FROM FILE',I4)
      END
C*MODULE MOROKM  *DECK MOINIT
      SUBROUTINE MOINIT(V,H,WRK,NE,L1,L3)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXMOL=10)
C
      DIMENSION V(*),H(*),WRK(*)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
      SAVE IFIRST
C
      DATA IFIRST/1/
C
C     READ IN DICTNRY 313 TO FORM INITIAL GUESS
C
      IF (IFIRST.EQ.0) THEN
         CALL DAREAD(IDAF,IODA,V,L3,316,0)
         RETURN
      END IF
C
      CALL VCLR(V,1,L3)
C
      L5 = 0
      L6 = 1
      DO 100 IMOL = 1, NMOL
         L5 =  L5 + NBAS(IMOL)**2
         L6 =  L6 + NBAS(IMOL)*NEM(IMOL)/2
  100 CONTINUE
C
      CALL DAREAD(IDAF,IODA,H,L5,313,0)
      NSFT1 = 1
      NSFT2 = 1
      NSFT3 = 1
      NSFT4 = L6
      L7 = 1
      L8 = L1*NE/2 + 1
      DO 300 IM = 1, NMOL
         NT = NBAS(IM)
         NO = NEM(IM)/2
         NV = NT - NO
         NSFT3 = NSFT3 + NT*NO
         IF (IFIRST.EQ.1) THEN
            CALL DCOPY(NT*NO,H(NSFT1),1,WRK(NSFT2),1)
            CALL DCOPY(NT*NV,H(NSFT3),1,WRK(NSFT4),1)
         END IF
         NSFT5 = L7
         DO 200 I = 1, NT
            CALL DCOPY(NT,H(NSFT1),1,V(NSFT5),1)
            NSFT1 = NSFT1 + NT
            NSFT5 = NSFT5 + L1
            IF (I.EQ.NO) NSFT5 = L8
  200    CONTINUE
         L7 = L7 + L1*NO + NT
         L8 = L8 + L1*NV + NT
         NSFT2 = NSFT2 + NT*NO
         NSFT3 = NSFT1
         NSFT4 = NSFT4 + NT*NV
  300 CONTINUE
C
      IF (IFIRST.EQ.1) THEN
         CALL DAWRIT(IDAF,IODA,WRK,L5,315,0)
         CALL DAWRIT(IDAF,IODA,V,L3,316,0)
      END IF
C
      IFIRST=0
      RETURN
      END
C*MODULE MOROKM  *DECK MOMEM
      SUBROUTINE MOMEM(NINTMX)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,TDSKWRK
C
      PARAMETER (MXATM=2000, MXMOL=10)
C
      COMMON /FMCOM / XX(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      DATA CHECK/8HCHECK   /
C
C     PARALLEL
C
      TDSKWRK = DSKWRK
      DSKWRK  = .TRUE.
C
C     LOCATING MEMORY
C
      CALL VALFM(LOADFM)
      I10  = LOADFM + 1
      IF (NMORO.GT.0.AND.NMORO.LE.NMOL) THEN
         I20  = I10    + NINTMX
         I30  = I20    + NINTMX
         I40  = I30    + NINTMX
         I50  = I40    + NINTMX
      ELSE IF (NMORO.GT.1000.OR.(NMORO.GT.3*NMOL.AND.NMORO.LE.5*NMOL))
     *        THEN
         L2   = NUM*(NUM+1)/2
         I50  = I10 + L2
      ELSE
         RETURN
      END IF
      NEED = I50 - LOADFM - 1
      CALL GETFM(NEED)
C
      IF (NMORO.GT.1000.OR.(NMORO.GT.3*NMOL.AND.NMORO.LE.5*NMOL)) THEN
         CALL DAREAD(IDAF,IODA,XX(I10),L2,311,0)
         CALL DAWRIT(IDAF,IODA,XX(I10),L2,11,0)
         CALL DAREAD(IDAF,IODA,XX(I10),L2,312,0)
         CALL DAWRIT(IDAF,IODA,XX(I10),L2,12,0)
      ELSE
         IF(NMORO.GT.0  .AND.  NMORO.LE.NMOL  .AND.  EXETYP.NE.CHECK)
     *       CALL MOIJKL(XX(I10),XX(I20),XX(I30),XX(I40),NINTMX,NOPK)
      END IF
      CALL RETFM(NEED)
C
C     SET BACK FOR DSKWRK
C
      DSKWRK  = TDSKWRK
C
      RETURN
      END
C*MODULE MOROKM  *DECK MOROIN
      SUBROUTINE MOROIN
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION MOROKUMA
C
      PARAMETER (NNAM=9)
      PARAMETER (MXATM=2000, MXMOL=10,KQMX=101)
C
      DIMENSION QNAM(NNAM),KQNAM(NNAM),IATM(MXMOL)
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL DOBSSE,CTPPL,CTPLX,MOROKM,RVS,RDENG
C
      COMMON /BASSPH/ QMTTOL,ISPHER
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IRDENG
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA MOROKUMA/8HMOROKM  /
      DATA QNAM/8HIATM    ,8HICHM    ,8HEQUM    ,8HBSSE    ,8HCTPSPL  ,
     *          8HCTPLX   ,8HMOROKM  ,8HRVS     ,8HRDENG   /
      DATA KQNAM/KQMX,KQMX,KQMX,0,0,0,0,0,0/
C
      DO 100 IM = 1, MXMOL
         IATM(IM) = 0
         ICHM(IM) = 0
         MONO(IM) = 0
         IEQM(IM) = 0
  100 CONTINUE
      IBSSE = 0
      ICTPPL = 1
      ICTPLX = 0
      IMOROX = 1
      IRVS = 0
      IRDENG = 0
      DOBSSE = .FALSE.
      CTPPL = .TRUE.
      CTPLX = .FALSE.
      MOROKM = .TRUE.
      RVS = .FALSE.
      RDENG=.FALSE.
C
C    ----- READ NAMELIST $MOROKM -----
C
      CALL NAMEIO(IR,JRET,MOROKUMA,NNAM,QNAM,KQNAM,
     *            IATM,ICHM,IEQM,DOBSSE,CTPPL,CTPLX,MOROKM,
     *            RVS,RDENG,
     *            0,0,0,0,0,
     *   0,0,0,0,0,   0,0,0,0,0,
     *   0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,  0,0,0,0,0,
     *   0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,  0,0,0,0,0)
      IF(JRET.EQ.2) THEN
         IF (MASWRK) WRITE(IW,9000)
         CALL ABRT
      END IF
C
      MONO(1) = 1
      ICHT = ICHM(1)
      IF (IATM(1).EQ.0) THEN
         MONO(2) = NAT/2 + 1
         ICHM(2) = ICH - ICHM(1)
         GO TO 300
      END IF
C
      DO 200 IM = 2, MXMOL
         MONO(IM) = MONO(IM-1) + IATM(IM-1)
         IF (MONO(IM).GT.NAT) THEN
            MONO(IM)=0
            GO TO 300
         ELSE IF (IATM(IM).EQ.0.AND.ICHM(IM).EQ.0) THEN
            ICHM(IM) = ICH - ICHT
            GO TO 300
         END IF
         ICHT = ICHT + ICHM(IM)
  200 CONTINUE
C
  300 DO 400 IM = 1, MXMOL
         IF (IEQM(IM).EQ.IM) IEQM(IM) = 0
         IF (IEQM(IM).GT.IM) THEN
         IF (IEQM(IM).GT.MXMOL) IEQM(IM) = 0
            IJ = IEQM(IM)
            IEQM(IJ) = IM
            IEQM(IM) = 0
         END IF
  400 CONTINUE
C
      IF (DOBSSE) IBSSE = 1
      IF (.NOT.CTPPL) ICTPPL = 0
      IF (.NOT.CTPPL) IBSSE  = 0
      IF (CTPLX) ICTPLX = 1
      IF (RDENG) IRDENG = 1
      IF (.NOT.MOROKM) THEN
         IMOROX = 0
         IBSSE = 0
         ICTPPL = 0
         ICTPLX = 0
      END IF
      IF (RVS) IRVS = 1
      IF (IRVS.EQ.0.AND.IMOROX.EQ.0) THEN
          WRITE(IW,*)' NO CALCULATION IS REQUIRED'
          WRITE(IW,*)' MOROKM = .F. AND RVS = .F.'
          CALL ABRT
      END IF
C
      IF(ISPHER.EQ.1) THEN
         IF(MASWRK) WRITE(IW,9010)
         CALL ABRT
         STOP
      END IF
C
      RETURN
C
 9000 FORMAT(1X,'ERROR IN $MOROKM INPUT')
 9010 FORMAT(///1X,'*** JOB KILLED ***'/1X,'SORRY, RUNTYP=MOROKUMA',
     *          ' AND ISPHER=1 ARE PRESENTLY INCOMPATIBLE')
      END
C*MODULE MOROKM  *DECK MOROST
      SUBROUTINE MOROST
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXSH=5000, MXGTOT=20000, MXMOL=10)
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),MIN(MXSH),MAX(MXSH),NSHELL
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /SVINFO/ NAT0,ICH0,MUL0,NUM0,NE0,NA0,NB0,NDUM,EF
C
C     DETERMINE HOW MANY MONOMERS
C
      NMOL = MXMOL
      DO 100 IMOL = 1, MXMOL
         IF (MONO(IMOL).NE.0) GO TO 100
         NMOL = IMOL - 1
         GO TO 101
  100 CONTINUE
C
  101 IF (NMOL.LE.1) THEN
         IF (MASWRK) WRITE(IW,1000)
         CALL ABRT
      END IF
C
C     DETERMINE HOW MANY BASIS FOR EACH MONOMER
C
      K0 = 1
      IST = 1
      NLOC(1) = 0
      NSHLLS(1) = 1
      DO 250 IMOL = 2, NMOL
         DO 200 II = IST, NSHELL
            I = KATOM(II)
            IF (I.NE.MONO(IMOL)) GO TO 200
            NBAS(IMOL-1) = KLOC(II)-K0
            NLOC(IMOL) = KLOC(II)-1
            K0 = KLOC(II)
            NSHLLS(IMOL) = II
            IST = II + 1
            GO TO 250
  200    CONTINUE
  250 CONTINUE
      NBAS(NMOL) = NUM - K0 + 1
C
C     DETERMINE HOW MANY ELECTRONS FOR EACH MONOMER
C
      NE0 = 0
      DO 350 IMOL = 1, NMOL
         NEM(IMOL) = -ICHM(IMOL)
         IST = MONO(IMOL)
         IF (IMOL.LT.NMOL) IEND = MONO(IMOL+1)-1
         IF (IMOL.EQ.NMOL) IEND = NAT
         DO 300 I = IST, IEND
            NEM(IMOL) = NEM(IMOL) + INT(ZAN(I))
  300    CONTINUE
      NE0 = NE0 + NEM(IMOL)
  350 CONTINUE
C
C     CHECK TOTAL ELECTRONS
C
      IF (NE0 .NE. NE) THEN
         IF (MASWRK) WRITE(IW,2000)
         CALL ABRT
      END IF
C
C     MUST BE CLOSE SHELL
C
      DO 400 IMOL = 1, NMOL
         IF (MOD(NEM(IMOL),2) .NE. 0) THEN
            IF (MASWRK) THEN
               WRITE(IW,2000) NMOL
               WRITE(IW,2010) (MONO(III),III=1,NMOL)
               WRITE(IW,2020) (ICHM(III),III=1,NMOL)
            END IF
            CALL ABRT
         END IF
  400 CONTINUE
C
      NAT0 = NAT
      ICH0 = ICH
      MUL0 = MUL
      NUM0 = NUM
      NE0 = NE
      NA0 = NA
      NB0 = NB
      RETURN
C
 1000 FORMAT(/1X,'TOTAL NUMBER OF MONOMERS ARE LESS THAN TWO',/)
 2000 FORMAT(/1X,'TOTAL NUMBER OF ELECTRONS IN SUPER MOLECULE IS '/
     *        1X,'NOT EQUAL TO THE SUM OF THOSE IN MONOMERS'/
     *        1X,'A. IF YOU HAVE USED SYMMETRY UNIQUE INPUT IN $DATA,'/
     *        1X,'USE C1 SYMMETRY INSTEAD.'/
     *        1X,'B. CHECK YOUR INPUT IN $MOROKM: NO.MONOMERS=',I4)
 2010 FORMAT( 1X,'MONOMER STARTING ATOMS=',10I4)
 2020 FORMAT( 1X,' MONOMER CHARGE VALUES=',10I4)
      END
C
C*MODULE MOROKM  *DECK MOROX
      SUBROUTINE MOROX
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXSH=5000, MXMOL=10,MXES=MXMOL*10+2, MXATM=2000)
C
      DIMENSION EM(MXMOL*5),E2(MXMOL),E6(MXMOL),ECTB(MXMOL),EEXB(MXMOL),
     *          E7(MXMOL),E8(MXMOL),E9(MXMOL),ECPXB(MXMOL),ESAVE(MXES)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,PACK2E,DIRSCF,FDIFF,SVGPAR,CALINT
C
      COMMON /BASSPH/ QMTTOL,ISPHER
      COMMON /CONV  / DENTOL,EN,ETOT,EHF,EHF0,DIFF,ITER,ICALP,ICBET
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IRDENG
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /ORDOPT/ NORDER,NDAR,LDAR,NBOXMX,NWORD,NOMEM,NSQUAR
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /SVINFO/ NAT0,ICH0,MUL0,NUM0,NE0,NA0,NB0,NDUM,EF
      COMMON /SCFOPT/ CONVHF,MAXIT,MCONV,NPUNCH,NPREO(4)
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                T(432),INVT(48),NT
      COMMON /TMVALS/ TI,TX,TIM
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DATA RHF/8HRHF     /
      DATA ZERO/0.00D+00/, TOKCAL/627.51D+00/
      DATA SMALL/1.00D-07/
C
C********************************************************************
C     THIS IS A MAIN DRIVE FOR MOROKUMA ANALYSIS. RESTART IS ONLY FOR
C     SAVING 2- ELECTRON INTEGRALS
C********************************************************************
C
C     COMMON /MOINFO/
C     NMORO:  CONTROL MOROKUMA ANALYSIS
C             =    0 : SUPER MOLECULE (FOR THE CASE OF 100 AND 200)
C             <=NMOL : MONOMER
C             =  100 : GET E3 AND E4
C             = 10II : GET E5 AND E6 SPLIT
C             =  200 : GET E1 AND E2
C             = 12II : GET E1 AND E2 SPLIT
C     NMOL  : TOTAL NUMBER OF MONOMER, DEFAULT IS TWO
C     MONO  : STARTING ATOM FOR EACH MONOMER
C     NSHLLS: STARTING SHELL OF EACH MONOMER
C     NBAS  : TOTAL NUMBER OF BASIS SET FOR EACH MONOMER
C     NEM   : TOTAL NUMBER OF ELECTRONS FOR EACH MONOMER
C     ICHM  : MONOMER CHARGE
C     NLOC: OFFSET OF BASIS SET FOR EACH MONOMER
C
C     DICTNRY FILE
C     311: COPY OF 11 FOR SUPER AO BASIS (HCORE) [NUM*(NMU+1)/2]
C     312: COPY OF 12 FOR SUPER AO BASIS (OVERLAP) [NUM*(NMU+1)/2]
C     313: 0-TH ORDER MO COEFFICENTS (SUM OVER EACH MONOMER)
C          [SUM NBAS(I)**2]
C     314: ORTHONORMAL 0-TH ORDER MO COEFFICENTS (FROM 316) [NUM**2]
C     315: 0-TH ORDER MO COEFFICENTS (ORDER AS OCC THEN VIR)
C          [SUM NBAS(I)**2]
C     316: 0-TH ORDER MO COEFFICENTS (ORDER AS OCC THEN VIR) [NUM**2]
C
      DO 10 I=1,NMOL
         E2(I) = ZERO
         E6(I) = ZERO
         E7(I) = ZERO
         E8(I) = ZERO
         E9(I) = ZERO
   10 CONTINUE
C
      NERR=0
C
C     DIRECT SCF IS NOT IMPLEMENTED FOR MOROKUMA ANALYSIS
C
      IF (DIRSCF) THEN
         IF (MASWRK) WRITE(IW,1400)
         NERR=NERR+1
      END IF
C
C     AT PRESENT, SPHERICAL HARMONICS ARE NOT PERMITTED
C
      IF(ISPHER.EQ.1) THEN
         IF(MASWRK) WRITE(IW,1500)
         NERR=NERR+1
      END IF
C
C     ONLY SCFTYP=RHF IS PERMITTED NOW
C
      IF (SCFTYP.NE.RHF) THEN
        IF (MASWRK) WRITE(IW,1600)
        NERR=NERR+1
      END IF
C
      IF(NERR.GT.0) THEN
         IF(MASWRK) WRITE(IW,1900)
         CALL ABRT
      END IF
C
C     SYMMETRY IS NOT USED IN MOROKUMA ANALYSIS
C
      IF (MASWRK) WRITE(IW,2000)
      NT=1
C
C     NORDER NOT ACTIVE IN MOROKUMA ANALYSIS
C
      IF (NORDER.EQ.1) THEN
        NORDER = 0
        IF (MASWRK) WRITE(IW,3000)
      END IF
C
C     GET THE STARTING NUMBER OF MONOMER
C
      CALL MOROIN
C
C     ESAVE FOR READING IN ENERGIES
C
      CALL RDENG(ESAVE,IES)
      IND=1
C
C     SETUP CHECKING
C
      NMORO=0
      CALL MOROST
C
C     2E INTEGRALS FOR SUPPER MOLECULE
C
      SVGPAR = GOPARR
      GOPARR = .TRUE.
      IF(IREST.LE.1) CALL JANDK
      GOPARR = SVGPAR
      IF(TIM.GE.TIMLIM) GO TO 120
C
C     GO FOR MONOMER
C
      E0M = ZERO
      DO 100 IM = 1, NMOL
         IREST=0
         NMORO = IM
         IF (MASWRK) WRITE(IW,5000)NMORO
C     ----- 1E- INTEGRALS -----
         CALL ONEEI
C     ----- PREPARE INITIAL ORBITALS -----
         CALL GUESMO(GUESS)
C     ----- 2E- INTEGRALS -----
         CALL MOMEM(NINTMX)
C     ----- RHF RUN -----
         CALL MOSCF
C     ----- RHF SAVE MOLECULE ORBITALS TO 313 -----
         CALL SAVORB
C     ----- TOTAL MONOMER ENERGY -----
         EM(NMORO) = ETOT
         E0M = E0M + ETOT
C     CHECK IF IRDENG
         IF (IRDENG.EQ.1.AND.IND.LE.IES) THEN
            IF (ABS(ETOT-ESAVE(IND)).GT.SMALL) THEN
               IF (MASWRK) WRITE(IW,8500)
               CALL ABRT
            END IF
            IND=IND+1
         END IF
C     ----- CHECK TIME -----
         IF(TIM.GE.TIMLIM) GO TO 120
  100 CONTINUE
C
C     INT2 IS SAVED AT SEQFILE 24 SO IS SHOULD BE SET TO 24
C
      ISSV = IS
      IS = 24
C
C     BSSE (J=1: FULL BSSE; J=2: VIR; J=3: OCC;
C           J=4: VIR WITH OCC + ALL VIR)
C
      IF (IBSSE.EQ.0.AND.IRVS.EQ.0) GO TO 206
C
      E0S = ZERO
      DO 205 IM = 1, NMOL
         IF (IEQM(IM).NE.0) THEN
            JM = IEQM(IM)
            IF (IBSSE.EQ.0) GO TO 201
            N1 = NMOL + IM
            N2 = NMOL + JM
            EM(N1) = EM(N2)
            E0S = E0S +EM(N1)
            N1 = N1 + NMOL
            N2 = N2 + NMOL
            EM(N1) = EM(N2)
            N1 = N1 + NMOL
            N2 = N2 + NMOL
            EM(N1) = EM(N2)
  201       IF (IRVS.EQ.0) GO TO 205
            N1 = 4*NMOL + IM
            N2 = 4*NMOL + JM
            EM(N1) = EM(N2)
            GO TO 205
         END IF
         IREST=0
         NMORO = NMOL + IM
         CALINT=.FALSE.
         DO 204 J = 1, 4
            IF (IBSSE.EQ.0.AND.J.LE.3) GO TO 203
            IF (IRVS.EQ.0.AND.J.EQ.4) GO TO 204
            IF (IRDENG.EQ.1.AND.IND.LE.IES) THEN
               EM(NMORO) = ESAVE(IND)
               IF (J.EQ.1) E0S = E0S + ESAVE(IND)
               IND=IND+1
               GO TO 203
            END IF
            IF (.NOT.CALINT) THEN
               NMOROS=NMORO
               NMORO=NMOL+IM
               CALL ONEEI
               NMORO=NMOROS
               CALINT=.TRUE.
            END IF
            IF (MASWRK.AND.J.EQ.1) WRITE(IW,5001) IM
            IF (MASWRK.AND.J.EQ.2) WRITE(IW,5002) IM
            IF (MASWRK.AND.J.EQ.3) WRITE(IW,5003) IM
            IF (MASWRK.AND.J.EQ.4) WRITE(IW,5004) IM
            IF (J.EQ.3.OR.(J.EQ.4.AND.IBSSE.EQ.1)) CALL MOMEM(NINTMX)
            IF (J.EQ.1) CALL GUESMO(GUESS)
            IF (J.NE.1) CALL GESSMO
C
C       LINEAR DEPENDENCE CANNOT BE TOLERATED BY THIS PROGRAM,
C       AND THIS IS THE FIRST TIME WE ARE USING THE ENTIRE BASIS
C       SET, TO KNOW IT OCCURS.  THE PREVIOUS MONOMER CALCULATIONS
C       WILL FIND -NQMT- LESS THAN -NUM-, SINCE MONOMERS ARE ALWAYS
C       LESS THAN THE ENTIRE BASIS, SO WE CANNOT TEST HIGHER UP.
C
            IF(NQMT.NE.NUM) THEN
               IF(MASWRK) WRITE(IW,4000)
               CALL ABRT
            END IF
C
            IF (J.NE.1) CALL CTINT1
            CALL MOSCF
            EM(NMORO) = ETOT
            IF (J.EQ.1) E0S = E0S +ETOT
            IF(TIM.GE.TIMLIM) GO TO 120
  203       NMORO = NMORO + NMOL
  204    CONTINUE
  205 CONTINUE
C
  206 CONTINUE
C
C     1E INTEGRALS FOR SUPPER MOLECULE
C
      NMORO=0
      CALL ONEEI
      IF(TIM.GE.TIMLIM) GO TO 120
C
C     CALCULATE E3 AND E4 IN MOROKUMA ANALYSIS
C
      IF (MASWRK) WRITE(IW,6000)
      IF (IRDENG.EQ.1.AND.IND.LE.IES) THEN
         MAXITS=MAXIT
         MAXIT=1
      END IF
      NMORO=100
      CALL GESSMO
      NMORO=0
      CALL MOSCF
      E3 = EF
      E4 = ETOT
      IF (IRDENG.EQ.1.AND.IND.LE.IES) THEN
         E4=ESAVE(IND)
         IND=IND+1
         MAXIT=MAXITS
      END IF
C
C     CALCULATE E5 AND E6 (SPLIT) IN MOROKUMA ANALYSIS
C
      IF (ICTPPL.EQ.0) GO TO 303
C
      E5=ZERO
      DO 300 IM = 1, NMOL
         IF (IEQM(IM).NE.0) THEN
            E6(IM) = E6(IEQM(IM))
            GO TO 300
         END IF
         NMORO = 1000 + IM
         IF (IRDENG.EQ.1.AND.IND.LE.IES) THEN
            MAXITS=MAXIT
            MAXIT=1
            IF (E5.NE.ZERO) GO TO 301
         END IF
         IF (MASWRK) WRITE(IW,7001) IM
         CALL MOMEM(NINTMX)
         CALL GESSMO
         CALL CTINT1
         CALL MOSCF
         E5 = EF
         E6(IM) = ETOT
  301    IF (IRDENG.EQ.1.AND.IND.LE.IES) THEN
            E6(IM)=ESAVE(IND)
            IND=IND+1
            MAXIT=MAXITS
         END IF
  300 CONTINUE
C
  303 CONTINUE
C
C     CALCULATE E7 (SPLIT) IN MOROKUMA ANALYSIS
C
      IF (ICTPLX.EQ.0) GO TO 353
C
      DO 350 IM = 1, NMOL
         IF (IEQM(IM).NE.0) THEN
            E7(IM) = E7(IEQM(IM))
            GO TO 350
         END IF
         IF (IRDENG.EQ.1.AND.IND.LE.IES) THEN
            E7(IM)=ESAVE(IND)
            IND=IND+1
            GO TO 350
         END IF
         NMORO = 1000 + NMOL + IM
         IF (MASWRK) WRITE(IW,7002) IM
         CALL MOMEM(NINTMX)
         CALL GESSMO
         CALL CTINT1
         CALL MOSCF
         E7(IM) = ETOT
  350 CONTINUE
C
  353 CONTINUE
C
      IF (IRVS.EQ.0) GO TO 399
C
C     RVS POL
C
      DO 360 IM = 1, NMOL
         IF (IEQM(IM).NE.0) THEN
            E8(IM) = E8(IEQM(IM))
            GO TO 360
         END IF
         IF (IRDENG.EQ.1.AND.IND.LE.IES) THEN
            E8(IM)=ESAVE(IND)
            IND=IND+1
            GO TO 360
         END IF
         NMORO = 1200 + IM + NMOL
         IF (MASWRK) WRITE(IW,8002) IM
         CALL MOMEM(NINTMX)
         CALL GESSMO
         CALL CTINT1
         CALL MOSCF
         E8(IM) = ETOT
  360 CONTINUE
C
C     RVS CT
C
      DO 370 IM = 1, NMOL
         IF (IEQM(IM).NE.0) THEN
            E9(IM) = E9(IEQM(IM))
            GO TO 370
         END IF
         IF (IRDENG.EQ.1.AND.IND.LE.IES) THEN
            E9(IM)=ESAVE(IND)
            IND=IND+1
            GO TO 370
         END IF
         NMORO = 1000 + IM + 2*NMOL
         IF (MASWRK) WRITE(IW,7003) IM
         CALL MOMEM(NINTMX)
         CALL GESSMO
         CALL CTINT1
         CALL MOSCF
         E9(IM) = ETOT
  370 CONTINUE
C
C     SET IS BACK TO 8
C
  399 IS = ISSV
C
C     NDO INT1 AND INT2
C
      NMORO=0
      CALL ZRMEM(NINTMX)
C
C     CALCULATE E1 AND E2 IN MOROKUMA ANALYSIS
C
      E1=ZERO
      IF (IRDENG.EQ.1.AND.IND.LE.IES) THEN
         IF (ICTPPL.NE.0) THEN
            GO TO 401
         ELSE
            MAXIT=1
         END IF
      END IF
      IF (MASWRK) WRITE(IW,8000)
      NMORO=200
      CALL GESSMO
      NMORO=0
      CALL MOSCF
      E1 = EF
      E2T = ETOT
  401 IF (IRDENG.EQ.1.AND.IND.LE.IES) THEN
         E2T=ESAVE(IND)
         IND=IND+1
      END IF
C
C     CALCULATE E2 (SPLIT) IN MOROKUMA ANALYSIS
C
      IF (ICTPPL.EQ.0) GO TO 453
C
      DO 400 IM = 1, NMOL
         IF (IEQM(IM).NE.0) THEN
            E2(IM) = E2(IEQM(IM))
            GO TO 400
         END IF
         IF (IRDENG.EQ.1.AND.IND.LE.IES) THEN
            MAXITS=MAXIT
            MAXIT=1
            IF (E1.NE.ZERO) GO TO 402
         END IF
         NMORO = 1200 + IM
         IF (MASWRK) WRITE(IW,8001) IM
         CALL ZRMEM(NINTMX)
         CALL GESSMO
         CALL CTINT1
         CALL MOSCF
         E1=EF
         E2(IM) = ETOT
  402    IF (IRDENG.EQ.1.AND.IND.LE.IES) THEN
            E2(IM)=ESAVE(IND)
            IND=IND+1
            MAXIT=MAXITS
         END IF
  400 CONTINUE
C
  453 CONTINUE
C
C     DONE WITH MOROKUMA ANALYSIS
C     PRINTING
C
      EST = E1 - E0M
      EPOL = E2T - E1
      EEX = E3 - E1
      EINT = E4 - E0M
      ESTKC  = TOKCAL * EST
      EPOLKC = TOKCAL * EPOL
      EEXKC  = TOKCAL * EEX
      EINTKC = TOKCAL * EINT
C
      IF (ICTPPL.EQ.1) THEN
         EPOT = -E1*NMOL
         ECT = -E5*NMOL
         DO 500 IM = 1, NMOL
            EPOT = EPOT + E2(IM)
            ECT = ECT + E6(IM)
  500    CONTINUE
         EMIX = EINT - (EST + EPOL + EEX + ECT)
         EPOM = EPOL - EPOT
         ECTKC = TOKCAL * ECT
         EMIXKC = TOKCAL * EMIX
         EPOMKC = TOKCAL * EPOM
      END IF
C
      IF (ICTPLX.EQ.1) THEN
         ECPX = -E3*NMOL
         DO 510 IM = 1, NMOL
            ECPX = ECPX + E7(IM)
  510    CONTINUE
         ERES = EINT - (EST + EEX + ECPX)
         ECPXKC = TOKCAL * ECPX
         ERESKC = TOKCAL * ERES
      END IF
C
      IF (IBSSE.EQ.1) THEN
         E0MS = E0M - E0S
         EINTB = E4 - E0S
         EINTBKC = TOKCAL * EINTB
C
         NTWMOL = 2*NMOL
         NTHMOL = 3*NMOL
         EEXBT = ZERO
         DO 520 I = 1, NMOL
            EEXB(I) = EM(I) - EM(NTHMOL+I)
            EEXBT = EEXBT + EEXB(I)
  520    CONTINUE
C
         IF (ICTPPL.EQ.1) THEN
            EMIXB = ZERO
            ECTBT = ZERO
            DO 550 I = 1, NMOL
               ECTB(I) = EM(I) - EM(NTWMOL+I)
               ECTBT = ECTBT + ECTB(I)
               EMIXB = EMIXB + EM(I) - EM(NMOL+I) - ECTB(I) - EEXB(I)
  550       CONTINUE
         END IF
C
         IF (ICTPLX.EQ.1) THEN
            ERESB = ZERO
            ECPXBT = ZERO
            NTWMOL = 2*NMOL
            NTHMOL = 3*NMOL
            DO 560 I = 1, NMOL
               ECPXB(I) = EM(I) - EM(NTWMOL+I)
               ECPXBT = ECPXBT + ECPXB(I)
               ERESB = ERESB + EM(I) - EM(NMOL+I) - ECPXB(I) - EEXB(I)
  560       CONTINUE
         END IF
      END IF
C
      IF (MASWRK) THEN
         WRITE(IW,9000)
         WRITE(IW,9010) EST,ESTKC
         WRITE(IW,9020) EEX,EEXKC
         WRITE(IW,9040) EPOL,EPOLKC
         IF (ICTPPL.EQ.1) THEN
            WRITE(IW,9030) ECT,ECTKC
            WRITE(IW,9050) EMIX,EMIXKC
         END IF
         IF (ICTPLX.EQ.1) THEN
            WRITE(IW,9032) ECPX,ECPXKC
            WRITE(IW,9052) ERES,ERESKC
         END IF
         WRITE(IW,9060) EINT,EINTKC
C
         IF (ICTPPL.EQ.1) THEN
            WRITE(IW,*)
            WRITE(IW,*)'DECOMPOSITION OF CT'
            DO 600 I = 1, NMOL
               WRITE(IW,9031) I,E6(I)-E5,(E6(I)-E5)*TOKCAL
  600       CONTINUE
            WRITE(IW,*)
            WRITE(IW,*)'DECOMPOSITION OF PL'
            DO 700 I = 1, NMOL
               WRITE(IW,9041) I,E2(I)-E1,(E2(I)-E1)*TOKCAL
  700       CONTINUE
            WRITE(IW,9051) EPOM,EPOMKC
         END IF
C
         IF (ICTPLX.EQ.1) THEN
            WRITE(IW,*)
            WRITE(IW,*)'DECOMPOSITION OF CTPLX'
            DO 710 I = 1, NMOL
               WRITE(IW,9033) I,E7(I)-E3,(E7(I)-E3)*TOKCAL
  710       CONTINUE
         END IF
C
         IF (IBSSE.EQ.1) THEN
            WRITE(IW,*)
            WRITE(IW,*)'BASIS SET SUPERPOSITION ERROR'
            WRITE(IW,9071) EINTB,EINTBKC
            WRITE(IW,9070) E0MS,E0MS*TOKCAL
            WRITE(IW,*)
C
            WRITE(IW,9074) EEX+EEXBT,(EEX+EEXBT)*TOKCAL
            DO 720 I = 1, NMOL
               WRITE(IW,9075) I,EEXB(I),EEXB(I)*TOKCAL
  720       CONTINUE
            WRITE(IW,*)
C
            IF (ICTPPL.EQ.1) THEN
               WRITE(IW,9072) ECT+ECTBT,(ECT+ECTBT)*TOKCAL
               DO 750 I = 1, NMOL
                  WRITE(IW,9077) I,ECTB(I),ECTB(I)*TOKCAL
  750          CONTINUE
               DO 751 I = 1, NMOL
                  WRITE(IW,9073) I,ECTB(I)+E6(I)-E5,
     *               (ECTB(I)+E6(I)-E5)*TOKCAL
  751          CONTINUE
               WRITE(IW,*)
               WRITE(IW,9076) EMIX+EMIXB,(EMIXB+EMIX)*TOKCAL
               WRITE(IW,*)
            END IF
C
            IF (ICTPLX.EQ.1) THEN
               WRITE(IW,9081) ECPX+ECPXBT,(ECPX+ECPXBT)*TOKCAL
               DO 760 I = 1, NMOL
                  WRITE(IW,9082) I,ECPXB(I),ECPXB(I)*TOKCAL
  760          CONTINUE
               DO 761 I = 1, NMOL
                  WRITE(IW,9083) I,ECPXB(I)+E7(I)-E3,
     *               (ECPXB(I)+E7(I)-E3)*TOKCAL
  761          CONTINUE
               WRITE(IW,*)
               WRITE(IW,9084) ERES+ERESB,(ERESB+ERES)*TOKCAL
               WRITE(IW,*)
            END IF
         END IF
      END IF
C
      IF (IRVS.EQ.1.AND.MASWRK) THEN
         WRITE(IW,9001)
C             RVS PAPER REPORTS THESE AS A SUM, RATHER THAN SEPARATELY,
C             SO A LITTLE FURTHER BELOW THESE ARE GIVEN AS A SUM "CEX".
C             THEY ARE IDENTICAL TO KITAURA/MOROKUMA'S DEFINITION.
         WRITE(IW,9120) EST,EST*TOKCAL
         WRITE(IW,9121) EEX,EEX*TOKCAL
         TCEX = EEX+EST
C
C             POLARIZATION ENERGIES
         TPOL = ZERO
         DO 801 IM = 1, NMOL
            ETMP = E8(IM)-E3
            WRITE(IW,9130) IM,ETMP,ETMP*TOKCAL
            TPOL = TPOL+ETMP
  801    CONTINUE
C
C             CHARGE TRANSFER ENERGIES
         TCTE = ZERO
         DO 802 IM = 1, NMOL
            ETMP = E9(IM)-E8(IM)-EM(IM+4*NMOL)+EM(IM)
            WRITE(IW,9140) IM,ETMP,ETMP*TOKCAL
            TCTE =TCTE+ETMP
  802    CONTINUE
C
C             E4 = TRUE ENERGY OF SUPERMOLECULE, E0M=SUM OF MONOMERS,
C             THE DIFFERENCE OF THESE IS THE TRUE INTERACTION ENERGY.
C
         TENG = TCEX + TPOL + TCTE
         WRITE(IW,*)
         WRITE(IW,9125) TCEX,TCEX*TOKCAL
         WRITE(IW,9135) TPOL,TPOL*TOKCAL
         WRITE(IW,9145) TCTE,TCTE*TOKCAL
         WRITE(IW,9160) TENG,TENG*TOKCAL
         WRITE(IW,9165) E4-E0M,(E4-E0M)*TOKCAL
         WRITE(IW,*)
C
C             BSSE CORRECTIONS
         TBSSE=ZERO
         DO 803 IM = 1, NMOL
            ETMP = EM(IM+4*NMOL)-EM(IM)
            WRITE(IW,9150) IM,ETMP,ETMP*TOKCAL
            TBSSE=TBSSE+ETMP
  803    CONTINUE
         WRITE(IW,9155) TBSSE,TBSSE*TOKCAL
         WRITE(IW,9170) E4-E0M-TBSSE,(E4-E0M-TBSSE)*TOKCAL
         WRITE(IW,*)
      END IF
C
  120 CONTINUE
      IF (MASWRK) WRITE(IW,*) '... END OF MOROKUMA DECOMPOSITION ...'
      CALL TIMIT(1)
      RETURN
C
 1400 FORMAT(/1X,'DIRECT SCF IS NOT IMPLEMENTED FOR MOROKUMA ANALYSIS')
 1500 FORMAT(/1X,'THIS RUN REQUESTED THE USE OF SPHERICAL HARMONICS,',
     *       1X,'BUT MOROKUMA ANALYSIS IS NOT PROGRAMMED FOR ISPHER=1.')
 1600 FORMAT(1X,'MOROKUMA ANALYSIS WORKS ONLY FOR SCFTYP = RHF')
 1900 FORMAT(/1X,'IT IS WISE TO READ THE $MOROKM DOCUMENTATION'/
     *       1X,'TO LEARN ALL THE LITTLE QUIRKS IN THIS PROGRAM.')
C
 2000 FORMAT(1X,'MOROKUMA ANALYSIS DOES NOT APPLY SYMMETRY OPERATION')
 3000 FORMAT(1X,'MOROKUMA ANALYSIS DOES NOT SUPORT INTEGRAL SORTING',
     *          ' THIS OPTION IS TURNED OFF AUTOMATICLY')
 4000 FORMAT(/1X,'*** BASIS SET LINEAR DEPENDENCE FOUND ***'/
     *       1X,'THIS BASIS SET CONTAINS LINEAR DEPENDENCE,',
     *          ' WHICH CANNOT BE DISCARDED'/
     *       1X,'DURING MOROKUMA/RVS RUNS.  PLEASE ELIMINATE THIS',
     *          ' PROBLEM BY'/
     *       5X,'A) DOUBLE CHECKING YOUR BASIS SET'/
     *       5X,'B) REDUCING THE SIZE OF YOUR BASIS SET'/
     *       5X,'C) DECREASING QMTTOL IN $CONTRL TO RETAIN THE',
     *          ' ENTIRE MO SPACE'/)
C
 5000 FORMAT(/10X,22(1H-)/10X,'RUNNING FOR MONOMER',I3/
     *        10X,22(1H-))
 5001 FORMAT(/10X,34(1H-)/10X,'RUNNING FOR MONOMER (WITH BSSE)',I3/
     *        10X,34(1H-))
 5002 FORMAT(/10X,38(1H-)/10X,'RUNNING FOR MONOMER (WITH BSSE VIR)',I3/
     *        10X,38(1H-))
 5003 FORMAT(/10X,38(1H-)/10X,'RUNNING FOR MONOMER (WITH BSSE OCC)',I3/
     *        10X,38(1H-))
 5004 FORMAT(/10X,42(1H-)/10X,'RUNNING FOR MONOMER (BSSE WITH ALL VIR)',
     *        I3,/10X,42(1H-))
 6000 FORMAT(/10X,21(1H-)/10X,'RUNNING FOR E3 AND E4'/
     *        10X,21(1H-))
 7001 FORMAT(/10X,33(1H-)/10X,'RUNNING FOR E6 (SPLIT), IMOL =',I3/
     *        10X,33(1H-))
 7002 FORMAT(/10X,33(1H-)/10X,'RUNNING FOR E7 (SPLIT), IMOL =',I3/
     *        10X,33(1H-))
 7003 FORMAT(/10X,34(1H-)/10X,'RUNNING FOR E9 (RVS CT), IMOL =',I3/
     *        10X,34(1H-))
 8000 FORMAT(/10X,21(1H-)/10X,'RUNNING FOR E1 AND E2'/
     *        10X,21(1H-))
 8001 FORMAT(/10X,33(1H-)/10X,'RUNNING FOR E2 (SPLIT), IMOL =',I3/
     *        10X,33(1H-))
 8002 FORMAT(/10X,35(1H-)/10X,'RUNNING FOR E8 (RVS POL), IMOL =',I3/
     *        10X,35(1H-))
 8500 FORMAT(1X,'READ IN ENERGY IS NOT IDENTICAL TO THE RECALCULATED')
 9000 FORMAT(/10X,36(1H-)/10X,'RESULTS OF KITAURA-MOROKUMA ANALYSIS'/
     *        10X,36(1H-)/
     *       /41X,'HARTREE',4X,'KCAL/MOLE')
 9001 FORMAT(/10X,23(1H-)/10X,'RESULTS OF RVS ANALYSIS'/
     *        10X,23(1H-)/
     *       /40X,'HARTREE',4X,'KCAL/MOLE')
 9010 FORMAT(1X,'ELECTROSTATIC ENERGY             ES=',F12.6,3X,F8.2)
 9020 FORMAT(1X,'EXCHANGE REPULSION ENERGY        EX=',F12.6,3X,F8.2)
 9040 FORMAT(1X,'POLARIZATION ENERGY              PL=',F12.6,3X,F8.2)
 9030 FORMAT(1X,'CHARGE TRANSFER ENERGY           CT=',F12.6,3X,F8.2)
 9050 FORMAT(1X,'HIGH ORDER COUPLING ENERGY      MIX=',F12.6,3X,F8.2)
 9032 FORMAT(1X,'CT + PL + X,                  CTPLX=',F12.6,3X,F8.2)
 9052 FORMAT(1X,'HIGH ORDER COUPLING FOR CPLX,   RES=',F12.6,3X,F8.2)
 9060 FORMAT(1X,'TOTAL INTERACTION ENERGY,   DELTA-E=',F12.6,3X,F8.2)
 9031 FORMAT(1X,'CHARGE TRANSFER ENERGY, MON=',I3,'  CT=',F12.6,3X,F8.2)
 9041 FORMAT(1X,'EPL,                    MON=',I3,'  PL=',F12.6,3X,F8.2)
 9051 FORMAT(1X,'HIGH ORDER COUPLING FOR PL,    PMIX=',F12.6,3X,F8.2)
 9033 FORMAT(1X,'CT + PL + X,            MON=',I3,' CPX=',F12.6,3X,F8.2)
 9071 FORMAT(1X,'TOTAL INT WITH BSSE,  DELTA-E(BSSE)=',F12.6,3X,F8.2)
 9070 FORMAT(1X,'BSSE CORRECTION,            E(BSSE)=',F12.6,3X,F8.2)
 9074 FORMAT(1X,'EEX WITH BSSE              EX(BSSE)=',F12.6,3X,F8.2)
 9075 FORMAT(1X,'EEX WITH BSSE     MON=',I3,'    DEL EX=',F12.6,3X,F8.2)
 9072 FORMAT(1X,'ECT WITH BSSE              CT(BSSE)=',F12.6,3X,F8.2)
 9073 FORMAT(1X,'ECT WITH BSSE     MON=',I3,'  CT(BSSE)=',F12.6,3X,F8.2)
 9076 FORMAT(1X,'EMIX WITH BSSE           EMIX(BSSE)=',F12.6,3X,F8.2)
 9077 FORMAT(1X,'ECT WITH BSSE     MON=',I3,'    DEL CT=',F12.6,3X,F8.2)
 9081 FORMAT(1X,'ECTPLX WITH BSSE        CTPLX(BSSE)=',F12.6,3X,F8.2)
 9082 FORMAT(1X,'ECTPLX WITH BSSE  MON=',I3,' DEL CTPLX=',F12.6,3X,F8.2)
 9083 FORMAT(1X,'ECTPLX WITH BSSE  MON=',I3,' CTPLX(BS)=',F12.6,3X,F8.2)
 9084 FORMAT(1X,'ERES WITH BSSE           ERES(BSSE)=',F12.6,3X,F8.2)
 9120 FORMAT(1X,'ES (ELECTROSTATIC, OR COULOMB)    ',F12.6,3X,F8.2)
 9121 FORMAT(1X,'EX (EXCHANGE REPULSION)           ',F12.6,3X,F8.2)
 9130 FORMAT(1X,'POL         MONOMER',I3,12X,F12.6,3X,F8.2)
 9140 FORMAT(1X,'CT          MONOMER',I3,12X,F12.6,3X,F8.2)
 9125 FORMAT(10X,'TOTAL COULOMB/EXCHANGE   ',F12.6,3X,F8.2)
 9135 FORMAT(10X,'TOTAL POLARIZATION       ',F12.6,3X,F8.2)
 9145 FORMAT(10X,'TOTAL CHARGE TRANSFER    ',F12.6,3X,F8.2)
 9160 FORMAT(10X,'TOTAL OF CEX+POL+CT      ',F12.6,3X,F8.2)
 9165 FORMAT(10X,'TOTAL INTERACTION ENERGY ',F12.6,3X,F8.2)
 9150 FORMAT(1X,'BSSE(VIR)   MONOMER',I3,12X,F12.6,3X,F8.2)
 9155 FORMAT(1X,'TOTAL BSSE         ',   15X,F12.6,3X,F8.2)
 9170 FORMAT(1X,'BSSE CORRECTED TOTAL INTERACTION  ',F12.6,3X,F8.2)
      END
C*MODULE MOROKM  *DECK MOSCF
      SUBROUTINE MOSCF
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C
      PARAMETER (MXATM=2000)
C
      COMMON /ACONV / RRSHFT,EXTTOL,DMPTOL,VSHTOL,IEXTIN
      COMMON /CONV  / ACURCY,EN,ETOT,EHF,EHF0,DIFF,ITER,ICALP,ICBET
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C
      SAVE IFIRST
      DATA IFIRST/1/
C
C     ----- SET CONVERGENCE CRITERIA -----
C
      IF (IFIRST.EQ.0) GO TO 100
      IEXTIN = 4
      EXTTOL = 1.0D-03
      DMPTOL = 1.0D-04
      VSHTOL = 0.4D+00
      IFIRST = 0
C
      CALL TRMAT
C
C     ----- EXECUTE SCF PROCEDURE -----
C
  100 EN=ENUC(NAT,ZAN,C)
      CALL RHFCL
C
      RETURN
      END
C*MODULE MOROKM  *DECK RDENG
      SUBROUTINE RDENG(ESAVE,I)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      CHARACTER*8 STVEC
      CHARACTER*16 LET
C
      PARAMETER (MXMOL=10,MXES=MXMOL*10+2)
      DIMENSION ESAVE(MXES)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IRDENG
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      CALL VCLR(ESAVE,1,MXES)
      I=0
      IF (IRDENG.EQ.0) RETURN
C
      CALL SEQREW(IR)
      STVEC=' $EMORO '
      CALL FNDGRP(IR,STVEC,IEOF)
      IF (IEOF.NE.0) THEN
         IF (MASWRK) WRITE(IW,1000)
         CALL ABRT
      END IF
C
      I=1
      IF (MASWRK) THEN
  200    READ(IR,1010,ERR=300,END=300) LET,ESAVE(I)
         CALL UPRCAS(LET,5)
         IF (LET(1:5).EQ.' $END') GO TO 300
         I=I+1
         GO TO 200
      END IF
C
  300 I=I-1
C
      IF (GOPARR) THEN
         CALL DDI_BCAST(428,'F',ESAVE,I,MASTER)
         CALL DDI_BCAST(429,'I',I    ,1,MASTER)
      END IF
      RETURN
C
 1000 FORMAT(1X,'INPUT $ENERG PLEASE FOR RDENG OPTION IN $MOROKM')
 1010 FORMAT(A16,F20.10)
      END
C*MODULE MOROKM  *DECK SAVORB
      SUBROUTINE SAVORB
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000,MXMOL=10)
C
      COMMON /FMCOM / XX(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
C
C     THIS ROUTINE IS FOR SAVING MONOMER'S ORBITAL
C     LOCATE MEMORY
C
      LL3 = NUM*NUM
      L3 = NBAS(NMORO)**2
      L5 = 0
      DO 100 IMOL = 1, NMOL
         IF (NMORO.EQ.IMOL) ISHFT = L5
         L5 =  L5 + NBAS(IMOL)**2
  100 CONTINUE
      CALL VALFM(LOADFM)
      I10  = LOADFM + 1
      I20  = I10    + LL3
      I30  = I20    + L5
      NEED = I30 - LOADFM - 1
      CALL GETFM(NEED)
C
      CALL DAREAD(IDAF,IODA,XX(I10),LL3,15,0)
      IF (NMORO.EQ.1) THEN
         CALL DAWRIT(IDAF,IODA,XX(I10),L5,313,0)
      ELSE
         CALL DAREAD(IDAF,IODA,XX(I20),L5,313,0)
         CALL DCOPY(L3,XX(I10),1,XX(I20+ISHFT),1)
         CALL DAWRIT(IDAF,IODA,XX(I20),L5,313,0)
      END IF
C
      CALL RETFM(NEED)
      RETURN
      END
C*MODULE MOROKM  *DECK STENUC
      SUBROUTINE STENUC(N,ISTART,IEND)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXMOL=10)
C
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
C
      IF (NMORO.GT.0.AND.NMORO.LE.5*NMOL) THEN
         NN=NMORO
  100    IF (NN.LE.NMOL) GO TO 110
         NN = NN - NMOL
         GO TO 100
  110    ISTART = MONO(NN) + 1
         IF (NN.EQ.NMOL) THEN
            IEND = N
         ELSE
            IEND = MONO(NN+1) - 1
         END IF
      ELSE
         ISTART = 2
         IEND   = N
      END IF
      RETURN
      END
C*MODULE MOROKM  *DECK STGUSS
      SUBROUTINE STGUSS(NA1,L1,L2,L3,GUESS,NORDER)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      CHARACTER*8 STVEC
      CHARACTER*1 NUMVEC
C
      PARAMETER (MXMOL=10)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA CORE/8HHCORE   /,RDMO/8HMOREAD  /
C
      IF (NMORO.EQ.0) THEN
         RETURN
      ELSE IF (NMORO.GT.NMOL) THEN
         NA1 = NEM(NMORO-NMOL)/2
         NUMVEC=CHAR(48+NMORO-NMOL)
      ELSE
         NA1 = NEM(NMORO)/2
         L1 = NBAS(NMORO)
         L3 = L1**2
         L2 = (L3+L1)/2
         NUMVEC=CHAR(48+NMORO)
      END IF
C
      GUESS= CORE
      CALL SEQREW(IR)
      STVEC(1:5)=' $VEC'
      STVEC(6:6)=NUMVEC
      STVEC(7:8)='  '
      CALL FNDGRP(IR,STVEC,IEOF)
      IF (IEOF.EQ.0) GUESS=RDMO
C
      IF (NORDER.EQ.1) THEN
         NORDER=0
         IF (MASWRK) WRITE(IW,1000)
      END IF
      RETURN
C
 1000 FORMAT(1X,'WARNING, MOROKUMA ANALYSIS DOES NOT PERMIT ORBITAL ',
     *       'SWITCHING FOR EACH INDIVIDAUL MOLECULE.',/,
     *       ' NORDER IS TURNED OFF')
C
      END
C*MODULE MOROKM  *DECK STINT1
      SUBROUTINE STINT1(ISTART,IEND,JSTART,LOCIJ,NATST,NATED,ISAVE,
     *                  L1,L2)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXSH=5000, MXGTOT=20000, MXMOL=10)
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
C
      IF (NMORO.EQ.0) THEN
         ISTART = 1
         IEND   = NSHELL
         JSTART = 1
         LOCIJ  = 0
         NATST  = 1
         NATED  = NAT
         ISAVE  = 1
         L1 = NUM
      ELSE IF (NMORO.GT.0.AND.NMORO.LE.NMOL) THEN
         ISTART = NSHLLS(NMORO)
         IF (NMORO.LT.NMOL) IEND = NSHLLS(NMORO+1)-1
         IF (NMORO.EQ.NMOL) IEND = NSHELL
         JSTART = ISTART
         LOCIJ  = NLOC(NMORO)
         NATST  = MONO(NMORO)
         IF (NMORO.LT.NMOL) NATED  = MONO(NMORO+1)-1
         IF (NMORO.EQ.NMOL) NATED  = NAT
         ISAVE  = 0
         L1 = NBAS(NMORO)
      ELSE IF (NMORO.GT.NMOL) THEN
         ISTART = 1
         IEND   = NSHELL
         JSTART = 1
         LOCIJ  = 0
         NN = NMORO - NMOL
  100    IF (NN.LE.NMOL) GO TO 110
         NN = NN - NMOL
         GO TO 100
  110    NATST  = MONO(NN)
         IF (NN.LT.NMOL) NATED  = MONO(NN+1)-1
         IF (NN.EQ.NMOL) NATED  = NAT
         ISAVE  = 0
         IF (NMORO.LE.2*NMOL) ISAVE=1
         L1 = NUM
      END IF
      L2 = (L1*(L1+1))/2
      RETURN
      END
C*MODULE MOROKM  *DECK STRDMO
      SUBROUTINE STRDMO(NMOS,STVEC,VEC,NSTM,NUM1,L3)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      CHARACTER*8 STVEC
      CHARACTER*1 NUMVEC
      DIMENSION VEC(*)
C
      PARAMETER (MXMOL=10)
C
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
C
      IF (NMORO.EQ.0.OR.NMORO.GT.2*NMOL) THEN
         RETURN
      ELSE IF (NMORO.GT.NMOL) THEN
         NN=NMORO-NMOL
      ELSE
         NN=NMORO
      END IF
C
      NMOS = NEM(NN)/2
      NUM1 = NBAS(NN)
      NSTM=0
      IF (NMORO.GT.NMOL+1) THEN
         DO 100 I=1,NN-1
            NSTM = NSTM + NBAS(I)
  100    CONTINUE
      END IF
C
      CALL VCLR(VEC,1,L3)
C
      NUMVEC=CHAR(48+NN)
      STVEC(1:5)=' $VEC'
      STVEC(6:6)=NUMVEC
      STVEC(7:8)='  '
C
      RETURN
      END
C*MODULE MOROKM  *DECK STRHF
      SUBROUTINE STRHF(NUM,NA,NB,NE,NST,LL1,LL2,LL3,DOMBAS)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXMOL=10)
      LOGICAL DOMBAS
C
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
      COMMON /SVINFO/ NAT0,ICH0,MUL0,NUM0,NE0,NA0,NB0,NDUM,EF
C
      DOMBAS=.FALSE.
      NST = 1
      IF (NMORO.EQ.0.OR.NMORO.GT.1000) THEN
         NUM=NUM0
         NA=NA0
         NB=NB0
         NE=NE0
      ELSE IF (NMORO.GT.0.AND.NMORO.LE.5*NMOL) THEN
         NUM=NUM0
         IF (NMORO.LE.NMOL) NUM=NBAS(NMORO)
         NN = NMORO
  100    IF (NN.LE.NMOL) GO TO 110
         NN = NN - NMOL
         GO TO 100
  110    NA=NEM(NN)/2
         NB=NEM(NN)/2
         NE=NEM(NN)
      END IF
      IF (NMORO.GT.1000) DOMBAS=.TRUE.
      IF (NMORO.GT.2*NMOL.AND.NMORO.LE.5*NMOL) THEN
         DOMBAS=.TRUE.
         DO 200 I = 1, NN - 1
            NST = NST + NEM(I)/2
  200    CONTINUE
      END IF
      LL1 = NUM0
      LL2 = (LL1*LL1+LL1)/2
      LL3 = LL1*LL1
      RETURN
      END
C*MODULE MOROKM  *DECK TFSQU1
      SUBROUTINE TFSQU1(F,H,T1,T2,WRK,N1,N2,N3,N4,NSFT1,NSFT2)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION H(*),F(*),T1(N1,N3),T2(N2,N4),WRK(N1)
C
C     ----- TRANSFORM THE SQUARE MATRIX F USING VECTORS T -----
C                      H = T1-DAGGER * F * T2
C           F IS A LOWER TRIANGULAR MATRIX START AT NSFT1*(NSFT1+1)/2+1
C           H IS A LOWER TRIANGULAR MATRIX START AT NSFT2*(NSFT2+1)/2+1
C           H MUST BE SET TO ZERO BEFORE RUNNING THIS ROUNTINE.
C
      DO 300 II = 1,N4
         LDX = 1
         DO 100 L=1,N1
            WRK(L) = DDOT(N2,T2(1,II),1,F(LDX),1)
            LDX = LDX + NSFT1 + L
  100    CONTINUE
         JDX = II
         DO 200 J=1,N3
            H(JDX) = DDOT(N1,WRK,1,T1(1,J),1)
            JDX = JDX + NSFT2 + J
  200    CONTINUE
  300 CONTINUE
C
      RETURN
      END
C*MODULE MOROKM  *DECK TFSQU2
      SUBROUTINE TFSQU2(F,H,T1,T2,WRK,N1,N2,N3,N4,NSFT1,NSFT2)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION H(*),F(*),T1(N1,N3),T2(N2,N4),WRK(N2)
C
C     ----- TRANSFORM THE SQUARE MATRIX F USING VECTORS T -----
C                      H = T1-DAGGER * F-DAGGER * T2
C           F IS A LOWER TRIANGULAR MATRIX,
C                     START AT NSFT1*(NSFT1+1)/2+1
C           H IS A LOWER TRIANGULAR MATRIX,
C                     START AT (NSFT2+N4)*(NSFT2+N4+1)/2+NSHFT2+1
C           H MUST BE SET TO ZERO BEFORE RUNNING THIS ROUNTINE.
C
      JDX = 1
      DO 300 II = 1,N3
         LDX = 1
         DO 100 L=1,N2
            WRK(L) = DDOT(N1,T1(1,II),1,F(LDX),1)
            LDX = LDX + NSFT1 + L
  100    CONTINUE
         DO 200 J=1,N4
            H(JDX) = DDOT(N2,WRK,1,T2(1,J),1)
            JDX = JDX + 1
  200    CONTINUE
         JDX = JDX + NSFT2 + II
  300 CONTINUE
C
      RETURN
      END
C*MODULE MOROKM  *DECK TFTRI1
      SUBROUTINE TFTRI1(F,H,T,WRK,M,N,NSFT1,NSFT2,DOALL)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL DOALL
C
      DIMENSION H(*),F(*),T(N,M),WRK(N)
C
      PARAMETER (ZERO=0.0D+00, SMALL=1.0D-11)
C
C     ----- TRANSFORM THE TRIANGULAR MATRIX F USING VECTORS T -----
C                      H = T-DAGGER * F * T
C     THE ORDER OF THE TRIANGULAR MATRICES H AND F ARE M AND N.
C        F IS A LOWER TRIANGULAR MATRIX START AT (NSFT1+1)*(NSFT1+2)/2
C        H IS A LOWER TRIANGULAR MATRIX START AT (NSFT2+1)*(NSFT2+2)/2
C        H MUST BE SET TO ZERO BEFORE RUNNING THIS ROUNTINE.
C        DOALL = .T. : ALL ELEMENT CALCULATED
C        DOALL = .F. : ONLY DIAG ELEMENT CALCULATED
C
      IJ = 0
      DO 300 JJ = 1,M
C
C             FIRST CALCULATE T-DAGGER TIMES -F-, A ROW AT A TIME
C
         IK = 0
         DO 140 I = 1,N
            IM1 = I-1
            DUM = ZERO
            TDUM = T(I,JJ)
            IF (IM1.GT.0) THEN
               DO 100 K = 1,IM1
                  IK = IK+1
                  WRK(K) = WRK(K)+F(IK)*TDUM
                  DUM = DUM+F(IK)*T(K,JJ)
  100          CONTINUE
            END IF
            IK = IK+1
            WRK(I) = DUM+F(IK)*TDUM
            IK = IK+NSFT1
  140    CONTINUE
C
C             THEN TAKE THAT ROW TIMES EVERY COLUMN IN -T-
C
         IF (.NOT.DOALL) GO TO 250
C
         DO 200 I = 1,JJ
            IJ = IJ+1
            HIJ = DDOT(N,T(1,I),1,WRK,1)
            IF(ABS(HIJ).LT.SMALL) HIJ=ZERO
            H(IJ)=HIJ
  200    CONTINUE
         GO TO 290
C
  250    IJ = IJ + JJ
         HIJ = DDOT(N,T(1,JJ),1,WRK,1)
         IF(ABS(HIJ).LT.SMALL) HIJ=ZERO
         H(IJ)=HIJ
C
  290    IJ = IJ + NSFT2
  300 CONTINUE
C
      RETURN
      END
C*MODULE MOROKM  *DECK TFTRI2
      SUBROUTINE TFTRI2(F,H,T1,T2,WRK,M1,M2,N,NSFT1,NSFT2)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION H(*),F(*),T1(N,M1),T2(N,M2),WRK(N)
C
      PARAMETER (ZERO=0.0D+00, SMALL=1.0D-11)
C
C     ----- TRANSFORM THE TRIANGULAR MATRIX F USING VECTORS T -----
C                      H = T1-DAGGER * F * T2
C     THE ORDER OF THE TRIANGULAR MATRICES H AND F ARE M AND N.
C           F IS A LOWER TRIANGULAR MATRIX,
C                  START AT (NSFT1+1)*(NSFT1+2)/2
C           H IS A LOWER TRIANGULAR MATRIX,
C                  START AT (NSFT2+1)*(NSFT2+2)/2
C           H MUST BE SET TO ZERO BEFORE RUNNING THIS ROUNTINE.
C
      DO 300 JJ = 1,M2
         IK = 0
         DO 140 I = 1,N
            IM1 = I-1
            DUM = ZERO
            TDUM = T2(I,JJ)
            IF (IM1.GT.0) THEN
               DO 100 K = 1,IM1
                  IK = IK+1
                  WRK(K) = WRK(K)+F(IK)*TDUM
                  DUM = DUM+F(IK)*T2(K,JJ)
  100          CONTINUE
            END IF
            IK = IK+1
            WRK(I) = DUM+F(IK)*TDUM
            IK = IK+NSFT1
  140    CONTINUE
         IJ = JJ
         DO 200 I = 1,M1
            HIJ = DDOT(N,T1(1,I),1,WRK,1)
            IF(ABS(HIJ).LT.SMALL) HIJ=ZERO
            H(IJ)=HIJ
            IJ = IJ + NSFT2 + I
  200    CONTINUE
  300 CONTINUE
C
      RETURN
      END
C*MODULE MOROKM  *DECK TRMOAO
      SUBROUTINE TRMOAO(V,Q,QN,WRK,NUM)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXMOL=10)
C
      DIMENSION V(*),Q(NUM,NUM),QN(NUM,NUM),WRK(*)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
C
      L1 = NUM
      L3 = NUM*NUM
      L5 = 0
      DO 50 IM = 1, NMOL
         L5 = L5 + NBAS(IM)**2
   50 CONTINUE
C
      NFILE = 316
      IF (NMORO.GT.1200+NMOL.AND.NMORO.LE.1200+2*NMOL) NFILE = 314
      IF (NMORO.GT.1000+2*NMOL.AND.NMORO.LE.1000+3*NMOL) NFILE = 314
      CALL DAREAD(IDAF,IODA,V,L3,NFILE,0)
      CALL DCOPY(L3,Q,1,QN,1)
      CALL TFSQB(QN,V,WRK,L1,L1,L1)
      RETURN
      END
C*MODULE MOROKM  *DECK ZRINT1
      SUBROUTINE ZRINT1(H,S)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,OUT
C
      DIMENSION H(*), S(*)
C
      PARAMETER (MXATM=2000, MXMOL=10)
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      PARAMETER (ZERO=0.0D+00)
C
      DATA DEBUG/8HDEBUG   /,DBUGME/8HINT1    /
C
      IF ((NPRINT.NE.-5) .AND. MASWRK) WRITE (IW,9000)
      IF ((NPRINT.NE.-5) .AND. MASWRK) WRITE (IW,9010)
      OUT = NPRINT.EQ.3  .OR.  EXETYP.EQ.DEBUG  .OR.  EXETYP.EQ.DBUGME
     *      .AND. MASWRK
C
      L1 = NUM
      L2 = NUM*(NUM+1)/2
      CALL DAREAD(IDAF,IODA,H,L2,311,0)
      CALL DAREAD(IDAF,IODA,S,L2,312,0)
C
      IED = NLOC(2)
      IJ = IED*(IED+1)/2
      DO 300 IM = 2, NMOL
         JED = IED
         IST = IED+1
         IED = IED+NBAS(IM)
         DO 200 II = IST, IED
            DO 100 JJ = 1, JED
               IJ = IJ + 1
               S(IJ) = ZERO
               H(IJ) = ZERO
  100       CONTINUE
            IJ = IJ + II - JED
  200    CONTINUE
  300 CONTINUE
C
      CALL DAWRIT(IDAF,IODA,H,L2,11,0)
      CALL DAWRIT(IDAF,IODA,S,L2,12,0)
C
      IF(OUT) THEN
         WRITE(IW,*) 'OVERLAP MATRIX'
         CALL PRTRIL(S,L1)
         WRITE(IW,*) 'BARE NUCLEUS HAMILTONIAN INTEGRALS (H=T+V)'
         CALL PRTRIL(H,L1)
      END IF
C
C     ----- DONE WITH INTEGRALS -----
C
      IF(MASWRK) WRITE (IW,9090)
      CALL TEXIT(1,1)
      RETURN
C
 9000 FORMAT(/10X,20(1H*)/10X,'1 ELECTRON INTEGRALS')
 9010 FORMAT(10X,'FOR SA(1)SB(2) = 0 '/10X,20(1H*))
 9090 FORMAT(1X,'...... END OF ONE-ELECTRON INTEGRALS ......')
      END
C*MODULE MOROKM  *DECK ZRINT2
      SUBROUTINE ZRINT2(XX,IX,YY,IY,NINTMX,NOPK)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXMOL=10)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCKLAB/ LABSIZ
C
      DIMENSION XX(NINTMX),IX(*),YY(NINTMX),IY(*)
C
      DATA IJKO/24/
C
      IF(MASWRK) WRITE(IW,3000) IJKO
      NREC = 0
      NXX = 0
      MN = 1
      NINTO = 0
C
      CALL SEQREW(IS)
      CALL SEQREW(IJKO)
      IF (NOPK .NE. 1) GO TO 300
C
C     ----- INTEGRALS ARE NOT IN SUPERMATRIX FORM (NOPK=.TRUE.) -----
C
  100 CONTINUE
      CALL PREAD(IJKO,XX,IX,NXX,NINTMX)
      IF (NXX .EQ. 0) GO TO 400
      NINT = IABS(NXX)
      IF (NINT .GT. NINTMX) CALL ABRT
      DO 200 M = 1,NINT
C
                       NPACK = M
                       IF (LABSIZ .EQ. 2) THEN
*I32                     LABEL = IX( 2*NPACK - 1 )
*I32                     IPACK = ISHFT( LABEL, -16 )
*I32                     JPACK = IAND(  LABEL, 65535 )
*I32                     LABEL = IX( 2*NPACK     )
*I32                     KPACK = ISHFT( LABEL, -16 )
*I32                     LPACK = IAND(  LABEL, 65535 )
*I64                     LABEL = IX(NPACK)
*I64                     IPACK = ISHFT( LABEL, -48 )
*I64                     JPACK = IAND( ISHFT( LABEL, -32 ), 65535 )
*I64                     KPACK = IAND( ISHFT( LABEL, -16 ), 65535 )
*I64                     LPACK = IAND( LABEL, 65535 )
                       ELSE IF (LABSIZ .EQ. 1) THEN
*I32                     LABEL = IX(NPACK)
*I32                     IPACK = ISHFT( LABEL, -24 )
*I32                     JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
*I32                     KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
*I32                     LPACK = IAND( LABEL, 255 )
*I64                     IF ( MOD(NPACK,2) .EQ. 0 ) THEN
*I64                       LABEL = IX( NPACK/2 )
*I64                       IPACK = IAND( ISHFT( LABEL, -24 ), 255 )
*I64                       JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
*I64                       KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
*I64                       LPACK = IAND( LABEL, 255 )
*I64                     ELSE
*I64                       LABEL = IX( (NPACK/2)+1 )
*I64                       IPACK = ISHFT( LABEL, -56 )
*I64                       JPACK = IAND( ISHFT( LABEL, -48 ), 255 )
*I64                       KPACK = IAND( ISHFT( LABEL, -40 ), 255 )
*I64                       LPACK = IAND( ISHFT( LABEL, -32 ), 255 )
*I64                     END IF
                       END IF
                       I = IPACK
                       J = JPACK
                       K = KPACK
                       L = LPACK
C
         IF (I.LE.NLOC(2)) GO TO 170
         DO 140 IM = 2, NMOL-1
            IF (I.GT.NLOC(IM+1)) GO TO 140
            IF (J.LE.NLOC(IM)) GO TO 200
            JMD = IM
            GO TO 150
  140    CONTINUE
         IF (J.LE.NLOC(NMOL)) GO TO 200
         JMD = NMOL-1
C
  150    DO 160 JM = 1, JMD
            IF (K.GT.NLOC(JM+1)) GO TO 160
            IF (L.LE.NLOC(JM)) GO TO 200
            GO TO 170
  160    CONTINUE
C
         IF (L.LE.NLOC(NMOL)) GO TO 200
C
  170    CONTINUE
C
         YY(MN)=XX(M)
         NPACK = MN
         IPACK = I
         JPACK = J
         KPACK = K
         LPACK = L
         IF (LABSIZ .EQ. 2) THEN
*I32       IY( 2*NPACK-1 ) = ISHFT( IPACK, 16 ) + JPACK
*I32       IY( 2*NPACK   ) = ISHFT( KPACK, 16 ) + LPACK
*I64       LABEL = ISHFT( IPACK, 48 ) + ISHFT( JPACK, 32 ) +
*I64 *             ISHFT( KPACK, 16 ) + LPACK
*I64       IY(NPACK) = LABEL
         ELSE IF (LABSIZ .EQ. 1) THEN
*I32       LABEL = ISHFT( IPACK, 24 ) + ISHFT( JPACK, 16 ) +
*I32 *             ISHFT( KPACK,  8 ) + LPACK
*I32       IY(NPACK) = LABEL
*I64       IF ( MOD(NPACK,2) .EQ. 0 ) THEN
*I64         LABEL = ISHFT( IPACK, 24 ) + ISHFT( JPACK, 16 ) +
*I64 *               ISHFT( KPACK,  8 ) + LPACK
*I64         IY( NPACK/2 ) = IY( NPACK/2 ) + LABEL
*I64       ELSE
*I64         LABEL = ISHFT( IPACK, 56 ) + ISHFT( JPACK, 48 ) +
*I64 *               ISHFT( KPACK, 40 ) + ISHFT( LPACK, 32 )
*I64         IY( (NPACK/2)+1 ) = LABEL
*I64       END IF
         END IF
C
         MN=MN+1
         IF (MN.GT.NINTMX) THEN
            NREC=NREC+1
            NINTO=NINTO+MN
            CALL PWRIT(IS,YY,IY,NINTMX,NINTMX)
            MN=1
         END IF
C
  200 CONTINUE
C
      IF (NXX .GT. 0) GO TO 100
C
      GO TO 400
C
C     ----- INTEGRALS ARE IN SUPERMATRIX FORM (NOPK=.FALSE.) -----
C
  300 CONTINUE
      WRITE(IW,*)' CAN NOT SORT INT2'
      CALL ABRT
C
C     ----- FINAL CLEANING UP -----
C
  400 CONTINUE
      MN=MN-1
      NINTO=NINTO+MN
      MN=-MN
      CALL PWRIT(IS,YY,IY,MN,NINTMX)
      NREC=NREC+1
      CALL SEQREW(IS)
      IF (MASWRK) WRITE(IW,2000) NINTO,NREC,NINTMX,IS
C
      CALL SEQREW(IJKO)
      RETURN
C
 2000 FORMAT(1X,I10,' INTEGRALS IN',I7,' RECORDS OF',I6,
     *       ' INTEGRALS WRITTEN ON UNIT',I3)
 3000 FORMAT(//1X,'SIFTING INTEGRALS FROM FILE',I4)
      END
C*MODULE MOROKM  *DECK ZRMEM
      SUBROUTINE ZRMEM(NINTMX)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,TDSKWRK
C
      PARAMETER (MXATM=2000, MXMOL=10)
C
      COMMON /FMCOM / XX(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /MOINFO/ NMORO,NMOL,MONO(MXMOL),NSHLLS(MXMOL),NBAS(MXMOL),
     *                NEM(MXMOL),ICHM(MXMOL),NLOC(MXMOL),IEQM(MXMOL),
     *                IBSSE,ICTPPL,ICTPLX,IMOROX,IRVS,IDUM
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      DATA CHECK/8HCHECK   /
C
      L2   = NUM*(NUM+1)/2
C
C     PARALLEL
C
      TDSKWRK = DSKWRK
      DSKWRK  = .TRUE.
C
C     LOCATE MEMORY
C
      CALL VALFM(LOADFM)
      I10  = LOADFM + 1
      I20  = I10    + NINTMX
      I30  = I20    + NINTMX
      I40  = I30    + NINTMX
      I50  = I40    + NINTMX
C
      I60  = I10 + L2
      I70  = I60 + L2
      I80  = MAX0(I70,I50)
      NEED = I80 - LOADFM - 1
      CALL GETFM(NEED)
C
      CALL ZRINT1(XX(I60),XX(I70))
      IF(NMORO.EQ.0  .AND.  EXETYP.NE.CHECK)
     *  CALL ZRINT2(XX(I10),XX(I20),XX(I30),XX(I40),NINTMX,NOPK)
C
      DSKWRK  = TDSKWRK
C
      CALL RETFM(NEED)
      RETURN
      END
C*MODULE MOROKM  *DECK LMOEDIN
      SUBROUTINE LMOEDIN(NMOL,MATOM,MCHARG,MELEC,MMULT,SUPBAS)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION LMOEDA
C
      PARAMETER (NNAM=4)
      PARAMETER (MXATM=2000, MXMOL=10)
C
      DIMENSION QNAM(NNAM),KQNAM(NNAM)
      DIMENSION MATOM(MXMOL),MCHARG(MXMOL),MELEC(MXMOL),MMULT(MXMOL)
      LOGICAL GOPARR,DSKWRK,MASWRK,SUPBAS
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DATA RHF/8HRHF     /
      DATA LMOEDA/8HLMOEDA  /
      DATA QNAM/8HMATOM   ,8HMCHARG  ,8HMMULT   ,8HSUPBAS  /
      DATA KQNAM/101,101,101,0/
C
      DO IM = 1, MXMOL
         MATOM(IM) = 0
         MELEC(IM) = 0
         MCHARG(IM)= 0
         MMULT(IM) = 1
      ENDDO
      SUPBAS= .TRUE.
C
C    ----- READ NAMELIST $LMOEDA -----
C
      CALL NAMEIO(IR,JRET,LMOEDA,NNAM,QNAM,KQNAM,
     *            MATOM,MCHARG,MMULT,SUPBAS,
     *   0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,  0,0,0,0,0,
     *   0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,  0,0,0,0,0,
     *   0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,  0,0,0,0,0)
      IF(JRET.EQ.2) THEN
         IF (MASWRK) WRITE(IW,9000)
         CALL ABRT
      END IF
C
C
      NCHSUM  = 0
      NATSUM  = 0
      NMOL    = 1
      IAT     = NAT - 1
      DO IMOL = 1, MXMOL
         NCHSUM = NCHSUM + MCHARG(IMOL)
         NATSUM = NATSUM + MATOM(IMOL)
         IAT    = IAT    - MATOM(IMOL)
         IF(IAT.GE.0) NMOL = NMOL + 1
      ENDDO
      IF(NATSUM.NE.NAT) THEN
         IF(MASWRK) WRITE(IW,9010)
         CALL ABRT
         STOP
      END IF
      IF(NCHSUM.NE.ICH) THEN
         IF(MASWRK) WRITE(IW,9015)
         CALL ABRT
         STOP
      END IF
C
C
      NSTART  = 1
      DO IMOL = 1, NMOL
         MELEC(IMOL) = -MCHARG(IMOL)
         DO III = NSTART, NSTART+MATOM(IMOL)-1
            MELEC(IMOL) = MELEC(IMOL) + INT(ZAN(III)+1.0D-03)
         ENDDO
         NSTART = NSTART + MATOM(IMOL)
      ENDDO
C
      SPIN    = (MUL - 1.0D+00)*0.50D+00
      SPINSUM = 0.0D+00
      DO IMOL = 1, NMOL
         IF(SCFTYP.EQ.RHF .AND. ABS(MMULT(IMOL)).GE.2) THEN
            IF(MASWRK) WRITE(IW,*)
     *         'ERROR: OPEN SHELL MOLECULE CANNOT USE RHF'
            CALL ABRT
         END IF
         IF(MMULT(IMOL).GT.0) THEN
            KK = MMULT(IMOL) - 1
            IF(MOD(MELEC(IMOL),2).NE.MOD(KK,2)) THEN
               IF(MASWRK) WRITE(IW,*)
     *            'ERROR: MONOMER MULTIPLICITY IS WRONG'
               CALL ABRT
            END IF
            SPINSUM = SPINSUM + (MMULT(IMOL) - 1.0D+00)*0.50D+00
         ELSE IF(MMULT(IMOL).LT.0) THEN
            KK =-MMULT(IMOL) - 1
            IF(MOD(MELEC(IMOL),2).NE.MOD(KK,2)) THEN
               IF(MASWRK) WRITE(IW,*)
     *            'ERROR: MONOMER MULTIPLICITY IS WRONG'
               CALL ABRT
            END IF
            SPINSUM = SPINSUM + (MMULT(IMOL) + 1.0D+00)*0.50D+00
         END IF
      ENDDO
      III = INT(SPIN*2.0D+00     + 1.0D-03)
      JJJ = INT(SPINSUM*2.0D+00  + 1.0D-03)
      IF(III.NE.JJJ) THEN
         IF(MASWRK) WRITE(IW,9020)
         CALL ABRT
         STOP
      END IF
C
      RETURN
C
 9000 FORMAT(1X,'ERROR IN $LMOEDA INPUT')
 9010 FORMAT(///1X,'*** JOB KILLED ***'/1X,'THE SUM OF MONOMER ',
     *          'ATOMS MUST EQUAL TO THAT OF THE SUPER MOLECULE')
 9015 FORMAT(///1X,'*** JOB KILLED ***'/1X,'THE SUM OF MONOMER ',
     *          'CHARGES MUST EQUAL TO THAT OF THE SUPER MOLECULE')
 9020 FORMAT(///1X,'*** JOB KILLED ***'/1X,'THE SUM OF MONOMER SPINS',
     *          ' MUST EQUAL TO SUPER MOLECULE SPIN, AND > 0')
      END
C*MODULE MOROKM  *DECK LMOEDAX
      SUBROUTINE LMOEDAX
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXATM=2000,NMO=500,MXMOL=10,MXSH=5000,MXGTOT=20000)
      PARAMETER (MXMPA=3*MXATM,MXMPSH=2*MXATM,MXMPGT=5*MXMPSH)
C
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
C
C
      NUM2    = NUM*NUM
      NMO2    = NMO*NMO
C
      CALL VALFM(LOADFM)
      LTMP1A  = LOADFM  + 1
      LTMP1B  = LTMP1A  + NUM2
      LTMP2   = LTMP1B  + NUM2
      LTMP3A  = LTMP2   + NUM2
      LTMP3B  = LTMP3A  + NUM2
      LCMO1A  = LTMP3B  + NUM2
      LCMO1B  = LCMO1A  + NUM2
      LCMO2A  = LCMO1B  + NUM2
      LCMO2B  = LCMO2A  + NUM2
      LCMO3A  = LCMO2B  + NUM2
      LCMO3B  = LCMO3A  + NUM2
      LTLMO1  = LCMO3B  + NUM2
      LVLMO1  = LTLMO1  + NMO2
      LTLMO1B = LVLMO1  + NMO2
      LVLMO1B = LTLMO1B + NMO2
      LGJ11   = LVLMO1B + NMO2
      LGK11   = LGJ11   + NMO2
      LGJ11B  = LGK11   + NMO2
      LGK11B  = LGJ11B  + NMO2
      LGD11   = LGK11B  + NMO2
      LGD11B  = LGD11   + NMO
      LERR    = LGD11B  + NMO
      LKCOREA = LERR    + NMO2
      LKCOREB = LKCOREA + NMO/NWDVAR + 1
      LKMINA  = LKCOREB + NMO/NWDVAR + 1
      LKMINB  = LKMINA  + NMO/NWDVAR + 1
      LEHF1   = LKMINB  + NMO/NWDVAR + 1
      LEHF2   = LEHF1   + MXMOL
      LEHF3   = LEHF2   + MXMOL
      LEMMP2  = LEHF3   + MXMOL
      LEAMP2  = LEMMP2  + MXMOL
      LEMCC   = LEAMP2  + MXMOL
      LEACC   = LEMCC   + MXMOL
      LCMO1T  = LEACC   + MXMOL
      LCMO1D  = LCMO1T  + MXMOL
      LCMO1J  = LCMO1D  + MXMOL
      LCMO1K  = LCMO1J  + MXMOL
      LCMO1V  = LCMO1K  + MXMOL
      LCMO2T  = LCMO1V  + MXMOL
      LCMO2D  = LCMO2T  + MXMOL
      LCMO2J  = LCMO2D  + MXMOL
      LCMO2K  = LCMO2J  + MXMOL
      LCMO2V  = LCMO2K  + MXMOL
      LCMO3T  = LCMO2V  + MXMOL
      LCMO3D  = LCMO3T  + MXMOL
      LCMO3J  = LCMO3D  + MXMOL
      LCMO3K  = LCMO3J  + MXMOL
      LCMO3V  = LCMO3K  + MXMOL
      LEX1    = LCMO3V  + MXMOL
      LEX2    = LEX1    + MXMOL
      LEX3    = LEX2    + MXMOL
      LEC1    = LEX3    + MXMOL
      LEC2    = LEC1    + MXMOL
      LEC3    = LEC2    + MXMOL
      LEMNU   = LEC3    + MXMOL
      LZANX   = LEMNU   + MXMOL
      LCLPX   = LZANX   + MXATM
      LZLPX   = LCLPX   + 400
      LNLPX   = LZLPX   + 400
      LKFRSTX = LNLPX   + 400/NWDVAR + 1
      LKLASTX = LKFRSTX + MXATM*6/NWDVAR + 1
      LLMAXSV = LKLASTX + MXATM*6/NWDVAR + 1
      LLPSKIPX= LLMAXSV + MXATM/NWDVAR + 1
      LIZCOREX= LLPSKIPX+ MXATM/NWDVAR + 1
      LCX     = LIZCOREX+ MXATM/NWDVAR + 1
      LIANX   = LCX     + MXATM*3
      LEXX    = LIANX   + MXATM/NWDVAR + 1
      LCSX    = LEXX    + MXGTOT
      LCPX    = LCSX    + MXGTOT
      LCDX    = LCPX    + MXGTOT
      LCFX    = LCDX    + MXGTOT
      LCGX    = LCFX    + MXGTOT
      LCHX    = LCGX    + MXGTOT
      LCIX    = LCHX    + MXGTOT
      LKSTARTX= LCIX    + MXSH
      LKATOMX = LKSTARTX+ MXSH/NWDVAR  + 1
      LKTYPEX = LKATOMX + MXSH/NWDVAR  + 1
      LKNGX   = LKTYPEX + MXSH/NWDVAR  + 1
      LKLOCX  = LKNGX   + MXSH/NWDVAR  + 1
      LMINX   = LKLOCX  + MXSH/NWDVAR  + 1
      LMAXX   = LMINX   + MXSH/NWDVAR  + 1
      LMATOM  = LMAXX   + MXSH/NWDVAR  + 1
      LMCHARG = LMATOM  + MXMOL/NWDVAR + 1
      LMELEC  = LMCHARG + MXMOL/NWDVAR + 1
      LMMULT  = LMELEC  + MXMOL/NWDVAR + 1
      LTLMOA  = LMMULT  + MXMOL/NWDVAR + 1
      LVLMOA  = LTLMOA  + NMO2
      LGJA    = LVLMOA  + NMO2
      LGKA    = LGJA    + NMO2
      LGDA    = LGKA    + NMO2
      LTLMOB  = LGDA    + NMO
      LVLMOB  = LTLMOB  + NMO2
      LGJB    = LVLMOB  + NMO2
      LGKB    = LGJB    + NMO2
      LGDB    = LGKB    + NMO2
      LMPTYPX = LGDB    + NMO
      LAN0X   = LMPTYPX + MXATM/NWDVAR + 1
      LALPN0X = LAN0X   + MXMPA
      LAN1X   = LALPN0X + MXMPA
      LALPN1X = LAN1X   + MXMPA
      LMPSKPX = LALPN1X + MXMPA
      LNOAN0X = LMPSKPX + MXATM/NWDVAR + 1
      LNOAN1X = LNOAN0X + MXATM/NWDVAR + 1
      LBPARX  = LNOAN1X + MXATM/NWDVAR + 1
      LEXPMPX = LBPARX  + MXMPSH
      LCSMPX  = LEXPMPX + MXMPGT
      LCPMPX  = LCSMPX  + MXMPGT
      LCDMPX  = LCPMPX  + MXMPGT
      LCFMPX  = LCDMPX  + MXMPGT
      LMPSKIPX= LCFMPX  + MXMPGT
      LNOCOSHX= LMPSKIPX+ MXATM/NWDVAR + 1
      LMPKSTAX= LNOCOSHX+ MXATM/NWDVAR + 1
      LMPKNGX = LMPKSTAX+ MXMPSH/NWDVAR+ 1
      LMPKTYPX= LMPKNGX + MXMPSH/NWDVAR+ 1
      LMPKMINX= LMPKTYPX+ MXMPSH/NWDVAR+ 1
      LMPKMAXX= LMPKMINX+ MXMPSH/NWDVAR+ 1
      LMPKLOCX= LMPKMAXX+ MXMPSH/NWDVAR+ 1
      LAST    = LMPKLOCX+ MXMPSH/NWDVAR+ 1
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
      CALL LMOED(X(LTMP1A),X(LTMP1B),X(LTMP2),
     *           X(LTMP3A),X(LTMP3B),X(LCMO1A),X(LCMO1B),
     *           X(LCMO2A),X(LCMO2B),X(LCMO3A),X(LCMO3B),
     *           X(LTLMO1),X(LVLMO1),X(LTLMO1B),X(LVLMO1B),
     *           X(LGJ11),X(LGK11),X(LGJ11B),X(LGK11B),
     *           X(LGD11),X(LGD11B),X(LERR),X(LKCOREA),X(LKCOREB),
     *           X(LKMINA),X(LKMINB),X(LEHF1),X(LEHF2),X(LEHF3),
     *           X(LEMMP2),X(LEAMP2),X(LEMCC),X(LEACC),
     *           X(LCMO1T),X(LCMO1D),X(LCMO1J),X(LCMO1K),X(LCMO1V),
     *           X(LCMO2T),X(LCMO2D),X(LCMO2J),X(LCMO2K),X(LCMO2V),
     *           X(LCMO3T),X(LCMO3D),X(LCMO3J),X(LCMO3K),X(LCMO3V),
     *           X(LEX1),X(LEX2),X(LEX3),X(LEC1),X(LEC2),X(LEC3),
     *           X(LEMNU),X(LZANX),X(LCLPX),X(LZLPX),X(LNLPX),
     *           X(LKFRSTX),X(LKLASTX),X(LLMAXSV),X(LLPSKIPX),
     *           X(LIZCOREX),X(LCX),X(LIANX),
     *           X(LEXX),X(LCSX),X(LCPX),X(LCDX),X(LCFX),X(LCGX),
     *           X(LCHX),X(LCIX),X(LKSTARTX),X(LKATOMX),X(LKTYPEX),
     *           X(LKNGX),X(LKLOCX),X(LMINX),X(LMAXX),
     *           X(LMATOM),X(LMCHARG),X(LMELEC),X(LMMULT),
     *           X(LTLMOA),X(LVLMOA),X(LGJA),X(LGKA),X(LGDA),
     *           X(LTLMOB),X(LVLMOB),X(LGJB),X(LGKB),X(LGDB),
     *           X(LMPTYPX),X(LAN0X),X(LALPN0X),X(LAN1X),X(LALPN1X),
     *           X(LMPSKPX),X(LNOAN0X),X(LNOAN1X),
     *           X(LBPARX),X(LEXPMPX),X(LCSMPX),
     *           X(LCPMPX),X(LCDMPX),X(LCFMPX),
     *           X(LMPSKIPX),X(LNOCOSHX),X(LMPKSTAX),
     *           X(LMPKNGX),X(LMPKTYPX),X(LMPKMINX),
     *           X(LMPKMAXX),X(LMPKLOCX))
      CALL RETFM(NEED)
      RETURN
      END
C*MODULE MOROKM  *DECK LMOED
      SUBROUTINE LMOED(TMP1A,TMP1B,TMP2,TMP3A,TMP3B,
     *                 CMO1A,CMO1B,CMO2A,CMO2B,CMO3A,CMO3B,
     *                 TLMO1,VLMO1,TLMO1B,VLMO1B,
     *                 GJ11,GK11,GJ11B,GK11B,GD11,GD11B,
     *                 ERR,KCOREA,KCOREB,KMINA,KMINB,EHF1,EHF2,EHF3,
     *                 EMMP2,EAMP2,EMCC,EACC,
     *                 CMO1T,CMO1D,CMO1J,CMO1K,CMO1V,
     *                 CMO2T,CMO2D,CMO2J,CMO2K,CMO2V,
     *                 CMO3T,CMO3D,CMO3J,CMO3K,CMO3V,
     *                 EX1,EX2,EX3,EC1,EC2,EC3,
     *                 EMNU,ZANX,CLPX,ZLPX,NLPX,
     *                 KFRSTX,KLASTX,LMAXSV,LPSKIPX,
     *                 IZCOREX,CX,IANX,
     *                 EXX,CSX,CPX,CDX,CFX,CGX,
     *                 CHX,CIX,KSTARTX,KATOMX,KTYPEX,
     *                 KNGX,KLOCX,MINX,MAXX,
     *                 MATOM,MCHARG,MELEC,MMULT,
     *                 TLMOA,VLMOA,GJA,GKA,GDA,
     *                 TLMOB,VLMOB,GJB,GKB,GDB,
     *                 MPTYPX,AN0X,ALPN0X,AN1X,ALPN1X,
     *                 MPSKPX,NOAN0X,NOAN1X,
     *                 BPARX,EXPMPX,CSMPX,
     *                 CPMPX,CDMPX,CFMPX,
     *                 MPSKIPX,NOCOSHX,MPKSTAX,
     *                 MPKNGX,MPKTYPX,MPKMINX,
     *                 MPKMAXX,MPKLOCX)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,
     *        ZDOSV,ZDOSV1,MPTEST,SUPBAS,CNVR,MOIDON,EDCOMP,DIPDCM,
     *        DEPRNT,QADDCM,ZDO,POLDCM,POLANG,POLAPP,KMIDPT,POLDYN
C
      CHARACTER*4 CDUMMY
C
      PARAMETER (MXAO=8192,MXSH=5000,MXMOL=10,MXATM=2000,
     *           MXGTOT=20000,NMO=500,MXRT=100)
      PARAMETER (MXMPA=3*MXATM,MXMPSH=2*MXATM,MXMPGT=5*MXMPSH)
C
      DIMENSION TMP1A(NUM,NUM),TMP2(NUM*NUM),TMP3A(NUM,NUM),
     *          TMP1B(NUM,NUM),TMP3B(NUM,NUM),
     *          CMO1A(NUM,NUM),CMO2A(NUM,NUM),CMO3A(NUM,NUM),
     *          CMO1B(NUM,NUM),CMO2B(NUM,NUM),CMO3B(NUM,NUM),
     *          TLMO1(NMO,NMO),VLMO1(NMO,NMO),
     *          TLMO1B(NMO,NMO),VLMO1B(NMO,NMO),
     *          GJ11(NMO,NMO),GK11(NMO,NMO),GD11(NMO),
     *          GJ11B(NMO,NMO),GK11B(NMO,NMO),GD11B(NMO),
     *          KCOREA(NMO),KCOREB(NMO),
     *          KMINA(NMO),KMINB(NMO),ERR(NMO,NMO),
     *          EHF1(MXMOL),EHF2(MXMOL),EHF3(MXMOL),
     *          EMMP2(MXMOL),EAMP2(MXMOL),EMCC(MXMOL),EACC(MXMOL),
     *          CMO1T(MXMOL),CMO1D(MXMOL),CMO1J(MXMOL),
     *          CMO1K(MXMOL),CMO1V(MXMOL),
     *          CMO2T(MXMOL),CMO2D(MXMOL),CMO2J(MXMOL),
     *          CMO2K(MXMOL),CMO2V(MXMOL),
     *          CMO3T(MXMOL),CMO3D(MXMOL),CMO3J(MXMOL),
     *          CMO3K(MXMOL),CMO3V(MXMOL),
     *          EX1(MXMOL),EX2(MXMOL),EX3(MXMOL),
     *          EC1(MXMOL),EC2(MXMOL),EC3(MXMOL),EMNU(MXMOL),
     *          ZANX(MXATM),CLPX(400),ZLPX(400),NLPX(400),
     *          KFRSTX(MXATM,6),KLASTX(MXATM,6),LMAXSV(MXATM),
     *          LPSKIPX(MXATM),IZCOREX(MXATM),CX(3,MXATM),IANX(MXATM),
     *          EXX(MXGTOT),CSX(MXGTOT),CPX(MXGTOT),CDX(MXGTOT),
     *          CFX(MXGTOT),CGX(MXGTOT),CHX(MXGTOT),CIX(MXGTOT),
     *          KSTARTX(MXSH),KATOMX(MXSH),
     *          KTYPEX(MXSH),KNGX(MXSH),
     *          KLOCX(MXSH),MINX(MXSH),MAXX(MXSH),
     *          MATOM(MXMOL),MCHARG(MXMOL),MELEC(MXMOL),MMULT(MXMOL),
     *          TLMOA(NMO,NMO),VLMOA(NMO,NMO),
     *          GJA(NMO,NMO),GKA(NMO,NMO),GDA(NMO),
     *          TLMOB(NMO,NMO),VLMOB(NMO,NMO),
     *          GJB(NMO,NMO),GKB(NMO,NMO),GDB(NMO),
     *          MPTYPX(MXATM),AN0X(MXMPA),ALPN0X(MXMPA),
     *          AN1X(MXMPA),ALPN1X(MXMPA),
     *          MPSKPX(MXATM),NOAN0X(MXATM),NOAN1X(MXATM),
     *          BPARX(MXMPSH),EXPMPX(MXMPGT),CSMPX(MXMPGT),
     *          CPMPX(MXMPGT),CDMPX(MXMPGT),CFMPX(MXMPGT),
     *          MPSKIPX(MXATM),NOCOSHX(MXATM),MPKSTAX(MXMPSH),
     *          MPKNGX(MXMPSH),MPKTYPX(MXMPSH),MPKMINX(MXMPSH),
     *          MPKMAXX(MXMPSH),MPKLOCX(MXMPSH)
C
      COMMON /CCENGY/ ENRG,EREF,EMP2CC,ECCN,ETOTCC(6),ECORR(6),
     *                DIAGS(3),AMPMX(5,2),IAMPMX(5,4,2),XO1,XO2,
     *                DIFMAX,DIFFENG,ITERCC,CNVR
      COMMON /CONV  / DENTOL,EN,ETOT,EHF,EHF0,DIFF,ITER,ICALP,ICBET
      COMMON /DFTPAR/ DFTTYP(20),EXENA,EXENB,EXENC,IDFT34,NAUXFUN,
     *                                                    NAUXSHL
      COMMON /ECP2  / CLP(400),ZLP(400),NLP(400),KFRST(MXATM,6),
     *                KLAST(MXATM,6),LMAX(MXATM),LPSKIP(MXATM),
     *                IZCORE(MXATM)
      COMMON /EDCMP / ZIJ(NMO),ZMO(5,NMO),OCCUP(NMO),DPFREQ(50),
     *                MOIDNO(5,NMO),IJMO(2,NMO),MOIJ(NMO),NMOIJ(NMO),
     *                NMOAT(NMO),NDPFREQ,IPROT(5),NPROT,
     *                MOIDON,EDCOMP,DIPDCM,DEPRNT,QADDCM,ZDO,POLDCM,
     *                POLANG,POLAPP,KMIDPT,POLDYN
      COMMON /ENRGMP/ EMP2,EMP3,EMP4,EMP2A
      COMMON /ENRGYS/ ENUC,EELEC,ETOTX,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FMCOM / XX(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEXTFLD
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /LMOEDA/ GDTOLA,GJTOLA,GKTOLA,TKTOLA,VTOLA,
     *                GDTOLB,GJTOLB,GKTOLB,TKTOLB,VTOLB,
     *                ECORL,EXCOR
      COMMON /MMPDOC/ MPTYP(MXATM),IMVO,IMCORE
      COMMON /MMP1  / AN0(MXMPA),ALPN0(MXMPA),AN1(MXMPA),ALPN1(MXMPA),
     *                MPSKP(MXATM),NOAN0(MXATM),NOAN1(MXATM)
      COMMON /MMP2  / BPAR(MXMPSH),EXPMP(MXMPGT),CSMP(MXMPGT),
     *                CPMP(MXMPGT),CDMP(MXMPGT),CFMP(MXMPGT),
     *                MPSKIP(MXATM),NOCOSH(MXATM),MPKSTA(MXMPSH),
     *                MPKNG(MXMPSH),MPKTYP(MXMPSH),MPKMIN(MXMPSH),
     *                MPKMAX(MXMPSH),MPKLOC(MXMPSH)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),MIN(MXSH),MAX(MXSH),NSHELL
      COMMON /OPTLOC/ CVGLOC,MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,
     *                MOOUTA(MXAO),MOOUTB(MXAO)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SCFOPT/ CONVHF,MAXIT,MCONV,NPUNCH,NPREO(4)
      COMMON /SIMDAT/ NACC,NREJ,IGOMIN,NRPA,IBWM,NACCT,NREJT,NRPAT,
     *                NPRTGO,IDPUNC,IGOFLG
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                T(432),INVT(48),NT
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
C
      DATA RHF,UHF,ROHF/8HRHF     ,8HUHF     ,8HROHF    /
      DATA RNONE,CCSD,CCSDT/8HNONE    ,8HCCSD    ,8HCCSD(T) /
      DATA ZERO/0.00D+00/, TOKCAL/627.51D+00/
      DATA PT25,PT5,TWO/0.25D+00,0.50D+00,2.0D+00/
C
C
C
      CALL VCLR(CMO1A,1,NUM*NUM)
      CALL VCLR(CMO2A,1,NUM*NUM)
      CALL VCLR(CMO3A,1,NUM*NUM)
      CALL VCLR(CMO1B,1,NUM*NUM)
      CALL VCLR(CMO2B,1,NUM*NUM)
      CALL VCLR(CMO3B,1,NUM*NUM)
      CALL VCLR(TMP1A,1,NUM*NUM)
      CALL VCLR(TMP2 ,1,NUM*NUM)
      CALL VCLR(TMP3A,1,NUM*NUM)
      CALL VCLR(TMP1B,1,NUM*NUM)
      CALL VCLR(TMP3B,1,NUM*NUM)
      CALL VCLR(TLMO1,1,NMO*NMO)
      CALL VCLR(VLMO1,1,NMO*NMO)
      CALL VCLR(TLMO1B,1,NMO*NMO)
      CALL VCLR(VLMO1B,1,NMO*NMO)
      CALL VCLR(GJ11,1,NMO*NMO)
      CALL VCLR(GK11,1,NMO*NMO)
      CALL VCLR(GD11,1,NMO)
      CALL VCLR(GJ11B,1,NMO*NMO)
      CALL VCLR(GK11B,1,NMO*NMO)
      CALL VCLR(GD11B,1,NMO)
      CALL VCLR(EHF1,1,MXMOL)
      CALL VCLR(EHF2,1,MXMOL)
      CALL VCLR(EHF3,1,MXMOL)
      CALL VCLR(EMMP2,1,MXMOL)
      CALL VCLR(EAMP2,1,MXMOL)
      CALL VCLR(EMCC,1,MXMOL)
      CALL VCLR(EACC,1,MXMOL)
      CALL VCLR(CMO1T,1,MXMOL)
      CALL VCLR(CMO1D,1,MXMOL)
      CALL VCLR(CMO1J,1,MXMOL)
      CALL VCLR(CMO1K,1,MXMOL)
      CALL VCLR(CMO1V,1,MXMOL)
      CALL VCLR(CMO2T,1,MXMOL)
      CALL VCLR(CMO2D,1,MXMOL)
      CALL VCLR(CMO2J,1,MXMOL)
      CALL VCLR(CMO2K,1,MXMOL)
      CALL VCLR(CMO2V,1,MXMOL)
      CALL VCLR(CMO3T,1,MXMOL)
      CALL VCLR(CMO3D,1,MXMOL)
      CALL VCLR(CMO3J,1,MXMOL)
      CALL VCLR(CMO3K,1,MXMOL)
      CALL VCLR(CMO3V,1,MXMOL)
      CALL VCLR(EX1,1,MXMOL)
      CALL VCLR(EX2,1,MXMOL)
      CALL VCLR(EX3,1,MXMOL)
      CALL VCLR(EC1,1,MXMOL)
      CALL VCLR(EC2,1,MXMOL)
      CALL VCLR(EC3,1,MXMOL)
      CALL VCLR(EMNU,1,MXMOL)
      CALL VCLR(ZANX,1,MXATM)
      CALL VCLR(CX,1,3*MXATM)
      CALL VCLR(EXX,1,MXGTOT)
      CALL VCLR(CSX,1,MXGTOT)
      CALL VCLR(CPX,1,MXGTOT)
      CALL VCLR(CDX,1,MXGTOT)
      CALL VCLR(CFX,1,MXGTOT)
      CALL VCLR(CGX,1,MXGTOT)
      CALL VCLR(CHX,1,MXGTOT)
      CALL VCLR(CIX,1,MXGTOT)
C
      CALL VICLR(IANX,1,MXATM)
      CALL VICLR(IZCOREX,1,MXATM)
      CALL VICLR(KSTARTX,1,MXSH)
      CALL VICLR(KATOMX,1,MXSH)
      CALL VICLR(KTYPEX,1,MXSH)
      CALL VICLR(KNGX,1,MXSH)
      CALL VICLR(KLOCX,1,MXSH)
      CALL VICLR(MINX,1,MXSH)
      CALL VICLR(MAXX,1,MXSH)
      CALL VICLR(KCOREA,1,NMO)
      CALL VICLR(KCOREB,1,NMO)
      CALL VICLR(KMINA,1,NMO)
      CALL VICLR(KMINB,1,NMO)
      CALL VICLR(MATOM,1,MXMOL)
      CALL VICLR(MCHARG,1,MXMOL)
      CALL VICLR(MELEC,1,MXMOL)
      CALL VICLR(MMULT,1,MXMOL)
C
      CALL VICLR(MPTYPX ,1, MXATM)
      CALL VCLR (AN0X   ,1, MXMPA)
      CALL VCLR (ALPN0X ,1, MXMPA)
      CALL VCLR (AN1X   ,1, MXMPA)
      CALL VCLR (ALPN1X ,1, MXMPA)
      CALL VICLR(MPSKPX ,1, MXATM)
      CALL VICLR(NOAN0X ,1, MXATM)
      CALL VICLR(NOAN1X ,1, MXATM)
      CALL VCLR (BPARX  ,1, MXMPSH)
      CALL VCLR (EXPMPX ,1, MXMPGT)
      CALL VCLR (CSMPX  ,1, MXMPGT)
      CALL VCLR (CPMPX  ,1, MXMPGT)
      CALL VCLR (CDMPX  ,1, MXMPGT)
      CALL VCLR (CFMPX  ,1, MXMPGT)
      CALL VICLR(MPSKIPX,1, MXATM)
      CALL VICLR(NOCOSHX,1, MXATM)
      CALL VICLR(MPKSTAX,1, MXMPSH)
      CALL VICLR(MPKNGX ,1, MXMPSH)
      CALL VICLR(MPKTYPX,1, MXMPSH)
      CALL VICLR(MPKMINX,1, MXMPSH)
      CALL VICLR(MPKMAXX,1, MXMPSH)
      CALL VICLR(MPKLOCX,1, MXMPSH)
C
C     - DFTTYP(3) IS THE COEFFICIENT FOR HARTREE-FOCK EXCHANGE
      DFHY = ZERO
      IF(DFTYPE.NE.RNONE) THEN
         DFHY = DFTTYP(3)
      END IF
C
C
      MPTEST   = .FALSE.
C
      NT=1
      IF((SCFTYP.NE.RHF).AND.(SCFTYP.NE.UHF).AND.(SCFTYP.NE.ROHF))THEN
        IF (MASWRK) WRITE(IW,4000)
        CALL ABRT
      END IF
C
C     - HUI LI: IT IS CRAZY BUT NECESSARY TO CALL THEM HERE -
C       SECRET: TO OCCUPY THE DAF SPACES !
C     LMOEDA CHANGES SIZES SO HERE THE MAXIMUM SIZES ARE USED
C
      CALL VALFM(LOADFM)
      LWORK   = LOADFM  + 1
      LAST    = LWORK   + NUM*NUM
      NEED    = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      LL2     = (NUM*NUM+NUM)/2
      NSH2 = (NSHELL*NSHELL+NSHELL)/2
      CALL VCLR(XX(LWORK),1,NUM*NUM)
C
      CALL DAWRIT(IDAF,IODA,XX(LWORK),LL2,14,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),LL2,18,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),LL2,23,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),LL2,24,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),LL2,25,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),LL2,26,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),LL2,27,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),LL2,28,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),LL2,35,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),LL2,36,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),LL2,51,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),LL2,95,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),LL2,96,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),LL2,97,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),3*NUM,250,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),LL2,308,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),LL2,355,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),LL2,418,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),LL2,428,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),NSH2,54,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),NUM*NUM,15,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),NUM*NUM,19,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),NUM*NUM,61,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),NUM*NUM,71,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),NUM*NUM,72,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),(NA+NB)*(NA+NB),73,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),NA*NA,74,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),(NA+NB)*(NA+NB),285,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),NUM,324,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),NUM,356,0)
      CALL DAWRIT(IDAF,IODA,XX(LWORK),NUM,357,0)
      CALL RETFM(NEED)
C
      CALL ONEEI
      CALL GUESMO(GUESS)
C
      NMOL    =  1
      SUPBAS  =  .TRUE.
C
      IF (MASWRK) WRITE(IW,1000)
      CALL LMOEDIN(NMOL,MATOM,MCHARG,MELEC,MMULT,SUPBAS)
C     **************************************************
      IF (MASWRK) WRITE(IW,2000)
C
C     - LMOEDA WORKS ONLY WITH ENERGY LOCALIZATION -
C       AND NO FROZEN CORE ORBITALS
      IF(ILOCAL.NE.2) THEN
         IF(MASWRK) WRITE(IW,*)
     *         ' ERROR: PLEASE USE LOCAL=RUEDNBRG FOR LMOEDA'
         CALL ABRT
      END IF
      IF(IFCORE.EQ.1) THEN
         IF(MASWRK) WRITE(IW,*)
     *         ' ERROR: PLEASE USE FCORE=.F. FOR LMOEDA'
         CALL ABRT
      END IF
C     - ONLY CCSD AND CCSD(T) ARE IMPLEMENTED -
      IF(CCTYP.NE.CCSD .AND. CCTYP.NE.CCSDT .AND. CCTYP.NE.RNONE)THEN
         IF(MASWRK) WRITE(IW,*)
     *   ' ERROR: ONLY CCSD AND CCSD(T) ARE IMPLEMENTED FOR LMOEDA'
         CALL ABRT
      END IF
C
C     - SAVE MOLECULAR INFORMATION -
C
      NATX    =  NAT
      ICHX    =  ICH
      MULX    =  MUL
      NUMX    =  NUM
      NQMTX   =  NQMT
      NEX     =  NE
      NAX     =  NA
      NBX     =  NB
      IECPX   =  IECP
      IMCOREX =  IMCORE
      DO III  =  1, NAT
         ZANX(III)   = ZAN(III)
         DO JJJ = 1, 6
            KFRSTX(III,JJJ) = KFRST(III,JJJ)
            KLASTX(III,JJJ) = KLAST(III,JJJ)
         ENDDO
         LMAXSV(III) = LMAX(III)
         LPSKIPX(III)= LPSKIP(III)
         IZCOREX(III)= IZCORE(III)
         CX(1,III)   = C(1,III)
         CX(2,III)   = C(2,III)
         CX(3,III)   = C(3,III)
         IANX(III)   = IAN(III)
      ENDDO
      DO III = 1, 400
         CLPX(III) = CLP(III)
         ZLPX(III) = ZLP(III)
         NLPX(III) = NLP(III)
      ENDDO
C
      DO III  =  1, MXGTOT
         EXX(III)  = EX(III)
         CSX(III)  = CS(III)
         CPX(III)  = CP(III)
         CDX(III)  = CD(III)
         CFX(III)  = CF(III)
         CGX(III)  = CG(III)
         CHX(III)  = CH(III)
         CIX(III)  = CI(III)
      ENDDO
      DO III  =  1, MXSH
         KSTARTX(III)  = KSTART(III)
         KATOMX(III)   = KATOM(III)
         KTYPEX(III)   = KTYPE(III)
         KNGX(III)     = KNG(III)
         KLOCX(III)    = KLOC(III)
         MINX(III)     = MIN(III)
         MAXX(III)     = MAX(III)
      ENDDO
      NSHELLX = NSHELL
      SCFTYPSV= SCFTYP
      IF(SCFTYPSV.EQ.ROHF) SCFTYP = UHF
C
      CALL ICOPY(MXATM ,MPTYP ,1, MPTYPX ,1)
      CALL DCOPY(MXMPA ,AN0   ,1, AN0X   ,1)
      CALL DCOPY(MXMPA ,ALPN0 ,1, ALPN0X ,1)
      CALL DCOPY(MXMPA ,AN1   ,1, AN1X   ,1)
      CALL DCOPY(MXMPA ,ALPN1 ,1, ALPN1X ,1)
      CALL ICOPY(MXATM ,MPSKP ,1, MPSKPX ,1)
      CALL ICOPY(MXATM ,NOAN0 ,1, NOAN0X ,1)
      CALL ICOPY(MXATM ,NOAN1 ,1, NOAN1X ,1)
      CALL DCOPY(MXMPSH,BPAR  ,1, BPARX  ,1)
      CALL DCOPY(MXMPGT,EXPMP ,1, EXPMPX ,1)
      CALL DCOPY(MXMPGT,CSMP  ,1, CSMPX  ,1)
      CALL DCOPY(MXMPGT,CPMP  ,1, CPMPX  ,1)
      CALL DCOPY(MXMPGT,CDMP  ,1, CDMPX  ,1)
      CALL DCOPY(MXMPGT,CFMP  ,1, CFMPX  ,1)
      CALL ICOPY(MXATM ,MPSKIP,1, MPSKIPX,1)
      CALL ICOPY(MXATM ,NOCOSH,1, NOCOSHX,1)
      CALL ICOPY(MXMPSH,MPKSTA,1, MPKSTAX,1)
      CALL ICOPY(MXMPSH,MPKNG ,1, MPKNGX ,1)
      CALL ICOPY(MXMPSH,MPKTYP,1, MPKTYPX,1)
      CALL ICOPY(MXMPSH,MPKMIN,1, MPKMINX,1)
      CALL ICOPY(MXMPSH,MPKMAX,1, MPKMAXX,1)
      CALL ICOPY(MXMPSH,MPKLOC,1, MPKLOCX,1)
C
C
C
C
C
C     ---------------------------------
C     - MONOMER ENERGY WITH OWN BASIS -
C     ---------------------------------
C
      EMALL    = ZERO
      EMMP2ALL = ZERO
      EMCCALL  = ZERO
      ENUCM    = ZERO
      NAALL    = 0
      NBALL    = 0
      NSTART   = 1
      NUMALL   = 0
      IMP      = 0
      JMP      = 0
      ICORSH   = 0
      IGTF     = 0
      MPNUMALL = 0
      PSMK0     = ZERO
      PSMC0     = ZERO
      DO 100 IM = 1, NMOL
         IF (MASWRK) WRITE(IW,5000) IM
         NAT     =  MATOM(IM)
         MUL     =  MMULT(IM)
         IF(MMULT(IM).LT.0) MUL = - MMULT(IM)
         NE      =  MELEC(IM)
         NA      =  (NE-1+MUL)/2
         NB      =  (NE+1-MUL)/2
         IAT     =  0
         IECP    =  0
         IMPIM   =  0
         JMPIM   =  0
         ICORSHIM=  0
         IGTFIM  =  0
         IMCORE  =  0
         DO III  =  NSTART, NSTART + MATOM(IM) -1
            IAT      = IAT + 1
            ZAN(IAT) = ZANX(III)
            C(1,IAT) = CX(1,III)
            C(2,IAT) = CX(2,III)
            C(3,IAT) = CX(3,III)
            IAN(IAT) = IANX(III)
            DO JJJ = 1, 6
               KFRST(IAT,JJJ) = KFRSTX(III,JJJ)
               KLAST(IAT,JJJ) = KLASTX(III,JJJ)
            ENDDO
            LMAX(IAT) = LMAXSV(III)
            LPSKIP(IAT)= LPSKIPX(III)
            DO LLL = 1, LMAX(IAT) + 1
               KF = KFRST(IAT,LLL)
               KL = KLAST(IAT,LLL)
               KFIII = KFRSTX(III,LLL)
               DO KKK = KF, KL
                  CLP(KKK) = CLPX(KFIII + (KKK-KF))
                  ZLP(KKK) = ZLPX(KFIII + (KKK-KF))
                  NLP(KKK) = NLPX(KFIII + (KKK-KF))
               ENDDO
            ENDDO
            IZCORE(IAT) = IZCOREX(III)
            IF(IZCOREX(III).GT.0) IECP = IECPX
            MPTYP(IAT)  = MPTYPX(III)
            MPSKP(IAT)  = MPSKPX(III)
            NOAN0(IAT)  = NOAN0X(III)
            NOAN1(IAT)  = NOAN1X(III)
            MPSKIP(IAT) = MPSKIPX(III)
            NOCOSH(IAT) = NOCOSHX(III)
            DO LLL = 1, NOAN0X(III)
               AN0(IMPIM+LLL)    = AN0X(IMP+LLL)
               ALPN0(IMPIM+LLL)  = ALPN0X(IMP+LLL)
            ENDDO
            DO LLL = 1, NOAN1X(III)
               AN1(JMPIM+LLL)    = AN1X(JMP+LLL)
               ALPN1(JMPIM+LLL)  = ALPN1X(JMP+LLL)
            ENDDO
            DO LLL = 1, NOCOSHX(III)
               BPAR  (ICORSHIM+LLL) = BPARX  (ICORSH+LLL)
               MPKNG (ICORSHIM+LLL) = MPKNGX (ICORSH+LLL)
               MPKTYP(ICORSHIM+LLL) = MPKTYPX(ICORSH+LLL)
               IF(MPKTYP(ICORSHIM+LLL).EQ.1) IMCORE = IMCORE + 1
               IF(MPKTYP(ICORSHIM+LLL).EQ.2) IMCORE = IMCORE + 3
               IF(MPKTYP(ICORSHIM+LLL).EQ.3) IMCORE = IMCORE + 6
               IF(MPKTYP(ICORSHIM+LLL).EQ.4) IMCORE = IMCORE + 10
               MPKMIN(ICORSHIM+LLL) = MPKMINX(ICORSH+LLL)
               MPKMAX(ICORSHIM+LLL) = MPKMAXX(ICORSH+LLL)
               MPKLOC(ICORSHIM+LLL) = MPKLOCX(ICORSH+LLL)-MPNUMALL
               MPKSTA(ICORSHIM+LLL) = MPKSTAX(ICORSH+LLL)-IGTF+IGTFIM
               DO KKK = 1, MPKNGX(ICORSH+LLL)
                  IGTFIM        = IGTFIM + 1
                  IGTF          = IGTF   + 1
                  EXPMP(IGTFIM) = EXPMPX(IGTF)
                  CSMP(IGTFIM)  = CSMPX(IGTF)
                  CPMP(IGTFIM)  = CPMPX(IGTF)
                  CDMP(IGTFIM)  = CDMPX(IGTF)
                  CFMP(IGTFIM)  = CFMPX(IGTF)
               ENDDO
            ENDDO
            IMPIM       = IMPIM   + NOAN0X (III)
            JMPIM       = JMPIM   + NOAN1X (III)
            ICORSHIM    = ICORSHIM+ NOCOSHX(III)
            IMP         = IMP     + NOAN0X (III)
            JMP         = JMP     + NOAN1X (III)
            ICORSH      = ICORSH  + NOCOSHX(III)
            IF(IAT.EQ.NAT) MPNUM = MPKLOC(ICORSHIM) + MPKMAX(ICORSHIM)
     *                                              - MPKMIN(ICORSHIM)
         ENDDO
         MPNUMALL = MPNUMALL + MPNUM
C
         III = 0
         JJJ = 0
         NUM = 0
         NPGALL = 0
         DO KKK  =  1, NSHELLX
            IATX=KATOMX(KKK)
            IF(IATX.GE.NSTART .AND. IATX.LE.(NSTART+MATOM(IM)-1)) THEN
               III = III + 1
               KSTART(III)  = KSTARTX(KKK) - NPGALL
               KATOM(III)   = KATOMX(KKK) - NSTART + 1
               KTYPE(III)   = KTYPEX(KKK)
               KNG(III)     = KNGX(KKK)
               KLOC(III)    = KLOCX(KKK) - NUMALL
               MIN(III)     = MINX(KKK)
               MAX(III)     = MAXX(KKK)
               I1 = KSTARTX(KKK)
               I2 = I1 + KNGX(KKK) - 1
               DO IG = I1, I2
                  JJJ = JJJ + 1
                  EX(JJJ)  = EXX(IG)
                  CS(JJJ)  = CSX(IG)
                  CP(JJJ)  = CPX(IG)
                  CD(JJJ)  = CDX(IG)
                  CF(JJJ)  = CFX(IG)
                  CG(JJJ)  = CGX(IG)
                  CH(JJJ)  = CHX(IG)
                  CI(JJJ)  = CIX(IG)
               ENDDO
            ELSE
               NPGALL = NPGALL + KNGX(KKK)
            END IF
            IF(IATX.EQ.(NSTART+MATOM(IM)-1)) THEN
               NUM = KLOC(III) + MAX(III) - MIN(III)
            END IF
         ENDDO
         NSHELL = III
         NQMT   = NUM
C
         DO LLL = 1, IAT
            ZAN(LLL) = ZAN(LLL) + IZCORE(LLL)
         ENDDO
         CALL SETLAB(1,CDUMMY)
         DO LLL = 1, IAT
            ZAN(LLL) = ZAN(LLL) - IZCORE(LLL)
         ENDDO
C
         CALL SYMORB
C
         ECORL    = ZERO
         EXCOR    = ZERO
         ETOT     = ZERO
         TKTOLA   = ZERO
         VTOLA    = ZERO
         GKTOLA   = ZERO
         GDTOLA   = ZERO
         GJTOLA   = ZERO
         TKTOLB   = ZERO
         VTOLB    = ZERO
         GKTOLB   = ZERO
         GDTOLB   = ZERO
         GJTOLB   = ZERO
         GKSV     = ZERO
         EMP2     = ZERO
         ESCF     = ZERO
         EMP2CC   = ZERO
         ENRG     = ZERO
         ECORR(2) = ZERO
         IF(NE.GT.0) THEN
            CCTYPSV = CCTYP
            IF(NE.EQ.1) CCTYP = RNONE
            IF(SCFTYPSV.EQ.ROHF) SCFTYP=ROHF
            IF(MPLEVL.EQ.2) CALL MP2INP(MPTEST)
            IF(CCTYP.EQ.CCSDT .OR. CCTYP.EQ.CCSD) CALL CCINP
            IREST = 0
            NEVALS= 0
            CALL ENERGX
            CCTYP = CCTYPSV
            EHF1(IM) = ESCF
            EMALL  = EMALL + ESCF
            IF(MPLEVL.EQ.2) THEN
               EMMP2(IM)=EMP2
               EMMP2ALL =EMMP2ALL + EMP2
            END IF
            IF(CCTYP.EQ.CCSDT .OR. CCTYP.EQ.CCSD) THEN
               CALL CCFCLO(.FALSE.)
               IF(SCFTYP.EQ.ROHF) THEN
                  DO IFILE=70, 95
                     CALL CCCLOS(IFILE,'DELETE')
                  END DO
               END IF
               EMMP2(IM) = EHF1(IM)  + EMP2CC
               EMMP2ALL  = EMMP2ALL  + EMMP2(IM)
               EMCC(IM)  = EHF1(IM)  + ECORR(2)
               IF(CCTYP.EQ.CCSD) EMCC(IM)  = EHF1(IM)  + ENRG
               EMCCALL   = EMCCALL   + EMCC(IM)
            END IF
            ILOCAL = 2
            CALL LOCENG
            IF(SCFTYPSV.EQ.ROHF) THEN
C              - USE LOCENG AGAIN IN UHF MODE TO GET CORRECT ENERGIES -
               SCFTYP=UHF
               CALL DAREAD(IDAF,IODA,TMP2,NUMX*NUMX,71,0)
               CALL DAWRIT(IDAF,IODA,TMP2,NUMX*NUMX,15,0)
               CALL DAWRIT(IDAF,IODA,TMP2,NUMX*NUMX,19,0)
               TKTOLA   = ZERO
               VTOLA    = ZERO
               GKTOLA   = ZERO
               GDTOLA   = ZERO
               GJTOLA   = ZERO
               TKTOLB   = ZERO
               VTOLB    = ZERO
               GKTOLB   = ZERO
               GDTOLB   = ZERO
               GJTOLB   = ZERO
               NPRINTSV = NPRINT
               NPRINT   = -5
               ZDOSV    = ZDO
               ZDO      = .TRUE.
               ILOCAL   = 0
               IF(NE.GT.0) CALL LOCENG
               NPRINT   = NPRINTSV
               ZDO      = ZDOSV
               CALL DAREAD(IDAF,IODA,TMP2,NUMX*NUMX,71,0)
               CALL DAWRIT(IDAF,IODA,TMP2,NUMX*NUMX,72,0)
            END IF
            CALL PRTDJK(GJA,GKA,GDA,GJB,GKB,GDB,NA,NB)
            CALL PRTTV(TLMOA,VLMOA,TLMOB,VLMOB,NA,NB)
         END IF
         GDDFTA = ZERO
         GDDFTB = ZERO
         IF(SCFTYP.EQ.UHF .AND. NA.EQ.1) GDDFTA = GDTOLA
         IF(SCFTYP.EQ.UHF .AND. NA.LE.1) GDTOLA = ZERO
         IF(NB.EQ.1) GDDFTB = GDTOLB
         IF(NB.LE.1) GDTOLB = ZERO
C
C        - SAVE MONOMER LMO IN CMO1 -
         IF(MMULT(IM).GT.0) THEN
            CALL VCLR(TMP2,1,NUMX*NUMX)
            IF(NA.GT.0) CALL DAREAD(IDAF,IODA,TMP2,NUMX*NUMX,71,0)
            DO ILMO = 1, NA
               DO JJJ = 1, NUM
                  CMO1A(NUMALL+JJJ,NAALL+ILMO)=TMP2((ILMO-1)*NUM+JJJ)
               ENDDO
            ENDDO
            IF(SCFTYP.EQ.UHF .AND. NB.GT.0) THEN
               CALL VCLR(TMP2,1,NUMX*NUMX)
               CALL DAREAD(IDAF,IODA,TMP2,NUMX*NUMX,72,0)
               DO ILMO = 1, NB
                  DO JJJ = 1, NUM
                   CMO1B(NUMALL+JJJ,NBALL+ILMO)=TMP2((ILMO-1)*NUM+JJJ)
                  ENDDO
               ENDDO
            END IF
         ELSE IF(MMULT(IM).LT.0) THEN
            CALL VCLR(TMP2,1,NUM*NUM)
            IF(NA.GT.0) CALL DAREAD(IDAF,IODA,TMP2,NUMX*NUMX,71,0)
            DO ILMO = 1, NA
               DO JJJ = 1, NUM
                  CMO1B(NUMALL+JJJ,NBALL+ILMO)=TMP2((ILMO-1)*NUM+JJJ)
               ENDDO
            ENDDO
            IF(SCFTYP.EQ.UHF .AND. NB.GT.0) THEN
               CALL VCLR(TMP2,1,NUM*NUM)
               CALL DAREAD(IDAF,IODA,TMP2,NUMX*NUMX,72,0)
               DO ILMO = 1, NB
                  DO JJJ = 1, NUM
                   CMO1A(NUMALL+JJJ,NAALL+ILMO)=TMP2((ILMO-1)*NUM+JJJ)
                  ENDDO
               ENDDO
            END IF
         END IF
C
C        - SAVE T,V,K,D,J
         ENUCM     = ENUCM + EN
         EMNU(IM)  = EN
         IF(SCFTYP.EQ.RHF) THEN
            CMO1T(IM) = TKTOLA
            CMO1V(IM) = VTOLA
            CMO1K(IM) =-GKTOLA
            GKSV      =-GKTOLA - GDTOLA
            CMO1D(IM) = GDTOLA
            CMO1J(IM) = GJTOLA + GDTOLA*PT5
         ELSE IF(SCFTYP.EQ.UHF) THEN
            CMO1T(IM) = (TKTOLB + TKTOLA)*PT5
            CMO1V(IM) = (VTOLB  +  VTOLA)*PT5
            CMO1K(IM) =-(GKTOLB + GKTOLA)*PT5
            GKSV      =-(GKTOLB + GKTOLA)*PT5-(GDTOLB + GDTOLA)*PT5
            CMO1D(IM) = (GDTOLB + GDTOLA)*PT5
            CMO1J(IM) = (GJTOLB + GJTOLA)*PT5+(GDTOLB + GDTOLA)*PT25
         END IF
C
C        - HOWEVER, J IS WRONG FOR UHF. RUN LOCENG AGAIN TO GET J
C        - WE CHEAT LOCENG BY SUPPLYING ALL ALPHA LMOS
         IF(SCFTYP.EQ.UHF .AND. NE.GT.0) THEN
            IF((NA+NB).GT.NQMT) THEN
               IF(MASWRK) WRITE(IW,*)
     *                         ' ERROR: PLEASE USE A LARGER BASIS SET'
               CALL ABRT
            END IF
            IF(MMULT(IM).GT.0) THEN
               CALL VCLR(TMP2,1,NUM*NUM)
               DO ILMO = 1, NA
                  DO JJJ = 1, NUM
                   TMP2((ILMO-1)*NUM+JJJ)=CMO1A(NUMALL+JJJ,NAALL+ILMO)
                  ENDDO
               ENDDO
               DO ILMO = 1, NB
                  DO JJJ = 1, NUM
                   TMP2((NA+ILMO-1)*NUM+JJJ)=
     *                                    CMO1B(NUMALL+JJJ,NBALL+ILMO)
                  ENDDO
               ENDDO
            ELSE IF(MMULT(IM).LT.0) THEN
               CALL VCLR(TMP2,1,NUM*NUM)
               DO ILMO = 1, NA
                  DO JJJ = 1, NUM
                   TMP2((ILMO-1)*NUM+JJJ)=CMO1B(NUMALL+JJJ,NBALL+ILMO)
                  ENDDO
               ENDDO
               DO ILMO = 1, NB
                  DO JJJ = 1, NUM
                   TMP2((NA+ILMO-1)*NUM+JJJ)=
     *                                    CMO1A(NUMALL+JJJ,NAALL+ILMO)
                  ENDDO
               ENDDO
            END IF
            CALL DAWRIT(IDAF,IODA,TMP2,NUMX*NUMX,15,0)
            SCFTYP   = RHF
            NA       = NA + NB
            TKTOLA   = ZERO
            VTOLA    = ZERO
            GKTOLA   = ZERO
            GDTOLA   = ZERO
            GJTOLA   = ZERO
            TKTOLB   = ZERO
            VTOLB    = ZERO
            GKTOLB   = ZERO
            GDTOLB   = ZERO
            GJTOLB   = ZERO
            NPRINTSV = NPRINT
            NPRINT   = -5
            ZDOSV    = ZDO
            ZDO      = .TRUE.
            ILOCAL   = 0
            IF(NE.GT.0) CALL LOCENG
            NPRINT   = NPRINTSV
            ZDO      = ZDOSV
            SCFTYP   = UHF
            NA       = NA - NB
            IF(NA.LE.1) GDTOLA = ZERO
            IF(NB.LE.1) GDTOLB = ZERO
            CMO1J(IM) = GJTOLA*PT25
            CALL DAREAD(IDAF,IODA,GJA,NMO*NMO,604,0)
            IF(MASWRK) THEN
               WRITE(IW,9160)
               DO I=1,NA
                  DO J=NA+1,NA+NB
                     WRITE(IW,'(I9,I9,5X,F17.10)')
     *                     I,J-NA,GJA(I,J)
                  ENDDO
                  WRITE(IW,*) ' '
               ENDDO
            END IF
         END IF
C
C        - SAVE DFT RESULTS -
         IF(DFTYPE.NE.RNONE) THEN
            EC1(IM)    = ECORL
            EX1(IM)    = EXCOR   - ECORL
            CMO1K(IM)  = EX1(IM) + CMO1D(IM) + DFHY*GKSV
            IF(SCFTYP.EQ.UHF .AND. NA.EQ.1) THEN
               CMO1K(IM) = EX1(IM) + GDDFTA*PT5*(1.0D+00 - DFHY)
               IF(NB.EQ.1) CMO1K(IM) = EX1(IM)+(GDDFTA+GDDFTB)*PT5
     *                                 *(1.0D+00-DFHY)
            END IF
            PSMC0      = PSMC0   + EC1(IM)
         END IF
C
         IF(MMULT(IM).GT.0) THEN
            NAALL  = NAALL + NA
            IF(SCFTYP.EQ.UHF) NBALL = NBALL + NB
         ELSE IF(MMULT(IM).LT.0) THEN
            NAALL  = NAALL + NB
            IF(SCFTYP.EQ.UHF) NBALL = NBALL + NA
         END IF
         NSTART = NSTART + MATOM(IM)
         NUMALL = NUMALL + NUM
         PSMK0  = PSMK0  + CMO1K(IM)
  100 CONTINUE
C
C     - RESTORE MOLECULAR INFORMATION -
      NAT    =  NATX
      ICH    =  ICHX
      MUL    =  MULX
      NUM    =  NUMX
      NQMT   =  NQMTX
      NE     =  NEX
      NA     =  NAX
      NB     =  NBX
      IECP   =  IECPX
      IMCORE =  IMCOREX
      DO III  =  1, NATX
         ZAN(III) = ZANX(III)
         DO JJJ = 1, 6
            KFRST(III,JJJ) = KFRSTX(III,JJJ)
            KLAST(III,JJJ) = KLASTX(III,JJJ)
         ENDDO
         LMAX(III) = LMAXSV(III)
         LPSKIP(III)= LPSKIPX(III)
         IZCORE(III)= IZCOREX(III)
         C(1,III) = CX(1,III)
         C(2,III) = CX(2,III)
         C(3,III) = CX(3,III)
         IAN(III) = IANX(III)
      ENDDO
      DO III = 1, 400
         CLP(III) = CLPX(III)
         ZLP(III) = ZLPX(III)
         NLP(III) = NLPX(III)
      ENDDO
      DO III  =  1, MXGTOT
         EX(III)  = EXX(III)
         CS(III)  = CSX(III)
         CP(III)  = CPX(III)
         CD(III)  = CDX(III)
         CF(III)  = CFX(III)
         CG(III)  = CGX(III)
         CH(III)  = CHX(III)
         CI(III)  = CIX(III)
      ENDDO
      DO III  =  1, MXSH
         KSTART(III)  = KSTARTX(III)
         KATOM(III)   = KATOMX(III)
         KTYPE(III)   = KTYPEX(III)
         KNG(III)     = KNGX(III)
         KLOC(III)    = KLOCX(III)
         MIN(III)     = MINX(III)
         MAX(III)     = MAXX(III)
      ENDDO
      NSHELL = NSHELLX
C
      DO LLL = 1, NAT
         ZAN(LLL) = ZAN(LLL) + IZCORE(LLL)
      ENDDO
      CALL SETLAB(1,CDUMMY)
      DO LLL = 1, NAT
         ZAN(LLL) = ZAN(LLL) - IZCORE(LLL)
      ENDDO
C
      CALL ICOPY(MXATM ,MPTYPX ,1, MPTYP ,1)
      CALL DCOPY(MXMPA ,AN0X   ,1, AN0   ,1)
      CALL DCOPY(MXMPA ,ALPN0X ,1, ALPN0 ,1)
      CALL DCOPY(MXMPA ,AN1X   ,1, AN1   ,1)
      CALL DCOPY(MXMPA ,ALPN1X ,1, ALPN1 ,1)
      CALL ICOPY(MXATM ,MPSKPX ,1, MPSKP ,1)
      CALL ICOPY(MXATM ,NOAN0X ,1, NOAN0 ,1)
      CALL ICOPY(MXATM ,NOAN1X ,1, NOAN1 ,1)
      CALL DCOPY(MXMPSH,BPARX  ,1, BPAR  ,1)
      CALL DCOPY(MXMPGT,EXPMPX ,1, EXPMP ,1)
      CALL DCOPY(MXMPGT,CSMPX  ,1, CSMP  ,1)
      CALL DCOPY(MXMPGT,CPMPX  ,1, CPMP  ,1)
      CALL DCOPY(MXMPGT,CDMPX  ,1, CDMP  ,1)
      CALL DCOPY(MXMPGT,CFMPX  ,1, CFMP  ,1)
      CALL ICOPY(MXATM ,MPSKIPX,1, MPSKIP,1)
      CALL ICOPY(MXATM ,NOCOSHX,1, NOCOSH,1)
      CALL ICOPY(MXMPSH,MPKSTAX,1, MPKSTA,1)
      CALL ICOPY(MXMPSH,MPKNGX ,1, MPKNG ,1)
      CALL ICOPY(MXMPSH,MPKTYPX,1, MPKTYP,1)
      CALL ICOPY(MXMPSH,MPKMINX,1, MPKMIN,1)
      CALL ICOPY(MXMPSH,MPKMAXX,1, MPKMAX,1)
      CALL ICOPY(MXMPSH,MPKLOCX,1, MPKLOC,1)
C
C
C
      IF(.NOT.SUPBAS) GOTO 210
C     *******************************
C
C
C     ---------------------------------
C     - MONOMER ENERGY WITH ALL BASIS -
C     ---------------------------------
C
      CALL SYMORB
C
      EAALL    = ZERO
      EAMP2ALL = ZERO
      EACCALL  = ZERO
      NAALL    = 0
      NBALL    = 0
      NSTART   = 1
      IMP      = 0
      JMP      = 0
      ICORSH   = 0
      IGTF     = 0
      MPNUMALL = 0
      PSAK0     = ZERO
      PSAC0     = ZERO
      DO 200 IM = 1, NMOL
         IF (MASWRK) WRITE(IW,5010) IM
         CALL VCLR(ZAN,1,NATX)
         CALL VCLR(CLP,1,400)
         CALL VCLR(ZLP,1,400)
         CALL VICLR(NLP,1,400)
         CALL VICLR(KFRST,1,MXATM*6)
         CALL VICLR(KLAST,1,MXATM*6)
         CALL VICLR(LMAX,1,MXATM)
         CALL VICLR(LPSKIP,1,MXATM)
         CALL VICLR(IZCORE,1,MXATM)
         CALL VICLR(MPTYP  ,1, MXATM)
         CALL VCLR (AN0    ,1, MXMPA)
         CALL VCLR (ALPN0  ,1, MXMPA)
         CALL VCLR (AN1    ,1, MXMPA) 
         CALL VCLR (ALPN1  ,1, MXMPA)
         CALL VICLR(MPSKP  ,1, MXATM)
         CALL VICLR(NOAN0  ,1, MXATM)
         CALL VICLR(NOAN1  ,1, MXATM)
         CALL VCLR (BPAR   ,1, MXMPSH)
         CALL VCLR (EXPMP  ,1, MXMPGT)
         CALL VCLR (CSMP   ,1, MXMPGT)
         CALL VCLR (CPMP   ,1, MXMPGT)
         CALL VCLR (CDMP   ,1, MXMPGT)
         CALL VCLR (CFMP   ,1, MXMPGT)
         CALL VICLR(MPSKIP ,1, MXATM)
         CALL VICLR(NOCOSH ,1, MXATM)
         CALL VICLR(MPKSTA ,1, MXMPSH)
         CALL VICLR(MPKNG  ,1, MXMPSH)
         CALL VICLR(MPKTYP ,1, MXMPSH)
         CALL VICLR(MPKMIN ,1, MXMPSH)
         CALL VICLR(MPKMAX ,1, MXMPSH)
         CALL VICLR(MPKLOC ,1, MXMPSH)
         MUL     =  MMULT(IM)
         IF(MMULT(IM).LT.0) MUL = - MMULT(IM)
         NE      =  MELEC(IM)
         NA      =  (NE-1+MUL)/2
         NB      =  (NE+1-MUL)/2
         IECP    =  0
         IMPIM   =  0
         JMPIM   =  0
         ICORSHIM=  0
         IGTFIM  =  0
         IMCORE  =  0
         DO III  =  NSTART, NSTART + MATOM(IM) -1
            ZAN(III) = ZANX(III)
            DO JJJ = 1, 6 
               KFRST(III,JJJ) = KFRSTX(III,JJJ)
               KLAST(III,JJJ) = KLASTX(III,JJJ) 
            ENDDO
            LMAX(III) = LMAXSV(III)
            LPSKIP(III)= LPSKIPX(III)
            DO LLL = 1, LMAX(III) + 1
               KF = KFRST(III,LLL)
               KL = KLAST(III,LLL)
               KFIII = KFRSTX(III,LLL)
               DO KKK = KF, KL
                  CLP(KKK) = CLPX(KFIII + (KKK-KF))
                  ZLP(KKK) = ZLPX(KFIII + (KKK-KF))
                  NLP(KKK) = NLPX(KFIII + (KKK-KF))
               ENDDO
            ENDDO
            IZCORE(III)= IZCOREX(III)
            IF(IZCOREX(III).GT.0) IECP = IECPX
            MPTYP(III)  = MPTYPX(III)
            MPSKP(III)  = MPSKPX(III)
            NOAN0(III)  = NOAN0X(III)
            NOAN1(III)  = NOAN1X(III)
            MPSKIP(III) = MPSKIPX(III)
            NOCOSH(III) = NOCOSHX(III)
            DO LLL = 1, NOAN0X(III)
               AN0(IMPIM+LLL)    = AN0X(IMP+LLL)
               ALPN0(IMPIM+LLL)  = ALPN0X(IMP+LLL)
            ENDDO
            DO LLL = 1, NOAN1X(III)
               AN1(JMPIM+LLL)    = AN1X(JMP+LLL)
               ALPN1(JMPIM+LLL)  = ALPN1X(JMP+LLL)
            ENDDO
            DO LLL = 1, NOCOSHX(III)
               BPAR  (ICORSHIM+LLL) = BPARX  (ICORSH+LLL)
               MPKNG (ICORSHIM+LLL) = MPKNGX (ICORSH+LLL)
               MPKTYP(ICORSHIM+LLL) = MPKTYPX(ICORSH+LLL)
               IF(MPKTYP(ICORSHIM+LLL).EQ.1) IMCORE = IMCORE + 1
               IF(MPKTYP(ICORSHIM+LLL).EQ.2) IMCORE = IMCORE + 3
               IF(MPKTYP(ICORSHIM+LLL).EQ.3) IMCORE = IMCORE + 6
               IF(MPKTYP(ICORSHIM+LLL).EQ.4) IMCORE = IMCORE + 10
               MPKMIN(ICORSHIM+LLL) = MPKMINX(ICORSH+LLL)
               MPKMAX(ICORSHIM+LLL) = MPKMAXX(ICORSH+LLL)
               MPKLOC(ICORSHIM+LLL) = MPKLOCX(ICORSH+LLL)-MPNUMALL
               MPKSTA(ICORSHIM+LLL) = MPKSTAX(ICORSH+LLL)-IGTF+IGTFIM
               DO KKK = 1, MPKNGX(ICORSH+LLL)
                  IGTFIM        = IGTFIM + 1
                  IGTF          = IGTF   + 1
                  EXPMP(IGTFIM) = EXPMPX(IGTF)
                  CSMP(IGTFIM)  = CSMPX(IGTF)
                  CPMP(IGTFIM)  = CPMPX(IGTF)
                  CDMP(IGTFIM)  = CDMPX(IGTF)
                  CFMP(IGTFIM)  = CFMPX(IGTF)
               ENDDO
            ENDDO
            IMPIM       = IMPIM   + NOAN0X (III)
            JMPIM       = JMPIM   + NOAN1X (III)
            ICORSHIM    = ICORSHIM+ NOCOSHX(III)
            IMP         = IMP     + NOAN0X (III)
            JMP         = JMP     + NOAN1X (III)
            ICORSH      = ICORSH  + NOCOSHX(III)
            IF(III.EQ.NSTART + MATOM(IM) -1) 
     *                     MPNUM = MPKLOC(ICORSHIM) + MPKMAX(ICORSHIM)
     *                                              - MPKMIN(ICORSHIM)
         ENDDO
         MPNUMALL = MPNUMALL + MPNUM
C
         ECORL    = ZERO
         EXCOR    = ZERO
         ETOT     = ZERO
         TKTOLA   = ZERO
         VTOLA    = ZERO
         GKTOLA   = ZERO
         GDTOLA   = ZERO
         GJTOLA   = ZERO
         TKTOLB   = ZERO
         VTOLB    = ZERO
         GKTOLB   = ZERO
         GDTOLB   = ZERO
         GJTOLB   = ZERO
         GKSV     = ZERO
         EMP2     = ZERO
         ESCF     = ZERO
         EMP2CC   = ZERO
         ENRG     = ZERO
         ECORR(2) = ZERO
         IF(NE.GT.0) THEN
            CCTYPSV = CCTYP
            IF(NE.EQ.1) CCTYP = RNONE
            IF(SCFTYPSV.EQ.ROHF) SCFTYP=ROHF
            IF(MPLEVL.EQ.2) CALL MP2INP(MPTEST)
            IF(CCTYP.EQ.CCSDT .OR. CCTYP.EQ.CCSD) CALL CCINP
            IREST = 0
            NEVALS= 0
            CALL ENERGX
            CCTYP = CCTYPSV
            EHF2(IM) = ESCF
            EAALL  = EAALL + ESCF
            IF(MPLEVL.EQ.2) THEN
               EAMP2(IM)=EMP2
               EAMP2ALL =EAMP2ALL + EMP2
            END IF
            IF(CCTYP.EQ.CCSDT .OR. CCTYP.EQ.CCSD) THEN
               CALL CCFCLO(.FALSE.)
               IF(SCFTYP.EQ.ROHF) THEN
                  DO IFILE=70, 95
                     CALL CCCLOS(IFILE,'DELETE')
                  END DO
               END IF
               EAMP2(IM) = EHF2(IM)  + EMP2CC
               EAMP2ALL  = EAMP2ALL  + EAMP2(IM)
               EACC(IM)  = EHF2(IM)  + ECORR(2)
               IF(CCTYP.EQ.CCSD) EACC(IM)  = EHF2(IM)  + ENRG
               EACCALL   = EACCALL   + EACC(IM)
            END IF
            ILOCAL = 2
            CALL LOCENG
            IF(SCFTYPSV.EQ.ROHF) THEN
C              - USE LOCENG AGAIN IN UHF MODE TO GET CORRECT ENERGIES -
               SCFTYP=UHF
               CALL DAREAD(IDAF,IODA,TMP2,NUM*NUM,71,0)
               CALL DAWRIT(IDAF,IODA,TMP2,NUM*NUM,15,0)
               CALL DAWRIT(IDAF,IODA,TMP2,NUM*NUM,19,0)
               TKTOLA   = ZERO
               VTOLA    = ZERO
               GKTOLA   = ZERO
               GDTOLA   = ZERO
               GJTOLA   = ZERO
               TKTOLB   = ZERO
               VTOLB    = ZERO
               GKTOLB   = ZERO
               GDTOLB   = ZERO
               GJTOLB   = ZERO
               NPRINTSV = NPRINT
               NPRINT   = -5
               ZDOSV    = ZDO
               ZDO      = .TRUE.
               ILOCAL   = 0
               IF(NE.GT.0) CALL LOCENG
               NPRINT   = NPRINTSV
               ZDO      = ZDOSV
               CALL DAREAD(IDAF,IODA,TMP2,NUM*NUM,71,0)
               CALL DAWRIT(IDAF,IODA,TMP2,NUM*NUM,72,0)
            END IF
            CALL PRTDJK(GJA,GKA,GDA,GJB,GKB,GDB,NA,NB)
            CALL PRTTV(TLMOA,VLMOA,TLMOB,VLMOB,NA,NB)
         END IF
         GDDFTA = ZERO
         GDDFTB = ZERO
         IF(SCFTYP.EQ.UHF .AND. NA.EQ.1) GDDFTA = GDTOLA
         IF(SCFTYP.EQ.UHF .AND. NA.LE.1) GDTOLA = ZERO
         IF(NB.EQ.1) GDDFTB = GDTOLB
         IF(NB.LE.1) GDTOLB = ZERO
C
C        - SAVE MONOMER LMO IN CMO2 -
         IF(MMULT(IM).GT.0) THEN
            IF(NA.GT.0) CALL DAREAD(IDAF,IODA,TMP1A,NUM*NUM,71,0)
            DO ILMO = 1, NA
               DO JJJ = 1, NUM
                  CMO2A(JJJ,NAALL+ILMO)=TMP1A(JJJ,ILMO)
               ENDDO
            ENDDO
            IF(SCFTYP.EQ.UHF .AND. NB.GT.0) THEN
               CALL DAREAD(IDAF,IODA,TMP1A,NUM*NUM,72,0)
               DO ILMO = 1, NB
                  DO JJJ = 1, NUM
                     CMO2B(JJJ,NBALL+ILMO)=TMP1A(JJJ,ILMO)
                  ENDDO
               ENDDO
            END IF
         ELSE IF(MMULT(IM).LT.0) THEN
C           - SAVE ALPHA LMO IN CMO2A AS BETA LMO -
            IF(NA.GT.0) CALL DAREAD(IDAF,IODA,TMP1A,NUM*NUM,71,0)
            DO ILMO = 1, NA
               DO JJJ = 1, NUM
                  CMO2B(JJJ,NBALL+ILMO)=TMP1A(JJJ,ILMO)
               ENDDO
            ENDDO
            IF(SCFTYP.EQ.UHF .AND. NB.GT.0) THEN
               CALL DAREAD(IDAF,IODA,TMP1A,NUM*NUM,72,0)
               DO ILMO = 1, NB
                  DO JJJ = 1, NUM
                     CMO2A(JJJ,NAALL+ILMO)=TMP1A(JJJ,ILMO)
                  ENDDO
               ENDDO
            END IF
         END IF
C
C        - SAVE T,V,D,J,K -
         IF(SCFTYP.EQ.RHF) THEN
            CMO2T(IM) = TKTOLA
            CMO2V(IM) = VTOLA
            CMO2K(IM) =-GKTOLA
            GKSV      =-GKTOLA - GDTOLA
            CMO2D(IM) = GDTOLA
            CMO2J(IM) = GJTOLA + GDTOLA*PT5
         ELSE IF(SCFTYP.EQ.UHF) THEN
            CMO2T(IM) = (TKTOLB + TKTOLA)*PT5
            CMO2V(IM) = (VTOLB  +  VTOLA)*PT5
            CMO2K(IM) =-(GKTOLB + GKTOLA)*PT5
            GKSV      =-(GKTOLB + GKTOLA)*PT5-(GDTOLB + GDTOLA)*PT5
            CMO2D(IM) = (GDTOLB + GDTOLA)*PT5
            CMO2J(IM) = (GJTOLB + GJTOLA)*PT5+(GDTOLB + GDTOLA)*PT25
         END IF
C        - HOWEVER, J IS WRONG FOR UHF. RUN LOCENG AGAIN TO GET J
C        - WE CHEAT LOCENG BY SUPPLYING ALL ALPHA LMOS
         IF(SCFTYP.EQ.UHF .AND. NE.GT.0) THEN
            CALL VCLR(TMP1A,1,NUM*NUM)
            IF(MMULT(IM).GT.0) THEN
               DO ILMO = 1, NA
                  DO JJJ = 1, NUM
                     TMP1A(JJJ,ILMO)=CMO2A(JJJ,NAALL+ILMO)
                  ENDDO
               ENDDO
               DO ILMO = 1, NB
                  DO JJJ = 1, NUM
                     TMP1A(JJJ,NA+ILMO)=CMO2B(JJJ,NBALL+ILMO)
                  ENDDO
               ENDDO
            ELSE IF(MMULT(IM).LT.0) THEN
               DO ILMO = 1, NA
                  DO JJJ = 1, NUM
                     TMP1A(JJJ,ILMO)=CMO2B(JJJ,NBALL+ILMO)
                  ENDDO
               ENDDO
               DO ILMO = 1, NB
                  DO JJJ = 1, NUM
                     TMP1A(JJJ,NA+ILMO)=CMO2A(JJJ,NAALL+ILMO)
                  ENDDO
               ENDDO
            END IF
            CALL DAWRIT(IDAF,IODA,TMP1A,NUM*NUM,15,0)
            SCFTYP   = RHF
            NA       = NA + NB
            TKTOLA   = ZERO
            VTOLA    = ZERO
            GKTOLA   = ZERO
            GDTOLA   = ZERO
            GJTOLA   = ZERO
            TKTOLB   = ZERO
            VTOLB    = ZERO
            GKTOLB   = ZERO
            GDTOLB   = ZERO
            GJTOLB   = ZERO
            NPRINTSV = NPRINT
            NPRINT   = -5
            ZDOSV    = ZDO
            ZDO      = .TRUE.
            ILOCAL   = 0
            IF(NE.GT.0) CALL LOCENG
            NPRINT   = NPRINTSV
            ZDO      = ZDOSV
            SCFTYP   = UHF
            NA       = NA - NB
            IF(NA.LE.1) GDTOLA = ZERO
            IF(NB.LE.1) GDTOLB = ZERO
            CMO2J(IM) = GJTOLA*PT25
            CALL DAREAD(IDAF,IODA,GJA,NMO*NMO,604,0)
            IF(MASWRK) THEN
               WRITE(IW,9160)
               DO I=1,NA
                  DO J=NA+1,NA+NB
                     WRITE(IW,'(I9,I9,5X,F17.10)')
     *                     I,J-NA,GJA(I,J)
                  ENDDO
                  WRITE(IW,*) ' '
               ENDDO
            END IF
         END IF
C
C        - SAVE DFT RESULTS -
         IF(DFTYPE.NE.RNONE) THEN
            EC2(IM)    = ECORL
            EX2(IM)    = EXCOR   - ECORL
            CMO2K(IM)  = EX2(IM) + CMO2D(IM) + DFHY*GKSV
            IF(SCFTYP.EQ.UHF .AND. NA.EQ.1) THEN
               CMO2K(IM) = EX2(IM) + GDDFTA*PT5*(1.0D+00 - DFHY)
               IF(NB.EQ.1) CMO2K(IM) = EX2(IM)+(GDDFTA+GDDFTB)*PT5
     *                                 *(1.0D+00-DFHY)
            END IF
            PSAC0      = PSAC0   + EC2(IM)
         END IF
C
         IF(MMULT(IM).GT.0) THEN
            NAALL  = NAALL + NA
            IF(SCFTYP.EQ.UHF) NBALL = NBALL + NB
         ELSE IF(MMULT(IM).LT.0) THEN
            NAALL  = NAALL + NB
            IF(SCFTYP.EQ.UHF) NBALL = NBALL + NA
         END IF
         NSTART = NSTART + MATOM(IM)
         PSAK0  = PSAK0  + CMO2K(IM)
  200 CONTINUE
C
C     - RESTORE MOLECULAR INFORMATION -
      NAT    =  NATX
      ICH    =  ICHX
      MUL    =  MULX
      NUM    =  NUMX
      NQMT   =  NQMTX
      NE     =  NEX
      NA     =  NAX
      NB     =  NBX
      IECP   =  IECPX
      IMCORE =  IMCOREX
      DO III  =  1, NATX
         ZAN(III) = ZANX(III)
         DO JJJ = 1, 6
            KFRST(III,JJJ) = KFRSTX(III,JJJ)
            KLAST(III,JJJ) = KLASTX(III,JJJ)
         ENDDO
         LMAX(III) = LMAXSV(III)
         LPSKIP(III)= LPSKIPX(III)
         IZCORE(III)= IZCOREX(III)
         C(1,III) = CX(1,III)
         C(2,III) = CX(2,III)
         C(3,III) = CX(3,III)
         IAN(III) = IANX(III)
      ENDDO
      DO III = 1, 400
         CLP(III) = CLPX(III)
         ZLP(III) = ZLPX(III)
         NLP(III) = NLPX(III)
      ENDDO
      CALL ICOPY(MXATM ,MPTYPX ,1, MPTYP ,1)
      CALL DCOPY(MXMPA ,AN0X   ,1, AN0   ,1)
      CALL DCOPY(MXMPA ,ALPN0X ,1, ALPN0 ,1)
      CALL DCOPY(MXMPA ,AN1X   ,1, AN1   ,1)
      CALL DCOPY(MXMPA ,ALPN1X ,1, ALPN1 ,1)
      CALL ICOPY(MXATM ,MPSKPX ,1, MPSKP ,1)
      CALL ICOPY(MXATM ,NOAN0X ,1, NOAN0 ,1)
      CALL ICOPY(MXATM ,NOAN1X ,1, NOAN1 ,1)
      CALL DCOPY(MXMPSH,BPARX  ,1, BPAR  ,1)
      CALL DCOPY(MXMPGT,EXPMPX ,1, EXPMP ,1)
      CALL DCOPY(MXMPGT,CSMPX  ,1, CSMP  ,1)
      CALL DCOPY(MXMPGT,CPMPX  ,1, CPMP  ,1)
      CALL DCOPY(MXMPGT,CDMPX  ,1, CDMP  ,1)
      CALL DCOPY(MXMPGT,CFMPX  ,1, CFMP  ,1)
      CALL ICOPY(MXATM ,MPSKIPX,1, MPSKIP,1)
      CALL ICOPY(MXATM ,NOCOSHX,1, NOCOSH,1)
      CALL ICOPY(MXMPSH,MPKSTAX,1, MPKSTA,1)
      CALL ICOPY(MXMPSH,MPKNGX ,1, MPKNG ,1)
      CALL ICOPY(MXMPSH,MPKTYPX,1, MPKTYP,1)
      CALL ICOPY(MXMPSH,MPKMINX,1, MPKMIN,1)
      CALL ICOPY(MXMPSH,MPKMAXX,1, MPKMAX,1)
      CALL ICOPY(MXMPSH,MPKLOCX,1, MPKLOC,1)
C
C
 210  CONTINUE
C     ********
C
C
C
C
C
C     -------------------------
C     - SUPER MOLECULE ENERGY -
C     -------------------------
C
      IF (MASWRK) WRITE(IW,5020)
      CALL SYMORB
      ECORL    = ZERO
      EXCOR    = ZERO
      TKTOLA   = ZERO
      VTOLA    = ZERO
      GKTOLA   = ZERO
      GDTOLA   = ZERO
      GJTOLA   = ZERO
      TKTOLB   = ZERO
      VTOLB    = ZERO
      GKTOLB   = ZERO
      GDTOLB   = ZERO
      GJTOLB   = ZERO
      GKSV     = ZERO
      EMP2     = ZERO
      ESCF     = ZERO
      EMP2CC   = ZERO
      ENRG     = ZERO
      ECORR(2) = ZERO
      IF(SCFTYPSV.EQ.ROHF) SCFTYP=ROHF
      IF(MPLEVL.EQ.2) CALL MP2INP(MPTEST)
      IF(CCTYP.EQ.CCSDT .OR. CCTYP.EQ.CCSD) CALL CCINP
      IREST = 0
      NEVALS= 0
      CALL ENERGX
      ENUCS  = EN
      ESUPER = ESCF
      IF(MPLEVL.EQ.2) ESUMP2=EMP2
      IF(CCTYP.EQ.CCSDT .OR. CCTYP.EQ.CCSD) THEN
         CALL CCFCLO(.FALSE.)
         IF(SCFTYP.EQ.ROHF) THEN
            DO IFILE=70, 95
               CALL CCCLOS(IFILE,'DELETE')
            END DO
         END IF
         ESUMP2 = ESUPER + EMP2CC
         ESUCC  = ESUPER + ECORR(2)
         IF(CCTYP.EQ.CCSD) ESUCC  = ESUPER  + ENRG
      END IF
      ILOCAL = 2
      CALL LOCENG
      IF(SCFTYPSV.EQ.ROHF) THEN
C        - USE LOCENG AGAIN IN UHF MODE TO GET CORRECT ENERGIES -
         SCFTYP=UHF
         CALL DAREAD(IDAF,IODA,TMP2,NUM*NUM,71,0)
         CALL DAWRIT(IDAF,IODA,TMP2,NUM*NUM,15,0)
         CALL DAWRIT(IDAF,IODA,TMP2,NUM*NUM,19,0)
         TKTOLA   = ZERO
         VTOLA    = ZERO
         GKTOLA   = ZERO
         GDTOLA   = ZERO
         GJTOLA   = ZERO
         TKTOLB   = ZERO
         VTOLB    = ZERO
         GKTOLB   = ZERO
         GDTOLB   = ZERO
         GJTOLB   = ZERO
         NPRINTSV = NPRINT
         NPRINT   = -5
         ZDOSV    = ZDO
         ZDO      = .TRUE.
         ILOCAL   = 0
         IF(NE.GT.0) CALL LOCENG
         NPRINT   = NPRINTSV
         ZDO      = ZDOSV
         CALL DAREAD(IDAF,IODA,TMP2,NUM*NUM,71,0)
         CALL DAWRIT(IDAF,IODA,TMP2,NUM*NUM,72,0)
      END IF
      CALL PRTDJK(GJA,GKA,GDA,GJB,GKB,GDB,NA,NB)
      CALL PRTTV(TLMOA,VLMOA,TLMOB,VLMOB,NA,NB)
      GDDFTA = ZERO
      GDDFTB = ZERO
      IF(SCFTYP.EQ.UHF .AND. NA.EQ.1) GDDFTA = GDTOLA
      IF(SCFTYP.EQ.UHF .AND. NA.LE.1) GDTOLA = ZERO
      IF(NB.EQ.1) GDDFTB = GDTOLB
      IF(NB.LE.1) GDTOLB = ZERO
C
C     - SAVE LMO IN TMP1 -
      IF(NA.GT.0) CALL DAREAD(IDAF,IODA,TMP1A,NUM*NUM,71,0)
      IF(SCFTYP.EQ.UHF .AND. NB.GT.0)THEN
         CALL DAREAD(IDAF,IODA,TMP1B,NUM*NUM,72,0)
      END IF
C
C     - SAVE T,V,K,D,J -
      IF(SCFTYP.EQ.RHF) THEN
         SUPERT = TKTOLA
         SUPERV =  VTOLA
         SUPERK =-GKTOLA
         GKSV   =-GKTOLA - GDTOLA
         SUPERD = GDTOLA
         SUPERJ = GJTOLA + GDTOLA*PT5
      ELSE IF(SCFTYP.EQ.UHF)THEN
         SUPERT = (TKTOLB + TKTOLA)*PT5
         SUPERV = (VTOLB  +  VTOLA)*PT5
         SUPERK =-(GKTOLB + GKTOLA)*PT5
         GKSV   =-(GKTOLB + GKTOLA)*PT5-(GDTOLB + GDTOLA)*PT5
         SUPERD = (GDTOLB + GDTOLA)*PT5
         SUPERJ = (GJTOLB + GJTOLA)*PT5+(GDTOLB + GDTOLA)*PT25
      END IF
C
C     - HOWEVER, J IS WRONG FOR UHF. RUN LOCENG AGAIN TO GET J
C     - WE CHEAT LOCENG BY SUPPLYING ALL ALPHA LMOS
      IF(SCFTYP.EQ.UHF .AND. NE.GT.0) THEN
         CALL VCLR(TMP3A,1,NUMX*NUMX)
         DO ILMO = 1, NA
            DO JJJ = 1, NUM
               TMP3A(JJJ,ILMO)=TMP1A(JJJ,ILMO)
            ENDDO
         ENDDO
         DO ILMO = 1, NB
            DO JJJ = 1, NUM
               TMP3A(JJJ,NA+ILMO)=TMP1B(JJJ,ILMO)
            ENDDO
         ENDDO
         CALL DAWRIT(IDAF,IODA,TMP3A,NUMX*NUMX,15,0)
         SCFTYP   = RHF
         NA       = NA + NB
         TKTOLA   = ZERO
         VTOLA    = ZERO
         GKTOLA   = ZERO
         GDTOLA   = ZERO
         GJTOLA   = ZERO
         TKTOLB   = ZERO
         VTOLB    = ZERO
         GKTOLB   = ZERO
         GDTOLB   = ZERO
         GJTOLB   = ZERO
         NPRINTSV = NPRINT
         NPRINT   = -5
         ZDOSV    = ZDO
         ZDO      = .TRUE.
         ILOCAL   = 0
         IF(NE.GT.0) CALL LOCENG
         NPRINT   = NPRINTSV
         ZDO      = ZDOSV
         SCFTYP   = UHF
         NA       = NA - NB
         IF(NA.LE.1) GDTOLA = ZERO
         IF(NB.LE.1) GDTOLB = ZERO
         SUPERJ = GJTOLA*PT25
         CALL DAREAD(IDAF,IODA,GJA,NMO*NMO,604,0)
         IF(MASWRK) THEN
            WRITE(IW,9160)
            DO I=1,NA
               DO J=NA+1,NA+NB
                  WRITE(IW,'(I9,I9,5X,F17.10)')
     *                  I,J-NA,GJA(I,J)
               ENDDO
               WRITE(IW,*) ' '
            ENDDO
         END IF
      END IF
C
C     - SAVE DFT RESULTS -
      IF(DFTYPE.NE.RNONE) THEN
         ESUC     = ECORL
         ESUX     = EXCOR - ECORL
         SUPERK   = ESUX+SUPERD+DFHY*GKSV
         IF(SCFTYP.EQ.UHF .AND. NA.EQ.1) THEN
            SUPERK = ESUX + GDDFTA*PT5*(1.0D+00-DFHY)
            IF(NB.EQ.1) SUPERK = ESUX+(GDDFTA+GDDFTB)*PT5
     *                           *(1.0D+00-DFHY)
         END IF
      END IF
C
C     - COMPARE SUPER MOLECULE LMO TO MONOMER LMO -
C
      NMO2 = NMO*NMO
      CALL DAREAD(IDAF,IODA,TLMOA,NMO2,600,0)
      CALL DAREAD(IDAF,IODA,VLMOA,NMO2,601,0)
      CALL DAREAD(IDAF,IODA,GJA  ,NMO2,604,0)
      CALL DAREAD(IDAF,IODA,GKA  ,NMO2,605,0)
      CALL DAREAD(IDAF,IODA,GDA  ,NMO ,606,0)
C
      CALL VCLR(ERR,1,NMO*NMO)
      DO IMO = 1, NMO
         KMINA(IMO) = 0
      ENDDO
      DO KC=1,NA
         DO IC=1,NA
            ERR(IC,KC) = 1.0D+03
            ERRT1=ZERO
            ERRT2=ZERO
            DO IBAS=1,NUM
               ERRT1=ERRT1+ABS(TMP1A(IBAS,KC)+CMO1A(IBAS,IC))
               ERRT2=ERRT2+ABS(TMP1A(IBAS,KC)-CMO1A(IBAS,IC))
            ENDDO
            ERR(IC,KC)=ERRT1
            IF(ERRT2.LT.ERRT1) ERR(IC,KC)=ERRT2
         ENDDO
      ENDDO
      DO KC=1,NA
         EMIN = ERR(1,KC)
         DO IC=1,NA
            IF(ERR(IC,KC).GT.EMIN) EMIN=ERR(IC,KC)
         ENDDO
         DO IC=1,NA
            IF(ERR(IC,KC).LT.EMIN .AND. KCOREA(IC).EQ.0) THEN
               EMIN=ERR(IC,KC)
               KMINA(KC)=IC
            END IF
         ENDDO
         KCOREA(KMINA(KC)) = 1
      ENDDO
      IF(NA.EQ.1) KMINA(1) = 1
      DO III = 1, NA
         TLMO1(KMINA(III),KMINA(III))   = TLMOA(III,III)
         VLMO1(KMINA(III),KMINA(III))   = VLMOA(III,III)
         GD11(KMINA(III))               = GDA(III)
         DO JJJ = 1, NA
            GK11(KMINA(JJJ),KMINA(III)) = GKA(JJJ,III)
            GJ11(KMINA(JJJ),KMINA(III)) = GJA(JJJ,III)
         ENDDO
      ENDDO
C     - STORE REORDERED LMO IN TMP3A -
      DO KC=1,NA
         DO IBAS=1,NUM
            TMP3A(IBAS,KMINA(KC))=TMP1A(IBAS,KC)
         ENDDO
      ENDDO
C
C
      IF(SCFTYP.EQ.UHF .AND. NB.GT.0) THEN
         CALL DAREAD(IDAF,IODA,TLMOB,NMO2,602,0)
         CALL DAREAD(IDAF,IODA,VLMOB,NMO2,603,0)
         CALL DAREAD(IDAF,IODA,GJB  ,NMO2,607,0)
         CALL DAREAD(IDAF,IODA,GKB  ,NMO2,608,0)
         CALL DAREAD(IDAF,IODA,GDB  ,NMO ,609,0)
         CALL VCLR(ERR,1,NMO*NMO)
         DO IMO = 1, NMO
            KMINB(IMO) = 0
         ENDDO
         DO KC=1,NB
            DO IC=1,NB
               ERR(IC,KC) = 1.0D+03
               ERRT1=ZERO
               ERRT2=ZERO
               DO IBAS=1,NUM
                  ERRT1=ERRT1+ABS(TMP1B(IBAS,KC)+CMO1B(IBAS,IC))
                  ERRT2=ERRT2+ABS(TMP1B(IBAS,KC)-CMO1B(IBAS,IC))
               ENDDO
               ERR(IC,KC)=ERRT1
               IF(ERRT2.LT.ERRT1) ERR(IC,KC)=ERRT2
            ENDDO
         ENDDO
         DO KC=1,NB
            EMIN = ERR(1,KC)
            DO IC=1,NB
               IF(ERR(IC,KC).GT.EMIN) EMIN=ERR(IC,KC)
            ENDDO
            DO IC=1,NB
               IF(ERR(IC,KC).LT.EMIN .AND. KCOREB(IC).EQ.0) THEN
                  EMIN=ERR(IC,KC)
                  KMINB(KC)=IC
               END IF
            ENDDO
            KCOREB(KMINB(KC)) = 1
         ENDDO
         IF(NB.EQ.1) KMINB(1) = 1
         DO I2=1, NB
            TLMO1B(KMINB(I2),KMINB(I2))   = TLMOB(I2,I2)
            VLMO1B(KMINB(I2),KMINB(I2))   = VLMOB(I2,I2)
            GD11B(KMINB(I2))              = GDB(I2)
            DO J2=1,NB
               GK11B(KMINB(J2),KMINB(I2)) = GKB(J2,I2)
               GJ11B(KMINB(J2),KMINB(I2)) = GJB(J2,I2)
            ENDDO
         ENDDO
C        - STORE REORDERED LMO IN TMP3B -
         DO III=1, NB
            DO IBAS=1,NUM
               TMP3B(IBAS,KMINB(III))=TMP1B(IBAS,III)
            ENDDO
         ENDDO
      END IF
C
C
      IF(MASWRK) THEN
         WRITE(IW,5100)
         DO I=1,NA
            IF(SCFTYP.EQ.RHF) THEN
               WRITE(IW,5200) I,TWO*TLMO1(I,I),TWO*VLMO1(I,I)
            ELSE
               WRITE(IW,5200) I,TLMO1(I,I),VLMO1(I,I)
            ENDIF
         ENDDO
         IF(NA.GT.1) THEN
            WRITE(IW,5300)
            DO I=1,NA
               WRITE(IW,5310) I,GD11(I)
            ENDDO
         END IF
            WRITE(IW,5315)
         DO I =1,NA
            DO J=1,NA
               IF(I.NE.J)THEN
                  IF(SCFTYP.EQ.RHF) THEN
                     WRITE(IW,5320) I,J,TWO*GJ11(I,J),-GK11(I,J)
                  ELSE
                     WRITE(IW,5320) I,J,GJ11(I,J),-GK11(I,J)
                  ENDIF
               ENDIF
            ENDDO
         ENDDO
      END IF
      IF(MASWRK.AND.SCFTYP.EQ.UHF .AND. NB.GT.0) THEN
         WRITE(IW,5105)
         DO I=1,NB
            WRITE(IW,5200) I,TLMO1B(I,I),VLMO1B(I,I)
         ENDDO
         IF(NB.GT.1) THEN
            WRITE(IW,5300)
            DO I=1,NB
               WRITE(IW,5310) I,GD11B(I)
            ENDDO
         END IF
         WRITE(IW,5315)
         DO I =1,NB
            DO J=1,NB
               IF(I.NE.J) WRITE(IW,5320) I,J,GJ11B(I,J),-GK11B(I,J)
            ENDDO
         ENDDO
      END IF
C
C
C
C
C
C     ----------------------------------------
C     - MONOMER ENERGY IN THE SUPER MOLECULE -
C     ----------------------------------------
C
      NAALL  = 0
      NBALL  = 0
      NSTART = 1
      PMST   = ZERO
      PMSK   = ZERO
      PMSC   = ZERO
      EPM    = ZERO
      DO 300 IM = 1, NMOL
         CALL VCLR(ZAN,1,NATX)
         MUL     =  MMULT(IM)
         IF(MMULT(IM).LT.0) MUL = - MMULT(IM)
         NE      =  MELEC(IM)
         NA      =  (NE-1+MUL)/2
         NB      =  (NE+1-MUL)/2
         DO III  =  NSTART, NSTART + MATOM(IM) -1
            ZAN(III) = ZANX(III)
         ENDDO
         NSTART = NSTART + MATOM(IM)
C
C        - EXTRACT MONOMER LMO AND SAVE IN CMO3 -
         IF(MMULT(IM).GT.0) THEN
            CALL VCLR(CMO3A,1,NUMX*NUMX)
            DO ILMO = 1, NA
               DO JJJ = 1, NUMX
                  CMO3A(JJJ,ILMO) = TMP3A(JJJ,NAALL+ILMO)
               ENDDO
            ENDDO
            IF(SCFTYP.EQ.UHF) THEN
               CALL VCLR(CMO3B,1,NUMX*NUMX)
               DO ILMO = 1, NB
                  DO JJJ = 1, NUMX
                     CMO3B(JJJ,ILMO) = TMP3B(JJJ,NBALL+ILMO)
                  ENDDO
               ENDDO
            END IF
         ELSE IF(MMULT(IM).LT.0) THEN
            CALL VCLR(CMO3A,1,NUMX*NUMX)
            DO ILMO = 1, NA
               DO JJJ = 1, NUMX
                  CMO3A(JJJ,ILMO) = TMP3B(JJJ,NBALL+ILMO)
               ENDDO
            ENDDO
            IF(SCFTYP.EQ.UHF) THEN
               CALL VCLR(CMO3B,1,NUMX*NUMX)
               DO ILMO = 1, NB
                  DO JJJ = 1, NUMX
                     CMO3B(JJJ,ILMO) = TMP3A(JJJ,NAALL+ILMO)
                  ENDDO
               ENDDO
            END IF
         END IF
C
         ZDOSV = ZDO
         ZDO   = .TRUE.
         IF (MASWRK) WRITE(IW,5011) IM
         CALL DAWRIT(IDAF,IODA,CMO3A,NUMX*NUMX,15,0)
         IF(SCFTYP.EQ.UHF .AND. NB.GT.0) THEN
            CALL DAWRIT(IDAF,IODA,CMO3B,NUMX*NUMX,19,0)
         END IF
         CALL ONEEI
         TKTOLA   = ZERO
         VTOLA    = ZERO
         GKTOLA   = ZERO
         GDTOLA   = ZERO
         GJTOLA   = ZERO
         TKTOLB   = ZERO
         VTOLB    = ZERO
         GKTOLB   = ZERO
         GDTOLB   = ZERO
         GJTOLB   = ZERO
         GKSV     = ZERO
         NPRINTSV = NPRINT
         NPRINT   = -5
         ILOCAL   = 0
         IF(NE.GT.0) CALL LOCENG
         NPRINT   = NPRINTSV
         GDDFTA   = ZERO
         GDDFTB   = ZERO
         CALL PRTDJK(GJA,GKA,GDA,GJB,GKB,GDB,NA,NB)
         CALL PRTTV(TLMOA,VLMOA,TLMOB,VLMOB,NA,NB)
         IF(SCFTYP.EQ.UHF .AND. NA.EQ.1) GDDFTA = GDTOLA
         IF(SCFTYP.EQ.UHF .AND. NA.LE.1) GDTOLA = ZERO
         IF(NB.EQ.1) GDDFTB = GDTOLB
         IF(NB.LE.1) GDTOLB = ZERO
C        - SAVE T,V,K,D,J -
         IF(SCFTYP.EQ.RHF) THEN
            CMO3T(IM) = TKTOLA
            CMO3V(IM) = VTOLA
            CMO3K(IM) =-GKTOLA
            GKSV      =-GKTOLA - GDTOLA
            CMO3D(IM) = GDTOLA
            CMO3J(IM) = GJTOLA + GDTOLA*PT5
         ELSE IF(SCFTYP.EQ.UHF) THEN
            CMO3T(IM) = (TKTOLB + TKTOLA)*PT5
            CMO3V(IM) = (VTOLB  +  VTOLA)*PT5
            CMO3K(IM) =-(GKTOLB + GKTOLA)*PT5
            GKSV      =-(GKTOLB + GKTOLA)*PT5-(GDTOLB + GDTOLA)*PT5
            CMO3D(IM) = (GDTOLB + GDTOLA)*PT5
            CMO3J(IM) = (GJTOLB + GJTOLA)*PT5+(GDTOLB + GDTOLA)*PT25
         END IF
C
C        - HOWEVER, J IS WRONG FOR UHF. RUN LOCENG AGAIN TO GET J
C        - WE CHEAT LOCENG BY SUPPLYING ALL ALPHA LMOS
         IF(SCFTYP.EQ.UHF .AND. NE.GT.0) THEN
C           - NO ACTION ON MMULT(IM) < 0
            CALL VCLR(TMP1A,1,NUM*NUM)
            DO ILMO = 1, NA
               DO JJJ = 1, NUM
                  TMP1A(JJJ,ILMO)=CMO3A(JJJ,ILMO)
               ENDDO
            ENDDO
            DO ILMO = 1, NB
               DO JJJ = 1, NUM
                  TMP1A(JJJ,NA+ILMO)=CMO3B(JJJ,ILMO)
               ENDDO
            ENDDO
            CALL DAWRIT(IDAF,IODA,TMP1A,NUM*NUM,15,0)
            SCFTYP   = RHF
            NA       = NA + NB
            TKTOLA   = ZERO
            VTOLA    = ZERO
            GKTOLA   = ZERO
            GDTOLA   = ZERO
            GJTOLA   = ZERO
            TKTOLB   = ZERO
            VTOLB    = ZERO
            GKTOLB   = ZERO
            GDTOLB   = ZERO
            GJTOLB   = ZERO
            NPRINTSV = NPRINT
            NPRINT   = -5
            ZDOSV1   = ZDO
            ZDO      = .TRUE.
            ILOCAL   = 0
            IF(NE.GT.0) CALL LOCENG
            NPRINT   = NPRINTSV
            ZDO      = ZDOSV1
            SCFTYP   = UHF
            NA       = NA - NB
            IF(NA.LE.1) GDTOLA = ZERO
            IF(NB.LE.1) GDTOLB = ZERO
            CMO3J(IM) = GJTOLA*PT25
            CALL DAREAD(IDAF,IODA,GJA,NMO*NMO,604,0)
            IF(MASWRK) THEN
               WRITE(IW,9160)
               DO I=1,NA
                  DO J=NA+1,NA+NB
                     WRITE(IW,'(I9,I9,5X,F17.10)')
     *                     I,J-NA,GJA(I,J)
                  ENDDO
                  WRITE(IW,*) ' '
               ENDDO
            END IF
         END IF
C
         EHF3(IM)=2*CMO3T(IM)+2*CMO3V(IM)+2*CMO3J(IM)+EMNU(IM)
     *             +CMO3K(IM)
         ZDO  = ZDOSV
C
C        - DFT CALCULATION -
C        - GET EXC FROM CURRENT MO DENSITY-
         IF(DFTYPE.NE.RNONE) THEN
            NPRINTSV = NPRINT
            NPRINT = -5
            NPRTGOSV = NPRTGO
            NPRTGO = 2
            IREST  = 2
            MAXITSV= MAXIT
            MAXIT  = 1
            ECORL  = ZERO
            EXCOR  = ZERO
            IF(SCFTYP.EQ.RHF .AND. NE.GT.0) THEN
               CALL RHFCL
            ELSE IF(SCFTYP.EQ.UHF .AND. NE.GT.0) THEN
               SZ = ZERO
               S2 = ZERO
               CALL UHFOP(SZ,S2)
            END IF
            MAXIT  = MAXITSV
            NPRINT = NPRINTSV
            NPRTGO = NPRTGOSV
            EC3(IM)  = ECORL
            EX3(IM)  = EXCOR - ECORL
            CMO3K(IM)  = EX3(IM)+CMO3D(IM)+DFHY*GKSV
            IF(SCFTYP.EQ.UHF .AND. NA.EQ.1) THEN
               CMO3K(IM) = EX3(IM) + GDDFTA*PT5*(1.0D+00-DFHY)
               IF(NB.EQ.1) CMO3K(IM)=EX3(IM)+(GDDFTA+GDDFTB)*PT5
     *                               *(1.0D+00-DFHY)
            END IF
            PMSC = PMSC + EC3(IM)
            EHF3(IM)=2*CMO3T(IM)+2*CMO3V(IM)+2*CMO3J(IM)+EMNU(IM)
     *                +CMO3K(IM)+EC3(IM)
         END IF
C
         IF(MMULT(IM).GT.0) THEN
            NAALL  = NAALL + NA
            IF(SCFTYP.EQ.UHF) NBALL = NBALL + NB
         ELSE IF(MMULT(IM).LT.0) THEN
            NAALL  = NAALL + NB
            IF(SCFTYP.EQ.UHF) NBALL = NBALL + NA
         END IF
      PMST = PMST + CMO3T(IM)
      PMSK = PMSK + CMO3K(IM)
      EPM  = EPM  +  EHF3(IM)
C
  300 CONTINUE
C
C     - RESTORE MOLECULAR INFORMATION -
      NAT    =  NATX
      ICH    =  ICHX
      MUL    =  MULX
      NUM    =  NUMX
      NQMT   =  NQMTX
      NE     =  NEX
      NA     =  NAX
      NB     =  NBX
      DO III  =  1, NATX
         ZAN(III) = ZANX(III)
         C(1,III) = CX(1,III)
         C(2,III) = CX(2,III)
         C(3,III) = CX(3,III)
         IAN(III) = IANX(III)
      ENDDO
C
C
C
C
C     ------------------------------------------
C     - SUPER MOLECULE ENERGY WITH MONOMER LMO -
C     ------------------------------------------
C
C     ZDO = .T. WILL SKIP ORTHONORMALIZATION IN TRFMCX
C               FOR ELECTROSTATIC INTERACTION
C     ZDO = .F. WILL ENFORCE ORTHONORMALIZATION IN TRFMCX
C               FOR EXCHANGE-REPULSION
C     ILOCAL = 0  MEANS NO LOCALIZATION IS ACTUALLY PERFORMED
C
      ZDOSV = ZDO
C
C
C     - ELECTROSTATIC INTERACTION -
C          OWN BASIS
C
      IF(MASWRK) WRITE(IW,5012)
      CALL ONEEI
      ZDO   = .TRUE.
      CALL DAWRIT(IDAF,IODA,CMO1A,NUM*NUM,15,0)
      IF(SCFTYP.EQ.UHF .AND. NB.GT.0) THEN
         CALL DAWRIT(IDAF,IODA,CMO1B,NUM*NUM,19,0)
      END IF
      TKTOLA   = ZERO
      VTOLA    = ZERO
      GKTOLA   = ZERO
      GDTOLA   = ZERO
      GJTOLA   = ZERO
      TKTOLB   = ZERO
      VTOLB    = ZERO
      GKTOLB   = ZERO
      GDTOLB   = ZERO
      GJTOLB   = ZERO
      GKSV     = ZERO
      NPRINTSV = NPRINT
      NPRINT   = -5
      ILOCAL   = 0
      IF(NE.GT.0) CALL LOCENG
      NPRINT   = NPRINTSV
      GDDFTA   = ZERO
      GDDFTB   = ZERO
      CALL PRTDJK(GJA,GKA,GDA,GJB,GKB,GDB,NA,NB)
      CALL PRTTV(TLMOA,VLMOA,TLMOB,VLMOB,NA,NB)
      IF(SCFTYP.EQ.UHF .AND. NA.EQ.1) GDDFTA = GDTOLA
      IF(SCFTYP.EQ.UHF .AND. NA.LE.1) GDTOLA = ZERO
      IF(NB.EQ.1) GDDFTB = GDTOLB
      IF(NB.LE.1) GDTOLB = ZERO
      IF(SCFTYP.EQ.RHF) THEN
         PSMT0 = TKTOLA
         PSMV0 =  VTOLA
         PSMK1 =-GKTOLA
         GKSV  =-GKTOLA - GDTOLA
         PSMD0 = GDTOLA
         PSMJ0 = GJTOLA + GDTOLA*PT5
      ELSE IF(SCFTYP.EQ.UHF) THEN
         PSMT0 = (TKTOLB + TKTOLA)*PT5
         PSMV0 = ( VTOLB +  VTOLA)*PT5
         PSMK1 =-(GKTOLB + GKTOLA)*PT5
         GKSV  =-(GKTOLB + GKTOLA)*PT5-(GDTOLB + GDTOLA)*PT5
         PSMD0 = (GDTOLB + GDTOLA)*PT5
         PSMJ0 = (GJTOLB + GJTOLA)*PT5+(GDTOLB + GDTOLA)*PT25
      END IF
C
C     - HOWEVER, J IS WRONG FOR UHF. RUN LOCENG AGAIN TO GET J
C     - WE CHEAT LOCENG BY SUPPLYING ALL ALPHA LMOS
      IF(SCFTYP.EQ.UHF .AND. NE.GT.0) THEN
         CALL VCLR(TMP1A,1,NUM*NUM)
         DO ILMO = 1, NA
            DO JJJ = 1, NUM
               TMP1A(JJJ,ILMO)=CMO1A(JJJ,ILMO)
            ENDDO
         ENDDO
         DO ILMO = 1, NB
            DO JJJ = 1, NUM
               TMP1A(JJJ,NA+ILMO)=CMO1B(JJJ,ILMO)
            ENDDO
         ENDDO
         CALL DAWRIT(IDAF,IODA,TMP1A,NUM*NUM,15,0)
         ZDOSV1   = ZDO
         ZDO      = .TRUE.
         SCFTYP   = RHF
         NA       = NA + NB
         TKTOLA   = ZERO
         VTOLA    = ZERO
         GKTOLA   = ZERO
         GDTOLA   = ZERO
         GJTOLA   = ZERO
         TKTOLB   = ZERO
         VTOLB    = ZERO
         GKTOLB   = ZERO
         GDTOLB   = ZERO
         GJTOLB   = ZERO
         NPRINTSV = NPRINT
         NPRINT   = -5
         ILOCAL   = 0
         IF(NE.GT.0) CALL LOCENG
         NPRINT   = NPRINTSV
         ZDO      = ZDOSV1
         SCFTYP   = UHF
         NA       = NA - NB
         IF(NA.LE.1) GDTOLA = ZERO
         IF(NB.LE.1) GDTOLB = ZERO
         PSMJ0  = GJTOLA*PT25
         CALL DAREAD(IDAF,IODA,GJA,NMO*NMO,604,0)
         IF(MASWRK) THEN
            WRITE(IW,9160)
            DO I=1,NA
               DO J=NA+1,NA+NB
                  WRITE(IW,'(I9,I9,5X,F17.10)')
     *                  I,J-NA,GJA(I,J)
               ENDDO
               WRITE(IW,*) ' '
            ENDDO
         END IF
      END IF
C
C     - GET DFT EXC FROM CMO1 -
      IF(DFTYPE.NE.RNONE) THEN
C        - WRITE LMO AGAIN -
         CALL DAWRIT(IDAF,IODA,CMO1A,NUM*NUM,15,0)
         IF(SCFTYP.EQ.UHF .AND. NB.GT.0) THEN
            CALL DAWRIT(IDAF,IODA,CMO1B,NUM*NUM,19,0)
         END IF
C
         NPRINTSV = NPRINT
         NPRINT = -5
         NPRTGOSV = NPRTGO
         NPRTGO = 2
         IREST  = 2
         MAXITSV= MAXIT
         MAXIT  = 1
         ECORL  = ZERO
         EXCOR  = ZERO
         IF(SCFTYP.EQ.RHF .AND. NE.GT.0) THEN
            CALL RHFCL
         ELSE IF(SCFTYP.EQ.UHF .AND. NE.GT.0) THEN
            SZ = ZERO
            S2 = ZERO
            CALL UHFOP(SZ,S2)
         END IF
         MAXIT  = MAXITSV
         NPRINT = NPRINTSV
         NPRTGO = NPRTGOSV
         PSMK1  = EXCOR - ECORL + PSMD0 + DFHY*GKSV
         IF(SCFTYP.EQ.UHF .AND. NA.EQ.1) THEN
            PSMK1 = EXCOR - ECORL+GDDFTA*PT5*(1.0D+00-DFHY)
            IF(NB.EQ.1) PSMK1 = EXCOR-ECORL+(GDDFTA+GDDFTB)*PT5
     *                          *(1.0D+00-DFHY)
         END IF
      END IF
C
C
      IF(.NOT.SUPBAS) GOTO 400
C     *******************************
C
C     - ELECTROSTATIC INTERACTION -
C          ALL BASIS
C
      IF(MASWRK) WRITE(IW,5013)
      CALL DAWRIT(IDAF,IODA,CMO2A,NUM*NUM,15,0)
      IF(SCFTYP.EQ.UHF .AND. NB.GT.0) THEN
         CALL DAWRIT(IDAF,IODA,CMO2B,NUM*NUM,19,0)
      END IF
      TKTOLA   = ZERO
      VTOLA    = ZERO
      GKTOLA   = ZERO
      GDTOLA   = ZERO
      GJTOLA   = ZERO
      TKTOLB   = ZERO
      VTOLB    = ZERO
      GKTOLB   = ZERO
      GDTOLB   = ZERO
      GJTOLB   = ZERO
      GKSV     = ZERO
      NPRINTSV = NPRINT
      NPRINT   = -5
      ILOCAL   = 0
      IF(NE.GT.0) CALL LOCENG
      NPRINT   = NPRINTSV
      GDDFTA = ZERO
      GDDFTB = ZERO
      CALL PRTDJK(GJA,GKA,GDA,GJB,GKB,GDB,NA,NB)
      CALL PRTTV(TLMOA,VLMOA,TLMOB,VLMOB,NA,NB)
      IF(SCFTYP.EQ.UHF .AND. NA.EQ.1) GDDFTA = GDTOLA
      IF(SCFTYP.EQ.UHF .AND. NA.LE.1) GDTOLA = ZERO
      IF(NB.EQ.1) GDDFTB = GDTOLB
      IF(NB.LE.1) GDTOLB = ZERO
      IF(SCFTYP.EQ.RHF) THEN
         PSAT0 = TKTOLA
         PSAV0 = VTOLA
         PSAK1 =-GKTOLA
         GKSV  =-GKTOLA - GDTOLA
         PSAD0 = GDTOLA
         PSAJ0 = GJTOLA + GDTOLA*PT5
      ELSE IF(SCFTYP.EQ.UHF) THEN
         PSAT0 = (TKTOLB + TKTOLA)*PT5
         PSAV0 = (VTOLB  +  VTOLA)*PT5
         PSAK1 =-(GKTOLB + GKTOLA)*PT5
         GKSV  =-(GKTOLB + GKTOLA)*PT5-(GDTOLB + GDTOLA)*PT5
         PSAD0 = (GDTOLB + GDTOLA)*PT5
         PSAJ0 = (GJTOLB + GJTOLA)*PT5+(GDTOLB + GDTOLA)*PT25
      END IF
C
C     - HOWEVER, J IS WRONG FOR UHF. RUN LOCENG AGAIN TO GET J
C     - WE CHEAT LOCENG BY SUPPLYING ALL ALPHA LMOS
      IF(SCFTYP.EQ.UHF .AND. NE.GT.0) THEN
         CALL VCLR(TMP1A,1,NUM*NUM)
         DO ILMO = 1, NA
            DO JJJ = 1, NUM
               TMP1A(JJJ,ILMO)=CMO2A(JJJ,ILMO)
            ENDDO
         ENDDO
         DO ILMO = 1, NB
            DO JJJ = 1, NUM
               TMP1A(JJJ,NA+ILMO)=CMO2B(JJJ,ILMO)
            ENDDO
         ENDDO
         CALL DAWRIT(IDAF,IODA,TMP1A,NUM*NUM,15,0)
         ZDOSV1   = ZDO
         ZDO      = .TRUE.
         SCFTYP   = RHF
         NA       = NA + NB
         TKTOLA   = ZERO
         VTOLA    = ZERO
         GKTOLA   = ZERO
         GDTOLA   = ZERO
         GJTOLA   = ZERO
         TKTOLB   = ZERO
         VTOLB    = ZERO
         GKTOLB   = ZERO
         GDTOLB   = ZERO
         GJTOLB   = ZERO
         NPRINTSV = NPRINT
         NPRINT   = -5
         ILOCAL   = 0
         IF(NE.GT.0) CALL LOCENG
         NPRINT   = NPRINTSV
         ZDO      = ZDOSV1
         SCFTYP   = UHF
         NA       = NA - NB
         IF(NA.LE.1) GDTOLA = ZERO
         IF(NB.LE.1) GDTOLB = ZERO
         PSAJ0  = GJTOLA*PT25
         CALL DAREAD(IDAF,IODA,GJA,NMO*NMO,604,0)
         IF(MASWRK) THEN
            WRITE(IW,9160)
            DO I=1,NA
               DO J=NA+1,NA+NB
                  WRITE(IW,'(I9,I9,5X,F17.10)')
     *                  I,J-NA,GJA(I,J)
               ENDDO
               WRITE(IW,*) ' '
            ENDDO
         END IF
      END IF
C
C     - GET DFT EXC FROM CMO2 -
      IF(DFTYPE.NE.RNONE) THEN
C        - WRITE LMO AGAIN -
         CALL DAWRIT(IDAF,IODA,CMO2A,NUM*NUM,15,0)
         IF(SCFTYP.EQ.UHF .AND. NB.GT.0) THEN
            CALL DAWRIT(IDAF,IODA,CMO2B,NUM*NUM,19,0)
         END IF
C
         NPRINTSV = NPRINT
         NPRINT = -5
         NPRTGOSV = NPRTGO
         NPRTGO = 2
         IREST  = 2
         MAXITSV= MAXIT
         MAXIT  = 1
         ECORL  = ZERO
         EXCOR  = ZERO
         IF(SCFTYP.EQ.RHF .AND. NE.GT.0) THEN
            CALL RHFCL
         ELSE IF(SCFTYP.EQ.UHF .AND. NE.GT.0) THEN
            SZ = ZERO
            S2 = ZERO
            CALL UHFOP(SZ,S2)
         END IF
         MAXIT  = MAXITSV
         NPRINT = NPRINTSV
         NPRTGO = NPRTGOSV
         PSAK1  = EXCOR - ECORL + PSAD0 + DFHY*GKSV
         IF(SCFTYP.EQ.UHF .AND. NA.EQ.1) THEN
            PSAK1 = EXCOR - ECORL+GDDFTA*PT5*(1.0D+00-DFHY)
            IF(NB.EQ.1) PSAK1 = EXCOR-ECORL+(GDDFTA+GDDFTB)*PT5
     *                          *(1.0D+00-DFHY)
         END IF
      END IF
  400 CONTINUE
C
C
C     - REPULSION INTERACTION -
C          OWN BASIS
C
      ZDO = .FALSE.
      IF(MASWRK) WRITE(IW,5014)
      CALL DAWRIT(IDAF,IODA,CMO1A,NUM*NUM,15,0)
      IF(SCFTYP.EQ.UHF .AND. NB.GT.0) THEN
         CALL DAWRIT(IDAF,IODA,CMO1B,NUM*NUM,19,0)
      END IF
      TKTOLA   = ZERO
      VTOLA    = ZERO
      GKTOLA   = ZERO
      GDTOLA   = ZERO
      GJTOLA   = ZERO
      TKTOLB   = ZERO
      VTOLB    = ZERO
      GKTOLB   = ZERO
      GDTOLB   = ZERO
      GJTOLB   = ZERO
      GKSV     = ZERO
      NPRINTSV = NPRINT
      NPRINT   = -5
      ILOCAL   = 0
      IF(NE.GT.0) CALL LOCENG
      NPRINT   = NPRINTSV
      GDDFTA   = ZERO
      GDDFTB   = ZERO
      CALL PRTDJK(GJA,GKA,GDA,GJB,GKB,GDB,NA,NB)
      CALL PRTTV(TLMOA,VLMOA,TLMOB,VLMOB,NA,NB)
      IF(SCFTYP.EQ.UHF .AND. NA.EQ.1) GDDFTA = GDTOLA
      IF(SCFTYP.EQ.UHF .AND. NA.LE.1) GDTOLA = ZERO
      IF(NB.EQ.1) GDDFTB = GDTOLB
      IF(NB.LE.1) GDTOLB = ZERO
      IF(SCFTYP.EQ.RHF) THEN
         PSMT2 = TKTOLA
         PSMV2 = VTOLA
         PSMK2 =-GKTOLA
         GKSV  =-GKTOLA - GDTOLA
         PSMD2 = GDTOLA
         PSMJ2 = GJTOLA + GDTOLA*PT5
      ELSE IF(SCFTYP.EQ.UHF) THEN
         PSMT2 = (TKTOLB + TKTOLA)*PT5
         PSMV2 = (VTOLB  +  VTOLA)*PT5
         PSMK2 =-(GKTOLB + GKTOLA)*PT5
         GKSV  =-(GKTOLB + GKTOLA)*PT5-(GDTOLB + GDTOLA)*PT5
         PSMD2 = (GDTOLB + GDTOLA)*PT5
         PSMJ2 = (GJTOLB + GJTOLA)*PT5+(GDTOLB + GDTOLA)*PT25
      END IF
C
C     - HOWEVER, J IS WRONG FOR UHF. RUN LOCENG AGAIN TO GET J
C     - WE CHEAT LOCENG BY SUPPLYING ALL ALPHA LMOS
      IF(SCFTYP.EQ.UHF .AND. NE.GT.0) THEN
C        - FIRST READ ORTHONORMALIZED LMO FROM 71 AND 72 -
         IF(NA.GT.0) CALL DAREAD(IDAF,IODA,TMP3A,NUM*NUM,71,0)
         IF(NB.GT.0) CALL DAREAD(IDAF,IODA,TMP3B,NUM*NUM,72,0)
C
         CALL VCLR(TMP1A,1,NUM*NUM)
         DO ILMO = 1, NA
            DO JJJ = 1, NUM
               TMP1A(JJJ,ILMO)=TMP3A(JJJ,ILMO)
            ENDDO
         ENDDO
         DO ILMO = 1, NB
            DO JJJ = 1, NUM
               TMP1A(JJJ,NA+ILMO)=TMP3B(JJJ,ILMO)
            ENDDO
         ENDDO
         CALL DAWRIT(IDAF,IODA,TMP1A,NUM*NUM,15,0)
         ZDOSV1 = ZDO
         ZDO    = .TRUE.
         SCFTYP = RHF
         NA     = NA + NB
         TKTOLA   = ZERO
         VTOLA    = ZERO
         GKTOLA   = ZERO
         GDTOLA   = ZERO
         GJTOLA   = ZERO
         TKTOLB   = ZERO
         VTOLB    = ZERO
         GKTOLB   = ZERO
         GDTOLB   = ZERO
         GJTOLB   = ZERO
         NPRINTSV = NPRINT
         NPRINT   = -5
         ILOCAL   = 0
         IF(NE.GT.0) CALL LOCENG
         NPRINT   = NPRINTSV
         ZDO      = ZDOSV1
         SCFTYP   = UHF
         NA       = NA - NB
         IF(NA.LE.1) GDTOLA = ZERO
         IF(NB.LE.1) GDTOLB = ZERO
         PSMJ2  = GJTOLA*PT25
         CALL DAREAD(IDAF,IODA,GJA,NMO*NMO,604,0)
         IF(MASWRK) THEN
            WRITE(IW,9160)
            DO I=1,NA
               DO J=NA+1,NA+NB
                  WRITE(IW,'(I9,I9,5X,F17.10)')
     *                  I,J-NA,GJA(I,J)
               ENDDO
               WRITE(IW,*) ' '
            ENDDO
         END IF
      END IF
C
C     - GET DFT EXC FROM ORTHO-NORM CMO1 -
      IF(DFTYPE.NE.RNONE) THEN
C        - FIRST READ ORTHONORMALIZED LMO FROM 71 AND 72 -
         IF(NA.GT.0) CALL DAREAD(IDAF,IODA,TMP3A,NUM*NUM,71,0)
         IF(NA.GT.0) CALL DAWRIT(IDAF,IODA,TMP3A,NUM*NUM,15,0)
         IF(SCFTYP.EQ.UHF .AND. NB.GT.0) THEN
            CALL DAREAD(IDAF,IODA,TMP3B,NUM*NUM,72,0)
            CALL DAWRIT(IDAF,IODA,TMP3B,NUM*NUM,19,0)
         END IF
C
         NPRINTSV = NPRINT
         NPRINT   = -5
         NPRTGOSV = NPRTGO
         NPRTGO = 2
         IREST=2
         MAXITSV=MAXIT
         MAXIT=1
         ECORL    = ZERO
         EXCOR    = ZERO
         IF(SCFTYP.EQ.RHF .AND. NE.GT.0) THEN
            CALL RHFCL
         ELSE IF(SCFTYP.EQ.UHF .AND. NE.GT.0) THEN
            SZ = ZERO
            S2 = ZERO
            CALL UHFOP(SZ,S2)
         END IF
         MAXIT = MAXITSV
         NPRINT= NPRINTSV
         NPRTGO= NPRTGOSV
         PSMK2 = EXCOR - ECORL + PSMD2 + DFHY*GKSV
         IF(SCFTYP.EQ.UHF .AND. NA.EQ.1) THEN
            PSMK2 = EXCOR - ECORL +GDDFTA*PT5*(1.0D+00-DFHY)
            IF(NB.EQ.1) PSMK2 = EXCOR-ECORL+(GDDFTA+GDDFTB)*PT5
     *                          *(1.0D+00-DFHY)
         END IF
      END IF
C
C
C
      IF(.NOT.SUPBAS) GOTO 500
C     *******************************
C
C     - REPULSION INTERACTION -
C          ALL BASIS
C
      IF(MASWRK) WRITE(IW,5015)
      CALL DAWRIT(IDAF,IODA,CMO2A,NUM*NUM,15,0)
      IF(SCFTYP.EQ.UHF .AND. NB.GT.0) THEN
         CALL DAWRIT(IDAF,IODA,CMO2B,NUM*NUM,19,0)
      END IF
      TKTOLA   = ZERO
      VTOLA    = ZERO
      GKTOLA   = ZERO
      GDTOLA   = ZERO
      GJTOLA   = ZERO
      TKTOLB   = ZERO
      VTOLB    = ZERO
      GKTOLB   = ZERO
      GDTOLB   = ZERO
      GJTOLB   = ZERO
      GKSV     = ZERO
      NPRINTSV = NPRINT
      NPRINT   = -5
      ILOCAL   = 0
      IF(NE.GT.0) CALL LOCENG
      NPRINT   = NPRINTSV
      GDDFTA   = ZERO
      GDDFTB   = ZERO
      CALL PRTDJK(GJA,GKA,GDA,GJB,GKB,GDB,NA,NB)
      CALL PRTTV(TLMOA,VLMOA,TLMOB,VLMOB,NA,NB)
      IF(SCFTYP.EQ.UHF .AND. NA.EQ.1) GDDFTA = GDTOLA
      IF(SCFTYP.EQ.UHF .AND. NA.LE.1) GDTOLA = ZERO
      IF(NB.EQ.1) GDDFTB = GDTOLB
      IF(NB.LE.1) GDTOLB = ZERO
      IF(SCFTYP.EQ.RHF) THEN
         PSAT2 = TKTOLA
         PSAV2 = VTOLA
         PSAK2 =-GKTOLA
         GKSV  =-GKTOLA - GDTOLA
         PSAD2 = GDTOLA
         PSAJ2 = GJTOLA + GDTOLA*PT5
      ELSE IF(SCFTYP.EQ.UHF) THEN
         PSAT2 = (TKTOLB + TKTOLA)*PT5
         PSAV2 = (VTOLB  +  VTOLA)*PT5
         PSAK2 =-(GKTOLB + GKTOLA)*PT5
         GKSV  =-(GKTOLB + GKTOLA)*PT5-(GDTOLB + GDTOLA)*PT5
         PSAD2 = (GDTOLB + GDTOLA)*PT5
         PSAJ2 = (GJTOLB + GJTOLA)*PT5+(GDTOLB + GDTOLA)*PT25
      END IF
C
C
C     - HOWEVER, J IS WRONG FOR UHF. RUN LOCENG AGAIN TO GET J
C     - WE CHEAT LOCENG BY SUPPLYING ALL ALPHA LMOS
      IF(SCFTYP.EQ.UHF .AND. NE.GT.0) THEN
C        - FIRST READ ORTHONORMALIZED LMO FROM 71 AND 72 -
         IF(NA.GT.0) CALL DAREAD(IDAF,IODA,TMP3A,NUM*NUM,71,0)
         IF(NB.GT.0) CALL DAREAD(IDAF,IODA,TMP3B,NUM*NUM,72,0)
C
         CALL VCLR(TMP1A,1,NUM*NUM)
         DO ILMO = 1, NA
            DO JJJ = 1, NUM
               TMP1A(JJJ,ILMO)=TMP3A(JJJ,ILMO)
            ENDDO
         ENDDO
         DO ILMO = 1, NB
            DO JJJ = 1, NUM
               TMP1A(JJJ,NA+ILMO)=TMP3B(JJJ,ILMO)
            ENDDO
         ENDDO
         CALL DAWRIT(IDAF,IODA,TMP1A,NUM*NUM,15,0)
         ZDOSV1   = ZDO
         ZDO      = .TRUE.
         SCFTYP   = RHF
         NA       = NA + NB
         TKTOLA   = ZERO
         VTOLA    = ZERO
         GKTOLA   = ZERO
         GDTOLA   = ZERO
         GJTOLA   = ZERO
         TKTOLB   = ZERO
         VTOLB    = ZERO
         GKTOLB   = ZERO
         GDTOLB   = ZERO
         GJTOLB   = ZERO
         NPRINTSV = NPRINT
         NPRINT   = -5
         ILOCAL   = 0
         IF(NE.GT.0) CALL LOCENG
         NPRINT   = NPRINTSV
         ZDO      = ZDOSV1
         SCFTYP   = UHF
         NA       = NA - NB
         IF(NA.LE.1) GDTOLA = ZERO
         IF(NB.LE.1) GDTOLB = ZERO
         PSAJ2  = GJTOLA*PT25
         CALL DAREAD(IDAF,IODA,GJA,NMO*NMO,604,0)
         IF(MASWRK) THEN
            WRITE(IW,9160)
            DO I=1,NA
               DO J=NA+1,NA+NB
                  WRITE(IW,'(I9,I9,5X,F17.10)')
     *                  I,J-NA,GJA(I,J)
               ENDDO
               WRITE(IW,*) ' '
            ENDDO
         END IF
      END IF
C
C
C     - GET DFT EXC FROM ORTHO-NORM CMO2 -
      IF(DFTYPE.NE.RNONE) THEN
C        - FIRST READ ORTHONORMALIZED LMO FROM 71 AND 72 -
         IF(NA.GT.0) CALL DAREAD(IDAF,IODA,TMP3A,NUM*NUM,71,0)
         IF(NA.GT.0) CALL DAWRIT(IDAF,IODA,TMP3A,NUM*NUM,15,0)
         IF(SCFTYP.EQ.UHF .AND. NB.GT.0) THEN
            CALL DAREAD(IDAF,IODA,TMP3B,NUM*NUM,72,0)
            CALL DAWRIT(IDAF,IODA,TMP3B,NUM*NUM,19,0)
         END IF
C
         NPRINTSV = NPRINT
         NPRINT   = -5
         NPRTGOSV = NPRTGO
         NPRTGO = 2
         IREST=2
         MAXITSV=MAXIT
         MAXIT=1
         ECORL    = ZERO
         EXCOR    = ZERO
         IF(SCFTYP.EQ.RHF .AND. NE.GT.0) THEN
            CALL RHFCL
         ELSE IF(SCFTYP.EQ.UHF .AND. NE.GT.0) THEN
            SZ = ZERO
            S2 = ZERO
            CALL UHFOP(SZ,S2)
         END IF
         MAXIT = MAXITSV
         NPRINT= NPRINTSV
         NPRTGO= NPRTGOSV
         PSAK2 = EXCOR - ECORL + PSAD2 + DFHY*GKSV
         IF(SCFTYP.EQ.UHF .AND. NA.EQ.1) THEN
            PSAK2 = EXCOR - ECORL+GDDFTA*PT5*(1.0D+00-DFHY)
            IF(NB.EQ.1) PSAK2 = EXCOR-ECORL+(GDDFTA+GDDFTB)*PT5
     *                          *(1.0D+00-DFHY)
         END IF
      END IF
  500 CONTINUE
C
      ZDO = ZDOSV
C
C
C
C     - CONSTRUCT SUPER MOLECULE ENERGY -
C
      PSME0  = TWO*(PSMT0 + PSMV0 + PSMJ0) + PSMK0 + ENUCS + PSMC0
      PSME1  = TWO*(PSMT0 + PSMV0 + PSMJ0) + PSMK1 + ENUCS + PSMC0
      PSME2  = TWO*(PSMT2 + PSMV2 + PSMJ2) + PSMK2 + ENUCS + PSMC0
      IF(SUPBAS) THEN
         PSAE0  = TWO*(PSAT0 + PSAV0 + PSAJ0) + PSAK0 + ENUCS + PSAC0
         PSAE1  = TWO*(PSAT0 + PSAV0 + PSAJ0) + PSAK1 + ENUCS + PSAC0
         PSAE2  = TWO*(PSAT2 + PSAV2 + PSAJ2) + PSAK2 + ENUCS + PSAC0
      ENDIF
      PMSE0  = TWO*(PMST +SUPERV + SUPERJ) + PMSK  + ENUCS + PMSC
      PMSE1  = TWO*(PMST +SUPERV + SUPERJ) + SUPERK+ ENUCS + PMSC
      PMSE2  = PMSE1
C
C     - CALCULATE INTERACTION ENERGIES -
C
      ESTM          = PSME0  - EMALL
      EEXM          = PSME1  - PSME0
      REPM          = PSME2  - PSME1
      EPOLM         = ESUPER - PSME2
      EINTHFM       = ESUPER - EMALL
      IF(SUPBAS) THEN
         ESTA          = PSAE0  - EAALL
         EEXA          = PSAE1  - PSAE0
         REPA          = PSAE2  - PSAE1
         EPOLA         = ESUPER - PSAE2
         EINTHFA       = ESUPER - EAALL
      END IF
      ESTP          = PMSE0  - EPM
      EEXP          = PMSE1  - PMSE0
      EINTHFP       = ESUPER - EPM
C
      IF(DFTYPE.NE.RNONE) THEN
         EDISPM     = ESUC   - PSMC0
         EPOLM      = EPOLM  - EDISPM
         IF(SUPBAS) THEN
            EDISPA     = ESUC   - PSAC0
            EPOLA      = EPOLA  - EDISPA
         END IF
         EDISPP     = ESUC   - PMSC
      END IF
C
      IF(MPLEVL.EQ.2 .OR. CCTYP.EQ.CCSDT .OR. CCTYP.EQ.CCSD) THEN
         EMP2DISPM  = ESUMP2 - EMMP2ALL - EINTHFM
         EMP2INTM   = ESUMP2 - EMMP2ALL
         IF(SUPBAS) THEN
         EMP2DISPA  = ESUMP2 - EAMP2ALL - EINTHFA
         EMP2INTA   = ESUMP2 - EAMP2ALL
         END IF
      END IF
C
      IF(CCTYP.EQ.CCSDT .OR. CCTYP.EQ.CCSD) THEN
         ECCDISPM   = ESUCC  - EMCCALL  - EINTHFM
         ECCINTM    = ESUCC  - EMCCALL
         IF(SUPBAS) THEN
         ECCDISPA   = ESUCC  - EACCALL  - EINTHFA
         ECCINTA    = ESUCC  - EACCALL
         ENDIF
      END IF
C
C
C
C     -----------------
C     - PRINT RESULTS -
C     -----------------
C
      IF (MASWRK) THEN
C
C        - PRINT MONOMER ENERGY -
C
         WRITE(IW,9000)
         WRITE(IW,9001)
         WRITE(IW,5690)
         DO IM=1,NMOL
          WRITE(IW,5800) IM
          IF(SUPBAS) THEN
            WRITE(IW,5900)
            WRITE(IW,6001)  TWO*CMO1T(IM), TWO*CMO2T(IM), TWO*CMO3T(IM)
            WRITE(IW,6002)  TWO*CMO1V(IM), TWO*CMO2V(IM), TWO*CMO3V(IM)
            WRITE(IW,6003)      CMO1K(IM),     CMO2K(IM),     CMO3K(IM)
            WRITE(IW,6005)  TWO*CMO1J(IM), TWO*CMO2J(IM), TWO*CMO3J(IM)
            WRITE(IW,6007)       EMNU(IM),      EMNU(IM),      EMNU(IM)
            IF(DFTYPE.NE.RNONE)
     *         WRITE(IW,6010)     EC1(IM),       EC2(IM),       EC3(IM)
            WRITE(IW,6006)       EHF1(IM),      EHF2(IM),      EHF3(IM)
            IF((MPLEVL.EQ.2 .OR. CCTYP.EQ.CCSDT
     *         .OR. (CCTYP.EQ.CCSD) .AND. SCFTYPSV.NE.ROHF))
     *         WRITE(IW,6008)   EMMP2(IM),     EAMP2(IM)
            IF(CCTYP.EQ.CCSD)
     *         WRITE(IW,6019)    EMCC(IM),      EACC(IM)
            IF(CCTYP.EQ.CCSDT)
     *         WRITE(IW,6009)    EMCC(IM),      EACC(IM)
          ELSE
            WRITE(IW,5910)
            WRITE(IW,6001)  TWO*CMO1T(IM), TWO*CMO3T(IM)
            WRITE(IW,6002)  TWO*CMO1V(IM), TWO*CMO3V(IM)
            WRITE(IW,6003)      CMO1K(IM),     CMO3K(IM)
            WRITE(IW,6005)  TWO*CMO1J(IM), TWO*CMO3J(IM)
            WRITE(IW,6007)       EMNU(IM),      EMNU(IM)
            IF(DFTYPE.NE.RNONE)
     *         WRITE(IW,6010)     EC1(IM),       EC3(IM)
            WRITE(IW,6006)       EHF1(IM),      EHF3(IM)
            IF((MPLEVL.EQ.2 .OR. CCTYP.EQ.CCSDT
     *         .OR. (CCTYP.EQ.CCSD) .AND. SCFTYPSV.NE.ROHF))
     *         WRITE(IW,6008)   EMMP2(IM)
            IF(CCTYP.EQ.CCSD)
     *         WRITE(IW,6019)    EMCC(IM),      EACC(IM)
            IF(CCTYP.EQ.CCSDT)
     *         WRITE(IW,6009)    EMCC(IM)
          ENDIF
         ENDDO
C
C        - 0. PRINT ENERGY OF SUPER MOLECULE -
C          (ELECTROSTATIC: NON-ANTISYMMETRIC NON-ORTHONORMAL LMO)
C
         WRITE(IW,5700)
         IF(SUPBAS) THEN
            WRITE(IW,5600)
            WRITE(IW,6001)       TWO*PSMT0,  TWO*PSAT0,    TWO*PMST
            WRITE(IW,6002)       TWO*PSMV0,  TWO*PSAV0,  TWO*SUPERV
            WRITE(IW,6003)           PSMK0,      PSAK0,        PMSK
            WRITE(IW,6005)       TWO*PSMJ0,  TWO*PSAJ0,  TWO*SUPERJ
            WRITE(IW,6007)           ENUCS,      ENUCS,       ENUCS
            IF(DFTYPE.NE.RNONE)
     *         WRITE(IW,6010)        PSMC0,      PSAC0,        PMSC
            WRITE(IW,6006)           PSME0,      PSAE0,       PMSE0
         ELSE
            WRITE(IW,5610)
            WRITE(IW,6001)       TWO*PSMT0,    TWO*PMST
            WRITE(IW,6002)       TWO*PSMV0,  TWO*SUPERV
            WRITE(IW,6003)           PSMK0,        PMSK
            WRITE(IW,6005)       TWO*PSMJ0,  TWO*SUPERJ
            WRITE(IW,6007)           ENUCS,       ENUCS
            IF(DFTYPE.NE.RNONE)
     *         WRITE(IW,6010)        PSMC0,        PMSC
            WRITE(IW,6006)           PSME0,       PMSE0
         END IF
C
C
C        - 1. PRINT ENERGY OF SUPER MOLECULE -
C          (EXCHANGE: ANTISYMMETRIC NON-ORTHONORMAL LMO)
C
         WRITE(IW,5710)
         IF(SUPBAS) THEN
            WRITE(IW,5600)
            WRITE(IW,6001)       TWO*PSMT0,  TWO*PSAT0,    TWO*PMST
            WRITE(IW,6002)       TWO*PSMV0,  TWO*PSAV0,  TWO*SUPERV
            WRITE(IW,6003)           PSMK1,      PSAK1,      SUPERK
            WRITE(IW,6005)       TWO*PSMJ0,  TWO*PSAJ0,  TWO*SUPERJ
            WRITE(IW,6007)           ENUCS,      ENUCS,       ENUCS
            IF(DFTYPE.NE.RNONE)
     *         WRITE(IW,6010)        PSMC0,      PSAC0,        PMSC
            WRITE(IW,6006)           PSME1,      PSAE1,       PMSE1
         ELSE
            WRITE(IW,5610)
            WRITE(IW,6001)       TWO*PSMT0,    TWO*PMST
            WRITE(IW,6002)       TWO*PSMV0,  TWO*SUPERV
            WRITE(IW,6003)           PSMK1,      SUPERK
            WRITE(IW,6005)       TWO*PSMJ0,  TWO*SUPERJ
            WRITE(IW,6007)           ENUCS,       ENUCS
            IF(DFTYPE.NE.RNONE)
     *         WRITE(IW,6010)        PSMC0,        PMSC
            WRITE(IW,6006)           PSME1,       PMSE1
         END IF
C
C
C        - 2. PRINT ENERGY OF SUPER MOLECULE -
C          (REPULSION: ANTISYMMETRIC-ORTHONORMAL LMO)
C
         WRITE(IW,5750)
         IF(SUPBAS) THEN
            WRITE(IW,5600)
            WRITE(IW,6001)       TWO*PSMT2,  TWO*PSAT2,    TWO*PMST
            WRITE(IW,6002)       TWO*PSMV2,  TWO*PSAV2,  TWO*SUPERV
            WRITE(IW,6003)           PSMK2,      PSAK2,      SUPERK
            WRITE(IW,6005)       TWO*PSMJ2,  TWO*PSAJ2,  TWO*SUPERJ
            WRITE(IW,6007)           ENUCS,      ENUCS,       ENUCS
            IF(DFTYPE.NE.RNONE)
     *         WRITE(IW,6010)        PSMC0,      PSAC0,        PMSC
            WRITE(IW,6006)           PSME2,      PSAE2,       PMSE2
         ELSE
            WRITE(IW,5610)
            WRITE(IW,6001)       TWO*PSMT2,    TWO*PMST
            WRITE(IW,6002)       TWO*PSMV2,  TWO*SUPERV
            WRITE(IW,6003)           PSMK2,      SUPERK
            WRITE(IW,6005)       TWO*PSMJ2,  TWO*SUPERJ
            WRITE(IW,6007)           ENUCS,       ENUCS
            IF(DFTYPE.NE.RNONE)
     *         WRITE(IW,6010)        PSMC0,        PMSC
            WRITE(IW,6006)           PSME2,       PMSE2
         END IF
C
C
C        - PRINT SCF SUPER MOLECULA ENERGY -
C
         WRITE(IW,5760)
         IF(SUPBAS) THEN
            WRITE(IW,6001)      TWO*SUPERT,  TWO*SUPERT
            WRITE(IW,6002)      TWO*SUPERV,  TWO*SUPERV
            WRITE(IW,6003)          SUPERK,      SUPERK
            WRITE(IW,6005)      TWO*SUPERJ,  TWO*SUPERJ
            WRITE(IW,6007)           ENUCS,       ENUCS
            IF(DFTYPE.NE.RNONE)
     *         WRITE(IW,6010)         ESUC,        ESUC
            WRITE(IW,6006)          ESUPER,      ESUPER
            IF((MPLEVL.EQ.2 .OR. CCTYP.EQ.CCSDT
     *         .OR. (CCTYP.EQ.CCSD) .AND. SCFTYPSV.NE.ROHF))
     *         WRITE(IW,6008)       ESUMP2,       ESUMP2
            IF(CCTYP.EQ.CCSD)
     *         WRITE(IW,6019)        ESUCC,        ESUCC
            IF(CCTYP.EQ.CCSDT)
     *         WRITE(IW,6009)        ESUCC,        ESUCC
         ELSE
            WRITE(IW,6001)       TWO*SUPERT
            WRITE(IW,6002)       TWO*SUPERV
            WRITE(IW,6003)           SUPERK
            WRITE(IW,6005)       TWO*SUPERJ
            WRITE(IW,6007)            ENUCS
            IF(DFTYPE.NE.RNONE)
     *         WRITE(IW,6010)          ESUC
            WRITE(IW,6006)           ESUPER
            IF((MPLEVL.EQ.2 .OR. CCTYP.EQ.CCSDT
     *         .OR. (CCTYP.EQ.CCSD) .AND. SCFTYPSV.NE.ROHF))
     *         WRITE(IW,6008)        ESUMP2
            IF(CCTYP.EQ.CCSD)
     *         WRITE(IW,6019)         ESUCC
            IF(CCTYP.EQ.CCSDT)
     *         WRITE(IW,6009)         ESUCC
         END IF
C
      END IF
C
C
C     - PRINT INTERACTION ENERGIES -
C
      IF (MASWRK) THEN
         WRITE(IW,8900)
C
C        - OWN BASIS -
         WRITE(IW,9100)
         WRITE(IW,9010) ESTM     ,      ESTM*TOKCAL
         WRITE(IW,9020) EEXM     ,      EEXM*TOKCAL
         WRITE(IW,9025) REPM     ,      REPM*TOKCAL
         WRITE(IW,9040) EPOLM    ,      EPOLM*TOKCAL
         IF(DFTYPE.NE.RNONE)
     *      WRITE(IW,9035) EDISPM   ,   EDISPM*TOKCAL
         IF((MPLEVL.EQ.2 .OR. CCTYP.EQ.CCSDT
     *      .OR. (CCTYP.EQ.CCSD) .AND. SCFTYPSV.NE.ROHF))
     *      WRITE(IW,9050) EMP2DISPM,   EMP2DISPM*TOKCAL
         IF(CCTYP.EQ.CCSD)
     *      WRITE(IW,9054) ECCDISPM ,   ECCDISPM*TOKCAL
         IF(CCTYP.EQ.CCSDT)
     *      WRITE(IW,9055) ECCDISPM ,   ECCDISPM*TOKCAL
         WRITE(IW,9058) EINTHFM  ,      EINTHFM*TOKCAL
         IF((MPLEVL.EQ.2 .OR. CCTYP.EQ.CCSDT
     *      .OR. (CCTYP.EQ.CCSD) .AND. SCFTYPSV.NE.ROHF))
     *      WRITE(IW,9060) EMP2INTM ,   EMP2INTM*TOKCAL
         IF(CCTYP.EQ.CCSD)
     *      WRITE(IW,9064) ECCINTM  ,   ECCINTM*TOKCAL
         IF(CCTYP.EQ.CCSDT)
     *      WRITE(IW,9065) ECCINTM  ,   ECCINTM*TOKCAL
         WRITE(IW,*) ' '
C
C        - ALL BASIS -
         IF(SUPBAS) THEN
         WRITE(IW,9200)
         WRITE(IW,9010) ESTA     ,      ESTA*TOKCAL
         WRITE(IW,9020) EEXA     ,      EEXA*TOKCAL
         WRITE(IW,9025) REPA     ,      REPA*TOKCAL
         WRITE(IW,9040) EPOLA    ,      EPOLA*TOKCAL
         IF(DFTYPE.NE.RNONE)
     *      WRITE(IW,9035) EDISPA   ,   EDISPA*TOKCAL
         IF((MPLEVL.EQ.2 .OR. CCTYP.EQ.CCSDT
     *      .OR. (CCTYP.EQ.CCSD) .AND. SCFTYPSV.NE.ROHF))
     *      WRITE(IW,9050) EMP2DISPA,   EMP2DISPA*TOKCAL
         IF(CCTYP.EQ.CCSD)
     *      WRITE(IW,9054) ECCDISPA ,   ECCDISPA*TOKCAL
         IF(CCTYP.EQ.CCSDT)
     *      WRITE(IW,9055) ECCDISPA ,   ECCDISPA*TOKCAL
         WRITE(IW,9058) EINTHFA  ,      EINTHFA*TOKCAL
         IF((MPLEVL.EQ.2 .OR. CCTYP.EQ.CCSDT
     *      .OR. (CCTYP.EQ.CCSD) .AND. SCFTYPSV.NE.ROHF))
     *      WRITE(IW,9060) EMP2INTA ,   EMP2INTA*TOKCAL
         IF(CCTYP.EQ.CCSD)
     *      WRITE(IW,9064) ECCINTA  ,   ECCINTA*TOKCAL
         IF(CCTYP.EQ.CCSDT)
     *      WRITE(IW,9065) ECCINTA  ,   ECCINTA*TOKCAL
         END IF
C
C     - IN SUPER MOL-
         WRITE(IW,9300)
         WRITE(IW,9010) ESTP     ,      ESTP*TOKCAL
         WRITE(IW,9020) EEXP     ,      EEXP*TOKCAL
         IF(DFTYPE.NE.RNONE)
     *      WRITE(IW,9035) EDISPP   ,   EDISPP*TOKCAL
         WRITE(IW,9058) EINTHFP  ,      EINTHFP*TOKCAL
      END IF
      IF(MASWRK) WRITE(IW,9070)
C
C
C     - NO MORE LMO -
      ILOCAL = 0
      SCFTYP = SCFTYPSV
      CALL TIMIT(1)
C
 1000 FORMAT(//10X,39(1H*)/
     *         10X,'*  LMO ENERGY DECOMPOSITION ANALYSIS  *'/
     *         10X,'*      - PEIFENG SU AND HUI LI -      *'/
     *         10X,39(1H*)//)
 2000 FORMAT(
     * /1X,71(1H=)
     * /1X,'LMOEDA PERFORMS THE FOLLOWING CALCULATIONS:'
     * /1X,'1. HF/DFT/MP2/CCSD/CCSD(T) FOR MONOMERS WITH'
     * /1X,'        MONOMERS OWN BASIS FUNCTIONS'
     * /1X,'        ALL BASIS FUNCTIONS (IF SUPBAS=.T.)'
     * /1X,'2. ELECTROSTATIC ENERGY WITH HF/DFT',
     *       ' DENSITY OF THE MONOMERS'
     * /1X,'3. EXCHANGE ENERGY WITH HF/DFT',
     *       ' MO OF THE MONOMERS'
     * /1X,'4. SUPER MOLECULE ENERGY WITH',
     *       ' ANTISYMMETRIZED HF/DFT MO OF THE MONOMERS'
     * /1X,'5. HF/DFT/MP2/CCSD/CCSD(T) FOR THE SUPER MOLECULE'
     * /1X,71(1H=))
 4000 FORMAT(1X,'LMOEDA WORKS ONLY FOR SCFTYP = RHF, ROHF AND UHF')
 5000 FORMAT(/10X,25(1H-)/10X,'MONOMER',I3,' WITH OWN BASIS'/
     *        10X,25(1H-))
 5010 FORMAT(/10X,25(1H-)/10X,'MONOMER',I3,' WITH ALL BASIS'/
     *        10X,25(1H-))
 5011 FORMAT(/10X,28(1H-)/10X,'MONOMER',I3,' IN SUPER MOLECULE'/
     *        10X,28(1H-))
 5012 FORMAT(/10X,45(1H-)/
     *        10X,'MONOMER ELECTROSTATIC INTERACTION (OWN BASIS)'/
     *        10X,45(1H-))
 5013 FORMAT(/10X,45(1H-)/
     *        10X,'MONOMER ELECTROSTATIC INTERACTION (ALL BASIS)'/
     *        10X,45(1H-))
 5014 FORMAT(/10X,50(1H-)/
     *        10X,'MONOMER EXCHANGE-REPULSION INTERACTION (OWN BASIS)'/
     *        10X,50(1H-))
 5015 FORMAT(/10X,50(1H-)/
     *        10X,'MONOMER EXCHANGE-REPULSION INTERACTION (ALL BASIS)'/
     *        10X,50(1H-))
 5020 FORMAT(/10X,14(1H-)/10X,'SUPER MOLECULE'/
     *        10X,14(1H-))
 5200 FORMAT(3X,I4,3X,F17.10,5X,F17.10)
 5100 FORMAT(/'ALPHA REARRANGEMENT'/
     *       /3X,50(1H-)/
     *        3X,'LMO(ALPHA)  T(KINETIC ENERGY)   V(POTENTIAL ENERGY)'
     *       /3X,50(1H-))
 5105 FORMAT(/'BETA REARRANGEMENT'/
     *       /1X,50(1H-)/
     *        1X,'LMO(BETA)   T(KINETIC ENERGY)   V(POTENTIAL ENERGY)'
     *       /1X,50(1H-))
 5300 FORMAT(/3X,36(1H-)/
     *        3X,'LMO         D(SELF-REPULSION ENERGY)'
     *       /3X,36(1H-))
 5310 FORMAT(2X,I4,9X,F17.10)
 5315 FORMAT(/3X,50(1H-)/
     *        3X,'LMO   LMO   J(COULOMB ENERGY)   K(EXCHANGE ENERGY)'
     *       /3X,50(1H-))
 5320 FORMAT(I6,I6,3X,F17.10,3X,F17.10)
 5600 FORMAT(/14X,'FROM OWN BASIS',6X,'FROM ALL BASIS',8X,
     *       'IN SUPER MOL')
 5610 FORMAT(/1X,'             FROM OWN BASIS      IN SUPER MOL')
 5690 FORMAT(/1X,14(1H-)/1X,'MONOMER ENERGY'/1X,14(1H-))
 5700 FORMAT(/1X,60(1H-)/1X,'SUPER MOLECULE ENERGY',
     *        1X,' USING NON-ANTISYMMETRIC WAVEFUNCTION'/
     *        1X,'(ELECTROSTATIC ENERGY: V J N CHANGE)'/1X,60(1H-))
 5710 FORMAT(/1X,70(1H-)/1X,'SUPER MOLECULE ENERGY',
     *        1X,' USING ANTISYMMETRIC NONORTHONORMAL WAVEFUNCTION'/
     *        1X,'(EXCHANGE ENERGY: ONLY X CHANGES)'/1X,70(1H-))
 5750 FORMAT(/1X,71(1H-)/1X,'SUPER MOLECULE ENERGY',
     *        1X,' USING ANTISYMMETRIC AND ORTHONORMAL WAVEFUNCTION'/
     *        1X,'(REPULSION ENERGY: T V X J CHANGE)'/
     *        1X,71(1H-))
 5760 FORMAT(/1X,45(1H-)/1X,'SUPER MOLECULE ENERGY',
     *        1X,' USING SCF WAVEFUNCTION'/
     *        1X,'(POLARIZATION ENERGY: T V X J CHANGE)'/1X,45(1H-))
 5800 FORMAT(/1X,'MONOMER',I5)
 5900 FORMAT(/2X,'                 OWN BASIS',
     *           '           ALL BASIS',
     *           '        IN SUPER MOL'/)
 5910 FORMAT(/2X,'                 OWN BASIS',
     *           '        IN SUPER MOL'/)
 6001 FORMAT(1X,'T',F26.8,F20.8,F20.8,F20.8,F20.8)
 6002 FORMAT(1X,'V',F26.8,F20.8,F20.8,F20.8,F20.8)
 6003 FORMAT(1X,'X',F26.8,F20.8,F20.8,F20.8,F20.8)
 6005 FORMAT(1X,'J',F26.8,F20.8,F20.8,F20.8,F20.8)
 6006 FORMAT(1X,'E',F26.8,F20.8,F20.8,F20.8,F20.8)
 6007 FORMAT(1X,'N',F26.8,F20.8,F20.8,F20.8,F20.8)
 6008 FORMAT(1X,'E(MP2)',F21.8,F20.8,F20.8,F20.8,F20.8)
 6019 FORMAT(1X,'CCSD   ',F20.8,F20.8,F20.8,F20.8,F20.8)
 6009 FORMAT(1X,'CCSD(T)',F20.8,F20.8,F20.8,F20.8,F20.8)
 6010 FORMAT(1X,'EC',F25.8,F20.8,F20.8,F20.8,F20.8)
 9000 FORMAT(/10X,36(1H-)/10X,'RESULTS OF LMO INTERACTION ANALYSIS'/
     *        10X,36(1H-))
 9001 FORMAT(/5X,'LMO ENERGY'
     *       /5X,'T   ELECTRON KINETIC ENERGY'
     *       /5X,'V   ELECTRON-NUCLEUS POTENTIAL ENERGY'
     *       /5X,'X   ELECTRON-ELECTRON EXCHANGE ENERGY'
     *       /5X,'J   ELECTRON-ELECTRON REPULSION ENERGY'
     *       /5X,'N   NUCLEUS-NUCLEUS REPULSION ENERGY')
 8900 FORMAT(//19X,31(1H*)/19X,'SUMMARY OF INTERACTION ENERGIES'/
     *                     19X,'   - PEIFENG SU AND HUI LI -   '/
     *         19X,31(1H*)/)
 9100 FORMAT(/1X,13(1H-)/
     *        1X,'OWN BASIS SET',39X,'HARTREE',10X,'KCAL/MOL'
     *       /1X,13(1H-))
 9010 FORMAT(1X,'ELECTROSTATIC ENERGY                  ES=',F18.6,F18.2)
 9020 FORMAT(1X,'EXCHANGE ENERGY                       EX=',F18.6,F18.2)
 9025 FORMAT(1X,'REPULSION ENERGY                     REP=',F18.6,F18.2)
 9035 FORMAT(1X,'DFT DISPERSION ENERGY               DISP=',F18.6,F18.2)
 9040 FORMAT(1X,'POLARIZATION ENERGY                  POL=',F18.6,F18.2)
 9050 FORMAT(1X,'MP2 DISPERSION ENERGY               DISP=',F18.6,F18.2)
 9054 FORMAT(1X,'CCSD DISPERSION ENERGY              DISP=',F18.6,F18.2)
 9055 FORMAT(1X,'CCSD(T) DISPERSION ENERGY           DISP=',F18.6,F18.2)
 9058 FORMAT(1X,'TOTAL INTERACTION ENERGY HF OR DFT     E=',F18.6,F18.2)
 9060 FORMAT(1X,'TOTAL INTERACTION ENERGY MP2           E=',F18.6,F18.2)
 9064 FORMAT(1X,'TOTAL INTERACTION ENERGY CCSD          E=',F18.6,F18.2)
 9065 FORMAT(1X,'TOTAL INTERACTION ENERGY CCSD(T)       E=',F18.6,F18.2)
 9070 FORMAT(/19X,31(1H*)/19X,'END OF LMO INTERACTION ANALYSIS'/
     *        19X,31(1H*)/)
 9160 FORMAT(/3X,40(1H-)/
     *       3X,'LMO(ALPHA) LMO(BETA)   J(COULOMB ENERGY)'
     *       /3X,40(1H-))
 9200 FORMAT(/1X,13(1H-)/
     *        1X,'ALL BASIS SET',39X,'HARTREE',10X,'KCAL/MOL'
     *       /1X,13(1H-))
 9300 FORMAT(/1X,37(1H-)/
     *        1X,'IN SUPER MOL (FOR SPECIAL COMPARISON)',
     *        15X,'HARTREE',10X,'KCAL/MOL'
     *       /1X,37(1H-))
      RETURN
      END
C*MODULE MOROKM  *DECK PRTTV
      SUBROUTINE PRTTV(TLMOA,VLMOA,TLMOB,VLMOB,NA,NB)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (NMO=500)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION TLMOA(NMO,NMO),VLMOA(NMO,NMO),
     *          TLMOB(NMO,NMO),VLMOB(NMO,NMO)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DATA RHF,UHF/8HRHF     ,8HUHF     /
      DATA TWO/2.0D+00/
C
      NMO2 = NMO*NMO
      CALL DAREAD(IDAF,IODA,TLMOA,NMO2,600,0)
      CALL DAREAD(IDAF,IODA,VLMOA,NMO2,601,0)
      IF(SCFTYP.EQ.UHF .AND. NB.GT.0) THEN
         CALL DAREAD(IDAF,IODA,TLMOB,NMO2,602,0)
         CALL DAREAD(IDAF,IODA,VLMOB,NMO2,603,0)
      END IF
      IF(MASWRK) THEN
         WRITE(IW,8105)
         DO I=1,NA
            IF(SCFTYP.EQ.RHF) THEN
               WRITE(IW,8100) I,TWO*TLMOA(I,I),TWO*VLMOA(I,I)
            ELSE
               WRITE(IW,8100) I,TLMOA(I,I),VLMOA(I,I)
            END IF
         ENDDO
         IF(SCFTYP.EQ.UHF .AND. NB.GT.0) THEN
            WRITE(IW,*) ' '
            WRITE(IW,8106)
            DO I=1,NB
               WRITE(IW,8100) I,TLMOB(I,I),VLMOB(I,I)
            ENDDO
            WRITE(IW,*) ' '
         END IF
      END IF
C
 8100 FORMAT(I6,9X,F17.10,3X,F17.10)
 8105 FORMAT(/3X,51(1H-)
     *       /3X,'LMO(ALPHA)   T(KINETIC ENERGY)  V(POTENTIAL ENERGY)'
     *       /3X,51(1H-))
 8106 FORMAT(/3X,51(1H-)
     *       /3X,'LMO(BETA)    T(KINETIC ENERGY)  V(POTENTIAL ENERGY)'
     *       /3X,51(1H-))
      RETURN
      END
C*MODULE MOROKM  *DECK PRTDJK
      SUBROUTINE PRTDJK(GJA,GKA,GDA,GJB,GKB,GDB,NA,NB)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (NMO=500)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION GJA(NMO,NMO),GKA(NMO,NMO),GDA(NMO),
     *          GJB(NMO,NMO),GKB(NMO,NMO),GDB(NMO)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DATA RHF,UHF/8HRHF     ,8HUHF     /
C
      PARAMETER (TWO=2.0D+00)
C
      NMO2 = NMO*NMO
      CALL DAREAD(IDAF,IODA,GJA  ,NMO2,604,0)
      CALL DAREAD(IDAF,IODA,GKA  ,NMO2,605,0)
      CALL DAREAD(IDAF,IODA,GDA  ,NMO ,606,0)
      IF(SCFTYP.EQ.UHF .AND. NB.GT.0) THEN
         CALL DAREAD(IDAF,IODA,GJB  ,NMO2,607,0)
         CALL DAREAD(IDAF,IODA,GKB  ,NMO2,608,0)
         CALL DAREAD(IDAF,IODA,GDB  ,NMO ,609,0)
      END IF
      IF(MASWRK) THEN
         WRITE(IW,*) ' '
         IF(NA.GT.1) THEN
            WRITE(IW,6050)
            DO I=1,NA
               WRITE(IW,6100) I,GDA(I)
            ENDDO
         END IF
         IF(NA.GT.1) WRITE(IW,6150)
         DO I=1,NA
           DO J=1,NA
              IF(I.NE.J) THEN
                IF(SCFTYP.EQ.RHF) THEN
                 WRITE(IW,6200)I,J,TWO*GJA(I,J),-GKA(I,J)
                ELSE
                 WRITE(IW,6200)I,J,GJA(I,J),-GKA(I,J)
                ENDIF
              END IF
           ENDDO
           WRITE(IW,*) ' '
         ENDDO
         IF(SCFTYP.EQ.UHF .AND. NB.GT.0) THEN
            IF(NB.GT.1) THEN
               WRITE(IW,6050)
               DO I=1,NB
                  WRITE(IW,6100) I,GDB(I)
               ENDDO
            END IF
            IF(NB.GT.1) WRITE(IW,6150)
            DO I=1,NB
              DO J=1,NB
                 IF(I.NE.J) THEN
                    WRITE(IW,6200)I,J,GJB(I,J),-GKB(I,J)
                 END IF
              ENDDO
              WRITE(IW,*) ' '
            ENDDO
         END IF
      END IF
C
 6050 FORMAT(/3X,36(1H-)
     *       /3X,'LMO         D(SELF-REPULSION ENERGY)'
     *       /3X,36(1H-))
 6100 FORMAT(I6,9X,F17.10)
 6150 FORMAT(/3X,50(1H-)
     *       /3X,'LMO   LMO   J(COULOMB ENERGY)   K(EXCHANGE ENERGY)'
     *       /3X,50(1H-))
 6200 FORMAT(I6,I6,3X,F17.10,3X,F17.10)
      RETURN
      END
