C 21 May 13 - HN,TN,DGF - changes for FMO 5.0 
C 31 Jul 12 - DGF - patch for initial dimer MOs with ISPHER=1
C 24 Jul 12 - HN,DGF - code update to finish FMO 4.3
C 21 JUN 12 - DGF - CHANGES FOR FMO 4.3
C 23 MAR 12 - DGF,CHC - code update to finish FMO 4.2
C 28 DEC 11 - TN  - changes for FMO 4.2
C 15 Apr 11 - TN  - misc changes for FMO 4.1
C 11 Aug 10 - TN  - CHANGES FOR FMO 4.0 
C 23 JUN 10 - RP  - DELETE SOME PREVIOUSLY COMMENTED OUT COSMO COMMONS
C 10 MAY 10 - MWS - ADD NEW ARGUMENT TO SETCONI
C 14 OCT 09 - DGF - CHANGES FOR FMO 3.3
C 15 DEC 08 - TN  - VARIOUS CHANGES FOR FMO 3.2 RELEASE
C 20 AUG 07 - TN  - INCLUDE MODULE FOR ELECTROSTATIC DERIVATIVE TERMS
C
C*MODULE FMOESD  *DECK FMOESDER
C>
C>     @brief ESP derivatives. 
C>
C>     @details Calculate electrostatic potential (ESP) derivatives. 
C>
C>     @author Takeshi Nagata 
C>
      SUBROUTINE FMOESDER(L1,L2,DA,LAYFRG,SCFFRG,IDMREC0,DC,WRK1,
     *                    MAPI,MAPJ,MAP3,MAXL1D,IREC00,IDAX,IDAXX,
     *                    ORBXCH1,ENEXCH1,KODEXCH,JODEXCH,IODEXCH,
     *                    ZVLAG,IPTLG,NQMTFG,loadhf,clm,flm,crfrg,
     *                    Ylmfrgq,Ylmfrgq2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=2000,MXSH=5000,MXGTOT=20000,MXAO=8192,MXGSH=30,
     *           MXG2=MXGSH*MXGSH,MXRT=100,MAXL=5,one=1.0D+00,
     *           HALF=0.5D+00,ZERO=0.0D+00,MaxNp=45)
      LOGICAL DIRSCF,FDIFF,DIRSAV,SCHWRZ,PACK2E,GOPARR,DSKWRK,MASWRK,
     *        OUT,SOME,BSSEDIM,ORBXCH,SAVGOP,ESPPAR,NXT,ESPAP,DODDCOR,
     *        ESDDER,LARGEPRI,LCFLAG,LRINT,LCFLAGS,LRINTS,CAMFLAG,
     *        CAMFLAGs,ESDER
      LOGICAL ORBXCH1,ENEXCH1,KODEXCH,JODEXCH,IODEXCH
      LOGICAL DOSCZV, DODISTR,QOPS,QFMM
      complex*16 Ylmfrgq(((NP+1)*(NP+2))/2,nfg)
      complex*16 Ylmfrgq2(((NP+1)*(NP+2))/2,nfg)
C
      DIMENSION DA(*),LAYFRG(*),SCFFRG(*),IDMREC0(*),KARTEN(0:MAXL-1)
      DIMENSION DC(*),WRK1(*),MAPI(*),MAPJ(*),MAP3(MAXL1D,3)
      DIMENSION ZVLAG(*),IPTLG(*),NQMTFG(*),crfrg(4,ncentm,nfg),
     *          CLM(-maxNP:maxNP),FLM(-maxNP:maxNP)
C
      COMMON /DFTCAM/ ALPHAC,BETAC,CAMMU,CAMVWN,CAMLYP,CAMFLAG
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FMCOM / X(1)
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
C     COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NLRC  / LCFLAG,LRINT,EMU,EMU2,LRFILE
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /QMFM  / SIZE,EPS1,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /SHLEXC/ NORGSH(3),NORGSP(3),IEXCH,NANGM,NGTH(4)
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo
      common /ppcpnt/ lddijpot,lzppcpot,lvipot,lgrdtest
      COMMON /SCZLAG/ LZVLAG,LZVWRK,LYALAG,LYAWRK
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      COMMON /GRAD  / DE(3,MXATM)
C
      DATA KARTEN/1,4,6,10,15/ 
      DATA RHF/8HRHF     /,RMC/8HMCSCF   /
     *     DBGFMO/8HDBGFMO  /,DBGME/8HFMOESP  /,DEBUG/8HDEBUG   /,
     *     UHF/8HUHF     /
C 
C     THIS ROUTINE COMPUTES THE ELECTROSTATIC POTENTIAL DERIVATIVES.
C     IN THE CURRENT VERSION, 
C     THIS ROUTINE CALCULATES DIMER AND TRIMER DERIVATIVES AT HF LEVEL
C     AND COMPUTES MP2 TERMS OF MONOMERS.
C
C     PARSTAT: GROUPFULL/GROUPNONE 
C
C     FOR NBSSE=3 MONOMERS AND DIMERS DURING BSSE RUNS ARE IN VACCUUM
      IF(NBSSE.EQ.3.AND.IFMOSTP.EQ.5. OR. IFMOSTP.EQ.1) RETURN
c       IF(MASWRK) WRITE(IW,*) 'ENTER FMOESD'
        CALL TIMIT(1)
C
C     THIS ROUTINE MUST BE CALLED EITHER IN MONOSCF, EDIMER OR ETRIMER
C
      IF (IFMOSTP.EQ.6) THEN
        WRITE (IW,*) 'IFMOSTP=6 IS NOT ALLOWED IN FMOESDER'
        CALL ABRT
      END IF
      IF (IFMOSTP.NE.2.AND.IFMOSTP.NE.4.AND.IFMOSTP.NE.9) RETURN
C     IF (MASWRK) WRITE (6,*) 'NOW INSIDE OF FMOESDER'
C
      SOME=(EXETYP.EQ.DEBUG.OR.EXETYP.EQ.DBGFMO.OR.EXETYP.EQ.DBGME).AND.
     *     MASWRK
      ORBXCH=MOD(MODORB,2).NE.0
C     ENEXCH=MOD(MODORB/2,2).NE.0
      ESPPAR=MOD(MODPAR/2,2).NE.0.AND.GOPARR
C     .TRUE.  DIVIDE FRAGMENTS
C     .FALSE. DIVIDE SHELLS
CZCZ
      DODISTR = IAND(MODPAR,512).NE.0
CZCZ
      LWRKDEN =LFMOBUF(1) ! MAXL1D+MAXL2D+MAXL3D
      LWRKESP =LFMOBUF(2) ! MAXL2D
      LWRKESP2=LFMODB
C     FOR MONOMER SCF THERE IS NO NEED TO ADJUST IREC0 BELOW (AND MPPROP MAY 
C     NOT HAVE BEEN READ ANYWAY). 
      ILAY=ICURLAY
      IFG=ICURFG
      IF(IFG.EQ.0) RETURN
C
      LCFLAGS=LCFLAG
      camFLAGS=camFLAG
      LRINTS=LRINT
      LCFLAG=.FALSE.
      camFLAG=.FALSE.
      LRINT=.FALSE.
C
C     ESP IS NOT NEEDED. THIS HAPPENS WHEN MONOMER/DIMER SCF ITERATIONS RUN.
C     (ESP IS COMPUTED BEFORE SUCH ITERATIONS ALONG WITH 1-EL INTEGRALS)
C
      CALL DERCHK(NDER)
C 
C     IESDPPC=1 AVOIDS ADDITION OF FMO/PCM REDUNDANT GRADIENTS IN SUBROUTINE FMODEG
C 
      IESDPPC = 1
C
      ESDER = NDER.GT.0.AND.IAND(MODGRD,2).NE.0
      IF (.NOT.ESDER) THEN
        WRITE(IW,*) 'MUST DEBUG FOR ESDER'
        CALL ABRT
      END IF
CZ    ESDDER=IFMOSTP.EQ.6.AND.RESDIM.NE.0.AND.IAND(IXESP,32).EQ.0.AND.
CZ   *       NDER.GT.0
      ESDDER=.TRUE.
CZCZ
      DOSCZV = NDER.GT.0.AND.IAND(MODGRD,32).NE.0
CZCZ
CZ
CZ    (1). DENSITY DERIVATIVES OF ESPS
CZ        NOTE THAT OUTPUT DA IS DI, DELTA DIJ OR DELTA DIJK
CZ
      CALL ESDNSDER(IDAX,IDAXX,L1,L2,DA,X(LFMODB),DC,X(LWRKDEN),WRK1,
     *     X(LFMOESPA),X(LWRKESP),X(LNUMFRG),MAPI,MAPJ,MAP3,
     *     MAXL1D,IREC00,ORBXCH1,ENEXCH1,
     *     KODEXCH,JODEXCH,IODEXCH,NQMTFG,scffrg)
c       IF(MASWRK) WRITE(IW,*) 'Done ESDNSDER'
c       CALL TIMIT(1)
CZ
CZ    IF (MASWRK) WRITE (6,*) 'AFTER DENSITY MATRIX',L1
CZ    CALL PRTRI(DA,L1)
CZ
      JFG  = JCURFG
      LFG  = KCURFG
      KFG0 = 1
      KFG1 = NFG
      IZ   = 1
CZ    KFACT=1
CZ
      RESPAPI=RESPAP(IZ)
      RESPPCI=RESPPC(IZ)
      BSSEDIM=NBSSE.EQ.2.AND.IFMOSTP.EQ.5
      IF(BSSEDIM) JFG=0
      ! FOR MONOMER; DODDCOR=F, FOR DIMER; T
      DODDCOR=IAND(IXESP,1024).NE.0
C
C     SCHWRZ = ISCHWZ.GT.0
      SCHWRZ = .TRUE. 
C     DO NOT THINK THAT YOU CAN SET SCHWRZ TO .FALSE. AND GET AWAY WITH IT.
C     SCHWRZ ALSO FORCES INTEGRAL INITIALISATION THAT WILL OTHERWISE NOT BE 
C     DONE.
C 
      DIRSAV=DIRSCF
      DIRSCF=.TRUE.
C     SCFTYP1=SCFTYP
C     IF(SCFTYP.EQ.RMC) SCFTYP1=RHF
      SCFTYP1=RHF
      OUT=SCHWRZ.AND.MASWRK.AND.IAND(NPRFMO,3).EQ.0
C
      CALL VCLR(X(LFMOESPA),1,L2)
CB    CALL VCLR(X(LFMOESPB),1,L2)
C
C     SAVE THE PRISTINE MONOMER(DIMER) CONFIGURATION
C
      CALL MONBSR(NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,NSHELL,NGAU,ENUCR,
     *            NAT0,ICH0,MUL0,NUM0,NQMT0,NE0,NA0,NB0,
     *            NCURSH,NGAU0,ENUCR0)
C
C     FIX THE NUMBER OF ELECTRONS TO AVOID DOUBLE COUNTING:
C     EXCLUDE CHARGE AS OTHERWISE THE CHARGE OF FRAGMENT I WILL BE ADDED
C     TO NE FIRST HERE AND THEN AGAIN IN MAKMOL BELOW.
C     AT PRESENT NE IS ACTUALLY NOT IMPORTANT BECAUSE NUMFRG HAS NA.
      NE0C=NE0+ICH0
C
      NPRSAV=NPRFMO
      IF(NPRINT.EQ.-5.AND.IAND(NPRFMO,3).EQ.0) NPRFMO=NPRFMO+1
C     THAT IS, ENFORCE REDUCED OUTPUT IF NPRINT.EQ.-5
C     FOR ESPS THE ONLY MEANINGFUL USAGE OF LOADM IS WITH TRUE ESPPAR.
C     LOADM SHOULD ONLY BE USED IF FULL RANGE OF FRAGMENTS IS TREATED
C     (THAT IS, EXCLUDING SEPARATED DIMERS).
      LOADHF=MOD(MODPAR,2)
      LARGEPRI=LOADHF.EQ.1.AND.ESPPAR.AND.KFG0.EQ.1.AND.KFG1.EQ.NFG
C     WRITE(6,*) 'WWWLB',LARGEPRI
CZ
      NATF1 = NATFMO*3
      NATF2 = NATF1 + NATF1
      IF (IFMOSTP.EQ.2.AND.MPLEVL.EQ.2) THEN
        ! JUST FOR MP2 CORRECTION IN THIS VER.
        LFDE2B = LFMODE + NATF1
        LFDE3B = LFDE2B
        IF (NBODY.GT.2) LFDE3B = LFMODE + NATF2
      ELSEIF (IFMOSTP.EQ.4) THEN
        LFDE2B = LFMODE + NATF1
        LFDE3B = LFDE2B
        IF (NBODY.GT.2) LFDE3B = LFMODE + NATF2
      ELSEIF (IFMOSTP.EQ.9) THEN
        LFDE2B = LFMODE + NATF2
        LFDE3B = LFDE2B
      END IF
c
      if(iand(modfmm,8).ne.0) then
        if(lfg.ne.0) call abrt
        call mmespg(ilay,ifg,jfg,loadhf,x(LLOADM),layfrg,
     *                  da,ncentm,clm,flm,crfrg,Ylmfrgq,Ylmfrgq2)
c       CALL EGOUT(DE,NAT)
c       Use DE computed in mmespg. 
        ifmostps=ifmostp 
        ifmostp=6
        CALL FMODEG(IDAX,X(LFDE2B),X(LFMOPG),X(LIAGLOB))
c       add the same for trimers
        ifmostp=ifmostps
      endif
CZ
CZ    (2). BASIS FUNCTION DERIVATIVES OF 1E INTEGRALS
CZ    DA IS OBTAINED IN ESDNSDER
CZ    THE CONTRIBUTIONS ARE DIRECTLY STORED IN FMODE().
CZ
      if(iand(modfmm,8).ne.0) modfmm=ior(modfmm,1024)
c     call dcopy(3*12,X(LFDE2B),1,detmp,1) 
      CALL ESVDER(IDAX,IDAXX,DA,X(LWRKDEN),X(LWRKESP),L2,0,
     *            X(LFDE2B),X(LFDE3B),.FALSE.)
      if(iand(modfmm,8).ne.0) modfmm=modfmm-1024
c     call vsub(detmp,1,X(LFDE2B),1,detmp,1,3*12)
c     write(6,*) 'AO derivatives'
c     CALL EGOUT(DEtmp,12)
c       IF(MASWRK) WRITE(IW,*) 'Done ESVDER'
c       CALL TIMIT(1)
CZ
CZ
CZ    (3). HELMANN-FEYNMAN TERMS
CZ
czcz
cz    if (maswrk) then
cz      write(6,*) 'Mulliken pop in ', ifmostp
cz      write(6,'(3F12.8)')
cz   *  (x(lpopmat+maxnat*nfg*(icurpop-1)+i1),i1=0,80) 
cz    end if
czcz
      if(iand(modfmm,8).ne.0) modfmm=ior(modfmm,1024)
c     call dcopy(3*9,X(LFDE2B),1,detmp,1) 
      CALL EXTHELFEY(IDAX,IDAXX,DA,X(LWRKDEN),L2,X(LFDE2B),X(LFDE3B),
     *              .FALSE.)
      if(iand(modfmm,8).ne.0) modfmm=modfmm-1024
c     call vsub(detmp,1,X(LFDE2B),1,detmp,1,3*9)
c     write(6,*) 'Hellmann-Feynman'
c     CALL EGOUT(DEtmp,9)
c       IF(MASWRK) WRITE(IW,*) 'Done EXTHELFEY'
c       CALL TIMIT(1)

CZ
CZ    (4). DERIVATIVES OF MULLIKEN CHARGES IN ESPPC 
CZ
      IF (NDER.GT.0.AND.IAND(MODGRD,8).NE.0.AND.RESPPCI.NE.ZERO) THEN
        if (ifmostp.eq.2.and.mplevl.eq.2) then
          if (nbody.eq.2)call getddijpot(idax, 0,DA,L2,X(LDDIJPOT))
          if (nbody.eq.3)call getddijpot(idaxx,0,DA,L2,X(LDDIJPOT))
        elseif (ifmostp.eq.4) then
          if (nbody.eq.2)call getddijpot(idax, 0,DA,L2,X(LDDIJPOT))
          if (nbody.eq.3)call getddijpot(idaxx,0,DA,L2,X(LDDIJPOT))
        elseif (ifmostp.eq.9) then
          call getddijpot(idax,0,DA,L2,X(LDDIJPOT))
        end if
      END IF
c       IF(MASWRK) WRITE(IW,*) 'Done Mul der'
c       CALL TIMIT(1)
CZ
C
C     ----- INITIALIZATION FOR PARALLEL WORK -----
C
      NXT = IBTYP.EQ.1
      NEXT  = -1
      KOUNT = -1
C
C     ESP WILL BE COMPUTED IN THE DIRECT FASHION
C
C     DO 100 KFG=1,NFG
      DO 100 KKFG=KFG0,KFG1
        IF(LARGEPRI) THEN
          KFG=IXFTCH(X(LLOADM),KKFG)
        ELSE
          KFG=KKFG
        ENDIF
        IF(IFG.EQ.KFG.OR.JFG.EQ.KFG.OR.LFG.EQ.KFG) GOTO 100
C
        IF(RESPPCI.NE.ZERO.OR.RESPAPI.NE.ZERO.OR.RESDIM.NE.ZERO) THEN
          RK=FMODIST(IFG,JFG,LFG,KFG)
C         THE DISTANCE WILL BE REFINED LATER FOR SMARTR. 
C         WRITE(6,*) 'DISTANCE IS',KFG,RK,RESPPCI
CZCZ      IF(IZ.EQ.1.AND.RK.GT.RESPPCI.AND.RESPPCI.NE.ZERO) GOTO 100
          IF(RK.GT.RESPPCI.AND.RESPPCI.NE.ZERO) GOTO 100
CZ
C
         IF(IFMOSTP.EQ.2.AND.IAND(IXESP,4096).NE.0.AND.RK.NE.0) GOTO 100
C
          ESPAP=RK.GT.RESPAPI.AND.RESPAPI.NE.ZERO
        ELSE
          ESPAP=.FALSE.
        ENDIF
C
        IF(ESPPAR) THEN
          KOUNT=KOUNT+1
          IF(GOPARR) THEN
            IF(NXT) THEN
              IF(KOUNT.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
              IF(NEXT.NE.KOUNT) GOTO 100
            ELSE
              IF(MOD(KOUNT,NPROC).NE.ME) GOTO 100
            ENDIF
          ENDIF
          SAVGOP=GOPARR
          GOPARR=.FALSE.
C         GOPARR IS SET TO .FALSE. TO PREVENT SHELL-BASED WORK DIVISION
C         INSIDE OF EXCHNG AND FMOESP. 
C         NOTE THAT SHELL-BASED WORK DIVISION IS USED FOR ESPPAR=.FALSE. 
        ENDIF
        KLAY=MIN(ILAY,LAYFRG(KFG))
C       BSSEDIM=NBSSE.EQ.2.AND.IFMOSTP.EQ.5.AND.KFG.EQ.JCURFG
        BSSEDIM=NBSSE.EQ.2.AND.IFMOSTP.EQ.5
        IF(SOME) WRITE(6,*) 'COMPUTING ESD DUE TO FRG',KFG,' LAYER',KLAY
C
C       ADD MONOMER KFG AND READ ITS DENSITY (NOW ONLY ALPHA)
C
        KFGX = KFG
        CALL MAKEMOL(KFGX,0,0,KLAY,0,NAT0,NCURSH,NGAU0,NE0C,ICH0,MUL0,
     *               .FALSE.)
        L1K=NUM-NUM0
        L2K=(L1K*L1K+L1K)/2
        L3K=L1K*L1K 
CZCZ
        IF (DOSCZV) THEN
CZCZ      NQK  = NQMT - NQMT0
          NQK  = IAND(NQMTFG(KFG),65535) 
          NAK  = ISHFT(IXFTCH(X(LNUMFRG),KFG),-16) 
          NOCK = NAK
          NVRK = NQK - NOCK
          if(scffrg(kfg).eq.uhf) then
            MULK=IXFTCH(X(LMULFG),KFG)
            NBK=NAK-MULK+1
            NOCKB = NBK
            NVRKB = NQK - NOCKB
          end if
        END IF
CZCZ
C
        IREC0=IDMREC0(KLAY)
C       HACK IT UP TO POINT TO RHF DENSITIES FOR RUNS WITH MP2 DENSITIES. 
        IF(DODDCOR) THEN
          IREC0RHF=1
          IF(IREC0.EQ.1) IREC0RHF=NFG*2+1
          IREC0=IREC0RHF
        ENDIF
        IDMREC0K=KFG+IREC0
        IF(.NOT.ESPAP) THEN
          NAK=ISHFT(IXFTCH(X(LNUMFRG),KFG),-16) 
          MULK=IXFTCH(X(LMULFG),KFG)
          NBK=NAK-MULK+1
C         IF(ORBXCH) THEN 
C           IF(SCFFRG(KFG).EQ.RMC) THEN
C            CALL RAREADS(IDAFMO,X(LIODFMO),X(LWRKDEN),L2K+L3K,IDMREC0K,0)
C           ELSE
C            CALL RAREADS(IDAFMO,X(LIODFMO),X(LWRKDEN+L2K),L3K,IDMREC0K,0)
C             CALL DMTX2(X(LWRKDEN),X(LWRKDEN+L2K),NAK,L1K,L1K) 
C           ENDIF
C         ELSE
C           CALL RAREADS(IDAFMO,X(LIODFMO),X(LWRKDEN),L2K,IDMREC0K,0)
C         ENDIF
CZCZ      HOW FORTUNATE LWRKESP2+L2K IS EMPTY THOROUGHOUT
          ! I EXPLOIT THIS FOR RESPONSE CALCULATION
          ! GET MO CO MATRIX AND ORBITAL ENERGY
          IF (IAND(MODGRD,32).EQ.0.or.scffrg(kfg).eq.UHF) THEN
            CALL READMOND(X(LWRKDEN),ORBXCH,SCFFRG(KFG).EQ.RMC,
     *                    NAK,NBK,L1K,X(LIODFMO),IDMREC0K,
     *                    scffrg(kfg).eq.uhf)
            CALL DCOPY(L3K+L1K,X(LWRKDEN+L2K),1,X(LWRKESP2+L2K),1)
          ELSE
            ! MO COEF. AND ORBITAL ENERGIES
            CALL RAREADS(IDAFMO,X(LIODFMO),X(LWRKDEN+L2K),L3K+L1K,
     *                   IDMREC0K,0)
            CALL DMTX2(X(LWRKDEN),X(LWRKDEN+L2K),NAK,L1K,L1K,NAK) 
            CALL DCOPY(L3K+L1K,X(LWRKDEN+L2K),1,X(LWRKESP2+L2K),1)
          END IF
CZ        IF (MASWRK) WRITE(6,*) 'DENSITY MATRIX FOR ', KFG
CZ        CALL PRTRI(X(LWRKDEN),L1K)
CZCZ
C         GOTO 100
C         WRITE(6,*) 'ORIGINAL DENSITY',KFG,L1K,NAK
C         CALL PRTRI(X(LFMODA),L1K)
C         CALL SEQOPN(38,'HESSIAN','UNKNOWN',.FALSE.,'UNFORMATTED')
C         WRITE(38) (X(LFMODA+I-1),I=1,L2K)
C         CALL SEQCLO(38,'KEEP')
C         READ BETA DENSITY
        ENDIF
C
C       ARRAY SIZES ARE DIFFERENT FOR EACH FRAGMENT. 
C
        NSH2 = (NSHELL*NSHELL+NSHELL)/2
        CALL BASCHK(LMAX)
        IF(LMAX.GE.5) THEN
           IF(MASWRK) WRITE(IW,*) 'FMO HAS NOT BEEN REVIEWED FOR H,I'
           CALL ABRT
        END IF
C       FOR SOME REASON GAMESS LIKES TO HANDLE AT LEAST L-SHELLS
        NANGM=KARTEN(MAX(LMAX,1))
        MAXG = NANGM**4
        CALL VALFM(LOADFM)
C
        LXINTS= LOADFM + 1
        LGHOND= LXINTS + NSH2
        LDSH  = LGHOND + MAXG
        LDSHB = LDSH   + NSH2
        LDDIJ = LDSHB  + NSH2
        LAST  = LDDIJ  + 49*MXG2
        NEED  = LAST- LOADFM -1
        CALL GETFM(NEED)
C
        LDENP=LPOPMUL+((ICURPOP-1)*NFG+KFG-1)*MAXL1
        IF(ESPAP) THEN
          LDENA=LDENP
          LDENB=LDENA
        ELSE
CZCZ      LDENA=LFMODA 
          LDENA=LWRKDEN 
          LDENB=LFMODB 
        ENDIF 
C
C       CALL ERIPRE
C       THERE IS NO NEED TO CALL ERIPRE HERE. FMO CODE ALWAYS CALLS EXCHNG
C       (BECAUSE SCHWRZ IS FORCED TRUE), AHD THIS IS WHERE INITIALISATION
C       FOR EACH (N+1)-MER IS DONE. NOTE THAT THIS INITIALISATION IS 
C       IMPORTANT NOW: IT SETS ARRAYS FOR SCREENING AND SOME OTHER THINGS. 
C
C       CREATE DENSITY MATRIX FOR SHELL INDICES
C
        IF(SCHWRZ) THEN
          DUMMY = 0.0D+00
CNB       FOR GRADIENTS, WHAT SHOULD BE SCFTYP??
C         L1 AND L2K SEEM TO BE THE RIGHT CHOICE:
C         L1 IS USED TO SKIP L1 AOS TO GET TO THE EXTERNAL MONOMER SHELL
C         L2K GIVES THE SIZE OF GVB DENSITY MATRICES FOR THE EXTERNAL MONOMER
C         WRITE(6,*) 'ORIGINAL DENSITY',KFG,L1K
C         CALL PRTRI(X(LFMODA),L1K)
          IF(ESPAP) THEN
C           WRITE(6,*) 'MULLIKENS'
C           CALL PRSQ(X(LDENA),L1K,1,1)
           CALL SHLDEND(SCFTYP1,X(LDENA),X(LDENB),DUMMY,X(LDSH),L1,1)
C          WRITE(6,*) 'CONTRACTED L-DENSITY',KFG,NSHELL-NCURSH
C           CALL PRSQ(X(LDSH),NSHELL-NCURSH,1,1)
          ELSE
            CALL SHLDEN(SCFTYP1,X(LDENA),X(LDENB),DUMMY,X(LDSH),IA,
     *                  L1,L2K,NSH2,1)
            IF(ESDDER) THEN
C            REMOVE ALL EVIDENCE OF FRAGMENT 2 BEING INVOLVED. 
C            KEEP ONLY FRAGMENT 1 INFORMATION AND OBTAIN ITS SHELL DENSITY. 
C            L1 ARGUMENT IS UNUSED BELOW.
             NSHSAV=NSHELL
             NSHELL=NCURSH
             NCURSH=0
CZCZ        CALL SHLDEN(SCFTYP1,X(LWRKDEN),X(LDENB),DUMMY,X(LDSHB),IA,
CZCZ *                  L1,L2K,NSH2,1)
            CALL SHLDEN(SCFTYP1,DA,X(LDENB),DUMMY,X(LDSHB),IA,
     *                  L1,L2,NSH2,1)
             NCURSH=NSHELL
             NSHELL=NSHSAV
            ENDIF
C         WRITE(6,*) 'CONTRACTED DENSITY',KFG,NSHELL-NCURSH
C         CALL PRTRI(X(LDSH),NSHELL-NCURSH)
          ENDIF
        END IF
C
C       INITIALISE TWO-ELECTRON INTEGRALS
C       POPLE INTEGRALS USE A SEPARATE COORDINATE COMMON BLOCK INITIALISED
C       ABOVE, ETC. ?ST MUST BE RESET SO THAT NO PHONEY RESTART IS DONE.
C
        IST=1
        JST=1
        KST=1
        LST=1
        CALL JANDK
C
C     ----- EXCHANGE INTEGRALS FOR DIRECT SCF THRESHOLD TESTS -----
C       COMPUTED FOR THE COMBINED SYSTEM, NO NEED TO ADJUST INDICES.
C
        NINT=0
        NSCHWZ=0
CNB5    EXCHNG CAN BE ADJUSTED TO TAKE ADVANTAGE OF THE REDUCED BASIS WITH BSSE.
C       GOTO 100
C       DO IOHNO=1,1000
        IF(SCHWRZ) CALL EXCHNG(X(LXINTS),X(LGHOND),X(LDDIJ),
     *                         NSH2,MAXG,INTTYP)
C       ENDDO
C       COMPUTE 2-EL INTEGRALS CORRESPONDING TO PLACING THE ORIGINAL 
C       MONOMER(DIMER) INTO THE COULOMB FIELD OF MONOMER KFG.
C 
C       GOTO 100
CZZ     IF(ESDDER) CALL VCLR(X(LWRKESP2),1,L2K)
        CALL VCLR(X(LWRKESP2),1,L2K)
CZ
C       CALL TIMIT(1)
C       DO IOHNO=1,100
CZ
CZ      WHAT I WANT IS NOT X(LFMOESPA), BUT X(LWRKESP2).
CZ
        CALL FMO2EI(SCHWRZ,NINT,NSCHWZ,NSCHWZB,NSCHWNZB,L1,L2,X(LXINTS),
     *              NSH2,X(LGHOND),MAXG,IA,LDENA,LDENP,X(LFMOESPA),
     *              DA,X(LWRKESP2),X(LDSH),X(LDSHB),X(LIAGLOB),
     *              X(LINDAT),X(LINDATG),BSSEDIM,RESPAPI,RESPPCI,ESPAP,
     *              ESDDER,ESDER,IFG,JFG,LFG,KFG,0)
CZCZ *              ESDDER,IFG,JFG,LFG,KFG)
C       ENDDO
C       CALL TIMIT(1)
        IF(OUT) THEN
          IF(NSCHWZB.EQ.0) THEN
            WRITE(IW,9000) KFG,NINT,NSCHWZ
          ELSE
            WRITE(IW,9005) KFG,NINT,NSCHWZ,NSCHWZB
          ENDIF
        ENDIF
C         WRITE(IW,*) 'NON-ZERO SUPERBLOCKS',NSCHWNZB,NSH2
C
C       WRITE(6,*) 'DENSITY IN ESP IS'
C       CALL PRTRIL(X(LFMODA),NUM0)
CZ
CZ      ADDED BY NAGATA 3/27/07
CZ
CZCZCZ  IF(SCHWRZ) CALL DAWRIT(IDAF,IODA,X(LXINTS),NSH2,54,0)
        IF(SCHWRZ) LFMOBUF(3) = LXINTS
CZ
CZCZCZ  CALL RETFM(NEED)
C
        IF(ESPPAR) GOPARR=SAVGOP
        CALL DSCAL(L2K,HALF,X(LWRKESP2),1)
        II=LWRKESP2-1
        DO I=1,L1K
          II = II+I
          X(II) = X(II) + X(II)
        ENDDO
        IF(GOPARR) CALL DDI_GSUMF(2418,X(LWRKESP2),L2K)
CZ
CZ
CZ      ZVLAG IS THE LAGRANGIAN MATRIX
CZ      IT IS SUMMED LATER (AFTER THE DIMER LOOP)
CZ
        IF (DOSCZV) THEN
          if(scffrg(kfg).eq.rhf) then
            CALL CPYTSQ(X(LWRKESP2),X(LWRKDEN+L2K),L1K,1)
            CALL SWBASIS(1,L1K,NOCK,NVRK,X(LWRKESP2+L2K),
     *                 X(LWRKDEN+L2K),L1K,X(LZVWRK),NVRK,DA(L2+1))
          else if(scffrg(kfg).eq.uhf) then
            CALL CPYTSQ(X(LWRKESP2),X(LWRKDEN+L2K),L1K,1)
            CALL SWBASIS(1,L1K,NOCK,NVRK,X(LWRKESP2+L2K),
     *                 X(LWRKDEN+L2K),L1K,X(LZVWRK),NVRK,DA(L2+1))
            CALL READMOND(X(LWRKDEN),ORBXCH,SCFFRG(KFG).EQ.RMC,
     *                    NAK,NBK,L1K,X(LIODFMO),IDMREC0K,
     *                    scffrg(kfg).eq.uhf)
            CALL DCOPY(L3K,X(LWRKDEN+L2K+L3K),1,X(LWRKESP2+L2K),1)
            CALL DCOPY(L1K,X(LWRKDEN+L2K+L3K*2+L1K),1,
     *                 X(LWRKESP2+L2K+L3K),1)
            CALL CPYTSQ(X(LWRKESP2),X(LWRKDEN+L2K),L1K,1)
            CALL SWBASIS(1,L1K,NOCKB,NVRKB,X(LWRKESP2+L2K),
     *                   X(LWRKDEN+L2K),L1K,X(LZVWRK+NOCK*NVRK),
     *                   NVRKB,DA(L2+1))
          end if
          NOCVRK = NOCK*NVRK
          IF (IFMOSTP.EQ.2.AND.MPLEVL.EQ.2) THEN
            CALL VCLR(DA(L2+1),1,NOCVRK)
            IF (NBODY.EQ.2)
     *      CALL ZVLGMULT(NOCVRK,IDAX, KFG,IPTLG,DODISTR,ZVLAG,
     *                    X(LZVWRK),DA(L2+1))
            IF (NBODY.EQ.3) 
     *      CALL ZVLGMULT(NOCVRK,IDAXX,KFG,IPTLG,DODISTR,ZVLAG,
     *                    X(LZVWRK),DA(L2+1))
          ELSEIF (IFMOSTP.EQ.4) THEN
            IF (NBODY.EQ.2.and.scffrg(kfg).eq.uhf) then
                NOCVRK = NOCKB*NVRKB+NOCK*NVRK
                CALL ZVLGMULT(NOCVRK,IDAX, KFG,IPTLG,DODISTR,ZVLAG,
     *                        X(LZVWRK),DA(L2+1))
                NOCVRK = NOCK*NVRK
            ELSE IF (NBODY.EQ.2) THEN 
                CALL ZVLGMULT(NOCVRK,IDAX, KFG,IPTLG,DODISTR,ZVLAG,
     *                    X(LZVWRK),DA(L2+1))
            END IF
            IF (NBODY.EQ.3)
     *      CALL ZVLGMULT(NOCVRK,IDAXX,KFG,IPTLG,DODISTR,ZVLAG,
     *                    X(LZVWRK),DA(L2+1))
          ELSEIF (IFMOSTP.EQ.9) THEN
            CALL ZVLGMULT(NOCVRK,IDAX, KFG,IPTLG,DODISTR,ZVLAG,
     *                    X(LZVWRK),DA(L2+1))
          END IF
        END IF
CZCZ
CZ      TEST
C       WRITE(6,*) 'WRKESP2',L1
C       CALL PRTRIL(X(LWRKESP2),L1K)

CZ
CZ      CALCULATE LAGRANGIAN-LIKE TERM, X
CZ
        ! ADD SQUARE SPACE AFTER TRIANGLE SPACE FOR LFMODA
        CALL VCLR(X(LWRKESP),1,L2K)
CZ
        if(scffrg(kfg).eq.uhf) then
!          Alpha Density D * V * D
           CALL READMOND(X(LWRKDEN),ORBXCH,SCFFRG(KFG).EQ.RMC,
     *                    NAK,NBK,L1K,X(LIODFMO),IDMREC0K,
     *                    scffrg(kfg).eq.uhf)
           CALL DMTX2(X(LWRKDEN),X(LWRKDEN+L2K),NAK,L1K,L1K,0)
           CALL CPYTSQ(X(LWRKDEN),X(LWRKDEN+L2K),L1K,1)
           CALL TFTRI(X(LWRKESP),X(LWRKESP2),X(LWRKDEN+L2K),
     *                X(LWRKDEN+L2K+L3K),L1K,L1K,L1K)
!          Beta Density D * V * D
           CALL READMOND(X(LWRKDEN),ORBXCH,SCFFRG(KFG).EQ.RMC,
     *                    NAK,NBK,L1K,X(LIODFMO),IDMREC0K,
     *                    scffrg(kfg).eq.uhf)
           CALL DMTX2(X(LWRKDEN),X(LWRKDEN+L2K+L3K),NBK,L1K,L1K,0)
           CALL CPYTSQ(X(LWRKDEN),X(LWRKDEN+L2K),L1K,1)
           CALL TFTRI(X(LWRKDEN),X(LWRKESP2),X(LWRKDEN+L2K),
     *                X(LWRKDEN+L2K+L3K),L1K,L1K,L1K)
!          ADD Alpha + Beta
           CALL DAXPY(L2K,one,X(LWRKDEN),1,X(LWRKESP),1)
           CALL DSCAL(L2K,-one,X(LWRKESP),1)
!          restore density
           CALL READMOND(X(LWRKDEN),ORBXCH,SCFFRG(KFG).EQ.RMC,
     *                    NAK,NBK,L1K,X(LIODFMO),IDMREC0K,
     *                    scffrg(kfg).eq.uhf)
        else
          CALL CPYTSQ(X(LWRKDEN),X(LWRKDEN+L2K),L1K,1)
          CALL TFTRI(X(LWRKESP),X(LWRKESP2),X(LWRKDEN+L2K),
     *             X(LWRKDEN+L2K+L3K),L1K,L1K,L1K)
          CALL DSCAL(L2K,-HALF,X(LWRKESP),1)
        end if
        CALL VCLR(DE,1,NAT*3)
        CALL EXTSDER(X(LWRKESP),X(LWRKESP+L2K),L1K,L2K,.FALSE.,
     *               .FALSE.,L1)
CZ      IF (MASWRK) THEN
CZ        WRITE(6,*) 'TEST AFTER LAGRANGIAN-LIKE TERM',KFG,NAT
CZ        DO IJ = 1, NAT
CZ          WRITE(6,'(3F12.8)') DE(1,IJ),DE(2,IJ),DE(3,IJ)
CZ        END DO
CZ      END IF
CZCZ    CALL PRTRIL(X(LWRKESP),L1K)

CZ
CZ
CZ      CALCULATIONS OF DERIVATIVE TERMS
CZ 
CZ      ELECTRON REPULSION TERM
CZ
CZ      DA IS DI, DELTA DIJ, OR DELTA DIJK 
CZ      X(LWRKDEN)  IS THE DENSITY FOR EXTERNAL MONOMER 
CZ      NOTE THAT DERIVATIVES ARE STORED IN DE().
CZ
        CALL ESD2DER(DA,X(LWRKDEN),L1)
        IF(GOPARR) CALL DDI_GSUMF(2418,DE,NAT*3)
CZ      IF (MASWRK) THEN
CZ        WRITE(6,*) 'TEST AFTER ESD2DER',KFG,NAT
CZ        DO IJ = 1, NAT
CZ          WRITE(6,'(3F12.8)') DE(1,IJ),DE(2,IJ),DE(3,IJ)
CZ        END DO
CZ      END IF
        CALL RETFM(NEED)
CZ
        IF (MASWRK) THEN
          IF     (IFMOSTP.EQ.2) THEN
            ! ONLY USED FOR MP2 CORRECTION
            CALL FMODEG(IDAX, X(LFDE2B),X(LFMOPG),X(LIAGLOB))
            IF (NBODY.GT.2)
     *      CALL FMODEG(IDAXX,X(LFDE3B),X(LFMOPG),X(LIAGLOB))
          ELSEIF (IFMOSTP.EQ.4) THEN
            CALL FMODEG(IDAX, X(LFDE2B),X(LFMOPG),X(LIAGLOB))
            IF (NBODY.GT.2) 
     *      CALL FMODEG(IDAXX,X(LFDE3B),X(LFMOPG),X(LIAGLOB))
            ! MUST CHANGE
          ELSEIF (IFMOSTP.EQ.9) THEN
            CALL FMODEG(IDAX, X(LFDE3B),X(LFMOPG),X(LIAGLOB))
          ENDIF
        ENDIF
  100 CONTINUE
      IF(ESPPAR.AND.GOPARR.AND.NXT) CALL DDI_DLBRESET
C
C     RESTORE THE PRISTINE MONOMER(DIMER) CONFIGURATION
C
      CALL MONBSR(NAT0,ICH0,MUL0,NUM0,NQMT0,NE0,NA0,NB0,NCURSH,NGAU0,
     *           ENUCR0,NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,NSHELL,NGAU,ENUCR)
C
C     IT IS IMPORTANT TO RESET NCURSH SO THAT 2E INTEGRALS WITHIN THE MONOMER
C     (DIMER) DURING THE FOLLOWING SCF ARE COMPUTED PROPERLY.
      NCURSH=0
C
C     COMPUTE 2-EL INTEGRALS FOR THE ORIGINAL MONOMER(DIMER)
C
      IF(IFMOSTP.NE.6) THEN
        IST=1
        JST=1
        KST=1
        LST=1
        CALL JANDK
      ENDIF
      NPRFMO=NPRSAV
      DIRSCF=DIRSAV
      LCFLAG=LCFLAGS
      camFLAG=camFLAGS
      LRINT=LRINTS
CZ
      IESDPPC    = 0
      LFMOBUF(3) = 0
      IF(MASWRK) WRITE(IW,*) 'DONE FMOESD'
      CALL TIMIT(1)
CZ
C     IF (MASWRK) WRITE(6,*) 'EXIT OF FMOESD',NQMT
      RETURN
 9000 FORMAT(/1X,'ESD LFG=',I5,': NZ',I12,' SKIPPED',I10,' BLOCKS.')
 9005 FORMAT(/1X,'ESD LFG=',I5,': NZ',I12,' SKIPPED',I10,' BLOCKS',I8,
     *           ' SUPERBLOCKS.')
      END
C*MODULE FMOESD  *DECK ESVDER
      SUBROUTINE ESVDER(IDAX,IDAXX,DENAB,DTINT,DVINT,L2,MODUS,
     *                  FMODEX,FMODEXX,LCPHF)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL OUT,DBG,NORM
      LOGICAL GOPARR,DSKWRK,MASWRK,NXT,SVDSKW
      LOGICAL LCPHF,fastvesp
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000, MXAO=8192)
      PARAMETER (MXCHRM=1)
C
      DIMENSION DENAB(L2),DTINT(L2,3,NAT),DVINT(L2,3,NAT)
      DIMENSION DIJ(225), IJX(35), IJY(35), IJZ(35),
     *          XV(6,5,5), YV(6,5,5), ZV(6,5,5),
     *          DXV(5,5,5), DYV(5,5,5), DZV(5,5,5),
     *          XS(6,7), YS(6,7), ZS(6,7), XT(6,5), YT(6,5), ZT(6,5),
     *          DXS(5,5), DYS(5,5), DZS(5,5),
     *          DXT(5,5), DYT(5,5), DZT(5,5)
      dimension FMODEX(3,*), FMODEXX(3,*)
C
      COMMON /CHMGMS/ XCHM(MXCHRM),YCHM(MXCHRM),ZCHM(MXCHRM),
     *                DXELMM(MXCHRM),DYELMM(MXCHRM),DZELMM(MXCHRM),
     *                QCHM(MXCHRM),NCHMAT,KCHRMM
      COMMON /DSTV  / XINT,YINT,ZINT,T,X0,Y0,Z0,XI,YI,ZI,
     *                XJ,YJ,ZJ,NI,NJ,CX,CY,CZ
      COMMON /FMCOM / X(1)
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /ROOT  / XX,U(13),W(13),NROOTS
      COMMON /RELWFN/ RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,IQRORD,MODQR,NESOC,
     *                NRATOM,NUMU,NQMTR,NQRDAF,MORDA,NDARELB
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00,TWO=2.0D+00)
      PARAMETER (RLN10=2.30258D+00)
      PARAMETER (PI212=1.1283791670955D+00)
      PARAMETER (SQRT3=1.73205080756888D+00)
      PARAMETER (SQRT5=2.23606797749979D+00,SQRT7=2.64575131106459D+00)
C
      DATA DEBUG/8HDEBUG   /, DBUGME/8HTVDER   /, GRD1/8HGRD1    /,
     *     RESC/8HRESC    /,ANESC/8HNESC    /
C
      DATA IJX / 1, 2, 1, 1, 3, 1, 1, 2, 2, 1,
     *           4, 1, 1, 3, 3, 2, 1, 2, 1, 2,
     *           5, 1, 1, 4, 4, 2, 1, 2, 1, 3,
     *           3, 1, 3, 2, 2/
      DATA IJY / 1, 1, 2, 1, 1, 3, 1, 2, 1, 2,
     *           1, 4, 1, 2, 1, 3, 3, 1, 2, 2,
     *           1, 5, 1, 2, 1, 4, 4, 1, 2, 3,
     *           1, 3, 2, 3, 2/
      DATA IJZ / 1, 1, 1, 2, 1, 1, 3, 1, 2, 2,
     *           1, 1, 4, 1, 2, 1, 2, 3, 3, 2,
     *           1, 1, 5, 1, 2, 1, 2, 4, 4, 1,
     *           3, 3, 2, 2, 3/
C
C     ----- BASIS FUNCTION DERIVATIVE CONTRIBUTIONS TO GRADIENT -----
C     INTEGRALS ARE OF TYPE <II'/H/JJ> = <II'/T+V/JJ>
C     RESC RUNS STORE INTEGRALS WITHOUT CONTRACTING THEM WITH DENSITY
C
C     MODUS - USED ONLY WITH NESC METHOD AND ONLY FOR KIN. ENERGY T
C           = 0 BULK T GRADIENT
C           = 1 CORRECTION TO S DERIVATIVE (PROPORTIONAL TO T)
C           = 2 CORRECTION TO T DERIVATIVE
C
      DBG = (EXETYP.EQ.DEBUG  .OR.  EXETYP.EQ.DBUGME)  .AND.  MASWRK
      OUT = (EXETYP.EQ.DEBUG  .OR.  EXETYP.EQ.DBUGME  .OR.
     *       EXETYP.EQ.GRD1   .OR.  NPRINT.EQ.-3)
      IF(DBG) WRITE(IW,9000)
      IAZ=0
C
      TOL = RLN10*ITOL
      NORM = NORMF .NE. 1 .OR. NORMP .NE. 1
      IF(RMETHOD.EQ.ANESC) THEN
         FSC=ONE/CLIG
         FSC2=FSC*FSC/TWO
      ENDIF
      IF(RMETHOD.EQ.RESC) THEN
         CALL VCLR(DTINT,1,L2*3*NAT)
         CALL VCLR(DVINT,1,L2*3*NAT)
      ENDIF
CZ
CZ    DETERMINE THE COEFFICIENTS FOR FMO N-MER GRAD 
CZ
czcz  IDAMM = 0
czcz  IDADD = 0
czcz  IDATT = 0
      IF     (IFMOSTP.EQ.2) THEN
czcz    ! ALWAYS MP2 WITH IAND(MODGRD,32).NE.0
czcz    IDAMM = 1
czcz    IDAMM = 0  ! HF CONTRIBUTION IS NOT CONSIDERED.
czcz    IF (NBODY.GT.1) IDADD = IDAX  ! MP2 CORRECTION
czcz    IF (NBODY.GT.2) IDATT = IDAXX
      ELSEIF (IFMOSTP.EQ.4) THEN
czcz    IDADD = IDAX
czcz    IF (NBODY.GT.2) IDATT = IDAXX
      ELSEIF (IFMOSTP.EQ.9) THEN
czcz    IDATT = IDAX
      ELSE
        WRITE (6,*) 'IFMOSTP MUST BE 2, 4, OR 9'
        CALL ABRT
      ENDIF
CZ    IF (IDAX.EQ.0.AND.IDAXX.EQ.0) RETURN
CZ    WRITE(6,*) 'COEF FOR FRAG ENER IN ES1DER',IDAX,IDAXX
CZ
C
C INITIALIZE PARALLEL
C
      NXT = IBTYP.EQ.1
      IPCOUNT = ME - 1
      NEXT = -1
      MINE = -1
C
C     -D*ELMM- CONTAINS CONTRIBUTION TO THE FORCES ON THE
C     EXTERNAL CHARGES WHICH ARE DUE TO QM MOLECULE.
C
      IF(NCHMAT.NE.0) THEN
         DO 100 ICHARM=1,NCHMAT
            DXELMM(ICHARM)=ZERO
            DYELMM(ICHARM)=ZERO
            DZELMM(ICHARM)=ZERO
  100    CONTINUE
      END IF
CZ    ESD=NFG.NE.0.AND. IFMOSTP.EQ.2.AND.MPLEVL.EQ.0.AND.
CZ   *                  RESDIM.NE.0.AND.IAND(IXESP,32).EQ.0
CZ    NEXTAT=NCHMAT
CZ    IF(ESD) NEXTAT=NATFMO
CZ    NEXTAT=NATFMO
CZ
CZ    SET UP A PARAMETER IN DEEPEST LOOP    
CZ
czcz  IC0   = 0
czcz  IC1   = 1
      MAXIC = NATFMO
czcz  IF (LCPHF) THEN
czcz    IC0   = NAT
czcz    IC1   = 1
czcz    MAXIC = NAT 
czcz    MAXIC = NAT + NATFMO
czcz  END IF
CZ
      call setatz(1,MAXIC,fastvesp,lfvesp,needfv)
c     setatz allocates memory. One should be careful in returining it. 
C
C     FIRST, LOOP OVER THE GENUINE QM MOLECULE (ICHARM=0 PASS),
C     AND THEN ANY EXTERNAL CHARGES WHICH CHARMM MAY BE USING.
C     THE LATTER MAKE A CONTRIBUTION TO THE GRADIENT OF THE ATOMS
C     IN THE QM MOLECULE, AS WELL AS TO THEMSELVES.
C     FMO EXTERNAL ATOMS FROM SEPARATED DIMERS ARE HANDLED SIMILARLY TO
C     CHARMM.
C
C     ----- I SHELL
C
      DO 1400 II = 1,NSHELL
C
C           GO PARALLEL!
C
        IF(NXT .AND. GOPARR) THEN
           MINE = MINE + 1
           IF(MINE.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
           IF(NEXT.NE.MINE) GO TO 1400
        END IF
C
        IAT = KATOM(II)
        XI = C(1,IAT)
        YI = C(2,IAT)
        ZI = C(3,IAT)
        I1 = KSTART(II)
        I2 = I1+KNG(II)-1
        LIT = KTYPE(II)
        MINI = KMIN(II)
        MAXI = KMAX(II)
        LOCI = KLOC(II)-MINI
        LITDER = LIT + 1
C
C     ----- J SHELL
C
        DO 1300 JJ = 1,NSHELL
C
C           GO PARALLEL!
C
          IF((.NOT.NXT) .AND. GOPARR) THEN
             IPCOUNT = IPCOUNT + 1
             IF(MOD(IPCOUNT,NPROC).NE.0) GO TO 1300
          END IF
C
          JAT = KATOM(JJ)
          XJ = C(1,JAT)
          YJ = C(2,JAT)
          ZJ = C(3,JAT)
          J1 = KSTART(JJ)
          J2 = J1+KNG(JJ)-1
          LJT = KTYPE(JJ)
          MINJ = KMIN(JJ)
          MAXJ = KMAX(JJ)
          LOCJ = KLOC(JJ)-MINJ
          LJTMOD = LJT+2
          NROOTS = (LIT+LJT-1)/2 + 1
          RR = (XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
C
C     ----- I PRIMITIVE
C
        DO 1100 IG = I1,I2
          AI = EX(IG)
          ARRI = AI*RR
          AXI = AI*XI
          AYI = AI*YI
          AZI = AI*ZI
          CSI=CS(IG)
          CPI=CP(IG)
          CDI=CD(IG)
          CFI=CF(IG)
          CGI=CG(IG)
C
C     ----- J PRIMITIVE
C
          DO 1000 JG = J1,J2
            AJ = EX(JG)
            AA = AI+AJ
            AA1 = ONE/AA
            DUM = AJ*ARRI*AA1
            IF(DUM .GT. TOL) GO TO 1000
            FAC = EXP(-DUM)
            CSJ = CS(JG)
            CPJ = CP(JG)
            CDJ = CD(JG)
            CFJ = CF(JG)
            CGJ = CG(JG)
            AX = (AXI+AJ*XJ)*AA1
            AY = (AYI+AJ*YJ)*AA1
            AZ = (AZI+AJ*ZJ)*AA1
C
C     ----- DENSITY FACTOR
C
            IJ = 0
            DUM1 = ZERO
            DUM2 = DUM1
            dijmax=0 
            DO 600 I=MINI,MAXI
              IF(I.EQ.1) DUM1=CSI*FAC
              IF(I.EQ.2) DUM1=CPI*FAC
              IF(I.EQ.5) DUM1=CDI*FAC
              IF(I.EQ.8.AND.NORM) DUM1=DUM1*SQRT3
              IF(I.EQ.11) DUM1=CFI*FAC
              IF(I.EQ.14.AND.NORM) DUM1=DUM1*SQRT5
              IF(I.EQ.20.AND.NORM) DUM1=DUM1*SQRT3
              IF(I.EQ.21) DUM1=CGI*FAC
              IF(I.EQ.24.AND.NORM) DUM1=DUM1*SQRT7
              IF(I.EQ.30.AND.NORM) DUM1=DUM1*SQRT5/SQRT3
              IF(I.EQ.33.AND.NORM) DUM1=DUM1*SQRT3
C
              DO 600 J = MINJ,MAXJ
                IF(J.EQ.1) DUM2=DUM1*CSJ
                IF(J.EQ.2) DUM2=DUM1*CPJ
                IF(J.EQ.5) DUM2=DUM1*CDJ
                IF(J.EQ.8.AND.NORM) DUM2=DUM2*SQRT3
                IF(J.EQ.11) DUM2=DUM1*CFJ
                IF(J.EQ.14.AND.NORM) DUM2=DUM2*SQRT5
                IF(J.EQ.20.AND.NORM) DUM2=DUM2*SQRT3
                IF(J.EQ.21) DUM2=DUM1*CGJ
                IF(J.EQ.24.AND.NORM) DUM2=DUM2*SQRT7
                IF(J.EQ.30.AND.NORM) DUM2=DUM2*SQRT5/SQRT3
                IF(J.EQ.33.AND.NORM) DUM2=DUM2*SQRT3
C
                IJ=IJ+1
                IF(RMETHOD.EQ.RESC) THEN
                  DEN=ONE
                  IF(LOCI+I.EQ.LOCJ+J) DEN=TWO
                ELSE
                  NN = IA(MAX0(LOCI+I,LOCJ+J))+MIN0(LOCI+I,LOCJ+J)
                  DEN = DENAB(NN)
                  DEN = DEN + DEN
                  IF(RMETHOD.EQ.ANESC) THEN
                    IF(MODUS.EQ.1) DEN=DEN*FSC2
                    IF(MODUS.EQ.2) DEN=-DEN
                  ENDIF
                ENDIF
                DIJ(IJ)=DUM2*DEN
                if(abs(DIJ(IJ)).gt.dijmax) dijmax=abs(DIJ(IJ))
  600         CONTINUE
c             write(6,*) 'wwwD',dijmax
C
C     -----  KINETIC ENERGY
C
CZCZ  IF(ICHARM.GT.0) GO TO 700
      IF(.NOT.LCPHF) GO TO 700
C
      T = SQRT(AA1)
      X0 = AX
      Y0 = AY
      Z0 = AZ
      DO 660 J = 1,LJTMOD
        NJ =J
        DO 660 I = 1,LITDER
          NI = I
          CALL VINT
          XS(I,J)=XINT*T
          YS(I,J)=YINT*T
          ZS(I,J)=ZINT*T
  660 CONTINUE
      CALL DTXYZ(XT,YT,ZT,XS,YS,ZS,LITDER,LJT,AJ)
      CALL DERI(DXS,DYS,DZS,XS,YS,ZS,LIT,LJT,AI)
      CALL DERI(DXT,DYT,DZT,XT,YT,ZT,LIT,LJT,AI)
      IJ=0
      DO 680 I=MINI,MAXI
        IX=IJX(I)
        IY=IJY(I)
        IZ=IJZ(I)
        DO 670 J=MINJ,MAXJ
          JX=IJX(J)
          JY=IJY(J)
          JZ=IJZ(J)
          DUMX=DXT(IX,JX)* YS(IY,JY)* ZS(IZ,JZ)
     1        +DXS(IX,JX)* YT(IY,JY)* ZS(IZ,JZ)
     2        +DXS(IX,JX)* YS(IY,JY)* ZT(IZ,JZ)
          DUMY= XT(IX,JX)*DYS(IY,JY)* ZS(IZ,JZ)
     1        + XS(IX,JX)*DYT(IY,JY)* ZS(IZ,JZ)
     2        + XS(IX,JX)*DYS(IY,JY)* ZT(IZ,JZ)
          DUMZ= XT(IX,JX)* YS(IY,JY)*DZS(IZ,JZ)
     1        + XS(IX,JX)* YT(IY,JY)*DZS(IZ,JZ)
     2        + XS(IX,JX)* YS(IY,JY)*DZT(IZ,JZ)
          IJ=IJ+1
          IF(RMETHOD.EQ.RESC) THEN
             NN=IA(MAX0(LOCI+I,LOCJ+J))+MIN0(LOCI+I,LOCJ+J)
             DUMINT=DIJ(IJ)
             DTINT(NN,1,IAT)=DTINT(NN,1,IAT)+DUMX*DUMINT
             DTINT(NN,2,IAT)=DTINT(NN,2,IAT)+DUMY*DUMINT
             DTINT(NN,3,IAT)=DTINT(NN,3,IAT)+DUMZ*DUMINT
          ELSE
             DE(1,IAT)=DE(1,IAT)+ DUMX*DIJ(IJ)
             DE(2,IAT)=DE(2,IAT)+ DUMY*DIJ(IJ)
             DE(3,IAT)=DE(3,IAT)+ DUMZ*DIJ(IJ)
          ENDIF
  670     CONTINUE
  680   CONTINUE
        IF(RMETHOD.EQ.ANESC.AND.MODUS.NE.0) GOTO 1000
 
C     ..... NUCLEAR ATTRACTION
 
  700 CONTINUE
      AAX = AA*AX
      AAY = AA*AY
      AAZ = AA*AZ
CZ    IF(ICHARM.EQ.0) THEN
CZ       MAXIC=NAT
CZ       IF(ISEPS) MAXIC=NAT+NPS
CZ    ELSE
CZ       MAXIC=1
CZ    END IF
C
      DO 790 IC = 1,MAXIC
         if(fastvesp) then
           icind=lfvesp+(ic-1)*6
           FRACV=x(icind)
           FRACESP=x(icind+1)
           ZNUC=x(icind+2)
           CX=x(icind+3)
           CY=x(icind+4)
           CZ=x(icind+5)
         else
           CALL FMOATFRG(IC,X(LINDAT),X(LINDATG),X(LIAGLOB),
     *                 X(LIALOC),X(LIABDFG),X(LJABDFG),
     *                 X(LINDBD),X(LFMOZAN),X(LFMOC),
     *                 NATFMO+NBDFG,X(LUNTXYZ),X(LPOPMAT),
     *                 KATOM(II),KATOM(JJ),FRACV,FRACESP,
     *                 KFG,ZNUC,CX,CY,CZ)
         endif
         if(lcphf) then
           IF (FRACESP.EQ.ZERO.AND.FRACV.EQ.ZERO) GOTO 790
         else
           IF (FRACESP.EQ.ZERO) GOTO 790
         endif
c        IF (FRACESP.EQ.ZERO.AND.FRACV.EQ.ZERO) GOTO 790
c        WRITE(6,*) 'WWWATOMA',IC,FRACV,FRACESP,lcphf

         XX = AA*((AX-CX)**2+(AY-CY)**2+(AZ-CZ)**2)
         IF(NROOTS.LE.3) CALL RT123
         IF(NROOTS.EQ.4) CALL ROOT4
         IF(NROOTS.EQ.5) CALL ROOT5
         DO 740 K = 1,NROOTS
            UU = AA*U(K)
            WW = W(K)*ZNUC
            TT = ONE/(AA+UU)
            T = SQRT(TT)
            X0 = (AAX+UU*CX)*TT
            Y0 = (AAY+UU*CY)*TT
            Z0 = (AAZ+UU*CZ)*TT
            DO 730 J = 1,LJT
               NJ = J
               DO 720 I = 1,LITDER
                  NI = I
                  CALL VINT
                  XV(I,J,K) = XINT
                  YV(I,J,K) = YINT
                  ZV(I,J,K) = ZINT*WW
  720          CONTINUE
  730       CONTINUE
            CALL DERI(DXV(1,1,K),DYV(1,1,K),DZV(1,1,K),
     *                 XV(1,1,K), YV(1,1,K), ZV(1,1,K),LIT,LJT,AI)
  740    CONTINUE
         IJ=0
         DO 780 I=MINI,MAXI
           IX=IJX(I)
           IY=IJY(I)
           IZ=IJZ(I)
           DO 780 J=MINJ,MAXJ
             JX=IJX(J)
             JY=IJY(J)
             JZ=IJZ(J)
             DUMX=ZERO
             DUMY=ZERO
             DUMZ=ZERO
             DO 770 K=1,NROOTS
               DUMX=DUMX+DXV(IX,JX,K)* YV(IY,JY,K)* ZV(IZ,JZ,K)
               DUMY=DUMY+ XV(IX,JX,K)*DYV(IY,JY,K)* ZV(IZ,JZ,K)
               DUMZ=DUMZ+ XV(IX,JX,K)* YV(IY,JY,K)*DZV(IZ,JZ,K)
  770        CONTINUE
             IJ=IJ+1
CZ 
CZCZCZ ???   IF((IC.GT.NAT).AND.(IAT.EQ.IAZ)) GOTO 780
CZ
             DUMINT=DIJ(IJ)*AA1*PI212
             IF(RMETHOD.EQ.RESC) THEN
                NN=IA(MAX0(LOCI+I,LOCJ+J))+MIN0(LOCI+I,LOCJ+J)
                DVINT(NN,1,IAT)=DVINT(NN,1,IAT)+DUMX*DUMINT
                DVINT(NN,2,IAT)=DVINT(NN,2,IAT)+DUMY*DUMINT
                DVINT(NN,3,IAT)=DVINT(NN,3,IAT)+DUMZ*DUMINT
C               IE. NO CHARMS NOW WITH RESC
             ELSE
CZ             SAVE TVDER GRADIENT TERMS TO IBODY ARRAYS
               DDDDX = DUMX*DUMINT
               DDDDY = DUMY*DUMINT
               DDDDZ = DUMZ*DUMINT
               IAZ=IXFTCH(X(LIAGLOB),IAT)
               IF (IDAX.NE.0) THEN
                 DAX = IDAX
                 DAX =  DAX * FRACESP
CZ               IOFF=LFMODE         +(IAZ-1)*3
                 FMODEX(1,IAZ)=FMODEX(1,IAZ)+DAX*DDDDX
                 FMODEX(2,IAZ)=FMODEX(2,IAZ)+DAX*DDDDY
                 FMODEX(3,IAZ)=FMODEX(3,IAZ)+DAX*DDDDZ
                 IF (LCPHF) THEN
                   IF (FRACV.NE.ZERO) THEN
                     DAX = IDAX
                     DAX =  DAX * FRACV
                     FMODEX(1,IAZ)=FMODEX(1,IAZ)+DAX*DDDDX
                     FMODEX(2,IAZ)=FMODEX(2,IAZ)+DAX*DDDDY
                     FMODEX(3,IAZ)=FMODEX(3,IAZ)+DAX*DDDDZ
                   END IF
                 END IF
               END IF
               IF (IDAXX.NE.0) THEN
                 DAXX = IDAXX
                 DAXX =  DAXX * FRACESP
CZ               IOFF=LFMODE+3*NATFMO+(IAZ-1)*3
                 FMODEXX(1,IAZ)=FMODEXX(1,IAZ)+DAXX*DDDDX
                 FMODEXX(2,IAZ)=FMODEXX(2,IAZ)+DAXX*DDDDY
                 FMODEXX(3,IAZ)=FMODEXX(3,IAZ)+DAXX*DDDDZ
                 IF (LCPHF) THEN
                   IF (FRACV.NE.ZERO) THEN
                     DAXX = IDAXX
                     DAXX =  DAXX * FRACV
                     FMODEXX(1,IAZ)=FMODEXX(1,IAZ)+DAXX*DDDDX
                     FMODEXX(2,IAZ)=FMODEXX(2,IAZ)+DAXX*DDDDY
                     FMODEXX(3,IAZ)=FMODEXX(3,IAZ)+DAXX*DDDDZ
                   END IF
                 END IF
               END IF
CZ
CZ     NOTE THAT THE CALCULATION OF HELFEY TERMS IS MOVED TO 
CZ     SUBROUTINE EXTHELFEY (9/24/2007) 
CZ
             ENDIF
  780    CONTINUE
  790 CONTINUE
C
 1000 CONTINUE
 1100 CONTINUE
C
C     ----- END OF PRIMITIVE LOOPS -----
C
      IF(DBG) THEN
         WRITE(IW,9100) II,JJ
         CALL EGOUT(DE,NAT)
      END IF
 1300 CONTINUE
 1400 CONTINUE
      if(fastvesp) call retfm(needfv)
C
C     ----- END OF SHELL LOOPS -----
C
      IF(OUT) THEN
         IF(GOPARR) CALL DDI_GSUMF(1503,DE,3*NAT)
         IF(MASWRK) THEN
            WRITE(IW,9000)
            CALL EGOUT(DE,NAT)
         END IF
         IF(GOPARR) CALL DSCAL(3*NAT,ONE/NPROC,DE,1)
C              WILL ONLY PRINT PARTIAL CONTRIBUTIONS IN PARALLEL.
CZCZ     IF(ESD) THEN
         IF(.TRUE.) THEN
            IF(MASWRK) WRITE(IW,9088)
            CALL EGOUT(X(LFMODE+3*NATFMO),NATFMO)
         END IF
      END IF
CZCZ FOR DEBUG
      IF(DBG) THEN
         IF(MASWRK) WRITE(IW,9088)
         IF(MASWRK) WRITE(IW,*) 'NATNAT',NAT
         CALL EGOUT(X(LFMODE),NATFMO*NBODY)
      END IF
CZCZ
C
CZ
      IF(GOPARR .AND. NXT) CALL DDI_DLBRESET
C
      IF(RMETHOD.EQ.RESC) THEN
        IF(GOPARR) CALL DDI_GSUMF(1503,DTINT,L2*3*NAT)
        IF(GOPARR) CALL DDI_GSUMF(1504,DVINT,L2*3*NAT)
        SVDSKW=DSKWRK
        DSKWRK=.TRUE.
         LREC=3*NAT
C        STARTING RECORD FOR THE T DERIVATIVE INTEGRALS
        DO I=1,NAT
          DO J=1,3
            LREC=LREC+1
            CALL RAWRIT(NQRDAF,X(MORDA),DTINT(1,J,I),L2,LREC,0)
C
C           ADD TWO CONTRIBUTIONS, HELLMANN-FEYNMAN AND DV GOT HERE
C
            CALL RAREAD(NQRDAF,X(MORDA),DTINT(1,J,I),L2,LREC+6*NAT,0)
            CALL DAXPY(L2,ONE,DTINT(1,J,I),1,DVINT(1,J,I),1)
            CALL RAWRIT(NQRDAF,X(MORDA),DVINT(1,J,I),L2,LREC+6*NAT,0)
          ENDDO
        ENDDO
        DSKWRK=SVDSKW
      ENDIF
C
      RETURN
C
 9000 FORMAT(/10X,38(1H-)/10X,'GRADIENT INCLUDING AO DERIVATIVE TERMS'/
     *        10X,38(1H-))
 9088 FORMAT(/10X,36(1H-)/10X,'ONE-ELECTRON ESD GRADIENT',/10X,36(1H-))
 9100 FORMAT(1X,'TVDER: SHELLS II,JJ=',2I5)
      END
C*MODULE FMOESD  *DECK EXTSDER
C>
C>     @brief Lagrangian-like contributions for ES dimers 
C>
C>     @details Add Lagrangian-like contributions for ES dimers.
C>
C>     @author Takeshi Nagata 
C>
      SUBROUTINE EXTSDER(EPS,DSINT,L1,L2,NOCON,LMONLAG,NUM0)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL DBG,NORM,OUT
      LOGICAL GOPARR,DSKWRK,MASWRK,NXT,SVDSKW,NOCON
CZ
      LOGICAL LMONLAG
CZ
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000, MXAO=8192)
C
      DIMENSION EPS((l1+l1*l1)/2),DSINT((l1+l1*l1)/2,3,*)
      DIMENSION DIJ(225), DIJINT(225), IJX(35), IJY(35),IJZ(35),
     *           XS(6,5), YS(6,5), ZS(6,5),
     *          DXS(5,5),DYS(5,5),DZS(5,5)
C
      COMMON /DSTV  / XINT,YINT,ZINT,T,X0,Y0,Z0,XI,YI,ZI,
     *                XJ,YJ,ZJ,NI,NJ,CX,CY,CZ
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /RELWFN/ RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,IQRORD,MODQR,NESOC,
     *                NRATOM,NUMU,NQMTR,NQRDAF,MORDA,NDARELB
      COMMON /FMCOM / X(1)
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo
C
      PARAMETER (SQRT3=1.73205080756888D+00)
      PARAMETER (SQRT5=2.23606797749979D+00, SQRT7=2.64575131106459D+00)
      PARAMETER (ONE=1.0D+00)
      PARAMETER (RLN10=2.30258D+00)
C
      DATA DEBUG/8HDEBUG   /, DBUGME/8HSDER    /, GRD1/8HGRD1    /,
     *     RESC/8HRESC    /
C
      DATA IJX / 1, 2, 1, 1, 3, 1, 1, 2, 2, 1,
     *           4, 1, 1, 3, 3, 2, 1, 2, 1, 2,
     *           5, 1, 1, 4, 4, 2, 1, 2, 1, 3,
     *           3, 1, 3, 2, 2/
      DATA IJY / 1, 1, 2, 1, 1, 3, 1, 2, 1, 2,
     *           1, 4, 1, 2, 1, 3, 3, 1, 2, 2,
     *           1, 5, 1, 2, 1, 4, 4, 1, 2, 3,
     *           1, 3, 2, 3, 2/
      DATA IJZ / 1, 1, 1, 2, 1, 1, 3, 1, 2, 2,
     *           1, 1, 4, 1, 2, 1, 2, 3, 3, 2,
     *           1, 1, 5, 1, 2, 1, 2, 4, 4, 1,
     *           3, 3, 2, 2, 3/
C
C     ----- CALCULATE DERIVATIVES OF THE OVERLAP MATRIX -----
C     THIS TERM RESULTS FROM DERIVATIVES OF THE DENSITY MATRIX,
C     WHICH CAN IN THE CASE OF A SYMMETRIC LAGRANGIAN MATRIX, CAN
C     BE CONVERTED INSTEAD INTO DERIVATIVES OF OVERLAP INTEGRALS.
C     RESC RUNS NEED BOTH CONTRACTION OF THE INTEGRALS WITH DENSITY
C     AND THE INTEGRALS THEMSELVES.
C     IN CASE OF INTERNALLY UNCONTRACTED RESC, ONE HAS TO TRANSFORM
C     THE OVERLAP DERIVATIVES TO CONTRACTED BASIS BEFORE
C     SUMMING (CONTRACTING) OVERLAP DERIVATIVES WITH THE LAGRANGIAN
C
C     NOCON IS TRUE IF LAGRANGIAN IS NOT TO BE SUMMED WITH.
      imode = 0
      IF(LMONLAG.and.num0.ne.0) then
C    DOUBLE check
c        call derchk(NDER) 
c        if(NDER.ne.2) call abrt
         natk = l2
         natin= nat - natk 
         l2   = (l1 + l1 * l1) /2
         imode= 1
      end if
C
      DBG = (EXETYP.EQ.DEBUG  .OR.  EXETYP.EQ.DBUGME)  .AND.  MASWRK
      OUT = (EXETYP.EQ.DEBUG  .OR.  EXETYP.EQ.DBUGME  .OR.
     *       EXETYP.EQ.GRD1   .OR.  NPRINT.EQ.-3)
      IF(DBG) WRITE(IW,9000)
C
      TOL = RLN10*ITOL
      NORM = NORMF .NE. 1 .OR. NORMP .NE. 1
CZCZ  IF(RMETHOD.EQ.RESC) CALL VCLR(DSINT,1,L2*3*NAT)
      IF(LMONLAG.and.imode.eq.0) CALL VCLR(DSINT,1,L2*3*NAT)
      IF(LMONLAG.and.imode.eq.1) CALL VCLR(DSINT,1,L2*3*NATK)
CZ
C
C     INITIALIZE PARALLEL
C
      NXT = IBTYP.EQ.1
      IPCOUNT = ME - 1
      NEXT = -1
      MINE = -1
C
      IF(DBG) THEN
         WRITE(IW,9010)
         CALL PRTRI(EPS,L1)
      END IF
C
C     ----- I SHELL
C
CZCZ  DO 780 II = 1,NSHELL
      DO 780 II = NCURSH+1,NSHELL
CZ
C
C           GO PARALLEL!
C
      IF(NXT .AND. GOPARR) THEN
         MINE = MINE + 1
         IF(MINE.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
         IF(NEXT.NE.MINE) GO TO 780
      END IF
C
      IAT = KATOM(II)
      XI = C(1,IAT)
      YI = C(2,IAT)
      ZI = C(3,IAT)
      I1 = KSTART(II)
      I2 = I1+KNG(II)-1
      LIT = KTYPE(II)
      MINI = KMIN(II)
      MAXI = KMAX(II)
      LOCI = KLOC(II)-MINI
      LITDER = LIT+1
      if(imode.eq.1) then
          IAT = IAT - natin
      end if
C
C     ----- J SHELL
C
CZCZ  DO 760 JJ = 1,II
      DO 760 JJ = NCURSH+1,II
CZ
C
C           GO PARALLEL!
C
      IF((.NOT.NXT) .AND. GOPARR) THEN
         IPCOUNT = IPCOUNT + 1
         IF(MOD(IPCOUNT,NPROC).NE.0) GO TO 760
      END IF
C
      JAT = KATOM(JJ)
      XJ = C(1,JAT)
      YJ = C(2,JAT)
      ZJ = C(3,JAT)
      J1 = KSTART(JJ)
      J2 = J1+KNG(JJ)-1
      LJT = KTYPE(JJ)
      MINJ = KMIN(JJ)
      MAXJ = KMAX(JJ)
      LOCJ = KLOC(JJ)-MINJ
      RR = (XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
      if(imode.eq.1) then
          JAT = JAT - natin
      end if
      IF(II.EQ.JJ) GO TO 760
C
C     ----- I PRIMITIVE
C
      DO 640 IG = I1,I2
        AI = EX(IG)
        ARRI = AI*RR
        AXI = AI*XI
        AYI = AI*YI
        AZI = AI*ZI
        CSI=CS(IG)
        CPI=CP(IG)
        CDI=CD(IG)
        CFI=CF(IG)
        CGI=CG(IG)
C
C     ----- J PRIMITIVE
C
        DO 620 JG = J1,J2
          AJ = EX(JG)
          AA = AI+AJ
          AA1 = ONE/AA
          DUM = AJ*ARRI*AA1
          IF(DUM .GT. TOL) GO TO 620
          FAC = EXP(-DUM)
          CSJ = CS(JG)
          CPJ = CP(JG)
          CDJ = CD(JG)
          CFJ = CF(JG)
          CGJ = CG(JG)
          AX = (AXI+AJ*XJ)*AA1
          AY = (AYI+AJ*YJ)*AA1
          AZ = (AZI+AJ*ZJ)*AA1
C
C     ----- DENSITY FACTOR
C
          IJ = 0
          DO 580 I = MINI,MAXI
            IF(I.EQ.1) DUM1=CSI*FAC
            IF(I.EQ.2) DUM1=CPI*FAC
            IF(I.EQ.5) DUM1=CDI*FAC
            IF(I.EQ.8.AND.NORM) DUM1=DUM1*SQRT3
            IF(I.EQ.11) DUM1=CFI*FAC
            IF(I.EQ.14.AND.NORM) DUM1=DUM1*SQRT5
            IF(I.EQ.20.AND.NORM) DUM1=DUM1*SQRT3
            IF(I.EQ.21) DUM1=CGI*FAC
            IF(I.EQ.24.AND.NORM) DUM1=DUM1*SQRT7
            IF(I.EQ.30.AND.NORM) DUM1=DUM1*SQRT5/SQRT3
            IF(I.EQ.33.AND.NORM) DUM1=DUM1*SQRT3
            DO 570 J = MINJ,MAXJ
              IF(J.EQ.1) DUM2=DUM1*CSJ
              IF(J.EQ.2) DUM2=DUM1*CPJ
              IF(J.EQ.5) DUM2=DUM1*CDJ
              IF(J.EQ.8.AND.NORM) DUM2=DUM2*SQRT3
              IF(J.EQ.11) DUM2=DUM1*CFJ
              IF(J.EQ.14.AND.NORM) DUM2=DUM2*SQRT5
              IF(J.EQ.20.AND.NORM) DUM2=DUM2*SQRT3
              IF(J.EQ.21) DUM2=DUM1*CGJ
              IF(J.EQ.24.AND.NORM) DUM2=DUM2*SQRT7
              IF(J.EQ.30.AND.NORM) DUM2=DUM2*SQRT5/SQRT3
              IF(J.EQ.33.AND.NORM) DUM2=DUM2*SQRT3
              IJ=IJ+1
CZCZ          NN=IA(LOCI+I)+(LOCJ+J)
              NN=IA(LOCI+I-NUM0)+(LOCJ+J-NUM0)
CZCZ DJUST THE POSITION OF EPS()
CZCZ          IF(RMETHOD.EQ.RESC) THEN
              IF(LMONLAG) THEN
                DIJINT(IJ)=DUM2
              ENDIF
              DEN = EPS(NN)
              DEN=DEN+DEN
              DIJ(IJ) = DUM2*DEN
  570       CONTINUE
  580     CONTINUE
C
C     ----- OVERLAP
C
      T = SQRT(AA1)
      X0 = AX
      Y0 = AY
      Z0 = AZ
      DO 590 J = 1,LJT
        NJ = J
        DO 590 I = 1,LITDER
          NI = I
          CALL VINT
          XS(I,J)=XINT*T
          YS(I,J)=YINT*T
          ZS(I,J)=ZINT*T
  590 CONTINUE
C
      CALL DERI(DXS,DYS,DZS,XS,YS,ZS,LIT,LJT,AI)
C
      IJ=0
      DO 600 I=MINI,MAXI
        IX=IJX(I)
        IY=IJY(I)
        IZ=IJZ(I)
        DO 600 J=MINJ,MAXJ
          JX=IJX(J)
          JY=IJY(J)
          JZ=IJZ(J)
          DUMX=DXS(IX,JX)* YS(IY,JY)* ZS(IZ,JZ)
          DUMY= XS(IX,JX)*DYS(IY,JY)* ZS(IZ,JZ)
          DUMZ= XS(IX,JX)* YS(IY,JY)*DZS(IZ,JZ)
          IJ=IJ+1
CZCZ      IF(RMETHOD.EQ.RESC) THEN
          IF(LMONLAG) THEN
            NN=IA(LOCI+I)+(LOCJ+J)
            if(imode.eq.1)  NN=IA(LOCI+I-NUM0)+(LOCJ+J-NUM0)
            DUMINT=DIJINT(IJ)
            DSINT(NN,1,IAT)=DSINT(NN,1,IAT)+DUMX*DUMINT
            DSINT(NN,2,IAT)=DSINT(NN,2,IAT)+DUMY*DUMINT
            DSINT(NN,3,IAT)=DSINT(NN,3,IAT)+DUMZ*DUMINT
            DSINT(NN,1,JAT)=DSINT(NN,1,JAT)-DUMX*DUMINT
            DSINT(NN,2,JAT)=DSINT(NN,2,JAT)-DUMY*DUMINT
            DSINT(NN,3,JAT)=DSINT(NN,3,JAT)-DUMZ*DUMINT
          ENDIF
          IF(.NOT.NOCON) THEN
            DE(1,IAT)=DE(1,IAT)+(DUMX*DIJ(IJ))
            DE(2,IAT)=DE(2,IAT)+(DUMY*DIJ(IJ))
            DE(3,IAT)=DE(3,IAT)+(DUMZ*DIJ(IJ))
            DE(1,JAT)=DE(1,JAT)-(DUMX*DIJ(IJ))
            DE(2,JAT)=DE(2,JAT)-(DUMY*DIJ(IJ))
            DE(3,JAT)=DE(3,JAT)-(DUMZ*DIJ(IJ))
          ENDIF
  600 CONTINUE
C
  620 CONTINUE
  640 CONTINUE
C
C     ----- END OF PRIMITIVE LOOPS -----
C
      IF(DBG) THEN
         WRITE(IW,9100) II,JJ
         CALL EGOUT(DE,NAT)
      END IF
  760 CONTINUE
  780 CONTINUE
C
C     ----- END OF SHELL LOOPS -----
C
      IF(OUT) THEN
         IF(GOPARR) CALL DDI_GSUMF(1501,DE,3*NAT)
         IF(MASWRK) THEN
            WRITE(IW,9000)
            CALL EGOUT(DE,NAT)
         END IF
         IF(GOPARR) CALL DSCAL(3*NAT,ONE/NPROC,DE,1)
      END IF
      IF(GOPARR .AND. NXT) CALL DDI_DLBRESET
C
      IF(RMETHOD.EQ.RESC) THEN
        IF(GOPARR) CALL DDI_GSUMF(1501,DSINT,L2*3*NAT)
        SVDSKW=DSKWRK
        DSKWRK=.TRUE.
        LREC=0
C       STARTING RECORD FOR THE S DERIVATIVE INTEGRALS
        DO I=1,NAT
          DO J=1,3
            LREC=LREC+1
            CALL RAWRIT(NQRDAF,X(MORDA),DSINT(1,J,I),L2,LREC,0)
          ENDDO
        ENDDO
        DSKWRK=SVDSKW
      ENDIF
C
      RETURN
C
 9000 FORMAT(/10X,33(1H-)/10X,'GRADIENT INCLUDING DENSITY FORCES'/
     *        10X,33(1H-))
 9010 FORMAT(1X,'THE LAGRANGIAN IN THE AO BASIS IS')
 9100 FORMAT(1X,'SDER: SHELLS II,JJ=',2I5)
      END
C*MODULE FMOESD  *DECK ESDNSDER
C>
C>     @brief ESP derivatives
C>
C>     @details Calculate density contributions to ESP derivatives.
C>
C>     @author Takeshi Nagata 
C>
      SUBROUTINE ESDNSDER(IDAX,IDAXX,L1,L2,DA,DB,DC,WRK,WRK1,
     *                    ESPA,WRKESP,NUMFRG,MAPI,MAPJ,MAP3,
     *                    MAXL1D,IREC0,ORBXCH1,ENEXCH1,
     *                    KODEXCH,JODEXCH,IODEXCH,NQMTFG,
     *                    scffrg)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000,ONE=1.0D+00,HALF=0.5D+00)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,SOME1,ORBXCH1,ENEXCH1
      LOGICAL KODEXCH,JODEXCH,IODEXCH
      LOGICAL DOMP2G32
C
C
      DIMENSION DA(1),DB(1),DC(1)
      DIMENSION ESPA(1),WRK(1),WRK1(1),WRKESP(1)
      DIMENSION NUMFRG(1),NQMTFG(*)
      DIMENSION MAPI(1),MAPJ(1),MAP3(MAXL1D,3) 
      DIMENSION scffrg(*)
C
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                MODLMO,NOPDEN,MOFOCK,modfd,modfmm,ncentm
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
CZ    COMMON /SCZVEC/ IDFZVEC,LIPTZVEC,LIPTLG
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      COMMON /GRAD  / DE(3,MXATM)
      DATA   UHF/8HUHF     / 
CZ
CZ    DENSITY DERIVATIVES OF EXTERNAL ELECTROSTATIC POTENTIALS
CZ
      DOMP2G32 = IAND(MODGRD,32).NE.0.AND.MPLEVL.EQ.2
c     Takeshi changed the above line into the following.
c     DOMP2G32 = IAND(MODGRD,2).NE.0.AND.MPLEVL.EQ.2
c     This might improve the accuracy of the approximate MP2 gradient?
      SOME1 = .FALSE.
      IFG  = ICURFG
      JFG  = JCURFG
      KFG  = KCURFG
czcz  ILAY = ICURLAY
      L1I  = IAND(NUMFRG(IFG),65535)
      L0I  = IAND(NQMTFG(IFG),65535)
      NAI  = ISHFT(NUMFRG(IFG),-16)
      NATI = IXFTCH(X(LNATFRG),IFG)
      MULI = IXFTCH(X(LMULFG),IFG)
      NBI  = NAI-MULI+1
      IF (JFG.NE.0) THEN
        L1J  = IAND(NUMFRG(JFG),65535)
        L0J  = IAND(NQMTFG(JFG),65535)
        NAJ  = ISHFT(NUMFRG(JFG),-16)
        NATJ = IXFTCH(X(LNATFRG),JFG)
        MULJ = IXFTCH(X(LMULFG),JFG)
        NBJ  = NAJ-MULJ+1
      END IF
      IF (KFG.NE.0) THEN
        L1K  = IAND(NUMFRG(KFG),65535)
        L0K  = IAND(NQMTFG(KFG),65535)
        NAK  = ISHFT(NUMFRG(KFG),-16)
        NATK = IXFTCH(X(LNATFRG),KFG)
        MULK = IXFTCH(X(LMULFG),KFG)
        NBK  = NAK-MULK+1
      END IF

      ! GET HF DENSITY (WRKESP)
      CALL READHFD(WRKESP,DA,L2)
C
czcz  IF (IFMOSTP.GE.4) THEN
czcz    ! ONLY FOR DIMERS: DODDCOR=T
czcz    DODDCOR=IAND(IXESP,1024).NE.0
czcz    IREC0 = IDMREC0(ILAY)
czcz    IF(DODDCOR) THEN
czcz      IREC0RHF=1
czcz      IF(IREC0.EQ.1) IREC0RHF=NFG*2+1
czcz      IREC0=IREC0RHF
czcz    ENDIF
czcz  END IF
CZ
CZ    CALCULATE -(DI*VIJ*DI+DJ*VIJ*DJ)*SDER FOR DIMER
CZ
      IF (IAND(MODGRD,1).EQ.0.AND.IFMOSTP.GE.4) THEN
CZ
CZ      CONSTRUCT MONOMER LAGRANGIAN TERM
CZ      NOTE: SINCE THE TERMS RELATIVE TO FMOESPA ARE CALCULATED HERE,
CZ      THE TERMS MUST BE SUBTRACTED USING FMOLAG IN GRAD1.SRC. 
CZ
        IF (IFMOSTP.EQ.4) THEN
          LDE2BD = LFMODE + 3*NATFMO
          LDE3BD = LDE2BD
          IF (NBODY.GT.2) LDE3BD = LFMODE + 6*NATFMO
          CALL ESLAGRN(IDAX,IDAXX,L1,L1I,L1J,L1J,NAI,NAJ,NAK,
     *                 NBI,NBJ,NBK,NATI,NATJ,NATJ,ORBXCH1,
     *                 IODEXCH,JODEXCH,KODEXCH,WRK,DB,
     *                 ESPA,MAPI,MAPJ,MAPI,IREC0,
     *                 X(LIAGLOB),X(LDE2BD),X(LDE3BD),NQMTFG,x(lscffrg))
        ELSEIF (IFMOSTP.EQ.9) THEN
          LDE3BD = LFMODE + 6*NATFMO
          CALL ESLAGRN(IDAX,IDAXX,L1,L1I,L1J,L1K,NAI,NAJ,NAK,
     *                 NBI,NBJ,NBK,NATI,NATJ,NATK,ORBXCH1,
     *                 IODEXCH,JODEXCH,KODEXCH,WRK,DB,
     *                 ESPA,MAP3(1,1),MAP3(1,2),MAP3(1,3),IREC0,
     *                 X(LIAGLOB),X(LDE3BD),X(LDE3BD),NQMTFG,x(lscffrg))
        END IF
CZ
CZ      DI, DIJ OR DIJK DERIVATIVES 
CZ
C       IF (MASWRK) THEN
C         WRITE (6,*) 'DENSITY2',L1,L1I,L1J
C         DO I = 1, L1
C           K = (I*I-I)/2
C           WRITE (6,'(6F12.8)') (DA(K+J),J=1,I) 
C         END DO
C       END IF

        CALL VCLR(DE,1,NAT*3)

        if(scftyp.eq.uhf) then
           l3=l1*l1
!          (D*V*D + D*V*D)*S^a
!         Alpha W
           CALL DAREAD(IDAF,IODA,da(l2+1),L3,15,0)
           CALL DMTX2(wrkesp,da(l2+1),na,l1,l1,0)
           CALL CPYTSQ(WRKESP,DA(L2+1),L1,1)
           CALL TFTRI(WRK,ESPA,DA(L2+1),WRK(L2+1),L1,L1,L1)
           call DCOPY(l2,wrk,1,wrkesp,1)
!         Beta W
           call daread(IDAF,IODA,da(l2+1),L3,19,0)
           CALL DMTX2(da,da(l2+1),nb,l1,l1,0)
           CALL CPYTSQ(da,DA(L2+1),L1,1)
           CALL TFTRI(WRK,ESPA,DA(L2+1),WRK(L2+1),L1,L1,L1)
           call DAXPY(l2,one,wrkesp,1,wrk,1)
           CALL DSCAL(L2,-one,WRK,1)
!         recover density
           call daread(IDAF,IODA,da(l2+1),L3,15,0)
           CALL DMTX2(wrkesp,da(l2+1),na,l1,l1,0)
           call daread(IDAF,IODA,da(l2+1),L3,19,0)
           CALL DMTX2(da,da(l2+1),nb,l1,l1,0)
           call daxpy(l2,one,da,1,wrkesp,1)
        else
          CALL CPYTSQ(WRKESP,DA(L2+1),L1,1)
          CALL TFTRI(WRK,ESPA,DA(L2+1),WRK(L2+1),L1,L1,L1)
          CALL DSCAL(L2,-HALF,WRK,1)
        end if

c
c
        CALL SDER(WRK,WRK(L2+1),L1,L2,.FALSE.)

        IF(GOPARR) CALL DDI_GSUMF(2418,DE,NAT*3)
 
        IF (MASWRK) THEN
          IF     (IFMOSTP.EQ.2) THEN
            ! NEVER COME HERE
            CALL FMODEG(IDAX, X(LFMODE),X(LFMOPG),X(LIAGLOB))
          ELSEIF (IFMOSTP.EQ.4) THEN
            NFMOPT = LFMODE + NATFMO*3
            CALL FMODEG(IDAX, X(NFMOPT),X(LFMOPG),X(LIAGLOB))
            NFMOPT = NFMOPT + NATFMO*3
            IF (NBODY.GT.2)
     *      CALL FMODEG(IDAXX,X(NFMOPT),X(LFMOPG),X(LIAGLOB))
          ELSEIF (IFMOSTP.EQ.9) THEN
            NFMOPT = LFMODE + NATFMO*6
            CALL FMODEG(IDAX, X(NFMOPT),X(LFMOPG),X(LIAGLOB))
          END IF
        END IF
      END IF


      ! GET MP2 DENSITY BEFORE IT IS TOO LATE
      IF (DOMP2G32) THEN
        IF     (IFMOSTP.EQ.2) THEN
          ! JUST GET THE MP2 DENSITY CORRECTION
          CALL DAREAD(IDAF,IODA,DA,    L2,307,0)
        ELSEIF (IFMOSTP.GE.4) THEN
          CALL DAREAD(IDAF,IODA,WRKESP,L2, 16,0)
        END IF
      END IF
CZ
CZ    CONSTRUCT DI + DJ (+ DK) BLOCK DIAGONAL MATRIX (STORED IN WRKESP)
CZ
      IF     (IFMOSTP.EQ.4) THEN
        CALL DIMINID(0,JFG,IFG,L1J,L1I,l0j,l0i,NAJ,NAI,NBJ,NBI,L1,DA,
     *               DB,WRK,WRK1,X(LIODFMO),IREC0,X(LIABDFG),X(LJABDFG),
     *               X(LINDAT),X(LIAGLOB),X(LLOCFMO),MAPJ,MAPI,
     *               ORBXCH1,ENEXCH1,JODEXCH,IODEXCH,0,DUM,0,
     *               scffrg(jfg).eq.uhf,scffrg(ifg).eq.uhf,some1)
      ELSEIF (IFMOSTP.EQ.9) THEN
        CALL TRIMINID(KFG,JFG,IFG,L1K,L1J,L1I,L0K,L0J,L0I,NAK,NAJ,NAI,
     *                NBK,NBJ,NBI,L1,DA,DB,DC,WRK,WRK1,X(LIODFMO),IREC0,
     *                X(LIABDFG),X(LJABDFG),X(LINDAT),X(LIAGLOB),
     *                X(LLOCFMO),MAP3(1,3),MAP3(1,2),MAP3(1,1),
     *                ORBXCH1,ENEXCH1,KODEXCH,JODEXCH,IODEXCH,SOME1,
     *      scffrg(kfg).eq.uhf,scffrg(jfg).eq.uhf,scffrg(ifg).eq.uhf)
      END IF
CZ
CZ    NOTE THAT DIMINID AND TRIMINID DESTROY NO. 16 OF DICTIONARY FILE
CZ

CZ
CZ    NOW DA IS DELTA DIJ WHICH IS USED FOR OTHER DERIVATIVES
CZ
      IF (IFMOSTP.GE.4) THEN
        CALL DAXPY(L2,-ONE,WRKESP,1,DA,1)
        CALL DSCAL(L2,-ONE,DA,1)
      END IF

      RETURN
      END
C*MODULE FMOESD  *DECK ESLAGRN
      SUBROUTINE ESLAGRN(IDAX,IDAXX,L1,L1I,L1J,L1K,NAI,NAJ,NAK,
     *                   NBI,NBJ,NBK,NATI,NATJ,NATK,ORBXCH,
     *                   IODEXCH,JODEXCH,KODEXCH,WRK,WRK1,
     *                   ESPA,MAPI,MAPJ,MAPK,IREC0,IAGLOB,
     *                   FDEX,FDEXX,NQMTFG,scffrg)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (HALF=0.5D+00,ZERO=0.0D+00,TWO=2.0D+00,ONE=1.0D+00)
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL ISINI, ISINJ, ISINK, ORBXCH,IODEXCH,JODEXCH,KODEXCH
      LOGICAL uhfcal
CZ
      DIMENSION ESPA(*),WRK(*),WRK1(*)
      DIMENSION IAGLOB(*),scffrg(*)
      DIMENSION MAPI(*),MAPJ(*),MAPK(*) 
      DIMENSION FDEX(3,*),FDEXX(3,*)
      DIMENSION NQMTFG(*)

      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                MODLMO,NOPDEN,MOFOCK,modfd,modfmm,ncentm
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo
      DATA UHF/8HUHF     /
CZ
CZ    THIS CALCULATES LAGRANGIAN-LIKE TERMS (DI+DJ)*VIJ
CZ
      IF (IFMOSTP.NE.4.AND.IFMOSTP.NE.9) THEN
        WRITE(IW,*) 'ESLAGRN MUST BE CALLED IN ESD'
        CALL ABRT
      END IF

      IFG = ICURFG
      JFG = JCURFG
      KFG = KCURFG
      IF (IFG.EQ.0.OR.JFG.EQ.0) THEN
        WRITE(6,*) 'DETECT A BUG IN DIMER ESLAGRN'
        CALL ABRT
      END IF 
CZ
CZ    L1 IS SUPPOSED TO BE FOR TARGET FRAGMENT 
      uhfcal=.false.
      do i=1,nfg
         if(scffrg(i).eq.uhf) uhfcal=.true.
      end do
CZ
      L1A = L1
czcz  DODDCOR=IAND(IXESP,1024).NE.0
CZ
CZ    CALCULATION FOR IFG
CZ
      ILAY=ICURLAY
czcz  KLAY=MIN(ILAY,LAYFRG(IFG))
czcz  IREC0 = IDMREC0(KLAY)
czcz  IF(DODDCOR) THEN
czcz    IREC0RHF=1
czcz    IF(IREC0.EQ.1) IREC0RHF=NFG*2+1
czcz    IREC0=IREC0RHF
czcz  ENDIF
      IDMREC0I=IFG+IREC0
CZCZ  CALL MAKEMOL(IFG,0,0,KLAY,0,0,0,0,0,0,0,.FALSE.)
      CALL MAKEMOL(IFG,0,0,ILAY,0,0,0,0,0,0,0,.FALSE.)
C
      L2I = (L1I*L1I + L1I)/2
      L2J = (L1J*L1J + L1J)/2
      MAXINT = MAX(3*NATI*L2I,3*NATJ*L2J)
      IF (IFMOSTP.EQ.9) THEN
        L2K = (L1K*L1K + L1K)/2
        MAXINT = MAX(MAXINT,3*NATK*L2K)
      END IF
      CALL VALFM(LOADFM)
      LDSINT = LOADFM + 1
      LAST   = LDSINT + MAXINT
      NEED   = LAST - LOADFM - 1
      CALL GETFM(NEED)
CZ 
CZ    HERE THE FIRST ARGUMENT IS DUMMY
CZ
      NCURS  = NCURSH
      NCURSH = 0
      CALL EXTSDER(WRK,X(LDSINT),L1I,L2I,.TRUE.,.TRUE.,0)
      NCURSH = NCURS
      IF(GOPARR) CALL DDI_GSUMF(1501,X(LDSINT),L2I*3*NATI)
C     IF (MASWRK) THEN
C       WRITE(6,*) 'DSINT IN ESLAGRN', ICURFG
C       WRITE(6,'(8F12.8)') (X(LDSINT+I-1),I=1,L2I)
C     END IF

C     CALL RAREADS(IDAFMO,X(LIODFMO),WRK,L2I,IDMREC0I,0)
      CALL READMOND(WRK,ORBXCH,IODEXCH,NAI,NBI,L1I,X(LIODFMO),
     *              IDMREC0I,scffrg(ifg).eq.uhf)
C     WRITE(6,*) 'WWWDENS',IFG,IREC0,WRK(1),WRK(2)
      l3i=l1i*l1i
      if(scffrg(ifg).ne.uhf) CALL CPYTSQ(WRK,WRK(L2I+1),L1I,1)
      if(scffrg(ifg).eq.uhf) then
            call DMTX2(wrk,wrk(l2I+1),nai,l1i,l1i,0)
            call DMTX2(wrk(l2I+1),wrk(l2I+1+L3I),nbi,l1i,l1i,0)
      end if
      IC1 = 0
      DO I = 1, NATI
        IATG=IAGLOB(I)
CZ      IF (MASWRK) WRITE(6,*) 'IATG', IATG
        DO K = 1, 3
          if(scffrg(ifg).eq.uhf) then
            CALL CPYTSQ(WRK,WRK(L2I+1+L3I),L1I,1)
            CALL TFTRI(WRK1,X(LDSINT+IC1*L2I),WRK(L2I+1+L3I),
     *                 WRK1(L2I+1),L1I,L1I,L1I)
            CALL CPYTSQ(WRK(L2I+1),WRK(L2I+1+L3I),L1I,1)
            CALL TFTRI(WRK1(L2I+1),X(LDSINT+IC1*L2I),WRK(L2I+1+L3I),
     *                 WRK1(L2I+1+L3I),L1I,L1I,L1I)
            call daxpy(l2i,one,wrk1(l2i+1),1,wrk1,1)
          else
            CALL TFTRI(WRK1,X(LDSINT+IC1*L2I),WRK(L2I+1),
     *                 WRK1(L2I+1),L1I,L1I,L1I)
            CALL DSCAL(L2I, HALF,WRK1,1)
          end if
          IC1 = IC1 + 1

          DECON = ZERO
          LOOP = 0
          DO II = 1, L1A
            DO JJ = 1, II
              TEMP = ZERO
              LOOP = LOOP + 1
              II1=MAPI(II)
              IJ1=MAPI(JJ)
              II2=MAX(II1,IJ1)
              IJ2=MIN(II1,IJ1)
              ISINI=II1.NE.0.AND.IJ1.NE.0
              IF (ISINI) THEN
                TEMP = WRK1((II2*II2-II2)/2+IJ2)
              END IF

              IF (TEMP.NE.ZERO) THEN
                IF (II.EQ.JJ) THEN
                  DECON = DECON +     TEMP*ESPA(LOOP)
                ELSE
                  DECON = DECON + TWO*TEMP*ESPA(LOOP)
                END IF
              END IF
            END DO
          END DO

          IF (MASWRK) THEN
            IF (IDAX.NE.0) THEN
              DAX = IDAX
              FDEX(K,IATG)  =  FDEX(K,IATG) +  DAX*DECON
            END IF
            IF (IDAXX.NE.0) THEN
              DAXX = IDAXX
              FDEXX(K,IATG) = FDEXX(K,IATG) + DAXX*DECON
            END IF
          END IF
        END DO
      END DO
cz
c     IF (IAND(MODGRD,42).EQ.42.and..not.(resppc(1).eq.-1.and.
c    *                                              resdim.eq.0)) THEN
czcz  Takeshi change the line below by the above.
      if (iand(modgrd,42).eq.42) then
         CALL XMERLAGCNT(IFG,IDAX,IDAXX,L1,L1I,WRK,WRK1,
     *                   IDMREC0I,ESPA,MAPI,x(liodfmo),NQMTFG,
     *                   scffrg(ifg).eq.uhf)
      end if 
CZ
CZ    CALCULATION FOR JFG
CZ
czcz  KLAY=MIN(ILAY,LAYFRG(JFG))
czcz  IREC0 = IDMREC0(KLAY)
czcz  IF(DODDCOR) THEN
czcz    IREC0RHF=1
czcz    IF(IREC0.EQ.1) IREC0RHF=NFG*2+1
czcz    IREC0=IREC0RHF
czcz  ENDIF
      IDMREC0J=JFG+IREC0
CZCZ  CALL MAKEMOL(JFG,0,0,KLAY,0,0,0,0,0,0,0,.FALSE.)
      CALL MAKEMOL(JFG,0,0,ILAY,0,0,0,0,0,0,0,.FALSE.)

      NCURS  = NCURSH
      NCURSH = 0
      CALL EXTSDER(WRK,X(LDSINT),L1J,L2J,.TRUE.,.TRUE.,0)
      NCURSH = NCURS
      IF(GOPARR) CALL DDI_GSUMF(1501,X(LDSINT),L2J*3*NATJ)
C     IF (MASWRK) WRITE(6,'(8F12.8)') (X(LDSINT+L2J+I-1),I=1,L2J)

C     CALL RAREADS(IDAFMO,X(LIODFMO),WRK,L2J,IDMREC0J,0)
      CALL READMOND(WRK,ORBXCH,JODEXCH,NAJ,NBJ,L1J,X(LIODFMO),
     *              IDMREC0J,scffrg(jfg).eq.uhf)

      l3j=l1j*l1j
      if(scffrg(jfg).ne.uhf) CALL CPYTSQ(WRK,WRK(L2J+1),L1J,1)
      if(scffrg(jfg).eq.uhf) then
            call DMTX2(wrk,wrk(l2J+1),naj,l1j,l1j,0)
            call DMTX2(wrk(l2J+1),wrk(l2J+1+L3J),nbj,l1j,l1j,0)
      end if
      IC1 = 0
      DO J = 1, NATJ
        JATG=IAGLOB(J)
        DO K = 1, 3
          if(scffrg(jfg).eq.uhf) then
            CALL CPYTSQ(WRK,WRK(L2j+1+L3J),L1j,1)
            CALL TFTRI(WRK1,X(LDSINT+IC1*L2J),WRK(L2J+1+L3J),
     *                 WRK1(L2J+1),L1J,L1J,L1J)
            CALL CPYTSQ(WRK(L2J+1),WRK(L2J+1+L3J),L1J,1)
            CALL TFTRI(WRK1(l2J+1),X(LDSINT+IC1*L2J),WRK(L2J+1+L3J),
     *                 WRK1(L2J+1+L3J),L1J,L1J,L1J)
            call daxpy(l2J,one,wrk1(L2J+1),1,wrk1,1)
          else
            CALL TFTRI(WRK1,X(LDSINT+IC1*L2J),WRK(L2J+1),
     *                 WRK1(L2J+1),L1J,L1J,L1J)
            CALL DSCAL(L2J, HALF,WRK1,1)
          end if
          IC1 = IC1 + 1

          DECON = ZERO
          LOOP  = 0
          DO II = 1, L1A
            DO JJ = 1, II
              TEMP = ZERO
              LOOP = LOOP + 1
              JI1=MAPJ(II)
              JJ1=MAPJ(JJ)
              JI2=MAX(JI1,JJ1)
              JJ2=MIN(JI1,JJ1)
              ISINJ=JI1.NE.0.AND.JJ1.NE.0
              IF (ISINJ) THEN
                TEMP = WRK1((JI2*JI2-JI2)/2+JJ2)
              END IF

              IF (TEMP.NE.ZERO) THEN
                IF (II.EQ.JJ) THEN
                  DECON = DECON +     TEMP*ESPA(LOOP)
                ELSE
                  DECON = DECON + TWO*TEMP*ESPA(LOOP)
                END IF
              END IF
            END DO
          END DO

          IF (MASWRK) THEN 
            IF (IDAX.NE.0) THEN
              DAX = IDAX
              FDEX(K,JATG)  =  FDEX(K,JATG) +  DAX*DECON
            END IF
            IF (IDAXX.NE.0) THEN
              DAXX = IDAXX
              FDEXX(K,JATG) = FDEXX(K,JATG) + DAXX*DECON
            END IF
          END IF
        END DO
      END DO
czcz
c     IF (IAND(MODGRD,42).EQ.42.and..not.(resppc(1).eq.-1.and.
c    *                                              resdim.eq.0)) THEN
czcz  Takeshi changed the line below by the above.
      if (iand(modgrd,42).eq.42) then
         CALL XMERLAGCNT(JFG,IDAX,IDAXX,L1,L1J,WRK,WRK1,
     *                   IDMREC0J,ESPA,MAPJ,x(liodfmo),NQMTFG,
     *                   scffrg(jfg).eq.uhf)
      end if 
czcz
CZ
CZ    CALCULATION FOR KFG
CZ
      IF (IFMOSTP.EQ.9) THEN
czcz    KLAY=MIN(ILAY,LAYFRG(KFG))
czcz    IREC0 = IDMREC0(KLAY)
czcz    IF(DODDCOR) THEN
czcz      IREC0RHF=1
czcz      IF(IREC0.EQ.1) IREC0RHF=NFG*2+1
czcz      IREC0=IREC0RHF
czcz    ENDIF
        IDMREC0K=KFG+IREC0
czcz    CALL MAKEMOL(KFG,0,0,KLAY,0,0,0,0,0,0,0,.FALSE.)
        CALL MAKEMOL(KFG,0,0,ILAY,0,0,0,0,0,0,0,.FALSE.)

        NCURS  = NCURSH
        NCURSH = 0
        CALL EXTSDER(WRK,X(LDSINT),L1K,L2K,.TRUE.,.TRUE.,0)
        NCURSH = NCURS
        IF(GOPARR) CALL DDI_GSUMF(1501,X(LDSINT),L2K*3*NATK)
C       IF (MASWRK) WRITE(6,'(8F12.8)') (X(LDSINT+L2K+I-1),I=1,L2J)

C       CALL RAREADS(IDAFMO,X(LIODFMO),WRK,L2K,IDMREC0K,0)
        CALL READMOND(WRK,ORBXCH,KODEXCH,NAK,NBK,L1K,X(LIODFMO),
     *                IDMREC0K,scffrg(kfg).eq.uhf)

        CALL CPYTSQ(WRK,WRK(L2K+1),L1K,1)
        IC1 = 0
        DO LL = 1, NATK
          KATG=IAGLOB(LL)
          DO K = 1, 3
            CALL TFTRI(WRK1,X(LDSINT+IC1*L2K),WRK(L2K+1),
     *                 WRK1(L2K+1),L1K,L1K,L1K)
            CALL DSCAL(L2K, HALF,WRK1,1)
            IC1 = IC1 + 1

            DECON = ZERO
            LOOP  = 0
            DO II = 1, L1A
              DO JJ = 1, II
                TEMP = ZERO
                LOOP = LOOP + 1
                KI1=MAPK(II)
                KJ1=MAPK(JJ)
                KI2=MAX(KI1,KJ1)
                KJ2=MIN(KI1,KJ1)
                ISINK=KI1.NE.0.AND.KJ1.NE.0
                IF (ISINK) THEN
                  TEMP = WRK1((KI2*KI2-KI2)/2+KJ2)
                END IF

                IF (TEMP.NE.ZERO) THEN
                  IF (II.EQ.JJ) THEN
                    DECON = DECON +     TEMP*ESPA(LOOP)
                  ELSE
                    DECON = DECON + TWO*TEMP*ESPA(LOOP)
                  END IF
                END IF
              END DO
            END DO

            IF (MASWRK) THEN 
              IF (IDAX.NE.0) THEN
                DAX = IDAX
                FDEX(K,KATG)  =  FDEX(K,KATG) +  DAX*DECON
              END IF
              IF (IDAXX.NE.0) THEN
                DAXX = IDAXX
                FDEXX(K,KATG) = FDEXX(K,KATG) + DAXX*DECON
              END IF
            END IF
          END DO
        END DO
 
czcz
c       IF (IAND(MODGRD,42).EQ.42.and..not.(resppc(1).eq.-1.and.
c    *                                              resdim.eq.0)) THEN
czcz    Takeshi changed the line below by the above.
        if (iand(modgrd,42).eq.42.and..not.uhfcal) then
           CALL XMERLAGCNT(KFG,IDAX,IDAXX,L1,L1K,WRK,WRK1,
     *                     IDMREC0K,ESPA,MAPK,x(liodfmo),NQMTFG,
     *                     scffrg(kfg).eq.uhf)
        end if 
czcz
      END IF
CZ
      CALL RETFM(NEED)
CZ
CZ    RESTORE THE DIMER OR TRIMER CALCULATION
CZ
      CALL MAKEMOL(IFG,JFG,KFG,ILAY,0,0,0,0,0,0,0,.TRUE.)
      RETURN
      END
C*MODULE FMOESD  *DECK EXTHELFEY
      SUBROUTINE EXTHELFEY(IDAX,IDAXX,DENAB,HFINT,L2,FMODEX,FMODEXX,
     *                     LCPHF)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL IANDJ,OUT,DBG,NORM,DOUBLE,GOPARR,DSKWRK,MASWRK,NXT,SVDSKW
C
C  MAGIC NUMBERS: S(1)+P(3)+D(6)+F(10)+G(15)=35
C                 BASIS FUNCTION TYPES=5
C                 MAXIMUM BASIS TYPE SQUARED = (15)**2 = 225
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000, MXAO=8192)
C
      DIMENSION DENAB(L2),HFINT(L2,3,NAT)
      DIMENSION IJX(35),IJY(35),IJZ(35),DIJ(225),
     *          XIN(5,5,5,2),YIN(5,5,5,2),ZIN(5,5,5,2)
      DIMENSION FMODEX(3,*),FMODEXX(3,*)
      LOGICAL LCPHF,fastvesp
CZCZ
C
      COMMON /DSTV  / XINT,YINT,ZINT,T,X0,Y0,Z0,XI,YI,ZI,
     *                XJ,YJ,ZJ,NI,NJ,CX,CY,CZ
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /ROOT  / XX,U(13),W(13),NROOTS
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /RELWFN/ RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,IQRORD,MODQR,NESOC,
     *                NRATOM,NUMU,NQMTR,NQRDAF,MORDA,NDARELB
      COMMON /FMCOM / X(1)
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
      PARAMETER (RLN10=2.30258D+00)
      PARAMETER (PI212=1.1283791670955D+00)
      PARAMETER (SQRT3=1.73205080756888D+00)
      PARAMETER (SQRT5=2.23606797749979D+00)
      PARAMETER (SQRT7=2.64575131106459D+00)
C
      DATA DEBUG/8HDEBUG   /, DBUGME/8HHELFEY  /, GRD1/8HGRD1    /,
     *     RESC/8HRESC    /
C
C  THE IJX, IJY, AND IJZ ARRAYS CONTAIN THE POWERS OF THE CARTESIAN
C  GAUSSIANS PLUS 1 IN EVERY PLACE.  THE REASON FOR THE PLUS ONE IS
C  THAT THEY ARE USED TO INDEX AN ARRAY RUNNING FROM 1-5 CORRESPONDING
C  TO 0-4 IN THE POWER.
C
      DATA IJX/ 1, 2, 1, 1, 3, 1, 1, 2, 2, 1,
     *          4, 1, 1, 3, 3, 2, 1, 2, 1, 2,
     *          5, 1, 1, 4, 4, 2, 1, 2, 1, 3,
     *          3, 1, 3, 2, 2/
      DATA IJY/ 1, 1, 2, 1, 1, 3, 1, 2, 1, 2,
     *          1, 4, 1, 2, 1, 3, 3, 1, 2, 2,
     *          1, 5, 1, 2, 1, 4, 4, 1, 2, 3,
     *          1, 3, 2, 3, 2/
      DATA IJZ/ 1, 1, 1, 2, 1, 1, 3, 1, 2, 2,
     *          1, 1, 4, 1, 2, 1, 2, 3, 3, 2,
     *          1, 1, 5, 1, 2, 1, 2, 4, 4, 1,
     *          3, 3, 2, 2, 3/
C
C     ----- HELMANN-FEYNMAN GRADIENT TERM -----
C     INTEGRAL TYPE IS <II/H'/JJ> = <II/V'/JJ>
C     RESC RUNS DO NOT CONTRACT THE INTEGRALS WITH DENSITY
C
      DBG = (EXETYP.EQ.DEBUG  .OR.  EXETYP.EQ.DBUGME)  .AND.  MASWRK
      OUT = (EXETYP.EQ.DEBUG  .OR.  EXETYP.EQ.DBUGME  .OR.
     *       EXETYP.EQ.GRD1   .OR.  NPRINT.EQ.-3)
      IF(DBG) WRITE(IW,9000)
C
      TOL = RLN10*ITOL
      NORM = NORMF.NE.1 .OR. NORMP.NE.1
      IF(RMETHOD.EQ.RESC) CALL VCLR(HFINT,1,L2*3*NAT)
CZCZ
czcz  IC0 = 0
czcz  IC1 = 1
      MAXIC = NATFMO
cz    IF (LCPHF) THEN 
cz      IC0   = NAT
cz      IC1   = 1
cz      MAXIC = NAT 
cz      MAXIC = NAT + NATFMO
cz    END IF
CZCZ
      call setatz(1,MAXIC,fastvesp,lfvesp,needfv)
c     setatz allocates memory. One should be careful in returining it. 
C
C     INITIALIZATION FOR PARALLEL
C
      NXT = IBTYP.EQ.1
      IPCOUNT = ME - 1
      NEXT = -1
      MINE = -1
C
C     ----- I SHELL
C
      DO 600 II = 1,NSHELL
C
C           GO PARALLEL!
C
      IF(NXT .AND. GOPARR) THEN
         MINE = MINE + 1
         IF(MINE.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
         IF(NEXT.NE.MINE) GO TO 600
      END IF
C
      I = KATOM(II)
      XI = C(1,I)
      YI = C(2,I)
      ZI = C(3,I)
      I1 = KSTART(II)
      I2 = I1+KNG(II)-1
      LIT = KTYPE(II)
      MINI = KMIN(II)
      MAXI = KMAX(II)
      LOCI = KLOC(II)-MINI
C
C     ----- J SHELL
C
      DO 580 JJ = 1,II
C
C           GO PARALLEL!
C
        IF((.NOT.NXT) .AND. GOPARR) THEN
           IPCOUNT = IPCOUNT + 1
           IF(MOD(IPCOUNT,NPROC).NE.0) GO TO 580
        END IF
C
        J = KATOM(JJ)
        XJ = C(1,J)
        YJ = C(2,J)
        ZJ = C(3,J)
        J1 = KSTART(JJ)
        J2 = J1+KNG(JJ)-1
        LJT = KTYPE(JJ)
        MINJ = KMIN(JJ)
        MAXJ = KMAX(JJ)
        LOCJ = KLOC(JJ)-MINJ
        NROOTS = (LIT+LJT+1-2)/2 + 1
        RR = (XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
        IANDJ = II .EQ. JJ
C
C     ----- I PRIMITIVE
C
        DO 520 IG = I1,I2
        AI = EX(IG)
        ARRI = AI*RR
        AXI = AI*XI
        AYI = AI*YI
        AZI = AI*ZI
        CSI = CS(IG)
        CPI = CP(IG)
        CDI = CD(IG)
        CFI = CF(IG)
        CGI = CG(IG)
C
C     ----- J PRIMITIVE
C
        JGMAX = J2
        IF(IANDJ) JGMAX = IG
        DO 500 JG = J1,JGMAX
          AJ = EX(JG)
          AA = AI+AJ
          AA1 = ONE/AA
          DUM = AJ*ARRI*AA1
          IF(DUM .GT. TOL) GO TO 500
          FAC = EXP(-DUM)
          CSJ = CS(JG)
          CPJ = CP(JG)
          CDJ = CD(JG)
          CFJ = CF(JG)
          CGJ = CG(JG)
          AX = (AXI+AJ*XJ)*AA1
          AY = (AYI+AJ*YJ)*AA1
          AZ = (AZI+AJ*ZJ)*AA1
C
C     ----- DENSITY FACTOR
C
          DOUBLE=IANDJ.AND.IG.NE.JG
          JMAX = MAXJ
          NN = 0
          DUM1 = ZERO
          DUM2 = DUM1
          dijmax=0
          DO 360 I = MINI,MAXI
            IF(I.EQ.1) DUM1=CSI*FAC
            IF(I.EQ.2) DUM1=CPI*FAC
            IF(I.EQ.5) DUM1=CDI*FAC
            IF(I.EQ.8.AND.NORM) DUM1=DUM1*SQRT3
            IF(I.EQ.11) DUM1=CFI*FAC
            IF(I.EQ.14.AND.NORM) DUM1=DUM1*SQRT5
            IF(I.EQ.20.AND.NORM) DUM1=DUM1*SQRT3
            IF(I.EQ.21) DUM1=CGI*FAC
            IF(I.EQ.24.AND.NORM) DUM1=DUM1*SQRT7
            IF(I.EQ.30.AND.NORM) DUM1=DUM1*SQRT5/SQRT3
            IF(I.EQ.33.AND.NORM) DUM1=DUM1*SQRT3
C
            IF(IANDJ) JMAX = I
            DO 360 J = MINJ,JMAX
              IF(J.EQ.1) THEN
                DUM2=DUM1*CSJ
                IF( .NOT. DOUBLE) GO TO 350
                IF(I .GT. 1) THEN
                 DUM2 = DUM2+CSI*CPJ*FAC
                ELSE
                 DUM2 = DUM2+DUM2
                END IF
              ELSE IF(J.EQ.2) THEN
                DUM2=DUM1*CPJ
                IF(DOUBLE) DUM2 = DUM2+DUM2
              ELSE IF(J.EQ.5) THEN
                DUM2=DUM1*CDJ
                IF(DOUBLE) DUM2 = DUM2+DUM2
              ELSE IF(J.EQ.8.AND.NORM) THEN
                DUM2 = DUM2*SQRT3
              ELSE IF(J.EQ.11) THEN
                DUM2=DUM1*CFJ
                IF(DOUBLE) DUM2=DUM2+DUM2
              ELSE IF(J.EQ.14.AND.NORM) THEN
                DUM2=DUM2*SQRT5
              ELSE IF(J.EQ.20.AND.NORM) THEN
                DUM2=DUM2*SQRT3
              ELSE IF(J.EQ.21) THEN
                DUM2=DUM1*CGJ
                IF(DOUBLE) DUM2=DUM2+DUM2
              ELSE IF(J.EQ.24.AND.NORM) THEN
                DUM2=DUM2*SQRT7
              ELSE IF(J.EQ.30.AND.NORM) THEN
                DUM2=DUM2*SQRT5/SQRT3
              ELSE IF(J.EQ.33.AND.NORM) THEN
                DUM2=DUM2*SQRT3
              END IF
C
  350         NN = NN+1
              IF(RMETHOD.EQ.RESC) THEN
                DIJ(NN)=DUM2*PI212*AA1
              ELSE
                NDUM = IA(LOCI+I)+(LOCJ+J)
                DEN = DENAB(NDUM)
                IF(.NOT.IANDJ.OR.I.NE.J) DEN=DEN+DEN
                DIJ(NN)=DUM2*DEN*PI212*AA1
              ENDIF
              if(abs(DIJ(NN)).gt.dijmax) dijmax=abs(DIJ(NN))
  360     CONTINUE
C
C     ..... HELLMANN-FEYNMAN TERM .....
C
          AAX = AA*AX
          AAY = AA*AY
          AAZ = AA*AZ
          DO 480 IC = 1, MAXIC
CZCZ        HELFEY TERMS FOR FMO ESP USED TO BE CALCULATED IN ES1DER 
CZCZ        IN THE NEW VERSION, HOWEVER, HELFEY TERMS ARE CALCULATED HERE
CZCZ        BESIDES, ESD FRACTION IS CALCULATED HERE UTILIZING FMOATFRG 
            if(fastvesp) then
              icind=lfvesp+(ic-1)*6
              FRACV=x(icind)
              FRACESP=x(icind+1)
              ZNUC=x(icind+2)
              CX=x(icind+3)
              CY=x(icind+4)
              CZ=x(icind+5)
            else
            CALL FMOATFRG(IC,X(LINDAT),X(LINDATG),X(LIAGLOB),
     *                    X(LIALOC),X(LIABDFG),X(LJABDFG),
     *                    X(LINDBD),X(LFMOZAN),X(LFMOC),
     *                    NATFMO+NBDFG,X(LUNTXYZ),X(LPOPMAT),
     *                    KATOM(II),KATOM(JJ),FRACV,FRACESP,
     *                    KFG,ZNUC,CX,CY,CZ)
            endif
            if(lcphf) then
              IF (FRACESP.EQ.ZERO.AND.FRACV.EQ.ZERO) GOTO 480
            else
              IF (FRACESP.EQ.ZERO) GOTO 480
            endif
c           IF (FRACV.EQ.ZERO.AND.FRACESP.EQ.ZERO) GOTO 480
c           WRITE(6,*) 'WWWATOMH',IC,FRACV,FRACESP,lcphf
czcz        if (lcphf.and.mod(icc,32).eq.0) 
czcz *         write(6,*) 'fracesp',znuc 
CZCZ
            XX = AA*((AX-CX)**2+(AY-CY)**2+(AZ-CZ)**2)
            IF(NROOTS.LE.3) CALL RT123
            IF(NROOTS.EQ.4) CALL ROOT4
            IF(NROOTS.EQ.5) CALL ROOT5
            DO 420 K = 1,NROOTS
              UU = AA*U(K)
              WW = W(K)*ZNUC
              WW=WW*(UU+UU)
              TT = ONE/(AA+UU)
              T = SQRT(TT)
              X0 = (AAX+UU*CX)*TT
              Y0 = (AAY+UU*CY)*TT
              Z0 = (AAZ+UU*CZ)*TT
              DO 400 J = 1,LJT
                NJ = J
                DO 400 I = 1,LIT
                  NI = I
                  CALL VINT
                  XIN(I,J,K,1) = XINT
                  YIN(I,J,K,1) = YINT
                  ZIN(I,J,K,1) = ZINT*WW
                  CALL DVINT
                  XIN(I,J,K,2) = XINT
                  YIN(I,J,K,2) = YINT
                  ZIN(I,J,K,2) = ZINT*WW
  400         CONTINUE
  420       CONTINUE
           IJ=0
           DO 460 I=MINI,MAXI
            IX=IJX(I)
            IY=IJY(I)
            IZ=IJZ(I)
            JMAX=MAXJ
            IF(IANDJ) JMAX=I
            DO 460 J=MINJ,JMAX
             JX=IJX(J)
             JY=IJY(J)
             JZ=IJZ(J)
             DUMX = ZERO
             DUMY = ZERO
             DUMZ = ZERO
             DO 440 K = 1,NROOTS
              DUMX = DUMX+XIN(IX,JX,K,2)*YIN(IY,JY,K,1)*ZIN(IZ,JZ,K,1)
              DUMY = DUMY+XIN(IX,JX,K,1)*YIN(IY,JY,K,2)*ZIN(IZ,JZ,K,1)
  440         DUMZ = DUMZ+XIN(IX,JX,K,1)*YIN(IY,JY,K,1)*ZIN(IZ,JZ,K,2)
             IJ=IJ+1
             DUM=DIJ(IJ)
             IF(RMETHOD.EQ.RESC) THEN
               NN=IA(LOCI+I)+(LOCJ+J)
               HFINT(NN,1,IC)=HFINT(NN,1,IC)+DUMX*DUM
               HFINT(NN,2,IC)=HFINT(NN,2,IC)+DUMY*DUM
               HFINT(NN,3,IC)=HFINT(NN,3,IC)+DUMZ*DUM
             ELSE
               IF (IDAX.NE.0) THEN
                 DAX  = IDAX
                 DAX = DAX*DUM*FRACESP
                 FMODEX(1,IC) = FMODEX(1,IC) + DAX*DUMX
                 FMODEX(2,IC) = FMODEX(2,IC) + DAX*DUMY
                 FMODEX(3,IC) = FMODEX(3,IC) + DAX*DUMZ
                 IF (LCPHF) THEN
                   IF (FRACV.NE.ZERO) THEN
                     DAX = IDAX
                     DAX = DAX*DUM*FRACV
                     FMODEX(1,IC) = FMODEX(1,IC) + DAX*DUMX
                     FMODEX(2,IC) = FMODEX(2,IC) + DAX*DUMY
                     FMODEX(3,IC) = FMODEX(3,IC) + DAX*DUMZ
                   END IF
                 END IF
               END IF
               IF (IDAXX.NE.0) THEN
                 DAXX = IDAXX
                 DAXX = DAXX*DUM*FRACESP
                 FMODEXX(1,IC) = FMODEXX(1,IC) + DAXX*DUMX
                 FMODEXX(2,IC) = FMODEXX(2,IC) + DAXX*DUMY
                 FMODEXX(3,IC) = FMODEXX(3,IC) + DAXX*DUMZ
                 IF (LCPHF) THEN
                   IF (FRACV.NE.ZERO) THEN
                     DAXX = IDAXX
                     DAXX = DAXX*DUM*FRACV
                     FMODEXX(1,IC) = FMODEXX(1,IC) + DAXX*DUMX
                     FMODEXX(2,IC) = FMODEXX(2,IC) + DAXX*DUMY
                     FMODEXX(3,IC) = FMODEXX(3,IC) + DAXX*DUMZ
                   END IF
                 END IF
               END IF
CZCZ
             ENDIF
             IF(DBG) WRITE(IW,9100) IC,II,JJ,IJ,DIJ(IJ),DUMX,DUMY,
     +                         DUMZ,DE(1,IC),DE(2,IC),DE(3,IC)
  460       CONTINUE
  480     CONTINUE
  500 CONTINUE
  520 CONTINUE
C
C     ----- END OF *PRIMITIVE* LOOPS -----
C
      IF(DBG) THEN
         WRITE(IW,9010) II,JJ
         CALL EGOUT(DE,NAT)
      END IF
  580 CONTINUE
  600 CONTINUE
      if(fastvesp) call retfm(needfv)
C
C     ----- END OF *SHELL* LOOPS -----
C
      IF(OUT) THEN
         IF(GOPARR) CALL DDI_GSUMF(1502,DE,3*NAT)
         IF(MASWRK) THEN
            WRITE(IW,9000)
            CALL EGOUT(DE,NAT)
         END IF
         IF(GOPARR) CALL DSCAL(3*NAT,ONE/NPROC,DE,1)
      END IF
      IF(GOPARR .AND. NXT) CALL DDI_DLBRESET
      IF(RMETHOD.EQ.RESC) THEN
        IF(GOPARR) CALL DDI_GSUMF(1502,HFINT,L2*3*NAT)
        SVDSKW=DSKWRK
        DSKWRK=.TRUE.
        LREC=3*3*NAT
C       STARTING RECORD FOR THE HELLMANN-FEYNMAN INTEGRALS
        DO I=1,NAT
          DO J=1,3
            LREC=LREC+1
            CALL RAWRIT(NQRDAF,X(MORDA),HFINT(1,J,I),L2,LREC,0)
          ENDDO
        ENDDO
        DSKWRK=SVDSKW
      ENDIF
C
      RETURN
C
 9000 FORMAT(/10X,22(1H-)/10X,'HELLMANN-FEYNMAN FORCE'/10X,22(1H-))
 9010 FORMAT(1X,'HELFEY: SHELLS II,JJ=',2I5)
 9100 FORMAT(1X,'IC',I3,' II, JJ, I',3I5,1P,4E15.7/
     *       25X,'DE(1,2,3 AND IC)',1P,3E15.7)
      END
C*MODULE FMOESD  *DECK ZVLGMULT 
      SUBROUTINE ZVLGMULT(NOCVRK,IDA,KFG,IPTLG,DODISTR,ZVLAG,WRK1,WRK2)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (ONE=1.0D+00)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL DODISTR
      DIMENSION IPTLG(1), ZVLAG(1)
      DIMENSION WRK1(1), WRK2(1)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      IF (IDA.EQ.0) RETURN
      DA = IDA
      DO I = 1, NOCVRK
        WRK2(I) = DA * WRK1(I)
      END DO
      IF (DODISTR) THEN
        CALL ZLAGACCGET(0,KFG,IPTLG,NOCVRK,WRK2)
      ELSE
        IF (MASWRK) THEN
          CALL DAXPY(NOCVRK,ONE,WRK2,1,ZVLAG(IPTLG(KFG)),1)
        END IF
      END IF

      RETURN
      END
C*MODULE FMOESD  *DECK 1etddijpot 
      SUBROUTINE getddijpot(IDDA,MODE,DA,L2,DDIJPOT)

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00)
CZ    LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION DA(*),DDIJPOT(1)
C
CZ    COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
CZ   *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FMCOM / X(1)
CZ    COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
CZ   *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C     COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
CZ    COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
CZ   *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
CZ   *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
CZ   *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
CZ    COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                MODLMO,NOPDEN,MOFOCK,modfd,modfmm,ncentm
CZ    COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
CZ   *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
CZ   *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
CZ   *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
CZ   *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
CZ   *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
CZ   *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
CZ   *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
CZ   *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
CZ   *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
CZ   *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
CZ   *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
CZ   *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg
CZ    COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
CZ   *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
CZ   *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
CZ   *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
CZ   *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo
C
CZ
CZ    This routine calculates the potential at external ESP atoms 
CZ    due to the delta D_IJ.
CZ
      RESPPCI = RESPPC(1)
      IF (RESPPCI.EQ.ZERO.OR.IDDA.EQ.0) RETURN
      DDA = IDDA
CZ
CZ    DYNAMIC MEMORY ALLOCATION 
CZ
      maxnatnfg = maxnat*nfg
      CALL VALFM(LOADFM)
      lpotmp = LOADFM + 1
      last   = lpotmp + maxnatnfg
      NEED   = LAST-LOADFM-1
      CALL GETFM(NEED)
CZ
      call vclr(x(lpotmp),1,maxnatnfg)
      call epoten2(MODE,one,x(lpotmp),da,natfmo,l2)
CZ    IF (GOPARR) CALL DDI_GSUMF(2999,X(LPOTMP),maxnatnfg)
CZ    IF (MASWRK) CALL DAXPY(maxnatnfg,DDA,X(LPOTMP),1,DDIJPOT,1)
      CALL DAXPY(maxnatnfg,DDA,X(LPOTMP),1,DDIJPOT,1)

      CALL RETFM(NEED)
      RETURN
      END
C*MODULE FMOESD  *DECK ESPPCDER 
C>
C>     @brief Point-charge derivative contributions for ESP
C>
C>     @details Add point-charge derivative contributions for ESP. 
C>
C>     @author Takeshi Nagata 
C>
      SUBROUTINE ESPPCDER(ISTEP,ILAY,LOADHF,LOADM,DA,IPTLG,
     *                    ZVLAG,ZPPCPOT,FMODE,ORBXCH,NUMFRG,
     *                    IODFMO,LAYFRG,SCFFRG,ISGDDI,IREC0,
     *                    NGRFMO,MANNOD,MASTID,NQMTFG,mulfg)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      LOGICAL GOPARR,MASWRK,DSKWRK
      LOGICAL ISGDDI,MYJOB
      LOGICAL ORBXCH
      LOGICAL DOSCZV,DODISTR,LCNTCAL
C
      INTEGER DDI_WORLD,DDI_GROUP
      PARAMETER (DDI_WORLD=0,DDI_GROUP=1)
      PARAMETER (MXATM=2000,MAXPST=10)
CZ    PARAMETER (MXFRG=1050)

      PARAMETER (ONE=1.0D+00)
CZCZ  PARAMETER (HALF=0.5D+00,ZERO=0.0D+00)
C
      DIMENSION DA(1)
      DIMENSION LOADM(*),NUMFRG(*),NQMTFG(*)
      DIMENSION IODFMO(*),LAYFRG(*),SCFFRG(*)
      DIMENSION NGRFMO(MAXPST,*),MANNOD(*),MASTID(*)
      DIMENSION FMODE(3,*)
      DIMENSION IPTLG(*),ZVLAG(*),ZPPCPOT(*)
      DIMENSION mulfg(*)
C
CZ    COMMON /PCMTMP/ IDSP(MXATM+MXFRG*5),DPCMFRG(6,MXFRG),
CZ   *                EGPCM(3,MXATM)
      COMMON /FMCOM / X(1)
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                MODLMO,NOPDEN,MOFOCK,modfd,modfmm,ncentm
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
CZ    COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
cz    COMMON /MLTFMO/ Q_MUL,IMLTFMO,ISWPFD,ISWNEW1
CZ    COMMON /MLTPNT/ LDELEPOT,LDELQSE,LQSETMP,LFZVEC
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
czcz  COMMON /PCMPNT/ LXYZRE,LSSFE,LLIST,LALPCM,LRINPCM,LINAPCM,LINFPCM,
czcz *                LINIPCM,LMEPCM,LAXYZCT,LXYZCT2,LNVERT,LQSN,LQSE,
czcz *                LQFS,LQIND,LISPHE,LVAD,LQOR,LVECMUL,LAIPRJ,LFIPRJ,
czcz *                LPEL,LPCMCDR,LDAI,LIDDAI,LQSND,LQSED
      COMMON /SCZLAG/ LZVLAG,LZVWRK,LYALAG,LYAWRK
CZ    COMMON /SCZVEC/ IDFZVEC,LIPTZVEC,LIPTLG
czcz
      common /ppcpnt/ lddijpot,lzppcpot,lvipot,lgrdtest
czcz
C
      DATA RMC/8HMCSCF   /,UHF/8HUHF     /
CZ
CZ    THIS SUBROUTINE COMPUTES MULLIKEN CHARGE DERIVATIVE CONTRIBUTION
CZ    TO THE GRADIENT.
CZ    THE CORRESPONDING AO DERIVATIVES AND HELMANN-FEYNMAN TERMS
CZ    ARE CALCULATED IN ESVDER AND EXTHELFEY.
CZ    THE CORRESPONDING LAGRANGE TERMS AND DELTA DIJ ARE COMPUTED 
CZ    THROUGH FMOESPA AND STORED IN ESDNSDER.
CZ
CZ    ISTEP=0
CZ    IAND(MODGRD,32).EQ.0: DERIVATIVE INTEGRALS
CZ    IAND(MODGRD,32).NE.0: JUST GET LAGRANGIAN
CZ
CZ    ISTEP=1 (ALWAYS COMES WITH IAND(MODGRD,32).NE.0)
CZ    DERIVATIVE INTEGRALS+RESPONSE TERM
CZ
C
      DOSCZV  = IAND(MODGRD, 32).NE.0
      DODISTR = IAND(MODPAR,512).NE.0
      LCNTCAL = (ISTEP.EQ.0.AND..NOT.DOSCZV).OR.(ISTEP.EQ.1.AND.DOSCZV)
CZCZ  DODDCOR=IAND(IXESP,1024).NE.0
      maxnatnfg = maxnat*nfg
CZ    IF (MASWRK) WRITE(6,*) 'LCNTCAL', ISTEP,LCNTCAL

CZ
CZ    WORLD SCOPE
CZ
      IF (ISGDDI) CALL GDDI_SCOPE(DDI_WORLD)
C
      IF     (ISTEP.EQ.0) THEN
        IF (GOPARR) CALL DDI_GSUMF(3003,X(LDDIJPOT),maxnatnfg)
cz      IF (MASWRK) THEN
cz        WRITE(6,*) 'POTENTIAL AT ATOMS DUE TO DELTA D_IJ'
cz        LXX = LDDIJPOT - 1
cz        WRITE(6,'(8F12.8)') (X(LXX+I),I=1,maxnatnfg)
cz      END IF
      ELSEIF (ISTEP.EQ.1) THEN
        ! LQSETMP HERE IS POTENTIAL DUE TO Z-VECTORS
        ! SEE FMOCP.SRC
cz      IF (MASWRK) THEN
cz        WRITE(6,*) 'POTENTIAL AT ATOMS DUE TO DELTA D_IJ'
cz        LXX = LDDIJPOT - 1
cz        WRITE(6,'(8F12.8)') (X(LXX+I),I=1,maxnatnfg)
cz      END IF
        IF (GOPARR) CALL DDI_GSUMF(3003,ZPPCPOT,maxnatnfg)
        CALL DAXPY(maxnatnfg,ONE,ZPPCPOT,1,X(LDDIJPOT),1)
cz      IF (MASWRK) THEN
cz        WRITE(6,*) 'ZPPCPOT'
cz        WRITE(6,'(8F12.8)') (ZPPCPOT(I),I=1,maxnatnfg)
cz      END IF
cz      IF (MASWRK) THEN
cz        WRITE(6,*) 'POTENTIAL AT ATOMS DUE TO DELTA D_IJ'
cz        LXX = LDDIJPOT - 1
cz        WRITE(6,'(8F12.8)') (X(LXX+I),I=1,maxnatnfg)
cz      END IF
      END IF
C
CZ
CZ    SWITCH TO GROUP
CZ
      IF (ISGDDI) CALL GDDI_SCOPE(DDI_GROUP)
      IF (ISGDDI.AND.NGRFMO(1,ILAY).NE.0)
     *  CALL FMOPRE(ILAY,1,NGRFMO,MANNOD,MASTID)
C
      JCURFG  = 0
      KCURFG  = 0
      ICURLAY = ILAY
      IF (ISGDDI) CALL GDDICOUNT(-1,LGROUP,MYJOB)
      DO 230 IIFG = 1,NFG
        IFG = IIFG
        IF (LOADHF.EQ.1) IFG = LOADM(IIFG)
C
        IF (LAYFRG(IFG).LT.ILAY) GOTO 230
        ICURFG = IFG
        IF (ISGDDI) THEN
          CALL GDDICOUNT(0,LGROUP,MYJOB)
          IF (.NOT.MYJOB) GOTO 230
        END IF
C
        CALL CLOSDA('DELETE')
        CALL OPENDA(0)
        CALL MAKEMOL(IFG,0,0,ILAY,0,0,0,0,0,0,0,.TRUE.)
        L1 = NUM
        L2 = (L1*L1+L1)/2
        L3 =  L1*L1

        IDMREC0I = IFG + IREC0
C
        IF (DOSCZV.or.scffrg(ifg).eq.uhf) THEN
          NQI    = IAND(NQMTFG(IFG),65535)
          NAI    = ISHFT(NUMFRG(IFG),-16)
          NOCI   = NAI
          NVRI   = NQI - NOCI
          NOCVRI = NOCI*NVRI
C
          NOCIB  = 0
          NVRIB  = 0
          LCCBO  = 0
          LCCBV  = 0
          lzvwrkb= lzvwrk
          NNUM   = NOCVRI
          if(scffrg(ifg).eq.uhf) then
            NBI=NAI + 1 - mulfg(ifg)
            NOCIB = NBI
            NVRIB = NQI - NOCIB
            NOCVRIB = NOCIB * NVRIB
            LCCBO   = L3+1+L2
            LCCBV   = L3+1+L2 + L1 * NOCIB
            lzvwrkB = LZVWRK  + NOCVRI
            NNUM    = NOCVRI  + NOCVRIB
          end if

C
          if(scffrg(ifg).eq.uhf) lenrec=l3*2+l1*2
          if(scffrg(ifg).ne.uhf) lenrec=l3  +l1
          ! MO COEF. AND ORBITAL ENERGIES
          CALL RAREADS(IDAFMO,IODFMO,DA(L2+1),lenrec,IDMREC0I,0)
          CALL DMTX2(DA,DA(L2+1),NAI,L1,L1,NAI)
czcz          write(6,*) 'MO coeff. in ESPPCDER',ifg
czcz            call prsq(da(l2+1),l1,l1,l1)
        ELSE
          CALL READMOND(DA,ORBXCH,SCFFRG(IFG).EQ.RMC,NA,NB,L1,
     *                  IODFMO,IDMREC0I,scffrg(ifg).eq.uhf)
        END IF

C
CZ      IF (MASWRK) WRITE(6,*) 'DENSITY FOR ',IFG
CZ      CALL PRTRI(DA,L1)

        CALL VALFM(LOADFM)
        if(scffrg(ifg).ne.uhf) then
          LWRT   = LOADFM + 1
          LWRK1  = LWRT   + L2
          LWRK2  = LWRK1  + L3
          LWRK3  = LWRK2  + L3
          LDSINT = LWRK3  + L3
          LAST   = LDSINT + L2*NAT*3
          NDPPC  = LAST - LOADFM -1
        else if(scffrg(ifg).eq.uhf) then
          LWRT   = LOADFM + 1
          LWRK1  = LWRT   + L2 * 2
          LWRK2  = LWRK1  + L3 * 2
          LWRK3  = LWRK2  + L3 * 2
          LDSINT = LWRK3  + L3 * 2
          LAST   = LDSINT + L2*NAT*3
          NDPPC  = LAST - LOADFM -1
        end if
        CALL GETFM(NDPPC)

czcz    IF (LCNTCAL) THEN
czcz      CALL VCLR(DE,1,NAT*3)
CZ
CZ        GET Z-VECTOR FOR FRAGMENT IFG
CZ
czcz      IF (ISTEP.EQ.1) THEN
czcz        IF (DODISTR) THEN
czcz          CALL ZVECPUTGET(1,0,IFG,NOCVRI,X(LIPTZVEC),X(LWRK1))
czcz        ELSE
czcz          CALL DCOPY(NOCVRI,ZVEC0(IPTZC(IFG)),1,X(LWRK1),1)
czcz        END IF 
czcz        CALL SWBASIS(0,L1,NOCI,NVRI,DA(L2+1),X(LWRK1),NVRI,
czcz *                   X(LWRK2),L1,X(LWRK3))
czcz        CALL SQ2TRI(L1,L1,X(LWRK2),X(LFZVEC),HALF)
czcz      END IF 
czcz    END IF


CZ
CZ      GET LAGRANGIAN CONTRIBUTION FOR Z-VECTOR CALCULATION
CZ
        IF (ISTEP.EQ.0.AND.DOSCZV) THEN
          CALL calcppclag(ifg,l1,l2,NOCI,NVRI,DA(L2+1),DA(L2+1+L1*NOCI),
     *                    x(lddijpot),x(lzvwrk),x(lwrt),x(lwrk1),
     *                    NOCIB,NVRIB,scffrg(ifg).eq.uhf,
     *                    DA(LCCBO),DA(LCCBV),x(lzvwrkb))
          CALL ZVLGMULT(NNUM,1,IFG,IPTLG,DODISTR,ZVLAG,X(LZVWRK),
     *                  X(LWRK1))
        END IF
CZ
CZ      CALCULATE THE OVERLAP DERIVATIVE
CZ
        IF (LCNTCAL) THEN
          CALL VCLR(DE,1,NAT*3)
          NCURS  = NCURSH
          NCURSH = 0
          CALL EXTSDER(X(LWRK1),X(LDSINT),L1,L2,.TRUE.,.TRUE.,0)
          NCURSH = NCURS
          IF(GOPARR) CALL DDI_GSUMF(1501,X(LDSINT),L2*3*NAT)

          ! note that DA(L2+1) (MO coeff.) dies after calcppcder
          call calcppcder(ifg,l1,l2,DA,x(ldsint),x(lddijpot),
     *                   DE,x(lwrt),x(lwrk1),x(lwrk2),x(lwrk3),DA(L2+1),
     *                   scffrg(ifg).eq.uhf,nai,nbi)

          IF (GOPARR) CALL DDI_GSUMF(2418,DE,NAT*3)
cz        write(6,*) 'GRAD CONT IN ESPPCDER',IFG
cz        do iatt = 1, nat
cz          write(6,'(3F12.8)') de(1,iatt), de(2,iatt), de(3,iatt)
cz        end do
          IF (MASWRK) CALL FMODEG(1,FMODE,X(LFMOPG),X(LIAGLOB))
        END IF

        CALL RETFM(NDPPC)
  230 CONTINUE
C
      IF (ISGDDI) CALL GDDICOUNT( 1,LGROUP,MYJOB)
C
      RETURN
      END
C*MODULE FMOESD  *DECK calcppcder 
C>
C>     @brief Point-charge derivative contributions for ESP
C>
C>     @details Add point-charge derivative contributions for ESP. 
C>
C>     @author Takeshi Nagata 
C>
      SUBROUTINE calcppcder(ifg,l1,l2,da,dsint,ddijpot,DE,
     *                      wrt,SS,DD,wrk3,wrk4,uhfcal,nai,nbi)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      LOGICAL GOPARR,MASWRK,DSKWRK,uhfcal
      logical lparasw
C
      PARAMETER (MXATM=2000, MXGTOT=20000, MXSH=5000)
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00,half=0.5D+00)
C
      dimension wrt(1), SS(l1,*), DD(l1,*), wrk3(l1,*),wrk4(l1,*)
      dimension da(1), DSINT(L2,3,*),ddijpot(maxnat,*),DE(3,*)
cz
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
CZ
CZ    The calculation of the ESPPC derivative contribution
CZ
      CALL VCLR(DE,1,NAT*3)
CZ
CZ    ESTIMATE OF THE OVERLAP INTEGRAL
CZ
      DUMMY  = ZERO
      IDUMMY = 0
      CALL COOVLP(0,wrt,DUMMY,L1,L1,L2,NAT,
     *            MXGTOT,NSHELL,EX,CS,CP,CD,CF,CG,CH,CI,
     *            KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,
     *            1,1,DUMMY,DUMMY,DUMMY,DUMMY,DUMMY,DUMMY,DUMMY,
     *            DUMMY,IDUMMY,IDUMMY,IDUMMY,IDUMMY,IDUMMY,IDUMMY,
     *            IDUMMY,C,C)
      CALL CPYTSQ(WRT,SS,L1,1)

      l3=l1*l1
c
      if(.not.uhfcal) then
        CALL CPYTSQ(DA, DD,L1,1)
        SCAL = half
      else if(uhfcal) then
        CALL DMTX2(DA,DA(L2+1),NAi,L1,L1,0)
        CALL CPYTSQ(DA, DD,L1,1)
        CALL DMTX2(DA(l2+1),DA(L2+1+L3),NBI,L1,L1,0)
        CALL CPYTSQ(DA(l2+1), DD(1,l1+1),L1,1)
        SCAL = one
      end if
cz    elec=TRACEP(da,wrt,l1)
cz    write(6,*) 'no of elec', elec, ifg

C
C     INITIALIZE PARALLEL
C
cz    lparasw = .t., parallelized here
cz    lparasw = .f., parallelized in TFTRI
cz
      LPARASW = L1.LE.MXSQN3().AND.GOPARR
      if (lparasw) IPCOUNT = ME - 1
C
      DO 100 IAT = 1, NAT
C
C       GO PARALLEL!
C
        IF (lparasw) THEN
           IPCOUNT = IPCOUNT + 1
           IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 100
        END IF
C
        DO IC = 1, 3
          ! WRK2 is DA
          ! calculate D*dS/da*D: stored in wrk3 (square form)
          CALL TFTRI(WRT,DSINT(1,IC,IAT),DD,WRK3,L1,L1,L1)
          if(uhfcal) then
            CALL TFTRI(WRT(l2+1),DSINT(1,IC,IAT),DD(1,l1+1),
     *                 WRK3,L1,L1,L1)
          end if
C
          CALL CPYTSQ(WRT,WRK3,L1,1)
          if(uhfcal)  CALL CPYTSQ(WRT(l2+1),WRK3(1,l1+1),L1,1)

          ! stored in wrk4 (dS/da)
          CALL CPYTSQ(DSINT(1,IC,IAT),WRK4,L1,1)

          DO II=1, NSHELL
            JAT=KATOM(II)
            MINI=KMIN(II)
            MAXI=KMAX(II)
            LOCI=KLOC(II)-MINI

            sum = zero 
            DO I=MINI,MAXI
              INUM = LOCI + I
              do ibs = 1, L1
                ! wrk4: ds/da, wrk3: D*ds/da*D 
                SUM = SUM + DD(IBS,INUM)*WRK4(IBS,INUM)
     *                    - SCAL*SS(IBS,INUM)*WRK3(IBS,INUM)
                if(uhfcal) SUM = SUM + DD(IBS,INUM+l1)*WRK4(IBS,INUM)
     *                    - SCAL*SS(IBS,INUM)*WRK3(IBS,INUM+l1)
              end do
            ENDDO
            if (lparasw) then
              DE(IC,IAT) = DE(IC,IAT) + SUM * DDIJPOT(jat,ifg)
            else
              if (maswrk)
     *        DE(IC,IAT) = DE(IC,IAT) + SUM * DDIJPOT(jat,ifg)
            end if
          END DO

        END DO
  100 CONTINUE

      RETURN
      END
C*MODULE FMOESD  *DECK calcppclag
C>
C>     @brief Lagrangian-like contributions for point-charge ESP
C>
C>     @details Add Lagrangian-like contributions for point-charge ESP.
C>
C>     @author Takeshi Nagata 
C>
      SUBROUTINE calcppclag(ifg,l1,l2,NOCC,NVIR,COCC,CVIR,ddijpot,
     *                      zvwrk,wrt,SS,NOCIB,NVRIB,uhfcal,
     *                      COCCB,CVIRB,zvwrkb)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      PARAMETER (MXATM=2000, MXGTOT=20000, MXSH=5000)
      PARAMETER (PT5=0.5D+00)
      PARAMETER (ZERO=0.0D+00)
C
      logical uhfcal
C
      DIMENSION COCC(L1,*),CVIR(L1,*),DDIJPOT(maxnat,*)
      DIMENSION COCCB(L1,*),CVIRB(L1,*)
      DIMENSION ZVWRK(NVIR,*),ZVWRKB(NVRIB,*)
      DIMENSION WRT(1), SS(L1,*)
C
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
CZ
CZ    LAGRANGIAN CONTRIBUTION DUE TO ESPPC
CZ
      if(uhfcal) then
        SCAL=PT5
        nloop=2
      else
        SCAL=PT5
        nloop=1
      end if

CZ
CZ    ESTIMATE OF THE OVERLAP INTEGRAL
CZ
      DUMMY  = ZERO
      IDUMMY = 0
      CALL COOVLP(0,wrt,DUMMY,L1,L1,L2,NAT,
     *            MXGTOT,NSHELL,EX,CS,CP,CD,CF,CG,CH,CI,
     *            KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,
     *            1,1,DUMMY,DUMMY,DUMMY,DUMMY,DUMMY,DUMMY,DUMMY,
     *            DUMMY,IDUMMY,IDUMMY,IDUMMY,IDUMMY,IDUMMY,IDUMMY,
     *            IDUMMY,C,C)
      CALL CPYTSQ(WRT,SS,L1,1)

      DO iloop=1,nloop
        if(nloop.eq.2.and.iloop.eq.2) then
           NV=NVRIB
           NO=NOCIB
        else if(iloop.eq.1) then
           NV=NVIR
           NO=NOCC
        end if
        DO IR = 1, NV
          DO IO = 1, NO

            CNT  = ZERO
            DO II=1, NSHELL
              IAT=KATOM(II)
              MINI=KMIN(II)
              MAXI=KMAX(II)
              LOCI=KLOC(II)-MINI

              TMP = ZERO
              DO I=MINI,MAXI
                INUM = LOCI + I
                TMP1 = ZERO
                TMP2 = ZERO
                DO IBS = 1, L1
                  if(iloop.eq.1) then
                    TMP1 = TMP1 + CVIR(IBS,IR)*SS(IBS,INUM)
                    TMP2 = TMP2 + COCC(IBS,IO)*SS(IBS,INUM)
                  else if(iloop.eq.2) then
                    TMP1 = TMP1 + CVIRB(IBS,IR)*SS(IBS,INUM)
                    TMP2 = TMP2 + COCCB(IBS,IO)*SS(IBS,INUM)
                  end if
                end do
                if(iloop.eq.1) then
                  TMP = TMP + COCC(INUM,IO)*TMP1+CVIR(INUM,IR)*TMP2
                else if(iloop.eq.2) then
                  TMP = TMP + COCCB(INUM,IO)*TMP1+CVIRB(INUM,IR)*TMP2
                end if
              ENDDO
              CNT = CNT + TMP*DDIJPOT(iat,ifg)
            END DO

            if(iloop.eq.1) then
              ZVWRK(IR,IO) = SCAL*CNT
            else if(iloop.eq.2) then
              ZVWRKB(IR,IO) = SCAL*CNT
            end if
          END DO
CZ        write(6,'(8F12.8)') (ZVWRK(IR,IIK),IIK=1,NOCC)
        END DO
      END DO
      
      RETURN
      END
C*MODULE FMOESD  *DECK calcqindz 
      SUBROUTINE calcqindz(IFG,L1,L2,zvec,s,qindz,WKL)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      PARAMETER (MXATM=2000, MXGTOT=20000, MXSH=5000)
C
      LOGICAL GOPARR,MASWRK,DSKWRK
C
      DIMENSION ZVEC(1), S(1), QINDZ(maxnat,*)
      DIMENSION WKL(1) 
      PARAMETER (ZERO=0.0D+00)
C
c     COMMON /FMCOM / X(1)
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2
c     COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
c     COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
c    *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
c    *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
c    *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
c    *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
c    *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
c    *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
c    *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
c    *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
c    *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
c    *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
c    *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
c    *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
       DUMMY = ZERO
      IDUMMY = 0
      CALL COOVLP(0,S,DUMMY,L1,L1,L2,NAT,
     *            MXGTOT,NSHELL,EX,CS,CP,CD,CF,CG,CH,CI,
     *            KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,
     *            1,1,DUMMY,DUMMY,DUMMY,DUMMY,DUMMY,DUMMY,DUMMY,
     *            DUMMY,IDUMMY,IDUMMY,IDUMMY,IDUMMY,IDUMMY,IDUMMY,
     *            IDUMMY,C,C)

      CALL VCLR(WKL,1,L1)
      LOOP = 0
      DO I = 1, L1
        sum = zero
        DO J = 1, I-1
          LOOP = LOOP + 1
          TMP = ZVEC(LOOP) * S(LOOP) 
          WKL(J) = WKL(J) + TMP
          SUM = SUM + TMP
        END DO
        LOOP = LOOP + 1
        WKL(I) = SUM + ZVEC(loop)*S(loop)
      enddo

      DO KK=1, NSHELL
        IAT=KATOM(KK)
        MINI=KMIN(KK)
        MAXI=KMAX(KK)
        LOCI=KLOC(KK)-MINI

        TMP = ZERO
        DO I=MINI,MAXI
          TMP = TMP + WKL(LOCI+I) 
        ENDDO
        IF (MASWRK) QINDZ(IAT,IFG) = QINDZ(IAT,IFG) + TMP
      END DO
      RETURN
      END
C*MODULE FMOESD    *DECK PPCVINT
      SUBROUTINE PPCVINT(qindz,CNT,LL2,SOME)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION MOROKM
C
      LOGICAL SOME,UNCON
      LOGICAL IANDJ,DOUBLE,GOPARR,DSKWRK,MASWRK,SCREEN
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000, MAXSH=84)
C
      DIMENSION VBLK(784)
      DIMENSION DIJ(784),IJX(784),IJY(784),IJZ(784),
     *          XIN(343),YIN(343),ZIN(343),CONI(MAXSH),CONJ(MAXSH),
     *          IX(84),IY(84),IZ(84),JX(84),JY(84),JZ(84)
CZCZ
      DIMENSION qindz(maxnat,*),CNT(LL2)
CZCZ
C
C       IF TX,TY,TZ NEEDED, THESE FIRST THREE MUST:
C            A) BE ALLOCATED DYNAMICALLY,
C            B) BE GLOBAL SUMMMED,
C            C) BE SAVED TO THE DIRECT ACCESS FILE AT UNUSED RECORDS
C-XYZ-DIMENSION TX(LL2),TY(LL2),TZ(LL2)
C-XYZ-DIMENSION TXBLK(784),TYBLK(784),TZBLK(784)
C-XYZ-DIMENSION FTX(784),FTY(784),FTZ(784)
C
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
CZ    COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
CZ   *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
CZ   *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
CZ   *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
CZ   *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
CZ   *                MODLMO,NOPDEN,MOFOCK,modfd,modfmm,ncentm
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
CZ    COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
CZ   *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
CZ   *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
CZ   *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
CZ   *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /ROOT  / XX,U(13),W(13),NROOTS
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SCINP / VLAMB,SCREEN
      COMMON /STV   / XINT,YINT,ZINT,TAA,X0,Y0,Z0,
     *                XI,YI,ZI,XJ,YJ,ZJ,NI,NJ
      COMMON /WERMIT/ W1,W2(2),W3(3),W4(4),W5(5),W6(6),W7(7),
     *                W8(8),W9(9),W10(10),
     *                W11(11),W12(12),W13(13),W14(14),W15(15)
      COMMON /SHLNRM/ PNRM(84)
      COMMON /SYMIND/ TOL,II,JJ,LIT,LJT,MINI,MINJ,MAXI,MAXJ,IANDJ
      COMMON /RELWFN/ RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,IQRORD,MODQR,NESOC,
     *                NRATOM,NUMU,NQMTR,NQRDAF,MORDA,NDARELB
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      COMMON /FMCOM / X(1)
C
CZ    COMMON /GRAD  / DE(3,MXATM)
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2
CZ    COMMON /IJPAIR/ IA(MXAO)
C
      PARAMETER (ZERO=0.0D+00, PT5=0.5D+00, ONE=1.0D+00, TWO=2.0D+00,
     *           PI212=1.1283791670955D+00, RLN10=2.30258D+00)
C
      DATA JX / 0, 1, 0, 0, 2, 0, 0, 1, 1, 0,
     *          3, 0, 0, 2, 2, 1, 0, 1, 0, 1,
     *          4, 0, 0, 3, 3, 1, 0, 1, 0, 2,
     *          2, 0, 2, 1, 1,
     *          5, 0, 0, 4, 4, 1, 0, 1, 0, 3,
     *          3, 2, 0, 2, 0, 3, 1, 1, 2, 2,
     *          1,
     *          6, 0, 0, 5, 5, 1, 0, 1, 0, 4,
     *          4, 2, 0, 2, 0, 4, 1, 1, 3, 3,
     *          0, 3, 3, 2, 1, 2, 1, 2/
      DATA IX / 1, 8, 1, 1,15, 1, 1, 8, 8, 1,
     *         22, 1, 1,15,15, 8, 1, 8, 1, 8,
     *         29, 1, 1,22,22, 8, 1, 8, 1,15,
     *         15, 1,15, 8, 8,
     *         36, 1, 1,29,29, 8, 1, 8, 1,22,
     *         22,15, 1,15, 1,22, 8, 8,15,15,
     *          8,
     *         43, 1, 1,36,36, 8, 1, 8, 1,29,
     *         29,15, 1,15, 1,29, 8, 8,22,22,
     *          1,22,22,15, 8,15, 8,15/
      DATA JY / 0, 0, 1, 0, 0, 2, 0, 1, 0, 1,
     *          0, 3, 0, 1, 0, 2, 2, 0, 1, 1,
     *          0, 4, 0, 1, 0, 3, 3, 0, 1, 2,
     *          0, 2, 1, 2, 1,
     *          0, 5, 0, 1, 0, 4, 4, 0, 1, 2,
     *          0, 3, 3, 0, 2, 1, 3, 1, 2, 1,
     *          2,
     *          0, 6, 0, 1, 0, 5, 5, 0, 1, 2,
     *          0, 4, 4, 0, 2, 1, 4, 1, 3, 0,
     *          3, 2, 1, 3, 3, 1, 2, 2/
      DATA IY / 1, 1, 8, 1, 1,15, 1, 8, 1, 8,
     *          1,22, 1, 8, 1,15,15, 1, 8, 8,
     *          1,29, 1, 8, 1,22,22, 1, 8,15,
     *          1,15, 8,15, 8,
     *          1,36, 1, 8, 1,29,29, 1, 8,15,
     *          1,22,22, 1,15, 8,22, 8,15, 8,
     *         15,
     *          1,43, 1, 8, 1,36,36, 1, 8,15,
     *          1,29,29, 1,15, 8,29, 8,22, 1,
     *         22,15, 8,22,22, 8,15,15/
      DATA JZ / 0, 0, 0, 1, 0, 0, 2, 0, 1, 1,
     *          0, 0, 3, 0, 1, 0, 1, 2, 2, 1,
     *          0, 0, 4, 0, 1, 0, 1, 3, 3, 0,
     *          2, 2, 1, 1, 2,
     *          0, 0, 5, 0, 1, 0, 1, 4, 4, 0,
     *          2, 0, 2, 3, 3, 1, 1, 3, 1, 2,
     *          2,
     *          0, 0, 6, 0, 1, 0, 1, 5, 5, 0,
     *          2, 0, 2, 4, 4, 1, 1, 4, 0, 3,
     *          3, 1, 2, 1, 2, 3, 3, 2/
      DATA IZ / 1, 1, 1, 8, 1, 1,15, 1, 8, 8,
     *          1, 1,22, 1, 8, 1, 8,15,15, 8,
     *          1, 1,29, 1, 8, 1, 8,22,22, 1,
     *         15,15, 8, 8,15,
     *          1, 1,36, 1, 8, 1, 8,29,29, 1,
     *         15, 1,15,22,22, 8, 8,22, 8,15,
     *         15,
     *          1, 1,43, 1, 8, 1, 8,36,36, 1,
     *         15, 1,15,29,29, 8, 8,29, 1,22,
     *         22, 8,15, 8,15,22,22,15/
C
      DATA MOROKM/8HMOROKUMA/
      DATA NONE,RNONE/4HNONE,8HNONE    /
CZ
CZ    AS OF 4/7/11, THIS ROUTINE COMPUTES THE ELECTROSTATIC POTENTIAL 
CZ    CONTRIBUTION DUE TO Z-VECTOR CHARGES TO "A" MATRIX OF Z-VECTOR 
CZ    EQUATIONS IN THE ESP-PC APPROXIMATION
CZ
      UNCON=RMETHOD.NE.RNONE.AND.MOD(MODQR,2).EQ.1
      TOL = RLN10*ITOL
C     NORM = NORMF .NE. 1 .OR. NORMP .NE. 1
      IF(SOME  .AND.  SCREEN) WRITE(IW,9010) VLAMB
CZCZ  IF(DOESP.AND.LZINT) THEN
C        ZBLK IS REUSED FOR SOME OTHER PURPOSE.
CZCZ     WRITE(IW,*) 'STORAGE NOT ALLOCATED IN HSANDT'
CZCZ     CALL ABRT
CZCZ  END IF
C
C     ----- MOPAC INTEGRALS ARE DONE ELSEWHERE -----
C
      IF(MPCTYP.NE.NONE) THEN
         CALL MPCINT
         RETURN
      END IF
C
C     ----- RESET SOME PARAMETERS FOR MOROKUMA DECOMPOSITIONS -----
C     ISAVE .EQ. 0 : SAVE S, H, AND T TO DAF 12, 11, AND 13
C     ISAVE .EQ. 1 : SAVE S, H, AND T TO DAF 12, 11, AND 13
C                    AND SAVE S AND H TO DAF 312 AND 311
C     NOTE THAT LL2 IS ALWAYS (NUM*NUM+NUM)/2,
C     L1,L2 MAY BE SMALLER THAN USUAL FOR A MONOMER IN A MOROKUMA RUN
C
      IF (RUNTYP.EQ.MOROKM) THEN
         CALL STINT1(ISTART,IEND,JSTART,LOCIJ,NATST,NATED,ISAVE,L1,L2)
      ELSE
czcz     RESPPCI = RESPPC(1)
         ISTART = 1
         IEND   = NSHELL
         JSTART = 1
         LOCIJ  = 0
         NATST  = 1
         NATED  = NATFMO
         ISAVE  = 0
         L1 = NUM
         IF(UNCON) L1=NUMU
         L2 = (L1*(L1+1))/2
      END IF
C
      IF(GOPARR) THEN
             CALL VCLR(CNT,1,LL2)
CZCZ         CALL VCLR(H ,1,LL2)
CZCZ         CALL VCLR(S ,1,LL2)
CZCZ         CALL VCLR(T ,1,LL2)
C-XYZ-   CALL VCLR(TX,1,LL2)
C-XYZ-   CALL VCLR(TY,1,LL2)
C-XYZ-   CALL VCLR(TZ,1,LL2)
CZCZ         IF(LZINT) CALL VCLR(Z,1,LL2)
CZCZ         IF(DOESP) CALL VCLR(ESP1E,1,LL2)
      END IF
C
C     ----- INTIALIZE PARALLEL -----
C
      IPCOUNT = ME - 1
C
C     ----- I SHELL -----
C
      DO 720 II = ISTART,IEND
         I = KATOM(II)
         XI = C(1,I)
         YI = C(2,I)
         ZI = C(3,I)
         I1 = KSTART(II)
         I2 = I1+KNG(II)-1
         LIT = KTYPE(II)
         MINI = KMIN(II)
         MAXI = KMAX(II)
         LOCI = KLOC(II)-MINI-LOCIJ
C
C     ----- J SHELL -----
C
         DO 700 JJ = JSTART,II
C
C     ----- GO PARALLEL! (STATIC LOAD BALANCING) -----
C
            IF (GOPARR) THEN
               IPCOUNT = IPCOUNT + 1
               IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 700
            END IF
C
            J = KATOM(JJ)
            XJ = C(1,J)
            YJ = C(2,J)
            ZJ = C(3,J)
            J1 = KSTART(JJ)
            J2 = J1+KNG(JJ)-1
            LJT = KTYPE(JJ)
            MINJ = KMIN(JJ)
            MAXJ = KMAX(JJ)
            LOCJ = KLOC(JJ)-MINJ-LOCIJ
            NROOTS = (LIT+LJT-2)/2+1
            RR = (XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
            IANDJ = II .EQ. JJ
C
C     ----- PREPARE INDICES FOR PAIRS OF (I,J) FUNCTIONS
C
            IJ = 0
            MAX = MAXJ
            DO 160 I = MINI,MAXI
               NX = IX(I)
               NY = IY(I)
               NZ = IZ(I)
               IF (IANDJ) MAX = I
               DO 140 J = MINJ,MAX
                  IJ = IJ+1
                  IJX(IJ) = NX+JX(J)
                  IJY(IJ) = NY+JY(J)
                  IJZ(IJ) = NZ+JZ(J)
C                 FT (IJ) = 2*(JX(J)+JY(J)+JZ(J)) + 3
C-XYZ-            FTX(IJ) = 2* JX(J)              + 1
C-XYZ-            FTY(IJ) = 2*       JY(J)        + 1
C-XYZ-            FTZ(IJ) = 2*             JZ(J)  + 1
  140          CONTINUE
  160       CONTINUE
C
CZCZ        CALL VCLR( SBLK,1,IJ)
CZCZ        CALL VCLR( TBLK,1,IJ)
            CALL VCLR( VBLK,1,IJ)
C-XYZ-      CALL VCLR(TXBLK,1,IJ)
C-XYZ-      CALL VCLR(TYBLK,1,IJ)
C-XYZ-      CALL VCLR(TZBLK,1,IJ)
CZCZ        IF(LZINT.OR.DOESP) CALL VCLR(ZBLK,1,IJ)
C
C     ----- I PRIMITIVE
C
            JGMAX = J2
            DO 520 IG = I1,I2
               AI = EX(IG)
               ARRI = AI*RR
               AXI = AI*XI
               AYI = AI*YI
               AZI = AI*ZI
               CALL SETCONI(CONI,IG,0)
C
C     ----- J PRIMITIVE
C
               IF (IANDJ) JGMAX = IG
               DO 500 JG = J1,JGMAX
                  AJ = EX(JG)
                  AA = AI+AJ
                  AA1 = ONE/AA
                  DUM = AJ*ARRI*AA1
                  IF (DUM .GT. TOL) GO TO 500
                  FAC = EXP(-DUM)
                  CALL SETCONI(CONJ,JG,0)
                  AX = (AXI+AJ*XJ)*AA1
                  AY = (AYI+AJ*YJ)*AA1
                  AZ = (AZI+AJ*ZJ)*AA1
C
C     ----- DENSITY FACTOR
C
C     THE ONLY REASON WHY -ILZ WORKS WITH THIS DENSITY THAT ASSUMES
C     HERMITICITY IS BECAUSE <I|-ILZ|I>=0 (MOMENTUM QUENCHING).
C
                  DOUBLE=IANDJ.AND.IG.NE.JG
                  MAX = MAXJ
                  NN = 0
                  DTWO=ONE
                  IF(DOUBLE) DTWO=TWO
C                 NOTE THAT PNRM FACTORS FOR S AND P SHELLS ARE 1.
                  SPDIJ=CS(IG)*CP(JG)*FAC
                  DO 220 I = MINI,MAXI
                     IF (IANDJ) MAX = I
                     FACI=FAC*CONI(I)*PNRM(I)*DTWO
                     NN1=NN+1
                     DO 200 J = MINJ,MAX
                        NN = NN+1
                        DIJ(NN)=FACI*CONJ(J)*PNRM(J)
C                    WRITE(6,*) 'WWWDIJ',NN,I,J,II,JJ,DIJ(NN)
  200                CONTINUE
C            CORRECT FOR L-SHELL DOUBLE COUNTING OF THE SP
C            OFF-DIAGONAL TERMS (FOR NON-L SHELLS CSI*CPJ IS ZERO).
C            NN1 POINTS TO THE APPROPRIATE DENSITY ELEMENT
                     IF(MINJ.LE.1.AND.I.GT.1.AND.DOUBLE)
     *                 DIJ(NN1)=DIJ(NN1)*PT5+SPDIJ
  220             CONTINUE
C
C     ----- NUCLEAR ATTRACTION
C     EL SIGUIENTE DO SOLO EN CASO NO SCREEN.
C
                  IF (.NOT.SCREEN) THEN
                     DUM = PI212*AA1
                     DO 400 I = 1,IJ
                        DIJ(I) = DIJ(I)*DUM
  400                CONTINUE
                  END IF
C
                  AAX = AA*AX
                  AAY = AA*AY
                  AAZ = AA*AZ
C
C     -NCHMAT- IS NONZERO IF THERE ARE EXTERNAL CHARGES WHICH
C     PERTURB THE SYSTEM, SUCH AS IF CHARMM IS IN USE.  NOTE
C     THAT THERE IS ALSO A NUCLEAR REPULSION TERM WHICH IS NOT
C     INCLUDED HERE, IT IS IN THE CHARMM INTERFACE CODE.
C
                  DO 460 IC = NATST,NATED
                     ! qindz is the charge due to z-vector
                     CALL FMOATFRG2(IC,X(LINDAT),X(LINDATG),X(LIAGLOB),
     *                              X(LIALOC),X(LIABDFG),X(LJABDFG),
     *                              X(LINDBD),X(LFMOZAN),X(LFMOC),
     *                              NATFMO+NBDFG,X(LUNTXYZ),qindz,
     *                              KATOM(II),KATOM(JJ),FRACV,FRACESP,
     *                              KFG,ZNUC,CX,CY,CZ,
     *                              idumi,idumj,idumk,iduml)
                     ZNUC = FRACESP
                     IF (ABS(ZNUC).LT.1.0D-08) GOTO 460
C
C         CHECKING IF IT IS AN SCREENED CALCULATION, IF SO CALL SCR1,
C         OTHERWISE, FOLLOW THE GAMESS CODE.
C
                  IF (SCREEN) THEN
                      NN=0
                      DO 425 I=MINI,MAXI
                         L1A=JX(I)
                         M1A=JY(I)
                         N1A=JZ(I)
                         MAX=MAXJ
                         IF(IANDJ) MAX=I
                         DO 415 J=MINJ,MAX
                            NN=NN+1
                            L2B=JX(J)
                            M2B=JY(J)
                            N2B=JZ(J)
                            VAL=FDNAI(VLAMB,AI,AJ,
     *                                L1A,M1A,N1A,L2B,M2B,N2B,
     *                                XI,YI,ZI,XJ,YJ,ZJ,CX,CY,CZ)
                            VBLK(NN) = VBLK(NN) + DIJ(NN)*VAL*ZNUC
 
  415                    CONTINUE
  425                 CONTINUE
                  ELSE
                     XX = AA*((AX-CX)**2+(AY-CY)**2+(AZ-CZ)**2)
                     IF (NROOTS.LE.3) CALL RT123
                     IF (NROOTS.EQ.4) CALL ROOT4
                     IF (NROOTS.EQ.5) CALL ROOT5
                     IF (NROOTS.GE.6) CALL ROOT6
                     MM = 0
                     DO 430 K = 1,NROOTS
                        UU = AA*U(K)
                        WW = W(K)*ZNUC
                        TT = ONE/(AA+UU)
                        TAA = SQRT(TT)
                        X0 = (AAX+UU*CX)*TT
                        Y0 = (AAY+UU*CY)*TT
                        Z0 = (AAZ+UU*CZ)*TT
                        IN = -7+MM
                        J0 = 2
C
C                       J0 SKIPS THE TRIVIAL COMBINATION NI=NJ=1
C                       THAT IS DONE EXPLICITLY NOW
C
                        XIN(IN+8) = W1
                        YIN(IN+8) = W1
                        ZIN(IN+8) = W1*WW
                        DO 420 I = 1,LIT
                           IN = IN+7
                           NI = I
                           DO 410 J = J0,LJT
                              JN = IN+J
                              NJ = J
                              CALL STVINT
                              XIN(JN) = XINT
                              YIN(JN) = YINT
                              ZIN(JN) = ZINT*WW
  410                      CONTINUE
                           J0 = 1
  420                   CONTINUE
                        MM = MM+49
  430                CONTINUE
                     DO 450 I = 1,IJ
                        NX = IJX(I)
                        NY = IJY(I)
                        NZ = IJZ(I)
                        DUM = ZERO
                        MM = 0
                        DO 440 K = 1,NROOTS
                           DUM = DUM+XIN(NX+MM)*YIN(NY+MM)*ZIN(NZ+MM)
                           MM = MM+49
  440                   CONTINUE
                        VBLK(I) = VBLK(I) + DUM*DIJ(I)
  450                CONTINUE
                   END IF
C
  460             CONTINUE
C
C     ----- END OF PRIMITIVE LOOPS -----
C
  500          CONTINUE
  520       CONTINUE
C
C     ----- COPY BLOCK INTO H-CORE, OVERLAP, AND KINETIC ENERGY MATRICES
C
            MAX = MAXJ
            NN = 0
            DO 620 I = MINI,MAXI
               LI = LOCI+I
               IN = (LI*(LI-1))/2
               IF (IANDJ) MAX = I
               DO 600 J = MINJ,MAX
                  LJ = LOCJ+J
                  JN = LJ+IN
                  NN = NN+1
                  CNT(JN) = VBLK(NN)
CZCZ              H(JN) =  TBLK(NN) + VBLK(NN)
CZCZ              S(JN) =  SBLK(NN)
CZCZ              T(JN) =  TBLK(NN)
C-XYZ-            TX(JN) = TXBLK(NN)
C-XYZ-            TY(JN) = TYBLK(NN)
C-XYZ-            TZ(JN) = TZBLK(NN)
CZCZ              IF(LZINT) Z(JN) = ZBLK(NN)
CZCZ              IF(DOESP) ESP1E(JN)=ZBLK(NN)
  600          CONTINUE
  620       CONTINUE
C
C     ----- END OF SHELL LOOPS -----
C
  700    CONTINUE
  720 CONTINUE
C
C     ----- SUM UP PARTIAL CONTRIBUTIONS IF PARALLEL -----
C
      IF (GOPARR) THEN
         CALL DDI_GSUMF(910,CNT,L2)
      END IF
C
C     ----- OPTIONAL DEBUG PRINTOUT -----
C
czcz  IF(DBUG) THEN
czcz     WRITE(IW,*) 'CONT. TO A MATRIX IN Z-VECTOR EQ'
czcz     CALL PRTRIL(CNT,L1)
CZCZ     WRITE(IW,*) 'OVERLAP MATRIX'
CZCZ     CALL PRTRIL(S,L1)
CZCZ     WRITE(IW,*) 'BARE NUCLEUS HAMILTONIAN INTEGRALS (H=T+V)'
CZCZ     CALL PRTRIL(H,L1)
CZCZ     WRITE(IW,*) 'KINETIC ENERGY INTEGRALS'
CZCZ     CALL PRTRIL(T,L1)
CZCZ     IF(LZINT.OR.DOESP) THEN
CZCZ        WRITE(IW,*) 'Z-ANGULAR MOMENTUM INTEGRALS'
CZCZ        CALL PRTRIL(Z,L1)
CZCZ     END IF
czcz  END IF
      RETURN
C
 9010 FORMAT(1X,'SCREENING VALUE=',F20.5,' IS BEING USED')
      END
C*MODULE FMOESD  *DECK GETCNT2UBAR 
C>
C>     @brief U^a-bar contributions to FMO gradient
C>
C>     @details Add responce term U^a-bar contributions to FMO gradient.
C>
C>     @author Takeshi Nagata 
C>
      SUBROUTINE getcnt2ubar(IDA,L1,L3,IFG,IPTLG,NQMTFG,CMO,ESPA,
     *                       ZVWRK,ZVLAG,uhfcal)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (ONE=1.0D+00)
      PARAMETER (MXATM=2000)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL DODISTR,uhfcal
      DIMENSION IPTLG(1),NQMTFG(1),ZVLAG(1)
      DIMENSION CMO(L1,*),ZVWRK(1)
      DIMENSION ESPA(1)
C
      COMMON /FMCOM / X(1)
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                MODLMO,NOPDEN,MOFOCK,modfd,modfmm,ncentm
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
CZ    COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
cz
cz    this routine computes the collection of the contirbutions to U^a BAR
cz
      IF (IDA.EQ.0) RETURN

      CALL VALFM(LOADFM)
      LWRK1 = LOADFM + 1
      LWRK2 = LWRK1 + L3 
      IF(uhfcal) LWRK2 = LWRK2 + L3
      LAST  = LWRK2 + L3
      if(uhfcal) LAST = LAST + l3
      NEED  = LAST-LOADFM -1
      CALL GETFM(NEED)

      NQI = IAND(NQMTFG(IFG),65535)
      NOCC = NA
      NVIR = NQI - NA
      NOCVR = NOCC*NVIR
      LNUM = NOCVR
c     SCAL = ONE
      if(uhfcal) then
        NOCCB   = NB
        NVIRB   = NQI   - NB
        NOCVRB  = NOCCB * NVIRB
        LNUM    = NOCVR + NOCVRB
c       SCAL    = ONE
      end if
C
      DODISTR = IAND(MODPAR,512).NE.0
      CALL CPYTSQ(ESPA,X(LWRK1),L1,1)
      CALL SWBASIS(1,L1,NOCC,NVIR,CMO,X(LWRK1),L1,ZVWRK,NVIR,X(LWRK2))
      if(uhfcal) CALL SWBASIS(1,L1,NOCCB,NVIRB,CMO(1,l1+1),
     *     X(LWRK1),L1,ZVWRK(NOCVR+1), NVIRB,X(LWRK2+l3))

      CALL RETFM(NEED)

      DA = IDA
      DO I = 1, LNUM
        ZVWRK(I) = DA * ZVWRK(I)
      END DO
 
cz    if     (itest.eq.1) then
cz      write(6,*) 'MONOMER XMER',ifg,NOCC,NVIR,iptlg(ifg)
cz      CALL PRSQ(zvwrk,NOCC,NVIR,NVIR)
cz    elseif (itest.eq.2) then
cz      write(6,*) 'DIMER XMER',ifg,NOCC,NVIR,iptlg(ifg)
cz      CALL PRSQ(zvwrk,NOCC,NVIR,NVIR)
cz    elseif (itest.eq.3) then
cz      write(6,*) 'ESDIM XMER',ifg,NOCC,NVIR,iptlg(ifg)
cz      CALL PRSQ(zvwrk,NOCC,NVIR,NVIR)
cz    end if

      IF (DODISTR) THEN
        CALL ZLAGACCGET(0,IFG,IPTLG,LNUM,ZVWRK)
      ELSE
        IF (MASWRK) THEN
          CALL DAXPY(LNUM,ONE,ZVWRK,1,ZVLAG(IPTLG(IFG)),1)
        END IF
      END IF

      RETURN
      END
C*MODULE FMOESD  *DECK XMERLAGCNT
      SUBROUTINE XMERLAGCNT(LFG,IDAX,IDAXX,L1,L1L,WRK,WRK1,
     *                      IDMREC0L,ESPA,MAPL,iodfmo,NQMTFG,uhfcal)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
cz    PARAMETER (HALF=0.5D+00,ZERO=0.0D+00,TWO=2.0D+00)
CZ    LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL ISINL,uhfcal
CZ
      DIMENSION IODFMO(*),NQMTFG(*)
      DIMENSION ESPA(*),WRK(*),WRK1(*)
      DIMENSION MAPL(*) 

      COMMON /FMCOM / X(1)
CZ    COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
CZ    COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
CZ    COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                MODLMO,NOPDEN,MOFOCK,modfd,modfmm,ncentm
CZ    COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
CZ   *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
CZ   *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
CZ   *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
CZ   *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
CZ   *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
CZ   *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
CZ   *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
CZ   *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
CZ   *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
CZ   *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
CZ   *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
CZ   *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo
      COMMON /SCZLAG/ LZVLAG,LZVWRK,LYALAG,LYAWRK
      COMMON /SCZVEC/ IDFZVEC,LIPTZVEC,LIPTLG
CZ
CZ    THIS CALCULATES LAGRANGIAN-LIKE TERMS C_I*VIJ*C_I
CZ
      IF (LFG.EQ.0.OR.IAND(MODGRD,42).NE.42) THEN
        WRITE(6,*) 'DETECT A BUG IN XDERLAGCNT'
        CALL ABRT
      END IF 
C
CZ
CZ    CALCULATION FOR LFG
CZ
C
czcz  L2  = (L1*L1+L1)/2
czcz  L3  =  L1*L1
      L2L = (L1L*L1L+L1L)/2
      L3L =  L1L*L1L
      if(uhfcal)       lnum=L3L+L3L
      if(.not.uhfcal)  lnum=L3L

      ! read the MO coeff.
      CALL RAREADS(IDAFMO,IODFMO,WRK(L2L+1),lnum,IDMREC0L,0)

      CALL VCLR(WRK1,1,L2L)
      LOOP = 0
      DO II = 1, L1
        DO JJ = 1, II
          ITMP = 0 
          LOOP = LOOP + 1
          II1=MAPL(II)
          IJ1=MAPL(JJ)
          II2=MAX(II1,IJ1)
          IJ2=MIN(II1,IJ1)
          ISINL=II1.NE.0.AND.IJ1.NE.0
          IF (ISINL) ITMP = (II2*II2-II2)/2+IJ2

          IF (ITMP.NE.0) THEN
            WRK1(ITMP) = ESPA(LOOP)
          END IF
        END DO
      END DO
cz    write(6,*) 'ESPA IN XMER', LFG, IDAX
cz    CALL PRTRI(wrk1,L1l)

CZ
CZ    WRK : MO coefficient
CZ    WRK1: ESPA CONT. OF LFG
CZ
      IF (IDAX.NE.0) THEN
        IDA1 = -IDAX
        call getcnt2ubar(IDA1,L1L,L3L,LFG,X(LIPTLG),NQMTFG,
     *                   WRK(L2L+1),WRK1,X(LZVWRK),X(LZVLAG),uhfcal)
      END IF
      IF (IDAXX.NE.0) THEN
        IDA1 = -IDAXX
        call getcnt2ubar(IDA1,L1L,L3L,LFG,X(LIPTLG),NQMTFG,
     *                   WRK(L2L+1),WRK1,X(LZVWRK),X(LZVLAG),uhfcal)
      END IF

      RETURN
      END
C*MODULE FMOESD  *DECK fmoatfrg2
      SUBROUTINE fmoatfrg2(iat0,indat,indatg,iaglob,ialoc,iabdfg,jabdfg,
     *                     indbd,fmozan,fmoc,natfmob,untxyz,qindz,iats,
     *                     jats,fracv,fracesp,iatfrg,ZNUC,cx,cy,cz,
     *                     KFG1,KAT1,KFG2,KAT2)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      logical iainside,jainside,smartr(2),bimer(3)
      dimension indat(*),indatg(natfmo,*),iaglob(*),ialoc(*),iabdfg(*),
     *          jabdfg(*),indbd(maxabd,*),fmozan(*),fmoc(3,*),
     *          untxyz(3,natfmob,*),qindz(maxnat,*)
      Parameter (MXATM=2000, zero=0.0D+00,one=1.0D+00,half=0.5D+00)
      COMMON /FMCOM / XX(1)
      COMMON /MCPFMO/ IMCPFMO,LFZCOR,LIFMPTYP,LIFMPTYP2,LMCPSW,
     *                LIZCOR2,imp0,jmp0,icorsh0,igtf0
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmolat/ untang(3),untorg(3),respbc(4),abclat(3),anglat(3),
     *                symtra(3,24),symope(3,3,24),iatorg,nsymop,maxklms,
     *                ioporg(3),iopdir(3),iopabc(3),iopang(3)
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo
c     data bimer/3*.false./
c
      bimer(1)=.false.
      bimer(2)=.false.
      bimer(3)=.false.
      if(iat0.gt.natfmo.and.ifmostp.le.2) then
        iat=mod(iat0-1,natfmo)+1
        iu=(iat0-1)/natfmo+1
        iatfrg=indat(iat)
        znuc=-fmozan(iat)
        cx=untxyz(1,iat,iu)
        cy=untxyz(2,iat,iu)
        cz=untxyz(3,iat,iu)
        fracv=zero
        fracesp=one
c       write(6,*) 'w',iat,iu-1,znuc,cx,cy,cz
        return
      endif
      if(maxklms.ne.0.and.ifmostp.gt.2) then
c       iu=1
        znuc=-zan(iat0)
        cx=c(1,iat0)
        cy=c(2,iat0)
        cz=c(3,iat0)
c       Only the external potential will be computed.
        fracv=zero
        fracesp=one
        if(iat0.le.nat) fracesp=zero 
        return
      endif
c     iu=0
c
c     Determine if atom IAT belongs to fragment 
c
      if(ifmostp.eq.2.and.iand(ixesp,4096).ne.0) then
        iatfrg=indat(iat0)
        rk=fmodist(icurfg,0,0,iatfrg)
        if(icurfg.ne.iatfrg) then
          fracv=0
          fracesp=0
          igot=0
          if(rk.eq.0) fracesp=one
          znuc=-fmozan(iat0)
          cx=fmoc(1,iat0)
          cy=fmoc(2,iat0)
          cz=fmoc(3,iat0)
          if(nbdfg.eq.0) goto 90
          do iabd=1,maxabd
            ibdfg=indbd(iabd,iat0)
            if(ibdfg.eq.0) goto 90
            ia=abs(iabdfg(ibdfg))
            ja=abs(jabdfg(ibdfg))
            iafrg=indat(ia)
            jafrg=indat(ja)
            if(iafrg.eq.icurfg.or.jafrg.eq.icurfg) then
c             this is handled below
              igot=1
              goto 90
            endif
c           ri=fmodist(icurfg,0,0,iafrg)
            rj=fmodist(icurfg,0,0,jafrg)
c           The code below may not work for multiply cut BDAs?
            if(rj.eq.0) then
              if(rk.ne.0) fracesp=fracesp-one/znuc
            else
              if(rk.eq.0) fracesp=fracesp+one/znuc
            endif
          enddo
   90     continue
          if(igot.eq.0) return
        endif 
      endif 
      if(ifmostp.ne.6) then
        iat=iat0
        IF (IMCPFMO.EQ.1) THEN
          znuc=-(fmozan(iat)-XX(LFZCOR+iat-1))
        ELSE
          znuc=-fmozan(iat)
        END IF
        cx=fmoc(1,iat)
        cy=fmoc(2,iat)
        cz=fmoc(3,iat)
        iz=1
        ifg=icurfg
        factk=one
      else
        iat=iat0+nat
        znuc=-zan(iat)
        cx=c(1,iat)
        cy=c(2,iat)
        cz=c(3,iat)
c       iat below must be global iat
        iat=iaglob(iat)
        iz=2
        ifg=ncursh
        factk=half
        ! for VFMO
        factk=one
        KFG1 = INDAT(IAT) 
        KAT1 = IAT0
        KFG2 = 0
        KAT2 = 0
        RETURN
      endif
      jfg=jcurfg
      lfg=kcurfg
      iatfrg=indat(iat)
      smartr(1)=iand(modesp,7).eq.1.and.jfg.ne.0
      smartr(2)=iand(modesp,7).eq.2.and.jfg.ne.0
      if(smartr(1).and.nbdfg.ne.0) then
        bimer(1)=fmodist(ifg,0,0,jfg).eq.0
        if(lfg.eq.0) then
          if(bimer(1)) smartr(1)=.false.
        else
          bimer(2)=fmodist(ifg,0,0,lfg).eq.0
          bimer(3)=fmodist(jfg,0,0,lfg).eq.0
        if(bimer(1).and.(bimer(2).or.bimer(3)).or.bimer(2).and.bimer(3))
     *    smartr(1)=.false.
        endif 
      endif 
      iatsg=iaglob(iats)
      jatsg=iaglob(jats)
      iifg=indat(iatsg)
      jjfg=indat(jatsg)
CZCZ
      FRACV   = ZERO
      FRACESP = ZERO
      KFG1 = 0
      KAT1 = 0
      KFG2 = 0
      KAT2 = 0
CZCZ
c     3 -body terms do not work with BSSE.
      if(nbdfg.eq.0.or.ifmostp.eq.6) then
CZ      fracv=zero
CZ      fracesp=one
c       BSSE
CZ      if(ifmostp.eq.5) then
CZ        if(nbsse.eq.1.and.iatfrg.eq.jfg .or. nbsse.eq.2.and.
CZ   *      iatfrg.ne.ifg.and.(iifg.eq.jfg.or.jjfg.eq.jfg)) fracesp=zero
CZ      endif
c       decide if the point charge iat should be included into ESP (keep=1)
CZ      if(ifmostp.ne.6) then
CZ       if(fracesp.eq.one.and.(nbsse.ne.2.or.ifmostp.ne.5.or.iatfrg.ne.
CZ   *  jfg).and.(iatfrg.eq.ifg.or.iatfrg.eq.jfg.or.iatfrg.eq.lfg)) then
CZ        fracv=one
CZ        fracesp=zero
CZ       endif 
CZ      endif
      else
c       this code does not support nbsse=1,2 and 3.
        if(nbsse.ne.0) then
          write(6,*) 'bad nbsse',nbsse
          call abrt
        endif
c       set values for the case atom IAT is not shared
CZ      if(iatfrg.eq.ifg.or.iatfrg.eq.jfg.or.iatfrg.eq.lfg) then
CZ        fracv=one
CZ        fracesp=zero
CZ      else
CZ        fracv=zero
CZ        fracesp=one
CZ      endif
        fracesp1=zero
c       do ibdfg=1,nbdfg
c       loop over all broken bonds in which atom IAT is involved.
c       we are only interested really in one n-mer here (n=1,2), so
c       we find if an atom is split between this n-mer and the rest, then quit. 
        do iabd=1,maxabd
          ibdfg=indbd(iabd,iat)
          if(ibdfg.eq.0) goto 100
          ia=abs(iabdfg(ibdfg))
          ja=abs(jabdfg(ibdfg))
c         reordering is now done in fmobon
c         the code below assumes the canonical order (left is negative). 
c         if(ja.lt.0) then
c           if(ia.lt.0) call abrt
c           idum=ia
c           ia=ja
c           ja=idum
c         endif
c         ia=abs(ia)
          iafrg=indat(ia)
          jafrg=indat(ja)
          iainside=iafrg.eq.ifg.or.iafrg.eq.jfg.or.iafrg.eq.lfg
          jainside=jafrg.eq.ifg.or.jafrg.eq.jfg.or.jafrg.eq.lfg
c         exclude the case when a cut bond is inside a dimer
          if(iat.eq.ia.and..not.(iainside.and.jainside)) then
CZ          if(iainside) then
CZ            fracv=(znuc+one)/znuc
CZ            fracesp=-one/znuc
CZ          endif
CZ          if(jainside) then
CZ            fracv=-one/znuc
CZ            fracesp=(znuc+one)/znuc
CZ          endif
          endif
c
c           now add partial charges. 
c           Here we add the "right" side (that is, pseudoproton). 
c           The left side (N-1) is treated below, along with all other cases. 
c           
          if(iat.eq.ia.and..not.jainside.and.resppc(iz).ne.zero) then
c           kfg is equal to jafrg.
c           tricky part! kat comes from the ghost atom stored in ialoc
c           Note that this atom has coordinates equal to those of iat
c           but its charge is stored as processed below.
            kfg=ishft(ialoc(natfmo+ibdfg),-16)
            kat=iand(ialoc(natfmo+ibdfg),65535)
cnb         ifmostp.eq.6 cannot come here?!
            if(ifmostp.ne.6) then
              if(smartr(1).or.smartr(2)) then
                rk=fmosdist(iifg,jjfg,indatg(iatsg,1),indatg(jatsg,1),
     *                      ifg,jfg,lfg,kfg,bimer)
              else
                rk=fmodist(ifg,jfg,lfg,kfg)
              endif
            else
              rk=fmodist(ifg,0,0,kfg)
            endif
            if(rk.gt.resppc(iz)) then 
CZCZ          fracesp1=fracesp1+popmat(kat,kfg,icurpop)*factk/znuc
              fracesp1=fracesp1+qindz(kat,kfg)*factk
CZ
              KFG1 = KFG
              KAT1 = KAT
CZ
            endif 
c           goto 100
          endif
          if(ifmostp.eq.6.and.resppc(iz).ne.zero) then
            write(6,*) 'fmoptc is not programmed for resppc(2) yet'
            call abrt
          endif
        enddo
  100   continue
        fracesp=fracesp+fracesp1
      endif
c     Add approximate 2e ESP contributions that become atomic Mulliken charges
c     centred at the atomic coordinates (point charge approximation).
      if(resppc(iz).ne.zero) then
        ind=iat
        kfg=ishft(ialoc(ind),-16)
        kat=iand(ialoc(ind),65535)
c       check if the gun is accidently or mistakenly loaded.  
        if(kfg.eq.0) call abrt 
c         
c       for regular runs we want all charges except those from I and J. 
        if(ifmostp.ne.6.and.(ifg.eq.kfg.or.jfg.eq.kfg.or.lfg.eq.kfg)) 
     *    goto 200
c       for esdim we only want charges coming from J
c
        if(ifmostp.ne.6) then
          if(smartr(1).or.smartr(2)) then
            rk=fmosdist(iifg,jjfg,indatg(iatsg,1),indatg(jatsg,1),
     *                   ifg,jfg,lfg,kfg,bimer)
          else
            rk=fmodist(ifg,jfg,lfg,kfg)
          endif
        else
          rk=fmodist(ifg,0,0,kfg)
        endif
        if(rk.gt.resppc(iz)) then 
CZCZ      fracesp=fracesp+popmat(kat,kfg,icurpop)*factk/znuc
czcz      fracesp=fracesp+qindz(kat,kfg)*factk
          fracesp=fracesp+qindz(kat,kfg)
CZCZ
          KFG2 = KFG
          KAT2 = KAT
CZCZ
        endif 
  200   continue
c
c       zero out ESP charges for the overlapping atoms
        tol2=1.0D-08
        if(fracesp.eq.0.or.iand(ixesp,32768).eq.0) goto 300
        do i=1,nat 
          if((c(1,i)-cx)**2+(c(2,i)-cy)**2+(c(3,i)-cz)**2.lt.tol2) then
c           write(6,*) 'Zeroed out ESPZ',znuc,cx,cy,cz,fracesp
            fracesp=zero
            goto 300
          endif
        enddo
  300   continue 
      endif
      RETURN
      END
C*MODULE FMOESD  *DECK EPOTEN2
      SUBROUTINE EPOTEN2(MODE,ACONST,VALUE,DA,NP,L2)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL IANDJ,NORM,DOUBLE,GOPARR,DSKWRK,MASWRK,NXT
C
      DIMENSION VALUE(maxnat,*),DA(L2)
      DIMENSION IX(35),IY(35),IZ(35),JX(35),JY(35),JZ(35),
     *          XIN(125),YIN(125),ZIN(125),
     *          DIJ(225),IJX(225),IJY(225),IJZ(225),
     *          HP(28),WP(28),MINP(7),MAXP(7)
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000)
C
      COMMON /HERMIT/ H1,H2(2),H3(3),H4(4),H5(5),H6(6),H7(7),
     *                H8(8),H9(9),H10(10),
     *                H11(11),H12(12),H13(13),H14(14),H15(15)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IRPPCM,IEFPCM,IP_F,NFMOPCM
      COMMON /PCMITR/ RCUT(2),THRES,IPCMIT,IMUL,MXDIIS,NREG,MXITR1,
     *                MXITR2,MODPAP
      COMMON /ROOT  / XX,U(13),W(13),NROOTS
      COMMON /WERMIT/ W1,W2(2),W3(3),W4(4),W5(5),W6(6),W7(7),
     *                W8(8),W9(9),W10(10),
     *                W11(11),W12(12),W13(13),W14(14),W15(15)
czcz
      COMMON /FMCOM / X(1)
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo
czcz
C
      EQUIVALENCE (HP(1),H1),(WP(1),W1)
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00, TWO=2.0D+00)
      PARAMETER (PI212=1.1283791670955D+00)
      PARAMETER (SQRT3=1.73205080756888D+00)
      PARAMETER (SQRT5=2.23606797749979D+00)
      PARAMETER (SQRT7=2.64575131106459D+00)
      PARAMETER (RLN10=2.30258D+00)
      DATA MINP /1,2,4,7,11,16,22/
      DATA MAXP /1,3,6,10,15,21,28/
      DATA JX / 0, 1, 0, 0, 2, 0, 0, 1, 1, 0,
     *          3, 0, 0, 2, 2, 1, 0, 1, 0, 1,
     *          4, 0, 0, 3, 3, 1, 0, 1, 0, 2,
     *          2, 0, 2, 1, 1/
      DATA IX / 1, 6, 1, 1,11, 1, 1, 6, 6, 1,
     *         16, 1, 1,11,11, 6, 1, 6, 1, 6,
     *         21, 1, 1,16,16, 6, 1, 6, 1,11,
     *         11, 1,11, 6, 6/
      DATA JY / 0, 0, 1, 0, 0, 2, 0, 1, 0, 1,
     *          0, 3, 0, 1, 0, 2, 2, 0, 1, 1,
     *          0, 4, 0, 1, 0, 3, 3, 0, 1, 2,
     *          0, 2, 1, 2, 1/
      DATA IY / 1, 1, 6, 1, 1,11, 1, 6, 1, 6,
     *          1,16, 1, 6, 1,11,11, 1, 6, 6,
     *          1,21, 1, 6, 1,16,16, 1, 6,11,
     *          1,11, 6,11, 6/
      DATA JZ / 0, 0, 0, 1, 0, 0, 2, 0, 1, 1,
     *          0, 0, 3, 0, 1, 0, 1, 2, 2, 1,
     *          0, 0, 4, 0, 1, 0, 1, 3, 3, 0,
     *          2, 2, 1, 1, 2/
      DATA IZ / 1, 1, 1, 6, 1, 1,11, 1, 6, 6,
     *          1, 1,16, 1, 6, 1, 6,11,11, 6,
     *          1, 1,21, 1, 6, 1, 6,16,16, 1,
     *         11,11, 6, 6,11/
C
C     EVALUATE THE VALUES OF THE ELECTROSTATIC POTENTIAL FOR ALL
C     POINTS GIVEN IN X,Y,ZCOORD.
C     AT PRESENT THERE ARE NO APPROXIMATIONS AND NO SCREENING OTHER
C     THAN THE USUAL INTEGRAL SCREENING WITH ITOL. THE INTEGRALS
C     ARE NEITHER ZEROED OUT AT THE BEGINNING NOR PARALLEL SUMMED
C     AT THE END.
C     THIS IS A CLONE OF EPCALC.
C
C     REDUCE THE ACCURACY 50 TIMES (E**4) FOR ITERATIVE SOLVER IN PCM
C     (AT PRESENT THIS ROUTINE IS ONLY CALLED IN CASE OF ITERATIVE PCM
C     SOLVER AND THE REASON FOR ACCURACY REDUCTION IS ITS LIMITED
C     NUMERIC ACCURACY).
C
C     THIS IS USED BY PCM AND FMO, AND IS LIMITED TO SPDFG ONLY.
C
CZ    MODE=0: USE THE NUMBER OF FMO ATOMS (NATFMO)
CZ    MODE=1: USE THE NUMBER OF FRAGMENT ATOMS (NAT)
CZ
      CALL BASCHK(LMAX)
      IF(LMAX.GT.4) THEN
         IF(MASWRK) WRITE(IW,*) 'EPOTEN: CODE IS SPDFG LIMITED'
         CALL ABRT
      END IF
C
czcz
cz    ISTART = 1
cz    IEND   = NSHELL
cz    JSTART = 1
      NATST  = 1
      IF     (MODE.EQ.0) THEN
        NATED = NP
      ELSEIF (MODE.EQ.1) THEN
        NATED = NAT1E 
      END IF
czcz
      ITOLPCM=ITOL
      IF(IPCM.NE.0.AND.IPCMIT.NE.0) ITOLPCM=ITOLPCM-4
      TOL = RLN10*ITOLPCM
C     ITOLPCM=20
C     TOL  = RLN10*ITOLPCM
      NORM = NORMF .NE. 1 .OR. NORMP .NE. 1
      NXT = IBTYP.EQ.1
      NEXT  = -1
      KOUNT = -1
C
C     PREPARE DENSITY FOR EASY TRACING: DOUBLE OFF-DIAGONAL ELEMENTS.
C
      L1=NUM
      LOOP=0
      DO I=1,L1
        DO J=1,I-1
          LOOP=LOOP+1
          DA(LOOP)=DA(LOOP)*TWO
        ENDDO
C       SKIP THE DIAGONAL
        LOOP=LOOP+1
      ENDDO
C
C                    LOOP OVER SHELLS II
C
      DO 510 II=1,NSHELL
        I    = KATOM(II)
        XI   = C(1,I)
        YI   = C(2,I)
        ZI   = C(3,I)
        I1   = KSTART(II)
        I2   = I1 + KNG(II) - 1
        LIT  = KTYPE(II)
        MINI = KMIN(II)
        MAXI = KMAX(II)
        LOCI = KLOC(II) - MINI
C
C                    LOOP OVER SHELLS JJ
C
        DO 500  JJ=1,II
C
          IF(GOPARR) THEN
            KOUNT=KOUNT+1
            IF(NXT) THEN
              IF(KOUNT.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
              IF(NEXT.NE.KOUNT) GOTO 500
            ELSE
              IF(MOD(KOUNT,NPROC).NE.ME) GOTO 500
            ENDIF
          ENDIF
          J    = KATOM(JJ)
          XJ   = C(1,J)
          YJ   = C(2,J)
          ZJ   = C(3,J)
          J1   = KSTART(JJ)
          J2   = J1 + KNG(JJ) - 1
          LJT  = KTYPE(JJ)
          MINJ = KMIN(JJ)
          MAXJ = KMAX(JJ)
          LOCJ = KLOC(JJ) - MINJ
C
          RR     = (XI-XJ)**2 + (YI-YJ)**2 + (ZI-ZJ)**2
          NROOTS = (LIT + LJT - 2)/2 + 1
          IANDJ  = II.EQ.JJ
C
C             PREPARE INDICES FOR PAIRS OF (I,J) ORBITALS
C
          IJ = 0
          MAX = MAXJ
          DO 100  I=MINI,MAXI
            NX = IX(I)
            NY = IY(I)
            NZ = IZ(I)
            IF (IANDJ) MAX = I
            DO 100  J=MINJ,MAX
              IJ = IJ+1
              IJX(IJ) = NX+JX(J)
              IJY(IJ) = NY+JY(J)
              IJZ(IJ) = NZ+JZ(J)
  100       CONTINUE
C
C                     LOOP OVER PRIMITIVES IG
C
          JGMAX = J2
          DO 410  IG=I1,I2
            AI  = EX(IG)
            CSI = CS(IG)
            CPI = CP(IG)
            CDI = CD(IG)
            CFI = CF(IG)
            CGI = CG(IG)
C
C                     LOOP OVER PRIMITIVES JG
C
            IF (IANDJ) JGMAX = IG
            DO 400 JG=J1,JGMAX
              AJ  = EX(JG)
              CSJ = CS(JG)
              CPJ = CP(JG)
              CDJ = CD(JG)
              CFJ = CF(JG)
              CGJ = CG(JG)
C
              AA  = AI + AJ
              AA1 = ONE/AA
              FI  = PI212*AA1
C
              AAX = (AI*XI + AJ*XJ)
              AAY = (AI*YI + AJ*YJ)
              AAZ = (AI*ZI + AJ*ZJ)
C
              AX  = AAX*AA1
              AY  = AAY*AA1
              AZ  = AAZ*AA1
C
              DUM = AI*AJ*RR*AA1
              IF(DUM .GT. TOL) GO TO 400
              FAC = FI*EXP(-DUM)
C
C                       CALCULATE DENSITY FACTORS
C
              DOUBLE = IANDJ.AND.IG.NE.JG
              MAX = MAXJ
              NN  = 0
C
              DUM1 = ZERO
              DUM2 = ZERO
              DO 200 I = MINI,MAXI
                IF(I.EQ.1) DUM1=CSI*FAC
                IF(I.EQ.2) DUM1=CPI*FAC
                IF(I.EQ.5) DUM1=CDI*FAC
                IF(I.EQ.8.AND.NORM) DUM1=DUM1*SQRT3
                IF(I.EQ.11) DUM1 = CFI*FAC
                IF((I.EQ.14).AND.NORM) DUM1 = DUM1*SQRT5
                IF((I.EQ.20).AND.NORM) DUM1 = DUM1*SQRT3
                IF(I.EQ.21) DUM1 = CGI*FAC
                IF((I.EQ.24).AND.NORM) DUM1 = DUM1*SQRT7
                IF((I.EQ.30).AND.NORM) DUM1 = DUM1*SQRT5/SQRT3
                IF((I.EQ.33).AND.NORM) DUM1 = DUM1*SQRT3
                IF(IANDJ) MAX = I
                DO 180 J = MINJ,MAX
                  NN = NN+1
                  IF(J.EQ.1) THEN
                    DUM2 = DUM1*CSJ
                    IF(DOUBLE .AND. I.EQ.1) DUM2 = DUM2 + DUM2
                    IF(DOUBLE .AND. I.GT.1) DUM2 = DUM2 + CSI*CPJ*FAC
C
                  ELSE IF(J.EQ.2) THEN
                  DUM2 = DUM1*CPJ
                  IF(DOUBLE) DUM2 = DUM2 + DUM2
C
                  ELSE IF(J.EQ.5) THEN
                    DUM2 = DUM1*CDJ
                    IF(DOUBLE) DUM2 = DUM2 + DUM2
C
                  ELSE IF((J.EQ.8).AND.NORM) THEN
                    DUM2 = DUM2*SQRT3
C
                  ELSE IF (J.EQ.11) THEN
                    DUM2 = DUM1*CFJ
                    IF (DOUBLE) DUM2 = DUM2+DUM2
C
                  ELSE IF ((J.EQ.14).AND.NORM) THEN
                    DUM2 = DUM2*SQRT5
C
                  ELSE IF ((J.EQ.20).AND.NORM) THEN
                    DUM2 = DUM2*SQRT3
C
                  ELSE IF (J.EQ.21) THEN
                    DUM2 = DUM1*CGJ
                    IF (DOUBLE) DUM2 = DUM2+DUM2
C
                  ELSE IF ((J.EQ.24).AND.NORM) THEN
                    DUM2 = DUM2*SQRT7
C
                  ELSE IF ((J.EQ.30).AND.NORM) THEN
                    DUM2 = DUM2*SQRT5/SQRT3
C
                  ELSE IF ((J.EQ.33).AND.NORM) THEN
                    DUM2 = DUM2*SQRT3
C
                  END IF
C
                  DIJ(NN) = DUM2
  180           CONTINUE
  200         CONTINUE
C
C                    LOOP OVER PROPERTY COORDINATES
C
              DO 600 IPT=NATST,NATED
                CALL FMOATFRG2(ipt,X(LINDAT),X(LINDATG),X(LIAGLOB),
     *                         X(LIALOC),X(LIABDFG),X(LJABDFG),
     *                         X(LINDBD),X(LFMOZAN),X(LFMOC),
     *                         NATFMO+NBDFG,X(LUNTXYZ),X(LPOPMAT),
     *                         KATOM(II),KATOM(JJ),FRACV,FRACESP,
     *                         KFG,ZNUC,xpp,ypp,zpp,KFG1,KAT1,KFG2,KAT2)
     
Cz              IF (ABS(FRACESP).LT.1.0D-08) GOTO 600
                IF (KFG1.EQ.0.AND.KFG2.EQ.0) GOTO 600
czcz
C
C       CALCULATE POINTS AND WEIGHTS FOR RYS POLYNOMIAL
C
                XX  = AA * ((AX-XPP)**2 + (AY-YPP)**2 + (AZ-ZPP)**2)
                IF (NROOTS.LE.3) CALL RT123
                IF (NROOTS.EQ.4) CALL ROOT4
                IF (NROOTS.EQ.5) CALL ROOT5
                IF (NROOTS.GE.6) CALL ROOT6
C
C       LOOP OVER ROOTS OF RYS POLYNOMIAL TO CALCULATE INTEGRALS
C
                MM = 0
                DO 340  K=1,NROOTS
C
                  UU = AA*U(K)
                  WW = W(K)
                  TT = ONE/(AA+UU)
                  T  = SQRT(TT)
C
                  X0 = (AAX + UU*XPP)*TT
                  Y0 = (AAY + UU*YPP)*TT
                  Z0 = (AAZ + UU*ZPP)*TT
C
C      CALCULATE 1-DIMENSIONAL INTEGRALS OVER ALL ANGULAR MOMENTA
C
                  IN = -5+MM
                  DO 320  I=1,LIT
                    IN = IN+5
                    NI = I
C
                    DO 320  J=1,LJT
                      JN = IN+J
                      NJ = J
C
C       EVALUATE MOMENT INTEGRALS USING GAUSS-HERMITE QUADRATURE:
C
                      XINT0 = ZERO
                      YINT0 = ZERO
                      ZINT0 = ZERO
C
                      NPTS = (NI + NJ - 2)/2 + 1
                      IMIN = MINP(NPTS)
                      IMAX = MAXP(NPTS)
C
                      DO 310  IROOT=IMIN,IMAX
C
                        DUM = WP(IROOT)
                        PX = DUM
                        PY = DUM
                        PZ = DUM
C
                        DUM = HP(IROOT)*T
                        PTX = DUM + X0
                        PTY = DUM + Y0
                        PTZ = DUM + Z0
C
                        AXI = PTX - XI
                        AYI = PTY - YI
                        AZI = PTZ - ZI
C
                        BXI = PTX - XJ
                        BYI = PTY - YJ
                        BZI = PTZ - ZJ
C
                        GO TO (250,240,230,220,210),NI
C
  210                   PX = PX*AXI
                        PY = PY*AYI
                        PZ = PZ*AZI
C
  220                   PX = PX*AXI
                        PY = PY*AYI
                        PZ = PZ*AZI
C
  230                   PX = PX*AXI
                        PY = PY*AYI
                        PZ = PZ*AZI
C
  240                   PX = PX*AXI
                        PY = PY*AYI
                        PZ = PZ*AZI
C
  250                   CONTINUE
C
                        GO TO (300,290,280,270,260),NJ
C
  260                   PX = PX*BXI
                        PY = PY*BYI
                        PZ = PZ*BZI
C
  270                   PX = PX*BXI
                        PY = PY*BYI
                        PZ = PZ*BZI
C
  280                   PX = PX*BXI
                        PY = PY*BYI
                        PZ = PZ*BZI
C
  290                   PX = PX*BXI
                        PY = PY*BYI
                        PZ = PZ*BZI
C
  300                   CONTINUE
C
                        XINT0 = XINT0 + PX
                        YINT0 = YINT0 + PY
                        ZINT0 = ZINT0 + PZ
C
  310                 CONTINUE
C
                      XIN(JN) = XINT0
                      YIN(JN) = YINT0
                      ZIN(JN) = ZINT0*WW
C
  320               CONTINUE
C
                  MM = MM+25
  340           CONTINUE
C
                NN = 0
                MAX = MAXJ
                SUM = ZERO
C         COMPUTE V(I)=TR(D*V(I)), WHERE V(I) IS THE POTENTIAL
C         AT THE POINT IPT (==I) AND D IS THE ELECTRON DENSITY.
                DO 420  I=MINI,MAXI
                  LI = LOCI + I
                  IN = LI*(LI-1)/2
                  IF (IANDJ) MAX = I
                  DO 420  J=MINJ,MAX
                    LJ = LOCJ + J
                    JN = LJ + IN
                    NN = NN + 1
                    NX = IJX(NN)
                    NY = IJY(NN)
                    NZ = IJZ(NN)
                    MM = 0
                    SUM1 = ZERO
                    DO 350 K=1,NROOTS
                      SUM1=SUM1+XIN(NX+MM)*YIN(NY+MM)*ZIN(NZ+MM)
                      MM = MM+25
  350               CONTINUE
                    SUM=SUM+DIJ(NN)*DA(JN)*SUM1
  420           CONTINUE
czcz            VALUE(IPT) = VALUE(IPT) + ACONST*SUM
                if (kfg1.ne.0) then
                  ! ghost atoms
                  VALUE(kat1,kfg1) = VALUE(kat1,kfg1) + ACONST*SUM
                end if
                if (kfg2.ne.0) then
                  VALUE(kat2,kfg2) = VALUE(kat2,kfg2) + ACONST*SUM
                end if
czcz
C
  600         CONTINUE
C
C        END OF LOOP OVER PROPERTY COORDINATES
C
  400       CONTINUE
  410    CONTINUE
C
C        END OF LOOPS OVER PRIMITIVES
C
C
  500   CONTINUE
  510 CONTINUE
C
C        END OF LOOPS OVER SHELLS
C
      IF(GOPARR.AND.NXT) CALL DDI_DLBRESET
C
C     RESTORE DENSITY IN COURTESY
C
      LOOP=0
      DO I=1,L1
        DO J=1,I-1
          LOOP=LOOP+1
          DA(LOOP)=DA(LOOP)/TWO
        ENDDO
C       SKIP THE DIAGONAL
        LOOP=LOOP+1
      ENDDO
C
czcz  IF(NFMOPCM.NE.0) THEN
czcz    IF(MASWRK) WRITE(IW,*) 'DONE PCM POT.'
czcz    CALL TIMIT(1)
czcz  ENDIF
C
      RETURN
      END
C*MODULE FMOESD  *DECK dltcnt2esp
      SUBROUTINE dltcnt2esp(L2,IAGLOB,IALOC,ESPA,CNT,H,VA,VAO,S)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      PARAMETER (MXGTOT=20000, MXSH=5000)
CZCZ  PARAMETER (PT5=0.5D+00,PT25=0.25D+00)
      PARAMETER (PT25=0.25D+00)
      PARAMETER (ONE=1.0D+00,ZERO=0.0D+00)
C
      LOGICAL IANDJ, LMULMER
      DIMENSION IAGLOB(1),IALOC(1)
      DIMENSION ESPA(1),CNT(1),H(1),VA(maxnat,*),VAO(MAXNAT,*),S(1)
C
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                MODLMO,NOPDEN,MOFOCK,MODFD,modfmm,ncentm
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo
CZ    COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
CZ   *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
CZ
CZ    a term including the product of Kronecker's deltas
CZ
      IF (RESPPC(1).EQ.ZERO) RETURN

      CALL VCLR(CNT,1,L2)
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      LMULMER = IFMOSTP.GE.4

      DO II=1, NSHELL
        IAT=KATOM(II)
        MINI=KMIN(II)
        MAXI=KMAX(II)
        LOCI=KLOC(II)-MINI
        IAGLO = IAGLOB(IAT)
        IAT=IAND(IALOC(IAGLO),65535)
        IATFRG=ISHFT(IALOC(IAGLO),-16)
        VAI = VA(IAT,IATFRG)
        IF (LMULMER) VAI = VAI - VAO(IAT,IATFRG)

        DO JJ=1, II
          JAT=KATOM(JJ)
          MINJ=KMIN(JJ)
          MAXJ=KMAX(JJ)
          LOCJ=KLOC(JJ)-MINJ
          JAGLO = IAGLOB(JAT)
          JAT=IAND(IALOC(JAGLO),65535)
          JATFRG=ISHFT(IALOC(JAGLO),-16)
          VAJ = VA(JAT,JATFRG)
          IF (LMULMER) VAJ = VAJ - VAO(JAT,JATFRG)

          IANDJ = II.EQ.JJ
          MAX5 = MAXJ
          DO I = MINI, MAXI
            INUM = LOCI + I
            IF (IANDJ) MAX5 = I
            DO J = MINJ, MAX5
              JNUM = LOCJ + J

              ITRI = (INUM-1)*INUM/2 + JNUM
              TMP = (VAI+VAJ)*S(ITRI)*PT25
              CNT(ITRI) = CNT(ITRI) + TMP
            ENDDO
          ENDDO
        END DO
      END DO

      ! diagonal elements are multiplied by 2
cz    II = 0
cz    DO I=1, L1
cz      II = II+I
cz      CNT(II) = CNT(II) + CNT(II)
cz    ENDDO

cz
      CALL DAXPY(L2,ONE,CNT,1,ESPA,1)
cz
czcz  write(6,*) 'espa in VFMO', ifg 
czcz  CALL PRTRI(espa,L1)
czcz  write(6,*) 'CNT in VFMO', ifg 
czcz  CALL PRTRI(cnt,L1)
cz    write(6,*) 'SS', ifg 
cz    CALL PRTRI(s,L1)
czcz 

      CALL DAREAD(IDAF,IODA,H,L2,11,0)
      CALL DAXPY(L2,ONE,CNT,1,H,1)
      CALL DAWRIT(IDAF,IODA,H,L2,11,0)
      RETURN
      END
C*MODULE FMOESD  *DECK compvipot 
      SUBROUTINE compvipot(NAT0,NAT1,IFG,fmoc,VIPOT)

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=2000)
czcz  PARAMETER (ZERO=0.0D+00,ONE=1.0D+00)
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION VIPOT(MAXNAT,*),fmoc(3,*)
C
      COMMON /FMCOM / X(1)
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
cz
cz    Add the contribution from nuclear charges into VIPOT
cz    Note that this type of contribution is estimated all over the fragments 
cz    i.e., there is no ESPPC approximation for the nuclear charge cont.
cz
      IF (IFMOSTP.EQ.2) THEN
        DO IAT = 1, NAT
          cx  = c(1,IAT)
          cy  = c(2,IAT)
          cz  = c(3,IAT)
          znuc = -zan(iat)
          DO I = 1, NATFMO
            LFG=ishft(ixftch(x(lialoc),i),-16)
            LAT=iand(ixftch(x(lialoc),i),65535)
            IF (IFG.NE.LFG) THEN
              rr = (cx - fmoc(1,i))**2
     *           + (cy - fmoc(2,i))**2
     *           + (cz - fmoc(3,i))**2
              IF (RR.GT.1.0D-08.and.maswrk) THEN
                rr = sqrt(rr)
                VIPOT(Lat,LFG) = VIPOT(LAT,LFG) + znuc/rr
              END IF
            END IF
          END DO
        END DO
      ELSEIF (IFMOSTP.GE.4) THEN
        DO IAT = 1, NAT0
          cx  = c(1,IAT)
          cy  = c(2,IAT)
          cz  = c(3,IAT)
          znuc = -zan(iat)
          DO JAT = NAT0+1, NAT1
            rr = (cx - c(1,JAT))**2
     *         + (cy - c(2,JAT))**2
     *         + (cz - c(3,JAT))**2
            IF (RR.GT.1.0D-08.and.maswrk) THEN
              JGAT = IXFTCH(x(LIAGLOB),JAT)
              LFG=ishft(ixftch(x(lialoc),JGAT),-16)
              LAT= iand(ixftch(x(lialoc),JGAT),65535)
              rr = sqrt(rr)
              VIPOT(Lat,LFG) = VIPOT(LAT,LFG) + znuc/rr
            END IF
          END DO
        END DO
        DO IAT = NAT0, NAT1
          cx  = c(1,IAT)
          cy  = c(2,IAT)
          cz  = c(3,IAT)
          znuc = -zan(iat)
          DO JAT = 1, NAT0
            rr = (cx - c(1,JAT))**2
     *         + (cy - c(2,JAT))**2
     *         + (cz - c(3,JAT))**2
            IF (RR.GT.1.0D-08.and.maswrk) THEN
              JGAT = IXFTCH(x(LIAGLOB),JAT)
              LFG=ishft(ixftch(x(lialoc),JGAT),-16)
              LAT= iand(ixftch(x(lialoc),JGAT),65535)
              rr = sqrt(rr)
              VIPOT(Lat,LFG) = VIPOT(LAT,LFG) + znuc/rr
            END IF
          END DO
        END DO

      END IF

      RETURN
      END
