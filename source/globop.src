C*MODULE GLOBOP  *DECK GLOPDR
C> @brief main driver for Monte Carlo Runs
C>
C> @details handles the default and input settings.
C>          Contains the main loop and tracks statistics as
C>          well as the final output.
C>
C>          The Metropolis Monte Carlo method implemented here
C>          takes a set of EFP and/or FMO groups and randomly
C>          moves and rotates one group at each step. The energy
C>          is calculated and if it is lower than the previous
C>          energy, the new coordinates are accepted.  If the
C>          energy is higher, then the new coordinates are accepted
C>          with a probablity dependent on the temperature.
C>
C>          Simulated annealing is implemented.
C>          The total number of steps is NTEMPS*NBLOCK.
C>          Additional information is dumped to the .trj file.
C>
C> @author Caleb Carlin
C>   - March 2013 
C>
      SUBROUTINE GLOPDR
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,MCMIN
      LOGICAL OPTN,RNDINI,ALERT,LSCZVFLG,ACCEPT
C
      PARAMETER (MXATM=2000, MXAO=8192,MXSHEF=1000, MXGEFP=4000,
     *           MXPT=2000, MXFRG=1050, MXDFG=5, MXFGPT=12000,
     *           MXDPPT=63000,SCALTM=3.1667606D-06)
C
      CHARACTER*8 LJNAME,ELJNAM
      DIMENSION SCALE(2),IFXFRG(MXFRG),IFRMOV(MXFRG)
      DOUBLE PRECISION LDMC, LDMA,TUMBLER
      INTEGER TTYPE
C
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NATEF(MXDFG),NUMEF(MXDFG),NTPATM
      COMMON /EFPCMO/ NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CANFOK(MXAO,MXDFG)
      COMMON /FMCOM / XX(1)
      COMMON /FMOAPI/ FMOID(MXATM),FMOAPI_COORD,LAP,LKEEPER
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                MODLMO,NOPDEN,MOFOCK,MODFD,modfmm
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,LIACTFG,lcrfrg
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG)
      COMMON /FRGLJP/ CORDLJ(3,MXPT),ELJCRD(3,MXFGPT),
     *                POTLJ(2,MXPT),ELJPOT(2,MXFGPT),
     *                LJNAME(MXPT),ELJNAM(MXFGPT),
     *                NLJPTS(MXFRG),NLJTTPT,ILJP,NMLJ(2)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /FUNCT / E,EG(3*MXATM)
      COMMON /GLOFMO/ MCMIN
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
C     COMMON /PCMPAR/ IPCM,NFT26,NFT27,IKREP,IEF,IP_F,NFMOPCM
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
      COMMON /SCFOPT/ CONVHF,MAXIT,MCONV,NPUNCH,NPREO(4)
      COMMON /SIMDAT/ NACC,NREJ,IGOMIN,NRPA,IBWM,NACCT,NREJT,NRPAT,
     *                NPRTGO,IDPUNC,IGOFLG
      COMMON /SIMEN / EPREV,EMIN,ALPHA,DAVE,XMIN,XMAX,YMIN,YMAX
     *               ,ZMIN,ZMAX,XRANGE,YRANGE,ZRANGE,SEPTOL
     *               ,DACRAT,UPDFAC
      COMMON /SCZVEC/ IDFZVEC,LIPTZVEC,LIPTLG
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00,
     *           UNITS = ONE/0.52917724924D+00)
C
      PARAMETER (NNAM=31)
      DIMENSION QNAM(NNAM),KQNAM(NNAM)
      DATA QNAM/8HTEMPI   ,8HTEMPF   ,8HNTEMPS  ,
     *          8HSCALE   ,8HALPHA   ,8HBOLTWT  ,
     *          8HXMIN    ,8HXMAX    ,8HYMIN    ,8HYMAX    ,
     *          8HZMIN    ,8HZMAX    ,8HSEPTOL  ,8HNPRT    ,
     *          8HRANDOM  ,8HIFXFRG  ,8HNFRMOV  ,8HDACRAT  ,
     *          8HUPDFAC  ,8HMCMIN   ,8HNFMORV  ,8HTTYPE   ,
     *          8HOPTN    ,8HNBLOCK  ,8HAIMOVE  ,8HNSTMIN  ,
     *          8HRNDINI  ,8HRIORD   ,8HMCTYP   ,8HNTRAN   ,
     *          8HNCDUMP  /
      DATA KQNAM / 3,  3,1,
     *            23,  3,5,
     *             3,  3,3,3,
     *             3,  3,3,1,
     *             5,201,1,3,
     *             3,  0,1,1,
     *             0,  1,3,1,
     *             0,  5,1,1,1/
C
      DATA GLOBOP/8HGLOBOP  /
      DATA OPT   /8HOPTIMIZE/
      DATA STANDARD /8HSTANDARD/, AVESTEP/8HAVESTEP /
      DATA DEBUG /8HDEBUG   /, RAND1/8HRAND1   /,RAND3/8HRAND3   /
      DATA RAND /8HRAND    /
C
C
C
C     ---- MAIN DRIVER FOR MONTE CARLO/SIMUMATED ANNEALING RUNS -----
C
C        THE FOLLOWING IS CONSIDERED THE MAIN OUTPUT FILE,
C        FOR BOTH ENERGIES AND COORDINATES.
C
      IPTRAJ = 4
      CALL SEQOPN(IPTRAJ,'TRAJECT','NEW',.FALSE.,'FORMATTED')
C
      NPUNCH=-2
C----------------------
C     NOW THAT WE ARE HERE WE CAN SWITCH TO NEW FMO INTERFACE
      FMOAPI_COORD=1 
      LAP=1
C        NEXT THREE INITIALIZATIONS MAY BE A BUG.
C        WITHOUT THEM, FTNCHEK COMPLAINS THEY ARE UNINITIALIZED VALUES.
C
      TEMPER=0.0D+00
C      DO I=1,3*NAT
C         ARAN(I)=0.0D+00
C      ENDDO
      Write(IW,*)'NFRG=',NFRG
      CALL FLSHBF(IW)
      if (NFRG.GT.1) THEN
      DO I=1,NFRG
         IFRMOV(I)=0
      ENDDO
      END IF
C---------------------
C	  Default parameters
      TEMPI = 20000.0D+00
      TEMPF = 0.0D+00
      NTEMPS = 1
      NFRMOV = 1
      NBLOCK=100
      MCMIN=.TRUE.
      OPTN=.FALSE.
      NTRAN = 1
C
      NSTMIN= 10
      AIMOVE=0.0D+00
C
      SCALE(1) = ONE
      SCALE(2) = ONE
      ALPHA = ZERO
      DACRAT = 0.5D+00
      UPDFAC = 0.95D+00
      SEPTOL = 2.8D+00
      XMIN = -1.0D+1
      XMAX =  1.0D+1
      YMIN = -1.0D+1
      YMAX =  1.0D+1
      ZMIN = -1.0D+1
      ZMAX =  1.0D+1
      BOLTWT = STANDARD
      RNDINI=.FALSE.
      RIORD=RAND
C     MCTYP is a bitwise flag for what type of groups are present      
C     (2=FMO,4=EFP,1=ab initio. so MCTYP=6 is FMO and EFP)
      MCTYP=2
C     TTYPE determines what type to move for each MCTYP=6 run
C     (0 is for random, 1 is for alternating)
      TTYPE=1
      TUMBLER=1
      NCDUMP=10
C     NCDUMP is the number of steps between dumping coordinates
C     to the .trj file.
C
C          NPRTGO=1 MEANS NORMAL PRINTING
C                =2 MEANS SUPPRESSED PRINTING
C
      NPRTGO = 2
C
C          IGOFLG=1 MEANS MONTE CARLO GLOBAL OPTIMIZATION IN PROGRESS
C                =2 MEANS ORDINARY GEOMETRY OPTIMIZATION
C
      IGOFLG = 1
C-------------------------
      RANDOM = RAND3
      DO 75 IFR=1,MXFRG
       IFXFRG(IFR)=0
 75   CONTINUE
C
      WRITE(IW,*) 'MCTYP/Nblock=',MCTYP,NBLOCK
      CALL FLSHBF(IW)
      JRET = 0
      CALL NAMEIO (IR,JRET,GLOBOP,NNAM,QNAM,KQNAM,
     *             TEMPI,TEMPF,NTEMPS,SCALE,ALPHA,
     *             BOLTWT,XMIN,XMAX,YMIN,YMAX,ZMIN,ZMAX,
     *             SEPTOL,NPRTGO,RANDOM,IFXFRG,NFRMOV,DACRAT,
     *             UPDFAC,MCMIN,NFMORV,TTYPE,OPTN,NBLOCK,
     *             AIMOVE,NSTMIN,RNDINI,RIORD,MCTYP,
     *     NTRAN,NCDUMP,0,0,0,  0,0,0,0,0,     0,0,0,0,0,
     *     0,0,0,0,0,     0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0)
      IF(JRET.GT.1) THEN
         IF(MASWRK) WRITE(IW,*) 'ERROR IN $GLOBOP GROUP'
         CALL ABRT
      END IF
      WRITE(IW,*) 'MCTYP/NBLOCK=',MCTYP,NBLOCK
      CALL FLSHBF(IW)
C
C      IF(MCTYP.EQ.0) THEN
C          IF (MASWRK) WRITE (IW,*) 'MCTYP must be specified'
C      END IF
      IF(NBLOCK.EQ.0) THEN
          IF (MASWRK) WRITE (IW,*) 'NBLOCK must be greater than 0'
          CALL ABRT
      END IF
C
      IF(MASWRK) THEN
          WRITE(IW,9100) TEMPI,TEMPF,NTEMPS,
     *                   NFRMOV,NBLOCK,SCALE,SEPTOL,
     *                   MCMIN,NSTMIN,OPTN,
     *                   XMIN,XMAX,YMIN,YMAX,ZMIN,ZMAX,
     *                   ALPHA,DACRAT,UPDFAC,BOLTWT,
     *                   AIMOVE,NPRTGO,RANDOM,RNDINI,RIORD
          WRITE(IW,9101) (IFXFRG(III),III=1,NFRG)
      END IF
 9100 FORMAT(/10X,'---- MONTE CARLO/SIMULATED ANNEALING OPTIONS -----'/
     *    1X,'TEMPI=',F10.1,' TEMPF=',F10.1,
     *       ' NTEMPS=',I4,/
     *    1X,'NFRMOV=',I4,' NBLOCK=',I4,
     *       ' SCALE=',2F6.2,' SEPTOL=',F6.3/
     *    1X,'MCMIN=',L2,' NSTMIN=',I4,' OPTN=',L2/
     *    1X,1P,'XMIN/XMAX=',2E10.2/
     *    1X,1P,'YMIN/YMAX=',2E10.2/
     *    1X,1P,'ZMIN/ZMAX=',2E10.2,0P/
     *    1X,'ALPHA=',F10.4,' DACRAT=',F10.4,' UPDFAC=',F10.4,
     *       ' BOLTWT=',A8/
     *    1X,'AIMOVE=',F9.4,'  NPRT=',I4,'  RANDOM=',A8,
     *    1X,'RNDINI=',L2,'  RIORD=',A8)
 9101 FORMAT(1X,'IFXFRG=',10I5)
      CALL FLSHBF(IW)
C
C        THIS OPTION SHARES A UNIT NUMBER WITH THE TRAJECTORY FILE,
C        SO IT IS TURNED OFF SO WE GET THAT MORE USEFUL DATA, INSTEAD.
C
C
C------------------
C	  Calculating parameters based on inputs
C
C      XMIN = XMIN * UNITS
C      XMAX = XMAX * UNITS
C      YMIN = YMIN * UNITS
C      YMAX = YMAX * UNITS
C      ZMIN = ZMIN * UNITS
C      ZMAX = ZMAX * UNITS
      XRANGE = XMAX - XMIN
      YRANGE = YMAX - YMIN
      ZRANGE = ZMAX - ZMIN
C      SEPTOL = SEPTOL * UNITS
      SCALE(1) = SCALE(1) * UNITS
      IF(TEMPI.LE.ZERO) THEN
        IF(MASWRK) WRITE(IW,*)
     *      'INITIAL TEMPERATURE MUST BE GREATER THAN ZERO.'
        CALL ABRT
      END IF
      GAMR = 1.0D+00
      IF(TEMPF.LT.ZERO) THEN
        IF(MASWRK) WRITE(IW,*)
     *      'FINAL TEMPERATURE MUST BE GREATER THAN ZERO.'
        CALL ABRT
      ELSE IF(TEMPF.GT.TEMPI) THEN
        IF(MASWRK) WRITE(IW,*)
     *      'FINAL TEMPERATURE CAN NOT BE GREATER THAN INITIAL.'
        CALL ABRT
      ELSE IF(TEMPF.EQ.ZERO) THEN
        IF(NTEMPS.GT.1) THEN
C CALCULATE FINAL TEMPERATURE BASED ON COOLING RATE OF 0.95
          GAMR=0.95D+00
C         GAMR=0.98D+00
         TEMPF=TEMPI*GAMR**(NTEMPS-1)
        ELSE IF(NTEMPS.LT.1) THEN
         IF(MASWRK) WRITE(IW,*)'NTEMPS MUST BE POSITIVE'
         CALL ABRT
        END IF
      ELSE
        IF(NTEMPS.GT.1) THEN
         GAMR = (TEMPF/TEMPI)**(ONE/(NTEMPS-1))
        ELSE IF(NTEMPS.LT.1) THEN
         IF(MASWRK) WRITE(IW,*)'NTEMPS MUST BE POSITIVE'
         CALL ABRT
        ELSE
C CALCULATE NUMBER OF TEMPERATURES BASED ON COOLING RATE OF 0.95
         GAMR=0.95D+00
C         GAMR=0.98D+00
         NTEMPS=INT(LOG(TEMPF/TEMPI)/LOG(GAMR))+1
         IF(MASWRK) WRITE(IW,*)'NUMBER OF TEMPERATURES WILL BE ',NTEMPS
        END IF
      END IF
      IF(BOLTWT.EQ.STANDARD) THEN
        IBWM = 0
      ELSE IF(BOLTWT.EQ.AVESTEP) THEN
        IBWM = 1
      ELSE
        IF(MASWRK) WRITE(IW,*)'ILLEGAL VALUE FOR BOLTWT IN $GLOBOP'
        CALL ABRT
      END IF
      IF(RANDOM.EQ.DEBUG) THEN
        IRTP = 0
      ELSE IF(RANDOM.EQ.RAND1) THEN
        IRTP = 1
      ELSE IF(RANDOM.EQ.RAND3) THEN
        IRTP = 3
      ELSE
        IF(MASWRK) WRITE(IW,*)'ILLEGAL VALUE FOR RANDOM IN $GLOBOP'
        CALL ABRT
      END IF
      IF(RIORD.NE.STANDARD.AND.RIORD.NE.RAND) THEN
        IF(MASWRK) WRITE(IW,*)'ILLEGAL VALUE FOR RIORD IN $GLOBOP'
        CALL ABRT
      END IF
      IF(NFRMOV.LT.0) THEN
        IF(MASWRK) WRITE(IW,*) 'NFRMOV CANNOT BE NEGATIVE'
        CALL ABRT
      ELSE IF(NFRMOV.GT.NFRG) THEN
        IF(MASWRK) WRITE(IW,*)'NFRMOV=',NFRMOV,
     *         ' IS GREATER THAN THE NUMBER OF FRAGMENTS=',NFRG
C        CALL ABRT
      END IF
C
C	End of calculation of parameters.  Now setting up memory allocation
C------------------
C 
C
C
C    NPBFMX will equal largest value in NPBF
      NPBFMX=NPBF(1)
      DO 15 IFRG=2,NFRG
        IF(NPBF(IFRG).GT.NPBFMX) NPBFMX=NPBF(IFRG)
 15   CONTINUE
C
C        SELECT THE STORAGE SIZE FOR RANDOM NUMBERS
C
      IF(AIMOVE.EQ.0.0D+00) THEN
         IMXRAN = NBLOCK*(6*(NFRG+NAT)+1)
      ELSE
         IMXRAN = NBLOCK*(6*(NFRG+NAT)+3*NAT+1)
      END IF
C
      MXBF=0
      DO I = 1, NFRG
         MXBF=MAX(MXBF,NPBF(I))
      END DO
C
C  ALLOCATE DYNAMIC MEMORY
C
      CALL VALFM(LOADFM)
      LDC     = LOADFM  + 1
      LDA     = LDC     + 3*NFRG
      LRN     = LDA    + 3*NFRG
      LWRK    = LRN     + IMXRAN
      LCMIN   = LWRK    + NUM*NUM
      LCOLD   = LCMIN   + 3*NAT + 22*NMTTPT + 12*NPTTPT + 12*NDPTTPT
     *                  + 3*NRTTPT + 3*NTPATM + MXBF*NTMO
     *                  + MXBF*NTAO + 3*NTMO + 3*NDTTPT + 3*NLJTTPT
      LPROVEC = LCOLD   + 3*NAT + 22*NMTTPT + 12*NPTTPT + 12*NDPTTPT
     *                  + 3*NRTTPT + 3*NTPATM + MXBF*NTMO
     *                  + MXBF*NTAO + 3*NTMO + 3*NDTTPT + 3*NLJTTPT
      LCTVEC  = LPROVEC + MXBF*NTMO
      LAST    = LCTVEC  + MXBF*NTAO
C 
C     TREATMENT OF FMO DENSITIES AND Z-VECTOR
C	This may need changing 
C------------------------------- 
      IF (NFG.NE.0) THEN
        NDPNT=0
        IF(IAND(NGUESS,8).NE.0) NDPNT=(NFG*NFG-NFG)/2
        NDAR30=0
        IF(IAND(MODPAR,512+1024).NE.0) NDAR30=1+NFG*2*2
C
        LIDMPNT = LAST
        LIDDPNT = LIDMPNT + (NDAR30-1)/NWDVAR+1
        LAST    = LIDDPNT + (NDPNT-1)/NWDVAR+1 

        LSCZVFLG = MCMIN.AND.IAND(MODGRD,32).NE.0.AND.
     *             IAND(MODPAR,512).NE.0
        IF (LSCZVFLG) THEN
          LIPTZVEC = LAST
C         LAST     = LIPTZVEC + 2*NFG/NWDVAR + 1
          LIPTLG   = LIPTZVEC + 2*NFG/NWDVAR + 1
          LAST     = LIPTLG   +   NFG/NWDVAR + 1
        END IF
      END IF
C   
      NEED = LAST  - LOADFM - 1
      CALL GETFM(NEED)
C
      LENPV=MXBF*NTMO
      IF (NFRG.GT.0.AND.NTMO.GT.0) THEN
         CALL DAREAD(IDAF,IODA,XX(LPROVEC),LENPV,267,0)
      END IF
      LENCV=MXBF*NTAO
      IF (NFRG.GT.0.AND.NTAO.GT.0) THEN
         CALL DAREAD(IDAF,IODA,XX(LCTVEC),LENCV,269,0)
      END IF
C
C   GETTING RANDOM INITIAL CLUSTER
C
      INIT=0
      IF(MASWRK)THEN
         CALL RNGEN(XX(LRN),IMXRAN,IRTP,INIT)
         CALL DDI_BCAST(2600,'F',XX(LRN),IMXRAN,MASTER)
      ELSE
         CALL DDI_BCAST(2600,'F',XX(LRN),IMXRAN,MASTER)
      END IF
      INIT=1
      IRN=LRN
C            
      IF(RNDINI) THEN
C        EFP randomization not currently working
C        IF(NFRG.GT.0) CALL EFPRAND(MASWRK,MCMIN,XX(LRN),
C     *   XX(LPROVEC),XX(LCTVEC),IRN)
        IF(NFG.GT.0) CALL FMORAND(IMXRAN,XX(LRN),IRN)
      END IF
C---------------------------------
C	Done with preparations, now to work
C---------------------------------

C
C  INITIALIZE GLOBAL OPTIMIZATION COUNT
C
      IGLO=0
      NACC=0
      NRPA=0
      NREJ=0
C  If a step that should print to traj is skipped for proximity alert,
C  ISTEP makes it so the next accepted move is printed
      ISTEP=0
C
C  DMAT is now a pair of constants since ALPHA is now removed as it is not used for Metropolis MC
C
C   EVALUATE ENERGY AND WAVE FUNCTION AT FIRST GEOMETRY
C
      XRAN=ZERO
      IF(MASWRK .AND. NPRINT.NE.-5) WRITE(IW,9050)
      CALL MC_ENERGY(0,XX(LCMIN),XX(LPROVEC),
     *      XX(LCTVEC),ACCEPT,XRAN,ZERO,NSTMIN,MCTYP)
      IGLO=IGLO+1
C     Store initial coordinates
      IF (NFRG.GT.0.AND.NTMO.GT.0) THEN
         CALL DAREAD(IDAF,IODA,XX(LPROVEC),LENPV,267,0)
      END IF
      IF (NFRG.GT.0.AND.NTAO.GT.0) THEN
         CALL DAREAD(IDAF,IODA,XX(LCTVEC),LENCV,269,0)
      END IF
      CALL STCOR(XX(LCOLD),XX(LPROVEC),XX(LCTVEC),MXBF)
      NPRINT=-5
C
      TEMPER = TEMPI
      ACCRATT = DACRAT
      IF(MASWRK) WRITE(IW,9126) GAMR,DACRAT,UPDFAC
      LDMC=1
      LDMA=1
C
C     ----LOOP OVER TEMPERATURE STARTS HERE ----
C
      DO 200 ITM=1,NTEMPS

      IF(MASWRK) WRITE(IW,9020) ITM,TEMPER
      NACCT=0
      NRPAT=0
      NREJT=0
      BETA=ONE/(TEMPER*SCALTM)
C
C  UPDATE MAXIMUM STEP SIZES TO GET DESIRED ACCEPTANCE RATIO
C
      IF(ACCRATT.GT.DACRAT) THEN
         UFAC = ONE/UPDFAC
      ELSE IF(ACCRATT.LT.DACRAT) THEN
         UFAC = UPDFAC
      ELSE
         UFAC = ONE
      END IF
C
      IDC=LDC
      IDA=LDA
      LDMC = LDMC * UFAC
      LDMA = LDMA * UFAC
      IF (MASWRK) WRITE(IW,229) LDMC, LDMA
 229  FORMAT(1X,'MAX.DISP.:',2F10.5)
      DO 225 INF=1,NFRG
       XX(IDC  ) = ZERO
       XX(IDC+1) = ZERO
       XX(IDC+2) = ZERO
       XX(IDA  ) = ZERO
       XX(IDA+1) = ZERO
       XX(IDA+2) = ZERO
       IDC=IDC+3
       IDA=IDA+3
 225   CONTINUE
C
C  GENERATE IMXRAN RANDOM NUMBERS
C
      INIT=0
      IF(MASWRK)THEN
         CALL RNGEN(XX(LRN),IMXRAN,IRTP,INIT)
         CALL DDI_BCAST(2600,'F',XX(LRN),IMXRAN,MASTER)
      ELSE
         CALL DDI_BCAST(2600,'F',XX(LRN),IMXRAN,MASTER)
      END IF
      INIT=1
      IRN=LRN
C
C        BIG LOOP OVER BLOCKS OF RANDOM COORDINATES
C        Use a switch arbitrarily called tumbler to decide whether to do an EFP or FMO step
C        Use either a random number to determine or simply switch back and forth
      DO ii=1,NBLOCK
        WRITE(IW,*)'MC step ii=',ii
        CALL FLSHBF(IW)
        IGLO=IGLO+1
        IF (iand(MCTYP,6)==6) THEN
            IF (TTYPE==0) THEN
                TUMBLER=2.0D+00*XX(IRN)-1.0D+00
                IRN=IRN+1
            ELSE
                TUMBLER=TUMBLER*(-1.0D+00)
            END IF
            IF (TUMBLER < 0.0D+00) THEN
                CALL MC_EFP_BLOCK(XX(LDC),LDMC,XX(LDA),LDMA,NFRMOV,
     *           XX(LPROVEC),XX(LCTVEC),XX(LRN),IRN,IFRMOV,NTRAN,IFXFRG)
                CALL PXALRT(ALERT,1)
                IF (ALERT .EQV. .TRUE.) THEN
                   NRPAT=NRPAT+1
                   ISTEP=1
                   CYCLE
                END IF
            END IF
            IF (TUMBLER >= 0.0D+00) THEN
                CALL MC_FMO_BLOCK(XX(LRN),IRN,NFMORV,
     *                LDMA,LDMC)
                CALL PXALRT(ALERT,0)
                IF (ALERT .EQV. .TRUE.) THEN
                    NRPAT=NRPAT+1
                    ISTEP=1
                    CYCLE
                END IF
            END IF
        ELSE IF(iand(MCTYP,4) .NE. 0) THEN
            CALL MC_EFP_BLOCK(XX(LDC),LDMC,XX(LDA),LDMA,NFRMOV,
     *           XX(LPROVEC),XX(LCTVEC),XX(LRN),IRN,IFRMOV,NTRAN,IFXFRG)
            CALL PXALRT(ALERT,1)
            IF (ALERT .EQV. .TRUE.) THEN
                NRPAT=NRPAT+1
                ISTEP=1
                CYCLE
            END IF
        ELSE IF(iand(MCTYP,2) .NE. 0) THEN
            CALL MC_FMO_BLOCK(XX(LRN),IRN,NFMORV,
     *              LDMA,LDMC)
            CALL PXALRT(ALERT,0)
            IF (ALERT .EQV. .TRUE.) THEN
                NRPAT=NRPAT+1
                ISTEP=1
                CYCLE
            END IF
        ELSE
            WRITE (IW,*) 'MCTYP NOT SET CORRECTLY'
            CALL ABRT
        END IF
C
C        IF (IAND(MCTYP,1) != 0) THEN
C            ab initio moving done here
C        END IF
C     ----------------------
      CALL MC_ENERGY(IGLO,XX(LCMIN),XX(LPROVEC),XX(LCTVEC),
     *               ACCEPT,XX(LRN),BETA,NSTMIN,MCTYP)
      IRN=IRN+2
C
C SAVE CURRENT COORDINATES OR RESTORE PREVIOUS 
C
        IF (ACCEPT) THEN
           IF (NFRG.GT.0.AND.NTMO.GT.0) THEN
              CALL DAREAD(IDAF,IODA,XX(LPROVEC),LENPV,267,0)
           END IF
           IF (NFRG.GT.0.AND.NTAO.GT.0) THEN
              CALL DAREAD(IDAF,IODA,XX(LCTVEC),LENCV,269,0)
           END IF
           CALL STCOR(XX(LCOLD),XX(LPROVEC),XX(LCTVEC),MXBF)
           NACCT=NACCT+1
        ELSE
           CALL RSTCOR(XX(LCOLD),XX(LPROVEC),XX(LCTVEC),MXBF)
           IF (NFRG.GT.0.AND.NTMO.GT.0) THEN
              CALL DAWRIT(IDAF,IODA,XX(LPROVEC),LENPV,267,0)
           END IF
           IF (NFRG.GT.0.AND.NTAO.GT.0) THEN
              CALL DAWRIT(IDAF,IODA,XX(LCTVEC),LENCV,269,0)
           END IF
           NREJT=NREJT+1
        END IF
C--------save coordinates if lowest energy
        IF(E.LT.EMIN) THEN
          EMIN=E
          IF (NFRG.GT.0.AND.NTMO.GT.0) THEN
            CALL DAREAD(IDAF,IODA,XX(LPROVEC),LENPV,267,0)
          END IF
          IF (NFRG.GT.0.AND.NTAO.GT.0) THEN
            CALL DAREAD(IDAF,IODA,XX(LCTVEC),LENCV,269,0)
          END IF
          CALL STCOR(XX(LCMIN),XX(LPROVEC),XX(LCTVEC),MXBF)
C 
          IF(MASWRK .AND. NPRTGO.NE.2) WRITE(IW,*) 'E=',E,'EMIN=',EMIN
C
C
          IGOMIN = IGLO
        END IF
C       WRITE OUT COORD EVERY 10 NBLOCKS (should be made adjustable)
C       OUTPUT GOES TO TRAJECT FILE
        IF(MOD(II,NCDUMP).EQ.0.OR.ISTEP==1) THEN
            WRITE(IPTRAJ,*)'CURRENT COORDINATES AT:'
            WRITE(IPTRAJ,*)'NBLOCK=/TEMPER=',II,TEMPER
            WRITE(IPTRAJ,*)'ENERGY = ',E
            WRITE(IPTRAJ,*)'CURRENT MINIMUM ENERGY = ',EMIN
            CALL PRATM(IPTRAJ,1)
            WRITE(IPTRAJ,*)'-------------------'
            ISTEP=0
        END IF
C   RESTORE MINIMUM COORDINATES AND OPTIMIZE STRUCTURE
C        IF (MCMIN .EQV. .TRUE. .AND. MOD(IGLO,NSTMIN) .EQ. 0) THEN
C          CALL RSTCOR(XX(LCMIN),XX(LPROVEC),XX(LCTVEC),MXBF)
C          IF (NFRG.GT.0.AND.NTMO.GT.0) THEN
C             CALL DAWRIT(IDAF,IODA,XX(LPROVEC),LENPV,267,0)
C          END IF
C          IF (NFRG.GT.0.AND.NTAO.GT.0) THEN
C             CALL DAWRIT(IDAF,IODA,XX(LCTVEC),LENCV,269,0)
C          END IF
C          TRUNTP=RUNTYP
C          RUNTYP=OPT
C          CALL SIGX(.FALSE.)
C          RUNTYP=TRUNTP
C        END IF
      END DO
C
      ACCRATT=NACCT
      ACCRATT=ACCRATT/(NACCT+NREJT-NRPAT)
      IF(MASWRK) WRITE(IW,9011) TEMPER,NRPAT,NBLOCK-NRPAT,NREJT-NRPAT,
     *                          NACCT,ACCRATT,EMIN,IGOMIN
      TEMPER = TEMPER * GAMR
      NACC=NACC+NACCT
      NREJ=NREJ+NREJT
      NRPA=NRPA+NRPAT
 200  CONTINUE
C----------------
C  End of big loop over Temperature
C----------------
C
      ACCRAT=NACC
      ACCRAT=ACCRAT/(NACC+NREJ-NRPA)
      IF(MASWRK) THEN
         WRITE(IW,9005)
         WRITE(IW,9010) IGLO,NRPA,IGLO-NRPA,NREJ,NACC+1,ACCRAT,
     *                  EPREV,EMIN,IGOMIN
         CALL PRFC
         CALL PRMNC(XX(LCMIN))
      END IF
C
      RUNTYP=OPT
      IF(NPRTGO.LT.0) NPRTGO=0
C
C  GEOMETRY OPTIMIZATION ON FINAL SA GEOMETRY
C
      IF(OPTN) THEN
         IF(MASWRK) WRITE(IW,9003)
         CALL SIGX(.FALSE.)
         IF(MASWRK) WRITE(IW,9002)
      END IF
      WRITE(IW,*)'AFTER calling SIGX for OPTN'
      CALL fLSHBF(IW)
C
C  GEOMETRY OPTIMIZATION ON MINIMUM-ENERGY SA GEOMETRY
C
      IF(OPTN) THEN
         IF(MASWRK) WRITE(IW,9004)
C
         CALL RSTCOR(XX(LCMIN),XX(LPROVEC),XX(LCTVEC),MXBF)
         IF (NFRG.GT.0.AND.NTMO.GT.0) THEN
            CALL DAWRIT(IDAF,IODA,XX(LPROVEC),LENPV,267,0)
         END IF
         IF (NFRG.GT.0.AND.NTAO.GT.0) THEN
            CALL DAWRIT(IDAF,IODA,XX(LCTVEC),LENCV,269,0)
         END IF
C
         CALL SIGX(.FALSE.)
         IF(MASWRK) WRITE(IW,9001)
      END IF
C
      CALL RETFM(NEED)
C   
      IF (NFG.NE.0) THEN
C        IF (LSCZVFLG) CALL RETZVEC
C        CALL RETDD
      END IF
C
      IF(MASWRK) WRITE(IW,*) '..... END OF GLOBAL OPTIMIZATION .....'
      NPRTGO= 1
      CALL TIMIT(1)
      RETURN
C
 9001 FORMAT(/10X,'***MINIMIZATION FROM MINIMUM-ENERGY SA ',
     *       'GEOMETRY COMPLETE***'/)
 9002 FORMAT(/10X,'***MINIMIZATION FROM FINAL SA GEOMETRY',
     *        ' COMPLETE***'/)
 9003 FORMAT(/10X,'***MINIMIZING ENERGY FROM FINAL SA GEOMETRY',
     *        '***'/)
 9004 FORMAT(/10X,'***MINIMIZING ENERGY FROM MINIMUM-ENERGY ',
     *        'SA GEOMETRY***'/)
 9005 FORMAT(/10X,'***GLOBAL OPTIMIZATION COMPLETE*** '/)
 9010 FORMAT(1X,'TOTAL NUMBER OF GEOMETRIES =   ',I6/
     *       1X,'NUMBER OF GEOMETRIES REJECTED '/
     *       1X,' DUE TO PROXIMITY ALERT =      ',I6/
     *       1X,'NUMBER OF ENERGY EVALUATIONS = ',I6/
     *       1X,'NUMBER OF ENERGIES REJECTED =  ',I6/
     *       1X,'NUMBER OF ENERGIES ACCEPTED =  ',I6/
     *       1X,'ACCEPTANCE RATIO =            ',F11.3/
     *       1X,'FINAL ENERGY FOUND =            ',F16.10/
     *       1X,'MINIMUM ENERGY FOUND =          ',F16.10,1X,
     *       1X,'AT GEOMETRY NUMBER ',I6//)
 9011 FORMAT(/10X,31(1H-)/10X,31HSTATISTICS FROM MONTE CARLO RUN/10X,
     *       31(1H-),//
     *       1X,'AT TEMPERATURE =               ',F9.2/
     *       1X,'NUMBER OF GEOMETRIES REJECTED ',/
     *       1X,' DUE TO PROXIMITY ALERT =      ',I6/
     *       1X,'NUMBER OF ENERGY EVALUATIONS = ',I6/
     *       1X,'NUMBER OF ENERGIES REJECTED =  ',I6/
     *       1X,'NUMBER OF ENERGIES ACCEPTED =  ',I6/
     *       1X,'ACCEPTANCE RATIO =            ',F11.3/
     *       1X,'MINIMUM ENERGY FOUND SO FAR =   ',F16.10,1X,
     *       1X,'AT GEOMETRY NUMBER ',I6,//)
 9020 FORMAT(1X,'TEMPERATURE NUMBER ',I3,' IS ',F9.2)
 9126 FORMAT(1X,'GAMR=',F12.6,' DACRAT=',F12.6,' UPDFAC=',F12.6)
 9050 FORMAT(/1X,19(1H-),5X,46(1H-)/
     *        1X,'GLOBAL OPTIMIZATION',5X,
     *        'WRITTEN BY PAUL DAY AND PRADIPTA BANDYOPADHYAY'/
     *        1X,19(1H-),5X,46(1H-))
      END
C*MODULE GLOBOP  *DECK STCOR
C> @brief stores minimum energy coordnates 
C>
C> @details stores EFP information including coordinates
C>          and coordinates in C, which means FMO and ab initio
C>
      SUBROUTINE STCOR(CMIN,PROVEC,CTVEC,MXBF)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXAO=8192, MXSHEF=1000, MXGEFP=4000,
     *           MXFRG=1050, MXFGPT=12000, MXDFG=5, MXIFRQ=12,
     *           MXDPPT=MXFRG*MXDFG*12, MXPT=2000)
C
      CHARACTER*8 FRGNME,REPNAM,POLNAM,DPOLNAM,DNAME,DPSNAM
      CHARACTER*8 LJNAME,ELJNAM
C
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NATEF(MXDFG),NUMEF(MXDFG),NTPATM
      COMMON /EFPCT / NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CTFOK(MXAO,MXDFG),NCTMO(MXDFG)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG)
      COMMON /FRGLJP/ CORDLJ(3,MXPT),ELJCRD(3,MXFGPT),
     *                POTLJ(2,MXPT),ELJPOT(2,MXFGPT),
     *                LJNAME(MXPT),ELJNAM(MXFGPT),
     *                NLJPTS(MXFRG),NLJTTPT,ILJP,NMLJ(2)
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ*MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
      COMMON /POL2  / DCORD(3,MXPT),CDIS(3,MXFGPT),
     *                CLPD(4*MXFGPT),ZLPD(4*MXFGPT),
     *                NLPD(4*MXFGPT),KFD(MXFGPT),KLD(MXFGPT),
     *                DNAME(MXPT),DPSNAM(MXFGPT)
      COMMON /REPPAR/ CREP(3,MXFGPT),CLPR(4*MXFGPT),ZLPR(4*MXFGPT),
     *                NLPR(4*MXFGPT),KFR(MXFGPT),KLR(MXFGPT),
     *                REPNAM(MXFGPT)
      COMMON /ZMTALT/ NZMAT2,NZVAR2,NVAR2,NZMTRD,ICOORD
C
      DIMENSION CMIN(*)
C
      DIMENSION PROVEC(MXBF,*),CTVEC(MXBF,*)
C
C     STORE NEW MINIMUM ENERGY COORDINATES
C
         IMN=1
         IF(ICOORD.NE.4) THEN
         DO 100 I = 1,NAT
            CMIN(IMN  ) = C(1,I)
            CMIN(IMN+1) = C(2,I)
            CMIN(IMN+2) = C(3,I)
            IMN=IMN+3
  100    CONTINUE
         END IF
C
         IF(NFRG.GT.0) THEN
            IAT=0
            DO 120 IFRG=1,NFRG
               DO 110 III=1,NMPTS(IFRG)
                  IAT=IAT+1
                  CMIN(IMN  ) = EFC(1,IAT)
                  CMIN(IMN+1) = EFC(2,IAT)
                  CMIN(IMN+2) = EFC(3,IAT)
                  IMN=IMN+3
  110         CONTINUE
  120      CONTINUE
C
            IAT=0
            NPST=0
            NLJST=0
            NDPST=0
            NRST=0
            NATST=0
            NORST=0
            NCTMOST=0
            NDST=0
            DO 121 IFRG=1,NFRG
               DO 119 III=1,NMPTS(IFRG)
                  IAT=IAT+1
C
                  CMIN(IMN  ) =  EFDIP(1,IAT)
                  CMIN(IMN+1) =  EFDIP(2,IAT)
                  CMIN(IMN+2) =  EFDIP(3,IAT)
                  CMIN(IMN+3) =  EFQAD(1,IAT)
                  CMIN(IMN+4) =  EFQAD(2,IAT)
                  CMIN(IMN+5) =  EFQAD(3,IAT)
                  CMIN(IMN+6) =  EFQAD(4,IAT)
                  CMIN(IMN+7) =  EFQAD(5,IAT)
                  CMIN(IMN+8) =  EFQAD(6,IAT)
                  CMIN(IMN+9) =  EFOCT(1,IAT)
                  CMIN(IMN+10) =  EFOCT(2,IAT)
                  CMIN(IMN+11) =  EFOCT(3,IAT)
                  CMIN(IMN+12) =  EFOCT(4,IAT)
                  CMIN(IMN+13) =  EFOCT(5,IAT)
                  CMIN(IMN+14) =  EFOCT(6,IAT)
                  CMIN(IMN+15) =  EFOCT(7,IAT)
                  CMIN(IMN+16) =  EFOCT(8,IAT)
                  CMIN(IMN+17) =  EFOCT(9,IAT)
                  CMIN(IMN+18) =  EFOCT(10,IAT)
                  IMN=IMN+19
  119         CONTINUE
              DO 111 III=1,NPPTS(IFRG)
                  NPST=NPST+1
                  CMIN(IMN  ) =  EFP(1,NPST)
                  CMIN(IMN+1) =  EFP(2,NPST)
                  CMIN(IMN+2) =  EFP(3,NPST)
                  CMIN(IMN+3) =  EFPOL(1,NPST)
                  CMIN(IMN+4) =  EFPOL(2,NPST)
                  CMIN(IMN+5) =  EFPOL(3,NPST)
                  CMIN(IMN+6) =  EFPOL(4,NPST)
                  CMIN(IMN+7) =  EFPOL(5,NPST)
                  CMIN(IMN+8) =  EFPOL(6,NPST)
                  CMIN(IMN+9) =  EFPOL(7,NPST)
                  CMIN(IMN+10) =  EFPOL(8,NPST)
                  CMIN(IMN+11) =  EFPOL(9,NPST)
                  IMN=IMN+12
  111         CONTINUE
              DO 112 III=1,NRPTS(IFRG)
                  NRST=NRST+1
                  CMIN(IMN  ) =  CREP(1,NRST)
                  CMIN(IMN+1) =  CREP(2,NRST)
                  CMIN(IMN+2) =  CREP(3,NRST)
                  IMN=IMN+3
  112         CONTINUE
              DO 113 III=1,NATEF(ISET(IFRG))
                  NATST=NATST+1
                  CMIN(IMN  ) =  PRCORD(1,NATST)
                  CMIN(IMN+1) =  PRCORD(2,NATST)
                  CMIN(IMN+2) =  PRCORD(3,NATST)
                  IMN=IMN+3
  113         CONTINUE
              DO 114 III=1,NLJPTS(IFRG)
                  NLJST=NLJST+1
                  CMIN(IMN  ) =  CORDLJ(1,NLJST)
                  CMIN(IMN+1) =  CORDLJ(2,NLJST)
                  CMIN(IMN+2) =  CORDLJ(3,NLJST)
                  IMN=IMN+3
  114         CONTINUE
              DO 115 NSHL = 1,NSHELL(ISET(IFRG))
                 ITYP=KMAX(NSHL,ISET(IFRG))-KMIN(NSHL,ISET(IFRG))+1
                 LOC = KLOC(NSHL,ISET(IFRG))
                 IF(ITYP.EQ.3) THEN
                   DO  III=1,NORB(IFRG)
                    CMIN(IMN  ) =  PROVEC(LOC  ,NORST+III)
                    CMIN(IMN+1) =  PROVEC(LOC+1,NORST+III)
                    CMIN(IMN+2) =  PROVEC(LOC+2,NORST+III)
                    IMN=IMN+3
                   END DO
                 END IF
                 IF(ITYP.EQ.4) THEN
                   DO  III=1,NORB(IFRG)
                    CMIN(IMN  ) =  PROVEC(LOC+1,NORST+III)
                    CMIN(IMN+1) =  PROVEC(LOC+2,NORST+III)
                    CMIN(IMN+2) =  PROVEC(LOC+3,NORST+III)
                    IMN=IMN+3
                   END DO
                 END IF
                 IF(ITYP.EQ.6) THEN
                   DO  III=1,NORB(IFRG)
                    CMIN(IMN  ) =  PROVEC(LOC  ,NORST+III)
                    CMIN(IMN+1) =  PROVEC(LOC+1,NORST+III)
                    CMIN(IMN+2) =  PROVEC(LOC+2,NORST+III)
                    CMIN(IMN+3) =  PROVEC(LOC+3,NORST+III)
                    CMIN(IMN+4) =  PROVEC(LOC+4,NORST+III)
                    CMIN(IMN+5) =  PROVEC(LOC+5,NORST+III)
                    IMN=IMN+6
                   END DO
                 END IF
                 IF(ITYP.EQ.10) THEN
                   DO  III=1,NORB(IFRG)
                    CMIN(IMN  ) =  PROVEC(LOC  ,NORST+III)
                    CMIN(IMN+1) =  PROVEC(LOC+1,NORST+III)
                    CMIN(IMN+2) =  PROVEC(LOC+2,NORST+III)
                    CMIN(IMN+3) =  PROVEC(LOC+3,NORST+III)
                    CMIN(IMN+4) =  PROVEC(LOC+4,NORST+III)
                    CMIN(IMN+5) =  PROVEC(LOC+5,NORST+III)
                    CMIN(IMN+6) =  PROVEC(LOC+6,NORST+III)
                    CMIN(IMN+7) =  PROVEC(LOC+7,NORST+III)
                    CMIN(IMN+8) =  PROVEC(LOC+8,NORST+III)
                    CMIN(IMN+9) =  PROVEC(LOC+9,NORST+III)
                    IMN=IMN+10
                   END DO
                 END IF
                 IF(ITYP.EQ.15) THEN
                   DO  III=1,NORB(IFRG)
                    CMIN(IMN  ) =  PROVEC(LOC  ,NORST+III)
                    CMIN(IMN+1) =  PROVEC(LOC+1,NORST+III)
                    CMIN(IMN+2) =  PROVEC(LOC+2,NORST+III)
                    CMIN(IMN+3) =  PROVEC(LOC+3,NORST+III)
                    CMIN(IMN+4) =  PROVEC(LOC+4,NORST+III)
                    CMIN(IMN+5) =  PROVEC(LOC+5,NORST+III)
                    CMIN(IMN+6) =  PROVEC(LOC+6,NORST+III)
                    CMIN(IMN+7) =  PROVEC(LOC+7,NORST+III)
                    CMIN(IMN+8) =  PROVEC(LOC+8,NORST+III)
                    CMIN(IMN+9) =  PROVEC(LOC+9,NORST+III)
                    CMIN(IMN+10) =  PROVEC(LOC+10,NORST+III)
                    CMIN(IMN+11) =  PROVEC(LOC+11,NORST+III)
                    CMIN(IMN+12) =  PROVEC(LOC+12,NORST+III)
                    CMIN(IMN+13) =  PROVEC(LOC+13,NORST+III)
                    CMIN(IMN+14) =  PROVEC(LOC+14,NORST+III)
                    IMN=IMN+15
                   END DO
                 END IF
                 IF(ITYP.EQ.3) THEN
                   DO  III=1,NCTMO(ISET(IFRG))
                    CMIN(IMN  ) =  CTVEC(LOC  ,NCTMOST+III)
                    CMIN(IMN+1) =  CTVEC(LOC+1,NCTMOST+III)
                    CMIN(IMN+2) =  CTVEC(LOC+2,NCTMOST+III)
                    IMN=IMN+3
                   END DO
                 END IF
                 IF(ITYP.EQ.4) THEN
                   DO  III=1,NCTMO(ISET(IFRG))
                    CMIN(IMN  ) =  CTVEC(LOC+1,NCTMOST+III)
                    CMIN(IMN+1) =  CTVEC(LOC+2,NCTMOST+III)
                    CMIN(IMN+2) =  CTVEC(LOC+3,NCTMOST+III)
                    IMN=IMN+3
                   END DO
                 END IF
                 IF(ITYP.EQ.6) THEN
                   DO  III=1,NCTMO(ISET(IFRG))
                    CMIN(IMN  ) =  CTVEC(LOC  ,NCTMOST+III)
                    CMIN(IMN+1) =  CTVEC(LOC+1,NCTMOST+III)
                    CMIN(IMN+2) =  CTVEC(LOC+2,NCTMOST+III)
                    CMIN(IMN+3) =  CTVEC(LOC+3,NCTMOST+III)
                    CMIN(IMN+4) =  CTVEC(LOC+4,NCTMOST+III)
                    CMIN(IMN+5) =  CTVEC(LOC+5,NCTMOST+III)
                    IMN=IMN+6
                   END DO
                 END IF
                 IF(ITYP.EQ.10) THEN
                   DO  III=1,NCTMO(ISET(IFRG))
                    CMIN(IMN  ) =  CTVEC(LOC  ,NCTMOST+III)
                    CMIN(IMN+1) =  CTVEC(LOC+1,NCTMOST+III)
                    CMIN(IMN+2) =  CTVEC(LOC+2,NCTMOST+III)
                    CMIN(IMN+3) =  CTVEC(LOC+3,NCTMOST+III)
                    CMIN(IMN+4) =  CTVEC(LOC+4,NCTMOST+III)
                    CMIN(IMN+5) =  CTVEC(LOC+5,NCTMOST+III)
                    CMIN(IMN+6) =  CTVEC(LOC+6,NCTMOST+III)
                    CMIN(IMN+7) =  CTVEC(LOC+7,NCTMOST+III)
                    CMIN(IMN+8) =  CTVEC(LOC+8,NCTMOST+III)
                    CMIN(IMN+9) =  CTVEC(LOC+9,NCTMOST+III)
                    IMN=IMN+10
                   END DO
                 END IF
                 IF(ITYP.EQ.15) THEN
                   DO  III=1,NCTMO(ISET(IFRG))
                    CMIN(IMN  ) =  CTVEC(LOC  ,NCTMOST+III)
                    CMIN(IMN+1) =  CTVEC(LOC+1,NCTMOST+III)
                    CMIN(IMN+2) =  CTVEC(LOC+2,NCTMOST+III)
                    CMIN(IMN+3) =  CTVEC(LOC+3,NCTMOST+III)
                    CMIN(IMN+4) =  CTVEC(LOC+4,NCTMOST+III)
                    CMIN(IMN+5) =  CTVEC(LOC+5,NCTMOST+III)
                    CMIN(IMN+6) =  CTVEC(LOC+6,NCTMOST+III)
                    CMIN(IMN+7) =  CTVEC(LOC+7,NCTMOST+III)
                    CMIN(IMN+8) =  CTVEC(LOC+8,NCTMOST+III)
                    CMIN(IMN+9) =  CTVEC(LOC+9,NCTMOST+III)
                    CMIN(IMN+10) = CTVEC(LOC+10,NCTMOST+III)
                    CMIN(IMN+11) = CTVEC(LOC+11,NCTMOST+III)
                    CMIN(IMN+12) = CTVEC(LOC+12,NCTMOST+III)
                    CMIN(IMN+13) = CTVEC(LOC+13,NCTMOST+III)
                    CMIN(IMN+14) = CTVEC(LOC+14,NCTMOST+III)
                    IMN=IMN+15
                   END DO
                 END IF
  115         CONTINUE
                 DO  III=1,NORB(IFRG)
                   CMIN(IMN  ) =  CENTCD(1,NORST+III)
                   CMIN(IMN+1) =  CENTCD(2,NORST+III)
                   CMIN(IMN+2) =  CENTCD(3,NORST+III)
                   IMN=IMN+3
                 END DO
                 NORST=NORST+NORB(IFRG)
                 NCTMOST=NCTMOST+NCTMO(ISET(IFRG))
C
C SAVE DYNAMIC POLARIZABILITY
C
              DO 116 III=1,NDPPTS(IFRG)
                  NDPST=NDPST+1
                  CMIN(IMN  ) =  EFDP(1,NDPST)
                  CMIN(IMN+1) =  EFDP(2,NDPST)
                  CMIN(IMN+2) =  EFDP(3,NDPST)
                  CMIN(IMN+3) =  EFDPOL(1,NDPST)
                  CMIN(IMN+4) =  EFDPOL(2,NDPST)
                  CMIN(IMN+5) =  EFDPOL(3,NDPST)
                  CMIN(IMN+6) =  EFDPOL(4,NDPST)
                  CMIN(IMN+7) =  EFDPOL(5,NDPST)
                  CMIN(IMN+8) =  EFDPOL(6,NDPST)
                  CMIN(IMN+9) =  EFDPOL(7,NDPST)
                  CMIN(IMN+10) =  EFDPOL(8,NDPST)
                  CMIN(IMN+11) =  EFDPOL(9,NDPST)
                  IMN=IMN+12
  116         CONTINUE
C
C SAVE DISPERSION COEFFICIENTS FOR EFP1-MP2
C
              DO 117 III=1,NDPTS(IFRG)
                  NDST=NDST+1
                  CMIN(IMN  ) =  CDIS(1,NDST)
                  CMIN(IMN+1) =  CDIS(2,NDST)
                  CMIN(IMN+2) =  CDIS(3,NDST)
                  IMN=IMN+3
  117         CONTINUE
  121      CONTINUE
         END IF
      RETURN
      END
C*MODULE GLOBOP  *DECK RSTCOR
C> @brief restores coordinates of minimum energy
C>
C> @details restores EFP information including coordinates
C>          and coordinates in C, which means FMO and ab initio
C>

      SUBROUTINE RSTCOR(CMIN,PROVEC,CTVEC,MXBF)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXAO=8192, MXSHEF=1000, MXGEFP=4000,
     *           MXFRG=1050, MXFGPT=12000, MXDFG=5, MXIFRQ=12,
     *           MXDPPT=MXFRG*MXDFG*12, MXPT=2000)
C
      CHARACTER*8 FRGNME,REPNAM,POLNAM,DPOLNAM,DNAME,DPSNAM
      CHARACTER*8 LJNAME,ELJNAM
C
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NATEF(MXDFG),NUMEF(MXDFG),NTPATM
      COMMON /EFPCT / NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CTFOK(MXAO,MXDFG),NCTMO(MXDFG)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG)
      COMMON /FRGLJP/ CORDLJ(3,MXPT),ELJCRD(3,MXFGPT),
     *                POTLJ(2,MXPT),ELJPOT(2,MXFGPT),
     *                LJNAME(MXPT),ELJNAM(MXFGPT),
     *                NLJPTS(MXFRG),NLJTTPT,ILJP,NMLJ(2)
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ*MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
      COMMON /POL2  / DCORD(3,MXPT),CDIS(3,MXFGPT),
     *                CLPD(4*MXFGPT),ZLPD(4*MXFGPT),
     *                NLPD(4*MXFGPT),KFD(MXFGPT),KLD(MXFGPT),
     *                DNAME(MXPT),DPSNAM(MXFGPT)
      COMMON /REPPAR/ CREP(3,MXFGPT),CLPR(4*MXFGPT),ZLPR(4*MXFGPT),
     *                NLPR(4*MXFGPT),KFR(MXFGPT),KLR(MXFGPT),
     *                REPNAM(MXFGPT)
      COMMON /ZMTALT/ NZMAT2,NZVAR2,NVAR2,NZMTRD,ICOORD
C
      DIMENSION CMIN(*)
C
      DIMENSION PROVEC(MXBF,*),CTVEC(MXBF,*)
C
C     RESTORE MINIMUM ENERGY COORDINATES OF AB INITIO ATOMS
C
      IMN=1
      IF(ICOORD.NE.4) THEN
         DO 100 I = 1,NAT
            C(1,I) = CMIN(IMN)
            C(2,I) = CMIN(IMN+1)
            C(3,I) = CMIN(IMN+2)
            IMN=IMN+3
  100    CONTINUE
      END IF
C
      IF(NFRG.GT.0) THEN
C
C     RESTORE MINIMUM ENERGY COORDINATES OF THE EFP
C
         IAT=0
         DO 120 IFRG=1,NFRG
            DO 110 III=1,NMPTS(IFRG)
               IAT=IAT+1
               EFC(1,IAT) = CMIN(IMN)
               EFC(2,IAT) = CMIN(IMN+1)
               EFC(3,IAT) = CMIN(IMN+2)
               IMN=IMN+3
  110       CONTINUE
  120    CONTINUE
C
         IAT=0
         NPST=0
         NLJST=0
         NDPST=0
         NRST=0
         NATST=0
         NORST=0
         NCTMOST=0
         NDST=0
C
         DO 121 IFRG=1,NFRG
C
C   RECOVER MULTIPOLE POTENTIAL
C
            DO 119 III=1,NMPTS(IFRG)
               IAT=IAT+1
               EFDIP(1,IAT) =  CMIN(IMN)
               EFDIP(2,IAT) =  CMIN(IMN+1)
               EFDIP(3,IAT) =  CMIN(IMN+2)
               EFQAD(1,IAT) =  CMIN(IMN+3)
               EFQAD(2,IAT) =  CMIN(IMN+4)
               EFQAD(3,IAT) =  CMIN(IMN+5)
               EFQAD(4,IAT) =  CMIN(IMN+6)
               EFQAD(5,IAT) =  CMIN(IMN+7)
               EFQAD(6,IAT) =  CMIN(IMN+8)
               EFOCT(1,IAT) =  CMIN(IMN+9)
               EFOCT(2,IAT) =  CMIN(IMN+10)
               EFOCT(3,IAT) =  CMIN(IMN+11)
               EFOCT(4,IAT) =  CMIN(IMN+12)
               EFOCT(5,IAT) =  CMIN(IMN+13)
               EFOCT(6,IAT) =  CMIN(IMN+14)
               EFOCT(7,IAT) =  CMIN(IMN+15)
               EFOCT(8,IAT) =  CMIN(IMN+16)
               EFOCT(9,IAT) =  CMIN(IMN+17)
               EFOCT(10,IAT) = CMIN(IMN+18)
               IMN=IMN+19
  119       CONTINUE
C
C     RECOVER DIPOLE POLARIZABILITY TENSORS
C
            DO 111 III=1,NPPTS(IFRG)
               NPST=NPST+1
               EFP(1,NPST) = CMIN(IMN)
               EFP(2,NPST) = CMIN(IMN+1)
               EFP(3,NPST) = CMIN(IMN+2)
               EFPOL(1,NPST) = CMIN(IMN+3)
               EFPOL(2,NPST) = CMIN(IMN+4)
               EFPOL(3,NPST) = CMIN(IMN+5)
               EFPOL(4,NPST) = CMIN(IMN+6)
               EFPOL(5,NPST) = CMIN(IMN+7)
               EFPOL(6,NPST) = CMIN(IMN+8)
               EFPOL(7,NPST) = CMIN(IMN+9)
               EFPOL(8,NPST) = CMIN(IMN+10)
               EFPOL(9,NPST) = CMIN(IMN+11)
               IMN=IMN+12
  111       CONTINUE
C
C       RECOVER FITTED REPULSION POTENTIAL
C
            DO 112 III=1,NRPTS(IFRG)
               NRST=NRST+1
               CREP(1,NRST) = CMIN(IMN)
               CREP(2,NRST) = CMIN(IMN+1)
               CREP(3,NRST) = CMIN(IMN+2)
               IMN=IMN+3
  112       CONTINUE
C
C       RECOVER PAULI FORMULA FOR EXCHANGE POTENTIAL
C
            DO 113 III=1,NATEF(ISET(IFRG))
               NATST=NATST+1
               PRCORD(1,NATST) = CMIN(IMN)
               PRCORD(2,NATST) = CMIN(IMN+1)
               PRCORD(3,NATST) = CMIN(IMN+2)
               IMN=IMN+3
  113       CONTINUE
C
            DO 114 III=1,NLJPTS(IFRG)
                NLJST=NLJST+1
                CORDLJ(1,NLJST) = CMIN(IMN  )
                CORDLJ(2,NLJST) = CMIN(IMN+1)
                CORDLJ(3,NLJST) = CMIN(IMN+2)
                IMN=IMN+3
  114       CONTINUE
C
            DO 115 NSHL = 1,NSHELL(ISET(IFRG))
               ITYP=KMAX(NSHL,ISET(IFRG))-KMIN(NSHL,ISET(IFRG))+1
               LOC = KLOC(NSHL,ISET(IFRG))
               IF(ITYP.EQ.3) THEN
                  DO III=1,NORB(IFRG)
                     PROVEC(LOC,NORST+III) = CMIN(IMN)
                     PROVEC(LOC+1,NORST+III) = CMIN(IMN+1)
                     PROVEC(LOC+2,NORST+III) = CMIN(IMN+2)
                     IMN=IMN+3
                  END DO
               END IF
               IF(ITYP.EQ.4) THEN
                  DO III=1,NORB(IFRG)
                     PROVEC(LOC+1,NORST+III) = CMIN(IMN)
                     PROVEC(LOC+2,NORST+III) = CMIN(IMN+1)
                     PROVEC(LOC+3,NORST+III) = CMIN(IMN+2)
                     IMN=IMN+3
                  END DO
               END IF
               IF(ITYP.EQ.6) THEN
                  DO III=1,NORB(IFRG)
                     PROVEC(LOC,NORST+III) = CMIN(IMN)
                     PROVEC(LOC+1,NORST+III) = CMIN(IMN+1)
                     PROVEC(LOC+2,NORST+III) = CMIN(IMN+2)
                     PROVEC(LOC+3,NORST+III) = CMIN(IMN+3)
                     PROVEC(LOC+4,NORST+III) = CMIN(IMN+4)
                     PROVEC(LOC+5,NORST+III) = CMIN(IMN+5)
                     IMN=IMN+6
                  END DO
               END IF
               IF(ITYP.EQ.10) THEN
                  DO  III=1,NORB(IFRG)
                     PROVEC(LOC,NORST+III) = CMIN(IMN)
                     PROVEC(LOC+1,NORST+III) = CMIN(IMN+1)
                     PROVEC(LOC+2,NORST+III) = CMIN(IMN+2)
                     PROVEC(LOC+3,NORST+III) = CMIN(IMN+3)
                     PROVEC(LOC+4,NORST+III) = CMIN(IMN+4)
                     PROVEC(LOC+5,NORST+III) = CMIN(IMN+5)
                     PROVEC(LOC+6,NORST+III) = CMIN(IMN+6)
                     PROVEC(LOC+7,NORST+III) = CMIN(IMN+7)
                     PROVEC(LOC+8,NORST+III) = CMIN(IMN+8)
                     PROVEC(LOC+9,NORST+III) = CMIN(IMN+9)
                     IMN=IMN+10
                  END DO
               END IF
               IF(ITYP.EQ.15) THEN
                  DO  III=1,NORB(IFRG)
                     PROVEC(LOC,NORST+III) = CMIN(IMN)
                     PROVEC(LOC+1,NORST+III) = CMIN(IMN+1)
                     PROVEC(LOC+2,NORST+III) = CMIN(IMN+2)
                     PROVEC(LOC+3,NORST+III) = CMIN(IMN+3)
                     PROVEC(LOC+4,NORST+III) = CMIN(IMN+4)
                     PROVEC(LOC+5,NORST+III) = CMIN(IMN+5)
                     PROVEC(LOC+6,NORST+III) = CMIN(IMN+6)
                     PROVEC(LOC+7,NORST+III) = CMIN(IMN+7)
                     PROVEC(LOC+8,NORST+III) = CMIN(IMN+8)
                     PROVEC(LOC+9,NORST+III) = CMIN(IMN+9)
                     PROVEC(LOC+10,NORST+III) = CMIN(IMN+10)
                     PROVEC(LOC+11,NORST+III) = CMIN(IMN+11)
                     PROVEC(LOC+12,NORST+III) = CMIN(IMN+12)
                     PROVEC(LOC+13,NORST+III) = CMIN(IMN+13)
                     PROVEC(LOC+14,NORST+III) = CMIN(IMN+14)
                     IMN=IMN+15
                  END DO
               END IF
               IF(ITYP.EQ.3) THEN
                  DO  III=1,NCTMO(ISET(IFRG))
                     CTVEC(LOC,NCTMOST+III) = CMIN(IMN)
                     CTVEC(LOC+1,NCTMOST+III) = CMIN(IMN+1)
                     CTVEC(LOC+2,NCTMOST+III) = CMIN(IMN+2)
                     IMN=IMN+3
                  END DO
               END IF
               IF(ITYP.EQ.4) THEN
                  DO  III=1,NCTMO(ISET(IFRG))
                     CTVEC(LOC+1,NCTMOST+III) = CMIN(IMN)
                     CTVEC(LOC+2,NCTMOST+III) = CMIN(IMN+1)
                     CTVEC(LOC+3,NCTMOST+III) = CMIN(IMN+2)
                     IMN=IMN+3
                  END DO
               END IF
               IF(ITYP.EQ.6) THEN
                  DO  III=1,NCTMO(ISET(IFRG))
                     CTVEC(LOC,NCTMOST+III) = CMIN(IMN)
                     CTVEC(LOC+1,NCTMOST+III) = CMIN(IMN+1)
                     CTVEC(LOC+2,NCTMOST+III) = CMIN(IMN+2)
                     CTVEC(LOC+3,NCTMOST+III) = CMIN(IMN+3)
                     CTVEC(LOC+4,NCTMOST+III) = CMIN(IMN+4)
                     CTVEC(LOC+5,NCTMOST+III) = CMIN(IMN+5)
                     IMN=IMN+6
                  END DO
               END IF
               IF(ITYP.EQ.10) THEN
                  DO  III=1,NCTMO(ISET(IFRG))
                     CTVEC(LOC,NCTMOST+III) = CMIN(IMN)
                     CTVEC(LOC+1,NCTMOST+III) = CMIN(IMN+1)
                     CTVEC(LOC+2,NCTMOST+III) = CMIN(IMN+2)
                     CTVEC(LOC+3,NCTMOST+III) = CMIN(IMN+3)
                     CTVEC(LOC+4,NCTMOST+III) = CMIN(IMN+4)
                     CTVEC(LOC+5,NCTMOST+III) = CMIN(IMN+5)
                     CTVEC(LOC+6,NCTMOST+III) = CMIN(IMN+6)
                     CTVEC(LOC+7,NCTMOST+III) = CMIN(IMN+7)
                     CTVEC(LOC+8,NCTMOST+III) = CMIN(IMN+8)
                     CTVEC(LOC+9,NCTMOST+III) = CMIN(IMN+9)
                     IMN=IMN+10
                  END DO
               END IF
               IF(ITYP.EQ.15) THEN
                  DO  III=1,NCTMO(ISET(IFRG))
                     CTVEC(LOC,NCTMOST+III) = CMIN(IMN)
                     CTVEC(LOC+1,NCTMOST+III) = CMIN(IMN+1)
                     CTVEC(LOC+2,NCTMOST+III) = CMIN(IMN+2)
                     CTVEC(LOC+3,NCTMOST+III) = CMIN(IMN+3)
                     CTVEC(LOC+4,NCTMOST+III) = CMIN(IMN+4)
                     CTVEC(LOC+5,NCTMOST+III) = CMIN(IMN+5)
                     CTVEC(LOC+6,NCTMOST+III) = CMIN(IMN+6)
                     CTVEC(LOC+7,NCTMOST+III) = CMIN(IMN+7)
                     CTVEC(LOC+8,NCTMOST+III) = CMIN(IMN+8)
                     CTVEC(LOC+9,NCTMOST+III) = CMIN(IMN+9)
                     CTVEC(LOC+10,NCTMOST+III) = CMIN(IMN+10)
                     CTVEC(LOC+11,NCTMOST+III) = CMIN(IMN+11)
                     CTVEC(LOC+12,NCTMOST+III) = CMIN(IMN+12)
                     CTVEC(LOC+13,NCTMOST+III) = CMIN(IMN+13)
                     CTVEC(LOC+14,NCTMOST+III) = CMIN(IMN+14)
                     IMN=IMN+15
                  END DO
               END IF
  115       CONTINUE
            DO III=1,NORB(IFRG)
               CENTCD(1,NORST+III) = CMIN(IMN)
               CENTCD(2,NORST+III) = CMIN(IMN+1)
               CENTCD(3,NORST+III) = CMIN(IMN+2)
               IMN=IMN+3
            END DO
            NORST=NORST+NORB(IFRG)
            NCTMOST=NCTMOST+NCTMO(ISET(IFRG))
C
C RECOVER DYNAMIC POLARIZABILITY
C
            DO 116 III=1,NDPPTS(IFRG)
               NDPST=NDPST+1
               EFDP(1,NDPST) = CMIN(IMN)
               EFDP(2,NDPST) = CMIN(IMN+1)
               EFDP(3,NDPST) = CMIN(IMN+2)
               EFDPOL(1,NDPST) = CMIN(IMN+3)
               EFDPOL(2,NDPST) = CMIN(IMN+4)
               EFDPOL(3,NDPST) = CMIN(IMN+5)
               EFDPOL(4,NDPST) = CMIN(IMN+6)
               EFDPOL(5,NDPST) = CMIN(IMN+7)
               EFDPOL(6,NDPST) = CMIN(IMN+8)
               EFDPOL(7,NDPST) = CMIN(IMN+9)
               EFDPOL(8,NDPST) = CMIN(IMN+10)
               EFDPOL(9,NDPST) = CMIN(IMN+11)
               IMN=IMN+12
  116       CONTINUE
C
C RECOVER DISPERSION COEFFICIENTS FOR EFP1-MP2
C
            DO 117 III=1,NDPTS(IFRG)
                NDST=NDST+1
                CDIS(1,NDST) = CMIN(IMN  )
                CDIS(2,NDST) = CMIN(IMN+1)
                CDIS(3,NDST) = CMIN(IMN+2)
                IMN=IMN+3
  117       CONTINUE
C
  121    CONTINUE
      END IF
C
      CALL EFCM
C
      RETURN
      END
C*MODULE GLOBOP  *DECK PRMNC
C> @brief prints current set of minimum energy coordinates
C>
C> @param CMIN allows for specifying the stored coordinates to print
C>
      SUBROUTINE PRMNC(CMIN)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXATM=2000, MXPT=2000, MXFRG=1050, MXAO=8192,
     *           MXFGPT=12000,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      CHARACTER*6 FRGNAM
      CHARACTER*8 FRGNME,PTNAM
C
      DIMENSION CMIN(*)
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG)
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      COMMON /ZMTALT/ NZMAT2,NZVAR2,NVAR2,NZMTRD,ICOORD
C
      PARAMETER (ZERO=0.0D+00,UNITS = 0.52917724924D+00)
C
C     PRINT MINIMUM ENERGY COORDINATES
C
      IF(MASWRK) WRITE(IW,9010)
C
      IMN=1
      IF(ICOORD.NE.4) THEN
         DO I = 1,NAT
            IF(MASWRK) WRITE(IW,9028) I,ANAM(I),BNAM(I),
     *             CMIN(IMN)*UNITS,CMIN(IMN+1)*UNITS,CMIN(IMN+2)*UNITS
         IMN=IMN+3
         ENDDO
      END IF
C
      IF(NFRG.GT.0) THEN
         IF(MASWRK) WRITE(IW,9011)
         IF(MASWRK) WRITE(IW,9021)
         IAT=0
         KMASS=0
         DO 120 IFRG=1,NFRG
            IF(MASWRK) WRITE(IW,9022) FRGNAM(IFRG)
            DO 110 III=1,NMPTS(IFRG)
               IAT=IAT+1
               IF(FMASS(III+KMASS).GT.ZERO) THEN
                  XF =  CMIN(IMN)*UNITS
                  YF =  CMIN(IMN+1)*UNITS
                  ZF =  CMIN(IMN+2)*UNITS
                  IF(MASWRK) WRITE(IW,9031) FRGNME(IAT),XF,YF,ZF
               END IF
               IMN=IMN+3
  110      CONTINUE
           KMASS=KMASS+NMPTS(IFRG)
  120   CONTINUE
      END IF
C
      RETURN
C
 9010 FORMAT(/2X,'COORDINATES OF MINIMUM ENERGY GEOMETRY (ANGS):'/)
 9011 FORMAT(1X,'COORDINATES OF FRAGMENT MULTIPOLE CENTERS (ANGS)')
 9021 FORMAT(1X,'MULTIPOLE NAME',9X,'X',18X,'Y',18X,'Z'/
     *       1X,60(1H-))
 9022 FORMAT(1X,'FRAGNAME=',A6)
 9028 FORMAT(1X,I3,2X,A8,A2,3F18.13)
 9031 FORMAT(1X,A8,7X,3F18.13)
C
      END
C*MODULE GLOBOP  *DECK PRFC
C> @brief prints current set of EFP and C coordinates
C>
      SUBROUTINE PRFC
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXATM=2000, MXAO=8192, MXPT=2000, MXFRG=1050,
     *           MXFGPT=12000,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      CHARACTER*6 FRGNAM
      CHARACTER*8 FRGNME,PTNAM
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG)
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      COMMON /ZMTALT/ NZMAT2,NZVAR2,NVAR2,NZMTRD,ICOORD
C
      PARAMETER (ZERO=0.0D+00,UNITS = 0.52917724924D+00)
C
C     PRINT MINIMUM ENERGY COORDINATES
C
      IF(MASWRK) WRITE(IW,9010)
C
      IF(ICOORD.NE.4) THEN
         DO I = 1,NAT
            IF(MASWRK) WRITE (IW,9028) I,ANAM(I),BNAM(I),
     *               C(1,I)*UNITS,C(2,I)*UNITS,C(3,I)*UNITS
         ENDDO
      END IF
C
      IF(NFRG.GT.0) THEN
         IF(MASWRK) WRITE(IW,9011)
         IF(MASWRK) WRITE(IW,9021)
         IAT=0
         KMASS=0
         DO 120 IFRG=1,NFRG
            IF(MASWRK) WRITE(IW,9022) FRGNAM(IFRG)
            DO 110 III=1,NMPTS(IFRG)
               IAT=IAT+1
               IF(FMASS(III+KMASS).GT.ZERO) THEN
                  XF = EFC(1,IAT)*UNITS
                  YF = EFC(2,IAT)*UNITS
                  ZF = EFC(3,IAT)*UNITS
                  IF(MASWRK) WRITE(IW,9031) FRGNME(IAT),XF,YF,ZF
               END IF
  110      CONTINUE
           KMASS=KMASS+NMPTS(IFRG)
  120   CONTINUE
      END IF
C
      RETURN
C
 9010 FORMAT(2X,'COORDINATES OF FINAL GEOMETRY (ANGS):'/)
 9011 FORMAT(1X,'COORDINATES OF FRAGMENT MULTIPOLE CENTERS (ANGS)')
 9021 FORMAT(1X,'MULTIPOLE NAME',9X,'X',18X,'Y',18X,'Z'/
     *       1X,60(1H-))
 9022 FORMAT(1X,'FRAGNAME=',A6)
 9028 FORMAT(1X,I3,2X,A8,A2,3F18.13)
 9031 FORMAT(1X,A8,7X,3F18.13)
C
      END
C*MODULE GLOBOP  *DECK RNGEN
C> @brief random number generator driver
C>
      SUBROUTINE RNGEN(RANNUM,NRN,IRTP,INIT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION RANNUM(NRN),ITIMST(6)
C
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
C
C        THE SEED -IX- IS EITHER A CONSTANT FOR DEBUGGING PURPOSES,
C        OR IS BASED ON THE TIME STRING.  ALL VALUES IN THE TIME
C        STRING ARE SUMMED SINCE DIFFERENT O/S RETURN THE SECONDS
C        FIELD IN DIFFERENT POSITIONS.  WE WANT TO BE SURE TO PICK
C        UP THE SECONDS PART OF THE STRING TO BE MORE RANDOMIZED.
C
      IF(INIT.EQ.0) THEN
         IA = 1345
         IC = 0
         M = 2**19 - 1
         IF(IRTP.EQ.0) THEN
            IX = 64097
         ELSE
            CALL TMDATE(ITIMST)
            IX=0
            LENTIM=6
            IF(NWDVAR.EQ.1) LENTIM=3
            DO I=1,LENTIM
               IX=IX+ITIMST(I)
            ENDDO
         END IF
         IX  = IABS(IX)
         IDUM= -IX
      END IF
C
      IF(IRTP.EQ.3) THEN
         DO I=1,NRN
            CALL RAND3(IDUM,RANNUM(I))
         ENDDO
      ELSE
         DO I=1,NRN
            ITEMP = IA*IX + IC
            IX = MOD(ITEMP,M)
            RANNUM(I)=IX
            RANNUM(I)=RANNUM(I)/(M-1)
         ENDDO
      END IF
      RETURN
      END
C*MODULE GLOBOP  *DECK RAND3
C> @brief random number generator from numerical recipe
C>
      SUBROUTINE RAND3(IDUM,RAN3)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C  ON FIRST CALL IDUM SHOULD BE LESS THAN ZERO
C  (C) COPR. 1986-92 NUMERICAL RECIPES SOFTWARE
C
      INTEGER IDUM
      INTEGER MBIG,MSEED,MZ
      PARAMETER (MBIG=1000000000,MSEED=161803398,MZ=0,FAC=1.0D+00/MBIG)
      DIMENSION MA(55)
      SAVE IFF,INEXT,INEXTP,MA
      DATA IFF /0/
C
      IF(IDUM.LT.0.OR.IFF.EQ.0) THEN
        IFF=1
        MJ=IABS(MSEED-IABS(IDUM))
        MJ=MOD(MJ,MBIG)
        MA(55)=MJ
        MK=1
        DO 11 I=1,54
          II=MOD(21*I,55)
          MA(II)=MK
          MK=MJ-MK
          IF(MK.LT.MZ) MK=MK+MBIG
          MJ=MA(II)
11      CONTINUE
        DO 13 K=1,4
          DO 12 I=1,55
            MA(I)=MA(I)-MA(1+MOD(I+30,55))
            IF(MA(I).LT.MZ) MA(I)=MA(I)+MBIG
12        CONTINUE
13      CONTINUE
        INEXT=0
        INEXTP=31
        IDUM=1
      END IF
C
      INEXT=INEXT+1
      IF(INEXT.EQ.56) INEXT=1
      INEXTP=INEXTP+1
      IF(INEXTP.EQ.56) INEXTP=1
C
      MJ=MA(INEXT)-MA(INEXTP)
      IF(MJ.LT.MZ) MJ=MJ+MBIG
      MA(INEXT)=MJ
      RAN3=MJ*FAC
      RETURN
      END
C
C*MODULE GLOBOP   *DECK PXALRT
C> @brief tests coordinate proximity
C>
C> @details Either rus through all of the EFP groups and
C>          determines the distance to all other coordinates
C>          or starts with the FMO atoms and does the same.
C>          For FMO, FMOID makes sure atoms in the same group
C>          are not compared.
C>
C> @param alert intent out, tracks whether there is a
C>              proximity issue
C> @param flag determines whether EFP or FMO is being looked at
C>        (1=EFP,0=FMO)
C>
      SUBROUTINE PXALRT(ALERT,FLAG)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C INDENTING NEEDS TO BE FIXED 
C NAT is set by FMO so it works
C FLAG determines whether to test FMO/AB INIT or EFP
C
      INTEGER FLAG
      LOGICAL ALERT,MCMIN
C
      PARAMETER (MXATM=2000,
     *           MXPT=2000, MXFRG=1050, MXDFG=5, MXFGPT=12000,
     *           MXDPPT=MXFRG*MXDFG*12)
C
      CHARACTER*8 FRGNME
C
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG)
      COMMON /FMOAPI/ FMOID(MXATM),FMOAPI_COORD,LAP,LKEEPER
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      COMMON /GLOFMO/ MCMIN
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /SIMEN / EPREV,EMIN,ALPHA,DAVE,XMIN,XMAX,YMIN,YMAX
     *               ,ZMIN,ZMAX,XRANGE,YRANGE,ZRANGE,SEPTOL
     *               ,DACRAT,UPDFAC
      COMMON /ZMTALT/ NZMAT2,NZVAR2,NVAR2,NZMTRD,ICOORD
C
C     CHECK THE DISPLACEMENT FOR NUCLEI TOO CLOSE TOGETHER
C     IF ANY ARE, REGISTER A PROXIMITY ALERT!
C
      ALERT=.FALSE.
      IF(FLAG.EQ.1) THEN
      IF(NFRG.GT.0) THEN
        IAT=0
        KMASS=0
        DO 220 IFRG=1,NFRG
         DO 210 III=1,NMPTS(IFRG)
          IAT=IAT+1
          IF(FMASS(III+KMASS).GT.0.0D+00) THEN
           XF = EFC(1,IAT)
           YF = EFC(2,IAT)
           ZF = EFC(3,IAT)
           IF(NAT.gt.0) THEN
            DO 400 I = 1,NAT
              SEP2 = (XF-C(1,I))**2+(YF-C(2,I))**2+(ZF-C(3,I))**2
              SEP = SQRT(SEP2)
              IF(SEP.LT.SEPTOL) THEN
                ALERT = .TRUE.
                RETURN
              END IF
  400       END DO
           END IF
           IAT2=0
           KMASS2=0
           DO 202 IFRG2=1,NFRG
             DO 201 III2=1,NMPTS(IFRG2)
               IAT2=IAT2+1
               IF(IFRG2.LE.IFRG) GO TO 201
               IF(FMASS(III2+KMASS2).GT.0.0D+00) THEN
                 XF2 = EFC(1,IAT2)
                 YF2 = EFC(2,IAT2)
                 ZF2 = EFC(3,IAT2)
                 SEP2 = (XF-XF2)**2+(YF-YF2)**2+(ZF-ZF2)**2
                 SEP = SQRT(SEP2)
                 IF(SEP.LT.SEPTOL) THEN
                   ALERT = .TRUE.
                   RETURN
                 END IF
               END IF
  201        END DO
             KMASS2=KMASS2+NMPTS(IFRG2)
  202      END DO
          END IF
  210    END DO
         KMASS=KMASS+NMPTS(IFRG)
  220   END DO
      END IF
      ELSE
      IF (NAT.NE.0) THEN
        IAT=0
        DO 310 IFRG=1,NAT
          IAT=IAT+1
          XF = C(1,IAT)
          YF = C(2,IAT)
          ZF = C(3,IAT)
          IF(NFRG.GT.0) THEN
            IAT2=0
            KMASS=0
            DO 302 JFRAG=1,NFRG
              DO 301 III=1,NMPTS(JFRAG)
               IAT2=IAT2+1
               IF(IFRG2.LE.IFRG) GO TO 301
               IF(FMASS(III2+KMASS2).GT.0.0D+00) THEN
                 XF2 = EFC(1,IAT2)
                 YF2 = EFC(2,IAT2)
                 ZF2 = EFC(3,IAT2)
                 SEP2 = (XF-XF2)**2+(YF-YF2)**2+(ZF-ZF2)**2
                 SEP = SQRT(SEP2)
                 IF(SEP.LT.SEPTOL) THEN
                   ALERT = .TRUE.
                   RETURN
                 END IF
               END IF
  301         END DO
             KMASS2=KMASS2+NMPTS(IFRG2)
  302       END DO
          END IF
          DO I=1,NAT
C-------Use FMOID to make sure that atoms in the same fragment
C-------are ignored by PXALRT
            IF(FMOID(IAT).NE.FMOID(I))THEN
            SEP2 = (XF-C(1,I))**2+(YF-C(2,I))**2+(ZF-C(3,I))**2
            SEP = SQRT(SEP2)
            IF(SEP.LT.SEPTOL.AND.SEP.NE.0) THEN
              ALERT = .TRUE.
              RETURN
            END IF
            END IF
          END DO
  310   END DO
      END IF
      END IF
      WRITE(6,*)'Leaving PXALRT with ALERT=',ALERT 
      CALL FLSHBF(IW)
C
      RETURN
      END SUBROUTINE
C*MODULE GLOBOP  *DECK FMORAND
C> @brief randomizes the initial coordinates of FMO groups
C>
C> @author Caleb Carlin
C>
C> @param IMXRAN max random numbers stored
C> @param IRTP 
C> @param LRN array of random numbers
C> @param IRN current position in LRN
C>
      SUBROUTINE FMOrand(IMXRAN,LRN,IRN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C     routine to randomly distribute FMO fragments if RNDINI=true
C     EFP groups are taken into account for proximity alerts, but are
C     moved elsewhere
      PARAMETER (MXATM=2000, MXFRG=1050)
C      COMMON /FMCOM / XX(1)
      COMMON /FMOAPI/ FMOID(MXATM),FMOAPI_COORD,LAP,LKEEPER
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /GLOFMO/ MCMIN
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)

      DOUBLE PRECISION AVEXYZ(MXFRG,3)
      DIMENSION LRN(*)
      DOUBLE PRECISION LRN
C      DIMENSION AVEXYZ(1050,3)
      LOGICAL GOPARR,DSKWRK,ALERT,MASWRK,MCMIN

      If (MASWRK) THEN
        WRITE(IW,*) ' '
        WRITE(IW,*) 'BEGINNING RANDOMINZG FMO CLUSTER FRAGMENTS'
      END IF

C
C     This should be changed to a do while loop
C
   30 CONTINUE
      ALERT=.FALSE.
      IF (IRN .GE. IMXRAN-10) IRN = 1
      WRITE(IW,*)'tgeox IRN=',IRN
C      CALL FLSHBF(IW)
C      call FLSHBF(IW)
C     SETTING UP RANDOM NUMBERS
C        INIT=0
C        IF(MASWRK) THEN
C          CALL RNGEN(LRN(1),IMXRAN,IRTP,INIT)
C          CALL DDI_BCAST(2600,'F',LRN,IMXRAN,MASTER)
C        ELSE
C          CALL DDI_BCAST(2600,'F',LRN,IMXRAN,MASTER)
C        END IF
C        INIT=1
C        IRN=1

        DO IFRG=1,NFG
          AVEXYZ(IFRG,1)=0.0D+00
          AVEXYZ(IFRG,2)=0.0D+00
          AVEXYZ(IFRG,3)=0.0D+00
          DENOM=0
          DO III=1,NAT
            IF(FMOID(III)==IFRG) THEN
              AVEXYZ(IFRG,1)=AVEXYZ(IFRG,1)+C(1,III)
              AVEXYZ(IFRG,2)=AVEXYZ(IFRG,2)+C(2,III)
              AVEXYZ(IFRG,3)=AVEXYZ(IFRG,3)+C(3,III)
              DENOM=DENOM+1
C              WRITE(IW,*)'FRAG III AVEX',IFRG,III,AVEXYZ(IFRG,1)
C              WRITE(IW,*)'DENOM=',DENOM
C              CALL FLSHBF(IW)
            END IF
          END DO
          AVEXYZ(IFRG,1)=AVEXYZ(IFRG,1)/DENOM
          AVEXYZ(IFRG,2)=AVEXYZ(IFRG,2)/DENOM
          AVEXYZ(IFRG,3)=AVEXYZ(IFRG,3)/DENOM
        END DO
C
        DO INF=1,NFG
          DX=4.0D+00*(2.0D+00*LRN(IRN  )-1.0D+00)-AVEXYZ(INF,1)
          DY=4.0D+00*(2.0D+00*LRN(IRN+1)-1.0D+00)-AVEXYZ(INF,2)
          DZ=4.0D+00*(2.0D+00*LRN(IRN+2)-1.0D+00)-AVEXYZ(INF,3)
          DA=1.57D+00*(2.0D+00*LRN(IRN+3)-1.0D+00)
          DB=1.57D+00*(2.0D+00*LRN(IRN+4)-1.0D+00)
          DG=1.57D+00*(2.0D+00*LRN(IRN+5)-1.0D+00)
          CALL FMOMOV(DX,DY,DZ,DA,DB,DG,INF,AVEXYZ)
          IRN=IRN+6
        END DO
        WRITE(IW,*)'before PXALRT ALERT=',ALERT
        CALL FLSHBF(IW)
        CALL PXALRT(ALERT,0)
        WRITE(IW,*)'after PXALRT ALERT=',ALERT
        CALL FLSHBF(IW)
      IF (ALERT) GOTO 30

C     TELL LOG FILE WHAT THE COORDINATES ARE
      WRITE(IW,*)' '
      WRITE(IW,*) 'RANDOMIZED FMO CLUSTER COORDINATES ARE:'
      DO I=1,NAT
        WRITE(IW,9010) FMOID(I),C(1,I),C(2,I),C(3,I)
      END DO
 9010 FORMAT(1X,F5.5,F10.5,F10.5,F10.5)
      END SUBROUTINE
C*MODULE GLOBOP  *DECK MC_EFP_BLOCK
C> @brief moves EFP group and calls energy calculation
C>
C> @details Each pass through does a translation and a rotation
C>
C> @author Caleb Carlin
C>
      subroutine MC_EFP_BLOCK(LDC,LDMC,LDA,LDMA,NFRMOV,
     *            PROVEC,CTVEC,LRN,IRN,IFRMOV,NTRAN,IFXFRG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      PARAMETER (MXAO=8192,MXFRG=1050, MXDFG=5, MXFGPT=12000,
     *           MXDPPT=63000,ZERO=0.0D+00, ONE=1.0D+00, TWO=2.0D+00,
     *           MXPT=2000,MXSHEF=1000,MXGEFP=4000)
C     
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NATEF(MXDFG),NUMEF(MXDFG),NTPATM
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /EFPCT / NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CTFOK(MXAO,MXDFG),NCTMO(MXDFG)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG)
      COMMON /FRGLJP/ CORDLJ(3,MXPT),ELJCRD(3,MXFGPT),
     *                POTLJ(2,MXPT),ELJPOT(2,MXFGPT),
     *                LJNAME(MXPT),ELJNAM(MXFGPT),
     *                NLJPTS(MXFRG),NLJTTPT,ILJP,NMLJ(2)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),JNLPR(4*MXPT),
     *                JKFR(MXPT),JKLR(MXPT),NDPTS(MXFRG),NDTTPT

      DOUBLE PRECISION LDC,LDA,LRN,EFC,LDMA,LDMC
      DIMENSION LDC(*),LDA(*),IFRMOV(*),LRN(*),IFXFRG(*)
      LOGICAL GOPARR,DSKWRK,MASWRK
      INTEGER MOVED
      CHARACTER*8 LJNAME,ELJNAM,FRGNME
C     routine to handle the movement of the EFP groups during the
C     loop over temperature
C
C              LOOP OVER TRANSLATIONAL HOPS
C
         IFRAG=0
         DO 178 ITRAN=1,NTRAN

            II=0
            DO INF=1,NFRG
               IFRMOV(INF)=0
            ENDDO
C
            DO WHILE (II < NFRMOV)
              IF(IFRAG.EQ.NFRG) IFRAG=0
              IFRAG=IFRAG+1
              IF(IFXFRG(IFRAG).GT.0) THEN
                CYCLE
              ELSE
                IFRMOV(IFRAG)=1
                II=II+1
              END IF
            END DO
C
C   DETERMINE NEW TEST COORDINATES
C   EACH MOVE HAS A TRANSLATION AND A ROTATION
C
            IDC=0
            IDA=0
            DO 110 INF=1,NFRG
               IF(IFXFRG(INF).EQ.0.AND.IFRMOV(INF).EQ.1) THEN
                  LDC(IDC  ) = LDMC*(TWO*LRN(IRN  )-ONE)
                  LDC(IDC+1) = LDMC*(TWO*LRN(IRN+1)-ONE)
                  LDC(IDC+2) = LDMC*(TWO*LRN(IRN+2)-ONE)
                  LDA(IDA  ) = LDMA*(3.1415D+00*LRN(IRN  )-1.57D+00)
                  LDA(IDA+1) = LDMA*(3.1415D+00*LRN(IRN+1)-1.57D+00)
                  LDA(IDA+2) = LDMA*(3.1415D+00*LRN(IRN+2)-1.57D+00)
                  IRN=IRN+6
               ELSE
                  LDC(IDC  ) = ZERO
                  LDC(IDC+1) = ZERO
                  LDC(IDC+2) = ZERO
                  LDA(IDA  ) = ZERO
                  LDA(IDA+1) = ZERO
                  LDA(IDA+2) = ZERO
               END IF
               IDC=IDC+3
               IDA=IDA+3
  110       CONTINUE
C
C           To be used when ab initio movement is put back in
C            IF(AIMOVE.GT.0.0D+00) THEN
C               DO I=1,3*NAT
C                  ARAN(I)=LRN(IRN+I)
C               ENDDO
C               IRN=IRN+3*NAT+1
C            ELSE
               IRN=IRN+1
C            END IF
C
C    EVALUATE ENERGY AT NEW GEOMETRY
C
C           IF(MASWRK.AND.NPRTGO.NE.2) WRITE(IW,*)
C     *           'EVALUATE ENERGY AT NEW GEOMETRY'
C
            NMST=0
            NPST=0
            NLJST=0
            NDPST=0
            NRST=0
            NDST=0
            NATST=0
            NORST=0
            NCTMOST=0
            IFRC=1
            DAVE=ZERO
C
C           MOVE FRAGMENT LOCATIONS
C
            IDC=0
            IDA=0
            DO 400 INF=1,NFRG
              IF(IFRMOV(INF).NE.0) THEN
C
C  CHECK IF STEP WILL BE OUT OF BOUNDS.  IF SO,
C  USE PERIODIC BOUNDARY. removed to elsewhere
C
                CALL MC_PBC(EFC(1,INF),EFC(2,INF),EFC(3,INF),LDC(IDC),
     *           LDC(IDC+1),LDC(IDC+2),MOVED)
C
                DAVE=DAVE+ABS(LDC(IDC  ))+ABS(LDC(IDC+1))
     *                  +ABS(LDC(IDC+2))+ABS(LDA(IDA  ))
     *                  +ABS(LDA(IDA+1))+ABS(LDA(IDA+2))
C
C                 THIS MOVES THE FRAGMENT IN QUESTION.
C
                CALL EFDSPL(INF,
     *               LDC(IDC),LDC(IDC+1),LDC(IDC+2),
     *               LDA(IDA),LDA(IDA+1),LDA(IDA+2),
     *               NMST,NPST,NLJST,NDPST,NRST,NDST,NATST,NORST,
     *               PROVEC,NCTMOST,CTVEC,MXBF)
                IDC=IDC+3
                IDA=IDA+3
              ELSE
                IDC=IDC+3
                IDA=IDA+3
              END IF
              NMST  = NMST  + NMPTS(INF)
              NPST  = NPST  + NPPTS(INF)
              NLJST = NLJST + NLJPTS(INF)
              NDPST = NDPST + NDPPTS(INF)
              NRST  = NRST  + NRPTS(INF)
              NDST  = NDST  + NDPTS(INF)
              NATST = NATST + NATEF(ISET(INF))
              NORST = NORST + NORB(INF)
              NCTMOST = NCTMOST + NCTMO(ISET(INF))
              IFRC=IFRC+3
  400       CONTINUE
C
            IF (NFRG.GT.0.AND.NTMO.GT.0)
     *        CALL DAWRIT(IDAF,IODA,PROVEC,LENPV,267,0)
            IF (NFRG.GT.0.AND.NTAO.GT.0)
     *        CALL DAWRIT(IDAF,IODA,CTVEC,LENCV,269,0)
C
            DAVE = DAVE/(6*NFRG)

  178    END DO
C
C
C      REMOVED LOOP OVER ROTATIONS AS THOSE ARE NOW INCLUDED ABOVE
      RETURN
C
C               -180- IS THE END OF THE LOOP OVER BLOCKS
C
      end subroutine MC_EFP_BLOCK
C*MODULE GLOBOP  *DECK FMOMOV
C> @brief moves a specified FMO group
C> 
C> @details moves all atoms in the group so that the center is at
C>          the origin and then applies the rotation before
C>          returning to original location plus the translation
C>
C> @param DX translation along X axis
C> @param DY translation along Y axis
C> @param DZ translation along Z axis
C> @param DA rotation by alpha degrees
C> @param DB rotation by beta degrees
C> @param DG rotation by gamma degrees
C> @param IFRG Fragmment number of fragment to be moved
C> @param AVEXYZ array of average x,y,z of fragment coordinates
C>
C> @author Caleb Carlin
C>
      SUBROUTINE FMOMOV(DX,DY,DZ,DA,DB,DG,IFRG,AVEXYZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     MOVES A SINGLE FMO FRAGMENT IN C
C
      PARAMETER (MXATM=2000)
      COMMON /FMOAPI/ FMOID(MXATM),FMOAPI_COORD,LAP,LKEEPER
      COMMON /GLOFMO/ MCMIN
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      DIMENSION AVEXYZ(1050,3)
      LOGICAL MCMIN
C
C
C------POSSIBLY A FASTER WAY TO DO THIS, BUT IT SHOULD WORK FOR NOW

      DO III=1,NAT
        IF(FMOID(III).EQ.IFRG) THEN
C     MOVE FRAGMENT TO ORIGIN
          XOLD=C(1,III)-AVEXYZ(IFRG,1)
          YOLD=C(2,III)-AVEXYZ(IFRG,2)
          ZOLD=C(3,III)-AVEXYZ(IFRG,3)
C     APPLY ROTATION USING A ROTATION MATRIX
          C(1,III)=XOLD*COS(DB)*COS(DG)-YOLD*(COS(DA)*SIN(DG)-
     *     SIN(DA)*SIN(DB)*COS(DG))+ZOLD*(SIN(DA)*SIN(DG)
     *     +COS(DA)*SIN(DB)*COS(DG))
          C(2,III)=XOLD*COS(DB)*SIN(DG)+YOLD*(COS(DA)*COS(DG)+
     *     SIN(DA)*SIN(DB)*SIN(DG))-ZOLD*(SIN(DA)*COS(DG)-
     *     COS(DA)*SIN(DB)*SIN(DG))
          C(3,III)=YOLD*SIN(DA)*COS(DB)-XOLD*SIN(DB)+
     *     ZOLD*COS(DA)*COS(DB)
C     MOVE BACK TO ORIGINAL SPOT AND DISPLACE
          C(1,III)=C(1,III)+AVEXYZ(IFRG,1)+DX
          C(2,III)=C(2,III)+AVEXYZ(IFRG,2)+DY
          C(3,III)=C(3,III)+AVEXYZ(IFRG,3)+DZ
          CALL FLSHBF(IW)
        END IF
      END DO
      RETURN

      END SUBROUTINE
C*MODULE GLOBOP  *DECK MC_FMO_BLOCK
C> @brief driver for FMO MC step
C>
C> @details Sets up the translation and rotation of NFMORV number
C>          of FMO groups.  Also calls energy calculation.
C>
C> @param LRN array of random numbers
C> @param IRN current position in LRN
C> @param NFMORV controls number of fragments moved
C> @param LDMA likely obsolete scaling factor for step size
C> @param LDMC likely obsolete scaling factor for step size
C>
C> @author Caleb Carlin
C>
      subroutine MC_FMO_BLOCK(LRN,IRN,NFMORV,
     *            LDMA,LDMC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      PARAMETER (MXATM=2000)
      COMMON /FMOAPI/ FMOID(MXATM),FMOAPI_COORD,LAP,LKEEPER
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /GLOFMO/ MCMIN
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      DIMENSION AVEXYZ(1050,3),LRN(*)
      DOUBLE PRECISION LRN,LDMC,LDMA
C     routine to setup the moving of fmo groups during the
C     loop over temperature
C
      INTEGER MOVED
      LOGICAL GOPARR,DSKWRK,MASWRK,MCMIN

      DO 180 IGM=1,NFMORV
C
C     Pick a fragment to move
C
      NFGMOVE=INT(NFG*LRN(IRN)+1)
      AVEXYZ(NFGMOVE,1)=0.0D+00
      AVEXYZ(NFGMOVE,2)=0.0D+00
      AVEXYZ(NFGMOVE,3)=0.0D+00
      DENOM=0
      DO III=1,NAT
      IF(FMOID(III).EQ.NFGMOVE) THEN
          AVEXYZ(NFGMOVE,1)=AVEXYZ(NFGMOVE,1)+C(1,III)
          AVEXYZ(NFGMOVE,2)=AVEXYZ(NFGMOVE,2)+C(2,III)
          AVEXYZ(NFGMOVE,3)=AVEXYZ(NFGMOVE,3)+C(3,III)
          DENOM=DENOM+1
      END IF
      END DO
      AVEXYZ(NFGMOVE,1)=AVEXYZ(NFGMOVE,1)/DENOM
      AVEXYZ(NFGMOVE,2)=AVEXYZ(NFGMOVE,2)/DENOM
      AVEXYZ(NFGMOVE,3)=AVEXYZ(NFGMOVE,3)/DENOM
C      CALL FLSHBF(IW)
!      IF(MASWRK)THEN
!         CALL RNGEN(XX(LRN),IMXRAN,IRTP,INIT)
!         CALL DDI_BCAST(2600,'F',LRN,IMXRAN,MASTER)
!      ELSE
!         CALL DDI_BCAST(2600,'F',LRN,IMXRAN,MASTER)
!      END IF
      IRN=1
C-----Set up the displacement variables
      DX=LDMC*(2.0D+00*LRN(IRN)-1.0D+00)
      DY=LDMC*(2.0D+00*LRN(IRN+1)-1.0D+00)
      DZ=LDMC*(2.0D+00*LRN(IRN+2)-1.0D+00)
      DA=LDMA*(3.1415D+00*LRN(IRN+3)-1.57D+00)
      DB=LDMA*(3.1415D+00*LRN(IRN+4)-1.57D+00)
      DC=LDMA*(3.1415D+00*LRN(IRN+5)-1.57D+00)
      IRN=IRN+6
C     Take a moment here to test the move for PBC.
C     If any of the atoms would be out of bounds, we take that atom's
C     Corrected displacement and apply it to the entire fragment
C     This isn't perfect, but should keep the fragments from going too
C     Far out of the box
      DO III=1,NAT
         IF (FMOID(III).EQ.NFGMOVE) THEN
             CALL MC_PBC(C(1,III),C(2,III),C(3,III),DX,DY,DZ,MOVED)
             IF (MOVED == 1) EXIT
         END IF
      END DO
      CALL FMOMOV(DX,DY,DZ,DA,DB,DC,NFGMOVE,AVEXYZ)
C   perform secondary mc here eventually, for now call energy
C   EACH MOVE HAS A TRANSLATION AND A ROTATION

C
C
C
 180  END DO
C
C
      end subroutine MC_FMO_BLOCK
C*MODULE GLOBOP  *DECK MC_PBC
C> @brief periodic boundary conditions check
C>
C> @details checks to see if any translations would move an atom
C>          outside the boundaries, and changes the translation to
C>          be within boundaries.
C>
C> @param X x-coordinate of atom
C> @param Y y-coordinate of atom
C> @param Z z-coordinate of atom
C> @param DX change in x-coordinate
C> @param DY change in y-coordinate
C> @param DZ change in z-coordinate
C> @param moved returns whether any displacements were changed
C>
C> @author Caleb Carlin
C>
      subroutine MC_PBC(X,Y,Z,DX,DY,DZ,MOVED)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

          COMMON /SIMEN / EPREV,EMIN,ALPHA,DAVE,XMIN,XMAX,YMIN,YMAX
     *               ,ZMIN,ZMAX,XRANGE,YRANGE,ZRANGE,SEPTOL
     *               ,DACRAT,UPDFAC
      DOUBLE PRECISION X,Y,Z,DX,DY,DZ
      INTEGER IOOB
      IOOB=1
      MOVED=0
C     Moved keeps track of if any of the displacements have changed
C      DO WHILE (IOOB=0)
   30 IF(IOOB .EQ. 1) THEN
         IOOB=0
C
               XTEMP=X+DX
               YTEMP=Y+DY
               ZTEMP=Z+DZ
C
               IF(XTEMP.GT.XMAX) THEN
                  DX=DX - XRANGE
                  IOOB=1
                  MOVED=1
               ELSE IF(XTEMP.LT.XMIN) THEN
                  DX=DX + XRANGE
                  IOOB=1
                  MOVED=1
               END IF
               IF(YTEMP.GT.YMAX) THEN
                  DY=DY - YRANGE
                  IOOB=1
                  MOVED=1
               ELSE IF(YTEMP.LT.YMIN) THEN
                  DY=DY + YRANGE
                  IOOB=1
                  MOVED=1
               END IF
               IF(ZTEMP.GT.ZMAX) THEN
                  DZ=DZ - ZRANGE
                  IOOB=1
                  MOVED=1
               ELSE IF(ZTEMP.LT.ZMIN) THEN
                  DZ=DZ + ZRANGE
                  IOOB=1
                  MOVED=1
               END IF
          GOTO 30
      END IF
C      END DO
      RETURN
      end subroutine MC_PBC
C*MODULE GLOBOP  *DECK MC_ENERGY
C> @brief energy driver for Monte Carlo
C>
C> @details If called on the zeroeth step, calls an energy calculation
C>          and automatically saves the coordinates and energy.
C>          Every other time, it calls an energy calculation and then
C>          compares the energy to see if it should be kept or rejected.
C>          If MCMIN is true, can be used to optimize the configuration
C>          every NSTMIN steps.
C>          Energy calls are made to ENERGX,SIGX, or FMOX depending on
C>          which tyes of atoms are present (ie MCTYP)
C>
C> @param IGLO tracks which overall step in the MC search
C> @param CMIN array that stores coordinates of minimum energy
C> @param PROVEC stores information of minimum energy configuration
C> @param CTVEC stores information of minimum energy configuration
C> @param ACCEPT intent out: whether the configuration is accepted or not
C> @param XRAN array of random numbers (elsewhere called LRN)
C> @param BETA Boltzemann constant times temperature
C> @param NSTMIN number of steps between optimizing geometry
C> @param MCTYP bitwise variable for which atoms are present
C>              (ie EFP and/or FMO)
C>
C> @author Caleb Carlin
C>
      subroutine MC_ENERGY(IGLO,CMIN,PROVEC,CTVEC,ACCEPT,XRAN,
     *           BETA,NSTMIN,MCTYP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000,MXFRG=1050,MXDPPT=63000,ZERO=0.0D+00,
     *           MXAO=8192,MXDFG=5,MXFGPT=12000)
      COMMON /EFPCMO/ NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CANFOK(MXAO,MXDFG)
      COMMON /EFPFMO/ RUNEFP,REFFMO,REPNUCEFP,IEFPFMO,ISWENUC,EFPEFP
      COMMON /FMOAPI/ FMOID(MXATM),FMOAPI_COORD,LAP,LKEEPER
      COMMON /FUNCT / E,EG(3*MXATM)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG)
      COMMON /GLOFMO/ MCMIN
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IKREP,IEF,IP_F,NFMOPCM
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SIMDAT/ NACC,NREJ,IGOMIN,NRPA,IBWM,NACCT,NREJT,NRPAT,
     *                NPRTGO,IDPUNC,IGOFLG
      COMMON /SIMEN / EPREV,EMIN,ALPHA,DAVE,XMIN,XMAX,YMIN,YMAX
     *               ,ZMIN,ZMAX,XRANGE,YRANGE,ZRANGE,SEPTOL
     *               ,DACRAT,UPDFAC
      COMMON /ZMTALT/ NZMAT2,NZVAR2,NVAR2,NZMTRD,ICOORD

      DATA OPT/8HOPTIMIZE/,ENERGY/8HENERGY  /
      DIMENSION CMIN(*),PROVEC(*),CTVEC(*),XRAN(*)
      DOUBLE PRECISION CMIN,PROVEC,CTVEC
      LOGICAL GOPARR,DSKWRK,ACCEPT,MASWRK,MCMIN

C      CALL FLSHBF(IW)
C      WRITE(IW,*)'Inside MC_ENERGY/E=  IGLO=',E,IGLO
C      CALL FLSHBF(IW)
      IF (IGLO.EQ.0) THEN
        E=ZERO
        IF (iand(MCTYP,2).NE.0) THEN
          TRUNTP=RUNTYP
          RUNTYP=ENERGY
          CALL FMOX(0)
          RUNTYP=TRUNTP
        ELSE
C          CALL FLSHBF(IW)
          CALL ENERGX
        ENDIF
C
C        WRITE(IW,*)'E is now=',E
C        CALL FLSHBF(IW)
        IF(IEFPFMO.EQ.0.AND.ICOORD.NE.4) CALL FFSVMO(0,WRK)
C
C           SAVE, INITIALIZING THE "BEST POINT SO FAR" INFORMATION
C
        EPREV=E
        EMIN=E
        IF (NFRG.GT.0.AND.NTMO.GT.0) THEN
           CALL DAREAD(IDAF,IODA,PROVEC,LENPV,267,0)
        END IF
        IF (NFRG.GT.0.AND.NTAO.GT.0) THEN
           CALL DAREAD(IDAF,IODA,CTVEC,LENCV,269,0)
        END IF
        CALL STCOR(CMIN,PROVEC,CTVEC,MXBF)
C
        IGOMIN = IGLO
C
      ELSE
C
C-----IF-IGLO.GT.0
        E=ZERO
C---FOR THE EFP+PCM PART
C        IF(IP_F.EQ.1) CALL MAKCVM
C---    IF(MASWRK) WRITE(IW,*)'IP_F-VALUE',IP_F,IPCM,IEFP
        WRITE(IW,*)'NSTMIN in MCENERGY=',NSTMIN
        IF(MCMIN.AND.(NSTMIN.EQ.1.OR.(MOD(IGLO,NSTMIN).EQ.0)))
     *    THEN
           TRUNTP=RUNTYP
           RUNTYP=OPT
           CALL SIGX(.FALSE.)
           RUNTYP=TRUNTP
           IF(IDPUNC.EQ.1) RETURN
        ELSE
C------PRADIPTA
C           IF((ICOORD.EQ.4).OR.(IP_F.EQ.1).OR.(NSTMIN.EQ.1)) THEN
             IF (iand(MCTYP,2).NE.0) THEN
               TRUNTP=RUNTYP
               RUNTYP=ENERGY
               CALL FLSHBF(IW)
               CALL FMOX(0)
               RUNTYP=TRUNTP
             ELSE
C               WRITE(IW,*)'CALLING ENRGX in MC_ENERGY'
C               CALL FLSHBF(IW)
               CALL ENERGX
             ENDIF
C           END IF
        END IF
C
         WRITE(6,*)'EPREV and E',EPREV,E
         IF(MASWRK.AND.NPRTGO.NE.2) WRITE(IW,*)'EPREV,E',EPREV,E
C---------actual Monte Carlo filter part.
         IF(E.LT.EPREV) THEN
          ACCEPT=.TRUE.
          EPREV=E
         ELSE
          APROP = EXP(-(E-EPREV)*BETA)
          IF(MASWRK.AND.NPRTGO.NE.2) WRITE(IW,*)'APROP,XRAN',
     *              APROP,XRAN(IGLO)
          IF(APROP.LT.XRAN(IGLO)) THEN
            WRITE(IW,*)'APROP is less than XRAN'
            CALL FLSHBF(IW)
            ACCEPT=.FALSE.
          ELSE
            WRITE(IW,*)'APROP is greater than XRAN'
            ACCEPT=.TRUE.
            EPREV=E
          END IF
         END IF
C
C     pass value of accept back to globop
C      IGLO=IGLO+1
      END IF
      WRITE(IW,*)'ACCEPT at end of MC_ENERGY is',ACCEPT
      RETURN
      end subroutine MC_ENERGY
C*MODULE GLOBOP  *DECK EFPRAND
C> @brief randomize initial EFP configuration
C>
C> @details Move EFP groups to origin, rotate randomly, and then
C>          translate randomly.  Performs a proximity test at the end
C>          and can perform an optimization on the geometry
C>
C> @param MASWRK logical true if on master node
C> @param MCMIN flag for optimizing geometry during MC run
C> @param LRN array of random numbers
C> @param IMXRAN size of LRN
C> @param PROVEC array holds information about minimum energy coord.
C> @param CTVEC array holds information about minimum energy coord.
C> @param IRN current position in LRN
C>
C> @author Caleb Carlin
C> 
      Subroutine EFPrand(MASWRK,MCMIN,LRN,
     *    PROVEC,CTVEC,IRN)

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL MASWRK,ALERT,MCMIN
      DIMENSION AVEXYZ(1050,3),LRN(*),CTVEC(*),PROVEC(*)
      DOUBLE PRECISION LRN

C
      PARAMETER (MXATM=2000,MXAO=8192,ONE=1.0D+00,TWO=2.0D+00,
     *           MXPT=2000, MXFRG=1050, MXDFG=5, MXFGPT=12000,
     *           MXDPPT=63000,ZERO=0.0D+00,MXSHEF=1000,MXGEFP=4000)
      DATA OPT /8HOPTIMIZE/
C
      CHARACTER*8 FRGNME
C
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NATEF(MXDFG),NUMEF(MXDFG),NTPATM
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /EFPCT / NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CTFOK(MXAO,MXDFG),NCTMO(MXDFG)
      COMMON /FRGLJP/ CORDLJ(3,MXPT),ELJCRD(3,MXFGPT),
     *                POTLJ(2,MXPT),ELJPOT(2,MXFGPT),
     *                LJNAME(MXPT),ELJNAM(MXFGPT),
     *                NLJPTS(MXFRG),NLJTTPT,ILJP,NMLJ(2)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG)
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /FUNCT / E,EG(3*MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),JNLPR(4*MXPT),
     *                JKFR(MXPT),JKLR(MXPT),NDPTS(MXFRG),NDTTPT
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SIMDAT/ NACC,NREJ,IGOMIN,NRPA,IBWM,NACCT,NREJT,NRPAT,
     *                NPRTGO,IDPUNC,IGOFLG
      COMMON /SIMEN / EPREV,EMIN,ALPHA,DAVE,XMIN,XMAX,YMIN,YMAX
     *               ,ZMIN,ZMAX,XRANGE,YRANGE,ZRANGE,SEPTOL
     *               ,DACRAT,UPDFAC
      COMMON /ZMTALT/ NZMAT2,NZVAR2,NVAR2,NZMTRD,ICOORD
      CHARACTER*8 LJNAME,ELJNAM
      
         IF(MASWRK) THEN
            WRITE(6,*) ' '
            WRITE(6,*) 'RANDOMIZED CLUSTER CONSTRUCTION BEGINNING...'
         END IF
C
C SPREAD MOLECULES FAR APART IN ORDER TO PREVENT PROXIMITY ALERTS
C
  441    CONTINUE

C
C CALCULATE AVERAGE X,Y,Z COORDINATES OF EACH FRAGMENT IN
C ORDER TO CENTER ALL MOLECULES AT (0,0,0) BEFORE RANDOMIZING
C
         IAT=0
         DO 1929 IFRG=1,NFRG
            AVEXYZ(IFRG,1)=ZERO
            AVEXYZ(IFRG,2)=ZERO
            AVEXYZ(IFRG,3)=ZERO
            DO 1919 III=1,NMPTS(IFRG)
               IAT=IAT+1
               AVEXYZ(IFRG,1)=AVEXYZ(IFRG,1)+EFC(1,IAT)
               AVEXYZ(IFRG,2)=AVEXYZ(IFRG,2)+EFC(2,IAT)
               AVEXYZ(IFRG,3)=AVEXYZ(IFRG,3)+EFC(3,IAT)
 1919       CONTINUE
            DENOM=NMPTS(IFRG)
            AVEXYZ(IFRG,1)=AVEXYZ(IFRG,1)/DENOM
            AVEXYZ(IFRG,2)=AVEXYZ(IFRG,2)/DENOM
            AVEXYZ(IFRG,3)=AVEXYZ(IFRG,3)/DENOM
 1929    CONTINUE
C
         NMST=0
         NPST=0
         NLJST=0
         NDPST=0
         NRST=0
         NDST=0
         NATST=0
         NORST=0
         NCTMOST=0
         DO 867 INF=1,NFRG
            DX = 3.0D+02*(TWO*LRN(IRN  )-ONE)-AVEXYZ(INF,1)
            DY = 3.0D+02*(TWO*LRN(IRN+1)-ONE)-AVEXYZ(INF,2)
            DZ = 3.0D+02*(TWO*LRN(IRN+2)-ONE)-AVEXYZ(INF,3)
            IRN=IRN+3
            CALL EFDSPL(INF,DX,DY,DZ,ZERO,ZERO,ZERO,
     *                  NMST,NPST,NLJST,NDPST,NRST,NDST,NATST,NORST,
     *                  PROVEC,NCTMOST,CTVEC,MXBF)
            NMST  = NMST  + NMPTS(INF)
            NPST  = NPST  + NPPTS(INF)
            NLJST = NLJST + NLJPTS(INF)
            NDPST = NDPST + NDPPTS(INF)
            NRST  = NRST  + NRPTS(INF)
            NDST  = NDST  + NDPTS(INF)
            NATST = NATST + NATEF(ISET(INF))
            NORST = NORST + NORB(INF)
            NCTMOST = NCTMOST + NCTMO(ISET(INF))
  867    CONTINUE
         CALL PXALRT(ALERT,1)
         IF(ALERT) GO TO 441
C
C Additional code for moving individual groups removed from here
C         
         IF (NFRG.GT.0.AND.NTMO.GT.0)
     *       CALL DAWRIT(IDAF,IODA,PROVEC,LENPV,267,0)
         IF (NFRG.GT.0.AND.NTAO.GT.0)
     *       CALL DAWRIT(IDAF,IODA,CTVEC,LENCV,269,0)
C
C TELL LOG FILE WHERE THE NEW COORIDINATES ARE
C
         IF(MASWRK) THEN
            WRITE(IW,*) 'THE RANDOM INITIAL CLUSTER GEOMETRY IS'
            CALL PRATM(IW,1)
         END IF
C
C OPTIONAL OPTIMIZATION OF THE INITIAL RANDOM STRUCTURE
C
         IF(MCMIN) THEN
            IF(MASWRK) WRITE(IW,*)
     *        'RANDOM INITIAL CLUSTER WILL NOW BE GEOMETRY OPTIMIZED...'
            TRUNTP=RUNTYP
            RUNTYP=OPT
            CALL SIGX(.FALSE.)
            RUNTYP=TRUNTP
         ELSE
            IF(MASWRK) WRITE(IW,*)
     *        'COMPUTING THE ENERGY OF THE RANDOMIZED CLUSTER...'
            NPRTGO=1   ! BUT, NOTE ENERGX TURNS NPRTGO BACK TO 2=SILENT
            CALL ENERGX
            IF(MASWRK) WRITE(IW,9015) E
         END IF
C
        RETURN
9015  FORMAT(1X,'INITIAL RANDOM CLUSTER''S ENERGY=',F20.10)
      END SUBROUTINE EFPRAND
