C 20 Feb 13 - MWS - synchronize SCFWFN common
C 19 Oct 12 - MWS - synchronize FRGINF common
C  2 Sep 12 - NM  - allow SF-TDDFT with EFP1 and/or C-PCM gradients
C  9 APR 12 - FZ  - PAD THE INFOTD COMMON FOR TPA
C 11 AUG 11 - NM  - NEW MODULE IMPLEMENTING SPIN-FLIP TD-DFT
C
C*MODULE SFDFT   *DECK SFDFTCALC
      SUBROUTINE SFDFTCALC
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,TRIPLET,SG1,SG1T,TAMMD,TPA
      LOGICAL SOME,GOPSAV
      LOGICAL LCFLAG,LRINT
      logical efstatic,mtd1,mtd2
C
      PARAMETER (MXRT=100)
      PARAMETER (MXGRID=10)
      parameter (mxatm=2000, mxfrg=1050, mxdfg=5, mxdppt=mxfrg*mxdfg*12)
C
      COMMON /DFGRID/ DFTTHR,DFTGTHR,SWOFF,SW0,BSLRD(137),NDFTFG,
     *                NRAD,NTHE,NPHI,NRAD0,NTHE0,NPHI0,
     *                NANGPT(MXGRID),NANGPT0(MXGRID),SG1,JANS
      COMMON /DFLEB/  NLEB(MXGRID),NLEB0(MXGRID)
C     COMMON /DFTPAR/ DFTTYP(20),EXENA,EXENB,EXENC,IDFT34,NAUXFUN,
C    *                                                    NAUXSHL
      common /efnrgy/ enucrp,repnuc0,enel,efrms,qefea0(5),qefeap(5),
     *                mtd1,mtd2,efstatic
      common /efptdg/ itdefg
      common /fmcom / x(1)
      common /frginf/ nmpts(mxfrg),nmttpt,iefc,iefd,iefq,iefo,
     *                nppts(mxfrg),npttpt,iefp,
     *                nrpts(mxfrg),nrttpt,irep,ichgp,nfrg,
     *                ndppts(mxdppt),ndpttpt,iefdp,lstmpts(mxfrg),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      common /infoa / nat,ich,mul,num,nqmt,ne,na,nb,
     *                zan(mxatm),c(3,mxatm),ian(mxatm)
      COMMON /INFOEX/ TDM(3,MXRT),MOCC(MXRT),MVIR(MXRT),
     *                MONOC1,MONVR1,IFMODIM
      COMMON /INFOTD/ CNVTOL,TRIPLET,SG1T,JANST,NRADT,NTHET,NPHIT,NLEBT,
     *                NSTAT,NTRIAL,MAXVEC,NTHST,IRECTD,
     *                ITDFG,NONEQR,ITDPRP,TAMMD,TPA
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NLRC  / LCFLAG,LRINT,EMU,EMU2,LRFILE
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      common /pcmpar/ ipcm,nft26,nft27,irppcm,ief,ip_f,nfmopcm
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DATA SFDFT,ROHF/8HSFDFT   ,8HROHF    /
      DATA CHECK/8HCHECK   /
      DATA MXITER/100/
C
      SOME = MASWRK .AND. NPRINT.NE.-5
C
C     ----- EXTRACT SOME INPUT PARAMETERS FROM $TDDFT -----
C
      IF(SOME) THEN
        WRITE(IW,9000) NSTAT,NTHST,MAXVEC,NTRIAL,CNVTOL
        WRITE(IW,9010)
      END IF
C
      IF(LCFLAG) THEN
        IF(MASWRK) WRITE(IW,*) ' ERROR: LC OPTION IS NOT SUPPORTED.'
        CALL ABRT
      END IF
C****                           ****************************************
C**** SF-DFT ENERGY CALCULATION ****************************************
C****                           ****************************************
      CALL VCLR(TDM,1,3*MXRT)
      CALL SPNFLPCL(SFDFT,CNVTOL,MOCC,MVIR,NSTAT,
     *              NTRIAL,MAXVEC,NTHST,MXITER,NCONV)
C
C        IF NO EXCITED STATE DENSITY WILL BE GENERATED, JUST QUIT.
C
      CALL DERCHK(NDER)
c     IF(NDER.EQ.0  .AND.  ITDPRP.EQ.0) RETURN
      if((nder.gt.0 .and. nglevl.eq.0).or. itdprp.eq.1) then
         continue
      else
         return
      end if
C
C****                             **************************************
C**** SF-DFT GRADIENT CALCULATION **************************************
C****                             **************************************
      IF(EXETYP.EQ.CHECK) NCONV = 0
      IF(NCONV.NE.0) THEN
         IF(MASWRK)  WRITE(IW,*)
     *      ' NO GRADIENT. SF-DFT ENERGY CALCULATION IS NOT CONVERGED.'
         CALL ABRT
      END IF
c
c     initialize sf-dft/efp1 gradient
c
      if(itdefg.ne.0) call tdefpinit 
C
C     PARALLEL VERSION OF THE GRADIENT CALCULATION ONLY WORKS FOR
C     DYANAMIC LOAD BALANCING
C
      GOPSAV = GOPARR
      NPROCS = NPROC
C
      IF(SOME) WRITE(IW,9100)
C
      IF(NTHST.GT.MXRT) THEN
         IF(MASWRK) WRITE(IW,*) 'SFDFT-GRADIENT CALCULATION IS ALLOWED',
     *                          'ONLY FOR IROOT.LE.',MXRT
         CALL ABRT
      END IF
C
C     -- SWITCH TO THE SMALL GRID SIZE FOR TDDFT
C
      NRADS   = NRAD
      NTHES   = NTHE
      NPHIS   = NPHI
      NLEBS   = NLEB(1)
      NRAD    = NRADT
      NTHE    = NTHET
      NPHI    = NPHIT
      NLEB(1) = NLEBT
C
C     POINT GROUP SYMMETRY CANNOT BE USED DURING THE RESPONSES.
C     THE SELECTED STATE MAY NOT HAVE A SYMMETRIC DENSITY, SO
C     WE ALSO HAVE TO DO THE GRADIENT INTEGRAL TERMS (LATER)
C     W/O SYMMETRY.
C
      CALL SYMOFF
      IF(SCFTYP.EQ.ROHF) THEN
         CALL SFROGRAD(SFDFT,NTHST)
      ELSE
         CALL   SFGRAD(SFDFT,NTHST)
      END IF
      CALL SYMON
C
      IF(MASWRK) WRITE(IW,9500)
      CALL TIMIT(1)
C
C     ----- CALCULATE PROPERTY -----
C
      IF(NPRINT.NE.-5) CALL PROPTY('TDDF')
c
c     ----- sfdft-efp1 -----
c
c     solve efp induced dipoles due to transition state density and
c     excitation difference density
c
      if(itdefg.eq.2 .and. ipcm.eq.0 .and. .not.efstatic) then
         l1 = num
         l2 = (num*(num+1))/2
         call valfm(loadfm)
         lpm   = loadfm + 1
         ldum  = lpm    + l2
         lxefi = ldum   + l2
         lyefi = lxefi  + l2
         lzefi = lyefi  + l2
         lfld  = lzefi  + l2
         last  = lfld   + npttpt*3
         need  = last  - loadfm -1
         call getfm(need)
         call sfdftm(x(lpm),x(ldum),x(lxefi),x(lyefi),x(lzefi),
     *               x(lfld),l1,l2,npttpt)
         call retfm(need)
      end if
C
C     -- SWITCH BACK TO THE REGULAR GRID SIZE, E.G. FOR GRADIENT STEP
C
      NRAD = NRADS
      NTHE = NTHES
      NPHI = NPHIS
      NLEB(1) = NLEBS
C
      NPROC  = NPROCS
      GOPARR = GOPSAV
C
      RETURN
 9000 FORMAT(/10X,47(1H-)/10X,'SF-DFT INPUT PARAMETERS ',
     *            '(EXTRACTED FROM $TDDFT)'/10X,47(1H-)//
     *        5X,'NSTATE=',I8,'  IROOT=',I8,' MAXVEC=',I8/
     *        5X,'NTRIAL=',I8,' CNVTOL=',1P,E10.2)
 9010 FORMAT(/5X,'********** NOTE: THE CURRENT STATUS OF SFDFT',
     *           ' **********'//
     *        5X,'(1) UHF AND ROHF REFERENCES ARE AVAILABLE.'/
     *        5X,'(2) COLLINEAR APPROXIMATION FOR XC FUNCTIONALS.'/
     *        5X,'(3) NEITHER LC NOR CAMB3LYP IS SUPPORTED.'/
     *        5X,'(4) INCORRECT ANALYTIC GRADIENT FOR META-GGA.'/
     *        5X,'(5) SOLVENT MODELS (EFP1 AND/OR C-PCM) ARE',
     *           ' AVAILABLE.'/
     *       /5X,55(1H*)/)
 9100 FORMAT(/1X,71(1H-)/
     *  19X,'SF-DFT ENERGY GRADIENT CALCULATION'/
     *       1X,71(1H-)/)
 9500 FORMAT(1X,'..... DONE WITH SF-DFT EXCITED STATE RESPONSE',
     *          ' AND DENSITY MATRIX .....')
      END
C*MODULE SFDFT   *DECK SFCISCALC
      SUBROUTINE SFCISCALC
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXSH=5000, MXATM=2000, MXRT=100)
      parameter (mxfrg=1050, mxdfg=5, mxdppt=mxfrg*mxdfg*12)
C
      LOGICAL DIRSCF,FDIFF
      LOGICAL GOPARR,DSKWRK,MASWRK,GOPSAV
      LOGICAL MNMEDG,MNMEOP,UNVGSS,DGAPRX,RDCISV
      LOGICAL SOME
C
      COMMON /CISPAR/ HAMTYP,DIAGZN,DAVCVG,PRTTOL,NSTATE,ISTATE,MULT,
     *                MXV,NDAVIT,ICISPR,NACORE,NBCORE,NOA,NOB,NORBOC,
     *                NBF,NGSVEC,MNMEDG,MNMEOP,ICLOBBR,UNVGSS,DGAPRX,
     *                RDCISV
      COMMON /DFTPAR/ DFTTYP(20),EXENA,EXENB,EXENC,IDFT34,NAUXFUN,
     *                                                    NAUXSHL
      common /frginf/ nmpts(mxfrg),nmttpt,iefc,iefd,iefq,iefo,
     *                nppts(mxfrg),npttpt,iefp,
     *                nrpts(mxfrg),nrttpt,irep,ichgp,nfrg,
     *                ndppts(mxdppt),ndpttpt,iefdp,lstmpts(mxfrg),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
C     COMMON /IJPAIR/ IA(MXAO)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      common /pcmpar/ ipcm,nft26,nft27,irppcm,ief,ip_f,nfmopcm
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                T(432),INVT(48),NT
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DIMENSION MOCC(MXRT),MVIR(MXRT)
C
      DATA SFCIS,ROHF/8HSFCIS   ,8HROHF    /
      DATA CHECK/8HCHECK   /
C
      SOME = MASWRK .AND. NPRINT.NE.-5
C
C     ----- EXTRACT SOME INPUT PARAMETERS FROM $CIS -----
C
      IF(SOME) WRITE(IW,9000) NACORE,NSTATE,ISTATE,MXV,NGSVEC,
     *                        NDAVIT,DAVCVG
C
C     ----- SET HARTREE-FOCK EXCHANGE SCALING -----
C
      DFTTYP3   = DFTTYP(3)
      DFTTYP(3) = 1.0D+00
C
C     ----- RECOMPUTE INTEGRALS -----
C
      IF(NT.GT.1) THEN
         CALL SYMOFF
         IF(.NOT.DIRSCF) CALL JANDK
         CALL SYMON
      END IF
C****                           ****************************************
C**** SF-CIS ENERGY CALCULATION ****************************************
C****                           ****************************************
      IF(NACORE.NE.0) THEN
         IF(MASWRK) WRITE(IW,*) '*** NOTE: NACORE IS SET TO BE 0'
      END IF
C
      CALL SPNFLPCL(SFCIS,DAVCVG,MOCC,MVIR,NSTATE,
     *              NGSVEC,MXV,ISTATE,NDAVIT,NCONV)
C
C        IF NO EXCITED STATE DENSITY WILL BE GENERATED, JUST QUIT.
C
      CALL DERCHK(NDER)
c     IF(NDER.EQ.0  .AND.  ICISPR.EQ.0) GO TO 200
      if((nder.gt.0 .and. nglevl.eq.0) .or. icispr.eq.1) then
         continue
      else
         go to 200
      end if
C
C****                             **************************************
C**** SF-CIS GRADIENT CALCULATION **************************************
C****                             **************************************
      IF(EXETYP.EQ.CHECK) NCONV = 0
      IF(NCONV.NE.0) THEN
         IF(MASWRK) WRITE(IW,*)
     *       ' NO GRADIENT. SF-CIS ENERGY CALCULATION IS NOT CONVERGED.'
         CALL ABRT
      END IF
c
c     trap sf-cis/efp1 gradient
c
      if(nfrg.gt.0 .and. iefp.eq.1) then
         write(iw,*) ' SF-CIS IS INCOMPATIBLE WITH EFP.'
         write(iw,*) ' USE SF-TDDFT WITH DFTTYP=NONE AND TAMMD=.T.'
         call abrt
      end if 
c
c     trap sf-cis/PCM gradient here
c
      if(ipcm.eq.1) then
         write(iw,*) ' SF-CIS IS INCOMPATIBLE WITH PCM.'
         write(iw,*) ' USE SF-TDDFT WITH DFTTYP=NONE AND TAMMD=.T.'
         call abrt
      end if 
C
C     PARALLEL VERSION OF THE GRADIENT CALCULATION ONLY WORKS FOR
C     DYANAMIC LOAD BALANCING
C
      GOPSAV = GOPARR
      NPROCS = NPROC
C
      IF(SOME) WRITE(IW,9100)
C
      IF (ISTATE.GT.MXRT) THEN
         IF(MASWRK) WRITE(IW,*) 'SFCIS-GRADIENT CALCULATION IS ALLOWED',
     *                          'ONLY FOR IROOT.LE.',MXRT
        CALL ABRT
      END IF
C
C     POINT GROUP SYMMETRY CANNOT BE USED DURING THE RESPONSES.
C     THE SELECTED STATE MAY NOT HAVE A SYMMETRIC DENSITY, SO
C     WE ALSO HAVE TO DO THE GRADIENT INTEGRAL TERMS (LATER)
C     W/O SYMMETRY.
C
      CALL SYMOFF
      IF(SCFTYP.EQ.ROHF) THEN
         CALL SFROGRAD(SFCIS,ISTATE)
      ELSE
         CALL   SFGRAD(SFCIS,ISTATE)
      END IF
      CALL SYMON
C
      IF(MASWRK) WRITE(IW,9500)
      CALL TIMIT(1)
C
C     ----- CALCULATE PROPERTY -----
C
      IF(NPRINT.NE.-5) CALL PROPTY('CISR')
C
      NPROC  = NPROCS
      GOPARR = GOPSAV
C
  200 CONTINUE
      DFTTYP(3) = DFTTYP3
      RETURN
C
 9000 FORMAT(/10X,45(1H-)/10X,'SF-CIS INPUT PARAMETERS ',
     *            '(EXTRACTED FROM $CIS)'/10X,45(1H-)//
     *        1X,'NACORE=',I8,' NSTATE=',I8,'  IROOT=',I8/
     *        1X,' MXVEC=',I8,' NGSVEC=',I8,' NDAVIT=',I8,
     *        1X,'DAVCVG=',1P,E10.2)
 9100 FORMAT(/1X,71(1H-)/
     *  19X,'SF-CIS ENERGY GRADIENT CALCULATION'/
     *       1X,71(1H-)/)
 9500 FORMAT(1X,'..... DONE WITH SF-CIS EXCITED STATE RESPONSE',
     *          ' AND DENSITY MATRIX .....')
      END
C*MODULE SFDFT  *DECK SFSSQU
      SUBROUTINE SFSSQU(S2,DA,DB,DDA,DDB,V,S,D,T,IA,L1,L2,NA,NB)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION DA(L2),DB(L2),DDA(L2),DDB(L2),V(L1,L1),S(L2),
     *          D(L2),T(L1),IA(L1)
C
      PARAMETER (ZERO=0.0D+00, HALF=0.5D+00, ONE=1.0D+00)
C
C     DA /DB  ... ALPHA/BETA DENSITY OF THE EXCITED STATE
C     DDA/DDB ... ALPHA/BETA DIFFERENCE DENSITY MATRIX
C
C     ----- CALCULATE SPIN EXPECTATION VALUES -----
C
      SZ   = HALF*(NA - NB - 2) 
      DUM0 = SZ*(SZ + ONE)
C
      DUM1 = NB + 1
C
C  SYMMETRIC MATRIX D = S*DA*S
C
      IJ=0
      DO 280 J=1,L1
         DO 200 I=1,L1
            DUM = ZERO
            DO 180 K = 1,L1
               IK = IA(I)+K
               IF(K.GT.I) IK=IA(K)+I
               JK = IA(J)+K
               IF(K.GT.J) JK = IA(K)+J
               DUM = DUM+DA(IK)*S(JK)
  180       CONTINUE
            T(I) = DUM
  200    CONTINUE
         DO 270 I = 1,J
            DUM = ZERO
            DO 260 K = 1,L1
               IK = IA(I)+K
               IF(K.GT.I) IK=IA(K) + I
               DUM = DUM+S(IK)*T(K)
  260       CONTINUE
            IJ = IJ+1
            D(IJ) = DUM
  270    CONTINUE
  280 CONTINUE
C
C -TR[ DB*S*DA*S ]
C
      DUM2 = -TRACEP(DB,D,L1)
C
C  SYMMETRIC MATRIX D = S*DDA*S
C
      IJ=0
      DO 480 J=1,L1
         DO 400 I=1,L1
            DUM = ZERO
            DO 380 K = 1,L1
               IK = IA(I)+K
               IF(K.GT.I) IK=IA(K)+I
               JK = IA(J)+K
               IF(K.GT.J) JK = IA(K)+J
               DUM = DUM+DDA(IK)*S(JK)
  380       CONTINUE
            T(I) = DUM
  400    CONTINUE
         DO 470 I = 1,J
            DUM = ZERO
            DO 460 K = 1,L1
               IK = IA(I)+K
               IF(K.GT.I) IK=IA(K) + I
               DUM = DUM+S(IK)*T(K)
  460       CONTINUE
            IJ = IJ+1
            D(IJ) = DUM
  470    CONTINUE

  480 CONTINUE
C
C -TR[ DDB*S*DDA*S ]
C
      DUM3 = -TRACEP(DDB,D,L1)
C
C +TR[ V*S ]
C
      DUM4 = ZERO
      DO J=1,L1
         DO I=1,L1
            IJ = IA(MAX(I,J)) + MIN(I,J)
            DUM4 = DUM4 + V(I,J)*S(IJ) 
         END DO
      END DO
C
C     ----- CALCULATE SPIN QUANTUM NUMBERS -----
C
      S2 = DUM0 + DUM1 + DUM2 - DUM3 + DUM4*DUM4
C
      RETURN
      END
C*MODULE SFDFT   *DECK SPNFLPCL
      SUBROUTINE SPNFLPCL(SFTYPE,CNVTOL,MOCC,MVIR,NSTAT,
     *                    NTRIAL,MAXVEC,NTHST,MXITER,NCONV)
C
C     DRIVER FOR SPIN-FLIP CIS/TDDFT EXCITATION ENERGIES
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXRT=100, MXAO=8192)
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
C      LOGICAL DBUG,TRIPLET,GOPARR,DSKWRK,MASWRK,PACK2E,SG1T
      LOGICAL SOME,ROREF,DBUG,GOPARR,DSKWRK,MASWRK,PACK2E
C
      COMMON /DFTPAR/ DFTTYP(20),EXENA,EXENB,EXENC,IDFT34,NAUXFUN,
     *                                                    NAUXSHL
      COMMON /ENRGYS/ ENUC,EELEC,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FMCOM / X(1)
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INFGRD/ RHOMIN,ILENG,MAXGRD
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCKLAB/ LABSIZ
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SCFWFN/ AROHF(3),BROHF(3),PACAVO(6),IACAVO,IUHFNO,ICUHF,
     *                MVOQ
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DIMENSION MOCC(MXRT),MVIR(MXRT)
C
      DATA CHECK/8HCHECK   /
      DATA ROHF/8HROHF    /
      DATA SFCIS,SFDFT/8HSFCIS   ,8HSFDFT   /
      DATA DBUG/.FALSE./
C
      SOME = MASWRK .AND. NPRINT.NE.-5
C
C     ----- TURN OFF SYMMETRY -----
C
C OF COURSE, MANY OF THE EXCITED STATES ARE NOT TOTALLY SYMMETRIC
C
      CALL SYMOFF
C
C      CALL VCLR(TDM,1,3*MXRT)
C
C     ----- DEFINE # OF OCCUPIED AND VIRTUAL ORBITALS -----
C
      LX    = NQMT
      NOCA  = NA        ! # OF OCCUPIED ALPHA ORBITALS
      NOCB  = NB        ! # OF OCCUPIED BETA  ORBITALS
      NVIRB = LX - NOCB ! # OF VIRTUAL  BETA  ORBITALS
C
      ROREF = SCFTYP .EQ. ROHF
      IF(ROREF) THEN
         IF(ABS(AROHF(1)+BROHF(1)-ONE).GT.1.0D-05 .OR.
     *      ABS(AROHF(2)+BROHF(2)-ONE).GT.1.0D-05 .OR.
     *      ABS(AROHF(3)+BROHF(3)-ONE).GT.1.0D-05) THEN
            IF(MASWRK) WRITE(IW,9999)
            CALL ABRT
          END IF 
      END IF
C
      IF(NOCB.EQ.0) THEN
         IF(MASWRK) WRITE(IW,9998)
         CALL ABRT
      END IF
C
      L0 = NINTMX
      L1 = NUM
      L2 = (L1*(L1+1))/2
      L3 = L1*L1
C
C L7 USED FOR COMPUTATIONS AND STORAGE, L7MAX USED FOR DA-WRITE,
C AS THE NUMBER OF VIRTUAL ORBITALS CAN FLUCTUATE DURING A RUN.
C
      L7    = NOCA*NVIRB
      L7MAX = NOCA*(NUM - NOCB)
      IF(DBUG) WRITE(IW,*) 'NOCA,NOCB,NVIRB,L7=',NOCA,NOCB,NVIRB,L7
C
C     ----- DEFINE MXVEC & NDSR & NVEC:NUMBER OF INITIAL VECORS -----
C
      NDSR = NSTAT
      NVEC = NTRIAL
      IF(NDSR.GT.L7) NDSR = L7
      MXVEC = MAXVEC*NDSR
      IF(MXVEC.GT.L7) MXVEC = L7
C
C     ----- LAST CHECK -----
C
      IF(NVEC.GT.MXVEC) NVEC = MXVEC
      IF(NVEC.LT.NDSR) NVEC = NDSR
      IF(DBUG) THEN
         WRITE(IW,*) 'ILENG =',ILENG
         WRITE(IW,*) 'NDSR  =',NDSR
         WRITE(IW,*) 'L7    =',L7
         WRITE(IW,*) 'NOCA  =',NOCA
         WRITE(IW,*) 'NOCB  =',NOCB
         WRITE(IW,*) 'NVIRB =',NVIRB
         WRITE(IW,*) 'NTHST =',NTHST
         WRITE(IW,*) 'MXVEC =',MXVEC
         WRITE(IW,*) 'MAXGRD=',MAXGRD
      END IF
C
      NMAX   = MAX(2*NDSR,NVEC)
      MXVEC2 = MXVEC*(MXVEC+1)/2
      MXVEC3 = MXVEC*MXVEC
C
      CALL GOTFM(NGOTMX)
      CALL VALFM(LOADFM)
C
C     ----- MEMORY ALLOCATION ----- 
C
      LVA    = LOADFM + 1
      LVB    = LVA    + L1*LX
      LEA    = LVB    + L1*LX
      LEB    = LEA    + LX
      LINXOV = LEB    + LX 
      LXM    = LINXOV + L7*2 
      LIM    = LXM    + L7
      LBVEC  = LIM    + L7
      LWRK1  = LBVEC  + L7*MXVEC
      LWRK2  = LWRK1  + L3
      LWRK3  = LWRK2  + L3
      LBVAO  = LWRK3  + L3
      LAMAT  = LBVAO  + L3*NMAX
      LBUF   = LAMAT  + L3*NMAX 
      LIBUF  = LBUF   + L0
      LAMO   = LIBUF  + L0*LABSIZ
      LRMA   = LAMO   + L7*MXVEC
      LRMEE  = LRMA   + MXVEC2
      LRMV   = LRMEE  + MXVEC
      LRMA2  = LRMV   + MXVEC3
      LRMSCR = LRMA2  + MXVEC2
      LISCR  = LRMSCR + MXVEC*8
      LRNORM = LISCR  + MXVEC
      LQVEC  = LRNORM + NDSR
      LSCR   = LQVEC  + L7*NDSR
      LLBSYM = LSCR   + MXVEC
      LIRMOA = LLBSYM + NDSR+1
      LIRMOB = LIRMOA + LX
      LDA    = LIRMOB + LX
      LDB    = LDA    + L2
      LTA    = LDB    + L2
      LTB    = LTA    + L2
      LSMAT  = LTB    + L2
      LSSQ   = LSMAT  + L2
      LFA    = LSSQ   + NDSR
      LFB    = LFA    + LX*LX
      LAST   = LFB    + LX*LX
C
      NEED = LAST - LOADFM - 1
      IF(MASWRK) WRITE(IW,9010) SFTYPE,NEED
      CALL GETFM(NEED)
C
      IF(EXETYP.EQ.CHECK) GO TO 800
C
C     ----- READ MO AND ORBITAL ENERGIES -----
C
C ALPHA
      CALL DAREAD(IDAF,IODA,X(LVA),L1*LX,15,0)
      CALL DAREAD(IDAF,IODA,X(LEA),LX   ,17,0)
C BETA
      CALL DAREAD(IDAF,IODA,X(LVB),L1*LX,19,0)
      CALL DAREAD(IDAF,IODA,X(LEB),LX   ,21,0)
C
      IF(DBUG) THEN
         WRITE(IW,*) 'ORBITAL ENERGIES, ALPHA/BETA'
         DO IORB=1,LX
            WRITE(IW,*) IORB,X(LEA+IORB-1),X(LEB+IORB-1)
         END DO
      END IF
C
C     ----- ADDITIONAL TERMS IN ROHF REFERENCE CASE -----
C
      IF(ROREF) THEN
C
C     ----- FOCK MATRICES -----
C
C ALPHA
         CALL DAREAD(IDAF,IODA,X(LWRK2),L2,14,0)
         CALL TFTRI(X(LWRK1),X(LWRK2),X(LVA),X(LWRK3),LX,L1,L1)
         CALL CANTOGEN(X(LWRK1),X(LFA),LX)
C BETA
         CALL DAREAD(IDAF,IODA,X(LWRK2),L2,18,0)
         CALL TFTRI(X(LWRK1),X(LWRK2),X(LVB),X(LWRK3),LX,L1,L1)
         CALL CANTOGEN(X(LWRK1),X(LFB),LX)
      END IF
C
C     ----- INITIAL TRIAL VECTORS BVEC(L7,NVEC) -----
C
      CALL SFINIVEC(X(LEA),X(LEB),X(LINXOV),X(LXM),X(LIM),X(LBVEC),
     *              LX,L7,NOCA,NOCB,NVEC,MXVEC)
      IF(DBUG) WRITE(IW,*)'INITIAL VECTORS / MXVEC ',NVEC,'/',MXVEC
C
      CALL VCLR(X(LRMA),1,MXVEC2)
C
      ISTART  = 1
      IEND    = NVEC
C****                        *******************************************
C**** SFCIS/SFDFT LOOP START *******************************************
C****                        *******************************************
      ITER = 0
   10 CONTINUE
      ITER = ITER + 1
      IF(ITER.GT.MXITER) THEN
         IF(MASWRK) THEN
            WRITE(IW,*) '  .. OVER MAXIMUM ITERATION NUMBER ..'
            WRITE(IW,*) 'ITER,MXITER=',ITER,MXITER
         END IF
         ICK = 1
         GO TO 20
      END IF
C
C     ----- MATRIX-VECTOR PRODUCTS: A*BVEC -----
C
      NV = IEND - ISTART + 1
      IF(DBUG) WRITE(IW,9020) ISTART,IEND,NV
C
C MO -> AO BASIS
C
      IV = 0
      DO IVEC=ISTART,IEND
         IV = IV + 1
         CALL SFIATOGEN(X(LBVEC),X(LWRK1),LX,L7,NOCA,NOCB,IVEC,MXVEC)
         CALL DGEMM('N','N',L1,LX,LX,ONE,X(LVA),L1,X(LWRK1),LX,ZERO,
     *              X(LWRK2),L1)
         CALL DGEMM('N','T',L1,L1,LX,ONE,X(LWRK2),L1,X(LVB),L1,ZERO,
     *              X(LBVAO+(IV-1)*L1*L1),L1)
      END DO
C
C 2-ELECTRON PART: CALCULATE MATRIX A 
C
C NOTE: (1) ONLY THE HARTREE-FOCK EXCHANGE CONTRIBUTES TO THE SF
C           COUPLING BLOCK OF THE MATRIX A
C
C       (2) DFTTYP(3)=1.0 FOR CIS (SEE -SFCISCALC-)
C
      CALL VCLR(X(LAMAT),1,L3*NMAX)
      HFSCAL = DFTTYP(3)
      IF(HFSCAL.NE.ZERO) THEN
         CALL SF2E(X(LBVAO),X(LAMAT),X(LBUF),X(LIBUF),L1,NV)
C SCALING HF-EXCHANGE
         IF(HFSCAL.NE.ONE) CALL DSCAL(L3*NV,HFSCAL,X(LAMAT),1)
      END IF
C
C PRODUCT A * X
C
      IV = 0
      DO IVEC=ISTART,IEND
         IV = IV + 1
         LPOINT = LAMAT + (IV-1)*L1*L1
         CALL SFMNTOIA(X(LPOINT),X(LAMO),X(LVA),X(LVB),X(LWRK1),
     *                 L1,LX,L7,NOCA,NOCB,IVEC)
         IF(ROREF) THEN
C
C RESTRICTED OPEN REFERENCE
C
C Z(I+,A-)
            CALL SFIATOGEN(X(LBVEC),X(LWRK3),LX,L7,NOCA,NOCB,IVEC,MXVEC)
C FA(I+,J+)*Z(J+,A-)
            CALL DGEMM('N','N',NOCA,LX,NOCA,ONE,X(LFA),LX,X(LWRK3),LX,
     *                 ZERO,X(LWRK1),NOCA)
C Z(I+,B-)*FB(B-,A-)
            CALL DGEMM('N','N',NOCA,LX,LX,ONE,X(LWRK3),LX,X(LFB),LX,
     *                 ZERO,X(LWRK2),NOCA)
C
            CALL SFROESUM(X(LWRK1),X(LWRK2),X(LAMO),LX,L7,
     *                     NOCA,NOCB,IVEC)
         ELSE
C
C UNRESTRICTED REFERENCE
C
            CALL SFESUM(X(LEA),X(LEB),X(LAMO),X(LBVEC),LX,L7,
     *                  NOCA,NOCB,IVEC)
         END IF
      END DO
C
C     ----- FORM SMALL REDUCED MATRIX A AND DIAGONALIZE IT -----
C
C CALCULATE MATRIX ELEMENTS AND ADD THEM TO PREVIOUS DATA
      CALL HSUBSP(X(LBVEC),X(LAMO),X(LRMA),L7,ISTART,IEND,X(LRMEE),
     *            .FALSE.,IA)
      NVEC2 = (NVEC*NVEC+NVEC)/2
C SAVE THE PRESENT MATRIX
      CALL DCOPY(NVEC2,X(LRMA),1,X(LRMA2),1)
C DIAGONALIZATION
      CALL GLDIAG(NVEC,NVEC,NVEC,X(LRMA2),X(LRMSCR),X(LRMEE),X(LRMV),
     *            IGERR,X(LISCR))
      IF(IGERR.NE.0) CALL ABRT
C
C      ----- NORMALIZATION -----
C
       DO I=1,NVEC
          VNORM = DDOT(NVEC,X(LRMV+(I-1)*NVEC),1,X(LRMV+(I-1)*NVEC),1)
          SCAL  = ONE/SQRT(VNORM)
          CALL DSCAL(NVEC,SCAL,X(LRMV+(I-1)*NVEC),1)
       END DO
C
C     ----- RESIDUAL VECTORS W AND PERTURBED VECTORS Q -----
C
      CALL RESVEC(X(LQVEC),X(LBVEC),X(LAMO),X(LRMV),X(LRMEE),
     *            L7,1,NVEC,X(LRNORM),NDSR)
      CALL SFQVEC(X(LQVEC),X(LXM),X(LRMEE),L7,NDSR)
C
C     ----- PRINT CURRENT EXCITATION ENERGIES -----
C
      IF(SOME) THEN
         WRITE(IW,9060)
         DO JSTATE=1,NDSR
            WRITE(IW,9065) JSTATE,ITER,X(LRMEE+JSTATE-1)+ESCF,
     *                     X(LRNORM+JSTATE-1)
         END DO
         CALL FLSHBF(IW)
      END IF
C
C     ----- CHECK CONVERGENCE -----
C
      IF(SFTYPE.EQ.SFCIS) THEN
C CNVTOL=DAVCVG: CONVERGENCE CRITERION FOR DAVIDSON EIGENVECTORS
C USE RMS-NORM (SEE CISGRD.SRC)
         RNMRMS = DDOT(NDSR,X(LRNORM),1,X(LRNORM),1)
         RNMRMS = SQRT(RNMRMS)
         IF(RNMRMS.LT.CNVTOL) THEN
            ICK = 0
            CALL TRFRMB(X(LBVEC),L7,X(LRMV),X(LRMSCR),NVEC,NDSR)
C NOW X(LBVEC) ... EIGENVECTORS(L7,NDSR)
            GO TO 20
         END IF
      ELSE IF(SFTYPE.EQ.SFDFT) THEN
C CNVTOL: CONVERGENCE TOLERANCE IN THE ITERATIVE SF-DFT STEP.
C USE MAXIMUM NORM (SEE TDDFT.SRC)
         RNRMMX = 0.0D+00
         DO JSTATE=1,NDSR
            DUMMY = X(LRNORM+JSTATE-1)
            IF(DUMMY.GT.RNRMMX) RNRMMX = DUMMY
         END DO
         IF(RNRMMX.LT.CNVTOL) THEN
            ICK = 0
            CALL TRFRMB(X(LBVEC),L7,X(LRMV),X(LRMSCR),NVEC,NDSR)
C NOW X(LBVEC) ... EIGENVECTORS(L7,NDSR)
            GO TO 20
         END IF
      ELSE
         IF(MASWRK) WRITE(IW,*) 'SFTYPE MUST BE SFCIS OR SFDFT.'
         CALL ABRT
      END IF
C
C     ----- ORTHONORMALIZE Q(L7,NDSR) AND APPEND NEW B VECTORS -----
C
      CALL SFNEWB(L7,NDSR,MXVEC,X(LBVEC),X(LQVEC),NOVEC,NVEC,ICK)
C     ICK=1 NVEC OVER MXVEC:NOT CONVERGED CASE
      IF(ICK.EQ.1) THEN
         IF(MASWRK) THEN
            WRITE(IW,*) '  ..SOMETHING IS WRONG.. NVEC.GT.MXVEC'
            WRITE(IW,*) 'NVEC/MXVEC=',NVEC,'/',MXVEC
         END IF
         GO TO 20
      END IF
C
C     ----- UPDATE ISTART AND IVEC -----
C
      ISTART = NOVEC + 1
      IEND   = NVEC
      GO TO 10
C****                      *********************************************
C**** SFCIS/SFDFT LOOP END *********************************************
C****                      *********************************************
   20 CONTINUE
      IF(ICK.EQ.0) THEN
         IF(SOME) THEN
            WRITE(IW,*)' '
            WRITE(IW,*)'  -----------------------------------  '
            WRITE(IW,*)'    SPIN-FLIP CALCULATION CONVERGED'
            WRITE(IW,*)'  -----------------------------------  '
         END IF
      ELSE
         IF(MASWRK) THEN
            WRITE(IW,*)' '
            WRITE(IW,*)'  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  '
            WRITE(IW,*)'    SPIN-FLIP CALCULATION NOT CONVERGED'
            WRITE(IW,*)'  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  '
         END IF
      END IF
C
C     RECOVER POINT GROUP SYMMETRY SO THAT WE CAN LABEL THE STATES
C
      CALL SYMON
C
      IF(SOME) THEN
         WRITE(IW,9310) NVEC ,MXVEC
         WRITE(IW,9320) ITER, MXITER
         WRITE(IW,9330) L7
         WRITE(IW,9340) NUM
      END IF
C
C     ----- PUNCH CIS VECTORS TO .DAT FILE -----
C
      IF(SOME .AND. SFTYPE.EQ.SFCIS) THEN
         WRITE(IP,FMT='(8H $CISVEC)')
         WRITE(IP,9510) L7,NDSR
         LPOINT = LBVEC - L7
         DO JSTATE=1,NDSR
            LPOINT = LPOINT + L7
            WRITE(IP,9520) JSTATE,ESCF+X(LRMEE+JSTATE-1)
            WRITE(IP,9530) (X(LPOINT+ICFG-1),ICFG=1,L7)
         END DO
         WRITE(IP,FMT='(5H $END)')
         CALL FLSHBF(IP)
      END IF
C
C     ----- EXCITED-STATE (UNRELAXED) DENSITY MATRIX -----
C
C
C READ OVERLAP MATRIX
      CALL DAREAD(IDAF,IODA,X(LSMAT),L2,12,0)
C READ ALPHA/BETA DENSITY OF THE REFERENCE STATE
      CALL DAREAD(IDAF,IODA,X(LDA),L2,16,0)
      CALL DAREAD(IDAF,IODA,X(LDB),L2,20,0)
C WRITE ALPHA/BETA DENSITY OF THE REFERENCE STATE
      CALL DAWRIT(IDAF,IODA,X(LDA),L2,418,0)
      CALL DAWRIT(IDAF,IODA,X(LDB),L2,428,0)
C
      LPOINT = LBVEC - L7
      DO JSTATE=1,NDSR
         LPOINT = LPOINT + L7 
         CALL SFDMAT(X(LPOINT),X(LWRK3),X(LVA),X(LVB),X(LDA),X(LDB),
     *               X(LTA),X(LTB),X(LWRK1),X(LWRK2),
     *               NOCA,NOCB,NVIRB,L1,L2,LX,L7)
C X(LWRK3) ... X IN AO BASIS
         IF(JSTATE.EQ.NTHST) THEN
            CALL DAWRIT(IDAF,IODA,X(LPOINT),L7MAX,472,0) ! IN MO-BASIS
            CALL DAWRIT(IDAF,IODA,X(LWRK3 ),L3   ,474,0) ! IN AO-BASIS
            CALL DAWRIT(IDAF,IODA,X(LTA),L2,417,0)       ! T   ALPHA
            CALL DAWRIT(IDAF,IODA,X(LTB),L2,427,0)       ! T   BETA
            CALL DAWRIT(IDAF,IODA,X(LDA),L2, 16,0)       ! D+T ALPHA
            CALL DAWRIT(IDAF,IODA,X(LDB),L2, 20,0)       ! D+T BETA
         END IF
C
C SPIN-QUANTUM NUMBER
C
         CALL SFSSQU(S2,X(LDA),X(LDB),X(LTA),X(LTB),X(LWRK3),
     *               X(LSMAT),X(LWRK1),X(LWRK2),IA,L1,L2,NOCA,NOCB)
         X(LSSQ+JSTATE-1) = S2
      END DO
C
C     ----- OUTPUT -----
C
C
C STORE THE MOST DOMINANT TRANSITION
C
      NSTMAX = NDSR
      DO IST=1,NSTMAX
         CALL MOCVIR(X(LBVEC),IST,L7,MOCC(IST),MVIR(IST),X(LINXOV))
      END DO
C
      IF(ICK.EQ.1) THEN
         IF(MASWRK) WRITE(IW,*) 'FAILED IN SFCIS/SFDFT STEP. STOP'
      ELSE
C
C READ SYMMETRY LABELS FOR ALPHA/BETA MO'S
C
         CALL DAREAD(IDAF,IODA,X(LIRMOA),LX,356,1)
         CALL DAREAD(IDAF,IODA,X(LIRMOB),LX,357,1)
C
C PRINT EXCITATION ENERGIES ETC.
C
         CALL SFPRNT(X(LSSQ),X(LIRMOA),X(LIRMOB),X(LLBSYM),X(LINXOV),
     *               NDSR,NTHST,X(LRMEE),X(LBVEC),NOCA,NOCB,LX,L7)
      END IF
C
C     ----- END OF SF-CIS/SF-DFT CALCULATION -----
C
  800 CONTINUE
      IF(EXETYP.EQ.CHECK) THEN
         CALL VCLR(X(LWRK1),1,L3)
         call vclr(x(lbvec),1,l7max)
         CALL DAWRIT(IDAF,IODA,X(LWRK1),L2, 16,0)
         CALL DAWRIT(IDAF,IODA,X(LWRK1),L2, 20,0)
         CALL DAWRIT(IDAF,IODA,X(LWRK1),L2,417,0)
         CALL DAWRIT(IDAF,IODA,X(LWRK1),L2,418,0)
         CALL DAWRIT(IDAF,IODA,X(LWRK1),L2,427,0)
         CALL DAWRIT(IDAF,IODA,X(LWRK1),L2,428,0)
         call dawrit(idaf,ioda,x(lbvec),l7max,472,0)
         CALL DAWRIT(IDAF,IODA,X(LWRK1 ),L3   ,474,0)
      END IF

      CALL RETFM(NEED)
      IF(MASWRK) WRITE(IW,9700) SFTYPE
      CALL TIMIT(1)
C
      NCONV = ICK
      RETURN
C
 9010 FORMAT(1X,'MEMORY REQUIRED FOR ',A8,'ITERATIONS IS',I10,
     *          ' WORDS.'/)
 9020 FORMAT(1X,'   CURRENT VECTORS ',I4,' TO',I4,' (',I4,' VECTORS)')
 9060 FORMAT(/1X,'STATE',6X,'ITERATION',6X,'ENERGY',9X,'RESIDUE NORM')
 9065 FORMAT(1X,I3,8X,I5,F20.10,F15.8)
 9310 FORMAT(' NUMBER OF USED VECTORS / MAX =',I4,1X,'/',I4)
 9320 FORMAT(' NUMBER OF ITERATIONS   / MAX =',I4,1X,'/',I4)
 9330 FORMAT(' NUMBER OF SINGLE EXCITATIONS =',I6)
 9340 FORMAT(' NUMBER OF ATOMIC ORBITALS    =',I4)
 9510 FORMAT(I10,1X,'SPINFLIP,',I4,' STATES')
 9520 FORMAT('STATE',I4,' ENERGY=',F20.10)
 9530 FORMAT(1P,5E14.6)
 9700 FORMAT(1X,'..... DONE WITH ',A8,'EXCITATION ENERGIES .....')
 9998 FORMAT(/1X,'BETA ORBITALS ARE NOT FOUND. STOP')
 9999 FORMAT(/1X,'FOR ROHF CANONICALIZATION PARAMETERS,'/
     *        1X,'ACC+BCC, AOO+BOO AND AVV+BVV MUST BE UNITY.')
      END
C*MODULE SFDFT   *DECK SF2E
      SUBROUTINE SF2E(DA,FA,BUF,IBUF,NBF,NV)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,TDSKWRK
      LOGICAL PACK2E,SCHWRZ,DIRSCF,FDIFF
C
      DIMENSION DA(NV*NBF*NBF) ! DA(NBF,NBF,NV)
      DIMENSION FA(NV*NBF*NBF) ! FA(NBF,NBF,NV)
      DIMENSION BUF(NINTMX),IBUF(NINTMX)
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXAO=8192)
C
C     COMMON /DFTPAR/ DFTTYP(20),EXENA,EXENB,EXENC,IDFT34,NAUXFUN,
C    *                                                    NAUXSHL
      COMMON /FMCOM / XX(1)
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DATA RHF/8HRHF     /
C
C     --- FORM SQUARE NON-SYMMETRIC FOCK-LIKE MATRIX ---
C         DIRECT METHOD = RECOMPUTE 2E- AO INTEGRALS
C         STANDARD METHOD = PROCESS INTEGRALS FROM DISK
C
      NINT = 0
      NSCHWZ = 0
      NBF3 = NBF*NBF
C
      IF(DIRSCF) THEN
         SCHWRZ=ISCHWZ.GT.0
         NSH2 = (NSHELL*NSHELL+NSHELL)/2
C
         CALL BASCHK(LMAX)
                       NANGM =  4
         IF(LMAX.EQ.2) NANGM =  6
         IF(LMAX.EQ.3) NANGM = 10
         IF(LMAX.EQ.4) NANGM = 15
         IF(LMAX.EQ.5) NANGM = 21
         IF(LMAX.EQ.6) NANGM = 28
         MAXG = NANGM**4
C
         CALL VALFM(LOADFM)
         LGHOND = LOADFM + 1
         LXINTS = LGHOND + MAXG
         LDSH   = LXINTS + NSH2
C         LDDIJ  = LDSH   + NSH2
C         LAST   = LDDIJ  + 49*MXG2
         LAST = LDSH     + NSH2
         NEED = LAST - LOADFM - 1
         CALL GETFM(NEED)
C
         IF(SCHWRZ) THEN
            DUMMY = 0.0D+00
            CALL SHLTD(RHF,DA,DUMMY,XX(LDSH),NBF,NSH2,NV)
            CALL DAREAD(IDAF,IODA,XX(LXINTS),NSH2,54,0)
         END IF
         CALL SFTWOEI(SCHWRZ,NINT,NSCHWZ,NBF,XX(LXINTS),NSH2,XX(LGHOND),
     *                MAXG,IA,DA,FA,XX(LDSH),NV)
         CALL RETFM(NEED)
      ELSE
         TDSKWRK = DSKWRK
         DSKWRK  = .TRUE.
         CALL SEQREW(IJK)
         CALL SFADISK(DA,NBF,FA,BUF,IBUF,NINTMX,NOPK,NV)
         DSKWRK  = TDSKWRK
      END IF
C
C     --- SUM UP PARTIAL FOCK-LIKE MATRICES ---
C
      IF(GOPARR) THEN
         CALL DDI_GSUMI(2311,NINT,1)
         CALL DDI_GSUMI(2312,NSCHWZ,1)
         CALL DDI_GSUMF(2313,FA,NV*NBF3)
      END IF
C
      RETURN
      END
C*MODULE SFDFT   *DECK SFADISK
      SUBROUTINE SFADISK(PA,L1,FA,XX,IX,NINTMX,NOPK,NV)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXAO=8192)
C
C     COMMON /DFTPAR/ DFTTYP(20),EXENA,EXENB,EXENC,IDFT34,NAUXFUN,
C    *                                                    NAUXSHL
      COMMON /IJPAIR/ IA(MXAO)
C     COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
C    *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /ORDOPT/ NORDER(7)
      COMMON /PCKLAB/ LABSIZ
C
      DIMENSION XX(NINTMX),IX(*)
      DIMENSION FA(L1,L1,NV)
      DIMENSION PA(L1,L1,NV)
C
      DATA HALF/0.5D+00/
C
      CALL SEQREW(IS)
      I = 0
      J = 0
      K = 0
      L = 0
      NXX = 0
      IF(NOPK.NE.1) THEN
         WRITE(IW,*) 'NOPK.NE.1' 
         WRITE(IW,*) 'SFDFT CALCULATION DOES NOT SUPPORT ',
     *               'THIS INTEGRAL TYPE'
         CALL ABRT
      END IF
C
C     ----- INTEGRALS ARE NOT IN SUPERMATRIX FORM (NOPK=.TRUE.) -----
C
  620 CONTINUE
      CALL PREAD(IS,XX,IX,NXX,NINTMX)
      IF(NXX .EQ. 0) GO TO 720
      NINT = IABS(NXX)
      IF(NINT .GT. NINTMX) CALL ABRT
      DO 700 M = 1,NINT
C
                       NPACK = M
                       IF (LABSIZ .EQ. 2) THEN
*I32                      LABEL = IX( 2*NPACK - 1 )
*I32                      IPACK = ISHFT( LABEL, -16 )
*I32                      JPACK = IAND(  LABEL, 65535 )
*I32                      LABEL = IX( 2*NPACK     )
*I32                      KPACK = ISHFT( LABEL, -16 )
*I32                      LPACK = IAND(  LABEL, 65535 )
*I64                     LABEL = IX(NPACK)
*I64                     IPACK = ISHFT( LABEL, -48 )
*I64                     JPACK = IAND( ISHFT( LABEL, -32 ), 65535 )
*I64                     KPACK = IAND( ISHFT( LABEL, -16 ), 65535 )
*I64                     LPACK = IAND( LABEL, 65535 )
                       ELSE IF (LABSIZ .EQ. 1) THEN
*I32                      LABEL = IX(NPACK)
*I32                      IPACK = ISHFT( LABEL, -24 )
*I32                      JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
*I32                      KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
*I32                      LPACK = IAND( LABEL, 255 )
*I64                     IF ( MOD(NPACK,2) .EQ. 0 ) THEN
*I64                       LABEL = IX( NPACK/2 )
*I64                       IPACK = IAND( ISHFT( LABEL, -24 ), 255 )
*I64                       JPACK = IAND( ISHFT( LABEL, -16 ), 255 )
*I64                       KPACK = IAND( ISHFT( LABEL,  -8 ), 255 )
*I64                       LPACK = IAND( LABEL, 255 )
*I64                     ELSE
*I64                       LABEL = IX( (NPACK/2)+1 )
*I64                       IPACK = ISHFT( LABEL, -56 )
*I64                       JPACK = IAND( ISHFT( LABEL, -48 ), 255 )
*I64                       KPACK = IAND( ISHFT( LABEL, -40 ), 255 )
*I64                       LPACK = IAND( ISHFT( LABEL, -32 ), 255 )
*I64                     END IF
                       END IF
                       I = IPACK
                       J = JPACK
                       K = KPACK
                       L = LPACK
C
         VAL = XX(M)
         NIJ = IA(I)+J
         NKL = IA(K)+L
C
C
C           USING SQUARE CANONICAL INTEGRAL FILE
C
         IF(NORDER(7) .EQ. 1) THEN
            IF(NKL .GT. NIJ) GO TO 700
            IF(I .EQ. J) VAL=VAL*HALF
            IF(K .EQ. L) VAL=VAL*HALF
            IF(NIJ .EQ. NKL) VAL=VAL*HALF
         END IF
C
         DO IMO=1,NV
            FA(I,K,IMO) = FA(I,K,IMO) - VAL*PA(J,L,IMO)
            FA(K,I,IMO) = FA(K,I,IMO) - VAL*PA(L,J,IMO)
            FA(I,L,IMO) = FA(I,L,IMO) - VAL*PA(J,K,IMO)
            FA(L,I,IMO) = FA(L,I,IMO) - VAL*PA(K,J,IMO)
            FA(J,K,IMO) = FA(J,K,IMO) - VAL*PA(I,L,IMO)
            FA(K,J,IMO) = FA(K,J,IMO) - VAL*PA(L,I,IMO)
            FA(J,L,IMO) = FA(J,L,IMO) - VAL*PA(I,K,IMO)
            FA(L,J,IMO) = FA(L,J,IMO) - VAL*PA(K,I,IMO)
         END DO
C
  700 CONTINUE
C
      IF(NXX .GT. 0) GO TO 620
C
  720 CONTINUE
C
      CALL SEQREW(IS)
C
      RETURN
      END
C*MODULE SFDFT   *DECK SFTWOEI
      SUBROUTINE SFTWOEI(SCHWRZ,NINT,NSCHWZ,L1,
     *                   XINTS,NSH2,GHONDO,MAXG,
     *                   IA,DA,F,DSH,NV)
C
C     THIS IS A DUMMY CODE OF 'SUBROUTINE TWOEI' @ INT2A.SRC
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL CMBDIR
      LOGICAL OUT,SCHWRZ,SCHSKP,GOPARR,DSKWRK,MASWRK,DLB,SLB,C1GRP
      LOGICAL SKIPA,SKIPB,SKIPC,NPSYM
      LOGICAL PK,PANDK,BLOCK,GPSAVE
      LOGICAL LTRMST
C
      CHARACTER*8 INAOFL
C
      DIMENSION XINTS(NSH2),GHONDO(MAXG),IA(L1),DA(*),
     *          F(L1,L1,*),DSH(NSH2)
      DIMENSION MI(48),MJ(48),MK(48),M0(48)
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000)
C
      COMMON /ELGFIL/ NFILE,INAOFL
      COMMON /ELGTRM/ LTRMST,NFLTRM,NRCTRM,NPSTRM,NHTSHL
      COMMON /INT2IC/ NINTIC,ININTIC,NXXIC,LBUFPIC,LIXIC,LABSIX,NINTIX
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PKFIL / PK,PANDK,BLOCK
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /SHLEXC/ NORGSH(3),NORGSP(3),IEXCH,NANGM,NGTH(4)
      COMMON /SHLG70/ ISH,JSH,KSH,LSH,IJKLXX(4)
      COMMON /SHLNOS/ QQ4,LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,
     *                MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,
     *                NIJ,IJ,KL,IJKL
      COMMON /SHLT  / TOL,CUTOFF,ICOUNT,OUT
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                T(432),INVT(48),NT
C
      PARAMETER (ZERO=0.0D+00)
C
C          ----- TWO-ELECTRON INTEGRALS -----
C     THIS VERSION CAN HANDLE S,P,D,F,G AND L SHELLS
C
      TIM = ZERO
      CALL TSECND(TIM)
C
      CMBDIR= .TRUE.
C
C        THE OLD FASHIONED PARALLEL INTEGRAL TRANSFORMATIONS DO NOT
C        ALLOW THE AO INTEGRAL WORK TO BE RUN IN PARALLEL.  THE MODERN
C        DISTRIBUTED MEMORY TRANSFORMATIONS DO NOT PASS THROUGH HERE.
C
      GPSAVE = GOPARR
C
C     ----- INITIALIZATION FOR PARALLEL WORK -----
C     BOTH STATIC AND DYNAMIC LOAD BALANCING ARE IMPLEMENTED BELOW
C
      SLB = GOPARR  .AND.  IBTYP.EQ.0
      DLB = GOPARR  .AND.  IBTYP.EQ.1
      NEXT = -1
      MINE = -1
      IPCOUNT = ME - 1
C
      C1GRP = NT.EQ.1
C
      CALL BASCHK(LMAX)
                    NANGM =  4
      IF(LMAX.EQ.2) NANGM =  6
      IF(LMAX.EQ.3) NANGM = 10
      IF(LMAX.EQ.4) NANGM = 15
      IF(LMAX.EQ.5) NANGM = 21
      IF(LMAX.EQ.6) NANGM = 28
      NGTH(4) = 1
      NGTH(3) = NGTH(4) * NANGM
      NGTH(2) = NGTH(3) * NANGM
      NGTH(1) = NGTH(2) * NANGM
      IF(NOPK.EQ.0) THEN
         NORGSH(1) = 0
         NORGSH(2) = NORGSH(1) + NANGM**4
         NORGSH(3) = NORGSH(2) + NANGM**4
         NORGSP(1) = 0
         NORGSP(2) = 256
         NORGSP(3) = 512
      ELSE
         DO I=1,3
            NORGSH(I) = 0
            NORGSP(I) = 0
         END DO
      END IF
C
      NINT  = 0
      NSCHWZ= 0
      SCHSKP=.FALSE.
      DENMAX = ZERO
C
C        NOW WE ARE READY TO LOOP OVER ALL NSHELL**4 SHELL QUARTETS
C
C     ----- I SHELL -----
C
      DO 920 II = IST,NSHELL
C
C     ----- CHECK CPU TIME -----
C
      CALL TSECND(TIM)
      IF(TIM.GE.TIMLIM) THEN
C        NOTHING CAN BE DONE FOR IN-CORE INTEGRALS: JUST FORGET THEM
         IF(MASWRK) WRITE(IW,9030)
         CALL ABRT
      END IF
C
C         ELONGATION METHOD
      IF(LTRMST) THEN
         IF(II.EQ.NHTSHL) THEN
            NFLTRM = NFILE
            NRCTRM = NREC
            NPSTRM = ICOUNT
         END IF
      END IF
C
C     ----- PRINT INTERMEDIATE RESTART DATA -----
C
      IF(NPRINT.NE.-5  .AND.  .NOT.CMBDIR .AND. MASWRK) THEN
         IF(ICOUNT.LE.NINTIC) THEN
            WRITE(IW,9015) II,JST,KST,LST,ICOUNT
         ELSE
            WRITE(IW,9010) II,JST,KST,LST,NREC,ICOUNT-NINTIC
         END IF
      END IF
C
C     ----- SKIP I SHELL IF NOT SYMMETRY UNIQUE -----
C     THIS, AND THE SIMILAR BRANCHINGS FOR THE J, K, AND L LOOPS IS
C     WHAT GENERATES THE "PETITE" RATHER THAN "GRANDE" INTEGRAL LIST.
C
      IF(C1GRP) THEN
         MI(1)=II
      ELSE
         DO 120 IT = 1,NT
            ID = MAPSHL(II,IT)
            IF (ID .GT. II) GO TO 920
            MI(IT) = ID
  120    CONTINUE
      END IF
C
C     ----- J SHELL -----
C
      J0 = JST
      DO 900 JJ = J0,II
      JST = 1
C
      IF(C1GRP) THEN
         MJ(1)=JJ
      ELSE
         DO 200 IT = 1,NT
            ID = MI(IT)
            JD = MAPSHL(JJ,IT)
            MJ(IT) = JD
            IF (ID .GE. JD) GO TO 160
            ND = ID
            ID = JD
            JD = ND
  160       IF (ID-II) 200,180,900
  180       IF (JD-JJ) 200,200,900
  200    CONTINUE
      END IF
C
C     ----- GO PARALLEL! -----
C
      IF (DLB) THEN
         MINE = MINE + 1
         IF (MINE.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
         IF (NEXT.NE.MINE) GO TO 900
      END IF
C
C     ----- K SHELL -----
C
      K0 = KST
      DO 880 KK = K0,JJ
      KST = 1
C
      IF(C1GRP) THEN
         MK(1)=KK
      ELSE
         DO 340 IT = 1,NT
            ID = MI(IT)
            JD = MJ(IT)
            KD = MAPSHL(KK,IT)
            MK(IT) = KD
  240       IF (ID .GE. JD) GO TO 260
            ND = ID
            ID = JD
            JD = ND
  260       IF (JD .GE. KD) GO TO 280
            ND = JD
            JD = KD
            KD = ND
            GO TO 240
  280       IF (ID-II) 340,300,880
  300       IF (JD-JJ) 340,320,880
  320       IF (KD-KK) 340,340,880
  340    CONTINUE
      END IF
C
C     ----- GO PARALLEL! -----
C
      IF(SLB) THEN
         IPCOUNT = IPCOUNT + 1
         IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 880
      END IF
C
C     ----- L SHELL ----
C
      L0 = LST
      DO 860 LL = L0,KK
      LST = 1
C
      IF(C1GRP) THEN
         M0(1)=1
         N4=1
      ELSE
         N4 = 0
         DO 540 IT = 1,NT
            ID = MI(IT)
            JD = MJ(IT)      
            KD = MK(IT)
            LD = MAPSHL(LL,IT)
  380       IF (ID .GE. JD) GO TO 400
            ND = ID
            ID = JD
            JD = ND
  400       IF (JD .GE. KD) GO TO 420
            ND = JD
            JD = KD
            KD = ND
            GO TO 380
  420       IF (KD .GE. LD) GO TO 440
            ND = KD
            KD = LD
            LD = ND
            GO TO 400
  440       IF (ID-II) 540,460,860
  460       IF (JD-JJ) 540,480,860
  480       IF (KD-KK) 540,500,860
  500       IF (LD-LL) 540,520,860
  520       N4 = N4+1
            M0(N4) = IT
  540    CONTINUE
      END IF
C
C         THE LOOP STRUCTURE IN THIS ROUTINE IS DESIGNED TO FACILITATE
C         SUPERMATRIX CONSTRUCTION BY HAVING UP TO THREE "EXCHANGED"
C         QUARTETS AVAILABLE AT ONCE.  THE LOOP STRUCTURE TO GENERATE
C         A MORE NORMAL CANONICAL ORDERING OF THE QUARTETS HITS THE
C         SAME QUARTETS IN A SLIGHTLY DIFFERENT ORDER, BUT BOTH LOOPS
C         WILL DO EXACTLY THE SAME QUARTETS.
C
C             CANONICAL                      SUPERMATRIX
C         DO ISH=1,NSHELL                 DO II=1,NSHELL
C           DO JSH=1,ISH                    DO JJ=1,II
C             IJSH = IA(ISH)+JSH
C             DO KSH=1,ISH                    DO KK=1,JJ
C               DO LSH=1,KSH                    DO LL=1,KK
C                 KLSH=IA(KSH)+LSH
C                 IF(IJSH.LT.KLSH),               [II JJ|KK LL],
C                    CYCLE KSH LOOP               [II KK|JJ LL],
C                 [ISH JSH|KSH LSH]               [II LL|JJ KK]
C               ENDDO                           ENDDO
C             ENDDO                           ENDDO
C           ENDDO                           ENDDO
C         ENDDO                           ENDDO
C
C     ----- CHECK FOR REDUNDANIES BETWEEN THE 3 COMBINATIONS -----
C            (II,JJ//KK,LL), (II,KK//JJ,LL), (II,LL//JJ,KK)
C
      SKIPA =  JJ.EQ.KK
      SKIPB = (II.EQ.KK) .OR. (JJ.EQ.LL)
      SKIPC = (II.EQ.JJ) .OR. (KK.EQ.LL)
      NPSYM = .FALSE.
      IF (SKIPA .OR. SKIPB .OR. SKIPC) GO TO 720
      NPSYM = .TRUE.
      DO 640 M = 1,N4
         IT = M0(M)
         IH = MI(IT)
         JH = MJ(IT)
         IF(JH.LE.IH) THEN
            ID = IH
            JD = JH
         ELSE
            ID = JH
            JD = IH
         END IF
         IF(.NOT.SKIPA) SKIPA = (ID.EQ.II .AND. JD.EQ.KK) .OR.
     *                          (ID.EQ.JJ .AND. JD.EQ.LL)
         IF(.NOT.SKIPB) SKIPB = (ID.EQ.II .AND. JD.EQ.LL) .OR.
     *                          (ID.EQ.JJ .AND. JD.EQ.KK)
         IF (SKIPA .AND. SKIPB) GO TO 660
         KH = MK(IT)
         IF(KH.LE.IH) THEN
            ID = IH
            KD = KH
         ELSE
            ID = KH
            KD = IH
         END IF
         IF(.NOT.SKIPC) SKIPC = (ID.EQ.II .AND. KD.EQ.LL) .OR.
     *                          (ID.EQ.JJ .AND. KD.EQ.KK)
         IF(SKIPA .AND. SKIPC) GO TO 680
         IF(SKIPB .AND. SKIPC) GO TO 700
  640 CONTINUE
      GO TO 720
C
  660 SKIPC = .TRUE.
      GO TO 720
  680 SKIPB = .TRUE.
      GO TO 720
  700 SKIPA = .TRUE.
C
C        GENERATE SYMMETRY FACTOR -Q4- FOR THIS QUARTET IN PETITE LIST
C
  720 CONTINUE
      Q4 = NT
      Q4 = Q4 / N4
C
C     ----- (II,JJ//KK,LL) -----
C
      IEXCH = 1
      ISH = II
      JSH = JJ
      KSH = KK
      LSH = LL
      QQ4 = Q4
      IF(SKIPA .AND. NPSYM) QQ4 = QQ4+Q4
      IF(SKIPB .AND. NPSYM) QQ4 = QQ4+Q4
      GO TO 780
C
C     ----- (II,KK//JJ,LL) -----
C
  740 IF (SKIPA) GO TO 760
      IEXCH = 2
      ISH = II
      JSH = KK
      KSH = JJ
      LSH = LL
      QQ4 = Q4
      IF (SKIPC .AND. NPSYM) QQ4 = QQ4+Q4
      GO TO 780
C
C     ----- (II,LL//JJ,KK) -----
C
  760 IF (SKIPB .OR. SKIPC) GO TO 840
      IEXCH = 3
      ISH = II
      JSH = LL
      KSH = JJ
      LSH = KK
      QQ4 = Q4
C
C        ----- COMPUTE TWO-ELECTRON INTEGRALS ----
C
  780 CONTINUE
      IF(PK .AND. IEXCH.EQ.1) CALL ZPKOUT(ISH,JSH,KSH,LSH,GHONDO,
     *                                    SKIPA,SKIPB,SKIPC,NPSYM)
C
C     APPLY THE SCHWARZ INEQUALITY TO SCREEN OUT SMALL INTEGRALS,
C      (II,JJ//KK,LL) .LE.  SQRT( (II,JJ//II,JJ)*(KK,LL//KK,LL) )
C     SEE, FOR EXAMPLE, J.L.WHITTEN, J.CHEM.PHYS. 58,4496-4501(1973)
C
      IF(SCHWRZ) THEN
         IJIJ = (ISH*ISH-ISH)/2 + JSH
         KLKL = (KSH*KSH-KSH)/2 + LSH
         TEST = QQ4*XINTS(IJIJ)*XINTS(KLKL)
         DENMAX = SCHWDN(DSH,ISH,JSH,KSH,LSH,IA)
         TEST = TEST*DENMAX
         SCHSKP = TEST.LT.CUTOFF
         IF(SCHSKP) NSCHWZ = NSCHWZ + 1
      END IF
      IF(SCHSKP) GO TO 820
C
C        ----- ELECTRON REPULSION INTEGRAL CALCULATION -----
C     THIS MAY USE ROTATED AXIS, ERIC, OR RYS QUADRATURE METHODS
C
      CALL SHELLQUART(ISH,JSH,KSH,LSH,GHONDO)
C
C        DIRECT SF-CIS AND SF-DFT
C
      CALL SFDIRFCK(DA,F,GHONDO,L1,NINT,NV)
C
  820 CONTINUE
      GO TO (740,760,840),IEXCH
C
  840 CONTINUE
C
C     ----- END OF SHELL LOOPS -----
C
  860 CONTINUE
  880 CONTINUE
  900 CONTINUE
  920 CONTINUE
C
      IF(DLB) CALL DDI_DLBRESET
C
      GOPARR = GPSAVE
      RETURN
C
 9010 FORMAT(1X,'II,JST,KST,LST =',4I3,' NREC =',I10,' INTLOC =',I5)
 9015 FORMAT(1X,'II,JST,KST,LST =',4I3,' IN CORE, INTLOC =',I12)
 9030 FORMAT(//1X,'*** THIS JOB HAS EXHAUSTED ITS CPU TIME ***'/
     *         1X,'     (WHILE COMPUTING 2E- INTEGRALS)'///)
      END
C*MODULE SFDFT   *DECK SFDIRFCK
      SUBROUTINE SFDIRFCK(DA,FA,GHONDO,NBF,NINT,NV)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL IANDJ,KANDL,SAME,OUT
C
      DIMENSION GHONDO(*)
      DIMENSION DA(NBF,NBF,NV)
      DIMENSION FA(NBF,NBF,NV)
C
      PARAMETER (MXSH=5000, MXGTOT=20000)
C
C     COMMON /DFTPAR/ DFTTYP(20),EXENA,EXENB,EXENC,IDFT34,NAUXFUN,
C    *                                                    NAUXSHL
      COMMON /ERIOUT/ ISH,JSH,KSH,LSH,LSTRI,LSTRJ,LSTRK,LSTRL
      COMMON /MISC  / IANDJ,KANDL,SAME
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /SHLNOS/ QQ4,LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,
     *                MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,
     *                NIJX,IJ,KL,IJKL
      COMMON /SHLT  / TOL,CUTOFF,ICOUNT,OUT
C
      DATA HALF /0.5D+00/
C
C-NEXT STATEMENT IS FOR VARIOUS IBM XLF 3.X AND 5.X COMPILERS-
C
      SAVE IJN,KLN
C
C     --- FORM A BATCH OF SQUARE NON-SYMMETRIC FOCK-LIKE MATRICES
C     DIRECTLY FROM INTEGRALS ---
C
      CUTINT = CUTOFF
C
      SAME  = ISH .EQ. KSH .AND. JSH .EQ. LSH
      IANDJ = ISH .EQ. JSH
      KANDL = KSH .EQ. LSH
C
      MINI = KMIN(ISH)
      MINJ = KMIN(JSH)
      MINK = KMIN(KSH)
      MINL = KMIN(LSH)
      MAXI = KMAX(ISH)
      MAXJ = KMAX(JSH)
      MAXK = KMAX(KSH)
      MAXL = KMAX(LSH)
      LOCI = KLOC(ISH)-MINI
      LOCJ = KLOC(JSH)-MINJ
      LOCK = KLOC(KSH)-MINK
      LOCL = KLOC(LSH)-MINL
C
      IJN = 0
      JMAX = MAXJ
      DO 360 I = MINI,MAXI
         I_ERIC = (I-MINI)*LSTRI + 1
         IF (IANDJ) JMAX = I
         DO 340 J = MINJ,JMAX
            IJ_ERIC = (J-MINJ)*LSTRJ + I_ERIC
            IJN = IJN+1
            LMAX = MAXL
            KLN = 0
            DO 320 K =  MINK,MAXK
               IJK_ERIC = (K-MINK)*LSTRK + IJ_ERIC
               IF (KANDL) LMAX = K
               DO 300 L = MINL,LMAX
                  KLN = KLN+1
                  IF(SAME .AND. KLN.GT.IJN) GO TO 340
C
                  IJKL_ERIC = (L-MINL)*LSTRL + IJK_ERIC
                  VAL = GHONDO( IJKL_ERIC )
                  IF(ABS(VAL).LT.CUTINT) GO TO 300
                  NINT = NINT + 1
C
                  II = LOCI+I
                  JJ = LOCJ+J
                  KK = LOCK+K
                  LL = LOCL+L
                  IF (II .GE. JJ) GO TO 100
                  N = II
                  II = JJ
                  JJ = N
  100             IF (KK .GE. LL) GO TO 120
                  N = KK
                  KK = LL
                  LL = N
  120             IF (II-KK) 140,160,180
  140             N = II
                  II = KK
                  KK = N
                  N = JJ
                  JJ = LL
                  LL = N
                  GO TO 180
  160             IF (JJ .LT. LL) GO TO 140
  180             CONTINUE
C
                  IF(II.EQ.JJ) VAL = VAL*HALF
                  IF(KK.EQ.LL) VAL = VAL*HALF
                  IF(II.EQ.KK  .AND.  JJ.EQ.LL) VAL = VAL*HALF
C
C                 --- LOOP OVER BATCH OF MOS AND MAKE CONTRIB. TO
C                 FOCK-LIKE MATRIX ---
C
                  DO IMO=1,NV
                     FA(II,KK,IMO) = FA(II,KK,IMO) - VAL*DA(JJ,LL,IMO)
                     FA(KK,II,IMO) = FA(KK,II,IMO) - VAL*DA(LL,JJ,IMO)
                     FA(II,LL,IMO) = FA(II,LL,IMO) - VAL*DA(JJ,KK,IMO)
                     FA(LL,II,IMO) = FA(LL,II,IMO) - VAL*DA(KK,JJ,IMO)
                     FA(JJ,KK,IMO) = FA(JJ,KK,IMO) - VAL*DA(II,LL,IMO)
                     FA(KK,JJ,IMO) = FA(KK,JJ,IMO) - VAL*DA(LL,II,IMO)
                     FA(JJ,LL,IMO) = FA(JJ,LL,IMO) - VAL*DA(II,KK,IMO)
                     FA(LL,JJ,IMO) = FA(LL,JJ,IMO) - VAL*DA(KK,II,IMO)
                  END DO
  300          CONTINUE
  320       CONTINUE
  340    CONTINUE
  360 CONTINUE
C
      RETURN
      END
C*MODULE SFDFT   *DECK SFESUM
      SUBROUTINE SFESUM(EA,EB,PMO,Z,LX,L7,NOCA,NOCB,IVEC)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION EA(*),EB(*)
      DIMENSION PMO(L7,*)
      DIMENSION Z(L7,*)
C
C     ----- ADD (EA-EI)*ZAI -----
C
      IJ = 0
      DO J=NOCB+1,LX
         DO I=1,NOCA
            IJ = IJ + 1
            PMO(IJ,IVEC) = PMO(IJ,IVEC) + (EB(J)-EA(I))*Z(IJ,IVEC)
         END DO
      END DO
      RETURN
      END
C
C*MODULE SFDFT   *DECK SFIATOGEN
      SUBROUTINE SFIATOGEN(PV,AV,LX,L7,NOCA,NOCB,IVEC,MXVEC)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION PV(L7,MXVEC),AV(LX,LX)
C
      CALL VCLR(AV,1,LX*LX)
C
      IJ = 0
      DO J=NOCB+1,LX
         DO I=1,NOCA
            IJ = IJ + 1
            AV(I,J) = PV(IJ,IVEC)
         END DO
      END DO
      RETURN
      END
C*MODULE SFDFT   *DECK SFINIVEC
      SUBROUTINE SFINIVEC(EA,EB,INXOV,XM,IM,BVEC,
     *                    LX,L7,NOCA,NOCB,NVEC,MXVEC)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL DBUG
C
      DIMENSION EA(LX),EB(LX)
      DIMENSION XM(L7)
      DIMENSION IM(L7)
      DIMENSION BVEC(L7,MXVEC)
      DIMENSION INXOV(2,*)
C
      DATA MXINIVEC/50/
      DATA DBUG/.FALSE./
C
C     -- MXINIVEC
      IF(MXINIVEC.GT.MXVEC) MXINIVEC = MXVEC
C     -- SET INXOV(2,L7) & XM(L7)
      IJ = 0
      DO J=NOCB+1,LX
         DO I=1,NOCA
            IJ = IJ + 1
            INXOV(1,IJ) = I
            INXOV(2,IJ) = J
C SAVE PREVIOUS ORDERING
            XM(IJ) = EB(J) - EA(I)
            IM(IJ) = IJ
         END DO
      END DO
C
C     ----- ORDERING XM(L7):XM(SMALL) =< XM(LARGE) -----
C     ** GET SMALLER DIAGONAL VALUES
      DO 20 J=1,L7-1
      DO 20 I=J+1,L7
         IF(XM(J).LE.XM(I)) GO TO 20
         XMJ   = XM(J)
         IMJ   = IM(J)
         XM(J) = XM(I)
         IM(J) = IM(I)
         XM(I) = XMJ
         IM(I) = IMJ
   20 CONTINUE
C
      IF (DBUG) THEN
         WRITE(6,*) 'PRINT XM(L7) ORDERING'
         DO I=1,L7
            WRITE(6,*) 'I,XM(I),IM(I)=',I,XM(I),IM(I)
         END DO
      END IF
C
C     ----- GET INITIAL VECTORS: BVEC(L7,NVEC) -----
C
      CALL VCLR(BVEC,1,L7*NVEC)
      DO K=1,NVEC
         BVEC(IM(K),K)=1.0D+00
      END DO
C
      IF(DBUG) THEN
         WRITE(6,*) 'PRINT INITIAL BVEC'
         JMAX = 0
 10      JMIN = JMAX + 1
         JMAX = JMIN + 4
         IF(JMAX.GT.NVEC) JMAX = NVEC
         WRITE(6,*) (J,J=JMIN,JMAX)
         DO I=1,L7
            WRITE(6,*) (BVEC(I,J),J=JMIN,JMAX)
         END DO
         IF(JMAX.LT.NVEC) GO TO 10
      END IF
C
C     ----- SET XM(L7) AGAIN -----
C
      IJ = 0
      DO J=NOCB+1,LX
         DO I=1,NOCA
            IJ = IJ + 1
            XM(IJ) = EB(J) - EA(I)
         END DO
      END DO
C
      RETURN
      END
C*MODULE SFDFT   *DECK SFMNTOIA
      SUBROUTINE SFMNTOIA(PAO,PMO,VA,VB,SCR,L1,LX,L7,NOCA,NOCB,IVEC)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00)
C
      DIMENSION PAO(L1,*)
      DIMENSION PMO(L7,*)
      DIMENSION VA(L1,LX),VB(L1,LX)
      DIMENSION SCR(NOCA,*)
C
C     ----- (M,N) TO (I+,N) -----
C
      CALL DGEMM('T','N',NOCA,L1,L1,ONE,VA,L1,PAO,L1,ZERO,SCR,NOCA)
C
C     ----- (I+,N) TO (I+A-) -----
C
      IJ = 0 
      DO J=NOCB+1,LX
         DO I=1,NOCA
            IJ = IJ + 1
            DUMN = ZERO
            DO N=1,L1
               DUMN = DUMN +SCR(I,N)*VB(N,J)
            END DO
            PMO(IJ,IVEC) = DUMN
         END DO
      END DO
C
      RETURN
      END
C*MODULE SFDFT   *DECK SFNEWB
      SUBROUTINE SFNEWB(NDIM,NDSR,MXVEC,BVEC,Q,NOVEC,NVEC,ICK)
C
C      ORTHONORMALIZE Q(NDIM,NDSR) AND APPEND TO BVEC
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL DBUG
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
      DIMENSION Q(NDIM,NDSR)
      DIMENSION BVEC(NDIM,*)
C
      DATA THREB /1.0D-09/
      DATA DBUG  /.FALSE./
C
C     SAVE NVEC AS NOVEC
C
      NOVEC = NVEC
      ICK = 0
C
C     SCHMIDT ORTHONORMALIZATION
C
      DO 100 K=1,NDSR
C
         DO ISTAT=1,NVEC
            BQ = DDOT(NDIM,BVEC(1,ISTAT),1,Q(1,K),1)
            CALL DAXPY(NDIM,-BQ,BVEC(1,ISTAT),1,Q(1,K),1)
         END DO
C
         FNOR = DDOT(NDIM,Q(1,K),1,Q(1,K),1)
         FNOR = SQRT(FNOR)
         IF(FNOR.LT.THREB) GO TO 100
C
C     -----  APPEND NEW B VECTOR -----
C
       NVEC = NVEC + 1
       IF(NVEC.GT.MXVEC) THEN
          ICK = 1
          RETURN
       ELSE
          SCAL = 1.0D+00/FNOR
          CALL DSCAL(NDIM,SCAL,Q(1,K),1)
          CALL DCOPY(NDIM,Q(1,K),1,BVEC(1,NVEC),1)
       END IF
C
  100 CONTINUE
C
C ERROR TERMINATION
C
      MS = NVEC - NOVEC
      IF(MS.EQ.0) THEN
         IF(MASWRK) WRITE(IW,*)
     *     'SOMETHING WRONG...THERE ARE NO VECTORS TO BE ADDED'
         CALL ABRT
      END IF
C
C DEBUG PRINT
C
      IF(DBUG) THEN
         WRITE(IW,*)'NUMBER OF VECTORS ',NVEC,'=',NOVEC,
     *              '(OLD)+',MS,'(NEW)'
         WRITE(IW,*) 'CHECK ORTHONORMALITY'
         DO ISTAT=1,NVEC
            DO K=1,ISTAT
               FNOR = DDOT(NDIM,BVEC(1,ISTAT),1,BVEC(1,K),1)
               WRITE(IW,'(2I5,3X,F7.3)') K,ISTAT,FNOR
            END DO
         END DO
      END IF
      RETURN
      END
C*MODULE SFDFT   *DECK SFPRNT
      SUBROUTINE SFPRNT(SSQ,IRMOA,IRMOB,LABSYM,INXOV,NDSR,NTHST,
     *                  EE,VRO,NOCA,NOCB,LX,L7)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
C      LOGICAL GOPARR,DSKWRK,MASWRK,TRIPLET,CHECK
C      LOGICAL ABEL,ABELPT,SG1T
      LOGICAL GOPARR,DSKWRK,MASWRK,CHECK
      LOGICAL ABEL,ABELPT
      LOGICAL SOME
C
      PARAMETER (MXATM=2000, MXRT=100)
C
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FUNCT / ENERGY,EG(3*MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C     COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /SYMMUL/ NIJREP(14,14),IJREP(2,14,14,14)
      COMMON /SYMREP/ IRPNAM(14),IPA(14),LAMBDA(14),LAMBD0(14),
     *                IADDR1(14),IADDR2(14),IADDR3(14)
C
      DIMENSION VRO(L7,*),INXOV(2,*)
      DIMENSION IRMOA(LX),IRMOB(LX),LABSYM(0:NDSR)
      DIMENSION SSQ(NDSR),EE(NDSR)
C
      PARAMETER (ZERO=0.0D+00)
      PARAMETER (TOEV=27.21138386D+00, THRESHOLD=5.0D-02)
      DATA IQMARK/4H????/
C-MWS DATA IBLANK/4H    /
C
C     SOME = MASWRK .AND. NPRINT.NE.-5
      SOME = MASWRK
      IF(SOME) WRITE(IW,8886)
C
      ABEL = ABELPT()
C      IF(.NOT.ABEL  .AND.  MASWRK) WRITE(IW,9050)
C
C      -- SYMMETRY OF REFERENCE STATE
C
      IRP = IRMOA(1) 
      DO I=2,NOCA 
         JRP = IRMOA(I)
         IINAM = IJREP(2,1,IRP,JRP)
         IRP = IINAM
      END DO
C
      IRP = IINAM
      DO I=1,NOCB
         JRP = IRMOB(I)
         IINAM = IJREP(2,1,IRP,JRP)
         IRP = IINAM
      END DO
      IINAM0    = IINAM
      LABSYM(0) = IRPNAM(IINAM0) 
C
      DO 10 ISTAT=1,NDSR
C         IF(ISTAT.LE.IMAX) GO TO 10
C         OSI  = OS(ISTAT)
         YDUM = TOEV*EE(ISTAT)
C
C      -- SYMMETRY OF EXCITED STATE
C     MIKE DOES NOT BELIEVE THAT THIS CODE ALWAYS PRINTS THE CORRECT
C     STATE SYMMETRY, AND HAS AN N2 EXAMPLE TO BACK THIS UP.  HE
C     ORIGINALLY USED THE LINES THAT YOU SEE COMMENTED OUT, PREFERRING
C     TO PRINT BLANKS FOR ALL STATES, RATHER THAN MISTAKES FOR SOME.
C
C-MWS   IF(ABEL) THEN
           CHECK = .FALSE.
           NAMSAV = -179
           DO IJ=1,L7
              I = INXOV(1,IJ)
              J = INXOV(2,IJ)
              XDUM = VRO(IJ,ISTAT)
              IF (ABS(XDUM).GT.THRESHOLD) THEN
                 IRP = IRMOA(I)
                 JRP = IRMOB(J)
                 IINAM = IJREP(2,1,IRP,JRP)
                 IF(CHECK) THEN
                    IF(IINAM.NE.NAMSAV) THEN
                       WRITE(IW,8892)
                       LABSYM(ISTAT) = IQMARK
                       GO TO 50
                    END IF
                 ELSE
                    CHECK = .TRUE.
                    NAMSAV = IINAM
                 END IF
              END IF
           END DO
           IINAM = IJREP(2,1,IINAM,IINAM0)
           LABSYM(ISTAT) = IRPNAM(IINAM)
C-MWS   ELSE
C-MWS      LABSYM(ISTAT)=IBLANK
C-MWS   END IF
C
   50   CONTINUE
C
        IF(SOME) THEN
           WRITE(IW,8888) ISTAT, YDUM
C           WRITE(IW,8889) OSI
           WRITE(IW,8890) LABSYM(ISTAT),SSQ(ISTAT)
           WRITE(IW,8887)
           WRITE(IW,8884)
        END IF
C
        DO IJ=1,L7
           I = INXOV(1,IJ)
           J = INXOV(2,IJ)
           XDUM = VRO(IJ,ISTAT)
           IF (ABS(XDUM).GT.THRESHOLD) THEN
              IF(SOME) WRITE(IW,8891) IJ,XDUM,I,J
           END IF
        END DO
   10 CONTINUE
C
C         PRINT SUMMARY TABLE
C
      IF(MASWRK) THEN
         IF(.NOT.ABEL) WRITE(IW,9050)
         WRITE(IW,9010)
C # OF NEGATIVE ROOTS
         NDEEX = 0
         DO IST=1,NDSR
            IF(EE(IST).LT.ZERO) NDEEX = NDEEX + 1
         END DO
         WRITE(IW,9015) NDEEX
C DE-EXCITATION
         DO IST=1,NDEEX
            WRITE(IW,9021) IST,LABSYM(IST),ESCF+EE(IST),
     *                     TOEV*EE(IST),SSQ(IST)
         END DO
C REFERENCE
         WRITE(IW,9020) 0,LABSYM(0),ESCF,ZERO
C EXCITATION
         DO IST=NDEEX+1,NDSR
            WRITE(IW,9021) IST,LABSYM(IST),ESCF+EE(IST),
     *                     TOEV*EE(IST),SSQ(IST)
         END DO
         WRITE(IW,*) ' '
      END IF
C
C                ----- SAVE ENERGY RESULTS -----
C     CAN'T UPDATE K.E., ET CETERA WITHOUT A DENSITY MATRIX
C
      SZZ       = SSQ(NTHST)
      SZ        = 0.0D+00
      ENERGY    = ESCF + EE(NTHST)
      ETOT      = ENERGY
      STATN     = MIN(1+NDSR,MXRT)
      DO I=1,MIN(NDSR,MXRT-1)
        ESTATE(I+1) = ESCF + EE(NTHST)
      END DO
      NSTMAX=NDSR
      DO I=1,NSTMAX
         ESTATE(I)       = EE(I)
C         TDM(1,I)    = 0.0D+00
C         TDM(2,I)    = 0.0D+00
C         TDM(3,I)    = 0.0D+00
      END DO
      CALL DAWRIT(IDAF,IODA,ENUCR,MXRT+15,2,0)
      IF(MASWRK) WRITE(IW,9030) NTHST,ENERGY
C
      RETURN
C
 8892 FORMAT(/1X,'WARNING: THIS STATE HAS BROKEN SYMMETRY, CHECK MOS')
 8890 FORMAT(1X,'SYMMETRY OF STATE   =',4X,A4/
     *       1X,'S-SQUARED           =',1X,F9.4)
 8888 FORMAT(/1X,'STATE #',I4,2X,'ENERGY =',F12.6,1X,'EV')
 8887 FORMAT(8X,'DRF',4X,'COEF',7X,'OCC(A)',4X,'VIR(B)')
 8886 FORMAT(/5X,35(1H-)/
     *        5X,'ALPHA -> BETA SPIN-FLIP EXCITATIONS'/
     *        5X,35(1H-))
 8884 FORMAT(8X,3(1H-),4X,4(1H-),7X,6(1H-),4X,6(1H-))
 8891 FORMAT(7X,I4,1X,F9.6,6X,I4,2X,'->',2X,I4,2X)
 9010 FORMAT(/10X,28(1H-)/
     *        10X,'SUMMARY OF SPIN-FLIP RESULTS'/
     *        10X,28(1H-)//
     *         3X,'STATE',13X,'ENERGY',5X,'EXCITATION',5X,'S-SQUARED')
 9015 FORMAT(/1X,I1,' NEGATIVE ROOT(S) FOUND.')
 9020 FORMAT(1X,I3,2X,A4,1X,F20.10,1X,F8.3,15X,'(REFERENCE STATE)')
 9021 FORMAT(1X,I3,2X,A4,1X,F20.10,1X,F8.3,5X,F9.4)
 9030 FORMAT(1X,'SELECTING EXCITED STATE IROOT=',I4,' AT E=',F20.10/
     *       1X,'AS THE STATE OF INTEREST.'/)
 9050 FORMAT(/1X,'THIS IS A NON-ABELIAN POINT GROUP, AS A RESULT,'/
     *       1X,'SOME STATE SYMMETRY LABELS MAY NOT BE CORRECTLY',
     *          ' PRINTED BELOW'/)
      END
C*MODULE SFDFT   *DECK SFQVEC
      SUBROUTINE SFQVEC(Q,XM,EIGV,NCFG,NSTATE)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION Q(NCFG,*),XM(*),EIGV(*)
C
      DO IST=1,NSTATE
         DO II=1,NCFG
            VAL1 = EIGV(IST) - XM(II)
            VAL2 = ABS(VAL1) 
C
            IF(VAL2.LT.1.0D-12) THEN
               VAL1 = 1.0D-05
            ELSE IF(VAL2.LT.1.0D-05) THEN
               SIGN = VAL2/VAL1
               VAL1 = SIGN*1.0D-05
            END IF
C
            Q(II,IST) = Q(II,IST)/VAL1
         END DO
      END DO
C
      RETURN
      END
C
      SUBROUTINE SFROESUM(FAZ,ZFB,PMO,LX,L7,NOCA,NOCB,IVEC)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION FAZ(NOCA,LX),ZFB(NOCA,LX)
      DIMENSION PMO(L7,*)
C
      IJ = 0
      DO J=NOCB+1,LX
         DO I=1,NOCA
            IJ = IJ + 1
            PMO(IJ,IVEC) = PMO(IJ,IVEC) + ZFB(I,J) - FAZ(I,J)
         END DO
      END DO
      RETURN
      END
C*MODULE SFDFT   *DECK SFDMAT
      SUBROUTINE SFDMAT(R,RAO,CA,CB,DA,DB,TA,TB,WRK1,WRK2,
     *                  NOCA,NOCB,NVIRB,L1,L2,LX,L7)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
      DIMENSION R(NOCA,NVIRB),RAO(L1,L1),CA(L1,LX),CB(L1,LX),
     *          DA(L2),DB(L2),TA(L2),TB(L2),WRK1(*),WRK2(*)
C
C MO(I+,A-) -> AO(M,N)
C
      CALL SFIATOGEN(R,WRK1,LX,L7,NOCA,NOCB,1,1)
      CALL DGEMM('N','N',L1,LX,LX,ONE,CA,L1,WRK1,LX,ZERO,WRK2,L1)
      CALL DGEMM('N','T',L1,L1,LX,ONE,WRK2,L1,CB,L1,ZERO,RAO,L1)
C
C     ----- UNRELAXED DIFFERENCE DENSITY MATRIX -----
C
C OCC(ALPHA)-OCC(ALPHA)
C
      CALL DGEMM('N','T',NOCA,NOCA,NVIRB,-ONE,R,NOCA,R,NOCA,ZERO,
     *           WRK1,NOCA)
C MO(I+,J+) -> AO(M,N)
      CALL DGEMM('N','N',L1,NOCA,NOCA,ONE,CA,L1,WRK1,NOCA,ZERO,WRK2,L1)
      CALL DGEMM('N','T',L1,L1,NOCA,ONE,WRK2,L1,CA,L1,ZERO,WRK1,L1)
      CALL GENTOCAN(WRK1,TA,L1)
C TOTAL (= REFERENCE + UNRELAXED) DENSITY FOR ALPHA
      CALL DAREAD(IDAF,IODA,DA,L2,418,0)
      CALL VADD(DA,1,TA,1,DA,1,L2)
C
C VIRT(BETA)-VIRT(BETA)
C
      CALL DGEMM('T','N',NVIRB,NVIRB,NOCA,ONE,R,NOCA,R,NOCA,ZERO,
     *           WRK1,NVIRB)
C MO(A-,B-) -> AO(M,N)
      CALL DGEMM('N','N',L1,NVIRB,NVIRB,ONE,CB(1,NOCB+1),L1,
     *           WRK1,NVIRB,ZERO,WRK2,L1)
      CALL DGEMM('N','T',L1,L1,NVIRB,ONE,WRK2,L1,CB(1,NOCB+1),
     *           L1,ZERO,WRK1,L1)
      CALL GENTOCAN(WRK1,TB,L1)
C TOTAL (= REFERENCE + UNRELAXED) DENSITY FOR BETA
      CALL DAREAD(IDAF,IODA,DB,L2,428,0)
      CALL VADD(DB,1,TB,1,DB,1,L2)
C
      RETURN
      END
