CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C     Main program
C000  PROGRAM VB2000
CSMI  PROGRAM VB2000
C
C     VB2000 embedded in Gaussian. Details are in 'gaussian.README'.
CGAU  SUBROUTINE VB2000(RWRK,EGAU)
C
C     VB2000 embedded in Gamess(US). Details are in 'gamess.README'.
CGMS  SUBROUTINE VB2000()
C
C     The solvation effects code is still work in progress. Routines are
C     now set to exit without doing anything. Do not use these routines.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     THIS IS THE APPLICATION LEVEL MAIN PROGRAM
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
CSTA  INCLUDE 'maxwork.inc'
CGAU  DIMENSION RWRK(*)
      LOGICAL LEX
      CHARACTER*2 ATMSYM,TEMPSYM(92)
      CHARACTER*3 FUNIT(10)
      CHARACTER*80 VBPATH
      CHARACTER*64 FSTR,RWFFILE,INTFILE,INPFILE,LOCFILE,FILE
CGAU  COMMON /IO/ IN, IOUT, IPUNCH
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
     &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
     &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
CGMS  COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
CGMS  COMMON /VBINTF/ VBENGY
CGMS  COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /VB2MEM/LOCX,LOCMEM,LOFFS,MEMWRK,MSCRATCH,MHIGH
      COMMON /ATOMSY/ ATMSYM(92)
      DATA TEMPSYM/' H','He','Li','Be',' B',' C',' N',' O',' F','Ne',
     1            'Na','Mg','Al','Si',' P',' S','Cl','Ar',
     2            ' K','Ca','Sc','Ti',' V','Cr','Mn','Fe','Co',
     3            'Ni','Cu','Zn','Ga','Ge','As','Se','Br','Kr','Rb',
     4 'Sr',' Y','Zr','Nb','Mo','Tc','Ru','Rh','Pd','Ag','Cd','In',
     5 'Sn','Sb','Te',' I','Xe','Cs','Ba','La','Ce','Pr','Nd','Pm',
     6 'Sm','Eu','Gd','Tb','Dy','Ho','Er','Tm','Yb','Lu','Hf','Ta',
     7 ' W','Re','Os','Ir','Pt','Au','Hg','Tl','Pb','Bi','Po','At',
     8 'Rn','Fr','Ra','Ac','Th','Pa',' U'/
CLIC  INTEGER*4 LICTEST(1)
CGMS  DATA CHECK  /8HCHECK   /
C
      DO I=1,92
         ATMSYM(I) = TEMPSYM(I)
      ENDDO
      CALL SETIAA()
      CALL IOVBINIT()
      CALL GETIOUNIT('IOTEMP  ',IOTEMP)
      CALL GETIOUNIT('IOTEMPA ',IOTEMPA)
      CALL GETIOUNIT('IOTEMPB ',IOTEMPB)
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL GETIOUNIT('IOVBORB ',IOVBORB)
      CALL GETIOUNIT('IVBO2E  ',IVBO2E)
      CALL GETIOUNIT('IOVBOLIB',IOVBOLIB)
      CALL GETIOUNIT('IAO2E   ',IAO2E)
      IOVBIN = 5
CGAU  IOVBIN = IN
CGMS  IOVBIN = IR
      IOUTVB = 6
CGAU  IOUTVB = IOUT
CGMS  IOUTVB = IW
      IPNT = 0
      ENERGY = 0.0D0
      MHIGH = 0
C
C     License check first
C
CLIC  CALL FCHECKLICENSE(LICTEST)
CLIC  IF(LICTEST(1) < 1) CALL ABORT0("NO LICENSE")
C     WRITE(IOUTVB,'(" MHIGH",2I12)') 1,MHIGH
C
C     All machine dependant stuff about random numbers is in subroutine
C     VBRAND at the end of this file. If you have problems, consult the
C     information in that routine.
C
C     Seed Random number generator for later
      ISEED=425001
      X = VBRAND(ISEED)
      ENERGY = X
C     Dummy statement to avoid ftncheck warning.
      ENERGY = 0.0D0
C
CGAU  GOTO 20
CGMS  IGMS=1
CGMS  IF(IGMS.EQ.1) GOTO 20
C
C     Get filename of job.
      CALL GETARG(1,FSTR)
      DO I=1,64
      IF(FSTR(I:I).EQ.' ') THEN
         LENFIL=I-1
         GOTO 1
      ENDIF
      ENDDO
C     With Watcom compiler and maybe others, the 7 lines above
C     can be replaced with:-
C     LENFIL = igetarg(1,FSTR)
C
 1    CONTINUE
      INPFILE=FSTR(1:LENFIL)//'.inp'
      OPEN(UNIT=IOVBIN,FILE=INPFILE,STATUS='OLD',
     1  ACCESS='SEQUENTIAL',FORM='FORMATTED')
C
C     Open IOENGI.
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(10)
      OPEN(UNIT=IOENGI,FILE=FILE,STATUS='UNKNOWN',
     1  ACCESS='SEQUENTIAL',FORM='FORMATTED')
C
      CALL VBINIT(IOVBIN,IOENGI)
      CALL BANNER(IOUTVB)
C
      WRITE(IOUTVB,102) FSTR
 20   CONTINUE
C
CGMS  IF (EXETYP.EQ.CHECK) WRITE(IOUTVB,
CGMS & '(/," THIS IS A RUNTYP=CHECK RUN")')
C
C     Get path from environment variable $VB2000PATH.
      VBPATH = ' '
      CALL GETENV('VB2000PATH',VBPATH)
C
C     If VBPATH is empty, assume it is the current dir
C
      IF (VBPATH .EQ. ' ') VBPATH = '. '
      WRITE(IOUTVB,101) VBPATH
C
C     SAVE VBPATH
C
      CALL SETVBPATH(VBPATH)
C
      LOCFILE=FSTR(1:LENFIL)//'.loc'
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(2)
      OPEN(UNIT=IAO2E,FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(4)
      OPEN(UNIT=IOVBORB,FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(5)
      OPEN(UNIT=IVBO2E,FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(6)
      OPEN(UNIT=IOTEMPA, FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(7)
      OPEN(UNIT=IOTEMPB, FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(9)
      OPEN(UNIT=IOVBOLIB, FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='FORMATTED')
C
C     SCAN RESTART FILE
C
      IFILE = IOVBIN
CGMS  IFILE = IOENGI
C
      CALL LOCTOR(IFILE,'$RESTARTFILE',12,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IFILE,*)FILE
      INQUIRE(FILE=FILE,EXIST=LEX)
      IF (.NOT.LEX) THEN
        WRITE(IOUTVB,106) FILE
        CALL ABORT0('MAIN0001  ')
      ENDIF
      OPEN(UNIT=IOTEMP,FILE=FILE,STATUS='UNKNOWN',
     1  ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      WRITE(IOUTVB,103) FILE
      REWIND(IOTEMP)
      REWIND(IOVBORB)
C
C     COPY RESTART FILE FROM IOTEMP TO IOVBORB
C
      CALL CPRESTART(IOTEMP,IOVBORB)
      CLOSE(IOTEMP)
      END IF
      MEMLIM = 6500000
C
C     Allocate memory dynamically
C
CDYN  REWIND(IOVBIN)
CDYN  CALL LOCTOR(IOVBIN,'$MEMORY',7,IOK,0)
CDYN  IF (IOK.EQ.1) READ(IOVBIN,*) MEMLIM
CDYN  CALL SETMEM(MEMLIM)
CGMS  REWIND(IOVBIN)
CGMS  CALL LOCTOR(IOVBIN,'$MEMORY',7,IOK,0)
CGMS  IF (IOK.EQ.1) READ(IOVBIN,*) MEMLIM
CGMS  CALL CKMEM(MEMMAX)
C     MEMMAX IS LARGEST MEMORY USED BY GAMESS BEFORE ENTRY TO VB2000
CGMS  CALL GOTFM(MEMGMS)
C     MEMGMS IS MEMORY ALLOCATED IN GAMESS $SYSTEM
CGMS  MEMVB = MEMGMS - MEMMAX
C     MEMVB = MAX(FREE GAMESS MEMORY,VB2000 MEMORY ALLOCATION)
CGMS  IF(MEMVB.LE.MEMLIM) MEMVB = MEMLIM
CGMS  MEMLIM = MEMVB
CGMS  WRITE(IOUTVB,104) MEMLIM
CGMS  CALL SETMEM(MEMLIM)
C
CSTA  WRITE(IOUTVB,'(" STATIC MEMORY USE IS:",I12,/)') MEMLIM
      MSCRATCH = MEMLIM
C
C     Start calculation - separate entry for $REACTOR runs and others.
      REWIND(IOVBIN)
      CALL LOCTOR(IOVBIN,'$REACTION',9,IOK,0)
      IF (IOK.EQ.1) THEN
CGAU    WRITE(IOUTVB,
CGAU & '(/," REACTION RUN IS NOT POSSIBLE WITH GAUSSIAN VERSION",/)')
CGAU    CALL ABRTG('VB Error')
C000    CALL REACTOR(IOVBIN,IOENGI)
CSMI    CALL REACTOR(IOVBIN,IOENGI)
CGMS    CALL REACTOR(IOVBIN,IOENGI)
      ELSE
CGAU    CALL VBENGINE(RWRK,ENERGY)
CGMS    CALL VBENGINE(ENERGY)
CGMS    VBENGY = ENERGY
C000    CALL VBENGINE(ENERGY)
CSMI    CALL VBENGINE(ENERGY)
      END IF
C
      CLOSE(IOVBORB)
      CLOSE(IVBO2E)
      CLOSE(IOVBOLIB)
      CLOSE(IOTEMPA)
      CLOSE(IOTEMPB)
      CLOSE(IOENGI)
      CLOSE(IAO2E)
      CLOSE(97)
C
C     Release memory
C
CDYN  CALL FREEMEM()
CGMS  CALL FREEMEM()
C

C     Now return to Gamess or Gaussian correctly.
CGMS  RETURN
CGAU  EGAU  = ENERGY
CGAU  RETURN
C
C 2   FORMAT(/,' Input files',/,' ===========',/,' RWF FILE is ',A64)
C 3   FORMAT(' INT FILE is ',A64)
C 4   FORMAT(' Standard input is ',A64)
 101  FORMAT(/,' VB2000 DIRECTORY IS: ',A80)
 102  FORMAT(/,' JOB NAME IS ',A64)
 103  FORMAT(' USING RESTARTFILE ',A64)
 104  FORMAT(" MAXIMUM MEMORY USE IS:",I12,/,
     &" THIS IS TAKEN AS THE MAXIMUM OF THE UNUSED MEMORY REQUESTED",/
     &" IN GAMESS $SYSTEM BLOCK AND MEMORY REQUESTED IN VB2000 DATA"/)
 106  FORMAT(" FILE: ",A64,/," DOES NOT EXIST")
      END
      SUBROUTINE BANNER(IIOUT)
      WRITE(IIOUT,1400)
CWVB  WRITE(IIOUT,1)
      WRITE(IIOUT,2)
      WRITE(IIOUT,1401)
 1400 FORMAT(/
     1' **************************************************************'/
     1' *                                                            *'/
     1' *                        V B 2 0 0 0                         *'/
     1' *                                                            *')
CWVB1 FORMAT(
CWVB 1' *                WinVB2000 - Windows Version                 *'/
CWVB 1' *                                                            *')
    2 FORMAT(
     1' *       An ab initio Valence-Bond Program Based on the       *'/
     1' *           Generalized Product Function Method and          *'/
     1' *                  the Algebrant Algorithm                   *'/
     1' *                                                            *'/
     1' *         `      Version 2.6(R1)  April 2012                 *'/
     1' *                                                            *'/
     1' *         Jiabo Li*, Brian Duke** and Roy McWeeny***         *'/
     1' *                                                            *'/
     1' *   * SciNet Technologies, 9943 Fieldthorn St., San Diego    *'/
     1' *     CA 92127, USA                                          *'/
     1' *                                                            *'/
     1' *  ** Monash University Institute of Pharmaceutical Sciences,*')
 1401 FORMAT(
     1' *     381 Royal Pde, Parkville, Victoria, 3052, Australia    *'/
     1' *                                                            *'/
     1' * *** Department of Chemistry, University of Pisa,           *'/
     1' *     56100 Pisa, Italy                                      *'/
     1' *                                                            *'/
     1' *  Reference for the software:                               *'/
     1' *     Jiabo Li, Brian Duke, and Roy McWeeny, VB2000 Version  *'/
     1' *     2.6, SciNet Technologies, San Diego, CA, 2012          *'/
     1' *     URL: http://www.scinetec.com or http://www.vb2000.net  *'/
     1' *                                                            *'/
     1' *  References for the theory:                                *'/
     1' *     Jiabo Li, and Roy McWeeny, "VB2000: Pushing Valence    *'/
     1' *     Bond Theory to New Limits", Int. J. Quantum Chem.,     *'/
     1' *     89(2002)208-216.                                       *'/
     1' *                                                            *'/
     1' *     Jiabo Li, Brian J. Duke, Thomas M. Klapoetke, and Roy  *'/
     1' *     McWeeny, Spin-Density of Spin-Free Valence Bond Wave   *'/
     1' *     Functions and Its Implementation in VB2000. J. Theor.  *'/
     1' *     Comp. Chem. 7(2008)853-867.                            *'/
     1' *                                                            *'/
     1' *  Copyright (C) 2000-2012 by SciNet Technologies            *'/
     1' **************************************************************')
      RETURN
      END
C
C     COPY DATA FROM IOTEMP TO IOVB
C
      SUBROUTINE CPRESTART(IOTEMP, IOVBORB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION MELEX(100),MLORBITX(100),METHODX(100)
      CHARACTER*12 BFLABEX(1000)
      DIMENSION BASISX(500000),DM1NONX(500000)
C
C     NBASISX =< 1000!
C
      READ(IOTEMP)  NSUBX,NDM1X,(MELEX(I),I=1,NSUBX),
     &              (MLORBITX(I),I=1,NSUBX),(METHODX(I),I=1,NSUBX)
      WRITE(IOVBORB)NSUBX,NDM1X,(MELEX(I),I=1,NSUBX),
     &              (MLORBITX(I),I=1,NSUBX),(METHODX(I),I=1,NSUBX)
C
      READ(IOTEMP)  NBASISX,NATOMX,NORBX,(BFLABEX(I),I=1,NBASISX)
      WRITE(IOVBORB)NBASISX,NATOMX,NORBX,(BFLABEX(I),I=1,NBASISX)
C
      READ(IOTEMP)  (BASISX(I),I=1,NBASISX*NORBX)
      WRITE(IOVBORB)(BASISX(I),I=1,NBASISX*NORBX)
C
      READ(IOTEMP)  (DM1NONX(I),I=1,NDM1X)
      WRITE(IOVBORB)(DM1NONX(I),I=1,NDM1X)
      RETURN
      END
      SUBROUTINE VBINIT(IOVBIN,IOENGI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 A
      REWIND(IOVBIN)
 10   READ(IOVBIN,'(A80)',END=100)A
      WRITE(IOENGI,'(A80)')A
      GOTO 10
 100  CONTINUE
      DO I=1,80
      A(I:I)=' '
      ENDDO
      WRITE(IOENGI,'(A80)')A
      REWIND(IOENGI)
      RETURN
      END
C
C     VB2000 Dynamic memory management
C
C     GAMESS-VB does not have CDYN flag remover, thus we need BOTH CDYN and CGMS
C
      SUBROUTINE SETMEM(MEMLIM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /VB2MEM/LOCX,LOCMEM,LOFFS,MEMWRK,MSCRATCH,MHIGH
CDYN  COMMON /GENWRK/X(1)
CGMS  COMMON /GENWRK/X(1)
CL32  LOCX = LADDRS(X)
CL64  LOCX = LOC(X)
CGMS  CALL GETLOC(X,LOCX)
CDYN  LOCMEM = MEMGET(MEMLIM)
CGMS  LOCMEM = MEMGET(MEMLIM)
C     WRITE(IOUTVB,1) LOCX, LOCMEM, MEMLIM
C1    FORMAT(' LOCX =',I14,' LOCMEM =',I14,' MEMLIM =',I14)
      IF(LOCMEM.EQ.0) THEN
        WRITE(IOUTVB,*)
     &      "MEMORY ALLOCATION FAILED. YOU MAY TRY WITH REDUCED"
        WRITE(IOUTVB,*)"MEMORY "
        CALL ABORT0('SETMEM0001')
      END IF
      LOFFS = LOCMEM - LOCX
      LOFFS = (LOFFS+7)/8 + 1
      MEMWRK = MEMLIM
      RETURN
      END
C
      SUBROUTINE FREEMEM()
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /VB2MEM/LOCX,LOCMEM,LOFFS,MEMWRK,MSCRATCH,MHIGH
CDYN  CALL MEMREL(LOCMEM)
CGMS  CALL MEMREL(LOCMEM)
      RETURN
      END
C
      SUBROUTINE PATHST(FILEN,IN1,IN2,IN3,K)
C     Combines strings IN1 (always VBPATH), IN2 (must be padded out to
C     16 with spaces) and IN3 (length K) and outputs result in FILEN.
C
      CHARACTER*80 FILEN,IN1,IN3
      CHARACTER*16 IN2
      INTEGER K,L,I,II,KK,LL
      L=LEN(IN1)
      DO I=2,16
        IF (IN2(I:I).EQ.' ') GOTO 1
      ENDDO
 1    LL=I-1
      DO I=1,L
        IF (IN1(I:I).NE.' ') THEN
          FILEN(I:I) = IN1(I:I)
        ELSE
          II=I+LL-1
          FILEN(I:II) = IN2
          II = II + 1
          KK=II+K-1
          FILEN(II:KK) = IN3(1:K)
          KK=KK+1
          FILEN(KK:80) = ' '
          RETURN
        ENDIF
      ENDDO
      RETURN
      END
C
C     Driver of reaction path
C
C     IOVBIN: ORIGINAL VB INPUT FILE WITH REACTION PATH DATA
C     IOENGI: WORKING INPUT FILE
C
      SUBROUTINE REACTOR(IOVBIN,IOENGI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=2000)
      PARAMETER (NATMAX=1000,MAXPTS=1000)
C     PARAMETER (NATMAX=10000,MAXPTS=1000)
      LOGICAL LXYZ
      CHARACTER*1 SYM
      CHARACTER*3 FUNIT(10)
      CHARACTER*10 NUMBER
      CHARACTER*40 TITLE
      CHARACTER*64 FSTR,RWFFILE,INTFILE,INPFILE,LOCFILE
      CHARACTER*80 CSTAR, CBLNK, ESTAR
      DIMENSION RPFXYZ(3,NATMAX),NATNUM(NATMAX),INTDEX(4,MAXPTS)
      DIMENSION XYZTMP(3,1000),EPATH(MAXPTS)
C000  DIMENSION C1(3,MXATM)
CSMI  DIMENSION C1(3,MXATM)
CGAU  DIMENSION C1(3,MXATM)
C     Note, not used in Gaussian version, but has to compile!
CGMS  COMMON /VBINTF/ VBENGY
      PARAMETER (MAXSHL=200,MAXATM=100)
      COMMON /SEEING/ XEXP(MAXSHL,30),COEFF(MAXSHL,30),SYM(MAXSHL),
     &NF(MAXSHL),JJ(MAXSHL),KATOM(MAXATM),IMOL
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
CGMS  COMMON/INFOA/ NAT1, ICH1, MUL1, NUM1, NX1, NE1, NA1, NB1,
CGMS 1    ZAN1(MXATM), C1(3,MXATM), IAN(MXATM)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
     &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
     &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
CGMS  COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
CGMS  DATA CHECK  /8HCHECK   /
      CSTAR='********************************************************'
      CBLNK='                                                        '
      NUMBER='0123456789'
      LXYZ=.FALSE.
      REWIND(IOVBIN)
      CALL LOCTOR(IOVBIN,'$REACTION',9,IOK,0)
      IF (IOK.EQ.1) THEN
      READ(IOVBIN,*,ERR=100)IPOINT,NGEOMS,NATOMS
      GOTO 110
 100  WRITE(IOUTVB,*)'ERROR IN READING IPOINT,NGEOMS,NATOMS'
      CALL ABORT0('REACTOR01 ')
 110  CONTINUE
      WRITE(IOUTVB,1100)
      END IF
      IF(IPOINT.LT.0.OR.NGEOMS.LT.0.OR.NATOMS.LT.0) THEN
        WRITE(IOUTVB,*)
     &      "ERROR IN REACTION INPUT FOR IPOINT,NGEOMS OR NATOMS"
        CALL ABORT0('REACTOR02 ')
      END IF
      WRITE(IOUTVB,1200)NGEOMS
      WRITE(IOUTVB,1300)IPOINT
      NAT=0
      DO I=1, NGEOMS
      READ(IOVBIN,*)
        DO J=1, NATOMS
        NAT = NAT + 1
        IF (NAT.GT.NATMAX) CALL ABORT0('REACTOR03 ')
        READ(IOVBIN,*,ERR=200)NATNUM(NAT),RPFXYZ(1,NAT),RPFXYZ(2,NAT),
     &                                    RPFXYZ(3,NAT)
C       WRITE(IOUTVB,'(I8,3F15.7)')NATNUM(NAT),RPFXYZ(1,NAT),
C    &     RPFXYZ(2,NAT),RPFXYZ(3,NAT)
        END DO
      END DO
C
C     STRUCTURE ALIGNMENT
C
      CALL ALIALL(RPFXYZ(1,1),NATOMS,NGEOMS)
      INTDEX(1,1)=1
      INTDEX(2,1)=IPOINT+1
      INTDEX(3,1)=2
      INTDEX(4,1)=0
      NPT = 0
      DO I=1, NGEOMS-1
      NPT = NPT + 1
      INTDEX(1,NPT) = I
      INTDEX(2,NPT) = IPOINT+1
      INTDEX(3,NPT) = I
      INTDEX(4,NPT) = 0
         DO J=1, IPOINT
         NPT = NPT +1
         IF(NPT.GT.MAXPTS) THEN
           WRITE(IOUTVB,*)
     &      "TOO MANY POINTS ( > 1000) ON THE REACTION PATH"
           CALL ABORT0('REACTOR03 ')
         END IF
         INTDEX(1,NPT) = I
         INTDEX(2,NPT) = INTDEX(2,NPT-1)-1
         INTDEX(3,NPT) = I + 1
         INTDEX(4,NPT) = INTDEX(4,NPT-1)+1
         END DO
      END DO
      NPT = NPT + 1
      INTDEX(1,NPT) = NGEOMS
      INTDEX(2,NPT) = IPOINT+1
      INTDEX(3,NPT) = NGEOMS
      INTDEX(4,NPT) = 0
C
C     REACTION DRIVER
C
C     Create simple XYZ file
      REWIND(IOVBIN)
      CALL LOCTOR(IOVBIN,'$XYZFILE',8,IOK,0)
      IF(IOK.EQ.1) THEN
        IMOL=96
        LXYZ=.TRUE.
        INPFILE=FSTR(1:LENFIL)//'.xyz'
        OPEN(UNIT=IMOL,FILE=INPFILE,STATUS='UNKNOWN',
     1    ACCESS='SEQUENTIAL',FORM='FORMATTED')
        TITLE(1:27)='REACTOR RUN - POINT NUMBER '
        TITLE(30:40)='           '
      ENDIF
      REWIND(IOENGI)
      WRITE(IOUTVB,*)'IRESTART IN REACTOR=',IRESTART
      DO I=1, NPT
CGMS     IF (EXETYP.EQ.CHECK.AND.I.EQ.2) RETURN
         IPNT = I
         WRITE(IOUTVB,101) IPNT
 101     FORMAT(/,' REACTOR POINT: ',I2,/)
         IF(LXYZ) THEN
            I1=MOD(IPNT,10) + 1
            I2=(IPNT/10) + 1
            TITLE(28:28)=NUMBER(I2:I2)
            TITLE(29:29)=NUMBER(I1:I1)
         ENDIF
         IF(I.GT.1) IRESTART = 1
         NPT1=(INTDEX(1,I)-1)*NATOMS+1
         NPT2=NPT1 + NATOMS
         CALL INTGEOM(RPFXYZ(1,NPT1),RPFXYZ(1,NPT2),INTDEX(2,I),
     &               INTDEX(4,I),XYZTMP(1,1),NATOMS)
         CALL VBINPUT(IOVBIN,IOENGI,XYZTMP,NATNUM,NATOMS,IRESTART)
         DO K=1,NATOMS
            DO J=1,3
               C1(J,K)=XYZTMP(J,K)/0.529177249D0
            ENDDO
C           WRITE(IOUTVB,'(3X,3F15.7)') C1(1,K),C1(2,K),C1(3,K)
         ENDDO
         IF(LXYZ) THEN
            CALL XYZFILE(C1,NATOMS,NATNUM,TITLE)
         ENDIF
CGMS     IF(I.GT.1) CALL GAMINT()
         CALL VBENGINE(EPATH(I))
CGMS     VBENGY = EPATH(I)
         CLOSE(97)
      END DO
      IF(LXYZ) THEN
         CLOSE(IMOL)
         WRITE(IOUTVB,108)
      ENDIF
 108  FORMAT(/,
     &' CREATED MULTIPLE XYZ FILE OF MOLECULAR COORDINATES',/)
      WRITE(IOUTVB,1500)
      NGRP = (NPT+5)/6
      NEND = 0
      DO I=1, NGRP
         NST = NEND + 1
         NEND = NST + 5
         IF(NEND.GT.NPT) NEND=NPT
         WRITE(IOUTVB,1600)(J,J=NST,NEND)
         WRITE(IOUTVB,1700)(EPATH(J),J=NST,NEND)
      END DO
      EMAX = FINDMAX(EPATH,NPT)
      EMIN = FINDMIN(EPATH,NPT)
      DELTA = EMAX - EMIN
      WRITE(IOUTVB,*)
      SCALE = 50/DELTA
      DO I=1,NPT
         NSTAR = INT(SCALE*(EPATH(I)-EMIN))
         ESTAR = CBLNK
         ESTAR = CSTAR(1:NSTAR)
         WRITE(IOUTVB,1000)I,ESTAR
      END DO
      WRITE(IOUTVB,'(1X,/)')
      RETURN
 200  CALL ABORT0('REACTOR03 ')
      RETURN
 1000 FORMAT(2X,I5,'|',A50)
 1100 FORMAT(//1X,'          Chemical Reaction Calculation'/
     &       1X,'================================================')
 1200 FORMAT(1X,'Number of intermediate structures:      ',I5)
 1300 FORMAT(1X,'Number of LST points bewteen structures:',I5)
C1400 FORMAT(1X,'Read guess (Yes/No = 1/0):              ',I5//)
 1500 FORMAT(1X,'Energy profile')
 1600 FORMAT(1X,6I12)
 1700 FORMAT(1X,6F12.5)
      END
      DOUBLE PRECISION FUNCTION FINDMAX(A,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(*)
      FINDMAX = -1.0D+100
      DO I=1,N
      IF(FINDMAX.LT.A(I)) FINDMAX=A(I)
      END DO
      RETURN
      END
      DOUBLE PRECISION FUNCTION FINDMIN(A,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(*)
      FINDMIN = 1.0D+100
      DO I=1,N
      IF(FINDMIN.GT.A(I)) FINDMIN=A(I)
      END DO
      RETURN
      END
      SUBROUTINE ALIALL(XYZ,NATOMS,NGEOMS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION XYZ(3,*),WT(1000)
      DO I=1,NATOMS
      WT(I)=1.0D0
      END DO
      DO I=1,NGEOMS-1
      NA1=(I-1)*NATOMS+1
      NA2=NA1+NATOMS
      CALL ALITWO(XYZ(1,NA1),XYZ(1,NA2),NATOMS,WT)
      END DO
      RETURN
      END
C
C     KABSCH ALGORITHM FOR THE ALIGNMENT OF TWO RIGID STRUCTURES
C
      SUBROUTINE ALITWO(Y,X,NATOMS,WT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION X(3,*),Y(3,*),WT(*),R(3,3),S(3,3),RR(3,3),U(3,3)
      DIMENSION CX(3),CY(3),A(3,3),B(3,3),E(10)
      EPS = 1.0D-15
C
C     Reset origin to the center of sytems
C
      DO J=1,3
      CX(J)=0.0D0
      CY(J)=0.0D0
      END DO
      TWT=0.0D0
      DO I=1,NATOMS
        DO J=1,3
        CX(J)=CX(J)+X(J,I)*WT(I)
        CY(J)=CY(J)+Y(J,I)*WT(I)
        END DO
      TWT = TWT + WT(I)
      END DO
      DO I=1,3
      CX(I) = CX(I)/TWT
      CY(I) = CY(I)/TWT
      END DO
      DO I=1,NATOMS
         DO J=1,3
         X(J,I) = X(J,I) - CX(J)
         Y(J,I) = Y(J,I) - CY(J)
         END DO
      END DO
C
C     UX->Y, i.e. Transfer X to fit Y
C
      DO J=1,3
      DO K=1,3
      R(J,K)=0.0D0
      S(J,K)=0.0D0
      END DO
      END DO
C
C     Build R and S matrices
C
      DO I=1,NATOMS
         DO J=1,3
         DO K=1,3
         R(J,K)=R(J,K)+WT(I)*Y(J,I)*X(K,I)
         S(J,K)=S(J,K)+WT(I)*X(J,I)*X(K,I)
         END DO
         END DO
      END DO
C
C     Form RR matrix
C
      DO J=1,3
      DO K=1,3
         RR(J,K)=0.0D0
         DO I=1,3
         RR(J,K)=RR(J,K)+R(I,J)*R(I,K)
         END DO
      END DO
      END DO
      CALL DIAG(RR,A,E,3,3)
C
C     Inverse eigen vector order
C
C     i.e. E(1) <= E(2) <= E(3)
C
      TEMP = E(1)
      E(1) = E(3)
      E(3) = TEMP
      DO I=1,3
         TEMP   = A(I,1)
         A(I,1) = A(I,3)
         A(I,3) = TEMP
      END DO
C
C   CROSS PRODUCT: A3 = A1 x A2 (cross product), so that A1,A2,A3 form a
C   right-handed system
C
      A(1,3) = A(2,1)*A(3,2)-A(2,2)*A(3,1)
      A(2,3) = A(1,2)*A(3,1)-A(1,1)*A(3,2)
      A(3,3) = A(1,1)*A(2,2)-A(1,2)*A(2,1)

      DO K=1,3
        DO I=1,3
        B(I,K)=0.0D0
          DO J=1,3
          B(I,K)=B(I,K)+R(I,J)*A(J,K)
          END DO
        END DO
      END DO
C
C   NORMALIZATION
C
      IF(E(1).LT.EPS ) THEN
      B(1,1)=1.0D0
      B(2,1)=0.0D0
      B(3,1)=0.0D0
      B(1,2)=0.0D0
      B(2,2)=1.0D0
      B(3,2)=0.0D0
      B(1,3)=0.0D0
      B(2,3)=0.0D0
      B(3,3)=1.0D0
      ELSE IF (E(2).LT.EPS) THEN
C
C     ARBITARY VECTOR
C
      B(1,2)=1.0D0
      B(2,2)=3.14159D0
      B(3,2)=2.0D0
      SUM = 0.0D0
      DO I=1,3
      SUM = SUM + B(I,1)*B(I,1)
      END DO
      SCALE = 1.0D0/DSQRT(SUM)
      DO I=1,3
      B(I,1)=B(I,1)*SCALE
      END DO
      PROD = B(1,1)*B(1,2) + B(2,1)*B(2,2) + B(3,1)*B(3,2)
      B(1,2) = B(1,2) - PROD*B(1,1)
      B(2,2) = B(2,2) - PROD*B(2,1)
      B(3,2) = B(3,2) - PROD*B(3,1)
        SUM = 0.0D0
        DO I=1,3
        SUM = SUM + B(I,2)*B(I,2)
        END DO
        SCALE = 1.0D0/DSQRT(SUM)
        DO I=1,3
        B(I,2)=B(I,2)*SCALE
        END DO
      END IF
      DO K = 1,2
        SUM = 0.0D0
        DO I=1,3
        SUM = SUM + B(I,K)*B(I,K)
        END DO
        SCALE = 1.0D0/DSQRT(SUM)
        DO I=1,3
        B(I,K)=B(I,K)*SCALE
        END DO
      END DO
C
C   CROSS PRODUCT
C
      B(1,3) = B(2,1)*B(3,2)-B(2,2)*B(3,1)
      B(2,3) = B(1,2)*B(3,1)-B(1,1)*B(3,2)
      B(3,3) = B(1,1)*B(2,2)-B(1,2)*B(2,1)
C
C   U = BA
C
      DO I=1,3
      DO J=1,3
      U(I,J)=0.0D0
      END DO
      END DO
      DO K=1,3
        DO I=1,3
        DO J=1,3
        U(I,J)=U(I,J)+B(I,K)*A(J,K)
        END DO
        END DO
      END DO
C
C     X = UX
C
      DO I = 1, NATOMS
         TEMPX=0.0D0
         DO J=1,3
         TEMPX = TEMPX + U(1,J)*X(J,I)
         END DO
         TEMPY=0.0D0
         DO J=1,3
         TEMPY = TEMPY + U(2,J)*X(J,I)
         END DO
         TEMPZ=0.0D0
         DO J=1,3
         TEMPZ = TEMPZ + U(3,J)*X(J,I)
         END DO
         X(1,I)=TEMPX
         X(2,I)=TEMPY
         X(3,I)=TEMPZ
      END DO
C
C     WRITE X
C
C     WRITE(IOUTVB,*)'TRANSFORERED XYZ'
C     SUMT = 0.0D0
C     DO J=1,NATOMS
C     WRITE(IOUTVB,*)(X(I,J),I=1,3)
C        DO I=1,3
C        END DO
C     END DO
      RETURN
      END
C
C     FIND THE U MATRIX FOR THE ROTATION, AND KEEP Y, X UNCHANGED
C
      SUBROUTINE FITROT(YY,XX,NATOMS,WT,U)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION XX(3,*),YY(3,*),WT(*),R(3,3),S(3,3),RR(3,3),U(3,3)
      DIMENSION CX(3),CY(3),A(3,3),B(3,3),E(10)
      DIMENSION X(3,100),Y(3,100)
      EPS = 1.0D-15
      DO I=1, NATOMS
        DO J=1,3
        X(J,I) = XX(J,I)
        Y(J,I) = YY(J,I)
        END DO
      END DO
C
C     Reset origin to the center of sytems
C
      DO J=1,3
      CX(J)=0.0D0
      CY(J)=0.0D0
      END DO
      TWT=0.0D0
      DO I=1,NATOMS
        DO J=1,3
        CX(J)=CX(J)+X(J,I)*WT(I)
        CY(J)=CY(J)+Y(J,I)*WT(I)
        END DO
      TWT = TWT + WT(I)
      END DO
      DO I=1,3
      CX(I) = CX(I)/TWT
      CY(I) = CY(I)/TWT
      END DO
      DO I=1,NATOMS
         DO J=1,3
         X(J,I) = X(J,I) - CX(J)
         Y(J,I) = Y(J,I) - CY(J)
         END DO
      END DO
C
C     UX->Y, i.e. Transfer X to fit Y
C
      DO J=1,3
      DO K=1,3
      R(J,K)=0.0D0
      S(J,K)=0.0D0
      END DO
      END DO
C
C     Build R and S matrices
C
      DO I=1,NATOMS
         DO J=1,3
         DO K=1,3
         R(J,K)=R(J,K)+WT(I)*Y(J,I)*X(K,I)
         S(J,K)=S(J,K)+WT(I)*X(J,I)*X(K,I)
         END DO
         END DO
      END DO
C
C     Form RR matrix
C
      DO J=1,3
      DO K=1,3
         RR(J,K)=0.0D0
         DO I=1,3
         RR(J,K)=RR(J,K)+R(I,J)*R(I,K)
         END DO
      END DO
      END DO
      CALL DIAG(RR,A,E,3,3)
C
C     Inverse eigen vector order
C
C     i.e. E(1) <= E(2) <= E(3)
C
      TEMP = E(1)
      E(1) = E(3)
      E(3) = TEMP
      DO I=1,3
         TEMP   = A(I,1)
         A(I,1) = A(I,3)
         A(I,3) = TEMP
      END DO
C
C   CROSS PRODUCT: A3 = A1 x A2 (cross product), so that A1,A2,A3 for a
C   right-handed system
C
      A(1,3) = A(2,1)*A(3,2)-A(2,2)*A(3,1)
      A(2,3) = A(1,2)*A(3,1)-A(1,1)*A(3,2)
      A(3,3) = A(1,1)*A(2,2)-A(1,2)*A(2,1)

      DO K=1,3
        DO I=1,3
        B(I,K)=0.0D0
          DO J=1,3
          B(I,K)=B(I,K)+R(I,J)*A(J,K)
          END DO
        END DO
      END DO
C
C   NORMALIZATION
C
      IF(E(1).LT.EPS ) THEN
      B(1,1)=1.0D0
      B(2,1)=0.0D0
      B(3,1)=0.0D0
      B(1,2)=0.0D0
      B(2,2)=1.0D0
      B(3,2)=0.0D0
      B(1,3)=0.0D0
      B(2,3)=0.0D0
      B(3,3)=1.0D0
      ELSE IF (E(2).LT.EPS) THEN
C
C     ARBITARY VECTOR
C
      B(1,2)=1.0D0
      B(2,2)=3.14159D0
      B(3,2)=2.0D0
      SUM = 0.0D0
      DO I=1,3
      SUM = SUM + B(I,1)*B(I,1)
      END DO
      SCALE = 1.0D0/DSQRT(SUM)
      DO I=1,3
      B(I,1)=B(I,1)*SCALE
      END DO
      PROD = B(1,1)*B(1,2) + B(2,1)*B(2,2) + B(3,1)*B(3,2)
      B(1,2) = B(1,2) - PROD*B(1,1)
      B(2,2) = B(2,2) - PROD*B(2,1)
      B(3,2) = B(3,2) - PROD*B(3,1)
        SUM = 0.0D0
        DO I=1,3
        SUM = SUM + B(I,2)*B(I,2)
        END DO
        SCALE = 1.0D0/DSQRT(SUM)
        DO I=1,3
        B(I,2)=B(I,2)*SCALE
        END DO
      END IF
      DO K = 1,2
        SUM = 0.0D0
        DO I=1,3
        SUM = SUM + B(I,K)*B(I,K)
        END DO
        SCALE = 1.0D0/DSQRT(SUM)
        DO I=1,3
        B(I,K)=B(I,K)*SCALE
        END DO
      END DO
C
C   CROSS PRODUCT
C
      B(1,3) = B(2,1)*B(3,2)-B(2,2)*B(3,1)
      B(2,3) = B(1,2)*B(3,1)-B(1,1)*B(3,2)
      B(3,3) = B(1,1)*B(2,2)-B(1,2)*B(2,1)
C
C   U = BA
C
      DO I=1,3
      DO J=1,3
      U(I,J)=0.0D0
      END DO
      END DO
      DO K=1,3
        DO I=1,3
        DO J=1,3
        U(I,J)=U(I,J)+B(I,K)*A(J,K)
        END DO
        END DO
      END DO
C
      RETURN
      END
      SUBROUTINE INTGEOM(XYZ1,XYZ2,IWT1,IWT2,XYZTMP,NATOMS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION XYZ1(3,*),XYZ2(3,*),XYZTMP(3,*)
      RATIO = DFLOAT(IWT1)/DFLOAT(IWT1+IWT2)
      DO I = 1, NATOMS
         DO J=1,3
         XYZTMP(J,I) = XYZ1(J,I)*RATIO + XYZ2(J,I)*(1.0D0-RATIO)
         END DO
      END DO
      RETURN
      END
C000  SUBROUTINE VBENGINE(ETOTAL)
CSMI  SUBROUTINE VBENGINE(ETOTAL)
CGMS  SUBROUTINE VBENGINE(ETOTAL)
CGAU  SUBROUTINE VBENGINE(RWRK,ETOTAL)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     MAIN PROGRAM FOR PERFORMING VALENCE BOND CALCULATIONS USING ALGEBRANT
C     ALGORITHM AND GENERALIZED PRODUCTION FUNCTION METHOD
C
C     NOTES:
C           THIS CAN BE USED AS A STAND ALONE PROGRAM. THE CORE OF VB2000
C           CAN ALSO BE USED AS A PLUG-IN FOR ANY ELECTRONIC STRUCTURE
C           PROGRAM WITH MINIMAL PROGRAMMING EFFORTS (TO PROVIDE INTERFACE
C           TO INTEGRALS AND HF ROUTINES).
C
C           TO RUN VB2000 IN A THIRD PARTY ELECTRONIC STRUCTURE PROGRAM,
C           ONE SHOULD PROVIDE THE CORRESPONDING INTERFACE ROUTINES
C           TO READ INTEGRALS, HARTREE-FOCK MOLECULAR ORBITALS, AND
C           THE BASIS SET INFORMATION.
C
C           THE CURRENT VERSION IS DESIGNED TO BE ABLE TO INTERFACE GAUSSIAN,
C           GAMESS, AND THE IN-HOUSE PROGRAM. TO CONNECT VB2000 WITH
C           A PARTICULAR PROGRAM, ONE NEEDS ACTIVE THE CORRESPONDING COMMENTED
C           STATEMENTS BEFORE COMPILE THE SOURCE CODE.
C
C     CODES:
C           C000: CONNECT ITSELF   (I.E. AS A STAND ALONE PROGRAM)
C           CGAU: CONNECT GAUSSIAN (INBEDDED INTO GAUSSSIAN AS NEW
C                                   LINK - L511)
C           CGMS: CONNECT GAMESS   (INBEDDED INTO GAMESS(US))
C           CSMI: CONNECT SMILES   (CONNECT TO SMILES INTEGRAL)
C
C     AUTHOR:
C
C           JIABO LI
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
CSTA  INCLUDE 'maxwork.inc'
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
CGAU  DIMENSION RWRK(*)
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
     &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
     &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
C     COMMON /IAA/IA(100000)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /VB2MEM/LOCX,LOCMEM,LOFFS,MEMWRK,MSCRATCH,MHIGH
CSTA  COMMON /GENWRK/G(MAXWK)
CDYN  COMMON /GENWRK/G(1)
C   GAU  COMMON /g98mem/MAXMEM
C     Note that /GENWRK/ is only used by standalone VB2000 in this
C     routine.
C000  DIMENSION E(5000)
      CHARACTER*64 SOURCEDAT
      KEY(99)=0
      MAXWRK = 6500000
CSTA  MAXWRK = MAXWK
CDYN  MAXWRK = MEMWRK
CDYN  WRITE(IOUTVB,'(" MAXIMUM DYNAMIC MEMORY IS: ",I14,/)') MAXWRK
C  GAU  CALL GETSCM(-1,RWRK,MAXMEM,'VB2000',0)
CGAU  MAXWRK=MAXMEM
CGAU  WRITE(IOUTVB,'(" MAXIMUM DYNAMIC MEMORY IS: ",I14,/)') MAXWRK
      IFLAG = 0
C000  IFLAG = 1
CSMI  IFLAG = 1
      CALL PRECALC(ICHARGE,MULTI,SOURCEDAT,IFLAG)
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL GETIOUNIT('IAO2E   ',IAO2E)
      CALL GETIOUNIT('IOHFORB ',IOHFORB)
      REWIND(IAO2E)
      IF(IFLAG.EQ.1) THEN
        NE=0
C000    CALL CALCINT(SOURCEDAT,ENREP,NBASIS,NATOM,NE,0)
CSMI    CALL SMIINT(NE)
C
C     COPY DATA TO GENINF
C
        NELE =NE - ICHARGE
        NSPIN=MULTI-1
C       NUM2 =NBASIS*(NBASIS+1)/2
        NFIRST = 1
CDYN    NFIRST = LOFFS
CGMS    NFIRST = LOFFS
        NSS  = NFIRST
        NHH  = NSS+NBASIS*NBASIS
        NVV  = NHH+NBASIS*NBASIS
        NFF  = NVV+NBASIS*NBASIS
        NPP  = NFF+NBASIS*NBASIS
        NPW  = NPP+NBASIS*NBASIS
        NWW  = NPW+NBASIS*NBASIS
        NEND = NWW+NBASIS*NBASIS*3
        MHIGH = MAX(MHIGH,NEND-NFIRST)
C       WRITE(IOUTVB,'(" MHIGH",2I12)') 2,MHIGH
C000    CALL RHND1E(IAO1E,G(NSS),G(NHH))
CSMI    CALL RSMI1E(G(NSS),G(NHH),NBASIS)
        IF(NEND-NFIRST.GE.MAXWRK) THEN
          WRITE(IOUTVB,*)"SCRATCH SPACE IS TOO SMALL"
          CALL ABORT0('VBENGINE01')
        END IF
C000    IF(IPNT.LE.1)
C000 &  CALL HFSCF(NELE,NSPIN,G(NSS),G(NHH),G(NVV),G(NFF),
C000 &  G(NPP),G(NPW),G(NWW),NBASIS,IOHFORB,128,ENERGY,ENREP,E,BFLABE)
CSMI    IF(IPNT.LE.1)
CSMI &  CALL HFSCF(NELE,NSPIN,G(NSS),G(NHH),G(NVV),G(NFF),
CSMI &  G(NPP),G(NPW),G(NWW),NBASIS,IOHFORB,128,ENERGY,ENREP,E,BFLABE)
C000    ETOTAL = ENERGY
CSMI    ETOTAL = ENERGY
      END IF
C
C     Possible initialization of a Post-HF solvation calculation
C
C000  CALL ALGEBRANT(ETOTAL)
CGMS  CALL ALGEBRANT(ETOTAL)
CGAU  CALL ALGEBRANT(RWRK,ETOTAL,MAXMEM)
CSMI  CALL ALGEBRANT(ETOTAL)
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     CORE OF VB2000
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     FUNCTION: TOP LEVEL ROUTINE OF VB2000
C
C
C     TIME TABLE FOR VB2000
C     =====================
C
C     1) XIAMEN UNIVERSITY, XIAMEN, CHINA                   (1991-1992)
C     2) INSTITUTE FOR MOLECULAR SCIENCE, OKAZAKI, JAPAN    (1992-1993)
C     3) UNIVERSITY OF ERLANGEN-NURNBERG, ERLANGEN, GERMANY (1993-1995)
C     4) COLUMBIA UNIVIERSITY, NEW YORK, NY, USA            (1995-1996)
C     5) UNIVERSITY OF MINNESOTA, MINNEAPOLIS, MN, USA      (1996-1999)
C     6) SAN DIEGO, CA, USA                                 (1999-    )
C
C
C     BRIEF HISTORY
C     =============
C
C     THE VERY EARLY IDEA FOR DEVELOPOING A NEW APPROCH TO NONORTHOGONALITY
C     PROBLEM OF MODERN VB CALCULATION WAS CREATED WHEN THE AUTHOR WAS A
C     POSTDOC WITH PROF. QIANER ZHANG. THE ORIGINAL MOTIVATION WAS TO
C     DEVELOP A VB PROGRAM TO STUDY ANDERSON'S RVB THEORY OF HIGH-TC
C     SUPERCONDUCTIVITY. SOON THE AUTHOR WAS CONVINCED THAT THE N! PROBLEM
C     IN MODERN VB CALCULATION WAS MORE DIFFICULT THAN HE COULD HANDEL, LET
C     ALONE THE HIGH-TC SUPERCONDUCTIVITY THEORIES.
C
C     WITHOUT MAKING MUCH PROGRESS IN HIGH-TC THEORIES, THE AUTHOR PROPOSED
C     THE PERMANENT METHOD FOR NONORTHOGOANL VB CALCULATIONS WITH THE HELP
C     OF DR. WEI WU. THE PERMANENT METHOD WAS EXTENSIVELY DEVELOPED DURING
C     THE AUTHOR'S VISITS TO PROF. MOROKUMA AND PROF. LADIK'S LABS. THE
C     SUPER-CI METHOD WAS ALSO IMPLEMENTED FOR OPTIMIZATION OF VB ORBITALS.
C     THE PRIMITIVE IDEA OF ALGEBRANT ALGORITHM WAS FORMED.
C
C     THE COLABORATION BETWEEN PROF. RUBEN PAUNCZ AND THE AUTHOR WAS
C     ESTABLISHED SOON AFTER A FEW E-MAIL CORESPONDANCES NEAR THE END OF 1994.
C     THE COLABORATION LED TO THE FORMAL FORMULATION OF THE ALGEBRANT
C     ALGORITHM. HOWEVER, THE AUTHOR'S MAJOR RESEARCH EFFORT WAS TURNED TO
C     MOLECULAR SIMULATIONS FROM 1996, AND THE NEWLY FORMED ALGORITHM WAS
C     NOT IMPLEMENTED UNTIL THE WINTER OF 1997 WHEN THE AUTHOR WAS VERY
C     INSPIRED BY PROF. ROY MCWEENY'S GROUP FUNCTION METHOD. A VERY CLOSE
C     COLLABORATION HAS BEEN ESTABLISHED BETWEEN ROY AND THE AUTHOR. TO ADOPT
C     MCWEENY'S GROUP FUNCTION METHOD AND DEVELOP A MUCH MORE ROBUST VB
C     PROGRAM, AN AGRESSIVE APPROACH WAS TAKEN: THE ORIGINAL VERSION OF VB
C     PROGRAM WAS COMPLETELY THROWN WAY, AND A COMPLETELY NEW VERSION WAS
C     BUILT FROM SCRATCH. THE NEWTON-RAPHSON METHOD WAS IMPLEMENTED FOR
C     VB ORBITAL OPTIMIZATION, AND MCWEENY'S GROUP-BY-GROUP OPTIMIZATION
C     METHOD WAS ALSO IMPLEMENTED IN MULTI-GROUP FUNCTION APPROACH.
C
C     UNFORTUNATELY, IT WAS SOON FOUND THAT THE GROUP-BY-GROUP METHOD FOR
C     OPTIMIZING A GENERALIZED PRODUCT FUNCTION DIDN'T WORK CORRECTLY
C     BECAUSE IT LACKED SOME DEGREES OF FREEDOM IN OPTIMIZATION. THE
C     SO-CALLED RIGID-ROTATION METHOD WAS FOUND AND IMPLEMENTED.
C
C     IN THE MIDDLE OF JUNE 1999, THE AUTHOR ACCEPTED A INDUSTRIAL POSITION
C     IN MOLECULAR SIMULATIONS AND MOVED TO SAN DIEGO. WHILE ENJOYING THE
C     SUNNY WEATHER OF SAN DIEGO, THE AUTHOR DECIDED TO REWRITE THE PROGRAM WITH
C     COMMERCIAL QUALITY. THE RIGID-ROTATION ALGORITHM WAS RE-DESIGNED AND
C     RE-CODED, AND A MUCH MORE MATURE ALGEBRANT ALGORITHM WAS DEVELOPED AND
C     IMPLEMENTED.
C
C     IT TURNS OUT THAT THE NEWEST VERSION IS ABOUT 1 TO 2 ORDERS OF MAGNITUDE
C     MORE EFFICIENT.
C
C     VB2000 IS STILL PUSHING THE BOUNDARY OF VB CALCULATIONS....
C
C
C     AKNOWLEDGEMENTS
C     ===============
C
C     SPECIAL THANKS ARE DUE TO:
C
C     DR. WEI WU,
C     FOR THE COLLABORATION ON THE THEORETICAL DEVELOPMENTS OF THE NEW
C     ALGORITHMS FOR VB CALCULATIONS DURING AUTHOR'S STAY IN XIAMEN.
C     THE PERMANENT ALGORITHM WAS FORMULATED AND IMPLEMENTED.
C
C     PROF. KEIJI MOROKUMA
C     FOR HIS SUPPORT DURING THE AUTHOR'S STAY AT THE INSTITUTE FOR MOLECULAR
C     SCIENCE, OKAZAKI, JAPAN.
C
C     PROF. JANOS LADIK
C     FOR HIS STRONG SUPPORT ON THIS WORK DURING THE AUTHOR'S STAY IN ERLANGEN
C     A QUITE SOPHISTICATED VB PROGRAM WITH CAPABILITY OF ORBITAL OPTIMIZATION
C     WAS DEVELOPED. THE IDEA OF USING ALGEBRANT ALGORITHM WAS PRACTISED
C     DURING THIS PERIOD
C
C     PROF. RUBEN PAUNCZ
C     FOR HIS STRONG SPIRITUAL SUPPORT AND THE COLLABORATION ON THE
C     LATESTED DEVELOPMENT ON THE ALGEBRANT ALGORITHM.
C
C     DR. DAVID L. COOPER
C     FOR BRINGING THE AUTHOR'S ATTENTION TO PIPEK-MEZEY LOCALIZATION METHOD,
C     WHICH IS A CRITICAL TECHNIQUE USED IN VB2000.
C
C     PROF. MARCO ZAIDER
C     FOR HIS STRONG INTERESTS AND SUPPORT ON THIS RESEARCH DURING THE AUTHOR'S
C     STAY AT COLUMBIA UNIVERSITY. THE ALGEBRANT ALGORITHM WAS EXPLICITLY
C     FORMULATED WITH THE COLLABORATION OF PROF. RUBEN PAUNCZ IN THIS TIME
C     FRAME.
C
C     PROF. ROY MCWEENY
C     FOR THE LONG-TIME COLLABORATION ON THE THEORETICAL DEVELOPMENTS AS WELL
C     AS THE IMPLEMENTATION OF VB METHODS AND THE SEPARABILITY THEORY.
C
C     PROF. CHRISTOPHER J. CRAMER, AND PROF. DONALD G. TRUHLAR
C     FOR THEIR DEEP INSIGHTS IN COMPUTATIONAL CHEMISTRY AND ENGENEERING IDEAS.
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C000  SUBROUTINE ALGEBRANT(ETOTAL)
CSMI  SUBROUTINE ALGEBRANT(ETOTAL)
CGMS  SUBROUTINE ALGEBRANT(ETOTAL)
CGAU  SUBROUTINE ALGEBRANT(RWRK,ETOTAL,MAXMEM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
CSTA  INCLUDE 'maxwork.inc'
CGAU  PARAMETER (MAXATM=20000)
CGAU  DIMENSION RWRK(*)
CGMS  LOGICAL NUMGR2
      LOGICAL LGR,GGDONE,LCOULRD
C     CHARACTER*80 VBPAT,FILE2
C     CHARACTER*1 SPACE
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*8 BONDLAB
C
C     DIMENSION IOPER(1000),VT(1000)
C
C  GAU  Common /Mol/ NAtoms,ICharg,Multip,NAE,NBE,NE,NBTEMP,IAn(MaxAtm),
C  GAU $  NBsUse,AtmChg(MaxAtm),C(3,MaxAtm),IAtTyp(MaxAtm),iatChMM(MaxAtm)
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
     &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
     &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
      COMMON /VB2MEM/LOCX,LOCMEM,LOFFS,MEMWRK,MSCRATCH,MHIGH
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /DPENAL/DPW,DEPS,DPWMAX,DENERGY,NITER,MAXMICRO
CSTA  COMMON /GENWRK/RWRK(MAXWK)
CDYN  COMMON /GENWRK/RWRK(1)
CGMS  COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
CGMS  COMMON /GENWRK/RWRK(1)
CGMS  COMMON /GMSODD/ MSTEP,NUMGR2
      COMMON /LTAB/NTYPE,MAPINCORE,MEL,MSP,LOOKTB(6,100),NGRECD(4,100)
      COMMON /AGCODE/NPK1,NPK2,NPK3
      COMMON /INVERS/OVM(129)
      COMMON /LMODAT/VMO(500000),VLMO(500000),LMOLAB(2,1000),
     &LMOATM(5,1000),PGM(100000),ENGLMO(1000),BONDLAB(1000),MCLMO(5,80),
     &LHFLAG
      COMMON /GBCNTL/EDIELE,ETGAS,DAMP,SOLN,SOLA,SOLB,SOLG,SOLC,SOLH,
     &               ISOL,ISCRF,ICMD,ICDS,IAQU,IDOSOL,ICSAVE,ICREAD,
     &               ISREAD,IGAS,LGR,GGDONE,LCOULRD
C
C     /GENINF/: Common block holding general information. For more detail,
C               see the input subroutine INPUTVB.
C     /GENCTL/: General control information is stored here. Also see INPUTVB.
C
C     /GENWRK/: General work space. Replaced by /FMCOM/ in Gamess version,
C               and by a DIMENSION statement for RWRK in Gaussian version.
C        RWRK : Work space for rotation algorithm. The following variables are
C               are stored in this work space:
C               BASNAO: Nonorthogonal orbitals of all subunits in AO basis.
C                       The starting address for BASNAO in the work space is
C                       NAOBAS, and the size is NBasis*NBasis
C               BASLAO: Lowdin orbitals (Lowdin orthogonalized version of
C                       BASNAO in AO basis. The starting address is LAOBAS.
C                       Size = NBasis*NBasis. This part can be used for
C                       other purpose.
C               BASNOC: Local nonorthogonal orbitals in Lowdin basis.
C                       Address: NOCBAS.
C                       Size = SUM MLorbit(I)*MLorbit(I) (I=1,2,...NSUB)
C                       where MLorbit(I) is the dimension of I-th subunit.
C                       The relative addresses for NSUB units are
C                       NB2ADD(I). (I=1,2,.....NSUB).
C               BASLOC: Lowdin orbitals in local nonorthogonal orbitals.
C                       Address: LOCBAS. The same size and the relative
C                       addresses as BASNOC.
C               DM1NON: First order density matrices in local basis BASNOC.
C                       Starting address: ND1STA. The relative addresses
C                       for all subunits: ND1ADD(I). (I=1,2,...NSUB).
C               DM2NON: Second order density matrices in local nonorthogonal
C                       basis BASNOC. The starting address is ND2STA. The
C                       relative addresses for all subunits are: ND2ADD(I).
C               DM1LOW: First order density matrices in local Lowdin basis
C                       BASLOC. The starting address is LD1STA. The relative
C                       addresses are ND1ADD(I) (I=1,2,....NSUB).
C               DM2LOW: Second order density matrices in Lowdin basis.
C                       The starting address is LD2STA. The relative addresses
C                       are ND2ADD(I).
C               LGDMP:  The starting address for scratch.
C
C     LOGICAL  Done
C
C     TESTING
C
C     DIMENSION R3D(3,3),ORBOUT(10000),XYZNEW(3,100)
C     DATA SPACE/' '/
CGMS  DATA CHECK  /8HCHECK   /
C
C
C     FOR HF METHOD (MTHEORY=1), RETURN HERE
C     POSTPONE THIS TO ALLOW CALL OF VISUAL
C     IF(MTHEORY.EQ.1) RETURN
C
      MEL=0
      MSP=0
      ETOLD=0.0D0
      DPW    = 0.0D0
      DPWMAX = 0.0D0
C
C     SET CODING PARAMETERS
C
      NPK1=64
      NPK2=NPK1*NPK1
      NPK3=NPK2*NPK1
      DO I=-64,64
      IF(I.NE.0) OVM(I+65)=1.0D0/I
      END DO
      IF (MTHEORY .EQ. 1) GOTO 998
C
C     SETUP BINORMIAL COEFFICINETS USING YANG HUI'S METHOD
C     YANG-HUI: AN ANCIENT CHINESE MATHEMATICIAN
C
      CALL YANGHUI()
C
C     SET UP A UNIVERAL TABLE FOR COMPUTING INDEXES OF ELEMENTS OF
C     AN N-DIMENSIONAL SYMMETRIC MATRIX.
C
      TIME1=XCLOCK()
      CALL SETABL()
C     TIME1=XCLOCK()-TIME1
C     WRITE(IOUTVB,*)'TIME FOR SETABLE=',TIME1
      TIME0=XCLOCK()
 998  CONTINUE
C
      NFIRST = 1
CDYN  NFIRST = LOFFS
CGMS  NFIRST = LOFFS
C
CGAU  MSIZE1 = MAXMEM
CSTA  MSIZE1 = MAXWK
CDYN  MSIZE1 = MEMWRK
CGMS  MSIZE1 = MEMWRK
      CALL GETIOUNIT('IOVBORB ',IOVBORB)
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      REWIND(IOVBORB)
C
C     WRITE(IOUTVB,*)'NFIRST =',NFIRST
      CALL INPUTVB(RWRK(NFIRST),MSIZE1)
      IF(LTEST.EQ.1) THEN
        CALL VISUAL(VLMO,ETOTAL)
        WRITE(IOUTVB,'(A23,/)') ' TEST RUN ONLY - ENDING'
        ETOTAL = 1.0D0
CGMS    CALL ENDGMS
        RETURN
      ENDIF
      IF(IRESTART.LT.0 .AND. MTHEORY .NE. 1) RETURN
      EPS=10.0D0**(-NEPS)
      DEPS   = EPS
      TIME1  = XCLOCK()
      LWRK1  = LGDMP+NBASIS*(NBASIS+1)/2
      LWRK2  = LWRK1+NBASIS*NBASIS
      LWRK3  = LWRK2+NBASIS*(NBASIS+1)
      MSIZE2 = MSIZE1 - LWRK2 + 1
      MSIZE3 = MSIZE1 - LGDMP + 1
      MSIZE4 = MSIZE1 - LWRK3 + 1
      MHIGH = MAX(MHIGH,LWRK3-1)
C     WRITE(IOUTVB,'(" MHIGH",2I12)') 3,MHIGH
C
C     Estimate the scratch space needed for the computation
C
      CALL COMPSIZE(NWNEED)
      IF(NWNEED.GT.MSIZE1) THEN
         WRITE(IOUTVB,101) NWNEED
 101     FORMAT(' INSUFFICIENT MEMORY - NWNEED =',I16)
CGMS     IF (EXETYP.EQ.CHECK) THEN
CGMS       WRITE(IOUTVB,'("YOU NEED AT LEAST ",I8)') NWNEED
CGMS     ELSE
           CALL ABORT0('ALGEBRANT0')
CGMS     ENDIF
      ENDIF
CGMS  IF (EXETYP.EQ.CHECK) THEN
CGMS    WRITE(IOUTVB,'(//," MEMORY NEEDED: ",I11)') NWNEED
CGMS    WRITE(IOUTVB,'(" MEMORY ALLOCATED: ",I8,/)') MSIZE1
CGMS    RETURN
CGMS  ENDIF

C
      IF(MSIZE4.LE.0) CALL ABORT0('ALGEBRANT1')
C
C     ADD OFFSET TO ADDRESS
C
      IF(MTHEORY.EQ.1) GOTO 999
      LNAOBAS = NAOBAS + NFIRST - 1
      LLAOBAS = LAOBAS + NFIRST - 1
      LND1STA = ND1STA + NFIRST - 1
      LND2STA = ND2STA + NFIRST - 1
      LLGDMP  = LGDMP  + NFIRST - 1
      LLWRK1  = LWRK1  + NFIRST - 1
      LLWRK2  = LWRK2  + NFIRST - 1
C     PERFORM MACRO ITERATIONS
C
      LASTITER = 0
      DO MITER1=1,IMACRO
      MITER = MITER1
      IF(MITER.EQ.IMACRO) LASTITER=1
C
C     PERFORM DIVIDE-AND-CONQUER
C
      CALL VBOSYM(NBASIS,RWRK(LNAOBAS))
      CALL DVDCON(MITER,RWRK(LNAOBAS),RWRK(LLAOBAS),RWRK(LND1STA),
     & RWRK(LND2STA),RWRK(LLGDMP),RWRK(LLWRK1),RWRK(LLWRK2),MSIZE2,
     & ENREP,ETOTAL,LASTITER)
C
C     RIGID ROTATION
C
      CALL ROTRAN(RWRK(NFIRST),RWRK(LLGDMP),MSIZE3,ETOTAL,MITER)
      CALL VBOSYM(NBASIS,RWRK(LNAOBAS))
      EDIFF=ETOTAL-ETOLD
      WRITE(IOUTVB,1000)MITER,ETOTAL,EDIFF
      ETOLD=ETOTAL
      DENERGY = ABS(EDIFF)
C
C     ADD POSSIBLE SCRF TO VB CALCULATION
C
CGMS  ISOL=0
CGMS  CALL VBSCRF(NBASIS,NSUB,MLORBIT,RWRK(NFIRST),ETOTAL)
CGMS  CALL FLSHBF(IOUTVB)
      IF(LASTITER.EQ.1) GOTO 100
      ABSDIF = DABS(EDIFF)
      IF(DABS(EDIFF).LT.EPS.AND.DPW.GE.DPWMAX) LASTITER=1
      END DO
  100 CONTINUE
      IF(ABSDIF.GT.EPS) WRITE(IOUTVB,1599)ABSDIF,EPS
      IF(DPW.LT.DPWMAX) WRITE(IOUTVB,1600)DPW
 1599 FORMAT(//' ********** MACRO ITERATION IS NOT FULLY CONVERGED. ',
     &      '********** '//,
     &       ' ENERGY DIFF =',F14.10,', ENERGY THREHSOLD =',F14.10//)
 1600 FORMAT(' NOT CONVERGED WITH FULL DPW. THE CURRENT DPW = ',F15.5)
CGMS  CALL PRTVBSOL()
C
C     PROPERTIES OF WAVE FUNCTION
C
C     PRINT CHARGE DISTRIBUTION OF EACH GROUP
C     IF(ICHARPT == 1)
C
      ICHAPRT = 0
      CALL LOCTOR(IOENGI,'$CHAPRT',7,IOK,0)
      IF(IOK.EQ.1) ICHAPRT = 1
      CALL VBPOPL(NSUB,MLORBIT,RWRK(NFIRST),ICHAPRT,MSIZE1)
CGAU  CALL VBPROP(NBASIS,NSUB,MLORBIT,RWRK(NFIRST))
CGMS  CALL VBDENS(NBASIS,NSUB,MLORBIT,RWRK(NFIRST),LWRK2)
C
C     SOLVATION
C
C     CALL VBPROP(NBASIS,NSUB,MLORBIT,RWRK(NFIRST))
C
C     READ BASIS
C
      REWIND(IOVBORB)
      READ(IOVBORB)
C     READ(IOVBORB)IJUNK,IJUNK,NORBX
      READ(IOVBORB)I,I,NORBX
C     I is not used.
      READ(IOVBORB)(RWRK(LNAOBAS-1+I),I=1,NBASIS*NORBX)
C
C     PRINT ORBITALS IN GLOBAL AO BASIS
C
      NOCB=NB1ADD(NSUB+1)-1
      NPRT=(NOCB+5)/6
      WRITE(IOUTVB,1700)
      NFIST=1
      DO I=1,NPRT
      NLAST=NFIST+5
      IF(NLAST.GT.NOCB) NLAST=NOCB
      WRITE(IOUTVB,1800)(K,K=NFIST,NLAST)
      WRITE(IOUTVB,1810)(IBASIS(K),K=NFIST,NLAST)
      WRITE(IOUTVB,1850)
      DO J=1,NBASIS
      WRITE(IOUTVB,1900)J,BFLABE(J),(RWRK(LNAOBAS-1+J+(K-1)*NBASIS),
     &                                         K=NFIST,NLAST)
      END DO
      WRITE(IOUTVB,*)
      NFIST=NLAST+1
      END DO
C
C     FOR GAMESS ONLY CORRECT AND STORE MO's
CGMS  CALL GMSMOS(RWRK(LNAOBAS),RWRK(LLAOBAS),NBASIS,NOCB)
C
      IF (IPNT.EQ.0) CALL VISUAL(RWRK(LNAOBAS),ETOTAL)
C
C     CALL VBOLGN: An utility for generation VBO library
C
      CALL VBOLGN(NATOM,NBASIS,NATNUM,XYZ,NATBAS,BFLABE,RWRK(LNAOBAS),
     &            IOENGI)
C
C     CALCULATE CENTROIDS OF CHARGE
CGMS  NBA2=(NBASIS*NBASIS + NBASIS)/2
C     REORGANIZE MEMORY USE
CGMS  MEM1 = LNAOBAS
CGMS  MEM2 = MEM1 + NBASIS*NOCB
CGMS  MEM3 = MEM2 + NBA2
CGMS  MEM4 = MEM3 + 9*NBA2 + 9*784
CGMS  MEM5 = MEM4 + 3*NOCB
CGMS  MEM6 = MEM5 + 3*NOCB
CGMS  MSIZE=MSIZE1-(MEM6-NFIRST+1)
CGMS  IF(MSIZE.LE.0) THEN
CGMS     WRITE(IOUTVB,1050) MEM6
CGMS     CALL ABORT0('ALGEBRANT2')
CGMS  ENDIF
CGMS  MHIGH = MAX(MHIGH, MEM6-NFIRST+1)
C
CGMS  IF (IPNT.GT.1) GOTO 999
CGMS  IF (MSTEP.EQ.1.OR.IPNT.EQ.1)
CGMS 1CALL CENTROID(RWRK(MEM1),RWRK(MEM2),RWRK(MEM3),RWRK(MEM4)
CGMS 2,RWRK(MEM5),NBASIS,NBA2,NOCB)
C
 999  CONTINUE
C     OUTPUT DATA FOR VISUALISATION PROGRAMS
C
C1701 FORMAT(1X,A7,2I12)
C
 1700 FORMAT(/
     &' ORBITALS OF EACH ELECTRON GROUP IN AO BASIS: ORBITAL(GROUP)')
 1800 FORMAT(1X,75(1H=)/'    Orbital#    ',6I10)
 1810 FORMAT('      Group#    ',6I10)
 1850 FORMAT(1X,75(1H-)/'  AO# LABELS')
 1900 FORMAT(I4,A12,6F10.5)
C1901 FORMAT(I4,A8,3F20.15)
CDYN  WRITE(IOUTVB,1101) MHIGH
CGMS  WRITE(IOUTVB,1101) MHIGH
CGMS  WRITE(IOUTVB,1102)
      TIME2=XCLOCK()
      TIME =TIME2-TIME0
      TIME2=TIME2-TIME1
      TIME1=TIME1-TIME0
      WRITE(IOUTVB,1100)TIME1,TIME2,TIME
 1000 FORMAT(/1X,'ENERGY AND DIFF OF MACROITER',I5,' =',2F16.8)
 1100 FORMAT(/1X,'STATISTICS OF CPU TIMES (SECONDS)'/
     1       1X,'CPU TIME FOR INITIALIZATION ',F10.3/
     1       1X,'CPU TIME FOR MACROITERATION ',F10.3/
     1       1X,'TOTAL CPU TIME              ',F10.3/)
 1101 FORMAT(" WORDS OF DYNAMIC MEMORY USED IN VB2000 CODE ONLY:"
     1,I12)
 1102 FORMAT(" NOTE THAT THIS IS IN ADDITION TO MEMORY USED BY GAMESS",
     1/," PRINTED NEAR END OF OUTPUT. ADD THE TWO AMOUNTS TO GIVE",
     2/," THE TOTAL MEMORY USED BY THE JOB")
 1050 FORMAT(' INSUFFICIENT MEMORY - USE $MEMORY EXPLICITLY',
     1' TO SELECT MORE THAN',I12,' WORDS.')
      END
      SUBROUTINE COMPSIZE(NWNEED)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Estimate the scratch space needed for computation
C
C     Notes:
C               This diagram shows that the calling tree of
C               the most memory consumption routines.
C               memory allocation changed in those routines, the formula
C               also should be modified accordingly. The estimation is not
C               the exact value, but with reasonable accuracy.
C
C               ALGEBRANT -> ROTRAN - > HESSTE
C                 LGDMP        NWHES      MAX(MSCR1,MSCR3)
C
C               ALGEBRANT -> DVDCON - > GENSCF -> VBSCF  -> VBHESS -> LAPLACE
C                 LWRK2                           MWKMISC             NAGSIZE
C     History:
C
C               First created in June 2004
C               Modified NAGSIZE estimation. April. 2010.
C
C     Author:
C
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
     &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
     &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
C
C     COMPUT NOCORB
C
      NOCORB = 0
      DO 20 I=1,NSUB
 20   NOCORB = NOCORB+MLORBIT(I)
C
C     COMPUTE SCRATCH SPACE FOR HESSIAN OF RIGID ROTATION
C
      NWHES = 0
      DO 3 I=1,NSUB-1
      DO 3 J=I+1,NSUB
      IF (NOTROT((J-1)*(J-2)/2+I).EQ.0) THEN
      NDIMGRP=MLORBIT(I)*MLORBIT(J)
      NWHES = NWHES + NDIMGRP*(NDIMGRP+1)/2
      END IF
 3    CONTINUE
C
C     VIRTUAL ORBITALS
C
C     NVIRX=NBASIS-NOCORB
      DO 5 I=1,NSUB
      IF (NOTROT(NSUB*(NSUB-1)/2+I).EQ.0) THEN
      NDIMGRP=MLORBIT(I)*NVIR
      NWHES = NWHES + NDIMGRP*(NDIMGRP+1)/2
      END IF
  5   CONTINUE
C
C     COMPUTE SCRATCH SPACE FOR HESSTE
C
      NSQ   = NOCORB*(NOCORB+1)/2
      MSQ   = NBASIS*(NBASIS+1)/2
      NV    = NSQ + NOCORB*NVIR
      NGSQ  = NV*(NV+1)/2+(MSQ-NV)*NSQ
      MSCR1 = NBASIS**3
C     MSCR2 = NBASIS**2 + (NBASIS**4)/8
      MSCR3 = NGSQ + NBASIS**2
      MSCR  = MAX(MSCR1,MSCR3)
C
      LWRK1  = LGDMP+NBASIS*(NBASIS+1)/2
      LWRK2  = LWRK1+NBASIS*NBASIS
C
C     COMPUTE THE MAXSIZE OF VBSCF
C
      MXSIZE = LGDMP + NWHES + MSCR
C     WRITE(IOUTVB,*)'MXSIZE1 =',MXSIZE
      DO I=1, NSUB
      IF(METHOD(I).EQ.1.OR.MELE(I).EQ.2*MLORBIT(I)) GOTO 10
C
C     A GOOD GUESS FOR MISC DATA (SEE NLAST IN VBHESS)
C
      MWKMISC = MLORBIT(I)**4
C
C     A GOOD ESTIMATION (FROM OBSERVATION) FOR NAGSIZE
C
      NX      = (MELE(I)+1)/2
      NAGSIZE = 100*4**NX
C
C
      MXSIZE2 = LWRK2 + MWKMISC + NAGSIZE
      IF(MXSIZE.LT.MXSIZE2) MXSIZE = MXSIZE2
 10   CONTINUE
      END DO
C
C     WRITE(IOUTVB,*)'MXSIZE =',MXSIZE
      NWNEED = MXSIZE
      RETURN
      END
      SUBROUTINE DMTRAN(NSUB,MLORBIT,MNORBIT,MELE,METHOD,DM1NON,DM2NON,
     &DM1LOW,DM2LOW,BASNOC,G,MSIZE,NOND1D,LOWD1D,NONADD,NOND2D,LOWD2D)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Density Matrix Transformation
C               (All subunits, from nonorthogonal basis to Lowdin basis)
C
C     Note:
C               Both 1D and 2D density matrix elements are stored in
C               compact forms.
C               Scratch space requirement: M**3 + M**2, M is the maximal
C               dimension of non-HF groups.
C
C     History:
C               First created in Feb. 1999.
C               Recoded in September, 1999.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MAXDIM = 200)
      DIMENSION DM1NON(*),DM1LOW(*),NOND1D(*),LOWD1D(*),BASNOC(*)
      DIMENSION NOND2D(*),LOWD2D(*),NONADD(*),MLORBIT(*),MNORBIT(*)
      DIMENSION DM2NON(*),DM2LOW(*),G(*),METHOD(*),MELE(*)
      DIMENSION TEMPX(MAXDIM*MAXDIM)
C
C     LDIM >= NDIM !
C
      DO 100 KK=1,NSUB
      LDIM=MLORBIT(KK)
      NDIM=MNORBIT(KK)
      IF(NDIM**3+NDIM*NDIM.GT.MSIZE) CALL ABORT0('DMTRAN01  ')
C     LSQ=LDIM*(LDIM+1)/2
      NSQ=NDIM*(NDIM+1)/2
      NSQ2=NSQ*(NSQ+1)/2
C     LSQ2=LSQ*(LSQ+1)/2
C
C     SPECIAL CASE OF LHFSCF
C
      IF(METHOD(KK).GT.1.AND.NDIM.EQ.MELE(KK)/2) THEN
        DO IJ=1,NSQ
        DM1LOW(LOWD1D(KK)-1+IJ)=0.0D0
        END DO
        DO I=1, NDIM
          I2=I*(I+1)/2
          DM1LOW(LOWD1D(KK)-1+I2)=2.0D0
        END DO
      ELSE
        CALL MATRAN1(LDIM,NDIM,BASNOC(NONADD(KK)),G,
     &            DM1NON(NOND1D(KK)),DM1LOW(LOWD1D(KK)))
      ENDIF
      IF(METHOD(KK).GT.1) THEN
         DO IJKL=1,NSQ2
         DM2LOW(LOWD2D(KK)-1+IJKL)=0.0D0
         END DO
         MPP=LDIM**3
         IF(LDIM.GT.MAXDIM) CALL ABORT0("DMTRAN0001")
         IF(NDIM.EQ.MELE(KK)/2) THEN
C
C        DOUBLE OCCUPIED VB GROUP
C
           DO I=1, NDIM
             II = I*(I-1)/2
             I2 = I*(I+1)/2
             DO J=1, I
               IJ = II + J
               IJ2 = IJ*(IJ+1)/2
               IIJJ = I2*(I2-1)/2 + J*(J+1)/2
               FACTOR = -2.0D0
               IF(I.EQ.J) FACTOR = 1.0D0
               DM2LOW(LOWD2D(KK)-1+IJ2)=FACTOR
               IF(I.NE.J) DM2LOW(LOWD2D(KK)-1+IIJJ)=4.0D0
             ENDDO
           ENDDO
         ELSE
         CALL M4TRAN(LDIM, NDIM,BASNOC(NONADD(KK)),G(1),G(MPP),
     &            DM2NON(NOND2D(KK)),DM2LOW(LOWD2D(KK)),TEMPX)
         END IF
      END IF
  100 CONTINUE
C
C     DENSITY
C
      RETURN
      END
      SUBROUTINE M4TRAN(LDIM,NDIM,BASIS,W,P,DENOLD,DENNEW,BASISX)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               2D Density Matrix Transformation
C
C     Note:
C               Similar to four-index 2E integral transformation. The
C               same algorithm is used.
C
C     History:
C               First created in Feb. 1999.
C               Recoded in September, 1999.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      PARAMETER (MAXDIM = 200)
      PARAMETER (MAXDIM2 = MAXDIM*(MAXDIM+1)/2)
      DIMENSION W(*),BASIS(NDIM,LDIM),DENOLD(*),DENNEW(*)
      DIMENSION P(LDIM,LDIM),PSQ(MAXDIM2),V(1000),DC1(1000)
      DIMENSION BASISX(LDIM,LDIM)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      IF(NDIM.GT.MAXDIM.OR.LDIM.GT.MAXDIM) THEN
        WRITE(IOUTVB,*)"NDIM OR LDIM OF VB GROUP > ",MAXDIM
        CALL ABORT0('M4TRAN01  ')
      END IF
      DO I=1, LDIM
        DO J=1, NDIM
        BASISX(J,I) = BASIS(J,I)
        END DO
        DO J=NDIM+1, LDIM
        BASISX(J,I) = 0.0D0
        END DO
      END DO
      CALL DENFACA(LDIM,DENOLD,1)
C
C     THE N**5 ALGORITHM FOR THE FOUR-INDEX TRANSFORMATION
C
      M=LDIM
      MSQ=M*(M+1)/2
      DO 100 L=1,M
         DO 105 K=1,M
 105     V(K)=BASISX(L,K)
      DO 110 IJ=1,MSQ
      IAIJ=IJ*(IJ-1)/2
      DO 120 K1=1,IJ
 120  PSQ(K1)=DENOLD(IAIJ+K1)
      DO 121 K1=IJ+1,MSQ
      IAK1=K1*(K1-1)/2
 121  PSQ(K1)=DENOLD(IAK1+IJ)
      CALL MALTSQ(M,MSQ,PSQ,DC1,V)
      LL=L
      DO 130 K=LL,M
      XX=0.0D0
      KK=K
      DO 135 KX=1,M
  135 XX=XX+DC1(KX)*BASISX(KK,KX)
      W((K-1)*MSQ+IJ)=XX
 130  CONTINUE
 110  CONTINUE
      DO 100 K=LL,M
      KK=(K-1)*MSQ
      DO 220 K1=1,M
      K1JJ=K1*(K1-1)/2+KK
      DO 221 K2=1,K1
 221  P(K2,K1)=W(K1JJ+K2)
      K1JJ=K1+KK
      DO 222 K2=K1+1,M
      IAK2=K2*(K2-1)/2
 222  P(K2,K1)=W(IAK2+K1JJ)
 220  CONTINUE
      DO 100 J=1,M
          DO MMM=1,M
           V(MMM)=BASISX(J,MMM)
          END DO
      CALL MALTID(M,P,DC1,V)
      II=J
      IF(K.GT.J) II=K
      IF(J.LT.L) II=K+1
      DO 100 I=II,M
      XX=0.0D0
      DO 235 KX=1,M
  235 XX=XX+DC1(KX)*BASISX(I,KX)
      IJKL=IJKL01(I,J,K,L)
      DENNEW(IJKL)=XX
  100 CONTINUE
      CALL DENFACA(LDIM,DENNEW,0)
      CALL DENFACA(LDIM,DENOLD,0)
      RETURN
      END
C
C     ROUTINE FOR FACTOR OR DE-FACTOR THE TWO_ELECTRON DENSITY MATRIX
C     IDFACT=1(DE-FACTOR) OR 0(FACTOR)
C
      SUBROUTINE DENFACA(NDIM,D2,IDFACT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION D2(*)
      DO I=1,NDIM
      DO J=1,I
      IJ=I*(I-1)/2+J
        DO K=1,I
        LL=K
        IF(K.EQ.I) LL=J
        DO L=1,LL
        KL=K*(K-1)/2+L
        IJKL=IJ00(IJ,KL)
        FACTOR=1.0D0
        IF(I.NE.J) FACTOR=FACTOR*2.0D0
         IF(K.NE.L) FACTOR=FACTOR*2.0D0
         IF(IJ.NE.KL) FACTOR=FACTOR*2.0D0
           IF(IDFACT.EQ.1) THEN
           D2(IJKL)=D2(IJKL)/FACTOR
           ELSE
           D2(IJKL)=D2(IJKL)*FACTOR
           END IF
        END DO
        END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE TENERGY(NBASIS,NSUB,MLORBIT,METHOD,ORBLAO,RWRK,FKN,W,
     &                   NWSIZE,D2,ER,ENERGY)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Total energy of the product wave function
C
C     Note:
C               Minimal work space = NBASIS*NBASIS*(NBASIS+1)/2
C
C     History:
C               First created in Feb. 1999.
C               Recoded in September, 1999.
C               New energy expression coded. April, 2004
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
      DIMENSION MLORBIT(*),RWRK(*),W(*),D2(*),METHOD(*),ORBLAO(*),FKN(*)
      COMMON /VB2MEM/LOCX,LOCMEM,LOFFS,MEMWRK,MSCRATCH,MHIGH
      MEMUSED = MSCRATCH - NWSIZE
      NBA2=NBASIS*(NBASIS+1)/2
C     NDEN = 1
C     NHAM = NDEN + NBA2
C     NWK  = NHAM + NBA2
      NWNEED = NBA2*NBASIS
      MHIGH = MAX(MHIGH,MEMUSED+NWNEED)
      IF(NWNEED.GE.NWSIZE) CALL ABORT0('TENERGY001')
C
C     FIRST TERM OF ENERGY
C
      ENERGY  = ER
      CALL GETIOUNIT('IOTEMPA ',IOTEMPA)
      CALL GETIOUNIT('IOTEMPB ',IOTEMPB)
      LBUFF   = 4095
C
C     1E CONTRIBUTION
C
      CALL ONETENE(NBASIS,NSUB,MLORBIT,RWRK,W,NWSIZE,ENEONE)
      ENERGY = ENERGY + ENEONE
C
C     2E HARTREE-FOCK CONTRIBUTION
C
      IHF = 0
C     TIME1 = XCLOCK()
      CALL HF2EENE(NBASIS,NSUB,MLORBIT,METHOD,RWRK,FKN,W,NWSIZE,
     &             HF2E,IHF)
C     TIME2 = XCLOCK()
      ENERGY = ENERGY + HF2E
      NOBADD1= 1
C     IFLAG = 0
      CALL GETIOUNIT('IVBO2E  ',IVBO2E)
      DO K=1, NSUB
        IF(METHOD(K).NE.1) THEN
          NORB  = MLORBIT(K)
          NORB2 = NORB*(NORB+1)/2
          NGSQ  = NORB2*(NORB2+1)/2
          MHIGH = MAX(MHIGH,MEMUSED+NGSQ)
          CALL TRANP2E(NBASIS,NORB,0,ORBLAO(NOBADD1),W,NWSIZE,
     &                  LBUFF,IOTEMPA,IOTEMPB)
          CALL GREAD(W,NGSQ,LBUFF,IVBO2E)
C         NDBG=N2DADD(K)-1+NGSQ
          CALL TRACE2E(NORB,D2(N2DADD(K)),W,TR)
          ENERGY = ENERGY + TR
        END IF
        NOBADD1=NOBADD1+MLORBIT(K)*NBASIS
      ENDDO
      RETURN
      END
      SUBROUTINE ONETENE(NBASIS,NSUB,MLORBIT,RWRK,W,NSIZE,ENEONE)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Total energy of from 1E contribution
C
C     Note:
C               NSIZE > NBASIS*NBASIS*2
C
C     History:
C               First created in April 2004.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
      DIMENSION MLORBIT(*),RWRK(*),W(*)
      NBA2=NBASIS*(NBASIS+1)/2
      NDEN = 1
      NHAM = NDEN + NBA2
      NWK  = NHAM + NBA2
      NLAST= NWK  + NBASIS*NBASIS
      IF(NLAST.GE.NSIZE) CALL ABORT0('ONETENE001')
C
C     Calculate total density
C
      DO I=1,NBA2
        W(NDEN-1+I) =0.0D0
      ENDDO
C
C     TOTAL DENSITY
C
      NOBADD1= NAOBAS
      IFLAG  = 1
      DO K=1,NSUB
        CALL MATRAN2(MLORBIT(K),NBASIS,RWRK(NOBADD1),W(NWK),
     &             RWRK(ND1STA-1+N1DADD(K)),W(NDEN),IFLAG)
        NOBADD1=NOBADD1+MLORBIT(K)*NBASIS
      ENDDO
C
C     1E CONTRIBUTION
C
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL READ1E(IAO1E,W(NWK),W(NHAM),NBASIS)
      CALL HMTRACE(NBASIS,W(NHAM),W(NDEN),ENEONE)
      RETURN
      END
      SUBROUTINE HF2EENE(NBASIS,NSUB,MLORBIT,METHOD,RWRK,FKN,W,
     &                   NSIZE,ENERGY,IHF)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               2E energy contribution from HF type interaction
C               2E energy contribution from non-HF groups is not included.
C
C     Notes:    RWRK stores Lowdin orthogonalized orbitals of all groups and
C               the corresponding 1e and 2e densities of each group in its
C               own Lowdin orbital basis functions
C
C               W is a scratch space, used to store temp densities and the Fock
C               matrices of all groups(in global AO basis functions). The total
C               density and the corresponding Fock matrix are stored at the
C               slot NSUB+1. Approximate scratch space size is:
C
C               NBasis*(NBasis+1)*(NSUB+3)/2
C
C               On return, FKN holds (NSUB+1+NHFORB) Fock matrices for
C               group 1 ... NSUB, the total Fock matrix and optionally HF
C               orbitals
C
C
C     History:
C               First created in April 2004.
C               Added option for Fock matrices of HF orbitals. July 3, 2004.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
      DIMENSION MLORBIT(*),RWRK(*),FKN(*),W(*),METHOD(*)
      NBA2=NBASIS*(NBASIS+1)/2
C     NDEN = 1
C     NDENT= 1    + NBA2*NSUB
C     NFK  = NDENT + NBA2
C     NWK  = NFK  + NBA2*(NSUB+1)
C     NWK2 = NWK  + NBASIS*NBASIS
C     NFKT = NFK  + NBA2*NSUB

      NFK  = 1
      NFKT = NFK  + NBA2*NSUB
      NDEN = 1
      NDENT= NDEN + NBA2*NSUB
      NWK  = NDENT+ NBA2
      NWK2 = NWK  + NBASIS*NBASIS
      IF(NWK2.GE.NSIZE) CALL ABORT0('HF2EENE001')
C
C     Calculate total density
C
      DO I=1,NBA2*(NSUB+1)
        W(NDEN-1+I) =0.0D0
      ENDDO
C
C     Initialize ENERGY
C
      ENERGY = 0.0D0
      IFLAG=0
      NOBADD1=NAOBAS
      DO K=1,NSUB
      NDENK = NDEN + (K-1)*NBA2
        CALL MATRAN2(MLORBIT(K),NBASIS,RWRK(NOBADD1),W(NWK),
     &             RWRK(ND1STA-1+N1DADD(K)),W(NDENK),IFLAG)
        NOBADD1=NOBADD1+MLORBIT(K)*NBASIS
      ENDDO
C
C     IF THIS IS CALLED FROM HESSTE, THEN ALSO
C     COMPUTE DENSITY MATRIX FOR EACH HF ORBITAL DIRECTLY FROM ORBITLA
C
      NHFORB = 0
      IF(IHF.EQ.1) THEN
        NOBADD1 = NAOBAS
        NDENADD = NDENT
        DO K=1, NSUB
        IF(METHOD(K).EQ.1) THEN
          DO I=1, MLORBIT(K)
          NHFORB  = NHFORB + 1
          NADD    = NOBADD1 + (I-1)*NBASIS - 1
          NDENADD = NDENADD + NBASIS*(NBASIS+1)/2
          NDENJL  = NDENADD - 1
            DO J=1, NBASIS
            DO L=1, J
            NDENJL = NDENJL + 1
            W(NDENJL) = 2.0D0*RWRK(NADD+J)*RWRK(NADD+L)
            END DO
            END DO
          END DO
        END IF
        NOBADD1=NOBADD1+MLORBIT(K)*NBASIS
        END DO
      END IF
C
C     1E CONTRIBUTION
C
      DO K=1, NSUB
      NDENK = NDEN + (K-1)*NBA2
        DO J=1, NBA2
        W(NDENT-1+J) = W(NDENT-1+J)+W(NDENK-1+J)
        END DO
      END DO
C
C     2E CONTRIBUTION. FK TERMS/TOTAL DENSITY
C
      NHFMAT = NSUB + 1 + NHFORB
      CALL FKENGI(FKN(NFK),W(NDEN),NBASIS,NHFMAT)
      CALL HMTRACE(NBASIS,FKN(NFKT),W(NDENT),TR)
      ENERGY = ENERGY + TR*0.5D0
      DO K=1, NSUB
        IF(METHOD(K).NE.1) THEN
        NDENK = NDEN + (K-1)*NBA2
        NFKK  = NFK  + (K-1)*NBA2
        CALL HMTRACE(NBASIS,FKN(NFKK),W(NDENK),TR)
        ENERGY = ENERGY - TR*0.5D0
        END IF
      END DO
      RETURN
      END
      SUBROUTINE HMTRACE(NBASIS,A,B,TR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(*),B(*)
      NBA2 = NBASIS*(NBASIS+1)/2
      TR = 0.0D0
      DO I=1, NBA2
      TR = TR + A(I)*B(I)*2.0D0
      END DO
      DO I=1, NBASIS
      II = I*(I+1)/2
      TR = TR - A(II)*B(II)
      END DO
      RETURN
      END
      SUBROUTINE TRACE2E(NORB,D2,G,TR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION D2(*),G(*)
      TR = 0.0D0
      DO I=1,NORB
      DO J=1,I
      IJ=I*(I-1)/2+J
        DO K=1,I
        LL=K
        IF(K.EQ.I) LL=J
        DO L=1,LL
        KL=K*(K-1)/2+L
        IJKL = IJ00(IJ,KL)
        TR = TR +D2(IJKL)*G(IJKL)
C       WRITE(IOUTVB,*)'TR2: D2, G=',D2(IJKL),G(IJKL)
        END DO
        END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE HESSTE(NBASIS,NOCB,DERV,HESS,NDH2,RWRK,NHFORB,
     &FKN,W,ORBLAO,NDH,NOBACC,NHESADD,D1,D2,NWSIZE,LD1ADD,
     &LD2ADD,ER,ENERGY,MITER)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               The 1st and 2nd derivatives of total energy with respect
C               to the rigid rotation parameters.
C     Notes:
C               Density matrices and integrals in Lowdin basis set are
C               used.
C
C               Minimal scratch space size = MAX(MSCR1,MSCR3)
C
C     History:
C               First created in Feb. 1999.
C
C               Recoded in September, 1999.
C
C               Added new algorithm for total energy evaluation
C               Added TRANP2E, automatic switch from TRANN2E to TRANP2E
C               when the scratch space is low. More efficient usage of
C               scratch space. June 2004.
C
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION W(*),ORBLAO(*),D1(*),D2(*),LD1ADD(*),LD2ADD(*)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
     &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
     &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
      DIMENSION HESS(*),DERV(*)
      DIMENSION NOBACC(*),NHESADD(*)
      DIMENSION FKN(*),NHFOADD(99)
      COMMON /IAA/IA(100000)
      COMMON /IBB/IB(100000),MWINZ,MBORZ
C     COMMON /IDD/ID(100000)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /VB2MEM/LOCX,LOCMEM,LOFFS,MEMWRK,MSCRATCH,MHIGH
      LOGICAL BLKHESS
      BLKHESS = .TRUE.
      MEMUSED = MSCRATCH - NWSIZE
C
C     FOR UNSTABLE SYSTEM, USE FULL HESSIAN
C
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$FULLHESS',9,IOK,0)
      IF(IOK.EQ.1) BLKHESS = .FALSE.
      IF(NDH.EQ.0) RETURN
C
C     ADDRESS AND MAP
C
      DO I=1,NDH
      DERV(I)=0.0D0
      END DO
      DO I=1,NDH2
      HESS(I)=0.0D0
      END DO
C     MWINDX=NBASIS
C
C     SET INDEX
C
      CALL SETIND(NBASIS,NOCB)
      NV     = IB(NBASIS+1)
      NSQ    = NOCB*(NOCB+1)/2
      MSQ    = NBASIS*(NBASIS+1)/2
      NGSQ   = NV*(NV+1)/2+(MSQ-NV)*NSQ
      MGSQ   = IA(MSQ+1)
      NMSQ   = NBASIS*MSQ
C
      MMS    = 1
      MMH    = MMS+MSQ
      MMG    = MMH+MSQ
C     MLAST1 = MM3+MSQ
C     NWRK   = NWSIZE - MMG
C
C     Scratch for TRAN1E
C
C     MA1    = MMH+MSQ
C     MA2    = MA1+NBASIS*NBASIS
C
C     Scratch for TRANN2E
C
      MBG    = 1
      MB1    = MBG + MGSQ
      MB2    = MB1 + NBASIS*NBASIS
      MB3    = MB2 + NMSQ
      MB4    = MB3 + MSQ
C
C     CHECK WORK SPACE AND ITRAN OPTION
C
      ITRAN = 2
      IF(NBASIS.GT.360) GOTO 998
      NBA2  = NBASIS*(NBASIS+1)/2
      MSCR1 = NBASIS**3
      MSCR2 = NBASIS**2 + IA(NBA2+1)
      MSCR3 = NGSQ + NBASIS**2
      IF(NWSIZE.LT.MSCR1.OR.NWSIZE.LT.MSCR3)  THEN
        NEED1 = MAX(MSCR1,MSCR3) - NWSIZE
        NEED2 = MSCR2 - NWSIZE
        IF(MB4-NWSIZE.GT.NEED2) NEED2 = MB4-NWSIZE
        WRITE(IOUTVB,*)
     &   'You need at least ',MSCRATCH+NEED1,' double words '
C000    WRITE(IOUTVB,*) 'Please use the $MEMORY keyword to specify at'
C000    WRITE(IOUTVB,*)' least that amount of scratch memory.'
CSMI    WRITE(IOUTVB,*) 'Please use the $MEMORY keyword to specify at'
CSMI    WRITE(IOUTVB,*)' least that amount of scratch memory.'
CGMS    WRITE(IOUTVB,*) 'Please use the $MEMORY keyword to specify at'
CGMS    WRITE(IOUTVB,*)' least that amount of scratch memory.'
CGAU    WRITE(IOUTVB,*) 'Please increase the amount of memory requested'
CGAU    WRITE(IOUTVB,*)' with the standard Gaussian %mem directive.'
        WRITE(IOUTVB,*)'For more efficient 2E transformation you need'
        WRITE(IOUTVB,*)'at least ',MSCRATCH+NEED2,' double words '
        CALL ABORT0('HESSTE0000')
      END IF
C
C     CHECK IF IN-CORE TRANSFORMATION IS POSSIBLE
C
      IF(NWSIZE.GT.MSCR2.AND.NWSIZE.GT.MB4) THEN
        ITRAN = 1
        MHIGH = MAX(MHIGH, MEMUSED+MB4)
C       ONLY REPORT ONCE AT THE VERY END
C       WRITE(IOUTVB,'(" MHIGH",2I12)') 4,MHIGH
      ENDIF
 998  CONTINUE
CSMI  ITRAN = 2
      IF(ITRAN.EQ.2) THEN
C
C     IN DISK-MODE, ALL MEMORY IS USED
C
      MHIGH = MSCRATCH
C     WRITE(IOUTVB,'(" MHIGH",2I12)') 5,MHIGH
C
C     PRINT A WARNING MESSAGE FOR DISK-TRANSFORMATION MODE
C
      MORENEED = MSCR2 - NWSIZE
      IF(MB4-NWSIZE.GT.MORENEED) MORENEED = MB4-NWSIZE
C
C     PRINT THE MESSAGE FOR THE FIRST ITERATION
C
      IF(MITER.EQ.1) THEN
      WRITE(IOUTVB,*)'DISK MODE FOR 2E TRANSFORMATION'
      WRITE(IOUTVB,*)
     & 'You need at least ',MSCRATCH+MORENEED,' double words'
      WRITE(IOUTVB,*)'for more efficient 2E transformation. '
C000  WRITE(IOUTVB,*)
C000 & 'Please use $MEMORY keyword to specify at least that'
C000  WRITE(IOUTVB,*)'amount of scratch space.'
CSMI  WRITE(IOUTVB,*)
CSMI & 'Please use $MEMORY keyword to specify at least that'
CSMI  WRITE(IOUTVB,*)'amount of scratch space.'
CGMS  WRITE(IOUTVB,*)
CGMS & 'Please use $MEMORY keyword to specify at least that'
CGMS  WRITE(IOUTVB,*)'amount of scratch space.'
CGAU  WRITE(IOUTVB,*)
CGAU & 'Please increase the amount of memory requested with'
CGAU  WRITE(IOUTVB,*)'the standard Gaussian %mem directive.'
      END IF
      END IF
      E1HF2E = ER
C
C     GET ONETENE AND HF2E
C
C     1E CONTRIBUTION
C
      CALL ONETENE(NBASIS,NSUB,MLORBIT,RWRK,W,NWSIZE,ENEONE)
      E1HF2E = E1HF2E + ENEONE
C
C     2E HARTREE-FOCK CONTRIBUTION
C     ALSO COMPUTE FOCK MATRICES FOR ALL HF ORBITALS
C
      TIME1 = XCLOCK()
      IHF = 1
      CALL HF2EENE(NBASIS,NSUB,MLORBIT,METHOD,RWRK,FKN,W,NWSIZE,HF2E,
     &             IHF)
      E1HF2E = E1HF2E + HF2E
      ENERGY = E1HF2E
      TIME2 = XCLOCK()
C     WRITE(IOUTVB,*)'HF TIME FOR IHF(1) =',TIME2-TIME1
C
C     END OF ENERGY
C
C     TRANSFORMATION OF FKN
C
      NFK   = 1
      NBAS2 = NBASIS*NBASIS
      DO  I = 1, NSUB+1+NHFORB
      CALL MATRAN(NBASIS,NBASIS,ORBLAO,W(NBAS2),FKN(NFK),W)
        DO J=1, MSQ
        FKN(NFK-1+J) = W(J)
        END DO
      NFK = NFK + MSQ
      END DO
C
C     TODO: NEED A CHECK FOR WORKING SPACE.
C
C     NVIRX  = NBASIS - NOCB
C
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL GETIOUNIT('IAO2E   ',IAO2E)
      CALL GETIOUNIT('IVBO2E  ',IVBO2E)
      LBUFF = 4095
      REWIND(IVBO2E)
C
C     WRITE TWO EMPTY RECORDS!
C
      WRITE(IVBO2E)
      WRITE(IVBO2E)
      TIME=XCLOCK()
      IF(ITRAN.EQ.1) THEN
C
C     IN-CORE MODE
C
C     ZERO 2E INTEGRALS
C
      MSQ2 = MSQ*(MSQ+1)/2
      DO I=1,MSQ2
      W(MBG-1+I) = 0.0D0
      END DO
      CALL READ2E(IAO2E,W(MBG))
      CALL TRANN2E(NBASIS,NOCB,NVIR,W(MBG),ORBLAO,
     & W(MB1),W(MB2),W(MB3),LBUFF,IVBO2E)
      ELSE
C
C     DISK MODE
C
      CALL GETIOUNIT('IOTEMPA ',IOTEMPA)
      CALL GETIOUNIT('IOTEMPB ',IOTEMPB)
      NWRK1 = NWSIZE
      CALL TRANP2E(NBASIS,NOCB,NVIR,ORBLAO,W(MBG),NWRK1,LBUFF,
     &             IOTEMPA,IOTEMPB)
      END IF
      TIME1=XCLOCK()
      TIME=TIME1-TIME
C     WRITE(IOUTVB,'(' 2E-TRAN TIME FOR ROTRAN=',F8.3)')TIME
C
C     TRANSFORMATION OF CORE HAMILTONAIN
C     IN THE FOLLOWING READ1E,W(MMS) HOLDS CORE H, AND W(MMH) HOLDS OVERLAP
C
      CALL READ1E(IAO1E,W(MMH),W(MMS),NBASIS)
C
C     AFTER TRANSFORMATION, W(MMH) HOLDS THE TRANFORMED CORE H
C
      CALL MATRAN(NBASIS,NBASIS,ORBLAO,W(MMH+MSQ),W(MMS),
     &            W(MMH))
C
C     ADD CORE H TO THE TOTAL FOCK MATRIX
C
      NFNT = 1 + NSUB*MSQ
      DO I=1, MSQ
      FKN(NFNT-1+I) = W(MMH-1+I) + FKN(NFNT-1+I)
      END DO
      CALL GREAD(W(MMG),NGSQ,LBUFF,IVBO2E)
C     NBM1=0
C
C     SETUP NHFOADD
C
      NHFOADD(1) = 0
      DO M1=2, NSUB
      NHFOADD(M1) = NHFOADD(M1-1)
      IF(METHOD(M1-1).EQ.1) THEN
      NHFOADD(M1) = NHFOADD(M1-1) + MNORBIT(M1-1)
      END IF
      END DO
C
      DO 999 M1=1,NSUB
C
C     COMPUTE NON-HF 2E ENERGY
C
      IF(METHOD(M1).NE.1) THEN
      IJKL1=LD2ADD(M1)-1
      DO I=1,MNORBIT(M1)
      DO J=1,I
      IJ=I*(I-1)/2+J
      IG=I+NOBACC(M1)
      JG=J+NOBACC(M1)
      IJG=IJ00(IG,JG)
        DO K=1,I
        LL=K
        IF(K.EQ.I) LL=J
        DO L=1,LL
        KG=K+NOBACC(M1)
        LG=L+NOBACC(M1)
        KL=K*(K-1)/2+L
        KLG=IJ00(KG,LG)
        IJKLG=IJ00(IJG,KLG)
        IJKL=IJKL1+IJ00(IJ,KL)
        ENERGY=ENERGY+D2(IJKL)*W(MMG-1+IJKLG)
        END DO
        END DO
      END DO
      END DO
      END IF
 999  CONTINUE
C
C     NEW CODE
C
C     W(MMS): SCRATCH
C     W(MMH): CORE H
C     W(MMG): 2E IN ORTHOGONAL BASIS FUNCTIONS
C     FKN:    FOCK MATRICES
C
      NHGRP = 0
      NHDIM = 0
      DO 3 MI=1,NSUB-1
      DO 3 MJ=MI+1,NSUB
      IF (NOTROT((MJ-1)*(MJ-2)/2+MI).NE.0) GOTO 2
      NDIMGRP = MNORBIT(MI)*MNORBIT(MJ)
      NHGRP = NHGRP + 1
      NHESTART = NHESADD(NHGRP)+1
C
C     EFFECTIVE POTENTIAL OF GROUP I AND J
C
C     HEFF = FKNT - FKI - FKJ
C
      NFKI = (MI-1)*MSQ
      NFKJ = (MJ-1)*MSQ
      NFNT =  NSUB*MSQ
      DO L1=1,MSQ
      W(MMH-1+L1)=FKN(NFNT+L1)-FKN(NFKI+L1)-FKN(NFKJ+L1)
      END DO
      IOPTION = 1
      IF(METHOD(MI).EQ.1.AND.BLKHESS) THEN
      IOPTION = 0
C
C     MTFKI: FORK MATRIX OF GROUP MI
C     MOFKI: FORK MATRICES OF MOs of GROUP MI
C
      MTFKI1 = NFKI+1
      MOFKI1 = (NSUB+1+NHFOADD(MI))*MSQ+1
      CALL MIXHFK(NBASIS,MNORBIT(MI),MNORBIT(MJ),METHOD(MI),METHOD(MJ),
     & NOBACC(MI),NOBACC(MJ),W(MMH),D1(LD1ADD(MI)),D1(LD1ADD(MJ)),
     & D2(LD2ADD(MI)),D2(LD2ADD(MJ)),W(MMG),IOPTION,
     & FKN(MTFKI1),FKN(MOFKI1),DERV(NHDIM+1),HESS(NHESTART))
      ELSE
      CALL MIXGIJ(MNORBIT(MI),MNORBIT(MJ),METHOD(MI),METHOD(MJ),
     & NOBACC(MI),NOBACC(MJ),W(MMH),D1(LD1ADD(MI)),D1(LD1ADD(MJ)),
     & D2(LD2ADD(MI)),D2(LD2ADD(MJ)),W(MMG),IOPTION,DERV(NHDIM+1),
     & HESS(NHESTART))
      END IF
      NHDIM = NHDIM + NDIMGRP
 2    CONTINUE
 3    CONTINUE
      DO 4 MI=1, NSUB
      IF ((NOTROT(NSUB*(NSUB-1)/2+MI).EQ.0).AND.METHOD(MI).NE.1) THEN
      NHGRP = NHGRP + 1
      NHESTART = NHESADD(NHGRP)+1
      NDIMGRP = MNORBIT(MI)*NVIR
C
C     EFFECTIVE POTENTIAL OF GROUP I
C
C     HEFF = FKNT - FKI
C
      NFKI = (MI-1)*MSQ
      NFNT =  NSUB*MSQ
      DO L1=1,MSQ
      W(MMH-1+L1)=FKN(NFNT+L1)-FKN(NFKI+L1)
      END DO
      IOPTION = 1
C     IF(BLKHESS) IOPTION = 0
      CALL MIXVIR(MNORBIT(MI),NVIR,METHOD(MI),
     & NOBACC(MI),NOBACC(NSUB+1),W(MMH),D1(LD1ADD(MI)),
     & D2(LD2ADD(MI)),W(MMG),IOPTION,DERV(NHDIM+1),HESS(NHESTART))
      NHDIM = NHDIM + NDIMGRP
      END IF
 4    CONTINUE
      TIME2=XCLOCK()
      TIME=TIME2-TIME1
C     WRITE(IOUTVB,'(' HESSIAN TIME FOR ROTRAN=',F8.3)')TIME
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     FUNCTION: COMPUTE HESSIAN OF RIGID ROTATION BETWEEN GROUP I AND J
C
C     NOTES:
C             W(MMS): SCRATCH
C             W(MMH): CORE H
C             W(MMG): 2E IN ORTHOGONAL BASIS FUNCTIONS
C             FKN:    FOCK MATRICES
C             IOPTION: 1 (FULL HESSIAN FOR GROUP I,J), 0 (BLOCK DIAGONAL)
C
C     HISTORY:
C
C             First version: June 30, 2004
C
C     AUTHOR:
C             Jiabo Li
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE MIXGIJ(MORBI,MORBJ,MTDI,MTDJ,NOBADDI,NOBADDJ,HEFF,
     &                  D1A,D1B,D2A,D2B,G,IOPTION,DERV,HESS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION HEFF(*),D1A(*),D1B(*),D2A(*),D2B(*),G(*),DERV(*),HESS(*)
      DIMENSION IJKL4(4),IFLAG(4)
      LOGICAL BLKHESS,COMPHESS
      BLKHESS = .FALSE.
      IF(IOPTION.EQ.0) BLKHESS=.TRUE.
      DO I=1, MORBI*MORBJ
      DERV(I) = 0.0D0
      END DO
      NDH1 = MORBI*MORBJ
      NDH2 = NDH1*(NDH1+1)/2
      DO I=1, NDH2
      HESS(I) = 0.0D0
      END DO
C
C     ENERGY OF GROUP I AND GROUP J IN THE HEFF
C
      ETEMP = 0.0D0
      IJ = 0
      DO I=1,MORBI
      DO J=1, I
      IG = I + NOBADDI
      JG = J + NOBADDI
      IJ = IJ00(I,J)
      IJG=IJ00(IG,JG)
      FAC = 1.0D0
      IF(I.NE.J) FAC = 2.0D0
      D1AIJ = D1A(IJ)*FAC
      ETEMP = ETEMP + FAC*D1A(IJ)*HEFF(IJG)
C
C       I-> IP (IP in GROUP B)
C       J-> IP
C
        IX1 = I
        DO IP=1, MORBJ
        I2IP = (I-1)*MORBJ + IP
        IPX  = NOBADDJ+ IP
        IJX = IJ00(IPX,JG)
        DERV(I2IP) = DERV(I2IP) + D1AIJ*HEFF(IJX)
C       GOTO 991
C
C       HESS
C          IP -> IPP (IPP in GROUP A)
C          J  -> JP  (JP in GROUP B)
           DO IPP = 1, MORBI
           IP2I  = (IPP-1)*MORBJ + IP
           IX2   = IPP
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(IP2I.GE.I2IP.AND.COMPHESS) THEN
           IPPX  = NOBADDI + IPP
           IJHES = IJ00(I2IP,IP2I)
           IJXX  = IJ00(IPPX,JG)
           HESS(IJHES) = HESS(IJHES) - D1AIJ*HEFF(IJXX)
C          CONTRI = - D1AIJ*HEFF(IJXX)
           END IF
           END DO
           DO JP = 1, MORBJ
           J2JP  = (J-1)*MORBJ + JP
           IX2   = J
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(J2JP.GE.I2IP.AND.COMPHESS) THEN
           JPX   = NOBADDJ + JP
           IJXX  = IJ00(IPX,JPX)
           IJHES = IJ00(I2IP,J2JP)
           HESS(IJHES) = HESS(IJHES) + D1AIJ*HEFF(IJXX)
C          CONTRI =  D1AIJ*HEFF(IJXX)
           END IF
           END DO
C991       CONTINUE
        END DO
C
        IX1 = J
        DO JP=1, MORBJ
        J2JP = (J-1)*MORBJ + JP
        JPX  = NOBADDJ+ JP
        IJX  = IJ00(IG,JPX)
        DERV(J2JP) = DERV(J2JP) + D1AIJ*HEFF(IJX)
C       GOTO 992
C
C       HESS
C          I  -> IP
C          JP -> JPP
           DO IP = 1, MORBJ
           I2IP = (I-1)*MORBJ + IP
           IX2   = I
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(I2IP.GE.J2JP.AND.COMPHESS) THEN
           IPX  = NOBADDJ + IP
           IJXX = IJ00(IPX,JPX)
           IJHES= IJ00(I2IP,J2JP)
           HESS(IJHES) = HESS(IJHES) + D1AIJ*HEFF(IJXX)
C          CONTRI =  D1AIJ*HEFF(IJXX)
           END IF
           END DO
           DO JPP=1, MORBI
           JP2J = (JPP-1)*MORBJ + JP
           IX2   = JPP
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(JP2J.GE.J2JP.AND.COMPHESS) THEN
           JPPX = NOBADDI + JPP
           IJHES= IJ00(J2JP,JP2J)
           IJXX = IJ00(IG,JPPX)
           HESS(IJHES) = HESS(IJHES) - D1AIJ*HEFF(IJXX)
C          CONTRI = -D1AIJ*HEFF(IJXX)
           END IF
           END DO
C992       CONTINUE
        END DO
      END DO
      END DO
C
      IJ = 0
      DO I=1,MORBJ
      DO J=1, I
      IG = I + NOBADDJ
      JG = J + NOBADDJ
      IJ = IJ00(I,J)
      IJG=IJ00(IG,JG)
      FAC = 1.0D0
      IF(I.NE.J) FAC = 2.0D0
      D1BIJ = D1B(IJ)*FAC
      ETEMP = ETEMP + FAC*D1B(IJ)*HEFF(IJG)
C     WRITE(IOUTVB,*)'DBG SOURCE: I,J,IG,JG,D1B,H',I,J,IG,JG,D1BIJ,
C    &                       HEFF(IJG)
C       I-> IP (IP in GROUP A)
C       J-> IP
C
        DO IP=1, MORBI
        I2IP = (IP-1)*MORBJ + I
        IPX  = NOBADDI+ IP
        IJX  = IJ00(IPX,JG)
        DERV(I2IP) = DERV(I2IP) - D1BIJ*HEFF(IJX)
C       GOTO 993
C
C       HESS
C          IP -> IPP (IPP in GROUP B)
C          J  -> JP  (JP in GROUP A)
           IX1 = IP
           DO IPP = 1, MORBJ
           IP2I  = (IP-1)*MORBJ + IPP
           IX2   = IP
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(IP2I.GE.I2IP.AND.COMPHESS) THEN
           IPPX  = NOBADDJ + IPP
           IJHES = IJ00(I2IP,IP2I)
           IJXX  = IJ00(IPPX,JG)
           HESS(IJHES) = HESS(IJHES) - D1BIJ*HEFF(IJXX)
C          CONTRI = -D1BIJ*HEFF(IJXX)
           END IF
           END DO
           DO JP = 1, MORBI
           J2JP  = (JP-1)*MORBJ + J
           IX2   = JP
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(J2JP.GE.I2IP.AND.COMPHESS) THEN
           JPX   = NOBADDI + JP
           IJXX  = IJ00(IPX,JPX)
           IJHES = IJ00(I2IP,J2JP)
           HESS(IJHES) = HESS(IJHES) + D1BIJ*HEFF(IJXX)
C          CONTRI =  D1BIJ*HEFF(IJXX)
           END IF
           END DO
C993       CONTINUE
        END DO
        DO JP=1, MORBI
        J2JP = (JP-1)*MORBJ + J
        JPX  = NOBADDI+ JP
        IJX = IJ00(IG,JPX)
        DERV(J2JP) = DERV(J2JP) - D1BIJ*HEFF(IJX)
C       GOTO 994
C
C       HESS
C          I  -> IP  (IN GROUP A)
C          JP -> JPP (IN GROUP B)
           IX1 = JP
           DO IP = 1, MORBI
           I2IP = (IP-1)*MORBJ + I
           IX2 = IP
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(I2IP.GE.J2JP.AND.COMPHESS) THEN
           IPX  = NOBADDI + IP
           IJXX = IJ00(IPX,JPX)
           IJHES= IJ00(I2IP,J2JP)
           HESS(IJHES) = HESS(IJHES) + D1BIJ*HEFF(IJXX)
C          CONTRI =  D1BIJ*HEFF(IJXX)
           END IF
           END DO
           DO JPP=1, MORBJ
           JP2J = (JP-1)*MORBJ + JPP
           IX2 = JP
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(JP2J.GE.J2JP.AND.COMPHESS) THEN
           JPPX = NOBADDJ + JPP
           IJHES= IJ00(J2JP,JP2J)
           IJXX = IJ00(IG,JPPX)
           HESS(IJHES) = HESS(IJHES) - D1BIJ*HEFF(IJXX)
C          CONTRI = -D1BIJ*HEFF(IJXX)
           END IF
           END DO
C994       CONTINUE
C
        END DO
      END DO
      END DO
      IFLAG(1) = 1
      IFLAG(2) = 1
      IFLAG(3) = 1
      IFLAG(4) = 1
C
C     IF GROUP I IS NOT A HF GROUP
C
      IF(MTDI.NE.1) THEN
      DO I=1,MORBI
      II = I*(I-1)/2
      IG = I+NOBADDI
      IIG= IG*(IG-1)/2
      DO J=1,I
      IJ = II+J
      JG = J+NOBADDI
      IJG= IIG + JG
        DO K=1,I
        LL  = K
        KK  = K*(K-1)/2
        KG  = K+NOBADDI
        KKG = KG*(KG-1)/2
        IF(K.EQ.I) LL=J
        DO L=1,LL
        LG = L+NOBADDI
        KL = KK+L
        KLG= KKG + LG
        IJKLG= IJ00(IJG,KLG)
        IJKL = IJ00(IJ,KL)
        D2AIJKL = D2A(IJKL)
        ETEMP=ETEMP+D2A(IJKL)*G(IJKLG)
        IJKL4(1) = I
        IJKL4(2) = J
        IJKL4(3) = K
        IJKL4(4) = L
        CALL HESSGAB(MORBI,MORBJ,NOBADDI,NOBADDJ,D2AIJKL,IJKL4,
     &               IFLAG,IOPTION,HESS,G)
C
C       I-> IP
C       J-> JP
C       K-> KP
C       L-> LP
C       (IP,JP,KP AND LP in GROUP B, PAIR FACTOR=1.0
C
           KLG = IJ00(KG,LG)
           DO IP=1, MORBJ
           IPX = IP + NOBADDJ
           I2IP= (I-1)*MORBJ + IP
           IJG = IJ00(IPX,JG)
           IJKLG = IJ00(IJG,KLG)
           DERV(I2IP) = DERV(I2IP) + D2A(IJKL)*G(IJKLG)
           END DO
           DO JP=1, MORBJ
           JPX = JP + NOBADDJ
           J2JP= (J-1)*MORBJ + JP
           IJG = IJ00(IG,JPX)
           IJKLG = IJ00(IJG,KLG)
           DERV(J2JP) = DERV(J2JP) + D2A(IJKL)*G(IJKLG)
           END DO
           IJG = IJ00(IG,JG)
           DO KP=1, MORBJ
           KPX = KP + NOBADDJ
           K2KP= (K-1)*MORBJ + KP
           KLG = IJ00(KPX,LG)
           IJKLG = IJ00(IJG,KLG)
           DERV(K2KP) = DERV(K2KP) + D2A(IJKL)*G(IJKLG)
           END DO
           DO LP=1, MORBJ
           LPX = LP + NOBADDJ
           L2LP= (L-1)*MORBJ + LP
           KLG = IJ00(KG,LPX)
           IJKLG = IJ00(IJG,KLG)
           DERV(L2LP) = DERV(L2LP) + D2A(IJKL)*G(IJKLG)
           END DO
        END DO
        END DO
      END DO
      END DO
      ELSE
C
C     GROUP MI IS A HF GROUP
C
      DO I=1,MORBI
      DO J=1,I
      IJ=I*(I-1)/2+J
      IG=I+NOBADDI
      JG=J+NOBADDI
      IJG=IJ00(IG,JG)
        DO K=1,I
        LL=K
        IF(K.EQ.I) LL=J
        DO L=1,LL
        KG=K+NOBADDI
        LG=L+NOBADDI
        KL=K*(K-1)/2+L
        KLG=IJ00(KG,LG)
        IJKLG=IJ00(IJG,KLG)
             DDD=0.0D0
               IF(IJ.EQ.KL) THEN
                DDD=1.0D0
                    IF(I.NE.J) DDD=-2.0D0
               ELSE IF(I.EQ.J.AND.K.EQ.L) THEN
               DDD=4.0D0
               END IF
        IF(DDD.NE.0.0D0) THEN
        ETEMP=ETEMP+DDD*G(IJKLG)
        IJKL4(1) = I
        IJKL4(2) = J
        IJKL4(3) = K
        IJKL4(4) = L
        CALL HESSGAB(MORBI,MORBJ,NOBADDI,NOBADDJ,DDD,IJKL4,
     &               IFLAG,IOPTION,HESS,G)
C
C       I-> IP
C       J-> JP
C       K-> KP
C       L-> LP
C       (IP,JP,KP AND LP in GROUP B, PAIR FACTOR=1.0
C
           D2AIJKL = DDD
           KLG = IJ00(KG,LG)
           DO IP=1, MORBJ
           IPX = IP + NOBADDJ
           I2IP= (I-1)*MORBJ + IP
           IJG = IJ00(IPX,JG)
           IJKLG = IJ00(IJG,KLG)
           DERV(I2IP) = DERV(I2IP) + D2AIJKL*G(IJKLG)
           END DO
           DO JP=1, MORBJ
           JPX = JP + NOBADDJ
           J2JP= (J-1)*MORBJ + JP
           IJG = IJ00(IG,JPX)
           IJKLG = IJ00(IJG,KLG)
           DERV(J2JP) = DERV(J2JP) + D2AIJKL*G(IJKLG)
           END DO
           IJG = IJ00(IG,JG)
           DO KP=1, MORBJ
           KPX = KP + NOBADDJ
           K2KP= (K-1)*MORBJ + KP
           KLG = IJ00(KPX,LG)
           IJKLG = IJ00(IJG,KLG)
           DERV(K2KP) = DERV(K2KP) + D2AIJKL*G(IJKLG)
           END DO
           DO LP=1, MORBJ
           LPX = LP + NOBADDJ
           L2LP= (L-1)*MORBJ + LP
           KLG = IJ00(KG,LPX)
           IJKLG = IJ00(IJG,KLG)
           DERV(L2LP) = DERV(L2LP) + D2AIJKL*G(IJKLG)
           END DO
        END IF
        END DO
        END DO
      END DO
      END DO
      END IF
      IFLAG(1) =-1
      IFLAG(2) =-1
      IFLAG(3) =-1
      IFLAG(4) =-1
C
C     IF GROUP MJ IS NOT A HF GROUP
C
      IF(MTDJ.NE.1) THEN
      DO I=1,MORBJ
      DO J=1,I
      IJ=I*(I-1)/2+J
      IG=I+NOBADDJ
      JG=J+NOBADDJ
      IJG=IJ00(IG,JG)
        DO K=1,I
        LL=K
        IF(K.EQ.I) LL=J
        DO L=1,LL
        KG=K+NOBADDJ
        LG=L+NOBADDJ
        KL=K*(K-1)/2+L
        KLG=IJ00(KG,LG)
        IJKLG=IJ00(IJG,KLG)
        IJKL=IJ00(IJ,KL)
        D2BIJKL = D2B(IJKL)
        ETEMP=ETEMP+D2B(IJKL)*G(IJKLG)
        IJKL4(1) = I
        IJKL4(2) = J
        IJKL4(3) = K
        IJKL4(4) = L
        CALL HESSGAB(MORBI,MORBJ,NOBADDI,NOBADDJ,D2BIJKL,IJKL4,
     &               IFLAG,IOPTION,HESS,G)
C
C       I-> IP
C       J-> JP
C       K-> KP
C       L-> LP
C       (IP,JP,KP AND LP in GROUP A, PAIR FACTOR=-1.0
C
           KLG = IJ00(KG,LG)
           DO IP=1, MORBI
           IPX = IP + NOBADDI
           I2IP= (IP-1)*MORBJ + I
           IJG = IJ00(IPX,JG)
           IJKLG = IJ00(IJG,KLG)
           DERV(I2IP) = DERV(I2IP) - D2B(IJKL)*G(IJKLG)
           END DO
           DO JP=1, MORBI
           JPX = JP + NOBADDI
           J2JP= (JP-1)*MORBJ + J
           IJG = IJ00(IG,JPX)
           IJKLG = IJ00(IJG,KLG)
           DERV(J2JP) = DERV(J2JP) - D2B(IJKL)*G(IJKLG)
           END DO
           IJG = IJ00(IG,JG)
           DO KP=1, MORBI
           KPX = KP + NOBADDI
           K2KP= (KP-1)*MORBJ + K
           KLG = IJ00(KPX,LG)
           IJKLG = IJ00(IJG,KLG)
           DERV(K2KP) = DERV(K2KP) - D2B(IJKL)*G(IJKLG)
           END DO
           DO LP=1, MORBI
           LPX = LP + NOBADDI
           L2LP= (LP-1)*MORBJ + L
           KLG = IJ00(KG,LPX)
           IJKLG = IJ00(IJG,KLG)
           DERV(L2LP) = DERV(L2LP) - D2B(IJKL)*G(IJKLG)
           END DO
        END DO
        END DO
      END DO
      END DO
      ELSE
C
C     GROUP MJ IS A HF GROUP
C
      DO I=1,MORBJ
      DO J=1,I
      IJ=I*(I-1)/2+J
      IG=I+NOBADDJ
      JG=J+NOBADDJ
      IJG=IJ00(IG,JG)
        DO K=1,I
        LL=K
        IF(K.EQ.I) LL=J
        DO L=1,LL
        KG=K+NOBADDJ
        LG=L+NOBADDJ
        KL=K*(K-1)/2+L
        KLG=IJ00(KG,LG)
        IJKLG=IJ00(IJG,KLG)
             DDD=0.0D0
               IF(IJ.EQ.KL) THEN
                DDD=1.0D0
                    IF(I.NE.J) DDD=-2.0D0
               ELSE IF(I.EQ.J.AND.K.EQ.L) THEN
               DDD=4.0D0
               END IF
        IF(DDD.NE.0.0D0) THEN
        ETEMP=ETEMP+DDD*G(IJKLG)
        IJKL4(1) = I
        IJKL4(2) = J
        IJKL4(3) = K
        IJKL4(4) = L
        CALL HESSGAB(MORBI,MORBJ,NOBADDI,NOBADDJ,DDD,IJKL4,
     &               IFLAG,IOPTION,HESS,G)
C
C       I-> IP
C       J-> JP
C       K-> KP
C       L-> LP
C       (IP,JP,KP AND LP in GROUP A, PAIR FACTOR=-1.0
C
           D2BIJKL = DDD
           KLG = IJ00(KG,LG)
           DO IP=1, MORBI
           IPX = IP + NOBADDI
           I2IP= (IP-1)*MORBJ + I
           IJG = IJ00(IPX,JG)
           IJKLG = IJ00(IJG,KLG)
           DERV(I2IP) = DERV(I2IP) - D2BIJKL*G(IJKLG)
           END DO
           DO JP=1, MORBI
           JPX = JP + NOBADDI
           J2JP= (JP-1)*MORBJ + J
           IJG = IJ00(IG,JPX)
           IJKLG = IJ00(IJG,KLG)
           DERV(J2JP) = DERV(J2JP) - D2BIJKL*G(IJKLG)
           END DO
           IJG = IJ00(IG,JG)
           DO KP=1, MORBI
           KPX = KP + NOBADDI
           K2KP= (KP-1)*MORBJ + K
           KLG = IJ00(KPX,LG)
           IJKLG = IJ00(IJG,KLG)
           DERV(K2KP) = DERV(K2KP) - D2BIJKL*G(IJKLG)
           END DO
           DO LP=1, MORBI
           LPX = LP + NOBADDI
           L2LP= (LP-1)*MORBJ + L
           KLG = IJ00(KG,LPX)
           IJKLG = IJ00(IJG,KLG)
           DERV(L2LP) = DERV(L2LP) - D2BIJKL*G(IJKLG)
           END DO
        END IF
        END DO
        END DO
      END DO
      END DO
      END IF
C
C    INTERACTION OF GROUP MI AND MJ
C
      IFLAG(1) = 1
      IFLAG(2) = 1
      IFLAG(3) =-1
      IFLAG(4) =-1
      DO I=1,MORBI
      DO J=1,I
      FACIJ = 2.0D0
      IF(I.EQ.J) FACIJ=1.0D0
      IJ=IJ00(I,J)
      IG=I+NOBADDI
      JG=J+NOBADDI
      IJG=IJ00(IG,JG)
      DO K=1,MORBJ
      DO L=1,MORBJ
      KL=IJ00(K,L)
      KG=K+NOBADDJ
      LG=L+NOBADDJ
      KLG=IJ00(KG,LG)
      IJKLG=IJ00(IJG,KLG)
      IKG=IJ00(IG,KG)
      JLG=IJ00(JG,LG)
      IKJLG=IJ00(IKG,JLG)
      D1AB=D1A(IJ)*D1B(KL)*FACIJ
      ETEMP=ETEMP+D1AB*(G(IJKLG)-0.5D0*G(IKJLG))
      IJKL4(1) = I
      IJKL4(2) = J
      IJKL4(3) = K
      IJKL4(4) = L
      CALL HESSGAB(MORBI,MORBJ,NOBADDI,NOBADDJ,D1AB,IJKL4,
     &             IFLAG,IOPTION,HESS,G)
C
C     SYMMETRY, REDUCE IT
C
C     I->IP, J->JP  (IP,JP in GROUP B, PAIR FACTOR = 1.0D0)
C     K->KP, L->LP  (KP,LP IN GROUP A, PAIR FACTOR =-1.0D0)
C
        DO IP = 1, MORBJ
        IPX = IP + NOBADDJ
        I2IP= (I-1)*MORBJ + IP
        IJG = IJ00(IPX,JG)
        KLG = IJ00(KG,LG)
        IKG = IJ00(IPX,KG)
        JLG = IJ00(JG,LG)
        IJKLG=IJ00(IJG,KLG)
        IKJLG=IJ00(IKG,JLG)
        DERV(I2IP) = DERV(I2IP) + D1AB*(G(IJKLG)-0.5D0*G(IKJLG))
        END DO
        DO JP = 1, MORBJ
        JPX = JP + NOBADDJ
        J2JP= (J-1)*MORBJ + JP
        IJG = IJ00(IG,JPX)
        KLG = IJ00(KG,LG)
        IKG = IJ00(IG,KG)
        JLG = IJ00(JPX,LG)
        IJKLG=IJ00(IJG,KLG)
        IKJLG=IJ00(IKG,JLG)
        DERV(J2JP) = DERV(J2JP) + D1AB*(G(IJKLG)-0.5D0*G(IKJLG))
        END DO
        DO KP = 1, MORBI
        KPX = KP + NOBADDI
        K2KP= (KP-1)*MORBJ + K
        IJG = IJ00(IG,JG)
        KLG = IJ00(KPX,LG)
        IKG = IJ00(IG,KPX)
        JLG = IJ00(JG,LG)
        IJKLG=IJ00(IJG,KLG)
        IKJLG=IJ00(IKG,JLG)
        DERV(K2KP) = DERV(K2KP) - D1AB*(G(IJKLG)-0.5D0*G(IKJLG))
        END DO
        DO LP = 1, MORBI
        LPX = LP + NOBADDI
        L2LP= (LP-1)*MORBJ + L
        IJG = IJ00(IG,JG)
        KLG = IJ00(KG,LPX)
        IKG = IJ00(IG,KG)
        JLG = IJ00(JG,LPX)
        IJKLG=IJ00(IJG,KLG)
        IKJLG=IJ00(IKG,JLG)
        DERV(L2LP) = DERV(L2LP) - D1AB*(G(IJKLG)-0.5D0*G(IKJLG))
        END DO
      END DO
      END DO
      END DO
      END DO
C
C     PRINT DERV
C
C     WRITE(IOUTVB,*)'DERV FROM MIXGIJ'
C     DO I=1, MORBI*MORBJ
C     WRITE(IOUTVB,'(I4,F10.7)')I,DERV(I)
C     END DO
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     FUNCTION: COMPUTE HESSIAN OF RIGID ROTATION BETWEEN GROUP I AND J
C
C     NOTES:
C             W(MMS): SCRATCH
C             W(MMH): CORE H
C             W(MMG): 2E IN ORTHOGONAL BASIS FUNCTIONS
C             FKN:    FOCK MATRICES
C             IOPTION: 1 (FULL HESSIAN FOR GROUP I,J), 0 (BLOCK DIAGONAL)
C
C     HISTORY:
C
C             First version: June 30, 2004
C
C     AUTHOR:
C             Jiabo Li
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE MIXHFK(NBASIS,MORBI,MORBJ,MTDI,MTDJ,NOBADDI,NOBADDJ,
     &           HEFF,D1A,D1B,D2A,D2B,G,IOPTION,FKN,FKMO,DERV,HESS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION HEFF(*),D1A(*),D1B(*),D2A(*),D2B(*),G(*),DERV(*),HESS(*)
      DIMENSION FKN(*),FKMO(*),HESSX(10000)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     LOGICAL BLKHESS
C     BLKHESS = .FALSE.
C
C     CHECK BOUNDARY
C
      IF(MORBJ.GT.100) CALL ABORT0('MIXHFK0001')
C     IF(IOPTION.EQ.0) BLKHESS=.TRUE.
      DO I=1, MORBI*MORBJ
      DERV(I) = 0.0D0
      END DO
      NDH1 = MORBI*MORBJ
      NDH2 = NDH1*(NDH1+1)/2
      DO I=1, NDH2
      HESS(I) = 0.0D0
      END DO
      NBA2 = NBASIS*(NBASIS+1)/2
C
C     HEFF OF GROUP J
C
      DO I=1, NBA2
      HEFF(I) = HEFF(I) + FKN(I)
      END DO
C
C     CHECK FKN AND FKMO
C
      DO I=1, NBA2
      AAA = 0.0D0
        DO J=1, MORBI
        JJ = (J-1)*NBA2
        AAA = AAA + FKMO(I+JJ)
        END DO
      CDIFF = ABS(AAA-FKN(I))
      IF(CDIFF.GT.1.0D-7) WRITE(IOUTVB,*)'CDIFF =',CDIFF
      END DO

C
C     COMPUTE HESSIAN OF MO-I AND GROUP J
C
      DO I=1, MORBI
      IH = (I-1)*MORBJ
      IH1= IH+1
C
C     HEFF OF MO-I
C
      II = (I-1)*NBA2
        DO J=1, NBA2
        HEFF(J) = HEFF(J) - FKMO(II+J)
        END DO
C
C     CALL MIXGIJ
C
      MORBIX = 1
      MTDIX  = MTDI
      NOBADDIX = NOBADDI + I - 1
      CALL MIXGIJ(MORBIX,MORBJ,MTDIX,MTDJ,NOBADDIX,NOBADDJ,HEFF,
     &            D1A,D1B,D2A,D2B,G,IOPTION,DERV(IH1),HESSX)
C
C     SET BACK HEFF
C
        DO J=1, NBA2
        HEFF(J) = HEFF(J) + FKMO(II+J)
        END DO
C
C     MAP BACK HESSIAN
C
      DO K=1, MORBJ
      DO L=1, K
      KL = IJ00(K,L)
      KLH = IJ00(K+IH,L+IH)
      HESS(KLH) = HESSX(KL)
      END DO
      END DO
C
C     LOOP OF ORBITAL I
C
      END DO
      RETURN
      END
      SUBROUTINE MIXVIR(MORBI,MORBJ,MTDI,NOBADDI,NOBADDJ,HEFF,
     &                  D1A,D2A,G,IOPTION,DERV,HESS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     COMMON /IBB/IB(100000),MWINZ,MBORZ
      COMMON /IDD/ID(100000)
      DIMENSION HEFF(*),D1A(*),D2A(*),G(*),DERV(*),HESS(*)
      DIMENSION IJKL4(4),IFLAG(4)
      LOGICAL BLKHESS,COMPHESS
      BLKHESS = .FALSE.
      IF(IOPTION.EQ.0) BLKHESS=.TRUE.
      DO I=1, MORBI*MORBJ
      DERV(I) = 0.0D0
      END DO
      NDH1 = MORBI*MORBJ
      NDH2 = NDH1*(NDH1+1)/2
      DO I=1, NDH2
      HESS(I) = 0.0D0
      END DO
C
C     ENERGY OF GROUP I IN THE HEFF
C
C     ETEMP = 0.0D0
      IJ = 0
      DO I=1,MORBI
      DO J=1, I
      IG = I + NOBADDI
      JG = J + NOBADDI
      IJ = IJ + 1
      IJG=IJ00(IG,JG)
      FAC = 1.0D0
      IF(I.NE.J) FAC = 2.0D0
      D1AIJ = D1A(IJ)*FAC
C     ETEMP = ETEMP + FAC*D1A(IJ)*HEFF(IJG)
C
C       I-> IP (IP in GROUP B)
C       J-> IP
C
        DO IP=1, MORBJ
        I2IP = (I-1)*MORBJ + IP
        IX1  = IP
        IPX  = NOBADDJ+ IP
        IJX = IJ00(IPX,JG)
        DERV(I2IP) = DERV(I2IP) + D1AIJ*HEFF(IJX)
C       GOTO 991
C
C       HESS
C          IP -> IPP (IPP in GROUP A)
C          J  -> JP  (JP in GROUP B)
           DO IPP = 1, MORBI
           IP2I  = (IPP-1)*MORBJ + IP
           IX2   = IP
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(IP2I.GE.I2IP.AND.COMPHESS) THEN
           IPPX  = NOBADDI + IPP
           IJHES = IJ00(I2IP,IP2I)
           IJXX  = IJ00(IPPX,JG)
           HESS(IJHES) = HESS(IJHES) - D1AIJ*HEFF(IJXX)
           END IF
           END DO
           DO JP = 1, MORBJ
           J2JP  = (J-1)*MORBJ + JP
           IX2   = JP
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(J2JP.GE.I2IP.AND.COMPHESS) THEN
           JPX   = NOBADDJ + JP
           IJXX  = IJ00(IPX,JPX)
           IJHES = IJ00(I2IP,J2JP)
           HESS(IJHES) = HESS(IJHES) + D1AIJ*HEFF(IJXX)
           END IF
           END DO
C991       CONTINUE
        END DO
        DO JP=1, MORBJ
        J2JP = (J-1)*MORBJ + JP
        IX1  = JP
        JPX  = NOBADDJ+ JP
        IJX  = IJ00(IG,JPX)
        DERV(J2JP) = DERV(J2JP) + D1AIJ*HEFF(IJX)
C       GOTO 992
C
C       HESS
C          I  -> IP
C          JP -> JPP
           DO IP = 1, MORBJ
           I2IP = (I-1)*MORBJ + IP
           IX2   = IP
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(I2IP.GE.J2JP.AND.COMPHESS) THEN
           IPX  = NOBADDJ + IP
           IJXX = IJ00(IPX,JPX)
           IJHES= IJ00(I2IP,J2JP)
           HESS(IJHES) = HESS(IJHES) + D1AIJ*HEFF(IJXX)
           END IF
           END DO
           DO JPP=1, MORBI
           JP2J = (JPP-1)*MORBJ + JP
           IX2   = JP
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(JP2J.GE.J2JP.AND.COMPHESS) THEN
           JPPX = NOBADDI + JPP
           IJHES= IJ00(J2JP,JP2J)
           IJXX = IJ00(IG,JPPX)
           HESS(IJHES) = HESS(IJHES) - D1AIJ*HEFF(IJXX)
           END IF
           END DO
C992       CONTINUE
        END DO
      END DO
      END DO
      IFLAG(1) = 1
      IFLAG(2) = 1
      IFLAG(3) = 1
      IFLAG(4) = 1
C
C     IF GROUP I IS NOT A HF GROUP
C
      IF(MTDI.NE.1) THEN
      DO I=1,MORBI
      II = I*(I-1)/2
      IG = I+NOBADDI
      IIG= IG*(IG-1)/2
      DO J=1,I
      IJ = II+J
      JG = J+NOBADDI
      IJG= IIG + JG
        DO K=1,I
        LL  = K
        KK  = K*(K-1)/2
        KG  = K+NOBADDI
        KKG = KG*(KG-1)/2
        IF(K.EQ.I) LL=J
        DO L=1,LL
        LG = L+NOBADDI
        KL = KK+L
        KLG= KKG + LG
        IJKLG= IJ00(IJG,KLG)
        IJKL = IJ00(IJ,KL)
        D2AIJKL = D2A(IJKL)
C       ETEMP=ETEMP+D2A(IJKL)*G(IJKLG)
        IJKL4(1) = I
        IJKL4(2) = J
        IJKL4(3) = K
        IJKL4(4) = L
        CALL HESSVIR(MORBI,MORBJ,NOBADDI,NOBADDJ,D2AIJKL,IJKL4,
     &               IFLAG,IOPTION,HESS,G)
C
C       I-> IP
C       J-> JP
C       K-> KP
C       L-> LP
C       (IP,JP,KP AND LP in GROUP B, PAIR FACTOR=1.0
C
           KLG = IJ00(KG,LG)
           DO IP=1, MORBJ
           IPX = IP + NOBADDJ
           I2IP= (I-1)*MORBJ + IP
           IJG = IJ01(IPX,JG)
           IJKLG = ID(IJG)+KLG
           DERV(I2IP) = DERV(I2IP) + D2A(IJKL)*G(IJKLG)
           END DO
           DO JP=1, MORBJ
           JPX = JP + NOBADDJ
           J2JP= (J-1)*MORBJ + JP
           IJG = IJ01(IG,JPX)
           IJKLG = ID(IJG)+KLG
           DERV(J2JP) = DERV(J2JP) + D2A(IJKL)*G(IJKLG)
           END DO
           IJG = IJ00(IG,JG)
           DO KP=1, MORBJ
           KPX = KP + NOBADDJ
           K2KP= (K-1)*MORBJ + KP
           KLG = IJ01(KPX,LG)
           IJKLG = ID(KLG)+IJG
           DERV(K2KP) = DERV(K2KP) + D2A(IJKL)*G(IJKLG)
           END DO
           DO LP=1, MORBJ
           LPX = LP + NOBADDJ
           L2LP= (L-1)*MORBJ + LP
           KLG = IJ01(KG,LPX)
           IJKLG = ID(KLG)+IJG
           DERV(L2LP) = DERV(L2LP) + D2A(IJKL)*G(IJKLG)
           END DO
        END DO
        END DO
      END DO
      END DO
      ELSE
      CALL ABORT0('MIXVIR0001')
      END IF
C
C     PRINT DERV
C
C     WRITE(IOUTVB,*)'DERV FROM MIXVIR'
C     DO I=1, MORBI*MORBJ
C     WRITE(IOUTVB,'(I4,F10.7)')I,DERV(I)
C     END DO
      RETURN
      END
      SUBROUTINE HESSGAB(MORBI,MORBJ,NOBADDI,NOBADDJ,D2AIJKL,
     &                   IJKL1,IFLAG1,IOPTION,HESS,G)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IJKL1(4),IJKL2(4),IJKL3(4),IFLAG1(4),IFLAG2(4),IFLAG3(4)
      DIMENSION HESS(*),G(*),IJKL4(4)
      LOGICAL BLKHESS,COMPHESS
      BLKHESS = .FALSE.
      IF(IOPTION.EQ.0) BLKHESS = .TRUE.
      DO JA=1,4
        DO IX=1, 4
        IFLAG2(IX) =  IFLAG1(IX)
        IJKL2(IX)  =  IJKL1(IX)
        END DO
        IFLAG2(JA) = -IFLAG1(JA)
        IF(IFLAG1(JA).EQ.1) THEN
        FAC1  = 1.0D0
        MORBX = MORBJ
        ELSE
        MORBX = MORBI
        FAC1  = -1.0D0
        END IF
      DO IP=1, MORBX
        IF(IFLAG1(JA).EQ.1) THEN
        JH1 = (IJKL1(JA)-1)*MORBJ + IP
        IX1 = IJKL1(JA)
        ELSE
        JH1 = (IP-1)*MORBJ + IJKL1(JA)
        IX1 = IP
        END IF
        IJKL2(JA) = IP
        DO JB=1,4
          DO IX=1, 4
          IJKL3(IX)  = IJKL2(IX)
          IFLAG3(IX) = IFLAG2(IX)
          END DO
          IFLAG3(JB) = -IFLAG2(JB)
          IF(IFLAG2(JB).EQ.1) THEN
          MORBY = MORBJ
          FAC2  = 1.0D0
          ELSE
          MORBY = MORBI
          FAC2  =-1.0D0
          END IF
        DO JP=1, MORBY
          IF(IFLAG2(JB).EQ.1) THEN
          JH2 = (IJKL2(JB)-1)*MORBJ + JP
          IX2 = IJKL2(JB)
          ELSE
          JH2 = (JP-1)*MORBJ + IJKL2(JB)
          IX2 = JP
          END IF
          COMPHESS = .TRUE.
          IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
          IF(JH2.GE.JH1.AND.COMPHESS) THEN
          IJKL3(JB) = JP
          DO IX=1,4
            IF(IFLAG3(IX).EQ.1) THEN
              IJKL4(IX) = IJKL3(IX) + NOBADDI
            ELSE
              IJKL4(IX) = IJKL3(IX) + NOBADDJ
            END IF
          END DO
          IJG = IJ00(IJKL4(1),IJKL4(2))
          KLG = IJ00(IJKL4(3),IJKL4(4))
          IJKLG = IJ00(IJG,KLG)
          JH12  = IJ00(JH1,JH2)
          HESS(JH12) = HESS(JH12) + D2AIJKL*FAC1*FAC2*G(IJKLG)
C         CONTRI =  D2AIJKL*FAC1*FAC2*G(IJKLG)
            IF(IFLAG1(2).NE.IFLAG1(3)) THEN
            IKG = IJ00(IJKL4(1),IJKL4(4))
            JLG = IJ00(IJKL4(2),IJKL4(3))
            IKJLG = IJ00(IKG,JLG)
            HESS(JH12) = HESS(JH12) - 0.5D0*D2AIJKL*FAC1*FAC2*G(IKJLG)
C           CONTRI = CONTRI - 0.5D0*D2AIJKL*FAC1*FAC2*G(IKJLG)
            END IF
          END IF
        END DO
        END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE HESSVIR(MORBI,MORBJ,NOBADDI,NOBADDJ,D2AIJKL,
     &                   IJKL1,IFLAG1,IOPTION,HESS,G)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     COMMON /IBB/IB(100000),MWINZ,MBORZ
      COMMON /IDD/ID(100000)
      DIMENSION IJKL1(4),IJKL2(4),IJKL3(4),IFLAG1(4),IFLAG2(4),IFLAG3(4)
      DIMENSION HESS(*),G(*),IJKL4(4)
      LOGICAL BLKHESS,COMPHESS
      BLKHESS = .FALSE.
      IF(IOPTION.EQ.0) BLKHESS = .TRUE.
      DO JA=1,4
        DO IX=1, 4
        IFLAG2(IX) =  IFLAG1(IX)
        IJKL2(IX)  =  IJKL1(IX)
        END DO
        IFLAG2(JA) = -IFLAG1(JA)
        FAC1  = 1.0D0
        MORBX = MORBJ
      DO IP=1, MORBX
        JH1 = (IJKL1(JA)-1)*MORBJ + IP
        IX1 = IP
        IJKL2(JA) = IP
        DO JB=1,4
          DO IX=1, 4
          IJKL3(IX)  = IJKL2(IX)
          IFLAG3(IX) = IFLAG2(IX)
          END DO
          IFLAG3(JB) = -IFLAG2(JB)
          IF(IFLAG2(JB).EQ.1) THEN
          MORBY = MORBJ
          FAC2  = 1.0D0
          ELSE
          MORBY = MORBI
          FAC2  =-1.0D0
          END IF
        DO JP=1, MORBY
          IF(IFLAG2(JB).EQ.1) THEN
          JH2 = (IJKL2(JB)-1)*MORBJ + JP
          IX2 = JP
          ELSE
          JH2 = (JP-1)*MORBJ + IJKL2(JB)
          IX2 = IJKL2(JB)
          END IF
          COMPHESS = .TRUE.
          IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS=.FALSE.
          IF(JH2.GE.JH1.AND.COMPHESS) THEN
          IJKL3(JB) = JP
          DO IX=1,4
            IF(IFLAG3(IX).EQ.1) THEN
              IJKL4(IX) = IJKL3(IX) + NOBADDI
            ELSE
              IJKL4(IX) = IJKL3(IX) + NOBADDJ
            END IF
          END DO
          IJG = IJ01(IJKL4(1),IJKL4(2))
          KLG = IJ01(IJKL4(3),IJKL4(4))
            IF(IJG.GE.KLG) THEN
            IJKLG = ID(IJG)+KLG
            ELSE
            IJKLG = ID(KLG)+IJG
            END IF
          JH12  = IJ00(JH1,JH2)
          HESS(JH12) = HESS(JH12) + D2AIJKL*FAC1*FAC2*G(IJKLG)
          END IF
        END DO
        END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE DVDCON(MITER,BASIS,WBASIS,DM1NON,DM2NON,GDMP,WRK1,
     & W,MSIZE,ENR,ETOTAL,LASTITER)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C               Top level group function method. This is a divide-and-conquer
C               approach to correlation problem of many electron systems.
C     Note:
C               Loop over all subunits.
C
C     GDMP:     Density of the whole system except the current subunit.
C     DM1NON:   1D density of subsystems in their LOCAL NONORTHOGONAL basis.
C     DM2NON:   2D density of subsystems in their LOCAL NONORTHOGONAL basis.
C
C     History:
C               First created in Feb. 1999.
C               Recoded in September, 1999.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      PARAMETER (ND1WRK=10000)
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
     &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
     &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /CSTRUC/CSTRUC(5000),ISTRUC(100)
      DIMENSION BASIS(*),WBASIS(*),CNORM(1000),DM1NON(*),DM2NON(*)
      DIMENSION WRK1(*),GDMP(*),MINDEX(9999),W(*),D1WRK(ND1WRK)
      ETOTAL=ENR
      ISTRUC(1)=0
      CNORM(1) =0
      NBA2=NBASIS*(NBASIS+1)/2
C     NDMP=NBA2*NSUB
C     NSSS=1
C     NWK=NSSS+NBASIS*(NBASIS+1)/2
      NOBADD1=1+MLORBIT(1)*NBASIS
C
C     ZERO GDMP !
C
      DO I=1,NBA2
      GDMP(I)=0.0D0
      END DO
C
C     ACCUMULATE GDMP
C
      IFLAG=1
      DO 100 K=2,NSUB
      NODADD1=ND1STA-1+N1DADD(K)
      CALL MATRAN2(MLORBIT(K),NBASIS,BASIS(NOBADD1),WRK1,
     &       DM1NON(N1DADD(K)),GDMP,IFLAG)
      NOBADD1=NOBADD1+MLORBIT(K)*NBASIS
 100  CONTINUE
      NODADD1=1
      NOBADD1=1
      IFLAG  =1
      NBO=0
      ISTRUC(1)=1
      DO 200 I=1,NSUB
      MGRP=I
      NBO=NBO+MLORBIT(I)
C     IDMGRP=(I-1)*NBA2
C     NDMGRP=I*NBA2
      ISTRUC(I+1)=ISTRUC(I)
C
C     SAVE A COPY TO D1WRK
C
      IF(N1DADD(I+1)-N1DADD(I).GT.ND1WRK) THEN
          WRITE(IOUTVB,*)"NUMBER OF ORBTIALS IN GROUP ",I," > 140"
          CALL ABORT0('DVDCON01  ')
      END IF
      DO K=1,N1DADD(I+1)-N1DADD(I)
      D1WRK(K)=DM1NON(N1DADD(I)-1+K)
      END DO
C
C     CALL WINDEX TO SET UP ORBITAL WINDOW INDEX
C
      CALL WINDEX(I,MBASIS,MWIN(I),IBASIS,MINDEX)
C
C     COLLECT ORBITALS WHICH ARE OPEN TO THE SUBUNIT
C
      CALL COLBAS(NBASIS,BASIS,WBASIS,MINDEX,MWIN(I))
      IF(MELE(I).GT.0) THEN
      CALL GENSCF(METHOD(I),MELE(I),MSPIN(I),NBASIS,MLORBIT(I),
     & MWIN(I),WBASIS,GDMP,DM1NON(N1DADD(I)),
     & DM2NON(N2DADD(I)),W,MSIZE,MITER,MGRP,LPTALL,LASTITER)
C    & DM2NON(N2DADD(I)),W,MSIZE,ETOTAL,MITER,MGRP,LPTALL,LASTITER)
      ELSE
       DO KK=N1DADD(I),N1DADD(I+1)-1
          DM1NON(KK) = 0.0D0
       END DO
       DO KK=N2DADD(I),N2DADD(I+1)-1
          DM2NON(KK) = 0.0D0
       END DO
      END IF
C
C     POSSIBLE SYMMETRY CORRECTION
C
      MGRP = I
C     MAXL = 4
      CALL SYMVBO(MGRP,MLORBIT(I),WBASIS,W,ISYMOPER,CNORM)
C
C     UPDATE ORBITALS
C
      CALL MODBAS(NBASIS,BASIS,WBASIS,MINDEX,MWIN(I))
C
C     UPDATE DENSITY MATRICES
C
      IF(NOBIAS.NE.1) THEN
      CALL MATRAN2(MLORBIT(I),NBASIS,BASIS(NOBADD1),WRK1,
     &             DM1NON(N1DADD(I)),GDMP,IFLAG)
      ELSE
      CALL MATRAN2(MLORBIT(I),NBASIS,BASIS(NOBADD1),WRK1,
     &             D1WRK(1),GDMP,IFLAG)
      END IF
      NODADD1=NODADD1+MLORBIT(I)*(MLORBIT(I)+1)/2
      NOBADD1=NOBADD1+MLORBIT(I)*NBASIS
C
C     SUBSTRACT THE 1D DENSITY FOR THE NEXT SUB GROUP.
C     IF IT IS THE LAST ONE, DON'T DO THIS, AND GDMP IS THE FULL
C     1D DENSITY
C
      NFLAG=-IFLAG
      IF(I.LT.NSUB) THEN
      CALL MATRAN2(MLORBIT(I+1),NBASIS,BASIS(NOBADD1),WRK1,
     &             DM1NON(N1DADD(I+1)),GDMP,NFLAG)
      END IF
  200 CONTINUE
C
C     SAVE BASIS AND GDM
C
C400  CONTINUE
      NDM1 = ND2STA-ND1STA
      CALL GETIOUNIT('IOVBORB ',IOVBORB)
      REWIND(IOVBORB)
      WRITE(IOVBORB)NSUB,NDM1,(MELE(I),I=1,NSUB),
     &              (MLORBIT(I),I=1,NSUB),(METHOD(I),I=1,NSUB)
C
C     Compute NORBX
C
      NORBX = 0
      DO I=1, NSUB
         NORBX = NORBX + MLORBIT(I)
      ENDDO
      IF(NORBX.LT.NBASIS) NORBX = NBASIS
      WRITE(IOVBORB)NBASIS,NATOM,NORBX,(BFLABE(I),I=1,NBASIS)
      WRITE(IOVBORB)(BASIS(I),I=1,NBASIS*NORBX)
      WRITE(IOVBORB)(DM1NON(I),I=1,NDM1)
      RETURN
C1000 FORMAT(/' ORBITALS IN AO BASIS: # OF ORBITAL(GROUP)'/)
C1100 FORMAT(/1X,8(I5,'(',I2,')'))
C1200 FORMAT(1X,8F9.6)
C1300 FORMAT(/' MACRO-ITERATION ENERGY',I5,F20.14/)
C1400 FORMAT(/
C    &/' ==========================================================='
C    &       /' SUBUNIT:',I2,',METHOD:',I2,',NUMBER OF ORBITALS:',I3,
C    &        ',WINDOW-SIZE:',I3
C    &/' ==========================================================='/)
      END
C
C     THE NEW ORBITAL COEFFICIENTS IN LOCAL BASIS FUNCTIONS
C     BASIS.ORBLOC = WBASIS
C
C     X(T)X V' = X(T)V
C     BASIS(T)BASIS.ORBLOC = BASIS(T).WBASIS
C
      SUBROUTINE LSFIT(NBASIS,NORB,BASIS,WBASIS,ORBLOC,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION BASIS(NBASIS,*),WBASIS(NBASIS,*),ORBLOC(NORB,NORB)
      DIMENSION W(*)
C     DO I=1, NORB
C        WRITE(IOUTVB,'(I3,4F12.8)')I,(ORBLOC(I,J),J=1,NORB)
C     ENDDO
      MXX = 1
      MXV = MXX + NORB*NORB
      MVP = MXV + NORB*NORB
      MXT = MVP + NORB*NORB
      DO I=1, NORB
      II = (I-1)*NORB
      DO J=1, NORB
         SUX = 0.0D0
         SUM = 0.0D0
         DO K=1, NBASIS
           SUM = SUM + BASIS(K,J)*BASIS(K,I)
           SUX = SUX + BASIS(K,J)*WBASIS(K,I)
         ENDDO
         W(MXX-1+II+J) = SUM
         W(MXV-1+II+J) = SUX
      ENDDO
      ENDDO
C
C     SOLVE LINEAR EQ
C     W(MXX).W(MVP) = W(MXV)
C
      CALL SOLVER(NORB,W(MXX),W(MVP),W(MXV),W(MXT),NORB)
      DO I=1, NORB
      DO J=1, NORB
        ORBLOC(I,J) = W(MVP-1+I+(J-1)*NORB)
      ENDDO
      ENDDO
C     DO I=1, NORB
C        WRITE(IOUTVB,'(I3,4F12.8)')I,(ORBLOC(I,J),J=1,NORB)
C     ENDDO
      RETURN
      END
C
C     THE NEW ORBITALS MUST IN THE ORIGINAL SPACE
C
C     MIRROR(I) = 0, NON-MIRROR OPERATION
C                 1, MIRROR OPERATION
C                 2, X-MIRROR OPERATION
C                 3, Y-MIRROR OPERATION
C                 4, Z-MIRROR OPERATION
C
      SUBROUTINE SYMVBO(MGRP,NORB,BASIS,W,ISYMOPER,CNORM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 FLAG
      CHARACTER*12 BFLABE
      CHARACTER*10 NUMBER
      CHARACTER*20 BASNAME
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      DIMENSION BASIS(*),W(*),VT(1000),MOPER(10000),IOPERJ(4,100)
      DIMENSION MIRROR(1000),VTP(1000),CNORM(*)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      ISYMOPER = 0
      NUMBER   = '0123456789'
      NC1      = 1+MGRP/10
      NC2      = 1+MGRP-10*(NC1-1)
      FLAG     = '$'
      FLAG(2:2)= NUMBER(NC1:NC1)
      FLAG(3:3)= NUMBER(NC2:NC2)
      FLAG(4:9)='SYMORB'
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,FLAG,9,IOK,0)
      IF(IOK.EQ.0) RETURN
      ISYMOPER = 1
      READ(IOENGI,*)NOPER
      IF(NATOM*NOPER.GT.10000) CALL ABORT0("SYMORB0001")
C
C     READ SYM OPERATION DEFINITION
C
      DO I=1, NOPER
      II = (I-1)*NATOM
      READ(IOENGI,*)MIRROR(I),(MOPER(II+J),J=1,NATOM)
      ENDDO
C
C     READ SYM OPERATIONS ON ORBITALS
C
C     FORMAT: IB, IO, JB
C             ORBITAL IB TRANSFORMED TO ORBITAL JB UNDER OPERATION IO
C
      READ(IOENGI,*)NSYM
      DO I=1, NSYM
       READ(IOENGI,*)(IOPERJ(J,I),J=1,3)
      ENDDO
      CALL GETIOUNIT('IAO1E   ',IAO1E)
C
      NB2     = NBASIS*NBASIS
      MSS = 1
      MHH = MSS + NB2
      MS0 = MSS + NB2
      MVV = MS0 + NBASIS*NBASIS
      MV1 = MVV + NBASIS*NBASIS
      MV2 = MV1 + NBASIS*NBASIS
      CALL READ1E(IAO1E,W(MSS),W(MHH),NBASIS)
      DO I=1, NBASIS
      II = (I-1)*NBASIS
      DO J=1, NBASIS
      W(MS0-1+II+J) = W(MSS-1+IJ00(I,J))
      ENDDO
      ENDDO
      CALL SHMIDT2(NBASIS,NORB,BASIS,W(MS0),NB,W(MVV))
      DO I=1, NSYM
        IBAS = (I-1)*NBASIS+1
        IA = (I-1)*NATOM+1
        IB = (IOPERJ(1,I)-1)*NBASIS+1
        IO = (IOPERJ(2,I)-1)*NATOM+1
        JB = (IOPERJ(3,I)-1)*NBASIS+1
        CNORM(IOPERJ(3,I)) = CNORM(IOPERJ(1,I))
CLIC    CALL SYMOPER(MIRROR(I),MOPER(IO),BASIS(IB),VT,MAXL)
C
C       PROJECT TO MVV SPACE
C
        IPROJ = 0
        IF(IPROJ.EQ.1) THEN
         CALL PROJEC(NBASIS,1,NB,W(MS0),VT,W(MVV),VTP,W(MV1))
        ELSE
         DO J=1,NBASIS
           VTP(J) = VT(J)
         ENDDO
        ENDIF
        IF(IB.EQ.JB) THEN
         WRITE(IOUTVB,*)"Before AVE"
         DO J=1,NBASIS
           WRITE(IOUTVB,'(2F20.10)')BASIS(JB-1+J),VTP(J)
         ENDDO
         CALL AVEORB(NBASIS,BASIS(JB),VTP)
         WRITE(IOUTVB,*)"After AVE"
         DO J=1,NBASIS
           WRITE(IOUTVB,'(2F20.10)')BASIS(JB-1+J),VTP(J)
         ENDDO
        ELSE
         DO J=1,NBASIS
C         WRITE(IOUTVB,'(I5,A10,F12.8)')J,BFLABE(J),VTP(J)
C         WRITE(IOUTVB,'(I5,A10,F12.8)')J,BFLABE(J),BASIS(JB-1+J)
          BASIS(JB-1+J) = VTP(J)
         END DO
        END IF
      ENDDO
CGMS  JUNKGMS = IA+IBAS+IO+MIRROR(1)+MOPER(1)+MV2
CGMS  IF (MGRP.GT.10000) WRITE(IOUTVB,*)"PRINT STUPID THINGS: ",JUNKGMS
      RETURN
      END
      SUBROUTINE AVEORB(NBASIS,BASIS,VTP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION BASIS(*),VTP(*)
C
C     TAKE AVERAGE OF BASIS AND VTP
C
      PROD = 0.0D0
      DO I=1, NBASIS
      PROD = PROD + BASIS(I)*VTP(I)
      END DO
      IF(PROD .GT. 0) THEN
        DO I=1, NBASIS
        BASIS(I) = (BASIS(I)+VTP(I))*0.5D0
        END DO
      ELSE
        DO I=1, NBASIS
        BASIS(I) = (BASIS(I)-VTP(I))*0.5D0
        END DO
      END IF
      RETURN
      END
      SUBROUTINE ROTRAN(RWRK,G,MSIZE,ETOTAL,MITER)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Top level of rigid rotation algorithm.
C     Notes:
C               G: global work field(the first portion will hold hessain).
C               MSIZE: size of the work field.
C               IRDEX(3,*): rotation parameter indexes.
C
C               Minimal scratch space: NDH2 + MAX(MSCR1,MSCR3) of HESSTE
C
C
C     History:
C               First created in Feb. 1999.
C               Recoded in September, 1999.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MAPSIZE=10000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
C     DIMENSION CNORM(1000),RWRK(*),G(*)
      DIMENSION RWRK(*),G(*)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
     &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
     &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION NHDADD(5000),IDIMGRP(5000),NHESADD(5000)
      DIMENSION RVEC(MAPSIZE),RDEV(MAPSIZE),IRDEX(3,MAPSIZE)
      DIMENSION DDEV(MAPSIZE)
      DIMENSION NORBADD(100)
      LOGICAL DIAGHESS
C     TIME1 = XCLOCK()
C
C     SET UP INDEXES
C
      NORBADD(1)= 0
      NHESADD(1)= 0
      NHDADD(1) = 0
      NHFORB = 0
      DO 20 I=1,NSUB
      IF(METHOD(I).EQ.1) NHFORB = NHFORB + MLORBIT(I)
 20   NORBADD(I+1)= NORBADD(I)+MNORBIT(I)
C
C     NHGRP: INDEX OF HESSIAN GROUP
C     NHDIM: DIMENSION OF HESSIAN MATRIX
C
C     TODO: REMOVE MAPBRI
C
      NHGRP=0
      NHDIM=0
      DO 3 I=1,NSUB-1
      DO 3 J=I+1,NSUB
      IF (NOTROT((J-1)*(J-2)/2+I).EQ.0) THEN
      NDIMGRP=MNORBIT(I)*MNORBIT(J)
      NHGRP=NHGRP+1
      NHESADD(NHGRP+1)=NHESADD(NHGRP)+NDIMGRP*(NDIMGRP+1)/2
      NHDADD(NHGRP+1) =NHDADD(NHGRP)+NDIMGRP
      IDIMGRP(NHGRP)=NDIMGRP
         DO 4 K=1,MNORBIT(I)
         DO 4 L=1,MNORBIT(J)
         NHDIM=NHDIM+1
C
C        CHECK BOUNDARY
C
         IF(NHDIM.GT.MAPSIZE) THEN
           WRITE(IOUTVB,*)
     &      "HESSIAN MATRIX FOR RIGID ROTATION IS TOO LARGE"
           CALL ABORT0('ROTRAN01  ')
         END IF
         IRDEX(1,NHDIM)=NORBADD(I)+K
         IRDEX(2,NHDIM)=NORBADD(J)+L
         IRDEX(3,NHDIM)=NHGRP
 4    CONTINUE
      END IF
 3    CONTINUE
      NOCB=NORBADD(NSUB+1)
C
C     VIRTUAL ORBITALS
C
C     NVIRX=NBASIS-NOCB
      DO 5 I=1,NSUB
      IF (NOTROT(NSUB*(NSUB-1)/2+I).EQ.0) THEN
      NDIMGRP=MNORBIT(I)*NVIR
      NHGRP=NHGRP+1
      NHESADD(NHGRP+1)=NHESADD(NHGRP)+NDIMGRP*(NDIMGRP+1)/2
      NHDADD(NHGRP+1) =NHDADD(NHGRP)+NDIMGRP
      IDIMGRP(NHGRP)=NDIMGRP
         DO 6 K=1,MNORBIT(I)
         DO 6 L=1,NVIR
         NHDIM=NHDIM+1
C
C        CHECK BOUNDARY
C
         IF(NHDIM.GT.MAPSIZE) THEN
           WRITE(IOUTVB,*)
     &      "HESSIAN MATRIX FOR RIGID ROTATION IS TOO LARGE"
           CALL ABORT0('ROTRAN02  ')
         END IF
         IRDEX(1,NHDIM)=NORBADD(I)+K
         IRDEX(2,NHDIM)=NOCB+L
         IRDEX(3,NHDIM)=NHGRP
  6   CONTINUE
      END IF
  5   CONTINUE
C
C     SETUP ADDRESSES AND CONTROLS
C
      IFIX = 1
      NSSS = 1
      NDH2 = NHESADD(NHGRP+1)
      NWK1 = NSSS+NBASIS*(NBASIS+1)/2
      NSTART = 1
      NHESS  = NSTART
      NHESS2 = NHESS  + NDH2
      NFORKS = NHESS2 + NDH2
      NWRK   = NFORKS + (NSUB+1+NHFORB)*NBASIS*(NBASIS+1)/2
      NWK2   = NFORKS
      LDNSS = NWK2
      LDNHH = LDNSS + NBASIS*(NBASIS+1)/2
      MSIZEA=MSIZE-NBASIS*(NBASIS+1)
      MSIZEB=MSIZE-NWRK
      MSIZEC=MSIZE-NWK1
      IF(MSIZEA.LE.0.OR.MSIZEB.LE.0) CALL ABORT0('ROTRAN03  ')
C
C     DIAGONAL HESS ONLY
C
      DIAGHESS = .FALSE.
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$DIAGHESS',9,IOK,0)
      IF(IOK.EQ.1) DIAGHESS = .TRUE.
C
C     CONSTRUCTE TRANSFORMATION MATRICES OF LOWDIN BASIS<---->NONORTHOGNAL BASIS
C     EACH GROUP HAS TWO TRANSFORMATION MATRICES (FOR FORWARD AND BACKWORD
C     TRANSFORMATION). THE MATRICES ARE STORED IN ALLDM, WITH ADDRESSES
C     MDADDR(NSUB+I)
C
C     LOWDIN ORTHOGONALIZATION OF SUBUNITS
C
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL READ1E(IAO1E,G(NSSS),G(NWK1),NBASIS)
C     CALL BASTRN(NBASIS,NSUB,MLORBIT,MNORBIT,RWRK(NAOBAS),G(NSSS),
C    &G(NWK1),MSIZEC,RWRK(LOCBAS),NB2ADD,RWRK(LAOBAS),RWRK(NOCBAS),
C    &NB2ADD)
      CALL BASTRN(NBASIS,NSUB,MLORBIT,MNORBIT,RWRK(NAOBAS),G(NSSS),
     &G(NWK1),MSIZEC,RWRK(LAOBAS),RWRK(NOCBAS),NB2ADD)
      CALL DMTRAN(NSUB,MLORBIT,MNORBIT,MELE,METHOD,RWRK(ND1STA),
     & RWRK(ND2STA),RWRK(LD1STA),RWRK(LD2STA),RWRK(NOCBAS),G(NSTART),
     & MSIZE,N1DADD,N1DADD,NB2ADD,N2DADD,N2DADD)
C     TIME2 = XCLOCK()
      IF(NHDIM.GT.0.AND.MROT.GT.0) THEN
      DO 400 IR=1,MROT
      CALL HESSTE(NBASIS,NOCB,RDEV,G(NHESS),NDH2,RWRK,NHFORB,
     & G(NFORKS),G(NWRK),RWRK(LAOBAS),NHDIM,NORBADD,NHESADD,
     & RWRK(LD1STA),RWRK(LD2STA),MSIZEB,N1DADD,N2DADD,ENREP,ETOTAL,
     & MITER)
C     TIME3 = XCLOCK()
C     WRITE(IOUTVB,*)"HESSTE = ", TIME3-TIME2
C
C     OPTIONALLY, ADD DELOCALIZATION PENALTY
C
      CALL READ1E(IAO1E,G(LDNSS),G(LDNHH),NBASIS)
C
      DO I=1, NDH2
      G(NHESS2-1+I) = 0.0D0
      ENDDO
      DO I=1, NHDIM
      DDEV(I) = 0.0D0
      ENDDO
      CALL DPENALTY2(RWRK(NAOBAS),RWRK(LAOBAS),RWRK(NOCBAS),
     &NB2ADD,G(LDNSS),NHDIM,NHDADD,NHESADD,IRDEX,G(LDNHH),DDEV,
     &G(NHESS2),NSUB,MLORBIT,MNORBIT,NHGRP,MITER)
C     TIME4 = XCLOCK()
C
C     COMPUTE ROTATION VECTOR OF WITHOUT DELOCALIZATION PENALTY
C
C     DO I=1,NHGRP
C     ERCTL=0.10D0
C     RDAMP=0.05D0
C     EPT=0.0D0
C     CALL DIAGHER(G(NHESADD(I)+NHESS),IDIMGRP(I),RDEV(NHDADD(I)+1),
C    &SEIG,G(NWK2),IFIX,DIAGHESS)
C     CALL NRDATER(IDIMGRP(I),RDEV(NHDADD(I)+1),G(NHESADD(I)+NHESS),
C    &OVEC(NHDADD(I)+1),CMAX,ERCTL,G(NWK2),RDAMP,EPT)
C     END DO
C
      DO I=1, NDH2
      G(NHESS-1+I) = G(NHESS-1+I) + G(NHESS2-1+I)
      ENDDO
      DO I=1, NHDIM
      RDEV(I) = RDEV(I) + DDEV(I)
      ENDDO
C
C     CALL NR PROCEDURE
C
C     CMAXVEC=0.0D0
      DO I=1,NHGRP
      ERCTL=0.10D0
      RDAMP=0.05D0
      EPT=0.0D0
C
C     IMPROVE CONDITION OF HESSIAN MATRIX. THIS MAY REDUCE THE PERFORMANCE
C     IN MOST CASES, THE THIS WILL MAKE THE ITERATION MORE STABLE
C
      CALL DIAGHER(G(NHESADD(I)+NHESS),IDIMGRP(I),RDEV(NHDADD(I)+1),
     &SEIG,G(NWK2),IFIX,DIAGHESS)
      CALL NRDATER(IDIMGRP(I),RDEV(NHDADD(I)+1),G(NHESADD(I)+NHESS),
     &RVEC(NHDADD(I)+1),CMAX,ERCTL,G(NWK2),RDAMP,EPT)
      END DO
C
C     PERFORM ROTATIONS
C
      CALL ROTLAO(NSUB,NBASIS,NHDIM,IRDEX,MLORBIT,MNORBIT,NB2ADD,
     & RWRK(NAOBAS),RVEC,RWRK(LAOBAS),RWRK(NOCBAS))
 400  CONTINUE
C410  CONTINUE
      ELSE
      CALL TENERGY(NBASIS,NSUB,MLORBIT,METHOD,RWRK(LAOBAS),RWRK,G(NWK2),
     &             G(NWRK),MSIZEB,RWRK(LD2STA),ENREP,ETOTAL)
      NHDIM = 0
      CALL DPENALTY2(RWRK(NAOBAS),RWRK(LAOBAS),RWRK(NOCBAS),
     &NB2ADD,G(LDNSS),NHDIM,NHDADD,NHESADD,IRDEX,G(LDNHH),DDEV,
     &G(NHESS2),NSUB,MLORBIT,MNORBIT,NHGRP,MITER)
C     TIME4 = XCLOCK()
      END IF
C
C     SAVE BASIS AND GDM
C     THERE ARE TWO LOCATIONS OF WRITE(IOVBORB)!!
C
      CALL GETIOUNIT('IOVBORB ',IOVBORB)
      REWIND(IOVBORB)
      NDM1 = ND2STA-ND1STA
      WRITE(IOVBORB)NSUB,NDM1,(MELE(I),I=1,NSUB),
     &              (MLORBIT(I),I=1,NSUB),(METHOD(I),I=1,NSUB)
C
C     Compute NORBX
C
      NORBX = 0
      DO I=1, NSUB
         NORBX = NORBX + MLORBIT(I)
      ENDDO
      IF(NORBX.LT.NBASIS) NORBX = NBASIS
C
      WRITE(IOVBORB)NBASIS,NATOM,NORBX,(BFLABE(I),I=1,NBASIS)
      WRITE(IOVBORB)(RWRK(NAOBAS-1+I),I=1,NBASIS*NORBX)
      WRITE(IOVBORB)(RWRK(I),I=ND1STA,ND2STA-1)
C
      CALL GETIOUNIT('IOTEMP  ',IOTEMP)
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL WTGUES(NBASIS,RWRK(NAOBAS),NBASIS,IOTEMP,IOENGI)
      RETURN
C1000 FORMAT(/' ORBITALS IN AO BASIS: # OF ORBITAL(GROUP)'/)
C1100 FORMAT(/1X,8(I5,'(',I2,')'))
C1200 FORMAT(1X,8F9.6)
      END
      SUBROUTINE ROTLAO(NSUB,NBASIS,NHDIM,IRDEX,MLORBIT,MNORBIT,
     &   NB2ADD,BASIS,RVEC,BASLAO,BASNOC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION BASIS(*),BASLAO(*),BASNOC(*),MLORBIT(*),IRDEX(3,*)
      DIMENSION MNORBIT(*),NB2ADD(*),RVEC(*)
      IF(NHDIM.LE.0) RETURN
      CMAX = 0.0D0
      DO I=1, NHDIM
      IF(ABS(RVEC(I)).GT.CMAX) CMAX=ABS(RVEC(I))
      END DO
C     WRITE(IOUTVB,*)'CMAX ROT = ', CMAX
      DAMP = 1.0D0
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$DAMPROT',8,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)DAMP
C
C     UPDATE LOWDIN ORBITALS
C     (PERFORM RIGID ROTATION OF LOWDIN BASIS FUNCTIONS)
C
      NSTEP=100
C     IF(NOBIAS.EQ.1) NSTEP=100
      FACTOR=DAMP/NSTEP
      DO K=1,NSTEP
      DO I=1,NHDIM
      IR1=IRDEX(1,I)
      IR2=IRDEX(2,I)
      IR1B=(IR1-1)*NBASIS
      IR2B=(IR2-1)*NBASIS
      STHETA=DSIN(FACTOR*RVEC(I))
      CTHETA=DCOS(FACTOR*RVEC(I))
C     WRITE(IOUTVB,*)'I,IR1,IR2,STHETA,CTHETA=',I,IR1,IR2,STHETA,CTHETA
C
C     A=DCOS(THETA)*A+DSIN(THETA)*B
C     B=DCOS(THETA)*B-DSIN(THETA)*A
C
        DO J=1,NBASIS
        TEMP=BASLAO(IR1B+J)
        BASLAO(IR1B+J)=CTHETA*BASLAO(IR1B+J)+STHETA*BASLAO(IR2B+J)
        BASLAO(IR2B+J)=CTHETA*BASLAO(IR2B+J)-STHETA*TEMP
        END DO
      END DO
      END DO
C
C     UPDATE NONORTHOGONAL BASIS AND VIRTUAL ORBITALS
C
      NOBT  = 1
      NOBTX = 1
      DO 250 I=1,NSUB
      IBAS =(NOBT-1)*NBASIS+1
      IBASX=(NOBTX-1)*NBASIS+1
      CALL MATMUL2(NBASIS,MNORBIT(I),MLORBIT(I),BASLAO(IBASX),
     &            BASNOC(NB2ADD(I)),BASIS(IBAS))
      NOBT =NOBT+MLORBIT(I)
      NOBTX=NOBTX+MNORBIT(I)
 250  CONTINUE
C
C     BASIS<--VIRTUAL ORBITALS (ORTHONORMALIZED)
C
      LVIR=(NOBTX-1)*NBASIS
      DO I=LVIR+1,NBASIS*NBASIS
      II = I + (NOBT-NOBTX)*NBASIS
      BASIS(II)=BASLAO(I)
      END DO
C
      RETURN
      END
      SUBROUTINE GENSCF(METHOD,MELE,MSPIN,NBASIS,MLORBIT,MWIN,
     &  WBASIS,DMP,GD1,GD2,W,MSIZE,MITER,MGRP,LPTALL,LASTITER)
C    &  WBASIS,DMP,GD1,GD2,W,MSIZE,ETOTAL,MITER,MGRP,LPTALL,LASTITER)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C                General SCF routine.
C                1. Hartree-Fock
C                2. VBSCF
C                3. SCVB
C                4. CASVB
C                5. MCSCF (CASSCF) to be implemented
C     Note:
C
C               DMP: 1E-density of the whole system except the current subunit.
C               GD1: 1E-density of the current subunit.
C               GD2: 2E-density of the current subunit.
C               W:   scratch field.
C               MSIZE:  size of scratch field.
C               WBASIS: orbital optimization space.
C
C     History:
C               First created in Feb. 1998.
C               Recoded in September, 1999.
C               Added SCVB and CASVB, March, 2000.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION WBASIS(*),DMP(*),GD1(*),GD2(*),W(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      CHARACTER*80 NUMBER,FLAG
      NUMBER   = '0123456789'
      NC1      = 1+MGRP/10
      NC2      = 1+MGRP-10*(NC1-1)
      FLAG     = '$'
      FLAG(2:2)= NUMBER(NC1:NC1)
      FLAG(3:3)= NUMBER(NC2:NC2)
C
C     Shortcut for special case: MELE=0
C
      IF(MELE.EQ.0) RETURN
      IF     (METHOD.EQ.1) THEN
      CALL PROJHF(NBASIS,MLORBIT,MWIN,MELE,MSPIN,MSIZE,WBASIS,DMP,
     &     W,GD1,MITER,MGRP)
      ELSE IF(METHOD.EQ.2) THEN
      CALL RVBSCF(NBASIS,MLORBIT,MWIN,MELE,MSPIN,MSIZE,WBASIS,DMP,
     &     W,GD1,GD2,MITER,MGRP,FLAG,LPTALL,LASTITER)
C    &     W,GD1,GD2,ETOTAL,MITER,MGRP,FLAG,LPTALL,LASTITER)
      ELSE IF(METHOD.EQ.3) THEN
      CALL SCVBSCF(NBASIS,MLORBIT,MWIN,MELE,MSPIN,MSIZE,WBASIS,DMP,
     &     W,GD1,GD2,MITER,MGRP,FLAG,LASTITER)
C    &     W,GD1,GD2,ETOTAL,MITER,MGRP,FLAG,LPTALL,LASTITER)
      ELSE IF(METHOD.EQ.4) THEN
      CALL CASVB(NBASIS,MLORBIT,MELE,MSPIN,MSIZE,WBASIS,DMP,
     &     W,GD1,GD2,MITER,MGRP,FLAG,LPTALL,LASTITER)
      ELSE IF(METHOD.GE.4) THEN
      WRITE(IOUTVB,*)'Method > 4 is not implemented, STOP'
      CALL ABRTVB
      STOP
      END IF
      RETURN
      END
      SUBROUTINE MODBAS(NBASIS,BASIS,WBASIS,MINDEX,MWIN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION MINDEX(*),BASIS(NBASIS,*),WBASIS(NBASIS,*)
      DO I=1,MWIN
      DO J=1,NBASIS
      BASIS(J,MINDEX(I))=WBASIS(J,I)
      END DO
      END DO
      RETURN
      END
      SUBROUTINE COLBAS(NBASIS,BASIS,WBASIS,MINDEX,MWIN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION MINDEX(*),BASIS(NBASIS,*),WBASIS(NBASIS,*)
      DO I=1,MWIN
      DO J=1,NBASIS
      WBASIS(J,I)=BASIS(J,MINDEX(I))
      END DO
      END DO
      RETURN
      END
      SUBROUTINE WINDEX(MGRP,NBASIS,MWIN,IBASIS,MINDEX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IBASIS(*),MINDEX(*)
      CHARACTER*80 NUMBER,WFLAG
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      NUMBER='0123456789'
      M2=1+MGRP/10
      M1=1+MGRP-(MGRP/10)*10
      WFLAG='$00WINDW'
      WFLAG(2:2)=NUMBER(M2:M2)
      WFLAG(3:3)=NUMBER(M1:M1)
C
C     SET DEFAULT WINDEX: MLORBIT+ALL VIRTURAL ORBITALS
C
      NOB=0
      DO I=1,NBASIS
      IF(IBASIS(I).EQ.MGRP) THEN
      NOB=NOB+1
      MINDEX(NOB)=I
      END IF
      END DO
      NOBV=NOB
      DO I=1,NBASIS
      IF(IBASIS(I).EQ.0) THEN
      NOBV=NOBV+1
      MINDEX(NOBV)=I
      END IF
      END DO
      IF(MWIN.NE.NOBV) THEN
      CALL LOCTOR(IOENGI,WFLAG,8,IOK,0)
        IF(IOK.EQ.0) THEN
C       WRITE(IOUTVB,*)'***WARNING***, INPUT FOR WINDOW IS MISSING'
C       WRITE(IOUTVB,*)'DEFAULT IS ASSUMED'
        ELSE
        READ(IOENGI,*)MWINMD,(IND,MINDEX(IND),K=1,MWINMD)
        END IF
      END IF
      RETURN
      END
      SUBROUTINE CASVB(NBASIS,MLORBIT,MELE,MSPIN,MWK,WBASIS,
     &    DMP,G,DMLOC,GD2,MITER,MGRP,FLAG,LPTALL,LASTITER)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Complete active space VB calculation.
C
C     Note:
C               Equivalent of CASSCF method.
C               For N<=6, CASVB is reasonably efficient. However,
C               CASVB is not implemented as an alternative to CASSCF for
C               larger N.
C     History:
C               First created in March, 2000.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     DMP:   DENSITY MATRIX OF THE WHOLE SYSTEM EXCEPT THE SUBSYSTEM
C     DMLOC: 1E-DENSITY MATRIX OF A SUBSYSTEM IN ITS LOCAL BASIS SET
C     GD2:   2E-DENSITY MATRIX OF A SUBSYSTEM IN ITS LOCAL BASIS SET
C     WBASIS:ORBITALS FOR THE CURRENT SUBUNIT
C     MGRP:  # OF THE SUBUNIT
C     MITER: # OF MACROITERATION
C     G:     SCRATCH
C
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*50 FLAG
C     PARAMETER (MAXNOB = 200)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION G(*),WBASIS(*),DMP(*),DMLOC(*),GD2(*)
      COMMON /VBSTR/CSTR(10000),NPHI(100000),NSTR
C     COMMON /VBCTL/EPS,MAXIT,NOPT,IHESS,NEWTON,NOB(MAXNOB),NVBI(5000)
      COMMON /CSTRUC/CSTRUC(5000),ISTRUC(100)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      LPRT = LPTALL
      IF(MITER.GT.1) LPRT = 0
      DW = 0.0D0
      FLAG(4:11)='LENHANCE'
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,FLAG,11,IOK,0)
      IF(IOK.EQ.1) THEN
C         READ(IOENGI,*)NVBO
          READ(IOENGI,*) I
C         I is not used.
      END IF
      CALL SETCASVB(MELE,MSPIN,NSTR,NPHI,MLORBIT,MGRP,LPRT)
      IF(NSTR.GT.2000) WRITE(IOUTVB,1000)
 1000 FORMAT(" WARNING: TOO MANY VB STRUCTURES IN CASVB ")
C
C     COPY STUCTURE COEFFICIENTS FROM COMMON BLOCK CSTRUC
C
      ISTRUC(MGRP+1)=ISTRUC(MGRP)+NSTR
      DO I=1,NSTR
      CSTR(I)=CSTRUC(ISTRUC(MGRP)+I)
      END DO
C
C     DETERMINE STRUCTURE COEFFIECNETS IF IT IS THE FIRST TIME CALL
C     OR LAST ITERATION
C
C     THE STRUCTURE COEFFIECIENTS ARE USED TO CONSTRUCT 1E AND 2E DENSITY
C     IN VBMATR.
C
      IF(MITER.LE.1.OR.LASTITER.EQ.1.OR.DW.GT.0.0D0) THEN
      CALL LOCANVBO(MLORBIT,WBASIS,G)
C
C     DON'T PRINT STRUCTURE WEIGHTS FOR THIS CALL SINCE THE NEXT
C     CALL OF RESONA WILL DO.
C
      CALL RESONA(MELE,MSPIN,NBASIS,MLORBIT,NSTR,CSTR,NPHI,G,
     &     WBASIS,DMP,DMLOC,GD2,MWK,FLAG,0,MGRP)
      END IF
      CALL RESONA(MELE,MSPIN,NBASIS,MLORBIT,NSTR,CSTR,NPHI,G,
     &     WBASIS,DMP,DMLOC,GD2,MWK,FLAG,LASTITER,MGRP)
C
C     POSSIBLE STRUCTURE SYMMETRY
C
      CALL STRSYM(CSTR,NSTR,FLAG)
C
C     UPDATE STUCTURE COEFFICIENTS TO COMMON BLOCK CSTRUC
C
      DO I=1,NSTR
      CSTRUC(ISTRUC(MGRP)+I)=CSTR(I)
      END DO
      RETURN
      END
      SUBROUTINE SCVBSCF(NBASIS,MLORBIT,MWIN,MELE,MSPIN,MWK,WBASIS,
     &    DMP,G,DMLOC,GD2,MITER,MGRP,FLAG,LASTITER)
C    &    DMP,G,DMLOC,GD2,ETOTAL,MITER,MGRP,FLAG,LPTALL,LASTITER)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Spin-coupled VB calculation.
C
C     Note:
C               For N>=10, it is more efficient to perform VBSCF
C               calculation with only one VB structure, then followed
C               by a SCVB type calculation.
C
C     History:
C               First created in March, 2000.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     DMP:   DENSITY MATRIX OF THE WHOLE SYSTEM EXCEPT THE SUBSYSTEM
C     DMLOC: 1E-DENSITY MATRIX OF A SUBSYSTEM IN ITS LOCAL BASIS SET
C     GD2:   2E-DENSITY MATRIX OF A SUBSYSTEM IN ITS LOCAL BASIS SET
C     WBASIS:ORBITALS FOR THE CURRENT SUBUNIT
C     MGRP:  # OF THE SUBUNIT
C     MITER: # OF MACROITERATION
C     G:     SCRATCH
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*50 FLAG
      PARAMETER (MAXNOB = 200)
      DIMENSION G(*),WBASIS(*),DMP(*),DMLOC(*),GD2(*)
      COMMON /VBSTR/CSTR(10000),NPHI(100000),NSTR
      COMMON /VBCTL/EPS,MAXIT,NOPT,IHESS,NEWTON,NOB(MAXNOB),NVBI(5000)
      COMMON /CSTRUC/CSTRUC(5000),ISTRUC(100)
      LPRT = 1
      IF(MITER.GT.1) LPRT = 0
      IF(MLORBIT.GT.MAXNOB) CALL ABORT0("SCVBSCF001")
      CALL SETSCVB(MELE,MSPIN,NSTR,NPHI,NOB,EPS,MAXIT,NEWTON,
     &             NOPT,MLORBIT,MGRP,FLAG,LPRT)
C
C     COPY STUCTURE COEFFICIENTS FROM COMMON BLOCK CSTRUC
C
      ISTRUC(MGRP+1)=ISTRUC(MGRP)+NSTR
      DO I=1,NSTR
      CSTR(I)=CSTRUC(ISTRUC(MGRP)+I)
      END DO
      CALL GETCTLVAL('LCIONLY   ',CTLVAL,INTVAL)
      LCIONLY = INTVAL
C
C     DETERMINE STRUCTURE COEFFIECNETS IF IT IS THE FIRST TIME CALL
C
      IF(MITER.LE.1) THEN
      CALL RESONA(MELE,MSPIN,NBASIS,MLORBIT,NSTR,CSTR,NPHI,G,
     &     WBASIS,DMP,DMLOC,GD2,MWK,FLAG,LASTITER,MGRP)
      END IF
      IF(LCIONLY.NE.1) THEN
      CALL VBSCF(MELE,MSPIN,NBASIS,MLORBIT,MWIN,G,WBASIS,DMP,
     &         DMLOC,GD2,MWK,MGRP,FLAG,MITER,LASTITER)
C    &         DMLOC,GD2,MWK,ETOTAL,MGRP,FLAG,MITER,LASTITER)
      ELSE
      CALL RESONA(MELE,MSPIN,NBASIS,MLORBIT,NSTR,CSTR,NPHI,G,
     &     WBASIS,DMP,DMLOC,GD2,MWK,FLAG,LASTITER,MGRP)
      END IF
C
C     UPDATE STUCTURE COEFFICIENTS TO COMMON BLOCK CSTRUC
C
      DO I=1,NSTR
      CSTRUC(ISTRUC(MGRP)+I)=CSTR(I)
      END DO
      RETURN
      END
      SUBROUTINE RVBSCF(NBASIS,MLORBIT,MWIN,MELE,MSPIN,MWK,WBASIS,
     &    DMP,G,DMLOC,GD2,MITER,MGRP,FLAG,LPTALL,LASTITER)
C    &    DMP,G,DMLOC,GD2,ETOTAL,MITER,MGRP,FLAG,LPTALL,LASTITER)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Resonance VBSCF calculation.
C
C     Note:
C               VBSCF method works efficient for one up to a few VB structures.
C
C     History:
C               First created in March, 2000.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     DMP:   DENSITY MATRIX OF THE WHOLE SYSTEM EXCEPT THE SUBSYSTEM
C     DMLOC: 1E-DENSITY MATRIX OF A SUBSYSTEM IN ITS LOCAL BASIS SET
C     GD2:   2E-DENSITY MATRIX OF A SUBSYSTEM IN ITS LOCAL BASIS SET
C     WBASIS:ORBITALS FOR THE CURRENT SUBUNIT
C     MGRP:  # OF THE SUBUNIT
C     MITER: # OF MACROITERATION
C     G:     SCRATCH
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*50 FLAG
      PARAMETER (MAXNOB = 200)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION G(*),WBASIS(*),DMP(*),DMLOC(*),GD2(*)
      COMMON /VBSTR/CSTR(10000),NPHI(100000),NSTR
      COMMON /VBCTL/EPS,MAXIT,NOPT,IHESS,NEWTON,NOB(MAXNOB),NVBI(5000)
      COMMON /CSTRUC/CSTRUC(5000),ISTRUC(100)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      IF(MLORBIT.GT.MAXNOB) CALL ABORT0("RVBSCF0001")
      CALL SETVB(MELE,NSTR,NPHI,NOB,EPS,MAXIT,NEWTON,
     &           NOPT,MLORBIT,MITER,MGRP,FLAG)
C
C     COPY STUCTURE COEFFICIENTS FROM COMMON BLOCK CSTRUC
C
      ISTRUC(MGRP+1)=ISTRUC(MGRP)+NSTR
      DO I=1,NSTR
      CSTR(I)=CSTRUC(ISTRUC(MGRP)+I)
      END DO
      CALL GETCTLVAL('LCIONLY   ',CTLVAL,INTVAL)
      LCIONLY = INTVAL
C
C     SPECIAL CASE: LOCALIZED HARTREE-FOCK
C
      IF(MELE.EQ.2*MLORBIT) THEN
        CSTRUC(ISTRUC(MGRP)+1)=1.0D0
        CALL LHFSCF(MELE,NBASIS,MLORBIT,MWIN,G,WBASIS,DMP,
     &       DMLOC,GD2,MWK,MGRP,FLAG,MITER,LASTITER)
C    &       DMLOC,GD2,MWK,ETOTAL,MGRP,FLAG,MITER,LASTITER)
      RETURN
      ENDIF
C
C     DETERMINE STRUCTURE COEFFIECNETS IF IT IS THE FIRST TIME CALL
C     CHANGE IT FOR 2. JLI, MAY 2, 2009
C
      IF(MITER.LE.1) THEN
      IF(LPTALL.EQ.1.AND.NSTR.GT.1) WRITE(IOUTVB,1000)
      CALL RESONA(MELE,MSPIN,NBASIS,MLORBIT,NSTR,CSTR,NPHI,G,
     &     WBASIS,DMP,DMLOC,GD2,MWK,FLAG,0,MGRP)
      END IF
      IF(LCIONLY.NE.1) THEN
      CALL VBSCF(MELE,MSPIN,NBASIS,MLORBIT,MWIN,G,WBASIS,DMP,
     &         DMLOC,GD2,MWK,MGRP,FLAG,MITER,LASTITER)
C    &         DMLOC,GD2,MWK,ETOTAL,MGRP,FLAG,MITER,LASTITER)
      ELSE
C
C     NOTE: CALL RESONA EACH MACRO ITERATION IS NECESSARY
C           OTHERWISE, THE NR METHOD MAY CONVERGE TO A
C           DIFFERENT STATE OF VBCI SPACE
C
      CALL RESONA(MELE,MSPIN,NBASIS,MLORBIT,NSTR,CSTR,NPHI,G,
     &     WBASIS,DMP,DMLOC,GD2,MWK,FLAG,LASTITER,MGRP)
      END IF
C
C     UPDATE STUCTURE COEFFICIENTS TO COMMON BLOCK CSTRUC
C
      DO I=1,NSTR
      CSTRUC(ISTRUC(MGRP)+I)=CSTR(I)
      END DO
      RETURN
 1000 FORMAT(' CALCULATE INITIAL STRUCTURE COEFFICIENTS')
      END
      SUBROUTINE RESONA(N,NS,MT,NORT,NSTR,CSTR,NPHI,W,
     &           WBASIS,DMP,DM1,DM2,MW,FLAG,LASTITER,MGRP)
C    &           WBASIS,DMP,DM1,DM2,MW,FLAG,LPTALL,LASTITER,MGRP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPHI(*),CSTR(*),W(MW),DMP(*),WBASIS(*),DM1(*),DM2(*)
C     DIMENSION SDM(10000)
      CHARACTER*50 FLAG
C     EPS=0.000001D0
      CALL GETIOUNIT('IOTEMPA ',IOTEMPA)
      CALL GETIOUNIT('IOTEMPB ',IOTEMPB)
      LBUFF   = 4095
C
C     ADDRESS
C
      MTX    = MT
      IF(NORT .GT. MT) MTX=NORT
      NSTRSQ = NSTR*(NSTR+1)/2
      MSQ    = MT*(MT+1)/2
C     MGSQ   = MSQ*(MSQ+1)/2
C     NMSQ   = MT*MSQ
      MXSQ   = MTX*(MTX+1)/2
C
      MMS    = 1
      MMH    = MMS+MXSQ
      MM1    = MMH+MXSQ
      MM2    = MM1+MTX*MTX
      MM3    = MM2+MTX*MTX*(MTX+1)/2
      NORTSQ = NORT*(NORT+1)/2
      NGSQ   = NORTSQ*(NORTSQ+1)/2
C
      NNS    = 1
      NNH    = NNS + NORTSQ
      NNG    = NNH + NORTSQ
      NNSS   = NNG + NGSQ
      NVBS   = NNSS + N*NORT
      NVBH   = NVBS + NSTRSQ
      NNWK   = NVBH + NSTRSQ
      NREM   = MW - NNWK+1
C
C     SET INDEX
C
      CALL SETIND(MTX,MTX)
C
C     CHECK WORK FIELD
C
      IF(MM3+MSQ.GT.MW.OR.NNWK+4*NSTR**2.GT.MW)
     &CALL ABORT0('RESONA01  ')
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL GETIOUNIT('IAO2E   ',IAO2E)
      CALL GETIOUNIT('IVBO2E  ',IVBO2E)
C     TIME2 = XCLOCK()
      CALL READ1E(IAO1E,W(MMS),W(MMH),MT)
C
C     COPY DENSITY OF CORE TO WORKING FILED G(MM3)
C
      DO I=1,MSQ
      W(MM3-1+I)=DMP(I)
      END DO
C     TIME=XCLOCK()
      REWIND(IVBO2E)
      IHFPO = 1
      CALL TRAN1E(MT,NORT,W(MMS),W(MMH),
     &     WBASIS,W(MM1),W(MM2),W(MM3),IHFPO,IVBO2E)
      CALL TRANP2E(MT,NORT,0,WBASIS,W,MW,LBUFF,IOTEMPA,IOTEMPB)
      CALL SHREAD(W(NNS),W(NNH),NORTSQ,IVBO2E)
      CALL GREAD(W(NNG),NGSQ,LBUFF,IVBO2E)
C
C     PRINT OVERLAP MATRIX OF VB ORBITALS
C
      IF(LASTITER.EQ.1) CALL MPRINT2(NORT,W(NNS),1,MGRP)
      CALL VBMATR(N,NS,NORT,NSTR,NPHI,CSTR,W(NNS),W(NNH),W(NNG),
     &     W(NVBS),W(NVBH),DM1,DM2,W(NNSS),W(NNWK),E0,NREM)
      CALL RVB(NSTR,CSTR,W(NVBS),W(NVBH),W(NNWK),NREM,F2,FLAG,
     &         LASTITER,MGRP)
C
C     COMPUTE SPIN DENSITY
C
      ISPDEN = 0
      CALL GETCTLVAL("SPINDEN   ",CTLVAL,ISPDEN)
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$SPDEN',6,IOK,0)
      IF(IOK.EQ.1) ISPDEN = 1
      IF(LASTITER.EQ.1.AND.NS.GT.0.AND.ISPDEN.EQ.1) THEN
        NSQ   = NORT*(NORT+1)/2
        NADDS = 1
        NADDD = NADDS+NSQ
        NADDAD= NADDD+NSQ
        NWK   = NADDAD + MSQ
        CALL SHREAD(W(NADDS),W(NADDD),NORTSQ,IVBO2E)
        CALL SPDEN(N,NS,NSTR,W(NADDS),NORT,NPHI,CSTR,W(NADDD))
        CALL MATRAN1(NORT,MT,WBASIS,W(NWK),W(NADDD),W(NADDAD))
        CALL SPDATM(W(NADDAD),W(NWK))
      END IF
      RETURN
      END
      SUBROUTINE PROJHF(M,NCORE,NCV,MESUB,MSSUB,MWK,WBASIS,DMP,
     &           W,GD1,MITER,MGRP)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Subspace Projected Hartree-Fock Method
C
C     Note:
C               This is Not the spin-projected HF, nor the extended HF method.
C               This is the HF calculation method for core electrons in the
C               field of other electrons. Projection of the Fock matrix in the
C               subspace of HF window is performed. The four-index integral
C               transformation of HF group is avoided.
C
C     History:
C               First created on April 1, 2000.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*50 FLAG
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME,FKFILE
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
     &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
     &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
      COMMON /CSTRUC/CSTRUC(5000),ISTRUC(100)
      DIMENSION W(*),DMP(*),E(5000),GD1(*),WBASIS(M,*)
      DIMENSION PGM(50000)
      ISTRUC(MGRP+1)=ISTRUC(MGRP)+1
      CSTRUC(ISTRUC(MGRP)+1)=1.0D0
      IF(NCORE.EQ.0.OR.(MITER.EQ.1.AND.MGRP.EQ.1).OR.
     & LFROZN.EQ.1) RETURN
      EPS=1.0D-4
      NE=NCORE*2
C     EOLD=0.0D0
      ITER=0
      ITMAX=30
C     0.0: NO DAMPING. 0.5 HALF
      DAMP = 0.0D0
      FKFILE=FSTR(1:LENFIL)//'.FKT'
C
C     ERROR CHECK
C
      IF(NE.NE.MESUB.OR.MSSUB.NE.0) CALL ABORT0('PROJHF01  ')
C
C     ADDRESS
C
      MSQ    = M*(M+1)/2
C     MGSQ   = MSQ*(MSQ+1)/2
C     NCVSQ  = NCV*(NCV+1)/2
      MMS    = 1
      MMH    = MMS+MSQ
      MMD    = MMH+MSQ
      MMF    = MMD+MSQ
      MMG    = MMF+MSQ
      MCVS   = MMG
      MCVH   = MCVS + NCV*NCV
      MCVF   = MCVH + NCV*NCV
      MCVD   = MCVF + NCV*NCV
      MWRK   = MCVD + NCV*NCV
      MCVV   = MCVD + NCV*NCV
      MCVWRK = MCVV + NCV*NCV
C     MFKOLD = MCVWRK
      MMS1   = 0
      MMH1   = MMS1+MSQ
      MMD1   = MMH1+MSQ
      MMF1   = MMD1+MSQ
      MMG1   = MMF1+MSQ
      MCVS1  = MMG1
      MCVH1  = MCVS1 + NCV*NCV
      MCVF1  = MCVH1 + NCV*NCV
      MCVD1  = MCVF1 + NCV*NCV
      MWRK1  = MCVD1 + NCV*NCV
      MCVV1  = MCVD1 + NCV*NCV
      MCVWRK1= MCVV1 + NCV*NCV
      MFKOLD1= MCVWRK1
C
C     CHECK WORK FIELD
C
      IF(MCVWRK.GT.MWK.OR.MCVWRK1.GT.MWK) CALL ABORT0('PROJHF02  ')
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL GETIOUNIT('IAO2E   ',IAO2E)
      CALL GETIOUNIT('IOTEMP  ',IOTEMP)
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$HFCOREDAMP',11,IOK,0)
      IF(IOK.GE.1) THEN
        READ(IOENGI,*)DAMP
        WRITE(IOUTVB,*)" CORE-HARTREE-FOCK DAMPING FACTOR = ",DAMP
        OPEN(IOTEMP,FILE=FKFILE,STATUS='UNKNOWN',FORM='UNFORMATTED',
     &       ERR=111)
      END IF
      GOTO 100
 111  WRITE(IOUTVB,*)"NO FILE OPEN"
 100  CONTINUE
      ITER=ITER+1
      CALL READ1E(IAO1E,W(MMS),W(MMH),M)
C
C     CONSTRUCT THE TOTAL DENSITY BY ADDING CORE ELECTRON PART
C
      DO I=1,MSQ
      W(MMD1+I)=DMP(I)
      END DO
      DO I=1,NCORE
        DO J=1,M
        JJ=J*(J-1)/2
        DO K=1,J
        JK=JJ+K
        W(MMD1+JK)=W(MMD1+JK)+2.0D0*WBASIS(J,I)*WBASIS(K,I)
        END DO
        END DO
      END DO
C
C     CONSTRUCT THE FOCK MATRIX
C
C     FOCK MATRIX
C
      CALL FKENGI(W(MMF),W(MMD),M,1)
      DO I=1, MSQ
      W(MMF1+I) = W(MMF1+I)+W(MMH1+I)
      END DO
      IF(ITER.GT.1.AND.DAMP.GT.0.0D0) THEN
         REWIND(IOTEMP)
         READ(IOTEMP)(W(MFKOLD1+I),I=1,MSQ)
         DO I=1, MSQ
           W(MMF1+I) = (1.0D0-DAMP)*W(MMF1+I) + DAMP*W(MFKOLD1+I)
         END DO
      END IF
      IF(DAMP.GT.0.0D0) THEN
          REWIND(IOTEMP)
          WRITE(IOTEMP)(W(MMF1+I),I=1,MSQ)
      END IF
C
C     TRANSFORMATION OF FOCK MATRIX
C
      CALL MATRAN(M,NCV,WBASIS,W(MWRK),W(MMF),W(MCVF))
      CALL MATRAN(M,NCV,WBASIS,W(MWRK),W(MMH),W(MCVH))
      CALL MATRAN(M,NCV,WBASIS,W(MWRK),W(MMS),W(MCVS))
C
C     RESTORE INTO SQUARE FORM
C
      IJ=0
      DO I=1,NCV
      DO J=1,NCV
      IJ=IJ+1
      W(MWRK1+IJ)=W(MCVF1+IJ00(I,J))
      END DO
      END DO
      DO I=1,NCV*NCV
      W(MCVF1+I)=W(MWRK1+I)
      END DO
      IJ=0
      DO I=1,NCV
      DO J=1,NCV
      IJ=IJ+1
      W(MWRK1+IJ)=W(MCVH1+IJ00(I,J))
      END DO
      END DO
      DO I=1,NCV*NCV
      W(MCVH1+I)=W(MWRK1+I)
      END DO
      IJ=0
      DO I=1,NCV
      DO J=1,NCV
      IJ=IJ+1
      W(MWRK1+IJ)=W(MCVS1+IJ00(I,J))
      END DO
      END DO
      DO I=1,NCV*NCV
      W(MCVS1+I)=W(MWRK1+I)
      END DO
      CALL EG(NCV,W(MCVF),W(MCVS),E,W(MCVV),W(MCVWRK))
C
C     FIND THE MAX. MODIFICATION
C
      CMAX=0.0D0
      IJ=0
      DO I=1,NCORE
      II=(I-1)*NCV
      DO J=NCORE+1,NCV
      IJ=II+J
      IF(DABS(W(MCVV1+IJ)).GT.CMAX) CMAX=DABS(W(MCVV1+IJ))
      END DO
      END DO
C
C     COMPUTE DENSITY IN ORBITAL BASIS SET
C
      DO I=1,NCV*NCV
      W(MCVD1+I)=0.0D0
      END DO
      DO I=1,NCORE
      IMCVV1=MCVV1+(I-1)*NCV
        DO J=1,NCV
        JJ=(J-1)*NCV
        DO K=1,NCV
        JK=JJ+K
        W(MCVD1+JK)=W(MCVD1+JK)+2.0D0*W(IMCVV1+J)*W(IMCVV1+K)
        END DO
        END DO
      END DO
C
C     CALCULATE ENERGY
C     THE ENERGY EXPRESSION IS NOT CORRECT, DON'T USE IT
C     JIABO LI, APRIL 1, 2000
C
      ENERGY=0.0D0
      DO I=1,NCV*NCV
      ENERGY=ENERGY+W(MCVD1+I)*(W(MCVH1+I)+W(MCVF1+I))
      END DO
      ENERGY=ENERGY*0.5D0
C     EDIFF=ENERGY-EOLD
C     EOLD=ENERGY
C     WRITE(IOUTVB,'(' COREHF: ITER, CMAX',I5,F10.5)')ITER,CMAX
C
C     UPDATE WBASIS
C
      CALL MATMUL2(M,NCV,NCV,WBASIS,W(MCVV),W(MCVWRK))
      IJ=0
      DO I=1,NCV
      DO J=1,M
      IJ=IJ+1
      WBASIS(J,I)=W(MCVWRK1+IJ)
      END DO
      END DO
      IF(ITER.GE.ITMAX.AND.CMAX.GT.EPS.AND.DAMP.LT.0.0001D0) THEN
      WRITE(IOUTVB,*)
     &  ' CORE-HARTREE-FOCK UNCONVERGED AFTER',ITER,'ITERATIONS'
      WRITE(IOUTVB,*)' CMAX =',CMAX
      WRITE(IOUTVB,*)
     &  ' PLEASE TRY TO USE A DAMPING FACTOR BY ADDING TWO '
      WRITE(IOUTVB,*)" LINES IN YOUR INPUT LIKE:"
      WRITE(IOUTVB,*)" $HFCOREDAMP"
      WRITE(IOUTVB,*)" 0.3"
      WRITE(IOUTVB,*)"  "
      WRITE(IOUTVB,*)" WHERE THE DAMPING FACTOR CAN BE A VALUE 0-0.8 "
      WRITE(IOUTVB,*)
     &  " 0: NO DAMPING. 0.8 VERY STRONG DAMPING, SLOW CONV."
      GOTO 200
      END IF
      IF(CMAX.GT.EPS) GOTO 100
 200  CONTINUE
C
C     LOCALIZATION. It will not effect the final results even if LMO is not
C     performed
C
      MWRK=MMH
      CALL READ1E(IAO1E,W(MMS),W(MWRK),M)
C
C     NVIRX=NCV-NCORE
C     NOBVIR=NCORE*M+1
      NPMVIR=NCORE*NATOM+1
C
C     CSPLIT IS USED IN A LOT OF PLACES. IF ANY CHANGE IS MADE,
C     MAKE SURE THE OTHER PLACES ARE ALSO CHANGED
C
      CSPLIT  = 0.15D0
C
C     READ CHARGE RATIO FOR SETING SPLITING FLAG
C
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$SPLITRATIO',11,IOK,0)
      IF(IOK.GE.1) READ(IOENGI,*)CSPLIT
      LPTALLX = 0
      CALL LOCAPM(M,NCORE,NATOM,NATBAS,W,W(MWRK),WBASIS,PGM,E,0,LPTALLX,
     &            BFLABE,CSPLIT,0)
      IF(NVIR.GT.0) THEN
      CALL LOCAPM(M,NVIR, NATOM,NATBAS,W,W(MWRK),WBASIS(1,NCORE+1)
     &,PGM(NPMVIR),E(NCORE+1),1,LPTALL,BFLABE,CSPLIT,0)
      END IF
C
C     CALCULATE D1 OF CORE ELECTRONS (LOCAL BASIS SET)
C
      DO 300 I=1,NCORE*(NCORE+1)/2
 300  GD1(I)=0.0D0
      DO 400 K=1,NCORE
      GD1(K*(K+1)/2)=2.0D0
 400  CONTINUE
      IF(DAMP.GT.0.0D0) CLOSE(IOTEMP)
      RETURN
      END
C========================================================================
C     IO routines and interfaces for Gaussian and Gamess.
C========================================================================
C
      SUBROUTINE IOVBINIT()
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 VBPATH
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /IOUNIT/IAO1E,IAO2E,IOHFORB,IOVBORB,IVBO2E,IOMAP,IOHES,
     &               IOVBOLIB,IOENGI,IOTEMP,IOTEMPA,IOTEMPB,VBPATH
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
C     Initialize I/O units
C     The I/O units can be assigned dynamically. In case having confliction
C     with a third party program, here is the place one can make changes.
C
C     81
C
      IAO1E   = 81
      FUNIT(1)='V81'
C
C     82
C
      IAO2E   = 82
      FUNIT(2)='V82'
C
C     83
C
      IOHFORB = 83
      FUNIT(3)='V83'
C
C     84
C
      IOVBORB = 84
      FUNIT(4)='V84'
C
C     85
C
      IVBO2E  = 85
      FUNIT(5)='V85'
C
C     86
C
      IOTEMPA = 86
      FUNIT(6)='V86'
C
C     87
C
      IOTEMPB = 87
      FUNIT(7)='V87'
C
C     88
C
      IOHES   = 88
      FUNIT(8)='V88'
C
C     89
C
      IOVBOLIB= 89
      FUNIT(9)='V89'
C
C     80
C
      IOENGI  = 80
      FUNIT(10)='V80'
C
      IOTEMP  = 78
      IOMAP   = 79
C
      RETURN
      END
C
C     GET IOUNIT BY IONAME
C
      SUBROUTINE GETIOUNIT(IONAME,IOUNIT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 VBPATH
      CHARACTER*8  IONAME
      COMMON /IOUNIT/IAO1E,IAO2E,IOHFORB,IOVBORB,IVBO2E,IOMAP,IOHES,
     &               IOVBOLIB,IOENGI,IOTEMP,IOTEMPA,IOTEMPB,VBPATH
      IF (IONAME.EQ.'IAO1E   ') IOUNIT = IAO1E
      IF (IONAME.EQ.'IAO2E   ') IOUNIT = IAO2E
      IF (IONAME.EQ.'IOHFORB ') IOUNIT = IOHFORB
      IF (IONAME.EQ.'IOVBORB ') IOUNIT = IOVBORB
      IF (IONAME.EQ.'IVBO2E  ') IOUNIT = IVBO2E
      IF (IONAME.EQ.'IOMAP   ') IOUNIT = IOMAP
      IF (IONAME.EQ.'IOHES   ') IOUNIT = IOHES
      IF (IONAME.EQ.'IOVBOLIB') IOUNIT = IOVBOLIB
      IF (IONAME.EQ.'IOENGI  ') IOUNIT = IOENGI
      IF (IONAME.EQ.'IOTEMP  ') IOUNIT = IOTEMP
      IF (IONAME.EQ.'IOTEMPA ') IOUNIT = IOTEMPA
      IF (IONAME.EQ.'IOTEMPB ') IOUNIT = IOTEMPB
      RETURN
      END
      SUBROUTINE GETVBPATH(VBPATHA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 VBPATH
      CHARACTER*80 VBPATHA
C     CHARACTER*8  IONAME
      COMMON /IOUNIT/IAO1E,IAO2E,IOHFORB,IOVBORB,IVBO2E,IOMAP,IOHES,
     &               IOVBOLIB,IOENGI,IOTEMP,IOTEMPA,IOTEMPB,VBPATH
      VBPATHA = VBPATH
      RETURN
      END
      SUBROUTINE SETVBPATH(VBPATHA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 VBPATH
      CHARACTER*80 VBPATHA
C     CHARACTER*8  IONAME
      COMMON /IOUNIT/IAO1E,IAO2E,IOHFORB,IOVBORB,IVBO2E,IOMAP,IOHES,
     &               IOVBOLIB,IOENGI,IOTEMP,IOTEMPA,IOTEMPB,VBPATH
      VBPATH = VBPATHA
      RETURN
      END
C
C     GET CONTROL VALUES
C
      SUBROUTINE GETCTLVAL(CTLNAME,CTLVAL,INTCTL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*10 CTLNAME
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
     &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
     &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION CTLVAL(*),INTCTL(*)
C
C     TODO: ADD MORE LINES
      IF(CTLNAME.EQ.'LCIONLY   ') THEN
        INTCTL(1) = LCIONLY
        RETURN
      END IF
C
C     SPIN DENSITY CONTROL
C
      IF(CTLNAME.EQ.'SPINDEN   ') THEN
        INTCTL(1) = KEY(13)
        RETURN
      END IF
C
C     DIIS CONTROL
C
      IF(CTLNAME.EQ.'DIIS      ') THEN
        INTCTL(1) = KEY(14)
        RETURN
      END IF
      CTLVAL(1) = 0
      WRITE(IOUTVB,*)'UNKNOWN CONTROL NAME = ', CTLNAME
      CALL ABORT0('GETCTLVAL1')
      RETURN
      END
      SUBROUTINE INPUTVB(W,MSIZE)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Top level input routine for VB2000.
C
C     Note:
C               This routine is called at the begining. It loads general
C               information about a molecule, i.e. the numbers of its atoms,
C               electrons, basis functions and charge. It also sets up
C               general controls for the calculations and initializes some
C               variables, including the initial guess of orbitals.
C
C     History:
C               Developed by Jiabo Li, 1993-1995, Erlangen, Germany
C               Re-Engineered by Jiabo Li, Dec., 1998, Minneapolis, USA
C               Updated by Jiabo Li, 1998-2000, Minneapolis/San Diego, USA
C
C               Nov. 10, 2003 Jiabo Li: Fixed a CASVB setting bug for number of
C               orbitals. Nov. 10, 2003
C
C               (TODO: the input logic need a more clean design).
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MAXWKI=100000)
      CHARACTER*80 BUFF,WORD,VBPATH,VBTEMP,BAS
      CHARACTER*12 BFLABE
CGMS  CHARACTER*12 DUMMY
CGAU  CHARACTER*12 DUMMY
      CHARACTER*20 BASNAME
      CHARACTER*8  BONDLAB
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
     &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
     &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /LMOCHA/CHAMAX(4,1000),MAXCHA(4,1000)
      COMMON /CSTRUC/CSTRUC(5000),ISTRUC(100)
C     COMMON /IAA/IA(100000)
CGAU  COMMON /DORF/ NUMD,NUMF
      DIMENSION EIG(5000),LMOGRP(1000),W(*),NAOST(1000)
      COMMON /LMODAT/VMO(500000),VLMO(500000),LMOLAB(2,1000),
     &LMOATM(5,1000),PGM(100000),ENGLMO(1000),BONDLAB(1000),MCLMO(5,80),
     &LHFLAG
CGMS  COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
CGMS  DATA CHECK  /8HCHECK   /
C
C     DESCRIPTION OF VARIABLES
C
C     GENINF [GENERAL(GLOBAL) INFORMATION]
C
C     ENREP:  	Energy of nuclear repulsion.
C     XYZ:	Cartesian coordinates.
C     NATOM:	Number of atoms in the molecule
C     NELE:	Number of electrons in the molecule.
C     NSPIN:    Number of unpaired spins in the molecule.
C     NBASIS:	Number of basis functions of the molecule.
C     NATNUM:	Nuclear number of atoms.
C     NATBAS:	Number of basis functions on each atom.
C
C     GENCTL [GENERAL(GLOBAL) CONTROL]
C
C     NSUB:	Number of subunits.
C     IMACRO:	Number of maximal macro iterations.
C     IRESTART:	Flag.
C               = 2: Restart job. Read guess. Integrals and HF can be skiped
C               = 1: Read orbital guess from previous VB computation.
C               = 0: New calculation.
C               =-1: Generate LMO only, then stop
C     MROT:     Number of rigid rotation for each macro-iteration
C               Default=1
C     ICON:     Flag
C               = 1  Connect Gaussian
C               = 2  Connect Gamess
C               = 3  Connect existing integral files (must in certain format)
C
C     MELE(99)	Number of electrons for each subunit.
C     MSPIN(99)	Number of unpaired spin for each subunit. (Only on subunit
C               is allowed to have a MPSIN >0. This is the restriction by
C               separability theory).
C     MLORBIT   Number of non-orthogonal orbitals used in each subunit.
C     MNORBIT   Number of linear independent orbitals used in each subunit.
C               MLORBIT >= MNORBIT
C     MWIN(99)  Number of orbitals in the window of the subunit.
C     MSTR(99)	Number of structures(or configurations) in VB (or CI)
C               calculations.
C     METHOD(99)Method for each subunit.
C               =1: Hartree-Fock (for core orbitals)
C               =2: VBSCF
C               =3: SCVB
C               =4: CASVB (=CASSCF)
C               =5: MCSCF (Not Ready)
C
C     IBASIS   	Indeces of orbitals indicating which subunit the orbit belongs
C               to. Thus, if IBASIS(I)=0, then orbital I is a virtual orbital.
C     NOCC	Occupation number.
C               =2: Doublly occupied.
C               =1: Partially occupied.
C               =0: Virtual orbital.
C
C     NEPS      Convergence threshold of total energy
C               (deltaE < 10**(-NEPS))
C               =6 (default)
C
C     FILES:
C               IAO1E  -- ONE-ELECTRON INTEGRALS IN ORIGINAL AO'S(SS,HH)
C               IAO2E  -- TWO-ELECTRON INTEGRALS IN ORIGINAL AO'S
C                         FUNCTIONS
C               IOHFORB-- HF ORBITALS
C               IOVBORB-- VB ORBITALS
C               IVBO2E -- TWO-ELECTRON INTEGRALS IN VBO BASIS SET.
C
C               IOMAP  -- MAP FILE OF VB
C               IOHES  -- FILE FOR HESSIAN
C
C
C     GUESS=READ: INPUT KEYWORD FOR SETTING IRESTART=1
C
C     RESTART:    INPUT KEYWORD ROR SETTING IRESTART=2
C
C
CGMS  DUMMY='            '
CGAU  DUMMY='            '
CGAU  ICON   = 1
CGMS  ICON   = 2
C000  ICON   = 3
CSMI  ICON   = 4
      NEPS   = 6
      IMACRO = 12
      NUMD = 1
      IOLVBO = 0
C
C     READ $GENINF
C
      GO TO (1,2,8),ICON
 1    CONTINUE
CGAU  CALL CONGAU()
      GOTO 8
 2    CONTINUE
CGMS  CALL CONGMS()
      GOTO 8
 8    CONTINUE
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL GETIOUNIT('IOVBORB ',IOVBORB)
      REWIND(IOVBORB,ERR=999)
      IF(IPNT.GT.1) THEN
C     READ(IOVBORB)NSUBX,NDM1X,(MELE(I),I=1,NSUBX),
C     J/NDM1J not used, so change to fool ftnchek.
      READ(IOVBORB)NSUBX,J,(MELE(I),I=1,NSUBX),
     &             (MLORBIT(I),I=1,NSUBX),(METHOD(I),I=1,NSUBX)
        DO I=1, NSUBX
        IF(METHOD(I).EQ.1) MELE(I)=MLORBIT(I)*2
        END DO
      REWIND(IOVBORB,ERR=999)
      GOTO 999
      END IF
      CALL GETVBPATH(VBPATH)
      CSPLIT = 0.15D0
      IF(MROT.LT.0) MROT = 1
C
C     READ CHARGE RATIO FOR SETING SPLITING FLAG
C
      CALL LOCTOR(IOENGI,'$SPLITRATIO',11,IOK,0)
      IF(IOK.GE.1) READ(IOENGI,*,ERR=9991)CSPLIT
      DO 20 I=1,5000
 20   CSTRUC(I)=1.0D0
      REWIND(IOVBORB,ERR=999)
      IF(NBASIS*(NBASIS+1)/2.GT.MAXWKI) CALL ABORT0('INPUTVB01 ')
      DO I=1, NBASIS
      BONDLAB(I) = '        '
      END DO
C
C     TODO: THIS LOGIC NEED MODIFIED GLOBALY
C
      NMO = (NELE+1)/2
C
C     SET RESTART FLAG
C
      IF(MTHEORY.EQ.1)  IRESTART = -1
      REWIND(IOVBORB,ERR=999)
C
C     CHECK IF PREVIOUS VB RESULTS EXIST OR NOT
C
      CALL GETIOUNIT('IOVBORB ',IOVBORB)
      IF(IRESTART.GE.1) THEN
      REWIND(IOVBORB,ERR=100)
      READ(IOVBORB)
      READ(IOVBORB,ERR=100,END=100)NBASISTEMP,NATOMTEMP
      IF(NBASISTEMP.NE.NBASIS.OR.NATOMTEMP.NE.NATOM) GOTO 100
      GOTO 201
 100  IRESTART=0
      WRITE(IOUTVB,*)'THE RESTART FILE IS WRONG!'
 201  CONTINUE
      END IF
C
C     IRESTART: Flag.
C               = 2: Restart job. Read guess. Integrals and HF can be skiped.
C               = 1: Read orbital guess from a previous VB calculaiton
C               = 0: New calculation (default).
C               =-1: Generate LMO only, then stop
C
C     DO LMO, and Store CHAMAX and MAXCHA in A COMMON BLOCK
C
C
C     READ S and MO'S
C
      NSS = 1
      NVV = NSS + NBASIS*(NBASIS+1)/2
      NFF = NVV + NBASIS*NBASIS
C     NPP = NFF + NBASIS*NBASIS
      NAOST(1) = 1
      DO I=1,NATOM
      NAOST(I+1) = NAOST(I) + NATBAS(I)
      END DO
C
C     INITIALIZE MOL TOPOL
C
      CALL INIMOLTOPOL()
C
C     OPEN VBOLIB FILE
C
      CALL GETIOUNIT('IOTEMP  ',IOTEMP)
      IOLVBO = IOTEMP
C     NUMD = 1 INDICATES CARTESIAN D FUNCTIONS AND IS DEFAULT
C     FOR STAND-ALONE VERSION.
      IF(BASNAME.EQ.'D95') THEN
      BAS='D95'
      K=3
      ELSE IF((BASNAME.EQ.'MIDIX'.OR.BASNAME.EQ.'MIDI!').AND.
     &  NUMD.EQ.1) THEN
      BAS='MIDIX'
      K=5
      ELSE IF(BASNAME.EQ.'STO-3G'.OR.BASNAME.EQ.'STO-4G'
     &  .OR.BASNAME.EQ.'STO-6G'.OR.BASNAME.EQ.'GENNG') THEN
      BAS='STO-nG'
      K=6
      ELSE IF(BASNAME.EQ.'3-21G') THEN
      BAS='3-21G'
      K=5
      ELSE IF((BASNAME.EQ.'3-21GSTAR' .OR. BASNAME.EQ.'3-21G*')
     &  .AND.NUMD.EQ.1) THEN
      BAS='3-21GSTAR'
      K=9
      ELSE IF(BASNAME.EQ.'6-31G') THEN
      BAS='6-31G'
      K=5
      ELSE IF((BASNAME.EQ.'6-31G*'.OR.BASNAME.EQ.'6-31GSTAR').AND.
     &  NUMD.EQ.1) THEN
      BAS='6-31GSTAR'
      K=9
      ELSE IF((BASNAME.EQ.'6-31G2STAR' .OR. BASNAME.EQ.'6-31G**')
     &  .AND.NUMD.EQ.1) THEN
      BAS='6-31G2STAR'
      K=10
      ELSE IF((BASNAME.EQ.'6-31PGSTAR' .OR. BASNAME.EQ.'6-31+G*')
     &  .AND.NUMD.EQ.1) THEN
      BAS='6-31PGSTAR'
      K=10
      ELSE IF((BASNAME.EQ.'6-31PPG2STAR' .OR. BASNAME.EQ.'6-31++G**')
     &  .AND.NUMD.EQ.1) THEN
      BAS='6-31PPG2STAR'
      K=12
      ELSE IF(BASNAME.EQ.'TZVP'.AND.NUMD.EQ.1) THEN
      BAS='TZVP'
      K=4
      ELSE IF((BASNAME.EQ.'CC-PVDZ'.OR.BASNAME.EQ.'CCPVDZ')
     &  .AND.NUMD.EQ.1) THEN
      BAS='CCPVDZ'
      K=6
      ELSE IF(BASNAME.EQ.'AUG-CC-PVDZ'.AND.NUMD.EQ.1) THEN
      BAS='AUG-CC-PVDZ'
      K=11
C     All basis sets below are only used in GAMESS/VB2000
C     or GAUSSIAN/VB2000 & to get the VBOLIB.
      ELSE IF((BASNAME.EQ.'CC-PVTZ'.OR.BASNAME.EQ.'CCPVTZ')
     &  .AND.NUMD.EQ.1) THEN
      BAS='CCPVTZ'
      K=6
      ELSE IF((BASNAME.EQ.'CC-PVQZ'.OR.BASNAME.EQ.'CCPVQZ')
     &  .AND.NUMD.EQ.1) THEN
      BAS='CCPVQZ'
      K=6
      ELSE IF(BASNAME.EQ.'AUG-CC-PVTZ'.AND.NUMD.EQ.1) THEN
      BAS='AUG-CC-PVTZ'
      K=11
      ELSE IF(BASNAME.EQ.'AUG-CC-PVQZ'.AND.NUMD.EQ.1) THEN
      BAS='AUG-CC-PVQZ'
      K=11
C     cc-pV5Z is built-in GAMESS basis - no h orbitals (no g on H)
      ELSE IF((BASNAME.EQ.'CC-PV5Z'.OR.BASNAME.EQ.'CCPV5Z')
     &  .AND.NUMD.EQ.1) THEN
      BAS='CCPV5Z'
      K=6
      ELSE IF(BASNAME.EQ.'AUG-CC-PV5Z'.AND.NUMD.EQ.1) THEN
      BAS='AUG-CC-PV5Z'
      K=11
C     These below are only for GAUSSIAN/VB2000. Beyond
C     CC-PVTZ is not possible.
      ELSE IF((BASNAME.EQ.'CC-PVDZ'.OR.BASNAME.EQ.'CCPVDZ')
     &  .AND.NUMD.EQ.0) THEN
      BAS='CCPVDZ-5D'
      K=9
      ELSE IF((BASNAME.EQ.'CC-PVTZ'.OR.BASNAME.EQ.'CCPVTZ')
     &  .AND.NUMD.EQ.0) THEN
      BAS='CCPVTZ-5D'
      K=9
      ELSE IF(BASNAME.EQ.'AUG-CCPVDZ'.AND.NUMD.EQ.0) THEN
      BAS='AUGCCPVDZ-5D'
      K=12
      ELSE
C
      WRITE(IOUTVB,101) BASNAME
 101  FORMAT(' VBO LIB NOT AVAILABLE FOR BASIS SET ',A20)
 102  FORMAT(' ALL FUNCTIONALITY RELATED TO LIB VBO WILL BE DISABLED')
CGAU  WRITE(IOUTVB,'(" POSSIBLY DUE TO USE OF SPHERICAL HARMONICS.")')
      WRITE(IOUTVB,102)
      IOLVBO = 0
      END IF
      IF(IOLVBO.NE.0) THEN
C     Add VBPATH
      CALL PATHST(VBTEMP,VBPATH,'/VBOLIB/VBOLIB  ',BAS,K)
      WRITE(IOUTVB,104) VBTEMP
      OPEN(IOLVBO,FILE=VBTEMP,STATUS='OLD',ERR=135)
      GOTO 136
 135  IOLVBO = 0
      WRITE(IOUTVB,101) BASNAME
      WRITE(IOUTVB,102)
      END IF
 136  CONTINUE
 104  FORMAT(' VBO LIB IS: ',A80)
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL GETIOUNIT('IOHFORB ',IOHFORB)
      CALL READ1E(IAO1E,W(NSS),W(NVV),NBASIS)
      CALL RDMORB(IOHFORB,W(NVV),EIG,NBASIS)
      NOCCORB = (NELE-NSPIN)/2 + NSPIN
      NOCC5V = NOCCORB + 5
      IF(NOCC5V .GT. NBASIS) NOCC5V = NBASIS
CGAU  IF(LPTALL.EQ.1)
CGAU &  CALL MPRINT(W(NVV),EIG,NBASIS,NOCC5V,4,BFLABE,DUMMY)
CGMS  IF (EXETYP.EQ.CHECK) LPTALL = 0
CGMS  IF(LPTALL.EQ.1.AND.IPNT.LE.1)
CGMS &  CALL MPRINT(W(NVV),EIG,NBASIS,NOCC5V,4,BFLABE,DUMMY)
CGMS  CALL FLSHBF(IOUTVB)
C
      NCORE   = NOCCORB
      LPTALLX = LPTALL
      IF(IRESTART.LT.1) LPTALLX = 0
      CALL CHALMO(NBASIS,NCORE,NATOM,NATBAS,BFLABE,W(NVV),W(NSS),PGM,
     &            W(NFF),EIG,CHAMAX,MAXCHA,CSPLIT,LPTALLX)
C
C     CHECK FOR LMOLIB GEN
      CALL LMOLGN(NATOM,NBASIS,NATNUM,XYZ,NATBAS,BFLABE,W(NVV),
     &            IOENGI)
      DO  I = 1, NCORE
      ENGLMO(I) = EIG(I)
      END DO
      IF(IRESTART.LT.1) THEN
      CALL CANLMO(W(NVV),W(NSS),NCORE,NBASIS,CHAMAX,MAXCHA,W(NFF),
     &            NATBAS,CSPLIT,BFLABE,NAOST,IOLVBO,IOENGI,LPTALL)
      END IF
C
C     COPY ALL LMOs to STORAGE
C
      DO I=1, NBASIS*NCORE
      VLMO(I) = W(NVV-1+I)
      END DO
C
C     READ MOs and copy MOs to VMO
C     4321
      CALL RDMORB(IOHFORB,VMO,EIG,NBASIS)
C

C     NAT2=NATOM*(NATOM+1)/2
C     NAT22=NAT2*2
      IF(3*NATOM*(NATOM+1)/2.GT.15000) THEN
         WRITE(IOUTVB,*)"MORE THAN 99 ATOMS"
         CALL ABORT0('INPUTVB02 ')
      END IF
CGMS  IF(MTHEORY.EQ.1) RETURN
C
C     SET DEFAULT GENCTL ACCCORDING TO THE KEY WORDS
C
      IF(MELE(2).GT.NELE) THEN
         WRITE(IOUTVB,*)"THE VB GROUP HAS ",MELE(2)," ELECTRON(S)"
         WRITE(IOUTVB,*)"AND THE MOLECULE HAS ONLY ",NELE," ELECTRON(S)"
         CALL ABORT0('INPUTVB03 ')
      END IF
      IF(1.LT.MTHEORY.AND.MTHEORY.LT.5) THEN
        IF(MELE(2).EQ.NELE) THEN
        NSUB = 1
        MELE(1)    = MELE(2)
        MLORBIT(1) = MLORBIT(2)
        METHOD(1) = METHOD(2)
        ELSE
        NSUB = 2
        MELE(1)   = NELE - MELE(2)
        MLORBIT(1) = MELE(1)/2
        METHOD(1) = 1
        END IF
      END IF
C
C     DOT NOTATION
C
      IF(MTHEORY.EQ.6) THEN
        METOTAL = 0
        DO I=2, NGPF
        METOTAL = METOTAL + MELE(I)
        END DO
        IF(METOTAL.EQ.NELE) THEN
C       HARTREE-FOCK GROUP DOES NOT EXIST
        NSUB = NGPF - 1
          DO I=1, NGPF - 1
          MELE(I)   = MELE(I+1)
          MLORBIT(I) = MLORBIT(I+1)
          METHOD(I) = METHOD(I+1)
          END DO
        ELSE
        NSUB = NGPF
        MELE(1)   = NELE-METOTAL
        MLORBIT(1) = MELE(1)/2
        METHOD(1) = 1
        END IF
      END IF
C
      IF(MTHEORY.EQ.5) THEN
      NSUB = NGPF
C
C     THE DEFAULT WILL BE A NGPF-1 GVB PAIRS
C
        DO I=2,NSUB
        MELE(I)=2
        METHOD(I)=2
        END DO
        MELE(1)=NELE-2*(NSUB-1)
        METHOD(1) =1
        MLORBIT(1) = MELE(1)/2
      END IF
      IF(MTHEORY.NE.5) GOTO 110
C
C     READ GENERAL CONTROL
C
      CALL LOCTOR(IOENGI,'$GENCTL',7,IOK,1)
      IF(IOK.EQ.0) THEN
      WRITE(IOUTVB,*)'WARNING: GENCTL IS MISSING, GVB IS ASSUMED'
      ELSE
      READ(IOENGI,*,ERR=9992)(MELE(I),I=1,NSUB)
      READ(IOENGI,*,ERR=9993)(METHOD(I),I=1,NSUB)
        DO I=1, NSUB
        IF(METHOD(I).EQ.1) MLORBIT(I) = MELE(I)/2
        END DO
      END IF
 110  CONTINUE
C
C     CHECK FOR SPHERICAL HARMONIC OPTION
C
      IF(KEY(15).EQ.1) THEN
        CALL COUNTNSP(NBASIS,BFLABE,NSHBAS)
        IF(NSHBAS.GT.0) THEN
           NSUB = NSUB+1
           METHOD(NSUB) =  99
           MLORBIT(NSUB) = NSHBAS
           MNORBIT(NSUB) = NSHBAS
           MELE(NSUB) = 0
        END IF
      END IF
C
C     SET DEFAULT SPIN FOR EACH GROUP ACCORDING TO ITS NUMBER OF ELECTRONS
C
      DO I=1,NSUB
        MSPIN(I) = 0
      END DO
      IF(MELE(NSUB).GT.0) MSPIN(NSUB)=NSPIN
      IF(MELE(NSUB).EQ.0) MSPIN(NSUB-1)=NSPIN
C
C     SET THE DEFAULT LMO GROUP ASSIGNMENT ACCORDING TO MELE(I) AND MSPIN(I)
C
      DO I=1, NCORE
      LMOGRP(I) = 1
      END DO
      DO I=NCORE+1,NBASIS
      LMOGRP(I)=0
      END DO
      NTMP=NCORE
      DO I=NSUB,1,-1
        DO J=1, (MELE(I)+MSPIN(I))/2
        IF(NTMP.LE.0) CALL ABORT0('INPUTVBTMP')
        LMOGRP(NTMP)=I
        NTMP=NTMP-1
        END DO
      END DO
C
C     POSSIBLE MODIFICATION OF LMO GROUP ASSIGNMENT
C     FORMAT: BOND ATOM_I-ATOM_J (TYPE: SIGMA/PI(1/2)) BELONGS TO GROUP K
C     SHORT-HAND: BOND(I,J,K) (TYPE)
C                 TYPE=0 (SIGMA)
C                      1 (PI-1)
C                      2 (PI-2)
C     OR LMO(X) BELONGS TO GROUP K: SHORT-HAND LMO(X,K)
C
C     LOOK FOR $LMOGROUP
C
      CALL LOCTOR(IOENGI,'$LMOGROUP',9,IOK,0)
      IF(IOK.EQ.1) THEN
 120    READ(IOENGI,'(A80)',ERR=125,END=125)BUFF
        CALL CONVCASE(BUFF,80,1)
        ICURSOR=1
        LENW=0
        LENBUF=80
        I=0
        J=0
        K=0
        ITYPE=0
        WORD = ' '
        CALL READWDM(BUFF,WORD,LENW,ICURSOR,LENBUF)
        IF(WORD.EQ.'BOND') THEN
          CALL READNUM(BUFF,I,LENW,ICURSOR,LENBUF)
          CALL READNUM(BUFF,J,LENW,ICURSOR,LENBUF)
          CALL READNUM(BUFF,K,LENW,ICURSOR,LENBUF)
          CALL READNUM(BUFF,ITYPE,LENW,ICURSOR,LENBUF)
          IF(I.EQ.0.OR.J.EQ.0.OR.K.EQ.0) CALL ABORT0('INPUTVBIJK')
          IBTYPE = ITYPE + 1
          CALL LOOKLMODX(I,J,IBTYPE,LMOLAB,NMO,IORBINDEX)
          IF(IORBINDEX.GT.0) THEN
          LMOGRP(IORBINDEX)=K
          ELSE
          WRITE(IOUTVB,*)'Invalid bond specification, discard it'
          END IF
        GOTO 120
        ELSE IF(WORD.EQ.'LMO') THEN
C
C     MAYBE SOME VIRTUAL ORBITALS ARE INVOLVED
C
          CALL READNUM(BUFF,I,LENW,ICURSOR,LENBUF)
          CALL READNUM(BUFF,K,LENW,ICURSOR,LENBUF)
          IF(I.EQ.0.OR.K.EQ.0) CALL ABORT0('INPUTVBIK ')
          LMOGRP(I)=K
        GOTO 120
        ELSE
        GOTO 125
        END IF
      END IF
 125  CONTINUE
C
C     LOOK FOR VALENCE BOND GROUP ASSIGNMENT
C
C     SEARCH FOR $VBGROUPASSIGNMENT OR $VBGA
C
C     IF THE ONE OF THE FLAG EXISTS, ALL PREVIOUS SETTING WILL BE OVER TAKEN
C
      CALL VBGRPA(IOENGI,LMOGRP,LMOLAB,NMO)
C
C     LMOGROUPMODIFY OVER WRITE ALL PREVIOUS SETTING
C
      CALL LOCTOR(IOENGI,'$LMOGRPMODIFY',13,IOK,0)
      IF(IOK.EQ.1) THEN
        READ(IOENGI,*)LMOMD
        WRITE(IOUTVB,*)'MODIFICATION OF LMO GROUP ASSIGNMENT:'
        DO JJ = 1, LMOMD
        READ(IOENGI,*,ERR=9994)IORBINDEX, LMOGRP(IORBINDEX)
C       WRITE(IOUTVB,106) iorbindex, LMOGRP(iorbindex)
        WRITE(IOUTVB,106) IORBINDEX, LMOGRP(IORBINDEX)
 106  FORMAT(' LMO# =',I2,' GROUP# =',I2)
        END DO
      END IF
C     LOOK FOR $LMOGROUP
C
C     SET THE DEFAULT MLORBIT(K) ACCORDING TO LMOs of GROUP K
C
C
      DO K=1,NSUB
      MELEK=0
      MORBK=0
      DO I=1,NCORE
        IF(LMOGRP(I).EQ.K) THEN
        ICOVA=0
        RAT1=DABS(CHAMAX(2,I)/CHAMAX(1,I))
        IF(RAT1.GT.CSPLIT) ICOVA=1
        MELEK=MELEK+2
        MORBK=MORBK+1
        IF(METHOD(K).GT.1.AND.ICOVA.EQ.1) MORBK=MORBK+1
        END IF
      END DO
C
C     ONLY MODIFY THE DEFAULT NUMBER OF ORBITALS FOR VB(N) GROUP
C
      IF(METHOD(K).EQ.2) THEN
        MLORBIT(K)=MORBK
      ENDIF
      IF(MELEK.NE.MELE(K)) WRITE(IOUTVB,*)'WARNING: MELEK != MELE(K)'
      END DO
C
C
C     POSSIBLE MODIFICATION OF MLORBIT(K) AND SPLIT FLAGS
C
      CALL LOCTOR(IOENGI,'$GRPDIM',7,IOK,0)
      NSUBX = NSUB
      IF(MELE(NSUB).EQ.0) NSUBX = NSUB - 1
      IF(IOK.EQ.1) THEN
        READ(IOENGI,*,ERR=9995)(MLORBIT(K),K=1,NSUBX)
      END IF
C
C     SET MLORBIT FOR CASVB(m,n) WITH EXPLICIT NUMBER OF ORBITALS
C     GRPDIM WILL BE IGNORED.
C
C     IF(MTHEORY.EQ.4) THEN
C       NSUB = 2
C       IF(MELECTRONS.EQ.NELE) NSUB=1
C       IF(NSUB.EQ.2) THEN
C       MLORBIT(2) = NORBITALS
C       MLORBIT(1) = MELE(1)/2
C       ELSE
C       MLORBIT(1) = NORBITALS
C       END IF
C     END IF
 999  CONTINUE
C
C     POSSIBLE MODIFICATION OF THE DEFAULT VALUE OF IMACRO
C
      CALL LOCTOR(IOENGI,'$MACROITER',10,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*,ERR=9996)IMACRO
      END IF
C
C     READ OPTIONS IN GENERAL CONTROL
C
      CALL LOCTOR(IOENGI,'$FROZEN',7,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)LFROZN
      CALL LOCTOR(IOENGI,'$CIONLY',7,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)LCIONLY
      CALL LOCTOR(IOENGI,'$NOBIAS',7,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)NOBIAS
      CALL LOCTOR(IOENGI,'$ROTATION',9,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*,ERR=9997)MROT
      CALL LOCTOR(IOENGI,'$ECONV',6,IOK,0)
C     IF(IOK.EQ.1) THEN
      IF(IOK.EQ.1) READ(IOENGI,*,ERR=9998) NEPS
C       WRITE(IOUTVB,105) NEPS
C105  FORMAT(/,' MACROITERATION CONVERGENCE TOLERANCE',
C    &   /,' ALTERED TO 10.00**(-',I1,').',/)
C     ENDIF
      CALL LOCTOR(IOENGI,'$HYBRID',7,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)LHYBRD
      CALL LOCTOR(IOENGI,'$PRINTALL',9,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)LPTALL
C
C999  CONTINUE
C
C     SET DEFAULT MNORBIT, WHICH IS EQUAL TO MLORBIT
C     FOR BOVB TYPE CALCULATION OR SOME SPECIAL CASES,
C     MNORBIT CAN BE DIFFERENT FROM MLORBIT
C
      DO I=1, NSUB
      MNORBIT(I) = MLORBIT(I)
      END DO
C
C
      NORBT=0
      DO I=1,NSUB
      NORBT=NORBT+MLORBIT(I)
      END DO
      NVIRX=NBASIS-NORBT
      DO I=1,NSUB*(NSUB+1)/2
      NOTROT(I)=0
      END DO
      DO I=1,NSUB
C
C     TURN OFF ROTATION PAIR OF CORE AND VIRTUAL GROUPS, ASSUME
C     THAT CHFSCF IS CALLED FOR CORE ORBITALS OPTIMIZATION WITHIN THE
C     OPTIMIZATION WINDOW INCLUDING THE VIRTUAL ORBITALS
C
      IF(METHOD(I).NE.1) THEN
      MWIN(I)=MLORBIT(I)
      ELSE
      IJ=NSUB*(NSUB-1)/2+I
C
C     TODO: NEED TO BE RESET
C
      MWIN(I)=MLORBIT(I)+NVIRX
      NOTROT(IJ)=1
      END IF
      END DO
C
C     IF(FROZEN CORE IS TRUE, TURN OFF ROTATION PAIR OF CORE AND ANY OTHER
C     GROUP
C
      IJ=0
      DO I=1,NSUB
      DO J=1,I-1
      IJ=IJ+1
      IF((METHOD(I).EQ.1.OR.METHOD(J).EQ.1).AND.LFROZN.EQ.1)
     & NOTROT(IJ)=1
      END DO
      END DO
C
C     TURN OFF FOR PAIRS WITH ZERO ELECTRON GROUP
C
      IJ=0
      DO I=1,NSUB
      DO J=1,I-1
      IJ=IJ+1
      IF(MELE(I).EQ.0.OR.MELE(J).EQ.0)
     & NOTROT(IJ)=1
      IF(MELE(I).EQ.0) THEN
          NOTROT(IJ00(I,NSUB))=1
      END IF
      END DO
      END DO
C
C     TURN OFF ROTATIONS BETWEEN SUBUNITS SPECIFIED IN NOTROT
C
      CALL LOCTOR(IOENGI,'$NOTROT',7,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*,ERR=9999)NROTPAIR
       DO I=1,NROTPAIR
       READ(IOENGI,*,ERR=9999)NR1,NR2
        IF(NR1.NE.NR2) THEN
          NR3=NR2
          IF(NR1.GT.NR2) THEN
          NR3=NR1
          NR1=NR2
          END IF
          NOTROT(IJ00(NR1,NR3-1))=1
        END IF
       END DO
      END IF
C999  CONTINUE
C
C     NEXTRA: RESEVED EXTRA SPACE FOR REDUNDANT ORBITALS IN BOVB TYPE
C             CALCULATION
C
      NEXTRA  = 20
C
C     IF MROT = 0, and LCIONLY = 1, SET IMACRO = 1
C
C     IF(MROT.EQ.0.AND.LCIONLY.EQ.1) IMACRO = 1
C     ERROR CHECKING
C
      IF(NSPIN.EQ.0.AND.(NELE/2)*2.NE.NELE) THEN
        WRITE(IOUTVB,*)"THE NUMBER OF ELECTRONS AND THE MULTIPLICITY IS"
        WRITE(IOUTVB,*)"INCONSISTANT"
        CALL ABORT0('INPUTVB04 ')
      END IF
C     SET DEFAULT VALUES FOR NOCC AND IBASIS
      NOB=0
      NST=0
      DO K=1,NSUB
      NST=NST+MSPIN(K)
      IF(METHOD(K).EQ.1.AND.MELE(K).NE.MLORBIT(K)*2) THEN
      WRITE(IOUTVB,*)'K,MELE(K),MLORBIT(K) =',K,MELE(K),MLORBIT(K)
C     CALL ABORT0('INPUTVB05 ')
      END IF
      IF(MELE(K).GT.MLORBIT(K)*2) THEN
      WRITE(IOUTVB,*)
     &       "THE NUMBER OF ELECTRONS IS MORE THAN THE DOUBLE OF "
      WRITE(IOUTVB,*)"THE NUMBER OF ORBITALS IN THIS GROUP"
      WRITE(IOUTVB,*)"K,MELE(K),MLORBIT(K) = ",K,MELE(K),MLORBIT(K)
      CALL ABORT0('INPUTVB06 ')
      END IF
      DO I=1,MLORBIT(K)
      NOB=NOB+1
      IF(METHOD(K).EQ.1) THEN
      NOCC(NOB)=2
      ELSE
      NOCC(NOB)=1
      END IF
      IBASIS(NOB)=K
      END DO
      END DO
      IF(NST.NE.NSPIN) CALL ABORT0('INPUTVB07 ')
      DO I=NOB+1,NBASIS+NEXTRA
      IBASIS(I)=0
      NOCC(I)=0
      END DO
C999  CONTINUE
C     NBA2=NBASIS*(NBASIS+1)/2
C
C     SCANE VBORB INPUT
C
      CALL SCANVBO(NSUB,MLORBIT)
C
C     Setup addresses for density matrices in local nonorthogonal basis sets
C     and vise verse
C
C     Note:  For core electrons, special treatment can be used so that both
C            1D and 2D are not necessary
C            This will be implemented later
C
C
C     Setup addresses for local transformation matrices from nonorthogonal to
C     orthogonal orbitals and vise verse
C
C     2D for Core electron group is skipped. March 26,04/JL
C
      NAOBAS    = 1
      LAOBAS    = NAOBAS + (NEXTRA+NBASIS)*NBASIS
      NOCBAS    = LAOBAS + NBASIS*NBASIS
      NB1ADD(1) = 1
      NB2ADD(1) = 1
      N1DADD(1) = 1
      DO 200 I=1,NSUB
      NB1ADD(I+1) = NB1ADD(I)+MLORBIT(I)
      NB2ADD(I+1) = NB2ADD(I)+MLORBIT(I)*MLORBIT(I)
 200  CONTINUE
      DO 300 I=1,NSUB
      MSQ         = MLORBIT(I)*(MLORBIT(I)+1)/2
      N1DADD(I+1) = N1DADD(I) + MSQ
 300  CONTINUE
      N2DADD(1)   = 1
      DO 400 I=1,NSUB
      IF(METHOD(I).GT.1) THEN
      MSQ         = MLORBIT(I)*(MLORBIT(I)+1)/2
      N2DADD(I+1) = N2DADD(I) + MSQ*(MSQ+1)/2
      ELSE
      N2DADD(I+1) = N2DADD(I) + 1
      END IF
 400  CONTINUE
      LOCBAS      = NOCBAS + NB2ADD(NSUB+1)-1
      ND1STA      = LOCBAS + NB2ADD(NSUB+1)-1
      ND2STA      = ND1STA + N1DADD(NSUB+1)-1
      LD1STA      = ND2STA + N2DADD(NSUB+1)-1
      LD2STA      = LD1STA + N1DADD(NSUB+1)-1
      LGDMP       = LD2STA + N2DADD(NSUB+1)-1
C     GENERATE INITIAL GUESS OF ORBITALS
      MSIZE1=MSIZE-ND2STA
      IF(MSIZE1.LE.0) THEN
CGMS     WRITE(IOUTVB,1050) ND2STA
         CALL ABORT0('INPUTVB08 ')
      ENDIF
      CALL IGUESS(W(NAOBAS),W(ND1STA),W(ND2STA),LMOGRP,MSIZE1,IOLVBO,
     &            NEXTRA)
C
      IF(MTHEORY.EQ.1) GOTO 998
C     WRITE OUT GENERAL CONTROL
C
      WRITE(IOUTVB,1000)NSUB,IMACRO,NEPS,IRESTART
      WRITE(IOUTVB,1005)(I,I=1,NSUB)
      WRITE(IOUTVB,1010)(MELE(I),I=1,NSUB)
      WRITE(IOUTVB,1020)(MSPIN(I),I=1,NSUB)
      WRITE(IOUTVB,1030)(MLORBIT(I),I=1,NSUB)
      WRITE(IOUTVB,1040)(METHOD(I),I=1,NSUB)
CGMS  CALL FLSHBF(IOUTVB)
 1000 FORMAT(/'      GENERAL CONTROLS ($GENCTL)'
     &        /1X,36(1H=)/' Number of electron groups       =',I5
     &                   /' Maximum macro-iterations        =',I5
     &                   /' Energy threshold           = 10**(-',I2,')',
     &                   /' Restart calculation(0/1/2)      =',I5)
 1005 FORMAT(' Group#                  ',I4,20I3)
 1010 FORMAT(' Num. of electrons       ',I4,20I3)
 1020 FORMAT(' Num. of spins           ',I4,20I3)
 1030 FORMAT(' Num. of orbitals        ',I4,20I3)
 1040 FORMAT(' Method#                 ',I4,20I3)
 1050 FORMAT(' INSUFFICIENT MEMORY - USE $MEMORY EXPLICITLY',
     1' TO SELECT MORE THAN',I12,' WORDS.')
C
 998  IF(IOLVBO.GT.0) CLOSE(IOLVBO)
      RETURN
C     ERROR MESSAGES
C
 9991 WRITE(IOUTVB,*)"ERROR IN $CSPLITRATIO"
      CALL ABRTVB
 9992 WRITE(IOUTVB,*)"ERROR IN $GENCTL: MELE(I)"
      CALL ABRTVB
 9993 WRITE(IOUTVB,*)"ERROR IN $GENCTL: METHOD(I)"
      CALL ABRTVB
 9994 WRITE(IOUTVB,*)"ERROR IN $LMOGRPMODIFY"
      CALL ABRTVB
 9995 WRITE(IOUTVB,*)"ERROR IN $GRPDIM"
      CALL ABRTVB
 9996 WRITE(IOUTVB,*)"ERROR IN $MACROITER"
      CALL ABRTVB
 9997 WRITE(IOUTVB,*)"ERROR IN $ROTATION"
      CALL ABRTVB
 9998 WRITE(IOUTVB,*)"ERROR IN $ECONV"
      CALL ABRTVB
 9999 WRITE(IOUTVB,*)"ERROR IN $NOTROT"
      CALL ABRTVB
      END
      SUBROUTINE LOOKLMODX(NATOMI,NATOMJ,IBTYPE,LMOLAB,NLMO,IORBINDEX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION LMOLAB(2,NLMO)
      IORBINDEX = 0
      IF(NATOMI.GE.NATOMJ) THEN
      NAIJ = NATOMI*(NATOMI-1)/2 + NATOMJ
      ELSE
      NAIJ = NATOMJ*(NATOMJ-1)/2 + NATOMI
      END IF
      DO I=1, NLMO
      IF(LMOLAB(1,I).EQ.NAIJ.AND.LMOLAB(2,I).EQ.IBTYPE) THEN
      IORBINDEX = I
      RETURN
      END IF
      END DO
      RETURN
      END
      SUBROUTINE VBGRPA(IOENGI,LMOGRP,LMOLAB,NLMO)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 BUFF
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION LMOGRP(*),LMOLAB(2,*),NVBOCODE(20)
      CALL LOCTOR(IOENGI,'$VBGROUPASSIGNMENT',18,IOK,0)
      IF(IOK.EQ.0) THEN
      CALL LOCTOR(IOENGI,'$VBGA',5,IOK,0)
      END IF
      IF(IOK.EQ.1) THEN
C
C     IF VBGA IS DETECTED, ALL PREVIOUS SETTING WILL BE OVER TAKEN
C
      DO I=1, NLMO
      LMOGRP(I) = 1
      END DO
C
 120    READ(IOENGI,'(A80)',ERR=200,END=200)BUFF
        CALL CONVCASE(BUFF,80,1)
        ICURSOR=1
        LSTRING=80
        CALL VBGAPARSER(BUFF,ICURSOR,LSTRING,NVBOCODE,IERR)
        IF(IERR.EQ.1) GOTO 200
        NATOM1 = NVBOCODE(1)
        NATOM2 = NVBOCODE(2)
        IBTYPE = NVBOCODE(3)
        IBORDE = NVBOCODE(4)
        IGROUP = NVBOCODE(5)
C
C       LP
C
        IF(IBTYPE.EQ.3) THEN
        NATOM2 = NATOM1
        CALL LOOKLMODX(NATOM1,NATOM2,IBORDE,LMOLAB,NLMO,IORBINDEX)
          IF(IORBINDEX.GT.0) THEN
            LMOGRP(IORBINDEX) = IGROUP
          ELSE
            WRITE(IOUTVB,*)'!!! NO LP IS FOUND ON THIS ATOM !!!'
          END IF
C
C       SINGLE BOND
C
        ELSE IF(IBTYPE.EQ.4) THEN
        CALL LOOKLMODX(NATOM1,NATOM2,IBORDE,LMOLAB,NLMO,IORBINDEX)
          IF(IORBINDEX.GT.0) THEN
            LMOGRP(IORBINDEX) = IGROUP
          ELSE
            WRITE(IOUTVB,*)'!!! NO BOND FOUND ON THE ATOM PAIR !!!'
          END IF
C
C       DOUBLE BOND
C
        ELSE IF(IBTYPE.EQ.5) THEN
        IBORDE = 1
        CALL LOOKLMODX(NATOM1,NATOM2,IBORDE,LMOLAB,NLMO,IORBINDEX)
          IF(IORBINDEX.GT.0) THEN
            LMOGRP(IORBINDEX) = IGROUP
          ELSE
            WRITE(IOUTVB,*)
     &       '!!! NO SIGMA BOND FOUND ON THE ATOM PAIR !!!'
          END IF
        IBORDE = 2
        CALL LOOKLMODX(NATOM1,NATOM2,IBORDE,LMOLAB,NLMO,IORBINDEX)
          IF(IORBINDEX.GT.0) THEN
            LMOGRP(IORBINDEX) = IGROUP
          ELSE
            WRITE(IOUTVB,*)'!!! NO PI BOND FOUND ON THE ATOM PAIR !!!'
          END IF
C
C       TRIPLE BOND
C
        ELSE IF(IBTYPE.EQ.6) THEN
        IBORDE = 1
        CALL LOOKLMODX(NATOM1,NATOM2,IBORDE,LMOLAB,NLMO,IORBINDEX)
          IF(IORBINDEX.GT.0) THEN
            LMOGRP(IORBINDEX) = IGROUP
          ELSE
            WRITE(IOUTVB,*)'!!! NO SIGMA FOUND ON THE ATOM PAIR !!!'
          END IF
        IBORDE = 2
        CALL LOOKLMODX(NATOM1,NATOM2,IBORDE,LMOLAB,NLMO,IORBINDEX)
          IF(IORBINDEX.GT.0) THEN
            LMOGRP(IORBINDEX) = IGROUP
          ELSE
            WRITE(IOUTVB,*)
     &       '!!! NO FIRST PI BOND FOUND ON THE ATOM PAIR !!!'
          END IF
        IBORDE = 3
        CALL LOOKLMODX(NATOM1,NATOM2,IBORDE,LMOLAB,NLMO,IORBINDEX)
          IF(IORBINDEX.GT.0) THEN
            LMOGRP(IORBINDEX) = IGROUP
          ELSE
            WRITE(IOUTVB,*)
     &       '!!! NO SECOND PI BOND FOUND ON THE ATOM PAIR !!!'
          END IF
        LMOGRP(IORBINDEX) = IGROUP
        ELSE IF(IBTYPE.EQ.7) THEN
        CALL LOOKLMODX(0,0,IBORDE,LMOLAB,NLMO,IORBINDEX)
          IF(IORBINDEX.GT.0) THEN
            LMOGRP(IORBINDEX) = IGROUP
          ELSE
            WRITE(IOUTVB,*)'!!! NO MC BOND FOUND !!!'
          END IF
        LMOGRP(IORBINDEX) = IGROUP
C
C       ERROR
C
        ELSE
        WRITE(IOUTVB,*)"ERROR IN VB GROUP ASSIGNMENT"
        CALL ABORT0('VBGRPA01  ')
        END IF
        IF(IERR.EQ.0) GOTO 120
      END IF
 200  CONTINUE
      RETURN
      END
      SUBROUTINE VBGAPARSER(BUFF,ICURSOR,LSTRING,NVBOCODE,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*1 BUFF(*)
      DIMENSION NVBOCODE(*)
      CALL VBOCRD(BUFF,ICURSOR,LSTRING,NVBOCODE,IERR)
      IF(IERR.EQ.1) RETURN
      DO I=ICURSOR, LSTRING
      IF(BUFF(I).EQ.'='.AND.BUFF(I+1).EQ.'>') THEN
      ICURSOR = I + 2
      GOTO 100
      END IF
      END DO
 100  CONTINUE
      CALL RNUMRD(BUFF,RNUMBER,ICURSOR,LSTRING,INTCODE,IERR)
      IF (IERR.EQ.1.OR.INTCODE.NE.1) THEN
      IERR = 1
      RETURN
      END IF
      NVBOCODE(5) = INT(RNUMBER + 1.0D-6)
      RETURN
      END
      SUBROUTINE INIGDM(NBASIS,NSUB,MLORBIT,ISPLIT,NGP,NATOM)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Initialize 1E density matrix.
C     Note:
C
C     History:
C               First created in July, 1998.
C               Fixed a bug for setting default spliting flags for groups with
C               odd number of electrons. Split higher energy bonding orbitals
C               first. August, 2003.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION MLORBIT(*),ISPLIT(*),NGP(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     NBA2=NBASIS*(NBASIS+1)/2
C
C     MLORBIT(K): NUMBER OF ORBITALS FOR GROUP K
C     MELE(K):   NUMBER OF ELECTRONS IN GROUP K
C
C     SET DEFAULT GROUP # AND SPLIT SWITCHES FOR LMO
C
C     IN A GROUP, THE BONDING LMOs SHOULD SPLIT FIRST. THEN THE HIGHER
C     ENERGY ONES ARE SPLIT FIRST
C
      NLMO=0
      DO 100 K=1,NSUB
C
C     CHECK HOW MANY ORBITALS ARE ASSIGNED TO SUB GROUP K
C
         NGPCOUNT = 0
         DO L=1,NBASIS
         IF(NGP(L).EQ.K)  NGPCOUNT=NGPCOUNT+1
         END DO
      NOB   =MLORBIT(K)
C     NUNSPL=MELE(K)-NOB
      NUNSPL=2*NGPCOUNT-NOB
      NCT=0
      DO 100 L=1,NBASIS
      IF(NGP(L).EQ.K) THEN
      NLMO=NLMO+1
      NCT=NCT+1
      ISPLIT(L)=0
      IF(NCT.GT.NUNSPL.AND.NATOM.GT.1) ISPLIT(L)=1
      END IF
  100 CONTINUE
C     LMOGRP=0
C
C     Modify SPLITING FLAGS if necessary
C
C     call loctor(IOENGI,'$LMOSPLIT',9,IOK,0)
C     IF(IOK.EQ.1) THEN
C     READ(5,*)LMOSPLIT
C     READ(5,*)(MODIORB,ISPLIT(MODIORB),K=1,LMOSPLIT)
C     END IF
      LMO=NLMO
C     IF(LMOGRP.GT.LMO) LMO=LMOGRP
      KS=1
      NGROUP=(LMO+19)/20
      WRITE(IOUTVB,900)
      DO I=1,NGROUP
      KT=KS+19
      IF(KT.GT.LMO) KT=LMO
      WRITE(IOUTVB,1000)(K,K=KS,KT)
      WRITE(IOUTVB,1100)(NGP(K),K=KS,KT)
      WRITE(IOUTVB,1200)(ISPLIT(K),K=KS,KT)
      KS=KS+20
      END DO
      WRITE(IOUTVB,*)
  900 FORMAT(/' PARTITIONING OF LMOs INTO GROUPS ($LMOGRP)'/
     & 1X,71(1H=))
 1000 FORMAT( ' LMO#   ',20I3)
 1100 FORMAT( ' Group# ',20I3)
 1200 FORMAT( ' Split  ',20I3/)
      RETURN
      END
      SUBROUTINE ININDM(NSUB,MELE,MLORBIT,DM1NON)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION MELE(*),MLORBIT(*),DM1NON(*)
C
C     ASSUME ORBITALS ARE NORMALIZED
C
      NODADD=0
      DO K=1,NSUB
      KSQ=MLORBIT(K)*(MLORBIT(K)+1)/2
        DO L=1,KSQ
        DM1NON(NODADD+L)=0.0D0
        END DO
        OCC=DFLOAT(MELE(K))/MLORBIT(K)
        DO L=1,MLORBIT(K)
        LL=L*(L+1)/2
        DM1NON(NODADD+LL)=OCC
        END DO
      NODADD=NODADD+KSQ
      END DO
      RETURN
      END
      SUBROUTINE VBOSYM(NBASIS,BASIS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION BASIS(NBASIS,*),NP(1000),CP(1000),NPAIR(2,100)
C     IOENGI = 80
      CALL GETIOUNIT('IOENGI  ',IOENGI)
C
C     LOOK FOR VBOSYM FLAG
C
      CALL LOCTOR(IOENGI,'$VBOSYM',7,IOK,0)
      IF(IOK.EQ.0) RETURN
      READ(IOENGI,*)NPA,(NPAIR(1,I),NPAIR(2,I),I=1,NPA)
      READ(IOENGI,*)NMOD,(NP(I),I=1,NMOD)
      DO 100 I=1,NPA
      READ(IOENGI,*)NMOD,(CP(J),J=1,NMOD)
       DO 110 J=1,NMOD
       BASIS(J,NPAIR(1,I))=BASIS(NP(J),NPAIR(2,I))*CP(J)
 110  CONTINUE
 100  CONTINUE
      RETURN
      END
      SUBROUTINE LMOTRN(NBASIS,BASIS,W,NATOM,PGM,EIG,PM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION BASIS(NBASIS,*),W(NBASIS,*),LMO(100),KMO(100),C(100)
      DIMENSION PGM(NATOM,*),PM(NATOM,*),EIG(*),EIGW(5000)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     IOENGI = 80
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      DO I=1,NBASIS
      EIGW(I)=EIG(I)
      END DO
C
C     LOOK FOR LMO TRANSFORMATION FLAG
C
      CALL LOCTOR(IOENGI,'$LMOTRAN',8,IOK,0)
      IF(IOK.EQ.0) RETURN
      READ(IOENGI,*)NTRAN
      READ(IOENGI,*)(LMO(I),I=1,NTRAN)
      DO 100 I=1,NTRAN
      READ(IOENGI,*)NMO
      READ(IOENGI,*)(KMO(K),K=1,NMO)
      READ(IOENGI,*)(C(K),K=1,NMO)
      WRITE(IOUTVB,*)NMO
      WRITE(IOUTVB,*)(KMO(K),K=1,NMO)
      WRITE(IOUTVB,*)(C(K),K=1,NMO)
      DO 110 J=1,NATOM
      PM(J,I)=0.0D0
        DO 110 K=1,NMO
        PM(J,I)=PM(J,I)+C(K)*C(K)*PGM(J,KMO(K))
 110  CONTINUE
      SUM=0.0D0
      EIGW(I)=0.0D0
        DO 115 K=1,NMO
        SUM=SUM+C(K)*C(K)
        EIGW(I)=EIGW(I)+C(K)*C(K)*EIG(KMO(K))
 115  CONTINUE
      EIGW(I)=EIGW(I)/SUM
      DO 100 J=1,NBASIS
      W(J,I)=0.0D0
        DO 100 K=1,NMO
        W(J,I)=W(J,I)+C(K)*BASIS(J,KMO(K))
 100  CONTINUE
      DO 200 J=1,NBASIS
      WRITE(IOUTVB,1000)(W(J,I),I=1,NTRAN)
      DO 200 I=1,NTRAN
 200  BASIS(J,LMO(I))=W(J,I)
      DO 210 J=1,NATOM
      WRITE(IOUTVB,1000)(PM(J,I),I=1,NTRAN)
      DO 210 I=1,NTRAN
 210  PGM(J,LMO(I))=PM(J,I)
      DO 220 I=1,NTRAN
 220  EIG(LMO(I))=EIGW(I)
 1000 FORMAT(10F8.5)
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     SETUP TRANSFORMATION MATRICES FOR THE BASIS FUNCTIONS OF CARTESIAN SPACE
C
C     INPUT: ROTATION MATRIX RT(3,3): V' = R V
C
C     TRANP(3,3)   FOR P ORBITALS
C     TRAND(6,6)   FOR D ORBITALS
C     TRANF(10,10) FOR F ORBITALS
C
C     X,Y,Z
C     1 2 3
C
C
C     XX,YY,ZZ,XY,XZ,YZ
C     1  2  3  4  5  6
C
C     Frist version: May 29, 2003
C     Fixed the denormalization bug for TRAND: Jan 17, 2005
C     Fixed RIJ bug for TRAND: Oct 27, 2005
C
C     Author: Jiabo Li
C     San Diego
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE MOLTRAN(R3D,TRANP,TRAND,TRANF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION R3D(3,3)
      DIMENSION TRANP(3,3),TRAND(6,6),TRANF(10,10)
      DO I=1, 3
        DO J=1, 3
C       TR(I,J)    = R3D(J,I)
        TRANP(I,J) = R3D(I,J)
        END DO
      END DO
      R11 = TRANP(1,1)
      R12 = TRANP(2,1)
      R13 = TRANP(3,1)
      R21 = TRANP(1,2)
      R22 = TRANP(2,2)
      R23 = TRANP(3,2)
      R31 = TRANP(1,3)
      R32 = TRANP(2,3)
      R33 = TRANP(3,3)
      TRAND(1,1) = R11*R11
      TRAND(2,1) = R12*R12
      TRAND(3,1) = R13*R13
      TRAND(4,1) = R11*R12 + R12*R11
      TRAND(5,1) = R11*R13 + R13*R11
      TRAND(6,1) = R12*R13 + R13*R12
      TRAND(1,2) = R21*R21
      TRAND(2,2) = R22*R22
      TRAND(3,2) = R23*R23
      TRAND(4,2) = R21*R22 + R22*R21
      TRAND(5,2) = R21*R23 + R23*R21
      TRAND(6,2) = R22*R23 + R23*R22
      TRAND(1,3) = R31*R31
      TRAND(2,3) = R32*R32
      TRAND(3,3) = R33*R33
      TRAND(4,3) = R31*R32 + R32*R31
      TRAND(5,3) = R31*R33 + R33*R31
      TRAND(6,3) = R32*R33 + R33*R32
      TRAND(1,4) = R11*R21
      TRAND(2,4) = R12*R22
      TRAND(3,4) = R13*R23
      TRAND(4,4) = R11*R22 + R12*R21
      TRAND(5,4) = R11*R23 + R13*R21
      TRAND(6,4) = R12*R23 + R13*R22
      TRAND(1,5) = R11*R31
      TRAND(2,5) = R12*R32
      TRAND(3,5) = R13*R33
      TRAND(4,5) = R11*R32 + R12*R31
      TRAND(5,5) = R11*R33 + R13*R31
      TRAND(6,5) = R12*R33 + R13*R32
      TRAND(1,6) = R21*R31
      TRAND(2,6) = R22*R32
      TRAND(3,6) = R23*R33
      TRAND(4,6) = R21*R32 + R22*R31
      TRAND(5,6) = R21*R33 + R23*R31
      TRAND(6,6) = R22*R33 + R23*R32
      TRANF(1,1) = 1.0D0
      RETURN
      END
      SUBROUTINE ORBTRN(NDIM,NORB,BFLABE,ORBINP,R3D,ORBOUT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE(*),ATMPY,ATMPZ
      CHARACTER*12 ATMP
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION R3D(3,3),ORBINP(NDIM,NORB),ORBOUT(NDIM,NORB),TT(20)
      DIMENSION TRANP(3,3),TRAND(6,6),TRANF(10,10),NPTRAN(2,1000)
      DIMENSION ORBTMP(1000)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      CALL MOLTRAN(R3D,TRANP,TRAND,TRANF)
C     WRITE(IOUTVB,*)'TRANP'
C     WRITE(IOUTVB,*)(TRANP(1,I),I=1,3)
C     WRITE(IOUTVB,*)(TRANP(2,I),I=1,3)
C     WRITE(IOUTVB,*)(TRANP(3,I),I=1,3)
C
C     NPTRAN(2,n)
C
C     NPTRAN(1,n): the type of the n-th shell(1=S, 2=P, 3=D, 4=F)
C     NPTRAN(2,n): the starting point of the n-th shell
C
C     ASSUME BFLABE is de-captialized
C
C     SETUP MATRIX
C
      NP  = 0
      NPB = 0
  100 CONTINUE
C     DEFAULT: CARTESIAN ORBITALS
      ICART= 1
      ATMP = BFLABE(NPB+1)
C     WRITE(IOUTVB,*)'ATMP =',ATMP
C     WRITE(IOUTVB,*)'ATMP(11:12)=',ATMP(11:12)
      IF(ATMP(11:12).EQ.' s') THEN
      NP=NP+1
      NPTRAN(1,NP)=1
      NPTRAN(2,NP)=NPB+1
      NPB=NPB+1
      ELSE IF(ATMP(11:12).EQ.' x') THEN
      NP=NP+1
      NPTRAN(1,NP)=2
      NPTRAN(2,NP)=NPB+1
C
C     CHECK THE ORDER OF BF
C
      ATMPY=BFLABE(NPB+2)
      ATMPZ=BFLABE(NPB+3)
      NPB=NPB+3
        IF(ATMPY(11:12).NE.' y'.OR.ATMPZ(11:12).NE.' z') THEN
C       WRITE(IOUTVB,*)'ATMPY = ',ATMPY
C       WRITE(IOUTVB,*)'ATMPZ = ',ATMPZ
        CALL ABORT0('MOTRAN01  ')
        END IF
      ELSE IF(ATMP(10:12).EQ.' xx') THEN
C     CARTESIAN D ORBITALS
C     ATMPYY=BFLABE(NPB+2)
C     ATMPZZ=BFLABE(NPB+3)
C     ATMPXY=BFLABE(NPB+4)
C     ATMPXZ=BFLABE(NPB+5)
C     ATMPYZ=BFLABE(NPB+6)
      NP=NP+1
      NPTRAN(1,NP)=3
      NPTRAN(2,NP)=NPB+1
C     IF(ATMPYY(11:12).NE.'yy'.OR.ATMPZZ(11:12).NE.'zz'.OR.
C    &   ATMPXY(11:12).NE.'xy'.OR.ATMPXZ(11:12).NE.'xz'.OR.
C    &   ATMPYZ(11:12).NE.'yz') CALL ABORT0('MOTRAN02  ')
      NPB=NPB+6
      ELSE IF(ATMP(10:12).EQ.'d 0') THEN
      ICART=0
C
C     5-D
C
      NP=NP+1
      NPTRAN(1,NP)=3
      NPTRAN(2,NP)=NPB+1
      NPB=NPB+5
      ELSE IF(ATMP(9:12).EQ.' xxx') THEN
C
C     CARTESIAN F ORBITALS
C
      NP=NP+1
      NPTRAN(1,NP)=4
      NPTRAN(2,NP)=NPB+1
      NPB=NPB+10
C
C     F ORBITAL HAVE TO BE ZERO IN VBOLIB
C
      ELSE IF(ATMP(10:12).EQ.'f 0') THEN
      ICART=0
C
C     7-F
C
      NP=NP+1
      NPTRAN(1,NP)=4
      NPTRAN(2,NP)=NPB+1
      NPB=NPB+7
      ELSE IF(ATMP(9:12).EQ.'xxxx') THEN
      WRITE(IOUTVB,*)'G orbital found'
C
C     CARTESIAN G ORBITALS
C
      NP=NP+1
      NPTRAN(1,NP)=5
      NPTRAN(2,NP)=NPB+1
      NPB=NPB+15
C
C     G ORBITAL HAVE TO BE ZERO IN VBOLIB
C
      ELSE
      CALL ABORT0('MOTRAN04  ')
      END IF
      IF(NPB.LT.NDIM) GOTO 100
C120  CONTINUE
      DO 140 I=1, NORB
      DO 145 NBLK=1,NP
C     WRITE(IOUTVB,*)'NPTRAN =',NPTRAN(1,NBLK),NPTRAN(2,NBLK)
      NBB = NPTRAN(2,NBLK)
      IF(NPTRAN(1,NBLK).EQ.1) THEN
C     WRITE(IOUTVB,*)'S orbital is handled'
      ORBTMP(NBB) = ORBINP(NBB,I)
      ELSE IF(NPTRAN(1,NBLK).EQ.2) THEN
C     WRITE(IOUTVB,*)'P orbital is handled'
      CALL MATMUL2(3,3,1,TRANP,ORBINP(NBB,I),ORBTMP(NBB))
      ELSE IF (NPTRAN(1,NBLK).EQ.3.AND.ICART.EQ.1) THEN
C     WRITE(IOUTVB,*)'D orbital is handled'
      DO KKK=1,6
      TT(KKK) = ORBINP(NBB-1+KKK,I)
      END DO
C
C     DE-NORMALIZATION
C
C     FACTORX = 1.15475D0
      FACTORX = DSQRT(1.0D0/3.0D0)
      TT(4) = TT(4)/FACTORX
      TT(5) = TT(5)/FACTORX
      TT(6) = TT(6)/FACTORX
      CALL MATMUL2(6,6,1,TRAND,TT,ORBTMP(NBB))
C
C     RE-NORMALIZATION
C
      ORBTMP(NBB+3) = ORBTMP(NBB+3)*FACTORX
      ORBTMP(NBB+4) = ORBTMP(NBB+4)*FACTORX
      ORBTMP(NBB+5) = ORBTMP(NBB+5)*FACTORX
      ELSE IF (NPTRAN(1,NBLK).EQ.3.AND.ICART.EQ.0) THEN
        DO KKK=1,5
        ORBTMP(NBB-1+KKK) = ORBINP(NBB-1+KKK,I)
        IF(ABS(ORBTMP(NBB-1+KKK)).GT.1.0D6) CALL ABORT0('5DNOTDONE0')
        END DO
      ELSE IF (NPTRAN(1,NBLK).EQ.4.AND.ICART.EQ.1) THEN
C     WRITE(IOUTVB,*)'F orbital is handled'
        DO KKK=1,10
        ORBTMP(NBB-1+KKK) = 0.0D0
        END DO
      ELSE IF (NPTRAN(1,NBLK).EQ.4.AND.ICART.EQ.0) THEN
        DO KKK=1,7
        ORBTMP(NBB-1+KKK) = 0.0D0
        END DO
      ELSE IF (NPTRAN(1,NBLK).EQ.5.AND.ICART.EQ.1) THEN
C     WRITE(IOUTVB,*)'G orbital is handled'
        DO KKK=1,16
        ORBTMP(NBB-1+KKK) = 0.0D0
        END DO
      END IF
 145  CONTINUE
C
C     COPY FROM ORBTMP TO ORBOUT
C
      DO J=1, NDIM
      ORBOUT(J,I) = ORBTMP(J)
      END DO
 140  CONTINUE
      RETURN
      END
      SUBROUTINE IGUESS(BASIS,DM1NON,W,NGP,MSIZE,IOLVBO,NEXTRA)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Generate initial guess.
C     Note:
C
C     History:
C               First created in Feb. 1998.
C               Updated 1999-2000.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*8  VBOLAB(1000),BONDLAB
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
C     CHARACTER*80 VBPATH
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
     &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
     &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
      COMMON /LMODAT/VMO(500000),VLMO(500000),LMOLAB(2,1000),
     &LMOATM(5,1000),PGM(100000),ENGLMO(1000),BONDLAB(1000),MCLMO(5,80),
     &LHFLAG
      DIMENSION W(*),DM1NON(*),BASIS(*),EIG(5000)
      DIMENSION ISPLIT(5000),NGP(*),CNORM(5000),NBONDALIST(10,1000)
      DIMENSION NBONDTYPE(10,1000)
      NSSS=1
      NWK0=NSSS+NBASIS*(NBASIS+1)/2
      NWK1=NWK0+NBASIS*NBASIS
      NWK2=NWK1+NBASIS*NBASIS
      NWK3=NWK2+NBASIS*NBASIS
      NWK4=NWK3+NBASIS*NBASIS
      MSIZE1=MSIZE-NWK3-NBASIS*NBASIS+1
      IF(MSIZE1.LE.0) CALL ABORT0('IGUESS01  ')
      IF(NATOM*NBASIS.GT.500000) CALL ABORT0('IGUESS02  ')
      NLOCAL=(NELE+1)/2
C     LOCVIR=NBASIS-NLOCAL
C     NOBVIR=NBASIS*NLOCAL+1
C     NPMVIR=NATOM*NLOCAL+1
      DISCON=1.0D0
      NORBI=0
      DO I=1,NSUB
      NORBI=NORBI+MLORBIT(I)
      END DO
C
C     INITIALIZE MOL TOPOL
C
      CALL INIMOLTOPOL()
C
C     FIND NEIGHBOR ATOMS (BONDED)
C
      CALL FINDNB(NATOM,NATNUM,XYZ,NBONDALIST,NBONDTYPE)
C
C     GET IOUNITS BY NAMES
C
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL GETIOUNIT('IOHFORB ',IOHFORB)
      CALL GETIOUNIT('IOVBORB ',IOVBORB)
      CALL GETIOUNIT('IOTEMP  ',IOTEMP)
C
C     READ S and MO'S
C
      CALL READ1E(IAO1E,W(NSSS),W(NWK0),NBASIS)
      IF(IRESTART.LE.0) THEN
      CALL LOCTOR(IOENGI,'$LMODISTORTION',14,IOK,0)
      IF(IOK.EQ.0) CALL LOCTOR(IOENGI,'$DISCON',7,IOK,0)
      IF(IOK.NE.0) READ(IOENGI,*)DISCON
C     CALL RDMORB(IOHFORB,BASIS,EIG,NBASIS)
C
C     Pick one of two options:
C
C     LHYBRD = 1, USING ROY MCWEENY'S HYBRID METHOD
C     LHYBRD = 0, USING DLMO METHOD
C
      CALL RDMORB(IOHFORB,BASIS,EIG,NBASIS)
      DO K=1, NBASIS+NEXTRA
      VBOLAB(K) = '       '
      END DO
      IF(LHYBRD.EQ.0) THEN
C
C     COPY CANON LMOS FROM VLMO TO BASIS
C
      DO K=1, NBASIS*NLOCAL
      BASIS(K) = VLMO(K)
      END DO
      DO K=1, NLOCAL
      VBOLAB(K) = BONDLAB(K)
      END DO
C
C     BY SETTING IRESTART=-1, THE COMPUTATION STOPS AFTER LMO IS DONE.
C
      IF(IRESTART.LT.0) RETURN
C     CALL LMOTRN(NBASIS,BASIS,W(NWK0),NATOM,PGM,EIG,W(NWK1))
      CALL INIGDM(NBASIS,NSUB,MLORBIT,ISPLIT,NGP,NATOM)
      CALL DISLMO(NBASIS,NSUB,MLORBIT,ISPLIT,NGP,NATOM,
     &     NATBAS,BASIS,W(NWK0),PGM,DISCON,BONDLAB,VBOLAB)
C
C     SET UP INDEXES
C
      NCORE=0
      NBOALL=0
      DO I=1,NSUB
        DO J=1,MLORBIT(I)
        NBOALL=NBOALL+1
        NOCC(NBOALL)=1
          IF(METHOD(I).EQ.1) THEN
          NCORE=NCORE+1
          NOCC(NBOALL)=2
          END IF
        END DO
      END DO
C
C     GENERATE ARBITARY VECTORS FOR VIRTUAL ORBITALS
C
      DO I=NBOALL+1,NBASIS+NEXTRA
        DO J=1,NBASIS
        XXX = VBRAND(0)
        BASIS(NBASIS*(I-1)+J)=XXX
        END DO
      END DO
C
C     SPECIAL ROUTINE FOR GENERATING PI ORBITALS
C
      CALL PIVBO(NBASIS,BASIS,NB1ADD)
C
C     NEW VERSION OF PI ORBITAL GENERATOR USING FRAGMENT DATA
C
      CALL LPIVBO(BASIS,NB1ADD,IOLVBO,NBONDALIST,NSUB,
     &            VBOLAB)
C
C     NEW VERSION OF VBO GENERATOR USING VBO LIBRARY
C
C     CALL VBOLIB(NBASIS,BASIS,NB1ADD,IOLVBO,NBONDALIST,NSUB,BONDLAB,
C    &            LMOLAB,VBOLAB)
      CALL VBOLIB(BASIS,NB1ADD,IOLVBO,NSUB,VBOLAB)
      ELSE
      CALL GUESS2(NATOM, NATBAS, NBASIS, BASIS, W(NSSS),W(NWK0),NELE)
C
C     SET UP INDEXES
C
      NCORE=0
      NBOALL=0
      DO I=1,NSUB
        DO J=1,MLORBIT(I)
        NBOALL=NBOALL+1
        NOCC(NBOALL)=1
          IF(METHOD(I).EQ.1) THEN
          NCORE=NCORE+1
          NOCC(NBOALL)=2
          END IF
        END DO
      END DO
C
C     GENERATE ARBITARY VECTORS FOR VIRTUAL ORBITALS
C
      DO I=NBOALL+1,NBASIS+NEXTRA
        DO J=1,NBASIS
        XXX = VBRAND(0)
        BASIS(NBASIS*(I-1)+J)=XXX
        END DO
      END DO
C
      END IF
C
C     SPECIAL ROUTINE FOR READING IN APPROXIMATE INITIAL GUESS
C
      CALL RDGUES(NBASIS,BASIS,IOTEMP,IOENGI)
C
      CALL WTGUES(NBASIS,BASIS,NBOALL,IOTEMP,IOENGI)
      ELSE
      DO K=1, NBASIS+NEXTRA
      VBOLAB(K) = '       '
      END DO
      DO K=1, NLOCAL
      VBOLAB(K) = BONDLAB(K)
      END DO
C
C     READ ORBITALS AND 1D DENSITIES FROM PREVIOUS CALCULATION
C
      CALL RESTARD(IOVBORB,IOENGI,NATOM,NSUB,MLORBIT,METHOD,NBASIS,
     &             BASIS,DM1NON)
      END IF
C
C     post initial guess processes
C

C     ORBITAL FILTER: LOCALIZATION OF VB ORBITALS BY TRUNCATION
C
      CALL LOCVBO(NBASIS,BASIS,NATOM,NATBAS,IOENGI,W(NSSS),W(NWK0))
C
C     S-->W(NWK1)
C
        DO I=1,NBASIS
        II=(I-1)*NBASIS-1
        DO J=1,NBASIS
        IJ=II+J
        W(NWK1+IJ)=W(NSSS-1+IJ00(I,J))
        END DO
        END DO
C
C     COLLECT CORE ORBITALS
C     CORE-->W(NWK2)
C
C     SPECIAL HANDLING FOR SPHER HARMONIC. PROJECT OUT NON-SPHER HARMONIC
C     PART
C
C     First, we need find the subspace that contains only spher harmonic basis
C
C     Steps: 1) Find the vectors which are orthogonal to the spher harmonic
C               space.
C
      NSP=0
C     MSP=0
      MSUB = 1
      DO I=1,NSUB
        IF(MELE(I).EQ.0) THEN
          NSP=I
C         MSP=MLORBIT(I)
          MMSUB=MSUB
          METHOD(I) = 99
        END IF
        MSUB = MSUB + MLORBIT(I)*NBASIS
      END DO
      IF(NSP.EQ.0) GOTO 111
      CALL GETSPH(NBASIS,BFLABE,W(NWK1),W(NWK2),W(NWK3),W(NWK4),NNSP)
C     NSPH: DIMENSION OF ACTIVE SPACE
      NSPH = NBASIS - NNSP
      DO J=1, NBASIS*NNSP
         BASIS(MMSUB-1+J) = W(NWK3-1+J)
      END DO
      IISUB = 1
      DO I=1, NSUB
         IF(I.NE.NSP) THEN
            CALL PROJEC(NBASIS,MLORBIT(I),NSPH,W(NWK1),BASIS(IISUB),
     &                  W(NWK2),W(NWK3),W(NWK4))
         END IF
         IISUB = IISUB + MLORBIT(I)*NBASIS
      END DO
      CALL PROJEC(NBASIS,NSPH,NSPH,W(NWK1),BASIS(IISUB),
     &                  W(NWK2),W(NWK3),W(NWK4))
 111  CONTINUE
      NCORE=0
      NT=0
      DO I=1,NBASIS
      II=(I-1)*NBASIS
      IF(IBASIS(I).GT.0) THEN
      IF(METHOD(IBASIS(I)).EQ.1) THEN
C     THIS IS A CORE ORBITAL
      NCORE=NCORE+1
         DO J=1,NBASIS
         W(NWK2+NT)=BASIS(II+J)
         NT=NT+1
         END DO
      END IF
      END IF
      END DO
C
C     ORTHOGONAL TO CORE ORBITALS
C
      CALL ORTHAB(NBASIS,NCORE,NBASIS+NEXTRA,W(NWK1),W(NWK2),BASIS,
     &            W(NWK3))
C
C
C     RETURN CORE ORBITALS BACK TO BASIS
C
      NT=0
      DO I=1,NBASIS+NEXTRA
      II=(I-1)*NBASIS
      IF(IBASIS(I).GT.0.AND.METHOD(IBASIS(I)).EQ.1) THEN
C     THIS IS A CORE ORBITAL, MODIFIED IN BASIS. RESET TO ORIGINAL
         DO J=1,NBASIS
         BASIS(II+J)=W(NWK2+NT)
         NT=NT+1
         END DO
      END IF
      END DO
C
C     FIND THE NUMBERS OF LINEAR INDEPENDENT ORBITALS OF ALL GROUPS
C     SET MNORBIT(I), NVIR
C
C     THE LINEAR INDEPENDENT ORBITALS ARE STORED IN W(NWK0)
C
      CALL SETNORB(NBASIS,NSUB,MLORBIT,MNORBIT,BASIS,W(NWK1),W(NWK0),
     &                                               W(NWK2))
      NX = 0
      NL = 0
      DO I=1, NSUB
      IF(MELE(I).EQ.0) MNORBIT(I) = MLORBIT(I)
      NX = NX + MNORBIT(I)
      NL = NL + MLORBIT(I)
      END DO
      NVIR = NBASIS - NX
      MBASIS = NL + NVIR
      DO I=1, NSUB
        IF(METHOD(I).EQ.1) THEN
        MWIN(I) = MLORBIT(I) + NVIR
        END IF
      END DO
C
C     COPY REMAINING VECTRORS BASIS->W(NWK0)
C
      DO I=1, NVIR
        MMM1= NWK0-1 + (NX+I-1)*NBASIS
        MMM2= (NL+I-1)*NBASIS
        DO J=1, NBASIS
        W(MMM1+J) = BASIS(MMM2+J)
        END DO
      END DO
C
C     LOWDIN ORTHOGONALIZATION OF SUBUNITS
C
      CALL INIBAS(NBASIS,NSUB,MLORBIT,MNORBIT,METHOD,NBASIS,BASIS,
     &             W(NSSS),W(NWK0),W(NWK1),CNORM)
C
C     INITIALIZE LOCAL ONE-DIMENSIONAL DENSITY MATRIX DM1NON
C     IN NONORTHOGONAL BASIS
C
      IF(IRESTART.LE.0)
     &CALL ININDM(NSUB,MELE,MLORBIT,DM1NON)
C
C     PRINT INITIAL ORBITALS
C
      IF(LPTALL.EQ.1) CALL MPRINT(BASIS,W,NBASIS,NORBI,3,BFLABE,VBOLAB)
      RETURN
      END
      SUBROUTINE RESTARD(IOVBORB,IOENGI,NATOM,NSUB,MLORBIT,METHOD,
     &                   NBASIS,BASIS,DM1NON)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABEX(1000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION BASIS(*),DM1NON(*),MLORBIT(*),METHOD(*),MAPHF(100)
      DIMENSION MAPGRP(100),NORBST(100),NORBSTX(100),N1DADD(100)
      DIMENSION N1DADDX(100),MELEX(100)
      DIMENSION BASISX(500000),DM1NONX(100000),MLORBITX(99),METHODX(99)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
C     BONDARY CHECK
C
      IF(NBASIS.GT.700) CALL ABORT0('RESTARD00 ')
      REWIND(IOVBORB)
      READ(IOVBORB)NSUBX,NDM1X,(MELEX(I),I=1,NSUBX),
     &              (MLORBITX(I),I=1,NSUBX),(METHODX(I),I=1,NSUBX)
      READ(IOVBORB)NBASISX,NATOMX,NORBX,(BFLABEX(I),I=1,NBASISX)
      READ(IOVBORB)(BASISX(I),I=1,NBASISX*NORBX)
      READ(IOVBORB)(DM1NONX(I),I=1,NDM1X)
      IF(NATOM.GT.10000000) WRITE(IOUTVB,*)MELEX(1),BFLABEX(1)
C
C     ERROR CHECK
C
      IF(NATOMX.NE.NATOM.OR.NBASIS.NE.NBASISX) THEN
         WRITE(IOUTVB,*)"THE RESTART FILE DOES NOT MATCH THE CURRENT "
         WRITE(IOUTVB,*)"CALCULATION"
         CALL ABORT0('RESTARD01 ')
      END IF
C
C     BUILD INDEXES OF GROUP ORBITALS
C
      NORBSTX(1) = 1
      N1DADDX(1) = 1
      DO I=2, NSUBX+1
      NORBSTX(I) = NORBSTX(I-1) + MLORBITX(I-1)
      N1DADDX(I) = N1DADDX(I-1) + MLORBITX(I-1)*(MLORBITX(I-1)+1)/2
      END DO
      NORBST(1) = 1
      N1DADD(1) = 1
      DO I=2, NSUB+1
      NORBST(I) = NORBST(I-1) + MLORBIT(I-1)
      N1DADD(I) = N1DADD(I-1) + MLORBIT(I-1)*(MLORBIT(I-1)+1)/2
      END DO
      DO I=1, N1DADD(NSUB+1) - 1
      DM1NON(I) = 0.0D0
      END DO
C
C     COMPARE NSUB, MLORBIT AND METHOD. IF ALL MATCH, JUST COPY DATA AND
C     RETURN, ELSE, SEARCH FOR $RESTARTMAPPING
C
      CALL RESTACOMP(NSUB,MLORBIT,METHOD,NSUBX,MLORBITX,METHODX,IEQ)
      DO I=1, NBASIS*NORBX
      BASIS(I) = BASISX(I)
      END DO
      DO I=1, NDM1X
      DM1NON(I) = DM1NONX(I)
      END DO
      IF(IEQ.EQ.1) THEN
        RETURN
      ELSE
C
C     SEARCH FOR MAPPING
C
      CALL LOCTOR(IOENGI,'$RESTARTMAPPING',15,IOK,0)
      WRITE(IOUTVB,*)'SEARCH FOR RESTARTMAPPING'
      IF(IOK.NE.1) THEN
         WRITE(IOUTVB,*)"A RESTART MAPPING FILE IS NEEDED"
         WRITE(IOUTVB,*)"IT CAN BE A INPUT ERROR"
         CALL ABORT0('RESTARD02 ')
      END IF
      NMAPHF = 0
        IF(METHODX(1).EQ.1) NMAPHF = MLORBITX(1)
        DO I=1, NMAPHF
        MAPHF(I) = 1
        END DO
        DO I=1, NSUBX
        MAPGRP(I) = I
        END DO
        IF(NMAPHF.GT.0) READ(IOENGI,*)(MAPHF(I),I=1,NMAPHF)
        READ(IOENGI,*)(MAPGRP(I),I=1,NSUBX)
C
C     NOW, COLLECT ORBITALS FOR EACH GROUP, AND BUILD LOCAL 1D DENSITY
C
      NORBT = 0
        DO I=1, NSUB
        NORB = 0
        NADD = N1DADD(I) - 1
C
C     COLLECT HF ORBITALS FIRST
C
           DO J=1, NMAPHF
           JJ = (J-1)*NBASIS
           IF(MAPHF(J).EQ.I) THEN
             NORB  = NORB + 1
             NORBT = NORBT + 1
             NNORBT = (NORBT-1)*NBASIS
             DO K=1, NBASIS
             BASIS(NNORBT+K) = BASISX(JJ+K)
             END DO
           NORB2 = NORB*(NORB+1)/2
           DM1NON(NADD + NORB2) = 2.0D0
           END IF
           END DO
           DO J=1, NSUBX
           NORBP = NORB
           JORBST = NORBSTX(J) - 1
           NADDJ  = N1DADDX(J) - 1
           IF(METHODX(J).NE.1.AND.MAPGRP(J).EQ.I) THEN
              DO K=1, MLORBITX(J)
              JJ = (JORBST+K-1)*NBASIS
              NORB  = NORB + 1
              NORBT = NORBT + 1
              NNORBT = (NORBT-1)*NBASIS
                DO L=1, NBASIS
                BASIS(NNORBT+L) = BASISX(JJ+L)
                END DO
              END DO
C
C             COPY D1
C
              DO K=1, MLORBITX(J)
              DO L=1, K
              KL = K*(K-1)/2 + L
              KK = NORBP + K
              LL = NORBP + L
              KL2 = KK*(KK-1)/2 + LL
              DM1NON(NADD+KL2) = DM1NONX(NADDJ+KL)
              END DO
              END DO
           END IF
           END DO
C
C       CHECK THE NUMBER OF ORBITALS COLLECT, AND DO ERROR CHECK
C
        IF(NORB.NE.MLORBIT(I)) CALL ABORT0('RESTARD03 ')
        END DO
      END IF
      RETURN
      END
      SUBROUTINE RESTACOMP(NSUB,MLORBIT,METHOD,NSUBX,MLORBITX,METHODX,
     &                     IEQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION MLORBIT(*),MLORBITX(*),METHOD(*),METHODX(*)
      IEQ = 0
      IF(NSUB.NE.NSUBX) RETURN
      DO I=1, NSUB
      IF(MLORBITX(I).NE.MLORBIT(I).OR.
     &     (METHOD(I).EQ.1.AND.METHODX(I).GT.1).OR.
     &     (METHOD(I).GT.1.AND.METHODX(I).EQ.1)) RETURN
      END DO
      IEQ = 1
      RETURN
      END
      SUBROUTINE FINDNB(NATOM,NATNUM,XYZ,NBONDALIST,NBONDTYPE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NATNUM(*),XYZ(3,*),NBONDALIST(10,*),ARADII(110)
      DIMENSION NBONDTYPE(10,*),CARADII(3,110)
      DATA ARADII/0.3D0,1.5D0,1.0D0,1.06D0,0.88D0,0.77D0,0.70D0,
     &            0.66D0,0.64D0,1.50D0,1.0D0,1.40D0,1.26D0,1.17D0,
     &            1.10D0,1.04D0,0.99D0,93*1.20D0/
      DATA CARADII/330*0.0D0/
C
C     The values are from Pauling's book of 'The Nature of The Chemical Bond'
C     Table 7-2 (P224) and Table 7-5 (p228), 1970 Eds.
C
C     H
      CARADII(1,1) = 0.30D0
C     B
      CARADII(1,5) = 0.81D0
      CARADII(2,5) = 0.71D0
      CARADII(3,5) = 0.64D0
C     C
      CARADII(1,6) = 0.772D0
      CARADII(2,6) = 0.667D0
      CARADII(3,6) = 0.603D0
C     N
      CARADII(1,7) = 0.74D0
      CARADII(2,7) = 0.62D0
      CARADII(3,7) = 0.55D0
C     O
      CARADII(1,8) = 0.74D0
      CARADII(2,8) = 0.62D0
      CARADII(3,8) = 0.55D0
C     F
      CARADII(1,9) = 0.72D0
      CARADII(2,9) = 0.60D0
C     Si
      CARADII(1,14) = 1.17D0
      CARADII(2,14) = 1.07D0
      CARADII(3,14) = 1.00D0
C     P
      CARADII(1,15) = 1.10D0
      CARADII(2,15) = 1.00D0
      CARADII(3,15) = 0.93D0
C     S
      CARADII(1,16) = 1.04D0
      CARADII(2,16) = 0.94D0
      CARADII(3,16) = 0.87D0
C     Cl
      CARADII(1,17) = 0.99D0
      CARADII(1,17) = 0.89D0
C     WRITE(IOUTVB,*)'FINDNB, NATOM = ',NATOM
      DO I=1, NATOM
      NBONDA=0
        DO J=1,NATOM
        DIJ = DSQRT((XYZ(1,I)-XYZ(1,J))**2+(XYZ(2,I)-XYZ(2,J))**2+
     &             (XYZ(3,I)-XYZ(3,J))**2)
        DIJT = (ARADII(NATNUM(I))+ARADII(NATNUM(J)))*1.30D0
        IF(DIJ.LE.DIJT.AND.I.NE.J) THEN
        NBONDA = NBONDA+1
        NBONDALIST(NBONDA+1,I) = J
        NATI = NATNUM(I)
        NATJ = NATNUM(J)
        CALL FINDBOD(NATI,NATJ,CARADII(1,NATI),CARADII(1,NATJ),DIJ,NBOD)
        NBONDTYPE(NBONDA+1,I) = NBOD
        END IF
        END DO
      NBONDALIST(1,I) = NBONDA
C     WRITE(IOUTVB,*)'NEIB =',NBONDA
C     WRITE(IOUTVB,*)'NEIB OF I=',I,(NBONDALIST(J+1,I),J=1,NBONDALIST(1,I))
      END DO
      RETURN
      END
C
C     FIND BOND ORDER BY DISTANCE
C
      SUBROUTINE FINDBOD(NA1,NA2,CR1,CR2,D12,NBOD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION CR1(3),CR2(3),R12(3)
      CALL FINDSTDL(NA1,NA2,CR1,CR2,R12)
C
C     DEFAULT: UNKNOWN BOND ORDER
C
      NBOD = 0
      IF(R12(1).EQ.0.0D0) RETURN
C
      IF(D12.GT.R12(1)) THEN
      NBOD = 1
      RETURN
      END IF
      IF(D12.LT.R12(3)) THEN
      NBOD = 3
      RETURN
      END IF
C
C     FIND THE BEST MATCH
C
      RERR = DABS(D12-R12(1))/D12
      NBOD = 1
      RTMP = DABS(D12-R12(2))/D12
      IF(RTMP.LT.RERR) THEN
        RERR = RTMP
        NBOD = 2
      END IF
      RTMP = DABS(D12-R12(3))/D12
      IF(RTMP.LT.RERR) THEN
        RERR = RTMP
        NBOD = 3
      END IF
C
C     SPECIAL CASE; AROMATIC BOND OF CC = 1.40
C
      IF(NA1.EQ.6.AND.NA2.EQ.6.AND.ABS(D12-1.40D0).LT.0.01D0) NBOD = 4
      RETURN
      END
      SUBROUTINE FINDSTDL(NA1,NA2,CR1,CR2,R12)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION CR1(3),CR2(3),R12(3)
      DO I=1,3
      R12(I) = 0.0D0
      IF(CR1(I).GT.0.0D0.AND.CR2(I).GT.0.0D0) R12(I) = CR1(I) + CR2(I)
      END DO
C
C     C-N = 1.47, C#N = 1.155
C
      IF(NA1.EQ.6.AND.NA2.EQ.7) THEN
      R12(1) = 1.47D0
      R12(3) = 1.155D0
      END IF
      IF(NA1.EQ.7.AND.NA2.EQ.6) THEN
      R12(1) = 1.47D0
      R12(3) = 1.155D0
      END IF
C
C     C-O = 1.43, C=O = 1.23, CO = 1.13
C
      IF(NA1.EQ.6.AND.NA2.EQ.8) THEN
      R12(1) = 1.43D0
      R12(2) = 1.23D0
      R12(2) = 1.13D0
      END IF
      IF(NA1.EQ.8.AND.NA2.EQ.6) THEN
      R12(1) = 1.43D0
      R12(2) = 1.23D0
      R12(2) = 1.13D0
      END IF
      RETURN
      END
C
C     ORBITAL FILTER: LOCALIZATION OF VB ORBITALS BY TRUNCATION
C
      SUBROUTINE LOCVBO(NBASIS,BASIS,NATOM,NATBAS,IOENGI,S,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION BASIS(NBASIS,*),NATBAS(*),NABAS(10000),NKATM(10)
      DIMENSION S(*),W(*),MAPVBO(20),MAPATM(1000),LATOM(20)
      NT = 0
      DO 1 I=1,NATOM
      DO 2 J=1,NATBAS(I)
      NT=NT+1
      IF (NT.GT.10000) CALL ABORT0('LOCVBO01  ')
      NABAS(NT)=I
  2   CONTINUE
  1   CONTINUE
      DO I=1, NBASIS
      MAPATM(I) = 0
      END DO
      CALL LOCTOR(IOENGI,'$LOCVBO',7,IOK,0)
      IF(IOK.EQ.0) RETURN
      READ(IOENGI,*)MODIFY
      DO I=1, MODIFY
      READ(IOENGI,*)IDXVBO,NKEEPATM,(NKATM(J),J=1,NKEEPATM)
      MAPATM(IDXVBO) = NKATM(1)
      CALL VBOTRK(NBASIS,BASIS(1,IDXVBO),NKEEPATM,NKATM,NABAS)
      END DO
C
C     OPTIONALLY CALL LOWDIN ORTHOGONALIZATION ON ATOMS SPECIFIED
C
      CALL LOCTOR(IOENGI,'$NOATMLWD',9,IOK,0)
      IF(IOK.EQ.1) RETURN
      LATOMS = NATOM
      DO I=1, NATOM
      LATOM(I) = I
      END DO
C
C
      DO NA = 1, LATOMS
      NATM = LATOM(NA)
      NAOS = 0
        DO K=1, NBASIS
        IF(MAPATM(K).EQ.NATM) THEN
        NAOS = NAOS + 1
        MAPVBO(NAOS) = K
        NAOSB = (NAOS-1)*NBASIS
        KK = (K-1)*NBASIS
          DO J=1, NBASIS
          W(J+NAOSB) = BASIS(J,K)
          END DO
        END IF
        END DO
C
      NATV = 1
      NSS= NATV + NBASIS*NBASIS
      NSA=NSS+NBASIS*NBASIS
      NV =NSA+NBASIS*NBASIS
      NW =NV +NBASIS*NBASIS
C     NWK=NW +NBASIS*NBASIS
C
C     S->W(NSS)
C
      DO 200 I=1,NBASIS
      II=NSS-1+(I-1)*NBASIS
      DO 200 J=1,NBASIS
      W(II+J)=S(IJ00(I,J))
 200  CONTINUE
C
C     Lowdin orthogonalization of all VBOs on the atom
C
      CALL LOWD(NBASIS,NAOS,W(NSS),W,W(NSA),W(NV),W(NW),IERR)
      IF(IERR.EQ.1) CALL ABORT0('LOCVBO01  ')
C
C     COPY W TO BASIS
C
        DO K=1, NAOS
        KK = NV-1+(K-1)*NBASIS
        NAOSB = (MAPVBO(K)-1)*NBASIS
          DO J=1, NBASIS
          BASIS(J,MAPVBO(K)) = W(KK+J)
          END DO
        END DO
      END DO
      RETURN
      END
      SUBROUTINE VBOTRK(NBASIS,V,NKATMS,NATMS,NABAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION V(*),NATMS(*),NABAS(*)
      DO I=1, NBASIS
      IATM  = NABAS(I)
      KPATM = 0
         DO J=1,NKATMS
         IF(NATMS(J).EQ.IATM) KPATM=1
         END DO
      IF(KPATM.NE.1) V(I) = 0.0D0
      END DO
      END
      SUBROUTINE COMBIN(N,M,NB,NM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NB(M+1,*),ITEMP(100)
      NM=0
      IF(M.LT.N) RETURN
      NM=1
      NB(M+1,1)=M
      DO I=1,N
      KNM=NM
      DO K=1,NM
      NLASTP=NB(M+1,K)
      NILAST=NLASTP-N+I
      DO J=I+1,NILAST
      KNM=KNM+1
        DO L=1,M
        ITEMP(L) =NB(L,K)
        END DO
        DO L=I,J-1
        ITEMP(M+L-I+1) =NB(L,K)
        END DO
        NSHIFT=J-I
        DO L=J,M+NSHIFT
        ITEMP(L-NSHIFT) =ITEMP(L)
        END DO
        ITEMP(M+1) =NB(M+1,K)-NSHIFT
        DO JJ=1,M+1
        NB(JJ,KNM) = ITEMP(JJ)
        END DO
      END DO
      END DO
      NM=KNM
      END DO
      RETURN
      END
      SUBROUTINE SETCASVB(MELE,MSPIN,NSTR,NPHI,MORB,MGRP,LPRT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPHI(*),NA(20000),NB(20000),NC(20000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
C     CHARACTER*50 FLAG
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DO I=1,MORB
      NA(I)=I
      NB(I)=I
      NC(I)=I
      END DO
C
C     SET DEFAULT VALUES
C
      NSTR=0
      IF(MELE.GT.MORB*2) RETURN
C     MOBMIM=(MELE-MSPIN)/2+MSPIN
C     MOBMAX=MELE
      NDMAX=(MELE-MSPIN)/2
      NDMIN=MELE-MORB
      IF(NDMIN.LT.0) NDMIN=0
      DO ND=NDMIN,NDMAX
      NRE=MELE-ND*2
      MND=MORB-ND
      CALL COMBIN(ND,MORB,NA,NM1)
      CALL COMBIN(NRE,MND,NB,NM2)
      CALL RUMERVB(NRE,MSPIN,NC,20000,NM3)
      CALL GENSTR(MELE,NPHI,MORB,MND,NRE,ND,NA,NB,NC,NM1,NM2,NM3,NSTR)
C     WRITE(IOUTVB,*)'NSTR=',NSTR
      END DO
      IF(LPRT.EQ.1) THEN
      WRITE(IOUTVB,1300)MGRP
      DO 110 I=1,NSTR
      I1=(I-1)*MELE
 110  WRITE(IOUTVB,1400)I,(NPHI(I1+J),J=1,MELE)
      WRITE(IOUTVB,*)
CGMS  CALL FLSHBF(IOUTVB)
      END IF
 1300 FORMAT(/1X,'SYMBOLIC VB STRUCTURE(S) OF GROUP',I3,/
     1       1X,'STR. NO.       RUMER PATTERN  ')
 1400 FORMAT(1X,I5,'      ',20(I4,I3))
      RETURN
      END
      SUBROUTINE GENSTR(MELE,NPHI,M,MND,NRE,ND,NA,NB,NC,M1,M2,M3,NSTR)
      DIMENSION NPHI(MELE,*),NA(M+1,*),NB(MND+1,*),NC(NRE,*)
      DIMENSION NW1(1000),NW2(1000)
      DO I=1,M1
        DO L=1,MND
        NW1(L)=NA(ND+L,I)
        END DO
      DO J=1,M2
        DO L=1,NRE
        NW2(L)=NW1(NB(L,J))
        END DO
      DO K=1,M3
      NSTR=NSTR+1
      IF(NSTR*MELE.GT.200000) CALL ABORT0("TOOMANYVB!")
        DO L=1,ND
        NPHI(L+L-1,NSTR)=NA(L,I)
        NPHI(L+L  ,NSTR)=NA(L,I)
        END DO
        DO L=1,NRE
        NPHI(ND*2+L,NSTR)=NW2(NC(L,K))
        END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE SETSCVB(MELE,MSPIN,NSTR,NPHI,NOB,EPS,MAXIT,
     &                 NEWTON,NOPT,MLORBIT,MGRP,FLAG,LPRT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPHI(*),NA(20000),NB(20000),NC(20000),NOB(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*50 FLAG
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      CALL GETIOUNIT('IOENGI  ',IOENGI)
C
C     SET DEFAULT VALUES
C
      NOPT=MLORBIT
      DO I=1,MLORBIT
      NOB(I)=I
      END DO
      NEWTON=1
      EPS   =1.0D-4
      MAXIT =15
C100  CONTINUE
      DO I=1,MLORBIT
      NA(I)=I
      NB(I)=I
      NC(I)=I
      END DO
C
C     SET DEFAULT VALUES
C
      NSTR=0
      IF(MELE.GT.MLORBIT*2) RETURN
C     MOBMIM=(MELE-MSPIN)/2+MSPIN
C     MOBMAX=MELE
C     NDMAX=(MELE-MSPIN)/2
      NDMIN=MELE-MLORBIT
      IF(NDMIN.LT.0) NDMIN=0
      ND = NDMIN
      NRE=MELE-ND*2
      MND=MLORBIT-ND
      CALL COMBIN(ND,MLORBIT,NA,NM1)
      CALL COMBIN(NRE,MND,NB,NM2)
      CALL RUMERVB(NRE,MSPIN,NC,20000,NM3)
      CALL GENSTR(MELE,NPHI,MLORBIT,MND,NRE,ND,NA,NB,NC,NM1,
     &                                         NM2,NM3,NSTR)
C200  CONTINUE
      IF(LPRT.EQ.1) THEN
      WRITE(IOUTVB,1300)MGRP
      DO 110 I=1,NSTR
      I1=(I-1)*MELE
 110  WRITE(IOUTVB,1400)I,(NPHI(I1+J),J=1,MELE)
      WRITE(IOUTVB,*)
CGMS  CALL FLSHBF(IOUTVB)
      END IF
C
C     READ SCF CONTROL
C
      CALL LOCTOR(IOENGI,'$VBSCF',6,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*)EPS,MAXIT
      END IF
      FLAG(4:10)='SCVBSCF'
      CALL LOCTOR(IOENGI,FLAG,10,IOK,0)
      IF(IOK.EQ.1) THEN
       READ(IOENGI,*)EPS,MAXIT
      ELSE
       CALL LOCTOR(IOENGI,'$SCVBSCF',8,IOK,0)
       IF(IOK.EQ.1) THEN
       READ(IOENGI,*)EPS,MAXIT
       END IF
      END IF
 1300 FORMAT(/1X,'SYMBOLIC VB STRUCTURE(S) OF GROUP',I3,/
     1       1X,'STR. NO.       RUMER PATTERN  ')
 1400 FORMAT(1X,I4,'        ',15(I4,I3))
      RETURN
      END
      SUBROUTINE RUMERVB(N,NS,NTAB,NW,NRUM)
      DIMENSION NTAB(N,*),NTAB0(100)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      NRUM=1
      IF(N.LE.0) RETURN
      DO I=1,N
      NTAB0(I)=NTAB(I,1)
      END DO
      NWN=NW/N
      DO I=1,NWN
      DO J=1,N
      NTAB(J,I)=0
      END DO
      END DO
      NTAB(1,1)=1
      NH=(N+NS)/2
      DO 100 I=2,N
      NRUMER=NRUM
      DO 110 J=1,NRUM
C
C     CHECK NALPHA,NBETA
C
      NA=0
      NB=0
      DO 120 K=1,NH-NS
      IF(NTAB(K+K-1,J).NE.0) NA=NA+1
      IF(NTAB(K+K,J).NE.0) NB=NB+1
  120 CONTINUE
      DO 125 K=N-NS+1,N
      IF(NTAB(K,J).NE.0) NA=NA+1
  125 CONTINUE
      IF(NA.EQ.NB) THEN
      NTAB(I,J)=I
      ELSE
        IF(NA.GE.NH) THEN
        NTAB(NB+NB+2,J)=I
        ELSE IF(NB.GE.NH-NS) THEN
        NTAB(I,J)=I
        ELSE
        NRUMER=NRUMER+1
        IF(NRUMER.GT.NWN) THEN
        WRITE(IOUTVB,*)'TOO MANY RUMER PATTERNS, STOP'
        CALL ABRTVB
        END IF
        DO 130 L=1,N
  130   NTAB(L,NRUMER)=NTAB(L,J)
        NTAB(NB+NB+2,J)=I
          IF(NA.GE.NH-NS) THEN
          NTAB(NA+NH-NS+1,NRUMER)=I
          ELSE
          NTAB(NA+NA+1,NRUMER)=I
          END IF
        END IF
      END IF
  110 CONTINUE
      NRUM=NRUMER
  100 CONTINUE
      DO 150 I=1,NRUM
      DO 150 J=1,N
  150 NTAB(J,I)=NTAB0(NTAB(J,I))
      RETURN
      END
      SUBROUTINE SETVB(MELE,NSTR,NPHI,NOB,EPS,MAXIT,
     &                 NEWTON,NOPT,MLORBIT,MITER,MGRP,FLAG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPHI(*),NOB(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      CHARACTER*50 FLAG
      CALL GETIOUNIT('IOENGI  ',IOENGI)
C
C     SET DEFAULT VALUES
C
      NSTR=1
      NDB=0
      IF(MELE.GT.MLORBIT) THEN
      NDB=MELE-MLORBIT
         DO I=1,NDB
         NPHI(I+I-1)=I
         NPHI(I+I)  =I
         END DO
      END IF
      NDD=NDB*2
      DO I=NDD+1,MELE
      NPHI(I)=I-NDB
      END DO
      NOPT=MLORBIT
      DO I=1,MLORBIT
      NOB(I)=I
      END DO
      NEWTON=1
      EPS   =1.0D-3
      MAXIT =15
      FLAG(4:8)='VBSTR'
C
C     READ PARAMETERS OF VB STRUCTURES
C
      CALL LOCTOR(IOENGI,FLAG,8,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*,ERR=101) NSTR
C
C     READ VB STRUCTURES
C
      DO 100 I=1,NSTR
      I1=(I-1)*MELE
 100  READ(IOENGI,*,ERR=101,END=101)(NPHI(I1+J),J=1,MELE)
      END IF
      GOTO 102
 101  WRITE(IOUTVB,*)"INPUT ERROR IN VBSTR"
      CALL ABORT0("SETVB00001")
 102  CONTINUE
      IF(MITER.EQ.1) THEN
      WRITE(IOUTVB,1300)MGRP
      DO 110 I=1,NSTR
      I1=(I-1)*MELE
 110  WRITE(IOUTVB,1400)I,(NPHI(I1+J),J=1,MELE)
      WRITE(IOUTVB,*)
CGMS  CALL FLSHBF(IOUTVB)
      END IF
C
C     READ VBSCF
C
      FLAG(4:8)='VBSCF'
      CALL LOCTOR(IOENGI,FLAG,8,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*)EPS,MAXIT
      IF (MITER.EQ.1) WRITE(IOUTVB,1500) FLAG(1:8),EPS,MAXIT
      ELSE
      CALL LOCTOR(IOENGI,'$VBSCF',6,IOK,0)
       IF(IOK.EQ.1) THEN
       READ(IOENGI,*)EPS,MAXIT
       IF (MITER.EQ.1) WRITE(IOUTVB,1501) EPS,MAXIT
       END IF
      END IF
 1300 FORMAT(/1X,'SYMBOLIC VB STRUCTURE(S) OF GROUP',I3,/
     1       1X,'STR. NO.       RUMER PATTERN  ')
 1400 FORMAT(1X,I4,'        ',15(I4,I3))
 1500 FORMAT(A8," VALUES ARE EPS =",F11.8," AND MAXIT =",I3)
 1501 FORMAT("$VBSCF VALUES ARE EPS =",F11.8," AND MAXIT =",I3)
      RETURN
      END
      SUBROUTINE READ1E(IAO1E,S,H,NBASIS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION S(*),H(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE,FILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
     &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
     &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
      NBA2=NBASIS*(NBASIS+1)/2
C
C     THIS IS THE FIRST ENTRY FOR 1E INTEGRAL ROUTINES
C     THERE ARE THREE OPTIONS:
C
C     1  GAUSSIAN
C     2  GAMESS
C     3  DEFAULT
C
      GO TO (1,2,3,4),ICON
C     CASE 1: GAUSSIAN
  1   CONTINUE
CGAU  CALL RGAU1E(S,H,NBASIS)
      GOTO 10
C     CASE 2: GAMESS
  2   CONTINUE
CGMS  CALL RGMS1E(S,H,NBASIS)
      GOTO 10
C     CASE 3: DEFAULT
  3   FILE=FSTR(1:LENFIL)//'.'//FUNIT(1)
      OPEN(UNIT=IAO1E,FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      REWIND(IAO1E)
      READ(IAO1E)NBA2
      READ(IAO1E)(S(I),I=1,NBA2)
      READ(IAO1E)(H(I),I=1,NBA2)
      CLOSE(IAO1E)
      GOTO 10
  4   CONTINUE
      WRITE(IOUTVB,*)"RSMI1E"
CSMI  CALL RSMI1E(S,H,NBASIS)
 10   CONTINUE
C     DEBUG - Write out S and H
C     WRITE(IOUTVB,13)
C13   FORMAT(/,' S MATRIX'/)
C     WRITE(IOUTVB,11) (S(I),I=1,NBA2)
C     WRITE(IOUTVB,14)
C14   FORMAT(/,' H MATRIX'/)
C     WRITE(IOUTVB,11) (H(I),I=1,NBA2)
C11   FORMAT(5F12.6)
C
C     CALL FOR POSSIBLE CORRECTION WITH SCRF
C
CGMS  ISOL=0
CGMS  CALL ADDRF(H,NBASIS,ISOL)
C
      RETURN
      END
      SUBROUTINE RHND1E(IAO1E,S,H)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION S(*),H(*)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE,FILE
      CHARACTER*3 FUNIT(10)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(1)
      OPEN(UNIT=IAO1E,FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      REWIND(IAO1E)
      READ(IAO1E)MSQ
      READ(IAO1E)(S(I),I=1,MSQ)
      READ(IAO1E)(H(I),I=1,MSQ)
      CLOSE(IAO1E)
      RETURN
      END
C
      SUBROUTINE READ2E(IAO2E,G)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION G(*)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
     &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
     &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
C     CHARACTER*3 FUNIT(10)
C     CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
C     COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
C     THIS IS THE FIRST ENTRY FOR 2E INTEGRAL ROUTINES
C     THERE ARE THREE OPTIONS:
C
C     1  GAUSSIAN
C     2  GAMESS
C     3  DEFAULT
C     4  SMILES
C
      GO TO (1,2,3,4),ICON
C     CASE 1: GAUSSIAN
  1   CONTINUE
CGAU  CALL RGAU2E(G)
      RETURN
C     CASE 2: GAMESS
  2   CONTINUE
CGMS  CALL RGMS2E(G)
      RETURN
C     CASE 3: DEFAULT
  3   CONTINUE
C000  CALL RD2E00(IAO2E,G)
C     CASE 4: SMILES
  4   CONTINUE
CSMI  CALL RSMI2E(G)
      IF(IAO2E.GT.1000000) WRITE(*,*)IAO2E
      RETURN
      END
      SUBROUTINE IJKLGG(IAO2E,GG,II,JJ,KK,LL,NINT)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION GG(*),II(*),JJ(*),KK(*),LL(*)
C     CHARACTER*3 FUNIT(10)
C     CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
C     COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
C     READ A RECORD OF 2E INTEGRALS
C     THE LAST RECORD SHOULD SET NINT TO ZERO
C
C     Integrals for default stand-alone version
C000  CALL IJKLG0(IAO2E,GG,II,JJ,KK,LL,NINT)
C
C     Integrals for Gamess(US) version.
CGMS  CALL IJKLG1(GG,II,JJ,KK,LL,NINT)
C
C     Integrals for Gaussian version.
CGAU  CALL IJKLG2(GG,II,JJ,KK,LL,NINT)
C
C     Integrals for SMILES version.
CSMI  CALL IJKLG3(GG,II,JJ,KK,LL,NINT)
      IF(IAO2E.GT.1000000) WRITE(*,*)IAO2E
      RETURN
      END
      SUBROUTINE RDMORB(IOHFORB,V,E,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE,FILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
     &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
     &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
      DIMENSION V(*),E(*)
C
C     THIS IS THE FIRST ENTRY TO READ MOs
C     THERE ARE THREE OPTIONS:
C
C     1  GAUSSIAN
C     2  GAMESS
C     3  DEFAULT
C
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(3)
      OPEN(UNIT=IOHFORB,FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      GO TO (1,2,3,3),ICON
C     CASE 1: GAUSSIAN
  1   CONTINUE
CGAU  CALL RGAUMO(V,E,N)
CGAU  CLOSE(IOHFORB)
      RETURN
C     CASE 2: GAMESS
  2   CONTINUE
CGMS  CALL RGMSMO(V,E,N)
      RETURN
C     CASE 3: DEFAULT
  3   REWIND(IOHFORB)
      READ(IOHFORB)NB,(NOCC(I),I=1,NB)
      READ(IOHFORB)(E(I),I=1,NB)
      READ(IOHFORB)(V(I),I=1,NB*N)
      CLOSE(IOHFORB)
C     WRITE(IOUTVB,*)"E=",(E(I),I=1,NB)
      RETURN
      END
      SUBROUTINE SHREAD(S,H,MSQ,IOSH)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     PARAMETER (NBF=10000)
      DIMENSION S(*),H(*)
      REWIND (IOSH)
      READ(IOSH)(S(I),I=1,MSQ)
      READ(IOSH)(H(I),I=1,MSQ)
      RETURN
      END
      SUBROUTINE GREAD(G,MSQ,NBF,IOVB2E)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     PARAMETER (NBF=10000)
      DIMENSION G(*)
      REWIND (IOVB2E)
      READ(IOVB2E)
      READ(IOVB2E)
      MX=0
      NRE=(MSQ+NBF-1)/NBF
      DO 100 I=1,NRE
      NNN=NBF
      IF(I.EQ.NRE) NNN=MSQ-NRE*NBF+NBF
      READ(IOVB2E)(KKK,G(KKK),J=1,NNN)
      MX=MX+NBF
  100 CONTINUE
      RETURN
      END
      SUBROUTINE GWRTE(G,MSQ,LBUFF,IOVB2E)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION G(*)
      REWIND (IOVB2E)
      READ(IOVB2E)
      READ(IOVB2E)
      MX=0
      NRE=(MSQ+LBUFF-1)/LBUFF
      DO 100 I=1,NRE
      NNN=LBUFF
      IF(I.EQ.NRE) NNN=MSQ-NRE*LBUFF+LBUFF
      WRITE(IOVB2E)(MX+J,G(MX+J),J=1,NNN)
      MX=MX+LBUFF
  100 CONTINUE
      RETURN
      END
      SUBROUTINE DISLMO(NBASIS,NSUB,MLORBIT,ISPLIT,NGP,
     &    NATOMS,NAO,V,WK,PGM,DISCON,BONDLAB,VBOLAB)
C----------------------------------------------------------------------------
C     GENERATE INITIAL ORBITALS FOR VB CALCULATION.
C     VBMO ARE GENERATED FROM LMO's BY DISTORTION.
C     NSUB:      NUMBER OF SUBUNITS
C     MELE(I):   NUMBER OF ELECTRONS OF EACH SUBUNIT.
C     METHOD(I): METHOD FOR TREATING EACH SUBUNIT
C     MLORBIT(I):NUMBER OF ORBITALS OF EACH SUBUNIT
C     ISPLIT(I): SWITCH OF SPLITING
C                =0, DO NOT SPLIT
C                =M, SPLIT THE LMO INTO M+1 VB ORBITALS
C     NGP(I):   INDEX OF A LMO INDICATING WHICH SUBUNIT  IT BELONGS TO.
C     NATOMS:   NUMBER OF ELECTRONS
C     NLOCAL:	NUMBER OF LOCALIZED ORBITALS
C     V:        LOCALIZED MO COEFFICIENTS
C     PGM:      MULLIKEN POLULATION ANALYSIS OF NLOCAL ORBITALS
C     WK:       WORK FILED
C     NBASIS:   DIMENSION OF MO
C     DISCON:   DISTORTION PARAMETERS (AN ARBITARY VALUE 0.0-1.0)
C               Default=1.0, Maximum distortion.
C               0.0, no distortion.
C     NAO:      NUMBER OF ATOMIC BASIS FUNCTIONS FOR EACH ATOM
C
C     Created by Jiabo Li, June, 1998
C     (first version)
C     Revised by Jiabo Li, Feb., 2000
C     (a LMO can be splited into many VB orbitals)
C     Revised by Jiabo Li, July, 2000
C     (3-center-2-electron bonds can be treated automatically)
C----------------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*8 VBOLAB(*),BONDLAB(*)
      PARAMETER (MAXFIL=50000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION WK(NBASIS,*),V(NBASIS,*),MLORBIT(*),PGM(NATOMS,*)
      DIMENSION NA(5000),NAO(*),ISPLIT(*),NGP(*)
      DIMENSION NWA(1000),WPGM(1000),NWK(1000),FILTER(MAXFIL)
      DIMENSION NPT(4),NGATM(1000)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      IF(NATOMS.GT.1000) CALL ABORT0('DISLMO01  ')
      IF(NATOMS*(NBASIS+20).GT.MAXFIL) THEN
        WRITE(IOUTVB,*)"NATOMS*NBASIS .GT. 50000"
        CALL ABORT0('DISLMO02  ')
      END IF
      DO I=1,1000
      NWK(I) = -1
      END DO
      DO I=1,NATOMS*(NBASIS+20)
      FILTER(I)=1.0D0
      END DO
      NT=0
      DO 1 I=1,NATOMS
      DO 2 J=1,NAO(I)
      NT=NT+1
      NA(NT)=I
  2   CONTINUE
  1   CONTINUE
      NBG=0
      DO 100 L=1,NSUB
      MBG=0
      DO 120 K=1,NBASIS
C
C     SET UP DEFAULT FOR LMO SPLIT PARTIONING
C
      DO I=1,4
      NPT(I)=1
      END DO
      IF(NGP(K).NE.L) GOTO 120
      RAT = 0.0D0
      IF(ISPLIT(K).EQ.0) THEN
C
C     Do not split
C
        MBG=MBG+1
        NWK(NBG+MBG)=K
        VBOLAB(NBG+MBG) = BONDLAB(K)
      ELSE
C
C     SPLIT LMO BY DISTORTION OF THE LMO
C
C     STEP 1: SORT ATOMS WITH THE LARGEST MULLIKEN CHARGES
        DO J=1,NATOMS
        WPGM(J)=PGM(J,K)
        END DO
        CALL SHELL(WPGM,NWA,NATOMS)
        NAHALF=NATOMS/2
        DO J=1,NAHALF
        NAJ=NWA(J)
        NWA(J)=NWA(NATOMS-J+1)
        NWA(NATOMS-J+1)=NAJ
        END DO
C
C     NOW, NWA(*) HOLD THE SORTED ATOM LIST STARTING WITH THE
C     LARGEST MULLIKEN CHARGE
C
C     STEP 2: SET UP PARTITIONING OF THE ATOM LIST
C
C     CONSIDER POSSIBLE THREE-CENTER-TWO-ELECTRON BONDS
C
      IF(NATOMS.GE.3.AND.PGM(NWA(2),K).GT.0.3D0
     &  .AND.PGM(NWA(3),K)/PGM(NWA(2),K).GT.0.95D0) NPT(2)=2
      NTMP=0
      DO KK=1,NATOMS
      NGATM(KK)=0
      END DO
      DO K4=1,4
       DO KK=1,NPT(K4)
       NTMP=NTMP+1
C
C      EARLY EXIT
C
       IF(NTMP.GT.NATOMS) GOTO 111
       NGATM(NWA(NTMP))=K4
       END DO
      END DO
 111  CONTINUE
C
C     STEP 3: DISTORTION OF LMO
        DO KK=1,ISPLIT(K)+1
        RAT=PGM(NWA(KK),K)/PGM(NWA(1),K)
        NWK(NBG+MBG+KK)=K
        VBOLAB(NBG+MBG+KK) = BONDLAB(K)
        MMK=(NBG+MBG+KK-1)*NATOMS
        DO J=1,NATOMS
        FACT=1.0D0-DISCON
        IF(NGATM(J).EQ.KK) FACT=1.0D0+DISCON
        FILTER(MMK+J)=FACT
        END DO
      END DO
      MBG=MBG+1+ISPLIT(K)
C
C     IF THE RAT IS VERY SMALL, THEN THE ORBITAL IS ALMOST A LONE PAIR
C     AND ONLY ONE ORBITAL SHOULD BE GENERATED. IF THE FOLLOWING MESSAGE
C     IS PRINTED, THE SETTING IS LIKELY BE WRONG
C
      IF(RAT.LT.0.1D0) WRITE(IOUTVB,1000)K
 1000 FORMAT(' WARNING: you are splitting a lone-pair LMO(',I3,')')
      END IF
      RATD=RAT
      IF(RATD.LT.0.1D0) RATD=0.1D0
      IF(MBG.GE.MLORBIT(L)) GOTO 110
 120  CONTINUE
C     IF(MBG.NE.MLORBIT(L)) WRITE(IOUTVB,*)"WARNING: VBORB INPUT IS NEEDED"
 110  NBG=NBG+MLORBIT(L)
 100  CONTINUE
C
C     Operate with the filter
C
      DO I=1,NBG
      II=(I-1)*NATOMS
      IF( NWK(I).GT.0) THEN
        DO J=1,NBASIS
        NAJ=NA(J)
        WK(J,I)=FILTER(II+NAJ)*V(J,NWK(I))
        END DO
      ELSE
        WRITE(IOUTVB,1002)I
C
C     GENERATE ARBITRARY VECTORS FOR VIRTUAL ORBITALS
C
        DO J=1,NBASIS
          WK(J,I)=VBRAND(0)
        END DO
C
      END IF
      END DO
C
C     WK-->V
C
      DO 210 J=1,NBASIS
      DO 200 I=1,NBG
      V(J,I)=WK(J,I)
 200  CONTINUE
C     WRITE(IOUTVB,1001)(V(J,I),I=1,NBG)
 210  CONTINUE
C1001 FORMAT(6F12.6)
 1002 FORMAT(' WARNING: Initial orbital',I3, ' undefined from DISLMO'/
     &       ' Initial orbital',I3, ' by an arbitrary vector')
      RETURN
      END
      SUBROUTINE EXPAND(VECT,CONSTR,ICONST,NPAR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION VECT(*),CONSTR(*),ICONST(*),V(5000)
      DO I=1,NPAR
      IF(ICONST(I).GT.0) THEN
      V(I)=CONSTR(I)*VECT(ICONST(I))
      ELSE
      V(I)=0.0D0
      END IF
      END DO
      DO I=1,NPAR
      VECT(I)=V(I)
C     WRITE(IOUTVB,'(I4,F12.8)')I,VECT(I)
      END DO
      RETURN
      END
      SUBROUTINE ZHESS(HESS,NSTR,CSTR,NBRIL,DEV1)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION HESS(*),CSTR(*),DEV1(*)
      SUM=0.0D0
      DO I=1,NSTR
      SUM=SUM+DEV1(NBRIL+I)**2
      END DO
      SUM=DSQRT(SUM/NSTR)
C     SCALE=2.0D0*SUM
      DO I=1,NSTR
      II=(NBRIL+I-1)*(NBRIL+I)/2
      DO J=1,I
      IJ=II+NBRIL+J
      HESS(IJ)=HESS(IJ)+CSTR(I)*CSTR(J)
      END DO
      END DO
      RETURN
      END
      SUBROUTINE BRIMASK(HESS,NSTR,NBRIL,DEV1,MASKBRI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION HESS(*),DEV1(*),MASKBRI(*)
      DO I=1, NBRIL
      II = I*(I-1)/2
      IF(MASKBRI(I).EQ.0) THEN
          DO J=1, I-1
          IJ = II+ J
          HESS(IJ)= 0.0D0
          END DO
          DO J=I+1,NBRIL+NSTR
          IJ=J*(J-1)/2+I
          HESS(IJ)= 0.0D0
          END DO
          HESS(II+I) = 1.0D0
          DEV1(I) = 0.0D0
      END IF
      END DO
      RETURN
      END
      SUBROUTINE CONDEN(HESS,HESSW,DEV1,DEV,NPAR,NONLIN,IDERANK,
     &       IOHES,CONSTR,ICONST)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE,FILE
      CHARACTER*3 FUNIT(10)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION HESS(*),DEV1(*),CONSTR(*),ICONST(*)
      DIMENSION HESSW(*),DEV(*)
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      NSQ2=NONLIN*(NONLIN+1)/2
C
C     IF (IDERANK.EQ.1), ONLY DEV1 IS CONDENSED
C
      DO I=1,NONLIN
      DEV(I)=0.0D0
      END DO
      DO I=1,NPAR
      II=ICONST(I)
      IF(II.GT.0) DEV(II)=DEV(II)+CONSTR(I)*DEV1(I)
      END DO
      IF(IDERANK.LE.1) THEN
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(8)
      OPEN(UNIT=IOHES,FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      REWIND(IOHES)
      READ(IOHES)(HESS(I),I=1,NSQ2)
      CLOSE(IOHES)
      RETURN
      END IF
      DO I=1,NSQ2
      HESSW(I)=0.0D0
      END DO
      IJ=0
      DO I=1,NPAR
      II=ICONST(I)
      DO J=1,I
      IJ=IJ+1
      JJ=ICONST(J)
      IF(II.GT.0.AND.JJ.GT.0) THEN
      IIJJ=IJ00(II,JJ)
      FACTOR=1.0D0
      IF(II.EQ.JJ.AND.I.NE.J) FACTOR=2.0D0
      HESSW(IIJJ)=HESSW(IIJJ)+CONSTR(I)*CONSTR(J)*HESS(IJ)*FACTOR
      END IF
      END DO
      END DO
      IJ=0
      DO I=1,NONLIN
      DO J=1,I
      IJ=IJ+1
      HESS(IJ)=HESSW(IJ)
      END DO
      END DO
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(8)
      OPEN(UNIT=IOHES,FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      REWIND(IOHES)
      WRITE(IOHES)(HESS(I),I=1,NSQ2)
      CLOSE(IOHES)
      RETURN
      END
      SUBROUTINE RCONST(CONSTR,ICONST,NBRI,NPAR,NLORBI,NLCSTR,FLAG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MAXPAR=10000)
      CHARACTER*50 FLAG
      DIMENSION CONSTR(*),ICONST(*),MAPCON(MAXPAR)
C     IOENGI = 80
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      IF(NPAR.GT.MAXPAR) CALL ABORT0("RCONST0001")
C
C     SET DEFAULT VALUES
C
      DO I=1,NPAR
      ICONST(I)=I
      CONSTR(I)=1.0D0
      MAPCON(I)=0
      END DO
C
C     Since the zero eigen problem of linear depencency is fixed,
C     the following line is commented out.
C
C     ICONST(NBRI+1)=0
      FLAG(4:8)='CONST'
      CALL LOCTOR(IOENGI,FLAG,8,IOK,0)
      IF(IOK.EQ.1) THEN
C
C     READ EQUIVALENT CONSTRAINTS
C     I.E. C(IND)=CONSTR(IND).*C(ICONST(IND))
C     FOR INSTRANCE, 5,-1,4
C     MEANS C(5)=-1.0*C(4)
C
C     4,1,0 MEANS THAT C(4) IS FIXED  (I.E. NOT OPTIMIZED)
C
      READ(IOENGI,*)NP
      READ(IOENGI,*)(IND,CONSTR(IND),ICONST(IND),J=1,NP)
      END IF
C
C     SETUP NEW INDEX FOR ALL LINEARLY INDEPENDENT PARAMETERS
C
      NCOUNT=0
      DO I=1,NPAR
      IF(ICONST(I).GT.0.AND.MAPCON(ICONST(I)).EQ.0) THEN
      NCOUNT=NCOUNT+1
      MAPCON(ICONST(I))=NCOUNT
      END IF
      IF(I.EQ.NBRI) NLORBI=NCOUNT
      IF(ICONST(I).GT.0) ICONST(I)=MAPCON(ICONST(I))
      END DO
      NLCSTR=NCOUNT-NLORBI
      RETURN
      END
      SUBROUTINE STRSYM(CSTR,NSTR,FLAG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*50 FLAG
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION CSTR(*)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      FLAG(4:8)='STRSY'
      CALL LOCTOR(IOENGI,FLAG,8,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*)NP
      DO I=1,NP
      READ(IOENGI,*)IA,FACTOR,IB
      IF(IA.GT.NSTR.OR.IB.GT.NSTR) WRITE(IOUTVB,*)"WRONG DATA!!!"
      CSTR(IA)=CSTR(IB)*FACTOR
      END DO
      END IF
      RETURN
      END
      SUBROUTINE RDGUES(NBASIS,BASIS,IOUNIT,IOENGI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION BASIS(NBASIS,*)
      CHARACTER*20 FILEGUESS
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      CALL LOCTOR(IOENGI,'$READGUESS',10,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*)FILEGUESS
      OPEN(IOUNIT,FILE=FILEGUESS,STATUS='OLD')
      READ(IOUNIT,2000)NBA,NORB
      IF(NBA.NE.NBASIS.OR.NORB.GT.NBASIS) THEN
        WRITE(IOUTVB,*)"INITIAL GUESS FILE IS NOT CORRECT"
        WRITE(IOUTVB,*)"PLEASE CHECK NBASIS AND NORB IN YOUR GUESS FILE"
        CALL ABORT0('RDGUESS01 ')
      ELSE
        WRITE(IOUTVB,'(" READING INITIAL GUESS FROM ",A20)') FILEGUESS
      END IF
      DO J=1,NORB
        READ(IOUNIT,1000) (BASIS(I,J),I=1,NBASIS)
      END DO
      CLOSE(IOUNIT)
      END IF
      RETURN
 1000 FORMAT(8F9.5)
 2000 FORMAT(2I5)
      END
      SUBROUTINE WTGUES(NBASIS,BASIS,NORB,IOUNIT,IOENGI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION BASIS(NBASIS,*)
      CHARACTER*20 FILEGUESS
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      call loctor(IOENGI,'$WRITEGUESS',11,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*)FILEGUESS
      OPEN(IOUNIT,FILE=FILEGUESS,STATUS='UNKNOWN')
      WRITE(IOUNIT,2000)NBASIS,NORB
      DO J=1,NORB
      WRITE(IOUNIT,1000)(BASIS(I,J),I=1,NBASIS)
      END DO
      CLOSE(IOUNIT)
      WRITE(IOUTVB,'(" WRITING GUESS TO ",A20)') FILEGUESS
      END IF
 1000 FORMAT(8F9.5)
 2000 FORMAT(2I5)
      RETURN
      END
      SUBROUTINE PIVBO(N,V,NB1ADD)
C----------------------------------------------------------------------------
C     V:        VB ORBITALS
C     N:        DIMENSION OF MO
C     NB1ADD:   STARTING INDEXES OF ORBITALS OF SUBUNITS
C     NATOMS:   NUMBER OF ATOMS
C----------------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*8 BONDLAB(*),VBOLAB(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION V(N,*),NB1ADD(*),NWA(100),NPI(2,1000)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      DO 100 I=1,99
 100  NWA(I)=NB1ADD(I)
      NPIORB = 0
      CALL LOCTOR(IOENGI,'$PIORB',6,IOK,0)
      IF(IOK.EQ.0) CALL LOCTOR(IOENGI,'$AOGROUP',8,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*,ERR=101)NPIORB
      READ(IOENGI,*,ERR=101)(NPI(1,I),I=1,NPIORB)
      READ(IOENGI,*,ERR=101)(NPI(2,I),I=1,NPIORB)
      END IF
      GOTO 102
 101  WRITE(IOUTVB,*)"ERROR IN $AOGROUP"
      CALL ABORT0("PIVBO00001")
 102  CONTINUE
C
C     Look for special flag $ALLAOS
C
      CALL LOCTOR(IOENGI,'$ALLAOS',7,IOK,0)
      IF(IOK.EQ.1) THEN
        NPIORB = N
        DO I=1, NPIORB
        NPI(1,I) = I
        NPI(2,I) = 1
        END DO
      END IF
C
C     PRINT AO group assignment
C
      IF (NPIORB.GT.0) THEN
      WRITE(IOUTVB,900)
      WRITE(IOUTVB,1000)(NPI(1,I),I=1,NPIORB)
      WRITE(IOUTVB,1100)(NPI(2,I),I=1,NPIORB)
      END IF
      DO I=1,NPIORB
      IDXPI=NWA(NPI(2,I))
      IDXAO=NPI(1,I)
        DO K=1,N
        V(K,IDXPI)=0.0D0
        V(IDXAO,K)=0.0D0
        END DO
      V(IDXAO,IDXPI)=1.0D0
      NWA(NPI(2,I))=NWA(NPI(2,I))+1
      END DO
      WRITE(IOUTVB,*)
  900 FORMAT(/' Group assignment of AOs'/1X,71(1H=))
 1000 FORMAT(' AO#:    ',20I3)
 1100 FORMAT(' Group#: ',20I3)
      RETURN
      END
      SUBROUTINE VBOPARSER(VBOFLAG,LSTRING,NTERMS,NVBOCODE,CTERMS,
     &                     IDXVBO,IERR)
C----------------------------------------------------------------------------
C     VBOFLAG:  INPUT STRING OF VBO FLAG
C     NTERMS:   NUMBER OF COMPONENTS IN THE VBO
C     NVBOCODE: VBO CODE FOR EACH COMPONENT
C     CTERMS:   COEFFICIENT OF EATCH TERM
C----------------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*80 NUMBER,VBOFLAG
      CHARACTER*80 VBOFLAG
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION NVBOCODE(5,*),CTERMS(*)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     NUMBER   = '0123456789'
      ICURSOR = 1
      TSIGN = 0.0D0
      NTERMS = 0
C     NVBOS  = 0
      ISTEM  = 1
 100  CONTINUE
      CALL SIGNRD(VBOFLAG,LSTRING,ICURSOR,TSIGN,IERR)
C
C     READ COEF
C
      CALL COEFRD(VBOFLAG,RNUM,ICURSOR,LSTRING,INTCODE,IERR)
      IF(IERR.EQ.1.AND.NTERMS.GT.0) GOTO 200
      IF(IERR.EQ.1) THEN
      WRITE(IOUTVB,*)'ERROR POSITION = ',ICURSOR,' IN THE VBO CODE:'
      WRITE(IOUTVB,'(A80)')VBOFLAG
      CALL ABORT0('VBOPARSER1')
      ELSE
      IF (INTCODE.LT.0) RNUM = 1.0D0
      END IF
      COEFF=TSIGN*RNUM
C
C     READ VBO CODE
C
      CALL VBOCRD(VBOFLAG,ICURSOR,LSTRING,NVBOCODE(1,NTERMS+1),
     &            IERR)
C
C     CHECK IF IT IS A CONDENSED EXPRESSION.
C
      IF(IERR.EQ.0) THEN
        IF(NVBOCODE(3,NTERMS+1).LT.4.OR.NVBOCODE(3,NTERMS+1).EQ.8) THEN
        NTERMS = NTERMS+1
          IF(ISTEM.EQ.1) THEN
          IDXVBO = IDXVBO+1
          ISTEM = 0
          END IF
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        ELSE IF(NVBOCODE(3,NTERMS+1).EQ.4) THEN
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        IBDIDX = NVBOCODE(4,NTERMS)
        IF(IBDIDX.EQ.1) THEN
        IBTYPE = 1
        IBORDE = 1
        ELSE IF(IBDIDX.EQ.2) THEN
        IBTYPE = 2
        IBORDE = 1
        ELSE IF(IBDIDX.EQ.3) THEN
        IBTYPE = 2
        IBORDE = 2
        END IF
        NATOM1 = NVBOCODE(1,NTERMS)
        NATOM2 = NVBOCODE(2,NTERMS)
        NVBOCODE(3,NTERMS) = IBTYPE
        NVBOCODE(4,NTERMS) = IBORDE
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        NVBOCODE(1,NTERMS) = NATOM2
        NVBOCODE(2,NTERMS) = NATOM1
        NVBOCODE(3,NTERMS) = IBTYPE
        NVBOCODE(4,NTERMS) = IBORDE
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        ELSE IF(NVBOCODE(3,NTERMS+1).EQ.5) THEN
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        NATOM1 = NVBOCODE(1,NTERMS)
        NATOM2 = NVBOCODE(2,NTERMS)
        NVBOCODE(3,NTERMS) = 1
        NVBOCODE(4,NTERMS) = 1
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        NVBOCODE(1,NTERMS) = NATOM2
        NVBOCODE(2,NTERMS) = NATOM1
        NVBOCODE(3,NTERMS) = 1
        NVBOCODE(4,NTERMS) = 1
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
C       FIRST PI
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        NVBOCODE(1,NTERMS) = NATOM1
        NVBOCODE(2,NTERMS) = NATOM2
        NVBOCODE(3,NTERMS) = 2
        NVBOCODE(4,NTERMS) = 1
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        NVBOCODE(1,NTERMS) = NATOM2
        NVBOCODE(2,NTERMS) = NATOM1
        NVBOCODE(3,NTERMS) = 2
        NVBOCODE(4,NTERMS) = 1
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        ELSE IF(NVBOCODE(3,NTERMS+1).EQ.6) THEN
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        NATOM1 = NVBOCODE(1,NTERMS)
        NATOM2 = NVBOCODE(2,NTERMS)
        NVBOCODE(3,NTERMS) = 1
        NVBOCODE(4,NTERMS) = 1
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        NVBOCODE(1,NTERMS) = NATOM2
        NVBOCODE(2,NTERMS) = NATOM1
        NVBOCODE(3,NTERMS) = 2
        NVBOCODE(3,NTERMS) = 1
        NVBOCODE(4,NTERMS) = 1
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
C       FIRST PI
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        NVBOCODE(1,NTERMS) = NATOM1
        NVBOCODE(2,NTERMS) = NATOM2
        NVBOCODE(3,NTERMS) = 2
        NVBOCODE(4,NTERMS) = 1
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        NVBOCODE(1,NTERMS) = NATOM2
        NVBOCODE(2,NTERMS) = NATOM1
        NVBOCODE(3,NTERMS) = 2
        NVBOCODE(4,NTERMS) = 1
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
C       SECOND PI
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        NVBOCODE(1,NTERMS) = NATOM1
        NVBOCODE(2,NTERMS) = NATOM2
        NVBOCODE(3,NTERMS) = 2
        NVBOCODE(4,NTERMS) = 2
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        NVBOCODE(1,NTERMS) = NATOM2
        NVBOCODE(2,NTERMS) = NATOM1
        NVBOCODE(3,NTERMS) = 2
        NVBOCODE(4,NTERMS) = 2
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        END IF
        IF(NVBOCODE(3,NTERMS+1).EQ.7) THEN
C       TYPE 7 (MC/LMO)
        NTERMS = NTERMS+1
          IF(ISTEM.EQ.1) THEN
          IDXVBO = IDXVBO+1
          ISTEM = 0
          END IF
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        ELSE IF(NVBOCODE(3,NTERMS+1).EQ.10) THEN
C       TYPE 10 (AO)
        NTERMS = NTERMS+1
          IF(ISTEM.EQ.1) THEN
          IDXVBO = IDXVBO+1
          ISTEM = 0
          END IF
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        ELSE IF(NVBOCODE(3,NTERMS+1).EQ.11) THEN
C       TYPE 11 (MO)
        NTERMS = NTERMS+1
          IF(ISTEM.EQ.1) THEN
          IDXVBO = IDXVBO+1
          ISTEM = 0
          END IF
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        ENDIF
      ELSE
        GOTO 200
      END IF
      IF(ICURSOR.LT.LSTRING.AND.IERR.EQ.0) GOTO 100
C
C     IF(NTERMS.GT.0), IGNORE THE BAD TERMS (IT COULD BE A COMMENT)
C
 200  CONTINUE
      IF(NTERMS.GT.0) IERR = 0
      RETURN
      END
      SUBROUTINE SIGNRD(VBOSTRING, LENBUF, ICURSOR, TSIGN, IERR)
C----------------------------------------------------------------------------
C     VBOSTRING:INPUT STRING OF VBO FLAG
C     ISTARTP:  STARTING POINTER
C     ISTOP:    STOPING POINTER
C     TSIGN:    SIGN (1.0 OR -1.0)
C     IERR:     ERROR CODE (0: NO ERROR, 1: ERROR)
C----------------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*80 NUMBER
      CHARACTER*1 VBOSTRING(*)
C     NUMBER   = '0123456789'
      TSIGN = 1.0D0
      ISTARTP = ICURSOR
      DO 100 I=ISTARTP,LENBUF
      IF(VBOSTRING(I).EQ.'+') THEN
      ICURSOR = I+1
      IERR = 0
      RETURN
      END IF
      IF(VBOSTRING(I).EQ.'-') THEN
      ICURSOR = I+1
      IERR = 0
      TSIGN = -1.0D0
      RETURN
      END IF
      IF(VBOSTRING(I).EQ.'('.OR.VBOSTRING(I).EQ.'['.OR.VBOSTRING(I)
     &               .EQ.'{'.OR.ISNUMBER(VBOSTRING(I)).GT.0) THEN
      ICURSOR = I
      IERR = 0
      RETURN
      END IF
      IF(VBOSTRING(I).NE.' ') THEN
      ICURSOR = I
      IERR = 1
      RETURN
      END IF
 100  CONTINUE
      RETURN
      END
      SUBROUTINE COEFRD(STRING,COEF,ICURSOR,LENBUF,INTCODE,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*1 STRING(*)
      LOGICAL ISATOM
      ISATOM = .FALSE.
      ICUR = ICURSOR
      CALL RNUMRD(STRING,RNUMBER,ICUR,LENBUF,INTCODE,IERR)
C
C     CASE 1: ERROR
C
      IF(IERR.EQ.1) RETURN
C
C     CASE 2: NO COEF, NO ERROR
C
      COEF = RNUMBER
      IF(INTCODE.EQ.-1.OR.INTCODE.EQ.0) THEN
      ICURSOR = ICUR
      RETURN
      END IF
      CALL SRCHVBOFLAG(STRING,ICUR,LENBUF,ISATOM)
      IF(INTCODE.EQ.1.AND.(.NOT.ISATOM)) THEN
      ICURSOR = ICUR
      RETURN
      ELSE
      INTCODE = -1
      IERR = 0
      END IF
      RETURN
      END
C
C     SEARCH '-', '=', '#', ':' AND '^'.
C
      SUBROUTINE SRCHVBOFLAG(STRING,ICUR,LENBUF,ISATOM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     character*80 A
      CHARACTER*1 STRING(*)
      LOGICAL ISATOM
      ISATOM = .FALSE.
      IF(STRING(ICUR).EQ.':'.OR.STRING(ICUR).EQ.'^') THEN
      ISATOM = .TRUE.
      RETURN
      END IF
      DO 100 I=ICUR,LENBUF
      IF(STRING(I).EQ.' ') THEN
      ELSE IF(STRING(I).EQ.'-'.OR.STRING(I).EQ.'='
     &        .OR.STRING(I).EQ.'#') THEN
      ISATOM = .TRUE.
      RETURN
      ELSE
      RETURN
      END IF
 100  CONTINUE
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     READ VBO CODE. SEARCH '-', '=', '#', ':' AND '^'.
C     EACH TYPE VBO CAN BE CODED AS FOLLOW:
C
C     NATOM1, NATOM2, NVBOTYPE, NBNDEX,NVBODEX
C
C     NATOM1: THE FIRST BONDING ATOM.
C     NATOM2: THE SECOND (BONDED) ATOM, IF ANY (FOR LP, PI, NATOM2=0).
C     NVBOTYPE: 1 = SIGMA, 2 = PI, 3 = LP, 4 = SINGLE BOND
C               5 = DOUBLE BOND, 6 = TRIPLE BOND, 7 = MC BOND/LMO,
C               8 = DIRECTIONAL PI BOND, I.E. THE PI ORBITAL OF NATOM1 POINTING
C                   TO NATOM2. NATOM1->NATOM2(PI)
C               9 = EXPLICIT DIRECTION POINT
C                   1 -> (1.0, -1.0, 0.0)
C               10 = AO(x). Use AO-x
C               11 = MO(x). Use MO-x
C
C     NBNDEX: BOND INDEX. 1 = THE FIRST ONE OF THE KIND.
C             FOR INSTANCE, TYPE=LP, AND NBNDEX=2, WHICH MEANS THE SECOND LP.
C             THE SAME RULES APPLY TO PI AND LMO AS WELL.
C     NVBODEX: THE VBO INDEX, I.E. WHICH VBO THE CODE IS SPECIFIED.
C
C
C     READ A TYPICAL VBO NOTATION:
C
C      (1-2(2))
C      -      -
C     THE UNDERLINED CHARS ARE OPTIONAL. BUT THEY MUST APPEAR IN PAIRS, OTHER
C     WISE, IT WILL GENERATE ERROR MESSAGE
C
C     FIRST CREATED: OCT. 15, 2003
C
C     AUTHOR: JIABO LI
C
C     9943 FIELDTHORN ST.
C     SAN DIEGO, CA 92127
C
C     REVISION: ADDED NVBOTYPE 8.
C
C     ADDED MULTIPLE-CENTER BOND TYPE: NVBOTYPE 7.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE VBOCRD(STRING,ICUR,LENBUF,NVBOCODE,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*1 STRING(*)
      CHARACTER*8 TEMP
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION NVBOCODE(5)
      LOGICAL LEFTP,RIGHTP,LEFTB,RIGHTB,LMODIP,RMODIP
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      LEFTP  = .FALSE.
      RIGHTP = .FALSE.
      LEFTB  = .FALSE.
      RIGHTB = .FALSE.
      LMODIP = .FALSE.
      RMODIP = .FALSE.
      IERR   = 0
      ICURSOR = ICUR
CGMS  IGMS=1
CGMS  IF (IGMS.GT.10) WRITE(IOUTVB,*)"STUPID",LMODIP,RIGHTB,
CGMS & RIGHTP,RMODIP
C
C     NVBO: THE NUMBER OF VBOS. FOR A MULTI-COMPONENT VBO,
C     NVBO IS SET ZERO FOR ALL TERMS EXCEPT FOR THE LAST TERM.
C     FOR LAST TERM, NVBO IS SET TO 1
C
C     FOR A MULTI-VBO INPUT, FOR INSTANCE, n-m, NVBO = 2
C     FOR n=m, NVBO =4, AND FOR n#m, NVBO = 6.
C     SET THE DEFAULT VALUES
C
      NVBOCODE(3) = 1
      NVBOCODE(4) = 1
C
C     SEARCH FOR MC, AO, LMO FLAG,
C
      DO 10 I=ICUR, LENBUF-1
      IF(STRING(I).EQ.'M'.AND.STRING(I+1).EQ.'C') THEN
      NVBOCODE(3) = 7
      ICURSOR = I+3
      GOTO 11
      END IF
      IF(STRING(I).EQ.'L'.AND.STRING(I+1).EQ.'M') THEN
      NVBOCODE(3) = 7
      ICURSOR = I+4
      GOTO 11
      END IF
      IF(STRING(I).EQ.'A'.AND.STRING(I+1).EQ.'O') THEN
      NVBOCODE(3) = 10
      ICURSOR = I+3
      GOTO 11
      END IF
      IF(STRING(I).EQ.'M'.AND.STRING(I+1).EQ.'O') THEN
      NVBOCODE(3) = 11
      ICURSOR = I+3
      GOTO 11
      END IF
 10   CONTINUE
 11   CONTINUE
      IF(NVBOCODE(3).EQ.1) GOTO 111
C
C     READ MC/LMO/AO INDEX,
C     MC(X)
C     AO(X)
C     LMO(X)
C
      ICUR = ICURSOR
      CALL RNUMRD(STRING,RNUMBER,ICUR,LENBUF,INTCODE,IERR)
      IF(IERR.EQ.1) RETURN
      IF(INTCODE.NE.1) THEN
      IERR = 1
      RETURN
      END IF
      NVBOCODE(4) = INT(RNUMBER + 1.0D-5)
      RETURN
 111  CONTINUE
C
C
C     SEARCH FOR LEFT PARENTHESIS
C
      DO 100 I=ICUR, LENBUF
      ITEMP = ISNUMBER(STRING(I))
      IF(STRING(I).EQ.' ') THEN
C     WRITE(IOUTVB,*)'SKIP SPACE'
      ELSE IF(STRING(I).EQ.'(') THEN
      LEFTP = .TRUE.
      ICURSOR = I + 1
      GOTO 110
      ELSE IF(STRING(I).EQ.'[') THEN
      LEFTB = .TRUE.
      ICURSOR = I + 1
      GOTO 110
      ELSE IF (ITEMP.GE.0) THEN
      ICURSOR = I
      GOTO 110
      ELSE
      IERR = 1
      RETURN
      END IF
 100  CONTINUE
 110  CONTINUE
C
C     READ NATOM1
C
      ICUR = ICURSOR
      CALL RNUMRD(STRING,RNUMBER,ICUR,LENBUF,INTCODE,IERR)
      IF(IERR.EQ.1) RETURN
      IF(INTCODE.NE.1) THEN
      IERR = 1
      RETURN
      END IF
      NVBOCODE(1) = INT(RNUMBER + 1.0D-5)
C     WRITE(IOUTVB,*)'NATOM1 = ', NVBOCODE(1)
C
C     READ VBO TYPE
C
      DO 200 I = ICUR, LENBUF
      IF(STRING(I).EQ.':') THEN
      NVBOCODE(2) = 0
      NVBOCODE(3) = 3
      ICURSOR = I + 1
C     WRITE(IOUTVB,*)' ICURSOR = ',ICURSOR
      GOTO 210
      ELSE IF(STRING(I).EQ.'^') THEN
      NVBOCODE(2) = 0
      NVBOCODE(3) = 2
      ICURSOR = I + 1
      GOTO 210
      ELSE IF(STRING(I).EQ.'-'.AND.STRING(I+1).EQ.'>'
     &                        .AND.STRING(I+2).EQ.'(') THEN
      NVBOCODE(3) = 9
      ICURSOR = I + 3
      GOTO 210
      ELSE IF(STRING(I).EQ.'-'.AND.STRING(I+1).EQ.'>') THEN
      NVBOCODE(3) = 1
      ICURSOR = I + 2
      GOTO 210
      ELSE IF(STRING(I).EQ.'-') THEN
      NVBOCODE(3) = 4
      ICURSOR = I + 1
      GOTO 210
      ELSE IF(STRING(I).EQ.'=') THEN
      NVBOCODE(3) = 5
      ICURSOR = I + 1
      GOTO 210
      ELSE IF(STRING(I).EQ.'#') THEN
      NVBOCODE(3) = 6
      ICURSOR = I + 1
      GOTO 210
      ELSE IF(STRING(I).EQ.' ') THEN
C     WRITE(IOUTVB,*)'SKIP SPACE'
      ELSE
      IERR = 1
      RETURN
      END IF
 200  CONTINUE
 210  CONTINUE
C     WRITE(IOUTVB,*)'VBO TYPE = ', NVBOCODE(3)
      ICUR = ICURSOR
C
C     READ (X,Y,Z)
C
      IF(NVBOCODE(3).EQ.9) THEN
          CALL RNUMRD(STRING,X,ICUR,LENBUF,INTCODE,IERR)
          ICUR = ICUR+1
          CALL RNUMRD(STRING,Y,ICUR,LENBUF,INTCODE,IERR)
          ICUR = ICUR+1
          CALL RNUMRD(STRING,Z,ICUR,LENBUF,INTCODE,IERR)
          WRITE(IOUTVB,*)"XYZ = ", X, Y, Z
         RETURN
      END IF
C
C
C     READ NATOM2 FOR SIGMA AND LMO BOND
C
      IF(NVBOCODE(3).EQ.1.OR.NVBOCODE(3).GE.4) THEN
C     WRITE(IOUTVB,*)'ICUR FOR READ NATOM2 = ', ICUR
      CALL RNUMRD(STRING,RNUMBER,ICUR,LENBUF,INTCODE,IERR)
      IF(IERR.EQ.1) RETURN
        IF(INTCODE.NE.1) THEN
        IERR = 1
        RETURN
        END IF
      NVBOCODE(2) = INT(RNUMBER + 1.0D-5)
      IF(RNUMBER.LT.0.0D0) NVBOCODE(2) = INT(RNUMBER - 1.0D-5)
C     WRITE(IOUTVB,*)'NATOM2=',NVBOCODE(2)
      ICURSOR = ICUR
      END IF
C
C     FOR LMO, PI, AND LP, READ POSSIBLE MODIFIER
C
      IF(NVBOCODE(3).EQ.1) GOTO 305
C     WRITE(IOUTVB,*)'ICUR AFTER NATOM2 = ', ICUR
      DO 300 I=ICUR, LENBUF
      ICURSOR = I
      IF(STRING(I).EQ.' ') THEN
C       WRITE(IOUTVB,*)'SKIP SPACE'
      ELSE IF(STRING(I).EQ.'(') THEN
C
C     MODIFIER STARTS
C
        LMODIP = .TRUE.
        ICURSOR = I + 1
        CALL RNUMRD(STRING,RNUMBER,ICURSOR,LENBUF,INTCODE,IERR)
        IF(IERR.EQ.1) RETURN
          IF(INTCODE.NE.1) THEN
          IERR = 1
          RETURN
          END IF
          NVBOCODE(4) = INT(RNUMBER + 1.0D-5)
        ICURX = ICURSOR
        DO J=ICURX, LENBUF
        IF(STRING(J).EQ.' ') THEN
C       WRITE(IOUTVB,*)'SKIP SPACE'
        ELSE IF(STRING(J).EQ.')')  THEN
        RMODIP = .TRUE.
        ICURSOR = J + 1
        GOTO 310
        ELSE
        IERR = 1
        RETURN
        END IF
        END DO
      ELSE
C
C     FOR ANY CHAR RATHER THAN ' ' and '(', STOP
C
      ICURSOR = I
      GOTO 310
      END IF
 300  CONTINUE
 305  CONTINUE
      DO 306 I=ICUR, LENBUF-3
      ICURSOR = I
      TEMP(1:1)=STRING(I)
      TEMP(2:2)=STRING(I+1)
      TEMP(3:3)=STRING(I+2)
      TEMP(4:4)=STRING(I+3)
      IF(STRING(I).NE.' ') THEN
        IF(TEMP(1:4).EQ.'(PI)') THEN
          NVBOCODE(3)=8
          ICURSOR = I+4
        END IF
        GOTO 310
      END IF
 306  CONTINUE
 310  CONTINUE
      ICUR = ICURSOR
C
C     FINISH THE VBOCODE READ
C
      IF(LEFTP) THEN
C
C     SEARCH FOR RIGHTP
C
        DO J=ICURSOR, LENBUF
        IF(STRING(J).EQ.' ') THEN
C       WRITE(IOUTVB,*)'SKIP SPACE'
        ELSE IF(STRING(J).EQ.')')  THEN
        RIGHTP = .TRUE.
        ICUR = J + 1
        GOTO 410
        ELSE
        IERR = 1
        RETURN
        END IF
        END DO
      ELSE IF(LEFTB) THEN
C
C     SEARCH FOR RIGHTB
C
        DO J=ICURSOR, LENBUF
        IF(STRING(J).EQ.' ') THEN
C       WRITE(IOUTVB,*)'SKIP SPACE'
        ELSE IF(STRING(J).EQ.']')  THEN
        RIGHTB = .TRUE.
        ICUR = J + 1
        GOTO 410
        ELSE
        IERR = 1
        RETURN
        END IF
        END DO
      END IF
 410  CONTINUE
C     WRITE(IOUTVB,*)'NVBOCODE =',(NVBOCODE(K),K=1,4)
C     WRITE(IOUTVB,*)'RETURN ICURSOR =', ICURSOR
      RETURN
      END
C
C     READ A REAL NUMBER FROM THE CURRENT POINT
C     STOP AT ANY NON-NUMBERICAL CHAR, INCLUDE THE CURRENT ONE
C     THE RETURN NUMBER IS IN RNUMBER
C     INTCODE: 1 = INTEGER; 0 = REAL; -1: EMPTY
C
      SUBROUTINE RNUMRD(STRING,RNUMBER,ICURSOR,LENBUF,INTCODE,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     character*80 A
      CHARACTER*1 STRING(*)
      DFACTOR = 1.0D0
C     number=0
      RNUMBER = 0.0D0
      NSTARTED = 0
      NDECSTED = 0
      INTCODE = -1
      INTDIG = 0
      IDEDIG = 0
      IERR = 0
      SIGN = 1.0D0
      ISTART = ICURSOR
      DO 100 I=ISTART,LENBUF
      ITEMP=ISNUMBER(STRING(I))
      IF(NSTARTED.EQ.0) THEN
C
C     NUMBER NOT STARTED YET
C
        IF(STRING(I).EQ.'-') THEN
           SIGN = -1.0D0
        ELSE IF(STRING(I).EQ.' ') THEN
C       WRITE(IOUTVB,*)'SKIP SPACE'
        ELSE IF(ITEMP.GE.0) THEN
        NSTARTED = 1
        RNUMBER = ITEMP
        INTCODE = 1
        INTDIG = INTDIG+1
        ELSE IF(STRING(I).EQ.'.') THEN
        NDECSTED = 1
        INTCODE  = 0
        NSTARTED = 1
        ELSE
         RNUMBER=SIGN*RNUMBER
        ICURSOR = I
        RETURN
        END IF
      ELSE IF(NDECSTED.EQ.0) THEN
C
C     INTEGER PART
C
        IF(STRING(I).EQ.' ') THEN
        ICURSOR = I
        RETURN
        ELSE IF(ITEMP.GE.0) THEN
        RNUMBER = RNUMBER*10 + ITEMP
        INTDIG = INTDIG+1
        ELSE IF (STRING(I).EQ.'.') THEN
        NDECSTED= 1
        NSTARTED= 1
        INTCODE = 0
        ELSE
         RNUMBER=SIGN*RNUMBER
        ICURSOR = I
        RETURN
        END IF
      ELSE
C
C     DECIMAL PART
C
        IF(ITEMP.GE.0) THEN
        DFACTOR = DFACTOR*0.1D0
        RNUMBER = RNUMBER + DFACTOR*ITEMP
        IDEDIG = IDEDIG + 1
        ELSE IF(STRING(I).EQ.'.') THEN
        INTCODE = -1
        ICURSOR = I
        IERR = 1
        RETURN
        ELSE IF(IDEDIG.EQ.0.AND.INTDIG.EQ.0) THEN
        ICURSOR = I
        INTCODE = -1
        IERR = 1
        RETURN
        ELSE
         RNUMBER=SIGN*RNUMBER
        ICURSOR = I
        RETURN
        END IF
      END IF
 100  CONTINUE
         RNUMBER=SIGN*RNUMBER
      ICURSOR=LENBUF
      RETURN
      END
      SUBROUTINE LPIVBO(V,NB1ADD,IOLVBO,NBONDALIST,NSUB,
     &                  VBOLAB)
C----------------------------------------------------------------------------
C     V:        VB ORBITALS
C     NDIM:     DIMENSION OF MO
C     NB1ADD:   STARTING INDEXES OF ORBITALS OF SUBUNITS
C----------------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 NUMBER,FLAG
      CHARACTER*12 FRGAOLB,BFLABE,ATEMP,BTEMP
      CHARACTER*20 BASNAME
      CHARACTER*8  VBOLAB(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION V(NBASIS,*),NB1ADD(*)
      DIMENSION NPIA(100),NAOST(1000),FRGORB(100)
      DIMENSION FRGXYZ(3,20),FRGAOLB(100),PLANXYZ(3,20),A(3),B(3)
      DIMENSION RMAT(3,3),WT(100),NBONDALIST(10,*)
      DIMENSION ATMPIDIR(3,20),GRPIDIR(3),VBOLDIR(3)
      LOGICAL GPIDIR,APIDIR(20)
C
C     FIRST, CHECK IOLVBO
C
      IF(IOLVBO.EQ.0) RETURN
      NUMBER   = '0123456789'
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      DO 100 I=1,99
      WT(I) = 1.0D0
 100  CONTINUE
      NAOST(1) = 1
      DO I=1,NATOM
      NAOST(I+1) = NAOST(I) + NATBAS(I)
      END DO
C
C     LOOP OVER EACH GROUP. IF $XXPIVBO IS FOUND, THEN THE GROUP XX IS
C     A PI GROUP, AND THE PI ORBITAL WILL BE DEFINED USING THE NEW RULES
C
      DO I=1, NSUB
      MGRP     = I
      NC1      = 1+MGRP/10
      NC2      = 1+MGRP-10*(NC1-1)
      FLAG     = '$'
      FLAG(2:2)= NUMBER(NC1:NC1)
      FLAG(3:3)= NUMBER(NC2:NC2)
C
C     SEARCH FOR EXPLICIT PI DIRECTION FROM $XXPIDIR
C
      FLAG(4:8)='PIDIR'
      GPIDIR = .FALSE.
      CALL LOCTOR(IOENGI,FLAG,8,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*,END=101,ERR=101)(GRPIDIR(K),K=1,3)
      GPIDIR = .TRUE.
      GOTO 102
 101  CALL ABORT0('PIDIRERR  ')
 102  CONTINUE
      END IF
      FLAG(4:8)='PIVBO'
      CALL LOCTOR(IOENGI,FLAG,8,IOK,0)
C
C     IF FLAG DOES NOT EXIST, THEN IT DOES NOT MEAN THAT THIS IS NOT A PI GROUP.
C     IT MEANS IT DOES NOT REQUIRE PI GROUP SPECIFICATION (FOR INSTANCE
C     IN CH2=CH2, NO EXPLICIT PI GROUP INPUT IS NECESSARY
C
      IF(IOK.NE.1) THEN
C     WRITE(IOUTVB,*)'This is not a explicit PI group'
      GOTO 200
      END IF
      READ(IOENGI,*)NPIORB
      READ(IOENGI,*)(NPIA(J),J=1,NPIORB)
C     WRITE(IOUTVB,*)'BASNAME,NPIA = ',BASNAME,(NPIA(J),J=1,NPIORB)
C     WRITE(IOUTVB,*)'NAOST = ',(NAOST(NPIA(J)),J=1,NPIORB)
C
C     AUTOMATIC DETECTION OF PI DIRECTION FOR EACH ATOM IN THE PI GROUP
C     FIRST, SETUP THE PI DIRECTIONS FOR THE FIRST GROUP ATOMS
C
      DO J=1, NPIORB
      APIDIR(J) = .FALSE.
      NBONDS = NBONDALIST(1,NPIA(J))
      NAT1 = NPIA(J)
      NAT2 = 0
      NBTYPE = 2
      NBINDX   = 1
      CALL CVBOLAB(NAT1,NAT2,NBTYPE,NBINDX,ATEMP)
      NVBJ     = NB1ADD(MGRP)+J-1
      VBOLAB(NVBJ) = ATEMP(1:8)
      CALL ATOMPIDIR(NPIA(J),NBONDS,NBONDALIST(2,NPIA(J)),XYZ,
     &               APIDIR(J),ATMPIDIR(1,J))
      END DO
C
C     NOW, SETUP THE PI DIRECTIONS FOR SECOND GROUP ATOMS (APIDIR(J) is F
C
      DO J=1, NPIORB
      JA = NPIA(J)
      IF(.NOT.APIDIR(J)) THEN
      TDIS = 1.0D+04
        DO K=1, NPIORB
        KA = NPIA(K)
         DISJK = ATOMDIS(XYZ(1,JA),XYZ(1,KA))
         IF(APIDIR(K).AND.DISJK.LT.TDIS) THEN
           ATMPIDIR(1,J) = ATMPIDIR(1,K)
           ATMPIDIR(2,J) = ATMPIDIR(2,K)
           ATMPIDIR(3,J) = ATMPIDIR(3,K)
           APIDIR(J) = .TRUE.
         END IF
        END DO
      END IF
C
C     OVER WRITE THE AUTOMATIC PI DIR IF GPIDIR IS TRUE
C
      IF(GPIDIR) THEN
        ATMPIDIR(1,J) = GRPIDIR(1)
        ATMPIDIR(2,J) = GRPIDIR(2)
        ATMPIDIR(3,J) = GRPIDIR(3)
        APIDIR(J) = .TRUE.
      END IF
      IF(.NOT.APIDIR(J)) THEN
        WRITE(IOUTVB,*)'PI-Direction needs to be specified explicitly '
        WRITE(IOUTVB,*)'for this group'
        WRITE(IOUTVB,*)
     & 'Please see Manual for Input of Pi Orbital Direction'
        CALL ABORT0('APIDIRERR ')
      END IF
      END DO
C
C     INVERSE THE DIRECTION IF THE PRODUCT OF THE TWO VEC IS NEGATIVE
C
      DO J=2, NPIORB
      CALL DOTPROD(ATMPIDIR(1,J-1),ATMPIDIR(1,J),PROD)
      IF(PROD.LT.0.0D0) CALL VECINV(ATMPIDIR(1,J))
      END DO
C
C     NOW, ALL PI ATOMS HAVE PI DIRECTIONS
C
      DO J=1, NPIORB
      NATNUMPI = NATNUM(NPIA(J))
      NAOSTJ   = NAOST(NPIA(J))
      NVBJ     = NB1ADD(MGRP)+J-1
      NBONDS = NBONDALIST(1,NPIA(J))
C
C     PI VBO LOOK UP ROUTINE
C
      CALL LOOKPIVBO(NATNUMPI,NBONDS,FRGXYZ,FRGORB,FRGAOLB,NAFRAG,
     &               NAOFRG,IOLVBO,VBOLDIR)
C    &               NAOFRG,IOLVBO,BASNAME,VBOLDIR)
C
C       PREPARE THE POINTS
C
        PLANXYZ(1,1) = 0.0D0
        PLANXYZ(2,1) = 0.0D0
        PLANXYZ(3,1) = 0.0D0
        PLANXYZ(1,2) = ATMPIDIR(1,J)
        PLANXYZ(2,2) = ATMPIDIR(2,J)
        PLANXYZ(3,2) = ATMPIDIR(3,J)
        A(1) = ATMPIDIR(1,J)
        A(2) = ATMPIDIR(2,J)
        A(3) = ATMPIDIR(3,J)
        B(1) = VBOLDIR(1)
        B(2) = VBOLDIR(2)
        B(3) = VBOLDIR(3)
C
C       CROSS PRODUCT C = AxB
C
        PLANXYZ(1,3) = A(2)*B(3) - A(3)*B(2)
        PLANXYZ(2,3) = A(3)*B(1) - A(1)*B(3)
        PLANXYZ(3,3) = A(1)*B(2) - A(2)*B(1)
C
C       COPY FROM FRGORB TO V_NVBJ
C
          DO K=1, NBASIS
          V(K,NVBJ) = 0.0D0
          END DO
          DO K=1, NAOFRG
          V(NAOSTJ+K-1,NVBJ) = FRGORB(K)
C         WRITE(IOUTVB,*)'NAOSTJ,NVBJ,FRGORB =',NAOSTJ,NVBJ,FRGORB(K)
          ATEMP=FRGAOLB(K)
          BTEMP=BFLABE(NAOSTJ+K-1)
            IF(ATEMP(11:12).NE.BTEMP(11:12)) THEN
            WRITE(IOUTVB,*)'A,B =',ATEMP,BTEMP
            CALL ABORT0('LPIVBO01  ')
            END IF
          END DO
C
C       FIND THE ROTATION MATRIX, FIT FRG TO PLANXYZ
C
          FRGXYZ(1,1) = 0.0D0
          FRGXYZ(2,1) = 0.0D0
          FRGXYZ(3,1) = 0.0D0
          FRGXYZ(1,2) = VBOLDIR(1)
          FRGXYZ(2,2) = VBOLDIR(2)
          FRGXYZ(3,2) = VBOLDIR(3)
          FRGXYZ(1,3) = PLANXYZ(1,3)
          FRGXYZ(2,3) = PLANXYZ(2,3)
          FRGXYZ(3,3) = PLANXYZ(3,3)
          NAFRAG = 3
          DO L=1, NAFRAG
C         WRITE(IOUTVB,*)'PLAN=',(PLANXYZ(K,L),K=1,3)
C         WRITE(IOUTVB,*)'FRG =',(FRGXYZ(K,L),K=1,3)
          END DO
        CALL FITROT(PLANXYZ,FRGXYZ,NAFRAG,WT,RMAT)
C       WRITE(IOUTVB,*)'RMAT=',((RMAT(K,L),L=1,3),K=1,3)
C
C       TRANSFORMATION OF LIB VBO TO MOL VBO
C
C       WRITE(IOUTVB,*)'PI ORB A=',(V(K,NVBJ),K=1,NBASIS)
        CALL ORBTRN(NAOFRG,1,BFLABE(NAOSTJ),V(NAOSTJ,NVBJ),RMAT,
     &              V(NAOSTJ,NVBJ))
C       WRITE(IOUTVB,*)'PI ORB B=',(V(K,NVBJ),K=1,NBASIS)
C
C      DO LOOP OF PI ORBITALS (J)
C
       END DO
 200  CONTINUE
C
      END DO
      WRITE(IOUTVB,*)
C 900 FORMAT(/' PI-ORBITALS ($PIORB)'/1X,71(1H=))
C1000 FORMAT(' Pi-AO#: ',20I3)
C1100 FORMAT(' Group#: ',20I3)
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     FIND TRANSLATION MATRIX TRAN SO THAT
C     TRAN VA = VB
C     WHREE BOTH VA AND VB ARE 3D UNIT VECTORS
C
C     RETURN:
C             TRAN(3,3). THE TRANSLATION MATRIX
C             IERR. THE ERROR CODE. (0/1 = NO ERROR/ERROR)
C             VA, VB ARE NORMALIZED.
C
C     FIRST VERSION: OCT 25, 2003
C     AUTHOR: JIABO LI
C
C     SAN DIEGO
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE TRNV2V(VA,VB,TRAN,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION VA(3),VB(3),VC(3),TRAN(3,3)
      DIMENSION POINTA(3,3),POINTB(3,3),WT(3)
      IERR = 0
      DO I=1, 3
      WT(I) = 1.0D0
        DO J=1, 3
        TRAN(I,J) = 0.0D0
        END DO
        TRAN(I,I) = 1.0D0
      END DO
C
C     NORMALIZATION
C
      CALL VECNORM(VA,NOZERO)
      IF(NOZERO.EQ.0) THEN
      IERR = 1
      RETURN
      END IF
      CALL VECNORM(VB,NOZERO)
      IF(NOZERO.EQ.0) THEN
      IERR = 1
      RETURN
      END IF
C
C     CROSS PRODUCT VC = VAxVB
C
      CALL XPROD(VA,VB,VC)
      CALL VECNORM(VC,NOZERO)
      IF(NOZERO.EQ.0) THEN
      CALL DOTPROD(VA,VB,VAB)
        IF (VAB.LT.0.0D0) THEN
C
C       INVERSE THE UNIT MATRIX
C
        DO I = 1, 3
        TRAN(I,I) = -1.0D0
        END DO
        END IF
      RETURN
      END IF
C
C       PREPARE THE POINTS
C
      DO I=1, 3
      POINTA(I,1) = 0.0D0
      POINTB(I,1) = 0.0D0
      POINTA(I,2) = VC(I)
      POINTB(I,2) = VC(I)
      POINTA(I,3) = VA(I)
      POINTB(I,3) = VB(I)
      END DO
C
C     FIND THE ROTATION MATRIX TRAN, FIT POINTA TO POINTB
C
      NPOINTS = 3
      CALL FITROT(POINTB,POINTA,NPOINTS,WT,TRAN)
C
C     TRAN VA =
C
      CALL MATMUL2(3,3,1,TRAN,VA,VC)
      RETURN
      END
C
C     SCAN VBO NUMBERS FOR EACH VB GROUP
C
      SUBROUTINE SCANVBO(NSUB,MLORBIT)
C----------------------------------------------------------------------------
C     NSUB:     NUMBER OF GROUPS
C     MLORBIT:  ARRARY OF ORBITAL NUMBERS OF ALL GROUPS
C----------------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MAXTEM = 200)
      CHARACTER*80 NUMBER,FLAG
      CHARACTER*3 FUNIT(10)
C     character*20 BASNAME
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION MLORBIT(*),NCODE(5,MAXTEM),COEF(MAXTEM)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
C     CHECK IOLVBO
C
C     IF(IOLVBO.EQ.0) RETURN
      NUMBER   = '0123456789'
      CALL GETIOUNIT('IOENGI  ',IOENGI)
C
C     LOOP OVER EACH GROUP. IF $XXVBORB IS FOUND, THEN READ THE VBO CODE
C     AND THE CORRESPONDING COEFFICIENT
C
      DO I=1, NSUB
      MGRP     = I
      NC1      = 1+MGRP/10
      NC2      = 1+MGRP-10*(NC1-1)
      FLAG     = '$'
      FLAG(2:2)= NUMBER(NC1:NC1)
      FLAG(3:3)= NUMBER(NC2:NC2)
      FLAG(4:8)='VBORB'
      CALL LOCTOR(IOENGI,FLAG,8,IOK,0)
C
C     IF $XXVBORB IS FOUND, THEN READ THE VBO INSTRUCTIONS AND GENERATE VBO
C
      IF(IOK.NE.1) THEN
C     WRITE(IOUTVB,*)'NO VBOLIB INPUT FOR THIS GROUP'
      GOTO 200
      END IF
      CALL VBOCODE(IOENGI,NVBO,NCODE,COEF,NTTMS,MAXTEM)
      IF(MLORBIT(I).LE.NVBO) THEN
      MLORBIT(I) = NVBO
      ELSE
      WRITE(IOUTVB,*)"MLORBIT,NVBO = ",MLORBIT(I),NVBO
      WRITE(IOUTVB,*)"VBO ENTRES FOR GROUP ",I," IS NOT ENOUGH"
      CALL ABORT0("SCANEVBO01")
      ENDIF
 200  CONTINUE
C
C     DO LOOP OF VBO GROUPS (I)
C
      END DO
      RETURN
      END
C     SUBROUTINE VBOLIB(NDIM,V,NB1ADD,IOLVBO,NBONDALIST,NSUB,BONDLAB,
C    &                  LMOLAB,VBOLAB)
      SUBROUTINE VBOLIB(V,NB1ADD,IOLVBO,NSUB,VBOLAB)
C----------------------------------------------------------------------------
C     V:        VB ORBITALS
C     NDIM:     DIMENSION OF MO
C     NB1ADD:   STARTING INDEXES OF ORBITALS OF SUBUNITS
C----------------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 NUMBER,FLAG
C     CHARACTER*8  BONDLAB(*),VBOLAB(*)
      CHARACTER*8  VBOLAB(*)
C     CHARACTER*12 FRGAOLB,ATEMP,BTEMP,BFLABE
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      PARAMETER (MAXTEM = 200)
C
C     TODO: ADD CHECK FORWT, FRGAOLB ETC FOR NEXT RELEASE
C
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
C     DIMENSION V(NBASIS,*),NB1ADD(*),NWA(100)
      DIMENSION V(NBASIS,*),NB1ADD(*)
C     DIMENSION NPIA(100),DIRECTION(3),NAOST(1000),FRGORB(100)
      DIMENSION NAOST(1000)
C     DIMENSION FRGXYZ(3,20),FRGAOLB(100),PLANXYZ(3,20),A(3),B(3)
C     DIMENSION RMAT(3,3),WT(100),OLDIR(3),NBONDALIST(10,*)
C     DIMENSION NCODE(5,MAXTEM),COEF(MAXTEM),LMOLAB(2,*)
      DIMENSION NCODE(5,MAXTEM),COEF(MAXTEM)
C
C     CHECK IOLVBO
C
C     IF(IOLVBO.EQ.0) RETURN
      NUMBER   = '0123456789'
      CALL GETIOUNIT('IOENGI  ',IOENGI)
C     DO 100 I=1,99
C     WT(I) = 1.0D0
C100  NWA(I)=NB1ADD(I)
C     WT & NWA are not used.
      NAOST(1) = 1
      DO I=1,NATOM
      NAOST(I+1) = NAOST(I) + NATBAS(I)
      END DO
C
C     LOOP OVER EACH GROUP. IF $XXVBORB IS FOUND, THEN READ THE VBO CODE
C     AND THE CORRESPONDING COEFFICIENT
C
      DO I=1, NSUB
      MGRP     = I
      NC1      = 1+MGRP/10
      NC2      = 1+MGRP-10*(NC1-1)
      FLAG     = '$'
      FLAG(2:2)= NUMBER(NC1:NC1)
      FLAG(3:3)= NUMBER(NC2:NC2)
      FLAG(4:8)='VBORB'
      CALL LOCTOR(IOENGI,FLAG,8,IOK,0)
C
C     IF $XXVBORB IS FOUND, THEN READ THE VBO INSTRUCTIONS AND GENERATE VBO
C
      IF(IOK.NE.1) THEN
C     WRITE(IOUTVB,*)'NO VBOLIB INPUT FOR THIS GROUP'
      GOTO 200
      END IF
      CALL VBOCODE(IOENGI,NVBO,NCODE,COEF,NTTMS, MAXTEM)
C
C     LIST VBO CODE
C
        DO J=1, NTTMS
C       WRITE(IOUTVB,*)'VBO CODE:',COEF(J),(NCODE(K,J),K=1,5)
        END DO
      NVBOST = NB1ADD(I)
      CALL VBOGEN(NVBO,NCODE,COEF,NTTMS,NBASIS,V(1,NVBOST),
     &            VBOLAB(NVBOST),IOLVBO,NATBAS,BFLABE)
 200  CONTINUE
C
C     DO LOOP OF VBO GROUPS (I)
C
      END DO
      DO I=1, 7
        DO K=1, NBASIS
C       WRITE(IOUTVB,'(I5,F10.5)')K, V(K,I)
        END DO
      END DO
      RETURN
      END
      SUBROUTINE VBOCODE(IOENGI,NVBO,NVBOCODE,COEF,NTTMS, MAXTEM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 VBOSTRING,BLANK
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION NVBOCODE(5,*),COEF(*)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      BLANK(1:40)  = '                                        '
      BLANK(41:80) = '                                        '
      IDXVBO = 0
      NTTMS  = 0
 100  READ(IOENGI,1000,END=200,ERR=200)VBOSTRING
      IF(VBOSTRING.EQ.BLANK) GOTO 200
      IF(NTTMS.GE.MAXTEM) CALL ABORT0("VBOCODE0001")
      LSTRING = 80
      CALL VBOPARSER(VBOSTRING,LSTRING,NTERMS,NVBOCODE(1,NTTMS+1),
     &              COEF(NTTMS+1),IDXVBO,IERR)
      IF(IERR.EQ.1) THEN
        WRITE(IOUTVB,*)"SYNTAX ERROR IN THIS VBORB SPECIFICATION"
        WRITE(IOUTVB,*)VBOSTRING
        CALL ABORT0('VBOCODE01 ')
      END IF
      NTTMS = NTTMS + NTERMS
      GOTO 100
 200  CONTINUE
 1000 FORMAT(A80)
      NVBO = IDXVBO
      DO I=1, NTTMS
C     WRITE(IOUTVB,*)'I, NVBOCODE=', I, (NVBOCODE(J,I),J=1, 5), COEF(I)
      END DO
      RETURN
      END
      SUBROUTINE VBOGEN(NVBO,NCODE,COEF,NTTMS,NBASIS,V,VBOLAB,
     &                  IOLVBO,NATBAS,BFLABE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*8 VBOLAB(*)
      CHARACTER*8 BONDLAB
      CHARACTER*12 AOLABEL,ATEMP,BTEMP,BFLABE(*)
C     CHARACTER*20 BASNAME
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION NCODE(5,*),COEF(*),V(NBASIS,*),VTMP(1000),VBODIR(3)
      DIMENSION SIGMAVBO(1000),AOLABEL(1000),NATBAS(*),NAOST(1000)
      DIMENSION RMAT(3,3),VBOLDIR(3),PIVBDIR(3),PLVBDIR(3)
      COMMON /LMODAT/VMO(500000),VLMO(500000),LMOLAB(2,1000),
     &LMOATM(5,1000),PGM(100000),ENGLMO(1000),BONDLAB(1000),MCLMO(5,80),
     &LHFLAG
      COMMON /MTOPOL/XYZMOL(3,1000),NATOMS,NATNNU(1001),
     &               NBONDALIST(10,1000),NBONDTYPE(10,1000)
C     LOGICAL APIDIR
C
C     IF LIB DOES NOT EXIST, DO NOTHING UNLESS FOR LMO(X) AND AO(X)
C
C     IF(IOLVBO.EQ.0) RETURN
C
C     GENERATE NVBO ORBITALS AND STORE IN V.
C
C     FIRST, ZERO V
C
      DO I=1, NVBO
        DO J=1, NBASIS
        V(J,I) = 0.0D0
        END DO
      END DO
C
C     SETUP AO STARTING INDEXES
C
      NAOST(1) = 1
      DO I=1, NATOMS
      NAOST(I+1) = NAOST(I) + NATBAS(I)
      END DO
C
C     LOOP OVER ALL TERMS IN VBO CODE
C
      NVBOLD = 0
      DO I=1, NTTMS
C
C     DECODE
C
      NATOM1 = NCODE(1,I)
      NATOM2 = NCODE(2,I)
      NBTYPE = NCODE(3,I)
      NBINDX = NCODE(4,I)
      NVBODX = NCODE(5,I)
      IF(IOLVBO.EQ.0.AND.(NBTYPE.NE.7.AND.NBTYPE.NE.10))
     &               CALL ABORT0("VBOGEN0001")
      CALL CVBOLAB(NATOM1,NATOM2,NBTYPE,NBINDX,ATEMP)
      IF(NVBODX.NE.NVBOLD) THEN
      NVBOLD = NVBODX
      VBOLAB(NVBODX) = ATEMP(1:8)
      ELSE
      VBOLAB(NVBODX) = 'MC-ORBIT'
      END IF
      IF(NBTYPE.EQ.1) THEN
C
C     THIS IS A SIGMA BOND, NA1,NA2 ARE ALL NON-ZERO!
C     ERROR CHECK FIRST!
C
      IF (NATOM1.EQ.0.OR.NATOM2.EQ.0) CALL ABORT0('VBOGEN01  ')
      CALL SIGMADIR(NATOM1,NATOM2,VBODIR)
C
C     LOOK UP SIGMA VBO ON NATOM1 POINTING TO NATOM2
C
      NATNUM = NATNNU(NATOM1)
      NBONDS = NBONDALIST(1,NATOM1)
      NAOSTI = NAOST(NATOM1)
      CALL LOOKSIGMA(NATNUM,NBONDS,VBOLDIR,SIGMAVBO,AOLABEL,NAOFRG,
     &               IOLVBO,IERR)
C
C     FIND TRAN MATRIX RMAT, WHICH TRANSLATE VBOLDIR TO VBODIR,
C     I.E. RMAT VBOLDIR = VBODIR
C
      CALL TRNV2V(VBOLDIR,VBODIR,RMAT,IERR)
      IF(IERR.EQ.1) CALL ABORT0('VBOGEN03  ')
C
C     COPY FROM SIGMAVBO TO VTEMP
C
      DO K=1, NBASIS
      VTMP(K) = 0.0D0
      END DO
      DO K=1, NAOFRG
      VTMP(NAOSTI+K-1) = SIGMAVBO(K)
      ATEMP = AOLABEL(K)
      BTEMP = BFLABE(NAOSTI+K-1)
        IF(ATEMP(11:12).NE.BTEMP(11:12)) CALL ABORT0('VBOGEN04A ')
      END DO
C
C     TRANSLATE LIB VBO TO MOL VBO
C
      CALL ORBTRN(NAOFRG,1,BFLABE(NAOSTI),VTMP(NAOSTI),RMAT,
     &            VTMP(NAOSTI))
C
C     NOW, ADD VTMP TO V WITH WEIGHT COEFF(I)
C
      DO K=1, NBASIS
      V(K,NVBODX) = V(K,NVBODX) + COEF(I)*VTMP(K)
      END DO
C
C     END OF IF BLOCK OF SIGMA BONDING VBO
C
      ELSE IF(NBTYPE.EQ.2) THEN
C
C     THIS IS A PI BONDING VBO, NA1 IS NON-ZERO!
C     ERROR CHECK FIRST!
C
      IF (NATOM1.LE.0) CALL ABORT0('VBOGEN04B ')
      IDXPI  = NBINDX
      NATNUM = NATNNU(NATOM1)
      NBONDS = NBONDALIST(1,NATOM1)
      NAOSTI = NAOST(NATOM1)
C
C     FIND THE LARGEST ATOM OF NATOM1's NEIGHBOR
C
      CALL FINDBPT(NBONDS,NBONDALIST(2,NATOM1),NATNNU,NATBPT)
C
C     FIND THE IDXPI DIRECTION
C
      CALL PIBDIR(NATOM1,NATBPT,IDXPI,PIVBDIR,IERR)
      IF(IERR.EQ.1) CALL ABORT0('GENPIVBO01')
C
C     LOOK UP THE IDXPI-th PI VBO ON NATOM1
C
      CALL LOOKPI(NATNUM,NBONDS,VBOLDIR,SIGMAVBO,AOLABEL,NAOFRG,IOLVBO)
C
C     FIND TRAN MATRIX RMAT, WHICH TRANSLATE VBOLDIR TO VBODIR,
C     I.E. RMAT VBOLDIR = VBODIR
C
      CALL TRNV2V(VBOLDIR,PIVBDIR,RMAT,IERR)
      IF(IERR.EQ.1) CALL ABORT0('VBOGEN03  ')
C
C     COPY FROM SIGMAVBO TO VTEMP
C
      DO K=1, NBASIS
      VTMP(K) = 0.0D0
      END DO
      DO K=1, NAOFRG
      VTMP(NAOSTI+K-1) = SIGMAVBO(K)
      ATEMP = AOLABEL(K)
      BTEMP = BFLABE(NAOSTI+K-1)
        IF(ATEMP(11:12).NE.BTEMP(11:12)) CALL ABORT0('VBOGEN04C ')
      END DO
C
C     TRANSLATE LIB VBO TO MOL VBO
C
      CALL ORBTRN(NAOFRG,1,BFLABE(NAOSTI),VTMP(NAOSTI),RMAT,
     &            VTMP(NAOSTI))
C
C     NOW, ADD VTMP TO V WITH WEIGHT COEFF(I)
C
      DO K=1, NBASIS
      V(K,NVBODX) = V(K,NVBODX) + COEF(I)*VTMP(K)
      END DO
C     END OF IF BLOCK OF PI BONDING VBO
      ELSE IF(NBTYPE.EQ.3) THEN
C
C     LONE PAIR VBO
C
      LPDEX  = NBINDX
      NATNUM = NATNNU(NATOM1)
      NBONDS = NBONDALIST(1,NATOM1)
      NAOSTI = NAOST(NATOM1)
      CALL LPDIR(NATOM1,LPDEX,PLVBDIR,LPTYPE,IERR)
      IF(IERR.EQ.1) CALL ABORT0('NOLPDIR   ')
      CALL LOOKLP(NATNUM,VBOLDIR,SIGMAVBO,AOLABEL,NAOFRG,
     &               LPTYPE,IOLVBO)
C
C     FIND THE LP DIR IN THE MOL
C
C     CALL LPDIR(NATOM1,LPDEX,PLVBDIR,LPTYPE,IERR)
C
C     FIND TRAN MATRIX RMAT, WHICH TRANSLATE VBOLDIR TO PLVBDIR,
C     I.E. RMAT VBOLDIR = PLVBDIR
C
      CALL TRNV2V(VBOLDIR,PLVBDIR,RMAT,IERR)
      IF(IERR.EQ.1) CALL ABORT0('VBOGEN05  ')
C
C     COPY FROM SIGMAVBO TO VTEMP
C
      DO K=1, NBASIS
      VTMP(K) = 0.0D0
      END DO
      DO K=1, NAOFRG
      VTMP(NAOSTI+K-1) = SIGMAVBO(K)
      ATEMP = AOLABEL(K)
      BTEMP = BFLABE(NAOSTI+K-1)
        IF(ATEMP(11:12).NE.BTEMP(11:12)) CALL ABORT0('VBOGEN06  ')
      END DO
C
C     TRANSLATE LIB VBO TO MOL VBO
C
      CALL ORBTRN(NAOFRG,1,BFLABE(NAOSTI),VTMP(NAOSTI),RMAT,
     &            VTMP(NAOSTI))
C
C     NOW, ADD VTMP TO V WITH WEIGHT COEFF(I)
C
      DO K=1, NBASIS
      V(K,NVBODX) = V(K,NVBODX) + COEF(I)*VTMP(K)
C     WRITE(IOUTVB,*)'V(K) =',K,V(K,NVBODX)
      END DO
C     END OF IF BLOCK OF LP BONDING VBO
C
      ELSE IF(NBTYPE.EQ.4) THEN
      WRITE(IOUTVB,*)'LMO AS A DOUBLE ELECTRON VBO'
      ELSE IF(NBTYPE.EQ.7) THEN
C       NBINDX: LMO index
        MMX = (NBINDX-1)*NBASIS
        DO K=1, NBASIS
        V(K,NVBODX) = V(K,NVBODX) + COEF(I)*VLMO(K+MMX)
        END DO
        VBOLAB(NVBODX) = "LMO TYPE"
      ELSE IF(NBTYPE.EQ.11) THEN
C       NBINDX: MO index
        MMX = (NBINDX-1)*NBASIS
        DO K=1, NBASIS
        V(K,NVBODX) = V(K,NVBODX) + COEF(I)*VMO(K+MMX)
        END DO
        VBOLAB(NVBODX) = "MO TYPE"
      ELSE IF(NBTYPE.EQ.10) THEN
C       NBINDX: AO index
        V(NBINDX,NVBODX) = V(NBINDX,NVBODX) + COEF(I)
        VBOLAB(NVBODX) = "AO TYPE"
      ELSE IF(NBTYPE.EQ.8) THEN
C
C     THIS IS A DIRECTIONAL PI BONDING VBO, NA1 AND NA2 ARE NON-ZERO!
C     ERROR CHECK FIRST!
C
      IF (NATOM1.LE.0.OR.NATOM2.LE.0) CALL ABORT0('VBOGEN03  ')
      IDXPI  = NBINDX
      NATNUM = NATNNU(NATOM1)
      NBONDS = NBONDALIST(1,NATOM1)
      NAOSTI = NAOST(NATOM1)
C
C     FIND THE VECTOR NATOM1->NATOM2
C
      CALL SIGMADIR(NATOM1,NATOM2,PIVBDIR)
C
C     LOOK UP THE DIRECTIONAL  PI VBO ON NATOM1 POINTING TO NATOM2
C
      CALL LOOKPI(NATNUM,NBONDS,VBOLDIR,SIGMAVBO,AOLABEL,NAOFRG,IOLVBO)
C
C     FIND TRAN MATRIX RMAT, WHICH TRANSLATE VBOLDIR TO VBODIR,
C     I.E. RMAT VBOLDIR = VBODIR
C
      CALL TRNV2V(VBOLDIR,PIVBDIR,RMAT,IERR)
      IF(IERR.EQ.1) CALL ABORT0('VBOGEN05  ')
C
C     COPY FROM SIGMAVBO TO VTEMP
C
      DO K=1, NBASIS
      VTMP(K) = 0.0D0
      END DO
      DO K=1, NAOFRG
      VTMP(NAOSTI+K-1) = SIGMAVBO(K)
      ATEMP = AOLABEL(K)
      BTEMP = BFLABE(NAOSTI+K-1)
        IF(ATEMP(11:12).NE.BTEMP(11:12)) CALL ABORT0('VBOGEN06  ')
      END DO
C
C     TRANSLATE LIB VBO TO MOL VBO
C
      CALL ORBTRN(NAOFRG,1,BFLABE(NAOSTI),VTMP(NAOSTI),RMAT,
     &            VTMP(NAOSTI))
C
C     NOW, ADD VTMP TO V WITH WEIGHT COEFF(I)
C
      DO K=1, NBASIS
      V(K,NVBODX) = V(K,NVBODX) + COEF(I)*VTMP(K)
      END DO
C     END OF IF BLOCK OF DIRECTIONAL PI BONDING VBO
      ELSE
      WRITE(IOUTVB,101)
 101  FORMAT('DO NOT KNOW HOW TO GENERATE VBO FOR THIS TYPE')
      WRITE(IOUTVB,102) NBTYPE
 102  FORMAT('NBTYPE = ',I4)
      END IF
C     END OF LOOP OVER I/NTTMS
      END DO
      RETURN
      END
C
C     NBTYPE=1,2,3 (SIGMA, 1st PI and 2nd PI)
C
      SUBROUTINE AVBOGEN(NATOM1,NATOM2,NBTYPE,V,VBODIR,IOLVBO,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 AOLABEL,ATEMP,BTEMP,BFLABE
      CHARACTER*20 BASNAME
C     CHARACTER*8 BONDLAB
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     DIMENSION V(NBASIS),VTMP(1000),VBODIR(3)
      DIMENSION V(NBASIS),VBODIR(3)
      DIMENSION SIGMAVBO(1000),AOLABEL(1000),NAOST(1000)
      DIMENSION RMAT(3,3),VBOLDIR(3)
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
C     COMMON /LMODAT/VMO(500000),VLMO(500000),LMOLAB(2,1000),
C    &LMOATM(5,1000),PGM(100000),ENGLMO(1000),BONDLAB(1000),MCLMO(5,80),
C    &LHFLAG
      COMMON /MTOPOL/XYZMOL(3,1000),NATOMS,NATNNU(1001),
     &               NBONDALIST(10,1000),NBONDTYPE(10,1000)
C     LOGICAL APIDIR
C
C     IF(IOLVBO.EQ.0), DO NOTHING
C
      IF(IOLVBO.EQ.0) RETURN
C     APIDIR = .FALSE.
      IERR = 0
C
C     FIRST, ZERO V
C
      DO J=1, NBASIS
      V(J) = 0.0D0
      END DO
C
C     SETUP AO STARTING INDEXES
C
      NAOST(1) = 1
      DO I=1, NATOMS
      NAOST(I+1) = NAOST(I) + NATBAS(I)
      END DO
      IF(NBTYPE.EQ.1) THEN
C
C     THIS IS A SIGMA BOND, NA1,NA2 ARE ALL NON-ZERO!
C     ERROR CHECK FIRST!
C
      IF (NATOM1.LE.0.OR.NATOM2.LE.0) CALL ABORT0('VBOGEN01  ')
      CALL SIGMADIR(NATOM1,NATOM2,VBODIR)
C
C     LOOK UP SIGMA VBO ON NATOM1 POINTING TO NATOM2
C
      NATNUC = NATNNU(NATOM1)
      NBONDS = NBONDALIST(1,NATOM1)
      NAOSTI = NAOST(NATOM1)
      CALL LOOKSIGMA(NATNUC,NBONDS,VBOLDIR,SIGMAVBO,AOLABEL,NAOFRG,
     &               IOLVBO,IERR)
C
C     FIND TRAN MATRIX RMAT, WHICH TRANSLATE VBOLDIR TO VBODIR,
C     I.E. RMAT VBOLDIR = VBODIR
C
      CALL TRNV2V(VBOLDIR,VBODIR,RMAT,IERR)
      IF(IERR.EQ.1) CALL ABORT0('VBOGEN03  ')
      DO K=1, NAOFRG
      V(NAOSTI+K-1) = SIGMAVBO(K)
      ATEMP = AOLABEL(K)
      BTEMP = BFLABE(NAOSTI+K-1)
        IF(ATEMP(11:12).NE.BTEMP(11:12)) CALL ABORT0('VBOGEN02X ')
      END DO
C
C     TRANSLATE LIB VBO TO MOL VBO
C
      CALL ORBTRN(NAOFRG,1,BFLABE(NAOSTI),V(NAOSTI),RMAT,V(NAOSTI))
C
C     END OF IF BLOCK OF SIGMA BONDING VBO
C
      ELSE IF(NBTYPE.EQ.2.OR.NBTYPE.EQ.3) THEN
C
C     THIS IS A PI BONDING VBO, NA1 IS NON-ZERO!
C     ERROR CHECK FIRST!
C
      IF (NATOM1.LE.0) CALL ABORT0('VBOGEN04D ')
      IDXPI  = NBTYPE-1
      NATNUC = NATNNU(NATOM1)
      NBONDS = NBONDALIST(1,NATOM1)
      NAOSTI = NAOST(NATOM1)
C
C     FIND THE IDXPI DIRECTION
C
      CALL PIBDIR(NATOM1,NATOM2,IDXPI,VBODIR,IERR)
      IF(IERR.EQ.1) CALL ABORT0('GENPIVBO01')
C
C     LOOK UP THE IDXPI-th PI VBO ON NATOM1
C
      CALL LOOKPI(NATNUC,NBONDS,VBOLDIR,SIGMAVBO,AOLABEL,NAOFRG,IOLVBO)
C
C     FIND TRAN MATRIX RMAT, WHICH TRANSLATE VBOLDIR TO VBODIR,
C     I.E. RMAT VBOLDIR = VBODIR
C
      CALL TRNV2V(VBOLDIR,VBODIR,RMAT,IERR)
      IF(IERR.EQ.1) CALL ABORT0('VBOGEN03  ')
      DO K=1, NAOFRG
      V(NAOSTI+K-1) = SIGMAVBO(K)
      ATEMP = AOLABEL(K)
      BTEMP = BFLABE(NAOSTI+K-1)
        IF(ATEMP(11:12).NE.BTEMP(11:12)) CALL ABORT0('VBOGEN04E ')
      END DO
C
C     TRANSLATE LIB VBO TO MOL VBO
C
      CALL ORBTRN(NAOFRG,1,BFLABE(NAOSTI),V(NAOSTI),RMAT,V(NAOSTI))
C     END OF IF BLOCK OF PI BONDING VBO
      ELSE IF(NBTYPE.GE.3) THEN
      WRITE(IOUTVB,*)'YOU COME HERE MAYBE DUE TO ERROR!'
      WRITE(IOUTVB,*)'NBTYPE = ', NBTYPE
      END IF
      RETURN
      END
      SUBROUTINE FINDBPT(NBONDS,NBONDALIST,NATNNU,NATBPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NBONDALIST(*),NATNNU(*)
      NATBPT = 0
      IF(NBONDS.LE.0) RETURN
      NATBPT = NBONDALIST(1)
      NATNU  = NATNNU(NATBPT)
      DO I=1, NBONDS
      IF(NATNNU(NBONDALIST(I)).GT.NATNU) THEN
         NATBPT = NBONDALIST(I)
         NATNU = NATNNU(NATBPT)
      END IF
      END DO
      RETURN
      END
      DOUBLE PRECISION FUNCTION ATOMDIS(A,B)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(3),B(3)
      ATOMDIS = DSQRT((A(1)-B(1))**2+(A(2)-B(2))**2+(A(3)-B(3))**2)
      RETURN
      END
      SUBROUTINE INIMOLTOPOL()
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      COMMON /MTOPOL/XYZMOL(3,1000),NATOMS,NATNNU(1001),
     &               NBONDALIST(10,1000),NBONDTYPE(10,1000)
      NATOMS = NATOM
      DO I=1, NATOMS
      NATNNU(I) = NATNUM(I)
        DO J=1, 3
        XYZMOL(J,I) = XYZ(J,I)
        END DO
      END DO
      CALL FINDNB(NATOMS,NATNNU,XYZMOL,NBONDALIST,NBONDTYPE)
      DO I=1, NATOMS
        DO J=1, NBONDALIST(1,I)
C       WRITE(IOUTVB,*)'I,NBA,NBTYPE =',I,NBONDALIST(J+1,I),NBONDTYPE(J+1,I)
        END DO
      END DO
C
C     TOPOL INFO CAN BE LOADED EXPLICITLY (FOR INSTANCE FROM A SD FILE
C
C     TO DO:
C     ALSO DO SOME SANITIZING CHECK USING SIMPLE RULES AND MAKE CORRECTIONS
C
      RETURN
      END
C
C     FIND THE SIGMA VBO OF NATCNT POINTING TO NATBPT
C
      SUBROUTINE SIGMADIR(NATCNT,NATBPT,VBDIR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION VBDIR(3)
      COMMON /MTOPOL/XYZMOL(3,1000),NATOMS,NATNNU(1001),
     &               NBONDALIST(10,1000),NBONDTYPE(10,1000)
      VBDIR(1) = XYZMOL(1,NATBPT) - XYZMOL(1,NATCNT)
      VBDIR(2) = XYZMOL(2,NATBPT) - XYZMOL(2,NATCNT)
      VBDIR(3) = XYZMOL(3,NATBPT) - XYZMOL(3,NATCNT)
      CALL VECNORM(VBDIR,IFLAG)
      RETURN
      END
C
C     FIND THE PI VBO OF NATCNT BONDING TO NATBPT
C
      SUBROUTINE PIBDIR(NATCNT,NATBPT,IDXPI,PIVBDIR,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION PIVBDIR(3),SGMDIR(3),TMPDIR(3),NBLIST(10)
      DIMENSION XAXIS(3),YAXIS(3),ZAXIS(3),PIXDIR(3),PIYDIR(3)
      LOGICAL APIDIR
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /MTOPOL/XYZMOL(3,1000),NATOMS,NATNNU(1001),
     &               NBONDALIST(10,1000),NBONDTYPE(10,1000)
      DATA XAXIS,YAXIS,ZAXIS/1.0D0,0.0D0,0.0D0,0.0D0,1.0D0,0.0D0,
     &                       0.0D0,0.0D0,1.0D0/
C
C     SIMPLE CASE: IDXPI = 1, AND NATCNT IS A SP2 ATOM
C
      APIDIR = .FALSE.
      IF(NATCNT.EQ.0.OR.NATBPT.EQ.0) CALL ABORT0('PIBDIR00  ')
      NBONDS = NBONDALIST(1,NATCNT)
      CALL ATOMPIDIR(NATCNT,NBONDS,NBONDALIST(2,NATCNT),XYZMOL,
     &               APIDIR,PIVBDIR)
      IF(IDXPI.EQ.1.AND.APIDIR) THEN
        IERR = 0
        RETURN
      END IF
C
C     CHECK FIRST NEIGHBOR
C
      NBONDS = NBONDALIST(1,NATBPT)
      CALL ATOMPIDIR(NATBPT,NBONDS,NBONDALIST(2,NATBPT),XYZMOL,
     &               APIDIR,PIVBDIR)
      IF(IDXPI.EQ.1.AND.APIDIR) THEN
        IERR = 0
        RETURN
      END IF
      IF(IDXPI.GT.1.AND.APIDIR) THEN
        IERR = 1
        WRITE(IOUTVB,*)'IT SEEMS ONLY ONE PI ORBITAL ON THIS ATOM !!!'
        CALL ABORT0('PIBDIR01  ')
        RETURN
      END IF
C
C     NOW, HANDLE CASE ATOMPIDIR CAN NOT DEFINED BY THE CENTER ATOM ITSELF
C     USUALLY, THIS MEANS THAT THIS IS A TRIPLE BOND ATOM
C
C     FIND NATCNT AND NATBPT's NEIGBOR, AND AND OF THEY NEIGHBOR IS A CONJUGATE
C     ATOM, USE THAT ONE AS THE FIRST VBPIDIR
C
      NNB = 0
      DO I=1, NBONDALIST(1,NATCNT)
      IF(NBONDALIST(I+1,NATCNT).NE.NATBPT) THEN
        NNB = NNB + 1
        NBLIST(NNB) = NBONDALIST(I+1,NATCNT)
      END IF
      END DO
      DO I=1, NBONDALIST(1,NATBPT)
      IF(NBONDALIST(I+1,NATBPT).NE.NATCNT) THEN
        NNB = NNB + 1
        NBLIST(NNB) = NBONDALIST(I+1,NATBPT)
      END IF
      END DO
C
      DO I=1, NNB
      IAT = NBLIST(I)
      NBONDS = NBONDALIST(1,IAT)
      CALL ATOMPIDIR(IAT,NBONDS,NBONDALIST(2,IAT),XYZMOL,
     &               APIDIR,PIVBDIR)
      IF (APIDIR) GOTO 100
      END DO
 100  CONTINUE
      IF(APIDIR) THEN
C
C     USE PIVBDIR AND NATCNT-NATBPT VECTOR TO DEFINE THE THIRD ONE
C
      IF(IDXPI.EQ.1) RETURN
      IF(NATBPT.LE.0) CALL ABORT0('PIBDIR02  ')
      CALL SIGMADIR(NATCNT,NATBPT,SGMDIR)
      CALL XPROD(SGMDIR,PIVBDIR,TMPDIR)
        IF(IDXPI.EQ.2) THEN
          PIVBDIR(1) = TMPDIR(1)
          PIVBDIR(2) = TMPDIR(2)
          PIVBDIR(3) = TMPDIR(3)
          RETURN
        ELSE
        CALL ABORT0('PIBDIR03  ')
        END IF
      ELSE
C
C     USE THE ORIENTATION OF NATCNT-NATBPT ONLY TO DEFINE
C
C     FIND THE SMALLEST ANGLE WITH X,Y,Z AXIS
C
      CALL SIGMADIR(NATCNT,NATBPT,SGMDIR)
C     WRITE(IOUTVB,*)'USE ORIENTATION TO BUILD PI DIR'
C     WRITE(IOUTVB,*)'SGMDIR =',(SGMDIR(K),K=1,3)
C     WRITE(IOUTVB,*)'XAXIS  =',(XAXIS(K),K=1,3)
      CALL DOTPROD(XAXIS,SGMDIR,XBDIR)
      CALL DOTPROD(YAXIS,SGMDIR,YBDIR)
      CALL DOTPROD(ZAXIS,SGMDIR,ZBDIR)
      AXBDIR = DABS(XBDIR)
      AYBDIR = DABS(YBDIR)
      AZBDIR = DABS(ZBDIR)
C     WRITE(IOUTVB,*)'AXYZ=',AXBDIR,AYBDIR,AZBDIR
C
C     AZBDIR is the largest
C
      IF(AZBDIR.GE.AXBDIR.AND.AZBDIR.GE.AYBDIR) THEN
C
C     PIXDIR = XAXIS - XBDIR*SGMDIR
C
        DO I=1, 3
        PIXDIR(I) = XAXIS(I) - XBDIR*SGMDIR(I)
        END DO
C     WRITE(IOUTVB,*)'PIXDIR  =',(PIXDIR(K),K=1,3)
C
C     PIYDIR = SGMDIR X PIXDIR
C
      CALL XPROD(SGMDIR,PIXDIR,PIYDIR)

      CALL VECNORM(PIXDIR,IFLAG)
      CALL VECNORM(PIYDIR,IFLAG)
C
C     MAKE SURE THAT THE TWO C#C CARBONS HAVE THE SAME PIYDIR
C
      CALL DOTPROD(YAXIS,PIYDIR,YPIYDIR)
      IF(YPIYDIR.LT.0.0D0) CALL VECINV(PIYDIR)
      ELSE IF (AXBDIR.GE.AYBDIR.AND.AXBDIR.GT.AZBDIR) THEN
C
C     PIXDIR = YAXIS - YBDIR*SGMDIR
C
        DO I=1, 3
        PIXDIR(I) = YAXIS(I) - YBDIR*SGMDIR(I)
        END DO
C
C     PIYDIR = SGMDIR X PIXDIR
C
      CALL XPROD(SGMDIR,PIXDIR,PIYDIR)

      CALL VECNORM(PIXDIR,IFLAG)
      CALL VECNORM(PIYDIR,IFLAG)
C
C     MAKE SURE THAT THE TWO C#C CARBONS HAVE THE SAME PIYDIR
C
      CALL DOTPROD(ZAXIS,PIYDIR,ZPIYDIR)
      IF(ZPIYDIR.LT.0.0D0) CALL VECINV(PIYDIR)
      ELSE
C
C     PIXDIR = ZAXIS - ZBDIR*SGMDIR
C
        DO I=1, 3
        PIXDIR(I) = ZAXIS(I) - ZBDIR*SGMDIR(I)
        END DO
C
C     PIYDIR = SGMDIR X PIXDIR
C
      CALL XPROD(SGMDIR,PIXDIR,PIYDIR)
      CALL VECNORM(PIXDIR,IFLAG)
      CALL VECNORM(PIYDIR,IFLAG)
C
C     MAKE SURE THAT THE TWO C#C CARBONS HAVE THE SAME PIYDIR
C
      CALL DOTPROD(XAXIS,PIYDIR,XPIYDIR)
      IF(XPIYDIR.LT.0.0D0) CALL VECINV(PIYDIR)
      END IF
      END IF
C
C     COPY PIDIR TO PIVBDIR
C
      IF(IDXPI.EQ.1) THEN
        DO I=1, 3
        PIVBDIR(I) = PIXDIR(I)
        END DO
      ELSE IF(IDXPI.EQ.2) THEN
        DO I=1, 3
        PIVBDIR(I) = PIYDIR(I)
        END DO
      ELSE
        WRITE(IOUTVB,*)'UNKNOWN PI DIR, STOP'
        CALL ABORT0('PIBDIR04  ')
      END IF
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     FIND THE LONE PAIR VBO OF ATOM NATCNT
C     NATCNT:  ATOM INDEX
C     LPDEX:   THE INDEX OF LP (1,2,3)
C     PLVBDIR: LP DIRECTION
C     IERR:    ERROR CODE 1/0 (ERR/NO-ERR)
C
C     FIRST CREATED: OCT. 4, 2003
C
C     AUTHOR: Jiabo LI
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE LPDIR(NATCNT,LPDEX,PLVBDIR,LPTYP,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION PLVBDIR(3),TMPDIR(3,5),LPTYPE(10)
C
      CALL FINDLPDIR(NATCNT,NLP,LPTYPE,TMPDIR,IERR)
      LPTYP = LPTYPE(LPDEX)
      IF(IERR.EQ.1) CALL ABORT0('LPDIR01   ')
      IF(NLP.LT.LPDEX) CALL ABORT0('LPDIR02   ')
      DO I=1, 3
      PLVBDIR(I) = TMPDIR(I,LPDEX)
      END DO
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     FIND ALL LONE PAIR VBO(s) OF ATOM NATCNT
C     NATCNT:  ATOM INDEX
C     NLP:     THE NUMBER OF OF LP (0,1,2,3,4)
C              IN NORMAL CASE, NLP=1,2,3
C              NOTE: DON'T RELY ON THIS FUNCTION TO DETECT THE NUMBER OF
C              LONE PAIRS, SINCE IT ONLY USE THE CONNECTIVITY INFO, AND
C              IT IS THE CALLER'S RESPONSIBILITY TO USE IT CORRECTLY.
C
C     PLVBDIR: LP DIRECTIONS
C     IERR:    ERROR CODE 1/0 (ERR/NO-ERR)
C              IF NO LP OR ISOLATE ATOM, IERR=1
C
C     FIRST CREATED: OCT. 4, 2003
C
C     AUTHOR: Jiabo LI
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE FINDLPDIR(NATCNT,NLP,LPTYPE,PLVBDIR,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL APIDIR
      DIMENSION PLVBDIR(3,*),TMPDIR(3),V1(3),V2(3),LPTYPE(10)
C     DIMENSION XAXIS(3),YAXIS(3),ZAXIS(3),PL1DIR(3),PL2DIR(3),PL3DIR(3)
      DIMENSION PL1DIR(3),PL2DIR(3),PL3DIR(3)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /MTOPOL/XYZMOL(3,1000),NATOMS,NATNNU(1001),
     &               NBONDALIST(10,1000),NBONDTYPE(10,1000)
C     DATA XAXIS,YAXIS,ZAXIS/1.0D0,0.0D0,0.0D0,0.0D0,1.0D0,0.0D0,
C    &                       0.0D0,0.0D0,1.0D0/
      APIDIR = .FALSE.
      DO I=1, 3
      PL1DIR(I) = 0.0D0
      PL2DIR(I) = 0.0D0
      PL3DIR(I) = 0.0D0
      END DO
      IERR = 1
      NBONDS = NBONDALIST(1,NATCNT)
C
C     ERROR DETECTION
C
      IF(NBONDS.LE.0.OR.NBONDS.GT.3) THEN
      WRITE(IOUTVB,999) NBONDS
 999  FORMAT(' ** THERE MAYBE AN ERROR IN THE INPUT !!! - NBONDS =',I5)
      RETURN
      END IF
C
C     FIND THE FIRST LPDIR
C
      IF(NBONDS.LE.2) THEN
        DO I=1, NBONDS
        NATBPT = NBONDALIST(I+1,NATCNT)
          DO J=1, 3
          TMPDIR(J) = XYZMOL(J,NATCNT)-XYZMOL(J,NATBPT)
          END DO
        CALL VECNORM(TMPDIR,IFLAG)
          DO J=1, 3
          PL1DIR(J) = PL1DIR(J) + TMPDIR(J)
          END DO
        END DO
        CALL VECNORM(PL1DIR,IFLAG)
C
C       THE FIRST LP OF R-X, R1-X-R2 WITH BOND ANGLE NOT EQ 180 DEGREE CAN BE
C       HANDELED THIS WAY. THE CASE X AND -X- WITH 180 DEGREE BOND ANGLE, THIS
C       WILL FAIL
C
C
        IF(IFLAG.EQ.0.AND.NBONDS.EQ.2) THEN
        NA1 = NATCNT
        NA2 = NBONDALIST(2,NATCNT)
        NA3 = 0
C       WRITE(IOUTVB,*)'NA1, NA2, NA3 =', NA1, NA2, NA3
        CALL LOCXYZ(NA1,NA2,NA3,XYZMOL,PL1DIR,PL2DIR,PL3DIR)
          DO I=1, 3
          PLVBDIR(I,1) = PL2DIR(I)
          PLVBDIR(I,2) = PL3DIR(I)
          END DO
        NLP = 2
        IERR = 0
C       WRITE(IOUTVB,*)'NLP = ', NLP
        LPTYPE(1) = 2
        LPTYPE(2) = 2
        RETURN
        END IF
        IF(IFLAG.EQ.0) CALL ABORT0('FNDLPDIR01')
      ELSE
C
C       THIS CAN BE A CASE OF -NH2, N AND ALL ITS 3 NEIBS ARE ON THE SAME PLAN
C       USING THE LOGIC FOR PI DIR.
C
        APIDIR = .FALSE.
        CALL ATOMPIDIR(NATCNT,NBONDS,NBONDALIST(2,NATCNT),XYZMOL,
     &               APIDIR,PL1DIR)
        IF(.NOT.APIDIR) CALL ABORT0('FNDLPDIR02')
      END IF
      NLP=1
      LPTYPE(1) = 1
      IERR = 0
      DO I=1, 3
      PLVBDIR(I,1) = PL1DIR(I)
      END DO
      IF(NBONDS.GE.3) RETURN
C     FIND THE SECOND LPDIR. IF NBONDS.GE.3, NO SECOND LP, RETURN
C
C     CASE 1, THE CENTER ATOM HAS TWO NEIGHBORS, SUCH AS -O-, -S- in H2O, Furan
C
      IF(NBONDS.EQ.2) THEN
        NA0 = NATCNT
        NA1 = NBONDALIST(2,NATCNT)
        NA2 = NBONDALIST(3,NATCNT)
          DO I=1, 3
          V1(I) = XYZMOL(I,NA1)-XYZMOL(I,NA0)
          V2(I) = XYZMOL(I,NA2)-XYZMOL(I,NA0)
          END DO
        CALL XPROD(V1,V2,PL2DIR)
        CALL VECNORM(PL2DIR,IFLAG)
        NLP=2
        IERR = 0
        DO I=1, 3
        PLVBDIR(I,2) = PL2DIR(I)
        END DO
        LPTYPE(1) = 1
        LPTYPE(2) = 2
        RETURN
      ELSE
C
C     CASE NBONDS.LE.1
C
C
C     THE ONLY CASE IS R-X, WHERE R IS A R-, Ph- AND X CAN BE -F, -Cl, -Br, -I
C     AND -O(-1).
C     IF X IS CONNECTED TO A CONJUGATE ATOM, SUCH AS A DOUBLE BONDED ATOM, OR
C     BENZENE RING, THE FIRST LP IS THE OPPOSITE DIRECTION OF R-X BOND, AND
C     THE SECOND LP IS THE PERPENDICULAR TO THE R-X BOND AND IN THE CONJUGATE
C     PLAN, I.E. PERPENDICULAR TO THE PIDIR
C
C     IF X IS NOT ATTATCHED TO A CONJUGATE ATOM, THEN USE THE RULE FOR LOCAL
C     XYZ
C
C
C     CASE 2, THE CENTER ATOM HAS ONLY ONE BOND CONNECTION, SUCH AS >C=O,
C     R-O(-), Ph-O(-). IF THE NEIGHBOR IS A CONJUGATE CENTER, THE SECOND LP
C     SHOULD BE IN THE PLANE OF CONJUGATION, I.E.
C
C
      IF(NBONDS.NE.1) CALL ABORT0('FNDLPDIR03')
      NAT = NBONDALIST(2,NATCNT)
      APIDIR = .FALSE.
      NBONDS = NBONDALIST(1,NAT)
      CALL ATOMPIDIR(NAT,NBONDS,NBONDALIST(2,NAT),XYZMOL,
     &               APIDIR,PL3DIR)
C       ONE NEIGHBOR. CASE 2A: IT IS A CONJUGATE ATOM
        IF(APIDIR) THEN
        CALL XPROD(PL3DIR,PL1DIR,PL2DIR)
        CALL VECNORM(PL2DIR,IFLAG)
        IF(IFLAG.EQ.0) CALL ABORT0('FNDLPDIR04')
          DO I=1, 3
          PLVBDIR(I,2) = PL2DIR(I)
          PLVBDIR(I,3) = PL3DIR(I)
          END DO
        NLP = 3
        IERR = 0
        LPTYPE(1) = 1
        LPTYPE(2) = 2
        LPTYPE(3) = 2
        RETURN
        ELSE
C       ONE NEIGHBOR. CASE 2B: IT IS NOT A CONJUGATE ATOM
C
C       LOCAL XYZ RULES
C
        NA3 = 0
        NA2 = 0
        NA1 = NATCNT
        IF(NBONDS.GT.0) NA2 = NBONDALIST(2,NATCNT)
          IF(NA2.GT.0.AND.NBONDALIST(1,NA2).GT.0) THEN
          NA3 = NBONDALIST(2,NA2)
          END IF
        CALL LOCXYZ(NA1,NA2,NA3,XYZMOL,PL1DIR,PL2DIR,PL3DIR)
          DO I=1, 3
          PLVBDIR(I,2) = PL2DIR(I)
          PLVBDIR(I,3) = PL3DIR(I)
          END DO
        NLP = 3
        IERR = 0
        LPTYPE(1) = 1
        LPTYPE(2) = 2
        LPTYPE(3) = 2
        END IF
      END IF
      RETURN
      END
C
C     DEFINE A LOCAL XYZ DIRECTIONS BY USING THREE ATOMS
C     NA1-NA2-NA3. NA1->NA2 WILLBE THE X-AXIS, and NA2->NA3 WILL BE IN THE PLAN
C     OF XY
C
      SUBROUTINE LOCXYZ(NA1,NA2,NA3,XYZ,AX,AY,AZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     DIMENSION XYZ(3,*),AX(3),AY(3),AZ(3),TMPDIR(3)
      DIMENSION XYZ(3,*),AX(3),AY(3),AZ(3)
      DIMENSION XAXIS(3),YAXIS(3),ZAXIS(3)
      DATA XAXIS,YAXIS,ZAXIS/1.0D0,0.0D0,0.0D0,0.0D0,1.0D0,0.0D0,
     &                       0.0D0,0.0D0,1.0D0/
      IF(NA1.EQ.0.OR.NA2.EQ.0) CALL ABORT0('LOCXYZ01  ')
      AX(1) = XYZ(1,NA2) - XYZ(1,NA1)
      AX(2) = XYZ(2,NA2) - XYZ(2,NA1)
      AX(3) = XYZ(3,NA2) - XYZ(3,NA1)
      CALL VECNORM(AX,IFLAG)
      IF(IFLAG.EQ.0) CALL ABORT0('LOCXYZ02  ')
      IF(NA3.NE.0) THEN
      AY(1) = XYZ(1,NA3) - XYZ(1,NA2)
      AY(2) = XYZ(2,NA3) - XYZ(2,NA2)
      AY(3) = XYZ(3,NA3) - XYZ(3,NA2)
      CALL XPROD(AX,AY,AZ)
      CALL VECNORM(AZ,IFLAG)
      IF(IFLAG.EQ.0) GOTO 100
      CALL XPROD(AZ,AX,AY)
      RETURN
      END IF
 100  CONTINUE
C
C     IF NA3.EQ.0, USE THE ORIENTATION OF NA1-NA2 ONLY TO DEFINE
C
C     FIND THE SMALLEST ANGLE WITH X,Y,Z AXIS
C
      CALL DOTPROD(XAXIS,AX,XBDIR)
      CALL DOTPROD(YAXIS,AX,YBDIR)
      CALL DOTPROD(ZAXIS,AX,ZBDIR)
      AXBDIR = DABS(XBDIR)
      AYBDIR = DABS(YBDIR)
      AZBDIR = DABS(ZBDIR)
C
C     AXBDIR is the largest
C
      IF (AXBDIR.GE.AYBDIR.AND.AXBDIR.GT.AZBDIR) THEN
C     X -> X', Y -> Y', Z -> Z'
C
C     AY = YAXIS - YBDIR*AX, AX IS NORMALIZED
C
        DO I=1, 3
        AY(I) = YAXIS(I) - YBDIR*AX(I)
        END DO
        CALL VECNORM(AY,IFLAG)
C
C     AZ = AX X AY
C
      CALL XPROD(AX,AY,AZ)
      ELSE IF(AYBDIR.GE.AXBDIR.AND.AYBDIR.GE.AZBDIR) THEN
C     Y -> X', Z -> Y', X -> Z'
C
C     AY = ZAXIS - ZBDIR*AX
C
        DO I=1, 3
        AY(I) = ZAXIS(I) - ZBDIR*AX(I)
        END DO
        CALL VECNORM(AY,IFLAG)
C
C     AZ = AX X AY
C
      CALL XPROD(AX,AY,AZ)
      ELSE
C     X -> Y', Y -> Z', Z -> X'
C
C     AY = XAXIS - XBDIR*AX
C
        DO I=1, 3
        AY(I) = XAXIS(I) - XBDIR*AX(I)
        END DO
        CALL VECNORM(AY,IFLAG)
C
C     AZ = AX X AY
C
      CALL XPROD(AX,AY,AZ)
      END IF
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     FIND PI ORBITAL DIRECTION ON ATOM NATCNT
C
C     IF IT IS NOT A CONJUGATE ATOM, RETURN FALSE (APIDIR)
C     OR IT IS A CONJUGATE ATOM, BUT THE PI ORBITAL DIRECTION CAN NOT
C     DETERMINED UNIQUELY, THEN RETURN APIDIR=.FALSE.
C
C     FIRST CREATED OCT.5 2003
C
C     AUTHOR: JIABO LI
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE ATOMPIDIR(NATCNT,NBONDS,NBALIST,XYZ,APIDIR,ATMPIDIR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL APIDIR
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION NBALIST(*),ATMPIDIR(3),XYZ(3,*),A(3),B(3),C(3)
      DIMENSION D(3),TMPDIR(3)
C     DIMENSION XAXIS(3),YAXIS(3),ZAXIS(3),PIXDIR(3),PIYDIR(3)
      DIMENSION XAXIS(3),YAXIS(3),ZAXIS(3)
      DATA XAXIS,YAXIS,ZAXIS/1.0D0,0.0D0,0.0D0,0.0D0,1.0D0,0.0D0,
     &                       0.0D0,0.0D0,1.0D0/
      IF(NBONDS.LE.1) THEN
      APIDIR = .FALSE.
      RETURN
      END IF
      IA = NATCNT
C
C     FIND THE PI DIR OF b-a-c
C
      IF(NBONDS.EQ.2) THEN
C
C     A = (b-a), B = (c-a)
C
      IB = NBALIST(1)
      IC = NBALIST(2)
      A(1) = XYZ(1,IB) - XYZ(1,IA)
      A(2) = XYZ(2,IB) - XYZ(2,IA)
      A(3) = XYZ(3,IB) - XYZ(3,IA)
      B(1) = XYZ(1,IC) - XYZ(1,IA)
      B(2) = XYZ(2,IC) - XYZ(2,IA)
      B(3) = XYZ(3,IC) - XYZ(3,IA)
      CALL XPROD(A,B,ATMPIDIR)
C
C     CHECK THE LENGTH OF ATMPIDIR
C
      RVEC = DSQRT(ATMPIDIR(1)**2+ATMPIDIR(2)**2+ATMPIDIR(3)**2)
C
C     IN CASE b-a-c are near colinear REUTRN WITH ERROR.
C     THE PARAMETER CAN BE ADJUSTED
C
      IF(RVEC.LT.0.1D0) RETURN
      CALL VECNORM(ATMPIDIR,IFLAG)
      IF(IFLAG.EQ.1) APIDIR = .TRUE.
      GOTO 200
      ELSE IF(NBONDS.EQ.3) THEN
C
C     A-(B,C,D)
C
      IB = NBALIST(1)
      IC = NBALIST(2)
      ID = NBALIST(3)
      A(1) = XYZ(1,IB) - XYZ(1,IA)
      A(2) = XYZ(2,IB) - XYZ(2,IA)
      A(3) = XYZ(3,IB) - XYZ(3,IA)
      B(1) = XYZ(1,IC) - XYZ(1,IA)
      B(2) = XYZ(2,IC) - XYZ(2,IA)
      B(3) = XYZ(3,IC) - XYZ(3,IA)
      C(1) = XYZ(1,ID) - XYZ(1,IA)
      C(2) = XYZ(2,ID) - XYZ(2,IA)
      C(3) = XYZ(3,ID) - XYZ(3,IA)
      CALL XPROD(A,B,ATMPIDIR)
      CALL XPROD(B,C,TMPDIR)
      CALL DOTPROD(ATMPIDIR,TMPDIR,PROD)
      IF(PROD.LT.0.0D0) CALL VECINV(TMPDIR)
      CALL VECAD(ATMPIDIR,TMPDIR,ATMPIDIR,3)
      CALL XPROD(A,C,TMPDIR)
      CALL DOTPROD(ATMPIDIR,TMPDIR,PROD)
      IF(PROD.LT.0.0D0) CALL VECINV(TMPDIR)
      CALL VECAD(ATMPIDIR,TMPDIR,ATMPIDIR,3)
      CALL VECNORM(ATMPIDIR,IFLAG)
      IF(IFLAG.EQ.0) WRITE(IOUTVB,*)'ERROR IN VECNORM'
      CALL DOTPROD(ATMPIDIR,A,AAPI)
      CALL DOTPROD(ATMPIDIR,B,BAPI)
      CALL DOTPROD(ATMPIDIR,C,CAPI)
      IF (AAPI+BAPI+CAPI.GT.0.0D0) CALL VECINV(ATMPIDIR)
      APIDIR = .TRUE.
      GOTO 200
      ELSE IF(NBONDS.EQ.4) THEN
      WRITE(IOUTVB,*)'WARNING: THIS IS A RARE CASE, PLEASE MAKE SURE'
      WRITE(IOUTVB,*)'         YOUR INPUT IS CORRECT.'
C
C     A-(B,C,D,E)
C
      IB = NBALIST(1)
      IC = NBALIST(2)
      ID = NBALIST(3)
      IE = NBALIST(4)
      A(1) = XYZ(1,IB) - XYZ(1,IA)
      A(2) = XYZ(2,IB) - XYZ(2,IA)
      A(3) = XYZ(3,IB) - XYZ(3,IA)
      B(1) = XYZ(1,IC) - XYZ(1,IA)
      B(2) = XYZ(2,IC) - XYZ(2,IA)
      B(3) = XYZ(3,IC) - XYZ(3,IA)
      C(1) = XYZ(1,ID) - XYZ(1,IA)
      C(2) = XYZ(2,ID) - XYZ(2,IA)
      C(3) = XYZ(3,ID) - XYZ(3,IA)
      D(1) = XYZ(1,IE) - XYZ(1,IA)
      D(2) = XYZ(2,IE) - XYZ(2,IA)
      D(3) = XYZ(3,IE) - XYZ(3,IA)
      CALL DOTPROD(A,A,A2)
      CALL DOTPROD(B,B,B2)
      CALL DOTPROD(C,C,C2)
      CALL DOTPROD(D,D,D2)
      ATMPIDIR(1) = 0.0D0
      ATMPIDIR(2) = 0.0D0
      ATMPIDIR(3) = 0.0D0
C     Angle AB < 135 degree, otherwise, remove it
      CALL DOTPROD(A,B,AB)
      AB135 = -0.707D0*DSQRT(A2*B2)
        IF(AB.GT.AB135) THEN
        CALL XPROD(A,B,TMPDIR)
        CALL DOTPROD(ATMPIDIR,TMPDIR,PROD)
        IF(PROD.LT.0.0D0) CALL VECINV(TMPDIR)
        CALL VECAD(ATMPIDIR,TMPDIR,ATMPIDIR,3)
        END IF
C     Angle AC < 135 degree, otherwise, remove it
      CALL DOTPROD(A,C,AC)
      AC135 = -0.707D0*DSQRT(A2*C2)
        IF(AC.GT.AC135) THEN
        CALL XPROD(A,C,TMPDIR)
        CALL DOTPROD(ATMPIDIR,TMPDIR,PROD)
        IF(PROD.LT.0.0D0) CALL VECINV(TMPDIR)
        CALL VECAD(ATMPIDIR,TMPDIR,ATMPIDIR,3)
        END IF
C     Angle AD < 135 degree, otherwise, remove it
      CALL DOTPROD(A,D,AD)
      AD135 = -0.707D0*DSQRT(A2*D2)
        IF(AD.GT.AD135) THEN
        CALL XPROD(A,D,TMPDIR)
        CALL DOTPROD(ATMPIDIR,TMPDIR,PROD)
        IF(PROD.LT.0.0D0) CALL VECINV(TMPDIR)
        CALL VECAD(ATMPIDIR,TMPDIR,ATMPIDIR,3)
        END IF
C     Angle BC < 135 degree, otherwise, remove it
      CALL DOTPROD(B,C,BC)
      BC135 = -0.707D0*DSQRT(B2*C2)
        IF(BC.GT.BC135) THEN
        CALL XPROD(B,C,TMPDIR)
        CALL DOTPROD(ATMPIDIR,TMPDIR,PROD)
        IF(PROD.LT.0.0D0) CALL VECINV(TMPDIR)
        CALL VECAD(ATMPIDIR,TMPDIR,ATMPIDIR,3)
        END IF
C     Angle BD < 135 degree, otherwise, remove it
      CALL DOTPROD(B,D,BD)
      BD135 = -0.707D0*DSQRT(B2*D2)
        IF(BD.GT.BD135) THEN
        CALL XPROD(B,D,TMPDIR)
        CALL DOTPROD(ATMPIDIR,TMPDIR,PROD)
        IF(PROD.LT.0.0D0) CALL VECINV(TMPDIR)
        CALL VECAD(ATMPIDIR,TMPDIR,ATMPIDIR,3)
        END IF
C     Angle CD < 135 degree, otherwise, remove it
      CALL DOTPROD(C,D,CD)
      CD135 = -0.707D0*DSQRT(C2*D2)
        IF(CD.GT.CD135) THEN
        CALL XPROD(C,D,TMPDIR)
        CALL DOTPROD(ATMPIDIR,TMPDIR,PROD)
        IF(PROD.LT.0.0D0) CALL VECINV(TMPDIR)
        CALL VECAD(ATMPIDIR,TMPDIR,ATMPIDIR,3)
        END IF
      CALL DOTPROD(ATMPIDIR,A,AAPI)
      CALL DOTPROD(ATMPIDIR,B,BAPI)
      CALL DOTPROD(ATMPIDIR,C,CAPI)
      CALL DOTPROD(ATMPIDIR,D,DAPI)
      IF (AAPI+BAPI+CAPI+DAPI.GT.0.0D0) CALL VECINV(ATMPIDIR)
      GOTO 200
      ELSE
C
C     NBONDS >4, TI IS NOT POSSIBLE TO DETERMINE THE PI DIR
C
      APIDIR = .FALSE.
      RETURN
      END IF
 200  CONTINUE
C
C     TO MAKE SURE THE PIDIR ORIENTATION IS NOT TOO ARBITARY
C     IT MAY NOT ALWAYS WORK, BUT SHOULD BE GOOD ENOUGH
C
      CALL DOTPROD(XAXIS,ATMPIDIR,XBDIR)
      CALL DOTPROD(YAXIS,ATMPIDIR,YBDIR)
      CALL DOTPROD(ZAXIS,ATMPIDIR,ZBDIR)
      AXBDIR = DABS(XBDIR)
      AYBDIR = DABS(YBDIR)
      AZBDIR = DABS(ZBDIR)
      IF(AXBDIR.GT.AYBDIR.AND.AXBDIR.GT.AZBDIR) THEN
C
C     ATMPIDIR IN X-AXIS DIR
C
        IF(XBDIR.LT.0.0D0) CALL VECINV(ATMPIDIR)
        RETURN
      ELSE IF(AYBDIR.GT.AZBDIR) THEN
C
C     ATMPIDIR IN Y-AXIS DIR
C
        IF(YBDIR.LT.0.0D0) CALL VECINV(ATMPIDIR)
        RETURN
      ELSE IF(ZBDIR.LT.0.0D0) THEN
C
C     ATMPIDIR IN Z-AXIS DIR
C
        CALL VECINV(ATMPIDIR)
        RETURN
      END IF
      RETURN
      END
      SUBROUTINE XPROD(A,B,C)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(3),B(3),C(3)
      C(1) = A(2)*B(3) - A(3)*B(2)
      C(2) = A(3)*B(1) - A(1)*B(3)
      C(3) = A(1)*B(2) - A(2)*B(1)
      RETURN
      END
      SUBROUTINE DOTPROD(A,B,C)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(3),B(3)
      C = A(1)*B(1) + A(2)*B(2) + A(3)*B(3)
      RETURN
      END
      SUBROUTINE VECNORM(A,IFLAG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(3)
      IFLAG = 0
      C = A(1)*A(1) + A(2)*A(2) + A(3)*A(3)
      IF(C.GT.1.0D-7) THEN
      C = DSQRT(C)
      A(1) = A(1) / C
      A(2) = A(2) / C
      A(3) = A(3) / C
      IFLAG = 1
      END IF
      RETURN
      END
      SUBROUTINE VECINV(A)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(3)
      A(1) = -A(1)
      A(2) = -A(2)
      A(3) = -A(3)
      RETURN
      END
      SUBROUTINE VECAD(A,B,C,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(*),B(*),C(*)
      DO I=1, N
      C(I) = A(I) + B(I)
      END DO
      RETURN
      END
      SUBROUTINE LOOKPIVBO(NATNUMPI,NBONDS,FRGXYZ,FRGORB,FRGAOLB,NAFRAG,
     &                     NAOFRG,IOLVBO,VBOLDIR)
C    &                     NAOFRG,IOLVBO,BASNAME,VBOLDIR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*20 BASNAME
      CHARACTER*12 FRGAOLB(*)
      CHARACTER*80 LOBNAME
      DIMENSION FRGXYZ(3,*),FRGORB(*),NATFRAG(30),VBOLDIR(3)
C     CHARACTER*3 FUNIT(10)
C     CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
C     COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
C     SEARCH MAP FOR Li, Be, B, C, N, O, F, Na, Mg, Al, Si, P, S, Cl, Br, I
C
      LOBNAME = '@#$%'
      IF (NATNUMPI.EQ.1)  LOBNAME = '$PI-H-IN-HH'
      IF (NATNUMPI.EQ.1)  LSTR    = 11
      IF (NATNUMPI.EQ.3)  LOBNAME = '$PI-LI-IN-LIH'
      IF (NATNUMPI.EQ.3)  LSTR    = 13
      IF (NATNUMPI.EQ.4)  LOBNAME = '$PI-BE-IN-H2BE'
      IF (NATNUMPI.EQ.4)  LSTR    = 14
      IF (NATNUMPI.EQ.5)  LOBNAME = '$PI-B-IN-BH3'
      IF (NATNUMPI.EQ.5)  LSTR    = 12
      IF (NATNUMPI.EQ.6)  LOBNAME = '$PI-C-IN-C2H4'
      IF (NATNUMPI.EQ.6)  LSTR    = 13
      IF (NATNUMPI.EQ.7)  LOBNAME = '$PI-N-IN-CH2NH'
      IF (NATNUMPI.EQ.7)  LSTR    = 14
      IF (NATNUMPI.EQ.8)  LOBNAME = '$PI-O-IN-CH2O'
      IF (NATNUMPI.EQ.8)  LSTR    = 13
      IF (NATNUMPI.EQ.9)  LOBNAME = '$PI-F-IN-HF'
      IF (NATNUMPI.EQ.9)  LSTR    = 11
      IF (NATNUMPI.EQ.11) LOBNAME = '$PI-NA-IN-NAH'
      IF (NATNUMPI.EQ.11) LSTR    = 13
      IF (NATNUMPI.EQ.12) LOBNAME = '$PI-MG-IN-MGH2'
      IF (NATNUMPI.EQ.12) LSTR    = 14
      IF (NATNUMPI.EQ.13) LOBNAME = '$PI-AL-IN-ALH3'
      IF (NATNUMPI.EQ.13) LSTR    = 14
      IF (NATNUMPI.EQ.14) LOBNAME = '$PI-SI-IN-SIH3'
      IF (NATNUMPI.EQ.14) LSTR    = 14
      IF (NATNUMPI.EQ.15) LOBNAME = '$PI-P-IN-PH3'
      IF (NATNUMPI.EQ.15) LSTR    = 12
      IF (NATNUMPI.EQ.16) LOBNAME = '$PI-S-IN-CH2S'
      IF (NATNUMPI.EQ.16) LSTR    = 13
      IF (NATNUMPI.EQ.17) LOBNAME = '$PI-CL-IN-HCL'
      IF (NATNUMPI.EQ.17) LSTR    = 13
      IF (NATNUMPI.EQ.35) LOBNAME = '$PI-BR-IN-HBR'
      IF (NATNUMPI.EQ.35) LSTR    = 13
      IF (NATNUMPI.EQ.53) LOBNAME = '$PI-I-IN-HI'
      IF (NATNUMPI.EQ.53) LSTR    = 11
C
C     DOUBLE OCCUPIED PI ORBITAL
C
      IF (NATNUMPI.EQ.7.AND.NBONDS.EQ.3)  LOBNAME = '$PI-N-IN-PYRROLE'
      IF (NATNUMPI.EQ.7.AND.NBONDS.EQ.3)  LSTR    = 16
      IF (NATNUMPI.EQ.8.AND.NBONDS.EQ.2)  LOBNAME = '$PI-O-IN-FURAN'
      IF (NATNUMPI.EQ.8.AND.NBONDS.EQ.2)  LSTR    = 14
      IF (NATNUMPI.EQ.16.AND.NBONDS.EQ.2) LOBNAME = '$PI-S-IN-THIOPHENE'
      IF (NATNUMPI.EQ.16.AND.NBONDS.EQ.2) LSTR    = 18
C
C     SEARCH FOR THE FLAG
C
C     WRITE(IOUTVB,*)'SEARCH FOR', LOBNAME
      CALL LOCTOR(IOLVBO,LOBNAME,LSTR,IOK,0)
      IF(IOK.NE.1) THEN
C
C     SEARCH FOR THE NEAREST MATCH
C
        IF(NATNUMPI.GT.2.AND.NATNUMPI.LE.10) THEN
        LOBNAME = '$PI-C-IN-C2H4'
        LSTR    = 13
        ELSE IF(NATNUMPI.GT.10.AND.NATNUMPI.LE.18) THEN
        LOBNAME = '$PI-S-IN-CH2S'
        LSTR    = 13
        END IF
        CALL LOCTOR(IOLVBO,LOBNAME,LSTR,IOK,0)
        IF(IOK.NE.1) CALL ABORT0('LOOKPIVB03')
      END IF
      READ(IOLVBO,*)NAFRAG
C     WRITE(IOUTVB,*)'NAFRAG = ',NAFRAG
        DO I=1, NAFRAG
        READ(IOLVBO,*)NATFRAG(I),(FRGXYZ(J,I),J=1,3)
C       WRITE(IOUTVB,*)NATFRAG(I),(FRGXYZ(J,I),J=1,3)
        END DO
      READ(IOLVBO,*)
      READ(IOLVBO,*)
      READ(IOLVBO,*)
      READ(IOLVBO,*)NAOFRG
        DO I=1, NAOFRG
        READ(IOLVBO,1000)INDEXO, FRGAOLB(I),FRGORB(I)
C       WRITE(IOUTVB,1000)INDEXO, FRGAOLB(I),FRGORB(I)
        END DO
      READ(IOLVBO,*)
      READ(IOLVBO,*)(VBOLDIR(I),I=1,3)
C
 1000 FORMAT(I4,A12,F10.5)
      IF(IOLVBO.GT.1000000) WRITE(*,*)INDEXO,NATFRAG(1)
      RETURN
      END
      SUBROUTINE LOOKSIGMA(NATNUM,NBONDS,VBOLDIR,FRGORB,FRGAOLB,
     &                     NAOFRG,IOLVBO,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 FRGAOLB(*)
C     character*20 BASNAME
      CHARACTER*80 LOBNAME
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION FRGORB(*),FRGXYZ(3,100),VBOLDIR(3),NATFRAG(100)
      DIMENSION NATBAS(100),NATLEV(100),NATLIST(100)
C
C     SEARCH MAP FOR H, Li, Be, B, C, N, O, F, Na, Mg, Al, Si, P, S, Cl, Br, I
C
      LOBNAME = '@#$%'
      IF (NATNUM.EQ.1)  LOBNAME = '$SIGMA-H-'
      IF (NATNUM.EQ.3)  LOBNAME = '$SIGMA-LI'
      IF (NATNUM.EQ.4)  LOBNAME = '$SIGMA-BE'
      IF (NATNUM.EQ.5)  LOBNAME = '$SIGMA-B-'
      IF (NATNUM.EQ.7)  LOBNAME = '$SIGMA-N-'
      IF (NATNUM.EQ.8)  LOBNAME = '$SIGMA-O-'
      IF (NATNUM.EQ.9)  LOBNAME = '$SIGMA-F-'
      IF (NATNUM.EQ.11) LOBNAME = '$SIGMA-NA'
      IF (NATNUM.EQ.12) LOBNAME = '$SIGMA-MG'
      IF (NATNUM.EQ.13) LOBNAME = '$SIGMA-AL'
      IF (NATNUM.EQ.14) LOBNAME = '$SIGMA-SI'
      IF (NATNUM.EQ.15) LOBNAME = '$SIGMA-P-'
      IF (NATNUM.EQ.16) LOBNAME = '$SIGMA-S-'
      IF (NATNUM.EQ.17) LOBNAME = '$SIGMA-CL'
      IF (NATNUM.EQ.35) LOBNAME = '$SIGMA-BR'
      IF (NATNUM.EQ.53) LOBNAME = '$SIGMA-I-'
      IF (NATNUM.EQ.1)  LSTR    = 9
      IF (NATNUM.EQ.3)  LSTR    = 9
      IF (NATNUM.EQ.4)  LSTR    = 9
      IF (NATNUM.EQ.5)  LSTR    = 9
      IF (NATNUM.EQ.7)  LSTR    = 9
      IF (NATNUM.EQ.8)  LSTR    = 9
      IF (NATNUM.EQ.9)  LSTR    = 9
      IF (NATNUM.EQ.11) LSTR    = 9
      IF (NATNUM.EQ.12) LSTR    = 9
      IF (NATNUM.EQ.13) LSTR    = 9
      IF (NATNUM.EQ.14) LSTR    = 9
      IF (NATNUM.EQ.15) LSTR    = 9
      IF (NATNUM.EQ.16) LSTR    = 9
      IF (NATNUM.EQ.17) LSTR    = 9
      IF (NATNUM.EQ.35) LSTR    = 9
      IF (NATNUM.EQ.53) LSTR    = 9
      IF (NATNUM.EQ.6.AND.NBONDS.GE.4) THEN
      LOBNAME = '$SIGMA-C-SP3'
      LSTR    = 12
      END IF
      IF (NATNUM.EQ.6.AND.NBONDS.EQ.3) THEN
      LOBNAME = '$SIGMA-C-SP2'
      LSTR    = 12
      END IF
      IF (NATNUM.EQ.6.AND.NBONDS.LE.2) THEN
      LOBNAME = '$SIGMA-C-SP1'
      LSTR    = 12
      END IF
C
      IF(LOBNAME .EQ. '@#$%' ) THEN
      WRITE(IOUTVB,*)'UNKNOWN VBO TYPE, STOP!'
      CALL ABORT0('LOOKSIGMA0')
      END IF
C
C     SEARCH FOR THE FLAG
C
      CALL LOCTOR(IOLVBO,LOBNAME,LSTR,IOK,0)
      IF(IOK.NE.1) THEN
C
C     SEARCH FOR THE NEAREST MATCH
C
        IF(NATNUM.GT.2.AND.NATNUM.LE.10) THEN
        LOBNAME = '$SIGMA-C-'
        LSTR = 8
        ELSE IF(NATNUM.GT.10.AND.NATNUM.LE.18) THEN
        LOBNAME = '$SIGMA-S-'
        LSTR = 8
        END IF
        CALL LOCTOR(IOLVBO,LOBNAME,LSTR,IOK,0)
        IF(IOK.NE.1) THEN
        WRITE(IOUTVB,*)'ERR:LOOKSGM03'
        IERR = 1
        RETURN
        END IF
      END IF
      READ(IOLVBO,*)NAFRAG
C     WRITE(IOUTVB,*)'NAFRAG = ',NAFRAG
        DO I=1, NAFRAG
        READ(IOLVBO,*)NATFRAG(I),(FRGXYZ(J,I),J=1,3),NATLEV(I)
C       WRITE(IOUTVB,*)NATFRAG(I),(FRGXYZ(J,I),J=1,3),NATLEV(I)
        END DO
      READ(IOLVBO,*)
      READ(IOLVBO,*)NATORB
      READ(IOLVBO,*)(NATLIST(I),I=1,NATORB)
      READ(IOLVBO,*)(NATBAS(I),I=1,NATORB)
      NAOTOTAL = 0
      DO K=1, NATORB
        DO I=NAOTOTAL+1, NAOTOTAL+NATBAS(K)
        READ(IOLVBO,1000)INDEXO, FRGAOLB(I),FRGORB(I)
C       WRITE(IOUTVB,1000)INDEXO, FRGAOLB(I),FRGORB(I)
        END DO
      NAOTOTAL = NAOTOTAL + NATBAS(K)
      END DO
C
C     ONLY THE AOs ON THE FIRST ATOM IS USED HERE
C
      NAOFRG = NATBAS(1)
      READ(IOLVBO,*)
      READ(IOLVBO,*)(VBOLDIR(I),I=1,3)
C     WRITE(IOUTVB,*)'VBOLDIR= ',(VBOLDIR(I),I=1,3)
 1000 FORMAT(I4,A12,F10.5)
      IF(IOLVBO.GT.1000000) WRITE(*,*)INDEXO,NATFRAG(1),NATLEV(1)
      IF(IOLVBO.GT.1000000) WRITE(*,*)FRGXYZ(1,1),NATLIST(1)
      RETURN
      END
      SUBROUTINE LOOKPI(NATNUM,NBONDS,VBOLDIR,FRGORB,FRGAOLB,
     &                     NAOFRG,IOLVBO)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 FRGAOLB(*)
C     character*20 BASNAME
      CHARACTER*80 LOBNAME
      DIMENSION FRGORB(*),FRGXYZ(3,100),VBOLDIR(3),NATFRAG(100)
      DIMENSION NATBAS(100),NATLEV(100),NATLIST(100)
C     CHARACTER*3 FUNIT(10)
C     CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
C     COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
C     SEARCH MAP FOR H, Li, Be, B, C, N, O, F, Na, Mg, Al, Si, P, S, Cl, Br, I
C
      LOBNAME = '@#$%'
      IF (NATNUM.EQ.1)  LOBNAME = '$PI-H-IN-HH'
      IF (NATNUM.EQ.1)  LSTR    = 11
      IF (NATNUM.EQ.3)  LOBNAME = '$PI-LI-IN-LIH'
      IF (NATNUM.EQ.3)  LSTR    = 13
      IF (NATNUM.EQ.4)  LOBNAME = '$PI-BE-IN-H2BE'
      IF (NATNUM.EQ.4)  LSTR    = 14
      IF (NATNUM.EQ.5)  LOBNAME = '$PI-B-IN-BH3'
      IF (NATNUM.EQ.5)  LSTR    = 12
      IF (NATNUM.EQ.6)  LOBNAME = '$PI-C-IN-C2H4'
      IF (NATNUM.EQ.6)  LSTR    = 13
      IF (NATNUM.EQ.7)  LOBNAME = '$PI-N-IN-CH2NH'
      IF (NATNUM.EQ.7)  LSTR    = 14
      IF (NATNUM.EQ.8)  LOBNAME = '$PI-O-IN-CH2O'
      IF (NATNUM.EQ.8)  LSTR    = 13
      IF (NATNUM.EQ.9)  LOBNAME = '$PI-F-IN-HF'
      IF (NATNUM.EQ.9)  LSTR    = 11
      IF (NATNUM.EQ.11) LOBNAME = '$PI-NA-IN-NAH'
      IF (NATNUM.EQ.11) LSTR    = 13
      IF (NATNUM.EQ.12) LOBNAME = '$PI-MG-IN-MGH2'
      IF (NATNUM.EQ.12) LSTR    = 14
      IF (NATNUM.EQ.13) LOBNAME = '$PI-AL-IN-ALH3'
      IF (NATNUM.EQ.13) LSTR    = 14
      IF (NATNUM.EQ.14) LOBNAME = '$PI-SI-IN-SIH3'
      IF (NATNUM.EQ.14) LSTR    = 14
      IF (NATNUM.EQ.15) LOBNAME = '$PI-P-IN-PH3'
      IF (NATNUM.EQ.15) LSTR    = 12
      IF (NATNUM.EQ.16) LOBNAME = '$PI-S-IN-CH2S'
      IF (NATNUM.EQ.16) LSTR    = 13
      IF (NATNUM.EQ.17) LOBNAME = '$PI-CL-IN-HCL'
      IF (NATNUM.EQ.17) LSTR    = 13
      IF (NATNUM.EQ.35) LOBNAME = '$PI-BR-IN-HBR'
      IF (NATNUM.EQ.35) LSTR    = 13
      IF (NATNUM.EQ.53) LOBNAME = '$PI-I-IN-HI'
      IF (NATNUM.EQ.53) LSTR    = 11
C
C     DOUBLE OCCUPIED PI ORBITAL
C
      IF (NATNUM.EQ.7.AND.NBONDS.EQ.3)  LOBNAME = '$PI-N-IN-PYRROLE'
      IF (NATNUM.EQ.7.AND.NBONDS.EQ.3)  LSTR    = 16
      IF (NATNUM.EQ.8.AND.NBONDS.EQ.2)  LOBNAME = '$PI-O-IN-FURAN'
      IF (NATNUM.EQ.8.AND.NBONDS.EQ.2)  LSTR    = 14
      IF (NATNUM.EQ.16.AND.NBONDS.EQ.2) LOBNAME = '$PI-S-IN-THIOPHENE'
      IF (NATNUM.EQ.16.AND.NBONDS.EQ.2) LSTR    = 18
C
C     SEARCH FOR THE FLAG
C
C     WRITE(IOUTVB,*)'SEARCH FOR', LOBNAME
      CALL LOCTOR(IOLVBO,LOBNAME,LSTR,IOK,1)
      IF(IOK.NE.1) THEN
C
C     SEARCH FOR THE NEAREST MATCH
C
        IF(NATNUM.GT.2.AND.NATNUM.LE.10) THEN
        LOBNAME = '$PI-C-IN-C2H4'
        LSTR = 13
        ELSE IF(NATNUM.GT.10.AND.NATNUM.LE.18) THEN
        LOBNAME = '$PI-S-IN-CH2S'
        LSTR = 13
        END IF
        CALL LOCTOR(IOLVBO,LOBNAME,LSTR,IOK,1)
        IF(IOK.NE.1) CALL ABORT0('LOOKPI03  ')
      END IF
      IF(IOK.NE.1) CALL ABORT0('LOOKPI04  ')
      READ(IOLVBO,*)NAFRAG
C     WRITE(IOUTVB,*)'NAFRAG = ',NAFRAG
        DO I=1, NAFRAG
        READ(IOLVBO,*)NATFRAG(I),(FRGXYZ(J,I),J=1,3),NATLEV(I)
C       WRITE(IOUTVB,*)NATFRAG(I),(FRGXYZ(J,I),J=1,3),NATLEV(I)
        END DO
      READ(IOLVBO,*)
      READ(IOLVBO,*)NATORB
      READ(IOLVBO,*)(NATLIST(I),I=1,NATORB)
      READ(IOLVBO,*)(NATBAS(I),I=1,NATORB)
      NAOTOTAL = 0
      DO K=1, NATORB
        DO I=NAOTOTAL+1, NAOTOTAL+NATBAS(K)
        READ(IOLVBO,1000)INDEXO, FRGAOLB(I),FRGORB(I)
C       WRITE(IOUTVB,1000)INDEXO, FRGAOLB(I),FRGORB(I)
        END DO
      NAOTOTAL = NAOTOTAL + NATBAS(K)
      END DO
C
C     ONLY THE AOs ON THE FIRST ATOM IS USED HERE
C
      NAOFRG = NATBAS(1)
      READ(IOLVBO,*)
      READ(IOLVBO,*)(VBOLDIR(I),I=1,3)
C     WRITE(IOUTVB,*)'VBOLDIR= ',(VBOLDIR(I),I=1,3)
C
 1000 FORMAT(I4,A12,F10.5)
      IF(IOLVBO.GT.1000000) WRITE(*,*)INDEXO,NATFRAG(1),NATLEV(1)
      IF(IOLVBO.GT.1000000) WRITE(*,*)FRGXYZ(1,1),NATLIST(1)
      RETURN
      END
      SUBROUTINE LOOKLP(NATNUM,VBOLDIR,FRGORB,FRGAOLB,
     &                     NAOFRG,LPDEX,IOLVBO)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     character*20 BASNAME
      CHARACTER*12 FRGAOLB(*)
      CHARACTER*80 LOBNAME
      DIMENSION FRGORB(*),FRGXYZ(3,100),VBOLDIR(3),NATFRAG(100)
      DIMENSION NATBAS(100),NATLEV(100),NATLIST(100)
C     CHARACTER*3 FUNIT(10)
C     CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
C     COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
C     SEARCH MAP FOR N, O, F, P, S, Cl, Br, I
C
      LOBNAME = '@#$%'
      LSTR    = 4
      IF (NATNUM.EQ.7.AND.LPDEX.EQ.1)  LOBNAME = '$LP1-N-'
      IF (NATNUM.EQ.7)  LSTR    = 7
      IF (NATNUM.EQ.8.AND.LPDEX.EQ.1)  LOBNAME = '$LP1-O-'
      IF (NATNUM.EQ.8.AND.LPDEX.EQ.2)  LOBNAME = '$LP2-O-'
      IF (NATNUM.EQ.8)  LSTR    = 7
      IF (NATNUM.EQ.9.AND.LPDEX.EQ.1)  LOBNAME = '$LP1-F-'
      IF (NATNUM.EQ.9.AND.LPDEX.GT.1)  LOBNAME = '$LP2-F-'
      IF (NATNUM.EQ.9)  LSTR    = 7
      IF (NATNUM.EQ.15.AND.LPDEX.EQ.1) LOBNAME = '$LP1-P-'
      IF (NATNUM.EQ.15) LSTR    = 7
      IF (NATNUM.EQ.16.AND.LPDEX.EQ.1) LOBNAME = '$LP1-S-'
      IF (NATNUM.EQ.16.AND.LPDEX.GT.1) LOBNAME = '$LP2-S-'
      IF (NATNUM.EQ.16) LSTR    = 7
      IF (NATNUM.EQ.17.AND.LPDEX.EQ.1) LOBNAME = '$LP1-CL'
      IF (NATNUM.EQ.17.AND.LPDEX.GT.1) LOBNAME = '$LP2-CL'
      IF (NATNUM.EQ.17) LSTR    = 7
      IF (NATNUM.EQ.35.AND.LPDEX.EQ.1) LOBNAME = '$LP1-BR'
      IF (NATNUM.EQ.35.AND.LPDEX.GT.1) LOBNAME = '$LP2-BR'
      IF (NATNUM.EQ.35) LSTR    = 7
      IF (NATNUM.EQ.53.AND.LPDEX.EQ.1) LOBNAME = '$LP1-I-'
      IF (NATNUM.EQ.53.AND.LPDEX.GT.1) LOBNAME = '$LP2-I-'
      IF (NATNUM.EQ.53) LSTR    = 7
C
C     SEARCH FOR THE FLAG
C
C     WRITE(IOUTVB,*)'SEARCH FOR', LOBNAME, LSTR
      CALL LOCTOR(IOLVBO,LOBNAME,LSTR,IOK,1)
      IF(IOK.NE.1) THEN
C
C     SEARCH FOR THE NEAREST MATCH, USING LP OF N OR P AS A TEMPLATE
C
        IF(NATNUM.GT.2.AND.NATNUM.LE.10) THEN
        LOBNAME = '$LP1-N-'
        LSTR = 7
        ELSE IF(NATNUM.GT.10.AND.NATNUM.LE.18) THEN
        LOBNAME = '$LP1-P-'
        LSTR = 7
        END IF
        CALL LOCTOR(IOLVBO,LOBNAME,LSTR,IOK,1)
        IF(IOK.NE.1) CALL ABORT0('LOOKLP03  ')
      END IF
      IF(IOK.NE.1) CALL ABORT0('LOOKLP04  ')
      READ(IOLVBO,*)NAFRAG
C     WRITE(IOUTVB,*)'NAFRAG = ',NAFRAG
        DO I=1, NAFRAG
        READ(IOLVBO,*)NATFRAG(I),(FRGXYZ(J,I),J=1,3),NATLEV(I)
C       WRITE(IOUTVB,*)NATFRAG(I),(FRGXYZ(J,I),J=1,3),NATLEV(I)
        END DO
      READ(IOLVBO,*)
      READ(IOLVBO,*)NATORB
      READ(IOLVBO,*)(NATLIST(I),I=1,NATORB)
      READ(IOLVBO,*)(NATBAS(I),I=1,NATORB)
      NAOTOTAL = 0
      DO K=1, NATORB
        DO I=NAOTOTAL+1, NAOTOTAL+NATBAS(K)
        READ(IOLVBO,1000)INDEXO, FRGAOLB(I),FRGORB(I)
C       WRITE(IOUTVB,1000)INDEXO, FRGAOLB(I),FRGORB(I)
        END DO
      NAOTOTAL = NAOTOTAL + NATBAS(K)
      END DO
C
C     ONLY THE AOs ON THE FIRST ATOM IS USED HERE
C
      NAOFRG = NATBAS(1)
      READ(IOLVBO,*)
      READ(IOLVBO,*)(VBOLDIR(I),I=1,3)
C     WRITE(IOUTVB,*)'VBOLDIR= ',(VBOLDIR(I),I=1,3)
C
 1000 FORMAT(I4,A12,F10.5)
      IF(IOLVBO.GT.1000000) WRITE(*,*)INDEXO,NATFRAG(1),NATLEV(1)
      IF(IOLVBO.GT.1000000) WRITE(*,*)FRGXYZ(1,1),NATLIST(1)
      RETURN
      END
      SUBROUTINE LOCTOR(IUNIT,STRING,LEN,IOK,IWARN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 A
      CHARACTER*80 TEMP
      CHARACTER*1 STRING(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      TEMP='          '
      REWIND(IUNIT)
      IOK=0
      DO 100 I=1,LEN
 100  TEMP(I:I)=STRING(I)
 200  READ(IUNIT,'(A80)',END=500,ERR=500)A
      DO 210 I=1,80-LEN
      IF(A(I:I+LEN-1).EQ.TEMP(1:LEN)) GOTO 220
 210  CONTINUE
      GOTO 200
 220  CONTINUE
      IOK=1
      RETURN
 500  IF(IWARN.GT.0) WRITE(IOUTVB,1000) TEMP
 1000 FORMAT(/' End of file. String ',A10, ' was not found')
      IOK=0
      RETURN
      END
      SUBROUTINE LOCTOR2(IUNIT,STRING,LEN,IOK,IWARN,A)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 A
      CHARACTER*80 TEMP
      CHARACTER*1 STRING(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      TEMP='          '
      REWIND(IUNIT)
      IOK=0
      DO 100 I=1,LEN
 100  TEMP(I:I)=STRING(I)
 200  READ(IUNIT,'(A80)',END=500)A
      DO 210 I=1,80-LEN
      IF(A(I:I+LEN-1).EQ.TEMP(1:LEN)) GOTO 220
 210  CONTINUE
      GOTO 200
 220  CONTINUE
      IOK=1
      RETURN
 500  IF(IWARN.GT.0) WRITE(IOUTVB,1000) TEMP
 1000 FORMAT(/' End of file. String ',A10, ' was not found')
      IOK=0
      RETURN
      END
C==========================================================================
C
C     VBSCF:  SUBROUTINE FOR VBSCF CALCULATIONS OF MULTI-VB STRUCTURES
C
C             QUADRATIC CONVERGENCE METHOD BASED ON NEWTON-RAPHSON
C             SCHEME. A DYNAMICALLY ADJUSTED PARAMETER IS USED TO
C             STABLIZE THE ITERATION PROCEDURE
C
C     Note:   Scratch space requirement:
C             NLAST + Sractch of algebrants (a function of N, NS)
C             OR MLAST, which ever is the larger.
C             NB = (N+1)/2
C             NAGSIZE = 80*5**NB
C             (8,0)  (10,0)  (12,0)  (14,0)
C             2000   10000   50000   250000
C
C
C     History:
C             June 5, 2004
C             Re-organized scratch space allocation, better estimation
C             of scratch space. A simple formulation for the approximate
C             size of scratch space has been found. (See the note above)
C
C             April 12, 2006
C             Added LDIAG option for updating VB structure coefficients
C
C             April 30, 2010
C             Increased scratch space for MAPs (MM=62500000 for N=18).
C
C             April 29, 2012
C             Reduced scratch space for MAPs to MM=2500000 for N=14 for
C             stand-alone VB2000 release, and to MM=50000 for N=12 for
C             GAMESS/VB2000 release, matching MAP files that are in that
C             release.
C
C     Author:
C
C             Jiabo Li
C
C===========================================================================
      SUBROUTINE VBSCF(MELX,MSPX,NBASIS,MORBX,MWINX,W,WBASIS,DMP,
     &              DMLOC,DM2LOC,MW,MGRP,FLAG,MITER,LASTITER)
C    &              DMLOC,DM2LOC,MW,ETOTAL,MGRP,FLAG,MITER,LASTITER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (NPA=4000, MAXNOB=200)
      CHARACTER*50 FLAG
      CHARACTER*80 VBPATH
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     LOGICAL   DECREASE,MAPEXISTS
      LOGICAL   DECREASE
C     DIMENSION CONSTR(1000),ICONST(1000),NBRIX(1000),MASKBRI(10000)
      DIMENSION CONSTR(1000),ICONST(1000),MASKBRI(10000)
C     DIMENSION NBOPT(100),DM2LOC(*),BASIS0(20000)
      DIMENSION DM2LOC(*),BASIS0(20000)
      DIMENSION CNORM(5000),DEV(NPA),DMP(*),WBASIS(*),DMLOC(*)
      DIMENSION INDX(2,NPA),DEV1(NPA),VECT(NPA)
C     DIMENSION INDX(2,NPA),DEV1(NPA),SV(NPA),VECT(NPA),VECT1(NPA)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
     &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
     &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
      COMMON /VBSTR/CSTR(10000),NPHI(100000),NSTR
      COMMON /VBCTL/EPS,MAXIT,NOPT,IHESS,NEWTON,NOB(MAXNOB),NVBI(5000)
C     COMMON /IAA/IA(100000)
C     COMMON /IBB/IB(100000),MWINZ,MBORZ
C     COMMON /ICC/IC(100000)
C
C     NOTE THAT MM IS SET IN 4 SUBROUTINES AND IT MUST BE SET
C     TO THE SAME VALUE.
C
CGMS  PARAMETER (MM=500000)
C     SUFFICIENT FOR MAP FILES IN GAMESS RELEASE.
C     IF YOU USE LARGER MAP FILES FROM THE VB2000 RELEASE,
C     YOU MUST INCREASE MM.
C
C000  PARAMETER (MM=2500000)
CSMI  PARAMETER (MM=2500000)
CGAU  PARAMETER (MM=2500000)
C     SUITABLE FOR 14 ELECTRONS WITH A SINGLET MOLECULE.
C
C     IF YOU ARE GOING TO USE MORE THAN 14 ELECTRON MAP FILES,
C     YOU MUST INCREASE MM. IF THE MULTIPCITY IS GREATER THAN 1,
C     MAY ALSO NEED TO INCREASE MM. 
C     A WARNING WILL BE GIVEN IF MM IS NOT LARGE ENOUGH.
C
C     FOR UP TO 12 ELECTRONS IN SINGLET USE - PARAMETER (MM=500000)
C     FOR UP TO 14 ELECTRONS IN SINGLET USE - PARAMETER (MM=2500000)
C     FOR UP TO 16 ELECTRONS IN SINGLET USE - PARAMETER (MM=12500000)
C
      DIMENSION NASTR(10000),INDXW(10)
      COMMON /LTAB/NTYPE,MAPINCORE,MEL,MSP,LOOKTB(6,100),NGRECD(4,100)
C     COMMON /MAP/MAP(3,MM),NALG(100),NRE(100),NAG1(100),NREC1(100),MVBM
      COMMON /MAP/MAP(3,MM),NALG(100),NRE(100),NAG1(100),MVBM
      COMMON /NBRTAB/NBTAB(10000),NOTAB(10000),INDXZ(2,1000)
      DIMENSION W(*),CSTRX(1000),XFACTOR(1000)
      DIMENSION SDM(20000),ORBLOC(20000)
      CHARACTER*80 NUMBER,MAPNNS,MAPFILE
      NUMBER  ='0123456789'
      CMAXCUT = 0.025D0
      CMAXX   = 0.0D0
      CMAX    = 0.0D0
C
C     RETURN IMMEDIATELY IF CI_ONLY IS TRUE
C
      IF(LCIONLY.EQ.1) RETURN
C     TIME1=XCLOCK()
C     IFLAG=0
      MVBM=0
      NORB=MWINX
      NOCORB=MORBX
      DO I=1, NSTR
      CSTRX(I) = 1.0D0
      END DO
C
C     GET IOUNITS BY NAMES
C
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL GETIOUNIT('IAO2E   ',IAO2E)
      CALL GETIOUNIT('IOMAP   ',IOMAP)
      CALL GETIOUNIT('IOHES   ',IOHES)
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL GETIOUNIT('IVBO2E  ',IVBO2E)
      CALL GETVBPATH(VBPATH)
      CALL GETCTLVAL("DIIS      ",CTLVAL,IDIIS)
      CALL LOCTOR(IOENGI,'$CMAXCUT',8,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)CMAXCUT
C
C    SCANE OCCUPIED ORBITALS
C
      NOCCORB=0
      DO I=1,MELX*NSTR
      IF(NPHI(I).GT.NOCCORB) NOCCORB=NPHI(I)
      END DO
      NOCORB=NOCCORB
      NS=MSPX
      N=MELX
      DO K=1,NSTR*N
      NASTR(K)=NPHI(K)
      END DO
      MAPNNS='MAP/MAP'
      NC1=1+N/10
      NC2=1+N-10*(NC1-1)
      MAPNNS(8:8)=NUMBER(NC1:NC1)
      MAPNNS(9:9)=NUMBER(NC2:NC2)
      NC1=1+NS/10
      NC2=1+NS-10*(NC1-1)
      MAPNNS(10:10)=NUMBER(NC1:NC1)
      MAPNNS(11:11)=NUMBER(NC2:NC2)
      K=11
CTMAP MAPNNS(12:12)='t'
CTMAP K=12
C     Add VBPATH
      CALL PATHST(MAPFILE,VBPATH,'/               ',MAPNNS,K)
C     MAPNNS = NUMBER
C     WRITE(IOUTVB,102) MAPNNS
C102  FORMAT(/,' MAP FILE IS: ',A80)
      NC1=1+N/10
C
C     LOADMAP
C
      IF(MEL.NE.N.OR.MSP.NE.NS) THEN
CBMAP OPEN(IOMAP,FILE=MAPFILE,STATUS='OLD',FORM='UNFORMATTED',
CBMAP&     ERR=2112)
CTMAP OPEN(IOMAP,FILE=MAPFILE,STATUS='OLD',FORM='FORMATTED',
CTMAP&     ERR=2112)
      GOTO 2111
2112  CONTINUE
      VBPATH = 'C:/VB2000NET/VB2000'
      CALL PATHST(MAPFILE,VBPATH,'/               ',MAPNNS,K)
CBMAP OPEN(IOMAP,FILE=MAPFILE,STATUS='OLD',FORM='UNFORMATTED',
CBMAP&     ERR=2113)
CTMAP OPEN(IOMAP,FILE=MAPFILE,STATUS='OLD',FORM='FORMATTED',
CTMAP&     ERR=2113)
      GOTO 2111
2113  CONTINUE
      WRITE(IOUTVB,*)"NO MAP FILE IS FOUND. THERE ARE TWO POSSIBILITIES"
      WRITE(IOUTVB,*)"1) THE JOB IS NOT RUNNING IN VB2000 DIRECTORY AND"
      WRITE(IOUTVB,*)"   VB2000PATH VARIABLE IS NOT SET "
      WRITE(IOUTVB,*)"2) THE MAP FILE IS NOT AVAILABLE FOR THIS RELEASE"
      WRITE(IOUTVB,*)"   PLEASE CONTACT US AT VB@SCINETEC.COM FOR HELP!"
      CALL ABRTVB
2111  CONTINUE
C     MSIZE = MM
      CALL LOADMAP(IOMAP,N,NS,NTYPE,MAPINCORE,MVBM,
     &             LOOKTB,NGRECD,MAP,MM)
      MSP=NS
      MEL=N
C     WRITE(IOUTVB,*)'LAPLACE EXPANSION MAP LOADED'
      END IF
      CALL BRITAB(NOCORB,NORB,INDX,NBRIL,NBTAB,NOTAB,MASKBRI,MITER)
      NORB2   = NORB*(NORB+1)/2
      INDXW(1)=NORB2
      INDXW(2)=NORB2
      INDXW(3)=NORB2
      CALL SETINXN(3,INDXW,NORB3)
C
C     COMPUTE ADDRESSES FOR VBHESS
C
      NWDM    = NORB2*(2+2*NSTR)+NORB2*(NORB2+1)*(2+NSTR)/2+NORB3
      NADDHESS= 1
      NADDS   = NADDHESS + (NBRIL+NSTR)*(NBRIL+NSTR+1)/2
      NADDH   = NADDS + NORB2
      NADDG   = NADDH + NORB2
      NADDVBS = NADDG + NORB2*(NORB2+1)/2
      NADDVBH = NADDVBS + NSTR*(NSTR+1)/2
      NADDM   = NADDVBH + NSTR*(NSTR+1)/2
      NADDSS  = NADDM + NWDM
      NADDAG  = NADDSS + N*NORB
      NREM1   = MW - NADDAG
C     NLAST   = NADDAG
      MMX1    = NADDG + NORB2*(NORB2+1)/2
      MMX2    = MMX1 + NORB*NORB
      MMX3    = MMX2 + NORB*NORB2
C     WRITE(IOUTVB,*)'MXMISC =',NLAST
C
C     THE REMANING (NREM1) IS FOR THE SCATCH SPACE OF ALGEBRANTS IN VBHESS
C     THE MINIMAL SIZE IS A FUNCTION OF (N, NS AND IDERANK)
C     TODO: BUILD SUCH A TABLE.
C
      IF(NREM1.LT.0) CALL ABORT0('VBSCF01   ')
C     TIME1=XCLOCK()-TIME1
C1111 CONTINUE
C
C     SET CONVERGENCE FLAG TO NEGATIVE
C
      ICONV=0
      IF(NOPT.LE.0) RETURN
      IF(NSTR.GT.199) THEN
        WRITE(IOUTVB,*)"NO MORE THAN 199 VB STRUCTURES CAN BE OPTIMIZED"
        CALL ABORT0('VBSCF02   ')
      END IF
C
C     CALCUULATE THE INDEXES
C
      CALL SETIND(MWINX,MORBX)
C
C     INDEXES
C
      NPAR   = NBRIL + NSTR
      MSQ    = MWINX*(MWINX+1)/2
C     MTSQ   = NBASIS*(NBASIS+1)/2
      MGSQ   = MSQ*(MSQ+1)/2
C     NMTSQ  = NBASIS*MTSQ
C
C     ADDRESS
C
C     THE ORDER OF MSS,MHH,MGG IS CRITICAL. IN HESSAN, HG STORE BOTH H AND G
C
      MTX    = NBASIS
      IF(NORB .GT. NBASIS) MTX = NORB
      MTXSQ  = MTX*(MTX+1)/2
      MSS    = 1
      MHH    = MSS+MTXSQ
      MGG    = MHH+MTXSQ
      MMT1   = MGG
      MMT2   = MMT1+MTX*MTX
      MMT3   = MMT2+MTX*MTXSQ
      MLAST  = MMT3+MTXSQ
      NREM2  = MW - MLAST
      IF(NREM2.LT.0) CALL ABORT0('VBSCF03   ')
C
C     MNSQ=MWINX*(MWINX+1)/2
C
C     READ CONSTRAINS FOR OPTIMIZATION (GENERAL, ORBITALS OR CSTR)
C     DETERMINE NONLINEARLY DEPENDENT PARAMETERS
C
      CALL RCONST(CONSTR,ICONST,NBRIL,NPAR,NLORBI,NLCSTR,FLAG)
      NONLIN=NLORBI+NLCSTR
C
      IFIX =1
      IF(NEWTON.GE.2) IFIX =0
      RGQT =0.1D0
      BGQT =0.9D0
      EPT  =0.0D0
      RDAMP=0.1D0
      TK   =0.1D0
      ERCTL=0.15D0
      ENG1 =0.0D0
      ENG2 =0.0D0
      DECREASE = .FALSE.
      CMAXOLD = 1000.0D0
      CALL LOCTOR(IOENGI,'$ERCTL',6,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)ERCTL
      ITER =0
      IF( LPTALL.EQ.1) THEN
CGMS     CALL FLSHBF(IOUTVB)
         WRITE(IOUTVB,101) MGRP
      ENDIF
 101  FORMAT(/' VB-ORBITAL OPTIMIZATION OF GROUP',I3,' ...')
      LDIAG = 0
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$LDIAGVB',8,IOK,0)
      IF(IOK.EQ.1) LDIAG = 1
C
C     VBOPT ITERATION STARTS HERE
C
      IF(MLORBIT(MGRP)*NBASIS.GT.20000) CALL ABORT0('VBSCF00001')
      NDIISS = 5
      CALL LOCTOR(IOENGI,'$DIISSTART',10,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)NDIISS
      NDIISMAX = 10
      IF(IDIIS.NE.1) NDIISS = 1000
 100  CONTINUE
      TK   =TK/2.0D0
      ITER =ITER+1
      CALL GETIOUNIT('IOTEMPA ',IOTEMPA)
      CALL GETIOUNIT('IOTEMPB ',IOTEMPB)
      IF(ITER.LE.1) THEN
      LBUFF   = 4095
C     NSQ     = NORB*(NORB+1)/2
C     NSQ2    = NSQ*(NSQ+1)/2
C     NB2     = NBASIS*NBASIS
      CALL READ1E(IAO1E,W(MSS),W(MHH),NBASIS)
      CALL VBONORM(NBASIS,MLORBIT(MGRP),WBASIS,W(MSS),CNORM)
C
C     APPLY SYMMETRY CORRECTION ......?
C     FIRST ITERATION GOES HERE
C
      CALL RNCSTR(NSTR,CSTR,XFACTOR,CNORM,MELX,NPHI)
C
C     TODO: MODIFY THIS
C
      NSIZE = MW - MGG
      CALL READ1E(IAO1E,W(MSS),W(MHH),NBASIS)
C
C     COPY DENSITY OF CORE TO WORKING FILED G(MMT3)
C
      DO I=1,NBASIS*(NBASIS+1)/2
      W(MMT3-1+I)=DMP(I)
      END DO
      IHFPO = 1
C     TIME=XCLOCK()
      REWIND(IVBO2E)
      CALL TRAN1E(NBASIS,NORB,W(MSS),W(MHH),
     &     WBASIS,W(MMT1),W(MMT2),W(MMT3),IHFPO,IVBO2E)
      CALL TRANP2E(NBASIS,NORB,0,WBASIS,W(MGG),NSIZE,LBUFF,
     &             IOTEMPA,IOTEMPB)
C
C     SAVE A COPY OF H,S,G OF THE FIRST ITERATION
C
      CALL SHREAD(W(NADDS),W(NADDH),MSQ,IVBO2E)
      CALL GREAD(W(NADDG),MGSQ,LBUFF,IVBO2E)
      CALL DSTORE(0,1,MSQ,2, INTDAT, W(NADDS))
      CALL DSTORE(0,1,MSQ,3, INTDAT, W(NADDH))
      CALL DSTORE(0,1,MGSQ,4,INTDAT, W(NADDG))
C     CALL DSTORE(0,1,NBASIS*NORB,5,INTDAT, WBASIS)
        IF(NBASIS*NORB.GT.20000) CALL ABORT0("BASIS10000")
        DO I=1, NORB*NORB
        ORBLOC(I)=0.0D0
        END DO
        DO I=1, NORB
        II = (I-1)*NORB+I
        ORBLOC(II) = 1.0D0
        END DO
        DO I=1, NBASIS*NORB
        BASIS0(I) = WBASIS(I)
        END DO
      ELSE
        CALL DSTORE(0,0,MSQ,2, INTDAT, W(NADDS))
        CALL DSTORE(0,0,MSQ,3, INTDAT, W(NADDH))
        CALL DSTORE(0,0,MGSQ,4,INTDAT, W(NADDG))
      TIME=XCLOCK()
      I = NINT(TIME)
      REWIND(IVBO2E)
      IHFPO = 0
      CALL TRAN1E(NORB,NORB,W(NADDS),W(NADDH),ORBLOC,W(MMX1),W(MMX2),
     &            DUMMY,IHFPO,IVBO2E)
      CALL TRANN2E(NORB,NORB,0,W(NADDG),ORBLOC,W(MMX1),W(MMX2),W(MMX3),
     &             LBUFF,IVBO2E)
      END IF
C     TIME1=XCLOCK()
C     TIME=TIME1-TIME
C     WRITE(IOUTVB,'(' 2E-TRAN TIME FOR VBSCF=',F8.3)')TIME
      CALL SHREAD(W(NADDS),W(NADDH),MSQ,IVBO2E)
      CALL GREAD(W(NADDG),MGSQ,LBUFF,IVBO2E)
      IF(ITER.EQ.1) CALL VBDIISINIT(NDIISMAX,NDIISS,W(NADDS),MSQ)
C
C     DERIVATIVES AND HESSIAN
C     IF(IDERANK.EQ.2), THEN HESSAIN WILL BE RE-COMPUTED
C     OTHERWISE, THE HESSIAN FROM PREVIOUS ITERATION WILL BE USED
C
C
      IDERANK=2
      IF(ICONV.EQ.1) IDERANK=1
      IF(ITER.GT.1.AND.CMAX.LT.CMAXCUT.AND.DECREASE) IDERANK=1
      IF(ITER.GT.1.AND.CMAX.LT.CMAXCUT.AND.IDIIS.EQ.1) IDERANK=1
C     TIME1=XCLOCK()
      CALL VBHESS(N,NS,NSTR,NASTR,CSTR,NORB,NBRIL,
     & NBTAB,NOTAB,W(NADDS),W(NADDH),W(NADDG),W(NADDVBS),W(NADDVBH),
     & DMLOC,DM2LOC,W(NADDM),W(NADDHESS),W(NADDSS),W(NADDAG),DEV1,
     & IDERANK,ENG2,NREM1)
C     CALL VBHESS(N,NS,NSTR,NASTR,CSTR,NORB,NOCORB,NBRIL,
C    & NBTAB,NOTAB,W(NADDS),W(NADDH),W(NADDG),W(NADDVBS),W(NADDVBH),
C    & DMLOC,DM2LOC,W(NADDM),W(NADDHESS),W(NADDSS),W(NADDAG),DEV1,
C    & IDERANK,ENG2,NREM1,FLAG)
C
C     OPTIONALLY ADD DELOCALIZATION PENALTY
C
      LPENADD1 = NADDAG
      LPENADD2 = LPENADD1 + NBASIS*NBASIS
      CALL READ1E(IAO1E,W(LPENADD1),W(LPENADD2),NBASIS)
      CALL DPENALTY1(WBASIS,NORB,W(LPENADD1),NBRIL,INDX,MGRP,
     &     W(LPENADD2),DEV1,W(NADDHESS),LASTITER,ICONV,MITER,
     &     TDELOCAL,ITER)
C
C     ADD DELOCALIZATION PENALTY
C
      ENG2 = ENG2 + TDELOCAL
      IF(LDIAG.EQ.1) CALL RVB(NSTR,CSTRX,W(NADDVBS),W(NADDVBH),
     &                        W(NADDAG),NREM1,F2,FLAG,0,MGRP)
C
C
C     Fix zero eigenvalue problem due to linear dependency of CSTR
C
      CALL ZHESS(W(NADDHESS),NSTR,CSTR,NBRIL,DEV1)
C
C     APPLY BRILLOUIN MASK (CONSTRAINED ORBITAL OPTIMIZATION)
C
      CALL BRIMASK(W(NADDHESS),NSTR,NBRIL,DEV1,MASKBRI)
C     TIME1=XCLOCK()-TIME1
C     WRITE(IOUTVB,*)'TIME FOR VBHESS=',TIME1
C     WRITE(IOUTVB,*)'ENG2-ENG1=',ENG2-ENG1
      IF(ENG2-ENG1.LT.0.0D0) DECREASE=.TRUE.
C
C     HESSIAN OF PREVIOUS ITERATION CAN BE OPTIONALLY LOADED FROM
C     FILE IOHES
C
      CALL CONDEN(W(NADDHESS),W(NADDAG),DEV1,DEV,NPAR,NONLIN,IDERANK,
     & IOHES,CONSTR,ICONST)
C
      IF(NEWTON.GE.1) THEN
C
C     Fix negative eigenvalue problem before going to NR
C     Jacobi is very poor for Diag. of Large matrix
C
C     WRITE(IOUTVB,*)"DEV FROM VBHESS"
C     DO I=1, NONLIN
C       WRITE(IOUTVB,'(I5,F15.10)')I, DEV(I)
C     ENDDO
      IF(IDERANK.GE.2)
     &  CALL DIAGHER(W(NADDHESS),NONLIN,DEV,SEIG,W(NADDAG),IFIX,.FALSE.)
      IF(IFIX.EQ.1) THEN
      CALL NRDATE(NONLIN,DEV,W(NADDHESS),VECT,CMAX,ERCTL,W(NADDAG),
     &            RDAMP,SEIG,EPT,ENG1,ENG2)
      ELSE
      CALL NRGQT3(NONLIN,DEV,W(NADDHESS),VECT,CMAX,ERCTL,W(NADDAG),
     &            RGQT,BGQT,SEIG,EPT,ENG1,ENG2)
      END IF
C
C     EXPAND PARAMETERS
C
      DAMPVEC = 1.0D0
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$DAMPVEC',8,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)DAMPVEC
      DO I=1, NPAR
         VECT(I) = VECT(I)*DAMPVEC
      END DO
      CALL EXPAND(VECT,CONSTR,ICONST,NPAR)
C
C     APPLY BRI MASK
C
      DO K=1, NBRIL
      IF(MASKBRI(K).EQ.0) VECT(K) = 0.0D0
      END DO
C
C     UPDATE STRUCTURE COEFFICIENTS
        IF(LDIAG.EQ.1) THEN
          CRATE = CSTR(1)/CSTRX(1)
          DO ISTR=1,NSTR
          CSTR(ISTR)=CRATE*CSTRX(ISTR)
          END DO
        ELSE
          DO ISTR=1,NSTR
          CSTR(ISTR)=CSTR(ISTR)+VECT(NBRIL+ISTR)
          END DO
        END IF
C
C     POSSIBLE STRUCTURE COEFFICIENT SYMMETRY
C
          CALL STRSYM(CSTR,NSTR,FLAG)
      ELSE
      WRITE(IOUTVB,*)
     & 'SORRY, CONJUGATE-GRADIENT METHOD HAS BEEN TAKEN AWAY'
      CALL ABRTVB
      END IF
      IF(ICONV.NE.1) THEN
      CMAXX=1.0D0
C     CALL VBDIIS(NOCORB,NORB,NBASIS,NBRIL,INDX,W,BASIS0,WBASIS,
C    &            ORBLOC,VECT,CMAX,CNORM)
C
C     USE DEV1 AS THE MINIMIZATION TARGET FOR DIIS
C     ALSO GET WBASIS UPDATED
C
      CALL VBDIIS(NOCORB,NORB,NBASIS,NBRIL,INDX,W,BASIS0,WBASIS,
     &            ORBLOC,DEV1,VECT,CMAX,CNORM)
C
C     POSSIBLE SYMMETRY CORRECTION
C
C     MAXL = 4
      CALL SYMVBO(MGRP,MORBX,WBASIS,W,ISYMOPER,CNORM)
      IF(ISYMOPER.EQ.1) THEN
C
C     UPDATE ORBLOC: COEFFICIENTS OF WBASIS IN BASIS0
C
      IF(NORB.NE.MORBX) CALL ABORT0("LSFIT00001")
      CALL LSFIT(NBASIS,NORB,BASIS0,WBASIS,ORBLOC,W)
      ENDIF
C
      CMAXX = CMAX
      CALL RNCSTR(NSTR,CSTR,XFACTOR,CNORM,MELX,NPHI)
      IF(LPTALL.EQ.1) WRITE(IOUTVB,103) MGRP,ITER,CMAX
 103  FORMAT(' GROUP =',I3,'  ITER =',I3,' CMAX = ',F16.14)
      END IF
C     ETOT = ETOTAL + ENG2
C     TIME=XCLOCK()
C     TIME=TIME-TIME1
      IF(CMAX.GT.CMAXOLD) DECREASE=.FALSE.
      CMAXOLD=CMAX
      IF(CMAXX.GT.EPS.AND.ICONV.EQ.1) THEN
      WRITE(IOUTVB,1100)CMAXX,ITER
      END IF
      IF(CMAX.GT.EPS.AND.ITER.LT.MAXIT.AND.ICONV.NE.1) GOTO 100
C
C     DO ONE MORE ITERATION TO OBTAIN DENSITY MATRIX WITHOUT
C     UPDATING VB ORBITALS.
C
      IF(ICONV.EQ.0) THEN
      ICONV=1
      GOTO 100
      END IF
 1100 FORMAT(" VBSCF NOT CONVERGED. CMAX = ",F16.14, " AFTER ",
     &        I3," ITERATIONS")
C
C     PRINT OVERLAP MATRIX
C
      IF(LASTITER.EQ.1) THEN
      CALL SHREAD(W(NADDS),W(NADDH),MSQ,IVBO2E)
      CALL MPRINT2(NORB,W(NADDS),1,MGRP)
      END IF
C
C     NORMALIZATION AND COPY THE LOCAL DENSITY MATRIX TO DMLOC
C
      SSS=0.0D0
      DO I=1,NORB2
      DMLOC(I)=W(NADDM-1+I)
      SSS=SSS+W(NADDS+I-1)*DMLOC(I)*2.0D0
      END DO
      DO I=1,NORB
      SSS=SSS-W(NADDS+IJ00(I,I)-1)*DMLOC(IJ00(I,I))
      END DO
      CN=MELX/SSS
      DO I=1,NORB2
      DMLOC(I)=DMLOC(I)*CN
      END DO
      DO I=1,NORB2*(NORB2+1)/2
      DM2LOC(I)=DM2LOC(I)*CN
      END DO
C1000 FORMAT(2X,'TOO MANY STRUCTURES FOR VBSCF,STOP.')
      SUM = 0.0D0
      IJ  = 0
      DO I=1, NSTR
      DO J=1, I
      IJ = IJ+1
      SUM = SUM +2.0D0*CSTR(I)*CSTR(J)*W(NADDVBS-1+IJ)
      END DO
      SUM = SUM - CSTR(I)*CSTR(I)*W(NADDVBS-1+IJ)
      END DO
      CNN = 1.0D0/DSQRT(SUM)
      DO I=1, NSTR
      CSTR(I) = CSTR(I)*CNN
      END DO
      ISPDEN = 0
      CALL GETCTLVAL("SPINDEN   ",CTLVAL,ISPDEN)
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$SPDEN',6,IOK,0)
      IF(IOK.EQ.1) ISPDEN = 1
C
C     CALCULATION SPIN DENSITY MATRIX
C
      IF(LASTITER.EQ.1.AND.NS.GT.0.AND.ISPDEN.EQ.1) THEN
         CALL SPDEN(N,NS,NSTR,W(NADDS),NORB,NPHI,CSTR,SDM)
      END IF
      CALL LOCTOR(IOENGI,'$PRINTHS',8,IOK,0)
      IF (LASTITER.EQ.1.AND.IOK.EQ.1) THEN
        CALL MPRINT3(NSTR,W(NADDVBS),W(NADDVBH),MGRP)
      END IF
C
C     COMPUTE STRUCTURE WEIGHTS
C
      DO I=1, NSTR*(NSTR+1)/2
       W(I) = W(NADDVBS-1+I)
      END DO
      MWRK  = MW - NSTR*(NSTR+1)/2
      NADDW = NSTR*(NSTR+1)/2 + 1
      IF (LASTITER.EQ.1.AND.NSTR.GT.1) THEN
        CALL STRWEIT(NSTR,CSTR,W(1),W(NADDW),MWRK)
      END IF
      IF(LASTITER.EQ.1.AND.NS.GT.0.AND.ISPDEN.EQ.1) THEN
C
C     DENSITY CONVERSION
C
        IJ = 0
        DO I=1, NORB
          DO J=1, I
          IJ = IJ + 1
          SDM(IJ) = SDM(IJ)
          END DO
        END DO
        MADDSD=1
        MADDW = MADDSD+NBASIS*(NBASIS+1)/2
C       NB2   = NBASIS*(NBASIS+1)/2
C       NSQ   = NORB*(NORB+1)/2
        CALL MATRAN1(NORB,NBASIS,WBASIS,W(MADDW),SDM,W(MADDSD))
        CALL SPDATM(W(MADDSD),W(MADDW))
      END IF
C     WRITE(IOUTVB,'("ETOTAL FROM VBSCF = ",F20.15)')ETOT
      RETURN
      END
C==========================================================================
C
C     LHFSCF: SUBROUTINE FOR LHFSCF CALCULATIONS
C
C             QUADRATIC CONVERGENCE METHOD BASED ON NEWTON-RAPHSON
C             SCHEME. A DYNAMICALLY ADJUSTED PARAMETER IS USED TO
C             STABLIZE THE ITERATION PROCEDURE
C
C     Note:   The automatic set-up of localization specification is
C             only work good for one group of the whole molecule system
C
C     History:
C             First version: May, 2009
C
C     Author:
C             Jiabo Li
C
C===========================================================================
      SUBROUTINE LHFSCF(MELX,NBASIS,MORBX,MWINX,W,WBASIS,DMP,
     &              DMLOC,DM2LOC,MW,MGRP,FLAG,MITER,LASTITER)
C    &              DMLOC,DM2LOC,MW,ETOTAL,MGRP,FLAG,MITER,LASTITER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (NPA=4000, MAXNOB=200, MAXPAR=10000)
      CHARACTER*50 FLAG
      CHARACTER*80 VBPATH
      CHARACTER*8  BONDLAB
      LOGICAL   DECREASE
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION CONSTR(MAXPAR),ICONST(MAXPAR),MASKBRI(MAXPAR)
C     DIMENSION NBOPT(100),DM2LOC(*),BASIS0(20000)
      DIMENSION DM2LOC(*),BASIS0(20000)
      DIMENSION CNORM(5000),DEV(NPA),DMP(*),WBASIS(*),DMLOC(*)
C     DIMENSION INDX(2,NPA),DEV1(NPA),SV(NPA),VECT(NPA),VECT1(NPA)
      DIMENSION INDX(2,NPA),DEV1(NPA),VECT(NPA)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
     &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
     &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
      COMMON /VBSTR/CSTR(10000),NPHI(100000),NSTR
      COMMON /VBCTL/EPS,MAXIT,NOPT,IHESS,NEWTON,NOB(MAXNOB),NVBI(5000)
C     COMMON /IAA/IA(100000)
C     COMMON /IBB/IB(100000),MWINZ,MBORZ
C     COMMON /ICC/IC(100000)
C
C     NOTE THAT MM IS SET IN 4 SUBROUTINES AND IT MUST BE SET
C     TO THE SAME VALUE.
C
CGMS  PARAMETER (MM=500000)
C     SUFFICIENT FOR MAP FILES IN GAMESS RELEASE.
C     IF YOU USE LARGER MAP FILES FROM THE VB2000 RELEASE,
C     YOU MUST INCREASE MM.
C
C000  PARAMETER (MM=2500000)
CSMI  PARAMETER (MM=2500000)
CGAU  PARAMETER (MM=2500000)
C     SUITABLE FOR 14 ELECTRONS WITH A SINGLET MOLECULE.
C
C     IF YOU ARE GOING TO USE MORE THAN 14 ELECTRON MAP FILES,
C     YOU MUST INCREASE MM. IF THE MULTIPCITY IS GREATER THAN 1,
C     MAY ALSO NEED TO INCREASE MM. 
C     A WARNING WILL BE GIVEN IF MM IS NOT LARGE ENOUGH.
C
C     FOR UP TO 12 ELECTRONS IN SINGLET USE - PARAMETER (MM=500000)
C     FOR UP TO 14 ELECTRONS IN SINGLET USE - PARAMETER (MM=2500000)
C     FOR UP TO 16 ELECTRONS IN SINGLET USE - PARAMETER (MM=12500000)
C
C     DIMENSION NASTR(10000),INDXW(10)
      DIMENSION INDXW(10)
C     COMMON /LTAB/NTYPE,MAPINCORE,MEL,MSP,LOOKTB(6,100),NGRECD(4,100)
C     COMMON /MAP/MAP(3,MM),NALG(100),NRE(100),NAG1(100),NREC1(100),MVBM
      COMMON /MAP/MAP(3,MM),NALG(100),NRE(100),NAG1(100),MVBM
      COMMON /NBRTAB/NBTAB(10000),NOTAB(10000),INDXZ(2,1000)
      COMMON /LMODAT/VMO(500000),VLMO(500000),LMOLAB(2,1000),
     &LMOATM(5,1000),PGM(100000),ENGLMO(1000),BONDLAB(1000),MCLMO(5,80),
     &LHFLAG
      DIMENSION W(*),CSTRX(1000),XFACTOR(1000)
C     DIMENSION SDM(20000),ORBLOC(20000)
      DIMENSION ORBLOC(20000)
C     CHARACTER*80 NUMBER,MAPNNS,MAPFILE
C     NUMBER  ='0123456789'
      CMAXCUT = 0.025D0
      CMAXX   = 0.0D0
      CMAX    = 10.0D0
      LHFLAG  = 1
C
C     RETURN IMMEDIATELY IF CI_ONLY IS TRUE
C
      IF(LCIONLY.EQ.1) RETURN
C     IFLAG=0
      MVBM=0
      NORB=MWINX
      NOCORB=MORBX
      DO I=1, NSTR
      CSTRX(I) = 1.0D0
      END DO
C
C     GET IOUNITS BY NAMES
C
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL GETIOUNIT('IAO2E   ',IAO2E)
      CALL GETIOUNIT('IOMAP   ',IOMAP)
      CALL GETIOUNIT('IOHES   ',IOHES)
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL GETIOUNIT('IVBO2E  ',IVBO2E)
      CALL GETVBPATH(VBPATH)
      CALL GETCTLVAL("DIIS      ",CTLVAL,IDIIS)
      CALL LOCTOR(IOENGI,'$CMAXCUT',8,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)CMAXCUT
C
C    SCANE OCCUPIED ORBITALS
C
      NOCCORB=0
      DO I=1,MELX*NSTR
      IF(NPHI(I).GT.NOCCORB) NOCCORB=NPHI(I)
      END DO
      NOCORB=NOCCORB
C     NS=MSPX ! MSPX now removed as argument
      N=MELX
      DO K=1,NSTR*N
C     NASTR(K)=NPHI(K)
      END DO
      CALL BRITAB(NOCORB,NORB,INDX,NBRIL,NBTAB,NOTAB,MASKBRI,MITER)
      NORB2   = NORB*(NORB+1)/2
      INDXW(1)=NORB2
      INDXW(2)=NORB2
      INDXW(3)=NORB2
      CALL SETINXN(3,INDXW,NORB3)
C
C     COMPUTE ADDRESSES FOR VBHESS
C
      NWDM    = NORB2*(2+2*NSTR)+NORB2*(NORB2+1)*(2+NSTR)/2+NORB3
      NADDHESS= 1
      NADDS   = NADDHESS + (NBRIL+NSTR)*(NBRIL+NSTR+1)/2
      NADDH   = NADDS + NORB2
      NADDG   = NADDH + NORB2
      NADDVBS = NADDG + NORB2*(NORB2+1)/2
      NADDVBH = NADDVBS + NSTR*(NSTR+1)/2
      NADDM   = NADDVBH + NSTR*(NSTR+1)/2
      NADDSS  = NADDM + NWDM
      NADDAG  = NADDSS + N*NORB
      NREM1   = MW - NADDAG
      NLAST   = NADDAG
      MMX1    = NADDG + NORB2*(NORB2+1)/2
      MMX2    = MMX1 + NORB*NORB
C     MMX3    = MMX2 + NORB*NORB2
C
C     THE REMANING (NREM1) IS FOR THE SCATCH SPACE OF ALGEBRANTS IN VBHESS
C     THE MINIMAL SIZE IS A FUNCTION OF (N, NS AND IDERANK)
C     TODO: BUILD SUCH A TABLE.
C
      IF(NREM1.LT.0) CALL ABORT0('VBSCF01   ')
C     TIME1=XCLOCK()-TIME1
C1111 CONTINUE
C
C     SET CONVERGENCE FLAG TO NEGATIVE
C
      ICONV=0
      IF(NOPT.LE.0) RETURN
      IF(NSTR.GT.250) THEN
        WRITE(IOUTVB,*)"NO MORE THAN 250 VB STRUCTURES CAN BE OPTIMIZED"
        CALL ABORT0('VBSCF02   ')
      END IF
C
C     CALCUULATE THE INDEXES
C
      CALL SETIND(MWINX,MORBX)
C
C     INDEXES
C
      NPAR   = NBRIL + NSTR
      MSQ    = MWINX*(MWINX+1)/2
C     MTSQ   = NBASIS*(NBASIS+1)/2
C     MGSQ   = MSQ*(MSQ+1)/2
C     NMTSQ  = NBASIS*MTSQ
C
C     ADDRESS
C
C     THE ORDER OF MSS,MHH,MGG IS CRITICAL. IN HESSAN, HG STORE BOTH H AND G
C
      MTX    = NBASIS
      IF(NORB .GT. NBASIS) MTX = NORB
      MTXSQ  = MTX*(MTX+1)/2
      MSS    = 1
      MHH    = MSS+MTXSQ
      MGG    = MHH+MTXSQ
      MMT1   = MGG
      MMT2   = MMT1+MTX*MTX
      MMT3   = MMT2+MTX*MTXSQ
      MLAST  = MMT3+MTXSQ
      NREM2  = MW - MLAST
      IF(NREM2.LT.0) CALL ABORT0('VBSCF03   ')
C
C     MNSQ=MWINX*(MWINX+1)/2
C
C     READ CONSTRAINS FOR OPTIMIZATION (GENERAL, ORBITALS OR CSTR)
C     DETERMINE NONLINEARLY DEPENDENT PARAMETERS
C
      CALL RCONST(CONSTR,ICONST,NBRIL,NPAR,NLORBI,NLCSTR,FLAG)
      NONLIN=NLORBI+NLCSTR
C
      IFIX =1
      IF(NEWTON.GE.2) IFIX =0
      RGQT =0.1D0
      BGQT =0.9D0
      EPT  =0.0D0
      RDAMP=0.1D0
      TK   =0.1D0
      ERCTL=0.15D0
      ENG1 =0.0D0
      ENG2 =0.0D0
      DECREASE = .FALSE.
      CMAXOLD = 1000.0D0
      CALL LOCTOR(IOENGI,'$ERCTL',6,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)ERCTL
      ITER =0
      IF( LPTALL.EQ.1)
     &WRITE(IOUTVB,101) MGRP
 101  FORMAT(/' VB-ORBITAL OPTIMIZATION OF GROUP',I3,' ...')
      LDIAG = 0
C
C     VBOPT ITERATION STARTS HERE
C
      IF(MLORBIT(MGRP)*NBASIS.GT.20000) CALL ABORT0('VBSCF00001')
      NDIISS = 5
      CALL LOCTOR(IOENGI,'$DIISSTART',10,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)NDIISS
      NDIISMAX = 10
      IF(IDIIS.NE.1) NDIISS = 1000
 100  CONTINUE
      ENG2 = 0.0D0
      TK   =TK/2.0D0
      ITER =ITER+1
      CALL GETIOUNIT('IOTEMPA ',IOTEMPA)
      CALL GETIOUNIT('IOTEMPB ',IOTEMPB)
      IF(ITER.LE.1) THEN
C     LBUFF   = 4095
C     NSQ     = NORB*(NORB+1)/2
C     NSQ2    = NSQ*(NSQ+1)/2
C     NB2     = NBASIS*NBASIS
      CALL READ1E(IAO1E,W(MSS),W(MHH),NBASIS)
      CALL VBONORM(NBASIS,MLORBIT(MGRP),WBASIS,W(MSS),CNORM)
      CALL RNCSTR(NSTR,CSTR,XFACTOR,CNORM,MELX,NPHI)
C
C     TODO: MODIFY THIS
C
C     NSIZE = MW - MGG
      CALL READ1E(IAO1E,W(MSS),W(MHH),NBASIS)
C
C     COPY DENSITY OF CORE TO WORKING FILED G(MMT3)
C
      DO I=1,NBASIS*(NBASIS+1)/2
      W(MMT3-1+I)=DMP(I)
      END DO
      IHFPO = 1
C     TIME=XCLOCK()
      REWIND(IVBO2E)
      CALL TRAN1E(NBASIS,NORB,W(MSS),W(MHH),
     &     WBASIS,W(MMT1),W(MMT2),W(MMT3),IHFPO,IVBO2E)
C
C     SAVE A COPY OF H,S OF THE FIRST ITERATION
C
      CALL SHREAD(W(NADDS),W(NADDH),MSQ,IVBO2E)
      CALL DSTORE(0,1,MSQ,2, INTDAT, W(NADDS))
      CALL DSTORE(0,1,MSQ,3, INTDAT, W(NADDH))
        IF(NBASIS*NORB.GT.20000) CALL ABORT0("BASIS10000")
        DO I=1, NORB*NORB
        ORBLOC(I)=0.0D0
        END DO
        DO I=1, NORB
        II = (I-1)*NORB+I
        ORBLOC(II) = 1.0D0
        END DO
        DO I=1, NBASIS*NORB
        BASIS0(I) = WBASIS(I)
        END DO
      ELSE
        CALL DSTORE(0,0,MSQ,2, INTDAT, W(NADDS))
        CALL DSTORE(0,0,MSQ,3, INTDAT, W(NADDH))
C     TIME=XCLOCK()
      REWIND(IVBO2E)
      IHFPO = 0
      CALL TRAN1E(NORB,NORB,W(NADDS),W(NADDH),ORBLOC,W(MMX1),W(MMX2),
     &            DUMMY,IHFPO,IVBO2E)
      END IF
C     TIME1=XCLOCK()
C     TIME=TIME1-TIME
C     WRITE(IOUTVB,'(' 2E-TRAN TIME FOR VBSCF=',F8.3)')TIME
      CALL SHREAD(W(NADDS),W(NADDH),MSQ,IVBO2E)
      IF(ITER.EQ.1) CALL VBDIISINIT(NDIISMAX,NDIISS,W(NADDS),MSQ)
C
C     DERIVATIVES AND HESSIAN
C     IF(IDERANK.EQ.2), THEN HESSAIN WILL BE RE-COMPUTED
C     OTHERWISE, THE HESSIAN FROM PREVIOUS ITERATION WILL BE USED
C
C
      IDERANK=2
      IF(ICONV.EQ.1) IDERANK=1
      IF(ITER.GT.1.AND.CMAX.LT.CMAXCUT.AND.DECREASE) IDERANK=1
      IF(ITER.GT.1.AND.CMAX.LT.CMAXCUT.AND.IDIIS.EQ.1) IDERANK=1
C     TIME1=XCLOCK()
      NVAR = NBRIL + NSTR
      IJ = 0
      DO I=1, NVAR
        DEV1(I) = 0.0D0
        DO J=1, I
        IJ = IJ+1
        W(NADDHESS-1+IJ) = 0.0D0
        ENDDO
      ENDDO
C
C     OPTIONALLY ADD DELOCALIZATION PENALTY
C
      LPENADD1 = NADDAG
      LPENADD2 = LPENADD1 + NBASIS*NBASIS
      CALL READ1E(IAO1E,W(LPENADD1),W(LPENADD2),NBASIS)
      CALL DPENALTY1(WBASIS,NORB,W(LPENADD1),NBRIL,INDX,MGRP,
     &     W(LPENADD2),DEV1,W(NADDHESS),LASTITER,ICONV,MITER,
     &     TDELOCAL,ITER)
C
C     ADD TDELOCAL TO ENERGY
C
      ENG2 = ENG2 + TDELOCAL
C     WRITE(IOUTVB,*)"ENG2, TDELOCAL = ",ENG2, TDELOCAL
C
C     OVERLAP PENALTY
C
      CALL SHREAD(W(LPENADD1),W(LPENADD2),MSQ,IVBO2E)
      CALL OPENALTY(NORB,W(LPENADD1),NBRIL,INDX,MGRP,DEV1,
     &              W(NADDHESS),LASTITER,ICONV,TOVERLAP)
      ENG2 = ENG2 + TOVERLAP
C     WRITE(IOUTVB,*)"ENG2, TOVERLAP = ",ENG2, TOVERLAP
C1112 CONTINUE
      IF(LDIAG.EQ.1) CALL RVB(NSTR,CSTRX,W(NADDVBS),W(NADDVBH),
     &                        W(NADDAG),NREM1,F2,FLAG,0,MGRP)
C
C     Fix zero eigenvalue problem due to linear dependency of CSTR
C
      CALL ZHESS(W(NADDHESS),NSTR,CSTR,NBRIL,DEV1)
C
C     APPLY BRILLOUIN MASK (CONSTRAINED ORBITAL OPTIMIZATION)
C
      CALL BRIMASK(W(NADDHESS),NSTR,NBRIL,DEV1,MASKBRI)
C     TIME1=XCLOCK()-TIME1
C     WRITE(IOUTVB,*)'TIME FOR VBHESS=',TIME1
C     WRITE(IOUTVB,*)'ENG2-ENG1=',ENG2-ENG1
      IF(ENG2-ENG1.LT.0.0D0) DECREASE=.TRUE.
C
C     HESSIAN OF PREVIOUS ITERATION CAN BE OPTIONALLY LOADED FROM
C     FILE IOHES
C
      CALL CONDEN(W(NADDHESS),W(NADDAG),DEV1,DEV,NPAR,NONLIN,IDERANK,
     & IOHES,CONSTR,ICONST)
C
      IF(NEWTON.GE.1) THEN
C
C     Fix negative eigenvalue problem before going to NR
C     Jacobi is very poor for Diag. of Large matrix
C
      IF(IDERANK.GE.2)
     &  CALL DIAGHER(W(NADDHESS),NONLIN,DEV,SEIG,W(NADDAG),IFIX,.FALSE.)
      IF(IFIX.EQ.1) THEN
      CALL NRDATE(NONLIN,DEV,W(NADDHESS),VECT,CMAX,ERCTL,W(NADDAG),
     &            RDAMP,SEIG,EPT,ENG1,ENG2)
      ELSE
      CALL NRGQT3(NONLIN,DEV,W(NADDHESS),VECT,CMAX,ERCTL,W(NADDAG),
     &            RGQT,BGQT,SEIG,EPT,ENG1,ENG2)
      END IF
C
C     EXPAND PARAMETERS
C
      DAMPVEC = 1.0D0
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$DAMPVEC',8,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)DAMPVEC
      DO I=1, NBRIL
         VECT(I) = VECT(I)*DAMPVEC
      END DO
      CALL EXPAND(VECT,CONSTR,ICONST,NPAR)
C
C     APPLY BRI MASK
C
      DO K=1, NBRIL
      IF(MASKBRI(K).EQ.0) VECT(K) = 0.0D0
      END DO
C
C     UPDATE STRUCTURE COEFFICIENTS
        IF(LDIAG.EQ.1) THEN
          CRATE = CSTR(1)/CSTRX(1)
          DO ISTR=1,NSTR
          CSTR(ISTR)=CRATE*CSTRX(ISTR)
          END DO
        ELSE
          DO ISTR=1,NSTR
          CSTR(ISTR)=CSTR(ISTR)+VECT(NBRIL+ISTR)
          END DO
        END IF
C
C     POSSIBLE STRUCTURE COEFFICIENT SYMMETRY
C
          CALL STRSYM(CSTR,NSTR,FLAG)
      ELSE
      WRITE(IOUTVB,*)
     & 'SORRY, CONJUGATE-GRADIENT METHOD HAS BEEN TAKEN AWAY'
      CALL ABRTVB
      END IF
      IF(ICONV.NE.1) THEN
      CMAXX=1.0D0
      CALL VBDIIS(NOCORB,NORB,NBASIS,NBRIL,INDX,W,BASIS0,WBASIS,
     &            ORBLOC,DEV1,VECT,CMAX,CNORM)
      CMAXX = CMAX
      CALL RNCSTR(NSTR,CSTR,XFACTOR,CNORM,MELX,NPHI)
      IF(LPTALL.EQ.1) WRITE(IOUTVB,103) MGRP,ITER,CMAX
 103  FORMAT(' GROUP =',I3,'  ITER =',I3,' CMAX = ',F16.14)
      END IF
C     ETOT = ETOTAL + ENG2
C     TIME=XCLOCK()
C     TIME=TIME-TIME1
      IF(CMAX.GT.CMAXOLD) DECREASE=.FALSE.
      CMAXOLD=CMAX
      IF(CMAXX.GT.EPS.AND.ICONV.EQ.1) THEN
      WRITE(IOUTVB,1100)CMAXX,ITER
      END IF
      IF(CMAX.GT.EPS.AND.ITER.LT.MAXIT.AND.ICONV.NE.1) GOTO 100
C
C     DO ONE MORE ITERATION TO OBTAIN DENSITY MATRIX WITHOUT
C     UPDATING VB ORBITALS.
C
      IF(ICONV.EQ.0) THEN
      ICONV=1
      GOTO 100
      END IF
 1100 FORMAT(" VBSCF NOT CONVERGED. CMAX = ",F16.14, " AFTER ",
     &        I3," ITERATIONS")
C
C     PRINT OVERLAP MATRIX
C
      IF(LASTITER.EQ.1) THEN
      CALL SHREAD(W(NADDS),W(NADDH),MSQ,IVBO2E)
      CALL MPRINT2(NORB,W(NADDS),1,MGRP)
      END IF
C
C     COMPUTE DMLOC FROM S MATRIX
C
      NADDS0 = NADDH
      NADDV  = NADDS0 + NORB*NORB
      NADDSA = NADDV  + NORB*NORB
      NADDA  = NADDSA + NORB*NORB
      NADDW  = NADDA  + NORB*NORB
      NLAST  = NADDW  + NORB*NORB*5
      IF(NLAST.GT.MW) CALL ABORT0("LHFSCF0001")
      DO I=1,NORB
        DO J=1, I
          IJ = I*(I-1)/2+J
          IJ2 = (I-1)*NORB+J
          JI2 = (J-1)*NORB+I
          W(NADDS0-1+IJ2) = W(NADDS-1+IJ)
          W(NADDS0-1+JI2) = W(NADDS-1+IJ)
          W(NADDA-1+IJ2) = 0.0D0
          W(NADDA-1+JI2) = 0.0D0
        ENDDO
        W(NADDA-1+JI2) = 1.0D0
      ENDDO
      CALL LOWD(NORB,NORB,W(NADDS0),W(NADDA),W(NADDSA),
     &                         W(NADDV),W(NADDW),IERR)
      NADDM1 = NADDS0
      DO I=1, NORB2
      W(NADDM1-1+I) = 0.0D0
      ENDDO
      DO I=1, NORB
        I2 = I*(I+1)/2
        W(NADDM1-1+I2) = 2.0D0
      ENDDO
      CALL MATRAN2(NORB,NORB,W(NADDV),W(NADDW),
     &       W(NADDM1),DMLOC,0)
C
C     COMPUTE D2
C     FIRST, COMPUTE D2 in LOWDIN ORBITALS
      DO I=1,NORB2*(NORB2+1)/2
      DM2LOC(I)=0.0D0
      END DO
      DO I=1, NORB
         II = I*(I-1)/2
         I2 = I*(I+1)/2
         DO J=1, I
           IJ = II + J
           IJ2 = IJ*(IJ+1)/2
           IIJJ = I2*(I2-1)/2 + J*(J+1)/2
           FACTOR = -2.0D0
           IF(I.EQ.J) FACTOR = 1.0D0
           DM2LOC(IJ2)=FACTOR
           IF(I.NE.J) DM2LOC(IIJJ)=4.0D0
         ENDDO
      ENDDO
      NADDP  = NADDV  + NORB*NORB
      NADDT  = NADDP  + NORB*NORB
      NADDN  = NADDT  + NORB*NORB
      NADDW  = NADDN  + NORB2*(NORB2+1)/2
      NLAST  = NADDW  + NORB2*NORB
      IF(NLAST.GT.MW) CALL ABORT0("LHFSCF0002")
      CALL M4TRAN(NORB, NORB,W(NADDV),W(NADDW),W(NADDP),
     &            DM2LOC,W(NADDN),W(NADDT))
      DO I=1, NORB2*(NORB2+1)/2
         DM2LOC(I) = W(NADDN-1+I)
      ENDDO
      CSTR(1) = 1.0D0
      RETURN
      END
      SUBROUTINE BRITAB(NOCORB,NORB,INDX,NBRIL,NBTAB,NOTAB,MASKBRI
     &,MITER)
C#######################################################################
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION INDX(2,*),NBTAB(NORB,*),NOTAB(NORB,*)
      DIMENSION MASK(200,200),MASKBRI(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      IF(NOCORB.GT.200.OR.NORB.GT.200) CALL ABORT0("BRITAB0001")
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      DO I=1, NOCORB
      DO J=1, NORB
      MASK(J,I)=1
      END DO
      MASK(I,I)=0
      END DO
      CALL LOCTOR(IOENGI,"$BRILLMASK",10,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*)NMASK
        IF(MITER.EQ.1)
     &  WRITE(IOUTVB,'(" $BRILLMASK APPLIES WITH",I4," CONDITIONS")') 
     &  NMASK
        DO I=1,NMASK
        READ(IOENGI,*)J,K
        MASK(K,J)=0
        END DO
      END IF
      NBRIL=0
      DO 100 I=1,NOCORB
      JT=0
      DO 200 J=1,NORB
        IF(I.EQ.J) THEN
        NBTAB(J,I)=0
        ELSE
        NBRIL=NBRIL+1
        JT=JT+1
        NBTAB(J,I)=NBRIL
        NOTAB(JT,I)=J
        INDX(1,NBRIL)=I
        INDX(2,NBRIL)=J
          IF(NBRIL.GT.10000) CALL ABORT0("BRITAB0001")
          IF(MASK(J,I).EQ.0) THEN
            MASKBRI(NBRIL) = 0
          ELSE
            MASKBRI(NBRIL) = 1
          END IF
        END IF
 200  CONTINUE
C     WRITE(IOUTVB,*)'NOTAB(J,I)',(NOTAB(J,I),J=1,NORB-1)
 100  CONTINUE
      RETURN
      END
      SUBROUTINE LOOKUP(NWK,LPTYPE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /LTAB/NTYPE,MAPINCORE,MEL,MSP,LOOKTB(6,100),NGRECD(4,100)
      DIMENSION NWK(6)
C
C     NGRECD(1,K): THE NUMBER OF ALGEBRANTS CORRESPONDING TO
C                  THE LPNODE (OR THE LP TYPE)
C     NGRECD(2,K): THE NUMBER OF CHILD ALGEBRANTS FROM THIS LP TYPE
C     NGRECD(3,K): THE RECORDS FOR THIS LPNODE (K)
C     NGRECD(4,K): THE STARTING ADDRESS FOR THIS LP TYPE
C
C     LOOKUP FOR LPTYPE OF NW, IF NOT FOUND, ADD IT INTO LOOKTB
C
      IF(NWK(1).GT.NWK(4)) THEN
      WRITE(IOUTVB,*)'WRONG DATA, STOP'
      CALL ABRTVB
      END IF
      DO 100 I=1,NTYPE
         DO K=1,6
         IF(NWK(K).NE.LOOKTB(K,I)) GOTO 100
         END DO
      LPTYPE=I
      RETURN
  100 CONTINUE
      NTYPE=NTYPE+1
      DO K=1,6
      LOOKTB(K,NTYPE)=NWK(K)
      END DO
      LPTYPE=NTYPE
C     WRITE(IOUTVB,'('NEW TYPE',I10,6I8)')NTYPE,(LOOKTB(K,NTYPE),K=1,6)
      RETURN
      END
      SUBROUTINE GSYMBO(N,NS,NASTR,NSTR,KTNODE,NODES,IDERANK,MAXNODE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (NW1=1000000)
      DIMENSION NASTR(N,*),NW(NW1),NPATN(NW1),KTNODE(*)
      NWK=1
      DO K=1,IDERANK+2
      IF(K.GT.N) GOTO 100
      NK=NCOMBI(N,K)
      DO I=1,NSTR
      IF(K.EQ.0) CALL GSYM00(N,NS,NASTR(1,I),NPATN(NWK),I)
      IF(K.EQ.1) CALL GSYM01(N,NS,1,NASTR(1,I),NPATN(NWK),I)
      IF(K.EQ.2) CALL GSYM02(N,NS,2,NASTR(1,I),NPATN(NWK),I)
      IF(K.EQ.3) CALL GSYM03(N,NS,3,NASTR(1,I),NPATN(NWK),I)
      IF(K.EQ.4) CALL GSYM04(N,NS,4,NASTR(1,I),NPATN(NWK),I)
      NWK=NWK+NK*(N+5)
      IF(NWK.GT.NW1) CALL ABORT0('GSYMBO01  ')
      END DO
      END DO
 100  CONTINUE
      NSET=NWK/(N+5)
      CALL BTSORT(N,NS,NSET,NPATN,NW,KTNODE,NODES,MAXNODE)
      RETURN
      END
      SUBROUTINE BTSORT(N,NS,NSET,NPATN,NW,KTNODE,NODES,MAXNODE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPATN(N+5,*),NW(N,*),NWK(100),KTNODE(5,*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      J=NSET
  5   IF(J.LE.1) GOTO 20
      J=J/2
      NMJ=NSET-J
  8   IFLAG=0
      DO 10 I=1,NMJ
      L=I+J
      IF(IBTDIFF(NPATN(1,I),NPATN(1,L),N).LE.0) GOTO 10
      CALL INTEQU(NWK,NPATN(1,I),N+5)
      CALL INTEQU(NPATN(1,I),NPATN(1,L),N+5)
      CALL INTEQU(NPATN(1,L),NWK,N+5)
      IFLAG=1
  10  CONTINUE
      IF(IFLAG.EQ.1) GOTO 8
      GOTO 5
 20   CONTINUE
      DO KR=N,1,-1
      KCOUNT=1
      NW(KR,1)=KCOUNT
      DO I=1,NSET-1
      KDIFF=KBTDIFF(NPATN(1,I),NPATN(1,I+1),N,KR)
      IF(KDIFF.EQ.0) THEN
      NW(KR,I+1)=KCOUNT
      ELSE IF(KDIFF.LT.0) THEN
      KCOUNT=KCOUNT+1
      NW(KR,I+1)=KCOUNT
      ELSE
      WRITE(IOUTVB,*)'WRONG RESULTS'
      END IF
      END DO
      END DO
      CALL TRNODE(NPATN,NW,NSET,N,NS,KTNODE,NODES,MAXNODE)
      RETURN
      END
      SUBROUTINE TRNODE(NPATN,NW,NGRP,N,NS,KTNODE,NODES,MAXNODE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPATN(N+5,*),NW(N,*),KTNODE(5,*)
      DIMENSION NWK(100),LPW(6)
      COMMON /AGCODE/NPK1,NPK2,NPK3
      DO I=1,N
      NWK(I)=0
      END DO
      NODES=0
      DO 100 K=1,NGRP
      KRANK=NPATN(N+5,K)
        DO 200 I=1,N
        NI=N-I+1
        NPARITY =1
        IDCHID=1
        IDTHIS=0
C       CALL BTYPE(NPATN(1,K),N,NS,NI-1,NSH,NBH,NPA)
C       CALL BTYPE(NPATN(1,K),N,NS,NI,NSL,NBL,NPA)
        CALL BTYPE(NPATN(1,K),N,NI-1,NSH,NBH,NPA)
        CALL BTYPE(NPATN(1,K),N,NI,NSL,NBL,NPA)
        IF(NI.LE.N) IDTHIS=NW(NI,K)
        IF(NI.GT.1) IDCHID=NW(NI-1,K)
        IRANKL=I-1
        IRANKH=I
        IDEN =0
C
C       SPECIAL CASE: THe LAST STEP FOR THE LAPLACE EXPANSION FOR
C       THIS NPATN
C
        IF(NI.EQ.KRANK) THEN
        IDEN=1
        IRANKH=N
        NSH=NS
        NBH=0
        N2=MOD(NPATN(N+3,K),2)
        IF(N2.EQ.1) NPARITY=-1
C
C        SUBCASE 1: KRANK=4
C        PACK a,b,c,d
C
         IF(KRANK.EQ.4) THEN
         IA=NPATN(1,K)
         IB=NPATN(2,K)
         IC=NPATN(3,K)
         ID=NPATN(4,K)
         IABCD=IA+IB*NPK1+IC*NPK2+ID*NPK3
         END IF
         IF(KRANK.EQ.3) THEN
         IA=NPATN(1,K)
         IB=NPATN(2,K)
         IC=NPATN(3,K)
         IABCD=IA+IB*NPK1+IC*NPK2
         END IF
         IF(KRANK.EQ.2) THEN
         IA=NPATN(1,K)
         IB=NPATN(2,K)
         IABCD=IA+IB*NPK1
         END IF
         IF(KRANK.EQ.1) THEN
         IA=NPATN(1,K)
         IABCD=IA
         END IF
        IDTHIS=NPATN(N+4,K)
        ELSE
C
C       SKIP IT IF IT IS AVAILABLE
C
        IF(IDTHIS.LE.NWK(I)) GOTO 200
        IABCD=NPATN(NI,K)
        END IF
      NODES=NODES+1
      IF(NODES.GT.MAXNODE) CALL ABORT0('TRNODE01  ')
      LPW(1)=IRANKL
      LPW(4)=IRANKH
      LPW(2)=NSL
      LPW(3)=NBL
      LPW(5)=NSH
      LPW(6)=NBH
      IF(IRANKH.GE.N) IDTHIS=NPATN(N+4,K)
      CALL LOOKUP(LPW,ITYPE)
      KTNODE(1,NODES)=IABCD
      KTNODE(2,NODES)=ITYPE
      KTNODE(3,NODES)=IDTHIS*NPARITY
      KTNODE(4,NODES)=IDCHID
      KTNODE(5,NODES)=IDEN
      IF(IDEN.EQ.1) GOTO 100
      NWK(I)=IDTHIS
  200 CONTINUE
  100 CONTINUE
      RETURN
      END
C
C     DETERMINE NSA,NBA,NPA of THE N-K SUBSET
C
C     SUBROUTINE BTYPE(NPATN,N,NS,K,NSA,NBA,NPA)
      SUBROUTINE BTYPE(NPATN,N,K,NSA,NBA,NPA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPATN(N+5)
      NUPSA=NPATN(N+1)
      NUPBA=NPATN(N+2)
      LRNKA=NPATN(N+5)
      NSA=NUPSA
      NBA=NUPBA
      NPA=(N-K-NSA-NBA)/2
      IF(K.LE.LRNKA) RETURN
      NBA=N-K-((N-K)/2)*2
      IF(K.LE.LRNKA+NUPSA) THEN
      NSA=LRNKA+NUPSA-K
      NBA=NUPBA
      ELSE IF(K.LE.LRNKA+NUPSA+NUPBA) THEN
      NBA=LRNKA+NUPSA+NUPBA-K
      NSA=0
      ELSE
      NSA=0
      END IF
      NPA=(N-K-NSA-NBA)/2
      RETURN
      END
      INTEGER FUNCTION KBTDIFF(NPATNA,NPATNB,N,KR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPATNA(N+5),NPATNB(N+5)
      KBTDIFF=0
      NUPSA=NPATNA(N+1)
      NUPBA=NPATNA(N+2)
      LRNKA=NPATNA(N+5)
      NUPSB=NPATNB(N+1)
      NUPBB=NPATNB(N+2)
      LRNKB=NPATNB(N+5)
      DO K=N,KR,-1
      IF(K.LE.LRNKA.AND.K.LE.LRNKB) RETURN
      IF(K.LE.LRNKA) THEN
      KBTDIFF=1
      RETURN
      END IF
      IF(K.LE.LRNKB) THEN
      KBTDIFF=-1
      RETURN
      END IF
      NUPBAA=N-K+1-((N-K+1)/2)*2
      NUPBBB=NUPBAA
      NUPSAA=0
      NUPSBB=0
      IF(K.LE.LRNKA+NUPSA) THEN
      NUPSAA=LRNKA+NUPSA-K
      NUPBAA=NUPBA
      ELSE IF(K.LE.LRNKA+NUPSA+NUPBA) THEN
      NUPSAA=0
      NUPBAA=LRNKA+NUPSA+NUPBA-K
      END IF
      IF(K.LE.LRNKB+NUPSB) THEN
      NUPBBB=NUPBB
      NUPSBB=LRNKB+NUPSB-K
      ELSE IF(K.LE.LRNKB+NUPSB+NUPBB) THEN
      NUPSBB=0
      NUPBBB=LRNKB+NUPSB+NUPBB-K
      END IF
      IF(NUPSAA.GT.NUPSBB) THEN
      KBTDIFF=1
      RETURN
      END IF
      IF(NUPSAA.LT.NUPSBB) THEN
      KBTDIFF=-1
      RETURN
      END IF
      IF(NUPBAA.GT.NUPBBB) THEN
      KBTDIFF=1
      RETURN
      END IF
      IF(NUPBAA.LT.NUPBBB) THEN
      KBTDIFF=-1
      RETURN
      END IF
      IF(NPATNA(K).GT.NPATNB(K)) THEN
      KBTDIFF=1
      RETURN
      END IF
      IF(NPATNA(K).LT.NPATNB(K)) THEN
      KBTDIFF=-1
      RETURN
      END IF
      END DO
      RETURN
      END
      INTEGER FUNCTION IBTDIFF(NPATNA,NPATNB,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPATNA(N+5),NPATNB(N+5)
      IBTDIFF=0
      NUPSA=NPATNA(N+1)
      NUPBA=NPATNA(N+2)
      LRNKA=NPATNA(N+5)
      NUPSB=NPATNB(N+1)
      NUPBB=NPATNB(N+2)
      LRNKB=NPATNB(N+5)
C     WRITE(IOUTVB,*)'IBTDIFF CALLED'
      DO K=N,1,-1
      IF(K.LE.LRNKA.AND.K.LE.LRNKB) RETURN
      IF(K.LE.LRNKA) THEN
      IBTDIFF=1
      RETURN
      END IF
      IF(K.LE.LRNKB) THEN
      IBTDIFF=-1
      RETURN
      END IF
      NUPBAA=N-K+1-((N-K+1)/2)*2
      NUPBBB=NUPBAA
      NUPSAA=0
      NUPSBB=0
      IF(K.LE.LRNKA+NUPSA) THEN
      NUPSAA=LRNKA+NUPSA-K
      NUPBAA=NUPBA
      ELSE IF(K.LE.LRNKA+NUPSA+NUPBA) THEN
      NUPSAA=0
      NUPBAA=LRNKA+NUPSA+NUPBA-K
      END IF
      IF(K.LE.LRNKB+NUPSB) THEN
      NUPBBB=NUPBB
      NUPSBB=LRNKB+NUPSB-K
      ELSE IF(K.LE.LRNKB+NUPSB+NUPBB) THEN
      NUPSBB=0
      NUPBBB=LRNKB+NUPSB+NUPBB-K
      END IF
      IF(NUPSAA.GT.NUPSBB) THEN
      IBTDIFF=1
      RETURN
      END IF
      IF(NUPSAA.LT.NUPSBB) THEN
      IBTDIFF=-1
      RETURN
      END IF
      IF(NUPBAA.GT.NUPBBB) THEN
      IBTDIFF=1
      RETURN
      END IF
      IF(NUPBAA.LT.NUPBBB) THEN
      IBTDIFF=-1
      RETURN
      END IF
      IF(NPATNA(K).GT.NPATNB(K)) THEN
      IBTDIFF=1
      RETURN
      END IF
      IF(NPATNA(K).LT.NPATNB(K)) THEN
      IBTDIFF=-1
      RETURN
      END IF
      END DO
      RETURN
      END
C     SUBROUTINE GSYM00(N,NS,NK,NASTR,NPATN,NSTRUC)
      SUBROUTINE GSYM00(N,NS,NASTR,NPATN,NSTRUC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     DIMENSION NPAIR(100),NWK(100),NASTR(N),NPATN(N+5,*)
      DIMENSION NASTR(N),NPATN(N+5,*)
C
C     DATA STRUCTURE
C
C          NPATN(N+1): NUMBER OF UNPAIRED SPINS IN THE (N-NK) SUBSET
C          NPATN(N+2): NUMBER OF UNPAIRED ORBITALS IN THE (N-NK) SUBSET
C          NPATN(N+3): PARITY DUE TO THE REORDER OF THE UNPAIRED SPINS
C          NPATN(N+4): # OF VB STRUCTURE THAT THE <B| OF THE ALGEBRANTS
C          NPATN(N+5): THE RANK OF THE FINAL ALGEBRANT-COFACTOR
C
      DO M=1,N
      NPATN(M,1)=NASTR(M)
      END DO
      IJK=1
C
C     SET TYPES AND PARITY
C
      NPATN(N+1,IJK)=NS
      NPATN(N+2,IJK)=0
      NPATN(N+3,IJK)=0
      NPATN(N+4,IJK)=NSTRUC
      NPATN(N+5,IJK)=0
C
C     REORDER TO STANDARD FORM
C
      CALL STDFOM(NPATN(1,IJK),N,0,NS)
      RETURN
      END
      SUBROUTINE GSYM01(N,NS,NK,NASTR,NPATN,NSTRUC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPAIR(100),NWK(100),NASTR(N),NPATN(N+5,*)
C
C     DATA STRUCTURE
C
C          NPATN(N+1): NUMBER OF UNPAIRED SPINS IN THE (N-NK) SUBSET
C          NPATN(N+2): NUMBER OF UNPAIRED ORBITALS IN THE (N-NK) SUBSET
C          NPATN(N+3): PARITY DUE TO THE REORDER OF THE UNPAIRED SPINS
C          NPATN(N+4): # OF VB STRUCTURE THAT THE <B| OF THE ALGEBRANTS
C          NPATN(N+5): THE RANK OF THE FINAL ALGEBRANT-COFACTOR
C
      DO I=N-NS+1,N
      NPAIR(I)=0
      END DO
      DO J=1,(N-NS)/2
      J1=J+J-1
      J2=J1+1
      NPAIR(J1)=J2
      NPAIR(J2)=J1
      END DO
      IJK=0
      DO I=1,N
      IJK=IJK+1
        DO M=1,N
        NWK(M)=NASTR(M)
        END DO
      NWK(I)=0
C
C     COLLECT UPAIRED SPINS AND ORBITALS
C
      NUPS=0
      NUPB=0
C     NP  =0
      NPARITY=0
      IF(NPAIR(I).EQ.0) THEN
      NUPS=NUPS+1
      NPATN(NUPS,IJK)=NASTR(I)
      NPARITY=NPARITY+I-NUPS
      ELSE
C     IF(NPAIR(I).GT.0) THEN
      NUPB=NUPB+1
      NPATN(NUPS+NUPB,IJK)=NASTR(I)
      NPATN(NK+NS-NUPS+NUPB,IJK)=NASTR(NPAIR(I))
      NWK(NPAIR(I))=0
      END IF
C
C     COLLECT UPAIRED SPINS FOR THE (N-NK) SET
C
      N1S=0
      DO M=N-NS+1,N
      IF(NWK(M).NE.0) THEN
      N1S=N1S+1
      NPATN(NK+N1S,IJK)=NASTR(M)
      NWK(M)=0
      END IF
      END DO
      NSTART=1+(NS-NUPS)+NUPB
      DO M=1,N
        IF(NWK(M).NE.0) THEN
        NSTART=NSTART+1
        NPATN(NSTART,IJK)=NASTR(M)
        END IF
      END DO
C
C     SET TYPES AND PARITY
C
      NPATN(N+1,IJK)=NS-NUPS
      NPATN(N+2,IJK)=NUPB
      NPATN(N+3,IJK)=NPARITY
      NPATN(N+4,IJK)=NSTRUC
      NPATN(N+5,IJK)=1
C
C     REORDER TO STANDARD FORM
C
      CALL STDFOM(NPATN(1,IJK),N,1,NS)
      END DO
      RETURN
      END
      SUBROUTINE GSYM02(N,NS,NK,NASTR,NPATN,NSTRUC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPAIR(100),NWK(100),NASTR(N),NPATN(N+5,*)
C
C     DATA STRUCTURE
C
C          NPATN(N+1): NUMBER OF UNPAIRED SPINS IN THE (N-NK) SUBSET
C          NPATN(N+2): NUMBER OF UNPAIRED ORBITALS IN THE (N-NK) SUBSET
C          NPATN(N+3): PARITY DUE TO THE REORDER OF THE UNPAIRED SPINS
C          NPATN(N+4): # OF VB STRUCTURE THAT THE <B| OF THE ALGEBRANTS
C
      DO I=N-NS+1,N
      NPAIR(I)=0
      END DO
      DO J=1,(N-NS)/2
      J1=J+J-1
      J2=J1+1
      NPAIR(J1)=J2
      NPAIR(J2)=J1
      END DO
      IJK=0
      DO I=1,N-1
      DO J=I+1,N
      IJK=IJK+1
        DO M=1,N
        NWK(M)=NASTR(M)
        END DO
      NWK(I)=0
      NWK(J)=0
C
C     COLLECT UPAIRED SPINS AND ORBITALS
C
      NUPS=0
      NUPB=0
      NP  =0
      NPARITY=0
      IF(NPAIR(I).EQ.0) THEN
      NUPS=NUPS+1
      NPATN(NUPS,IJK)=NASTR(I)
      NPARITY=NPARITY+I-NUPS
      END IF
      IF(NPAIR(J).EQ.0) THEN
      NUPS=NUPS+1
      NPATN(NUPS,IJK)=NASTR(J)
      NPARITY=NPARITY+J-NUPS
      END IF
      IF(NPAIR(I).GT.0.AND.NPAIR(I).NE.J) THEN
      NUPB=NUPB+1
      NPATN(NUPS+NUPB,IJK)=NASTR(I)
      NPATN(NK+NS-NUPS+NUPB,IJK)=NASTR(NPAIR(I))
      NWK(NPAIR(I))=0
      END IF
      IF(NPAIR(J).GT.0.AND.NPAIR(J).NE.I) THEN
      NUPB=NUPB+1
      NPATN(NUPS+NUPB,IJK)=NASTR(J)
      NPATN(NK+NS-NUPS+NUPB,IJK)=NASTR(NPAIR(J))
      NWK(NPAIR(J))=0
      END IF
C
C     COLLECT UPAIRED SPINS FOR THE (N-NK) SET
C
      N2S=0
      DO M=N-NS+1,N
      IF(NWK(M).NE.0) THEN
      N2S=N2S+1
      NPATN(NK+N2S,IJK)=NASTR(M)
      NWK(M)=0
      END IF
      END DO
C
C     COLLECT ORBITAL PAIRS
C
      IF(NPAIR(I).EQ.J) THEN
      NPATN(NUPS+NUPB+NP+1,IJK)=NASTR(I)
      NPATN(NUPS+NUPB+NP+2,IJK)=NASTR(J)
      NP=NP+2
      END IF
      NSTART=2+(NS-NUPS)+NUPB
      DO M=1,N
        IF(NWK(M).NE.0) THEN
        NSTART=NSTART+1
        NPATN(NSTART,IJK)=NASTR(M)
        END IF
      END DO
C
C     SET TYPES AND PARITY
C
      NPATN(N+1,IJK)=NS-NUPS
      NPATN(N+2,IJK)=NUPB
      NPATN(N+3,IJK)=NPARITY
      NPATN(N+4,IJK)=NSTRUC
      NPATN(N+5,IJK)=2
C
C     REORDER TO STANDARD FORM
C
      CALL STDFOM(NPATN(1,IJK),N,2,NS)
      END DO
      END DO
      RETURN
      END
      SUBROUTINE GSYM03(N,NS,NK,NASTR,NPATN,NSTRUC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPAIR(100),NWK(100),NASTR(N),NPATN(N+5,*)
C
C     DATA STRUCTURE
C
C          NPATN(N+1): NUMBER OF UNPAIRED SPINS IN THE (N-NK) SUBSET
C          NPATN(N+2): NUMBER OF UNPAIRED ORBITALS IN THE (N-NK) SUBSET
C          NPATN(N+3): PARITY DUE TO THE REORDER OF THE UNPAIRED SPINS
C          NPATN(N+4): # OF VB STRUCTURE THAT THE <B| OF THE ALGEBRANTS
C
      DO I=N-NS+1,N
      NPAIR(I)=0
      END DO
      DO J=1,(N-NS)/2
      J1=J+J-1
      J2=J1+1
      NPAIR(J1)=J2
      NPAIR(J2)=J1
      END DO
      IJK=0
      DO I=1,N-2
      DO J=I+1,N-1
      DO K=J+1,N
      IJK=IJK+1
        DO M=1,N
        NWK(M)=NASTR(M)
        END DO
      NWK(I)=0
      NWK(J)=0
      NWK(K)=0
C
C     COLLECT UPAIRED SPINS AND ORBITALS
C
      NUPS=0
      NUPB=0
      NP  =0
      NPARITY=0
      IF(NPAIR(I).EQ.0) THEN
      NUPS=NUPS+1
      NPATN(NUPS,IJK)=NASTR(I)
      NPARITY=NPARITY+I-NUPS
      END IF
      IF(NPAIR(J).EQ.0) THEN
      NUPS=NUPS+1
      NPATN(NUPS,IJK)=NASTR(J)
      NPARITY=NPARITY+J-NUPS
      END IF
      IF(NPAIR(K).EQ.0) THEN
      NUPS=NUPS+1
      NPATN(NUPS,IJK)=NASTR(K)
      NPARITY=NPARITY+K-NUPS
      END IF
      IF(NPAIR(I).GT.0.AND.NPAIR(I).NE.J) THEN
      NUPB=NUPB+1
      NPATN(NUPS+NUPB,IJK)=NASTR(I)
      NPATN(NK+NS-NUPS+NUPB,IJK)=NASTR(NPAIR(I))
      NWK(NPAIR(I))=0
      END IF
      IF(NPAIR(J).GT.0.AND.NPAIR(J).NE.I.AND.NPAIR(J).NE.K) THEN
      NUPB=NUPB+1
      NPATN(NUPS+NUPB,IJK)=NASTR(J)
      NPATN(NK+NS-NUPS+NUPB,IJK)=NASTR(NPAIR(J))
      NWK(NPAIR(J))=0
      END IF
      IF(NPAIR(K).GT.0.AND.NPAIR(K).NE.J) THEN
      NUPB=NUPB+1
      NPATN(NUPS+NUPB,IJK)=NASTR(K)
      NPATN(NK+NS-NUPS+NUPB,IJK)=NASTR(NPAIR(K))
      NWK(NPAIR(K))=0
      END IF
C
C     COLLECT UPAIRED SPINS FOR THE (N-NK) SET
C
      N3S=0
      DO M=N-NS+1,N
      IF(NWK(M).NE.0) THEN
      N3S=N3S+1
      NPATN(NK+N3S,IJK)=NASTR(M)
      NWK(M)=0
      END IF
      END DO
C
C     COLLECT ORBITAL PAIRS
C
      IF(NPAIR(I).EQ.J) THEN
      NPATN(NUPS+NUPB+NP+1,IJK)=NASTR(I)
      NPATN(NUPS+NUPB+NP+2,IJK)=NASTR(J)
      NP=NP+2
      END IF
      IF(NPAIR(J).EQ.K) THEN
      NPATN(NUPS+NUPB+NP+1,IJK)=NASTR(J)
      NPATN(NUPS+NUPB+NP+2,IJK)=NASTR(K)
      NP=NP+2
      END IF
      NSTART=3+(NS-NUPS)+NUPB
      DO M=1,N
        IF(NWK(M).NE.0) THEN
        NSTART=NSTART+1
        NPATN(NSTART,IJK)=NASTR(M)
        END IF
      END DO
C
C     SET TYPES AND PARITY
C
      NPATN(N+1,IJK)=NS-NUPS
      NPATN(N+2,IJK)=NUPB
      NPATN(N+3,IJK)=NPARITY
      NPATN(N+4,IJK)=NSTRUC
      NPATN(N+5,IJK)=3
C
C     REORDER TO STANDARD FORM
C
      CALL STDFOM(NPATN(1,IJK),N,3,NS)
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE GSYM04(N,NS,NK,NASTR,NPATN,NSTRUC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPAIR(100),NWK(100),NASTR(N),NPATN(N+5,*)
C
C     DATA STRUCTURE
C
C          NPATN(N+1): NUMBER OF UNPAIRED SPINS IN THE (N-4) SUBSET
C          NPATN(N+2): NUMBER OF UNPAIRED ORBITALS IN THE (N-4) SUBSET
C          NPATN(N+3): PARITY DUE TO THE REORDER OF THE UNPAIRED SPINS
C          NPATN(N+4): NOT USED YET
C
      DO I=N-NS+1,N
      NPAIR(I)=0
      END DO
      DO J=1,(N-NS)/2
      J1=J+J-1
      J2=J1+1
      NPAIR(J1)=J2
      NPAIR(J2)=J1
      END DO
      IJKL=0
      DO I=1,N-3
      DO J=I+1,N-2
      DO K=J+1,N-1
      DO L=K+1,N
      IJKL=IJKL+1
        DO M=1,N
        NWK(M)=NASTR(M)
        END DO
      NWK(I)=0
      NWK(J)=0
      NWK(K)=0
      NWK(L)=0
C
C     COLLECT UPAIRED SPINS AND ORBITALS
C
      NUPS=0
      NUPB=0
      NP  =0
      NPARITY=0
      IF(NPAIR(I).EQ.0) THEN
      NUPS=NUPS+1
      NPATN(NUPS,IJKL)=NASTR(I)
      NPARITY=NPARITY+I-NUPS
      END IF
      IF(NPAIR(J).EQ.0) THEN
      NUPS=NUPS+1
      NPATN(NUPS,IJKL)=NASTR(J)
      NPARITY=NPARITY+J-NUPS
      END IF
      IF(NPAIR(K).EQ.0) THEN
      NUPS=NUPS+1
      NPATN(NUPS,IJKL)=NASTR(K)
      NPARITY=NPARITY+K-NUPS
      END IF
      IF(NPAIR(L).EQ.0) THEN
      NUPS=NUPS+1
      NPATN(NUPS,IJKL)=NASTR(L)
      NPARITY=NPARITY+L-NUPS
      END IF
      IF(NPAIR(I).GT.0.AND.NPAIR(I).NE.J) THEN
      NUPB=NUPB+1
      NPATN(NUPS+NUPB,IJKL)=NASTR(I)
      NPATN(4+NS-NUPS+NUPB,IJKL)=NASTR(NPAIR(I))
      NWK(NPAIR(I))=0
      END IF
      IF(NPAIR(J).GT.0.AND.NPAIR(J).NE.I.AND.NPAIR(J).NE.K) THEN
      NUPB=NUPB+1
      NPATN(NUPS+NUPB,IJKL)=NASTR(J)
      NPATN(4+NS-NUPS+NUPB,IJKL)=NASTR(NPAIR(J))
      NWK(NPAIR(J))=0
      END IF
      IF(NPAIR(K).GT.0.AND.NPAIR(K).NE.J.AND.NPAIR(K).NE.L) THEN
      NUPB=NUPB+1
      NPATN(NUPS+NUPB,IJKL)=NASTR(K)
      NPATN(4+NS-NUPS+NUPB,IJKL)=NASTR(NPAIR(K))
      NWK(NPAIR(K))=0
      END IF
      IF(NPAIR(L).GT.0.AND.NPAIR(L).NE.K) THEN
      NUPB=NUPB+1
      NPATN(NUPS+NUPB,IJKL)=NASTR(L)
      NPATN(4+NS-NUPS+NUPB,IJKL)=NASTR(NPAIR(L))
      NWK(NPAIR(L))=0
      END IF
C
C     COLLECT UPAIRED SPINS FOR THE (N-4) SET
C
      N4S=0
      DO M=N-NS+1,N
      IF(NWK(M).NE.0) THEN
      N4S=N4S+1
      NPATN(NK+N4S,IJKL)=NASTR(M)
      NWK(M)=0
      END IF
      END DO
C
C     COLLECT ORBITAL PAIRS
C
      IF(NPAIR(I).EQ.J) THEN
      NPATN(NUPS+NUPB+NP+1,IJKL)=NASTR(I)
      NPATN(NUPS+NUPB+NP+2,IJKL)=NASTR(J)
      NP=NP+2
      END IF
      IF(NPAIR(J).EQ.K) THEN
      NPATN(NUPS+NUPB+NP+1,IJKL)=NASTR(J)
      NPATN(NUPS+NUPB+NP+2,IJKL)=NASTR(K)
      NP=NP+2
      END IF
      IF(NPAIR(K).EQ.L) THEN
      NPATN(NUPS+NUPB+NP+1,IJKL)=NASTR(K)
      NPATN(NUPS+NUPB+NP+2,IJKL)=NASTR(L)
      NP=NP+2
      END IF
      NSTART=4+(NS-NUPS)+NUPB
      DO M=1,N
        IF(NWK(M).NE.0) THEN
        NSTART=NSTART+1
        NPATN(NSTART,IJKL)=NASTR(M)
        END IF
      END DO
C
C     SET TYPES AND PARITY
C
      NPATN(N+1,IJKL)=NS-NUPS
      NPATN(N+2,IJKL)=NUPB
      NPATN(N+3,IJKL)=NPARITY
      NPATN(N+4,IJKL)=NSTRUC
      NPATN(N+5,IJKL)=4
C
C     REORDER TO STANDARD FORM
C
      CALL STDFOM(NPATN(1,IJKL),N,4,NS)
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE STDFOM(NPATN,N,NK,NS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPATN(*)
      NKS    =NPATN(N+1)
      NKB    =NPATN(N+2)
      NPARITY=NPATN(N+3)
C
C     SORT UNPAIRED SPINS IN THE (N-NK) SUBSET
C
      DO I=1,NKS-1
      MINX=NPATN(NK+I)
      MINP=NK+I
        DO J=I+1,NKS
        IF(MINX.GT.NPATN(NK+J)) THEN
        MINX=NPATN(NK+J)
        MINP=NK+J
        END IF
        END DO
      IF(MINP.NE.NK+I) THEN
      NPARITY=NPARITY+1
      NPATN(MINP)=NPATN(NK+I)
      NPATN(NK+I)=MINX
      END IF
      END DO
C
C     SORT UNPAIRED ORBITALS IN THE (N-NK) SUBSET
C
      DO I=1,NKB-1
      MINX=NPATN(NK+NKS+I)
      MINP=NK+NKS+I
        DO J=I+1,NKB
        IF(MINX.GT.NPATN(NK+NKS+J)) THEN
        MINX=NPATN(NK+NKS+J)
        MINP=NK+NKS+J
        END IF
        END DO
      IF(MINP.NE.NK+NKS+I) THEN
      NPATN(MINP)=NPATN(NK+NKS+I)
      NPATN(NK+NKS+I)=MINX
C
C     INTERCHANGE THE CORRESPONDING UNPAIRED ORBITALS IN THE NK SUBSET
C
      MTEMP=NPATN(NS-NKS+I)
      NPATN(NS-NKS+I)=NPATN(MINP+NS-NK-2*NKS)
      NPATN(MINP+NS-NK-2*NKS)=MTEMP
      END IF
      END DO
C
C     SORT PAIRS IN THE (N-NK) SUBSET
C
      NSTART=NK+NKS+NKB
      DO I=1,(N-NSTART)/2
      I1=NSTART+I+I-1
      I2=I1+1
      IF(NPATN(I1).GT.NPATN(I2)) THEN
      NTEMP=NPATN(I2)
      NPATN(I2)=NPATN(I1)
      NPATN(I1)=NTEMP
      END IF
      END DO
      DO I=1,(N-NSTART)/2-1
      I1=NSTART+I+I-1
      MINX=NPATN(I1)
      MINP=I1
        DO J=I+1,(N-NSTART)/2
        J1=NSTART+J+J-1
        IF(MINX.GT.NPATN(J1)) THEN
        MINX=NPATN(J1)
        MINP=J1
        END IF
        END DO
        IF(MINP.NE.I1) THEN
        NTEMP=NPATN(MINP)
        NPATN(MINP)=NPATN(I1)
        NPATN(I1)=NTEMP
        NTEMP=NPATN(MINP+1)
        NPATN(MINP+1)=NPATN(I1+1)
        NPATN(I1+1)=NTEMP
        END IF
      END DO
C
      NPATN(N+3)=NPARITY
      RETURN
      END
      SUBROUTINE YANGHUI()
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /YANG/IYANG(200,20)
      DO I=1,20
      IYANG(1,I)=1
      END DO
      DO J=1,200
      IYANG(J,1)=1
      END DO
      DO I=2,20
      DO J=2,200
        IYANG(J,I)=IYANG(J-1,I)+IYANG(J,I-1)
      END DO
      END DO
      END
      FUNCTION NCOMBI(N,M)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /YANG/IYANG(200,20)
      I=N-M+1
      J=M+1
      IF(I.GT.200.OR.J.GT.20) THEN
      WRITE(IOUTVB,*)'OUT OF RANG IN NCOMBI!'
      CALL ABRTVB
      END IF
      NCOMBI=IYANG(I,J)
      RETURN
      END
      SUBROUTINE MAPADD(IOMAP,MAP,ITYPE,NADSTA,MSIZE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /LTAB/NTYPE,MAPINCORE,MEL,MSP,LOOKTB(6,100),NGRECD(4,100)
      DIMENSION MAP(3,*)
      IF(MAPINCORE.EQ.1) THEN
      NADSTA=NGRECD(4,ITYPE)+1
      RETURN
      ELSE
C
C     READ HEADER, AND CHECK ERRORS
C
      REWIND(IOMAP)
C     READ(IOMAP)NX,NSX,NSTRX
C     NX,NSX,NSTRX are not used so replace with variables that are overwritten
      READ(IOMAP) K,I,J
      DO I=1,ITYPE-1
      READ(IOMAP)
      READ(IOMAP)
      END DO
      READ(IOMAP)(NGRECD(K,ITYPE),K=1,4),(LOOKTB(K,ITYPE),K=1,6)
        IF(NGRECD(3,ITYPE).GT.MSIZE) THEN
        WRITE(IOUTVB,*)'MSIZE IS TOO SMALL, STOP'
        END IF
      READ(IOMAP)((MAP(J,I),J=1,3),I=1,NGRECD(3,ITYPE))
      NADSTA=1
      END IF
      RETURN
      END
      SUBROUTINE LOADMAP(IOMAP,N,NSPIN,NTYPE,MAPINCORE,MVBM,
     &  LOOKTB,NGRECD,MAP,MSIZE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION LOOKTB(6,100),NGRECD(4,100),MAP(3,*)
      REWIND(IOMAP)
      NTYPE=0
      NTREC=0
      MAPINCORE=1
      MAXAG = 0
C
C     READ HEADER, AND CHECK ERRORS
C
C  TMAP READ(IOMAP,*)NX,NSX,NSTRX,MVBM
C  BMAP READ(IOMAP)NX,NSX,NSTRX,MVBM
C  NSTRX is not used so replace with K which is overwritten later.
CTMAP READ(IOMAP,*)NX,NSX,K,MVBM
CBMAP READ(IOMAP)NX,NSX,K,MVBM
      IF(NX.NE.N.OR.NSX.NE.NSPIN) THEN
      WRITE(IOUTVB,*)'LOADMAP READ WRONG FILE, STOP'
      CALL ABRTVB
      END IF
 100  NT1=NTYPE+1
CTMAP READ(IOMAP,*)(NGRECD(K,NT1),K=1,4),(LOOKTB(K,NT1),K=1,6)
CBMAP READ(IOMAP)(NGRECD(K,NT1),K=1,4),(LOOKTB(K,NT1),K=1,6)
      IF(MAXAG.LT.NGRECD(1,NT1)+NGRECD(2,NT1)) THEN
         MAXAG = NGRECD(1,NT1)+NGRECD(2,NT1)
      END IF
      IF(NTYPE.GT.0) THEN
      NTEMP = NTREC + NGRECD(3,NTYPE)
      IF(NTREC+NGRECD(3,NTYPE).GT.MSIZE) THEN
      WRITE(IOUTVB,*)"NTEMP, MSIZE =",NTEMP,MSIZE
      WRITE(IOUTVB,*)'MAP_IN_CORE FAILED,SET MAP_IN_CCORE=FALSE'
      MAPINCORE=0
      END IF
      END IF
      IF(NGRECD(1,NT1).LE.0) RETURN
      NTYPE=NTYPE+1
      IF(MAPINCORE.EQ.1) THEN
CTMAP READ(IOMAP,*)((MAP(J,I+NTREC),J=1,3),I=1,NGRECD(3,NTYPE))
CBMAP READ(IOMAP)((MAP(J,I+NTREC),J=1,3),I=1,NGRECD(3,NTYPE))
      NGRECD(4,NTYPE)=NTREC
      NTREC=NTREC+NGRECD(3,NTYPE)
      ELSE
CTMAP READ(IOMAP,*)
CBMAP READ(IOMAP)
      END IF
      GOTO 100
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Laplace expansion, the core of algebrant algorithm.
C
C     History:
C               First Version created in May 1998
C               Completely revised in December 1999, so that the expression
C               is extremely simple!
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     SUBROUTINE LAPLACE(AG1,AG2,NAGH,NREC,IRANK,MAP,S)
      SUBROUTINE LAPLACE(AG1,AG2,NAGH,IRANK,MAP,S)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /INVERS/OVM(129)
      DIMENSION AG1(*),AG2(*),MAP(3,*),S(*)
      IJ=0
      DO I=1,NAGH
      AG2(I)=0.0D0
        DO J=1,IRANK
        IJ=IJ+1
        AG2(I)=AG2(I)+S(MAP(1,IJ))*OVM(65+MAP(2,IJ))*AG1(MAP(3,IJ))
        END DO
      END DO
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     VB CALCULATIONS USING ALGEBRANTS
C
C     N         NUMBER OF ELECTRONS IN VB WAVE FUNCTIONS
C     NS        NUMBER OF UNPAIRED PARALLEL SPINS (I.E. S=NS/2)
C     NORB      NUMBER OF ORBITALS FOR THE CONSTRUCTION OF VB WAVE FUNCTION
C     NSTR      NUMBER OF VB STRUCTURES
C     NASTR     ARRAY HOLDS SYMBOLIC VB STRUCTURES
C               EACH VB STRUCTURE IS REPRESENTED BY A SET OF N ORBITALS
C               (INTEGERS), UNPAIRED ORBITALS COME FIRST, FOLLOWED BY ORBITAL
C               PAIRS
C     CSTR      COEFFICIENTS OF VB STRUCTURES
C
C     SS,HH,GG  OVERLAP, ONE- AND TWO-ELECTRON INTEGRALS IN VB ORBITAL
C               BASIS
C
C     DM1       ON RETURN:
C               HOLDS THE ONE-ELECTRON DENSITY MATRIX OF THE WAVE FUNCTION
C               WHICH IS A LINEAR COMBINATION OF NSTR VB STRUCTURES WITH
C               COEFFICIENTS CSTR(i).
C               D1: LOWER TRANGULAR STORAGE
C
C     DM2       ON RETURN:
C               HOLDS THE TWO-ELECTRON DENSITY MATRIX OF THE WAVE FUNCTION
C               WHICH IS A LINEAR COMBINATION OF NSTR VB STRUCTURES WITH
C               COEFFICIENTS CSTR(i).
C               D2: M*M*(M*M+1)/2, i.e. (ij|kl), i>=<j, ij>=kl.
C               (Symmetry factor weighted)
C
C     NADD(1)   NADD for SS
C     NADD(2)   NADD for HH
C     NADD(3)   NADD for GG
C     NADD(4)   NADD for Contribution to one-electron density matrix
C     NADD(5)   NADD for Density D2
C     NADD(6)   NADD for Work field for subalgebrants
C     NADD(7)   Number of NBND records for 1-e contribution of Hessan
C     NADD(8)   Number of NBND records for 2-e contribution of Hessan
C     NADD(10)  MAX. Work field for subalgebrants
C     NREC(I)   Number of record for algebrants of the i-th order
C     NALGE(I)  Number of algebrants of the i-th order
C     N1E       Number of record for 1-electron Hamiltonian
C     N2E 	Number of records for 2-electorn Hamiltonain
C     MAP	Master map of successive Laplace expansion of algebrants
C
C     Revision history
C     July 12, 2003: Fixed a multi-VB bug with S=1/2
C     ---JLI---
C
      SUBROUTINE VBMATR(N,NS,NORB,NSTR,NASTR,CSTR,SIJ,HIJ,GIJKL,
     &  SRVB,HRVB,DM1,DM2,SS,AG,E0,MSIZE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     PARAMETER (MAXNODE=150000,MAXNB2=100000)
      PARAMETER (MAXNODE=150000)
C
C     NOTE THAT MM IS SET IN 4 SUBROUTINES AND IT MUST BE SET
C     TO THE SAME VALUE.
C
CGMS  PARAMETER (MM=500000)
C     SUFFICIENT FOR MAP FILES IN GAMESS RELEASE.
C     IF YOU USE LARGER MAP FILES FROM THE VB2000 RELEASE,
C     YOU MUST INCREASE MM.
C
C000  PARAMETER (MM=2500000)
CSMI  PARAMETER (MM=2500000)
CGAU  PARAMETER (MM=2500000)
C     SUITABLE FOR 14 ELECTRONS WITH A SINGLET MOLECULE.
C
C     IF YOU ARE GOING TO USE MORE THAN 14 ELECTRON MAP FILES,
C     YOU MUST INCREASE MM. IF THE MULTIPCITY IS GREATER THAN 1,
C     MAY ALSO NEED TO INCREASE MM. 
C     A WARNING WILL BE GIVEN IF MM IS NOT LARGE ENOUGH.
C
C     FOR UP TO 12 ELECTRONS IN SINGLET USE - PARAMETER (MM=500000)
C     FOR UP TO 14 ELECTRONS IN SINGLET USE - PARAMETER (MM=2500000)
C     FOR UP TO 16 ELECTRONS IN SINGLET USE - PARAMETER (MM=12500000)
C
C     LOGICAL MAPEXISTS
      CHARACTER*80 NUMBER,MAPNNS,VBPATH,MAPFILE
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     DIMENSION AG(*),LPW(10),INDXW(100),KTNODE(5,MAXNODE)
      DIMENSION AG(*),KTNODE(5,MAXNODE)
      DIMENSION SIJ(*),HIJ(*),GIJKL(*),CSTR(*)
C     DIMENSION IJMAP(2,MAXNB2),DM1(*),DM2(*)
      DIMENSION DM1(*),DM2(*)
C     DIMENSION NASTR(N,*),MASTR(100),SRVB(*),HRVB(*)
      DIMENSION NASTR(N,*),SRVB(*),HRVB(*)
      DIMENSION SS(N,NORB)
      COMMON /LTAB/NTYPE,MAPINCORE,MEL,MSP,LOOKTB(6,100),NGRECD(4,100)
C     COMMON /MAP/MAP(3,MM),NALG(100),NRE(100),NAG1(100),NREC1(100),MVBM
      COMMON /MAP/MAP(3,MM),NALG(100),NRE(100),NAG1(100),MVBM
      COMMON /AGCODE/NPK1,NPK2,NPK3
      COMMON /INVERS/OVM(129)
      COMMON /IAA/IAA(100000)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
     &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
     &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
      NUMBER  ='0123456789'
C
C     GET IO UNITS
C
      CALL GETIOUNIT('IOMAP   ',IOMAP)
      CALL GETVBPATH(VBPATH)
      MAPNNS='MAP/MAP'
      NC1=1+N/10
      NC2=1+N-10*(NC1-1)
      MAPNNS(8:8)=NUMBER(NC1:NC1)
      MAPNNS(9:9)=NUMBER(NC2:NC2)
      NC1=1+NS/10
      NC2=1+NS-10*(NC1-1)
      MAPNNS(10:10)=NUMBER(NC1:NC1)
      MAPNNS(11:11)=NUMBER(NC2:NC2)
      K=11
CTMAP MAPNNS(12:12)='t'
CTMAP K=12
C     Add VBPATH
      CALL PATHST(MAPFILE,VBPATH,'/               ',MAPNNS,K)
C     MAPNNS = NUMBER
      WRITE(IOUTVB,102) MAPFILE
C     WRITE(IOUTVB,102) MAPNNS
 102  FORMAT(/,' MAP FILE IS: ',A80)
      IF(MEL.NE.N.OR.MSP.NE.NS) THEN
      IF (IPNT.GT.1) CLOSE(IOMAP)
CBMAP OPEN(IOMAP,FILE=MAPFILE,STATUS='OLD',FORM='UNFORMATTED',
CBMAP&     ERR=1112)
CTMAP OPEN(IOMAP,FILE=MAPFILE,STATUS='OLD',FORM='FORMATTED',
CTMAP&     ERR=1112)
      GOTO 1111
1112  CONTINUE
      VBPATH = 'C:/VB2000NET/VB2000'
      CALL PATHST(MAPFILE,VBPATH,'/               ',MAPNNS,K)
CBMAP OPEN(IOMAP,FILE=MAPFILE,STATUS='OLD',FORM='UNFORMATTED',
CBMAP&     ERR=1113)
CTMAP OPEN(IOMAP,FILE=MAPFILE,STATUS='OLD',FORM='FORMATTED',
CTMAP&     ERR=1113)
      GOTO 1111
1113  CONTINUE
      WRITE(IOUTVB,*)"NO MAP FILE IS FOUND. THERE ARE TWO POSSIBILITIES"
      WRITE(IOUTVB,*)"1) THE JOB IS NOT RUNNING IN VB2000 DIRECTORY AND"
      WRITE(IOUTVB,*)"   VB2000PATH VARIABLE IS NOT SET "
      WRITE(IOUTVB,*)"2) THE MAP FILE IS NOT AVAILABLE FOR THIS RELEASE"
      WRITE(IOUTVB,*)"   PLEASE CONTACT US AT VB@SCINETEC.COM FOR HELP!"
      CALL ABRTVB
1111  CONTINUE

      CALL LOADMAP(IOMAP,N,NS,NTYPE,MAPINCORE,MVBM,
     &             LOOKTB,NGRECD,MAP,MM)
      MSP=NS
      MEL=N
      END IF
      DO IJ=1,NSTR*(NSTR+1)/2
      SRVB(IJ)=0.0D0
      HRVB(IJ)=0.0D0
      END DO
      NORB2=NORB*(NORB+1)/2
C
C     RESET
C
      DO I=1,NORB2
      DM1(I)=0.0D0
      END DO
      DO I=1,NORB2*(NORB2+1)/2
      DM2(I)=0.0D0
      END DO
C1000 FORMAT(10F8.5)
      IDERANK=0
      DO 100 ISTR=1,NSTR
      ISTR2=ISTR*(ISTR-1)/2
        DO J=1,NORB
        DO K=1,N
           KK = NASTR(K,ISTR)
           IF(KK.GT.J) THEN
              KKJ = IAA(KK)+ J
           ELSE
              KKJ = IAA(J) + KK
           ENDIF
           SS(K,J)=SIJ(KKJ)
        END DO
        END DO
      IF(NS.EQ.0) THEN
      CALL GSYMBO(N,NS,NASTR,ISTR,KTNODE,NODES,IDERANK,MAXNODE)
      DO 105 KT=1,NODES
      IABCD=KTNODE(1,KT)
      ITYPE=KTNODE(2,KT)
      IDTHIS=IABS(KTNODE(3,KT))
      IJVB=ISTR2+IDTHIS
      NPARITY=1
      IF(KTNODE(3,KT).LT.0) NPARITY=-1
C     IDCHID=KTNODE(4,KT)
      IDEN  =KTNODE(5,KT)
      IRANKL=LOOKTB(1,ITYPE)
      IRANKH=LOOKTB(4,ITYPE)
      IF(IDEN.NE.1) THEN
        NAGH=NGRECD(1,ITYPE)
        NAGL=NGRECD(2,ITYPE)
C       NREC=NGRECD(3,ITYPE)
        IF(IRANKL.EQ.0) THEN
        AG(1)=1.0D0
        NAG1(1)=1
        END IF
        NAG1(IRANKH+1)=NAG1(IRANKL+1)+NAGL
        NADDL=NAG1(IRANKL+1)
        NADDH=NAG1(IRANKH+1)
        IF(NADDH+NAGH.GT.MSIZE) THEN
        WRITE(IOUTVB,*)'ARRAY AG OUT OF BOUNDARY, STOP'
        WRITE(IOUTVB,*)'TOTAL, AVAILABLE=',NADDH+NAGH,MSIZE
        CALL ABRTVB
        END IF
        IA=IABCD
        CALL MAPADD(IOMAP,MAP,ITYPE,NADSTA,MM)
C
C       BE CAREFUL, <B| |K> are interchanged for convenience in LAPLACE
C       So must the last step
C
C       CALL LAPLACE(AG(NADDL),AG(NADDH),NAGH,NREC,IRANKH,
        CALL LAPLACE(AG(NADDL),AG(NADDH),NAGH,IRANKH,
     &               MAP(1,NADSTA),SS(1,IA))
          DO LX=1,NAGH
          AG(NADDH-1+LX)=AG(NADDH-1+LX)*NPARITY
          END DO
          NAG1(IRANKH+2)=NAG1(IRANKH+1)+NAGH
        ELSE
        NAGH=NGRECD(1,ITYPE)
        NAGL=NGRECD(2,ITYPE)
C       NREC=NGRECD(3,ITYPE)
        IF(IRANKL.EQ.0) THEN
        AG(1)=1.0D0
        NAG1(1)=1
        END IF
        NADD=NAG1(IRANKL+1)-1
C       ISQ1=(ISTR-1)*NORB2
C       JSQ1=(IDTHIS-1)*NORB2
C       ISQ2=(ISTR-1)*NORB2*(NORB2+1)/2
C       JSQ2=(IDTHIS-1)*NORB2*(NORB2+1)/2
        CPARITY=CSTR(ISTR)*CSTR(IDTHIS)*NPARITY
        CPA0=CSTR(ISTR)*NPARITY
        CPB0=CSTR(IDTHIS)*NPARITY
          IF(ISTR.NE.IDTHIS) THEN
          CPARITY=CPARITY+CPARITY
          CPA0=CPA0+CPA0
          CPB0=CPB0+CPB0
          END IF
        IA=IABCD
C       IF(IRANKL.EQ.0) AG(1)=1.0D0
        LCRANK=IRANKH-IRANKL
C       SUM=0.0D0
        IA=0
        IB=0
        IC=0
        ID=0
           IF(LCRANK.GE.4) THEN
           ID=IABCD/NPK3
           IABCD=IABCD-ID*NPK3
           END IF
           IF(LCRANK.GE.3) THEN
           IC=IABCD/NPK2
           IABCD=IABCD-IC*NPK2
           END IF
           IF(LCRANK.GE.2) THEN
           IB=IABCD/NPK1
           END IF
           IA=IABCD-IB*NPK1
        CALL MAPADD(IOMAP,MAP,ITYPE,NADSTA,MM)
        LX=NADSTA-1
        DO 110 IW=1,N
        I=NASTR(IW,ISTR)
C        IAI=INDXIJ(I,IA)
        IF(I.GT.IA) THEN
          IAI = IAA(I) + IA
        ELSE
          IAI = IAA(IA) + I
        ENDIF
        IF(LCRANK.EQ.1) THEN
        LX=LX+1
          DVALUE = OVM(65+MAP(2,LX))
          D11PARITY=DVALUE*CPARITY
C         CPA=CPA0*DVALUE
C         CPB=CPB0*DVALUE
          D11PAR=DVALUE*NPARITY
          DXAG=D11PARITY*AG(NADD+MAP(3,LX))
C         CPAG=CPA*AG(NADD+MAP(3,LX))
C         CPBG=CPB*AG(NADD+MAP(3,LX))
C   BUILD 1SD
          DM1(IAI)=DM1(IAI) + DXAG
C
          SRVB(IJVB)=SRVB(IJVB)+D11PAR*AG(NADD+MAP(3,LX))*SIJ(IAI)
          HRVB(IJVB)=HRVB(IJVB)+D11PAR*AG(NADD+MAP(3,LX))*HIJ(IAI)
        ELSE
          DO 120 JW=1,N
          IF(JW.EQ.IW) GOTO 120
          J=NASTR(JW,ISTR)
C          IBJ=INDXIJ(J,IB)
        IF(J.GT.IB) THEN
          IBJ = IAA(J) + IB
        ELSE
          IBJ = IAA(IB) + J
        ENDIF
          IF(LCRANK.EQ.2) THEN
          LX=LX+1
          DVALUE = OVM(65+MAP(2,LX))
          D11PARITY=DVALUE*CPARITY
C         CPA=CPA0*DVALUE
C         CPB=CPB0*DVALUE
          D11PAR=DVALUE*NPARITY
          DXAG=D11PARITY*AG(NADD+MAP(3,LX))
C         CPAG=CPA*AG(NADD+MAP(3,LX))
C         CPBG=CPB*AG(NADD+MAP(3,LX))
C   BUILD 1HD,2SD
C          IIAJIB=INDXIJ(IAI,IBJ)
        IF(IAI.GT.IBJ) THEN
          IIAJIB = IAA(IAI) + IBJ
        ELSE
          IIAJIB = IAA(IBJ) + IAI
        ENDIF
C   2SD
          DM2(IIAJIB) = DM2(IIAJIB) + DXAG
C
          HRVB(IJVB)=HRVB(IJVB)+D11PAR*AG(NADD+MAP(3,LX))*
     &         GIJKL(IIAJIB)
          ELSE
          WRITE(IOUTVB,*)'WRONG DATA, STOP'
          CALL ABRTVB
          END IF
 120  CONTINUE
      END IF
 110  CONTINUE
      END IF
 105  CONTINUE
      ELSE
      DO 107 JSTR=1, ISTR
      CALL GSYMBO(N,NS,NASTR(1,JSTR),1,KTNODE,NODES,IDERANK,MAXNODE)
      DO 107 KT=1,NODES
      IABCD=KTNODE(1,KT)
      ITYPE=KTNODE(2,KT)
      IDTHIS=JSTR
      IJVB=ISTR2+IDTHIS
      NPARITY=1
      IF(KTNODE(3,KT).LT.0) NPARITY=-1
C     IDCHID=KTNODE(4,KT)
      IDEN  =KTNODE(5,KT)
      IRANKL=LOOKTB(1,ITYPE)
      IRANKH=LOOKTB(4,ITYPE)
      IF(IDEN.NE.1) THEN
        NAGH=NGRECD(1,ITYPE)
        NAGL=NGRECD(2,ITYPE)
C       NREC=NGRECD(3,ITYPE)
        IF(IRANKL.EQ.0) THEN
        AG(1)=1.0D0
        NAG1(1)=1
        END IF
        NAG1(IRANKH+1)=NAG1(IRANKL+1)+NAGL
        NADDL=NAG1(IRANKL+1)
        NADDH=NAG1(IRANKH+1)
        IF(NADDH+NAGH.GT.MSIZE) THEN
        WRITE(IOUTVB,*)'ARRAY AG OUT OF BOUNDARY, STOP'
        WRITE(IOUTVB,*)'TOTAL, AVAILABLE=',NADDH+NAGH,MSIZE
        CALL ABRTVB
        END IF
        IA=IABCD
        CALL MAPADD(IOMAP,MAP,ITYPE,NADSTA,MM)
C
C       BE CAREFUL, <B| |K> are interchanged for convenience in LAPLACE
C       So must the last step
C
C       CALL LAPLACE(AG(NADDL),AG(NADDH),NAGH,NREC,IRANKH,
        CALL LAPLACE(AG(NADDL),AG(NADDH),NAGH,IRANKH,
     &               MAP(1,NADSTA),SS(1,IA))
          DO LX=1,NAGH
          AG(NADDH-1+LX)=AG(NADDH-1+LX)*NPARITY
          END DO
          NAG1(IRANKH+2)=NAG1(IRANKH+1)+NAGH
        ELSE
        NAGH=NGRECD(1,ITYPE)
        NAGL=NGRECD(2,ITYPE)
C       NREC=NGRECD(3,ITYPE)
        IF(IRANKL.EQ.0) THEN
        AG(1)=1.0D0
        NAG1(1)=1
        END IF
        NADD=NAG1(IRANKL+1)-1
C       ISQ1=(ISTR-1)*NORB2
C       JSQ1=(IDTHIS-1)*NORB2
C       ISQ2=(ISTR-1)*NORB2*(NORB2+1)/2
C       JSQ2=(IDTHIS-1)*NORB2*(NORB2+1)/2
        CPARITY=CSTR(ISTR)*CSTR(IDTHIS)*NPARITY
        CPA0=CSTR(ISTR)*NPARITY
        CPB0=CSTR(IDTHIS)*NPARITY
          IF(ISTR.NE.IDTHIS) THEN
          CPARITY=CPARITY+CPARITY
          CPA0=CPA0+CPA0
          CPB0=CPB0+CPB0
          END IF
        IA=IABCD
C       IF(IRANKL.EQ.0) AG(1)=1.0D0
        LCRANK=IRANKH-IRANKL
C       SUM=0.0D0
        IA=0
        IB=0
        IC=0
        ID=0
           IF(LCRANK.GE.4) THEN
           ID=IABCD/NPK3
           IABCD=IABCD-ID*NPK3
           END IF
           IF(LCRANK.GE.3) THEN
           IC=IABCD/NPK2
           IABCD=IABCD-IC*NPK2
           END IF
           IF(LCRANK.GE.2) THEN
           IB=IABCD/NPK1
           END IF
           IA=IABCD-IB*NPK1
        CALL MAPADD(IOMAP,MAP,ITYPE,NADSTA,MM)
        LX=NADSTA-1
        DO 115 IW=1,N
        I=NASTR(IW,ISTR)
C        IAI=INDXIJ(I,IA)
        IF(I.GT.IA) THEN
          IAI = IAA(I) + IA
        ELSE
          IAI = IAA(IA) + I
        ENDIF
        IF(LCRANK.EQ.1) THEN
        LX=LX+1
          DVALUE = OVM(65+MAP(2,LX))
          D11PARITY=DVALUE*CPARITY
C         CPA=CPA0*DVALUE
C         CPB=CPB0*DVALUE
          D11PAR=DVALUE*NPARITY
          DXAG=D11PARITY*AG(NADD+MAP(3,LX))
C         CPAG=CPA*AG(NADD+MAP(3,LX))
C         CPBG=CPB*AG(NADD+MAP(3,LX))
C   BUILD 1SD
          DM1(IAI)=DM1(IAI) + DXAG
C
          SRVB(IJVB)=SRVB(IJVB)+D11PAR*AG(NADD+MAP(3,LX))*SIJ(IAI)
          HRVB(IJVB)=HRVB(IJVB)+D11PAR*AG(NADD+MAP(3,LX))*HIJ(IAI)
        ELSE
          DO 125 JW=1,N
          IF(JW.EQ.IW) GOTO 125
          J=NASTR(JW,ISTR)
C          IBJ=INDXIJ(J,IB)
        IF(J.GT.IB) THEN
          IBJ = IAA(J) + IB
        ELSE
          IBJ = IAA(IB) + J
        ENDIF
          IF(LCRANK.EQ.2) THEN
          LX=LX+1
          DVALUE = OVM(65+MAP(2,LX))
          D11PARITY=DVALUE*CPARITY
C         CPA=CPA0*DVALUE
C         CPB=CPB0*DVALUE
          D11PAR=DVALUE*NPARITY
          DXAG=D11PARITY*AG(NADD+MAP(3,LX))
C         CPAG=CPA*AG(NADD+MAP(3,LX))
C         CPBG=CPB*AG(NADD+MAP(3,LX))
C   BUILD 1HD,2SD
C          IIAJIB=INDXIJ(IAI,IBJ)
        IF(IAI.GT.IBJ) THEN
          IIAJIB = IAA(IAI) + IBJ
        ELSE
          IIAJIB = IAA(IBJ) + IAI
        ENDIF
C   2SD
          DM2(IIAJIB) = DM2(IIAJIB) + DXAG
C
          HRVB(IJVB)=HRVB(IJVB)+D11PAR*AG(NADD+MAP(3,LX))*
     &         GIJKL(IIAJIB)
          ELSE
          WRITE(IOUTVB,*)'WRONG DATA, STOP'
          CALL ABRTVB
          END IF
 125  CONTINUE
      END IF
 115  CONTINUE
      END IF
 107  CONTINUE
      END IF
 100  CONTINUE
C150  CONTINUE
C250  CONTINUE
      DO IJ=1,NSTR*(NSTR+1)/2
      SRVB(IJ)=SRVB(IJ)/N
      END DO
      VBHH0=0.0D0
      VBGG0=0.0D0
      VBSSN=0.0D0
      DO I=1,NORB2
      VBHH0=VBHH0+DM1(I)*HIJ(I)
      VBSSN=VBSSN+DM1(I)*SIJ(I)
      END DO
      DO I=1,NORB2*(NORB2+1)/2
      VBGG0=VBGG0+DM2(I)*GIJKL(I)
      END DO
      S0=VBSSN/N
      E0=(VBHH0+VBGG0)/S0
C     TIME1=XCLOCK()
C2000 CONTINUE
C
C     DE-FACTORIZE THE NON-DIAGONAL 1D DENSITY MATRIX ELEMENTS
C
      DO I=1,NORB
      II=I*(I-1)/2
      DO J=1,I-1
      DM1(II+J)=DM1(II+J)*0.5D0
      END DO
      END DO
C
C     DE-FACTORIZE THE NON-SYMMETRIC ELEMENTS OF 2D DENSITY MATRIX
C
C     IDFACT=1
C     CALL DENFACA(NORB,DM2,IDFACT)
C
C     RENORMALIZATION OF BOTH DM1 AND DM2.
C
      OVS=1.0D0/S0
      DO I=1,NORB2
      DM1(I)=DM1(I)*OVS
      END DO
      DO I=1,NORB2*(NORB2+1)/2
      DM2(I)=DM2(I)*OVS
      END DO
C     TIME1=XCLOCK()-TIME1
      RETURN
      END
C
C     Revision history
C
C     July 12, 2003: Fixed a multi-VB bug with S=1/2
C     --JLI--
C
C     SUBROUTINE VBHESS(N,NSPIN,NSTR,NASTR,CSTR,NORB,NOCORB,NBRIL,
C    & NBTAB,NOTAB,SIJ,HIJ,GIJKL,SRVB,HRVB,DM1,DM2,DENSTY,HESS,SS,
C    & AG,DEVE,IDERANK,E0,MSIZE,FLAG)
      SUBROUTINE VBHESS(N,NSPIN,NSTR,NASTR,CSTR,NORB,NBRIL,
     & NBTAB,NOTAB,SIJ,HIJ,GIJKL,SRVB,HRVB,DM1,DM2,DENSTY,HESS,SS,
     & AG,DEVE,IDERANK,E0,MSIZE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*50 FLAG
      PARAMETER (MAXNODE=150000,MAXNB2=100000)
C
C     NOTE THAT MM IS SET IN 4 SUBROUTINES AND IT MUST BE SET
C     TO THE SAME VALUE.
C
CGMS  PARAMETER (MM=500000)
C     SUFFICIENT FOR MAP FILES IN GAMESS RELEASE.
C     IF YOU USE LARGER MAP FILES FROM THE VB2000 RELEASE,
C     YOU MUST INCREASE MM.
C
C000  PARAMETER (MM=2500000)
CSMI  PARAMETER (MM=2500000)
CGAU  PARAMETER (MM=2500000)
C     SUITABLE FOR 14 ELECTRONS WITH A SINGLET MOLECULE.
C
C     IF YOU ARE GOING TO USE MORE THAN 14 ELECTRON MAP FILES,
C     YOU MUST INCREASE MM. IF THE MULTIPCITY IS GREATER THAN 1,
C     MAY ALSO NEED TO INCREASE MM. 
C     A WARNING WILL BE GIVEN IF MM IS NOT LARGE ENOUGH.
C
C     FOR UP TO 12 ELECTRONS IN SINGLET USE - PARAMETER (MM=500000)
C     FOR UP TO 14 ELECTRONS IN SINGLET USE - PARAMETER (MM=2500000)
C     FOR UP TO 16 ELECTRONS IN SINGLET USE - PARAMETER (MM=12500000)
C
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /LTAB/NTYPE,MAPINCORE,MEL,MSP,LOOKTB(6,100),NGRECD(4,100)
C     COMMON /MAP/MAP(3,MM),NALG(100),NRE(100),NAG1(100),NREC1(100),MVBM
      COMMON /MAP/MAP(3,MM),NALG(100),NRE(100),NAG1(100),MVBM
      COMMON /AGCODE/NPK1,NPK2,NPK3
      COMMON /INVERS/OVM(129)
      COMMON /IAA/IAA(100000)
C     DIMENSION AG(*),LPW(10),INDXW(100),KTNODE(5,MAXNODE)
      DIMENSION AG(*),INDXW(100),KTNODE(5,MAXNODE)
      DIMENSION SIJ(*),HIJ(*),GIJKL(*),CSTR(*)
      DIMENSION DM1(*),DM2(*),DENSTY(*),IJMAP(2,MAXNB2),NBTAB(NORB,*)
C     DIMENSION NOTAB(NORB,*),HESS(*),NASTR(N,*),MASTR(100)
      DIMENSION NOTAB(NORB,*),HESS(*),NASTR(N,*)
      DIMENSION SRVB(*),HRVB(*),DEVS(1000),DEVE(*)
      DIMENSION SS(N,NORB)
      MAGSIZE = 0
C
C     IDERANK: RANK OF DERIVERTIVES.
C              0: VB MATRIX ELEMENTS ONLY
C              1: PLUS FIRST ORDER DERIVERTIVES (GRADIENT)
C              2: PLUS SECOND ORDER DERIVERTIVES (HESSIAN)
C
C     SET ADDRESSES FOR VARIOUS DENSITY MATRIXES
C
C     N1SD,N2SD,N3SD: DENSITY MATRIX ELEMENTS OF ORDER 1-3.
C     N1HD,N2HD: H-ARGUMENTED DENSITY MATRIX ELEMENTS OF ORDER 1-2.
C     M1SD,M1HD,M2SD: STRUCTURE-WEIGHTED DENSITY MATRIXES(M=1,...NSTR)
C     CARNONICAL STORAGE, i.e. ONLY SYMMETRY UNIQUE MATRIX ELEMENTS ARE
C     STORED
C     NORB: NUMBER OF ORBITALS FOR THIS VB GROUP
      NVAR=NBRIL+NSTR
      DO IJ=1,NSTR*(NSTR+1)/2
      SRVB(IJ)=0.0D0
      HRVB(IJ)=0.0D0
      END DO
      IF(IDERANK.GE.2) THEN
        DO IJ=1,NVAR*(NVAR+1)/2
        HESS(IJ)=0.0D0
        END DO
      END IF
      MLAST=NORB*(NORB+1)/2
      IF(IDERANK.GT.0) THEN
      NORB2=NORB*(NORB+1)/2
      INDXW(1)=NORB2
      INDXW(2)=NORB2
      INDXW(3)=NORB2
      CALL SETINXN(3,INDXW,NORB3)
C
C     ERROR CHECK
C
      IF(NVAR.GT.1000.OR.IAA(NORB+1).GT.MAXNB2) THEN
      WRITE(IOUTVB,*) 'NVAR = ', NVAR
      WRITE(IOUTVB,*) 'NORB = ', NORB
C     WRITE(IOUTVB,*) 'INDMAX = ', INDMAX
      WRITE(IOUTVB,*) 'NBRIL = ', NBRIL
      WRITE(IOUTVB,*)'OUT OF BOUNDARY IN HESSAN, STOP'
      CALL ABRTVB
      END IF
      DO I=1,NVAR
      DEVS(I)=0.0D0
      DEVE(I)=0.0D0
      END DO
      IJ=0
      DO I=1,NORB
      DO J=1,I
      IJ=IJ+1
      IJMAP(1,IJ)=I
      IJMAP(2,IJ)=J
      END DO
      END DO
      END IF
      N1SD=0
      N1HD=N1SD+NORB2
      N2SD=N1HD+NORB2
      N2HD=N2SD+NORB2*(NORB2+1)/2
      N3SD=N2HD+NORB2*(NORB2+1)/2
      M1SD=N3SD+NORB3
      M1HD=M1SD+NORB2*NSTR
      M2SD=M1HD+NORB2*NSTR
      MLAST=M2SD+NORB2*(NORB2+1)*NSTR/2
C
C     RESET
C
      DO I=1,MLAST
      DENSTY(I)=0.0D0
      END DO
C1000 FORMAT(10F8.5)
      IF(MVBM.GT.0) GOTO 150
C
C     MVBM=0
C
      DO 100 ISTR=1,NSTR
      ISTR2=ISTR*(ISTR-1)/2
        DO J=1,NORB
        DO K=1,N
C       SS(K,J)=SIJ(INDXIJ(NASTR(K,ISTR),J))
           KK = NASTR(K,ISTR)
           IF(KK.GT.J) THEN
              KKJ = IAA(KK)+ J
           ELSE
              KKJ = IAA(J) + KK
           ENDIF
           SS(K,J)=SIJ(KKJ)
        END DO
        END DO
      IF(NSPIN.EQ.0) THEN
      CALL GSYMBO(N,NSPIN,NASTR,ISTR,KTNODE,NODES,IDERANK,MAXNODE)
      DO 105 KT=1,NODES
      IABCD=KTNODE(1,KT)
      ITYPE=KTNODE(2,KT)
      IDTHIS=IABS(KTNODE(3,KT))
      IJVB=ISTR2+IDTHIS
      NPARITY=1
      IF(KTNODE(3,KT).LT.0) NPARITY=-1
C     IDCHID=KTNODE(4,KT)
      IDEN  =KTNODE(5,KT)
      IRANKL=LOOKTB(1,ITYPE)
      IRANKH=LOOKTB(4,ITYPE)
      IF(IDEN.NE.1) THEN
        NAGH=NGRECD(1,ITYPE)
        NAGL=NGRECD(2,ITYPE)
C       NREC=NGRECD(3,ITYPE)
        IF(IRANKL.EQ.0) THEN
        AG(1)=1.0D0
        NAG1(1)=1
        END IF
        NAG1(IRANKH+1)=NAG1(IRANKL+1)+NAGL
        NADDL=NAG1(IRANKL+1)
        NADDH=NAG1(IRANKH+1)
        IF(NADDH+NAGH.GT.MAGSIZE) MAGSIZE=NADDH+NAGH
        IF(NADDH+NAGH.GT.MSIZE) THEN
        WRITE(IOUTVB,*)'ARRAY AG OUT OF BOUNDARY, STOP'
        CALL ABRTVB
        END IF
        IA=IABCD
        CALL GETIOUNIT('IOMAP   ',IOMAP)
        CALL MAPADD(IOMAP,MAP,ITYPE,NADSTA,MM)
C
C       BE CAREFUL, <B| |K> are interchanged for convenience in LAPLACE
C       So must the last step
C
C       CALL LAPLACE(AG(NADDL),AG(NADDH),NAGH,NREC,IRANKH,
        CALL LAPLACE(AG(NADDL),AG(NADDH),NAGH,IRANKH,
     &               MAP(1,NADSTA),SS(1,IA))
          DO LX=1,NAGH
          AG(NADDH-1+LX)=AG(NADDH-1+LX)*NPARITY
          END DO
          NAG1(IRANKH+2)=NAG1(IRANKH+1)+NAGH
        ELSE
        NAGH=NGRECD(1,ITYPE)
        NAGL=NGRECD(2,ITYPE)
C       NREC=NGRECD(3,ITYPE)
        IF(IRANKL.EQ.0) THEN
        AG(1)=1.0D0
        NAG1(1)=1
        END IF
        NADD=NAG1(IRANKL+1)-1
        ISQ1=(ISTR-1)*NORB2
        JSQ1=(IDTHIS-1)*NORB2
        ISQ2=(ISTR-1)*NORB2*(NORB2+1)/2
        JSQ2=(IDTHIS-1)*NORB2*(NORB2+1)/2
        CPARITY=CSTR(ISTR)*CSTR(IDTHIS)*NPARITY
        CPA0=CSTR(ISTR)*NPARITY
        CPB0=CSTR(IDTHIS)*NPARITY
          IF(ISTR.NE.IDTHIS) THEN
          CPARITY=CPARITY+CPARITY
          CPA0=CPA0+CPA0
          CPB0=CPB0+CPB0
          END IF
        IA=IABCD
C       IF(IRANKL.EQ.0) AG(1)=1.0D0
        LCRANK=IRANKH-IRANKL
C       SUM=0.0D0
        IA=0
        IB=0
        IC=0
        ID=0
           IF(LCRANK.GE.4) THEN
           ID=IABCD/NPK3
           IABCD=IABCD-ID*NPK3
           END IF
           IF(LCRANK.GE.3) THEN
           IC=IABCD/NPK2
           IABCD=IABCD-IC*NPK2
           END IF
           IF(LCRANK.GE.2) THEN
           IB=IABCD/NPK1
           END IF
           IA=IABCD-IB*NPK1
        CALL MAPADD(IOMAP,MAP,ITYPE,NADSTA,MM)
        LX=NADSTA-1
        DO 110 IW=1,N
        I=NASTR(IW,ISTR)
C        IAI=INDXIJ(I,IA)
        IF(I.GT.IA) THEN
          IAI = IAA(I) + IA
        ELSE
          IAI = IAA(IA) + I
        ENDIF
C       INDXW(1)=IAI
        IF(LCRANK.EQ.1) THEN
        LX=LX+1
          DVALUE = 1.0D0/MAP(2,LX)
          D11PARITY=DVALUE*CPARITY
          CPA=CPA0*DVALUE
          CPB=CPB0*DVALUE
          D11PAR=DVALUE*NPARITY
          DXAG=D11PARITY*AG(NADD+MAP(3,LX))
          CPAG=CPA*AG(NADD+MAP(3,LX))
          CPBG=CPB*AG(NADD+MAP(3,LX))
C   BUILD 1SD
          DENSTY(N1SD+IAI)=DENSTY(N1SD+IAI) + DXAG
C
          DENSTY(M1SD+ISQ1+IAI)=DENSTY(M1SD+ISQ1+IAI) + CPBG
          DENSTY(M1SD+JSQ1+IAI)=DENSTY(M1SD+JSQ1+IAI) + CPAG
          SSSS=AG(NADD+MAP(3,LX))*SIJ(IAI)
          HHHH=AG(NADD+MAP(3,LX))*HIJ(IAI)
          SRVB(IJVB)=SRVB(IJVB)+SSSS*D11PAR
          HRVB(IJVB)=HRVB(IJVB)+HHHH*D11PAR
        ELSE
          DO 120 JW=1,N
          IF(JW.EQ.IW) GOTO 120
          J=NASTR(JW,ISTR)
C          IBJ=INDXIJ(J,IB)
        IF(J.GT.IB) THEN
          IBJ = IAA(J) + IB
        ELSE
          IBJ = IAA(IB) + J
        ENDIF
C         INDXW(2)=IBJ
          IF(LCRANK.EQ.2) THEN
          LX=LX+1
          DVALUE = OVM(65+MAP(2,LX))
          D11PARITY=DVALUE*CPARITY
          CPA=CPA0*DVALUE
          CPB=CPB0*DVALUE
          D11PAR=DVALUE*NPARITY
          DXAG=D11PARITY*AG(NADD+MAP(3,LX))
          CPAG=CPA*AG(NADD+MAP(3,LX))
          CPBG=CPB*AG(NADD+MAP(3,LX))
C   BUILD 1HD,2SD
C          IIAJIB=INDXIJ(IAI,IBJ)
        IF(IAI.GT.IBJ) THEN
          IIAJIB = IAA(IAI) + IBJ
        ELSE
          IIAJIB = IAA(IBJ) + IAI
        ENDIF
C   2SD
          DENSTY(N2SD+IIAJIB) = DENSTY(N2SD+IIAJIB) + DXAG
C
          DENSTY(M2SD+ISQ2+IIAJIB) = DENSTY(M2SD+ISQ2+IIAJIB) + CPBG
          DENSTY(M2SD+JSQ2+IIAJIB) = DENSTY(M2SD+JSQ2+IIAJIB) + CPAG
C   1HD
          DENSTY(N1HD+IAI) = DENSTY(N1HD+IAI) + DXAG*HIJ(IBJ)
          DENSTY(N1HD+IBJ) = DENSTY(N1HD+IBJ) + DXAG*HIJ(IAI)
C
          DENSTY(M1HD+ISQ1+IAI)=DENSTY(M1HD+ISQ1+IAI) + CPBG*HIJ(IBJ)
          DENSTY(M1HD+ISQ1+IBJ)=DENSTY(M1HD+ISQ1+IBJ) + CPBG*HIJ(IAI)
          DENSTY(M1HD+JSQ1+IAI)=DENSTY(M1HD+JSQ1+IAI) + CPAG*HIJ(IBJ)
          DENSTY(M1HD+JSQ1+IBJ)=DENSTY(M1HD+JSQ1+IBJ) + CPAG*HIJ(IAI)
          GGGG=AG(NADD+MAP(3,LX))*GIJKL(IIAJIB)
          HRVB(IJVB)=HRVB(IJVB)+GGGG*D11PAR
          ELSE
          DO 130 KW=1,N
            IF(KW.EQ.JW.OR.KW.EQ.IW) GOTO 130
            K=NASTR(KW,ISTR)
C            ICK=INDXIJ(K,IC)
        IF(K.GT.IC) THEN
          ICK = IAA(K) + IC
        ELSE
          ICK = IAA(IC) + K
        ENDIF
            INDXW(1)=IAI
            INDXW(2)=IBJ
            INDXW(3)=ICK
            IF(LCRANK.EQ.3) THEN
            LX=LX+1
            DVALUE = OVM(65+MAP(2,LX))
            DXAG=DVALUE*CPARITY*AG(NADD+MAP(3,LX))
            CPAG=CPA0*DVALUE*AG(NADD+MAP(3,LX))
            CPBG=CPB0*DVALUE*AG(NADD+MAP(3,LX))
C            IIAJIB=INDXIJ(IAI,IBJ)
        IF(IAI.GT.IBJ) THEN
          IIAJIB = IAA(IAI) + IBJ
        ELSE
          IIAJIB = IAA(IBJ) + IAI
        ENDIF
C            IIAKIC=INDXIJ(IAI,ICK)
        IF(IAI.GT.ICK) THEN
          IIAKIC = IAA(IAI) + ICK
        ELSE
          IIAKIC = IAA(ICK) + IAI
        ENDIF
C            JIBKIC=INDXIJ(IBJ,ICK)
        IF(IBJ.GT.ICK) THEN
          JIBKIC = IAA(IBJ) + ICK
        ELSE
          JIBKIC = IAA(ICK) + IBJ
        ENDIF
C
C   BUILD 3SD,2HD,1HD
C
C   3SD
            CALL SETINXN(3,INDXW,N3)
            DENSTY(N3SD+N3)=DENSTY(N3SD+N3) + DXAG
C
C   2HD
            DENSTY(N2HD+JIBKIC) = DENSTY(N2HD+JIBKIC) + DXAG*HIJ(IAI)
            DENSTY(N2HD+IIAKIC) = DENSTY(N2HD+IIAKIC) + DXAG*HIJ(IBJ)
            DENSTY(N2HD+IIAJIB) = DENSTY(N2HD+IIAJIB) + DXAG*HIJ(ICK)
C
C   1HD
C
            DENSTY(N1HD+IAI) = DENSTY(N1HD+IAI) + DXAG*GIJKL(JIBKIC)
            DENSTY(N1HD+IBJ) = DENSTY(N1HD+IBJ) + DXAG*GIJKL(IIAKIC)
            DENSTY(N1HD+ICK) = DENSTY(N1HD+ICK) + DXAG*GIJKL(IIAJIB)
C
        DENSTY(M1HD+ISQ1+IAI)=DENSTY(M1HD+ISQ1+IAI)+CPBG*GIJKL(JIBKIC)
        DENSTY(M1HD+ISQ1+IBJ)=DENSTY(M1HD+ISQ1+IBJ)+CPBG*GIJKL(IIAKIC)
        DENSTY(M1HD+ISQ1+ICK)=DENSTY(M1HD+ISQ1+ICK)+CPBG*GIJKL(IIAJIB)
C
        DENSTY(M1HD+JSQ1+IAI)=DENSTY(M1HD+JSQ1+IAI)+CPAG*GIJKL(JIBKIC)
        DENSTY(M1HD+JSQ1+IBJ)=DENSTY(M1HD+JSQ1+IBJ)+CPAG*GIJKL(IIAKIC)
        DENSTY(M1HD+JSQ1+ICK)=DENSTY(M1HD+JSQ1+ICK)+CPAG*GIJKL(IIAJIB)
            ELSE
              DO 140 LW=1,N
              IF(LW.EQ.KW.OR.LW.EQ.JW.OR.LW.EQ.IW) GOTO 140
              L=NASTR(LW,ISTR)
C              IDL=INDXIJ(L,ID)
        IF(L.GT.ID) THEN
          IDL = IAA(L) + ID
        ELSE
          IDL = IAA(ID) + L
        ENDIF
              INDXW(4)=IDL
              IF(LCRANK.EQ.4) THEN
              LX=LX+1
              DXAG=CPARITY*OVM(65+MAP(2,LX))*AG(NADD+MAP(3,LX))
C
C   BUILD 2HD
C   SIX COMBINATIONS
C
C        IIAJIB=INDXIJ(IAI,IBJ)
        IF(IAI.GT.IBJ) THEN
          IIAJIB = IAA(IAI) + IBJ
        ELSE
          IIAJIB = IAA(IBJ) + IAI
        ENDIF
C        KICLID=INDXIJ(ICK,IDL)
        IF(ICK.GT.IDL) THEN
          KICLID = IAA(ICK) + IDL
        ELSE
          KICLID = IAA(IDL) + ICK
        ENDIF
C        IIAKIC=INDXIJ(IAI,ICK)
        IF(IAI.GT.ICK) THEN
          IIAKIC = IAA(IAI) + ICK
        ELSE
          IIAKIC = IAA(ICK) + IAI
        ENDIF
C        JIBLID=INDXIJ(IBJ,IDL)
        IF(IBJ.GT.IDL) THEN
          JIBLID = IAA(IBJ) + IDL
        ELSE
          JIBLID = IAA(IDL) + IBJ
        ENDIF
C        IIALID=INDXIJ(IAI,IDL)
        IF(IAI.GT.IDL) THEN
          IIALID = IAA(IAI) + IDL
        ELSE
          IIALID = IAA(IDL) + IAI
        ENDIF
C        JIBKIC=INDXIJ(IBJ,ICK)
        IF(IBJ.GT.ICK) THEN
          JIBKIC = IAA(IBJ) + ICK
        ELSE
          JIBKIC = IAA(ICK) + IBJ
        ENDIF
        DENSTY(N2HD+IIAJIB)=DENSTY(N2HD+IIAJIB) + DXAG*GIJKL(KICLID)
        DENSTY(N2HD+IIAKIC)=DENSTY(N2HD+IIAKIC) + DXAG*GIJKL(JIBLID)
        DENSTY(N2HD+IIALID)=DENSTY(N2HD+IIALID) + DXAG*GIJKL(JIBKIC)
        DENSTY(N2HD+JIBKIC)=DENSTY(N2HD+JIBKIC) + DXAG*GIJKL(IIALID)
        DENSTY(N2HD+JIBLID)=DENSTY(N2HD+JIBLID) + DXAG*GIJKL(IIAKIC)
        DENSTY(N2HD+KICLID)=DENSTY(N2HD+KICLID) + DXAG*GIJKL(IIAJIB)
          END IF
 140      CONTINUE
          END IF
 130    CONTINUE
        END IF
 120  CONTINUE
      END IF
 110  CONTINUE
      END IF
 105  CONTINUE
      ELSE
      DO 107 JSTR=1, ISTR
      CALL GSYMBO(N,NSPIN,NASTR(1,JSTR),1,KTNODE,NODES,IDERANK,MAXNODE)
      DO 107 KT=1,NODES
      IABCD=KTNODE(1,KT)
      ITYPE=KTNODE(2,KT)
      IDTHIS=JSTR
      IJVB=ISTR2+IDTHIS
      NPARITY=1
      IF(KTNODE(3,KT).LT.0) NPARITY=-1
C     IDCHID=KTNODE(4,KT)
      IDEN  =KTNODE(5,KT)
      IRANKL=LOOKTB(1,ITYPE)
      IRANKH=LOOKTB(4,ITYPE)
      IF(IDEN.NE.1) THEN
        NAGH=NGRECD(1,ITYPE)
        NAGL=NGRECD(2,ITYPE)
C       NREC=NGRECD(3,ITYPE)
        IF(IRANKL.EQ.0) THEN
        AG(1)=1.0D0
        NAG1(1)=1
        END IF
        NAG1(IRANKH+1)=NAG1(IRANKL+1)+NAGL
        NADDL=NAG1(IRANKL+1)
        NADDH=NAG1(IRANKH+1)
        IF(NADDH+NAGH.GT.MSIZE) THEN
        WRITE(IOUTVB,*)'ARRAY AG OUT OF BOUNDARY, STOP'
        CALL ABRTVB
        END IF
        IA=IABCD
        CALL MAPADD(IOMAP,MAP,ITYPE,NADSTA,MM)
C
C       BE CAREFUL, <B| |K> are interchanged for convenience in LAPLACE
C       So must the last step
C
C       CALL LAPLACE(AG(NADDL),AG(NADDH),NAGH,NREC,IRANKH,
        CALL LAPLACE(AG(NADDL),AG(NADDH),NAGH,IRANKH,
     &               MAP(1,NADSTA),SS(1,IA))
          DO LX=1,NAGH
          AG(NADDH-1+LX)=AG(NADDH-1+LX)*NPARITY
          END DO
          NAG1(IRANKH+2)=NAG1(IRANKH+1)+NAGH
        ELSE
        NAGH=NGRECD(1,ITYPE)
        NAGL=NGRECD(2,ITYPE)
C       NREC=NGRECD(3,ITYPE)
        IF(IRANKL.EQ.0) THEN
        AG(1)=1.0D0
        NAG1(1)=1
        END IF
        NADD=NAG1(IRANKL+1)-1
        ISQ1=(ISTR-1)*NORB2
        JSQ1=(IDTHIS-1)*NORB2
        ISQ2=(ISTR-1)*NORB2*(NORB2+1)/2
        JSQ2=(IDTHIS-1)*NORB2*(NORB2+1)/2
        CPARITY=CSTR(ISTR)*CSTR(IDTHIS)*NPARITY
        CPA0=CSTR(ISTR)*NPARITY
        CPB0=CSTR(IDTHIS)*NPARITY
          IF(ISTR.NE.IDTHIS) THEN
          CPARITY=CPARITY+CPARITY
          CPA0=CPA0+CPA0
          CPB0=CPB0+CPB0
          END IF
        IA=IABCD
C       IF(IRANKL.EQ.0) AG(1)=1.0D0
        LCRANK=IRANKH-IRANKL
C       SUM=0.0D0
        IA=0
        IB=0
        IC=0
        ID=0
           IF(LCRANK.GE.4) THEN
           ID=IABCD/NPK3
           IABCD=IABCD-ID*NPK3
           END IF
           IF(LCRANK.GE.3) THEN
           IC=IABCD/NPK2
           IABCD=IABCD-IC*NPK2
           END IF
           IF(LCRANK.GE.2) THEN
           IB=IABCD/NPK1
           END IF
           IA=IABCD-IB*NPK1
        CALL MAPADD(IOMAP,MAP,ITYPE,NADSTA,MM)
        LX=NADSTA-1
        DO 115 IW=1,N
        I=NASTR(IW,ISTR)
C        IAI=INDXIJ(I,IA)
        IF(I.GT.IA) THEN
          IAI = IAA(I) + IA
        ELSE
          IAI = IAA(IA) + I
        ENDIF
C       INDXW(1)=IAI
        IF(LCRANK.EQ.1) THEN
        LX=LX+1
          DVALUE = 1.0D0/MAP(2,LX)
          D11PARITY=DVALUE*CPARITY
          CPA=CPA0*DVALUE
          CPB=CPB0*DVALUE
          D11PAR=DVALUE*NPARITY
          DXAG=D11PARITY*AG(NADD+MAP(3,LX))
          CPAG=CPA*AG(NADD+MAP(3,LX))
          CPBG=CPB*AG(NADD+MAP(3,LX))
C   BUILD 1SD
          DENSTY(N1SD+IAI)=DENSTY(N1SD+IAI) + DXAG
C
          DENSTY(M1SD+ISQ1+IAI)=DENSTY(M1SD+ISQ1+IAI) + CPBG
          DENSTY(M1SD+JSQ1+IAI)=DENSTY(M1SD+JSQ1+IAI) + CPAG
          SSSS=AG(NADD+MAP(3,LX))*SIJ(IAI)
          HHHH=AG(NADD+MAP(3,LX))*HIJ(IAI)
          SRVB(IJVB)=SRVB(IJVB)+SSSS*D11PAR
          HRVB(IJVB)=HRVB(IJVB)+HHHH*D11PAR
        ELSE
          DO 125 JW=1,N
          IF(JW.EQ.IW) GOTO 125
          J=NASTR(JW,ISTR)
C          IBJ=INDXIJ(J,IB)
        IF(J.GT.IB) THEN
          IBJ = IAA(J) + IB
        ELSE
          IBJ = IAA(IB) + J
        ENDIF
          IF(J.GT.IB) THEN
            IBJ = IAA(J) + IB
          ELSE
            IBJ = IAA(IB) + J
          ENDIF
C         INDXW(2)=IBJ
          IF(LCRANK.EQ.2) THEN
          LX=LX+1
          DVALUE = OVM(65+MAP(2,LX))
          D11PARITY=DVALUE*CPARITY
          CPA=CPA0*DVALUE
          CPB=CPB0*DVALUE
          D11PAR=DVALUE*NPARITY
          DXAG=D11PARITY*AG(NADD+MAP(3,LX))
          CPAG=CPA*AG(NADD+MAP(3,LX))
          CPBG=CPB*AG(NADD+MAP(3,LX))
C   BUILD 1HD,2SD
C          IIAJIB=INDXIJ(IAI,IBJ)
        IF(IAI.GT.IBJ) THEN
          IIAJIB = IAA(IAI) + IBJ
        ELSE
          IIAJIB = IAA(IBJ) + IAI
        ENDIF
C   2SD
          DENSTY(N2SD+IIAJIB) = DENSTY(N2SD+IIAJIB) + DXAG
C
          DENSTY(M2SD+ISQ2+IIAJIB) = DENSTY(M2SD+ISQ2+IIAJIB) + CPBG
          DENSTY(M2SD+JSQ2+IIAJIB) = DENSTY(M2SD+JSQ2+IIAJIB) + CPAG
C   1HD
          DENSTY(N1HD+IAI) = DENSTY(N1HD+IAI) + DXAG*HIJ(IBJ)
          DENSTY(N1HD+IBJ) = DENSTY(N1HD+IBJ) + DXAG*HIJ(IAI)
C
          DENSTY(M1HD+ISQ1+IAI)=DENSTY(M1HD+ISQ1+IAI) + CPBG*HIJ(IBJ)
          DENSTY(M1HD+ISQ1+IBJ)=DENSTY(M1HD+ISQ1+IBJ) + CPBG*HIJ(IAI)
          DENSTY(M1HD+JSQ1+IAI)=DENSTY(M1HD+JSQ1+IAI) + CPAG*HIJ(IBJ)
          DENSTY(M1HD+JSQ1+IBJ)=DENSTY(M1HD+JSQ1+IBJ) + CPAG*HIJ(IAI)
          GGGG=AG(NADD+MAP(3,LX))*GIJKL(IIAJIB)
          HRVB(IJVB)=HRVB(IJVB)+GGGG*D11PAR
          ELSE
          DO 135 KW=1,N
            IF(KW.EQ.JW.OR.KW.EQ.IW) GOTO 135
            K=NASTR(KW,ISTR)
C            ICK=INDXIJ(K,IC)
        IF(K.GT.IC) THEN
          ICK = IAA(K) + IC
        ELSE
          ICK = IAA(IC) + K
        ENDIF
            INDXW(1)=IAI
            INDXW(2)=IBJ
            INDXW(3)=ICK
            IF(LCRANK.EQ.3) THEN
            LX=LX+1
            DVALUE = OVM(65+MAP(2,LX))
            DXAG=DVALUE*CPARITY*AG(NADD+MAP(3,LX))
            CPAG=CPA0*DVALUE*AG(NADD+MAP(3,LX))
            CPBG=CPB0*DVALUE*AG(NADD+MAP(3,LX))
C            IIAJIB=INDXIJ(IAI,IBJ)
        IF(IAI.GT.IBJ) THEN
          IIAJIB = IAA(IAI) + IBJ
        ELSE
          IIAJIB = IAA(IBJ) + IAI
        ENDIF
C            IIAKIC=INDXIJ(IAI,ICK)
        IF(IAI.GT.ICK) THEN
          IIAKIC = IAA(IAI) + ICK
        ELSE
          IIAKIC = IAA(ICK) + IAI
        ENDIF
C            JIBKIC=INDXIJ(IBJ,ICK)
        IF(IBJ.GT.ICK) THEN
          JIBKIC = IAA(IBJ) + ICK
        ELSE
          JIBKIC = IAA(ICK) + IBJ
        ENDIF
C
C   BUILD 3SD,2HD,1HD
C
C   3SD
            CALL SETINXN(3,INDXW,N3)
            DENSTY(N3SD+N3)=DENSTY(N3SD+N3) + DXAG
C
C   2HD
            DENSTY(N2HD+JIBKIC) = DENSTY(N2HD+JIBKIC) + DXAG*HIJ(IAI)
            DENSTY(N2HD+IIAKIC) = DENSTY(N2HD+IIAKIC) + DXAG*HIJ(IBJ)
            DENSTY(N2HD+IIAJIB) = DENSTY(N2HD+IIAJIB) + DXAG*HIJ(ICK)
C
C   1HD
C
            DENSTY(N1HD+IAI) = DENSTY(N1HD+IAI) + DXAG*GIJKL(JIBKIC)
            DENSTY(N1HD+IBJ) = DENSTY(N1HD+IBJ) + DXAG*GIJKL(IIAKIC)
            DENSTY(N1HD+ICK) = DENSTY(N1HD+ICK) + DXAG*GIJKL(IIAJIB)
C
        DENSTY(M1HD+ISQ1+IAI)=DENSTY(M1HD+ISQ1+IAI)+CPBG*GIJKL(JIBKIC)
        DENSTY(M1HD+ISQ1+IBJ)=DENSTY(M1HD+ISQ1+IBJ)+CPBG*GIJKL(IIAKIC)
        DENSTY(M1HD+ISQ1+ICK)=DENSTY(M1HD+ISQ1+ICK)+CPBG*GIJKL(IIAJIB)
C
        DENSTY(M1HD+JSQ1+IAI)=DENSTY(M1HD+JSQ1+IAI)+CPAG*GIJKL(JIBKIC)
        DENSTY(M1HD+JSQ1+IBJ)=DENSTY(M1HD+JSQ1+IBJ)+CPAG*GIJKL(IIAKIC)
        DENSTY(M1HD+JSQ1+ICK)=DENSTY(M1HD+JSQ1+ICK)+CPAG*GIJKL(IIAJIB)
            ELSE
              DO 145 LW=1,N
              IF(LW.EQ.KW.OR.LW.EQ.JW.OR.LW.EQ.IW) GOTO 145
              L=NASTR(LW,ISTR)
C              IDL=INDXIJ(L,ID)
        IF(L.GT.ID) THEN
          IDL = IAA(L) + ID
        ELSE
          IDL = IAA(ID) + L
        ENDIF
              INDXW(4)=IDL
              IF(LCRANK.EQ.4) THEN
              LX=LX+1
              DXAG=CPARITY*OVM(65+MAP(2,LX))*AG(NADD+MAP(3,LX))
C
C   BUILD 2HD
C   SIX COMBINATIONS
C
C        IIAJIB=INDXIJ(IAI,IBJ)
        IF(IAI.GT.IBJ) THEN
          IIAJIB = IAA(IAI) + IBJ
        ELSE
          IIAJIB = IAA(IBJ) + IAI
        ENDIF
C        KICLID=INDXIJ(ICK,IDL)
        IF(ICK.GT.IDL) THEN
          KICLID = IAA(ICK) + IDL
        ELSE
          KICLID = IAA(IDL) + ICK
        ENDIF
C        IIAKIC=INDXIJ(IAI,ICK)
        IF(IAI.GT.ICK) THEN
          IIAKIC = IAA(IAI) + ICK
        ELSE
          IIAKIC = IAA(ICK) + IAI
        ENDIF
C        JIBLID=INDXIJ(IBJ,IDL)
        IF(IBJ.GT.IDL) THEN
          JIBLID = IAA(IBJ) + IDL
        ELSE
          JIBLID = IAA(IDL) + IBJ
        ENDIF
C        IIALID=INDXIJ(IAI,IDL)
        IF(IAI.GT.IDL) THEN
          IIALID = IAA(IAI) + IDL
        ELSE
          IIALID = IAA(IDL) + IAI
        ENDIF
C        JIBKIC=INDXIJ(IBJ,ICK)
        IF(IBJ.GT.ICK) THEN
          JIBKIC = IAA(IBJ) + ICK
        ELSE
          JIBKIC = IAA(ICK) + IBJ
        ENDIF
        DENSTY(N2HD+IIAJIB)=DENSTY(N2HD+IIAJIB) + DXAG*GIJKL(KICLID)
        DENSTY(N2HD+IIAKIC)=DENSTY(N2HD+IIAKIC) + DXAG*GIJKL(JIBLID)
        DENSTY(N2HD+IIALID)=DENSTY(N2HD+IIALID) + DXAG*GIJKL(JIBKIC)
        DENSTY(N2HD+JIBKIC)=DENSTY(N2HD+JIBKIC) + DXAG*GIJKL(IIALID)
        DENSTY(N2HD+JIBLID)=DENSTY(N2HD+JIBLID) + DXAG*GIJKL(IIAKIC)
        DENSTY(N2HD+KICLID)=DENSTY(N2HD+KICLID) + DXAG*GIJKL(IIAJIB)
          END IF
 145      CONTINUE
          END IF
 135    CONTINUE
        END IF
 125  CONTINUE
      END IF
 115  CONTINUE
      END IF
 107  CONTINUE
      END IF
 100  CONTINUE
      GOTO 250
 150  CONTINUE
C
C     MVBM=1
C
      WRITE(IOUTVB,*)'MVBMAP=1 IS NOT IMPLEMETED YET'
      CALL ABRTVB
C200  CONTINUE
 250  CONTINUE
      DO IJ=1,NSTR*(NSTR+1)/2
      SRVB(IJ)=SRVB(IJ)/N
      END DO
      VBHH0=0.0D0
      VBGG0=0.0D0
      VBSSN=0.0D0
      DO I=1,NORB2
      VBHH0=VBHH0+DENSTY(N1SD+I)*HIJ(I)
      VBSSN=VBSSN+DENSTY(N1SD+I)*SIJ(I)
      END DO
      DO I=1,NORB2*(NORB2+1)/2
      VBGG0=VBGG0+DENSTY(N2SD+I)*GIJKL(I)
      END DO
      S0=VBSSN/N
      E0=(VBHH0+VBGG0)/S0
C     TIME1=XCLOCK()
C
C     UPDATE CSTR BY SOLVE THE SECULAR EQUATION
C     HC = ESC
C
C     WRITE(IOUTVB,*)'CSTR BEFORE =',(CSTR(I),I=1,NSTR)
C     CALL RVB(NSTR,CSTR,SRVB,HRVB,AG,F2,FLAG,LPTALL)
C     FLAD NEEDS ADDING BACK AS ARGUMENT IF ABOVE IS USED
C     WRITE(IOUTVB,*)'CSTR AFTER  =',(CSTR(I),I=1,NSTR)
C
C     BAD IDEA, JL/04/12/04
C
      IF(IDERANK.EQ.0) GOTO 2000
C
C     DERIVATIVES: STRUCTURES
C
      DO I=1,NSTR
      DO J=1,NSTR
      IF(I.GT.J) THEN
      IJ=I*(I-1)/2+J
      ELSE
      IJ=J*(J-1)/2+I
      END IF
      DEVS(NBRIL+I)=DEVS(NBRIL+I)+CSTR(J)*SRVB(IJ)
      DEVS(NBRIL+J)=DEVS(NBRIL+J)+CSTR(I)*SRVB(IJ)
      DEVE(NBRIL+I)=DEVE(NBRIL+I)+CSTR(J)*(HRVB(IJ)-E0*SRVB(IJ))
      DEVE(NBRIL+J)=DEVE(NBRIL+J)+CSTR(I)*(HRVB(IJ)-E0*SRVB(IJ))
      END DO
      END DO
C
C     DERIVATIVES
C
      DO I=1,NORB2
C
C      PART 1: <a|b><HAG_N_1>
C      PART 2: <a|h|b><AG_N-1>
C      PART 3: -E<a|b><AG_N-1>
C
      IA=IJMAP(1,I)
      IB=IJMAP(2,I)
       DO K=1,NORB
       KA=NBTAB(K,IA)
       KB=NBTAB(K,IB)
C       IAK=INDXIJ(K,IA)
        IF(K.GT.IA) THEN
          IAK = IAA(K) + IA
        ELSE
          IAK = IAA(IA) + K
        ENDIF
C       IBK=INDXIJ(K,IB)
        IF(K.GT.IB) THEN
          IBK = IAA(K) + IB
        ELSE
          IBK = IAA(IB) + K
        ENDIF
       IF(KA.GT.0) THEN
       DEVE(KA)=DEVE(KA)+SIJ(IBK)*DENSTY(N1HD+I)+
     &          HIJ(IBK)*DENSTY(N1SD+I)-E0*SIJ(IBK)*DENSTY(N1SD+I)
       DEVS(KA)=DEVS(KA)+SIJ(IBK)*DENSTY(N1SD+I)
       END IF
       IF(KB.GT.0) THEN
       DEVE(KB)=DEVE(KB)+SIJ(IAK)*DENSTY(N1HD+I)+
     &          HIJ(IAK)*DENSTY(N1SD+I)-E0*SIJ(IAK)*DENSTY(N1SD+I)
       DEVS(KB)=DEVS(KB)+SIJ(IAK)*DENSTY(N1SD+I)
       END IF
       END DO
      END DO
C      PART 4: <ab|g|cd><AG_N-2>
      DO I=1,NORB2
      IA=IJMAP(1,I)
      IB=IJMAP(2,I)
      DO J=1,I
      IC=IJMAP(1,J)
      ID=IJMAP(2,J)
C      IJ=INDXIJ(J,I)
        IF(J.GT.I) THEN
          IJ = IAA(J) + I
        ELSE
          IJ = IAA(I) + J
        ENDIF
       DO K=1,NORB
       KA=NBTAB(K,IA)
       KB=NBTAB(K,IB)
       KC=NBTAB(K,IC)
       KD=NBTAB(K,ID)
       IF(KA.GT.0) THEN
C       IBK=INDXIJ(K,IB)
        IF(K.GT.IB) THEN
          IBK = IAA(K) + IB
        ELSE
          IBK = IAA(IB) + K
        ENDIF
C       IKBCD=INDXIJ(J,IBK)
        IF(J.GT.IBK) THEN
          IKBCD = IAA(J) + IBK
        ELSE
          IKBCD = IAA(IBK) + J
        ENDIF
       DEVE(KA)=DEVE(KA)+GIJKL(IKBCD)*DENSTY(N2SD+IJ)
       END IF
       IF(KB.GT.0) THEN
C       IAK=INDXIJ(K,IA)
        IF(K.GT.IA) THEN
          IAK = IAA(K) + IA
        ELSE
          IAK = IAA(IA) + K
        ENDIF
C       IAKCD=INDXIJ(J,IAK)
        IF(J.GT.IAK) THEN
          IAKCD = IAA(J) + IAK
        ELSE
          IAKCD = IAA(IAK) + J
        ENDIF
       DEVE(KB)=DEVE(KB)+GIJKL(IAKCD)*DENSTY(N2SD+IJ)
       END IF
       IF(KC.GT.0) THEN
C       IDK=INDXIJ(K,ID)
        IF(K.GT.ID) THEN
          IDK = IAA(K) + ID
        ELSE
          IDK = IAA(ID) + K
        ENDIF
C       IABKD=INDXIJ(I,IDK)
        IF(I.GT.IDK) THEN
          IABKD = IAA(I) + IDK
        ELSE
          IABKD = IAA(IDK) + I
        ENDIF
       DEVE(KC)=DEVE(KC)+GIJKL(IABKD)*DENSTY(N2SD+IJ)
       END IF
       IF(KD.GT.0) THEN
C       ICK=INDXIJ(K,IC)
        IF(K.GT.IC) THEN
          ICK = IAA(K) + IC
        ELSE
          ICK = IAA(IC) + K
        ENDIF
C       IABCK=INDXIJ(I,ICK)
        IF(I.GT.ICK) THEN
          IABCK = IAA(I) + ICK
        ELSE
          IABCK = IAA(ICK) + I
        ENDIF
       DEVE(KD)=DEVE(KD)+GIJKL(IABCK)*DENSTY(N2SD+IJ)
       END IF
       END DO
      END DO
      END DO
      OVS=1.0D0/S0
      DO I=1,NBRIL+NSTR
      DEVE(I)=DEVE(I)*OVS
      END DO
C     STOP
      IF(IDERANK.EQ.1) GOTO 2000
C
C     HESSIAN: ORBITAL-ORBITAL BLOCK
C
      DO I=1,NORB2
C
C      PART 1: <a|b><HAG_N_1>
C      PART 2: <a|h|b><AG_N-1>
C      PART 3: -E<a|b><AG_N-1>
C
      IA=IJMAP(1,I)
      IB=IJMAP(2,I)
       DO K=1,NORB
       KA=NBTAB(K,IA)
       DO L=1,NORB
       LB=NBTAB(L,IB)
       IF(KA.GT.0.AND.LB.GT.0) THEN
C       KL=INDXIJ(K,L)
        IF(K.GT.L) THEN
          KL = IAA(K) + L
        ELSE
          KL = IAA(L) + K
        ENDIF
C       KLAB=INDXIJ(KA,LB)
        IF(KA.GT.LB) THEN
          KLAB = IAA(KA) + LB
        ELSE
          KLAB = IAA(LB) + KA
        ENDIF
       HESS(KLAB)=HESS(KLAB) +  SIJ(KL)*DENSTY(N1HD+I)
     &                       +  HIJ(KL)*DENSTY(N1SD+I)
     &                      -E0*SIJ(KL)*DENSTY(N1SD+I)
       END IF
       END DO
       END DO
      END DO
C      PART 4: (ab|cd)<HAG_N-2>
C      PART 5: <a|h|b><c|d><AG_N-2>
C      PART 6: (ab|g|cd)<AG_N-2>
C      PART 7: -E(ab|cd)<AG_N-2>
      DO I=1,NORB2
      IA=IJMAP(1,I)
      IB=IJMAP(2,I)
      DO J=1,I
      IC=IJMAP(1,J)
      ID=IJMAP(2,J)
C      IJ=INDXIJ(I,J)
        IF(I.GT.J) THEN
          IJ = IAA(I) + J
        ELSE
          IJ = IAA(J) + I
        ENDIF
       DO K=1,NORB
       KA=NBTAB(K,IA)
       KB=NBTAB(K,IB)
       KC=NBTAB(K,IC)
       KD=NBTAB(K,ID)
C       IAK=INDXIJ(K,IA)
        IF(K.GT.IA) THEN
          IAK = IAA(K) + IA
        ELSE
          IAK = IAA(IA) + K
        ENDIF
C       IBK=INDXIJ(K,IB)
        IF(K.GT.IB) THEN
          IBK = IAA(K) + IB
        ELSE
          IBK = IAA(IB) + K
        ENDIF
       DO L=1,NORB
C      LA=NBTAB(L,IA)
       LB=NBTAB(L,IB)
       LC=NBTAB(L,IC)
       LD=NBTAB(L,ID)
C       ICL=INDXIJ(L,IC)
        IF(L.GT.IC) THEN
          ICL = IAA(L) + IC
        ELSE
          ICL = IAA(IC) + L
        ENDIF
C       IDL=INDXIJ(L,ID)
        IF(L.GT.ID) THEN
          IDL = IAA(L) + ID
        ELSE
          IDL = IAA(ID) + L
        ENDIF
C       KL=INDXIJ(K,L)
        IF(K.GT.L) THEN
          KL = IAA(K) + L
        ELSE
          KL = IAA(L) + K
        ENDIF
C       IAKCL=INDXIJ(IAK,ICL)
        IF(IAK.GT.ICL) THEN
          IAKCL = IAA(IAK) + ICL
        ELSE
          IAKCL = IAA(ICL) + IAK
        ENDIF
C       IAKLD=INDXIJ(IAK,IDL)
        IF(IAK.GT.IDL) THEN
          IAKLD = IAA(IAK) + IDL
        ELSE
          IAKLD = IAA(IDL) + IAK
        ENDIF
C       IKBCL=INDXIJ(IBK,ICL)
        IF(IBK.GT.ICL) THEN
          IKBCL = IAA(IBK) + ICL
        ELSE
          IKBCL = IAA(ICL) + IBK
        ENDIF
C       IKBLD=INDXIJ(IBK,IDL)
        IF(IBK.GT.IDL) THEN
          IKBLD = IAA(IBK) + IDL
        ELSE
          IKBLD = IAA(IDL) + IBK
        ENDIF
C       IKLCD=INDXIJ(KL,J)
        IF(KL.GT.J) THEN
          IKLCD = IAA(KL) + J
        ELSE
          IKLCD = IAA(J) + KL
        ENDIF
C       IABKL=INDXIJ(I,KL)
        IF(I.GT.KL) THEN
          IABKL = IAA(I) + KL
        ELSE
          IABKL = IAA(KL) + I
        ENDIF
       IF(KA.GT.0.AND.LC.GT.0) THEN
C       KLAC=INDXIJ(KA,LC)
        IF(KA.GT.LC) THEN
          KLAC = IAA(KA) + LC
        ELSE
          KLAC = IAA(LC) + KA
        ENDIF
       HESS(KLAC)=HESS(KLAC)+SIJ(IBK)*SIJ(IDL)*DENSTY(N2HD+IJ)
     &  +(SIJ(IBK)*HIJ(IDL)+HIJ(IBK)*SIJ(IDL)+GIJKL(IKBLD)
     &    -E0*SIJ(IBK)*SIJ(IDL))*DENSTY(N2SD+IJ)
       END IF
       IF(KA.GT.0.AND.LD.GT.0) THEN
C       KLAD=INDXIJ(KA,LD)
        IF(KA.GT.LD) THEN
          KLAD = IAA(KA) + LD
        ELSE
          KLAD = IAA(LD) + KA
        ENDIF
       HESS(KLAD)=HESS(KLAD)+SIJ(IBK)*SIJ(ICL)*DENSTY(N2HD+IJ)
     &  +(HIJ(IBK)*SIJ(ICL)+SIJ(IBK)*HIJ(ICL)+GIJKL(IKBCL)
     &    -E0*SIJ(IBK)*SIJ(ICL))*DENSTY(N2SD+IJ)
       END IF
       IF(KB.GT.0.AND.LC.GT.0) THEN
C       KLBC=INDXIJ(KB,LC)
        IF(KB.GT.LC) THEN
          KLBC = IAA(KB) + LC
        ELSE
          KLBC = IAA(LC) + KB
        ENDIF
       HESS(KLBC)=HESS(KLBC)+SIJ(IAK)*SIJ(IDL)*DENSTY(N2HD+IJ)
     &  +(SIJ(IAK)*HIJ(IDL)+HIJ(IAK)*SIJ(IDL)+GIJKL(IAKLD)
     &    -E0*SIJ(IAK)*SIJ(IDL))*DENSTY(N2SD+IJ)
       END IF
       IF(KB.GT.0.AND.LD.GT.0) THEN
C       KLBD=INDXIJ(KB,LD)
        IF(KB.GT.LD) THEN
          KLBD = IAA(KB) + LD
        ELSE
          KLBD = IAA(LD) + KB
        ENDIF
       HESS(KLBD)=HESS(KLBD)+SIJ(IAK)*SIJ(ICL)*DENSTY(N2HD+IJ)
     &  +(SIJ(IAK)*HIJ(ICL)+HIJ(IAK)*SIJ(ICL)+GIJKL(IAKCL)
     &    -E0*SIJ(IAK)*SIJ(ICL))*DENSTY(N2SD+IJ)
       END IF
       IF(KA.GT.0.AND.LB.GT.0) THEN
C       KLAB =INDXIJ(KA,LB)
        IF(KA.GT.LB) THEN
          KLAB = IAA(KA) + LB
        ELSE
          KLAB = IAA(LB) + KA
        ENDIF
       HESS(KLAB)=HESS (KLAB)+GIJKL(IKLCD)*DENSTY(N2SD+IJ)
       END IF
       IF(KC.GT.0.AND.LD.GT.0) THEN
C       KLCD=INDXIJ(KC,LD)
        IF(KC.GT.LD) THEN
          KLCD = IAA(KC) + LD
        ELSE
          KLCD = IAA(LD) + KC
        ENDIF
       HESS(KLCD)=HESS(KLCD)+GIJKL(IABKL)*DENSTY(N2SD+IJ)
       END IF
C      end of modification
       END DO
       END DO
      END DO
      END DO
C     IF(N.LT.3) SKIP THIS PART
      IF(N.LT.3) GOTO 333
C
C    PART 8 (ab|cd)<e|f><AG_N-3>
C
      N3SDIJK=N3SD
C     SUM3=0.0D0
      DO I=1,NORB2
      IA=IJMAP(1,I)
      IB=IJMAP(2,I)
      DO J=1,I
      JC=IJMAP(1,J)
      JD=IJMAP(2,J)
      DO K=1,J
      KE=IJMAP(1,K)
      KF=IJMAP(2,K)
      N3SDIJK=N3SDIJK+1
       DO L=1,NORB-1
       LIA=NOTAB(L,IA)
       LIB=NOTAB(L,IB)
       LJC=NOTAB(L,JC)
       LJD=NOTAB(L,JD)
       LKE=NOTAB(L,KE)
       LKF=NOTAB(L,KF)
       L2A=NBTAB(LIA,IA)
       L2B=NBTAB(LIB,IB)
       L2C=NBTAB(LJC,JC)
       L2D=NBTAB(LJD,JD)
       L2E=NBTAB(LKE,KE)
       L2F=NBTAB(LKF,KF)
C       IAL=INDXIJ(IA,LIB)
        IF(IA.GT.LIB) THEN
          IAL = IAA(IA) + LIB
        ELSE
          IAL = IAA(LIB) + IA
        ENDIF
C       IBL=INDXIJ(IB,LIA)
        IF(IB.GT.LIA) THEN
          IBL = IAA(IB) + LIA
        ELSE
          IBL = IAA(LIA) + IB
        ENDIF
C       JCL=INDXIJ(JC,LJD)
        IF(JC.GT.LJD) THEN
          JCL = IAA(JC) + LJD
        ELSE
          JCL = IAA(LJD) + JC
        ENDIF
C       JDL=INDXIJ(JD,LJC)
        IF(JD.GT.LJC) THEN
          JDL = IAA(JD) + LJC
        ELSE
          JDL = IAA(LJC) + JD
        ENDIF
C       KEL=INDXIJ(KE,LKF)
        IF(KE.GT.LKF) THEN
          KEL = IAA(KE) + LKF
        ELSE
          KEL = IAA(LKF) + KE
        ENDIF
C       KFL=INDXIJ(KF,LKE)
        IF(KF.GT.LKE) THEN
          KFL = IAA(KF) + LKE
        ELSE
          KFL = IAA(LKE) + KF
        ENDIF
C       LBCD=INDXIJ(IBL,J)
        IF(IBL.GT.J) THEN
          LBCD = IAA(IBL) + J
        ELSE
          LBCD = IAA(J) + IBL
        ENDIF
C       LACD=INDXIJ(IAL,J)
        IF(IAL.GT.J) THEN
          LACD = IAA(IAL) + J
        ELSE
          LACD = IAA(J) + IAL
        ENDIF
C       LABD=INDXIJ(I,JDL)
        IF(I.GT.JDL) THEN
          LABD = IAA(I) + JDL
        ELSE
          LABD = IAA(JDL) + I
        ENDIF
C       LABC=INDXIJ(I,JCL)
        IF(I.GT.JCL) THEN
          LABC = IAA(I) + JCL
        ELSE
          LABC = IAA(JCL) + I
        ENDIF
C       LBEF=INDXIJ(IBL,K)
        IF(IBL.GT.K) THEN
          LBEF = IAA(IBL) + K
        ELSE
          LBEF = IAA(K) + IBL
        ENDIF
C       LAEF=INDXIJ(IAL,K)
        IF(IAL.GT.K) THEN
          LAEF = IAA(IAL) + K
        ELSE
          LAEF = IAA(K) + IAL
        ENDIF
C       LABF=INDXIJ(I,KFL)
        IF(I.GT.KFL) THEN
          LABF = IAA(I) + KFL
        ELSE
          LABF = IAA(KFL) + I
        ENDIF
C       LABE=INDXIJ(I,KEL)
        IF(I.GT.KEL) THEN
          LABE = IAA(I) + KEL
        ELSE
          LABE = IAA(KEL) + I
        ENDIF
C       LDEF=INDXIJ(JDL,K)
        IF(JDL.GT.K) THEN
          LDEF = IAA(JDL) + K
        ELSE
          LDEF = IAA(K) + JDL
        ENDIF
C       LCEF=INDXIJ(JCL,K)
        IF(JCL.GT.K) THEN
          LCEF = IAA(JCL) + K
        ELSE
          LCEF = IAA(K) + JCL
        ENDIF
C       LCDF=INDXIJ(J,KFL)
        IF(J.GT.KFL) THEN
          LCDF = IAA(J) + KFL
        ELSE
          LCDF = IAA(KFL) + J
        ENDIF
C       LCDE=INDXIJ(J,KEL)
        IF(J.GT.KEL) THEN
          LCDE = IAA(J) + KEL
        ELSE
          LCDE = IAA(KEL) + J
        ENDIF
       GLBCD=GIJKL(LBCD)*DENSTY(N3SDIJK)
       GLACD=GIJKL(LACD)*DENSTY(N3SDIJK)
       GLABD=GIJKL(LABD)*DENSTY(N3SDIJK)
       GLABC=GIJKL(LABC)*DENSTY(N3SDIJK)
       GLBEF=GIJKL(LBEF)*DENSTY(N3SDIJK)
       GLAEF=GIJKL(LAEF)*DENSTY(N3SDIJK)
       GLABF=GIJKL(LABF)*DENSTY(N3SDIJK)
       GLABE=GIJKL(LABE)*DENSTY(N3SDIJK)
       GLDEF=GIJKL(LDEF)*DENSTY(N3SDIJK)
       GLCEF=GIJKL(LCEF)*DENSTY(N3SDIJK)
       GLCDE=GIJKL(LCDE)*DENSTY(N3SDIJK)
       GLCDF=GIJKL(LCDF)*DENSTY(N3SDIJK)
       DO M=1,NORB-1
       MIA=NOTAB(M,IA)
       MIB=NOTAB(M,IB)
       MJC=NOTAB(M,JC)
       MJD=NOTAB(M,JD)
       MKE=NOTAB(M,KE)
       MKF=NOTAB(M,KF)
       M2A=NBTAB(MIA,IA)
       M2B=NBTAB(MIB,IB)
       M2C=NBTAB(MJC,JC)
       M2D=NBTAB(MJD,JD)
       M2E=NBTAB(MKE,KE)
       M2F=NBTAB(MKF,KF)
C       IAM=INDXIJ(IA,MIB)
        IF(IA.GT.MIB) THEN
          IAM = IAA(IA) + MIB
        ELSE
          IAM = IAA(MIB) + IA
        ENDIF
C       IBM=INDXIJ(IB,MIA)
        IF(IB.GT.MIA) THEN
          IBM = IAA(IB) + MIA
        ELSE
          IBM = IAA(MIA) + IB
        ENDIF
C       JCM=INDXIJ(JC,MJD)
        IF(JC.GT.MJD) THEN
          JCM = IAA(JC) + MJD
        ELSE
          JCM = IAA(MJD) + JC
        ENDIF
C       JDM=INDXIJ(JD,MJC)
        IF(JD.GT.MJC) THEN
          JDM = IAA(JD) + MJC
        ELSE
          JDM = IAA(MJC) + JD
        ENDIF
C       KEM=INDXIJ(KE,MKF)
        IF(KE.GT.MKF) THEN
          KEM = IAA(KE) + MKF
        ELSE
          KEM = IAA(MKF) + KE
        ENDIF
C       KFM=INDXIJ(KF,MKE)
        IF(KF.GT.MKE) THEN
          KFM = IAA(KF) + MKE
        ELSE
          KFM = IAA(MKE) + KF
        ENDIF
C
C     3*8 CASES
C
C     (ab|g|cd)<e|f>
C
C        (Lb|g|cd)<M|f>
C      L2AM2E=INDXIJ(L2A,M2E)
        IF(L2A.GT.M2E) THEN
          L2AM2E = IAA(L2A) + M2E
        ELSE
          L2AM2E = IAA(M2E) + L2A
        ENDIF
      HESS(L2AM2E)=HESS(L2AM2E)+GLBCD*SIJ(KFM)
C        (Lb|g|cd)<e|M>
C      L2AM2F=INDXIJ(L2A,M2F)
        IF(L2A.GT.M2F) THEN
          L2AM2F = IAA(L2A) + M2F
        ELSE
          L2AM2F = IAA(M2F) + L2A
        ENDIF
      HESS(L2AM2F)=HESS(L2AM2F)+GLBCD*SIJ(KEM)
C        (aL|g|cd)<M|f>
C      L2BM2E=INDXIJ(L2B,M2E)
        IF(L2B.GT.M2E) THEN
          L2BM2E = IAA(L2B) + M2E
        ELSE
          L2BM2E = IAA(M2E) + L2B
        ENDIF
      HESS(L2BM2E)=HESS(L2BM2E)+GLACD*SIJ(KFM)
C        (aL|g|cd)<e|M>
C      L2BM2F=INDXIJ(L2B,M2F)
        IF(L2B.GT.M2F) THEN
          L2BM2F = IAA(L2B) + M2F
        ELSE
          L2BM2F = IAA(M2F) + L2B
        ENDIF
      HESS(L2BM2F)=HESS(L2BM2F)+GLACD*SIJ(KEM)
C        (ab|g|Ld)<M|f>
C      L2CM2E=INDXIJ(L2C,M2E)
        IF(L2C.GT.M2E) THEN
          L2CM2E = IAA(L2C) + M2E
        ELSE
          L2CM2E = IAA(M2E) + L2C
        ENDIF
      HESS(L2CM2E)=HESS(L2CM2E)+GLABD*SIJ(KFM)
C        (ab|g|Ld)<e|M>
C      L2CM2F=INDXIJ(L2C,M2F)
        IF(L2C.GT.M2F) THEN
          L2CM2F = IAA(L2C) + M2F
        ELSE
          L2CM2F = IAA(M2F) + L2C
        ENDIF
      HESS(L2CM2F)=HESS(L2CM2F)+GLABD*SIJ(KEM)
C        (ab|g|cL)<M|f>
C      L2DM2E=INDXIJ(L2D,M2E)
        IF(L2D.GT.M2E) THEN
          L2DM2E = IAA(L2D) + M2E
        ELSE
          L2DM2E = IAA(M2E) + L2D
        ENDIF
      HESS(L2DM2E)=HESS(L2DM2E)+GLABC*SIJ(KFM)
C        (ab|g|cL)<e|M>
C      L2DM2F=INDXIJ(L2D,M2F)
        IF(L2D.GT.M2F) THEN
          L2DM2F = IAA(L2D) + M2F
        ELSE
          L2DM2F = IAA(M2F) + L2D
        ENDIF
      HESS(L2DM2F)=HESS(L2DM2F)+GLABC*SIJ(KEM)
C
C
C     (ab|g|ef)<c|d>
C
C        (Lb|g|ef)<M|d>
C      L2AM2C=INDXIJ(L2A,M2C)
        IF(L2A.GT.M2C) THEN
          L2AM2C = IAA(L2A) + M2C
        ELSE
          L2AM2C = IAA(M2C) + L2A
        ENDIF
      HESS(L2AM2C)=HESS(L2AM2C)+GLBEF*SIJ(JDM)
C        (Lb|g|ef)<c|M>
C      L2AM2D=INDXIJ(L2A,M2D)
        IF(L2A.GT.M2D) THEN
          L2AM2D = IAA(L2A) + M2D
        ELSE
          L2AM2D = IAA(M2D) + L2A
        ENDIF
      HESS(L2AM2D)=HESS(L2AM2D)+GLBEF*SIJ(JCM)
C        (aL|g|ef)<M|d>
C      L2BM2C=INDXIJ(L2B,M2C)
        IF(L2B.GT.M2C) THEN
          L2BM2C = IAA(L2B) + M2C
        ELSE
          L2BM2C = IAA(M2C) + L2B
        ENDIF
      HESS(L2BM2C)=HESS(L2BM2C)+GLAEF*SIJ(JDM)
C        (aL|g|ef)<c|M>
C      L2BM2D=INDXIJ(L2B,M2D)
        IF(L2B.GT.M2D) THEN
          L2BM2D = IAA(L2B) + M2D
        ELSE
          L2BM2D = IAA(M2D) + L2B
        ENDIF
      HESS(L2BM2D)=HESS(L2BM2D)+GLAEF*SIJ(JCM)
C        (ab|g|Lf)<M|d>
C      L2EM2C=INDXIJ(L2E,M2C)
        IF(L2E.GT.M2C) THEN
          L2EM2C = IAA(L2E) + M2C
        ELSE
          L2EM2C = IAA(M2C) + L2E
        ENDIF
      HESS(L2EM2C)=HESS(L2EM2C)+GLABF*SIJ(JDM)
C        (ab|g|Lf)<c|M>
C      L2EM2D=INDXIJ(L2E,M2D)
        IF(L2E.GT.M2D) THEN
          L2EM2D = IAA(L2E) + M2D
        ELSE
          L2EM2D = IAA(M2D) + L2E
        ENDIF
      HESS(L2EM2D)=HESS(L2EM2D)+GLABF*SIJ(JCM)
C        (ab|g|eL)<M|d>
C      L2FM2C=INDXIJ(L2F,M2C)
        IF(L2F.GT.M2C) THEN
          L2FM2C = IAA(L2F) + M2C
        ELSE
          L2FM2C = IAA(M2C) + L2F
        ENDIF
      HESS(L2FM2C)=HESS(L2FM2C)+GLABE*SIJ(JDM)
C        (ab|g|eL)<c|M>
C      L2FM2D=INDXIJ(L2F,M2D)
        IF(L2F.GT.M2D) THEN
          L2FM2D = IAA(L2F) + M2D
        ELSE
          L2FM2D = IAA(M2D) + L2F
        ENDIF
      HESS(L2FM2D)=HESS(L2FM2D)+GLABE*SIJ(JCM)
C
C     (cd|g|ef)<a|b>
C
C        (Ld|g|ef)<M|b>
C      L2CM2A=INDXIJ(L2C,M2A)
        IF(L2C.GT.M2A) THEN
          L2CM2A = IAA(L2C) + M2A
        ELSE
          L2CM2A = IAA(M2A) + L2C
        ENDIF
      HESS(L2CM2A)=HESS(L2CM2A)+GLDEF*SIJ(IBM)
C        (Ld|g|ef)<a|M>
C      L2CM2B=INDXIJ(L2C,M2B)
        IF(L2C.GT.M2B) THEN
          L2CM2B = IAA(L2C) + M2B
        ELSE
          L2CM2B = IAA(M2B) + L2C
        ENDIF
      HESS(L2CM2B)=HESS(L2CM2B)+GLDEF*SIJ(IAM)
C        (cL|g|ef)<M|b>
C      L2DM2A=INDXIJ(L2D,M2A)
        IF(L2D.GT.M2A) THEN
          L2DM2A = IAA(L2D) + M2A
        ELSE
          L2DM2A = IAA(M2A) + L2D
        ENDIF
      HESS(L2DM2A)=HESS(L2DM2A)+GLCEF*SIJ(IBM)
C        (cL|g|ef)<a|M>
C      L2DM2B=INDXIJ(L2D,M2B)
        IF(L2D.GT.M2B) THEN
          L2DM2B = IAA(L2D) + M2B
        ELSE
          L2DM2B = IAA(M2B) + L2D
        ENDIF
      HESS(L2DM2B)=HESS(L2DM2B)+GLCEF*SIJ(IAM)
C        (cd|g|Lf)<M|b>
C      L2EM2A=INDXIJ(L2E,M2A)
        IF(L2E.GT.M2A) THEN
          L2EM2A = IAA(L2E) + M2A
        ELSE
          L2EM2A = IAA(M2A) + L2E
        ENDIF
      HESS(L2EM2A)=HESS(L2EM2A)+GLCDF*SIJ(IBM)
C        (cd|g|Lf)<a|M>
C      L2EM2B=INDXIJ(L2E,M2B)
        IF(L2E.GT.M2B) THEN
          L2EM2B = IAA(L2E) + M2B
        ELSE
          L2EM2B = IAA(M2B) + L2E
        ENDIF
      HESS(L2EM2B)=HESS(L2EM2B)+GLCDF*SIJ(IAM)
C        (cd|g|eL)<M|b>
C      L2FM2A=INDXIJ(L2F,M2A)
        IF(L2F.GT.M2A) THEN
          L2FM2A = IAA(L2F) + M2A
        ELSE
          L2FM2A = IAA(M2A) + L2F
        ENDIF
      HESS(L2FM2A)=HESS(L2FM2A)+GLCDE*SIJ(IBM)
C        (cd|g|eL)<a|M>
C      L2FM2B=INDXIJ(L2F,M2B)
        IF(L2F.GT.M2B) THEN
          L2FM2B = IAA(L2F) + M2B
        ELSE
          L2FM2B = IAA(M2B) + L2F
        ENDIF
      HESS(L2FM2B)=HESS(L2FM2B)+GLCDE*SIJ(IAM)
        END DO
        END DO
      END DO
      END DO
      END DO
  333 CONTINUE
C
C     HESSIAN: ORBITAL-STRUCTURE BLOCK
C
      DO I=1,NORB2
C      PART 1: <a|b><HAG_N_1>
C      PART 2: <a|h|b><AG_N-1>
C      PART 3: -E<a|b><AG_N-1>
C
      IA=IJMAP(1,I)
      IB=IJMAP(2,I)
       DO K=1,NORB
       KA=NBTAB(K,IA)
       KB=NBTAB(K,IB)
C       IAK=INDXIJ(IA,K)
        IF(IA.GT.K) THEN
          IAK = IAA(IA) + K
        ELSE
          IAK = IAA(K) + IA
        ENDIF
C       IBK=INDXIJ(IB,K)
        IF(IB.GT.K) THEN
          IBK = IAA(IB) + K
        ELSE
          IBK = IAA(K) + IB
        ENDIF
       IF(KA.GT.0) THEN
         DO L=1,NSTR
         LSQI=(L-1)*NORB2+I
         LLKA=(L+NBRIL)*(L+NBRIL-1)/2+KA
         HESS(LLKA)=HESS(LLKA)+SIJ(IBK)*DENSTY(M1HD+LSQI)
     &   +HIJ(IBK)*DENSTY(M1SD+LSQI)-E0*SIJ(IBK)*DENSTY(M1SD+LSQI)
         END DO
       END IF
       IF(KB.GT.0) THEN
         DO L=1,NSTR
         LSQI=(L-1)*NORB2+I
         LLKB=(L+NBRIL)*(L+NBRIL-1)/2+KB
         HESS(LLKB)=HESS(LLKB)+SIJ(IAK)*DENSTY(M1HD+LSQI)
     &   +HIJ(IAK)*DENSTY(M1SD+LSQI)-E0*SIJ(IAK)*DENSTY(M1SD+LSQI)
         END DO
       END IF
       END DO
      END DO
C      PART 4: <ab|g|cd><AG_N-2>
      DO I=1,NORB2
      IA=IJMAP(1,I)
      IB=IJMAP(2,I)
      DO J=1,I
      IC=IJMAP(1,J)
      ID=IJMAP(2,J)
C      IJ=INDXIJ(I,J)
        IF(I.GT.J) THEN
          IJ = IAA(I) + J
        ELSE
          IJ = IAA(J) + I
        ENDIF
       DO K=1,NORB
       KA=NBTAB(K,IA)
       KB=NBTAB(K,IB)
       KC=NBTAB(K,IC)
       KD=NBTAB(K,ID)
C       IAK=INDXIJ(IA,K)
        IF(IA.GT.K) THEN
          IAK = IAA(IA) + K
        ELSE
          IAK = IAA(K) + IA
        ENDIF
C       IBK=INDXIJ(IB,K)
        IF(IB.GT.K) THEN
          IBK = IAA(IB) + K
        ELSE
          IBK = IAA(K) + IB
        ENDIF
C       ICK=INDXIJ(IC,K)
        IF(IC.GT.K) THEN
          ICK = IAA(IC) + K
        ELSE
          ICK = IAA(K) + IC
        ENDIF
C       IDK=INDXIJ(ID,K)
        IF(ID.GT.K) THEN
          IDK = IAA(ID) + K
        ELSE
          IDK = IAA(K) + ID
        ENDIF
C       IABCK=INDXIJ(I,ICK)
        IF(I.GT.ICK) THEN
          IABCK = IAA(I) + ICK
        ELSE
          IABCK = IAA(ICK) + I
        ENDIF
C       IABKD=INDXIJ(I,IDK)
        IF(I.GT.IDK) THEN
          IABKD = IAA(I) + IDK
        ELSE
          IABKD = IAA(IDK) + I
        ENDIF
C       IAKCD=INDXIJ(J,IAK)
        IF(J.GT.IAK) THEN
          IAKCD = IAA(J) + IAK
        ELSE
          IAKCD = IAA(IAK) + J
        ENDIF
C       IKBCD=INDXIJ(J,IBK)
        IF(J.GT.IBK) THEN
          IKBCD = IAA(J) + IBK
        ELSE
          IKBCD = IAA(IBK) + J
        ENDIF
       NORB4=NORB2*(NORB2+1)/2
       LSQ2=M2SD-NORB4
         DO L=1,NSTR
         LL=(L+NBRIL)*(L+NBRIL-1)/2
         LSQ2=LSQ2+NORB4
         IF(KA.GT.0)
     &     HESS(LL+KA)=HESS(LL+KA)+GIJKL(IKBCD)*DENSTY(LSQ2+IJ)
         IF(KB.GT.0)
     &     HESS(LL+KB)=HESS(LL+KB)+GIJKL(IAKCD)*DENSTY(LSQ2+IJ)
         IF(KC.GT.0)
     &     HESS(LL+KC)=HESS(LL+KC)+GIJKL(IABKD)*DENSTY(LSQ2+IJ)
         IF(KD.GT.0)
     &     HESS(LL+KD)=HESS(LL+KD)+GIJKL(IABCK)*DENSTY(LSQ2+IJ)
         END DO
       END DO
      END DO
      END DO
C
C     HESSIAN: STRUCTURE-STRUCTURE BLOCK
C
C     OVS=1/S0 (One_Over_S)
C
      OVS=1.0D0/S0
      IJ=0
      DO I=1,NSTR
      II=(NBRIL+I)*(NBRIL+I-1)/2
      DO J=1,I
      IJ=IJ+1
      IIJJ=II+NBRIL+J
      HESS(IIJJ)=2.0D0*(HRVB(IJ)-E0*SRVB(IJ))
      END DO
      END DO
C     DEBUGLOCATOR
      DO I=1,NBRIL
      II=I*(I+1)/2
      HESS(II)=HESS(II)+HESS(II)
      END DO
C
C     NORMALIZATION AND PRODUCTION ACCUMULATION
C
      IJ=0
      DO I=1,NBRIL+NSTR
      II=I*(I-1)/2
        DO J=1,I
        IJ=IJ+1
        HESS(IJ)=(HESS(IJ)-DEVE(I)*DEVS(J)-DEVE(J)*DEVS(I))*OVS
        END DO
C     WRITE(IOUTVB,1000)(HESS(II+J),J=1,I)
      END DO
 2000 CONTINUE
C
C     DE-FACTORIZE THE NON-DIAGONAL 1D DENSITY MATRIX ELEMENTS
C
      DO I=1,NORB
      II=I*(I-1)/2
      DO J=1,I-1
      DENSTY(II+J)=DENSTY(II+J)*0.5D0
      END DO
      END DO
      DO I=1,NORB2
      DM1(I)=DENSTY(I)
      END DO
C
C     COPY 2D DENSITY MATRIX ELEMENTS
C     NOTE: DM2 IS SYMMTRY FACTOR WEIGHTED. SAME AS DM2 IN VBMATR
C
      DO I=1,NORB2*(NORB2+1)/2
      DM2(I) = DENSTY(N2SD+I)
      END DO
C     TIME1=XCLOCK()-TIME1
C     WRITE(IOUTVB,*)'TIME FOR DER',TIME1
      RETURN
      END
      SUBROUTINE INTEQU(NA,NB,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C     COPY INTEGER ARRAY
C     NA <= NB
C
      DIMENSION NA(*),NB(*)
      DO I=1,N
      NA(I)=NB(I)
      END DO
      RETURN
      END
C
C     This is subroutine to determine the alphabetic order using
C     Three indexes: INDEXA, IDSETB, INDEXB
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     SET UP A TABLE
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE SETABL()
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (NMAX=4,MMAX=200)
      COMMON /ITABLE/TABLE(NMAX,MMAX)
C
C     TABLE(N,M) GIVES THE COMPACT-INDEX OF A DIAGONAL ELEMENT OF
C     N-DIMENSIONAL SYMMETRIC MATRIX WITH ALL SUB-INDEXES EQ TO M
C
      DO 100 I=1,NMAX
        DO 200 J=1,MMAX
        TEMP=0
          DO 300 K=1,J
          TEMP=TEMP+BINOMI(I-1,K-1)*BINOMI(J,K)
  300     CONTINUE
        TABLE(I,J)=TEMP
  200   CONTINUE
  100 CONTINUE
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     BINOMIAL COEFFICIENTS C(N,M),( N>M )
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     INTEGER FUNCTION INOMI(N,M)
      DOUBLE PRECISION FUNCTION BINOMI(N,M)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      TEMP=1.0D0
      DO 100 I=1,M
      TEMP=TEMP*DBLE(N-I+1)/DBLE(I)
  100 CONTINUE
C     INOMI=(TEMP+0.000001)
      BINOMI=TEMP
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     COMPACT INDEX OF N-DIMENSIONAL SYMMETRY MATRIX ELEMENTS
C
C     Jiabo Li
C     April 28,99
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE SETINXN(N,INDX,IDCOMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (NMAX=4,MMAX=200)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /ITABLE/TABLE(NMAX,MMAX)
      DIMENSION INDX(N)
      IF(N.GT.NMAX) WRITE(IOUTVB,101)
 101  FORMAT('N.GT.NMAX')
C
C     SORT INDEX
C
      CALL SHELL2(N,INDX)
      IDCOMP=1
      DO 100 K=0,N-1
      ITEMP=INDX(N-K)-1
         IF(ITEMP.GT.0) THEN
         IDCOMP=IDCOMP+INT(TABLE(N-K,ITEMP))
         END IF
 100  CONTINUE
      RETURN
      END
      SUBROUTINE SHELL2(N,IX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IX(N)
      IF(N.LE.1) RETURN
      J=N
  5   IF(J.EQ.1) GOTO 20
      J=J/2
      NMJ=N-J
  8   IFLAG=0
      DO 10 I=1,NMJ
      L=I+J
      IF(IX(I).LE.IX(L)) GOTO 10
      ITX=IX(I)
      IX(I)=IX(L)
      IX(L)=ITX
      IFLAG=1
  10  CONTINUE
      IF(IFLAG.EQ.1) GOTO 8
      GOTO 5
 20   RETURN
      END
C
C     NROOTPRT: NUMBER OF ROOTS PRINTED
C
      SUBROUTINE RVB(NSTR,CSTR,VBS,VBH,W,MWRK,F2,FLAG,LASTITER,
     &               MGRP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*50 FLAG
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION CSTR(*),VBS(*),VBH(*),W(*),E(5000)
C     DIMENSION CSTR(*),VBS(*),VBH(*),W(*),E(5000),WEIGHT(5000)
C     DIMENSION CLWD(5000),WEIGHT1(5000),WEIGHT2(5000),WEIGHT3(5000)
C     DIMENSION WEIGHT4(5000)
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      IF(NSTR.GT.5000) CALL ABORT0('TooBigBstr')
      FLAG(4:7)='ROOT'
      NROOT=1
      NROOTPRT = 0
      NW1= 0
      NW2=NW1+NSTR*NSTR
      NW3=NW2+NSTR*NSTR
      NW4=NW3+NSTR*NSTR
      NW5=NW4+NSTR*NSTR
      IF(NW5.GT.MWRK) CALL ABORT0('RVB0000001')
      IJ=0
      DO I=1,NSTR
      DO J=1,NSTR
      IJ=IJ+1
      W(NW1+IJ)=VBH(IJ00(I,J))
      W(NW2+IJ)=VBS(IJ00(I,J))
      END DO
      END DO
      IJ=0
      CALL EG(NSTR,W(NW1+1),W(NW2+1),E,W(NW3+1),W(NW4+1))
C     WRITE(IOUTVB,*)"EIGENVALUES"
C     WRITE(IOUTVB,'(5F15.8)')(E(I),I=1,NSTR)
C
C     READ ROOT NUMBER
C
      CALL LOCTOR(IOENGI,FLAG,7,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*)NROOT
      END IF
      NWROOT=NW3+(NROOT-1)*NSTR
      F2=E(NROOT)
      DO I=1,NSTR
      CSTR(I)=W(NWROOT+I)
      END DO
C
C     SEARCH FOR NROOTS FLAG
      FLAG(4:9)='NROOTP'
C     FLAG(4:9)='NROOTPRT'
      CALL LOCTOR(IOENGI,FLAG,9,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*)NROOTPRT
      END IF
      IF(NROOTPRT.GT.NSTR) NROOTPRT = NSTR
      IF(NROOTPRT.GT.0) THEN
        WRITE(IOUTVB,*)"EIGENVALUES"
        WRITE(IOUTVB,'(5F15.8)')(E(I),I=1,NROOTPRT)
      ENDIF
C
C
C     POSSIBLE STRUCTURE SYMMETRY
C
      CALL STRSYM(CSTR,NSTR,FLAG)
      CALL LOCTOR(IOENGI,'$PRINTHS',8,IOK,0)
      IF (LASTITER.EQ.1.AND.IOK.EQ.1) THEN
        CALL MPRINT3(NSTR,VBS,VBH,MGRP)
      END IF
C
C     Structure weight analysis
C
      IF (LASTITER.EQ.1.AND.NSTR.GT.1)
     &     CALL STRWEIT(NSTR,CSTR,VBS,W,MWRK)
C1000 FORMAT(1X,I5,F15.10)
      RETURN
      END
      SUBROUTINE STRWEIT(NSTR,CSTR,VBS,W,MWRK)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION CSTR(*),VBS(*),W(*)
      DIMENSION CLWD(5000),WEIGHT1(5000),WEIGHT3(5000)
      DIMENSION WEIGHT4(5000),CSTRN(5000),SHF(5000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      IF(NSTR.GT.5000) CALL ABORT0('TooBigBstr')
      NWSHALF = 0
      LOWDINOLD = 0
      NW1= NWSHALF + NSTR*NSTR
      NW2=NW1+NSTR*NSTR
      NW3=NW2+NSTR*NSTR
      NW4=NW3+NSTR*NSTR
      IF(NW4.GT.MWRK) CALL ABORT0('STRWEIT001')
C
C     CHECK OPTION FOR OLD-LOWDIN FORMULA
C
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,"$OLDLOWDIN",10,LOWDINOLD,0)
      DO I=1, NSTR
        SHF(I) = DSQRT(VBS(IJ00(I,I)))
        IF(LOWDINOLD.EQ.1) SHF(I) = 1.0D0
      END DO
C
C     COMPUTE S-HALF MATRIX
C
      IJ=0
      DO I=1,NSTR
        DO J=1,NSTR
          IJ=IJ+1
          W(NW1+IJ)=SHF(I)*SHF(J)*VBS(IJ00(I,J))
        END DO
      END DO
      CALL SHALFMAT(NSTR,W(NW1+1),W(NWSHALF+1),W(NW2+1),W(NW3+1))
C
C     Mulliken Weights
C
      WSUM = 0.0D0
      DO I=1, NSTR
        WEIGHT1(I)=0.0D0
        SHALF=DSQRT(VBS(IJ00(I,I)))
        CSTRN(I) = CSTR(I)*SHALF
        DO J=1,NSTR
          WEIGHT1(I)=WEIGHT1(I)+CSTR(I)*CSTR(J)*VBS(IJ00(I,J))
        END DO
        WSUM = WSUM + WEIGHT1(I)
      END DO
      DO I=1, NSTR
        WEIGHT1(I) = WEIGHT1(I)/WSUM
      END DO
      WRITE(IOUTVB,*)
      WRITE(IOUTVB,1000)
      WRITE(IOUTVB,'(10F8.4)')(CSTRN(I),I=1,NSTR)
      WRITE(IOUTVB,*)
      WRITE(IOUTVB,1010)
      WRITE(IOUTVB,'(10F8.4)')(WEIGHT1(I),I=1,NSTR)
      WRITE(IOUTVB,*)
C
C     Lowdin Weights
C     CLWD = S-half x CSTR
C
      WSUM = 0.0D0
      DO I=1, NSTR
      CLWD(I) = 0.0D0
        DO J=1, NSTR
          IJ = (J-1)*NSTR + I
          CLWD(I) = CLWD(I) + W(NWSHALF+IJ)*CSTR(J)*SHF(J)
        END DO
        WEIGHT3(I) = CLWD(I)*CLWD(I)
        WSUM = WSUM + WEIGHT3(I)
      END DO
      DO I=1, NSTR
        WEIGHT3(I) = WEIGHT3(I)/WSUM
      END DO
      IF(LOWDINOLD.EQ.1)
     &  WRITE(IOUTVB,'(" OLD LOWDIN WEIGHTS WILL BE PRINTED")')
      WRITE(IOUTVB,1020)
      WRITE(IOUTVB,'(10F8.4)')(WEIGHT3(I),I=1,NSTR)
      WRITE(IOUTVB,*)
C
C     Hiberty Weights
C
      WSUM = 0.0D0
      DO I=1, NSTR
        WEIGHT4(I) = CSTRN(I)**2
        WSUM = WSUM + WEIGHT4(I)
      END DO
      DO I=1, NSTR
        WEIGHT4(I) = WEIGHT4(I)/WSUM
      END DO
      WRITE(IOUTVB,1030)
      WRITE(IOUTVB,'(10F8.4)')(WEIGHT4(I),I=1,NSTR)
      WRITE(IOUTVB,*)
C
 1000 FORMAT(1X,'Normalized structure coefficients')
 1010 FORMAT(1X,'====Mulliken Weight====')
 1020 FORMAT(1X,'====Lowdin   Weight====')
 1030 FORMAT(1X,'====Hiberty  Weight====')
      RETURN
      END
      FUNCTION IJ00(I,J)
      COMMON /IAA/IA(100000)
      IF(I.GT.J) THEN
      IJ00=IA(I)+J
      ELSE
      IJ00=IA(J)+I
      ENDIF
      RETURN
      END
      FUNCTION IJ01(I,J)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /IBB/IB(100000),MWIN,MORBI
      IF(I.GT.J) THEN
        IF(J.LE.MORBI) IJ01=IB(I)+J
        IF(J.GT.MORBI) IJ01=IB(MWIN)+(I-MORBI)*(I-MORBI-1)/2+J
      ELSE
        IF(I.LE.MORBI) IJ01=IB(J)+I
        IF(I.GT.MORBI) IJ01=IB(MWIN)+(J-MORBI)*(J-MORBI-1)/2+I
      ENDIF
      RETURN
      END
      SUBROUTINE SETIAA()
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /IAA/IA(100000)
      IA(1) = 0
      DO I=2,100000
        IA(I) = IA(I-1) + I-1
      END DO
      RETURN
      END
      SUBROUTINE SETIND(M,NORT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /IAA/IA(100000)
      COMMON /IBB/IB(100000),MWIN,MORBI
      COMMON /ICC/IC(100000)
      COMMON /IDD/ID(100000)
      MORBI=NORT
      MWIN=M
      MSQ=IA(M+1)
      NORTSQ=IA(NORT+1)
      DO 104 I=1,NORT
  104 IB(I)=I*(I-1)/2
      DO 105 I=NORT+1,M
  105 IB(I)=IB(NORT)+(I-NORT)*NORT
      IB(M+1)=IB(M)+NORT
      NV=IB(M+1)
      DO 106 I=1,NV+1
  106 IC(I)=(I-1)*NV
      DO 107 I=NV+2,MSQ
  107 IC(I)=IC(NV+1)+(I-NV-1)*NORTSQ
      IC(MSQ+1)=IC(MSQ)+NORTSQ
      DO 108 I=1,NV+1
  108 ID(I)=I*(I-1)/2
      DO 109 I=NV+2,MSQ
  109 ID(I)=ID(NV+1)+(I-NV-1)*NORTSQ
      ID(MSQ+1)=ID(MSQ)+NORTSQ
      RETURN
      END
C
C     JIABO LI
C     DEC. 19, 1998
C     ORBITALS IN ORTHONORMALIZED BASIS FUNCTIONS
C     B IS ORTHONORMALIZED
C     C=<B|S0|A>
C     C->A
C
C     SUBROUTINE BASLOW(NBASIS,NA,NB,S,A,B,C,W,MSIZE,BASLOC,BASNOC)
      SUBROUTINE BASLOW(NBASIS,NA,NB,S,A,B,C,W,MSIZE,BASNOC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION S(NBASIS,NBASIS),A(NBASIS,NA),B(NBASIS,NB)
C     DIMENSION C(NB,*),W(NB,*),BASLOC(*),BASNOC(*)
      DIMENSION C(NB,*),W(NB,*),BASNOC(*)
      IF(MSIZE.LE.NBASIS*NBASIS) CALL ABORT0('BASLOW 001')
C
C     B'->W
C
      DO 100 I=1,NB
      DO 100 J=1,NBASIS
      W(I,J)=B(J,I)
 100  CONTINUE
C
C     <B|S>->C
C
      CALL MATMUL2(NB,NBASIS,NBASIS,W,S,C)
C
C     <C|A>
C
      CALL MATMUL2(NB,NBASIS,NA,C,A,BASNOC)
C
C     C->A
C
C200  CONTINUE
C     CALL INVMAT(NA,BASNOC,BASLOC,W,W(1,NA+1))
C     INVMAT NEEDS TO PUT BACK AS ARGUMENT IF ABOVE IS USED
C     BASLOC NEEDS TO PUT BACK AS ARGUMENT IF ABOVE IS USED
      RETURN
      END
C
C     JIABO LI
C     DEC. 19, 1998
C     PROJECT BASIS FUNCTIONS SET A INTO THE SUBSPACE OF SET B
C     B IS ORTHONORMALIZED
C     C=|B><B|S0|A>
C     C->A
C
      SUBROUTINE PROJEC(NBASIS,NA,NB,S,A,B,C,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION S(NBASIS,NBASIS),A(NBASIS,NA),B(NBASIS,NB)
      DIMENSION C(NBASIS,*),W(NB,*)
C
C     PROJECT A INTO SUBSPACE B
C
C     B'->W
C
      DO 100 I=1,NB
      DO 100 J=1,NBASIS
      W(I,J)=B(J,I)
 100  CONTINUE
C
C     |B><B|--->C
C
      CALL MATMUL2(NBASIS,NB,NBASIS,B,W,C)
C
C     |B><B|S0--->W
C
      CALL MATMUL2(NBASIS,NBASIS,NBASIS,C,S,W)
C
C     <W|A>
C
      CALL MATMUL2(NBASIS,NBASIS,NA,W,A,C)
C
C     C->A
C
      DO 200 I=1,NA
      DO 200 J=1,NBASIS
      A(J,I)=C(J,I)
 200  CONTINUE
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     LOWDIN ORTHOGONALIZATION
C
C     Note:
C               INPUT A(M,NA)
C               OUTPUT V(NA,M), BUT STORED IN V(M,NA) FORMAT !!!
C
C     History:
C               Frist created: Dec. 18, 1998
C               Added automatic correct threshold for ill-conditioned
C               S matrix. Sept. 19,2004
C               Added special case for NA.EQ.1. March 26, 2006
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE LOWD(M,NA,S0,A,SA,V,W, IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      PARAMETER (EPS = -1.0D-12)
      DIMENSION A(M,NA),S0(M,M),D(5000),SA(NA,NA),V(NA,M)
      DIMENSION W(M,*)
      IERR = 0
      IF(M.GT.5000) THEN
        WRITE(IOUTVB,*)'M.GT.5000'
        IERR = 1
        RETURN
      END IF
      IF(NA.EQ.1) THEN
        DO I=1, M
        V(1,I) = A(I,1)
        END DO
        RETURN
      END IF
      IF(NA.GT.M) THEN
        WRITE(IOUTVB,*)'NA.GT.M'
        IERR = 1
C       RETURN
      END IF
      IF (NA.LE.0) RETURN
      DO 300 I=1,M
      DO 300 J=1,NA
      V(J,I)=A(I,J)
 300  CONTINUE
      CALL MATMUL2(M,M,NA,S0,A,W)
      CALL MATMUL2(NA,M,NA,V,W,SA)
      CALL DIAG(SA,V,D,NA,NA)
C
C     SA**(-1/2)
C
      DO 100 I=1,NA
      DO 100 J=1,NA
 100  SA(I,J)=0.0D0
      DO 200 K=1,NA
      IF(D(K).LE.EPS) THEN
      WRITE(IOUTVB,*)'NA,K =',NA,K
      WRITE(IOUTVB,*)"D(K)=",(D(KX),KX=1,10)
      WRITE(IOUTVB,*)'NEGATIVE EIGENVALUES OF S MATRIX D=',D(K)
      IERR = 1
      RETURN
C     CALL ABORT0('LOWDIN02  ')
      END IF
      DK=1.0D0/DSQRT(DABS(D(K)))
      DO 200 I=1,NA
      DO 200 J=1,NA
      SA(I,J)=SA(I,J)+V(I,K)*V(J,K)*DK
 200  CONTINUE
C
C     LOWDIN BASIS ->V
C
      CALL MATMUL2(M,NA,NA,A,SA,V)
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     S**(1/2) matrix
C
C     History:
C               Frist created: Feb 25, 2003
C               Added automatic correct threshold for ill-conditioned
C               S matrix. Sept. 19,2004
C
C     Author:
C               Jiabo Li
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE SHALFMAT(M,S,SHM,W,V)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      PARAMETER (EPS = -1.0D-12)
      DIMENSION S(M,M),SHM(M,M),D(5000),V(M,M)
      DIMENSION W(M,M)
      IF(M.GT.5000) CALL ABORT0('LOWDIN01  ')
      IF (M.LE.0) RETURN
      DO 300 I=1,M
      DO 300 J=1,M
      W(J,I)=S(I,J)
 300  CONTINUE
      CALL DIAG(W,V,D,M,M)
C
C     S**(1/2)
C
      DO 100 I=1,M
      DO 100 J=1,M
 100  SHM(I,J)=0.0D0
      DO 200 K=1,M
      IF(D(K).LE.EPS) THEN
      WRITE(IOUTVB,*)'M =',M
      WRITE(IOUTVB,*)'NEGATIVE EIGENVALUES OF S MATRIX D=',D(K)
      CALL ABORT0('SHALFMAT01')
      END IF
      DK=DSQRT(DABS(D(K)))
      DO 200 I=1,M
      DO 200 J=1,M
      SHM(I,J)=SHM(I,J)+V(I,K)*V(J,K)*DK
 200  CONTINUE
      RETURN
      END
C
C     GET SPH AND NSHP PARTITION OF BASIS SET SPACE
C     NSHBAS: NUMBER OF NON-SPHERICAL/JUNK
C
C     SEE http://en.wikipedia.org/wiki/Table_of_spherical_harmonics
C
      SUBROUTINE GETSPH(M,BFLABE,S,BASSPH,BASNSH,W,NSHBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE(M),BTEMP
      DIMENSION DCS(6,5),FCS(10,7),GCS(15,9)
C     DIMENSION S(M,M),D(5000),BASNSH(M,*),W(*),BASSPH(M,*)
      DIMENSION S(M,M),BASNSH(M,*),W(*),BASSPH(M,*)
      DENMF3  =   3.8729833462074170D0
      DENMF21 =   1.7320508075688772D0
      DENMG4  =  10.2469507659595980D0
      DENMG31 =   3.8729833462074170D0
      DENMG22 =   3.0000000000000000D0
      DENMG211=   1.7320508075688772D0
C
C     INITIALIZE CARTESIAN TO SPHERICAL HARMONICS TRANSFORMAITON
C
C     Cartesian D: xx,yy,zz,xy,xz,yz
C     SH D: xy,xz,yz,z2,x2-y2
C
      DO I=1, 5
        DO J=1, 6
          DCS(J,I) = 0.0D0
        END DO
      END DO
      DO I=1, 7
        DO J=1, 10
          FCS(J,I) = 0.0D0
        END DO
      END DO
      DO I=1, 9
        DO J=1, 15
          GCS(J,I) = 0.0D0
        END DO
      END DO
      DCS(4,1) = 1.0D0
      DCS(5,2) = 1.0D0
      DCS(6,3) = 1.0D0
      DCS(1,4) = -1.0D0
      DCS(2,4) = -1.0D0
      DCS(3,4) =  2.0D0
      DCS(1,5) =  1.0D0
      DCS(2,5) = -1.0D0
C
C     Cartesian F: xxx,yyy,zzz,xxy,xxz,yyx,yyz,zzx,zzy,xyz
C                   1   2   3   4   5   6   7   8   9  10
C
C     2Z**3-3X**2Z-3Y**2Z
C       3    5       7
C
      FCS(3,1) = 2*DENMF3
      FCS(5,1) = -3*DENMF21
      FCS(7,1) = -3*DENMF21
C
C     3X**2Y-Y**3
C       4    2
C
      FCS(4,2) = 3*DENMF21
      FCS(2,2) = -DENMF3
C
C     X**3-3Y**2X
C       1    6
C
      FCS(6,3) = -3*DENMF21
      FCS(1,3) = DENMF3
C
C     X**2Z-Y**2Z
C       5    7
C
      FCS(5,4) = DENMF21
      FCS(7,4) = -DENMF21
C
C     XYZ
C     10
C
      FCS(10,5) = 1.0D0
C
C     4ZZY-XXY-YYY
C     9     4   2
C
      FCS(9,6) = 4*DENMF21
      FCS(4,6) = -DENMF21
      FCS(2,6) = -DENMF3
C
C     4ZZX-YYX-XXX
C     8     6   1
C
      FCS(8,7) = 4*DENMF21
      FCS(6,7) = -DENMF21
      FCS(1,7) = -DENMF3
C
C     Cartesian G: xxxx,yyyy,zzzz,xxxy,xxxz,yyyx,yyyz,zzzx,zzzy,
C                   1    2    3    4    5    6    7    8    9
C                  xxyy,xxzz,yyzz,xxyz,yyxz,zzxy
C                   10   11   12   13   14   15
C     8*zzzz-24xxzz-24yyzz+6xxyy+3xxxx+3yyyy
C       3      11    12     10    1      2
C
      GCS(1,1) = 3*DENMG4
      GCS(2,1) = 3*DENMG4
      GCS(3,1) = 8*DENMG4
      GCS(10,1) = 6*DENMG22
      GCS(11,1) = -24*DENMG22
      GCS(12,1) = -24*DENMG22
C
C     4xzzz-3xxxz-3yyxz
C       8      5     14
C
      GCS(5,2) =-3*DENMG31
      GCS(8,2) = 4*DENMG31
      GCS(14,2) =-3*DENMG211
C
C     4*yzzz-3yyyz-3xxyz
C       9     7     13
      GCS(7,3) =-3*DENMG31
      GCS(9,3) = 4*DENMG31
      GCS(13,3) =-3*DENMG211
C
C     yyyy - xxxx + 6xxzz - 6yyzz
C      2      1       11      12
C
      GCS(1,4) =-DENMG4
      GCS(2,4) = DENMG4
      GCS(11,4) = 6*DENMG22
      GCS(12,4) =-6*DENMG22
C
C     6zzxy-xxxy-yyyx
C      15    4    6
      GCS(4,5) =-DENMG31
      GCS(6,5) =-DENMG31
      GCS(15,5) = 6*DENMG211
C
C     xxxz-3yyxz
C      5     14
      GCS(5,6) = DENMG31
      GCS(14,6) = -3*DENMG211
C
C     yyyz-3xxyz
C      7    13
      GCS(7,7) = DENMG31
      GCS(13,7) = -3*DENMG211
C
C     xxxx + yyyy -6xxyy
C      1      2     10
      GCS(1,8) = DENMG4
      GCS(2,8) = DENMG4
      GCS(10,8) =-6*DENMG22
C
C     xxxy - yyyx
C       4     6
      GCS(4,9) = DENMG31
      GCS(6,9) =-DENMG31
C
      DO I=1, M
        DO J=1, M
          BASSPH(J,I) = 0.0D0
        ENDDO
      ENDDO
      MSPHHAR = 0
      DO I=1,M
        BTEMP = BFLABE(I)
        IF(BTEMP(10:12).EQ.'  s'.OR.BTEMP(10:12).EQ.'  x'.OR.
     &     BTEMP(10:12).EQ.'  y'.OR.BTEMP(10:12).EQ.'  z') THEN
             MSPHHAR=MSPHHAR+1
             BASSPH(I,MSPHHAR) = 1.0D0
        ELSE IF(BTEMP(10:12).EQ.' xx') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,6
               BASSPH(I+K-1,MSPHHAR) = DCS(K,1)
             END DO
        ELSE IF(BTEMP(10:12).EQ.' yy') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,6
               BASSPH(I+K-2,MSPHHAR) = DCS(K,2)
             END DO
        ELSE IF(BTEMP(10:12).EQ.' zz') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,6
               BASSPH(I+K-3,MSPHHAR) = DCS(K,3)
             END DO
        ELSE IF(BTEMP(10:12).EQ.' xy') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,6
               BASSPH(I+K-4,MSPHHAR) = DCS(K,4)
             END DO
        ELSE IF(BTEMP(10:12).EQ.' xz') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,6
               BASSPH(I+K-5,MSPHHAR) = DCS(K,5)
             END DO
        ELSE IF(BTEMP(10:12).EQ.' yz') THEN
C            SKIP
        ELSE IF(BTEMP(9:12).EQ.' xxx') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,10
               BASSPH(I+K-1,MSPHHAR) = FCS(K,1)
             END DO
        ELSE IF(BTEMP(9:12).EQ.' yyy') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,10
               BASSPH(I+K-2,MSPHHAR) = FCS(K,2)
             END DO
        ELSE IF(BTEMP(9:12).EQ.' zzz') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,10
               BASSPH(I+K-3,MSPHHAR) = FCS(K,3)
             END DO
        ELSE IF(BTEMP(9:12).EQ.' xxy') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,10
               BASSPH(I+K-4,MSPHHAR) = FCS(K,4)
             END DO
        ELSE IF(BTEMP(9:12).EQ.' xxz') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,10
               BASSPH(I+K-5,MSPHHAR) = FCS(K,5)
             END DO
        ELSE IF(BTEMP(9:12).EQ.' yyx') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,10
               BASSPH(I+K-6,MSPHHAR) = FCS(K,6)
             END DO
        ELSE IF(BTEMP(9:12).EQ.' yyz') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,10
               BASSPH(I+K-7,MSPHHAR) = FCS(K,7)
             END DO
        ELSE IF(BTEMP(9:12).EQ.' zzx') THEN
C            SKIP
        ELSE IF(BTEMP(9:12).EQ.' zzy') THEN
C            SKIP
        ELSE IF(BTEMP(9:12).EQ.' xyz') THEN
C            SKIP
C       G Blocks
        ELSE IF(BTEMP(8:12).EQ.' xxxx') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,15
               BASSPH(I+K-1,MSPHHAR) = GCS(K,1)
             END DO
        ELSE IF(BTEMP(8:12).EQ.' yyyy') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,15
               BASSPH(I+K-2,MSPHHAR) = GCS(K,2)
             END DO
        ELSE IF(BTEMP(8:12).EQ.' zzzz') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,15
               BASSPH(I+K-3,MSPHHAR) = GCS(K,3)
             END DO
        ELSE IF(BTEMP(8:12).EQ.' xxxy') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,15
               BASSPH(I+K-4,MSPHHAR) = GCS(K,4)
             END DO
        ELSE IF(BTEMP(8:12).EQ.' xxxz') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,15
               BASSPH(I+K-5,MSPHHAR) = GCS(K,5)
             END DO
        ELSE IF(BTEMP(8:12).EQ.' yyyx') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,15
               BASSPH(I+K-6,MSPHHAR) = GCS(K,6)
             END DO
        ELSE IF(BTEMP(8:12).EQ.' yyyz') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,15
               BASSPH(I+K-7,MSPHHAR) = GCS(K,7)
             END DO
        ELSE IF(BTEMP(8:12).EQ.' zzzx') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,15
               BASSPH(I+K-8,MSPHHAR) = GCS(K,8)
             END DO
        ELSE IF(BTEMP(8:12).EQ.' zzzy') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,15
               BASSPH(I+K-9,MSPHHAR) = GCS(K,9)
             END DO
        ELSE IF(BTEMP(8:12).EQ.' xxyy'.OR.BTEMP(8:12).EQ.' xxzz'.OR.
     &          BTEMP(8:12).EQ.' yyzz'.OR.BTEMP(8:12).EQ.' xxyz'.OR.
     &          BTEMP(8:12).EQ.' yyxz'.OR.BTEMP(8:12).EQ.' zzxy') THEN
C            SKIP
        ELSE
C            H, ...HERE. The following two lines means skip
C            projection.
             MSPHHAR=MSPHHAR+1
             BASSPH(I,MSPHHAR) = 1.0D0
        END IF
      END DO
      MSHBAS = MSPHHAR
      CALL SHMIDT2(M,MSHBAS,BASSPH,S,NB,W)
      IF(MSHBAS.NE.NB) CALL ABORT0("GETSPH0001")
      NSHBAS = M - NB
C
C     COPY BACK TO BASSPH FROM W
C
      DO I=1, MSHBAS
        IM = (I-1)*M
        DO J=1, M
          BASSPH(J,I) = W(IM+J)
        END DO
      END DO
      DO I=1, NSHBAS
        DO J=1, M
          BASNSH(J,I) = VBRAND(0)
        END DO
      END DO
      CALL ORTHAB(M,MSHBAS,NSHBAS,S,BASSPH,BASNSH,W)
      CALL SHMIDT2(M,NSHBAS,BASNSH,S,NB,W)
      DO I=1, NSHBAS
        IM = (I-1)*M
        DO J=1, M
          BASNSH(J,I) = W(IM+J)
        END DO
      END DO
      RETURN
      END
C
C     GET NUMBER OF NON-SPHERICAL HARMONIC COUNT
C
      SUBROUTINE COUNTNSP(M,BFLABE,NSHBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE(M),BTEMP
      NSHBAS = 0
      DO I=1,M
        BTEMP = BFLABE(I)
        IF (BTEMP(10:12).EQ.' xx') THEN
             NSHBAS = NSHBAS + 1
        ELSE IF (BTEMP(9:12).EQ.' xxx') THEN
             NSHBAS = NSHBAS + 3
        ELSE IF (BTEMP(8:12).EQ.' xxxx') THEN
             NSHBAS = NSHBAS + 6
C       Add more here of h ...
C       Make sure it is consistent with GETSPH
C       ELSE IF (BTEMP(7:12).eq.' xxxxx') THEN
C            NSHBAS = NSHBAS + 6
        END IF
      END DO
      RETURN
      END
C
C     JIABO LI
C     NOV. 24, 1998
C     ORBITAL SET B ORTHOGONALIZED TO ORBITAL SET A
C     SET A REMAINS UNCHANGED
C
      SUBROUTINE ORTHAB(M,NA,NB,S0,A,B,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(M,*),B(M,*),S0(M,M),D(5000),W(M,M)
      IF(M.GT.5000) CALL ABORT0('ORTHAB01  ')
      IF(NA.LE.0.OR.NB.LE.0) RETURN
C
C     COPY A-->W
C
      DO 350 I=1,NA
      DO 350 J=1,M
      W(J,I)=A(J,I)
  350 CONTINUE
C
C     CALL SCHMIDT FOR THE FIRST NA ORBITALS IN WORK FIELD
C
      CALL SHMIDT(M,NA,W,S0)
      DO 300 I=1,NB
      DO 310 J=1,M
      D(J)=0.0D0
      DO 310 K=1,M
 310  D(J)=D(J)+S0(K,J)*B(K,I)
      DO 315 J=1,NA
      SUM=0.0D0
      DO 320 K=1,M
 320  SUM=SUM+D(K)*W(K,J)
      DO 340 K=1,M
 340  B(K,I)=B(K,I)-SUM*W(K,J)
 315  CONTINUE
 300  CONTINUE
      RETURN
      END
C
C     JIABO LI
C     NOV. 24, 2005
C     ORBITAL SET A ORTHOGONALIZED AND STORED IN B
C     SET A REMAINS UNCHANGED
C
      SUBROUTINE SETNORB(M,NSUB,MLORBIT,MNORBIT,BASIS,S0,B,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION BASIS(M,*),S0(M,M),B(M,*),W(M,*)
      DIMENSION MLORBIT(*),MNORBIT(*)
      IF(M.GT.5000) CALL ABORT0('SETNORB001')
      NAT=0
      NBT=0
      DO I=1, NSUB
      NA = MLORBIT(I)
      CALL SHMIDT2(M,NA,BASIS(1,NAT+1),S0,NB,W)
      DO 300 J=1,NB
      NBT = NBT + 1
      DO 310 K=1,M
 310  B(K,NBT) = W(K,J)
 300  CONTINUE
      NAT = NAT + MLORBIT(I)
      MNORBIT(I) = NB
      END DO
      RETURN
      END
C
C     JIABO LI
C     DEC. 16, 2005
C     ORBITAL SET A ORTHOGONALIZED AND STORED IN B
C     IT IS ASSUMED THAT THE RANK OF BASIS IS NBASIS, I.E. IT CONTAINS
C     M LINEARLY INDEPNDENT VECTORS
C
C     SET A REMAINS UNCHANGED
C
      SUBROUTINE SETNORB2(M,NSUB,MLORBIT,MNORBIT,BASIS,S0,B,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION BASIS(M,*),S0(M,M),B(M,*),W(M,*)
      DIMENSION MLORBIT(*),MNORBIT(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      IF(M.GT.5000) CALL ABORT0('SETNORB001')
      NAT=0
      NBT=0
      DO I=1, NSUB
      NA = MLORBIT(I)
      CALL SHMIDT2(M,NA,BASIS(1,NAT+1),S0,NB,W)
      DO 300 J=1,NB
      NBT = NBT + 1
      DO 310 K=1,M
 310  B(K,NBT) = W(K,J)
 300  CONTINUE
      NAT = NAT + MLORBIT(I)
      IF(MNORBIT(I).NE.NB) THEN
        WRITE(IOUTVB,*)"I, NB, MNORBIT =",I,NB, MNORBIT(I)
C       CALL ABORT0("SETNORB201")
      END IF
      END DO
C
      NVIR = M - NBT
      MLORBIT(NSUB+1) = NVIR
      MNORBIT(NSUB+1) = NVIR
      NA = NVIR
      IF(NVIR.LT.1) GOTO 400
      CALL SHMIDT2(M,NA,BASIS(1,NAT+1),S0,NB,W)
      DO 301 J=1,NB
      NBT = NBT + 1
      DO 311 K=1,M
 311  B(K,NBT) = W(K,J)
 301  CONTINUE
      IF(NB.NE.NVIR) CALL ABORT0("SETNORB202")
 400  CONTINUE
      RETURN
      END
C
C     JIABO LI
C     NOV. 24, 1998
C
C     THE SUBROUTINE IS CALLED TO PERFORM SCHMIDT ORTHONORMALIZATION
C
C     A: VECTORS OF OBRITALS, CONSISTS OF NA ORBITALS NEED TO BE
C        ORTHONORMALIZED
C
      SUBROUTINE SHMIDT(M,NA,A,S0)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      PARAMETER (EPS=10.0D0**(-10))
      DIMENSION A(M,*),S0(M,M),D(5000)
      IF(M.GT.5000) CALL ABORT0('SCHMIDT01 ')
      IF(NA.LE.0) RETURN
C
C     NORMALIZATION OF THE FIRST ORBITAL
C
      SUM=0.0D0
      DO 100 L=1,M
      DO 100 K=1,M
 100  SUM=SUM+A(K,1)*S0(K,L)*A(L,1)
      SUM=DSQRT(SUM)
      DO 110 I=1,M
 110  A(I,1)=A(I,1)/SUM
C
C     ORTHOGONALIZATION OF THE REMAINING ORBITALS
C
      DO 200 I=2,NA
      DO 210 J=1,M
      D(J)=0.0D0
      DO 210 K=1,M
  210 D(J)=D(J)+S0(K,J)*A(K,I)
      DO 220 J=1,I-1
      SUM=0.D0
      DO 230 K=1,M
 230  SUM=SUM+D(K)*A(K,J)
      DO 240 K=1,M
 240  A(K,I)=A(K,I)-SUM*A(K,J)
 220  CONTINUE
C
C     NORMALIZATION
C
      SUM=0.0D0
      DO 250 L=1,M
      DO 250 K=1,M
 250  SUM=SUM+A(K,I)*S0(K,L)*A(L,I)
      SUM=DSQRT(SUM)
      IF(SUM.LT.EPS) THEN
      WRITE(IOUTVB,*)'WARNING: SUM<EPS in SCHMIDT'
      END IF
      DO 260 J=1,M
 260  A(J,I)=A(J,I)/SUM
 200  CONTINUE
      RETURN
      END
C
C     JIABO LI
C     NOV. 24, 2005
C
C     THE SUBROUTINE IS CALLED TO PERFORM SCHMIDT ORTHONORMALIZATION
C
C     A: VECTORS OF OBRITALS, CONSISTS OF NA ORBITALS NEED TO BE
C        ORTHONORMALIZED
C     B: STORE ORTHONORMALIZED VECTORS. LINEAR DEPENDENT VECTORS ARE
C        REMOVED
C
C     August 8 2009 JLI: IMPROVED NUMERICAL STABILITY BY RE-NORMALIZATION
C
      SUBROUTINE SHMIDT2(M,NA,A,S0,NB,B)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      PARAMETER (EPS=1.0D-8)
      DIMENSION A(M,*),S0(M,M),D(5000),B(M,*)
      IF(M.GT.5000) CALL ABORT0('SCHMIDT01 ')
      IF(NA.LE.0) RETURN
      NB = 0
      DO 200 I=1,NA
      NB1 = NB + 1
        DO 210 J=1,M
        D(J)=0.0D0
        B(J,NB1) = A(J,I)
        DO 210 K=1,M
  210   D(J)=D(J)+S0(K,J)*A(K,I)
        DO 220 J=1,NB
        SUM=0.D0
        DO 230 K=1,M
 230    SUM=SUM+D(K)*B(K,J)
        DO 240 K=1,M
 240    B(K,NB1)=B(K,NB1)-SUM*B(K,J)
 220    CONTINUE
C
C     NORMALIZATION
C
        SUM=0.0D0
        DO 250 L=1,M
        DO 250 K=1,M
 250    SUM=SUM+B(K,NB1)*S0(K,L)*B(L,NB1)
        SUM=DSQRT(SUM)
        IF(SUM.LT.EPS) THEN
        WRITE(IOUTVB,*)'LINEAR DEPENDENT VECTOR IDENTIFIED'
        ELSE
        DO 260 J=1,M
 260    B(J,NB1)=B(J,NB1)/SUM
C
C       DO ANOTHER PROJECTION TO REMOVE NUMERICAL ROUNDOFF ERROR,
C       ESPECIALLY FOR SMALL NORMAL VALUE
C
        DO 211 J=1,M
        D(J)=0.0D0
        DO 211 K=1,M
  211   D(J)=D(J)+S0(K,J)*B(K,NB1)
        DO 221 J=1,NB
        SUM=0.D0
        DO 231 K=1,M
 231    SUM=SUM+D(K)*B(K,J)
        DO 241 K=1,M
 241    B(K,NB1)=B(K,NB1)-SUM*B(K,J)
 221    CONTINUE
C
C       RE-NORMALIZATION
C
        SUM=0.0D0
        DO 251 L=1,M
        DO 251 K=1,M
 251    SUM=SUM+B(K,NB1)*S0(K,L)*B(L,NB1)
        SUM=DSQRT(SUM)
        DO 261 J=1,M
 261    B(J,NB1)=B(J,NB1)/SUM
        NB = NB1
        END IF
 200  CONTINUE
      RETURN
      END
C     A GENERAL SUBROUTINE FOR ONE- AND TWO-ELECTRON INTEGRAL
C     TRANSFORMATION. FOR THE 4-INDEX(TWO-ELECTRON INTEGRALS) TRANSFORMATION,
C     THE N**5 ALGORITHM IS USED.
C
C     ON ENTRY:
C
C     M:   TOTAL NUMBER OF BASIS FUNCTIONS
C     NA:  NUMBER OF ORBITALS OF A SUBSYSTEM(E.G. VB ORBITALS)
C          THIS SUBROUTINE ASSUMES THAT THE NA ORBITALS ARE ORTHOGONAL TO
C          THE ORBITALS OF OTHER SUBSYSTEMS (E.G.CORE ORBITALS),BUT MAY NOT
C          BE ORTHOGONAL AMONG THEMSELF. THE NA ORBITALS ARE STORED IN
C          ARRAY A.
C     NB:  NUMBER OF VIRTUAL ORBITALS
C          THOSE ORBITALS ARE NOT OCCUPIED BY ANY ELECTRONS. THUS THEY ARE
C          ORTHOGONALIZD TO ALL USED ORBITALS
C          M = NOTHER + NA + NB
C          (IF ONLY SINGLE POINT ENERGY IS CALCULATED, ONE CAN SET NB=0)
C          (NOTHER: THE NUMBER OF ORBITALS OF ALL OTHER SUBSYSTEMS)
C
C     A:   VECTORS FOR ALL M ORBITALS AS LINEAR COMBINATIONS OF
C          THE M BASIS FUNCTIONS. THE ORBITALS ARE STORED IN THE ARRAY IN
C
C     S0:  OVERLAP IN GLOBAL AO BASIS FUNCTIONS
C     F0:  HAMILTONIAN IN GLOBAL AO BASIS FUNCTIONS
C     G0:  TWO-ELECTRON INTEGRALS IN GLOBAL AO BASIS FUNCTIONS
C
C     ON EXIT:
C
C     ECORE: CORE ELECTRON ENERGY OF THE DOUBLE-OCCUPIED ORBITALS
C     S0:  OVERLAP IN ORBITALS AFTER PROJECTION FROM ALL USED ORBITALS OF OTHER
C          SUBSYSTEMS (INCLUDING CORE ORBITALS)
C     F0:  HAMILTONIAN IN ORBITAL BASIS AFTER PROJECTION
C     GW:  WORK BUFFER FOR NEW TWO-ELCTRON INTEGRALS IN OBRITAL BASIS
C          ALL NEW 2-E INTEGRALS ARE STORED ON DISK.
C          THIS ROUTINE PERFORMS PARTIAL INTEGRAL TRANSFORMATION, SINCE
C          FOR UPDATING VB ORBITALS, A FULL TRANSFORMATION IS NOT NECESSARY
C          ANY 4-INDEX INTEGRAL INVOLVES THREE OR FOUR INDECES OF VIRTUAL
C          ORBITALS IS NOT USED, THEREFORE THOSE INTEGRALS ARE NOT CALCULATED
C          NOR STORED IN THE DISK FILE.
C
C          ONE CAN ALLWAYS PERFORM A FULL TRANSFORMATION BY ASSUME ALL ORBITALS
C          ARE USED (I.E. NA=M)
C
C     CORRESPONDING TO SUCH A PARTITIONING, THE TWO-ELECTRON
C     INTEGRALS G(I,J,K,L) ARE ALSO DIVIDED INTO TWO PARTS:
C     PART I: M >= I >= 1, NA >= J >=1; IJ>= KL   (I>J; K>L)
C     PART II:M >= I,J >= 1, AND NA >= K,L      (I>J; K>L)
C
C     PART I:
C     SECTION A: I,J <=NA; K,L<=NA, and IJ>=KL
C     SECTION B: I>NA,J<=NA, K,L<=NA
C     SECTION C: I>NA,J<=NA,K>NA,L<=NA,K<I
C
C     PART II:
C     SECTION D: I,J>NA, K,L<=NA
C     STORAGE: (A+B+C)+D
C
C     THE INTEGRALS ARE STORED IN THE FOLLOWING WAY:
C
C     *****************************************************
C      *   A   |           *                              *
C        *   PART I        *           PART II            *
C          *   |     B     *             D                *
C            * |           *                              *
C              * - - - - - ********************************
C                *         *
C                  *   C   *
C                    *     *
C                      *   *
C                        * *
C                          *
C
C     BY ASSUMING NA=M AND NB=0, THEN FULL TRANSFORMATION WILL BE
C     PERFORMED AND THE NEW INTEGRALS WILL BE STORED IN THE USUAL
C     CARNONICAL ORDER
C
C     BUFFER SIZE IS LBUFF. THE NEW INTEGRALS ARE WRITTEN ON A DISK FILE
C
C     Jiabo Li, Revision history:NOV.25,1993 (first version)
C                                APR.05,1994 (partial integral transformation)
C                                FEB.28,1998 (re-organized)
C                                JUL.01,1998 (separate COREDM and TRAN)
C                                JAN.21,1999 (COREDM removed)
C                                SEP.06,1999 (simplified and reorganized)
C                                JAN.06,2000 (S and H matrixes are exported)
C                                APR.21,2004 (TRANN-> TRAN1E and TRANN2E)
C                                JUN.02,2004 clean up
C
      SUBROUTINE TRANN2E(M,NA,NB,G0,A,P,W,PSQ,LBUFF,IOUT2E)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION G0(*),A(M,M),P(M,M),PSQ(*),W(*)
      DIMENSION DC1(2047),GW(10000),IJKLW(10000)
      COMMON /IAA/IA(100000)
      MSQ=M*(M+1)/2
      NEXTRA=20
      IF(MSQ.GT.100000.OR.NA+NB.GT.M+NEXTRA) CALL ABORT0('TRAN2E0001')
      IF(LBUFF.GT.10000) CALL ABORT0('TRAN2E0002')
      NAB=NA+NB
C     NSQ=NAB*(NAB+1)/2
C
C     THE N**5 ALGORITHM FOR THE FOUR-INDEX TRANSFORMATION
C
      IJKLS=0
C     MM=M*M
      DO 100 L=1,NA
      DO 110 IJ=1,MSQ
      IAIJ=IA(IJ)
      DO 120 K1=1,IJ
 120  PSQ(K1)=G0(IAIJ+K1)
      DO 121 K1=IJ+1,MSQ
 121  PSQ(K1)=G0(IA(K1)+IJ)
      CALL MALTSQ(M,MSQ,PSQ,DC1,A(1,L))
      LL=L
      DO 130 K=LL,NAB
      XX=0.0D0
      KK=K
      DO 135 KX=1,M
  135 XX=XX+DC1(KX)*A(KX,KK)
      W((K-1)*IA(M+1)+IJ)=XX
 130  CONTINUE
 110  CONTINUE
      DO 100 K=LL,NAB
      KK=(K-1)*MSQ
      DO 220 K1=1,M
      K1JJ=IA(K1)+KK
      DO 221 K2=1,K1
 221  P(K2,K1)=W(K1JJ+K2)
      K1JJ=K1+KK
      DO 222 K2=K1+1,M
 222  P(K2,K1)=W(IA(K2)+K1JJ)
 220  CONTINUE
      J1=1
      J2=NAB
      IF(K.GT.NA) J2=NA
      DO 100 J=J1,J2
      CALL MALTID(M,P,DC1,A(1,J))
      II=J
      IF(K.GT.J) II=K
      IF(J.LT.L) II=K+1
      DO 100 I=II,NAB
      XX=0.0D0
      DO 235 KX=1,M
  235 XX=XX+DC1(KX)*A(KX,I)
      IJKLS=IJKLS+1
      IJKLW(IJKLS)=IJKLGX(I,J,K,L)
      GW(IJKLS)=XX
      IF(IJKLS.GE.LBUFF) THEN
      WRITE(IOUT2E)(IJKLW(KKK),GW(KKK),KKK=1,LBUFF)
      IJKLS=0
      END IF
 100  CONTINUE
      IF(IJKLS.NE.0) WRITE(IOUT2E)(IJKLW(KKK),GW(KKK),KKK=1,IJKLS)
      RETURN
      END
C
C     1E INTEGRAL TRANSFORMATION WITH EFFECTIVE HF POTENTIAL (IF IHFPO=1)
C
      SUBROUTINE TRAN1E(M,NAB,S0,F0,A,P,W,PSQ,IHFPO,IOUT2E)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION S0(*),F0(*),A(*),P(*),PSQ(*),W(*)
      MSQ=M*(M+1)/2
      NSQ=NAB*(NAB+1)/2
      IF(IHFPO.EQ.1) THEN
      CALL FKENGI(W,PSQ,M,1)
        DO I=1,MSQ
        F0(I) = W(I) + F0(I)
        END DO
      END IF
C
      CALL MATRAN(M,NAB,A,P,F0,W)
      DO I=1,NSQ
      F0(I) = W(I)
      END DO
C
C     GET THE NEW OVERLAP MATRIX ELEMENTS
C
      CALL MATRAN(M,NAB,A,P,S0,W)
      DO I=1,NSQ
      S0(I)=W(I)
      END DO
      WRITE(IOUT2E)(S0(I),I=1,NSQ)
      WRITE(IOUT2E)(F0(I),I=1,NSQ)
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Integral-driven 2E transformation.
C
C     Note:
C               Scratch space size can be calculated by the following formula
C               KLMX   = NORB*(NORB+1)/2+NORB*NVIR
C               NTINT  = KLMX*(KLMX+1)/2 + NORB*(NORB+1)*NVIR*(NVIR+1)/4
C               NWNEED = MAX(NTINT,MSQ*NBASIS)
C
C     History:
C               First created in April, 2004
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE TRANP2E(NBASIS,NORB,NVIR,A,W,NWRK,LBUFF,
     &                   IOTEMPA,IOTEMPB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(NBASIS,NORB),W(NWRK)
C     DIMENSION IB(2000),DC1(2047),GW(20000),IJKLW(20000)
      DIMENSION IB(2000),GW(20000),IJKLW(20000)
      GW(1) = 0.0D0
C     IJKLW(1) = 0.0D0
      IJKLW(1) = 0
      MSQ   = NBASIS*(NBASIS+1)/2
      IF(NBASIS.GT.2000) CALL ABORT0('TRANP2E001')
      DO I=1,NORB+1
      IB(I)=I*(I-1)/2
      END DO
      MORB = NORB + NVIR
      DO I=NORB+1,MORB+1
      IB(I) = IB(I-1) + NORB
      END DO
      KLMX   = NORB*(NORB+1)/2+NORB*NVIR
      NTINT  = KLMX*(KLMX+1)/2 + NORB*(NORB+1)*NVIR*(NVIR+1)/4
      NWNEED = MAX(NTINT,MSQ*NBASIS)
      IF(NWNEED.GT.NWRK) CALL ABORT0('TRANP2E000')
C
C     Transfer the first index
C
      MINWRK = NBASIS*MSQ
      NGWRK  = NWRK/MINWRK
      NG     = NGWRK
      NORBSTA= 0
      REWIND(IOTEMPA)
C     TIME=XCLOCK()
      IF(NGWRK.LT.1) CALL ABORT0('TRAN2E0002')
  10  IF(NORBSTA+NG.GT.NORB) NG = NORB - NORBSTA
      NORBSTA1= NORBSTA+1
C     NW      = NG*MINWRK
      NGNB    = NG*NBASIS
      CALL TRANSP1(NBASIS,MSQ,NG,A(1,NORBSTA1),W)
      CALL WRT2EP1(NBASIS,MSQ,NGNB,NORBSTA,LBUFF,W,IOTEMPA)
      NORBSTA = NORBSTA + NG
      IF(NORBSTA.LT.NORB) GOTO 10
C     TIME1 = XCLOCK()
C     WRITE(IOUTVB,*)'TRANSP1 TIME = ',TIME1-TIME
C
C     WRITE A EMPTY RECORD TO TERMINATE THE INTEGRALS
C
      NWORD = 0
      WRITE(IOTEMPA)(GW(I),I=1,LBUFF),(IJKLW(I),I=1,LBUFF*2),NWORD
C
C     Transfer the second index
C
      MINWRK = MSQ
      NGWRK  = NWRK/MINWRK
      NG     = NGWRK
      NSQ    = IB(MORB+1)
      NSQSTA = 0
      REWIND(IOTEMPA)
      REWIND(IOTEMPB)
      IF(NGWRK.LT.1) CALL ABORT0('TRAN2E0003')
  20  IF(NSQSTA+NG.GT.NSQ) NG = NSQ - NSQSTA
C     NSQSTA1= NSQSTA+1
C     NW     = NG*MINWRK
      CALL TRANSP2(NBASIS,MORB,MSQ,IB,NSQSTA,NG,A,W,LBUFF,
     &             IOTEMPA)
      CALL WRT2EP2(MSQ,NG,NSQSTA,LBUFF,W,IOTEMPB)
      NSQSTA = NSQSTA + NG
      IF(NSQSTA.LT.NSQ) GOTO 20
C
C     WRITE A EMPTY RECORD TO TERMINATE THE INTEGRALS
C
      NWORD = 0
      WRITE(IOTEMPB)(GW(I),I=1,LBUFF),(IJKLW(I),I=1,LBUFF*2),NWORD
C     TIME = XCLOCK()
C
C     Transfer the third index
C
      MINWRK = NBASIS*IB(MORB+1)
      NGWRK  = NWRK/MINWRK
      NG     = NGWRK
      NORBSTA= 0
      REWIND(IOTEMPA)
      REWIND(IOTEMPB)
      IF(NGWRK.LT.1) CALL ABORT0('TRAN2E0004')
  30  IF(NORBSTA+NG.GT.MORB) NG = MORB - NORBSTA
      NORBSTA1= NORBSTA+1
C     NW      = NG*MINWRK
      CALL TRANSP3(NBASIS,KLMX,NG,A(1,NORBSTA1),W,
     &             LBUFF,IOTEMPB)
      CALL WRT2EP3(NBASIS,KLMX,NG,NORBSTA,LBUFF,W,IOTEMPA)
      NORBSTA = NORBSTA + NG
      IF(NORBSTA.LT.MORB) GOTO 30
      NWORD = 0
      WRITE(IOTEMPA)(GW(I),I=1,LBUFF),(IJKLW(I),I=1,LBUFF*2),NWORD
C
C     Transfer the 4-th index
C
C     TOTAL INTEGRALS
C
C     NTINT  = KLMX*(KLMX+1)/2 + NORB*(NORB+1)*NVIR*(NVIR+1)/4
      IF(NTINT.GT.NWRK) CALL ABORT0('TRAN2PX000')
      CALL GETIOUNIT('IVBO2E  ',IVBO2E)
      REWIND(IOTEMPA)
      REWIND(IOTEMPB)
      REWIND(IVBO2E)
      CALL TRANSP4(NBASIS,NORB,MORB,A,W,NTINT,LBUFF,IOTEMPA)
      CALL GWRTE(W,NTINT,LBUFF,IVBO2E)
C     TIME = XCLOCK()
C     WRITE(IOUTVB,*)'TRANSP4 TIME = ',TIME-TIME1
C
      RETURN
      END
C
C     TRANSFORMATION OF THE FIRST INDEXES
C     IA,JA,KA,LA - > IO,JA,KA,LA
C
C     STORAGE OF INTEGRAL (IO,JA | KA,LA): W(KLA,IOJA)
C     WHERE IOJA = (IO-1)*NBASIS + JA
C           KLA  = KA*(KA-1)/2 + LA
C
      SUBROUTINE TRANSP1(NBASIS,MSQ,NG,C,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
CGMS  COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      DIMENSION C(NBASIS,NG),W(MSQ,NBASIS*NG)
      DIMENSION IAA(2000),GG(100000)
      DIMENSION II(100000),JJ(100000),KK(100000),LL(100000)
      DO I=1, NBASIS+1
      IAA(I) = I*(I-1)/2
      END DO
      CALL GETIOUNIT('IAO2E   ',IAO2E)
C000  REWIND(IAO2E)
CSMI  REWIND(10)
CSMI  REWIND(11)
CGMS  REWIND(IS)
      DO J=1, NBASIS*NG
        DO I=1, MSQ
        W(I,J) = 0.0D0
        END DO
      END DO
 10   CONTINUE
      CALL IJKLGG(IAO2E,GG,II,JJ,KK,LL,NINT)
C     WRITE(6,*) 'OUT OF IJKLGG IN TRANSP1 WITH NINT =',NINT
C
C     ASSUME IA,JA,KA,LA ARE SORTED
C
      DO IJKL=1, NINT
      IA  = II(IJKL)
      JA  = JJ(IJKL)
      KA  = KK(IJKL)
      LA  = LL(IJKL)
      VAL = GG(IJKL)
      IJA = IAA(IA)+JA
      KLA = IAA(KA)+LA
C
C     LOOP OVER ALL ORBITALS
C
        MM = JA - NBASIS
        DO IO=1, NG
          MM = MM+NBASIS
          W(KLA,MM) = W(KLA,MM) + C(IA,IO)*VAL
        END DO
        IF(IA.NE.JA) THEN
          MM = IA - NBASIS
          DO IO=1, NG
          MM = MM + NBASIS
          W(KLA,MM) = W(KLA,MM) + C(JA,IO)*VAL
          END DO
        END IF
        IF(IJA.NE.KLA) THEN
          MM = LA - NBASIS
          DO IO=1, NG
          MM = MM + NBASIS
          W(IJA,MM) = W(IJA,MM) + C(KA,IO)*VAL
          END DO
          IF(KA.NE.LA) THEN
            MM = KA - NBASIS
            DO IO=1, NG
            MM = MM + NBASIS
            W(IJA,MM) = W(IJA,MM) + C(LA,IO)*VAL
            END DO
          END IF
        END IF
      END DO
      IF(NINT.NE.0) GOTO 10
CGMS  REWIND(IS)
C
C     TEST THE FIRST INDEX TRANS
C
C     CALL TRANDD1(NBASIS,NORB,C,W,W(1,NBASIS*NG+1),MSQ)
      RETURN
      END
      SUBROUTINE WRT2EP1(NBASIS,MSQ,NGNB,NORBSTA,LBUFF,W,IOTEMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION W(MSQ,NGNB),GW(20000),IJW(20000),KLW(20000)
      EPS = 1.0D-10
      IF(LBUFF.GT.20000) CALL ABORT0('WRT2EP1002')
      NINT=0
      DO J=1, NGNB
        DO I=1, MSQ
        IF(ABS(W(I,J)).GT.EPS) THEN
        NINT = NINT + 1
        GW(NINT) = W(I,J)
        IJW(NINT)= I
        KLW(NINT)= J+NORBSTA*NBASIS
        END IF
        IF(NINT.GE.LBUFF) THEN
        WRITE(IOTEMP)(GW(K),K=1,LBUFF),(IJW(K),K=1,LBUFF),
     &               (KLW(K),K=1,LBUFF),NINT
        NINT = 0
        END IF
        END DO
      END DO
      IF(NINT.GT.0) THEN
      WRITE(IOTEMP)(GW(K),K=1,LBUFF),(IJW(K),K=1,LBUFF),
     &             (KLW(K),K=1,LBUFF),NINT
      END IF
      RETURN
      END
C
C     TRANSFORMATION OF THE SECOND INDEXES
C     IA,JA,KA,LO - > IA,JA,KO,LO
C
C     STORAGE OF INTEGRAL (IA,JA | KO,LO): W(KLO,IJA)
C     WHERE IJA = IJ00(IA,JA)
C           KLO = IA(KO) + LO
C           SKIP IF NSQSTA >= KLO > NSQSTA+NG
C
      SUBROUTINE TRANSP2(NBASIS,MORB,MSQ,IB,NSQSTA,NG,C,W,
     &                   LBUFF,IOTEMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION C(NBASIS,*),W(MSQ,*)
      DIMENSION IB(*),IJW(20000),KLW(20000),GW(20000),IJTAB(2,100000)
      REWIND(IOTEMP)
      IJMX = NBASIS*(NBASIS+1)/2
      IF(IJMX.GT.100000)  CALL ABORT0('TRANSP2001')
      IF(LBUFF.GT.20000)  CALL ABORT0('TRANSP2001')
      DO IJ = 1, IJMX
      CALL DECODEIJ(IJ,IA,JA)
      IJTAB(1,IJ) = IA
      IJTAB(2,IJ) = JA
      END DO
      DO J=1, NG
        DO I=1, MSQ
        W(I,J) = 0.0D0
        END DO
      END DO
 10   CONTINUE
      READ(IOTEMP)(GW(K),K=1,LBUFF),(IJW(K),K=1,LBUFF),
     &            (KLW(K),K=1,LBUFF),NINT
      DO IJKL=1, NINT
      LO  = (KLW(IJKL)-1)/NBASIS + 1
      KA  = KLW(IJKL)-(LO-1)*NBASIS
      IJA = IJW(IJKL)
      VAL = GW(IJKL)
      IA = IJTAB(1,IJA)
      JA = IJTAB(2,IJA)
C
C     LOOP OVER ALL ORBITALS
C
        DO KO=LO, MORB
          KLO = IB(KO) + LO - NSQSTA
          IF(KLO.LE.NG.AND.KLO.GT.0) THEN
             W(IJA,KLO)=W(IJA,KLO)+C(KA,KO)*VAL
          END IF
        END DO
C 100 CONTINUE
C
      END DO
      IF(NINT.GT.0) GOTO 10
C
C     TEST SECOND INDEX
C
C     CALL TRANDD2(NBASIS,NORB,MORB,C,W,W(1,NG+1),MSQ)
      RETURN
      END
      SUBROUTINE WRT2EP2(MSQ,NG,NSQSTA,LBUFF,W,IOTEMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION W(MSQ,NG),GW(20000),IJW(20000),KLW(20000)
      EPS = 1.0D-10
      IF(LBUFF.GT.20000) CALL ABORT0('WRT2E20002')
      NINT=0
      DO J=1, NG
        DO I=1, MSQ
        IF(ABS(W(I,J)).GT.EPS) THEN
        NINT = NINT + 1
        GW(NINT) = W(I,J)
        IJW(NINT)= I
        KLW(NINT)= J+NSQSTA
        END IF
        IF(NINT.GE.LBUFF) THEN
        WRITE(IOTEMP)(GW(K),K=1,LBUFF),(IJW(K),K=1,LBUFF),
     &               (KLW(K),K=1,LBUFF),NINT
        NINT = 0
        END IF
        END DO
      END DO
      IF(NINT.GT.0) THEN
      WRITE(IOTEMP)(GW(K),K=1,LBUFF),(IJW(K),K=1,LBUFF),
     &             (KLW(K),K=1,LBUFF),NINT
      END IF
      RETURN
      END
C
C     TRANSFORMATION OF THE THIRD INDEXES
C     IO,JO,KA,LA - > IO,JO,KO,LA
C
C     STORAGE OF INTEGRAL (IO,JO | KO,LA): W(KOLA,IJO)
C     WHERE IJO = IJOO(IO,JO)
C           KOLA= (KO-1)*NORB + LA
C
      SUBROUTINE TRANSP3(NBASIS,KLMX,NG,C,W,LBUFF,IOTEMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION C(NBASIS,*),W(NG*NBASIS,KLMX)
C     DIMENSION IAA(*),IJW(20000),KLW(20000),GW(20000),IJTAB(2,100000)
      DIMENSION IJW(20000),KLW(20000),GW(20000),IJTAB(2,100000)
      MSQ = NBASIS*(NBASIS+1)/2
C     NSQ = IAA(MORB+1)
C     ARGUMENTS NEED ADDING BACK IF ABOVE IS EVER USED
      REWIND(IOTEMP)
      DO IJ = 1, MSQ
      CALL DECODEIJ(IJ,IA,JA)
      IJTAB(1,IJ) = IA
      IJTAB(2,IJ) = JA
      END DO
      IF(MSQ.GT.100000)  CALL ABORT0('TRANSP3001')
      IF(LBUFF.GT.20000) CALL ABORT0('TRANSP3002')
      DO J=1, KLMX
        DO I=1, NG*NBASIS
        W(I,J) = 0.0D0
        END DO
      END DO
 10   CONTINUE
C     TIME = XCLOCK()
      READ(IOTEMP)(GW(K),K=1,LBUFF),(IJW(K),K=1,LBUFF),
     &            (KLW(K),K=1,LBUFF),NINT
C     TIME1 = XCLOCK()
      DO IJKL=1, NINT
      KLO = KLW(IJKL)
      IJA = IJW(IJKL)
      VAL = GW(IJKL)
      IA  = IJTAB(1,IJA)
      JA  = IJTAB(2,IJA)
C
C     LOOP OVER ALL ORBITALS
C
      IAJO = IA - NBASIS
      JAJO = JA - NBASIS
        DO JO=1, NG
          IAJO = IAJO + NBASIS
          W(IAJO,KLO) = W(IAJO,KLO) + C(JA,JO)*VAL
          IF(IA.NE.JA) THEN
          JAJO = JAJO + NBASIS
          W(JAJO,KLO) = W(JAJO,KLO) + C(IA,JO)*VAL
          END IF
        END DO
C 101 CONTINUE
C 100 CONTINUE
C
      END DO
C     TIME  = XCLOCK()
      IF(NINT.GT.0) GOTO 10
C
C     TEST SECOND INDEX
C
C     CALL TRANDD3(NBASIS,NORB,MORB,NG,KLMX,C,W,W(1,NG*NBASIS+1),MSQ)
      RETURN
      END
C
C     STORAGE OF INTEGRAL (IO,JO | KO,LA): W(KOLA,IJO)
C     W(NG*NBASIS,NORB*(NORB+1)/2)
C
      SUBROUTINE WRT2EP3(NBASIS,KLMX,NG,NORBSTA,LBUFF,W,IOTEMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION W(NG*NBASIS,KLMX),GW(20000),IJW(20000),KLW(20000)
      EPS = 1.0D-10
      IF(LBUFF.GT.20000) CALL ABORT0('WRT2E30002')
      NINT=0
      DO J=1, KLMX
        DO I=1, NG*NBASIS
        IF(ABS(W(I,J)).GT.EPS) THEN
        NINT = NINT + 1
        GW(NINT) = W(I,J)
        KLW(NINT)= J
        IJW(NINT)= I + NORBSTA*NBASIS
        END IF
        IF(NINT.GE.LBUFF) THEN
        WRITE(IOTEMP)(GW(K),K=1,LBUFF),(IJW(K),K=1,LBUFF),
     &               (KLW(K),K=1,LBUFF),NINT
        NINT = 0
        END IF
        END DO
      END DO
      IF(NINT.GT.0) THEN
      WRITE(IOTEMP)(GW(K),K=1,LBUFF),(IJW(K),K=1,LBUFF),
     &             (KLW(K),K=1,LBUFF),NINT
      END IF
      RETURN
      END
C
C     TRANSFORMATION OF THE THIRD INDEXES
C     IO,JO,KO,LA - > IO,JO,KO,LO
C
C     STORAGE OF INTEGRAL (IO,JO | KO,LO): W(KLO,IJO)
C     WHERE IJO = IJOO(IO,JO)
C           KLO = IJ00(KO,LO)
C
      SUBROUTINE TRANSP4(NBASIS,NORB,MORB,C,W,NTINT,LBUFF,IOTEMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION C(NBASIS,*),W(NTINT)
      DIMENSION IB(10000),MA(100000),MB(100000),IJW(20000)
      DIMENSION KLW(20000),GW(20000)
C     MSQ = NBASIS*(NBASIS+1)/2
      DO I=1, 10000
      MA(I) = I*(I-1)/2
      END DO
      DO I=1, NORB
      IB(I) = I*(I-1)/2
      END DO
      DO I=NORB+1,MORB+1
      IB(I) = IB(I-1) + NORB
      END DO
      KLN = IB(NORB+1)
      IJN = IB(MORB+1)
      IF(IJN.GT.100000) CALL ABORT0('TRANS2P401')
      DO I=1, IJN+1
      MB(I) = I*(I-1)/2
      END DO
      REWIND(IOTEMP)
      IF(LBUFF.GT.10000) CALL ABORT0('TRANS2P401')
      DO I=1, NTINT
      W(I) = 0.0D0
      END DO
 10   CONTINUE
      READ(IOTEMP)(GW(K),K=1,LBUFF),(IJW(K),K=1,LBUFF),
     &            (KLW(K),K=1,LBUFF),NINT
      DO I=1, NINT
      IAJO = IJW(I)
      KLO  = KLW(I)
      VAL  = GW(I)
C
C     DECODE IAJO
C
      JO  = (IAJO-1)/NBASIS + 1
      IA  = IAJO - (JO-1)*NBASIS
C
C     DECODE KLO
C
      IF(KLO.LE.KLN) THEN
      CALL DECODEIJ(KLO,KO,LO)
      ELSE
      KO = (KLO-KLN)/NORB + 1
      LO = KLO-KLN - (KO-1)*NORB
      KO = KO + NORB
      END IF
C
C     VERIFY DECODE KLO
C
      IF(KLO.NE.(IB(KO)+LO)) CALL ABORT0('DECODEKLO0')
      IF(JO.GT.NORB.AND.KO.GT.NORB) GOTO 100
C
C     LOOP OVER ALL ORBITALS
C
        DO IO=JO,MORB
          IF(JO.LE.NORB) THEN
          IJO = IB(IO) + JO
          IJKLO = MA(IJO) + KLO
          ELSE
          IJX = (IO-NORB)*(IO-NORB-1)/2 + JO-NORB
          IJO = IJN + IJX
          IJKLO = MB(IJN+1) + (IJX-1)*KLN + KLO
          END IF
          IF(KLO.LE.IJO) W(IJKLO)=W(IJKLO)+C(IA,IO)*VAL
        END DO
  100 CONTINUE
C
      END DO
      IF(NINT.GT.0) GOTO 10
      RETURN
      END
      SUBROUTINE NRDATER(N,DEV,HESS,ER,ERMAX,ERCTL,W,RDAMP,EPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION HESS(*),DEV(*),ER(*),W(*),DV1(5000)
      IF(N.GT.5000) CALL ABORT0('NRDATER01 ')
      BETA=RDAMP
      IF(BETA.LE.0.0D0) BETA=1.0D-1
C
C     COPY HESSIAN and DERIVATIVE TO WORK FIELDS
C
      DEVM=0.0D0
      DO J=1,N
      DV1(J)=-DEV(J)
      IF(DABS(DEV(J)).GT.DEVM) DEVM=DABS(DEV(J))
      END DO
      DO I=1,N
      II=(I-1)*N
      DO J=1,N
      IJ=II+J
      W(IJ)=HESS(IJ00(I,J))
      END DO
      END DO
      NVEC=1
      CALL GAUSSE(N,W,DV1,NFC,NVEC)
      IF(NFC.GT.0) THEN
 100     BETA=BETA*2
         WRITE(IOUTVB,*)'NEGATIVE EIG. OF HESS. NFC=',NFC,N,BETA
         DO I=1,N
         II=(I-1)*N
         DO J=1,N
         IJ=II+J
         W(IJ)=HESS(IJ00(I,J))
         END DO
         END DO
         DO J=1,N
         W((J-1)*N+J)=HESS(IJ00(J,J))+BETA
         END DO
         CALL GAUSSE(N,W,DV1,NFC,NVEC)
         IF(NFC.GT.0) GOTO 100
      END IF
      CALL SOLVEA(N,W,DV1,ER,NVEC)
C
C     ERROR CONTROL
C
      CALL ERCHEK(N,ERMAX,ERCTL,ER)
      EPT=0.0D0
      DO I=1,N
      EPT=EPT+DEV(I)*ER(I)
      END DO
      DO I=1,N
      DO J=1,N
      EPT=EPT+0.5D0*ER(I)*HESS(IJ00(I,J))*ER(J)
      END DO
      END DO
C     WRITE(IOUTVB,*)'EPT =',EPT
      RETURN
      END
      SUBROUTINE NRDATE(N,DEV,HESS,ER,ERMAX,ERCTL,W,RDAMP,
     &                  SEIG,EPT,F1,F2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION HESS(*),DEV(*),ER(*),W(*),DV1(5000)
      IF(N.GT.5000) CALL ABORT0('NRDATE01  ')
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      HESSCONST = 0.0D0
      CALL LOCTOR(IOENGI,"$HESSCONST",10,IOK,0)
      IF(IOK.EQ.1) THEN
        READ(IOENGI,*)HESSCONST
      ENDIF
C
C     CHECK PERFORMANCE
C     AND DYNAMIC ADJUSTMENT
C
      IF(EPT.EQ.0.0D0) THEN
      RAT=0.65D0
      ELSE
      RAT=(F2-F1)/EPT
      END IF
C
C     USE THE CHANGE of MAXDEV to adjust BETA
C
      IF(RAT.GT.0.85D0) RDAMP=RDAMP/2.00D0
      IF(RAT.LT.0.55D0) RDAMP=3.0D0*RDAMP
      F1=F2
      BETA=RDAMP
C
C     COPY HESSIAN and DERIVATIVE TO WORK FIELDS
C
      DEVM=0.0D0
      DO J=1,N
      DV1(J)=-DEV(J)
      IF(DABS(DEV(J)).GT.DEVM) DEVM=DABS(DEV(J))
      END DO
      RDEVM=DEVM/DABS(SEIG)
      IF(SEIG.GT.0.0D0.AND.RAT.GT.0.65D0.AND.RDEVM.LT.1.0D0) BETA=0.0D0
      IF(HESSCONST .GT. 0.0D0) BETA = HESSCONST
      DO I=1,N
      II=(I-1)*N
      DO J=1,N
      IJ=II+J
      W(IJ)=HESS(IJ00(I,J))
      END DO
      END DO
      DO J=1,N
      W((J-1)*N+J)=HESS(IJ00(J,J))+BETA
      END DO
      NVEC=1
      CALL GAUSSE(N,W,DV1,NFC,NVEC)
      CALL SOLVEA(N,W,DV1,ER,NVEC)
C
C     ERROR CONTROL
C
      CALL ERCHEK(N,ERMAX,ERCTL,ER)
      EPT=0.0D0
      DO I=1,N
      EPT=EPT+DEV(I)*ER(I)
      END DO
      DO I=1,N
      DO J=1,N
      EPT=EPT+0.5D0*ER(I)*HESS(IJ00(I,J))*ER(J)
      END DO
      END DO
      RETURN
      END
C
C     Stabilized Newton-Raphson method (v3) based on Goldfeld, Quandt, and
C     Trotter.
C
C     Jiabo Li, Feb., 2000. San Diego
C
      SUBROUTINE NRGQT3(N,DEV,HESS,ER,ERMAX,ERCTL,W,RGQT,BGQT,
     &                  SEIG,EPT,F1,F2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION HESS(*),DEV(*),ER(*),W(*),DV1(5000)
      IF(N.GT.5000) CALL ABORT0('NRGQT01   ')
      WRITE(IOUTVB,*)'NRGQT3 IS CALLED'
C
C     CHECK PERFORMANCE
C     AND DYNAMIC ADJUSTMENT
C
      IF(EPT.EQ.0.0D0) THEN
      RAT=0.65D0
      ELSE
      RAT=(F2-F1)/EPT
      END IF
      IF(RAT.GT.0.90D0) RGQT=RGQT/2.0D0
      IF(RAT.LT.0.60D0.OR.F2-F1.GT.0.0D0) RGQT=RGQT*3.0D0
      F1=F2
C
C     Compute alpha
C
      G=0.0D0
      D=0.0D0
      DO I=1,N
      G=G+DEV(I)*DEV(I)
      D=D+ER(I)*ER(I)
      END DO
      G=DSQRT(G)
      ALPHA=RGQT*G
      IF(SEIG.LT.0.0D0) ALPHA=ALPHA+DABS(SEIG)
      BETA =BGQT*BGQT-1.0D0
C
C     COPY HESSIAN and DERIVATIVE TO WORK FIELDS
C     ADD MODIFICATION TO HESSIAN (+ alpha*Q)
C
      DO J=1,N
      DV1(J)=-DEV(J)
      END DO
      DO I=1,N
      II=(I-1)*N
      DO J=1,N
      IJ=II+J
      IF(EPT.EQ.0.0D0)  THEN
      W(IJ)=HESS(IJ00(I,J))
      ELSE
      W(IJ)=HESS(IJ00(I,J)) + ALPHA*BETA*ER(I)*ER(J)/D
      END IF
      END DO
      W(II+I)=W(II+I) + ALPHA
      END DO
      NVEC=1
      CALL GAUSSE(N,W,DV1,NFC,NVEC)
      IF(NFC.GT.0) THEN
      WRITE(IOUTVB,*)'NEGATIVE EIG. OF HESS. NFC=',NFC
      RGQT=RGQT*10.0D0
C     CALL ABORT0('NRGQT301  ')
      END IF
      CALL SOLVEA(N,W,DV1,ER,NVEC)
C
C     ERROR CONTROL
C
      CALL ERCHEK(N,ERMAX,ERCTL,ER)
      EPT=0.0D0
      DO I=1,N
      EPT=EPT+DEV(I)*ER(I)
      END DO
      DO I=1,N
      DO J=1,N
      EPT=EPT+0.5D0*ER(I)*HESS(IJ00(I,J))*ER(J)
      END DO
      END DO
      RETURN
      END
      SUBROUTINE GAUSSE(N,A,V,NFC,M)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(N,N),V(N,*)
C
C     GAUSSIAN ELIMINATION
C     NFC:   # OF NEGATIVE EIGENVALUES OF MATRIX A
C
      NFC=0
      IF(N.LE.0) RETURN
      DO I=1,N-1
      IF(A(I,I).LE.0.0D0) NFC=NFC+1
C
C     DO ELIMINATION
C
          DO J=I+1,N
          EX=A(J,I)/A(I,I)
          A(J,I)=0.0D0
            DO K=1,M
            V(J,K)=V(J,K)-V(I,K)*EX
            END DO
            DO K=I+1,N
            A(J,K)=A(J,K)-A(I,K)*EX
            END DO
          END DO
      END DO
      IF(A(N,N).LE.0.0D0) NFC=NFC+1
      RETURN
      END
      SUBROUTINE SOLVEA(N,A,V,C,M)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(N,N),C(N,*),V(N,*)
      DO 100 I=1,M
      DO 200 J=N,1,-1
      SUM=V(J,I)
      DO 300 K=J+1,N
 300  SUM=SUM-A(J,K)*C(K,I)
 200  C(J,I)=SUM/A(J,J)
 100  CONTINUE
      RETURN
      END
C
C     SOLVE EQ
C     A*B=U
C
      SUBROUTINE SOLVER(N,A,B,U,W,M)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(N,N),B(N,N),U(N,N),W(N,N)
      DO 200 I=1,N
      DO 100 J=1,N
      W(I,J)=A(I,J)
 100  CONTINUE
      W(I,I)=W(I,I)
 200  CONTINUE
      CALL GAUSSE(N,W,U,NFC,M)
      CALL SOLVEA(N,W,U,B,M)
      RETURN
      END
      SUBROUTINE ERCHEK(N,ERMAX,ERCTL,ER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION ER(N)
      ERMAX=0.0D0
      DO 100 I=1,N
      IF(ERMAX.LT.DABS(ER(I))) ERMAX=DABS(ER(I))
 100  CONTINUE
      IF(ERMAX.GT.ERCTL) THEN
      SCALE=ERCTL/ERMAX
      DO 200 I=1,N
      ER(I)=ER(I)*SCALE
 200  CONTINUE
      ERMAX=ERCTL
      END IF
      RETURN
      END
      SUBROUTINE BASTRN(NBASIS,NSUB,MLORBIT,MNORBIT,BASIS,S,W,MSIZE,
     &   BASLAO,BASNOC,NONADD)
C    &   BASLOC,LOWADD,BASLAO,BASNOC,NONADD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION S(*),BASIS(NBASIS,*),W(*),MLORBIT(*),MNORBIT(*)
C     DIMENSION BASLAO(*),BASLOC(*),LOWADD(*)
      DIMENSION BASLAO(*)
      DIMENSION BASNOC(*),NONADD(*)
C     DIMENSION BASX(100)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      NORBIT=0
      DO 100 I=1,NSUB
      NORBIT=NORBIT+MLORBIT(I)
 100  CONTINUE
C
      NSS=1
      NSA=NSS+NBASIS*NBASIS
      NV =NSA+NBASIS*NBASIS
      NW =NV +NBASIS*NBASIS
      NWK=NW +NBASIS*NBASIS
C     NW1=NSA
      MSIZEA=MSIZE-NWK+1
C
C     S->W(NSS)
C
      DO 200 I=1,NBASIS
      II=NSS-1+(I-1)*NBASIS
      DO 200 J=1,NBASIS
      W(II+J)=S(IJ00(I,J))
 200  CONTINUE
C
C     Lowdin orthogonalization of all occupied orbitals
C
C     CALL LOWD(NBASIS,NORBIT,W(NSS),BASIS,W(NSA),W(NV),W(NW),IERR)
      CALL SETNORB2(NBASIS,NSUB,MLORBIT,MNORBIT,BASIS,W(NSS),W(NV),
     &              W(NW))
C     IF(IERR.EQ.1) CALL ABORT0('BASTRN01  ')
C
C     EXPRESS ORBITALS IN LOWDIN BASIS FUNCTIONS
C
      NORBIT =1
      NORBITX=1
      DO 300 K=1,NSUB
      NB=(NORBITX-1)*NBASIS+NV
      MK=MLORBIT(K)
      MX=MNORBIT(K)
      CALL BASLOW(NBASIS,MK,MX,W(NSS),BASIS(1,NORBIT),W(NB),W(NW),
     &            W(NWK),MSIZEA,BASNOC(NONADD(K)))
C    &            W(NWK),MSIZEA,BASLOC(LOWADD(K)),BASNOC(NONADD(K)))
      NORBIT =NORBIT +MK
      NORBITX=NORBITX+MX
 300  CONTINUE
C
C     STORE LOWDIN BASIS FUNCTIONS IN TRNMAT FOR LATER USE
C     STORE LOWDIN ORBITALS (IN AO BASIS) IN BASLAO FOR LATER USE
C
C     DO 400 I=1,(NORBITX-1)*NBASIS
      DO 400 I=1,NBASIS*NBASIS
      II=1+(I-1)/NBASIS
      J=I-(II-1)*NBASIS
      BASLAO(I)=W(NV-1+I)
 400  CONTINUE
C
C     ASSUME THAT THE VIRTUAL ORBITALS IN BASIS ARE ORTHOGONALIZED !
C     OTHERWISE, DO SOME TREATMENT TO ENFORCE IT.
C
C     DO 410 I=(NORBITX-1)*NBASIS+1,NBASIS*NBASIS
C     II=1+(I-1)/NBASIS
C     J=I-(II-1)*NBASIS
C410  BASLAO(I)=BASIS(J,II)
C
C     TEST ORTHOGONALITY
C
      CALL ORTHTE(NBASIS,NBASIS,BASLAO,W(NSS),OERROR,0)
      IF(OERROR.GT.0.000001D0) THEN
      WRITE(IOUTVB,*)'WARNING: ORTHOGONALITY ERROR B =',OERROR
C     CALL ABORT0('ORTHTEST01')
      END IF
      RETURN
      END
      SUBROUTINE ORTHTE(NBASIS,NTORB,BASIS,S,OERROR,IFLAG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION BASIS(NBASIS,NTORB),S(*)
      OERROR=0.0D0
      DO 100 I=2,NTORB
      DO 100 J=1,I-1
         SUM=0.0D0
         DO 110 K=1,NBASIS
         DO 110 L=1,NBASIS
         KL=(L-1)*NBASIS+K
         IF(IFLAG.EQ.1) KL=IJ00(K,L)
         SUM=SUM+S(KL)*BASIS(K,I)*BASIS(L,J)
 110     CONTINUE
      OERROR=OERROR+DABS(SUM)
 100  CONTINUE
      RETURN
      END
      SUBROUTINE INIBAS(NBASIS,NSUB,MLORBIT,MNORBIT,METHOD,NBALL,
     &                  BASIS,S,V,W,CNORM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION S(*),BASIS(NBASIS,*),V(NBASIS,*),W(*),MLORBIT(*)
      DIMENSION MNORBIT(*),METHOD(*),CNORM(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      NORBIT =0
      NORBITX=0
      DO 100 I=1,NSUB
      NORBIT =NORBIT+ MLORBIT(I)
      NORBITX=NORBITX+MNORBIT(I)
 100  CONTINUE
      NVIR=NBALL-NORBITX
      NOB=NORBITX+1
C
C
      NSS=1
      NSA=NSS+NBASIS*NBASIS
      NV =NSA+NBASIS*NBASIS
      NW =NV +NBASIS*NBASIS
      NWK=NW +NBASIS*NBASIS
      NW1=NSA
C
C     S->W(NSS)
C
      DO 200 I=1,NBASIS
      II=(I-1)*NBASIS
      DO 200 J=1,NBASIS
      W(II+J)=S(IJ00(I,J))
 200  CONTINUE
C
C     Orthogonalize virtual orbitals to all occupied orbitals.
C
C     Special handling: MELE(NSUB)=0 group, already orth to others,
C     skip it. Treat orbitals in MELE(NUSB)=0 group as junk.
C
C
      NORBITXX = NORBITX
      IF(METHOD(NSUB).GT.10) NORBITXX = NORBITX-MLORBIT(NSUB)
      IF(NVIR.GT.0) THEN
        CALL ORTHAB(NBASIS,NORBITXX,NVIR,W(NSS),V,V(1,NOB),W(NW1))
      ENDIF
C
C     Lowdin orthogonalization of all occupied orbitals
C
      CALL LOWD(NBASIS,NORBITXX,W(NSS),V,W(NSA),W(NV),W(NW),IERR)
C     IF(IERR.EQ.1) CALL ABORT0('INIBAS01  ')
      IF(IERR.EQ.1) WRITE(IOUTVB,*)"ERROR in LOWD IN INIBAS01"
C
C     COPY W(NV) -> V
C     ORTHOGONAL
C
      DO I=1, NORBITX
      DO J=1, NBASIS
      IJ = (I-1)*NBASIS + J - 1
      V(J,I) = W(NV + IJ)
      END DO
      END DO
C
C     PROJECTION
C     |Wi><Wi|ORBITLAS>  (Wi: the subspace of a subunit)
C
      NORBIT =1
      NORBITX=1
      DO 300 K=1,NSUB
      NB=(NORBITX-1)*NBASIS+NV
      MK=MLORBIT(K)
      MX=MNORBIT(K)
      IF(METHOD(K).EQ.1) THEN
        CALL CPYVEC(MK*NBASIS,W(NB),BASIS(1,NORBIT))
      ELSE IF(METHOD(K).GT.10) THEN
        CALL CPYVEC(MK*NBASIS,BASIS(1,NORBIT),W(NB))
      ELSE
        CALL PROJEC(NBASIS,MK,MX,W(NSS),BASIS(1,NORBIT),W(NB),W(NW),
     &            W(NWK))
      END IF
      NORBIT =NORBIT+ MLORBIT(K)
      NORBITX=NORBITX+MNORBIT(K)
 300  CONTINUE
C
C     COPY VIRTURAL ORBITALS V -> BASIS
C
      DO I=1, NVIR
        DO J=1, NBASIS
        BASIS(J,NORBIT+I-1) = V(J,NORBITX+I-1)
        END DO
      END DO
C
C     NORMALIZATION
C
      DO 350 K=1,NORBIT-1
      SUM=0.0D0
      DO 360 I=1,NBASIS
      DO 360 J=1,NBASIS
      SUM=SUM+BASIS(I,K)*S(IJ00(I,J))*BASIS(J,K)
  360 CONTINUE
      SUM=DSQRT(SUM)
      CNORM(K)=SUM
      DO 370 I=1,NBASIS
      BASIS(I,K)=BASIS(I,K)/SUM
  370 CONTINUE
  350 CONTINUE
C
C     Lowdin orthogonalization of virtual orbitals.
C     Restore orthogogality keep minimal changes for each orbital
C
C     IF(NVIR.GT.1) THEN
      CALL LOWD(NBASIS,NVIR,W(NSS),BASIS(1,NORBIT),W(NSA),W(NV),W(NW),
     &            IERR)
C     ELSE IF(NVIR.EQ.1) THEN
C       DO I=1, NBASIS
C       W(NV-1+I) = BASIS(I,NORBIT)
C       END DO
C     END IF
      IF(IERR.EQ.1) CALL ABORT0('INIBAS02  ')
      DO 400 I=1,NVIR
      II=(NORBIT+I-1)
      IIX=(NORBITX+I-1)
      INBA=(I-1)*NBASIS
      DO 400 J=1,NBASIS
      BASIS(J,II)= W(NV-1+INBA+J)
      V(J,IIX)   = W(NV-1+INBA+J)
 400  CONTINUE
      RETURN
      END
      SUBROUTINE VBONORM(NBASIS,MLORBIT,BASIS,S,CNORM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION S(*),BASIS(NBASIS,*),CNORM(*)
C
C     NORMALIZATION
C
      DO 350 K=1,MLORBIT
      SUM=0.0D0
      DO 360 I=1,NBASIS
      DO 360 J=1,NBASIS
      SUM=SUM+BASIS(I,K)*S(IJ00(I,J))*BASIS(J,K)
  360 CONTINUE
      SUM=DSQRT(SUM)
      CNORM(K)=SUM
      DO 370 I=1,NBASIS
      BASIS(I,K)=BASIS(I,K)/SUM
  370 CONTINUE
  350 CONTINUE
      RETURN
      END
      SUBROUTINE RNCSTR(NSTR,CSTR,XFACTOR,CNORM,N,NPHI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION CSTR(NSTR),XFACTOR(NSTR),CNORM(*),NPHI(N,*)
      DO I=1,NSTR
      FACTOR=1.0D0
        DO J=1,N
        FACTOR=FACTOR*CNORM(NPHI(J,I))
        END DO
      XFACTOR(I) = FACTOR
      CSTR(I)=CSTR(I)*FACTOR
      END DO
      RETURN
      END
C
C     SORT ERROR VECTORS
C     Jiabo Li
C     First version:   Oct. 1994, Erlangen
C     Second revision: Nov. 1998, Minneapolis
C     Third revision:  Jan. 2000, San Diego
C		       Added ORBLOC
C     Fourth revision: Feb. 2000, San Diego
C		       Simplified and reorganized
C     Fifth revision:  May 29, 2006, San Diego
C                      Replaced by VBDIIS
C     Sixth revision   May 29 2009 San Diego
C                      Expand the array size
C
      SUBROUTINE VBDIISINIT(NDIISM,NDIISTART,SS,MSQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION SS(*)
      COMMON /VBODIIS/VBOS(10000),VBODIIS(100000),ERRDIIS(100000),
     &                NDIISMAX,NDIIS,NDIISS,JUNK
      IF(MSQ.GT.10000) CALL ABORT0('VBDIISINIT')
      DO I=1, MSQ
      VBOS(I) = SS(I)
      END DO
      NDIISMAX = NDIISM
      NDIISS   = NDIISTART
      NDIIS    = 0
      RETURN
      END
C
C     DIIS FOR ORBITAL UPDATE
C
      SUBROUTINE VBDIIS(N,L,M,NBRIL,INDX,B,BASIS0,BASIS,ORBLOC,
     &                  DEV,C,CMAX,CNORM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /VBODIIS/VBOS(10000),VBODIIS(100000),ERRDIIS(100000),
     &                NDIISMAX,NDIIS,NDIISS,JUNK
      DIMENSION EM(1000),CX(100),C0(100)
      DIMENSION B(L,N),INDX(2,NBRIL),ORBLOC(L,L),DEV(*)
      DIMENSION BASIS(M,L),ER(10000),C(NBRIL),CNORM(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      IF(NBRIL.GT.10000) CALL ABORT0('VBDIIS0001')
      NDIIS = NDIIS + 1
      NDIIX = NDIIS
      CX(1) = 1.0D0
      IF(NDIIS.GT.NDIISMAX) NDIIX = NDIISMAX
      IF(NDIIX*L*N.GT.100000) THEN
        WRITE(IOUTVB,*)"OUT OF THE SCRATCH SPACE FOR DIIS"
        CALL ABORT0("VBDIIS0002")
      END IF
      IF(NDIIS.GT.NDIISMAX) THEN
       DO I=2, NDIISMAX
         DO J=1,L*N
         IJ= (I-1)*L*N+J
         VBODIIS(IJ-L*N) = VBODIIS(IJ)
         ERRDIIS(IJ-L*N) = ERRDIIS(IJ)
         END DO
       END DO
      END IF
C
      DO 111 I=1,N
      DO 111 J=1,L
 111  B(J,I)=0.0D0
      DO 221 I=1,NBRIL
      NORB=INDX(1,I)
      NBAS=INDX(2,I)
      B(NBAS,NORB)=DEV(I)
 221  CONTINUE
      CALL MATMUL2(L,L,N,ORBLOC,B,ER)
      IDIIS = (NDIIX-1)*L*N
      DO 302 I=1,N
      DO 302 J=1,L
      IJ=(I-1)*L+J
      ERRDIIS(IDIIS+IJ) = ER(IJ)
 302  CONTINUE
C
      DO 110 I=1,N
      DO 110 J=1,L
 110  B(J,I)=0.0D0
      DO 220 I=1,NBRIL
      IF(DABS(C(I)).GT.CMAX) CMAX=DABS(C(I))
      NORB=INDX(1,I)
      NBAS=INDX(2,I)
      B(NBAS,NORB)=C(I)
 220  CONTINUE
      CALL MATMUL2(L,L,N,ORBLOC,B,ER)
      CMAX=0.0D0
      IDIIS = (NDIIX-1)*L*N
      DO 301 I=1,N
      DO 301 J=1,L
      IJ=(I-1)*L+J
      CABS=DABS(ER(IJ))
      IF(CABS.GT.CMAX) CMAX=CABS
      VBODIIS(IDIIS+IJ) = ORBLOC(J,I)
 301  ORBLOC(J,I) = ORBLOC(J,I) + ER(IJ)
      DO I=1, N
      CNORM(I) = 1.0D0
      END DO
      IF(NDIIS.LT.NDIISS) GOTO 1001
C
C     NOW, COMPUTE DIIS COEFFICIENTS
C
      DO I=1, NDIIX
      II = (I-1)*L*N
      DO J=1, I
      JJ = (J-1)*L*N
      FACTX=1.0D0
      IF(I.EQ.J) FACTX=1.02D0
        SUM = 0.0D0
        DO K=1, L*N
        SUM = SUM + ERRDIIS(II+K)*ERRDIIS(JJ+K)
        END DO
        IJ = (I-1)*(NDIIX+1) + J
        JI = (J-1)*(NDIIX+1) + I
      EM(IJ) = FACTX*SUM
      EM(JI) = FACTX*SUM
      END DO
      END DO
      DO K = 1, NDIIX
      C0(K) = 0.0D0
      IK = NDIIX*(NDIIX+1) + K
      KI = (K-1)*(NDIIX+1) + NDIIX+1
      EM(IK) = -1.0D0
      EM(KI) = -1.0D0
      END DO
      EM((NDIIX+1)*(NDIIX+1)) = 0.0D0
      C0(NDIIX+1) = -1.0D0
      DO I=1, NDIIX+1
      II = (I-1)*(NDIIX+1)
C     WRITE(IOUTVB,*)
C     WRITE(IOUTVB,1000)(EM(II+J),J=1,NDIIX+1)
      END DO
C1000 FORMAT(4F20.15)
      NVEC=1
      CALL GAUSSE(NDIIX+1,EM,C0,NFC,NVEC)
      CALL SOLVEA(NDIIX+1,EM,C0,CX,NVEC)
      DO I=1, N
      DO J=1, L
        SUM = 0.0D0
        DO K=1, NDIIX
        KIJ = (K-1)*L*N+(I-1)*L+J
        SUM = SUM + VBODIIS(KIJ)*CX(K)
        END DO
        ORBLOC(J,I) = SUM
      END DO
      END DO
 1001 CONTINUE
      CALL MATMUL2(M,L,N,BASIS0,ORBLOC,BASIS)
C
C     NORMALIZATION OF EACH ORBITAL
C
      DO I=1, N
        SUM = 0.0D0
        JK = 0
        DO J=1, L
        DO K=1, J
        JK = JK + 1
        FACTOR2 = 2.0D0
          IF(J.EQ.K) FACTOR2 = 1.0D0
        SUM = SUM + FACTOR2*ORBLOC(J,I)*VBOS(JK)*ORBLOC(K,I)
        END DO
        END DO
        CNORM(I) = 1.0D0/SQRT(SUM)
        DO J=1, L
        ORBLOC(J,I) = ORBLOC(J,I)*CNORM(I)
        END DO
        DO J=1, M
        BASIS(J,I)  = BASIS(J,I)*CNORM(I)
        END DO
      END DO
      RETURN
      END
      SUBROUTINE DIAGHER(HESS,NDIM,DEV,SEIG,W,IFIX,DIAGHESS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION HESS(*),W(*),DEV(*),IWRK(5000),E(5000)
      PARAMETER (EPSABS=2.0D-1)
      LOGICAL DIAGHESS
      IF(NDIM.LE.0) RETURN
      IF(NDIM.GT.5000) CALL ABORT0('DIAGHE    ')
      NDIM2=NDIM*NDIM+1
C     NDIM5=NDIM*5
      NVK=1
      NWK=NDIM2+NVK
      G=0.0D0
      DO I=1,NDIM
      II = I*(I-1)/2
      G=G+DEV(I)*DEV(I)
      DO J=1,NDIM
      IJ=(I-1)*NDIM+J
      W(IJ)=HESS(IJ00(I,J))
      IF(DIAGHESS.AND.I.NE.J) W(IJ) = 0.0D0
      END DO
      END DO
      G=DSQRT(G)
      CALL GIVEIS(NDIM,NDIM,NDIM,HESS,W(NWK),IWRK,E,W(NVK),IERR)
      SEIG=E(1)
      DO I=1,NDIM*(NDIM+1)/2
      HESS(I)=0.0D0
      END DO
C
C     SEIG: THE SMALLEST EIGENVLAUE OF HESSIAN MATRIX
C
      SMALLESTE = EPSABS*G
      SABSEIG=DABS(E(1))
      DO I=1,NDIM
      EABS=DABS(E(I))
      IF(EABS.LT.SMALLESTE) EABS=SMALLESTE
      IF(IFIX.EQ.0) EABS=E(I)
      IF(DABS(E(I)).LT.SABSEIG) SABSEIG=DABS(E(I))
      II=(I-1)*NDIM
      DO J=1,NDIM
      EICIJ=EABS*W(II+J)
      JJ=J*(J-1)/2
      DO K=1,J
      HESS(JJ+K)=HESS(JJ+K)+EICIJ*W(II+K)
      END DO
      END DO
      END DO
      RETURN
      END
C---------------------------------------------------------------------------
C     Localization routine of Pipek-Mezey method
C
C     J. Pipek and P. G. Mezey, J. Chem. Phys., 90(1989)4916.
C
C     March, 1995, Erlangen, Germany    (First implementation)
C     July,  1998, Minneapolis, MN, USA (Revised)
C     Feb.,  2000, San Diego, CA, USA   (Revised, LMOs sorted by energies)
C     Nov. 6 2003, San Diego, CA, USA   (Revised, Set new ANGLES to a
C            much smaller value. Also added check for BST so that to avoid
C            bad ratation in ill condition. For instance, localization of MOs
C            of Cl-. No rotation should be performed on a single atom mol.)
C     Nov.26 2003, San Diego, CA, USA   (Revised. Use CSPLIT parameter to
C            detect lone pair)
C     Jul.14 2004, San Diego, CA, USA   (Revised. Fixed a bug for ALPHAM. Mix
C            orbitals with close MO energies first, then extend the energy
C            range to the whole spectrum)
C     Jul.21 2004, San Diego, CA, USA   (Added QuickScane)
C
C     Mar.06 2005, San Diego, CA, USA   (Tuned parameters EPS and ELGAP)
C
C     May 06 2010, San Diego, CA, USA   (Added a new option: LPIMO)
C
C     Created by Jiabo Li
C
C---------------------------------------------------------------------------
      SUBROUTINE LOCAPM(N,NLOCAL,NATOMS,NAO,S,W,V,PGM,EIG,LVIR,LPTALL,
     &                  BFLABE,CSPLIT,LPIMO)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 DUMMY
C     CHARACTER*12 BFLABE(*),BFLAB
      CHARACTER*12 BFLABE(*)
C     PARAMETER (EPS=0.5D-6,ANGLES=0.00001D0,MAXIT=120,MAXBF=5000)
      PARAMETER (EPS=0.5D-6,ANGLES=0.01D0,MAXIT=150,MAXBF=5000)
      DIMENSION V(N,*),S(*),RI(MAXBF),RJ(MAXBF),PGM(NATOMS,NLOCAL)
      DIMENSION NA(MAXBF),SPAS(MAXBF),SPAT(MAXBF),TPAT(MAXBF),NAO(*)
      DIMENSION EIG(*),ELMO(5000),LPFLAG(5000),TX(5000),W(N,*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DUMMY='            '
      CALL GETIOUNIT('IOENGI  ',IOENGI)
C
C     LVIR = 0, occupied orbitals, print all LMOs
C     LVIR = 1, virtual orbitals, print some LMOs
C     LVIR > 1, no printing for any kind of orbital
C
      IF(LVIR.EQ.1) THEN
C
C     FIND HOW MANY VIRTUAL ORBITALS WILL BE PRINTED
C     DEFAULT: ZERO
C
      LPTVIR=0
      CALL LOCTOR(IOENGI,'$LPTVIR',7,IOK,0)
        IF(IOK.EQ.1) READ(IOENGI,*)LPTVIR
        IF(LPTVIR.GT.NLOCAL) LPTVIR=NLOCAL
      END IF
      IF(N.GT.5000) CALL ABORT0('LOCAPM01  ')
      ITER=0
      NT  = 0
      DO 1 I=1,NATOMS
      DO 2 J=1,NAO(I)
      NT=NT+1
      NA(NT)=I
  2   CONTINUE
  1   CONTINUE
      NATOMX = NATOMS
      IF(LPIMO.EQ.1) THEN
        NT = N
        DO J=1, N
          NA(J) = J
        ENDDO
        NATOMX = N
      END IF
      IF(NT.NE.N.OR.NT.GT.MAXBF) THEN
      WRITE(IOUTVB,*)'DATA WRONG !'
      CALL ABORT0('LOCAPM02  ')
      END IF
      DO 3 I=1,N
      DO 4 J=1,NLOCAL
      W(I,J)=0.0D0
  4   CONTINUE
      W(I,I)=1.0D0
      ELMO(I)=EIG(I)
  3   CONTINUE
      DO 420 I=1,NLOCAL
      DO 420 J=I+1,NLOCAL
      CALL QUICKSCANE(N,V(1,I),V(1,J),S,NA,ANGLES,SA,CA)
      IF(LPIMO.EQ.1) THEN
        CA=DCOS(ANGLES)
        SA=DSIN(ANGLES)
      ENDIF
      DO 420 K=1,N
      SK=V(K,I)
      V(K,I)=CA*V(K,I)+SA*V(K,J)
      V(K,J)=CA*V(K,J)-SA*SK
      SK=W(K,I)
      W(K,I)=CA*W(K,I)+SA*W(K,J)
      W(K,J)=CA*W(K,J)-SA*SK
  420 CONTINUE
      ELGAP = 1.0D0
      ELGAPM= DABS(EIG(NLOCAL) - EIG(1)) + 1.0D-5
  10  CONTINUE
      ITER=ITER+1
      NROT=0
      ALPHAM=0.0D0
      DO 100 I=1,NLOCAL
      DO 100 J=I+1,NLOCAL
      DELTAE = DABS(EIG(J)-EIG(I))
C     WRITE(IOUTVB,*)'DELTAE,ELGAP=',DELTAE,ELGAP
      IF(DELTAE.GT.ELGAP) GOTO 101
      DO 110 K=1,N
      RI(K)=0.0D0
      RJ(K)=0.0D0
      DO 110 L=1,N
      IF(K.GT.L) THEN
      KL=K*(K-1)/2+L
      ELSE
      KL=L*(L-1)/2+K
      END IF
      RI(K)=RI(K)+0.5D0*V(L,I)*S(KL)
      RJ(K)=RJ(K)+0.5D0*V(L,J)*S(KL)
  110 CONTINUE
      DO 120 K=1,NATOMX
      SPAS(K)=0.0D0
      TPAT(K)=0.0D0
  120 SPAT(K)=0.0D0
      DO 130 K=1,N
      NATM=NA(K)
      SPAS(NATM)=SPAS(NATM)+V(K,I)*RI(K)*2.0D0
      TPAT(NATM)=TPAT(NATM)+V(K,J)*RJ(K)*2.0D0
      SPAT(NATM)=SPAT(NATM)+V(K,J)*RI(K)+V(K,I)*RJ(K)
  130 CONTINUE
      AST=0.0D0
      BST=0.0D0
      DO 140 K=1,NATOMX
      AST=AST+SPAT(K)**2-(SPAS(K)-TPAT(K))**2/4.0D0
      BST=BST+(SPAS(K)-TPAT(K))*SPAT(K)
  140 CONTINUE
C
C     IF THE DIRIVATIVE IS TOO SMALL, THERE IS NO POINT TO DO ROTATION
C
C     WRITE(IOUTVB,*)'BST,AST=',BST,AST
      IF(DABS(BST).GT.EPS) THEN
      SI4A=BST/DSQRT((AST**2+BST**2))
      ALPHA=DASIN(SI4A)/4.0D0
      IF(DABS(ALPHA).GT.ALPHAM) ALPHAM=DABS(ALPHA)
      IF(DABS(ALPHA).GT.EPS) THEN
      NROT=NROT+1
      CA=DCOS(ALPHA)
      SA=DSIN(ALPHA)
      DO 150 K=1,N
      SK=V(K,I)
      V(K,I)=CA*V(K,I)+SA*V(K,J)
      V(K,J)=CA*V(K,J)-SA*SK
      SK=W(K,I)
      W(K,I)=CA*W(K,I)+SA*W(K,J)
      W(K,J)=CA*W(K,J)-SA*SK
  150 CONTINUE
      END IF
      END IF
  101 CONTINUE
  100 CONTINUE
C     WRITE(IOUTVB,1000)NROT,ALPHAM
      IF(NROT.GT.0.AND.ITER.LE.MAXIT) GOTO 10
      IF(NROT.EQ.0.OR.((ITER/10)*10.EQ.ITER)) THEN
      ELGAP = ELGAP + ELGAP
      END IF
      IF(ITER.LE.MAXIT.AND.(ELGAP.LE.ELGAPM*2.OR.NROT.GT.0)) GOTO 10
C
C     Calculate the LMO energies
C
      DO I=1,NLOCAL
      ELMO(I)=0.0D0
        DO J=1,NLOCAL
        ELMO(I)=ELMO(I)+W(J,I)*W(J,I)*EIG(J)
        END DO
      END DO
      IF(LPIMO.EQ.1) RETURN
C
C     Sort LMOs by LMO energies
C
      CALL RORDER(V,W,ELMO,NLOCAL,N)
C
C     Check if this orbital is a covalent bond or not
C     If ratio of max_next/max < CSPLIT
C     then this LMO is considered as a LP.
C
      DO 520 I=1,NLOCAL
      DO 540 K=1,NATOMS
  540 PGM(K,I)=0.0D0
      DO 530 K=1,N
      KN=NA(K)
      DO 530 L=1,N
      LN=NA(L)
      IF(K.GT.L) THEN
      KL=K*(K-1)/2+L
      ELSE
      KL=L*(L-1)/2+K
      END IF
      PGM(KN,I)=PGM(KN,I)+V(L,I)*S(KL)*V(K,I)
      PGM(LN,I)=PGM(LN,I)+V(L,I)*S(KL)*V(K,I)
  530 CONTINUE
      LPFLAG(I)=0
      FPGM = 0.0D0
      SPGM = 0.0D0
        DO L=1,NATOMS
          IF(DABS(PGM(L,I)).GT.FPGM) THEN
          SPGM = FPGM
          FPGM = DABS(PGM(L,I))
          ELSE IF(DABS(PGM(L,I)).GT.SPGM) THEN
          SPGM = DABS(PGM(L,I))
          END IF
        END DO
      RPGM = SPGM/FPGM
      IF(RPGM.LT.CSPLIT) LPFLAG(I) = 1
  520 CONTINUE
C
C     SORT ORBITALS SO THAT COVALENT BONDING ORBITALS COME LAST
C
      DO I=1,NLOCAL
      TX(I)=1.0D-10*I-LPFLAG(I)
      END DO
      CALL RORDER(ELMO,W,TX,NLOCAL,1)
      DO I=1,NLOCAL
      TX(I)=1.0D-10*I-LPFLAG(I)
      END DO
      CALL RORDER(PGM,W,TX,NLOCAL,NATOMS)
      DO I=1,NLOCAL
      TX(I)=1.0D-10*I-LPFLAG(I)
      END DO
      CALL RORDER(V,W,TX,NLOCAL,N)
      DO I=1, NLOCAL
      EIG(I) = ELMO(I)
      END DO
C
C     PRINT LMOs AND E-LMOs
C
      IF(LPTALL.EQ.1) THEN
        IF(LVIR.EQ.0) CALL MPRINT(V,ELMO,N,NLOCAL,1,BFLABE,DUMMY)
        IF(LVIR.EQ.1) CALL MPRINT(V,ELMO,N,LPTVIR,1,BFLABE,DUMMY)
      END IF
C
C     PRINT MULLIKEN POPULATION ANALYSIS
C
C     IF(LVIR.EQ.0) CALL MPRINT(PGM,ELMO,NATOMS,NLOCAL,2,BFLABE,DUMMY)
C     IF(LVIR.EQ.1) CALL MPRINT(PGM,ELMO,NATOMS,LPTVIR,2,BFLABE,DUMMY)
C 900 FORMAT(/1X,'Iteration exceeds maxit')
C 910 FORMAT(/1X,'OCCUPIED ORBITALS')
C 920 FORMAT(/1X,'VIRTUAL ORBITALS')
C1000 FORMAT(2X,'NUMBER OF ROTATIONS OF PAIRS',I5/
C    &          'MAXIMAL ROTATION ANGLE      ',F15.10)
      RETURN
      END
C     SUBROUTINE LOCANVBO(MORB,BASIS,W,MITER)
      SUBROUTINE LOCANVBO(MORB,BASIS,W)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C     PARAMETER (MAXIT=120,MAXBF=5000)
      PARAMETER (MAXBF=5000)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
C     COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
C    &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
C    &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
C    &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
      DIMENSION W(*),BASIS(*),NAT(MAXBF),MASKLOCA(40000)
C     DIMENSION CHAMAX(4,1000),MAXCHA(4,1000),NWA(1000),PGMT(1000)
C
C     QUICK EXIT IF CASVB LOCALIZATION IS DISABLED
C
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$NOLOCVBO',9,IOK,0)
      IF(IOK.EQ.1) THEN
        WRITE(IOUTVB,*)'VBO LOCALIZATION FOR IS DISABLED FOR CASVB'
        RETURN
      END IF
      IF(MORB.GT.200) CALL ABORT0('LOCANVBO01')
C     IF(MITER.NE.1.AND.LPTALL.EQ.1) WRITE(IOUTVB,1000)
C     NEED TO PUT MITER BACK AS ARGUMENT IF THIS IS USED
C     LPRT = 1
      NNS  = 1
      NPGM = NNS + NBASIS*(NBASIS+1)/2
      NWK  = NPGM + NATOM*MORB
      NT   = 0
      DO 1 I=1,NATOM
      DO 2 J=1,NATBAS(I)
      NT=NT+1
      NAT(NT)=I
  2   CONTINUE
  1   CONTINUE
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL READ1E(IAO1E,W(NNS),W(NWK),NBASIS)
      CALL MULLIKEN(NBASIS,MORB,BASIS,W(NNS),NAT,NATOM,W(NPGM))
      CALL SETMASK(MORB,NATOM,W(NPGM),MASKLOCA)
      CALL LOCALI(NBASIS,MORB,NATOM,NATBAS,W(NNS),W(NWK),BASIS,
     $           W(NPGM),MASKLOCA)
      RETURN
C1000 FORMAT(/' ORBITAL LOCALIZATION PERFORMED FOR CASVB CALCULATION',
C    &     /,' THE STRUCTURE WEIGHTS MAY BE SLIGHTLY DIFFERENT FROM',
C    &     /,' THE RESULTS OF PREVIOUS ITERATION ')
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     FUNCTION:
C                Nonthogonal localization method.
C                It refines the localized orbitals without orthognality
C                constrains
C
C     HISTORY:
C
C                First created in July, 2004
C
C     AUTHOR:
C
C                Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE LOCALI(N,NLOCAL,NATOMS,NAO,S,W,V,PGM,
     &                  MASKLOCA)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C     CHARACTER*12 BFLABE(*),BFLAB
C     PARAMETER (EPS=1.0D-06,DELTA=1.0D-7,TSTEP=1.0D-1)
C     PARAMETER (MAXIT=120,MAXBF=5000)
      PARAMETER (MAXBF=5000)
      DIMENSION V(N,*),W(N,*),S(*),PGM(NATOMS,NLOCAL)
C     DIMENSION NA(MAXBF),NAO(*),VT(MAXBF),MASKLOCA(NLOCAL,NLOCAL)
      DIMENSION NA(MAXBF),NAO(*),MASKLOCA(NLOCAL,NLOCAL)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     WRITE(IOUTVB,*)'EPS, DELTA =',EPS,DELTA
      IF(N.GT.MAXBF) CALL ABORT0('LOCALI01  ')
C     ITER=0
      NT  = 0
      DO 1 I=1,NATOMS
      DO 2 J=1,NAO(I)
      NT=NT+1
      NA(NT)=I
  2   CONTINUE
  1   CONTINUE
      IF(NT.NE.N.OR.NT.GT.MAXBF) THEN
      WRITE(IOUTVB,*)'DATA WRONG !'
      CALL ABORT0('LOCALI02  ')
      END IF
C
C     MAKE A COPY OF ORIGINAL ORBITALS
C
      DO I=1, NLOCAL
C     WRITE(IOUTVB,*)'LOCAL I=',I
      DO J=1, N
      W(J,I)=V(J,I)
C     WRITE(IOUTVB,'(I3,F10.6)')I,V(J,I)
      END DO
      END DO
C
C     LOCALIZATION FOR EACH ORBITAL
C
      NSEARCH= 4
      NSCANE = 20
      CRANGE = 0.5D0
      DO L=1, NSEARCH
      DO 3 I=1, NLOCAL
        DO 4 J=1, NLOCAL
        IF(MASKLOCA(I,J).EQ.0) GOTO 4
        CALL BINSEARCH(N,W(1,I),V(1,J),S,NA,CRANGE,NSCANE)
  4     CONTINUE
  3   CONTINUE
      CRANGE = CRANGE/10.0D0
C
C     COPY BACK TO V
C
      DO I=1, NLOCAL
         DO J=1, N
         V(J,I) = W(J,I)
         END DO
      END DO
      END DO
C
C     COPY BACK TO V
C
      DO I=1, NLOCAL
C     WRITE(IOUTVB,*)'FINAL I=',I
         DO J=1, N
         V(J,I) = W(J,I)
C     WRITE(IOUTVB,'(I3,F10.6)')I,V(J,I)
         END DO
      END DO
      DO 520 I=1,NLOCAL
      DO 540 K=1,NATOMS
  540 PGM(K,I)=0.0D0
      DO 530 K=1,N
      KN=NA(K)
      DO 530 L=1,N
      LN=NA(L)
      IF(K.GT.L) THEN
      KL=K*(K-1)/2+L
      ELSE
      KL=L*(L-1)/2+K
      END IF
      PGM(KN,I)=PGM(KN,I)+V(L,I)*S(KL)*V(K,I)
      PGM(LN,I)=PGM(LN,I)+V(L,I)*S(KL)*V(K,I)
  530 CONTINUE
  520 CONTINUE
      RETURN
      END
      SUBROUTINE SETMASK(MORB,NATOMS,PGM,MASKLOCA)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION PGM(NATOMS,MORB),MOATOM(1000)
      DIMENSION MASKLOCA(MORB,MORB),PGMT(1000),NWA(1000)
      DO I=1,MORB
        M4 = 4
        IF (M4.GT.NATOMS) M4 =NATOMS
        DO J=1, NATOMS
        PGMT(J) = PGM(J,I)
        END DO
        CALL SHELL(PGMT,NWA,NATOMS)
        DO J=1,M4
C       CHAMAX(J,I) = PGMT(NATOMS-J+1)
C       MAXCHA(J,I) = NWA(NATOMS-J+1)
        END DO
        MOATOM(I) = NWA(NATOMS)
      END DO
      DO I=1,MORB
      DO J=1,MORB
      MASKLOCA(I,J) = 1
      IF(MOATOM(I).EQ.MOATOM(J)) MASKLOCA(I,J) = 0
      IF(I.EQ.J) MASKLOCA(I,J) = 0
      END DO
      END DO
      RETURN
      END
      SUBROUTINE MULLIKEN(N,NORB,V,S,NA,NATOMS,PGM)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION V(N,NORB),S(*),NA(*),PGM(NATOMS,NORB)
      DO 520 I=1,NORB
      DO 540 K=1,NATOMS
  540 PGM(K,I)=0.0D0
      DO 530 K=1,N
      KN=NA(K)
      DO 530 L=1,K
      FACTOR=1.0D0
      IF(K.EQ.L) FACTOR=0.5D0
      LN=NA(L)
      IF(K.GT.L) THEN
      KL=K*(K-1)/2+L
      ELSE
      KL=L*(L-1)/2+K
      END IF
      PGM(KN,I)=PGM(KN,I)+FACTOR*V(L,I)*S(KL)*V(K,I)
      PGM(LN,I)=PGM(LN,I)+FACTOR*V(L,I)*S(KL)*V(K,I)
  530 CONTINUE
  520 CONTINUE
      RETURN
      END
      SUBROUTINE BINSEARCH(N,W,V,S,NA,CRANGE,NSCANE)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION W(*),V(*),S(*),NA(*),VT(5000)
      C1=-CRANGE
      C2= CRANGE
      C2MAX = 0.0D0
C     NIMAX = 1
      CCMX  = 0.0D0
      DO I=1, NSCANE+1
      CX = C1+(I-1)*(C2-C1)/NSCANE
        DO K=1, N
        VT(K) = W(K) + CX*V(K)
        END DO
      CALL MC2(N,VT,S,NA,CMX,3)
      IF(CMX.GT.C2MAX) THEN
        C2MAX = CMX
C       NIMAX = I
        CCMX  = CX
      END IF
      END DO
        DO K=1, N
        W(K) = W(K) + CCMX*V(K)
        END DO
      CALL MC2(N,W,S,NA,CMX,3)
      RETURN
      END
      SUBROUTINE QUICKSCANE(N,V1,V2,S,NA,SANGLE,SINA,COSA)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION V1(*),V2(*),S(*),NA(*),VT1(5000),VT2(5000)
      C1=-SANGLE
      C2= SANGLE
      C2MAX = 0.0D0
C     NIMAX = 1
      CCMX  = 0.0D0
      NSCANE= 2
      NMID  = NSCANE/2+1
      C2Z   = 0.0D0
      DO I=1, NSCANE+1
      CX = C1+(I-1)*(C2-C1)/NSCANE
      SA = DSIN(CX)
      CA = DCOS(CX)
        DO K=1, N
        VT1(K) = CA*V1(K) + SA*V2(K)
        VT2(K) = CA*V2(K) - SA*V1(K)
        END DO
      CALL MC2(N,VT1,S,NA,CMA,1)
      CALL MC2(N,VT2,S,NA,CMB,1)
      CMX = CMA+CMB
      IF(I.EQ.NMID) C2Z = CMX
      IF(CMX.GT.C2MAX) THEN
        C2MAX = CMX
C       NIMAX = I
        CCMX  = CX
      END IF
      END DO
      IF(DABS((C2Z-C2MAX)/SANGLE).LT.0.0001D0) CCMX = 0.001D0*SANGLE
      SINA = DSIN(CCMX)
      COSA = DCOS(CCMX)
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     THREE FUNCTIONS FOR LOCALIZAITON
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE MC2(N,V,S,NA,C2,IOP)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION V(*),S(*),NA(*),CHARGE(5000),CSITE(5000),CSQ(5000)
      NATOMS = NA(N)
      DO I=1, NATOMS
      CHARGE(I) = 0.0D0
      CSQ(I)    = 0.0D0
      CSITE(I)  = 0.0D0
      END DO
C
C     NORMALIZATION OF VECTOR
C
      CALL NORMORB(N,1,V,S,IERR)
      IJ = 0
      DO I=1, N
      NAI = NA(I)
      CSQ(NAI) = CSQ(NAI) + V(I)*V(I)
      DO J=1, I
      FACTOR = 1.0D0
      IF(I.EQ.J) FACTOR = 0.5D0
      IJ = IJ+1
      NAJ = NA(J)
      CHARGE(NAI) = CHARGE(NAI) + FACTOR*V(I)*V(J)*S(IJ)
      CHARGE(NAJ) = CHARGE(NAJ) + FACTOR*V(I)*V(J)*S(IJ)
      IF(NAI.EQ.NAJ) CSITE(NAI)=CSITE(NAI)+2.0D0*FACTOR*V(I)*V(J)*S(IJ)
      END DO
      END DO
C
C     COMPUTE C2 and ERROR CHECK
C
      C2 = 0.0D0
      C1 = 0.0D0
      DO I=1, NATOMS
      IF(IOP.EQ.1) THEN
        C1 = C1 + CHARGE(I)
      ELSE IF(IOP.EQ.2) THEN
        C1 = C1 + CSQ(I)
      ELSE IF(IOP.EQ.3) THEN
        C1 = C1 + CSITE(I)
      ELSE
        CALL ABORT0('MC20000001')
      END IF
      END DO
      DO I=1, NATOMS
      IF(IOP.EQ.1) THEN
        C2 = C2 + CHARGE(I)*CHARGE(I)
      ELSE IF(IOP.EQ.2) THEN
        C2 = C2 + CSQ(I)*CSQ(I)
      ELSE IF(IOP.EQ.3) THEN
        C2 = C2 + CSITE(I)*CSITE(I)
      ELSE
        CALL ABORT0('MC20000002')
      END IF
      END DO
      C2 = C2/(C1*C1)
      RETURN
      END
      SUBROUTINE CHALMO(M,NCORE,NATOM,NATBAS,BFLABE,WBASIS,S,PGM,W,E,
     &                  CHAMAX,MAXCHA,CSPLIT,LPTALL)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      CHARACTER*12 BFLABE(*)
      DIMENSION NATBAS(*),WBASIS(M,*),W(*),S(*),PGM(NATOM,*),E(*)
      DIMENSION CHAMAX(4,*),MAXCHA(4,*),NWA(1000),PGMT(1000)
      DIMENSION NDGSIZE(1000)
CGMS  PARAMETER (MXATM=2000)
CGMS  COMMON/INFOA/ NAT1, ICH1, MUL1, NUM1, NQMT, NE1, NA1, NB1,
CGMS 1    ZAN1(MXATM), C1(3,MXATM), IAN(MXATM)
C
C     THIS NVIR IS DIFFERNT FROM NVIR IN VB CALCULATION
C
      NVIR=M-NCORE
CGMS  NVIR = NQMT-NCORE
C     NOBVIR=NCORE*M+1
C     NPMVIR=NCORE*NATOM+1
      CALL LOCAPM(M,NCORE,NATOM,NATBAS,S,W,WBASIS,PGM,E,0,LPTALL,
     &            BFLABE,CSPLIT,0)
      IF(NVIR.GT.0) THEN
      CALL LOCAPM(M,NVIR, NATOM,NATBAS,S,W,WBASIS(1,NCORE+1)
     &,PGM(1,NCORE+1),E(NCORE+1),1,LPTALL,BFLABE,CSPLIT,0)
      END IF
      DO I=1,M
        M4 = 4
        IF (M4.GT.NATOM) M4 =NATOM
        DO J=1, NATOM
        PGMT(J) = PGM(J,I)
        END DO
        CALL SHELL(PGMT,NWA,NATOM)
        DO J=1,M4
        CHAMAX(J,I) = PGMT(NATOM-J+1)
        MAXCHA(J,I) = NWA(NATOM-J+1)
        END DO
      END DO
C
C     POSSIBLE LPIMO OPTION
C     DO THIS ONLY IF LPIMO FLAG EXIST
C     ONLY APPLY FOR LINEAR MOLECULES
C
      LPIMO = 0
C
C     TODO: CHECK $LPIMO
C
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$LPIMO',6,IOK,0)
      IF(IOK.EQ.1) LPIMO=1
      NDG = 0
C     NDGS = 0
      NDGSIZE(1) = 1
      DO I=1, NCORE-1
        IF(ABS(E(I+1)-E(I)).GT.1.0D-3) THEN
           NDG = NDG+1
           NDGSIZE(NDG+1) = I+1
        END IF
      ENDDO
      NDG = NDG+1
      NDGSIZE(NDG+1) = NCORE+1
      DO I=1, NDG+1
      ENDDO
      DO I=1, NDG
        NGG = NDGSIZE(I)
        NGP = NDGSIZE(I+1) - NDGSIZE(I)
        IF(NGP .GT. 1. AND. LPIMO.EQ.1) THEN
          CALL LOCAPM(M,NGP, NATOM,NATBAS,S,W,WBASIS(1,NGG)
     &               ,PGM(1,NGG),E(NGG),1,LPTALL,BFLABE,CSPLIT,1)
        ENDIF
      ENDDO
C
C     PERFORM POSSIBLE TRANSFORMATION
C
      NBASIS = M
      NWK0 = 1
      NWK1 = NWK0 + NBASIS*NBASIS
      CALL LMOTRN(NBASIS,WBASIS,W(NWK0),NATOM,PGM,E,W(NWK1))
      RETURN
      END
C
C     MATRIX PRINTER
C
      SUBROUTINE MPRINT(A,E,N,M,IFLAG,BFLABE,BONDLAB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE(*)
      CHARACTER*12 BFLABF
      CHARACTER*20 BASNAME
      CHARACTER*8 BONDLAB(*)
      CHARACTER*2 ATMSYM
      DIMENSION A(N,M),E(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABF(1000),BASNAME
      COMMON /ATOMSY/ ATMSYM(92)
C
C     IFLAG = PRINT FLAG
C             1: PRINT LMO and E-LMO
C             2: PRINT LMO-Mulliken population
C             3: PRINT Initial orbitals
C             4: PRINT CANON MO
C             5: PRINT CANON LMO
C
      IF(M.LE.0) RETURN
      NPRT=(M+5)/6
      IF(IFLAG.EQ.1) WRITE(IOUTVB,1700)
      IF(IFLAG.EQ.2) WRITE(IOUTVB,1800)
      IF(IFLAG.EQ.3) WRITE(IOUTVB,1850)
      IF(IFLAG.EQ.4) WRITE(IOUTVB,1750)
      IF(IFLAG.EQ.5) WRITE(IOUTVB,1755)
      NFIST=1
      DO I=1,NPRT
      NLAST=NFIST+5
      IF(NLAST.GT.M) NLAST=M
      IF(IFLAG.EQ.1) WRITE(IOUTVB,1950)(K,K=NFIST,NLAST)
      IF(IFLAG.EQ.2) WRITE(IOUTVB,1950)(K,K=NFIST,NLAST)
      IF(IFLAG.EQ.3) WRITE(IOUTVB,1956)(K,K=NFIST,NLAST)
      IF(IFLAG.EQ.4) WRITE(IOUTVB,1955)(K,K=NFIST,NLAST)
      IF(IFLAG.EQ.5) WRITE(IOUTVB,1950)(K,K=NFIST,NLAST)
      IF(IFLAG.EQ.1) WRITE(IOUTVB,1900)(E(K),K=NFIST,NLAST)
      IF(IFLAG.EQ.2) WRITE(IOUTVB,1900)(E(K),K=NFIST,NLAST)
      IF(IFLAG.EQ.4) WRITE(IOUTVB,1900)(E(K),K=NFIST,NLAST)
      IF(IFLAG.EQ.5) WRITE(IOUTVB,1900)(E(K),K=NFIST,NLAST)
      IF(IFLAG.EQ.5) WRITE(IOUTVB,1965)(BONDLAB(K),K=NFIST,NLAST)
      IF(IFLAG.EQ.2) WRITE(IOUTVB,1965)(BONDLAB(K),K=NFIST,NLAST)
      IF(IFLAG.EQ.3) WRITE(IOUTVB,1965)(BONDLAB(K),K=NFIST,NLAST)
      WRITE(IOUTVB,1970)
      IF(IFLAG.EQ.2) THEN
        DO J=1,N
        WRITE(IOUTVB,2000)J,ATMSYM(NATNUM(J)),(A(J,K),K=NFIST,NLAST)
        END DO
      ELSE
        DO J=1,N
        WRITE(IOUTVB,2100)J,BFLABE(J),(A(J,K),K=NFIST,NLAST)
        END DO
      END IF
      WRITE(IOUTVB,*)
      NFIST=NLAST+1
      END DO
 1700 FORMAT(/' Localized molecular orbitals by PM method'/1X,79(1H=))
 1750 FORMAT(/' Molecular orbitals by HF method'/1X,79(1H=))
 1755 FORMAT(/' Localized molecular orbitals and the bond labels'
     &          /1X,79(1H=))
 1800 FORMAT(/' Mulliken population of localized molecular orbitals'/
     & 1X,79(1H=))
 1850 FORMAT(/' Initial guess of orbitals'/1X,79(1H=))
 1900 FORMAT(1X,'E(a.u.)          ',6F10.3)
 1950 FORMAT(1X,'LMO#             ',6I10)
 1955 FORMAT(1X,'MO#              ',6I10)
 1956 FORMAT(1X,'ORBITAL#         ',6I10)
C1960 FORMAT(1X,'                 ',6I10)
 1965 FORMAT(1X,'Bond Label       ',6A10)
 1970 FORMAT(1X,79(1H-)/)
 2000 FORMAT(1X,I3,8X,A2,4X,6F10.5)
 2100 FORMAT(1X,I3,A12,2X,6F10.5)
      RETURN
      END
C
C     SYMMETRIC MATRIX PRINTER
C
      SUBROUTINE MPRINT2(N,A,IFLAG,MGRP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(*),D(1000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      IF(N.LE.0) RETURN
      IF(IFLAG.EQ.1) WRITE(IOUTVB,1000) MGRP
      IF(N.GT.1000) THEN
        WRITE(IOUTVB,*)
     &   "SORRY, NO MATRIX WITH DIMENSION MORE THAN 1000 WILL"
        WRITE(IOUTVB,*)"BE PRINTED."
        RETURN
      END IF
      DO I=1, N
      IF(IFLAG.EQ.1) D(I) = 1.0D0/DSQRT(A(IJ00(I,I)))
      END DO
      NPRT=(N+11)/12
      NFIST=1
      DO I=1,NPRT
      NLAST=NFIST+11
      IF(NLAST.GT.N) NLAST=N
      WRITE(IOUTVB,1200)(K,K=NFIST,NLAST)
      WRITE(IOUTVB,1400)("=======",K=NFIST,NLAST)
        DO J=NFIST, N
        NLL = NLAST
        IF(NLL.GT.J) NLL = J
        WRITE(IOUTVB,1300)J,(A(IJ00(J,K))*D(J)*D(K),K=NFIST,NLL)
        END DO
      NFIST=NLAST+1
      END DO
 1000 FORMAT(//" OVERLAP MATRIX OF VB ORBITALS FOR GROUP ",I3)
 1200 FORMAT(/2X,12I6)
 1300 FORMAT(1X,I3,12F6.3)
C1301 FORMAT(1X,A7,F14.6)
 1400 FORMAT(1X,3(1H=),12(A6))
      RETURN
      END
C
C     PRINT H,S WITH NORMALIZATION
C
      SUBROUTINE MPRINT3(N,S,H,MGRP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION S(*),H(*),D(1000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      IF(N.LE.0) RETURN
      WRITE(IOUTVB,1100) MGRP
      IF(N.GT.1000) THEN
        WRITE(IOUTVB,*)
     &  "SORRY, NO MATRIX WITH DIMENSION MORE THAN 1000 WILL"
        WRITE(IOUTVB,*)"BE PRINTED."
        RETURN
      END IF
      DO I=1, N
      D(I) = 1.0D0/DSQRT(S(IJ00(I,I)))
      END DO
      NPRT=(N+5)/6
C
C     PRINT S MATRIX
C
      NFIST=1
      DO I=1,NPRT
      NLAST=NFIST+5
      IF(NLAST.GT.N) NLAST=N
      WRITE(IOUTVB,1200)(K,K=NFIST,NLAST)
      WRITE(IOUTVB,1400)("============",K=NFIST,NLAST)
        DO J=NFIST, N
        NLL = NLAST
        IF(NLL.GT.J) NLL = J
          WRITE(IOUTVB,1300)J,(S(IJ00(J,K))*D(J)*D(K),K=NFIST,NLL)
        END DO
      NFIST=NLAST+1
      END DO
C
C     PRINT H MATRIX
C
      WRITE(IOUTVB,1110) MGRP
      NFIST=1
      DO I=1,NPRT
      NLAST=NFIST+5
      IF(NLAST.GT.N) NLAST=N
      WRITE(IOUTVB,1200)(K,K=NFIST,NLAST)
      WRITE(IOUTVB,1400)("============",K=NFIST,NLAST)
        DO J=NFIST, N
        NLL = NLAST
        IF(NLL.GT.J) NLL = J
          WRITE(IOUTVB,1300)J,(H(IJ00(J,K))*D(J)*D(K),K=NFIST,NLL)
        END DO
      NFIST=NLAST+1
      END DO
      WRITE(IOUTVB,1500)
      WRITE(IOUTVB,1501)
      WRITE(IOUTVB,'(8F10.6)')(1.0D0/D(I),I=1,N)
 1100 FORMAT(//" OVERLAP MATRIX OF VB STRUCTURES FOR GROUP ",I3)
 1110 FORMAT(//" HAMILTONIAN MATRIX OF VB STRUCTURES FOR GROUP ",I3)
 1200 FORMAT(/2X,6I12)
 1300 FORMAT(1X,I3,6F12.6)
 1400 FORMAT(1X,3(1H=),6(A12))
 1500 FORMAT(//" Normalization constants of VB structures")
 1501 FORMAT("      I.E. N in C(norm) = N C(unnorm)",/)
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     ROUTINE FOR CANONICALIZING LMOs, SET UP LMO INDEXES
C
C     VARIABLES:
C
C     WLMO: LMOs
C     CHAMAX: CHARGES OF LMO ON ATOMS (SORTED FROM LARGEST TO SMALLEST)
C     MAXCHA: ATOM INDEX OF CHAMAX
C     LMOLAB: LMO LABELS. LMOLAB(1,I) = LMO LOCATION IJ(NA1, NA2) OF THE LMO I.
C
C             FOR MC LMO, LMO LOCATION INDEX = 0
C             LMOLAB(2,I) = BOND INDEX. I.E. HOW MANY LMOs AT THIS LOCATION
C
C             NOTE: THE BOND INDEX IS LABELED IN SUCH A WAY THAT THE HIGH
C             ENERGY ONES (I.E. VALENCE BONDS) ARE LABELED FIRST. TO BE
C             CONSISTENT, ALL LMOs HAVE BOND INDEX, EVEN FOR LP AND INNER ORB.
C     MCLMO:  MULTI-CENTER LMOs. THE DATA STRUCTURE IS GIVEN AS BELOW:
C
C             MCLMO(1,I): THE I-TH MCLMO INDEX (LMO INDEX)
C             MCLMO(2-5,I): THE MC ATOM INDEXES OF THE LMO
C
C     NOTE:   NO MORE THAN 1000 ATOMS, NO MORE THAN 1000 BASIS FUNCTIONS
C     REVISION HISTORY
C     FIRST CREATION: NOV. 1, 2003
C
C     AUTHOR: JIABO LI
C     SAN DIEGO
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE CANLMO(WLMO,S,NCORE,NBASIS,CHAMAX,MAXCHA,W,
     &                  NAO,CSPLIT,BFLABE,NAOST,IOLVBO,IOENGI,LPRT)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      CHARACTER*12 BFLABE(*)
      CHARACTER*8 BONDLAB
      DIMENSION WLMO(*),CHAMAX(4,*),MAXCHA(4,*),S(*),W(*),NAOST(*)
      DIMENSION NAO(*),NA(1000),NATOMBOND(1000),NATOMLP(1000)
      DIMENSION NAOFFSET(1000)
      COMMON /LMODAT/VMO(500000),VLMO(500000),LMOLAB(2,1000),
     &LMOATM(5,1000),PGM(100000),ENGLMO(1000),BONDLAB(1000),MCLMO(5,80),
     &LHFLAG
      COMMON /MTOPOL/XYZMOL(3,1000),NATOMS,NATNNU(1001),
     &               NBONDALIST(10,1000),NBONDTYPE(10,1000)
      IF(NBASIS.GT.1000.OR.NATOMS.GT.1000) CALL ABORT0('CANLMO01  ')
C
C     COPY ALL LMOs to STORAGE
C
      DO I=1, NBASIS*NCORE
      VLMO(I) = WLMO(I)
      END DO
C
C     ZERO LABELS
C
      DO I=1,1000
      LMOLAB(1,I) = 0
      LMOLAB(2,I) = 0
      LMOATM(1,I) = 0
      LMOATM(2,I) = 0
      LMOATM(3,I) = 0
      LMOATM(4,I) = 0
      LMOATM(5,I) = 0
      END DO
      LHFLAG = 0
      DO I=1, 10
        DO J=1, 5
        MCLMO(J,I) = 0
        END DO
      END DO
      MCLMOCOUNT = 0
      NAT2=NATOMS*(NATOMS+1)/2
C     MCINDEX = NAT2 + 1
      MCINDEX = 0
C     NAT22=NAT2*2
C     IF(3*NATOMS*(NATOMS+1)/2.GT.15000) CALL ABORT0('INPUTVB02 ')
      DO I=NCORE,1,-1
      RAT1=DABS(CHAMAX(2,I)/CHAMAX(1,I))
      RAT2=0.0D0
      IF(NATOMS.GE.3) RAT2=DABS(CHAMAX(3,I)/CHAMAX(1,I))
C     WRITE(IOUTVB,*)'RAT1, RAT2 =',RAT1, RAT2
      IF(RAT1.LT.CSPLIT) THEN
C
C       LONE_PAIR
C
        IJ=IJ00(MAXCHA(1,I),MAXCHA(1,I))
        LMOLAB(1,I) = IJ
        LMOATM(1,I) = MAXCHA(1,I)
        LMOATM(5,I) = 1
      ELSE IF(RAT2.LT.CSPLIT) THEN
C
C       NORMAL BOND
C
        IJ=IJ00(MAXCHA(1,I),MAXCHA(2,I))
        LMOLAB(1,I) = IJ
        LMOATM(1,I) = MAXCHA(1,I)
        LMOATM(2,I) = MAXCHA(2,I)
        LMOATM(5,I) = 2
      ELSE
C
C       MULTI-CENTER BOND
C
        MCLMOCOUNT  = MCLMOCOUNT + 1
        LMOLAB(1,I) = MCINDEX
        LMOLAB(2,I) = MCLMOCOUNT
        MCLMO(1,MCLMOCOUNT) = I
        MCLMO(2,MCLMOCOUNT) = MAXCHA(1,I)
        MCLMO(3,MCLMOCOUNT) = MAXCHA(2,I)
        MCLMO(4,MCLMOCOUNT) = MAXCHA(3,I)
        LMOATM(1,I) = MAXCHA(1,I)
        LMOATM(2,I) = MAXCHA(2,I)
        LMOATM(3,I) = MAXCHA(3,I)
        LMOATM(5,I) = 3
        IF(NATOMS.GT.3) MCLMO(5,MCLMOCOUNT) = MAXCHA(4,I)
        IF(NATOMS.GT.3) LMOATM(4,I) = MAXCHA(4,I)
        IF(NATOMS.GT.3) LMOATM(5,I) = 4
      END IF
      END DO
C
C     SET UP ATOM BOND INDEX
C
C     NATOMBOND(K) = THE NUMBER OF BONDS OF ATOM K. SINGLE BOND COUNTS 1,
C                    DOUBLE BOND COUNTS 2, AND TRIPLE BOND COUNTS 3
C     NATOMLP(K)   = THE NUMBER OF LONE PAIRS (OF VALENCE SHELL) ON ATOM K.
C
      DO K=1, NATOMS
      NATOMBOND(K) = 0
      NATOMLP(K)   = 0
      END DO
      DO K=1, NCORE
      IJ = LMOLAB(1,K)
      CALL DECODEIJ(IJ,I,J)
        IF(IJ.GT.0.AND.I.NE.J) THEN
        NATOMBOND(I) = NATOMBOND(I) + 1
        NATOMBOND(J) = NATOMBOND(J) + 1
        END IF
      END DO
C
C
C     NOW, SET LMO BOND INDEX
C
      DO I=1, NATOMS
      IF((NATNNU(I).GE.7.AND.NATNNU(I).LE.9).OR.(NATNNU(I).GE.15.AND.
     &    NATNNU(I).LE.17).OR.NATNNU(I).EQ.35.OR.NATNNU(I).EQ.53) THEN
C
C     COLLECT LMOs ON LP ATOMS
C     N,O,F,P,S,Cl,Br,I
C
      NATOMLP(I) = 4 - NATOMBOND(I)
      END IF
      END DO
      DO I=1, NATOMS
      II = I*(I+1)/2
      ICOUNT = 0
        DO LMODEX =1,NCORE
        IF(LMOLAB(1,LMODEX).EQ.II) THEN
        ICOUNT = ICOUNT + 1
        LMOLAB(2,LMODEX) = ICOUNT
        END IF
        END DO
      NAOFFSET(I) = ICOUNT - NATOMLP(I)
      END DO
      DO IJ=1, NAT2
      CALL DECODEIJ(IJ,I,J)
      ICOUNT = 0
        DO LMODEX =1,NCORE
        IF(LMOLAB(1,LMODEX).EQ.IJ) THEN
          ICOUNT = ICOUNT + 1
          LMOLAB(2,LMODEX) = ICOUNT
C
C       LONE PAIR INDEX
C
          IF(I.EQ.J) THEN
          LPINDX = ICOUNT - NAOFFSET(I)
          IF(LPINDX.LT.0) LPINDX = 0
          LMOLAB(2,LMODEX) = LPINDX
          END IF
        END IF
        END DO
      END DO
C
C     FIND LMO BOND TYPE, AND CANONICALIZE LPs, AND MULTIPLE PI BONDS
C
      CALL LOCTOR(IOENGI,'$CANONLP',8,IOK,0)
      IF(IOK.EQ.1) THEN
C
C     FIRST, CANONLP
C
      CALL CANONLP(NATOMS,NCORE,LMOLAB,NATNNU,VLMO,
     &             NBASIS,S,BFLABE,NAOST,W,IOLVBO)
      END IF
C100  CONTINUE
C
C     COPY ALL NEW LMOs to WLMO
C
      DO I=1, NBASIS*NCORE
      WLMO(I) = VLMO(I)
      END DO
      CALL LOCTOR(IOENGI,'$CANONPI',8,IOK,0)
      IF(IOK.EQ.1) THEN
C
C     THEN, CANONPI
C
      CALL CANONPI(NATOMS,NCORE,LMOLAB,VLMO,NBASIS,S,W,IOLVBO,IFAIL)
      END IF
C200  CONTINUE
C
C     COPY ALL NEW LMOs to WLMO
C
      DO I=1, NBASIS*NCORE
      WLMO(I) = VLMO(I)
      END DO
C
C     RE-COMPUTE PGM
C
      NT=0
      DO 1 I=1,NATOMS
      DO 2 J=1,NAO(I)
      NT=NT+1
      NA(NT)=I
  2   CONTINUE
  1   CONTINUE
      DO 520 I=1,NCORE
      II = (I-1)*NATOMS
      IV = (I-1)*NBASIS
      DO 540 K=1,NATOMS
  540 PGM(K+II)=0.0D0
      DO 530 K=1,NBASIS
      KN=NA(K)
      DO 530 L=1,NBASIS
      LN=NA(L)
      IF(K.GT.L) THEN
      KL=K*(K-1)/2+L
      ELSE
      KL=L*(L-1)/2+K
      END IF
      PGM(KN+II)=PGM(KN+II)+VLMO(L+IV)*S(KL)*VLMO(K+IV)
      PGM(LN+II)=PGM(LN+II)+VLMO(L+IV)*S(KL)*VLMO(K+IV)
  530 CONTINUE
  520 CONTINUE
C
C     CREATE LMO LABELS
C
      CALL CLMOLAB(LMOLAB,BONDLAB,NCORE,MCINDEX)
      IF(LPRT.EQ.1) THEN
      CALL MPRINT(VLMO,ENGLMO,NBASIS,NCORE,5,BFLABE,BONDLAB)
      CALL MPRINT(PGM,ENGLMO,NATOMS,NCORE,2,BFLABE,BONDLAB)
      END IF
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     CREATED NOV. 10, 2003
C
C     NOTE: IF THERE ARE MORE THAN 99 ATOMS, THE LABEL MAY NOT BE
C           PROPERLY CREATED.
C
C     AUTHOR: JIABO LI
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE CLMOLAB(LMOLAB,BONDLAB,NLMO,MCINDEX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*8 BONDLAB(*)
      CHARACTER*80 NUMBER,FLAG
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     DIMENSION LMOLAB(2,*),MCLMO(5,20)
      DIMENSION LMOLAB(2,*)
      NUMBER   = '0123456789'
      DO I=1, NLMO
      FLAG     = ' '
      II  = LMOLAB(1,I)
      NBC = LMOLAB(2,I) + 1
      IF(II.EQ.MCINDEX) THEN
      FLAG(1:2)='MC'
      NCC = 2
      ELSE
      CALL DECODEIJ(II,IA,IB)
      IF(IA.GT.99.OR.IB.GT.99) WRITE(IOUTVB,*)
     & 'WARNING: LMO LABEL TRUNCATED!'
      NC1      = 1+IA/10
      NC2      = 1+IA-10*(NC1-1)
      NCC = 0
        IF(NC1.GT.1) THEN
        NCC = NCC + 1
        FLAG(NCC:NCC) = NUMBER(NC1:NC1)
        END IF
        NCC = NCC + 1
        FLAG(NCC:NCC) = NUMBER(NC2:NC2)
        IF(IA.NE.IB) THEN
        NCC = NCC + 1
        FLAG(NCC:NCC) = '-'
        NC1      = 1+IB/10
        NC2      = 1+IB-10*(NC1-1)
          IF(NC1.GT.1) THEN
          NCC = NCC + 1
          FLAG(NCC:NCC) = NUMBER(NC1:NC1)
          END IF
          NCC = NCC + 1
          FLAG(NCC:NCC) = NUMBER(NC2:NC2)
        ELSE
        NCC = NCC + 1
        FLAG(NCC:NCC) = ':'
        END IF
      END IF
      NCC = NCC + 1
      FLAG(NCC:NCC)='('
      NCC = NCC + 1
      FLAG(NCC:NCC)= NUMBER(NBC:NBC)
      NCC = NCC + 1
      FLAG(NCC:NCC)= ')'
        IF(NCC.LT.8) THEN
        IDFF= 8-NCC
        DO J=8, IDFF+1, -1
        FLAG(J:J) = FLAG(J-IDFF:J-IDFF)
        END DO
        DO J=1, IDFF
        FLAG(J:J) = ' '
        END DO
        END IF
      BONDLAB(I) = FLAG(1:8)
      END DO
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     CREATED VBO LABEL
C
C     NOTE: IF THERE ARE MORE THAN 99 ATOMS, THE LABEL MAY NOT BE
C           PROPERLY CREATED.
C
C     NOV. 18, 2003
C
C     AUTHOR: JIABO LI
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE CVBOLAB(NATOM1,NATOM2,NBTYPE,NBINDX,ATEMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 ATEMP
      CHARACTER*80 NUMBER,FLAG
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      NUMBER   = '0123456789'
      IF(NATOM1.GT.99.OR.NATOM2.GT.99)
     &     WRITE(IOUTVB,*)'WARNING: LMO LABELS ARE TRUNCATED!'
      IF(NBTYPE.LT.1.OR.NBTYPE.GT.3) THEN
      ATEMP = 'UNKNOWN!'
      RETURN
      END IF
      NBC = NBINDX + 1
      NC1      = 1+NATOM1/10
      NC2      = 1+NATOM1-10*(NC1-1)
      NCC = 0
      IF(NC1.GT.1) THEN
      NCC = NCC + 1
      FLAG(NCC:NCC) = NUMBER(NC1:NC1)
      END IF
      NCC = NCC + 1
      FLAG(NCC:NCC) = NUMBER(NC2:NC2)
C
C     SIGMA
C
      IF(NBTYPE.EQ.1) THEN
        NCC = NCC + 1
        FLAG(NCC:NCC) = '-'
        NCC = NCC + 1
        FLAG(NCC:NCC) = '>'
        NC1      = 1+NATOM2/10
        NC2      = 1+NATOM2-10*(NC1-1)
        IF(NC1.GT.1) THEN
        NCC = NCC + 1
        FLAG(NCC:NCC) = NUMBER(NC1:NC1)
        END IF
        NCC = NCC + 1
        FLAG(NCC:NCC) = NUMBER(NC2:NC2)
      ELSE IF(NBTYPE.EQ.2) THEN
C
C     PI
C
        NCC = NCC + 1
        FLAG(NCC:NCC) = '^'
      ELSE IF(NBTYPE.EQ.3) THEN
C
C     LP
C
        NCC = NCC + 1
        FLAG(NCC:NCC) = ':'
      END IF
      NCC = NCC + 1
      FLAG(NCC:NCC)='('
      NCC = NCC + 1
      FLAG(NCC:NCC)= NUMBER(NBC:NBC)
      NCC = NCC + 1
      FLAG(NCC:NCC)= ')'
        IF(NCC.LT.8) THEN
        IDFF= 8-NCC
        DO J=8, IDFF+1, -1
        FLAG(J:J) = FLAG(J-IDFF:J-IDFF)
        END DO
        DO J=1, IDFF
        FLAG(J:J) = ' '
        END DO
        END IF
      ATEMP = FLAG(1:8)
      RETURN
      END
      SUBROUTINE DECODEIJ(II,IA,IB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      IA = INT(DSQRT(II+II+1.00000001D0))
      IB = II - IA*(IA-1)/2
      IF(IB.GT.IA) THEN
        IB = IB - IA
        IA = IA + 1
      END IF
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     CANONICALIZE THE LP DIRECTIONS OF LMOs ON N,O,F,P,S,Cl,Br and I
C
C     FIND STANDARD LP DIRECTIONS, AND PERFORM TRANSFORMATION OF THE
C     CORRESPONDING LMOS SO THAT THE LMOS HAVE THE STANDARD ORIENTATION
C     THE LMOLAB(2,I) ALSO HAVE THE CORRECT INDEXES.
C
C     CREATED ON NOV. 1, 2003
C
C     AUTHOR: JIABO LI
C     SAN DIEGO
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     SUBROUTINE CANONLP(NATOMS,NLMO,LMOLAB,NBONDALIST,NATNNU,VLMO,
      SUBROUTINE CANONLP(NATOMS,NLMO,LMOLAB,NATNNU,VLMO,
     &             NBASIS,S,BFLABE,NAOST,W,IOLVBO)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 AOLABEL(1000),ATEMP,BTEMP,BFLABE(*)
C     DIMENSION VLMO(NBASIS,*),S(*),LMOLAB(2,*),NBONDALIST(10,*)
      DIMENSION VLMO(NBASIS,*),S(*),LMOLAB(2,*)
      DIMENSION VLP(10000),NATNNU(*),W(*),NAOST(*),TMPDIR(3,10)
      DIMENSION VBOLP(1000),PLVBDIR(3),VBOLDIR(3),VTMP(1000)
      DIMENSION RMAT(3,3),LPTYPE(10),PROJECTION(10,100),RLP(100)
      DIMENSION IN(100),MASKLP(100),LP2LMO(10),LMOMAPED(100)
      DIMENSION LMOIDX(100),NATOMBOND(1000)
C
C     SET UP ATOM BOND INDEX
C
C     NATOMBOND(I) = THE NUMBER OF BONDS OF ATOM I. SINGLE BOND COUNTS 1,
C                    DOUBLE BOND COUNTS 2, AND TRIPLE BOND COUNTS 3
C                    NOTE: MULTI-CENTER BONDS ARE IGNORED.
C
      DO K=1, NATOMS
      NATOMBOND(K) = 0
      END DO
      DO K=1, NLMO
      IJ = LMOLAB(1,K)
      CALL DECODEIJ(IJ,I,J)
        IF(IJ.GT.0.AND.I.NE.J) THEN
        NATOMBOND(I) = NATOMBOND(I) + 1
        NATOMBOND(J) = NATOMBOND(J) + 1
        END IF
      END DO
      DO I=1, NATOMS
      IF((NATNNU(I).GE.7.AND.NATNNU(I).LE.9).OR.(NATNNU(I).GE.15.AND.
     &    NATNNU(I).LE.17).OR.NATNNU(I).EQ.35.OR.NATNNU(I).EQ.53) THEN
C
C     COLLECT LMOs ON LP ATOMS
C     N,O,F,P,S,Cl,Br,I
C
      II = I*(I+1)/2
      NACORE = 0
        DO J=NLMO,1,-1
        IF(LMOLAB(1,J).EQ.II) THEN
        NACORE = NACORE + 1
        LMOIDX(NACORE) = J
        NAB = (NACORE-1)*NBASIS
        JJ  = (J-1)*NBASIS
          DO K=1, NBASIS
          W(NAB+K) = VLMO(K,J)
          END DO
        END IF
        END DO
C
C     NOW, W HOLDS THE LP LMOs ON ATOM I
C     WRITE(IOUTVB,*)'LP ON ATOM I, NACORE=',I,NACORE
      DO J=1, NACORE
      LMOID = LMOIDX(J)
      LMOLAB(2,LMOID) = 0
      END DO
C
C     GENERATE STANDARD LP VBOS
C
C
C     LONE PAIR VBO
C
      NATOM1 = I
      NATNUM = NATNNU(NATOM1)
C     NBONDS = NBONDALIST(1,NATOM1)
      NAOSTI = NAOST(NATOM1)
      CALL FINDLPDIR(NATOM1,NLP,LPTYPE,TMPDIR,IERR)
C
C     IN H...F...H, NLP = 2
C
      IF(NLP.GT.(4 - NATOMBOND(NATOM1))) NLP = 4 - NATOMBOND(NATOM1)
C
C     IACORE = NACORE - NLP
      NACORE = NLP
C     WRITE(IOUTVB,*)'NLP FINAL = ',NLP
C
C     SET DEFAULT VALANCE LP INDEXES
C
C     DO J=1, NLP
C     LMOLAB(2,J+IACORE) = J
C     END DO
      IF(IOLVBO.EQ.0) GOTO 300
C
C     LOOP OVER ALL LPs
C
      DO J=1, NLP
      LPDEX = J
      LPTYPEJ = LPTYPE(J)
      CALL LOOKLP(NATNUM,VBOLDIR,VBOLP,AOLABEL,NAOFRG,
     &               LPTYPEJ,IOLVBO)
C
C     FIND THE LP DIR IN THE MOL
C
      PLVBDIR(1) = TMPDIR(1,LPDEX)
      PLVBDIR(2) = TMPDIR(2,LPDEX)
      PLVBDIR(3) = TMPDIR(3,LPDEX)
C
C     FIND TRAN MATRIX RMAT, WHICH TRANSLATE VBOLDIR TO PLVBDIR,
C     I.E. RMAT VBOLDIR = PLVBDIR
C
      CALL TRNV2V(VBOLDIR,PLVBDIR,RMAT,IERR)
      IF(IERR.EQ.1) CALL ABORT0('CANONLP001')
C
C     COPY FROM VBOLP TO VTEMP
C
        DO K=1, NBASIS
        VTMP(K) = 0.0D0
        END DO
        DO K=1, NAOFRG
        VTMP(NAOSTI+K-1) = VBOLP(K)
        ATEMP = AOLABEL(K)
        BTEMP = BFLABE(NAOSTI+K-1)
        IF(ATEMP(11:12).NE.BTEMP(11:12)) CALL ABORT0('CANONLP002')
        END DO
C
C     TRANSLATE LIB VBO TO MOL VBO
C
      CALL ORBTRN(NAOFRG,1,BFLABE(NAOSTI),VTMP(NAOSTI),RMAT,
     &            VTMP(NAOSTI))
C
C     NOW, COPY VTMP TO VLP
C
      JJ = (J-1)*NBASIS
        DO K=1, NBASIS
        VLP(JJ+K) = VTMP(K)
        END DO
C
C     LOOP OVER LPs ON A LP ATOM
C
      END DO
C
C     NOW, VLP HOLDS THE LP VBOs ON ATOM I
C
      DO J=1, NLP
      JJ = (J-1)*NBASIS
C
C     NORMALIZATION OF THE ORBITAL
C
      CALL NORMORB(NBASIS,1,VLP(JJ+1),S,IERR)
      END DO
C
C     OVERLAPS
C
        DO K=1, NACORE
        KK = (K-1)*NBASIS
        VL = 0.0D0
          DO J=1, NLP
          JJ = (J-1)*NBASIS
          CALL ORBOVL(NBASIS,VLP(JJ+1),W(KK+1),S,AB)
          PROJECTION(J,K) = AB
          VL = VL + AB*AB
C         WRITE(IOUTVB,*)'LMO K PROJECTED INTO LP J =', K,J,AB
          END DO
        RLP(K) = VL
        END DO
C
C     FIND NLP LARGEST VLP
C
      CALL SHELL(RLP,IN,NACORE)
C
C     DEFINE MASK
C
        DO J=1, NACORE
        MASKLP(J) = 0
        LMOMAPED(J) = 0
        END DO
        DO J=NACORE,NACORE-NLP+1,-1
        MASKLP(IN(J)) = 1
        END DO
C
C     APPLY MASK ON PROJECTION MATRIX
C
        DO J=1, NLP
        PMAX =0.0D0
        LMODEX = 0
          DO K=1, NACORE
          PROJECTION(J,K) = PROJECTION(J,K)*MASKLP(K)
          IF(PMAX.LT.DABS(PROJECTION(J,K)).AND.LMOMAPED(K).EQ.0) THEN
             PMAX = DABS(PROJECTION(J,K))
             LMODEX = K
          END IF
          END DO
        IF(LMODEX.EQ.0) CALL ABORT0('CANONLP003')
        LP2LMO(J) = LMODEX
        LMOMAPED(LMODEX) = 1
        END DO
C       WRITE(IOUTVB,*)'LP2LMO MAP 1 =',(LP2LMO(J),J=1, NLP)
C       WRITE(IOUTVB,*)'LP2LMO MAP 2 =',(LMOIDX(LP2LMO(J)),J=1, NLP)
C
C     SET BONDTYPE TO ZERO FOR ALL LMOS ON THE ATOM
C
        DO J=1, NACORE
        LMOLAB(2,LMOIDX(J)) = 0
        END DO
C
C     LABEL LP LMOS
C
        DO J=1, NLP
        LMOLAB(2,LMOIDX(LP2LMO(J))) = J
        END DO

C
C     DEFINE NEW LPs AND THE MAP TO LMOs
C
        DO J=1, NLP
        JJ = (J-1)*NBASIS
          DO K=1, NBASIS
          VLP(JJ+K) = 0.0D0
          END DO
          DO K=1, NACORE
          KK = (K-1)*NBASIS
            DO L=1,NBASIS
            VLP(JJ+L) = VLP(JJ+L)+PROJECTION(J,K)*W(KK+L)
            END DO
          END DO
C
C         NORMALIZATION
C
          CALL NORMORB(NBASIS,1,VLP(JJ+1),S,IERR)
          IF(IERR.EQ.1) CALL ABORT0('CANONLP004')
C
C       COPY VLP TO LMO
C
          LMODXJ = LMOIDX(LP2LMO(J))
          DO L=1, NBASIS
          VLMO(L, LMODXJ) = VLP(JJ+L)
          END DO
        END DO
C-------------------------------------------------------------------------
C
C     PERFORM LOWDIN ORTHOGONALIZAITON OF LPs
C
        NSS= 1
        NSA=NSS+NBASIS*NBASIS
        NV =NSA+NBASIS*NBASIS
        NW =NV +NBASIS*NBASIS
C       NWK=NW +NBASIS*NBASIS
C
C       S->W(NSS)
C
        DO 200 J=1,NBASIS
        JJ=NSS-1+(J-1)*NBASIS
        DO 200 K=1,NBASIS
        W(JJ+K)=S(IJ00(J,K))
 200    CONTINUE
C
C     Lowdin orthogonalization of all VBOs on the atom
C
        CALL LOWD(NBASIS,NLP,W(NSS),VLP,W(NSA),W(NV),W(NW),IERR)
        IF(IERR.EQ.1) CALL ABORT0('CANONLP005')
C
C     COPY W(NV) TO VLMO
C
        DO J=1, NLP
        JJ = NV-1+(J-1)*NBASIS
C
C       COPY VLP TO LMO
C
          LMODXJ = LMOIDX(LP2LMO(J))
          DO L=1, NBASIS
          VLMO(L, LMODXJ) = W(JJ+L)
          END DO
        END DO
C-------------------------------------------------------------------------
C
C     IF OF LP ATOMS
C
      ELSE
C     IF IS NON-LP ATOMS
      II = I*(I+1)/2
        DO J=1, NLMO
C       MARK IT AS A CORE
        IF(LMOLAB(1,J).EQ.II) LMOLAB(2,J) = 0
        END DO
      END IF
  300 CONTINUE
C
C     LOOP OVER ATOMS
C
      END DO
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     CANONICALIZE THE PI ORBITAL LMOs ON TRIPLE BONDS (SUCH AS CN, CC ETC
C
C     FIND STANDARD PI DIRECTIONS FOR MULTIPLE PI BONDS, AND PERFORM
C     TRANSLATION OF LMOS SO THAT THEY HAVE THE STANDARD ORIENTATION
C     THE LMOLAB(2,I) ALSO HAVE THE CORRECT INDEXES.
C
C     CREATED ON NOV. 7, 2003
C
C     AUTHOR: JIABO LI
C     SAN DIEGO
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE CANONPI(NATOMS,NLMO,LMOLAB,VLMO,NBASIS,S,W,IOLVBO,
     & IFAIL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*12 AOLABEL(1000),ATEMP,BTEMP,BFLABE(*)
C     DIMENSION VLMO(NBASIS,*),S(*),LMOLAB(2,*),NBONDALIST(10,*)
      DIMENSION VLMO(NBASIS,*),S(*),LMOLAB(2,*)
C     DIMENSION BLMO(10000),NATNNU(*),W(*),NAOST(*),TMPDIR(3,10)
      DIMENSION BLMO(10000),W(*)
C     DIMENSION VBOLP(1000),PLVBDIR(3),VBOLDIR(3),VTMP(1000)
C     DIMENSION RMAT(3,3),LPTYPE(10),PROJECTION(10,100),RLP(100)
      DIMENSION PROJECTION(10,100)
C     DIMENSION IN(100),MASKLP(100),LPI2LMO(10),LMOMAPED(100)
      DIMENSION LPI2LMO(10),LMOMAPED(100)
      DIMENSION LMOIDX(100)
      IFAIL = 0
C
      DO IA=1, NATOMS
      DO IB=IA+1, NATOMS
      IAXX = IA
      IBXX = IB
C
C     COLLECT LMOs BEWTEEN ATOMS IA AND IB
C
      IAB = IB*(IB-1)/2 + IA
      LMOBONDS = 0
        DO J=1, NLMO
        IF(LMOLAB(1,J).EQ.IAB) THEN
        LMOBONDS = LMOBONDS + 1
        LMOLAB(2,J)=LMOBONDS
        LMOIDX(LMOBONDS) = J
        NAB = (LMOBONDS-1)*NBASIS
        JJ  = (J-1)*NBASIS
          DO K=1, NBASIS
          W(NAB+K) = VLMO(K,J)
          END DO
        END IF
        END DO
C
C     NOW, W HOLDS THE BONDING LMOs BEWTEEN ATOM IA AND IB
C
      DO J=1, LMOBONDS
      JJ = (J-1)*NBASIS
        DO K=1, NBASIS
C       WRITE(IOUTVB,'(2X,F10.5)')W(JJ+K)
        END DO
      END DO
C
C     DO NOTHING FOR A SINGLE AND DOUBLE BOND
C
      IF(LMOBONDS.LE.2.OR.IOLVBO.EQ.0) GOTO 300
C
C     GENERATE STANDARD BONDING LMOS BETWEEN ATOM1 AND ATOM2
C
C     THREE LMOs WILL BE RETURNED. FIRST IS A SIGMA, SECOND IS THE 1ST PI
C     THRID THE 2ND PI. IERR IS THE ERROR CODE (0/1 = NO ERROR/ERROR)
C
C     WRITE(IOUTVB,*)'CREATE STD BONDING LMOs'
      CALL GENBDLMO(IAXX,IBXX,NBASIS,BLMO,LMOBONDS,IOLVBO,IERR)
        IF(IERR.EQ.1) THEN
        IFAIL = 1
        GOTO 300
        END IF
      NBLMO = LMOBONDS
      DO J=1, NBLMO
      JJ = (J-1)*NBASIS
C
C     NORMALIZATION OF THE ORBITAL
C
      CALL NORMORB(NBASIS,1,BLMO(JJ+1),S,IERR)
C     WRITE(IOUTVB,*)(BLMO(JJ+K),K=1,NBASIS)
      END DO
C
C     OVERLAPS
C
        DO K=1, LMOBONDS
        KK = (K-1)*NBASIS
        VL = 0.0D0
          DO J=1, NBLMO
          JJ = (J-1)*NBASIS
          CALL ORBOVL(NBASIS,BLMO(JJ+1),W(KK+1),S,AB)
          PROJECTION(J,K) = AB
          VL = VL + AB*AB
C         WRITE(IOUTVB,*)'LMO K PROJECTED INTO STD BLMO J =', K,J,AB
          END DO
C       RLP(K) = VL
        END DO
        DO J=1, LMOBONDS
        LMOMAPED(J) = 0
        END DO
C       WRITE(IOUTVB,*)'LMOMAPED =',(LMOMAPED(K),K=1,LMOBONDS)
        DO J=1, NBLMO
        PMAX =0.0D0
        LMODEX = 0
C       WRITE(IOUTVB,*)'LMOBONDS, NBLMO,IA,IB =',LMOBONDS,NBLMO,IA,IB
          DO K=1, LMOBONDS
          IF(PMAX.LT.DABS(PROJECTION(J,K)).AND.LMOMAPED(K).EQ.0) THEN
             PMAX = DABS(PROJECTION(J,K))
             LMODEX = K
          END IF
          END DO
        IF(LMODEX.EQ.0) CALL ABORT0('CANONPIX  ')
        LPI2LMO(J) = LMODEX
        LMOMAPED(LMODEX) = 1
        END DO
C
C     DEFINE NEW BLMO AND THE MAP TO LMOs
C
        DO J=1, NBLMO
        JJ = (J-1)*NBASIS
          DO K=1, NBASIS
          BLMO(JJ+K) = 0.0D0
          END DO
          DO K=1, LMOBONDS
          KK = (K-1)*NBASIS
            DO L=1,NBASIS
            BLMO(JJ+L) = BLMO(JJ+L)+PROJECTION(J,K)*W(KK+L)
            END DO
          END DO
C
C       COPY BLMO TO LMO, RELABE BOND INDEX (1=SIGMA, 2=1st PI; 3=2nd PI)
C
          LMODXJ = LMOIDX(LPI2LMO(J))
          DO L=1, NBASIS
          VLMO(L, LMODXJ) = BLMO(JJ+L)
          END DO
C
        LMOLAB(2,LMODXJ)=J
        END DO
C-------------------------------------------------------------------------
C
C     PERFORM LOWDIN ORTHOGONALIZAITON OF LPs
C
        NSS= 1
        NSA=NSS+NBASIS*NBASIS
        NV =NSA+NBASIS*NBASIS
        NW =NV +NBASIS*NBASIS
C       NWK=NW +NBASIS*NBASIS
C
C       S->W(NSS)
C
        DO 200 J=1,NBASIS
        JJ=NSS-1+(J-1)*NBASIS
        DO 200 K=1,NBASIS
        W(JJ+K)=S(IJ00(J,K))
 200    CONTINUE
C
C     Lowdin orthogonalization of all VBOs on the atom
C
        CALL LOWD(NBASIS,LMOBONDS,W(NSS),BLMO,W(NSA),W(NV),W(NW),IERR)
        IF(IERR.EQ.1) CALL ABORT0('CANONPI01 ')
C
C     COPY W(NV) TO VLMO
C
        DO J=1, NBLMO
        JJ = NV-1+(J-1)*NBASIS
C
C       COPY VPI TO LMO
C
          LMODXJ = LMOIDX(LPI2LMO(J))
          DO L=1, NBASIS
C         VLMO(L, LMODXJ) = W(JJ+L)
          END DO
        END DO
  300 CONTINUE
C-------------------------------------------------------------------------
C
C     LOOP OVER J (ATOMS)
C
      END DO
C
C     LOOP OVER I (ATOMS)
C
      END DO
      RETURN
      END
      SUBROUTINE GENBDLMO(NATOM1,NATOM2,NBASIS,BLMO,LMOBONDS,
     &                    IOLVBO,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION BLMO(NBASIS,*),VBOD1(3),VBOD2(3),V1(2000),V2(2000)
      IERR = 0
      DO I=1, LMOBONDS
      NBTYPE = I
      CALL AVBOGEN(NATOM1,NATOM2,NBTYPE,V1,VBOD1,IOLVBO,IERR)
      CALL AVBOGEN(NATOM2,NATOM1,NBTYPE,V2,VBOD2,IOLVBO,IERR)
      CALL DOTPROD(VBOD1,VBOD2,AB)
      IF(DABS(AB).LT.0.866D0) THEN
      IERR = 1
      RETURN
      ELSE
        FACTOR = 1.0D0
        IF(DABS(AB).LT.0.0D0) FACTOR = -1.0D0
        DO J=1, NBASIS
        BLMO(J,I) = V1(J) + FACTOR*V2(J)
        END DO
      END IF
      END DO
      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     MATH ROUTINES
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     NORMALIZATION OF THE ORBITAL
C
C     A: INPUT ORBITALS
C     S: OVERLAP MATRIX LOWER HALF FORMAT
C     NBASIS: DIMENSION OF ORBITALS
C     NORB: NUMBER OF ORBITALS
C
C     CREATED NOV. 4, 2003
C
C     AUTHOR: JIABO LI
C
C     SAN DIEGO
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE NORMORB(NBASIS,NORB,A,S,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(NBASIS,NORB),S(*)
      PARAMETER (EPS = 0.000001D0)
      IERR = 0
      DO 100 I=1, NORB
      SUM=0.0D0
      DO 110 J=1, NBASIS
      DO 110 K=1, NBASIS
 110  SUM=SUM+A(J,I)*S(IJ00(J,K))*A(K,I)
      SUM=DSQRT(SUM)
C     WRITE(IOUTVB,1) SUM
C1    FORMAT(" SUM = ",D20.4)
      IF(SUM.LT.EPS) THEN
      IERR = 1
      RETURN
      END IF
      DO 120 J=1,NBASIS
 120  A(J,I)=A(J,I)/SUM
 100  CONTINUE
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     OVERLAP OF TWO ORBITALS
C
C     A, B: INPUT ORBITALS
C     S: OVERLAP MATRIX, LOWER HALF FORMAT
C     NBASIS: DIMENSION OF ORBITALS
C     AB: RETURN VALUE OF THE OVERLAP OF A AND B
C
C     CREATED: NOV. 4, 2003
C
C     AUTHOR: JIABO LI
C
C     SAN DIEGO
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE ORBOVL(NBASIS,A,B,S,AB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(NBASIS), B(NBASIS), S(*)
      AB = 0.0D0
      DO 110 I=1, NBASIS
      DO 110 J=1, NBASIS
 110  AB=AB+A(I)*S(IJ00(I,J))*B(J)
      RETURN
      END
C
C     MATRIX  MULTIPLICATION
C     C=A*B,
C     A IS A SYMMETRIC MATRIX
C
      SUBROUTINE MATSYM(M,N,A,B,C)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(*),B(M,N),C(M,N)
      DO 100 I=1,N
      DO 100 J=1,M
      SUM=0.0D0
      IAJ=J*(J-1)/2
      DO 200 K=1,J
  200 SUM=SUM+A(IAJ+K)*B(K,I)
      IAK=J*(J+3)/2
      DO 250 K=J+1,M
      SUM=SUM+A(IAK)*B(K,I)
  250 IAK=IAK+K
  100 C(J,I)=SUM
      RETURN
      END
C
C     MATRIX  MULTIPLICATION
C     C=A*B',
C     A IS A SYMMETRIC MATRIX
C     B' IS THE TRANSPOSE OF MATRIX B
C
      SUBROUTINE MATSYM2(M,N,A,B,C)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(*),B(N,M),C(M,N)
      DO 100 I=1,N
      DO 100 J=1,M
      SUM=0.0D0
      IAJ=J*(J-1)/2
      DO 200 K=1,J
  200 SUM=SUM+A(IAJ+K)*B(I,K)
      IAK=J*(J+3)/2
      DO 250 K=J+1,M
      SUM=SUM+A(IAK)*B(I,K)
  250 IAK=IAK+K
  100 C(J,I)=SUM
      RETURN
      END
C
C     COPY VECTORS
C     A->B
C
      SUBROUTINE CPYVEC(N,A,B)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(N),B(N)
      DO 100 I=1,N
  100 B(I)=A(I)
      RETURN
      END
C
C     A,B ARE GENERAL MATRICES
C     C=A*B
C
      SUBROUTINE MATMUL2(M,L,N,A,B,C)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(M,L),B(L,N),C(M,N)
      DO 100 I=1,N
      DO 100 J=1,M
      SUM=0.0D0
      DO 200 K=1,L
  200 SUM=SUM+A(J,K)*B(K,I)
  100 C(J,I)=SUM
      RETURN
      END
C
C     MATRIX TRANSFORMATION
C     C=A'*B*A
C     B IS A SYMMETRIC MATRIX
C
      SUBROUTINE MATRAN(M,N,A,W,B,C)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(M,N),W(M,N),B(*),C(*)
      CALL MATSYM(M,N,B,A,W)
      IJ=0
      DO 100 I=1,N
      DO 100 J=1,I
      SUM=0.0D0
      IJ=IJ+1
      DO 110 K=1,M
  110 SUM=SUM+A(K,I)*W(K,J)
  100 C(IJ)=SUM
      RETURN
      END
C
C     MATRIX TRANSFORMATION
C     C=A*B*A'
C     B IS A SYMMETRIC MATRIX
C
      SUBROUTINE MATRAN1(M,N,A,W,B,C)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(N,M),W(M,N),B(*),C(*)
      CALL MATSYM2(M,N,B,A,W)
      IJ=0
      DO 100 I=1,N
      DO 100 J=1,I
      SUM=0.0D0
      IJ=IJ+1
      DO 110 K=1,M
  110 SUM=SUM+A(I,K)*W(K,J)
  100 C(IJ)=SUM
      RETURN
      END
C
C     MATRIX TRANSFORMATION
C     C=F1*C+F2*A*B*A'
C     B IS A SYMMETRIC MATRIX
C     F1,F2 ARE TWO CONSTRANTS
C
      SUBROUTINE MATRAN2(M,N,A,W,B,C,IFLAG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(N,M),W(M,N),B(*),C(*)
      IF(IFLAG.EQ.0) THEN
      F1=0.0D0
      F2=1.0D0
      ELSE IF(IFLAG.EQ.1) THEN
      F1=1.0D0
      F2=1.0D0
      ELSE IF(IFLAG.EQ.-1) THEN
      F1=1.0D0
      F2=-1.0D0
      END IF
      CALL MATSYM2(M,N,B,A,W)
      IJ=0
      DO 100 I=1,N
      DO 100 J=1,I
      SUM=0.0D0
      IJ=IJ+1
      DO 110 K=1,M
  110 SUM=SUM+A(I,K)*W(K,J)
  100 C(IJ)=F1*C(IJ)+F2*SUM
      RETURN
      END
      SUBROUTINE MALTID(M,D1,DC1,V)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION D1(M,M),DC1(M),V(M)
      DO 100 I=1,M
      DC1(I)=0.0D0
      DO 100 J=1,M
      DC1(I)=D1(J,I)*V(J)+DC1(I)
  100 CONTINUE
      RETURN
      END
      SUBROUTINE MALTSQ(M,MSQ,DSQ,DC1,V)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION DSQ(MSQ),DC1(M),V(M)
      DO 100 I=1,M
      DC1(I)=0.0D0
      IAI=I*(I-1)/2
      DO 110 J=1,I
      DC1(I)=DSQ(IAI+J)*V(J)+DC1(I)
  110 CONTINUE
      IAJ=I*(I+3)/2
      DO 120 J=I+1,M
      DC1(I)=DSQ(IAJ)*V(J)+DC1(I)
      IAJ=IAJ+J
  120 CONTINUE
  100 CONTINUE
      RETURN
      END
      FUNCTION IJKLGX(I,J,K,L)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /IDD/ID(100000)
      IJ=IJ01(I,J)
      KL=IJ01(K,L)
      IF(IJ.GE.KL) THEN
      IJKLGX=ID(IJ)+KL
      ELSE
      IJKLGX=ID(KL)+IJ
      END IF
      RETURN
      END
      FUNCTION IJKL01(I,J,K,L)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /IAA/IA(100000)
      IF(I.GT.J) THEN
      IJ=IA(I)+J
      ELSE
      IJ=IA(J)+I
      END IF
      IF(K.GT.L) THEN
      KL=IA(K)+L
      ELSE
      KL=IA(L)+K
      END IF
      IF(IJ.GT.KL) THEN
      IJKL01=IA(IJ)+KL
      ELSE
      IJKL01=IA(KL)+IJ
      END IF
      RETURN
      END
      SUBROUTINE DIAG(A,U,E,N,NDIM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C********************************************************************C
C   ARGUMENTS.                                                       C
C        A       MATRIX TO BE DIAGONALIZED.                          C
C        U       MATRIX OF EIGENVECTORS.                             C
C        E       LIST OF EIGENVALUES                                 C
C        N       # OF EIGENVALUES NEEDED                             C
C        NDIM    DIMENSION OF THE MATRICES AND THE VECTOR.           C
C********************************************************************C
      DIMENSION A(NDIM,NDIM),U(NDIM,NDIM),E(NDIM)
      DATA ZER,ONE,TWO,FOR,EPS/0.0D 00,1.0D 00,2.0D 00,4.0D 00,1.0D-30/
      DO 8 J=1,NDIM
      DO 9 I=1,NDIM
    9 U(I,J)=ZER
    8 U(J,J)=ONE
   10 AMAX=ZER
      DO 11 I=2,N
      JUP=I-1
      DO 11 J=1,JUP
      AII=A(I,I)
      AJJ=A(J,J)
      AOD=A(I,J)
      ASQ=AOD*AOD
      IF(ASQ.LE.AMAX) GOTO 23
      AMAX=ASQ
   23 IF(ASQ.LE.EPS) GOTO 11
      DIFFR=AII-AJJ
      IF(DIFFR.GE.0.0D0) GOTO 15
      SIGN=-TWO
      DIFFR=-DIFFR
      GO TO 16
   15 SIGN=TWO
   16 TDEN=DIFFR+ DSQRT(DIFFR*DIFFR+FOR*ASQ)
      TAN=SIGN*AOD/TDEN
      C=ONE/( DSQRT(ONE+TAN*TAN))
      S=C*TAN
      DO 24 K=1,N
      XJ=C*U(K,J)-S*U(K,I)
      U(K,I)=S*U(K,J)+C*U(K,I)
      U(K,J)=XJ
      IF(K.EQ.J) GOTO 24
      IF(K.EQ.I) GOTO 24
      XJ=C*A(K,J)-S*A(K,I)
      A(K,I)=S*A(K,J)+C*A(K,I)
      A(K,J)=XJ
      A(I,K)=A(K,I)
      A(J,K)=A(K,J)
   24 CONTINUE
      A(I,I)=C*C*AII+S*S*AJJ+TWO*S*C*AOD
      A(I,J)=ZER
       A(J,J)=C*C*AJJ+S*S*AII-TWO*S*C*AOD
      A(J,I)=ZER
   11 CONTINUE
      IF(AMAX.GT.EPS) GOTO 10
      DO 25 I=1,N
   25 E(I)=A(I,I)
CJLI
      CALL RORDER(U,A,E,N,NDIM)
CJLI
      RETURN
      END
      SUBROUTINE RORDER(C,PW,E,N,NDIM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION C(NDIM,N),PW(NDIM,N),IN(5000),E(*)
      IF(N.LE.0) RETURN
      CALL SHELL(E,IN,N)
      DO I=1,N
      II=IN(I)
      DO J=1,NDIM
      PW(J,I)=C(J,II)
      END DO
      END DO
      DO I=1,N
      DO J=1,NDIM
      C(J,I)=PW(J,I)
      END DO
      END DO
      RETURN
      END
C
C     THIS IS A SORTING ROUTINE
C
      SUBROUTINE SHELL(X,IN,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION X(N),IN(N)
      IF(N.LE.0) RETURN
      DO 100 I=1,N
 100  IN(I)=I
      J=N
  5   IF(J.EQ.1) GOTO 20
      J=J/2
      NMJ=N-J
  8   IFLAG=0
      DO 10 I=1,NMJ
      L=I+J
      IF(X(I).LE.X(L)) GOTO 10
      TX=X(I)
      IX=IN(I)
      X(I)=X(L)
      X(L)=TX
      IN(I)=IN(L)
      IN(L)=IX
      IFLAG=1
C     IFLAG=1.0
  10  CONTINUE
      IF(IFLAG.EQ.1) GOTO 8
      GOTO 5
 20   RETURN
      END
C
C     JACOBI METHOD FOR DIAGONLIZATION
C
C     THIS SUBROUTINE IS A PROGRAM FROM WHICH WE CAN OBTAIN
C     EIGENFUNCTIONS AND EIGENVALUES, WHERE MATRICES A AND B ARE
C     RESPECTIVELY HAMILTON AND OVERLAP MATRICES, D ARE EIGENVALUES,
C     AND E IS THE MIN. OF D. N IS THE DIMENSION OF MATRICE.
C
      SUBROUTINE EG(N,A,B,D,V,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION B(N,N),D(N),A(N,N),DL(5000),V(N,N),IN(5000),W(*)
      NWA=1
      NWK=NWA+N*(N+1)/2
      CALL REDUCVB2K(N,A,B,DL)
      DO 5 I=1,N
      DO 5 J=I,N
 5    A(I,J)=A(J,I)
      IJ=0
      DO 6 I=1,N
      DO 6 J=1,I
      IJ=IJ+1
 6    W(IJ)=A(J,I)
Cxxx  CALL JACOB(N,A,D,1,V)
Cxxx  CALL DiagD(W(NWA),V,D,N,W(NWK),W(NWK+N),N,.FALSE.)
      CALL GIVEIS(N,N,N,W(NWA),W(NWK),IN,D,V,IERR)
      CALL REBAC1(N,N,B,DL,V)
      CALL SHELL(D,IN,N)
      DO 200 I=1,N
      II=IN(I)
      DO 200 J=1,N
 200  B(J,I)=V(J,II)
      DO 210 I=1,N
      DO 210 J=1,N
 210  V(J,I)=B(J,I)
      IF(N.EQ.1) THEN
        V(1,1) = 1.0D0/SQRT(B(1,1))
      END IF
      RETURN
      END
C
      SUBROUTINE REDUCVB2K(N,A,B,DL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(N,N),B(N,N),DL(N)
      DO 110 I=1,N
      DO 110 J=I,N
      X=B(I,J)
      DO 140 K=1,I-1
140   X=X-B(I,K)*B(J,K)
      IF(I.EQ.J) THEN
      DL(I)=DSQRT(X)
      ELSE
      B(J,I)=X/DL(I)
      END IF
110   CONTINUE
      DO 210 I=1,N
      DO 210 J=I,N
      X=A(I,J)
      DO 240 K=1,I-1
240   X=X-B(I,K)*A(J,K)
      A(J,I)=X/DL(I)
210   CONTINUE
      DO 310 J=1,N
      DO 310 I=J,N
      X=A(I,J)
      DO 340 K=J,I-1
340   X=X-A(K,J)*B(I,K)
      DO 370 K=1,J-1
370   X=X-A(J,K)*B(I,K)
      A(I,J)=X/DL(I)
310   CONTINUE
      RETURN
      END
C
      SUBROUTINE REBAC1(N,M,B,DL,Z)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION B(N,N),DL(N),Z(N,M)
      DO 100 J=1,M
      DO 100 I1=1,N
      I=N-I1+1
      X=Z(I,J)
      I2=I+1
      DO 130 K=I2,N
130   X=X-B(K,I)*Z(K,J)
      Z(I,J)=X/DL(I)
100   CONTINUE
      RETURN
      END
      SUBROUTINE ABORT0(MESSAGE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*10 MESSAGE
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      WRITE(IOUTVB,*)'PROGRAM STOPPED AT ',MESSAGE(1:10)
      WRITE(IOUTVB,*)'PLEASE CHECK YOUR INPUT OR CONTACT THE AUTHORS AT'
      WRITE(IOUTVB,*)'vb@scinetec.com WITH THIS ERROR MESSAGE AND YOUR'
      WRITE(IOUTVB,*)'INPUT/OUTPUT FILES'
CGMS  CALL ABRT
CGAU  CALL ABRTG(MESSAGE)
      STOP
      END
      SUBROUTINE ABRTVB()
CGMS  CALL ABRT
CGAU  CALL ABRTG('VB ERROR')
      STOP
      END
      SUBROUTINE PRECALC(ICHARGE,MULTIPLICITY,SOURCEDAT,IFLAG)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Pre-calculation process
C               (Key words parsing, basis set loading, inputs)
C
C     Note:
C               There are fifteen built-in basis sets. The list can be easily
C               extended by adding new basis set files to the basis set
C               directory BASET.
C
C     History:
C               First created in May 2000
C               Added output for input summary, July 2000
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=2000)
      CHARACTER*80 BUFF,WORD,KEYWORDS,COMMENTS,BASET,BLANK
      CHARACTER*20 SYMBOL,KEYNAMES
      CHARACTER*2 ATMSYM
      CHARACTER*64 SOURCEDAT
      DIMENSION BASET(10000),KEYWORDS(100),LCTBAS(105),LENBAS(105)
      DIMENSION KEYLENS(100),KEYNAMES(100),KEYVALUES(1000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
     &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
     &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /ATOMSY/ ATMSYM(92)
      COMMON /ATMCH/ ATMCHG(MXATM),NATNO(MXATM)
      BLANK(1:40)  = '                                        '
      BLANK(41:80) = '                                        '
      SYMBOL       = 'ATOM'
      ICURSOR      = 1
      LENBUF       = 80
C     iounit       = 5
      ITOPIC       = 1
C     IOENGI       = 80
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      NOBIAS=0
      LFROZN=0
      LCIONLY=0
      LPTALL=0
      LHYBRD=0
      IFLAG =0

C000  IFLAG =1
CSMI  IFLAG =1
      SOURCEDAT=FSTR(1:LENFIL)//'.source'
C     SOURCEDAT='SOURCEDAT'
C     call loctor(IOENGI,'#!',2,iok,1)
      CALL LOCTOR2(IOENGI,'#!',2,IOK,1,BUFF)
      IF(IOK.EQ.0) CALL ABORT0('NOKEYWORDS')
C     backspace(IOENGI)
C     read(IOENGI,'(A80)')buff
      WRITE(IOUTVB,101)
 101  FORMAT(/' Input of molecule',/,' =================')
      CALL CONVCASE(BUFF,80,1)
      WRITE(IOUTVB,'(1X,A80)') BUFF
C
C     Do some clean-up (remove '/')
C
      DO I=1,LENBUF
      IF(BUFF(I:I).EQ.'/') BUFF(I:I)=' '
      END DO
      CALL READWDS(BUFF,KEYWORDS,KEYLENS,ICURSOR,LENBUF,NWORD)
C
C     A blank line to terminate keyword input
C
 100  READ(IOENGI,'(A80)')BUFF
      CALL CONVCASE(BUFF,80,1)
      WRITE(IOUTVB,'(1X,A80)') BUFF
      ICURSOR=1
      CALL READWDS(BUFF,KEYWORDS(NWORD+1),KEYLENS(NWORD+1),
     &             ICURSOR,LENBUF,NEWWORD)
      NWORD = NWORD + NEWWORD
      IF(NEWWORD.GT.0) GOTO 100
      ITOPIC=ITOPIC+1
C
C     setup keynames-values according to the keywords.
C
      CALL SETKEYVAL(NWORD,KEYWORDS,KEYNAMES,KEYVALUES)
      IRESTART=KEYVALUES(9)
C
C     method
C
      ICURSOR=1
      CALL PARMTHD(KEYWORDS(2),KEYLENS(2),MTHEORY,METHOD,NGPF,
     &             ICURSOR,MLORBIT,MELE)
      WORD    = KEYWORDS(3)
      BASNAME = WORD(1:20)
      DO I=1,105
      LCTBAS(I)=0
      LENBAS(I)=0
      END DO
C     if(iflag.eq.0) return
C     Move above line below title
C
C     Go to the next topic: comments
C
      READ(IOENGI,'(A80)')COMMENTS
      WRITE(IOUTVB,201) COMMENTS
 200  READ(IOENGI,'(A80)')BUFF
      IF(BUFF.NE.BLANK.AND.COMMENTS.NE.BLANK) THEN
      WRITE(IOUTVB,202) BUFF
         GOTO 200
      ENDIF
 201  FORMAT(' Title: ',A80)
 202  FORMAT('        ',A80)
      WRITE(IOUTVB,203)
 203  FORMAT(1X)
      IF(IFLAG.EQ.0) RETURN
C
C     Go to the next topic: charge and multiplicity
C
      ITOPIC=ITOPIC+1
      READ(IOENGI,*,ERR=901)ICHARGE,MULTIPLICITY
      GOTO 902
  901 WRITE(IOUTVB,*)"INPUT ERROR FOR CHARGE AND MULTIPLICITY"
      CALL ABORT0("PRECALC001")
  902 CONTINUE
      WRITE(IOUTVB,900)ICHARGE, MULTIPLICITY
  900 FORMAT(' Charge =',I3,' Multiplicity =',I3)
C
C     Go to the next topic: read Cartesian coordiantes
C
      ITOPIC=ITOPIC+1
      NATOM=0
      NELECTRON = 0
 300  READ(IOENGI,'(A80)',ERR=400, END=400)BUFF
      IF(BUFF(1:80).EQ.BLANK(1:80)) GOTO 400
      NATOM = NATOM +1
      READ(BUFF(1:80),*,ERR=301)NATNUM(NATOM),(XYZ(J,NATOM),J=1,3)
      GOTO 303
 301  READ(BUFF(1:80),*,ERR=302)TNATNUM,(XYZ(J,NATOM),J=1,3)
      NATNUM(NATOM) = INT(TNATNUM + 0.1D0)
      GOTO 303
 302  WRITE(IOUTVB,*)
     &  "WRONG FORMAT IN YOUR INPUT. PLEASE CHECK THIS LINE"
      WRITE(IOUTVB,'(A80)') BUFF
      CALL ABORT0("INPUTERROR")
 303  CONTINUE
      NELECTRON = NELECTRON + NATNUM(NATOM)
      GOTO 300
 400  ITOPIC=ITOPIC+1
C
C     Check validity of Icharge and Multiplicity
C
      NELECTRON = NELECTRON - ICHARGE
      NALPHA = (NELECTRON + MULTIPLICITY - 1)/2
      NBETA = (NELECTRON - MULTIPLICITY + 1)/2
      IF ((NALPHA + NBETA).NE.NELECTRON) THEN
        WRITE(IOUTVB,1400)
 1400   FORMAT(" Multiplicity and Nuclear Charge are not compatible",
     &  /," Please check and correct them. Exiting!",/)
        CALL ABRTVB
      ENDIF
C
C     load basis set
C
      CALL LOADBAS(BASNAME,BASET,LCTBAS,LENBAS)
      IOUNIT=99
      OPEN(IOUNIT,FILE=SOURCEDAT,STATUS='UNKNOWN',ACCESS='SEQUENTIAL',
     $FORM='FORMATTED')
      WRITE(IOUNIT,1000)
      SCALING=1.0D0
      IF(KEYVALUES(3).EQ.1) SCALING = 1.0D0/0.529177249D0
      WRITE(IOUTVB,102)
 102  FORMAT(/' Cartesian coordinates of atoms in Angstrom'/
     &   ' ----------------------------------------------------'/
     &   '                    X             Y             Z   '/)
      DO I=1,NATOM
C
C     atomic units
C
        DO J=1,3
        XYZ(J,I)=XYZ(J,I)*SCALING
        END DO
C
C     symbol, xyz, basis set
C
      ATMCHG(I)=NATNUM(I)
      WRITE(IOUNIT,1100)SYMBOL,ATMCHG(I),(XYZ(J,I),J=1,3)
C
C     Angstrom
C
      DO J=1,3
        XYZ(J,I)=XYZ(J,I)*0.529177249D0
      END DO
      WRITE(IOUTVB,1110) ATMSYM(NATNUM(I)),ATMCHG(I),(XYZ(J,I),J=1,3)
      IF(LENBAS(NATNUM(I)).LE.0) THEN
      WRITE(IOUTVB,103) NATNUM(I)
 103  FORMAT(' No basis set for element ')
      STOP
      END IF
      DO J=LCTBAS(NATNUM(I)),LCTBAS(NATNUM(I))+LENBAS(NATNUM(I))-1
      WRITE(IOUNIT,1200)BASET(J)
      END DO
      WRITE(IOUNIT,104)
 104  FORMAT('END')
      END DO
      WRITE(IOUTVB,105)
 105  FORMAT(' ----------------------------------------------------'/)
      WRITE(IOUNIT,1300)
      CLOSE(IOUNIT)
 1000 FORMAT('TITLE'/'BASIS SET'/'CONVERGENCE 7'/'PRINT 3'/'ATOMS')
 1100 FORMAT(A10,F8.1,3F20.10)
 1110 FORMAT(1X,A2,3X,F5.1,3F14.6)
 1200 FORMAT(A80)
 1300 FORMAT('END'/'RUNTYP INTEGRAL'/'START'/'FINISH'/'  ')
      RETURN
      END
C
C     prepare vb input file for reactor run at geom xyztmp
C     iovbin: original vb input file
C     iotemp: reaction path file
C     ioengi: working file for vb calculation at geom xyztmp
C
      SUBROUTINE VBINPUT(IOVBIN,IOENGI,XYZTMP,NATNUM,NATOMS,
     &                   IGUESSREAD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 BUFF,KEYWORDS,COMMENTS,BLANK
      DIMENSION KEYWORDS(100)
      DIMENSION KEYLENS(100)
      DIMENSION XYZTMP(3,*),NATNUM(*)
      BLANK(1:40)  = '                                        '
      BLANK(41:80) = '                                        '
C     SYMBOL       = 'ATOM'
      ICURSOR      = 1
      LENBUF       = 80
C     iovbin       = 5
      ITOPIC       = 1
      NWORD        = 0
C     IOENGI       = 80
C     NOBIAS=0
C     LFROZN=0
C     LCIONLY=0
C     LPTALL=0
C     LHYBRD=0
C     IFLAG =0
C 000  IFLAG =1
C SMI  IFLAG =1
      REWIND(IOENGI)
      REWIND(IOVBIN)
C     call loctor(iovbin,'#!',2,iok,1)
      CALL LOCTOR2(IOVBIN,'#!',2,IOK,1,BUFF)
      IF(IOK.EQ.0) CALL ABORT0('NOKEYWORDS')
C     backspace(iovbin)
C     read(iovbin,'(A80)')buff
      WRITE(IOENGI,'(A80)') BUFF
      if(IGUESSREAD.GT.0) WRITE(IOENGI,*)'GUESS=READ'
C
C     A blank line to terminate keyword input
C
 100  READ(IOVBIN,'(A80)',END=110)BUFF
      CALL CONVCASE(BUFF,80,1)
      WRITE(IOENGI,'(A80)') BUFF
      ICURSOR=1
      CALL READWDS(BUFF,KEYWORDS(NWORD+1),KEYLENS(NWORD+1),
     &             ICURSOR,LENBUF,NEWWORD)
      NWORD = NWORD + NEWWORD
      IF(NEWWORD.GT.0) GOTO 100
 110  ITOPIC=ITOPIC+1
C
C     Go to the next topic: comments
C
      READ(IOVBIN,'(A80)') COMMENTS
      WRITE(IOENGI,'(A80)')comments
 200  READ(IOVBIN,'(A80)') BUFF
      WRITE(IOENGI,'(A80)') BUFF
      IF(BUFF.NE.BLANK.AND.COMMENTS.NE.BLANK) GOTO 200
C
C     Go to the next topic: charge and multiplicity
C
      ITOPIC=ITOPIC+1
      READ(IOVBIN,*) ICHARGE, MULTIPLICITY
      WRITE(IOENGI,*) ICHARGE, MULTIPLICITY
C
C     Go to the next topic: read Cartesian coordiantes
C
C     Skip Cartesian coordinates that follow Icharge and Multi
C
      ITOPIC=ITOPIC+1
      NATOM=0
 300  READ(IOVBIN,'(A80)')BUFF
      IF(BUFF(1:80).EQ.BLANK(1:80)) GOTO 400
      NATOM = NATOM +1
      GOTO 300
 400  ITOPIC=ITOPIC+1
      DO I=1, NATOMS
      WRITE(IOENGI,1000)NATNUM(I),XYZTMP(1,I),XYZTMP(2,I),XYZTMP(3,I)
      END DO
      WRITE(IOENGI,*)
 1000 FORMAT(I4,3F12.6)
 450  READ(IOVBIN,'(A80)',END=500,ERR=500)BUFF
      WRITE(IOENGI,'(A80)') BUFF
      GOTO 450
 500  CONTINUE
      RETURN
      END
      SUBROUTINE SETKEYVAL(NWORD,KEYWORDS,KEYNAMES,KEYVALUES)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*80 KEYWORDS,BASET,A,RESTFILE
      CHARACTER*80 KEYWORDS,A
      CHARACTER*20 KEYNAMES
      DIMENSION KEYWORDS(*),KEYNAMES(*),KEYVALUES(*)
C     character*12 BFLABE
C     character*20 BASNAME
C     COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
C    &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
     &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
     &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
C     SAVE method, m,n,ng.
      KEYNAMES(1) = 'METHOD'
      KEYNAMES(2) = 'BASIS SET'
      KEYNAMES(3) = 'UNITS'
C
C     Some option key words are loaded from this section and
C     the values are stored in the common block GENCTL. To
C     keep the compatability with other packages, a second way of
C     loading these parameters is provided in INPUTVB.
C
C
C     key-values
C
C     keyvalues(1) = 1: HF
C                  = 2: VB(m)
C                  = 3: SCVB(m)
C                  = 4: CASVB(m,n)
C     (for 2-4)         THE m HIGHEST ENERGY ELECTRONS ARE TREATED BY
C                       VB METHOD. IF A LMO IS A BONDING ORBITAL, SPLIT IT
C                       FOR CASVB(m,n), SPLIT THE HIGHEST (n-m/2) ORBITALS.
C                       (if n < m/2, error!)
C                  = 5: GPF(n)
C                       n GROUPS. BY DEFAULT, IT HAS n-1 GVB PAIRS.
C                       (n-1) HIGHEST BONDING ORBITALS. IF NO MORE THAN
C                       (n-1) BONDING LMOs, error!
C                  = 6: Dot notation of GPF. For instance
C                       VB(n1).CASVB(n2,m2).VB(n3)
C                       Where n_i is the number of electrons in the VB group i.
C                       By default, VB group i has n_i vb orbitals, unless
C                       the number of orbitals is explicitly declared as in
C                       CASVB(n2,m2). In this case, the number of orbitals
C                       is m2. The number of orbitals can be modified by
C                       input $GRPDIM, which list the numbers of VB orbitals
C                       in each group.
C
C     keyvalues(2) = 1: D95
C                  = 2: MIDIX
C                  = 3: STO-3G
C                  = 4: STO-4G
C                  = 5: STO-6G
C                  = 6: 3-21G
C                  = 7: 3-21G*
C                  = 8: 6-31G
C                  = 9: 6-31G* (6-31GSTAR)
C                  = 10: 6-31+G* (6-31PGSTAR)
C                  = 11: 6-31G** (6-31G2STAR)
C                  = 12: 6-31++G** (6-31PPG2STAR)
C                  = 13: cc-pVDZ
C                  = 14: AUG-cc-pVDZ
C                  = 15: TZVP
C
C     keyvalues(3) = 1: Angstrom
C                  = 2: Bohr
C
C     keyvalues(4) = 1: FROZEN HF PART
C                  = 0: (DEFAULT) OPTIMIZE HF PART
C
C     keyvalues(5) = 1: CIONLY
C                  = 0: (DEFAULT) OPTIMIZE VB ORBITALS
C
C     keyvalues(6) = 1: HYBRID GUESS
C                  = 0: (DEFAULT) DLMO GUESS
C
C     keyvalues(7) = 1: PRINT ALL
C                  = 0: (DEFAULT) MINIMUM PRINT MESSAGE
C
C     keyvalues(8) = 1: NOBIAS
C                  = 0: (DEFAULT) NO-BIAS OPTIMIZATION IS OFF
C
C     keyvalues(9) = 1: Restart calculation, skip integration and HF calc.
C                  = 0: (DEFAULT) New calculation, must do HF
C
C     keyvalues(10)= 1: GUESS=READ. Read initial guess from previous
C                    0: (DEFAULT), controled by keyvalues(9)
C
C     keyvalues(11)= 1: Turn off rigid rotation
C                    0: (DEFAULT), Perform rigid rotation
C
C     keyvalues(12)= 1: Do test run only, stopping after output of initial quess
C                    0: (DEFAULT), Do full run
C
C     keyvalues(13)= 1: Calculate spin-density of VB wave function for VB group
C                       with spin-multiplicity > 1.
C                    0: Do not calculate spin-density
C
C     keyvalues(14)= 1: DIIS for VB orbital optimization
C                    0: DIIS disabled
C
C     keyvalues(15)= 1: SPHERICAL HARMONIC BASIS FUNCTIONS ARE USED
C                    0: CARTESIAN AOs ARE USED
C
C     setup defaults
      KEYVALUES(3) = 1
      KEYVALUES(4) = 0
      KEYVALUES(5) = 0
      KEYVALUES(6) = 0
      KEYVALUES(7) = 0
      KEYVALUES(8) = 0
      KEYVALUES(9) = 0
      KEYVALUES(10)= 0
      KEYVALUES(11)= 0
      KEYVALUES(12)= 0
      KEYVALUES(13)= 0
      KEYVALUES(14)= 0
      KEYVALUES(15)= 0
      LFROZN  = 0
      LCIONLY = 0
      LHYBRD  = 0
      LPTALL  = 0
      NOBIAS  = 0
      LTEST   = 0
C
C     Search for 'UNITS=BOHR'. If found, set keyvalues(3)=2.
C
      A='UNITS=BOHR'
      LEN = 10
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.EQ.1) KEYVALUES(3)=2
C
C     Search for 'FROZEN'. If found, set keyvalues(4)=1.
C
      A='FROZEN'
      LEN = 6
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.EQ.1) THEN
      KEYVALUES(4)=1
      LFROZN=1
      END IF
C
C     Search for 'CIONLY'. If found, set keyvalues(5)=1.
C
      A='CIONLY'
      LEN = 6
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.EQ.1) THEN
      KEYVALUES(5)=1
      LCIONLY=1
      END IF
C
C     Search for 'HYBRID'. If found, set keyvalues(6)=1.
C
      A='HYBRID'
      LEN = 6
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.EQ.1) THEN
      KEYVALUES(6)=1
      LHYBRD=1
      END IF
C
C     Search for 'PRINTALL'. If found, set keyvalues(7)=1.
C
      A='PRINTALL'
      LEN = 8
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.EQ.1) THEN
      KEYVALUES(7)=1
      LPTALL=1
      END IF
C
C     Search for 'NOBIAS'. If found, set keyvalues(8)=1.
C
      A='NOBIAS'
      LEN = 6
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.EQ.1) THEN
      KEYVALUES(8)=1
      NOBIAS=1
      END IF
C
C     Search for 'RESTART'. If found, set keyvalues(9)=2.
C
      A='RESTART'
      LEN = 7
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.EQ.1) THEN
        KEYVALUES(9) =2
        IRESTART     =2
        KEYVALUES(10)=1
      END IF
C
C     Search for 'LMONLY'. If found, set keyvalues(9)=-1.
C     LMO Only
C
      A='LMONLY'
      LEN = 6
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.EQ.1) THEN
      KEYVALUES(9)=-1
      IRESTART=-1
      END IF
C
C     Search for 'GUESS=READ'. If found, set keyvalues(10)=1.
C
      A='GUESS=READ'
      LEN = 10
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.EQ.1) THEN
      KEYVALUES(10)=1
      KEYVALUES(9) =1
      IRESTART     =1
      END IF
C
C     Search for 'NOROT'. If found, set keyvalues(11)=1.
C
      MROT = 1
      A='NOROT'
      LEN = 5
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.EQ.1) THEN
      KEYVALUES(11)=1
      MROT=0
      END IF
C
C     Search for 'TEST'. If found, set keyvalues(12)=1.
C
      A='TEST'
      LEN = 4
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.GE.1) THEN
      KEYVALUES(12)=1
      LTEST = 1
      LPTALL = 1
      END IF
C
C     Search for 'SPDEN'. If found, set keyvalues(13)=1.
C
      A='SPDEN'
      LEN = 5
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.GE.1) THEN
      KEYVALUES(13)=1
      END IF
C
C     Search for 'DIIS'. If found, set keyvalues(14)=1.
C
      A='DIIS'
      LEN = 4
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.GE.1) THEN
      KEYVALUES(14)=1
      END IF
C
C     Search for 'SPHER'. If found, set keyvalues(15)=1.
C
      A='SPHER'
      LEN = 5
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.GE.1) THEN
      KEYVALUES(15)=1
      END IF
C
C     copy keyvalues to key
C
      DO I=1, 99
      KEY(I) = KEYVALUES(I)
      END DO
      RETURN
      END
      SUBROUTINE SEARCHFOR(STRING,LENSTR,KEYWORDS,NWORD,IFOUND)
      CHARACTER*80 KEYWORDS,A,B
      CHARACTER*1 STRING(*)
      DIMENSION KEYWORDS(*)
      DO I=1,LENSTR
      A(I:I)=STRING(I)
      END DO
      IFOUND = 0
      DO I=1,NWORD
      B = KEYWORDS(I)
      IF(A(1:LENSTR).EQ.B(1:LENSTR)) THEN
      IFOUND = 1
      END IF
      END DO
      RETURN
      END
      SUBROUTINE CONVCASE(STRING,LEN,ICASE)
      IMPLICIT NONE
      INTEGER ICASE,LEN,I,IC
      CHARACTER*(*) STRING
      CHARACTER*26 UCASE,LCASE
      DATA UCASE /'ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
      DATA LCASE /'abcdefghijklmnopqrstuvwxyz'/
C
C     ICASE = 1 lower --> upper
C     ICASE = 2 upper --> lower
      IF (ICASE.EQ.1) THEN
      DO I=1,LEN
         IC = INDEX(LCASE,STRING(I:I))
         IF (IC.GT.0) STRING(I:I) = UCASE(IC:IC)
      END DO
      RETURN
      ENDIF
      IF (ICASE.EQ.2) THEN
      DO I=1,LEN
         IC = INDEX(UCASE,STRING(I:I))
         IF (IC.GT.0) STRING(I:I) = LCASE(IC:IC)
      END DO
      RETURN
      ENDIF
      END
      SUBROUTINE LOADBAS(BASNAME,BASET,LCTBAS,LENBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 WORD,PATH,BASET,A,VBPATH,TPATH
      CHARACTER*20 BASNAME
      LOGICAL GOTPATH
      DIMENSION BASET(*),LCTBAS(*),LENBAS(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      PATH='BASET/'
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL GETVBPATH(VBPATH)
 1100 FORMAT(/
     &' The following basis sets are available:'//
     &' D95:         Double-zeta basis set'/
     &' MIDIX:       MIDI! basis set (Uni. of Minnesota)'/
     &' STO-3G:      STO-3G basis set'/
     &' STO-4G:      STO-4G basis set'/
     &' STO-6G:      STO-6G basis set'/
     &' 3-21G:       3-21G basis set'/
     &' 3-21G*:      3-21G* basis set'/
     &' 6-31G:       6-31G basis set'/
     &' 6-31G*:      6-31G* basis set'/
     &' 6-31G**:     6-31G** basis set'/
     &' 6-31+G*:     6-31+G* basis set'/
     &' 6-31++G**:   6-31++G** basis set'/
     &' cc-pVDZ:     cc-pVDZ basis set'/
     &' AUG-cc-pVDZ: AUG-cc-pVDZ basis set'/
     &' TZVP:        Triple-zeta valence + polarisation basis set'/
     &'              but only TZV for Sc - Zn'/
     &' GEN:         General basis set (provided by user)'/
     &' GENNG:       As GEN for general STO-nG, using VBOLIB'/)
C
C     built-in basis set
C
C     1.  D95
C     2.  MIDIX
C     3.  STO-3G
C     4.  STO-4G
C     5.  STO-6G
C     6.  3-21G
C     7.  3-21G*
C     8.  6-31G
C     9.  6-31G*
C     10. 6-31G**
C     11. 6-31+G*
C     12. 6-31++G**
C     13. cc-pVDZ
C     14. AUG-cc-pVDZ
C     15. TZVP
C     x.  gen
C     x.  genng
C
      CALL CONVCASE(BASNAME,20,1)
      IF(BASNAME.EQ.'D95') THEN
      PATH(7:9)='D95'
      K=9
      ELSE IF(BASNAME.EQ.'MIDIX'.OR.BASNAME.EQ.'MIDI!') THEN
      PATH(7:11)='MIDIX'
      K=11
      ELSE IF(BASNAME.EQ.'STO-3G') THEN
      PATH(7:12)='STO-3G'
      K=12
      ELSE IF(BASNAME.EQ.'STO-4G') THEN
      PATH(7:12)='STO-4G'
      K=12
      ELSE IF(BASNAME.EQ.'STO-6G') THEN
      PATH(7:12)='STO-6G'
      K=12
      ELSE IF(BASNAME.EQ.'3-21G') THEN
      PATH(7:11)='3-21G'
      K=11
      ELSE IF(BASNAME.EQ.'3-21G*'.OR.BASNAME.EQ.'3-21GSTAR') THEN
      PATH(7:15)='3-21GSTAR'
      BASNAME = '3-21GSTAR'
      K=15
      ELSE IF(BASNAME.EQ.'6-31G') THEN
      PATH(7:11)='6-31G'
      K=11
      ELSE IF(BASNAME.EQ.'6-31G*'.OR.BASNAME.EQ.'6-31GSTAR') THEN
      PATH(7:15)='6-31GSTAR'
      BASNAME = '6-31GSTAR'
      K=15
      ELSE IF(BASNAME.EQ.'6-31+G*'.OR.BASNAME.EQ.'6-31PGSTAR') THEN
      PATH(7:16)='6-31PGSTAR'
      BASNAME = '6-31PGSTAR'
      K=16
      ELSE IF(BASNAME.EQ.'6-31G**'.OR.BASNAME.EQ.'6-31G2STAR') THEN
      PATH(7:16)='6-31G2STAR'
      BASNAME = '6-31G2STAR'
      K=16
      ELSE IF(BASNAME.EQ.'6-31++G**'.OR.BASNAME.EQ.'6-31PPG2STAR') THEN
      PATH(7:18)='6-31PPG2STAR'
      BASNAME = '6-31PPG2STAR'
      K=18
      ELSE IF(BASNAME.EQ.'CC-PVDZ') THEN
      PATH(7:13)='cc-pVDZ'
      K=13
      ELSE IF(BASNAME.EQ.'AUG-CC-PVDZ') THEN
      PATH(7:17)='AUG-cc-pVDZ'
      K=17
      ELSE IF(BASNAME.EQ.'TZVP') THEN
      PATH(7:10)='TZVP'
      K=10
      ELSE IF(BASNAME.EQ.'GEN'.OR.BASNAME.EQ.'GENNG') THEN
      CALL LOCTOR(IOENGI,'&',1,IOK,0)
        IF(IOK.EQ.0) THEN
        WRITE(IOUTVB,*)
     &   ' Please provide the basis set file name with path'
        STOP
        END IF
      BACKSPACE(IOENGI)
      READ(IOENGI,'(A80)')A
      ICURSOR=1
      LENBUF=80
      CALL READWDM(A,WORD,LENW,ICURSOR,LENBUF)
      GOTPATH=.FALSE.
      IF (WORD(LENW-1:LENW) .EQ. '/N') THEN
         WORD(LENW-1:LENW) = '  '
         LENW=LENW-2
      ENDIF
      DO I=2,LENW
        IF (WORD(I:I) .EQ. '/') THEN
          GOTPATH=.TRUE.
          GOTO 99
        ENDIF
      ENDDO
 99   IF (GOTPATH) THEN
        PATH = ' '
        PATH(1:LENW-1)=WORD(2:LENW)
        LENW = LENW-1
        K=0
      ELSE
        K = LENW + 5
        PATH(7:K) = WORD(2:LENW)
      ENDIF
      ELSE
      WRITE(IOUTVB,103) BASNAME
 103  FORMAT(' Unknown basis set name: ',A20)
      WRITE(IOUTVB,1100)
      CALL ABRTVB
      END IF
      IF (K.EQ.0) THEN
        TPATH(1:LENW)=PATH(1:LENW)
        DO I=LENW+1,80
          TPATH(I:I) = ' '
        ENDDO
      ELSE
        CALL PATHST(TPATH,VBPATH,'/               ',PATH,K)
      ENDIF
      WRITE (*,102) TPATH
 102  FORMAT(/,' BASIS SET FILE IS: ',A80)
      IOUNIT=99
      OPEN(IOUNIT,FILE=TPATH,STATUS='OLD')
      NREC=1
  10  READ(IOUNIT,'(A80)',END=100,ERR=100)BASET(NREC)
      NREC=NREC+1
      GOTO 10
 100  NREC=NREC-1
      CLOSE(IOUNIT)
C
C     Scane baset, and set-up indexes
C
      IST=0
      DO I=1,NREC
      A= BASET(I)
C
C     CHECK FOR STARTING POINT
C
      IF(IST.EQ.0.AND.A(1:1).EQ.'-') THEN
      IST=1
      CALL LKELEM(A,NELEM)
      IF(NELEM.GT.0) LCTBAS(NELEM)=I+1
      ELSE IF(IST.EQ.1.AND.A(1:4).EQ.'****') THEN
      IST=0
      LENBAS(NELEM)=I-LCTBAS(NELEM)
      END IF
      END DO
      RETURN
      END
      SUBROUTINE LKELEM(STRING, NELEM)
      CHARACTER*5 STRING
      CHARACTER*2 ATMSYM(92)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     Note that this ATMSYM block is different from the normal one, as
C     one-letter elements are left-centered, not right-centered. It is
C     used only here.
      DATA ATMSYM/'H ','He','Li','Be','B ','C ','N ','O ','F ','Ne',
     1            'Na','Mg','Al','Si','P ','S ','Cl','Ar',
     2            'K ','Ca','Sc','Ti','V ','Cr','Mn','Fe','Co',
     3            'Ni','Cu','Zn','Ga','Ge','As','Se','Br','Kr','Rb',
     4 'Sr','Y ','Zr','Nb','Mo','Tc','Ru','Rh','Pd','Ag','Cd','In',
     5 'Sn','Sb','Te','I ','Xe','Cs','Ba','La','Ce','Pr','Nd','Pm',
     6 'Sm','Eu','Gd','Tb','Dy','Ho','Er','Tm','Yb','Lu','Hf','Ta',
     7 'W ','Re','Os','Ir','Pt','Au','Hg','Tl','Pb','Bi','Po','At',
     8 'Rn','Fr','Ra','Ac','Th','Pa','U '/
C
C     look-up for elements
C
      DO I=1,92
        IF(STRING(1:3).EQ.'-'//ATMSYM(I)) THEN
           NELEM=I
           GOTO 1
        ENDIF
      ENDDO
      WRITE(IOUTVB,2) STRING
 2    FORMAT(' Unknown element: ',A5)
      STOP
 1    RETURN
      END
      SUBROUTINE PARMTHD(STRING,LEN,MTHEORY,METHOD,NG,ICURSOR,
     &                   MORB,MELE)
C
C
C     Theory            Control parameters
C
C     1. HF             No.
C     2. VB             m    // VB(m), m=# of electrons in m orbitals
C     3. SCVB           m    // SCVB(m) m electrons in m orbitals.
C     4. CASVB          (m,n)// CASVB(m,n), m=# of electrons in n=# of orbs.
C     5. GPF            ng   // generalized product function method, ng group.
C     6. DOT            Dot notation of GPF.
C                       For instance VB(8).CASVB(6,6).VB(8)
C                       In dot notation, HF group is omitted.
C
C     Notes:            No space in the string, otherwise, the parsing will
C                       fail.
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*80 A,WORD
      CHARACTER*80 WORD
      CHARACTER*1 STRING(*)
      DIMENSION MORB(*),MELE(*),METHOD(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      LENW=0
      LENBUF=LEN
C
C     scane for dot (.) notation
C
      IDOT = 0
      DO 10 I=ICURSOR,LENBUF
      IF(STRING(I).EQ.'.') IDOT=IDOT+1
 10   CONTINUE
      IF(IDOT.GT.0) GOTO 200
      M=0
      N=0
      NG=1
      WORD = ' '
      CALL READWDM(STRING,WORD,LENW,ICURSOR,LENBUF)
      IF(WORD.EQ.'HF') THEN
      NELE = 0
      WRITE(IOUTVB,*)"TODO: Please check NELE will be corrected later"
      MORB(1) = (NELE+1)/2
      MELE(1) = NELE
      MTHEORY=1
      ELSE IF(WORD.EQ.'VB') THEN
      MTHEORY=2
      CALL READNUM(STRING,M,LENW,ICURSOR,LENBUF)
C     WRITE(IOUTVB,*)'VB(M)=',M
      N = M
        IF(M.LT.0) THEN
        WRITE(IOUTVB,*)"The number of electrons in a VB group must > 0"
        CALL ABORT0("PARATH0000")
        END IF
      ELSE IF(WORD.EQ.'SCVB') THEN
      MTHEORY=3
      CALL READNUM(STRING,M,LENW,ICURSOR,LENBUF)
C     WRITE(IOUTVB,*)'SCVB(M)=',M
      N = M
      ELSE IF(WORD.EQ.'SC') THEN
      MTHEORY=3
      CALL READNUM(STRING,M,LENW,ICURSOR,LENBUF)
      CALL READNUM(STRING,N,LENW,ICURSOR,LENBUF)
      IF(N.EQ.0) N = M
      ELSE IF(WORD.EQ.'CASVB') THEN
      MTHEORY=4
      CALL READNUM(STRING,M,LENW,ICURSOR,LENBUF)
      CALL READNUM(STRING,N,LENW,ICURSOR,LENBUF)
C     WRITE(IOUTVB,*)"M,N = ",M,N
      ELSE IF(WORD.EQ.'GPF') THEN
      MTHEORY=5
      CALL READNUM(STRING,NG,LENW,ICURSOR,LENBUF)
C     WRITE(IOUTVB,*)'GPF(N)=',NG
      ELSE
      WRITE(IOUTVB,*)' Unknown method'
      CALL ABORT0('PARMTH0001')
      END IF
      IF (1.LT.MTHEORY.AND.MTHEORY.LT.5) THEN
C
C       Assume there is a HF group. As the total number of electrons
C       is not available here, this should be verified later
C
        NG = 2
        MORB(1) = 0
        MELE(1) = 0
        METHOD(1) = 1
        MORB(2) = N
        MELE(2) = M
        METHOD(2) = MTHEORY
      END IF
      RETURN
 200  CONTINUE
C
C     parse dot notation
C
      MTHEORY=6
      METOTAL=0
      NG = IDOT+2
      DO K=1, IDOT+1
      M=0
      N=0
      WORD = ' '
      CALL READWDM(STRING,WORD,LENW,ICURSOR,LENBUF)
      IF(WORD.EQ.'VB') THEN
      MTHEO=2
      CALL READNUM(STRING,M,LENW,ICURSOR,LENBUF)
      N = M
C     skip ').'
      ICURSOR=ICURSOR+2
      ELSE IF(WORD.EQ.'SCVB') THEN
      MTHEO=3
      CALL READNUM(STRING,M,LENW,ICURSOR,LENBUF)
      N = M
C     skip ').'
      ICURSOR=ICURSOR+2
      ELSE IF(WORD.EQ.'SC') THEN
      MTHEO=3
      CALL READNUM(STRING,M,LENW,ICURSOR,LENBUF)
      CALL READNUM(STRING,N,LENW,ICURSOR,LENBUF)
      IF(N.EQ.0) N = M
C     skip ').'
      ICURSOR=ICURSOR+2
      ELSE IF(WORD.EQ.'CASVB') THEN
      MTHEO=4
      CALL READNUM(STRING,M,LENW,ICURSOR,LENBUF)
      CALL READNUM(STRING,N,LENW,ICURSOR,LENBUF)
      WRITE(IOUTVB,*)"M,N= ",M,N
C     skip ').'
      ICURSOR=ICURSOR+2
      ELSE
      WRITE(IOUTVB,*)
     & 'Error in dot notation. No space is allowed in keywords'
      WRITE(IOUTVB,*)'WORD=',WORD
      CALL ABORT0('PARMTH0002')
      END IF
      METOTAL=METOTAL+M
      MELE(K+1)=M
      MORB(K+1)=N
      METHOD(K+1) = MTHEO
      END DO
      RETURN
      END
      SUBROUTINE READNUM(STRING,NUMBER,LEN,ICURSOR,LENBUF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*80 A
      CHARACTER*1 STRING(*)
      LEN=0
      IST=0
      NUMBER=0
      DO 100 I=ICURSOR,LENBUF
      ITEMP=ISNUMBER(STRING(I))
      IF(IST.EQ.0.AND.(ITEMP.GE.0)) THEN
      NUMBER=ISNUMBER(STRING(I))
      IST=1
      LEN=1
      ELSE IF(IST.EQ.1.AND.(ITEMP.GE.0)) THEN
      LEN=LEN+1
      NUMBER = NUMBER*10 + ISNUMBER(STRING(I))
      ELSE IF(IST.EQ.1.AND.(ITEMP.LT.0)) THEN
      ICURSOR=I
      RETURN
      END IF
 100  CONTINUE
      ICURSOR=LENBUF
      END
      FUNCTION ISNUMBER(CHAR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*1 CHAR
      CHARACTER*10 NUMBER
      NUMBER   = '1234567890'
      ISNUMBER = -1
      DO I=1,10
      IF(CHAR.EQ.NUMBER(I:I)) THEN
      ISNUMBER = I
      IF(I.EQ.10) ISNUMBER=0
      RETURN
      END IF
      END DO
      END
      SUBROUTINE READWDM(STRING,WORD,LEN,ICURSOR,LENBUF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*80 A
      CHARACTER*1 WORD(*),STRING(*)
      LEN=0
      IST=0
      DO 100 I=ICURSOR,LENBUF
      IF(IST.EQ.0.AND.(STRING(I).NE.' '.AND.STRING(I).NE.'(')) THEN
      WORD(1)=STRING(I)
      IST=1
      LEN=1
      ELSE IF(IST.EQ.1.AND.(STRING(I).NE.' '.AND.STRING(I).NE.'('))
     & THEN
      LEN=LEN+1
      WORD(LEN)=STRING(I)
      ELSE IF(IST.EQ.1.AND.(STRING(I).EQ.' '.OR.STRING(I).EQ.'('))
     & THEN
      ICURSOR=I
      RETURN
      END IF
 100  CONTINUE
      ICURSOR=LENBUF
      END
      SUBROUTINE READWDS(BUFF,WORDS,LENS,ICURSOR,LENBUF,NWORD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*80 A,WORDS,BUFF
      CHARACTER*80 WORDS,BUFF
      DIMENSION WORDS(*),LENS(*)
      NWORD=0
 100  NWORD= NWORD+1
      WORDS(NWORD) = ' '
      CALL READWD(BUFF,WORDS(NWORD),LENS(NWORD),ICURSOR,LENBUF)
      IF(ICURSOR.LT.LENBUF.AND.LENS(NWORD).GT.0) GOTO 100
      IF(LENS(NWORD).LE.0) NWORD=NWORD-1
      RETURN
      END
      SUBROUTINE READWD(STRING,WORD,LEN,ICURSOR,LENBUF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*80 A
      CHARACTER*1 WORD(*),STRING(*)
      LEN=0
      IST=0
      DO 100 I=ICURSOR,LENBUF
      IF(IST.EQ.0.AND.STRING(I).NE.' ') THEN
      WORD(1)=STRING(I)
      IST=1
      LEN=1
      ELSE IF(IST.EQ.1.AND.STRING(I).NE.' ') THEN
      LEN=LEN+1
      WORD(LEN)=STRING(I)
      ELSE IF(IST.EQ.1.AND.STRING(I).EQ.' ') THEN
      ICURSOR=I
      RETURN
      END IF
 100  CONTINUE
      ICURSOR=LENBUF
      END
      SUBROUTINE VBOLGN(NATOM,NBASIS,NATNUM,XYZ,NATBAS,BFLABE,
     &                  BASIS,IOENGI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE(*)
      DIMENSION NATNUM(*),NATBAS(*),BASIS(NBASIS,*),XYZ(3,*)
C
C     IOPTION = 1: OUTPUT VBO FROM FINAL RESULTS
C
      IOPTION = 1
      CALL VBOLGNY(NATOM,NBASIS,NATNUM,XYZ,NATBAS,BFLABE,
     &                  BASIS,IOENGI,IOPTION)
      RETURN
      END
      SUBROUTINE LMOLGN(NATOM,NBASIS,NATNUM,XYZ,NATBAS,BFLABE,
     &                  BASIS,IOENGI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE(*)
      DIMENSION NATNUM(*),NATBAS(*),BASIS(NBASIS,*),XYZ(3,*)
C
C     IOPTION = 2: OUTPUT VBO FROM LMO OF HFSCF
C
      IOPTION = 2
      CALL VBOLGNY(NATOM,NBASIS,NATNUM,XYZ,NATBAS,BFLABE,
     &                  BASIS,IOENGI,IOPTION)
      RETURN
      END
C
C     SIMPLE VERSION
C
      SUBROUTINE VBOLGNY(NATOM,NBASIS,NATNUM,XYZ,NATBAS,BFLABE,
     &                  BASIS,IOENGI,IOPTION)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE(*)
      CHARACTER*80 VBONAME,BLANK,BUFF
C     DIMENSION NATNUM(*),NATBAS(*),BASIS(NBASIS,*),NABS(100)
      DIMENSION NATNUM(*),NATBAS(*),BASIS(NBASIS,*)
C     DIMENSION V1(3),V2(3),XYZ(3,*),NFA(100),LFA(100),NABSS(1000)
      DIMENSION V1(3),XYZ(3,*),NFA(100),LFA(100),NABSS(1000)
      BLANK(1:40)  = '                                        '
      BLANK(41:80) = '                                        '
      NABSS(1) = 1
      DO I=2, NATOM
      NABSS(I) = NABSS(I-1) + NATBAS(I-1)
      END DO
      NABSS(NATOM+1) = NABSS(NATOM) + NATBAS(NATOM)
C
C     CHECK $VBOLIBGEN
C
      CALL GETIOUNIT('IOVBOLIB',IOVBOLIB)
      IF(IOPTION.EQ.1) THEN
         CALL LOCTOR(IOENGI,'$VBOLIBGEN',10,IOK,0)
      ELSE
         CALL LOCTOR(IOENGI,'$LMOLIBGEN',10,IOK,0)
      END IF
      IF(IOK.EQ.0) RETURN
  10  READ(IOENGI,'(A80)',END=100,ERR=100)BUFF
      IF(BUFF(1:80).EQ.BLANK(1:80)) GOTO 100
      READ(BUFF(1:80),*, END=100,ERR=100)VBONAME, NEOCC
      IF(IOPTION.EQ.2.AND.NEOCC.NE.2) CALL ABORT0('VBOLGNY01 ')
      IF(VBONAME.EQ.BLANK) GOTO 100
C     READ(IOENGI,*)NFATOM
      NFATOM = 1
      READ(IOENGI,*)NAT1,NAT2
      NFA(1)=NAT1
      LFA(1)=0
      READ(IOENGI,*)NVBO
      IF(NAT2.EQ.0) THEN
        READ(IOENGI,*)(V1(I),I=1,3)
      ELSE
        V1(1) = XYZ(1,NAT2) - XYZ(1,NAT1)
        V1(2) = XYZ(2,NAT2) - XYZ(2,NAT1)
        V1(3) = XYZ(3,NAT2) - XYZ(3,NAT1)
      END IF
C
C     OUTPUT OF VBOLIB
C
      WRITE(IOVBOLIB,'(1X,A20,I5)')VBONAME,NEOCC
      WRITE(IOVBOLIB,'(I3)')NFATOM
      DO I=1, NFATOM
      WRITE(IOVBOLIB,1000)NATNUM(NFA(I)),(XYZ(J,NFA(I)),J=1,3),LFA(I)
      END DO
      WRITE(IOVBOLIB,*)
      WRITE(IOVBOLIB,'(I3)')NFATOM
      WRITE(IOVBOLIB,'(20I3)')(I,I=1,NFATOM)
      WRITE(IOVBOLIB,'(20I3)')(NATBAS(NFA(I)),I=1,NFATOM)
      SIGNMAX = 1.0D0
      CMAXX   = 0.0D0
      JJ = 0
      DO I=1, NFATOM
         II = NFA(I)
         DO J=NABSS(II), NABSS(II+1)-1
         JJ = JJ + 1
         IF(CMAXX.LT.DABS(BASIS(J,NVBO))) THEN
            CMAXX = ABS(BASIS(J,NVBO))
            SIGNMAX = BASIS(J,NVBO)/CMAXX
         END IF
C
C        ZERO SMALL NUMBERS, WHICH COULD BE NON-SYMMETRIC NOISE
C
           CABS = ABS(BASIS(J,NVBO))
           IF(CABS.LT.0.002D0) BASIS(J,NVBO) =0.0D0
         END DO
      END DO
C
      JJ = 0
      DO I=1, NFATOM
         II = NFA(I)
         DO J=NABSS(II), NABSS(II+1)-1
         JJ = JJ + 1
         WRITE(IOVBOLIB,'(I4,A12,F10.5)')
     &                     JJ,BFLABE(J),BASIS(J,NVBO)*SIGNMAX
         END DO
      END DO
      WRITE(IOVBOLIB,*)
      CALL VECNORM(V1,IFLAG)
      WRITE(IOVBOLIB,'(3F10.5)')(V1(J),J=1,3)
      WRITE(IOVBOLIB,*)
      GOTO 10
 100  CONTINUE
 1000 FORMAT(I3,3F10.5,I5)
      RETURN
      END
C19219CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     END OF CORE VB20000
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE HFSCF(NE,NS,S,H,C,F,P,PW,W,NDIM,IOHFORB,ITMAX,
     &                 ENERGY,ER,E,BFLABE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE(*),DUMMY
C     CHARACTER*64 FSTR,RWFFILE,INTFILE,INPFILE,LOCFILE,FILE
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE,FILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     PARAMETER (EPS=0.00001D0,NDSQ=10000)
      PARAMETER (EPS=0.00001D0)
      DIMENSION S(*),H(*),C(NDIM,NDIM),OCC(5000)
      DIMENSION P(*),F(*),PW(*),W(*),E(*)
      DUMMY='            '
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      DAMP=0.7D0
      EOLD=0.0D0
C     IRDORB=0
      NOCC5V = (NE+NS)/2 + 5
      IF(NOCC5V .GT. NDIM) NOCC5V = NDIM
      NDIMSQ=NDIM*(NDIM+1)/2
      DO I=1,NDIM
      DO J=1,NDIM
      IJ = (I-1)*NDIM + J
      C(I,J)=0.0D0
      END DO
      END DO
      AE=DFLOAT(NE)/NDIM
      DO I=1,NDIMSQ
      P(I)=0.0D0
      END DO
      DO I=1,NDIM
      II=I*(I+1)/2
      P(II)=AE
      END DO
      NDOCC = (NE - NS)/2
      NSOCC = NS
      NOCC  = NDOCC + NSOCC
      DO I=1,NDOCC
      OCC(I)=2.0D0
      END DO
      DO I=NDOCC+1,NDOCC+NSOCC
      OCC(I)=1.0D0
      END DO
      DO I=NDOCC+NSOCC+1,NDIM
      OCC(I)=0.0D0
      END DO
C
C     Modify occupation number
C
      CALL LOCTOR(IOENGI,'$HFSCF',6,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*)NOCC
      READ(IOENGI,*)NOCCMD,(K,OCC(K),I=1,NOCCMD)
      END IF
      ITER=0
      NDIMSQ=NDIM*(NDIM+1)/2
C
C     DENSITY MATRIX
C
 100  CONTINUE
      ITER=ITER+1
      ENERGY=ER
      SUME=0.0D0
      IF(ITER.EQ.1) GOTO 101
      DO I=1,NDIMSQ
      P(I)=0.0D0
      END DO
      DO K=1,NOCC
      DO I=1,NDIM
      II=I*(I-1)/2
      DO J=1,I
      IJ=II+J
      P(IJ)=P(IJ)+OCC(K)*C(I,K)*C(J,K)
      END DO
      END DO
      END DO
 101  CONTINUE
C
C     CHECK DENSITY
C
      DMAX=0.0D0
      DO I=1,NDIMSQ
      IF(DABS(P(I)-PW(I)).GT.DMAX) DMAX=DABS(P(I)-PW(I))
      IF(ITER.GT.1) P(I)=PW(I)+DAMP*(P(I)-PW(I))
      END DO
C     WRITE(IOUTVB,*)'ITER,DMAX =',ITER,DMAX
C
C     FOCK MATRIX
C
      CALL FKENGI(F,P,NDIM,1)
      DO I=1, NDIMSQ
      F(I) = F(I) + H(I)
      END DO
C
C     CALCULATE ENERGY
C
      DO I=1,NDIMSQ
      ENERGY=ENERGY+P(I)*(H(I)+F(I))
      SUME=SUME+P(I)*S(I)
      END DO
      DO I=1,NDIM
      II=I*(I+1)/2
      ENERGY=ENERGY-5.0D-1*P(II)*(H(II)+F(II))
      SUME=SUME-5.0D-1*P(II)*S(II)
      END DO
      EDIFF=ENERGY-EOLD
      EOLD=ENERGY
      IF(EDIFF.GT.0.0D0) DAMP=DAMP*0.70D0
      IF(EDIFF.LT.0.0D0) DAMP=DAMP/0.95D0
      IF(DAMP.GT.1.0D0) DAMP=1.0D0
C     WRITE(IOUTVB,'(" HF ENERGY",I5,F20.12)')ITER,ENERGY
      IF((DMAX.LT.EPS.OR.ITER.GT.ITMAX).AND.ITER.GT.1) GOTO 200
      IF(ITER.GE.ITMAX.AND.DMAX.GT.EPS)
     $WRITE(IOUTVB,*)'UNCONVERGED AFTER',ITER,'ITERATIONS'
      IJ=0
      DO I=1,NDIM
      DO J=1,NDIM
      IJ=IJ+1
      W(IJ)=F(IJ00(I,J))
      PW(IJ)=S(IJ00(I,J))
      END DO
      END DO
      NWK=NDIM*NDIM+1
      CALL EG(NDIM,W,PW,E,C,W(NWK))
      DO I=1,NDIMSQ
      PW(I)=P(I)
      END DO
      GOTO 100
 200  CONTINUE
      WRITE(IOUTVB,102) ITER,DMAX
 102  FORMAT(' Number of iter =    ',I3,', DMAX =  ',F20.12)
      WRITE(IOUTVB,103) ENERGY
 103  FORMAT(' Final Hartree-Fock Energy =',4X,F22.12)
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(3)
      OPEN(UNIT=IOHFORB,FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      REWIND(IOHFORB)
      WRITE(IOHFORB)NDIM,(2,I=1,NDIM)
      WRITE(IOHFORB)(E(J),J=1,NDIM)
      WRITE(IOHFORB)((C(J,I),J=1,NDIM),I=1,NDIM)
      CLOSE(IOHFORB)
C
C     ONLY PRINT OCCUPIDED ORBTALS + 5 Virtual orbitals
C
      CALL MPRINT(C,E,NDIM,NOCC5V,4,BFLABE,DUMMY)
      RETURN
      END
      SUBROUTINE FKENGI(F,DEN,NDIM,NFK)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Fock Engine for computing Fock matrices of multiple groups
C
C     Notes:    F (Fock matrices), DEN (Density matrices), NDIM (Dimension)
C               NFK (Number of groups)
C
C     History:
C               First created in March 2004
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
CGMS  COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      DIMENSION F(*),DEN(*)
      DIMENSION II(100000),JJ(100000),KK(100000),LL(100000)
      DIMENSION GG(100000)
      COMMON /IAA/IA(100000)
      CALL GETIOUNIT('IAO2E   ',IAO2E)
C000  REWIND(IAO2E)
CSMI  REWIND(10)
CSMI  REWIND(11)
CGMS  REWIND(IS)
      IF(NDIM.GT.2000) CALL ABORT0("FKENGI0001")
      NDSQ = NDIM*(NDIM+1)/2
      DO I=1, NDSQ*NFK
      F(I) = 0.0D0
      END DO
      NREC = 0
 10   CONTINUE
      CALL IJKLGG(IAO2E,GG,II,JJ,KK,LL,NINT)
      NREC = NREC + 1
C
C     TODO: INDEX REORDERING CAN BE SKIPPED
C
      DO MM= 1, NINT
      I = II(MM)
      J = JJ(MM)
      K = KK(MM)
      L = LL(MM)
      VAL = GG(MM)
      IF (I.GE.J) GOTO 100
      N = I
      I = J
      J = N
  100 IF (K.GE.L) GOTO 120
      N = K
      K = L
      L = N
  120 IF(I.GT.K) GOTO 180
      IF(I.EQ.K) GOTO 160
  140 N = I
      I = K
      K = N
      N = J
      J = L
      L = N
      GOTO 180
  160 IF(J.LT.L) GOTO 140
  180 CONTINUE
C
      IF(I.EQ.J) VAL = VAL*0.5D0
      IF(K.EQ.L) VAL = VAL*0.5D0
      IF(I.EQ.K.AND.J.EQ.L) VAL = VAL*0.5D0
      NIJ = IA(I) + J
      NKL = IA(K) + L
      NIK = IA(I) + K
      NIL = IA(I) + L
      NJK = IA(J) + K
      NJL = IA(J) + L
      IF(J.LT.K) NJK = IA(K) + J
      IF(J.LT.L) NJL = IA(L) + J
      VAL2   = VAL + VAL
      VAL4   = VAL2 + VAL2
        DO K=1, NFK
        K2 = (K-1)*NDSQ
        NIJK2 = NIJ+K2
        NKLK2 = NKL+K2
        NIKK2 = NIK+K2
        NILK2 = NIL+K2
        NJKK2 = NJK+K2
        NJLK2 = NJL+K2
C
        F(NIJK2) = F(NIJK2) + VAL4*DEN(NKLK2)
        F(NKLK2) = F(NKLK2) + VAL4*DEN(NIJK2)
        F(NIKK2) = F(NIKK2) - VAL*DEN(NJLK2)
        F(NILK2) = F(NILK2) - VAL*DEN(NJKK2)
        F(NJKK2) = F(NJKK2) - VAL*DEN(NILK2)
        F(NJLK2) = F(NJLK2) - VAL*DEN(NIKK2)
        END DO
      END DO
      IF(NINT.NE.0) GOTO 10
CGMS  REWIND(IS)
C200  CONTINUE
      DO I=1, NDSQ*NFK
      F(I) = F(I)*0.5D0
      END DO
      DO I=1, NDIM
      I2 = I*(I+1)/2
        DO K=1, NFK
        K2 = (K-1)*NDSQ
        F(I2+K2) = F(I2+K2) + F(I2+K2)
        END DO
      END DO
      RETURN
      END
C
      SUBROUTINE HYBRIDS(SS,R,U,S,P,BIGU,SM,SP,W,NATOMS,NATBAS,
     1 NBASIS)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION U(NBASIS,*),S(NBASIS,*),E(1000),R(NBASIS,*),
     1 P(NBASIS,*),BIGU(NBASIS,*),SS(NBASIS,*),SM(NBASIS,*),
     1 SP(NBASIS,*),NATBAS(*),W(*)
      DIMENSION MAT(1000),NOCC(1000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     DATA ZERO,ONE,TWO,HALF/0.0D 00,1.0D 00,2.0D 00,0.5D 00/
      DATA ZERO,TWO,HALF/0.0D 00,2.0D 00,0.5D 00/
      CALL GETIOUNIT('IOTEMP  ',IOTEMP)
C     LLLL=LADDRS(U)
C     WRITE(IOUTVB,*) 'U in HYBRIDS',LLLL
      WRITE(IOTEMP,*)'U matrix is '
      CALL MATREC(U,NBASIS,NBASIS,NBASIS)
      NWK1 = 1
      NWK2 = NWK1 + NBASIS*NBASIS
      NWK3 = NWK2 + NBASIS*NBASIS
      NWK4 = NWK3 + NBASIS*NBASIS
      NWK5 = NWK4 + NBASIS*NBASIS
      NWK6 = NWK5 + NBASIS*NBASIS
      NWK7 = NWK6 + NBASIS*NBASIS
      NWK8 = NWK7 + NBASIS*NBASIS
C     NWK9 = NWK8 + NBASIS*NBASIS
C     NWK0 = NWK9 + NBASIS*NBASIS
      NAT  = NATOMS
      MBAS = NBASIS
      DO I=1, NATOMS
      MAT(I)=NATBAS(I)
      END DO
  103 FORMAT(10f7.3)
C     INTEGRAL INPUT FOR FULL BASIS SET
      MB=MBAS
      NORB=0
      DO NA=1,NAT
      NOCC(NA)=0
      ENDDO
C
C     S**(-1/2)->SM
C
      DO 1 I=1,MB
      DO 1 J=1,MB
      SM(I,J)=SS(I,J)
      U(I,J)=ZERO
    1 CONTINUE
      CALL SMINX(SM,U,E,MB,MB,HALF)
C     FROM NOW ON SM HOLDS S MINUS HALF
      DO 10 I=1,MB
      DO 10 J=1,MB
 10   S(J,I)=SS(J,I)
C------------------------------------------
C     REFER DM TO ORTHOG BASIS AND PUT IN P
      EXP=-HALF
      WRITE(IOUTVB,*)'SMINX matrix is '
      CALL SMINX(S,U,E,MB,MB,EXP)
      WRITE(IOUTVB,*)'after SMINX '
C     S replaced by S**half
      WRITE(IOTEMP,*)'S matrix is '
      CALL MATREC(S,MB,MB,MB)
      WRITE(IOTEMP,*)'R matrix is '
      CALL MATREC(R,MB,MB,MB)
      CALL HTRAN(R,S,E,MB,MB)
      WRITE(IOTEMP,*)'R matrix is '
      CALL MATREC(R,MB,MB,MB)
      DO 12 J=1,MB
      DO 12 I=1,MB
      SP(I,J)=S(I,J)
   12 P(J,I)=TWO*R(J,I)
      WRITE(IOTEMP,*)'P matrix is '
      WRITE(IOUTVB,*)'P matrix is '
      CALL MATREC(P,MB,MB,MB)
      TR=ZERO
      DO I=1,MB
      TR=TR+P(I,I)
      ENDDO
      WRITE(IOTEMP,105)TR
  105 FORMAT('Trace of whole dm =',f12.8)
      WRITE(IOTEMP,*)'Call LOCALIZE to get local nat orbs'

C     GO TO 29 for testing scf

      WRITE(IOUTVB,*)'CALL LOC'
      CALL LOCALIZE(MB,NORB,P,U,BIGU,W(NWK1),W(NWK2),W(NWK3),
     &  W(NWK4),W(NWK5),W(NWK6),W(NWK7),W(NWK8),NAT,MAT,NOCC)
      WRITE(IOUTVB,*)'CALL SIN'
      WRITE(IOTEMP,*) 'Call SINGVAL to get conventional ',
     & '(directed) hybrids'
      CALL SINGVAL(MB,P,U,BIGU,W(NWK1),W(NWK2),W(NWK3),
     &  W(NWK4),W(NWK5),W(NWK6),W(NWK7),W(NWK8),NAT,MAT,NOCC)
      WRITE(IOUTVB,*)'AFTERCALL SIN'
      WRITE(IOTEMP,*)'MATRIX BIGU, FOR GLOBAL BASIS TO HYBRIDS, IS:'
      NB=NORB
C     BSD - This is needed to flush FIL.LOC in case of error.
CGMS  CALL FLSHBF(98)
      CALL MATREC(BIGU,MB,NB,MB)
C     Now refer UDAG to raw AO basis
      DO I=1,MB
      DO J=1,MB
      S(J,I)=SM(J,I)
      ENDDO
      ENDDO
      DO I=1,MB
      DO J=1,NB
      U(I,J)=ZERO
      DO K=1,MB
      U(I,J)=U(I,J)+S(I,K)*BIGU(K,J)
      ENDDO
      ENDDO
      ENDDO

      DO I=1,MB
      DO J=1,MB
      R(J,I)=SS(J,I)
      ENDDO
      ENDDO
C     Full basis metric in R

      DO I=1,NB
      DO J=1,NB
      S(I,J)=ZERO
      DO K=1,MB
      DO L=1,MB
      S(I,J)=S(I,J)+U(K,I)*R(K,L)*U(L,J)
      ENDDO
      ENDDO
      ENDDO
      ENDDO
      WRITE(IOTEMP,*)'S for cols of bigu is -'
      DO J=1,NB
      WRITE(IOTEMP,103)(S(I,J),I=1,NB)
      ENDDO
      CALL SMINX(S,R,E,NB,MB,-HALF)
      DO I=1,MB
      DO J=1,NB
      BIGU(I,J)=ZERO
      DO K=1,NB
      BIGU(I,J)=BIGU(I,J)+U(I,K)*S(K,J)
      ENDDO
      ENDDO
      ENDDO

C     Put final U matrix, cols now orthonorm, into FIL.LOC
      WRITE(IOTEMP,*)'Referred to raw AOs, BIGU becomes -'
      DO J=1,NB
      WRITE(IOTEMP,103)(BIGU(I,J),I=1,MB)
      ENDDO
C  29 continue
      RETURN
      END

      SUBROUTINE LOCALIZE(MB,NORB,P,U,BIGU,D,S,PNEW,U1,U2,D1,D2,
     & P12,NAT,MAT,NOCC)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION P(MB,*),D(MB,*),S(MB,*),U(MB,*),E(1000),COL(1000)
C     DIMENSION PNEW(MB,*),BIGU(MB,*),SS(MB,*)
      DIMENSION PNEW(MB,*),BIGU(MB,*)
      DIMENSION U1(MB,*),U2(MB,*),D1(MB,*),D2(MB,*),P12(MB,*)
      DIMENSION MAT(*),NOCC(*)
      COMMON/INDICES/ KCLP(1000),KVAL(1000),MSTRT(1000),NSTRT(1000)
C     DATA ZERO,ONE,TWO,HALF,THRESH/0.0D 00,1.0D 00,2.0D 00,0.5D 00,
C    1 0.3D 00 /
      DATA ZERO,THRESH/0.0D 00,0.3D 00 /
      CALL GETIOUNIT('IOTEMP  ',IOTEMP)
CALIZE
      MSTRT(1)=1
      NA=1
      IF(NA.EQ.1) MSTRT(NA)=1
      DO NA=2,NAT
      MSTRT(NA)=MSTRT(NA-1)+MAT(NA-1)
      ENDDO
C     MSTRT(NA) NOW HOLDS START INDEX FOR BASIS FNS ON ATOM NA
C     WRITE(98,*)'Start indices, for bfs, are - '
C     WRITE(98,100)(MSTRT(NA),NA=1,NAT)
  100 FORMAT(10i6)
      DO J=1,MB
      DO I=1,MB
      BIGU(I,J)=ZERO
      ENDDO
      ENDDO
C     DO 20 NA=1,NAT
      DO 20 NA=1,NAT
      MM=MAT(NA)
      DO 3 J=1,MM
      DO 3 I=1,MM
      I1=MSTRT(NA)+I-1
      J1=MSTRT(NA)+J-1
      D(I,J)=P(I1,J1)
      S(I,J)=D(I,J)
    3 P(I1,J1)=ZERO
C     WRITE(98,201)NA
C 201 FORMAT('dmat for atom', I3)
C     do i=1,mm
C     WRITE(98,101)(D(I,J),J=1,MM)
C     enddo
C     DIAG BLOCK OF P COPIED INTO D - FOR each ATOM NA - COPY IN S
      CALL DIAGX(S,U,E,MM,MB)
      CALL ORDIN(S,U,E,MM,MB)
C     WRITE(98,203)NA
C 203 FORMAT(1H ,'eigenpops for atom',I3,1X,'are')
C     WRITE(98,99)(E(I),I=1,MM)
C  99 FORMAT(10F10.6)
C----------------------- counting routine -----------------------
C     NOCC(NA)=0 (in common block)
C     mclp=0
      KC=0
      KV=0
      DO I=1,MM
      IF(E(I).GE.(1.8D 00))THEN
         KC=KC+1
C        mclp=mclp+1
         KCLP(NA)=I
      ELSE
       IF(E(I).GE.THRESH)THEN
          KV=KV+1
          KVAL(NA)=I
        ENDIF
      ENDIF
      ENDDO
      WRITE(IOTEMP,137) NA,KCLP(NA)
  137 FORMAT('On atom ',I2,1X, 'there are',I2,1X,'core and lp orbitals')
      WRITE(IOTEMP,138) KV
  138 FORMAT('and',I2,1X,'valence orbitals')
      NOCC(NA)=NOCC(NA)+KC+KV
      NORB=NORB+NOCC(NA)
C     -----------------------------
      NSTRT(1)=1
      NAA=1
      IF(NAA.EQ.1) NSTRT(NAA)=1
      DO NAA=2,NAT
      NSTRT(NAA)=NSTRT(NAA-1)+NOCC(NAA-1)
      ENDDO
C     NSTRT(NA) NOW HOLDS START INDEX FOR ORBS ON ATOM NA
C-------------------------------------------------------------------
      WRITE(IOTEMP,*)'Orbitals (same order) are in cols of matrix below'
      NN=NOCC(NA)
      DO I=1,MM
      WRITE(IOTEMP,101)(U(I,J),J=1,NN)
      ENDDO
C     EV'S HERE ARE IN DESCENDING ORDER
C     RECTANGULAR U HOLDS NAT HYBRIDS (COLS IN SAME ORDER)
      CALL HTRAN1(D,U,COL,MM,NN,MB)
C     WRITE(98,207)NA
C 207 FORMAT(1H ,'UDAG*D*U for atom', I3)
  101 FORMAT(10F7.3)
      DO 6 I=1,NN
      DO 6 J=1,NN
      I1=NSTRT(NA)+I-1
      J1=NSTRT(NA)+J-1
    6 PNEW(I1,J1)=D(I,J)
      DO 7 I=1,MM
      DO 7 J=1,NN
      I1=MSTRT(NA)+I-1
      J1=NSTRT(NA)+J-1
    7 BIGU(I1,J1)=U(I,J)
C     BLOCKS OF PNEW AND BIGU ARE ACCUMULATING (also nocc and norb)
C     NSTRT(NA) NOW HOLDS START INDEX FOR ORBS ON ATOM NA
   20 CONTINUE
      NB=NORB
      WRITE(IOTEMP,*)'Block-diag form of new P is'
      CALL MATREC(PNEW,NB,NB,MB)
      WRITE(IOTEMP,*)'- and of BIGU is'
      CALL MATREC(BIGU,MB,NB,MB)

C     DIAG BLOCKS OF P NOW CONTAIN NAT POPS,
C     THOSE OF U CONTAIN NAT AOs
C     OPEN LOOPS (NA1,NA2) TO WORK ON OFF-DIAG BLOCKS
C     WRITE(98,*)'Open loop 30, for off-diag blocks'
      DO 30 NA1=1,NAT
      MM1=MAT(NA1)
      NN1=NOCC(NA1)
      DO 8 I=1,MM1
      DO 8 J=1,NN1
      I1=MSTRT(NA1)+I-1
      J1=NSTRT(NA1)+J-1
    8 U1(I,J)=BIGU(I1,J1)
C     WRITE(98,*)'Open loop 31, for second atom'
      DO 31 NA2=1,NAT
      IF(NA2.LE.NA1)GO TO 31
      IF(NA1.EQ.NAT)GO TO 30
      MM2=MAT(NA2)
      NN2=NOCC(NA2)
      DO 9 I=1,MM2
      DO 9 J=1,NN2
      I2=MSTRT(NA2)+I-1
      J2=NSTRT(NA2)+J-1
    9 U2(I,J)=BIGU(I2,J2)

      DO 10 K=1,MM1
      DO 10 L=1,MM2
      K1=MSTRT(NA1)+K-1
      L1=MSTRT(NA2)+L-1
   10 P12(K,L)= P(K1,L1)
C     WRITE (9,*)'OFF-DIAG BLOCK OF P IS -'
C     do i=1,mm1
C     WRITE(98,101)(P12(I,J),J=1,MM2)
C     enddo
      DO I=1,MM1
      DO J=1,MM2
      D1(I,J)=P12(I,J)
      ENDDO
      ENDDO
      DO I=1,MM1
      DO J=1,NN2
C     Use s as workspace
      S(I,J)=ZERO
      DO K=1,MM2
      S(I,J)=S(I,J)+D1(I,K)*U2(K,J)
      ENDDO
      ENDDO
      ENDDO
C     WRITE(98,*)'D1*S2, in D1, is'
      DO I=1,MM1
      DO J=1,NN2
      D1(I,J)=S(I,J)
      S(I,J)=ZERO
      ENDDO
      ENDDO
C      p12*u2 now in d1(mm1 x nn2): get d2=u1dag
      DO I=1,NN1
      DO J=1,MM1
      D2(I,J)=U1(J,I)
      ENDDO
      ENDDO
      DO I=1,NN1
      DO J=1,NN2
C     Use s as workspace
      S(I,J)=ZERO
      DO K=1,MM1
      S(I,J)=S(I,J)+D2(I,K)*D1(K,J)
      ENDDO
      ENDDO
      ENDDO
C     pnew12 now in s(nn1,nn2)
C     WRITE (9,*)'OFF-DIAG BLOCK OF PNEW IS -'
C     do I=1,NN1
C     WRITE(98,101)(S(I,J),J=1,NN2)
C     enddo
C     Put p12 in correct place in pnew
      DO K=1,NN1
      DO L=1,NN2
      K1=NSTRT(NA1)+K-1
      L1=NSTRT(NA2)+L-1
      PNEW(K1,L1)=S(K,L)
      ENDDO
      ENDDO
   31 CONTINUE
C     WRITE(98,*)'End of NA2 loop'
   30 CONTINUE
C     WRITE(98,*)'End of NA1 loop'
      IF(NA1.EQ.NAT)GO TO 32
   32 WRITE(IOTEMP,*)'Complete pnew is -'
      DO I=1,NB
      DO J=1,I
      PNEW(I,J)=PNEW(J,I)
      PNEW(J,I)=PNEW(I,J)
      P(I,J)=PNEW(J,I)
      P(J,I)=PNEW(I,J)
      ENDDO
      ENDDO
      CALL MATREC(PNEW,NB,NB,MB)
      WRITE(IOTEMP,*) 'Start indices for val orbs on atoms, are '
      WRITE(IOTEMP,100)(NSTRT(NA),NA=1,NAT)
      WRITE(IOTEMP,*) 'Numbers of val orbs on atoms, are '
      WRITE(IOTEMP,100)(KVAL(NA),NA=1,NAT)
C     Note: pnew still referred to Lowdin basis - PUT INTO P
      TR= ZERO
      DO I=1,NB
      TR=TR+PNEW(I,I)
      DO J=1,NB
      P(J,I)=PNEW(J,I)
      ENDDO
      ENDDO
C     TRACE IS APPROX TO NUMBER OF ELECTRONS
      WRITE(IOTEMP,105)TR
  105 FORMAT('Trace of whole dm =',f12.8)
      DO I=1,NB
      DO J=1,MB
      U(J,I)=BIGU(J,I)
      ENDDO
      ENDDO
C  21 continue
      RETURN
      END

C ------------ new sub (singular value decomposition)
      SUBROUTINE SINGVAL(MB,P,U,BIGU,X,S,U1,U2,P12,
     &  V1,V2,T,NAT,MAT,NOCC)

C     MAT(NA)=NO. OF BFS ON ATOM NA
C     NOCC(NA)=NO. OF OCC ORBS ON ATOM NA (CORE+LP+VAL)

C     P= DENSITY MATRIX PNEW AFTER BLOCK DIAGONALIZATION,
C     -- but referred to Lowdin basis, also hh in common
C     H (IN COMMON) IS HH + HALF*G
C     MB=MBAS=TOTAL BASIS SET SIZE. NORB=NO. OF OCC ORBS
C     ALGORITHM SEEKS V SUCH THAT U->U'=UV (FOR EACH BLOCK, A,B,..)
C     WILL CONTAIN REVISED NAT ORBS, MAXIMIZING INTER-AT BOND ORDERS.

      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C     DIMENSION P(MB,*),X(MB,*),S(MB,*),U(MB,*),E(1000),COL(1000)
C    1,U1(MB,*),U2(MB,*),P12(MB,*),V1(MB,*),V2(MB,*),SS(MB,*)
      DIMENSION P(MB,*),X(MB,*),S(MB,*),U(MB,*),E(1000),COL(1000)
     1,U1(MB,*),U2(MB,*),P12(MB,*),V1(MB,*),V2(MB,*)
C     DIMENSION SM(MB,*),SP(MB,*),BIGU(MB,*),T(MB,*),MAT(*),NOCC(*)
      DIMENSION BIGU(MB,*),T(MB,*),MAT(*),NOCC(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON/INDICES/ KCLP(1000),KVAL(1000),MSTRT(1000),NSTRT(1000)
C     DATA ZERO,ONE,TWO,HALF,ZZ/0.0D 00,1.0D 00,2.0D 00,0.5D 00,1.D-05/
      DATA ZERO,ONE,HALF,ZZ/0.0D 00,1.0D 00,0.5D 00,1.D-05/
C     Note U is rectangular with orth cols
      CALL GETIOUNIT('IOTEMP  ',IOTEMP)
C     NB=NORB
C     neither NB nor NORB are used so NORB removed as argument.
  101 FORMAT(10f7.3)
C     OPEN LOOPS (NA1,NA2) TO WORK ON OFF-DIAG BLOCKS
      DO 30 NA1=1,NAT
      NCLP=KCLP(NA1)
      NBON=0
      MM1=MAT(NA1)
      NN1=NOCC(NA1)
      DO 8 I=1,MM1
      DO 8 J=1,NN1
      I1=MSTRT(NA1)+I-1
      J1=NSTRT(NA1)+J-1
      U(I,J)=BIGU(I1,J1)
    8 U1(I,J)=BIGU(I1,J1)
C     U1 for first atom (na1), copy kept in U
C     Open loop 31, for second atom
      DO 31 NA2=1,NAT
      IF(NA2.EQ.NA1)GO TO 31
      MM2=MAT(NA2)
      NN2=NOCC(NA2)
      DO 9 I=1,MM2
      DO 9 J=1,NN2
      I2=MSTRT(NA2)+I-1
      J2=NSTRT(NA2)+J-1
    9 U2(I,J)=BIGU(I2,J2)

      DO 10 K=1,NN1
      DO 10 L=1,NN2
      K1=NSTRT(NA1)+K-1
      L1=NSTRT(NA2)+L-1
   10 P12(K,L)= P(K1,L1)
      SUM=ZERO
      DO I=1,NN1
      DO J=1,NN2
      SUM=SUM+P12(I,J)*P12(I,J)
      ENDDO
      ENDDO
      IF(SUM.LT.1.0D-01)GO TO 31
      WRITE (IOTEMP,57) NA1,NA2
   57 FORMAT('OFF-DIAG BLOCK OF P FOR NA1,NA2=',2I3)
      DO I=1,NN1
      WRITE(IOTEMP,101) (P12(I,J),J=1,NN2)
      ENDDO

C     Use s as workspace
      DO I=1,NN1
      DO J=1,NN2
      S(I,J)=P12(I,J)
      ENDDO
      ENDDO
      DO I=1,NN1
      DO J=1,NN1
      X(I,J)=ZERO
      DO K=1,NN2
      X(I,J)=X(I,J)+S(I,K)*P12(J,K)
      ENDDO
      ENDDO
      ENDDO
C     T as workspace
      DO I=1,NN2
      DO J=1,NN2
      T(I,J)=ZERO
      DO K=1,NN1
      T(I,J)=T(I,J)+S(K,I)*P12(K,J)
      ENDDO
      ENDDO
      ENDDO
      CALL DIAGX(X,V1,E,NN1,MB)
      CALL DIAGX(T,V2,COL,NN2,MB)
C     ---------Is there a unique bond NA1--NA2 ?
C     Next bit changed 13 july
      NBON=NBON+1
      J=0
   35 J=J+1
      COLJ=COL(J)
      IF(COLJ.LT.HALF)GO TO 35
      I=0
   36 I=I+1
      EI=E(I)
      IF(EI.LT.HALF)GO TO 36
      NUM=I
      DIFF=DABS(EI-COLJ)
      IF(DIFF.LT.ZZ)NU=NUM
      WRITE(IOUTVB,*)'NN1,NU =',NN1,NU
      DO I=1,NN1
      COL(I)=V1(I,NU)
      ENDDO
C     This is first orb on na1 bonding to na2; revise column ncol of UA
C     It will bond with first orb on na2. Use X as workspace
      WRITE(IOTEMP,103) NBON
  103 FORMAT(' NBON for this neighbour (NA2) =',I3)
      NCOL=NCLP+NBON
      WRITE(IOTEMP,105) NU,NCOL
  105 FORMAT(I3,'-column of V1 becomes', I3,'-col of X')
      DO I=1,NN1
      DO J=1,NN1
      X(I,J)=ZERO
      ENDDO
      X(I,I)=ONE
      ENDDO
      DO I=1,NN1
      X(I,NCOL)=V1(I,NU)
      ENDDO
      DO I=1,MM1
      COL(I)=ZERO
      DO J=1,NN1
      COL(I)=COL(I)+U1(I,J)*X(J,NCOL)
      ENDDO
      ENDDO
C---------------------
C     Write modified col into U (copy of u1) in correct place
      DO I=1,MM1
      U(I,NCOL)=COL(I)
      ENDDO
C     U col modified for neighbour na2
C     - must do this for all na2, storing modified cols in U
   31 CONTINUE
      WRITE(IOTEMP,*)'End of NA2 loop'
      WRITE(IOTEMP,*)'Modified U is'
      DO I=1,MM1
      WRITE(IOTEMP,101)(U(I,J),J=1,NN1)
      ENDDO
C     Orthonormality lost -- restore (T,S,E, workspace)
      CALL ORTON(U,T,S,E,MM1,NN1,MB)
      WRITE(IOTEMP,*)'After ORTON, U is'
      DO I=1,MM1
      WRITE(IOTEMP,101)(U(I,J),J=1,NN1)
      ENDDO
C     Write modified U into BIGU in correct place
      DO I=1,MM1
      DO J=1,NN1
      I1=MSTRT(NA1)+I-1
      J1=NSTRT(NA1)+J-1
      BIGU(I1,J1)=U(I,J)
      ENDDO
      ENDDO
   30 CONTINUE
      WRITE(IOTEMP,*)'End of NA1 loop - all atoms done'
C     NOTE: P NOT REVISED (CAN BE DONE ANYTIME USING BIGU)
      RETURN
      END

      SUBROUTINE MML1(V,R,COL,M1,M2,M3,NDIM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     V(DAGGER)R->R, DIM(V)=M2XM1, DIM(R)=M2XM3,
C     THE FINAL R HAS DIM=M1XM3
      DIMENSION V(NDIM,NDIM),R(NDIM,NDIM),COL(NDIM)
      DATA ZER/0.0D 00/
      DO 3 J=1,M3
      DO 2 I=1,M1
      A=ZER
      DO 1 K=1,M2
    1 A=A+V(K,I)*R(K,J)
    2 COL(I)=A
      DO 3 I=1,M1
    3 R(I,J)=COL(I)
      RETURN
      END

      SUBROUTINE DIAGX(A,U,E,N,NDIM)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C  ....  THIS ROUTINE DIAGONALIZES THE INPUT MATRIX, A, BY THE
C  ....  JACOBI METHOD, PLACING THE EIGENVECTORS IN THE COLUMNS OF
C  ....  U, AND THE EIGENVALUES IN THE DIAGONAL OF A.
C********************************************************************C
C   ARGUMENTS.                                                       C
C        A       MATRIX TO BE DIAGONALIZED.                          C
C        U       MATRIX OF EIGENVECTORS.                             C
C        E       LIST OF EIGENVALUES                                 C
C        N       DIMENSION OF THE MATRICES AND THE VECTOR.           C
C********************************************************************C
      DIMENSION A(NDIM,NDIM),U(NDIM,NDIM),E(NDIM)
      DATA ZER,ONE,TWO,FOR,EPS/0.0D 00,1.0D 00,2.0D 00,4.0D 00,1.0D-20/
      DO 8 J=1,N
      DO 9 I=1,N
    9 U(I,J)=ZER
    8 U(J,J)=ONE
   10 AMAX=ZER
      DO 11 I=2,N
      JUP=I-1
      DO 11 J=1,JUP
      AII=A(I,I)
      AJJ=A(J,J)
      AOD=A(I,J)
      ASQ=AOD*AOD
      IF(ASQ.LE.AMAX) GOTO 23
      AMAX=ASQ
   23 IF(ASQ.LE.EPS)  GOTO 11
      DIFFR=AII-AJJ
      IF(DIFFR.GE.0.0D0)  GOTO 15
      SIGN=-TWO
      DIFFR=-DIFFR
      GO TO 16
   15 SIGN=TWO
   16 TDEN=DIFFR+ DSQRT(DIFFR*DIFFR+FOR*ASQ)
      TAN=SIGN*AOD/TDEN
      C=ONE/( DSQRT(ONE+TAN*TAN))
      S=C*TAN
      DO 24 K=1,N
      XJ=C*U(K,J)-S*U(K,I)
      U(K,I)=S*U(K,J)+C*U(K,I)
      U(K,J)=XJ
      IF(K.EQ.J)  GOTO 24
      IF(K.EQ.I)  GOTO 24
      XJ=C*A(K,J)-S*A(K,I)
      A(K,I)=S*A(K,J)+C*A(K,I)
      A(K,J)=XJ
      A(I,K)=A(K,I)
      A(J,K)=A(K,J)
   24 CONTINUE
      A(I,I)=C*C*AII+S*S*AJJ+TWO*S*C*AOD
      A(I,J)=ZER
       A(J,J)=C*C*AJJ+S*S*AII-TWO*S*C*AOD
      A(J,I)=ZER
   11 CONTINUE
      IF(AMAX.GT.EPS) GOTO 10
      DO 25 I=1,N
   25 E(I)=A(I,I)
      RETURN
      END

      SUBROUTINE ORDIN(H,U,E,M,NDIM)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C     PUTS (POSITIVE) E ENTRIES IN DESCENDING ORDER (INVERSE OF USUAL)
      DIMENSION H(NDIM,NDIM),U(NDIM,NDIM),E(NDIM)
      DO 1 K=1,M
      ET=E(K)
      JT=K
      DO 2 J=K,M
      IF(ET.GE.E(J)) GOTO 2
      ET=E(J)
      JT=J
    2 CONTINUE
      E(JT)=E(K)
      E(K)=ET
      DO 1 I=1,M
      H(I,I)=U(I,JT)
      U(I,JT)=U(I,K)
    1 U(I,K)=H(I,I)
      RETURN
      END
      SUBROUTINE SMINH (S,U,E,M,NDIM)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C     THIS REPLACES OVERLAP MATRIX S BY S**(-1/2)
      DIMENSION S(NDIM,NDIM),U(NDIM,NDIM),E(NDIM)
      CALL DIAG (S,U,E,M,NDIM)
C     U BRINGS S IN DIAGONAL FORM. SU = UD ,  D(DIAG) IN E
      DO 1 I=1,M
    1 E(I)=1.D0/DSQRT(E(I))
      DO 2 I=1,M
      DO 2 J=1,I
      S(I,J)=0.D0
      DO 3 K=1,M
    3 S(I,J)=S(I,J)+U(I,K)*E(K)*U(J,K)
      S(J,I)=S(I,J)
    2 CONTINUE
      RETURN
      END

      SUBROUTINE HTRAN(H,V,COL,N,NDIM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C  ....  ROUTINE TO FORM VDAGGER*H*V    FROM TWO SQUARE INPUT MATRICES,
C  ....  H AND V.  THE RESULT OVERWRITES H WITH V REMAINING UNCHANGED.
C  ....  THIS IS VARIABLE-DIMENSION VERSION OF HTRAN.
      DIMENSION H(NDIM,NDIM),V(NDIM,NDIM),COL(NDIM)
      DATA ZER/0.D0/
      DO 3 I=1,N
      DO 2 J=1,N
      A=ZER
      DO 1 K=1,N
    1 A=A+H(I,K)*V(K,J)
    2 COL(J)=A
      DO 3 K=1,N
    3 H(I,K)=COL(K)
      DO 33 J=1,N
      DO 22 I=1,N
      A=ZER
      DO 11 K=1,N
   11 A=A+V(K,I)*H(K,J)
   22 COL(I)=A
      DO 33 K=1,N
   33 H(K,J)=COL(K)
      RETURN
      END
      SUBROUTINE MATREC(A,N1,N2,NDIM)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION A(NDIM,NDIM)
C     KITE=MIN0(KITE,N2)
C     KITE does not seem to be used until KITE=0
      CALL GETIOUNIT('IOTEMP  ',IOTEMP)
   18 FORMAT(1H ,I2,2X,10(F7.3))
C  18 FORMAT(1H ,I2,2X,5(F13.8))
C  18 FORMAT(1H ,I2,2X,7(E10.4))
   19 FORMAT(1X/1H ,3x,10(4X,I3),//)
C  19 FORMAT(1X/1H ,5(10X,I3),//)
C  19 FORMAT(1X/1H ,7(8X,I3),//)
C     LLLL=LADDRS(A)
C     WRITE(IOUTVB,*) 'In MATREC',LLLL
      KITE=0
   20 LOW=KITE+1
C     IF(N2-(KITE+5)) 23,25,25
      IF(N2.GE.(KITE+10)) GOTO 25
      KITE=KITE+(N2-KITE)
      GO TO 27
C  25 KITE=KITE+5
   25 KITE=KITE+10
   27 WRITE(IOTEMP,19) (II,II=LOW,KITE)
      DO 30 I=1,N1
   30 WRITE(IOTEMP,18) I,(A(I,II),II=LOW,KITE)
      IF(N2.GT.KITE) GOTO 20
      RETURN
      END

      SUBROUTINE HTRAN1(H,V,COL,M1,M2,NDIM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C  ....  ROUTINE TO FORM VDAGGER*H*V    FROM H(M1,M1) AND V(M1,M2)
C  ....  H AND V.  THE RESULT OVERWRITES H WITH V REMAINING UNCHANGED.
C  ....  THIS IS RECTANGULAR-V VERSION OF HTRAN.

      DIMENSION H(NDIM,NDIM),V(NDIM,NDIM),COL(NDIM)
      DATA ZER/0.D0/
      DO 3 I=1,M1
      DO 2 J=1,M2
      A=ZER
      DO 1 K=1,M1
    1 A=A+H(I,K)*V(K,J)
    2 COL(J)=A
      DO 3 K=1,M2
    3 H(I,K)=COL(K)
      DO 33 J=1,M1
      DO 22 I=1,M2
      A=ZER
      DO 11 K=1,M1
   11 A=A+V(K,I)*H(K,J)
   22 COL(I)=A
      DO 33 K=1,M2
   33 H(K,J)=COL(K)
      RETURN
      END

      SUBROUTINE SMINX (S,U,E,M,NDIM,EXP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     THIS REPLACES OVERLAP MATRIX S BY S**(-EXP)
      DIMENSION S(NDIM,NDIM),U(NDIM,NDIM),E(NDIM)
      CALL DIAG (S,U,E,M,NDIM)
C     U BRINGS S IN DIAGONAL FORM. SU = UD ,  D(DIAG) IN E
      DO 1 I=1,M
    1 E(I)=1.D0/E(I)**EXP
      DO 2 I=1,M
      DO 2 J=1,I
      S(I,J)=0.D0
      DO 3 K=1,M
    3 S(I,J)=S(I,J)+U(I,K)*E(K)*U(J,K)
      S(J,I)=S(I,J)
    2 CONTINUE
      RETURN
      END

      SUBROUTINE ORTON(U,W,S,E,M,N,NDIM)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C     ORTHONORMALIZE COLS OF U (RECTANGULAR), UNIT METRIC
      DIMENSION U(NDIM,NDIM),S(NDIM,NDIM),W(NDIM,NDIM),E(NDIM)
C     DATA ZERO,ONE/0.0D 00,1.0D 00/
      DATA ZERO/0.0D 00/
      DO 1 J=1,N
      DO 1 I=1,M
    1 S(I,J)=U(I,J)
C     KEEP COPY OF INPUT COLS
      CALL MML1(S,S,E,N,M,N,NDIM)
C     S CONTAINS METRIC UDAG*U
      CALL SMINH(S,W,E,N,NDIM)
C     S NOW REPLACED BY Su**(-half)
      DO 6 I=1,M
      DO 6 J=1,N
    6 W(I,J)=U(I,J)
      DO 7 I=1,M
      DO 7 J=1,N
      U(I,J)=ZERO
      DO 8 K=1,N
    8 U(I,J)=U(I,J)+W(I,K)*S(K,J)
    7 CONTINUE
      RETURN
      END

      SUBROUTINE GUESS2(NATOMS, NATBAS, NBASIS, BASIS,ST,W,NELE)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C     DIMENSION U(50,50),R(50,50),SS(50,50),NATBAS(1000)
      DIMENSION ST(*),W(*),BASIS(NBASIS,*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     OPEN(98,FILE='FIL.LOC',STATUS='UNKNOWN')
      CALL GETIOUNIT('IOTEMP  ',IOTEMP)
      OPEN(IOTEMP,FILE=LOCFILE,STATUS='UNKNOWN')
      NOCC = NELE /2
      REWIND 9
      NWKU = 1
      NWKR = NWKU + NBASIS*NBASIS
      NWKS = NWKR + NBASIS*NBASIS
      NWK1 = NWKS + NBASIS*NBASIS
      NWK2 = NWK1 + NBASIS*NBASIS
      NWK3 = NWK2 + NBASIS*NBASIS
      NWK4 = NWK3 + NBASIS*NBASIS
      NWK5 = NWK4 + NBASIS*NBASIS
      NWK6 = NWK5 + NBASIS*NBASIS
C     NWKX = NWK6 + NBASIS*NBASIS
C     Now read integral file. Put integs in common
      IJ=0
      DO 2 I=1,NBASIS
      II = (I-1)*NBASIS
      DO 2 J=1,I
      JJ = (J-1)*NBASIS
      IJ=IJ+1
      W(NWKS+II+J-1) = ST(IJ)
      W(NWKS+JJ+I-1) = ST(IJ)
 2    CONTINUE
      NBAS2=NBASIS*(NBASIS+1)/2
      WRITE(IOTEMP,1) (ST(I),I=1,NBAS2)
 1    FORMAT(5F12.5)
      DO I=1,NBASIS*NBASIS
      W(NWKR-1+I)=0.0D0
      END DO
      DO I=1,NBASIS
      II = (I-1)*NBASIS
      DO J=1,NBASIS
      W(NWKU+II+J-1)=BASIS(J,I)
      END DO
      END DO
      DO K=1,NOCC
      DO I=1,NBASIS
      II = (I-1)*NBASIS
      DO J=1,NBASIS
      W(NWKR+II+J-1)=W(NWKR+II+J-1)+BASIS(I,K)*BASIS(J,K)
      END DO
      END DO
      END DO
      CALL HYBRIDS(W(NWKS),W(NWKR),W(NWKU),W(NWK1),W(NWK2),W(NWK3),
     & W(NWK4),W(NWK5),W(NWK6),NATOMS,NATBAS,NBASIS)
C
C     COPY BACK TO BASIS
C
      IJ=0
      DO I=1,NBASIS
      DO J=1,NBASIS
      IJ=IJ+1
      BASIS(J,I)=W(NWK3-1+IJ)
      END DO
      END DO
      CLOSE(98)
      RETURN
      END
      SUBROUTINE VISUAL(RWRK,ETOTAL)
C
C     Routine to create visualisation files:-
C
C     $MOLPLT - *.mol file for Gamess Graphics molplt program.
C     $PLTORB - *.vec and (not in Gamess) *.orb for Gamess Graphics
C       molplt program. In Gamess orb data is in PUNCH
C     $MOLEKEL - *.mkl file in MKL format for Molekel program.
C     $MOLDEN - *.molf file in molden file format for Molden program.
C     $XYZFILE - *.xyz file in XYZ format for several programs.
C     $CUBE - *.cube file in Gaussian cube format, but one file per VB
C       orbital, for several programs.
C     $GENGRID - *.grd file in DSV GRID output format - one per orbital.
C     $GRID - alternative to $GENGRID, but only for stand-alone program.
C     $LINE - constructs *.csv files that can be used in a spreadsheet 
C       to plot VB orbitals along a set of connected lines.
C
C     Created (along with all routines below that are called from VISUAL):
C               Brian Duke, Jan - June, 2005
C
C     Added capability to use LMOs, rather then VBOs, in TEST runs.
C               Brian Duke, Nov, 2011
C
C     Added capability to create molden format files and LINE csv files.
C               Brian Duke, Dec, 2011
C
      IMPLICIT NONE
      CHARACTER*1 SYM,BLANK
      CHARACTER*2 ATMSYM
      CHARACTER*3 FUNIT(10),TAG
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*40 TITLE
      CHARACTER*64 FSTR,RWFFILE,INTFILE,INPFILE,LOCFILE
      LOGICAL LMOLT,LPLT,LMKL,LMOLD,LXYZ,LCUBE,LGRID,LLINE,LFIRST,LGOT
CGMS  LOGICAL AIMPAC,PLTORB,MOLPLT,RPAC
CGAU  INTEGER NUMD,NUMF
      INTEGER KVB(100),IOK,IOENGI,I,J,NP,NVB,IT,JT,KT(1000),IGRID,
     & IMOL,NF,JJ,KATOM,MAXATM,MAXSHL,LENFIL,IOHFORB,IOUTVB,NATOM,NELE,
     & NSPIN,NBASIS,NATNUM,NATBAS,NATNO,IERR,IIIP,I1,KEY,NATPT,NCRIT,
     & NPOINT,MXATM,NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,NVIR,
     & MBASIS,LPTALL,LHYBRD,MELE,MSPIN,MNORBIT,MLORBIT,MWIN,MSTR,METHOD,
     & IBASIS,NOCC,NOBIAS,NEPS,NOTROT,LTEST,IRESTART,IGUESSREAD,MTHEORY,
     & NGPF,NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,LD2STA,
     & LGDMP,N1DADD,N2DADD,NB1ADD,NB2ADD,IBASCK
CGMS  INTEGER MXRT
CGMS  PARAMETER (MXRT=100)
      PARAMETER (MAXSHL=200,MAXATM=100,MXATM=2000)
      DOUBLE PRECISION XE,C,ETOTAL,XEXP,COEFF,ENREP,XYZ,TOANG,
     & XALL(3,10),ATMCHG,C1(3,1000),EIG(500),C2(1000),RWRK(*)
CGMS  DOUBLE PRECISION ENUCR,EELCT,ETOT,SZ2,SZZ2,ECORE,ESCF,EERD,
CGMS & E1,E2,VEN,VEE,EPOT,EKIN,ESTATE,STATN,EDFT,EDISP,FRIEND
CGAU  COMMON /DORF/ NUMD,NUMF
      COMMON /CUBEC/ XE(1000),C(1000),IT(1000),JT(1000)
      COMMON /SEEING/ XEXP(MAXSHL,30),COEFF(MAXSHL,30),SYM(MAXSHL),
     &NF(MAXSHL),JJ(MAXSHL),KATOM(MAXATM),IMOL
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
     &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
     &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
CGMS  COMMON /INTRFC/ FRIEND,AIMPAC,RPAC,PLTORB,MOLPLT
CGMS  COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ2,SZZ2,ECORE,ESCF,EERD,E1,E2,
CGMS &                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /ATMCH/ ATMCHG(MXATM),NATNO(MXATM)
      DATA TOANG /0.529177249D0/
      DATA BLANK /' '/
      COMMON /ATOMSY/ ATMSYM(92)
      IMOL = 96
      LGOT = .FALSE.
      IF(LTEST.EQ.1) THEN
         WRITE(IOUTVB,
     &   '(/," SEARCHING FOR VISUAL DATA WITH LMOs IN TEST RUN",/)')
      ENDIF
C
C     CHECK WHICH VISUAL DIRECTIVES ARE PRESENT
C
      LMOLT = .FALSE.
      LPLT = .FALSE.
      LMKL = .FALSE.
      LMOLD = .FALSE.
      LXYZ = .FALSE.
      LCUBE = .FALSE.
      LGRID = .FALSE.
      LLINE = .FALSE.
      IGRID = 0
C
C     $MOLPLT
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$MOLPLT',7,IOK,0)
      IF(IOK.EQ.1) LMOLT = .TRUE.
C
C     $PLTORB
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$PLTORB',7,IOK,0)
      IF(IOK.EQ.1) LPLT = .TRUE.
C
C     $MOLEKEL
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$MOLEKEL',8,IOK,0)
      IF(IOK.EQ.1) LMKL = .TRUE.
C
C     $MOLDEN
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$MOLDEN',7,IOK,0)
      IF(IOK.EQ.1) LMOLD = .TRUE.
C
C     $XYZFILE
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$XYZFILE',8,IOK,0)
      IF(IOK.EQ.1) LXYZ = .TRUE.
C
C     $GENGRID & $GRID
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$GENGRID',5,IOK,0)
      IF(IOK.EQ.1) THEN
         LGRID = .TRUE.
         IGRID = 1
      ENDIF
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$GRID',5,IOK,0)
      IF(IOK.EQ.1) THEN
         IF(IGRID.EQ.1) THEN
            WRITE(IOUTVB,'(" BOTH $GRID AND $GENGRID FOUND")')
            WRITE(IOUTVB,'(" IGNORING $GRID")')
         ELSE
           LGRID = .TRUE.
           IGRID = 2
         ENDIF
      ENDIF
CGMS  IF(IGRID.EQ.2) THEN
CGMS     WRITE(IOUTVB,
CGMS & '(" $GRID NOT ALLOWED IN GAMESS/VB2000 - USE $GENGRID",/)')
CGMS     LGRID = .FALSE.
CGMS  ENDIF
C
C     $CUBE
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$CUBE',5,IOK,0)
      IF(IOK.EQ.1) LCUBE = .TRUE.
C
C     $LINE
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$LINE',5,IOK,0)
      IF(IOK.EQ.1) LLINE = .TRUE.
C
C     RETURN IF NO DIRECTIVES FOUND
      IF (.NOT.(LMOLT.OR.LPLT.OR.LMKL.OR.LMOLD.OR.LXYZ.OR.LCUBE
     & .OR.LGRID.OR.LLINE)) RETURN
C
C     CAN NOT DO CUBE, GRID AND LINE IN GAUSSIAN IF SPHERICAL HARMONICS
CGAU  IF(LCUBE.OR.LGRID.OR.LLINE) THEN
CGAU    IF (NUMD.EQ.0) THEN
CGAU      WRITE(IOUTVB,
CGAU &    '(/," USING SPHERICAL HARMONICS.")')
CGAU      WRITE(IOUTVB,
CGAU &    '(/," CUBE AND GRID FILE CREATION NOT ALLOWED.",/)')
CGAU      LCUBE = .FALSE.
CGAU      LGRID = .FALSE.
CGAU      LLINE = .FALSE.
CGAU    ENDIF
CGAU  ENDIF
C
C     CALL BASIS FUNCTIONS ONLY ONCE. 
      IF (LMOLT.OR.LPLT.OR.LMKL.OR.LMOLD.OR.LCUBE.OR.LGRID.OR.LLINE) 
     &THEN
        DO I=1,MAXSHL
          SYM(I)=BLANK
        ENDDO
C000    IBASCK=1
CSMI    IBASCK=2
CGMS    IBASCK=3
CGAU    IBASCK=4
        IF(IBASCK.EQ.1) CALL BASISA(NATOM)
CSMI    IF(IBASCK.EQ.2) CALL BASISI(NATOM)
CGMS    IF(IBASCK.EQ.3) CALL BASISM()
CGAU    IF(IBASCK.EQ.4) CALL BASISG(NATOM)
      ENDIF
C
      IF (LPLT.OR.LMKL.OR.LMOLD.OR.LCUBE.OR.LGRID.OR.LLINE) THEN
      IF (LTEST .NE. 1 .AND. MTHEORY .EQ. 1 .AND. .NOT. LGOT) THEN
CGMS     ETOTAL = ETOT
         NSUB = 1
         NB1ADD(1) = 1
         NB1ADD(2) = 1 + NBASIS
         CALL GETIOUNIT('IOHFORB ',IOHFORB)
         CALL RDMORB(IOHFORB,RWRK(1),EIG,NBASIS)
         LGOT = .TRUE.
      ENDIF
      ENDIF
C
C     $MOLPLT
C     Create mol file for molplt to display molecular frame.
C     File called GMSPLT to avoid conflict with MOLPLT in Gamess.
C
      IF(.NOT.LMOLT) GOTO  201
C     Ignore GMS $CONTRL MOLPLT if VB MOLPLT is present.
CGMS  MOLPLT=.FALSE.
      CALL GMSPLT(ATMSYM)
      WRITE(IOUTVB,101)
 101  FORMAT(' CREATED FILE FOR MOLPLT ANALYSIS',/)
 201  CONTINUE
C
C     $PLTORB
C     Create $VEC file for pltorb to display orbitals.
C     File called GMSORB to avoid conflict with PLTORB in Gamess.
C
      IF(.NOT.LPLT) GOTO  202
CGAU  IF (NUMD.EQ.0) THEN
CGAU     WRITE(IOUTVB,
CGAU &   '(/," PLTORB NOT ALLOWED WITH SPHERICAL HARMONICS",/)')
CGAU     GOTO 202
CGAU  ENDIF
      CALL GMSORB(RWRK,ATMSYM)
      WRITE(IOUTVB,'(" CREATED VEC & ORB FILE FOR PLTORB ANALYSIS",/)')
 202  CONTINUE
C
C     $MOLEKEL OR $MOLDEN
C     Create MKL file for MOLEKEL or molden file format for MOLDEN
C
      IF(.NOT.LMKL .AND. .NOT.LMOLD) GOTO  203
      IF(LMKL) THEN
        CALL MOLEKEL(RWRK,IERR,.TRUE.)
        IF(IERR.eq.0) WRITE(IOUTVB,121)
      ENDIF
      IF(LMOLD) THEN
        CALL MOLEKEL(RWRK,IERR,.FALSE.)
        IF(IERR.eq.0) WRITE(IOUTVB,122)
      ENDIF
 121  FORMAT(' CREATED FILE FOR MOLEKEL ANALYSIS',/)
 122  FORMAT(' CREATED FILE FOR MOLDEN ANALYSIS',/)
 203  CONTINUE
C
C     $XYZFILE
C     Create simple XYZ file
C
      IF(.NOT.LXYZ) GOTO  204
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$XYZFILE',8,IOK,0)
      IF(IOK.EQ.1) THEN
        READ(IOENGI,'(A40)') TITLE
        INPFILE=FSTR(1:LENFIL)//'.xyz'
        OPEN(UNIT=IMOL,FILE=INPFILE,STATUS='UNKNOWN',
     1    ACCESS='SEQUENTIAL',FORM='FORMATTED')
        CALL XYZFILE(XYZ,NATOM,NATNUM,TITLE)
        WRITE(IOUTVB,131)
        CLOSE(IMOL)
      ENDIF
 131  FORMAT(' CREATED XYZ FILE OF MOLECULAR COORDINATES',/)
 204  CONTINUE
C
C     $CUBE
C     Create CUBE Cube file for MOLEKEL and other codes, and GRID files.
C
      IF(.NOT.LCUBE) GOTO  205
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$CUBE',5,IOK,0)
C     NO OF VB ORBITALS FOLLOWED BY ORBITAL NUMBERS
      READ(IOENGI,*) NVB
      READ(IOENGI,*) (KVB(J),J=1,NVB)
C     TITLE - NO DEFAULT
      READ(IOENGI,'(A40)') TITLE
C     UNFORMATTED - NPOINTS (DEFAULT = 80)
      READ(IOENGI,*) NP
      IF(NP.EQ.0) NP=80
      IF(NP.GT.100) THEN
         WRITE(IOUTVB,106) NP
         GOTO 205
      ENDIF
      CALL SETCUBE(KT,IIIP,IERR)
      IF (IERR.EQ.1) RETURN
C     IIIP IS TOTAL NO. OF PRIMITIVES.
      LFIRST=.TRUE.
      DO J=1,NVB
        I=KVB(J)
        CALL GETTAG(I,TAG)
        INPFILE=FSTR(1:LENFIL)//'-'//TAG//'.cube'
        OPEN(UNIT=IMOL,FILE=INPFILE,STATUS='UNKNOWN',
     1    ACCESS='SEQUENTIAL',FORM='FORMATTED')
C       FOLD IN COEFFICIENTS FROM SELECTED VB ORBITAL
C       WRITE(IOUTVB,'(10F10.5)') (C(I1),I1=1,IIIP)
        DO I1=1,IIIP
           C2(I1) = RWRK(KT(I1)+(I-1)*NBASIS)
        ENDDO
C       WRITE(IOUTVB,'(10F10.5)') (C2(I1),I1=1,IIIP)
        DO I1=1,IIIP
           C2(I1) = C(I1)*C2(I1)
        ENDDO
C       WRITE(IOUTVB,'(10F10.5)') (C2(I1),I1=1,IIIP)
        CALL CUBE(C2,TITLE,NP,I,IIIP,LFIRST)
        CLOSE(IMOL)
        WRITE(IOUTVB,142) I,INPFILE
        LFIRST=.FALSE.
      ENDDO
 142  FORMAT(' CUBE FILE FOR ORBITAL',I4,' CREATED AS ',A64)
 205  CONTINUE
C
C     $GENGRID & $GRID
C     Create GRID files for DS Visualizer, which is free from Accelrys.
C
      IF(.NOT.LGRID) GOTO  206
      REWIND(IOENGI)
      IF(IGRID.EQ.1) CALL LOCTOR(IOENGI,'$GENGRID',5,IOK,0)
      IF(IGRID.EQ.2) CALL LOCTOR(IOENGI,'$GRID',5,IOK,0)
C     NO OF VB ORBITALS FOLLOWED BY ORBITAL NUMBERS
      READ(IOENGI,*) NVB
      READ(IOENGI,*) (KVB(J),J=1,NVB)
C     TITLE - NO DEFAULT
      READ(IOENGI,'(A40)') TITLE
C     UNFORMATTED - NPOINTS (DEFAULT = 80)
      READ(IOENGI,*) NP
      IF(NP.EQ.0) NP=80
      IF(NP.GT.100) THEN
         WRITE(IOUTVB,106) NP
         GOTO 206
      ENDIF
      CALL SETCUBE(KT,IIIP,IERR)
      IF (IERR.EQ.1) RETURN
C     IIIP IS TOTAL NO. OF PRIMITIVES.
      DO J=1,NVB
        I=KVB(J)
        CALL GETTAG(I,TAG)
        INPFILE=FSTR(1:LENFIL)//'-'//TAG//'.grd'
        OPEN(UNIT=IMOL,FILE=INPFILE,STATUS='UNKNOWN',
     1    ACCESS='SEQUENTIAL',FORM='FORMATTED')
C       FOLD IN COEFFICIENTS FROM SELECTED VB ORBITAL
C       WRITE(IOUTVB,'(10F10.5)') (C(I1),I1=1,IIIP)
        DO I1=1,IIIP
           C2(I1) = RWRK(KT(I1)+(I-1)*NBASIS)
        ENDDO
C       WRITE(IOUTVB,'(10F10.5)') (C2(I1),I1=1,IIIP)
        DO I1=1,IIIP
           C2(I1) = C(I1)*C2(I1)
        ENDDO
C       WRITE(IOUTVB,'(10F10.5)') (C2(I1),I1=1,IIIP)
        CALL GENGRID(C2,TITLE,NP,IMOL,IIIP)
        CLOSE(IMOL)
        WRITE(IOUTVB,146) I,INPFILE
      ENDDO
 146  FORMAT(' GRID FILE FOR ORBITAL',I4,' CREATED AS ',A64)
 206  CONTINUE
C
C     $LINE directive.
C
C     The purpose is to produce the value of a VBO along a line which
C     can be divided into sections of the same length. The data is output 
C     in a form (*.csv) where it can readily be in put into a spreadsheet 
C     such as Excel, OpenOfficei or LibreOffice.
C
      IF(.NOT.LLINE) GOTO  99
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$LINE',5,IOK,0)
C     NO OF VB ORBITALS FOLLOWED BY ORBITAL NUMBERS
      READ(IOENGI,*) NVB
      READ(IOENGI,*) (KVB(J),J=1,NVB)
      READ(IOENGI,*) NCRIT,NP
      IF(NCRIT.LT.2) NCRIT=2
      IF(NP.GT.100) THEN
         WRITE(IOUTVB,106) NP
         GOTO 99
      ENDIF
      WRITE(IOUTVB,100)
      WRITE(IOUTVB,108)
      WRITE(IOUTVB,107)
      NPOINT=0
      DO I=1,NCRIT
        READ(IOENGI,*) NATPT,(XALL(J,I+1),J=1,3)
        IF (I.EQ.1) THEN
          NPOINT=NPOINT + NP + 1
        ELSE
          NPOINT=NPOINT + 2 * NP + 1
        ENDIF
        IF (NATPT.GT.0) THEN
          WRITE(IOUTVB,102) ATMSYM(NATNUM(NATPT)),NPOINT,
     &      ATMCHG(NATPT),(XALL(J,I+1),J=1,3)
        ELSE
          WRITE(IOUTVB,109) NPOINT,(XALL(J,I+1),J=1,3)
        ENDIF
      ENDDO
      WRITE(IOUTVB,103) NVB
      CALL SETCUBE(KT,IIIP,IERR)
      IF (IERR.EQ.1) RETURN
C     IIIP IS TOTAL NO. OF PRIMITIVES
      DO I=1,NATOM
      DO J=1,3
        C1(J,I)=XYZ(J,I)/TOANG
      ENDDO
      ENDDO
      DO I=1,NCRIT
      DO J=1,3
        XALL(J,I+1)=XALL(J,I+1)/TOANG
      ENDDO
      ENDDO
      LFIRST=.TRUE.
      DO J=1,NVB
        I=KVB(J)
        CALL GETTAG(I,TAG)
        INPFILE=FSTR(1:LENFIL)//'-'//TAG//'.csv'
        OPEN(UNIT=IMOL,FILE=INPFILE,STATUS='UNKNOWN',
     1    ACCESS='SEQUENTIAL',FORM='FORMATTED')
C       FOLD IN COEFFICIENTS FROM SELECTED VB ORBITAL
C       WRITE(IOUTVB,'(10F10.5)') (C(I1),I1=1,IIIP)
        DO I1=1,IIIP
           C2(I1) = RWRK(KT(I1)+(I-1)*NBASIS)
        ENDDO
C       WRITE(IOUTVB,'(10F10.5)') (C2(I1),I1=1,IIIP)
        DO I1=1,IIIP
           C2(I1) = C(I1)*C2(I1)
        ENDDO
C       WRITE(IOUTVB,'(10F10.5)') (C2(I1),I1=1,IIIP)
        CALL LINE(C1,C2,NCRIT,NP,IIIP,LFIRST,XALL)
        LFIRST=.FALSE.
        CLOSE(IMOL)
        WRITE(IOUTVB,104) I
        WRITE(IOUTVB,110) I,INPFILE
      ENDDO
 99   RETURN
 100  FORMAT(" LINE FILE DETAILS",/)
 102  FORMAT(2X,A2,3X,I4,2X,4F12.6)
 103  FORMAT(/," No. of VB orbitals =",I2)
 104  FORMAT(" VB orbital =",I4)
 106  FORMAT(' NP CAN NOT EXCEED 100. IT IS',I4)
 107  FORMAT(" ATOM  NPOINT    ATOM CHG",7X,"X",11X,"Y",11X,"Z",/)
 108  FORMAT(" THE VALUES OF NPOINT BELOW ARE THE SPREADSHEET POINTS",
     &" FOR THE",/," CRITICAL POINTS. THE ATOM SYMBOL AND CHARGE",
     &" ASSUME THE CRITICAL",/," POINT IS AN ATOM OR ASSOCIATED",
     &" WITH AN ATOM",/)
 109  FORMAT(7X,I4,2X,12X,3F12.6)
 110  FORMAT(/,' LINE FILE FOR ORBITAL',I4,' CREATED AS ',A64)
      END
      SUBROUTINE GETTAG(I,TAG)
C     GETS TAG FOR CUBE, GENGRID AND LINE FILE NAMES
      IMPLICIT NONE
      CHARACTER*3 TAG
      CHARACTER*10 NUMBER
      INTEGER I,II,I1,I2,I3
      NUMBER='0123456789'
      I1=MOD(I,10) + 1
      II=I/10
      I2=MOD(II,10) + 1
      I3=(II/10) + 1
      TAG(1:1)=NUMBER(I3:I3)
      TAG(2:2)=NUMBER(I2:I2)
      TAG(3:3)=NUMBER(I1:I1)
      RETURN
      END
      SUBROUTINE SETCUBE(KT,IIIP,IERR)
      IMPLICIT NONE
      CHARACTER*1 SYM
      CHARACTER*3 FUNIT(10)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      INTEGER I,J,IT,JT,KT(1000),IMOL,JJ,KATOM,MAXATM,MAXSHL,LENFIL,
     & IOUTVB,NATOM,NELE,NSPIN,NBASIS,NATNUM,NATBAS,IIIP,IIIC,KK,NN,K,
     & KKK,JJJ,NF,IERR
      PARAMETER (MAXSHL=200,MAXATM=100)
      DOUBLE PRECISION FACTR(5),ENREP,XYZ
      DOUBLE PRECISION XE,C,XEXP,COEFF,PI,PI32,SQ3,SQ5,SQ7,AA,CC
      COMMON /CUBEC/ XE(1000),C(1000),IT(1000),JT(1000)
      COMMON /SEEING/ XEXP(MAXSHL,30),COEFF(MAXSHL,30),SYM(MAXSHL),
     &NF(MAXSHL),JJ(MAXSHL),KATOM(MAXATM),IMOL
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      DATA FACTR/1.0D+00,1.0D+00,  3.0D+00, 15.0D+00, 105.0D+00/
      PI = ACOS(-1.0D0)
      PI32 = PI * SQRT(PI)
      IERR = 0
      IIIP=0
      IIIC=0
      NN=0
      SQ3 = SQRT(3.0D0)
      SQ5 = SQRT(5.0D0)
      SQ7 = SQRT(7.0D0)
C     WRITE(IOUTVB,'(10(1X,A1))') (SYM(I),I=1,20)
C     WRITE(IOUTVB,'(10I4)') (KATOM(I),I=1,NATOM)
C     WRITE(IOUTVB,145)
      DO I=1,NATOM
        DO KK=1,KATOM(I)
          NN=NN+1
          IF (SYM(NN).EQ.'S') THEN
            K=1
            KKK=1
            GOTO 111
          ENDIF
          IF (SYM(NN).EQ.'P') THEN
            K=3
            KKK=2
            GOTO 111
          ENDIF
          IF (SYM(NN).EQ.'D') THEN
            K=6
            KKK=3
            GOTO 111
          ENDIF
          IF (SYM(NN).EQ.'F') THEN
            K=10
            KKK=4
            GOTO 111
          ENDIF
          IF (SYM(NN).EQ.'G') THEN
            K=15
            KKK=5
            GOTO 111
          ENDIF
          WRITE(IOUTVB,144) SYM(NN)
          IERR = 1
          RETURN
 111      DO JJJ=1,K
            IIIC=IIIC+1
            DO J=1,NF(NN)
              IIIP=IIIP+1
              JT(IIIP) = I
C             STORE ATOM
C
C             KKK - TYPE OF ORBITAL - S, P, D, F, G --> 1 2 3 4 5
C             JJJ -  SUB-TYPE - e,g D --> 1 2 3 4 5 6
              IF(KKK.EQ.1) IT(IIIP)=JJJ
              IF(KKK.EQ.2) IT(IIIP)=JJJ + 1
              IF(KKK.EQ.3) IT(IIIP)=JJJ + 4
              IF(KKK.EQ.4) IT(IIIP)=JJJ + 10
              IF(KKK.EQ.5) IT(IIIP)=JJJ + 20
              XE(IIIP)=XEXP(NN,J)
C             PRIMITIVE ORBITAL EXPONENT
              AA = XEXP(NN,J)**(KKK+0.5D+00) *
     &            2.0D+00**(KKK+KKK-0.5D+00)
              AA = AA / (FACTR(KKK)*PI32)
              CC=SQRT(AA)*COEFF(NN,J)
C             CONTRACTION COEFFICIENT + NORMALISATION
              IF(KKK.EQ.3.AND.JJJ.GE.4) CC = SQ3 * CC
C             D NORM BASED ON XX - MODIFY XY etc.
              IF(KKK.EQ.4) THEN
                IF(JJJ.GE.4) CC = SQ5 * CC
                IF(JJJ.EQ.10) CC = SQ3 * CC
              ENDIF
C             F NORM BASED ON XXX - MODIFY OTHERS
              IF(KKK.EQ.5) THEN
                IF(JJJ.GE.4) CC = SQ7 * CC
                IF(JJJ.GE.10) CC = SQ5 * CC / SQ3
                IF(JJJ.GE.13) CC = SQ3 * CC
C             G NORM BASED ON XXXX - MODIFY OTHERS
              ENDIF
              C(IIIP) = CC
              KT(IIIP)=IIIC
C             BASIS FUNCTION FROM VB ORBITAL TO WRAP IN LATER
C             FOLD IN NORMALISATION
C             WRITE(IOUTVB,143) IIIP,XE(IIIP),C(IIIP),KKK,JJJ,KT(IIIP),
C    &          IT(IIIP),JT(IIIP)
            ENDDO
          ENDDO
        ENDDO
      ENDDO
      RETURN
C143  FORMAT(I4,2F16.8,5I4)
 144  FORMAT(' INCORRECT SYMBOL ',A1)
C145  FORMAT(' IIIP         XEXP           COEFF   ',
C    &' KKK JJJ  KT  IT  JT')
      END
      SUBROUTINE LINE(C1,C2,NCRIT,NP,IIIP,LFIRST,XALL)
C
C     Calculates LINE output - one per orbital.
C
      IMPLICIT NONE
      CHARACTER*1 SYM
      LOGICAL LFIRST
      INTEGER IT,JT,NCRIT,IMOL,NF,JJ,KATOM,MAXATM,MAXSHL
      INTEGER J,NP,IIIP,I1,I2,I3,I4,L,K,N
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
      DOUBLE PRECISION XEXP,COEFF
      DOUBLE PRECISION XE,C,X,Y,Z,SUM
      DOUBLE PRECISION C2(1000),C1(3,1000),XX(3),XALL(3,10)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /CUBEC/ XE(1000),C(1000),IT(1000),JT(1000)
      PARAMETER (MAXSHL=200,MAXATM=100)
      COMMON /SEEING/ XEXP(MAXSHL,30),COEFF(MAXSHL,30),SYM(MAXSHL),
     &NF(MAXSHL),JJ(MAXSHL),KATOM(MAXATM),IMOL
C
      DO J=1,3
      XX(J) = (XALL(J,3)-XALL(J,2))/(2*NP)
      XALL(J,1)=XALL(J,2) - NP * XX(J)
      XALL(J,NCRIT+2)=XALL(J,NCRIT+1) + NP * XX(J)
      ENDDO
      L = 0
      N = NCRIT + 1
      I2 = 2 * NP + 1
      I3 = 1
      DO I4=1,N
      IF (I4.EQ.3) I3 = 0
      K = 2 * NP
      IF(I4.EQ.1.OR.I4.EQ.N) K = NP
      IF(I4.EQ.2) K = I2
      IF(I4.GT.2.AND.I4.LT.N) THEN
        XX(1) = (XALL(1,I4+1)-XALL(1,I4))/(2*NP)
        XX(2) = (XALL(2,I4+1)-XALL(2,I4))/(2*NP)
        XX(3) = (XALL(3,I4+1)-XALL(3,I4))/(2*NP)
      ENDIF
      DO I1=1,K
        L = L + 1
        X=XALL(1,I4) + (I1-I3)*XX(1)
        Y=XALL(2,I4) + (I1-I3)*XX(2)
        Z=XALL(3,I4) + (I1-I3)*XX(3)
        SUM = 0.0D0
        CALL ORBPT(SUM,C1,C2,XE,X,Y,Z,JT,IT,IIIP)
        WRITE(IMOL,105) L,SUM
C       IF (LFIRST) WRITE(IW,101) L,X,Y,Z,SUM
        ENDDO
      ENDDO
      IF (LFIRST) WRITE(IW,106) L
      RETURN
C101  FORMAT(I4,3F12.6,E13.5)
 105  FORMAT(I4,",",F15.10)
 106  FORMAT(" Total number of points =",I4,/)
      END

      SUBROUTINE GMSORB(RWRK,ATMSYM)
C
C     Calculates PLTORB outout.
C
      IMPLICIT NONE
      DOUBLE PRECISION RWRK(*)
      CHARACTER*1 SYM
      CHARACTER*2 ATMSYM(92),XY
      CHARACTER*3 FUNIT(10)
      CHARACTER*8 PLANE
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*40 TITLE
      CHARACTER*64 FSTR,RWFFILE,INTFILE,INPFILE,LOCFILE
CGMS  INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA,IGMS,ISAVE
      INTEGER IMOL,NF,JJ,KATOM,MAXATM,MAXSHL,LENFIL,IOUTVB,NATOM,
     & NELE,NSPIN,NBASIS,NATNUM,NATBAS,KK,NN,NO,MAX,MIN,MODJ,I,J,ID,
     & NOCB,NCCC,IA(20),IB(20),IC(20),NBONDS,NVBOS,IOENGI,IOK
      INTEGER NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,NVIR,MBASIS,
     &LPTALL,LHYBRD,MELE,MSPIN,MNORBIT,MLORBIT,MWIN,MSTR,METHOD,IBASIS,
     &NOCC,NOBIAS,NEPS,NOTROT,LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF
      INTEGER NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD,N2DADD,NB1ADD,NB2ADD,KEY,IAT1,IAT2,IAT3
      DOUBLE PRECISION XEXP,COEFF,ENREP,XYZ,PX(4),XOFF
      PARAMETER (MAXSHL=200,MAXATM=100)
      COMMON /SEEING/ XEXP(MAXSHL,30),COEFF(MAXSHL,30),SYM(MAXSHL),
     &NF(MAXSHL),JJ(MAXSHL),KATOM(MAXATM),IMOL
CGMS  COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
     &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
     &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
C#######################################################################
C
C     CREATE $VEC GROUP OF VB ORBITALS FOR PLTORB IN GMS VERSION
C     AND BOTH *.vec AND *.orb IN OTHER VERSIONS.
C
      INPFILE=FSTR(1:LENFIL)//'.vec'
      OPEN(UNIT=IMOL,FILE=INPFILE,STATUS='UNKNOWN',
     1  ACCESS='SEQUENTIAL',FORM='FORMATTED')
      NOCB=NB1ADD(NSUB+1)-1
      WRITE(IMOL,101)
 101  FORMAT(' $VEC')
C
C     GAMESS USE - EASY, GET PUSQL TO DO IT.
C     SET IGMS=1 and use IF(IGMS.EQ.1) statement to void ftnchek error
C
      NCCC=NOCB
      IF(LTEST.EQ.1) NCCC=(NELE-NSPIN)/2 + NSPIN
CGMS  ISAVE=IP
CGMS  IP=IMOL
CGMS  CALL PUSQL(RWRK(1),NCCC,NBASIS,NBASIS)
CGMS  IP=ISAVE
CGMS  WRITE(IMOL,102)
CGMS  IGMS=1
CGMS  IF(IGMS.EQ.1) GOTO 12
C
C     NOW FOR MORE COMPLEX NON-GAMESS use.
C
C     VEC FIRST
      DO J = 1,NCCC
        ID = 0
        MAX = 0
 11     MIN = MAX+1
        MAX = MAX+5
        ID = ID+1
        IF (MAX .GT. NBASIS) MAX = NBASIS
        MODJ=MOD(J,100)
        WRITE (IMOL,9) MODJ,ID,(RWRK(I+(J-1)*NBASIS),I = MIN,MAX)
        IF (MAX .LT. NBASIS) GO TO 11
      ENDDO
      WRITE(IMOL,102)
      CLOSE(IMOL)
C
C     THEN *.orb FILE
      PLANE="        "
 12   CALL GETIOUNIT('IOENGI  ',IOENGI)
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$PLTORB',7,IOK,0)
      IF(IOK.EQ.1) THEN
        READ(IOENGI,*) NBONDS,(IA(J),IB(J),J=1,NBONDS)
        READ(IOENGI,*) NVBOS,(IC(J),J=1,NVBOS)
        READ(IOENGI,*) PLANE
        IF (PLANE.EQ."SYMBOLIC") READ(IOENGI,*) XY
        IF (PLANE.EQ."3ATOMS  ") READ(IOENGI,*) IAT1,IAT2,IAT3
        READ(IOENGI,*) XOFF
        READ(IOENGI,*) (PX(J),J=1,4)
      ELSE
        RETURN
      ENDIF
      INPFILE=FSTR(1:LENFIL)//'.orb'
      OPEN(UNIT=IMOL,FILE=INPFILE,STATUS='UNKNOWN',
     1  ACCESS='SEQUENTIAL',FORM='FORMATTED')
      WRITE(IMOL,1) NATOM,NBONDS,NBASIS,NBASIS,NVBOS,PLANE
      NO=1
      DO I=1,NATOM
        WRITE(IMOL,2) ATMSYM(NATNUM(I)),(XYZ(J,I),J=1,3)
      ENDDO
      IF (PLANE.EQ."SYMBOLIC") WRITE(IMOL,3) XY 
      IF (PLANE.EQ."3ATOMS  ") WRITE(IMOL,'(3I3)') IAT1,IAT2,IAT3
      WRITE(IMOL,10) XOFF,(PX(J),J=1,4)
      WRITE(IMOL,4) (IA(J),IB(J),J=1,NBONDS)
      WRITE(IMOL,5) (IC(J),J=1,NVBOS)
      NN=0
      DO I=1,NATOM
        WRITE(IMOL,104) ATMSYM(NATNUM(I)),KATOM(I)
        DO KK=1,KATOM(I)
        NN=NN+1
        WRITE(IMOL,6) SYM(NN),NF(NN),NO
        WRITE(IMOL,7) (XEXP(NN,J),J=1,NF(NN))
        WRITE(IMOL,7) (COEFF(NN,J),J=1,NF(NN))
        ENDDO
      ENDDO
      DO J=1,NVBOS
        READ(IOENGI,'(A40)') TITLE
        WRITE(IMOL,8) TITLE
      ENDDO
      CLOSE(IMOL)
C
 1    FORMAT('NATOMS=',I4,'   NBONDS=',I4,'  NAOS=',I4,'   NMOS=',I4,
     &'  NPLOTS=',I4,/,
     &'PLANE=',A8,'  KOLOR=1 ANGSTROMS FORMAT (5X,5E15.8)')
 2    FORMAT(A2,3F20.10)
 3    FORMAT(A2)
 10   FORMAT(F8.4,/,4F8.4)
 4    FORMAT('BONDATOMS ',40I3)
 5    FORMAT('PLOTMOS ',20I3)
 6    FORMAT(A1,2I3)
 7    FORMAT(1P,5E14.6,:,' >')
 8    FORMAT(A40)
 9    FORMAT(I2,I3,1P,5E15.8)
 102  FORMAT(' $END')
 104  FORMAT(A2,I6)
      RETURN
      END

      SUBROUTINE GMSPLT(ATMSYM)
C
C     Calculates MOLPLT output.
C
      IMPLICIT NONE
      CHARACTER*1 SYM
      CHARACTER*2 ATMSYM(92)
      CHARACTER*3 FUNIT(10)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*64 FSTR,RWFFILE,INTFILE,INPFILE,LOCFILE
      INTEGER IKINDS(92),KOLORS(92),I,J,NKINDS,IMOL,NF,JJ,KATOM,
     & MAXATM,MAXSHL,LENFIL,IOUTVB,NATOM,NELE,NSPIN,NBASIS,NATNUM,NATBAS
      DOUBLE PRECISION XEXP,COEFF,ENREP,XYZ,CARBON,SIZE
      PARAMETER (MAXSHL=200,MAXATM=100)
      COMMON /SEEING/ XEXP(MAXSHL,30),COEFF(MAXSHL,30),SYM(MAXSHL),
     &NF(MAXSHL),JJ(MAXSHL),KATOM(MAXATM),IMOL
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      DATA KOLORS/5,14,          2*11,10,1,4,2,15,14,
     *    2*11,10,6,9,7,3,14,    2*11,10*8,4*10,9,14,
     *    2*11,10*8,4*10,12,14,  2*11,14*13,10*8,5*10,14,
     *    2*11,4*13/
C     These colours and the atomic sizes below are taken from
C     Gamess for consistency with plots made from Gamess.
C
C     Create mol file for molplt to display molecular frame.
C
      DO I=1,92
        IKINDS(I)=0
      ENDDO
      INPFILE=FSTR(1:LENFIL)//'.mol'
      OPEN(UNIT=IMOL,FILE=INPFILE,STATUS='UNKNOWN',
     1  ACCESS='SEQUENTIAL',FORM='FORMATTED')
C
C     Find NKINDS - the number of different atoms
C
      DO I=1,NATOM
         IKINDS(NATNUM(I)) = 1
      ENDDO
      NKINDS = 0
      DO I=1,92
        IF (IKINDS(I).EQ.1) NKINDS=NKINDS+1
      ENDDO
      WRITE(IMOL,2) NATOM,NKINDS
      WRITE(IMOL,101) FSTR
 101  FORMAT(A40)
      CARBON = 0.3D+00
      DO I=1,92
        IF (IKINDS(I).EQ.1) THEN
                      SIZE=0.75D+00* CARBON
          IF(I.GT. 2) SIZE=          CARBON
          IF(I.GT.10) SIZE=1.6D+00 * CARBON
          IF(I.GT.18) SIZE=1.7D+00 * CARBON
          IF(I.GT.36) SIZE=1.9D+00 * CARBON
          IF(I.GT.54) SIZE=2.0D+00 * CARBON
          IF(I.GT.86) SIZE=2.1D+00 * CARBON
          WRITE(IMOL,3) ATMSYM(I),KOLORS(I),SIZE
        ENDIF
      ENDDO
      DO I=1,NATOM
        WRITE(IMOL,1) ATMSYM(NATNUM(I)), (XYZ(J,I),J=1,3)
      ENDDO
      CLOSE(IMOL)
      RETURN
 1    FORMAT(A2,3F12.7)
 2    FORMAT('NATOM=',I3,'   NKINDS=',I3)
 3    FORMAT(A2,I4,F4.1)
      END
      SUBROUTINE XYZFILE(XYZ,NATOM,NATNUM,TITLE)
      IMPLICIT NONE
      CHARACTER*1 SYM
      CHARACTER*2 ATMSYM
      CHARACTER*40 TITLE
      INTEGER IMOL,NF,JJ,KATOM,MAXATM,MAXSHL,NATOM,I,J,NATNUM(1000)
      DOUBLE PRECISION XYZ(3,1000),XEXP,COEFF
      PARAMETER (MAXSHL=200,MAXATM=100)
      COMMON /SEEING/ XEXP(MAXSHL,30),COEFF(MAXSHL,30),SYM(MAXSHL),
     &NF(MAXSHL),JJ(MAXSHL),KATOM(MAXATM),IMOL
      COMMON /ATOMSY/ ATMSYM(92)
      WRITE(IMOL,'(I4)') NATOM
      WRITE(IMOL,'(A40)') TITLE
      DO I=1,NATOM
        WRITE(IMOL,1) ATMSYM(NATNUM(I)), (XYZ(J,I),J=1,3)
      ENDDO
      RETURN
 1    FORMAT(A2,3F12.7)
      END
      SUBROUTINE MOLEKEL(RWRK,IERR,LMOLK)
C
C     Calculates MOLEKEL input as MKL file or MOLDEN input as MOLDEN format file.
C
      IMPLICIT NONE
      DOUBLE PRECISION RWRK(*),EIG(1000)
      CHARACTER*1 SYM
      CHARACTER*2 ATMSYM
      CHARACTER*3 FUNIT(10)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*64 FSTR,RWFFILE,INTFILE,INPFILE,LOCFILE
      INTEGER IMOL,NF,JJ,KATOM,MAXATM,MAXSHL,NATOM,NELE,
     & NSPIN,NBASIS,NATNUM,NATBAS,LENFIL,IOUTVB
      INTEGER NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,NVIR,MBASIS,
     &LPTALL,LHYBRD,MELE,MSPIN,MNORBIT,MLORBIT,MWIN,MSTR,METHOD,IBASIS,
     &NOCC,NOBIAS,NEPS,NOTROT,LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF
      INTEGER NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD,N2DADD,NB1ADD,NB2ADD,KEY
      INTEGER IERR,ITOTCH,I,J,MULTI,ICHARGE,NN,KK,K,NOCB,
     &IFIRST,ILAST,NCCC
      LOGICAL LMOLK
      DOUBLE PRECISION XEXP,COEFF,ENREP,XYZ,X
      PARAMETER (MAXSHL=200,MAXATM=100)
      COMMON /SEEING/ XEXP(MAXSHL,30),COEFF(MAXSHL,30),SYM(MAXSHL),
     &NF(MAXSHL),JJ(MAXSHL),KATOM(MAXATM),IMOL
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(99),MSPIN(99),MNORBIT(99),MLORBIT(99),MWIN(99),
     &MSTR(99),METHOD(99),IBASIS(9999),NOCC(9999),NOBIAS,NEPS,NVIR,
     &NOTROT(5000),LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(99)
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
      COMMON /ATOMSY/ ATMSYM(92)
      IERR=0
      IF(LMOLK) THEN
        INPFILE=FSTR(1:LENFIL)//'.mkl'
      ELSE
        INPFILE=FSTR(1:LENFIL)//'.molf'
      ENDIF
      OPEN(UNIT=IMOL,FILE=INPFILE,STATUS='UNKNOWN',
     1  ACCESS='SEQUENTIAL',FORM='FORMATTED')
      IF(LMOLK) THEN
        WRITE(IMOL,'("$MKL")') 
C       COORD BLOCK
        WRITE(IMOL,'("$COORD")') 
        ITOTCH = 0
        DO I=1,NATOM
          WRITE(IMOL,4) NATNUM(I), (XYZ(J,I),J=1,3)
          ITOTCH = ITOTCH + NATNUM(I)
        ENDDO
        WRITE(IMOL,'("$END")')
C       CHAR_MULT BLOCK
        MULTI=NSPIN+1
        ICHARGE = ITOTCH - NELE
        WRITE(IMOL,105) '$CHAR_MULT'
        WRITE(IMOL,'(2I2)') ICHARGE,MULTI
        WRITE(IMOL,'("$END")')
C       BASIS BLOCK
        WRITE(IMOL,107) '$BASIS'
      ELSE
        WRITE(IMOL,'("[Molden Format]")')
C       COORD BLOCK
        WRITE(IMOL,'("[Atoms] Angs")')
        DO I=1,NATOM
          WRITE(IMOL,91) ATMSYM(NATNUM(I)), I, NATNUM(I), 
     &      (XYZ(J,I),J=1,3)
        ENDDO
C       BASIS BLOCK
        WRITE(IMOL,'("[GTO]")')
      ENDIF
C
C     GAUSSIAN AND GAMESS BASIS ROUTINES ARE IN vb2gau.src AND vb2gms.src.
C
      NN=0
      X=1.0D0
C     WRITE(IOUTVB,'(10(1X,A1))') (SYM(I),I=1,20)
C     WRITE(IOUTVB,'(10I4)') (KATOM(I),I=1,NATOM)
      DO I=1,NATOM
        IF(.NOT.LMOLK) WRITE(IMOL,'(I4)') I
        DO KK=1,KATOM(I)
          NN=NN+1
          IF (SYM(NN).EQ.'S') THEN
            K=1
            GOTO 11
          ENDIF
          IF (SYM(NN).EQ.'P') THEN
            K=3
            GOTO 11
          ENDIF
          IF (SYM(NN).EQ.'D') THEN
            K=6
            GOTO 11
          ENDIF
          IF (SYM(NN).EQ.'F') THEN
            K=10
            GOTO 11
          ENDIF
          IF(LMOLK) THEN
            IF (SYM(NN).EQ.'G') THEN
               WRITE(IOUTVB,10)
               IERR=1
               GOTO 1
            ELSE
              K=16
              GOTO 11
            ENDIF
          ENDIF
          WRITE(IOUTVB,12) SYM(NN)
          IERR=1
          GOTO 1
 11       IF(LMOLK) THEN
            WRITE(IMOL,5) K, SYM(NN),X
          ELSE
            WRITE(IMOL,3) SYM(NN),NF(NN)
          ENDIF
          DO J=1,NF(NN)
            WRITE(IMOL,6) XEXP(NN,J),COEFF(NN,J)
          ENDDO
        ENDDO
        IF(LMOLK) THEN
          IF (I.ne.NATOM) WRITE(IMOL,108)
        ELSE
          WRITE(IMOL,*)
        ENDIF
      ENDDO
      NOCB=NB1ADD(NSUB+1)-1
      NCCC=NOCB
      IF(LTEST.EQ.1) NCCC=(NELE-NSPIN)/2 + NSPIN
      DO I=1,NCCC
        EIG(I)=2.0D0
        IF(LTEST.NE.1.AND.IBASIS(I).GT.1) EIG(I)=1.0D0
      ENDDO
      IF(LMOLK) THEN
        WRITE(IMOL,'("$END")')
C       COEFF_ALPHA BLOCK
        WRITE(IMOL,'(A12)') '$COEFF_ALPHA'
        IFIRST=1
 14     ILAST=IFIRST+4
        IF(ILAST.GT.NCCC) ILAST=NCCC
        WRITE(IMOL,7) (IBASIS(J),J=IFIRST,ILAST)
        WRITE(IMOL,9) (EIG(J),J=IFIRST,ILAST)
        DO I=1,NBASIS
          WRITE(IMOL,8) (RWRK(I+(J-1)*NBASIS),J=IFIRST,ILAST)
        ENDDO
        IFIRST=IFIRST+5
        IF(ILAST.LT.NCCC) GOTO 14
        WRITE(IMOL,'("$END")')
C       OCC_ALPHA BLOCK
        WRITE(IMOL,109) '$OCC_ALPHA'
        WRITE(IMOL,9) (EIG(J),J=1,NCCC)
        WRITE(IMOL,'("$END")')
C       CHARGES BLOCK
C       Zero charges added just to prevent window popping up.
        WRITE(IMOL,110) '$CHARGES'
        DO I=1,NATOM
          WRITE(IMOL,111) 0.0
        ENDDO
        WRITE(IMOL,'("$END")')
      ELSE
        WRITE(IMOL,'("[MO]")')
        DO J=1,NCCC
          WRITE(IMOL,95) EIG(J)
          WRITE(IMOL,96)
          WRITE(IMOL,97) 1.0D0
          DO I=1,NBASIS
            WRITE(IMOL,98) I,RWRK(I+(J-1)*NBASIS)
          ENDDO
        ENDDO
      ENDIF
 1    CLOSE(IMOL)
      RETURN
 3    FORMAT(4X,A1,I6)
 4    FORMAT(I2,3F12.7)
 5    FORMAT(I2,4X,A1,F7.1)
 6    FORMAT(4X,3F20.10)
 7    FORMAT(5(I2,2X))
 8    FORMAT(5F10.5)
 9    FORMAT(5F5.1)
 10   FORMAT(' MOLEKEL CAN NOT HANDLE G FUNCTIONS.',/
     & ' ABORTING WRITING MOLEKEL mkl FILE.'/)
 12   FORMAT(' INCORRECT SYMBOL',A1,/
     & ' ABORTING WRITING MOLEKEL mkl FILE.'/)
 91   FORMAT(A2,2I5,1X,3F20.10)
 95   FORMAT(" Ene= ",F12.4)
 96   FORMAT(" Spin= Alpha")
 97   FORMAT(" Occup= ",F10.6)
 98   FORMAT(I4,F16.11)
 105  FORMAT(A10)
 107  FORMAT(A6)
 108  FORMAT('$$')
 109  FORMAT(A10)
 110  FORMAT(A8)
 111  FORMAT(F6.4)
      END
      SUBROUTINE BASNORM(NATOM)
C
C     Normalises the basis set read from the SOURCEDAT file
C     in BASISA.
C     Similar normalisation is not needed in BASISM & BASISG
C
      IMPLICIT NONE
      CHARACTER*1 SYM
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      INTEGER LENFIL,IOUTVB,IMOL,NF,JJ,KATOM,MAXATM,MAXSHL,NATOM,
     &  NN,I,KK,K1,J1,J2
      DOUBLE PRECISION C(30),XEXP,COEFF,PI,PI32,E,EE,X,Y,Z
      PARAMETER (MAXSHL=200,MAXATM=100)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /SEEING/ XEXP(MAXSHL,30),COEFF(MAXSHL,30),SYM(MAXSHL),
     &NF(MAXSHL),JJ(MAXSHL),KATOM(MAXATM),IMOL
C
      PI = ACOS(-1.0D0)
      PI32 = PI * SQRT(PI)
      NN=0
      DO I=1,NATOM
        DO KK=1,KATOM(I)
          NN=NN+1
          K1 = NF(NN)
          X=0.0D0
          DO J1=1,K1
            E=2*XEXP(NN,J1)
            EE=PI32/(E*SQRT(E))
            IF (SYM(NN).EQ.'S') THEN
              Z=EE
              GOTO 12
            ENDIF
            IF (SYM(NN).EQ.'P') THEN
              Z=0.5D0*EE/E
              GOTO 12
            ENDIF
            IF (SYM(NN).EQ.'D') THEN
              Z=0.75D0*EE/(E*E)
              GOTO 12
            ENDIF
C           IF (SYM(NN).eq.'F') THEN
C             Z=(1.5D1*EE/8.0D0)/(E**3)
C             GOTO 12
C           ENDIF
C           IF (SYM(NN).eq.'G') THEN
C             Z=(1.05D2*EE/1.6D1)/(E**4)
C             GOTO 12
C           ENDIF
            GOTO 1
 12         C(J1) = COEFF(NN,J1)/SQRT(Z)
          ENDDO
          DO J1=1,K1
            DO J2=1,J1
              E=XEXP(NN,J1)+XEXP(NN,J2)
              EE=E*SQRT(E)
              IF (SYM(NN).EQ.'S') THEN
                Z=1.0D0/EE
                GOTO 11
              ENDIF
              IF (SYM(NN).EQ.'P') THEN
                Z=0.5D0/(E*EE)
                GOTO 11
              ENDIF
              IF (SYM(NN).EQ.'D') THEN
                Z=0.75D0/(E*E*EE)
                GOTO 11
              ENDIF
C             IF (SYM(NN).eq.'F') THEN
C               Z=(1.5D1/8.0D0)/(E**3*EE)
C               GOTO 11
C             ENDIF
C             IF (SYM(NN).eq.'G') THEN
C               Z=(1.05D2/1.6D1)/(E**4*EE)
C               GOTO 11
C             ENDIF
              GOTO 1
 11           Y = C(J1)*C(J2)*Z
              IF(J1.NE.J2) Y = Y + Y
              X = X + Y
            ENDDO
          ENDDO
          X = 1.0D0/SQRT(X*PI32)
C         WRITE(IOUTVB,2) SYM(NN),K1,X
          DO J1=1,K1
C           Y = COEFF(NN,J1)
            COEFF(NN,J1) = COEFF(NN,J1)*X
C           WRITE(IOUTVB,'(3F20.8)') XEXP(NN,J1),Y,COEFF(NN,J1)
          ENDDO
        ENDDO
      ENDDO
      RETURN
 1    WRITE(IOUTVB,3)
      RETURN
 3    FORMAT(' INCORRECT SYMBOL')
C2    FORMAT(' NORMALISATION FOR ',A1,' SIZE ',I2,' IS',F14.8)
      END
      SUBROUTINE CUBE(C2,TITLE,NP,KVB,IIIP,LFIRST)
C
C     Calculates CUBE output - one per orbital.
C
      IMPLICIT NONE
      CHARACTER*1 SYM
      CHARACTER*3 FUNIT(10)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*40 TITLE
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      LOGICAL LFIRST
      INTEGER IT,JT,MXATM,LENFIL,IOUTVB,IMOL,NF,JJ,KATOM,
     & MAXATM,MAXSHL,NATOM,NELE,NSPIN,NBASIS,NATNUM,NATBAS,I,J,NP,KVB,
     & IIIP,N,K,I1,I2,I3,L,NVB,NATNO
      DOUBLE PRECISION XEXP,COEFF,ENREP,XYZ,ATMCHG,TOANG,ZERO,XE,C,X,
     & Y,Z,SUM,XNORM
      DOUBLE PRECISION C1(3,1000),XMIN(3),XMAX(3),XX(3),
     & C2(1000),XORB(1000)
      PARAMETER (MXATM=2000,MAXSHL=200,MAXATM=100)
      COMMON /CUBEC/ XE(1000),C(1000),IT(1000),JT(1000)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /SEEING/ XEXP(MAXSHL,30),COEFF(MAXSHL,30),SYM(MAXSHL),
     &NF(MAXSHL),JJ(MAXSHL),KATOM(MAXATM),IMOL
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      COMMON /ATMCH/ ATMCHG(MXATM),NATNO(MXATM)
      DATA TOANG /0.529177249D0/
      DATA ZERO /0.0D00/
      IF (LFIRST) WRITE(IOUTVB,100)
      WRITE(IMOL,102) TITLE
      IF (LFIRST) WRITE(IOUTVB,102) TITLE
      WRITE(IMOL,103)
      IF (LFIRST) WRITE(IOUTVB,103)
C     THIS MAY BE NEEDED AS WE ARE FOOLING THE SYSTEM THAT
C     VB ORBITALS ARE THE SAME AS MO'S.
      DO I=1,NATOM
        DO J=1,3
          C1(J,I)=XYZ(J,I)/TOANG
        ENDDO
      ENDDO
      DO J=1,3
        XMIN(J)=1.0D8
        XMAX(J)=-1.0D8
        DO I=1,NATOM
          IF (C1(J,I).LT.XMIN(J)) XMIN(J)=C1(J,I)
          IF (C1(J,I).GT.XMAX(J)) XMAX(J)=C1(J,I)
        ENDDO
        XMAX(J)=XMAX(J)+6.0D0
        XMIN(J)=XMIN(J)-6.0D0
        XX(J) = (XMAX(J)-XMIN(J))/(NP-1)
      ENDDO
      N=-NATOM
      WRITE(IMOL,101) N,(XMIN(K),K=1,3)
      IF (LFIRST) WRITE(IOUTVB,101) N,(XMIN(K),K=1,3)
      WRITE(IMOL,101) NP,XX(1),ZERO,ZERO
      WRITE(IMOL,101) NP,ZERO,XX(2),ZERO
      WRITE(IMOL,101) NP,ZERO,ZERO,XX(3)
      IF (LFIRST) THEN
        WRITE(IOUTVB,101) NP,XX(1),ZERO,ZERO
        WRITE(IOUTVB,101) NP,ZERO,XX(2),ZERO
        WRITE(IOUTVB,101) NP,ZERO,ZERO,XX(3)
      ENDIF
      DO I=1,NATOM
        WRITE(IMOL,101) NATNO(I),ATMCHG(I),(C1(J,I),J=1,3)
        IF (LFIRST) WRITE(IOUTVB,101) NATNO(I),
     &    ATMCHG(I),(C1(J,I),J=1,3)
      ENDDO
      NVB = 1
      WRITE(IMOL,104) NVB,KVB
      IF (LFIRST) WRITE(IOUTVB,104) NVB,KVB
      IF (LFIRST) WRITE(IOUTVB,*) 
C
      XNORM=0.0D0
      DO I1=1,NP
        X=XMIN(1) + (I1-1)*XX(1)
        DO I2=1,NP
          Y=XMIN(2) + (I2-1)*XX(2)
          DO I3=1,NP
            Z=XMIN(3) + (I3-1)*XX(3)
            SUM = 0.0D0
            CALL ORBPT(SUM,C1,C2,XE,X,Y,Z,JT,IT,IIIP)
            XORB(I3) = SUM
C           SUM ORBITAL NORMALIZATION
            XNORM=XNORM+SUM*SUM
          ENDDO
          WRITE(IMOL,105) (XORB(L),L=1,NP)
        ENDDO
      ENDDO
C     Calculates normalisation of VB orbital from CUBE points
      XNORM = XNORM * (XX(1) * XX(2) * XX(3))
      WRITE(IOUTVB,'(/," NORMALIZATION OF ORBITAL IS:",F12.6)') XNORM
      WRITE(IOUTVB,
     & '(" IF THIS IS FAR BELOW 1.0, YOU NEED MORE CUBE POINTS",/)')
      RETURN
 100  FORMAT(" CUBE FILE HEADERS",/)
 101  FORMAT(I4,4F12.6)
 102  FORMAT(1X,A40)
 103  FORMAT(' SCF Molecular Orbitals')
 104  FORMAT(10I4)
 105  FORMAT(6E13.5)
      END
      SUBROUTINE GENGRID(C2,TITLE,NP,IGRD,IIIP)
C
C     Calculates DSV GRID output - one per orbital.
C
C     IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      IMPLICIT NONE
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*40 TITLE
      INTEGER IT,JT,NP
      INTEGER NPX,NPY,NPZ,IXMIN,IYMIN,IZMIN
      DOUBLE PRECISION XL,YL,ZL,HALFPI,GRIDSIZE,GRIDX
      DOUBLE PRECISION XMIN0,YMIN0,ZMIN0
      INTEGER NATOM,NELE,NSPIN,NBASIS,NATNUM,NATBAS
      INTEGER I,J,IGRD,I1,I2,I3,IIIP
      DOUBLE PRECISION ENREP,XYZ
      DOUBLE PRECISION TOANG,XE,C,X,Y,Z,SUM
      DOUBLE PRECISION C2(1000),C1(3,1000),XMIN(3),XMAX(3)
      COMMON /CUBEC/ XE(1000),C(1000),IT(1000),JT(1000)
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      DATA TOANG /0.529177249D0/
      GRIDSIZE = 8.0D0/NP
      HALFPI = 90.0D0
      WRITE(IGRD,'(A40)')TITLE
      DO I=1,NATOM
        DO J=1,3
          C1(J,I)=XYZ(J,I)/TOANG
        ENDDO
      ENDDO
      DO J=1,3
        XMIN(J)=1.0D8
        XMAX(J)=-1.0D8
        DO I=1,NATOM
          IF (C1(J,I).LT.XMIN(J)) XMIN(J)=C1(J,I)
          IF (C1(J,I).GT.XMAX(J)) XMAX(J)=C1(J,I)
        ENDDO
        XMAX(J)=XMAX(J)+6.0D0
        XMIN(J)=XMIN(J)-6.0D0
      ENDDO
      XL = (XMAX(1) - XMIN(1))*TOANG
      YL = (XMAX(2) - XMIN(2))*TOANG
      ZL = (XMAX(3) - XMIN(3))*TOANG
      NPX = 1+INT(XL/GRIDSIZE)
      NPY = 1+INT(YL/GRIDSIZE)
      NPZ = 1+INT(ZL/GRIDSIZE)
      IXMIN = INT((TOANG*XMIN(1))/GRIDSIZE)
      IYMIN = INT((TOANG*XMIN(2))/GRIDSIZE)
      IZMIN = INT((TOANG*XMIN(3))/GRIDSIZE)
      GRIDX = GRIDSIZE/TOANG
      XMIN0 = IXMIN*GRIDX
      YMIN0 = IYMIN*GRIDX
      ZMIN0 = IZMIN*GRIDX
C
C     WRITE HEADER
C
      WRITE(IGRD,'("(1F15.10)")')
      WRITE(IGRD,'(6F8.3)')XL,YL,ZL,HALFPI,HALFPI,HALFPI
      WRITE(IGRD,'(3I5)')NPX-1,NPY-1,NPZ-1
      WRITE(IGRD,'(7I5)')1,IXMIN,0,IYMIN,0,IZMIN,0
C
      DO I1=1,NPZ
        Z=ZMIN0 + (I1-1)*GRIDX
        DO I2=1,NPY
          Y=YMIN0 + (I2-1)*GRIDX
          DO I3=1,NPX
            X=XMIN0 + (I3-1)*GRIDX
            SUM = 0.0D0
            CALL ORBPT(SUM,C1,C2,XE,X,Y,Z,JT,IT,IIIP)
            IF(SUM .GT. 9.9D0) SUM = 9.9D0
            IF(SUM .LT. -9.9D0) SUM =-9.9D0
C           WRITE(IGRD,'(F6.3)') SUM
            WRITE(IGRD,'(F9.6)') SUM
          ENDDO
        ENDDO
      ENDDO
      RETURN
      END
      SUBROUTINE BASISA(NATOM)
      IMPLICIT NONE
      CHARACTER*1 SYM
      CHARACTER*3 FUNIT(10),CHAR3
      CHARACTER*5 CHAR5
      CHARACTER*40 SOURCEDAT,RECORD
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      INTEGER IMOL,NF,JJ,KATOM,MAXATM,MAXSHL,LENFIL,IOUTVB,NATOM,
     &IOUNIT,NN,I,J,K
      DOUBLE PRECISION XEXP,COEFF,E,C
      PARAMETER (MAXSHL=200,MAXATM=100)
      COMMON /SEEING/ XEXP(MAXSHL,30),COEFF(MAXSHL,30),SYM(MAXSHL),
     &NF(MAXSHL),JJ(MAXSHL),KATOM(MAXATM),IMOL
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
C     GET BASIS SET INTO APPROPRIATE FORM IN STAND-ALONE VB2000
C
      IOUNIT=99
      SOURCEDAT=FSTR(1:LENFIL)//'.source'
      OPEN(IOUNIT,FILE=SOURCEDAT,STATUS='UNKNOWN',ACCESS='SEQUENTIAL',
     $FORM='FORMATTED')
      REWIND(IOUNIT)
 11   CONTINUE
      READ(IOUNIT,'(A5)') CHAR5
      IF (CHAR5.NE.'ATOMS') GOTO 11
      NN=0
      DO I=1,NATOM
        READ(IOUNIT,'(A5)') CHAR5
        KATOM(I)=0
 13     CONTINUE
        READ(IOUNIT,'(A40)') RECORD
        READ(RECORD(1:3),'(A3)') CHAR3
        IF(CHAR3.EQ.'END') GOTO 12
        KATOM(I)=KATOM(I)+1
        NN=NN+1
        IF(NN.GT.MAXSHL) CALL ABORT0("MAXSHL>100")
        READ(RECORD(1:40),*) JJ(NN),SYM(NN),NF(NN)
C       WRITE(IOUTVB,'(I3,3X,A1,3X,I3)') JJ(NN),SYM(NN),NF(NN)
        DO J=1,NF(NN)
          READ(IOUNIT,*) K,E,C
          XEXP(NN,J)=E
          COEFF(NN,J)=C
C         WRITE(IOUTVB,'(3F15.8)') E,COEFF(NN,J),C
        ENDDO
        GOTO 13
 12     CONTINUE
      ENDDO
      CALL BASNORM(NATOM)
      IF(IOUNIT.GT.1000000) WRITE(*,*)K
      RETURN
      END
      DOUBLE PRECISION FUNCTION VBRAND(I)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      SAVE RSEED
      IF(I.NE.0) RSEED = I
C     IF(ABS(RSEED) .LT. 0.001) RSEED = 1.0D0
      IF(ABS(RSEED) .LT. 0.1D0) RSEED = RSEED + 0.5D0
      TEMP    = ABS(SIN(RSEED*100.0D0))
      ITEMP   = INT(TEMP*1.0D7)
      RSEED   = TEMP*1.0D7-ITEMP
      VBRAND  = RSEED
      RETURN
      END
      DOUBLE PRECISION FUNCTION XCLOCK()
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     Getting CPU time can also be machine dependant.
C000  REAL*4 TARRAY(2)
CSMI  REAL*4 TARRAY(2)
CGAU  REAL*4 TARRAY(2)
CG98  REAL*4 TARRAY(2)
C
C     ETIME exists on most, but not all systems.
C
C000  TARRAY(1) = 0.0
C000  TARRAY(2) = 0.0
C000  XCLOCK = ETIME(TARRAY)
C000  XCLOCK = DBLE(TARRAY(1) + TARRAY(2))
CSMI  TARRAY(1) = 0.0
CSMI  TARRAY(2) = 0.0
CSMI  XCLOCK = ETIME(TARRAY)
CSMI  XCLOCK = DBLE(TARRAY(1) + TARRAY(2))
CGAU  TARRAY(1) = 0.0
CGAU  TARRAY(2) = 0.0
CGAU  XCLOCK = ETIME(TARRAY)
CGAU  XCLOCK = DBLE(TARRAY(1) + TARRAY(2))
CG98  TARRAY(1) = 0.0
CG98  TARRAY(2) = 0.0
CG98  XCLOCK = ETIME(TARRAY)
CG98  XCLOCK = DBLE(TARRAY(1) + TARRAY(2))
C
C     Use TSECND from GAMESS UNPORT, so all machine dependent stuff
C     is handled there.
CGMS  CALL TSECND(TIM)
CGMS  XCLOCK = TIM
C
C     This is for SALFORD compiler, but is not well tested.
C     CALL CLOCK@(X)
C     XCLOCK = X
C     Earlier we used MCLOCK, but this needs different scaling factors
C     on different systems, as seen below.
C     linux g77  XCLOCK=MCLOCK()/1000000.0D0
C     Other unix  XCLOCK=MCLOCK()/100.0D0
C     Cygwin g77  XCLOCK=MCLOCK()/1000.0D0
C     Intel 1.6 ifc  XCLOCK=MCLOCK()/100.0D0
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     FUNCTION: DATA STOREAGE UTILITY
C               IT IS USED FOR ANY DATA STOREAGE. THE DATA HAS A DYNAMIC RANGE
C               AND THE DATA NEED TO BE SHARED BY DIFFERENT PARTS OF THE PROGRAM
C               IN THE CURRENT IMPLEMENTATION, EACH DATA RECORD IS STORED ON
C               A DIFFERENT FILE, AND THE DATA CAN BE READ AND WRITTEN.
C
C     NOTES:
C               IDATYP: DATA TYPE. 0=DOUBLE, 1=INTEGER
C               IRWTYP: READ/WRITE FLAG. 0=READ, 1=WRITE
C               ISIZE:  DATA ARRAY SIZE.
C               IDREC:  DATA RECORD ID.
C               INTDAT: INTEGER ARRAY.
C               DBLDAT: DOUBLE ARRAY.
C
C               THE IOTEMP UNIT IS USED. IT IS ASSUMED THAT THIS IO UNIT
C               WILL BE OPENED AND CLOSED IN THIS SUBROUTINE.
C
C     HISTORY:
C               First created: April 29, 2006
C
C     AUTHOR:
C               Jiabo Li
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE DSTORE(IDATYP, IRWTYP, ISIZE, IDREC, INTDAT, DBLDAT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION INTDAT(*),DBLDAT(*)
      CHARACTER*80 FILENAME
      CHARACTER*3 FUNIT(10)
C     CHARACTER*64 FSTR,RWFFILE,INTFILE,INPFILE,LOCFILE,FILE
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      CALL GETIOUNIT('IOTEMP  ',IOTEMP)
C
C     IDREC = 1, SPIN-DENSITY
C     IDREC = 2, ANY THING ELSE
C     ........
C
      IF(IDREC.LT.1.OR.IDREC.GT.5) CALL ABORT0("DSTORE0001")
      IF(IDREC.EQ.2) FILENAME=FSTR(1:LENFIL)//'.TEMP02'
      IF(IDREC.EQ.3) FILENAME=FSTR(1:LENFIL)//'.TEMP03'
      IF(IDREC.EQ.4) FILENAME=FSTR(1:LENFIL)//'.TEMP04'
      IF(IDREC.EQ.5) FILENAME=FSTR(1:LENFIL)//'.TEMP05'
      IF(IDREC.EQ.6) FILENAME=FSTR(1:LENFIL)//'.TEMP06'
      IF(IDREC.EQ.7) FILENAME=FSTR(1:LENFIL)//'.TEMP07'
      IF(IDREC.EQ.8) FILENAME=FSTR(1:LENFIL)//'.TEMP08'
      IF(IDREC.EQ.9) FILENAME=FSTR(1:LENFIL)//'.TEMP09'
      OPEN(UNIT=IOTEMP, FILE=FILENAME, STATUS="UNKNOWN",
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      IF(IRWTYP.EQ.0.AND.IDATYP.EQ.0) THEN
         READ(IOTEMP)(DBLDAT(I),I=1,ISIZE)
      ELSE IF(IRWTYP.EQ.1.AND.IDATYP.EQ.0) THEN
         WRITE(IOTEMP)(DBLDAT(I),I=1,ISIZE)
      ELSE IF(IRWTYP.EQ.0.AND.IDATYP.EQ.1) THEN
         READ(IOTEMP)(INTDAT(I),I=1,ISIZE)
      ELSE IF(IRWTYP.EQ.1.AND.IDATYP.EQ.1) THEN
         WRITE(IOTEMP)(INTDAT(I),I=1,ISIZE)
      ELSE
         WRITE(IOUTVB,*)"UNKNOWN DATA TYPE AND READ/WRITE FLAG"
         CALL ABORT0("DSTORE0002")
      END IF
      CLOSE(IOTEMP)
      RETURN
      END
      SUBROUTINE SPDEN(N,NS,NSTR,S,NORB,NVBSTR,CSTR,SDMATR)
      IMPLICIT REAL*8 (A-H,O-Z)
C     PARAMETER (MAXNP = 380000)
      COMMON /NFACT/NFAC0(20),NFACX(20)
C     DIMENSION NPER(MAXNP),NA(20)
C     DIMENSION NB(20),NGRAPH(3,40),NG2(40),NG3(40),NAA(20),NBB(20)
      DIMENSION NA(20),NB(20),NGRAPH(3,40),NG2(40),NG3(40)
      DIMENSION S(*),NVBSTR(N,NSTR),CSTR(NSTR)
C     DIMENSION SDMATR(*),NPRE(100000)
      DIMENSION SDMATR(*)
      IF(NORB*(NORB+1)/2.GT.20000) CALL ABORT0("SPDEN00001")
      DO I=1, NORB*(NORB+1)/2
         SDMATR(I) = 0.0D0
      END DO
      CALL PERINI(N)
      DO I=1, 20
      NA(I) = I
      END DO
      SUM = 0.0D0
      SDSUM = 0.0D0
      N10 = N
      IF(N .GT. 10) THEN
         N10 = 10
      END IF
      NFAC10 = 1
      DO I=11, N
      NFAC10 = NFAC10*I
      END DO
      DO IDX0=1,NFAC10
      DO IDX=1,NFACX(N10)
        DO I=1, N
          NB(I) = I
        END DO
        CALL PERGEN0(N,IDX0,IDX,NB)
        CALL DLAMD0(N,NS,NA,NB,D11,NGRAPH)
        DO I=1, N
           NG2(I) = NGRAPH(2,NB(I))
           NG3(I) = NGRAPH(3,NB(I))
        END DO

C
C       LOOP STRUCTURE PAIRS
C
        DO IA=1, NSTR
        DO IB=1, IA
          PROD = D11*CSTR(IA)*CSTR(IB)
          IF(IA.NE.IB) PROD = PROD+PROD
          DO K=1,N
          NAK = NVBSTR(K,IA)
          NBK = NVBSTR(NB(K),IB)
            IF(NAK.GE.NBK) THEN
              NABK = NAK*(NAK-1)/2+NBK
            ELSE
              NABK = NBK*(NBK-1)/2+NAK
            END IF
            PROD = PROD*S(NABK)
          END DO
          SUM = SUM + PROD
          DO K=1, N
            IF(NG2(K).EQ.1) THEN
              SDSUM = SDSUM + PROD*NG3(K)
            END IF
          END DO
          DO K=1,N
          NAK = NVBSTR(K,IA)
          NBK = NVBSTR(NB(K),IB)
            IF(NAK.GE.NBK) THEN
              NABK = NAK*(NAK-1)/2+NBK
            ELSE
              NABK = NBK*(NBK-1)/2+NAK
            END IF
C
C           IF(NG2(K).EQ.0) THEN THEN D11 IS ZERO, THUS NO CONTRIBUTION
C
            IF(ABS(S(NABK)).GT.0.00000001D0.AND.NG2(K).EQ.1) THEN
              SDMATR(NABK) = SDMATR(NABK) + NG3(K)*PROD/S(NABK)
            END IF
          END DO
        END DO
        END DO
C
      END DO
      END DO
      SDSUM = SDSUM/SUM
      SDSUM = 0.0D0
      DO I=1, NORB
        DO J=1, I
        IJ=I*(I-1)/2+J
        SDSUM = SDSUM + SDMATR(IJ)*S(IJ)
C
C       DEFACTOR
C
        IF(I.NE.J) SDMATR(IJ) = SDMATR(IJ)*0.5D0
        END DO
      END DO
      SDSUM = SDSUM/SUM
      RETURN
      END
      SUBROUTINE PERINI(N)
      COMMON /NFACT/NFAC0(20),NFAC(20)
      IF(N.GT.20) CALL ABORT0("PERINI0001")
      NFAC(1) = 1
      DO I=2, 12
      NFAC(I) = NFAC(I-1)*I
      END DO
      NFAC0(10) = 1
      DO I=11,16
      NFAC0(I) = I*NFAC0(I-1)
      END DO
      RETURN
      END
      SUBROUTINE PERGEN0(N,IDX0,IDX1,NPER)
      COMMON /NFACT/NFAC0(20),NFACX(20)
C     DIMENSION NPER(*), NP(20),NPT(20)
      DIMENSION NPER(*), NP(20)
      N0 = 0
      IF(N.GT.10) N0 = N-10
      NREM = IDX0
      DO I=1, N0
        NP(I) = (NREM-1)/NFAC0(N-I) + 1
        NREM  = NREM - NFAC0(N-I)*(NP(I)-1)
      END DO
      NREM = IDX1
      DO I=N0+1, N-1
        NP(I) = (NREM-1)/NFACX(N-I) + 1
        NREM  = NREM - NFACX(N-I)*(NP(I)-1)
      END DO
        NP(N) = NREM
      DO I=1, N
        NTMP = NPER(I)
        NPER(I) = NPER(I-1+NP(I))
        NPER(I-1+NP(I)) = NTMP
      END DO
      RETURN
      END
      SUBROUTINE DLAMD0(N,K,MA,MB,D11,NGRAPH)
C
C     This is subroutine to calculation the overlap of two Rumber
C     patterns. N: number of indexes. K: number of unpaired indexes.
C     MA, MB: Rumer patterns. The paired indexes come first, followed
C     by unpaired indexes.
C
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER (NOR=40)
      DIMENSION MA(N),MB(N),IA(60),IB(60),NA(60),NB(60),NPART(NOR)
      DATA NPART/2,1,4,3,6,5,8,7,10,9,12,11,14,13,16,15,18,17,20,19
     &,22,21,24,23,26,25,28,27,30,29,32,31,34,33,36,35,38,37,40,39/
      DIMENSION NTEMP(NOR)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      NFRAG=0
      NSIZE=0
      FACTOR = 1.0D0
      M=(N-K)/2
      L=M+K
      L2=L*2
      LOOPS1=0
      LOOPS2=0
      NCC=0
      DO 100 I=1,K
      NA(I+I-1)=MA(N-K+I)
      NB(I+I-1)=MB(N-K+I)
      NA(I+I)  =NOR+I
      NB(I+I)  =NOR+I
      IA(NA(I+I-1))=I+I-1
      IB(NB(I+I-1))=I+I-1
      IA(NA(I+I))  =I+I
  100 IB(NB(I+I))  =I+I
      DO 110 I=K+1,N
      NA(K+I)=MA(I-K)
      NB(K+I)=MB(I-K)
      IA(NA(K+I))=K+I
  110 IB(NB(K+I))=K+I
 200  CONTINUE
      DO 300 I=1,L2
      IF(NA(I).EQ.0) GOTO 300
      NI=NA(I)
      NT=NA(I)
      GOTO 400
 300  CONTINUE
      GOTO 900
 400  CONTINUE
      ILEFT=0
      IRIGHT=0
 500  CONTINUE
      NCC=NCC+1
      IF(NT.GT.NOR)ILEFT=1
      NSIZE=NSIZE+1
      NTEMP(NSIZE)=NA(IA(NT))
      NA(IA(NT))=0
      NPIANT=NPART(IA(NT))
      NTA=NA(NPIANT)
      IF(NTA.GT.NOR) IRIGHT=1
          IF(ILEFT*IRIGHT.NE.0) THEN
          D11=0.0D0
          FACTOR=0.0D0
C         RETURN
          END IF
      NSIZE=NSIZE+1
      NTEMP(NSIZE)=NA(NPIANT)
      NA(NPIANT)=0
      IBA=IB(NTA)
      NT=NB(NPART(IBA))
      IF(NT.EQ.0.OR.NCC.GT.100) THEN
      WRITE(IOUTVB,*)'WRONG DATA IN DLAMBDA ROUTINE'
      WRITE(IOUTVB,*)MA
      WRITE(IOUTVB,*)MB
      CALL ABRTVB
      END IF
      IF(NT.EQ.NI) THEN
            IF(ILEFT+IRIGHT.GT.0) THEN
            CALL FINDALLGRAPH(NFRAG,NTEMP,NSIZE,NGRAPH)
            LOOPS2=LOOPS2+1
            NSIZE=0
            ELSE
            LOOPS1=LOOPS1+1
            CALL FINDALLGRAPH(NFRAG,NTEMP,NSIZE,NGRAPH)
            NSIZE=0
            END IF
      GOTO 200
      ELSE
      GOTO 500
      END IF
 900  CONTINUE
      D11=FACTOR*(-1)**(LOOPS2+LOOPS1+L)/(2.0D0)**(M-LOOPS1)
      RETURN
      END
C
C     NFRAG: INDEX OF GRPAH
C     IFAC:  PARITY FACTOR
C     IEO:   EVEN-ODD INDEX. 0=EVEN, 1= ODD, 2=ISLAND
C

      SUBROUTINE FINDALLGRAPH(NFRAG,NTEMP,NSIZE,NGRAPH)
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER (NOR=40)
      DIMENSION NTEMP(*),NGRAPH(3,*),NA(40)
      NCT=0
      NA(1) = 0
C
C     SCANE NTEMP
C
      ICHAIN=0
      DO I=1, NSIZE
        IF(NTEMP(I).GT.NOR) THEN
        ICHAIN=1
        END IF
      END DO
C     WRITE(IOUTVB,*)"NSIZE, ICHAIN =",NSIZE,ICHAIN
      IF(ICHAIN.EQ.0) THEN
        NFRAG = NFRAG + 1
        DO I=1, NSIZE
        NGRAPH(1,NTEMP(I)) = NFRAG
        NGRAPH(2,NTEMP(I)) = 2
        NGRAPH(3,NTEMP(I)) = 0
        END DO
        RETURN
      END IF
 100  IF(NTEMP(1).LE.NOR) THEN
      NCT=NCT+1
        NX = NTEMP(1)
        DO I=2,NSIZE
        NTEMP(I-1) = NTEMP(I)
        END DO
        NTEMP(NSIZE)=NX
      END IF
      IF(NTEMP(1).LE.NOR.AND.NCT.LT.NSIZE) GOTO 100
C
C     CUT
C
      NX = 0
      DO I=1, NSIZE
        IF(NTEMP(I).GT.NOR)  THEN
            IF(NX.GT.0) THEN
              IEO = NX-2*(NX/2)
              IFAC = -1
              DO J=1, NX
                IFAC=-IFAC
                NGRAPH(1,NA(J)) = NFRAG
                NGRAPH(2,NA(J)) = IEO
                NGRAPH(3,NA(J)) = IFAC
              END DO
            END IF
          NFRAG=NFRAG+1
          NX = 0
        ELSE IF(NTEMP(I).LE.NOR) THEN
          NX = NX+1
          NA(NX) = NTEMP(I)
        END IF
      END DO
      IF(NX.GT.0) THEN
        IEO = NX-2*(NX/2)
        IFAC = -1
        DO J=1, NX
           IFAC=-IFAC
           NGRAPH(1,NA(J)) = NFRAG
           NGRAPH(2,NA(J)) = IEO
           NGRAPH(3,NA(J)) = IFAC
        END DO
      END IF
      RETURN
      END
      SUBROUTINE SPDATM(SDM,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
CGMS  COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      DIMENSION SDM(*),W(*),SDATOM(1000),NBAS2A(4000)
      MT = NBASIS
      MMS = 1
      MMH = MMS + NBASIS*(NBASIS+1)/2
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL READ1E(IAO1E,W(MMS),W(MMH),MT)
      DO I=1, NATOM
      SDATOM(I) = 0.0D0
      END DO
      IC = 0
      DO I=1, NATOM
        DO J=1, NATBAS(I)
        IC = IC + 1
        NBAS2A(IC) = I
        END DO
      END DO
      IC = 0
      DO I=1, NBASIS
        II = NBAS2A(I)
        DO J=1, I
        JJ = NBAS2A(J)
        FACTOR = 1.0D0
        IF(I.EQ.J) FACTOR = 0.5D0
        IC = IC + 1
        SDATOM(II) = SDATOM(II) + SDM(IC)*W(MMS-1+IC)*FACTOR
        SDATOM(JJ) = SDATOM(JJ) + SDM(IC)*W(MMS-1+IC)*FACTOR
        END DO
      END DO
CGMS  CALL DAWRIT(IDAF,IODA,SDM(1),IC,20,0)
C GAU  CALL FILEIO(1,-530,IC,SDM(1),0)
C
C     WRITE SDM TO A TEMP FILE
C
C     IDATYP= 0
C     IRWTYP= 1
C     ISIZE = NBASIS*(NBASIS+1)/2
C     IDREC = 1
C     CALL DSTORE(IDATYP, IRWTYP, ISIZE, IDREC, INTDAT, SDM)
      WRITE(IOUTVB,1000)
      WRITE(IOUTVB,1100)
      SDSUM = 0.0D0
      DO I=1, NATOM
      SDSUM = SDSUM + SDATOM(I)
      WRITE(IOUTVB,1200)I,SDATOM(I)
      END DO
      WRITE(IOUTVB,*)
      WRITE(IOUTVB,1300)
 1000 FORMAT(/1X,"SPIN DENSITY ON ATOMS",/1X,"---------------------")
 1100 FORMAT(1X,"ATOM      DENSITY",/)
 1200 FORMAT(1X,I4,1X,F12.5)
 1300 FORMAT(1X,"---------------------",/)
      RETURN
      END
C
C     COMPUTE DELOCALIZATION PENALTY CONTRIBUTION TO DERIVATIVES
C     VBSCF PART
C
C     VBOS: VB ORBITALS
C     NBRIL: VBSCF PARAMETERS
C     INDX:  BRILL TABLE
C     MGRP:  GROUP INDEX
C     SXBAR: SX_BAR
C     DEV:   DERIVATIVES OF DELOCALIZATION
C     HESS:  HESSIAN OF DELOCALIZATION
C     LOCATM(I): LOCALIZATION ATOM OF ORBITAL I
C                = 0. NO LOCALIZATION
C                = X. NUMBER OF ATOMS THAT ORBITAL I LOCALIZED ON.
C
C                THIS TABLE CAN BE READ IN OR DETECTED AUTOMATICALLY
C
C     History: First created in May 2007
C              Jiabo Li
C
C
      SUBROUTINE DPENALTY1(VBOS,NORB,S,NBRIL,INDX,MGRP,SXBAR,DEV,HESS,
     &                     LASTITER,ICONV,MITER,TDELOCAL,ITER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*8  BONDLAB
      CHARACTER*80 NUMBER,FLAG
      PARAMETER (MAXBRIL= 10000)
      PARAMETER (MAXBAS = 1000)
      PARAMETER (MAXATM = 500)
      PARAMETER (MAXMSK = 10000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      COMMON /DPENAL/DPW,DEPS,DPWMAX,DENERGY,NITER,MAXMICRO
      COMMON /LMODAT/VMO(500000),VLMO(500000),LMOLAB(2,1000),
     &LMOATM(5,1000),PGM(100000),ENGLMO(1000),BONDLAB(1000),MCLMO(5,80),
     &LHFLAG
      DIMENSION VBOS(NBASIS,*),S(*),INDX(2,*),DEV(*),HESS(*)
      DIMENSION SXBAR(*),NAOATM(2000)
      DIMENSION LOCATM(MAXBAS),DEVT(MAXBRIL),LAMASK(MAXMSK)
C               ,MASK(1000)
      DIMENSION LMASK(MAXBAS),ITEMP(MAXATM),SN(MAXBAS)
      IF(NBRIL.GT.MAXBRIL) CALL ABORT0("DPENALTY0A")
      IF(NORB*NATOM.GT.MAXMSK) CALL ABORT0("DPENALTY1A")
      IF(NORB.GT.MAXBAS) CALL ABORT0("DPENALTY2A")
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      WSTART = 10.0D+10
      WDX    = 0.1D0
      TDELOCAL = 0.0D0
      CALL LOCTOR(IOENGI,'$WSTART',7,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*,ERR=101)WSTART
      IF(MITER.EQ.1) THEN
        DPW     = WSTART
        NITER   = 0
        MAXMICRO= 100
        DENERGY = 1.0D0
      ENDIF
      DO I=1, NORB
         LOCATM(I)=0
         II = (I-1)*NATOM
         DO J=1, NATOM
           LAMASK(II+J) = 0
         END DO
         SN(I) = 1.0D0
      END DO
C
C     THIS ASSUMES THAT ONLY ONE GROUP FOR THE WHOLE MOL
C
      IF(LHFLAG.EQ.1) THEN
      DO I=1, NORB
         LOCATM(I)=LMOATM(5,I)
         II = (I-1)*NATOM
         DO J=1, 4
           JJ = LMOATM(J,I)
           IF(JJ.GT.0) LAMASK(II+JJ) = 1
         END DO
C        WRITE(IOUTVB,*)"LATOM =",LOCATM(I)
C        WRITE(IOUTVB,'(10I5)')(LAMASK(II+J),J=1,NATOM)
      END DO
      ENDIF
C
C     COMPUTE NORMALIZATION
C
      NUMBER   = '0123456789'
      NC1      = 1+MGRP/10
      NC2      = 1+MGRP-10*(NC1-1)
      FLAG     = '$'
      FLAG(2:2)= NUMBER(NC1:NC1)
      FLAG(3:3)= NUMBER(NC2:NC2)
      FLAG(4:11)='LENHANCE'
      NADD=1
C     NBA2=NBASIS*(NBASIS+1)/2
      DO I=1, NATOM
        DO J=1, NATBAS(I)
        NAOATM(NADD) = I
        NADD= NADD+1
        END DO
      END DO
C
C     READ PARAMETERS OF VB STRUCTURES
C
      CALL LOCTOR(IOENGI,'$DPWEIGHT',9,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*,ERR=101)WDX
      CALL LOCTOR(IOENGI,FLAG,11,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*,ERR=101) LVBO
C
C     NEW FORMULA FOR DYNAMIC ADJUSTING OF WD
C
      IF(MITER.EQ.1.AND.ITER.EQ.1) THEN
      WRITE(IOUTVB,'(" $LENHANCE APPLIES WITH",I4," CONDITIONS")') LVBO
      WRITE(IOUTVB,'(" $DPWEIGHT IS ",D20.3,/)') WDX
      ENDIF
      WD = DPW + 0.1D0*NITER*DPW
      IF(NITER.GT.10) WD = DPW + DPW
      IF(WDX .LT. WD) WD = WDX
C
       DO I=1, LVBO
        READ(IOENGI,*,ERR=101)IVBO,LATM,(ITEMP(J),J=1,LATM)
        LOCATM(IVBO) = LATM
        II = (IVBO-1)*NATOM
        DO J=1, LATM
           LAMASK(II+ITEMP(J)) = 1
        END DO
       END DO
      ELSE
       RETURN
      END IF
C
C     COMPUTE DELOCALIZATION
C
      IF(LASTITER.EQ.1.AND.ICONV.EQ.1) THEN
       WRITE(IOUTVB,*)
         WRITE(IOUTVB,1000)MGRP
         WRITE(IOUTVB,1001)
      ENDIF
       DO IX=1, NORB
         IF(LOCATM(IX).GT.0) THEN
         IXX = (IX-1)*NATOM
         DO J=1, NBASIS
            LMASK(J) = 0
            IF(LAMASK(IXX+NAOATM(J)).EQ.0) LMASK(J) = 1
         END DO
         JK = 0
         DO J=1,NBASIS
           JJ = J*(J-1)/2
           DO K=1,J
           JK=JK+1
           SXBAR(JK)=S(JK)*LMASK(J)*LMASK(K)
           IF(NAOATM(J).NE.NAOATM(K)) SXBAR(JK) = 0.0D0
C          Use only diagonal elements
C          IF(J.NE.K) SXBAR(JK) = 0.0D0
           END DO
         END DO
         CALL SPROD(NBASIS, VBOS(1,IX),SXBAR,VBOS(1,IX),DELOCAL)
         TDELOCAL = TDELOCAL + DELOCAL*WD
         IF(LASTITER.EQ.1.AND.ICONV.EQ.1) THEN
         WRITE(IOUTVB,'(" VBO INDEX =",I3, " DELOCALIZATION =", F10.5)')
     &             IX,DELOCAL
         END IF
        END IF
       END DO
 1000 FORMAT(" DELOCALIZATION FOR VB ORBITALS OF GROUP ",I2)
 1001 FORMAT(" =============================================")
C
      DO I=1, NBRIL
        IX = INDX(1,I)
        IK = INDX(2,I)
        IF(LOCATM(IX).EQ.0) THEN
          DEVT(I)=0.0D0
        ELSE
C
C     COMPUTE DEV
C
          IXX = (IX-1)*NATOM
          DO J=1, NBASIS
             LMASK(J) = 0
             IF(LAMASK(IXX+NAOATM(J)).EQ.0) LMASK(J) = 1
          END DO
          JK = 0
          DO J=1,NBASIS
            JJ = J*(J-1)/2
            DO K=1,J
            JK=JK+1
            SXBAR(JK)=S(JK)*LMASK(J)*LMASK(K)
            IF(NAOATM(J).NE.NAOATM(K)) SXBAR(JK) = 0.0D0
C           IF(J.NE.K) SXBAR(JK) = 0.0D0
            END DO
          END DO
          DEVT(I) = 0.0D0
          CALL SPROD(NBASIS, VBOS(1,IX),SXBAR,VBOS(1,IK),XSBARK)
          CALL SPROD(NBASIS, VBOS(1,IX),SXBAR,VBOS(1,IX),XSBARX)
          CALL SPROD(NBASIS, VBOS(1,IX),S, VBOS(1,IK),XSK)
          DEVT(I) = DEVT(I) + (2.0D0*XSBARK/SN(IX)
     &                      - 2.0D0*XSBARX*XSK/(SN(IX)*SN(IX)))*WD
        END IF
      END DO
      DO I=1, NBRIL
       IX = INDX(1,I)
       IK = INDX(2,I)
       IF(LOCATM(IX).NE.0) THEN
        IXX = (IX-1)*NATOM
        DO J=1, NBASIS
           LMASK(J) = 0
           IF(LAMASK(IXX+NAOATM(J)).EQ.0) LMASK(J) = 1
        END DO
        JK = 0
        DO J=1,NBASIS
          DO K=1,J
          JK=JK+1
          SXBAR(JK)=S(JK)*LMASK(J)*LMASK(K)
          IF(NAOATM(J).NE.NAOATM(K)) SXBAR(JK) = 0.0D0
C         IF(J.NE.K) SXBAR(JK) = 0.0D0
          END DO
        END DO
        DO J=1,I
         J1 = INDX(1,J)
         J2 = INDX(2,J)
C
C        CASE 1: J1 == IX
C
         IF(J1.EQ.IX) THEN
           CALL SPROD(NBASIS,VBOS(1,IK),SXBAR,VBOS(1,J2),P1)
           CALL SPROD(NBASIS,VBOS(1,IX),SXBAR,VBOS(1,IK),P2)
           CALL SPROD(NBASIS,VBOS(1,IX),S,VBOS(1,J2),P3)
           CALL SPROD(NBASIS,VBOS(1,IX),SXBAR,VBOS(1,J2),P4)
           CALL SPROD(NBASIS,VBOS(1,IX),S,VBOS(1,IK),P5)
           CALL SPROD(NBASIS,VBOS(1,IX),SXBAR,VBOS(1,IX),P6)
           CALL SPROD(NBASIS,VBOS(1,IK),S,VBOS(1,J2),P7)
           IJ = I*(I-1)/2+J
           HESS(IJ) = HESS(IJ) + (2*P1/SN(IX)-4*P2*P3/(SN(IX)*SN(IX))-
     &               4*P4*P5/(SN(IX)*SN(IX)) - 2*P6*P7/(SN(IX)*SN(IX))+
     &               8*P5*P6*P3/(SN(IX)*SN(IX)*SN(IX)))*WD
         END IF
        END DO
       END IF
      END DO
      DO I=1, NBRIL
        DEV(I) = DEV(I) + DEVT(I)
      END DO
      RETURN
 101  WRITE(IOUTVB,*)"WRONG DATA 1"
      END
C
C     COMPUTE OVERLAP PENALTY CONTRIBUTION TO DERIVATIVES
C     VBSCF PART
C
C     VBOS: VB ORBITALS
C     NBRIL: VBSCF PARAMETERS
C     INDX:  BRILL TABLE
C     MGRP:  GROUP INDEX
C     DEV:   DERIVATIVES OF DELOCALIZATION
C     HESS:  HESSIAN OF DELOCALIZATION
C
C     History: First created in Oct 2009
C              Jiabo Li
C
      SUBROUTINE OPENALTY(NORB,S,NBRIL,INDX,MGRP,DEV,HESS,
     &                    LASTITER,ICONV,TOVERLAP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
C     CHARACTER*8  BONDLAB
C     CHARACTER*80 NUMBER,FLAG
      PARAMETER (MAXBRIL= 10000)
      PARAMETER (MAXBAS = 1000)
C     PARAMETER (MAXATM = 500)
      PARAMETER (MAXMSK = 10000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
C     COMMON /DPENAL/DPW,DEPS,DPWMAX,DENERGY,NITER,MAXMICRO
C     COMMON /LMODAT/VMO(500000),VLMO(500000),LMOLAB(2,1000),
C    &LMOATM(5,1000),PGM(100000),ENGLMO(1000),BONDLAB(1000),MCLMO(5,80),
C    &LHFLAG
      DIMENSION S(*),INDX(2,*),DEV(*),HESS(*)
C     DIMENSION NAOATM(2000)
      DIMENSION DEVT(MAXBRIL)
C     DIMENSION LOCATM(MAXBAS),DEVT(MAXBRIL),LAMASK(MAXMSK)
C     DIMENSION LMASK(MAXBAS),ITEMP(MAXATM),SN(MAXBAS)
      IF(NBRIL.GT.MAXBRIL) CALL ABORT0("OPENALTY0A")
      IF(NORB*NATOM.GT.MAXMSK) CALL ABORT0("OPENALTY1A")
      IF(NORB.GT.MAXBAS) CALL ABORT0("OPENALTY2A")
      WOX    = 0.001D0
      TOVERLAP = 0.0D0
C     HPI = 3.14159265358979D0/2.0D0
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$WOX',4,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)WOX

C
C     COMPUTE OVERLAP
C
      IF(LASTITER.EQ.1.AND.ICONV.EQ.1) THEN
         WRITE(IOUTVB,*)
         WRITE(IOUTVB,1000)MGRP
         WRITE(IOUTVB,1001)
      ENDIF
      DO I=1, NORB
        II = I*(I-1)/2
        DO J=1, I-1
           IJ = II+J
           SIJ = S(IJ)
           IF(SIJ.GT.1.0D0)  SIJ = 1.0D0
           IF(SIJ.LT.-1.0D0) SIJ = -1.0D0
           A = ACOS(SIJ)
           TOVERLAP = TOVERLAP + COS(2.0D0*A)
        END DO
      END DO
      TOVERLAP = TOVERLAP*WOX
 1000 FORMAT(" OVERLAP SUM  FOR VB ORBITALS OF GROUP ",I2)
 1001 FORMAT(" =============================================")
C
C     COMPUTE DEV
C
      DO I=1, NBRIL
       I1 = INDX(1,I)
       I2 = INDX(2,I)
       I12 = IJ00(I1,I2)
       S12 = S(I12)
       IF(S12.GT.1.0D0)  S12 = 1.0D0
       IF(S12.LT.-1.0D0) S12 = -1.0D0
       A = ACOS(S12)
       DEVT(I) = 2.0D0*SIN(2.0D0*A)*SIN(A)
        DO J=1,I
         J1 = INDX(1,J)
         J2 = INDX(2,J)
         J12 = IJ00(J1,J2)
         IJ = I*(I-1)/2+J
         IF(I12.EQ.J12) THEN
           HESS(IJ) = HESS(IJ) - (4.0D0*COS(2.0D0*A)*SIN(A)
     &                           +2.0D0*SIN(2.0D0*A)*COS(A))*SIN(A)*WOX
         ENDIF
        END DO
      END DO
      DO I=1, NBRIL
        DEV(I) = DEV(I) + WOX*DEVT(I)
      END DO
      RETURN
      END
C
C     PROD = V2*S*V1
C
      SUBROUTINE SPROD(N, V1, S, V2, PROD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION S(*),V1(*),V2(*),V3(1000)
      PROD = 0.0D0
      CALL MATSYM(N,1,S,V1,V3)
      DO J=1, N
         PROD = PROD + V2(J)*V3(J)
      END DO
      RETURN
      END
C
C     COMPUTE DELOCALIZATION PENALTY CONTRIBUTION TO DERIVATIVES
C     RIGID ROTATION PART
C
C     VBON:   VBO of nonorthogonal in AO basis
C     VBOL:   Lowdin orbitals in AO basis
C     BASLOC: VBO in Lowdin basis (local express)
C
C     First created: May 21, 2007
C     Fixed boundary check bugs:  April 4 2009
C
C     Author:        Jiabo Li
C
      SUBROUTINE DPENALTY2(VBON,VBOL,BASLOC,NB2ADD,S,
     &NHDIM,NHDADD,NHESADD,IRDEX,SXBAR,DEV,HESS,NSUB,MLORBIT,MNORBIT,
     &NHGRP,MITER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*8 BONDLAB
      CHARACTER*80 NUMBER,FLAG
      PARAMETER (MAXWRK = 1000000)
      PARAMETER (MAXHDM = 10000)
      PARAMETER (MAXLOC = 1000)
      PARAMETER (MAXNBS = 1000)
      PARAMETER (MAXMSK = 10000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      COMMON /DPENAL/DPW,DEPS,DPWMAX,DENERGY,NITER,MAXMICRO
      COMMON /LMODAT/VMO(500000),VLMO(500000),LMOLAB(2,1000),
     &LMOATM(5,1000),PGM(100000),ENGLMO(1000),BONDLAB(1000),MCLMO(5,80),
     &LHFLAG
      DIMENSION VBON(NBASIS,*),VBOL(NBASIS,*),BASLOC(*)
      DIMENSION IRDEX(3,*),S(*),DEV(*),NHDADD(*),NHESADD(*)
      DIMENSION NB2ADD(*),MLORBIT(*),MNORBIT(*)
      DIMENSION SXBAR(*),NAOATM(2000),HESS(*)
      DIMENSION LOCATM(MAXLOC),GDW(MAXLOC),LOCORB(MAXLOC)
      DIMENSION DEVT(MAXHDM),IGROUP(MAXNBS),LOCIDX(MAXNBS)
      DIMENSION LAMASK(MAXMSK),LMASK(MAXNBS),ITEMP(500)
      DIMENSION NBOADD(100),LBOADD(100)
      DIMENSION SPRODLL(MAXWRK),SPRODLN(MAXWRK)
      IF(NHDIM .GT. MAXHDM) CALL ABORT0("DPENALTY2A")
      IF(NBASIS.GT.MAXNBS)  CALL ABORT0("DPENALTY2B")
      EPS     = 1.0D-10
      SFACTOR = 0.0D0
      WD      = 0.0D0
      WDX     = 0.1D0
      WSTART  = 10.0D+10
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$WSTART',7,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*,ERR=101)WSTART
      IF(MITER.EQ.1) THEN
        DPW     = WSTART
        NITER   = 0
        MAXMICRO= 100
        DENERGY = 1.0D0
      ENDIF
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$SFACTOR',8,IOK,0)
      IF(IOK.EQ.1) THEN
          READ(IOENGI,*)SFACTOR
      END IF
      NORB = 0
      LORB = 0
      NBOADD(1) = 0
      LBOADD(1) = 0
      NLOCORB = 0
      DO I=1, NBASIS
         LOCIDX(I) = 0
      END DO
      DO I=1, NSUB
        NORB = NORB + MLORBIT(I)
        LORB = LORB + MNORBIT(I)
        NBOADD(I+1) = NBOADD(I)+MLORBIT(I)
        LBOADD(I+1) = LBOADD(I)+MNORBIT(I)
        DO J=LBOADD(I)+1, LBOADD(I+1)
           IGROUP(J) = I
        END DO
      END DO
      DO J=LBOADD(NSUB+1)+1,1000
        IGROUP(J) = NSUB+1
      END DO
      IF(NORB*NATOM.GT.MAXMSK) CALL ABORT0("DPENALTY2C")
      DO I=1, NORB
         LOCATM(I)=0
         II = (I-1)*NATOM
         DO J=1, NATOM
           LAMASK(II+J) = 0
         END DO
      END DO
C
C     THIS ASSUMES THAT ONLY ONE GROUP FOR THE WHOLE MOL
C
      IF(LHFLAG.EQ.1) THEN
      DO I=1, NORB
         LOCATM(I)=LMOATM(5,I)
         II = (I-1)*NATOM
         DO J=1, 4
           JJ = LMOATM(J,I)
           IF(JJ.GT.0) LAMASK(II+JJ) = 1
         END DO
         NLOCORB = NLOCORB + 1
         LOCIDX(I) = NLOCORB
         LOCORB(NLOCORB) = I
      END DO
      ENDIF
      NADD=1
      DO I=1, NATOM
        DO J=1, NATBAS(I)
        NAOATM(NADD) = I
        NADD= NADD+1
        END DO
      END DO
      DO I=1, NHGRP
        NDIM = NHDADD(I+1)-NHDADD(I)
        DO J=1, NDIM
          JJ = NHESADD(I)+J*(J-1)/2
C         WRITE(IOUTVB,'(8F10.5)')(HESS(JJ+K),K=1,J)
        END DO
      END DO
C
C     PRINT TRANSFORMATION MATRIX (LOCAL VBO IN LOWDIN BASIS
C
      DO I=1, NSUB
        DO J=1, MLORBIT(I)
         JJ= (J-1)*MNORBIT(I)-1
C        WRITE(IOUTVB,'(I3,7F10.5)')J,(BASLOC(NB2ADD(I)+JJ+K),K=1,MNORBIT(I))
        END DO
      END DO
      NUMBER   = '0123456789'
      LDPEN  = 0
C
C     NEW FORMULA
C
      CALL LOCTOR(IOENGI,'$DPWEIGHT',9,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*,ERR=101)WDX
        IF(DPWMAX.LT.WDX) DPWMAX = WDX
        WD = DPW + 0.1D0*NITER*DPW
        IF(NITER.GT.10) WD = DPW + DPW
        DEPSX = DEPS
        IF(DPW.GT.2.0D0) DEPSX = DEPS/10.0D0
        IF((DENERGY.LT.DEPSX.AND.NITER.GT.10).OR.NITER.GE.MAXMICRO) THEN
          DPW = DPW + DPW
          NITER = 0
          IF(DPW.GT.DPWMAX) DPW = DPWMAX
        ENDIF
        NITER = NITER+1
        IF(WDX .LT. WD) WD = WDX
        IF(NHDIM.EQ.0) RETURN
C
      GDW(NSUB+1) = 0.0D0
      DO MGRP=1, NSUB
        NC1      = 1+MGRP/10
        NC2      = 1+MGRP-10*(NC1-1)
        FLAG     = '$'
        FLAG(2:2)= NUMBER(NC1:NC1)
        FLAG(3:3)= NUMBER(NC2:NC2)
        FLAG(4:11)='LENHANCE'
        GDW(MGRP) = 0.0D0
C
C       READ PARAMETERS OF VB STRUCTURES
C
        CALL LOCTOR(IOENGI,FLAG,11,IOK,0)
        IF(IOK.EQ.1) THEN
        READ(IOENGI,*,ERR=101) LVBO
        DO I=1, LVBO
          READ(IOENGI,*,ERR=101)IVBO,LATM,(ITEMP(J),J=1,LATM)
          LOCATM(NBOADD(MGRP)+IVBO) = LATM
          II = (NBOADD(MGRP)+IVBO-1)*NATOM
          DO J=1, LATM
             LAMASK(II+ITEMP(J)) = 1
          END DO
          IF(LHFLAG.NE.1) THEN
            NLOCORB = NLOCORB + 1
            LOCIDX(NBOADD(MGRP)+IVBO) = NLOCORB
            LOCORB(NLOCORB) = NBOADD(MGRP)+IVBO
          END IF
        END DO
        GDW(MGRP) = WD
        END IF
        IF(WD .GT. EPS) LDPEN = 1
        IF(WD .LT. -EPS) CALL ABORT0("DPENALTY2B")
      END DO
      IF(NLOCORB*NBASIS*NBASIS.GT.MAXWRK) CALL ABORT0("DPENALTY2D")
      IF(LDPEN.EQ.0)  RETURN
C
C     COMPUTE SPRODUCTS
C
      DO M=1, NLOCORB
         KK = LOCORB(M)
         KXX = (KK-1)*NATOM
         DO J=1,NBASIS
            LMASK(J) = 0
            IF(LAMASK(KXX+NAOATM(J)).EQ.0) LMASK(J) = 1
         END DO
         JL = 0
         DO J=1,NBASIS
           DO L=1, J
           JL = JL + 1
           SXBAR(JL)=S(JL)*LMASK(J)*LMASK(L)
           IF(NAOATM(J).NE.NAOATM(L)) SXBAR(JL)=0.0D0
C          IF(J.NE.L) SXBAR(JL) = 0.0D0
           END DO
         END DO
         DO IA = 1, NBASIS
         DO IB = 1, NBASIS
           CALL SPROD(NBASIS,VBOL(1,IA),SXBAR,VBOL(1,IB), ALSB)
           CALL SPROD(NBASIS,VBOL(1,IA),SXBAR,VBON(1,IB), ANSB)
           MMMM = (M-1)*NBASIS*NBASIS
           IAB = MMMM + (IA-1)*NBASIS+IB
           SPRODLL(IAB) = ALSB
           SPRODLN(IAB) = ANSB
         END DO
         END DO
      END DO
C
C     COMPUTE DERIVATIVES
C
      DO I=1, NHDIM
        IA = IRDEX(1,I)
        JB = IRDEX(2,I)
        MG = IRDEX(3,I)
        IAG = IGROUP(IA)
        JBG = IGROUP(JB)
        IAL = IA - LBOADD(IAG)
        JBL = JB - LBOADD(JBG)
        DEVT(I)=0.0D0
        HESST = 0.0D0
        II = I - NHDADD(MG)
        I2 = NHESADD(MG) + II*(II+1)/2
        DO K=1, MLORBIT(IAG)
          FACTOR = BASLOC(NB2ADD(IAG)-1+(K-1)*MNORBIT(IAG)+IAL)
          FACTOR2= FACTOR*FACTOR
          KK = NBOADD(IAG) + K
          IF(LOCATM(KK).NE.0.AND.GDW(IAG).GT.EPS) THEN
C
C     COMPUTE DEV
C
          MMMM = (LOCIDX(KK)-1)*NBASIS*NBASIS
          JBKK = MMMM + (JB-1)*NBASIS+KK
          IAKK = MMMM + (IA-1)*NBASIS+KK
          JBB  = MMMM + (JB-1)*NBASIS+JB
          APSA  = SPRODLN(JBKK)
          APPSA = SPRODLN(IAKK)
          APSAP = SPRODLL(JBB)
          DEVT(I) = DEVT(I) + 2*FACTOR*APSA*GDW(IAG)
          HESST   = HESST + (2*FACTOR2*APSAP - 2*FACTOR*APPSA)*GDW(IAG)
          END IF
        END DO
        DO K=1, MLORBIT(JBG)
          FACTOR = BASLOC(NB2ADD(JBG)-1+(K-1)*MNORBIT(JBG)+JBL)
          FACTOR2= FACTOR*FACTOR
          KK = NBOADD(JBG) + K
          IF(LOCATM(KK).NE.0.AND.GDW(JBG).GT.EPS) THEN
C
C     COMPUTE DEV
C
          MMMM = (LOCIDX(KK)-1)*NBASIS*NBASIS
          JBKK = MMMM + (JB-1)*NBASIS+KK
          IAKK = MMMM + (IA-1)*NBASIS+KK
          IAA  = MMMM + (IA-1)*NBASIS+IA
          BPSB  = SPRODLN(IAKK)
          BPPSB = SPRODLN(JBKK)
          BPSBP = SPRODLL(IAA)
          DEVT(I) = DEVT(I) - 2*FACTOR*BPSB*GDW(JBG)
          HESST   = HESST + (2*FACTOR2*BPSBP -2*FACTOR*BPPSB)*GDW(JBG)
          END IF
        END DO
        HESS(I2) = HESS(I2) + HESST + SFACTOR*(GDW(JBG)+GDW(IAG))
C
C       OFF-DIAGONAL ELEMENTS
C
        DO I1=1, I-1
          IA1 = IRDEX(1,I1)
          JB1 = IRDEX(2,I1)
          MG1 = IRDEX(3,I1)
          IAG1 = IGROUP(IA1)
          JBG1 = IGROUP(JB1)
          IF(IAG.NE.IAG1.OR.JBG.NE.JBG1) GOTO 102
          IAL1 = IA1 - LBOADD(IAG1)
          JBL1 = JB1 - LBOADD(JBG1)
          HESST = 0.0D0
          II1 = I1 - NHDADD(MG1)
          I21 = NHESADD(MG1) + II*(II-1)/2 + II1
          DO K1=1, MLORBIT(IAG1)
            FACTOR2 = BASLOC(NB2ADD(IAG1)-1+(K1-1)*MNORBIT(IAG1)+IAL1)*
     &                BASLOC(NB2ADD(IAG1)-1+(K1-1)*MNORBIT(IAG1)+IAL)
            KK1 = NBOADD(IAG1) + K1
            IF(LOCATM(KK1).NE.0.AND.GDW(IAG1).GT.EPS) THEN
C
C     COMPUTE DEV
C
            JBB1 = (LOCIDX(KK1)-1)*NBASIS*NBASIS+(JB-1)*NBASIS+JB1
            APSAP = SPRODLL(JBB1)
            HESST   = HESST + 2*FACTOR2*APSAP*GDW(IAG1)
            END IF
          END DO
          DO K1=1, MLORBIT(JBG1)
            FACTOR2 = BASLOC(NB2ADD(JBG1)-1+(K1-1)*MNORBIT(JBG1)+JBL1)*
     &                BASLOC(NB2ADD(JBG1)-1+(K1-1)*MNORBIT(JBG1)+JBL)
            KK1 = NBOADD(JBG1) + K1
            IF(LOCATM(KK1).NE.0.AND.GDW(JBG1).GT.EPS) THEN
C
C     COMPUTE DEV
C
            IAA1 = (LOCIDX(KK1)-1)*NBASIS*NBASIS+(IA-1)*NBASIS+IA1
            BPSBP = SPRODLL(IAA1)
            HESST   = HESST + 2*FACTOR2*BPSBP*GDW(JBG1)
            END IF
          END DO
          HESS(I21) = HESS(I21) + HESST
 102    CONTINUE
        END DO
      END DO
      DO I=1, NHDIM
        DEV(I) = DEV(I) + DEVT(I)
C       WRITE(IOUTVB,*)"I, DEV(I) =",I, DEV(I)
      END DO
      RETURN
 101  WRITE(IOUTVB,*)"WRONG DATA 2"
      END
      SUBROUTINE VBPOPL(NSUB,MORBIT,RWRK, ICHAPRT,MSIZE)
C
C     Function:
C               Calculates VB Density and Mulliken population analysis
C
C     Note:
C               Currently only atomic charge distribution is computed
C
C     History:
C               First created in March  2009.
C
C     Author:
C               Jiabo Li
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
C     PARAMETER (MXATM=2000)
      DIMENSION MORBIT(*),RWRK(*)
      DIMENSION CHATOM(1000),NBAS2A(10000),CEATOM(1000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /GENINF/ENREP,XYZ(3,1000),NATOM,NELE,NSPIN,NBASIS,
     &               NATNUM(1000),NATBAS(1000),BFLABE(1000),BASNAME
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
      NBA2=NBASIS*(NBASIS+1)/2
      LDMA=LGDMP
      MMS = LDMA+ NBA2
      MMH = MMS + NBA2
      LWK1= MMS
      LWK2= LWK1 + NBA2*2
      LLAST = LWK2
      IF(LLAST.GT.MSIZE) CALL ABORT0("POPANA0201")
      DO I=1,NBA2
         RWRK(LDMA-1+I) =0.0D0
      ENDDO
C
C     BUILD ATOM INDEX
C
      IC=0
      DO I=1, NATOM
        CHATOM(I) = NATNUM(I)
        DO J=1, NATBAS(I)
           IC = IC + 1
           NBAS2A(IC) = I
        END DO
      END DO
C
C     ICHAPRT: CHARGE PRINTING OPTIONS
C     ICHARPT = 0: TOTAL DENSITY
C     ICHAPRT = 1: EACH GROUP ELECTRONS
C
      NOBADD1=NAOBAS
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      DO K=1,NSUB
         CALL MATRAN2(MORBIT(K),NBASIS,RWRK(NOBADD1),RWRK(LWK1),
     &             RWRK(ND1STA-1+N1DADD(K)),RWRK(LDMA),0)
         NOBADD1=NOBADD1+MORBIT(K)*NBASIS
         CALL READ1E(IAO1E,RWRK(MMS),RWRK(MMH),NBASIS)
         DO I=1, NATOM
            CEATOM(I) = 0.0D0
         END DO
         IC = 0
        DO I=1, NBASIS
        II = NBAS2A(I)
         DO J=1, I
         JJ = NBAS2A(J)
         FACTOR = 1.0D0
         IF(I.EQ.J) FACTOR = 0.5D0
         IC = IC + 1
         CHATOM(II) = CHATOM(II)-RWRK(LDMA-1+IC)*RWRK(MMS-1+IC)*FACTOR
         CHATOM(JJ) = CHATOM(JJ)-RWRK(LDMA-1+IC)*RWRK(MMS-1+IC)*FACTOR
         CEATOM(II) = CEATOM(II)-RWRK(LDMA-1+IC)*RWRK(MMS-1+IC)*FACTOR
         CEATOM(JJ) = CEATOM(JJ)-RWRK(LDMA-1+IC)*RWRK(MMS-1+IC)*FACTOR
         END DO
        END DO
C
C     PRINT ELECTRON CHARGES ON ATOMS FOR EACH GROUP
C
      IF(ICHAPRT.EQ.1) THEN
        WRITE(IOUTVB,1010)K
        WRITE(IOUTVB,1110)
        DO I=1, NATOM
          WRITE(IOUTVB,1200)I,CEATOM(I)
        END DO
        WRITE(IOUTVB,*)
        WRITE(IOUTVB,1300)
      END IF
C
C     PRINT ATOMIC CHARGES
C
      IF(K.EQ.NSUB) THEN
        WRITE(IOUTVB,1000)
        WRITE(IOUTVB,1100)
        DO I=1, NATOM
          WRITE(IOUTVB,1200)I,CHATOM(I)
        END DO
        WRITE(IOUTVB,*)
        WRITE(IOUTVB,1300)
      END IF
      ENDDO
 1000 FORMAT(//1X,"MULLIKEN CHARGES ON ATOMS",/1X,
     &          "-------------------------")
 1100 FORMAT(1X," ATOM             CHARGE ",/)
 1200 FORMAT(1X,I4,8X,F12.5)
 1300 FORMAT(1X,"-------------------------",/)
 1010 FORMAT(//1X,"ELECTRON CHARGES ON ATOMS",/1X,
     &            "OF ELECTRON GROUP",I4,/1X,
     &          "-------------------------")
 1110 FORMAT(1X,"ATOM       ELECTRON CHARGE",/)
      RETURN
      END
      SUBROUTINE ORBPT(SUM,C1,C2,XE,X,Y,Z,JT,IT,N)
      IMPLICIT NONE
      DOUBLE PRECISION C2(1000),C1(3,1000),XE(10001),SUM,
     & X,Y,Z,R,XXXX,YYYY,ZZZZ
      INTEGER JT(1000),IT(1000),N,J
      DO J=1,N
        XXXX = X - C1(1,JT(J))
        YYYY = Y - C1(2,JT(J))
        ZZZZ = Z - C1(3,JT(J))
        R = XXXX*XXXX + YYYY*YYYY + ZZZZ*ZZZZ
        R = SQRT(R)
        GOTO (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
     &   19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35)
     &   IT(J)
C       S ORBITALS
 1      SUM = SUM + C2(J) * EXP(-XE(J)*R*R)
        GOTO 99
C       P ORBITALS
 2      SUM = SUM + C2(J) * XXXX * EXP(-XE(J)*R*R)
        GOTO 99
 3      SUM = SUM + C2(J) * YYYY * EXP(-XE(J)*R*R)
        GOTO 99
 4      SUM = SUM + C2(J) * ZZZZ * EXP(-XE(J)*R*R)
        GOTO 99
C       D ORBITALS
 5      SUM = SUM + C2(J) * XXXX * XXXX * EXP(-XE(J)*R*R)
        GOTO 99
 6      SUM = SUM + C2(J) * YYYY * YYYY * EXP(-XE(J)*R*R)
        GOTO 99
 7      SUM = SUM + C2(J) * ZZZZ * ZZZZ * EXP(-XE(J)*R*R)
        GOTO 99
 8      SUM = SUM + C2(J) * XXXX * YYYY * EXP(-XE(J)*R*R)
        GOTO 99
 9      SUM = SUM + C2(J) * XXXX * ZZZZ * EXP(-XE(J)*R*R)
        GOTO 99
 10     SUM = SUM + C2(J) * YYYY * ZZZZ * EXP(-XE(J)*R*R)
        GOTO 99
C       F ORBITALS
 11     SUM = SUM + C2(J) * XXXX * XXXX * XXXX * EXP(-XE(J)*R*R)
        GOTO 99
 12     SUM = SUM + C2(J) * YYYY * YYYY * YYYY * EXP(-XE(J)*R*R)
        GOTO 99
 13     SUM = SUM + C2(J) * ZZZZ * ZZZZ * ZZZZ * EXP(-XE(J)*R*R)
        GOTO 99
 14     SUM = SUM + C2(J) * XXXX * XXXX * YYYY * EXP(-XE(J)*R*R)
        GOTO 99
 15     SUM = SUM + C2(J) * XXXX * XXXX * ZZZZ * EXP(-XE(J)*R*R)
        GOTO 99
 16     SUM = SUM + C2(J) * YYYY * YYYY * XXXX * EXP(-XE(J)*R*R)
        GOTO 99
 17     SUM = SUM + C2(J) * YYYY * YYYY * ZZZZ * EXP(-XE(J)*R*R)
        GOTO 99
 18     SUM = SUM + C2(J) * ZZZZ * ZZZZ * XXXX * EXP(-XE(J)*R*R)
        GOTO 99
 19     SUM = SUM + C2(J) * ZZZZ * ZZZZ * YYYY * EXP(-XE(J)*R*R)
        GOTO 99
 20     SUM = SUM + C2(J) * XXXX * YYYY * ZZZZ * EXP(-XE(J)*R*R)
        GOTO 99
C       G ORBITALS
 21     SUM = SUM + C2(J) *XXXX*XXXX*XXXX*XXXX * EXP(-XE(J)*R*R)
        GOTO 99
 22     SUM = SUM + C2(J) *YYYY*YYYY*YYYY*YYYY * EXP(-XE(J)*R*R)
        GOTO 99
 23     SUM = SUM + C2(J) *ZZZZ*ZZZZ*ZZZZ*ZZZZ * EXP(-XE(J)*R*R)
        GOTO 99
 24     SUM = SUM + C2(J) *XXXX*XXXX*XXXX*YYYY * EXP(-XE(J)*R*R)
        GOTO 99
 25     SUM = SUM + C2(J) *XXXX*XXXX*XXXX*ZZZZ * EXP(-XE(J)*R*R)
        GOTO 99
 26     SUM = SUM + C2(J) *YYYY*YYYY*YYYY*XXXX * EXP(-XE(J)*R*R)
        GOTO 99
 27     SUM = SUM + C2(J) *YYYY*YYYY*YYYY*ZZZZ * EXP(-XE(J)*R*R)
        GOTO 99
 28     SUM = SUM + C2(J) *ZZZZ*ZZZZ*ZZZZ*XXXX * EXP(-XE(J)*R*R)
        GOTO 99
 29     SUM = SUM + C2(J) *ZZZZ*ZZZZ*ZZZZ*YYYY * EXP(-XE(J)*R*R)
        GOTO 99
 30     SUM = SUM + C2(J) *XXXX*XXXX*YYYY*YYYY * EXP(-XE(J)*R*R)
        GOTO 99
 31     SUM = SUM + C2(J) *XXXX*XXXX*ZZZZ*ZZZZ * EXP(-XE(J)*R*R)
        GOTO 99
 32     SUM = SUM + C2(J) *YYYY*YYYY*ZZZZ*ZZZZ * EXP(-XE(J)*R*R)
        GOTO 99
 33     SUM = SUM + C2(J) *XXXX*XXXX*YYYY*ZZZZ * EXP(-XE(J)*R*R)
        GOTO 99
 34     SUM = SUM + C2(J) *YYYY*YYYY*XXXX*ZZZZ * EXP(-XE(J)*R*R)
        GOTO 99
 35     SUM = SUM + C2(J) *ZZZZ*ZZZZ*XXXX*YYYY * EXP(-XE(J)*R*R)
 99     CONTINUE
      ENDDO
      RETURN
      END
