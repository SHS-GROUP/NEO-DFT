C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     Main program
C000  PROGRAM VB2000
CSMI  PROGRAM VB2000
C
C     The earlier version that created an extra Gaussian link, l511, has now 
C     been removed from the current release. This worked well with G98 and G03 
C     but there were some problems with G09. Details are in 'gaussian.README'.
C
C     Lines starting with CGAU are for a new version that creates a stand-alone 
C     code that reads files produced by Gaussian (Version D1 and later). It can 
C     therefore be used by the average Gaussian user who only has access to the 
C     Gaussian executables and can not compile a new link.
C
CGAU  PROGRAM VB2000
C
C     VB2000 embedded in Gamess(US). Details are in 'gamess.README'.
C
CGMS  SUBROUTINE VB2000()
C
C     The solvation effects code is still work in progress. Routines are
C     now set to exit without doing anything. Do not use these routines.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     THIS IS THE APPLICATION LEVEL MAIN PROGRAM
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
CSTA  INCLUDE 'maxwork.inc'
      LOGICAL LEX
      CHARACTER*2 ATMSYM,TEMPSYM(92)
      CHARACTER*3 FUNIT(10)
      CHARACTER*4 DMETH(4)
      CHARACTER*25 COMPILER
      CHARACTER*50 RECORD
      CHARACTER*80 VBPATH
      CHARACTER*64 FSTR,RWFFILE,INTFILE,INPFILE,LOCFILE,FILE
      CHARACTER*64 DENFILE
CGAU  COMMON /IO/ IN, IOUT, IPUNCH, IU, ICHK
      LOGICAL LDENS,LTOT,LGRP,LSD
      COMMON /DCUBE/ IDENS,LDENS,LTOT,LGRP,LSD,DENFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      PARAMETER (MAXBFN=726)
      PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA,MAXGRP=99)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(MAXGRP),MSPIN(MAXGRP),MNORBIT(MAXGRP),
     &MLORBIT(MAXGRP),MWIN(MAXGRP),MSTR(MAXGRP),METHOD(MAXGRP),
     &IBASIS(MAXEXT),NOCC(MAXEXT),NOBIAS,NEPS,NVIR,NOTROT(5000),
     &LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(MAXGRP)
CGMS  COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
CGMS  COMMON /VBINTF/ VBENGY
CGMS  COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /VB2MEM/LOCX,LOCMEM,LOFFS,MEMWRK,MSCRATCH,MHIGH
      COMMON /ATOMSY/ ATMSYM(92)
      DATA TEMPSYM/' H','He','Li','Be',' B',' C',' N',' O',' F','Ne',
     1            'Na','Mg','Al','Si',' P',' S','Cl','Ar',
     2            ' K','Ca','Sc','Ti',' V','Cr','Mn','Fe','Co',
     3            'Ni','Cu','Zn','Ga','Ge','As','Se','Br','Kr','Rb',
     4 'Sr',' Y','Zr','Nb','Mo','Tc','Ru','Rh','Pd','Ag','Cd','In',
     5 'Sn','Sb','Te',' I','Xe','Cs','Ba','La','Ce','Pr','Nd','Pm',
     6 'Sm','Eu','Gd','Tb','Dy','Ho','Er','Tm','Yb','Lu','Hf','Ta',
     7 ' W','Re','Os','Ir','Pt','Au','Hg','Tl','Pb','Bi','Po','At',
     8 'Rn','Fr','Ra','Ac','Th','Pa',' U'/
CLIC  INTEGER*4 LICTEST(1)
CGMS  DATA CHECK  /8HCHECK   /
      DATA DMETH /'DENS','SPIN','VBOS','GRPS'/
C
      DO I=1,92
         ATMSYM(I) = TEMPSYM(I)
      ENDDO
      CALL SETIAA()
      CALL IOVBINIT()
      CALL GETIOUNIT('IOTEMP  ',IOTEMP)
      CALL GETIOUNIT('IOTEMPA ',IOTEMPA)
      CALL GETIOUNIT('IOTEMPB ',IOTEMPB)
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL GETIOUNIT('IOVBORB ',IOVBORB)
      CALL GETIOUNIT('IVBO2E  ',IVBO2E)
      CALL GETIOUNIT('IOVBOLIB',IOVBOLIB)
      CALL GETIOUNIT('IAO2E   ',IAO2E)
      IOVBIN = 5
CGAU  IN = IOVBIN
CGMS  IOVBIN = IR
C     Set IPUNCH = 7 just in case.
CGAU  IPUNCH = 7
      IOUTVB = 6
CGAU  IOUT = IOUTVB
CGMS  IOUTVB = IW
CGAU  ICHK = 8
CGAU  IU = 9
C
      IPNT = 0
      MHIGH = 0
C
C     License check first
C
CLIC  CALL FCHECKLICENSE(LICTEST)
CLIC  IF(LICTEST(1) < 1) CALL ABORT0("NO LICENSE")
C     WRITE(IOUTVB,'(" MHIGH",2I12)') 1,MHIGH
C
C     All machine dependant stuff about random numbers is in subroutine
C     VBRAND at the end of this file. If you have problems, consult the
C     information in that routine.
C
C     Seed Random number generator for later
      ISEED=425001
      X = VBRAND(ISEED)
      ENERGY = X
C     Dummy statement to avoid ftncheck warning on X.
      ENERGY = 0.0D0
C
      IGMS=0
CGMS  IGMS=1
      IF(IGMS.EQ.1) GOTO 20
C
C     Get filename of job.
      CALL GETARG(1,FSTR)
      DO I=1,64
      IF(FSTR(I:I).EQ.' ') THEN
         LENFIL=I-1
         GOTO 1
      ENDIF
      ENDDO
C     With Watcom compiler and maybe others, the 7 lines above
C     can be replaced with:-
C     LENFIL = igetarg(1,FSTR)
C
 1    CONTINUE
      INPFILE=FSTR(1:LENFIL)//'.inp'
      OPEN(UNIT=IOVBIN,FILE=INPFILE,STATUS='OLD',
     1  ACCESS='SEQUENTIAL',FORM='FORMATTED')
C
C     Open IOENGI.
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(10)
      OPEN(UNIT=IOENGI,FILE=FILE,STATUS='UNKNOWN',
     1  ACCESS='SEQUENTIAL',FORM='FORMATTED')
C
      CALL VBINIT(IOVBIN,IOENGI)
C     COMPILER="Compiler: GFORTRAN 4.6.3 "
C     COMPILER="  Compiler: IFORT 12.1.5 "
C     The line below is changed by sed in install files to
C     something like the above lines, otherwise below is default.
      COMPILER="==========+++++=========="
      CALL BANNER(IOUTVB,COMPILER)
CGAU  CALL VBGAU
C
      WRITE(IOUTVB,102) FSTR
 20   CONTINUE
C
CGMS  IF (EXETYP.EQ.CHECK) WRITE(IOUTVB,
CGMS & '(/," THIS IS A RUNTYP=CHECK RUN")')
C
C     Get path from environment variable $VB2000PATH.
      VBPATH = ' '
      CALL GETENV('VB2000PATH',VBPATH)
C
C     If VBPATH is empty, assume it is the current dir
C
      IF (VBPATH .EQ. ' ') VBPATH = '. '
      WRITE(IOUTVB,101) VBPATH
C
C     SAVE VBPATH
C
      CALL SETVBPATH(VBPATH)
C
      LOCFILE=FSTR(1:LENFIL)//'.loc'
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(2)
      OPEN(UNIT=IAO2E,FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(4)
      OPEN(UNIT=IOVBORB,FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(5)
      OPEN(UNIT=IVBO2E,FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(6)
      OPEN(UNIT=IOTEMPA, FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(7)
      OPEN(UNIT=IOTEMPB, FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(9)
      OPEN(UNIT=IOVBOLIB, FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='FORMATTED')
C
      LDENS = .FALSE.
      LTOT = .FALSE.
      LSD = .FALSE.
      LGRP = .FALSE.
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$DENSCUBE',9,IOK,0)
      IF(IOK.EQ.1) THEN 
        LDENS = .TRUE.
        READ(IOENGI,'(A50)') RECORD
        DO I=1,47
          IF(.NOT.LTOT.AND.RECORD(I:I+3).EQ.DMETH(1)) LTOT=.TRUE.
          IF(.NOT.LSD.AND.RECORD(I:I+3).EQ.DMETH(2)) LSD=.TRUE.
          IF(.NOT.LGRP.AND.RECORD(I:I+3).EQ.DMETH(3)) LGRP=.TRUE.
          IF(.NOT.LGRP.AND.RECORD(I:I+3).EQ.DMETH(4)) LGRP=.TRUE.
        ENDDO
        DENFILE=FSTR(1:LENFIL)//'.den'
        IDENS = 26
C       IDENS is unit for density file in DENSCUBE. UNIT 26 is used 
C       only by COSMO code in GAMESS, so seems a safe choice.
      ENDIF
      LHFLAG = 0
      CALL LOCTOR(IOENGI,' LHF/',5,IOK,0)
      IF(IOK.EQ.1) LHFLAG = 1
      CALL LOCTOR(IOENGI,' LHF2',5,IOK,0)
      IF(IOK.EQ.1) LHFLAG = 2
C
C     SCAN RESTART FILE
      CALL LOCTOR(IOENGI,'$RESTARTFILE',12,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*)FILE
      INQUIRE(FILE=FILE,EXIST=LEX)
      IF (.NOT.LEX) THEN
        WRITE(IOUTVB,106) FILE
        CALL ABORT0('MAIN0001  ')
      ENDIF
      OPEN(UNIT=IOTEMP,FILE=FILE,STATUS='UNKNOWN',
     1  ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      WRITE(IOUTVB,103) FILE
      REWIND(IOTEMP)
      REWIND(IOVBORB)
C
C     COPY RESTART FILE FROM IOTEMP TO IOVBORB
C
      CALL CPRESTART(IOTEMP,IOVBORB,LHFLAG)
      CLOSE(IOTEMP)
      END IF
      MEMLIM = 6500000
C
C     Allocate memory dynamically
C
CDYN  REWIND(IOVBIN)
CDYN  CALL LOCTOR(IOVBIN,'$MEMORY',7,IOK,0)
CDYN  IF (IOK.EQ.1) READ(IOVBIN,*) MEMLIM
CDYN  CALL SETMEM(MEMLIM)
C
CGAU  REWIND(IOVBIN)
CGAU  CALL LOCTOR(IOVBIN,'$MEMORY',7,IOK,0)
CGAU  IF (IOK.EQ.1) READ(IOVBIN,*) MEMLIM
CGAU  CALL SETMEM(MEMLIM)
C
CGMS  REWIND(IOVBIN)
CGMS  CALL LOCTOR(IOVBIN,'$MEMORY',7,IOK,0)
CGMS  IF (IOK.EQ.1) READ(IOVBIN,*) MEMLIM
CGMS  CALL CKMEM(MEMMAX)
C     MEMMAX IS LARGEST MEMORY USED BY GAMESS BEFORE ENTRY TO VB2000
CGMS  CALL GOTFM(MEMGMS)
C     MEMGMS IS MEMORY ALLOCATED IN GAMESS $SYSTEM
CGMS  MEMVB = MEMGMS - MEMMAX
C     MEMVB = MAX(FREE GAMESS MEMORY,VB2000 MEMORY ALLOCATION)
CGMS  IF(MEMVB.LE.MEMLIM) MEMVB = MEMLIM
CGMS  MEMLIM = MEMVB
CGMS  WRITE(IOUTVB,5) MEMLIM
CGMS  CALL SETMEM(MEMLIM)
C
CSTA  WRITE(IOUTVB,'(" STATIC MEMORY USE IS:",I12,/)') MEMLIM
      MSCRATCH = MEMLIM
C
C     Start calculation - separate entry for $REACTOR runs and others.
      REWIND(IOVBIN)
      CALL LOCTOR(IOVBIN,'$REACTION',9,IOK,0)
      IF (IOK.EQ.1) THEN
CGAU    WRITE(IOUTVB,
CGAU & '(/," REACTION RUN IS NOT POSSIBLE WITH GAUSSIAN VERSION",/)')
CGAU    CALL ABRTG('VB Error')
C000    CALL REACTOR(IOVBIN,IOENGI)
CSMI    CALL REACTOR(IOVBIN,IOENGI)
CGMS    CALL REACTOR(IOVBIN,IOENGI)
      ELSE
        CALL VBENGINE(ENERGY)
CGMS    VBENGY = ENERGY
      END IF
C
      CLOSE(IOVBORB)
      CLOSE(IVBO2E)
      CLOSE(IOVBOLIB)
      CLOSE(IOTEMPA)
      CLOSE(IOTEMPB)
      CLOSE(IOENGI)
      CLOSE(IAO2E)
      CLOSE(97)
C
C     Release memory
C
CDYN  CALL FREEMEM()
CGMS  CALL FREEMEM()
CGAU  CALL FREEMEM()
C

C     Now return to Gamess or Gaussian correctly.
CGMS  RETURN
CGAU  CALL VBGAU2
C
C 2   FORMAT(/,' Input files',/,' ===========',/,' RWF FILE is ',A64)
C 3   FORMAT(' INT FILE is ',A64)
C 4   FORMAT(' Standard input is ',A64)
 101  FORMAT(/,' VB2000 DIRECTORY IS: ',A80)
 102  FORMAT(/,' JOB NAME IS ',A64)
 103  FORMAT(' USING RESTARTFILE ',A64)
CGMS5 FORMAT(" MAXIMUM MEMORY USE IS:",I12,/,
CGMS &" THIS IS TAKEN AS THE MAXIMUM OF THE UNUSED MEMORY REQUESTED",/
CGMS &" IN GAMESS $SYSTEM BLOCK AND MEMORY REQUESTED IN VB2000 DATA"/)
 106  FORMAT(" FILE: ",A64,/," DOES NOT EXIST")
      END
      SUBROUTINE BANNER(IIOUT,COMPILER)
      CHARACTER*25 COMPILER
      WRITE(IIOUT,1400)
      WRITE(IIOUT,1)
      WRITE(IIOUT,3) COMPILER
      WRITE(IIOUT,2)
      WRITE(IIOUT,1401)
      WRITE(IIOUT,1402)
 1400 FORMAT(/
     1' **************************************************************'/
     1' *                                                            *'/
     1' *                        V B 2 0 0 0                         *'/
     1' *                                                            *'/
     1' *       An ab initio Valence-Bond Program Based on the       *'/
     1' *           Generalized Product Function Method and          *'/
     1' *                   the Algebrant Algorithm                  *'/
     1' *                                                            *'/
     1' *                   Version 2.7 October 2013                 *')
CWVB1 FORMAT(
CWVB 1' *                 WinVB2000 - Windows Version                *')
C0001 FORMAT(
C000 1' *                     Stand-alone Version                    *')
CSMI1 FORMAT(
CSMI 1' *                   Smiles integrals Version                 *')
CGMS1 FORMAT(
CGMS 1' *                      GAMESS(US) Version                    *')
CGAU1 FORMAT(
CGAU 1' *                       Gaussian Version                     *')
    3 FORMAT(
     1' *                  ',A25,'                 *')
    2 FORMAT(
     1' *                                                            *'/
     1' *         Jiabo Li*, Brian Duke** and Roy McWeeny***         *'/
     1' *                                                            *'/
     1' *        * SciNet Technologies, 9943 Fieldthorn St.,         *'/
     1' *                   San Diego, CA 92127, USA                 *'/
     1' *                                                            *'/
     1' *  ** Monash University Institute of Pharmaceutical Sciences,*'/
     1' *     381 Royal Pde, Parkville, Victoria, 3052, Australia    *'/
     1' *                                                            *')
 1401 FORMAT(
     1' * *** Department of Chemistry, University of Pisa,           *'/
     1' *     56100 Pisa, Italy                                      *'/
     1' *                                                            *'/
     1' *  Reference for the software:                               *'/
     1' *     Jiabo Li, Brian Duke, and Roy McWeeny, VB2000 Version  *'/
     1' *     2.7, SciNet Technologies, San Diego, CA, 2013          *'/
     1' *     URL: http://www.scinetec.com or http://www.vb2000.net  *'/
     1' *                                                            *'/
     1' *  References for the theory:                                *'/
     1' *     General:                                               *'/
     1' *     Jiabo Li, and Roy McWeeny, "VB2000: Pushing Valence    *'/
     1' *     Bond Theory to New Limits", Int. J. Quantum Chem.,     *'/
     1' *     89(2002)208-216.                                       *'/
     1' *                                                            *'/
     1' *     Spin densities:-                                       *'/
     1' *     Jiabo Li, Brian J. Duke, Thomas M. Klapoetke, and Roy  *'/
     1' *     McWeeny, Spin-Density of Spin-Free Valence Bond Wave   *'/
     1' *     Functions and Its Implementation in VB2000. J. Theor.  *'/
     1' *     Comp. Chem. 7(2008)853-867.                            *'/
     1' *                                                            *')
 1402 FORMAT(
     1' *     Spin coupled - n electrons in m orbitals:-             *'/
     1' *     Peter B. Karadakov, David L. Cooper, Brian J. Duke,    *'/
     1' *     and Jiabo Li, Spin-Coupled Theory for N Electrons in   *'/
     1' *     M Orbitals Active Spaces,  J. Phys. Chem. A, 116,      *'/
     1' *     7238 - 7244, 2012                                      *'/
     1' *                                                            *'/
     1' *  Copyright (C) 2000-2013 by SciNet Technologies            *'/
     1' **************************************************************')
      RETURN
      END
C
C     COPY DATA FROM IOTEMP TO IOVB
C
      SUBROUTINE CPRESTART(IOTEMP, IOVBORB,LHFLAG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION MELEX(100),MLORBITX(100),METHODX(100)
      CHARACTER*12 BFLABEX(1000)
      DIMENSION BASISX(500000),DM1NONX(500000)
      DIMENSION LMOATM(5,1000)
C
C     NBASISX =< 1000!
C
      READ(IOTEMP)  NSUBX,NDM1X,(MELEX(I),I=1,NSUBX),
     &              (MLORBITX(I),I=1,NSUBX),(METHODX(I),I=1,NSUBX)
      WRITE(IOVBORB)NSUBX,NDM1X,(MELEX(I),I=1,NSUBX),
     &              (MLORBITX(I),I=1,NSUBX),(METHODX(I),I=1,NSUBX)
C
      READ(IOTEMP)  NBASISX,NATOMX,NORBX,(BFLABEX(I),I=1,NBASISX)
      WRITE(IOVBORB)NBASISX,NATOMX,NORBX,(BFLABEX(I),I=1,NBASISX)
C
      READ(IOTEMP)  (BASISX(I),I=1,NBASISX*NORBX)
      WRITE(IOVBORB)(BASISX(I),I=1,NBASISX*NORBX)
C
      READ(IOTEMP)  (DM1NONX(I),I=1,NDM1X)
      WRITE(IOVBORB)(DM1NONX(I),I=1,NDM1X)
C
      IF(LHFLAG.GE.1) THEN
        READ(IOTEMP)  ((LMOATM(I,J),I=1,5),J=1,NORBX)
        WRITE(IOVBORB)((LMOATM(I,J),I=1,5),J=1,NORBX)
      END IF
      RETURN
      END
      SUBROUTINE VBINIT(IOVBIN,IOENGI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 A
      REWIND(IOVBIN)
 10   READ(IOVBIN,'(A80)',END=100)A
      WRITE(IOENGI,'(A80)')A
      GOTO 10
 100  CONTINUE
      DO I=1,80
      A(I:I)=' '
      ENDDO
      WRITE(IOENGI,'(A80)')A
      REWIND(IOENGI)
      RETURN
      END
C
C     VB2000 Dynamic memory management
C
C     GAMESS-VB does not have CDYN flag remover, thus we need BOTH CDYN and CGMS
C
      SUBROUTINE SETMEM(MEMLIM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /VB2MEM/LOCX,LOCMEM,LOFFS,MEMWRK,MSCRATCH,MHIGH
CDYN  COMMON /GENWRK/X(1)
CGAU  COMMON /GENWRK/X(1)
CGMS  COMMON /GENWRK/X(1)
CL32  LOCX = LADDRS(X)
CL64  LOCX = LOC(X)
CGMS  CALL GETLOC(X,LOCX)
CDYN  LOCMEM = MEMGET(MEMLIM)
CGAU  LOCMEM = MEMGET(MEMLIM)
CGMS  LOCMEM = MEMGET(MEMLIM)
C     WRITE(IOUTVB,1) LOCX, LOCMEM, MEMLIM
C1    FORMAT(' LOCX =',I14,' LOCMEM =',I14,' MEMLIM =',I14)
      IF(LOCMEM.EQ.0) THEN
        WRITE(IOUTVB,*)
     &      "MEMORY ALLOCATION FAILED. YOU MAY TRY WITH REDUCED"
        WRITE(IOUTVB,*)"MEMORY "
        CALL ABORT0('SETMEM0001')
      END IF
      LOFFS = LOCMEM - LOCX
      LOFFS = (LOFFS+7)/8 + 1
      MEMWRK = MEMLIM
      RETURN
      END
C
      SUBROUTINE FREEMEM()
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /VB2MEM/LOCX,LOCMEM,LOFFS,MEMWRK,MSCRATCH,MHIGH
CDYN  CALL MEMREL(LOCMEM)
CGMS  CALL MEMREL(LOCMEM)
CGAU  CALL MEMREL(LOCMEM)
      RETURN
      END
C
      SUBROUTINE PATHST(FILEN,IN1,IN2,IN3,K)
C     Combines strings IN1 (always VBPATH), IN2 (must be padded out to
C     16 with spaces) and IN3 (length K) and outputs result in FILEN.
C
      CHARACTER*80 FILEN,IN1,IN3
      CHARACTER*16 IN2
      INTEGER K,L,I,II,KK,LL
      L=LEN(IN1)
      DO I=2,16
        IF (IN2(I:I).EQ.' ') GOTO 1
      ENDDO
 1    LL=I-1
      DO I=1,L
        IF (IN1(I:I).NE.' ') THEN
          FILEN(I:I) = IN1(I:I)
        ELSE
          II=I+LL-1
          FILEN(I:II) = IN2
          II = II + 1
          KK=II+K-1
          FILEN(II:KK) = IN3(1:K)
          KK=KK+1
          FILEN(KK:80) = ' '
          RETURN
        ENDIF
      ENDDO
      RETURN
      END
C
C     Driver of reaction path
C
C     IOVBIN: ORIGINAL VB INPUT FILE WITH REACTION PATH DATA
C     IOENGI: WORKING INPUT FILE
C
      SUBROUTINE REACTOR(IOVBIN,IOENGI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
CGMS  PARAMETER (MXATM=2000)
      PARAMETER (MAXCEN=200)
C     MXATM IS FOR GAMESS, WHILE MAXCEN IS LOWER LIMIT FOR VB
      PARAMETER (NATMAX=1000,MAXPTS=1000)
C     PARAMETER (NATMAX=10000,MAXPTS=1000)
      LOGICAL LXYZ
      CHARACTER*1 SYM
      CHARACTER*3 FUNIT(10)
      CHARACTER*40 TITLE
      CHARACTER*64 FSTR,RWFFILE,INTFILE,INPFILE,LOCFILE
      CHARACTER*80 CSTAR, CBLNK, ESTAR
      DIMENSION RPFXYZ(3,NATMAX),NATNUM(NATMAX),INTDEX(4,MAXPTS)
      DIMENSION XYZTMP(3,1000),EPATH(MAXPTS)
C000  DIMENSION C1(3,MAXCEN)
CSMI  DIMENSION C1(3,MAXCEN)
CGAU  DIMENSION C1(3,MAXCEN)
C     Note, not used in Gaussian version, but has to compile!
CGMS  COMMON /VBINTF/ VBENGY
      PARAMETER (MAXSHL=500,MAXPRM=15,MAXBFN=726)
      COMMON /SEEING/ XEXP(MAXSHL,MAXPRM),COEFF(MAXSHL,MAXPRM)
     &,NF(MAXSHL),KATOM(MAXCEN),IMOL,SYM(MAXSHL)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
CGMS  COMMON/INFOA/ NAT1, ICH1, MUL1, NUM1, NX1, NE1, NA1, NB1,
CGMS 1    ZAN1(MXATM), C1(3,MXATM), IAN(MXATM)
      PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA,MAXGRP=99)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(MAXGRP),MSPIN(MAXGRP),MNORBIT(MAXGRP),
     &MLORBIT(MAXGRP),MWIN(MAXGRP),MSTR(MAXGRP),METHOD(MAXGRP),
     &IBASIS(MAXEXT),NOCC(MAXEXT),NOBIAS,NEPS,NVIR,NOTROT(5000),
     &LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(MAXGRP)
CGMS  COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
CGMS  DATA CHECK  /8HCHECK   /
      CSTAR='********************************************************'
      CBLNK='                                                        '
      LXYZ=.FALSE.
      REWIND(IOVBIN)
      CALL LOCTOR(IOVBIN,'$REACTION',9,IOK,0)
      IF (IOK.EQ.1) THEN
      READ(IOVBIN,*,ERR=100)IPOINT,NGEOMS,NATOMS
      GOTO 110
 100  WRITE(IOUTVB,*)'ERROR IN READING IPOINT,NGEOMS,NATOMS'
      CALL ABORT0('REACTOR01 ')
 110  CONTINUE
      WRITE(IOUTVB,1100)
      END IF
      IF(IPOINT.LT.0.OR.NGEOMS.LT.0.OR.NATOMS.LT.0) THEN
        WRITE(IOUTVB,*)
     &      "ERROR IN REACTION INPUT FOR IPOINT,NGEOMS OR NATOMS"
        CALL ABORT0('REACTOR02 ')
      END IF
      WRITE(IOUTVB,1200)NGEOMS
      WRITE(IOUTVB,1300)IPOINT
      NAT=0
      DO I=1, NGEOMS
      READ(IOVBIN,*)
        DO J=1, NATOMS
        NAT = NAT + 1
        IF (NAT.GT.NATMAX) CALL ABORT0('REACTOR03 ')
        READ(IOVBIN,*,ERR=200)NATNUM(NAT),RPFXYZ(1,NAT),RPFXYZ(2,NAT),
     &                                    RPFXYZ(3,NAT)
C       WRITE(IOUTVB,'(I8,3F15.7)')NATNUM(NAT),RPFXYZ(1,NAT),
C    &     RPFXYZ(2,NAT),RPFXYZ(3,NAT)
        END DO
      END DO
C
C     STRUCTURE ALIGNMENT
C
      CALL ALIALL(RPFXYZ(1,1),NATOMS,NGEOMS)
      INTDEX(1,1)=1
      INTDEX(2,1)=IPOINT+1
      INTDEX(3,1)=2
      INTDEX(4,1)=0
      NPT = 0
      DO I=1, NGEOMS-1
      NPT = NPT + 1
      INTDEX(1,NPT) = I
      INTDEX(2,NPT) = IPOINT+1
      INTDEX(3,NPT) = I
      INTDEX(4,NPT) = 0
         DO J=1, IPOINT
         NPT = NPT +1
         IF(NPT.GT.MAXPTS) THEN
           WRITE(IOUTVB,*)
     &      "TOO MANY POINTS ( > 1000) ON THE REACTION PATH"
           CALL ABORT0('REACTOR03 ')
         END IF
         INTDEX(1,NPT) = I
         INTDEX(2,NPT) = INTDEX(2,NPT-1)-1
         INTDEX(3,NPT) = I + 1
         INTDEX(4,NPT) = INTDEX(4,NPT-1)+1
         END DO
      END DO
      NPT = NPT + 1
      INTDEX(1,NPT) = NGEOMS
      INTDEX(2,NPT) = IPOINT+1
      INTDEX(3,NPT) = NGEOMS
      INTDEX(4,NPT) = 0
C
C     REACTION DRIVER
C
C     Create simple XYZ file
      REWIND(IOVBIN)
      CALL LOCTOR(IOVBIN,'$XYZFILE',8,IOK,0)
      IF(IOK.EQ.1) THEN
        IMOL=96
        LXYZ=.TRUE.
        INPFILE=FSTR(1:LENFIL)//'.xyz'
        OPEN(UNIT=IMOL,FILE=INPFILE,STATUS='UNKNOWN',
     1    ACCESS='SEQUENTIAL',FORM='FORMATTED')
        TITLE(1:27)='REACTOR RUN - POINT NUMBER '
        TITLE(30:40)='           '
      ENDIF
      REWIND(IOENGI)
      WRITE(IOUTVB,*)'IRESTART IN REACTOR=',IRESTART
      DO I=1, NPT
CGMS     IF (EXETYP.EQ.CHECK.AND.I.EQ.2) RETURN
         IPNT = I
         WRITE(IOUTVB,101) IPNT
 101     FORMAT(/,' REACTOR POINT: ',I2,/)
         IF(LXYZ) WRITE(TITLE(28:29),'(I2.2)') IPNT
         IF(I.GT.1) IRESTART = 1
         NPT1=(INTDEX(1,I)-1)*NATOMS+1
         NPT2=NPT1 + NATOMS
         CALL INTGEOM(RPFXYZ(1,NPT1),RPFXYZ(1,NPT2),INTDEX(2,I),
     &               INTDEX(4,I),XYZTMP(1,1),NATOMS)
         CALL VBINPUT(IOVBIN,IOENGI,XYZTMP,NATNUM,NATOMS,IRESTART)
         DO K=1,NATOMS
            DO J=1,3
               C1(J,K)=XYZTMP(J,K)/0.529177249D0
            ENDDO
C           WRITE(IOUTVB,'(3X,3F15.7)') C1(1,K),C1(2,K),C1(3,K)
         ENDDO
         IF(LXYZ) THEN
            CALL XYZFILE(C1,NATOMS,NATNUM,TITLE)
         ENDIF
CGMS     IF(I.GT.1) CALL GAMINT()
         CALL VBENGINE(EPATH(I))
CGMS     VBENGY = EPATH(I)
         CLOSE(97)
      END DO
      IF(LXYZ) THEN
         CLOSE(IMOL)
         WRITE(IOUTVB,108)
      ENDIF
 108  FORMAT(/,
     &' CREATED MULTIPLE XYZ FILE OF MOLECULAR COORDINATES',/)
      WRITE(IOUTVB,1500)
      NGRP = (NPT+5)/6
      NEND = 0
      DO I=1, NGRP
         NST = NEND + 1
         NEND = NST + 5
         IF(NEND.GT.NPT) NEND=NPT
         WRITE(IOUTVB,1600)(J,J=NST,NEND)
         WRITE(IOUTVB,1700)(EPATH(J),J=NST,NEND)
      END DO
      EMAX = FINDMAX(EPATH,NPT)
      EMIN = FINDMIN(EPATH,NPT)
      DELTA = EMAX - EMIN
      WRITE(IOUTVB,*)
      SCALE = 50/DELTA
      DO I=1,NPT
         NSTAR = INT(SCALE*(EPATH(I)-EMIN))
         ESTAR = CBLNK
         ESTAR = CSTAR(1:NSTAR)
         WRITE(IOUTVB,1000)I,ESTAR
      END DO
      WRITE(IOUTVB,'(1X,/)')
      RETURN
 200  CALL ABORT0('REACTOR03 ')
      RETURN
 1000 FORMAT(2X,I5,'|',A50)
 1100 FORMAT(//1X,'          Chemical Reaction Calculation'/
     &       1X,'================================================')
 1200 FORMAT(1X,'Number of intermediate structures:      ',I5)
 1300 FORMAT(1X,'Number of LST points bewteen structures:',I5)
C1400 FORMAT(1X,'Read guess (Yes/No = 1/0):              ',I5//)
 1500 FORMAT(1X,'Energy profile')
 1600 FORMAT(1X,6I12)
 1700 FORMAT(1X,6F12.5)
      END
      DOUBLE PRECISION FUNCTION FINDMAX(A,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(*)
      FINDMAX = -1.0D+100
      DO I=1,N
      IF(FINDMAX.LT.A(I)) FINDMAX=A(I)
      END DO
      RETURN
      END
      DOUBLE PRECISION FUNCTION FINDMIN(A,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(*)
      FINDMIN = 1.0D+100
      DO I=1,N
      IF(FINDMIN.GT.A(I)) FINDMIN=A(I)
      END DO
      RETURN
      END
      SUBROUTINE ALIALL(XYZ,NATOMS,NGEOMS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION XYZ(3,*),WT(1000)
      DO I=1,NATOMS
      WT(I)=1.0D0
      END DO
      DO I=1,NGEOMS-1
      NA1=(I-1)*NATOMS+1
      NA2=NA1+NATOMS
      CALL ALITWO(XYZ(1,NA1),XYZ(1,NA2),NATOMS,WT)
      END DO
      RETURN
      END
C
C     KABSCH ALGORITHM FOR THE ALIGNMENT OF TWO RIGID STRUCTURES
C
      SUBROUTINE ALITWO(Y,X,NATOMS,WT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION X(3,*),Y(3,*),WT(*),R(3,3),S(3,3),RR(3,3),U(3,3)
      DIMENSION CX(3),CY(3),A(3,3),B(3,3),E(10)
      EPS = 1.0D-15
C
C     Reset origin to the center of sytems
C
      DO J=1,3
      CX(J)=0.0D0
      CY(J)=0.0D0
      END DO
      TWT=0.0D0
      DO I=1,NATOMS
        DO J=1,3
        CX(J)=CX(J)+X(J,I)*WT(I)
        CY(J)=CY(J)+Y(J,I)*WT(I)
        END DO
      TWT = TWT + WT(I)
      END DO
      DO I=1,3
      CX(I) = CX(I)/TWT
      CY(I) = CY(I)/TWT
      END DO
      DO I=1,NATOMS
         DO J=1,3
         X(J,I) = X(J,I) - CX(J)
         Y(J,I) = Y(J,I) - CY(J)
         END DO
      END DO
C
C     UX->Y, i.e. Transfer X to fit Y
C
      DO J=1,3
      DO K=1,3
      R(J,K)=0.0D0
      S(J,K)=0.0D0
      END DO
      END DO
C
C     Build R and S matrices
C
      DO I=1,NATOMS
         DO J=1,3
         DO K=1,3
         R(J,K)=R(J,K)+WT(I)*Y(J,I)*X(K,I)
         S(J,K)=S(J,K)+WT(I)*X(J,I)*X(K,I)
         END DO
         END DO
      END DO
C
C     Form RR matrix
C
      DO J=1,3
      DO K=1,3
         RR(J,K)=0.0D0
         DO I=1,3
         RR(J,K)=RR(J,K)+R(I,J)*R(I,K)
         END DO
      END DO
      END DO
      CALL DIAG(RR,A,E,3,3)
C
C     Inverse eigen vector order
C
C     i.e. E(1) <= E(2) <= E(3)
C
      TEMP = E(1)
      E(1) = E(3)
      E(3) = TEMP
      DO I=1,3
         TEMP   = A(I,1)
         A(I,1) = A(I,3)
         A(I,3) = TEMP
      END DO
C
C   CROSS PRODUCT: A3 = A1 x A2 (cross product), so that A1,A2,A3 form a
C   right-handed system
C
      A(1,3) = A(2,1)*A(3,2)-A(2,2)*A(3,1)
      A(2,3) = A(1,2)*A(3,1)-A(1,1)*A(3,2)
      A(3,3) = A(1,1)*A(2,2)-A(1,2)*A(2,1)

      DO K=1,3
        DO I=1,3
        B(I,K)=0.0D0
          DO J=1,3
          B(I,K)=B(I,K)+R(I,J)*A(J,K)
          END DO
        END DO
      END DO
C
C   NORMALIZATION
C
      IF(E(1).LT.EPS ) THEN
      B(1,1)=1.0D0
      B(2,1)=0.0D0
      B(3,1)=0.0D0
      B(1,2)=0.0D0
      B(2,2)=1.0D0
      B(3,2)=0.0D0
      B(1,3)=0.0D0
      B(2,3)=0.0D0
      B(3,3)=1.0D0
      ELSE IF (E(2).LT.EPS) THEN
C
C     ARBITARY VECTOR
C
      B(1,2)=1.0D0
      B(2,2)=3.14159D0
      B(3,2)=2.0D0
      SUM = 0.0D0
      DO I=1,3
      SUM = SUM + B(I,1)*B(I,1)
      END DO
      SCALE = 1.0D0/DSQRT(SUM)
      DO I=1,3
      B(I,1)=B(I,1)*SCALE
      END DO
      PROD = B(1,1)*B(1,2) + B(2,1)*B(2,2) + B(3,1)*B(3,2)
      B(1,2) = B(1,2) - PROD*B(1,1)
      B(2,2) = B(2,2) - PROD*B(2,1)
      B(3,2) = B(3,2) - PROD*B(3,1)
        SUM = 0.0D0
        DO I=1,3
        SUM = SUM + B(I,2)*B(I,2)
        END DO
        SCALE = 1.0D0/DSQRT(SUM)
        DO I=1,3
        B(I,2)=B(I,2)*SCALE
        END DO
      END IF
      DO K = 1,2
        SUM = 0.0D0
        DO I=1,3
        SUM = SUM + B(I,K)*B(I,K)
        END DO
        SCALE = 1.0D0/DSQRT(SUM)
        DO I=1,3
        B(I,K)=B(I,K)*SCALE
        END DO
      END DO
C
C   CROSS PRODUCT
C
      B(1,3) = B(2,1)*B(3,2)-B(2,2)*B(3,1)
      B(2,3) = B(1,2)*B(3,1)-B(1,1)*B(3,2)
      B(3,3) = B(1,1)*B(2,2)-B(1,2)*B(2,1)
C
C   U = BA
C
      DO I=1,3
      DO J=1,3
      U(I,J)=0.0D0
      END DO
      END DO
      DO K=1,3
        DO I=1,3
        DO J=1,3
        U(I,J)=U(I,J)+B(I,K)*A(J,K)
        END DO
        END DO
      END DO
C
C     X = UX
C
      DO I = 1, NATOMS
         TEMPX=0.0D0
         DO J=1,3
         TEMPX = TEMPX + U(1,J)*X(J,I)
         END DO
         TEMPY=0.0D0
         DO J=1,3
         TEMPY = TEMPY + U(2,J)*X(J,I)
         END DO
         TEMPZ=0.0D0
         DO J=1,3
         TEMPZ = TEMPZ + U(3,J)*X(J,I)
         END DO
         X(1,I)=TEMPX
         X(2,I)=TEMPY
         X(3,I)=TEMPZ
      END DO
C
C     WRITE X
C
C     WRITE(IOUTVB,*)'TRANSFORERED XYZ'
C     SUMT = 0.0D0
C     DO J=1,NATOMS
C     WRITE(IOUTVB,*)(X(I,J),I=1,3)
C        DO I=1,3
C        END DO
C     END DO
      RETURN
      END
C
C     FIND THE U MATRIX FOR THE ROTATION, AND KEEP Y, X UNCHANGED
C
      SUBROUTINE FITROT(YY,XX,NATOMS,WT,U)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION XX(3,*),YY(3,*),WT(*),R(3,3),S(3,3),RR(3,3),U(3,3)
      DIMENSION CX(3),CY(3),A(3,3),B(3,3),E(10)
      DIMENSION X(3,100),Y(3,100)
      EPS = 1.0D-15
      DO I=1, NATOMS
        DO J=1,3
        X(J,I) = XX(J,I)
        Y(J,I) = YY(J,I)
        END DO
      END DO
C
C     Reset origin to the center of sytems
C
      DO J=1,3
      CX(J)=0.0D0
      CY(J)=0.0D0
      END DO
      TWT=0.0D0
      DO I=1,NATOMS
        DO J=1,3
        CX(J)=CX(J)+X(J,I)*WT(I)
        CY(J)=CY(J)+Y(J,I)*WT(I)
        END DO
      TWT = TWT + WT(I)
      END DO
      DO I=1,3
      CX(I) = CX(I)/TWT
      CY(I) = CY(I)/TWT
      END DO
      DO I=1,NATOMS
         DO J=1,3
         X(J,I) = X(J,I) - CX(J)
         Y(J,I) = Y(J,I) - CY(J)
         END DO
      END DO
C
C     UX->Y, i.e. Transfer X to fit Y
C
      DO J=1,3
      DO K=1,3
      R(J,K)=0.0D0
      S(J,K)=0.0D0
      END DO
      END DO
C
C     Build R and S matrices
C
      DO I=1,NATOMS
         DO J=1,3
         DO K=1,3
         R(J,K)=R(J,K)+WT(I)*Y(J,I)*X(K,I)
         S(J,K)=S(J,K)+WT(I)*X(J,I)*X(K,I)
         END DO
         END DO
      END DO
C
C     Form RR matrix
C
      DO J=1,3
      DO K=1,3
         RR(J,K)=0.0D0
         DO I=1,3
         RR(J,K)=RR(J,K)+R(I,J)*R(I,K)
         END DO
      END DO
      END DO
      CALL DIAG(RR,A,E,3,3)
C
C     Inverse eigen vector order
C
C     i.e. E(1) <= E(2) <= E(3)
C
      TEMP = E(1)
      E(1) = E(3)
      E(3) = TEMP
      DO I=1,3
         TEMP   = A(I,1)
         A(I,1) = A(I,3)
         A(I,3) = TEMP
      END DO
C
C   CROSS PRODUCT: A3 = A1 x A2 (cross product), so that A1,A2,A3 for a
C   right-handed system
C
      A(1,3) = A(2,1)*A(3,2)-A(2,2)*A(3,1)
      A(2,3) = A(1,2)*A(3,1)-A(1,1)*A(3,2)
      A(3,3) = A(1,1)*A(2,2)-A(1,2)*A(2,1)

      DO K=1,3
        DO I=1,3
        B(I,K)=0.0D0
          DO J=1,3
          B(I,K)=B(I,K)+R(I,J)*A(J,K)
          END DO
        END DO
      END DO
C
C   NORMALIZATION
C
      IF(E(1).LT.EPS ) THEN
      B(1,1)=1.0D0
      B(2,1)=0.0D0
      B(3,1)=0.0D0
      B(1,2)=0.0D0
      B(2,2)=1.0D0
      B(3,2)=0.0D0
      B(1,3)=0.0D0
      B(2,3)=0.0D0
      B(3,3)=1.0D0
      ELSE IF (E(2).LT.EPS) THEN
C
C     ARBITARY VECTOR
C
      B(1,2)=1.0D0
      B(2,2)=3.14159D0
      B(3,2)=2.0D0
      SUM = 0.0D0
      DO I=1,3
      SUM = SUM + B(I,1)*B(I,1)
      END DO
      SCALE = 1.0D0/DSQRT(SUM)
      DO I=1,3
      B(I,1)=B(I,1)*SCALE
      END DO
      PROD = B(1,1)*B(1,2) + B(2,1)*B(2,2) + B(3,1)*B(3,2)
      B(1,2) = B(1,2) - PROD*B(1,1)
      B(2,2) = B(2,2) - PROD*B(2,1)
      B(3,2) = B(3,2) - PROD*B(3,1)
        SUM = 0.0D0
        DO I=1,3
        SUM = SUM + B(I,2)*B(I,2)
        END DO
        SCALE = 1.0D0/DSQRT(SUM)
        DO I=1,3
        B(I,2)=B(I,2)*SCALE
        END DO
      END IF
      DO K = 1,2
        SUM = 0.0D0
        DO I=1,3
        SUM = SUM + B(I,K)*B(I,K)
        END DO
        SCALE = 1.0D0/DSQRT(SUM)
        DO I=1,3
        B(I,K)=B(I,K)*SCALE
        END DO
      END DO
C
C   CROSS PRODUCT
C
      B(1,3) = B(2,1)*B(3,2)-B(2,2)*B(3,1)
      B(2,3) = B(1,2)*B(3,1)-B(1,1)*B(3,2)
      B(3,3) = B(1,1)*B(2,2)-B(1,2)*B(2,1)
C
C   U = BA
C
      DO I=1,3
      DO J=1,3
      U(I,J)=0.0D0
      END DO
      END DO
      DO K=1,3
        DO I=1,3
        DO J=1,3
        U(I,J)=U(I,J)+B(I,K)*A(J,K)
        END DO
        END DO
      END DO
C
      RETURN
      END
      SUBROUTINE INTGEOM(XYZ1,XYZ2,IWT1,IWT2,XYZTMP,NATOMS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION XYZ1(3,*),XYZ2(3,*),XYZTMP(3,*)
      RATIO = DFLOAT(IWT1)/DFLOAT(IWT1+IWT2)
      DO I = 1, NATOMS
         DO J=1,3
         XYZTMP(J,I) = XYZ1(J,I)*RATIO + XYZ2(J,I)*(1.0D0-RATIO)
         END DO
      END DO
      RETURN
      END
      SUBROUTINE VBENGINE(ETOTAL)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     MAIN PROGRAM FOR PERFORMING VALENCE BOND CALCULATIONS USING ALGEBRANT
C     ALGORITHM AND GENERALIZED PRODUCTION FUNCTION METHOD
C
C     NOTES:
C           THIS CAN BE USED AS A STAND ALONE PROGRAM. THE CORE OF VB2000
C           CAN ALSO BE USED AS A PLUG-IN FOR ANY ELECTRONIC STRUCTURE
C           PROGRAM WITH MINIMAL PROGRAMMING EFFORTS (TO PROVIDE INTERFACE
C           TO INTEGRALS AND HF ROUTINES).
C
C           TO RUN VB2000 IN A THIRD PARTY ELECTRONIC STRUCTURE PROGRAM,
C           ONE SHOULD PROVIDE THE CORRESPONDING INTERFACE ROUTINES
C           TO READ INTEGRALS, HARTREE-FOCK MOLECULAR ORBITALS, AND
C           THE BASIS SET INFORMATION.
C
C           THE CURRENT VERSION IS DESIGNED TO BE ABLE TO INTERFACE GAUSSIAN,
C           GAMESS, AND THE IN-HOUSE PROGRAM. TO CONNECT VB2000 WITH
C           A PARTICULAR PROGRAM, ONE NEEDS ACTIVE THE CORRESPONDING COMMENTED
C           STATEMENTS BEFORE COMPILE THE SOURCE CODE.
C
C     CODES:
C           C000: CONNECT ITSELF   (I.E. AS A STAND ALONE PROGRAM)
C           CGAU: A STAND-ALONE CODE THAT READS INTEGRALS AND MOLECULAR
C                 DATA FROM GAUSSIAN09
C           CGMS: CONNECT GAMESS   (INBEDDED INTO GAMESS(US))
C           CSMI: CONNECT SMILES   (CONNECT TO SMILES INTEGRAL)
C
C     AUTHOR:
C
C           JIABO LI
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
CSTA  INCLUDE 'maxwork.inc'
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      PARAMETER (MAXCEN=200,MAXBFN=726)
CGAU  COMMON /CONG/ C(3,MAXCEN),IAN(MAXCEN),ILSW(100),JCHARGE,MULTIP
CGAU &,NATOMT,NLAB,NBASIST,NBSUSE,NE,LEN12L,LEN4L
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
      PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA,MAXGRP=99)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(MAXGRP),MSPIN(MAXGRP),MNORBIT(MAXGRP),
     &MLORBIT(MAXGRP),MWIN(MAXGRP),MSTR(MAXGRP),METHOD(MAXGRP),
     &IBASIS(MAXEXT),NOCC(MAXEXT),NOBIAS,NEPS,NVIR,NOTROT(5000),
     &LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(MAXGRP)
C     COMMON /IAA/IA(100000)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /VB2MEM/LOCX,LOCMEM,LOFFS,MEMWRK,MSCRATCH,MHIGH
CSTA  COMMON /GENWRK/G(MAXWK)
CDYN  COMMON /GENWRK/G(1)
CGAU  COMMON /GENWRK/G(1)
C000  DIMENSION E(5000)
      CHARACTER*64 SOURCEDAT
      KEY(99)=0
      MAXWRK = 6500000
CSTA  MAXWRK = MAXWK
CDYN  MAXWRK = MEMWRK
CDYN  WRITE(IOUTVB,'(" MAXIMUM DYNAMIC MEMORY IS: ",I14,/)') MAXWRK
CGAU  MAXWRK=MEMWRK
CGAU  WRITE(IOUTVB,'(/," MAXIMUM DYNAMIC MEMORY IS: ",I14,/)') MAXWRK
      IFLAG = 0
C000  IFLAG = 1
CSMI  IFLAG = 1
CGAU  IFLAG = 2
      CALL PRECALC(ICHARGE,MULTI,SOURCEDAT,IFLAG)
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL GETIOUNIT('IAO2E   ',IAO2E)
      CALL GETIOUNIT('IOHFORB ',IOHFORB)
      REWIND(IAO2E)
      IF(IFLAG.EQ.1) THEN
C
C       Standard stand-alone version.
C
        NE=0
C000    CALL CALCINT(SOURCEDAT,ENREP,NBASIS,NATOM,NE,0)
CSMI    CALL SMIINT(NE)
C
C     COPY DATA TO GENINF
C
        NELE =NE - ICHARGE
        NSPIN=MULTI-1
        NFIRST = 1
CDYN    NFIRST = LOFFS
        NSS  = NFIRST
        NHH  = NSS+NBASIS*NBASIS
        NVV  = NHH+NBASIS*NBASIS
        NFF  = NVV+NBASIS*NBASIS
        NPP  = NFF+NBASIS*NBASIS
        NPW  = NPP+NBASIS*NBASIS
        NWW  = NPW+NBASIS*NBASIS
        NEND = NWW+NBASIS*NBASIS*3
        MHIGH = MAX(MHIGH,NEND-NFIRST)
C       WRITE(IOUTVB,'(" MHIGH",2I12)') 2,MHIGH
C000    CALL RHND1E(IAO1E,G(NSS),G(NHH))
CSMI    CALL RSMI1E(G(NSS),G(NHH),NBASIS)
        IF(NEND-NFIRST.GE.MAXWRK) THEN
          WRITE(IOUTVB,*)"SCRATCH SPACE IS TOO SMALL"
          CALL ABORT0('VBENGINE01')
        END IF
C000    IF(IPNT.LE.1)
C000 &  CALL HFSCF(NELE,NSPIN,G(NSS),G(NHH),G(NVV),G(NFF),
C000 &  G(NPP),G(NPW),G(NWW),NBASIS,IOHFORB,128,ENERGY,ENREP,E,BFLABE)
CSMI    IF(IPNT.LE.1)
CSMI &  CALL HFSCF(NELE,NSPIN,G(NSS),G(NHH),G(NVV),G(NFF),
CSMI &  G(NPP),G(NPW),G(NWW),NBASIS,IOHFORB,128,ENERGY,ENREP,E,BFLABE)
C000    ETOTAL = ENERGY
CSMI    ETOTAL = ENERGY
      END IF
CGAU  IF(IFLAG.EQ.2) THEN
C
C       Gaussian stand-alone version.
C
CGAU    CALL CONGAU1()
CGAU    NFIRST = LOFFS
CGAU    NSS  = NFIRST
CGAU    NHH  = NSS+NBASIS*NBASIS
CGAU    NEND = NHH+10000
C       Adds a maximum size of buffer defined later by LBUFF
CGAU    MHIGH = MAX(MHIGH,NEND-NFIRST)
C       WRITE(IOUTVB,'(" GAU MHIGH",2I12)') 2,MHIGH
CGAU    CALL CONGAU2(G(NSS),G(NHH))
CGAU    ICHARGE = JCHARGE
CGAU    MULTI = MULTIP
CGAU    CALL READ1E(IAO1E,G(NSS),G(NHH),NBASIS)
C       DEBUG - Write out S and H
C GAU    WRITE(IOUTVB,'(/," S MATRIX",/)')
C GAU    NUM2 =NBASIS*(NBASIS+1)/2
C GAU    WRITE(IOUTVB,'(5F12.6)') (G(NSS-1+I),I=1,NUM2)
C GAU    WRITE(IOUTVB,'(/," H MATRIX",/)')
C GAU    WRITE(IOUTVB,'(5F12.6)') (G(NHH-1+I),I=1,NUM2)
CGAU    CALL GET2E(G(NWW))
CGAU  END IF
C
C     Possible initialization of a Post-HF solvation calculation
C
      CALL ALGEBRANT(ETOTAL)
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     CORE OF VB2000
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     FUNCTION: TOP LEVEL ROUTINE OF VB2000
C
C
C     TIME TABLE FOR VB2000
C     =====================
C
C     1) XIAMEN UNIVERSITY, XIAMEN, CHINA                   (1991-1992)
C     2) INSTITUTE FOR MOLECULAR SCIENCE, OKAZAKI, JAPAN    (1992-1993)
C     3) UNIVERSITY OF ERLANGEN-NURNBERG, ERLANGEN, GERMANY (1993-1995)
C     4) COLUMBIA UNIVIERSITY, NEW YORK, NY, USA            (1995-1996)
C     5) UNIVERSITY OF MINNESOTA, MINNEAPOLIS, MN, USA      (1996-1999)
C     6) SAN DIEGO, CA, USA                                 (1999-    )
C
C
C     BRIEF HISTORY
C     =============
C
C     THE VERY EARLY IDEA FOR DEVELOPOING A NEW APPROCH TO NONORTHOGONALITY
C     PROBLEM OF MODERN VB CALCULATION WAS CREATED WHEN THE AUTHOR WAS A
C     POSTDOC WITH PROF. QIANER ZHANG. THE ORIGINAL MOTIVATION WAS TO
C     DEVELOP A VB PROGRAM TO STUDY ANDERSON'S RVB THEORY OF HIGH-TC
C     SUPERCONDUCTIVITY. SOON THE AUTHOR WAS CONVINCED THAT THE N! PROBLEM
C     IN MODERN VB CALCULATION WAS MORE DIFFICULT THAN HE COULD HANDEL, LET
C     ALONE THE HIGH-TC SUPERCONDUCTIVITY THEORIES.
C
C     WITHOUT MAKING MUCH PROGRESS IN HIGH-TC THEORIES, THE AUTHOR PROPOSED
C     THE PERMANENT METHOD FOR NONORTHOGOANL VB CALCULATIONS WITH THE HELP
C     OF DR. WEI WU. THE PERMANENT METHOD WAS EXTENSIVELY DEVELOPED DURING
C     THE AUTHOR'S VISITS TO PROF. MOROKUMA AND PROF. LADIK'S LABS. THE
C     SUPER-CI METHOD WAS ALSO IMPLEMENTED FOR OPTIMIZATION OF VB ORBITALS.
C     THE PRIMITIVE IDEA OF ALGEBRANT ALGORITHM WAS FORMED.
C
C     THE COLABORATION BETWEEN PROF. RUBEN PAUNCZ AND THE AUTHOR WAS
C     ESTABLISHED SOON AFTER A FEW E-MAIL CORESPONDANCES NEAR THE END OF 1994.
C     THE COLABORATION LED TO THE FORMAL FORMULATION OF THE ALGEBRANT
C     ALGORITHM. HOWEVER, THE AUTHOR'S MAJOR RESEARCH EFFORT WAS TURNED TO
C     MOLECULAR SIMULATIONS FROM 1996, AND THE NEWLY FORMED ALGORITHM WAS
C     NOT IMPLEMENTED UNTIL THE WINTER OF 1997 WHEN THE AUTHOR WAS VERY
C     INSPIRED BY PROF. ROY MCWEENY'S GROUP FUNCTION METHOD. A VERY CLOSE
C     COLLABORATION HAS BEEN ESTABLISHED BETWEEN ROY AND THE AUTHOR. TO ADOPT
C     MCWEENY'S GROUP FUNCTION METHOD AND DEVELOP A MUCH MORE ROBUST VB
C     PROGRAM, AN AGRESSIVE APPROACH WAS TAKEN: THE ORIGINAL VERSION OF VB
C     PROGRAM WAS COMPLETELY THROWN WAY, AND A COMPLETELY NEW VERSION WAS
C     BUILT FROM SCRATCH. THE NEWTON-RAPHSON METHOD WAS IMPLEMENTED FOR
C     VB ORBITAL OPTIMIZATION, AND MCWEENY'S GROUP-BY-GROUP OPTIMIZATION
C     METHOD WAS ALSO IMPLEMENTED IN MULTI-GROUP FUNCTION APPROACH.
C
C     UNFORTUNATELY, IT WAS SOON FOUND THAT THE GROUP-BY-GROUP METHOD FOR
C     OPTIMIZING A GENERALIZED PRODUCT FUNCTION DIDN'T WORK CORRECTLY
C     BECAUSE IT LACKED SOME DEGREES OF FREEDOM IN OPTIMIZATION. THE
C     SO-CALLED RIGID-ROTATION METHOD WAS FOUND AND IMPLEMENTED.
C
C     IN THE MIDDLE OF JUNE 1999, THE AUTHOR ACCEPTED A INDUSTRIAL POSITION
C     IN MOLECULAR SIMULATIONS AND MOVED TO SAN DIEGO. WHILE ENJOYING THE
C     SUNNY WEATHER OF SAN DIEGO, THE AUTHOR DECIDED TO REWRITE THE PROGRAM WITH
C     COMMERCIAL QUALITY. THE RIGID-ROTATION ALGORITHM WAS RE-DESIGNED AND
C     RE-CODED, AND A MUCH MORE MATURE ALGEBRANT ALGORITHM WAS DEVELOPED AND
C     IMPLEMENTED.
C
C     IT TURNS OUT THAT THE NEWEST VERSION IS ABOUT 1 TO 2 ORDERS OF MAGNITUDE
C     MORE EFFICIENT.
C
C     VB2000 IS STILL PUSHING THE BOUNDARY OF VB CALCULATIONS....
C
C
C     AKNOWLEDGEMENTS
C     ===============
C
C     SPECIAL THANKS ARE DUE TO:
C
C     DR. WEI WU,
C     FOR THE COLLABORATION ON THE THEORETICAL DEVELOPMENTS OF THE NEW
C     ALGORITHMS FOR VB CALCULATIONS DURING AUTHOR'S STAY IN XIAMEN.
C     THE PERMANENT ALGORITHM WAS FORMULATED AND IMPLEMENTED.
C
C     PROF. KEIJI MOROKUMA
C     FOR HIS SUPPORT DURING THE AUTHOR'S STAY AT THE INSTITUTE FOR MOLECULAR
C     SCIENCE, OKAZAKI, JAPAN.
C
C     PROF. JANOS LADIK
C     FOR HIS STRONG SUPPORT ON THIS WORK DURING THE AUTHOR'S STAY IN ERLANGEN
C     A QUITE SOPHISTICATED VB PROGRAM WITH CAPABILITY OF ORBITAL OPTIMIZATION
C     WAS DEVELOPED. THE IDEA OF USING ALGEBRANT ALGORITHM WAS PRACTISED
C     DURING THIS PERIOD
C
C     PROF. RUBEN PAUNCZ
C     FOR HIS STRONG SPIRITUAL SUPPORT AND THE COLLABORATION ON THE
C     LATESTED DEVELOPMENT ON THE ALGEBRANT ALGORITHM.
C
C     DR. DAVID L. COOPER
C     FOR BRINGING THE AUTHOR'S ATTENTION TO PIPEK-MEZEY LOCALIZATION METHOD,
C     WHICH IS A CRITICAL TECHNIQUE USED IN VB2000.
C
C     PROF. MARCO ZAIDER
C     FOR HIS STRONG INTERESTS AND SUPPORT ON THIS RESEARCH DURING THE AUTHOR'S
C     STAY AT COLUMBIA UNIVERSITY. THE ALGEBRANT ALGORITHM WAS EXPLICITLY
C     FORMULATED WITH THE COLLABORATION OF PROF. RUBEN PAUNCZ IN THIS TIME
C     FRAME.
C
C     PROF. ROY MCWEENY
C     FOR THE LONG-TIME COLLABORATION ON THE THEORETICAL DEVELOPMENTS AS WELL
C     AS THE IMPLEMENTATION OF VB METHODS AND THE SEPARABILITY THEORY.
C
C     PROF. CHRISTOPHER J. CRAMER, AND PROF. DONALD G. TRUHLAR
C     FOR THEIR DEEP INSIGHTS IN COMPUTATIONAL CHEMISTRY AND ENGENEERING IDEAS.
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE ALGEBRANT(ETOTAL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
CSTA  INCLUDE 'maxwork.inc'
CGMS  LOGICAL NUMGR2
CGMS  LOGICAL LGR,GGDONE,LCOULRD
C     CHARACTER*80 VBPAT,FILE2
C     CHARACTER*1 SPACE
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*8 BONDLAB
C
C     DIMENSION IOPER(1000),VT(1000)
C
      PARAMETER (MAXCEN=200,MAXBFN=726)
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
      PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA,MAXGRP=99)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(MAXGRP),MSPIN(MAXGRP),MNORBIT(MAXGRP),
     &MLORBIT(MAXGRP),MWIN(MAXGRP),MSTR(MAXGRP),METHOD(MAXGRP),
     &IBASIS(MAXEXT),NOCC(MAXEXT),NOBIAS,NEPS,NVIR,NOTROT(5000),
     &LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(MAXGRP)
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
      COMMON /VB2MEM/LOCX,LOCMEM,LOFFS,MEMWRK,MSCRATCH,MHIGH
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /DPENAL/DPW,DEPS,DPWMAX,DENERGY,NITER,MAXMICRO
CSTA  COMMON /GENWRK/RWRK(MAXWK)
CDYN  COMMON /GENWRK/RWRK(1)
CGAU  COMMON /GENWRK/RWRK(1)
CGMS  COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
CGMS  COMMON /GENWRK/RWRK(1)
CGMS  COMMON /GMSODD/ MSTEP,NUMGR2
      COMMON /LTAB/NTYPE,MAPINCORE,MEL,MSP,LOOKTB(6,100),NGRECD(4,100)
      COMMON /AGCODE/NPK1,NPK2,NPK3
      COMMON /INVERS/OVM(129)
      PARAMETER (MAXNAB=MAXCEN*MAXBFN/2,MAXBF2=MAXBFN*MAXBFN)
      COMMON /LMODAT/VMO(MAXBF2),VLMO(MAXBF2),LMOLAB(2,MAXBFN),
     &LMOATM(5,MAXBFN),PGM(MAXNAB),ENGLMO(MAXBFN),BONDLAB(MAXBFN),
     &MCLMO(5,80),LHFLAG
CGMS  COMMON /GBCNTL/EDIELE,ETGAS,DAMP,SOLN,SOLA,SOLB,SOLG,SOLC,SOLH,
CGMS &               ISOL,ISCRF,ICMD,ICDS,IAQU,IDOSOL,ICSAVE,ICREAD,
CGMS &               ISREAD,IGAS,LGR,GGDONE,LCOULRD
C
C     /GENINF/: Common block holding general information. For more detail,
C               see the input subroutine INPUTVB.
C     /GENCTL/: General control information is stored here. Also see INPUTVB.
C
C     /GENWRK/: General work space. Replaced by /FMCOM/ in Gamess version.
C        RWRK : Work space for rotation algorithm. The following variables are
C               are stored in this work space:
C               BASNAO: Nonorthogonal orbitals of all subunits in AO basis.
C                       The starting address for BASNAO in the work space is
C                       NAOBAS, and the size is NBasis*NBasis
C               BASLAO: Lowdin orbitals (Lowdin orthogonalized version of
C                       BASNAO in AO basis. The starting address is LAOBAS.
C                       Size = NBasis*NBasis. This part can be used for
C                       other purpose.
C               BASNOC: Local nonorthogonal orbitals in Lowdin basis.
C                       Address: NOCBAS.
C                       Size = SUM MLorbit(I)*MLorbit(I) (I=1,2,...NSUB)
C                       where MLorbit(I) is the dimension of I-th subunit.
C                       The relative addresses for NSUB units are
C                       NB2ADD(I). (I=1,2,.....NSUB).
C               BASLOC: Lowdin orbitals in local nonorthogonal orbitals.
C                       Address: LOCBAS. The same size and the relative
C                       addresses as BASNOC.
C               DM1NON: First order density matrices in local basis BASNOC.
C                       Starting address: ND1STA. The relative addresses
C                       for all subunits: ND1ADD(I). (I=1,2,...NSUB).
C               DM2NON: Second order density matrices in local nonorthogonal
C                       basis BASNOC. The starting address is ND2STA. The
C                       relative addresses for all subunits are: ND2ADD(I).
C               DM1LOW: First order density matrices in local Lowdin basis
C                       BASLOC. The starting address is LD1STA. The relative
C                       addresses are ND1ADD(I) (I=1,2,....NSUB).
C               DM2LOW: Second order density matrices in Lowdin basis.
C                       The starting address is LD2STA. The relative addresses
C                       are ND2ADD(I).
C               LGDMP:  The starting address for scratch.
C
C     LOGICAL  Done
C
C     TESTING
C
C     DIMENSION R3D(3,3),ORBOUT(10000),XYZNEW(3,100)
C     DATA SPACE/' '/
CGMS  DATA CHECK  /8HCHECK   /
C
C
C     FOR HF METHOD (MTHEORY=1), RETURN HERE
C     POSTPONE THIS TO ALLOW CALL OF VISUAL
C     IF(MTHEORY.EQ.1) RETURN
C
      MEL=0
      MSP=0
      ETOLD=0.0D0
      DPW    = 0.0D0
      DPWMAX = 0.0D0
C
C     SET CODING PARAMETERS
C
      NPK1=64
      NPK2=NPK1*NPK1
      NPK3=NPK2*NPK1
      DO I=-64,64
      IF(I.NE.0) OVM(I+65)=1.0D0/I
      END DO
      IF (MTHEORY .EQ. 1) GOTO 998
C
C     SETUP BINORMIAL COEFFICINETS USING YANG HUI'S METHOD
C     YANG-HUI: AN ANCIENT CHINESE MATHEMATICIAN
C
      CALL YANGHUI()
C
C     SET UP A UNIVERAL TABLE FOR COMPUTING INDEXES OF ELEMENTS OF
C     AN N-DIMENSIONAL SYMMETRIC MATRIX.
C
      TIME1=XCLOCK()
      CALL SETABL()
C     TIME1=XCLOCK()-TIME1
C     WRITE(IOUTVB,*)'TIME FOR SETABLE=',TIME1
      TIME0=XCLOCK()
 998  CONTINUE
C
      NFIRST = 1
CDYN  NFIRST = LOFFS
CGMS  NFIRST = LOFFS
CGAU  NFIRST = LOFFS
C
CSTA  MSIZE1 = MAXWK
CDYN  MSIZE1 = MEMWRK
CGAU  MSIZE1 = MEMWRK
CGMS  MSIZE1 = MEMWRK
      CALL GETIOUNIT('IOVBORB ',IOVBORB)
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      REWIND(IOVBORB)
C
C     WRITE(IOUTVB,*)'NFIRST =',NFIRST
      CALL INPUTVB(RWRK(NFIRST),MSIZE1)
      IF(LTEST.EQ.1) THEN
        CALL VISUAL(VLMO,RWRK(NFIRST))
C       CALL VISUAL(VLMO,RWRK(NFIRST),ETOTAL)
        WRITE(IOUTVB,'(A23,/)') ' TEST RUN ONLY - ENDING'
C       ETOTAL = 1.0D0
CGMS    CALL ENDGMS
        RETURN
      ENDIF
      IF(IRESTART.LT.0 .AND. MTHEORY .NE. 1) RETURN
      EPS=10.0D0**(-NEPS)
      DEPS   = EPS
      TIME1  = XCLOCK()
      LWRK1  = LGDMP+NBASIS*(NBASIS+1)/2
      LWRK2  = LWRK1+NBASIS*NBASIS
      LWRK3  = LWRK2+NBASIS*(NBASIS+1)
      MSIZE2 = MSIZE1 - LWRK2 + 1
      MSIZE3 = MSIZE1 - LGDMP + 1
      MSIZE4 = MSIZE1 - LWRK3 + 1
      MHIGH = MAX(MHIGH,LWRK3-1)
C     WRITE(IOUTVB,'(" MHIGH",2I12)') 3,MHIGH
C
C     Estimate the scratch space needed for the computation
C
      CALL COMPSIZE(NWNEED)
      IF(NWNEED.GT.MSIZE1) THEN
         WRITE(IOUTVB,101) NWNEED
 101     FORMAT(' INSUFFICIENT MEMORY - NWNEED =',I16)
CGMS     IF (EXETYP.EQ.CHECK) THEN
CGMS       WRITE(IOUTVB,'("YOU NEED AT LEAST ",I8)') NWNEED
CGMS     ELSE
           CALL ABORT0('ALGEBRANT0')
CGMS     ENDIF
      ENDIF
CGMS  IF (EXETYP.EQ.CHECK) THEN
CGMS    WRITE(IOUTVB,'(//," MEMORY NEEDED: ",I11)') NWNEED
CGMS    WRITE(IOUTVB,'(" MEMORY ALLOCATED: ",I8,/)') MSIZE1
CGMS    RETURN
CGMS  ENDIF

C
      IF(MSIZE4.LE.0) CALL ABORT0('ALGEBRANT1')
C
C     ADD OFFSET TO ADDRESS
C
C     IF(MTHEORY.EQ.1) GOTO 999
      LNAOBAS = NAOBAS + NFIRST - 1
      LLAOBAS = LAOBAS + NFIRST - 1
      IF(MTHEORY.EQ.1) GOTO 999
      LND1STA = ND1STA + NFIRST - 1
      LND2STA = ND2STA + NFIRST - 1
      LLGDMP  = LGDMP  + NFIRST - 1
      LLWRK1  = LWRK1  + NFIRST - 1
      LLWRK2  = LWRK2  + NFIRST - 1
C     PERFORM MACRO ITERATIONS
C
      LASTITER = 0
      DO MITER1=1,IMACRO
      MITER = MITER1
      IF(MITER.EQ.IMACRO) LASTITER=1
C
C     PERFORM DIVIDE-AND-CONQUER
C
      CALL VBOSYM(NBASIS,RWRK(LNAOBAS))
      CALL DVDCON(MITER,RWRK(LNAOBAS),RWRK(LLAOBAS),RWRK(LND1STA),
     & RWRK(LND2STA),RWRK(LLGDMP),RWRK(LLWRK1),RWRK(LLWRK2),MSIZE2,
     & ENREP,ETOTAL,LASTITER)
C
C     RIGID ROTATION
C
      CALL ROTRAN(RWRK(NFIRST),RWRK(LLGDMP),MSIZE3,ETOTAL,MITER)
      CALL VBOSYM(NBASIS,RWRK(LNAOBAS))
      EDIFF=ETOTAL-ETOLD
      WRITE(IOUTVB,1000)MITER,ETOTAL,EDIFF
      ETOLD=ETOTAL
      DENERGY = ABS(EDIFF)
C
C     ADD POSSIBLE SCRF TO VB CALCULATION
C
CGMS  ISOL=0
CGMS  CALL VBSCRF(NBASIS,NSUB,MLORBIT,RWRK(NFIRST),ETOTAL)
CGMS  CALL FLSHBF(IOUTVB)
      IF(LASTITER.EQ.1) GOTO 100
      ABSDIF = DABS(EDIFF)
      IF(DABS(EDIFF).LT.EPS.AND.DPW.GE.DPWMAX) LASTITER=1
      END DO
  100 CONTINUE
      IF(ABSDIF.GT.EPS) WRITE(IOUTVB,1599)ABSDIF,EPS
      IF(DPW.LT.DPWMAX) WRITE(IOUTVB,1600)DPW
 1599 FORMAT(//' ********** MACRO ITERATION IS NOT FULLY CONVERGED. ',
     &      '********** '//,
     &       ' ENERGY DIFF =',F14.10,', ENERGY THREHSOLD =',F14.10//)
 1600 FORMAT(' NOT CONVERGED WITH FULL DPW. THE CURRENT DPW = ',F15.5)
CGMS  CALL PRTVBSOL()
C
C     PROPERTIES OF WAVE FUNCTION
C
C     PRINT CHARGE DISTRIBUTION OF EACH GROUP
C     IF(ICHARPT == 1)
C
      ICHAPRT = 0
      CALL LOCTOR(IOENGI,'$CHAPRT',7,IOK,0)
      IF(IOK.EQ.1) ICHAPRT = 1
      CALL VBPOPL(NSUB,MLORBIT,RWRK(NFIRST),ICHAPRT,MSIZE1)
CGAU  CALL VBPROP(NBASIS,NSUB,MLORBIT,RWRK(NFIRST))
CGMS  CALL VBDENS(NBASIS,NSUB,MLORBIT,RWRK(NFIRST),LWRK2)
C
C     SOLVATION
C
C     CALL VBPROP(NBASIS,NSUB,MLORBIT,RWRK(NFIRST))
C
C     READ BASIS
C
      REWIND(IOVBORB)
      READ(IOVBORB)
C     READ(IOVBORB)IJUNK,IJUNK,NORBX
      READ(IOVBORB)I,I,NORBX
C     I is not used.
      READ(IOVBORB)(RWRK(LNAOBAS-1+I),I=1,NBASIS*NORBX)
C
C     PRINT ORBITALS IN GLOBAL AO BASIS
C
      NOCB=NB1ADD(NSUB+1)-1
      NPRT=(NOCB+5)/6
      WRITE(IOUTVB,1700)
      NFIST=1
      DO I=1,NPRT
      NLAST=NFIST+5
      IF(NLAST.GT.NOCB) NLAST=NOCB
      WRITE(IOUTVB,1800)(K,K=NFIST,NLAST)
      WRITE(IOUTVB,1810)(IBASIS(K),K=NFIST,NLAST)
      WRITE(IOUTVB,1850)
      DO J=1,NBASIS
      WRITE(IOUTVB,1900)J,BFLABE(J),(RWRK(LNAOBAS-1+J+(K-1)*NBASIS),
     &                                         K=NFIST,NLAST)
      END DO
      WRITE(IOUTVB,*)
      NFIST=NLAST+1
      END DO
C
C     FOR GAMESS ONLY CORRECT AND STORE MO's
CGMS  CALL GMSMOS(RWRK(LNAOBAS),RWRK(LLAOBAS),NBASIS,NOCB)
C
 999  CONTINUE
      IF (IPNT.EQ.0) CALL VISUAL(RWRK(LNAOBAS),RWRK(LLAOBAS))
C     IF (IPNT.EQ.0) CALL VISUAL(RWRK(LNAOBAS),RWRK(LLAOBAS),ETOTAL)
C     OUTPUT DATA FOR VISUALISATION PROGRAMS
C
C     CALL VBOLGN: An utility for generation VBO library
C
      CALL VBOLGN(NATOM,NBASIS,NATNUM,XYZ,NATBAS,BFLABE,RWRK(LNAOBAS),
     &            IOENGI)
C
C     CALCULATE CENTROIDS OF CHARGE
C     REORGANIZE MEMORY USE
CGMS  NBA2=(NBASIS*NBASIS + NBASIS)/2
CGMS  MEM1 = LNAOBAS
CGMS  MEM2 = MEM1 + NBASIS*NOCB
CGMS  MEM3 = MEM2 + NBA2
CGMS  MEM4 = MEM3 + 9*NBA2 + 9*784
CGMS  MEM5 = MEM4 + 3*NOCB
CGMS  MEM6 = MEM5 + 3*NOCB
CGMS  MSIZE=MSIZE1-(MEM6-NFIRST+1)
CGMS  IF(MSIZE.LE.0) THEN
CGMS     WRITE(IOUTVB,9) MEM6
CGMS     CALL ABORT0('ALGEBRANT2')
CGMS  ENDIF
CGMS  MHIGH = MAX(MHIGH, MEM6-NFIRST+1)
C
CGMS  IF (MSTEP.EQ.1.OR.IPNT.EQ.1)
CGMS 1CALL CENTROID(RWRK(MEM1),RWRK(MEM2),RWRK(MEM3),RWRK(MEM4)
CGMS 2,RWRK(MEM5),NBASIS,NBA2,NOCB)
C
CGAU  NBA2=(NBASIS*NBASIS + NBASIS)/2
CGAU  MEM1 = LNAOBAS
CGAU  MEM2 = MEM1 + NBASIS*NOCB
CGAU  MEM3 = MEM2 + 3*NBA2
CGAU  MEM6 = MEM3 + NBASIS*NBASIS
CGAU  MSIZE=MSIZE1-(MEM6-NFIRST+1)
CGAU  IF(MSIZE.LE.0) THEN
CGAU     WRITE(IOUTVB,9) MEM6
CGAU     CALL ABORT0('ALGEBRANT2')
CGAU  ENDIF
CGAU  MHIGH = MAX(MHIGH, MEM6-NFIRST+1)
CGAU  CALL CENTROID(RWRK(MEM1),RWRK(MEM2),RWRK(MEM3),NBASIS,NBA2,NOCB)
C
 1700 FORMAT(/
     &' ORBITALS OF EACH ELECTRON GROUP IN AO BASIS: ORBITAL(GROUP)')
 1800 FORMAT(1X,75(1H=)/'    Orbital#    ',6I10)
 1810 FORMAT('      Group#    ',6I10)
 1850 FORMAT(1X,75(1H-)/'  AO# LABELS')
 1900 FORMAT(I4,A12,6F10.5)
C1901 FORMAT(I4,A8,3F20.15)
CDYN  WRITE(IOUTVB,1101) MHIGH
CGMS  WRITE(IOUTVB,1101) MHIGH
CGAU  WRITE(IOUTVB,1101) MHIGH
CGMS  WRITE(IOUTVB,8)
      TIME2=XCLOCK()
      TIME =TIME2-TIME0
      TIME2=TIME2-TIME1
      TIME1=TIME1-TIME0
      WRITE(IOUTVB,1100)TIME1,TIME2,TIME
 1000 FORMAT(/' ENERGY AND DIFF OF MACROITER',I5,' =',2F16.8)
 1100 FORMAT(/,' STATISTICS OF CPU TIMES (SECONDS)'/
     1       ' CPU TIME FOR INITIALIZATION ',F12.3/
     1       ' CPU TIME FOR MACROITERATION ',F12.3/
     1       ' TOTAL CPU TIME              ',F12.3/)
 1101 FORMAT(/," WORDS OF DYNAMIC MEMORY USED IN VB2000 CODE ONLY:"
     1,I12)
CGMS8 FORMAT(" NOTE THAT THIS IS IN ADDITION TO MEMORY USED BY GAMESS",
CGMS 1/," PRINTED NEAR END OF OUTPUT. ADD THE TWO AMOUNTS TO GIVE",
CGMS 2/," THE TOTAL MEMORY USED BY THE JOB")
CGMS9 FORMAT(' INSUFFICIENT MEMORY - USE $MEMORY EXPLICITLY',
CGMS 1' TO SELECT MORE THAN',I12,' WORDS.')
CGAU9 FORMAT(' INSUFFICIENT MEMORY - USE $MEMORY EXPLICITLY',
CGAU 1' TO SELECT MORE THAN',I12,' WORDS.')
      END
      SUBROUTINE COMPSIZE(NWNEED)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Estimate the scratch space needed for computation
C
C     Notes:
C               This diagram shows that the calling tree of
C               the most memory consumption routines.
C               memory allocation changed in those routines, the formula
C               also should be modified accordingly. The estimation is not
C               the exact value, but with reasonable accuracy.
C
C               ALGEBRANT -> ROTRAN - > HESSTE
C                 LGDMP        NWHES      MAX(MSCR1,MSCR3)
C
C               ALGEBRANT -> DVDCON - > GENSCF -> VBSCF  -> VBHESS -> LAPLACE
C                 LWRK2                           MWKMISC             NAGSIZE
C     History:
C
C               First created in June 2004
C               Modified NAGSIZE estimation. April. 2010.
C
C     Author:
C
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      PARAMETER (MAXCEN=200,MAXBFN=726)
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
      PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA,MAXGRP=99)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(MAXGRP),MSPIN(MAXGRP),MNORBIT(MAXGRP),
     &MLORBIT(MAXGRP),MWIN(MAXGRP),MSTR(MAXGRP),METHOD(MAXGRP),
     &IBASIS(MAXEXT),NOCC(MAXEXT),NOBIAS,NEPS,NVIR,NOTROT(5000),
     &LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(MAXGRP)
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
C
C     COMPUT NOCORB
C
      NOCORB = 0
      DO 20 I=1,NSUB
 20   NOCORB = NOCORB+MLORBIT(I)
C
C     COMPUTE SCRATCH SPACE FOR HESSIAN OF RIGID ROTATION
C
      NWHES = 0
      DO 3 I=1,NSUB-1
      DO 3 J=I+1,NSUB
      IF (NOTROT((J-1)*(J-2)/2+I).EQ.0) THEN
      NDIMGRP=MLORBIT(I)*MLORBIT(J)
      NWHES = NWHES + NDIMGRP*(NDIMGRP+1)/2
      END IF
 3    CONTINUE
C
C     VIRTUAL ORBITALS
C
C     NVIRX=NBASIS-NOCORB
      DO 5 I=1,NSUB
      IF (NOTROT(NSUB*(NSUB-1)/2+I).EQ.0) THEN
      NDIMGRP=MLORBIT(I)*NVIR
      NWHES = NWHES + NDIMGRP*(NDIMGRP+1)/2
      END IF
  5   CONTINUE
C
C     COMPUTE SCRATCH SPACE FOR HESSTE
C
      NSQ   = NOCORB*(NOCORB+1)/2
      MSQ   = NBASIS*(NBASIS+1)/2
      NV    = NSQ + NOCORB*NVIR
      NGSQ  = NV*(NV+1)/2+(MSQ-NV)*NSQ
      MSCR1 = NBASIS**3
C     MSCR2 = NBASIS**2 + (NBASIS**4)/8
      MSCR3 = NGSQ + NBASIS**2
      MSCR  = MAX(MSCR1,MSCR3)
C
      LWRK1  = LGDMP+NBASIS*(NBASIS+1)/2
      LWRK2  = LWRK1+NBASIS*NBASIS
C
C     COMPUTE THE MAXSIZE OF VBSCF
C
      MXSIZE = LGDMP + NWHES + MSCR
C     WRITE(IOUTVB,*)'MXSIZE1 =',MXSIZE
      DO I=1, NSUB
      IF(METHOD(I).EQ.1.OR.MELE(I).EQ.2*MLORBIT(I)) GOTO 10
C
C     A GOOD GUESS FOR MISC DATA (SEE NLAST IN VBHESS)
C
      MWKMISC = MLORBIT(I)**4
C
C     A GOOD ESTIMATION (FROM OBSERVATION) FOR NAGSIZE
C
      NX      = (MELE(I)+1)/2
      NAGSIZE = 100*4**NX
C
C
      MXSIZE2 = LWRK2 + MWKMISC + NAGSIZE
      IF(MXSIZE.LT.MXSIZE2) MXSIZE = MXSIZE2
 10   CONTINUE
      END DO
C
C     WRITE(IOUTVB,*)'MXSIZE =',MXSIZE
      NWNEED = MXSIZE
      RETURN
      END
      SUBROUTINE DMTRAN(NSUB,MLORBIT,MNORBIT,MELE,METHOD,DM1NON,DM2NON,
     &DM1LOW,DM2LOW,BASNOC,G,MSIZE,NOND1D,LOWD1D,NONADD,NOND2D,LOWD2D)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Density Matrix Transformation
C               (All subunits, from nonorthogonal basis to Lowdin basis)
C
C     Note:
C               Both 1D and 2D density matrix elements are stored in
C               compact forms.
C               Scratch space requirement: M**3 + M**2, M is the maximal
C               dimension of non-HF groups.
C
C     History:
C               First created in Feb. 1999.
C               Recoded in September, 1999.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MAXDIM = 200)
      DIMENSION DM1NON(*),DM1LOW(*),NOND1D(*),LOWD1D(*),BASNOC(*)
      DIMENSION NOND2D(*),LOWD2D(*),NONADD(*),MLORBIT(*),MNORBIT(*)
      DIMENSION DM2NON(*),DM2LOW(*),G(*),METHOD(*),MELE(*)
      DIMENSION TEMPX(MAXDIM*MAXDIM)
C
C     LDIM >= NDIM !
C
      DO 100 KK=1,NSUB
      LDIM=MLORBIT(KK)
      NDIM=MNORBIT(KK)
      IF(NDIM**3+NDIM*NDIM.GT.MSIZE) CALL ABORT0('DMTRAN01  ')
C     LSQ=LDIM*(LDIM+1)/2
      NSQ=NDIM*(NDIM+1)/2
      NSQ2=NSQ*(NSQ+1)/2
C     LSQ2=LSQ*(LSQ+1)/2
C
C     SPECIAL CASE OF LHFSCF
C
      IF(METHOD(KK).GT.1.AND.NDIM.EQ.MELE(KK)/2) THEN
        DO IJ=1,NSQ
        DM1LOW(LOWD1D(KK)-1+IJ)=0.0D0
        END DO
        DO I=1, NDIM
          I2=I*(I+1)/2
          DM1LOW(LOWD1D(KK)-1+I2)=2.0D0
        END DO
      ELSE
        CALL MATRAN1(LDIM,NDIM,BASNOC(NONADD(KK)),G,
     &            DM1NON(NOND1D(KK)),DM1LOW(LOWD1D(KK)))
      ENDIF
      IF(METHOD(KK).GT.1) THEN
         DO IJKL=1,NSQ2
         DM2LOW(LOWD2D(KK)-1+IJKL)=0.0D0
         END DO
         MPP=LDIM**3
         IF(LDIM.GT.MAXDIM) CALL ABORT0("DMTRAN0001")
         IF(NDIM.EQ.MELE(KK)/2) THEN
C
C        DOUBLE OCCUPIED VB GROUP
C
           DO I=1, NDIM
             II = I*(I-1)/2
             I2 = I*(I+1)/2
             DO J=1, I
               IJ = II + J
               IJ2 = IJ*(IJ+1)/2
               IIJJ = I2*(I2-1)/2 + J*(J+1)/2
               FACTOR = -2.0D0
               IF(I.EQ.J) FACTOR = 1.0D0
               DM2LOW(LOWD2D(KK)-1+IJ2)=FACTOR
               IF(I.NE.J) DM2LOW(LOWD2D(KK)-1+IIJJ)=4.0D0
             ENDDO
           ENDDO
         ELSE
         CALL M4TRAN(LDIM, NDIM,BASNOC(NONADD(KK)),G(1),G(MPP),
     &            DM2NON(NOND2D(KK)),DM2LOW(LOWD2D(KK)),TEMPX)
         END IF
      END IF
  100 CONTINUE
C
C     DENSITY
C
      RETURN
      END
      SUBROUTINE M4TRAN(LDIM,NDIM,BASIS,W,P,DENOLD,DENNEW,BASISX)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               2D Density Matrix Transformation
C
C     Note:
C               Similar to four-index 2E integral transformation. The
C               same algorithm is used.
C
C     History:
C               First created in Feb. 1999.
C               Recoded in September, 1999.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      PARAMETER (MAXDIM = 200)
      PARAMETER (MAXDIM2 = MAXDIM*(MAXDIM+1)/2)
      DIMENSION W(*),BASIS(NDIM,LDIM),DENOLD(*),DENNEW(*)
      DIMENSION P(LDIM,LDIM),PSQ(MAXDIM2),V(1000),DC1(1000)
      DIMENSION BASISX(LDIM,LDIM)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      IF(NDIM.GT.MAXDIM.OR.LDIM.GT.MAXDIM) THEN
        WRITE(IOUTVB,*)"NDIM OR LDIM OF VB GROUP > ",MAXDIM
        CALL ABORT0('M4TRAN01  ')
      END IF
      DO I=1, LDIM
        DO J=1, NDIM
        BASISX(J,I) = BASIS(J,I)
        END DO
        DO J=NDIM+1, LDIM
        BASISX(J,I) = 0.0D0
        END DO
      END DO
      CALL DENFACA(LDIM,DENOLD,1)
C
C     THE N**5 ALGORITHM FOR THE FOUR-INDEX TRANSFORMATION
C
      M=LDIM
      MSQ=M*(M+1)/2
      DO 100 L=1,M
         DO 105 K=1,M
 105     V(K)=BASISX(L,K)
      DO 110 IJ=1,MSQ
      IAIJ=IJ*(IJ-1)/2
      DO 120 K1=1,IJ
 120  PSQ(K1)=DENOLD(IAIJ+K1)
      DO 121 K1=IJ+1,MSQ
      IAK1=K1*(K1-1)/2
 121  PSQ(K1)=DENOLD(IAK1+IJ)
      CALL MALTSQ(M,MSQ,PSQ,DC1,V)
      LL=L
      DO 130 K=LL,M
      XX=0.0D0
      KK=K
      DO 135 KX=1,M
  135 XX=XX+DC1(KX)*BASISX(KK,KX)
      W((K-1)*MSQ+IJ)=XX
 130  CONTINUE
 110  CONTINUE
      DO 100 K=LL,M
      KK=(K-1)*MSQ
      DO 220 K1=1,M
      K1JJ=K1*(K1-1)/2+KK
      DO 221 K2=1,K1
 221  P(K2,K1)=W(K1JJ+K2)
      K1JJ=K1+KK
      DO 222 K2=K1+1,M
      IAK2=K2*(K2-1)/2
 222  P(K2,K1)=W(IAK2+K1JJ)
 220  CONTINUE
      DO 100 J=1,M
          DO MMM=1,M
           V(MMM)=BASISX(J,MMM)
          END DO
      CALL MALTID(M,P,DC1,V)
      II=J
      IF(K.GT.J) II=K
      IF(J.LT.L) II=K+1
      DO 100 I=II,M
      XX=0.0D0
      DO 235 KX=1,M
  235 XX=XX+DC1(KX)*BASISX(I,KX)
      IJKL=IJKL01(I,J,K,L)
      DENNEW(IJKL)=XX
  100 CONTINUE
      CALL DENFACA(LDIM,DENNEW,0)
      CALL DENFACA(LDIM,DENOLD,0)
      RETURN
      END
C
C     ROUTINE FOR FACTOR OR DE-FACTOR THE TWO_ELECTRON DENSITY MATRIX
C     IDFACT=1(DE-FACTOR) OR 0(FACTOR)
C
      SUBROUTINE DENFACA(NDIM,D2,IDFACT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION D2(*)
      DO I=1,NDIM
      DO J=1,I
      IJ=I*(I-1)/2+J
        DO K=1,I
        LL=K
        IF(K.EQ.I) LL=J
        DO L=1,LL
        KL=K*(K-1)/2+L
        IJKL=IJ00(IJ,KL)
        FACTOR=1.0D0
        IF(I.NE.J) FACTOR=FACTOR*2.0D0
         IF(K.NE.L) FACTOR=FACTOR*2.0D0
         IF(IJ.NE.KL) FACTOR=FACTOR*2.0D0
           IF(IDFACT.EQ.1) THEN
           D2(IJKL)=D2(IJKL)/FACTOR
           ELSE
           D2(IJKL)=D2(IJKL)*FACTOR
           END IF
        END DO
        END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE TENERGY(NBASIS,NSUB,MLORBIT,METHOD,ORBLAO,RWRK,FKN,W,
     &                   NWSIZE,D2,ER,ENERGY)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Total energy of the product wave function
C
C     Note:
C               Minimal work space = NBASIS*NBASIS*(NBASIS+1)/2
C
C     History:
C               First created in Feb. 1999.
C               Recoded in September, 1999.
C               New energy expression coded. April, 2004
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
      DIMENSION MLORBIT(*),RWRK(*),W(*),D2(*),METHOD(*),ORBLAO(*),FKN(*)
      COMMON /VB2MEM/LOCX,LOCMEM,LOFFS,MEMWRK,MSCRATCH,MHIGH
      MEMUSED = MSCRATCH - NWSIZE
      NBA2=NBASIS*(NBASIS+1)/2
C     NDEN = 1
C     NHAM = NDEN + NBA2
C     NWK  = NHAM + NBA2
      NWNEED = NBA2*NBASIS
      MHIGH = MAX(MHIGH,MEMUSED+NWNEED)
      IF(NWNEED.GE.NWSIZE) CALL ABORT0('TENERGY001')
C
C     FIRST TERM OF ENERGY
C
      ENERGY  = ER
      CALL GETIOUNIT('IOTEMPA ',IOTEMPA)
      CALL GETIOUNIT('IOTEMPB ',IOTEMPB)
      LBUFF   = 4095
C
C     1E CONTRIBUTION
C
      CALL ONETENE(NBASIS,NSUB,MLORBIT,RWRK,W,NWSIZE,ENEONE)
      ENERGY = ENERGY + ENEONE
C
C     2E HARTREE-FOCK CONTRIBUTION
C
      IHF = 0
C     TIME1 = XCLOCK()
      CALL HF2EENE(NBASIS,NSUB,MLORBIT,METHOD,RWRK,FKN,W,NWSIZE,
     &             HF2E,IHF)
C     TIME2 = XCLOCK()
      ENERGY = ENERGY + HF2E
      NOBADD1= 1
C     IFLAG = 0
      CALL GETIOUNIT('IVBO2E  ',IVBO2E)
      DO K=1, NSUB
        IF(METHOD(K).NE.1) THEN
          NORB  = MLORBIT(K)
          NORB2 = NORB*(NORB+1)/2
          NGSQ  = NORB2*(NORB2+1)/2
          MHIGH = MAX(MHIGH,MEMUSED+NGSQ)
          CALL TRANP2E(NBASIS,NORB,0,ORBLAO(NOBADD1),W,NWSIZE,
     &                  LBUFF,IOTEMPA,IOTEMPB)
          CALL GREAD(W,NGSQ,LBUFF,IVBO2E)
C         NDBG=N2DADD(K)-1+NGSQ
          CALL TRACE2E(NORB,D2(N2DADD(K)),W,TR)
          ENERGY = ENERGY + TR
        END IF
        NOBADD1=NOBADD1+MLORBIT(K)*NBASIS
      ENDDO
      RETURN
      END
      SUBROUTINE ONETENE(NBASIS,NSUB,MLORBIT,RWRK,W,NSIZE,ENEONE)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Total energy of from 1E contribution
C
C     Note:
C               NSIZE > NBASIS*NBASIS*2
C
C     History:
C               First created in April 2004.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
      DIMENSION MLORBIT(*),RWRK(*),W(*)
      NBA2=NBASIS*(NBASIS+1)/2
      NDEN = 1
      NHAM = NDEN + NBA2
      NWK  = NHAM + NBA2
      NLAST= NWK  + NBASIS*NBASIS
      IF(NLAST.GE.NSIZE) CALL ABORT0('ONETENE001')
C
C     Calculate total density
C
      DO I=1,NBA2
        W(NDEN-1+I) =0.0D0
      ENDDO
C
C     TOTAL DENSITY
C
      NOBADD1= NAOBAS
      IFLAG  = 1
      DO K=1,NSUB
        CALL MATRAN2(MLORBIT(K),NBASIS,RWRK(NOBADD1),W(NWK),
     &             RWRK(ND1STA-1+N1DADD(K)),W(NDEN),IFLAG)
        NOBADD1=NOBADD1+MLORBIT(K)*NBASIS
      ENDDO
C
C     1E CONTRIBUTION
C
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL READ1E(IAO1E,W(NWK),W(NHAM),NBASIS)
      CALL HMTRACE(NBASIS,W(NHAM),W(NDEN),ENEONE)
      RETURN
      END
      SUBROUTINE HF2EENE(NBASIS,NSUB,MLORBIT,METHOD,RWRK,FKN,W,
     &                   NSIZE,ENERGY,IHF)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               2E energy contribution from HF type interaction
C               2E energy contribution from non-HF groups is not included.
C
C     Notes:    RWRK stores Lowdin orthogonalized orbitals of all groups and
C               the corresponding 1e and 2e densities of each group in its
C               own Lowdin orbital basis functions
C
C               W is a scratch space, used to store temp densities and the Fock
C               matrices of all groups(in global AO basis functions). The total
C               density and the corresponding Fock matrix are stored at the
C               slot NSUB+1. Approximate scratch space size is:
C
C               NBasis*(NBasis+1)*(NSUB+3)/2
C
C               On return, FKN holds (NSUB+1+NHFORB) Fock matrices for
C               group 1 ... NSUB, the total Fock matrix and optionally HF
C               orbitals
C
C
C     History:
C               First created in April 2004.
C               Added option for Fock matrices of HF orbitals. July 3, 2004.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
      DIMENSION MLORBIT(*),RWRK(*),FKN(*),W(*),METHOD(*)
      NBA2=NBASIS*(NBASIS+1)/2
C     NDEN = 1
C     NDENT= 1    + NBA2*NSUB
C     NFK  = NDENT + NBA2
C     NWK  = NFK  + NBA2*(NSUB+1)
C     NWK2 = NWK  + NBASIS*NBASIS
C     NFKT = NFK  + NBA2*NSUB

      NFK  = 1
      NFKT = NFK  + NBA2*NSUB
      NDEN = 1
      NDENT= NDEN + NBA2*NSUB
      NWK  = NDENT+ NBA2
      NWK2 = NWK  + NBASIS*NBASIS
      IF(NWK2.GE.NSIZE) CALL ABORT0('HF2EENE001')
C
C     Calculate total density
C
      DO I=1,NBA2*(NSUB+1)
        W(NDEN-1+I) =0.0D0
      ENDDO
C
C     Initialize ENERGY
C
      ENERGY = 0.0D0
      IFLAG=0
      NOBADD1=NAOBAS
      DO K=1,NSUB
      NDENK = NDEN + (K-1)*NBA2
        CALL MATRAN2(MLORBIT(K),NBASIS,RWRK(NOBADD1),W(NWK),
     &             RWRK(ND1STA-1+N1DADD(K)),W(NDENK),IFLAG)
        NOBADD1=NOBADD1+MLORBIT(K)*NBASIS
      ENDDO
C
C     IF THIS IS CALLED FROM HESSTE, THEN ALSO
C     COMPUTE DENSITY MATRIX FOR EACH HF ORBITAL DIRECTLY FROM ORBITLA
C
      NHFORB = 0
      IF(IHF.EQ.1) THEN
        NOBADD1 = NAOBAS
        NDENADD = NDENT
        DO K=1, NSUB
        IF(METHOD(K).EQ.1) THEN
          DO I=1, MLORBIT(K)
          NHFORB  = NHFORB + 1
          NADD    = NOBADD1 + (I-1)*NBASIS - 1
          NDENADD = NDENADD + NBASIS*(NBASIS+1)/2
          NDENJL  = NDENADD - 1
            DO J=1, NBASIS
            DO L=1, J
            NDENJL = NDENJL + 1
            W(NDENJL) = 2.0D0*RWRK(NADD+J)*RWRK(NADD+L)
            END DO
            END DO
          END DO
        END IF
        NOBADD1=NOBADD1+MLORBIT(K)*NBASIS
        END DO
      END IF
C
C     1E CONTRIBUTION
C
      DO K=1, NSUB
      NDENK = NDEN + (K-1)*NBA2
        DO J=1, NBA2
        W(NDENT-1+J) = W(NDENT-1+J)+W(NDENK-1+J)
        END DO
      END DO
C
C     2E CONTRIBUTION. FK TERMS/TOTAL DENSITY
C
      NHFMAT = NSUB + 1 + NHFORB
      CALL FKENGI(FKN(NFK),W(NDEN),NBASIS,NHFMAT)
      CALL HMTRACE(NBASIS,FKN(NFKT),W(NDENT),TR)
      ENERGY = ENERGY + TR*0.5D0
      DO K=1, NSUB
        IF(METHOD(K).NE.1) THEN
        NDENK = NDEN + (K-1)*NBA2
        NFKK  = NFK  + (K-1)*NBA2
        CALL HMTRACE(NBASIS,FKN(NFKK),W(NDENK),TR)
        ENERGY = ENERGY - TR*0.5D0
        END IF
      END DO
      RETURN
      END
      SUBROUTINE HMTRACE(NBASIS,A,B,TR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(*),B(*)
      NBA2 = NBASIS*(NBASIS+1)/2
      TR = 0.0D0
      DO I=1, NBA2
      TR = TR + A(I)*B(I)*2.0D0
      END DO
      DO I=1, NBASIS
      II = I*(I+1)/2
      TR = TR - A(II)*B(II)
      END DO
      RETURN
      END
      SUBROUTINE TRACE2E(NORB,D2,G,TR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION D2(*),G(*)
      TR = 0.0D0
      DO I=1,NORB
      DO J=1,I
      IJ=I*(I-1)/2+J
        DO K=1,I
        LL=K
        IF(K.EQ.I) LL=J
        DO L=1,LL
        KL=K*(K-1)/2+L
        IJKL = IJ00(IJ,KL)
        TR = TR +D2(IJKL)*G(IJKL)
C       WRITE(IOUTVB,*)'TR2: D2, G=',D2(IJKL),G(IJKL)
        END DO
        END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE HESSTE(NBASIS,NOCB,DERV,HESS,NDH2,RWRK,NHFORB,
     &FKN,W,ORBLAO,NDH,NOBACC,NHESADD,D1,D2,NWSIZE,LD1ADD,
     &LD2ADD,ER,ENERGY,MITER)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               The 1st and 2nd derivatives of total energy with respect
C               to the rigid rotation parameters.
C     Notes:
C               Density matrices and integrals in Lowdin basis set are
C               used.
C
C               Minimal scratch space size = MAX(MSCR1,MSCR3)
C
C     History:
C               First created in Feb. 1999.
C
C               Recoded in September, 1999.
C
C               Added new algorithm for total energy evaluation
C               Added TRANP2E, automatic switch from TRANN2E to TRANP2E
C               when the scratch space is low. More efficient usage of
C               scratch space. June 2004.
C
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION W(*),ORBLAO(*),D1(*),D2(*),LD1ADD(*),LD2ADD(*)
      PARAMETER (MAXBFN=726)
      PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA,MAXGRP=99)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(MAXGRP),MSPIN(MAXGRP),MNORBIT(MAXGRP),
     &MLORBIT(MAXGRP),MWIN(MAXGRP),MSTR(MAXGRP),METHOD(MAXGRP),
     &IBASIS(MAXEXT),NOCC(MAXEXT),NOBIAS,NEPS,NVIR,NOTROT(5000),
     &LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(MAXGRP)
      DIMENSION HESS(*),DERV(*)
      DIMENSION NOBACC(*),NHESADD(*)
      DIMENSION FKN(*),NHFOADD(99)
      COMMON /IAA/IA(100000)
      COMMON /IBB/IB(100000),MWINZ,MBORZ
C     COMMON /IDD/ID(100000)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /VB2MEM/LOCX,LOCMEM,LOFFS,MEMWRK,MSCRATCH,MHIGH
      LOGICAL BLKHESS
      BLKHESS = .TRUE.
      MEMUSED = MSCRATCH - NWSIZE
C
C     FOR UNSTABLE SYSTEM, USE FULL HESSIAN
C
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$FULLHESS',9,IOK,0)
      IF(IOK.EQ.1) BLKHESS = .FALSE.
      IF(NDH.EQ.0) RETURN
C
C     ADDRESS AND MAP
C
      DO I=1,NDH
      DERV(I)=0.0D0
      END DO
      DO I=1,NDH2
      HESS(I)=0.0D0
      END DO
C     MWINDX=NBASIS
C
C     SET INDEX
C
      CALL SETIND(NBASIS,NOCB)
      NV     = IB(NBASIS+1)
      NSQ    = NOCB*(NOCB+1)/2
      MSQ    = NBASIS*(NBASIS+1)/2
      NGSQ   = NV*(NV+1)/2+(MSQ-NV)*NSQ
      MGSQ   = IA(MSQ+1)
      NMSQ   = NBASIS*MSQ
C
      MMS    = 1
      MMH    = MMS+MSQ
      MMG    = MMH+MSQ
C     MLAST1 = MM3+MSQ
C     NWRK   = NWSIZE - MMG
C
C     Scratch for TRAN1E
C
C     MA1    = MMH+MSQ
C     MA2    = MA1+NBASIS*NBASIS
C
C     Scratch for TRANN2E
C
      MBG    = 1
      MB1    = MBG + MGSQ
      MB2    = MB1 + NBASIS*NBASIS
      MB3    = MB2 + NMSQ
      MB4    = MB3 + MSQ
C
C     CHECK WORK SPACE AND ITRAN OPTION
C
      ITRAN = 2
      IF(NBASIS.GT.360) GOTO 998
      NBA2  = NBASIS*(NBASIS+1)/2
      MSCR1 = NBASIS**3
      MSCR2 = NBASIS**2 + IA(NBA2+1)
      MSCR3 = NGSQ + NBASIS**2
      IF(NWSIZE.LT.MSCR1.OR.NWSIZE.LT.MSCR3)  THEN
        NEED1 = MAX(MSCR1,MSCR3) - NWSIZE
        NEED2 = MSCR2 - NWSIZE
        IF(MB4-NWSIZE.GT.NEED2) NEED2 = MB4-NWSIZE
        WRITE(IOUTVB,*)
     &   'You need at least ',MSCRATCH+NEED1,' double words '
        WRITE(IOUTVB,*) 'Please use the $MEMORY keyword to specify at'
        WRITE(IOUTVB,*)' least that amount of scratch memory.'
        WRITE(IOUTVB,*)'For more efficient 2E transformation you need'
        WRITE(IOUTVB,*)'at least ',MSCRATCH+NEED2,' double words '
        CALL ABORT0('HESSTE0000')
      END IF
C
C     CHECK IF IN-CORE TRANSFORMATION IS POSSIBLE
C
      IF(NWSIZE.GT.MSCR2.AND.NWSIZE.GT.MB4) THEN
        ITRAN = 1
        MHIGH = MAX(MHIGH, MEMUSED+MB4)
C       ONLY REPORT ONCE AT THE VERY END
C       WRITE(IOUTVB,'(" MHIGH",2I12)') 4,MHIGH
      ENDIF
 998  CONTINUE
CSMI  ITRAN = 2
      IF(ITRAN.EQ.2) THEN
C
C     IN DISK-MODE, ALL MEMORY IS USED
C
      MHIGH = MSCRATCH
C     WRITE(IOUTVB,'(" MHIGH",2I12)') 5,MHIGH
C
C     PRINT A WARNING MESSAGE FOR DISK-TRANSFORMATION MODE
C
      MORENEED = MSCR2 - NWSIZE
      IF(MB4-NWSIZE.GT.MORENEED) MORENEED = MB4-NWSIZE
C
C     PRINT THE MESSAGE FOR THE FIRST ITERATION
C
      IF(MITER.EQ.1) THEN
       WRITE(IOUTVB,*)'DISK MODE FOR 2E TRANSFORMATION'
       WRITE(IOUTVB,*)
     &  'You need at least ',MSCRATCH+MORENEED,' double words'
       WRITE(IOUTVB,*)'for more efficient 2E transformation. '
       IF(KEY(15).EQ.1.AND.MNORBIT(NSUB).GE.30) THEN
        WRITE(IOUTVB,
     &  '(" SPHER group dimension",I3," > 29 has bug.")') MNORBIT(NSUB)
        WRITE(IOUTVB,
     &  '(" Use memory as specified above for in-core transformation."
     &  ," Aborting this run.")')
        CALL ABRTVB()
       ELSE
        WRITE(IOUTVB,*)
     &   'Please use $MEMORY keyword to specify at least that'
        WRITE(IOUTVB,*)'amount of scratch space.'
       ENDIF
      END IF
      END IF
      E1HF2E = ER
C
C     GET ONETENE AND HF2E
C
C     1E CONTRIBUTION
C
      CALL ONETENE(NBASIS,NSUB,MLORBIT,RWRK,W,NWSIZE,ENEONE)
      E1HF2E = E1HF2E + ENEONE
C
C     2E HARTREE-FOCK CONTRIBUTION
C     ALSO COMPUTE FOCK MATRICES FOR ALL HF ORBITALS
C
      TIME1 = XCLOCK()
      IHF = 1
      CALL HF2EENE(NBASIS,NSUB,MLORBIT,METHOD,RWRK,FKN,W,NWSIZE,HF2E,
     &             IHF)
      E1HF2E = E1HF2E + HF2E
      ENERGY = E1HF2E
      TIME2 = XCLOCK()
C     WRITE(IOUTVB,*)'HF TIME FOR IHF(1) =',TIME2-TIME1
C
C     END OF ENERGY
C
C     TRANSFORMATION OF FKN
C
      NFK   = 1
      NBAS2 = NBASIS*NBASIS
      DO  I = 1, NSUB+1+NHFORB
      CALL MATRAN(NBASIS,NBASIS,ORBLAO,W(NBAS2),FKN(NFK),W)
        DO J=1, MSQ
        FKN(NFK-1+J) = W(J)
        END DO
      NFK = NFK + MSQ
      END DO
C
C     TODO: NEED A CHECK FOR WORKING SPACE.
C
C     NVIRX  = NBASIS - NOCB
C
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL GETIOUNIT('IAO2E   ',IAO2E)
      CALL GETIOUNIT('IVBO2E  ',IVBO2E)
      LBUFF = 4095
      REWIND(IVBO2E)
C
C     WRITE TWO EMPTY RECORDS!
C
      WRITE(IVBO2E)
      WRITE(IVBO2E)
      TIME=XCLOCK()
      IF(ITRAN.EQ.1) THEN
C
C     IN-CORE MODE
C
C     ZERO 2E INTEGRALS
C
      MSQ2 = MSQ*(MSQ+1)/2
      DO I=1,MSQ2
      W(MBG-1+I) = 0.0D0
      END DO
      CALL READ2E(IAO2E,W(MBG))
      CALL TRANN2E(NBASIS,NOCB,NVIR,W(MBG),ORBLAO,
     & W(MB1),W(MB2),W(MB3),LBUFF,IVBO2E)
      ELSE
C
C     DISK MODE
C
      CALL GETIOUNIT('IOTEMPA ',IOTEMPA)
      CALL GETIOUNIT('IOTEMPB ',IOTEMPB)
      NWRK1 = NWSIZE
      CALL TRANP2E(NBASIS,NOCB,NVIR,ORBLAO,W(MBG),NWRK1,LBUFF,
     &             IOTEMPA,IOTEMPB)
      END IF
      TIME1=XCLOCK()
      TIME=TIME1-TIME
C     WRITE(IOUTVB,'(' 2E-TRAN TIME FOR ROTRAN=',F8.3)')TIME
C
C     TRANSFORMATION OF CORE HAMILTONAIN
C     IN THE FOLLOWING READ1E,W(MMS) HOLDS CORE H, AND W(MMH) HOLDS OVERLAP
C
      CALL READ1E(IAO1E,W(MMH),W(MMS),NBASIS)
C
C     AFTER TRANSFORMATION, W(MMH) HOLDS THE TRANFORMED CORE H
C
      CALL MATRAN(NBASIS,NBASIS,ORBLAO,W(MMH+MSQ),W(MMS),
     &            W(MMH))
C
C     ADD CORE H TO THE TOTAL FOCK MATRIX
C
      NFNT = 1 + NSUB*MSQ
      DO I=1, MSQ
      FKN(NFNT-1+I) = W(MMH-1+I) + FKN(NFNT-1+I)
      END DO
      CALL GREAD(W(MMG),NGSQ,LBUFF,IVBO2E)
C     NBM1=0
C
C     SETUP NHFOADD
C
      NHFOADD(1) = 0
      DO M1=2, NSUB
      NHFOADD(M1) = NHFOADD(M1-1)
      IF(METHOD(M1-1).EQ.1) THEN
      NHFOADD(M1) = NHFOADD(M1-1) + MNORBIT(M1-1)
      END IF
      END DO
C
      DO 999 M1=1,NSUB
C
C     COMPUTE NON-HF 2E ENERGY
C
      IF(METHOD(M1).NE.1) THEN
      IJKL1=LD2ADD(M1)-1
      DO I=1,MNORBIT(M1)
      DO J=1,I
      IJ=I*(I-1)/2+J
      IG=I+NOBACC(M1)
      JG=J+NOBACC(M1)
      IJG=IJ00(IG,JG)
        DO K=1,I
        LL=K
        IF(K.EQ.I) LL=J
        DO L=1,LL
        KG=K+NOBACC(M1)
        LG=L+NOBACC(M1)
        KL=K*(K-1)/2+L
        KLG=IJ00(KG,LG)
        IJKLG=IJ00(IJG,KLG)
        IJKL=IJKL1+IJ00(IJ,KL)
        ENERGY=ENERGY+D2(IJKL)*W(MMG-1+IJKLG)
        END DO
        END DO
      END DO
      END DO
      END IF
 999  CONTINUE
C
C     NEW CODE
C
C     W(MMS): SCRATCH
C     W(MMH): CORE H
C     W(MMG): 2E IN ORTHOGONAL BASIS FUNCTIONS
C     FKN:    FOCK MATRICES
C
      NHGRP = 0
      NHDIM = 0
      DO 3 MI=1,NSUB-1
      DO 3 MJ=MI+1,NSUB
      IF (NOTROT((MJ-1)*(MJ-2)/2+MI).NE.0) GOTO 2
      NDIMGRP = MNORBIT(MI)*MNORBIT(MJ)
      NHGRP = NHGRP + 1
      NHESTART = NHESADD(NHGRP)+1
C
C     EFFECTIVE POTENTIAL OF GROUP I AND J
C
C     HEFF = FKNT - FKI - FKJ
C
      NFKI = (MI-1)*MSQ
      NFKJ = (MJ-1)*MSQ
      NFNT =  NSUB*MSQ
      DO L1=1,MSQ
      W(MMH-1+L1)=FKN(NFNT+L1)-FKN(NFKI+L1)-FKN(NFKJ+L1)
      END DO
      IOPTION = 1
      IF(METHOD(MI).EQ.1.AND.BLKHESS) THEN
      IOPTION = 0
C
C     MTFKI: FORK MATRIX OF GROUP MI
C     MOFKI: FORK MATRICES OF MOs of GROUP MI
C
      MTFKI1 = NFKI+1
      MOFKI1 = (NSUB+1+NHFOADD(MI))*MSQ+1
      CALL MIXHFK(NBASIS,MNORBIT(MI),MNORBIT(MJ),METHOD(MI),METHOD(MJ),
     & NOBACC(MI),NOBACC(MJ),W(MMH),D1(LD1ADD(MI)),D1(LD1ADD(MJ)),
     & D2(LD2ADD(MI)),D2(LD2ADD(MJ)),W(MMG),IOPTION,
     & FKN(MTFKI1),FKN(MOFKI1),DERV(NHDIM+1),HESS(NHESTART))
      ELSE
      CALL MIXGIJ(MNORBIT(MI),MNORBIT(MJ),METHOD(MI),METHOD(MJ),
     & NOBACC(MI),NOBACC(MJ),W(MMH),D1(LD1ADD(MI)),D1(LD1ADD(MJ)),
     & D2(LD2ADD(MI)),D2(LD2ADD(MJ)),W(MMG),IOPTION,DERV(NHDIM+1),
     & HESS(NHESTART))
      END IF
      NHDIM = NHDIM + NDIMGRP
 2    CONTINUE
 3    CONTINUE
      DO 4 MI=1, NSUB
      IF ((NOTROT(NSUB*(NSUB-1)/2+MI).EQ.0).AND.METHOD(MI).NE.1) THEN
      NHGRP = NHGRP + 1
      NHESTART = NHESADD(NHGRP)+1
      NDIMGRP = MNORBIT(MI)*NVIR
C
C     EFFECTIVE POTENTIAL OF GROUP I
C
C     HEFF = FKNT - FKI
C
      NFKI = (MI-1)*MSQ
      NFNT =  NSUB*MSQ
      DO L1=1,MSQ
      W(MMH-1+L1)=FKN(NFNT+L1)-FKN(NFKI+L1)
      END DO
      IOPTION = 1
C     IF(BLKHESS) IOPTION = 0
      CALL MIXVIR(MNORBIT(MI),NVIR,METHOD(MI),
     & NOBACC(MI),NOBACC(NSUB+1),W(MMH),D1(LD1ADD(MI)),
     & D2(LD2ADD(MI)),W(MMG),IOPTION,DERV(NHDIM+1),HESS(NHESTART))
      NHDIM = NHDIM + NDIMGRP
      END IF
 4    CONTINUE
      TIME2=XCLOCK()
      TIME=TIME2-TIME1
C     WRITE(IOUTVB,'(' HESSIAN TIME FOR ROTRAN=',F8.3)')TIME
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     FUNCTION: COMPUTE HESSIAN OF RIGID ROTATION BETWEEN GROUP I AND J
C
C     NOTES:
C             W(MMS): SCRATCH
C             W(MMH): CORE H
C             W(MMG): 2E IN ORTHOGONAL BASIS FUNCTIONS
C             FKN:    FOCK MATRICES
C             IOPTION: 1 (FULL HESSIAN FOR GROUP I,J), 0 (BLOCK DIAGONAL)
C
C     HISTORY:
C
C             First version: June 30, 2004
C
C     AUTHOR:
C             Jiabo Li
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE MIXGIJ(MORBI,MORBJ,MTDI,MTDJ,NOBADDI,NOBADDJ,HEFF,
     &                  D1A,D1B,D2A,D2B,G,IOPTION,DERV,HESS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION HEFF(*),D1A(*),D1B(*),D2A(*),D2B(*),G(*),DERV(*),HESS(*)
      DIMENSION IJKL4(4),IFLAG(4)
      LOGICAL BLKHESS,COMPHESS
      BLKHESS = .FALSE.
      IF(IOPTION.EQ.0) BLKHESS=.TRUE.
      DO I=1, MORBI*MORBJ
      DERV(I) = 0.0D0
      END DO
      NDH1 = MORBI*MORBJ
      NDH2 = NDH1*(NDH1+1)/2
      DO I=1, NDH2
      HESS(I) = 0.0D0
      END DO
C
C     ENERGY OF GROUP I AND GROUP J IN THE HEFF
C
      ETEMP = 0.0D0
      IJ = 0
      DO I=1,MORBI
      DO J=1, I
      IG = I + NOBADDI
      JG = J + NOBADDI
      IJ = IJ00(I,J)
      IJG=IJ00(IG,JG)
      FAC = 1.0D0
      IF(I.NE.J) FAC = 2.0D0
      D1AIJ = D1A(IJ)*FAC
      ETEMP = ETEMP + FAC*D1A(IJ)*HEFF(IJG)
C
C       I-> IP (IP in GROUP B)
C       J-> IP
C
        IX1 = I
        DO IP=1, MORBJ
        I2IP = (I-1)*MORBJ + IP
        IPX  = NOBADDJ+ IP
        IJX = IJ00(IPX,JG)
        DERV(I2IP) = DERV(I2IP) + D1AIJ*HEFF(IJX)
C       GOTO 991
C
C       HESS
C          IP -> IPP (IPP in GROUP A)
C          J  -> JP  (JP in GROUP B)
           DO IPP = 1, MORBI
           IP2I  = (IPP-1)*MORBJ + IP
           IX2   = IPP
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(IP2I.GE.I2IP.AND.COMPHESS) THEN
           IPPX  = NOBADDI + IPP
           IJHES = IJ00(I2IP,IP2I)
           IJXX  = IJ00(IPPX,JG)
           HESS(IJHES) = HESS(IJHES) - D1AIJ*HEFF(IJXX)
C          CONTRI = - D1AIJ*HEFF(IJXX)
           END IF
           END DO
           DO JP = 1, MORBJ
           J2JP  = (J-1)*MORBJ + JP
           IX2   = J
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(J2JP.GE.I2IP.AND.COMPHESS) THEN
           JPX   = NOBADDJ + JP
           IJXX  = IJ00(IPX,JPX)
           IJHES = IJ00(I2IP,J2JP)
           HESS(IJHES) = HESS(IJHES) + D1AIJ*HEFF(IJXX)
C          CONTRI =  D1AIJ*HEFF(IJXX)
           END IF
           END DO
C991       CONTINUE
        END DO
C
        IX1 = J
        DO JP=1, MORBJ
        J2JP = (J-1)*MORBJ + JP
        JPX  = NOBADDJ+ JP
        IJX  = IJ00(IG,JPX)
        DERV(J2JP) = DERV(J2JP) + D1AIJ*HEFF(IJX)
C       GOTO 992
C
C       HESS
C          I  -> IP
C          JP -> JPP
           DO IP = 1, MORBJ
           I2IP = (I-1)*MORBJ + IP
           IX2   = I
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(I2IP.GE.J2JP.AND.COMPHESS) THEN
           IPX  = NOBADDJ + IP
           IJXX = IJ00(IPX,JPX)
           IJHES= IJ00(I2IP,J2JP)
           HESS(IJHES) = HESS(IJHES) + D1AIJ*HEFF(IJXX)
C          CONTRI =  D1AIJ*HEFF(IJXX)
           END IF
           END DO
           DO JPP=1, MORBI
           JP2J = (JPP-1)*MORBJ + JP
           IX2   = JPP
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(JP2J.GE.J2JP.AND.COMPHESS) THEN
           JPPX = NOBADDI + JPP
           IJHES= IJ00(J2JP,JP2J)
           IJXX = IJ00(IG,JPPX)
           HESS(IJHES) = HESS(IJHES) - D1AIJ*HEFF(IJXX)
C          CONTRI = -D1AIJ*HEFF(IJXX)
           END IF
           END DO
C992       CONTINUE
        END DO
      END DO
      END DO
C
      IJ = 0
      DO I=1,MORBJ
      DO J=1, I
      IG = I + NOBADDJ
      JG = J + NOBADDJ
      IJ = IJ00(I,J)
      IJG=IJ00(IG,JG)
      FAC = 1.0D0
      IF(I.NE.J) FAC = 2.0D0
      D1BIJ = D1B(IJ)*FAC
      ETEMP = ETEMP + FAC*D1B(IJ)*HEFF(IJG)
C     WRITE(IOUTVB,*)'DBG SOURCE: I,J,IG,JG,D1B,H',I,J,IG,JG,D1BIJ,
C    &                       HEFF(IJG)
C       I-> IP (IP in GROUP A)
C       J-> IP
C
        DO IP=1, MORBI
        I2IP = (IP-1)*MORBJ + I
        IPX  = NOBADDI+ IP
        IJX  = IJ00(IPX,JG)
        DERV(I2IP) = DERV(I2IP) - D1BIJ*HEFF(IJX)
C       GOTO 993
C
C       HESS
C          IP -> IPP (IPP in GROUP B)
C          J  -> JP  (JP in GROUP A)
           IX1 = IP
           DO IPP = 1, MORBJ
           IP2I  = (IP-1)*MORBJ + IPP
           IX2   = IP
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(IP2I.GE.I2IP.AND.COMPHESS) THEN
           IPPX  = NOBADDJ + IPP
           IJHES = IJ00(I2IP,IP2I)
           IJXX  = IJ00(IPPX,JG)
           HESS(IJHES) = HESS(IJHES) - D1BIJ*HEFF(IJXX)
C          CONTRI = -D1BIJ*HEFF(IJXX)
           END IF
           END DO
           DO JP = 1, MORBI
           J2JP  = (JP-1)*MORBJ + J
           IX2   = JP
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(J2JP.GE.I2IP.AND.COMPHESS) THEN
           JPX   = NOBADDI + JP
           IJXX  = IJ00(IPX,JPX)
           IJHES = IJ00(I2IP,J2JP)
           HESS(IJHES) = HESS(IJHES) + D1BIJ*HEFF(IJXX)
C          CONTRI =  D1BIJ*HEFF(IJXX)
           END IF
           END DO
C993       CONTINUE
        END DO
        DO JP=1, MORBI
        J2JP = (JP-1)*MORBJ + J
        JPX  = NOBADDI+ JP
        IJX = IJ00(IG,JPX)
        DERV(J2JP) = DERV(J2JP) - D1BIJ*HEFF(IJX)
C       GOTO 994
C
C       HESS
C          I  -> IP  (IN GROUP A)
C          JP -> JPP (IN GROUP B)
           IX1 = JP
           DO IP = 1, MORBI
           I2IP = (IP-1)*MORBJ + I
           IX2 = IP
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(I2IP.GE.J2JP.AND.COMPHESS) THEN
           IPX  = NOBADDI + IP
           IJXX = IJ00(IPX,JPX)
           IJHES= IJ00(I2IP,J2JP)
           HESS(IJHES) = HESS(IJHES) + D1BIJ*HEFF(IJXX)
C          CONTRI =  D1BIJ*HEFF(IJXX)
           END IF
           END DO
           DO JPP=1, MORBJ
           JP2J = (JP-1)*MORBJ + JPP
           IX2 = JP
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(JP2J.GE.J2JP.AND.COMPHESS) THEN
           JPPX = NOBADDJ + JPP
           IJHES= IJ00(J2JP,JP2J)
           IJXX = IJ00(IG,JPPX)
           HESS(IJHES) = HESS(IJHES) - D1BIJ*HEFF(IJXX)
C          CONTRI = -D1BIJ*HEFF(IJXX)
           END IF
           END DO
C994       CONTINUE
C
        END DO
      END DO
      END DO
      IFLAG(1) = 1
      IFLAG(2) = 1
      IFLAG(3) = 1
      IFLAG(4) = 1
C
C     IF GROUP I IS NOT A HF GROUP
C
      IF(MTDI.NE.1) THEN
      DO I=1,MORBI
      II = I*(I-1)/2
      IG = I+NOBADDI
      IIG= IG*(IG-1)/2
      DO J=1,I
      IJ = II+J
      JG = J+NOBADDI
      IJG= IIG + JG
        DO K=1,I
        LL  = K
        KK  = K*(K-1)/2
        KG  = K+NOBADDI
        KKG = KG*(KG-1)/2
        IF(K.EQ.I) LL=J
        DO L=1,LL
        LG = L+NOBADDI
        KL = KK+L
        KLG= KKG + LG
        IJKLG= IJ00(IJG,KLG)
        IJKL = IJ00(IJ,KL)
        D2AIJKL = D2A(IJKL)
        ETEMP=ETEMP+D2A(IJKL)*G(IJKLG)
        IJKL4(1) = I
        IJKL4(2) = J
        IJKL4(3) = K
        IJKL4(4) = L
        CALL HESSGAB(MORBI,MORBJ,NOBADDI,NOBADDJ,D2AIJKL,IJKL4,
     &               IFLAG,IOPTION,HESS,G)
C
C       I-> IP
C       J-> JP
C       K-> KP
C       L-> LP
C       (IP,JP,KP AND LP in GROUP B, PAIR FACTOR=1.0
C
           KLG = IJ00(KG,LG)
           DO IP=1, MORBJ
           IPX = IP + NOBADDJ
           I2IP= (I-1)*MORBJ + IP
           IJG = IJ00(IPX,JG)
           IJKLG = IJ00(IJG,KLG)
           DERV(I2IP) = DERV(I2IP) + D2A(IJKL)*G(IJKLG)
           END DO
           DO JP=1, MORBJ
           JPX = JP + NOBADDJ
           J2JP= (J-1)*MORBJ + JP
           IJG = IJ00(IG,JPX)
           IJKLG = IJ00(IJG,KLG)
           DERV(J2JP) = DERV(J2JP) + D2A(IJKL)*G(IJKLG)
           END DO
           IJG = IJ00(IG,JG)
           DO KP=1, MORBJ
           KPX = KP + NOBADDJ
           K2KP= (K-1)*MORBJ + KP
           KLG = IJ00(KPX,LG)
           IJKLG = IJ00(IJG,KLG)
           DERV(K2KP) = DERV(K2KP) + D2A(IJKL)*G(IJKLG)
           END DO
           DO LP=1, MORBJ
           LPX = LP + NOBADDJ
           L2LP= (L-1)*MORBJ + LP
           KLG = IJ00(KG,LPX)
           IJKLG = IJ00(IJG,KLG)
           DERV(L2LP) = DERV(L2LP) + D2A(IJKL)*G(IJKLG)
           END DO
        END DO
        END DO
      END DO
      END DO
      ELSE
C
C     GROUP MI IS A HF GROUP
C
      DO I=1,MORBI
      DO J=1,I
      IJ=I*(I-1)/2+J
      IG=I+NOBADDI
      JG=J+NOBADDI
      IJG=IJ00(IG,JG)
        DO K=1,I
        LL=K
        IF(K.EQ.I) LL=J
        DO L=1,LL
        KG=K+NOBADDI
        LG=L+NOBADDI
        KL=K*(K-1)/2+L
        KLG=IJ00(KG,LG)
        IJKLG=IJ00(IJG,KLG)
             DDD=0.0D0
               IF(IJ.EQ.KL) THEN
                DDD=1.0D0
                    IF(I.NE.J) DDD=-2.0D0
               ELSE IF(I.EQ.J.AND.K.EQ.L) THEN
               DDD=4.0D0
               END IF
        IF(DDD.NE.0.0D0) THEN
        ETEMP=ETEMP+DDD*G(IJKLG)
        IJKL4(1) = I
        IJKL4(2) = J
        IJKL4(3) = K
        IJKL4(4) = L
        CALL HESSGAB(MORBI,MORBJ,NOBADDI,NOBADDJ,DDD,IJKL4,
     &               IFLAG,IOPTION,HESS,G)
C
C       I-> IP
C       J-> JP
C       K-> KP
C       L-> LP
C       (IP,JP,KP AND LP in GROUP B, PAIR FACTOR=1.0
C
           D2AIJKL = DDD
           KLG = IJ00(KG,LG)
           DO IP=1, MORBJ
           IPX = IP + NOBADDJ
           I2IP= (I-1)*MORBJ + IP
           IJG = IJ00(IPX,JG)
           IJKLG = IJ00(IJG,KLG)
           DERV(I2IP) = DERV(I2IP) + D2AIJKL*G(IJKLG)
           END DO
           DO JP=1, MORBJ
           JPX = JP + NOBADDJ
           J2JP= (J-1)*MORBJ + JP
           IJG = IJ00(IG,JPX)
           IJKLG = IJ00(IJG,KLG)
           DERV(J2JP) = DERV(J2JP) + D2AIJKL*G(IJKLG)
           END DO
           IJG = IJ00(IG,JG)
           DO KP=1, MORBJ
           KPX = KP + NOBADDJ
           K2KP= (K-1)*MORBJ + KP
           KLG = IJ00(KPX,LG)
           IJKLG = IJ00(IJG,KLG)
           DERV(K2KP) = DERV(K2KP) + D2AIJKL*G(IJKLG)
           END DO
           DO LP=1, MORBJ
           LPX = LP + NOBADDJ
           L2LP= (L-1)*MORBJ + LP
           KLG = IJ00(KG,LPX)
           IJKLG = IJ00(IJG,KLG)
           DERV(L2LP) = DERV(L2LP) + D2AIJKL*G(IJKLG)
           END DO
        END IF
        END DO
        END DO
      END DO
      END DO
      END IF
      IFLAG(1) =-1
      IFLAG(2) =-1
      IFLAG(3) =-1
      IFLAG(4) =-1
C
C     IF GROUP MJ IS NOT A HF GROUP
C
      IF(MTDJ.NE.1) THEN
      DO I=1,MORBJ
      DO J=1,I
      IJ=I*(I-1)/2+J
      IG=I+NOBADDJ
      JG=J+NOBADDJ
      IJG=IJ00(IG,JG)
        DO K=1,I
        LL=K
        IF(K.EQ.I) LL=J
        DO L=1,LL
        KG=K+NOBADDJ
        LG=L+NOBADDJ
        KL=K*(K-1)/2+L
        KLG=IJ00(KG,LG)
        IJKLG=IJ00(IJG,KLG)
        IJKL=IJ00(IJ,KL)
        D2BIJKL = D2B(IJKL)
        ETEMP=ETEMP+D2B(IJKL)*G(IJKLG)
        IJKL4(1) = I
        IJKL4(2) = J
        IJKL4(3) = K
        IJKL4(4) = L
        CALL HESSGAB(MORBI,MORBJ,NOBADDI,NOBADDJ,D2BIJKL,IJKL4,
     &               IFLAG,IOPTION,HESS,G)
C
C       I-> IP
C       J-> JP
C       K-> KP
C       L-> LP
C       (IP,JP,KP AND LP in GROUP A, PAIR FACTOR=-1.0
C
           KLG = IJ00(KG,LG)
           DO IP=1, MORBI
           IPX = IP + NOBADDI
           I2IP= (IP-1)*MORBJ + I
           IJG = IJ00(IPX,JG)
           IJKLG = IJ00(IJG,KLG)
           DERV(I2IP) = DERV(I2IP) - D2B(IJKL)*G(IJKLG)
           END DO
           DO JP=1, MORBI
           JPX = JP + NOBADDI
           J2JP= (JP-1)*MORBJ + J
           IJG = IJ00(IG,JPX)
           IJKLG = IJ00(IJG,KLG)
           DERV(J2JP) = DERV(J2JP) - D2B(IJKL)*G(IJKLG)
           END DO
           IJG = IJ00(IG,JG)
           DO KP=1, MORBI
           KPX = KP + NOBADDI
           K2KP= (KP-1)*MORBJ + K
           KLG = IJ00(KPX,LG)
           IJKLG = IJ00(IJG,KLG)
           DERV(K2KP) = DERV(K2KP) - D2B(IJKL)*G(IJKLG)
           END DO
           DO LP=1, MORBI
           LPX = LP + NOBADDI
           L2LP= (LP-1)*MORBJ + L
           KLG = IJ00(KG,LPX)
           IJKLG = IJ00(IJG,KLG)
           DERV(L2LP) = DERV(L2LP) - D2B(IJKL)*G(IJKLG)
           END DO
        END DO
        END DO
      END DO
      END DO
      ELSE
C
C     GROUP MJ IS A HF GROUP
C
      DO I=1,MORBJ
      DO J=1,I
      IJ=I*(I-1)/2+J
      IG=I+NOBADDJ
      JG=J+NOBADDJ
      IJG=IJ00(IG,JG)
        DO K=1,I
        LL=K
        IF(K.EQ.I) LL=J
        DO L=1,LL
        KG=K+NOBADDJ
        LG=L+NOBADDJ
        KL=K*(K-1)/2+L
        KLG=IJ00(KG,LG)
        IJKLG=IJ00(IJG,KLG)
             DDD=0.0D0
               IF(IJ.EQ.KL) THEN
                DDD=1.0D0
                    IF(I.NE.J) DDD=-2.0D0
               ELSE IF(I.EQ.J.AND.K.EQ.L) THEN
               DDD=4.0D0
               END IF
        IF(DDD.NE.0.0D0) THEN
        ETEMP=ETEMP+DDD*G(IJKLG)
        IJKL4(1) = I
        IJKL4(2) = J
        IJKL4(3) = K
        IJKL4(4) = L
        CALL HESSGAB(MORBI,MORBJ,NOBADDI,NOBADDJ,DDD,IJKL4,
     &               IFLAG,IOPTION,HESS,G)
C
C       I-> IP
C       J-> JP
C       K-> KP
C       L-> LP
C       (IP,JP,KP AND LP in GROUP A, PAIR FACTOR=-1.0
C
           D2BIJKL = DDD
           KLG = IJ00(KG,LG)
           DO IP=1, MORBI
           IPX = IP + NOBADDI
           I2IP= (IP-1)*MORBJ + I
           IJG = IJ00(IPX,JG)
           IJKLG = IJ00(IJG,KLG)
           DERV(I2IP) = DERV(I2IP) - D2BIJKL*G(IJKLG)
           END DO
           DO JP=1, MORBI
           JPX = JP + NOBADDI
           J2JP= (JP-1)*MORBJ + J
           IJG = IJ00(IG,JPX)
           IJKLG = IJ00(IJG,KLG)
           DERV(J2JP) = DERV(J2JP) - D2BIJKL*G(IJKLG)
           END DO
           IJG = IJ00(IG,JG)
           DO KP=1, MORBI
           KPX = KP + NOBADDI
           K2KP= (KP-1)*MORBJ + K
           KLG = IJ00(KPX,LG)
           IJKLG = IJ00(IJG,KLG)
           DERV(K2KP) = DERV(K2KP) - D2BIJKL*G(IJKLG)
           END DO
           DO LP=1, MORBI
           LPX = LP + NOBADDI
           L2LP= (LP-1)*MORBJ + L
           KLG = IJ00(KG,LPX)
           IJKLG = IJ00(IJG,KLG)
           DERV(L2LP) = DERV(L2LP) - D2BIJKL*G(IJKLG)
           END DO
        END IF
        END DO
        END DO
      END DO
      END DO
      END IF
C
C    INTERACTION OF GROUP MI AND MJ
C
      IFLAG(1) = 1
      IFLAG(2) = 1
      IFLAG(3) =-1
      IFLAG(4) =-1
      DO I=1,MORBI
      DO J=1,I
      FACIJ = 2.0D0
      IF(I.EQ.J) FACIJ=1.0D0
      IJ=IJ00(I,J)
      IG=I+NOBADDI
      JG=J+NOBADDI
      IJG=IJ00(IG,JG)
      DO K=1,MORBJ
      DO L=1,MORBJ
      KL=IJ00(K,L)
      KG=K+NOBADDJ
      LG=L+NOBADDJ
      KLG=IJ00(KG,LG)
      IJKLG=IJ00(IJG,KLG)
      IKG=IJ00(IG,KG)
      JLG=IJ00(JG,LG)
      IKJLG=IJ00(IKG,JLG)
      D1AB=D1A(IJ)*D1B(KL)*FACIJ
      ETEMP=ETEMP+D1AB*(G(IJKLG)-0.5D0*G(IKJLG))
      IJKL4(1) = I
      IJKL4(2) = J
      IJKL4(3) = K
      IJKL4(4) = L
      CALL HESSGAB(MORBI,MORBJ,NOBADDI,NOBADDJ,D1AB,IJKL4,
     &             IFLAG,IOPTION,HESS,G)
C
C     SYMMETRY, REDUCE IT
C
C     I->IP, J->JP  (IP,JP in GROUP B, PAIR FACTOR = 1.0D0)
C     K->KP, L->LP  (KP,LP IN GROUP A, PAIR FACTOR =-1.0D0)
C
        DO IP = 1, MORBJ
        IPX = IP + NOBADDJ
        I2IP= (I-1)*MORBJ + IP
        IJG = IJ00(IPX,JG)
        KLG = IJ00(KG,LG)
        IKG = IJ00(IPX,KG)
        JLG = IJ00(JG,LG)
        IJKLG=IJ00(IJG,KLG)
        IKJLG=IJ00(IKG,JLG)
        DERV(I2IP) = DERV(I2IP) + D1AB*(G(IJKLG)-0.5D0*G(IKJLG))
        END DO
        DO JP = 1, MORBJ
        JPX = JP + NOBADDJ
        J2JP= (J-1)*MORBJ + JP
        IJG = IJ00(IG,JPX)
        KLG = IJ00(KG,LG)
        IKG = IJ00(IG,KG)
        JLG = IJ00(JPX,LG)
        IJKLG=IJ00(IJG,KLG)
        IKJLG=IJ00(IKG,JLG)
        DERV(J2JP) = DERV(J2JP) + D1AB*(G(IJKLG)-0.5D0*G(IKJLG))
        END DO
        DO KP = 1, MORBI
        KPX = KP + NOBADDI
        K2KP= (KP-1)*MORBJ + K
        IJG = IJ00(IG,JG)
        KLG = IJ00(KPX,LG)
        IKG = IJ00(IG,KPX)
        JLG = IJ00(JG,LG)
        IJKLG=IJ00(IJG,KLG)
        IKJLG=IJ00(IKG,JLG)
        DERV(K2KP) = DERV(K2KP) - D1AB*(G(IJKLG)-0.5D0*G(IKJLG))
        END DO
        DO LP = 1, MORBI
        LPX = LP + NOBADDI
        L2LP= (LP-1)*MORBJ + L
        IJG = IJ00(IG,JG)
        KLG = IJ00(KG,LPX)
        IKG = IJ00(IG,KG)
        JLG = IJ00(JG,LPX)
        IJKLG=IJ00(IJG,KLG)
        IKJLG=IJ00(IKG,JLG)
        DERV(L2LP) = DERV(L2LP) - D1AB*(G(IJKLG)-0.5D0*G(IKJLG))
        END DO
      END DO
      END DO
      END DO
      END DO
C
C     PRINT DERV
C
C     WRITE(IOUTVB,*)'DERV FROM MIXGIJ'
C     DO I=1, MORBI*MORBJ
C     WRITE(IOUTVB,'(I4,F10.7)')I,DERV(I)
C     END DO
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     FUNCTION: COMPUTE HESSIAN OF RIGID ROTATION BETWEEN GROUP I AND J
C
C     NOTES:
C             W(MMS): SCRATCH
C             W(MMH): CORE H
C             W(MMG): 2E IN ORTHOGONAL BASIS FUNCTIONS
C             FKN:    FOCK MATRICES
C             IOPTION: 1 (FULL HESSIAN FOR GROUP I,J), 0 (BLOCK DIAGONAL)
C
C     HISTORY:
C
C             First version: June 30, 2004
C
C     AUTHOR:
C             Jiabo Li
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE MIXHFK(NBASIS,MORBI,MORBJ,MTDI,MTDJ,NOBADDI,NOBADDJ,
     &           HEFF,D1A,D1B,D2A,D2B,G,IOPTION,FKN,FKMO,DERV,HESS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION HEFF(*),D1A(*),D1B(*),D2A(*),D2B(*),G(*),DERV(*),HESS(*)
      DIMENSION FKN(*),FKMO(*),HESSX(10000)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     LOGICAL BLKHESS
C     BLKHESS = .FALSE.
C
C     CHECK BOUNDARY
C
      IF(MORBJ.GT.100) CALL ABORT0('MIXHFK0001')
C     IF(IOPTION.EQ.0) BLKHESS=.TRUE.
      DO I=1, MORBI*MORBJ
      DERV(I) = 0.0D0
      END DO
      NDH1 = MORBI*MORBJ
      NDH2 = NDH1*(NDH1+1)/2
      DO I=1, NDH2
      HESS(I) = 0.0D0
      END DO
      NBA2 = NBASIS*(NBASIS+1)/2
C
C     HEFF OF GROUP J
C
      DO I=1, NBA2
      HEFF(I) = HEFF(I) + FKN(I)
      END DO
C
C     CHECK FKN AND FKMO
C
      DO I=1, NBA2
      AAA = 0.0D0
        DO J=1, MORBI
        JJ = (J-1)*NBA2
        AAA = AAA + FKMO(I+JJ)
        END DO
      CDIFF = ABS(AAA-FKN(I))
      IF(CDIFF.GT.1.0D-7) WRITE(IOUTVB,*)'CDIFF =',CDIFF
      END DO

C
C     COMPUTE HESSIAN OF MO-I AND GROUP J
C
      DO I=1, MORBI
      IH = (I-1)*MORBJ
      IH1= IH+1
C
C     HEFF OF MO-I
C
      II = (I-1)*NBA2
        DO J=1, NBA2
        HEFF(J) = HEFF(J) - FKMO(II+J)
        END DO
C
C     CALL MIXGIJ
C
      MORBIX = 1
      MTDIX  = MTDI
      NOBADDIX = NOBADDI + I - 1
      CALL MIXGIJ(MORBIX,MORBJ,MTDIX,MTDJ,NOBADDIX,NOBADDJ,HEFF,
     &            D1A,D1B,D2A,D2B,G,IOPTION,DERV(IH1),HESSX)
C
C     SET BACK HEFF
C
        DO J=1, NBA2
        HEFF(J) = HEFF(J) + FKMO(II+J)
        END DO
C
C     MAP BACK HESSIAN
C
      DO K=1, MORBJ
      DO L=1, K
      KL = IJ00(K,L)
      KLH = IJ00(K+IH,L+IH)
      HESS(KLH) = HESSX(KL)
      END DO
      END DO
C
C     LOOP OF ORBITAL I
C
      END DO
      RETURN
      END
      SUBROUTINE MIXVIR(MORBI,MORBJ,MTDI,NOBADDI,NOBADDJ,HEFF,
     &                  D1A,D2A,G,IOPTION,DERV,HESS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     COMMON /IBB/IB(100000),MWINZ,MBORZ
      COMMON /IDD/ID(100000)
      DIMENSION HEFF(*),D1A(*),D2A(*),G(*),DERV(*),HESS(*)
      DIMENSION IJKL4(4),IFLAG(4)
      LOGICAL BLKHESS,COMPHESS
      BLKHESS = .FALSE.
      IF(IOPTION.EQ.0) BLKHESS=.TRUE.
      DO I=1, MORBI*MORBJ
      DERV(I) = 0.0D0
      END DO
      NDH1 = MORBI*MORBJ
      NDH2 = NDH1*(NDH1+1)/2
      DO I=1, NDH2
      HESS(I) = 0.0D0
      END DO
C
C     ENERGY OF GROUP I IN THE HEFF
C
C     ETEMP = 0.0D0
      IJ = 0
      DO I=1,MORBI
      DO J=1, I
      IG = I + NOBADDI
      JG = J + NOBADDI
      IJ = IJ + 1
      IJG=IJ00(IG,JG)
      FAC = 1.0D0
      IF(I.NE.J) FAC = 2.0D0
      D1AIJ = D1A(IJ)*FAC
C     ETEMP = ETEMP + FAC*D1A(IJ)*HEFF(IJG)
C
C       I-> IP (IP in GROUP B)
C       J-> IP
C
        DO IP=1, MORBJ
        I2IP = (I-1)*MORBJ + IP
        IX1  = IP
        IPX  = NOBADDJ+ IP
        IJX = IJ00(IPX,JG)
        DERV(I2IP) = DERV(I2IP) + D1AIJ*HEFF(IJX)
C       GOTO 991
C
C       HESS
C          IP -> IPP (IPP in GROUP A)
C          J  -> JP  (JP in GROUP B)
           DO IPP = 1, MORBI
           IP2I  = (IPP-1)*MORBJ + IP
           IX2   = IP
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(IP2I.GE.I2IP.AND.COMPHESS) THEN
           IPPX  = NOBADDI + IPP
           IJHES = IJ00(I2IP,IP2I)
           IJXX  = IJ00(IPPX,JG)
           HESS(IJHES) = HESS(IJHES) - D1AIJ*HEFF(IJXX)
           END IF
           END DO
           DO JP = 1, MORBJ
           J2JP  = (J-1)*MORBJ + JP
           IX2   = JP
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(J2JP.GE.I2IP.AND.COMPHESS) THEN
           JPX   = NOBADDJ + JP
           IJXX  = IJ00(IPX,JPX)
           IJHES = IJ00(I2IP,J2JP)
           HESS(IJHES) = HESS(IJHES) + D1AIJ*HEFF(IJXX)
           END IF
           END DO
C991       CONTINUE
        END DO
        DO JP=1, MORBJ
        J2JP = (J-1)*MORBJ + JP
        IX1  = JP
        JPX  = NOBADDJ+ JP
        IJX  = IJ00(IG,JPX)
        DERV(J2JP) = DERV(J2JP) + D1AIJ*HEFF(IJX)
C       GOTO 992
C
C       HESS
C          I  -> IP
C          JP -> JPP
           DO IP = 1, MORBJ
           I2IP = (I-1)*MORBJ + IP
           IX2   = IP
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(I2IP.GE.J2JP.AND.COMPHESS) THEN
           IPX  = NOBADDJ + IP
           IJXX = IJ00(IPX,JPX)
           IJHES= IJ00(I2IP,J2JP)
           HESS(IJHES) = HESS(IJHES) + D1AIJ*HEFF(IJXX)
           END IF
           END DO
           DO JPP=1, MORBI
           JP2J = (JPP-1)*MORBJ + JP
           IX2   = JP
           COMPHESS = .TRUE.
           IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
           IF(JP2J.GE.J2JP.AND.COMPHESS) THEN
           JPPX = NOBADDI + JPP
           IJHES= IJ00(J2JP,JP2J)
           IJXX = IJ00(IG,JPPX)
           HESS(IJHES) = HESS(IJHES) - D1AIJ*HEFF(IJXX)
           END IF
           END DO
C992       CONTINUE
        END DO
      END DO
      END DO
      IFLAG(1) = 1
      IFLAG(2) = 1
      IFLAG(3) = 1
      IFLAG(4) = 1
C
C     IF GROUP I IS NOT A HF GROUP
C
      IF(MTDI.NE.1) THEN
      DO I=1,MORBI
      II = I*(I-1)/2
      IG = I+NOBADDI
      IIG= IG*(IG-1)/2
      DO J=1,I
      IJ = II+J
      JG = J+NOBADDI
      IJG= IIG + JG
        DO K=1,I
        LL  = K
        KK  = K*(K-1)/2
        KG  = K+NOBADDI
        KKG = KG*(KG-1)/2
        IF(K.EQ.I) LL=J
        DO L=1,LL
        LG = L+NOBADDI
        KL = KK+L
        KLG= KKG + LG
        IJKLG= IJ00(IJG,KLG)
        IJKL = IJ00(IJ,KL)
        D2AIJKL = D2A(IJKL)
C       ETEMP=ETEMP+D2A(IJKL)*G(IJKLG)
        IJKL4(1) = I
        IJKL4(2) = J
        IJKL4(3) = K
        IJKL4(4) = L
        CALL HESSVIR(MORBI,MORBJ,NOBADDI,NOBADDJ,D2AIJKL,IJKL4,
     &               IFLAG,IOPTION,HESS,G)
C
C       I-> IP
C       J-> JP
C       K-> KP
C       L-> LP
C       (IP,JP,KP AND LP in GROUP B, PAIR FACTOR=1.0
C
           KLG = IJ00(KG,LG)
           DO IP=1, MORBJ
           IPX = IP + NOBADDJ
           I2IP= (I-1)*MORBJ + IP
           IJG = IJ01(IPX,JG)
           IJKLG = ID(IJG)+KLG
           DERV(I2IP) = DERV(I2IP) + D2A(IJKL)*G(IJKLG)
           END DO
           DO JP=1, MORBJ
           JPX = JP + NOBADDJ
           J2JP= (J-1)*MORBJ + JP
           IJG = IJ01(IG,JPX)
           IJKLG = ID(IJG)+KLG
           DERV(J2JP) = DERV(J2JP) + D2A(IJKL)*G(IJKLG)
           END DO
           IJG = IJ00(IG,JG)
           DO KP=1, MORBJ
           KPX = KP + NOBADDJ
           K2KP= (K-1)*MORBJ + KP
           KLG = IJ01(KPX,LG)
           IJKLG = ID(KLG)+IJG
           DERV(K2KP) = DERV(K2KP) + D2A(IJKL)*G(IJKLG)
           END DO
           DO LP=1, MORBJ
           LPX = LP + NOBADDJ
           L2LP= (L-1)*MORBJ + LP
           KLG = IJ01(KG,LPX)
           IJKLG = ID(KLG)+IJG
           DERV(L2LP) = DERV(L2LP) + D2A(IJKL)*G(IJKLG)
           END DO
        END DO
        END DO
      END DO
      END DO
      ELSE
      CALL ABORT0('MIXVIR0001')
      END IF
C
C     PRINT DERV
C
C     WRITE(IOUTVB,*)'DERV FROM MIXVIR'
C     DO I=1, MORBI*MORBJ
C     WRITE(IOUTVB,'(I4,F10.7)')I,DERV(I)
C     END DO
      RETURN
      END
      SUBROUTINE HESSGAB(MORBI,MORBJ,NOBADDI,NOBADDJ,D2AIJKL,
     &                   IJKL1,IFLAG1,IOPTION,HESS,G)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IJKL1(4),IJKL2(4),IJKL3(4),IFLAG1(4),IFLAG2(4),IFLAG3(4)
      DIMENSION HESS(*),G(*),IJKL4(4)
      LOGICAL BLKHESS,COMPHESS
      BLKHESS = .FALSE.
      IF(IOPTION.EQ.0) BLKHESS = .TRUE.
      DO JA=1,4
        DO IX=1, 4
        IFLAG2(IX) =  IFLAG1(IX)
        IJKL2(IX)  =  IJKL1(IX)
        END DO
        IFLAG2(JA) = -IFLAG1(JA)
        IF(IFLAG1(JA).EQ.1) THEN
        FAC1  = 1.0D0
        MORBX = MORBJ
        ELSE
        MORBX = MORBI
        FAC1  = -1.0D0
        END IF
      DO IP=1, MORBX
        IF(IFLAG1(JA).EQ.1) THEN
        JH1 = (IJKL1(JA)-1)*MORBJ + IP
        IX1 = IJKL1(JA)
        ELSE
        JH1 = (IP-1)*MORBJ + IJKL1(JA)
        IX1 = IP
        END IF
        IJKL2(JA) = IP
        DO JB=1,4
          DO IX=1, 4
          IJKL3(IX)  = IJKL2(IX)
          IFLAG3(IX) = IFLAG2(IX)
          END DO
          IFLAG3(JB) = -IFLAG2(JB)
          IF(IFLAG2(JB).EQ.1) THEN
          MORBY = MORBJ
          FAC2  = 1.0D0
          ELSE
          MORBY = MORBI
          FAC2  =-1.0D0
          END IF
        DO JP=1, MORBY
          IF(IFLAG2(JB).EQ.1) THEN
          JH2 = (IJKL2(JB)-1)*MORBJ + JP
          IX2 = IJKL2(JB)
          ELSE
          JH2 = (JP-1)*MORBJ + IJKL2(JB)
          IX2 = JP
          END IF
          COMPHESS = .TRUE.
          IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS = .FALSE.
          IF(JH2.GE.JH1.AND.COMPHESS) THEN
          IJKL3(JB) = JP
          DO IX=1,4
            IF(IFLAG3(IX).EQ.1) THEN
              IJKL4(IX) = IJKL3(IX) + NOBADDI
            ELSE
              IJKL4(IX) = IJKL3(IX) + NOBADDJ
            END IF
          END DO
          IJG = IJ00(IJKL4(1),IJKL4(2))
          KLG = IJ00(IJKL4(3),IJKL4(4))
          IJKLG = IJ00(IJG,KLG)
          JH12  = IJ00(JH1,JH2)
          HESS(JH12) = HESS(JH12) + D2AIJKL*FAC1*FAC2*G(IJKLG)
C         CONTRI =  D2AIJKL*FAC1*FAC2*G(IJKLG)
            IF(IFLAG1(2).NE.IFLAG1(3)) THEN
            IKG = IJ00(IJKL4(1),IJKL4(4))
            JLG = IJ00(IJKL4(2),IJKL4(3))
            IKJLG = IJ00(IKG,JLG)
            HESS(JH12) = HESS(JH12) - 0.5D0*D2AIJKL*FAC1*FAC2*G(IKJLG)
C           CONTRI = CONTRI - 0.5D0*D2AIJKL*FAC1*FAC2*G(IKJLG)
            END IF
          END IF
        END DO
        END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE HESSVIR(MORBI,MORBJ,NOBADDI,NOBADDJ,D2AIJKL,
     &                   IJKL1,IFLAG1,IOPTION,HESS,G)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     COMMON /IBB/IB(100000),MWINZ,MBORZ
      COMMON /IDD/ID(100000)
      DIMENSION IJKL1(4),IJKL2(4),IJKL3(4),IFLAG1(4),IFLAG2(4),IFLAG3(4)
      DIMENSION HESS(*),G(*),IJKL4(4)
      LOGICAL BLKHESS,COMPHESS
      BLKHESS = .FALSE.
      IF(IOPTION.EQ.0) BLKHESS = .TRUE.
      DO JA=1,4
        DO IX=1, 4
        IFLAG2(IX) =  IFLAG1(IX)
        IJKL2(IX)  =  IJKL1(IX)
        END DO
        IFLAG2(JA) = -IFLAG1(JA)
        FAC1  = 1.0D0
        MORBX = MORBJ
      DO IP=1, MORBX
        JH1 = (IJKL1(JA)-1)*MORBJ + IP
        IX1 = IP
        IJKL2(JA) = IP
        DO JB=1,4
          DO IX=1, 4
          IJKL3(IX)  = IJKL2(IX)
          IFLAG3(IX) = IFLAG2(IX)
          END DO
          IFLAG3(JB) = -IFLAG2(JB)
          IF(IFLAG2(JB).EQ.1) THEN
          MORBY = MORBJ
          FAC2  = 1.0D0
          ELSE
          MORBY = MORBI
          FAC2  =-1.0D0
          END IF
        DO JP=1, MORBY
          IF(IFLAG2(JB).EQ.1) THEN
          JH2 = (IJKL2(JB)-1)*MORBJ + JP
          IX2 = JP
          ELSE
          JH2 = (JP-1)*MORBJ + IJKL2(JB)
          IX2 = IJKL2(JB)
          END IF
          COMPHESS = .TRUE.
          IF(BLKHESS.AND.IX1.NE.IX2) COMPHESS=.FALSE.
          IF(JH2.GE.JH1.AND.COMPHESS) THEN
          IJKL3(JB) = JP
          DO IX=1,4
            IF(IFLAG3(IX).EQ.1) THEN
              IJKL4(IX) = IJKL3(IX) + NOBADDI
            ELSE
              IJKL4(IX) = IJKL3(IX) + NOBADDJ
            END IF
          END DO
          IJG = IJ01(IJKL4(1),IJKL4(2))
          KLG = IJ01(IJKL4(3),IJKL4(4))
            IF(IJG.GE.KLG) THEN
            IJKLG = ID(IJG)+KLG
            ELSE
            IJKLG = ID(KLG)+IJG
            END IF
          JH12  = IJ00(JH1,JH2)
          HESS(JH12) = HESS(JH12) + D2AIJKL*FAC1*FAC2*G(IJKLG)
          END IF
        END DO
        END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE DVDCON(MITER,BASIS,WBASIS,DM1NON,DM2NON,GDMP,WRK1,
     & W,MSIZE,ENR,ETOTAL,LASTITER)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C               Top level group function method. This is a divide-and-conquer
C               approach to correlation problem of many electron systems.
C     Note:
C               Loop over all subunits.
C
C     GDMP:     Density of the whole system except the current subunit.
C     DM1NON:   1D density of subsystems in their LOCAL NONORTHOGONAL basis.
C     DM2NON:   2D density of subsystems in their LOCAL NONORTHOGONAL basis.
C
C     History:
C               First created in Feb. 1999.
C               Recoded in September, 1999.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*8 BONDLAB
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      PARAMETER (ND1WRK=20000)
      PARAMETER (MAXCEN=200,MAXBFN=726)
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
      PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA,MAXGRP=99)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(MAXGRP),MSPIN(MAXGRP),MNORBIT(MAXGRP),
     &MLORBIT(MAXGRP),MWIN(MAXGRP),MSTR(MAXGRP),METHOD(MAXGRP),
     &IBASIS(MAXEXT),NOCC(MAXEXT),NOBIAS,NEPS,NVIR,NOTROT(5000),
     &LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(MAXGRP)
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
      PARAMETER (MAXNAB=MAXCEN*MAXBFN/2,MAXBF2=MAXBFN*MAXBFN)
      COMMON /LMODAT/VMO(MAXBF2),VLMO(MAXBF2),LMOLAB(2,MAXBFN),
     &LMOATM(5,MAXBFN),PGM(MAXNAB),ENGLMO(MAXBFN),BONDLAB(MAXBFN),
     &MCLMO(5,80),LHFLAG
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /CSTRUC/CSTRUC(5000),ISTRUC(100)
      DIMENSION BASIS(*),WBASIS(*),CNORM(1000),DM1NON(*),DM2NON(*)
      DIMENSION WRK1(*),GDMP(*),MINDEX(9999),W(*),D1WRK(ND1WRK)
      ETOTAL=ENR
      ISTRUC(1)=0
      CNORM(1) =0
      NBA2=NBASIS*(NBASIS+1)/2
C     NDMP=NBA2*NSUB
C     NSSS=1
C     NWK=NSSS+NBASIS*(NBASIS+1)/2
      NOBADD1=1+MLORBIT(1)*NBASIS
C
C     ZERO GDMP !
C
      DO I=1,NBA2
      GDMP(I)=0.0D0
      END DO
C
C     ACCUMULATE GDMP
C
      IFLAG=1
      DO 100 K=2,NSUB
      NODADD1=ND1STA-1+N1DADD(K)
      CALL MATRAN2(MLORBIT(K),NBASIS,BASIS(NOBADD1),WRK1,
     &       DM1NON(N1DADD(K)),GDMP,IFLAG)
      NOBADD1=NOBADD1+MLORBIT(K)*NBASIS
 100  CONTINUE
      NODADD1=1
      NOBADD1=1
      IFLAG  =1
      NBO=0
      ISTRUC(1)=1
      DO 200 I=1,NSUB
      MGRP=I
      NBO=NBO+MLORBIT(I)
C     IDMGRP=(I-1)*NBA2
C     NDMGRP=I*NBA2
      ISTRUC(I+1)=ISTRUC(I)
C
C     SAVE A COPY TO D1WRK
C
      IF(N1DADD(I+1)-N1DADD(I).GT.ND1WRK) THEN
          WRITE(IOUTVB,*)"NUMBER OF ORBTIALS IN GROUP ",I," > 140"
          CALL ABORT0('DVDCON01  ')
      END IF
      DO K=1,N1DADD(I+1)-N1DADD(I)
      D1WRK(K)=DM1NON(N1DADD(I)-1+K)
      END DO
C
C     CALL WINDEX TO SET UP ORBITAL WINDOW INDEX
C
      CALL WINDEX(I,MBASIS,MWIN(I),IBASIS,MINDEX)
C
C     COLLECT ORBITALS WHICH ARE OPEN TO THE SUBUNIT
C
      CALL COLBAS(NBASIS,BASIS,WBASIS,MINDEX,MWIN(I))
      IF(MELE(I).GT.0) THEN
      CALL GENSCF(METHOD(I),MELE(I),MSPIN(I),NBASIS,MLORBIT(I),
     & MWIN(I),WBASIS,GDMP,DM1NON(N1DADD(I)),
     & DM2NON(N2DADD(I)),W,MSIZE,MITER,MGRP,LPTALL,LASTITER)
C    & DM2NON(N2DADD(I)),W,MSIZE,ETOTAL,MITER,MGRP,LPTALL,LASTITER)
      ELSE
       DO KK=N1DADD(I),N1DADD(I+1)-1
          DM1NON(KK) = 0.0D0
       END DO
       DO KK=N2DADD(I),N2DADD(I+1)-1
          DM2NON(KK) = 0.0D0
       END DO
      END IF
C
C     POSSIBLE SYMMETRY CORRECTION
C
      MGRP = I
C     MAXL = 4
      CALL SYMVBO(MGRP,MLORBIT(I),WBASIS,W,ISYMOPER,CNORM)
C
C     UPDATE ORBITALS
C
      CALL MODBAS(NBASIS,BASIS,WBASIS,MINDEX,MWIN(I))
C
C     UPDATE DENSITY MATRICES
C
      IF(NOBIAS.NE.1) THEN
      CALL MATRAN2(MLORBIT(I),NBASIS,BASIS(NOBADD1),WRK1,
     &             DM1NON(N1DADD(I)),GDMP,IFLAG)
      ELSE
      CALL MATRAN2(MLORBIT(I),NBASIS,BASIS(NOBADD1),WRK1,
     &             D1WRK(1),GDMP,IFLAG)
      END IF
      NODADD1=NODADD1+MLORBIT(I)*(MLORBIT(I)+1)/2
      NOBADD1=NOBADD1+MLORBIT(I)*NBASIS
C
C     SUBSTRACT THE 1D DENSITY FOR THE NEXT SUB GROUP.
C     IF IT IS THE LAST ONE, DON'T DO THIS, AND GDMP IS THE FULL
C     1D DENSITY
C
      NFLAG=-IFLAG
      IF(I.LT.NSUB) THEN
      CALL MATRAN2(MLORBIT(I+1),NBASIS,BASIS(NOBADD1),WRK1,
     &             DM1NON(N1DADD(I+1)),GDMP,NFLAG)
      END IF
  200 CONTINUE
C
C     SAVE BASIS AND GDM
C
C400  CONTINUE
      NDM1 = ND2STA-ND1STA
      CALL GETIOUNIT('IOVBORB ',IOVBORB)
      REWIND(IOVBORB)
      WRITE(IOVBORB)NSUB,NDM1,(MELE(I),I=1,NSUB),
     &              (MLORBIT(I),I=1,NSUB),(METHOD(I),I=1,NSUB)
C
C     Compute NORBX
C
      NORBX = 0
      DO I=1, NSUB
         NORBX = NORBX + MLORBIT(I)
      ENDDO
      IF(NORBX.LT.NBASIS) NORBX = NBASIS
      WRITE(IOVBORB)NBASIS,NATOM,NORBX,(BFLABE(I),I=1,NBASIS)
      WRITE(IOVBORB)(BASIS(I),I=1,NBASIS*NORBX)
      WRITE(IOVBORB)(DM1NON(I),I=1,NDM1)
      IF(LHFLAG.GE.1) WRITE(IOVBORB)((LMOATM(I,J),I=1,5),J=1,NORBX)
      RETURN
C1000 FORMAT(/' ORBITALS IN AO BASIS: # OF ORBITAL(GROUP)'/)
C1100 FORMAT(/1X,8(I5,'(',I2,')'))
C1200 FORMAT(1X,8F9.6)
C1300 FORMAT(/' MACRO-ITERATION ENERGY',I5,F20.14/)
C1400 FORMAT(/
C    &/' ==========================================================='
C    &       /' SUBUNIT:',I2,',METHOD:',I2,',NUMBER OF ORBITALS:',I3,
C    &        ',WINDOW-SIZE:',I3
C    &/' ==========================================================='/)
      END
C
C     THE NEW ORBITAL COEFFICIENTS IN LOCAL BASIS FUNCTIONS
C     BASIS.ORBLOC = WBASIS
C
C     X(T)X V' = X(T)V
C     BASIS(T)BASIS.ORBLOC = BASIS(T).WBASIS
C
      SUBROUTINE LSFIT(NBASIS,NORB,BASIS,WBASIS,ORBLOC,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION BASIS(NBASIS,*),WBASIS(NBASIS,*),ORBLOC(NORB,NORB)
      DIMENSION W(*)
C     DO I=1, NORB
C        WRITE(IOUTVB,'(I3,4F12.8)')I,(ORBLOC(I,J),J=1,NORB)
C     ENDDO
      MXX = 1
      MXV = MXX + NORB*NORB
      MVP = MXV + NORB*NORB
      MXT = MVP + NORB*NORB
      DO I=1, NORB
      II = (I-1)*NORB
      DO J=1, NORB
         SUX = 0.0D0
         SUM = 0.0D0
         DO K=1, NBASIS
           SUM = SUM + BASIS(K,J)*BASIS(K,I)
           SUX = SUX + BASIS(K,J)*WBASIS(K,I)
         ENDDO
         W(MXX-1+II+J) = SUM
         W(MXV-1+II+J) = SUX
      ENDDO
      ENDDO
C
C     SOLVE LINEAR EQ
C     W(MXX).W(MVP) = W(MXV)
C
      CALL SOLVER(NORB,W(MXX),W(MVP),W(MXV),W(MXT),NORB)
      DO I=1, NORB
      DO J=1, NORB
        ORBLOC(I,J) = W(MVP-1+I+(J-1)*NORB)
      ENDDO
      ENDDO
C     DO I=1, NORB
C        WRITE(IOUTVB,'(I3,4F12.8)')I,(ORBLOC(I,J),J=1,NORB)
C     ENDDO
      RETURN
      END
C
C     THE NEW ORBITALS MUST IN THE ORIGINAL SPACE
C
C     MIRROR(I) = 0, NON-MIRROR OPERATION
C                 1, MIRROR OPERATION
C                 2, X-MIRROR OPERATION
C                 3, Y-MIRROR OPERATION
C                 4, Z-MIRROR OPERATION
C
      SUBROUTINE SYMVBO(MGRP,NORB,BASIS,W,ISYMOPER,CNORM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 FLAG
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      PARAMETER (MAXCEN=200,MAXBFN=726)
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
      DIMENSION BASIS(*),W(*),VT(1000),IOPERJ(4,100)
CLIC  DIMENSION MOPER(10000),MIRROR(1000)
      DIMENSION VTP(1000),CNORM(*)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      ISYMOPER = 0
      FLAG     = '$'
      WRITE(FLAG(2:3),'(I2.2)') MGRP
      FLAG(4:9)='SYMORB'
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,FLAG,9,IOK,0)
      IF(IOK.EQ.0) RETURN
      ISYMOPER = 1
      READ(IOENGI,*)NOPER
      IF(NATOM*NOPER.GT.10000) CALL ABORT0("SYMORB0001")
C
C     READ SYM OPERATION DEFINITION
C
CLIC  DO I=1, NOPER
CLIC  II = (I-1)*NATOM
CLIC  READ(IOENGI,*)MIRROR(I),(MOPER(II+J),J=1,NATOM)
CLIC  ENDDO
C
C     READ SYM OPERATIONS ON ORBITALS
C
C     FORMAT: IB, IO, JB
C             ORBITAL IB TRANSFORMED TO ORBITAL JB UNDER OPERATION IO
C
      READ(IOENGI,*)NSYM
      DO I=1, NSYM
       READ(IOENGI,*)(IOPERJ(J,I),J=1,3)
      ENDDO
      CALL GETIOUNIT('IAO1E   ',IAO1E)
C
      NB2     = NBASIS*NBASIS
      MSS = 1
      MHH = MSS + NB2
      MS0 = MSS + NB2
      MVV = MS0 + NBASIS*NBASIS
      MV1 = MVV + NBASIS*NBASIS
CLIC  MV2 = MV1 + NBASIS*NBASIS
      CALL READ1E(IAO1E,W(MSS),W(MHH),NBASIS)
      DO I=1, NBASIS
      II = (I-1)*NBASIS
      DO J=1, NBASIS
      W(MS0-1+II+J) = W(MSS-1+IJ00(I,J))
      ENDDO
      ENDDO
      CALL SHMIDT2(NBASIS,NORB,BASIS,W(MS0),NB,W(MVV))
      DO I=1, NSYM
CLIC    IBAS = (I-1)*NBASIS+1
CLIC    IA = (I-1)*NATOM+1
        IB = (IOPERJ(1,I)-1)*NBASIS+1
CLIC    IO = (IOPERJ(2,I)-1)*NATOM+1
        JB = (IOPERJ(3,I)-1)*NBASIS+1
        CNORM(IOPERJ(3,I)) = CNORM(IOPERJ(1,I))
CLIC    CALL SYMOPER(MIRROR(I),MOPER(IO),BASIS(IB),VT,MAXL)
C
C       PROJECT TO MVV SPACE
C
        IPROJ = 0
        IF(IPROJ.EQ.1) THEN
         CALL PROJEC(NBASIS,1,NB,W(MS0),VT,W(MVV),VTP,W(MV1))
        ELSE
         DO J=1,NBASIS
           VTP(J) = VT(J)
         ENDDO
        ENDIF
        IF(IB.EQ.JB) THEN
         WRITE(IOUTVB,*)"Before AVE"
         DO J=1,NBASIS
           WRITE(IOUTVB,'(2F20.10)')BASIS(JB-1+J),VTP(J)
         ENDDO
         CALL AVEORB(NBASIS,BASIS(JB),VTP)
         WRITE(IOUTVB,*)"After AVE"
         DO J=1,NBASIS
           WRITE(IOUTVB,'(2F20.10)')BASIS(JB-1+J),VTP(J)
         ENDDO
        ELSE
         DO J=1,NBASIS
C         WRITE(IOUTVB,'(I5,A10,F12.8)')J,BFLABE(J),VTP(J)
C         WRITE(IOUTVB,'(I5,A10,F12.8)')J,BFLABE(J),BASIS(JB-1+J)
          BASIS(JB-1+J) = VTP(J)
         END DO
        END IF
      ENDDO
C  GMS  JUNKGMS = IA+IBAS+IO+MIRROR(1)+MOPER(1)+MV2
C  GMS  IF (MGRP.GT.10000) WRITE(IOUTVB,*)"PRINT STUPID THINGS: ",JUNKGMS
      RETURN
      END
      SUBROUTINE AVEORB(NBASIS,BASIS,VTP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION BASIS(*),VTP(*)
C
C     TAKE AVERAGE OF BASIS AND VTP
C
      PROD = 0.0D0
      DO I=1, NBASIS
      PROD = PROD + BASIS(I)*VTP(I)
      END DO
      IF(PROD .GT. 0) THEN
        DO I=1, NBASIS
        BASIS(I) = (BASIS(I)+VTP(I))*0.5D0
        END DO
      ELSE
        DO I=1, NBASIS
        BASIS(I) = (BASIS(I)-VTP(I))*0.5D0
        END DO
      END IF
      RETURN
      END
      SUBROUTINE ROTRAN(RWRK,G,MSIZE,ETOTAL,MITER)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Top level of rigid rotation algorithm.
C     Notes:
C               G: global work field(the first portion will hold hessain).
C               MSIZE: size of the work field.
C               IRDEX(3,*): rotation parameter indexes.
C
C               Minimal scratch space: NDH2 + MAX(MSCR1,MSCR3) of HESSTE
C
C
C     History:
C               First created in Feb. 1999.
C               Recoded in September, 1999.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MAPSIZE=10000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
C     DIMENSION CNORM(1000),RWRK(*),G(*)
      DIMENSION RWRK(*),G(*)
      CHARACTER*8 BONDLAB
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      PARAMETER (MAXCEN=200,MAXBFN=726)
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
      PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA,MAXGRP=99)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(MAXGRP),MSPIN(MAXGRP),MNORBIT(MAXGRP),
     &MLORBIT(MAXGRP),MWIN(MAXGRP),MSTR(MAXGRP),METHOD(MAXGRP),
     &IBASIS(MAXEXT),NOCC(MAXEXT),NOBIAS,NEPS,NVIR,NOTROT(5000),
     &LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(MAXGRP)
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      PARAMETER (MAXNAB=MAXCEN*MAXBFN/2,MAXBF2=MAXBFN*MAXBFN)
      COMMON /LMODAT/VMO(MAXBF2),VLMO(MAXBF2),LMOLAB(2,MAXBFN),
     &LMOATM(5,MAXBFN),PGM(MAXNAB),ENGLMO(MAXBFN),BONDLAB(MAXBFN),
     &MCLMO(5,80),LHFLAG
      DIMENSION NHDADD(5000),IDIMGRP(5000),NHESADD(5000)
      DIMENSION RVEC(MAPSIZE),RDEV(MAPSIZE),IRDEX(3,MAPSIZE)
      DIMENSION DDEV(MAPSIZE)
      DIMENSION NORBADD(100)
      LOGICAL DIAGHESS
C     TIME1 = XCLOCK()
C
C     SET UP INDEXES
C
      NORBADD(1)= 0
      NHESADD(1)= 0
      NHDADD(1) = 0
      NHFORB = 0
      DO 20 I=1,NSUB
      IF(METHOD(I).EQ.1) NHFORB = NHFORB + MLORBIT(I)
 20   NORBADD(I+1)= NORBADD(I)+MNORBIT(I)
C
C     NHGRP: INDEX OF HESSIAN GROUP
C     NHDIM: DIMENSION OF HESSIAN MATRIX
C
C     TODO: REMOVE MAPBRI
C
      NHGRP=0
      NHDIM=0
      DO 3 I=1,NSUB-1
      DO 3 J=I+1,NSUB
      IF (NOTROT((J-1)*(J-2)/2+I).EQ.0) THEN
      NDIMGRP=MNORBIT(I)*MNORBIT(J)
      NHGRP=NHGRP+1
      NHESADD(NHGRP+1)=NHESADD(NHGRP)+NDIMGRP*(NDIMGRP+1)/2
      NHDADD(NHGRP+1) =NHDADD(NHGRP)+NDIMGRP
      IDIMGRP(NHGRP)=NDIMGRP
         DO 4 K=1,MNORBIT(I)
         DO 4 L=1,MNORBIT(J)
         NHDIM=NHDIM+1
C
C        CHECK BOUNDARY
C
         IF(NHDIM.GT.MAPSIZE) THEN
           WRITE(IOUTVB,*)
     &      "HESSIAN MATRIX FOR RIGID ROTATION IS TOO LARGE"
           CALL ABORT0('ROTRAN01  ')
         END IF
         IRDEX(1,NHDIM)=NORBADD(I)+K
         IRDEX(2,NHDIM)=NORBADD(J)+L
         IRDEX(3,NHDIM)=NHGRP
 4    CONTINUE
      END IF
 3    CONTINUE
      NOCB=NORBADD(NSUB+1)
C
C     VIRTUAL ORBITALS
C
C     NVIRX=NBASIS-NOCB
      DO 5 I=1,NSUB
      IF (NOTROT(NSUB*(NSUB-1)/2+I).EQ.0) THEN
      NDIMGRP=MNORBIT(I)*NVIR
      NHGRP=NHGRP+1
      NHESADD(NHGRP+1)=NHESADD(NHGRP)+NDIMGRP*(NDIMGRP+1)/2
      NHDADD(NHGRP+1) =NHDADD(NHGRP)+NDIMGRP
      IDIMGRP(NHGRP)=NDIMGRP
         DO 6 K=1,MNORBIT(I)
         DO 6 L=1,NVIR
         NHDIM=NHDIM+1
C
C        CHECK BOUNDARY
C
         IF(NHDIM.GT.MAPSIZE) THEN
           WRITE(IOUTVB,*)
     &      "HESSIAN MATRIX FOR RIGID ROTATION IS TOO LARGE"
           CALL ABORT0('ROTRAN02  ')
         END IF
         IRDEX(1,NHDIM)=NORBADD(I)+K
         IRDEX(2,NHDIM)=NOCB+L
         IRDEX(3,NHDIM)=NHGRP
  6   CONTINUE
      END IF
  5   CONTINUE
C
C     SETUP ADDRESSES AND CONTROLS
C
      IFIX = 1
      NSSS = 1
      NDH2 = NHESADD(NHGRP+1)
      NWK1 = NSSS+NBASIS*(NBASIS+1)/2
      NSTART = 1
      NHESS  = NSTART
      NHESS2 = NHESS  + NDH2
      NFORKS = NHESS2 + NDH2
      NWRK   = NFORKS + (NSUB+1+NHFORB)*NBASIS*(NBASIS+1)/2
      NWK2   = NFORKS
      LDNSS = NWK2
      LDNHH = LDNSS + NBASIS*(NBASIS+1)/2
      MSIZEA=MSIZE-NBASIS*(NBASIS+1)
      MSIZEB=MSIZE-NWRK
      MSIZEC=MSIZE-NWK1
      IF(MSIZEA.LE.0.OR.MSIZEB.LE.0) CALL ABORT0('ROTRAN03  ')
C
C     DIAGONAL HESS ONLY
C
      DIAGHESS = .FALSE.
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$DIAGHESS',9,IOK,0)
      IF(IOK.EQ.1) DIAGHESS = .TRUE.
C
C     CONSTRUCTE TRANSFORMATION MATRICES OF LOWDIN BASIS<---->NONORTHOGNAL BASIS
C     EACH GROUP HAS TWO TRANSFORMATION MATRICES (FOR FORWARD AND BACKWORD
C     TRANSFORMATION). THE MATRICES ARE STORED IN ALLDM, WITH ADDRESSES
C     MDADDR(NSUB+I)
C
C     LOWDIN ORTHOGONALIZATION OF SUBUNITS
C
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL READ1E(IAO1E,G(NSSS),G(NWK1),NBASIS)
C     CALL BASTRN(NBASIS,NSUB,MLORBIT,MNORBIT,RWRK(NAOBAS),G(NSSS),
C    &G(NWK1),MSIZEC,RWRK(LOCBAS),NB2ADD,RWRK(LAOBAS),RWRK(NOCBAS),
C    &NB2ADD)
      CALL BASTRN(NBASIS,NSUB,MLORBIT,MNORBIT,RWRK(NAOBAS),G(NSSS),
     &G(NWK1),MSIZEC,RWRK(LAOBAS),RWRK(NOCBAS),NB2ADD)
      CALL DMTRAN(NSUB,MLORBIT,MNORBIT,MELE,METHOD,RWRK(ND1STA),
     & RWRK(ND2STA),RWRK(LD1STA),RWRK(LD2STA),RWRK(NOCBAS),G(NSTART),
     & MSIZE,N1DADD,N1DADD,NB2ADD,N2DADD,N2DADD)
C     TIME2 = XCLOCK()
      IF(NHDIM.GT.0.AND.MROT.GT.0) THEN
      DO 400 IR=1,MROT
      CALL HESSTE(NBASIS,NOCB,RDEV,G(NHESS),NDH2,RWRK,NHFORB,
     & G(NFORKS),G(NWRK),RWRK(LAOBAS),NHDIM,NORBADD,NHESADD,
     & RWRK(LD1STA),RWRK(LD2STA),MSIZEB,N1DADD,N2DADD,ENREP,ETOTAL,
     & MITER)
C     TIME3 = XCLOCK()
C     WRITE(IOUTVB,*)"HESSTE = ", TIME3-TIME2
C
C     OPTIONALLY, ADD DELOCALIZATION PENALTY
C
      CALL READ1E(IAO1E,G(LDNSS),G(LDNHH),NBASIS)
C
      DO I=1, NDH2
      G(NHESS2-1+I) = 0.0D0
      ENDDO
      DO I=1, NHDIM
      DDEV(I) = 0.0D0
      ENDDO
      CALL DPENALTY2(RWRK(NAOBAS),RWRK(LAOBAS),RWRK(NOCBAS),
     &NB2ADD,G(LDNSS),NHDIM,NHDADD,NHESADD,IRDEX,G(LDNHH),DDEV,
     &G(NHESS2),NSUB,MLORBIT,MNORBIT,NHGRP,MITER)
C     TIME4 = XCLOCK()
C
C     COMPUTE ROTATION VECTOR OF WITHOUT DELOCALIZATION PENALTY
C
C     DO I=1,NHGRP
C     ERCTL=0.10D0
C     RDAMP=0.05D0
C     EPT=0.0D0
C     CALL DIAGHER(G(NHESADD(I)+NHESS),IDIMGRP(I),RDEV(NHDADD(I)+1),
C    &SEIG,G(NWK2),IFIX,DIAGHESS)
C     CALL NRDATER(IDIMGRP(I),RDEV(NHDADD(I)+1),G(NHESADD(I)+NHESS),
C    &OVEC(NHDADD(I)+1),CMAX,ERCTL,G(NWK2),RDAMP,EPT)
C     END DO
C
      DO I=1, NDH2
      G(NHESS-1+I) = G(NHESS-1+I) + G(NHESS2-1+I)
      ENDDO
      DO I=1, NHDIM
      RDEV(I) = RDEV(I) + DDEV(I)
      ENDDO
C
C     CALL NR PROCEDURE
C
C     CMAXVEC=0.0D0
      DO I=1,NHGRP
      ERCTL=0.10D0
      RDAMP=0.05D0
      EPT=0.0D0
C
C     IMPROVE CONDITION OF HESSIAN MATRIX. THIS MAY REDUCE THE PERFORMANCE
C     IN MOST CASES, BUT THIS WILL MAKE THE ITERATION MORE STABLE
C
      CALL DIAGHER(G(NHESADD(I)+NHESS),IDIMGRP(I),RDEV(NHDADD(I)+1),
     &SEIG,G(NWK2),IFIX,DIAGHESS)
      CALL NRDATER(IDIMGRP(I),RDEV(NHDADD(I)+1),G(NHESADD(I)+NHESS),
     &RVEC(NHDADD(I)+1),CMAX,ERCTL,G(NWK2),RDAMP,EPT)
      END DO
C
C     PERFORM ROTATIONS
C
      CALL ROTLAO(NSUB,NBASIS,NHDIM,IRDEX,MLORBIT,MNORBIT,NB2ADD,
     & RWRK(NAOBAS),RVEC,RWRK(LAOBAS),RWRK(NOCBAS))
 400  CONTINUE
C410  CONTINUE
      ELSE
      CALL TENERGY(NBASIS,NSUB,MLORBIT,METHOD,RWRK(LAOBAS),RWRK,G(NWK2),
     &             G(NWRK),MSIZEB,RWRK(LD2STA),ENREP,ETOTAL)
      NHDIM = 0
      CALL DPENALTY2(RWRK(NAOBAS),RWRK(LAOBAS),RWRK(NOCBAS),
     &NB2ADD,G(LDNSS),NHDIM,NHDADD,NHESADD,IRDEX,G(LDNHH),DDEV,
     &G(NHESS2),NSUB,MLORBIT,MNORBIT,NHGRP,MITER)
C     TIME4 = XCLOCK()
      END IF
C
C     SAVE BASIS AND GDM
C     THERE ARE TWO LOCATIONS OF WRITE(IOVBORB)!!
C
      CALL GETIOUNIT('IOVBORB ',IOVBORB)
      REWIND(IOVBORB)
      NDM1 = ND2STA-ND1STA
      WRITE(IOVBORB)NSUB,NDM1,(MELE(I),I=1,NSUB),
     &              (MLORBIT(I),I=1,NSUB),(METHOD(I),I=1,NSUB)
C
C     Compute NORBX
C
      NORBX = 0
      DO I=1, NSUB
         NORBX = NORBX + MLORBIT(I)
      ENDDO
      IF(NORBX.LT.NBASIS) NORBX = NBASIS
C
      WRITE(IOVBORB)NBASIS,NATOM,NORBX,(BFLABE(I),I=1,NBASIS)
      WRITE(IOVBORB)(RWRK(NAOBAS-1+I),I=1,NBASIS*NORBX)
      WRITE(IOVBORB)(RWRK(I),I=ND1STA,ND2STA-1)
      IF(LHFLAG.GE.1) WRITE(IOVBORB)((LMOATM(I,J),I=1,5),J=1,NORBX)
C
      CALL GETIOUNIT('IOTEMP  ',IOTEMP)
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL WTGUES(NBASIS,RWRK(NAOBAS),NBASIS,IOTEMP,IOENGI)
      RETURN
C1000 FORMAT(/' ORBITALS IN AO BASIS: # OF ORBITAL(GROUP)'/)
C1100 FORMAT(/1X,8(I5,'(',I2,')'))
C1200 FORMAT(1X,8F9.6)
      END
      SUBROUTINE ROTLAO(NSUB,NBASIS,NHDIM,IRDEX,MLORBIT,MNORBIT,
     &   NB2ADD,BASIS,RVEC,BASLAO,BASNOC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION BASIS(*),BASLAO(*),BASNOC(*),MLORBIT(*),IRDEX(3,*)
      DIMENSION MNORBIT(*),NB2ADD(*),RVEC(*)
      IF(NHDIM.LE.0) RETURN
      CMAX = 0.0D0
      DO I=1, NHDIM
      IF(ABS(RVEC(I)).GT.CMAX) CMAX=ABS(RVEC(I))
      END DO
C     WRITE(IOUTVB,*)'CMAX ROT = ', CMAX
      DAMP = 1.0D0
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$DAMPROT',8,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)DAMP
C
C     UPDATE LOWDIN ORBITALS
C     (PERFORM RIGID ROTATION OF LOWDIN BASIS FUNCTIONS)
C
      NSTEP=100
C     IF(NOBIAS.EQ.1) NSTEP=100
      FACTOR=DAMP/NSTEP
      DO K=1,NSTEP
      DO I=1,NHDIM
      IR1=IRDEX(1,I)
      IR2=IRDEX(2,I)
      IR1B=(IR1-1)*NBASIS
      IR2B=(IR2-1)*NBASIS
      STHETA=DSIN(FACTOR*RVEC(I))
      CTHETA=DCOS(FACTOR*RVEC(I))
C     WRITE(IOUTVB,*)'I,IR1,IR2,STHETA,CTHETA=',I,IR1,IR2,STHETA,CTHETA
C
C     A=DCOS(THETA)*A+DSIN(THETA)*B
C     B=DCOS(THETA)*B-DSIN(THETA)*A
C
        DO J=1,NBASIS
        TEMP=BASLAO(IR1B+J)
        BASLAO(IR1B+J)=CTHETA*BASLAO(IR1B+J)+STHETA*BASLAO(IR2B+J)
        BASLAO(IR2B+J)=CTHETA*BASLAO(IR2B+J)-STHETA*TEMP
        END DO
      END DO
      END DO
C
C     UPDATE NONORTHOGONAL BASIS AND VIRTUAL ORBITALS
C
      NOBT  = 1
      NOBTX = 1
      DO 250 I=1,NSUB
      IBAS =(NOBT-1)*NBASIS+1
      IBASX=(NOBTX-1)*NBASIS+1
      CALL MATMUL2(NBASIS,MNORBIT(I),MLORBIT(I),BASLAO(IBASX),
     &            BASNOC(NB2ADD(I)),BASIS(IBAS))
      NOBT =NOBT+MLORBIT(I)
      NOBTX=NOBTX+MNORBIT(I)
 250  CONTINUE
C
C     BASIS<--VIRTUAL ORBITALS (ORTHONORMALIZED)
C
      LVIR=(NOBTX-1)*NBASIS
      DO I=LVIR+1,NBASIS*NBASIS
      II = I + (NOBT-NOBTX)*NBASIS
      BASIS(II)=BASLAO(I)
      END DO
C
      RETURN
      END
      SUBROUTINE GENSCF(METHOD,MELE,MSPIN,NBASIS,MLORBIT,MWIN,
     &  WBASIS,DMP,GD1,GD2,W,MSIZE,MITER,MGRP,LPTALL,LASTITER)
C    &  WBASIS,DMP,GD1,GD2,W,MSIZE,ETOTAL,MITER,MGRP,LPTALL,LASTITER)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C                General SCF routine.
C                1. Hartree-Fock
C                2. VBSCF
C                3. SCVB
C                4. CASVB
C                5. LHFSCF (localized nonorthgonal Hartree-Fock)
C     Note:
C
C               DMP: 1E-density of the whole system except the current subunit.
C               GD1: 1E-density of the current subunit.
C               GD2: 2E-density of the current subunit.
C               W:   scratch field.
C               MSIZE:  size of scratch field.
C               WBASIS: orbital optimization space.
C
C     History:
C               First created in Feb. 1998.
C               Recoded in September, 1999.
C               Added SCVB and CASVB, March, 2000.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION WBASIS(*),DMP(*),GD1(*),GD2(*),W(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      CHARACTER*80 FLAG
C
C     THE USE OF THE NUMBER CHARACTER IS NOW NO LONGER REQUIRED
C     BUT THIS EXAMPLE IS LEFT AS A COMMENTED OUT EXAMPLE, IN CASE
C     THE NEW METHOD IS NOT SUPPORTED BY SOME COMPILERS.
C     CHARACTER*80 NUMBER
C     NUMBER   = '0123456789'
C     NC1      = 1+MGRP/10
C     NC2      = 1+MGRP-10*(NC1-1)
      FLAG     = '$'
C     FLAG(2:2)= NUMBER(NC1:NC1)
C     FLAG(3:3)= NUMBER(NC2:NC2)
C     READ OR WRITE TO CHARACTER STRING IS ALLOWED IN RECENT COMPILERS
      WRITE(FLAG(2:3),'(I2.2)') MGRP
C     END OF EXAMPLE
C
C     Shortcut for special case: MELE=0
C
      IF(MELE.EQ.0) RETURN
      IF     (METHOD.EQ.1) THEN
      CALL PROJHF(NBASIS,MLORBIT,MWIN,MELE,MSPIN,MSIZE,WBASIS,DMP,
     &     W,GD1,MITER,MGRP)
      ELSE IF(METHOD.EQ.2) THEN
      CALL RVBSCF(NBASIS,MLORBIT,MWIN,MELE,MSPIN,MSIZE,WBASIS,DMP,
     &     W,GD1,GD2,MITER,MGRP,FLAG,LPTALL,LASTITER)
C    &     W,GD1,GD2,ETOTAL,MITER,MGRP,FLAG,LPTALL,LASTITER)
      ELSE IF(METHOD.EQ.3) THEN
      CALL SCVBSCF(NBASIS,MLORBIT,MWIN,MELE,MSPIN,MSIZE,WBASIS,DMP,
     &     W,GD1,GD2,MITER,MGRP,FLAG,LASTITER)
C    &     W,GD1,GD2,ETOTAL,MITER,MGRP,FLAG,LPTALL,LASTITER)
      ELSE IF(METHOD.EQ.4) THEN
      CALL CASVB(NBASIS,MLORBIT,MELE,MSPIN,MSIZE,WBASIS,DMP,
     &     W,GD1,GD2,MITER,MGRP,FLAG,LPTALL,LASTITER)
      ELSE IF(METHOD.EQ.5) THEN
      CALL RVBSCF(NBASIS,MLORBIT,MWIN,MELE,MSPIN,MSIZE,WBASIS,DMP,
     &     W,GD1,GD2,MITER,MGRP,FLAG,LPTALL,LASTITER)
      ELSE IF(METHOD.GE.5) THEN
      WRITE(IOUTVB,*)'Method > 5 is not implemented, STOP'
      CALL ABRTVB
      STOP
      END IF
      RETURN
      END
      SUBROUTINE MODBAS(NBASIS,BASIS,WBASIS,MINDEX,MWIN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION MINDEX(*),BASIS(NBASIS,*),WBASIS(NBASIS,*)
      DO I=1,MWIN
      DO J=1,NBASIS
      BASIS(J,MINDEX(I))=WBASIS(J,I)
      END DO
      END DO
      RETURN
      END
      SUBROUTINE COLBAS(NBASIS,BASIS,WBASIS,MINDEX,MWIN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION MINDEX(*),BASIS(NBASIS,*),WBASIS(NBASIS,*)
      DO I=1,MWIN
      DO J=1,NBASIS
      WBASIS(J,I)=BASIS(J,MINDEX(I))
      END DO
      END DO
      RETURN
      END
      SUBROUTINE WINDEX(MGRP,NBASIS,MWIN,IBASIS,MINDEX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IBASIS(*),MINDEX(*)
      CHARACTER*80 WFLAG
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      WFLAG='$00WINDW'
      WRITE(WFLAG(2:3),'(I2.2)') MGRP
C
C     SET DEFAULT WINDEX: MLORBIT+ALL VIRTURAL ORBITALS
C
      NOB=0
      DO I=1,NBASIS
      IF(IBASIS(I).EQ.MGRP) THEN
      NOB=NOB+1
      MINDEX(NOB)=I
      END IF
      END DO
      NOBV=NOB
      DO I=1,NBASIS
      IF(IBASIS(I).EQ.0) THEN
      NOBV=NOBV+1
      MINDEX(NOBV)=I
      END IF
      END DO
      IF(MWIN.NE.NOBV) THEN
      CALL LOCTOR(IOENGI,WFLAG,8,IOK,0)
        IF(IOK.EQ.0) THEN
C       WRITE(IOUTVB,*)'***WARNING***, INPUT FOR WINDOW IS MISSING'
C       WRITE(IOUTVB,*)'DEFAULT IS ASSUMED'
        ELSE
        READ(IOENGI,*)MWINMD,(IND,MINDEX(IND),K=1,MWINMD)
        END IF
      END IF
      RETURN
      END
      SUBROUTINE CASVB(NBASIS,MLORBIT,MELE,MSPIN,MWK,WBASIS,
     &    DMP,G,DMLOC,GD2,MITER,MGRP,FLAG,LPTALL,LASTITER)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Complete active space VB calculation.
C
C     Note:
C               Equivalent of CASSCF method.
C               For N<=6, CASVB is reasonably efficient. However,
C               CASVB is not implemented as an alternative to CASSCF for
C               larger N.
C     History:
C               First created in March, 2000.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     DMP:   DENSITY MATRIX OF THE WHOLE SYSTEM EXCEPT THE SUBSYSTEM
C     DMLOC: 1E-DENSITY MATRIX OF A SUBSYSTEM IN ITS LOCAL BASIS SET
C     GD2:   2E-DENSITY MATRIX OF A SUBSYSTEM IN ITS LOCAL BASIS SET
C     WBASIS:ORBITALS FOR THE CURRENT SUBUNIT
C     MGRP:  # OF THE SUBUNIT
C     MITER: # OF MACROITERATION
C     G:     SCRATCH
C
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*50 FLAG
C     PARAMETER (MAXNOB=200)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION G(*),WBASIS(*),DMP(*),DMLOC(*),GD2(*)
      COMMON /VBSTR/CSTR(10000),NPHI(100000),NSTR
C     COMMON /VBCTL/EPS,MAXIT,NOPT,IHESS,NEWTON,NOB(MAXNOB),NVBI(5000)
      COMMON /CSTRUC/CSTRUC(5000),ISTRUC(100)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      LPRT = LPTALL
      IF(MITER.GT.1) LPRT = 0
      DW = 0.0D0
      FLAG(4:11)='LENHANCE'
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,FLAG,11,IOK,0)
      IF(IOK.EQ.1) THEN
C         READ(IOENGI,*)NVBO
          READ(IOENGI,*) I
C         I is not used.
      END IF
      CALL SETCASVB(MELE,MSPIN,NSTR,NPHI,MLORBIT,MGRP,LPRT)
      IF(NSTR.GT.2000) WRITE(IOUTVB,1000)
 1000 FORMAT(" WARNING: TOO MANY VB STRUCTURES IN CASVB ")
C
C     COPY STUCTURE COEFFICIENTS FROM COMMON BLOCK CSTRUC
C
      ISTRUC(MGRP+1)=ISTRUC(MGRP)+NSTR
      DO I=1,NSTR
      CSTR(I)=CSTRUC(ISTRUC(MGRP)+I)
      END DO
C
C     DETERMINE STRUCTURE COEFFIECNETS IF IT IS THE FIRST TIME CALL
C     OR LAST ITERATION
C
C     THE STRUCTURE COEFFIECIENTS ARE USED TO CONSTRUCT 1E AND 2E DENSITY
C     IN VBMATR.
C
      IF(MITER.LE.1.OR.LASTITER.EQ.1.OR.DW.GT.0.0D0) THEN
      CALL LOCANVBO(MLORBIT,WBASIS,G)
C
C     DON'T PRINT STRUCTURE WEIGHTS FOR THIS CALL SINCE THE NEXT
C     CALL OF RESONA WILL DO.
C
      CALL RESONA(MELE,MSPIN,NBASIS,MLORBIT,NSTR,CSTR,NPHI,G,
     &     WBASIS,DMP,DMLOC,GD2,MWK,FLAG,0,MGRP)
      END IF
      CALL RESONA(MELE,MSPIN,NBASIS,MLORBIT,NSTR,CSTR,NPHI,G,
     &     WBASIS,DMP,DMLOC,GD2,MWK,FLAG,LASTITER,MGRP)
C
C     POSSIBLE STRUCTURE SYMMETRY
C
      CALL STRSYM(CSTR,NSTR,FLAG)
C
C     UPDATE STUCTURE COEFFICIENTS TO COMMON BLOCK CSTRUC
C
      DO I=1,NSTR
      CSTRUC(ISTRUC(MGRP)+I)=CSTR(I)
      END DO
      RETURN
      END
      SUBROUTINE SCVBSCF(NBASIS,MLORBIT,MWIN,MELE,MSPIN,MWK,WBASIS,
     &    DMP,G,DMLOC,GD2,MITER,MGRP,FLAG,LASTITER)
C    &    DMP,G,DMLOC,GD2,ETOTAL,MITER,MGRP,FLAG,LPTALL,LASTITER)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Spin-coupled VB calculation.
C
C     Note:
C               For N>=10, it is more efficient to perform VBSCF
C               calculation with only one VB structure, then followed
C               by a SCVB type calculation.
C
C     History:
C               First created in March, 2000.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     DMP:   DENSITY MATRIX OF THE WHOLE SYSTEM EXCEPT THE SUBSYSTEM
C     DMLOC: 1E-DENSITY MATRIX OF A SUBSYSTEM IN ITS LOCAL BASIS SET
C     GD2:   2E-DENSITY MATRIX OF A SUBSYSTEM IN ITS LOCAL BASIS SET
C     WBASIS:ORBITALS FOR THE CURRENT SUBUNIT
C     MGRP:  # OF THE SUBUNIT
C     MITER: # OF MACROITERATION
C     G:     SCRATCH
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*50 FLAG
      PARAMETER (MAXNOB=200)
      DIMENSION G(*),WBASIS(*),DMP(*),DMLOC(*),GD2(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /VBSTR/CSTR(10000),NPHI(100000),NSTR
      COMMON /VBCTL/EPS,MAXIT,NOPT,IHESS,NEWTON,NOB(MAXNOB),NVBI(5000)
      COMMON /CSTRUC/CSTRUC(5000),ISTRUC(100)
      LPRT = 1
      IF(MITER.GT.1) LPRT = 0
      IF(MLORBIT.GE.MAXNOB) THEN
        WRITE(IOUTVB,'(" IN SCVBSCF")')
        CALL SIZEABT(MLORBIT,MAXNOB,"VBOS IN GRP ",
     &  "MAXNOB",IOUTVB,.TRUE.)
      ENDIF
      CALL SETSCVB(MELE,MSPIN,NSTR,NPHI,NOB,EPS,MAXIT,NEWTON,
     &             NOPT,MLORBIT,MGRP,FLAG,LPRT)
C
C     COPY STUCTURE COEFFICIENTS FROM COMMON BLOCK CSTRUC
C
      ISTRUC(MGRP+1)=ISTRUC(MGRP)+NSTR
      DO I=1,NSTR
      CSTR(I)=CSTRUC(ISTRUC(MGRP)+I)
      END DO
      CALL GETCTLVAL('LCIONLY   ',CTLVAL,INTVAL)
      LCIONLY = INTVAL
C
C     DETERMINE STRUCTURE COEFFIECNETS IF IT IS THE FIRST TIME CALL
C
      IF(MITER.LE.1) THEN
      CALL RESONA(MELE,MSPIN,NBASIS,MLORBIT,NSTR,CSTR,NPHI,G,
     &     WBASIS,DMP,DMLOC,GD2,MWK,FLAG,LASTITER,MGRP)
      END IF
      IF(LCIONLY.NE.1) THEN
      CALL VBSCF(MELE,MSPIN,NBASIS,MLORBIT,MWIN,G,WBASIS,DMP,
     &         DMLOC,GD2,MWK,MGRP,FLAG,MITER,LASTITER)
C    &         DMLOC,GD2,MWK,ETOTAL,MGRP,FLAG,MITER,LASTITER)
      ELSE
      CALL RESONA(MELE,MSPIN,NBASIS,MLORBIT,NSTR,CSTR,NPHI,G,
     &     WBASIS,DMP,DMLOC,GD2,MWK,FLAG,LASTITER,MGRP)
      END IF
C
C     UPDATE STUCTURE COEFFICIENTS TO COMMON BLOCK CSTRUC
C
      DO I=1,NSTR
      CSTRUC(ISTRUC(MGRP)+I)=CSTR(I)
      END DO
      RETURN
      END
      SUBROUTINE RVBSCF(NBASIS,MLORBIT,MWIN,MELE,MSPIN,MWK,WBASIS,
     &    DMP,G,DMLOC,GD2,MITER,MGRP,FLAG,LPTALL,LASTITER)
C    &    DMP,G,DMLOC,GD2,ETOTAL,MITER,MGRP,FLAG,LPTALL,LASTITER)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Resonance VBSCF calculation.
C
C     Note:
C               VBSCF method works efficient for one up to a few VB structures.
C
C     History:
C               First created in March, 2000.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     DMP:   DENSITY MATRIX OF THE WHOLE SYSTEM EXCEPT THE SUBSYSTEM
C     DMLOC: 1E-DENSITY MATRIX OF A SUBSYSTEM IN ITS LOCAL BASIS SET
C     GD2:   2E-DENSITY MATRIX OF A SUBSYSTEM IN ITS LOCAL BASIS SET
C     WBASIS:ORBITALS FOR THE CURRENT SUBUNIT
C     MGRP:  # OF THE SUBUNIT
C     MITER: # OF MACROITERATION
C     G:     SCRATCH
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*50 FLAG
      PARAMETER (MAXNOB=200)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION G(*),WBASIS(*),DMP(*),DMLOC(*),GD2(*)
      COMMON /VBSTR/CSTR(10000),NPHI(100000),NSTR
      COMMON /VBCTL/EPS,MAXIT,NOPT,IHESS,NEWTON,NOB(MAXNOB),NVBI(5000)
      COMMON /CSTRUC/CSTRUC(5000),ISTRUC(100)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      IF(MLORBIT.GE.MAXNOB) THEN
        WRITE(IOUTVB,'(" IN RVBSCF")')
        CALL SIZEABT(MLORBIT,MAXNOB,"VBOS IN GRP ",
     &  "MAXNOB",IOUTVB,.TRUE.)
      ENDIF
      CALL SETVB(MELE,NSTR,NPHI,NOB,EPS,MAXIT,NEWTON,
     &           NOPT,MLORBIT,MITER,MGRP,FLAG)
C
C     COPY STUCTURE COEFFICIENTS FROM COMMON BLOCK CSTRUC
C
      ISTRUC(MGRP+1)=ISTRUC(MGRP)+NSTR
      DO I=1,NSTR
      CSTR(I)=CSTRUC(ISTRUC(MGRP)+I)
      END DO
      CALL GETCTLVAL('LCIONLY   ',CTLVAL,INTVAL)
      LCIONLY = INTVAL
C
C     SPECIAL CASE: LOCALIZED HARTREE-FOCK
C
      IF(MELE.EQ.2*MLORBIT) THEN
        CSTRUC(ISTRUC(MGRP)+1)=1.0D0
        CALL LHFSCF(MELE,NBASIS,MLORBIT,MWIN,G,WBASIS,DMP,
     &       DMLOC,GD2,MWK,MGRP,FLAG,MITER,LASTITER)
C    &       DMLOC,GD2,MWK,ETOTAL,MGRP,FLAG,MITER,LASTITER)
      RETURN
      ENDIF
C
C     DETERMINE STRUCTURE COEFFIECNETS IF IT IS THE FIRST TIME CALL
C     CHANGE IT FOR 2. JLI, MAY 2, 2009
C
      IF(MITER.LE.1) THEN
      IF(LPTALL.EQ.1.AND.NSTR.GT.1) WRITE(IOUTVB,1000)
      CALL RESONA(MELE,MSPIN,NBASIS,MLORBIT,NSTR,CSTR,NPHI,G,
     &     WBASIS,DMP,DMLOC,GD2,MWK,FLAG,0,MGRP)
      END IF
      IF(LCIONLY.NE.1) THEN
      CALL VBSCF(MELE,MSPIN,NBASIS,MLORBIT,MWIN,G,WBASIS,DMP,
     &         DMLOC,GD2,MWK,MGRP,FLAG,MITER,LASTITER)
C    &         DMLOC,GD2,MWK,ETOTAL,MGRP,FLAG,MITER,LASTITER)
      ELSE
C
C     NOTE: CALL RESONA EACH MACRO ITERATION IS NECESSARY
C           OTHERWISE, THE NR METHOD MAY CONVERGE TO A
C           DIFFERENT STATE OF VBCI SPACE
C
      CALL RESONA(MELE,MSPIN,NBASIS,MLORBIT,NSTR,CSTR,NPHI,G,
     &     WBASIS,DMP,DMLOC,GD2,MWK,FLAG,LASTITER,MGRP)
      END IF
C
C     UPDATE STUCTURE COEFFICIENTS TO COMMON BLOCK CSTRUC
C
      DO I=1,NSTR
      CSTRUC(ISTRUC(MGRP)+I)=CSTR(I)
      END DO
      RETURN
 1000 FORMAT(' CALCULATE INITIAL STRUCTURE COEFFICIENTS')
      END
      SUBROUTINE RESONA(N,NS,MT,NORT,NSTR,CSTR,NPHI,W,
     &           WBASIS,DMP,DM1,DM2,MW,FLAG,LASTITER,MGRP)
C    &           WBASIS,DMP,DM1,DM2,MW,FLAG,LPTALL,LASTITER,MGRP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPHI(*),CSTR(*),W(MW),DMP(*),WBASIS(*),DM1(*),DM2(*)
C     DIMENSION SDM(10000)
      CHARACTER*50 FLAG
C     EPS=0.000001D0
      CALL GETIOUNIT('IOTEMPA ',IOTEMPA)
      CALL GETIOUNIT('IOTEMPB ',IOTEMPB)
      LBUFF   = 4095
C
C     ADDRESS
C
      MTX    = MT
      IF(NORT .GT. MT) MTX=NORT
      NSTRSQ = NSTR*(NSTR+1)/2
      MSQ    = MT*(MT+1)/2
C     MGSQ   = MSQ*(MSQ+1)/2
C     NMSQ   = MT*MSQ
      MXSQ   = MTX*(MTX+1)/2
C
      MMS    = 1
      MMH    = MMS+MXSQ
      MM1    = MMH+MXSQ
      MM2    = MM1+MTX*MTX
      MM3    = MM2+MTX*MTX*(MTX+1)/2
      NORTSQ = NORT*(NORT+1)/2
      NGSQ   = NORTSQ*(NORTSQ+1)/2
C
      NNS    = 1
      NNH    = NNS + NORTSQ
      NNG    = NNH + NORTSQ
      NNSS   = NNG + NGSQ
      NVBS   = NNSS + N*NORT
      NVBH   = NVBS + NSTRSQ
      NNWK   = NVBH + NSTRSQ
      NREM   = MW - NNWK+1
C
C     SET INDEX
C
      CALL SETIND(MTX,MTX)
C
C     CHECK WORK FIELD
C
      IF(MM3+MSQ.GT.MW.OR.NNWK+4*NSTR**2.GT.MW)
     &CALL ABORT0('RESONA01  ')
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL GETIOUNIT('IAO2E   ',IAO2E)
      CALL GETIOUNIT('IVBO2E  ',IVBO2E)
C     TIME2 = XCLOCK()
      CALL READ1E(IAO1E,W(MMS),W(MMH),MT)
C
C     COPY DENSITY OF CORE TO WORKING FILED G(MM3)
C
      DO I=1,MSQ
      W(MM3-1+I)=DMP(I)
      END DO
C     TIME=XCLOCK()
      REWIND(IVBO2E)
      IHFPO = 1
      CALL TRAN1E(MT,NORT,W(MMS),W(MMH),
     &     WBASIS,W(MM1),W(MM2),W(MM3),IHFPO,IVBO2E)
      CALL TRANP2E(MT,NORT,0,WBASIS,W,MW,LBUFF,IOTEMPA,IOTEMPB)
      CALL SHREAD(W(NNS),W(NNH),NORTSQ,IVBO2E)
      CALL GREAD(W(NNG),NGSQ,LBUFF,IVBO2E)
C
C     PRINT OVERLAP MATRIX OF VB ORBITALS
C
      IF(LASTITER.EQ.1) CALL MPRINT2(NORT,W(NNS),1,MGRP)
      CALL VBMATR(N,NS,NORT,NSTR,NPHI,CSTR,W(NNS),W(NNH),W(NNG),
     &     W(NVBS),W(NVBH),DM1,DM2,W(NNSS),W(NNWK),E0,NREM)
      CALL RVB(NSTR,CSTR,W(NVBS),W(NVBH),W(NNWK),NREM,F2,FLAG,
     &         LASTITER,MGRP)
C
C     COMPUTE SPIN DENSITY
C
      ISPDEN = 0
      CALL GETCTLVAL("SPINDEN   ",CTLVAL,ISPDEN)
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$SPDEN',6,IOK,0)
      IF(IOK.EQ.1) ISPDEN = 1
      IF(LASTITER.EQ.1.AND.NS.GT.0.AND.ISPDEN.EQ.1) THEN
        NSQ   = NORT*(NORT+1)/2
        NADDS = 1
        NADDD = NADDS+NSQ
        NADDAD= NADDD+NSQ
        NWK   = NADDAD + MSQ
        CALL SHREAD(W(NADDS),W(NADDD),NORTSQ,IVBO2E)
        CALL SPDEN(N,NS,NSTR,W(NADDS),NORT,NPHI,CSTR,W(NADDD))
        CALL MATRAN1(NORT,MT,WBASIS,W(NWK),W(NADDD),W(NADDAD))
        CALL SPDATM(W(NADDAD),W(NWK))
      END IF
      RETURN
      END
      SUBROUTINE PROJHF(M,NCORE,NCV,MESUB,MSSUB,MWK,WBASIS,DMP,
     &           W,GD1,MITER,MGRP)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Subspace Projected Hartree-Fock Method
C
C     Note:
C               This is Not the spin-projected HF, nor the extended HF method.
C               This is the HF calculation method for core electrons in the
C               field of other electrons. Projection of the Fock matrix in the
C               subspace of HF window is performed. The four-index integral
C               transformation of HF group is avoided.
C
C     History:
C               First created on April 1, 2000.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*50 FLAG
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME,FKFILE
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      PARAMETER (MAXCEN=200,MAXBFN=726)
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
      PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA,MAXGRP=99)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(MAXGRP),MSPIN(MAXGRP),MNORBIT(MAXGRP),
     &MLORBIT(MAXGRP),MWIN(MAXGRP),MSTR(MAXGRP),METHOD(MAXGRP),
     &IBASIS(MAXEXT),NOCC(MAXEXT),NOBIAS,NEPS,NVIR,NOTROT(5000),
     &LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(MAXGRP)
      COMMON /CSTRUC/CSTRUC(5000),ISTRUC(100)
      DIMENSION W(*),DMP(*),E(5000),GD1(*),WBASIS(M,*)
      DIMENSION PGM(50000)
      ISTRUC(MGRP+1)=ISTRUC(MGRP)+1
      CSTRUC(ISTRUC(MGRP)+1)=1.0D0
      IF(NCORE.EQ.0.OR.(MITER.EQ.1.AND.MGRP.EQ.1).OR.
     & LFROZN.EQ.1) RETURN
      EPS=1.0D-4
      NE=NCORE*2
C     EOLD=0.0D0
      ITER=0
      ITMAX=30
C     0.0: NO DAMPING. 0.5 HALF
      DAMP = 0.0D0
      FKFILE=FSTR(1:LENFIL)//'.FKT'
C
C     ERROR CHECK
C
      IF(NE.NE.MESUB.OR.MSSUB.NE.0) CALL ABORT0('PROJHF01  ')
C
C     ADDRESS
C
      MSQ    = M*(M+1)/2
C     MGSQ   = MSQ*(MSQ+1)/2
C     NCVSQ  = NCV*(NCV+1)/2
      MMS    = 1
      MMH    = MMS+MSQ
      MMD    = MMH+MSQ
      MMF    = MMD+MSQ
      MMG    = MMF+MSQ
      MCVS   = MMG
      MCVH   = MCVS + NCV*NCV
      MCVF   = MCVH + NCV*NCV
      MCVD   = MCVF + NCV*NCV
      MWRK   = MCVD + NCV*NCV
      MCVV   = MCVD + NCV*NCV
      MCVWRK = MCVV + NCV*NCV
C     MFKOLD = MCVWRK
      MMS1   = 0
      MMH1   = MMS1+MSQ
      MMD1   = MMH1+MSQ
      MMF1   = MMD1+MSQ
      MMG1   = MMF1+MSQ
      MCVS1  = MMG1
      MCVH1  = MCVS1 + NCV*NCV
      MCVF1  = MCVH1 + NCV*NCV
      MCVD1  = MCVF1 + NCV*NCV
      MWRK1  = MCVD1 + NCV*NCV
      MCVV1  = MCVD1 + NCV*NCV
      MCVWRK1= MCVV1 + NCV*NCV
      MFKOLD1= MCVWRK1
C
C     CHECK WORK FIELD
C
      IF(MCVWRK.GT.MWK.OR.MCVWRK1.GT.MWK) CALL ABORT0('PROJHF02  ')
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL GETIOUNIT('IAO2E   ',IAO2E)
      CALL GETIOUNIT('IOTEMP  ',IOTEMP)
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$HFCOREDAMP',11,IOK,0)
      IF(IOK.GE.1) THEN
        READ(IOENGI,*)DAMP
        WRITE(IOUTVB,*)" CORE-HARTREE-FOCK DAMPING FACTOR = ",DAMP
        OPEN(IOTEMP,FILE=FKFILE,STATUS='UNKNOWN',FORM='UNFORMATTED',
     &       ERR=111)
      END IF
      GOTO 100
 111  WRITE(IOUTVB,*)"NO FILE OPEN"
 100  CONTINUE
      ITER=ITER+1
      CALL READ1E(IAO1E,W(MMS),W(MMH),M)
C
C     CONSTRUCT THE TOTAL DENSITY BY ADDING CORE ELECTRON PART
C
      DO I=1,MSQ
      W(MMD1+I)=DMP(I)
      END DO
      DO I=1,NCORE
        DO J=1,M
        JJ=J*(J-1)/2
        DO K=1,J
        JK=JJ+K
        W(MMD1+JK)=W(MMD1+JK)+2.0D0*WBASIS(J,I)*WBASIS(K,I)
        END DO
        END DO
      END DO
C
C     CONSTRUCT THE FOCK MATRIX
C
C     FOCK MATRIX
C
      CALL FKENGI(W(MMF),W(MMD),M,1)
      DO I=1, MSQ
      W(MMF1+I) = W(MMF1+I)+W(MMH1+I)
      END DO
      IF(ITER.GT.1.AND.DAMP.GT.0.0D0) THEN
         REWIND(IOTEMP)
         READ(IOTEMP)(W(MFKOLD1+I),I=1,MSQ)
         DO I=1, MSQ
           W(MMF1+I) = (1.0D0-DAMP)*W(MMF1+I) + DAMP*W(MFKOLD1+I)
         END DO
      END IF
      IF(DAMP.GT.0.0D0) THEN
          REWIND(IOTEMP)
          WRITE(IOTEMP)(W(MMF1+I),I=1,MSQ)
      END IF
C
C     TRANSFORMATION OF FOCK MATRIX
C
      CALL MATRAN(M,NCV,WBASIS,W(MWRK),W(MMF),W(MCVF))
      CALL MATRAN(M,NCV,WBASIS,W(MWRK),W(MMH),W(MCVH))
      CALL MATRAN(M,NCV,WBASIS,W(MWRK),W(MMS),W(MCVS))
C
C     RESTORE INTO SQUARE FORM
C
      IJ=0
      DO I=1,NCV
      DO J=1,NCV
      IJ=IJ+1
      W(MWRK1+IJ)=W(MCVF1+IJ00(I,J))
      END DO
      END DO
      DO I=1,NCV*NCV
      W(MCVF1+I)=W(MWRK1+I)
      END DO
      IJ=0
      DO I=1,NCV
      DO J=1,NCV
      IJ=IJ+1
      W(MWRK1+IJ)=W(MCVH1+IJ00(I,J))
      END DO
      END DO
      DO I=1,NCV*NCV
      W(MCVH1+I)=W(MWRK1+I)
      END DO
      IJ=0
      DO I=1,NCV
      DO J=1,NCV
      IJ=IJ+1
      W(MWRK1+IJ)=W(MCVS1+IJ00(I,J))
      END DO
      END DO
      DO I=1,NCV*NCV
      W(MCVS1+I)=W(MWRK1+I)
      END DO
      CALL EG(NCV,W(MCVF),W(MCVS),E,W(MCVV),W(MCVWRK))
C
C     FIND THE MAX. MODIFICATION
C
      CMAX=0.0D0
      IJ=0
      DO I=1,NCORE
      II=(I-1)*NCV
      DO J=NCORE+1,NCV
      IJ=II+J
      IF(DABS(W(MCVV1+IJ)).GT.CMAX) CMAX=DABS(W(MCVV1+IJ))
      END DO
      END DO
C
C     COMPUTE DENSITY IN ORBITAL BASIS SET
C
      DO I=1,NCV*NCV
      W(MCVD1+I)=0.0D0
      END DO
      DO I=1,NCORE
      IMCVV1=MCVV1+(I-1)*NCV
        DO J=1,NCV
        JJ=(J-1)*NCV
        DO K=1,NCV
        JK=JJ+K
        W(MCVD1+JK)=W(MCVD1+JK)+2.0D0*W(IMCVV1+J)*W(IMCVV1+K)
        END DO
        END DO
      END DO
C
C     CALCULATE ENERGY
C     THE ENERGY EXPRESSION IS NOT CORRECT, DON'T USE IT
C     JIABO LI, APRIL 1, 2000
C
      ENERGY=0.0D0
      DO I=1,NCV*NCV
      ENERGY=ENERGY+W(MCVD1+I)*(W(MCVH1+I)+W(MCVF1+I))
      END DO
      ENERGY=ENERGY*0.5D0
C     EDIFF=ENERGY-EOLD
C     EOLD=ENERGY
C     WRITE(IOUTVB,'(' COREHF: ITER, CMAX',I5,F10.5)')ITER,CMAX
C
C     UPDATE WBASIS
C
      CALL MATMUL2(M,NCV,NCV,WBASIS,W(MCVV),W(MCVWRK))
      IJ=0
      DO I=1,NCV
      DO J=1,M
      IJ=IJ+1
      WBASIS(J,I)=W(MCVWRK1+IJ)
      END DO
      END DO
      IF(ITER.GE.ITMAX.AND.CMAX.GT.EPS.AND.DAMP.LT.0.0001D0) THEN
      WRITE(IOUTVB,*)
     &  ' CORE-HARTREE-FOCK UNCONVERGED AFTER',ITER,'ITERATIONS'
      WRITE(IOUTVB,*)' CMAX =',CMAX
      WRITE(IOUTVB,*)
     &  ' PLEASE TRY TO USE A DAMPING FACTOR BY ADDING TWO '
      WRITE(IOUTVB,*)" LINES IN YOUR INPUT LIKE:"
      WRITE(IOUTVB,*)" $HFCOREDAMP"
      WRITE(IOUTVB,*)" 0.3"
      WRITE(IOUTVB,*)"  "
      WRITE(IOUTVB,*)" WHERE THE DAMPING FACTOR CAN BE A VALUE 0-0.8 "
      WRITE(IOUTVB,*)
     &  " 0: NO DAMPING. 0.8 VERY STRONG DAMPING, SLOW CONV."
      GOTO 200
      END IF
      IF(CMAX.GT.EPS) GOTO 100
 200  CONTINUE
C
C     LOCALIZATION. It will not effect the final results even if LMO is not
C     performed
C
      MWRK=MMH
      CALL READ1E(IAO1E,W(MMS),W(MWRK),M)
C
C     NVIRX=NCV-NCORE
C     NOBVIR=NCORE*M+1
      NPMVIR=NCORE*NATOM+1
C
C     CSPLIT IS USED IN A LOT OF PLACES. IF ANY CHANGE IS MADE,
C     MAKE SURE THE OTHER PLACES ARE ALSO CHANGED
C
      CSPLIT  = 0.15D0
C
C     READ CHARGE RATIO FOR SETTING SPLITING FLAG
C
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$SPLITRATIO',11,IOK,0)
      IF(IOK.GE.1) READ(IOENGI,*)CSPLIT
      LPTALLX = 0
      CALL LOCAPM(M,NCORE,NATOM,NATBAS,W,W(MWRK),WBASIS,PGM,E,0,LPTALLX,
     &            BFLABE,CSPLIT,0)
      IF(NVIR.GT.0) THEN
      CALL LOCAPM(M,NVIR, NATOM,NATBAS,W,W(MWRK),WBASIS(1,NCORE+1)
     &,PGM(NPMVIR),E(NCORE+1),1,LPTALL,BFLABE,CSPLIT,0)
      END IF
C
C     CALCULATE D1 OF CORE ELECTRONS (LOCAL BASIS SET)
C
      DO 300 I=1,NCORE*(NCORE+1)/2
 300  GD1(I)=0.0D0
      DO 400 K=1,NCORE
      GD1(K*(K+1)/2)=2.0D0
 400  CONTINUE
      IF(DAMP.GT.0.0D0) CLOSE(IOTEMP)
      RETURN
      END
C========================================================================
C     IO routines and interfaces for Gaussian and Gamess.
C========================================================================
C
      SUBROUTINE IOVBINIT()
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 VBPATH
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /IOUNIT/IAO1E,IAO2E,IOHFORB,IOVBORB,IVBO2E,IOMAP,IOHES,
     &               IOVBOLIB,IOENGI,IOTEMP,IOTEMPA,IOTEMPB,VBPATH
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
C     Initialize I/O units
C     The I/O units can be assigned dynamically. In case having confliction
C     with a third party program, here is the place one can make changes.
C
C     81
C
      IAO1E   = 81
      FUNIT(1)='V81'
C
C     82
C
      IAO2E   = 82
      FUNIT(2)='V82'
C
C     83
C
      IOHFORB = 83
      FUNIT(3)='V83'
C
C     84
C
      IOVBORB = 84
      FUNIT(4)='V84'
C
C     85
C
      IVBO2E  = 85
      FUNIT(5)='V85'
C
C     86
C
      IOTEMPA = 86
      FUNIT(6)='V86'
C
C     87
C
      IOTEMPB = 87
      FUNIT(7)='V87'
C
C     88
C
      IOHES   = 88
      FUNIT(8)='V88'
C
C     89
C
      IOVBOLIB= 89
      FUNIT(9)='V89'
C
C     80
C
      IOENGI  = 80
      FUNIT(10)='V80'
C
      IOTEMP  = 78
      IOMAP   = 79
C
      RETURN
      END
C
C     GET IOUNIT BY IONAME
C
      SUBROUTINE GETIOUNIT(IONAME,IOUNIT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 VBPATH
      CHARACTER*8  IONAME
      COMMON /IOUNIT/IAO1E,IAO2E,IOHFORB,IOVBORB,IVBO2E,IOMAP,IOHES,
     &               IOVBOLIB,IOENGI,IOTEMP,IOTEMPA,IOTEMPB,VBPATH
      IF (IONAME.EQ.'IAO1E   ') IOUNIT = IAO1E
      IF (IONAME.EQ.'IAO2E   ') IOUNIT = IAO2E
      IF (IONAME.EQ.'IOHFORB ') IOUNIT = IOHFORB
      IF (IONAME.EQ.'IOVBORB ') IOUNIT = IOVBORB
      IF (IONAME.EQ.'IVBO2E  ') IOUNIT = IVBO2E
      IF (IONAME.EQ.'IOMAP   ') IOUNIT = IOMAP
      IF (IONAME.EQ.'IOHES   ') IOUNIT = IOHES
      IF (IONAME.EQ.'IOVBOLIB') IOUNIT = IOVBOLIB
      IF (IONAME.EQ.'IOENGI  ') IOUNIT = IOENGI
      IF (IONAME.EQ.'IOTEMP  ') IOUNIT = IOTEMP
      IF (IONAME.EQ.'IOTEMPA ') IOUNIT = IOTEMPA
      IF (IONAME.EQ.'IOTEMPB ') IOUNIT = IOTEMPB
      RETURN
      END
      SUBROUTINE GETVBPATH(VBPATHA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 VBPATH
      CHARACTER*80 VBPATHA
C     CHARACTER*8  IONAME
      COMMON /IOUNIT/IAO1E,IAO2E,IOHFORB,IOVBORB,IVBO2E,IOMAP,IOHES,
     &               IOVBOLIB,IOENGI,IOTEMP,IOTEMPA,IOTEMPB,VBPATH
      VBPATHA = VBPATH
      RETURN
      END
      SUBROUTINE SETVBPATH(VBPATHA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 VBPATH
      CHARACTER*80 VBPATHA
C     CHARACTER*8  IONAME
      COMMON /IOUNIT/IAO1E,IAO2E,IOHFORB,IOVBORB,IVBO2E,IOMAP,IOHES,
     &               IOVBOLIB,IOENGI,IOTEMP,IOTEMPA,IOTEMPB,VBPATH
      VBPATH = VBPATHA
      RETURN
      END
C
C     GET CONTROL VALUES
C
      SUBROUTINE GETCTLVAL(CTLNAME,CTLVAL,INTCTL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*10 CTLNAME
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      PARAMETER (MAXBFN=726)
      PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA,MAXGRP=99)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(MAXGRP),MSPIN(MAXGRP),MNORBIT(MAXGRP),
     &MLORBIT(MAXGRP),MWIN(MAXGRP),MSTR(MAXGRP),METHOD(MAXGRP),
     &IBASIS(MAXEXT),NOCC(MAXEXT),NOBIAS,NEPS,NVIR,NOTROT(5000),
     &LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(MAXGRP)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION CTLVAL(*),INTCTL(*)
C
C     TODO: ADD MORE LINES
      IF(CTLNAME.EQ.'LCIONLY   ') THEN
        INTCTL(1) = LCIONLY
        RETURN
      END IF
C
C     SPIN DENSITY CONTROL
C
      IF(CTLNAME.EQ.'SPINDEN   ') THEN
        INTCTL(1) = KEY(13)
        RETURN
      END IF
C
C     DIIS CONTROL
C
      IF(CTLNAME.EQ.'DIIS      ') THEN
        INTCTL(1) = KEY(14)
        RETURN
      END IF
      CTLVAL(1) = 0
      WRITE(IOUTVB,*)'UNKNOWN CONTROL NAME = ', CTLNAME
      CALL ABORT0('GETCTLVAL1')
      RETURN
      END
      SUBROUTINE INPUTVB(W,MSIZE)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Top level input routine for VB2000.
C
C     Note:
C               This routine is called at the begining. It loads general
C               information about a molecule, i.e. the numbers of its atoms,
C               electrons, basis functions and charge. It also sets up
C               general controls for the calculations and initializes some
C               variables, including the initial guess of orbitals.
C
C     History:
C               Developed by Jiabo Li, 1993-1995, Erlangen, Germany
C               Re-Engineered by Jiabo Li, Dec., 1998, Minneapolis, USA
C               Updated by Jiabo Li, 1998-2000, Minneapolis/San Diego, USA
C
C               Nov. 10, 2003 Jiabo Li: Fixed a CASVB setting bug for number of
C               orbitals. Nov. 10, 2003
C
C               (TODO: the input logic need a more clean design).
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     PARAMETER (MAXWKI=100000)
      CHARACTER*80 BUFF,WORD,VBPATH,VBTEMP,BAS
CGMS  CHARACTER*80 FILENAME
CGAU  CHARACTER*80 FILENAME
      CHARACTER*12 BFLABE
CGMS  CHARACTER*12 DUMMY
CGAU  CHARACTER*12 DUMMY
      CHARACTER*20 BASNAME
      CHARACTER*8  BONDLAB
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      PARAMETER (MAXSHL=500,MAXPRM=15,MAXEXP=1000)
      PARAMETER (MAXCEN=200,MAXBFN=726,MAXCUB=100)
      PARAMETER (MAXST1=33334,MAXNOB=200,MAXGRP=99,MAXBLL=12500)
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
      PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA)
C
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(MAXGRP),MSPIN(MAXGRP),MNORBIT(MAXGRP),
     &MLORBIT(MAXGRP),MWIN(MAXGRP),MSTR(MAXGRP),METHOD(MAXGRP),
     &IBASIS(MAXEXT),NOCC(MAXEXT),NOBIAS,NEPS,NVIR,NOTROT(5000),
     &LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(MAXGRP)
C
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /LMOCHA/CHAMAX(4,1000),MAXCHA(4,1000)
      COMMON /CSTRUC/CSTRUC(5000),ISTRUC(100)
C     COMMON /IAA/IA(100000)
C000  COMMON /DORF/ NUMD,NUMF
CSMI  COMMON /DORF/ NUMD,NUMF
CGMS  COMMON /DORF/ NUMD,NUMF
      DIMENSION EIG(5000),LMOGRP(1000),W(*),NAOST(1000)
      PARAMETER (MAXNAB=MAXCEN*MAXBFN/2,MAXBF2=MAXBFN*MAXBFN)
      COMMON /LMODAT/VMO(MAXBF2),VLMO(MAXBF2),LMOLAB(2,MAXBFN),
     &LMOATM(5,MAXBFN),PGM(MAXNAB),ENGLMO(MAXBFN),BONDLAB(MAXBFN),
     &MCLMO(5,80),LHFLAG
CGMS  COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
CGMS  DATA CHECK  /8HCHECK   /
C
C     DESCRIPTION OF VARIABLES
C
C     GENINF [GENERAL(GLOBAL) INFORMATION]
C
C     ENREP:  	Energy of nuclear repulsion.
C     XYZ:	Cartesian coordinates.
C     NATOM:	Number of atoms in the molecule
C     NELE:	Number of electrons in the molecule.
C     NSPIN:    Number of unpaired spins in the molecule.
C     NBASIS:	Number of basis functions of the molecule.
C     NATNUM:	Nuclear number of atoms.
C     NATBAS:	Number of basis functions on each atom.
C
C     GENCTL [GENERAL(GLOBAL) CONTROL]
C
C     NSUB:	Number of subunits.
C     IMACRO:	Number of maximal macro iterations.
C     IRESTART:	Flag.
C               = 2: Restart job. Read guess. Integrals and HF can be skiped
C               = 1: Read orbital guess from previous VB computation.
C               = 0: New calculation.
C               =-1: Generate LMO only, then stop
C     MROT:     Number of rigid rotation for each macro-iteration
C               Default=1
C     ICON:     Flag
C               = 1  Connect Gaussian
C               = 2  Connect Gamess
C               = 3  Connect existing integral files (must in certain format)
C
C     MELE(99)	Number of electrons for each subunit.
C     MSPIN(99)	Number of unpaired spin for each subunit. (Only on subunit
C               is allowed to have a MPSIN >0. This is the restriction by
C               separability theory).
C     MLORBIT   Number of non-orthogonal orbitals used in each subunit.
C     MNORBIT   Number of linear independent orbitals used in each subunit.
C               MLORBIT >= MNORBIT
C     MWIN(99)  Number of orbitals in the window of the subunit.
C     MSTR(99)	Number of structures(or configurations) in VB (or CI)
C               calculations.
C     METHOD(99)Method for each subunit.
C               =1: Hartree-Fock (for core orbitals)
C               =2: VBSCF
C               =3: SCVB
C               =4: CASVB (=CASSCF)
C               =5: LHFCF (localized Hartree-Fock)
C
C     IBASIS   	Indeces of orbitals indicating which subunit the orbit belongs
C               to. Thus, if IBASIS(I)=0, then orbital I is a virtual orbital.
C     NOCC	Occupation number.
C               =2: Doublly occupied.
C               =1: Partially occupied.
C               =0: Virtual orbital.
C
C     NEPS      Convergence threshold of total energy
C               (deltaE < 10**(-NEPS))
C               =6 (default)
C
C     FILES:
C               IAO1E  -- ONE-ELECTRON INTEGRALS IN ORIGINAL AO'S(SS,HH)
C               IAO2E  -- TWO-ELECTRON INTEGRALS IN ORIGINAL AO'S
C                         FUNCTIONS
C               IOHFORB-- HF ORBITALS
C               IOVBORB-- VB ORBITALS
C               IVBO2E -- TWO-ELECTRON INTEGRALS IN VBO BASIS SET.
C
C               IOMAP  -- MAP FILE OF VB
C               IOHES  -- FILE FOR HESSIAN
C
C
C     GUESS=READ: INPUT KEYWORD FOR SETTING IRESTART=1
C
C     RESTART:    INPUT KEYWORD ROR SETTING IRESTART=2
C
C
CGMS  DUMMY='            '
CGAU  DUMMY='            '
CGAU  ICON   = 1
CGMS  ICON   = 2
C000  ICON   = 3
CSMI  ICON   = 4
      NEPS   = 6
      IMACRO = 12
      IOLVBO = 0
C
C     READ $GENINF
C
CGMS  IF (ICON.EQ.2) CALL CONGMS()
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL GETIOUNIT('IOVBORB ',IOVBORB)
      REWIND(IOVBORB,ERR=999)
      IF(IPNT.GT.1) THEN
C     READ(IOVBORB)NSUBX,NDM1X,(MELE(I),I=1,NSUBX),
C     J/NDM1J not used, so change to fool ftnchek.
      READ(IOVBORB)NSUBX,J,(MELE(I),I=1,NSUBX),
     &             (MLORBIT(I),I=1,NSUBX),(METHOD(I),I=1,NSUBX)
        DO I=1, NSUBX
        IF(METHOD(I).EQ.1) MELE(I)=MLORBIT(I)*2
        END DO
      REWIND(IOVBORB,ERR=999)
      GOTO 999
      END IF
      CALL GETVBPATH(VBPATH)
      CSPLIT = 0.15D0
      IF(MROT.LT.0) MROT = 1
C
C     READ CHARGE RATIO FOR SETING SPLITING FLAG
C
      CALL LOCTOR(IOENGI,'$SPLITRATIO',11,IOK,0)
      IF(IOK.GE.1) READ(IOENGI,*,ERR=9991)CSPLIT
      DO 20 I=1,5000
 20   CSTRUC(I)=1.0D0
      REWIND(IOVBORB,ERR=999)
C     IF(NBASIS*(NBASIS+1)/2.GT.MAXWKI) CALL ABORT0('INPUTVB01 ')
      IF(LPTALL.EQ.1) THEN
      WRITE(IOUTVB,'(/,"                    PARAMETER LIMIT VALUES")') 
      WRITE(IOUTVB,
     &'(" Max. no. of atoms                    MAXCEN =",I6)') MAXCEN
      WRITE(IOUTVB,
     &'(" Max. no. of basis functions          MAXBFN =",I6)') MAXBFN
      WRITE(IOUTVB,
     &'(" Max. no. of shells                   MAXSHL =",I6)') MAXSHL
      WRITE(IOUTVB,
     &'(" Max. no. of total primitives         MAXEXP =",I6)') MAXEXP
      WRITE(IOUTVB,
     &'(" Max. no. of primitives per orbital   MAXPRM =",I6)') MAXPRM
      WRITE(IOUTVB,
     &'(" Max. no. of atoms * no. of orbitals  MAXNAB =",I6)') MAXNAB
      WRITE(IOUTVB,
     &'(" Increase max basis set size by       NEXTRA =",I6)') NEXTRA
      WRITE(IOUTVB,
     &'(" Max. size for Rumer data             MAXST1 =",I6)') MAXST1
      WRITE(IOUTVB,
     &'(" Max. no. of orbitals in group        MAXNOB =",I6)') MAXNOB
      WRITE(IOUTVB,
     &'(" Max. no. of CUBE orbitals            MAXCUB =",I6)') MAXCUB
      WRITE(IOUTVB,
     &'(" Max. no. of groups                   MAXGRP =",I6)') MAXGRP
      WRITE(IOUTVB,
     &'(" BRILLMASK array sizes                MAXBLL =",I6)') MAXBLL
      ENDIF
      IF(NBASIS.GE.MAXBFN) CALL SIZEABT(NBASIS,MAXBFN,"BASIS SIZE  ",
     &  "MAXBFN",IOUTVB,.TRUE.)
      DO I=1, NBASIS
      BONDLAB(I) = '        '
      END DO
C
C     TODO: THIS LOGIC NEED MODIFIED GLOBALY
C
      NMO = (NELE+1)/2
C
C     SET RESTART FLAG
C
      IF(MTHEORY.EQ.1)  IRESTART = -1
      REWIND(IOVBORB,ERR=999)
C
C     CHECK IF PREVIOUS VB RESULTS EXIST OR NOT
C
      CALL GETIOUNIT('IOVBORB ',IOVBORB)
      IF(IRESTART.GE.1) THEN
      REWIND(IOVBORB,ERR=100)
      READ(IOVBORB)
      READ(IOVBORB,ERR=100,END=100)NBASISTEMP,NATOMTEMP
      IF(NBASISTEMP.NE.NBASIS.OR.NATOMTEMP.NE.NATOM) GOTO 100
      GOTO 201
 100  IRESTART=0
      WRITE(IOUTVB,*)'THE RESTART FILE IS WRONG!'
 201  CONTINUE
      END IF
C
C     IRESTART: Flag.
C               = 2: Restart job. Read guess. Integrals and HF can be skiped.
C               = 1: Read orbital guess from a previous VB calculaiton
C               = 0: New calculation (default).
C               =-1: Generate LMO only, then stop
C
C     DO LMO, and Store CHAMAX and MAXCHA in A COMMON BLOCK
C
C
C     READ S and MO'S
C
      NSS = 1
      NVV = NSS + NBASIS*(NBASIS+1)/2
      NFF = NVV + NBASIS*NBASIS
C     NPP = NFF + NBASIS*NBASIS
      NAOST(1) = 1
      DO I=1,NATOM
      NAOST(I+1) = NAOST(I) + NATBAS(I)
      END DO
C
C     INITIALIZE MOL TOPOL
C
      CALL INIMOLTOPOL()
C
C     OPEN VBOLIB FILE
C
      CALL GETIOUNIT('IOTEMP  ',IOTEMP)
      IOLVBO = IOTEMP
C
C     NUMD and NUMF are initiallised earlier for Gaussian version.
C000  NUMD = 1
C000  NUMF = 1
CSMI  NUMD = 1
CSMI  NUMF = 1
CGMS  NUMD = 1
CGMS  NUMF = 1
C     NUMD = 1 (or NUMF = 1) INDICATES CARTESIAN D FUNCTIONS AND IS 
C     THE ONLY CHOICE FOR STAND-ALONE AND GAMESS VERSIONS.
C     NOTE THAT THE USE OF SPHER DIRECTIVE DOES NOT ALTER THIS, AS
C     INTEGRALS OVER CARTESIAN D FUNCTIONS ARE STILL USED.
C
C     NUMD = 0 FOR SPHERICAL HARMONICS IS ONLY POSSIBLE IN GAUSSIAN
C     WHEN INTEGRALS OVER SPHERICAL HARMONICS CAN BE SELECTED.
C     NUMF INDICATES CARTESIAN F, G. H or I FUNCTIONS AND THIS HAS 
C     THE SAME RESTRICTIONS AS NUMD.
C
C     IN THE GAUSSIAN STAND-ALONE VERSION, CARE IS TAKEN TO ALLOW
C     SPHERICAL HARMONIC D AND F (G, H or I) FUNCTIONS SEPARATELY, 
C     ALTHOUGH NORMALLY BOTH NUMD AND NUMF WOULD BE SET TO THE SAME VALUE.
C
C     CHECKING BASIS SET NAME TO SELECT VBOLIB.
C     ALL LIBRARIES ARE CONSTRUCTED FOR CARTESIANS AND MODIFIED FOR
C     SPHERICAL HARMONICS LATER ALONG WITH DIFFERENT ORDER FOR f AND
C     HIGHER IN GAUSSIAN.
      IGMS=1
CGMS  IGMS=2
CGAU  IGMS=2
      IF(IGMS.EQ.2) GOTO 137
C     GET VBOLIB NAME FOR STAND-ALONE VERSION
      IF(BASNAME.EQ.'D95') THEN
        BAS='D95'
        K=3
      ELSE IF(BASNAME.EQ.'MIDIX'.OR.BASNAME.EQ.'MIDI!') THEN
        BAS='MIDIX'
        K=5
      ELSE IF(BASNAME.EQ.'STO-3G'.OR.BASNAME.EQ.'STO-4G'
     &  .OR.BASNAME.EQ.'STO-6G'.OR.BASNAME.EQ.'GENNG') THEN
        BAS='STO-nG'
        K=6
      ELSE IF(BASNAME.EQ.'3-21G') THEN
        BAS='3-21G'
        K=5
      ELSE IF(BASNAME.EQ.'3-21GSTAR' .OR. BASNAME.EQ.'3-21G*') THEN
        BAS='3-21GSTAR'
        K=9
      ELSE IF(BASNAME.EQ.'6-31G') THEN
        BAS='6-31G'
        K=5
      ELSE IF(BASNAME.EQ.'6-31G*'.OR.BASNAME.EQ.'6-31GSTAR') THEN
        BAS='6-31GSTAR'
        K=9
      ELSE IF(BASNAME.EQ.'6-31G2STAR' .OR. BASNAME.EQ.'6-31G**') THEN
        BAS='6-31G2STAR'
        K=10
      ELSE IF(BASNAME.EQ.'6-31PGSTAR' .OR. BASNAME.EQ.'6-31+G*') THEN
        BAS='6-31PGSTAR'
        K=10
      ELSE IF(BASNAME.EQ.'6-31PPG2STAR' .OR. BASNAME.EQ.'6-31++G**')
     &  THEN
        BAS='6-31PPG2STAR'
        K=12
      ELSE IF(BASNAME.EQ.'TZVP') THEN
        BAS='TZVP'
        K=4
      ELSE IF(BASNAME.EQ.'CC-PVDZ'.OR.BASNAME.EQ.'CCPVDZ') THEN
        BAS='CCPVDZ'
        K=6
      ELSE IF(BASNAME.EQ.'AUG-CC-PVDZ') THEN
        BAS='AUG-CC-PVDZ'
        K=11
      ELSE
        WRITE(IOUTVB,101) BASNAME
        WRITE(IOUTVB,102)
        IOLVBO = 0
      END IF
 137  CONTINUE
C     GET VBOLIB FOR GAMESS
CGMS  BAS(1:20)=BASNAME(1:20)
CGMS  CALL GETVBOLIB(K,BAS,IOLVBO,MAXATNO)
C     GET VBOLIB FOR GAUSSIAN
CGAU  BAS(1:20)=BASNAME(1:20)
CGAU  CALL GETVBOLIB(K,BAS,IOLVBO,MAXATNO)
C
      IF(IOLVBO.NE.0) THEN
C       Add VBPATH
        CALL PATHST(VBTEMP,VBPATH,'/VBOLIB/VBOLIB  ',BAS,K)
        WRITE(IOUTVB,104) VBTEMP
CGMS    IF(BAS.EQ.'D95') WRITE(IOUTVB,
CGMS &   '(" IS BASIS D95 CORRECTLY DEFINED IN $DATA GROUP?")')
        OPEN(IOLVBO,FILE=VBTEMP,STATUS='OLD',ERR=135)
C
C       MODIFY VBOLIB FOR GAMESS
CGMS    CALL LOCTOR(IOENGI,'$LSTVBOLIB',10,IOK,0)
CGMS    FILENAME=FSTR(1:LENFIL)//'.TEMP-MOD'
CGMS    CALL ADDVBOLIB(IOLVBO,98,FILENAME,BAS,MAXATNO,IOK)
C
C       MODIFY VBOLIB FOR GAUSSIAN
CGAU    CALL LOCTOR(IOENGI,'$LSTVBOLIB',10,IOK,0)
CGAU    FILENAME=FSTR(1:LENFIL)//'.TEMP-ADD'
CGAU    CALL ADDVBOLIB(IOLVBO,98,FILENAME,MAXATNO,IOK)
CGAU    FILENAME=FSTR(1:LENFIL)//'.TEMP-MOD'
CGAU    CALL MODVBOLIB(IOLVBO,98,FILENAME,IOK)
C
        GOTO 136
 135    IOLVBO = 0
        WRITE(IOUTVB,101) BAS
        WRITE(IOUTVB,102)
      END IF
 136  CONTINUE
 101  FORMAT(/,' VBO LIB NOT AVAILABLE FOR BASIS SET ',A20)
 102  FORMAT(' ALL FUNCTIONALITY RELATED TO LIB VBO WILL BE DISABLED')
 104  FORMAT(/,' VBO LIB IS: ',A80)
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL GETIOUNIT('IOHFORB ',IOHFORB)
      CALL READ1E(IAO1E,W(NSS),W(NVV),NBASIS)
      CALL RDMORB(IOHFORB,W(NVV),EIG,NBASIS)
      NOCCORB = (NELE-NSPIN)/2 + NSPIN
      NOCC5V = NOCCORB + 5
      IF(NOCC5V .GT. NBASIS) NOCC5V = NBASIS
CGAU  IF(LPTALL.EQ.1)
CGAU &  CALL MPRINT(W(NVV),EIG,NBASIS,NOCC5V,4,BFLABE,DUMMY)
CGMS  IF (EXETYP.EQ.CHECK) LPTALL = 0
CGMS  IF(LPTALL.EQ.1.AND.IPNT.LE.1)
CGMS &  CALL MPRINT(W(NVV),EIG,NBASIS,NOCC5V,4,BFLABE,DUMMY)
CGMS  CALL FLSHBF(IOUTVB)
C
      NCORE   = NOCCORB
      LPTALLX = LPTALL
      IF(IRESTART.LT.1) LPTALLX = 0
      CALL CHALMO(NBASIS,NCORE,NATOM,NATBAS,BFLABE,W(NVV),W(NSS),PGM,
     &            W(NFF),EIG,CHAMAX,MAXCHA,CSPLIT,LPTALLX)
C
C     CHECK FOR LMOLIB GEN
      CALL LMOLGN(NATOM,NBASIS,NATNUM,XYZ,NATBAS,BFLABE,W(NVV),
     &            IOENGI)
      DO  I = 1, NCORE
      ENGLMO(I) = EIG(I)
      END DO
      IF(IRESTART.LT.1) THEN
      CALL CANLMO(W(NVV),W(NSS),NCORE,NBASIS,CHAMAX,MAXCHA,W(NFF),
     &            NATBAS,CSPLIT,BFLABE,NAOST,IOLVBO,IOENGI,LPTALL)
      END IF
C
C     COPY ALL LMOs to STORAGE
C
      DO I=1, NBASIS*NCORE
      VLMO(I) = W(NVV-1+I)
      END DO
C
C     READ MOs and copy MOs to VMO
C     4321
      CALL RDMORB(IOHFORB,VMO,EIG,NBASIS)
C

C     NAT2=NATOM*(NATOM+1)/2
C     NAT22=NAT2*2
C     IF(3*NATOM*(NATOM+1)/2.GT.15000) THEN
C        WRITE(IOUTVB,*)"MORE THAN 99 ATOMS"
C     WRITE(IOUTVB,*) "NATOM & NBASIS",NATOM,NBASIS
C     IF(NATOM*NBASIS.GT.100000) THEN
C        WRITE(IOUTVB,*)"NATOM*NBASIS MORE THAN 100000"
C        CALL ABORT0('INPUTVB02 ')
C     END IF
      NNAB = NATOM*NBASIS
      IF(NNAB.GE.MAXNAB) CALL SIZEABT(NNAB,MAXNAB,"NATOM*NBASIS",
     &  "MAXNAB",IOUTVB,.TRUE.)
CGMS  IF(MTHEORY.EQ.1) RETURN
C
C     SET DEFAULT GENCTL ACCCORDING TO THE KEY WORDS
C
      IF(MELE(2).GT.NELE) THEN
         WRITE(IOUTVB,*)"THE VB GROUP HAS ",MELE(2)," ELECTRON(S)"
         WRITE(IOUTVB,*)"AND THE MOLECULE HAS ONLY ",NELE," ELECTRON(S)"
         CALL ABORT0('INPUTVB03 ')
      END IF
      IF(1.LT.MTHEORY.AND.MTHEORY.LT.5) THEN
        IF(MELE(2).EQ.NELE) THEN
        NSUB = 1
        MELE(1)    = MELE(2)
        MLORBIT(1) = MLORBIT(2)
        METHOD(1) = METHOD(2)
        ELSE
        NSUB = 2
        MELE(1)   = NELE - MELE(2)
        MLORBIT(1) = MELE(1)/2
        METHOD(1) = 1
        END IF
      END IF
      IF(MTHEORY.GE.7) THEN
        NSUB = 1
      ENDIF
C
C     DOT NOTATION
C
      IF(MTHEORY.EQ.6) THEN
        METOTAL = 0
        DO I=2, NGPF
        METOTAL = METOTAL + MELE(I)
        END DO
        IF(METOTAL.EQ.NELE) THEN
C       HARTREE-FOCK GROUP DOES NOT EXIST
        NSUB = NGPF - 1
          DO I=1, NGPF - 1
          MELE(I)   = MELE(I+1)
          MLORBIT(I) = MLORBIT(I+1)
          METHOD(I) = METHOD(I+1)
          END DO
        ELSE
        NSUB = NGPF
        MELE(1)   = NELE-METOTAL
        MLORBIT(1) = MELE(1)/2
        METHOD(1) = 1
        END IF
      END IF
C
      IF(MTHEORY.EQ.5) THEN
      NSUB = NGPF
C
C     THE DEFAULT WILL BE A NGPF-1 GVB PAIRS
C
        DO I=2,NSUB
        MELE(I)=2
        METHOD(I)=2
        END DO
        MELE(1)=NELE-2*(NSUB-1)
        METHOD(1) =1
        MLORBIT(1) = MELE(1)/2
      END IF
      IF(MTHEORY.NE.5) GOTO 110
C
C     READ GENERAL CONTROL
C
      CALL LOCTOR(IOENGI,'$GENCTL',7,IOK,1)
      IF(IOK.EQ.0) THEN
      WRITE(IOUTVB,*)'WARNING: GENCTL IS MISSING, GVB IS ASSUMED'
      ELSE
      READ(IOENGI,*,ERR=9992)(MELE(I),I=1,NSUB)
      READ(IOENGI,*,ERR=9993)(METHOD(I),I=1,NSUB)
        DO I=1, NSUB
        IF(METHOD(I).EQ.1) MLORBIT(I) = MELE(I)/2
        END DO
      END IF
 110  CONTINUE
C
C     CHECK FOR SPHERICAL HARMONIC OPTION
C
      IF(KEY(15).EQ.1) THEN
        CALL COUNTNSP(NBASIS,BFLABE,NSHBAS)
        IF(NSHBAS.GT.0) THEN
           NSUB = NSUB+1
           METHOD(NSUB) =  99
           MLORBIT(NSUB) = NSHBAS
           MNORBIT(NSUB) = NSHBAS
           MELE(NSUB) = 0
        END IF
      END IF
C
C     SET DEFAULT SPIN FOR EACH GROUP ACCORDING TO ITS NUMBER OF ELECTRONS
C
      DO I=1,NSUB
        MSPIN(I) = 0
      END DO
      IF(MELE(NSUB).GT.0) MSPIN(NSUB)=NSPIN
      IF(MELE(NSUB).EQ.0) MSPIN(NSUB-1)=NSPIN
C
C     SET THE DEFAULT LMO GROUP ASSIGNMENT ACCORDING TO MELE(I) AND MSPIN(I)
C
      DO I=1, NCORE
      LMOGRP(I) = 1
      END DO
      DO I=NCORE+1,NBASIS
      LMOGRP(I)=0
      END DO
      NTMP=NCORE
      DO I=NSUB,1,-1
        DO J=1, (MELE(I)+MSPIN(I))/2
        IF(NTMP.LE.0) CALL ABORT0('INPUTVBTMP')
        LMOGRP(NTMP)=I
        NTMP=NTMP-1
        END DO
      END DO
C
C     POSSIBLE MODIFICATION OF LMO GROUP ASSIGNMENT
C     FORMAT: BOND ATOM_I-ATOM_J (TYPE: SIGMA/PI(1/2)) BELONGS TO GROUP K
C     SHORT-HAND: BOND(I,J,K) (TYPE)
C                 TYPE=0 (SIGMA)
C                      1 (PI-1)
C                      2 (PI-2)
C     OR LMO(X) BELONGS TO GROUP K: SHORT-HAND LMO(X,K)
C
C     LOOK FOR $LMOGROUP
C
      CALL LOCTOR(IOENGI,'$LMOGROUP',9,IOK,0)
      IF(IOK.EQ.1) THEN
 120    READ(IOENGI,'(A80)',ERR=125,END=125)BUFF
        CALL CONVCASE(BUFF,80,1)
        ICURSOR=1
        LENW=0
        LENBUF=80
        I=0
        J=0
        K=0
        ITYPE=0
        WORD = ' '
        CALL READWDM(BUFF,WORD,LENW,ICURSOR,LENBUF)
        IF(WORD.EQ.'BOND') THEN
          CALL READNUM(BUFF,I,LENW,ICURSOR,LENBUF)
          CALL READNUM(BUFF,J,LENW,ICURSOR,LENBUF)
          CALL READNUM(BUFF,K,LENW,ICURSOR,LENBUF)
          CALL READNUM(BUFF,ITYPE,LENW,ICURSOR,LENBUF)
          IF(I.EQ.0.OR.J.EQ.0.OR.K.EQ.0) CALL ABORT0('INPUTVBIJK')
          IBTYPE = ITYPE + 1
          CALL LOOKLMODX(I,J,IBTYPE,LMOLAB,NMO,IORBINDEX)
          IF(IORBINDEX.GT.0) THEN
          LMOGRP(IORBINDEX)=K
          ELSE
          WRITE(IOUTVB,*)'Invalid bond specification, discard it'
          END IF
        GOTO 120
        ELSE IF(WORD.EQ.'LMO') THEN
C
C     MAYBE SOME VIRTUAL ORBITALS ARE INVOLVED
C
          CALL READNUM(BUFF,I,LENW,ICURSOR,LENBUF)
          CALL READNUM(BUFF,K,LENW,ICURSOR,LENBUF)
          IF(I.EQ.0.OR.K.EQ.0) CALL ABORT0('INPUTVBIK ')
          LMOGRP(I)=K
        GOTO 120
        ELSE
        GOTO 125
        END IF
      END IF
 125  CONTINUE
C
C     LOOK FOR VALENCE BOND GROUP ASSIGNMENT
C
C     SEARCH FOR $VBGROUPASSIGNMENT OR $VBGA
C
C     IF THE ONE OF THE FLAG EXISTS, ALL PREVIOUS SETTING WILL BE OVER TAKEN
C
      CALL VBGRPA(IOENGI,LMOGRP,LMOLAB,NMO)
C
C     LMOGROUPMODIFY OVER WRITE ALL PREVIOUS SETTING
C
      CALL LOCTOR(IOENGI,'$LMOGRPMODIFY',13,IOK,0)
      IF(IOK.EQ.1) THEN
        READ(IOENGI,*)LMOMD
        WRITE(IOUTVB,*)'MODIFICATION OF LMO GROUP ASSIGNMENT:'
        DO JJ = 1, LMOMD
        READ(IOENGI,*,ERR=9994)IORBINDEX, LMOGRP(IORBINDEX)
C       WRITE(IOUTVB,106) iorbindex, LMOGRP(iorbindex)
        WRITE(IOUTVB,106) IORBINDEX, LMOGRP(IORBINDEX)
 106  FORMAT(' LMO# =',I2,' GROUP# =',I2)
        END DO
      END IF
C     LOOK FOR $LMOGROUP
C
C     SET THE DEFAULT MLORBIT(K) ACCORDING TO LMOs of GROUP K
C
C
      DO K=1,NSUB
      MELEK=0
      MORBK=0
      DO I=1,NCORE
        IF(LMOGRP(I).EQ.K) THEN
        ICOVA=0
        RAT1=DABS(CHAMAX(2,I)/CHAMAX(1,I))
        IF(RAT1.GT.CSPLIT) ICOVA=1
        MELEK=MELEK+2
        MORBK=MORBK+1
        IF(METHOD(K).GT.1.AND.ICOVA.EQ.1) MORBK=MORBK+1
        END IF
      END DO
C
C     ONLY MODIFY THE DEFAULT NUMBER OF ORBITALS FOR VB(N) GROUP
C
      IF(METHOD(K).EQ.2.AND.MTHEORY.LT.7) THEN
        MLORBIT(K)=MORBK
      ENDIF
      IF(MELEK.NE.MELE(K)) WRITE(IOUTVB,*)'WARNING: MELEK != MELE(K)'
      END DO
C
C
C     POSSIBLE MODIFICATION OF MLORBIT(K) AND SPLIT FLAGS
C
      CALL LOCTOR(IOENGI,'$GRPDIM',7,IOK,0)
      NSUBX = NSUB
      IF(MELE(NSUB).EQ.0) NSUBX = NSUB - 1
      IF(IOK.EQ.1) THEN
        READ(IOENGI,*,ERR=9995)(MLORBIT(K),K=1,NSUBX)
      END IF
C
C     SET MLORBIT FOR CASVB(m,n) WITH EXPLICIT NUMBER OF ORBITALS
C     GRPDIM WILL BE IGNORED.
C
C     IF(MTHEORY.EQ.4) THEN
C       NSUB = 2
C       IF(MELECTRONS.EQ.NELE) NSUB=1
C       IF(NSUB.EQ.2) THEN
C       MLORBIT(2) = NORBITALS
C       MLORBIT(1) = MELE(1)/2
C       ELSE
C       MLORBIT(1) = NORBITALS
C       END IF
C     END IF
 999  CONTINUE
C
C     POSSIBLE MODIFICATION OF THE DEFAULT VALUE OF IMACRO
C
      CALL LOCTOR(IOENGI,'$MACROITER',10,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*,ERR=9996)IMACRO
      END IF
C
C     READ OPTIONS IN GENERAL CONTROL
C
      CALL LOCTOR(IOENGI,'$FROZEN',7,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)LFROZN
      CALL LOCTOR(IOENGI,'$CIONLY',7,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)LCIONLY
      CALL LOCTOR(IOENGI,'$NOBIAS',7,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)NOBIAS
      CALL LOCTOR(IOENGI,'$ROTATION',9,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*,ERR=9997)MROT
      CALL LOCTOR(IOENGI,'$ECONV',6,IOK,0)
C     IF(IOK.EQ.1) THEN
      IF(IOK.EQ.1) READ(IOENGI,*,ERR=9998) NEPS
C       WRITE(IOUTVB,105) NEPS
C105  FORMAT(/,' MACROITERATION CONVERGENCE TOLERANCE',
C    &   /,' ALTERED TO 10.00**(-',I1,').',/)
C     ENDIF
      CALL LOCTOR(IOENGI,'$HYBRID',7,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)LHYBRD
      CALL LOCTOR(IOENGI,'$PRINTALL',9,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)LPTALL
C
C     SET DEFAULT MNORBIT, WHICH IS EQUAL TO MLORBIT
C     FOR BOVB TYPE CALCULATION OR SOME SPECIAL CASES,
C     MNORBIT CAN BE DIFFERENT FROM MLORBIT
C
      DO I=1, NSUB
      MNORBIT(I) = MLORBIT(I)
      END DO
C
C
      NORBT=0
      DO I=1,NSUB
      NORBT=NORBT+MLORBIT(I)
      END DO
      NVIRX=NBASIS-NORBT
      DO I=1,NSUB*(NSUB+1)/2
      NOTROT(I)=0
      END DO
      DO I=1,NSUB
C
C     TURN OFF ROTATION PAIR OF CORE AND VIRTUAL GROUPS, ASSUME
C     THAT CHFSCF IS CALLED FOR CORE ORBITALS OPTIMIZATION WITHIN THE
C     OPTIMIZATION WINDOW INCLUDING THE VIRTUAL ORBITALS
C
      IF(METHOD(I).NE.1) THEN
      MWIN(I)=MLORBIT(I)
      ELSE
      IJ=NSUB*(NSUB-1)/2+I
C
C     TODO: NEED TO BE RESET
C
      MWIN(I)=MLORBIT(I)+NVIRX
      NOTROT(IJ)=1
      END IF
      END DO
C
C     IF(FROZEN CORE IS TRUE, TURN OFF ROTATION PAIR OF CORE AND ANY OTHER
C     GROUP
C
      IJ=0
      DO I=1,NSUB
      DO J=1,I-1
      IJ=IJ+1
      IF((METHOD(I).EQ.1.OR.METHOD(J).EQ.1).AND.LFROZN.EQ.1)
     & NOTROT(IJ)=1
      END DO
      END DO
C
C     TURN OFF FOR PAIRS WITH ZERO ELECTRON GROUP
C
      IJ=0
      DO I=1,NSUB
      DO J=1,I-1
      IJ=IJ+1
      IF(MELE(I).EQ.0.OR.MELE(J).EQ.0)
     & NOTROT(IJ)=1
      IF(MELE(I).EQ.0) THEN
          NOTROT(IJ00(I,NSUB))=1
      END IF
      END DO
      END DO
C
C     TURN OFF ROTATIONS BETWEEN SUBUNITS SPECIFIED IN NOTROT
C
      CALL LOCTOR(IOENGI,'$NOTROT',7,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*,ERR=9999)NROTPAIR
       DO I=1,NROTPAIR
       READ(IOENGI,*,ERR=9999)NR1,NR2
        IF(NR1.NE.NR2) THEN
          NR3=NR2
          IF(NR1.GT.NR2) THEN
          NR3=NR1
          NR1=NR2
          END IF
          NOTROT(IJ00(NR1,NR3-1))=1
        END IF
       END DO
      END IF
C
C     NEXTRA: RESERVED EXTRA SPACE FOR REDUNDANT ORBITALS IN BOVB TYPE
C             CALCULATION - SET AS A PARAMETER ABOVE
C
C     IF MROT = 0, and LCIONLY = 1, SET IMACRO = 1
C
C     IF(MROT.EQ.0.AND.LCIONLY.EQ.1) IMACRO = 1
C     ERROR CHECKING
C
      IF(NSPIN.EQ.0.AND.(NELE/2)*2.NE.NELE) THEN
        WRITE(IOUTVB,*)"THE NUMBER OF ELECTRONS AND THE MULTIPLICITY IS"
        WRITE(IOUTVB,*)"INCONSISTANT"
        CALL ABORT0('INPUTVB04 ')
      END IF
C     SET DEFAULT VALUES FOR NOCC AND IBASIS
      NOB=0
      NST=0
      DO K=1,NSUB
      NST=NST+MSPIN(K)
      IF(METHOD(K).EQ.1.AND.MELE(K).NE.MLORBIT(K)*2) THEN
      WRITE(IOUTVB,*)'K,MELE(K),MLORBIT(K) =',K,MELE(K),MLORBIT(K)
C     CALL ABORT0('INPUTVB05 ')
      END IF
      IF(MELE(K).GT.MLORBIT(K)*2) THEN
      WRITE(IOUTVB,*)
     &       "THE NUMBER OF ELECTRONS IS MORE THAN THE DOUBLE OF "
      WRITE(IOUTVB,*)"THE NUMBER OF ORBITALS IN THIS GROUP"
      WRITE(IOUTVB,*)"K,MELE(K),MLORBIT(K) = ",K,MELE(K),MLORBIT(K)
      CALL ABORT0('INPUTVB06 ')
      END IF
      DO I=1,MLORBIT(K)
      NOB=NOB+1
      IF(METHOD(K).EQ.1) THEN
      NOCC(NOB)=2
      ELSE
      NOCC(NOB)=1
      END IF
      IBASIS(NOB)=K
      END DO
      END DO
      IF(NST.NE.NSPIN) CALL ABORT0('INPUTVB07 ')
      DO I=NOB+1,NBASIS+NEXTRA
      IBASIS(I)=0
      NOCC(I)=0
      END DO
C     NBA2=NBASIS*(NBASIS+1)/2
C
C     SCANE VBORB INPUT
C
      CALL SCANVBO(NSUB,MLORBIT)
C
C     Setup addresses for density matrices in local nonorthogonal basis sets
C     and vise verse
C
C     Note:  For core electrons, special treatment can be used so that both
C            1D and 2D are not necessary
C            This will be implemented later
C
C
C     Setup addresses for local transformation matrices from nonorthogonal to
C     orthogonal orbitals and vise verse
C
C     2D for Core electron group is skipped. March 26,04/JL
C
      NAOBAS    = 1
      LAOBAS    = NAOBAS + (NEXTRA+NBASIS)*NBASIS
      NOCBAS    = LAOBAS + NBASIS*NBASIS
      NB1ADD(1) = 1
      NB2ADD(1) = 1
      N1DADD(1) = 1
      DO 200 I=1,NSUB
      NB1ADD(I+1) = NB1ADD(I)+MLORBIT(I)
      NB2ADD(I+1) = NB2ADD(I)+MLORBIT(I)*MLORBIT(I)
 200  CONTINUE
      DO 300 I=1,NSUB
      MSQ         = MLORBIT(I)*(MLORBIT(I)+1)/2
      N1DADD(I+1) = N1DADD(I) + MSQ
 300  CONTINUE
      N2DADD(1)   = 1
      DO 400 I=1,NSUB
      IF(METHOD(I).GT.1) THEN
      MSQ         = MLORBIT(I)*(MLORBIT(I)+1)/2
      N2DADD(I+1) = N2DADD(I) + MSQ*(MSQ+1)/2
      ELSE
      N2DADD(I+1) = N2DADD(I) + 1
      END IF
 400  CONTINUE
      LOCBAS      = NOCBAS + NB2ADD(NSUB+1)-1
      ND1STA      = LOCBAS + NB2ADD(NSUB+1)-1
      ND2STA      = ND1STA + N1DADD(NSUB+1)-1
      LD1STA      = ND2STA + N2DADD(NSUB+1)-1
      LD2STA      = LD1STA + N1DADD(NSUB+1)-1
      LGDMP       = LD2STA + N2DADD(NSUB+1)-1
C     GENERATE INITIAL GUESS OF ORBITALS
      MSIZE1=MSIZE-ND2STA
      IF(MSIZE1.LE.0) THEN
CGMS     WRITE(IOUTVB,9) ND2STA
         CALL ABORT0('INPUTVB08 ')
      ENDIF
      CALL IGUESS(W(NAOBAS),W(ND1STA),W(ND2STA),LMOGRP,MSIZE1,IOLVBO)
C
      IF(MTHEORY.EQ.1) GOTO 998
C     WRITE OUT GENERAL CONTROL
C
      WRITE(IOUTVB,1000)NSUB,IMACRO,NEPS,IRESTART
      WRITE(IOUTVB,1005)(I,I=1,NSUB)
      WRITE(IOUTVB,1010)(MELE(I),I=1,NSUB)
      WRITE(IOUTVB,1020)(MSPIN(I),I=1,NSUB)
      WRITE(IOUTVB,1030)(MLORBIT(I),I=1,NSUB)
      WRITE(IOUTVB,1040)(METHOD(I),I=1,NSUB)
CGMS  CALL FLSHBF(IOUTVB)
 1000 FORMAT(/'      GENERAL CONTROLS ($GENCTL)'
     &        /1X,36(1H=)/' Number of electron groups       =',I5
     &                   /' Maximum macro-iterations        =',I5
     &                   /' Energy threshold           = 10**(-',I2,')',
     &                   /' Restart calculation(0/1/2)      =',I5)
 1005 FORMAT(' Group#                  ',I4,20I3)
 1010 FORMAT(' Num. of electrons       ',I4,20I3)
 1020 FORMAT(' Num. of spins           ',I4,20I3)
 1030 FORMAT(' Num. of orbitals        ',I4,20I3)
 1040 FORMAT(' Method#                 ',I4,20I3)
CGMS9 FORMAT(' INSUFFICIENT MEMORY - USE $MEMORY EXPLICITLY',
CGMS 1' TO SELECT MORE THAN',I12,' WORDS.')
C
 998  IF(IOLVBO.GT.0) CLOSE(IOLVBO)
      RETURN
C     ERROR MESSAGES
C
 9991 WRITE(IOUTVB,*)"ERROR IN $CSPLITRATIO"
      CALL ABRTVB
 9992 WRITE(IOUTVB,*)"ERROR IN $GENCTL: MELE(I)"
      CALL ABRTVB
 9993 WRITE(IOUTVB,*)"ERROR IN $GENCTL: METHOD(I)"
      CALL ABRTVB
 9994 WRITE(IOUTVB,*)"ERROR IN $LMOGRPMODIFY"
      CALL ABRTVB
 9995 WRITE(IOUTVB,*)"ERROR IN $GRPDIM"
      CALL ABRTVB
 9996 WRITE(IOUTVB,*)"ERROR IN $MACROITER"
      CALL ABRTVB
 9997 WRITE(IOUTVB,*)"ERROR IN $ROTATION"
      CALL ABRTVB
 9998 WRITE(IOUTVB,*)"ERROR IN $ECONV"
      CALL ABRTVB
 9999 WRITE(IOUTVB,*)"ERROR IN $NOTROT"
      CALL ABRTVB
      END
      SUBROUTINE LOOKLMODX(NATOMI,NATOMJ,IBTYPE,LMOLAB,NLMO,IORBINDEX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION LMOLAB(2,NLMO)
      IORBINDEX = 0
      IF(NATOMI.GE.NATOMJ) THEN
      NAIJ = NATOMI*(NATOMI-1)/2 + NATOMJ
      ELSE
      NAIJ = NATOMJ*(NATOMJ-1)/2 + NATOMI
      END IF
      DO I=1, NLMO
      IF(LMOLAB(1,I).EQ.NAIJ.AND.LMOLAB(2,I).EQ.IBTYPE) THEN
      IORBINDEX = I
      RETURN
      END IF
      END DO
      RETURN
      END
      SUBROUTINE VBGRPA(IOENGI,LMOGRP,LMOLAB,NLMO)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 BUFF
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION LMOGRP(*),LMOLAB(2,*),NVBOCODE(20)
      CALL LOCTOR(IOENGI,'$VBGROUPASSIGNMENT',18,IOK,0)
      IF(IOK.EQ.0) THEN
      CALL LOCTOR(IOENGI,'$VBGA',5,IOK,0)
      END IF
      IF(IOK.EQ.1) THEN
C
C     IF VBGA IS DETECTED, ALL PREVIOUS SETTING WILL BE OVER TAKEN
C
      DO I=1, NLMO
      LMOGRP(I) = 1
      END DO
C
 120    READ(IOENGI,'(A80)',ERR=200,END=200)BUFF
        CALL CONVCASE(BUFF,80,1)
        ICURSOR=1
        LSTRING=80
        CALL VBGAPARSER(BUFF,ICURSOR,LSTRING,NVBOCODE,IERR)
        IF(IERR.EQ.1) GOTO 200
        NATOM1 = NVBOCODE(1)
        NATOM2 = NVBOCODE(2)
        IBTYPE = NVBOCODE(3)
        IBORDE = NVBOCODE(4)
        IGROUP = NVBOCODE(5)
C
C       LP
C
        IF(IBTYPE.EQ.3) THEN
        NATOM2 = NATOM1
        CALL LOOKLMODX(NATOM1,NATOM2,IBORDE,LMOLAB,NLMO,IORBINDEX)
          IF(IORBINDEX.GT.0) THEN
            LMOGRP(IORBINDEX) = IGROUP
          ELSE
            WRITE(IOUTVB,*)'!!! NO LP IS FOUND ON THIS ATOM !!!'
          END IF
C
C       SINGLE BOND
C
        ELSE IF(IBTYPE.EQ.4) THEN
        CALL LOOKLMODX(NATOM1,NATOM2,IBORDE,LMOLAB,NLMO,IORBINDEX)
          IF(IORBINDEX.GT.0) THEN
            LMOGRP(IORBINDEX) = IGROUP
          ELSE
            WRITE(IOUTVB,*)'!!! NO BOND FOUND ON THE ATOM PAIR !!!'
          END IF
C
C       DOUBLE BOND
C
        ELSE IF(IBTYPE.EQ.5) THEN
        IBORDE = 1
        CALL LOOKLMODX(NATOM1,NATOM2,IBORDE,LMOLAB,NLMO,IORBINDEX)
          IF(IORBINDEX.GT.0) THEN
            LMOGRP(IORBINDEX) = IGROUP
          ELSE
            WRITE(IOUTVB,*)
     &       '!!! NO SIGMA BOND FOUND ON THE ATOM PAIR !!!'
          END IF
        IBORDE = 2
        CALL LOOKLMODX(NATOM1,NATOM2,IBORDE,LMOLAB,NLMO,IORBINDEX)
          IF(IORBINDEX.GT.0) THEN
            LMOGRP(IORBINDEX) = IGROUP
          ELSE
            WRITE(IOUTVB,*)'!!! NO PI BOND FOUND ON THE ATOM PAIR !!!'
          END IF
C
C       TRIPLE BOND
C
        ELSE IF(IBTYPE.EQ.6) THEN
        IBORDE = 1
        CALL LOOKLMODX(NATOM1,NATOM2,IBORDE,LMOLAB,NLMO,IORBINDEX)
          IF(IORBINDEX.GT.0) THEN
            LMOGRP(IORBINDEX) = IGROUP
          ELSE
            WRITE(IOUTVB,*)'!!! NO SIGMA FOUND ON THE ATOM PAIR !!!'
          END IF
        IBORDE = 2
        CALL LOOKLMODX(NATOM1,NATOM2,IBORDE,LMOLAB,NLMO,IORBINDEX)
          IF(IORBINDEX.GT.0) THEN
            LMOGRP(IORBINDEX) = IGROUP
          ELSE
            WRITE(IOUTVB,*)
     &       '!!! NO FIRST PI BOND FOUND ON THE ATOM PAIR !!!'
          END IF
        IBORDE = 3
        CALL LOOKLMODX(NATOM1,NATOM2,IBORDE,LMOLAB,NLMO,IORBINDEX)
          IF(IORBINDEX.GT.0) THEN
            LMOGRP(IORBINDEX) = IGROUP
          ELSE
            WRITE(IOUTVB,*)
     &       '!!! NO SECOND PI BOND FOUND ON THE ATOM PAIR !!!'
          END IF
        LMOGRP(IORBINDEX) = IGROUP
        ELSE IF(IBTYPE.EQ.7) THEN
        CALL LOOKLMODX(0,0,IBORDE,LMOLAB,NLMO,IORBINDEX)
          IF(IORBINDEX.GT.0) THEN
            LMOGRP(IORBINDEX) = IGROUP
          ELSE
            WRITE(IOUTVB,*)'!!! NO MC BOND FOUND !!!'
          END IF
        LMOGRP(IORBINDEX) = IGROUP
C
C       ERROR
C
        ELSE
        WRITE(IOUTVB,*)"ERROR IN VB GROUP ASSIGNMENT"
        CALL ABORT0('VBGRPA01  ')
        END IF
        IF(IERR.EQ.0) GOTO 120
      END IF
 200  CONTINUE
      RETURN
      END
      SUBROUTINE VBGAPARSER(BUFF,ICURSOR,LSTRING,NVBOCODE,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*1 BUFF(*)
      DIMENSION NVBOCODE(*)
      CALL VBOCRD(BUFF,ICURSOR,LSTRING,NVBOCODE,IERR)
      IF(IERR.EQ.1) RETURN
      DO I=ICURSOR, LSTRING
      IF(BUFF(I).EQ.'='.AND.BUFF(I+1).EQ.'>') THEN
      ICURSOR = I + 2
      GOTO 100
      END IF
      END DO
 100  CONTINUE
      CALL RNUMRD(BUFF,RNUMBER,ICURSOR,LSTRING,INTCODE,IERR)
      IF (IERR.EQ.1.OR.INTCODE.NE.1) THEN
      IERR = 1
      RETURN
      END IF
      NVBOCODE(5) = INT(RNUMBER + 1.0D-6)
      RETURN
      END
      SUBROUTINE INIGDM(NBASIS,NSUB,MLORBIT,ISPLIT,NGP,NATOM)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Initialize 1E density matrix.
C     Note:
C
C     History:
C               First created in July, 1998.
C               Fixed a bug for setting default spliting flags for groups with
C               odd number of electrons. Split higher energy bonding orbitals
C               first. August, 2003.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION MLORBIT(*),ISPLIT(*),NGP(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     NBA2=NBASIS*(NBASIS+1)/2
C
C     MLORBIT(K): NUMBER OF ORBITALS FOR GROUP K
C     MELE(K):   NUMBER OF ELECTRONS IN GROUP K
C
C     SET DEFAULT GROUP # AND SPLIT SWITCHES FOR LMO
C
C     IN A GROUP, THE BONDING LMOs SHOULD SPLIT FIRST. THEN THE HIGHER
C     ENERGY ONES ARE SPLIT FIRST
C
      NLMO=0
      DO 100 K=1,NSUB
C
C     CHECK HOW MANY ORBITALS ARE ASSIGNED TO SUB GROUP K
C
         NGPCOUNT = 0
         DO L=1,NBASIS
         IF(NGP(L).EQ.K)  NGPCOUNT=NGPCOUNT+1
         END DO
      NOB   =MLORBIT(K)
C     NUNSPL=MELE(K)-NOB
      NUNSPL=2*NGPCOUNT-NOB
      NCT=0
      DO 100 L=1,NBASIS
      IF(NGP(L).EQ.K) THEN
      NLMO=NLMO+1
      NCT=NCT+1
      ISPLIT(L)=0
      IF(NCT.GT.NUNSPL.AND.NATOM.GT.1) ISPLIT(L)=1
      END IF
  100 CONTINUE
C     LMOGRP=0
C
C     Modify SPLITING FLAGS if necessary
C
C     CALL LOCTOR(IOENGI,'$LMOSPLIT',9,IOK,0)
C     IF(IOK.EQ.1) THEN
C     READ(5,*)LMOSPLIT
C     READ(5,*)(MODIORB,ISPLIT(MODIORB),K=1,LMOSPLIT)
C     END IF
      LMO=NLMO
C     IF(LMOGRP.GT.LMO) LMO=LMOGRP
      KS=1
      NGROUP=(LMO+19)/20
      WRITE(IOUTVB,900)
      DO I=1,NGROUP
      KT=KS+19
      IF(KT.GT.LMO) KT=LMO
      WRITE(IOUTVB,1000)(K,K=KS,KT)
      WRITE(IOUTVB,1100)(NGP(K),K=KS,KT)
      WRITE(IOUTVB,1200)(ISPLIT(K),K=KS,KT)
      KS=KS+20
      END DO
      WRITE(IOUTVB,*)
  900 FORMAT(/' PARTITIONING OF LMOs INTO GROUPS ($LMOGRP)'/
     & 1X,71(1H=))
 1000 FORMAT( ' LMO#   ',20I3)
 1100 FORMAT( ' Group# ',20I3)
 1200 FORMAT( ' Split  ',20I3/)
      RETURN
      END
      SUBROUTINE ININDM(NSUB,MELE,MLORBIT,DM1NON)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION MELE(*),MLORBIT(*),DM1NON(*)
C
C     ASSUME ORBITALS ARE NORMALIZED
C
      NODADD=0
      DO K=1,NSUB
      KSQ=MLORBIT(K)*(MLORBIT(K)+1)/2
        DO L=1,KSQ
        DM1NON(NODADD+L)=0.0D0
        END DO
        OCC=DFLOAT(MELE(K))/MLORBIT(K)
        DO L=1,MLORBIT(K)
        LL=L*(L+1)/2
        DM1NON(NODADD+LL)=OCC
        END DO
      NODADD=NODADD+KSQ
      END DO
      RETURN
      END
      SUBROUTINE VBOSYM(NBASIS,BASIS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION BASIS(NBASIS,*),NP(1000),CP(1000),NPAIR(2,100)
C     IOENGI = 80
      CALL GETIOUNIT('IOENGI  ',IOENGI)
C
C     LOOK FOR VBOSYM FLAG
C
      CALL LOCTOR(IOENGI,'$VBOSYM',7,IOK,0)
      IF(IOK.EQ.0) RETURN
      READ(IOENGI,*)NPA,(NPAIR(1,I),NPAIR(2,I),I=1,NPA)
      READ(IOENGI,*)NMOD,(NP(I),I=1,NMOD)
      DO 100 I=1,NPA
      READ(IOENGI,*)NMOD,(CP(J),J=1,NMOD)
       DO 110 J=1,NMOD
       BASIS(J,NPAIR(1,I))=BASIS(NP(J),NPAIR(2,I))*CP(J)
 110  CONTINUE
 100  CONTINUE
      RETURN
      END
      SUBROUTINE LMOTRN(NBASIS,BASIS,W,NATOM,PGM,EIG,PM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION BASIS(NBASIS,*),W(NBASIS,*),LMO(100),KMO(100),C(100)
      DIMENSION PGM(NATOM,*),PM(NATOM,*),EIG(*),EIGW(5000)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     IOENGI = 80
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      DO I=1,NBASIS
      EIGW(I)=EIG(I)
      END DO
C
C     LOOK FOR LMO TRANSFORMATION FLAG
C
      CALL LOCTOR(IOENGI,'$LMOTRAN',8,IOK,0)
      IF(IOK.EQ.0) RETURN
      READ(IOENGI,*)NTRAN
      READ(IOENGI,*)(LMO(I),I=1,NTRAN)
      DO 100 I=1,NTRAN
      READ(IOENGI,*)NMO
      READ(IOENGI,*)(KMO(K),K=1,NMO)
      READ(IOENGI,*)(C(K),K=1,NMO)
      WRITE(IOUTVB,*)NMO
      WRITE(IOUTVB,*)(KMO(K),K=1,NMO)
      WRITE(IOUTVB,*)(C(K),K=1,NMO)
      DO 110 J=1,NATOM
      PM(J,I)=0.0D0
        DO 110 K=1,NMO
        PM(J,I)=PM(J,I)+C(K)*C(K)*PGM(J,KMO(K))
 110  CONTINUE
      SUM=0.0D0
      EIGW(I)=0.0D0
        DO 115 K=1,NMO
        SUM=SUM+C(K)*C(K)
        EIGW(I)=EIGW(I)+C(K)*C(K)*EIG(KMO(K))
 115  CONTINUE
      EIGW(I)=EIGW(I)/SUM
      DO 100 J=1,NBASIS
      W(J,I)=0.0D0
        DO 100 K=1,NMO
        W(J,I)=W(J,I)+C(K)*BASIS(J,KMO(K))
 100  CONTINUE
      DO 200 J=1,NBASIS
      WRITE(IOUTVB,1000)(W(J,I),I=1,NTRAN)
      DO 200 I=1,NTRAN
 200  BASIS(J,LMO(I))=W(J,I)
      DO 210 J=1,NATOM
      WRITE(IOUTVB,1000)(PM(J,I),I=1,NTRAN)
      DO 210 I=1,NTRAN
 210  PGM(J,LMO(I))=PM(J,I)
      DO 220 I=1,NTRAN
 220  EIG(LMO(I))=EIGW(I)
 1000 FORMAT(10F8.5)
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     SETUP TRANSFORMATION MATRICES FOR THE BASIS FUNCTIONS OF CARTESIAN SPACE
C
C     INPUT: ROTATION MATRIX RT(3,3): V' = R V
C
C     TRANP(3,3)   FOR P ORBITALS
C     TRAND(6,6)   FOR D ORBITALS
C     TRANF(10,10) FOR F ORBITALS
C
C     X,Y,Z
C     1 2 3
C
C
C     XX,YY,ZZ,XY,XZ,YZ
C     1  2  3  4  5  6
C
C     Frist version: May 29, 2003
C     Fixed the denormalization bug for TRAND: Jan 17, 2005
C     Fixed RIJ bug for TRAND: Oct 27, 2005
C
C     Author: Jiabo Li
C     San Diego
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE MOLTRAN(R3D,TRANP,TRAND,TRANF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION R3D(3,3)
      DIMENSION TRANP(3,3),TRAND(6,6),TRANF(10,10)
      DO I=1, 3
        DO J=1, 3
C       TR(I,J)    = R3D(J,I)
        TRANP(I,J) = R3D(I,J)
        END DO
      END DO
      R11 = TRANP(1,1)
      R12 = TRANP(2,1)
      R13 = TRANP(3,1)
      R21 = TRANP(1,2)
      R22 = TRANP(2,2)
      R23 = TRANP(3,2)
      R31 = TRANP(1,3)
      R32 = TRANP(2,3)
      R33 = TRANP(3,3)
      TRAND(1,1) = R11*R11
      TRAND(2,1) = R12*R12
      TRAND(3,1) = R13*R13
      TRAND(4,1) = R11*R12 + R12*R11
      TRAND(5,1) = R11*R13 + R13*R11
      TRAND(6,1) = R12*R13 + R13*R12
      TRAND(1,2) = R21*R21
      TRAND(2,2) = R22*R22
      TRAND(3,2) = R23*R23
      TRAND(4,2) = R21*R22 + R22*R21
      TRAND(5,2) = R21*R23 + R23*R21
      TRAND(6,2) = R22*R23 + R23*R22
      TRAND(1,3) = R31*R31
      TRAND(2,3) = R32*R32
      TRAND(3,3) = R33*R33
      TRAND(4,3) = R31*R32 + R32*R31
      TRAND(5,3) = R31*R33 + R33*R31
      TRAND(6,3) = R32*R33 + R33*R32
      TRAND(1,4) = R11*R21
      TRAND(2,4) = R12*R22
      TRAND(3,4) = R13*R23
      TRAND(4,4) = R11*R22 + R12*R21
      TRAND(5,4) = R11*R23 + R13*R21
      TRAND(6,4) = R12*R23 + R13*R22
      TRAND(1,5) = R11*R31
      TRAND(2,5) = R12*R32
      TRAND(3,5) = R13*R33
      TRAND(4,5) = R11*R32 + R12*R31
      TRAND(5,5) = R11*R33 + R13*R31
      TRAND(6,5) = R12*R33 + R13*R32
      TRAND(1,6) = R21*R31
      TRAND(2,6) = R22*R32
      TRAND(3,6) = R23*R33
      TRAND(4,6) = R21*R32 + R22*R31
      TRAND(5,6) = R21*R33 + R23*R31
      TRAND(6,6) = R22*R33 + R23*R32
      TRANF(1,1) = 1.0D0
      RETURN
      END
      SUBROUTINE ORBTRN(NDIM,NORB,BFLABE,ORBINP,R3D,ORBOUT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE(*),ATMPY,ATMPZ
      CHARACTER*12 ATMP
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION R3D(3,3),ORBINP(NDIM,NORB),ORBOUT(NDIM,NORB),TT(20)
      DIMENSION TRANP(3,3),TRAND(6,6),TRANF(10,10),NPTRAN(2,1000)
      DIMENSION ORBTMP(1000)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      CALL MOLTRAN(R3D,TRANP,TRAND,TRANF)
C     WRITE(IOUTVB,*)'TRANP'
C     WRITE(IOUTVB,*)(TRANP(1,I),I=1,3)
C     WRITE(IOUTVB,*)(TRANP(2,I),I=1,3)
C     WRITE(IOUTVB,*)(TRANP(3,I),I=1,3)
C
C     NPTRAN(2,n)
C
C     NPTRAN(1,n): the type of the n-th shell(1=S, 2=P, 3=D, 4=F)
C     NPTRAN(2,n): the starting point of the n-th shell
C
C     ASSUME BFLABE is de-captialized
C
C     SETUP MATRIX
C
      NP  = 0
      NPB = 0
  100 CONTINUE
C     DEFAULT: CARTESIAN ORBITALS
      ICART= 1
      ATMP = BFLABE(NPB+1)
C     WRITE(IOUTVB,*)'ATMP =',ATMP
C     WRITE(IOUTVB,*)'ATMP(11:12)=',ATMP(11:12)
      IF(ATMP(11:12).EQ.' s') THEN
      NP=NP+1
      NPTRAN(1,NP)=1
      NPTRAN(2,NP)=NPB+1
      NPB=NPB+1
      ELSE IF(ATMP(11:12).EQ.' x') THEN
      NP=NP+1
      NPTRAN(1,NP)=2
      NPTRAN(2,NP)=NPB+1
C
C     CHECK THE ORDER OF BF
C
      ATMPY=BFLABE(NPB+2)
      ATMPZ=BFLABE(NPB+3)
      NPB=NPB+3
        IF(ATMPY(11:12).NE.' y'.OR.ATMPZ(11:12).NE.' z') THEN
C       WRITE(IOUTVB,*)'ATMPY = ',ATMPY
C       WRITE(IOUTVB,*)'ATMPZ = ',ATMPZ
        CALL ABORT0('MOTRAN01  ')
        END IF
      ELSE IF(ATMP(10:12).EQ.' xx') THEN
C     CARTESIAN D ORBITALS
C     ATMPYY=BFLABE(NPB+2)
C     ATMPZZ=BFLABE(NPB+3)
C     ATMPXY=BFLABE(NPB+4)
C     ATMPXZ=BFLABE(NPB+5)
C     ATMPYZ=BFLABE(NPB+6)
      NP=NP+1
      NPTRAN(1,NP)=3
      NPTRAN(2,NP)=NPB+1
C     IF(ATMPYY(11:12).NE.'yy'.OR.ATMPZZ(11:12).NE.'zz'.OR.
C    &   ATMPXY(11:12).NE.'xy'.OR.ATMPXZ(11:12).NE.'xz'.OR.
C    &   ATMPYZ(11:12).NE.'yz') CALL ABORT0('MOTRAN02  ')
      NPB=NPB+6
      ELSE IF(ATMP(10:12).EQ.'d 0') THEN
      ICART=0
C
C     5-D
C
      NP=NP+1
      NPTRAN(1,NP)=3
      NPTRAN(2,NP)=NPB+1
      NPB=NPB+5
      ELSE IF(ATMP(9:12).EQ.' xxx') THEN
C
C     CARTESIAN F ORBITALS
C
      NP=NP+1
      NPTRAN(1,NP)=4
      NPTRAN(2,NP)=NPB+1
      NPB=NPB+10
C
C     F ORBITAL HAVE TO BE ZERO IN VBOLIB
C
      ELSE IF(ATMP(10:12).EQ.'f 0') THEN
      ICART=0
C
C     7-F
C
      NP=NP+1
      NPTRAN(1,NP)=4
      NPTRAN(2,NP)=NPB+1
      NPB=NPB+7
      ELSE IF(ATMP(9:12).EQ.'xxxx') THEN
      WRITE(IOUTVB,*)'G orbital found'
C
C     CARTESIAN G ORBITALS
C
      NP=NP+1
      NPTRAN(1,NP)=5
      NPTRAN(2,NP)=NPB+1
      NPB=NPB+15
C
C     G ORBITAL HAVE TO BE ZERO IN VBOLIB
C
      ELSE IF(ATMP(10:12).EQ.'g 0') THEN
      ICART=0
C
C     9-G
C
      NP=NP+1
      NPTRAN(1,NP)=5
      NPTRAN(2,NP)=NPB+1
      NPB=NPB+9
      ELSE
      CALL ABORT0('MOTRAN04  ')
      END IF
      IF(NPB.LT.NDIM) GOTO 100
C120  CONTINUE
      DO 140 I=1, NORB
      DO 145 NBLK=1,NP
C     WRITE(IOUTVB,*)'NPTRAN =',NPTRAN(1,NBLK),NPTRAN(2,NBLK)
      NBB = NPTRAN(2,NBLK)
      IF(NPTRAN(1,NBLK).EQ.1) THEN
C     WRITE(IOUTVB,*)'S orbital is handled'
      ORBTMP(NBB) = ORBINP(NBB,I)
      ELSE IF(NPTRAN(1,NBLK).EQ.2) THEN
C     WRITE(IOUTVB,*)'P orbital is handled'
      CALL MATMUL2(3,3,1,TRANP,ORBINP(NBB,I),ORBTMP(NBB))
      ELSE IF (NPTRAN(1,NBLK).EQ.3.AND.ICART.EQ.1) THEN
C     WRITE(IOUTVB,*)'D orbital is handled'
      DO KKK=1,6
      TT(KKK) = ORBINP(NBB-1+KKK,I)
      END DO
C
C     DE-NORMALIZATION
C
C     FACTORX = 1.15475D0
      FACTORX = DSQRT(1.0D0/3.0D0)
      TT(4) = TT(4)/FACTORX
      TT(5) = TT(5)/FACTORX
      TT(6) = TT(6)/FACTORX
      CALL MATMUL2(6,6,1,TRAND,TT,ORBTMP(NBB))
C
C     RE-NORMALIZATION
C
      ORBTMP(NBB+3) = ORBTMP(NBB+3)*FACTORX
      ORBTMP(NBB+4) = ORBTMP(NBB+4)*FACTORX
      ORBTMP(NBB+5) = ORBTMP(NBB+5)*FACTORX
      ELSE IF (NPTRAN(1,NBLK).EQ.3.AND.ICART.EQ.0) THEN
        DO KKK=1,5
        ORBTMP(NBB-1+KKK) = ORBINP(NBB-1+KKK,I)
        IF(ABS(ORBTMP(NBB-1+KKK)).GT.1.0D6) CALL ABORT0('5DNOTDONE0')
        END DO
      ELSE IF (NPTRAN(1,NBLK).EQ.4.AND.ICART.EQ.1) THEN
C     WRITE(IOUTVB,*)'F orbital is handled'
        DO KKK=1,10
        ORBTMP(NBB-1+KKK) = 0.0D0
        END DO
      ELSE IF (NPTRAN(1,NBLK).EQ.4.AND.ICART.EQ.0) THEN
        DO KKK=1,7
        ORBTMP(NBB-1+KKK) = 0.0D0
        END DO
      ELSE IF (NPTRAN(1,NBLK).EQ.5.AND.ICART.EQ.1) THEN
C     WRITE(IOUTVB,*)'G orbital is handled'
        DO KKK=1,16
        ORBTMP(NBB-1+KKK) = 0.0D0
        END DO
      END IF
 145  CONTINUE
C
C     COPY FROM ORBTMP TO ORBOUT
C
      DO J=1, NDIM
      ORBOUT(J,I) = ORBTMP(J)
      END DO
 140  CONTINUE
      RETURN
      END
      SUBROUTINE IGUESS(BASIS,DM1NON,W,NGP,MSIZE,IOLVBO)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Generate initial guess.
C     Note:
C
C     History:
C               First created in Feb. 1998.
C               Updated 1999-2000.
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*8  VBOLAB(1000),BONDLAB
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
C     CHARACTER*80 VBPATH
      PARAMETER (MAXCEN=200,MAXBFN=726)
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
      PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA,MAXGRP=99)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(MAXGRP),MSPIN(MAXGRP),MNORBIT(MAXGRP),
     &MLORBIT(MAXGRP),MWIN(MAXGRP),MSTR(MAXGRP),METHOD(MAXGRP),
     &IBASIS(MAXEXT),NOCC(MAXEXT),NOBIAS,NEPS,NVIR,NOTROT(5000),
     &LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(MAXGRP)
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
      PARAMETER (MAXNAB=MAXCEN*MAXBFN/2,MAXBF2=MAXBFN*MAXBFN)
      COMMON /LMODAT/VMO(MAXBF2),VLMO(MAXBF2),LMOLAB(2,MAXBFN),
     &LMOATM(5,MAXBFN),PGM(MAXNAB),ENGLMO(MAXBFN),BONDLAB(MAXBFN),
     &MCLMO(5,80),LHFLAG
      DIMENSION W(*),DM1NON(*),BASIS(*),EIG(5000)
      DIMENSION ISPLIT(5000),NGP(*),CNORM(5000),NBONDALIST(10,1000)
      DIMENSION NBONDTYPE(10,1000)
      NSSS=1
      NWK0=NSSS+NBASIS*(NBASIS+1)/2
      NWK1=NWK0+NBASIS*NBASIS
      NWK2=NWK1+NBASIS*NBASIS
      NWK3=NWK2+NBASIS*NBASIS
      NWK4=NWK3+NBASIS*NBASIS
      MSIZE1=MSIZE-NWK3-NBASIS*NBASIS+1
      IF(MSIZE1.LE.0) CALL ABORT0('IGUESS01  ')
      IF(NATOM*NBASIS.GT.500000) CALL ABORT0('IGUESS02  ')
      NLOCAL=(NELE+1)/2
C     LOCVIR=NBASIS-NLOCAL
C     NOBVIR=NBASIS*NLOCAL+1
C     NPMVIR=NATOM*NLOCAL+1
      DISCON=1.0D0
      NORBI=0
      DO I=1,NSUB
      NORBI=NORBI+MLORBIT(I)
      END DO
C
C     INITIALIZE MOL TOPOL
C
      CALL INIMOLTOPOL()
C
C     FIND NEIGHBOR ATOMS (BONDED)
C
      CALL FINDNB(NATOM,NATNUM,XYZ,NBONDALIST,NBONDTYPE)
C
C     GET IOUNITS BY NAMES
C
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL GETIOUNIT('IOHFORB ',IOHFORB)
      CALL GETIOUNIT('IOVBORB ',IOVBORB)
      CALL GETIOUNIT('IOTEMP  ',IOTEMP)
C
C     READ S and MO'S
C
      CALL READ1E(IAO1E,W(NSSS),W(NWK0),NBASIS)
      IF(IRESTART.LE.0) THEN
      CALL LOCTOR(IOENGI,'$LMODISTORTION',14,IOK,0)
      IF(IOK.EQ.0) CALL LOCTOR(IOENGI,'$DISCON',7,IOK,0)
      IF(IOK.NE.0) READ(IOENGI,*)DISCON
C     CALL RDMORB(IOHFORB,BASIS,EIG,NBASIS)
C
C     Pick one of two options:
C
C     LHYBRD = 1, USING ROY MCWEENY'S HYBRID METHOD
C     LHYBRD = 0, USING DLMO METHOD
C
      CALL RDMORB(IOHFORB,BASIS,EIG,NBASIS)
      DO K=1, NBASIS+NEXTRA
      VBOLAB(K) = '       '
      END DO
      IF(LHYBRD.EQ.0) THEN
C
C     COPY CANON LMOS FROM VLMO TO BASIS
C
      DO K=1, NBASIS*NLOCAL
      BASIS(K) = VLMO(K)
      END DO
      DO K=1, NLOCAL
      VBOLAB(K) = BONDLAB(K)
      END DO
C
C     BY SETTING IRESTART=-1, THE COMPUTATION STOPS AFTER LMO IS DONE.
C
      IF(IRESTART.LT.0) RETURN
C     CALL LMOTRN(NBASIS,BASIS,W(NWK0),NATOM,PGM,EIG,W(NWK1))
      CALL INIGDM(NBASIS,NSUB,MLORBIT,ISPLIT,NGP,NATOM)
      CALL DISLMO(NBASIS,NSUB,MLORBIT,ISPLIT,NGP,NATOM,
     &     NATBAS,BASIS,W(NWK0),PGM,DISCON,BONDLAB,VBOLAB)
C
C     SET UP INDEXES
C
      NCORE=0
      NBOALL=0
      DO I=1,NSUB
        DO J=1,MLORBIT(I)
        NBOALL=NBOALL+1
        NOCC(NBOALL)=1
          IF(METHOD(I).EQ.1) THEN
          NCORE=NCORE+1
          NOCC(NBOALL)=2
          END IF
        END DO
      END DO
C
C     GENERATE ARBITARY VECTORS FOR VIRTUAL ORBITALS
C
      DO I=NBOALL+1,NBASIS+NEXTRA
        DO J=1,NBASIS
        XXX = VBRAND(0)
        BASIS(NBASIS*(I-1)+J)=XXX
        END DO
      END DO
C
C     SPECIAL ROUTINE FOR GENERATING PI ORBITALS
C
      CALL PIVBO(NBASIS,BASIS,NB1ADD)
C
C     NEW VERSION OF PI ORBITAL GENERATOR USING FRAGMENT DATA
C
      CALL LPIVBO(BASIS,NB1ADD,IOLVBO,NBONDALIST,NSUB,
     &            VBOLAB)
C
C     NEW VERSION OF VBO GENERATOR USING VBO LIBRARY
C
C     CALL VBOLIB(NBASIS,BASIS,NB1ADD,IOLVBO,NBONDALIST,NSUB,BONDLAB,
C    &            LMOLAB,VBOLAB)
      CALL VBOLIB(BASIS,NB1ADD,IOLVBO,NSUB,VBOLAB)
      ELSE
      CALL GUESS2(NATOM, NATBAS, NBASIS, BASIS, W(NSSS),W(NWK0),NELE)
C
C     SET UP INDEXES
C
      NCORE=0
      NBOALL=0
      DO I=1,NSUB
        DO J=1,MLORBIT(I)
        NBOALL=NBOALL+1
        NOCC(NBOALL)=1
          IF(METHOD(I).EQ.1) THEN
          NCORE=NCORE+1
          NOCC(NBOALL)=2
          END IF
        END DO
      END DO
C
C     GENERATE ARBITARY VECTORS FOR VIRTUAL ORBITALS
C
      DO I=NBOALL+1,NBASIS+NEXTRA
        DO J=1,NBASIS
        XXX = VBRAND(0)
        BASIS(NBASIS*(I-1)+J)=XXX
        END DO
      END DO
C
      END IF
C
C     SPECIAL ROUTINE FOR READING IN APPROXIMATE INITIAL GUESS
C
      CALL RDGUES(NBASIS,BASIS,IOTEMP,IOENGI)
C
      CALL WTGUES(NBASIS,BASIS,NBOALL,IOTEMP,IOENGI)
      ELSE
      DO K=1, NBASIS+NEXTRA
      VBOLAB(K) = '       '
      END DO
      DO K=1, NLOCAL
      VBOLAB(K) = BONDLAB(K)
      END DO
C
C     READ ORBITALS AND 1D DENSITIES FROM PREVIOUS CALCULATION
C
      CALL RESTARD(IOVBORB,IOENGI,NATOM,NSUB,MLORBIT,METHOD,NBASIS,
     &             BASIS,DM1NON,LHFLAG,LMOATM)
      END IF
C
C     post initial guess processes
C

C     ORBITAL FILTER: LOCALIZATION OF VB ORBITALS BY TRUNCATION
C
      CALL LOCVBO(NBASIS,BASIS,NATOM,NATBAS,IOENGI,W(NSSS),W(NWK0))
C
C     S-->W(NWK1)
C
        DO I=1,NBASIS
        II=(I-1)*NBASIS-1
        DO J=1,NBASIS
        IJ=II+J
        W(NWK1+IJ)=W(NSSS-1+IJ00(I,J))
        END DO
        END DO
C
C     COLLECT CORE ORBITALS
C     CORE-->W(NWK2)
C
C     SPECIAL HANDLING FOR SPHER HARMONIC. PROJECT OUT NON-SPHER HARMONIC
C     PART
C
C     First, we need find the subspace that contains only spher harmonic basis
C
C     Steps: 1) Find the vectors which are orthogonal to the spher harmonic
C               space.
C
      NSP=0
C     MSP=0
      MSUB = 1
      DO I=1,NSUB
        IF(MELE(I).EQ.0) THEN
          NSP=I
C         MSP=MLORBIT(I)
          MMSUB=MSUB
          METHOD(I) = 99
        END IF
        MSUB = MSUB + MLORBIT(I)*NBASIS
      END DO
      IF(NSP.EQ.0) GOTO 111
      CALL GETSPH(NBASIS,BFLABE,W(NWK1),W(NWK2),W(NWK3),W(NWK4),NNSP)
C     NSPH: DIMENSION OF ACTIVE SPACE
      NSPH = NBASIS - NNSP
      DO J=1, NBASIS*NNSP
         BASIS(MMSUB-1+J) = W(NWK3-1+J)
      END DO
      IISUB = 1
      DO I=1, NSUB
         IF(I.NE.NSP) THEN
            CALL PROJEC(NBASIS,MLORBIT(I),NSPH,W(NWK1),BASIS(IISUB),
     &                  W(NWK2),W(NWK3),W(NWK4))
         END IF
         IISUB = IISUB + MLORBIT(I)*NBASIS
      END DO
      CALL PROJEC(NBASIS,NSPH,NSPH,W(NWK1),BASIS(IISUB),
     &                  W(NWK2),W(NWK3),W(NWK4))
 111  CONTINUE
      NCORE=0
      NT=0
      DO I=1,NBASIS
      II=(I-1)*NBASIS
      IF(IBASIS(I).GT.0) THEN
      IF(METHOD(IBASIS(I)).EQ.1) THEN
C     THIS IS A CORE ORBITAL
      NCORE=NCORE+1
         DO J=1,NBASIS
         W(NWK2+NT)=BASIS(II+J)
         NT=NT+1
         END DO
      END IF
      END IF
      END DO
C
C     ORTHOGONAL TO CORE ORBITALS
C
      CALL ORTHAB(NBASIS,NCORE,NBASIS+NEXTRA,W(NWK1),W(NWK2),BASIS,
     &            W(NWK3))
C
C
C     RETURN CORE ORBITALS BACK TO BASIS
C
      NT=0
      DO I=1,NBASIS+NEXTRA
      II=(I-1)*NBASIS
      IF(IBASIS(I).GT.0.AND.METHOD(IBASIS(I)).EQ.1) THEN
C     THIS IS A CORE ORBITAL, MODIFIED IN BASIS. RESET TO ORIGINAL
         DO J=1,NBASIS
         BASIS(II+J)=W(NWK2+NT)
         NT=NT+1
         END DO
      END IF
      END DO
C
C     FIND THE NUMBERS OF LINEAR INDEPENDENT ORBITALS OF ALL GROUPS
C     SET MNORBIT(I), NVIR
C
C     THE LINEAR INDEPENDENT ORBITALS ARE STORED IN W(NWK0)
C
      CALL SETNORB(NBASIS,NSUB,MLORBIT,MNORBIT,BASIS,W(NWK1),W(NWK0),
     &                                               W(NWK2))
      NX = 0
      NL = 0
      DO I=1, NSUB
      IF(MELE(I).EQ.0) MNORBIT(I) = MLORBIT(I)
      NX = NX + MNORBIT(I)
      NL = NL + MLORBIT(I)
      END DO
      NVIR = NBASIS - NX
      MBASIS = NL + NVIR
      DO I=1, NSUB
        IF(METHOD(I).EQ.1) THEN
        MWIN(I) = MLORBIT(I) + NVIR
        END IF
      END DO
C
C     COPY REMAINING VECTRORS BASIS->W(NWK0)
C
      DO I=1, NVIR
        MMM1= NWK0-1 + (NX+I-1)*NBASIS
        MMM2= (NL+I-1)*NBASIS
        DO J=1, NBASIS
        W(MMM1+J) = BASIS(MMM2+J)
        END DO
      END DO
C
C     LOWDIN ORTHOGONALIZATION OF SUBUNITS
C
      CALL INIBAS(NBASIS,NSUB,MLORBIT,MNORBIT,METHOD,NBASIS,BASIS,
     &             W(NSSS),W(NWK0),W(NWK1),CNORM)
C
C     INITIALIZE LOCAL ONE-DIMENSIONAL DENSITY MATRIX DM1NON
C     IN NONORTHOGONAL BASIS
C
      IF(IRESTART.LE.0)
     &CALL ININDM(NSUB,MELE,MLORBIT,DM1NON)
C
C     PRINT INITIAL ORBITALS
C
      IF(LPTALL.EQ.1) CALL MPRINT(BASIS,W,NBASIS,NORBI,3,BFLABE,VBOLAB)
      RETURN
      END
      SUBROUTINE RESTARD(IOVBORB,IOENGI,NATOM,NSUB,MLORBIT,METHOD,
     &                   NBASIS,BASIS,DM1NON,LHFLAG,LMOATM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABEX(1000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION BASIS(*),DM1NON(*),MLORBIT(*),METHOD(*),MAPHF(100)
      DIMENSION MAPGRP(100),NORBST(100),NORBSTX(100),N1DADD(100)
      DIMENSION N1DADDX(100),MELEX(100),LMOATM(5,*)
      DIMENSION BASISX(500000),DM1NONX(100000),MLORBITX(99),METHODX(99)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
C     BONDARY CHECK
C
C     IF(NBASIS.GT.700) CALL ABORT0('RESTARD00 ')
      REWIND(IOVBORB)
      READ(IOVBORB)NSUBX,NDM1X,(MELEX(I),I=1,NSUBX),
     &              (MLORBITX(I),I=1,NSUBX),(METHODX(I),I=1,NSUBX)
      READ(IOVBORB)NBASISX,NATOMX,NORBX,(BFLABEX(I),I=1,NBASISX)
      READ(IOVBORB)(BASISX(I),I=1,NBASISX*NORBX)
      READ(IOVBORB)(DM1NONX(I),I=1,NDM1X)
      IF(LHFLAG.GE.1) READ(IOVBORB)((LMOATM(I,J),I=1,5),J=1,NORBX)
      IF(NATOM.GT.10000000) WRITE(IOUTVB,*)MELEX(1),BFLABEX(1)
C
C     ERROR CHECK
C
      IF(NATOMX.NE.NATOM.OR.NBASIS.NE.NBASISX) THEN
         WRITE(IOUTVB,*)"THE RESTART FILE DOES NOT MATCH THE CURRENT "
         WRITE(IOUTVB,*)"CALCULATION"
         CALL ABORT0('RESTARD01 ')
      END IF
C
C     BUILD INDEXES OF GROUP ORBITALS
C
      NORBSTX(1) = 1
      N1DADDX(1) = 1
      DO I=2, NSUBX+1
      NORBSTX(I) = NORBSTX(I-1) + MLORBITX(I-1)
      N1DADDX(I) = N1DADDX(I-1) + MLORBITX(I-1)*(MLORBITX(I-1)+1)/2
      END DO
      NORBST(1) = 1
      N1DADD(1) = 1
      DO I=2, NSUB+1
      NORBST(I) = NORBST(I-1) + MLORBIT(I-1)
      N1DADD(I) = N1DADD(I-1) + MLORBIT(I-1)*(MLORBIT(I-1)+1)/2
      END DO
      DO I=1, N1DADD(NSUB+1) - 1
      DM1NON(I) = 0.0D0
      END DO
C
C     COMPARE NSUB, MLORBIT AND METHOD. IF ALL MATCH, JUST COPY DATA AND
C     RETURN, ELSE, SEARCH FOR $RESTARTMAPPING
C
      CALL RESTACOMP(NSUB,MLORBIT,METHOD,NSUBX,MLORBITX,METHODX,IEQ)
      DO I=1, NBASIS*NORBX
      BASIS(I) = BASISX(I)
      END DO
      DO I=1, NDM1X
      DM1NON(I) = DM1NONX(I)
      END DO
      IF(IEQ.EQ.1) THEN
        RETURN
      ELSE
C
C     SEARCH FOR MAPPING
C
      CALL LOCTOR(IOENGI,'$RESTARTMAPPING',15,IOK,0)
      WRITE(IOUTVB,*)'SEARCH FOR RESTARTMAPPING'
      IF(IOK.NE.1) THEN
         WRITE(IOUTVB,*)"A RESTART MAPPING FILE IS NEEDED"
         WRITE(IOUTVB,*)"IT CAN BE A INPUT ERROR"
         CALL ABORT0('RESTARD02 ')
      END IF
      NMAPHF = 0
        IF(METHODX(1).EQ.1) NMAPHF = MLORBITX(1)
        DO I=1, NMAPHF
        MAPHF(I) = 1
        END DO
        DO I=1, NSUBX
        MAPGRP(I) = I
        END DO
        IF(NMAPHF.GT.0) READ(IOENGI,*)(MAPHF(I),I=1,NMAPHF)
        READ(IOENGI,*)(MAPGRP(I),I=1,NSUBX)
C
C     NOW, COLLECT ORBITALS FOR EACH GROUP, AND BUILD LOCAL 1D DENSITY
C
      NORBT = 0
        DO I=1, NSUB
        NORB = 0
        NADD = N1DADD(I) - 1
C
C     COLLECT HF ORBITALS FIRST
C
           DO J=1, NMAPHF
           JJ = (J-1)*NBASIS
           IF(MAPHF(J).EQ.I) THEN
             NORB  = NORB + 1
             NORBT = NORBT + 1
             NNORBT = (NORBT-1)*NBASIS
             DO K=1, NBASIS
             BASIS(NNORBT+K) = BASISX(JJ+K)
             END DO
           NORB2 = NORB*(NORB+1)/2
           DM1NON(NADD + NORB2) = 2.0D0
           END IF
           END DO
           DO J=1, NSUBX
           NORBP = NORB
           JORBST = NORBSTX(J) - 1
           NADDJ  = N1DADDX(J) - 1
           IF(METHODX(J).NE.1.AND.MAPGRP(J).EQ.I) THEN
              DO K=1, MLORBITX(J)
              JJ = (JORBST+K-1)*NBASIS
              NORB  = NORB + 1
              NORBT = NORBT + 1
              NNORBT = (NORBT-1)*NBASIS
                DO L=1, NBASIS
                BASIS(NNORBT+L) = BASISX(JJ+L)
                END DO
              END DO
C
C             COPY D1
C
              DO K=1, MLORBITX(J)
              DO L=1, K
              KL = K*(K-1)/2 + L
              KK = NORBP + K
              LL = NORBP + L
              KL2 = KK*(KK-1)/2 + LL
              DM1NON(NADD+KL2) = DM1NONX(NADDJ+KL)
              END DO
              END DO
           END IF
           END DO
C
C       CHECK THE NUMBER OF ORBITALS COLLECT, AND DO ERROR CHECK
C
        IF(NORB.NE.MLORBIT(I)) CALL ABORT0('RESTARD03 ')
        END DO
      END IF
      RETURN
      END
      SUBROUTINE RESTACOMP(NSUB,MLORBIT,METHOD,NSUBX,MLORBITX,METHODX,
     &                     IEQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION MLORBIT(*),MLORBITX(*),METHOD(*),METHODX(*)
      IEQ = 0
      IF(NSUB.NE.NSUBX) RETURN
      DO I=1, NSUB
      IF(MLORBITX(I).NE.MLORBIT(I).OR.
     &     (METHOD(I).EQ.1.AND.METHODX(I).GT.1).OR.
     &     (METHOD(I).GT.1.AND.METHODX(I).EQ.1)) RETURN
      END DO
      IEQ = 1
      RETURN
      END
      SUBROUTINE FINDNB(NATOM,NATNUM,XYZ,NBONDALIST,NBONDTYPE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NATNUM(*),XYZ(3,*),NBONDALIST(10,*),ARADII(110)
      DIMENSION NBONDTYPE(10,*),CARADII(3,110)
      DATA ARADII/0.3D0,1.5D0,1.0D0,1.06D0,0.88D0,0.77D0,0.70D0,
     &            0.66D0,0.64D0,1.50D0,1.0D0,1.40D0,1.26D0,1.17D0,
     &            1.10D0,1.04D0,0.99D0,93*1.20D0/
      DATA CARADII/330*0.0D0/
C
C     The values are from Pauling's book of 'The Nature of The Chemical Bond'
C     Table 7-2 (P224) and Table 7-5 (p228), 1970 Eds.
C
C     H
      CARADII(1,1) = 0.30D0
C     B
      CARADII(1,5) = 0.81D0
      CARADII(2,5) = 0.71D0
      CARADII(3,5) = 0.64D0
C     C
      CARADII(1,6) = 0.772D0
      CARADII(2,6) = 0.667D0
      CARADII(3,6) = 0.603D0
C     N
      CARADII(1,7) = 0.74D0
      CARADII(2,7) = 0.62D0
      CARADII(3,7) = 0.55D0
C     O
      CARADII(1,8) = 0.74D0
      CARADII(2,8) = 0.62D0
      CARADII(3,8) = 0.55D0
C     F
      CARADII(1,9) = 0.72D0
      CARADII(2,9) = 0.60D0
C     Si
      CARADII(1,14) = 1.17D0
      CARADII(2,14) = 1.07D0
      CARADII(3,14) = 1.00D0
C     P
      CARADII(1,15) = 1.10D0
      CARADII(2,15) = 1.00D0
      CARADII(3,15) = 0.93D0
C     S
      CARADII(1,16) = 1.04D0
      CARADII(2,16) = 0.94D0
      CARADII(3,16) = 0.87D0
C     Cl
      CARADII(1,17) = 0.99D0
      CARADII(1,17) = 0.89D0
C     WRITE(IOUTVB,*)'FINDNB, NATOM = ',NATOM
      DO I=1, NATOM
      NBONDA=0
        DO J=1,NATOM
        DIJ = DSQRT((XYZ(1,I)-XYZ(1,J))**2+(XYZ(2,I)-XYZ(2,J))**2+
     &             (XYZ(3,I)-XYZ(3,J))**2)
        DIJT = (ARADII(NATNUM(I))+ARADII(NATNUM(J)))*1.30D0
        IF(DIJ.LE.DIJT.AND.I.NE.J) THEN
        NBONDA = NBONDA+1
        NBONDALIST(NBONDA+1,I) = J
        NATI = NATNUM(I)
        NATJ = NATNUM(J)
        CALL FINDBOD(NATI,NATJ,CARADII(1,NATI),CARADII(1,NATJ),DIJ,NBOD)
        NBONDTYPE(NBONDA+1,I) = NBOD
        END IF
        END DO
      NBONDALIST(1,I) = NBONDA
C     WRITE(IOUTVB,*)'NEIB =',NBONDA
C     WRITE(IOUTVB,*)'NEIB OF I=',I,(NBONDALIST(J+1,I),J=1,NBONDALIST(1,I))
      END DO
      RETURN
      END
C
C     FIND BOND ORDER BY DISTANCE
C
      SUBROUTINE FINDBOD(NA1,NA2,CR1,CR2,D12,NBOD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION CR1(3),CR2(3),R12(3)
      CALL FINDSTDL(NA1,NA2,CR1,CR2,R12)
C
C     DEFAULT: UNKNOWN BOND ORDER
C
      NBOD = 0
      IF(R12(1).EQ.0.0D0) RETURN
C
      IF(D12.GT.R12(1)) THEN
      NBOD = 1
      RETURN
      END IF
      IF(D12.LT.R12(3)) THEN
      NBOD = 3
      RETURN
      END IF
C
C     FIND THE BEST MATCH
C
      RERR = DABS(D12-R12(1))/D12
      NBOD = 1
      RTMP = DABS(D12-R12(2))/D12
      IF(RTMP.LT.RERR) THEN
        RERR = RTMP
        NBOD = 2
      END IF
      RTMP = DABS(D12-R12(3))/D12
      IF(RTMP.LT.RERR) THEN
        RERR = RTMP
        NBOD = 3
      END IF
C
C     SPECIAL CASE; AROMATIC BOND OF CC = 1.40
C
      IF(NA1.EQ.6.AND.NA2.EQ.6.AND.ABS(D12-1.40D0).LT.0.01D0) NBOD = 4
      RETURN
      END
      SUBROUTINE FINDSTDL(NA1,NA2,CR1,CR2,R12)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION CR1(3),CR2(3),R12(3)
      DO I=1,3
      R12(I) = 0.0D0
      IF(CR1(I).GT.0.0D0.AND.CR2(I).GT.0.0D0) R12(I) = CR1(I) + CR2(I)
      END DO
C
C     C-N = 1.47, C#N = 1.155
C
      IF(NA1.EQ.6.AND.NA2.EQ.7) THEN
      R12(1) = 1.47D0
      R12(3) = 1.155D0
      END IF
      IF(NA1.EQ.7.AND.NA2.EQ.6) THEN
      R12(1) = 1.47D0
      R12(3) = 1.155D0
      END IF
C
C     C-O = 1.43, C=O = 1.23, CO = 1.13
C
      IF(NA1.EQ.6.AND.NA2.EQ.8) THEN
      R12(1) = 1.43D0
      R12(2) = 1.23D0
      R12(2) = 1.13D0
      END IF
      IF(NA1.EQ.8.AND.NA2.EQ.6) THEN
      R12(1) = 1.43D0
      R12(2) = 1.23D0
      R12(2) = 1.13D0
      END IF
      RETURN
      END
C
C     ORBITAL FILTER: LOCALIZATION OF VB ORBITALS BY TRUNCATION
C
      SUBROUTINE LOCVBO(NBASIS,BASIS,NATOM,NATBAS,IOENGI,S,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION BASIS(NBASIS,*),NATBAS(*),NABAS(10000),NKATM(10)
      DIMENSION S(*),W(*),MAPVBO(20),MAPATM(1000),LATOM(20)
      NT = 0
      DO 1 I=1,NATOM
      DO 2 J=1,NATBAS(I)
      NT=NT+1
      IF (NT.GT.10000) CALL ABORT0('LOCVBO01  ')
      NABAS(NT)=I
  2   CONTINUE
  1   CONTINUE
      DO I=1, NBASIS
      MAPATM(I) = 0
      END DO
      CALL LOCTOR(IOENGI,'$LOCVBO',7,IOK,0)
      IF(IOK.EQ.0) RETURN
      READ(IOENGI,*)MODIFY
      DO I=1, MODIFY
      READ(IOENGI,*)IDXVBO,NKEEPATM,(NKATM(J),J=1,NKEEPATM)
      MAPATM(IDXVBO) = NKATM(1)
      CALL VBOTRK(NBASIS,BASIS(1,IDXVBO),NKEEPATM,NKATM,NABAS)
      END DO
C
C     OPTIONALLY CALL LOWDIN ORTHOGONALIZATION ON ATOMS SPECIFIED
C
      CALL LOCTOR(IOENGI,'$NOATMLWD',9,IOK,0)
      IF(IOK.EQ.1) RETURN
      LATOMS = NATOM
      DO I=1, NATOM
      LATOM(I) = I
      END DO
C
C
      DO NA = 1, LATOMS
      NATM = LATOM(NA)
      NAOS = 0
        DO K=1, NBASIS
        IF(MAPATM(K).EQ.NATM) THEN
        NAOS = NAOS + 1
        MAPVBO(NAOS) = K
        NAOSB = (NAOS-1)*NBASIS
        KK = (K-1)*NBASIS
          DO J=1, NBASIS
          W(J+NAOSB) = BASIS(J,K)
          END DO
        END IF
        END DO
C
      NATV = 1
      NSS= NATV + NBASIS*NBASIS
      NSA=NSS+NBASIS*NBASIS
      NV =NSA+NBASIS*NBASIS
      NW =NV +NBASIS*NBASIS
C     NWK=NW +NBASIS*NBASIS
C
C     S->W(NSS)
C
      DO 200 I=1,NBASIS
      II=NSS-1+(I-1)*NBASIS
      DO 200 J=1,NBASIS
      W(II+J)=S(IJ00(I,J))
 200  CONTINUE
C
C     Lowdin orthogonalization of all VBOs on the atom
C
      CALL LOWD(NBASIS,NAOS,W(NSS),W,W(NSA),W(NV),W(NW),IERR)
      IF(IERR.EQ.1) CALL ABORT0('LOCVBO01  ')
C
C     COPY W TO BASIS
C
        DO K=1, NAOS
        KK = NV-1+(K-1)*NBASIS
        NAOSB = (MAPVBO(K)-1)*NBASIS
          DO J=1, NBASIS
          BASIS(J,MAPVBO(K)) = W(KK+J)
          END DO
        END DO
      END DO
      RETURN
      END
      SUBROUTINE VBOTRK(NBASIS,V,NKATMS,NATMS,NABAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION V(*),NATMS(*),NABAS(*)
      DO I=1, NBASIS
      IATM  = NABAS(I)
      KPATM = 0
         DO J=1,NKATMS
         IF(NATMS(J).EQ.IATM) KPATM=1
         END DO
      IF(KPATM.NE.1) V(I) = 0.0D0
      END DO
      END
      SUBROUTINE COMBIN(N,M,NB,NM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MAXST1=33334)
      DIMENSION NB(M+1,*),ITEMP(100)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      NM=0
      IF(M.LT.N) RETURN
      NM=1
      NB(M+1,1)=M
      DO I=1,N
      KNM=NM
      DO K=1,NM
      NLASTP=NB(M+1,K)
      NILAST=NLASTP-N+I
      DO J=I+1,NILAST
      KNM=KNM+1
        DO L=1,M
        ITEMP(L) =NB(L,K)
        END DO
        DO L=I,J-1
        ITEMP(M+L-I+1) =NB(L,K)
        END DO
        NSHIFT=J-I
        DO L=J,M+NSHIFT
        ITEMP(L-NSHIFT) =ITEMP(L)
        END DO
        ITEMP(M+1) =NB(M+1,K)-NSHIFT
        DO JJ=1,M+1
        NB(JJ,KNM) = ITEMP(JJ)
        END DO
      END DO
      END DO
      NM=KNM
      END DO
C     IF((M+1)*NM.GT.MAXST1) THEN
C       WRITE(IOUTVB,*)'TOO MANY RUMER PATTERNS, STOP'
C       WRITE(IOUTVB,
C    &   '(" YOU NEED TO INCREASE MAXST1 TO MORE THAN ",I7)') (M+1)*NM
C      CALL ABRTVB
C     END IF
      IF((M+1)*NM.GE.MAXST1) CALL SIZEABT((M+1)*NM,MAXST1,
     & "RUMER DATA  ","MAXST1",IOUTVB,.TRUE.)
      RETURN
      END
      SUBROUTINE SETCASVB(MELE,MSPIN,NSTR,NPHI,MORB,MGRP,LPRT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MAXST1=33334)
      DIMENSION NPHI(*),NA(MAXST1),NB(MAXST1),NC(MAXST1)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
C     CHARACTER*50 FLAG
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DO I=1,MORB
      NA(I)=I
      NB(I)=I
      NC(I)=I
      END DO
C
C     SET DEFAULT VALUES
C
      NSTR=0
      IF(MELE.GT.MORB*2) RETURN
C     MOBMIM=(MELE-MSPIN)/2+MSPIN
C     MOBMAX=MELE
      NDMAX=(MELE-MSPIN)/2
      NDMIN=MELE-MORB
      IF(NDMIN.LT.0) NDMIN=0
C     WRITE(6,'(" NDMIN,NDMAX",2I5)') NDMIN,NDMAX
      DO ND=NDMIN,NDMAX
      NRE=MELE-ND*2
      MND=MORB-ND
      CALL COMBIN(ND,MORB,NA,NM1)
      CALL COMBIN(NRE,MND,NB,NM2)
      CALL RUMERVB(NRE,MSPIN,NC,MAXST1,NM3)
C     WRITE(6,'(" B GENSTR - MORB,MND,NRE,ND,NM1,NM2,NM3",10I5)') 
C    & MORB,MND,NRE,ND,NM1,NM2,NM3
      CALL GENSTR(MELE,NPHI,MORB,MND,NRE,ND,NA,NB,NC,NM1,NM2,NM3,NSTR)
C     WRITE(6,'(" B GENSTR - MORB,MND,NRE,ND,NM1,NM2,NM3",10I5)') 
C    & MORB,MND,NRE,ND,NM1,NM2,NM3
      END DO
      IF(LPRT.EQ.1) THEN
      WRITE(IOUTVB,1300)MGRP
      DO 110 I=1,NSTR
      I1=(I-1)*MELE
 110  WRITE(IOUTVB,1400)I,(NPHI(I1+J),J=1,MELE)
      WRITE(IOUTVB,*)
CGMS  CALL FLSHBF(IOUTVB)
      END IF
 1300 FORMAT(/1X,'SYMBOLIC VB STRUCTURE(S) OF GROUP',I3,/
     1       1X,'STR. NO.       RUMER PATTERN  ')
 1400 FORMAT(1X,I5,'      ',20(I4,I3))
      RETURN
      END
      SUBROUTINE GENSTR(MELE,NPHI,M,MND,NRE,ND,NA,NB,NC,M1,M2,M3,NSTR)
      DIMENSION NPHI(MELE,*),NA(M+1,*),NB(MND+1,*),NC(NRE,*)
      DIMENSION NW1(1000),NW2(1000)
      DO I=1,M1
        DO L=1,MND
        NW1(L)=NA(ND+L,I)
        END DO
      DO J=1,M2
        DO L=1,NRE
        NW2(L)=NW1(NB(L,J))
        END DO
      DO K=1,M3
      NSTR=NSTR+1
      IF(NSTR*MELE.GT.33334) CALL ABORT0("TOOMANYVB!")
        DO L=1,ND
        NPHI(L+L-1,NSTR)=NA(L,I)
        NPHI(L+L  ,NSTR)=NA(L,I)
        END DO
        DO L=1,NRE
        NPHI(ND*2+L,NSTR)=NW2(NC(L,K))
        END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE SETSCVB(MELE,MSPIN,NSTR,NPHI,NOB,EPS,MAXIT,
     &                 NEWTON,NOPT,MLORBIT,MGRP,FLAG,LPRT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MAXST1=33334)
      DIMENSION NPHI(*),NA(MAXST1),NB(MAXST1),NC(MAXST1),NOB(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*50 FLAG
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      CALL GETIOUNIT('IOENGI  ',IOENGI)
C
C     SET DEFAULT VALUES
C
      NOPT=MLORBIT
      DO I=1,MLORBIT
      NOB(I)=I
      END DO
      NEWTON=1
      EPS   =1.0D-4
      MAXIT =15
C100  CONTINUE
      DO I=1,MLORBIT
      NA(I)=I
      NB(I)=I
      NC(I)=I
      END DO
C
C     SET DEFAULT VALUES
C
      NSTR=0
      IF(MELE.GT.MLORBIT*2) RETURN
C     MOBMIM=(MELE-MSPIN)/2+MSPIN
C     MOBMAX=MELE
C     NDMAX=(MELE-MSPIN)/2
      NDMIN=MELE-MLORBIT
      IF(NDMIN.LT.0) NDMIN=0
      ND = NDMIN
      NRE=MELE-ND*2
      MND=MLORBIT-ND
      CALL COMBIN(ND,MLORBIT,NA,NM1)
      CALL COMBIN(NRE,MND,NB,NM2)
      CALL RUMERVB(NRE,MSPIN,NC,MAXST1,NM3)
      CALL GENSTR(MELE,NPHI,MLORBIT,MND,NRE,ND,NA,NB,NC,NM1,
     &                                         NM2,NM3,NSTR)
C200  CONTINUE
      IF(LPRT.EQ.1) THEN
      WRITE(IOUTVB,1300)MGRP
      DO 110 I=1,NSTR
      I1=(I-1)*MELE
 110  WRITE(IOUTVB,1400)I,(NPHI(I1+J),J=1,MELE)
      WRITE(IOUTVB,*)
CGMS  CALL FLSHBF(IOUTVB)
      END IF
C
C     READ SCF CONTROL
C
      CALL LOCTOR(IOENGI,'$VBSCF',6,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*)EPS,MAXIT
      END IF
      FLAG(4:10)='SCVBSCF'
      CALL LOCTOR(IOENGI,FLAG,10,IOK,0)
      IF(IOK.EQ.1) THEN
       READ(IOENGI,*)EPS,MAXIT
      ELSE
       CALL LOCTOR(IOENGI,'$SCVBSCF',8,IOK,0)
       IF(IOK.EQ.1) THEN
       READ(IOENGI,*)EPS,MAXIT
       END IF
      END IF
 1300 FORMAT(/1X,'SYMBOLIC VB STRUCTURE(S) OF GROUP',I3,/
     1       1X,'STR. NO.       RUMER PATTERN  ')
 1400 FORMAT(1X,I4,'        ',15(I4,I3))
      RETURN
      END
      SUBROUTINE RUMERVB(N,NS,NTAB,NW,NRUM)
      DIMENSION NTAB(N,*),NTAB0(100)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      NRUM=1
      IF(N.LE.0) RETURN
      DO I=1,N
      NTAB0(I)=NTAB(I,1)
      END DO
      NWN=NW/N
      DO I=1,NWN
      DO J=1,N
      NTAB(J,I)=0
      END DO
      END DO
      NTAB(1,1)=1
      NH=(N+NS)/2
      DO 100 I=2,N
      NRUMER=NRUM
      DO 110 J=1,NRUM
C
C     CHECK NALPHA,NBETA
C
      NA=0
      NB=0
      DO 120 K=1,NH-NS
      IF(NTAB(K+K-1,J).NE.0) NA=NA+1
      IF(NTAB(K+K,J).NE.0) NB=NB+1
  120 CONTINUE
      DO 125 K=N-NS+1,N
      IF(NTAB(K,J).NE.0) NA=NA+1
  125 CONTINUE
      IF(NA.EQ.NB) THEN
      NTAB(I,J)=I
      ELSE
        IF(NA.GE.NH) THEN
        NTAB(NB+NB+2,J)=I
        ELSE IF(NB.GE.NH-NS) THEN
        NTAB(I,J)=I
        ELSE
        NRUMER=NRUMER+1
        IF(NRUMER.GT.NWN) THEN
        WRITE(IOUTVB,*)'TOO MANY RUMER PATTERNS, STOP'
        CALL ABRTVB
        END IF
        DO 130 L=1,N
  130   NTAB(L,NRUMER)=NTAB(L,J)
        NTAB(NB+NB+2,J)=I
          IF(NA.GE.NH-NS) THEN
          NTAB(NA+NH-NS+1,NRUMER)=I
          ELSE
          NTAB(NA+NA+1,NRUMER)=I
          END IF
        END IF
      END IF
  110 CONTINUE
      NRUM=NRUMER
  100 CONTINUE
      DO 150 I=1,NRUM
      DO 150 J=1,N
  150 NTAB(J,I)=NTAB0(NTAB(J,I))
      RETURN
      END
      SUBROUTINE SETVB(MELE,NSTR,NPHI,NOB,EPS,MAXIT,
     &                 NEWTON,NOPT,MLORBIT,MITER,MGRP,FLAG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPHI(*),NOB(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      CHARACTER*50 FLAG
      CALL GETIOUNIT('IOENGI  ',IOENGI)
C
C     SET DEFAULT VALUES
C
      NSTR=1
      NDB=0
      IF(MELE.GT.MLORBIT) THEN
      NDB=MELE-MLORBIT
         DO I=1,NDB
         NPHI(I+I-1)=I
         NPHI(I+I)  =I
         END DO
      END IF
      NDD=NDB*2
      DO I=NDD+1,MELE
      NPHI(I)=I-NDB
      END DO
      NOPT=MLORBIT
      DO I=1,MLORBIT
      NOB(I)=I
      END DO
      NEWTON=1
      EPS   =1.0D-3
      MAXIT =15
      FLAG(4:8)='VBSTR'
C
C     READ PARAMETERS OF VB STRUCTURES
C
      CALL LOCTOR(IOENGI,FLAG,8,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*,ERR=101) NSTR
C
C     READ VB STRUCTURES
C
      DO 100 I=1,NSTR
      I1=(I-1)*MELE
 100  READ(IOENGI,*,ERR=101,END=101)(NPHI(I1+J),J=1,MELE)
      END IF
      GOTO 102
 101  WRITE(IOUTVB,*)"INPUT ERROR IN VBSTR"
      CALL ABORT0("SETVB00001")
 102  CONTINUE
      IF(MITER.EQ.1) THEN
      WRITE(IOUTVB,1300)MGRP
      DO 110 I=1,NSTR
      I1=(I-1)*MELE
 110  WRITE(IOUTVB,1400)I,(NPHI(I1+J),J=1,MELE)
      WRITE(IOUTVB,*)
CGMS  CALL FLSHBF(IOUTVB)
      END IF
C
C     READ VBSCF
C
      FLAG(4:8)='VBSCF'
      CALL LOCTOR(IOENGI,FLAG,8,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*)EPS,MAXIT
      IF (MITER.EQ.1) WRITE(IOUTVB,1500) FLAG(1:8),EPS,MAXIT
      ELSE
      CALL LOCTOR(IOENGI,'$VBSCF',6,IOK,0)
       IF(IOK.EQ.1) THEN
       READ(IOENGI,*)EPS,MAXIT
       IF (MITER.EQ.1) WRITE(IOUTVB,1501) EPS,MAXIT
       END IF
      END IF
 1300 FORMAT(/1X,'SYMBOLIC VB STRUCTURE(S) OF GROUP',I3,/
     1       1X,'STR. NO.       RUMER PATTERN  ')
 1400 FORMAT(1X,I4,'        ',15(I4,I3))
 1500 FORMAT(1X,A8," VALUES ARE EPS =",F11.8," AND MAXIT =",I3)
 1501 FORMAT(" $VBSCF VALUES ARE EPS =",F11.8," AND MAXIT =",I3)
      RETURN
      END
      SUBROUTINE READ1E(IAO1E,S,H,NBASIS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION S(*),H(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE,FILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      PARAMETER (MAXBFN=726)
      PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA,MAXGRP=99)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(MAXGRP),MSPIN(MAXGRP),MNORBIT(MAXGRP),
     &MLORBIT(MAXGRP),MWIN(MAXGRP),MSTR(MAXGRP),METHOD(MAXGRP),
     &IBASIS(MAXEXT),NOCC(MAXEXT),NOBIAS,NEPS,NVIR,NOTROT(5000),
     &LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(MAXGRP)
      NBA2=NBASIS*(NBASIS+1)/2
C
C     THIS IS THE FIRST ENTRY FOR 1E INTEGRAL ROUTINES
C     THERE ARE THREE OPTIONS:
C
C     1  GAUSSIAN
C     2  GAMESS
C     3  DEFAULT
C
      GO TO (3,2,3,4),ICON
C     CASE 2: GAMESS
  2   CONTINUE
CGMS  CALL RGMS1E(S,H,NBASIS)
      GOTO 10
C     CASE 1: GAUSSIAN
C     CASE 3: DEFAULT
  3   FILE=FSTR(1:LENFIL)//'.'//FUNIT(1)
      OPEN(UNIT=IAO1E,FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      REWIND(IAO1E)
      READ(IAO1E)NBA2
      READ(IAO1E)(S(I),I=1,NBA2)
      READ(IAO1E)(H(I),I=1,NBA2)
      CLOSE(IAO1E)
      GOTO 10
C     CASE 4: SMILES
  4   CONTINUE
      WRITE(IOUTVB,*)"RSMI1E"
CSMI  CALL RSMI1E(S,H,NBASIS)
 10   CONTINUE
C     DEBUG - Write out S and H
C     WRITE(IOUTVB,13)
C13   FORMAT(/,' S MATRIX'/)
C     WRITE(IOUTVB,11) (S(I),I=1,NBA2)
C     WRITE(IOUTVB,14)
C14   FORMAT(/,' H MATRIX'/)
C     WRITE(IOUTVB,11) (H(I),I=1,NBA2)
C11   FORMAT(5F12.6)
C
C     CALL FOR POSSIBLE CORRECTION WITH SCRF
C
CGMS  ISOL=0
CGMS  CALL ADDRF(H,NBASIS,ISOL)
C
      RETURN
      END
C
      SUBROUTINE READ2E(IAO2E,G)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION G(*)
      PARAMETER (MAXBFN=726)
      PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA,MAXGRP=99)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(MAXGRP),MSPIN(MAXGRP),MNORBIT(MAXGRP),
     &MLORBIT(MAXGRP),MWIN(MAXGRP),MSTR(MAXGRP),METHOD(MAXGRP),
     &IBASIS(MAXEXT),NOCC(MAXEXT),NOBIAS,NEPS,NVIR,NOTROT(5000),
     &LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(MAXGRP)
C     CHARACTER*3 FUNIT(10)
C     CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
C     COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
C     THIS IS THE FIRST ENTRY FOR 2E INTEGRAL ROUTINES
C     THERE ARE THREE OPTIONS:
C
C     1  GAUSSIAN
C     2  GAMESS
C     3  DEFAULT
C     4  SMILES
C
      GO TO (1,2,3,4),ICON
C     CASE 1: GAUSSIAN
  1   CONTINUE
CGAU  CALL RGAU2E(IAO2E,G)
      RETURN
C     CASE 2: GAMESS
  2   CONTINUE
CGMS  CALL RGMS2E(G)
      RETURN
C     CASE 3: DEFAULT
  3   CONTINUE
C000  CALL RD2E00(IAO2E,G)
C     CASE 4: SMILES
  4   CONTINUE
CSMI  CALL RSMI2E(G)
      IF(IAO2E.GT.1000000) WRITE(*,*)IAO2E
      RETURN
      END
      SUBROUTINE IJKLGG(IAO2E,GG,II,JJ,KK,LL,NINT)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION GG(*),II(*),JJ(*),KK(*),LL(*)
C     CHARACTER*3 FUNIT(10)
C     CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
C     COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
C     READ A RECORD OF 2E INTEGRALS
C     THE LAST RECORD SHOULD SET NINT TO ZERO
C
C     Integrals for default stand-alone version
C000  CALL IJKLG0(IAO2E,GG,II,JJ,KK,LL,NINT)
C
C     Integrals for Gamess(US) version.
CGMS  CALL IJKLG1(GG,II,JJ,KK,LL,NINT)
C
C     Integrals for Gaussian version.
CGAU  CALL IJKLG0(IAO2E,GG,II,JJ,KK,LL,NINT)
C
C     Integrals for SMILES version.
CSMI  CALL IJKLG3(GG,II,JJ,KK,LL,NINT)
      IF(IAO2E.GT.1000000) WRITE(*,*)IAO2E
      RETURN
      END
      SUBROUTINE RDMORB(IOHFORB,V,E,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE,FILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      PARAMETER (MAXBFN=726)
      PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA,MAXGRP=99)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(MAXGRP),MSPIN(MAXGRP),MNORBIT(MAXGRP),
     &MLORBIT(MAXGRP),MWIN(MAXGRP),MSTR(MAXGRP),METHOD(MAXGRP),
     &IBASIS(MAXEXT),NOCC(MAXEXT),NOBIAS,NEPS,NVIR,NOTROT(5000),
     &LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(MAXGRP)
      DIMENSION V(*),E(*)
C
C     THIS IS THE FIRST ENTRY TO READ MOs
C     THERE ARE THREE OPTIONS:
C
C     1  GAUSSIAN
C     2  GAMESS
C     3  DEFAULT
C
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(3)
      OPEN(UNIT=IOHFORB,FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      GO TO (3,2,3,3),ICON
C     CASE 2: GAMESS
  2   CONTINUE
CGMS  CALL RGMSMO(V,E,N)
      RETURN
C     CASE 1: GAUSSIAN
C     CASE 3: DEFAULT
C     CASE 4: SMILES
  3   REWIND(IOHFORB)
      READ(IOHFORB)NB,(NOCC(I),I=1,NB)
      READ(IOHFORB)(E(I),I=1,NB)
      READ(IOHFORB)(V(I),I=1,NB*N)
      CLOSE(IOHFORB)
      RETURN
      END
      SUBROUTINE SHREAD(S,H,MSQ,IOSH)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     PARAMETER (NBF=10000)
      DIMENSION S(*),H(*)
      REWIND (IOSH)
      READ(IOSH)(S(I),I=1,MSQ)
      READ(IOSH)(H(I),I=1,MSQ)
      RETURN
      END
      SUBROUTINE GREAD(G,MSQ,NBF,IOVB2E)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     PARAMETER (NBF=10000)
      DIMENSION G(*)
      REWIND (IOVB2E)
      READ(IOVB2E)
      READ(IOVB2E)
      MX=0
      NRE=(MSQ+NBF-1)/NBF
      DO 100 I=1,NRE
      NNN=NBF
      IF(I.EQ.NRE) NNN=MSQ-NRE*NBF+NBF
      READ(IOVB2E)(KKK,G(KKK),J=1,NNN)
      MX=MX+NBF
  100 CONTINUE
      RETURN
      END
      SUBROUTINE GWRTE(G,MSQ,LBUFF,IOVB2E)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION G(*)
      REWIND (IOVB2E)
      READ(IOVB2E)
      READ(IOVB2E)
      MX=0
      NRE=(MSQ+LBUFF-1)/LBUFF
      DO 100 I=1,NRE
      NNN=LBUFF
      IF(I.EQ.NRE) NNN=MSQ-NRE*LBUFF+LBUFF
      WRITE(IOVB2E)(MX+J,G(MX+J),J=1,NNN)
      MX=MX+LBUFF
  100 CONTINUE
      RETURN
      END
      SUBROUTINE DISLMO(NBASIS,NSUB,MLORBIT,ISPLIT,NGP,
     &    NATOMS,NAO,V,WK,PGM,DISCON,BONDLAB,VBOLAB)
C----------------------------------------------------------------------------
C     GENERATE INITIAL ORBITALS FOR VB CALCULATION.
C     VBMO ARE GENERATED FROM LMO's BY DISTORTION.
C     NSUB:      NUMBER OF SUBUNITS
C     MELE(I):   NUMBER OF ELECTRONS OF EACH SUBUNIT.
C     METHOD(I): METHOD FOR TREATING EACH SUBUNIT
C     MLORBIT(I):NUMBER OF ORBITALS OF EACH SUBUNIT
C     ISPLIT(I): SWITCH OF SPLITING
C                =0, DO NOT SPLIT
C                =M, SPLIT THE LMO INTO M+1 VB ORBITALS
C     NGP(I):   INDEX OF A LMO INDICATING WHICH SUBUNIT  IT BELONGS TO.
C     NATOMS:   NUMBER OF ELECTRONS
C     NLOCAL:	NUMBER OF LOCALIZED ORBITALS
C     V:        LOCALIZED MO COEFFICIENTS
C     PGM:      MULLIKEN POLULATION ANALYSIS OF NLOCAL ORBITALS
C     WK:       WORK FILED
C     NBASIS:   DIMENSION OF MO
C     DISCON:   DISTORTION PARAMETERS (AN ARBITARY VALUE 0.0-1.0)
C               Default=1.0, Maximum distortion.
C               0.0, no distortion.
C     NAO:      NUMBER OF ATOMIC BASIS FUNCTIONS FOR EACH ATOM
C
C     Created by Jiabo Li, June, 1998
C     (first version)
C     Revised by Jiabo Li, Feb., 2000
C     (a LMO can be splited into many VB orbitals)
C     Revised by Jiabo Li, July, 2000
C     (3-center-2-electron bonds can be treated automatically)
C----------------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*8 VBOLAB(*),BONDLAB(*)
      PARAMETER (MAXFIL=50000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION WK(NBASIS,*),V(NBASIS,*),MLORBIT(*),PGM(NATOMS,*)
      DIMENSION NA(5000),NAO(*),ISPLIT(*),NGP(*)
      DIMENSION NWA(1000),WPGM(1000),NWK(1000),FILTER(MAXFIL)
      DIMENSION NPT(4),NGATM(1000)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      IF(NATOMS.GT.1000) CALL ABORT0('DISLMO01  ')
      IF(NATOMS*(NBASIS+20).GT.MAXFIL) THEN
        WRITE(IOUTVB,*)"NATOMS*NBASIS .GT. 50000"
        CALL ABORT0('DISLMO02  ')
      END IF
      DO I=1,1000
      NWK(I) = -1
      END DO
      DO I=1,NATOMS*(NBASIS+20)
      FILTER(I)=1.0D0
      END DO
      NT=0
      DO 1 I=1,NATOMS
      DO 2 J=1,NAO(I)
      NT=NT+1
      NA(NT)=I
  2   CONTINUE
  1   CONTINUE
      NBG=0
      DO 100 L=1,NSUB
      MBG=0
      DO 120 K=1,NBASIS
C
C     SET UP DEFAULT FOR LMO SPLIT PARTIONING
C
      DO I=1,4
      NPT(I)=1
      END DO
      IF(NGP(K).NE.L) GOTO 120
      RAT = 0.0D0
      IF(ISPLIT(K).EQ.0) THEN
C
C     Do not split
C
        MBG=MBG+1
        NWK(NBG+MBG)=K
        VBOLAB(NBG+MBG) = BONDLAB(K)
      ELSE
C
C     SPLIT LMO BY DISTORTION OF THE LMO
C
C     STEP 1: SORT ATOMS WITH THE LARGEST MULLIKEN CHARGES
        DO J=1,NATOMS
        WPGM(J)=PGM(J,K)
        END DO
        CALL SHELL(WPGM,NWA,NATOMS)
        NAHALF=NATOMS/2
        DO J=1,NAHALF
        NAJ=NWA(J)
        NWA(J)=NWA(NATOMS-J+1)
        NWA(NATOMS-J+1)=NAJ
        END DO
C
C     NOW, NWA(*) HOLD THE SORTED ATOM LIST STARTING WITH THE
C     LARGEST MULLIKEN CHARGE
C
C     STEP 2: SET UP PARTITIONING OF THE ATOM LIST
C
C     CONSIDER POSSIBLE THREE-CENTER-TWO-ELECTRON BONDS
C
      IF(NATOMS.GE.3.AND.PGM(NWA(2),K).GT.0.3D0
     &  .AND.PGM(NWA(3),K)/PGM(NWA(2),K).GT.0.95D0) NPT(2)=2
      NTMP=0
      DO KK=1,NATOMS
      NGATM(KK)=0
      END DO
      DO K4=1,4
       DO KK=1,NPT(K4)
       NTMP=NTMP+1
C
C      EARLY EXIT
C
       IF(NTMP.GT.NATOMS) GOTO 111
       NGATM(NWA(NTMP))=K4
       END DO
      END DO
 111  CONTINUE
C
C     STEP 3: DISTORTION OF LMO
        DO KK=1,ISPLIT(K)+1
        RAT=PGM(NWA(KK),K)/PGM(NWA(1),K)
        NWK(NBG+MBG+KK)=K
        VBOLAB(NBG+MBG+KK) = BONDLAB(K)
        MMK=(NBG+MBG+KK-1)*NATOMS
        DO J=1,NATOMS
        FACT=1.0D0-DISCON
        IF(NGATM(J).EQ.KK) FACT=1.0D0+DISCON
        FILTER(MMK+J)=FACT
        END DO
      END DO
      MBG=MBG+1+ISPLIT(K)
C
C     IF THE RAT IS VERY SMALL, THEN THE ORBITAL IS ALMOST A LONE PAIR
C     AND ONLY ONE ORBITAL SHOULD BE GENERATED. IF THE FOLLOWING MESSAGE
C     IS PRINTED, THE SETTING IS LIKELY BE WRONG
C
      IF(RAT.LT.0.1D0) WRITE(IOUTVB,1000)K
 1000 FORMAT(' WARNING: you are splitting a lone-pair LMO(',I3,')')
      END IF
      RATD=RAT
      IF(RATD.LT.0.1D0) RATD=0.1D0
      IF(MBG.GE.MLORBIT(L)) GOTO 110
 120  CONTINUE
C     IF(MBG.NE.MLORBIT(L)) WRITE(IOUTVB,*)"WARNING: VBORB INPUT IS NEEDED"
 110  NBG=NBG+MLORBIT(L)
 100  CONTINUE
C
C     Operate with the filter
C
      DO I=1,NBG
      II=(I-1)*NATOMS
      IF( NWK(I).GT.0) THEN
        DO J=1,NBASIS
        NAJ=NA(J)
        WK(J,I)=FILTER(II+NAJ)*V(J,NWK(I))
        END DO
      ELSE
        WRITE(IOUTVB,1002)I
C
C     GENERATE ARBITRARY VECTORS FOR VIRTUAL ORBITALS
C
        DO J=1,NBASIS
          WK(J,I)=VBRAND(0)
        END DO
C
      END IF
      END DO
C
C     WK-->V
C
      DO 210 J=1,NBASIS
      DO 200 I=1,NBG
      V(J,I)=WK(J,I)
 200  CONTINUE
C     WRITE(IOUTVB,1001)(V(J,I),I=1,NBG)
 210  CONTINUE
C1001 FORMAT(6F12.6)
 1002 FORMAT(' WARNING: Initial orbital',I3, ' undefined from DISLMO'/
     &       ' Initial orbital',I3, ' by an arbitrary vector')
      RETURN
      END
      SUBROUTINE EXPAND(VECT,CONSTR,ICONST,NPAR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION VECT(*),CONSTR(*),ICONST(*),V(5000)
      DO I=1,NPAR
      IF(ICONST(I).GT.0) THEN
      V(I)=CONSTR(I)*VECT(ICONST(I))
      ELSE
      V(I)=0.0D0
      END IF
      END DO
      DO I=1,NPAR
      VECT(I)=V(I)
C     WRITE(IOUTVB,'(I4,F12.8)')I,VECT(I)
      END DO
      RETURN
      END
      SUBROUTINE ZHESS(HESS,NSTR,CSTR,NBRIL,DEV1)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION HESS(*),CSTR(*),DEV1(*)
      SUM=0.0D0
      DO I=1,NSTR
      SUM=SUM+DEV1(NBRIL+I)**2
      END DO
      SUM=DSQRT(SUM/NSTR)
C     SCALE=2.0D0*SUM
      DO I=1,NSTR
      II=(NBRIL+I-1)*(NBRIL+I)/2
      DO J=1,I
      IJ=II+NBRIL+J
      HESS(IJ)=HESS(IJ)+CSTR(I)*CSTR(J)
      END DO
      END DO
      RETURN
      END
      SUBROUTINE BRIMASK(HESS,NSTR,NBRIL,DEV1,MASKBRI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION HESS(*),DEV1(*),MASKBRI(*)
      DO I=1, NBRIL
      II = I*(I-1)/2
      IF(MASKBRI(I).EQ.0) THEN
          DO J=1, I-1
          IJ = II+ J
          HESS(IJ)= 0.0D0
          END DO
          DO J=I+1,NBRIL+NSTR
          IJ=J*(J-1)/2+I
          HESS(IJ)= 0.0D0
          END DO
          HESS(II+I) = 1.0D0
          DEV1(I) = 0.0D0
      END IF
      END DO
      RETURN
      END
      SUBROUTINE CONDEN(HESS,HESSW,DEV1,DEV,NPAR,NONLIN,IDERANK,
     &       IOHES,CONSTR,ICONST)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE,FILE
      CHARACTER*3 FUNIT(10)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION HESS(*),DEV1(*),CONSTR(*),ICONST(*)
      DIMENSION HESSW(*),DEV(*)
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      NSQ2=NONLIN*(NONLIN+1)/2
C
C     IF (IDERANK.EQ.1), ONLY DEV1 IS CONDENSED
C
      DO I=1,NONLIN
      DEV(I)=0.0D0
      END DO
      DO I=1,NPAR
      II=ICONST(I)
      IF(II.GT.0) DEV(II)=DEV(II)+CONSTR(I)*DEV1(I)
      END DO
      IF(IDERANK.LE.1) THEN
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(8)
      OPEN(UNIT=IOHES,FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      REWIND(IOHES)
      READ(IOHES)(HESS(I),I=1,NSQ2)
      CLOSE(IOHES)
      RETURN
      END IF
      DO I=1,NSQ2
      HESSW(I)=0.0D0
      END DO
      IJ=0
      DO I=1,NPAR
      II=ICONST(I)
      DO J=1,I
      IJ=IJ+1
      JJ=ICONST(J)
      IF(II.GT.0.AND.JJ.GT.0) THEN
      IIJJ=IJ00(II,JJ)
      FACTOR=1.0D0
      IF(II.EQ.JJ.AND.I.NE.J) FACTOR=2.0D0
      HESSW(IIJJ)=HESSW(IIJJ)+CONSTR(I)*CONSTR(J)*HESS(IJ)*FACTOR
      END IF
      END DO
      END DO
      IJ=0
      DO I=1,NONLIN
      DO J=1,I
      IJ=IJ+1
      HESS(IJ)=HESSW(IJ)
      END DO
      END DO
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(8)
      OPEN(UNIT=IOHES,FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      REWIND(IOHES)
      WRITE(IOHES)(HESS(I),I=1,NSQ2)
      CLOSE(IOHES)
      RETURN
      END
      SUBROUTINE RCONST(CONSTR,ICONST,NBRI,NPAR,NLORBI,NLCSTR,FLAG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MAXPAR=10000)
      CHARACTER*50 FLAG
      DIMENSION CONSTR(*),ICONST(*),MAPCON(MAXPAR)
C     IOENGI = 80
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      IF(NPAR.GT.MAXPAR) CALL ABORT0("RCONST0001")
C
C     SET DEFAULT VALUES
C
      DO I=1,NPAR
      ICONST(I)=I
      CONSTR(I)=1.0D0
      MAPCON(I)=0
      END DO
C
C     Since the zero eigen problem of linear depencency is fixed,
C     the following line is commented out.
C
C     ICONST(NBRI+1)=0
      FLAG(4:8)='CONST'
      CALL LOCTOR(IOENGI,FLAG,8,IOK,0)
      IF(IOK.EQ.1) THEN
C
C     READ EQUIVALENT CONSTRAINTS
C     I.E. C(IND)=CONSTR(IND).*C(ICONST(IND))
C     FOR INSTRANCE, 5,-1,4
C     MEANS C(5)=-1.0*C(4)
C
C     4,1,0 MEANS THAT C(4) IS FIXED  (I.E. NOT OPTIMIZED)
C
      READ(IOENGI,*)NP
      READ(IOENGI,*)(IND,CONSTR(IND),ICONST(IND),J=1,NP)
      END IF
C
C     SETUP NEW INDEX FOR ALL LINEARLY INDEPENDENT PARAMETERS
C
      NCOUNT=0
      DO I=1,NPAR
      IF(ICONST(I).GT.0.AND.MAPCON(ICONST(I)).EQ.0) THEN
      NCOUNT=NCOUNT+1
      MAPCON(ICONST(I))=NCOUNT
      END IF
      IF(I.EQ.NBRI) NLORBI=NCOUNT
      IF(ICONST(I).GT.0) ICONST(I)=MAPCON(ICONST(I))
      END DO
      NLCSTR=NCOUNT-NLORBI
      RETURN
      END
      SUBROUTINE STRSYM(CSTR,NSTR,FLAG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*50 FLAG
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION CSTR(*)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      FLAG(4:8)='STRSY'
      CALL LOCTOR(IOENGI,FLAG,8,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*)NP
      DO I=1,NP
      READ(IOENGI,*)IA,FACTOR,IB
      IF(IA.GT.NSTR.OR.IB.GT.NSTR) WRITE(IOUTVB,*)"WRONG DATA!!!"
      CSTR(IA)=CSTR(IB)*FACTOR
      END DO
      END IF
      RETURN
      END
      SUBROUTINE RDGUES(NBASIS,BASIS,IOUNIT,IOENGI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION BASIS(NBASIS,*)
      CHARACTER*20 FILEGUESS
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      CALL LOCTOR(IOENGI,'$READGUESS',10,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*)FILEGUESS
      OPEN(IOUNIT,FILE=FILEGUESS,STATUS='OLD')
      READ(IOUNIT,2000)NBA,NORB
      IF(NBA.NE.NBASIS.OR.NORB.GT.NBASIS) THEN
        WRITE(IOUTVB,*)"INITIAL GUESS FILE IS NOT CORRECT"
        WRITE(IOUTVB,*)"PLEASE CHECK NBASIS AND NORB IN YOUR GUESS FILE"
        CALL ABORT0('RDGUESS01 ')
      ELSE
        WRITE(IOUTVB,'(" READING INITIAL GUESS FROM ",A20)') FILEGUESS
      END IF
      DO J=1,NORB
        READ(IOUNIT,1000) (BASIS(I,J),I=1,NBASIS)
      END DO
      CLOSE(IOUNIT)
      END IF
      RETURN
 1000 FORMAT(8F9.5)
 2000 FORMAT(2I5)
      END
      SUBROUTINE WTGUES(NBASIS,BASIS,NORB,IOUNIT,IOENGI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION BASIS(NBASIS,*)
      CHARACTER*20 FILEGUESS
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      CALL LOCTOR(IOENGI,'$WRITEGUESS',11,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*)FILEGUESS
      OPEN(IOUNIT,FILE=FILEGUESS,STATUS='UNKNOWN')
      WRITE(IOUNIT,2000)NBASIS,NORB
      DO J=1,NORB
      WRITE(IOUNIT,1000)(BASIS(I,J),I=1,NBASIS)
      END DO
      CLOSE(IOUNIT)
      WRITE(IOUTVB,'(" WRITING GUESS TO ",A20)') FILEGUESS
      END IF
 1000 FORMAT(8F9.5)
 2000 FORMAT(2I5)
      RETURN
      END
      SUBROUTINE PIVBO(N,V,NB1ADD)
C----------------------------------------------------------------------------
C     V:        VB ORBITALS
C     N:        DIMENSION OF MO
C     NB1ADD:   STARTING INDEXES OF ORBITALS OF SUBUNITS
C     NATOMS:   NUMBER OF ATOMS
C----------------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*8 BONDLAB(*),VBOLAB(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION V(N,*),NB1ADD(*),NWA(100),NPI(2,1000)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      DO 100 I=1,99
 100  NWA(I)=NB1ADD(I)
      NPIORB = 0
      CALL LOCTOR(IOENGI,'$PIORB',6,IOK,0)
      IF(IOK.EQ.0) CALL LOCTOR(IOENGI,'$AOGROUP',8,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*,ERR=101)NPIORB
      READ(IOENGI,*,ERR=101)(NPI(1,I),I=1,NPIORB)
      READ(IOENGI,*,ERR=101)(NPI(2,I),I=1,NPIORB)
      END IF
      GOTO 102
 101  WRITE(IOUTVB,*)"ERROR IN $AOGROUP"
      CALL ABORT0("PIVBO00001")
 102  CONTINUE
C
C     Look for special flag $ALLAOS
C
      CALL LOCTOR(IOENGI,'$ALLAOS',7,IOK,0)
      IF(IOK.EQ.1) THEN
        NPIORB = N
        DO I=1, NPIORB
        NPI(1,I) = I
        NPI(2,I) = 1
        END DO
      END IF
C
C     PRINT AO group assignment
C
      IF (NPIORB.GT.0) THEN
      WRITE(IOUTVB,900)
      WRITE(IOUTVB,1000)(NPI(1,I),I=1,NPIORB)
      WRITE(IOUTVB,1100)(NPI(2,I),I=1,NPIORB)
      END IF
      DO I=1,NPIORB
      IDXPI=NWA(NPI(2,I))
      IDXAO=NPI(1,I)
        DO K=1,N
        V(K,IDXPI)=0.0D0
        V(IDXAO,K)=0.0D0
        END DO
      V(IDXAO,IDXPI)=1.0D0
      NWA(NPI(2,I))=NWA(NPI(2,I))+1
      END DO
      WRITE(IOUTVB,*)
  900 FORMAT(/' Group assignment of AOs'/1X,71(1H=))
 1000 FORMAT(' AO#:    ',20I3)
 1100 FORMAT(' Group#: ',20I3)
      RETURN
      END
      SUBROUTINE VBOPARSER(VBOFLAG,LSTRING,NTERMS,NVBOCODE,CTERMS,
     &                     IDXVBO,IERR)
C----------------------------------------------------------------------------
C     VBOFLAG:  INPUT STRING OF VBO FLAG
C     NTERMS:   NUMBER OF COMPONENTS IN THE VBO
C     NVBOCODE: VBO CODE FOR EACH COMPONENT
C     CTERMS:   COEFFICIENT OF EATCH TERM
C----------------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 VBOFLAG
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION NVBOCODE(5,*),CTERMS(*)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      ICURSOR = 1
      TSIGN = 0.0D0
      NTERMS = 0
C     NVBOS  = 0
      ISTEM  = 1
 100  CONTINUE
      CALL SIGNRD(VBOFLAG,LSTRING,ICURSOR,TSIGN,IERR)
C
C     READ COEF
C
      CALL COEFRD(VBOFLAG,RNUM,ICURSOR,LSTRING,INTCODE,IERR)
      IF(IERR.EQ.1.AND.NTERMS.GT.0) GOTO 200
      IF(IERR.EQ.1) THEN
      WRITE(IOUTVB,*)'ERROR POSITION = ',ICURSOR,' IN THE VBO CODE:'
      WRITE(IOUTVB,'(A80)')VBOFLAG
      CALL ABORT0('VBOPARSER1')
      ELSE
      IF (INTCODE.LT.0) RNUM = 1.0D0
      END IF
      COEFF=TSIGN*RNUM
C
C     READ VBO CODE
C
      CALL VBOCRD(VBOFLAG,ICURSOR,LSTRING,NVBOCODE(1,NTERMS+1),
     &            IERR)
C
C     CHECK IF IT IS A CONDENSED EXPRESSION.
C
      IF(IERR.EQ.0) THEN
        IF(NVBOCODE(3,NTERMS+1).LT.4.OR.NVBOCODE(3,NTERMS+1).EQ.8) THEN
        NTERMS = NTERMS+1
          IF(ISTEM.EQ.1) THEN
          IDXVBO = IDXVBO+1
          ISTEM = 0
          END IF
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        ELSE IF(NVBOCODE(3,NTERMS+1).EQ.4) THEN
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        IBDIDX = NVBOCODE(4,NTERMS)
        IF(IBDIDX.EQ.1) THEN
        IBTYPE = 1
        IBORDE = 1
        ELSE IF(IBDIDX.EQ.2) THEN
        IBTYPE = 2
        IBORDE = 1
        ELSE IF(IBDIDX.EQ.3) THEN
        IBTYPE = 2
        IBORDE = 2
        END IF
        NATOM1 = NVBOCODE(1,NTERMS)
        NATOM2 = NVBOCODE(2,NTERMS)
        NVBOCODE(3,NTERMS) = IBTYPE
        NVBOCODE(4,NTERMS) = IBORDE
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        NVBOCODE(1,NTERMS) = NATOM2
        NVBOCODE(2,NTERMS) = NATOM1
        NVBOCODE(3,NTERMS) = IBTYPE
        NVBOCODE(4,NTERMS) = IBORDE
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        ELSE IF(NVBOCODE(3,NTERMS+1).EQ.5) THEN
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        NATOM1 = NVBOCODE(1,NTERMS)
        NATOM2 = NVBOCODE(2,NTERMS)
        NVBOCODE(3,NTERMS) = 1
        NVBOCODE(4,NTERMS) = 1
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        NVBOCODE(1,NTERMS) = NATOM2
        NVBOCODE(2,NTERMS) = NATOM1
        NVBOCODE(3,NTERMS) = 1
        NVBOCODE(4,NTERMS) = 1
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
C       FIRST PI
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        NVBOCODE(1,NTERMS) = NATOM1
        NVBOCODE(2,NTERMS) = NATOM2
        NVBOCODE(3,NTERMS) = 2
        NVBOCODE(4,NTERMS) = 1
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        NVBOCODE(1,NTERMS) = NATOM2
        NVBOCODE(2,NTERMS) = NATOM1
        NVBOCODE(3,NTERMS) = 2
        NVBOCODE(4,NTERMS) = 1
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        ELSE IF(NVBOCODE(3,NTERMS+1).EQ.6) THEN
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        NATOM1 = NVBOCODE(1,NTERMS)
        NATOM2 = NVBOCODE(2,NTERMS)
        NVBOCODE(3,NTERMS) = 1
        NVBOCODE(4,NTERMS) = 1
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        NVBOCODE(1,NTERMS) = NATOM2
        NVBOCODE(2,NTERMS) = NATOM1
        NVBOCODE(3,NTERMS) = 2
        NVBOCODE(3,NTERMS) = 1
        NVBOCODE(4,NTERMS) = 1
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
C       FIRST PI
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        NVBOCODE(1,NTERMS) = NATOM1
        NVBOCODE(2,NTERMS) = NATOM2
        NVBOCODE(3,NTERMS) = 2
        NVBOCODE(4,NTERMS) = 1
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        NVBOCODE(1,NTERMS) = NATOM2
        NVBOCODE(2,NTERMS) = NATOM1
        NVBOCODE(3,NTERMS) = 2
        NVBOCODE(4,NTERMS) = 1
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
C       SECOND PI
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        NVBOCODE(1,NTERMS) = NATOM1
        NVBOCODE(2,NTERMS) = NATOM2
        NVBOCODE(3,NTERMS) = 2
        NVBOCODE(4,NTERMS) = 2
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        NTERMS = NTERMS+1
        IDXVBO = IDXVBO+1
        NVBOCODE(1,NTERMS) = NATOM2
        NVBOCODE(2,NTERMS) = NATOM1
        NVBOCODE(3,NTERMS) = 2
        NVBOCODE(4,NTERMS) = 2
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        END IF
        IF(NVBOCODE(3,NTERMS+1).EQ.7) THEN
C       TYPE 7 (MC/LMO)
        NTERMS = NTERMS+1
          IF(ISTEM.EQ.1) THEN
          IDXVBO = IDXVBO+1
          ISTEM = 0
          END IF
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        ELSE IF(NVBOCODE(3,NTERMS+1).EQ.10) THEN
C       TYPE 10 (AO)
        NTERMS = NTERMS+1
          IF(ISTEM.EQ.1) THEN
          IDXVBO = IDXVBO+1
          ISTEM = 0
          END IF
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        ELSE IF(NVBOCODE(3,NTERMS+1).EQ.11) THEN
C       TYPE 11 (MO)
        NTERMS = NTERMS+1
          IF(ISTEM.EQ.1) THEN
          IDXVBO = IDXVBO+1
          ISTEM = 0
          END IF
        NVBOCODE(5,NTERMS) = IDXVBO
        CTERMS(NTERMS) = COEFF
        ENDIF
      ELSE
        GOTO 200
      END IF
      IF(ICURSOR.LT.LSTRING.AND.IERR.EQ.0) GOTO 100
C
C     IF(NTERMS.GT.0), IGNORE THE BAD TERMS (IT COULD BE A COMMENT)
C
 200  CONTINUE
      IF(NTERMS.GT.0) IERR = 0
      RETURN
      END
      SUBROUTINE SIGNRD(VBOSTRING, LENBUF, ICURSOR, TSIGN, IERR)
C----------------------------------------------------------------------------
C     VBOSTRING:INPUT STRING OF VBO FLAG
C     ISTARTP:  STARTING POINTER
C     ISTOP:    STOPING POINTER
C     TSIGN:    SIGN (1.0 OR -1.0)
C     IERR:     ERROR CODE (0: NO ERROR, 1: ERROR)
C----------------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*1 VBOSTRING(*)
      TSIGN = 1.0D0
      ISTARTP = ICURSOR
      DO 100 I=ISTARTP,LENBUF
      IF(VBOSTRING(I).EQ.'+') THEN
      ICURSOR = I+1
      IERR = 0
      RETURN
      END IF
      IF(VBOSTRING(I).EQ.'-') THEN
      ICURSOR = I+1
      IERR = 0
      TSIGN = -1.0D0
      RETURN
      END IF
      IF(VBOSTRING(I).EQ.'('.OR.VBOSTRING(I).EQ.'['.OR.VBOSTRING(I)
     &               .EQ.'{'.OR.ISNUMBER(VBOSTRING(I)).GT.0) THEN
      ICURSOR = I
      IERR = 0
      RETURN
      END IF
      IF(VBOSTRING(I).NE.' ') THEN
      ICURSOR = I
      IERR = 1
      RETURN
      END IF
 100  CONTINUE
      RETURN
      END
      SUBROUTINE COEFRD(STRING,COEF,ICURSOR,LENBUF,INTCODE,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*1 STRING(*)
      LOGICAL ISATOM
      ISATOM = .FALSE.
      ICUR = ICURSOR
      CALL RNUMRD(STRING,RNUMBER,ICUR,LENBUF,INTCODE,IERR)
C
C     CASE 1: ERROR
C
      IF(IERR.EQ.1) RETURN
C
C     CASE 2: NO COEF, NO ERROR
C
      COEF = RNUMBER
      IF(INTCODE.EQ.-1.OR.INTCODE.EQ.0) THEN
      ICURSOR = ICUR
      RETURN
      END IF
      CALL SRCHVBOFLAG(STRING,ICUR,LENBUF,ISATOM)
      IF(INTCODE.EQ.1.AND.(.NOT.ISATOM)) THEN
      ICURSOR = ICUR
      RETURN
      ELSE
      INTCODE = -1
      IERR = 0
      END IF
      RETURN
      END
C
C     SEARCH '-', '=', '#', ':' AND '^'.
C
      SUBROUTINE SRCHVBOFLAG(STRING,ICUR,LENBUF,ISATOM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     character*80 A
      CHARACTER*1 STRING(*)
      LOGICAL ISATOM
      ISATOM = .FALSE.
      IF(STRING(ICUR).EQ.':'.OR.STRING(ICUR).EQ.'^') THEN
      ISATOM = .TRUE.
      RETURN
      END IF
      DO 100 I=ICUR,LENBUF
      IF(STRING(I).EQ.' ') THEN
      ELSE IF(STRING(I).EQ.'-'.OR.STRING(I).EQ.'='
     &        .OR.STRING(I).EQ.'#') THEN
      ISATOM = .TRUE.
      RETURN
      ELSE
      RETURN
      END IF
 100  CONTINUE
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     READ VBO CODE. SEARCH '-', '=', '#', ':' AND '^'.
C     EACH TYPE VBO CAN BE CODED AS FOLLOW:
C
C     NATOM1, NATOM2, NVBOTYPE, NBNDEX,NVBODEX
C
C     NATOM1: THE FIRST BONDING ATOM.
C     NATOM2: THE SECOND (BONDED) ATOM, IF ANY (FOR LP, PI, NATOM2=0).
C     NVBOTYPE: 1 = SIGMA, 2 = PI, 3 = LP, 4 = SINGLE BOND
C               5 = DOUBLE BOND, 6 = TRIPLE BOND, 7 = MC BOND/LMO,
C               8 = DIRECTIONAL PI BOND, I.E. THE PI ORBITAL OF NATOM1 POINTING
C                   TO NATOM2. NATOM1->NATOM2(PI)
C               9 = EXPLICIT DIRECTION POINT
C                   1 -> (1.0, -1.0, 0.0)
C               10 = AO(x). Use AO-x
C               11 = MO(x). Use MO-x
C
C     NBNDEX: BOND INDEX. 1 = THE FIRST ONE OF THE KIND.
C             FOR INSTANCE, TYPE=LP, AND NBNDEX=2, WHICH MEANS THE SECOND LP.
C             THE SAME RULES APPLY TO PI AND LMO AS WELL.
C     NVBODEX: THE VBO INDEX, I.E. WHICH VBO THE CODE IS SPECIFIED.
C
C
C     READ A TYPICAL VBO NOTATION:
C
C      (1-2(2))
C      -      -
C     THE UNDERLINED CHARS ARE OPTIONAL. BUT THEY MUST APPEAR IN PAIRS, OTHER
C     WISE, IT WILL GENERATE ERROR MESSAGE
C
C     FIRST CREATED: OCT. 15, 2003
C
C     AUTHOR: JIABO LI
C
C     9943 FIELDTHORN ST.
C     SAN DIEGO, CA 92127
C
C     REVISION: ADDED NVBOTYPE 8.
C
C     ADDED MULTIPLE-CENTER BOND TYPE: NVBOTYPE 7.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE VBOCRD(STRING,ICUR,LENBUF,NVBOCODE,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*1 STRING(*)
      CHARACTER*8 TEMP
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION NVBOCODE(5)
C     LOGICAL LEFTP,RIGHTP,LEFTB,RIGHTB,LMODIP,RMODIP
      LOGICAL LEFTP,LEFTB
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      LEFTP  = .FALSE.
C     RIGHTP = .FALSE.
      LEFTB  = .FALSE.
C     RIGHTB = .FALSE.
C     LMODIP = .FALSE.
C     RMODIP = .FALSE.
      IERR   = 0
      ICURSOR = ICUR
C GMS  IGMS=1
C GMS  IF (IGMS.GT.10) WRITE(IOUTVB,*)"STUPID",LMODIP,RIGHTB,
C GMS & RIGHTP,RMODIP
C
C     NVBO: THE NUMBER OF VBOS. FOR A MULTI-COMPONENT VBO,
C     NVBO IS SET ZERO FOR ALL TERMS EXCEPT FOR THE LAST TERM.
C     FOR LAST TERM, NVBO IS SET TO 1
C
C     FOR A MULTI-VBO INPUT, FOR INSTANCE, n-m, NVBO = 2
C     FOR n=m, NVBO =4, AND FOR n#m, NVBO = 6.
C     SET THE DEFAULT VALUES
C
      NVBOCODE(3) = 1
      NVBOCODE(4) = 1
C
C     SEARCH FOR MC, AO, LMO FLAG,
C
      DO 10 I=ICUR, LENBUF-1
      IF(STRING(I).EQ.'M'.AND.STRING(I+1).EQ.'C') THEN
      NVBOCODE(3) = 7
      ICURSOR = I+3
      GOTO 11
      END IF
      IF(STRING(I).EQ.'L'.AND.STRING(I+1).EQ.'M') THEN
      NVBOCODE(3) = 7
      ICURSOR = I+4
      GOTO 11
      END IF
      IF(STRING(I).EQ.'A'.AND.STRING(I+1).EQ.'O') THEN
      NVBOCODE(3) = 10
      ICURSOR = I+3
      GOTO 11
      END IF
      IF(STRING(I).EQ.'M'.AND.STRING(I+1).EQ.'O') THEN
      NVBOCODE(3) = 11
      ICURSOR = I+3
      GOTO 11
      END IF
 10   CONTINUE
 11   CONTINUE
      IF(NVBOCODE(3).EQ.1) GOTO 111
C
C     READ MC/LMO/AO INDEX,
C     MC(X)
C     AO(X)
C     LMO(X)
C
      ICUR = ICURSOR
      CALL RNUMRD(STRING,RNUMBER,ICUR,LENBUF,INTCODE,IERR)
      IF(IERR.EQ.1) RETURN
      IF(INTCODE.NE.1) THEN
      IERR = 1
      RETURN
      END IF
      NVBOCODE(4) = INT(RNUMBER + 1.0D-5)
      RETURN
 111  CONTINUE
C
C
C     SEARCH FOR LEFT PARENTHESIS
C
      DO 100 I=ICUR, LENBUF
      ITEMP = ISNUMBER(STRING(I))
      IF(STRING(I).EQ.' ') THEN
C     WRITE(IOUTVB,*)'SKIP SPACE'
      ELSE IF(STRING(I).EQ.'(') THEN
      LEFTP = .TRUE.
      ICURSOR = I + 1
      GOTO 110
      ELSE IF(STRING(I).EQ.'[') THEN
      LEFTB = .TRUE.
      ICURSOR = I + 1
      GOTO 110
      ELSE IF (ITEMP.GE.0) THEN
      ICURSOR = I
      GOTO 110
      ELSE
      IERR = 1
      RETURN
      END IF
 100  CONTINUE
 110  CONTINUE
C
C     READ NATOM1
C
      ICUR = ICURSOR
      CALL RNUMRD(STRING,RNUMBER,ICUR,LENBUF,INTCODE,IERR)
      IF(IERR.EQ.1) RETURN
      IF(INTCODE.NE.1) THEN
      IERR = 1
      RETURN
      END IF
      NVBOCODE(1) = INT(RNUMBER + 1.0D-5)
C     WRITE(IOUTVB,*)'NATOM1 = ', NVBOCODE(1)
C
C     READ VBO TYPE
C
      DO 200 I = ICUR, LENBUF
      IF(STRING(I).EQ.':') THEN
      NVBOCODE(2) = 0
      NVBOCODE(3) = 3
      ICURSOR = I + 1
C     WRITE(IOUTVB,*)' ICURSOR = ',ICURSOR
      GOTO 210
      ELSE IF(STRING(I).EQ.'^') THEN
      NVBOCODE(2) = 0
      NVBOCODE(3) = 2
      ICURSOR = I + 1
      GOTO 210
      ELSE IF(STRING(I).EQ.'-'.AND.STRING(I+1).EQ.'>'
     &                        .AND.STRING(I+2).EQ.'(') THEN
      NVBOCODE(3) = 9
      ICURSOR = I + 3
      GOTO 210
      ELSE IF(STRING(I).EQ.'-'.AND.STRING(I+1).EQ.'>') THEN
      NVBOCODE(3) = 1
      ICURSOR = I + 2
      GOTO 210
      ELSE IF(STRING(I).EQ.'-') THEN
      NVBOCODE(3) = 4
      ICURSOR = I + 1
      GOTO 210
      ELSE IF(STRING(I).EQ.'=') THEN
      NVBOCODE(3) = 5
      ICURSOR = I + 1
      GOTO 210
      ELSE IF(STRING(I).EQ.'#') THEN
      NVBOCODE(3) = 6
      ICURSOR = I + 1
      GOTO 210
      ELSE IF(STRING(I).EQ.' ') THEN
C     WRITE(IOUTVB,*)'SKIP SPACE'
      ELSE
      IERR = 1
      RETURN
      END IF
 200  CONTINUE
 210  CONTINUE
C     WRITE(IOUTVB,*)'VBO TYPE = ', NVBOCODE(3)
      ICUR = ICURSOR
C
C     READ (X,Y,Z)
C
      IF(NVBOCODE(3).EQ.9) THEN
          CALL RNUMRD(STRING,X,ICUR,LENBUF,INTCODE,IERR)
          ICUR = ICUR+1
          CALL RNUMRD(STRING,Y,ICUR,LENBUF,INTCODE,IERR)
          ICUR = ICUR+1
          CALL RNUMRD(STRING,Z,ICUR,LENBUF,INTCODE,IERR)
          WRITE(IOUTVB,*)"XYZ = ", X, Y, Z
         RETURN
      END IF
C
C
C     READ NATOM2 FOR SIGMA AND LMO BOND
C
      IF(NVBOCODE(3).EQ.1.OR.NVBOCODE(3).GE.4) THEN
C     WRITE(IOUTVB,*)'ICUR FOR READ NATOM2 = ', ICUR
      CALL RNUMRD(STRING,RNUMBER,ICUR,LENBUF,INTCODE,IERR)
      IF(IERR.EQ.1) RETURN
        IF(INTCODE.NE.1) THEN
        IERR = 1
        RETURN
        END IF
      NVBOCODE(2) = INT(RNUMBER + 1.0D-5)
      IF(RNUMBER.LT.0.0D0) NVBOCODE(2) = INT(RNUMBER - 1.0D-5)
C     WRITE(IOUTVB,*)'NATOM2=',NVBOCODE(2)
      ICURSOR = ICUR
      END IF
C
C     FOR LMO, PI, AND LP, READ POSSIBLE MODIFIER
C
      IF(NVBOCODE(3).EQ.1) GOTO 305
C     WRITE(IOUTVB,*)'ICUR AFTER NATOM2 = ', ICUR
      DO 300 I=ICUR, LENBUF
      ICURSOR = I
      IF(STRING(I).EQ.' ') THEN
C       WRITE(IOUTVB,*)'SKIP SPACE'
      ELSE IF(STRING(I).EQ.'(') THEN
C
C     MODIFIER STARTS
C
C       LMODIP = .TRUE.
        ICURSOR = I + 1
        CALL RNUMRD(STRING,RNUMBER,ICURSOR,LENBUF,INTCODE,IERR)
        IF(IERR.EQ.1) RETURN
          IF(INTCODE.NE.1) THEN
          IERR = 1
          RETURN
          END IF
          NVBOCODE(4) = INT(RNUMBER + 1.0D-5)
        ICURX = ICURSOR
        DO J=ICURX, LENBUF
        IF(STRING(J).EQ.' ') THEN
C       WRITE(IOUTVB,*)'SKIP SPACE'
        ELSE IF(STRING(J).EQ.')')  THEN
C       RMODIP = .TRUE.
        ICURSOR = J + 1
        GOTO 310
        ELSE
        IERR = 1
        RETURN
        END IF
        END DO
      ELSE
C
C     FOR ANY CHAR RATHER THAN ' ' and '(', STOP
C
      ICURSOR = I
      GOTO 310
      END IF
 300  CONTINUE
 305  CONTINUE
      DO 306 I=ICUR, LENBUF-3
      ICURSOR = I
      TEMP(1:1)=STRING(I)
      TEMP(2:2)=STRING(I+1)
      TEMP(3:3)=STRING(I+2)
      TEMP(4:4)=STRING(I+3)
      IF(STRING(I).NE.' ') THEN
        IF(TEMP(1:4).EQ.'(PI)') THEN
          NVBOCODE(3)=8
          ICURSOR = I+4
        END IF
        GOTO 310
      END IF
 306  CONTINUE
 310  CONTINUE
      ICUR = ICURSOR
C
C     FINISH THE VBOCODE READ
C
      IF(LEFTP) THEN
C
C     SEARCH FOR RIGHTP
C
        DO J=ICURSOR, LENBUF
        IF(STRING(J).EQ.' ') THEN
C       WRITE(IOUTVB,*)'SKIP SPACE'
        ELSE IF(STRING(J).EQ.')')  THEN
C       RIGHTP = .TRUE.
        ICUR = J + 1
        GOTO 410
        ELSE
        IERR = 1
        RETURN
        END IF
        END DO
      ELSE IF(LEFTB) THEN
C
C     SEARCH FOR RIGHTB
C
        DO J=ICURSOR, LENBUF
        IF(STRING(J).EQ.' ') THEN
C       WRITE(IOUTVB,*)'SKIP SPACE'
        ELSE IF(STRING(J).EQ.']')  THEN
C       RIGHTB = .TRUE.
        ICUR = J + 1
        GOTO 410
        ELSE
        IERR = 1
        RETURN
        END IF
        END DO
      END IF
 410  CONTINUE
C     WRITE(IOUTVB,*)'NVBOCODE =',(NVBOCODE(K),K=1,4)
C     WRITE(IOUTVB,*)'RETURN ICURSOR =', ICURSOR
      RETURN
      END
C
C     READ A REAL NUMBER FROM THE CURRENT POINT
C     STOP AT ANY NON-NUMBERICAL CHAR, INCLUDE THE CURRENT ONE
C     THE RETURN NUMBER IS IN RNUMBER
C     INTCODE: 1 = INTEGER; 0 = REAL; -1: EMPTY
C
      SUBROUTINE RNUMRD(STRING,RNUMBER,ICURSOR,LENBUF,INTCODE,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     character*80 A
      CHARACTER*1 STRING(*)
      DFACTOR = 1.0D0
C     number=0
      RNUMBER = 0.0D0
      NSTARTED = 0
      NDECSTED = 0
      INTCODE = -1
      INTDIG = 0
      IDEDIG = 0
      IERR = 0
      SIGN = 1.0D0
      ISTART = ICURSOR
      DO 100 I=ISTART,LENBUF
      ITEMP=ISNUMBER(STRING(I))
      IF(NSTARTED.EQ.0) THEN
C
C     NUMBER NOT STARTED YET
C
        IF(STRING(I).EQ.'-') THEN
           SIGN = -1.0D0
        ELSE IF(STRING(I).EQ.' ') THEN
C       WRITE(IOUTVB,*)'SKIP SPACE'
        ELSE IF(ITEMP.GE.0) THEN
        NSTARTED = 1
        RNUMBER = ITEMP
        INTCODE = 1
        INTDIG = INTDIG+1
        ELSE IF(STRING(I).EQ.'.') THEN
        NDECSTED = 1
        INTCODE  = 0
        NSTARTED = 1
        ELSE
         RNUMBER=SIGN*RNUMBER
        ICURSOR = I
        RETURN
        END IF
      ELSE IF(NDECSTED.EQ.0) THEN
C
C     INTEGER PART
C
        IF(STRING(I).EQ.' ') THEN
        ICURSOR = I
        RETURN
        ELSE IF(ITEMP.GE.0) THEN
        RNUMBER = RNUMBER*10 + ITEMP
        INTDIG = INTDIG+1
        ELSE IF (STRING(I).EQ.'.') THEN
        NDECSTED= 1
        NSTARTED= 1
        INTCODE = 0
        ELSE
         RNUMBER=SIGN*RNUMBER
        ICURSOR = I
        RETURN
        END IF
      ELSE
C
C     DECIMAL PART
C
        IF(ITEMP.GE.0) THEN
        DFACTOR = DFACTOR*0.1D0
        RNUMBER = RNUMBER + DFACTOR*ITEMP
        IDEDIG = IDEDIG + 1
        ELSE IF(STRING(I).EQ.'.') THEN
        INTCODE = -1
        ICURSOR = I
        IERR = 1
        RETURN
        ELSE IF(IDEDIG.EQ.0.AND.INTDIG.EQ.0) THEN
        ICURSOR = I
        INTCODE = -1
        IERR = 1
        RETURN
        ELSE
         RNUMBER=SIGN*RNUMBER
        ICURSOR = I
        RETURN
        END IF
      END IF
 100  CONTINUE
         RNUMBER=SIGN*RNUMBER
      ICURSOR=LENBUF
      RETURN
      END
      SUBROUTINE LPIVBO(V,NB1ADD,IOLVBO,NBONDALIST,NSUB,
     &                  VBOLAB)
C----------------------------------------------------------------------------
C     V:        VB ORBITALS
C     NDIM:     DIMENSION OF MO
C     NB1ADD:   STARTING INDEXES OF ORBITALS OF SUBUNITS
C----------------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 FLAG
      CHARACTER*12 FRGAOLB,BFLABE,ATEMP,BTEMP
      CHARACTER*20 BASNAME
      CHARACTER*8  VBOLAB(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      PARAMETER (MAXCEN=200,MAXBFN=726)
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION V(NBASIS,*),NB1ADD(*)
      DIMENSION NPIA(100),NAOST(1000),FRGORB(100)
      DIMENSION FRGXYZ(3,20),FRGAOLB(100),PLANXYZ(3,20),A(3),B(3)
      DIMENSION RMAT(3,3),WT(100),NBONDALIST(10,*)
      DIMENSION ATMPIDIR(3,20),GRPIDIR(3),VBOLDIR(3)
      LOGICAL GPIDIR,APIDIR(20)
C
C     FIRST, CHECK IOLVBO
C
      IF(IOLVBO.EQ.0) RETURN
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      DO 100 I=1,99
      WT(I) = 1.0D0
 100  CONTINUE
      NAOST(1) = 1
      DO I=1,NATOM
      NAOST(I+1) = NAOST(I) + NATBAS(I)
      END DO
C
C     LOOP OVER EACH GROUP. IF $XXPIVBO IS FOUND, THEN THE GROUP XX IS
C     A PI GROUP, AND THE PI ORBITAL WILL BE DEFINED USING THE NEW RULES
C
      DO I=1, NSUB
      MGRP     = I
C     NC1      = 1+MGRP/10
C     NC2      = 1+MGRP-10*(NC1-1)
      FLAG     = '$'
      WRITE(FLAG(2:3),'(I2.2)') MGRP
C
C     SEARCH FOR EXPLICIT PI DIRECTION FROM $XXPIDIR
C
      FLAG(4:8)='PIDIR'
      GPIDIR = .FALSE.
      CALL LOCTOR(IOENGI,FLAG,8,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*,END=101,ERR=101)(GRPIDIR(K),K=1,3)
      GPIDIR = .TRUE.
      GOTO 102
 101  CALL ABORT0('PIDIRERR  ')
 102  CONTINUE
      END IF
      FLAG(4:8)='PIVBO'
      CALL LOCTOR(IOENGI,FLAG,8,IOK,0)
C
C     IF FLAG DOES NOT EXIST, THEN IT DOES NOT MEAN THAT THIS IS NOT A PI GROUP.
C     IT MEANS IT DOES NOT REQUIRE PI GROUP SPECIFICATION (FOR INSTANCE
C     IN CH2=CH2, NO EXPLICIT PI GROUP INPUT IS NECESSARY
C
      IF(IOK.NE.1) THEN
C     WRITE(IOUTVB,*)'This is not a explicit PI group'
      GOTO 200
      END IF
      READ(IOENGI,*)NPIORB
      READ(IOENGI,*)(NPIA(J),J=1,NPIORB)
C     WRITE(IOUTVB,*)'BASNAME,NPIA = ',BASNAME,(NPIA(J),J=1,NPIORB)
C     WRITE(IOUTVB,*)'NAOST = ',(NAOST(NPIA(J)),J=1,NPIORB)
C
C     AUTOMATIC DETECTION OF PI DIRECTION FOR EACH ATOM IN THE PI GROUP
C     FIRST, SETUP THE PI DIRECTIONS FOR THE FIRST GROUP ATOMS
C
      DO J=1, NPIORB
      APIDIR(J) = .FALSE.
      NBONDS = NBONDALIST(1,NPIA(J))
      NAT1 = NPIA(J)
      NAT2 = 0
      NBTYPE = 2
      NBINDX   = 1
      CALL CVBOLAB(NAT1,NAT2,NBTYPE,NBINDX,ATEMP)
      NVBJ     = NB1ADD(MGRP)+J-1
      VBOLAB(NVBJ) = ATEMP(1:8)
      CALL ATOMPIDIR(NPIA(J),NBONDS,NBONDALIST(2,NPIA(J)),XYZ,
     &               APIDIR(J),ATMPIDIR(1,J))
      END DO
C
C     NOW, SETUP THE PI DIRECTIONS FOR SECOND GROUP ATOMS (APIDIR(J) is F
C
      DO J=1, NPIORB
      JA = NPIA(J)
      IF(.NOT.APIDIR(J)) THEN
      TDIS = 1.0D+04
        DO K=1, NPIORB
        KA = NPIA(K)
         DISJK = ATOMDIS(XYZ(1,JA),XYZ(1,KA))
         IF(APIDIR(K).AND.DISJK.LT.TDIS) THEN
           ATMPIDIR(1,J) = ATMPIDIR(1,K)
           ATMPIDIR(2,J) = ATMPIDIR(2,K)
           ATMPIDIR(3,J) = ATMPIDIR(3,K)
           APIDIR(J) = .TRUE.
         END IF
        END DO
      END IF
C
C     OVER WRITE THE AUTOMATIC PI DIR IF GPIDIR IS TRUE
C
      IF(GPIDIR) THEN
        ATMPIDIR(1,J) = GRPIDIR(1)
        ATMPIDIR(2,J) = GRPIDIR(2)
        ATMPIDIR(3,J) = GRPIDIR(3)
        APIDIR(J) = .TRUE.
      END IF
      IF(.NOT.APIDIR(J)) THEN
        WRITE(IOUTVB,*)'PI-Direction needs to be specified explicitly '
        WRITE(IOUTVB,*)'for this group'
        WRITE(IOUTVB,*)
     & 'Please see Manual for Input of Pi Orbital Direction'
        CALL ABORT0('APIDIRERR ')
      END IF
      END DO
C
C     INVERSE THE DIRECTION IF THE PRODUCT OF THE TWO VEC IS NEGATIVE
C
      DO J=2, NPIORB
      CALL DOTPROD(ATMPIDIR(1,J-1),ATMPIDIR(1,J),PROD)
      IF(PROD.LT.0.0D0) CALL VECINV(ATMPIDIR(1,J))
      END DO
C
C     NOW, ALL PI ATOMS HAVE PI DIRECTIONS
C
      DO J=1, NPIORB
      NATNUMPI = NATNUM(NPIA(J))
      NAOSTJ   = NAOST(NPIA(J))
      NVBJ     = NB1ADD(MGRP)+J-1
      NBONDS = NBONDALIST(1,NPIA(J))
C
C     PI VBO LOOK UP ROUTINE
C
      CALL LOOKPIVBO(NATNUMPI,NBONDS,FRGXYZ,FRGORB,FRGAOLB,NAFRAG,
     &               NAOFRG,IOLVBO,VBOLDIR)
C    &               NAOFRG,IOLVBO,BASNAME,VBOLDIR)
C
C       PREPARE THE POINTS
C
        PLANXYZ(1,1) = 0.0D0
        PLANXYZ(2,1) = 0.0D0
        PLANXYZ(3,1) = 0.0D0
        PLANXYZ(1,2) = ATMPIDIR(1,J)
        PLANXYZ(2,2) = ATMPIDIR(2,J)
        PLANXYZ(3,2) = ATMPIDIR(3,J)
        A(1) = ATMPIDIR(1,J)
        A(2) = ATMPIDIR(2,J)
        A(3) = ATMPIDIR(3,J)
        B(1) = VBOLDIR(1)
        B(2) = VBOLDIR(2)
        B(3) = VBOLDIR(3)
C
C       CROSS PRODUCT C = AxB
C
        PLANXYZ(1,3) = A(2)*B(3) - A(3)*B(2)
        PLANXYZ(2,3) = A(3)*B(1) - A(1)*B(3)
        PLANXYZ(3,3) = A(1)*B(2) - A(2)*B(1)
C
C       COPY FROM FRGORB TO V_NVBJ
C
          DO K=1, NBASIS
          V(K,NVBJ) = 0.0D0
          END DO
          DO K=1, NAOFRG
          V(NAOSTJ+K-1,NVBJ) = FRGORB(K)
C         WRITE(IOUTVB,*)'NAOSTJ,NVBJ,FRGORB =',NAOSTJ,NVBJ,FRGORB(K)
          ATEMP=FRGAOLB(K)
          BTEMP=BFLABE(NAOSTJ+K-1)
            IF(ATEMP(11:12).NE.BTEMP(11:12)) THEN
            WRITE(IOUTVB,*)'A,B =',ATEMP,BTEMP
            CALL ABORT0('LPIVBO01  ')
            END IF
          END DO
C
C       FIND THE ROTATION MATRIX, FIT FRG TO PLANXYZ
C
          FRGXYZ(1,1) = 0.0D0
          FRGXYZ(2,1) = 0.0D0
          FRGXYZ(3,1) = 0.0D0
          FRGXYZ(1,2) = VBOLDIR(1)
          FRGXYZ(2,2) = VBOLDIR(2)
          FRGXYZ(3,2) = VBOLDIR(3)
          FRGXYZ(1,3) = PLANXYZ(1,3)
          FRGXYZ(2,3) = PLANXYZ(2,3)
          FRGXYZ(3,3) = PLANXYZ(3,3)
          NAFRAG = 3
          DO L=1, NAFRAG
C         WRITE(IOUTVB,*)'PLAN=',(PLANXYZ(K,L),K=1,3)
C         WRITE(IOUTVB,*)'FRG =',(FRGXYZ(K,L),K=1,3)
          END DO
        CALL FITROT(PLANXYZ,FRGXYZ,NAFRAG,WT,RMAT)
C       WRITE(IOUTVB,*)'RMAT=',((RMAT(K,L),L=1,3),K=1,3)
C
C       TRANSFORMATION OF LIB VBO TO MOL VBO
C
C       WRITE(IOUTVB,*)'PI ORB A=',(V(K,NVBJ),K=1,NBASIS)
        CALL ORBTRN(NAOFRG,1,BFLABE(NAOSTJ),V(NAOSTJ,NVBJ),RMAT,
     &              V(NAOSTJ,NVBJ))
C       WRITE(IOUTVB,*)'PI ORB B=',(V(K,NVBJ),K=1,NBASIS)
C
C      DO LOOP OF PI ORBITALS (J)
C
       END DO
 200  CONTINUE
C
      END DO
      WRITE(IOUTVB,*)
C 900 FORMAT(/' PI-ORBITALS ($PIORB)'/1X,71(1H=))
C1000 FORMAT(' Pi-AO#: ',20I3)
C1100 FORMAT(' Group#: ',20I3)
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     FIND TRANSLATION MATRIX TRAN SO THAT
C     TRAN VA = VB
C     WHREE BOTH VA AND VB ARE 3D UNIT VECTORS
C
C     RETURN:
C             TRAN(3,3). THE TRANSLATION MATRIX
C             IERR. THE ERROR CODE. (0/1 = NO ERROR/ERROR)
C             VA, VB ARE NORMALIZED.
C
C     FIRST VERSION: OCT 25, 2003
C     AUTHOR: JIABO LI
C
C     SAN DIEGO
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE TRNV2V(VA,VB,TRAN,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION VA(3),VB(3),VC(3),TRAN(3,3)
      DIMENSION POINTA(3,3),POINTB(3,3),WT(3)
      IERR = 0
      DO I=1, 3
      WT(I) = 1.0D0
        DO J=1, 3
        TRAN(I,J) = 0.0D0
        END DO
        TRAN(I,I) = 1.0D0
      END DO
C
C     NORMALIZATION
C
      CALL VECNORM(VA,NOZERO)
      IF(NOZERO.EQ.0) THEN
      IERR = 1
      RETURN
      END IF
      CALL VECNORM(VB,NOZERO)
      IF(NOZERO.EQ.0) THEN
      IERR = 1
      RETURN
      END IF
C
C     CROSS PRODUCT VC = VAxVB
C
      CALL XPROD(VA,VB,VC)
      CALL VECNORM(VC,NOZERO)
      IF(NOZERO.EQ.0) THEN
      CALL DOTPROD(VA,VB,VAB)
        IF (VAB.LT.0.0D0) THEN
C
C       INVERSE THE UNIT MATRIX
C
        DO I = 1, 3
        TRAN(I,I) = -1.0D0
        END DO
        END IF
      RETURN
      END IF
C
C       PREPARE THE POINTS
C
      DO I=1, 3
      POINTA(I,1) = 0.0D0
      POINTB(I,1) = 0.0D0
      POINTA(I,2) = VC(I)
      POINTB(I,2) = VC(I)
      POINTA(I,3) = VA(I)
      POINTB(I,3) = VB(I)
      END DO
C
C     FIND THE ROTATION MATRIX TRAN, FIT POINTA TO POINTB
C
      NPOINTS = 3
      CALL FITROT(POINTB,POINTA,NPOINTS,WT,TRAN)
C
C     TRAN VA =
C
      CALL MATMUL2(3,3,1,TRAN,VA,VC)
      RETURN
      END
C
C     SCAN VBO NUMBERS FOR EACH VB GROUP
C
      SUBROUTINE SCANVBO(NSUB,MLORBIT)
C----------------------------------------------------------------------------
C     NSUB:     NUMBER OF GROUPS
C     MLORBIT:  ARRARY OF ORBITAL NUMBERS OF ALL GROUPS
C----------------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MAXTEM = 200)
      CHARACTER*80 FLAG
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION MLORBIT(*),NCODE(5,MAXTEM),COEF(MAXTEM)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
C     CHECK IOLVBO
C
C     IF(IOLVBO.EQ.0) RETURN
      CALL GETIOUNIT('IOENGI  ',IOENGI)
C
C     LOOP OVER EACH GROUP. IF $XXVBORB IS FOUND, THEN READ THE VBO CODE
C     AND THE CORRESPONDING COEFFICIENT
C
      DO I=1, NSUB
      MGRP     = I
C     NC1      = 1+MGRP/10
C     NC2      = 1+MGRP-10*(NC1-1)
      FLAG     = '$'
      WRITE(FLAG(2:3),'(I2.2)') MGRP
      FLAG(4:8)='VBORB'
      CALL LOCTOR(IOENGI,FLAG,8,IOK,0)
C
C     IF $XXVBORB IS FOUND, THEN READ THE VBO INSTRUCTIONS AND GENERATE VBO
C
      IF(IOK.NE.1) THEN
C     WRITE(IOUTVB,*)'NO VBOLIB INPUT FOR THIS GROUP'
      GOTO 200
      END IF
      CALL VBOCODE(IOENGI,NVBO,NCODE,COEF,NTTMS,MAXTEM)
      IF(MLORBIT(I).LE.NVBO) THEN
      MLORBIT(I) = NVBO
      ELSE
      WRITE(IOUTVB,*)"MLORBIT,NVBO = ",MLORBIT(I),NVBO
      WRITE(IOUTVB,*)"VBO ENTRES FOR GROUP ",I," IS NOT ENOUGH"
      CALL ABORT0("SCANEVBO01")
      ENDIF
 200  CONTINUE
C
C     DO LOOP OF VBO GROUPS (I)
C
      END DO
      RETURN
      END
C     SUBROUTINE VBOLIB(NDIM,V,NB1ADD,IOLVBO,NBONDALIST,NSUB,BONDLAB,
C    &                  LMOLAB,VBOLAB)
      SUBROUTINE VBOLIB(V,NB1ADD,IOLVBO,NSUB,VBOLAB)
C----------------------------------------------------------------------------
C     V:        VB ORBITALS
C     NDIM:     DIMENSION OF MO
C     NB1ADD:   STARTING INDEXES OF ORBITALS OF SUBUNITS
C----------------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 FLAG
C     CHARACTER*8  BONDLAB(*),VBOLAB(*)
      CHARACTER*8  VBOLAB(*)
C     CHARACTER*12 FRGAOLB,ATEMP,BTEMP,BFLABE
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      PARAMETER (MAXTEM = 200)
C
C     TODO: ADD CHECK FORWT, FRGAOLB ETC FOR NEXT RELEASE
C
      PARAMETER (MAXCEN=200,MAXBFN=726)
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
C     DIMENSION V(NBASIS,*),NB1ADD(*),NWA(100)
      DIMENSION V(NBASIS,*),NB1ADD(*)
C     DIMENSION NPIA(100),DIRECTION(3),NAOST(1000),FRGORB(100)
      DIMENSION NAOST(1000)
C     DIMENSION FRGXYZ(3,20),FRGAOLB(100),PLANXYZ(3,20),A(3),B(3)
C     DIMENSION RMAT(3,3),WT(100),OLDIR(3),NBONDALIST(10,*)
C     DIMENSION NCODE(5,MAXTEM),COEF(MAXTEM),LMOLAB(2,*)
      DIMENSION NCODE(5,MAXTEM),COEF(MAXTEM)
C
C     CHECK IOLVBO
C
C     IF(IOLVBO.EQ.0) RETURN
      CALL GETIOUNIT('IOENGI  ',IOENGI)
C     DO 100 I=1,99
C     WT(I) = 1.0D0
C100  NWA(I)=NB1ADD(I)
C     WT & NWA are not used.
      NAOST(1) = 1
      DO I=1,NATOM
      NAOST(I+1) = NAOST(I) + NATBAS(I)
      END DO
C
C     LOOP OVER EACH GROUP. IF $XXVBORB IS FOUND, THEN READ THE VBO CODE
C     AND THE CORRESPONDING COEFFICIENT
C
      DO I=1, NSUB
      MGRP     = I
C     NC1      = 1+MGRP/10
C     NC2      = 1+MGRP-10*(NC1-1)
      FLAG     = '$'
      WRITE(FLAG(2:3),'(I2.2)') MGRP
      FLAG(4:8)='VBORB'
      CALL LOCTOR(IOENGI,FLAG,8,IOK,0)
C
C     IF $XXVBORB IS FOUND, THEN READ THE VBO INSTRUCTIONS AND GENERATE VBO
C
      IF(IOK.NE.1) THEN
C     WRITE(IOUTVB,*)'NO VBOLIB INPUT FOR THIS GROUP'
      GOTO 200
      END IF
      CALL VBOCODE(IOENGI,NVBO,NCODE,COEF,NTTMS, MAXTEM)
C
C     LIST VBO CODE
C
        DO J=1, NTTMS
C       WRITE(IOUTVB,*)'VBO CODE:',COEF(J),(NCODE(K,J),K=1,5)
        END DO
      NVBOST = NB1ADD(I)
      CALL VBOGEN(NVBO,NCODE,COEF,NTTMS,NBASIS,V(1,NVBOST),
     &            VBOLAB(NVBOST),IOLVBO,NATBAS,BFLABE)
 200  CONTINUE
C
C     DO LOOP OF VBO GROUPS (I)
C
      END DO
      DO I=1, 7
        DO K=1, NBASIS
C       WRITE(IOUTVB,'(I5,F10.5)')K, V(K,I)
        END DO
      END DO
      RETURN
      END
      SUBROUTINE VBOCODE(IOENGI,NVBO,NVBOCODE,COEF,NTTMS, MAXTEM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 VBOSTRING,BLANK
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      DIMENSION NVBOCODE(5,*),COEF(*)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      BLANK(1:40)  = '                                        '
      BLANK(41:80) = '                                        '
      IDXVBO = 0
      NTTMS  = 0
 100  READ(IOENGI,1000,END=200,ERR=200)VBOSTRING
      IF(VBOSTRING.EQ.BLANK) GOTO 200
      IF(NTTMS.GE.MAXTEM) CALL ABORT0("VBOCODE0001")
      LSTRING = 80
      CALL VBOPARSER(VBOSTRING,LSTRING,NTERMS,NVBOCODE(1,NTTMS+1),
     &              COEF(NTTMS+1),IDXVBO,IERR)
      IF(IERR.EQ.1) THEN
        WRITE(IOUTVB,*)"SYNTAX ERROR IN THIS VBORB SPECIFICATION"
        WRITE(IOUTVB,*)VBOSTRING
        CALL ABORT0('VBOCODE01 ')
      END IF
      NTTMS = NTTMS + NTERMS
      GOTO 100
 200  CONTINUE
 1000 FORMAT(A80)
      NVBO = IDXVBO
      DO I=1, NTTMS
C     WRITE(IOUTVB,*)'I, NVBOCODE=', I, (NVBOCODE(J,I),J=1, 5), COEF(I)
      END DO
      RETURN
      END
      SUBROUTINE VBOGEN(NVBO,NCODE,COEF,NTTMS,NBASIS,V,VBOLAB,
     &                  IOLVBO,NATBAS,BFLABE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*8 VBOLAB(*)
      CHARACTER*8 BONDLAB
      CHARACTER*12 AOLABEL,ATEMP,BTEMP,BFLABE(*)
C     CHARACTER*20 BASNAME
      CHARACTER*3 FUNIT(10)
      PARAMETER (MAXCEN=200,MAXBFN=726)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION NCODE(5,*),COEF(*),V(NBASIS,*),VTMP(1000),VBODIR(3)
      DIMENSION SIGMAVBO(1000),AOLABEL(1000),NATBAS(*),NAOST(1000)
      DIMENSION RMAT(3,3),VBOLDIR(3),PIVBDIR(3),PLVBDIR(3)
      PARAMETER (MAXNAB=MAXCEN*MAXBFN/2,MAXBF2=MAXBFN*MAXBFN)
      COMMON /LMODAT/VMO(MAXBF2),VLMO(MAXBF2),LMOLAB(2,MAXBFN),
     &LMOATM(5,MAXBFN),PGM(MAXNAB),ENGLMO(MAXBFN),BONDLAB(MAXBFN),
     &MCLMO(5,80),LHFLAG
      COMMON /MTOPOL/XYZMOL(3,1000),NATOMS,NATNNU(1001),
     &               NBONDALIST(10,1000),NBONDTYPE(10,1000)
C     LOGICAL APIDIR
C
C     IF LIB DOES NOT EXIST, DO NOTHING UNLESS FOR LMO(X) AND AO(X)
C
C     IF(IOLVBO.EQ.0) RETURN
C
C     GENERATE NVBO ORBITALS AND STORE IN V.
C
C     FIRST, ZERO V
C
      DO I=1, NVBO
        DO J=1, NBASIS
        V(J,I) = 0.0D0
        END DO
      END DO
C
C     SETUP AO STARTING INDEXES
C
      NAOST(1) = 1
      DO I=1, NATOMS
      NAOST(I+1) = NAOST(I) + NATBAS(I)
      END DO
C
C     LOOP OVER ALL TERMS IN VBO CODE
C
      NVBOLD = 0
      DO I=1, NTTMS
C
C     DECODE
C
      NATOM1 = NCODE(1,I)
      NATOM2 = NCODE(2,I)
      NBTYPE = NCODE(3,I)
      NBINDX = NCODE(4,I)
      NVBODX = NCODE(5,I)
      IF(IOLVBO.EQ.0.AND.(NBTYPE.NE.7.AND.NBTYPE.NE.10))
     &               CALL ABORT0("VBOGEN0001")
      CALL CVBOLAB(NATOM1,NATOM2,NBTYPE,NBINDX,ATEMP)
      IF(NVBODX.NE.NVBOLD) THEN
      NVBOLD = NVBODX
      VBOLAB(NVBODX) = ATEMP(1:8)
      ELSE
      VBOLAB(NVBODX) = 'MC-ORBIT'
      END IF
      IF(NBTYPE.EQ.1) THEN
C
C     THIS IS A SIGMA BOND, NA1,NA2 ARE ALL NON-ZERO!
C     ERROR CHECK FIRST!
C
      IF (NATOM1.EQ.0.OR.NATOM2.EQ.0) CALL ABORT0('VBOGEN01  ')
      CALL SIGMADIR(NATOM1,NATOM2,VBODIR)
C
C     LOOK UP SIGMA VBO ON NATOM1 POINTING TO NATOM2
C
      NATNUM = NATNNU(NATOM1)
      NBONDS = NBONDALIST(1,NATOM1)
      NAOSTI = NAOST(NATOM1)
      CALL LOOKSIGMA(NATNUM,NBONDS,VBOLDIR,SIGMAVBO,AOLABEL,NAOFRG,
     &               IOLVBO,IERR)
C
C     FIND TRAN MATRIX RMAT, WHICH TRANSLATE VBOLDIR TO VBODIR,
C     I.E. RMAT VBOLDIR = VBODIR
C
      CALL TRNV2V(VBOLDIR,VBODIR,RMAT,IERR)
      IF(IERR.EQ.1) CALL ABORT0('VBOGEN03  ')
C
C     COPY FROM SIGMAVBO TO VTEMP
C
      DO K=1, NBASIS
      VTMP(K) = 0.0D0
      END DO
      DO K=1, NAOFRG
        VTMP(NAOSTI+K-1) = SIGMAVBO(K)
        ATEMP = AOLABEL(K)
        BTEMP = BFLABE(NAOSTI+K-1)
        IF(ATEMP(11:12).NE.BTEMP(11:12)) CALL ABORT0('VBOGEN04A ')
      END DO
C
C     TRANSLATE LIB VBO TO MOL VBO
C
      CALL ORBTRN(NAOFRG,1,BFLABE(NAOSTI),VTMP(NAOSTI),RMAT,
     &            VTMP(NAOSTI))
C
C     NOW, ADD VTMP TO V WITH WEIGHT COEFF(I)
C
      DO K=1, NBASIS
      V(K,NVBODX) = V(K,NVBODX) + COEF(I)*VTMP(K)
      END DO
C
C     END OF IF BLOCK OF SIGMA BONDING VBO
C
      ELSE IF(NBTYPE.EQ.2) THEN
C
C     THIS IS A PI BONDING VBO, NA1 IS NON-ZERO!
C     ERROR CHECK FIRST!
C
      IF (NATOM1.LE.0) CALL ABORT0('VBOGEN04B ')
      IDXPI  = NBINDX
      NATNUM = NATNNU(NATOM1)
      NBONDS = NBONDALIST(1,NATOM1)
      NAOSTI = NAOST(NATOM1)
C
C     FIND THE LARGEST ATOM OF NATOM1's NEIGHBOR
C
      CALL FINDBPT(NBONDS,NBONDALIST(2,NATOM1),NATNNU,NATBPT)
C
C     FIND THE IDXPI DIRECTION
C
      CALL PIBDIR(NATOM1,NATBPT,IDXPI,PIVBDIR,IERR)
      IF(IERR.EQ.1) CALL ABORT0('GENPIVBO01')
C
C     LOOK UP THE IDXPI-th PI VBO ON NATOM1
C
      CALL LOOKPI(NATNUM,NBONDS,VBOLDIR,SIGMAVBO,AOLABEL,NAOFRG,IOLVBO)
C
C     FIND TRAN MATRIX RMAT, WHICH TRANSLATE VBOLDIR TO VBODIR,
C     I.E. RMAT VBOLDIR = VBODIR
C
      CALL TRNV2V(VBOLDIR,PIVBDIR,RMAT,IERR)
      IF(IERR.EQ.1) CALL ABORT0('VBOGEN03  ')
C
C     COPY FROM SIGMAVBO TO VTEMP
C
      DO K=1, NBASIS
      VTMP(K) = 0.0D0
      END DO
      DO K=1, NAOFRG
      VTMP(NAOSTI+K-1) = SIGMAVBO(K)
      ATEMP = AOLABEL(K)
      BTEMP = BFLABE(NAOSTI+K-1)
        IF(ATEMP(11:12).NE.BTEMP(11:12)) CALL ABORT0('VBOGEN04C ')
      END DO
C
C     TRANSLATE LIB VBO TO MOL VBO
C
      CALL ORBTRN(NAOFRG,1,BFLABE(NAOSTI),VTMP(NAOSTI),RMAT,
     &            VTMP(NAOSTI))
C
C     NOW, ADD VTMP TO V WITH WEIGHT COEFF(I)
C
      DO K=1, NBASIS
      V(K,NVBODX) = V(K,NVBODX) + COEF(I)*VTMP(K)
      END DO
C     END OF IF BLOCK OF PI BONDING VBO
      ELSE IF(NBTYPE.EQ.3) THEN
C
C     LONE PAIR VBO
C
      LPDEX  = NBINDX
      NATNUM = NATNNU(NATOM1)
      NBONDS = NBONDALIST(1,NATOM1)
      NAOSTI = NAOST(NATOM1)
      CALL LPDIR(NATOM1,LPDEX,PLVBDIR,LPTYPE,IERR)
      IF(IERR.EQ.1) CALL ABORT0('NOLPDIR   ')
      CALL LOOKLP(NATNUM,VBOLDIR,SIGMAVBO,AOLABEL,NAOFRG,
     &               LPTYPE,IOLVBO)
C
C     FIND THE LP DIR IN THE MOL
C
C     CALL LPDIR(NATOM1,LPDEX,PLVBDIR,LPTYPE,IERR)
C
C     FIND TRAN MATRIX RMAT, WHICH TRANSLATE VBOLDIR TO PLVBDIR,
C     I.E. RMAT VBOLDIR = PLVBDIR
C
      CALL TRNV2V(VBOLDIR,PLVBDIR,RMAT,IERR)
      IF(IERR.EQ.1) CALL ABORT0('VBOGEN05  ')
C
C     COPY FROM SIGMAVBO TO VTEMP
C
      DO K=1, NBASIS
      VTMP(K) = 0.0D0
      END DO
      DO K=1, NAOFRG
      VTMP(NAOSTI+K-1) = SIGMAVBO(K)
      ATEMP = AOLABEL(K)
      BTEMP = BFLABE(NAOSTI+K-1)
        IF(ATEMP(11:12).NE.BTEMP(11:12)) CALL ABORT0('VBOGEN06  ')
      END DO
C
C     TRANSLATE LIB VBO TO MOL VBO
C
      CALL ORBTRN(NAOFRG,1,BFLABE(NAOSTI),VTMP(NAOSTI),RMAT,
     &            VTMP(NAOSTI))
C
C     NOW, ADD VTMP TO V WITH WEIGHT COEFF(I)
C
      DO K=1, NBASIS
      V(K,NVBODX) = V(K,NVBODX) + COEF(I)*VTMP(K)
C     WRITE(IOUTVB,*)'V(K) =',K,V(K,NVBODX)
      END DO
C     END OF IF BLOCK OF LP BONDING VBO
C
      ELSE IF(NBTYPE.EQ.4) THEN
      WRITE(IOUTVB,*)'LMO AS A DOUBLE ELECTRON VBO'
      ELSE IF(NBTYPE.EQ.7) THEN
C       NBINDX: LMO index
        MMX = (NBINDX-1)*NBASIS
        DO K=1, NBASIS
        V(K,NVBODX) = V(K,NVBODX) + COEF(I)*VLMO(K+MMX)
        END DO
        VBOLAB(NVBODX) = "LMO TYPE"
      ELSE IF(NBTYPE.EQ.11) THEN
C       NBINDX: MO index
        MMX = (NBINDX-1)*NBASIS
        DO K=1, NBASIS
        V(K,NVBODX) = V(K,NVBODX) + COEF(I)*VMO(K+MMX)
        END DO
        VBOLAB(NVBODX) = "MO TYPE"
      ELSE IF(NBTYPE.EQ.10) THEN
C       NBINDX: AO index
        V(NBINDX,NVBODX) = V(NBINDX,NVBODX) + COEF(I)
        VBOLAB(NVBODX) = "AO TYPE"
      ELSE IF(NBTYPE.EQ.8) THEN
C
C     THIS IS A DIRECTIONAL PI BONDING VBO, NA1 AND NA2 ARE NON-ZERO!
C     ERROR CHECK FIRST!
C
      IF (NATOM1.LE.0.OR.NATOM2.LE.0) CALL ABORT0('VBOGEN03  ')
      IDXPI  = NBINDX
      NATNUM = NATNNU(NATOM1)
      NBONDS = NBONDALIST(1,NATOM1)
      NAOSTI = NAOST(NATOM1)
C
C     FIND THE VECTOR NATOM1->NATOM2
C
      CALL SIGMADIR(NATOM1,NATOM2,PIVBDIR)
C
C     LOOK UP THE DIRECTIONAL  PI VBO ON NATOM1 POINTING TO NATOM2
C
      CALL LOOKPI(NATNUM,NBONDS,VBOLDIR,SIGMAVBO,AOLABEL,NAOFRG,IOLVBO)
C
C     FIND TRAN MATRIX RMAT, WHICH TRANSLATE VBOLDIR TO VBODIR,
C     I.E. RMAT VBOLDIR = VBODIR
C
      CALL TRNV2V(VBOLDIR,PIVBDIR,RMAT,IERR)
      IF(IERR.EQ.1) CALL ABORT0('VBOGEN05  ')
C
C     COPY FROM SIGMAVBO TO VTEMP
C
      DO K=1, NBASIS
      VTMP(K) = 0.0D0
      END DO
      DO K=1, NAOFRG
      VTMP(NAOSTI+K-1) = SIGMAVBO(K)
      ATEMP = AOLABEL(K)
      BTEMP = BFLABE(NAOSTI+K-1)
        IF(ATEMP(11:12).NE.BTEMP(11:12)) CALL ABORT0('VBOGEN06  ')
      END DO
C
C     TRANSLATE LIB VBO TO MOL VBO
C
      CALL ORBTRN(NAOFRG,1,BFLABE(NAOSTI),VTMP(NAOSTI),RMAT,
     &            VTMP(NAOSTI))
C
C     NOW, ADD VTMP TO V WITH WEIGHT COEFF(I)
C
      DO K=1, NBASIS
      V(K,NVBODX) = V(K,NVBODX) + COEF(I)*VTMP(K)
      END DO
C     END OF IF BLOCK OF DIRECTIONAL PI BONDING VBO
      ELSE
      WRITE(IOUTVB,101)
 101  FORMAT('DO NOT KNOW HOW TO GENERATE VBO FOR THIS TYPE')
      WRITE(IOUTVB,102) NBTYPE
 102  FORMAT('NBTYPE = ',I4)
      END IF
C     END OF LOOP OVER I/NTTMS
      END DO
      RETURN
      END
C
C     NBTYPE=1,2,3 (SIGMA, 1st PI and 2nd PI)
C
      SUBROUTINE AVBOGEN(NATOM1,NATOM2,NBTYPE,V,VBODIR,IOLVBO,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 AOLABEL,ATEMP,BTEMP,BFLABE
      CHARACTER*20 BASNAME
C     CHARACTER*8 BONDLAB
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     DIMENSION V(NBASIS),VTMP(1000),VBODIR(3)
      DIMENSION V(NBASIS),VBODIR(3)
      DIMENSION SIGMAVBO(1000),AOLABEL(1000),NAOST(1000)
      DIMENSION RMAT(3,3),VBOLDIR(3)
      PARAMETER (MAXCEN=200,MAXBFN=726)
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
C     PARAMETER (MAXNAB=MAXCEN*MAXBFN/2,MAXBF2=MAXBFN*MAXBFN)
C     COMMON /LMODAT/VMO(MAXBF2),VLMO(MAXBF2),LMOLAB(2,MAXBFN),
C    &LMOATM(5,MAXBFN),PGM(MAXNAB),ENGLMO(MAXBFN),BONDLAB(MAXBFN),
C    &MCLMO(5,80),LHFLAG
      COMMON /MTOPOL/XYZMOL(3,1000),NATOMS,NATNNU(1001),
     &               NBONDALIST(10,1000),NBONDTYPE(10,1000)
C     LOGICAL APIDIR
C
C     IF(IOLVBO.EQ.0), DO NOTHING
C
      IF(IOLVBO.EQ.0) RETURN
C     APIDIR = .FALSE.
      IERR = 0
C
C     FIRST, ZERO V
C
      DO J=1, NBASIS
      V(J) = 0.0D0
      END DO
C
C     SETUP AO STARTING INDEXES
C
      NAOST(1) = 1
      DO I=1, NATOMS
      NAOST(I+1) = NAOST(I) + NATBAS(I)
      END DO
      IF(NBTYPE.EQ.1) THEN
C
C     THIS IS A SIGMA BOND, NA1,NA2 ARE ALL NON-ZERO!
C     ERROR CHECK FIRST!
C
      IF (NATOM1.LE.0.OR.NATOM2.LE.0) CALL ABORT0('VBOGEN01  ')
      CALL SIGMADIR(NATOM1,NATOM2,VBODIR)
C
C     LOOK UP SIGMA VBO ON NATOM1 POINTING TO NATOM2
C
      NATNUC = NATNNU(NATOM1)
      NBONDS = NBONDALIST(1,NATOM1)
      NAOSTI = NAOST(NATOM1)
      CALL LOOKSIGMA(NATNUC,NBONDS,VBOLDIR,SIGMAVBO,AOLABEL,NAOFRG,
     &               IOLVBO,IERR)
C
C     FIND TRAN MATRIX RMAT, WHICH TRANSLATE VBOLDIR TO VBODIR,
C     I.E. RMAT VBOLDIR = VBODIR
C
      CALL TRNV2V(VBOLDIR,VBODIR,RMAT,IERR)
      IF(IERR.EQ.1) CALL ABORT0('VBOGEN03  ')
      DO K=1, NAOFRG
      V(NAOSTI+K-1) = SIGMAVBO(K)
      ATEMP = AOLABEL(K)
      BTEMP = BFLABE(NAOSTI+K-1)
        IF(ATEMP(11:12).NE.BTEMP(11:12)) CALL ABORT0('VBOGEN02X ')
      END DO
C
C     TRANSLATE LIB VBO TO MOL VBO
C
      CALL ORBTRN(NAOFRG,1,BFLABE(NAOSTI),V(NAOSTI),RMAT,V(NAOSTI))
C
C     END OF IF BLOCK OF SIGMA BONDING VBO
C
      ELSE IF(NBTYPE.EQ.2.OR.NBTYPE.EQ.3) THEN
C
C     THIS IS A PI BONDING VBO, NA1 IS NON-ZERO!
C     ERROR CHECK FIRST!
C
      IF (NATOM1.LE.0) CALL ABORT0('VBOGEN04D ')
      IDXPI  = NBTYPE-1
      NATNUC = NATNNU(NATOM1)
      NBONDS = NBONDALIST(1,NATOM1)
      NAOSTI = NAOST(NATOM1)
C
C     FIND THE IDXPI DIRECTION
C
      CALL PIBDIR(NATOM1,NATOM2,IDXPI,VBODIR,IERR)
      IF(IERR.EQ.1) CALL ABORT0('GENPIVBO01')
C
C     LOOK UP THE IDXPI-th PI VBO ON NATOM1
C
      CALL LOOKPI(NATNUC,NBONDS,VBOLDIR,SIGMAVBO,AOLABEL,NAOFRG,IOLVBO)
C
C     FIND TRAN MATRIX RMAT, WHICH TRANSLATE VBOLDIR TO VBODIR,
C     I.E. RMAT VBOLDIR = VBODIR
C
      CALL TRNV2V(VBOLDIR,VBODIR,RMAT,IERR)
      IF(IERR.EQ.1) CALL ABORT0('VBOGEN03  ')
      DO K=1, NAOFRG
      V(NAOSTI+K-1) = SIGMAVBO(K)
      ATEMP = AOLABEL(K)
      BTEMP = BFLABE(NAOSTI+K-1)
        IF(ATEMP(11:12).NE.BTEMP(11:12)) CALL ABORT0('VBOGEN04E ')
      END DO
C
C     TRANSLATE LIB VBO TO MOL VBO
C
      CALL ORBTRN(NAOFRG,1,BFLABE(NAOSTI),V(NAOSTI),RMAT,V(NAOSTI))
C     END OF IF BLOCK OF PI BONDING VBO
      ELSE IF(NBTYPE.GE.3) THEN
      WRITE(IOUTVB,*)'YOU COME HERE MAYBE DUE TO ERROR!'
      WRITE(IOUTVB,*)'NBTYPE = ', NBTYPE
      END IF
      RETURN
      END
      SUBROUTINE FINDBPT(NBONDS,NBONDALIST,NATNNU,NATBPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NBONDALIST(*),NATNNU(*)
      NATBPT = 0
      IF(NBONDS.LE.0) RETURN
      NATBPT = NBONDALIST(1)
      NATNU  = NATNNU(NATBPT)
      DO I=1, NBONDS
      IF(NATNNU(NBONDALIST(I)).GT.NATNU) THEN
         NATBPT = NBONDALIST(I)
         NATNU = NATNNU(NATBPT)
      END IF
      END DO
      RETURN
      END
      DOUBLE PRECISION FUNCTION ATOMDIS(A,B)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(3),B(3)
      ATOMDIS = DSQRT((A(1)-B(1))**2+(A(2)-B(2))**2+(A(3)-B(3))**2)
      RETURN
      END
      SUBROUTINE LMOATMLIST(LOPTION,NORB,LMOATM,LMOALIST,LATMS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /MTOPOL/XYZMOL(3,1000),NATOMS,NATNNU(1001),
     &               NBONDALIST(10,1000),NBONDTYPE(10,1000)
      DIMENSION LMOATM(5,*),LMOALIST(*),LATMS(*),NEIB(100) 
      NA=1
      DO I=1, NORB
      LATMS(I) = NA
        NB = 0
        DO J=1, LMOATM(5,I)
         NB = NB + 1
         NEIB(NB) = LMOATM(J,I)
         NA = NA + 1
        END DO
C       
C       OPTION 2, ADD FIRST NEIGHBOR
C
        NC = NB
        IF(LOPTION.EQ.2) THEN
        DO J=1, NB
         DO K=1, NBONDALIST(1,NEIB(J))
           NEWX=1
           KATOM = NBONDALIST(K+1,NEIB(J))
           DO L=1,NC
              IF(NEIB(L).EQ.KATOM) NEWX=0
           END DO 
           IF(NEWX.EQ.1) THEN
              NC=NC+1
              NEIB(NC)=KATOM
           END IF
         END DO
        END DO   
        END IF
        DO K=1,NC
        LMOALIST(NA+K-1) = NEIB(K)
        END DO
        NA = NA + NC
        LATMS(I+1) = NA      
      END DO
      RETURN
      END
      SUBROUTINE INIMOLTOPOL()
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      PARAMETER (MAXCEN=200,MAXBFN=726)
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
      COMMON /MTOPOL/XYZMOL(3,1000),NATOMS,NATNNU(1001),
     &               NBONDALIST(10,1000),NBONDTYPE(10,1000)
      NATOMS = NATOM
      DO I=1, NATOMS
      NATNNU(I) = NATNUM(I)
        DO J=1, 3
        XYZMOL(J,I) = XYZ(J,I)
        END DO
      END DO
      CALL FINDNB(NATOMS,NATNNU,XYZMOL,NBONDALIST,NBONDTYPE)
      DO I=1, NATOMS
        DO J=1, NBONDALIST(1,I)
C       WRITE(IOUTVB,*)'I,NBA,NBTYPE =',I,NBONDALIST(J+1,I),NBONDTYPE(J+1,I)
        END DO
      END DO
C
C     TOPOL INFO CAN BE LOADED EXPLICITLY (FOR INSTANCE FROM A SD FILE
C
C     TO DO:
C     ALSO DO SOME SANITIZING CHECK USING SIMPLE RULES AND MAKE CORRECTIONS
C
      RETURN
      END
C
C     FIND THE SIGMA VBO OF NATCNT POINTING TO NATBPT
C
      SUBROUTINE SIGMADIR(NATCNT,NATBPT,VBDIR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION VBDIR(3)
      COMMON /MTOPOL/XYZMOL(3,1000),NATOMS,NATNNU(1001),
     &               NBONDALIST(10,1000),NBONDTYPE(10,1000)
      VBDIR(1) = XYZMOL(1,NATBPT) - XYZMOL(1,NATCNT)
      VBDIR(2) = XYZMOL(2,NATBPT) - XYZMOL(2,NATCNT)
      VBDIR(3) = XYZMOL(3,NATBPT) - XYZMOL(3,NATCNT)
      CALL VECNORM(VBDIR,IFLAG)
      RETURN
      END
C
C     FIND THE PI VBO OF NATCNT BONDING TO NATBPT
C
      SUBROUTINE PIBDIR(NATCNT,NATBPT,IDXPI,PIVBDIR,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION PIVBDIR(3),SGMDIR(3),TMPDIR(3),NBLIST(10)
      DIMENSION XAXIS(3),YAXIS(3),ZAXIS(3),PIXDIR(3),PIYDIR(3)
      LOGICAL APIDIR
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /MTOPOL/XYZMOL(3,1000),NATOMS,NATNNU(1001),
     &               NBONDALIST(10,1000),NBONDTYPE(10,1000)
      DATA XAXIS,YAXIS,ZAXIS/1.0D0,0.0D0,0.0D0,0.0D0,1.0D0,0.0D0,
     &                       0.0D0,0.0D0,1.0D0/
C
C     SIMPLE CASE: IDXPI = 1, AND NATCNT IS A SP2 ATOM
C
      APIDIR = .FALSE.
      IF(NATCNT.EQ.0.OR.NATBPT.EQ.0) CALL ABORT0('PIBDIR00  ')
      NBONDS = NBONDALIST(1,NATCNT)
      CALL ATOMPIDIR(NATCNT,NBONDS,NBONDALIST(2,NATCNT),XYZMOL,
     &               APIDIR,PIVBDIR)
      IF(IDXPI.EQ.1.AND.APIDIR) THEN
        IERR = 0
        RETURN
      END IF
C
C     CHECK FIRST NEIGHBOR
C
      NBONDS = NBONDALIST(1,NATBPT)
      CALL ATOMPIDIR(NATBPT,NBONDS,NBONDALIST(2,NATBPT),XYZMOL,
     &               APIDIR,PIVBDIR)
      IF(IDXPI.EQ.1.AND.APIDIR) THEN
        IERR = 0
        RETURN
      END IF
      IF(IDXPI.GT.1.AND.APIDIR) THEN
        IERR = 1
        WRITE(IOUTVB,*)'IT SEEMS ONLY ONE PI ORBITAL ON THIS ATOM !!!'
        CALL ABORT0('PIBDIR01  ')
        RETURN
      END IF
C
C     NOW, HANDLE CASE ATOMPIDIR CAN NOT DEFINED BY THE CENTER ATOM ITSELF
C     USUALLY, THIS MEANS THAT THIS IS A TRIPLE BOND ATOM
C
C     FIND NATCNT AND NATBPT's NEIGBOR, AND AND OF THEY NEIGHBOR IS A CONJUGATE
C     ATOM, USE THAT ONE AS THE FIRST VBPIDIR
C
      NNB = 0
      DO I=1, NBONDALIST(1,NATCNT)
      IF(NBONDALIST(I+1,NATCNT).NE.NATBPT) THEN
        NNB = NNB + 1
        NBLIST(NNB) = NBONDALIST(I+1,NATCNT)
      END IF
      END DO
      DO I=1, NBONDALIST(1,NATBPT)
      IF(NBONDALIST(I+1,NATBPT).NE.NATCNT) THEN
        NNB = NNB + 1
        NBLIST(NNB) = NBONDALIST(I+1,NATBPT)
      END IF
      END DO
C
      DO I=1, NNB
      IAT = NBLIST(I)
      NBONDS = NBONDALIST(1,IAT)
      CALL ATOMPIDIR(IAT,NBONDS,NBONDALIST(2,IAT),XYZMOL,
     &               APIDIR,PIVBDIR)
      IF (APIDIR) GOTO 100
      END DO
 100  CONTINUE
      IF(APIDIR) THEN
C
C     USE PIVBDIR AND NATCNT-NATBPT VECTOR TO DEFINE THE THIRD ONE
C
      IF(IDXPI.EQ.1) RETURN
      IF(NATBPT.LE.0) CALL ABORT0('PIBDIR02  ')
      CALL SIGMADIR(NATCNT,NATBPT,SGMDIR)
      CALL XPROD(SGMDIR,PIVBDIR,TMPDIR)
        IF(IDXPI.EQ.2) THEN
          PIVBDIR(1) = TMPDIR(1)
          PIVBDIR(2) = TMPDIR(2)
          PIVBDIR(3) = TMPDIR(3)
          RETURN
        ELSE
        CALL ABORT0('PIBDIR03  ')
        END IF
      ELSE
C
C     USE THE ORIENTATION OF NATCNT-NATBPT ONLY TO DEFINE
C
C     FIND THE SMALLEST ANGLE WITH X,Y,Z AXIS
C
      CALL SIGMADIR(NATCNT,NATBPT,SGMDIR)
C     WRITE(IOUTVB,*)'USE ORIENTATION TO BUILD PI DIR'
C     WRITE(IOUTVB,*)'SGMDIR =',(SGMDIR(K),K=1,3)
C     WRITE(IOUTVB,*)'XAXIS  =',(XAXIS(K),K=1,3)
      CALL DOTPROD(XAXIS,SGMDIR,XBDIR)
      CALL DOTPROD(YAXIS,SGMDIR,YBDIR)
      CALL DOTPROD(ZAXIS,SGMDIR,ZBDIR)
      AXBDIR = DABS(XBDIR)
      AYBDIR = DABS(YBDIR)
      AZBDIR = DABS(ZBDIR)
C     WRITE(IOUTVB,*)'AXYZ=',AXBDIR,AYBDIR,AZBDIR
C
C     AZBDIR is the largest
C
      IF(AZBDIR.GE.AXBDIR.AND.AZBDIR.GE.AYBDIR) THEN
C
C     PIXDIR = XAXIS - XBDIR*SGMDIR
C
        DO I=1, 3
        PIXDIR(I) = XAXIS(I) - XBDIR*SGMDIR(I)
        END DO
C     WRITE(IOUTVB,*)'PIXDIR  =',(PIXDIR(K),K=1,3)
C
C     PIYDIR = SGMDIR X PIXDIR
C
      CALL XPROD(SGMDIR,PIXDIR,PIYDIR)

      CALL VECNORM(PIXDIR,IFLAG)
      CALL VECNORM(PIYDIR,IFLAG)
C
C     MAKE SURE THAT THE TWO C#C CARBONS HAVE THE SAME PIYDIR
C
      CALL DOTPROD(YAXIS,PIYDIR,YPIYDIR)
      IF(YPIYDIR.LT.0.0D0) CALL VECINV(PIYDIR)
      ELSE IF (AXBDIR.GE.AYBDIR.AND.AXBDIR.GT.AZBDIR) THEN
C
C     PIXDIR = YAXIS - YBDIR*SGMDIR
C
        DO I=1, 3
        PIXDIR(I) = YAXIS(I) - YBDIR*SGMDIR(I)
        END DO
C
C     PIYDIR = SGMDIR X PIXDIR
C
      CALL XPROD(SGMDIR,PIXDIR,PIYDIR)

      CALL VECNORM(PIXDIR,IFLAG)
      CALL VECNORM(PIYDIR,IFLAG)
C
C     MAKE SURE THAT THE TWO C#C CARBONS HAVE THE SAME PIYDIR
C
      CALL DOTPROD(ZAXIS,PIYDIR,ZPIYDIR)
      IF(ZPIYDIR.LT.0.0D0) CALL VECINV(PIYDIR)
      ELSE
C
C     PIXDIR = ZAXIS - ZBDIR*SGMDIR
C
        DO I=1, 3
        PIXDIR(I) = ZAXIS(I) - ZBDIR*SGMDIR(I)
        END DO
C
C     PIYDIR = SGMDIR X PIXDIR
C
      CALL XPROD(SGMDIR,PIXDIR,PIYDIR)
      CALL VECNORM(PIXDIR,IFLAG)
      CALL VECNORM(PIYDIR,IFLAG)
C
C     MAKE SURE THAT THE TWO C#C CARBONS HAVE THE SAME PIYDIR
C
      CALL DOTPROD(XAXIS,PIYDIR,XPIYDIR)
      IF(XPIYDIR.LT.0.0D0) CALL VECINV(PIYDIR)
      END IF
      END IF
C
C     COPY PIDIR TO PIVBDIR
C
      IF(IDXPI.EQ.1) THEN
        DO I=1, 3
        PIVBDIR(I) = PIXDIR(I)
        END DO
      ELSE IF(IDXPI.EQ.2) THEN
        DO I=1, 3
        PIVBDIR(I) = PIYDIR(I)
        END DO
      ELSE
        WRITE(IOUTVB,*)'UNKNOWN PI DIR, STOP'
        CALL ABORT0('PIBDIR04  ')
      END IF
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     FIND THE LONE PAIR VBO OF ATOM NATCNT
C     NATCNT:  ATOM INDEX
C     LPDEX:   THE INDEX OF LP (1,2,3)
C     PLVBDIR: LP DIRECTION
C     IERR:    ERROR CODE 1/0 (ERR/NO-ERR)
C
C     FIRST CREATED: OCT. 4, 2003
C
C     AUTHOR: Jiabo LI
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE LPDIR(NATCNT,LPDEX,PLVBDIR,LPTYP,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION PLVBDIR(3),TMPDIR(3,5),LPTYPE(10)
C
      CALL FINDLPDIR(NATCNT,NLP,LPTYPE,TMPDIR,IERR)
      LPTYP = LPTYPE(LPDEX)
      IF(IERR.EQ.1) CALL ABORT0('LPDIR01   ')
      IF(NLP.LT.LPDEX) CALL ABORT0('LPDIR02   ')
      DO I=1, 3
      PLVBDIR(I) = TMPDIR(I,LPDEX)
      END DO
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     FIND ALL LONE PAIR VBO(s) OF ATOM NATCNT
C     NATCNT:  ATOM INDEX
C     NLP:     THE NUMBER OF OF LP (0,1,2,3,4)
C              IN NORMAL CASE, NLP=1,2,3
C              NOTE: DON'T RELY ON THIS FUNCTION TO DETECT THE NUMBER OF
C              LONE PAIRS, SINCE IT ONLY USE THE CONNECTIVITY INFO, AND
C              IT IS THE CALLER'S RESPONSIBILITY TO USE IT CORRECTLY.
C
C     PLVBDIR: LP DIRECTIONS
C     IERR:    ERROR CODE 1/0 (ERR/NO-ERR)
C              IF NO LP OR ISOLATE ATOM, IERR=1
C
C     FIRST CREATED: OCT. 4, 2003
C
C     AUTHOR: Jiabo LI
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE FINDLPDIR(NATCNT,NLP,LPTYPE,PLVBDIR,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL APIDIR
      DIMENSION PLVBDIR(3,*),TMPDIR(3),V1(3),V2(3),LPTYPE(10)
C     DIMENSION XAXIS(3),YAXIS(3),ZAXIS(3),PL1DIR(3),PL2DIR(3),PL3DIR(3)
      DIMENSION PL1DIR(3),PL2DIR(3),PL3DIR(3)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /MTOPOL/XYZMOL(3,1000),NATOMS,NATNNU(1001),
     &               NBONDALIST(10,1000),NBONDTYPE(10,1000)
C     DATA XAXIS,YAXIS,ZAXIS/1.0D0,0.0D0,0.0D0,0.0D0,1.0D0,0.0D0,
C    &                       0.0D0,0.0D0,1.0D0/
      APIDIR = .FALSE.
      DO I=1, 3
      PL1DIR(I) = 0.0D0
      PL2DIR(I) = 0.0D0
      PL3DIR(I) = 0.0D0
      END DO
      IERR = 1
      NBONDS = NBONDALIST(1,NATCNT)
C
C     ERROR DETECTION
C
      IF(NBONDS.LE.0.OR.NBONDS.GT.3) THEN
      WRITE(IOUTVB,999) NBONDS
 999  FORMAT(' ** THERE MAYBE AN ERROR IN THE INPUT !!! - NBONDS =',I5)
      RETURN
      END IF
C
C     FIND THE FIRST LPDIR
C
      IF(NBONDS.LE.2) THEN
        DO I=1, NBONDS
        NATBPT = NBONDALIST(I+1,NATCNT)
          DO J=1, 3
          TMPDIR(J) = XYZMOL(J,NATCNT)-XYZMOL(J,NATBPT)
          END DO
        CALL VECNORM(TMPDIR,IFLAG)
          DO J=1, 3
          PL1DIR(J) = PL1DIR(J) + TMPDIR(J)
          END DO
        END DO
        CALL VECNORM(PL1DIR,IFLAG)
C
C       THE FIRST LP OF R-X, R1-X-R2 WITH BOND ANGLE NOT EQ 180 DEGREE CAN BE
C       HANDELED THIS WAY. THE CASE X AND -X- WITH 180 DEGREE BOND ANGLE, THIS
C       WILL FAIL
C
C
        IF(IFLAG.EQ.0.AND.NBONDS.EQ.2) THEN
        NA1 = NATCNT
        NA2 = NBONDALIST(2,NATCNT)
        NA3 = 0
C       WRITE(IOUTVB,*)'NA1, NA2, NA3 =', NA1, NA2, NA3
        CALL LOCXYZ(NA1,NA2,NA3,XYZMOL,PL1DIR,PL2DIR,PL3DIR)
          DO I=1, 3
          PLVBDIR(I,1) = PL2DIR(I)
          PLVBDIR(I,2) = PL3DIR(I)
          END DO
        NLP = 2
        IERR = 0
C       WRITE(IOUTVB,*)'NLP = ', NLP
        LPTYPE(1) = 2
        LPTYPE(2) = 2
        RETURN
        END IF
        IF(IFLAG.EQ.0) CALL ABORT0('FNDLPDIR01')
      ELSE
C
C       THIS CAN BE A CASE OF -NH2, N AND ALL ITS 3 NEIBS ARE ON THE SAME PLAN
C       USING THE LOGIC FOR PI DIR.
C
        APIDIR = .FALSE.
        CALL ATOMPIDIR(NATCNT,NBONDS,NBONDALIST(2,NATCNT),XYZMOL,
     &               APIDIR,PL1DIR)
        IF(.NOT.APIDIR) CALL ABORT0('FNDLPDIR02')
      END IF
      NLP=1
      LPTYPE(1) = 1
      IERR = 0
      DO I=1, 3
      PLVBDIR(I,1) = PL1DIR(I)
      END DO
      IF(NBONDS.GE.3) RETURN
C     FIND THE SECOND LPDIR. IF NBONDS.GE.3, NO SECOND LP, RETURN
C
C     CASE 1, THE CENTER ATOM HAS TWO NEIGHBORS, SUCH AS -O-, -S- in H2O, Furan
C
      IF(NBONDS.EQ.2) THEN
        NA0 = NATCNT
        NA1 = NBONDALIST(2,NATCNT)
        NA2 = NBONDALIST(3,NATCNT)
          DO I=1, 3
          V1(I) = XYZMOL(I,NA1)-XYZMOL(I,NA0)
          V2(I) = XYZMOL(I,NA2)-XYZMOL(I,NA0)
          END DO
        CALL XPROD(V1,V2,PL2DIR)
        CALL VECNORM(PL2DIR,IFLAG)
        NLP=2
        IERR = 0
        DO I=1, 3
        PLVBDIR(I,2) = PL2DIR(I)
        END DO
        LPTYPE(1) = 1
        LPTYPE(2) = 2
        RETURN
      ELSE
C
C     CASE NBONDS.LE.1
C
C
C     THE ONLY CASE IS R-X, WHERE R IS A R-, Ph- AND X CAN BE -F, -Cl, -Br, -I
C     AND -O(-1).
C     IF X IS CONNECTED TO A CONJUGATE ATOM, SUCH AS A DOUBLE BONDED ATOM, OR
C     BENZENE RING, THE FIRST LP IS THE OPPOSITE DIRECTION OF R-X BOND, AND
C     THE SECOND LP IS THE PERPENDICULAR TO THE R-X BOND AND IN THE CONJUGATE
C     PLAN, I.E. PERPENDICULAR TO THE PIDIR
C
C     IF X IS NOT ATTATCHED TO A CONJUGATE ATOM, THEN USE THE RULE FOR LOCAL
C     XYZ
C
C
C     CASE 2, THE CENTER ATOM HAS ONLY ONE BOND CONNECTION, SUCH AS >C=O,
C     R-O(-), Ph-O(-). IF THE NEIGHBOR IS A CONJUGATE CENTER, THE SECOND LP
C     SHOULD BE IN THE PLANE OF CONJUGATION, I.E.
C
C
      IF(NBONDS.NE.1) CALL ABORT0('FNDLPDIR03')
      NAT = NBONDALIST(2,NATCNT)
      APIDIR = .FALSE.
      NBONDS = NBONDALIST(1,NAT)
      CALL ATOMPIDIR(NAT,NBONDS,NBONDALIST(2,NAT),XYZMOL,
     &               APIDIR,PL3DIR)
C       ONE NEIGHBOR. CASE 2A: IT IS A CONJUGATE ATOM
        IF(APIDIR) THEN
        CALL XPROD(PL3DIR,PL1DIR,PL2DIR)
        CALL VECNORM(PL2DIR,IFLAG)
        IF(IFLAG.EQ.0) CALL ABORT0('FNDLPDIR04')
          DO I=1, 3
          PLVBDIR(I,2) = PL2DIR(I)
          PLVBDIR(I,3) = PL3DIR(I)
          END DO
        NLP = 3
        IERR = 0
        LPTYPE(1) = 1
        LPTYPE(2) = 2
        LPTYPE(3) = 2
        RETURN
        ELSE
C       ONE NEIGHBOR. CASE 2B: IT IS NOT A CONJUGATE ATOM
C
C       LOCAL XYZ RULES
C
        NA3 = 0
        NA2 = 0
        NA1 = NATCNT
        IF(NBONDS.GT.0) NA2 = NBONDALIST(2,NATCNT)
          IF(NA2.GT.0.AND.NBONDALIST(1,NA2).GT.0) THEN
          NA3 = NBONDALIST(2,NA2)
          END IF
        CALL LOCXYZ(NA1,NA2,NA3,XYZMOL,PL1DIR,PL2DIR,PL3DIR)
          DO I=1, 3
          PLVBDIR(I,2) = PL2DIR(I)
          PLVBDIR(I,3) = PL3DIR(I)
          END DO
        NLP = 3
        IERR = 0
        LPTYPE(1) = 1
        LPTYPE(2) = 2
        LPTYPE(3) = 2
        END IF
      END IF
      RETURN
      END
C
C     DEFINE A LOCAL XYZ DIRECTIONS BY USING THREE ATOMS
C     NA1-NA2-NA3. NA1->NA2 WILLBE THE X-AXIS, and NA2->NA3 WILL BE IN THE PLAN
C     OF XY
C
      SUBROUTINE LOCXYZ(NA1,NA2,NA3,XYZ,AX,AY,AZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     DIMENSION XYZ(3,*),AX(3),AY(3),AZ(3),TMPDIR(3)
      DIMENSION XYZ(3,*),AX(3),AY(3),AZ(3)
      DIMENSION XAXIS(3),YAXIS(3),ZAXIS(3)
      DATA XAXIS,YAXIS,ZAXIS/1.0D0,0.0D0,0.0D0,0.0D0,1.0D0,0.0D0,
     &                       0.0D0,0.0D0,1.0D0/
      IF(NA1.EQ.0.OR.NA2.EQ.0) CALL ABORT0('LOCXYZ01  ')
      AX(1) = XYZ(1,NA2) - XYZ(1,NA1)
      AX(2) = XYZ(2,NA2) - XYZ(2,NA1)
      AX(3) = XYZ(3,NA2) - XYZ(3,NA1)
      CALL VECNORM(AX,IFLAG)
      IF(IFLAG.EQ.0) CALL ABORT0('LOCXYZ02  ')
      IF(NA3.NE.0) THEN
      AY(1) = XYZ(1,NA3) - XYZ(1,NA2)
      AY(2) = XYZ(2,NA3) - XYZ(2,NA2)
      AY(3) = XYZ(3,NA3) - XYZ(3,NA2)
      CALL XPROD(AX,AY,AZ)
      CALL VECNORM(AZ,IFLAG)
      IF(IFLAG.EQ.0) GOTO 100
      CALL XPROD(AZ,AX,AY)
      RETURN
      END IF
 100  CONTINUE
C
C     IF NA3.EQ.0, USE THE ORIENTATION OF NA1-NA2 ONLY TO DEFINE
C
C     FIND THE SMALLEST ANGLE WITH X,Y,Z AXIS
C
      CALL DOTPROD(XAXIS,AX,XBDIR)
      CALL DOTPROD(YAXIS,AX,YBDIR)
      CALL DOTPROD(ZAXIS,AX,ZBDIR)
      AXBDIR = DABS(XBDIR)
      AYBDIR = DABS(YBDIR)
      AZBDIR = DABS(ZBDIR)
C
C     AXBDIR is the largest
C
      IF (AXBDIR.GE.AYBDIR.AND.AXBDIR.GT.AZBDIR) THEN
C     X -> X', Y -> Y', Z -> Z'
C
C     AY = YAXIS - YBDIR*AX, AX IS NORMALIZED
C
        DO I=1, 3
        AY(I) = YAXIS(I) - YBDIR*AX(I)
        END DO
        CALL VECNORM(AY,IFLAG)
C
C     AZ = AX X AY
C
      CALL XPROD(AX,AY,AZ)
      ELSE IF(AYBDIR.GE.AXBDIR.AND.AYBDIR.GE.AZBDIR) THEN
C     Y -> X', Z -> Y', X -> Z'
C
C     AY = ZAXIS - ZBDIR*AX
C
        DO I=1, 3
        AY(I) = ZAXIS(I) - ZBDIR*AX(I)
        END DO
        CALL VECNORM(AY,IFLAG)
C
C     AZ = AX X AY
C
      CALL XPROD(AX,AY,AZ)
      ELSE
C     X -> Y', Y -> Z', Z -> X'
C
C     AY = XAXIS - XBDIR*AX
C
        DO I=1, 3
        AY(I) = XAXIS(I) - XBDIR*AX(I)
        END DO
        CALL VECNORM(AY,IFLAG)
C
C     AZ = AX X AY
C
      CALL XPROD(AX,AY,AZ)
      END IF
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     FIND PI ORBITAL DIRECTION ON ATOM NATCNT
C
C     IF IT IS NOT A CONJUGATE ATOM, RETURN FALSE (APIDIR)
C     OR IT IS A CONJUGATE ATOM, BUT THE PI ORBITAL DIRECTION CAN NOT
C     DETERMINED UNIQUELY, THEN RETURN APIDIR=.FALSE.
C
C     FIRST CREATED OCT.5 2003
C
C     AUTHOR: JIABO LI
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE ATOMPIDIR(NATCNT,NBONDS,NBALIST,XYZ,APIDIR,ATMPIDIR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL APIDIR
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION NBALIST(*),ATMPIDIR(3),XYZ(3,*),A(3),B(3),C(3)
      DIMENSION D(3),TMPDIR(3)
C     DIMENSION XAXIS(3),YAXIS(3),ZAXIS(3),PIXDIR(3),PIYDIR(3)
      DIMENSION XAXIS(3),YAXIS(3),ZAXIS(3)
      DATA XAXIS,YAXIS,ZAXIS/1.0D0,0.0D0,0.0D0,0.0D0,1.0D0,0.0D0,
     &                       0.0D0,0.0D0,1.0D0/
      IF(NBONDS.LE.1) THEN
      APIDIR = .FALSE.
      RETURN
      END IF
      IA = NATCNT
C
C     FIND THE PI DIR OF b-a-c
C
      IF(NBONDS.EQ.2) THEN
C
C     A = (b-a), B = (c-a)
C
      IB = NBALIST(1)
      IC = NBALIST(2)
      A(1) = XYZ(1,IB) - XYZ(1,IA)
      A(2) = XYZ(2,IB) - XYZ(2,IA)
      A(3) = XYZ(3,IB) - XYZ(3,IA)
      B(1) = XYZ(1,IC) - XYZ(1,IA)
      B(2) = XYZ(2,IC) - XYZ(2,IA)
      B(3) = XYZ(3,IC) - XYZ(3,IA)
      CALL XPROD(A,B,ATMPIDIR)
C
C     CHECK THE LENGTH OF ATMPIDIR
C
      RVEC = DSQRT(ATMPIDIR(1)**2+ATMPIDIR(2)**2+ATMPIDIR(3)**2)
C
C     IN CASE b-a-c are near colinear REUTRN WITH ERROR.
C     THE PARAMETER CAN BE ADJUSTED
C
      IF(RVEC.LT.0.1D0) RETURN
      CALL VECNORM(ATMPIDIR,IFLAG)
      IF(IFLAG.EQ.1) APIDIR = .TRUE.
      GOTO 200
      ELSE IF(NBONDS.EQ.3) THEN
C
C     A-(B,C,D)
C
      IB = NBALIST(1)
      IC = NBALIST(2)
      ID = NBALIST(3)
      A(1) = XYZ(1,IB) - XYZ(1,IA)
      A(2) = XYZ(2,IB) - XYZ(2,IA)
      A(3) = XYZ(3,IB) - XYZ(3,IA)
      B(1) = XYZ(1,IC) - XYZ(1,IA)
      B(2) = XYZ(2,IC) - XYZ(2,IA)
      B(3) = XYZ(3,IC) - XYZ(3,IA)
      C(1) = XYZ(1,ID) - XYZ(1,IA)
      C(2) = XYZ(2,ID) - XYZ(2,IA)
      C(3) = XYZ(3,ID) - XYZ(3,IA)
      CALL XPROD(A,B,ATMPIDIR)
      CALL XPROD(B,C,TMPDIR)
      CALL DOTPROD(ATMPIDIR,TMPDIR,PROD)
      IF(PROD.LT.0.0D0) CALL VECINV(TMPDIR)
      CALL VECAD(ATMPIDIR,TMPDIR,ATMPIDIR,3)
      CALL XPROD(A,C,TMPDIR)
      CALL DOTPROD(ATMPIDIR,TMPDIR,PROD)
      IF(PROD.LT.0.0D0) CALL VECINV(TMPDIR)
      CALL VECAD(ATMPIDIR,TMPDIR,ATMPIDIR,3)
      CALL VECNORM(ATMPIDIR,IFLAG)
      IF(IFLAG.EQ.0) WRITE(IOUTVB,*)'ERROR IN VECNORM'
      CALL DOTPROD(ATMPIDIR,A,AAPI)
      CALL DOTPROD(ATMPIDIR,B,BAPI)
      CALL DOTPROD(ATMPIDIR,C,CAPI)
      IF (AAPI+BAPI+CAPI.GT.0.0D0) CALL VECINV(ATMPIDIR)
      APIDIR = .TRUE.
      GOTO 200
      ELSE IF(NBONDS.EQ.4) THEN
      WRITE(IOUTVB,*)'WARNING: THIS IS A RARE CASE, PLEASE MAKE SURE'
      WRITE(IOUTVB,*)'         YOUR INPUT IS CORRECT.'
C
C     A-(B,C,D,E)
C
      IB = NBALIST(1)
      IC = NBALIST(2)
      ID = NBALIST(3)
      IE = NBALIST(4)
      A(1) = XYZ(1,IB) - XYZ(1,IA)
      A(2) = XYZ(2,IB) - XYZ(2,IA)
      A(3) = XYZ(3,IB) - XYZ(3,IA)
      B(1) = XYZ(1,IC) - XYZ(1,IA)
      B(2) = XYZ(2,IC) - XYZ(2,IA)
      B(3) = XYZ(3,IC) - XYZ(3,IA)
      C(1) = XYZ(1,ID) - XYZ(1,IA)
      C(2) = XYZ(2,ID) - XYZ(2,IA)
      C(3) = XYZ(3,ID) - XYZ(3,IA)
      D(1) = XYZ(1,IE) - XYZ(1,IA)
      D(2) = XYZ(2,IE) - XYZ(2,IA)
      D(3) = XYZ(3,IE) - XYZ(3,IA)
      CALL DOTPROD(A,A,A2)
      CALL DOTPROD(B,B,B2)
      CALL DOTPROD(C,C,C2)
      CALL DOTPROD(D,D,D2)
      ATMPIDIR(1) = 0.0D0
      ATMPIDIR(2) = 0.0D0
      ATMPIDIR(3) = 0.0D0
C     Angle AB < 135 degree, otherwise, remove it
      CALL DOTPROD(A,B,AB)
      AB135 = -0.707D0*DSQRT(A2*B2)
        IF(AB.GT.AB135) THEN
        CALL XPROD(A,B,TMPDIR)
        CALL DOTPROD(ATMPIDIR,TMPDIR,PROD)
        IF(PROD.LT.0.0D0) CALL VECINV(TMPDIR)
        CALL VECAD(ATMPIDIR,TMPDIR,ATMPIDIR,3)
        END IF
C     Angle AC < 135 degree, otherwise, remove it
      CALL DOTPROD(A,C,AC)
      AC135 = -0.707D0*DSQRT(A2*C2)
        IF(AC.GT.AC135) THEN
        CALL XPROD(A,C,TMPDIR)
        CALL DOTPROD(ATMPIDIR,TMPDIR,PROD)
        IF(PROD.LT.0.0D0) CALL VECINV(TMPDIR)
        CALL VECAD(ATMPIDIR,TMPDIR,ATMPIDIR,3)
        END IF
C     Angle AD < 135 degree, otherwise, remove it
      CALL DOTPROD(A,D,AD)
      AD135 = -0.707D0*DSQRT(A2*D2)
        IF(AD.GT.AD135) THEN
        CALL XPROD(A,D,TMPDIR)
        CALL DOTPROD(ATMPIDIR,TMPDIR,PROD)
        IF(PROD.LT.0.0D0) CALL VECINV(TMPDIR)
        CALL VECAD(ATMPIDIR,TMPDIR,ATMPIDIR,3)
        END IF
C     Angle BC < 135 degree, otherwise, remove it
      CALL DOTPROD(B,C,BC)
      BC135 = -0.707D0*DSQRT(B2*C2)
        IF(BC.GT.BC135) THEN
        CALL XPROD(B,C,TMPDIR)
        CALL DOTPROD(ATMPIDIR,TMPDIR,PROD)
        IF(PROD.LT.0.0D0) CALL VECINV(TMPDIR)
        CALL VECAD(ATMPIDIR,TMPDIR,ATMPIDIR,3)
        END IF
C     Angle BD < 135 degree, otherwise, remove it
      CALL DOTPROD(B,D,BD)
      BD135 = -0.707D0*DSQRT(B2*D2)
        IF(BD.GT.BD135) THEN
        CALL XPROD(B,D,TMPDIR)
        CALL DOTPROD(ATMPIDIR,TMPDIR,PROD)
        IF(PROD.LT.0.0D0) CALL VECINV(TMPDIR)
        CALL VECAD(ATMPIDIR,TMPDIR,ATMPIDIR,3)
        END IF
C     Angle CD < 135 degree, otherwise, remove it
      CALL DOTPROD(C,D,CD)
      CD135 = -0.707D0*DSQRT(C2*D2)
        IF(CD.GT.CD135) THEN
        CALL XPROD(C,D,TMPDIR)
        CALL DOTPROD(ATMPIDIR,TMPDIR,PROD)
        IF(PROD.LT.0.0D0) CALL VECINV(TMPDIR)
        CALL VECAD(ATMPIDIR,TMPDIR,ATMPIDIR,3)
        END IF
      CALL DOTPROD(ATMPIDIR,A,AAPI)
      CALL DOTPROD(ATMPIDIR,B,BAPI)
      CALL DOTPROD(ATMPIDIR,C,CAPI)
      CALL DOTPROD(ATMPIDIR,D,DAPI)
      IF (AAPI+BAPI+CAPI+DAPI.GT.0.0D0) CALL VECINV(ATMPIDIR)
      GOTO 200
      ELSE
C
C     NBONDS >4, TI IS NOT POSSIBLE TO DETERMINE THE PI DIR
C
      APIDIR = .FALSE.
      RETURN
      END IF
 200  CONTINUE
C
C     TO MAKE SURE THE PIDIR ORIENTATION IS NOT TOO ARBITARY
C     IT MAY NOT ALWAYS WORK, BUT SHOULD BE GOOD ENOUGH
C
      CALL DOTPROD(XAXIS,ATMPIDIR,XBDIR)
      CALL DOTPROD(YAXIS,ATMPIDIR,YBDIR)
      CALL DOTPROD(ZAXIS,ATMPIDIR,ZBDIR)
      AXBDIR = DABS(XBDIR)
      AYBDIR = DABS(YBDIR)
      AZBDIR = DABS(ZBDIR)
      IF(AXBDIR.GT.AYBDIR.AND.AXBDIR.GT.AZBDIR) THEN
C
C     ATMPIDIR IN X-AXIS DIR
C
        IF(XBDIR.LT.0.0D0) CALL VECINV(ATMPIDIR)
        RETURN
      ELSE IF(AYBDIR.GT.AZBDIR) THEN
C
C     ATMPIDIR IN Y-AXIS DIR
C
        IF(YBDIR.LT.0.0D0) CALL VECINV(ATMPIDIR)
        RETURN
      ELSE IF(ZBDIR.LT.0.0D0) THEN
C
C     ATMPIDIR IN Z-AXIS DIR
C
        CALL VECINV(ATMPIDIR)
        RETURN
      END IF
      RETURN
      END
      SUBROUTINE XPROD(A,B,C)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(3),B(3),C(3)
      C(1) = A(2)*B(3) - A(3)*B(2)
      C(2) = A(3)*B(1) - A(1)*B(3)
      C(3) = A(1)*B(2) - A(2)*B(1)
      RETURN
      END
      SUBROUTINE DOTPROD(A,B,C)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(3),B(3)
      C = A(1)*B(1) + A(2)*B(2) + A(3)*B(3)
      RETURN
      END
      SUBROUTINE VECNORM(A,IFLAG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(3)
      IFLAG = 0
      C = A(1)*A(1) + A(2)*A(2) + A(3)*A(3)
      IF(C.GT.1.0D-7) THEN
      C = DSQRT(C)
      A(1) = A(1) / C
      A(2) = A(2) / C
      A(3) = A(3) / C
      IFLAG = 1
      END IF
      RETURN
      END
      SUBROUTINE VECINV(A)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(3)
      A(1) = -A(1)
      A(2) = -A(2)
      A(3) = -A(3)
      RETURN
      END
      SUBROUTINE VECAD(A,B,C,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(*),B(*),C(*)
      DO I=1, N
      C(I) = A(I) + B(I)
      END DO
      RETURN
      END
      SUBROUTINE LOOKPIVBO(NATNUMPI,NBONDS,FRGXYZ,FRGORB,FRGAOLB,NAFRAG,
     &                     NAOFRG,IOLVBO,VBOLDIR)
C    &                     NAOFRG,IOLVBO,BASNAME,VBOLDIR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*20 BASNAME
      CHARACTER*12 FRGAOLB(*)
      CHARACTER*80 LOBNAME
      DIMENSION FRGXYZ(3,*),FRGORB(*),NATFRAG(30),VBOLDIR(3)
C     CHARACTER*3 FUNIT(10)
C     CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
C     COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
C     SEARCH MAP FOR Li, Be, B, C, N, O, F, Na, Mg, Al, Si, P, S, Cl, Br, I
C
      LOBNAME = '@#$%'
      IF (NATNUMPI.EQ.1)  LOBNAME = '$PI-H-IN-HH'
      IF (NATNUMPI.EQ.1)  LSTR    = 11
      IF (NATNUMPI.EQ.3)  LOBNAME = '$PI-LI-IN-LIH'
      IF (NATNUMPI.EQ.3)  LSTR    = 13
      IF (NATNUMPI.EQ.4)  LOBNAME = '$PI-BE-IN-H2BE'
      IF (NATNUMPI.EQ.4)  LSTR    = 14
      IF (NATNUMPI.EQ.5)  LOBNAME = '$PI-B-IN-BH3'
      IF (NATNUMPI.EQ.5)  LSTR    = 12
      IF (NATNUMPI.EQ.6)  LOBNAME = '$PI-C-IN-C2H4'
      IF (NATNUMPI.EQ.6)  LSTR    = 13
      IF (NATNUMPI.EQ.7)  LOBNAME = '$PI-N-IN-CH2NH'
      IF (NATNUMPI.EQ.7)  LSTR    = 14
      IF (NATNUMPI.EQ.8)  LOBNAME = '$PI-O-IN-CH2O'
      IF (NATNUMPI.EQ.8)  LSTR    = 13
      IF (NATNUMPI.EQ.9)  LOBNAME = '$PI-F-IN-HF'
      IF (NATNUMPI.EQ.9)  LSTR    = 11
      IF (NATNUMPI.EQ.11) LOBNAME = '$PI-NA-IN-NAH'
      IF (NATNUMPI.EQ.11) LSTR    = 13
      IF (NATNUMPI.EQ.12) LOBNAME = '$PI-MG-IN-MGH2'
      IF (NATNUMPI.EQ.12) LSTR    = 14
      IF (NATNUMPI.EQ.13) LOBNAME = '$PI-AL-IN-ALH3'
      IF (NATNUMPI.EQ.13) LSTR    = 14
      IF (NATNUMPI.EQ.14) LOBNAME = '$PI-SI-IN-SIH3'
      IF (NATNUMPI.EQ.14) LSTR    = 14
      IF (NATNUMPI.EQ.15) LOBNAME = '$PI-P-IN-PH3'
      IF (NATNUMPI.EQ.15) LSTR    = 12
      IF (NATNUMPI.EQ.16) LOBNAME = '$PI-S-IN-CH2S'
      IF (NATNUMPI.EQ.16) LSTR    = 13
      IF (NATNUMPI.EQ.17) LOBNAME = '$PI-CL-IN-HCL'
      IF (NATNUMPI.EQ.17) LSTR    = 13
      IF (NATNUMPI.EQ.35) LOBNAME = '$PI-BR-IN-HBR'
      IF (NATNUMPI.EQ.35) LSTR    = 13
      IF (NATNUMPI.EQ.53) LOBNAME = '$PI-I-IN-HI'
      IF (NATNUMPI.EQ.53) LSTR    = 11
C
C     DOUBLE OCCUPIED PI ORBITAL
C
      IF (NATNUMPI.EQ.7.AND.NBONDS.EQ.3)  LOBNAME = '$PI-N-IN-PYRROLE'
      IF (NATNUMPI.EQ.7.AND.NBONDS.EQ.3)  LSTR    = 16
      IF (NATNUMPI.EQ.8.AND.NBONDS.EQ.2)  LOBNAME = '$PI-O-IN-FURAN'
      IF (NATNUMPI.EQ.8.AND.NBONDS.EQ.2)  LSTR    = 14
      IF (NATNUMPI.EQ.16.AND.NBONDS.EQ.2) LOBNAME = '$PI-S-IN-THIOPHENE'
      IF (NATNUMPI.EQ.16.AND.NBONDS.EQ.2) LSTR    = 18
C
C     SEARCH FOR THE FLAG
C
C     WRITE(IOUTVB,*)'SEARCH FOR', LOBNAME
      CALL LOCTOR(IOLVBO,LOBNAME,LSTR,IOK,0)
      IF(IOK.NE.1) THEN
C
C     SEARCH FOR THE NEAREST MATCH
C
        IF(NATNUMPI.GT.2.AND.NATNUMPI.LE.10) THEN
        LOBNAME = '$PI-C-IN-C2H4'
        LSTR    = 13
        ELSE IF(NATNUMPI.GT.10.AND.NATNUMPI.LE.18) THEN
        LOBNAME = '$PI-S-IN-CH2S'
        LSTR    = 13
        END IF
        CALL LOCTOR(IOLVBO,LOBNAME,LSTR,IOK,0)
        IF(IOK.NE.1) CALL ABORT0('LOOKPIVB03')
      END IF
      READ(IOLVBO,*)NAFRAG
C     WRITE(IOUTVB,*)'NAFRAG = ',NAFRAG
        DO I=1, NAFRAG
        READ(IOLVBO,*)NATFRAG(I),(FRGXYZ(J,I),J=1,3)
C       WRITE(IOUTVB,*)NATFRAG(I),(FRGXYZ(J,I),J=1,3)
        END DO
      READ(IOLVBO,*)
      READ(IOLVBO,*)
      READ(IOLVBO,*)
      READ(IOLVBO,*)NAOFRG
        DO I=1, NAOFRG
        READ(IOLVBO,1000)INDEXO, FRGAOLB(I),FRGORB(I)
C       WRITE(IOUTVB,1000)INDEXO, FRGAOLB(I),FRGORB(I)
        END DO
      READ(IOLVBO,*)
      READ(IOLVBO,*)(VBOLDIR(I),I=1,3)
C
 1000 FORMAT(I4,A12,F10.5)
      IF(IOLVBO.GT.1000000) WRITE(*,*)INDEXO,NATFRAG(1)
      RETURN
      END
      SUBROUTINE LOOKSIGMA(NATNUM,NBONDS,VBOLDIR,FRGORB,FRGAOLB,
     &                     NAOFRG,IOLVBO,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 FRGAOLB(*)
C     character*20 BASNAME
      CHARACTER*80 LOBNAME
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION FRGORB(*),FRGXYZ(3,100),VBOLDIR(3),NATFRAG(100)
      DIMENSION NATBAS(100),NATLEV(100),NATLIST(100)
C
C     SEARCH MAP FOR H, Li, Be, B, C, N, O, F, Na, Mg, Al, Si, P, S, Cl, Br, I
C
      LOBNAME = '@#$%'
      IF (NATNUM.EQ.1)  LOBNAME = '$SIGMA-H-'
      IF (NATNUM.EQ.3)  LOBNAME = '$SIGMA-LI'
      IF (NATNUM.EQ.4)  LOBNAME = '$SIGMA-BE'
      IF (NATNUM.EQ.5)  LOBNAME = '$SIGMA-B-'
      IF (NATNUM.EQ.7)  LOBNAME = '$SIGMA-N-'
      IF (NATNUM.EQ.8)  LOBNAME = '$SIGMA-O-'
      IF (NATNUM.EQ.9)  LOBNAME = '$SIGMA-F-'
      IF (NATNUM.EQ.11) LOBNAME = '$SIGMA-NA'
      IF (NATNUM.EQ.12) LOBNAME = '$SIGMA-MG'
      IF (NATNUM.EQ.13) LOBNAME = '$SIGMA-AL'
      IF (NATNUM.EQ.14) LOBNAME = '$SIGMA-SI'
      IF (NATNUM.EQ.15) LOBNAME = '$SIGMA-P-'
      IF (NATNUM.EQ.16) LOBNAME = '$SIGMA-S-'
      IF (NATNUM.EQ.17) LOBNAME = '$SIGMA-CL'
      IF (NATNUM.EQ.35) LOBNAME = '$SIGMA-BR'
      IF (NATNUM.EQ.53) LOBNAME = '$SIGMA-I-'
      IF (NATNUM.EQ.1)  LSTR    = 9
      IF (NATNUM.EQ.3)  LSTR    = 9
      IF (NATNUM.EQ.4)  LSTR    = 9
      IF (NATNUM.EQ.5)  LSTR    = 9
      IF (NATNUM.EQ.7)  LSTR    = 9
      IF (NATNUM.EQ.8)  LSTR    = 9
      IF (NATNUM.EQ.9)  LSTR    = 9
      IF (NATNUM.EQ.11) LSTR    = 9
      IF (NATNUM.EQ.12) LSTR    = 9
      IF (NATNUM.EQ.13) LSTR    = 9
      IF (NATNUM.EQ.14) LSTR    = 9
      IF (NATNUM.EQ.15) LSTR    = 9
      IF (NATNUM.EQ.16) LSTR    = 9
      IF (NATNUM.EQ.17) LSTR    = 9
      IF (NATNUM.EQ.35) LSTR    = 9
      IF (NATNUM.EQ.53) LSTR    = 9
      IF (NATNUM.EQ.6.AND.NBONDS.GE.4) THEN
      LOBNAME = '$SIGMA-C-SP3'
      LSTR    = 12
      END IF
      IF (NATNUM.EQ.6.AND.NBONDS.EQ.3) THEN
      LOBNAME = '$SIGMA-C-SP2'
      LSTR    = 12
      END IF
      IF (NATNUM.EQ.6.AND.NBONDS.LE.2) THEN
      LOBNAME = '$SIGMA-C-SP1'
      LSTR    = 12
      END IF
C
      IF(LOBNAME .EQ. '@#$%' ) THEN
      WRITE(IOUTVB,*)'UNKNOWN VBO TYPE, STOP!'
      CALL ABORT0('LOOKSIGMA0')
      END IF
C
C     SEARCH FOR THE FLAG
C
      CALL LOCTOR(IOLVBO,LOBNAME,LSTR,IOK,0)
      IF(IOK.NE.1) THEN
C
C     SEARCH FOR THE NEAREST MATCH
C
        IF(NATNUM.GT.2.AND.NATNUM.LE.10) THEN
        LOBNAME = '$SIGMA-C-'
        LSTR = 8
        ELSE IF(NATNUM.GT.10.AND.NATNUM.LE.18) THEN
        LOBNAME = '$SIGMA-S-'
        LSTR = 8
        END IF
        CALL LOCTOR(IOLVBO,LOBNAME,LSTR,IOK,0)
        IF(IOK.NE.1) THEN
        WRITE(IOUTVB,*)'ERR:LOOKSGM03'
        IERR = 1
        RETURN
        END IF
      END IF
      READ(IOLVBO,*)NAFRAG
C     WRITE(IOUTVB,*)'NAFRAG = ',NAFRAG
        DO I=1, NAFRAG
        READ(IOLVBO,*)NATFRAG(I),(FRGXYZ(J,I),J=1,3),NATLEV(I)
C       WRITE(IOUTVB,*)NATFRAG(I),(FRGXYZ(J,I),J=1,3),NATLEV(I)
        END DO
      READ(IOLVBO,*)
      READ(IOLVBO,*)NATORB
      READ(IOLVBO,*)(NATLIST(I),I=1,NATORB)
      READ(IOLVBO,*)(NATBAS(I),I=1,NATORB)
      NAOTOTAL = 0
      DO K=1, NATORB
        DO I=NAOTOTAL+1, NAOTOTAL+NATBAS(K)
        READ(IOLVBO,1000)INDEXO, FRGAOLB(I),FRGORB(I)
C       WRITE(IOUTVB,1000)INDEXO, FRGAOLB(I),FRGORB(I)
        END DO
      NAOTOTAL = NAOTOTAL + NATBAS(K)
      END DO
C
C     ONLY THE AOs ON THE FIRST ATOM IS USED HERE
C
      NAOFRG = NATBAS(1)
      READ(IOLVBO,*)
      READ(IOLVBO,*)(VBOLDIR(I),I=1,3)
C     WRITE(IOUTVB,*)'VBOLDIR= ',(VBOLDIR(I),I=1,3)
 1000 FORMAT(I4,A12,F10.5)
      IF(IOLVBO.GT.1000000) WRITE(*,*)INDEXO,NATFRAG(1),NATLEV(1)
      IF(IOLVBO.GT.1000000) WRITE(*,*)FRGXYZ(1,1),NATLIST(1)
      RETURN
      END
      SUBROUTINE LOOKPI(NATNUM,NBONDS,VBOLDIR,FRGORB,FRGAOLB,
     &                     NAOFRG,IOLVBO)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 FRGAOLB(*)
C     character*20 BASNAME
      CHARACTER*80 LOBNAME
      DIMENSION FRGORB(*),FRGXYZ(3,100),VBOLDIR(3),NATFRAG(100)
      DIMENSION NATBAS(100),NATLEV(100),NATLIST(100)
C     CHARACTER*3 FUNIT(10)
C     CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
C     COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
C     SEARCH MAP FOR H, Li, Be, B, C, N, O, F, Na, Mg, Al, Si, P, S, Cl, Br, I
C
      LOBNAME = '@#$%'
      IF (NATNUM.EQ.1)  LOBNAME = '$PI-H-IN-HH'
      IF (NATNUM.EQ.1)  LSTR    = 11
      IF (NATNUM.EQ.3)  LOBNAME = '$PI-LI-IN-LIH'
      IF (NATNUM.EQ.3)  LSTR    = 13
      IF (NATNUM.EQ.4)  LOBNAME = '$PI-BE-IN-H2BE'
      IF (NATNUM.EQ.4)  LSTR    = 14
      IF (NATNUM.EQ.5)  LOBNAME = '$PI-B-IN-BH3'
      IF (NATNUM.EQ.5)  LSTR    = 12
      IF (NATNUM.EQ.6)  LOBNAME = '$PI-C-IN-C2H4'
      IF (NATNUM.EQ.6)  LSTR    = 13
      IF (NATNUM.EQ.7)  LOBNAME = '$PI-N-IN-CH2NH'
      IF (NATNUM.EQ.7)  LSTR    = 14
      IF (NATNUM.EQ.8)  LOBNAME = '$PI-O-IN-CH2O'
      IF (NATNUM.EQ.8)  LSTR    = 13
      IF (NATNUM.EQ.9)  LOBNAME = '$PI-F-IN-HF'
      IF (NATNUM.EQ.9)  LSTR    = 11
      IF (NATNUM.EQ.11) LOBNAME = '$PI-NA-IN-NAH'
      IF (NATNUM.EQ.11) LSTR    = 13
      IF (NATNUM.EQ.12) LOBNAME = '$PI-MG-IN-MGH2'
      IF (NATNUM.EQ.12) LSTR    = 14
      IF (NATNUM.EQ.13) LOBNAME = '$PI-AL-IN-ALH3'
      IF (NATNUM.EQ.13) LSTR    = 14
      IF (NATNUM.EQ.14) LOBNAME = '$PI-SI-IN-SIH3'
      IF (NATNUM.EQ.14) LSTR    = 14
      IF (NATNUM.EQ.15) LOBNAME = '$PI-P-IN-PH3'
      IF (NATNUM.EQ.15) LSTR    = 12
      IF (NATNUM.EQ.16) LOBNAME = '$PI-S-IN-CH2S'
      IF (NATNUM.EQ.16) LSTR    = 13
      IF (NATNUM.EQ.17) LOBNAME = '$PI-CL-IN-HCL'
      IF (NATNUM.EQ.17) LSTR    = 13
      IF (NATNUM.EQ.35) LOBNAME = '$PI-BR-IN-HBR'
      IF (NATNUM.EQ.35) LSTR    = 13
      IF (NATNUM.EQ.53) LOBNAME = '$PI-I-IN-HI'
      IF (NATNUM.EQ.53) LSTR    = 11
C
C     DOUBLE OCCUPIED PI ORBITAL
C
      IF (NATNUM.EQ.7.AND.NBONDS.EQ.3)  LOBNAME = '$PI-N-IN-PYRROLE'
      IF (NATNUM.EQ.7.AND.NBONDS.EQ.3)  LSTR    = 16
      IF (NATNUM.EQ.8.AND.NBONDS.EQ.2)  LOBNAME = '$PI-O-IN-FURAN'
      IF (NATNUM.EQ.8.AND.NBONDS.EQ.2)  LSTR    = 14
      IF (NATNUM.EQ.16.AND.NBONDS.EQ.2) LOBNAME = '$PI-S-IN-THIOPHENE'
      IF (NATNUM.EQ.16.AND.NBONDS.EQ.2) LSTR    = 18
C
C     SEARCH FOR THE FLAG
C
C     WRITE(IOUTVB,*)'SEARCH FOR', LOBNAME
      CALL LOCTOR(IOLVBO,LOBNAME,LSTR,IOK,1)
      IF(IOK.NE.1) THEN
C
C     SEARCH FOR THE NEAREST MATCH
C
        IF(NATNUM.GT.2.AND.NATNUM.LE.10) THEN
        LOBNAME = '$PI-C-IN-C2H4'
        LSTR = 13
        ELSE IF(NATNUM.GT.10.AND.NATNUM.LE.18) THEN
        LOBNAME = '$PI-S-IN-CH2S'
        LSTR = 13
        END IF
        CALL LOCTOR(IOLVBO,LOBNAME,LSTR,IOK,1)
        IF(IOK.NE.1) CALL ABORT0('LOOKPI03  ')
      END IF
      IF(IOK.NE.1) CALL ABORT0('LOOKPI04  ')
      READ(IOLVBO,*)NAFRAG
C     WRITE(IOUTVB,*)'NAFRAG = ',NAFRAG
        DO I=1, NAFRAG
        READ(IOLVBO,*)NATFRAG(I),(FRGXYZ(J,I),J=1,3),NATLEV(I)
C       WRITE(IOUTVB,*)NATFRAG(I),(FRGXYZ(J,I),J=1,3),NATLEV(I)
        END DO
      READ(IOLVBO,*)
      READ(IOLVBO,*)NATORB
      READ(IOLVBO,*)(NATLIST(I),I=1,NATORB)
      READ(IOLVBO,*)(NATBAS(I),I=1,NATORB)
      NAOTOTAL = 0
      DO K=1, NATORB
        DO I=NAOTOTAL+1, NAOTOTAL+NATBAS(K)
        READ(IOLVBO,1000)INDEXO, FRGAOLB(I),FRGORB(I)
C       WRITE(IOUTVB,1000)INDEXO, FRGAOLB(I),FRGORB(I)
        END DO
      NAOTOTAL = NAOTOTAL + NATBAS(K)
      END DO
C
C     ONLY THE AOs ON THE FIRST ATOM IS USED HERE
C
      NAOFRG = NATBAS(1)
      READ(IOLVBO,*)
      READ(IOLVBO,*)(VBOLDIR(I),I=1,3)
C     WRITE(IOUTVB,*)'VBOLDIR= ',(VBOLDIR(I),I=1,3)
C
 1000 FORMAT(I4,A12,F10.5)
      IF(IOLVBO.GT.1000000) WRITE(*,*)INDEXO,NATFRAG(1),NATLEV(1)
      IF(IOLVBO.GT.1000000) WRITE(*,*)FRGXYZ(1,1),NATLIST(1)
      RETURN
      END
      SUBROUTINE LOOKLP(NATNUM,VBOLDIR,FRGORB,FRGAOLB,
     &                     NAOFRG,LPDEX,IOLVBO)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     character*20 BASNAME
      CHARACTER*12 FRGAOLB(*)
      CHARACTER*80 LOBNAME
      DIMENSION FRGORB(*),FRGXYZ(3,100),VBOLDIR(3),NATFRAG(100)
      DIMENSION NATBAS(100),NATLEV(100),NATLIST(100)
C     CHARACTER*3 FUNIT(10)
C     CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
C     COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
C     SEARCH MAP FOR N, O, F, P, S, Cl, Br, I
C
      LOBNAME = '@#$%'
      LSTR    = 4
      IF (NATNUM.EQ.7.AND.LPDEX.EQ.1)  LOBNAME = '$LP1-N-'
      IF (NATNUM.EQ.7)  LSTR    = 7
      IF (NATNUM.EQ.8.AND.LPDEX.EQ.1)  LOBNAME = '$LP1-O-'
      IF (NATNUM.EQ.8.AND.LPDEX.EQ.2)  LOBNAME = '$LP2-O-'
      IF (NATNUM.EQ.8)  LSTR    = 7
      IF (NATNUM.EQ.9.AND.LPDEX.EQ.1)  LOBNAME = '$LP1-F-'
      IF (NATNUM.EQ.9.AND.LPDEX.GT.1)  LOBNAME = '$LP2-F-'
      IF (NATNUM.EQ.9)  LSTR    = 7
      IF (NATNUM.EQ.15.AND.LPDEX.EQ.1) LOBNAME = '$LP1-P-'
      IF (NATNUM.EQ.15) LSTR    = 7
      IF (NATNUM.EQ.16.AND.LPDEX.EQ.1) LOBNAME = '$LP1-S-'
      IF (NATNUM.EQ.16.AND.LPDEX.GT.1) LOBNAME = '$LP2-S-'
      IF (NATNUM.EQ.16) LSTR    = 7
      IF (NATNUM.EQ.17.AND.LPDEX.EQ.1) LOBNAME = '$LP1-CL'
      IF (NATNUM.EQ.17.AND.LPDEX.GT.1) LOBNAME = '$LP2-CL'
      IF (NATNUM.EQ.17) LSTR    = 7
      IF (NATNUM.EQ.35.AND.LPDEX.EQ.1) LOBNAME = '$LP1-BR'
      IF (NATNUM.EQ.35.AND.LPDEX.GT.1) LOBNAME = '$LP2-BR'
      IF (NATNUM.EQ.35) LSTR    = 7
      IF (NATNUM.EQ.53.AND.LPDEX.EQ.1) LOBNAME = '$LP1-I-'
      IF (NATNUM.EQ.53.AND.LPDEX.GT.1) LOBNAME = '$LP2-I-'
      IF (NATNUM.EQ.53) LSTR    = 7
C
C     SEARCH FOR THE FLAG
C
C     WRITE(IOUTVB,*)'SEARCH FOR', LOBNAME, LSTR
      CALL LOCTOR(IOLVBO,LOBNAME,LSTR,IOK,1)
      IF(IOK.NE.1) THEN
C
C     SEARCH FOR THE NEAREST MATCH, USING LP OF N OR P AS A TEMPLATE
C
        IF(NATNUM.GT.2.AND.NATNUM.LE.10) THEN
        LOBNAME = '$LP1-N-'
        LSTR = 7
        ELSE IF(NATNUM.GT.10.AND.NATNUM.LE.18) THEN
        LOBNAME = '$LP1-P-'
        LSTR = 7
        END IF
        CALL LOCTOR(IOLVBO,LOBNAME,LSTR,IOK,1)
        IF(IOK.NE.1) CALL ABORT0('LOOKLP03  ')
      END IF
      IF(IOK.NE.1) CALL ABORT0('LOOKLP04  ')
      READ(IOLVBO,*)NAFRAG
C     WRITE(IOUTVB,*)'NAFRAG = ',NAFRAG
        DO I=1, NAFRAG
        READ(IOLVBO,*)NATFRAG(I),(FRGXYZ(J,I),J=1,3),NATLEV(I)
C       WRITE(IOUTVB,*)NATFRAG(I),(FRGXYZ(J,I),J=1,3),NATLEV(I)
        END DO
      READ(IOLVBO,*)
      READ(IOLVBO,*)NATORB
      READ(IOLVBO,*)(NATLIST(I),I=1,NATORB)
      READ(IOLVBO,*)(NATBAS(I),I=1,NATORB)
      NAOTOTAL = 0
      DO K=1, NATORB
        DO I=NAOTOTAL+1, NAOTOTAL+NATBAS(K)
        READ(IOLVBO,1000)INDEXO, FRGAOLB(I),FRGORB(I)
C       WRITE(IOUTVB,1000)INDEXO, FRGAOLB(I),FRGORB(I)
        END DO
      NAOTOTAL = NAOTOTAL + NATBAS(K)
      END DO
C
C     ONLY THE AOs ON THE FIRST ATOM IS USED HERE
C
      NAOFRG = NATBAS(1)
      READ(IOLVBO,*)
      READ(IOLVBO,*)(VBOLDIR(I),I=1,3)
C     WRITE(IOUTVB,*)'VBOLDIR= ',(VBOLDIR(I),I=1,3)
C
 1000 FORMAT(I4,A12,F10.5)
      IF(IOLVBO.GT.1000000) WRITE(*,*)INDEXO,NATFRAG(1),NATLEV(1)
      IF(IOLVBO.GT.1000000) WRITE(*,*)FRGXYZ(1,1),NATLIST(1)
      RETURN
      END
      SUBROUTINE LOCTOR(IUNIT,STRING,LEN,IOK,IWARN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 A
      CHARACTER*80 TEMP
      CHARACTER*1 STRING(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      TEMP='          '
      REWIND(IUNIT)
      IOK=0
      DO 100 I=1,LEN
 100  TEMP(I:I)=STRING(I)
 200  READ(IUNIT,'(A80)',END=500,ERR=500)A
      DO 210 I=1,80-LEN
      IF(A(I:I+LEN-1).EQ.TEMP(1:LEN)) GOTO 220
 210  CONTINUE
      GOTO 200
 220  CONTINUE
      IOK=1
      RETURN
 500  IF(IWARN.GT.0) WRITE(IOUTVB,1000) TEMP
 1000 FORMAT(/' End of file. String ',A10, ' was not found')
      IOK=0
      RETURN
      END
      SUBROUTINE LOCTOR2(IUNIT,STRING,LEN,IOK,IWARN,A)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 A
      CHARACTER*80 TEMP
      CHARACTER*1 STRING(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      TEMP='          '
      REWIND(IUNIT)
      IOK=0
      DO 100 I=1,LEN
 100  TEMP(I:I)=STRING(I)
 200  READ(IUNIT,'(A80)',END=500)A
      DO 210 I=1,80-LEN
      IF(A(I:I+LEN-1).EQ.TEMP(1:LEN)) GOTO 220
 210  CONTINUE
      GOTO 200
 220  CONTINUE
      IOK=1
      RETURN
 500  IF(IWARN.GT.0) WRITE(IOUTVB,1000) TEMP
 1000 FORMAT(/' End of file. String ',A10, ' was not found')
      IOK=0
      RETURN
      END
C==========================================================================
C
C     VBSCF:  SUBROUTINE FOR VBSCF CALCULATIONS OF MULTI-VB STRUCTURES
C
C             QUADRATIC CONVERGENCE METHOD BASED ON NEWTON-RAPHSON
C             SCHEME. A DYNAMICALLY ADJUSTED PARAMETER IS USED TO
C             STABLIZE THE ITERATION PROCEDURE
C
C     Note:   Scratch space requirement:
C             NLAST + Sractch of algebrants (a function of N, NS)
C             OR MLAST, which ever is the larger.
C             NB = (N+1)/2
C             NAGSIZE = 80*5**NB
C             (8,0)  (10,0)  (12,0)  (14,0)
C             2000   10000   50000   250000
C
C
C     History:
C             June 5, 2004
C             Re-organized scratch space allocation, better estimation
C             of scratch space. A simple formulation for the approximate
C             size of scratch space has been found. (See the note above)
C
C             April 12, 2006
C             Added LDIAG option for updating VB structure coefficients
C
C             April 30, 2010
C             Increased scratch space for MAPs (MM=62500000 for N=18).
C
C             April 29, 2012
C             Reduced scratch space for MAPs to MM=2500000 for N=14 for
C             stand-alone VB2000 release, and to MM=50000 for N=12 for
C             GAMESS/VB2000 release, matching MAP files that are in that
C             release.
C
C     Author:
C
C             Jiabo Li
C
C===========================================================================
      SUBROUTINE VBSCF(MELX,MSPX,NBASIS,MORBX,MWINX,W,WBASIS,DMP,
     &              DMLOC,DM2LOC,MW,MGRP,FLAG,MITER,LASTITER)
C    &              DMLOC,DM2LOC,MW,ETOTAL,MGRP,FLAG,MITER,LASTITER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (NPA=4000,MAXNOB=200,MAXBFN=726,MAXRBF=MAXNOB*MAXBFN)
      CHARACTER*50 FLAG
      CHARACTER*80 VBPATH
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     LOGICAL   DECREASE,MAPEXISTS
      LOGICAL   DECREASE
C     DIMENSION CONSTR(1000),ICONST(1000),NBRIX(1000),MASKBRI(10000)
      DIMENSION CONSTR(1000),ICONST(1000),MASKBRI(10000)
C     DIMENSION NBOPT(100),DM2LOC(*),BASIS0(33334)
      DIMENSION DM2LOC(*),BASIS0(33334)
      DIMENSION CNORM(5000),DEV(NPA),DMP(*),WBASIS(*),DMLOC(*)
      DIMENSION INDX(2,NPA),DEV1(NPA),VECT(NPA)
C     DIMENSION INDX(2,NPA),DEV1(NPA),SV(NPA),VECT(NPA),VECT1(NPA)
      PARAMETER (MAXBLL=12500)
      PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA,MAXGRP=99)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(MAXGRP),MSPIN(MAXGRP),MNORBIT(MAXGRP),
     &MLORBIT(MAXGRP),MWIN(MAXGRP),MSTR(MAXGRP),METHOD(MAXGRP),
     &IBASIS(MAXEXT),NOCC(MAXEXT),NOBIAS,NEPS,NVIR,NOTROT(5000),
     &LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(MAXGRP)
      COMMON /VBSTR/CSTR(10000),NPHI(100000),NSTR
      COMMON /VBCTL/EPS,MAXIT,NOPT,IHESS,NEWTON,NOB(MAXNOB),NVBI(5000)
C     COMMON /IAA/IA(100000)
C     COMMON /IBB/IB(100000),MWINZ,MBORZ
C     COMMON /ICC/IC(100000)
C
C     NOTE THAT MM IS SET IN 4 SUBROUTINES AND IT MUST BE SET
C     TO THE SAME VALUE.
C
CGMS  PARAMETER (MM=500000)
C     SUFFICIENT FOR MAP FILES IN GAMESS RELEASE.
C     IF YOU USE LARGER MAP FILES FROM THE VB2000 RELEASE,
C     YOU MUST INCREASE MM.
C
C000  PARAMETER (MM=2500000)
CSMI  PARAMETER (MM=2500000)
CGAU  PARAMETER (MM=2500000)
C     SUITABLE FOR 14 ELECTRONS WITH A SINGLET MOLECULE.
C
C     IF YOU ARE GOING TO USE MORE THAN 14 ELECTRON MAP FILES,
C     YOU MUST INCREASE MM. IF THE MULTIPCITY IS GREATER THAN 1,
C     MAY ALSO NEED TO INCREASE MM. 
C     A WARNING WILL BE GIVEN IF MM IS NOT LARGE ENOUGH.
C
C     FOR UP TO 12 ELECTRONS IN SINGLET USE - PARAMETER (MM=500000)
C     FOR UP TO 14 ELECTRONS IN SINGLET USE - PARAMETER (MM=2500000)
C     FOR UP TO 16 ELECTRONS IN SINGLET USE - PARAMETER (MM=12500000)
C     FOR UP TO 18 ELECTRONS IN SINGLET USE - PARAMETER (MM=62500000)
C
      DIMENSION NASTR(10000),INDXW(10)
      COMMON /LTAB/NTYPE,MAPINCORE,MEL,MSP,LOOKTB(6,100),NGRECD(4,100)
C     COMMON /MAP/MAP(3,MM),NALG(100),NRE(100),NAG1(100),NREC1(100),MVBM
      COMMON /MAP/MAP(3,MM),NALG(100),NRE(100),NAG1(100),MVBM
C     COMMON /NBRTAB/NBTAB(33336),NOTAB(33336),INDXZ(2,1000)
      COMMON /NBRTAB/NBTAB(MAXBLL),NOTAB(MAXBLL)
      DIMENSION W(*),CSTRX(1000),XFACTOR(1000)
      DIMENSION SDM(MAXRBF),ORBLOC(MAXRBF)
      CHARACTER*80 MAPNNS,MAPFILE
      CMAXCUT = 0.025D0
      CMAXX   = 0.0D0
      CMAX    = 0.0D0
C
C     RETURN IMMEDIATELY IF CI_ONLY IS TRUE
C
      IF(LCIONLY.EQ.1) RETURN
C     TIME1=XCLOCK()
C     IFLAG=0
      MVBM=0
      NORB=MWINX
      NOCORB=MORBX
      DO I=1, NSTR
      CSTRX(I) = 1.0D0
      END DO
C
C     GET IOUNITS BY NAMES
C
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL GETIOUNIT('IAO2E   ',IAO2E)
      CALL GETIOUNIT('IOMAP   ',IOMAP)
      CALL GETIOUNIT('IOHES   ',IOHES)
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL GETIOUNIT('IVBO2E  ',IVBO2E)
      CALL GETVBPATH(VBPATH)
      CALL GETCTLVAL("DIIS      ",CTLVAL,IDIIS)
      CALL LOCTOR(IOENGI,'$CMAXCUT',8,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)CMAXCUT
C
C    SCANE OCCUPIED ORBITALS
C
      NOCCORB=0
      DO I=1,MELX*NSTR
      IF(NPHI(I).GT.NOCCORB) NOCCORB=NPHI(I)
      END DO
      NOCORB=NOCCORB
      NS=MSPX
      N=MELX
      DO K=1,NSTR*N
      NASTR(K)=NPHI(K)
      END DO
      MAPNNS='MAP/MAP'
      WRITE(MAPNNS(8:9),'(I2.2)') N
      WRITE(MAPNNS(10:11),'(I2.2)') NS
      K=11
CTMAP MAPNNS(12:12)='t'
CTMAP K=12
C     Add VBPATH
      CALL PATHST(MAPFILE,VBPATH,'/               ',MAPNNS,K)
C     WRITE(IOUTVB,102) MAPNNS
C102  FORMAT(/,' MAP FILE IS: ',A80)
C
C     LOADMAP
C
      IF(MEL.NE.N.OR.MSP.NE.NS) THEN
CBMAP OPEN(IOMAP,FILE=MAPFILE,STATUS='OLD',FORM='UNFORMATTED',
CBMAP&     ERR=2112)
CTMAP OPEN(IOMAP,FILE=MAPFILE,STATUS='OLD',FORM='FORMATTED',
CTMAP&     ERR=2112)
      GOTO 2111
2112  CONTINUE
      VBPATH = 'C:/VB2000NET/VB2000'
      CALL PATHST(MAPFILE,VBPATH,'/               ',MAPNNS,K)
CBMAP OPEN(IOMAP,FILE=MAPFILE,STATUS='OLD',FORM='UNFORMATTED',
CBMAP&     ERR=2113)
CTMAP OPEN(IOMAP,FILE=MAPFILE,STATUS='OLD',FORM='FORMATTED',
CTMAP&     ERR=2113)
      GOTO 2111
2113  CONTINUE
      WRITE(IOUTVB,*)"NO MAP FILE IS FOUND. THERE ARE TWO POSSIBILITIES"
      WRITE(IOUTVB,*)"1) THE JOB IS NOT RUNNING IN VB2000 DIRECTORY AND"
      WRITE(IOUTVB,*)"   VB2000PATH VARIABLE IS NOT SET "
      WRITE(IOUTVB,*)"2) THE MAP FILE IS NOT AVAILABLE FOR THIS RELEASE"
      WRITE(IOUTVB,*)"   PLEASE CONTACT US AT VB@SCINETEC.COM FOR HELP!"
      CALL ABRTVB
2111  CONTINUE
C     MSIZE = MM
      CALL LOADMAP(IOMAP,N,NS,NTYPE,MAPINCORE,MVBM,
     &             LOOKTB,NGRECD,MAP,MM)
      MSP=NS
      MEL=N
C     WRITE(IOUTVB,*)'LAPLACE EXPANSION MAP LOADED'
      END IF
      CALL BRITAB(NOCORB,NORB,INDX,NBRIL,NBTAB,NOTAB,MASKBRI,MITER)
      NORB2   = NORB*(NORB+1)/2
      INDXW(1)=NORB2
      INDXW(2)=NORB2
      INDXW(3)=NORB2
      CALL SETINXN(3,INDXW,NORB3)
C     WRITE(IOUTVB,*) "NORB3=",NORB3
C
C     COMPUTE ADDRESSES FOR VBHESS
C
      NWDM    = NORB2*(2+2*NSTR)+NORB2*(NORB2+1)*(2+NSTR)/2+NORB3
      NADDHESS= 1
      NADDS   = NADDHESS + (NBRIL+NSTR)*(NBRIL+NSTR+1)/2
      NADDH   = NADDS + NORB2
      NADDG   = NADDH + NORB2
      NADDVBS = NADDG + NORB2*(NORB2+1)/2
      NADDVBH = NADDVBS + NSTR*(NSTR+1)/2
      NADDM   = NADDVBH + NSTR*(NSTR+1)/2
      NADDSS  = NADDM + NWDM
      NADDAG  = NADDSS + N*NORB
      NREM1   = MW - NADDAG
C     WRITE(IOUTVB,*) "NWDM,NBRIL,NSTR,NORB2,NORB,NORB3,MW,NADDAG"
C     WRITE(IOUTVB,*) NWDM,NBRIL,NSTR,NORB2,NORB,NORB3,MW,NADDAG
C     NLAST   = NADDAG
      MMX1    = NADDG + NORB2*(NORB2+1)/2
      MMX2    = MMX1 + NORB*NORB
      MMX3    = MMX2 + NORB*NORB2
C     WRITE(IOUTVB,*)'MXMISC =',NLAST
C
C     THE REMANING (NREM1) IS FOR THE SCATCH SPACE OF ALGEBRANTS IN VBHESS
C     THE MINIMAL SIZE IS A FUNCTION OF (N, NS AND IDERANK)
C     TODO: BUILD SUCH A TABLE.
C
      IF(NREM1.LT.0) CALL ABORT0('VBSCF01   ')
C     TIME1=XCLOCK()-TIME1
C1111 CONTINUE
C
C     SET CONVERGENCE FLAG TO NEGATIVE
C
      ICONV=0
      IF(NOPT.LE.0) RETURN
      IF(NSTR.GT.199) THEN
        WRITE(IOUTVB,*)"NO MORE THAN 199 VB STRUCTURES CAN BE OPTIMIZED"
        CALL ABORT0('VBSCF02   ')
      END IF
C
C     CALCUULATE THE INDEXES
C
      CALL SETIND(MWINX,MORBX)
C
C     INDEXES
C
      NPAR   = NBRIL + NSTR
      MSQ    = MWINX*(MWINX+1)/2
C     MTSQ   = NBASIS*(NBASIS+1)/2
      MGSQ   = MSQ*(MSQ+1)/2
C     NMTSQ  = NBASIS*MTSQ
C
C     ADDRESS
C
C     THE ORDER OF MSS,MHH,MGG IS CRITICAL. IN HESSAN, HG STORE BOTH H AND G
C
      MTX    = NBASIS
      IF(NORB .GT. NBASIS) MTX = NORB
      MTXSQ  = MTX*(MTX+1)/2
      MSS    = 1
      MHH    = MSS+MTXSQ
      MGG    = MHH+MTXSQ
      MMT1   = MGG
      MMT2   = MMT1+MTX*MTX
      MMT3   = MMT2+MTX*MTXSQ
      MLAST  = MMT3+MTXSQ
      NREM2  = MW - MLAST
      IF(NREM2.LT.0) CALL ABORT0('VBSCF03   ')
C
C     MNSQ=MWINX*(MWINX+1)/2
C
C     READ CONSTRAINS FOR OPTIMIZATION (GENERAL, ORBITALS OR CSTR)
C     DETERMINE NONLINEARLY DEPENDENT PARAMETERS
C
      CALL RCONST(CONSTR,ICONST,NBRIL,NPAR,NLORBI,NLCSTR,FLAG)
      NONLIN=NLORBI+NLCSTR
C
      IFIX =1
      IF(NEWTON.GE.2) IFIX =0
      RGQT =0.1D0
      BGQT =0.9D0
      EPT  =0.0D0
      RDAMP=0.1D0
      TK   =0.1D0
      ERCTL=0.15D0
      ENG1 =0.0D0
      ENG2 =0.0D0
      DECREASE = .FALSE.
      CMAXOLD = 1000.0D0
      CALL LOCTOR(IOENGI,'$ERCTL',6,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)ERCTL
      ITER =0
      IF( LPTALL.EQ.1) THEN
CGMS     CALL FLSHBF(IOUTVB)
         WRITE(IOUTVB,101) MGRP
      ENDIF
 101  FORMAT(/' VB-ORBITAL OPTIMIZATION OF GROUP',I3,' ...')
      LDIAG = 0
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$LDIAGVB',8,IOK,0)
      IF(IOK.EQ.1) LDIAG = 1
C
C     VBOPT ITERATION STARTS HERE
C
C     WRITE(IOUTVB,'(" NBASIS AT VBSCF00001",I8)') NBASIS
C     WRITE(IOUTVB,'(10I8)') (MLORBIT(I),I=1,99)
      IF(MLORBIT(MGRP)*NBASIS.GT.MAXRBF) CALL ABORT0('VBSCF00001')
      NDIISS = 5
      CALL LOCTOR(IOENGI,'$DIISSTART',10,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)NDIISS
      NDIISMAX = 10
      IF(IDIIS.NE.1) NDIISS = 1000
 100  CONTINUE
      TK   =TK/2.0D0
      ITER =ITER+1
      CALL GETIOUNIT('IOTEMPA ',IOTEMPA)
      CALL GETIOUNIT('IOTEMPB ',IOTEMPB)
      IF(ITER.LE.1) THEN
      LBUFF   = 4095
C     NSQ     = NORB*(NORB+1)/2
C     NSQ2    = NSQ*(NSQ+1)/2
C     NB2     = NBASIS*NBASIS
      CALL READ1E(IAO1E,W(MSS),W(MHH),NBASIS)
      CALL VBONORM(NBASIS,MLORBIT(MGRP),WBASIS,W(MSS),CNORM)
C
C     APPLY SYMMETRY CORRECTION ......?
C     FIRST ITERATION GOES HERE
C
      CALL RNCSTR(NSTR,CSTR,XFACTOR,CNORM,MELX,NPHI)
C
C     TODO: MODIFY THIS
C
      NSIZE = MW - MGG
      CALL READ1E(IAO1E,W(MSS),W(MHH),NBASIS)
C
C     COPY DENSITY OF CORE TO WORKING FILED G(MMT3)
C
      DO I=1,NBASIS*(NBASIS+1)/2
      W(MMT3-1+I)=DMP(I)
      END DO
      IHFPO = 1
C     TIME=XCLOCK()
      REWIND(IVBO2E)
      CALL TRAN1E(NBASIS,NORB,W(MSS),W(MHH),
     &     WBASIS,W(MMT1),W(MMT2),W(MMT3),IHFPO,IVBO2E)
      CALL TRANP2E(NBASIS,NORB,0,WBASIS,W(MGG),NSIZE,LBUFF,
     &             IOTEMPA,IOTEMPB)
C
C     SAVE A COPY OF H,S,G OF THE FIRST ITERATION
C
      CALL SHREAD(W(NADDS),W(NADDH),MSQ,IVBO2E)
      CALL GREAD(W(NADDG),MGSQ,LBUFF,IVBO2E)
      CALL DSTORE(0,1,MSQ,2, INTDAT, W(NADDS))
      CALL DSTORE(0,1,MSQ,3, INTDAT, W(NADDH))
      CALL DSTORE(0,1,MGSQ,4,INTDAT, W(NADDG))
C     CALL DSTORE(0,1,NBASIS*NORB,5,INTDAT, WBASIS)
        IF(NBASIS*NORB.GT.MAXRBF) CALL ABORT0("BASIS10000")
        DO I=1, NORB*NORB
        ORBLOC(I)=0.0D0
        END DO
        DO I=1, NORB
        II = (I-1)*NORB+I
        ORBLOC(II) = 1.0D0
        END DO
        DO I=1, NBASIS*NORB
        BASIS0(I) = WBASIS(I)
        END DO
      ELSE
        CALL DSTORE(0,0,MSQ,2, INTDAT, W(NADDS))
        CALL DSTORE(0,0,MSQ,3, INTDAT, W(NADDH))
        CALL DSTORE(0,0,MGSQ,4,INTDAT, W(NADDG))
      TIME=XCLOCK()
      I = NINT(TIME)
      REWIND(IVBO2E)
      IHFPO = 0
      CALL TRAN1E(NORB,NORB,W(NADDS),W(NADDH),ORBLOC,W(MMX1),W(MMX2),
     &            DUMMY,IHFPO,IVBO2E)
      CALL TRANN2E(NORB,NORB,0,W(NADDG),ORBLOC,W(MMX1),W(MMX2),W(MMX3),
     &             LBUFF,IVBO2E)
      END IF
C     TIME1=XCLOCK()
C     TIME=TIME1-TIME
C     WRITE(IOUTVB,'(' 2E-TRAN TIME FOR VBSCF=',F8.3)')TIME
      CALL SHREAD(W(NADDS),W(NADDH),MSQ,IVBO2E)
      CALL GREAD(W(NADDG),MGSQ,LBUFF,IVBO2E)
      IF(ITER.EQ.1) CALL VBDIISINIT(NDIISMAX,NDIISS,W(NADDS),MSQ)
C
C     DERIVATIVES AND HESSIAN
C     IF(IDERANK.EQ.2), THEN HESSAIN WILL BE RE-COMPUTED
C     OTHERWISE, THE HESSIAN FROM PREVIOUS ITERATION WILL BE USED
C
C
      IDERANK=2
      IF(ICONV.EQ.1) IDERANK=1
      IF(ITER.GT.1.AND.CMAX.LT.CMAXCUT.AND.DECREASE) IDERANK=1
      IF(ITER.GT.1.AND.CMAX.LT.CMAXCUT.AND.IDIIS.EQ.1) IDERANK=1
C     TIME1=XCLOCK()
      CALL VBHESS(N,NS,NSTR,NASTR,CSTR,NORB,NBRIL,
     & NBTAB,NOTAB,W(NADDS),W(NADDH),W(NADDG),W(NADDVBS),W(NADDVBH),
     & DMLOC,DM2LOC,W(NADDM),W(NADDHESS),W(NADDSS),W(NADDAG),DEV1,
     & IDERANK,ENG2,NREM1)
C     CALL VBHESS(N,NS,NSTR,NASTR,CSTR,NORB,NOCORB,NBRIL,
C    & NBTAB,NOTAB,W(NADDS),W(NADDH),W(NADDG),W(NADDVBS),W(NADDVBH),
C    & DMLOC,DM2LOC,W(NADDM),W(NADDHESS),W(NADDSS),W(NADDAG),DEV1,
C    & IDERANK,ENG2,NREM1,FLAG)
C
C     OPTIONALLY ADD DELOCALIZATION PENALTY
C
      LPENADD1 = NADDAG
      LPENADD2 = LPENADD1 + NBASIS*NBASIS
      CALL READ1E(IAO1E,W(LPENADD1),W(LPENADD2),NBASIS)
      CALL DPENALTY1(WBASIS,NORB,W(LPENADD1),NBRIL,INDX,MGRP,
     &     W(LPENADD2),DEV1,W(NADDHESS),LASTITER,ICONV,MITER,
     &     TDELOCAL,ITER)
C
C     ADD DELOCALIZATION PENALTY
C
      ENG2 = ENG2 + TDELOCAL
      IF(LDIAG.EQ.1) CALL RVB(NSTR,CSTRX,W(NADDVBS),W(NADDVBH),
     &                        W(NADDAG),NREM1,F2,FLAG,0,MGRP)
C
C
C     Fix zero eigenvalue problem due to linear dependency of CSTR
C
      CALL ZHESS(W(NADDHESS),NSTR,CSTR,NBRIL,DEV1)
C
C     APPLY BRILLOUIN MASK (CONSTRAINED ORBITAL OPTIMIZATION)
C
      CALL BRIMASK(W(NADDHESS),NSTR,NBRIL,DEV1,MASKBRI)
C     TIME1=XCLOCK()-TIME1
C     WRITE(IOUTVB,*)'TIME FOR VBHESS=',TIME1
C     WRITE(IOUTVB,*)'ENG2-ENG1=',ENG2-ENG1
      IF(ENG2-ENG1.LT.0.0D0) DECREASE=.TRUE.
C
C     HESSIAN OF PREVIOUS ITERATION CAN BE OPTIONALLY LOADED FROM
C     FILE IOHES
C
      CALL CONDEN(W(NADDHESS),W(NADDAG),DEV1,DEV,NPAR,NONLIN,IDERANK,
     & IOHES,CONSTR,ICONST)
C
      IF(NEWTON.GE.1) THEN
C
C     Fix negative eigenvalue problem before going to NR
C     Jacobi is very poor for Diag. of Large matrix
C
C     WRITE(IOUTVB,*)"DEV FROM VBHESS"
C     DO I=1, NONLIN
C       WRITE(IOUTVB,'(I5,F15.10)')I, DEV(I)
C     ENDDO
      IF(IDERANK.GE.2)
     &  CALL DIAGHER(W(NADDHESS),NONLIN,DEV,SEIG,W(NADDAG),IFIX,.FALSE.)
      IF(IFIX.EQ.1) THEN
      CALL NRDATE(NONLIN,DEV,W(NADDHESS),VECT,CMAX,ERCTL,W(NADDAG),
     &            RDAMP,SEIG,EPT,ENG1,ENG2)
      ELSE
      CALL NRGQT3(NONLIN,DEV,W(NADDHESS),VECT,CMAX,ERCTL,W(NADDAG),
     &            RGQT,BGQT,SEIG,EPT,ENG1,ENG2)
      END IF
C
C     EXPAND PARAMETERS
C
      DAMPVEC = 1.0D0
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$DAMPVEC',8,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)DAMPVEC
      DO I=1, NPAR
         VECT(I) = VECT(I)*DAMPVEC
      END DO
      CALL EXPAND(VECT,CONSTR,ICONST,NPAR)
C
C     APPLY BRI MASK
C
      DO K=1, NBRIL
      IF(MASKBRI(K).EQ.0) VECT(K) = 0.0D0
      END DO
C
C     UPDATE STRUCTURE COEFFICIENTS
        IF(LDIAG.EQ.1) THEN
          CRATE = CSTR(1)/CSTRX(1)
          DO ISTR=1,NSTR
          CSTR(ISTR)=CRATE*CSTRX(ISTR)
          END DO
        ELSE
          DO ISTR=1,NSTR
          CSTR(ISTR)=CSTR(ISTR)+VECT(NBRIL+ISTR)
          END DO
        END IF
C
C     POSSIBLE STRUCTURE COEFFICIENT SYMMETRY
C
          CALL STRSYM(CSTR,NSTR,FLAG)
      ELSE
      WRITE(IOUTVB,*)
     & 'SORRY, CONJUGATE-GRADIENT METHOD HAS BEEN TAKEN AWAY'
      CALL ABRTVB
      END IF
      IF(ICONV.NE.1) THEN
      CMAXX=1.0D0
C     CALL VBDIIS(NOCORB,NORB,NBASIS,NBRIL,INDX,W,BASIS0,WBASIS,
C    &            ORBLOC,VECT,CMAX,CNORM)
C
C     USE DEV1 AS THE MINIMIZATION TARGET FOR DIIS
C     ALSO GET WBASIS UPDATED
C
      CALL VBDIIS(NOCORB,NORB,NBASIS,NBRIL,INDX,W,BASIS0,WBASIS,
     &            ORBLOC,DEV1,VECT,CMAX,CNORM)
C
C     POSSIBLE SYMMETRY CORRECTION
C
C     MAXL = 4
      CALL SYMVBO(MGRP,MORBX,WBASIS,W,ISYMOPER,CNORM)
      IF(ISYMOPER.EQ.1) THEN
C
C     UPDATE ORBLOC: COEFFICIENTS OF WBASIS IN BASIS0
C
      IF(NORB.NE.MORBX) CALL ABORT0("LSFIT00001")
      CALL LSFIT(NBASIS,NORB,BASIS0,WBASIS,ORBLOC,W)
      ENDIF
C
      CMAXX = CMAX
      CALL RNCSTR(NSTR,CSTR,XFACTOR,CNORM,MELX,NPHI)
      IF(LPTALL.EQ.1) WRITE(IOUTVB,103) MGRP,ITER,CMAX
 103  FORMAT(' GROUP =',I3,'  ITER =',I3,' CMAX = ',F17.14)
      END IF
C     ETOT = ETOTAL + ENG2
C     TIME=XCLOCK()
C     TIME=TIME-TIME1
      IF(CMAX.GT.CMAXOLD) DECREASE=.FALSE.
      CMAXOLD=CMAX
      IF(CMAXX.GT.EPS.AND.ICONV.EQ.1) THEN
      WRITE(IOUTVB,1100)CMAXX,ITER
      END IF
      IF(CMAX.GT.EPS.AND.ITER.LT.MAXIT.AND.ICONV.NE.1) GOTO 100
C
C     DO ONE MORE ITERATION TO OBTAIN DENSITY MATRIX WITHOUT
C     UPDATING VB ORBITALS.
C
      IF(ICONV.EQ.0) THEN
      ICONV=1
      GOTO 100
      END IF
 1100 FORMAT(" VBSCF NOT CONVERGED. CMAX = ",F17.14, " AFTER ",
     &        I3," ITERATIONS")
C
C     PRINT OVERLAP MATRIX
C
      IF(LASTITER.EQ.1) THEN
      CALL SHREAD(W(NADDS),W(NADDH),MSQ,IVBO2E)
      CALL MPRINT2(NORB,W(NADDS),1,MGRP)
      END IF
C
C     NORMALIZATION AND COPY THE LOCAL DENSITY MATRIX TO DMLOC
C
      SSS=0.0D0
      DO I=1,NORB2
      DMLOC(I)=W(NADDM-1+I)
      SSS=SSS+W(NADDS+I-1)*DMLOC(I)*2.0D0
      END DO
      DO I=1,NORB
      SSS=SSS-W(NADDS+IJ00(I,I)-1)*DMLOC(IJ00(I,I))
      END DO
      CN=MELX/SSS
      DO I=1,NORB2
      DMLOC(I)=DMLOC(I)*CN
      END DO
      DO I=1,NORB2*(NORB2+1)/2
      DM2LOC(I)=DM2LOC(I)*CN
      END DO
C1000 FORMAT(2X,'TOO MANY STRUCTURES FOR VBSCF,STOP.')
      SUM = 0.0D0
      IJ  = 0
      DO I=1, NSTR
      DO J=1, I
      IJ = IJ+1
      SUM = SUM +2.0D0*CSTR(I)*CSTR(J)*W(NADDVBS-1+IJ)
      END DO
      SUM = SUM - CSTR(I)*CSTR(I)*W(NADDVBS-1+IJ)
      END DO
      CNN = 1.0D0/DSQRT(SUM)
      DO I=1, NSTR
      CSTR(I) = CSTR(I)*CNN
      END DO
      ISPDEN = 0
      CALL GETCTLVAL("SPINDEN   ",CTLVAL,ISPDEN)
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$SPDEN',6,IOK,0)
      IF(IOK.EQ.1) ISPDEN = 1
C
C     CALCULATION SPIN DENSITY MATRIX
C
      IF(LASTITER.EQ.1.AND.NS.GT.0.AND.ISPDEN.EQ.1) THEN
         CALL SPDEN(N,NS,NSTR,W(NADDS),NORB,NPHI,CSTR,SDM)
      END IF
      CALL LOCTOR(IOENGI,'$PRINTHS',8,IOK,0)
      IF (LASTITER.EQ.1.AND.IOK.EQ.1) THEN
        CALL MPRINT3(NSTR,W(NADDVBS),W(NADDVBH),MGRP)
      END IF
C
C     COMPUTE STRUCTURE WEIGHTS
C
      DO I=1, NSTR*(NSTR+1)/2
       W(I) = W(NADDVBS-1+I)
      END DO
      MWRK  = MW - NSTR*(NSTR+1)/2
      NADDW = NSTR*(NSTR+1)/2 + 1
      IF (LASTITER.EQ.1.AND.NSTR.GT.1) THEN
        CALL STRWEIT(NSTR,CSTR,W(1),W(NADDW),MWRK)
      END IF
      IF(LASTITER.EQ.1.AND.NS.GT.0.AND.ISPDEN.EQ.1) THEN
C
C     DENSITY CONVERSION
C
        IJ = 0
        DO I=1, NORB
          DO J=1, I
          IJ = IJ + 1
          SDM(IJ) = SDM(IJ)
          END DO
        END DO
        MADDSD=1
        MADDW = MADDSD+NBASIS*(NBASIS+1)/2
C       NB2   = NBASIS*(NBASIS+1)/2
C       NSQ   = NORB*(NORB+1)/2
        CALL MATRAN1(NORB,NBASIS,WBASIS,W(MADDW),SDM,W(MADDSD))
        CALL SPDATM(W(MADDSD),W(MADDW))
      END IF
C     WRITE(IOUTVB,'("ETOTAL FROM VBSCF = ",F20.15)')ETOT
      RETURN
      END
C==========================================================================
C
C     LHFSCF: SUBROUTINE FOR LHFSCF CALCULATIONS
C
C             QUADRATIC CONVERGENCE METHOD BASED ON NEWTON-RAPHSON
C             SCHEME. A DYNAMICALLY ADJUSTED PARAMETER IS USED TO
C             STABLIZE THE ITERATION PROCEDURE
C
C     Note:   The automatic set-up of localization specification is
C             only work good for one group of the whole molecule system
C
C     History:
C             First version: May, 2009
C
C     Author:
C             Jiabo Li
C
C===========================================================================
      SUBROUTINE LHFSCF(MELX,NBASIS,MORBX,MWINX,W,WBASIS,DMP,
     &              DMLOC,DM2LOC,MW,MGRP,FLAG,MITER,LASTITER)
C    &              DMLOC,DM2LOC,MW,ETOTAL,MGRP,FLAG,MITER,LASTITER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (NPA=4000, MAXNOB=200, MAXPAR=10000)
      PARAMETER (MAXBFN=726, MAXRBF=MAXNOB*MAXBFN)
      CHARACTER*50 FLAG
      CHARACTER*80 VBPATH
C     CHARACTER*8  BONDLAB
      LOGICAL   DECREASE
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION CONSTR(MAXPAR),ICONST(MAXPAR),MASKBRI(MAXPAR)
C     DIMENSION NBOPT(100),DM2LOC(*),BASIS0(33334)
      DIMENSION DM2LOC(*),BASIS0(33334)
      DIMENSION CNORM(5000),DEV(NPA),DMP(*),WBASIS(*),DMLOC(*)
C     DIMENSION INDX(2,NPA),DEV1(NPA),SV(NPA),VECT(NPA),VECT1(NPA)
      DIMENSION INDX(2,NPA),DEV1(NPA),VECT(NPA)
      PARAMETER (MAXBLL=12500)
      PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA,MAXGRP=99)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(MAXGRP),MSPIN(MAXGRP),MNORBIT(MAXGRP),
     &MLORBIT(MAXGRP),MWIN(MAXGRP),MSTR(MAXGRP),METHOD(MAXGRP),
     &IBASIS(MAXEXT),NOCC(MAXEXT),NOBIAS,NEPS,NVIR,NOTROT(5000),
     &LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(MAXGRP)
      COMMON /VBSTR/CSTR(10000),NPHI(100000),NSTR
      COMMON /VBCTL/EPS,MAXIT,NOPT,IHESS,NEWTON,NOB(MAXNOB),NVBI(5000)
C     COMMON /IAA/IA(100000)
C     COMMON /IBB/IB(100000),MWINZ,MBORZ
C     COMMON /ICC/IC(100000)
C
C     NOTE THAT MM IS SET IN 4 SUBROUTINES AND IT MUST BE SET
C     TO THE SAME VALUE.
C
CGMS  PARAMETER (MM=500000)
C     SUFFICIENT FOR MAP FILES IN GAMESS RELEASE.
C     IF YOU USE LARGER MAP FILES FROM THE VB2000 RELEASE,
C     YOU MUST INCREASE MM.
C
C000  PARAMETER (MM=2500000)
CSMI  PARAMETER (MM=2500000)
CGAU  PARAMETER (MM=2500000)
C     SUITABLE FOR 14 ELECTRONS WITH A SINGLET MOLECULE.
C
C     IF YOU ARE GOING TO USE MORE THAN 14 ELECTRON MAP FILES,
C     YOU MUST INCREASE MM. IF THE MULTIPCITY IS GREATER THAN 1,
C     MAY ALSO NEED TO INCREASE MM. 
C     A WARNING WILL BE GIVEN IF MM IS NOT LARGE ENOUGH.
C
C     FOR UP TO 12 ELECTRONS IN SINGLET USE - PARAMETER (MM=500000)
C     FOR UP TO 14 ELECTRONS IN SINGLET USE - PARAMETER (MM=2500000)
C     FOR UP TO 16 ELECTRONS IN SINGLET USE - PARAMETER (MM=12500000)
C     FOR UP TO 18 ELECTRONS IN SINGLET USE - PARAMETER (MM=62500000)
C
C     DIMENSION NASTR(10000),INDXW(10)
C     COMMON /LTAB/NTYPE,MAPINCORE,MEL,MSP,LOOKTB(6,100),NGRECD(4,100)
C     COMMON /MAP/MAP(3,MM),NALG(100),NRE(100),NAG1(100),NREC1(100),MVBM
      COMMON /MAP/MAP(3,MM),NALG(100),NRE(100),NAG1(100),MVBM
C     COMMON /NBRTAB/NBTAB(33336),NOTAB(33336),INDXZ(2,1000)
      COMMON /NBRTAB/NBTAB(MAXBLL),NOTAB(MAXBLL)
C     PARAMETER (MAXCEN=200)
C     PARAMETER (MAXNAB=MAXCEN*MAXBFN/2,MAXBF2=MAXBFN*MAXBFN)
C     COMMON /LMODAT/VMO(MAXBF2),VLMO(MAXBF2),LMOLAB(2,MAXBFN),
C    &LMOATM(5,MAXBFN),PGM(MAXNAB),ENGLMO(MAXBFN),BONDLAB(MAXBFN),
C    &MCLMO(5,80),LHFLAG
      DIMENSION W(*),CSTRX(1000),XFACTOR(1000)
C     DIMENSION SDM(MAXRBF),ORBLOC(MAXRBF)
      DIMENSION ORBLOC(MAXRBF)
      CMAXCUT = 0.025D0
      CMAXX   = 0.0D0
      CMAX    = 10.0D0
C     LHFLAG  = 1
C
C     RETURN IMMEDIATELY IF CI_ONLY IS TRUE
C
      IF(LCIONLY.EQ.1) RETURN
C     IFLAG=0
      MVBM=0
      NORB=MWINX
      NOCORB=MORBX
      DO I=1, NSTR
      CSTRX(I) = 1.0D0
      END DO
C
C     GET IOUNITS BY NAMES
C
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL GETIOUNIT('IAO2E   ',IAO2E)
      CALL GETIOUNIT('IOMAP   ',IOMAP)
      CALL GETIOUNIT('IOHES   ',IOHES)
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL GETIOUNIT('IVBO2E  ',IVBO2E)
      CALL GETVBPATH(VBPATH)
      CALL GETCTLVAL("DIIS      ",CTLVAL,IDIIS)
      CALL LOCTOR(IOENGI,'$CMAXCUT',8,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)CMAXCUT
C
C    SCANE OCCUPIED ORBITALS
C
      NOCCORB=0
      DO I=1,MELX*NSTR
      IF(NPHI(I).GT.NOCCORB) NOCCORB=NPHI(I)
      END DO
      NOCORB=NOCCORB
C     NS=MSPX ! MSPX now removed as argument
      N=MELX
      DO K=1,NSTR*N
C     NASTR(K)=NPHI(K)
      END DO
      CALL BRITAB(NOCORB,NORB,INDX,NBRIL,NBTAB,NOTAB,MASKBRI,MITER)
      NORB2   = NORB*(NORB+1)/2
C     INDXW(1)=NORB2
C     INDXW(2)=NORB2
C     INDXW(3)=NORB2
C
C     COMPUTE  SCRATCH SPACE FOR 3RD ORDER DENSITY MATRIX
C     FOR LHFSCF, THIS IS NOT NEEDED, THUS SET NORB3=1
C
      NORB3 = 1
C
C     COMPUTE ADDRESSES FOR VBHESS
C
      NWDM    = NORB2*(2+2*NSTR)+NORB2*(NORB2+1)*(2+NSTR)/2+NORB3
      NADDHESS= 1
      NADDS   = NADDHESS + (NBRIL+NSTR)*(NBRIL+NSTR+1)/2
      NADDH   = NADDS + NORB2
      NADDG   = NADDH + NORB2
      NADDVBS = NADDG + NORB2*(NORB2+1)/2
      NADDVBH = NADDVBS + NSTR*(NSTR+1)/2
      NADDM   = NADDVBH + NSTR*(NSTR+1)/2
      NADDSS  = NADDM + NWDM
      NADDAG  = NADDSS + N*NORB
      NREM1   = MW - NADDAG
      NLAST   = NADDAG
      MMX1    = NADDG + NORB2*(NORB2+1)/2
      MMX2    = MMX1 + NORB*NORB
C     MMX3    = MMX2 + NORB*NORB2
C
C     THE REMANING (NREM1) IS FOR THE SCATCH SPACE OF ALGEBRANTS IN VBHESS
C     THE MINIMAL SIZE IS A FUNCTION OF (N, NS AND IDERANK)
C     TODO: BUILD SUCH A TABLE.
C
      IF(NREM1.LT.0) CALL ABORT0('VBSCF01   ')
C     TIME1=XCLOCK()-TIME1
C1111 CONTINUE
C
C     SET CONVERGENCE FLAG TO NEGATIVE
C
      ICONV=0
      IF(NOPT.LE.0) RETURN
      IF(NSTR.GT.250) THEN
        WRITE(IOUTVB,*)"NO MORE THAN 250 VB STRUCTURES CAN BE OPTIMIZED"
        CALL ABORT0('VBSCF02   ')
      END IF
C
C     CALCUULATE THE INDEXES
C
      CALL SETIND(MWINX,MORBX)
C
C     INDEXES
C
      NPAR   = NBRIL + NSTR
      MSQ    = MWINX*(MWINX+1)/2
C     MTSQ   = NBASIS*(NBASIS+1)/2
C     MGSQ   = MSQ*(MSQ+1)/2
C     NMTSQ  = NBASIS*MTSQ
C
C     ADDRESS
C
C     THE ORDER OF MSS,MHH,MGG IS CRITICAL. IN HESSAN, HG STORE BOTH H AND G
C
      MTX    = NBASIS
      IF(NORB .GT. NBASIS) MTX = NORB
      MTXSQ  = MTX*(MTX+1)/2
      MSS    = 1
      MHH    = MSS+MTXSQ
      MGG    = MHH+MTXSQ
      MMT1   = MGG
      MMT2   = MMT1+MTX*MTX
      MMT3   = MMT2+MTX*MTXSQ
      MLAST  = MMT3+MTXSQ
      NREM2  = MW - MLAST
      IF(NREM2.LT.0) CALL ABORT0('VBSCF03   ')
C
C     MNSQ=MWINX*(MWINX+1)/2
C
C     READ CONSTRAINS FOR OPTIMIZATION (GENERAL, ORBITALS OR CSTR)
C     DETERMINE NONLINEARLY DEPENDENT PARAMETERS
C
      CALL RCONST(CONSTR,ICONST,NBRIL,NPAR,NLORBI,NLCSTR,FLAG)
      NONLIN=NLORBI+NLCSTR
C
      IFIX =1
      IF(NEWTON.GE.2) IFIX =0
      RGQT =0.1D0
      BGQT =0.9D0
      EPT  =0.0D0
      RDAMP=0.1D0
      TK   =0.1D0
      ERCTL=0.15D0
      ENG1 =0.0D0
      ENG2 =0.0D0
      DECREASE = .FALSE.
      CMAXOLD = 1000.0D0
      CALL LOCTOR(IOENGI,'$ERCTL',6,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)ERCTL
      ITER =0
      IF( LPTALL.EQ.1)
     &WRITE(IOUTVB,101) MGRP
 101  FORMAT(/' VB-ORBITAL OPTIMIZATION OF GROUP',I3,' ...')
      LDIAG = 0
C
C     VBOPT ITERATION STARTS HERE
C
      IF(MLORBIT(MGRP)*NBASIS.GT.33334) CALL ABORT0('VBSCF00001')
      NDIISS = 5
      CALL LOCTOR(IOENGI,'$DIISSTART',10,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)NDIISS
      NDIISMAX = 10
      IF(IDIIS.NE.1) NDIISS = 1000
 100  CONTINUE
      ENG2 = 0.0D0
      TK   =TK/2.0D0
      ITER =ITER+1
      CALL GETIOUNIT('IOTEMPA ',IOTEMPA)
      CALL GETIOUNIT('IOTEMPB ',IOTEMPB)
      IF(ITER.LE.1) THEN
C     LBUFF   = 4095
C     NSQ     = NORB*(NORB+1)/2
C     NSQ2    = NSQ*(NSQ+1)/2
C     NB2     = NBASIS*NBASIS
      CALL READ1E(IAO1E,W(MSS),W(MHH),NBASIS)
      CALL VBONORM(NBASIS,MLORBIT(MGRP),WBASIS,W(MSS),CNORM)
      CALL RNCSTR(NSTR,CSTR,XFACTOR,CNORM,MELX,NPHI)
C
C     TODO: MODIFY THIS
C
C     NSIZE = MW - MGG
      CALL READ1E(IAO1E,W(MSS),W(MHH),NBASIS)
C
C     COPY DENSITY OF CORE TO WORKING FILED G(MMT3)
C
      DO I=1,NBASIS*(NBASIS+1)/2
      W(MMT3-1+I)=DMP(I)
      END DO
      IHFPO = 1
C     TIME=XCLOCK()
      REWIND(IVBO2E)
      CALL TRAN1E(NBASIS,NORB,W(MSS),W(MHH),
     &     WBASIS,W(MMT1),W(MMT2),W(MMT3),IHFPO,IVBO2E)
C
C     SAVE A COPY OF H,S OF THE FIRST ITERATION
C
      CALL SHREAD(W(NADDS),W(NADDH),MSQ,IVBO2E)
      CALL DSTORE(0,1,MSQ,2, INTDAT, W(NADDS))
      CALL DSTORE(0,1,MSQ,3, INTDAT, W(NADDH))
        IF(NBASIS*NORB.GT.MAXRBF) CALL ABORT0("BASIS10000")
        DO I=1, NORB*NORB
        ORBLOC(I)=0.0D0
        END DO
        DO I=1, NORB
        II = (I-1)*NORB+I
        ORBLOC(II) = 1.0D0
        END DO
        DO I=1, NBASIS*NORB
        BASIS0(I) = WBASIS(I)
        END DO
      ELSE
        CALL DSTORE(0,0,MSQ,2, INTDAT, W(NADDS))
        CALL DSTORE(0,0,MSQ,3, INTDAT, W(NADDH))
C     TIME=XCLOCK()
      REWIND(IVBO2E)
      IHFPO = 0
      CALL TRAN1E(NORB,NORB,W(NADDS),W(NADDH),ORBLOC,W(MMX1),W(MMX2),
     &            DUMMY,IHFPO,IVBO2E)
      END IF
C     TIME1=XCLOCK()
C     TIME=TIME1-TIME
C     WRITE(IOUTVB,'(" 2E-TRAN TIME FOR VBSCF=",F8.3)')TIME
      CALL SHREAD(W(NADDS),W(NADDH),MSQ,IVBO2E)
      IF(ITER.EQ.1) CALL VBDIISINIT(NDIISMAX,NDIISS,W(NADDS),MSQ)
C
C     DERIVATIVES AND HESSIAN
C     IF(IDERANK.EQ.2), THEN HESSAIN WILL BE RE-COMPUTED
C     OTHERWISE, THE HESSIAN FROM PREVIOUS ITERATION WILL BE USED
C
C
      IDERANK=2
      IF(ICONV.EQ.1) IDERANK=1
      IF(ITER.GT.1.AND.CMAX.LT.CMAXCUT.AND.DECREASE) IDERANK=1
      IF(ITER.GT.1.AND.CMAX.LT.CMAXCUT.AND.IDIIS.EQ.1) IDERANK=1
C     TIME1=XCLOCK()
      NVAR = NBRIL + NSTR
      IJ = 0
      DO I=1, NVAR
        DEV1(I) = 0.0D0
        DO J=1, I
        IJ = IJ+1
        W(NADDHESS-1+IJ) = 0.0D0
        ENDDO
      ENDDO
C
C     OPTIONALLY ADD DELOCALIZATION PENALTY
C
      LPENADD1 = NADDAG
      LPENADD2 = LPENADD1 + NBASIS*NBASIS
      CALL READ1E(IAO1E,W(LPENADD1),W(LPENADD2),NBASIS)
      CALL DPENALTY1(WBASIS,NORB,W(LPENADD1),NBRIL,INDX,MGRP,
     &     W(LPENADD2),DEV1,W(NADDHESS),LASTITER,ICONV,MITER,
     &     TDELOCAL,ITER)
C
C     ADD TDELOCAL TO ENERGY
C
      ENG2 = ENG2 + TDELOCAL
C     WRITE(IOUTVB,*)"ENG2, TDELOCAL = ",ENG2, TDELOCAL
C
C     OVERLAP PENALTY
C
      CALL SHREAD(W(LPENADD1),W(LPENADD2),MSQ,IVBO2E)
      CALL OPENALTY(NORB,W(LPENADD1),NBRIL,INDX,MGRP,DEV1,
     &              W(NADDHESS),LASTITER,ICONV,TOVERLAP)
      ENG2 = ENG2 + TOVERLAP
C     WRITE(IOUTVB,*)"ENG2, TOVERLAP = ",ENG2, TOVERLAP
C1112 CONTINUE
      IF(LDIAG.EQ.1) CALL RVB(NSTR,CSTRX,W(NADDVBS),W(NADDVBH),
     &                        W(NADDAG),NREM1,F2,FLAG,0,MGRP)
C
C     Fix zero eigenvalue problem due to linear dependency of CSTR
C
      CALL ZHESS(W(NADDHESS),NSTR,CSTR,NBRIL,DEV1)
C
C     APPLY BRILLOUIN MASK (CONSTRAINED ORBITAL OPTIMIZATION)
C
      CALL BRIMASK(W(NADDHESS),NSTR,NBRIL,DEV1,MASKBRI)
C     TIME1=XCLOCK()-TIME1
C     WRITE(IOUTVB,*)'TIME FOR VBHESS=',TIME1
C     WRITE(IOUTVB,*)'ENG2-ENG1=',ENG2-ENG1
      IF(ENG2-ENG1.LT.0.0D0) DECREASE=.TRUE.
C
C     HESSIAN OF PREVIOUS ITERATION CAN BE OPTIONALLY LOADED FROM
C     FILE IOHES
C
      CALL CONDEN(W(NADDHESS),W(NADDAG),DEV1,DEV,NPAR,NONLIN,IDERANK,
     & IOHES,CONSTR,ICONST)
C
      IF(NEWTON.GE.1) THEN
C
C     Fix negative eigenvalue problem before going to NR
C     Jacobi is very poor for Diag. of Large matrix
C
      IF(IDERANK.GE.2)
     &  CALL DIAGHER(W(NADDHESS),NONLIN,DEV,SEIG,W(NADDAG),IFIX,.FALSE.)
      IF(IFIX.EQ.1) THEN
      CALL NRDATE(NONLIN,DEV,W(NADDHESS),VECT,CMAX,ERCTL,W(NADDAG),
     &            RDAMP,SEIG,EPT,ENG1,ENG2)
      ELSE
      CALL NRGQT3(NONLIN,DEV,W(NADDHESS),VECT,CMAX,ERCTL,W(NADDAG),
     &            RGQT,BGQT,SEIG,EPT,ENG1,ENG2)
      END IF
C
C     EXPAND PARAMETERS
C
      DAMPVEC = 1.0D0
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$DAMPVEC',8,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)DAMPVEC
      DO I=1, NBRIL
         VECT(I) = VECT(I)*DAMPVEC
      END DO
      CALL EXPAND(VECT,CONSTR,ICONST,NPAR)
C
C     APPLY BRI MASK
C
      DO K=1, NBRIL
      IF(MASKBRI(K).EQ.0) VECT(K) = 0.0D0
      END DO
C
C     UPDATE STRUCTURE COEFFICIENTS
        IF(LDIAG.EQ.1) THEN
          CRATE = CSTR(1)/CSTRX(1)
          DO ISTR=1,NSTR
          CSTR(ISTR)=CRATE*CSTRX(ISTR)
          END DO
        ELSE
          DO ISTR=1,NSTR
          CSTR(ISTR)=CSTR(ISTR)+VECT(NBRIL+ISTR)
          END DO
        END IF
C
C     POSSIBLE STRUCTURE COEFFICIENT SYMMETRY
C
          CALL STRSYM(CSTR,NSTR,FLAG)
      ELSE
      WRITE(IOUTVB,*)
     & 'SORRY, CONJUGATE-GRADIENT METHOD HAS BEEN TAKEN AWAY'
      CALL ABRTVB
      END IF
      IF(ICONV.NE.1) THEN
      CMAXX=1.0D0
      CALL VBDIIS(NOCORB,NORB,NBASIS,NBRIL,INDX,W,BASIS0,WBASIS,
     &            ORBLOC,DEV1,VECT,CMAX,CNORM)
      CMAXX = CMAX
      CALL RNCSTR(NSTR,CSTR,XFACTOR,CNORM,MELX,NPHI)
      IF(LPTALL.EQ.1) WRITE(IOUTVB,103) MGRP,ITER,CMAX
 103  FORMAT(' GROUP =',I3,'  ITER =',I3,' CMAX = ',F17.14)
      END IF
C     ETOT = ETOTAL + ENG2
C     TIME=XCLOCK()
C     TIME=TIME-TIME1
      IF(CMAX.GT.CMAXOLD) DECREASE=.FALSE.
      CMAXOLD=CMAX
      IF(CMAXX.GT.EPS.AND.ICONV.EQ.1) THEN
      WRITE(IOUTVB,1100)CMAXX,ITER
      END IF
      IF(CMAX.GT.EPS.AND.ITER.LT.MAXIT.AND.ICONV.NE.1) GOTO 100
C
C     DO ONE MORE ITERATION TO OBTAIN DENSITY MATRIX WITHOUT
C     UPDATING VB ORBITALS.
C
      IF(ICONV.EQ.0) THEN
      ICONV=1
      GOTO 100
      END IF
 1100 FORMAT(" VBSCF NOT CONVERGED. CMAX = ",F17.14, " AFTER ",
     &        I3," ITERATIONS")
C
C     PRINT OVERLAP MATRIX
C
      IF(LASTITER.EQ.1) THEN
      CALL SHREAD(W(NADDS),W(NADDH),MSQ,IVBO2E)
      CALL MPRINT2(NORB,W(NADDS),1,MGRP)
      END IF
C
C     COMPUTE DMLOC FROM S MATRIX
C
      NADDS0 = NADDH
      NADDV  = NADDS0 + NORB*NORB
      NADDSA = NADDV  + NORB*NORB
      NADDA  = NADDSA + NORB*NORB
      NADDW  = NADDA  + NORB*NORB
      NLAST  = NADDW  + NORB*NORB*5
      IF(NLAST.GT.MW) CALL ABORT0("LHFSCF0001")
      DO I=1,NORB
        DO J=1, I
          IJ = I*(I-1)/2+J
          IJ2 = (I-1)*NORB+J
          JI2 = (J-1)*NORB+I
          W(NADDS0-1+IJ2) = W(NADDS-1+IJ)
          W(NADDS0-1+JI2) = W(NADDS-1+IJ)
          W(NADDA-1+IJ2) = 0.0D0
          W(NADDA-1+JI2) = 0.0D0
        ENDDO
        W(NADDA-1+JI2) = 1.0D0
      ENDDO
      CALL LOWD(NORB,NORB,W(NADDS0),W(NADDA),W(NADDSA),
     &                         W(NADDV),W(NADDW),IERR)
      NADDM1 = NADDS0
      DO I=1, NORB2
      W(NADDM1-1+I) = 0.0D0
      ENDDO
      DO I=1, NORB
        I2 = I*(I+1)/2
        W(NADDM1-1+I2) = 2.0D0
      ENDDO
      CALL MATRAN2(NORB,NORB,W(NADDV),W(NADDW),
     &       W(NADDM1),DMLOC,0)
C
C     COMPUTE D2
C     FIRST, COMPUTE D2 in LOWDIN ORBITALS
      DO I=1,NORB2*(NORB2+1)/2
      DM2LOC(I)=0.0D0
      END DO
      DO I=1, NORB
         II = I*(I-1)/2
         I2 = I*(I+1)/2
         DO J=1, I
           IJ = II + J
           IJ2 = IJ*(IJ+1)/2
           IIJJ = I2*(I2-1)/2 + J*(J+1)/2
           FACTOR = -2.0D0
           IF(I.EQ.J) FACTOR = 1.0D0
           DM2LOC(IJ2)=FACTOR
           IF(I.NE.J) DM2LOC(IIJJ)=4.0D0
         ENDDO
      ENDDO
      NADDP  = NADDV  + NORB*NORB
      NADDT  = NADDP  + NORB*NORB
      NADDN  = NADDT  + NORB*NORB
      NADDW  = NADDN  + NORB2*(NORB2+1)/2
      NLAST  = NADDW  + NORB2*NORB
      IF(NLAST.GT.MW) CALL ABORT0("LHFSCF0002")
      CALL M4TRAN(NORB, NORB,W(NADDV),W(NADDW),W(NADDP),
     &            DM2LOC,W(NADDN),W(NADDT))
      DO I=1, NORB2*(NORB2+1)/2
         DM2LOC(I) = W(NADDN-1+I)
      ENDDO
      CSTR(1) = 1.0D0
      RETURN
      END
      SUBROUTINE BRITAB(NOCORB,NORB,INDX,NBRIL,NBTAB,NOTAB,MASKBRI
     &,MITER)
C#######################################################################
      IMPLICIT NONE
      LOGICAL GOTAOGRP
      INTEGER NOCORB,NORB,INDX,NBRIL,NBTAB,NOTAB,MASKBRI,MITER,IOENGI,
     &MAXCEN,MAXBFN,MAXBLL,NBLL,
     &KATOM,NPJ,I,J,K,I1,J1,JT,IOK,IOK2,NP,MASK,NMASK
      PARAMETER (MAXCEN=200,MAXBFN=726,MAXBLL=12500)
      DIMENSION KATOM(MAXBFN),NPJ(MAXBFN)
      DIMENSION INDX(2,*),NBTAB(NORB,*),NOTAB(NORB,*)
      DIMENSION MASK(200,200),MASKBRI(*)
C
      INTEGER IOUTVB,LENFIL
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
      CHARACTER*20 BASNAME
      CHARACTER*12 BFLABE
      INTEGER NATOM,NELE,NSPIN,NBASIS,NATNUM,NATBAS
      DOUBLE PRECISION ENREP,XYZ
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
C
      IF(NOCORB.GT.200.OR.NORB.GT.200) CALL ABORT0("BRITAB0001")
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      DO I=1, NOCORB
        DO J=1, NORB
          MASK(J,I)=1
        END DO
        MASK(I,I)=0
      END DO
C     AUTOMATIC BRILLMASK SECTION
      CALL LOCTOR(IOENGI,'$AOGROUP',8,IOK2,0)
      GOTAOGRP=IOK2.EQ.1
      CALL LOCTOR(IOENGI,"$BRILLMASK",10,IOK,0)
      IF(IOK.EQ.1) THEN
        NMASK=0
        READ(IOENGI,*,END=1,ERR=1) NMASK
        IF(NMASK.GT.0) GOTO 301
        IF(NMASK.LT.0) NP = -NMASK
 1      IF(MITER.EQ.1) WRITE(IOUTVB,
     &  '(" $BRILLMASK WILL OBTAIN PARAMETERS AUTOMATICALLY")')
        IF(GOTAOGRP) THEN
          CALL LOCTOR(IOENGI,'$AOGROUP',8,IOK2,0)
          READ(IOENGI,*,ERR=101) NP
          READ(IOENGI,*,ERR=101) (NPJ(I),I=1,NP)
          DO I=1,NP
            READ(BFLABE(NPJ(I))(1:3),'(I3)') KATOM(I)
          END DO
        ELSE
C         READ(IOENGI,*,ERR=102) NP
          READ(IOENGI,*,ERR=102) (KATOM(I),I=1,NP)
        ENDIF
C       IF(MITER.EQ.1) 
C    &    WRITE(IOUTVB,'(" KATOM  ",10I4)') (KATOM(I),I=1,NP)
        NMASK = 0
        DO I=1,NOCORB
          I1=KATOM(I)
          DO J=1,NP
            J1=KATOM(J)
            IF(J1.NE.I1.AND.I.NE.J) THEN
              NMASK = NMASK + 1
              MASK(J,I)=0
C             IF(MITER.EQ.1) WRITE(IOUTVB,'(2I4)') I,J
            ENDIF
          ENDDO
        ENDDO
        IF(MITER.EQ.1) WRITE(IOUTVB,
     &    '(" $BRILLMASK FINDS ",I4," CONDITIONS AND",I3,
     &    " ACTIVE VBOS")') NMASK,NOCORB
        GOTO 300
 101  CALL ABORT0("BRITAB0002")
 102  WRITE(IOUTVB,'(" NO ATOM ARRAY FOUND, WITH AOGROUP ABSENT")')
      CALL ABORT0("BRITAB0003")
C     FULL BRILLMASK SECTION
 301    IF(MITER.EQ.1) WRITE(IOUTVB,
     &    '(/," $BRILLMASK APPLIES WITH ",I4," CONDITIONS")') NMASK
        DO I=1,NMASK
          READ(IOENGI,*)J,K
          MASK(K,J)=0
        END DO
      END IF
 300  NBRIL=0
      DO 100 I=1,NOCORB
      JT=0
      DO 200 J=1,NORB
        IF(I.EQ.J) THEN
          NBTAB(J,I)=0
        ELSE
          NBRIL=NBRIL+1
          JT=JT+1
          NBTAB(J,I)=NBRIL
          NOTAB(JT,I)=J
          INDX(1,NBRIL)=I
          INDX(2,NBRIL)=J
          IF(NBRIL.GT.10000) CALL ABORT0("BRITAB0004")
          IF(MASK(J,I).EQ.0) THEN
            MASKBRI(NBRIL) = 0
          ELSE
            MASKBRI(NBRIL) = 1
          END IF
        END IF
 200  CONTINUE
C     IF (MITER.EQ.1) 
C    & WRITE(IOUTVB,*)'NOTAB(J,I)',(NOTAB(J,I),J=1,NORB-1)
 100  CONTINUE
      NBLL = NOCORB + (NORB - 1)
      IF(NBLL.GE.MAXBFN) CALL SIZEABT(NBLL,MAXBLL,"BRILLMASK arrays  ",
     &  "MAXBLL",IOUTVB,.TRUE.)
      RETURN
      END
      SUBROUTINE LOOKUP(NWK,LPTYPE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /LTAB/NTYPE,MAPINCORE,MEL,MSP,LOOKTB(6,100),NGRECD(4,100)
      DIMENSION NWK(6)
C
C     NGRECD(1,K): THE NUMBER OF ALGEBRANTS CORRESPONDING TO
C                  THE LPNODE (OR THE LP TYPE)
C     NGRECD(2,K): THE NUMBER OF CHILD ALGEBRANTS FROM THIS LP TYPE
C     NGRECD(3,K): THE RECORDS FOR THIS LPNODE (K)
C     NGRECD(4,K): THE STARTING ADDRESS FOR THIS LP TYPE
C
C     LOOKUP FOR LPTYPE OF NW, IF NOT FOUND, ADD IT INTO LOOKTB
C
      IF(NWK(1).GT.NWK(4)) THEN
      WRITE(IOUTVB,*)'WRONG DATA, STOP'
      CALL ABRTVB
      END IF
      DO 100 I=1,NTYPE
         DO K=1,6
         IF(NWK(K).NE.LOOKTB(K,I)) GOTO 100
         END DO
      LPTYPE=I
      RETURN
  100 CONTINUE
      NTYPE=NTYPE+1
      DO K=1,6
      LOOKTB(K,NTYPE)=NWK(K)
      END DO
      LPTYPE=NTYPE
C     WRITE(IOUTVB,'('NEW TYPE',I10,6I8)')NTYPE,(LOOKTB(K,NTYPE),K=1,6)
      RETURN
      END
      SUBROUTINE GSYMBO(N,NS,NASTR,NSTR,KTNODE,NODES,IDERANK,MAXNODE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
CN18  PARAMETER (NW1=1000000)
CN14  PARAMETER (NW1=100000)
      PARAMETER (NW1=100000)
      DIMENSION NASTR(N,*),NW(NW1),NPATN(NW1),KTNODE(*)
      NWK=1
      DO K=1,IDERANK+2
      IF(K.GT.N) GOTO 100
      NK=NCOMBI(N,K)
      DO I=1,NSTR
      IF(K.EQ.0) CALL GSYM00(N,NS,NASTR(1,I),NPATN(NWK),I)
      IF(K.EQ.1) CALL GSYM01(N,NS,1,NASTR(1,I),NPATN(NWK),I)
      IF(K.EQ.2) CALL GSYM02(N,NS,2,NASTR(1,I),NPATN(NWK),I)
      IF(K.EQ.3) CALL GSYM03(N,NS,3,NASTR(1,I),NPATN(NWK),I)
      IF(K.EQ.4) CALL GSYM04(N,NS,4,NASTR(1,I),NPATN(NWK),I)
      NWK=NWK+NK*(N+5)
      IF(NWK.GT.NW1) CALL ABORT0('GSYMBO01  ')
      END DO
      END DO
 100  CONTINUE
      NSET=NWK/(N+5)
      CALL BTSORT(N,NS,NSET,NPATN,NW,KTNODE,NODES,MAXNODE)
      RETURN
      END
      SUBROUTINE BTSORT(N,NS,NSET,NPATN,NW,KTNODE,NODES,MAXNODE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPATN(N+5,*),NW(N,*),NWK(100),KTNODE(5,*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      J=NSET
  5   IF(J.LE.1) GOTO 20
      J=J/2
      NMJ=NSET-J
  8   IFLAG=0
      DO 10 I=1,NMJ
      L=I+J
      IF(IBTDIFF(NPATN(1,I),NPATN(1,L),N).LE.0) GOTO 10
      CALL INTEQU(NWK,NPATN(1,I),N+5)
      CALL INTEQU(NPATN(1,I),NPATN(1,L),N+5)
      CALL INTEQU(NPATN(1,L),NWK,N+5)
      IFLAG=1
  10  CONTINUE
      IF(IFLAG.EQ.1) GOTO 8
      GOTO 5
 20   CONTINUE
      DO KR=N,1,-1
      KCOUNT=1
      NW(KR,1)=KCOUNT
      DO I=1,NSET-1
      KDIFF=KBTDIFF(NPATN(1,I),NPATN(1,I+1),N,KR)
      IF(KDIFF.EQ.0) THEN
      NW(KR,I+1)=KCOUNT
      ELSE IF(KDIFF.LT.0) THEN
      KCOUNT=KCOUNT+1
      NW(KR,I+1)=KCOUNT
      ELSE
      WRITE(IOUTVB,*)'WRONG RESULTS'
      END IF
      END DO
      END DO
      CALL TRNODE(NPATN,NW,NSET,N,NS,KTNODE,NODES,MAXNODE)
      RETURN
      END
      SUBROUTINE TRNODE(NPATN,NW,NGRP,N,NS,KTNODE,NODES,MAXNODE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPATN(N+5,*),NW(N,*),KTNODE(5,*)
      DIMENSION NWK(100),LPW(6)
      COMMON /AGCODE/NPK1,NPK2,NPK3
      DO I=1,N
      NWK(I)=0
      END DO
      NODES=0
      DO 100 K=1,NGRP
      KRANK=NPATN(N+5,K)
        DO 200 I=1,N
        NI=N-I+1
        NPARITY =1
        IDCHID=1
        IDTHIS=0
C       CALL BTYPE(NPATN(1,K),N,NS,NI-1,NSH,NBH,NPA)
C       CALL BTYPE(NPATN(1,K),N,NS,NI,NSL,NBL,NPA)
        CALL BTYPE(NPATN(1,K),N,NI-1,NSH,NBH,NPA)
        CALL BTYPE(NPATN(1,K),N,NI,NSL,NBL,NPA)
        IF(NI.LE.N) IDTHIS=NW(NI,K)
        IF(NI.GT.1) IDCHID=NW(NI-1,K)
        IRANKL=I-1
        IRANKH=I
        IDEN =0
C
C       SPECIAL CASE: THe LAST STEP FOR THE LAPLACE EXPANSION FOR
C       THIS NPATN
C
        IF(NI.EQ.KRANK) THEN
        IDEN=1
        IRANKH=N
        NSH=NS
        NBH=0
        N2=MOD(NPATN(N+3,K),2)
        IF(N2.EQ.1) NPARITY=-1
C
C        SUBCASE 1: KRANK=4
C        PACK a,b,c,d
C
         IF(KRANK.EQ.4) THEN
         IA=NPATN(1,K)
         IB=NPATN(2,K)
         IC=NPATN(3,K)
         ID=NPATN(4,K)
         IABCD=IA+IB*NPK1+IC*NPK2+ID*NPK3
         END IF
         IF(KRANK.EQ.3) THEN
         IA=NPATN(1,K)
         IB=NPATN(2,K)
         IC=NPATN(3,K)
         IABCD=IA+IB*NPK1+IC*NPK2
         END IF
         IF(KRANK.EQ.2) THEN
         IA=NPATN(1,K)
         IB=NPATN(2,K)
         IABCD=IA+IB*NPK1
         END IF
         IF(KRANK.EQ.1) THEN
         IA=NPATN(1,K)
         IABCD=IA
         END IF
        IDTHIS=NPATN(N+4,K)
        ELSE
C
C       SKIP IT IF IT IS AVAILABLE
C
        IF(IDTHIS.LE.NWK(I)) GOTO 200
        IABCD=NPATN(NI,K)
        END IF
      NODES=NODES+1
      IF(NODES.GT.MAXNODE) CALL ABORT0('TRNODE01  ')
      LPW(1)=IRANKL
      LPW(4)=IRANKH
      LPW(2)=NSL
      LPW(3)=NBL
      LPW(5)=NSH
      LPW(6)=NBH
      IF(IRANKH.GE.N) IDTHIS=NPATN(N+4,K)
      CALL LOOKUP(LPW,ITYPE)
      KTNODE(1,NODES)=IABCD
      KTNODE(2,NODES)=ITYPE
      KTNODE(3,NODES)=IDTHIS*NPARITY
      KTNODE(4,NODES)=IDCHID
      KTNODE(5,NODES)=IDEN
      IF(IDEN.EQ.1) GOTO 100
      NWK(I)=IDTHIS
  200 CONTINUE
  100 CONTINUE
      RETURN
      END
C
C     DETERMINE NSA,NBA,NPA of THE N-K SUBSET
C
C     SUBROUTINE BTYPE(NPATN,N,NS,K,NSA,NBA,NPA)
      SUBROUTINE BTYPE(NPATN,N,K,NSA,NBA,NPA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPATN(N+5)
      NUPSA=NPATN(N+1)
      NUPBA=NPATN(N+2)
      LRNKA=NPATN(N+5)
      NSA=NUPSA
      NBA=NUPBA
      NPA=(N-K-NSA-NBA)/2
      IF(K.LE.LRNKA) RETURN
      NBA=N-K-((N-K)/2)*2
      IF(K.LE.LRNKA+NUPSA) THEN
      NSA=LRNKA+NUPSA-K
      NBA=NUPBA
      ELSE IF(K.LE.LRNKA+NUPSA+NUPBA) THEN
      NBA=LRNKA+NUPSA+NUPBA-K
      NSA=0
      ELSE
      NSA=0
      END IF
      NPA=(N-K-NSA-NBA)/2
      RETURN
      END
      INTEGER FUNCTION KBTDIFF(NPATNA,NPATNB,N,KR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPATNA(N+5),NPATNB(N+5)
      KBTDIFF=0
      NUPSA=NPATNA(N+1)
      NUPBA=NPATNA(N+2)
      LRNKA=NPATNA(N+5)
      NUPSB=NPATNB(N+1)
      NUPBB=NPATNB(N+2)
      LRNKB=NPATNB(N+5)
      DO K=N,KR,-1
      IF(K.LE.LRNKA.AND.K.LE.LRNKB) RETURN
      IF(K.LE.LRNKA) THEN
      KBTDIFF=1
      RETURN
      END IF
      IF(K.LE.LRNKB) THEN
      KBTDIFF=-1
      RETURN
      END IF
      NUPBAA=N-K+1-((N-K+1)/2)*2
      NUPBBB=NUPBAA
      NUPSAA=0
      NUPSBB=0
      IF(K.LE.LRNKA+NUPSA) THEN
      NUPSAA=LRNKA+NUPSA-K
      NUPBAA=NUPBA
      ELSE IF(K.LE.LRNKA+NUPSA+NUPBA) THEN
      NUPSAA=0
      NUPBAA=LRNKA+NUPSA+NUPBA-K
      END IF
      IF(K.LE.LRNKB+NUPSB) THEN
      NUPBBB=NUPBB
      NUPSBB=LRNKB+NUPSB-K
      ELSE IF(K.LE.LRNKB+NUPSB+NUPBB) THEN
      NUPSBB=0
      NUPBBB=LRNKB+NUPSB+NUPBB-K
      END IF
      IF(NUPSAA.GT.NUPSBB) THEN
      KBTDIFF=1
      RETURN
      END IF
      IF(NUPSAA.LT.NUPSBB) THEN
      KBTDIFF=-1
      RETURN
      END IF
      IF(NUPBAA.GT.NUPBBB) THEN
      KBTDIFF=1
      RETURN
      END IF
      IF(NUPBAA.LT.NUPBBB) THEN
      KBTDIFF=-1
      RETURN
      END IF
      IF(NPATNA(K).GT.NPATNB(K)) THEN
      KBTDIFF=1
      RETURN
      END IF
      IF(NPATNA(K).LT.NPATNB(K)) THEN
      KBTDIFF=-1
      RETURN
      END IF
      END DO
      RETURN
      END
      INTEGER FUNCTION IBTDIFF(NPATNA,NPATNB,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPATNA(N+5),NPATNB(N+5)
      IBTDIFF=0
      NUPSA=NPATNA(N+1)
      NUPBA=NPATNA(N+2)
      LRNKA=NPATNA(N+5)
      NUPSB=NPATNB(N+1)
      NUPBB=NPATNB(N+2)
      LRNKB=NPATNB(N+5)
C     WRITE(IOUTVB,*)'IBTDIFF CALLED'
      DO K=N,1,-1
      IF(K.LE.LRNKA.AND.K.LE.LRNKB) RETURN
      IF(K.LE.LRNKA) THEN
      IBTDIFF=1
      RETURN
      END IF
      IF(K.LE.LRNKB) THEN
      IBTDIFF=-1
      RETURN
      END IF
      NUPBAA=N-K+1-((N-K+1)/2)*2
      NUPBBB=NUPBAA
      NUPSAA=0
      NUPSBB=0
      IF(K.LE.LRNKA+NUPSA) THEN
      NUPSAA=LRNKA+NUPSA-K
      NUPBAA=NUPBA
      ELSE IF(K.LE.LRNKA+NUPSA+NUPBA) THEN
      NUPSAA=0
      NUPBAA=LRNKA+NUPSA+NUPBA-K
      END IF
      IF(K.LE.LRNKB+NUPSB) THEN
      NUPBBB=NUPBB
      NUPSBB=LRNKB+NUPSB-K
      ELSE IF(K.LE.LRNKB+NUPSB+NUPBB) THEN
      NUPSBB=0
      NUPBBB=LRNKB+NUPSB+NUPBB-K
      END IF
      IF(NUPSAA.GT.NUPSBB) THEN
      IBTDIFF=1
      RETURN
      END IF
      IF(NUPSAA.LT.NUPSBB) THEN
      IBTDIFF=-1
      RETURN
      END IF
      IF(NUPBAA.GT.NUPBBB) THEN
      IBTDIFF=1
      RETURN
      END IF
      IF(NUPBAA.LT.NUPBBB) THEN
      IBTDIFF=-1
      RETURN
      END IF
      IF(NPATNA(K).GT.NPATNB(K)) THEN
      IBTDIFF=1
      RETURN
      END IF
      IF(NPATNA(K).LT.NPATNB(K)) THEN
      IBTDIFF=-1
      RETURN
      END IF
      END DO
      RETURN
      END
C     SUBROUTINE GSYM00(N,NS,NK,NASTR,NPATN,NSTRUC)
      SUBROUTINE GSYM00(N,NS,NASTR,NPATN,NSTRUC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     DIMENSION NPAIR(100),NWK(100),NASTR(N),NPATN(N+5,*)
      DIMENSION NASTR(N),NPATN(N+5,*)
C
C     DATA STRUCTURE
C
C          NPATN(N+1): NUMBER OF UNPAIRED SPINS IN THE (N-NK) SUBSET
C          NPATN(N+2): NUMBER OF UNPAIRED ORBITALS IN THE (N-NK) SUBSET
C          NPATN(N+3): PARITY DUE TO THE REORDER OF THE UNPAIRED SPINS
C          NPATN(N+4): # OF VB STRUCTURE THAT THE <B| OF THE ALGEBRANTS
C          NPATN(N+5): THE RANK OF THE FINAL ALGEBRANT-COFACTOR
C
      DO M=1,N
      NPATN(M,1)=NASTR(M)
      END DO
      IJK=1
C
C     SET TYPES AND PARITY
C
      NPATN(N+1,IJK)=NS
      NPATN(N+2,IJK)=0
      NPATN(N+3,IJK)=0
      NPATN(N+4,IJK)=NSTRUC
      NPATN(N+5,IJK)=0
C
C     REORDER TO STANDARD FORM
C
      CALL STDFOM(NPATN(1,IJK),N,0,NS)
      RETURN
      END
      SUBROUTINE GSYM01(N,NS,NK,NASTR,NPATN,NSTRUC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPAIR(100),NWK(100),NASTR(N),NPATN(N+5,*)
C
C     DATA STRUCTURE
C
C          NPATN(N+1): NUMBER OF UNPAIRED SPINS IN THE (N-NK) SUBSET
C          NPATN(N+2): NUMBER OF UNPAIRED ORBITALS IN THE (N-NK) SUBSET
C          NPATN(N+3): PARITY DUE TO THE REORDER OF THE UNPAIRED SPINS
C          NPATN(N+4): # OF VB STRUCTURE THAT THE <B| OF THE ALGEBRANTS
C          NPATN(N+5): THE RANK OF THE FINAL ALGEBRANT-COFACTOR
C
      DO I=N-NS+1,N
      NPAIR(I)=0
      END DO
      DO J=1,(N-NS)/2
      J1=J+J-1
      J2=J1+1
      NPAIR(J1)=J2
      NPAIR(J2)=J1
      END DO
      IJK=0
      DO I=1,N
      IJK=IJK+1
        DO M=1,N
        NWK(M)=NASTR(M)
        END DO
      NWK(I)=0
C
C     COLLECT UPAIRED SPINS AND ORBITALS
C
      NUPS=0
      NUPB=0
C     NP  =0
      NPARITY=0
      IF(NPAIR(I).EQ.0) THEN
      NUPS=NUPS+1
      NPATN(NUPS,IJK)=NASTR(I)
      NPARITY=NPARITY+I-NUPS
      ELSE
C     IF(NPAIR(I).GT.0) THEN
      NUPB=NUPB+1
      NPATN(NUPS+NUPB,IJK)=NASTR(I)
      NPATN(NK+NS-NUPS+NUPB,IJK)=NASTR(NPAIR(I))
      NWK(NPAIR(I))=0
      END IF
C
C     COLLECT UPAIRED SPINS FOR THE (N-NK) SET
C
      N1S=0
      DO M=N-NS+1,N
      IF(NWK(M).NE.0) THEN
      N1S=N1S+1
      NPATN(NK+N1S,IJK)=NASTR(M)
      NWK(M)=0
      END IF
      END DO
      NSTART=1+(NS-NUPS)+NUPB
      DO M=1,N
        IF(NWK(M).NE.0) THEN
        NSTART=NSTART+1
        NPATN(NSTART,IJK)=NASTR(M)
        END IF
      END DO
C
C     SET TYPES AND PARITY
C
      NPATN(N+1,IJK)=NS-NUPS
      NPATN(N+2,IJK)=NUPB
      NPATN(N+3,IJK)=NPARITY
      NPATN(N+4,IJK)=NSTRUC
      NPATN(N+5,IJK)=1
C
C     REORDER TO STANDARD FORM
C
      CALL STDFOM(NPATN(1,IJK),N,1,NS)
      END DO
      RETURN
      END
      SUBROUTINE GSYM02(N,NS,NK,NASTR,NPATN,NSTRUC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPAIR(100),NWK(100),NASTR(N),NPATN(N+5,*)
C
C     DATA STRUCTURE
C
C          NPATN(N+1): NUMBER OF UNPAIRED SPINS IN THE (N-NK) SUBSET
C          NPATN(N+2): NUMBER OF UNPAIRED ORBITALS IN THE (N-NK) SUBSET
C          NPATN(N+3): PARITY DUE TO THE REORDER OF THE UNPAIRED SPINS
C          NPATN(N+4): # OF VB STRUCTURE THAT THE <B| OF THE ALGEBRANTS
C
      DO I=N-NS+1,N
      NPAIR(I)=0
      END DO
      DO J=1,(N-NS)/2
      J1=J+J-1
      J2=J1+1
      NPAIR(J1)=J2
      NPAIR(J2)=J1
      END DO
      IJK=0
      DO I=1,N-1
      DO J=I+1,N
      IJK=IJK+1
        DO M=1,N
        NWK(M)=NASTR(M)
        END DO
      NWK(I)=0
      NWK(J)=0
C
C     COLLECT UPAIRED SPINS AND ORBITALS
C
      NUPS=0
      NUPB=0
      NP  =0
      NPARITY=0
      IF(NPAIR(I).EQ.0) THEN
      NUPS=NUPS+1
      NPATN(NUPS,IJK)=NASTR(I)
      NPARITY=NPARITY+I-NUPS
      END IF
      IF(NPAIR(J).EQ.0) THEN
      NUPS=NUPS+1
      NPATN(NUPS,IJK)=NASTR(J)
      NPARITY=NPARITY+J-NUPS
      END IF
      IF(NPAIR(I).GT.0.AND.NPAIR(I).NE.J) THEN
      NUPB=NUPB+1
      NPATN(NUPS+NUPB,IJK)=NASTR(I)
      NPATN(NK+NS-NUPS+NUPB,IJK)=NASTR(NPAIR(I))
      NWK(NPAIR(I))=0
      END IF
      IF(NPAIR(J).GT.0.AND.NPAIR(J).NE.I) THEN
      NUPB=NUPB+1
      NPATN(NUPS+NUPB,IJK)=NASTR(J)
      NPATN(NK+NS-NUPS+NUPB,IJK)=NASTR(NPAIR(J))
      NWK(NPAIR(J))=0
      END IF
C
C     COLLECT UPAIRED SPINS FOR THE (N-NK) SET
C
      N2S=0
      DO M=N-NS+1,N
      IF(NWK(M).NE.0) THEN
      N2S=N2S+1
      NPATN(NK+N2S,IJK)=NASTR(M)
      NWK(M)=0
      END IF
      END DO
C
C     COLLECT ORBITAL PAIRS
C
      IF(NPAIR(I).EQ.J) THEN
      NPATN(NUPS+NUPB+NP+1,IJK)=NASTR(I)
      NPATN(NUPS+NUPB+NP+2,IJK)=NASTR(J)
      NP=NP+2
      END IF
      NSTART=2+(NS-NUPS)+NUPB
      DO M=1,N
        IF(NWK(M).NE.0) THEN
        NSTART=NSTART+1
        NPATN(NSTART,IJK)=NASTR(M)
        END IF
      END DO
C
C     SET TYPES AND PARITY
C
      NPATN(N+1,IJK)=NS-NUPS
      NPATN(N+2,IJK)=NUPB
      NPATN(N+3,IJK)=NPARITY
      NPATN(N+4,IJK)=NSTRUC
      NPATN(N+5,IJK)=2
C
C     REORDER TO STANDARD FORM
C
      CALL STDFOM(NPATN(1,IJK),N,2,NS)
      END DO
      END DO
      RETURN
      END
      SUBROUTINE GSYM03(N,NS,NK,NASTR,NPATN,NSTRUC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPAIR(100),NWK(100),NASTR(N),NPATN(N+5,*)
C
C     DATA STRUCTURE
C
C          NPATN(N+1): NUMBER OF UNPAIRED SPINS IN THE (N-NK) SUBSET
C          NPATN(N+2): NUMBER OF UNPAIRED ORBITALS IN THE (N-NK) SUBSET
C          NPATN(N+3): PARITY DUE TO THE REORDER OF THE UNPAIRED SPINS
C          NPATN(N+4): # OF VB STRUCTURE THAT THE <B| OF THE ALGEBRANTS
C
      DO I=N-NS+1,N
      NPAIR(I)=0
      END DO
      DO J=1,(N-NS)/2
      J1=J+J-1
      J2=J1+1
      NPAIR(J1)=J2
      NPAIR(J2)=J1
      END DO
      IJK=0
      DO I=1,N-2
      DO J=I+1,N-1
      DO K=J+1,N
      IJK=IJK+1
        DO M=1,N
        NWK(M)=NASTR(M)
        END DO
      NWK(I)=0
      NWK(J)=0
      NWK(K)=0
C
C     COLLECT UPAIRED SPINS AND ORBITALS
C
      NUPS=0
      NUPB=0
      NP  =0
      NPARITY=0
      IF(NPAIR(I).EQ.0) THEN
      NUPS=NUPS+1
      NPATN(NUPS,IJK)=NASTR(I)
      NPARITY=NPARITY+I-NUPS
      END IF
      IF(NPAIR(J).EQ.0) THEN
      NUPS=NUPS+1
      NPATN(NUPS,IJK)=NASTR(J)
      NPARITY=NPARITY+J-NUPS
      END IF
      IF(NPAIR(K).EQ.0) THEN
      NUPS=NUPS+1
      NPATN(NUPS,IJK)=NASTR(K)
      NPARITY=NPARITY+K-NUPS
      END IF
      IF(NPAIR(I).GT.0.AND.NPAIR(I).NE.J) THEN
      NUPB=NUPB+1
      NPATN(NUPS+NUPB,IJK)=NASTR(I)
      NPATN(NK+NS-NUPS+NUPB,IJK)=NASTR(NPAIR(I))
      NWK(NPAIR(I))=0
      END IF
      IF(NPAIR(J).GT.0.AND.NPAIR(J).NE.I.AND.NPAIR(J).NE.K) THEN
      NUPB=NUPB+1
      NPATN(NUPS+NUPB,IJK)=NASTR(J)
      NPATN(NK+NS-NUPS+NUPB,IJK)=NASTR(NPAIR(J))
      NWK(NPAIR(J))=0
      END IF
      IF(NPAIR(K).GT.0.AND.NPAIR(K).NE.J) THEN
      NUPB=NUPB+1
      NPATN(NUPS+NUPB,IJK)=NASTR(K)
      NPATN(NK+NS-NUPS+NUPB,IJK)=NASTR(NPAIR(K))
      NWK(NPAIR(K))=0
      END IF
C
C     COLLECT UPAIRED SPINS FOR THE (N-NK) SET
C
      N3S=0
      DO M=N-NS+1,N
      IF(NWK(M).NE.0) THEN
      N3S=N3S+1
      NPATN(NK+N3S,IJK)=NASTR(M)
      NWK(M)=0
      END IF
      END DO
C
C     COLLECT ORBITAL PAIRS
C
      IF(NPAIR(I).EQ.J) THEN
      NPATN(NUPS+NUPB+NP+1,IJK)=NASTR(I)
      NPATN(NUPS+NUPB+NP+2,IJK)=NASTR(J)
      NP=NP+2
      END IF
      IF(NPAIR(J).EQ.K) THEN
      NPATN(NUPS+NUPB+NP+1,IJK)=NASTR(J)
      NPATN(NUPS+NUPB+NP+2,IJK)=NASTR(K)
      NP=NP+2
      END IF
      NSTART=3+(NS-NUPS)+NUPB
      DO M=1,N
        IF(NWK(M).NE.0) THEN
        NSTART=NSTART+1
        NPATN(NSTART,IJK)=NASTR(M)
        END IF
      END DO
C
C     SET TYPES AND PARITY
C
      NPATN(N+1,IJK)=NS-NUPS
      NPATN(N+2,IJK)=NUPB
      NPATN(N+3,IJK)=NPARITY
      NPATN(N+4,IJK)=NSTRUC
      NPATN(N+5,IJK)=3
C
C     REORDER TO STANDARD FORM
C
      CALL STDFOM(NPATN(1,IJK),N,3,NS)
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE GSYM04(N,NS,NK,NASTR,NPATN,NSTRUC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPAIR(100),NWK(100),NASTR(N),NPATN(N+5,*)
C
C     DATA STRUCTURE
C
C          NPATN(N+1): NUMBER OF UNPAIRED SPINS IN THE (N-4) SUBSET
C          NPATN(N+2): NUMBER OF UNPAIRED ORBITALS IN THE (N-4) SUBSET
C          NPATN(N+3): PARITY DUE TO THE REORDER OF THE UNPAIRED SPINS
C          NPATN(N+4): NOT USED YET
C
      DO I=N-NS+1,N
      NPAIR(I)=0
      END DO
      DO J=1,(N-NS)/2
      J1=J+J-1
      J2=J1+1
      NPAIR(J1)=J2
      NPAIR(J2)=J1
      END DO
      IJKL=0
      DO I=1,N-3
      DO J=I+1,N-2
      DO K=J+1,N-1
      DO L=K+1,N
      IJKL=IJKL+1
        DO M=1,N
        NWK(M)=NASTR(M)
        END DO
      NWK(I)=0
      NWK(J)=0
      NWK(K)=0
      NWK(L)=0
C
C     COLLECT UPAIRED SPINS AND ORBITALS
C
      NUPS=0
      NUPB=0
      NP  =0
      NPARITY=0
      IF(NPAIR(I).EQ.0) THEN
      NUPS=NUPS+1
      NPATN(NUPS,IJKL)=NASTR(I)
      NPARITY=NPARITY+I-NUPS
      END IF
      IF(NPAIR(J).EQ.0) THEN
      NUPS=NUPS+1
      NPATN(NUPS,IJKL)=NASTR(J)
      NPARITY=NPARITY+J-NUPS
      END IF
      IF(NPAIR(K).EQ.0) THEN
      NUPS=NUPS+1
      NPATN(NUPS,IJKL)=NASTR(K)
      NPARITY=NPARITY+K-NUPS
      END IF
      IF(NPAIR(L).EQ.0) THEN
      NUPS=NUPS+1
      NPATN(NUPS,IJKL)=NASTR(L)
      NPARITY=NPARITY+L-NUPS
      END IF
      IF(NPAIR(I).GT.0.AND.NPAIR(I).NE.J) THEN
      NUPB=NUPB+1
      NPATN(NUPS+NUPB,IJKL)=NASTR(I)
      NPATN(4+NS-NUPS+NUPB,IJKL)=NASTR(NPAIR(I))
      NWK(NPAIR(I))=0
      END IF
      IF(NPAIR(J).GT.0.AND.NPAIR(J).NE.I.AND.NPAIR(J).NE.K) THEN
      NUPB=NUPB+1
      NPATN(NUPS+NUPB,IJKL)=NASTR(J)
      NPATN(4+NS-NUPS+NUPB,IJKL)=NASTR(NPAIR(J))
      NWK(NPAIR(J))=0
      END IF
      IF(NPAIR(K).GT.0.AND.NPAIR(K).NE.J.AND.NPAIR(K).NE.L) THEN
      NUPB=NUPB+1
      NPATN(NUPS+NUPB,IJKL)=NASTR(K)
      NPATN(4+NS-NUPS+NUPB,IJKL)=NASTR(NPAIR(K))
      NWK(NPAIR(K))=0
      END IF
      IF(NPAIR(L).GT.0.AND.NPAIR(L).NE.K) THEN
      NUPB=NUPB+1
      NPATN(NUPS+NUPB,IJKL)=NASTR(L)
      NPATN(4+NS-NUPS+NUPB,IJKL)=NASTR(NPAIR(L))
      NWK(NPAIR(L))=0
      END IF
C
C     COLLECT UPAIRED SPINS FOR THE (N-4) SET
C
      N4S=0
      DO M=N-NS+1,N
      IF(NWK(M).NE.0) THEN
      N4S=N4S+1
      NPATN(NK+N4S,IJKL)=NASTR(M)
      NWK(M)=0
      END IF
      END DO
C
C     COLLECT ORBITAL PAIRS
C
      IF(NPAIR(I).EQ.J) THEN
      NPATN(NUPS+NUPB+NP+1,IJKL)=NASTR(I)
      NPATN(NUPS+NUPB+NP+2,IJKL)=NASTR(J)
      NP=NP+2
      END IF
      IF(NPAIR(J).EQ.K) THEN
      NPATN(NUPS+NUPB+NP+1,IJKL)=NASTR(J)
      NPATN(NUPS+NUPB+NP+2,IJKL)=NASTR(K)
      NP=NP+2
      END IF
      IF(NPAIR(K).EQ.L) THEN
      NPATN(NUPS+NUPB+NP+1,IJKL)=NASTR(K)
      NPATN(NUPS+NUPB+NP+2,IJKL)=NASTR(L)
      NP=NP+2
      END IF
      NSTART=4+(NS-NUPS)+NUPB
      DO M=1,N
        IF(NWK(M).NE.0) THEN
        NSTART=NSTART+1
        NPATN(NSTART,IJKL)=NASTR(M)
        END IF
      END DO
C
C     SET TYPES AND PARITY
C
      NPATN(N+1,IJKL)=NS-NUPS
      NPATN(N+2,IJKL)=NUPB
      NPATN(N+3,IJKL)=NPARITY
      NPATN(N+4,IJKL)=NSTRUC
      NPATN(N+5,IJKL)=4
C
C     REORDER TO STANDARD FORM
C
      CALL STDFOM(NPATN(1,IJKL),N,4,NS)
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE STDFOM(NPATN,N,NK,NS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NPATN(*)
      NKS    =NPATN(N+1)
      NKB    =NPATN(N+2)
      NPARITY=NPATN(N+3)
C
C     SORT UNPAIRED SPINS IN THE (N-NK) SUBSET
C
      DO I=1,NKS-1
      MINX=NPATN(NK+I)
      MINP=NK+I
        DO J=I+1,NKS
        IF(MINX.GT.NPATN(NK+J)) THEN
        MINX=NPATN(NK+J)
        MINP=NK+J
        END IF
        END DO
      IF(MINP.NE.NK+I) THEN
      NPARITY=NPARITY+1
      NPATN(MINP)=NPATN(NK+I)
      NPATN(NK+I)=MINX
      END IF
      END DO
C
C     SORT UNPAIRED ORBITALS IN THE (N-NK) SUBSET
C
      DO I=1,NKB-1
      MINX=NPATN(NK+NKS+I)
      MINP=NK+NKS+I
        DO J=I+1,NKB
        IF(MINX.GT.NPATN(NK+NKS+J)) THEN
        MINX=NPATN(NK+NKS+J)
        MINP=NK+NKS+J
        END IF
        END DO
      IF(MINP.NE.NK+NKS+I) THEN
      NPATN(MINP)=NPATN(NK+NKS+I)
      NPATN(NK+NKS+I)=MINX
C
C     INTERCHANGE THE CORRESPONDING UNPAIRED ORBITALS IN THE NK SUBSET
C
      MTEMP=NPATN(NS-NKS+I)
      NPATN(NS-NKS+I)=NPATN(MINP+NS-NK-2*NKS)
      NPATN(MINP+NS-NK-2*NKS)=MTEMP
      END IF
      END DO
C
C     SORT PAIRS IN THE (N-NK) SUBSET
C
      NSTART=NK+NKS+NKB
      DO I=1,(N-NSTART)/2
      I1=NSTART+I+I-1
      I2=I1+1
      IF(NPATN(I1).GT.NPATN(I2)) THEN
      NTEMP=NPATN(I2)
      NPATN(I2)=NPATN(I1)
      NPATN(I1)=NTEMP
      END IF
      END DO
      DO I=1,(N-NSTART)/2-1
      I1=NSTART+I+I-1
      MINX=NPATN(I1)
      MINP=I1
        DO J=I+1,(N-NSTART)/2
        J1=NSTART+J+J-1
        IF(MINX.GT.NPATN(J1)) THEN
        MINX=NPATN(J1)
        MINP=J1
        END IF
        END DO
        IF(MINP.NE.I1) THEN
        NTEMP=NPATN(MINP)
        NPATN(MINP)=NPATN(I1)
        NPATN(I1)=NTEMP
        NTEMP=NPATN(MINP+1)
        NPATN(MINP+1)=NPATN(I1+1)
        NPATN(I1+1)=NTEMP
        END IF
      END DO
C
      NPATN(N+3)=NPARITY
      RETURN
      END
      SUBROUTINE YANGHUI()
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /YANG/IYANG(200,20)
      DO I=1,20
      IYANG(1,I)=1
      END DO
      DO J=1,200
      IYANG(J,1)=1
      END DO
      DO I=2,20
      DO J=2,200
        IYANG(J,I)=IYANG(J-1,I)+IYANG(J,I-1)
      END DO
      END DO
      END
      FUNCTION NCOMBI(N,M)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /YANG/IYANG(200,20)
      I=N-M+1
      J=M+1
      IF(I.GT.200.OR.J.GT.20) THEN
      WRITE(IOUTVB,*)'OUT OF RANG IN NCOMBI!'
      CALL ABRTVB
      END IF
      NCOMBI=IYANG(I,J)
      RETURN
      END
      SUBROUTINE MAPADD(IOMAP,MAP,ITYPE,NADSTA,MSIZE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /LTAB/NTYPE,MAPINCORE,MEL,MSP,LOOKTB(6,100),NGRECD(4,100)
      DIMENSION MAP(3,*)
      IF(MAPINCORE.EQ.1) THEN
      NADSTA=NGRECD(4,ITYPE)+1
      RETURN
      ELSE
C
C     READ HEADER, AND CHECK ERRORS
C
      REWIND(IOMAP)
C     READ(IOMAP)NX,NSX,NSTRX
C     NX,NSX,NSTRX are not used so replace with variables that are overwritten
      READ(IOMAP) K,I,J
      DO I=1,ITYPE-1
      READ(IOMAP)
      READ(IOMAP)
      END DO
      READ(IOMAP)(NGRECD(K,ITYPE),K=1,4),(LOOKTB(K,ITYPE),K=1,6)
        IF(NGRECD(3,ITYPE).GT.MSIZE) THEN
        WRITE(IOUTVB,*)'MSIZE IS TOO SMALL, STOP'
        END IF
      READ(IOMAP)((MAP(J,I),J=1,3),I=1,NGRECD(3,ITYPE))
      NADSTA=1
      END IF
      RETURN
      END
      SUBROUTINE LOADMAP(IOMAP,N,NSPIN,NTYPE,MAPINCORE,MVBM,
     &  LOOKTB,NGRECD,MAP,MSIZE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION LOOKTB(6,100),NGRECD(4,100),MAP(3,*)
      REWIND(IOMAP)
      NTYPE=0
      NTREC=0
      MAPINCORE=1
      MAXAG = 0
C
C     READ HEADER, AND CHECK ERRORS
C
C  TMAP READ(IOMAP,*)NX,NSX,NSTRX,MVBM
C  BMAP READ(IOMAP)NX,NSX,NSTRX,MVBM
C  NSTRX is not used so replace with K which is overwritten later.
CTMAP READ(IOMAP,*)NX,NSX,K,MVBM
CBMAP READ(IOMAP)NX,NSX,K,MVBM
      IF(NX.NE.N.OR.NSX.NE.NSPIN) THEN
      WRITE(IOUTVB,*)'LOADMAP READ WRONG FILE, STOP'
      CALL ABRTVB
      END IF
 100  NT1=NTYPE+1
CTMAP READ(IOMAP,*)(NGRECD(K,NT1),K=1,4),(LOOKTB(K,NT1),K=1,6)
CBMAP READ(IOMAP)(NGRECD(K,NT1),K=1,4),(LOOKTB(K,NT1),K=1,6)
      IF(MAXAG.LT.NGRECD(1,NT1)+NGRECD(2,NT1)) THEN
         MAXAG = NGRECD(1,NT1)+NGRECD(2,NT1)
      END IF
      IF(NTYPE.GT.0) THEN
      NTEMP = NTREC + NGRECD(3,NTYPE)
      IF(NTREC+NGRECD(3,NTYPE).GT.MSIZE) THEN
      WRITE(IOUTVB,*)"NTEMP, MSIZE =",NTEMP,MSIZE
      WRITE(IOUTVB,*)'MAP_IN_CORE FAILED,SET MAP_IN_CCORE=FALSE'
      MAPINCORE=0
      END IF
      END IF
      IF(NGRECD(1,NT1).LE.0) RETURN
      NTYPE=NTYPE+1
      IF(MAPINCORE.EQ.1) THEN
CTMAP READ(IOMAP,*)((MAP(J,I+NTREC),J=1,3),I=1,NGRECD(3,NTYPE))
CBMAP READ(IOMAP)((MAP(J,I+NTREC),J=1,3),I=1,NGRECD(3,NTYPE))
      NGRECD(4,NTYPE)=NTREC
      NTREC=NTREC+NGRECD(3,NTYPE)
      ELSE
CTMAP READ(IOMAP,*)
CBMAP READ(IOMAP)
      END IF
      GOTO 100
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Laplace expansion, the core of algebrant algorithm.
C
C     History:
C               First Version created in May 1998
C               Completely revised in December 1999, so that the expression
C               is extremely simple!
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     SUBROUTINE LAPLACE(AG1,AG2,NAGH,NREC,IRANK,MAP,S)
      SUBROUTINE LAPLACE(AG1,AG2,NAGH,IRANK,MAP,S)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /INVERS/OVM(129)
      DIMENSION AG1(*),AG2(*),MAP(3,*),S(*)
      IJ=0
      DO I=1,NAGH
      AG2(I)=0.0D0
        DO J=1,IRANK
        IJ=IJ+1
        AG2(I)=AG2(I)+S(MAP(1,IJ))*OVM(65+MAP(2,IJ))*AG1(MAP(3,IJ))
        END DO
      END DO
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     VB CALCULATIONS USING ALGEBRANTS
C
C     N         NUMBER OF ELECTRONS IN VB WAVE FUNCTIONS
C     NS        NUMBER OF UNPAIRED PARALLEL SPINS (I.E. S=NS/2)
C     NORB      NUMBER OF ORBITALS FOR THE CONSTRUCTION OF VB WAVE FUNCTION
C     NSTR      NUMBER OF VB STRUCTURES
C     NASTR     ARRAY HOLDS SYMBOLIC VB STRUCTURES
C               EACH VB STRUCTURE IS REPRESENTED BY A SET OF N ORBITALS
C               (INTEGERS), UNPAIRED ORBITALS COME FIRST, FOLLOWED BY ORBITAL
C               PAIRS
C     CSTR      COEFFICIENTS OF VB STRUCTURES
C
C     SS,HH,GG  OVERLAP, ONE- AND TWO-ELECTRON INTEGRALS IN VB ORBITAL
C               BASIS
C
C     DM1       ON RETURN:
C               HOLDS THE ONE-ELECTRON DENSITY MATRIX OF THE WAVE FUNCTION
C               WHICH IS A LINEAR COMBINATION OF NSTR VB STRUCTURES WITH
C               COEFFICIENTS CSTR(i).
C               D1: LOWER TRANGULAR STORAGE
C
C     DM2       ON RETURN:
C               HOLDS THE TWO-ELECTRON DENSITY MATRIX OF THE WAVE FUNCTION
C               WHICH IS A LINEAR COMBINATION OF NSTR VB STRUCTURES WITH
C               COEFFICIENTS CSTR(i).
C               D2: M*M*(M*M+1)/2, i.e. (ij|kl), i>=<j, ij>=kl.
C               (Symmetry factor weighted)
C
C     NADD(1)   NADD for SS
C     NADD(2)   NADD for HH
C     NADD(3)   NADD for GG
C     NADD(4)   NADD for Contribution to one-electron density matrix
C     NADD(5)   NADD for Density D2
C     NADD(6)   NADD for Work field for subalgebrants
C     NADD(7)   Number of NBND records for 1-e contribution of Hessan
C     NADD(8)   Number of NBND records for 2-e contribution of Hessan
C     NADD(10)  MAX. Work field for subalgebrants
C     NREC(I)   Number of record for algebrants of the i-th order
C     NALGE(I)  Number of algebrants of the i-th order
C     N1E       Number of record for 1-electron Hamiltonian
C     N2E 	Number of records for 2-electorn Hamiltonain
C     MAP	Master map of successive Laplace expansion of algebrants
C
C     Revision history
C     July 12, 2003: Fixed a multi-VB bug with S=1/2
C     ---JLI---
C
      SUBROUTINE VBMATR(N,NS,NORB,NSTR,NASTR,CSTR,SIJ,HIJ,GIJKL,
     &  SRVB,HRVB,DM1,DM2,SS,AG,E0,MSIZE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     PARAMETER (MAXNODE=150000,MAXNB2=100000)
      PARAMETER (MAXNODE=150000)
C
C     NOTE THAT MM IS SET IN 4 SUBROUTINES AND IT MUST BE SET
C     TO THE SAME VALUE.
C
CGMS  PARAMETER (MM=500000)
C     SUFFICIENT FOR MAP FILES IN GAMESS RELEASE.
C     IF YOU USE LARGER MAP FILES FROM THE VB2000 RELEASE,
C     YOU MUST INCREASE MM.
C
C000  PARAMETER (MM=2500000)
CSMI  PARAMETER (MM=2500000)
CGAU  PARAMETER (MM=2500000)
C     SUITABLE FOR 14 ELECTRONS WITH A SINGLET MOLECULE.
C
C     IF YOU ARE GOING TO USE MORE THAN 14 ELECTRON MAP FILES,
C     YOU MUST INCREASE MM. IF THE MULTIPCITY IS GREATER THAN 1,
C     MAY ALSO NEED TO INCREASE MM. 
C     A WARNING WILL BE GIVEN IF MM IS NOT LARGE ENOUGH.
C
C     FOR UP TO 12 ELECTRONS IN SINGLET USE - PARAMETER (MM=500000)
C     FOR UP TO 14 ELECTRONS IN SINGLET USE - PARAMETER (MM=2500000)
C     FOR UP TO 16 ELECTRONS IN SINGLET USE - PARAMETER (MM=12500000)
C     FOR UP TO 18 ELECTRONS IN SINGLET USE - PARAMETER (MM=62500000)
C
C     LOGICAL MAPEXISTS
      CHARACTER*80 MAPNNS,VBPATH,MAPFILE
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     DIMENSION AG(*),LPW(10),INDXW(100),KTNODE(5,MAXNODE)
      DIMENSION AG(*),KTNODE(5,MAXNODE)
      DIMENSION SIJ(*),HIJ(*),GIJKL(*),CSTR(*)
C     DIMENSION IJMAP(2,MAXNB2),DM1(*),DM2(*)
      DIMENSION DM1(*),DM2(*)
C     DIMENSION NASTR(N,*),MASTR(100),SRVB(*),HRVB(*)
      DIMENSION NASTR(N,*),SRVB(*),HRVB(*)
      DIMENSION SS(N,NORB)
      COMMON /LTAB/NTYPE,MAPINCORE,MEL,MSP,LOOKTB(6,100),NGRECD(4,100)
C     COMMON /MAP/MAP(3,MM),NALG(100),NRE(100),NAG1(100),NREC1(100),MVBM
      COMMON /MAP/MAP(3,MM),NALG(100),NRE(100),NAG1(100),MVBM
      COMMON /AGCODE/NPK1,NPK2,NPK3
      COMMON /INVERS/OVM(129)
      COMMON /IAA/IAA(100000)
      PARAMETER (MAXBFN=726)
      PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA,MAXGRP=99)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(MAXGRP),MSPIN(MAXGRP),MNORBIT(MAXGRP),
     &MLORBIT(MAXGRP),MWIN(MAXGRP),MSTR(MAXGRP),METHOD(MAXGRP),
     &IBASIS(MAXEXT),NOCC(MAXEXT),NOBIAS,NEPS,NVIR,NOTROT(5000),
     &LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(MAXGRP)
C
C     GET IO UNITS
C
      CALL GETIOUNIT('IOMAP   ',IOMAP)
      CALL GETVBPATH(VBPATH)
      MAPNNS='MAP/MAP'
      WRITE(MAPNNS(8:9),'(I2.2)') N
      WRITE(MAPNNS(10:11),'(I2.2)') NS
      K=11
CTMAP MAPNNS(12:12)='t'
CTMAP K=12
C     Add VBPATH
      CALL PATHST(MAPFILE,VBPATH,'/               ',MAPNNS,K)
      WRITE(IOUTVB,102) MAPFILE
 102  FORMAT(/,' MAP FILE IS: ',A80)
      IF(MEL.NE.N.OR.MSP.NE.NS) THEN
      IF (IPNT.GT.1) CLOSE(IOMAP)
CBMAP OPEN(IOMAP,FILE=MAPFILE,STATUS='OLD',FORM='UNFORMATTED',
CBMAP&     ERR=1112)
CTMAP OPEN(IOMAP,FILE=MAPFILE,STATUS='OLD',FORM='FORMATTED',
CTMAP&     ERR=1112)
      GOTO 1111
1112  CONTINUE
      VBPATH = 'C:/VB2000NET/VB2000'
      CALL PATHST(MAPFILE,VBPATH,'/               ',MAPNNS,K)
CBMAP OPEN(IOMAP,FILE=MAPFILE,STATUS='OLD',FORM='UNFORMATTED',
CBMAP&     ERR=1113)
CTMAP OPEN(IOMAP,FILE=MAPFILE,STATUS='OLD',FORM='FORMATTED',
CTMAP&     ERR=1113)
      GOTO 1111
1113  CONTINUE
      WRITE(IOUTVB,*)"NO MAP FILE IS FOUND. THERE ARE TWO POSSIBILITIES"
      WRITE(IOUTVB,*)"1) THE JOB IS NOT RUNNING IN VB2000 DIRECTORY AND"
      WRITE(IOUTVB,*)"   VB2000PATH VARIABLE IS NOT SET "
      WRITE(IOUTVB,*)"2) THE MAP FILE IS NOT AVAILABLE FOR THIS RELEASE"
      WRITE(IOUTVB,*)"   PLEASE CONTACT US AT VB@SCINETEC.COM FOR HELP!"
      CALL ABRTVB
1111  CONTINUE

      CALL LOADMAP(IOMAP,N,NS,NTYPE,MAPINCORE,MVBM,
     &             LOOKTB,NGRECD,MAP,MM)
      MSP=NS
      MEL=N
      END IF
      DO IJ=1,NSTR*(NSTR+1)/2
      SRVB(IJ)=0.0D0
      HRVB(IJ)=0.0D0
      END DO
      NORB2=NORB*(NORB+1)/2
C
C     RESET
C
      DO I=1,NORB2
      DM1(I)=0.0D0
      END DO
      DO I=1,NORB2*(NORB2+1)/2
      DM2(I)=0.0D0
      END DO
C1000 FORMAT(10F8.5)
      IDERANK=0
      DO 100 ISTR=1,NSTR
      ISTR2=ISTR*(ISTR-1)/2
        DO J=1,NORB
        DO K=1,N
           KK = NASTR(K,ISTR)
           IF(KK.GT.J) THEN
              KKJ = IAA(KK)+ J
           ELSE
              KKJ = IAA(J) + KK
           ENDIF
           SS(K,J)=SIJ(KKJ)
        END DO
        END DO
      IF(NS.EQ.0) THEN
      CALL GSYMBO(N,NS,NASTR,ISTR,KTNODE,NODES,IDERANK,MAXNODE)
      DO 105 KT=1,NODES
      IABCD=KTNODE(1,KT)
      ITYPE=KTNODE(2,KT)
      IDTHIS=IABS(KTNODE(3,KT))
      IJVB=ISTR2+IDTHIS
      NPARITY=1
      IF(KTNODE(3,KT).LT.0) NPARITY=-1
C     IDCHID=KTNODE(4,KT)
      IDEN  =KTNODE(5,KT)
      IRANKL=LOOKTB(1,ITYPE)
      IRANKH=LOOKTB(4,ITYPE)
      IF(IDEN.NE.1) THEN
        NAGH=NGRECD(1,ITYPE)
        NAGL=NGRECD(2,ITYPE)
C       NREC=NGRECD(3,ITYPE)
        IF(IRANKL.EQ.0) THEN
        AG(1)=1.0D0
        NAG1(1)=1
        END IF
        NAG1(IRANKH+1)=NAG1(IRANKL+1)+NAGL
        NADDL=NAG1(IRANKL+1)
        NADDH=NAG1(IRANKH+1)
        IF(NADDH+NAGH.GT.MSIZE) THEN
        WRITE(IOUTVB,*)'ARRAY AG OUT OF BOUNDARY, STOP'
        WRITE(IOUTVB,*)'TOTAL, AVAILABLE=',NADDH+NAGH,MSIZE
        CALL ABRTVB
        END IF
        IA=IABCD
        CALL MAPADD(IOMAP,MAP,ITYPE,NADSTA,MM)
C
C       BE CAREFUL, <B| |K> are interchanged for convenience in LAPLACE
C       So must the last step
C
C       CALL LAPLACE(AG(NADDL),AG(NADDH),NAGH,NREC,IRANKH,
        CALL LAPLACE(AG(NADDL),AG(NADDH),NAGH,IRANKH,
     &               MAP(1,NADSTA),SS(1,IA))
          DO LX=1,NAGH
          AG(NADDH-1+LX)=AG(NADDH-1+LX)*NPARITY
          END DO
          NAG1(IRANKH+2)=NAG1(IRANKH+1)+NAGH
        ELSE
        NAGH=NGRECD(1,ITYPE)
        NAGL=NGRECD(2,ITYPE)
C       NREC=NGRECD(3,ITYPE)
        IF(IRANKL.EQ.0) THEN
        AG(1)=1.0D0
        NAG1(1)=1
        END IF
        NADD=NAG1(IRANKL+1)-1
C       ISQ1=(ISTR-1)*NORB2
C       JSQ1=(IDTHIS-1)*NORB2
C       ISQ2=(ISTR-1)*NORB2*(NORB2+1)/2
C       JSQ2=(IDTHIS-1)*NORB2*(NORB2+1)/2
        CPARITY=CSTR(ISTR)*CSTR(IDTHIS)*NPARITY
        CPA0=CSTR(ISTR)*NPARITY
        CPB0=CSTR(IDTHIS)*NPARITY
          IF(ISTR.NE.IDTHIS) THEN
          CPARITY=CPARITY+CPARITY
          CPA0=CPA0+CPA0
          CPB0=CPB0+CPB0
          END IF
        IA=IABCD
C       IF(IRANKL.EQ.0) AG(1)=1.0D0
        LCRANK=IRANKH-IRANKL
C       SUM=0.0D0
        IA=0
        IB=0
        IC=0
        ID=0
           IF(LCRANK.GE.4) THEN
           ID=IABCD/NPK3
           IABCD=IABCD-ID*NPK3
           END IF
           IF(LCRANK.GE.3) THEN
           IC=IABCD/NPK2
           IABCD=IABCD-IC*NPK2
           END IF
           IF(LCRANK.GE.2) THEN
           IB=IABCD/NPK1
           END IF
           IA=IABCD-IB*NPK1
        CALL MAPADD(IOMAP,MAP,ITYPE,NADSTA,MM)
        LX=NADSTA-1
        DO 110 IW=1,N
        I=NASTR(IW,ISTR)
C        IAI=INDXIJ(I,IA)
        IF(I.GT.IA) THEN
          IAI = IAA(I) + IA
        ELSE
          IAI = IAA(IA) + I
        ENDIF
        IF(LCRANK.EQ.1) THEN
        LX=LX+1
          DVALUE = OVM(65+MAP(2,LX))
          D11PARITY=DVALUE*CPARITY
C         CPA=CPA0*DVALUE
C         CPB=CPB0*DVALUE
          D11PAR=DVALUE*NPARITY
          DXAG=D11PARITY*AG(NADD+MAP(3,LX))
C         CPAG=CPA*AG(NADD+MAP(3,LX))
C         CPBG=CPB*AG(NADD+MAP(3,LX))
C   BUILD 1SD
          DM1(IAI)=DM1(IAI) + DXAG
C
          SRVB(IJVB)=SRVB(IJVB)+D11PAR*AG(NADD+MAP(3,LX))*SIJ(IAI)
          HRVB(IJVB)=HRVB(IJVB)+D11PAR*AG(NADD+MAP(3,LX))*HIJ(IAI)
        ELSE
          DO 120 JW=1,N
          IF(JW.EQ.IW) GOTO 120
          J=NASTR(JW,ISTR)
C          IBJ=INDXIJ(J,IB)
        IF(J.GT.IB) THEN
          IBJ = IAA(J) + IB
        ELSE
          IBJ = IAA(IB) + J
        ENDIF
          IF(LCRANK.EQ.2) THEN
          LX=LX+1
          DVALUE = OVM(65+MAP(2,LX))
          D11PARITY=DVALUE*CPARITY
C         CPA=CPA0*DVALUE
C         CPB=CPB0*DVALUE
          D11PAR=DVALUE*NPARITY
          DXAG=D11PARITY*AG(NADD+MAP(3,LX))
C         CPAG=CPA*AG(NADD+MAP(3,LX))
C         CPBG=CPB*AG(NADD+MAP(3,LX))
C   BUILD 1HD,2SD
C          IIAJIB=INDXIJ(IAI,IBJ)
        IF(IAI.GT.IBJ) THEN
          IIAJIB = IAA(IAI) + IBJ
        ELSE
          IIAJIB = IAA(IBJ) + IAI
        ENDIF
C   2SD
          DM2(IIAJIB) = DM2(IIAJIB) + DXAG
C
          HRVB(IJVB)=HRVB(IJVB)+D11PAR*AG(NADD+MAP(3,LX))*
     &         GIJKL(IIAJIB)
          ELSE
          WRITE(IOUTVB,*)'WRONG DATA, STOP'
          CALL ABRTVB
          END IF
 120  CONTINUE
      END IF
 110  CONTINUE
      END IF
 105  CONTINUE
      ELSE
      DO 107 JSTR=1, ISTR
      CALL GSYMBO(N,NS,NASTR(1,JSTR),1,KTNODE,NODES,IDERANK,MAXNODE)
      DO 107 KT=1,NODES
      IABCD=KTNODE(1,KT)
      ITYPE=KTNODE(2,KT)
      IDTHIS=JSTR
      IJVB=ISTR2+IDTHIS
      NPARITY=1
      IF(KTNODE(3,KT).LT.0) NPARITY=-1
C     IDCHID=KTNODE(4,KT)
      IDEN  =KTNODE(5,KT)
      IRANKL=LOOKTB(1,ITYPE)
      IRANKH=LOOKTB(4,ITYPE)
      IF(IDEN.NE.1) THEN
        NAGH=NGRECD(1,ITYPE)
        NAGL=NGRECD(2,ITYPE)
C       NREC=NGRECD(3,ITYPE)
        IF(IRANKL.EQ.0) THEN
        AG(1)=1.0D0
        NAG1(1)=1
        END IF
        NAG1(IRANKH+1)=NAG1(IRANKL+1)+NAGL
        NADDL=NAG1(IRANKL+1)
        NADDH=NAG1(IRANKH+1)
        IF(NADDH+NAGH.GT.MSIZE) THEN
        WRITE(IOUTVB,*)'ARRAY AG OUT OF BOUNDARY, STOP'
        WRITE(IOUTVB,*)'TOTAL, AVAILABLE=',NADDH+NAGH,MSIZE
        CALL ABRTVB
        END IF
        IA=IABCD
        CALL MAPADD(IOMAP,MAP,ITYPE,NADSTA,MM)
C
C       BE CAREFUL, <B| |K> are interchanged for convenience in LAPLACE
C       So must the last step
C
C       CALL LAPLACE(AG(NADDL),AG(NADDH),NAGH,NREC,IRANKH,
        CALL LAPLACE(AG(NADDL),AG(NADDH),NAGH,IRANKH,
     &               MAP(1,NADSTA),SS(1,IA))
          DO LX=1,NAGH
          AG(NADDH-1+LX)=AG(NADDH-1+LX)*NPARITY
          END DO
          NAG1(IRANKH+2)=NAG1(IRANKH+1)+NAGH
        ELSE
        NAGH=NGRECD(1,ITYPE)
        NAGL=NGRECD(2,ITYPE)
C       NREC=NGRECD(3,ITYPE)
        IF(IRANKL.EQ.0) THEN
        AG(1)=1.0D0
        NAG1(1)=1
        END IF
        NADD=NAG1(IRANKL+1)-1
C       ISQ1=(ISTR-1)*NORB2
C       JSQ1=(IDTHIS-1)*NORB2
C       ISQ2=(ISTR-1)*NORB2*(NORB2+1)/2
C       JSQ2=(IDTHIS-1)*NORB2*(NORB2+1)/2
        CPARITY=CSTR(ISTR)*CSTR(IDTHIS)*NPARITY
        CPA0=CSTR(ISTR)*NPARITY
        CPB0=CSTR(IDTHIS)*NPARITY
          IF(ISTR.NE.IDTHIS) THEN
          CPARITY=CPARITY+CPARITY
          CPA0=CPA0+CPA0
          CPB0=CPB0+CPB0
          END IF
        IA=IABCD
C       IF(IRANKL.EQ.0) AG(1)=1.0D0
        LCRANK=IRANKH-IRANKL
C       SUM=0.0D0
        IA=0
        IB=0
        IC=0
        ID=0
           IF(LCRANK.GE.4) THEN
           ID=IABCD/NPK3
           IABCD=IABCD-ID*NPK3
           END IF
           IF(LCRANK.GE.3) THEN
           IC=IABCD/NPK2
           IABCD=IABCD-IC*NPK2
           END IF
           IF(LCRANK.GE.2) THEN
           IB=IABCD/NPK1
           END IF
           IA=IABCD-IB*NPK1
        CALL MAPADD(IOMAP,MAP,ITYPE,NADSTA,MM)
        LX=NADSTA-1
        DO 115 IW=1,N
        I=NASTR(IW,ISTR)
C        IAI=INDXIJ(I,IA)
        IF(I.GT.IA) THEN
          IAI = IAA(I) + IA
        ELSE
          IAI = IAA(IA) + I
        ENDIF
        IF(LCRANK.EQ.1) THEN
        LX=LX+1
          DVALUE = OVM(65+MAP(2,LX))
          D11PARITY=DVALUE*CPARITY
C         CPA=CPA0*DVALUE
C         CPB=CPB0*DVALUE
          D11PAR=DVALUE*NPARITY
          DXAG=D11PARITY*AG(NADD+MAP(3,LX))
C         CPAG=CPA*AG(NADD+MAP(3,LX))
C         CPBG=CPB*AG(NADD+MAP(3,LX))
C   BUILD 1SD
          DM1(IAI)=DM1(IAI) + DXAG
C
          SRVB(IJVB)=SRVB(IJVB)+D11PAR*AG(NADD+MAP(3,LX))*SIJ(IAI)
          HRVB(IJVB)=HRVB(IJVB)+D11PAR*AG(NADD+MAP(3,LX))*HIJ(IAI)
        ELSE
          DO 125 JW=1,N
          IF(JW.EQ.IW) GOTO 125
          J=NASTR(JW,ISTR)
C          IBJ=INDXIJ(J,IB)
        IF(J.GT.IB) THEN
          IBJ = IAA(J) + IB
        ELSE
          IBJ = IAA(IB) + J
        ENDIF
          IF(LCRANK.EQ.2) THEN
          LX=LX+1
          DVALUE = OVM(65+MAP(2,LX))
          D11PARITY=DVALUE*CPARITY
C         CPA=CPA0*DVALUE
C         CPB=CPB0*DVALUE
          D11PAR=DVALUE*NPARITY
          DXAG=D11PARITY*AG(NADD+MAP(3,LX))
C         CPAG=CPA*AG(NADD+MAP(3,LX))
C         CPBG=CPB*AG(NADD+MAP(3,LX))
C   BUILD 1HD,2SD
C          IIAJIB=INDXIJ(IAI,IBJ)
        IF(IAI.GT.IBJ) THEN
          IIAJIB = IAA(IAI) + IBJ
        ELSE
          IIAJIB = IAA(IBJ) + IAI
        ENDIF
C   2SD
          DM2(IIAJIB) = DM2(IIAJIB) + DXAG
C
          HRVB(IJVB)=HRVB(IJVB)+D11PAR*AG(NADD+MAP(3,LX))*
     &         GIJKL(IIAJIB)
          ELSE
          WRITE(IOUTVB,*)'WRONG DATA, STOP'
          CALL ABRTVB
          END IF
 125  CONTINUE
      END IF
 115  CONTINUE
      END IF
 107  CONTINUE
      END IF
 100  CONTINUE
C150  CONTINUE
C250  CONTINUE
      DO IJ=1,NSTR*(NSTR+1)/2
      SRVB(IJ)=SRVB(IJ)/N
      END DO
      VBHH0=0.0D0
      VBGG0=0.0D0
      VBSSN=0.0D0
      DO I=1,NORB2
      VBHH0=VBHH0+DM1(I)*HIJ(I)
      VBSSN=VBSSN+DM1(I)*SIJ(I)
      END DO
      DO I=1,NORB2*(NORB2+1)/2
      VBGG0=VBGG0+DM2(I)*GIJKL(I)
      END DO
      S0=VBSSN/N
      E0=(VBHH0+VBGG0)/S0
C     TIME1=XCLOCK()
C2000 CONTINUE
C
C     DE-FACTORIZE THE NON-DIAGONAL 1D DENSITY MATRIX ELEMENTS
C
      DO I=1,NORB
      II=I*(I-1)/2
      DO J=1,I-1
      DM1(II+J)=DM1(II+J)*0.5D0
      END DO
      END DO
C
C     DE-FACTORIZE THE NON-SYMMETRIC ELEMENTS OF 2D DENSITY MATRIX
C
C     IDFACT=1
C     CALL DENFACA(NORB,DM2,IDFACT)
C
C     RENORMALIZATION OF BOTH DM1 AND DM2.
C
      OVS=1.0D0/S0
      DO I=1,NORB2
      DM1(I)=DM1(I)*OVS
      END DO
      DO I=1,NORB2*(NORB2+1)/2
      DM2(I)=DM2(I)*OVS
      END DO
C     TIME1=XCLOCK()-TIME1
      RETURN
      END
C
C     Revision history
C
C     July 12, 2003: Fixed a multi-VB bug with S=1/2
C     --JLI--
C
C     SUBROUTINE VBHESS(N,NSPIN,NSTR,NASTR,CSTR,NORB,NOCORB,NBRIL,
C    & NBTAB,NOTAB,SIJ,HIJ,GIJKL,SRVB,HRVB,DM1,DM2,DENSTY,HESS,SS,
C    & AG,DEVE,IDERANK,E0,MSIZE,FLAG)
      SUBROUTINE VBHESS(N,NSPIN,NSTR,NASTR,CSTR,NORB,NBRIL,
     & NBTAB,NOTAB,SIJ,HIJ,GIJKL,SRVB,HRVB,DM1,DM2,DENSTY,HESS,SS,
     & AG,DEVE,IDERANK,E0,MSIZE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*50 FLAG
      PARAMETER (MAXNODE=150000,MAXNB2=100000)
C
C     NOTE THAT MM IS SET IN 4 SUBROUTINES AND IT MUST BE SET
C     TO THE SAME VALUE.
C
CGMS  PARAMETER (MM=500000)
C     SUFFICIENT FOR MAP FILES IN GAMESS RELEASE.
C     IF YOU USE LARGER MAP FILES FROM THE VB2000 RELEASE,
C     YOU MUST INCREASE MM.
C
C000  PARAMETER (MM=2500000)
CSMI  PARAMETER (MM=2500000)
CGAU  PARAMETER (MM=2500000)
C     SUITABLE FOR 14 ELECTRONS WITH A SINGLET MOLECULE.
C
C     IF YOU ARE GOING TO USE MORE THAN 14 ELECTRON MAP FILES,
C     YOU MUST INCREASE MM. IF THE MULTIPCITY IS GREATER THAN 1,
C     MAY ALSO NEED TO INCREASE MM. 
C     A WARNING WILL BE GIVEN IF MM IS NOT LARGE ENOUGH.
C
C     FOR UP TO 12 ELECTRONS IN SINGLET USE - PARAMETER (MM=500000)
C     FOR UP TO 14 ELECTRONS IN SINGLET USE - PARAMETER (MM=2500000)
C     FOR UP TO 16 ELECTRONS IN SINGLET USE - PARAMETER (MM=12500000)
C     FOR UP TO 18 ELECTRONS IN SINGLET USE - PARAMETER (MM=62500000)
C
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /LTAB/NTYPE,MAPINCORE,MEL,MSP,LOOKTB(6,100),NGRECD(4,100)
C     COMMON /MAP/MAP(3,MM),NALG(100),NRE(100),NAG1(100),NREC1(100),MVBM
      COMMON /MAP/MAP(3,MM),NALG(100),NRE(100),NAG1(100),MVBM
      COMMON /AGCODE/NPK1,NPK2,NPK3
      COMMON /INVERS/OVM(129)
      COMMON /IAA/IAA(100000)
C     DIMENSION AG(*),LPW(10),INDXW(100),KTNODE(5,MAXNODE)
      DIMENSION AG(*),INDXW(100),KTNODE(5,MAXNODE)
      DIMENSION SIJ(*),HIJ(*),GIJKL(*),CSTR(*)
      DIMENSION DM1(*),DM2(*),DENSTY(*),IJMAP(2,MAXNB2),NBTAB(NORB,*)
C     DIMENSION NOTAB(NORB,*),HESS(*),NASTR(N,*),MASTR(100)
      DIMENSION NOTAB(NORB,*),HESS(*),NASTR(N,*)
      DIMENSION SRVB(*),HRVB(*),DEVS(1000),DEVE(*)
      DIMENSION SS(N,NORB)
      MAGSIZE = 0
C
C     IDERANK: RANK OF DERIVERTIVES.
C              0: VB MATRIX ELEMENTS ONLY
C              1: PLUS FIRST ORDER DERIVERTIVES (GRADIENT)
C              2: PLUS SECOND ORDER DERIVERTIVES (HESSIAN)
C
C     SET ADDRESSES FOR VARIOUS DENSITY MATRIXES
C
C     N1SD,N2SD,N3SD: DENSITY MATRIX ELEMENTS OF ORDER 1-3.
C     N1HD,N2HD: H-ARGUMENTED DENSITY MATRIX ELEMENTS OF ORDER 1-2.
C     M1SD,M1HD,M2SD: STRUCTURE-WEIGHTED DENSITY MATRIXES(M=1,...NSTR)
C     CARNONICAL STORAGE, i.e. ONLY SYMMETRY UNIQUE MATRIX ELEMENTS ARE
C     STORED
C     NORB: NUMBER OF ORBITALS FOR THIS VB GROUP
C     WRITE(IOUTVB,*) 'IN VBHESS ', NBRIL, NSTR
      NVAR=NBRIL+NSTR
      DO IJ=1,NSTR*(NSTR+1)/2
      SRVB(IJ)=0.0D0
      HRVB(IJ)=0.0D0
      END DO
      IF(IDERANK.GE.2) THEN
        DO IJ=1,NVAR*(NVAR+1)/2
        HESS(IJ)=0.0D0
        END DO
      END IF
      MLAST=NORB*(NORB+1)/2
      IF(IDERANK.GT.0) THEN
      NORB2=NORB*(NORB+1)/2
      INDXW(1)=NORB2
      INDXW(2)=NORB2
      INDXW(3)=NORB2
C
C     COMPUTE  SCRATCH SPACE FOR 3RD ORDER DENSITY MATRIX
C     FOR TWO ELECTRON SYSTEM, THIS IS NOT NEEDED, THUS SET NORB3=1
C
      NORB3 = 1
      IF(N.GT.2) CALL SETINXN(3,INDXW,NORB3)
C
C     ERROR CHECK
C
      IF(NVAR.GT.1000.OR.IAA(NORB+1).GT.MAXNB2) THEN
      WRITE(IOUTVB,*) 'NVAR = ', NVAR
      WRITE(IOUTVB,*) 'NORB = ', NORB
C     WRITE(IOUTVB,*) 'INDMAX = ', INDMAX
      WRITE(IOUTVB,*) 'NBRIL = ', NBRIL
      WRITE(IOUTVB,*)'OUT OF BOUNDARY IN HESSAN, STOP'
      CALL ABRTVB
      END IF
      DO I=1,NVAR
      DEVS(I)=0.0D0
      DEVE(I)=0.0D0
      END DO
      IJ=0
      DO I=1,NORB
      DO J=1,I
      IJ=IJ+1
      IJMAP(1,IJ)=I
      IJMAP(2,IJ)=J
      END DO
      END DO
      END IF
      N1SD=0
      N1HD=N1SD+NORB2
      N2SD=N1HD+NORB2
      N2HD=N2SD+NORB2*(NORB2+1)/2
      N3SD=N2HD+NORB2*(NORB2+1)/2
      M1SD=N3SD+NORB3
      M1HD=M1SD+NORB2*NSTR
      M2SD=M1HD+NORB2*NSTR
      MLAST=M2SD+NORB2*(NORB2+1)*NSTR/2
C
C     RESET
C
      DO I=1,MLAST
      DENSTY(I)=0.0D0
      END DO
C1000 FORMAT(10F8.5)
      IF(MVBM.GT.0) GOTO 150
C
C     MVBM=0
C
      DO 100 ISTR=1,NSTR
      ISTR2=ISTR*(ISTR-1)/2
        DO J=1,NORB
        DO K=1,N
C       SS(K,J)=SIJ(INDXIJ(NASTR(K,ISTR),J))
           KK = NASTR(K,ISTR)
           IF(KK.GT.J) THEN
              KKJ = IAA(KK)+ J
           ELSE
              KKJ = IAA(J) + KK
           ENDIF
           SS(K,J)=SIJ(KKJ)
        END DO
        END DO
      IF(NSPIN.EQ.0) THEN
      CALL GSYMBO(N,NSPIN,NASTR,ISTR,KTNODE,NODES,IDERANK,MAXNODE)
      DO 105 KT=1,NODES
      IABCD=KTNODE(1,KT)
      ITYPE=KTNODE(2,KT)
      IDTHIS=IABS(KTNODE(3,KT))
      IJVB=ISTR2+IDTHIS
      NPARITY=1
      IF(KTNODE(3,KT).LT.0) NPARITY=-1
C     IDCHID=KTNODE(4,KT)
      IDEN  =KTNODE(5,KT)
      IRANKL=LOOKTB(1,ITYPE)
      IRANKH=LOOKTB(4,ITYPE)
      IF(IDEN.NE.1) THEN
        NAGH=NGRECD(1,ITYPE)
        NAGL=NGRECD(2,ITYPE)
C       NREC=NGRECD(3,ITYPE)
        IF(IRANKL.EQ.0) THEN
        AG(1)=1.0D0
        NAG1(1)=1
        END IF
        NAG1(IRANKH+1)=NAG1(IRANKL+1)+NAGL
        NADDL=NAG1(IRANKL+1)
        NADDH=NAG1(IRANKH+1)
        IF(NADDH+NAGH.GT.MAGSIZE) MAGSIZE=NADDH+NAGH
        IF(NADDH+NAGH.GT.MSIZE) THEN
        WRITE(IOUTVB,*)'ARRAY AG OUT OF BOUNDARY, STOP'
        CALL ABRTVB
        END IF
        IA=IABCD
        CALL GETIOUNIT('IOMAP   ',IOMAP)
        CALL MAPADD(IOMAP,MAP,ITYPE,NADSTA,MM)
C
C       BE CAREFUL, <B| |K> are interchanged for convenience in LAPLACE
C       So must the last step
C
C       CALL LAPLACE(AG(NADDL),AG(NADDH),NAGH,NREC,IRANKH,
        CALL LAPLACE(AG(NADDL),AG(NADDH),NAGH,IRANKH,
     &               MAP(1,NADSTA),SS(1,IA))
          DO LX=1,NAGH
          AG(NADDH-1+LX)=AG(NADDH-1+LX)*NPARITY
          END DO
          NAG1(IRANKH+2)=NAG1(IRANKH+1)+NAGH
        ELSE
        NAGH=NGRECD(1,ITYPE)
        NAGL=NGRECD(2,ITYPE)
C       NREC=NGRECD(3,ITYPE)
        IF(IRANKL.EQ.0) THEN
        AG(1)=1.0D0
        NAG1(1)=1
        END IF
        NADD=NAG1(IRANKL+1)-1
        ISQ1=(ISTR-1)*NORB2
        JSQ1=(IDTHIS-1)*NORB2
        ISQ2=(ISTR-1)*NORB2*(NORB2+1)/2
        JSQ2=(IDTHIS-1)*NORB2*(NORB2+1)/2
        CPARITY=CSTR(ISTR)*CSTR(IDTHIS)*NPARITY
        CPA0=CSTR(ISTR)*NPARITY
        CPB0=CSTR(IDTHIS)*NPARITY
          IF(ISTR.NE.IDTHIS) THEN
          CPARITY=CPARITY+CPARITY
          CPA0=CPA0+CPA0
          CPB0=CPB0+CPB0
          END IF
        IA=IABCD
C       IF(IRANKL.EQ.0) AG(1)=1.0D0
        LCRANK=IRANKH-IRANKL
C       SUM=0.0D0
        IA=0
        IB=0
        IC=0
        ID=0
           IF(LCRANK.GE.4) THEN
           ID=IABCD/NPK3
           IABCD=IABCD-ID*NPK3
           END IF
           IF(LCRANK.GE.3) THEN
           IC=IABCD/NPK2
           IABCD=IABCD-IC*NPK2
           END IF
           IF(LCRANK.GE.2) THEN
           IB=IABCD/NPK1
           END IF
           IA=IABCD-IB*NPK1
        CALL MAPADD(IOMAP,MAP,ITYPE,NADSTA,MM)
        LX=NADSTA-1
        DO 110 IW=1,N
        I=NASTR(IW,ISTR)
C        IAI=INDXIJ(I,IA)
        IF(I.GT.IA) THEN
          IAI = IAA(I) + IA
        ELSE
          IAI = IAA(IA) + I
        ENDIF
C       INDXW(1)=IAI
        IF(LCRANK.EQ.1) THEN
        LX=LX+1
          DVALUE = 1.0D0/MAP(2,LX)
          D11PARITY=DVALUE*CPARITY
          CPA=CPA0*DVALUE
          CPB=CPB0*DVALUE
          D11PAR=DVALUE*NPARITY
          DXAG=D11PARITY*AG(NADD+MAP(3,LX))
          CPAG=CPA*AG(NADD+MAP(3,LX))
          CPBG=CPB*AG(NADD+MAP(3,LX))
C   BUILD 1SD
          DENSTY(N1SD+IAI)=DENSTY(N1SD+IAI) + DXAG
C
          DENSTY(M1SD+ISQ1+IAI)=DENSTY(M1SD+ISQ1+IAI) + CPBG
          DENSTY(M1SD+JSQ1+IAI)=DENSTY(M1SD+JSQ1+IAI) + CPAG
          SSSS=AG(NADD+MAP(3,LX))*SIJ(IAI)
          HHHH=AG(NADD+MAP(3,LX))*HIJ(IAI)
          SRVB(IJVB)=SRVB(IJVB)+SSSS*D11PAR
          HRVB(IJVB)=HRVB(IJVB)+HHHH*D11PAR
        ELSE
          DO 120 JW=1,N
          IF(JW.EQ.IW) GOTO 120
          J=NASTR(JW,ISTR)
C          IBJ=INDXIJ(J,IB)
        IF(J.GT.IB) THEN
          IBJ = IAA(J) + IB
        ELSE
          IBJ = IAA(IB) + J
        ENDIF
C         INDXW(2)=IBJ
          IF(LCRANK.EQ.2) THEN
          LX=LX+1
          DVALUE = OVM(65+MAP(2,LX))
          D11PARITY=DVALUE*CPARITY
          CPA=CPA0*DVALUE
          CPB=CPB0*DVALUE
          D11PAR=DVALUE*NPARITY
          DXAG=D11PARITY*AG(NADD+MAP(3,LX))
          CPAG=CPA*AG(NADD+MAP(3,LX))
          CPBG=CPB*AG(NADD+MAP(3,LX))
C   BUILD 1HD,2SD
C          IIAJIB=INDXIJ(IAI,IBJ)
        IF(IAI.GT.IBJ) THEN
          IIAJIB = IAA(IAI) + IBJ
        ELSE
          IIAJIB = IAA(IBJ) + IAI
        ENDIF
C   2SD
          DENSTY(N2SD+IIAJIB) = DENSTY(N2SD+IIAJIB) + DXAG
C
          DENSTY(M2SD+ISQ2+IIAJIB) = DENSTY(M2SD+ISQ2+IIAJIB) + CPBG
          DENSTY(M2SD+JSQ2+IIAJIB) = DENSTY(M2SD+JSQ2+IIAJIB) + CPAG
C   1HD
          DENSTY(N1HD+IAI) = DENSTY(N1HD+IAI) + DXAG*HIJ(IBJ)
          DENSTY(N1HD+IBJ) = DENSTY(N1HD+IBJ) + DXAG*HIJ(IAI)
C
          DENSTY(M1HD+ISQ1+IAI)=DENSTY(M1HD+ISQ1+IAI) + CPBG*HIJ(IBJ)
          DENSTY(M1HD+ISQ1+IBJ)=DENSTY(M1HD+ISQ1+IBJ) + CPBG*HIJ(IAI)
          DENSTY(M1HD+JSQ1+IAI)=DENSTY(M1HD+JSQ1+IAI) + CPAG*HIJ(IBJ)
          DENSTY(M1HD+JSQ1+IBJ)=DENSTY(M1HD+JSQ1+IBJ) + CPAG*HIJ(IAI)
          GGGG=AG(NADD+MAP(3,LX))*GIJKL(IIAJIB)
          HRVB(IJVB)=HRVB(IJVB)+GGGG*D11PAR
          ELSE
          DO 130 KW=1,N
            IF(KW.EQ.JW.OR.KW.EQ.IW) GOTO 130
            K=NASTR(KW,ISTR)
C            ICK=INDXIJ(K,IC)
        IF(K.GT.IC) THEN
          ICK = IAA(K) + IC
        ELSE
          ICK = IAA(IC) + K
        ENDIF
            INDXW(1)=IAI
            INDXW(2)=IBJ
            INDXW(3)=ICK
            IF(LCRANK.EQ.3) THEN
            LX=LX+1
            DVALUE = OVM(65+MAP(2,LX))
            DXAG=DVALUE*CPARITY*AG(NADD+MAP(3,LX))
            CPAG=CPA0*DVALUE*AG(NADD+MAP(3,LX))
            CPBG=CPB0*DVALUE*AG(NADD+MAP(3,LX))
C            IIAJIB=INDXIJ(IAI,IBJ)
        IF(IAI.GT.IBJ) THEN
          IIAJIB = IAA(IAI) + IBJ
        ELSE
          IIAJIB = IAA(IBJ) + IAI
        ENDIF
C            IIAKIC=INDXIJ(IAI,ICK)
        IF(IAI.GT.ICK) THEN
          IIAKIC = IAA(IAI) + ICK
        ELSE
          IIAKIC = IAA(ICK) + IAI
        ENDIF
C            JIBKIC=INDXIJ(IBJ,ICK)
        IF(IBJ.GT.ICK) THEN
          JIBKIC = IAA(IBJ) + ICK
        ELSE
          JIBKIC = IAA(ICK) + IBJ
        ENDIF
C
C   BUILD 3SD,2HD,1HD
C
C   3SD
            CALL SETINXN(3,INDXW,N3)
            DENSTY(N3SD+N3)=DENSTY(N3SD+N3) + DXAG
C
C   2HD
            DENSTY(N2HD+JIBKIC) = DENSTY(N2HD+JIBKIC) + DXAG*HIJ(IAI)
            DENSTY(N2HD+IIAKIC) = DENSTY(N2HD+IIAKIC) + DXAG*HIJ(IBJ)
            DENSTY(N2HD+IIAJIB) = DENSTY(N2HD+IIAJIB) + DXAG*HIJ(ICK)
C
C   1HD
C
            DENSTY(N1HD+IAI) = DENSTY(N1HD+IAI) + DXAG*GIJKL(JIBKIC)
            DENSTY(N1HD+IBJ) = DENSTY(N1HD+IBJ) + DXAG*GIJKL(IIAKIC)
            DENSTY(N1HD+ICK) = DENSTY(N1HD+ICK) + DXAG*GIJKL(IIAJIB)
C
        DENSTY(M1HD+ISQ1+IAI)=DENSTY(M1HD+ISQ1+IAI)+CPBG*GIJKL(JIBKIC)
        DENSTY(M1HD+ISQ1+IBJ)=DENSTY(M1HD+ISQ1+IBJ)+CPBG*GIJKL(IIAKIC)
        DENSTY(M1HD+ISQ1+ICK)=DENSTY(M1HD+ISQ1+ICK)+CPBG*GIJKL(IIAJIB)
C
        DENSTY(M1HD+JSQ1+IAI)=DENSTY(M1HD+JSQ1+IAI)+CPAG*GIJKL(JIBKIC)
        DENSTY(M1HD+JSQ1+IBJ)=DENSTY(M1HD+JSQ1+IBJ)+CPAG*GIJKL(IIAKIC)
        DENSTY(M1HD+JSQ1+ICK)=DENSTY(M1HD+JSQ1+ICK)+CPAG*GIJKL(IIAJIB)
            ELSE
              DO 140 LW=1,N
              IF(LW.EQ.KW.OR.LW.EQ.JW.OR.LW.EQ.IW) GOTO 140
              L=NASTR(LW,ISTR)
C              IDL=INDXIJ(L,ID)
        IF(L.GT.ID) THEN
          IDL = IAA(L) + ID
        ELSE
          IDL = IAA(ID) + L
        ENDIF
              INDXW(4)=IDL
              IF(LCRANK.EQ.4) THEN
              LX=LX+1
              DXAG=CPARITY*OVM(65+MAP(2,LX))*AG(NADD+MAP(3,LX))
C
C   BUILD 2HD
C   SIX COMBINATIONS
C
C        IIAJIB=INDXIJ(IAI,IBJ)
        IF(IAI.GT.IBJ) THEN
          IIAJIB = IAA(IAI) + IBJ
        ELSE
          IIAJIB = IAA(IBJ) + IAI
        ENDIF
C        KICLID=INDXIJ(ICK,IDL)
        IF(ICK.GT.IDL) THEN
          KICLID = IAA(ICK) + IDL
        ELSE
          KICLID = IAA(IDL) + ICK
        ENDIF
C        IIAKIC=INDXIJ(IAI,ICK)
        IF(IAI.GT.ICK) THEN
          IIAKIC = IAA(IAI) + ICK
        ELSE
          IIAKIC = IAA(ICK) + IAI
        ENDIF
C        JIBLID=INDXIJ(IBJ,IDL)
        IF(IBJ.GT.IDL) THEN
          JIBLID = IAA(IBJ) + IDL
        ELSE
          JIBLID = IAA(IDL) + IBJ
        ENDIF
C        IIALID=INDXIJ(IAI,IDL)
        IF(IAI.GT.IDL) THEN
          IIALID = IAA(IAI) + IDL
        ELSE
          IIALID = IAA(IDL) + IAI
        ENDIF
C        JIBKIC=INDXIJ(IBJ,ICK)
        IF(IBJ.GT.ICK) THEN
          JIBKIC = IAA(IBJ) + ICK
        ELSE
          JIBKIC = IAA(ICK) + IBJ
        ENDIF
        DENSTY(N2HD+IIAJIB)=DENSTY(N2HD+IIAJIB) + DXAG*GIJKL(KICLID)
        DENSTY(N2HD+IIAKIC)=DENSTY(N2HD+IIAKIC) + DXAG*GIJKL(JIBLID)
        DENSTY(N2HD+IIALID)=DENSTY(N2HD+IIALID) + DXAG*GIJKL(JIBKIC)
        DENSTY(N2HD+JIBKIC)=DENSTY(N2HD+JIBKIC) + DXAG*GIJKL(IIALID)
        DENSTY(N2HD+JIBLID)=DENSTY(N2HD+JIBLID) + DXAG*GIJKL(IIAKIC)
        DENSTY(N2HD+KICLID)=DENSTY(N2HD+KICLID) + DXAG*GIJKL(IIAJIB)
          END IF
 140      CONTINUE
          END IF
 130    CONTINUE
        END IF
 120  CONTINUE
      END IF
 110  CONTINUE
      END IF
 105  CONTINUE
      ELSE
      DO 107 JSTR=1, ISTR
      CALL GSYMBO(N,NSPIN,NASTR(1,JSTR),1,KTNODE,NODES,IDERANK,MAXNODE)
      DO 107 KT=1,NODES
      IABCD=KTNODE(1,KT)
      ITYPE=KTNODE(2,KT)
      IDTHIS=JSTR
      IJVB=ISTR2+IDTHIS
      NPARITY=1
      IF(KTNODE(3,KT).LT.0) NPARITY=-1
C     IDCHID=KTNODE(4,KT)
      IDEN  =KTNODE(5,KT)
      IRANKL=LOOKTB(1,ITYPE)
      IRANKH=LOOKTB(4,ITYPE)
      IF(IDEN.NE.1) THEN
        NAGH=NGRECD(1,ITYPE)
        NAGL=NGRECD(2,ITYPE)
C       NREC=NGRECD(3,ITYPE)
        IF(IRANKL.EQ.0) THEN
        AG(1)=1.0D0
        NAG1(1)=1
        END IF
        NAG1(IRANKH+1)=NAG1(IRANKL+1)+NAGL
        NADDL=NAG1(IRANKL+1)
        NADDH=NAG1(IRANKH+1)
        IF(NADDH+NAGH.GT.MSIZE) THEN
        WRITE(IOUTVB,*)'ARRAY AG OUT OF BOUNDARY, STOP'
        CALL ABRTVB
        END IF
        IA=IABCD
        CALL MAPADD(IOMAP,MAP,ITYPE,NADSTA,MM)
C
C       BE CAREFUL, <B| |K> are interchanged for convenience in LAPLACE
C       So must the last step
C
C       CALL LAPLACE(AG(NADDL),AG(NADDH),NAGH,NREC,IRANKH,
        CALL LAPLACE(AG(NADDL),AG(NADDH),NAGH,IRANKH,
     &               MAP(1,NADSTA),SS(1,IA))
          DO LX=1,NAGH
          AG(NADDH-1+LX)=AG(NADDH-1+LX)*NPARITY
          END DO
          NAG1(IRANKH+2)=NAG1(IRANKH+1)+NAGH
        ELSE
        NAGH=NGRECD(1,ITYPE)
        NAGL=NGRECD(2,ITYPE)
C       NREC=NGRECD(3,ITYPE)
        IF(IRANKL.EQ.0) THEN
        AG(1)=1.0D0
        NAG1(1)=1
        END IF
        NADD=NAG1(IRANKL+1)-1
        ISQ1=(ISTR-1)*NORB2
        JSQ1=(IDTHIS-1)*NORB2
        ISQ2=(ISTR-1)*NORB2*(NORB2+1)/2
        JSQ2=(IDTHIS-1)*NORB2*(NORB2+1)/2
        CPARITY=CSTR(ISTR)*CSTR(IDTHIS)*NPARITY
        CPA0=CSTR(ISTR)*NPARITY
        CPB0=CSTR(IDTHIS)*NPARITY
          IF(ISTR.NE.IDTHIS) THEN
          CPARITY=CPARITY+CPARITY
          CPA0=CPA0+CPA0
          CPB0=CPB0+CPB0
          END IF
        IA=IABCD
C       IF(IRANKL.EQ.0) AG(1)=1.0D0
        LCRANK=IRANKH-IRANKL
C       SUM=0.0D0
        IA=0
        IB=0
        IC=0
        ID=0
           IF(LCRANK.GE.4) THEN
           ID=IABCD/NPK3
           IABCD=IABCD-ID*NPK3
           END IF
           IF(LCRANK.GE.3) THEN
           IC=IABCD/NPK2
           IABCD=IABCD-IC*NPK2
           END IF
           IF(LCRANK.GE.2) THEN
           IB=IABCD/NPK1
           END IF
           IA=IABCD-IB*NPK1
        CALL MAPADD(IOMAP,MAP,ITYPE,NADSTA,MM)
        LX=NADSTA-1
        DO 115 IW=1,N
        I=NASTR(IW,ISTR)
C        IAI=INDXIJ(I,IA)
        IF(I.GT.IA) THEN
          IAI = IAA(I) + IA
        ELSE
          IAI = IAA(IA) + I
        ENDIF
C       INDXW(1)=IAI
        IF(LCRANK.EQ.1) THEN
        LX=LX+1
          DVALUE = 1.0D0/MAP(2,LX)
          D11PARITY=DVALUE*CPARITY
          CPA=CPA0*DVALUE
          CPB=CPB0*DVALUE
          D11PAR=DVALUE*NPARITY
          DXAG=D11PARITY*AG(NADD+MAP(3,LX))
          CPAG=CPA*AG(NADD+MAP(3,LX))
          CPBG=CPB*AG(NADD+MAP(3,LX))
C   BUILD 1SD
          DENSTY(N1SD+IAI)=DENSTY(N1SD+IAI) + DXAG
C
          DENSTY(M1SD+ISQ1+IAI)=DENSTY(M1SD+ISQ1+IAI) + CPBG
          DENSTY(M1SD+JSQ1+IAI)=DENSTY(M1SD+JSQ1+IAI) + CPAG
          SSSS=AG(NADD+MAP(3,LX))*SIJ(IAI)
          HHHH=AG(NADD+MAP(3,LX))*HIJ(IAI)
          SRVB(IJVB)=SRVB(IJVB)+SSSS*D11PAR
          HRVB(IJVB)=HRVB(IJVB)+HHHH*D11PAR
        ELSE
          DO 125 JW=1,N
          IF(JW.EQ.IW) GOTO 125
          J=NASTR(JW,ISTR)
C          IBJ=INDXIJ(J,IB)
        IF(J.GT.IB) THEN
          IBJ = IAA(J) + IB
        ELSE
          IBJ = IAA(IB) + J
        ENDIF
          IF(J.GT.IB) THEN
            IBJ = IAA(J) + IB
          ELSE
            IBJ = IAA(IB) + J
          ENDIF
C         INDXW(2)=IBJ
          IF(LCRANK.EQ.2) THEN
          LX=LX+1
          DVALUE = OVM(65+MAP(2,LX))
          D11PARITY=DVALUE*CPARITY
          CPA=CPA0*DVALUE
          CPB=CPB0*DVALUE
          D11PAR=DVALUE*NPARITY
          DXAG=D11PARITY*AG(NADD+MAP(3,LX))
          CPAG=CPA*AG(NADD+MAP(3,LX))
          CPBG=CPB*AG(NADD+MAP(3,LX))
C   BUILD 1HD,2SD
C          IIAJIB=INDXIJ(IAI,IBJ)
        IF(IAI.GT.IBJ) THEN
          IIAJIB = IAA(IAI) + IBJ
        ELSE
          IIAJIB = IAA(IBJ) + IAI
        ENDIF
C   2SD
          DENSTY(N2SD+IIAJIB) = DENSTY(N2SD+IIAJIB) + DXAG
C
          DENSTY(M2SD+ISQ2+IIAJIB) = DENSTY(M2SD+ISQ2+IIAJIB) + CPBG
          DENSTY(M2SD+JSQ2+IIAJIB) = DENSTY(M2SD+JSQ2+IIAJIB) + CPAG
C   1HD
          DENSTY(N1HD+IAI) = DENSTY(N1HD+IAI) + DXAG*HIJ(IBJ)
          DENSTY(N1HD+IBJ) = DENSTY(N1HD+IBJ) + DXAG*HIJ(IAI)
C
          DENSTY(M1HD+ISQ1+IAI)=DENSTY(M1HD+ISQ1+IAI) + CPBG*HIJ(IBJ)
          DENSTY(M1HD+ISQ1+IBJ)=DENSTY(M1HD+ISQ1+IBJ) + CPBG*HIJ(IAI)
          DENSTY(M1HD+JSQ1+IAI)=DENSTY(M1HD+JSQ1+IAI) + CPAG*HIJ(IBJ)
          DENSTY(M1HD+JSQ1+IBJ)=DENSTY(M1HD+JSQ1+IBJ) + CPAG*HIJ(IAI)
          GGGG=AG(NADD+MAP(3,LX))*GIJKL(IIAJIB)
          HRVB(IJVB)=HRVB(IJVB)+GGGG*D11PAR
          ELSE
          DO 135 KW=1,N
            IF(KW.EQ.JW.OR.KW.EQ.IW) GOTO 135
            K=NASTR(KW,ISTR)
C            ICK=INDXIJ(K,IC)
        IF(K.GT.IC) THEN
          ICK = IAA(K) + IC
        ELSE
          ICK = IAA(IC) + K
        ENDIF
            INDXW(1)=IAI
            INDXW(2)=IBJ
            INDXW(3)=ICK
            IF(LCRANK.EQ.3) THEN
            LX=LX+1
            DVALUE = OVM(65+MAP(2,LX))
            DXAG=DVALUE*CPARITY*AG(NADD+MAP(3,LX))
            CPAG=CPA0*DVALUE*AG(NADD+MAP(3,LX))
            CPBG=CPB0*DVALUE*AG(NADD+MAP(3,LX))
C            IIAJIB=INDXIJ(IAI,IBJ)
        IF(IAI.GT.IBJ) THEN
          IIAJIB = IAA(IAI) + IBJ
        ELSE
          IIAJIB = IAA(IBJ) + IAI
        ENDIF
C            IIAKIC=INDXIJ(IAI,ICK)
        IF(IAI.GT.ICK) THEN
          IIAKIC = IAA(IAI) + ICK
        ELSE
          IIAKIC = IAA(ICK) + IAI
        ENDIF
C            JIBKIC=INDXIJ(IBJ,ICK)
        IF(IBJ.GT.ICK) THEN
          JIBKIC = IAA(IBJ) + ICK
        ELSE
          JIBKIC = IAA(ICK) + IBJ
        ENDIF
C
C   BUILD 3SD,2HD,1HD
C
C   3SD
            CALL SETINXN(3,INDXW,N3)
            DENSTY(N3SD+N3)=DENSTY(N3SD+N3) + DXAG
C
C   2HD
            DENSTY(N2HD+JIBKIC) = DENSTY(N2HD+JIBKIC) + DXAG*HIJ(IAI)
            DENSTY(N2HD+IIAKIC) = DENSTY(N2HD+IIAKIC) + DXAG*HIJ(IBJ)
            DENSTY(N2HD+IIAJIB) = DENSTY(N2HD+IIAJIB) + DXAG*HIJ(ICK)
C
C   1HD
C
            DENSTY(N1HD+IAI) = DENSTY(N1HD+IAI) + DXAG*GIJKL(JIBKIC)
            DENSTY(N1HD+IBJ) = DENSTY(N1HD+IBJ) + DXAG*GIJKL(IIAKIC)
            DENSTY(N1HD+ICK) = DENSTY(N1HD+ICK) + DXAG*GIJKL(IIAJIB)
C
        DENSTY(M1HD+ISQ1+IAI)=DENSTY(M1HD+ISQ1+IAI)+CPBG*GIJKL(JIBKIC)
        DENSTY(M1HD+ISQ1+IBJ)=DENSTY(M1HD+ISQ1+IBJ)+CPBG*GIJKL(IIAKIC)
        DENSTY(M1HD+ISQ1+ICK)=DENSTY(M1HD+ISQ1+ICK)+CPBG*GIJKL(IIAJIB)
C
        DENSTY(M1HD+JSQ1+IAI)=DENSTY(M1HD+JSQ1+IAI)+CPAG*GIJKL(JIBKIC)
        DENSTY(M1HD+JSQ1+IBJ)=DENSTY(M1HD+JSQ1+IBJ)+CPAG*GIJKL(IIAKIC)
        DENSTY(M1HD+JSQ1+ICK)=DENSTY(M1HD+JSQ1+ICK)+CPAG*GIJKL(IIAJIB)
            ELSE
              DO 145 LW=1,N
              IF(LW.EQ.KW.OR.LW.EQ.JW.OR.LW.EQ.IW) GOTO 145
              L=NASTR(LW,ISTR)
C              IDL=INDXIJ(L,ID)
        IF(L.GT.ID) THEN
          IDL = IAA(L) + ID
        ELSE
          IDL = IAA(ID) + L
        ENDIF
              INDXW(4)=IDL
              IF(LCRANK.EQ.4) THEN
              LX=LX+1
              DXAG=CPARITY*OVM(65+MAP(2,LX))*AG(NADD+MAP(3,LX))
C
C   BUILD 2HD
C   SIX COMBINATIONS
C
C        IIAJIB=INDXIJ(IAI,IBJ)
        IF(IAI.GT.IBJ) THEN
          IIAJIB = IAA(IAI) + IBJ
        ELSE
          IIAJIB = IAA(IBJ) + IAI
        ENDIF
C        KICLID=INDXIJ(ICK,IDL)
        IF(ICK.GT.IDL) THEN
          KICLID = IAA(ICK) + IDL
        ELSE
          KICLID = IAA(IDL) + ICK
        ENDIF
C        IIAKIC=INDXIJ(IAI,ICK)
        IF(IAI.GT.ICK) THEN
          IIAKIC = IAA(IAI) + ICK
        ELSE
          IIAKIC = IAA(ICK) + IAI
        ENDIF
C        JIBLID=INDXIJ(IBJ,IDL)
        IF(IBJ.GT.IDL) THEN
          JIBLID = IAA(IBJ) + IDL
        ELSE
          JIBLID = IAA(IDL) + IBJ
        ENDIF
C        IIALID=INDXIJ(IAI,IDL)
        IF(IAI.GT.IDL) THEN
          IIALID = IAA(IAI) + IDL
        ELSE
          IIALID = IAA(IDL) + IAI
        ENDIF
C        JIBKIC=INDXIJ(IBJ,ICK)
        IF(IBJ.GT.ICK) THEN
          JIBKIC = IAA(IBJ) + ICK
        ELSE
          JIBKIC = IAA(ICK) + IBJ
        ENDIF
        DENSTY(N2HD+IIAJIB)=DENSTY(N2HD+IIAJIB) + DXAG*GIJKL(KICLID)
        DENSTY(N2HD+IIAKIC)=DENSTY(N2HD+IIAKIC) + DXAG*GIJKL(JIBLID)
        DENSTY(N2HD+IIALID)=DENSTY(N2HD+IIALID) + DXAG*GIJKL(JIBKIC)
        DENSTY(N2HD+JIBKIC)=DENSTY(N2HD+JIBKIC) + DXAG*GIJKL(IIALID)
        DENSTY(N2HD+JIBLID)=DENSTY(N2HD+JIBLID) + DXAG*GIJKL(IIAKIC)
        DENSTY(N2HD+KICLID)=DENSTY(N2HD+KICLID) + DXAG*GIJKL(IIAJIB)
          END IF
 145      CONTINUE
          END IF
 135    CONTINUE
        END IF
 125  CONTINUE
      END IF
 115  CONTINUE
      END IF
 107  CONTINUE
      END IF
 100  CONTINUE
      GOTO 250
 150  CONTINUE
C
C     MVBM=1
C
      WRITE(IOUTVB,*)'MVBMAP=1 IS NOT IMPLEMETED YET'
      CALL ABRTVB
C200  CONTINUE
 250  CONTINUE
      DO IJ=1,NSTR*(NSTR+1)/2
      SRVB(IJ)=SRVB(IJ)/N
      END DO
      VBHH0=0.0D0
      VBGG0=0.0D0
      VBSSN=0.0D0
      DO I=1,NORB2
      VBHH0=VBHH0+DENSTY(N1SD+I)*HIJ(I)
      VBSSN=VBSSN+DENSTY(N1SD+I)*SIJ(I)
      END DO
      DO I=1,NORB2*(NORB2+1)/2
      VBGG0=VBGG0+DENSTY(N2SD+I)*GIJKL(I)
      END DO
      S0=VBSSN/N
      E0=(VBHH0+VBGG0)/S0
C     TIME1=XCLOCK()
C
C     UPDATE CSTR BY SOLVE THE SECULAR EQUATION
C     HC = ESC
C
C     WRITE(IOUTVB,*)'CSTR BEFORE =',(CSTR(I),I=1,NSTR)
C     CALL RVB(NSTR,CSTR,SRVB,HRVB,AG,F2,FLAG,LPTALL)
C     FLAD NEEDS ADDING BACK AS ARGUMENT IF ABOVE IS USED
C     WRITE(IOUTVB,*)'CSTR AFTER  =',(CSTR(I),I=1,NSTR)
C
C     BAD IDEA, JL/04/12/04
C
      IF(IDERANK.EQ.0) GOTO 2000
C
C     DERIVATIVES: STRUCTURES
C
      DO I=1,NSTR
      DO J=1,NSTR
      IF(I.GT.J) THEN
      IJ=I*(I-1)/2+J
      ELSE
      IJ=J*(J-1)/2+I
      END IF
      DEVS(NBRIL+I)=DEVS(NBRIL+I)+CSTR(J)*SRVB(IJ)
      DEVS(NBRIL+J)=DEVS(NBRIL+J)+CSTR(I)*SRVB(IJ)
      DEVE(NBRIL+I)=DEVE(NBRIL+I)+CSTR(J)*(HRVB(IJ)-E0*SRVB(IJ))
      DEVE(NBRIL+J)=DEVE(NBRIL+J)+CSTR(I)*(HRVB(IJ)-E0*SRVB(IJ))
      END DO
      END DO
C
C     DERIVATIVES
C
      DO I=1,NORB2
C
C      PART 1: <a|b><HAG_N_1>
C      PART 2: <a|h|b><AG_N-1>
C      PART 3: -E<a|b><AG_N-1>
C
      IA=IJMAP(1,I)
      IB=IJMAP(2,I)
       DO K=1,NORB
       KA=NBTAB(K,IA)
       KB=NBTAB(K,IB)
C       IAK=INDXIJ(K,IA)
        IF(K.GT.IA) THEN
          IAK = IAA(K) + IA
        ELSE
          IAK = IAA(IA) + K
        ENDIF
C       IBK=INDXIJ(K,IB)
        IF(K.GT.IB) THEN
          IBK = IAA(K) + IB
        ELSE
          IBK = IAA(IB) + K
        ENDIF
       IF(KA.GT.0) THEN
       DEVE(KA)=DEVE(KA)+SIJ(IBK)*DENSTY(N1HD+I)+
     &          HIJ(IBK)*DENSTY(N1SD+I)-E0*SIJ(IBK)*DENSTY(N1SD+I)
       DEVS(KA)=DEVS(KA)+SIJ(IBK)*DENSTY(N1SD+I)
       END IF
       IF(KB.GT.0) THEN
       DEVE(KB)=DEVE(KB)+SIJ(IAK)*DENSTY(N1HD+I)+
     &          HIJ(IAK)*DENSTY(N1SD+I)-E0*SIJ(IAK)*DENSTY(N1SD+I)
       DEVS(KB)=DEVS(KB)+SIJ(IAK)*DENSTY(N1SD+I)
       END IF
       END DO
      END DO
C      PART 4: <ab|g|cd><AG_N-2>
      DO I=1,NORB2
      IA=IJMAP(1,I)
      IB=IJMAP(2,I)
      DO J=1,I
      IC=IJMAP(1,J)
      ID=IJMAP(2,J)
C      IJ=INDXIJ(J,I)
        IF(J.GT.I) THEN
          IJ = IAA(J) + I
        ELSE
          IJ = IAA(I) + J
        ENDIF
       DO K=1,NORB
       KA=NBTAB(K,IA)
       KB=NBTAB(K,IB)
       KC=NBTAB(K,IC)
       KD=NBTAB(K,ID)
       IF(KA.GT.0) THEN
C       IBK=INDXIJ(K,IB)
        IF(K.GT.IB) THEN
          IBK = IAA(K) + IB
        ELSE
          IBK = IAA(IB) + K
        ENDIF
C       IKBCD=INDXIJ(J,IBK)
        IF(J.GT.IBK) THEN
          IKBCD = IAA(J) + IBK
        ELSE
          IKBCD = IAA(IBK) + J
        ENDIF
       DEVE(KA)=DEVE(KA)+GIJKL(IKBCD)*DENSTY(N2SD+IJ)
       END IF
       IF(KB.GT.0) THEN
C       IAK=INDXIJ(K,IA)
        IF(K.GT.IA) THEN
          IAK = IAA(K) + IA
        ELSE
          IAK = IAA(IA) + K
        ENDIF
C       IAKCD=INDXIJ(J,IAK)
        IF(J.GT.IAK) THEN
          IAKCD = IAA(J) + IAK
        ELSE
          IAKCD = IAA(IAK) + J
        ENDIF
       DEVE(KB)=DEVE(KB)+GIJKL(IAKCD)*DENSTY(N2SD+IJ)
       END IF
       IF(KC.GT.0) THEN
C       IDK=INDXIJ(K,ID)
        IF(K.GT.ID) THEN
          IDK = IAA(K) + ID
        ELSE
          IDK = IAA(ID) + K
        ENDIF
C       IABKD=INDXIJ(I,IDK)
        IF(I.GT.IDK) THEN
          IABKD = IAA(I) + IDK
        ELSE
          IABKD = IAA(IDK) + I
        ENDIF
       DEVE(KC)=DEVE(KC)+GIJKL(IABKD)*DENSTY(N2SD+IJ)
       END IF
       IF(KD.GT.0) THEN
C       ICK=INDXIJ(K,IC)
        IF(K.GT.IC) THEN
          ICK = IAA(K) + IC
        ELSE
          ICK = IAA(IC) + K
        ENDIF
C       IABCK=INDXIJ(I,ICK)
        IF(I.GT.ICK) THEN
          IABCK = IAA(I) + ICK
        ELSE
          IABCK = IAA(ICK) + I
        ENDIF
       DEVE(KD)=DEVE(KD)+GIJKL(IABCK)*DENSTY(N2SD+IJ)
       END IF
       END DO
      END DO
      END DO
      OVS=1.0D0/S0
      DO I=1,NBRIL+NSTR
      DEVE(I)=DEVE(I)*OVS
      END DO
C     STOP
      IF(IDERANK.EQ.1) GOTO 2000
C
C     HESSIAN: ORBITAL-ORBITAL BLOCK
C
      DO I=1,NORB2
C
C      PART 1: <a|b><HAG_N_1>
C      PART 2: <a|h|b><AG_N-1>
C      PART 3: -E<a|b><AG_N-1>
C
      IA=IJMAP(1,I)
      IB=IJMAP(2,I)
       DO K=1,NORB
       KA=NBTAB(K,IA)
       DO L=1,NORB
       LB=NBTAB(L,IB)
       IF(KA.GT.0.AND.LB.GT.0) THEN
C       KL=INDXIJ(K,L)
        IF(K.GT.L) THEN
          KL = IAA(K) + L
        ELSE
          KL = IAA(L) + K
        ENDIF
C       KLAB=INDXIJ(KA,LB)
        IF(KA.GT.LB) THEN
          KLAB = IAA(KA) + LB
        ELSE
          KLAB = IAA(LB) + KA
        ENDIF
       HESS(KLAB)=HESS(KLAB) +  SIJ(KL)*DENSTY(N1HD+I)
     &                       +  HIJ(KL)*DENSTY(N1SD+I)
     &                      -E0*SIJ(KL)*DENSTY(N1SD+I)
       END IF
       END DO
       END DO
      END DO
C      PART 4: (ab|cd)<HAG_N-2>
C      PART 5: <a|h|b><c|d><AG_N-2>
C      PART 6: (ab|g|cd)<AG_N-2>
C      PART 7: -E(ab|cd)<AG_N-2>
      DO I=1,NORB2
      IA=IJMAP(1,I)
      IB=IJMAP(2,I)
      DO J=1,I
      IC=IJMAP(1,J)
      ID=IJMAP(2,J)
C      IJ=INDXIJ(I,J)
        IF(I.GT.J) THEN
          IJ = IAA(I) + J
        ELSE
          IJ = IAA(J) + I
        ENDIF
       DO K=1,NORB
       KA=NBTAB(K,IA)
       KB=NBTAB(K,IB)
       KC=NBTAB(K,IC)
       KD=NBTAB(K,ID)
C       IAK=INDXIJ(K,IA)
        IF(K.GT.IA) THEN
          IAK = IAA(K) + IA
        ELSE
          IAK = IAA(IA) + K
        ENDIF
C       IBK=INDXIJ(K,IB)
        IF(K.GT.IB) THEN
          IBK = IAA(K) + IB
        ELSE
          IBK = IAA(IB) + K
        ENDIF
       DO L=1,NORB
C      LA=NBTAB(L,IA)
       LB=NBTAB(L,IB)
       LC=NBTAB(L,IC)
       LD=NBTAB(L,ID)
C       ICL=INDXIJ(L,IC)
        IF(L.GT.IC) THEN
          ICL = IAA(L) + IC
        ELSE
          ICL = IAA(IC) + L
        ENDIF
C       IDL=INDXIJ(L,ID)
        IF(L.GT.ID) THEN
          IDL = IAA(L) + ID
        ELSE
          IDL = IAA(ID) + L
        ENDIF
C       KL=INDXIJ(K,L)
        IF(K.GT.L) THEN
          KL = IAA(K) + L
        ELSE
          KL = IAA(L) + K
        ENDIF
C       IAKCL=INDXIJ(IAK,ICL)
        IF(IAK.GT.ICL) THEN
          IAKCL = IAA(IAK) + ICL
        ELSE
          IAKCL = IAA(ICL) + IAK
        ENDIF
C       IAKLD=INDXIJ(IAK,IDL)
        IF(IAK.GT.IDL) THEN
          IAKLD = IAA(IAK) + IDL
        ELSE
          IAKLD = IAA(IDL) + IAK
        ENDIF
C       IKBCL=INDXIJ(IBK,ICL)
        IF(IBK.GT.ICL) THEN
          IKBCL = IAA(IBK) + ICL
        ELSE
          IKBCL = IAA(ICL) + IBK
        ENDIF
C       IKBLD=INDXIJ(IBK,IDL)
        IF(IBK.GT.IDL) THEN
          IKBLD = IAA(IBK) + IDL
        ELSE
          IKBLD = IAA(IDL) + IBK
        ENDIF
C       IKLCD=INDXIJ(KL,J)
        IF(KL.GT.J) THEN
          IKLCD = IAA(KL) + J
        ELSE
          IKLCD = IAA(J) + KL
        ENDIF
C       IABKL=INDXIJ(I,KL)
        IF(I.GT.KL) THEN
          IABKL = IAA(I) + KL
        ELSE
          IABKL = IAA(KL) + I
        ENDIF
       IF(KA.GT.0.AND.LC.GT.0) THEN
C       KLAC=INDXIJ(KA,LC)
        IF(KA.GT.LC) THEN
          KLAC = IAA(KA) + LC
        ELSE
          KLAC = IAA(LC) + KA
        ENDIF
       HESS(KLAC)=HESS(KLAC)+SIJ(IBK)*SIJ(IDL)*DENSTY(N2HD+IJ)
     &  +(SIJ(IBK)*HIJ(IDL)+HIJ(IBK)*SIJ(IDL)+GIJKL(IKBLD)
     &    -E0*SIJ(IBK)*SIJ(IDL))*DENSTY(N2SD+IJ)
       END IF
       IF(KA.GT.0.AND.LD.GT.0) THEN
C       KLAD=INDXIJ(KA,LD)
        IF(KA.GT.LD) THEN
          KLAD = IAA(KA) + LD
        ELSE
          KLAD = IAA(LD) + KA
        ENDIF
       HESS(KLAD)=HESS(KLAD)+SIJ(IBK)*SIJ(ICL)*DENSTY(N2HD+IJ)
     &  +(HIJ(IBK)*SIJ(ICL)+SIJ(IBK)*HIJ(ICL)+GIJKL(IKBCL)
     &    -E0*SIJ(IBK)*SIJ(ICL))*DENSTY(N2SD+IJ)
       END IF
       IF(KB.GT.0.AND.LC.GT.0) THEN
C       KLBC=INDXIJ(KB,LC)
        IF(KB.GT.LC) THEN
          KLBC = IAA(KB) + LC
        ELSE
          KLBC = IAA(LC) + KB
        ENDIF
       HESS(KLBC)=HESS(KLBC)+SIJ(IAK)*SIJ(IDL)*DENSTY(N2HD+IJ)
     &  +(SIJ(IAK)*HIJ(IDL)+HIJ(IAK)*SIJ(IDL)+GIJKL(IAKLD)
     &    -E0*SIJ(IAK)*SIJ(IDL))*DENSTY(N2SD+IJ)
       END IF
       IF(KB.GT.0.AND.LD.GT.0) THEN
C       KLBD=INDXIJ(KB,LD)
        IF(KB.GT.LD) THEN
          KLBD = IAA(KB) + LD
        ELSE
          KLBD = IAA(LD) + KB
        ENDIF
       HESS(KLBD)=HESS(KLBD)+SIJ(IAK)*SIJ(ICL)*DENSTY(N2HD+IJ)
     &  +(SIJ(IAK)*HIJ(ICL)+HIJ(IAK)*SIJ(ICL)+GIJKL(IAKCL)
     &    -E0*SIJ(IAK)*SIJ(ICL))*DENSTY(N2SD+IJ)
       END IF
       IF(KA.GT.0.AND.LB.GT.0) THEN
C       KLAB =INDXIJ(KA,LB)
        IF(KA.GT.LB) THEN
          KLAB = IAA(KA) + LB
        ELSE
          KLAB = IAA(LB) + KA
        ENDIF
       HESS(KLAB)=HESS (KLAB)+GIJKL(IKLCD)*DENSTY(N2SD+IJ)
       END IF
       IF(KC.GT.0.AND.LD.GT.0) THEN
C       KLCD=INDXIJ(KC,LD)
        IF(KC.GT.LD) THEN
          KLCD = IAA(KC) + LD
        ELSE
          KLCD = IAA(LD) + KC
        ENDIF
       HESS(KLCD)=HESS(KLCD)+GIJKL(IABKL)*DENSTY(N2SD+IJ)
       END IF
C      end of modification
       END DO
       END DO
      END DO
      END DO
C     IF(N.LT.3) SKIP THIS PART
      IF(N.LT.3) GOTO 333
C
C    PART 8 (ab|cd)<e|f><AG_N-3>
C
      N3SDIJK=N3SD
C     SUM3=0.0D0
      DO I=1,NORB2
      IA=IJMAP(1,I)
      IB=IJMAP(2,I)
      DO J=1,I
      JC=IJMAP(1,J)
      JD=IJMAP(2,J)
      DO K=1,J
      KE=IJMAP(1,K)
      KF=IJMAP(2,K)
      N3SDIJK=N3SDIJK+1
       DO L=1,NORB-1
       LIA=NOTAB(L,IA)
       LIB=NOTAB(L,IB)
       LJC=NOTAB(L,JC)
       LJD=NOTAB(L,JD)
       LKE=NOTAB(L,KE)
       LKF=NOTAB(L,KF)
       L2A=NBTAB(LIA,IA)
       L2B=NBTAB(LIB,IB)
       L2C=NBTAB(LJC,JC)
       L2D=NBTAB(LJD,JD)
       L2E=NBTAB(LKE,KE)
       L2F=NBTAB(LKF,KF)
C       IAL=INDXIJ(IA,LIB)
        IF(IA.GT.LIB) THEN
          IAL = IAA(IA) + LIB
        ELSE
          IAL = IAA(LIB) + IA
        ENDIF
C       IBL=INDXIJ(IB,LIA)
        IF(IB.GT.LIA) THEN
          IBL = IAA(IB) + LIA
        ELSE
          IBL = IAA(LIA) + IB
        ENDIF
C       JCL=INDXIJ(JC,LJD)
        IF(JC.GT.LJD) THEN
          JCL = IAA(JC) + LJD
        ELSE
          JCL = IAA(LJD) + JC
        ENDIF
C       JDL=INDXIJ(JD,LJC)
        IF(JD.GT.LJC) THEN
          JDL = IAA(JD) + LJC
        ELSE
          JDL = IAA(LJC) + JD
        ENDIF
C       KEL=INDXIJ(KE,LKF)
        IF(KE.GT.LKF) THEN
          KEL = IAA(KE) + LKF
        ELSE
          KEL = IAA(LKF) + KE
        ENDIF
C       KFL=INDXIJ(KF,LKE)
        IF(KF.GT.LKE) THEN
          KFL = IAA(KF) + LKE
        ELSE
          KFL = IAA(LKE) + KF
        ENDIF
C       LBCD=INDXIJ(IBL,J)
        IF(IBL.GT.J) THEN
          LBCD = IAA(IBL) + J
        ELSE
          LBCD = IAA(J) + IBL
        ENDIF
C       LACD=INDXIJ(IAL,J)
        IF(IAL.GT.J) THEN
          LACD = IAA(IAL) + J
        ELSE
          LACD = IAA(J) + IAL
        ENDIF
C       LABD=INDXIJ(I,JDL)
        IF(I.GT.JDL) THEN
          LABD = IAA(I) + JDL
        ELSE
          LABD = IAA(JDL) + I
        ENDIF
C       LABC=INDXIJ(I,JCL)
        IF(I.GT.JCL) THEN
          LABC = IAA(I) + JCL
        ELSE
          LABC = IAA(JCL) + I
        ENDIF
C       LBEF=INDXIJ(IBL,K)
        IF(IBL.GT.K) THEN
          LBEF = IAA(IBL) + K
        ELSE
          LBEF = IAA(K) + IBL
        ENDIF
C       LAEF=INDXIJ(IAL,K)
        IF(IAL.GT.K) THEN
          LAEF = IAA(IAL) + K
        ELSE
          LAEF = IAA(K) + IAL
        ENDIF
C       LABF=INDXIJ(I,KFL)
        IF(I.GT.KFL) THEN
          LABF = IAA(I) + KFL
        ELSE
          LABF = IAA(KFL) + I
        ENDIF
C       LABE=INDXIJ(I,KEL)
        IF(I.GT.KEL) THEN
          LABE = IAA(I) + KEL
        ELSE
          LABE = IAA(KEL) + I
        ENDIF
C       LDEF=INDXIJ(JDL,K)
        IF(JDL.GT.K) THEN
          LDEF = IAA(JDL) + K
        ELSE
          LDEF = IAA(K) + JDL
        ENDIF
C       LCEF=INDXIJ(JCL,K)
        IF(JCL.GT.K) THEN
          LCEF = IAA(JCL) + K
        ELSE
          LCEF = IAA(K) + JCL
        ENDIF
C       LCDF=INDXIJ(J,KFL)
        IF(J.GT.KFL) THEN
          LCDF = IAA(J) + KFL
        ELSE
          LCDF = IAA(KFL) + J
        ENDIF
C       LCDE=INDXIJ(J,KEL)
        IF(J.GT.KEL) THEN
          LCDE = IAA(J) + KEL
        ELSE
          LCDE = IAA(KEL) + J
        ENDIF
       GLBCD=GIJKL(LBCD)*DENSTY(N3SDIJK)
       GLACD=GIJKL(LACD)*DENSTY(N3SDIJK)
       GLABD=GIJKL(LABD)*DENSTY(N3SDIJK)
       GLABC=GIJKL(LABC)*DENSTY(N3SDIJK)
       GLBEF=GIJKL(LBEF)*DENSTY(N3SDIJK)
       GLAEF=GIJKL(LAEF)*DENSTY(N3SDIJK)
       GLABF=GIJKL(LABF)*DENSTY(N3SDIJK)
       GLABE=GIJKL(LABE)*DENSTY(N3SDIJK)
       GLDEF=GIJKL(LDEF)*DENSTY(N3SDIJK)
       GLCEF=GIJKL(LCEF)*DENSTY(N3SDIJK)
       GLCDE=GIJKL(LCDE)*DENSTY(N3SDIJK)
       GLCDF=GIJKL(LCDF)*DENSTY(N3SDIJK)
       DO M=1,NORB-1
       MIA=NOTAB(M,IA)
       MIB=NOTAB(M,IB)
       MJC=NOTAB(M,JC)
       MJD=NOTAB(M,JD)
       MKE=NOTAB(M,KE)
       MKF=NOTAB(M,KF)
       M2A=NBTAB(MIA,IA)
       M2B=NBTAB(MIB,IB)
       M2C=NBTAB(MJC,JC)
       M2D=NBTAB(MJD,JD)
       M2E=NBTAB(MKE,KE)
       M2F=NBTAB(MKF,KF)
C       IAM=INDXIJ(IA,MIB)
        IF(IA.GT.MIB) THEN
          IAM = IAA(IA) + MIB
        ELSE
          IAM = IAA(MIB) + IA
        ENDIF
C       IBM=INDXIJ(IB,MIA)
        IF(IB.GT.MIA) THEN
          IBM = IAA(IB) + MIA
        ELSE
          IBM = IAA(MIA) + IB
        ENDIF
C       JCM=INDXIJ(JC,MJD)
        IF(JC.GT.MJD) THEN
          JCM = IAA(JC) + MJD
        ELSE
          JCM = IAA(MJD) + JC
        ENDIF
C       JDM=INDXIJ(JD,MJC)
        IF(JD.GT.MJC) THEN
          JDM = IAA(JD) + MJC
        ELSE
          JDM = IAA(MJC) + JD
        ENDIF
C       KEM=INDXIJ(KE,MKF)
        IF(KE.GT.MKF) THEN
          KEM = IAA(KE) + MKF
        ELSE
          KEM = IAA(MKF) + KE
        ENDIF
C       KFM=INDXIJ(KF,MKE)
        IF(KF.GT.MKE) THEN
          KFM = IAA(KF) + MKE
        ELSE
          KFM = IAA(MKE) + KF
        ENDIF
C
C     3*8 CASES
C
C     (ab|g|cd)<e|f>
C
C        (Lb|g|cd)<M|f>
C      L2AM2E=INDXIJ(L2A,M2E)
       IF(L2A.GT.0.AND.M2E.GT.0) THEN
        IF(L2A.GT.M2E) THEN
          L2AM2E = IAA(L2A) + M2E
        ELSE
          L2AM2E = IAA(M2E) + L2A
        ENDIF
      HESS(L2AM2E)=HESS(L2AM2E)+GLBCD*SIJ(KFM)
       ENDIF
C        (Lb|g|cd)<e|M>
C      L2AM2F=INDXIJ(L2A,M2F)
       IF(L2A.GT.0.AND.M2F.GT.0) THEN
        IF(L2A.GT.M2F) THEN
          L2AM2F = IAA(L2A) + M2F
        ELSE
          L2AM2F = IAA(M2F) + L2A
        ENDIF
      HESS(L2AM2F)=HESS(L2AM2F)+GLBCD*SIJ(KEM)
       ENDIF
C        (aL|g|cd)<M|f>
C      L2BM2E=INDXIJ(L2B,M2E)
       IF(L2B.GT.0.AND.M2E.GT.0) THEN
        IF(L2B.GT.M2E) THEN
          L2BM2E = IAA(L2B) + M2E
        ELSE
          L2BM2E = IAA(M2E) + L2B
        ENDIF
      HESS(L2BM2E)=HESS(L2BM2E)+GLACD*SIJ(KFM)
       ENDIF
C        (aL|g|cd)<e|M>
C      L2BM2F=INDXIJ(L2B,M2F)
       IF(L2B.GT.0.AND.M2F.GT.0) THEN
        IF(L2B.GT.M2F) THEN
          L2BM2F = IAA(L2B) + M2F
        ELSE
          L2BM2F = IAA(M2F) + L2B
        ENDIF
      HESS(L2BM2F)=HESS(L2BM2F)+GLACD*SIJ(KEM)
       ENDIF
C        (ab|g|Ld)<M|f>
C      L2CM2E=INDXIJ(L2C,M2E)
       IF(L2C.GT.0.AND.M2E.GT.0) THEN
        IF(L2C.GT.M2E) THEN
          L2CM2E = IAA(L2C) + M2E
        ELSE
          L2CM2E = IAA(M2E) + L2C
        ENDIF
      HESS(L2CM2E)=HESS(L2CM2E)+GLABD*SIJ(KFM)
       ENDIF
C        (ab|g|Ld)<e|M>
C      L2CM2F=INDXIJ(L2C,M2F)
       IF(L2C.GT.0.AND.M2F.GT.0) THEN
        IF(L2C.GT.M2F) THEN
          L2CM2F = IAA(L2C) + M2F
        ELSE
          L2CM2F = IAA(M2F) + L2C
        ENDIF
      HESS(L2CM2F)=HESS(L2CM2F)+GLABD*SIJ(KEM)
       ENDIF
C        (ab|g|cL)<M|f>
C      L2DM2E=INDXIJ(L2D,M2E)
       IF(L2D.GT.0.AND.M2E.GT.0) THEN
        IF(L2D.GT.M2E) THEN
          L2DM2E = IAA(L2D) + M2E
        ELSE
          L2DM2E = IAA(M2E) + L2D
        ENDIF
      HESS(L2DM2E)=HESS(L2DM2E)+GLABC*SIJ(KFM)
       ENDIF
C        (ab|g|cL)<e|M>
C      L2DM2F=INDXIJ(L2D,M2F)
       IF(L2D.GT.0.AND.M2F.GT.0) THEN
        IF(L2D.GT.M2F) THEN
          L2DM2F = IAA(L2D) + M2F
        ELSE
          L2DM2F = IAA(M2F) + L2D
        ENDIF
      HESS(L2DM2F)=HESS(L2DM2F)+GLABC*SIJ(KEM)
       ENDIF
C
C
C     (ab|g|ef)<c|d>
C
C        (Lb|g|ef)<M|d>
C      L2AM2C=INDXIJ(L2A,M2C)
       IF(L2A.GT.0.AND.M2C.GT.0) THEN
        IF(L2A.GT.M2C) THEN
          L2AM2C = IAA(L2A) + M2C
        ELSE
          L2AM2C = IAA(M2C) + L2A
        ENDIF
      HESS(L2AM2C)=HESS(L2AM2C)+GLBEF*SIJ(JDM)
       ENDIF
C        (Lb|g|ef)<c|M>
C      L2AM2D=INDXIJ(L2A,M2D)
       IF(L2A.GT.0.AND.M2D.GT.0) THEN
        IF(L2A.GT.M2D) THEN
          L2AM2D = IAA(L2A) + M2D
        ELSE
          L2AM2D = IAA(M2D) + L2A
        ENDIF
      HESS(L2AM2D)=HESS(L2AM2D)+GLBEF*SIJ(JCM)
       ENDIF
C        (aL|g|ef)<M|d>
C      L2BM2C=INDXIJ(L2B,M2C)
       IF(L2B.GT.0.AND.M2C.GT.0) THEN
        IF(L2B.GT.M2C) THEN
          L2BM2C = IAA(L2B) + M2C
        ELSE
          L2BM2C = IAA(M2C) + L2B
        ENDIF
      HESS(L2BM2C)=HESS(L2BM2C)+GLAEF*SIJ(JDM)
       ENDIF
C        (aL|g|ef)<c|M>
C      L2BM2D=INDXIJ(L2B,M2D)
       IF(L2B.GT.0.AND.M2D.GT.0) THEN
        IF(L2B.GT.M2D) THEN
          L2BM2D = IAA(L2B) + M2D
        ELSE
          L2BM2D = IAA(M2D) + L2B
        ENDIF
      HESS(L2BM2D)=HESS(L2BM2D)+GLAEF*SIJ(JCM)
       ENDIF
C        (ab|g|Lf)<M|d>
C      L2EM2C=INDXIJ(L2E,M2C)
       IF(L2E.GT.0.AND.M2C.GT.0) THEN
        IF(L2E.GT.M2C) THEN
          L2EM2C = IAA(L2E) + M2C
        ELSE
          L2EM2C = IAA(M2C) + L2E
        ENDIF
      HESS(L2EM2C)=HESS(L2EM2C)+GLABF*SIJ(JDM)
       ENDIF
C        (ab|g|Lf)<c|M>
C      L2EM2D=INDXIJ(L2E,M2D)
       IF(L2E.GT.0.AND.M2D.GT.0) THEN
        IF(L2E.GT.M2D) THEN
          L2EM2D = IAA(L2E) + M2D
        ELSE
          L2EM2D = IAA(M2D) + L2E
        ENDIF
      HESS(L2EM2D)=HESS(L2EM2D)+GLABF*SIJ(JCM)
       ENDIF
C        (ab|g|eL)<M|d>
C      L2FM2C=INDXIJ(L2F,M2C)
       IF(L2F.GT.0.AND.M2C.GT.0) THEN
        IF(L2F.GT.M2C) THEN
          L2FM2C = IAA(L2F) + M2C
        ELSE
          L2FM2C = IAA(M2C) + L2F
        ENDIF
      HESS(L2FM2C)=HESS(L2FM2C)+GLABE*SIJ(JDM)
       ENDIF
C        (ab|g|eL)<c|M>
C      L2FM2D=INDXIJ(L2F,M2D)
       IF(L2F.GT.0.AND.M2D.GT.0) THEN
        IF(L2F.GT.M2D) THEN
          L2FM2D = IAA(L2F) + M2D
        ELSE
          L2FM2D = IAA(M2D) + L2F
        ENDIF
      HESS(L2FM2D)=HESS(L2FM2D)+GLABE*SIJ(JCM)
       ENDIF
C
C     (cd|g|ef)<a|b>
C
C        (Ld|g|ef)<M|b>
C      L2CM2A=INDXIJ(L2C,M2A)
       IF(L2C.GT.0.AND.M2A.GT.0) THEN
        IF(L2C.GT.M2A) THEN
          L2CM2A = IAA(L2C) + M2A
        ELSE
          L2CM2A = IAA(M2A) + L2C
        ENDIF
      HESS(L2CM2A)=HESS(L2CM2A)+GLDEF*SIJ(IBM)
       ENDIF
C        (Ld|g|ef)<a|M>
C      L2CM2B=INDXIJ(L2C,M2B)
       IF(L2C.GT.0.AND.M2B.GT.0) THEN
        IF(L2C.GT.M2B) THEN
          L2CM2B = IAA(L2C) + M2B
        ELSE
          L2CM2B = IAA(M2B) + L2C
        ENDIF
      HESS(L2CM2B)=HESS(L2CM2B)+GLDEF*SIJ(IAM)
       ENDIF
C        (cL|g|ef)<M|b>
C      L2DM2A=INDXIJ(L2D,M2A)
       IF(L2D.GT.0.AND.M2A.GT.0) THEN
        IF(L2D.GT.M2A) THEN
          L2DM2A = IAA(L2D) + M2A
        ELSE
          L2DM2A = IAA(M2A) + L2D
        ENDIF
      HESS(L2DM2A)=HESS(L2DM2A)+GLCEF*SIJ(IBM)
       ENDIF
C        (cL|g|ef)<a|M>
C      L2DM2B=INDXIJ(L2D,M2B)
       IF(L2D.GT.0.AND.M2B.GT.0) THEN
        IF(L2D.GT.M2B) THEN
          L2DM2B = IAA(L2D) + M2B
        ELSE
          L2DM2B = IAA(M2B) + L2D
        ENDIF
      HESS(L2DM2B)=HESS(L2DM2B)+GLCEF*SIJ(IAM)
       ENDIF
C        (cd|g|Lf)<M|b>
C      L2EM2A=INDXIJ(L2E,M2A)
       IF(L2E.GT.0.AND.M2A.GT.0) THEN
        IF(L2E.GT.M2A) THEN
          L2EM2A = IAA(L2E) + M2A
        ELSE
          L2EM2A = IAA(M2A) + L2E
        ENDIF
      HESS(L2EM2A)=HESS(L2EM2A)+GLCDF*SIJ(IBM)
       ENDIF
C        (cd|g|Lf)<a|M>
C      L2EM2B=INDXIJ(L2E,M2B)
       IF(L2E.GT.0.AND.M2B.GT.0) THEN
        IF(L2E.GT.M2B) THEN
          L2EM2B = IAA(L2E) + M2B
        ELSE
          L2EM2B = IAA(M2B) + L2E
        ENDIF
      HESS(L2EM2B)=HESS(L2EM2B)+GLCDF*SIJ(IAM)
       ENDIF
C        (cd|g|eL)<M|b>
C      L2FM2A=INDXIJ(L2F,M2A)
       IF(L2F.GT.0.AND.M2A.GT.0) THEN
        IF(L2F.GT.M2A) THEN
          L2FM2A = IAA(L2F) + M2A
        ELSE
          L2FM2A = IAA(M2A) + L2F
        ENDIF
      HESS(L2FM2A)=HESS(L2FM2A)+GLCDE*SIJ(IBM)
       ENDIF
C        (cd|g|eL)<a|M>
C      L2FM2B=INDXIJ(L2F,M2B)
       IF(L2F.GT.0.AND.M2B.GT.0) THEN
        IF(L2F.GT.M2B) THEN
          L2FM2B = IAA(L2F) + M2B
        ELSE
          L2FM2B = IAA(M2B) + L2F
        ENDIF
      HESS(L2FM2B)=HESS(L2FM2B)+GLCDE*SIJ(IAM)
       ENDIF
        END DO
        END DO
      END DO
      END DO
      END DO
  333 CONTINUE
C
C     HESSIAN: ORBITAL-STRUCTURE BLOCK
C
      DO I=1,NORB2
C      PART 1: <a|b><HAG_N_1>
C      PART 2: <a|h|b><AG_N-1>
C      PART 3: -E<a|b><AG_N-1>
C
      IA=IJMAP(1,I)
      IB=IJMAP(2,I)
       DO K=1,NORB
       KA=NBTAB(K,IA)
       KB=NBTAB(K,IB)
C       IAK=INDXIJ(IA,K)
        IF(IA.GT.K) THEN
          IAK = IAA(IA) + K
        ELSE
          IAK = IAA(K) + IA
        ENDIF
C       IBK=INDXIJ(IB,K)
        IF(IB.GT.K) THEN
          IBK = IAA(IB) + K
        ELSE
          IBK = IAA(K) + IB
        ENDIF
       IF(KA.GT.0) THEN
         DO L=1,NSTR
         LSQI=(L-1)*NORB2+I
         LLKA=(L+NBRIL)*(L+NBRIL-1)/2+KA
         HESS(LLKA)=HESS(LLKA)+SIJ(IBK)*DENSTY(M1HD+LSQI)
     &   +HIJ(IBK)*DENSTY(M1SD+LSQI)-E0*SIJ(IBK)*DENSTY(M1SD+LSQI)
         END DO
       END IF
       IF(KB.GT.0) THEN
         DO L=1,NSTR
         LSQI=(L-1)*NORB2+I
         LLKB=(L+NBRIL)*(L+NBRIL-1)/2+KB
         HESS(LLKB)=HESS(LLKB)+SIJ(IAK)*DENSTY(M1HD+LSQI)
     &   +HIJ(IAK)*DENSTY(M1SD+LSQI)-E0*SIJ(IAK)*DENSTY(M1SD+LSQI)
         END DO
       END IF
       END DO
      END DO
C      PART 4: <ab|g|cd><AG_N-2>
      DO I=1,NORB2
      IA=IJMAP(1,I)
      IB=IJMAP(2,I)
      DO J=1,I
      IC=IJMAP(1,J)
      ID=IJMAP(2,J)
C      IJ=INDXIJ(I,J)
        IF(I.GT.J) THEN
          IJ = IAA(I) + J
        ELSE
          IJ = IAA(J) + I
        ENDIF
       DO K=1,NORB
       KA=NBTAB(K,IA)
       KB=NBTAB(K,IB)
       KC=NBTAB(K,IC)
       KD=NBTAB(K,ID)
C       IAK=INDXIJ(IA,K)
        IF(IA.GT.K) THEN
          IAK = IAA(IA) + K
        ELSE
          IAK = IAA(K) + IA
        ENDIF
C       IBK=INDXIJ(IB,K)
        IF(IB.GT.K) THEN
          IBK = IAA(IB) + K
        ELSE
          IBK = IAA(K) + IB
        ENDIF
C       ICK=INDXIJ(IC,K)
        IF(IC.GT.K) THEN
          ICK = IAA(IC) + K
        ELSE
          ICK = IAA(K) + IC
        ENDIF
C       IDK=INDXIJ(ID,K)
        IF(ID.GT.K) THEN
          IDK = IAA(ID) + K
        ELSE
          IDK = IAA(K) + ID
        ENDIF
C       IABCK=INDXIJ(I,ICK)
        IF(I.GT.ICK) THEN
          IABCK = IAA(I) + ICK
        ELSE
          IABCK = IAA(ICK) + I
        ENDIF
C       IABKD=INDXIJ(I,IDK)
        IF(I.GT.IDK) THEN
          IABKD = IAA(I) + IDK
        ELSE
          IABKD = IAA(IDK) + I
        ENDIF
C       IAKCD=INDXIJ(J,IAK)
        IF(J.GT.IAK) THEN
          IAKCD = IAA(J) + IAK
        ELSE
          IAKCD = IAA(IAK) + J
        ENDIF
C       IKBCD=INDXIJ(J,IBK)
        IF(J.GT.IBK) THEN
          IKBCD = IAA(J) + IBK
        ELSE
          IKBCD = IAA(IBK) + J
        ENDIF
       NORB4=NORB2*(NORB2+1)/2
       LSQ2=M2SD-NORB4
         DO L=1,NSTR
         LL=(L+NBRIL)*(L+NBRIL-1)/2
         LSQ2=LSQ2+NORB4
         IF(KA.GT.0)
     &     HESS(LL+KA)=HESS(LL+KA)+GIJKL(IKBCD)*DENSTY(LSQ2+IJ)
         IF(KB.GT.0)
     &     HESS(LL+KB)=HESS(LL+KB)+GIJKL(IAKCD)*DENSTY(LSQ2+IJ)
         IF(KC.GT.0)
     &     HESS(LL+KC)=HESS(LL+KC)+GIJKL(IABKD)*DENSTY(LSQ2+IJ)
         IF(KD.GT.0)
     &     HESS(LL+KD)=HESS(LL+KD)+GIJKL(IABCK)*DENSTY(LSQ2+IJ)
         END DO
       END DO
      END DO
      END DO
C
C     HESSIAN: STRUCTURE-STRUCTURE BLOCK
C
C     OVS=1/S0 (One_Over_S)
C
      OVS=1.0D0/S0
      IJ=0
      DO I=1,NSTR
      II=(NBRIL+I)*(NBRIL+I-1)/2
      DO J=1,I
      IJ=IJ+1
      IIJJ=II+NBRIL+J
      HESS(IIJJ)=2.0D0*(HRVB(IJ)-E0*SRVB(IJ))
      END DO
      END DO
C     DEBUGLOCATOR
      DO I=1,NBRIL
      II=I*(I+1)/2
      HESS(II)=HESS(II)+HESS(II)
      END DO
C
C     NORMALIZATION AND PRODUCTION ACCUMULATION
C
      IJ=0
      DO I=1,NBRIL+NSTR
      II=I*(I-1)/2
        DO J=1,I
        IJ=IJ+1
        HESS(IJ)=(HESS(IJ)-DEVE(I)*DEVS(J)-DEVE(J)*DEVS(I))*OVS
        END DO
C     WRITE(IOUTVB,1000)(HESS(II+J),J=1,I)
      END DO
 2000 CONTINUE
C
C     DE-FACTORIZE THE NON-DIAGONAL 1D DENSITY MATRIX ELEMENTS
C
      DO I=1,NORB
      II=I*(I-1)/2
      DO J=1,I-1
      DENSTY(II+J)=DENSTY(II+J)*0.5D0
      END DO
      END DO
      DO I=1,NORB2
      DM1(I)=DENSTY(I)
      END DO
C
C     COPY 2D DENSITY MATRIX ELEMENTS
C     NOTE: DM2 IS SYMMTRY FACTOR WEIGHTED. SAME AS DM2 IN VBMATR
C
      DO I=1,NORB2*(NORB2+1)/2
      DM2(I) = DENSTY(N2SD+I)
      END DO
C     TIME1=XCLOCK()-TIME1
C     WRITE(IOUTVB,*)'TIME FOR DER',TIME1
      RETURN
      END
      SUBROUTINE INTEQU(NA,NB,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C     COPY INTEGER ARRAY
C     NA <= NB
C
      DIMENSION NA(*),NB(*)
      DO I=1,N
      NA(I)=NB(I)
      END DO
      RETURN
      END
C
C     This is subroutine to determine the alphabetic order using
C     Three indexes: INDEXA, IDSETB, INDEXB
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     SET UP A TABLE
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE SETABL()
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (NMAX=4,MMAX=200)
      COMMON /ITABLE/TABLE(NMAX,MMAX)
C
C     TABLE(N,M) GIVES THE COMPACT-INDEX OF A DIAGONAL ELEMENT OF
C     N-DIMENSIONAL SYMMETRIC MATRIX WITH ALL SUB-INDEXES EQ TO M
C
      DO 100 I=1,NMAX
        DO 200 J=1,MMAX
        TEMP=0
          DO 300 K=1,J
          TEMP=TEMP+BINOMI(I-1,K-1)*BINOMI(J,K)
  300     CONTINUE
        TABLE(I,J)=TEMP
  200   CONTINUE
  100 CONTINUE
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     BINOMIAL COEFFICIENTS C(N,M),( N>M )
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     INTEGER FUNCTION INOMI(N,M)
      DOUBLE PRECISION FUNCTION BINOMI(N,M)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      TEMP=1.0D0
      DO 100 I=1,M
      TEMP=TEMP*DBLE(N-I+1)/DBLE(I)
  100 CONTINUE
C     INOMI=(TEMP+0.000001)
      BINOMI=TEMP
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     COMPACT INDEX OF N-DIMENSIONAL SYMMETRY MATRIX ELEMENTS
C
C     Jiabo Li
C     April 28,99
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE SETINXN(N,INDX,IDCOMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (NMAX=4,MMAX=200)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /ITABLE/TABLE(NMAX,MMAX)
      DIMENSION INDX(N)
      IF(N.GT.NMAX) WRITE(IOUTVB,101)
 101  FORMAT('N.GT.NMAX')
C
C     SORT INDEX
C
      CALL SHELL2(N,INDX)
C     WRITE(IOUTVB,'(" MMAX=",I5)') MMAX
C     WRITE(IOUTVB,'(" N=",I5)') N
C     DO K=1,N
C     WRITE(IOUTVB,'(" K=",I5)') INDX(K)
C     ENDDO
      IDCOMP=1
      DO 100 K=0,N-1
      ITEMP=INDX(N-K)-1
C       IF(ITEMP.GT.MMAX) THEN
C         CALL ABORT0("MMAX=1000 ")
C       END IF
C       WRITE(IOUTVB,'(" ITEMP=",I5)') ITEMP
        IF(ITEMP.GT.0) THEN
C         WRITE(IOUTVB,*) " IDCOMP=",IDCOMP
          IDCOMP=IDCOMP+INT(TABLE(N-K,ITEMP))
        END IF
C       WRITE(IOUTVB,*) " IDCOMP=",IDCOMP
 100  CONTINUE
      RETURN
      END
      SUBROUTINE SHELL2(N,IX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IX(N)
      IF(N.LE.1) RETURN
      J=N
  5   IF(J.EQ.1) GOTO 20
      J=J/2
      NMJ=N-J
  8   IFLAG=0
      DO 10 I=1,NMJ
      L=I+J
      IF(IX(I).LE.IX(L)) GOTO 10
      ITX=IX(I)
      IX(I)=IX(L)
      IX(L)=ITX
      IFLAG=1
  10  CONTINUE
      IF(IFLAG.EQ.1) GOTO 8
      GOTO 5
 20   RETURN
      END
C
C     NROOTPRT: NUMBER OF ROOTS PRINTED
C
      SUBROUTINE RVB(NSTR,CSTR,VBS,VBH,W,MWRK,F2,FLAG,LASTITER,
     &               MGRP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*50 FLAG
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION CSTR(*),VBS(*),VBH(*),W(*),E(5000)
C     DIMENSION CSTR(*),VBS(*),VBH(*),W(*),E(5000),WEIGHT(5000)
C     DIMENSION CLWD(5000),WEIGHT1(5000),WEIGHT2(5000),WEIGHT3(5000)
C     DIMENSION WEIGHT4(5000)
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      IF(NSTR.GT.5000) CALL ABORT0('TooBigBstr')
      FLAG(4:7)='ROOT'
      NROOT=1
      NROOTPRT = 0
      NW1= 0
      NW2=NW1+NSTR*NSTR
      NW3=NW2+NSTR*NSTR
      NW4=NW3+NSTR*NSTR
      NW5=NW4+NSTR*NSTR
      IF(NW5.GT.MWRK) CALL ABORT0('RVB0000001')
      IJ=0
      DO I=1,NSTR
      DO J=1,NSTR
      IJ=IJ+1
      W(NW1+IJ)=VBH(IJ00(I,J))
      W(NW2+IJ)=VBS(IJ00(I,J))
      END DO
      END DO
      IJ=0
      CALL EG(NSTR,W(NW1+1),W(NW2+1),E,W(NW3+1),W(NW4+1))
C     WRITE(IOUTVB,*)"EIGENVALUES"
C     WRITE(IOUTVB,'(5F15.8)')(E(I),I=1,NSTR)
C
C     READ ROOT NUMBER
C
      CALL LOCTOR(IOENGI,FLAG,7,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*)NROOT
      END IF
      NWROOT=NW3+(NROOT-1)*NSTR
      F2=E(NROOT)
      DO I=1,NSTR
      CSTR(I)=W(NWROOT+I)
      END DO
C
C     SEARCH FOR NROOTS FLAG
      FLAG(4:9)='NROOTP'
C     FLAG(4:9)='NROOTPRT'
      CALL LOCTOR(IOENGI,FLAG,9,IOK,0)
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*)NROOTPRT
      END IF
      IF(NROOTPRT.GT.NSTR) NROOTPRT = NSTR
      IF(NROOTPRT.GT.0) THEN
        WRITE(IOUTVB,*)"EIGENVALUES"
        WRITE(IOUTVB,'(5F15.8)')(E(I),I=1,NROOTPRT)
      ENDIF
C
C
C     POSSIBLE STRUCTURE SYMMETRY
C
      CALL STRSYM(CSTR,NSTR,FLAG)
      CALL LOCTOR(IOENGI,'$PRINTHS',8,IOK,0)
      IF (LASTITER.EQ.1.AND.IOK.EQ.1) THEN
        CALL MPRINT3(NSTR,VBS,VBH,MGRP)
      END IF
C
C     Structure weight analysis
C
      IF (LASTITER.EQ.1.AND.NSTR.GT.1)
     &     CALL STRWEIT(NSTR,CSTR,VBS,W,MWRK)
C1000 FORMAT(1X,I5,F15.10)
      RETURN
      END
      SUBROUTINE STRWEIT(NSTR,CSTR,VBS,W,MWRK)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION CSTR(*),VBS(*),W(*)
      DIMENSION CLWD(5000),WEIGHT1(5000),WEIGHT3(5000)
      DIMENSION WEIGHT4(5000),CSTRN(5000),SHF(5000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      IF(NSTR.GT.5000) CALL ABORT0('TooBigBstr')
      NWSHALF = 0
      LOWDINOLD = 0
      NW1= NWSHALF + NSTR*NSTR
      NW2=NW1+NSTR*NSTR
      NW3=NW2+NSTR*NSTR
      NW4=NW3+NSTR*NSTR
      IF(NW4.GT.MWRK) CALL ABORT0('STRWEIT001')
C
C     CHECK OPTION FOR OLD-LOWDIN FORMULA
C
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,"$OLDLOWDIN",10,LOWDINOLD,0)
      DO I=1, NSTR
        SHF(I) = DSQRT(VBS(IJ00(I,I)))
        IF(LOWDINOLD.EQ.1) SHF(I) = 1.0D0
      END DO
C
C     COMPUTE S-HALF MATRIX
C
      IJ=0
      DO I=1,NSTR
        DO J=1,NSTR
          IJ=IJ+1
          W(NW1+IJ)=SHF(I)*SHF(J)*VBS(IJ00(I,J))
        END DO
      END DO
      CALL SHALFMAT(NSTR,W(NW1+1),W(NWSHALF+1),W(NW2+1),W(NW3+1))
C
C     Mulliken Weights
C
      WSUM = 0.0D0
      DO I=1, NSTR
        WEIGHT1(I)=0.0D0
        SHALF=DSQRT(VBS(IJ00(I,I)))
        CSTRN(I) = CSTR(I)*SHALF
        DO J=1,NSTR
          WEIGHT1(I)=WEIGHT1(I)+CSTR(I)*CSTR(J)*VBS(IJ00(I,J))
        END DO
        WSUM = WSUM + WEIGHT1(I)
      END DO
      DO I=1, NSTR
        WEIGHT1(I) = WEIGHT1(I)/WSUM
      END DO
      WRITE(IOUTVB,*)
      WRITE(IOUTVB,1000)
      WRITE(IOUTVB,'(10F8.4)')(CSTRN(I),I=1,NSTR)
      WRITE(IOUTVB,*)
      WRITE(IOUTVB,1010)
      WRITE(IOUTVB,'(10F8.4)')(WEIGHT1(I),I=1,NSTR)
      WRITE(IOUTVB,*)
C
C     Lowdin Weights
C     CLWD = S-half x CSTR
C
      WSUM = 0.0D0
      DO I=1, NSTR
      CLWD(I) = 0.0D0
        DO J=1, NSTR
          IJ = (J-1)*NSTR + I
          CLWD(I) = CLWD(I) + W(NWSHALF+IJ)*CSTR(J)*SHF(J)
        END DO
        WEIGHT3(I) = CLWD(I)*CLWD(I)
        WSUM = WSUM + WEIGHT3(I)
      END DO
      DO I=1, NSTR
        WEIGHT3(I) = WEIGHT3(I)/WSUM
      END DO
      IF(LOWDINOLD.EQ.1)
     &  WRITE(IOUTVB,'(" OLD LOWDIN WEIGHTS WILL BE PRINTED")')
      WRITE(IOUTVB,1020)
      WRITE(IOUTVB,'(10F8.4)')(WEIGHT3(I),I=1,NSTR)
      WRITE(IOUTVB,*)
C
C     Hiberty Weights
C
      WSUM = 0.0D0
      DO I=1, NSTR
        WEIGHT4(I) = CSTRN(I)**2
        WSUM = WSUM + WEIGHT4(I)
      END DO
      DO I=1, NSTR
        WEIGHT4(I) = WEIGHT4(I)/WSUM
      END DO
      WRITE(IOUTVB,1030)
      WRITE(IOUTVB,'(10F8.4)')(WEIGHT4(I),I=1,NSTR)
      WRITE(IOUTVB,*)
C
 1000 FORMAT(1X,'Normalized structure coefficients')
 1010 FORMAT(1X,'====Mulliken Weight====')
 1020 FORMAT(1X,'====Lowdin   Weight====')
 1030 FORMAT(1X,'====Hiberty  Weight====')
      RETURN
      END
      FUNCTION IJ00(I,J)
      COMMON /IAA/IA(100000)
      IF(I.GT.J) THEN
      IJ00=IA(I)+J
      ELSE
      IJ00=IA(J)+I
      ENDIF
      RETURN
      END
      FUNCTION IJ01(I,J)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /IBB/IB(100000),MWIN,MORBI
      IF(I.GT.J) THEN
        IF(J.LE.MORBI) IJ01=IB(I)+J
        IF(J.GT.MORBI) IJ01=IB(MWIN)+(I-MORBI)*(I-MORBI-1)/2+J
      ELSE
        IF(I.LE.MORBI) IJ01=IB(J)+I
        IF(I.GT.MORBI) IJ01=IB(MWIN)+(J-MORBI)*(J-MORBI-1)/2+I
      ENDIF
      RETURN
      END
      SUBROUTINE SETIAA()
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /IAA/IA(100000)
      IA(1) = 0
      DO I=2,100000
        IA(I) = IA(I-1) + I-1
      END DO
      RETURN
      END
      SUBROUTINE SETIND(M,NORT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /IAA/IA(100000)
      COMMON /IBB/IB(100000),MWIN,MORBI
      COMMON /ICC/IC(100000)
      COMMON /IDD/ID(100000)
      MORBI=NORT
      MWIN=M
      MSQ=IA(M+1)
      NORTSQ=IA(NORT+1)
      DO 104 I=1,NORT
  104 IB(I)=I*(I-1)/2
      DO 105 I=NORT+1,M
  105 IB(I)=IB(NORT)+(I-NORT)*NORT
      IB(M+1)=IB(M)+NORT
      NV=IB(M+1)
      DO 106 I=1,NV+1
  106 IC(I)=(I-1)*NV
      DO 107 I=NV+2,MSQ
  107 IC(I)=IC(NV+1)+(I-NV-1)*NORTSQ
      IC(MSQ+1)=IC(MSQ)+NORTSQ
      DO 108 I=1,NV+1
  108 ID(I)=I*(I-1)/2
      DO 109 I=NV+2,MSQ
  109 ID(I)=ID(NV+1)+(I-NV-1)*NORTSQ
      ID(MSQ+1)=ID(MSQ)+NORTSQ
      RETURN
      END
C
C     JIABO LI
C     DEC. 19, 1998
C     ORBITALS IN ORTHONORMALIZED BASIS FUNCTIONS
C     B IS ORTHONORMALIZED
C     C=<B|S0|A>
C     C->A
C
C     SUBROUTINE BASLOW(NBASIS,NA,NB,S,A,B,C,W,MSIZE,BASLOC,BASNOC)
      SUBROUTINE BASLOW(NBASIS,NA,NB,S,A,B,C,W,MSIZE,BASNOC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION S(NBASIS,NBASIS),A(NBASIS,NA),B(NBASIS,NB)
C     DIMENSION C(NB,*),W(NB,*),BASLOC(*),BASNOC(*)
      DIMENSION C(NB,*),W(NB,*),BASNOC(*)
      IF(MSIZE.LE.NBASIS*NBASIS) CALL ABORT0('BASLOW 001')
C
C     B'->W
C
      DO 100 I=1,NB
      DO 100 J=1,NBASIS
      W(I,J)=B(J,I)
 100  CONTINUE
C
C     <B|S>->C
C
      CALL MATMUL2(NB,NBASIS,NBASIS,W,S,C)
C
C     <C|A>
C
      CALL MATMUL2(NB,NBASIS,NA,C,A,BASNOC)
C
C     C->A
C
C200  CONTINUE
C     CALL INVMAT(NA,BASNOC,BASLOC,W,W(1,NA+1))
C     INVMAT NEEDS TO PUT BACK AS ARGUMENT IF ABOVE IS USED
C     BASLOC NEEDS TO PUT BACK AS ARGUMENT IF ABOVE IS USED
      RETURN
      END
C
C     JIABO LI
C     DEC. 19, 1998
C     PROJECT BASIS FUNCTIONS SET A INTO THE SUBSPACE OF SET B
C     B IS ORTHONORMALIZED
C     C=|B><B|S0|A>
C     C->A
C
      SUBROUTINE PROJEC(NBASIS,NA,NB,S,A,B,C,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION S(NBASIS,NBASIS),A(NBASIS,NA),B(NBASIS,NB)
      DIMENSION C(NBASIS,*),W(NB,*)
C
C     PROJECT A INTO SUBSPACE B
C
C     B'->W
C
      DO 100 I=1,NB
      DO 100 J=1,NBASIS
      W(I,J)=B(J,I)
 100  CONTINUE
C
C     |B><B|--->C
C
      CALL MATMUL2(NBASIS,NB,NBASIS,B,W,C)
C
C     |B><B|S0--->W
C
      CALL MATMUL2(NBASIS,NBASIS,NBASIS,C,S,W)
C
C     <W|A>
C
      CALL MATMUL2(NBASIS,NBASIS,NA,W,A,C)
C
C     C->A
C
      DO 200 I=1,NA
      DO 200 J=1,NBASIS
      A(J,I)=C(J,I)
 200  CONTINUE
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     LOWDIN ORTHOGONALIZATION
C
C     Note:
C               INPUT A(M,NA)
C               OUTPUT V(NA,M), BUT STORED IN V(M,NA) FORMAT !!!
C
C     History:
C               Frist created: Dec. 18, 1998
C               Added automatic correct threshold for ill-conditioned
C               S matrix. Sept. 19,2004
C               Added special case for NA.EQ.1. March 26, 2006
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE LOWD(M,NA,S0,A,SA,V,W, IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      PARAMETER (EPS = -1.0D-12)
      DIMENSION A(M,NA),S0(M,M),D(5000),SA(NA,NA),V(NA,M)
      DIMENSION W(M,*)
      IERR = 0
      IF(M.GT.5000) THEN
        WRITE(IOUTVB,*)'M.GT.5000'
        IERR = 1
        RETURN
      END IF
      IF(NA.EQ.1) THEN
        DO I=1, M
        V(1,I) = A(I,1)
        END DO
        RETURN
      END IF
      IF(NA.GT.M) THEN
        WRITE(IOUTVB,*)'NA.GT.M'
        IERR = 1
C       RETURN
      END IF
      IF (NA.LE.0) RETURN
      DO 300 I=1,M
      DO 300 J=1,NA
      V(J,I)=A(I,J)
 300  CONTINUE
      CALL MATMUL2(M,M,NA,S0,A,W)
      CALL MATMUL2(NA,M,NA,V,W,SA)
      CALL DIAG(SA,V,D,NA,NA)
C
C     SA**(-1/2)
C
      DO 100 I=1,NA
      DO 100 J=1,NA
 100  SA(I,J)=0.0D0
      DO 200 K=1,NA
      IF(D(K).LE.EPS) THEN
      WRITE(IOUTVB,*)'NA,K =',NA,K
      WRITE(IOUTVB,*)"D(K)=",(D(KX),KX=1,10)
      WRITE(IOUTVB,*)'NEGATIVE EIGENVALUES OF S MATRIX D=',D(K)
      IERR = 1
      RETURN
C     CALL ABORT0('LOWDIN02  ')
      END IF
      DK=1.0D0/DSQRT(DABS(D(K)))
      DO 200 I=1,NA
      DO 200 J=1,NA
      SA(I,J)=SA(I,J)+V(I,K)*V(J,K)*DK
 200  CONTINUE
C
C     LOWDIN BASIS ->V
C
      CALL MATMUL2(M,NA,NA,A,SA,V)
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     S**(1/2) matrix
C
C     History:
C               Frist created: Feb 25, 2003
C               Added automatic correct threshold for ill-conditioned
C               S matrix. Sept. 19,2004
C
C     Author:
C               Jiabo Li
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE SHALFMAT(M,S,SHM,W,V)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      PARAMETER (EPS = -1.0D-12)
      DIMENSION S(M,M),SHM(M,M),D(5000),V(M,M)
      DIMENSION W(M,M)
      IF(M.GT.5000) CALL ABORT0('LOWDIN01  ')
      IF (M.LE.0) RETURN
      DO 300 I=1,M
      DO 300 J=1,M
      W(J,I)=S(I,J)
 300  CONTINUE
      CALL DIAG(W,V,D,M,M)
C
C     S**(1/2)
C
      DO 100 I=1,M
      DO 100 J=1,M
 100  SHM(I,J)=0.0D0
      DO 200 K=1,M
      IF(D(K).LE.EPS) THEN
      WRITE(IOUTVB,*)'M =',M
      WRITE(IOUTVB,*)'NEGATIVE EIGENVALUES OF S MATRIX D=',D(K)
      CALL ABORT0('SHALFMAT01')
      END IF
      DK=DSQRT(DABS(D(K)))
      DO 200 I=1,M
      DO 200 J=1,M
      SHM(I,J)=SHM(I,J)+V(I,K)*V(J,K)*DK
 200  CONTINUE
      RETURN
      END
C
C     GET SPH AND NSHP PARTITION OF BASIS SET SPACE
C     NSHBAS: NUMBER OF NON-SPHERICAL/JUNK
C
C     SEE http://en.wikipedia.org/wiki/Table_of_spherical_harmonics
C
      SUBROUTINE GETSPH(M,BFLABE,S,BASSPH,BASNSH,W,NSHBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE(M),BTEMP
      DIMENSION DCS(6,5),FCS(10,7),GCS(15,9)
C     DIMENSION S(M,M),D(5000),BASNSH(M,*),W(*),BASSPH(M,*)
      DIMENSION S(M,M),BASNSH(M,*),W(*),BASSPH(M,*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DENMF3  =   3.8729833462074170D0
      DENMF21 =   1.7320508075688772D0
      DENMG4  =  10.2469507659595980D0
      DENMG31 =   3.8729833462074170D0
      DENMG22 =   3.0000000000000000D0
      DENMG211=   1.7320508075688772D0
C
C     INITIALIZE CARTESIAN TO SPHERICAL HARMONICS TRANSFORMAITON
C
C     Cartesian D: xx,yy,zz,xy,xz,yz
C     SH D: xy,xz,yz,z2,x2-y2
C
      DO I=1, 5
        DO J=1, 6
          DCS(J,I) = 0.0D0
        END DO
      END DO
      DO I=1, 7
        DO J=1, 10
          FCS(J,I) = 0.0D0
        END DO
      END DO
      DO I=1, 9
        DO J=1, 15
          GCS(J,I) = 0.0D0
        END DO
      END DO
      DCS(4,1) = 1.0D0
      DCS(5,2) = 1.0D0
      DCS(6,3) = 1.0D0
      DCS(1,4) = -1.0D0
      DCS(2,4) = -1.0D0
      DCS(3,4) =  2.0D0
      DCS(1,5) =  1.0D0
      DCS(2,5) = -1.0D0
C
C     Cartesian F: xxx,yyy,zzz,xxy,xxz,yyx,yyz,zzx,zzy,xyz
C                   1   2   3   4   5   6   7   8   9  10
C
C     2Z**3-3X**2Z-3Y**2Z
C       3    5       7
C
      FCS(3,1) = 2*DENMF3
      FCS(5,1) = -3*DENMF21
      FCS(7,1) = -3*DENMF21
C
C     3X**2Y-Y**3
C       4    2
C
      FCS(4,2) = 3*DENMF21
      FCS(2,2) = -DENMF3
C
C     X**3-3Y**2X
C       1    6
C
      FCS(6,3) = -3*DENMF21
      FCS(1,3) = DENMF3
C
C     X**2Z-Y**2Z
C       5    7
C
      FCS(5,4) = DENMF21
      FCS(7,4) = -DENMF21
C
C     XYZ
C     10
C
      FCS(10,5) = 1.0D0
C
C     4ZZY-XXY-YYY
C     9     4   2
C
      FCS(9,6) = 4*DENMF21
      FCS(4,6) = -DENMF21
      FCS(2,6) = -DENMF3
C
C     4ZZX-YYX-XXX
C     8     6   1
C
      FCS(8,7) = 4*DENMF21
      FCS(6,7) = -DENMF21
      FCS(1,7) = -DENMF3
C
C     Cartesian G: xxxx,yyyy,zzzz,xxxy,xxxz,yyyx,yyyz,zzzx,zzzy,
C                   1    2    3    4    5    6    7    8    9
C                  xxyy,xxzz,yyzz,xxyz,yyxz,zzxy
C                   10   11   12   13   14   15
C     8*zzzz-24xxzz-24yyzz+6xxyy+3xxxx+3yyyy
C       3      11    12     10    1      2
C
      GCS(1,1) = 3*DENMG4
      GCS(2,1) = 3*DENMG4
      GCS(3,1) = 8*DENMG4
      GCS(10,1) = 6*DENMG22
      GCS(11,1) = -24*DENMG22
      GCS(12,1) = -24*DENMG22
C
C     4xzzz-3xxxz-3yyxz
C       8      5     14
C
      GCS(5,2) =-3*DENMG31
      GCS(8,2) = 4*DENMG31
      GCS(14,2) =-3*DENMG211
C
C     4*yzzz-3yyyz-3xxyz
C       9     7     13
      GCS(7,3) =-3*DENMG31
      GCS(9,3) = 4*DENMG31
      GCS(13,3) =-3*DENMG211
C
C     yyyy - xxxx + 6xxzz - 6yyzz
C      2      1       11      12
C
      GCS(1,4) =-DENMG4
      GCS(2,4) = DENMG4
      GCS(11,4) = 6*DENMG22
      GCS(12,4) =-6*DENMG22
C
C     6zzxy-xxxy-yyyx
C      15    4    6
      GCS(4,5) =-DENMG31
      GCS(6,5) =-DENMG31
      GCS(15,5) = 6*DENMG211
C
C     xxxz-3yyxz
C      5     14
      GCS(5,6) = DENMG31
      GCS(14,6) = -3*DENMG211
C
C     yyyz-3xxyz
C      7    13
      GCS(7,7) = DENMG31
      GCS(13,7) = -3*DENMG211
C
C     xxxx + yyyy -6xxyy
C      1      2     10
      GCS(1,8) = DENMG4
      GCS(2,8) = DENMG4
      GCS(10,8) =-6*DENMG22
C
C     xxxy - yyyx
C       4     6
      GCS(4,9) = DENMG31
      GCS(6,9) =-DENMG31
C
      DO I=1, M
        DO J=1, M
          BASSPH(J,I) = 0.0D0
        ENDDO
      ENDDO
      MSPHHAR = 0
      DO I=1,M
        BTEMP = BFLABE(I)
        IF(BTEMP(10:12).EQ.'  s'.OR.BTEMP(10:12).EQ.'  x'.OR.
     &     BTEMP(10:12).EQ.'  y'.OR.BTEMP(10:12).EQ.'  z') THEN
             MSPHHAR=MSPHHAR+1
             BASSPH(I,MSPHHAR) = 1.0D0
        ELSE IF(BTEMP(10:12).EQ.' xx') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,6
               BASSPH(I+K-1,MSPHHAR) = DCS(K,1)
             END DO
        ELSE IF(BTEMP(10:12).EQ.' yy') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,6
               BASSPH(I+K-2,MSPHHAR) = DCS(K,2)
             END DO
        ELSE IF(BTEMP(10:12).EQ.' zz') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,6
               BASSPH(I+K-3,MSPHHAR) = DCS(K,3)
             END DO
        ELSE IF(BTEMP(10:12).EQ.' xy') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,6
               BASSPH(I+K-4,MSPHHAR) = DCS(K,4)
             END DO
        ELSE IF(BTEMP(10:12).EQ.' xz') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,6
               BASSPH(I+K-5,MSPHHAR) = DCS(K,5)
             END DO
        ELSE IF(BTEMP(10:12).EQ.' yz') THEN
C            SKIP
        ELSE IF(BTEMP(9:12).EQ.' xxx') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,10
               BASSPH(I+K-1,MSPHHAR) = FCS(K,1)
             END DO
        ELSE IF(BTEMP(9:12).EQ.' yyy') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,10
               BASSPH(I+K-2,MSPHHAR) = FCS(K,2)
             END DO
        ELSE IF(BTEMP(9:12).EQ.' zzz') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,10
               BASSPH(I+K-3,MSPHHAR) = FCS(K,3)
             END DO
        ELSE IF(BTEMP(9:12).EQ.' xxy') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,10
               BASSPH(I+K-4,MSPHHAR) = FCS(K,4)
             END DO
        ELSE IF(BTEMP(9:12).EQ.' xxz') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,10
               BASSPH(I+K-5,MSPHHAR) = FCS(K,5)
             END DO
        ELSE IF(BTEMP(9:12).EQ.' yyx') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,10
               BASSPH(I+K-6,MSPHHAR) = FCS(K,6)
             END DO
        ELSE IF(BTEMP(9:12).EQ.' yyz') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,10
               BASSPH(I+K-7,MSPHHAR) = FCS(K,7)
             END DO
        ELSE IF(BTEMP(9:12).EQ.' zzx'.OR.BTEMP(9:12).EQ.' zzy'.OR.
     &          BTEMP(9:12).EQ.' xyz') THEN
C            SKIP
C       G Blocks
        ELSE IF(BTEMP(8:12).EQ.' xxxx') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,15
               BASSPH(I+K-1,MSPHHAR) = GCS(K,1)
             END DO
        ELSE IF(BTEMP(8:12).EQ.' yyyy') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,15
               BASSPH(I+K-2,MSPHHAR) = GCS(K,2)
             END DO
        ELSE IF(BTEMP(8:12).EQ.' zzzz') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,15
               BASSPH(I+K-3,MSPHHAR) = GCS(K,3)
             END DO
        ELSE IF(BTEMP(8:12).EQ.' xxxy') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,15
               BASSPH(I+K-4,MSPHHAR) = GCS(K,4)
             END DO
        ELSE IF(BTEMP(8:12).EQ.' xxxz') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,15
               BASSPH(I+K-5,MSPHHAR) = GCS(K,5)
             END DO
        ELSE IF(BTEMP(8:12).EQ.' yyyx') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,15
               BASSPH(I+K-6,MSPHHAR) = GCS(K,6)
             END DO
        ELSE IF(BTEMP(8:12).EQ.' yyyz') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,15
               BASSPH(I+K-7,MSPHHAR) = GCS(K,7)
             END DO
        ELSE IF(BTEMP(8:12).EQ.' zzzx') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,15
               BASSPH(I+K-8,MSPHHAR) = GCS(K,8)
             END DO
        ELSE IF(BTEMP(8:12).EQ.' zzzy') THEN
             MSPHHAR=MSPHHAR+1
             DO K=1,15
               BASSPH(I+K-9,MSPHHAR) = GCS(K,9)
             END DO
        ELSE IF(BTEMP(8:12).EQ.' xxyy'.OR.BTEMP(8:12).EQ.' xxzz'.OR.
     &          BTEMP(8:12).EQ.' yyzz'.OR.BTEMP(8:12).EQ.' xxyz'.OR.
     &          BTEMP(8:12).EQ.' yyxz'.OR.BTEMP(8:12).EQ.' zzxy') THEN
C            SKIP
        ELSE IF(BTEMP(8:12).EQ.'xxxxx'.OR.BTEMP(8:12).EQ.'   6x') THEN
             WRITE(IOUTVB,100)
             CALL ABORT0("GETSPH0001")
        ELSE
C            The following two lines means skip projection.
             MSPHHAR=MSPHHAR+1
             BASSPH(I,MSPHHAR) = 1.0D0
        END IF
      END DO
 100  FORMAT(" THE SPHER DIRECTIVE IS NOT SUPPORTED FOR h AND i ",
     & "BASIS FUNCTIONS"/," USE THE GAUSSIAN/VB2000 VERSION, AS ",
     & "THIS IS MUCH MORE EFFICIENT",/)
C
      MSHBAS = MSPHHAR
      CALL SHMIDT2(M,MSHBAS,BASSPH,S,NB,W)
      IF(MSHBAS.NE.NB) CALL ABORT0("GETSPH0002")
      NSHBAS = M - NB
C
C     COPY BACK TO BASSPH FROM W
C
      DO I=1, MSHBAS
        IM = (I-1)*M
        DO J=1, M
          BASSPH(J,I) = W(IM+J)
        END DO
      END DO
      DO I=1, NSHBAS
        DO J=1, M
          BASNSH(J,I) = VBRAND(0)
        END DO
      END DO
      CALL ORTHAB(M,MSHBAS,NSHBAS,S,BASSPH,BASNSH,W)
      CALL SHMIDT2(M,NSHBAS,BASNSH,S,NB,W)
      DO I=1, NSHBAS
        IM = (I-1)*M
        DO J=1, M
          BASNSH(J,I) = W(IM+J)
        END DO
      END DO
      RETURN
      END
C
C     GET NUMBER OF NON-SPHERICAL HARMONIC COUNT
C
      SUBROUTINE COUNTNSP(M,BFLABE,NSHBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE(M),BTEMP
      NSHBAS = 0
      DO I=1,M
        BTEMP = BFLABE(I)
        IF (BTEMP(10:12).EQ.' xx') THEN
             NSHBAS = NSHBAS + 1
        ELSE IF (BTEMP(9:12).EQ.' xxx') THEN
             NSHBAS = NSHBAS + 3
        ELSE IF (BTEMP(8:12).EQ.' xxxx') THEN
             NSHBAS = NSHBAS + 6
C       h 
C       ELSE IF (BTEMP(7:12).eq.' xxxxx') THEN
C            NSHBAS = NSHBAS + 10
C       i 
C       ELSE IF (BTEMP(10:12).eq.' x6') THEN
C            NSHBAS = NSHBAS + 15
C       Make sure it is consistent with GETSPH
        END IF
      END DO
      RETURN
      END
C
C     JIABO LI
C     NOV. 24, 1998
C     ORBITAL SET B ORTHOGONALIZED TO ORBITAL SET A
C     SET A REMAINS UNCHANGED
C
      SUBROUTINE ORTHAB(M,NA,NB,S0,A,B,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(M,*),B(M,*),S0(M,M),D(5000),W(M,M)
      IF(M.GT.5000) CALL ABORT0('ORTHAB01  ')
      IF(NA.LE.0.OR.NB.LE.0) RETURN
C
C     COPY A-->W
C
      DO 350 I=1,NA
      DO 350 J=1,M
      W(J,I)=A(J,I)
  350 CONTINUE
C
C     CALL SCHMIDT FOR THE FIRST NA ORBITALS IN WORK FIELD
C
      CALL SHMIDT(M,NA,W,S0)
      DO 300 I=1,NB
      DO 310 J=1,M
      D(J)=0.0D0
      DO 310 K=1,M
 310  D(J)=D(J)+S0(K,J)*B(K,I)
      DO 315 J=1,NA
      SUM=0.0D0
      DO 320 K=1,M
 320  SUM=SUM+D(K)*W(K,J)
      DO 340 K=1,M
 340  B(K,I)=B(K,I)-SUM*W(K,J)
 315  CONTINUE
 300  CONTINUE
      RETURN
      END
C
C     JIABO LI
C     NOV. 24, 2005
C     ORBITAL SET A ORTHOGONALIZED AND STORED IN B
C     SET A REMAINS UNCHANGED
C
      SUBROUTINE SETNORB(M,NSUB,MLORBIT,MNORBIT,BASIS,S0,B,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION BASIS(M,*),S0(M,M),B(M,*),W(M,*)
      DIMENSION MLORBIT(*),MNORBIT(*)
      IF(M.GT.5000) CALL ABORT0('SETNORB001')
      NAT=0
      NBT=0
      DO I=1, NSUB
      NA = MLORBIT(I)
      CALL SHMIDT2(M,NA,BASIS(1,NAT+1),S0,NB,W)
      DO 300 J=1,NB
      NBT = NBT + 1
      DO 310 K=1,M
 310  B(K,NBT) = W(K,J)
 300  CONTINUE
      NAT = NAT + MLORBIT(I)
      MNORBIT(I) = NB
      END DO
      RETURN
      END
C
C     JIABO LI
C     DEC. 16, 2005
C     ORBITAL SET A ORTHOGONALIZED AND STORED IN B
C     IT IS ASSUMED THAT THE RANK OF BASIS IS NBASIS, I.E. IT CONTAINS
C     M LINEARLY INDEPNDENT VECTORS
C
C     SET A REMAINS UNCHANGED
C
      SUBROUTINE SETNORB2(M,NSUB,MLORBIT,MNORBIT,BASIS,S0,B,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION BASIS(M,*),S0(M,M),B(M,*),W(M,*)
      DIMENSION MLORBIT(*),MNORBIT(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      IF(M.GT.5000) CALL ABORT0('SETNORB001')
      NAT=0
      NBT=0
      DO I=1, NSUB
      NA = MLORBIT(I)
      CALL SHMIDT2(M,NA,BASIS(1,NAT+1),S0,NB,W)
      DO 300 J=1,NB
      NBT = NBT + 1
      DO 310 K=1,M
 310  B(K,NBT) = W(K,J)
 300  CONTINUE
      NAT = NAT + MLORBIT(I)
      IF(MNORBIT(I).NE.NB) THEN
        WRITE(IOUTVB,*)"I, NB, MNORBIT =",I,NB, MNORBIT(I)
C       CALL ABORT0("SETNORB201")
      END IF
      END DO
C
      NVIR = M - NBT
      MLORBIT(NSUB+1) = NVIR
      MNORBIT(NSUB+1) = NVIR
      NA = NVIR
      IF(NVIR.LT.1) GOTO 400
      CALL SHMIDT2(M,NA,BASIS(1,NAT+1),S0,NB,W)
      DO 301 J=1,NB
      NBT = NBT + 1
      DO 311 K=1,M
 311  B(K,NBT) = W(K,J)
 301  CONTINUE
      IF(NB.NE.NVIR) CALL ABORT0("SETNORB202")
 400  CONTINUE
      RETURN
      END
C
C     JIABO LI
C     NOV. 24, 1998
C
C     THE SUBROUTINE IS CALLED TO PERFORM SCHMIDT ORTHONORMALIZATION
C
C     A: VECTORS OF OBRITALS, CONSISTS OF NA ORBITALS NEED TO BE
C        ORTHONORMALIZED
C
      SUBROUTINE SHMIDT(M,NA,A,S0)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      PARAMETER (EPS=10.0D0**(-10))
      DIMENSION A(M,*),S0(M,M),D(5000)
      IF(M.GT.5000) CALL ABORT0('SCHMIDT01 ')
      IF(NA.LE.0) RETURN
C
C     NORMALIZATION OF THE FIRST ORBITAL
C
      SUM=0.0D0
      DO 100 L=1,M
      DO 100 K=1,M
 100  SUM=SUM+A(K,1)*S0(K,L)*A(L,1)
      SUM=DSQRT(SUM)
      DO 110 I=1,M
 110  A(I,1)=A(I,1)/SUM
C
C     ORTHOGONALIZATION OF THE REMAINING ORBITALS
C
      DO 200 I=2,NA
      DO 210 J=1,M
      D(J)=0.0D0
      DO 210 K=1,M
  210 D(J)=D(J)+S0(K,J)*A(K,I)
      DO 220 J=1,I-1
      SUM=0.D0
      DO 230 K=1,M
 230  SUM=SUM+D(K)*A(K,J)
      DO 240 K=1,M
 240  A(K,I)=A(K,I)-SUM*A(K,J)
 220  CONTINUE
C
C     NORMALIZATION
C
      SUM=0.0D0
      DO 250 L=1,M
      DO 250 K=1,M
 250  SUM=SUM+A(K,I)*S0(K,L)*A(L,I)
      SUM=DSQRT(SUM)
      IF(SUM.LT.EPS) THEN
      WRITE(IOUTVB,*)'WARNING: SUM<EPS in SCHMIDT'
      END IF
      DO 260 J=1,M
 260  A(J,I)=A(J,I)/SUM
 200  CONTINUE
      RETURN
      END
C
C     JIABO LI
C     NOV. 24, 2005
C
C     THE SUBROUTINE IS CALLED TO PERFORM SCHMIDT ORTHONORMALIZATION
C
C     A: VECTORS OF OBRITALS, CONSISTS OF NA ORBITALS NEED TO BE
C        ORTHONORMALIZED
C     B: STORE ORTHONORMALIZED VECTORS. LINEAR DEPENDENT VECTORS ARE
C        REMOVED
C
C     August 8 2009 JLI: IMPROVED NUMERICAL STABILITY BY RE-NORMALIZATION
C
      SUBROUTINE SHMIDT2(M,NA,A,S0,NB,B)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      PARAMETER (EPS=1.0D-8)
      DIMENSION A(M,*),S0(M,M),D(5000),B(M,*)
      IF(M.GT.5000) CALL ABORT0('SCHMIDT01 ')
      IF(NA.LE.0) RETURN
      NB = 0
      DO 200 I=1,NA
      NB1 = NB + 1
        DO 210 J=1,M
        D(J)=0.0D0
        B(J,NB1) = A(J,I)
        DO 210 K=1,M
  210   D(J)=D(J)+S0(K,J)*A(K,I)
        DO 220 J=1,NB
        SUM=0.D0
        DO 230 K=1,M
 230    SUM=SUM+D(K)*B(K,J)
        DO 240 K=1,M
 240    B(K,NB1)=B(K,NB1)-SUM*B(K,J)
 220    CONTINUE
C
C     NORMALIZATION
C
        SUM=0.0D0
        DO 250 L=1,M
        DO 250 K=1,M
 250    SUM=SUM+B(K,NB1)*S0(K,L)*B(L,NB1)
        SUM=DSQRT(SUM)
        IF(SUM.LT.EPS) THEN
        WRITE(IOUTVB,*)'LINEAR DEPENDENT VECTOR IDENTIFIED'
        ELSE
        DO 260 J=1,M
 260    B(J,NB1)=B(J,NB1)/SUM
C
C       DO ANOTHER PROJECTION TO REMOVE NUMERICAL ROUNDOFF ERROR,
C       ESPECIALLY FOR SMALL NORMAL VALUE
C
        DO 211 J=1,M
        D(J)=0.0D0
        DO 211 K=1,M
  211   D(J)=D(J)+S0(K,J)*B(K,NB1)
        DO 221 J=1,NB
        SUM=0.D0
        DO 231 K=1,M
 231    SUM=SUM+D(K)*B(K,J)
        DO 241 K=1,M
 241    B(K,NB1)=B(K,NB1)-SUM*B(K,J)
 221    CONTINUE
C
C       RE-NORMALIZATION
C
        SUM=0.0D0
        DO 251 L=1,M
        DO 251 K=1,M
 251    SUM=SUM+B(K,NB1)*S0(K,L)*B(L,NB1)
        SUM=DSQRT(SUM)
        DO 261 J=1,M
 261    B(J,NB1)=B(J,NB1)/SUM
        NB = NB1
        END IF
 200  CONTINUE
      RETURN
      END
C     A GENERAL SUBROUTINE FOR ONE- AND TWO-ELECTRON INTEGRAL
C     TRANSFORMATION. FOR THE 4-INDEX(TWO-ELECTRON INTEGRALS) TRANSFORMATION,
C     THE N**5 ALGORITHM IS USED.
C
C     ON ENTRY:
C
C     M:   TOTAL NUMBER OF BASIS FUNCTIONS
C     NA:  NUMBER OF ORBITALS OF A SUBSYSTEM(E.G. VB ORBITALS)
C          THIS SUBROUTINE ASSUMES THAT THE NA ORBITALS ARE ORTHOGONAL TO
C          THE ORBITALS OF OTHER SUBSYSTEMS (E.G.CORE ORBITALS),BUT MAY NOT
C          BE ORTHOGONAL AMONG THEMSELF. THE NA ORBITALS ARE STORED IN
C          ARRAY A.
C     NB:  NUMBER OF VIRTUAL ORBITALS
C          THOSE ORBITALS ARE NOT OCCUPIED BY ANY ELECTRONS. THUS THEY ARE
C          ORTHOGONALIZD TO ALL USED ORBITALS
C          M = NOTHER + NA + NB
C          (IF ONLY SINGLE POINT ENERGY IS CALCULATED, ONE CAN SET NB=0)
C          (NOTHER: THE NUMBER OF ORBITALS OF ALL OTHER SUBSYSTEMS)
C
C     A:   VECTORS FOR ALL M ORBITALS AS LINEAR COMBINATIONS OF
C          THE M BASIS FUNCTIONS. THE ORBITALS ARE STORED IN THE ARRAY IN
C
C     S0:  OVERLAP IN GLOBAL AO BASIS FUNCTIONS
C     F0:  HAMILTONIAN IN GLOBAL AO BASIS FUNCTIONS
C     G0:  TWO-ELECTRON INTEGRALS IN GLOBAL AO BASIS FUNCTIONS
C
C     ON EXIT:
C
C     ECORE: CORE ELECTRON ENERGY OF THE DOUBLE-OCCUPIED ORBITALS
C     S0:  OVERLAP IN ORBITALS AFTER PROJECTION FROM ALL USED ORBITALS OF OTHER
C          SUBSYSTEMS (INCLUDING CORE ORBITALS)
C     F0:  HAMILTONIAN IN ORBITAL BASIS AFTER PROJECTION
C     GW:  WORK BUFFER FOR NEW TWO-ELCTRON INTEGRALS IN OBRITAL BASIS
C          ALL NEW 2-E INTEGRALS ARE STORED ON DISK.
C          THIS ROUTINE PERFORMS PARTIAL INTEGRAL TRANSFORMATION, SINCE
C          FOR UPDATING VB ORBITALS, A FULL TRANSFORMATION IS NOT NECESSARY
C          ANY 4-INDEX INTEGRAL INVOLVES THREE OR FOUR INDECES OF VIRTUAL
C          ORBITALS IS NOT USED, THEREFORE THOSE INTEGRALS ARE NOT CALCULATED
C          NOR STORED IN THE DISK FILE.
C
C          ONE CAN ALLWAYS PERFORM A FULL TRANSFORMATION BY ASSUME ALL ORBITALS
C          ARE USED (I.E. NA=M)
C
C     CORRESPONDING TO SUCH A PARTITIONING, THE TWO-ELECTRON
C     INTEGRALS G(I,J,K,L) ARE ALSO DIVIDED INTO TWO PARTS:
C     PART I: M >= I >= 1, NA >= J >=1; IJ>= KL   (I>J; K>L)
C     PART II:M >= I,J >= 1, AND NA >= K,L      (I>J; K>L)
C
C     PART I:
C     SECTION A: I,J <=NA; K,L<=NA, and IJ>=KL
C     SECTION B: I>NA,J<=NA, K,L<=NA
C     SECTION C: I>NA,J<=NA,K>NA,L<=NA,K<I
C
C     PART II:
C     SECTION D: I,J>NA, K,L<=NA
C     STORAGE: (A+B+C)+D
C
C     THE INTEGRALS ARE STORED IN THE FOLLOWING WAY:
C
C     *****************************************************
C      *   A   |           *                              *
C        *   PART I        *           PART II            *
C          *   |     B     *             D                *
C            * |           *                              *
C              * - - - - - ********************************
C                *         *
C                  *   C   *
C                    *     *
C                      *   *
C                        * *
C                          *
C
C     BY ASSUMING NA=M AND NB=0, THEN FULL TRANSFORMATION WILL BE
C     PERFORMED AND THE NEW INTEGRALS WILL BE STORED IN THE USUAL
C     CARNONICAL ORDER
C
C     BUFFER SIZE IS LBUFF. THE NEW INTEGRALS ARE WRITTEN ON A DISK FILE
C
C     Jiabo Li, Revision history:NOV.25,1993 (first version)
C                                APR.05,1994 (partial integral transformation)
C                                FEB.28,1998 (re-organized)
C                                JUL.01,1998 (separate COREDM and TRAN)
C                                JAN.21,1999 (COREDM removed)
C                                SEP.06,1999 (simplified and reorganized)
C                                JAN.06,2000 (S and H matrixes are exported)
C                                APR.21,2004 (TRANN-> TRAN1E and TRANN2E)
C                                JUN.02,2004 clean up
C
      SUBROUTINE TRANN2E(M,NA,NB,G0,A,P,W,PSQ,LBUFF,IOUT2E)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER(NEXTRA=20)
      DIMENSION G0(*),A(M,M),P(M,M),PSQ(*),W(*)
      DIMENSION DC1(2047),GW(10000),IJKLW(10000)
      COMMON /IAA/IA(100000)
      MSQ=M*(M+1)/2
      IF(MSQ.GT.100000.OR.NA+NB.GT.M+NEXTRA) CALL ABORT0('TRAN2E0001')
      IF(LBUFF.GT.4095) CALL ABORT0('TRAN2E0002')
      NAB=NA+NB
C     NSQ=NAB*(NAB+1)/2
C
C     THE N**5 ALGORITHM FOR THE FOUR-INDEX TRANSFORMATION
C
      IJKLS=0
C     MM=M*M
      DO 100 L=1,NA
      DO 110 IJ=1,MSQ
      IAIJ=IA(IJ)
      DO 120 K1=1,IJ
 120  PSQ(K1)=G0(IAIJ+K1)
      DO 121 K1=IJ+1,MSQ
 121  PSQ(K1)=G0(IA(K1)+IJ)
      CALL MALTSQ(M,MSQ,PSQ,DC1,A(1,L))
      LL=L
      DO 130 K=LL,NAB
      XX=0.0D0
      KK=K
      DO 135 KX=1,M
  135 XX=XX+DC1(KX)*A(KX,KK)
      W((K-1)*IA(M+1)+IJ)=XX
 130  CONTINUE
 110  CONTINUE
      DO 100 K=LL,NAB
      KK=(K-1)*MSQ
      DO 220 K1=1,M
      K1JJ=IA(K1)+KK
      DO 221 K2=1,K1
 221  P(K2,K1)=W(K1JJ+K2)
      K1JJ=K1+KK
      DO 222 K2=K1+1,M
 222  P(K2,K1)=W(IA(K2)+K1JJ)
 220  CONTINUE
      J1=1
      J2=NAB
      IF(K.GT.NA) J2=NA
      DO 100 J=J1,J2
      CALL MALTID(M,P,DC1,A(1,J))
      II=J
      IF(K.GT.J) II=K
      IF(J.LT.L) II=K+1
      DO 100 I=II,NAB
      XX=0.0D0
      DO 235 KX=1,M
  235 XX=XX+DC1(KX)*A(KX,I)
      IJKLS=IJKLS+1
      IJKLW(IJKLS)=IJKLGX(I,J,K,L)
      GW(IJKLS)=XX
      IF(IJKLS.GE.LBUFF) THEN
      WRITE(IOUT2E)(IJKLW(KKK),GW(KKK),KKK=1,LBUFF)
      IJKLS=0
      END IF
 100  CONTINUE
      IF(IJKLS.NE.0) WRITE(IOUT2E)(IJKLW(KKK),GW(KKK),KKK=1,IJKLS)
      RETURN
      END
C
C     1E INTEGRAL TRANSFORMATION WITH EFFECTIVE HF POTENTIAL (IF IHFPO=1)
C
      SUBROUTINE TRAN1E(M,NAB,S0,F0,A,P,W,PSQ,IHFPO,IOUT2E)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION S0(*),F0(*),A(*),P(*),PSQ(*),W(*)
      MSQ=M*(M+1)/2
      NSQ=NAB*(NAB+1)/2
      IF(IHFPO.EQ.1) THEN
      CALL FKENGI(W,PSQ,M,1)
        DO I=1,MSQ
        F0(I) = W(I) + F0(I)
        END DO
      END IF
C
      CALL MATRAN(M,NAB,A,P,F0,W)
      DO I=1,NSQ
      F0(I) = W(I)
      END DO
C
C     GET THE NEW OVERLAP MATRIX ELEMENTS
C
      CALL MATRAN(M,NAB,A,P,S0,W)
      DO I=1,NSQ
      S0(I)=W(I)
      END DO
      WRITE(IOUT2E)(S0(I),I=1,NSQ)
      WRITE(IOUT2E)(F0(I),I=1,NSQ)
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Integral-driven 2E transformation.
C
C     Note:
C               Scratch space size can be calculated by the following formula
C               KLMX   = NORB*(NORB+1)/2+NORB*NVIR
C               NTINT  = KLMX*(KLMX+1)/2 + NORB*(NORB+1)*NVIR*(NVIR+1)/4
C               NWNEED = MAX(NTINT,MSQ*NBASIS)
C
C     History:
C               First created in April, 2004
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE TRANP2E(NBASIS,NORB,NVIR,A,W,NWRK,LBUFF,
     &                   IOTEMPA,IOTEMPB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(NBASIS,NORB),W(NWRK)
C     DIMENSION IB(2000),DC1(2047),GW(33334),IJKLW(33334)
      DIMENSION IB(2000),GW(33334),IJKLW(33334)
      GW(1) = 0.0D0
C     IJKLW(1) = 0.0D0
      IJKLW(1) = 0
      MSQ   = NBASIS*(NBASIS+1)/2
      IF(NBASIS.GT.2000) CALL ABORT0('TRANP2E001')
      DO I=1,NORB+1
      IB(I)=I*(I-1)/2
      END DO
      MORB = NORB + NVIR
      DO I=NORB+1,MORB+1
      IB(I) = IB(I-1) + NORB
      END DO
      KLMX   = NORB*(NORB+1)/2+NORB*NVIR
      NTINT  = KLMX*(KLMX+1)/2 + NORB*(NORB+1)*NVIR*(NVIR+1)/4
      NWNEED = MAX(NTINT,MSQ*NBASIS)
      IF(NWNEED.GT.NWRK) CALL ABORT0('TRANP2E000')
C
C     Transfer the first index
C
      MINWRK = NBASIS*MSQ
      NGWRK  = NWRK/MINWRK
      NG     = NGWRK
      NORBSTA= 0
      REWIND(IOTEMPA)
C     TIME=XCLOCK()
      IF(NGWRK.LT.1) CALL ABORT0('TRAN2E0002')
  10  IF(NORBSTA+NG.GT.NORB) NG = NORB - NORBSTA
      NORBSTA1= NORBSTA+1
C     NW      = NG*MINWRK
      NGNB    = NG*NBASIS
      CALL TRANSP1(NBASIS,MSQ,NG,A(1,NORBSTA1),W)
      CALL WRT2EP1(NBASIS,MSQ,NGNB,NORBSTA,LBUFF,W,IOTEMPA)
      NORBSTA = NORBSTA + NG
      IF(NORBSTA.LT.NORB) GOTO 10
C     TIME1 = XCLOCK()
C     WRITE(IOUTVB,*)'TRANSP1 TIME = ',TIME1-TIME
C
C     WRITE A EMPTY RECORD TO TERMINATE THE INTEGRALS
C
      NWORD = 0
      WRITE(IOTEMPA)(GW(I),I=1,LBUFF),(IJKLW(I),I=1,LBUFF*2),NWORD
C
C     Transfer the second index
C
      MINWRK = MSQ
      NGWRK  = NWRK/MINWRK
      NG     = NGWRK
      NSQ    = IB(MORB+1)
      NSQSTA = 0
      REWIND(IOTEMPA)
      REWIND(IOTEMPB)
      IF(NGWRK.LT.1) CALL ABORT0('TRAN2E0003')
  20  IF(NSQSTA+NG.GT.NSQ) NG = NSQ - NSQSTA
C     NSQSTA1= NSQSTA+1
C     NW     = NG*MINWRK
      CALL TRANSP2(NBASIS,MORB,MSQ,IB,NSQSTA,NG,A,W,LBUFF,
     &             IOTEMPA)
      CALL WRT2EP2(MSQ,NG,NSQSTA,LBUFF,W,IOTEMPB)
      NSQSTA = NSQSTA + NG
      IF(NSQSTA.LT.NSQ) GOTO 20
C
C     WRITE A EMPTY RECORD TO TERMINATE THE INTEGRALS
C
      NWORD = 0
      WRITE(IOTEMPB)(GW(I),I=1,LBUFF),(IJKLW(I),I=1,LBUFF*2),NWORD
C     TIME = XCLOCK()
C
C     Transfer the third index
C
      MINWRK = NBASIS*IB(MORB+1)
      NGWRK  = NWRK/MINWRK
      NG     = NGWRK
      NORBSTA= 0
      REWIND(IOTEMPA)
      REWIND(IOTEMPB)
      IF(NGWRK.LT.1) CALL ABORT0('TRAN2E0004')
  30  IF(NORBSTA+NG.GT.MORB) NG = MORB - NORBSTA
      NORBSTA1= NORBSTA+1
C     NW      = NG*MINWRK
      CALL TRANSP3(NBASIS,KLMX,NG,A(1,NORBSTA1),W,
     &             LBUFF,IOTEMPB)
      CALL WRT2EP3(NBASIS,KLMX,NG,NORBSTA,LBUFF,W,IOTEMPA)
      NORBSTA = NORBSTA + NG
      IF(NORBSTA.LT.MORB) GOTO 30
      NWORD = 0
      WRITE(IOTEMPA)(GW(I),I=1,LBUFF),(IJKLW(I),I=1,LBUFF*2),NWORD
C
C     Transfer the 4-th index
C
C     TOTAL INTEGRALS
C
C     NTINT  = KLMX*(KLMX+1)/2 + NORB*(NORB+1)*NVIR*(NVIR+1)/4
      IF(NTINT.GT.NWRK) CALL ABORT0('TRAN2PX000')
      CALL GETIOUNIT('IVBO2E  ',IVBO2E)
      REWIND(IOTEMPA)
      REWIND(IOTEMPB)
      REWIND(IVBO2E)
      CALL TRANSP4(NBASIS,NORB,MORB,A,W,NTINT,LBUFF,IOTEMPA)
      CALL GWRTE(W,NTINT,LBUFF,IVBO2E)
C     TIME = XCLOCK()
C     WRITE(IOUTVB,*)'TRANSP4 TIME = ',TIME-TIME1
C
      RETURN
      END
C
C     TRANSFORMATION OF THE FIRST INDEXES
C     IA,JA,KA,LA - > IO,JA,KA,LA
C
C     STORAGE OF INTEGRAL (IO,JA | KA,LA): W(KLA,IOJA)
C     WHERE IOJA = (IO-1)*NBASIS + JA
C           KLA  = KA*(KA-1)/2 + LA
C
      SUBROUTINE TRANSP1(NBASIS,MSQ,NG,C,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
CGMS  COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      DIMENSION C(NBASIS,NG),W(MSQ,NBASIS*NG)
      DIMENSION IAA(2000),GG(100000)
      DIMENSION II(100000),JJ(100000),KK(100000),LL(100000)
      DO I=1, NBASIS+1
      IAA(I) = I*(I-1)/2
      END DO
      CALL GETIOUNIT('IAO2E   ',IAO2E)
C000  REWIND(IAO2E)
CGAU  REWIND(IAO2E)
CSMI  REWIND(10)
CSMI  REWIND(11)
CGMS  REWIND(IS)
      DO J=1, NBASIS*NG
        DO I=1, MSQ
        W(I,J) = 0.0D0
        END DO
      END DO
 10   CONTINUE
      CALL IJKLGG(IAO2E,GG,II,JJ,KK,LL,NINT)
C     WRITE(6,*) 'OUT OF IJKLGG IN TRANSP1 WITH NINT =',NINT
C
C     ASSUME IA,JA,KA,LA ARE SORTED
C
      DO IJKL=1, NINT
      IA  = II(IJKL)
      JA  = JJ(IJKL)
      KA  = KK(IJKL)
      LA  = LL(IJKL)
      VAL = GG(IJKL)
      IJA = IAA(IA)+JA
      KLA = IAA(KA)+LA
C
C     LOOP OVER ALL ORBITALS
C
        MM = JA - NBASIS
        DO IO=1, NG
          MM = MM+NBASIS
          W(KLA,MM) = W(KLA,MM) + C(IA,IO)*VAL
        END DO
        IF(IA.NE.JA) THEN
          MM = IA - NBASIS
          DO IO=1, NG
          MM = MM + NBASIS
          W(KLA,MM) = W(KLA,MM) + C(JA,IO)*VAL
          END DO
        END IF
        IF(IJA.NE.KLA) THEN
          MM = LA - NBASIS
          DO IO=1, NG
          MM = MM + NBASIS
          W(IJA,MM) = W(IJA,MM) + C(KA,IO)*VAL
          END DO
          IF(KA.NE.LA) THEN
            MM = KA - NBASIS
            DO IO=1, NG
            MM = MM + NBASIS
            W(IJA,MM) = W(IJA,MM) + C(LA,IO)*VAL
            END DO
          END IF
        END IF
      END DO
      IF(NINT.NE.0) GOTO 10
CGMS  REWIND(IS)
C
C     TEST THE FIRST INDEX TRANS
C
C     CALL TRANDD1(NBASIS,NORB,C,W,W(1,NBASIS*NG+1),MSQ)
      RETURN
      END
      SUBROUTINE WRT2EP1(NBASIS,MSQ,NGNB,NORBSTA,LBUFF,W,IOTEMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION W(MSQ,NGNB),GW(33334),IJW(33334),KLW(33334)
      EPS = 1.0D-10
      IF(LBUFF.GT.4095) CALL ABORT0('WRT2EP1002')
      NINT=0
      DO J=1, NGNB
        DO I=1, MSQ
        IF(ABS(W(I,J)).GT.EPS) THEN
        NINT = NINT + 1
        GW(NINT) = W(I,J)
        IJW(NINT)= I
        KLW(NINT)= J+NORBSTA*NBASIS
        END IF
        IF(NINT.GE.LBUFF) THEN
        WRITE(IOTEMP)(GW(K),K=1,LBUFF),(IJW(K),K=1,LBUFF),
     &               (KLW(K),K=1,LBUFF),NINT
        NINT = 0
        END IF
        END DO
      END DO
      IF(NINT.GT.0) THEN
      WRITE(IOTEMP)(GW(K),K=1,LBUFF),(IJW(K),K=1,LBUFF),
     &             (KLW(K),K=1,LBUFF),NINT
      END IF
      RETURN
      END
C
C     TRANSFORMATION OF THE SECOND INDEXES
C     IA,JA,KA,LO - > IA,JA,KO,LO
C
C     STORAGE OF INTEGRAL (IA,JA | KO,LO): W(KLO,IJA)
C     WHERE IJA = IJ00(IA,JA)
C           KLO = IA(KO) + LO
C           SKIP IF NSQSTA >= KLO > NSQSTA+NG
C
      SUBROUTINE TRANSP2(NBASIS,MORB,MSQ,IB,NSQSTA,NG,C,W,
     &                   LBUFF,IOTEMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION C(NBASIS,*),W(MSQ,*)
      DIMENSION IB(*),IJW(33334),KLW(33334),GW(33334),IJTAB(2,100000)
      REWIND(IOTEMP)
      IJMX = NBASIS*(NBASIS+1)/2
      IF(IJMX.GT.100000)  CALL ABORT0('TRANSP2001')
      IF(LBUFF.GT.4095)  CALL ABORT0('TRANSP2001')
      DO IJ = 1, IJMX
      CALL DECODEIJ(IJ,IA,JA)
      IJTAB(1,IJ) = IA
      IJTAB(2,IJ) = JA
      END DO
      DO J=1, NG
        DO I=1, MSQ
        W(I,J) = 0.0D0
        END DO
      END DO
 10   CONTINUE
      READ(IOTEMP)(GW(K),K=1,LBUFF),(IJW(K),K=1,LBUFF),
     &            (KLW(K),K=1,LBUFF),NINT
      DO IJKL=1, NINT
      LO  = (KLW(IJKL)-1)/NBASIS + 1
      KA  = KLW(IJKL)-(LO-1)*NBASIS
      IJA = IJW(IJKL)
      VAL = GW(IJKL)
      IA = IJTAB(1,IJA)
      JA = IJTAB(2,IJA)
C
C     LOOP OVER ALL ORBITALS
C
        DO KO=LO, MORB
          KLO = IB(KO) + LO - NSQSTA
          IF(KLO.LE.NG.AND.KLO.GT.0) THEN
             W(IJA,KLO)=W(IJA,KLO)+C(KA,KO)*VAL
          END IF
        END DO
C 100 CONTINUE
C
      END DO
      IF(NINT.GT.0) GOTO 10
C
C     TEST SECOND INDEX
C
C     CALL TRANDD2(NBASIS,NORB,MORB,C,W,W(1,NG+1),MSQ)
      RETURN
      END
      SUBROUTINE WRT2EP2(MSQ,NG,NSQSTA,LBUFF,W,IOTEMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION W(MSQ,NG),GW(33334),IJW(33334),KLW(33334)
      EPS = 1.0D-10
      IF(LBUFF.GT.4095) CALL ABORT0('WRT2E20002')
      NINT=0
      DO J=1, NG
        DO I=1, MSQ
        IF(ABS(W(I,J)).GT.EPS) THEN
        NINT = NINT + 1
        GW(NINT) = W(I,J)
        IJW(NINT)= I
        KLW(NINT)= J+NSQSTA
        END IF
        IF(NINT.GE.LBUFF) THEN
        WRITE(IOTEMP)(GW(K),K=1,LBUFF),(IJW(K),K=1,LBUFF),
     &               (KLW(K),K=1,LBUFF),NINT
        NINT = 0
        END IF
        END DO
      END DO
      IF(NINT.GT.0) THEN
      WRITE(IOTEMP)(GW(K),K=1,LBUFF),(IJW(K),K=1,LBUFF),
     &             (KLW(K),K=1,LBUFF),NINT
      END IF
      RETURN
      END
C
C     TRANSFORMATION OF THE THIRD INDEXES
C     IO,JO,KA,LA - > IO,JO,KO,LA
C
C     STORAGE OF INTEGRAL (IO,JO | KO,LA): W(KOLA,IJO)
C     WHERE IJO = IJOO(IO,JO)
C           KOLA= (KO-1)*NORB + LA
C
      SUBROUTINE TRANSP3(NBASIS,KLMX,NG,C,W,LBUFF,IOTEMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION C(NBASIS,*),W(NG*NBASIS,KLMX)
C     DIMENSION IAA(*),IJW(33334),KLW(33334),GW(33334),IJTAB(2,100000)
      DIMENSION IJW(33334),KLW(33334),GW(33334),IJTAB(2,100000)
      MSQ = NBASIS*(NBASIS+1)/2
C     NSQ = IAA(MORB+1)
C     ARGUMENTS NEED ADDING BACK IF ABOVE IS EVER USED
      REWIND(IOTEMP)
      DO IJ = 1, MSQ
      CALL DECODEIJ(IJ,IA,JA)
      IJTAB(1,IJ) = IA
      IJTAB(2,IJ) = JA
      END DO
      IF(MSQ.GT.100000)  CALL ABORT0('TRANSP3001')
      IF(LBUFF.GT.4095) CALL ABORT0('TRANSP3002')
      DO J=1, KLMX
        DO I=1, NG*NBASIS
        W(I,J) = 0.0D0
        END DO
      END DO
 10   CONTINUE
C     TIME = XCLOCK()
      READ(IOTEMP)(GW(K),K=1,LBUFF),(IJW(K),K=1,LBUFF),
     &            (KLW(K),K=1,LBUFF),NINT
C     TIME1 = XCLOCK()
      DO IJKL=1, NINT
      KLO = KLW(IJKL)
      IJA = IJW(IJKL)
      VAL = GW(IJKL)
      IA  = IJTAB(1,IJA)
      JA  = IJTAB(2,IJA)
C
C     LOOP OVER ALL ORBITALS
C
      IAJO = IA - NBASIS
      JAJO = JA - NBASIS
        DO JO=1, NG
          IAJO = IAJO + NBASIS
          W(IAJO,KLO) = W(IAJO,KLO) + C(JA,JO)*VAL
          IF(IA.NE.JA) THEN
          JAJO = JAJO + NBASIS
          W(JAJO,KLO) = W(JAJO,KLO) + C(IA,JO)*VAL
          END IF
        END DO
C 101 CONTINUE
C 100 CONTINUE
C
      END DO
C     TIME  = XCLOCK()
      IF(NINT.GT.0) GOTO 10
C
C     TEST SECOND INDEX
C
C     CALL TRANDD3(NBASIS,NORB,MORB,NG,KLMX,C,W,W(1,NG*NBASIS+1),MSQ)
      RETURN
      END
C
C     STORAGE OF INTEGRAL (IO,JO | KO,LA): W(KOLA,IJO)
C     W(NG*NBASIS,NORB*(NORB+1)/2)
C
      SUBROUTINE WRT2EP3(NBASIS,KLMX,NG,NORBSTA,LBUFF,W,IOTEMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION W(NG*NBASIS,KLMX),GW(33334),IJW(33334),KLW(33334)
      EPS = 1.0D-10
      IF(LBUFF.GT.4095) CALL ABORT0('WRT2E30002')
      NINT=0
      DO J=1, KLMX
        DO I=1, NG*NBASIS
        IF(ABS(W(I,J)).GT.EPS) THEN
        NINT = NINT + 1
        GW(NINT) = W(I,J)
        KLW(NINT)= J
        IJW(NINT)= I + NORBSTA*NBASIS
        END IF
        IF(NINT.GE.LBUFF) THEN
        WRITE(IOTEMP)(GW(K),K=1,LBUFF),(IJW(K),K=1,LBUFF),
     &               (KLW(K),K=1,LBUFF),NINT
        NINT = 0
        END IF
        END DO
      END DO
      IF(NINT.GT.0) THEN
      WRITE(IOTEMP)(GW(K),K=1,LBUFF),(IJW(K),K=1,LBUFF),
     &             (KLW(K),K=1,LBUFF),NINT
      END IF
      RETURN
      END
C
C     TRANSFORMATION OF THE THIRD INDEXES
C     IO,JO,KO,LA - > IO,JO,KO,LO
C
C     STORAGE OF INTEGRAL (IO,JO | KO,LO): W(KLO,IJO)
C     WHERE IJO = IJOO(IO,JO)
C           KLO = IJ00(KO,LO)
C
      SUBROUTINE TRANSP4(NBASIS,NORB,MORB,C,W,NTINT,LBUFF,IOTEMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION C(NBASIS,*),W(NTINT)
      DIMENSION IB(10000),MA(100000),MB(100000),IJW(33334)
      DIMENSION KLW(33334),GW(33334)
C     MSQ = NBASIS*(NBASIS+1)/2
      DO I=1, 10000
      MA(I) = I*(I-1)/2
      END DO
      DO I=1, NORB
      IB(I) = I*(I-1)/2
      END DO
      DO I=NORB+1,MORB+1
      IB(I) = IB(I-1) + NORB
      END DO
      KLN = IB(NORB+1)
      IJN = IB(MORB+1)
      IF(IJN.GT.100000) CALL ABORT0('TRANS2P401')
      DO I=1, IJN+1
      MB(I) = I*(I-1)/2
      END DO
      REWIND(IOTEMP)
      IF(LBUFF.GT.4095) CALL ABORT0('TRANS2P401')
      DO I=1, NTINT
      W(I) = 0.0D0
      END DO
 10   CONTINUE
      READ(IOTEMP)(GW(K),K=1,LBUFF),(IJW(K),K=1,LBUFF),
     &            (KLW(K),K=1,LBUFF),NINT
      DO I=1, NINT
      IAJO = IJW(I)
      KLO  = KLW(I)
      VAL  = GW(I)
C
C     DECODE IAJO
C
      JO  = (IAJO-1)/NBASIS + 1
      IA  = IAJO - (JO-1)*NBASIS
C
C     DECODE KLO
C
      IF(KLO.LE.KLN) THEN
      CALL DECODEIJ(KLO,KO,LO)
      ELSE
      KO = (KLO-KLN)/NORB + 1
      LO = KLO-KLN - (KO-1)*NORB
      KO = KO + NORB
      END IF
C
C     VERIFY DECODE KLO
C
      IF(KLO.NE.(IB(KO)+LO)) CALL ABORT0('DECODEKLO0')
      IF(JO.GT.NORB.AND.KO.GT.NORB) GOTO 100
C
C     LOOP OVER ALL ORBITALS
C
        DO IO=JO,MORB
          IF(JO.LE.NORB) THEN
          IJO = IB(IO) + JO
          IJKLO = MA(IJO) + KLO
          ELSE
          IJX = (IO-NORB)*(IO-NORB-1)/2 + JO-NORB
          IJO = IJN + IJX
          IJKLO = MB(IJN+1) + (IJX-1)*KLN + KLO
          END IF
          IF(KLO.LE.IJO) W(IJKLO)=W(IJKLO)+C(IA,IO)*VAL
        END DO
  100 CONTINUE
C
      END DO
      IF(NINT.GT.0) GOTO 10
      RETURN
      END
      SUBROUTINE NRDATER(N,DEV,HESS,ER,ERMAX,ERCTL,W,RDAMP,EPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION HESS(*),DEV(*),ER(*),W(*),DV1(5000)
      IF(N.GT.5000) CALL ABORT0('NRDATER01 ')
      BETA=RDAMP
      IF(BETA.LE.0.0D0) BETA=1.0D-1
C
C     COPY HESSIAN and DERIVATIVE TO WORK FIELDS
C
      DEVM=0.0D0
      DO J=1,N
      DV1(J)=-DEV(J)
      IF(DABS(DEV(J)).GT.DEVM) DEVM=DABS(DEV(J))
      END DO
      DO I=1,N
      II=(I-1)*N
      DO J=1,N
      IJ=II+J
      W(IJ)=HESS(IJ00(I,J))
      END DO
      END DO
      NVEC=1
      CALL GAUSSE(N,W,DV1,NFC,NVEC)
      IF(NFC.GT.0) THEN
 100     BETA=BETA*2
         WRITE(IOUTVB,*)'NEGATIVE EIG. OF HESS. NFC=',NFC,N,BETA
         DO I=1,N
         II=(I-1)*N
         DO J=1,N
         IJ=II+J
         W(IJ)=HESS(IJ00(I,J))
         END DO
         END DO
         DO J=1,N
         W((J-1)*N+J)=HESS(IJ00(J,J))+BETA
         END DO
         CALL GAUSSE(N,W,DV1,NFC,NVEC)
         IF(NFC.GT.0) GOTO 100
      END IF
      CALL SOLVEA(N,W,DV1,ER,NVEC)
C
C     ERROR CONTROL
C
      CALL ERCHEK(N,ERMAX,ERCTL,ER)
      EPT=0.0D0
      DO I=1,N
      EPT=EPT+DEV(I)*ER(I)
      END DO
      DO I=1,N
      DO J=1,N
      EPT=EPT+0.5D0*ER(I)*HESS(IJ00(I,J))*ER(J)
      END DO
      END DO
C     WRITE(IOUTVB,*)'EPT =',EPT
      RETURN
      END
      SUBROUTINE NRDATE(N,DEV,HESS,ER,ERMAX,ERCTL,W,RDAMP,
     &                  SEIG,EPT,F1,F2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION HESS(*),DEV(*),ER(*),W(*),DV1(5000)
      IF(N.GT.5000) CALL ABORT0('NRDATE01  ')
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      HESSCONST = 0.0D0
      CALL LOCTOR(IOENGI,"$HESSCONST",10,IOK,0)
      IF(IOK.EQ.1) THEN
        READ(IOENGI,*)HESSCONST
      ENDIF
C
C     CHECK PERFORMANCE
C     AND DYNAMIC ADJUSTMENT
C
      IF(EPT.EQ.0.0D0) THEN
      RAT=0.65D0
      ELSE
      RAT=(F2-F1)/EPT
      END IF
C
C     USE THE CHANGE of MAXDEV to adjust BETA
C
      IF(RAT.GT.0.85D0) RDAMP=RDAMP/2.00D0
      IF(RAT.LT.0.55D0) RDAMP=3.0D0*RDAMP
      F1=F2
      BETA=RDAMP
C
C     COPY HESSIAN and DERIVATIVE TO WORK FIELDS
C
      DEVM=0.0D0
      DO J=1,N
      DV1(J)=-DEV(J)
      IF(DABS(DEV(J)).GT.DEVM) DEVM=DABS(DEV(J))
      END DO
      RDEVM=DEVM/DABS(SEIG)
      IF(SEIG.GT.0.0D0.AND.RAT.GT.0.65D0.AND.RDEVM.LT.1.0D0) BETA=0.0D0
      IF(HESSCONST .GT. 0.0D0) BETA = HESSCONST
      DO I=1,N
      II=(I-1)*N
      DO J=1,N
      IJ=II+J
      W(IJ)=HESS(IJ00(I,J))
      END DO
      END DO
      DO J=1,N
      W((J-1)*N+J)=HESS(IJ00(J,J))+BETA
      END DO
      NVEC=1
      CALL GAUSSE(N,W,DV1,NFC,NVEC)
      CALL SOLVEA(N,W,DV1,ER,NVEC)
C
C     ERROR CONTROL
C
      CALL ERCHEK(N,ERMAX,ERCTL,ER)
      EPT=0.0D0
      DO I=1,N
      EPT=EPT+DEV(I)*ER(I)
      END DO
      DO I=1,N
      DO J=1,N
      EPT=EPT+0.5D0*ER(I)*HESS(IJ00(I,J))*ER(J)
      END DO
      END DO
      RETURN
      END
C
C     Stabilized Newton-Raphson method (v3) based on Goldfeld, Quandt, and
C     Trotter.
C
C     Jiabo Li, Feb., 2000. San Diego
C
      SUBROUTINE NRGQT3(N,DEV,HESS,ER,ERMAX,ERCTL,W,RGQT,BGQT,
     &                  SEIG,EPT,F1,F2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DIMENSION HESS(*),DEV(*),ER(*),W(*),DV1(5000)
      IF(N.GT.5000) CALL ABORT0('NRGQT01   ')
      WRITE(IOUTVB,*)'NRGQT3 IS CALLED'
C
C     CHECK PERFORMANCE
C     AND DYNAMIC ADJUSTMENT
C
      IF(EPT.EQ.0.0D0) THEN
      RAT=0.65D0
      ELSE
      RAT=(F2-F1)/EPT
      END IF
      IF(RAT.GT.0.90D0) RGQT=RGQT/2.0D0
      IF(RAT.LT.0.60D0.OR.F2-F1.GT.0.0D0) RGQT=RGQT*3.0D0
      F1=F2
C
C     Compute alpha
C
      G=0.0D0
      D=0.0D0
      DO I=1,N
      G=G+DEV(I)*DEV(I)
      D=D+ER(I)*ER(I)
      END DO
      G=DSQRT(G)
      ALPHA=RGQT*G
      IF(SEIG.LT.0.0D0) ALPHA=ALPHA+DABS(SEIG)
      BETA =BGQT*BGQT-1.0D0
C
C     COPY HESSIAN and DERIVATIVE TO WORK FIELDS
C     ADD MODIFICATION TO HESSIAN (+ alpha*Q)
C
      DO J=1,N
      DV1(J)=-DEV(J)
      END DO
      DO I=1,N
      II=(I-1)*N
      DO J=1,N
      IJ=II+J
      IF(EPT.EQ.0.0D0)  THEN
      W(IJ)=HESS(IJ00(I,J))
      ELSE
      W(IJ)=HESS(IJ00(I,J)) + ALPHA*BETA*ER(I)*ER(J)/D
      END IF
      END DO
      W(II+I)=W(II+I) + ALPHA
      END DO
      NVEC=1
      CALL GAUSSE(N,W,DV1,NFC,NVEC)
      IF(NFC.GT.0) THEN
      WRITE(IOUTVB,*)'NEGATIVE EIG. OF HESS. NFC=',NFC
      RGQT=RGQT*10.0D0
C     CALL ABORT0('NRGQT301  ')
      END IF
      CALL SOLVEA(N,W,DV1,ER,NVEC)
C
C     ERROR CONTROL
C
      CALL ERCHEK(N,ERMAX,ERCTL,ER)
      EPT=0.0D0
      DO I=1,N
      EPT=EPT+DEV(I)*ER(I)
      END DO
      DO I=1,N
      DO J=1,N
      EPT=EPT+0.5D0*ER(I)*HESS(IJ00(I,J))*ER(J)
      END DO
      END DO
      RETURN
      END
      SUBROUTINE GAUSSE(N,A,V,NFC,M)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(N,N),V(N,*)
C
C     GAUSSIAN ELIMINATION
C     NFC:   # OF NEGATIVE EIGENVALUES OF MATRIX A
C
      NFC=0
      IF(N.LE.0) RETURN
      DO I=1,N-1
      IF(A(I,I).LE.0.0D0) NFC=NFC+1
C
C     DO ELIMINATION
C
          DO J=I+1,N
          EX=A(J,I)/A(I,I)
          A(J,I)=0.0D0
            DO K=1,M
            V(J,K)=V(J,K)-V(I,K)*EX
            END DO
            DO K=I+1,N
            A(J,K)=A(J,K)-A(I,K)*EX
            END DO
          END DO
      END DO
      IF(A(N,N).LE.0.0D0) NFC=NFC+1
      RETURN
      END
      SUBROUTINE SOLVEA(N,A,V,C,M)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(N,N),C(N,*),V(N,*)
      DO 100 I=1,M
      DO 200 J=N,1,-1
      SUM=V(J,I)
      DO 300 K=J+1,N
 300  SUM=SUM-A(J,K)*C(K,I)
 200  C(J,I)=SUM/A(J,J)
 100  CONTINUE
      RETURN
      END
C
C     SOLVE EQ
C     A*B=U
C
      SUBROUTINE SOLVER(N,A,B,U,W,M)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(N,N),B(N,N),U(N,N),W(N,N)
      DO 200 I=1,N
      DO 100 J=1,N
      W(I,J)=A(I,J)
 100  CONTINUE
      W(I,I)=W(I,I)
 200  CONTINUE
      CALL GAUSSE(N,W,U,NFC,M)
      CALL SOLVEA(N,W,U,B,M)
      RETURN
      END
      SUBROUTINE ERCHEK(N,ERMAX,ERCTL,ER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION ER(N)
      ERMAX=0.0D0
      DO 100 I=1,N
      IF(ERMAX.LT.DABS(ER(I))) ERMAX=DABS(ER(I))
 100  CONTINUE
      IF(ERMAX.GT.ERCTL) THEN
      SCALE=ERCTL/ERMAX
      DO 200 I=1,N
      ER(I)=ER(I)*SCALE
 200  CONTINUE
      ERMAX=ERCTL
      END IF
      RETURN
      END
      SUBROUTINE BASTRN(NBASIS,NSUB,MLORBIT,MNORBIT,BASIS,S,W,MSIZE,
     &   BASLAO,BASNOC,NONADD)
C    &   BASLOC,LOWADD,BASLAO,BASNOC,NONADD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION S(*),BASIS(NBASIS,*),W(*),MLORBIT(*),MNORBIT(*)
C     DIMENSION BASLAO(*),BASLOC(*),LOWADD(*)
      DIMENSION BASLAO(*)
      DIMENSION BASNOC(*),NONADD(*)
C     DIMENSION BASX(100)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      NORBIT=0
      DO 100 I=1,NSUB
      NORBIT=NORBIT+MLORBIT(I)
 100  CONTINUE
C
      NSS=1
      NSA=NSS+NBASIS*NBASIS
      NV =NSA+NBASIS*NBASIS
      NW =NV +NBASIS*NBASIS
      NWK=NW +NBASIS*NBASIS
C     NW1=NSA
      MSIZEA=MSIZE-NWK+1
C
C     S->W(NSS)
C
      DO 200 I=1,NBASIS
      II=NSS-1+(I-1)*NBASIS
      DO 200 J=1,NBASIS
      W(II+J)=S(IJ00(I,J))
 200  CONTINUE
C
C     Lowdin orthogonalization of all occupied orbitals
C
C     CALL LOWD(NBASIS,NORBIT,W(NSS),BASIS,W(NSA),W(NV),W(NW),IERR)
      CALL SETNORB2(NBASIS,NSUB,MLORBIT,MNORBIT,BASIS,W(NSS),W(NV),
     &              W(NW))
C     IF(IERR.EQ.1) CALL ABORT0('BASTRN01  ')
C
C     EXPRESS ORBITALS IN LOWDIN BASIS FUNCTIONS
C
      NORBIT =1
      NORBITX=1
      DO 300 K=1,NSUB
      NB=(NORBITX-1)*NBASIS+NV
      MK=MLORBIT(K)
      MX=MNORBIT(K)
      CALL BASLOW(NBASIS,MK,MX,W(NSS),BASIS(1,NORBIT),W(NB),W(NW),
     &            W(NWK),MSIZEA,BASNOC(NONADD(K)))
C    &            W(NWK),MSIZEA,BASLOC(LOWADD(K)),BASNOC(NONADD(K)))
      NORBIT =NORBIT +MK
      NORBITX=NORBITX+MX
 300  CONTINUE
C
C     STORE LOWDIN BASIS FUNCTIONS IN TRNMAT FOR LATER USE
C     STORE LOWDIN ORBITALS (IN AO BASIS) IN BASLAO FOR LATER USE
C
C     DO 400 I=1,(NORBITX-1)*NBASIS
      DO 400 I=1,NBASIS*NBASIS
      II=1+(I-1)/NBASIS
      J=I-(II-1)*NBASIS
      BASLAO(I)=W(NV-1+I)
 400  CONTINUE
C
C     ASSUME THAT THE VIRTUAL ORBITALS IN BASIS ARE ORTHOGONALIZED !
C     OTHERWISE, DO SOME TREATMENT TO ENFORCE IT.
C
C     DO 410 I=(NORBITX-1)*NBASIS+1,NBASIS*NBASIS
C     II=1+(I-1)/NBASIS
C     J=I-(II-1)*NBASIS
C410  BASLAO(I)=BASIS(J,II)
C
C     TEST ORTHOGONALITY
C
      CALL ORTHTE(NBASIS,NBASIS,BASLAO,W(NSS),OERROR,0)
      IF(OERROR.GT.0.000001D0) THEN
      WRITE(IOUTVB,*)'WARNING: ORTHOGONALITY ERROR B =',OERROR
C     CALL ABORT0('ORTHTEST01')
      END IF
      RETURN
      END
      SUBROUTINE ORTHTE(NBASIS,NTORB,BASIS,S,OERROR,IFLAG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION BASIS(NBASIS,NTORB),S(*)
      OERROR=0.0D0
      DO 100 I=2,NTORB
      DO 100 J=1,I-1
         SUM=0.0D0
         DO 110 K=1,NBASIS
         DO 110 L=1,NBASIS
         KL=(L-1)*NBASIS+K
         IF(IFLAG.EQ.1) KL=IJ00(K,L)
         SUM=SUM+S(KL)*BASIS(K,I)*BASIS(L,J)
 110     CONTINUE
      OERROR=OERROR+DABS(SUM)
 100  CONTINUE
      RETURN
      END
      SUBROUTINE INIBAS(NBASIS,NSUB,MLORBIT,MNORBIT,METHOD,NBALL,
     &                  BASIS,S,V,W,CNORM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION S(*),BASIS(NBASIS,*),V(NBASIS,*),W(*),MLORBIT(*)
      DIMENSION MNORBIT(*),METHOD(*),CNORM(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      NORBIT =0
      NORBITX=0
      DO 100 I=1,NSUB
      NORBIT =NORBIT+ MLORBIT(I)
      NORBITX=NORBITX+MNORBIT(I)
 100  CONTINUE
      NVIR=NBALL-NORBITX
      NOB=NORBITX+1
C
C
      NSS=1
      NSA=NSS+NBASIS*NBASIS
      NV =NSA+NBASIS*NBASIS
      NW =NV +NBASIS*NBASIS
      NWK=NW +NBASIS*NBASIS
      NW1=NSA
C
C     S->W(NSS)
C
      DO 200 I=1,NBASIS
      II=(I-1)*NBASIS
      DO 200 J=1,NBASIS
      W(II+J)=S(IJ00(I,J))
 200  CONTINUE
C
C     Orthogonalize virtual orbitals to all occupied orbitals.
C
C     Special handling: MELE(NSUB)=0 group, already orth to others,
C     skip it. Treat orbitals in MELE(NUSB)=0 group as junk.
C
C
      NORBITXX = NORBITX
      IF(METHOD(NSUB).GT.10) NORBITXX = NORBITX-MLORBIT(NSUB)
      IF(NVIR.GT.0) THEN
        CALL ORTHAB(NBASIS,NORBITXX,NVIR,W(NSS),V,V(1,NOB),W(NW1))
      ENDIF
C
C     Lowdin orthogonalization of all occupied orbitals
C
      CALL LOWD(NBASIS,NORBITXX,W(NSS),V,W(NSA),W(NV),W(NW),IERR)
C     IF(IERR.EQ.1) CALL ABORT0('INIBAS01  ')
      IF(IERR.EQ.1) WRITE(IOUTVB,*)"ERROR in LOWD IN INIBAS01"
C
C     COPY W(NV) -> V
C     ORTHOGONAL
C
      DO I=1, NORBITX
      DO J=1, NBASIS
      IJ = (I-1)*NBASIS + J - 1
      V(J,I) = W(NV + IJ)
      END DO
      END DO
C
C     PROJECTION
C     |Wi><Wi|ORBITLAS>  (Wi: the subspace of a subunit)
C
      NORBIT =1
      NORBITX=1
      DO 300 K=1,NSUB
      NB=(NORBITX-1)*NBASIS+NV
      MK=MLORBIT(K)
      MX=MNORBIT(K)
      IF(METHOD(K).EQ.1) THEN
        CALL CPYVEC(MK*NBASIS,W(NB),BASIS(1,NORBIT))
      ELSE IF(METHOD(K).GT.10) THEN
        CALL CPYVEC(MK*NBASIS,BASIS(1,NORBIT),W(NB))
      ELSE
        CALL PROJEC(NBASIS,MK,MX,W(NSS),BASIS(1,NORBIT),W(NB),W(NW),
     &            W(NWK))
      END IF
      NORBIT =NORBIT+ MLORBIT(K)
      NORBITX=NORBITX+MNORBIT(K)
 300  CONTINUE
C
C     COPY VIRTURAL ORBITALS V -> BASIS
C
      DO I=1, NVIR
        DO J=1, NBASIS
        BASIS(J,NORBIT+I-1) = V(J,NORBITX+I-1)
        END DO
      END DO
C
C     NORMALIZATION
C
      DO 350 K=1,NORBIT-1
      SUM=0.0D0
      DO 360 I=1,NBASIS
      DO 360 J=1,NBASIS
      SUM=SUM+BASIS(I,K)*S(IJ00(I,J))*BASIS(J,K)
  360 CONTINUE
      SUM=DSQRT(SUM)
      CNORM(K)=SUM
      DO 370 I=1,NBASIS
      BASIS(I,K)=BASIS(I,K)/SUM
  370 CONTINUE
  350 CONTINUE
C
C     Lowdin orthogonalization of virtual orbitals.
C     Restore orthogogality keep minimal changes for each orbital
C
C     IF(NVIR.GT.1) THEN
      CALL LOWD(NBASIS,NVIR,W(NSS),BASIS(1,NORBIT),W(NSA),W(NV),W(NW),
     &            IERR)
C     ELSE IF(NVIR.EQ.1) THEN
C       DO I=1, NBASIS
C       W(NV-1+I) = BASIS(I,NORBIT)
C       END DO
C     END IF
      IF(IERR.EQ.1) CALL ABORT0('INIBAS02  ')
      DO 400 I=1,NVIR
      II=(NORBIT+I-1)
      IIX=(NORBITX+I-1)
      INBA=(I-1)*NBASIS
      DO 400 J=1,NBASIS
      BASIS(J,II)= W(NV-1+INBA+J)
      V(J,IIX)   = W(NV-1+INBA+J)
 400  CONTINUE
      RETURN
      END
      SUBROUTINE VBONORM(NBASIS,MLORBIT,BASIS,S,CNORM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION S(*),BASIS(NBASIS,*),CNORM(*)
C
C     NORMALIZATION
C
      DO 350 K=1,MLORBIT
      SUM=0.0D0
      DO 360 I=1,NBASIS
      DO 360 J=1,NBASIS
      SUM=SUM+BASIS(I,K)*S(IJ00(I,J))*BASIS(J,K)
  360 CONTINUE
      SUM=DSQRT(SUM)
      CNORM(K)=SUM
      DO 370 I=1,NBASIS
      BASIS(I,K)=BASIS(I,K)/SUM
  370 CONTINUE
  350 CONTINUE
      RETURN
      END
      SUBROUTINE RNCSTR(NSTR,CSTR,XFACTOR,CNORM,N,NPHI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION CSTR(NSTR),XFACTOR(NSTR),CNORM(*),NPHI(N,*)
      DO I=1,NSTR
      FACTOR=1.0D0
        DO J=1,N
        FACTOR=FACTOR*CNORM(NPHI(J,I))
        END DO
      XFACTOR(I) = FACTOR
      CSTR(I)=CSTR(I)*FACTOR
      END DO
      RETURN
      END
C
C     SORT ERROR VECTORS
C     Jiabo Li
C     First version:   Oct. 1994, Erlangen
C     Second revision: Nov. 1998, Minneapolis
C     Third revision:  Jan. 2000, San Diego
C                      Added ORBLOC
C     Fourth revision: Feb. 2000, San Diego
C                      Simplified and reorganized
C     Fifth revision:  May 29, 2006, San Diego
C                      Replaced by VBDIIS
C     Sixth revision   May 29 2009 San Diego
C                      Expand the array size
C
      SUBROUTINE VBDIISINIT(NDIISM,NDIISTART,SS,MSQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION SS(*)
      COMMON /VBODIIS/VBOS(40000),VBODIIS(100000),ERRDIIS(100000),
     &                NDIISMAX,NDIIS,NDIISS,JUNK
      IF(MSQ.GT.40000) CALL ABORT0('VBDIISINIT')
      DO I=1, MSQ
      VBOS(I) = SS(I)
      END DO
      NDIISMAX = NDIISM
      NDIISS   = NDIISTART
      NDIIS    = 0
      RETURN
      END
C
C     DIIS FOR ORBITAL UPDATE
C
      SUBROUTINE VBDIIS(N,L,M,NBRIL,INDX,B,BASIS0,BASIS,ORBLOC,
     &                  DEV,C,CMAX,CNORM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /VBODIIS/VBOS(40000),VBODIIS(100000),ERRDIIS(100000),
     &                NDIISMAX,NDIIS,NDIISS,JUNK
      DIMENSION EM(1000),CX(100),C0(100)
      DIMENSION B(L,N),INDX(2,NBRIL),ORBLOC(L,L),DEV(*)
      DIMENSION BASIS(M,L),ER(10000),C(NBRIL),CNORM(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      IF(NBRIL.GT.10000) CALL ABORT0('VBDIIS0001')
      NDIIS = NDIIS + 1
      NDIIX = NDIIS
      CX(1) = 1.0D0
      IF(NDIIS.GT.NDIISMAX) NDIIX = NDIISMAX
      IF(NDIIX*L*N.GT.100000) THEN
        WRITE(IOUTVB,*)"OUT OF THE SCRATCH SPACE FOR DIIS"
        CALL ABORT0("VBDIIS0002")
      END IF
      IF(NDIIS.GT.NDIISMAX) THEN
       DO I=2, NDIISMAX
         DO J=1,L*N
         IJ= (I-1)*L*N+J
         VBODIIS(IJ-L*N) = VBODIIS(IJ)
         ERRDIIS(IJ-L*N) = ERRDIIS(IJ)
         END DO
       END DO
      END IF
C
      DO 111 I=1,N
      DO 111 J=1,L
 111  B(J,I)=0.0D0
      DO 221 I=1,NBRIL
      NORB=INDX(1,I)
      NBAS=INDX(2,I)
      B(NBAS,NORB)=DEV(I)
 221  CONTINUE
      CALL MATMUL2(L,L,N,ORBLOC,B,ER)
      IDIIS = (NDIIX-1)*L*N
      DO 302 I=1,N
      DO 302 J=1,L
      IJ=(I-1)*L+J
      ERRDIIS(IDIIS+IJ) = ER(IJ)
 302  CONTINUE
C
      DO 110 I=1,N
      DO 110 J=1,L
 110  B(J,I)=0.0D0
      DO 220 I=1,NBRIL
      IF(DABS(C(I)).GT.CMAX) CMAX=DABS(C(I))
      NORB=INDX(1,I)
      NBAS=INDX(2,I)
      B(NBAS,NORB)=C(I)
 220  CONTINUE
      CALL MATMUL2(L,L,N,ORBLOC,B,ER)
      CMAX=0.0D0
      IDIIS = (NDIIX-1)*L*N
      DO 301 I=1,N
      DO 301 J=1,L
      IJ=(I-1)*L+J
      CABS=DABS(ER(IJ))
      IF(CABS.GT.CMAX) CMAX=CABS
      VBODIIS(IDIIS+IJ) = ORBLOC(J,I)
 301  ORBLOC(J,I) = ORBLOC(J,I) + ER(IJ)
      DO I=1, N
      CNORM(I) = 1.0D0
      END DO
      IF(NDIIS.LT.NDIISS) GOTO 1001
C
C     NOW, COMPUTE DIIS COEFFICIENTS
C
      DO I=1, NDIIX
      II = (I-1)*L*N
      DO J=1, I
      JJ = (J-1)*L*N
      FACTX=1.0D0
      IF(I.EQ.J) FACTX=1.02D0
        SUM = 0.0D0
        DO K=1, L*N
        SUM = SUM + ERRDIIS(II+K)*ERRDIIS(JJ+K)
        END DO
        IJ = (I-1)*(NDIIX+1) + J
        JI = (J-1)*(NDIIX+1) + I
      EM(IJ) = FACTX*SUM
      EM(JI) = FACTX*SUM
      END DO
      END DO
      DO K = 1, NDIIX
      C0(K) = 0.0D0
      IK = NDIIX*(NDIIX+1) + K
      KI = (K-1)*(NDIIX+1) + NDIIX+1
      EM(IK) = -1.0D0
      EM(KI) = -1.0D0
      END DO
      EM((NDIIX+1)*(NDIIX+1)) = 0.0D0
      C0(NDIIX+1) = -1.0D0
      DO I=1, NDIIX+1
      II = (I-1)*(NDIIX+1)
C     WRITE(IOUTVB,*)
C     WRITE(IOUTVB,1000)(EM(II+J),J=1,NDIIX+1)
      END DO
C1000 FORMAT(4F20.15)
      NVEC=1
      CALL GAUSSE(NDIIX+1,EM,C0,NFC,NVEC)
      CALL SOLVEA(NDIIX+1,EM,C0,CX,NVEC)
      DO I=1, N
      DO J=1, L
        SUM = 0.0D0
        DO K=1, NDIIX
        KIJ = (K-1)*L*N+(I-1)*L+J
        SUM = SUM + VBODIIS(KIJ)*CX(K)
        END DO
        ORBLOC(J,I) = SUM
      END DO
      END DO
 1001 CONTINUE
      CALL MATMUL2(M,L,N,BASIS0,ORBLOC,BASIS)
C
C     NORMALIZATION OF EACH ORBITAL
C
      DO I=1, N
        SUM = 0.0D0
        JK = 0
        DO J=1, L
        DO K=1, J
        JK = JK + 1
        FACTOR2 = 2.0D0
          IF(J.EQ.K) FACTOR2 = 1.0D0
        SUM = SUM + FACTOR2*ORBLOC(J,I)*VBOS(JK)*ORBLOC(K,I)
        END DO
        END DO
        CNORM(I) = 1.0D0/SQRT(SUM)
        DO J=1, L
        ORBLOC(J,I) = ORBLOC(J,I)*CNORM(I)
        END DO
        DO J=1, M
        BASIS(J,I)  = BASIS(J,I)*CNORM(I)
        END DO
      END DO
      RETURN
      END
      SUBROUTINE DIAGHER(HESS,NDIM,DEV,SEIG,W,IFIX,DIAGHESS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION HESS(*),W(*),DEV(*),IWRK(5000),E(5000)
      PARAMETER (EPSABS=2.0D-1)
      LOGICAL DIAGHESS
      IF(NDIM.LE.0) RETURN
      IF(NDIM.GT.5000) CALL ABORT0('DIAGHE0001')
      NDIM2=NDIM*NDIM+1
C     NDIM5=NDIM*5
      NVK=1
      NWK=NDIM2+NVK
      G=0.0D0
      DO I=1,NDIM
      II = I*(I-1)/2
      G=G+DEV(I)*DEV(I)
      DO J=1,NDIM
      IJ=(I-1)*NDIM+J
      W(IJ)=HESS(IJ00(I,J))
      IF(DIAGHESS.AND.I.NE.J) W(IJ) = 0.0D0
      END DO
      END DO
      G=DSQRT(G)
      CALL GIVEIS(NDIM,NDIM,NDIM,HESS,W(NWK),IWRK,E,W(NVK),IERR)
      SEIG=E(1)
      DO I=1,NDIM*(NDIM+1)/2
      HESS(I)=0.0D0
      END DO
C
C     SEIG: THE SMALLEST EIGENVLAUE OF HESSIAN MATRIX
C
      SMALLESTE = EPSABS*G
      SABSEIG=DABS(E(1))
      DO I=1,NDIM
      EABS=DABS(E(I))
      IF(EABS.LT.SMALLESTE) EABS=SMALLESTE
      IF(IFIX.EQ.0) EABS=E(I)
      IF(DABS(E(I)).LT.SABSEIG) SABSEIG=DABS(E(I))
      II=(I-1)*NDIM
      DO J=1,NDIM
      EICIJ=EABS*W(II+J)
      JJ=J*(J-1)/2
      DO K=1,J
      HESS(JJ+K)=HESS(JJ+K)+EICIJ*W(II+K)
      END DO
      END DO
      END DO
      RETURN
      END
C---------------------------------------------------------------------------
C     Localization routine of Pipek-Mezey method
C
C     J. Pipek and P. G. Mezey, J. Chem. Phys., 90(1989)4916.
C
C     March, 1995, Erlangen, Germany    (First implementation)
C     July,  1998, Minneapolis, MN, USA (Revised)
C     Feb.,  2000, San Diego, CA, USA   (Revised, LMOs sorted by energies)
C     Nov. 6 2003, San Diego, CA, USA   (Revised, Set new ANGLES to a
C            much smaller value. Also added check for BST so that to avoid
C            bad ratation in ill condition. For instance, localization of MOs
C            of Cl-. No rotation should be performed on a single atom mol.)
C     Nov.26 2003, San Diego, CA, USA   (Revised. Use CSPLIT parameter to
C            detect lone pair)
C     Jul.14 2004, San Diego, CA, USA   (Revised. Fixed a bug for ALPHAM. Mix
C            orbitals with close MO energies first, then extend the energy
C            range to the whole spectrum)
C     Jul.21 2004, San Diego, CA, USA   (Added QuickScane)
C
C     Mar.06 2005, San Diego, CA, USA   (Tuned parameters EPS and ELGAP)
C
C     May 06 2010, San Diego, CA, USA   (Added a new option: LPIMO)
C
C     Created by Jiabo Li
C
C---------------------------------------------------------------------------
      SUBROUTINE LOCAPM(N,NLOCAL,NATOMS,NAO,S,W,V,PGM,EIG,LVIR,LPTALL,
     &                  BFLABE,CSPLIT,LPIMO)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 DUMMY
C     CHARACTER*12 BFLABE(*),BFLAB
      CHARACTER*12 BFLABE(*)
C     PARAMETER (EPS=0.5D-6,ANGLES=0.00001D0,MAXIT=120,MAXBF=5000)
      PARAMETER (EPS=0.5D-6,ANGLES=0.01D0,MAXIT=150,MAXBF=5000)
      DIMENSION V(N,*),S(*),RI(MAXBF),RJ(MAXBF),PGM(NATOMS,NLOCAL)
      DIMENSION NA(MAXBF),SPAS(MAXBF),SPAT(MAXBF),TPAT(MAXBF),NAO(*)
      DIMENSION EIG(*),ELMO(5000),LPFLAG(5000),TX(5000),W(N,*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      DUMMY='            '
      CALL GETIOUNIT('IOENGI  ',IOENGI)
C
C     LVIR = 0, occupied orbitals, print all LMOs
C     LVIR = 1, virtual orbitals, print some LMOs
C     LVIR > 1, no printing for any kind of orbital
C
      IF(LVIR.EQ.1) THEN
C
C     FIND HOW MANY VIRTUAL ORBITALS WILL BE PRINTED
C     DEFAULT: ZERO
C
      LPTVIR=0
      CALL LOCTOR(IOENGI,'$LPTVIR',7,IOK,0)
        IF(IOK.EQ.1) READ(IOENGI,*)LPTVIR
        IF(LPTVIR.GT.NLOCAL) LPTVIR=NLOCAL
      END IF
      IF(N.GT.5000) CALL ABORT0('LOCAPM01  ')
      ITER=0
      NT  = 0
      DO 1 I=1,NATOMS
      DO 2 J=1,NAO(I)
      NT=NT+1
      NA(NT)=I
  2   CONTINUE
  1   CONTINUE
      NATOMX = NATOMS
      IF(LPIMO.EQ.1) THEN
        NT = N
        DO J=1, N
          NA(J) = J
        ENDDO
        NATOMX = N
      END IF
      IF(NT.NE.N.OR.NT.GT.MAXBF) THEN
      WRITE(IOUTVB,*)'DATA WRONG !'
      CALL ABORT0('LOCAPM02  ')
      END IF
      DO 3 I=1,N
      DO 4 J=1,NLOCAL
      W(I,J)=0.0D0
  4   CONTINUE
      W(I,I)=1.0D0
      ELMO(I)=EIG(I)
  3   CONTINUE
      DO 420 I=1,NLOCAL
      DO 420 J=I+1,NLOCAL
      CALL QUICKSCANE(N,V(1,I),V(1,J),S,NA,ANGLES,SA,CA)
      IF(LPIMO.EQ.1) THEN
        CA=DCOS(ANGLES)
        SA=DSIN(ANGLES)
      ENDIF
      DO 420 K=1,N
      SK=V(K,I)
      V(K,I)=CA*V(K,I)+SA*V(K,J)
      V(K,J)=CA*V(K,J)-SA*SK
      SK=W(K,I)
      W(K,I)=CA*W(K,I)+SA*W(K,J)
      W(K,J)=CA*W(K,J)-SA*SK
  420 CONTINUE
      ELGAP = 1.0D0
      ELGAPM= DABS(EIG(NLOCAL) - EIG(1)) + 1.0D-5
  10  CONTINUE
      ITER=ITER+1
      NROT=0
      ALPHAM=0.0D0
      DO 100 I=1,NLOCAL
      DO 100 J=I+1,NLOCAL
      DELTAE = DABS(EIG(J)-EIG(I))
C     WRITE(IOUTVB,*)'DELTAE,ELGAP=',DELTAE,ELGAP
      IF(DELTAE.GT.ELGAP) GOTO 101
      DO 110 K=1,N
      RI(K)=0.0D0
      RJ(K)=0.0D0
      DO 110 L=1,N
      IF(K.GT.L) THEN
      KL=K*(K-1)/2+L
      ELSE
      KL=L*(L-1)/2+K
      END IF
      RI(K)=RI(K)+0.5D0*V(L,I)*S(KL)
      RJ(K)=RJ(K)+0.5D0*V(L,J)*S(KL)
  110 CONTINUE
      DO 120 K=1,NATOMX
      SPAS(K)=0.0D0
      TPAT(K)=0.0D0
  120 SPAT(K)=0.0D0
      DO 130 K=1,N
      NATM=NA(K)
      SPAS(NATM)=SPAS(NATM)+V(K,I)*RI(K)*2.0D0
      TPAT(NATM)=TPAT(NATM)+V(K,J)*RJ(K)*2.0D0
      SPAT(NATM)=SPAT(NATM)+V(K,J)*RI(K)+V(K,I)*RJ(K)
  130 CONTINUE
      AST=0.0D0
      BST=0.0D0
      DO 140 K=1,NATOMX
      AST=AST+SPAT(K)**2-(SPAS(K)-TPAT(K))**2/4.0D0
      BST=BST+(SPAS(K)-TPAT(K))*SPAT(K)
  140 CONTINUE
C
C     IF THE DIRIVATIVE IS TOO SMALL, THERE IS NO POINT TO DO ROTATION
C
C     WRITE(IOUTVB,*)'BST,AST=',BST,AST
      IF(DABS(BST).GT.EPS) THEN
      SI4A=BST/DSQRT((AST**2+BST**2))
      ALPHA=DASIN(SI4A)/4.0D0
      IF(DABS(ALPHA).GT.ALPHAM) ALPHAM=DABS(ALPHA)
      IF(DABS(ALPHA).GT.EPS) THEN
      NROT=NROT+1
      CA=DCOS(ALPHA)
      SA=DSIN(ALPHA)
      DO 150 K=1,N
      SK=V(K,I)
      V(K,I)=CA*V(K,I)+SA*V(K,J)
      V(K,J)=CA*V(K,J)-SA*SK
      SK=W(K,I)
      W(K,I)=CA*W(K,I)+SA*W(K,J)
      W(K,J)=CA*W(K,J)-SA*SK
  150 CONTINUE
      END IF
      END IF
  101 CONTINUE
  100 CONTINUE
C     WRITE(IOUTVB,1000)NROT,ALPHAM
      IF(NROT.GT.0.AND.ITER.LE.MAXIT) GOTO 10
      IF(NROT.EQ.0.OR.((ITER/10)*10.EQ.ITER)) THEN
      ELGAP = ELGAP + ELGAP
      END IF
      IF(ITER.LE.MAXIT.AND.(ELGAP.LE.ELGAPM*2.OR.NROT.GT.0)) GOTO 10
C
C     Calculate the LMO energies
C
      DO I=1,NLOCAL
      ELMO(I)=0.0D0
        DO J=1,NLOCAL
        ELMO(I)=ELMO(I)+W(J,I)*W(J,I)*EIG(J)
        END DO
      END DO
      IF(LPIMO.EQ.1) RETURN
C
C     Sort LMOs by LMO energies
C
      CALL RORDER(V,W,ELMO,NLOCAL,N)
C
C     Check if this orbital is a covalent bond or not
C     If ratio of max_next/max < CSPLIT
C     then this LMO is considered as a LP.
C
      DO 520 I=1,NLOCAL
      DO 540 K=1,NATOMS
  540 PGM(K,I)=0.0D0
      DO 530 K=1,N
      KN=NA(K)
      DO 530 L=1,N
      LN=NA(L)
      IF(K.GT.L) THEN
      KL=K*(K-1)/2+L
      ELSE
      KL=L*(L-1)/2+K
      END IF
      PGM(KN,I)=PGM(KN,I)+V(L,I)*S(KL)*V(K,I)
      PGM(LN,I)=PGM(LN,I)+V(L,I)*S(KL)*V(K,I)
  530 CONTINUE
      LPFLAG(I)=0
      FPGM = 0.0D0
      SPGM = 0.0D0
        DO L=1,NATOMS
          IF(DABS(PGM(L,I)).GT.FPGM) THEN
          SPGM = FPGM
          FPGM = DABS(PGM(L,I))
          ELSE IF(DABS(PGM(L,I)).GT.SPGM) THEN
          SPGM = DABS(PGM(L,I))
          END IF
        END DO
      RPGM = SPGM/FPGM
      IF(RPGM.LT.CSPLIT) LPFLAG(I) = 1
  520 CONTINUE
C
C     SORT ORBITALS SO THAT COVALENT BONDING ORBITALS COME LAST
C
      DO I=1,NLOCAL
      TX(I)=1.0D-10*I-LPFLAG(I)
      END DO
      CALL RORDER(ELMO,W,TX,NLOCAL,1)
      DO I=1,NLOCAL
      TX(I)=1.0D-10*I-LPFLAG(I)
      END DO
      CALL RORDER(PGM,W,TX,NLOCAL,NATOMS)
      DO I=1,NLOCAL
      TX(I)=1.0D-10*I-LPFLAG(I)
      END DO
      CALL RORDER(V,W,TX,NLOCAL,N)
      DO I=1, NLOCAL
      EIG(I) = ELMO(I)
      END DO
C
C     PRINT LMOs AND E-LMOs
C
      IF(LPTALL.EQ.1) THEN
        IF(LVIR.EQ.0) CALL MPRINT(V,ELMO,N,NLOCAL,1,BFLABE,DUMMY)
        IF(LVIR.EQ.1) CALL MPRINT(V,ELMO,N,LPTVIR,1,BFLABE,DUMMY)
      END IF
C
C     PRINT MULLIKEN POPULATION ANALYSIS
C
C     IF(LVIR.EQ.0) CALL MPRINT(PGM,ELMO,NATOMS,NLOCAL,2,BFLABE,DUMMY)
C     IF(LVIR.EQ.1) CALL MPRINT(PGM,ELMO,NATOMS,LPTVIR,2,BFLABE,DUMMY)
C 900 FORMAT(/1X,'Iteration exceeds maxit')
C 910 FORMAT(/1X,'OCCUPIED ORBITALS')
C 920 FORMAT(/1X,'VIRTUAL ORBITALS')
C1000 FORMAT(2X,'NUMBER OF ROTATIONS OF PAIRS',I5/
C    &          'MAXIMAL ROTATION ANGLE      ',F15.10)
      RETURN
      END
C     SUBROUTINE LOCANVBO(MORB,BASIS,W,MITER)
      SUBROUTINE LOCANVBO(MORB,BASIS,W)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C     PARAMETER (MAXIT=120,MAXBF=5000)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      PARAMETER (MAXCEN=200,MAXBFN=726)
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
C     PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA)
      DIMENSION W(*),BASIS(*),NAT(MAXBFN),MASKLOCA(40000)
C     DIMENSION CHAMAX(4,1000),MAXCHA(4,1000),NWA(1000),PGMT(1000)
C
C     QUICK EXIT IF CASVB LOCALIZATION IS DISABLED
C
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$NOLOCVBO',9,IOK,0)
      IF(IOK.EQ.1) THEN
        WRITE(IOUTVB,*)'VBO LOCALIZATION IS DISABLED FOR CASVB'
        RETURN
      END IF
      IF(MORB.GT.200) CALL ABORT0('LOCANVBO01')
C     IF(MITER.NE.1.AND.LPTALL.EQ.1) WRITE(IOUTVB,1000)
C     NEED TO PUT MITER BACK AS ARGUMENT IF THIS IS USED
C     LPRT = 1
      NNS  = 1
      NPGM = NNS + NBASIS*(NBASIS+1)/2
      NWK  = NPGM + NATOM*MORB
      NT   = 0
      DO 1 I=1,NATOM
      DO 2 J=1,NATBAS(I)
      NT=NT+1
      NAT(NT)=I
  2   CONTINUE
  1   CONTINUE
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL READ1E(IAO1E,W(NNS),W(NWK),NBASIS)
      CALL MULLIKEN(NBASIS,MORB,BASIS,W(NNS),NAT,NATOM,W(NPGM))
      CALL SETMASK(MORB,NATOM,W(NPGM),MASKLOCA)
      CALL LOCALI(NBASIS,MORB,NATOM,NATBAS,W(NNS),W(NWK),BASIS,
     $           W(NPGM),MASKLOCA)
      RETURN
C1000 FORMAT(/' ORBITAL LOCALIZATION PERFORMED FOR CASVB CALCULATION',
C    &     /,' THE STRUCTURE WEIGHTS MAY BE SLIGHTLY DIFFERENT FROM',
C    &     /,' THE RESULTS OF PREVIOUS ITERATION ')
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     FUNCTION:
C                Nonthogonal localization method.
C                It refines the localized orbitals without orthognality
C                constrains
C
C     HISTORY:
C
C                First created in July, 2004
C
C     AUTHOR:
C
C                Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE LOCALI(N,NLOCAL,NATOMS,NAO,S,W,V,PGM,
     &                  MASKLOCA)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C     CHARACTER*12 BFLABE(*),BFLAB
C     PARAMETER (EPS=1.0D-06,DELTA=1.0D-7,TSTEP=1.0D-1)
C     PARAMETER (MAXIT=120,MAXBF=5000)
      PARAMETER (MAXBF=5000)
      DIMENSION V(N,*),W(N,*),S(*),PGM(NATOMS,NLOCAL)
C     DIMENSION NA(MAXBF),NAO(*),VT(MAXBF),MASKLOCA(NLOCAL,NLOCAL)
      DIMENSION NA(MAXBF),NAO(*),MASKLOCA(NLOCAL,NLOCAL)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     WRITE(IOUTVB,*)'EPS, DELTA =',EPS,DELTA
      IF(N.GT.MAXBF) CALL ABORT0('LOCALI01  ')
C     ITER=0
      NT  = 0
      DO 1 I=1,NATOMS
      DO 2 J=1,NAO(I)
      NT=NT+1
      NA(NT)=I
  2   CONTINUE
  1   CONTINUE
      IF(NT.NE.N.OR.NT.GT.MAXBF) THEN
      WRITE(IOUTVB,*)'DATA WRONG !'
      CALL ABORT0('LOCALI02  ')
      END IF
C
C     MAKE A COPY OF ORIGINAL ORBITALS
C
      DO I=1, NLOCAL
C     WRITE(IOUTVB,*)'LOCAL I=',I
      DO J=1, N
      W(J,I)=V(J,I)
C     WRITE(IOUTVB,'(I3,F10.6)')I,V(J,I)
      END DO
      END DO
C
C     LOCALIZATION FOR EACH ORBITAL
C
      NSEARCH= 4
      NSCANE = 20
      CRANGE = 0.5D0
      DO L=1, NSEARCH
      DO 3 I=1, NLOCAL
        DO 4 J=1, NLOCAL
        IF(MASKLOCA(I,J).EQ.0) GOTO 4
        CALL BINSEARCH(N,W(1,I),V(1,J),S,NA,CRANGE,NSCANE)
  4     CONTINUE
  3   CONTINUE
      CRANGE = CRANGE/10.0D0
C
C     COPY BACK TO V
C
      DO I=1, NLOCAL
         DO J=1, N
         V(J,I) = W(J,I)
         END DO
      END DO
      END DO
C
C     COPY BACK TO V
C
      DO I=1, NLOCAL
C     WRITE(IOUTVB,*)'FINAL I=',I
         DO J=1, N
         V(J,I) = W(J,I)
C     WRITE(IOUTVB,'(I3,F10.6)')I,V(J,I)
         END DO
      END DO
      DO 520 I=1,NLOCAL
      DO 540 K=1,NATOMS
  540 PGM(K,I)=0.0D0
      DO 530 K=1,N
      KN=NA(K)
      DO 530 L=1,N
      LN=NA(L)
      IF(K.GT.L) THEN
      KL=K*(K-1)/2+L
      ELSE
      KL=L*(L-1)/2+K
      END IF
      PGM(KN,I)=PGM(KN,I)+V(L,I)*S(KL)*V(K,I)
      PGM(LN,I)=PGM(LN,I)+V(L,I)*S(KL)*V(K,I)
  530 CONTINUE
  520 CONTINUE
      RETURN
      END
      SUBROUTINE SETMASK(MORB,NATOMS,PGM,MASKLOCA)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION PGM(NATOMS,MORB),MOATOM(1000)
      DIMENSION MASKLOCA(MORB,MORB),PGMT(1000),NWA(1000)
      DO I=1,MORB
        M4 = 4
        IF (M4.GT.NATOMS) M4 =NATOMS
        DO J=1, NATOMS
        PGMT(J) = PGM(J,I)
        END DO
        CALL SHELL(PGMT,NWA,NATOMS)
        DO J=1,M4
C       CHAMAX(J,I) = PGMT(NATOMS-J+1)
C       MAXCHA(J,I) = NWA(NATOMS-J+1)
        END DO
        MOATOM(I) = NWA(NATOMS)
      END DO
      DO I=1,MORB
      DO J=1,MORB
      MASKLOCA(I,J) = 1
      IF(MOATOM(I).EQ.MOATOM(J)) MASKLOCA(I,J) = 0
      IF(I.EQ.J) MASKLOCA(I,J) = 0
      END DO
      END DO
      RETURN
      END
      SUBROUTINE MULLIKEN(N,NORB,V,S,NA,NATOMS,PGM)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION V(N,NORB),S(*),NA(*),PGM(NATOMS,NORB)
      DO 520 I=1,NORB
      DO 540 K=1,NATOMS
  540 PGM(K,I)=0.0D0
      DO 530 K=1,N
      KN=NA(K)
      DO 530 L=1,K
      FACTOR=1.0D0
      IF(K.EQ.L) FACTOR=0.5D0
      LN=NA(L)
      IF(K.GT.L) THEN
      KL=K*(K-1)/2+L
      ELSE
      KL=L*(L-1)/2+K
      END IF
      PGM(KN,I)=PGM(KN,I)+FACTOR*V(L,I)*S(KL)*V(K,I)
      PGM(LN,I)=PGM(LN,I)+FACTOR*V(L,I)*S(KL)*V(K,I)
  530 CONTINUE
  520 CONTINUE
      RETURN
      END
      SUBROUTINE BINSEARCH(N,W,V,S,NA,CRANGE,NSCANE)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION W(*),V(*),S(*),NA(*),VT(5000)
      C1=-CRANGE
      C2= CRANGE
      C2MAX = 0.0D0
C     NIMAX = 1
      CCMX  = 0.0D0
      DO I=1, NSCANE+1
      CX = C1+(I-1)*(C2-C1)/NSCANE
        DO K=1, N
        VT(K) = W(K) + CX*V(K)
        END DO
      CALL MC2(N,VT,S,NA,CMX,3)
      IF(CMX.GT.C2MAX) THEN
        C2MAX = CMX
C       NIMAX = I
        CCMX  = CX
      END IF
      END DO
        DO K=1, N
        W(K) = W(K) + CCMX*V(K)
        END DO
      CALL MC2(N,W,S,NA,CMX,3)
      RETURN
      END
      SUBROUTINE QUICKSCANE(N,V1,V2,S,NA,SANGLE,SINA,COSA)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION V1(*),V2(*),S(*),NA(*),VT1(5000),VT2(5000)
      C1=-SANGLE
      C2= SANGLE
      C2MAX = 0.0D0
C     NIMAX = 1
      CCMX  = 0.0D0
      NSCANE= 2
      NMID  = NSCANE/2+1
      C2Z   = 0.0D0
      DO I=1, NSCANE+1
      CX = C1+(I-1)*(C2-C1)/NSCANE
      SA = DSIN(CX)
      CA = DCOS(CX)
        DO K=1, N
        VT1(K) = CA*V1(K) + SA*V2(K)
        VT2(K) = CA*V2(K) - SA*V1(K)
        END DO
      CALL MC2(N,VT1,S,NA,CMA,1)
      CALL MC2(N,VT2,S,NA,CMB,1)
      CMX = CMA+CMB
      IF(I.EQ.NMID) C2Z = CMX
      IF(CMX.GT.C2MAX) THEN
        C2MAX = CMX
C       NIMAX = I
        CCMX  = CX
      END IF
      END DO
      IF(DABS((C2Z-C2MAX)/SANGLE).LT.0.0001D0) CCMX = 0.001D0*SANGLE
      SINA = DSIN(CCMX)
      COSA = DCOS(CCMX)
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     THREE FUNCTIONS FOR LOCALIZAITON
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE MC2(N,V,S,NA,C2,IOP)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION V(*),S(*),NA(*),CHARGE(5000),CSITE(5000),CSQ(5000)
      NATOMS = NA(N)
      DO I=1, NATOMS
      CHARGE(I) = 0.0D0
      CSQ(I)    = 0.0D0
      CSITE(I)  = 0.0D0
      END DO
C
C     NORMALIZATION OF VECTOR
C
      CALL NORMORB(N,1,V,S,IERR)
      IJ = 0
      DO I=1, N
      NAI = NA(I)
      CSQ(NAI) = CSQ(NAI) + V(I)*V(I)
      DO J=1, I
      FACTOR = 1.0D0
      IF(I.EQ.J) FACTOR = 0.5D0
      IJ = IJ+1
      NAJ = NA(J)
      CHARGE(NAI) = CHARGE(NAI) + FACTOR*V(I)*V(J)*S(IJ)
      CHARGE(NAJ) = CHARGE(NAJ) + FACTOR*V(I)*V(J)*S(IJ)
      IF(NAI.EQ.NAJ) CSITE(NAI)=CSITE(NAI)+2.0D0*FACTOR*V(I)*V(J)*S(IJ)
      END DO
      END DO
C
C     COMPUTE C2 and ERROR CHECK
C
      C2 = 0.0D0
      C1 = 0.0D0
      DO I=1, NATOMS
      IF(IOP.EQ.1) THEN
        C1 = C1 + CHARGE(I)
      ELSE IF(IOP.EQ.2) THEN
        C1 = C1 + CSQ(I)
      ELSE IF(IOP.EQ.3) THEN
        C1 = C1 + CSITE(I)
      ELSE
        CALL ABORT0('MC20000001')
      END IF
      END DO
      DO I=1, NATOMS
      IF(IOP.EQ.1) THEN
        C2 = C2 + CHARGE(I)*CHARGE(I)
      ELSE IF(IOP.EQ.2) THEN
        C2 = C2 + CSQ(I)*CSQ(I)
      ELSE IF(IOP.EQ.3) THEN
        C2 = C2 + CSITE(I)*CSITE(I)
      ELSE
        CALL ABORT0('MC20000002')
      END IF
      END DO
      C2 = C2/(C1*C1)
      RETURN
      END
      SUBROUTINE CHALMO(M,NCORE,NATOM,NATBAS,BFLABE,WBASIS,S,PGM,W,E,
     &                  CHAMAX,MAXCHA,CSPLIT,LPTALL)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      CHARACTER*12 BFLABE(*)
      DIMENSION NATBAS(*),WBASIS(M,*),W(*),S(*),PGM(NATOM,*),E(*)
      DIMENSION CHAMAX(4,*),MAXCHA(4,*),NWA(1000),PGMT(1000)
      DIMENSION NDGSIZE(1000)
CGMS  PARAMETER (MXATM=2000)
CGMS  COMMON/INFOA/ NAT1, ICH1, MUL1, NUM1, NQMT, NE1, NA1, NB1,
CGMS 1    ZAN1(MXATM), C1(3,MXATM), IAN(MXATM)
C
C     THIS NVIR IS DIFFERNT FROM NVIR IN VB CALCULATION
C
      NVIR=M-NCORE
CGMS  NVIR = NQMT-NCORE
C     NOBVIR=NCORE*M+1
C     NPMVIR=NCORE*NATOM+1
      CALL LOCAPM(M,NCORE,NATOM,NATBAS,S,W,WBASIS,PGM,E,0,LPTALL,
     &            BFLABE,CSPLIT,0)
      IF(NVIR.GT.0) THEN
      CALL LOCAPM(M,NVIR, NATOM,NATBAS,S,W,WBASIS(1,NCORE+1)
     &,PGM(1,NCORE+1),E(NCORE+1),1,LPTALL,BFLABE,CSPLIT,0)
      END IF
      DO I=1,M
        M4 = 4
        IF (M4.GT.NATOM) M4 =NATOM
        DO J=1, NATOM
        PGMT(J) = PGM(J,I)
        END DO
        CALL SHELL(PGMT,NWA,NATOM)
        DO J=1,M4
        CHAMAX(J,I) = PGMT(NATOM-J+1)
        MAXCHA(J,I) = NWA(NATOM-J+1)
        END DO
      END DO
C
C     POSSIBLE LPIMO OPTION
C     DO THIS ONLY IF LPIMO FLAG EXIST
C     ONLY APPLY FOR LINEAR MOLECULES
C
      LPIMO = 0
C
C     TODO: CHECK $LPIMO
C
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$LPIMO',6,IOK,0)
      IF(IOK.EQ.1) LPIMO=1
      NDG = 0
C     NDGS = 0
      NDGSIZE(1) = 1
      DO I=1, NCORE-1
        IF(ABS(E(I+1)-E(I)).GT.1.0D-3) THEN
           NDG = NDG+1
           NDGSIZE(NDG+1) = I+1
        END IF
      ENDDO
      NDG = NDG+1
      NDGSIZE(NDG+1) = NCORE+1
      DO I=1, NDG+1
      ENDDO
      DO I=1, NDG
        NGG = NDGSIZE(I)
        NGP = NDGSIZE(I+1) - NDGSIZE(I)
        IF(NGP .GT. 1. AND. LPIMO.EQ.1) THEN
          CALL LOCAPM(M,NGP, NATOM,NATBAS,S,W,WBASIS(1,NGG)
     &               ,PGM(1,NGG),E(NGG),1,LPTALL,BFLABE,CSPLIT,1)
        ENDIF
      ENDDO
C
C     PERFORM POSSIBLE TRANSFORMATION
C
      NBASIS = M
      NWK0 = 1
      NWK1 = NWK0 + NBASIS*NBASIS
      CALL LMOTRN(NBASIS,WBASIS,W(NWK0),NATOM,PGM,E,W(NWK1))
      RETURN
      END
C
C     MATRIX PRINTER
C
      SUBROUTINE MPRINT(A,E,N,M,IFLAG,BFLABE,BONDLAB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE(*)
      CHARACTER*12 BFLABF
      CHARACTER*20 BASNAME
      CHARACTER*8 BONDLAB(*)
      CHARACTER*2 ATMSYM
      DIMENSION A(N,M),E(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      PARAMETER (MAXCEN=200,MAXBFN=726)
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABF(MAXBFN),BASNAME
      COMMON /ATOMSY/ ATMSYM(92)
C
C     IFLAG = PRINT FLAG
C             1: PRINT LMO and E-LMO
C             2: PRINT LMO-Mulliken population
C             3: PRINT Initial orbitals
C             4: PRINT CANON MO
C             5: PRINT CANON LMO
C
      IF(M.LE.0) RETURN
      NPRT=(M+5)/6
      IF(IFLAG.EQ.1) WRITE(IOUTVB,1700)
      IF(IFLAG.EQ.2) WRITE(IOUTVB,1800)
      IF(IFLAG.EQ.3) WRITE(IOUTVB,1850)
      IF(IFLAG.EQ.4) WRITE(IOUTVB,1750)
      IF(IFLAG.EQ.5) WRITE(IOUTVB,1755)
      NFIST=1
      DO I=1,NPRT
      NLAST=NFIST+5
      IF(NLAST.GT.M) NLAST=M
      IF(IFLAG.EQ.1) WRITE(IOUTVB,1950)(K,K=NFIST,NLAST)
      IF(IFLAG.EQ.2) WRITE(IOUTVB,1950)(K,K=NFIST,NLAST)
      IF(IFLAG.EQ.3) WRITE(IOUTVB,1956)(K,K=NFIST,NLAST)
      IF(IFLAG.EQ.4) WRITE(IOUTVB,1955)(K,K=NFIST,NLAST)
      IF(IFLAG.EQ.5) WRITE(IOUTVB,1950)(K,K=NFIST,NLAST)
      IF(IFLAG.EQ.1) WRITE(IOUTVB,1900)(E(K),K=NFIST,NLAST)
      IF(IFLAG.EQ.2) WRITE(IOUTVB,1900)(E(K),K=NFIST,NLAST)
      IF(IFLAG.EQ.4) WRITE(IOUTVB,1900)(E(K),K=NFIST,NLAST)
      IF(IFLAG.EQ.5) WRITE(IOUTVB,1900)(E(K),K=NFIST,NLAST)
      IF(IFLAG.EQ.5) WRITE(IOUTVB,1965)(BONDLAB(K),K=NFIST,NLAST)
      IF(IFLAG.EQ.2) WRITE(IOUTVB,1965)(BONDLAB(K),K=NFIST,NLAST)
      IF(IFLAG.EQ.3) WRITE(IOUTVB,1965)(BONDLAB(K),K=NFIST,NLAST)
      WRITE(IOUTVB,1970)
      IF(IFLAG.EQ.2) THEN
        DO J=1,N
        WRITE(IOUTVB,2000)J,ATMSYM(NATNUM(J)),(A(J,K),K=NFIST,NLAST)
        END DO
      ELSE
        DO J=1,N
        WRITE(IOUTVB,2100)J,BFLABE(J),(A(J,K),K=NFIST,NLAST)
        END DO
      END IF
      WRITE(IOUTVB,*)
      NFIST=NLAST+1
      END DO
 1700 FORMAT(/' Localized molecular orbitals by PM method'/1X,79(1H=))
 1750 FORMAT(/' Molecular orbitals by HF method'/1X,79(1H=))
 1755 FORMAT(/' Localized molecular orbitals and the bond labels'
     &          /1X,79(1H=))
 1800 FORMAT(/' Mulliken population of localized molecular orbitals'/
     & 1X,79(1H=))
 1850 FORMAT(/' Initial guess of orbitals'/1X,79(1H=))
 1900 FORMAT(1X,'E(a.u.)          ',6F10.3)
 1950 FORMAT(1X,'LMO#             ',6I10)
 1955 FORMAT(1X,'MO#              ',6I10)
 1956 FORMAT(1X,'ORBITAL#         ',6I10)
C1960 FORMAT(1X,'                 ',6I10)
 1965 FORMAT(1X,'Bond Label       ',6A10)
 1970 FORMAT(1X,79(1H-)/)
 2000 FORMAT(1X,I3,8X,A2,4X,6F10.5)
 2100 FORMAT(1X,I3,A12,2X,6F10.5)
      RETURN
      END
C
C     SYMMETRIC MATRIX PRINTER
C
      SUBROUTINE MPRINT2(N,A,IFLAG,MGRP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(*),D(1000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      IF(N.LE.0) RETURN
      IF(IFLAG.EQ.1) WRITE(IOUTVB,1000) MGRP
      DO I=1, N
      IF(IFLAG.EQ.1) D(I) = 1.0D0/DSQRT(A(IJ00(I,I)))
      END DO
      NPRT=(N+11)/12
      NFIST=1
      DO I=1,NPRT
      NLAST=NFIST+11
      IF(NLAST.GT.N) NLAST=N
      WRITE(IOUTVB,1200)(K,K=NFIST,NLAST)
      WRITE(IOUTVB,1400)("=======",K=NFIST,NLAST)
        DO J=NFIST, N
        NLL = NLAST
        IF(NLL.GT.J) NLL = J
        WRITE(IOUTVB,1300)J,(A(IJ00(J,K))*D(J)*D(K),K=NFIST,NLL)
        END DO
      NFIST=NLAST+1
      END DO
 1000 FORMAT(//" OVERLAP MATRIX OF VB ORBITALS FOR GROUP ",I3)
 1200 FORMAT(/2X,12I7)
 1300 FORMAT(1X,I3,12F7.4)
C1301 FORMAT(1X,A7,F14.6)
 1400 FORMAT(1X,3(1H=),12(A7))
      RETURN
      END
C
C     PRINT H,S WITH NORMALIZATION
C
      SUBROUTINE MPRINT3(N,S,H,MGRP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION S(*),H(*),D(1000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      IF(N.LE.0) RETURN
      WRITE(IOUTVB,1100) MGRP
      DO I=1, N
      D(I) = 1.0D0/DSQRT(S(IJ00(I,I)))
      END DO
      NPRT=(N+5)/6
C
C     PRINT S MATRIX
C
      NFIST=1
      DO I=1,NPRT
      NLAST=NFIST+5
      IF(NLAST.GT.N) NLAST=N
      WRITE(IOUTVB,1200)(K,K=NFIST,NLAST)
      WRITE(IOUTVB,1400)("============",K=NFIST,NLAST)
        DO J=NFIST, N
        NLL = NLAST
        IF(NLL.GT.J) NLL = J
          WRITE(IOUTVB,1300)J,(S(IJ00(J,K))*D(J)*D(K),K=NFIST,NLL)
        END DO
      NFIST=NLAST+1
      END DO
C
C     PRINT H MATRIX
C
      WRITE(IOUTVB,1110) MGRP
      NFIST=1
      DO I=1,NPRT
      NLAST=NFIST+5
      IF(NLAST.GT.N) NLAST=N
      WRITE(IOUTVB,1200)(K,K=NFIST,NLAST)
      WRITE(IOUTVB,1400)("============",K=NFIST,NLAST)
        DO J=NFIST, N
        NLL = NLAST
        IF(NLL.GT.J) NLL = J
          WRITE(IOUTVB,1300)J,(H(IJ00(J,K))*D(J)*D(K),K=NFIST,NLL)
        END DO
      NFIST=NLAST+1
      END DO
      WRITE(IOUTVB,1500)
      WRITE(IOUTVB,1501)
      WRITE(IOUTVB,'(8F10.6)')(1.0D0/D(I),I=1,N)
 1100 FORMAT(//" OVERLAP MATRIX OF VB STRUCTURES FOR GROUP ",I3)
 1110 FORMAT(//" HAMILTONIAN MATRIX OF VB STRUCTURES FOR GROUP ",I3)
 1200 FORMAT(/2X,6I12)
 1300 FORMAT(1X,I3,6F12.6)
 1400 FORMAT(1X,3(1H=),6(A12))
 1500 FORMAT(//" Normalization constants of VB structures")
 1501 FORMAT("      I.E. N in C(norm) = N C(unnorm)",/)
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     ROUTINE FOR CANONICALIZING LMOs, SET UP LMO INDEXES
C
C     VARIABLES:
C
C     WLMO: LMOs
C     CHAMAX: CHARGES OF LMO ON ATOMS (SORTED FROM LARGEST TO SMALLEST)
C     MAXCHA: ATOM INDEX OF CHAMAX
C     LMOLAB: LMO LABELS. LMOLAB(1,I) = LMO LOCATION IJ(NA1, NA2) OF THE LMO I.
C
C             FOR MC LMO, LMO LOCATION INDEX = 0
C             LMOLAB(2,I) = BOND INDEX. I.E. HOW MANY LMOs AT THIS LOCATION
C
C             NOTE: THE BOND INDEX IS LABELED IN SUCH A WAY THAT THE HIGH
C             ENERGY ONES (I.E. VALENCE BONDS) ARE LABELED FIRST. TO BE
C             CONSISTENT, ALL LMOs HAVE BOND INDEX, EVEN FOR LP AND INNER ORB.
C     MCLMO:  MULTI-CENTER LMOs. THE DATA STRUCTURE IS GIVEN AS BELOW:
C
C             MCLMO(1,I): THE I-TH MCLMO INDEX (LMO INDEX)
C             MCLMO(2-5,I): THE MC ATOM INDEXES OF THE LMO
C
C     NOTE:   NO MORE THAN 1000 ATOMS, NO MORE THAN 1000 BASIS FUNCTIONS
C     REVISION HISTORY
C     FIRST CREATION: NOV. 1, 2003
C
C     AUTHOR: JIABO LI
C     SAN DIEGO
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE CANLMO(WLMO,S,NCORE,NBASIS,CHAMAX,MAXCHA,W,
     &                  NAO,CSPLIT,BFLABE,NAOST,IOLVBO,IOENGI,LPRT)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      CHARACTER*12 BFLABE(*)
      CHARACTER*8 BONDLAB
      DIMENSION WLMO(*),CHAMAX(4,*),MAXCHA(4,*),S(*),W(*),NAOST(*)
      DIMENSION NAO(*),NA(1000),NATOMBOND(1000),NATOMLP(1000)
      DIMENSION NAOFFSET(1000)
      PARAMETER (MAXCEN=200,MAXBFN=726)
      PARAMETER (MAXNAB=MAXCEN*MAXBFN/2,MAXBF2=MAXBFN*MAXBFN)
      COMMON /LMODAT/VMO(MAXBF2),VLMO(MAXBF2),LMOLAB(2,MAXBFN),
     &LMOATM(5,MAXBFN),PGM(MAXNAB),ENGLMO(MAXBFN),BONDLAB(MAXBFN),
     &MCLMO(5,80),LHFLAG
      COMMON /MTOPOL/XYZMOL(3,1000),NATOMS,NATNNU(1001),
     &               NBONDALIST(10,1000),NBONDTYPE(10,1000)
C     IF(NBASIS.GT.1000.OR.NATOMS.GT.1000) CALL ABORT0('CANLMO01  ')
C
C     COPY ALL LMOs to STORAGE
C
      DO I=1, NBASIS*NCORE
      VLMO(I) = WLMO(I)
      END DO
C
C     ZERO LABELS
C
      DO I=1,1000
      LMOLAB(1,I) = 0
      LMOLAB(2,I) = 0
      LMOATM(1,I) = 0
      LMOATM(2,I) = 0
      LMOATM(3,I) = 0
      LMOATM(4,I) = 0
      LMOATM(5,I) = 0
      END DO
C     LHFLAG = 0
      DO I=1, 10
        DO J=1, 5
        MCLMO(J,I) = 0
        END DO
      END DO
      MCLMOCOUNT = 0
      NAT2=NATOMS*(NATOMS+1)/2
C     MCINDEX = NAT2 + 1
      MCINDEX = 0
C     NAT22=NAT2*2
C     IF(3*NATOMS*(NATOMS+1)/2.GT.15000) CALL ABORT0('INPUTVB02 ')
      DO I=NCORE,1,-1
      RAT1=DABS(CHAMAX(2,I)/CHAMAX(1,I))
      RAT2=0.0D0
      IF(NATOMS.GE.3) RAT2=DABS(CHAMAX(3,I)/CHAMAX(1,I))
C     WRITE(IOUTVB,*)'RAT1, RAT2 =',RAT1, RAT2
      IF(RAT1.LT.CSPLIT) THEN
C
C       LONE_PAIR
C
        IJ=IJ00(MAXCHA(1,I),MAXCHA(1,I))
        LMOLAB(1,I) = IJ
        LMOATM(1,I) = MAXCHA(1,I)
        LMOATM(5,I) = 1
      ELSE IF(RAT2.LT.CSPLIT) THEN
C
C       NORMAL BOND
C
        IJ=IJ00(MAXCHA(1,I),MAXCHA(2,I))
        LMOLAB(1,I) = IJ
        LMOATM(1,I) = MAXCHA(1,I)
        LMOATM(2,I) = MAXCHA(2,I)
        LMOATM(5,I) = 2
      ELSE
C
C       MULTI-CENTER BOND
C
        MCLMOCOUNT  = MCLMOCOUNT + 1
        LMOLAB(1,I) = MCINDEX
        LMOLAB(2,I) = MCLMOCOUNT
        MCLMO(1,MCLMOCOUNT) = I
        MCLMO(2,MCLMOCOUNT) = MAXCHA(1,I)
        MCLMO(3,MCLMOCOUNT) = MAXCHA(2,I)
        MCLMO(4,MCLMOCOUNT) = MAXCHA(3,I)
        LMOATM(1,I) = MAXCHA(1,I)
        LMOATM(2,I) = MAXCHA(2,I)
        LMOATM(3,I) = MAXCHA(3,I)
        LMOATM(5,I) = 3
        IF(NATOMS.GT.3) MCLMO(5,MCLMOCOUNT) = MAXCHA(4,I)
        IF(NATOMS.GT.3) LMOATM(4,I) = MAXCHA(4,I)
        IF(NATOMS.GT.3) LMOATM(5,I) = 4
      END IF
      END DO
C
C     SET UP ATOM BOND INDEX
C
C     NATOMBOND(K) = THE NUMBER OF BONDS OF ATOM K. SINGLE BOND COUNTS 1,
C                    DOUBLE BOND COUNTS 2, AND TRIPLE BOND COUNTS 3
C     NATOMLP(K)   = THE NUMBER OF LONE PAIRS (OF VALENCE SHELL) ON ATOM K.
C
      DO K=1, NATOMS
      NATOMBOND(K) = 0
      NATOMLP(K)   = 0
      END DO
      DO K=1, NCORE
      IJ = LMOLAB(1,K)
      CALL DECODEIJ(IJ,I,J)
        IF(IJ.GT.0.AND.I.NE.J) THEN
        NATOMBOND(I) = NATOMBOND(I) + 1
        NATOMBOND(J) = NATOMBOND(J) + 1
        END IF
      END DO
C
C
C     NOW, SET LMO BOND INDEX
C
      DO I=1, NATOMS
      IF((NATNNU(I).GE.7.AND.NATNNU(I).LE.9).OR.(NATNNU(I).GE.15.AND.
     &    NATNNU(I).LE.17).OR.NATNNU(I).EQ.35.OR.NATNNU(I).EQ.53) THEN
C
C     COLLECT LMOs ON LP ATOMS
C     N,O,F,P,S,Cl,Br,I
C
      NATOMLP(I) = 4 - NATOMBOND(I)
      END IF
      END DO
      DO I=1, NATOMS
      II = I*(I+1)/2
      ICOUNT = 0
        DO LMODEX =1,NCORE
        IF(LMOLAB(1,LMODEX).EQ.II) THEN
        ICOUNT = ICOUNT + 1
        LMOLAB(2,LMODEX) = ICOUNT
        END IF
        END DO
      NAOFFSET(I) = ICOUNT - NATOMLP(I)
      END DO
      DO IJ=1, NAT2
      CALL DECODEIJ(IJ,I,J)
      ICOUNT = 0
        DO LMODEX =1,NCORE
        IF(LMOLAB(1,LMODEX).EQ.IJ) THEN
          ICOUNT = ICOUNT + 1
          LMOLAB(2,LMODEX) = ICOUNT
C
C       LONE PAIR INDEX
C
          IF(I.EQ.J) THEN
          LPINDX = ICOUNT - NAOFFSET(I)
          IF(LPINDX.LT.0) LPINDX = 0
          LMOLAB(2,LMODEX) = LPINDX
          END IF
        END IF
        END DO
      END DO
C
C     FIND LMO BOND TYPE, AND CANONICALIZE LPs, AND MULTIPLE PI BONDS
C
      CALL LOCTOR(IOENGI,'$CANONLP',8,IOK,0)
      IF(IOK.EQ.1) THEN
C
C     FIRST, CANONLP
C
      CALL CANONLP(NATOMS,NCORE,LMOLAB,NATNNU,VLMO,
     &             NBASIS,S,BFLABE,NAOST,W,IOLVBO)
      END IF
C100  CONTINUE
C
C     COPY ALL NEW LMOs to WLMO
C
      DO I=1, NBASIS*NCORE
      WLMO(I) = VLMO(I)
      END DO
      CALL LOCTOR(IOENGI,'$CANONPI',8,IOK,0)
      IF(IOK.EQ.1) THEN
C
C     THEN, CANONPI
C
      CALL CANONPI(NATOMS,NCORE,LMOLAB,VLMO,NBASIS,S,W,IOLVBO,IFAIL)
      END IF
C200  CONTINUE
C
C     COPY ALL NEW LMOs to WLMO
C
      DO I=1, NBASIS*NCORE
      WLMO(I) = VLMO(I)
      END DO
C
C     RE-COMPUTE PGM
C
      NT=0
      DO 1 I=1,NATOMS
      DO 2 J=1,NAO(I)
      NT=NT+1
      NA(NT)=I
  2   CONTINUE
  1   CONTINUE
      DO 520 I=1,NCORE
      II = (I-1)*NATOMS
      IV = (I-1)*NBASIS
      DO 540 K=1,NATOMS
  540 PGM(K+II)=0.0D0
      DO 530 K=1,NBASIS
      KN=NA(K)
      DO 530 L=1,NBASIS
      LN=NA(L)
      IF(K.GT.L) THEN
      KL=K*(K-1)/2+L
      ELSE
      KL=L*(L-1)/2+K
      END IF
      PGM(KN+II)=PGM(KN+II)+VLMO(L+IV)*S(KL)*VLMO(K+IV)
      PGM(LN+II)=PGM(LN+II)+VLMO(L+IV)*S(KL)*VLMO(K+IV)
  530 CONTINUE
  520 CONTINUE
C
C     CREATE LMO LABELS
C
      CALL CLMOLAB(LMOLAB,BONDLAB,NCORE,MCINDEX)
      IF(LPRT.EQ.1) THEN
      CALL MPRINT(VLMO,ENGLMO,NBASIS,NCORE,5,BFLABE,BONDLAB)
      CALL MPRINT(PGM,ENGLMO,NATOMS,NCORE,2,BFLABE,BONDLAB)
      END IF
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     CREATED NOV. 10, 2003
C
C     NOTE: IF THERE ARE MORE THAN 99 ATOMS, THE LABEL MAY NOT BE
C           PROPERLY CREATED.
C
C     AUTHOR: JIABO LI
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE CLMOLAB(LMOLAB,BONDLAB,NLMO,MCINDEX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*8 BONDLAB(*)
      CHARACTER*80 NUMBER,FLAG
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     DIMENSION LMOLAB(2,*),MCLMO(5,20)
      DIMENSION LMOLAB(2,*)
C     USE OF NUMBER RETAINED HERE AS IT IS COMPACT
      NUMBER   = '0123456789'
      DO I=1, NLMO
      FLAG     = ' '
      II  = LMOLAB(1,I)
      NBC = LMOLAB(2,I) + 1
      IF(II.EQ.MCINDEX) THEN
      FLAG(1:2)='MC'
      NCC = 2
      ELSE
      CALL DECODEIJ(II,IA,IB)
      IF(IA.GT.99.OR.IB.GT.99) WRITE(IOUTVB,*)
     & 'WARNING: LMO LABEL TRUNCATED!'
      NC1      = 1+IA/10
      NC2      = 1+IA-10*(NC1-1)
      NCC = 0
        IF(NC1.GT.1) THEN
        NCC = NCC + 1
        FLAG(NCC:NCC) = NUMBER(NC1:NC1)
        END IF
        NCC = NCC + 1
        FLAG(NCC:NCC) = NUMBER(NC2:NC2)
        IF(IA.NE.IB) THEN
        NCC = NCC + 1
        FLAG(NCC:NCC) = '-'
        NC1      = 1+IB/10
        NC2      = 1+IB-10*(NC1-1)
          IF(NC1.GT.1) THEN
          NCC = NCC + 1
          FLAG(NCC:NCC) = NUMBER(NC1:NC1)
          END IF
          NCC = NCC + 1
          FLAG(NCC:NCC) = NUMBER(NC2:NC2)
        ELSE
        NCC = NCC + 1
        FLAG(NCC:NCC) = ':'
        END IF
      END IF
      NCC = NCC + 1
      FLAG(NCC:NCC)='('
      NCC = NCC + 1
      FLAG(NCC:NCC)= NUMBER(NBC:NBC)
      NCC = NCC + 1
      FLAG(NCC:NCC)= ')'
        IF(NCC.LT.8) THEN
        IDFF= 8-NCC
        DO J=8, IDFF+1, -1
        FLAG(J:J) = FLAG(J-IDFF:J-IDFF)
        END DO
        DO J=1, IDFF
        FLAG(J:J) = ' '
        END DO
        END IF
      BONDLAB(I) = FLAG(1:8)
      END DO
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     CREATED VBO LABEL
C
C     NOTE: IF THERE ARE MORE THAN 99 ATOMS, THE LABEL MAY NOT BE
C           PROPERLY CREATED.
C
C     NOV. 18, 2003
C
C     AUTHOR: JIABO LI
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE CVBOLAB(NATOM1,NATOM2,NBTYPE,NBINDX,ATEMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 ATEMP
      CHARACTER*80 NUMBER,FLAG
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      NUMBER   = '0123456789'
      IF(NATOM1.GT.99.OR.NATOM2.GT.99)
     &     WRITE(IOUTVB,*)'WARNING: LMO LABELS ARE TRUNCATED!'
      IF(NBTYPE.LT.1.OR.NBTYPE.GT.3) THEN
      ATEMP = 'UNKNOWN!'
      RETURN
      END IF
      NBC = NBINDX + 1
      NC1      = 1+NATOM1/10
      NC2      = 1+NATOM1-10*(NC1-1)
      NCC = 0
      IF(NC1.GT.1) THEN
      NCC = NCC + 1
      FLAG(NCC:NCC) = NUMBER(NC1:NC1)
      END IF
      NCC = NCC + 1
      FLAG(NCC:NCC) = NUMBER(NC2:NC2)
C
C     SIGMA
C
      IF(NBTYPE.EQ.1) THEN
        NCC = NCC + 1
        FLAG(NCC:NCC) = '-'
        NCC = NCC + 1
        FLAG(NCC:NCC) = '>'
        NC1      = 1+NATOM2/10
        NC2      = 1+NATOM2-10*(NC1-1)
        IF(NC1.GT.1) THEN
        NCC = NCC + 1
        FLAG(NCC:NCC) = NUMBER(NC1:NC1)
        END IF
        NCC = NCC + 1
        FLAG(NCC:NCC) = NUMBER(NC2:NC2)
      ELSE IF(NBTYPE.EQ.2) THEN
C
C     PI
C
        NCC = NCC + 1
        FLAG(NCC:NCC) = '^'
      ELSE IF(NBTYPE.EQ.3) THEN
C
C     LP
C
        NCC = NCC + 1
        FLAG(NCC:NCC) = ':'
      END IF
      NCC = NCC + 1
      FLAG(NCC:NCC)='('
      NCC = NCC + 1
      FLAG(NCC:NCC)= NUMBER(NBC:NBC)
      NCC = NCC + 1
      FLAG(NCC:NCC)= ')'
        IF(NCC.LT.8) THEN
        IDFF= 8-NCC
        DO J=8, IDFF+1, -1
        FLAG(J:J) = FLAG(J-IDFF:J-IDFF)
        END DO
        DO J=1, IDFF
        FLAG(J:J) = ' '
        END DO
        END IF
      ATEMP = FLAG(1:8)
      RETURN
      END
      SUBROUTINE DECODEIJ(II,IA,IB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      IA = INT(DSQRT(II+II+1.00000001D0))
      IB = II - IA*(IA-1)/2
      IF(IB.GT.IA) THEN
        IB = IB - IA
        IA = IA + 1
      END IF
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     CANONICALIZE THE LP DIRECTIONS OF LMOs ON N,O,F,P,S,Cl,Br and I
C
C     FIND STANDARD LP DIRECTIONS, AND PERFORM TRANSFORMATION OF THE
C     CORRESPONDING LMOS SO THAT THE LMOS HAVE THE STANDARD ORIENTATION
C     THE LMOLAB(2,I) ALSO HAVE THE CORRECT INDEXES.
C
C     CREATED ON NOV. 1, 2003
C
C     AUTHOR: JIABO LI
C     SAN DIEGO
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     SUBROUTINE CANONLP(NATOMS,NLMO,LMOLAB,NBONDALIST,NATNNU,VLMO,
      SUBROUTINE CANONLP(NATOMS,NLMO,LMOLAB,NATNNU,VLMO,
     &             NBASIS,S,BFLABE,NAOST,W,IOLVBO)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 AOLABEL(1000),ATEMP,BTEMP,BFLABE(*)
C     DIMENSION VLMO(NBASIS,*),S(*),LMOLAB(2,*),NBONDALIST(10,*)
      DIMENSION VLMO(NBASIS,*),S(*),LMOLAB(2,*)
      DIMENSION VLP(10000),NATNNU(*),W(*),NAOST(*),TMPDIR(3,10)
      DIMENSION VBOLP(1000),PLVBDIR(3),VBOLDIR(3),VTMP(1000)
      DIMENSION RMAT(3,3),LPTYPE(10),PROJECTION(10,100),RLP(100)
      DIMENSION IN(100),MASKLP(100),LP2LMO(10),LMOMAPED(100)
      DIMENSION LMOIDX(100),NATOMBOND(1000)
C
C     SET UP ATOM BOND INDEX
C
C     NATOMBOND(I) = THE NUMBER OF BONDS OF ATOM I. SINGLE BOND COUNTS 1,
C                    DOUBLE BOND COUNTS 2, AND TRIPLE BOND COUNTS 3
C                    NOTE: MULTI-CENTER BONDS ARE IGNORED.
C
      DO K=1, NATOMS
      NATOMBOND(K) = 0
      END DO
      DO K=1, NLMO
      IJ = LMOLAB(1,K)
      CALL DECODEIJ(IJ,I,J)
        IF(IJ.GT.0.AND.I.NE.J) THEN
        NATOMBOND(I) = NATOMBOND(I) + 1
        NATOMBOND(J) = NATOMBOND(J) + 1
        END IF
      END DO
      DO I=1, NATOMS
      IF((NATNNU(I).GE.7.AND.NATNNU(I).LE.9).OR.(NATNNU(I).GE.15.AND.
     &    NATNNU(I).LE.17).OR.NATNNU(I).EQ.35.OR.NATNNU(I).EQ.53) THEN
C
C     COLLECT LMOs ON LP ATOMS
C     N,O,F,P,S,Cl,Br,I
C
      II = I*(I+1)/2
      NACORE = 0
        DO J=NLMO,1,-1
        IF(LMOLAB(1,J).EQ.II) THEN
        NACORE = NACORE + 1
        LMOIDX(NACORE) = J
        NAB = (NACORE-1)*NBASIS
        JJ  = (J-1)*NBASIS
          DO K=1, NBASIS
          W(NAB+K) = VLMO(K,J)
          END DO
        END IF
        END DO
C
C     NOW, W HOLDS THE LP LMOs ON ATOM I
C     WRITE(IOUTVB,*)'LP ON ATOM I, NACORE=',I,NACORE
      DO J=1, NACORE
      LMOID = LMOIDX(J)
      LMOLAB(2,LMOID) = 0
      END DO
C
C     GENERATE STANDARD LP VBOS
C
C
C     LONE PAIR VBO
C
      NATOM1 = I
      NATNUM = NATNNU(NATOM1)
C     NBONDS = NBONDALIST(1,NATOM1)
      NAOSTI = NAOST(NATOM1)
      CALL FINDLPDIR(NATOM1,NLP,LPTYPE,TMPDIR,IERR)
C
C     IN H...F...H, NLP = 2
C
      IF(NLP.GT.(4 - NATOMBOND(NATOM1))) NLP = 4 - NATOMBOND(NATOM1)
C
C     IACORE = NACORE - NLP
      NACORE = NLP
C     WRITE(IOUTVB,*)'NLP FINAL = ',NLP
C
C     SET DEFAULT VALANCE LP INDEXES
C
C     DO J=1, NLP
C     LMOLAB(2,J+IACORE) = J
C     END DO
      IF(IOLVBO.EQ.0) GOTO 300
C
C     LOOP OVER ALL LPs
C
      DO J=1, NLP
      LPDEX = J
      LPTYPEJ = LPTYPE(J)
      CALL LOOKLP(NATNUM,VBOLDIR,VBOLP,AOLABEL,NAOFRG,
     &               LPTYPEJ,IOLVBO)
C
C     FIND THE LP DIR IN THE MOL
C
      PLVBDIR(1) = TMPDIR(1,LPDEX)
      PLVBDIR(2) = TMPDIR(2,LPDEX)
      PLVBDIR(3) = TMPDIR(3,LPDEX)
C
C     FIND TRAN MATRIX RMAT, WHICH TRANSLATE VBOLDIR TO PLVBDIR,
C     I.E. RMAT VBOLDIR = PLVBDIR
C
      CALL TRNV2V(VBOLDIR,PLVBDIR,RMAT,IERR)
      IF(IERR.EQ.1) CALL ABORT0('CANONLP001')
C
C     COPY FROM VBOLP TO VTEMP
C
        DO K=1, NBASIS
        VTMP(K) = 0.0D0
        END DO
        DO K=1, NAOFRG
        VTMP(NAOSTI+K-1) = VBOLP(K)
        ATEMP = AOLABEL(K)
        BTEMP = BFLABE(NAOSTI+K-1)
        IF(ATEMP(11:12).NE.BTEMP(11:12)) CALL ABORT0('CANONLP002')
        END DO
C
C     TRANSLATE LIB VBO TO MOL VBO
C
      CALL ORBTRN(NAOFRG,1,BFLABE(NAOSTI),VTMP(NAOSTI),RMAT,
     &            VTMP(NAOSTI))
C
C     NOW, COPY VTMP TO VLP
C
      JJ = (J-1)*NBASIS
        DO K=1, NBASIS
        VLP(JJ+K) = VTMP(K)
        END DO
C
C     LOOP OVER LPs ON A LP ATOM
C
      END DO
C
C     NOW, VLP HOLDS THE LP VBOs ON ATOM I
C
      DO J=1, NLP
      JJ = (J-1)*NBASIS
C
C     NORMALIZATION OF THE ORBITAL
C
      CALL NORMORB(NBASIS,1,VLP(JJ+1),S,IERR)
      END DO
C
C     OVERLAPS
C
        DO K=1, NACORE
        KK = (K-1)*NBASIS
        VL = 0.0D0
          DO J=1, NLP
          JJ = (J-1)*NBASIS
          CALL ORBOVL(NBASIS,VLP(JJ+1),W(KK+1),S,AB)
          PROJECTION(J,K) = AB
          VL = VL + AB*AB
C         WRITE(IOUTVB,*)'LMO K PROJECTED INTO LP J =', K,J,AB
          END DO
        RLP(K) = VL
        END DO
C
C     FIND NLP LARGEST VLP
C
      CALL SHELL(RLP,IN,NACORE)
C
C     DEFINE MASK
C
        DO J=1, NACORE
        MASKLP(J) = 0
        LMOMAPED(J) = 0
        END DO
        DO J=NACORE,NACORE-NLP+1,-1
        MASKLP(IN(J)) = 1
        END DO
C
C     APPLY MASK ON PROJECTION MATRIX
C
        DO J=1, NLP
        PMAX =0.0D0
        LMODEX = 0
          DO K=1, NACORE
          PROJECTION(J,K) = PROJECTION(J,K)*MASKLP(K)
          IF(PMAX.LT.DABS(PROJECTION(J,K)).AND.LMOMAPED(K).EQ.0) THEN
             PMAX = DABS(PROJECTION(J,K))
             LMODEX = K
          END IF
          END DO
        IF(LMODEX.EQ.0) CALL ABORT0('CANONLP003')
        LP2LMO(J) = LMODEX
        LMOMAPED(LMODEX) = 1
        END DO
C       WRITE(IOUTVB,*)'LP2LMO MAP 1 =',(LP2LMO(J),J=1, NLP)
C       WRITE(IOUTVB,*)'LP2LMO MAP 2 =',(LMOIDX(LP2LMO(J)),J=1, NLP)
C
C     SET BONDTYPE TO ZERO FOR ALL LMOS ON THE ATOM
C
        DO J=1, NACORE
        LMOLAB(2,LMOIDX(J)) = 0
        END DO
C
C     LABEL LP LMOS
C
        DO J=1, NLP
        LMOLAB(2,LMOIDX(LP2LMO(J))) = J
        END DO

C
C     DEFINE NEW LPs AND THE MAP TO LMOs
C
        DO J=1, NLP
        JJ = (J-1)*NBASIS
          DO K=1, NBASIS
          VLP(JJ+K) = 0.0D0
          END DO
          DO K=1, NACORE
          KK = (K-1)*NBASIS
            DO L=1,NBASIS
            VLP(JJ+L) = VLP(JJ+L)+PROJECTION(J,K)*W(KK+L)
            END DO
          END DO
C
C         NORMALIZATION
C
          CALL NORMORB(NBASIS,1,VLP(JJ+1),S,IERR)
          IF(IERR.EQ.1) CALL ABORT0('CANONLP004')
C
C       COPY VLP TO LMO
C
          LMODXJ = LMOIDX(LP2LMO(J))
          DO L=1, NBASIS
          VLMO(L, LMODXJ) = VLP(JJ+L)
          END DO
        END DO
C-------------------------------------------------------------------------
C
C     PERFORM LOWDIN ORTHOGONALIZAITON OF LPs
C
        NSS= 1
        NSA=NSS+NBASIS*NBASIS
        NV =NSA+NBASIS*NBASIS
        NW =NV +NBASIS*NBASIS
C       NWK=NW +NBASIS*NBASIS
C
C       S->W(NSS)
C
        DO 200 J=1,NBASIS
        JJ=NSS-1+(J-1)*NBASIS
        DO 200 K=1,NBASIS
        W(JJ+K)=S(IJ00(J,K))
 200    CONTINUE
C
C     Lowdin orthogonalization of all VBOs on the atom
C
        CALL LOWD(NBASIS,NLP,W(NSS),VLP,W(NSA),W(NV),W(NW),IERR)
        IF(IERR.EQ.1) CALL ABORT0('CANONLP005')
C
C     COPY W(NV) TO VLMO
C
        DO J=1, NLP
        JJ = NV-1+(J-1)*NBASIS
C
C       COPY VLP TO LMO
C
          LMODXJ = LMOIDX(LP2LMO(J))
          DO L=1, NBASIS
          VLMO(L, LMODXJ) = W(JJ+L)
          END DO
        END DO
C-------------------------------------------------------------------------
C
C     IF OF LP ATOMS
C
      ELSE
C     IF IS NON-LP ATOMS
      II = I*(I+1)/2
        DO J=1, NLMO
C       MARK IT AS A CORE
        IF(LMOLAB(1,J).EQ.II) LMOLAB(2,J) = 0
        END DO
      END IF
  300 CONTINUE
C
C     LOOP OVER ATOMS
C
      END DO
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     CANONICALIZE THE PI ORBITAL LMOs ON TRIPLE BONDS (SUCH AS CN, CC ETC
C
C     FIND STANDARD PI DIRECTIONS FOR MULTIPLE PI BONDS, AND PERFORM
C     TRANSLATION OF LMOS SO THAT THEY HAVE THE STANDARD ORIENTATION
C     THE LMOLAB(2,I) ALSO HAVE THE CORRECT INDEXES.
C
C     CREATED ON NOV. 7, 2003
C
C     AUTHOR: JIABO LI
C     SAN DIEGO
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE CANONPI(NATOMS,NLMO,LMOLAB,VLMO,NBASIS,S,W,IOLVBO,
     & IFAIL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*12 AOLABEL(1000),ATEMP,BTEMP,BFLABE(*)
C     DIMENSION VLMO(NBASIS,*),S(*),LMOLAB(2,*),NBONDALIST(10,*)
      DIMENSION VLMO(NBASIS,*),S(*),LMOLAB(2,*)
C     DIMENSION BLMO(10000),NATNNU(*),W(*),NAOST(*),TMPDIR(3,10)
      DIMENSION BLMO(10000),W(*)
C     DIMENSION VBOLP(1000),PLVBDIR(3),VBOLDIR(3),VTMP(1000)
C     DIMENSION RMAT(3,3),LPTYPE(10),PROJECTION(10,100),RLP(100)
      DIMENSION PROJECTION(10,100)
C     DIMENSION IN(100),MASKLP(100),LPI2LMO(10),LMOMAPED(100)
      DIMENSION LPI2LMO(10),LMOMAPED(100)
      DIMENSION LMOIDX(100)
      IFAIL = 0
C
      DO IA=1, NATOMS
      DO IB=IA+1, NATOMS
      IAXX = IA
      IBXX = IB
C
C     COLLECT LMOs BEWTEEN ATOMS IA AND IB
C
      IAB = IB*(IB-1)/2 + IA
      LMOBONDS = 0
        DO J=1, NLMO
        IF(LMOLAB(1,J).EQ.IAB) THEN
        LMOBONDS = LMOBONDS + 1
        LMOLAB(2,J)=LMOBONDS
        LMOIDX(LMOBONDS) = J
        NAB = (LMOBONDS-1)*NBASIS
        JJ  = (J-1)*NBASIS
          DO K=1, NBASIS
          W(NAB+K) = VLMO(K,J)
          END DO
        END IF
        END DO
C
C     NOW, W HOLDS THE BONDING LMOs BEWTEEN ATOM IA AND IB
C
      DO J=1, LMOBONDS
      JJ = (J-1)*NBASIS
        DO K=1, NBASIS
C       WRITE(IOUTVB,'(2X,F10.5)')W(JJ+K)
        END DO
      END DO
C
C     DO NOTHING FOR A SINGLE AND DOUBLE BOND
C
      IF(LMOBONDS.LE.2.OR.IOLVBO.EQ.0) GOTO 300
C
C     GENERATE STANDARD BONDING LMOS BETWEEN ATOM1 AND ATOM2
C
C     THREE LMOs WILL BE RETURNED. FIRST IS A SIGMA, SECOND IS THE 1ST PI
C     THRID THE 2ND PI. IERR IS THE ERROR CODE (0/1 = NO ERROR/ERROR)
C
C     WRITE(IOUTVB,*)'CREATE STD BONDING LMOs'
      CALL GENBDLMO(IAXX,IBXX,NBASIS,BLMO,LMOBONDS,IOLVBO,IERR)
        IF(IERR.EQ.1) THEN
        IFAIL = 1
        GOTO 300
        END IF
      NBLMO = LMOBONDS
      DO J=1, NBLMO
      JJ = (J-1)*NBASIS
C
C     NORMALIZATION OF THE ORBITAL
C
      CALL NORMORB(NBASIS,1,BLMO(JJ+1),S,IERR)
C     WRITE(IOUTVB,*)(BLMO(JJ+K),K=1,NBASIS)
      END DO
C
C     OVERLAPS
C
        DO K=1, LMOBONDS
        KK = (K-1)*NBASIS
        VL = 0.0D0
          DO J=1, NBLMO
          JJ = (J-1)*NBASIS
          CALL ORBOVL(NBASIS,BLMO(JJ+1),W(KK+1),S,AB)
          PROJECTION(J,K) = AB
          VL = VL + AB*AB
C         WRITE(IOUTVB,*)'LMO K PROJECTED INTO STD BLMO J =', K,J,AB
          END DO
C       RLP(K) = VL
        END DO
        DO J=1, LMOBONDS
        LMOMAPED(J) = 0
        END DO
C       WRITE(IOUTVB,*)'LMOMAPED =',(LMOMAPED(K),K=1,LMOBONDS)
        DO J=1, NBLMO
        PMAX =0.0D0
        LMODEX = 0
C       WRITE(IOUTVB,*)'LMOBONDS, NBLMO,IA,IB =',LMOBONDS,NBLMO,IA,IB
          DO K=1, LMOBONDS
          IF(PMAX.LT.DABS(PROJECTION(J,K)).AND.LMOMAPED(K).EQ.0) THEN
             PMAX = DABS(PROJECTION(J,K))
             LMODEX = K
          END IF
          END DO
        IF(LMODEX.EQ.0) CALL ABORT0('CANONPIX  ')
        LPI2LMO(J) = LMODEX
        LMOMAPED(LMODEX) = 1
        END DO
C
C     DEFINE NEW BLMO AND THE MAP TO LMOs
C
        DO J=1, NBLMO
        JJ = (J-1)*NBASIS
          DO K=1, NBASIS
          BLMO(JJ+K) = 0.0D0
          END DO
          DO K=1, LMOBONDS
          KK = (K-1)*NBASIS
            DO L=1,NBASIS
            BLMO(JJ+L) = BLMO(JJ+L)+PROJECTION(J,K)*W(KK+L)
            END DO
          END DO
C
C       COPY BLMO TO LMO, RELABE BOND INDEX (1=SIGMA, 2=1st PI; 3=2nd PI)
C
          LMODXJ = LMOIDX(LPI2LMO(J))
          DO L=1, NBASIS
          VLMO(L, LMODXJ) = BLMO(JJ+L)
          END DO
C
        LMOLAB(2,LMODXJ)=J
        END DO
C-------------------------------------------------------------------------
C
C     PERFORM LOWDIN ORTHOGONALIZAITON OF LPs
C
        NSS= 1
        NSA=NSS+NBASIS*NBASIS
        NV =NSA+NBASIS*NBASIS
        NW =NV +NBASIS*NBASIS
C       NWK=NW +NBASIS*NBASIS
C
C       S->W(NSS)
C
        DO 200 J=1,NBASIS
        JJ=NSS-1+(J-1)*NBASIS
        DO 200 K=1,NBASIS
        W(JJ+K)=S(IJ00(J,K))
 200    CONTINUE
C
C     Lowdin orthogonalization of all VBOs on the atom
C
        CALL LOWD(NBASIS,LMOBONDS,W(NSS),BLMO,W(NSA),W(NV),W(NW),IERR)
        IF(IERR.EQ.1) CALL ABORT0('CANONPI01 ')
C
C     COPY W(NV) TO VLMO
C
        DO J=1, NBLMO
        JJ = NV-1+(J-1)*NBASIS
C
C       COPY VPI TO LMO
C
          LMODXJ = LMOIDX(LPI2LMO(J))
          DO L=1, NBASIS
C         VLMO(L, LMODXJ) = W(JJ+L)
          END DO
        END DO
  300 CONTINUE
C-------------------------------------------------------------------------
C
C     LOOP OVER J (ATOMS)
C
      END DO
C
C     LOOP OVER I (ATOMS)
C
      END DO
      RETURN
      END
      SUBROUTINE GENBDLMO(NATOM1,NATOM2,NBASIS,BLMO,LMOBONDS,
     &                    IOLVBO,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION BLMO(NBASIS,*),VBOD1(3),VBOD2(3),V1(2000),V2(2000)
      IERR = 0
      DO I=1, LMOBONDS
      NBTYPE = I
      CALL AVBOGEN(NATOM1,NATOM2,NBTYPE,V1,VBOD1,IOLVBO,IERR)
      CALL AVBOGEN(NATOM2,NATOM1,NBTYPE,V2,VBOD2,IOLVBO,IERR)
      CALL DOTPROD(VBOD1,VBOD2,AB)
      IF(DABS(AB).LT.0.866D0) THEN
      IERR = 1
      RETURN
      ELSE
        FACTOR = 1.0D0
        IF(DABS(AB).LT.0.0D0) FACTOR = -1.0D0
        DO J=1, NBASIS
        BLMO(J,I) = V1(J) + FACTOR*V2(J)
        END DO
      END IF
      END DO
      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     MATH ROUTINES
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     NORMALIZATION OF THE ORBITAL
C
C     A: INPUT ORBITALS
C     S: OVERLAP MATRIX LOWER HALF FORMAT
C     NBASIS: DIMENSION OF ORBITALS
C     NORB: NUMBER OF ORBITALS
C
C     CREATED NOV. 4, 2003
C
C     AUTHOR: JIABO LI
C
C     SAN DIEGO
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE NORMORB(NBASIS,NORB,A,S,IERR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(NBASIS,NORB),S(*)
      PARAMETER (EPS = 0.000001D0)
      IERR = 0
      DO 100 I=1, NORB
      SUM=0.0D0
      DO 110 J=1, NBASIS
      DO 110 K=1, NBASIS
 110  SUM=SUM+A(J,I)*S(IJ00(J,K))*A(K,I)
      SUM=DSQRT(SUM)
C     WRITE(IOUTVB,1) SUM
C1    FORMAT(" SUM = ",D20.4)
      IF(SUM.LT.EPS) THEN
      IERR = 1
      RETURN
      END IF
      DO 120 J=1,NBASIS
 120  A(J,I)=A(J,I)/SUM
 100  CONTINUE
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     OVERLAP OF TWO ORBITALS
C
C     A, B: INPUT ORBITALS
C     S: OVERLAP MATRIX, LOWER HALF FORMAT
C     NBASIS: DIMENSION OF ORBITALS
C     AB: RETURN VALUE OF THE OVERLAP OF A AND B
C
C     CREATED: NOV. 4, 2003
C
C     AUTHOR: JIABO LI
C
C     SAN DIEGO
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE ORBOVL(NBASIS,A,B,S,AB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(NBASIS), B(NBASIS), S(*)
      AB = 0.0D0
      DO 110 I=1, NBASIS
      DO 110 J=1, NBASIS
 110  AB=AB+A(I)*S(IJ00(I,J))*B(J)
      RETURN
      END
C
C     MATRIX  MULTIPLICATION
C     C=A*B,
C     A IS A SYMMETRIC MATRIX
C
      SUBROUTINE MATSYM(M,N,A,B,C)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(*),B(M,N),C(M,N)
      DO 100 I=1,N
      DO 100 J=1,M
      SUM=0.0D0
      IAJ=J*(J-1)/2
      DO 200 K=1,J
  200 SUM=SUM+A(IAJ+K)*B(K,I)
      IAK=J*(J+3)/2
      DO 250 K=J+1,M
      SUM=SUM+A(IAK)*B(K,I)
  250 IAK=IAK+K
  100 C(J,I)=SUM
      RETURN
      END
C
C     MATRIX  MULTIPLICATION
C     C=A*B',
C     A IS A SYMMETRIC MATRIX
C     B' IS THE TRANSPOSE OF MATRIX B
C
      SUBROUTINE MATSYM2(M,N,A,B,C)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(*),B(N,M),C(M,N)
      DO 100 I=1,N
      DO 100 J=1,M
      SUM=0.0D0
      IAJ=J*(J-1)/2
      DO 200 K=1,J
  200 SUM=SUM+A(IAJ+K)*B(I,K)
      IAK=J*(J+3)/2
      DO 250 K=J+1,M
      SUM=SUM+A(IAK)*B(I,K)
  250 IAK=IAK+K
  100 C(J,I)=SUM
      RETURN
      END
C
C     COPY VECTORS
C     A->B
C
      SUBROUTINE CPYVEC(N,A,B)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(N),B(N)
      DO 100 I=1,N
  100 B(I)=A(I)
      RETURN
      END
C
C     A,B ARE GENERAL MATRICES
C     C=A*B
C
      SUBROUTINE MATMUL2(M,L,N,A,B,C)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(M,L),B(L,N),C(M,N)
      DO 100 I=1,N
      DO 100 J=1,M
      SUM=0.0D0
      DO 200 K=1,L
  200 SUM=SUM+A(J,K)*B(K,I)
  100 C(J,I)=SUM
      RETURN
      END
C
C     MATRIX TRANSFORMATION
C     C=A'*B*A
C     B IS A SYMMETRIC MATRIX
C
      SUBROUTINE MATRAN(M,N,A,W,B,C)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(M,N),W(M,N),B(*),C(*)
      CALL MATSYM(M,N,B,A,W)
      IJ=0
      DO 100 I=1,N
      DO 100 J=1,I
      SUM=0.0D0
      IJ=IJ+1
      DO 110 K=1,M
  110 SUM=SUM+A(K,I)*W(K,J)
  100 C(IJ)=SUM
      RETURN
      END
C
C     MATRIX TRANSFORMATION
C     C=A*B*A'
C     B IS A SYMMETRIC MATRIX
C
      SUBROUTINE MATRAN1(M,N,A,W,B,C)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(N,M),W(M,N),B(*),C(*)
      CALL MATSYM2(M,N,B,A,W)
      IJ=0
      DO 100 I=1,N
      DO 100 J=1,I
      SUM=0.0D0
      IJ=IJ+1
      DO 110 K=1,M
  110 SUM=SUM+A(I,K)*W(K,J)
  100 C(IJ)=SUM
      RETURN
      END
C
C     MATRIX TRANSFORMATION
C     C=F1*C+F2*A*B*A'
C     B IS A SYMMETRIC MATRIX
C     F1,F2 ARE TWO CONSTRANTS
C
      SUBROUTINE MATRAN2(M,N,A,W,B,C,IFLAG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(N,M),W(M,N),B(*),C(*)
      IF(IFLAG.EQ.0) THEN
      F1=0.0D0
      F2=1.0D0
      ELSE IF(IFLAG.EQ.1) THEN
      F1=1.0D0
      F2=1.0D0
      ELSE IF(IFLAG.EQ.-1) THEN
      F1=1.0D0
      F2=-1.0D0
      END IF
      CALL MATSYM2(M,N,B,A,W)
      IJ=0
      DO 100 I=1,N
      DO 100 J=1,I
      SUM=0.0D0
      IJ=IJ+1
      DO 110 K=1,M
  110 SUM=SUM+A(I,K)*W(K,J)
  100 C(IJ)=F1*C(IJ)+F2*SUM
      RETURN
      END
      SUBROUTINE MALTID(M,D1,DC1,V)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION D1(M,M),DC1(M),V(M)
      DO 100 I=1,M
      DC1(I)=0.0D0
      DO 100 J=1,M
      DC1(I)=D1(J,I)*V(J)+DC1(I)
  100 CONTINUE
      RETURN
      END
      SUBROUTINE MALTSQ(M,MSQ,DSQ,DC1,V)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION DSQ(MSQ),DC1(M),V(M)
      DO 100 I=1,M
      DC1(I)=0.0D0
      IAI=I*(I-1)/2
      DO 110 J=1,I
      DC1(I)=DSQ(IAI+J)*V(J)+DC1(I)
  110 CONTINUE
      IAJ=I*(I+3)/2
      DO 120 J=I+1,M
      DC1(I)=DSQ(IAJ)*V(J)+DC1(I)
      IAJ=IAJ+J
  120 CONTINUE
  100 CONTINUE
      RETURN
      END
      FUNCTION IJKLGX(I,J,K,L)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /IDD/ID(100000)
      IJ=IJ01(I,J)
      KL=IJ01(K,L)
      IF(IJ.GE.KL) THEN
      IJKLGX=ID(IJ)+KL
      ELSE
      IJKLGX=ID(KL)+IJ
      END IF
      RETURN
      END
      FUNCTION IJKL01(I,J,K,L)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /IAA/IA(100000)
      IF(I.GT.J) THEN
      IJ=IA(I)+J
      ELSE
      IJ=IA(J)+I
      END IF
      IF(K.GT.L) THEN
      KL=IA(K)+L
      ELSE
      KL=IA(L)+K
      END IF
      IF(IJ.GT.KL) THEN
      IJKL01=IA(IJ)+KL
      ELSE
      IJKL01=IA(KL)+IJ
      END IF
      RETURN
      END
      SUBROUTINE DIAG(A,U,E,N,NDIM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C********************************************************************C
C   ARGUMENTS.                                                       C
C        A       MATRIX TO BE DIAGONALIZED.                          C
C        U       MATRIX OF EIGENVECTORS.                             C
C        E       LIST OF EIGENVALUES                                 C
C        N       # OF EIGENVALUES NEEDED                             C
C        NDIM    DIMENSION OF THE MATRICES AND THE VECTOR.           C
C********************************************************************C
      DIMENSION A(NDIM,NDIM),U(NDIM,NDIM),E(NDIM)
      DATA ZER,ONE,TWO,FOR,EPS/0.0D 00,1.0D 00,2.0D 00,4.0D 00,1.0D-30/
      DO 8 J=1,NDIM
      DO 9 I=1,NDIM
    9 U(I,J)=ZER
    8 U(J,J)=ONE
   10 AMAX=ZER
      DO 11 I=2,N
      JUP=I-1
      DO 11 J=1,JUP
      AII=A(I,I)
      AJJ=A(J,J)
      AOD=A(I,J)
      ASQ=AOD*AOD
      IF(ASQ.LE.AMAX) GOTO 23
      AMAX=ASQ
   23 IF(ASQ.LE.EPS) GOTO 11
      DIFFR=AII-AJJ
      IF(DIFFR.GE.0.0D0) GOTO 15
      SIGN=-TWO
      DIFFR=-DIFFR
      GO TO 16
   15 SIGN=TWO
   16 TDEN=DIFFR+ DSQRT(DIFFR*DIFFR+FOR*ASQ)
      TAN=SIGN*AOD/TDEN
      C=ONE/( DSQRT(ONE+TAN*TAN))
      S=C*TAN
      DO 24 K=1,N
      XJ=C*U(K,J)-S*U(K,I)
      U(K,I)=S*U(K,J)+C*U(K,I)
      U(K,J)=XJ
      IF(K.EQ.J) GOTO 24
      IF(K.EQ.I) GOTO 24
      XJ=C*A(K,J)-S*A(K,I)
      A(K,I)=S*A(K,J)+C*A(K,I)
      A(K,J)=XJ
      A(I,K)=A(K,I)
      A(J,K)=A(K,J)
   24 CONTINUE
      A(I,I)=C*C*AII+S*S*AJJ+TWO*S*C*AOD
      A(I,J)=ZER
       A(J,J)=C*C*AJJ+S*S*AII-TWO*S*C*AOD
      A(J,I)=ZER
   11 CONTINUE
      IF(AMAX.GT.EPS) GOTO 10
      DO 25 I=1,N
   25 E(I)=A(I,I)
CJLI
      CALL RORDER(U,A,E,N,NDIM)
CJLI
      RETURN
      END
      SUBROUTINE RORDER(C,PW,E,N,NDIM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION C(NDIM,N),PW(NDIM,N),IN(5000),E(*)
      IF(N.LE.0) RETURN
      CALL SHELL(E,IN,N)
      DO I=1,N
      II=IN(I)
      DO J=1,NDIM
      PW(J,I)=C(J,II)
      END DO
      END DO
      DO I=1,N
      DO J=1,NDIM
      C(J,I)=PW(J,I)
      END DO
      END DO
      RETURN
      END
C
C     THIS IS A SORTING ROUTINE
C
      SUBROUTINE SHELL(X,IN,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION X(N),IN(N)
      IF(N.LE.0) RETURN
      DO 100 I=1,N
 100  IN(I)=I
      J=N
  5   IF(J.EQ.1) GOTO 20
      J=J/2
      NMJ=N-J
  8   IFLAG=0
      DO 10 I=1,NMJ
      L=I+J
      IF(X(I).LE.X(L)) GOTO 10
      TX=X(I)
      IX=IN(I)
      X(I)=X(L)
      X(L)=TX
      IN(I)=IN(L)
      IN(L)=IX
      IFLAG=1
C     IFLAG=1.0
  10  CONTINUE
      IF(IFLAG.EQ.1) GOTO 8
      GOTO 5
 20   RETURN
      END
C
C     JACOBI METHOD FOR DIAGONLIZATION
C
C     THIS SUBROUTINE IS A PROGRAM FROM WHICH WE CAN OBTAIN
C     EIGENFUNCTIONS AND EIGENVALUES, WHERE MATRICES A AND B ARE
C     RESPECTIVELY HAMILTON AND OVERLAP MATRICES, D ARE EIGENVALUES,
C     AND E IS THE MIN. OF D. N IS THE DIMENSION OF MATRICE.
C
      SUBROUTINE EG(N,A,B,D,V,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION B(N,N),D(N),A(N,N),DL(5000),V(N,N),IN(5000),W(*)
      NWA=1
      NWK=NWA+N*(N+1)/2
      CALL REDUCVB2K(N,A,B,DL)
      DO 5 I=1,N
      DO 5 J=I,N
 5    A(I,J)=A(J,I)
      IJ=0
      DO 6 I=1,N
      DO 6 J=1,I
      IJ=IJ+1
 6    W(IJ)=A(J,I)
Cxxx  CALL JACOB(N,A,D,1,V)
Cxxx  CALL DiagD(W(NWA),V,D,N,W(NWK),W(NWK+N),N,.FALSE.)
      CALL GIVEIS(N,N,N,W(NWA),W(NWK),IN,D,V,IERR)
      CALL REBAC1(N,N,B,DL,V)
      CALL SHELL(D,IN,N)
      DO 200 I=1,N
      II=IN(I)
      DO 200 J=1,N
 200  B(J,I)=V(J,II)
      DO 210 I=1,N
      DO 210 J=1,N
 210  V(J,I)=B(J,I)
      IF(N.EQ.1) THEN
        V(1,1) = 1.0D0/SQRT(B(1,1))
      END IF
      RETURN
      END
C
      SUBROUTINE REDUCVB2K(N,A,B,DL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(N,N),B(N,N),DL(N)
      DO 110 I=1,N
      DO 110 J=I,N
      X=B(I,J)
      DO 140 K=1,I-1
140   X=X-B(I,K)*B(J,K)
      IF(I.EQ.J) THEN
      DL(I)=DSQRT(X)
      ELSE
      B(J,I)=X/DL(I)
      END IF
110   CONTINUE
      DO 210 I=1,N
      DO 210 J=I,N
      X=A(I,J)
      DO 240 K=1,I-1
240   X=X-B(I,K)*A(J,K)
      A(J,I)=X/DL(I)
210   CONTINUE
      DO 310 J=1,N
      DO 310 I=J,N
      X=A(I,J)
      DO 340 K=J,I-1
340   X=X-A(K,J)*B(I,K)
      DO 370 K=1,J-1
370   X=X-A(J,K)*B(I,K)
      A(I,J)=X/DL(I)
310   CONTINUE
      RETURN
      END
C
      SUBROUTINE REBAC1(N,M,B,DL,Z)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION B(N,N),DL(N),Z(N,M)
      DO 100 J=1,M
      DO 100 I1=1,N
      I=N-I1+1
      X=Z(I,J)
      I2=I+1
      DO 130 K=I2,N
130   X=X-B(K,I)*Z(K,J)
      Z(I,J)=X/DL(I)
100   CONTINUE
      RETURN
      END
      SUBROUTINE ABORT0(MESSAGE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*10 MESSAGE
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      WRITE(IOUTVB,*)'PROGRAM STOPPED AT ',MESSAGE(1:10)
      WRITE(IOUTVB,*)'PLEASE CHECK YOUR INPUT OR CONTACT THE AUTHORS AT'
      WRITE(IOUTVB,*)'vb@scinetec.com WITH THIS ERROR MESSAGE AND YOUR'
      WRITE(IOUTVB,*)'INPUT/OUTPUT FILES'
CGMS  CALL FLSHBF(IOUTVB)
CGMS  CALL ABRT
CGAU  CALL ABRTG(MESSAGE)
      STOP
      END
      SUBROUTINE ABRTVB()
CGMS  COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
CGMS  CALL FLSHBF(IW)
CGMS  CALL ABRT
CGAU  CALL ABRTG(' ')
      STOP
      END
      SUBROUTINE SIZEABT(N,M,CH1,CH2,IOUTVB,ABORT)
      IMPLICIT NONE
      LOGICAL ABORT
      INTEGER N,M,IOUTVB
      CHARACTER*12 CH1
      CHARACTER*6 CH2
      WRITE(IOUTVB,1) CH2
      WRITE(IOUTVB,2) CH1,N,CH2,M
      IF (CH2.EQ."MAXNAB") THEN
       WRITE(IOUTVB,'(" SEE MANUAL ON HOW TO CHANGE THIS.")')
      ELSE
       WRITE(IOUTVB,3) CH2
       WRITE(IOUTVB,'(1X,"/",A6,"=",I0,"/")') CH2,M
C      The above I0 format was introduced in F95, but appears to work
C      with all compilers. If not, use the commented lines below.
C
C      IF(M.LE.10) THEN
C        WRITE(IOUTVB,'(1X,"/",A6,"=",I1,"/")') CH2,M
C      ELSE IF (M.LE.100) THEN
C        WRITE(IOUTVB,'(1X,"/",A6,"=",I2,"/")') CH2,M
C      ELSE IF (M.LE.1000) THEN
C        WRITE(IOUTVB,'(1X,"/",A6,"=",I3,"/")') CH2,M
C      ELSE
C        WRITE(IOUTVB,'(1X,"/",A6,"=",I4,"/")') CH2,M
C      ENDIF 
C
       IF (CH2.NE."MAXBLL") THEN
CGMS   WRITE(IOUTVB,'(" YOU MAY NEED TO ALSO CHANGE vb2gms.src")')
CGAU   WRITE(IOUTVB,'(" YOU MAY NEED TO ALSO CHANGE vb2gau-so.src")')
       ENDIF
      ENDIF
      IF (CH2.EQ."MAXPRM") GOTO 5
C000  WRITE(IOUTVB,4) CH2
CSMI  WRITE(IOUTVB,4) CH2
 5    CONTINUE
      IF (ABORT) THEN
CGMS  CALL ENDGMS
      CALL ABRTVB()
      ENDIF
      RETURN
 1    FORMAT(" VARIABLE EXCEEDS PARAMETER ",A6) 
 2    FORMAT(1X,A12," =",I6," IS GREATER THAN OR EQUAL TO ",A6," =",I6)
 3    FORMAT(" IN vb2000.src, CHANGE ",A6," BY A GLOBAL EDIT OF ")
C0004 FORMAT(
C000 &" ALSO CHANGE ",A6," IN maxcen.inc FOR vb2000ints.src")
CSMI4 FORMAT(
CSMI &" ALSO CHANGE ",A6," IN maxcen.inc FOR vb2000ints.src")
      END
      SUBROUTINE PRECALC(ICHARGE,MULTIPLICITY,SOURCEDAT,IFLAG)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Pre-calculation process
C               (Key words parsing, basis set loading, inputs)
C
C     Note:
C               There are fifteen built-in basis sets. The list can be easily
C               extended by adding new basis set files to the basis set
C               directory BASET.
C
C     History:
C               First created in May 2000
C               Added output for input summary, July 2000
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 BUFF,WORD,KEYWORDS,COMMENTS,BASET,BLANK
      CHARACTER*20 SYMBOL,KEYNAMES
      CHARACTER*2 ATMSYM
      CHARACTER*8 BONDLAB
      CHARACTER*64 SOURCEDAT
      DIMENSION BASET(10000),KEYWORDS(100),LCTBAS(105),LENBAS(105)
      DIMENSION KEYLENS(100),KEYNAMES(100),KEYVALUES(1000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      PARAMETER (MAXCEN=200,MAXBFN=726)
CGAU  COMMON /CONG/ C(3,MAXCEN),IAN(MAXCEN),ILSW(100),JCHARGE,MULTIP
CGAU &,NATOMT,NLAB,NBASIST,NBSUSE,NE,LEN12L,LEN4L
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
      PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA,MAXGRP=99)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(MAXGRP),MSPIN(MAXGRP),MNORBIT(MAXGRP),
     &MLORBIT(MAXGRP),MWIN(MAXGRP),MSTR(MAXGRP),METHOD(MAXGRP),
     &IBASIS(MAXEXT),NOCC(MAXEXT),NOBIAS,NEPS,NVIR,NOTROT(5000),
     &LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(MAXGRP)
      PARAMETER (MAXNAB=MAXCEN*MAXBFN/2,MAXBF2=MAXBFN*MAXBFN)
      COMMON /LMODAT/VMO(MAXBF2),VLMO(MAXBF2),LMOLAB(2,MAXBFN),
     &LMOATM(5,MAXBFN),PGM(MAXNAB),ENGLMO(MAXBFN),BONDLAB(MAXBFN),
     &MCLMO(5,80),LHFLAG
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON /ATOMSY/ ATMSYM(92)
      COMMON /ATMCH/ ATMCHG(MAXCEN)
      BLANK(1:40)  = '                                        '
      BLANK(41:80) = '                                        '
      SYMBOL       = 'ATOM'
      ICURSOR      = 1
      LENBUF       = 80
C     iounit       = 5
      ITOPIC       = 1
C     IOENGI       = 80
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      NOBIAS=0
      LFROZN=0
      LCIONLY=0
      LPTALL=0
      LHYBRD=0
C
C     Wrong to set IFLAG here as it is comes in as parameter from VBENGINE
C     IFLAG =0
C  000  IFLAG =1
C  SMI  IFLAG =1
      SOURCEDAT=FSTR(1:LENFIL)//'.source'
C     SOURCEDAT='SOURCEDAT'
C     CALL LOCTOR(IOENGI,'#!',2,iok,1)
      CALL LOCTOR2(IOENGI,'#!',2,IOK,1,BUFF)
      IF(IOK.EQ.0) CALL ABORT0('NOKEYWORDS')
C     backspace(IOENGI)
C     read(IOENGI,'(A80)')buff
      WRITE(IOUTVB,101)
 101  FORMAT(' Input of molecule',/,' =================')
      CALL CONVCASE(BUFF,80,1)
      WRITE(IOUTVB,'(1X,A80)') BUFF
C
C     Do some clean-up (remove '/')
C
      DO I=1,LENBUF
      IF(BUFF(I:I).EQ.'/') BUFF(I:I)=' '
      END DO
      CALL READWDS(BUFF,KEYWORDS,KEYLENS,ICURSOR,LENBUF,NWORD)
C
C     A blank line to terminate keyword input
C
 100  READ(IOENGI,'(A80)')BUFF
      CALL CONVCASE(BUFF,80,1)
      WRITE(IOUTVB,'(1X,A80)') BUFF
      ICURSOR=1
      CALL READWDS(BUFF,KEYWORDS(NWORD+1),KEYLENS(NWORD+1),
     &             ICURSOR,LENBUF,NEWWORD)
      NWORD = NWORD + NEWWORD
      IF(NEWWORD.GT.0) GOTO 100
      ITOPIC=ITOPIC+1
C
C     setup keynames-values according to the keywords.
C
      CALL SETKEYVAL(NWORD,KEYWORDS,KEYNAMES,KEYVALUES)
      IRESTART=KEYVALUES(9)
C
C     method
C
      ICURSOR=1
      CALL PARMTHD(KEYWORDS(2),KEYLENS(2),MTHEORY,METHOD,NGPF,
     &             ICURSOR,MLORBIT,MELE)
      WORD    = KEYWORDS(3)
      BASNAME = WORD(1:20)
      DO I=1,105
      LCTBAS(I)=0
      LENBAS(I)=0
      END DO
C
C     Go to the next topic: comments
C
      READ(IOENGI,'(A80)')COMMENTS
      WRITE(IOUTVB,201) COMMENTS
 200  READ(IOENGI,'(A80)')BUFF
      IF(BUFF.NE.BLANK.AND.COMMENTS.NE.BLANK) THEN
      WRITE(IOUTVB,202) BUFF
         GOTO 200
      ENDIF
 201  FORMAT(' Title: ',A80)
 202  FORMAT('        ',A80)
      WRITE(IOUTVB,203)
 203  FORMAT(1X)
      IF(IFLAG.EQ.0) RETURN
C
C     Go to the next topic: charge and multiplicity
C
      ITOPIC=ITOPIC+1
      READ(IOENGI,*,ERR=901)ICHARGE,MULTIPLICITY
      GOTO 902
  901 WRITE(IOUTVB,*)"INPUT ERROR FOR CHARGE AND MULTIPLICITY"
      CALL ABORT0("PRECALC001")
  902 CONTINUE
CGAU  JCHARGE = ICHARGE
CGAU  MULTIP = MULTIPLICITY
      IF(IFLAG.EQ.2) RETURN
      WRITE(IOUTVB,900)ICHARGE, MULTIPLICITY
  900 FORMAT(' Charge =',I3,' Multiplicity =',I3)
C
C     Go to the next topic: read Cartesian coordiantes
C
      ITOPIC=ITOPIC+1
      NATOM=0
      NELECTRON = 0
 300  READ(IOENGI,'(A80)',ERR=400, END=400)BUFF
      IF(BUFF(1:80).EQ.BLANK(1:80)) GOTO 400
      NATOM = NATOM +1
      READ(BUFF(1:80),*,ERR=301)NATNUM(NATOM),(XYZ(J,NATOM),J=1,3)
      GOTO 303
 301  READ(BUFF(1:80),*,ERR=302)TNATNUM,(XYZ(J,NATOM),J=1,3)
      NATNUM(NATOM) = INT(TNATNUM + 0.1D0)
      GOTO 303
 302  WRITE(IOUTVB,*)
     &  "WRONG FORMAT IN YOUR INPUT. PLEASE CHECK THIS LINE"
      WRITE(IOUTVB,'(A80)') BUFF
      CALL ABORT0("INPUTERROR")
 303  CONTINUE
      NELECTRON = NELECTRON + NATNUM(NATOM)
      GOTO 300
 400  IF(NATOM.GE.MAXCEN) CALL SIZEABT(NATOM,MAXCEN,"NATOM       ",
     & "MAXCEN",IOUTVB,.TRUE.)
C
C     Check validity of Icharge and Multiplicity
C
      ITOPIC=ITOPIC+1
      NELECTRON = NELECTRON - ICHARGE
      NALPHA = (NELECTRON + MULTIPLICITY - 1)/2
      NBETA = (NELECTRON - MULTIPLICITY + 1)/2
      IF ((NALPHA + NBETA).NE.NELECTRON) THEN
        WRITE(IOUTVB,1400)
 1400   FORMAT(" Multiplicity and Nuclear Charge are not compatible",
     &  /," Please check and correct them. Exiting!",/)
        CALL ABRTVB
      ENDIF
C
C     SET UP FOR LHFSCF
C
      IF(MTHEORY.EQ.7) THEN
        LHFLAG     = 1
        MELE(1)    = NELECTRON
        MLORBIT(1) = NELECTRON/2
        METHOD(1)  = 2
      END IF
      IF(MTHEORY.EQ.8) THEN
        LHFLAG     = 2
        MELE(1)    = NELECTRON
        MLORBIT(1) = NELECTRON/2
        METHOD(1)  = 2
      END IF
C
C     load basis set
C
      CALL LOADBAS(BASNAME,BASET,LCTBAS,LENBAS)
      IOUNIT=99
      OPEN(IOUNIT,FILE=SOURCEDAT,STATUS='UNKNOWN',ACCESS='SEQUENTIAL',
     $FORM='FORMATTED')
      WRITE(IOUNIT,1000)
      SCALING=1.0D0
      IF(KEYVALUES(3).EQ.1) SCALING = 1.0D0/0.529177249D0
      WRITE(IOUTVB,102)
 102  FORMAT(/' Cartesian coordinates of atoms in Angstrom'/
     &   ' ----------------------------------------------------'/
     &   '                    X             Y             Z   '/)
      DO I=1,NATOM
C
C     atomic units
C
        DO J=1,3
        XYZ(J,I)=XYZ(J,I)*SCALING
        END DO
C
C     symbol, xyz, basis set
C
      ATMCHG(I)=NATNUM(I)
      WRITE(IOUNIT,1100)SYMBOL,ATMCHG(I),(XYZ(J,I),J=1,3)
C
C     Angstrom
C
      DO J=1,3
        XYZ(J,I)=XYZ(J,I)*0.529177249D0
      END DO
      WRITE(IOUTVB,1110) ATMSYM(NATNUM(I)),ATMCHG(I),(XYZ(J,I),J=1,3)
      IF(LENBAS(NATNUM(I)).LE.0) THEN
      WRITE(IOUTVB,103) NATNUM(I)
 103  FORMAT(' No basis set for element ')
      STOP
      END IF
      DO J=LCTBAS(NATNUM(I)),LCTBAS(NATNUM(I))+LENBAS(NATNUM(I))-1
      WRITE(IOUNIT,1200)BASET(J)
      END DO
      WRITE(IOUNIT,104)
 104  FORMAT('END')
      END DO
      WRITE(IOUTVB,105)
 105  FORMAT(' ----------------------------------------------------'/)
      WRITE(IOUNIT,1300)
      CLOSE(IOUNIT)
 1000 FORMAT('TITLE'/'BASIS SET'/'CONVERGENCE 7'/'PRINT 3'/'ATOMS')
 1100 FORMAT(A10,F8.1,3F20.10)
 1110 FORMAT(1X,A2,3X,F5.1,3F14.6)
 1200 FORMAT(A80)
 1300 FORMAT('END'/'RUNTYP INTEGRAL'/'START'/'FINISH'/'  ')
      RETURN
      END
C
C     prepare vb input file for reactor run at geom xyztmp
C     iovbin: original vb input file
C     iotemp: reaction path file
C     ioengi: working file for vb calculation at geom xyztmp
C
      SUBROUTINE VBINPUT(IOVBIN,IOENGI,XYZTMP,NATNUM,NATOMS,
     &                   IGUESSREAD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 BUFF,KEYWORDS,COMMENTS,BLANK
      DIMENSION KEYWORDS(100)
      DIMENSION KEYLENS(100)
      DIMENSION XYZTMP(3,*),NATNUM(*)
      BLANK(1:40)  = '                                        '
      BLANK(41:80) = '                                        '
C     SYMBOL       = 'ATOM'
      ICURSOR      = 1
      LENBUF       = 80
C     iovbin       = 5
      ITOPIC       = 1
      NWORD        = 0
C     IOENGI       = 80
C     NOBIAS=0
C     LFROZN=0
C     LCIONLY=0
C     LPTALL=0
C     LHYBRD=0
C     IFLAG =0
C 000  IFLAG =1
C SMI  IFLAG =1
      REWIND(IOENGI)
      REWIND(IOVBIN)
C     CALL LOCTOR(iovbin,'#!',2,iok,1)
      CALL LOCTOR2(IOVBIN,'#!',2,IOK,1,BUFF)
      IF(IOK.EQ.0) CALL ABORT0('NOKEYWORDS')
C     backspace(iovbin)
C     read(iovbin,'(A80)')buff
      WRITE(IOENGI,'(A80)') BUFF
      if(IGUESSREAD.GT.0) WRITE(IOENGI,*)'GUESS=READ'
C
C     A blank line to terminate keyword input
C
 100  READ(IOVBIN,'(A80)',END=110)BUFF
      CALL CONVCASE(BUFF,80,1)
      WRITE(IOENGI,'(A80)') BUFF
      ICURSOR=1
      CALL READWDS(BUFF,KEYWORDS(NWORD+1),KEYLENS(NWORD+1),
     &             ICURSOR,LENBUF,NEWWORD)
      NWORD = NWORD + NEWWORD
      IF(NEWWORD.GT.0) GOTO 100
 110  ITOPIC=ITOPIC+1
C
C     Go to the next topic: comments
C
      READ(IOVBIN,'(A80)') COMMENTS
      WRITE(IOENGI,'(A80)')comments
 200  READ(IOVBIN,'(A80)') BUFF
      WRITE(IOENGI,'(A80)') BUFF
      IF(BUFF.NE.BLANK.AND.COMMENTS.NE.BLANK) GOTO 200
C
C     Go to the next topic: charge and multiplicity
C
      ITOPIC=ITOPIC+1
      READ(IOVBIN,*) ICHARGE, MULTIPLICITY
      WRITE(IOENGI,*) ICHARGE, MULTIPLICITY
C
C     Go to the next topic: read Cartesian coordiantes
C
C     Skip Cartesian coordinates that follow Icharge and Multi
C
      ITOPIC=ITOPIC+1
      NATOM=0
 300  READ(IOVBIN,'(A80)')BUFF
      IF(BUFF(1:80).EQ.BLANK(1:80)) GOTO 400
      NATOM = NATOM +1
      GOTO 300
 400  ITOPIC=ITOPIC+1
      DO I=1, NATOMS
      WRITE(IOENGI,1000)NATNUM(I),XYZTMP(1,I),XYZTMP(2,I),XYZTMP(3,I)
      END DO
      WRITE(IOENGI,*)
 1000 FORMAT(I4,3F12.6)
 450  READ(IOVBIN,'(A80)',END=500,ERR=500)BUFF
      WRITE(IOENGI,'(A80)') BUFF
      GOTO 450
 500  CONTINUE
      RETURN
      END
      SUBROUTINE SETKEYVAL(NWORD,KEYWORDS,KEYNAMES,KEYVALUES)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*80 KEYWORDS,BASET,A,RESTFILE
      CHARACTER*80 KEYWORDS,A
      CHARACTER*20 KEYNAMES
      DIMENSION KEYWORDS(*),KEYNAMES(*),KEYVALUES(*)
      PARAMETER (MAXBFN=726)
      PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA,MAXGRP=99)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(MAXGRP),MSPIN(MAXGRP),MNORBIT(MAXGRP),
     &MLORBIT(MAXGRP),MWIN(MAXGRP),MSTR(MAXGRP),METHOD(MAXGRP),
     &IBASIS(MAXEXT),NOCC(MAXEXT),NOBIAS,NEPS,NVIR,NOTROT(5000),
     &LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(MAXGRP)
C     SAVE method, m,n,ng.
      KEYNAMES(1) = 'METHOD'
      KEYNAMES(2) = 'BASIS SET'
      KEYNAMES(3) = 'UNITS'
C
C     Some option key words are loaded from this section and
C     the values are stored in the common block GENCTL. To
C     keep the compatability with other packages, a second way of
C     loading these parameters is provided in INPUTVB.
C
C
C     key-values
C
C     keyvalues(1) = 1: HF
C                  = 2: VB(m)
C                  = 3: SCVB(m)
C                  = 4: CASVB(m,n)
C     (for 2-4)         THE m HIGHEST ENERGY ELECTRONS ARE TREATED BY
C                       VB METHOD. IF A LMO IS A BONDING ORBITAL, SPLIT IT
C                       FOR CASVB(m,n), SPLIT THE HIGHEST (n-m/2) ORBITALS.
C                       (if n < m/2, error!)
C                  = 5: GPF(n)
C                       n GROUPS. BY DEFAULT, IT HAS n-1 GVB PAIRS.
C                       (n-1) HIGHEST BONDING ORBITALS. IF NO MORE THAN
C                       (n-1) BONDING LMOs, error!
C                  = 6: Dot notation of GPF. For instance
C                       VB(n1).CASVB(n2,m2).VB(n3)
C                       Where n_i is the number of electrons in the VB group i.
C                       By default, VB group i has n_i vb orbitals, unless
C                       the number of orbitals is explicitly declared as in
C                       CASVB(n2,m2). In this case, the number of orbitals
C                       is m2. The number of orbitals can be modified by
C                       input $GRPDIM, which list the numbers of VB orbitals
C                       in each group.
C
C     keyvalues(2) = 1: D95
C                  = 2: MIDIX
C                  = 3: STO-3G
C                  = 4: STO-4G
C                  = 5: STO-6G
C                  = 6: 3-21G
C                  = 7: 3-21G*
C                  = 8: 6-31G
C                  = 9: 6-31G* (6-31GSTAR)
C                  = 10: 6-31+G* (6-31PGSTAR)
C                  = 11: 6-31G** (6-31G2STAR)
C                  = 12: 6-31++G** (6-31PPG2STAR)
C                  = 13: cc-pVDZ
C                  = 14: AUG-cc-pVDZ
C                  = 15: TZVP
C
C     keyvalues(3) = 1: Angstrom
C                  = 2: Bohr
C
C     keyvalues(4) = 1: FROZEN HF PART
C                  = 0: (DEFAULT) OPTIMIZE HF PART
C
C     keyvalues(5) = 1: CIONLY
C                  = 0: (DEFAULT) OPTIMIZE VB ORBITALS
C
C     keyvalues(6) = 1: HYBRID GUESS
C                  = 0: (DEFAULT) DLMO GUESS
C
C     keyvalues(7) = 1: PRINT ALL
C                  = 0: (DEFAULT) MINIMUM PRINT MESSAGE
C
C     keyvalues(8) = 1: NOBIAS
C                  = 0: (DEFAULT) NO-BIAS OPTIMIZATION IS OFF
C
C     keyvalues(9) = 1: Restart calculation, skip integration and HF calc.
C                  = 0: (DEFAULT) New calculation, must do HF
C
C     keyvalues(10)= 1: GUESS=READ. Read initial guess from previous
C                    0: (DEFAULT), controled by keyvalues(9)
C
C     keyvalues(11)= 1: Turn off rigid rotation
C                    0: (DEFAULT), Perform rigid rotation
C
C     keyvalues(12)= 1: Do test run only, stopping after output of initial quess
C                    0: (DEFAULT), Do full run
C
C     keyvalues(13)= 1: Calculate spin-density of VB wave function for VB group
C                       with spin-multiplicity > 1.
C                    0: Do not calculate spin-density
C
C     keyvalues(14)= 1: DIIS for VB orbital optimization
C                    0: DIIS disabled
C
C     keyvalues(15)= 1: SPHERICAL HARMONIC BASIS FUNCTIONS ARE USED
C                    0: CARTESIAN AOs ARE USED
C
C     setup defaults
      KEYVALUES(3) = 1
      KEYVALUES(4) = 0
      KEYVALUES(5) = 0
      KEYVALUES(6) = 0
      KEYVALUES(7) = 0
      KEYVALUES(8) = 0
      KEYVALUES(9) = 0
      KEYVALUES(10)= 0
      KEYVALUES(11)= 0
      KEYVALUES(12)= 0
      KEYVALUES(13)= 0
      KEYVALUES(14)= 0
      KEYVALUES(15)= 0
      LFROZN  = 0
      LCIONLY = 0
      LHYBRD  = 0
      LPTALL  = 0
      NOBIAS  = 0
      LTEST   = 0
C
C     Search for 'UNITS=BOHR'. If found, set keyvalues(3)=2.
C
      A='UNITS=BOHR'
      LEN = 10
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.EQ.1) KEYVALUES(3)=2
C
C     Search for 'FROZEN'. If found, set keyvalues(4)=1.
C
      A='FROZEN'
      LEN = 6
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.EQ.1) THEN
      KEYVALUES(4)=1
      LFROZN=1
      END IF
C
C     Search for 'CIONLY'. If found, set keyvalues(5)=1.
C
      A='CIONLY'
      LEN = 6
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.EQ.1) THEN
      KEYVALUES(5)=1
      LCIONLY=1
      END IF
C
C     Search for 'HYBRID'. If found, set keyvalues(6)=1.
C
      A='HYBRID'
      LEN = 6
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.EQ.1) THEN
      KEYVALUES(6)=1
      LHYBRD=1
      END IF
C
C     Search for 'PRINTALL'. If found, set keyvalues(7)=1.
C
      A='PRINTALL'
      LEN = 8
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.EQ.1) THEN
      KEYVALUES(7)=1
      LPTALL=1
      END IF
C
C     Search for 'NOBIAS'. If found, set keyvalues(8)=1.
C
      A='NOBIAS'
      LEN = 6
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.EQ.1) THEN
      KEYVALUES(8)=1
      NOBIAS=1
      END IF
C
C     Search for 'RESTART'. If found, set keyvalues(9)=2.
C
      A='RESTART'
      LEN = 7
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.EQ.1) THEN
        KEYVALUES(9) =2
        IRESTART     =2
        KEYVALUES(10)=1
      END IF
C
C     Search for 'LMONLY'. If found, set keyvalues(9)=-1.
C     LMO Only
C
      A='LMONLY'
      LEN = 6
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.EQ.1) THEN
      KEYVALUES(9)=-1
      IRESTART=-1
      END IF
C
C     Search for 'GUESS=READ'. If found, set keyvalues(10)=1.
C
      A='GUESS=READ'
      LEN = 10
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.EQ.1) THEN
      KEYVALUES(10)=1
      KEYVALUES(9) =1
      IRESTART     =1
      END IF
C
C     Search for 'NOROT'. If found, set keyvalues(11)=1.
C
      MROT = 1
      A='NOROT'
      LEN = 5
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.EQ.1) THEN
      KEYVALUES(11)=1
      MROT=0
      END IF
C
C     Search for 'TEST'. If found, set keyvalues(12)=1.
C
      A='TEST'
      LEN = 4
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.GE.1) THEN
      KEYVALUES(12)=1
      LTEST = 1
      LPTALL = 1
      END IF
C
C     Search for 'SPDEN'. If found, set keyvalues(13)=1.
C
      A='SPDEN'
      LEN = 5
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.GE.1) THEN
      KEYVALUES(13)=1
      END IF
C
C     Search for 'DIIS'. If found, set keyvalues(14)=1.
C
      A='DIIS'
      LEN = 4
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.GE.1) THEN
      KEYVALUES(14)=1
      END IF
C
C     Search for 'SPHER'. If found, set keyvalues(15)=1.
C
      A='SPHER'
      LEN = 5
      CALL SEARCHFOR(A,LEN,KEYWORDS,NWORD,IFOUND)
      IF(IFOUND.GE.1) THEN
      KEYVALUES(15)=1
      END IF
C
C     copy keyvalues to key
C
      DO I=1, 99
      KEY(I) = KEYVALUES(I)
      END DO
      RETURN
      END
      SUBROUTINE SEARCHFOR(STRING,LENSTR,KEYWORDS,NWORD,IFOUND)
      CHARACTER*80 KEYWORDS,A,B
      CHARACTER*1 STRING(*)
      DIMENSION KEYWORDS(*)
      DO I=1,LENSTR
      A(I:I)=STRING(I)
      END DO
      IFOUND = 0
      DO I=1,NWORD
      B = KEYWORDS(I)
      IF(A(1:LENSTR).EQ.B(1:LENSTR)) THEN
      IFOUND = 1
      END IF
      END DO
      RETURN
      END
      SUBROUTINE CONVCASE(STRING,LEN,ICASE)
      IMPLICIT NONE
      INTEGER ICASE,LEN,I,IC
      CHARACTER*(*) STRING
      CHARACTER*26 UCASE,LCASE
      DATA UCASE /'ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
      DATA LCASE /'abcdefghijklmnopqrstuvwxyz'/
C
C     ICASE = 1 lower --> upper
C     ICASE = 2 upper --> lower
      IF (ICASE.EQ.1) THEN
      DO I=1,LEN
         IC = INDEX(LCASE,STRING(I:I))
         IF (IC.GT.0) STRING(I:I) = UCASE(IC:IC)
      END DO
      RETURN
      ENDIF
      IF (ICASE.EQ.2) THEN
      DO I=1,LEN
         IC = INDEX(UCASE,STRING(I:I))
         IF (IC.GT.0) STRING(I:I) = LCASE(IC:IC)
      END DO
      RETURN
      ENDIF
      END
      SUBROUTINE LOADBAS(BASNAME,BASET,LCTBAS,LENBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 WORD,PATH,BASET,A,VBPATH,TPATH
      CHARACTER*20 BASNAME
      LOGICAL GOTPATH,GOTFILE
      DIMENSION BASET(*),LCTBAS(*),LENBAS(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      PATH='BASET/'
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL GETVBPATH(VBPATH)
 1100 FORMAT(/
     &' The following basis sets are available:'//
     &' D95:         Double-zeta basis set'/
     &' MIDIX:       MIDI! basis set (Uni. of Minnesota)'/
     &' STO-3G:      STO-3G basis set'/
     &' STO-4G:      STO-4G basis set'/
     &' STO-6G:      STO-6G basis set'/
     &' 3-21G:       3-21G basis set'/
     &' 3-21G*:      3-21G* basis set'/
     &' 6-31G:       6-31G basis set'/
     &' 6-31G*:      6-31G* basis set'/
     &' 6-31G**:     6-31G** basis set'/
     &' 6-31+G*:     6-31+G* basis set'/
     &' 6-31++G**:   6-31++G** basis set'/
     &' cc-pVDZ:     cc-pVDZ basis set'/
     &' AUG-cc-pVDZ: AUG-cc-pVDZ basis set'/
     &' TZVP:        Triple-zeta valence + polarisation basis set'/
     &'              but only TZV for Sc - Zn'/
     &' GEN:         General basis set (provided by user)'/
     &' GENNG:       As GEN for general STO-nG, using VBOLIB'/)
C
C     built-in basis set
C
C     1.  D95
C     2.  MIDIX
C     3.  STO-3G
C     4.  STO-4G
C     5.  STO-6G
C     6.  3-21G
C     7.  3-21G*
C     8.  6-31G
C     9.  6-31G*
C     10. 6-31G**
C     11. 6-31+G*
C     12. 6-31++G**
C     13. cc-pVDZ
C     14. AUG-cc-pVDZ
C     15. TZVP
C     x.  gen
C     x.  genng
C
      CALL CONVCASE(BASNAME,20,1)
      IF(BASNAME.EQ.'D95') THEN
      PATH(7:9)='D95'
      K=9
      ELSE IF(BASNAME.EQ.'MIDIX'.OR.BASNAME.EQ.'MIDI!') THEN
      PATH(7:11)='MIDIX'
      K=11
      ELSE IF(BASNAME.EQ.'STO-3G') THEN
      PATH(7:12)='STO-3G'
      K=12
      ELSE IF(BASNAME.EQ.'STO-4G') THEN
      PATH(7:12)='STO-4G'
      K=12
      ELSE IF(BASNAME.EQ.'STO-6G') THEN
      PATH(7:12)='STO-6G'
      K=12
      ELSE IF(BASNAME.EQ.'3-21G') THEN
      PATH(7:11)='3-21G'
      K=11
      ELSE IF(BASNAME.EQ.'3-21G*'.OR.BASNAME.EQ.'3-21GSTAR') THEN
      PATH(7:15)='3-21GSTAR'
      BASNAME = '3-21GSTAR'
      K=15
      ELSE IF(BASNAME.EQ.'6-31G') THEN
      PATH(7:11)='6-31G'
      K=11
      ELSE IF(BASNAME.EQ.'6-31G*'.OR.BASNAME.EQ.'6-31GSTAR') THEN
      PATH(7:15)='6-31GSTAR'
      BASNAME = '6-31GSTAR'
      K=15
      ELSE IF(BASNAME.EQ.'6-31+G*'.OR.BASNAME.EQ.'6-31PGSTAR') THEN
      PATH(7:16)='6-31PGSTAR'
      BASNAME = '6-31PGSTAR'
      K=16
      ELSE IF(BASNAME.EQ.'6-31G**'.OR.BASNAME.EQ.'6-31G2STAR') THEN
      PATH(7:16)='6-31G2STAR'
      BASNAME = '6-31G2STAR'
      K=16
      ELSE IF(BASNAME.EQ.'6-31++G**'.OR.BASNAME.EQ.'6-31PPG2STAR') THEN
      PATH(7:18)='6-31PPG2STAR'
      BASNAME = '6-31PPG2STAR'
      K=18
      ELSE IF(BASNAME.EQ.'CC-PVDZ') THEN
      PATH(7:13)='cc-pVDZ'
      K=13
      ELSE IF(BASNAME.EQ.'AUG-CC-PVDZ') THEN
      PATH(7:17)='AUG-cc-pVDZ'
      K=17
      ELSE IF(BASNAME.EQ.'TZVP') THEN
      PATH(7:10)='TZVP'
      K=10
      ELSE IF(BASNAME.EQ.'GEN'.OR.BASNAME.EQ.'GENNG') THEN
      CALL LOCTOR(IOENGI,'&',1,IOK,0)
        IF(IOK.EQ.0) THEN
        WRITE(IOUTVB,*)
     &   ' Please provide the basis set file name with path'
        STOP
        END IF
      BACKSPACE(IOENGI)
      READ(IOENGI,'(A80)')A
      ICURSOR=1
      LENBUF=80
      CALL READWDM(A,WORD,LENW,ICURSOR,LENBUF)
      GOTPATH=.FALSE.
        IF (WORD(LENW-1:LENW) .EQ. '/N') THEN
           WORD(LENW-1:LENW) = '  '
           LENW=LENW-2
        ENDIF
      DO I=2,LENW
        IF (WORD(I:I) .EQ. '/') THEN
          GOTPATH=.TRUE.
          GOTO 99
        ENDIF
      ENDDO
 99     IF (GOTPATH) THEN
          PATH = ' '
          PATH(1:LENW-1)=WORD(2:LENW)
          LENW = LENW-1
          K=0
        ELSE
          K = LENW + 5
          PATH(7:K) = WORD(2:LENW)
        ENDIF
      ELSE
        WRITE(IOUTVB,103) BASNAME
 103    FORMAT(' Unknown basis set name: ',A20)
        WRITE(IOUTVB,1100)
        CALL ABRTVB
      END IF
C     FINAL END OF LONG IF STATEMENT OVER BASIS NAMES
      IF (K.EQ.0) THEN
        TPATH(1:LENW)=PATH(1:LENW)
        DO I=LENW+1,80
          TPATH(I:I) = ' '
        ENDDO
      ELSE
        CALL PATHST(TPATH,VBPATH,'/               ',PATH,K)
      ENDIF
      WRITE(IOUTVB,102) TPATH
 102  FORMAT(/,' BASIS SET FILE IS: ',A80)
      INQUIRE(FILE=TPATH,EXIST=GOTFILE)
      IF (.NOT.GOTFILE) THEN
        WRITE(IOUTVB,104)
        CALL ABRTVB
      END IF
 104  FORMAT(" BASIS SET FILE DOES NOT EXIST!",/
     & " The file must be in BASET or a full path.",/
     &," The file may really be missing, but check that you",/ 
     &," do not have  the symbol & in your data elsewhere.")
      IOUNIT=99
      OPEN(IOUNIT,FILE=TPATH,STATUS='OLD')
      NREC=1
  10  READ(IOUNIT,'(A80)',END=100,ERR=100)BASET(NREC)
      NREC=NREC+1
      GOTO 10
 100  NREC=NREC-1
      CLOSE(IOUNIT)
C
C     Scane baset, and set-up indexes
C
      IST=0
      DO I=1,NREC
      A= BASET(I)
C
C     CHECK FOR STARTING POINT
C
      IF(IST.EQ.0.AND.A(1:1).EQ.'-') THEN
      IST=1
      CALL LKELEM(A,NELEM)
      IF(NELEM.GT.0) LCTBAS(NELEM)=I+1
      ELSE IF(IST.EQ.1.AND.A(1:4).EQ.'****') THEN
      IST=0
      LENBAS(NELEM)=I-LCTBAS(NELEM)
      END IF
      END DO
      RETURN
      END
      SUBROUTINE LKELEM(STRING, NELEM)
      CHARACTER*5 STRING
      CHARACTER*2 ATMSYM(92)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     Note that this ATMSYM block is different from the normal one, as
C     one-letter elements are left-centered, not right-centered. It is
C     used only here.
      DATA ATMSYM/'H ','He','Li','Be','B ','C ','N ','O ','F ','Ne',
     1            'Na','Mg','Al','Si','P ','S ','Cl','Ar',
     2            'K ','Ca','Sc','Ti','V ','Cr','Mn','Fe','Co',
     3            'Ni','Cu','Zn','Ga','Ge','As','Se','Br','Kr','Rb',
     4 'Sr','Y ','Zr','Nb','Mo','Tc','Ru','Rh','Pd','Ag','Cd','In',
     5 'Sn','Sb','Te','I ','Xe','Cs','Ba','La','Ce','Pr','Nd','Pm',
     6 'Sm','Eu','Gd','Tb','Dy','Ho','Er','Tm','Yb','Lu','Hf','Ta',
     7 'W ','Re','Os','Ir','Pt','Au','Hg','Tl','Pb','Bi','Po','At',
     8 'Rn','Fr','Ra','Ac','Th','Pa','U '/
C
C     look-up for elements
C
      DO I=1,92
        IF(STRING(1:3).EQ.'-'//ATMSYM(I)) THEN
           NELEM=I
           GOTO 1
        ENDIF
      ENDDO
      WRITE(IOUTVB,2) STRING
 2    FORMAT(' Unknown element: ',A5)
      STOP
 1    RETURN
      END
      SUBROUTINE PARMTHD(STRING,LEN,MTHEORY,METHOD,NG,ICURSOR,
     &                   MORB,MELE)
C
C
C     Theory            Control parameters
C
C     1. HF             No.
C     2. VB             m    // VB(m), m=# of electrons in m orbitals
C     3. SCVB           m    // SCVB(m) m electrons in m orbitals.
C     4. CASVB          (m,n)// CASVB(m,n), m=# of electrons in n=# of orbs.
C     5. GPF            ng   // generalized product function method, ng group.
C     6. DOT            Dot notation of GPF.
C                       For instance VB(8).CASVB(6,6).VB(8)
C                       In dot notation, HF group is omitted.
C     7. LHF1           No.
C     8. LHF2           No.
C
C     Notes:            No space in the string, otherwise, the parsing will
C                       fail.
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*80 A,WORD
      CHARACTER*80 WORD
      CHARACTER*1 STRING(*)
      DIMENSION MORB(*),MELE(*),METHOD(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      LENW=0
      LENBUF=LEN
C
C     scane for dot (.) notation
C
      IDOT = 0
      DO 10 I=ICURSOR,LENBUF
      IF(STRING(I).EQ.'.') IDOT=IDOT+1
 10   CONTINUE
      IF(IDOT.GT.0) GOTO 200
      M=0
      N=0
      NG=1
      WORD = ' '
      CALL READWDM(STRING,WORD,LENW,ICURSOR,LENBUF)
      IF(WORD.EQ.'HF') THEN
      NELE = 0
      WRITE(IOUTVB,*)"TODO: Please check NELE will be corrected later"
      MORB(1) = (NELE+1)/2
      MELE(1) = NELE
      MTHEORY=1
      ELSE IF(WORD.EQ.'VB') THEN
      MTHEORY=2
      CALL READNUM(STRING,M,LENW,ICURSOR,LENBUF)
C     WRITE(IOUTVB,*)'VB(M)=',M
      N = M
        IF(M.LT.0) THEN
        WRITE(IOUTVB,*)"The number of electrons in a VB group must > 0"
        CALL ABORT0("PARATH0000")
        END IF
      ELSE IF(WORD.EQ.'SCVB') THEN
      MTHEORY=3
      CALL READNUM(STRING,M,LENW,ICURSOR,LENBUF)
C     WRITE(IOUTVB,*)'SCVB(M)=',M
      N = M
      ELSE IF(WORD.EQ.'SC') THEN
      MTHEORY=3
      CALL READNUM(STRING,M,LENW,ICURSOR,LENBUF)
      CALL READNUM(STRING,N,LENW,ICURSOR,LENBUF)
      IF(N.EQ.0) N = M
      ELSE IF(WORD.EQ.'CASVB') THEN
      MTHEORY=4
      CALL READNUM(STRING,M,LENW,ICURSOR,LENBUF)
      CALL READNUM(STRING,N,LENW,ICURSOR,LENBUF)
C     WRITE(IOUTVB,*)"M,N = ",M,N
      ELSE IF(WORD.EQ.'GPF') THEN
      MTHEORY=5
      CALL READNUM(STRING,NG,LENW,ICURSOR,LENBUF)
C     WRITE(IOUTVB,*)'GPF(N)=',NG
      ELSE IF(WORD.EQ.'LHF') THEN
        NG = 1
        MTHEORY=7
        METHOD(1) = 2
      ELSE IF(WORD.EQ.'LHF2') THEN
        NG = 1
        MTHEORY=8
        METHOD(1) = 2
      ELSE
      WRITE(IOUTVB,*)' Unknown method'
      CALL ABORT0('PARMTH0001')
      END IF
      IF (1.LT.MTHEORY.AND.MTHEORY.LT.5) THEN
C
C       Assume there is a HF group. As the total number of electrons
C       is not available here, this should be verified later
C
        NG = 2
        MORB(1) = 0
        MELE(1) = 0
        METHOD(1) = 1
        MORB(2) = N
        MELE(2) = M
        METHOD(2) = MTHEORY
      END IF
      RETURN
 200  CONTINUE
C
C     parse dot notation
C
      MTHEORY=6
      METOTAL=0
      NG = IDOT+2
      DO K=1, IDOT+1
      M=0
      N=0
      WORD = ' '
      CALL READWDM(STRING,WORD,LENW,ICURSOR,LENBUF)
      IF(WORD.EQ.'VB') THEN
      MTHEO=2
      CALL READNUM(STRING,M,LENW,ICURSOR,LENBUF)
      N = M
C     skip ').'
      ICURSOR=ICURSOR+2
      ELSE IF(WORD.EQ.'SCVB') THEN
      MTHEO=3
      CALL READNUM(STRING,M,LENW,ICURSOR,LENBUF)
      N = M
C     skip ').'
      ICURSOR=ICURSOR+2
      ELSE IF(WORD.EQ.'SC') THEN
      MTHEO=3
      CALL READNUM(STRING,M,LENW,ICURSOR,LENBUF)
      CALL READNUM(STRING,N,LENW,ICURSOR,LENBUF)
      IF(N.EQ.0) N = M
C     skip ').'
      ICURSOR=ICURSOR+2
      ELSE IF(WORD.EQ.'CASVB') THEN
      MTHEO=4
      CALL READNUM(STRING,M,LENW,ICURSOR,LENBUF)
      CALL READNUM(STRING,N,LENW,ICURSOR,LENBUF)
      WRITE(IOUTVB,*)"M,N= ",M,N
C     skip ').'
      ICURSOR=ICURSOR+2
      ELSE
      WRITE(IOUTVB,*)
     & 'Error in dot notation. No space is allowed in keywords'
      WRITE(IOUTVB,*)'WORD=',WORD
      CALL ABORT0('PARMTH0002')
      END IF
      METOTAL=METOTAL+M
      MELE(K+1)=M
      MORB(K+1)=N
      METHOD(K+1) = MTHEO
      END DO
      RETURN
      END
      SUBROUTINE READNUM(STRING,NUMBER,LEN,ICURSOR,LENBUF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*80 A
      CHARACTER*1 STRING(*)
      LEN=0
      IST=0
      NUMBER=0
      DO 100 I=ICURSOR,LENBUF
      ITEMP=ISNUMBER(STRING(I))
      IF(IST.EQ.0.AND.(ITEMP.GE.0)) THEN
      NUMBER=ISNUMBER(STRING(I))
      IST=1
      LEN=1
      ELSE IF(IST.EQ.1.AND.(ITEMP.GE.0)) THEN
      LEN=LEN+1
      NUMBER = NUMBER*10 + ISNUMBER(STRING(I))
      ELSE IF(IST.EQ.1.AND.(ITEMP.LT.0)) THEN
      ICURSOR=I
      RETURN
      END IF
 100  CONTINUE
      ICURSOR=LENBUF
      END
      FUNCTION ISNUMBER(CHAR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*1 CHAR
      CHARACTER*10 NUMBER
      NUMBER   = '1234567890'
      ISNUMBER = -1
      DO I=1,10
      IF(CHAR.EQ.NUMBER(I:I)) THEN
      ISNUMBER = I
      IF(I.EQ.10) ISNUMBER=0
      RETURN
      END IF
      END DO
      END
      SUBROUTINE READWDM(STRING,WORD,LEN,ICURSOR,LENBUF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*80 A
      CHARACTER*1 WORD(*),STRING(*)
      LEN=0
      IST=0
      DO 100 I=ICURSOR,LENBUF
      IF(IST.EQ.0.AND.(STRING(I).NE.' '.AND.STRING(I).NE.'(')) THEN
      WORD(1)=STRING(I)
      IST=1
      LEN=1
      ELSE IF(IST.EQ.1.AND.(STRING(I).NE.' '.AND.STRING(I).NE.'('))
     & THEN
      LEN=LEN+1
      WORD(LEN)=STRING(I)
      ELSE IF(IST.EQ.1.AND.(STRING(I).EQ.' '.OR.STRING(I).EQ.'('))
     & THEN
      ICURSOR=I
      RETURN
      END IF
 100  CONTINUE
      ICURSOR=LENBUF
      END
      SUBROUTINE READWDS(BUFF,WORDS,LENS,ICURSOR,LENBUF,NWORD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*80 A,WORDS,BUFF
      CHARACTER*80 WORDS,BUFF
      DIMENSION WORDS(*),LENS(*)
      NWORD=0
 100  NWORD= NWORD+1
      WORDS(NWORD) = ' '
      CALL READWD(BUFF,WORDS(NWORD),LENS(NWORD),ICURSOR,LENBUF)
      IF(ICURSOR.LT.LENBUF.AND.LENS(NWORD).GT.0) GOTO 100
      IF(LENS(NWORD).LE.0) NWORD=NWORD-1
      RETURN
      END
      SUBROUTINE READWD(STRING,WORD,LEN,ICURSOR,LENBUF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*80 A
      CHARACTER*1 WORD(*),STRING(*)
      LEN=0
      IST=0
      DO 100 I=ICURSOR,LENBUF
      IF(IST.EQ.0.AND.STRING(I).NE.' ') THEN
      WORD(1)=STRING(I)
      IST=1
      LEN=1
      ELSE IF(IST.EQ.1.AND.STRING(I).NE.' ') THEN
      LEN=LEN+1
      WORD(LEN)=STRING(I)
      ELSE IF(IST.EQ.1.AND.STRING(I).EQ.' ') THEN
      ICURSOR=I
      RETURN
      END IF
 100  CONTINUE
      ICURSOR=LENBUF
      END
      SUBROUTINE VBOLGN(NATOM,NBASIS,NATNUM,XYZ,NATBAS,BFLABE,
     &                  BASIS,IOENGI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE(*)
      DIMENSION NATNUM(*),NATBAS(*),BASIS(NBASIS,*),XYZ(3,*)
C
C     IOPTION = 1: OUTPUT VBO FROM FINAL RESULTS
C
      IOPTION = 1
      CALL VBOLGNY(NATOM,NBASIS,NATNUM,XYZ,NATBAS,BFLABE,
     &                  BASIS,IOENGI,IOPTION)
      RETURN
      END
      SUBROUTINE LMOLGN(NATOM,NBASIS,NATNUM,XYZ,NATBAS,BFLABE,
     &                  BASIS,IOENGI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE(*)
      DIMENSION NATNUM(*),NATBAS(*),BASIS(NBASIS,*),XYZ(3,*)
C
C     IOPTION = 2: OUTPUT VBO FROM LMO OF HFSCF
C
      IOPTION = 2
      CALL VBOLGNY(NATOM,NBASIS,NATNUM,XYZ,NATBAS,BFLABE,
     &                  BASIS,IOENGI,IOPTION)
      RETURN
      END
C
C     SIMPLE VERSION
C
      SUBROUTINE VBOLGNY(NATOM,NBASIS,NATNUM,XYZ,NATBAS,BFLABE,
     &                  BASIS,IOENGI,IOPTION)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE(*)
      CHARACTER*80 VBONAME,BLANK,BUFF
C     DIMENSION NATNUM(*),NATBAS(*),BASIS(NBASIS,*),NABS(100)
      DIMENSION NATNUM(*),NATBAS(*),BASIS(NBASIS,*)
C     DIMENSION V1(3),V2(3),XYZ(3,*),NFA(100),LFA(100),NABSS(1000)
      DIMENSION V1(3),XYZ(3,*),NFA(100),LFA(100),NABSS(1000)
      BLANK(1:40)  = '                                        '
      BLANK(41:80) = '                                        '
      NABSS(1) = 1
      DO I=2, NATOM
      NABSS(I) = NABSS(I-1) + NATBAS(I-1)
      END DO
      NABSS(NATOM+1) = NABSS(NATOM) + NATBAS(NATOM)
C
C     CHECK $VBOLIBGEN
C
      CALL GETIOUNIT('IOVBOLIB',IOVBOLIB)
      IF(IOPTION.EQ.1) THEN
         CALL LOCTOR(IOENGI,'$VBOLIBGEN',10,IOK,0)
      ELSE
         CALL LOCTOR(IOENGI,'$LMOLIBGEN',10,IOK,0)
      END IF
      IF(IOK.EQ.0) RETURN
  10  READ(IOENGI,'(A80)',END=100,ERR=100)BUFF
      IF(BUFF(1:80).EQ.BLANK(1:80)) GOTO 100
      READ(BUFF(1:80),*, END=100,ERR=100)VBONAME, NEOCC
      IF(IOPTION.EQ.2.AND.NEOCC.NE.2) CALL ABORT0('VBOLGNY01 ')
      IF(VBONAME.EQ.BLANK) GOTO 100
C     READ(IOENGI,*)NFATOM
      NFATOM = 1
      READ(IOENGI,*)NAT1,NAT2
      NFA(1)=NAT1
      LFA(1)=0
      READ(IOENGI,*)NVBO
      IF(NAT2.EQ.0) THEN
        READ(IOENGI,*)(V1(I),I=1,3)
      ELSE
        V1(1) = XYZ(1,NAT2) - XYZ(1,NAT1)
        V1(2) = XYZ(2,NAT2) - XYZ(2,NAT1)
        V1(3) = XYZ(3,NAT2) - XYZ(3,NAT1)
      END IF
C
C     OUTPUT OF VBOLIB
C
      WRITE(IOVBOLIB,'(1X,A20,I5)')VBONAME,NEOCC
      WRITE(IOVBOLIB,'(I3)')NFATOM
      DO I=1, NFATOM
      WRITE(IOVBOLIB,1000)NATNUM(NFA(I)),(XYZ(J,NFA(I)),J=1,3),LFA(I)
      END DO
      WRITE(IOVBOLIB,*)
      WRITE(IOVBOLIB,'(I3)')NFATOM
      WRITE(IOVBOLIB,'(20I3)')(I,I=1,NFATOM)
      WRITE(IOVBOLIB,'(20I3)')(NATBAS(NFA(I)),I=1,NFATOM)
      SIGNMAX = 1.0D0
      CMAXX   = 0.0D0
      JJ = 0
      DO I=1, NFATOM
         II = NFA(I)
         DO J=NABSS(II), NABSS(II+1)-1
         JJ = JJ + 1
         IF(CMAXX.LT.DABS(BASIS(J,NVBO))) THEN
            CMAXX = ABS(BASIS(J,NVBO))
            SIGNMAX = BASIS(J,NVBO)/CMAXX
         END IF
C
C        ZERO SMALL NUMBERS, WHICH COULD BE NON-SYMMETRIC NOISE
C
           CABS = ABS(BASIS(J,NVBO))
           IF(CABS.LT.0.002D0) BASIS(J,NVBO) =0.0D0
         END DO
      END DO
C
      JJ = 0
      DO I=1, NFATOM
         II = NFA(I)
         DO J=NABSS(II), NABSS(II+1)-1
         JJ = JJ + 1
         WRITE(IOVBOLIB,'(I4,A12,F10.5)')
     &                     JJ,BFLABE(J),BASIS(J,NVBO)*SIGNMAX
         END DO
      END DO
      WRITE(IOVBOLIB,*)
      CALL VECNORM(V1,IFLAG)
      WRITE(IOVBOLIB,'(3F10.5)')(V1(J),J=1,3)
      WRITE(IOVBOLIB,*)
      GOTO 10
 100  CONTINUE
 1000 FORMAT(I3,3F10.5,I5)
      RETURN
      END
C19219CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     END OF CORE VB20000
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE FKENGI(F,DEN,NDIM,NFK)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Fock Engine for computing Fock matrices of multiple groups
C
C     Notes:    F (Fock matrices), DEN (Density matrices), NDIM (Dimension)
C               NFK (Number of groups)
C
C     History:
C               First created in March 2004
C
C     Author:
C               Jiabo Li
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
CGMS  COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      DIMENSION F(*),DEN(*)
      DIMENSION II(100000),JJ(100000),KK(100000),LL(100000)
      DIMENSION GG(100000)
      COMMON /IAA/IA(100000)
      CALL GETIOUNIT('IAO2E   ',IAO2E)
C000  REWIND(IAO2E)
CGAU  REWIND(IAO2E)
CSMI  REWIND(10)
CSMI  REWIND(11)
CGMS  REWIND(IS)
      IF(NDIM.GT.2000) CALL ABORT0("FKENGI0001")
      NDSQ = NDIM*(NDIM+1)/2
      DO I=1, NDSQ*NFK
      F(I) = 0.0D0
      END DO
      NREC = 0
 10   CONTINUE
      CALL IJKLGG(IAO2E,GG,II,JJ,KK,LL,NINT)
      NREC = NREC + 1
C
      DO MM= 1, NINT
      I = II(MM)
      J = JJ(MM)
      K = KK(MM)
      L = LL(MM)
      VAL = GG(MM)
      IF (I.GE.J) THEN
          NIJ = IA(I) + J
      ELSE
          NIJ = IA(J) + I
      END IF
      IF (K.GE.L) THEN
          NKL = IA(K) + L
      ELSE
          NKL = IA(L) + K
      END IF
C     NIJKL IS NOT USED SO COMMENT OUT FOR NOW
C     IF(NIJ.GE.NKL) THEN
C        NIJKL = IA(NIJ) + NKL
C     ELSE
C        NIJKL = IA(NKL) + NIJ
C     END IF
C
      IF(I.EQ.J) VAL = VAL*0.5D0
      IF(K.EQ.L) VAL = VAL*0.5D0
      IF(NIJ.EQ.NKL) VAL = VAL*0.5D0
      NIK = IA(I) + K
      NIL = IA(I) + L
      NJK = IA(J) + K
      NJL = IA(J) + L
      IF(I.LT.K) NIK = IA(K) + I
      IF(I.LT.L) NIL = IA(L) + I
      IF(J.LT.K) NJK = IA(K) + J
      IF(J.LT.L) NJL = IA(L) + J
      VAL2   = VAL + VAL
      VAL4   = VAL2 + VAL2
        DO K=1, NFK
        K2 = (K-1)*NDSQ
        NIJK2 = NIJ+K2
        NKLK2 = NKL+K2
        NIKK2 = NIK+K2
        NILK2 = NIL+K2
        NJKK2 = NJK+K2
        NJLK2 = NJL+K2
C
        F(NIJK2) = F(NIJK2) + VAL4*DEN(NKLK2)
        F(NKLK2) = F(NKLK2) + VAL4*DEN(NIJK2)
        F(NIKK2) = F(NIKK2) - VAL*DEN(NJLK2)
        F(NILK2) = F(NILK2) - VAL*DEN(NJKK2)
        F(NJKK2) = F(NJKK2) - VAL*DEN(NILK2)
        F(NJLK2) = F(NJLK2) - VAL*DEN(NIKK2)
        END DO
      END DO
      IF(NINT.NE.0) GOTO 10
CGMS  REWIND(IS)
C200  CONTINUE
      DO I=1, NDSQ*NFK
      F(I) = F(I)*0.5D0
      END DO
      DO I=1, NDIM
      I2 = I*(I+1)/2
        DO K=1, NFK
        K2 = (K-1)*NDSQ
        F(I2+K2) = F(I2+K2) + F(I2+K2)
        END DO
      END DO
      RETURN
      END
C
      SUBROUTINE HYBRIDS(SS,R,U,S,P,BIGU,SM,SP,W,NATOMS,NATBAS,
     1 NBASIS)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION U(NBASIS,*),S(NBASIS,*),E(1000),R(NBASIS,*),
     1 P(NBASIS,*),BIGU(NBASIS,*),SS(NBASIS,*),SM(NBASIS,*),
     1 SP(NBASIS,*),NATBAS(*),W(*)
      DIMENSION MAT(1000),NOCC(1000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     DATA ZERO,ONE,TWO,HALF/0.0D 00,1.0D 00,2.0D 00,0.5D 00/
      DATA ZERO,TWO,HALF/0.0D 00,2.0D 00,0.5D 00/
      CALL GETIOUNIT('IOTEMP  ',IOTEMP)
C     LLLL=LADDRS(U)
C     WRITE(IOUTVB,*) 'U in HYBRIDS',LLLL
      WRITE(IOTEMP,*)'U matrix is '
      CALL MATREC(U,NBASIS,NBASIS,NBASIS)
      NWK1 = 1
      NWK2 = NWK1 + NBASIS*NBASIS
      NWK3 = NWK2 + NBASIS*NBASIS
      NWK4 = NWK3 + NBASIS*NBASIS
      NWK5 = NWK4 + NBASIS*NBASIS
      NWK6 = NWK5 + NBASIS*NBASIS
      NWK7 = NWK6 + NBASIS*NBASIS
      NWK8 = NWK7 + NBASIS*NBASIS
C     NWK9 = NWK8 + NBASIS*NBASIS
C     NWK0 = NWK9 + NBASIS*NBASIS
      NAT  = NATOMS
      MBAS = NBASIS
      DO I=1, NATOMS
      MAT(I)=NATBAS(I)
      END DO
  103 FORMAT(10f7.3)
C     INTEGRAL INPUT FOR FULL BASIS SET
      MB=MBAS
      NORB=0
      DO NA=1,NAT
      NOCC(NA)=0
      ENDDO
C
C     S**(-1/2)->SM
C
      DO 1 I=1,MB
      DO 1 J=1,MB
      SM(I,J)=SS(I,J)
      U(I,J)=ZERO
    1 CONTINUE
      CALL SMINX(SM,U,E,MB,MB,HALF)
C     FROM NOW ON SM HOLDS S MINUS HALF
      DO 10 I=1,MB
      DO 10 J=1,MB
 10   S(J,I)=SS(J,I)
C------------------------------------------
C     REFER DM TO ORTHOG BASIS AND PUT IN P
      EXP=-HALF
      WRITE(IOUTVB,*)'SMINX matrix is '
      CALL SMINX(S,U,E,MB,MB,EXP)
      WRITE(IOUTVB,*)'after SMINX '
C     S replaced by S**half
      WRITE(IOTEMP,*)'S matrix is '
      CALL MATREC(S,MB,MB,MB)
      WRITE(IOTEMP,*)'R matrix is '
      CALL MATREC(R,MB,MB,MB)
      CALL HTRAN(R,S,E,MB,MB)
      WRITE(IOTEMP,*)'R matrix is '
      CALL MATREC(R,MB,MB,MB)
      DO 12 J=1,MB
      DO 12 I=1,MB
      SP(I,J)=S(I,J)
   12 P(J,I)=TWO*R(J,I)
      WRITE(IOTEMP,*)'P matrix is '
      WRITE(IOUTVB,*)'P matrix is '
      CALL MATREC(P,MB,MB,MB)
      TR=ZERO
      DO I=1,MB
      TR=TR+P(I,I)
      ENDDO
      WRITE(IOTEMP,105)TR
  105 FORMAT('Trace of whole dm =',f12.8)
      WRITE(IOTEMP,*)'Call LOCALIZE to get local nat orbs'

C     GO TO 29 for testing scf

      WRITE(IOUTVB,*)'CALL LOC'
      CALL LOCALIZE(MB,NORB,P,U,BIGU,W(NWK1),W(NWK2),W(NWK3),
     &  W(NWK4),W(NWK5),W(NWK6),W(NWK7),W(NWK8),NAT,MAT,NOCC)
      WRITE(IOUTVB,*)'CALL SIN'
      WRITE(IOTEMP,*) 'Call SINGVAL to get conventional ',
     & '(directed) hybrids'
      CALL SINGVAL(MB,P,U,BIGU,W(NWK1),W(NWK2),W(NWK3),
     &  W(NWK4),W(NWK5),W(NWK6),W(NWK7),W(NWK8),NAT,MAT,NOCC)
      WRITE(IOUTVB,*)'AFTERCALL SIN'
      WRITE(IOTEMP,*)'MATRIX BIGU, FOR GLOBAL BASIS TO HYBRIDS, IS:'
      NB=NORB
C     BSD - This is needed to flush FIL.LOC in case of error.
CGMS  CALL FLSHBF(98)
      CALL MATREC(BIGU,MB,NB,MB)
C     Now refer UDAG to raw AO basis
      DO I=1,MB
      DO J=1,MB
      S(J,I)=SM(J,I)
      ENDDO
      ENDDO
      DO I=1,MB
      DO J=1,NB
      U(I,J)=ZERO
      DO K=1,MB
      U(I,J)=U(I,J)+S(I,K)*BIGU(K,J)
      ENDDO
      ENDDO
      ENDDO

      DO I=1,MB
      DO J=1,MB
      R(J,I)=SS(J,I)
      ENDDO
      ENDDO
C     Full basis metric in R

      DO I=1,NB
      DO J=1,NB
      S(I,J)=ZERO
      DO K=1,MB
      DO L=1,MB
      S(I,J)=S(I,J)+U(K,I)*R(K,L)*U(L,J)
      ENDDO
      ENDDO
      ENDDO
      ENDDO
      WRITE(IOTEMP,*)'S for cols of bigu is -'
      DO J=1,NB
      WRITE(IOTEMP,103)(S(I,J),I=1,NB)
      ENDDO
      CALL SMINX(S,R,E,NB,MB,-HALF)
      DO I=1,MB
      DO J=1,NB
      BIGU(I,J)=ZERO
      DO K=1,NB
      BIGU(I,J)=BIGU(I,J)+U(I,K)*S(K,J)
      ENDDO
      ENDDO
      ENDDO

C     Put final U matrix, cols now orthonorm, into FIL.LOC
      WRITE(IOTEMP,*)'Referred to raw AOs, BIGU becomes -'
      DO J=1,NB
      WRITE(IOTEMP,103)(BIGU(I,J),I=1,MB)
      ENDDO
C  29 continue
      RETURN
      END

      SUBROUTINE LOCALIZE(MB,NORB,P,U,BIGU,D,S,PNEW,U1,U2,D1,D2,
     & P12,NAT,MAT,NOCC)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION P(MB,*),D(MB,*),S(MB,*),U(MB,*),E(1000),COL(1000)
C     DIMENSION PNEW(MB,*),BIGU(MB,*),SS(MB,*)
      DIMENSION PNEW(MB,*),BIGU(MB,*)
      DIMENSION U1(MB,*),U2(MB,*),D1(MB,*),D2(MB,*),P12(MB,*)
      DIMENSION MAT(*),NOCC(*)
      COMMON/INDICES/ KCLP(1000),KVAL(1000),MSTRT(1000),NSTRT(1000)
C     DATA ZERO,ONE,TWO,HALF,THRESH/0.0D 00,1.0D 00,2.0D 00,0.5D 00,
C    1 0.3D 00 /
      DATA ZERO,THRESH/0.0D 00,0.3D 00 /
      CALL GETIOUNIT('IOTEMP  ',IOTEMP)
CALIZE
      MSTRT(1)=1
      NA=1
      IF(NA.EQ.1) MSTRT(NA)=1
      DO NA=2,NAT
      MSTRT(NA)=MSTRT(NA-1)+MAT(NA-1)
      ENDDO
C     MSTRT(NA) NOW HOLDS START INDEX FOR BASIS FNS ON ATOM NA
C     WRITE(98,*)'Start indices, for bfs, are - '
C     WRITE(98,100)(MSTRT(NA),NA=1,NAT)
  100 FORMAT(10i6)
      DO J=1,MB
      DO I=1,MB
      BIGU(I,J)=ZERO
      ENDDO
      ENDDO
C     DO 20 NA=1,NAT
      DO 20 NA=1,NAT
      MM=MAT(NA)
      DO 3 J=1,MM
      DO 3 I=1,MM
      I1=MSTRT(NA)+I-1
      J1=MSTRT(NA)+J-1
      D(I,J)=P(I1,J1)
      S(I,J)=D(I,J)
    3 P(I1,J1)=ZERO
C     WRITE(98,201)NA
C 201 FORMAT('dmat for atom', I3)
C     do i=1,mm
C     WRITE(98,101)(D(I,J),J=1,MM)
C     enddo
C     DIAG BLOCK OF P COPIED INTO D - FOR each ATOM NA - COPY IN S
      CALL DIAGX(S,U,E,MM,MB)
      CALL ORDIN(S,U,E,MM,MB)
C     WRITE(98,203)NA
C 203 FORMAT(1H ,'eigenpops for atom',I3,1X,'are')
C     WRITE(98,99)(E(I),I=1,MM)
C  99 FORMAT(10F10.6)
C----------------------- counting routine -----------------------
C     NOCC(NA)=0 (in common block)
C     mclp=0
      KC=0
      KV=0
      DO I=1,MM
      IF(E(I).GE.(1.8D 00))THEN
         KC=KC+1
C        mclp=mclp+1
         KCLP(NA)=I
      ELSE
       IF(E(I).GE.THRESH)THEN
          KV=KV+1
          KVAL(NA)=I
        ENDIF
      ENDIF
      ENDDO
      WRITE(IOTEMP,137) NA,KCLP(NA)
  137 FORMAT('On atom ',I2,1X, 'there are',I2,1X,'core and lp orbitals')
      WRITE(IOTEMP,138) KV
  138 FORMAT('and',I2,1X,'valence orbitals')
      NOCC(NA)=NOCC(NA)+KC+KV
      NORB=NORB+NOCC(NA)
C     -----------------------------
      NSTRT(1)=1
      NAA=1
      IF(NAA.EQ.1) NSTRT(NAA)=1
      DO NAA=2,NAT
      NSTRT(NAA)=NSTRT(NAA-1)+NOCC(NAA-1)
      ENDDO
C     NSTRT(NA) NOW HOLDS START INDEX FOR ORBS ON ATOM NA
C-------------------------------------------------------------------
      WRITE(IOTEMP,*)'Orbitals (same order) are in cols of matrix below'
      NN=NOCC(NA)
      DO I=1,MM
      WRITE(IOTEMP,101)(U(I,J),J=1,NN)
      ENDDO
C     EV'S HERE ARE IN DESCENDING ORDER
C     RECTANGULAR U HOLDS NAT HYBRIDS (COLS IN SAME ORDER)
      CALL HTRAN1(D,U,COL,MM,NN,MB)
C     WRITE(98,207)NA
C 207 FORMAT(1H ,'UDAG*D*U for atom', I3)
  101 FORMAT(10F7.3)
      DO 6 I=1,NN
      DO 6 J=1,NN
      I1=NSTRT(NA)+I-1
      J1=NSTRT(NA)+J-1
    6 PNEW(I1,J1)=D(I,J)
      DO 7 I=1,MM
      DO 7 J=1,NN
      I1=MSTRT(NA)+I-1
      J1=NSTRT(NA)+J-1
    7 BIGU(I1,J1)=U(I,J)
C     BLOCKS OF PNEW AND BIGU ARE ACCUMULATING (also nocc and norb)
C     NSTRT(NA) NOW HOLDS START INDEX FOR ORBS ON ATOM NA
   20 CONTINUE
      NB=NORB
      WRITE(IOTEMP,*)'Block-diag form of new P is'
      CALL MATREC(PNEW,NB,NB,MB)
      WRITE(IOTEMP,*)'- and of BIGU is'
      CALL MATREC(BIGU,MB,NB,MB)

C     DIAG BLOCKS OF P NOW CONTAIN NAT POPS,
C     THOSE OF U CONTAIN NAT AOs
C     OPEN LOOPS (NA1,NA2) TO WORK ON OFF-DIAG BLOCKS
C     WRITE(98,*)'Open loop 30, for off-diag blocks'
      DO 30 NA1=1,NAT
      MM1=MAT(NA1)
      NN1=NOCC(NA1)
      DO 8 I=1,MM1
      DO 8 J=1,NN1
      I1=MSTRT(NA1)+I-1
      J1=NSTRT(NA1)+J-1
    8 U1(I,J)=BIGU(I1,J1)
C     WRITE(98,*)'Open loop 31, for second atom'
      DO 31 NA2=1,NAT
      IF(NA2.LE.NA1)GO TO 31
      IF(NA1.EQ.NAT)GO TO 30
      MM2=MAT(NA2)
      NN2=NOCC(NA2)
      DO 9 I=1,MM2
      DO 9 J=1,NN2
      I2=MSTRT(NA2)+I-1
      J2=NSTRT(NA2)+J-1
    9 U2(I,J)=BIGU(I2,J2)

      DO 10 K=1,MM1
      DO 10 L=1,MM2
      K1=MSTRT(NA1)+K-1
      L1=MSTRT(NA2)+L-1
   10 P12(K,L)= P(K1,L1)
C     WRITE (9,*)'OFF-DIAG BLOCK OF P IS -'
C     do i=1,mm1
C     WRITE(98,101)(P12(I,J),J=1,MM2)
C     enddo
      DO I=1,MM1
      DO J=1,MM2
      D1(I,J)=P12(I,J)
      ENDDO
      ENDDO
      DO I=1,MM1
      DO J=1,NN2
C     Use s as workspace
      S(I,J)=ZERO
      DO K=1,MM2
      S(I,J)=S(I,J)+D1(I,K)*U2(K,J)
      ENDDO
      ENDDO
      ENDDO
C     WRITE(98,*)'D1*S2, in D1, is'
      DO I=1,MM1
      DO J=1,NN2
      D1(I,J)=S(I,J)
      S(I,J)=ZERO
      ENDDO
      ENDDO
C      p12*u2 now in d1(mm1 x nn2): get d2=u1dag
      DO I=1,NN1
      DO J=1,MM1
      D2(I,J)=U1(J,I)
      ENDDO
      ENDDO
      DO I=1,NN1
      DO J=1,NN2
C     Use s as workspace
      S(I,J)=ZERO
      DO K=1,MM1
      S(I,J)=S(I,J)+D2(I,K)*D1(K,J)
      ENDDO
      ENDDO
      ENDDO
C     pnew12 now in s(nn1,nn2)
C     WRITE (9,*)'OFF-DIAG BLOCK OF PNEW IS -'
C     do I=1,NN1
C     WRITE(98,101)(S(I,J),J=1,NN2)
C     enddo
C     Put p12 in correct place in pnew
      DO K=1,NN1
      DO L=1,NN2
      K1=NSTRT(NA1)+K-1
      L1=NSTRT(NA2)+L-1
      PNEW(K1,L1)=S(K,L)
      ENDDO
      ENDDO
   31 CONTINUE
C     WRITE(98,*)'End of NA2 loop'
   30 CONTINUE
C     WRITE(98,*)'End of NA1 loop'
      IF(NA1.EQ.NAT)GO TO 32
   32 WRITE(IOTEMP,*)'Complete pnew is -'
      DO I=1,NB
      DO J=1,I
      PNEW(I,J)=PNEW(J,I)
      PNEW(J,I)=PNEW(I,J)
      P(I,J)=PNEW(J,I)
      P(J,I)=PNEW(I,J)
      ENDDO
      ENDDO
      CALL MATREC(PNEW,NB,NB,MB)
      WRITE(IOTEMP,*) 'Start indices for val orbs on atoms, are '
      WRITE(IOTEMP,100)(NSTRT(NA),NA=1,NAT)
      WRITE(IOTEMP,*) 'Numbers of val orbs on atoms, are '
      WRITE(IOTEMP,100)(KVAL(NA),NA=1,NAT)
C     Note: pnew still referred to Lowdin basis - PUT INTO P
      TR= ZERO
      DO I=1,NB
      TR=TR+PNEW(I,I)
      DO J=1,NB
      P(J,I)=PNEW(J,I)
      ENDDO
      ENDDO
C     TRACE IS APPROX TO NUMBER OF ELECTRONS
      WRITE(IOTEMP,105)TR
  105 FORMAT('Trace of whole dm =',f12.8)
      DO I=1,NB
      DO J=1,MB
      U(J,I)=BIGU(J,I)
      ENDDO
      ENDDO
C  21 continue
      RETURN
      END

C ------------ new sub (singular value decomposition)
      SUBROUTINE SINGVAL(MB,P,U,BIGU,X,S,U1,U2,P12,
     &  V1,V2,T,NAT,MAT,NOCC)

C     MAT(NA)=NO. OF BFS ON ATOM NA
C     NOCC(NA)=NO. OF OCC ORBS ON ATOM NA (CORE+LP+VAL)

C     P= DENSITY MATRIX PNEW AFTER BLOCK DIAGONALIZATION,
C     -- but referred to Lowdin basis, also hh in common
C     H (IN COMMON) IS HH + HALF*G
C     MB=MBAS=TOTAL BASIS SET SIZE. NORB=NO. OF OCC ORBS
C     ALGORITHM SEEKS V SUCH THAT U->U'=UV (FOR EACH BLOCK, A,B,..)
C     WILL CONTAIN REVISED NAT ORBS, MAXIMIZING INTER-AT BOND ORDERS.

      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C     DIMENSION P(MB,*),X(MB,*),S(MB,*),U(MB,*),E(1000),COL(1000)
C    1,U1(MB,*),U2(MB,*),P12(MB,*),V1(MB,*),V2(MB,*),SS(MB,*)
      DIMENSION P(MB,*),X(MB,*),S(MB,*),U(MB,*),E(1000),COL(1000)
     1,U1(MB,*),U2(MB,*),P12(MB,*),V1(MB,*),V2(MB,*)
C     DIMENSION SM(MB,*),SP(MB,*),BIGU(MB,*),T(MB,*),MAT(*),NOCC(*)
      DIMENSION BIGU(MB,*),T(MB,*),MAT(*),NOCC(*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      COMMON/INDICES/ KCLP(1000),KVAL(1000),MSTRT(1000),NSTRT(1000)
C     DATA ZERO,ONE,TWO,HALF,ZZ/0.0D 00,1.0D 00,2.0D 00,0.5D 00,1.D-05/
      DATA ZERO,ONE,HALF,ZZ/0.0D 00,1.0D 00,0.5D 00,1.D-05/
C     Note U is rectangular with orth cols
      CALL GETIOUNIT('IOTEMP  ',IOTEMP)
C     NB=NORB
C     neither NB nor NORB are used so NORB removed as argument.
  101 FORMAT(10f7.3)
C     OPEN LOOPS (NA1,NA2) TO WORK ON OFF-DIAG BLOCKS
      DO 30 NA1=1,NAT
      NCLP=KCLP(NA1)
      NBON=0
      MM1=MAT(NA1)
      NN1=NOCC(NA1)
      DO 8 I=1,MM1
      DO 8 J=1,NN1
      I1=MSTRT(NA1)+I-1
      J1=NSTRT(NA1)+J-1
      U(I,J)=BIGU(I1,J1)
    8 U1(I,J)=BIGU(I1,J1)
C     U1 for first atom (na1), copy kept in U
C     Open loop 31, for second atom
      DO 31 NA2=1,NAT
      IF(NA2.EQ.NA1)GO TO 31
      MM2=MAT(NA2)
      NN2=NOCC(NA2)
      DO 9 I=1,MM2
      DO 9 J=1,NN2
      I2=MSTRT(NA2)+I-1
      J2=NSTRT(NA2)+J-1
    9 U2(I,J)=BIGU(I2,J2)

      DO 10 K=1,NN1
      DO 10 L=1,NN2
      K1=NSTRT(NA1)+K-1
      L1=NSTRT(NA2)+L-1
   10 P12(K,L)= P(K1,L1)
      SUM=ZERO
      DO I=1,NN1
      DO J=1,NN2
      SUM=SUM+P12(I,J)*P12(I,J)
      ENDDO
      ENDDO
      IF(SUM.LT.1.0D-01)GO TO 31
      WRITE (IOTEMP,57) NA1,NA2
   57 FORMAT('OFF-DIAG BLOCK OF P FOR NA1,NA2=',2I3)
      DO I=1,NN1
      WRITE(IOTEMP,101) (P12(I,J),J=1,NN2)
      ENDDO

C     Use s as workspace
      DO I=1,NN1
      DO J=1,NN2
      S(I,J)=P12(I,J)
      ENDDO
      ENDDO
      DO I=1,NN1
      DO J=1,NN1
      X(I,J)=ZERO
      DO K=1,NN2
      X(I,J)=X(I,J)+S(I,K)*P12(J,K)
      ENDDO
      ENDDO
      ENDDO
C     T as workspace
      DO I=1,NN2
      DO J=1,NN2
      T(I,J)=ZERO
      DO K=1,NN1
      T(I,J)=T(I,J)+S(K,I)*P12(K,J)
      ENDDO
      ENDDO
      ENDDO
      CALL DIAGX(X,V1,E,NN1,MB)
      CALL DIAGX(T,V2,COL,NN2,MB)
C     ---------Is there a unique bond NA1--NA2 ?
C     Next bit changed 13 july
      NBON=NBON+1
      J=0
   35 J=J+1
      COLJ=COL(J)
      IF(COLJ.LT.HALF)GO TO 35
      I=0
   36 I=I+1
      EI=E(I)
      IF(EI.LT.HALF)GO TO 36
      NUM=I
      DIFF=DABS(EI-COLJ)
      IF(DIFF.LT.ZZ)NU=NUM
      WRITE(IOUTVB,*)'NN1,NU =',NN1,NU
      DO I=1,NN1
      COL(I)=V1(I,NU)
      ENDDO
C     This is first orb on na1 bonding to na2; revise column ncol of UA
C     It will bond with first orb on na2. Use X as workspace
      WRITE(IOTEMP,103) NBON
  103 FORMAT(' NBON for this neighbour (NA2) =',I3)
      NCOL=NCLP+NBON
      WRITE(IOTEMP,105) NU,NCOL
  105 FORMAT(I3,'-column of V1 becomes', I3,'-col of X')
      DO I=1,NN1
      DO J=1,NN1
      X(I,J)=ZERO
      ENDDO
      X(I,I)=ONE
      ENDDO
      DO I=1,NN1
      X(I,NCOL)=V1(I,NU)
      ENDDO
      DO I=1,MM1
      COL(I)=ZERO
      DO J=1,NN1
      COL(I)=COL(I)+U1(I,J)*X(J,NCOL)
      ENDDO
      ENDDO
C---------------------
C     Write modified col into U (copy of u1) in correct place
      DO I=1,MM1
      U(I,NCOL)=COL(I)
      ENDDO
C     U col modified for neighbour na2
C     - must do this for all na2, storing modified cols in U
   31 CONTINUE
      WRITE(IOTEMP,*)'End of NA2 loop'
      WRITE(IOTEMP,*)'Modified U is'
      DO I=1,MM1
      WRITE(IOTEMP,101)(U(I,J),J=1,NN1)
      ENDDO
C     Orthonormality lost -- restore (T,S,E, workspace)
      CALL ORTON(U,T,S,E,MM1,NN1,MB)
      WRITE(IOTEMP,*)'After ORTON, U is'
      DO I=1,MM1
      WRITE(IOTEMP,101)(U(I,J),J=1,NN1)
      ENDDO
C     Write modified U into BIGU in correct place
      DO I=1,MM1
      DO J=1,NN1
      I1=MSTRT(NA1)+I-1
      J1=NSTRT(NA1)+J-1
      BIGU(I1,J1)=U(I,J)
      ENDDO
      ENDDO
   30 CONTINUE
      WRITE(IOTEMP,*)'End of NA1 loop - all atoms done'
C     NOTE: P NOT REVISED (CAN BE DONE ANYTIME USING BIGU)
      RETURN
      END

      SUBROUTINE MML1(V,R,COL,M1,M2,M3,NDIM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     V(DAGGER)R->R, DIM(V)=M2XM1, DIM(R)=M2XM3,
C     THE FINAL R HAS DIM=M1XM3
      DIMENSION V(NDIM,NDIM),R(NDIM,NDIM),COL(NDIM)
      DATA ZER/0.0D 00/
      DO 3 J=1,M3
      DO 2 I=1,M1
      A=ZER
      DO 1 K=1,M2
    1 A=A+V(K,I)*R(K,J)
    2 COL(I)=A
      DO 3 I=1,M1
    3 R(I,J)=COL(I)
      RETURN
      END

      SUBROUTINE DIAGX(A,U,E,N,NDIM)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C  ....  THIS ROUTINE DIAGONALIZES THE INPUT MATRIX, A, BY THE
C  ....  JACOBI METHOD, PLACING THE EIGENVECTORS IN THE COLUMNS OF
C  ....  U, AND THE EIGENVALUES IN THE DIAGONAL OF A.
C********************************************************************C
C   ARGUMENTS.                                                       C
C        A       MATRIX TO BE DIAGONALIZED.                          C
C        U       MATRIX OF EIGENVECTORS.                             C
C        E       LIST OF EIGENVALUES                                 C
C        N       DIMENSION OF THE MATRICES AND THE VECTOR.           C
C********************************************************************C
      DIMENSION A(NDIM,NDIM),U(NDIM,NDIM),E(NDIM)
      DATA ZER,ONE,TWO,FOR,EPS/0.0D 00,1.0D 00,2.0D 00,4.0D 00,1.0D-20/
      DO 8 J=1,N
      DO 9 I=1,N
    9 U(I,J)=ZER
    8 U(J,J)=ONE
   10 AMAX=ZER
      DO 11 I=2,N
      JUP=I-1
      DO 11 J=1,JUP
      AII=A(I,I)
      AJJ=A(J,J)
      AOD=A(I,J)
      ASQ=AOD*AOD
      IF(ASQ.LE.AMAX) GOTO 23
      AMAX=ASQ
   23 IF(ASQ.LE.EPS)  GOTO 11
      DIFFR=AII-AJJ
      IF(DIFFR.GE.0.0D0)  GOTO 15
      SIGN=-TWO
      DIFFR=-DIFFR
      GO TO 16
   15 SIGN=TWO
   16 TDEN=DIFFR+ DSQRT(DIFFR*DIFFR+FOR*ASQ)
      TAN=SIGN*AOD/TDEN
      C=ONE/( DSQRT(ONE+TAN*TAN))
      S=C*TAN
      DO 24 K=1,N
      XJ=C*U(K,J)-S*U(K,I)
      U(K,I)=S*U(K,J)+C*U(K,I)
      U(K,J)=XJ
      IF(K.EQ.J)  GOTO 24
      IF(K.EQ.I)  GOTO 24
      XJ=C*A(K,J)-S*A(K,I)
      A(K,I)=S*A(K,J)+C*A(K,I)
      A(K,J)=XJ
      A(I,K)=A(K,I)
      A(J,K)=A(K,J)
   24 CONTINUE
      A(I,I)=C*C*AII+S*S*AJJ+TWO*S*C*AOD
      A(I,J)=ZER
       A(J,J)=C*C*AJJ+S*S*AII-TWO*S*C*AOD
      A(J,I)=ZER
   11 CONTINUE
      IF(AMAX.GT.EPS) GOTO 10
      DO 25 I=1,N
   25 E(I)=A(I,I)
      RETURN
      END

      SUBROUTINE ORDIN(H,U,E,M,NDIM)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C     PUTS (POSITIVE) E ENTRIES IN DESCENDING ORDER (INVERSE OF USUAL)
      DIMENSION H(NDIM,NDIM),U(NDIM,NDIM),E(NDIM)
      DO 1 K=1,M
      ET=E(K)
      JT=K
      DO 2 J=K,M
      IF(ET.GE.E(J)) GOTO 2
      ET=E(J)
      JT=J
    2 CONTINUE
      E(JT)=E(K)
      E(K)=ET
      DO 1 I=1,M
      H(I,I)=U(I,JT)
      U(I,JT)=U(I,K)
    1 U(I,K)=H(I,I)
      RETURN
      END
      SUBROUTINE SMINH (S,U,E,M,NDIM)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C     THIS REPLACES OVERLAP MATRIX S BY S**(-1/2)
      DIMENSION S(NDIM,NDIM),U(NDIM,NDIM),E(NDIM)
      CALL DIAG (S,U,E,M,NDIM)
C     U BRINGS S IN DIAGONAL FORM. SU = UD ,  D(DIAG) IN E
      DO 1 I=1,M
    1 E(I)=1.D0/DSQRT(E(I))
      DO 2 I=1,M
      DO 2 J=1,I
      S(I,J)=0.D0
      DO 3 K=1,M
    3 S(I,J)=S(I,J)+U(I,K)*E(K)*U(J,K)
      S(J,I)=S(I,J)
    2 CONTINUE
      RETURN
      END

      SUBROUTINE HTRAN(H,V,COL,N,NDIM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C  ....  ROUTINE TO FORM VDAGGER*H*V    FROM TWO SQUARE INPUT MATRICES,
C  ....  H AND V.  THE RESULT OVERWRITES H WITH V REMAINING UNCHANGED.
C  ....  THIS IS VARIABLE-DIMENSION VERSION OF HTRAN.
      DIMENSION H(NDIM,NDIM),V(NDIM,NDIM),COL(NDIM)
      DATA ZER/0.D0/
      DO 3 I=1,N
      DO 2 J=1,N
      A=ZER
      DO 1 K=1,N
    1 A=A+H(I,K)*V(K,J)
    2 COL(J)=A
      DO 3 K=1,N
    3 H(I,K)=COL(K)
      DO 33 J=1,N
      DO 22 I=1,N
      A=ZER
      DO 11 K=1,N
   11 A=A+V(K,I)*H(K,J)
   22 COL(I)=A
      DO 33 K=1,N
   33 H(K,J)=COL(K)
      RETURN
      END
      SUBROUTINE MATREC(A,N1,N2,NDIM)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION A(NDIM,NDIM)
C     KITE=MIN0(KITE,N2)
C     KITE does not seem to be used until KITE=0
      CALL GETIOUNIT('IOTEMP  ',IOTEMP)
   18 FORMAT(1H ,I2,2X,10(F7.3))
C  18 FORMAT(1H ,I2,2X,5(F13.8))
C  18 FORMAT(1H ,I2,2X,7(E10.4))
   19 FORMAT(1X/1H ,3x,10(4X,I3),//)
C  19 FORMAT(1X/1H ,5(10X,I3),//)
C  19 FORMAT(1X/1H ,7(8X,I3),//)
C     LLLL=LADDRS(A)
C     WRITE(IOUTVB,*) 'In MATREC',LLLL
      KITE=0
   20 LOW=KITE+1
C     IF(N2-(KITE+5)) 23,25,25
      IF(N2.GE.(KITE+10)) GOTO 25
      KITE=KITE+(N2-KITE)
      GO TO 27
C  25 KITE=KITE+5
   25 KITE=KITE+10
   27 WRITE(IOTEMP,19) (II,II=LOW,KITE)
      DO 30 I=1,N1
   30 WRITE(IOTEMP,18) I,(A(I,II),II=LOW,KITE)
      IF(N2.GT.KITE) GOTO 20
      RETURN
      END

      SUBROUTINE HTRAN1(H,V,COL,M1,M2,NDIM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C  ....  ROUTINE TO FORM VDAGGER*H*V    FROM H(M1,M1) AND V(M1,M2)
C  ....  H AND V.  THE RESULT OVERWRITES H WITH V REMAINING UNCHANGED.
C  ....  THIS IS RECTANGULAR-V VERSION OF HTRAN.

      DIMENSION H(NDIM,NDIM),V(NDIM,NDIM),COL(NDIM)
      DATA ZER/0.D0/
      DO 3 I=1,M1
      DO 2 J=1,M2
      A=ZER
      DO 1 K=1,M1
    1 A=A+H(I,K)*V(K,J)
    2 COL(J)=A
      DO 3 K=1,M2
    3 H(I,K)=COL(K)
      DO 33 J=1,M1
      DO 22 I=1,M2
      A=ZER
      DO 11 K=1,M1
   11 A=A+V(K,I)*H(K,J)
   22 COL(I)=A
      DO 33 K=1,M2
   33 H(K,J)=COL(K)
      RETURN
      END

      SUBROUTINE SMINX (S,U,E,M,NDIM,EXP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     THIS REPLACES OVERLAP MATRIX S BY S**(-EXP)
      DIMENSION S(NDIM,NDIM),U(NDIM,NDIM),E(NDIM)
      CALL DIAG (S,U,E,M,NDIM)
C     U BRINGS S IN DIAGONAL FORM. SU = UD ,  D(DIAG) IN E
      DO 1 I=1,M
    1 E(I)=1.D0/E(I)**EXP
      DO 2 I=1,M
      DO 2 J=1,I
      S(I,J)=0.D0
      DO 3 K=1,M
    3 S(I,J)=S(I,J)+U(I,K)*E(K)*U(J,K)
      S(J,I)=S(I,J)
    2 CONTINUE
      RETURN
      END

      SUBROUTINE ORTON(U,W,S,E,M,N,NDIM)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C     ORTHONORMALIZE COLS OF U (RECTANGULAR), UNIT METRIC
      DIMENSION U(NDIM,NDIM),S(NDIM,NDIM),W(NDIM,NDIM),E(NDIM)
C     DATA ZERO,ONE/0.0D 00,1.0D 00/
      DATA ZERO/0.0D 00/
      DO 1 J=1,N
      DO 1 I=1,M
    1 S(I,J)=U(I,J)
C     KEEP COPY OF INPUT COLS
      CALL MML1(S,S,E,N,M,N,NDIM)
C     S CONTAINS METRIC UDAG*U
      CALL SMINH(S,W,E,N,NDIM)
C     S NOW REPLACED BY Su**(-half)
      DO 6 I=1,M
      DO 6 J=1,N
    6 W(I,J)=U(I,J)
      DO 7 I=1,M
      DO 7 J=1,N
      U(I,J)=ZERO
      DO 8 K=1,N
    8 U(I,J)=U(I,J)+W(I,K)*S(K,J)
    7 CONTINUE
      RETURN
      END

      SUBROUTINE GUESS2(NATOMS, NATBAS, NBASIS, BASIS,ST,W,NELE)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C     DIMENSION U(50,50),R(50,50),SS(50,50),NATBAS(1000)
      DIMENSION ST(*),W(*),BASIS(NBASIS,*)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C     OPEN(98,FILE='FIL.LOC',STATUS='UNKNOWN')
      CALL GETIOUNIT('IOTEMP  ',IOTEMP)
      OPEN(IOTEMP,FILE=LOCFILE,STATUS='UNKNOWN')
      NOCC = NELE /2
      REWIND 9
      NWKU = 1
      NWKR = NWKU + NBASIS*NBASIS
      NWKS = NWKR + NBASIS*NBASIS
      NWK1 = NWKS + NBASIS*NBASIS
      NWK2 = NWK1 + NBASIS*NBASIS
      NWK3 = NWK2 + NBASIS*NBASIS
      NWK4 = NWK3 + NBASIS*NBASIS
      NWK5 = NWK4 + NBASIS*NBASIS
      NWK6 = NWK5 + NBASIS*NBASIS
C     NWKX = NWK6 + NBASIS*NBASIS
C     Now read integral file. Put integs in common
      IJ=0
      DO 2 I=1,NBASIS
      II = (I-1)*NBASIS
      DO 2 J=1,I
      JJ = (J-1)*NBASIS
      IJ=IJ+1
      W(NWKS+II+J-1) = ST(IJ)
      W(NWKS+JJ+I-1) = ST(IJ)
 2    CONTINUE
      NBAS2=NBASIS*(NBASIS+1)/2
      WRITE(IOTEMP,1) (ST(I),I=1,NBAS2)
 1    FORMAT(5F12.5)
      DO I=1,NBASIS*NBASIS
      W(NWKR-1+I)=0.0D0
      END DO
      DO I=1,NBASIS
      II = (I-1)*NBASIS
      DO J=1,NBASIS
      W(NWKU+II+J-1)=BASIS(J,I)
      END DO
      END DO
      DO K=1,NOCC
      DO I=1,NBASIS
      II = (I-1)*NBASIS
      DO J=1,NBASIS
      W(NWKR+II+J-1)=W(NWKR+II+J-1)+BASIS(I,K)*BASIS(J,K)
      END DO
      END DO
      END DO
      CALL HYBRIDS(W(NWKS),W(NWKR),W(NWKU),W(NWK1),W(NWK2),W(NWK3),
     & W(NWK4),W(NWK5),W(NWK6),NATOMS,NATBAS,NBASIS)
C
C     COPY BACK TO BASIS
C
      IJ=0
      DO I=1,NBASIS
      DO J=1,NBASIS
      IJ=IJ+1
      BASIS(J,I)=W(NWK3-1+IJ)
      END DO
      END DO
      CLOSE(98)
      RETURN
      END
      SUBROUTINE VISUAL(RWRK,EIG)
C#######################################################################
C
C     Routine to create visualisation files:-
C
C     $MOLPLT - *.mol file for Gamess Graphics molplt program.
C     $PLTORB - *.vec and *.orb for Gamess Graphics molplt program. 
C     $VECONLY - *.vec only for import into MacMolPlt to display VBOs
C     $MOLEKEL - *.mkl file in MKL format for Molekel program.
C     $MOLDEN - *.molf file in molden file format for Molden program.
C     $XYZFILE - *.xyz file in XYZ format for several programs.
C     $CUBE - *.cube file in Gaussian cube format, but one file per VB
C       orbital, for several programs.
C     $GENGRID - *.grd file in DSV GRID output format - one per orbital.
C     $GRID - alternative to $GENGRID, but only for stand-alone program.
C     $LINE - constructs *.csv files that can be used in a spreadsheet 
C       to plot VB orbitals along a set of connected lines.
C     $DENSCUBE - creates CUBE files for the total density, the density
C       of individual groups or the spin density.
C
C     Created (along with all routines below that are called from VISUAL):
C               Brian Duke, Jan - June, 2005
C
C     Added capability to use LMOs, rather then VBOs, in TEST runs.
C               Brian Duke, Nov, 2011
C
C     Added capability to create molden format files and LINE csv files.
C               Brian Duke, Dec, 2011
C
C     Added capability to CUBE files for the total density, and ability
C     to handle proper 5D spherical harmonic basis sets.
C               Brian Duke, Dec, 2012 & Jan, 2013.
C
C#######################################################################
      IMPLICIT NONE
      DOUBLE PRECISION EIG(*),RWRK(*)
C
      INTEGER MAXEXP,MAXSHL,MAXPRM,MAXBFN,NEXTRA,MAXEXT,MAXCUB
     & ,MAXCEN,MAXGRP
      PARAMETER (MAXSHL=500,MAXPRM=15,MAXBFN=726,MAXEXP=1000)
      PARAMETER (MAXCEN=200,MAXCUB=100)
      CHARACTER*1 BLANK
      CHARACTER*3 TAG
      CHARACTER*40 TITLE
      DOUBLE PRECISION TIME1,TIME2,XCLOCK
      LOGICAL LMOLT,LPLT,LVEC,LMKL,LMOLD,LXYZ,LCUBE,LGRID,LLINE,LFIRST
     &,HAVE
      INTEGER KVB(MAXCUB),IOK,IOENGI,I,J,NP,NVB,IGRID,IOHFORB,I1
     & ,IERR,IPRM,NATPT,NCRIT,NPOINT,IBASCK,K,L,NBA2,LDMA,NOCB
      DOUBLE PRECISION TOANG,XALL(3,10),C1(3,MAXCEN),C2(MAXBFN),
     &C3(MAXBFN)
C
C     MAXEXP IS ONLY USED IN COMMON /CUBEC/ IN THE VISUALISATION
C     ROUTINES. IT IS SET TO A LOWER VALUE THAN USED IN vb2000ints.src
C     BUT CAN BE CHANGED IN vb2000.src ONLY.
C
      DOUBLE PRECISION XE,C
      INTEGER IT,JT,KT,MT,MCT
      COMMON /CUBEC/ XE(MAXEXP),C(MAXEXP),IT(MAXEXP),JT(MAXEXP),
     & KT(MAXEXP),MT(MAXBFN),MCT(MAXBFN)
C
      CHARACTER*64 DENFILE
      INTEGER IDENS
      LOGICAL LDENS,LTOT,LGRP,LSD
      COMMON /DCUBE/ IDENS,LDENS,LTOT,LGRP,LSD,DENFILE
C
      INTEGER NF,KATOM,IMOL
      CHARACTER*1 SYM
      DOUBLE PRECISION XEXP,COEFF
      COMMON /SEEING/ XEXP(MAXSHL,MAXPRM),COEFF(MAXSHL,MAXPRM)
     &,NF(MAXSHL),KATOM(MAXCEN),IMOL,SYM(MAXSHL)
C
      INTEGER IOUTVB,LENFIL
      CHARACTER*64 FSTR,RWFFILE,INTFILE,INPFILE,LOCFILE
      CHARACTER*3 FUNIT(10)
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      INTEGER NATOM,NELE,NSPIN,NBASIS,NATNUM,NATBAS
      DOUBLE PRECISION ENREP,XYZ
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
C
      INTEGER NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,LPTALL,LHYBRD
     &,MELE,MSPIN,MNORBIT,MLORBIT,MWIN,MSTR,METHOD,IBASIS,NOCC,NOBIAS
     &,NEPS,NVIR,NOTROT,LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS
     &,KEY
      PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA,MAXGRP=99)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(MAXGRP),MSPIN(MAXGRP),MNORBIT(MAXGRP),
     &MLORBIT(MAXGRP),MWIN(MAXGRP),MSTR(MAXGRP),METHOD(MAXGRP),
     &IBASIS(MAXEXT),NOCC(MAXEXT),NOBIAS,NEPS,NVIR,NOTROT(5000),
     &LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(MAXGRP)
C
      INTEGER NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,LD2STA,
     & LGDMP,N1DADD,N2DADD,NB1ADD,NB2ADD
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
C
CGMS  LOGICAL AIMPAC,PLTORB,MOLPLT,RPAC
CGMS  DOUBLE PRECISION FRIEND
CGMS  COMMON /INTRFC/ FRIEND,AIMPAC,RPAC,PLTORB,MOLPLT
C
      DOUBLE PRECISION ATMCHG
      COMMON /ATMCH/ ATMCHG(MAXCEN)
C
      CHARACTER*2 ATMSYM
      COMMON /ATOMSY/ ATMSYM(92)
C
      DATA TOANG /0.529177249D0/
      DATA BLANK /' '/
      IMOL = 96
      IF(LTEST.EQ.1) THEN
         WRITE(IOUTVB,
     &   '(/," SEARCHING FOR VISUAL DATA WITH LMOs IN TEST RUN",/)')
      ENDIF
      NBA2=NBASIS*(NBASIS+1)/2
      LDMA=NBASIS*NBASIS+1
C
C     CHECK WHICH VISUAL DIRECTIVES ARE PRESENT
C
      LMOLT = .FALSE.
      LPLT = .FALSE.
      LVEC = .FALSE.
      LMKL = .FALSE.
      LMOLD = .FALSE.
      LXYZ = .FALSE.
      LCUBE = .FALSE.
      LGRID = .FALSE.
      LLINE = .FALSE.
      IGRID = 0
C
C     $MOLPLT
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$MOLPLT',7,IOK,0)
      IF(IOK.EQ.1) LMOLT = .TRUE.
C
C     $PLTORB
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$PLTORB',7,IOK,0)
      IF(IOK.EQ.1) LPLT = .TRUE.
C
C     $VECONLY
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$VECONLY',8,IOK,0)
      IF(IOK.EQ.1) LVEC = .TRUE.
C
C     $MOLEKEL
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$MOLEKEL',8,IOK,0)
      IF(IOK.EQ.1) LMKL = .TRUE.
C
C     $MOLDEN
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$MOLDEN',7,IOK,0)
      IF(IOK.EQ.1) LMOLD = .TRUE.
C
C     $XYZFILE
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$XYZFILE',8,IOK,0)
      IF(IOK.EQ.1) LXYZ = .TRUE.
C
C     $GENGRID & $GRID
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$GENGRID',8,IOK,0)
      IF(IOK.EQ.1) THEN
         LGRID = .TRUE.
         IGRID = 1
      ENDIF
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$GRID',5,IOK,0)
      IF(IOK.EQ.1) THEN
         IF(IGRID.EQ.1) THEN
            WRITE(IOUTVB,'(" BOTH $GRID AND $GENGRID FOUND")')
            WRITE(IOUTVB,'(" IGNORING $GRID")')
         ELSE
           LGRID = .TRUE.
           IGRID = 2
         ENDIF
      ENDIF
CGMS  IF(IGRID.EQ.2) THEN
CGMS     WRITE(IOUTVB,
CGMS & '(" $GRID NOT ALLOWED IN GAMESS/VB2000 - USE $GENGRID",/)')
CGMS     LGRID = .FALSE.
CGMS  ENDIF
C
C     $CUBE
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$CUBE',5,IOK,0)
      IF(IOK.EQ.1) LCUBE = .TRUE.
C
C     $LINE
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$LINE',5,IOK,0)
      IF(IOK.EQ.1) LLINE = .TRUE.
C
C     $DENSCUBE
C     Selected in VB2000 main routine - not here.
      IF (LDENS.AND.LTEST.EQ.1) THEN
        WRITE(IOUTVB,'(" $DENSCUBE NOT ALLOWED IN TEST RUN",/)')
        LDENS = .FALSE.
      ENDIF
      IF (LTEST .NE. 1 .AND. MTHEORY .EQ. 1) THEN
        WRITE(IOUTVB,'(" $DENSCUBE NOT ALLOWED FOR HF ONLY RUN",/)')
        LDENS = .FALSE.
      ENDIF
C
C     RETURN IF NO DIRECTIVES FOUND
      IF (.NOT.(LMOLT.OR.LPLT.OR.LVEC.OR.LMKL.OR.LMOLD.OR.LXYZ
     & .OR.LCUBE.OR.LGRID.OR.LLINE.OR.LDENS)) RETURN
C
C     CALL BASIS FUNCTIONS ONLY ONCE. 
      IF (LMOLT.OR.LPLT.OR.LVEC.OR.LMKL.OR.LMOLD.OR.LCUBE.OR.LGRID
     & .OR.LLINE.OR.LDENS) THEN
        DO I=1,MAXSHL
          SYM(I)=BLANK
        ENDDO
C000    IBASCK=1
CSMI    IBASCK=2
CGMS    IBASCK=3
CGAU    IBASCK=4
C000    IF(IBASCK.EQ.1) CALL BASISA(NATOM)
CSMI    IF(IBASCK.EQ.2) CALL BASISI(NATOM)
CGMS    IF(IBASCK.EQ.3) CALL BASISM()
CGAU    IF(IBASCK.EQ.4) CALL BASISG(NATOM)
      ENDIF
C
C     SET UP CONSTANTS NEEDED ONLY FOR SPHERICAL HARMONICS
CGAU  CALL SPHCONST
C
C     FOR HARTEE-FOCK ONLY RUNS
      IF (LPLT.OR.LMKL.OR.LMOLD.OR.LCUBE.OR.LGRID.OR.LLINE) THEN
        IF (LTEST .NE. 1 .AND. MTHEORY .EQ. 1) THEN
          NSUB = 1
          NB1ADD(1) = 1
          NB1ADD(2) = 1 + NBASIS
          CALL GETIOUNIT('IOHFORB ',IOHFORB)
          CALL RDMORB(IOHFORB,RWRK(1),EIG,NBASIS)
        ENDIF
      ENDIF
C
      NOCB=NB1ADD(NSUB+1)-1
      IF(LTEST.EQ.1) NOCB=(NELE-NSPIN)/2 + NSPIN
C
C     $MOLPLT
C     Create mol file for molplt to display molecular frame.
C     File called GMSPLT to avoid conflict with MOLPLT in Gamess.
C
      IF(.NOT.LMOLT) GOTO  201
C     Ignore GMS $CONTRL MOLPLT if VB MOLPLT is present.
CGMS  MOLPLT=.FALSE.
      CALL GMSPLT(ATMSYM)
      WRITE(IOUTVB,101)
 101  FORMAT(' CREATED FILE FOR MOLPLT ANALYSIS',/)
 201  CONTINUE
C
C     $PLTORB
C     Create $VEC file for pltorb to display orbitals.
C     File called GMSORB to avoid conflict with PLTORB in Gamess.
C
      IF(.NOT.LPLT) GOTO  202
      CALL GMSORB(RWRK,ATMSYM,NOCB,1)
      WRITE(IOUTVB,'(" CREATED VEC & ORB FILE FOR PLTORB ANALYSIS",/)')
 202  CONTINUE
C
C     $VECONLY
C     Create $VEC file only for import into MacMolPlt to display VBOs
C
      IF(.NOT.LVEC) GOTO  209
      CALL GMSORB(RWRK,ATMSYM,NOCB,2)
      WRITE(IOUTVB,'(" CREATED VEC FILE FOR MacMolPlt import",/)')
 209  CONTINUE
C
C     $MOLEKEL OR $MOLDEN
C     Create MKL file for MOLEKEL or molden file format for MOLDEN
C
      IF(.NOT.LMKL .AND. .NOT.LMOLD) GOTO  203
      IF(LMKL) THEN
        CALL MOLEKEL(RWRK,IERR,.TRUE.,NOCB)
        IF(IERR.eq.0) WRITE(IOUTVB,121)
      ENDIF
      IF(LMOLD) THEN
        CALL MOLEKEL(RWRK,IERR,.FALSE.,NOCB)
        IF(IERR.eq.0) WRITE(IOUTVB,122)
      ENDIF
 121  FORMAT(' CREATED FILE FOR MOLEKEL ANALYSIS',/)
 122  FORMAT(' CREATED FILE FOR MOLDEN ANALYSIS',/)
 203  CONTINUE
C
C     $XYZFILE
C     Create simple XYZ file
C
      IF(.NOT.LXYZ) GOTO  204
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$XYZFILE',8,IOK,0)
      IF(IOK.EQ.1) THEN
        READ(IOENGI,'(A40)') TITLE
        INPFILE=FSTR(1:LENFIL)//'.xyz'
        OPEN(UNIT=IMOL,FILE=INPFILE,STATUS='UNKNOWN',
     1    ACCESS='SEQUENTIAL',FORM='FORMATTED')
        CALL XYZFILE(XYZ,NATOM,NATNUM,TITLE)
        WRITE(IOUTVB,131)
        CLOSE(IMOL)
      ENDIF
 131  FORMAT(' CREATED XYZ FILE OF MOLECULAR COORDINATES',/)
 204  CONTINUE
C
C     Common stuff for CUBE, GRID, LINE and DENSCUBE
      IF(LCUBE.OR.LGRID.OR.LLINE.OR.LDENS) THEN
        CALL SETCUBE(IPRM,IERR)
        IF (IERR.EQ.1) RETURN
      ENDIF

C     $CUBE
C     Create CUBE Cube file for MOLEKEL and other codes.
C
      IF(.NOT.LCUBE) GOTO  205
      TIME1=XCLOCK()
      LFIRST=.TRUE.
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$CUBE',5,IOK,0)
      CALL CUBEDATA(NVB,NP,KVB,TITLE,IOENGI,IOUTVB,IERR,NOCB,MAXCUB)
      IF (IERR.EQ.1) THEN
         WRITE(IOUTVB,106) NP
         GOTO 205
      ENDIF
C     WRITE(IOUTVB,'(6E16.8)') (C(I1),I1=1,IPRM)
      DO J=1,NVB
        I=KVB(J)
        WRITE(TAG,'(I3.3)') I
        INPFILE=FSTR(1:LENFIL)//'-orb-'//TAG//'.cube'
        OPEN(UNIT=IMOL,FILE=INPFILE,STATUS='UNKNOWN',
     1    ACCESS='SEQUENTIAL',FORM='FORMATTED')
        DO I1=1,NBASIS
           C3(I1) = RWRK(I1+(I-1)*NBASIS)
        ENDDO
C       WRITE(IOUTVB,'(6E16.8)') (C3(I1),I1=1,NBASIS)
        DO I1=1,IPRM
           C2(I1) = C3(KT(I1))
        ENDDO
C       WRITE(IOUTVB,'(6E16.8)') (C2(I1),I1=1,IPRM)
C       FOLD IN COEFFICIENTS FROM SELECTED VB ORBITAL
        DO I1=1,IPRM
           C2(I1) = C(I1)*C2(I1)
        ENDDO
C       WRITE(IOUTVB,'(6E16.8)') (C2(I1),I1=1,IPRM)
        CALL CUBE(C2,TITLE,NP,I,IPRM,LFIRST)
        CLOSE(IMOL)
        WRITE(IOUTVB,142) I,INPFILE
        LFIRST=.FALSE.
      ENDDO
      TIME2=XCLOCK()
      WRITE(IOUTVB,'(/," TIME FOR CUBE =",F8.3)') TIME2-TIME1
 142  FORMAT(' CUBE FILE FOR ORBITAL',I4,' CREATED AS ',A64)
 205  CONTINUE
C
C     $GENGRID & $GRID
C     Create GRID files for DS Visualizer, which is free from Accelrys.
C
      IF(.NOT.LGRID) GOTO  206
      TIME1=XCLOCK()
      IF(IGRID.EQ.1) CALL LOCTOR(IOENGI,'$GENGRID',5,IOK,0)
      IF(IGRID.EQ.2) CALL LOCTOR(IOENGI,'$GRID',5,IOK,0)
      CALL CUBEDATA(NVB,NP,KVB,TITLE,IOENGI,IOUTVB,IERR,NOCB,MAXCUB)
      IF (IERR.EQ.1) THEN
         WRITE(IOUTVB,106) NP
         GOTO 206
      ENDIF
      DO J=1,NVB
        I=KVB(J)
        WRITE(TAG,'(I3.3)') I
        INPFILE=FSTR(1:LENFIL)//'-orb-'//TAG//'.grd'
        OPEN(UNIT=IMOL,FILE=INPFILE,STATUS='UNKNOWN',
     1    ACCESS='SEQUENTIAL',FORM='FORMATTED')
        DO I1=1,NBASIS
           C3(I1) = RWRK(I1+(I-1)*NBASIS)
        ENDDO
        DO I1=1,IPRM
           C2(I1) = C3(KT(I1))
        ENDDO
        DO I1=1,IPRM
           C2(I1) = C(I1)*C2(I1)
        ENDDO
        CALL GENGRID(C2,TITLE,NP,IMOL,I,IPRM)
        CLOSE(IMOL)
        WRITE(IOUTVB,146) I,INPFILE
      ENDDO
 146  FORMAT(' GRID FILE FOR ORBITAL',I4,' CREATED AS ',A64)
      TIME2=XCLOCK()
      WRITE(IOUTVB,'(/," TIME FOR GRID =",F8.3)') TIME2-TIME1
 206  CONTINUE
C
C     $LINE directive.
C
C     The purpose is to produce the value of a VBO along a line which
C     can be divided into sections of the same length. The data is output 
C     in a form (*.csv) where it can readily be in put into a spreadsheet 
C     such as Excel, OpenOffice or LibreOffice.
C
      IF(.NOT.LLINE) GOTO  207
      TIME1=XCLOCK()
      LFIRST=.TRUE.
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$LINE',5,IOK,0)
C     NO OF VB ORBITALS FOLLOWED BY ORBITAL NUMBERS
      READ(IOENGI,*) NVB
      READ(IOENGI,*) (KVB(J),J=1,NVB)
      READ(IOENGI,*) NCRIT,NP
      IF(NCRIT.LT.2) NCRIT=2
      IF(NP.GT.100) THEN
         WRITE(IOUTVB,106) NP
         GOTO 207
      ENDIF
      WRITE(IOUTVB,100)
      WRITE(IOUTVB,108)
      WRITE(IOUTVB,107)
      NPOINT=0
      DO I=1,NCRIT
        READ(IOENGI,*) NATPT,(XALL(J,I+1),J=1,3)
        IF (I.EQ.1) THEN
          NPOINT=NPOINT + NP + 1
        ELSE
          NPOINT=NPOINT + 2 * NP + 1
        ENDIF
        IF (NATPT.GT.0) THEN
          WRITE(IOUTVB,102) ATMSYM(NATNUM(NATPT)),NPOINT,
     &      ATMCHG(NATPT),(XALL(J,I+1),J=1,3)
        ELSE
          WRITE(IOUTVB,109) NPOINT,(XALL(J,I+1),J=1,3)
        ENDIF
      ENDDO
      WRITE(IOUTVB,103) NVB
      DO I=1,NATOM
      DO J=1,3
        C1(J,I)=XYZ(J,I)/TOANG
      ENDDO
      ENDDO
      DO I=1,NCRIT
      DO J=1,3
        XALL(J,I+1)=XALL(J,I+1)/TOANG
      ENDDO
      ENDDO
      DO J=1,NVB
        I=KVB(J)
        WRITE(TAG,'(I3.3)') I
        INPFILE=FSTR(1:LENFIL)//'-'//TAG//'.csv'
        OPEN(UNIT=IMOL,FILE=INPFILE,STATUS='UNKNOWN',
     1    ACCESS='SEQUENTIAL',FORM='FORMATTED')
C       Get VBO in C3 in any event.        
        DO I1=1,NBASIS
           C3(I1) = RWRK(I1+(I-1)*NBASIS)
        ENDDO
        DO I1=1,IPRM
           C2(I1) = C3(KT(I1))
        ENDDO
C       FOLD IN COEFFICIENTS FROM SELECTED VB ORBITAL
        DO I1=1,IPRM
           C2(I1) = C(I1)*C2(I1)
        ENDDO
        CALL LINE(C1,C2,NCRIT,NP,IPRM,LFIRST,XALL)
        LFIRST=.FALSE.
        CLOSE(IMOL)
        WRITE(IOUTVB,104) I
        WRITE(IOUTVB,110) I,INPFILE
      ENDDO
      TIME2=XCLOCK()
      WRITE(IOUTVB,'(/," TIME FOR LINE =",F8.3)') TIME2-TIME1
 100  FORMAT(" LINE FILE DETAILS",/)
 102  FORMAT(2X,A2,3X,I4,2X,4F12.6)
 103  FORMAT(/," No. of VB orbitals =",I2)
 104  FORMAT(" VB orbital =",I4)
 106  FORMAT(' NP CAN NOT EXCEED 100. IT IS',I4,/)
 107  FORMAT(" ATOM  NPOINT    ATOM CHG",7X,"X",11X,"Y",11X,"Z",/)
 108  FORMAT(" THE VALUES OF NPOINT BELOW ARE THE SPREADSHEET POINTS",
     &" FOR THE",/," CRITICAL POINTS. THE ATOM SYMBOL AND CHARGE",
     &" ASSUME THE CRITICAL",/," POINT IS AN ATOM OR ASSOCIATED",
     &" WITH AN ATOM",/)
 109  FORMAT(7X,I4,2X,12X,3F12.6)
 110  FORMAT(' LINE FILE FOR ORBITAL',I4,' CREATED AS ',A64,/)
 207  CONTINUE
C
C     $DENSCUBE directive.
C
C     The purpose is to produce a CUBE file for the total density, 
C     or the density of a single group, most likely a VB group, 
C     or the spin density.
C
      IF(.NOT.LDENS) GOTO 208
      TIME1=XCLOCK()
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$DENSCUBE',9,IOK,0)
      READ(IOENGI,'(A40)') TITLE
C     WRITE(IOUTVB,'(/," DENSCUBE DATA")') 
C     WRITE(IOUTVB,'(A40)') TITLE
C     DUMMY READ - LDENS etc. read earlier.
      IF(LTEST.EQ.1) NOCB=(NELE-NSPIN)/2 + NSPIN
      CALL CUBEDATA(NVB,NP,KVB,TITLE,IOENGI,IOUTVB,IERR,NOCB,MAXCUB)
C     WRITE(IOUTVB,'(I4)') NVB
C     WRITE(IOUTVB,'(10I4)') (KVB(J),J=1,NVB)
C     WRITE(IOUTVB,'(A40)') TITLE
C     WRITE(IOUTVB,'(I4,/)') NP
      IF (IERR.EQ.1) THEN
         WRITE(IOUTVB,106) NP
         GOTO 208
      ENDIF
      OPEN(UNIT=IDENS,FILE=DENFILE,STATUS='OLD',
     &    FORM='UNFORMATTED')
      LFIRST=.TRUE.
      IF (LSD) THEN
        INPFILE=FSTR(1:LENFIL)//'-dens-spin.cube'
        OPEN(UNIT=IMOL,FILE=INPFILE,STATUS='UNKNOWN',
     1    ACCESS='SEQUENTIAL',FORM='FORMATTED')
        K = 1
        READ(IDENS) (RWRK(LDMA-1+L),L=1,NBA2)
        CALL DENSCUBE(RWRK(LDMA),TITLE,NP,K,LFIRST,NSPIN,1)
        CLOSE(IMOL)
        WRITE(IOUTVB,152) INPFILE
        LFIRST=.FALSE.
      ENDIF
      IF (LGRP) THEN
        READ(IDENS) J
        DO K=1,NSUB
          HAVE=.FALSE.
          DO I=1,NVB
            IF (K.EQ.KVB(I)) HAVE=.TRUE.
          ENDDO
          READ(IDENS) (RWRK(LDMA-1+L),L=1,NBA2)
          IF (HAVE) THEN
            WRITE(TAG,'(I3.3)') K
            INPFILE=FSTR(1:LENFIL)//'-dens-'//TAG//'.cube'
            OPEN(UNIT=IMOL,FILE=INPFILE,STATUS='UNKNOWN',
     1        ACCESS='SEQUENTIAL',FORM='FORMATTED')
            CALL DENSCUBE(RWRK(LDMA),TITLE,NP,K,LFIRST,MELE(K),2)
            CLOSE(IMOL)
            LFIRST=.FALSE.
            WRITE(IOUTVB,150) K,INPFILE
          ENDIF
        ENDDO
      ENDIF
      IF (LTOT) THEN
        INPFILE=FSTR(1:LENFIL)//'-dens-tot.cube'
        OPEN(UNIT=IMOL,FILE=INPFILE,STATUS='UNKNOWN',
     1    ACCESS='SEQUENTIAL',FORM='FORMATTED')
        K = 1
        READ(IDENS) (RWRK(LDMA-1+L),L=1,NBA2)
        CALL DENSCUBE(RWRK(LDMA),TITLE,NP,K,LFIRST,NELE,3)
        CLOSE(IMOL)
        WRITE(IOUTVB,153) INPFILE
      ENDIF
      TIME2=XCLOCK()
      WRITE(IOUTVB,'(" TIME FOR DENSITY CUBES =",F8.3)') TIME2-TIME1
      CLOSE(IDENS,STATUS='DELETE')
C
 150  FORMAT(' DENSITY FILE FOR GROUP',I4,' CREATED AS ',A64,/)
 152  FORMAT(' SPIN DENSITY FILE CREATED AS ',A64,/)
 153  FORMAT(' TOTAL DENSITY FILE CREATED AS ',A64,/)
 208  RETURN
      END
      SUBROUTINE CUBEDATA(NVB,NP,KVB,TITLE,IOENGI,IOUTVB,IERR,NOCB,
     &MAXCUB)
      IMPLICIT NONE
      CHARACTER*40 TITLE
      INTEGER MAXCUB
      INTEGER KVB(MAXCUB),NVB,NP,IERR,IOENGI,IOUTVB,NOCB
C
      INTEGER I,J,LVB(100)
C
      CHARACTER*64 DENFILE
      INTEGER IDENS
      LOGICAL LDENS,LTOT,LGRP,LSD
      COMMON /DCUBE/ IDENS,LDENS,LTOT,LGRP,LSD,DENFILE
C
      IERR = 0
      IF (LGRP.OR..NOT.LDENS) THEN
C       NO OF VB ORBITALS FOLLOWED BY ORBITAL NUMBERS
        READ(IOENGI,*) NVB
        IF(NVB.GE.MAXCUB) CALL SIZEABT(NVB,MAXCUB,"CUBE FILES  ",
     &     "MAXCUB",IOUTVB,.TRUE.)
        READ(IOENGI,*) (KVB(J),J=1,NVB)
        I = 0
        DO J=1,NVB
          IF (KVB(J).LE.NOCB) THEN
            I = I + 1 
            LVB(I) = KVB(J)
          ELSE
            WRITE(IOUTVB, '(/,"ORBITAL",I4,
     &        " REMOVED FROM LIST - NOT AVAILABLE")') KVB(J)
          ENDIF
        ENDDO
        NVB = I
        DO J=1,NVB
          KVB(J) = LVB(J)
        ENDDO
      ENDIF
C     TITLE - NO DEFAULT
      READ(IOENGI,'(A40)') TITLE
C     UNFORMATTED - NPOINTS (DEFAULT = 80)
      READ(IOENGI,*) NP
      IF(NP.EQ.0) NP=80
      IF(NP.GT.100) IERR = 1
      RETURN
      END
      SUBROUTINE SETCUBE(IPRM,IERR)
      IMPLICIT NONE
      INTEGER IPRM,IERR
      INTEGER I,J,IIIC,KK,NN,K,KKK,JJJ,KKK1
      DOUBLE PRECISION FACTR(7)
      DOUBLE PRECISION PI,PI32,AA,CC
C
      INTEGER NUMD,NUMF
      COMMON /DORF/ NUMD,NUMF
C
      DOUBLE PRECISION XE,C
      INTEGER IT,JT,KT,MT,MCT,MAXEXP,MAXBFN
      PARAMETER(MAXEXP=1000,MAXBFN=726)
      COMMON /CUBEC/ XE(MAXEXP),C(MAXEXP),IT(MAXEXP),JT(MAXEXP),
     & KT(MAXEXP),MT(MAXBFN),MCT(MAXBFN)
C
      CHARACTER*1 SYM
      INTEGER MAXCEN,MAXSHL,NF,KATOM,IMOL,MAXPRM
      DOUBLE PRECISION XEXP,COEFF
      PARAMETER (MAXSHL=500,MAXCEN=200,MAXPRM=15)
      COMMON /SEEING/ XEXP(MAXSHL,MAXPRM),COEFF(MAXSHL,MAXPRM)
     &,NF(MAXSHL),KATOM(MAXCEN),IMOL,SYM(MAXSHL)
C
      INTEGER IOUTVB,LENFIL
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      INTEGER NATOM,NELE,NSPIN,NBASIS,NATNUM,NATBAS
      DOUBLE PRECISION ENREP,XYZ
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
C
      DOUBLE PRECISION HALF,THR,FOUR,FIVE,X10,X20,SQ2,SQ3,SQ5,SQ6,SQ7
     & ,SQ10,SQ14,SQ21,SQ30,SQ35,SQ70,SQ105,FACTSQ
      COMMON /SPHCON/HALF,THR,FOUR,FIVE,X10,X20,SQ2,SQ3,SQ5,SQ6,SQ7
     &,SQ10,SQ14,SQ21,SQ30,SQ35,SQ70,SQ105,FACTSQ(7)
C
      DATA FACTR/1.0D+00,1.0D+00,3.0D+00,1.5D+01,1.05D+02,9.45D+02,
     & 1.0395D+04/
      DO I=1,7
        FACTSQ(I) = 1.0D0/SQRT(FACTR(I))
      ENDDO
      PI = ACOS(-1.0D0)
      PI32 = PI * SQRT(PI)
      SQ7 = SQRT(7.0D0)
      IERR = 0
      IPRM=0
      IIIC=0
      NN=0
      DO I=1,NATOM
        DO KK=1,KATOM(I)
          NN=NN+1
          IF (SYM(NN).EQ.'S') THEN
            K=1
            KKK=1
            GOTO 111
          ENDIF
          IF (SYM(NN).EQ.'P') THEN
            K=3
            KKK=2
            GOTO 111
          ENDIF
          IF (SYM(NN).EQ.'D') THEN
CGAU        IF(NUMD.EQ.0) THEN
CGAU          K=5
CGAU          KKK=13
CGAU        ELSE
              K=6
              KKK=3
CGAU        ENDIF
            GOTO 111
          ENDIF
          IF(NUMF.NE.0) THEN
            IF (SYM(NN).EQ.'F') THEN
              K=10
              KKK=4
              GOTO 111
            ENDIF
            IF (SYM(NN).EQ.'G') THEN
              K=15
              KKK=5
              GOTO 111
            ENDIF
            IF (SYM(NN).EQ.'H') THEN
              K=21
              KKK=6
              GOTO 111
            ENDIF
            IF (SYM(NN).EQ.'I') THEN
              K=28
              KKK=7
              GOTO 111
            ENDIF
CGAU      ELSE
CGAU        IF (SYM(NN).EQ.'F') THEN
CGAU          K=7
CGAU          KKK=14
CGAU          GOTO 111
CGAU        ENDIF
CGAU        IF (SYM(NN).EQ.'G') THEN
CGAU          K=9
CGAU          KKK=15
CGAU          GOTO 111
CGAU        ENDIF
CGAU        IF (SYM(NN).EQ.'H') THEN
CGAU          K=11
CGAU          KKK=16
CGAU          GOTO 111
CGAU        ENDIF
CGAU        IF (SYM(NN).EQ.'I') THEN
CGAU          K=13
CGAU          KKK=17
CGAU          GOTO 111
CGAU        ENDIF
          ENDIF
          WRITE(IOUTVB,144) SYM(NN)
          IERR = 1
          RETURN
 111      DO JJJ=1,K
            IIIC=IIIC+1
            DO J=1,NF(NN)
              IPRM=IPRM+1
              JT(IPRM) = I
C             STORE ATOM
C
C             KKK - TYPE OF ORBITAL - S, P, D, F, G, H, I --> 1 2 3 4 5 6 7
C                   SPHERICAL HARMONIC - D, F, G, H, I --> 13 14 15 16 17
C             JJJ -  SUB-TYPE - e,g D --> 1 2 3 4 5 6
              IF(KKK.EQ.1) IT(IPRM)=JJJ
              IF(KKK.EQ.2) IT(IPRM)=JJJ + 1
              IF(KKK.EQ.3) IT(IPRM)=JJJ + 4
              IF(KKK.EQ.4) IT(IPRM)=JJJ + 10
              IF(KKK.EQ.5) IT(IPRM)=JJJ + 20
              IF(KKK.EQ.6) IT(IPRM)=JJJ + 35
              IF(KKK.EQ.7) IT(IPRM)=JJJ + 56
C             PURE SPHERICAL HARMONIC - ONLY IN GAUSSIAN
CGAU          IF(KKK.EQ.13) IT(IPRM)=JJJ + 100
CGAU          IF(KKK.EQ.14) IT(IPRM)=JJJ + 105
CGAU          IF(KKK.EQ.15) IT(IPRM)=JJJ + 112
CGAU          IF(KKK.EQ.16) IT(IPRM)=JJJ + 121
CGAU          IF(KKK.EQ.17) IT(IPRM)=JJJ + 132
              KKK1 = KKK
CGAU          IF (KKK.GT.10) KKK1 = KKK - 10
              XE(IPRM)=XEXP(NN,J)
C             PRIMITIVE ORBITAL EXPONENT
              AA = XEXP(NN,J)**(KKK1+0.5D+00) *
     &            2.0D+00**(KKK1+KKK1-0.5D+00)
              AA = AA / PI32
C
C             ADD NORMALISATION INTO CONTRACTION COEFFICIENT ALONG 
C             WITH ANYTHING ELSE THAT IS NOT DEPENDENT ON POSITION,
C             OTHER THAN DOUBLE FACTORIAL NORMALISATION TERMS.
              CC=SQRT(AA)*COEFF(NN,J)
C
C             D CARTESIANS
              IF(KKK.EQ.3.and.JJJ.LE.3) CC = FACTSQ(3) * CC
C             D SPHERICAL HARMONICS ONLY FOR GAUSSIAN - ALL DONE HERE
CGAU          IF(KKK.EQ.13) THEN
CGAU            IF(JJJ.EQ.1) CC = FACTSQ(3) * CC
CGAU            IF(JJJ.EQ.4) CC = FACTSQ(3) * CC
CGAU          ENDIF
C
C             FROM F ON, CARTESIAN ORDER IS DIFFERENT IN GAMESS & GAUSSIAN.
C
C             F FUNCTIONS
C             GMS & GAU GROUPING IS THE SAME BUT ORDER DIFFERENT.
              IF(KKK.EQ.4) THEN
                IF(JJJ.LT.4) CC = FACTSQ(4) * CC
                IF(JJJ.GE.4.AND.JJJ.LT.10) CC = FACTSQ(3) * CC
              ENDIF
C             SPHERICAL HARMONICS LEFT TO SPHERGAU
C
C             G FUNCTIONS
              IF(KKK.EQ.5) THEN
CGMS            IF(JJJ.LT.4) CC = FACTSQ(5) * CC
CGMS            IF(JJJ.GE.4.AND.JJJ.LT.10) CC = FACTSQ(4) * CC
CGMS            IF(JJJ.GE.10.AND.JJJ.LT.13) 
CGMS &             CC = FACTSQ(3) * FACTSQ(3) * CC  
CGMS            IF(JJJ.GE.13) CC = FACTSQ(3) * CC
C
C       GAUSSIAN CARTESIANS FOR G, H & I IN VB2000 CAN NOT BE TESTED 
C       AS THERE IS A BUG IN GAUSSIAN THAT IS FIXED FOR THE NEXT RELEASE
CGAU            IF(JJJ.EQ.1.OR.JJJ.EQ.5.OR.JJJ.EQ.15) 
CGAU &             CC = FACTSQ(5) * CC
CGAU            IF(JJJ.EQ.2.OR.JJJ.EQ.4.OR.JJJ.EQ.6) 
CGAU &             CC = FACTSQ(4) * CC
CGAU            IF(JJJ.EQ.9.OR.JJJ.EQ.13.OR.JJJ.EQ.14) 
CGAU &             CC = FACTSQ(4) * CC
CGAU            IF(JJJ.EQ.3.OR.JJJ.EQ.10.OR.JJJ.EQ.12) 
CGAU &            CC = FACTSQ(3) * FACTSQ(3) * CC 
CGAU            IF(JJJ.EQ.7.OR.JJJ.EQ.8.OR.JJJ.EQ.11) 
CGAU &            CC = FACTSQ(3) * CC
              ENDIF
C             SPHERICAL HARMONICS LEFT TO SPHERGAU
C
C             H FUNCTIONS
              IF(KKK.EQ.6) THEN
CGMS            IF(JJJ.LT.4) CC = FACTSQ(6) * CC
CGMS            IF(JJJ.GE.4.AND.JJJ.LT.10) CC = FACTSQ(5) * CC
CGMS            IF(JJJ.GE.10.AND.JJJ.LT.16) 
CGMS &             CC = FACTSQ(4) * FACTSQ(3) * CC
CGMS            IF(JJJ.GE.16.AND.JJJ.LT.19) CC = FACTSQ(4) * CC
CGMS            IF(JJJ.GE.19) CC = FACTSQ(3) * FACTSQ(3) * CC 
C
C       THIS SECTION IS MISSING A GROUP OF 6 - 3 4 12 15 16 18 THAT
C       MIGHT BE FACTSQ(5), BUT NEEDS CHECKING - NOT POSSIBLE - SEE ABOVE
C  GAU            IF(JJJ.EQ.1.OR.JJJ.EQ.6.OR.JJJ.EQ.21) 
C  GAU &             CC = FACTSQ(6) * CC
C  GAU            IF(JJJ.EQ.2.OR.JJJ.EQ.5.OR.JJJ.EQ.7)
C  GAU &             CC = FACTSQ(4) * FACTSQ(3) * CC
C  GAU            IF(JJJ.EQ.11.OR.JJJ.EQ.19.OR.JJJ.EQ.20) 
C  GAU &            CC = FACTSQ(4) * FACTSQ(3) * CC
C  GAU            IF(JJJ.EQ.8.OR.JJJ.EQ.10.OR.JJJ.EQ.17) 
C  GAU &            CC = FACTSQ(4) * CC
C  GAU            IF(JJJ.EQ.9.OR.JJJ.EQ.13.OR.JJJ.EQ.14) 
C  GAU &            CC = FACTSQ(3) * FACTSQ(3) * CC 
              ENDIF
C             SPHERICAL HARMONICS LEFT TO SPHERGAU
C
C             I FUNCTIONS
              IF(KKK.EQ.7) THEN
CGMS            IF(JJJ.LE.3) CC = FACTSQ(7) * CC 
CGMS            IF(JJJ.GE.4.AND.JJJ.LT.10) CC = FACTSQ(6) * CC 
CGMS            IF(JJJ.GE.10.AND.JJJ.LT.16) 
CGMS &            CC = FACTSQ(5) * FACTSQ(3) * CC 
CGMS            IF(JJJ.GE.16.AND.JJJ.LT.19) CC = FACTSQ(5) * CC
CGMS            IF(JJJ.GE.19.AND.JJJ.LT.22) 
CGMS &            CC = FACTSQ(4) * FACTSQ(4) * CC 
CGMS            IF(JJJ.GE.22.AND.JJJ.LT.28) 
CGMS &            CC = FACTSQ(4) * FACTSQ(3) * CC 
CGMS            IF(JJJ.EQ.28) 
CGMS &            CC = FACTSQ(3) * FACTSQ(3) * FACTSQ(3) * CC 
C
C               GAUSSIAN I CARTESIANS STILL TO BE DONE
              ENDIF
C             SPHERICAL HARMONICS LEFT TO SPHERGAU
C
              C(IPRM) = CC
              KT(IPRM)=IIIC
C             BASIS FUNCTION FROM VB ORBITAL TO WRAP IN LATER
C             FOLD IN NORMALISATION
C             WRITE(IOUTVB,143) IPRM,XE(IPRM),C(IPRM),KKK,JJJ,KT(IPRM),
C    &          IT(IPRM),JT(IPRM)
            ENDDO
          ENDDO
        ENDDO
      ENDDO
      DO I=1,NBASIS
        MT(I) = 0
      ENDDO
      DO J=1,IPRM
        MT(KT(J)) = MT(KT(J)) + 1
      ENDDO
      DO I=1,NBASIS
        DO J=1,IPRM
          IF (KT(J).EQ.I) THEN
            MCT(I) = J
            GOTO 200
          ENDIF
        ENDDO
 200    CONTINUE
      ENDDO
      IF (IPRM.GE.MAXEXP) THEN
        CALL SIZEABT(IPRM,MAXEXP,"TOTAL PRIMS ",
     &   "MAXEXP",IOUTVB,.FALSE.)
        IERR = 1
      ENDIF
      RETURN
 144  FORMAT(' INCORRECT SYMBOL ',A1)
      END
      SUBROUTINE LINE(C1,C2,NCRIT,NP,IPRM,LFIRST,XALL)
C#######################################################################
C
C     Calculates LINE output - one per orbital.
C
C#######################################################################
      IMPLICIT NONE
      INTEGER NCRIT,NP,IPRM,MAXCEN,MAXEXP,MAXBFN
      PARAMETER (MAXCEN=200,MAXEXP=1000,MAXBFN=726)
      DOUBLE PRECISION C1(3,MAXCEN),C2(MAXEXP),XALL(3,10)
      LOGICAL LFIRST
C
      INTEGER J,I1,I2,I3,I4,L,K,N
      DOUBLE PRECISION X,Y,Z,SUM,XX(3)
C
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      INTEGER IOUTVB,LENFIL
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
      DOUBLE PRECISION XE,C
      INTEGER IT,JT,KT,MT,MCT
      COMMON /CUBEC/ XE(MAXEXP),C(MAXEXP),IT(MAXEXP),JT(MAXEXP),
     & KT(MAXEXP),MT(MAXBFN),MCT(MAXBFN)
C
      CHARACTER*1 SYM
      INTEGER MAXSHL,NF,KATOM,IMOL,MAXPRM
      DOUBLE PRECISION XEXP,COEFF
      PARAMETER (MAXSHL=500,MAXPRM=15)
      COMMON /SEEING/ XEXP(MAXSHL,MAXPRM),COEFF(MAXSHL,MAXPRM)
     &,NF(MAXSHL),KATOM(MAXCEN),IMOL,SYM(MAXSHL)
C
      DO J=1,3
        XX(J) = (XALL(J,3)-XALL(J,2))/(2*NP)
        XALL(J,1)=XALL(J,2) - NP * XX(J)
        XALL(J,NCRIT+2)=XALL(J,NCRIT+1) + NP * XX(J)
      ENDDO
      L = 0
      N = NCRIT + 1
      I2 = 2 * NP + 1
      I3 = 1
      DO I4=1,N
      IF (I4.EQ.3) I3 = 0
      K = 2 * NP
      IF(I4.EQ.1.OR.I4.EQ.N) K = NP
      IF(I4.EQ.2) K = I2
      IF(I4.GT.2.AND.I4.LT.N) THEN
        XX(1) = (XALL(1,I4+1)-XALL(1,I4))/(2*NP)
        XX(2) = (XALL(2,I4+1)-XALL(2,I4))/(2*NP)
        XX(3) = (XALL(3,I4+1)-XALL(3,I4))/(2*NP)
      ENDIF
      DO I1=1,K
        L = L + 1
        X=XALL(1,I4) + (I1-I3)*XX(1)
        Y=XALL(2,I4) + (I1-I3)*XX(2)
        Z=XALL(3,I4) + (I1-I3)*XX(3)
        SUM = 0.0D0
C000    CALL ORBPT(SUM,C1,C2,XE,X,Y,Z,JT,IT,1,IPRM)
CGMS    CALL ORBPTM(SUM,C1,C2,XE,X,Y,Z,JT,IT,1,IPRM)
CGAU    CALL ORBPTG(SUM,C1,C2,XE,X,Y,Z,JT,IT,1,IPRM)
        WRITE(IMOL,105) L,SUM
        ENDDO
      ENDDO
      IF (LFIRST) WRITE(IOUTVB,106) L
      RETURN
 105  FORMAT(I4,",",F15.10)
 106  FORMAT(" Total number of points =",I4,/)
      END
      SUBROUTINE GMSORB(RWRK,ATMSYM,NCCC,IVEC)
C#######################################################################
C
C     Calculates PLTORB outout.
C
C#######################################################################
      IMPLICIT NONE
      DOUBLE PRECISION RWRK(*)
      CHARACTER*2 ATMSYM(92),XY
      CHARACTER*8 PLANE
      CHARACTER*40 TITLE
CGMS  INTEGER ISAVE
      INTEGER IAT1,IAT2,IAT3,KK,NN,NO,MAX,MIN,MODJ,I,J,ID,IGMS,
     & NCCC,IVEC,IA(20),IB(20),IC(20),NBONDS,NVBOS,IOENGI,IOK
      DOUBLE PRECISION PX(4),XOFF
C
      CHARACTER*1 SYM
      INTEGER MAXCEN,MAXSHL,MAXBFN,NF,KATOM,IMOL,MAXPRM
      DOUBLE PRECISION XEXP,COEFF
      PARAMETER (MAXSHL=500,MAXCEN=200,MAXPRM=15,MAXBFN=726)
      COMMON /SEEING/ XEXP(MAXSHL,MAXPRM),COEFF(MAXSHL,MAXPRM)
     &,NF(MAXSHL),KATOM(MAXCEN),IMOL,SYM(MAXSHL)
C
CGMS  INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
CGMS  COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,INPFILE,LOCFILE
      INTEGER IOUTVB,LENFIL
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      INTEGER NATOM,NELE,NSPIN,NBASIS,NATNUM,NATBAS
      DOUBLE PRECISION ENREP,XYZ
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
C
CGAU  INTEGER NUMD,NUMF
CGAU  COMMON /DORF/ NUMD,NUMF
C
C     CREATE *.orb FILE AND $VEC GROUP OF VB ORBITALS IN *.vec FOR 
C     PLTORB, OR JUST  *.vec FILE FOR MacMolPlt.
C
      INPFILE=FSTR(1:LENFIL)//'.vec'
      OPEN(UNIT=IMOL,FILE=INPFILE,STATUS='UNKNOWN',
     1  ACCESS='SEQUENTIAL',FORM='FORMATTED')
C     NOCB=NB1ADD(NSUB+1)-1
      WRITE(IMOL,'("VB2000 orbitals")')
      WRITE(IMOL,101)
 101  FORMAT(' $VEC')
C
C     GAMESS USE - EASY, GET PUSQL TO DO IT.
C     SET IGMS=1 and use IF(IGMS.EQ.1) statement to void ftnchek error
CGMS  ISAVE=IP
CGMS  IP=IMOL
CGMS  CALL PUSQL(RWRK(1),NCCC,NBASIS,NBASIS)
CGMS  IP=ISAVE
CGMS  WRITE(IMOL,102)
      IGMS=0
CGMS  IGMS=1
      IF(IGMS.EQ.1) GOTO 12
C
C     NOW FOR MORE COMPLEX NON-GAMESS use.
C
C     VEC FIRST
      DO J = 1,NCCC
        ID = 0
        MAX = 0
 11     MIN = MAX+1
        MAX = MAX+5
        ID = ID+1
        IF (MAX .GT. NBASIS) MAX = NBASIS
        MODJ=MOD(J,100)
        WRITE (IMOL,9) MODJ,ID,(RWRK(I+(J-1)*NBASIS),I = MIN,MAX)
        IF (MAX .LT. NBASIS) GO TO 11
      ENDDO
      WRITE(IMOL,102)
      CLOSE(IMOL)
 12   CONTINUE
C
C     RETURN IF ONLY *.vec REQUIRED
      IF(IVEC.EQ.2) RETURN
C     THEN *.orb FILE
      PLANE="        "
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      REWIND(IOENGI)
      CALL LOCTOR(IOENGI,'$PLTORB',7,IOK,0)
      IF(IOK.EQ.1) THEN
        READ(IOENGI,*) NBONDS,(IA(J),IB(J),J=1,NBONDS)
        READ(IOENGI,*) NVBOS,(IC(J),J=1,NVBOS)
        READ(IOENGI,*) PLANE
        IF (PLANE.EQ."SYMBOLIC") READ(IOENGI,*) XY
        IF (PLANE.EQ."3ATOMS  ") READ(IOENGI,*) IAT1,IAT2,IAT3
        READ(IOENGI,*) XOFF
        READ(IOENGI,*) (PX(J),J=1,4)
      ELSE
        RETURN
      ENDIF
      INPFILE=FSTR(1:LENFIL)//'.orb'
      OPEN(UNIT=IMOL,FILE=INPFILE,STATUS='UNKNOWN',
     1  ACCESS='SEQUENTIAL',FORM='FORMATTED')
      WRITE(IMOL,1) NATOM,NBONDS,NBASIS,NCCC,NVBOS,PLANE
CGAU  IF(NUMD.EQ.0.AND.NUMF.EQ.1) WRITE(IMOL,'("5D GAUSN")')
CGAU  IF(NUMD.EQ.1.AND.NUMF.EQ.0) WRITE(IMOL,'("7F GAUSN")')
CGAU  IF(NUMD.EQ.0.AND.NUMF.EQ.0) WRITE(IMOL,'("5D 7F GAUSN")')
      WRITE(IMOL,'("FORMAT (5X,5E15.8)")')
      NO=1
      DO I=1,NATOM
        WRITE(IMOL,2) ATMSYM(NATNUM(I)),(XYZ(J,I),J=1,3)
      ENDDO
      IF (PLANE.EQ."SYMBOLIC") WRITE(IMOL,3) XY 
      IF (PLANE.EQ."3ATOMS  ") WRITE(IMOL,'(3I3)') IAT1,IAT2,IAT3
      WRITE(IMOL,10) XOFF,(PX(J),J=1,4)
      WRITE(IMOL,4) (IA(J),IB(J),J=1,NBONDS)
      WRITE(IMOL,5) (IC(J),J=1,NVBOS)
      NN=0
      DO I=1,NATOM
        WRITE(IMOL,104) ATMSYM(NATNUM(I)),KATOM(I)
        DO KK=1,KATOM(I)
        NN=NN+1
        WRITE(IMOL,6) SYM(NN),NF(NN),NO
        WRITE(IMOL,7) (XEXP(NN,J),J=1,NF(NN))
        WRITE(IMOL,7) (COEFF(NN,J),J=1,NF(NN))
        ENDDO
      ENDDO
      DO J=1,NVBOS
        READ(IOENGI,'(A40)') TITLE
        WRITE(IMOL,8) TITLE
      ENDDO
      CLOSE(IMOL)
C
 1    FORMAT('NATOMS=',I4,'   NBONDS=',I4,'  NAOS=',I4,'   NMOS=',I4,
     &'  NPLOTS=',I4,/,'PLANE=',A8,'  KOLOR=1 ANGSTROMS ')
 2    FORMAT(A2,3F20.10)
 3    FORMAT(A2)
 10   FORMAT(F8.4,/,4F8.4)
 4    FORMAT('BONDATOMS ',40I3)
 5    FORMAT('PLOTMOS ',20I3)
 6    FORMAT(A1,2I3)
 7    FORMAT(1P,5E14.6,:,' >')
 8    FORMAT(A40)
 9    FORMAT(I2,I3,1P,5E15.8)
 102  FORMAT(' $END')
 104  FORMAT(A2,I6)
      RETURN
      END

      SUBROUTINE GMSPLT(ATMSYM)
C#######################################################################
C
C     Calculates MOLPLT output.
C
C#######################################################################
      IMPLICIT NONE
      CHARACTER*2 ATMSYM(92)
      INTEGER IKINDS(92),KOLORS(92),I,J,NKINDS
      DOUBLE PRECISION CARBON,SIZE
C
      CHARACTER*1 SYM
      INTEGER MAXCEN,MAXSHL,MAXBFN,NF,KATOM,IMOL,MAXPRM
      DOUBLE PRECISION XEXP,COEFF
      PARAMETER (MAXSHL=500,MAXCEN=200,MAXPRM=15,MAXBFN=726)
      COMMON /SEEING/ XEXP(MAXSHL,MAXPRM),COEFF(MAXSHL,MAXPRM)
     &,NF(MAXSHL),KATOM(MAXCEN),IMOL,SYM(MAXSHL)
C
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,INPFILE,LOCFILE
      INTEGER IOUTVB,LENFIL
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      INTEGER NATOM,NELE,NSPIN,NBASIS,NATNUM,NATBAS
      DOUBLE PRECISION ENREP,XYZ
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
C
      DATA KOLORS/5,14,          2*11,10,1,4,2,15,14,
     *    2*11,10,6,9,7,3,14,    2*11,10*8,4*10,9,14,
     *    2*11,10*8,4*10,12,14,  2*11,14*13,10*8,5*10,14,
     *    2*11,4*13/
C     These colours and the atomic sizes below are taken from
C     Gamess for consistency with plots made from Gamess.
C
C     Create mol file for molplt to display molecular frame.
C
      DO I=1,92
        IKINDS(I)=0
      ENDDO
      INPFILE=FSTR(1:LENFIL)//'.mol'
      OPEN(UNIT=IMOL,FILE=INPFILE,STATUS='UNKNOWN',
     1  ACCESS='SEQUENTIAL',FORM='FORMATTED')
C
C     Find NKINDS - the number of different atoms
C
      DO I=1,NATOM
         IKINDS(NATNUM(I)) = 1
      ENDDO
      NKINDS = 0
      DO I=1,92
        IF (IKINDS(I).EQ.1) NKINDS=NKINDS+1
      ENDDO
      WRITE(IMOL,2) NATOM,NKINDS
      WRITE(IMOL,101) FSTR
 101  FORMAT(A40)
      CARBON = 0.3D+00
      DO I=1,92
        IF (IKINDS(I).EQ.1) THEN
                      SIZE=0.75D+00* CARBON
          IF(I.GT. 2) SIZE=          CARBON
          IF(I.GT.10) SIZE=1.6D+00 * CARBON
          IF(I.GT.18) SIZE=1.7D+00 * CARBON
          IF(I.GT.36) SIZE=1.9D+00 * CARBON
          IF(I.GT.54) SIZE=2.0D+00 * CARBON
          IF(I.GT.86) SIZE=2.1D+00 * CARBON
          WRITE(IMOL,3) ATMSYM(I),KOLORS(I),SIZE
        ENDIF
      ENDDO
      DO I=1,NATOM
        WRITE(IMOL,1) ATMSYM(NATNUM(I)), (XYZ(J,I),J=1,3)
      ENDDO
      CLOSE(IMOL)
      RETURN
 1    FORMAT(A2,3F12.7)
 2    FORMAT('NATOM=',I3,'   NKINDS=',I3)
 3    FORMAT(A2,I4,F4.1)
      END
      SUBROUTINE XYZFILE(XYZ,NATOM,NATNUM,TITLE)
      IMPLICIT NONE
      DOUBLE PRECISION XYZ(3,1000)
      INTEGER NATOM,NATNUM(1000)
      CHARACTER*40 TITLE
C
      INTEGER I,J
C
      CHARACTER*1 SYM
      INTEGER MAXCEN,MAXSHL,NF,KATOM,IMOL,MAXPRM
      DOUBLE PRECISION XEXP,COEFF
      PARAMETER (MAXSHL=500,MAXCEN=200,MAXPRM=15)
      COMMON /SEEING/ XEXP(MAXSHL,MAXPRM),COEFF(MAXSHL,MAXPRM)
     &,NF(MAXSHL),KATOM(MAXCEN),IMOL,SYM(MAXSHL)
C
      CHARACTER*2 ATMSYM
      COMMON /ATOMSY/ ATMSYM(92)
C
      WRITE(IMOL,'(I4)') NATOM
      WRITE(IMOL,'(A40)') TITLE
      DO I=1,NATOM
        WRITE(IMOL,1) ATMSYM(NATNUM(I)), (XYZ(J,I),J=1,3)
      ENDDO
      RETURN
 1    FORMAT(A2,3F12.7)
      END
      SUBROUTINE MOLEKEL(RWRK,IERR,LMOLK,NCCC)
C#######################################################################
C
C     Calculates MOLEKEL input as MKL file or MOLDEN input 
C     as MOLDEN format file.
C
C     See http://www.cmbi.ru.nl/molden/molden_format.html
C     for MOLDEN format
C
C#######################################################################
      IMPLICIT NONE
      DOUBLE PRECISION RWRK(*)
      INTEGER IERR,NCCC
      LOGICAL LMOLK
C
      DOUBLE PRECISION X,EIG(1000)
      INTEGER ITOTCH,I,J,MULTI,ICHARGE,NN,KK,K,IFIRST,ILAST
C
      CHARACTER*1 SYM
      INTEGER NF,KATOM,IMOL
      DOUBLE PRECISION XEXP,COEFF
      INTEGER MAXCEN,MAXSHL,MAXPRM,MAXBFN,NEXTRA,MAXEXT,MAXGRP
      PARAMETER (MAXSHL=500,MAXPRM=15,MAXBFN=726,MAXCEN=200)
      COMMON /SEEING/ XEXP(MAXSHL,MAXPRM),COEFF(MAXSHL,MAXPRM)
     &,NF(MAXSHL),KATOM(MAXCEN),IMOL,SYM(MAXSHL)
C
      INTEGER LENFIL,IOUTVB
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,INPFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
CGAU  INTEGER NUMD,NUMF
CGAU  COMMON /DORF/ NUMD,NUMF
C
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      INTEGER NATOM,NELE,NSPIN,NBASIS,NATNUM,NATBAS
      DOUBLE PRECISION ENREP,XYZ
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
C
      INTEGER NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,NVIR,
     &LPTALL,LHYBRD,MELE,MSPIN,MNORBIT,MLORBIT,MWIN,MSTR,METHOD,IBASIS,
     &NOCC,NOBIAS,NEPS,NOTROT,LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,
     &MBASIS,KEY
      PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA,MAXGRP=99)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,
     &LPTALL,LHYBRD,MELE(MAXGRP),MSPIN(MAXGRP),MNORBIT(MAXGRP),
     &MLORBIT(MAXGRP),MWIN(MAXGRP),MSTR(MAXGRP),METHOD(MAXGRP),
     &IBASIS(MAXEXT),NOCC(MAXEXT),NOBIAS,NEPS,NVIR,NOTROT(5000),
     &LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(MAXGRP)
C
      CHARACTER*2 ATMSYM
      COMMON /ATOMSY/ ATMSYM(92)
C
      IERR=0
      IF(LMOLK) THEN
        INPFILE=FSTR(1:LENFIL)//'.mkl'
      ELSE
        INPFILE=FSTR(1:LENFIL)//'.molf'
      ENDIF
      OPEN(UNIT=IMOL,FILE=INPFILE,STATUS='UNKNOWN',
     1  ACCESS='SEQUENTIAL',FORM='FORMATTED')
      IF(LMOLK) THEN
        WRITE(IMOL,'("$MKL")') 
C       COORD BLOCK
        WRITE(IMOL,'("$COORD")') 
        ITOTCH = 0
        DO I=1,NATOM
          WRITE(IMOL,4) NATNUM(I), (XYZ(J,I),J=1,3)
          ITOTCH = ITOTCH + NATNUM(I)
        ENDDO
        WRITE(IMOL,'("$END")')
C       CHAR_MULT BLOCK
        MULTI=NSPIN+1
        ICHARGE = ITOTCH - NELE
        WRITE(IMOL,105) '$CHAR_MULT'
        WRITE(IMOL,'(2I2)') ICHARGE,MULTI
        WRITE(IMOL,'("$END")')
C       BASIS BLOCK
        WRITE(IMOL,107) '$BASIS'
      ELSE
        WRITE(IMOL,'("[Molden Format]")')
C       COORD BLOCK
        WRITE(IMOL,'("[Atoms] Angs")')
        DO I=1,NATOM
          WRITE(IMOL,91) ATMSYM(NATNUM(I)), I, NATNUM(I), 
     &      (XYZ(J,I),J=1,3)
        ENDDO
CGAU    IF(NUMD.EQ.0.AND.NUMF.EQ.0) WRITE(IMOL,'("[5D]")')
CGAU    IF(NUMD.EQ.1.AND.NUMF.EQ.0) WRITE(IMOL,'("[7F]")')
CGAU    IF(NUMD.EQ.0.AND.NUMF.EQ.1) WRITE(IMOL,'("[5D10F]")')
C       BASIS BLOCK
        WRITE(IMOL,'("[GTO]")')
      ENDIF
C
C     GAUSSIAN AND GAMESS BASIS ROUTINES ARE IN vb2gau.src 
C     AND vb2gms.src.
C
      NN=0
      X=1.0D0
C     WRITE(IOUTVB,'(30(1X,A1))') (SYM(I),I=1,60)
C     WRITE(IOUTVB,'(10I4)') (KATOM(I),I=1,NATOM)
C     WRITE(IOUTVB,'(20I4)') (NF(I),I=1,60)
      DO I=1,NATOM
        IF(.NOT.LMOLK) WRITE(IMOL,'(I4)') I
        DO KK=1,KATOM(I)
          NN=NN+1
          IF (SYM(NN).EQ.'S') THEN
            K=1
            GOTO 11
          ENDIF
          IF (SYM(NN).EQ.'P') THEN
            K=3
            GOTO 11
          ENDIF
          IF (SYM(NN).EQ.'D') THEN
            K=6
CGAU        IF (NUMD.EQ.0) K=5
            GOTO 11
          ENDIF
          IF (SYM(NN).EQ.'F') THEN
            K=10
CGAU        IF (NUMF.EQ.0) K=7
            GOTO 11
          ENDIF
          IF (SYM(NN).EQ.'G') THEN
            K=15
CGAU        IF (NUMF.EQ.0) K=9
            GOTO 11
          ENDIF
          IF (SYM(NN).EQ.'H') THEN
            K=21
CGAU        IF (NUMF.EQ.0) K=11
            GOTO 11
          ENDIF
          IF (SYM(NN).EQ.'I') THEN
            K=28
CGAU        IF (NUMF.EQ.0) K=13
            GOTO 11
          ENDIF
C         MOLEKEL AND MOLDEN PROBABLY DO NOT GO TO I, BUT
C         THEY MAY IN FUTURE OR OTHER PROGRAMS MAY ACCEPT
C         THESE FORMATS,
          IF(LMOLK) THEN
            WRITE(IOUTVB,12) SYM(NN)
          ELSE
            WRITE(IOUTVB,10) SYM(NN)
          ENDIF
          IERR=1
          GOTO 1
 11       IF(LMOLK) THEN
            WRITE(IMOL,5) K, SYM(NN),X
          ELSE
            WRITE(IMOL,3) SYM(NN),NF(NN)
          ENDIF
          DO J=1,NF(NN)
            WRITE(IMOL,6) XEXP(NN,J),COEFF(NN,J)
          ENDDO
        ENDDO
        IF(LMOLK) THEN
          IF (I.ne.NATOM) WRITE(IMOL,108)
        ELSE
          WRITE(IMOL,*)
        ENDIF
      ENDDO
      DO I=1,NCCC
        EIG(I)=2.0D0
        IF(LTEST.NE.1.AND.IBASIS(I).GT.1) EIG(I)=1.0D0
      ENDDO
      IF(LMOLK) THEN
        WRITE(IMOL,'("$END")')
C       COEFF_ALPHA BLOCK
        WRITE(IMOL,'(A12)') '$COEFF_ALPHA'
        IFIRST=1
 14     ILAST=IFIRST+4
        IF(ILAST.GT.NCCC) ILAST=NCCC
        WRITE(IMOL,7) (IBASIS(J),J=IFIRST,ILAST)
        WRITE(IMOL,9) (EIG(J),J=IFIRST,ILAST)
        DO I=1,NBASIS
          WRITE(IMOL,8) (RWRK(I+(J-1)*NBASIS),J=IFIRST,ILAST)
        ENDDO
        IFIRST=IFIRST+5
        IF(ILAST.LT.NCCC) GOTO 14
        WRITE(IMOL,'("$END")')
C       OCC_ALPHA BLOCK
        WRITE(IMOL,109) '$OCC_ALPHA'
        WRITE(IMOL,9) (EIG(J),J=1,NCCC)
        WRITE(IMOL,'("$END")')
C       CHARGES BLOCK
C       Zero charges added just to prevent window popping up.
        WRITE(IMOL,110) '$CHARGES'
        DO I=1,NATOM
          WRITE(IMOL,111) 0.0
        ENDDO
        WRITE(IMOL,'("$END")')
      ELSE
        WRITE(IMOL,'("[MO]")')
        DO J=1,NCCC
          WRITE(IMOL,95) EIG(J)
          WRITE(IMOL,96)
          WRITE(IMOL,97) 1.0D0
          DO I=1,NBASIS
            WRITE(IMOL,98) I,RWRK(I+(J-1)*NBASIS)
          ENDDO
        ENDDO
      ENDIF
 1    CLOSE(IMOL)
      RETURN
 3    FORMAT(4X,A1,I6)
 4    FORMAT(I2,3F12.7)
 5    FORMAT(I2,4X,A1,F7.1)
 6    FORMAT(4X,3F20.10)
 7    FORMAT(5(I2,2X))
 8    FORMAT(5F10.5)
 9    FORMAT(5F5.1)
 10   FORMAT(' INCORRECT SYMBOL ',A1,/
     & ' ABORTING WRITING MOLDEN molf FILE.'/)
 12   FORMAT(' INCORRECT SYMBOL ',A1,/
     & ' ABORTING WRITING MOLEKEL mkl FILE.'/)
 91   FORMAT(A2,2I5,1X,3F20.10)
 95   FORMAT(" Ene= ",F12.4)
 96   FORMAT(" Spin= Alpha")
 97   FORMAT(" Occup= ",F10.6)
 98   FORMAT(I4,F16.11)
 105  FORMAT(A10)
 107  FORMAT(A6)
 108  FORMAT('$$')
 109  FORMAT(A10)
 110  FORMAT(A8)
 111  FORMAT(F8.5)
      END
      SUBROUTINE CUBE(C2,TITLE,NP,KVB,IPRM,LFIRST)
C#######################################################################
C
C     Calculates CUBE output - one per orbital.
C
C#######################################################################
      IMPLICIT NONE
      CHARACTER*40 TITLE
      INTEGER NP,KVB,IPRM
      LOGICAL LFIRST
C
      INTEGER I,J,N,K,I1,I2,I3,L,NVB,MAXCEN,MAXEXP,MAXBFN
      PARAMETER (MAXCEN=200,MAXEXP=1000,MAXBFN=726)
      DOUBLE PRECISION TOANG,ZERO,X,Y,Z,SUM,XNORM
      DOUBLE PRECISION C1(3,MAXCEN),XMIN(3),XMAX(3),XX(3),XORB(100)
      DOUBLE PRECISION C2(MAXEXP)
C
      DOUBLE PRECISION XE,C
      INTEGER IT,JT,KT,MT,MCT
      COMMON /CUBEC/ XE(MAXEXP),C(MAXEXP),IT(MAXEXP),JT(MAXEXP),
     & KT(MAXEXP),MT(MAXBFN),MCT(MAXBFN)
C
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      INTEGER IOUTVB,LENFIL
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
      CHARACTER*1 SYM
      INTEGER MAXSHL,NF,KATOM,IMOL,MAXPRM
      DOUBLE PRECISION XEXP,COEFF
      PARAMETER (MAXSHL=500,MAXPRM=15)
      COMMON /SEEING/ XEXP(MAXSHL,MAXPRM),COEFF(MAXSHL,MAXPRM)
     &,NF(MAXSHL),KATOM(MAXCEN),IMOL,SYM(MAXSHL)
C
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      INTEGER NATOM,NELE,NSPIN,NBASIS,NATNUM,NATBAS
      DOUBLE PRECISION ENREP,XYZ
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
C
      DOUBLE PRECISION ATMCHG
      COMMON /ATMCH/ ATMCHG(MAXCEN)
C
      DATA TOANG /0.529177249D0/
      DATA ZERO /0.0D00/
      IF (LFIRST) WRITE(IOUTVB,100)
      WRITE(IMOL,102) TITLE
      IF (LFIRST) WRITE(IOUTVB,102) TITLE
      WRITE(IMOL,103)
      IF (LFIRST) WRITE(IOUTVB,103)
C     THIS MAY BE NEEDED AS WE ARE FOOLING THE SYSTEM THAT
C     VB ORBITALS ARE THE SAME AS MO'S.
      DO I=1,NATOM
        DO J=1,3
          C1(J,I)=XYZ(J,I)/TOANG
        ENDDO
      ENDDO
      DO J=1,3
        XMIN(J)=1.0D8
        XMAX(J)=-1.0D8
        DO I=1,NATOM
          IF (C1(J,I).LT.XMIN(J)) XMIN(J)=C1(J,I)
          IF (C1(J,I).GT.XMAX(J)) XMAX(J)=C1(J,I)
        ENDDO
        XMAX(J)=XMAX(J)+6.0D0
        XMIN(J)=XMIN(J)-6.0D0
        XX(J) = (XMAX(J)-XMIN(J))/(NP-1)
      ENDDO
      N=-NATOM
      WRITE(IMOL,101) N,(XMIN(K),K=1,3)
      IF (LFIRST) WRITE(IOUTVB,101) N,(XMIN(K),K=1,3)
      WRITE(IMOL,101) NP,XX(1),ZERO,ZERO
      WRITE(IMOL,101) NP,ZERO,XX(2),ZERO
      WRITE(IMOL,101) NP,ZERO,ZERO,XX(3)
      IF (LFIRST) THEN
        WRITE(IOUTVB,101) NP,XX(1),ZERO,ZERO
        WRITE(IOUTVB,101) NP,ZERO,XX(2),ZERO
        WRITE(IOUTVB,101) NP,ZERO,ZERO,XX(3)
      ENDIF
      DO I=1,NATOM
        WRITE(IMOL,101) NATNUM(I),ATMCHG(I),(C1(J,I),J=1,3)
        IF (LFIRST) WRITE(IOUTVB,101) NATNUM(I),
     &    ATMCHG(I),(C1(J,I),J=1,3)
      ENDDO
      NVB = 1
      WRITE(IMOL,104) NVB,KVB
      IF (LFIRST) WRITE(IOUTVB,104) NVB,KVB
      IF (LFIRST) WRITE(IOUTVB,*) 
C
      XNORM=0.0D0
      DO I1=1,NP
        X=XMIN(1) + (I1-1)*XX(1)
        DO I2=1,NP
          Y=XMIN(2) + (I2-1)*XX(2)
          DO I3=1,NP
            Z=XMIN(3) + (I3-1)*XX(3)
            SUM = 0.0D0
C000        CALL ORBPT(SUM,C1,C2,XE,X,Y,Z,JT,IT,1,IPRM)
CGMS        CALL ORBPTM(SUM,C1,C2,XE,X,Y,Z,JT,IT,1,IPRM)
CGAU        CALL ORBPTG(SUM,C1,C2,XE,X,Y,Z,JT,IT,1,IPRM)
            XORB(I3) = SUM
C           SUM ORBITAL NORMALIZATION
            XNORM=XNORM+SUM*SUM
          ENDDO
          WRITE(IMOL,105) (XORB(L),L=1,NP)
        ENDDO
      ENDDO
C     Calculates normalisation of VB orbital from CUBE points
      XNORM = XNORM * (XX(1) * XX(2) * XX(3))
      WRITE(IOUTVB,
     & '(/," NORMALIZATION OF ORBITAL",I3," IS:",F12.6)') KVB,XNORM
      IF (ABS(XNORM-1.0D0).GT.2.0D-2) WRITE(IOUTVB,
     &'(" NORMALIZATION SUGGESTS YOU NEED MORE CUBE POINTS,",/
     &  " BUT VALUE WITH INNER CORE ELECTRONS CAN BE TOO LOW.")')
      RETURN
 100  FORMAT(/," CUBE FILE HEADERS",/)
 101  FORMAT(I4,4F12.6)
 102  FORMAT(1X,A40)
 103  FORMAT(' SCF Molecular Orbitals')
 104  FORMAT(10I4)
 105  FORMAT(6E13.5)
      END
      SUBROUTINE GENGRID(C2,TITLE,NP,IGRD,KVB,IPRM)
C#######################################################################
C
C     Calculates DSV GRID output - one per orbital.
C
C#######################################################################
      IMPLICIT NONE
      CHARACTER*40 TITLE
      INTEGER KVB,NP,IGRD,IPRM
C
      INTEGER NPX,NPY,NPZ,IXMIN,IYMIN,IZMIN,I,J,I1,I2,I3,
     & MAXCEN,MAXEXP,MAXBFN
      PARAMETER (MAXCEN=200,MAXEXP=1000,MAXBFN=726)
      DOUBLE PRECISION XL,YL,ZL,HALFPI,GRIDSIZE,GRIDX,XMIN0,YMIN0,
     &ZMIN0,XNORM,TOANG,X,Y,Z,SUM,C1(3,MAXCEN),XMIN(3),XMAX(3)
      DOUBLE PRECISION C2(MAXEXP)
C
      DOUBLE PRECISION XE,C
      INTEGER IT,JT,KT,MT,MCT
      COMMON /CUBEC/ XE(MAXEXP),C(MAXEXP),IT(MAXEXP),JT(MAXEXP),
     & KT(MAXEXP),MT(MAXBFN),MCT(MAXBFN)
C
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      INTEGER IOUTVB,LENFIL
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      INTEGER NATOM,NELE,NSPIN,NBASIS,NATNUM,NATBAS
      DOUBLE PRECISION ENREP,XYZ
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
C
      DATA TOANG /0.529177249D0/
      GRIDSIZE = 8.0D0/NP
      HALFPI = 90.0D0
      WRITE(IGRD,'(A40)')TITLE
      DO I=1,NATOM
        DO J=1,3
          C1(J,I)=XYZ(J,I)/TOANG
        ENDDO
      ENDDO
      DO J=1,3
        XMIN(J)=1.0D8
        XMAX(J)=-1.0D8
        DO I=1,NATOM
          IF (C1(J,I).LT.XMIN(J)) XMIN(J)=C1(J,I)
          IF (C1(J,I).GT.XMAX(J)) XMAX(J)=C1(J,I)
        ENDDO
        XMAX(J)=XMAX(J)+6.0D0
        XMIN(J)=XMIN(J)-6.0D0
      ENDDO
      XL = (XMAX(1) - XMIN(1))*TOANG
      YL = (XMAX(2) - XMIN(2))*TOANG
      ZL = (XMAX(3) - XMIN(3))*TOANG
      NPX = 1+INT(XL/GRIDSIZE)
      NPY = 1+INT(YL/GRIDSIZE)
      NPZ = 1+INT(ZL/GRIDSIZE)
      IXMIN = INT((TOANG*XMIN(1))/GRIDSIZE)
      IYMIN = INT((TOANG*XMIN(2))/GRIDSIZE)
      IZMIN = INT((TOANG*XMIN(3))/GRIDSIZE)
      GRIDX = GRIDSIZE/TOANG
      XMIN0 = IXMIN*GRIDX
      YMIN0 = IYMIN*GRIDX
      ZMIN0 = IZMIN*GRIDX
C
C     WRITE HEADER
C
      WRITE(IGRD,'("(1F15.10)")')
      WRITE(IGRD,'(6F8.3)')XL,YL,ZL,HALFPI,HALFPI,HALFPI
      WRITE(IGRD,'(3I5)')NPX-1,NPY-1,NPZ-1
      WRITE(IGRD,'(7I5)')1,IXMIN,0,IYMIN,0,IZMIN,0
C
      XNORM = 0.0D0
      DO I1=1,NPZ
        Z=ZMIN0 + (I1-1)*GRIDX
        DO I2=1,NPY
          Y=YMIN0 + (I2-1)*GRIDX
          DO I3=1,NPX
            X=XMIN0 + (I3-1)*GRIDX
            SUM = 0.0D0
C000        CALL ORBPT(SUM,C1,C2,XE,X,Y,Z,JT,IT,1,IPRM)
CGMS        CALL ORBPTM(SUM,C1,C2,XE,X,Y,Z,JT,IT,1,IPRM)
CGAU        CALL ORBPTG(SUM,C1,C2,XE,X,Y,Z,JT,IT,1,IPRM)
            XNORM=XNORM+SUM*SUM
            IF(SUM .GT. 9.9D0) SUM = 9.9D0
            IF(SUM .LT. -9.9D0) SUM =-9.9D0
C           WRITE(IGRD,'(F6.3)') SUM
            WRITE(IGRD,'(F9.6)') SUM
          ENDDO
        ENDDO
      ENDDO
C     Calculates normalisation of VB orbital from CUBE points
      XNORM = XNORM * GRIDX**3
      WRITE(IOUTVB,
     & '(/," NORMALIZATION OF ORBITAL",I3," IS:",F12.6)') KVB,XNORM
      IF (ABS(XNORM-1.0D0).GT.2.0D-2) WRITE(IOUTVB,
     &'(" NORMALIZATION SUGGESTS YOU NEED MORE GRID POINTS,",/
     &  " BUT VALUE WITH INNER CORE ELECTRONS CAN BE FAR FROM 1.00.")')
      RETURN
      END
      DOUBLE PRECISION FUNCTION VBRAND(I)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      SAVE RSEED
      IF(I.NE.0) RSEED = I
C     IF(ABS(RSEED) .LT. 0.001) RSEED = 1.0D0
      IF(ABS(RSEED) .LT. 0.1D0) RSEED = RSEED + 0.5D0
      TEMP    = ABS(SIN(RSEED*100.0D0))
      ITEMP   = INT(TEMP*1.0D7)
      RSEED   = TEMP*1.0D7-ITEMP
      VBRAND  = RSEED
      RETURN
      END
      DOUBLE PRECISION FUNCTION XCLOCK()
      IMPLICIT NONE
C     Getting CPU time can also be machine dependant.
C 000  REAL*4 TARRAY(2)
C 000  REAL*4 TIME
CSMI  REAL*4 TARRAY(2)
C GAU  REAL*4 TARRAY(2)
C GAU  REAL*4 TIME
      DOUBLE PRECISION TIM
C
C     CPU_TIME IS PART OF THE FORTRAN STANDARD FROM FORTRAN95, UNLIKE
C     ETIME. IT IS SUPPORTED BY GFORTRAN AND IFORT. IF IT DOES NOT
C     WORK, TRY ETIME.
C000  CALL CPU_TIME(TIM)
C000  XCLOCK = TIM
CGAU  CALL CPU_TIME(TIM)
CGAU  XCLOCK = TIM
C
C     Use TSECND from GAMESS UNPORT, so all machine dependent stuff
C     is handled there.
CGMS  CALL TSECND(TIM)
CGMS  XCLOCK = TIM
C
C     ETIME exists on most, but not all systems.
C
C 000  TARRAY(1) = 0.0
C 000  TARRAY(2) = 0.0
C 000  XCLOCK = ETIME(TARRAY)
C 000  XCLOCK = DBLE(TARRAY(1) + TARRAY(2))
C 000  CALL ETIME(TARRAY,TIME)
C 000  XCLOCK = DBLE(TIME)
C
CSMI  TARRAY(1) = 0.0
CSMI  TARRAY(2) = 0.0
CSMI  XCLOCK = ETIME(TARRAY)
CSMI  XCLOCK = DBLE(TARRAY(1) + TARRAY(2))
C
C     This was for SALFORD compiler.
C     It was not well tested and is probably of no value now (Jan 2013)
C     CALL CLOCK@(X)
C     XCLOCK = X
C     Earlier we used MCLOCK, but this needs different scaling factors
C     on different systems, as seen below.
C     linux g77  XCLOCK=MCLOCK()/1000000.0D0
C     Other unix  XCLOCK=MCLOCK()/100.0D0
C     Cygwin g77  XCLOCK=MCLOCK()/1000.0D0
C     Intel 1.6 ifc  XCLOCK=MCLOCK()/100.0D0
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     FUNCTION: DATA STOREAGE UTILITY
C               IT IS USED FOR ANY DATA STOREAGE. THE DATA HAS A DYNAMIC RANGE
C               AND THE DATA NEED TO BE SHARED BY DIFFERENT PARTS OF THE PROGRAM
C               IN THE CURRENT IMPLEMENTATION, EACH DATA RECORD IS STORED ON
C               A DIFFERENT FILE, AND THE DATA CAN BE READ AND WRITTEN.
C
C     NOTES:
C               IDATYP: DATA TYPE. 0=DOUBLE, 1=INTEGER
C               IRWTYP: READ/WRITE FLAG. 0=READ, 1=WRITE
C               ISIZE:  DATA ARRAY SIZE.
C               IDREC:  DATA RECORD ID.
C               INTDAT: INTEGER ARRAY.
C               DBLDAT: DOUBLE ARRAY.
C
C               THE IOTEMP UNIT IS USED. IT IS ASSUMED THAT THIS IO UNIT
C               WILL BE OPENED AND CLOSED IN THIS SUBROUTINE.
C
C     HISTORY:
C               First created: April 29, 2006
C
C     AUTHOR:
C               Jiabo Li
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE DSTORE(IDATYP, IRWTYP, ISIZE, IDREC, INTDAT, DBLDAT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION INTDAT(*),DBLDAT(*)
      CHARACTER*80 FILENAME
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      CALL GETIOUNIT('IOTEMP  ',IOTEMP)
C
C     IDREC = 1, SPIN-DENSITY
C     IDREC = 2, ANY THING ELSE
C     ........
C
      IF(IDREC.LT.1.OR.IDREC.GT.5) CALL ABORT0("DSTORE0001")
      IF(IDREC.EQ.2) FILENAME=FSTR(1:LENFIL)//'.TEMP02'
      IF(IDREC.EQ.3) FILENAME=FSTR(1:LENFIL)//'.TEMP03'
      IF(IDREC.EQ.4) FILENAME=FSTR(1:LENFIL)//'.TEMP04'
      IF(IDREC.EQ.5) FILENAME=FSTR(1:LENFIL)//'.TEMP05'
      IF(IDREC.EQ.6) FILENAME=FSTR(1:LENFIL)//'.TEMP06'
      IF(IDREC.EQ.7) FILENAME=FSTR(1:LENFIL)//'.TEMP07'
      IF(IDREC.EQ.8) FILENAME=FSTR(1:LENFIL)//'.TEMP08'
      IF(IDREC.EQ.9) FILENAME=FSTR(1:LENFIL)//'.TEMP09'
      OPEN(UNIT=IOTEMP, FILE=FILENAME, STATUS="UNKNOWN",
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      IF(IRWTYP.EQ.0.AND.IDATYP.EQ.0) THEN
         READ(IOTEMP)(DBLDAT(I),I=1,ISIZE)
      ELSE IF(IRWTYP.EQ.1.AND.IDATYP.EQ.0) THEN
         WRITE(IOTEMP)(DBLDAT(I),I=1,ISIZE)
      ELSE IF(IRWTYP.EQ.0.AND.IDATYP.EQ.1) THEN
         READ(IOTEMP)(INTDAT(I),I=1,ISIZE)
      ELSE IF(IRWTYP.EQ.1.AND.IDATYP.EQ.1) THEN
         WRITE(IOTEMP)(INTDAT(I),I=1,ISIZE)
      ELSE
         WRITE(IOUTVB,*)"UNKNOWN DATA TYPE AND READ/WRITE FLAG"
         CALL ABORT0("DSTORE0002")
      END IF
      CLOSE(IOTEMP)
      RETURN
      END
      SUBROUTINE SPDEN(N,NS,NSTR,S,NORB,NVBSTR,CSTR,SDMATR)
      IMPLICIT REAL*8 (A-H,O-Z)
      COMMON /NFACT/NFAC0(20),NFACX(20)
      DIMENSION NA(20),NB(20),NGRAPH(3,40),NG2(40),NG3(40)
      DIMENSION S(*),NVBSTR(N,NSTR),CSTR(NSTR)
      DIMENSION SDMATR(*)
      IF(NORB*(NORB+1)/2.GT.33334) CALL ABORT0("SPDEN00001")
      DO I=1, NORB*(NORB+1)/2
         SDMATR(I) = 0.0D0
      END DO
      CALL PERINI(N)
      DO I=1, 20
      NA(I) = I
      END DO
      SUM = 0.0D0
      SDSUM = 0.0D0
      N10 = N
      IF(N .GT. 10) THEN
         N10 = 10
      END IF
      NFAC10 = 1
      DO I=11, N
      NFAC10 = NFAC10*I
      END DO
      DO IDX0=1,NFAC10
      DO IDX=1,NFACX(N10)
        DO I=1, N
          NB(I) = I
        END DO
        CALL PERGEN0(N,IDX0,IDX,NB)
        CALL DLAMD0(N,NS,NA,NB,D11,NGRAPH)
        DO I=1, N
           NG2(I) = NGRAPH(2,NB(I))
           NG3(I) = NGRAPH(3,NB(I))
        END DO

C
C       LOOP STRUCTURE PAIRS
C
        DO IA=1, NSTR
        DO IB=1, IA
          PROD = D11*CSTR(IA)*CSTR(IB)
          IF(IA.NE.IB) PROD = PROD+PROD
          DO K=1,N
          NAK = NVBSTR(K,IA)
          NBK = NVBSTR(NB(K),IB)
            IF(NAK.GE.NBK) THEN
              NABK = NAK*(NAK-1)/2+NBK
            ELSE
              NABK = NBK*(NBK-1)/2+NAK
            END IF
            PROD = PROD*S(NABK)
          END DO
          SUM = SUM + PROD
          DO K=1, N
            IF(NG2(K).EQ.1) THEN
              SDSUM = SDSUM + PROD*NG3(K)
            END IF
          END DO
          DO K=1,N
          NAK = NVBSTR(K,IA)
          NBK = NVBSTR(NB(K),IB)
            IF(NAK.GE.NBK) THEN
              NABK = NAK*(NAK-1)/2+NBK
            ELSE
              NABK = NBK*(NBK-1)/2+NAK
            END IF
C
C           IF(NG2(K).EQ.0) THEN THEN D11 IS ZERO, THUS NO CONTRIBUTION
C
            IF(ABS(S(NABK)).GT.0.00000001D0.AND.NG2(K).EQ.1) THEN
              SDMATR(NABK) = SDMATR(NABK) + NG3(K)*PROD/S(NABK)
            END IF
          END DO
        END DO
        END DO
C
      END DO
      END DO
      SDSUM = SDSUM/SUM
      SDSUM = 0.0D0
      DO I=1, NORB
        DO J=1, I
        IJ=I*(I-1)/2+J
        SDSUM = SDSUM + SDMATR(IJ)*S(IJ)
C
C       DEFACTOR
C
        IF(I.NE.J) SDMATR(IJ) = SDMATR(IJ)*0.5D0
        END DO
      END DO
      SDSUM = SDSUM/SUM
      RETURN
      END
      SUBROUTINE PERINI(N)
      COMMON /NFACT/NFAC0(20),NFAC(20)
      IF(N.GT.20) CALL ABORT0("PERINI0001")
      NFAC(1) = 1
      DO I=2, 12
      NFAC(I) = NFAC(I-1)*I
      END DO
      NFAC0(10) = 1
      DO I=11,16
      NFAC0(I) = I*NFAC0(I-1)
      END DO
      RETURN
      END
      SUBROUTINE PERGEN0(N,IDX0,IDX1,NPER)
      COMMON /NFACT/NFAC0(20),NFACX(20)
      DIMENSION NPER(*), NP(20)
      N0 = 0
      IF(N.GT.10) N0 = N-10
      NREM = IDX0
      DO I=1, N0
        NP(I) = (NREM-1)/NFAC0(N-I) + 1
        NREM  = NREM - NFAC0(N-I)*(NP(I)-1)
      END DO
      NREM = IDX1
      DO I=N0+1, N-1
        NP(I) = (NREM-1)/NFACX(N-I) + 1
        NREM  = NREM - NFACX(N-I)*(NP(I)-1)
      END DO
        NP(N) = NREM
      DO I=1, N
        NTMP = NPER(I)
        NPER(I) = NPER(I-1+NP(I))
        NPER(I-1+NP(I)) = NTMP
      END DO
      RETURN
      END
      SUBROUTINE DLAMD0(N,K,MA,MB,D11,NGRAPH)
C
C     This is subroutine to calculation the overlap of two Rumber
C     patterns. N: number of indexes. K: number of unpaired indexes.
C     MA, MB: Rumer patterns. The paired indexes come first, followed
C     by unpaired indexes.
C
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER (NOR=40)
      DIMENSION MA(N),MB(N),IA(60),IB(60),NA(60),NB(60),NPART(NOR)
      DATA NPART/2,1,4,3,6,5,8,7,10,9,12,11,14,13,16,15,18,17,20,19
     &,22,21,24,23,26,25,28,27,30,29,32,31,34,33,36,35,38,37,40,39/
      DIMENSION NTEMP(NOR)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      NFRAG=0
      NSIZE=0
      FACTOR = 1.0D0
      M=(N-K)/2
      L=M+K
      L2=L*2
      LOOPS1=0
      LOOPS2=0
      NCC=0
      DO 100 I=1,K
      NA(I+I-1)=MA(N-K+I)
      NB(I+I-1)=MB(N-K+I)
      NA(I+I)  =NOR+I
      NB(I+I)  =NOR+I
      IA(NA(I+I-1))=I+I-1
      IB(NB(I+I-1))=I+I-1
      IA(NA(I+I))  =I+I
  100 IB(NB(I+I))  =I+I
      DO 110 I=K+1,N
      NA(K+I)=MA(I-K)
      NB(K+I)=MB(I-K)
      IA(NA(K+I))=K+I
  110 IB(NB(K+I))=K+I
 200  CONTINUE
      DO 300 I=1,L2
      IF(NA(I).EQ.0) GOTO 300
      NI=NA(I)
      NT=NA(I)
      GOTO 400
 300  CONTINUE
      GOTO 900
 400  CONTINUE
      ILEFT=0
      IRIGHT=0
 500  CONTINUE
      NCC=NCC+1
      IF(NT.GT.NOR)ILEFT=1
      NSIZE=NSIZE+1
      NTEMP(NSIZE)=NA(IA(NT))
      NA(IA(NT))=0
      NPIANT=NPART(IA(NT))
      NTA=NA(NPIANT)
      IF(NTA.GT.NOR) IRIGHT=1
          IF(ILEFT*IRIGHT.NE.0) THEN
          D11=0.0D0
          FACTOR=0.0D0
C         RETURN
          END IF
      NSIZE=NSIZE+1
      NTEMP(NSIZE)=NA(NPIANT)
      NA(NPIANT)=0
      IBA=IB(NTA)
      NT=NB(NPART(IBA))
      IF(NT.EQ.0.OR.NCC.GT.100) THEN
      WRITE(IOUTVB,*)'WRONG DATA IN DLAMBDA ROUTINE'
      WRITE(IOUTVB,*)MA
      WRITE(IOUTVB,*)MB
      CALL ABRTVB
      END IF
      IF(NT.EQ.NI) THEN
            IF(ILEFT+IRIGHT.GT.0) THEN
            CALL FINDALLGRAPH(NFRAG,NTEMP,NSIZE,NGRAPH)
            LOOPS2=LOOPS2+1
            NSIZE=0
            ELSE
            LOOPS1=LOOPS1+1
            CALL FINDALLGRAPH(NFRAG,NTEMP,NSIZE,NGRAPH)
            NSIZE=0
            END IF
      GOTO 200
      ELSE
      GOTO 500
      END IF
 900  CONTINUE
      D11=FACTOR*(-1)**(LOOPS2+LOOPS1+L)/(2.0D0)**(M-LOOPS1)
      RETURN
      END
C
C     NFRAG: INDEX OF GRPAH
C     IFAC:  PARITY FACTOR
C     IEO:   EVEN-ODD INDEX. 0=EVEN, 1= ODD, 2=ISLAND
C

      SUBROUTINE FINDALLGRAPH(NFRAG,NTEMP,NSIZE,NGRAPH)
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER (NOR=40)
      DIMENSION NTEMP(*),NGRAPH(3,*),NA(40)
      NCT=0
      NA(1) = 0
C
C     SCANE NTEMP
C
      ICHAIN=0
      DO I=1, NSIZE
        IF(NTEMP(I).GT.NOR) THEN
        ICHAIN=1
        END IF
      END DO
C     WRITE(IOUTVB,*)"NSIZE, ICHAIN =",NSIZE,ICHAIN
      IF(ICHAIN.EQ.0) THEN
        NFRAG = NFRAG + 1
        DO I=1, NSIZE
        NGRAPH(1,NTEMP(I)) = NFRAG
        NGRAPH(2,NTEMP(I)) = 2
        NGRAPH(3,NTEMP(I)) = 0
        END DO
        RETURN
      END IF
 100  IF(NTEMP(1).LE.NOR) THEN
      NCT=NCT+1
        NX = NTEMP(1)
        DO I=2,NSIZE
        NTEMP(I-1) = NTEMP(I)
        END DO
        NTEMP(NSIZE)=NX
      END IF
      IF(NTEMP(1).LE.NOR.AND.NCT.LT.NSIZE) GOTO 100
C
C     CUT
C
      NX = 0
      DO I=1, NSIZE
        IF(NTEMP(I).GT.NOR)  THEN
            IF(NX.GT.0) THEN
              IEO = NX-2*(NX/2)
              IFAC = -1
              DO J=1, NX
                IFAC=-IFAC
                NGRAPH(1,NA(J)) = NFRAG
                NGRAPH(2,NA(J)) = IEO
                NGRAPH(3,NA(J)) = IFAC
              END DO
            END IF
          NFRAG=NFRAG+1
          NX = 0
        ELSE IF(NTEMP(I).LE.NOR) THEN
          NX = NX+1
          NA(NX) = NTEMP(I)
        END IF
      END DO
      IF(NX.GT.0) THEN
        IEO = NX-2*(NX/2)
        IFAC = -1
        DO J=1, NX
           IFAC=-IFAC
           NGRAPH(1,NA(J)) = NFRAG
           NGRAPH(2,NA(J)) = IEO
           NGRAPH(3,NA(J)) = IFAC
        END DO
      END IF
      RETURN
      END
      SUBROUTINE SPDATM(SDM,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE,DENFILE
      LOGICAL LDENS,LTOT,LGRP,LSD
      COMMON /DCUBE/ IDENS,LDENS,LTOT,LGRP,LSD,DENFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
CGMS  COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      PARAMETER (MAXCEN=200,MAXBFN=726)
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
      DIMENSION SDM(*),W(*),SDATOM(MAXCEN),NBAS2A(4000)
      MT = NBASIS
      MMS = 1
      MMH = MMS + NBASIS*(NBASIS+1)/2
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      CALL READ1E(IAO1E,W(MMS),W(MMH),MT)
      DO I=1, NATOM
        SDATOM(I) = 0.0D0
      END DO
      IC = 0
      DO I=1, NATOM
        DO J=1, NATBAS(I)
        IC = IC + 1
        NBAS2A(IC) = I
        END DO
      END DO
      IC = 0
      DO I=1, NBASIS
        II = NBAS2A(I)
        DO J=1, I
        JJ = NBAS2A(J)
        FACTOR = 1.0D0
        IF(I.EQ.J) FACTOR = 0.5D0
        IC = IC + 1
        SDATOM(II) = SDATOM(II) + SDM(IC)*W(MMS-1+IC)*FACTOR
        SDATOM(JJ) = SDATOM(JJ) + SDM(IC)*W(MMS-1+IC)*FACTOR
        END DO
      END DO
      IF (LSD) THEN
        OPEN(UNIT=IDENS,FILE=DENFILE,STATUS='UNKNOWN',
     &    FORM='UNFORMATTED')
        WRITE(IDENS) (SDM(I),I=1,IC)
        CLOSE(IDENS)
      ENDIF
CGMS  CALL DAWRIT(IDAF,IODA,SDM(1),IC,20,0)
C GAU  CALL FILEIO(1,-530,IC,SDM(1),0)
C
C     WRITE SDM TO A TEMP FILE
C
C     IDATYP= 0
C     IRWTYP= 1
C     ISIZE = NBASIS*(NBASIS+1)/2
C     IDREC = 1
C     CALL DSTORE(IDATYP, IRWTYP, ISIZE, IDREC, INTDAT, SDM)
      WRITE(IOUTVB,1000)
      WRITE(IOUTVB,1100)
      SDSUM = 0.0D0
      DO I=1, NATOM
      SDSUM = SDSUM + SDATOM(I)
      WRITE(IOUTVB,1200)I,SDATOM(I)
      END DO
      WRITE(IOUTVB,*)
      WRITE(IOUTVB,1300)
 1000 FORMAT(/1X,"SPIN DENSITY ON ATOMS",/1X,"---------------------")
 1100 FORMAT(1X,"ATOM      DENSITY",/)
 1200 FORMAT(1X,I4,1X,F12.5)
 1300 FORMAT(1X,"---------------------",/)
      RETURN
      END
C
C     COMPUTE DELOCALIZATION PENALTY CONTRIBUTION TO DERIVATIVES
C     VBSCF PART
C
C     VBOS: VB ORBITALS
C     NBRIL: VBSCF PARAMETERS
C     INDX:  BRILL TABLE
C     MGRP:  GROUP INDEX
C     SXBAR: SX_BAR
C     DEV:   DERIVATIVES OF DELOCALIZATION
C     HESS:  HESSIAN OF DELOCALIZATION
C     LOCATM(I): LOCALIZATION ATOM OF ORBITAL I
C                = 0. NO LOCALIZATION
C                = X. NUMBER OF ATOMS THAT ORBITAL I LOCALIZED ON.
C
C                THIS TABLE CAN BE READ IN OR DETECTED AUTOMATICALLY
C
C     History: First created in May 2007
C              Jiabo Li
C
C
      SUBROUTINE DPENALTY1(VBOS,NORB,S,NBRIL,INDX,MGRP,SXBAR,DEV,HESS,
     &                     LASTITER,ICONV,MITER,TDELOCAL,ITER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*8  BONDLAB
      CHARACTER*80 FLAG
      PARAMETER (MAXBRIL= 10000)
      PARAMETER (MAXMSK = 10000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      PARAMETER (MAXCEN=200,MAXBFN=726)
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
      COMMON /DPENAL/DPW,DEPS,DPWMAX,DENERGY,NITER,MAXMICRO
      PARAMETER (MAXNAB=MAXCEN*MAXBFN/2,MAXBF2=MAXBFN*MAXBFN)
      COMMON /LMODAT/VMO(MAXBF2),VLMO(MAXBF2),LMOLAB(2,MAXBFN),
     &LMOATM(5,MAXBFN),PGM(MAXNAB),ENGLMO(MAXBFN),BONDLAB(MAXBFN),
     &MCLMO(5,80),LHFLAG
      DIMENSION VBOS(NBASIS,*),S(*),INDX(2,*),DEV(*),HESS(*)
      DIMENSION SXBAR(*),NAOATM(2000)
      DIMENSION LOCATM(MAXBFN),DEVT(MAXBRIL),LAMASK(MAXMSK)
C               ,MASK(1000)
      DIMENSION LMASK(MAXBFN),ITEMP(MAXCEN),SN(MAXBFN)
      DIMENSION LMOALIST(10000),LATMS(1000)
      IF(NBRIL.GT.MAXBRIL) CALL ABORT0("DPENALTY0A")
      IF(NORB*NATOM.GT.MAXMSK) CALL ABORT0("DPENALTY1A")
      IF(NORB.GT.MAXBFN) CALL ABORT0("DPENALTY2A")
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      WSTART = 10.0D+10
      WDX    = 0.1D0
      TDELOCAL = 0.0D0
      CALL LOCTOR(IOENGI,'$WSTART',7,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*,ERR=101)WSTART
      IF(MITER.EQ.1) THEN
        DPW     = WSTART
        NITER   = 0
        MAXMICRO= 100
        DENERGY = 1.0D0
      ENDIF
      DO I=1, NORB
         LOCATM(I)=0
         II = (I-1)*NATOM
         DO J=1, NATOM
           LAMASK(II+J) = 0
         END DO
         SN(I) = 1.0D0
      END DO
C
C     THIS ASSUMES THAT ONLY ONE GROUP FOR THE WHOLE MOL
C
 1002 FORMAT(" ",20I4)
      IF(LHFLAG.GE.1) THEN
      CALL LMOATMLIST(LHFLAG,NORB,LMOATM,LMOALIST,LATMS)
        IF(ITER.EQ.1.AND.MITER.EQ.1) WRITE(IOUTVB,*)"  LENHANCE"
        IF(ITER.EQ.1.AND.MITER.EQ.1) WRITE(IOUTVB,1002)NORB
        DO I=1, NORB
         IF(MITER.EQ.1.AND.ITER.EQ.1) THEN
           WRITE(IOUTVB,1002)I,LMOATM(5,I),(LMOATM(K,I),K=1,LMOATM(5,I))
         END IF
C        LOCATM(I)=LMOATM(5,I)
         LOCATM(I)=LATMS(I+1)-LATMS(I)
         II = (I-1)*NATOM
C        DO J=1, 4
C          JJ = LMOATM(J,I)
         DO J=LATMS(I),LATMS(I+1)-1
           JJ = LMOALIST(J)
           IF(JJ.GT.0) LAMASK(II+JJ) = 1
         END DO
C        WRITE(IOUTVB,*)"LATOM =",LOCATM(I)
C        WRITE(IOUTVB,'(10I5)')(LAMASK(II+J),J=1,NATOM)
        END DO
      ENDIF
C
C     COMPUTE NORMALIZATION
C
      FLAG     = '$'
      WRITE(FLAG(2:3),'(I2.2)') MGRP
      FLAG(4:11)='LENHANCE'
      NADD=1
C     NBA2=NBASIS*(NBASIS+1)/2
      DO I=1, NATOM
        DO J=1, NATBAS(I)
        NAOATM(NADD) = I
        NADD= NADD+1
        END DO
      END DO
C
C     READ PARAMETERS OF VB STRUCTURES
C
      CALL LOCTOR(IOENGI,'$DPWEIGHT',9,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*,ERR=101)WDX
      CALL LOCTOR(IOENGI,FLAG,11,IOK,0)
      IF(IOK.EQ.1.OR.LHFLAG.GE.1) THEN
C
C     NEW FORMULA FOR DYNAMIC ADJUSTING OF WD
C
       IF(MITER.EQ.1.AND.ITER.EQ.1) THEN
        WRITE(IOUTVB,'(" $DPWEIGHT IS ",D20.3,/)') WDX
       ENDIF
       WD = DPW + 0.1D0*NITER*DPW
       IF(NITER.GT.10) WD = DPW + DPW
       IF(WDX .LT. WD) WD = WDX
C
      ENDIF
      IF(IOK.EQ.1) THEN
      READ(IOENGI,*,ERR=101) LVBO
       IF(MITER.EQ.1.AND.ITER.EQ.1) THEN
       WRITE(IOUTVB,'(" $LENHANCE APPLIES WITH",I4," CONDITIONS")') LVBO
       ENDIF
       DO I=1, LVBO
        READ(IOENGI,*,ERR=101)IVBO,LATM,(ITEMP(J),J=1,LATM)
        LOCATM(IVBO) = LATM
        II = (IVBO-1)*NATOM
        DO J=1, LATM
           LAMASK(II+ITEMP(J)) = 1
        END DO
       END DO
      ELSE IF(LHFLAG.LT.1) THEN
       RETURN
      END IF
C
C     COMPUTE DELOCALIZATION
C
      IF(LASTITER.EQ.1.AND.ICONV.EQ.1) THEN
       WRITE(IOUTVB,*)
         WRITE(IOUTVB,1000)MGRP
         WRITE(IOUTVB,1001)
      ENDIF
       DO IX=1, NORB
         IF(LOCATM(IX).GT.0) THEN
         IXX = (IX-1)*NATOM
         DO J=1, NBASIS
            LMASK(J) = 0
            IF(LAMASK(IXX+NAOATM(J)).EQ.0) LMASK(J) = 1
         END DO
         JK = 0
         DO J=1,NBASIS
           JJ = J*(J-1)/2
           DO K=1,J
           JK=JK+1
           SXBAR(JK)=S(JK)*LMASK(J)*LMASK(K)
           IF(NAOATM(J).NE.NAOATM(K)) SXBAR(JK) = 0.0D0
C          Use only diagonal elements
C          IF(J.NE.K) SXBAR(JK) = 0.0D0
           END DO
         END DO
         CALL SPROD(NBASIS, VBOS(1,IX),SXBAR,VBOS(1,IX),DELOCAL)
         TDELOCAL = TDELOCAL + DELOCAL*WD
         IF(LASTITER.EQ.1.AND.ICONV.EQ.1) THEN
         WRITE(IOUTVB,'(" VBO INDEX =",I3, " DELOCALIZATION =", F10.5)')
     &             IX,DELOCAL
         END IF
        END IF
       END DO
 1000 FORMAT(" DELOCALIZATION FOR VB ORBITALS OF GROUP ",I2)
 1001 FORMAT(" =============================================")
C
      DO I=1, NBRIL
        IX = INDX(1,I)
        IK = INDX(2,I)
        IF(LOCATM(IX).EQ.0) THEN
          DEVT(I)=0.0D0
        ELSE
C
C     COMPUTE DEV
C
          IXX = (IX-1)*NATOM
          DO J=1, NBASIS
             LMASK(J) = 0
             IF(LAMASK(IXX+NAOATM(J)).EQ.0) LMASK(J) = 1
          END DO
          JK = 0
          DO J=1,NBASIS
            JJ = J*(J-1)/2
            DO K=1,J
            JK=JK+1
            SXBAR(JK)=S(JK)*LMASK(J)*LMASK(K)
            IF(NAOATM(J).NE.NAOATM(K)) SXBAR(JK) = 0.0D0
C           IF(J.NE.K) SXBAR(JK) = 0.0D0
            END DO
          END DO
          DEVT(I) = 0.0D0
          CALL SPROD(NBASIS, VBOS(1,IX),SXBAR,VBOS(1,IK),XSBARK)
          CALL SPROD(NBASIS, VBOS(1,IX),SXBAR,VBOS(1,IX),XSBARX)
          CALL SPROD(NBASIS, VBOS(1,IX),S, VBOS(1,IK),XSK)
          DEVT(I) = DEVT(I) + (2.0D0*XSBARK/SN(IX)
     &                      - 2.0D0*XSBARX*XSK/(SN(IX)*SN(IX)))*WD
        END IF
      END DO
      DO I=1, NBRIL
       IX = INDX(1,I)
       IK = INDX(2,I)
       IF(LOCATM(IX).NE.0) THEN
        IXX = (IX-1)*NATOM
        DO J=1, NBASIS
           LMASK(J) = 0
           IF(LAMASK(IXX+NAOATM(J)).EQ.0) LMASK(J) = 1
        END DO
        JK = 0
        DO J=1,NBASIS
          DO K=1,J
          JK=JK+1
          SXBAR(JK)=S(JK)*LMASK(J)*LMASK(K)
          IF(NAOATM(J).NE.NAOATM(K)) SXBAR(JK) = 0.0D0
C         IF(J.NE.K) SXBAR(JK) = 0.0D0
          END DO
        END DO
        DO J=1,I
         J1 = INDX(1,J)
         J2 = INDX(2,J)
C
C        CASE 1: J1 == IX
C
         IF(J1.EQ.IX) THEN
           CALL SPROD(NBASIS,VBOS(1,IK),SXBAR,VBOS(1,J2),P1)
           CALL SPROD(NBASIS,VBOS(1,IX),SXBAR,VBOS(1,IK),P2)
           CALL SPROD(NBASIS,VBOS(1,IX),S,VBOS(1,J2),P3)
           CALL SPROD(NBASIS,VBOS(1,IX),SXBAR,VBOS(1,J2),P4)
           CALL SPROD(NBASIS,VBOS(1,IX),S,VBOS(1,IK),P5)
           CALL SPROD(NBASIS,VBOS(1,IX),SXBAR,VBOS(1,IX),P6)
           CALL SPROD(NBASIS,VBOS(1,IK),S,VBOS(1,J2),P7)
           IJ = I*(I-1)/2+J
           HESS(IJ) = HESS(IJ) + (2*P1/SN(IX)-4*P2*P3/(SN(IX)*SN(IX))-
     &               4*P4*P5/(SN(IX)*SN(IX)) - 2*P6*P7/(SN(IX)*SN(IX))+
     &               8*P5*P6*P3/(SN(IX)*SN(IX)*SN(IX)))*WD
         END IF
        END DO
       END IF
      END DO
      DO I=1, NBRIL
        DEV(I) = DEV(I) + DEVT(I)
      END DO
      RETURN
 101  WRITE(IOUTVB,*)"WRONG DATA 1"
      END
C
C     COMPUTE OVERLAP PENALTY CONTRIBUTION TO DERIVATIVES
C     VBSCF PART
C
C     VBOS: VB ORBITALS
C     NBRIL: VBSCF PARAMETERS
C     INDX:  BRILL TABLE
C     MGRP:  GROUP INDEX
C     DEV:   DERIVATIVES OF DELOCALIZATION
C     HESS:  HESSIAN OF DELOCALIZATION
C
C     History: First created in Oct 2009
C              Jiabo Li
C
      SUBROUTINE OPENALTY(NORB,S,NBRIL,INDX,MGRP,DEV,HESS,
     &                    LASTITER,ICONV,TOVERLAP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      PARAMETER (MAXBRIL= 10000)
      PARAMETER (MAXMSK = 10000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      PARAMETER (MAXCEN=200,MAXBFN=726)
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
C     COMMON /DPENAL/DPW,DEPS,DPWMAX,DENERGY,NITER,MAXMICRO
C     PARAMETER (MAXNAB=MAXCEN*MAXBFN/2,MAXBF2=MAXBFN*MAXBFN)
C     COMMON /LMODAT/VMO(MAXBF2),VLMO(MAXBF2),LMOLAB(2,MAXBFN),
C    &LMOATM(5,MAXBFN),PGM(MAXNAB),ENGLMO(MAXBFN),BONDLAB(MAXBFN),
C    &MCLMO(5,80),LHFLAG
      DIMENSION S(*),INDX(2,*),DEV(*),HESS(*)
C     DIMENSION NAOATM(2000)
      DIMENSION DEVT(MAXBRIL)
C     DIMENSION LOCATM(MAXBFN),DEVT(MAXBRIL),LAMASK(MAXMSK)
C     DIMENSION LMASK(MAXBFN),ITEMP(MAXCEN),SN(MAXBFN)
      IF(NBRIL.GT.MAXBRIL) CALL ABORT0("OPENALTY0A")
      IF(NORB*NATOM.GT.MAXMSK) CALL ABORT0("OPENALTY1A")
      IF(NORB.GT.MAXBFN) CALL ABORT0("OPENALTY2A")
      WOX    = 0.001D0
      TOVERLAP = 0.0D0
C     HPI = 3.14159265358979D0/2.0D0
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$WOX',4,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*)WOX

C
C     COMPUTE OVERLAP
C
      IF(LASTITER.EQ.1.AND.ICONV.EQ.1) THEN
         WRITE(IOUTVB,*)
         WRITE(IOUTVB,1000)MGRP
         WRITE(IOUTVB,1001)
      ENDIF
      DO I=1, NORB
        II = I*(I-1)/2
        DO J=1, I-1
           IJ = II+J
           SIJ = S(IJ)
           IF(SIJ.GT.1.0D0)  SIJ = 1.0D0
           IF(SIJ.LT.-1.0D0) SIJ = -1.0D0
           A = ACOS(SIJ)
           TOVERLAP = TOVERLAP + COS(2.0D0*A)
        END DO
      END DO
      TOVERLAP = TOVERLAP*WOX
 1000 FORMAT(" OVERLAP SUM  FOR VB ORBITALS OF GROUP ",I2)
 1001 FORMAT(" =============================================")
C
C     COMPUTE DEV
C
      DO I=1, NBRIL
       I1 = INDX(1,I)
       I2 = INDX(2,I)
       I12 = IJ00(I1,I2)
       S12 = S(I12)
       IF(S12.GT.1.0D0)  S12 = 1.0D0
       IF(S12.LT.-1.0D0) S12 = -1.0D0
       A = ACOS(S12)
       DEVT(I) = 2.0D0*SIN(2.0D0*A)*SIN(A)
        DO J=1,I
         J1 = INDX(1,J)
         J2 = INDX(2,J)
         J12 = IJ00(J1,J2)
         IJ = I*(I-1)/2+J
         IF(I12.EQ.J12) THEN
           HESS(IJ) = HESS(IJ) - (4.0D0*COS(2.0D0*A)*SIN(A)
     &                           +2.0D0*SIN(2.0D0*A)*COS(A))*SIN(A)*WOX
         ENDIF
        END DO
      END DO
      DO I=1, NBRIL
        DEV(I) = DEV(I) + WOX*DEVT(I)
      END DO
      RETURN
      END
C
C     PROD = V2*S*V1
C
      SUBROUTINE SPROD(N, V1, S, V2, PROD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION S(*),V1(*),V2(*),V3(1000)
      PROD = 0.0D0
      CALL MATSYM(N,1,S,V1,V3)
      DO J=1, N
         PROD = PROD + V2(J)*V3(J)
      END DO
      RETURN
      END
C
C     COMPUTE DELOCALIZATION PENALTY CONTRIBUTION TO DERIVATIVES
C     RIGID ROTATION PART
C
C     VBON:   VBO of nonorthogonal in AO basis
C     VBOL:   Lowdin orbitals in AO basis
C     BASLOC: VBO in Lowdin basis (local express)
C
C     First created: May 21, 2007
C     Fixed boundary check bugs:  April 4 2009
C
C     Author:        Jiabo Li
C
      SUBROUTINE DPENALTY2(VBON,VBOL,BASLOC,NB2ADD,S,
     &NHDIM,NHDADD,NHESADD,IRDEX,SXBAR,DEV,HESS,NSUB,MLORBIT,MNORBIT,
     &NHGRP,MITER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*8 BONDLAB
      CHARACTER*80 FLAG
      PARAMETER (MAXWRK = 1000000)
      PARAMETER (MAXHDM = 10000)
      PARAMETER (MAXLOC = 1000)
      PARAMETER (MAXNBS = 1000)
      PARAMETER (MAXMSK = 10000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      PARAMETER (MAXCEN=200,MAXBFN=726)
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
      COMMON /DPENAL/DPW,DEPS,DPWMAX,DENERGY,NITER,MAXMICRO
      PARAMETER (MAXNAB=MAXCEN*MAXBFN/2,MAXBF2=MAXBFN*MAXBFN)
      COMMON /LMODAT/VMO(MAXBF2),VLMO(MAXBF2),LMOLAB(2,MAXBFN),
     &LMOATM(5,MAXBFN),PGM(MAXNAB),ENGLMO(MAXBFN),BONDLAB(MAXBFN),
     &MCLMO(5,80),LHFLAG
      DIMENSION VBON(NBASIS,*),VBOL(NBASIS,*),BASLOC(*)
      DIMENSION IRDEX(3,*),S(*),DEV(*),NHDADD(*),NHESADD(*)
      DIMENSION NB2ADD(*),MLORBIT(*),MNORBIT(*)
      DIMENSION SXBAR(*),NAOATM(2000),HESS(*)
      DIMENSION LOCATM(MAXLOC),GDW(MAXLOC),LOCORB(MAXLOC)
      DIMENSION DEVT(MAXHDM),IGROUP(MAXNBS),LOCIDX(MAXNBS)
      DIMENSION LAMASK(MAXMSK),LMASK(MAXNBS),ITEMP(500)
      DIMENSION NBOADD(100),LBOADD(100)
      DIMENSION SPRODLL(MAXWRK),SPRODLN(MAXWRK)
      DIMENSION LATMS(1000),LMOALIST(10000) 
      IF(NHDIM .GT. MAXHDM) CALL ABORT0("DPENALTY2A")
      IF(NBASIS.GT.MAXNBS)  CALL ABORT0("DPENALTY2B")
      EPS     = 1.0D-10
      SFACTOR = 0.0D0
      WD      = 0.0D0
      WDX     = 0.1D0
      WSTART  = 10.0D+10
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$WSTART',7,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*,ERR=101)WSTART
      IF(MITER.EQ.1) THEN
        DPW     = WSTART
        NITER   = 0
        MAXMICRO= 100
        DENERGY = 1.0D0
      ENDIF
      CALL GETIOUNIT('IOENGI  ',IOENGI)
      CALL LOCTOR(IOENGI,'$SFACTOR',8,IOK,0)
      IF(IOK.EQ.1) THEN
          READ(IOENGI,*)SFACTOR
      END IF
      NORB = 0
      LORB = 0
      NBOADD(1) = 0
      LBOADD(1) = 0
      NLOCORB = 0
      DO I=1, NBASIS
         LOCIDX(I) = 0
      END DO
      DO I=1, NSUB
        NORB = NORB + MLORBIT(I)
        LORB = LORB + MNORBIT(I)
        NBOADD(I+1) = NBOADD(I)+MLORBIT(I)
        LBOADD(I+1) = LBOADD(I)+MNORBIT(I)
        DO J=LBOADD(I)+1, LBOADD(I+1)
           IGROUP(J) = I
        END DO
      END DO
      DO J=LBOADD(NSUB+1)+1,1000
        IGROUP(J) = NSUB+1
      END DO
      IF(NORB*NATOM.GT.MAXMSK) CALL ABORT0("DPENALTY2C")
      DO I=1, NORB
         LOCATM(I)=0
         II = (I-1)*NATOM
         DO J=1, NATOM
           LAMASK(II+J) = 0
         END DO
      END DO
C
C     THIS ASSUMES THAT ONLY ONE GROUP FOR THE WHOLE MOL
C
      IF(LHFLAG.GE.1) THEN
      CALL LMOATMLIST(LHFLAG,NORB,LMOATM,LMOALIST,LATMS)
      DO I=1, NORB
C        LOCATM(I)=LMOATM(5,I)
         LOCATM(I)=LATMS(I+1)-LATMS(I)
         II = (I-1)*NATOM
C        DO J=1, 4
C          JJ = LMOATM(J,I)
         DO J=LATMS(I),LATMS(I+1)-1
           JJ = LMOALIST(J)
           IF(JJ.GT.0) LAMASK(II+JJ) = 1
         END DO
         NLOCORB = NLOCORB + 1
         LOCIDX(I) = NLOCORB
         LOCORB(NLOCORB) = I
      END DO
      ENDIF
      NADD=1
      DO I=1, NATOM
        DO J=1, NATBAS(I)
        NAOATM(NADD) = I
        NADD= NADD+1
        END DO
      END DO
      DO I=1, NHGRP
        NDIM = NHDADD(I+1)-NHDADD(I)
        DO J=1, NDIM
          JJ = NHESADD(I)+J*(J-1)/2
C         WRITE(IOUTVB,'(8F10.5)')(HESS(JJ+K),K=1,J)
        END DO
      END DO
C
C     PRINT TRANSFORMATION MATRIX (LOCAL VBO IN LOWDIN BASIS
C
      DO I=1, NSUB
        DO J=1, MLORBIT(I)
         JJ= (J-1)*MNORBIT(I)-1
C        WRITE(IOUTVB,'(I3,7F10.5)')J,(BASLOC(NB2ADD(I)+JJ+K),K=1,MNORBIT(I))
        END DO
      END DO
      LDPEN  = 0
C
C     NEW FORMULA
C
      CALL LOCTOR(IOENGI,'$DPWEIGHT',9,IOK,0)
      IF(IOK.EQ.1) READ(IOENGI,*,ERR=101)WDX
        IF(DPWMAX.LT.WDX) DPWMAX = WDX
        WD = DPW + 0.1D0*NITER*DPW
        IF(NITER.GT.10) WD = DPW + DPW
        DEPSX = DEPS
        IF(DPW.GT.2.0D0) DEPSX = DEPS/10.0D0
        IF((DENERGY.LT.DEPSX.AND.NITER.GT.10).OR.NITER.GE.MAXMICRO) THEN
          DPW = DPW + DPW
          NITER = 0
          IF(DPW.GT.DPWMAX) DPW = DPWMAX
        ENDIF
        NITER = NITER+1
        IF(WDX .LT. WD) WD = WDX
        IF(NHDIM.EQ.0) RETURN
C
      GDW(NSUB+1) = 0.0D0
      DO MGRP=1, NSUB
        FLAG     = '$'
        WRITE(FLAG(2:3),'(I2.2)') MGRP
        FLAG(4:11)='LENHANCE'
        GDW(MGRP) = 0.0D0
C
C       READ PARAMETERS OF VB STRUCTURES
C
        CALL LOCTOR(IOENGI,FLAG,11,IOK,0)
        IF(IOK.EQ.1) THEN
         READ(IOENGI,*,ERR=101) LVBO
         DO I=1, LVBO
          READ(IOENGI,*,ERR=101)IVBO,LATM,(ITEMP(J),J=1,LATM)
          LOCATM(NBOADD(MGRP)+IVBO) = LATM
          II = (NBOADD(MGRP)+IVBO-1)*NATOM
          DO J=1, LATM
             LAMASK(II+ITEMP(J)) = 1
          END DO
          IF(LHFLAG.LT.1) THEN
            NLOCORB = NLOCORB + 1
            LOCIDX(NBOADD(MGRP)+IVBO) = NLOCORB
            LOCORB(NLOCORB) = NBOADD(MGRP)+IVBO
          END IF
         END DO
         GDW(MGRP) = WD
        END IF
        IF(LHFLAG.GE.1) GDW(MGRP) = WD
        IF(WD .GT. EPS) LDPEN = 1
        IF(WD .LT. -EPS) CALL ABORT0("DPENALTY2B")
      END DO
      IF(NLOCORB*NBASIS*NBASIS.GT.MAXWRK) CALL ABORT0("DPENALTY2D")
      IF(LDPEN.EQ.0)  RETURN
C
C     COMPUTE SPRODUCTS
C
      DO M=1, NLOCORB
         KK = LOCORB(M)
         KXX = (KK-1)*NATOM
         DO J=1,NBASIS
            LMASK(J) = 0
            IF(LAMASK(KXX+NAOATM(J)).EQ.0) LMASK(J) = 1
         END DO
         JL = 0
         DO J=1,NBASIS
           DO L=1, J
           JL = JL + 1
           SXBAR(JL)=S(JL)*LMASK(J)*LMASK(L)
           IF(NAOATM(J).NE.NAOATM(L)) SXBAR(JL)=0.0D0
C          IF(J.NE.L) SXBAR(JL) = 0.0D0
           END DO
         END DO
         DO IA = 1, NBASIS
         DO IB = 1, NBASIS
           CALL SPROD(NBASIS,VBOL(1,IA),SXBAR,VBOL(1,IB), ALSB)
           CALL SPROD(NBASIS,VBOL(1,IA),SXBAR,VBON(1,IB), ANSB)
           MMMM = (M-1)*NBASIS*NBASIS
           IAB = MMMM + (IA-1)*NBASIS+IB
           SPRODLL(IAB) = ALSB
           SPRODLN(IAB) = ANSB
         END DO
         END DO
      END DO
C
C     COMPUTE DERIVATIVES
C
      DO I=1, NHDIM
        IA = IRDEX(1,I)
        JB = IRDEX(2,I)
        MG = IRDEX(3,I)
        IAG = IGROUP(IA)
        JBG = IGROUP(JB)
        IAL = IA - LBOADD(IAG)
        JBL = JB - LBOADD(JBG)
        DEVT(I)=0.0D0
        HESST = 0.0D0
        II = I - NHDADD(MG)
        I2 = NHESADD(MG) + II*(II+1)/2
        DO K=1, MLORBIT(IAG)
          FACTOR = BASLOC(NB2ADD(IAG)-1+(K-1)*MNORBIT(IAG)+IAL)
          FACTOR2= FACTOR*FACTOR
          KK = NBOADD(IAG) + K
          IF(LOCATM(KK).NE.0.AND.GDW(IAG).GT.EPS) THEN
C
C     COMPUTE DEV
C
          MMMM = (LOCIDX(KK)-1)*NBASIS*NBASIS
          JBKK = MMMM + (JB-1)*NBASIS+KK
          IAKK = MMMM + (IA-1)*NBASIS+KK
          JBB  = MMMM + (JB-1)*NBASIS+JB
          APSA  = SPRODLN(JBKK)
          APPSA = SPRODLN(IAKK)
          APSAP = SPRODLL(JBB)
          DEVT(I) = DEVT(I) + 2*FACTOR*APSA*GDW(IAG)
          HESST   = HESST + (2*FACTOR2*APSAP - 2*FACTOR*APPSA)*GDW(IAG)
          END IF
        END DO
        DO K=1, MLORBIT(JBG)
          FACTOR = BASLOC(NB2ADD(JBG)-1+(K-1)*MNORBIT(JBG)+JBL)
          FACTOR2= FACTOR*FACTOR
          KK = NBOADD(JBG) + K
          IF(LOCATM(KK).NE.0.AND.GDW(JBG).GT.EPS) THEN
C
C     COMPUTE DEV
C
          MMMM = (LOCIDX(KK)-1)*NBASIS*NBASIS
          JBKK = MMMM + (JB-1)*NBASIS+KK
          IAKK = MMMM + (IA-1)*NBASIS+KK
          IAA  = MMMM + (IA-1)*NBASIS+IA
          BPSB  = SPRODLN(IAKK)
          BPPSB = SPRODLN(JBKK)
          BPSBP = SPRODLL(IAA)
          DEVT(I) = DEVT(I) - 2*FACTOR*BPSB*GDW(JBG)
          HESST   = HESST + (2*FACTOR2*BPSBP -2*FACTOR*BPPSB)*GDW(JBG)
          END IF
        END DO
        HESS(I2) = HESS(I2) + HESST + SFACTOR*(GDW(JBG)+GDW(IAG))
C
C       OFF-DIAGONAL ELEMENTS
C
        DO I1=1, I-1
          IA1 = IRDEX(1,I1)
          JB1 = IRDEX(2,I1)
          MG1 = IRDEX(3,I1)
          IAG1 = IGROUP(IA1)
          JBG1 = IGROUP(JB1)
          IF(IAG.NE.IAG1.OR.JBG.NE.JBG1) GOTO 102
          IAL1 = IA1 - LBOADD(IAG1)
          JBL1 = JB1 - LBOADD(JBG1)
          HESST = 0.0D0
          II1 = I1 - NHDADD(MG1)
          I21 = NHESADD(MG1) + II*(II-1)/2 + II1
          DO K1=1, MLORBIT(IAG1)
            FACTOR2 = BASLOC(NB2ADD(IAG1)-1+(K1-1)*MNORBIT(IAG1)+IAL1)*
     &                BASLOC(NB2ADD(IAG1)-1+(K1-1)*MNORBIT(IAG1)+IAL)
            KK1 = NBOADD(IAG1) + K1
            IF(LOCATM(KK1).NE.0.AND.GDW(IAG1).GT.EPS) THEN
C
C     COMPUTE DEV
C
            JBB1 = (LOCIDX(KK1)-1)*NBASIS*NBASIS+(JB-1)*NBASIS+JB1
            APSAP = SPRODLL(JBB1)
            HESST   = HESST + 2*FACTOR2*APSAP*GDW(IAG1)
            END IF
          END DO
          DO K1=1, MLORBIT(JBG1)
            FACTOR2 = BASLOC(NB2ADD(JBG1)-1+(K1-1)*MNORBIT(JBG1)+JBL1)*
     &                BASLOC(NB2ADD(JBG1)-1+(K1-1)*MNORBIT(JBG1)+JBL)
            KK1 = NBOADD(JBG1) + K1
            IF(LOCATM(KK1).NE.0.AND.GDW(JBG1).GT.EPS) THEN
C
C     COMPUTE DEV
C
            IAA1 = (LOCIDX(KK1)-1)*NBASIS*NBASIS+(IA-1)*NBASIS+IA1
            BPSBP = SPRODLL(IAA1)
            HESST   = HESST + 2*FACTOR2*BPSBP*GDW(JBG1)
            END IF
          END DO
          HESS(I21) = HESS(I21) + HESST
 102    CONTINUE
        END DO
      END DO
      DO I=1, NHDIM
        DEV(I) = DEV(I) + DEVT(I)
C       WRITE(IOUTVB,*)"I, DEV(I) =",I, DEV(I)
      END DO
      RETURN
 101  WRITE(IOUTVB,*)"WRONG DATA 2"
      END
      SUBROUTINE VBPOPL(NSUB,MORBIT,RWRK, ICHAPRT,MSIZE)
C
C     Function:
C               Calculates VB Density and Mulliken population analysis
C
C     Note:
C               Currently only atomic charge distribution is computed
C
C     History:
C               First created in March  2009.
C
C     Author:
C               Jiabo Li
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      DIMENSION MORBIT(*),RWRK(*)
      DIMENSION CHATOM(1000),NBAS2A(10000),CEATOM(1000)
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE,DENFILE
      LOGICAL LDENS,LTOT,LGRP,LSD
      COMMON /DCUBE/ IDENS,LDENS,LTOT,LGRP,LSD,DENFILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
      PARAMETER (MAXCEN=200,MAXBFN=726)
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
      NBA2=NBASIS*(NBASIS+1)/2
      LDMA=LGDMP
      MMS = LDMA+ NBA2
      MMH = MMS + NBA2
      LWK1= MMS
      LWK2= LWK1 + NBA2*2
      LLAST = LWK2
      IF(LLAST.GT.MSIZE) CALL ABORT0("POPANA0201")
C     WAS SPDEN SET?
      IF (LSD) THEN
        CALL GETCTLVAL("SPINDEN   ",CTLVAL,I1)
        CALL GETIOUNIT('IOENGI  ',IOENGI)
        REWIND(IOENGI)
        CALL LOCTOR(IOENGI,'$SPDEN',6,IOK,0)
        IF(IOK.EQ.1) I1 = 1
        IF (I1.NE.1) THEN
          WRITE(IOUTVB,
     &    '(/," SPIN DENSITY CUBE NOT ALLOWED - SPDEN NOT PRESENT")')
          LSD=.FALSE.
        ENDIF
      ENDIF
      IF(LTOT.OR.LGRP) THEN
        OPEN(UNIT=IDENS,FILE=DENFILE,STATUS='UNKNOWN',
     &    FORM='UNFORMATTED')
        IF(LSD) READ(IDENS) (RWRK(LDMA-1+J1),J1=1,NBA2)
      ENDIF
      DO I=1,NBA2
         RWRK(LDMA-1+I) =0.0D0
      ENDDO
C
C     BUILD ATOM INDEX
C
      IC=0
      DO I=1, NATOM
        CHATOM(I) = NATNUM(I)
        DO J=1, NATBAS(I)
           IC = IC + 1
           NBAS2A(IC) = I
        END DO
      END DO
C
C     ICHAPRT: CHARGE PRINTING OPTIONS
C     ICHARPT = 0: TOTAL DENSITY
C     ICHAPRT = 1: EACH GROUP ELECTRONS
C
      NOBADD1=NAOBAS
      IF (LGRP) WRITE(IDENS) NSUB
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      DO K=1,NSUB
        CALL MATRAN2(MORBIT(K),NBASIS,RWRK(NOBADD1),RWRK(LWK1),
     &            RWRK(ND1STA-1+N1DADD(K)),RWRK(LDMA),0)
        NOBADD1=NOBADD1+MORBIT(K)*NBASIS
        CALL READ1E(IAO1E,RWRK(MMS),RWRK(MMH),NBASIS)
        DO I=1, NATOM
          CEATOM(I) = 0.0D0
        END DO
        IC = 0
        DO I=1, NBASIS
         II = NBAS2A(I)
         DO J=1, I
          JJ = NBAS2A(J)
          FACTOR = 1.0D0
          IF(I.EQ.J) FACTOR = 0.5D0
          IC = IC + 1
          CHATOM(II) = CHATOM(II)-RWRK(LDMA-1+IC)*RWRK(MMS-1+IC)*FACTOR
          CHATOM(JJ) = CHATOM(JJ)-RWRK(LDMA-1+IC)*RWRK(MMS-1+IC)*FACTOR
          CEATOM(II) = CEATOM(II)-RWRK(LDMA-1+IC)*RWRK(MMS-1+IC)*FACTOR
          CEATOM(JJ) = CEATOM(JJ)-RWRK(LDMA-1+IC)*RWRK(MMS-1+IC)*FACTOR
         END DO
        END DO
        IF (LGRP) WRITE(IDENS) (RWRK(LDMA-1+J1),J1=1,NBA2)
C
C       PRINT ELECTRON CHARGES ON ATOMS FOR EACH GROUP
C
        IF(ICHAPRT.EQ.1) THEN
          WRITE(IOUTVB,1010)K
          WRITE(IOUTVB,1110)
          DO I=1, NATOM
            WRITE(IOUTVB,1200)I,CEATOM(I)
          END DO
          WRITE(IOUTVB,*)
          WRITE(IOUTVB,1300)
        END IF
C
C       PRINT ATOMIC CHARGES
C
        IF(K.EQ.NSUB) THEN
          WRITE(IOUTVB,1000)
          WRITE(IOUTVB,1100)
          DO I=1, NATOM
            WRITE(IOUTVB,1200)I,CHATOM(I)
          END DO
          WRITE(IOUTVB,*)
          WRITE(IOUTVB,1300)
        END IF
      ENDDO
C
C     GET TOTAL DENSITY AND PRINT IT
      DO I=1,NBA2
         RWRK(LDMA-1+I) =0.0D0
      ENDDO
      NOBADD1= NAOBAS
      IFLAG  = 1
      DO K=1,NSUB
        CALL MATRAN2(MORBIT(K),NBASIS,RWRK(NOBADD1),RWRK(LWK1),
     &             RWRK(ND1STA-1+N1DADD(K)),RWRK(LDMA),IFLAG)
        NOBADD1=NOBADD1+MORBIT(K)*NBASIS
      ENDDO
      IF (LTOT) WRITE(IDENS) (RWRK(LDMA-1+J1),J1=1,NBA2)
      IF (LTOT.OR.LGRP) CLOSE(IDENS)
C
 1000 FORMAT(//1X,"MULLIKEN CHARGES ON ATOMS",/1X,
     &          "-------------------------")
 1100 FORMAT(1X," ATOM             CHARGE ",/)
 1200 FORMAT(1X,I4,8X,F12.5)
 1300 FORMAT(1X,"-------------------------",/)
 1010 FORMAT(//1X,"ELECTRON CHARGES ON ATOMS",/1X,
     &            "OF ELECTRON GROUP",I4,/1X,
     &          "-------------------------")
 1110 FORMAT(1X,"ATOM       ELECTRON CHARGE",/)
      RETURN
      END
      SUBROUTINE DENSCUBE(D,TITLE,NP,KVB,LFIRST,NOEL,NO)
C#######################################################################
C
C     Calculates Density CUBE output for density in D.
C
C#######################################################################
      IMPLICIT NONE
      DOUBLE PRECISION D(*)
      CHARACTER*40 TITLE
      INTEGER NP,KVB,NOEL,NO
      LOGICAL LFIRST
C
      INTEGER MAXCEN,MAXEXP,MAXBFN
      PARAMETER(MAXEXP=1000,MAXBFN=726,MAXCEN=200)
      INTEGER I,J,N,K,I1,I2,I3,L,NVB
      DOUBLE PRECISION TOANG,ZERO,X,Y,Z,SUM,XNORM
      DOUBLE PRECISION C1(3,MAXCEN),XMIN(3),XMAX(3),XX(3),XORB(1000)
C
      DOUBLE PRECISION XE,C
      INTEGER IT,JT,KT,MT,MCT
      COMMON /CUBEC/ XE(MAXEXP),C(MAXEXP),IT(MAXEXP),JT(MAXEXP),
     & KT(MAXEXP),MT(MAXBFN),MCT(MAXBFN)
C
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE
      INTEGER IOUTVB,LENFIL
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
      CHARACTER*1 SYM
      INTEGER MAXSHL,NF,KATOM,IMOL,MAXPRM
      DOUBLE PRECISION XEXP,COEFF
      PARAMETER (MAXSHL=500,MAXPRM=15)
      COMMON /SEEING/ XEXP(MAXSHL,MAXPRM),COEFF(MAXSHL,MAXPRM)
     &,NF(MAXSHL),KATOM(MAXCEN),IMOL,SYM(MAXSHL)
C
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      INTEGER NATOM,NELE,NSPIN,NBASIS,NATNUM,NATBAS
      DOUBLE PRECISION ENREP,XYZ
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
C
      DOUBLE PRECISION ATMCHG
      COMMON /ATMCH/ ATMCHG(MAXCEN)
C
      DOUBLE PRECISION CORB(MAXBFN),SUM2
      DATA TOANG /0.529177249D0/
      DATA ZERO /0.0D00/
      K = 0
C     R3 = 1.0D0/SQRT(3.00D0)
C     DO I=1, NBASIS
C       WRITE(IOUTVB,'(7F10.5)') (D(J),J=K+1,K+I)
C       K = K + I
C     ENDDO
C
      IF (LFIRST) WRITE(IOUTVB,100)
      WRITE(IMOL,102) TITLE
      IF (LFIRST) WRITE(IOUTVB,102) TITLE
      WRITE(IMOL,103)
      IF (LFIRST) WRITE(IOUTVB,103)
      DO I=1,NATOM
        DO J=1,3
          C1(J,I)=XYZ(J,I)/TOANG
        ENDDO
      ENDDO
      DO J=1,3
        XMIN(J)=1.0D8
        XMAX(J)=-1.0D8
        DO I=1,NATOM
          IF (C1(J,I).LT.XMIN(J)) XMIN(J)=C1(J,I)
          IF (C1(J,I).GT.XMAX(J)) XMAX(J)=C1(J,I)
        ENDDO
        XMAX(J)=XMAX(J)+6.0D0
        XMIN(J)=XMIN(J)-6.0D0
        XX(J) = (XMAX(J)-XMIN(J))/(NP-1)
      ENDDO
      N=-NATOM
      WRITE(IMOL,101) N,(XMIN(K),K=1,3)
      IF (LFIRST) WRITE(IOUTVB,101) N,(XMIN(K),K=1,3)
      WRITE(IMOL,101) NP,XX(1),ZERO,ZERO
      WRITE(IMOL,101) NP,ZERO,XX(2),ZERO
      WRITE(IMOL,101) NP,ZERO,ZERO,XX(3)
      IF (LFIRST) THEN
        WRITE(IOUTVB,101) NP,XX(1),ZERO,ZERO
        WRITE(IOUTVB,101) NP,ZERO,XX(2),ZERO
        WRITE(IOUTVB,101) NP,ZERO,ZERO,XX(3)
      ENDIF
      DO I=1,NATOM
        WRITE(IMOL,101) NATNUM(I),ATMCHG(I),(C1(J,I),J=1,3)
        IF (LFIRST) WRITE(IOUTVB,101) NATNUM(I),
     &    ATMCHG(I),(C1(J,I),J=1,3)
      ENDDO
      NVB = 1
      WRITE(IMOL,104) NVB,KVB
      IF (LFIRST) WRITE(IOUTVB,104) NVB,KVB
      IF (LFIRST) WRITE(IOUTVB,*) 
C
      IF(NO.EQ.1) WRITE(IOUTVB,'(" SPIN DENSITY CUBE")')
      IF(NO.EQ.2) WRITE(IOUTVB,'(" DENSITY CUBE FOR GROUP",I2)') KVB
      IF(NO.EQ.3) WRITE(IOUTVB,'(" TOTAL DENSITY CUBE")')
      XNORM=0.0D0
      DO I1=1,NP
        X=XMIN(1) + (I1-1)*XX(1)
        DO I2=1,NP
          Y=XMIN(2) + (I2-1)*XX(2)
          DO I3=1,NP
            Z=XMIN(3) + (I3-1)*XX(3)
C
C  Get value of each basis function in CORB
C
            DO I = 1,NBASIS
              SUM = 0.0D0
              J = MCT(I) 
              K = J + MT(I) - 1
C000          CALL ORBPT(SUM,C1,C,XE,X,Y,Z,JT,IT,J,K)
CGMS          CALL ORBPTM(SUM,C1,C,XE,X,Y,Z,JT,IT,J,K)
CGAU          CALL ORBPTG(SUM,C1,C,XE,X,Y,Z,JT,IT,J,K)
              CORB(I) = SUM
            ENDDO
C
C  Here where density is calculated as C(trans)*D*C
C
            SUM = 0.0D0
            SUM2 = 0.0D0
            K = 0
            DO I=1, NBASIS
              DO J=1, I
                SUM = SUM + CORB(I)*D(K+J)*CORB(J)
              ENDDO
              SUM2 = SUM2 + CORB(I)*D(K+I)*CORB(I)
              K = K + I
            ENDDO
            SUM = 2.0D0*SUM - SUM2
            XORB(I3) = SUM
C           SUM DENSITY POINTS
            XNORM=XNORM+SUM
          ENDDO
          WRITE(IMOL,105) (XORB(L),L=1,NP)
        ENDDO
      ENDDO
C     Calculates normalisation of VB orbital from CUBE points
      XNORM = XNORM * (XX(1) * XX(2) * XX(3))
      WRITE(IOUTVB,'(/," NORMALIZATION FROM DENSITY IS: ",F12.6," FOR",
     &I4," ELECTRONS")') XNORM,NOEL
      IF (ABS(XNORM/NOEL-1.0D0).GT.2.0D-2) WRITE(IOUTVB,
     &'(" NORMALIZATION SUGGESTS YOU NEED MORE CUBE POINTS,",/
     &  " BUT VALUE WITH INNER CORE ELECTRONS CAN BE TOO LOW.")')
      RETURN
 100  FORMAT(/," DENSITY CUBE FILE HEADERS",/)
 101  FORMAT(I4,4F12.6)
 102  FORMAT(1X,A40)
 103  FORMAT(' SCF Molecular Orbitals')
 104  FORMAT(10I4)
 105  FORMAT(6E13.5)
      END
