C 11 AUG 11 - MK  - DCSCF: ADD DISPERSION ENERGY ONLY ONCE
C 15 APR 11 - YI  - CHANGES FOR LOCAL RESPONSE DISPERSION METHOD
C 15 APR 11 - AVM,MK - INTERFACING WITH U.MINNESOTA SMX CODES
C 15 APR 11 - MK  - FIX $DM PUNCH
C 15 APR 11 - MK  - FIX ANDERSON-LIKE DIIS, SYNC DCDIIS,SUBSP 
C 15 APR 11 - TY,MK - FINISHED DC-UHF IMPLEMENTATION
C 15 APR 11 - TA,MK - IMPLEMENTED VFON METHOD
C 11 AUG 10 - DGF - SYNCH COMMON BLOCK ENRGYS
C 23 JUN 10 - RP  - NEW COSMO IMPLEMENTATION, DFT-D3 INCLUDED
C 25 MAR 10 - TY,MK - DIVIDE-AND-CONQUER UHF (NOT YET FINISHED)
C 25 MAR 10 - MK  - ANDERSON-LIKE DIIS, UPDATE DFT FUNCTIONALS
C 14 OCT 09 - MWS - DROP CALL TO OLD QM/EFP2 PAULI REPULSION
C 14 AUG 09 - RP  - PAD COMMON BLOCK VDWPAR
C 22 MAY 09 - DMC - MINIMIZE SVP MODEL'S COMMON BLOCK FOOTPRINT
C  1 MAY 09 - KKB - REMOVE COSMO OUTPUTS
C 12 JAN 09 - TA,MK - IMPLEMENTATION OF DIVIDE-AND-CONQUER
C
C*MODULE DCSCF   *DECK DCSCF
C        MODIFIED FROM RHFCL
      SUBROUTINE DCSCF(SZ,S2)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL PACK2E,OUT,SOME,PRDENS,DIRSCF,FDIFF,SCHWRZ,
     *        CVGED,CVGING,CVDENS,CVENGY,CVDIIS,
     *        CVGSVP,CVGSVPDN,CVGSVPDN1,CVGSVPNR,
     *        DODIIS,DAMPH,EXTRAH,VSHIFT,RSTRCT,DEM,DEMOFF,
     *        NOTOPN,GOPARR,DSKWRK,MASWRK,TDSKWRK,MASPRT,
     *        ABINIT,MINMEM,VTSCAL,VIROK,LVCLN,IZRFLS,
     *        SOSCF0,SOSCF,EIGAVL,FT15OP,MFRZ,IPCFP,
     *        QOPS,QFMM,SHLOUT,DIISON,ISGDDI,PAROUT,INITGDDI,
     *        LCFLAG,LRINT,LCFLAGS,LRINTS,NEEDTAU,PRTTAU,SG1,
     *        CAMFLAG,DHFUNC
C
      LOGICAL LUHF,DIIS1
      DOUBLE PRECISION MOROKM, MD
      CHARACTER*12 METHOD
C
      DIMENSION TIMSTR(3),NSBOX(20)
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXGSH=30, MXG2=MXGSH*MXGSH,
     *           MXATM=2000, MXFRG=1050, MXAO=8192, MAXNFRAGS=10,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12,
     *           MXRT=100, MXGRID=10)
      PARAMETER (NUMRA=23, NITDIR=10)
C
      COMMON /ACONV / RRSHFT,EXTTOL,DMPTOL,VSHTOL,IEXTIN
      COMMON /ATHEAT/ ATHEAT
      COMMON /CDSPRT/ GCDS,AREACDS
      COMMON /CONV  / DENTOL,EN,ETOT,EHF,EHF0,DIFF,ITER,ICALP,ICBET
      COMMON /DFGRID/ DFTTHR,DFTGTHR,SWOFF,SW0,BSLRD(137),NDFTFG,
     *                NRAD,NTHE,NPHI,NRAD0,NTHE0,NPHI0,
     *                NANGPT(MXGRID),NANGPT0(MXGRID),SG1,JANS
      COMMON /DFLEB/  NLEB(MXGRID),NLEB0(MXGRID)
      COMMON /DFTCAM/ ALPHAC,BETAC,CAMMU,CAMVWN,CAMLYP,CAMFLAG
      COMMON /DFTDH / CHF,CMP2,C2S,C2T,DHFUNC
      COMMON /DFTPAR/ DFTTYP(20),EXENA,EXENB,EXENC,IDFT34,NAUXFUN,
     *                                                    NAUXSHL
      COMMON /DIISSO/ SOGTOL,ETHRSH,MAXDII,IRAF
      COMMON /DMPING/ SHIFTO,SHIFTV,DMPCUT,SWDIIS,DIRTHR
      COMMON /EFPBUF/ POLCHG(10),NBUFMO,LBUFF(MXAO),LBF,NAPOL,IAPOL(10)
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT1,SZ2,SZZ2,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FMCOM / X(1)
      COMMON /FMMDER/ MAXWS, NTBOX,NCXYZ, NTMPL,MAXNYP
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG)
      COMMON /FUNCT / ENERGY,EGRAD(3,MXATM)
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,NPGLOB,NNGLOB,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INDDIP/ TMUX,TMUY,TMUZ,TMUXD,TMUYD,TMUZD,MINMEM
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /INT2IC/ NINTIC,ININTIC,NXXIC,LBUFPIC,LIXIC,LABSIX,NINTIX
      COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /METGGA/ NEEDTAU,PRTTAU
      COMMON /MFRPAR/ MFRZ,NUMFRZ,NORFRZ,IFRZ(MXAO)
      COMMON /MIOPT / DTOLMI,CNVLOCMI,DIISTL,ALPHAMI,
     *                NF(MAXNFRAGS),MF(MAXNFRAGS),NFRAGS,MSHIFTMI,
     *                ITERMI,ITLOCMI,IGUESSMI,MXDIISMI,
     *                IOPTMI,MIFLAG,DIISON
      COMMON /MOLMEC/ HTYPE(4),NHCO(4,200),NNHCO,ITYPE
      COMMON /MPCGEO/ GEO(3,MXATM)
      COMMON /N2ELCT/ N2EL
      COMMON /NEOJOB/ NEORUN,NELERM
      COMMON /NLRC  / LCFLAG,LRINT,EMU,EMU2,LRFILE
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCMCHG/ PB,PX,PC,UNZ,QNUC,FN,FE,UNZOR,PORT
      COMMON /PCMDIM/ MXSP,MXTS,MEMPCM1,MEMPCM2,NTS
      COMMON /PCMITR/ RCUT(2),THRES,IPCMIT,IMUL,MXDIIS,NREG,MXITR1,
     *                MXITR2,MODPAP
      COMMON /PCMOPT/ RABI,RASC,REFPOL,THRSLS,DENSLS,WB,WA,ETA2,GD,EVAC,
     *                RHOW,PM,AREATL,AREAKP,BONDRY,OMEGA,RET,FRO,EPSINF,
     *                EPS,DR,RSOLV,VMOL,TCE,STEN,DSTEN,CMF,TABS,IDIRCT,
     *                IPCDER,IDP,ICOMP,IFIELD,ICAV,IDISP,IPRINT,IRETCAV,
     *                ICENT,IFAST,NEVAL,IEFPOL,KEEPSM,IMGABI,IMGASC,NADD
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IKREP,IEF,IP_F,NFMOPCM
      COMMON /PCMPNT/ LXYZRE,LSSFE,LLIST,LALPCM,LRINPCM,LINAPCM,LINFPCM,
     *                LINIPCM,LMEPCM,LAXYZCT,LXYZCT2,LNVERT,LQSN,LQSE,
     *                LQFS,LQIND,LISPHE,LVAD,LQOR,LVECMUL,LAIPRJ,LFIPRJ,
     *                LPEL,LPCMCDR,LDAI,LIDDAI,LQSND,LQSED
      COMMON /PCMPRT/ GCAVP,GCAVS,GDISP,GREP,EHFGAS
      COMMON /QMFM  / SIZE,EPSLN,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
      COMMON /QFMMRA/IORA(NUMRA),IQRAF,MIJKL
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SCFOPT/ CONVHF,MAXIT,MCONV,NPUNCH,NPREO(4)
      COMMON /SCFWFN/ AROHF(3),BROHF(3),PACAVO(6),IACAVO,IUHFNO,
     *                MVOQ
      COMMON /SHLT  / SHLTOL,CUTOFF,ICOUNT,SHLOUT
      COMMON /SIMDAT/ NACC,NREJ,IGOMIN,NRPA,IBWM,NACCT,NREJT,NRPAT,
     *                NPRTGO,IDPUNC,IGOFLG
      COMMON /SOLSMX/ SOLA,SOLB,SOLC,SOLG,SOLH,SOLN,ISMX
      COMMON /SVPOPT/ ISVP,NSVP,MTHSVP,NCAV,NVLPL,IQP
      COMMON /VIRIAL/ SCALTE,SCALTT,GVIR,VTCONV,MAXVT,VTSCAL,VIROK,LVCLN
      COMMON /VVOPAR/ IVVOS,NVVOS,BNDDEN
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      COMMON /ZRFPAR/ GZRF,FIND(3),GNUCF,EBORN,DIELEC,IZRF,ICALC
C
      PARAMETER (MXLATM=200, MXLSHL=700)
      LOGICAL STDCDI,DODCDI,NOTODC
C
      LOGICAL DCFLG,DIIDCF,DIIQTR
      COMMON /DCDIIS/ EXTDII,PEXDII,ETHRDC,DIITYP,NDCDIS,IRAFDC,DIIDCF,
     *                DIIQTR
      COMMON /DCDOS / DOSRGL,DOSRGR,DOSITV,BDOS
      COMMON /DCFRM / FRMLVA,FRMLVB,FRBETA,FTOL,MXITDC
      COMMON /DCOPT / SUBTYP,BUFTYP,SUBLNG,BUFRAD,NDCPRT,NSUBS,DCFLG
      COMMON /DCPRP / IORBD
      COMMON /DCQMT / NLQMT(MXATM)
      COMMON /DNSAO / IDENAO
      COMMON /INFOLC/ LOC2TA(MXLATM),LOC2TS(MXLSHL),LCKLOC(MXLSHL),
     *                NLAT,NLATC,NLSH,NLSHC,LNUM,LNUMC
      COMMON /IODC  / IDCSUB,IDCVEC,IDCDM,IDCQ,IDCDMO,IDCEIG,IDCW,IDCEDM
      COMMON /SUBSP / ILCST1(MXATM),NLC1,LNUMMX,ILATST(MXATM),NLCAT1
      COMMON /FONOPT/ FONTYP,BETINI,BETFIN,FONSTA,FONEND
C
      DATA APEXDI,AEXTDI/8HEXTDII  ,8HPEXDII  /
C
C     COSMO INFORMATION
C
      LOGICAL ISEPS, USEPS
      COMMON /ISEPS / ISEPS, USEPS
      LOGICAL COSBUG,COSWRT,DCOSMO,PRFCND,IOUTCH
      COMMON /COSDAT/ SE2,SECORR,QVCOSMO,ELAST,EMP2COS,EMP2LAST,
     *                COSVOL,COSSAR,EDIEL,EOC1,DEOC_RS,SUMQSC,
     *                SUMQSCOLD,ZSUM,ZSUM2,ZSUM3,FEPSI,RDS,DISEX2,
     *                EPSI,COSRAD,DISEX,OUTCHG,EDIEL_SAVE,
     *                MAXNPS,ICORR,ITRIP,NQS,MP2TRIP,MP2ITER,
     *                ICFREQ,NSPA,NSPH,NPSD,NPS,NPS2,NDEN,NPSPHER,
     *                COSBUG,COSWRT,DCOSMO,PRFCND,IOUTCH
C
C     COMMON BLOCK FOR DISPERSION CODE
C
      LOGICAL DC,DCCHG,DCABC
      COMMON /DFTDC / DC,IDCVER,DCCHG,DCABC,DCSR,DCS6,DCS8,DCALP
C
C     COMMON BLOCK FOR LOCAL RESPONSE DISPERSION
C
      LOGICAL LRDFLG,MLTINT,DOLRD
      COMMON /LRDISP/ ELRD6,ELRD8,ELRD10,EMULT,LRDFLG,MLTINT,DOLRD
C
      PARAMETER (ZERO=0.0D+00, HALF=0.5D+00, ONE=1.0D+00, TWO=2.0D+00,
     *           FIVE=5.0D+00, TEN=1.0D+01, SMALL=1.0D-08,
     *           PT2=0.2D+00, TWOPT2=2.2D+00, DMPTLC=1.0D-02)
      PARAMETER (VLN10=2.30258509299405D+00)
C
      SAVE FT15OP
C
      DATA FT15OP/.FALSE./
C
      DATA    UHF/8HUHF     /
      DATA  CHECK/8HCHECK   /, DEBUG/8HDEBUG   /, DBUGME/8HDCSCF   /
      DATA MOROKM/8HMOROKUMA/,  HESS/8HHESSIAN /, OPTMZE/8HOPTIMIZE/
      DATA     MD/8HMD      /, BNDANA/8HBONDANAL/
      DATA  G3MP2/8HG3MP2   /
      DATA NONE,ANONE/4HNONE,8HNONE    /
      DATA COARSE,FINE/8HCOARSE  ,8HFINE    /
      DATA WB97X    /8HWB97X   /
      DATA WB97XD   /8HWB97X-D /
      DATA WB97X2TQZ/8HWB97X-2 /
      DATA WB97X2LP /8HWB97X-2L/
      DATA FDS    /8HFDS     /
      DATA DIIER  /8HDIIER   /
C
C     ---------- DIVIDE-AND-CONQUER SCF CALCULATION ----------
C     W.YANG AND T-S.LEE, J.CHEM.PHYS. 103, 5674-5678(1995)
C     T.AKAMA, M.KOBAYASHI, AND H.NAKAI, J.COMPUT.CHEM. 28, 2003 (2007)
C
      ABINIT = MPCTYP.EQ.NONE
      LUHF   = SCFTYP.EQ.UHF
C
      IF(LUHF) THEN
        METHOD='DC-UHF      '
        IF(DFTYPE.NE.ANONE)
     *        WRITE(UNIT=METHOD,FMT='(''DC-U'',A8)') DFTYPE
        IF(MPCTYP.NE.NONE)
     *        WRITE(UNIT=METHOD,FMT='(''DC-U'',A4,''    '')') MPCTYP
      ELSE
        METHOD='DC-RHF      '
        IF(DFTYPE.NE.ANONE)
     *        WRITE(UNIT=METHOD,FMT='(''DC-'',A8,'' '')') DFTYPE
        IF(MPCTYP.NE.NONE)
     *        WRITE(UNIT=METHOD,FMT='(''DC-'',A4,''     '')') MPCTYP
      END IF
      LENMTH = LSTRNG(METHOD,12)
C
C           SCF-MI CALCULATION IS NOT SUPPORTED IN DC CALCULATION
C
      IF(MIFLAG.EQ.1) THEN
         IF(MASWRK) WRITE(IW,9900)
         CALL ABRT
      END IF
C
      IZRFLS = IZRF.NE.0
C
C        SET UP THE CASE OF BOTH EFP AND PCM MODELS BEING USED TOGETHER
C
      IF(IPCM.EQ.1 .AND. IEFP.EQ.1) THEN
         IPCM=0
         IEFP=0
         IPCFP=.TRUE.
      ELSE
         IPCFP=.FALSE.
      END IF
C
C     --- COUNTER FOR NEO ---
      ICNT = 0
C
      OUT    = .FALSE.
      SOME   = .FALSE.
      PRDENS = .FALSE.
      IF(MASWRK) THEN
        OUT    = NPRINT.EQ. 5 .OR. EXETYP.EQ.DEBUG .OR. EXETYP.EQ.DBUGME
        SOME   = NPRINT.NE.-5 .OR. EXETYP.EQ.DEBUG .OR. EXETYP.EQ.DBUGME
        PRDENS = NPRINT.GT. 8 .OR. EXETYP.EQ.DEBUG .OR. EXETYP.EQ.DBUGME
        OUT    = OUT .AND. NPRTGO.NE.2
        SOME   = SOME .AND. NPRTGO.NE.2
        PRDENS = PRDENS .AND. NPRTGO.NE.2
      END IF
      MASPRT = MASWRK  .AND.  NPRTGO.NE.2 .AND. RUNTYP.NE.MD
C
      IF(MASPRT)
     *   WRITE(IW,9000) METHOD(1:LENMTH)
C
C        PRINT $DANDC INPUT
C
      DIEXIT=APEXDI
      IF(NDCDIS.EQ.1) DIEXIT=AEXTDI
      IF(DCFLG.AND.MASWRK)
     *   WRITE (IW,9002) FRBETA,MXITDC,FTOL,
     *                   PEXDII,EXTDII,DIEXIT,DIITYP,DIIDCF,ETHRDC,
     *                   NDCPRT,IORBD,DOSITV,DOSRGL,DOSRGR
      IF(MASWRK)
     *   WRITE (IW,9003) FONTYP,BETINI,BETFIN,FONSTA,FONEND
C
C     ----- START THE CLOCKS -----
C
      TIM0 = ZERO
      TIM1 = ZERO
      CALL TSECND(TIM0)
      TLEFTS = TIMLIM - TIM0
C
C     ----- SELECT CONVERGENCE PROCEDURES(S) -----
C
      EXTRAH = MOD(MCONV,2)  .EQ. 1
      DAMPH  = MOD(MCONV,4)  .GE. 2
      VSHIFT = MOD(MCONV,8)  .GE. 4
      RSTRCT = MOD(MCONV,16) .GE. 8
      DODIIS = MOD(MCONV,32) .GE.16
      DEM    = MOD(MCONV,64) .GE.32
      SOSCF0 = MOD(MCONV,128).GE.64
C        IF WE ARE SWITCHING LATER, WE NEED TO ALLOCATE STORAGE FOR
C        THE SOSCF, BUT BE SURE SOSCF IS TURNED OFF BEFORE ITERS START.
      SOSCF  = SOSCF0 .OR.  SWDIIS.GT.0.0D+00
C
C     ----- SET POINTERS FOR PARTITIONING OF MEMORY -----
C
      IF(RUNTYP.EQ.MOROKM) THEN
         IF(MASWRK) WRITE(IW,9910)
         CALL ABRT
      ELSE
         LL1 = NUM
         LL2 = (LL1*LL1+LL1)/2
         LL3 = LL1*LL1
      END IF
C
      L0 = NQMT
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
C
C        FOR MOROKUMA RUNS, L1 MAY BE A SMALL PART OF MO SPACE
C
      IF(RUNTYP.EQ.MOROKM) L0 = MIN(NQMT,L1)
C
      MAXIT2=(MAXIT*MAXIT+MAXIT)/2
C
      NSH2 = (NSHELL*NSHELL+NSHELL)/2
C
      CALL VALFM(LOADFM)
      CALL GOTFM(NGOTMX)
      LSCR  = LOADFM + 1
      LIWRK = LSCR   + L1*8
      LWRK  = LIWRK  + L1
      LWRK1 = LWRK   + L1
      LWRK2 = LWRK1  + LL3
      LWRK3 = LWRK2  + LL3
      LFAO  = LWRK3  + LL3
      LD    = LFAO   + LL2
      LAST  = LD     + LL2
      LFAOB = LAST
      LDB   = LAST
      LWRK4 = LAST
      IF(LUHF) THEN
         LFAOB = LAST
         LDB   = LFAOB + LL2
         LWRK4 = LDB   + LL2
         LAST  = LWRK4 + LL3
      END IF
C
C     DUMMY POINTERS
      LEIG  = LAST
      LVEC  = LAST
      LOCC  = LAST
C
C     ----- ADD MEMORY FOR DIVIDE-AND-CONQUER METHOD -----
C
      LEIGT = LAST
      LWT   = LEIGT  + NLC1
      LKTP  = LWT    + NLC1
      LKEGTS= LKTP   + NLC1
      LNLCT = LKEGTS + NLC1
      LAST  = LNLCT  + LL2
      LEIGTB= LAST
      LWTB  = LAST
      IF(LUHF) THEN
         LEIGTB= LAST
         LWTB  = LEIGTB + NLC1
         LAST  = LWTB   + NLC1
      END IF
C
      CALL BASCHK(LMAX)
                    NANGM =  4
      IF(LMAX.EQ.2) NANGM =  6
      IF(LMAX.EQ.3) NANGM = 10
      IF(LMAX.EQ.4) NANGM = 15
      IF(LMAX.EQ.5) NANGM = 21
      IF(LMAX.EQ.6) NANGM = 28
      MAXG = NANGM**4
C
      MINTMX=NINTMX
      IF(NINTIC.NE.0) MINTMX=0
C     MEMORY IS ALLOCATED ELSEWHERE
CNB   FANCY OPTIONS (LOOK FOR NINTMX BELOW) WILL NOT WORK WITH
C     IN CORE INTEGRALS
C
      IF(ABINIT) THEN
         IF(DIRSCF) THEN
            LBUF  = LAST
            LIBUF = LAST
            LXINTS= LAST
            LXK   = LAST
            LGHOND= LXINTS + NSH2
            LDSH  = LGHOND + MAXG
            LDDIJ = LDSH   + NSH2
            LAST  = LDDIJ  + 49*MXG2
         ELSE
            LXINTS= LAST
            LGHOND= LAST
            LDSH  = LAST
            LDDIJ = LAST
            LBUF  = LAST
            LIBUF = LBUF   + MINTMX
            LAST  = LIBUF  + MINTMX
C
            LXK   = LAST
            IF(LUHF)  LAST = LXK + MINTMX
         END IF
         IF(NINTIC.NE.0) THEN
            LBUF  = LBUFPIC
            LIBUF = LIXIC
         END IF
         LTWOEI= LAST
         LPTOT2= LAST
      ELSE
         LXINTS= LAST
         LGHOND= LAST
         LDSH  = LAST
         LDDIJ = LAST
         LBUF  = LAST
         LIBUF = LAST
         LTWOEI= LAST
         LPTOT2= LTWOEI + N2EL
         LAST  = LPTOT2 + NAT*16
      END IF
C
      IF(DODIIS) THEN
         LADIIS = LAST
         LBDIIS = LADIIS + MAXDII*MAXDII
         LPDIIS = LBDIIS + MAXIT2
         LXDIIS = LPDIIS + MAXIT
         LIODII = LXDIIS + MAXIT
         LAST   = LIODII + 4*MAXDII
      ELSE
         LADIIS = LAST
         LBDIIS = LAST
         LPDIIS = LAST
         LXDIIS = LAST
         LIODII = LAST
      END IF
C
C     MEMORY FOR DC-DIIS
C
      IF(DIIDCF) THEN
         IF(LUHF) THEN
            MAXIO  = 4*NSUBS*MAXDII
         ELSE
            MAXIO  = 2*NSUBS*MAXDII
         END IF
         LIODCD = LAST
         LIODLE = LIODCD + MAXIO
         LAST   = LIODLE + MAXIO
      END IF
C
      IF(DEM) THEN
         IF(MASWRK) WRITE(IW,9950)
         CALL ABRT
      END IF
C
C      EXTRA MEMORY FOR APPROXIMATE CORRELATION ADAPTED VIRTUAL ORBITALS
C
      IF(IACAVO.EQ.1) THEN
         LKCORE = LAST
         LKVAL  = LKCORE + L2
         LAST   = LKVAL  + L2
      ELSE
         LKCORE = LAST
         LKVAL  = LAST
      END IF
C
C     -- MEMORY FOR SOLVATION METHODS
C        THE ORDER MUST BE PCM, EFP, PCM/EFP.
C
C         THERE IS A BUG WITH DFT+PCM+DIRSCF+FDIFF, AND A
C         WORKAROUND (AS OPPOSED TO A FIX) IS TO TURN FDIFF OFF.
      IF((IPCFP  .OR.  IPCM.EQ.1)   .AND.  NDFTFG.EQ.1
     *                              .AND.  DIRSCF) FDIFF=.FALSE.
C
      CALL PCMMEM3(IPCFP,L2,LAST,NTSPAR,LSOL,LCHG,LDMATM,LQPOT,LQFLD,
     *             LVPOT,LSE,LDE,LQ0,LQ1,LQ2,LQ3,LD0,LQA,LDIMAT,LQREP,
     *             LTMP0,LTMP1,LTMP2,LIPVT,LPOTTMP,LRMUL,LCHG2,
     *             LASCCRD,LASCCHG,LASCDIP,LASCQAD,LDISV,LDIS1,LDIS2,
     *             LCQEF,LQEFF,LELD,LXDINT,LYDINT,LZDINT,LEFLD,MADD,
     *             LABFLD,LVECMP,LVEC_2,LVEC_S,LAPROJ,LFPROJ)
C
      IF((IZRFLS .OR. IEFP.EQ.1 .OR. IPCFP)
     *    .AND. (DIRSCF.AND.FDIFF)) THEN
         NDIPER = LAST
         LDIPER = NDIPER  + L2
         LAST   = LDIPER  + L2
      ELSE
         NDIPER = LAST
         LDIPER = LAST
      END IF
C
C         MEMORY FOR SVP SOLVENT MODEL
C
      IF(ISVP.EQ.1) THEN
         NOPER=2
         IF(IQP.EQ.0.AND.MTHSVP.EQ.1) NOPER=1
         LENSVP=10*NCAV+NOPER*NCAV**2
         LSVP=LAST
         LAST=LSVP+LENSVP
      ELSE
         LSVP=LAST
         LENSVP=0
      END IF
C          AND AN INITIALIZATION FOR -SVP- MODEL
      IF(ISVP.EQ.1) FDIFF=.FALSE.
C
C         FOR SOSCF CONVERGER
C
      NFT15=15
      NPR=(L0-NA)*NA
      ITSO=0
      ORBGRD=ZERO
      IF(SOSCF) THEN
         IF(MASWRK) WRITE(IW,9954)
         CALL ABRT
C
         LGRAD  = LAST
         LHESS  = LGRAD  + NPR
         LPGRAD = LHESS  + NPR
         LDISPL = LPGRAD + NPR
         LAST   = LDISPL + NPR
      ELSE
         LGRAD  = LAST
         LHESS  = LAST
         LPGRAD = LAST
         LDISPL = LAST
      END IF
C
C     ----- FOR QFMM -----
C
      IF (QFMM) THEN
         CALL INITPRMT(NCXYZ,1)
         NSHL2=NSHELL*NSHELL
C
         IF (NCXYZ.LT.NUMRD) NUMRD=NCXYZ-1
C
         LCXYZ= LAST
         LIYP = LCXYZ    + NCXYZ*3
         LIBS = LIYP     + NCXYZ/NWDVAR+1
         LISP = LIBS     + NCXYZ*4/NWDVAR
         LIPP = LISP     + NCXYZ*2/NWDVAR
         LIDXWS = LIPP   + NCXYZ*2/NWDVAR
         LIDXIJK= LIDXWS + NCXYZ/NWDVAR+1
         LPTBL  = LIDXIJK+ NCXYZ*3/NWDVAR+2
         LYZTBL = LPTBL  + ((2**(NS+1)-1)**3+1)/NWDVAR+1
         LCLM   = LYZTBL + ((2**(NS+1)-1)**3+1)/NWDVAR+1
         LFLM   = LCLM   + 2*NP+1
         LPNTR  = LFLM   + 2*NP+1
         LG     = LPNTR  + 3*2**NS/NWDVAR+1
         LF     = LG     + 8*((NP*(NP+1)*(NP+2)*4/3)+(NP+1))
         LZLL   = LF     + 8*((NP*(NP+1)*(NP+2)*4/3)+(NP+1))
         LINDX  = LZLL   + (2*NP+2)*2
         LINDX2 = LINDX  + NCXYZ/NWDVAR+1
         LINDX3 = LINDX2 + NCXYZ/NWDVAR+1
         LDLIST = LINDX3 + NCXYZ/NWDVAR+1
         LSLIST = LDLIST + NSHL2/NWDVAR+1
         LDLN   = LSLIST + NSHL2/NWDVAR+1
         LSLN   = LDLN   + NSHELL/NWDVAR+2
         LMLIST   = LSLN   + NSHELL/NWDVAR+2
         LMLPNT = LMLIST + 4*NSHL2/NWDVAR+1
         LTS    = LMLPNT + 2*NSHELL/NWDVAR+1
         LMAXIJ = LTS    + NSHELL
         LIDXSHL= LMAXIJ + NSHELL
         LAST  = LIDXSHL+ NSH2/NWDVAR+2
      ELSE
         LCXYZ= LAST
         LIYP = LAST
         LIBS = LAST
         LISP = LAST
         LIPP = LAST
         LIDXWS = LAST
         LIDXIJK= LAST
         LPTBL  = LAST
         LYZTBL = LAST
         LCLM   = LAST
         LFLM   = LAST
         LPNTR  = LAST
         LG     = LAST
         LF     = LAST
         LZLL   = LAST
         LINDX  = LAST
         LINDX2 = LAST
         LINDX3 = LAST
         LDLIST = LAST
         LSLIST = LAST
         LDLN   = LAST
         LSLN   = LAST
         LMLIST = LAST
         LMLPNT = LAST
         LTS    = LAST
         LMAXIJ = LAST
         LIDXSHL= LAST
      END IF
C
C     ----- ADD IN GRID-BASED DFT MEMORY -----
C
C        ISWOFF=1 MEANS USE RHF UNTIL THE DENSITY GETS BELOW SWOFF,
C        THIS APPLIES ONLY TO THE VERY FIRST GEOMETRY IN THE RUN.
C
      ISWOFF=0
      IF(NDFTFG.EQ.1) THEN
         LFXC    = LAST
         IGRDDFT = LFXC + LL2
         IF (CAMFLAG) THEN
            LAFAO   = IGRDDFT
            LAFAOB  = IGRDDFT
            IF(LUHF) LAFAOB = LAFAO + LL2
            IGRDDFT = LAFAOB + LL2
         ELSE
            LAFAO = IGRDDFT
            LAFAOB= IGRDDFT
         END IF
         CALL GRDDFT(LL2,NGRDMEM)
         LAST    = IGRDDFT + NGRDMEM
         LFXCB   = LAST
         IF(LUHF) LAST = LFXCB + LL2
         IF(NEVALS.EQ.0 .AND. SWOFF.NE.0) ISWOFF=1
      END IF
      HFSSAV=DFTTYP(3)
      NDFTSV=NDFTFG
      IDFTSWITCH=0
      ISWDIR=1
C     ISWDIR TELLS HOW MANY TIMES WE PERMIT TO RECOMPUTE THE FOCK MATRIX
C     USING DIRTHR.
      LCFLAGS=LCFLAG
      LRINTS=LRINT
C
C          THESE NEED BOTH LONG-RANGE HF AND FULL HF AT SAME TIME
      IF(DIRSCF  .AND.
     *   (DFTYPE.EQ.WB97X     .OR. DFTYPE.EQ.WB97XD  .OR.
     *    DFTYPE.EQ.WB97X2TQZ .OR. DFTYPE.EQ.WB97X2LP)) THEN
         IF(MASWRK) WRITE(IW,*)
     *        'SORRY, WB97X FAMILY AND -DIRSCF- ARE INCOMPATIBLE'
         CALL ABRT
      END IF
C
C     ----- GRID-FREE DFT CANNOT BE PERFORMED IN DC METHOD -----
C
      IF(DFTTYP(1) .NE. 0.0D+00) THEN
         IF(MASWRK) WRITE(IW,9920)
         CALL ABRT
      END IF
C
C        WE CAN REDUCE MEMORY NEED BY 2N**2 BY DOING MORE DAREADS,
C        TO OVERLAP -H1- AND -WRK1-, -Q- AND -WRK2-, -S- AND -WRK3-.
C        THERE ARE A NUMBER OF EXOTIC OPTIONS THAT DON'T ENSURE
C        THE OVERLAPPING WILL WORK PROPERLY, SO FORCE THEM INTO THE
C        SEPARATE ALLOCATION.
C
      NEED = LAST - LOADFM - 1
      NSAVE = 2*LL2 + LL3
      NEEDI = NEED + NSAVE
      IF((NEEDI.LT.NGOTMX)  .OR.
     * (DEM .OR. VSHIFT .OR. IZRFLS .OR.
     *  IPCFP. OR. IPCM.EQ.1 .OR. IEFP.EQ.1)) THEN
         MINMEM = .FALSE.
         LH1   = LAST
         LQ    = LH1    + LL2
         LS    = LQ     + LL3
         LAST  = LS     + LL2
         NEED  = LAST -LOADFM -1
      ELSE
         MINMEM = .TRUE.
         IF(SOME) WRITE(IW,9005) NSAVE
         LH1 = LWRK1
         LQ  = LWRK2
         LS  = LWRK3
      END IF
C
      LVLEFP = LEVELEFP()
C
      IF(LVLEFP.EQ.2) THEN
         IF(MASWRK) WRITE(IW,9008)
         CALL ABRT
      END IF
C
C     ----- GET MEMORY -----
C
      CALL GETFM(NEED)
C
C     ----- INITIALIZE VARIABLES -----
C
      NOTOPN = .TRUE.
      NOTODC = .TRUE.
      DIIS1  = .TRUE.
      IF(MAXIT.LE.0) MAXIT = 30
C
C        LOOSEN CONVERGENCE FOR DIRECT SCF BY JUST A BIT
C
      IF(DIRSCF) THEN
         DENTOL = TWO * CONVHF
         ENGTOL = 1.0D-08
         DIITOL = 1.0D-06
      ELSE
         DENTOL = CONVHF
         ENGTOL = 1.0D-09
         DIITOL = 1.0D-07
      END IF
      IF(NDFTFG.NE.1) THEN
C        SW0=ZERO
C        CREATES PROBLEMS IN FMO WHEN MIXING RHF AND DFT.
      ELSE
C        IF(SW0.LT.CONVHF.AND.SW0.NE.0) THEN
         IF(SW0.LT.CONVHF) THEN
            IF(MASWRK) WRITE(IW,9006) SW0,CONVHF
            CALL ABRT
         END IF
      END IF
      SWDFT = SW0
      IF(NDFTFG.NE.1) SWDFT=ZERO
C
C        AT EARLY POINTS IN GEOMETRY OPTS, WE CAN BE A BIT COARSER,
C        WHENEVER THE LAST GEOMETRY'S GRADIENT WAS STILL BIG.
C
      IF((RUNTYP.EQ.OPTMZE  .OR. RUNTYP.EQ.G3MP2)  .AND.
     *   (NEVALS.GT.0)) THEN
         GRMS = DDOT(3*NAT,EGRAD,1,EGRAD,1)
         GRMS = SQRT(GRMS/(3*NAT))
                               CFACT =  1.0D+00
         IF(GRMS.GT.0.005D+00) CFACT =  5.0D+00
         IF(GRMS.GT.0.020D+00) CFACT = 20.0D+00
         IF(GRMS.GT.0.100D+00) CFACT = 50.0D+00
         DENTOL = CFACT*DENTOL
         ENGTOL = CFACT*ENGTOL
         DIITOL = CFACT*ENGTOL
         SWDFT  = CFACT*SWDFT
      END IF
C
      DTOL2 = TWO * DENTOL
      ETOL2 = TEN * ENGTOL
      CVDIIS = .FALSE.
      CVGING = .FALSE.
      CVGED  = .FALSE.
C
C     CVGSVP KEEPS TRACK OF WHETHER SVP CHARGES/DIPOLES APPEAR CONVERGED
C
      CVGSVP    = .FALSE.
      CVGSVPDN  = .FALSE.
      CVGSVPDN1 = .FALSE.
      CVGSVPNR  = .FALSE.
C
      ICCFLG=0
      ITDIIS = 1
      MPUNCH = NPUNCH
      EHF = ZERO
      ETOT= ZERO
      EEXC= ZERO
      EDHF1=ZERO
      EDHF2=ZERO
      ITERV= 0
      ICALP = 0
      ICBET = 0
      ICAB  = 0
      DAMP = ZERO
      DAMP0 = ZERO
      IF(DMPCUT .LE. ZERO) DMPCUT = ZERO
      RRSHFT = ZERO
      ERDIIS=ONE
      DIFF = ZERO
      DIFFP= ZERO
      DELE = ZERO
      DEAVG = ZERO
      NDAF = 15
      NDAFD = 23
      NDAFDB= 26
      IF(DAMPH .OR. VSHIFT) DAMP = ONE
      NUMDEM = 0
C
C     FOR DC-DIIS
C
      DODCDI=.FALSE.
      ITDIDC = 1
      IF(DIIDCF) ERDCDI=ZERO
C
      II = 0
      DO 140 I = 1,L1
         IA(I) = II
         II = II + I
  140 CONTINUE
C
C     ----- INITIALIZE -SVP- MODEL -----
C
      IF(ISVP.EQ.1) THEN
         IADDR_SVP=LSVP
         ILAST_SVP=LSVP+LENSVP-1
         CALL SVPSET
      END IF
C
C        MOPAC HAS A MOLECULAR MECHANICS PEPTIDE BOND CORRECTION
C
      EHNCO = ZERO
      IF(MPCTYP.NE.NONE) THEN
         DO I=1,NNHCO
            CALL DIHED(GEO,NHCO(1,I),NHCO(2,I),
     *                     NHCO(3,I),NHCO(4,I),ANGLE,SIGNA)
            SINANG = SIN(ANGLE)
            EHNCO = EHNCO + HTYPE(ITYPE)*SINANG*SINANG
         ENDDO
         EHNCO = EHNCO/627.52791D+00
      END IF
C
C --  C. AMOVILLI AND B. MENNUCCI
C     PCM CALCULATION OF DISPERSION INTERACTION
C     THREE STAGE PROCEDURE:
C      1) IN VACUO CALCULATION
C      2) SOLUTE AVERAGE TRANSITION FREQUENCY
C      3) ADDITION OF SOLVENT INTERACTION MATRICES:
C         ELECTROSTATIC + DISPERSION (+ REPULSION IF IRPCM=1)
C
C      PCM STAGE 1) IN VACUO CALCULATION
C
      ISD=1
      IF(IPCM.EQ.1  .AND.  IDP.EQ.1) THEN
        EN=EN-UNZ
        ISD=0
      END IF
      WA = ZERO
C
C        READ INVERSE D MATRIX FOR PCM (SKIP FOR ITERATIVE SOLVER)
C
      IF(IPCMIT.EQ.0  .AND.  (IPCM.EQ.1 .OR. IPCFP)) THEN
         NTS3 = NTS*NTS
         CALL SEQREW(NFT26)
         CALL DERCHK(NDER)
         IF(NDER.EQ.1.AND.IPCDER.EQ.1) THEN
            CALL SEQADV(NFT26)
            CALL SEQADV(NFT26)
            CALL SEQADV(NFT26)
            CALL SEQADV(NFT26)
         END IF
         IF(IEF.GT.0.AND.IEF.LT.3) THEN
            CALL SEQADV(NFT26)
            CALL SEQADV(NFT26)
            CALL SQREAD(NFT26,X(LSE),NTS3)
            CALL SQREAD(NFT26,X(LDE),NTS3)
         END IF
         CALL SQREAD(NFT26,X(LDMATM),NTS3)
         CALL SEQREW(NFT26)
      END IF
C
C     PCM STAGE 3) ADDITION OF SOLVENT INTERACTION MATRICES:
C
  333 CONTINUE
      IF(IPCM.EQ.1 .AND. IDP.EQ.1 .AND. ISD.EQ.1) THEN
         EN=EN+UNZ
         IF(SOME) WRITE(IW,9007) UNZ,EN
         IF(SOME) WRITE(IW,*)
         IF(DIRSCF  .AND.  FDIFF) THEN
            IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LH1),LL2,11,0)
            CALL DAWRIT(IDAF,IODA,X(LH1),LL2,14,0)
            CALL VCLR(X(LWRK1),1,L2)
         END IF
         GO TO 101
      END IF
C
C     ----- PRINT SCF OPTIONS -----
C
      IF(MASPRT) THEN
         IF(SOME) WRITE(IW,9010) EN,MAXIT,MPUNCH,EXTRAH,DAMPH,
     *                  VSHIFT,RSTRCT,DODIIS,DEM,SOSCF
         IF(NDFTFG.NE.1) THEN
            WRITE(IW,9012) DENTOL
         ELSE
            WRITE(IW,9013) DENTOL,SWDFT,SWOFF
         END IF
         IF(SOME  .AND.  VTSCAL) WRITE(IW,9015) VTSCAL,MAXVT,VTCONV
         IF(SOME  .AND.  SOSCF) WRITE(IW,9017) NPR,SOGTOL
         IF(SOME) WRITE(IW,9020) NEED
      END IF
C
C     ----- EXCHANGE INTEGRALS FOR DIRECT SCF THRESHOLD TESTS -----
C
      NINT=0
      NSCHWZ=0
      IF(DIRSCF.AND.ABINIT) THEN
         SCHWRZ = ISCHWZ.GT.0
         IF(MASPRT) WRITE(IW,9030) SCHWRZ,FDIFF,DIRTHR,NITDIR
         IF(SCHWRZ) CALL EXCHNG(X(LXINTS),X(LGHOND),X(LDDIJ),
     *                          NSH2,MAXG,INTTYP)
      ELSE
         SCHWRZ=.FALSE.
      END IF
C
C     ----- READ IN MOPAC 2-ELECTRON INTEGRALS -----
C
      IF(MPCTYP.NE.NONE  .AND.  N2EL.GT.0)
     *    CALL DAREAD(IDAF,IODA,X(LTWOEI),N2EL,53,0)
C
C     ----- READ BARE NUCLEUS HAMILTONIAN -----
C     ----- READ OVERLAP INTEGRALS -----
C     L0 = NUMBER OF CANONICAL ORTHONORMAL VECTORS KEPT.
C
      IF(.NOT.MINMEM) THEN
         CALL DAREAD(IDAF,IODA,X(LH1),LL2,11,0)
         CALL DAREAD(IDAF,IODA,X(LS) ,LL2,12,0)
         CALL DAREAD(IDAF,IODA,X(LQ) ,LL3,45,0)
      END IF
C     ----- READ INITIAL DENSITY MATRIX -----
      CALL TRLC2T(IDCDM,X(LD),X(LDB),X(LWRK1),LL1,LL2,'DENSITY ',
     *            .TRUE.,LUHF)
C
C     THE FOLLOWING IS FOR THE DENSITY UPDATE IN THE INNER SCF WITHIN
C     MP2 ITERATIONS - HERE THE SCF-DENSITY IS IN RECORD 308,
C     RECORD 16 CONTAINS THE MP2 DENSITY, SO WE READ FROM RECORD 308
C
      IF(ISEPS  .AND.  MP2ITER.EQ.1) THEN
         CALL DAREAD(IDAF,IODA,X(LD),LL2,308,0)
         IF (COSBUG) THEN
           WRITE(IW,*)
           WRITE(IW,*)"    READING IN SCF-DENSITY AGAIN FOR MP2ITER=1"
         END IF
      END IF
C
      IF(SOSCF) THEN
         CALL DAREAD(IDAF,IODA,X(LVEC),LL3,15,0)
         CALL DAREAD(IDAF,IODA,X(LEIG),LL1,17,0)
         TDSKWRK = DSKWRK
         DSKWRK = .FALSE.
         IF(.NOT.FT15OP) THEN
            FT15OP = .TRUE.
            CALL SEQOPN(NFT15,'WORK15','UNKNOWN',.FALSE.,'UNFORMATTED')
            CALL SEQREW(NFT15)
         ELSE
            CALL SEQREW(NFT15)
         END IF
         DSKWRK = TDSKWRK
      END IF
C
C     ----- PREVIOUS DENSITY IS ZERO, PREVIOUS FOCK MAT. IS HCORE -----
C
      IF(DIRSCF  .AND.  FDIFF) THEN
         IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LH1),LL2,11,0)
         CALL DAWRIT(IDAF,IODA,X(LH1),LL2,14,0)
         CALL VCLR(X(LWRK1),1,L2)
         IF(LUHF) THEN
            CALL DAWRIT(IDAF,IODA,X(LH1),LL2,18,0)
            CALL VCLR(X(LWRK3),1,L2)
         END IF
      END IF
C
C     ----- IF SCRF SAVE PRISTINE ONE ELEC. HAM. -----
C     -----    AND READ IN DIPOLE INTEGRALS      -----
C
      IF(IZRFLS) THEN
         CALL DAREAD(IDAF,IODA,X(LXDINT),LL2,95,0)
         CALL DAREAD(IDAF,IODA,X(LYDINT),LL2,96,0)
         CALL DAREAD(IDAF,IODA,X(LZDINT),LL2,97,0)
      END IF
      IF(IZRFLS  .OR.  IEFP.EQ.1  .OR.  IPCFP  .OR.  ISVP.EQ.1) THEN
         CALL DAWRIT(IDAF,IODA,X(LH1),LL2,87,0)
      END IF
C
C     ----- SETTING FOR GRID DFT -----
C
      IF (NDFTFG.EQ.1) THEN
C          PCM HAS A BUG RESETTING THE GRID, SO JUST DON'T LET IT
         IF(IPCM.EQ.1) THEN
            NRAD0 = NRAD
            NPHI0 = NPHI
            NTHE0 = NTHE
            NLEB0(1) = NLEB(1)
         END IF
         IF(SG1) THEN
            GRIDTYP=FINE
         ELSE
            IF (NLEB(1).NE.0) THEN
               IF(NLEB(1)*NRAD.GT.NRAD0*NLEB0(1)) THEN
                  IF(MASPRT) WRITE(IW,9335) NRAD,NLEB(1),NRAD0,NLEB0(1)
                  IF(EXETYP.NE.CHECK) THEN
                     CALL SWGRID
                     GRIDTYP=COARSE
                  ELSE
                     GRIDTYP=FINE
                  END IF
               ELSE
                  GRIDTYP=FINE
               END IF
            ELSE
               IF(NRAD*NPHI*NTHE.GT.NRAD0*NPHI0*NTHE0) THEN
                  IF(MASPRT) WRITE(IW,9340) NRAD,NTHE,NPHI,NRAD0,NTHE0,
     *                                      NPHI0
C     POSSIBLE TDDFT CHECK RUN WILL NEED TO SEE TRUE GRID SIZE
                  IF(EXETYP.NE.CHECK) THEN
                     CALL SWGRID
                     GRIDTYP=COARSE
                  ELSE
                     GRIDTYP=FINE
                  END IF
               ELSE
                  GRIDTYP=FINE
               END IF
            ENDIF
         ENDIF   ! END SG1 IF/THEN/ELSE
         CALL DFTSET(X(IGRDDFT),1,.FALSE.)
C
C         SWITCH OFF DFT AT THIS POINT IF WE INITIATE BY HF ITERS
C
         IF(ISWOFF.GT.0) THEN
            IF(MASWRK  .AND.  NDFTFG.NE.0) WRITE(IW,9350)
            DFTTYP(3)=1.0D+00
            NDFTFG=0
            LCFLAG=.FALSE.
            LRINT=.FALSE.
         END IF
      END IF
C
C     ----- SETUP FOR QFMM -----
C
      IF (QFMM) THEN
         CALL QFMMUP(LL2,LS,NSHL2,LSLIST,NSHELL,LSLN,LTS,
     *     NCXYZ,LCXYZ,LIYP,LIBS,LISP,LIPP,LIDXWS,LINDX,MAXWS,
     *     MAXNYP,NSH2,LIDXSHL,LPNTR,NBOX,NTBOX,LCLM,LFLM,
     *     LAST,LIDXBOX,LMBOX,LEBOX,LNBR,LNUMWS,LYZPNT,LTMPGPS,
     *     LTMPGPL,NEED1,NEED,LAST1,LINDX2,LINDX3,
     *     LIDXIJK,LPTBL,LYZTBL,NSBOX,NTMPL,
     *     MTIJ,MIJKL,LYP,LZP,LITSP,LITPP,LITSP2,
     *     LITPP2,IJTPP,KLTPP,IJSPP,KLSPP,IJTBLP,IJTBL,LAST2,NEED2)
C
C           THERE ARE ADDITIONAL MEMORY ALLOCATIONS INSIDE ROUTINES
C           -QFMMBOX- AND -NEARJ-, WHICH THE CHECK RUN WILL BRANCH
C           AROUND W/O CALLING WHEN BRANCHING PAST THE ITERS BELOW.
C           THESE MEMORY NEEDS ARE NOT SIMULTANEOUSLY NECESSARY.
C
         MQBOX = 3*NCXYZ + 2*NCXYZ/NWDVAR + 3*2**NS/NWDVAR + 3
         MNEARJ= 6*MIJKL + 2
C
         IF(EXETYP.EQ.CHECK) THEN
            NEED2 = NEED2 + MAX(MQBOX,MNEARJ)
         ELSE
            IF(MASPRT) WRITE(IW,9035) NEED2 + MAX(MQBOX,MNEARJ)
         END IF
         CALL GETFM(NEED2)
         NEED=NEED+NEED2
      END IF
C
      IF(EXETYP.EQ.CHECK) THEN
         IF(RUNTYP.EQ.BNDANA) THEN
            GO TO 510
         ELSE
            GO TO 520
         END IF
      END IF
C
      IF(FONTYP.EQ.DIIER) THEN
         CFON=(BETINI-BETFIN)/LOG10(FONSTA/FONEND)
         FRBETA=BETINI
      END IF
C
C     MO-S CANNOT BE FROZEN IN DC METHOD
      IF(MFRZ) THEN
         IF(MASWRK) WRITE(IW,9930)
         CALL ABRT
      END IF
C
C     ORBITAL ROTATION RESTRICTION IS SENSELESS IN DC METHOD
      IF(RSTRCT) THEN
         IF(MASWRK) WRITE(IW,9935)
         CALL ABRT
      END IF
C
C     LEVEL SHIFTING OF FOCK MATRIX DOES NOT WORK CURRENTLY
      IF(VSHIFT) THEN
         IF(MASWRK) WRITE(IW,9958)
         CALL ABRT
      END IF
C
      CALL DAREAD(IDAF,IODA,X(LNLCT),LL2,272,1)
C
      IF(MASPRT.AND.DIIDCF) WRITE(IW,9600)
C
C     ----- PRINT ITERATION HEADER -----
C
      IF(NBUFMO.GT.0) THEN
        IF(MASWRK) WRITE(IW,9039)
        CALL ABRT
      END IF
C
      IF(MASPRT) THEN
      IF(DIIDCF) THEN
         IF(DAMPH) THEN
            IF(.NOT.DIRSCF) WRITE(IW,9047)
            IF(     DIRSCF) WRITE(IW,9057)
         ELSE
            IF(.NOT.DIRSCF) WRITE(IW,9067)
            IF(     DIRSCF) WRITE(IW,9077)
         END IF
      ELSE
         IF(DAMPH) THEN
            IF(.NOT.DIRSCF) WRITE(IW,9045)
            IF(     DIRSCF) WRITE(IW,9055)
         ELSE
            IF(.NOT.DIRSCF) WRITE(IW,9065)
            IF(     DIRSCF) WRITE(IW,9075)
         END IF
      END IF
      END IF
C
C           ********************
C     ***** START RHF ITERATIONS *****
C           ********************
C
  101 CONTINUE
      TFOCK = ZERO
      TSOLVE = ZERO
      TFERMI = ZERO
      ITDIR=0
      SOSCF = SOSCF0
      DO 300 ITER=1,MAXIT
C
  310 CONTINUE
      CALL TSECND(TITER0)
C
C     ----- CONSTRUCT SKELETON 2 ELECTRON FOCK MATRIX -----
C     FOR DIRECT SCF,
C     EITHER -LWRK1- IS THE CHANGE IN THE DENSITY, WITH THE CHANGE
C     TO THE FOCK MATRIX TO BE COMPUTED IN -LFAO-, OR ELSE
C     -LWRK1- IS THE CURRENT DENSITY, WITH ALL 2 E- TERMS IN -LFAO-.
C
      IF(ABINIT) THEN
         IF(DIRSCF) THEN
            IF(FDIFF) THEN
               CALL VSUB(X(LWRK1),1,X(LD),1,X(LWRK1),1,L2)
               IF(LUHF) CALL VSUB(X(LWRK3),1,X(LDB),1,X(LWRK3),1,L2)
            ELSE
               CALL DCOPY(L2,X(LD),1,X(LWRK1),1)
               IF(LUHF) CALL DCOPY(L2,X(LDB),1,X(LWRK3),1)
            END IF
            IF(SCHWRZ) THEN
               DUMMY = 0.0D+00
               CALL SHLDEN(SCFTYP,X(LWRK1),X(LWRK3),DUMMY,X(LDSH),
     *                     IA,L1,L2,NSH2,1)
            END IF
            CALL VCLR(X(LFAO),1,L2)
            IF(LUHF) CALL VCLR(X(LFAOB),1,L2)
C
C         ----- LINEAR SCALING TWO-ELECTRON INTEGRAL COMPUTATION -----
C
            IF (QFMM) THEN
               IDUMMY=0
               CALL LSTWOEI(LDLIST,NSHL2,LDLN,LTS,NSHELL,LMAXIJ,LDSH,
     *            NSH2,NINT,L1,L2,LXINTS,LGHOND,MAXG,LDDIJ,LWRK1,LFAO,
     *            LSLIST,LMLIST,LIDXSHL,LIPP,LINDX2,LIDXIJK,
     *            LIDXWS,NCXYZ,LSLN,LMLPNT,LIYP,LCXYZ,LIBS,LYZTBL,
     *            NTMPL,LYP,LZP,NTBOX,MAXWS,LYZPNT,LF,LG,LZLL,LCLM,
     *            LFLM,LIDXBOX,NSBOX,NZ,LISP,
     *            SCHWRZ,NSCHWZ,LINDX,LITSP,LITPP,LITSP2,LITPP2,LMBOX,
     *            LEBOX,LNBR,LNUMWS,MIJKL,LWRK3,LFAOB,
     *            IJTPP,KLTPP,IJSPP,KLSPP,IJTBLP,IJTBL)
C
C          ----- DIRECT TWO-ELECTRON INTEGRAL COMPUTATION -----
C                LARGE MOLECULES AND/OR DIFFUSE FUNCTIONS NEED
C                INCREASED ACCURACY TO AVOID ROUNDOFF ERRORS NEAR
C                CONVERGENCE.  FOCK DIFFERENCING NEEDS A LITTLE
C                BIT MORE CARE WITH THE CONVERGENCE THAN THAT.
C
            ELSE
               CUTSV  = CUTOFF
               CUTOFF = MIN(CUTOFF,1.0D-10)
               IF(FDIFF) CUTOFF=CUTOFF/TWO
C
C                     ATTENUATED INTEGRALS FOR LC-TYPE DFT
               IF(LCFLAG) THEN
                  LRINT=.TRUE.
                  CALL TWOEIDC(SCFTYP,DIRSCF,.FALSE.,.FALSE.,.FALSE.,
     *                         INTTYP,SCHWRZ,NINT,NSCHWZ,L1,L2,
     *                         DUMMY,DUMMY,IDUMMY,1,
     *                         X(LXINTS),NSH2,X(LGHOND),MAXG,X(LDDIJ),
     *                         IA,X(LWRK1),X(LFAO),X(LWRK3),X(LFAOB),
     *                         X(LDSH),DUMMY,DUMMY,1,X(LNLCT))
                  LRINT=.FALSE.
               END IF
C
               IF(CAMFLAG  .AND.  NDFTFG.EQ.1) THEN
C
C                DO REGULAR INTEGRALS, SCALED BY ALPHAC
C
                 DFTTYP(3) = ALPHAC
                 CALL TWOEIDC(SCFTYP,DIRSCF,.FALSE.,.FALSE.,.FALSE.,
     *                        INTTYP,SCHWRZ,NINT,NSCHWZ,L1,L2,
     *                        DUMMY,DUMMY,IDUMMY,1,
     *                        X(LXINTS),NSH2,X(LGHOND),MAXG,X(LDDIJ),
     *                        IA,X(LWRK1),X(LFAO),X(LWRK3),X(LFAOB),
     *                        X(LDSH),DUMMY,DUMMY,1,X(LNLCT))
C
C                DO ATTENUATED INTEGRALS, SCALED BY BETAC
C
                 CALL VCLR(X(LAFAO),1,L2)
                 IF(LUHF) CALL VCLR(X(LAFAOB),1,L2)
                 LRINT=.TRUE.
                 EMU = CAMMU
                 EMU2 = CAMMU*CAMMU
                 DFTTYP(3) = BETAC
                 CALL TWOEIDC(SCFTYP,DIRSCF,.FALSE.,.FALSE.,.FALSE.,
     *                        INTTYP,SCHWRZ,NINT,NSCHWZ,L1,L2,
     *                        DUMMY,DUMMY,IDUMMY,1,
     *                        X(LXINTS),NSH2,X(LGHOND),MAXG,X(LDDIJ),
     *                        IA,X(LWRK1),X(LAFAO),X(LWRK3),X(LAFAOB),
     *                        X(LDSH),DUMMY,DUMMY,1,X(LNLCT))
                 LRINT=.FALSE.
                 CALL VADD(X(LFAO),1,X(LAFAO),1,X(LFAO),1,L2)
                 IF(LUHF)CALL VADD(X(LFAOB),1,X(LAFAOB),1,X(LFAOB),1,L2)
C
C                   THIS -ELSE- PART IS THE STANDARD 2E- FOCK BUILD,
C                   AND ALSO THE REGULAR INTEGRALS PART OF LC-TYPE DFT
               ELSE
                 CALL TWOEIDC(SCFTYP,DIRSCF,.FALSE.,.FALSE.,.FALSE.,
     *                        INTTYP,SCHWRZ,NINT,NSCHWZ,L1,L2,
     *                        DUMMY,DUMMY,IDUMMY,1,
     *                        X(LXINTS),NSH2,X(LGHOND),MAXG,X(LDDIJ),
     *                        IA,X(LWRK1),X(LFAO),X(LWRK3),X(LFAOB),
     *                        X(LDSH),DUMMY,DUMMY,1,X(LNLCT))
               END IF
               CUTOFF = CUTSV
            END IF
C
            CALL DSCAL(L2,HALF,X(LFAO),1)
            II=LFAO-1
            DO I=1,L1
               II = II+I
               X(II) = X(II) + X(II)
            END DO
            IF(LUHF) THEN
               CALL DSCAL(L2,HALF,X(LFAOB),1)
               II=LFAOB-1
               DO I=1,L1
                  II = II+I
                  X(II) = X(II) + X(II)
               END DO
            END IF
C
C          ----- TWO-ELECTRON INTEGRALS TAKEN FROM DISK -----
C
         ELSE
            TDSKWRK = DSKWRK
            DSKWRK  = .TRUE.
C
            IF(CAMFLAG  .AND.  NDFTFG.EQ.1) THEN
               CALL SEQREW(LRFILE)
               EMU = CAMMU
               EMU2 = CAMMU*CAMMU
               CALL VCLR(X(LAFAO),1,L2)
               IF(LUHF) THEN
                 CALL VCLR(X(LAFAOB),1,L2)
                 CALL HSTARLCU(X(LD),X(LAFAO),X(LDB),X(LAFAOB),X(LBUF),
     *                         X(LIBUF),NINTMX,IA)
                 CALL DSCAL(L2,HALF,X(LAFAOB),1)
                 II=LAFAOB-1
                 DO I=1,L1
                    II = II+I
                    X(II) = X(II) + X(II)
                 ENDDO
               ELSE
                 CALL HSTARLC(X(LD),X(LAFAO),X(LBUF),X(LIBUF),NINTMX,IA)
               END IF
               CALL DSCAL(L2,HALF,X(LAFAO),1)
               II=LAFAO-1
               DO I=1,L1
                  II = II+I
                  X(II) = X(II) + X(II)
               ENDDO
            ENDIF
C
C               ATTENUATED INTEGRALS FOR LC-TYPE DFT
            IF(LCFLAG) THEN
               CALL SEQREW(LRFILE)
               IF(LUHF) THEN
                  CALL HSTARLCU(X(LD),X(LFAO),X(LDB),X(LFAOB),X(LBUF),
     *                          X(LIBUF),NINTMX,IA)
               ELSE
                  CALL HSTARLC(X(LD),X(LFAO),X(LBUF),X(LIBUF),NINTMX,IA)
               END IF
            END IF
C
            IF(CAMFLAG  .AND.  NDFTFG.EQ.1) DFTTYP(3) = ALPHAC
C
C               ORDINARY INTEGRAL CONTRIBUTIONS TO FOCK MATRIX,
C               WHICH ARE ALSO NEEDED FOR RANGE-SEPARATED DFT.
C
            CALL SEQREW(IS)
            IF(LUHF) THEN
               CALL HSTARU(X(LD),X(LFAO),X(LDB),X(LFAOB),X(LBUF),
     *                     X(LIBUF),X(LBUF),X(LXK),NINTMX,IA,NOPK)
            ELSE
               CALL HSTAR(X(LD),X(LFAO),X(LBUF),X(LIBUF),
     *                    NINTMX,IA,NOPK,.FALSE.)
            END IF
C
            IF(CAMFLAG  .AND.  NDFTFG.EQ.1) THEN
               CALL VADD(X(LFAO),1,X(LAFAO),1,X(LFAO),1,L2)
               IF(LUHF) CALL VADD(X(LFAOB),1,X(LAFAOB),1,X(LFAOB),1,L2)
            END IF
C
            DSKWRK  = TDSKWRK
         END IF
C
C     ----- ADD GRID DFT CONTRIBUTION TO 2E- FOCK OPERATOR -----
C
         IF (NDFTFG.EQ.1) THEN
           IF(IDENAO.EQ.0) THEN
C             *** NOT POSSIBLE ***
              IF(MASWRK) WRITE(IW,9940)
              CALL ABRT
           ELSE
              DOLRD=.FALSE.
              IF(LRDFLG .AND. CVGING) DOLRD=.TRUE.
              CALL DFTEXCOR(X(IGRDDFT),X(LFXC),X(LFXCB),X(LD),X(LDB),
     *                      L1,L2,EEXC,TOTELE,TOTKIN)
           END IF
           CALL SYMH(X(LFXC),X(LWRK2),IA)
           IF(LUHF) CALL SYMH(X(LFXCB),X(LWRK2),IA)
C
C          FOCK MATRIX WILL BE CONTRACTED WITH DENSITY.
C          THIS IS MEANINGLESS FOR THE DFT EXCHANGE CORRELATION,
C          SO WE SUBSTRACT THAT LATER.
C          P.S. MEANINGLESS BECAUSE FXC DEPENDS ON DENSITY.
C
           CALL DDI_GSUMF(2310,EEXC,1)
           CALL DDI_GSUMF(2311,TOTELE,1)
           EDFT(1)=EEXC
           EDFT(2)=TOTELE
C
           IF (PRTTAU) THEN
             CALL DDI_GSUMF(2317,TOTKIN,1)
             WRITE(IW,9326) TOTKIN
           END IF
C
C          BY ADDING FXC NOW WE SAVE ONE CALL TO DDI_GSUM.
C
           IF(.NOT.(ABINIT.AND.DIRSCF.AND.FDIFF)) THEN
             EDHF1 = TRACEP(X(LD),X(LFXC),L1)/TWO
             CALL DDI_GSUMF(2314,EDHF1,1)
             CALL VADD(X(LFAO),1,X(LFXC),1,X(LFAO),1,L2)
             IF(LUHF) THEN
               EDHF2 = TRACEP(X(LDB),X(LFXCB),L1)/TWO
               CALL DDI_GSUMF(2315,EDHF2,1)
               CALL VADD(X(LFAOB),1,X(LFXCB),1,X(LFAOB),1,L2)
             END IF
           END IF
C
C          FDIFF DOES NOT WORK WITH DFT, UNLESS ONE DOES NOT
C          INCLUDE FXC (FOCK EX-CORR) INTO DIFFERENCING,
C          PROBABLY BECAUSE OF THE ABOVE P.S.
C
         END IF
         IF(GOPARR) THEN
            CALL DDI_GSUMF(1000,X(LFAO),L2)
            CALL DDI_GSUMI(1001,NINT   ,1)
            CALL DDI_GSUMI(1002,NSCHWZ ,1)
            IF(LUHF) CALL DDI_GSUMF(1003,X(LFAOB),L2)
         END IF
C
C           ----- MOPAC SEMI-EMPIRICAL 2E- FOCK OPERATOR -----
C
      ELSE
         IF(LUHF) THEN
            HFCO = -ONE
            CALL MPCG(X(LFAO),X(LFAOB),X(LWRK1),X(LD),X(LDB),X(LPTOT2),
     *                X(LTWOEI),L2,HFCO)
         ELSE
            HFCO = -HALF
            CALL MPCG(X(LFAO),X(LFAO),X(LD),DUMMY,DUMMY,X(LPTOT2),
     *                X(LTWOEI),L2,HFCO)
         END IF
      END IF
C
C     ----- GRID-FREE DFT ENERGIES ARE ZERO
C
      EXENA=ZERO
      EXENB=ZERO
      EXENC=ZERO
C
C           AT THIS POINT, THE SKELETON 2E- FOCK OPERATOR IS FINISHED
C
      IF(OUT) THEN
         WRITE(IW,*) '*** START OF DEBUG OUTPUT FOR ITERATION',ITER
         WRITE(IW,*) 'SKELETON FOCK MATRIX'
         CALL PRTRIL(X(LFAO),L1)
         IF(LUHF) THEN
            WRITE(IW,*) 'SKELETON FOCK MATRIX (BETA)'
            CALL PRTRIL(X(LFAOB),L1)
         END IF
      END IF
C
C     ----- SYMMETRIZE SKELETON FOCK MATRIX -----
C     SCRATCH AREA AT LWRK1 IS USED AS A SYMMETRIC MATRIX
C
      CALL SYMH(X(LFAO),X(LWRK1),IA)
      IF(LUHF) CALL SYMH(X(LFAOB),X(LWRK1),IA)
      IF(OUT) THEN
         WRITE(IW,*) 'SYMMETRIZED FOCK OPERATOR'
         CALL PRTRIL(X(LFAO),L1)
         IF(LUHF) THEN
            WRITE(IW,*) 'SYMMETRIZED FOCK OPERATOR (BETA)'
            CALL PRTRIL(X(LFAOB),L1)
         END IF
      END IF
C
C     ----- POSSIBLE NUCLEAR SCF LOOP(S) FOR NEO -----
C
      ADDNEO = 0.0D+00
      IF(NEORUN.EQ.1) THEN
         CALL NEOHF(X(LH1),X(LFAO),X(LD),DUMMY,DUMMY,X(LWRK1),DUMMY,
     *              X(LWRK2),X(LWRK3),ADDNEO,L1,L2,ICNT,EHFCL,
     *              ITER,EN)
      END IF
C
C     * * * * * SOLVATION MODEL CORRECTIONS TO 1E- TERM * * * * *
C
C                ----- ONSAGER REACTION FIELD -----
C     GET PRISTINE ONE ELEC. HAM., CALC. INDUCED DIPOLES, ADD PERTURB.
C
      IF(IZRFLS) THEN
         CALL DAREAD(IDAF,IODA,X(LH1),LL2,87,0)
         IF(DIRSCF .AND. FDIFF) THEN
            CALL RCNFLD(X(LH1),X(LFAO),DUMMY,X(LD),X(NDIPER),
     *                  X(LDIPER),X(LXDINT),X(LYDINT),X(LZDINT),L2,L1,0)
         ELSE
            CALL RCNFLD(X(LH1),DUMMY,DUMMY,X(LD),DUMMY,
     *                  DUMMY,X(LXDINT),X(LYDINT),X(LZDINT),L2,L1,0)
         END IF
      END IF
C
C     ----- SURFACE AND VOLUME POLARIZATION FOR ELECTROSTATICS -----
C
      IF(ISVP.EQ.1) THEN
         CALL SVPCHG(X(LD),X(LD),X(LH1),X(LWRK1),IADDR_SVP,ILAST_SVP,
     1                LL2,LL1,ESVP,ITER,
     2                CVGSVPDN,CVGSVPDN1,CVGSVPNR,CHGDIF,CVGSVP)
      END IF
C
C     ----- POLARIZABLE CONTINUUM MODEL CALCULATION -----
C
      IF(IPCM.EQ.1) THEN
C
C        NBUFMO SHOULD BE ZERO IN DC-SCF
C
         CALL DCOPY(L2,X(LD),1,X(LWRK2),1)
         CALL PCMFLD(X(LFAO),DUMMY,X(LD),X(LSOL),X(LCHG),X(LWRK1),
     *               X(LDISV),X(LDIS1),X(LDIS2),X(LWRK3),X(LSCR),
     *               X(LDMATM),X(LCQEF),X(LQEFF),X(LELD),X(LQPOT),
     *               X(LQFLD),X(LVPOT),X(LSE),X(LDE),
     *               X(LQ0),X(LQ1),X(LQ2),X(LQ3),
     *               X(LD0),X(LQA),X(LDIMAT),X(LQREP),
     *               X(LTMP0),X(LTMP1),X(LTMP2),X(LIPVT),
     *               X(LPOTTMP),X(LRMUL),TCH,QET,QETN,QESC,ISD,NFT27,
     *               IPCFP,L1,L2,NTSPAR,X(LAXYZCT),X(LAXYZCT+MXTS),
     *               X(LAXYZCT+MXTS*2),X(LXYZCT2),X(LXYZCT2+MXTS),
     *               X(LXYZCT2+MXTS*2),X(LAXYZCT+MXTS*3),X(LQSN),
     *               X(LQSE),X(LQSED),X(LQFS),X(LVECMUL),
     *               X(LCHG2),X(LQIND+MXTS),X(LPEL),
     *               X(LASCCRD),X(LASCCHG),X(LASCDIP),X(LASCQAD),
     *               X(LXYZRE),X(LXYZRE+MXSP),X(LXYZRE+MXSP*2),
     *               X(LXYZRE+MXSP*3),X(LISPHE),X(LLIST))
      END IF
      IF(NFMOPCM.NE.0) THEN
        CALL DAREAD(IDAF,IODA,X(LWRK2),L2,311,0)
        PX=-TRACEP(X(LD),X(LWRK2),L1)
      ENDIF
C
C               ------ COMBINED PCM/EFP METHOD ------
C
      IF(IPCFP) THEN
         CALL DCOPY(L2,X(LD),1,X(LWRK2),1)
         CALL PCMFLD(X(LFAO),DUMMY,X(LD),X(LSOL),X(LCHG),X(LWRK1),
     *               X(LDISV),X(LDIS1),X(LDIS2),X(LWRK3),X(LSCR),
     *               X(LDMATM),X(LCQEF),X(LQEFF),X(LELD),X(LQPOT),
     *               X(LQFLD),X(LVPOT),X(LSE),X(LDE),
     *               X(LQ0),X(LQ1),X(LQ2),X(LQ3),
     *               X(LD0),X(LQA),X(LDIMAT),X(LQREP),
     *               X(LTMP0),X(LTMP1),X(LTMP2),X(LIPVT),
     *               X(LPOTTMP),X(LRMUL),TCH,QET,QETN,QESC,ISD,NFT27,
     *               IPCFP,L1,L2,NTSPAR,X(LAXYZCT),X(LAXYZCT+MXTS),
     *               X(LAXYZCT+MXTS*2),X(LXYZCT2),X(LXYZCT2+MXTS),
     *               X(LXYZCT2+MXTS*2),X(LAXYZCT+MXTS*3),X(LQSN),
     *               X(LQSE),X(LQSED),X(LQFS),X(LVECMUL),
     *               X(LCHG2),X(LQIND+MXTS),X(LPEL),
     *               X(LASCCRD),X(LASCCHG),X(LASCDIP),X(LASCQAD),
     *               X(LXYZRE),X(LXYZRE+MXSP),X(LXYZRE+MXSP*2),
     *               X(LXYZRE+MXSP*3),X(LISPHE),X(LLIST))
         CALL DAREAD(IDAF,IODA,X(LH1),LL2,87,0)
C
C        NBUFMO SHOULD BE ZERO IN DC-SCF
C
         IF(DIRSCF .AND. FDIFF) THEN
            CALL CHGIND(X(LH1),X(LFAO),DUMMY,X(LD),X(NDIPER),X(LDIPER),
     *                  X(LDMATM),X(LXDINT),X(LYDINT),X(LZDINT),
     *                  X(LEFLD),X(MADD),X(LABFLD),X(LVECMP),X(LVEC_2),
     *                  X(LVEC_S),L2,L1,0,
     *                  X(LAXYZCT),X(LAXYZCT+MXTS),X(LAXYZCT+MXTS*2),
     *                  X(LAXYZCT+MXTS*3),X(LQSN),X(LQSE),X(LQFS),
     *                  X(LQIND),X(LAIPRJ),X(LFIPRJ))
         ELSE
            CALL CHGIND(X(LH1),DUMMY,DUMMY,X(LD),DUMMY,DUMMY,
     *                  X(LDMATM),X(LXDINT),X(LYDINT),X(LZDINT),
     *                  X(LEFLD),X(MADD),X(LABFLD),X(LVECMP),X(LVEC_2),
     *                  X(LVEC_S),L2,L1,0,
     *                  X(LAXYZCT),X(LAXYZCT+MXTS),X(LAXYZCT+MXTS*2),
     *                  X(LAXYZCT+MXTS*3),X(LQSN),X(LQSE),X(LQFS),
     *                  X(LQIND),X(LAIPRJ),X(LFIPRJ))
         END IF
C
C           WE WANT THE FULL DENSITY BACK AFTER EFPCMP IS DONE
C
      END IF
C
C           ---- EFFECTIVE FRAGMENT POTENTIAL MODEL -----
C
      EEXCH=ZERO
      IF(IEFP.EQ.1) THEN
         CALL DAREAD(IDAF,IODA,X(LH1),LL2,87,0)
C
C        DOES NOT WORK
         IF(LVLEFP.EQ.2) THEN
            IF(ITER.EQ.1) THEN
               CALL DIPINT(ZERO,ZERO,ZERO,.FALSE.)
            ELSE
CCC               CALL TFTRI(X(LHMO),X(LH1),X(LVEC),X(LWRK1),L1,L1,L1)
CCC               CALL EFHFDR(X(LHMO),X(LVMI),X(LVMITR),EEXCH,L1,CVGED)
CCC               CALL TFTRIB(X(LH1),X(LHMO),X(LS),X(LVEC),X(LSV),
CCC     *                     X(LWRK1),L1,L1,L2,L3)
            END IF
         END IF
C
C      NBUFMO SHOULD BE ZERO IN DC-SCF
C
         IF(DIRSCF .AND. FDIFF) THEN
           CALL EFPCMP(X(LH1),X(LFAO),DUMMY,X(LD),X(NDIPER),
     *                 X(LDIPER),X(LXDINT),X(LYDINT),X(LZDINT),
     *                 X(LEFLD),X(MADD),X(LABFLD),L2,L1,0)
         ELSE
           CALL EFPCMP(X(LH1),DUMMY,DUMMY,X(LD),DUMMY,DUMMY,
     *                 X(LXDINT),X(LYDINT),X(LZDINT),X(LEFLD),
     *                 X(MADD),X(LABFLD),L2,L1,0)
         END IF
C   WE WANT THE FULL DENSITY BACK AFTER EFPCMP IS DONE
      END IF
C
C                      ----- COSMO -----
C     ADD IN CORRECTION DUE TO SOLVENT SCREENING SELF-CONSISTENTLY
C     FIXED SCREENING CHARGES FOR HF PART WITHIN MP2 (MP2ITER=1)
C
      IF(ISEPS  .AND.  MP2ITER.EQ.0) CALL COSADD(.TRUE.)      
C
C     * * * * * END OF SOLVATION MODEL CORRECTIONS TO 1E- TERM * * * * *
C
C     ----- COMPLETE THE FOCK MATRIX -----
C     WE EITHER ADD THE FOCK OPERATOR OF THE PREVIOUS ITERATION TO
C     THE CHANGE IN THE FOCK MATRIX, OR WE ADD THE ONE ELECTRON
C     HAMILTONIAN TO THE FULLY COMPUTED TWO ELECTRON OPERATOR.
C
C       IF MO FREEZING IS IN EFFECT,
C       THE UNZEROED FOCK MATRIX IN AO BASIS WILL BE NEEDED TO
C       COMPUTE LAGRANGIAN AT THE END OF THE LAST ITERATION
C       (DICTIONARY FILE 317).
C
C     FOR COSMO, WE NEED TO UPDATE THE ONE-ELECTRON HAMILTONIAN FOR
C     CONVENTIONAL SCF-COSMO AND FOR THE INNER SCF WITHIN THE
C     MP2-COSMO ITERATIONS FOR BOTH SCF TYPES
C
      IF(ISEPS) CALL DAREAD(IDAF,IODA,X(LH1),LL2,11,0)
C
      IF(ABINIT  .AND.  DIRSCF  .AND.  FDIFF) THEN
         CALL DAREAD(IDAF,IODA,X(LWRK1),LL2,14,0)
         CALL VADD(X(LFAO),1,X(LWRK1),1,X(LFAO),1,L2)
         IF(LUHF) THEN
            CALL DAREAD(IDAF,IODA,X(LWRK1),LL2,18,0)
            CALL VADD(X(LFAOB),1,X(LWRK1),1,X(LFAOB),1,L2)
         END IF
C
C     FOR DIRECT SCF-COSMO WHERE THE SURFACE CHARGES ARE UPDATED EACH
C     SCF ITERATION, WE NEED THE CHANGE IN H BETWEEN THE CURRENT AND
C     THE PREVIOUS SCF ITERATION, SO THE CURRENT H IS ADDED FROM
C     SECTION 11 AND THE PREVIOUS H SUBTRACTED FROM SECTION 87
C
         IF(ISEPS.AND.(MP2ITER.EQ.0)) THEN
            WRITE(IW,*)"ADDING DIFFERENCE HNEW-HOLD TO F"
            CALL VADD(X(LFAO),1,X(LH1),1,X(LFAO),1,L2)
            CALL DAREAD(IDAF,IODA,X(LH1),LL2,87,0)
            CALL VSUB(X(LH1),1,X(LFAO),1,X(LFAO),1,L2)
         END IF
C
         IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LH1),LL2,11,0)
      ELSE
         IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LH1),LL2,11,0)
         CALL VADD(X(LFAO),1,X(LH1),1,X(LFAO),1,L2)
         IF(LUHF) CALL VADD(X(LFAOB),1,X(LH1),1,X(LFAOB),1,L2)
C
C        MK DELETED THE FOLLOWING PROCEDURE IN 2010
CCC         CALL IRPROD(X(LNLCT),X(LFAO),L2)
C
      END IF
C
C        SAVE THE FOCK MATRIX TO DISK.  NOTE THAT THIS DOES NOT
C        CONTAIN THE DFT EXCHANGE, BUT MUST BE SAVED HERE SO THAT
C        THE FDIFF OPTION WORKS PROPERLY.
C        SEE THE NOTE ABOUT DFT EXCHANGE ABOVE, IT CANNOT BE FDIFF'ED.
C
      CALL DAWRIT(IDAF,IODA,X(LFAO),LL2,14,0)
      IF(LUHF) CALL DAWRIT(IDAF,IODA,X(LFAOB),LL2,18,0)
      IF(CVGED  .AND.  ICCFLG.GT.0) GO TO 710
C
C     ----- CALCULATE THE ENERGY -----
C
      EHF1 = TRACEP(X(LD),X(LFAO),L1)
      EHF2 = TRACEP(X(LD),X(LH1),L1)
      IF(LUHF) THEN
         EHF1 = EHF1 + TRACEP(X(LDB),X(LFAOB),L1)
         EHF2 = EHF2 + TRACEP(X(LDB),X(LH1),L1)
      END IF
C
C       GRID DFT: FXC HAS NOT YET BEEN SUMMED, DO IT NOW (COMPLETES F)
C       SAVE THIS COMPLETED FOCK MATRIX FOR THE END OF THE RUN,
C       RECYCLING -308- RECORD SINCE MP2 AND DFT DON'T CLASH,
C       AND THE SIZE OF THIS RECORD IS THE SAME.
C
      IF(NDFTFG.EQ.1.AND.ABINIT.AND.DIRSCF.AND.FDIFF) THEN
        CALL DDI_GSUMF(2312,X(LFXC),L2)
        CALL VADD(X(LFAO),1,X(LFXC),1,X(LFAO),1,L2)
        CALL DAWRIT(IDAF,IODA,X(LFAO),LL2,308,0)
        IF(LUHF) THEN
          CALL DDI_GSUMF(2313,X(LFXCB),L2)
          CALL VADD(X(LFAOB),1,X(LFXCB),1,X(LFAOB),1,L2)
          CALL DAWRIT(IDAF,IODA,X(LFAOB),LL2,309,0)
        END IF
      END IF
C
C     IF PCM: ADD SOLUTE-SOLVENT DISPERSION ENERGY
C
      IF(IPCM.EQ.1  .AND.  IDP.EQ.1  .AND.  ISD.EQ.1)
     *  EHF2=EHF2+TRACEP(X(LD),X(LDIS1),L1)
C
C   SUBTRACT INTERACTION OF THE EFP WITH THE BUFFER ZONE DENSITY.
C   IF EFP + PCM, REMOVE CONTRIBUTIONS FROM NUCLEI AND ELECTRONS
C   INTERACTING WITH THE NUCLEAR INDUCED CHARGE
C   CALCULATE THE DENSITY OF THE BUFFER ZONE (FIRST NBUFMO MO-S)
C
C   HERE WE DEFINE EEFP AS THE INTERACTION OF THE EFP(MULTIPOLE
C   POINTS AND POLARIZABLE POINTS) WITH THE BUFFER ZONE DENSITY
C   I.E. (1)BUFFER ELECTRON -- MULTIPOLE POINTS
C        (2)BUFFER ELECTRON -- POLARIZABLE POINTS(INDUCED DIPOLE)
C   ANY PCM ASC ASSOCIATED INTERACTION IS NOT CONSIDERED AS A
C   PART OF EEFP.
C
C        NBUFMO SHOULD BE ZERO IN DC-SCF
C
      EEFP = ZERO
C
C         THE CONTRIBUTIONS HERE ARE THE AB INITO ENERGY
C         PLUS EXCHANGE CORRELATION FROM GRIDLESS DFT
C         PLUS EXCHANGE CORRELATION FROM GRID DFT
C         MINUS A CORRECTION FROM THE BUFFER REGION EFP CODE
C         PLUS A POSSIBLE MOPAC EMPIRICAL MM ENERGY FOR PEPTIDE BONDS
C
      EHF0 = EHF
      EHF = (EHF1+EHF2)/TWO
     *    + (EXENA+EXENB+EXENC)
     *    + (EEXC-EDHF1-EDHF2)
     *    - EEFP
     *    + EHNCO
C
C     COSMO CORRECTS ENERGY FOR CREATION OF CAVITY
C
      IF(ISEPS) EHF = EHF - SECORR
C
C     ----- DEBUG PRINT OF ENERGY AND FOCK MATRIX -----
C     -FV- AND -EIJ- AT LWRK1 AND LWRK2 ARE SQUARE MATRICES
C
      IF(OUT) THEN
         WRITE(IW,9080) EHF1,EHF2,EHF
         WRITE(IW,*) 'TOTAL FOCK OPERATOR'
         CALL PRTRIL(X(LFAO),L1)
         IF(LUHF) THEN
            WRITE(IW,*) 'TOTAL FOCK OPERATOR (BETA)'
            CALL PRTRIL(X(LFAOB),L1)
         END IF
      END IF
C
      ETOT0 = ETOT
      ETOT  = EHF+EN
C
C     --- POSSIBLE ADDITION OF NEO ENERGY ---
C
      ETOT = ETOT + ADDNEO
C
C        ---- SOLVENT ENERGY CORRECTIONS ----
C
C     NOTE: ONSAGER MODEL PUT FREE ENERGY CORRECTIONS INTO -EN- ALREADY
C
C     IF PCM: CALCULATE THE CORRECT VARIATIONAL FREE ENERGY
C
      IF(IPCMIT.EQ.0) THEN
         IF((IPCM.EQ.1.AND.ISD.EQ.1).OR.IPCFP) ETOT=ETOT-HALF*(PB-PC)
      ELSE
         IF((IPCM.EQ.1.AND.ISD.EQ.1).OR.IPCFP) ETOT=ETOT+HALF*PX
      END IF
      IF(NFMOPCM.NE.0) ETOT=ETOT+HALF*(PC+PX)
C
      IF(IPCM.EQ.1 .OR. IPCFP) THEN
         ETOT=ETOT+(GCAVP+GDISP+GREP)/627.509541D+00
      END IF
C
C     SVP MODEL'S FREE ENERGY CORRECTION
C
      IF(ISVP.EQ.1) ETOT=ETOT+HALF*ESVP
C
C     MINNESOTA SOLVATION MODELS
C
      IF((ISMX.EQ.1.OR.ISMX.EQ.2).AND.(IPCM.EQ.1.OR.IPCFP)) THEN
         IF (ITER.EQ.1) CALL CDSSET(ISMX)
         ETOT=ETOT-(GCAVP+GDISP+GREP)/627.509541D+00+GCDS/627.509541D+00
      END IF
      IF(ISMX.EQ.3  .AND.  ISVP.EQ.1) THEN
         IF (ITER.EQ.1) CALL CDSSET(ISMX)
      END IF
C
      IF(ITER.EQ.1) E0 = ETOT
      DELE0 = DELE
      DELE  = ETOT-ETOT0
      IF(ITER.EQ.1) DEAVG = ZERO
      IF(ITER.EQ.2) DEAVG = ABS(DELE)
      IF(ITER.GE.3) DEAVG = (ABS(DELE)+ ABS(DELE0)+PT2*DEAVG)/TWOPT2
      CALL TSECND(TITER1)
C
C     ----- POSSIBLE SECOND ORDER SCF -----
C     ON THE VERY FIRST ITERATION OF THE VERY FIRST GEOMETRY, WE MUST
C     DO A DIAGONALIZATION TO GET EIGENVALUES TO APPROX. THE HESSIAN.
C     ALL THREE -LWRK- WORK ARRAYS ARE AVAILABLE FOR SCRATCH USAGE.
C     HESSIAN RUNS MAY NOT HAVE CANONICAL VIRTUAL ORBITALS READ IN,
C     AND IT IS PROBABLY A GOOD IDEA TO DIAGONALIZE ONCE ANYWAY, JUST
C     TO MIX SYMMETRIES UP WELL DURING NUMERICAL RUNS.
C
      EIGAVL = ITER.GT.1  .OR.  NEVALS.GE.1
      IF(RUNTYP.EQ.HESS)   EIGAVL = ITER.GT.1
      IF(RUNTYP.EQ.MOROKM) EIGAVL = ITER.GT.1
C
C     CURRENTLY VSHIFT DOES NOT WORK AT ALL
      IF(SOSCF .AND.  EIGAVL) THEN
         CALL SOGRAD(X(LGRAD),X(LFAO),X(LVEC),X(LSCR),NPR,NA,
     *               L0,L1,ORBGRD)
C        SEE COMMENTS BELOW AT SIMILAR B'CASTS. ISGDDI SHOULD BE GOPARR.
         IF(ISGDDI) CALL DDI_BCAST(2421,'F',ORBGRD,1,MASTER)
         IF(ORBGRD.LT.SMALL) THEN
            DIFF = ZERO
            CVGING=.TRUE.
            GO TO 700
         END IF
         IF(ORBGRD.LT.SOGTOL  .OR.  ITSO.GT.0) THEN
            IF(ITSO.EQ.0) THEN
               DAMP = ZERO
               RRSHFT = ZERO
               IF(MASPRT) WRITE(IW,9200)
               CALL SOHESS(X(LHESS),X(LEIG),NPR,L0,NA,NA)
            END IF
C
            ITSO = ITSO+1
            CALL SONEWT(X(LHESS),X(LGRAD),X(LPGRAD),X(LDISPL),
     *                  X(LWRK1),X(LWRK2),X(LWRK3),
     *                  X(LWRK1+NPR),X(LWRK2+NPR),X(LWRK3+NPR),
     *                  ORBGRD,NPR,ITSO,NFT15)
            IF(ORBGRD.EQ.-123) GO TO 350
            CALL SOTRAN(X(LDISPL),X(LVEC),X(LWRK1),X(LSCR),
     *                  NPR,L0,L1,NA,NA,ORBGRD)
            CALL DCOPY(NPR,X(LGRAD),1,X(LPGRAD),1)
            GO TO 800
         END IF
      END IF
C
C     ----- POSSIBLE DIIS INTERPOLATION -----
C     THE RHF ERROR MATRIX ERR = FDS-SDF IS FORMED AT -LWRK3-
C     SQUARE FORMS OF -F- AND -S- ARE HELD AT -LWRK1- AND -LWRK2-
C     IF DIIS GETS TURNED ON BY -DIIS-, ITDIIS WILL BE .GT. 1
C
      IF(DODIIS .AND. .NOT.DODCDI) THEN
C
C       PULAY'S MODIFIED DIIS
        IF(DIITYP.EQ.FDS) THEN
         IF(ABINIT) THEN
            IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LS),LL2,12,0)
            CALL EXPND(X(LFAO),X(LWRK1),L1,0)
            CALL EXPND(X(LS),X(LWRK2),L1,0)
            CALL DIISER(X(LWRK1),X(LD),X(LWRK2),X(LWRK3),X(LWRK),
     *                  L1,L2,1,1)
            IF(LUHF) THEN
               CALL EXPND(X(LFAOB),X(LWRK1),L1,0)
               CALL DIISER(X(LWRK1),X(LDB),X(LWRK2),X(LWRK4),X(LWRK),
     *                  L1,L2,1,1)
            END IF
         ELSE
            CALL EXPND(X(LFAO),X(LWRK1),L1,0)
            CALL EXPND(X(LD),X(LWRK2),L1,0)
            CALL MRARBR(X(LWRK1),L1,L1,L1,X(LWRK2),L1,L1,X(LWRK3),L1)
            IF(LUHF) THEN
               CALL EXPND(X(LDB),X(LWRK1),L1,0)
               CALL MTARBR(X(LFAOB),L1,X(LWRK1),L1,X(LWRK2),L1,1)
               CALL VADD(X(LWRK3),1,X(LWRK2),1,X(LWRK3),1,L3)
            END IF
            CALL SUBMT(X(LWRK3),L1)
         END IF
C
C       ANDERSON-LIKE DIIS
        ELSE IF(.NOT.DIIS1) THEN
           CALL DAREAD(IDAF,IODA,X(LWRK1),L2,273,0)
           CALL VSUB(X(LWRK1),1,X(LFAO),1,X(LWRK2),1,L2)
           CALL EXPND(X(LWRK2),X(LWRK3),L1,0)
           IF(LUHF) THEN
              CALL DAREAD(IDAF,IODA,X(LWRK1),L2,274,0)
              CALL VSUB(X(LWRK1),1,X(LFAOB),1,X(LWRK2),1,L2)
              CALL EXPND(X(LWRK2),X(LWRK4),L1,0)
           END IF
        END IF
        IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LQ),LL3,45,0)
        IF(.NOT.DIIS1 .OR. DIITYP.EQ.FDS)
     *   CALL DIIS(SCFTYP,IW,ITDIIS,X(LQ),X(LFAO),X(LFAOB),X(LWRK3),
     *             X(LWRK4),X(LWRK1),X(LADIIS),X(LXDIIS),X(LPDIIS),
     *             X(LBDIIS),X(LIODII),X(LWRK),L1,L2,L3,MAXIT,MAXIT2,
     *             4*MAXDII,ERDIIS,NOTOPN,MASPRT)
        IF(DIITYP.NE.FDS) THEN
           CALL DAWRIT(IDAF,IODA,X(LFAO),L2,273,0)
           IF(LUHF) CALL DAWRIT(IDAF,IODA,X(LFAOB),L2,274,0)
        END IF
C
        IF(FONTYP.EQ.DIIER) THEN
          IF(DIIS1 .AND. DIITYP.NE.FDS) THEN
            IF(NEVALS.NE.0) THEN
              FRBETA=BETFIN
            END IF
          ELSE
            IF(ISWOFF.EQ.1) THEN
              FRBETA=BETINI
            ELSE IF(ERDIIS.GT.FONSTA) THEN
              FRBETA=BETINI
            ELSE IF(ERDIIS.LE.FONEND) THEN
              FRBETA=BETFIN
            ELSE
              FRBETA=MAX(FRBETA,BETFIN+CFON*LOG10(ERDIIS/FONEND))
            END IF
          END IF
        END IF
        DIIS1=.FALSE.
      END IF
C
      IF(FONTYP.EQ.DIIER .AND. (DODCDI .OR. .NOT.DODIIS)) FRBETA=BETFIN
C
C     ----- DAMP AND EXTRAPOLATE THE FOCK MATRIX -----
C     DAMPD COMPUTES THE DAMP FACTOR, EXTRAP ACTUALLY DOES THE DAMPING
C     LWRK1,LWRK2,LWRK3 HOLD THE 3 PREVIOUS SYMMETRIC FOCK MATRICES
C
C     CONVERGENCE ACCELERATIONS ARE SKIPPED IF WE ARE CONVERGING
C
C     WHY IABS ???
      IF((DAMPH.AND.ITER.GT.2)  .AND.  IABS(ITDIIS).EQ.1
     *          .AND.   .NOT.CVGING .AND.  IABS(ITDIDC).EQ.1)
     *   CALL DAMPD(DELE,DELE0,DEAVG,DAMP,DENTOL,DIFF,DIFFP,DMPTLC)
      IF(DAMP .LT. DMPCUT) DAMP = DMPCUT
C
      IF((DAMPH.OR.EXTRAH) .AND. IABS(ITDIIS).EQ.1 .AND. .NOT.CVGING
     *    .AND.  IABS(ITDIIS).EQ.1 ) THEN
         CALL EXTRAP(DELE,DAMP,DAMP0,X(LFAO),X(LWRK1),X(LWRK2),
     *               X(LWRK3),L1,L2,LL2,NDAFD,ITERV,1,1)
         IF(ICALP.EQ.0) ICAB=0
         IF(LUHF) THEN
            CALL EXTRAP(DELE,DAMP,DAMP0,X(LFAOB),X(LWRK1),
     *                  X(LWRK2),X(LWRK3),L1,L2,LL2,NDAFDB,ITERV,2,1)
            IF(ICBET.EQ.0) ICAB=0
         END IF
      END IF
C     ???
C
C     ----- DIRECT ENERGY MINIMIZATION DOES NOT WORK -----
C
      DEMOFF = .TRUE.
C
C     CURRENTLY VSHIFT DOES NOT WORK AT ALL
C     ----- OPTIONAL LEVEL SHIFTING -----
C     LWRK1,LWRK2 USED AS SYMMETRIC, LWRK3 AS SQUARE SCRATCH STORAGE
C
      IF(VSHIFT  .AND.  ITDIIS.EQ.1) THEN
         IF(DEMOFF) CALL DAREAD(IDAF,IODA,X(LVEC),LL3,15,0)
         CALL LEVELS(X(LFAO),X(LS),X(LVEC),X(LWRK1),X(LWRK2),X(LWRK3),
     *               X(LWRK),L0,L1,L2,L3,ITER,NA,0,DELE,DELE0,DIFF,
     *               ITERV,1,EXTRAH,CVGING)
      END IF
C
      IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LS),LL2,12,0)
C
      IF(DIIDCF) THEN
         STDCDI=.TRUE.
         CALL DAREAD(IDAF,IODA,X(LH1),LL2,11,0)
      END IF
C
C     ************************************
C     * START SUBSYSTEM LOOP 1 IN DC SCF *
C     ************************************
C
C     DYNAMIC LOAD BALANCING FOR DC-PARALLEL (NOT IMPLEMENTED)
C
CPA      DLBDC = IBTYP.EQ.1 .AND. GOPARR .AND. (.NOT. DIIDCF)
CPA      IF (DLBDC) THEN
CPA        CALL DDI_DLBRESET()
CPA        CALL DDI_DLBNEXT( MTSKDC )
CPA      END IF
C
CPA      CALL VCLR(X(LVECT),1,NLC3)
CPA      CALL VCLR(X(LEIGT),1,NLC1)
CPA      CALL VCLR(X(LWT),1,NLC1)
C
CPA      PRSAVE=GOPARR
CPA      GOPARR=.FALSE.
      CALL SEQREW(IDCVEC)
      CALL SEQREW(IDCQ)
      CALL SEQREW(IDCDM)
      CALL SEQREW(IDCDMO)
      DO 4000 ISUB=1,NSUBS
         IF(OUT) WRITE(IW,9610) ISUB
C
C     LOAD BALANCER
C
CPA         LTSKDC=ISUB-1
CPA         IF (DLBDC) THEN
CPA           DTSKDC = LTSKDC.EQ.MTSKDC
CPA         ELSE
CPA           DTSKDC = MOD(LTSKDC,NPROC).EQ.ME
CPA         END IF
C
CPA         IF (DTSKDC) THEN
C
C        *** DETERMINE LOCALIZATION REGION ***
C
         CALL LOCREG(ISUB)
C
         LSUB1=LNUM
         LSUB3=LSUB1*LSUB1
         LSUB2=(LSUB3+LSUB1)/2
         LSUB0=NLQMT(ISUB)
C
C        --- ALLOCATE MEMORY FOR THE ORBITALS
C               OF ISUB-TH LOCALIZATION REGION ---
C
         CALL VALFM(LOADFM)
         LEIGLC= LOADFM + 1
         LFAOLC= LEIGLC + LSUB1
         LVECLC= LFAOLC + LSUB2
         LQLC  = LVECLC + LSUB3
         LSLC  = LQLC   + LSUB3
         LWLC  = LSLC   + LSUB2
         LWRKLC= LWLC   + LSUB1
         LIWRKL= LWRKLC + LSUB3
         LDLC  = LIWRKL + LSUB1
         LAST  = LDLC   + LSUB2
C
         LEIGLB= LAST
         LFAOLB= LAST
         LVECLB= LAST
         LWLCB = LAST
         LDLCB = LAST
         IF(LUHF) THEN
            LEIGLB= LAST
            LFAOLB= LEIGLB + LSUB1
            LVECLB= LFAOLB + LSUB2
            LWLCB = LVECLB + LSUB3
            LDLCB = LWLCB  + LSUB1
            LAST  = LDLCB  + LSUB2
         END IF
C
         NEEDLC= LAST - LOADFM - 1
         CALL GETFM(NEEDLC)
C
C        SET LOCAL FOCK AND OVERLAP MATRICES
         CALL TRT2LC(X(LFAO),X(LFAOLC),L1,L2,LSUB1,LSUB2,'FOCK    ')
         IF(LUHF) CALL TRT2LC(X(LFAOB),X(LFAOLB),L1,L2,LSUB1,LSUB2,
     *                        'FOCKB   ')
         CALL TRT2LC(X(LS)  ,X(LSLC)  ,L1,L2,LSUB1,LSUB2,'OVERLAP ')
C
C        ----- TRANSFORM FOCK OPERATOR TO THE -Q- MATRIX BASIS -----
C        ----- DIAGONALIZE THE CURRENT FOCK MATRIX -----
C        ----- BACK-TRANSFORM THE EIGENVECTORS TO AO BASIS -----
C        FOCK OPERATOR IN ONB FOR DIAGONALIZATION MUST BE AT -LWRK1-
C
         IF(ABINIT) THEN
C
C           READ LOCAL DENSITY AND Q MATRICES
            CALL SQREAD(IDCDM,X(LDLC),LSUB2)
            CALL SQREAD(IDCQ ,X(LQLC),LSUB3)
C
C           SAVE OLD DENSITY MATRIX
            CALL SQWRIT(IDCDMO,X(LDLC),LSUB2)
            IF(LUHF) THEN
               CALL SQREAD(IDCDM,X(LDLCB),LSUB2)
               CALL SQWRIT(IDCDMO,X(LDLCB),LSUB2)
            END IF
C
C           --- LOCAL FOCK MATRIX IS EXTRAPOLATED BY DC-DIIS METHOD ---
C           THE LOCAL DC ERROR MATRIX ERR = FDS-SDF IS AT -LERRLC-
C           SQUARE FORMS OF LOCAL -F- ARE HELD AT -LWRKL1-
C           SQUARE FORMS OF LOCAL -S- ARE HELD AT -LWRKL2-
C           IF DC-DIIS GETS TURNED ON BY -DIIDCF-, ITDIDC WILL BE .GT. 1
C
            IF(DIIDCF) THEN
C
C              -- ALOCATE THE MEMORY FOR DC-DIIS,
C                   OR DIIS IN EACH LOCALIZATION REGION MATRIX
               CALL VALFM(LOADFM)
               LHCLC = LOADFM+1
               LWRKL1= LHCLC + LSUB2
               LWRKL2= LWRKL1+ LSUB3
               LERRLC= LWRKL2+ LSUB3
               LBDCDI= LERRLC+ LSUB3
               LPDCDI= LBDCDI+ MAXDII*MAXDII
               LXDCDI= LPDCDI+ MAXDII
               LAST  = LXDCDI+ MAXDII
               LERRLB= LAST
               IF(LUHF) LAST = LERRLB + LSUB3
C
               NEEDDI = LAST - LOADFM - 1
               CALL GETFM(NEEDDI)
C
               CALL DCOPY(LSUB2,X(LDLC),1,X(LWRKL1),1)
               CALL MRPMTX(X(LWRKL1),LSUB1,LNUMC)
C
C              -- CALCULATE VIRTUAL NUMBER OF ELECTRONS
C                 IN THE LOCALIZATION REGION
               ELENDI=TRACEP(X(LWRKL1),X(LSLC),LSUB1)
               ELENIV=ONE/ELENDI
C
C              -- FOCK MATRIX IS SCALED TO N_ELEC=1
               CALL TRT2LC(X(LFAO),X(LFAOLC),L1,L2,LSUB1,LSUB2,
     *                     'FOCK    ')
               CALL DSCAL(LSUB2,ELENIV,X(LFAOLC),1)
C
C              -- TRIANGULAR MATRIX IS EXPANDED TO SQUARE FORM
               CALL EXPND(X(LFAOLC),X(LWRKL1),LSUB1,0)
               CALL EXPND(X(LSLC),X(LWRKL2),LSUB1,0)
C
C              -- DEBUG PRINT
               IF(OUT) THEN
                  WRITE(IW,*) ISUB,' TH DENSITY MATRIX'
                  CALL PRTRILDC(0,X(LDLC),LSUB1)
                  WRITE(IW,*) ISUB,' TH SCALED FOCK MATRIX (SQUARE)'
                  CALL PRSQLDC(0,X(LWRKL1),LSUB1,LSUB1,LSUB1)
                  WRITE(IW,*) ISUB,' TH OVERLAP MATRIX (SQUARE)'
                  CALL PRSQLDC(0,X(LWRKL2),LSUB1,LSUB1,LSUB1)
               END IF
C
               CALL DIISER(X(LWRKL1),X(LDLC),X(LWRKL2),X(LERRLC),
     *                     X(LWRKLC),LSUB1,LSUB2,1,1)
C
C              -- DEBUG PRINT
               IF(OUT) THEN
                  WRITE(IW,*) ISUB,' TH LOCAL ERROR MATRIX'
                  CALL PRSQ(X(LERRLC),LSUB1,LSUB1,LSUB1)
               END IF
C
               IF(LUHF) THEN
                  CALL DCOPY(LSUB2,X(LDLCB),1,X(LWRKL1),1)
                  CALL MRPMTX(X(LWRKL1),LSUB1,LNUMC)
C
C                 -- CALCULATE VIRTUAL NUMBER OF ELECTRONS
C                    IN THE LOCALIZATION REGION
                  ELENDI=TRACEP(X(LWRKL1),X(LSLC),LSUB1)
                  ELENIV=ONE/ELENDI
C
C                 -- FOCK MATRIX IS SCALED TO N_ELEC=1
                  CALL TRT2LC(X(LFAOB),X(LFAOLB),L1,L2,LSUB1,LSUB2,
     *                        'FOCKB   ')
                  CALL DSCAL(LSUB2,ELENIV,X(LFAOLB),1)
C
C                 -- TRIANGULAR MATRIX IS EXPANDED TO SQUARE FORM
                  CALL EXPND(X(LFAOLB),X(LWRKL1),LSUB1,0)
C
C                 -- DEBUG PRINT
                  IF(OUT) THEN
                     WRITE(IW,*) ISUB,' TH BETA DENSITY MATRIX'
                     CALL PRTRILDC(0,X(LDLCB),LSUB1)
                     WRITE(IW,*) ISUB,' TH SCALED BETA FOCK (SQUARE)'
                     CALL PRSQLDC(0,X(LWRKL1),LSUB1,LSUB1,LSUB1)
                  END IF
C
                  CALL DIISER(X(LWRKL1),X(LDLCB),X(LWRKL2),X(LERRLB),
     *                        X(LWRKLC),LSUB1,LSUB2,1,1)
C
C                 -- DEBUG PRINT
                  IF(OUT) THEN
                     WRITE(IW,*) ISUB,' TH LOCAL BETA ERROR MATRIX'
                     CALL PRSQ(X(LERRLB),LSUB1,LSUB1,LSUB1)
                  END IF
               END IF
C
C              -- FORM DC-DIIS EXTRAPOLATED LOCAL FOCK MATRIX
C                   OF THE ISUB-TH LOCALIZATION REGION
               IF(ITER.GE.2)
     *           CALL DIISDC(SCFTYP,IW,ITDIDC,ISUB,X(LQLC),X(LFAOLC),
     *                       X(LFAOLB),X(LERRLC),X(LERRLB),X(LWRKL1),
     *                       X(LWRKL2),X(LXDCDI),X(LPDCDI),X(LBDCDI),
     *                       X(LIODCD),X(LIODLE),X(LWRKLC),LSUB1,LSUB2,
     *                       LSUB3,MAXIT,MAXIO,ERDCDI,NOTODC,MASPRT,
     *                       STDCDI,DODCDI)
C
C              -- FOCK MATRIX IS SCALED TO RECOVER N_ELEC
               CALL DSCAL(LSUB2,ELENDI,X(LFAOLC),1)
               IF(LUHF) CALL DSCAL(LSUB2,ELENDI,X(LFAOLB),1)
C
               CALL RETFM(NEEDDI)
            END IF
C
            CALL TFTRI(X(LWRK1),X(LFAOLC),X(LQLC),X(LWRK),
     *                 LSUB0,LSUB1,LSUB1)
            CALL SYMDIA(X(LWRK1),X(LVECLC),X(LEIGLC),X(LSCR),X(LIWRKL),
     *                  LSUB0,LSUB2,LSUB1)
            CALL TFSQB(X(LVECLC),X(LQLC),X(LWRK),LSUB0,LSUB1,LSUB1)
            IF(LUHF) THEN
               CALL TFTRI(X(LWRK1),X(LFAOLB),X(LQLC),X(LWRK),
     *                    LSUB0,LSUB1,LSUB1)
               CALL SYMDIA(X(LWRK1),X(LVECLB),X(LEIGLB),X(LSCR),
     *                     X(LIWRKL),LSUB0,LSUB2,LSUB1)
               CALL TFSQB(X(LVECLB),X(LQLC),X(LWRK),LSUB0,LSUB1,LSUB1)
            END IF
         ELSE
            CALL GLDIAG(LSUB1,LSUB1,LSUB1,X(LFAOLC),X(LSCR),X(LEIGLC),
     *                  X(LVECLC),IGERR,X(LIWRKL))
            IF(IGERR.NE.0) CALL ABRT
            IF(LUHF) THEN
               CALL GLDIAG(LSUB1,LSUB1,LSUB1,X(LFAOLB),X(LSCR),
     *                     X(LEIGLB),X(LVECLB),IGERR,X(LIWRKL))
               IF(IGERR.NE.0) CALL ABRT
            END IF
         END IF
C
C        SAVE SUBSYSTEM EIG AND VEC
         CALL DCOPY(LSUB1,X(LEIGLC),1,X(LEIGT+ILCST1(ISUB)-1),1)
         CALL SQWRIT(IDCVEC,X(LVECLC),LSUB3)
         IF(LUHF) THEN
            CALL DCOPY(LSUB1,X(LEIGLB),1,X(LEIGTB+ILCST1(ISUB)-1),1)
            CALL SQWRIT(IDCVEC,X(LVECLB),LSUB3)
         END IF
C
C        800 SHOULD NOT BE HERE???
C  800 CONTINUE
C
C        *** CALCULATE ORBITAL WEIGHT ***
C           W = SUM (P_(MU,NU)*C_(MU,I)*C_(NU,I)*S_(MU,NU)) OVER MU, NU
C
         CALL DCWCAL(X(LVECLC),X(LSLC),X(LWLC),LSUB1,LSUB2,LNUMC)
         CALL DCOPY(LSUB1,X(LWLC),1,X(LWT+ILCST1(ISUB)-1),1)
         IF(LUHF) THEN
            CALL DCWCAL(X(LVECLB),X(LSLC),X(LWLCB),LSUB1,LSUB2,LNUMC)
            CALL DCOPY(LSUB1,X(LWLCB),1,X(LWTB+ILCST1(ISUB)-1),1)
         END IF
C
C        -- DEBUG PRINT
         IF(OUT) THEN
            WRITE(IW,*) 'NEW ORBITALS'
            CALL PREVDC(ISUB,X(LVECLC),X(LEIGLC),LSUB0,LSUB1,LSUB1)
            IF(LUHF) THEN
               WRITE(IW,*) 'NEW ORBITALS (BETA)'
               CALL PREVDC(ISUB,X(LVECLB),X(LEIGLB),LSUB0,LSUB1,LSUB1)
            END IF
         END IF
C
         CALL RETFM(NEEDLC)
C
CPA         IF (DLBDC) CALL DDI_DLBNEXT( MTSKDC )
CPA         END IF       !  LOAD BALANCER
C
 4000 CONTINUE
C
CPA      GOPARR=PRSAVE
C
CPA      IF(GOPARR) THEN
CPA         CALL DDI_SYNC(11100)
CPA         CALL DDI_GSUMF(11101,X(LVECT),NLC3)
CPA         CALL DDI_GSUMF(11102,X(LEIGT),NLC1)
CPA         CALL DDI_GSUMF(11103,X(LWT),NLC1)
CPA      END IF
C
C     ---------------------------------
C     END OF SUBSYSTEM LOOP 1 IN DC SCF
C     ---------------------------------
C
C     SAVE EIGENVALUES AND ORBITAL WEIGHTS IN FILES
      CALL SEQREW(IDCEIG)
      CALL SEQREW(IDCW)
      CALL SQWRIT(IDCEIG,X(LEIGT),NLC1)
      CALL SQWRIT(IDCW  ,X(LWT)  ,NLC1)
      IF (LUHF) THEN
         CALL SQWRIT(IDCEIG,X(LEIGTB),NLC1)
         CALL SQWRIT(IDCW  ,X(LWTB)  ,NLC1)
      END IF
C
C     *** DETERMINATION OF FERMI LEVEL ***
C
      CALL TSECND(TFRMI0)
      FRMLV=FRMLVA
      CALL FRMLEV(X(LEIGT),X(LWT),X(LKEGTS),X(LKTP),NLC1,ELENDC,
     *            NA,FRMLV,OUT)
      FRMLVA=FRMLV
      IF(LUHF) THEN
         FRMLV=FRMLVB
         CALL FRMLEV(X(LEIGTB),X(LWTB),X(LKEGTS),X(LKTP),NLC1,ELENDC,
     *               NB,FRMLV,OUT)
         FRMLVB=FRMLV
      END IF
      CALL TSECND(TFRMI1)
C
C    800 ???
  800 CONTINUE
C    ???
C
C     ----- FORM THE NEW DENSITY MATRIX, AND ITS MAXIMUM CHANGE -----
C     OLD TOTAL DENSITY IS COPIED TO -LWRK1-, AS A SYMMETRIC MATRIX
C
      CALL DCOPY(L2,X(LD),1,X(LWRK1),1)
      IF(LUHF) CALL DCOPY(L2,X(LDB),1,X(LWRK3),1)
C
C     ************************************
C     * START SUBSYSTEM LOOP 2 IN DC SCF *
C     ************************************
C
C     DYNAMIC LOAD BALANCING FOR DC-PARALLEL (NOT IMPLEMENTED)
C
CPA      DLBDC = IBTYP.EQ.1 .AND. GOPARR
CPA      IF (DLBDC) THEN
CPA        CALL DDI_DLBRESET()
CPA        CALL DDI_DLBNEXT( MTSKDC )
CPA      END IF
C
CPA      CALL VCLR(X(LDT),1,NLC2)
CPA      IF(DIIDCF) CALL VCLR(X(LDTDCD),1,NLC2)
C
CPA      PRSAVE=GOPARR
CPA      GOPARR=.FALSE.
C
      CALL SEQREW(IDCDM)
      CALL SEQREW(IDCVEC)
      DO 4100 ISUB=1,NSUBS
         IF(OUT) WRITE(IW,9610) ISUB
C
C     LOAD BALANCER
C
CPA         LTSKDC=ISUB-1
CPA         IF (DLBDC) THEN
CPA           DTSKDC = LTSKDC.EQ.MTSKDC
CPA         ELSE
CPA           DTSKDC = MOD(LTSKDC,NPROC).EQ.ME
CPA         END IF
C
CPA         IF (DTSKDC) THEN
C
         CALL LOCREG(ISUB)
         LSUB1=LNUM
         LSUB3=LSUB1*LSUB1
         LSUB2=(LSUB3+LSUB1)/2
         LSUB0=NLQMT(ISUB)
C
         CALL VALFM(LOADFM)
         LEIGLC= LOADFM+1
         LOCCLC= LEIGLC+ LSUB1
         LDALC = LOCCLC+ LSUB1
         LVECLC= LDALC + LSUB2
         LAST  = LVECLC+ LSUB3
C
         NEEDLC = LAST - LOADFM - 1
         CALL GETFM(NEEDLC)
C
C        READ SUBSYSTEM EIGENVECTORS
         CALL SQREAD(IDCVEC,X(LVECLC),LSUB3)
C        SET SUBSYSTEM EIGENVALUES
         CALL DCOPY(LSUB1,X(LEIGT+ILCST1(ISUB)-1),1,X(LEIGLC),1)
C
         CALL VCLR(X(LOCCLC),1,LSUB1)
C
C        --- OCCUPATION NUMBERS IN DC METHOD ---
C                                  DC OCCUPANCIES
         I=1
         VAL=FRMLVA-X(LEIGLC+I-1)
         XFTOL= VLN10*FTOL/FRBETA
C
C        VALUE OF FERMI FUNCTION IS CLOSE TO ONE
         DO WHILE (I.LE.LSUB0 .AND. VAL.GT.XFTOL)
            X(LOCCLC+I-1) = TWO
            I=I+1
            VAL=FRMLVA-X(LEIGLC+I-1)
         END DO
C
C        VALUE OF FERMI FUNCTION IS NOT CLOSE TO EITHER ZERO OR ONE
         DO WHILE (I.LE.LSUB0 .AND. VAL.GE.-XFTOL)
            X(LOCCLC+I-1) = TWO * FERMIF(VAL,FRBETA)
            I=I+1
            VAL=FRMLVA-X(LEIGLC+I-1)
         END DO
C
         NOCDC=I-1
C
         IF(LUHF) CALL DSCAL(LSUB1,HALF,X(LOCCLC),1)
         IF(OUT) THEN
            WRITE (IW,9620)
            WRITE (IW,9624)
            WRITE (IW,9628) (X(LOCCLC+I-1),I = 1,LSUB0)
            CALL PREVDC(ISUB,X(LVECLC),X(LEIGLC),LSUB0,LSUB1,LSUB1)
         END IF
C
C        --- FORM NEW SUBSYSTEM DENSITY MATRIX ---
C
         CALL DMTX(X(LDALC),X(LVECLC),X(LOCCLC),NOCDC,LSUB1,LSUB1)
C
C        -- DEBUG PRINT
         IF(OUT) THEN
            WRITE(IW,*) ' NEW LOCAL DENSITY MATRIX'
            CALL PRTRILDC(ISUB,X(LDALC),LSUB1)
         END IF
C
         CALL SQWRIT(IDCDM,X(LDALC),LSUB2)
C
         IF(LUHF) THEN
            CALL SQREAD(IDCVEC,X(LVECLC),LSUB3)
C        SET SUBSYSTEM EIGENVALUES
            CALL DCOPY(LSUB1,X(LEIGTB+ILCST1(ISUB)-1),1,X(LEIGLC),1)
C
            CALL VCLR(X(LOCCLC),1,LSUB1)
C
C        --- OCCUPATION NUMBERS IN DC METHOD ---
C                                  DC OCCUPANCIES
            I=1
            VAL=FRMLVB-X(LEIGLC+I-1)
            XFTOL= VLN10*FTOL/FRBETA
C
C        VALUE OF FERMI FUNCTION IS CLOSE TO ONE
            DO WHILE (I.LE.LSUB0 .AND. VAL.GT.XFTOL)
               X(LOCCLC+I-1) = ONE
               I=I+1
               VAL=FRMLVB-X(LEIGLC+I-1)
            END DO
C
C        VALUE OF FERMI FUNCTION IS NOT CLOSE TO EITHER ZERO OR ONE
            DO WHILE (I.LE.LSUB0 .AND. VAL.GE.-XFTOL)
               X(LOCCLC+I-1) = FERMIF(VAL,FRBETA)
               I=I+1
               VAL=FRMLVB-X(LEIGLC+I-1)
            END DO
C
            NOCDC=I-1
C
            IF(OUT) THEN
               WRITE (IW,9620)
               WRITE (IW,9624)
               WRITE (IW,9628) (X(LOCCLC+I-1),I = 1,LSUB0)
               CALL PREVDC(ISUB,X(LVECLC),X(LEIGLC),LSUB0,LSUB1,LSUB1)
            END IF
C
C        --- FORM NEW SUBSYSTEM DENSITY MATRIX ---
C
            CALL DMTX(X(LDALC),X(LVECLC),X(LOCCLC),NOCDC,LSUB1,LSUB1)
C
C        -- DEBUG PRINT
            IF(OUT) THEN
               WRITE(IW,*) ' NEW LOCAL DENSITY MATRIX (BETA)'
               CALL PRTRILDC(ISUB,X(LDALC),LSUB1)
            END IF
C
            CALL SQWRIT(IDCDM,X(LDALC),LSUB2)
         END IF
C
         CALL RETFM(NEEDLC)
C
CPA         IF (DLBDC) CALL DDI_DLBNEXT( MTSKDC )
CPA         END IF       !  LOAD BALANCER
C
 4100 CONTINUE
C
CPA      GOPARR=PRSAVE
C
CPA      IF(GOPARR) THEN
CPA         CALL DDI_GSUMF(11104,X(LDT),NLC2)
CPA         IF(DIIDCF) CALL DDI_GSUMF(11105,X(LDTDCD),NLC1)
CPA      END IF
C
C     ---------------------------------
C     END OF SUBSYSTEM LOOP 2 IN DC SCF
C     ---------------------------------
C
C     CONSTRUCT TOTAL DENSITY MATRIX FROM SUBSYSTEM MATRICES
      CALL TRLC2T(IDCDM,X(LD),X(LDB),X(LWRK2),LL1,LL2,'DENSITY ',
     *     .TRUE.,LUHF)
C
C     *** MAXIMUM DIFFERENCE BETWEEN OLD AND NEW DENSITY MATRIX ***
C         DIFF : DIFFERENCE , DIFFP : PREVIOUS DIFFERENCE
C
      DIFFP = DIFF
      CALL DDIFF(X(LWRK1),X(LD),L2,DIFF)
      IF(LUHF) THEN
         CALL DDIFF(X(LWRK3),X(LDB),L2,DIFFB)
         DIFF = MAX(DIFF,DIFFB)
      END IF
      IF(OUT) THEN
         WRITE(IW,*) 'NEW DENSITY MATRIX'
         CALL PRTRIL(X(LD),L1)
         IF(LUHF) THEN
            WRITE(IW,*) 'NEW DENSITY MATRIX (BETA)'
            CALL PRTRIL(X(LDB),L1)
         END IF
         WRITE(IW,*) '*** END OF DEBUG OUTPUT FOR ITERATION',ITER
      END IF
C
C     ----- SAVE MO-S + DENSITY + ORBITAL ENERGIES -----
C
      CALL DAWRIT(IDAF,IODA,X(LD),L2,16,0)
      IF(LUHF) CALL DAWRIT(IDAF,IODA,X(LDB),L2,20,0)
C
      CALL TSECND(TITER2)
      TFOCK  = TFOCK  + (TITER1-TITER0)
      TFERMI = TFERMI + (TFRMI1-TFRMI0)
      TSOLVE = TSOLVE + (TITER2-TITER1)
      IF(ITER.EQ.1) TFOCK1 = TITER1 - TITER0
      TFOCKN = TITER1 - TITER0
C
C     ----- CHECK CONVERGENCE BEHAVIOR -----
C
  700 CONTINUE
      IF(SOSCF) THEN
         ERRORC = ORBGRD
      ELSE
         ERRORC = ERDIIS
         IF(DIIDCF.AND.DODCDI) ERRORC = ERDCDI
      END IF
      IF(MASPRT) THEN
         IF(DAMPH) THEN
            IF(DIRSCF) THEN
               WRITE(IW,9090) ITER,ICAB,NUMDEM,ETOT,DELE,DIFF,ERRORC,
     *                        FRMLVA,DAMP,NINT,NSCHWZ
            ELSE
               WRITE(IW,9090) ITER,ICAB,NUMDEM,ETOT,DELE,DIFF,ERRORC,
     *                        FRMLVA,DAMP
            END IF
         ELSE
            IF(DIRSCF) THEN
               WRITE(IW,9100) ITER,ICAB,NUMDEM,ETOT,DELE,DIFF,ERRORC,
     *                        FRMLVA,NINT,NSCHWZ
            ELSE
               WRITE(IW,9100) ITER,ICAB,NUMDEM,ETOT,DELE,DIFF,ERRORC,
     *                        FRMLVA
            END IF
         END IF
      END IF
C
      IF(MASPRT .AND. FONTYP.EQ.DIIER) THEN
         WRITE(IW,9095) FRBETA
      END IF
 9095 FORMAT(62X,'BETA =',F9.2)
C
      CALL FLSHBF(IW)
C
C     WILL THIS CURE MYSTERIOUS HANG-UPS?  (IN PARALLEL RUNS)
C     IT SEEMS THAT IN MIXED NODE ENVIRONMENT ONE MAY GET SOME NODE
C     CONVERGED AND OTHERS NOT (ACTUALLY, THIS IS SUPPOSED TO HOLD
C     TRUE NOT JUST FOR GDDI BUT ANY PARALLEL RUNS). TRY JUST GDDI 1ST.
C     POSSIBLE AGGRAVATION COMES FROM MINUTE NUMERIC ERRORS DUE TO
C     ADDING SMALL/LARGE NUMBERS (FROM FMO PROJECTORS).
C     SO THE PROBLEM IS POSSIBLY ENHANCED BY (BUT NOT LIMITED TO)
C     A) RUNNING FMO
C     B) USING SMART BLAS LIBRARIES THAT MAY GIVE SLIGHTLY DIFFERENT
C        ANSWERS ON DIFFERENT CPUS.
C     ISGDDI SHOULD REALLY BE GOPARR, PERHAPS, TO GET NON-FMO RUNS.
C
      IF(ISGDDI) THEN
         CALL DDI_BCAST(2422,'F',DIFF,1,MASTER)
         CALL DDI_BCAST(2423,'F',DELE,1,MASTER)
         IF(DODIIS) CALL DDI_BCAST(2424,'F',ERDIIS,1,MASTER)
         IF(DIIDCF) CALL DDI_BCAST(2425,'F',ERDCDI,1,MASTER)
      ENDIF
C
      ICALP = ICALP+1
      ICAB  = ICAB+1
      IF(LUHF) THEN
         ICBET = ICBET+1
      END IF
      CVDENS = (DIFF.LT.DENTOL  .AND.  ABS(DELE).LT.ETOL2) .OR.
     *         (DIFF.LT.DENTOL/FIVE)
      CVENGY = ABS(DELE).LT.ENGTOL  .AND.  DIFF.LT.DTOL2
      IF(DODIIS) CVDIIS = ERDIIS.LT.DIITOL  .AND.  DIFF.LT.DTOL2
C     DC-DIIS CONVERGENCE CHECK
      IF(DIIDCF) CVDIIS = ERDCDI.LT.DIITOL  .AND.  DIFF.LT.DTOL2
      CVGED  = (CVGING  .AND.  (CVDENS.OR.CVENGY.OR.CVDIIS))
      CVGED  = CVGED  .AND.  ISWOFF.EQ.0
      IF(NEORUN.EQ.1)
     *   CVGED  = (CVGING  .AND.  (CVDENS.AND.CVENGY.OR.CVDIIS))
      IF(NDFTFG.EQ.1) CVGED = CVGED  .AND.  GRIDTYP.EQ.FINE
      CVGING = CVDENS.OR.CVENGY.OR.CVDIIS
C
      IF(ISVP.EQ.1) THEN
         CVGED  = CVGED   .AND.  CVGSVP
         CVGING = CVGING  .AND.  CVGSVP
         CVGSVPNR = DIFF  .LT.  100.0D+00 * DENTOL
         CVGSVPDN = CVGING
         CVGSVPDN1 = CVGING
      END IF
C
C         TURN ON THE DFT IF PRELIMINARY SCF IS BECOMING CONVERGED.
C
      IDFTSWITCH_SAVE=IDFTSWITCH
      IF(ISWOFF.GT.0.AND.DIFF.LT.SWOFF) THEN
        IF(MASWRK) WRITE(IW,9355)
        DFTTYP(3)=HFSSAV
        NDFTFG=NDFTSV
        LCFLAG=LCFLAGS
        LRINT=LRINTS
        ISWOFF=0
        IDFTSWITCH=1
      END IF
C
C         DFT MUST SWITCH TO A TIGHTER GRID AS IT NEARS CONVERGENCE.
C
      IF(NDFTFG.EQ.1.AND.DIFF.LT.SWDFT) THEN
         IF(NRAD*NANGPT(1).LT.NRAD0*NANGPT0(1)  .AND.  .NOT.SG1) THEN
            IF(MASPRT) WRITE(IW,9330)
            CALL SWGRID
            GRIDTYP = FINE
            CALL DFTSET(X(IGRDDFT),0,.FALSE.)
            IDFTSWITCH=2
         END IF
      END IF
      IF(DIRSCF.AND.FDIFF.AND.ABS(DELE).LT.DIRTHR.AND.ISWDIR.GT.0) THEN
        ITDIR=ITDIR+1
        IF(ITDIR.GE.NITDIR) THEN
           ITDIR=0
           IF(MASWRK) WRITE(IW,9370)
           IDFTSWITCH=3
C          THIS IS NOT REALLY A DFT SWITCH BUT IT WILL DO THE TRICK
           ISWDIR=ISWDIR-1
        ENDIF
      ELSE
        ITDIR=0
      ENDIF
C
C       SWITCH FROM DIIS TO SOSCF!
C       OBVIOUSLY SUCH SWITCH CAN BE DONE ONLY ONCE IN ANY RUN.
C       NOTE THAT DENSITY DIFFERENCING (FDIFF) NEED NOT BE RESET.
C       POSTPONE SWITCH DIIS->SOSCF IF WE HAVE JUST SWITCHED SCF-->DFT
C       AND ARE USING DIRSCF+FDIFF (DOUBLE SWITCH IS NOT WORKING NOW).
C       THIS POSTPONEMENT WAS PUT IN SEPTEMBER 2009
C
C---  IF(DODIIS  .AND.  SWDIIS.GT.0.0D+00  .AND.  DIFF.LT.SWDIIS) THEN
      IF(DODIIS  .AND.  SWDIIS.GT.0.0D+00  .AND.  DIFF.LT.SWDIIS  .AND.
     *   (IDFTSWITCH.EQ.IDFTSWITCH_SAVE.OR.DIRSCF.AND..NOT.FDIFF)) THEN
        ITDIIS=1
        IF(.NOT.NOTOPN) CALL RACLOS(20,'DELETE')
        NOTOPN=.TRUE.
        DIIS1=.TRUE.
        DODIIS=.FALSE.
        SOSCF=.TRUE.
        MCONV = MCONV - 16 + 64
        IF(MASWRK) WRITE(IW,9380)
        IDFTSWITCH=4
      END IF
C
C         ANY SUCH SWITCH IN GRIDS OR CONVERGERS MUST RESET CONVERGERS,
C         AND PERHAPS RESET THE DIFFERENTIAL FOCK FORMATION.
C
      IF(IDFTSWITCH.NE.0) THEN
        CVGED=.FALSE.
        CVGING=.FALSE.
        CVENGY=.FALSE.
        CVDIIS=.FALSE.
        CVDENS=.FALSE.
        EXTRAH = .FALSE.
        DAMPH  = .FALSE.
C       WHY ORIGINALLY COMMENTED OUT???
C        DAMPH  = .FALSE.
        VSHIFT = .FALSE.
        DEM    = .FALSE.
        IF(DODIIS) THEN
          ITDIIS=1
          IF(.NOT.NOTOPN) CALL RACLOS(20,'DELETE')
          NOTOPN=.TRUE.
          DIIS1=.TRUE.
        END IF
        IF(DIIDCF) THEN
          ITDIDC=1
          IF(.NOT.NOTODC) CALL RACLOS(30,'DELETE')
          NOTODC=.TRUE.
          DODCDI=.FALSE.
        END IF
        IF(SOSCF) ITSO=0
        IF(ABINIT .AND. DIRSCF .AND. FDIFF .AND. IDFTSWITCH.NE.4) THEN
           IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LH1),LL2,11,0)
           CALL DAWRIT(IDAF,IODA,X(LH1),LL2,14,0)
           CALL VCLR(X(LWRK1),1,L2)
           IF(LUHF) THEN
             CALL DAWRIT(IDAF,IODA,X(LH1),LL2,18,0)
             CALL VCLR(X(LWRK3),1,L2)
           END IF
        END IF
        IDFTSWITCH=0
      END IF
C
C         IF WE ARE FINISHED, CANONICALIZE THE 2ND ORDER SCF ORBITALS
C
      IF(CVGED  .AND.  SOSCF) THEN
         IF(ABINIT) THEN
            IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LQ),LL3,45,0)
            CALL TFTRI(X(LWRK1),X(LFAO),X(LQ),X(LWRK),L0,L1,L1)
            CALL SYMDIA(X(LWRK1),X(LVEC),X(LEIG),X(LSCR),X(LIWRK),
     *                  L0,L2,L1)
            CALL TFSQB(X(LVEC),X(LQ),X(LWRK),L0,L1,L1)
         ELSE
            CALL GLDIAG(L1,L1,L1,X(LFAO),X(LSCR),X(LEIG),X(LVEC),
     *                  IGERR,X(LIWRK))
            IF(IGERR.NE.0) CALL ABRT
         END IF
         CALL DMTX(X(LD),X(LVEC),X(LOCC),NA,L1,L1)
         CALL SCFSAV(X(LVEC),X(LD),X(LEIG),NDAF,LL1,LL2,LL3)
      END IF
C
C     THE COUPLED CLUSTER PROGRAM WANTS THE FOCK MATRIX THAT
C     CORRESPONDS -EXACTLY- TO THE FINAL ORBITALS.  EVEN AT
C     CONVERGENCE THERE IS ALWAYS SOME RESIDUAL OFF-DIAGONAL
C     FOCK MATRIX ELEMENTS, SO WE MUST COMPUTE IT ONCE MORE.
C
      IF(CVGED  .AND.  CCTYP.NE.ANONE) THEN
         ICCFLG=ICCFLG+1
         IF(MASPRT) WRITE(IW,9105)
         IF(ABINIT  .AND.  DIRSCF  .AND.  FDIFF) THEN
            IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LH1),LL2,11,0)
            CALL DAWRIT(IDAF,IODA,X(LH1),LL2,14,0)
            CALL VCLR(X(LWRK1),1,L2)
         END IF
         GO TO 310
      END IF
  710 CONTINUE
C
      IF(CVGED) THEN
C
C     --- PCM DISPERSION INTERACTION PROCEDURE ---
C     PCM STAGE 2) SOLUTE AVERAGE TRANSITION FREQUENCY
C
         IF(IPCM.EQ.1  .AND.  IDP.EQ.1  .AND.  ISD.EQ.0) THEN
C                RESET ALL CONVERGER INFORMATION
            CVGED=.FALSE.
            CVGING=.FALSE.
            CVENGY=.FALSE.
            CVDIIS=.FALSE.
            CVDENS=.FALSE.
            EXTRAH = .FALSE.
            DAMPH  = .FALSE.
            VSHIFT = .FALSE.
            DEM    = .FALSE.
            IF(DODIIS) THEN
              ITDIIS=1
              IF(.NOT.NOTOPN) CALL RACLOS(20,'DELETE')
              NOTOPN=.TRUE.
              DIIS1=.TRUE.
            END IF
            IF(DIIDCF) THEN
              ITDIDC=1
              IF(.NOT.NOTODC) CALL RACLOS(30,'DELETE')
              NOTODC=.TRUE.
              DODCDI=.FALSE.
            END IF
            IF(SOSCF) ITSO=0
            IF(ABINIT .AND. DIRSCF .AND. FDIFF) THEN
               IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LH1),LL2,11,0)
               CALL DAWRIT(IDAF,IODA,X(LH1),LL2,14,0)
               CALL VCLR(X(LWRK1),1,L2)
            END IF
C                  TURN ON THE SOLUTE TERMS
            EVAC=ETOT
C
C           TRANSITION FREQUENCY CALCULATION IS NOT IMPLEMENTED
C            CALL WTRANSA(X(LEIG),L1)
            CALL JMATDIS(X(LS),X(LH1),X(LWRK1),X(LWRK2),X(LWRK3),L1,L2,
     *                   X(LAXYZCT),X(LAXYZCT+MXTS),X(LAXYZCT+MXTS*2),
     *                   X(LQSN))
            ISD=1
            GO TO 333
         END IF
C
C             DFT FOCK MATRIX LEFT ON DISK MUST INCLUDE EXCHANGE TERMS
         IF(NDFTFG.EQ.1.AND.ABINIT.AND.DIRSCF.AND.FDIFF) THEN
            CALL DAREAD(IDAF,IODA,X(LFAO),LL2,308,0)
            CALL DAWRIT(IDAF,IODA,X(LFAO),LL2,14,0)
            IF(LUHF) THEN
               CALL DAREAD(IDAF,IODA,X(LFAO),LL2,309,0)
               CALL DAWRIT(IDAF,IODA,X(LFAO),LL2,18,0)
            END IF
         END IF
C
         IF(CVDENS) THEN
            IF(MASPRT) WRITE(IW,9110)
            GO TO 400
         END IF
         IF(CVDIIS) THEN
            IF(MASPRT) WRITE(IW,9120)
            GO TO 400
         END IF
         IF(CVENGY) THEN
            IF(MASPRT) WRITE(IW,9130)
            GO TO 400
         END IF
      END IF
C
C     ----- EXIT IN CASE OF TIME LIMIT -----
C
      CALL TSECND(TIM1)
      TLEFT = TIMLIM - TIM1
      TIM0 = TIM1
      IF(TLEFT .GT. 2.0D+00*(TLEFTS-TLEFT)/ITER) GO TO 300
      IF(CVGING) THEN
         IF(MASPRT) WRITE(IW,9140)
         GO TO 400
      ELSE
         ETOT = ZERO
         EHF = -EN
         IF(MASPRT) WRITE(IW,9150)
         GO TO 400
      END IF
  300 CONTINUE
C
C           *********************
C     ***** END OF RHF ITERATIONS *****
C           *********************
C
C     FALLING OUT OF LOOP 300 MEANS WE HAVE FAILED TO CONVERGE
C
      IF(MASPRT) WRITE(IW,9160)
      ITER = MAXIT
  350 CONTINUE
      ETOT = ZERO
      EHF = -EN
C
C     BRANCH TO HERE ON SUCCESFUL CONVERGENCE
C
  400 CONTINUE
C
      TFITER = TFOCK/ITER
      TSITER = TSOLVE/ITER
C     TIME FOR FERMI ENERGY DETERMINATION
      TFRITE = TFERMI/ITER
      TSOLVE = TSOLVE - TFERMI
      IF(MASPRT  .AND.  ISD.EQ.1) THEN
         IF(DIRSCF) THEN
            WRITE(IW,9300) TFOCK,TFITER,TFOCK1,TFOCKN,TSOLVE,TSITER,
     *                     TFERMI,TFRITE
         ELSE
            WRITE(IW,9310) TFOCK,TFITER,TSOLVE,TSITER,TFERMI,TFRITE
         END IF
      END IF
C
C     ----- POSSIBLE AB INITIO - FRAGMENT EXCHANGE REPULSION
C     NOTE THAT OLD EFP2/QM CALL WAS DELETED FROM HERE IN SEPTEMBER 2009
C
      IF(LVLEFP.EQ.2) THEN
CCC         CALL EFHFDR(X(LHMO),X(LVMI),X(LVMITR),EEXCH,L1,CVGED)
      END IF
      ETOT = ETOT + EEXCH
C
C     ----- DISPERSION CORRECTIONS
C
      IF(DC) THEN
         CALL DFTD3(1,EDISP,DUMMY)
         ETOTD = ETOT
         IF(ETOT.NE.ZERO) ETOT = ETOT + EDISP
      END IF
C
C     ----- LOCAL RESPONSE DISPERSION CORRECTIONS
C
      IF(LRDFLG) THEN
         EDISP = ELRD6 + ELRD8 + ELRD10 + EMULT
         ETOTD = ETOT
         IF(ETOT.NE.ZERO) ETOT = ETOT + EDISP
         CALL PRTLRD
      END IF
C
C     ----- PRINT FINAL RESULTS -----
C
      IF(MASPRT) THEN
         IF(DHFUNC) THEN
            WRITE(IW,9171) METHOD(1:LENMTH),ETOT,ITER
            WRITE(IW,9172)
            WRITE(IW,9173)
            WRITE(IW,9174) 'ALPHA',FRMLVA
            IF(LUHF) WRITE(IW,9174) 'BETA ',FRMLVB
            IF(DFTTYP(1).NE.0.0D+00) THEN
             IF(LUHF) THEN
               WRITE(IW,9210) EXENA
               WRITE(IW,9220) EXENB
             ELSE
               WRITE(IW,9320) EXENA+EXENB
             END IF
            END IF
            IF(NDFTFG.EQ.1) THEN
               WRITE(IW,9320) EEXC
               WRITE(IW,9325) TOTELE
               IF (NEEDTAU) WRITE(IW,9327) TOTKIN
            END IF
C                THE -ELSE- IS THE USUAL OUTPUT SECTION
         ELSE
            WRITE(IW,9170) METHOD(1:LENMTH),ETOT,ITER
            WRITE(IW,9174) 'ALPHA',FRMLVA
            IF(LUHF) WRITE(IW,9174) 'BETA ',FRMLVB
            IF(DFTTYP(1).NE.0.0D+00) THEN
             IF(LUHF) THEN
               WRITE(IW,9210) EXENA
               WRITE(IW,9220) EXENB
             ELSE
               WRITE(IW,9320) EXENA+EXENB
             END IF
            END IF
            IF(NDFTFG.EQ.1) THEN
               WRITE(IW,9320) EEXC
               WRITE(IW,9325) TOTELE
               IF (NEEDTAU) WRITE(IW,9327) TOTKIN
            END IF
            IF(MPCTYP.NE.NONE  .AND.  ETOT.NE.ZERO) THEN
               DELTAH = ETOT*627.52791D+00 + ATHEAT
               WRITE(IW,9175) DELTAH
            END IF
         END IF
C              PRINT DISPERSION CORRECTIONS
         IF(DC) THEN
            WRITE(IW,9510) EDISP
            WRITE(IW,9500) ETOTD
         END IF
C
         IF(LRDFLG) THEN
            WRITE(IW,9550) ETOTD
         END IF
      END IF
C
C     ----- SPIN EXPECTATION VALUES -----
C     -LWRK1- USED AS TRIANGULAR SCRATCH SPACE
C
      IF(LUHF) THEN
         IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
         CALL SPIN(SZ,S2,X(LD),X(LDB),X(LS),X(LWRK1),X(LSCR),
     *             IA,NA,NB,L1,L2)
         IF(MASPRT) WRITE(IW,9948) SZ,S2
      END IF
C
C     OPTIONAL SUBSYSTEM ENERGY CALCULATION
      IF(MOD(NDCPRT,8).GE.4) THEN
C        READ PREVIOUS SUBSYSTEM DENSITY
         CALL TRLC2T(IDCDMO,X(LD),X(LDB),X(LWRK1),LL1,LL2,'OLD DENS',
     *               .TRUE.,LUHF)
C
         IF(MASWRK) THEN
            WRITE (IW,9630)
         END IF
         EDNNT  =ZERO
         EDKINT =ZERO
         EDNAET =ZERO
         EDNANT =ZERO
         EDTWOT =ZERO
         EDTOTT =ZERO
C
C        READ KINETIC ENERGY MATRIX
         CALL DAREAD(IDAF,IODA,X(LWRK2),LL2,13,0)
C
         CALL SEQREW(IDCDMO)
         DO ISUB=1,NSUBS
            IF(OUT) WRITE(IW,9610) ISUB
C
C           *** DETERMINE LOCALIZATION REGION ***
            CALL LOCREG(ISUB)
C
            LSUB1=LNUM
            LSUB3=LSUB1*LSUB1
            LSUB2=(LSUB3+LSUB1)/2
C
            CALL VALFM(LOADFM)
            LFAOLC= LOADFM + 1
            LDLC  = LFAOLC + LSUB2
            LHLC  = LDLC   + LSUB2
            LTLC  = LHLC   + LSUB2
            LAST  = LTLC   + LSUB2
C
            NEEDLC= LAST - LOADFM - 1
            CALL GETFM(NEEDLC)
C
C           CONSTRUCT SUBSYSTEM FOCK, H1, KINETIC MATRICES
            CALL TRT2LC(X(LFAO) ,X(LFAOLC),L1,L2,LSUB1,LSUB2,'FOCK    ')
            CALL TRT2LC(X(LH1)  ,X(LHLC)  ,L1,L2,LSUB1,LSUB2,'HCORE   ')
            CALL TRT2LC(X(LWRK2),X(LTLC)  ,L1,L2,LSUB1,LSUB2,'KINETIC ')
C
C           READ SUBSYSTEM DENSITY MATRIX AND MULTIPLY PARTITION MATRIX
            CALL SQREAD(IDCDMO,X(LDLC),LSUB2)
            CALL MRPMTX(X(LDLC),LSUB1,LNUMC)
C
C           SUBSYSTEM ENERGY COMPONENTS
            EDFOCK = TRACEP(X(LDLC),X(LFAOLC),LSUB1)
            EDCORE = TRACEP(X(LDLC),X(LHLC),LSUB1)
            EDKINE = TRACEP(X(LDLC),X(LTLC),LSUB1)
            EDNAEL = (EDCORE - EDKINE)*HALF
            EDTWOE = (EDFOCK - EDCORE)*HALF
C
C           SUBSYSTEM NUCLEAR ATTRACTION ENERGY
C           CONSTRUCT SPECIAL NUCLEAR ATTRACTION INTEGRAL MATRIX
            CALL TSUB(X(LWRK3),X(LWRK1),LL2,OUT,.TRUE.)
            EDNANU = TRACEP(X(LD),X(LWRK3),L1)*HALF
C
C           SUBSYSTEM NUCLEAR-NUCLEAR REPULSION ENERGY
            EDNUC  = ZERO
            DO IATMC=1,NLATC
               DO JATM=1,NAT
                  RR = ZERO
                  DO K = 1,3
                     RK = C(K,LOC2TA(IATMC))-C(K,JATM)
                     RR = RR+RK*RK
                  END DO
                  IF(RR.NE.ZERO) EDNUC=EDNUC
     *                       +HALF*ZAN(LOC2TA(IATMC))*ZAN(JATM)/SQRT(RR)
               END DO
            END DO
C
C           SUMMED SUBSYSTEM ENERGY AND VIRIAL RATIO
            EDTOT  = EDNUC+EDKINE+EDNAEL+EDNANU+EDTWOE
            EDVIRI = ONE - EDTOT/EDKINE
C
            IF(MASWRK) THEN
               WRITE (IW,9631) ISUB,EDNUC,EDKINE,EDNAEL,
     *                         EDNANU,EDTWOE,EDTOT,EDVIRI
            END IF
C
            EDNNT  = EDNNT  + EDNUC
            EDKINT = EDKINT + EDKINE
            EDNAET = EDNAET + EDNAEL
            EDNANT = EDNANT + EDNANU
            EDTWOT = EDTWOT + EDTWOE
            EDTOTT = EDTOTT + EDTOT
            EDVIRT = ONE - EDTOTT/EDKINT
C
            CALL RETFM(NEEDLC)
         END DO
C
         IF(MASWRK) THEN
            WRITE(IW,9632) EDNNT,EDKINT,EDNAET,EDNANT,EDTWOT,
     *                     EDTOTT,EDVIRT
         END IF
C
      END IF
C
C         SOLVATION OUTPUT FOR COSMO MODEL
C
      IF(ISEPS .AND. MPLEVL.EQ.0) CALL COSOCE(ETOT)
C
C         SOLVATION OUTPUT FOR PCM MODEL
C
      IF(IPCFP) THEN
         IPCM=1
         IEFP=1
         IPCFP=.FALSE.
      END IF
C
      QTT=0.0D+00
      DO I=0,NTS-1
C        QT=QSE(I)+QSN(I)+Q_FS(I)+Q_IND(I)
         QT=X(LQSE+I)+X(LQSN+I)+X(LQFS+I)+X(LQIND+I)
         QTT=QTT+QT
      ENDDO
      IF(IPCM.EQ.1  .AND.  MASPRT) THEN
         IF(IPCMIT.EQ.1) THEN
            WRITE(IW,*) ' '
            IF(ICOMP.EQ.0) WRITE(IW,'(A10,F18.10)') 'PCM ASC=',QTT
            IF(ICOMP.EQ.2) WRITE(IW,1120) QTT,QESC
         END IF
        WRITE(IW,'(A10,F18.10)') 'GCAVP  =',GCAVP/627.509541D+00
        WRITE(IW,'(A10,F18.10)') 'GDISP  =',GDISP/627.509541D+00
        WRITE(IW,'(A10,F18.10)') 'GREP   =', GREP/627.509541D+00
      END IF
C
      IF(MASPRT  .AND.  IPCM.EQ.1  .AND.  IPCMIT.EQ.0) THEN
         WRITE(IW,*)
         WRITE(IW,*)'-- INDUCED PCM ELECTRONIC CHARGES --'
         IF(ICOMP.EQ.0) WRITE(IW,1000) QET, TCH
         IF(ICOMP.EQ.1.OR.ICOMP.EQ.2) WRITE(IW,1100) QET, TCH, QETN
         IF(ICOMP.EQ.3) WRITE(IW,1110) QET, TCH, QESC, QETN
         WRITE(IW,*)'--------------------------------------'
      END IF
C
C         SOLVATION OUTPUT FOR SVP MODEL
C
      IF(ISVP.EQ.1  .AND.  MASWRK) THEN
         IF(LUHF) THEN
            CALL SVPOUT(X(LD),X(LDB),ETOT,ECHIP,NPRINT,'DCSCF ')
         ELSE
            CALL SVPOUT(X(LD),X(LD),ETOT,ECHIP,NPRINT,'DCSCF ')
         END IF
      END IF
C
C         SOLVATION OUTPUT FOR ONSAGER OR EFP MODELS
C
      IF(IZRFLS .OR. IEFP.EQ.1) THEN
      IF(MASPRT) WRITE(IW,9165) TMUX,TMUXD,TMUY,TMUYD,TMUZ,TMUZD
      END IF
C
C     ----- MODIFIED VIRTUAL ORBITAL CALCULATIONS ARE IGNORED -----
C
      IF(  MVOQ.NE.0 .AND. MASWRK) WRITE(IW,9970)
      IF(IACAVO.NE.0 .AND. MASWRK) WRITE(IW,9972)
      IF( IVVOS.NE.0 .AND. MASWRK) WRITE(IW,9974)
C
  510 CONTINUE
      IF(EXETYP.EQ.CHECK) GO TO 520
C
C     ----- ASSIGN SYMMETRY LABELS, AND PRINT FINAL RESULTS -----
C     -SYMBMO- AT X(LWRK)
C     NOTE THAT THE CALL TO SYMMOS WILL DESTROY THE -Q- MATRIX
C
      CALL TRLC2T(IDCDM,X(LD),X(LDB),X(LWRK1),LL1,LL2,'DENSITY ',
     *            .TRUE.,LUHF)
      CALL SEQREW(IDCEIG)
      CALL SQREAD(IDCEIG,X(LEIGT),NLC1)
      IF(MINMEM) THEN
         CALL DAREAD(IDAF,IODA,X(LS),LL2,12,0)
      END IF
C
      IF(MASWRK)THEN
         IF(MOD(NDCPRT,16).GE.8) THEN
            WRITE(IW,9650)
         ELSE
            WRITE(IW,9655)
         END IF
      END IF
C
      CALL SEQREW(IDCQ)
      CALL SEQREW(IDCVEC)
      DO ISUB=1,NSUBS
         IF (OUT) WRITE(IW,9500) ISUB
C
         CALL LOCREG(ISUB)
C
         LSUB1=LNUM
         LSUB3=LSUB1*LSUB1
         LSUB2=(LSUB3+LSUB1)/2
         LSUB0=NLQMT(ISUB)
C
         CALL VALFM(LOADFM)
         LEIGLC= LOADFM+1
         LSLC  = LEIGLC+ LSUB1
         LVECLC= LSLC  + LSUB2
         LQLC  = LVECLC+ LSUB3
         LSCRLC= LQLC  + LSUB3
         LWRKLC= LSCRLC+ 8*LSUB1
         LAST  = LWRKLC+ LSUB1
C
         NEEDLC = LAST - LOADFM - 1
         CALL GETFM(NEEDLC)
C
         CALL SQREAD(IDCQ,X(LQLC),LSUB3)
         CALL SQREAD(IDCVEC,X(LVECLC),LSUB3)
         CALL DCOPY(LSUB1,X(LEIGT+ILCST1(ISUB)-1),1,X(LEIGLC),1)
         CALL TRT2LC(X(LS),X(LSLC),L1,L2,LSUB1,LSUB2,'OVERLAP ')
         CALL SYMMOS(X(LWRKLC),X(LQLC),X(LSLC),X(LVECLC),X(LSCRLC),
     *               LSUB0,LSUB1,LSUB0,LSUB1)
C         CALL DCOPY(LSUB1,X(LWRKLC),1,X(LWRK1+ILCST1(ISUB)-1),1)
         IF(LUHF) THEN
            CALL SQREAD(IDCVEC,X(LVECLC),LSUB3)
            CALL DCOPY(LSUB1,X(LEIGTB+ILCST1(ISUB)-1),1,X(LEIGLC),1)
            CALL SYMMOS(X(LWRKLC),X(LQLC),X(LSLC),X(LVECLC),X(LSCRLC),
     *                  LSUB0,LSUB1,LSUB0,LSUB1)
C            CALL DCOPY(LSUB1,X(LWRKLC),1,X(LWRK1+ILCST1(ISUB)-1),1)
         END IF
C
         IF(MOD(NDCPRT,16).GE.8) THEN
           CALL PREVSDC(ISUB,X(LVECLC),X(LEIGLC),X(LWRKLC),
     *                  LSUB0,LSUB1,LSUB1,1)
         END IF
C
         CALL RETFM(NEEDLC)
      END DO
C
      IF(PRDENS) THEN
         WRITE(IW,9190)
         CALL PRTRIL(X(LD),L1)
      END IF
C
C     OPTIONAL DENSITY-OF-STATES PRINT-OUT
C
      IF(DOSITV.GT.ZERO .AND. MASWRK) THEN
         WRITE(IW,*)
         WRITE(IW,*) ' ##### DENSITY-OF-STATES CALCULATION #####'
         WRITE(IW,*)
         WRITE(IW,*) ' === SUBSYSTEM EIGENVALUES ==='
C
         DO ISUB=1,NSUBS
            CALL LOCREG(ISUB)
            LSUB1=LNUM
            LSUB3=LSUB1*LSUB1
            LSUB2=(LSUB3+LSUB1)/2
            WRITE(IW,*)
            WRITE(IW,'(5X,A10,I5)') 'SUBSYSTEM ',ISUB
            WRITE(IW,*)
            IMAX=0
            DO WHILE(IMAX.LT.LSUB1)
               IMIN = IMAX+1
               IMAX = IMAX+5
               IF(IMAX.GT.LSUB1) IMAX = LSUB1
               WRITE (IW,'(10X,5F14.8)')
     *                      (X(LEIGT+ILCST1(ISUB)+I-2), I=IMIN,IMAX)
            END DO
         END DO
C
         WRITE(IW,*)
         WRITE(IW,*) ' === SUBSYSTEM ORBITAL-WEIGHTS ==='
C
         DO ISUB=1,NSUBS
            CALL LOCREG(ISUB)
            LSUB1=LNUM
            LSUB3=LSUB1*LSUB1
            LSUB2=(LSUB3+LSUB1)/2
            WRITE(IW,*)
            WRITE(IW,'(5X,A10,I5)') 'SUBSYSTEM ',ISUB
            WRITE(IW,*)
            IMAX=0
            DO WHILE(IMAX.LT.LSUB1)
               IMIN = IMAX+1
               IMAX = IMAX+5
               IF(IMAX.GT.LSUB1) IMAX = LSUB1
               WRITE (IW,'(10X,5F14.8)')
     *                      (X(LWT+ILCST1(ISUB)+I-2), I=IMIN,IMAX)
            END DO
         END DO
C
         WRITE(IW,*)
         WRITE(IW,*) ' === CALCULATED DENSITY-OF-STATES ==='
C
C        ** CAUTION! **
C          IN THE DC METHOD, BDOS SHOULD BE EQUAL TO FRBETA.
         IF(BDOS.NE.FRBETA) THEN
            WRITE(IW,*) ' *** WARNING! *** '
            WRITE(IW,*) '   BETA USED TO PLOT DOS IS DIFFERENT',
     *                  ' FROM FRBETA USED IN DC CALCULATION.'
            WRITE(IW,*) '   BDOS = ',BDOS,'   FRBETA = ',FRBETA
         ELSE
            WRITE(IW,*) '   BDOS = FRBETA = ',FRBETA
         END IF
C
         CALL DOSPLT(X(LEIGT),X(LWT),DOSRGL,DOSRGR,DOSITV,BDOS,
     *               NE,NLC1)
C
         WRITE(IW,*)
         WRITE(IW,*) ' ## END OF DENSITY-OF-STATES CALCULATION ##'
C
      END IF
C
C     OPTIONAL DENSITY MATRIX PUNCH
      IF (MOD(NDCPRT,4).GE.2) THEN
         CALL TMDATE(TIMSTR)
         IF(MASWRK) WRITE(IP,8100) TIMSTR,TITLE,METHOD(1:LENMTH),
     *                             ETOT,EN,ITER
C
C        --- READ DENSITY MATRIX CORRESPONDING TO THE LAST ENERGY
         CALL TRLC2T(IDCDMO,X(LD),X(LDB),X(LWRK1),LL1,LL2,'OLD DENS',
     *               .TRUE.,LUHF)
         IF(MASWRK) THEN
           WRITE(IP, FMT='(5H $DM )')
           J0=1
           DO I0=1,L1
             MDI=MOD(I0,100)
             JCT=0
             DO J=1,I0,5
               JCT=JCT+1
               IF(JCT.GE.1000) JCT=JCT-1000
               JL=J0+MIN(I0-J,4)
               WRITE(IP,'(I2,I3,1P,5E15.8)') MDI,JCT,(X(LD+K-1),K=J0,JL)
               J0=JL+1
             END DO
           END DO
           IF(LUHF) THEN
             J0=1
             DO I0=1,L1
               MDI=MOD(I0,100)
               JCT=0
               DO J=1,I0,5
                 JCT=JCT+1
                 IF(JCT.GE.1000) JCT=JCT-1000
                 JL=J0+MIN(I0-J,4)
                 WRITE(IP,'(I2,I3,1P,5E15.8)') MDI,JCT,
     *                                         (X(LDB+K-1),K=J0,JL)
                 J0=JL+1
               END DO
             END DO
           END IF
           WRITE(IP, FMT='(5H $END)')
           WRITE(IP,*) ' ...... END OF DENSITY MATRIX OUTPUT ......'
           WRITE(IP,*)
         END IF
C        --- PUT BACK CURRENT DENSITY MATRIX
         CALL TRLC2T(IDCDM,X(LD),X(LDB),X(LWRK1),LL1,LL2,'DENSITY ',
     *               .TRUE.,LUHF)
      END IF
C
C     --- IF NEO RUN OUPUT NUCLEAR MOS ---
C
      IF(SOME .AND. NEORUN.EQ.1) THEN
         CALL NMOOUT(MPUNCH)
      END IF
C
C     *** CALCULATE ORBITAL DNESITY MATRIX ***
C           -IORBD- ORBITAL'S DENSITY MATRIX
C               IORBD : ORBITAL NUMBER (FROM THE FERMI LEVEL)
C                       NEGATIVE NUMBER FOR OCCUPIED ORBITAL
C                       POSITIVE NUMBER FOR UNOCCUPIED ORBITAL
C                        EX. HOMO: -1, LUMO: 1, ... ETC.
C
C     NOTE THAT THE CALL TO ORBDEN WILL DESTROY THE -D- AND -DT- MATRIX
C     (ORBITAL DENSITY MATRIX WILL BE WRITTEN ON -D- AND -DT-)
C
      NOCORB=NE/2
      NTHRUP=NUM-NOCORB
      NTHRLW=-NOCORB
      IF(IORBD.LT.NTHRLW .OR. IORBD.GT.NTHRUP) IORBD=0
C
      IF(IORBD.NE.0) THEN
         CALL ORBDEN(X(LEIGT),X(LWT),X(LKEGTS),X(LKTP),X(LD),
     *               L1,L2,IORBD,OUT)
         CALL DAWRIT(IDAF,IODA,X(LD),LL2,271,0)
      END IF
C
C     ----- TIDY UP AND EXIT -----
C
  520 CONTINUE
      IF(CVGED) IREST = 0
C
      IF(FT15OP) THEN
C          MORBID PROBLEM:
C       SEQOPN OPENS NFT15 ON SLAVES, BUT SEQCLO DOES NOT
C       CLOSE IT ON THEM!
        TDSKWRK = DSKWRK
        DSKWRK = .TRUE.
        CALL SEQCLO(NFT15,'DELETE')
        DSKWRK = TDSKWRK
      ENDIF
      FT15OP=.FALSE.
      IF(.NOT.NOTOPN) CALL RACLOS(20,'DELETE')
      NOTOPN=.TRUE.
      DIIS1=.TRUE.
      IF(.NOT.NOTODC) CALL RACLOS(30,'DELETE')
      NOTODC=.TRUE.
C
C     SAVE FMM DATA FOR DERIVATIVE CALCULATIONS
C
      IF (QFMM) THEN
         CALL DERCHK(NDER)
         IF (NDER.GT.0) THEN
          CALL DENWZP(SCFTYP,NCXYZ,X(LIYP),X(LINDX2),
     *       X(LIDXIJK),X(LIDXWS),X(LCXYZ),X(LIBS),X(LYZTBL),NTMPL,
     *       X(LYP),X(LZP),L2,X(LD),X(LDB),NTBOX,MAXWS,X(LYZPNT),
     *       X(LF),X(LG),X(LZLL),X(LCLM),X(LFLM),X(LIDXBOX),NSBOX,
     *       X(LISP),X(LIPP))
          CALL SHLDEN(SCFTYP,X(LD),X(LDB),DUMMY,X(LDSH),IA,L1,L2,NSH2,1)
          CALL WRTFMM(X(LYP),X(LZP),NP,NTMPL,NCXYZ,X(LIYP),
     *         X(LINDX2),X(LIDXIJK),X(LIDXWS),X(LIBS),
     *         X(LYZTBL),NTBOX,MAXWS,X(LYZPNT),X(LCLM),
     *         X(LIDXBOX),NSBOX,X(LISP),X(LIPP),X(LEBOX),
     *         X(LMBOX),X(LINDX),X(LNUMWS),X(LDSH),X(LSLIST),
     *         X(LIDXSHL),X(LSLN),X(LXINTS),NSHELL,NSH2,NSHL2,NS)
         END IF
      END IF
      CALL RETFM(NEED)
C
      IF(RUNTYP.EQ.MOROKM) CALL EDRHF(NUM,NA,NB,NE,E0)
C
      IF(MASPRT)
     *   WRITE(IW,FMT='('' ...... END OF RHF CALCULATION ......'')')
      CALL TIMIT(1)
      RETURN
C
 8100 FORMAT('--- DC DENXITY MATRIX --- GENERATED AT ',3A8/10A8/
     *       'E(',A,')=',F20.10,', E(NUC)=',F16.10,',',I5,' ITERS')
C
 9000 FORMAT(/10X,28(1H-)/10X,A12,' SCF CALCULATION'/10X,28(1H-))
 9002 FORMAT(/15X,'$DANDC OPTIONS'/15X,14(1H-)/
     * 11X,'FRBETA=',F8.2,5X,'MXITDC=',I8   ,5X,'FTOL  =',F8.3/
     * 11X,'PEXDII=',F8.4,5X,'EXTDII=',E10.3,3X,'(',A8,'IS USED)'/
     * 11X,'DIITYP=',A8  ,5X,'DIIDCF=',L8   ,5X,'ETHRDC=',E10.3/
     * 11X,'NDCPRT=',I8  ,5X,'IORBD =',I8/
     * 11X,'DOSITV=',F8.4,5X,'DOSRGL=',F8.3 ,5X,'DOSRGR=',F8.3)
 9003 FORMAT(/15X,'OPTIONS REGARDING FON'/15X,21(1H-)/
     * 11X,'FONTYP=',A8/
     * 11X,'BETINI=',F10.3,5X,'BETFIN=FRBETA=',F10.3/
     * 11X,'FONSTA=',E10.3,5X,'FONEND=',E10.3)
 9005 FORMAT(/1X,'OVERLAPPING STORAGE FOR H,S,Q MATRICES,',
     *        1X,'TO SAVE',I10,' WORDS.'/1X,'ADDING THIS AMOUNT',
     *        1X,'MAY IMPROVE EFFICIENCY SOMEWHAT.')
 9006 FORMAT(1X,'* * * ERROR * * *'/
     *       1X,'IT IS ILLOGICAL FOR THE GRID SWITCHING VALUE',
     *          ' $DFT SWITCH=',1P,E7.1/
     *       1X,'    TO BE SMALLER THAN THE DENSITY CONVERGEN',
     *          'CE $SCF CONV=',1P,E7.1)
 9007 FORMAT(5X,'NUCLEI-NUCLEAR POLARIZATION CHARGE INTERACTION = '
     *         ,F20.10,/
     *      ,5X,'TOTAL NUCLEAR ENERGY                           = '
     *         ,F20.10)
 9008 FORMAT(/1X,'AB INITIO/EFP2 EX-REP NOT CODED FOR',
     *           '  DIVIDE=AND-CONQUER SCF')
 9010 FORMAT(/5X,'NUCLEAR ENERGY = ',F20.10/
     *       5X,'MAXIT =',I5,5X,'NPUNCH=',I5/
     *       5X,'EXTRAP=',L1,'  DAMP=',L1,'  SHIFT=',L1,
     *          '  RSTRCT=',L1,'  DIIS=',L1,'  DEM=',L1,'  SOSCF=',L1)
 9012 FORMAT(5X,'DENSITY MATRIX CONV=',1P,E10.2)
 9013 FORMAT(5X,'    DENSITY MATRIX CONVERGENCE THRESHOLD=',1P,E10.2/
     *       5X,'COARSE -> FINE DFT GRID SWITCH THRESHOLD=',1P,E10.2,
     *          ' (SWITCH IN $DFT)'/
     *       5X,'              HF -> DFT SWITCH THRESHOLD=',1P,E10.2,
     *          ' (SWOFF IN $DFT)')
 9015 FORMAT(5X,'VTSCAL=',L1,'  MAXVT=',I3,'  VTCONV=',F12.8)
 9017 FORMAT(5X,'SOSCF WILL OPTIMIZE',I8,' ORBITAL ROTATIONS, SOGTOL=',
     *          F8.3)
 9020 FORMAT(5X,'MEMORY REQUIRED FOR RHF ITERS=',I10,' WORDS.')
 9030 FORMAT(/1X,'DIRECT SCF CALCULATION, SCHWRZ=',L1,'   FDIFF=',L1,
     *       ',  DIRTHR=',E10.2,' NITDIR=',I2)
 9035 FORMAT(1X,'QFMM WILL USE ADDITIONAL MEMORY OF',I10,' WORDS')
 9039 FORMAT(/1X,'### ERROR! NBUFFMO SHOULD BE 0 IN DC CALCULATION')
 9045 FORMAT(/' ITER EX DEM     TOTAL ENERGY        E CHANGE  DENSITY ',
     *        'CHANGE    DIIS ERROR    EPS_F       DAMPING        ')
 9047 FORMAT(/' ITER EX DEM     TOTAL ENERGY        E CHANGE  DENSITY ',
     *        'CHANGE  DC-DIIS ERROR   EPS_F       DAMPING        ')
 9055 FORMAT(/108X,'NONZERO     BLOCKS'/
     *        ' ITER EX DEM     TOTAL ENERGY        E CHANGE  DENSITY ',
     *        'CHANGE    DIIS ERROR    EPS_F       DAMPING        ',
     *        'INTEGRALS    SKIPPED')
 9057 FORMAT(/108X,'NONZERO     BLOCKS'/
     *        ' ITER EX DEM     TOTAL ENERGY        E CHANGE  DENSITY ',
     *        'CHANGE  DC-DIIS ERROR   EPS_F       DAMPING        ',
     *        'INTEGRALS    SKIPPED')
 9065 FORMAT(/' ITER EX DEM     TOTAL ENERGY        E CHANGE  DENSITY ',
     *        'CHANGE    DIIS ERROR    EPS_F')
 9067 FORMAT(/' ITER EX DEM     TOTAL ENERGY        E CHANGE  DENSITY ',
     *        'CHANGE  DC-DIIS ERROR   EPS_F')
 9075 FORMAT(/92X,'NONZERO     BLOCKS'/
     *        ' ITER EX DEM     TOTAL ENERGY        E CHANGE  DENSITY ',
     *        'CHANGE    DIIS ERROR    EPS_F      INTEGRALS    SKIPPED')
 9077 FORMAT(/92X,'NONZERO     BLOCKS'/
     *        ' ITER EX DEM     TOTAL ENERGY        E CHANGE  DENSITY ',
     *        'CHANGE  DC-DIIS ERROR   EPS_F      INTEGRALS    SKIPPED')
 9080 FORMAT(/8H EHF1 = ,F20.12,8H EHF2 = ,F20.12,7H EHF = ,F20.12)
 9090 FORMAT(1X,3I3,F20.10,F17.10,2F14.9,F9.4,F16.9,I15,I11)
 9100 FORMAT(1X,3I3,F20.10,F17.10,2F14.9,F9.4,I15,I11)
 9105 FORMAT(/1X,'RHF HAS CONVERGED, NOW COMPUTING EXACT TOTAL FOCK',
     *           ' MATRIX'/
     *        1X,'FOR USE DURING THE COUPLED CLUSTER CALCULATION',
     *           ' THAT FOLLOWS.')
 9110 FORMAT(/10X,17(1H-)/10X,17HDENSITY CONVERGED/10X,17(1H-))
 9120 FORMAT(/10X,14(1H-)/10X,14HDIIS CONVERGED/10X,14(1H-))
 9130 FORMAT(/10X,16(1H-)/10X,16HENERGY CONVERGED/10X,16(1H-))
 9140 FORMAT(/1X,'... SCF HAS ALMOST CONVERGED BUT ROUTINE STOPPED',
     *           ' FOR TIMLIM BEFORE ULTIMATE CYCLE ...')
 9150 FORMAT(/1X,'SCF IS UNCONVERGED, TOO LITTLE TIME LEFT')
 9160 FORMAT(/1X,'SCF IS UNCONVERGED, TOO MANY ITERATIONS')
 9165 FORMAT(/10X,'INDUCED DIPOLE',5X,'ATOMIC UNITS',10X,'DEBYE',
     *       /10X,'      X(IND)  ',5X,F12.5,5X,F12.5,
     *       /10X,'      Y(IND)  ',5X,F12.5,5X,F12.5,
     *       /10X,'      Z(IND)  ',5X,F12.5,5X,F12.5)
 9170 FORMAT(/1X,'FINAL ',A,' ENERGY IS',F20.10,' AFTER',I4,
     *           ' ITERATIONS')
 9171 FORMAT(/1X,'PURE DFT ',A,' ENERGY IS',F20.10,' AFTER',I4,
     *           ' ITERATIONS')
 9172 FORMAT(1X,'THIS IS ONLY THE DFT PART OF THE TOTAL ENERGY,')
 9173 FORMAT(1X,'LOOK AFTER FOR THE TOTAL ENERGY WITH MP2 ADDITION')
 9174 FORMAT( 1X,'THE ',A5,' FERMI LEVEL IS',F20.10)
 9175 FORMAT(/1X,'HEAT OF FORMATION IS',F15.5,' KCAL/MOL')
 9510 FORMAT(1X,'GRIMME''S DISPERSION ENERGY                     =',
     *           F20.10)
 9500 FORMAT(1X,'ENERGY WITHOUT GRIMME''S DISPERSION CORRECTION IS',
     *           F20.10)
 9550 FORMAT(1X,'ENERGY WITHOUT LRD CORRECTION IS',F20.10)
 9190 FORMAT(/10X,14(1H-)/10X,14HDENSITY MATRIX/10X,14(1H-))
 9200 FORMAT(10X,15(1H-),'START SECOND ORDER SCF',15(1H-))
 9210 FORMAT(1X,'ALPHA DFT EXCHANGE + CORRELATION ENERGY = ',F20.10)
 9220 FORMAT(1X,' BETA DFT EXCHANGE + CORRELATION ENERGY = ',F20.10)
 9300 FORMAT(5X,'TIME TO FORM FOCK OPERATORS  =',F10.1,' SECONDS (',
     *          F10.1,' SEC/ITER)'/
     *       5X,'FOCK TIME ON FIRST ITERATION =',F10.1,
     *          ', LAST ITERATION=',F10.1/
     *       5X,'TIME TO SOLVE SCF EQUATIONS  =',F10.1,' SECONDS (',
     *          F10.1,' SEC/ITER)'/
     *       5X,'TIME TO DETERMINE FERMI LEVEL=',F10.1,' SECONDS (',
     *          F10.1,' SEC/ITER)')
 9310 FORMAT(5X,'TIME TO FORM FOCK OPERATORS  =',F10.1,' SECONDS (',
     *          F10.1,' SEC/ITER)'/
     *       5X,'TIME TO SOLVE SCF EQUATIONS  =',F10.1,' SECONDS (',
     *          F10.1,' SEC/ITER)'/
     *       5X,'TIME TO DETERMINE FERMI LEVEL=',F10.1,' SECONDS (',
     *          F10.1,' SEC/ITER)')
 9320 FORMAT(1X,'DFT EXCHANGE + CORRELATION ENERGY = ',F20.10)
 9325 FORMAT(1X,'TOTAL ELECTRON NUMBER             = ',F20.10)
 9326 FORMAT(/10X,'TOTAL KINETIC ENERGY DENSITY      = ',F20.10,1X/)
 9327 FORMAT(1X,'TOTAL KINETIC ENERGY DENSITY      = ',F20.10,1X)
 9330 FORMAT(1X,'DFT CODE IS SWITCHING BACK TO THE FINE GRID')
 9335 FORMAT(/1X,'DFT CODE IS SWITCHING FROM THE FINE GRID NRAD=',I3,
     *           ',  NLEB=',I5/
     *       22X,'TO THE COARSE GRID NRAD0=',I3,', NLEB0=',I5)
 9340 FORMAT(/1X,'DFT CODE IS SWITCHING FROM THE FINE GRID NRAD=',I4,
     *          ',  NTHE, NPHI=',2I3/
     *       22X,'TO THE COARSE GRID NRAD0=',I3,
     *          ', NTHE0,NPHI0=',2I3)
 9350 FORMAT(1X,'DFT IS SWITCHED OFF, PERFORMING PURE SCF UNTIL SWOFF',
     *          ' THRESHOLD IS REACHED.')
 9355 FORMAT(1X,'CONVERGED TO SWOFF, SO DFT CALCULATION IS NOW',
     *          ' SWITCHED ON.')
 9370 FORMAT(1X,'ENERGY IS NOT DECREASING: FOCK MATRIX WILL BE ',
     *          'RECOMPUTED.')
 9380 FORMAT(9X,'SWDIIS THRESHOLD HAS BEEN REACHED:',
     *          ' SWITCHING DIIS OFF.')
C
 9600 FORMAT(5X,'DC-DIIS IS TURNED ON'/)
 9610 FORMAT(/5X,'*** IN SUBSYSTEM ',I5,' ***')
 9620 FORMAT(/30X,22(1H-)/30X,'NEW LOCAL ORBITALS'/
     *        30X,22(1H-))
 9624 FORMAT(/30X,'ASSIGNED OCCUPANCIES'/)
 9628 FORMAT(15X,5F11.6)
 9630 FORMAT(/10X,16(1H-)/10X,'SUBSYSTEM ENERGY'/10X,16(1H-)/
     *    /13X,"E_NN        E_KIN      E_NE(ELEC)   E_NE(NUC)     ",
     *    "E_2ELEC         E_TOT      (  VIRIAL )")
 9631 FORMAT(     I5,2X,5F13.6,F17.8," (",F9.6,")")
 9632 FORMAT(/" TOTAL ",5F13.6,F17.8," (",F9.6,")")
 9650 FORMAT(/10X,22(1H-)/10X,22HSUBSYSTEM EIGENVECTORS/10X,22(1H-)/)
 9655 FORMAT(/1X,'SUBSYSTEM MO IS AVAILABLE BY ADDING 8 TO ',
     *           'NDCPRT IN $DANDC'/)
C
 9900 FORMAT(/1X,'### ERROR! '/
     *        1X,'SCF-MI CAN NOT BE PERFORMED WITH DC SCF')
 9910 FORMAT(/1X,'### ERROR! '/
     *        1X,'DC CALCULATION DOES NOT SUPPORT RUNTYP=MOROKUMA')
 9920 FORMAT(/1X,'### ERROR! '/
     *        1X,'GRID-FREE DFT CAN NOT BE PERFORMED WITH DC SCF')
 9930 FORMAT(/1X,'### ERROR! '/
     *        1X,'MO-S CANNOT BE FROZEN IN DC SCF')
 9935 FORMAT(/1X,'### ERROR! '/
     *        1X,'ORBITAL ROTATION RESTRICTION IS SENSELESS IN DC SCF')
 9940 FORMAT(/1X,'### ERROR! '/
     *        1X,'IDENAO SHOULD BE 1 IN DC SCF')
 9948 FORMAT(/10X,20(1H-)/10X,12HSPIN SZ   = ,F8.3/
     *        10X,12HS-SQUARED = ,F8.3/10X,20(1H-))
 9950 FORMAT(/1X,'### ERROR! '/
     *        1X,'DIRECT ENERGY MINIMIZATION DOES NOT WORK IN DC SCF')
 9954 FORMAT(/1X,'### ERROR! '/
     *        1X,'SECOND-ORDER SCF DOES NOT WORK IN DC SCF')
 9958 FORMAT(/1X,'### ERROR! '/
     *        1X,'LEVEL SHIFTING DOES NOT WORK IN DC SCF')
 9970 FORMAT(/1X,'--- WARNING! '/
     *        1X,'ORBITAL MODIFICATION (MVOQ) IS IGNORED IN DC')
 9972 FORMAT(/1X,'--- WARNING! '/
     *        1X,'ORBITAL MODIFICATION (ACAVO) IS IGNORED IN DC')
 9974 FORMAT(/1X,'--- WARNING! '/
     *        1X,'ORBITAL MODIFICATION (VVOS) IS IGNORED IN DC')
C
 1000 FORMAT(1X,'CALCULATED ',F10.5,' THEORETICAL ',
     * F10.5,' NOT RENORMALIZED',F10.5)
 1100 FORMAT(1X,'CALCULATED ',F10.5,' THEORETICAL ',
     * F10.5,' RENORMALIZED',F10.5)
 1110 FORMAT(1X,'CALCULATED',F10.5,' (THEOR= ',
     * F10.5,')  ESCAPED',F10.5,' FINAL', F10.5)
 1120 FORMAT(2X,'PCM ASC=',F18.10,' ( UNNORMALIZED=',F18.10,' )')
C
      END
C
C*MODULE DCSCF   *DECK DIISDC
C        MODIFIED FROM DIIS
      SUBROUTINE DIISDC(SCFTYP,IW,ITDIIS,ISUB,Q,DA,DB,ERR,ERRB,WRK,WRKB,
     *                  X,IPVT,B,IODIIS,IODCLE,SCR,L1,L2,L3,MAXIT,MAXIO,
     *                  ERDCDI,NOTOPN,MASOUT,STDCDI,DODCDI)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL NOTOPN,DBG,GOPARR,DSKWRK,MASWRK,GPSAVE,MASOUT
      LOGICAL STDCDI,DODCDI
C
      COMMON /DIISSO/ SOGTOL,ETHRSH,MAXDII,IRAF
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      LOGICAL DCFLG,DIIDCF,DIIQTR
      COMMON /DCDIIS/ EXTDII,PEXDII,ETHRDC,DIITYP,NDCDIS,IRAFDC,DIIDCF,
     *                DIIQTR
      COMMON /DCOPT / SUBTYP,BUFTYP,SUBLNG,BUFRAD,NDCPRT,NSUBS,DCFLG
C
      DIMENSION Q(L3),DA(L2),DB(L2),ERR(L3),WRK(L3),IODIIS(MAXIO),
     *          IODCLE(MAXIO),X(MAXDII),IPVT(MAXDII),B(MAXDII*MAXDII),
     *          SCR(L1),ERRB(L3)
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
      DATA DBUG,DBUGME/8HDEBUG   ,8HDIIS    /
      DATA UHF/8HUHF     /
C
C                 THIS ROUTINE PERFORMS THE
C        *** DIRECT INVERSION IN THE ITERATIVE SUBSPACE ***
C                 FOR DIVIDE-AND-CONQUER METHOD
C        INTERPOLATION USING THE CURRENT AND PREVIOUS LOCAL DENSITY
C        MATRICES (OF THE ISUB-TH LOCALIZATION REGION) TO SPEED UP
C        THE CONVERGENCE OF THE SCF.
C
C        (CONVENTIONAL DIIS METHOD)
CCCC        THE METHOD IS P.PULAY, J.COMPUT.CHEM., 3, 556-560 (1982).
CCCC        BUT SEE ALSO P.PULAY, CHEM.PHYS.LETT., 73, 393-398 (1980),
CCCC        T.P.HAMILTON, P.PULAY, J.CHEM.PHYS., 84, 5728-5734 (1986).
CCCC
CCCC        WRITTEN BY BRENDA LAM IN APRIL 1986 AT U. HOUSTON
CCCC        SIMPLIFIED BY MWS IN SEPTEMBER 1991 AT NDSU.
C
C     ON ENTRY, -DA- AND -DB- ARE THE CURRENT LOCAL DENSITY MATRICES.
C               -ERR- AND -ERRB- ARE THE CURRENT LOCAL ERROR MATRICES,
C               EXPRESSED IN THE AO BASIS.
C     ON EXIT,  -ERR- AND -ERRB- ARE DESTROYED, WHILE -DA- AND -DB- WILL
C               CONTAIN INTERPOLATED LOCAL DENSITIES (IF ITDIIS.GT.2)
C
C     ITDIIS.EQ.1 MEANS DIIS IS NOT YET TURNED ON
C     ITDIIS.EQ.2 MEANS DIIS HAS BEEN INITIATED
C     ITDIIS.GT.2 MEANS A DIIS INTERPOLATION OF ITDIIS-1
C                 LOCAL DENSITY MATRICES (OF THE ISUB-TH LOCALIZATION
C                 REGION)  HAS BEEN PERFORMED.
C
      DBG = (NPRINT.EQ.5  .OR.  EXETYP.EQ.DBUG  .OR.  EXETYP.EQ.DBUGME)
     *      .AND. MASWRK
C
C     DC-DIIS DATA IS SAVED ON DIRECT FILE -IRAF- IN CYCLIC ORDER,
C      2*(ISUB-1)   *MAXDII
C                + 1,2,3,...,MAXDII = LAST MAXDII LOCAL ERROR MATRICES
C     (2*(ISUB-1)+1)*MAXDII
C                + 1,2,3,...,MAXDII = LAST MAXDII LOCAL ALPHA DENSITIES
C
C     (2*NSUBS*MAXDII+ 2*(ISUB-1)   *MAXDII
C             + 1,2,3,...,MAXDII = LAST MAXDII LOCAL ERROR (BETA))
C     (2*NSUB*MAXDII+(2*(ISUB-1)+1)*MAXDII
C             + 1,2,3,...,MAXDII = LAST MAXDII LOCAL BETA DENSITIES
C
C     --- DEBUG PRINT
      IF(DBG) WRITE(IW,*) 'MAXIO=',MAXIO
C
      LRAFEA= MAXDII* 2*(ISUB-1)
      LRAFEB= MAXDII*2*NSUBS+MAXDII* 2*(ISUB-1)
      LRAFDA= MAXDII*(2*(ISUB-1)+1)
      LRAFDB= MAXDII*2*NSUBS+MAXDII*(2*(ISUB-1)+1)
C
C     ----- IF WE ARE ON THE LAST SCF CYCLE, SHUT DIIS DOWN -----
C
      IF(ITDIIS.GE.MAXIT) THEN
         IF(.NOT.NOTOPN) CALL RACLOS(IRAFDC,'DELETE')
         NOTOPN = .TRUE.
         RETURN
      END IF
C
      IF(NOTOPN) THEN
         NOTOPN = .FALSE.
         IRAFDC = 30
         NDAF20 = MAXIO
         CALL RAOPDC(IRAFDC,IODIIS,NDAF20,5)
      END IF
C
C     ----- PUT ERROR MATRIX INTO CONSISTENT O.N.B. -----
C     PULAY USES S**-1/2, BUT HERE WE USE Q, Q OBEYS Q-DAGGER*S*Q=I
C     E-ORTH = Q-DAGGER * E * Q, DA IS USED AS A SCRATCH -L1- VECTOR
C
      CALL DCOPY(L3,ERR,1,WRK,1)
      CALL TFSQU(ERR,WRK,Q,SCR,L1,L1)
      IF(SCFTYP.EQ.UHF)THEN
        CALL DCOPY(L3,ERRB,1,WRK,1)
        CALL TFSQU(ERRB,WRK,Q,SCR,L1,L1)
      END IF
      IF(DBG) THEN
         WRITE(IW,*) 'LOCAL ERROR MATRIX IN O.N.B. OF SUBSYSTEM',ISUB
         CALL PRSQ(ERR,L1,L1,L1)
      END IF
C
C     ----- START DIIS PROCEDURE IF ERDCDI < ETHRSH -----
C
C       ERDCDI IS MAX ELEMENT OF ALL LOCAL ERROR MATRICES
C         (ISUB-1)-TH ERDCDI IS STORED TEMPORALILY AT ERDCDO
      ERDCDO=ERDCDI
C
      IMAX   = IDAMAX(L3,ERR,1)
      ERDCDI = ABS(ERR(IMAX))
      IF(SCFTYP .EQ. UHF) THEN
        JMAX   = IDAMAX(L3,ERRB,1)
        ERDCDI = ERDCDI + ABS(ERRB(JMAX))
      END IF
C     --- DEBUG PRINT
      IF(DBG) WRITE(IW,*) 'MAX ELEMENTS OF',ISUB,
     *                    ' TH LOCAL ERROR MATRIX=',ERDCDI
C
      IF(ISUB.NE.1) ERDCDI=MAX(ERDCDI,ERDCDO)
C     --- DEBUG PRINT
      IF(DBG) WRITE(IW,*) 'ERDCDI=',ERDCDI
C
      IF(.NOT.DODCDI) THEN
         IF(.NOT.STDCDI) THEN
            RETURN
         ELSE
            IF(ERDCDI.GT.ETHRDC) THEN
               STDCDI=.FALSE.
               ITDIIS=1
               RETURN
            END IF
         END IF
      END IF
      IF(ISUB.EQ.1) ITDIIS = ITDIIS+1
C
C     ----- SAVE THE CURRENT LOCAL DENSITY MATRIX -----
C
      LDA = LRAFDA + MOD(ITDIIS-2,MAXDII) + 1
      LDB = LRAFDB + MOD(ITDIIS-2,MAXDII) + 1
      CALL RAWRDC(IRAFDC,IODIIS,IODCLE,DA,L2,LDA,0)
      IF(SCFTYP.EQ.UHF) CALL RAWRDC(IRAFDC,IODIIS,IODCLE,DB,L2,LDB,0)
C
C     ----- SAVE THE CURRENT LOCAL ERROR MATRIX -----
C
      LERR = LRAFEA + MOD(ITDIIS-2,MAXDII) + 1
      CALL RAWRDC(IRAFDC,IODIIS,IODCLE,ERR,L3,LERR,0)
      IF(SCFTYP.EQ.UHF)THEN
        LERR = LRAFEB + MOD(ITDIIS-2,MAXDII) + 1
        CALL RAWRDC(IRAFDC,IODIIS,IODCLE,ERRB,L3,LERR,0)
      END IF
C
C        WHEN RUNNING IN PARALLEL, THE O(N**2) COMMUNICATIONS
C        COSTS IN -RAREAD- BELOW ARE THE SAME MAGNITUDE AS
C        THE COMPUTATION IN -DDOT- AND -DAXPY-.
C        IT SEEMS WISEST JUST TO LET THE MASTER DO THIS I/O,
C        THEN BROADCAST THE INTERPOLATION RESULTS AT THE END.
C
      GPSAVE = GOPARR
      GOPARR = .FALSE.
C
C        FORM LAST ROW (ROW ITDIIS) OF TRIANGULAR MATRIX B,
C        FIRST DOING THE DIAGONAL AND THE FIRST ELEMENT OF THE ROW.
C        THE TRANSPOSE IN PULAY'S STEP (2) IS JUST A SIGN CHANGE
C        BECAUSE ERROR MATRICES ARE ANTISYMMETRIC BY CONSTRUCTION.
C        THE SIGN IS IGNORED BECAUSE IT DOESN'T AFFECT THE LINEAR
C        EQUATION'S SOLUTION.
C
C     --- CONSTRUCT LOCAL B-MATRIX (SQUARE) ---
C         (FOR EACH SUBSYSTEM AND EACH DC-DIIS ITERATION)
C
C       FIRST, FORM B AS AN UPPER TRIANGULAR MATRIX
      BJJ=DDOT(L3,ERR,1,ERR,1)
      IF(SCFTYP .EQ. UHF) THEN
        BJJ = (BJJ + DDOT(L3,ERRB,1,ERRB,1))/2.0D+00
      END IF
C
      NB=MIN(ITDIIS,MAXDII)
C
      IF(ITDIIS.EQ.2) THEN
         NB=2
         B(1)=ZERO
         B(2)=-ONE
         B(3)=-ONE
         B(4)=BJJ
      ELSE IF(ITDIIS.GT.2) THEN
         NBM1=NB-1
         NBSQ=NB*NBM1
         B(1)=ZERO
         B(NB+1)=-ONE
         B(NBSQ+1)=-ONE
         B(NBSQ+NB)=BJJ
C
         DO I=2,NBM1
            LERRI = LRAFEA + MOD(ITDIIS-NB+I-2,MAXDII) + 1
            CALL RAREDC(IRAFDC,IODIIS,WRK,L3,LERRI,0)
            BINB=DDOT(L3,WRK,1,ERR,1)
            IF(SCFTYP .EQ. UHF) THEN
               LERRI = LRAFEB + MOD(ITDIIS-NB+I-2,MAXDII) + 1
               CALL RAREDC(IRAFDC,IODIIS,WRKB,L3,LERRI,0)
               BINB = (BINB + DDOT(L3,WRKB,1,ERRB,1))/2.0D+00
            END IF
            B(NBSQ+I)=BINB
         END DO
C
         DO J=2,NBM1
            JSQ=NB*(J-1)
            B(JSQ+1)=-ONE
            LERRJ = LRAFEA + MOD(ITDIIS-NB+J-2,MAXDII) + 1
            CALL RAREDC(IRAFDC,IODIIS,WRK,L3,LERRJ,0)
            BJJ=DDOT(L3,WRK,1,WRK,1)
            IF(SCFTYP .EQ. UHF) THEN
               LERRJ = LRAFEB + MOD(ITDIIS-NB+J-2,MAXDII) + 1
               CALL RAREDC(IRAFDC,IODIIS,WRKB,L3,LERRJ,0)
               BJJ  = (BJJ  + DDOT(L3,WRKB,1,WRKB,1))/2.0D+00
            END IF
            DO I=2,J-1
               LERRI = LRAFEA + MOD(ITDIIS-NB+I-2,MAXDII) + 1
               CALL RAREDC(IRAFDC,IODIIS,ERR,L3,LERRI,0)
               BIJ=DDOT(L3,WRK,1,ERR,1)
               IF(SCFTYP .EQ. UHF) THEN
                  LERRI = LRAFEB + MOD(ITDIIS-NB+I-2,MAXDII) + 1
                  CALL RAREDC(IRAFDC,IODIIS,ERRB,L3,LERRI,0)
                  BIJ  = (BIJ  + DDOT(L3,WRKB,1,ERRB,1))/2.0D+00
               END IF
               B(JSQ+I)=BIJ
            END DO
            B(JSQ+J)=BJJ
         END DO
C
C          TRANSFORM (UPPER) TRIANGULAR MATRIX B TO SQUARE MATRIX
         CALL TRTOSQ(B,NB)
      END IF
C
C     --- DEBUG PRINT
      IF(DBG) THEN
         WRITE(IW,*) 'DC-DIIS EQUATIONS'
         CALL PRSQ(B,NB,NB,NB)
      END IF
C
C     ----- SET UP AND SOLVE THE SET OF DIIS LINEAR EQUATIONS -----
C
  180 CONTINUE
      CALL VCLR(X,1,NB)
      X(1)=-ONE
      IERR=0
      CALL SLVLEQ(B,X,IPVT,NB,NB,0,IERR)
      IF(IERR.NE.0) THEN
         NB = NB - 1
         IF(MASWRK) WRITE(IW,*)
     *      'REDUCING DIIS EQUATION SIZE BY 1 FOR NUMERICAL STABILITY'
         IF (NB .NE. 1) GO TO 180
         IF(MASWRK) WRITE(IW,*) 'DIIS EQUATIONS ARE SINGULAR, BOMBING'
         CALL ABRT
      END IF
C
C     --- DEBUG PRINT
      IF(DBG) THEN
         WRITE(IW,*) 'DC-DIIS INTERPOLATION COEFFICIENTS'
         WRITE(IW,910) (X(I),I=1,NB)
      END IF
C
C     ----- FORM THE INTERPOLATED LOCAL ALPHA DENSITY MATRIX -----
C     THE INTERPOLATION IS SUMMATION C(I)*D(I)
C
      CALL VCLR(DA,1,L2)
      DO 220 IX=2,NB
         LDA = LRAFDA + MOD(ITDIIS-NB+IX-2,MAXDII) + 1
         CALL RAREDC(IRAFDC,IODIIS,WRK,L2,LDA,0)
         CI = X(IX)
         CALL DAXPY(L2,CI,WRK,1,DA,1)
  220 CONTINUE
      IF(DBG) THEN
         WRITE(IW,*) '     IN THE',ISUB,' TH LOCALIZATION REGION'
         WRITE(IW,*) 'DC-DIIS INTERPOLATED ALPHA DENSITY MATRIX IS'
         CALL PRTRIL(DA,L1)
      END IF
C
C     ----- FORM THE INTERPOLATED -UHF- LOCAL BETA DENSITY MATRIX -----
C
      IF(SCFTYP.EQ.UHF) THEN
         CALL VCLR(DB,1,L2)
         DO 240 IX=2,NB
            LDB = LRAFDB + MOD(ITDIIS-NB+IX-2,MAXDII) + 1
            CALL RAREDC(IRAFDC,IODIIS,WRK,L2,LDB,0)
            CI = X(IX)
            CALL DAXPY(L2,CI,WRK,1,DB,1)
  240    CONTINUE
         IF(DBG) THEN
            WRITE(IW,*) 'DC-DIIS INTERPOLATED BETA DENSITY MATRIX IS'
            CALL PRTRIL(DB,L1)
         END IF
      END IF
C
      GOPARR=GPSAVE
      IF(GOPARR) THEN
         CALL DDI_BCAST(1005,'F',DA,L2,MASTER)
         IF(SCFTYP.EQ.UHF)
     *   CALL DDI_BCAST(1006,'F',DB,L2,MASTER)
      END IF
C
      IF(ITDIIS.EQ.2 .AND. ISUB.EQ.NSUBS) THEN
         DODCDI=.TRUE.
         IF (MASOUT) WRITE(IW,900)
      END IF
C
      RETURN
C
  900 FORMAT(10X,'* * *   INITIATING DC-DIIS PROCEDURE   * * *')
  910 FORMAT(1X,5F13.8)
      END
C     NEXT CODE'S CALL IS COMMENTED OUT ABOVE
C---C
C---C*MODULE DCSCF   *DECK IRPROD
C---      SUBROUTINE IRPROD(IVEC,RVEC,LNG)
C---C
C---      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C---      DIMENSION IVEC(LNG), RVEC(LNG)
C---C
C---C     RVEC(I) <- IVEC(I)*RVEC(I)
C---C     LNG: LENGTH OF VECTORS
C---C
C---      DO I=1,LNG
C---         RVEC(I)=RVEC(I)*IVEC(I)
C---      ENDDO
C---C
C---      RETURN
C---C
C---      END
