C 14 OCT 09 - DGF - CHANGES FOR FMO 3.3
C 15 DEC 08 - TN  - VARIOUS CHANGES FOR FMO 3.2 RELEASE
C 20 AUG 07 - TN  - INCLUDE MODULE FOR ELECTROSTATIC DERIVATIVE TERMS
C
C*MODULE FMOESD  *DECK FMOESDER
      SUBROUTINE FMOESDER(L1,L2,DA,LAYFRG,SCFFRG,IDMREC0,DC,WRK1,
     *                    MAPI,MAPJ,MAP3,MAXL1D,IREC00,IDAM,IDAD,IDAT,
     *                    ORBXCH1,ENEXCH1,KODEXCH,JODEXCH,IODEXCH)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=2000,MXSH=5000,MXGTOT=20000,MXAO=8192,MXGSH=30,
     *           MXG2=MXGSH*MXGSH,MXRT=100,MAXL=5,
     *           HALF=0.5D+00,ZERO=0.0D+00)
      LOGICAL DIRSCF,FDIFF,DIRSAV,SCHWRZ,PACK2E,GOPARR,DSKWRK,MASWRK,
     *        OUT,SOME,BSSEDIM,ORBXCH,SAVGOP,ESPPAR,NXT,ESPAP,DODDCOR,
     *        ESDDER,LARGEPRI,LCFLAG,LRINT,LCFLAGS,LRINTS
      LOGICAL ESDER
      LOGICAL ORBXCH1,ENEXCH1,KODEXCH,JODEXCH,IODEXCH
C
      DIMENSION DA(*),LAYFRG(*),SCFFRG(*),IDMREC0(*),KARTEN(0:MAXL-1)
      DIMENSION DC(*),WRK1(*),MAPI(*),MAPJ(*),MAP3(MAXL1D,3)
C
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2)
      COMMON /FMCOM / X(1)
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
C     COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NLRC  / LCFLAG,LRINT,EMU,EMU2,LRFILE
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /SHLEXC/ NORGSH(3),NORGSP(3),IEXCH,NANGM,NGTH(4)
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(3),
     *                ORSHFT,CNVAFO,IXESP,MXITFG,NGUESS,NBSSE,MODORB,
     *                MODPAR,IRSTSTP,IRSTLAY,NPRFMO,NFMOPAL,MODPRP,
     *                MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,MODLMO,NOPDEN,
     *                MOFOCK
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT
C
      COMMON /GRAD  / DE(3,MXATM)
C
      DATA KARTEN/1,4,6,10,15/ 
      DATA RHF/8HRHF     /,RMC/8HMCSCF   /
     *     DBGFMO/8HDBGFMO  /,DBGME/8HFMOESP  /,DEBUG/8HDEBUG   /
CZ
CZ    IN THE CURRENT VERSION, THIS ROUTINE IS USED FOR DIMER AND TRIMER.
CZ
C
C     THIS ROUTINE COMPUTES THE ELECTROSTATIC POTENTIAL (ESP).
C     ONE ELECTRON PART IS COMPUTED IN ONEEI. HERE ONLY TWO-ELECTRON
C     CONTRIBUTION IS ADDED.
C     PARSTAT: GROUPFULL/GROUPNONE 
C
C     FOR NBSSE=3 MONOMERS AND DIMERS DURING BSSE RUNS ARE IN VACCUUM
      IF(NBSSE.EQ.3.AND.IFMOSTP.EQ.5. OR. IFMOSTP.EQ.1) RETURN
C
C     THIS ROUTINE MUST BE CALLED EITHER IN MONOSCF, EDIMER OR ETRIMER
C
      IF (IFMOSTP.EQ.6) THEN
        WRITE (IW,*) 'IFMOSTP=6 IS NOT ALLOWED IN FMOESDER'
        CALL ABRT
      END IF
      IF (IFMOSTP.NE.2.AND.IFMOSTP.NE.4.AND.IFMOSTP.NE.8) RETURN
C     IF (MASWRK) WRITE (6,*) 'NOW INSIDE OF FMOESDER'
CZ
C
      SOME=(EXETYP.EQ.DEBUG.OR.EXETYP.EQ.DBGFMO.OR.EXETYP.EQ.DBGME).AND.
     *     MASWRK
      ORBXCH=MOD(MODORB,2).NE.0
C     ENEXCH=MOD(MODORB/2,2).NE.0
      ESPPAR=MOD(MODPAR/2,2).NE.0.AND.GOPARR
C     .TRUE.  DIVIDE FRAGMENTS
C     .FALSE. DIVIDE SHELLS
      LWRKDEN=LFMOBUF(1)
      LWRKESP=LFMOBUF(2)
      LWRKESP2=LFMODB
C     FOR MONOMER SCF THERE IS NO NEED TO ADJUST IREC0 BELOW (AND MPPROP MAY 
C     NOT HAVE BEEN READ ANYWAY). 
      ILAY=ICURLAY
      IFG=ICURFG
      IF(IFG.EQ.0) RETURN
C
      LCFLAGS=LCFLAG
      LRINTS=LRINT
      LCFLAG=.FALSE.
      LRINT=.FALSE.
C
C     ESP IS NOT NEEDED. THIS HAPPENS WHEN MONOMER/DIMER SCF ITERATIONS RUN.
C     (ESP IS COMPUTED BEFORE SUCH ITERATIONS ALONG WITH 1-EL INTEGRALS)
C
      CALL DERCHK(NDER)
CZ
CZ    IESDPPC=1 AVOIDS ADDITION OF FMO/PCM REDUNDANT GRADIENTS IN SUBROUTINE FMODEG
CZ
      IESDPPC = 1
CZCZ
      ESDER = NDER.GT.0.AND.IAND(MODGRD,2).NE.0
      IF (.NOT.ESDER) THEN
        WRITE(IW,*) 'MUST DEBUG FOR ESDER'
        CALL ABRT
      END IF
CZ    ESDDER=IFMOSTP.EQ.6.AND.RESDIM.NE.0.AND.IAND(IXESP,32).EQ.0.AND.
CZ   *       NDER.GT.0
      ESDDER=.TRUE.
CZ
CZ    (1). DENSITY DERIVATIVES OF ESPS
CZ        NOTE THAT OUTPUT DA IS DI, DELTA DIJ OR DELTA DIJK
CZ
      CALL ESDNSDER(L1,L2,DA,X(LFMODB),DC,X(LWRKDEN),WRK1,
     *     LAYFRG,IDMREC0,X(LFMOESPA),
     *     X(LWRKESP),X(LNUMFRG),MAPI,MAPJ,MAP3,MAXL1D,IREC00,
     *     ORBXCH1,ENEXCH1,KODEXCH,JODEXCH,IODEXCH)
CZ
CZ    IF (MASWRK) THEN
CZ      WRITE (6,*) 'AFTER DENSITY MATRIX'
CZ      DO I = 1, L1
CZ      KK = I*(I-1)/2
CZ      WRITE (6,'(6F12.8)') (DA(KK+J),J=1,I)
CZ      END DO
CZ    END IF
CZ
      JFG=JCURFG
      LFG=KCURFG
      KFG0=1
      KFG1=NFG
      IZ=1
CZ    KFACT=1
CZ
      RESPAPI=RESPAP(IZ)
      RESPPCI=RESPPC(IZ)
      BSSEDIM=NBSSE.EQ.2.AND.IFMOSTP.EQ.5
      IF(BSSEDIM) JFG=0
      DODDCOR=IAND(IXESP,1024).NE.0
C
C     SCHWRZ = ISCHWZ.GT.0
      SCHWRZ = .TRUE. 
C     DO NOT THINK THAT YOU CAN SET SCHWRZ TO .FALSE. AND GET AWAY WITH IT.
C     SCHWRZ ALSO FORCES INTEGRAL INITIALISATION THAT WILL OTHERWISE NOT BE 
C     DONE.
C 
      DIRSAV=DIRSCF
      DIRSCF=.TRUE.
C     SCFTYP1=SCFTYP
C     IF(SCFTYP.EQ.RMC) SCFTYP1=RHF
      SCFTYP1=RHF
      OUT=SCHWRZ.AND.MASWRK.AND.IAND(NPRFMO,3).EQ.0
C
      CALL VCLR(X(LFMOESPA),1,L2)
CB    CALL VCLR(X(LFMOESPB),1,L2)
C
C
C     SAVE THE PRISTINE MONOMER(DIMER) CONFIGURATION
C
      CALL MONBSR(NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,NSHELL,NGAU,ENUCR,
     *            NAT0,ICH0,MUL0,NUM0,NQMT0,NE0,NA0,NB0,
     *            NCURSH,NGAU0,ENUCR0)
C
C     FIX THE NUMBER OF ELECTRONS TO AVOID DOUBLE COUNTING:
C     EXCLUDE CHARGE AS OTHERWISE THE CHARGE OF FRAGMENT I WILL BE ADDED
C     TO NE FIRST HERE AND THEN AGAIN IN MAKMOL BELOW.
C     AT PRESENT NE IS ACTUALLY NOT IMPORTANT BECAUSE NUMFRG HAS NA.
      NE0C=NE0+ICH0
C
      NPRSAV=NPRFMO
      IF(NPRINT.EQ.-5.AND.IAND(NPRFMO,3).EQ.0) NPRFMO=NPRFMO+1
C     THAT IS, ENFORCE REDUCED OUTPUT IF NPRINT.EQ.-5
C     FOR ESPS THE ONLY MEANINGFUL USAGE OF LOADM IS WITH TRUE ESPPAR.
C     LOADM SHOULD ONLY BE USED IF FULL RANGE OF FRAGMENTS IS TREATED
C     (THAT IS, EXCLUDING SEPARATED DIMERS).
      LOADHF=MOD(MODPAR,2)
      LARGEPRI=LOADHF.EQ.1.AND.ESPPAR.AND.KFG0.EQ.1.AND.KFG1.EQ.NFG
C     WRITE(6,*) 'WWWLB',LARGEPRI
CZ
CZ    (2). BASIS FUNCTION DERIVATIVES OF 1E INTEGRALS
CZ    DA IS OBTAINED IN ESDNSDER
CZ    THE CONTRIBUTIONS ARE DIRECTLY STORED IN FMODE().
CZ
      CALL ESVDER(DA,X(LWRKDEN),X(LWRKESP),L2,0,IDAM,IDAD,IDAT)
CZ
      NATF1 = NATFMO*3
      NATF2 = NATF1 *2
CZ
CZ    (3). HELMANN-FEYNMAN TERMS
CZ
      IF (IFMOSTP.EQ.2) THEN
        IOFF = 0
      ELSEIF (IFMOSTP.EQ.4) THEN
        IOFF = NATF1 
      ELSEIF (IFMOSTP.EQ.8) THEN
        IOFF = NATF2 
      END IF
      CALL EXTHELFEY(DA,X(LWRKDEN),L2,X(LFMODE+IOFF))

CZ
CZ    (4). DERIVATIVES OF MULLIKEN CHARGES IN ESPPC 
CZ
      IF (NDER.GT.0.AND.IAND(MODGRD,8).NE.0) THEN
        CALL ESPPCDER(ILAY,DA,L2,X(LPOPDMAT),LAYFRG)
      END IF
CZ
C
C     ----- INITIALIZATION FOR PARALLEL WORK -----
C
      NXT = IBTYP.EQ.1
      NEXT  = -1
      KOUNT = -1
C
C     ESP WILL BE COMPUTED IN THE DIRECT FASHION
C
C     DO 100 KFG=1,NFG
      DO 100 KKFG=KFG0,KFG1
        IF(LARGEPRI) THEN
          KFG=IXFTCH(X(LLOADM),KKFG)
        ELSE
          KFG=KKFG
        ENDIF
        IF(IFG.EQ.KFG.OR.JFG.EQ.KFG.OR.LFG.EQ.KFG) GOTO 100
C
        IF(RESPPCI.NE.ZERO.OR.RESPAPI.NE.ZERO.OR.RESDIM.NE.ZERO) THEN
          RK=FMODIST(IFG,JFG,LFG,KFG)
C         THE DISTANCE WILL BE REFINED LATER FOR SMARTR. 
C         WRITE(6,*) 'DISTANCE IS',KFG,RK,RESPPCI
CZCZ      IF(IZ.EQ.1.AND.RK.GT.RESPPCI.AND.RESPPCI.NE.ZERO) GOTO 100
          IF(RK.GT.RESPPCI.AND.RESPPCI.NE.ZERO) GOTO 100
CZ
C
         IF(IFMOSTP.EQ.2.AND.IAND(IXESP,4096).NE.0.AND.RK.NE.0) GOTO 100
C
          ESPAP=RK.GT.RESPAPI.AND.RESPAPI.NE.ZERO
        ELSE
          ESPAP=.FALSE.
        ENDIF
C
CZ
CZ      WHEN IS ESPPAR TRUE?????? 03/16/07
CZ      I HAVE TO ASK DMITRI 
CZ
        IF(ESPPAR) THEN
          KOUNT=KOUNT+1
          IF(GOPARR) THEN
            IF(NXT) THEN
              IF(KOUNT.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
              IF(NEXT.NE.KOUNT) GOTO 100
            ELSE
              IF(MOD(KOUNT,NPROC).NE.ME) GOTO 100
            ENDIF
          ENDIF
          SAVGOP=GOPARR
          GOPARR=.FALSE.
C         GOPARR IS SET TO .FALSE. TO PREVENT SHELL-BASED WORK DIVISION
C         INSIDE OF EXCHNG AND FMOESP. 
C         NOTE THAT SHELL-BASED WORK DIVISION IS USED FOR ESPPAR=.FALSE. 
        ENDIF
        KLAY=MIN(ILAY,LAYFRG(KFG))
C       BSSEDIM=NBSSE.EQ.2.AND.IFMOSTP.EQ.5.AND.KFG.EQ.JCURFG
        BSSEDIM=NBSSE.EQ.2.AND.IFMOSTP.EQ.5
        IF(SOME) WRITE(6,*) 'COMPUTING ESD DUE TO FRG',KFG,' LAYER',KLAY
C
C       ADD MONOMER KFG AND READ ITS DENSITY (NOW ONLY ALPHA)
C
        KFGX = KFG
        CALL MAKEMOL(KFGX,0,0,KLAY,0,NAT0,NCURSH,NGAU0,NE0C,ICH0,MUL0,
     *               .FALSE.)
        L1K=NUM-NUM0
        L2K=(L1K*L1K+L1K)/2
C       L3K=L1K*L1K 
C       WRITE(6,*) 'COMPUTING ESP DUE TO FRG',KFG,' LAYER',KLAY
C      WRITE(6,*) (X(LPOPMUL+((ICURPOP-1)*NFG+KFG-1)*MAXL1+I-1),I=1,L1K)
C       WRITE(6,*) (X(LPOPMAT+((ICURPOP-1)*NFG+KFG-1)*MAXNAT+I-1),I=1,
C    *              NAT-NAT0)
C
C       FOR SEPARATED DIMERS CALL 1E INTEGRALS AND QUIT. 
C       LUCKILY FOR SEPARATED DIMERS THE DISTANCE GIVEN BY FMODIST AND FMOSDIST
C       ARE EXACTLY SAME (MONOMER-MONOMER DISTANCE).
CZCZ
CZ      IF (LESDIM) THEN
CZ        IFLAG = 1
CZ        CALL VCLR(X(LFMOESPB),1,L2)
CZ
C         SET NAT1E TO JFG ATOMS
CZ        NAT1E=NAT-NAT0 
C         BASIS SET MUST BE RESET TO IFG MONOMER TO DO 1E INTEGRALS. 
C         SAVE DIMER INFO
CZ        NSHS=NSHELL
CZ        NUMS=NUM
CZ        NATS=NAT
CZ        NUM=NUM0
CZ        NSHELL=NCURSH
CZ        NAT=NAT0
C         ICURFG=0 PREVENTS UNWANTED RECURSIVE CALLS TO FMOESP FROM ONEEI.
C         ICURFG IS STORED IN NCURSH, THAT IS UNUSED IN ONEEI.
CZ        NCURS=NCURSH
CZ        NCURSH=ICURFG 
CZ        ICURFG=0
CZ
CZ        RESPPCS = RESPPC(2)
CZ        ! NOT TO CALCULATE APPROXIMATION TO 2E TERMS
CZ        RESPPC(2) = ZERO
CZ        IFMOS   = IFMOSTP
CZ        IFMOSTP = 6
CZ
C
CZ        CALL ONEEI
C
CZ
CZ        IFMOSTP = IFMOS
CZ        RESPPC(2) = RESPPCS
CZ
CZ        NCURSH=NCURS
CZ        NAT1E=NATFMO
CZ        NUM=NUMS
CZ        NSHELL=NSHS
CZ        NAT=NATS
C         RESPPCI USES POINT CHARGES - NO 2E INTEGRALS; FACTK=HALF SKIPS
C         UPPER TRIANGLE OF IFG,JFG CONTRIBUTIONS AS THEY ARE SYMMETRIC 
C         ADD INTERFRAGMENT NUCLEAR REPULSION, DEIJ=(EIJ-EI-EJ)/2
CZ        N0J=NAT0+1
C
C         THE CONDITION BELOW IFG.GT.JFG IS PLACED TO AVOID DOUBLE COUNTING.
C         FMOESP IS CALLED TWICE, SO THERE WOULD HAVE BEEN TWO EQUAL 
C         SAVE 1E POTENTIAL 
CZ        CALL DAXPY(L2,ONE,X(LFMOESPB),1,X(LFMOESPA),1)
CZ        IF(RK.GT.RESPPCI.AND.RESPPCI.NE.ZERO) GOTO 100
CZ      ENDIF
C

        IREC0=IDMREC0(KLAY)
C       HACK IT UP TO POINT TO RHF DENSITIES FOR RUNS WITH MP2 DENSITIES. 
        IF(DODDCOR) THEN
          IREC0RHF=1
          IF(IREC0.EQ.1) IREC0RHF=NFG*2+1
          IREC0=IREC0RHF
        ENDIF
        IDMREC0K=KFG+IREC0
        IF(.NOT.ESPAP) THEN
        NAK=ISHFT(IXFTCH(X(LNUMFRG),KFG),-16) 
        MULK=IXFTCH(X(LMULFG),KFG)
        NBK=NAK-MULK+1
C       IF(ORBXCH) THEN 
C         IF(SCFFRG(KFG).EQ.RMC) THEN
C          CALL RAREADS(IDAFMO,X(LIODFMO),X(LWRKDEN),L2K+L3K,IDMREC0K,0)
C         ELSE
C          CALL RAREADS(IDAFMO,X(LIODFMO),X(LWRKDEN+L2K),L3K,IDMREC0K,0)
C           CALL DMTX2(X(LWRKDEN),X(LWRKDEN+L2K),NAK,L1K,L1K) 
C         ENDIF
C       ELSE
C         CALL RAREADS(IDAFMO,X(LIODFMO),X(LWRKDEN),L2K,IDMREC0K,0)
C       ENDIF
        CALL READMOND(X(LWRKDEN),ORBXCH,SCFFRG(KFG).EQ.RMC,
     *                NAK,NBK,L1K,X(LIODFMO),IDMREC0K)
C       GOTO 100
C       WRITE(6,*) 'ORIGINAL DENSITY',KFG,L1K,NAK
C       CALL PRTRI(X(LFMODA),L1K)
C       CALL SEQOPN(38,'HESSIAN','UNKNOWN',.FALSE.,'UNFORMATTED')
C       WRITE(38) (X(LFMODA+I-1),I=1,L2K)
C       CALL SEQCLO(38,'KEEP')
C       READ BETA DENSITY
        ENDIF
C
C       ARRAY SIZES ARE DIFFERENT FOR EACH FRAGMENT. 
C
        NSH2 = (NSHELL*NSHELL+NSHELL)/2
        CALL BASCHK(LMAX)
        IF(LMAX.GE.5) THEN
           IF(MASWRK) WRITE(IW,*) 'FMO HAS NOT BEEN REVIEWED FOR H,I'
           CALL ABRT
        END IF
C       FOR SOME REASON GAMESS LIKES TO HANDLE AT LEAST L-SHELLS
        NANGM=KARTEN(MAX(LMAX,1))
        MAXG = NANGM**4
        CALL VALFM(LOADFM)
C
        LXINTS= LOADFM + 1
        LGHOND= LXINTS + NSH2
        LDSH  = LGHOND + MAXG
        LDSHB = LDSH   + NSH2
        LDDIJ = LDSHB  + NSH2
        LAST  = LDDIJ  + 49*MXG2
        NEED  = LAST- LOADFM -1
        CALL GETFM(NEED)
C
        LDENP=LPOPMUL+((ICURPOP-1)*NFG+KFG-1)*MAXL1
        IF(ESPAP) THEN
          LDENA=LDENP
          LDENB=LDENA
        ELSE
CZCZ      LDENA=LFMODA 
          LDENA=LWRKDEN 
          LDENB=LFMODB 
        ENDIF 
C
C       CALL ERIPRE
C       THERE IS NO NEED TO CALL ERIPRE HERE. FMO CODE ALWAYS CALLS EXCHNG
C       (BECAUSE SCHWRZ IS FORCED TRUE), AHD THIS IS WHERE INITIALISATION
C       FOR EACH (N+1)-MER IS DONE. NOTE THAT THIS INITIALISATION IS 
C       IMPORTANT NOW: IT SETS ARRAYS FOR SCREENING AND SOME OTHER THINGS. 
C
C       CREATE DENSITY MATRIX FOR SHELL INDICES
C
        IF(SCHWRZ) THEN
          DUMMY = 0.0D+00
CNB       FOR GRADIENTS, WHAT SHOULD BE SCFTYP??
C         L1 AND L2K SEEM TO BE THE RIGHT CHOICE:
C         L1 IS USED TO SKIP L1 AOS TO GET TO THE EXTERNAL MONOMER SHELL
C         L2K GIVES THE SIZE OF GVB DENSITY MATRICES FOR THE EXTERNAL MONOMER
C         WRITE(6,*) 'ORIGINAL DENSITY',KFG,L1K
C         CALL PRTRI(X(LFMODA),L1K)
          IF(ESPAP) THEN
C           WRITE(6,*) 'MULLIKENS'
C           CALL PRSQ(X(LDENA),L1K,1,1)
           CALL SHLDEND(SCFTYP1,X(LDENA),X(LDENB),DUMMY,X(LDSH),L1,1)
C          WRITE(6,*) 'CONTRACTED L-DENSITY',KFG,NSHELL-NCURSH
C           CALL PRSQ(X(LDSH),NSHELL-NCURSH,1,1)
          ELSE
            CALL SHLDEN(SCFTYP1,X(LDENA),X(LDENB),DUMMY,X(LDSH),IA,
     *                  L1,L2K,NSH2,1)
            IF(ESDDER) THEN
C            REMOVE ALL EVIDENCE OF FRAGMENT 2 BEING INVOLVED. 
C            KEEP ONLY FRAGMENT 1 INFORMATION AND OBTAIN ITS SHELL DENSITY. 
C            L1 ARGUMENT IS UNUSED BELOW.
             NSHSAV=NSHELL
             NSHELL=NCURSH
             NCURSH=0
CZCZ        CALL SHLDEN(SCFTYP1,X(LWRKDEN),X(LDENB),DUMMY,X(LDSHB),IA,
CZCZ *                  L1,L2K,NSH2,1)
            CALL SHLDEN(SCFTYP1,DA,X(LDENB),DUMMY,X(LDSHB),IA,
     *                  L1,L2K,NSH2,1)
             NCURSH=NSHELL
             NSHELL=NSHSAV
            ENDIF
C         WRITE(6,*) 'CONTRACTED DENSITY',KFG,NSHELL-NCURSH
C         CALL PRTRI(X(LDSH),NSHELL-NCURSH)
          ENDIF
        END IF
C
C       INITIALISE TWO-ELECTRON INTEGRALS
C       POPLE INTEGRALS USE A SEPARATE COORDINATE COMMON BLOCK INITIALISED
C       ABOVE, ETC. ?ST MUST BE RESET SO THAT NO PHONEY RESTART IS DONE.
C
        IST=1
        JST=1
        KST=1
        LST=1
        CALL JANDK
C
C     ----- EXCHANGE INTEGRALS FOR DIRECT SCF THRESHOLD TESTS -----
C       COMPUTED FOR THE COMBINED SYSTEM, NO NEED TO ADJUST INDICES.
C
        NINT=0
        NSCHWZ=0
CNB5    EXCHNG CAN BE ADJUSTED TO TAKE ADVANTAGE OF THE REDUCED BASIS WITH BSSE.
C       GOTO 100
C       DO IOHNO=1,1000
        IF(SCHWRZ) CALL EXCHNG(X(LXINTS),X(LGHOND),X(LDDIJ),
     *                         NSH2,MAXG,INTTYP)
C       ENDDO
C       COMPUTE 2-EL INTEGRALS CORRESPONDING TO PLACING THE ORIGINAL 
C       MONOMER(DIMER) INTO THE COULOMB FIELD OF MONOMER KFG.
C 
C       GOTO 100
CZZ     IF(ESDDER) CALL VCLR(X(LWRKESP2),1,L2K)
        CALL VCLR(X(LWRKESP2),1,L2K)
CZ
C       CALL TIMIT(1)
C       DO IOHNO=1,100
CZ
CZ      WHAT I WANT IS NOT X(LFMOESPA), BUT X(LWRKESP2).
CZ      I WILL MODIFY FMOESP2 TO DO SO 
CZ
        CALL FMO2EI(SCHWRZ,NINT,NSCHWZ,NSCHWZB,NSCHWNZB,L1,L2,X(LXINTS),
     *              NSH2,X(LGHOND),MAXG,IA,LDENA,LDENP,X(LFMOESPA),
     *              DA,X(LWRKESP2),X(LDSH),X(LDSHB),X(LIAGLOB),
     *              X(LINDAT),X(LINDATG),BSSEDIM,RESPAPI,RESPPCI,ESPAP,
     *              ESDDER,ESDER,IFG,JFG,LFG,KFG)
CZCZ *              ESDDER,IFG,JFG,LFG,KFG)
C       ENDDO
C       CALL TIMIT(1)
        IF(OUT) THEN
          IF(NSCHWZB.EQ.0) THEN
            WRITE(IW,9000) KFG,NINT,NSCHWZ
          ELSE
            WRITE(IW,9005) KFG,NINT,NSCHWZ,NSCHWZB
          ENDIF
        ENDIF
C         WRITE(IW,*) 'NON-ZERO SUPERBLOCKS',NSCHWNZB,NSH2
C
C       WRITE(6,*) 'DENSITY IN ESP IS'
C       CALL PRTRIL(X(LFMODA),NUM0)
CZ
CZ      ADDED BY NAGATA 3/27/07
CZ
CZCZCZ  IF(SCHWRZ) CALL DAWRIT(IDAF,IODA,X(LXINTS),NSH2,54,0)
        IF(SCHWRZ) LFMOBUF(3) = LXINTS
CZ
CZCZCZ  CALL RETFM(NEED)
C
        IF(ESPPAR) GOPARR=SAVGOP
CZCZ    IF(ESDDER) THEN
          CALL DSCAL(L2K,HALF,X(LWRKESP2),1)
          II=LWRKESP2-1
          DO I=1,L1K
            II = II+I
            X(II) = X(II) + X(II)
          ENDDO
          IF(GOPARR) CALL DDI_GSUMF(2418,X(LWRKESP2),L2K)
C         WRITE(6,*) 'HAVING V1',L1K
C         CALL PRTRIL(X(LWRKESP),L1K)
C         WRITE(6,*) 'HAVING V2',L1K
C         CALL PRTRIL(X(LWRKESP2),L1K)
CZCZ      CALL DAXPY(L2K,ONE,X(LWRKESP2),1,X(LWRKESP),1)
CZCZ    ENDIF

CZ      TEST
C       WRITE(6,*) 'WRKESP2',L1
C       CALL PRTRIL(X(LWRKESP2),L1K)
CZ
C
CZ
CZ      CALCULATE LAGRANGIAN-LIKE TERM, X
CZ
        ! ADD SQUARE SPACE AFTER TRIANGLE SPACE FOR LFMODA
        CALL VCLR(X(LWRKESP),1,L2K)
CZ
        CALL CPYTSQ(X(LWRKDEN),X(LWRKDEN+L2K),L1K,1)
        CALL TFTRI(X(LWRKESP),X(LWRKESP2),X(LWRKDEN+L2K),
     *             X(LWRKESP+L2K),L1K,L1K,L1K)
        CALL DSCAL(L2K,-HALF,X(LWRKESP),1)
        CALL VCLR(DE,1,NAT*3)
        CALL EXTSDER(X(LWRKESP),X(LWRKESP+L2K),L1K,L2K,.FALSE.,
     *               .FALSE.,L1)
CZ      IF (MASWRK) THEN
CZ        WRITE(6,*) 'TEST AFTER LAGRANGIAN-LIKE TERM',KFG,NAT
CZ        DO IJ = 1, NAT
CZ          WRITE(6,'(3F12.8)') DE(1,IJ),DE(2,IJ),DE(3,IJ)
CZ        END DO
CZ      END IF
CZCZ    CALL PRTRIL(X(LWRKESP),L1K)
CZ
CZ
CZ      CALCULATIONS OF DERIVATIVE TERMS
CZ 
CZ      ELECTRON REPULSION TERM
CZ
CZ      DA IS DI, DELTA DIJ, OR DELTA DIJK 
CZ      X(LWRKDEN)  IS THE DENSITY FOR EXTERNAL MONOMER 
CZ      NOTE THAT DERIVATIVES ARE STORED IN DE().
CZ
        CALL ESD2DER(DA,X(LWRKDEN),L1)
        IF(GOPARR) CALL DDI_GSUMF(2418,DE,NAT*3)
CZ      IF (MASWRK) THEN
CZ        WRITE(6,*) 'TEST AFTER ESD2DER',KFG,NAT
CZ        DO IJ = 1, NAT
CZ          WRITE(6,'(3F12.8)') DE(1,IJ),DE(2,IJ),DE(3,IJ)
CZ        END DO
CZ      END IF
        CALL RETFM(NEED)
CZ
        IF (MASWRK) THEN
          IF (IFMOSTP.EQ.2) THEN
            CALL FMODEG(1,X(LFMODE),X(LFMOPG),X(LIAGLOB))
          ELSEIF (IFMOSTP.EQ.4) THEN
            CALL FMODEG(1,X(LFMODE+NATF1),X(LFMOPG),X(LIAGLOB))
            N11 = IDAM + IDAD
            N11 = 0      ! NEED TO FIX FOR APPROXIMATE FMO3 
            IF (NBODY.GT.2) CALL FMODEG
     *         (N11,X(LFMODE+NATF2),X(LFMOPG),X(LIAGLOB))
            ! MUST CHANGE
          ELSEIF (IFMOSTP.EQ.8) THEN
            CALL FMODEG(1,X(LFMODE+NATF2),X(LFMOPG),X(LIAGLOB))
          ENDIF
        ENDIF
  100 CONTINUE
      IF(ESPPAR.AND.GOPARR.AND.NXT) CALL DDI_DLBRESET
C
C     RESTORE THE PRISTINE MONOMER(DIMER) CONFIGURATION
C
      CALL MONBSR(NAT0,ICH0,MUL0,NUM0,NQMT0,NE0,NA0,NB0,NCURSH,NGAU0,
     *           ENUCR0,NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,NSHELL,NGAU,ENUCR)
C
C     IT IS IMPORTANT TO RESET NCURSH SO THAT 2E INTEGRALS WITHIN THE MONOMER
C     (DIMER) DURING THE FOLLOWING SCF ARE COMPUTED PROPERLY.
      NCURSH=0
C
C     COMPUTE 2-EL INTEGRALS FOR THE ORIGINAL MONOMER(DIMER)
C
      IF(IFMOSTP.NE.6) THEN
        IST=1
        JST=1
        KST=1
        LST=1
        CALL JANDK
      ENDIF
      NPRFMO=NPRSAV
      DIRSCF=DIRSAV
      LCFLAG=LCFLAGS
      LRINT=LRINTS
C     IF (MPLEVL.EQ.0) THEN
C       CALL DAREAD(IDAF,IODA,DA,L2,16,0)
C     ELSE
C       CALL DAREAD(IDAF,IODA,DA,L2,308,0)
C     END IF
C     IF (MASWRK) WRITE(6,*) 'EXIT OF FMOESD',NQMT
CZ
      IESDPPC = 0
CZ
      RETURN
 9000 FORMAT(/1X,'ESD LFG=',I5,': NZ',I12,' SKIPPED',I10,' BLOCKS.')
 9005 FORMAT(/1X,'ESD LFG=',I5,': NZ',I12,' SKIPPED',I10,' BLOCKS',I8,
     *           ' SUPERBLOCKS.')
      END
C*MODULE FMOESD  *DECK ESVDER
      SUBROUTINE ESVDER(DENAB,DTINT,DVINT,L2,MODUS,IDAM,IDAD,IDAT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL OUT,DBG,NORM
      LOGICAL GOPARR,DSKWRK,MASWRK,NXT,SVDSKW,DEBUGOPT
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000, MXAO=8192)
      PARAMETER (MXCHRM=1)
C
      DIMENSION DENAB(L2),DTINT(L2,3,NAT),DVINT(L2,3,NAT)
      DIMENSION DIJ(225), IJX(35), IJY(35), IJZ(35),
     *          XV(6,5,5), YV(6,5,5), ZV(6,5,5),
     *          DXV(5,5,5), DYV(5,5,5), DZV(5,5,5)
CZ   *          XS(6,7), YS(6,7), ZS(6,7), XT(6,5), YT(6,5), ZT(6,5),
CZ   *          DXS(5,5), DYS(5,5), DZS(5,5),
CZ   *          DXT(5,5), DYT(5,5), DZT(5,5),
C
      COMMON /CHMGMS/ XCHM(MXCHRM),YCHM(MXCHRM),ZCHM(MXCHRM),
     *                DXELMM(MXCHRM),DYELMM(MXCHRM),DZELMM(MXCHRM),
     *                QCHM(MXCHRM),NCHMAT,KCHRMM
      COMMON /DSTV  / XINT,YINT,ZINT,T,X0,Y0,Z0,XI,YI,ZI,
     *                XJ,YJ,ZJ,NI,NJ,CX,CY,CZ
      COMMON /FMCOM / X(1)
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /ROOT  / XX,U(13),W(13),NROOTS
      COMMON /RELWFN/ RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,IQRORD,MODQR,NESOC,
     *                NRATOM,NUMU,NQMTR,NQRDAF,MORDA,NDARELB
CZCZ  COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
CZCZ *                MPLEVL,MPCTYP
C
CZ    PARAMETER (MAXDEN=25*MXATM, LENABC=2000, NPPA=1082)
CZ    LOGICAL ISEPS, USEPS
CZ    COMMON /ISEPS / ISEPS, USEPS
CZ    COMMON /SOLV  / FEPSI,RDS,DISEX2,COSURF(3,LENABC),SRAD(MXATM),
CZ   *                QDEN(MAXDEN),AR(LENABC),
CZ   *                NSPA,NPS,NPS2,NDEN,NPSPHER
CZ    COMMON /SOLVI / IATSP(LENABC+1),N0(2),NP1,NP2,ISKIP
CZ    COMMON /COSMO3/ COSZAN(NPPA),CORZAN(3,NPPA)
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00,TWO=2.0D+00)
      PARAMETER (RLN10=2.30258D+00)
      PARAMETER (PI212=1.1283791670955D+00)
      PARAMETER (SQRT3=1.73205080756888D+00)
      PARAMETER (SQRT5=2.23606797749979D+00,SQRT7=2.64575131106459D+00)
C
      DATA DEBUG/8HDEBUG   /, DBUGME/8HTVDER   /, GRD1/8HGRD1    /,
     *     RESC/8HRESC    /,ANESC/8HNESC    /
C
      DATA IJX / 1, 2, 1, 1, 3, 1, 1, 2, 2, 1,
     *           4, 1, 1, 3, 3, 2, 1, 2, 1, 2,
     *           5, 1, 1, 4, 4, 2, 1, 2, 1, 3,
     *           3, 1, 3, 2, 2/
      DATA IJY / 1, 1, 2, 1, 1, 3, 1, 2, 1, 2,
     *           1, 4, 1, 2, 1, 3, 3, 1, 2, 2,
     *           1, 5, 1, 2, 1, 4, 4, 1, 2, 3,
     *           1, 3, 2, 3, 2/
      DATA IJZ / 1, 1, 1, 2, 1, 1, 3, 1, 2, 2,
     *           1, 1, 4, 1, 2, 1, 2, 3, 3, 2,
     *           1, 1, 5, 1, 2, 1, 2, 4, 4, 1,
     *           3, 3, 2, 2, 3/
C
C     ----- BASIS FUNCTION DERIVATIVE CONTRIBUTIONS TO GRADIENT -----
C     INTEGRALS ARE OF TYPE <II'/H/JJ> = <II'/T+V/JJ>
C     RESC RUNS STORE INTEGRALS WITHOUT CONTRACTING THEM WITH DENSITY
C
C     MODUS - USED ONLY WITH NESC METHOD AND ONLY FOR KIN. ENERGY T
C           = 0 BULK T GRADIENT
C           = 1 CORRECTION TO S DERIVATIVE (PROPORTIONAL TO T)
C           = 2 CORRECTION TO T DERIVATIVE
C
      DBG = (EXETYP.EQ.DEBUG  .OR.  EXETYP.EQ.DBUGME)  .AND.  MASWRK
      OUT = (EXETYP.EQ.DEBUG  .OR.  EXETYP.EQ.DBUGME  .OR.
     *       EXETYP.EQ.GRD1   .OR.  NPRINT.EQ.-3)
      IF(DBG) WRITE(IW,9000)
      IAZ=0
C
      TOL = RLN10*ITOL
      NORM = NORMF .NE. 1 .OR. NORMP .NE. 1
      IF(RMETHOD.EQ.ANESC) THEN
         FSC=ONE/CLIG
         FSC2=FSC*FSC/TWO
      ENDIF
      IF(RMETHOD.EQ.RESC) THEN
         CALL VCLR(DTINT,1,L2*3*NAT)
         CALL VCLR(DVINT,1,L2*3*NAT)
      ENDIF
CZ
CZ    DETERMINE THE COEFFICIENTS FOR FMO N-MER GRAD 
CZ
      IDAMM = 0
      IDADD = 0
      IDATT = 0
      IF (IFMOSTP.EQ.2) THEN
        IDAMM = IDAM
        IDAMM = 1
      ELSEIF (IFMOSTP.EQ.4) THEN
        IF (NBODY.GT.1) IDADD = 1
        IF (NBODY.GT.2) IDATT = IDAD + IDAT ! MUST CHANGE
        IF (NBODY.GT.2) IDATT = 0           ! MUST CHANGE
      ELSEIF (IFMOSTP.EQ.8) THEN
        IDATT = 1 
      ELSE
        WRITE (6,*) 'IFMOSTP MUST BE 2, 4, OR 8'
        CALL ABRT
      ENDIF
CZCZ  IF (IDAMM.EQ.0.AND.IDADD.EQ.0.AND.IDATT.EQ.0) RETURN
CZ    WRITE(6,*) 'COEF FOR FRAG ENER IN ES1DER',IDAMM,IDADD,IDATT
CZ
C
C INITIALIZE PARALLEL
C
      NXT = IBTYP.EQ.1
      IPCOUNT = ME - 1
      NEXT = -1
      MINE = -1
C
C     -D*ELMM- CONTAINS CONTRIBUTION TO THE FORCES ON THE
C     EXTERNAL CHARGES WHICH ARE DUE TO QM MOLECULE.
C
      IF(NCHMAT.NE.0) THEN
         DO 100 ICHARM=1,NCHMAT
            DXELMM(ICHARM)=ZERO
            DYELMM(ICHARM)=ZERO
            DZELMM(ICHARM)=ZERO
  100    CONTINUE
      END IF
CZ    ESD=NFG.NE.0.AND. IFMOSTP.EQ.2.AND.MPLEVL.EQ.0.AND.
CZ   *                  RESDIM.NE.0.AND.IAND(IXESP,32).EQ.0
CZ    NEXTAT=NCHMAT
CZ    IF(ESD) NEXTAT=NATFMO
CZ    NEXTAT=NATFMO
CZ
CZ    SET UP A PARAMETER IN DEEPEST LOOP    
CZ
      MAXIC = NATFMO
CZ
C
C     FIRST, LOOP OVER THE GENUINE QM MOLECULE (ICHARM=0 PASS),
C     AND THEN ANY EXTERNAL CHARGES WHICH CHARMM MAY BE USING.
C     THE LATTER MAKE A CONTRIBUTION TO THE GRADIENT OF THE ATOMS
C     IN THE QM MOLECULE, AS WELL AS TO THEMSELVES.
C     FMO EXTERNAL ATOMS FROM SEPARATED DIMERS ARE HANDLED SIMILARLY TO
C     CHARMM.
C
CZ
CZ    THIS LOOP IS MOVED 
CZ
CZCZ  DO 2000 ICHARM=0,NEXTAT
CZCZ    IF(ESD.AND.ICHARM.GT.0) THEN
CZCZ    CALL ESDDERZ(ICHARM,X(LLAYFRG),X(LINDAT),X(LIABDFG),X(LJABDFG)
CZCZ *              ,X(LINDBD),X(LFMOZAN),X(LFMOC),ZNUC,CX,CY,CZ)
C       WRITE(6,*) 'WWWEXTZ',ICHARM,-ZNUC,CX,CY,CZ
CZCZ    IF(ABS(ZNUC).LT.1.0D-08) GOTO 2000
C       THE CHARGE IS OF COURSE EITHER 0 OR NOT, NOT MERELY CLOSE TO 0.
CZ      ENDIF
C
C     ----- I SHELL
C
      DO 1400 II = 1,NSHELL
C
C           GO PARALLEL!
C
        IF(NXT .AND. GOPARR) THEN
           MINE = MINE + 1
           IF(MINE.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
           IF(NEXT.NE.MINE) GO TO 1400
        END IF
C
        IAT = KATOM(II)
        XI = C(1,IAT)
        YI = C(2,IAT)
        ZI = C(3,IAT)
        I1 = KSTART(II)
        I2 = I1+KNG(II)-1
        LIT = KTYPE(II)
        MINI = KMIN(II)
        MAXI = KMAX(II)
        LOCI = KLOC(II)-MINI
        LITDER = LIT + 1
C
C     ----- J SHELL
C
        DO 1300 JJ = 1,NSHELL
C
C           GO PARALLEL!
C
          IF((.NOT.NXT) .AND. GOPARR) THEN
             IPCOUNT = IPCOUNT + 1
             IF(MOD(IPCOUNT,NPROC).NE.0) GO TO 1300
          END IF
C
          JAT = KATOM(JJ)
          XJ = C(1,JAT)
          YJ = C(2,JAT)
          ZJ = C(3,JAT)
          J1 = KSTART(JJ)
          J2 = J1+KNG(JJ)-1
          LJT = KTYPE(JJ)
          MINJ = KMIN(JJ)
          MAXJ = KMAX(JJ)
          LOCJ = KLOC(JJ)-MINJ
CZCZ      LJTMOD = LJT+2
          NROOTS = (LIT+LJT-1)/2 + 1
          RR = (XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
C
C     ----- I PRIMITIVE
C
        DO 1100 IG = I1,I2
          AI = EX(IG)
          ARRI = AI*RR
          AXI = AI*XI
          AYI = AI*YI
          AZI = AI*ZI
          CSI=CS(IG)
          CPI=CP(IG)
          CDI=CD(IG)
          CFI=CF(IG)
          CGI=CG(IG)
C
C     ----- J PRIMITIVE
C
          DO 1000 JG = J1,J2
            AJ = EX(JG)
            AA = AI+AJ
            AA1 = ONE/AA
            DUM = AJ*ARRI*AA1
            IF(DUM .GT. TOL) GO TO 1000
            FAC = EXP(-DUM)
            CSJ = CS(JG)
            CPJ = CP(JG)
            CDJ = CD(JG)
            CFJ = CF(JG)
            CGJ = CG(JG)
            AX = (AXI+AJ*XJ)*AA1
            AY = (AYI+AJ*YJ)*AA1
            AZ = (AZI+AJ*ZJ)*AA1
C
C     ----- DENSITY FACTOR
C
            IJ = 0
            DUM1 = ZERO
            DUM2 = DUM1
            DO 600 I=MINI,MAXI
              IF(I.EQ.1) DUM1=CSI*FAC
              IF(I.EQ.2) DUM1=CPI*FAC
              IF(I.EQ.5) DUM1=CDI*FAC
              IF(I.EQ.8.AND.NORM) DUM1=DUM1*SQRT3
              IF(I.EQ.11) DUM1=CFI*FAC
              IF(I.EQ.14.AND.NORM) DUM1=DUM1*SQRT5
              IF(I.EQ.20.AND.NORM) DUM1=DUM1*SQRT3
              IF(I.EQ.21) DUM1=CGI*FAC
              IF(I.EQ.24.AND.NORM) DUM1=DUM1*SQRT7
              IF(I.EQ.30.AND.NORM) DUM1=DUM1*SQRT5/SQRT3
              IF(I.EQ.33.AND.NORM) DUM1=DUM1*SQRT3
C
              DO 600 J = MINJ,MAXJ
                IF(J.EQ.1) DUM2=DUM1*CSJ
                IF(J.EQ.2) DUM2=DUM1*CPJ
                IF(J.EQ.5) DUM2=DUM1*CDJ
                IF(J.EQ.8.AND.NORM) DUM2=DUM2*SQRT3
                IF(J.EQ.11) DUM2=DUM1*CFJ
                IF(J.EQ.14.AND.NORM) DUM2=DUM2*SQRT5
                IF(J.EQ.20.AND.NORM) DUM2=DUM2*SQRT3
                IF(J.EQ.21) DUM2=DUM1*CGJ
                IF(J.EQ.24.AND.NORM) DUM2=DUM2*SQRT7
                IF(J.EQ.30.AND.NORM) DUM2=DUM2*SQRT5/SQRT3
                IF(J.EQ.33.AND.NORM) DUM2=DUM2*SQRT3
C
                IJ=IJ+1
                IF(RMETHOD.EQ.RESC) THEN
                  DEN=ONE
                  IF(LOCI+I.EQ.LOCJ+J) DEN=TWO
                ELSE
                  NN = IA(MAX0(LOCI+I,LOCJ+J))+MIN0(LOCI+I,LOCJ+J)
                  DEN = DENAB(NN)
                  DEN = DEN + DEN
                  IF(RMETHOD.EQ.ANESC) THEN
                    IF(MODUS.EQ.1) DEN=DEN*FSC2
                    IF(MODUS.EQ.2) DEN=-DEN
                  ENDIF
                ENDIF
                DIJ(IJ)=DUM2*DEN
  600         CONTINUE
C
C     -----  KINETIC ENERGY
C
CZ    IF(ICHARM.GT.0) GO TO 700
C
CZ    T = SQRT(AA1)
CZ    X0 = AX
CZ    Y0 = AY
CZ    Z0 = AZ
CZ    DO 660 J = 1,LJTMOD
CZ      NJ =J
CZ      DO 660 I = 1,LITDER
CZ        NI = I
CZ        CALL VINT
CZ        XS(I,J)=XINT*T
CZ        YS(I,J)=YINT*T
CZ        ZS(I,J)=ZINT*T
CZ660 CONTINUE
CZ    CALL DTXYZ(XT,YT,ZT,XS,YS,ZS,LITDER,LJT,AJ)
CZ    CALL DERI(DXS,DYS,DZS,XS,YS,ZS,LIT,LJT,AI)
CZ    CALL DERI(DXT,DYT,DZT,XT,YT,ZT,LIT,LJT,AI)
CZ    IJ=0
CZ    DO 680 I=MINI,MAXI
CZ      IX=IJX(I)
CZ      IY=IJY(I)
CZ      IZ=IJZ(I)
CZ      DO 670 J=MINJ,MAXJ
CZ        JX=IJX(J)
CZ        JY=IJY(J)
CZ        JZ=IJZ(J)
CZ        DUMX=DXT(IX,JX)* YS(IY,JY)* ZS(IZ,JZ)
CZ   1        +DXS(IX,JX)* YT(IY,JY)* ZS(IZ,JZ)
CZ   2        +DXS(IX,JX)* YS(IY,JY)* ZT(IZ,JZ)
CZ        DUMY= XT(IX,JX)*DYS(IY,JY)* ZS(IZ,JZ)
CZ   1        + XS(IX,JX)*DYT(IY,JY)* ZS(IZ,JZ)
CZ   2        + XS(IX,JX)*DYS(IY,JY)* ZT(IZ,JZ)
CZ        DUMZ= XT(IX,JX)* YS(IY,JY)*DZS(IZ,JZ)
CZ   1        + XS(IX,JX)* YT(IY,JY)*DZS(IZ,JZ)
CZ   2        + XS(IX,JX)* YS(IY,JY)*DZT(IZ,JZ)
CZ        IJ=IJ+1
CZ        IF(RMETHOD.EQ.RESC) THEN
CZ           NN=IA(MAX0(LOCI+I,LOCJ+J))+MIN0(LOCI+I,LOCJ+J)
CZ           DUMINT=DIJ(IJ)
CZ           DTINT(NN,1,IAT)=DTINT(NN,1,IAT)+DUMX*DUMINT
CZ           DTINT(NN,2,IAT)=DTINT(NN,2,IAT)+DUMY*DUMINT
CZ           DTINT(NN,3,IAT)=DTINT(NN,3,IAT)+DUMZ*DUMINT
CZ        ELSE
CZ           DE(1,IAT)=DE(1,IAT)+ DUMX*DIJ(IJ)
CZ           DE(2,IAT)=DE(2,IAT)+ DUMY*DIJ(IJ)
CZ           DE(3,IAT)=DE(3,IAT)+ DUMZ*DIJ(IJ)
CZ        ENDIF
CZ670     CONTINUE
CZ680   CONTINUE
CZ      IF(RMETHOD.EQ.ANESC.AND.MODUS.NE.0) GOTO 1000
C
C     ..... NUCLEAR ATTRACTION
C
CZ700 CONTINUE
      AAX = AA*AX
      AAY = AA*AY
      AAZ = AA*AZ
CZ    IF(ICHARM.EQ.0) THEN
CZ       MAXIC=NAT
CZ       IF(ISEPS) MAXIC=NAT+NPS
CZ    ELSE
CZ       MAXIC=1
CZ    END IF
C
      DO 790 IC = 1,MAXIC
         CALL FMOATFRG(IC,X(LINDAT),X(LINDATG),X(LIAGLOB),
     *                 X(LIALOC),X(LIABDFG),X(LJABDFG),
     *                 X(LINDBD),X(LFMOZAN),X(LFMOC),
     *                 NATFMO+NBDFG,X(LUNTXYZ),X(LPOPMAT),
     *                 KATOM(II),KATOM(JJ),FRACV,FRACESP,
     *                 KFG,ZNUC,CX,CY,CZ)
C        IF (ABS(ZNUC).LT.1.0D-08) GOTO 790
         IF (ABS(FRACESP*ZNUC).LT.1.0D-08) GOTO 790

CZ
CZ       IF(ICHARM.EQ.0) THEN
CZ          IF(IC.LE.NAT) THEN
CZ             ZNUC = -ZAN(IC)
CZ             CX = C(1,IC)
CZ             CY = C(2,IC)
CZ             CZ = C(3,IC)
CZ          ELSE
CZ             IAZ=IATSP(IC-NAT)
CZ             ZNUC = -COSZAN(IC-NAT)
CZ             CX = CORZAN(1,IC-NAT)
CZ             CY = CORZAN(2,IC-NAT)
CZ             CZ = CORZAN(3,IC-NAT)
CZ          END IF
CZ       ELSE
CZ         IF(.NOT.ESD) THEN
CZ          ZNUC = -QCHM(ICHARM)
CZ          CX = XCHM(ICHARM)
CZ          CY = YCHM(ICHARM)
CZ          CZ = ZCHM(ICHARM)
CZ          ENDIF
C           FOR ESD THE VARIABLES ARE SET ABOVE IN ESDDERZ.
CZ       END IF
         XX = AA*((AX-CX)**2+(AY-CY)**2+(AZ-CZ)**2)
         IF(NROOTS.LE.3) CALL RT123
         IF(NROOTS.EQ.4) CALL ROOT4
         IF(NROOTS.EQ.5) CALL ROOT5
         DO 740 K = 1,NROOTS
            UU = AA*U(K)
            WW = W(K)*ZNUC
            TT = ONE/(AA+UU)
            T = SQRT(TT)
            X0 = (AAX+UU*CX)*TT
            Y0 = (AAY+UU*CY)*TT
            Z0 = (AAZ+UU*CZ)*TT
            DO 730 J = 1,LJT
               NJ = J
               DO 720 I = 1,LITDER
                  NI = I
                  CALL VINT
                  XV(I,J,K) = XINT
                  YV(I,J,K) = YINT
                  ZV(I,J,K) = ZINT*WW
  720          CONTINUE
  730       CONTINUE
            CALL DERI(DXV(1,1,K),DYV(1,1,K),DZV(1,1,K),
     *                 XV(1,1,K), YV(1,1,K), ZV(1,1,K),LIT,LJT,AI)
  740    CONTINUE
         IJ=0
         DO 780 I=MINI,MAXI
           IX=IJX(I)
           IY=IJY(I)
           IZ=IJZ(I)
           DO 780 J=MINJ,MAXJ
             JX=IJX(J)
             JY=IJY(J)
             JZ=IJZ(J)
             DUMX=ZERO
             DUMY=ZERO
             DUMZ=ZERO
             DO 770 K=1,NROOTS
               DUMX=DUMX+DXV(IX,JX,K)* YV(IY,JY,K)* ZV(IZ,JZ,K)
               DUMY=DUMY+ XV(IX,JX,K)*DYV(IY,JY,K)* ZV(IZ,JZ,K)
               DUMZ=DUMZ+ XV(IX,JX,K)* YV(IY,JY,K)*DZV(IZ,JZ,K)
  770        CONTINUE
             IJ=IJ+1
CZ 
CZCZCZ ???   IF((IC.GT.NAT).AND.(IAT.EQ.IAZ)) GOTO 780
CZ
             DUMINT=DIJ(IJ)*AA1*PI212
             IF(RMETHOD.EQ.RESC) THEN
                NN=IA(MAX0(LOCI+I,LOCJ+J))+MIN0(LOCI+I,LOCJ+J)
                DVINT(NN,1,IAT)=DVINT(NN,1,IAT)+DUMX*DUMINT
                DVINT(NN,2,IAT)=DVINT(NN,2,IAT)+DUMY*DUMINT
                DVINT(NN,3,IAT)=DVINT(NN,3,IAT)+DUMZ*DUMINT
C               IE. NO CHARMS NOW WITH RESC
             ELSE
CZ              IF(ESD.AND.ICHARM.GT.0) THEN
CZ              SAVE TVDER GRADIENT TERMS TO IBODY ARRAYS
                DDDDX = DUMX*DUMINT
                DDDDY = DUMY*DUMINT
                DDDDZ = DUMZ*DUMINT
                IAZ=IXFTCH(X(LIAGLOB),IAT)
                IF (IDAMM.NE.0) THEN
                  DAMM = IDAMM
                  DAMM = DAMM * FRACESP
                  IOFF=LFMODE         +(IAZ-1)*3
                  X(IOFF  )=X(IOFF  )+DAMM*DDDDX
                  X(IOFF+1)=X(IOFF+1)+DAMM*DDDDY
                  X(IOFF+2)=X(IOFF+2)+DAMM*DDDDZ
                END IF
                IF (IDADD.NE.0) THEN
                  DADD = IDADD
                  DADD = DADD * FRACESP
                  IOFF=LFMODE+3*NATFMO+(IAZ-1)*3
                  X(IOFF  )=X(IOFF  )+DADD*DDDDX
                  X(IOFF+1)=X(IOFF+1)+DADD*DDDDY
                  X(IOFF+2)=X(IOFF+2)+DADD*DDDDZ
                END IF
                IF (IDATT.NE.0) THEN
                  DATT = IDATT
                  DATT = DATT * FRACESP
                  IOFF=LFMODE+6*NATFMO+(IAZ-1)*3
                  X(IOFF  )=X(IOFF  )+DATT*DDDDX
                  X(IOFF+1)=X(IOFF+1)+DATT*DDDDY
                  X(IOFF+2)=X(IOFF+2)+DATT*DDDDZ
                END IF
CZCZ               IAZ=IXFTCH(X(LIAGLOB),IAT)
CZCZ               IOFF=LFMODE+3*NATFMO+(IAZ-1)*3
CZCZ               X(IOFF  )=X(IOFF  )+DUMX*DUMINT
CZCZ               X(IOFF+1)=X(IOFF+1)+DUMY*DUMINT
CZCZ               X(IOFF+2)=X(IOFF+2)+DUMZ*DUMINT
C                  WRITE(6,*) 'WWWADD1',IAZ,IAT
CZ              ELSE
CZ                 I WONDER IF THIS IS TVDER GRADIENT
CZ                 DE(1,IAT)=DE(1,IAT)+DUMX*DUMINT
CZ                 DE(2,IAT)=DE(2,IAT)+DUMY*DUMINT
CZ                 DE(3,IAT)=DE(3,IAT)+DUMZ*DUMINT
CZ              ENDIF
CZCZ            IF(ISEPS.AND.(IC.GT.NAT)) THEN
CZCZ               DE(1,IAZ)=DE(1,IAZ)-DUMX*(DIJ(IJ)*AA1*PI212)
CZCZ               DE(2,IAZ)=DE(2,IAZ)-DUMY*(DIJ(IJ)*AA1*PI212)
CZCZ               DE(3,IAZ)=DE(3,IAZ)-DUMZ*(DIJ(IJ)*AA1*PI212)
CZCZ            END IF
CZ              IF(ICHARM.GT.0) THEN
CZ                 IF(ESD) THEN
CZ              SAVE HELFEY GRADIENT TERMS TO IBODY ARRAYS
CZ
CZ     NOTE THAT THE CALCULATION OF HELFEY TERMS IS MOVED TO 
CZ     SUBROUTINE EXTHELFEY (9/24/2007) 
CZ
CZCZCZ          IF (IDAMM.NE.0) THEN
CZCZCZ            DAMM = IDAMM
CZCZCZ            IOFF=LFMODE         +(IC-1)*3
CZCZCZ            X(IOFF  )=X(IOFF  )-DAMM*DDDDX
CZCZCZ            X(IOFF+1)=X(IOFF+1)-DAMM*DDDDY
CZCZCZ            X(IOFF+2)=X(IOFF+2)-DAMM*DDDDZ
CZCZCZ          END IF
CZCZCZ          IF (IDADD.NE.0) THEN
CZCZCZ            DADD = IDADD
CZCZCZ            IOFF=LFMODE+3*NATFMO+(IC-1)*3
CZCZCZ            X(IOFF  )=X(IOFF  )-DADD*DDDDX
CZCZCZ            X(IOFF+1)=X(IOFF+1)-DADD*DDDDY
CZCZCZ            X(IOFF+2)=X(IOFF+2)-DADD*DDDDZ
CZCZCZ          END IF
CZCZCZ          IF (IDATT.NE.0) THEN
CZCZCZ            DATT = IDATT
CZCZCZ            IOFF=LFMODE+6*NATFMO+(IC-1)*3
CZCZCZ            X(IOFF  )=X(IOFF  )-DATT*DDDDX
CZCZCZ            X(IOFF+1)=X(IOFF+1)-DATT*DDDDY
CZCZCZ            X(IOFF+2)=X(IOFF+2)-DATT*DDDDZ
CZCZCZ          END IF
CZCZ                  IOFF=LFMODE+3*NATFMO+(ICHARM-1)*3
CZCZ                  X(IOFF  )=X(IOFF  )-DUMX*DUMINT
CZCZ                  X(IOFF+1)=X(IOFF+1)-DUMY*DUMINT
CZCZ                  X(IOFF+2)=X(IOFF+2)-DUMZ*DUMINT
C                     WRITE(6,*) 'WWWADD2',ICHARM
C            CHARMM CODE BELOW NEEDS THE FORCE, NOT THE GRADIENT?
CZ                 ELSE
CZ                    DXELMM(ICHARM)=DXELMM(ICHARM)+DUMX*DUMINT
CZ                    DYELMM(ICHARM)=DYELMM(ICHARM)+DUMY*DUMINT
CZ                    DZELMM(ICHARM)=DZELMM(ICHARM)+DUMZ*DUMINT
CZ                 ENDIF
CZ             END IF
             ENDIF
  780    CONTINUE
  790 CONTINUE
C
 1000 CONTINUE
 1100 CONTINUE
C
C     ----- END OF PRIMITIVE LOOPS -----
C
      IF(DBG) THEN
         WRITE(IW,9100) II,JJ
         CALL EGOUT(DE,NAT)
      END IF
 1300 CONTINUE
 1400 CONTINUE
C
C     ----- END OF SHELL LOOPS -----
C
CZCZ
C2000 CONTINUE
CZCZ
      IF(OUT) THEN
         IF(GOPARR) CALL DDI_GSUMF(1503,DE,3*NAT)
         IF(MASWRK) THEN
            WRITE(IW,9000)
            CALL EGOUT(DE,NAT)
         END IF
         IF(GOPARR) CALL DSCAL(3*NAT,ONE/NPROC,DE,1)
C              WILL ONLY PRINT PARTIAL CONTRIBUTIONS IN PARALLEL.
CZCZ     IF(ESD) THEN
         IF(.TRUE.) THEN
            IF(MASWRK) WRITE(IW,9088)
            CALL EGOUT(X(LFMODE+3*NATFMO),NATFMO)
         END IF
      END IF
CZCZ     IF(ESD) THEN
CZCZ FOR DEBUG
         DEBUGOPT=.FALSE.
         IF(DEBUGOPT) THEN
            IF(MASWRK) WRITE(IW,9088)
            IF(MASWRK) WRITE(IW,*) 'NATNAT',NAT
            CALL EGOUT(X(LFMODE),NATFMO*NBODY)
         END IF
CZCZ
C
CZ
      IF(GOPARR .AND. NXT) CALL DDI_DLBRESET
C
      IF(RMETHOD.EQ.RESC) THEN
        IF(GOPARR) CALL DDI_GSUMF(1503,DTINT,L2*3*NAT)
        IF(GOPARR) CALL DDI_GSUMF(1504,DVINT,L2*3*NAT)
        SVDSKW=DSKWRK
        DSKWRK=.TRUE.
         LREC=3*NAT
C        STARTING RECORD FOR THE T DERIVATIVE INTEGRALS
        DO I=1,NAT
          DO J=1,3
            LREC=LREC+1
            CALL RAWRIT(NQRDAF,X(MORDA),DTINT(1,J,I),L2,LREC,0)
C
C           ADD TWO CONTRIBUTIONS, HELLMANN-FEYNMAN AND DV GOT HERE
C
            CALL RAREAD(NQRDAF,X(MORDA),DTINT(1,J,I),L2,LREC+6*NAT,0)
            CALL DAXPY(L2,ONE,DTINT(1,J,I),1,DVINT(1,J,I),1)
            CALL RAWRIT(NQRDAF,X(MORDA),DVINT(1,J,I),L2,LREC+6*NAT,0)
          ENDDO
        ENDDO
        DSKWRK=SVDSKW
      ENDIF
C
      RETURN
C
 9000 FORMAT(/10X,38(1H-)/10X,'GRADIENT INCLUDING AO DERIVATIVE TERMS'/
     *        10X,38(1H-))
 9088 FORMAT(/10X,36(1H-)/10X,'ONE-ELECTRON ESD GRADIENT',/10X,36(1H-))
 9100 FORMAT(1X,'TVDER: SHELLS II,JJ=',2I5)
      END
C*MODULE FMOESD  *DECK EXTSDER
      SUBROUTINE EXTSDER(EPS,DSINT,L1,L2,NOCON,LMONLAG,NUM0)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL DBG,NORM,OUT
      LOGICAL GOPARR,DSKWRK,MASWRK,NXT,SVDSKW,NOCON
CZ
      LOGICAL LMONLAG
CZ
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000, MXAO=8192)
C
      DIMENSION EPS(L2),DSINT(L2,3,NAT)
      DIMENSION DIJ(225), DIJINT(225), IJX(35), IJY(35),IJZ(35),
     *           XS(6,5), YS(6,5), ZS(6,5),
     *          DXS(5,5),DYS(5,5),DZS(5,5)
C
      COMMON /DSTV  / XINT,YINT,ZINT,T,X0,Y0,Z0,XI,YI,ZI,
     *                XJ,YJ,ZJ,NI,NJ,CX,CY,CZ
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /RELWFN/ RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,IQRORD,MODQR,NESOC,
     *                NRATOM,NUMU,NQMTR,NQRDAF,MORDA,NDARELB
      COMMON /FMCOM / X(1)
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT
C
      PARAMETER (SQRT3=1.73205080756888D+00)
      PARAMETER (SQRT5=2.23606797749979D+00, SQRT7=2.64575131106459D+00)
      PARAMETER (ONE=1.0D+00)
      PARAMETER (RLN10=2.30258D+00)
C
      DATA DEBUG/8HDEBUG   /, DBUGME/8HSDER    /, GRD1/8HGRD1    /,
     *     RESC/8HRESC    /
C
      DATA IJX / 1, 2, 1, 1, 3, 1, 1, 2, 2, 1,
     *           4, 1, 1, 3, 3, 2, 1, 2, 1, 2,
     *           5, 1, 1, 4, 4, 2, 1, 2, 1, 3,
     *           3, 1, 3, 2, 2/
      DATA IJY / 1, 1, 2, 1, 1, 3, 1, 2, 1, 2,
     *           1, 4, 1, 2, 1, 3, 3, 1, 2, 2,
     *           1, 5, 1, 2, 1, 4, 4, 1, 2, 3,
     *           1, 3, 2, 3, 2/
      DATA IJZ / 1, 1, 1, 2, 1, 1, 3, 1, 2, 2,
     *           1, 1, 4, 1, 2, 1, 2, 3, 3, 2,
     *           1, 1, 5, 1, 2, 1, 2, 4, 4, 1,
     *           3, 3, 2, 2, 3/
C
C     ----- CALCULATE DERIVATIVES OF THE OVERLAP MATRIX -----
C     THIS TERM RESULTS FROM DERIVATIVES OF THE DENSITY MATRIX,
C     WHICH CAN IN THE CASE OF A SYMMETRIC LAGRANGIAN MATRIX, CAN
C     BE CONVERTED INSTEAD INTO DERIVATIVES OF OVERLAP INTEGRALS.
C     RESC RUNS NEED BOTH CONTRACTION OF THE INTEGRALS WITH DENSITY
C     AND THE INTEGRALS THEMSELVES.
C     IN CASE OF INTERNALLY UNCONTRACTED RESC, ONE HAS TO TRANSFORM
C     THE OVERLAP DERIVATIVES TO CONTRACTED BASIS BEFORE
C     SUMMING (CONTRACTING) OVERLAP DERIVATIVES WITH THE LAGRANGIAN
C
C     NOCON IS TRUE IF LAGRANGIAN IS NOT TO BE SUMMED WITH.
C
      DBG = (EXETYP.EQ.DEBUG  .OR.  EXETYP.EQ.DBUGME)  .AND.  MASWRK
      OUT = (EXETYP.EQ.DEBUG  .OR.  EXETYP.EQ.DBUGME  .OR.
     *       EXETYP.EQ.GRD1   .OR.  NPRINT.EQ.-3)
      IF(DBG) WRITE(IW,9000)
C
      TOL = RLN10*ITOL
      NORM = NORMF .NE. 1 .OR. NORMP .NE. 1
CZCZ  IF(RMETHOD.EQ.RESC) CALL VCLR(DSINT,1,L2*3*NAT)
      IF(LMONLAG) CALL VCLR(DSINT,1,L2*3*NAT)
CZ
C
C     INITIALIZE PARALLEL
C
      NXT = IBTYP.EQ.1
      IPCOUNT = ME - 1
      NEXT = -1
      MINE = -1
C
      IF(DBG) THEN
         WRITE(IW,9010)
         CALL PRTRI(EPS,L1)
      END IF
C
C     ----- I SHELL
C
CZCZ  DO 780 II = 1,NSHELL
      DO 780 II = NCURSH+1,NSHELL
CZ
C
C           GO PARALLEL!
C
      IF(NXT .AND. GOPARR) THEN
         MINE = MINE + 1
         IF(MINE.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
         IF(NEXT.NE.MINE) GO TO 780
      END IF
C
      IAT = KATOM(II)
      XI = C(1,IAT)
      YI = C(2,IAT)
      ZI = C(3,IAT)
      I1 = KSTART(II)
      I2 = I1+KNG(II)-1
      LIT = KTYPE(II)
      MINI = KMIN(II)
      MAXI = KMAX(II)
      LOCI = KLOC(II)-MINI
      LITDER = LIT+1
C
C     ----- J SHELL
C
CZCZ  DO 760 JJ = 1,II
      DO 760 JJ = NCURSH+1,II
CZ
C
C           GO PARALLEL!
C
      IF((.NOT.NXT) .AND. GOPARR) THEN
         IPCOUNT = IPCOUNT + 1
         IF(MOD(IPCOUNT,NPROC).NE.0) GO TO 760
      END IF
C
      JAT = KATOM(JJ)
      XJ = C(1,JAT)
      YJ = C(2,JAT)
      ZJ = C(3,JAT)
      J1 = KSTART(JJ)
      J2 = J1+KNG(JJ)-1
      LJT = KTYPE(JJ)
      MINJ = KMIN(JJ)
      MAXJ = KMAX(JJ)
      LOCJ = KLOC(JJ)-MINJ
      RR = (XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
      IF(II.EQ.JJ) GO TO 760
C
C     ----- I PRIMITIVE
C
      DO 640 IG = I1,I2
        AI = EX(IG)
        ARRI = AI*RR
        AXI = AI*XI
        AYI = AI*YI
        AZI = AI*ZI
        CSI=CS(IG)
        CPI=CP(IG)
        CDI=CD(IG)
        CFI=CF(IG)
        CGI=CG(IG)
C
C     ----- J PRIMITIVE
C
        DO 620 JG = J1,J2
          AJ = EX(JG)
          AA = AI+AJ
          AA1 = ONE/AA
          DUM = AJ*ARRI*AA1
          IF(DUM .GT. TOL) GO TO 620
          FAC = EXP(-DUM)
          CSJ = CS(JG)
          CPJ = CP(JG)
          CDJ = CD(JG)
          CFJ = CF(JG)
          CGJ = CG(JG)
          AX = (AXI+AJ*XJ)*AA1
          AY = (AYI+AJ*YJ)*AA1
          AZ = (AZI+AJ*ZJ)*AA1
C
C     ----- DENSITY FACTOR
C
          IJ = 0
          DO 580 I = MINI,MAXI
            IF(I.EQ.1) DUM1=CSI*FAC
            IF(I.EQ.2) DUM1=CPI*FAC
            IF(I.EQ.5) DUM1=CDI*FAC
            IF(I.EQ.8.AND.NORM) DUM1=DUM1*SQRT3
            IF(I.EQ.11) DUM1=CFI*FAC
            IF(I.EQ.14.AND.NORM) DUM1=DUM1*SQRT5
            IF(I.EQ.20.AND.NORM) DUM1=DUM1*SQRT3
            IF(I.EQ.21) DUM1=CGI*FAC
            IF(I.EQ.24.AND.NORM) DUM1=DUM1*SQRT7
            IF(I.EQ.30.AND.NORM) DUM1=DUM1*SQRT5/SQRT3
            IF(I.EQ.33.AND.NORM) DUM1=DUM1*SQRT3
            DO 570 J = MINJ,MAXJ
              IF(J.EQ.1) DUM2=DUM1*CSJ
              IF(J.EQ.2) DUM2=DUM1*CPJ
              IF(J.EQ.5) DUM2=DUM1*CDJ
              IF(J.EQ.8.AND.NORM) DUM2=DUM2*SQRT3
              IF(J.EQ.11) DUM2=DUM1*CFJ
              IF(J.EQ.14.AND.NORM) DUM2=DUM2*SQRT5
              IF(J.EQ.20.AND.NORM) DUM2=DUM2*SQRT3
              IF(J.EQ.21) DUM2=DUM1*CGJ
              IF(J.EQ.24.AND.NORM) DUM2=DUM2*SQRT7
              IF(J.EQ.30.AND.NORM) DUM2=DUM2*SQRT5/SQRT3
              IF(J.EQ.33.AND.NORM) DUM2=DUM2*SQRT3
              IJ=IJ+1
CZCZ          NN=IA(LOCI+I)+(LOCJ+J)
              NN=IA(LOCI+I-NUM0)+(LOCJ+J-NUM0)
CZCZ DJUST THE POSITION OF EPS()
CZCZ          IF(RMETHOD.EQ.RESC) THEN
              IF(LMONLAG) THEN
                DIJINT(IJ)=DUM2
              ENDIF
              DEN = EPS(NN)
              DEN=DEN+DEN
              DIJ(IJ) = DUM2*DEN
  570       CONTINUE
  580     CONTINUE
C
C     ----- OVERLAP
C
      T = SQRT(AA1)
      X0 = AX
      Y0 = AY
      Z0 = AZ
      DO 590 J = 1,LJT
        NJ = J
        DO 590 I = 1,LITDER
          NI = I
          CALL VINT
          XS(I,J)=XINT*T
          YS(I,J)=YINT*T
          ZS(I,J)=ZINT*T
  590 CONTINUE
C
      CALL DERI(DXS,DYS,DZS,XS,YS,ZS,LIT,LJT,AI)
C
      IJ=0
      DO 600 I=MINI,MAXI
        IX=IJX(I)
        IY=IJY(I)
        IZ=IJZ(I)
        DO 600 J=MINJ,MAXJ
          JX=IJX(J)
          JY=IJY(J)
          JZ=IJZ(J)
          DUMX=DXS(IX,JX)* YS(IY,JY)* ZS(IZ,JZ)
          DUMY= XS(IX,JX)*DYS(IY,JY)* ZS(IZ,JZ)
          DUMZ= XS(IX,JX)* YS(IY,JY)*DZS(IZ,JZ)
          IJ=IJ+1
CZCZ      IF(RMETHOD.EQ.RESC) THEN
          IF(LMONLAG) THEN
            NN=IA(LOCI+I)+(LOCJ+J)
            DUMINT=DIJINT(IJ)
            DSINT(NN,1,IAT)=DSINT(NN,1,IAT)+DUMX*DUMINT
            DSINT(NN,2,IAT)=DSINT(NN,2,IAT)+DUMY*DUMINT
            DSINT(NN,3,IAT)=DSINT(NN,3,IAT)+DUMZ*DUMINT
            DSINT(NN,1,JAT)=DSINT(NN,1,JAT)-DUMX*DUMINT
            DSINT(NN,2,JAT)=DSINT(NN,2,JAT)-DUMY*DUMINT
            DSINT(NN,3,JAT)=DSINT(NN,3,JAT)-DUMZ*DUMINT
          ENDIF
          IF(.NOT.NOCON) THEN
            DE(1,IAT)=DE(1,IAT)+(DUMX*DIJ(IJ))
            DE(2,IAT)=DE(2,IAT)+(DUMY*DIJ(IJ))
            DE(3,IAT)=DE(3,IAT)+(DUMZ*DIJ(IJ))
            DE(1,JAT)=DE(1,JAT)-(DUMX*DIJ(IJ))
            DE(2,JAT)=DE(2,JAT)-(DUMY*DIJ(IJ))
            DE(3,JAT)=DE(3,JAT)-(DUMZ*DIJ(IJ))
          ENDIF
  600 CONTINUE
C
  620 CONTINUE
  640 CONTINUE
C
C     ----- END OF PRIMITIVE LOOPS -----
C
      IF(DBG) THEN
         WRITE(IW,9100) II,JJ
         CALL EGOUT(DE,NAT)
      END IF
  760 CONTINUE
  780 CONTINUE
C
C     ----- END OF SHELL LOOPS -----
C
      IF(OUT) THEN
         IF(GOPARR) CALL DDI_GSUMF(1501,DE,3*NAT)
         IF(MASWRK) THEN
            WRITE(IW,9000)
            CALL EGOUT(DE,NAT)
         END IF
         IF(GOPARR) CALL DSCAL(3*NAT,ONE/NPROC,DE,1)
      END IF
      IF(GOPARR .AND. NXT) CALL DDI_DLBRESET
C
      IF(RMETHOD.EQ.RESC) THEN
        IF(GOPARR) CALL DDI_GSUMF(1501,DSINT,L2*3*NAT)
        SVDSKW=DSKWRK
        DSKWRK=.TRUE.
        LREC=0
C       STARTING RECORD FOR THE S DERIVATIVE INTEGRALS
        DO I=1,NAT
          DO J=1,3
            LREC=LREC+1
            CALL RAWRIT(NQRDAF,X(MORDA),DSINT(1,J,I),L2,LREC,0)
          ENDDO
        ENDDO
        DSKWRK=SVDSKW
      ENDIF
C
      RETURN
C
 9000 FORMAT(/10X,33(1H-)/10X,'GRADIENT INCLUDING DENSITY FORCES'/
     *        10X,33(1H-))
 9010 FORMAT(1X,'THE LAGRANGIAN IN THE AO BASIS IS')
 9100 FORMAT(1X,'SDER: SHELLS II,JJ=',2I5)
      END
C*MODULE FMOESD  *DECK ESDNSDER
      SUBROUTINE ESDNSDER(L1,L2,DA,DB,DC,WRK,WRK1,LAYFRG,IDMREC0,
     *                    ESPA,WRKESP,NUMFRG,
     *                    MAPI,MAPJ,MAP3,MAXL1D,IREC0,
     *                    ORBXCH1,ENEXCH1,KODEXCH,JODEXCH,IODEXCH)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000,ONE=1.0D+00,HALF=0.5D+00)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,DODDCOR,SOME1,ORBXCH1,ENEXCH1
      LOGICAL KODEXCH,JODEXCH,IODEXCH
C
      DIMENSION LAYFRG(*),IDMREC0(*)
C
      DIMENSION DA(1),DB(1),DC(1)
      DIMENSION ESPA(1),WRK(1),WRK1(1),WRKESP(1)
      DIMENSION NUMFRG(1)
      DIMENSION MAPI(1),MAPJ(1),MAP3(MAXL1D,3) 
C
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(3),
     *                ORSHFT,CNVAFO,IXESP,MXITFG,NGUESS,NBSSE,MODORB,
     *                MODPAR,IRSTSTP,IRSTLAY,NPRFMO,NFMOPAL,MODPRP,
     *                MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,MODLMO,NOPDEN,
     *                MOFOCK
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      DATA RNONE/8HNONE    /
CZ
CZ    DENSITY DERIVATIVES OF EXTERNAL ELECTROSTATIC POTENTIALS
CZ
      SOME1 = .FALSE.
      IFG  = ICURFG
      JFG  = JCURFG
      KFG  = KCURFG
      ILAY = ICURLAY
      L1I  = IAND(NUMFRG(IFG),65535)
      NAI  = ISHFT(NUMFRG(IFG),-16)
      NATI = IXFTCH(X(LNATFRG),IFG)
      MULI=IXFTCH(X(LMULFG),IFG)
      NBI=NAI-MULI+1
      IF (JFG.NE.0) THEN
        L1J  = IAND(NUMFRG(JFG),65535)
        NAJ  = ISHFT(NUMFRG(JFG),-16)
        NATJ = IXFTCH(X(LNATFRG),JFG)
        MULJ=IXFTCH(X(LMULFG),JFG)
        NBJ=NAJ-MULJ+1
      END IF
      IF (KFG.NE.0) THEN
        L1K  = IAND(NUMFRG(KFG),65535)
        NAK  = ISHFT(NUMFRG(KFG),-16)
        NATK = IXFTCH(X(LNATFRG),KFG)
        MULK=IXFTCH(X(LMULFG),KFG)
        NBK=NAK-MULK+1
      END IF
      IF (MPLEVL.EQ.0.AND.TDDFTYP.EQ.RNONE) THEN
        CALL DAREAD(IDAF,IODA,WRKESP,L2,16,0)
      ELSE
        CALL DAREAD(IDAF,IODA,WRKESP,L2,308,0)
      END IF
CZ
CZ    CONSTRUCT DI + DJ (+ DK) BLOCK DIAGONAL MATRIX (STORED IN ESPB) 
CZ
      IF (IFMOSTP.EQ.4.OR.IFMOSTP.EQ.8) THEN
        DODDCOR=IAND(IXESP,1024).NE.0
        IREC0 = IDMREC0(ILAY)
        IF(DODDCOR) THEN
          IREC0RHF=1
          IF(IREC0.EQ.1) IREC0RHF=NFG*2+1
          IREC0=IREC0RHF
        ENDIF
      END IF

      NN = 1 
      IF (IFMOSTP.EQ.4) THEN
        NN = 2
        CALL DIMINID(0,JFG,IFG,L1J,L1I,NAJ,NAI,NBJ,NBI,L1,DA,DB,WRK,
     *               WRK1,X(LIODFMO),IREC0,X(LIABDFG),X(LJABDFG),
     *               X(LINDAT),X(LIAGLOB),X(LLOCFMO),MAPJ,MAPI,
     *               ORBXCH1,ENEXCH1,JODEXCH,IODEXCH,0,
     *               DUM,SOME1)
      ELSEIF (IFMOSTP.EQ.8) THEN
        NN = 3
        CALL TRIMINID(KFG,JFG,IFG,L1K,L1J,L1I,NAK,NAJ,NAI,NBK,NBJ,NBI,
     *                L1,DA,DB,DC,WRK,WRK1,X(LIODFMO),IREC0,X(LIABDFG),
     *                X(LJABDFG),X(LINDAT),X(LIAGLOB),X(LLOCFMO),
     *                MAP3(1,3),MAP3(1,2),MAP3(1,1),
     *                ORBXCH1,ENEXCH1,KODEXCH,JODEXCH,IODEXCH,SOME1)
      END IF
CZ
CZ    NOTE THAT DIMINID AND TRIMINID DESTROY NO. 16 OF DICTIONARY FILE
CZ

CZ
CZ    CALCULATE -(DI*VIJ*DI+DJ*VIJ*DJ)*SDER FOR DIMER
CZ
      CALL VCLR(DE,1,NAT*3)
CZ
CZ    CONSTRUCT MONOMER LAGRANGIAN TERM
CZ    NOTE: SINCE THE TERMS RELATIVE TO FMOESPA ARE CALCULATED HERE,
CZ    THE TERMS MUST BE SUBTRACTED USING FMOLAG IN GRAD1.SRC. 
CZ
      IF (IFMOSTP.EQ.4) THEN
        NATF2 = 3*NATFMO
        CALL ESLAGRN(L1,L1I,L1J,L1J,NAI,NAJ,NAK,NBI,NBJ,NBK,NATI,NATJ,
     *               NATJ,ORBXCH1,IODEXCH,JODEXCH,KODEXCH,
     *               WRK,DB,LAYFRG,IDMREC0,ESPA,
     *               MAPI,MAPJ,MAPI,
     *               IREC0,X(LIAGLOB),X(LFMODE+NATF2))
      ELSEIF (IFMOSTP.EQ.8) THEN
        NATF3 = 6*NATFMO
        CALL ESLAGRN(L1,L1I,L1J,L1K,NAI,NAJ,NAK,NBI,NBJ,NBK,NATI,NATJ,
     *               NATK,ORBXCH1,IODEXCH,JODEXCH,KODEXCH,
     *               WRK,DB,LAYFRG,IDMREC0,ESPA,
     *               MAP3(1,1),MAP3(1,2),MAP3(1,3),
     *               IREC0,X(LIAGLOB),X(LFMODE+NATF3))
      END IF
CZ
CZ    DI, DIJ OR DIJK DERIVATIVES 
CZ
C     IF (MASWRK) THEN
C       WRITE (6,*) 'DENSITY2',L1,L1I,L1J
C       DO I = 1, L1
C         K = (I*I-I)/2
C         WRITE (6,'(6F12.8)') (DA(K+J),J=1,I) 
C       END DO
C     END IF
      CALL CPYTSQ(WRKESP,DA(L2+1),L1,1)
      CALL TFTRI(WRK,ESPA,DA(L2+1),WRK(L2+1),L1,L1,L1)
      CALL DSCAL(L2,-HALF,WRK,1)
      CALL SDER(WRK,WRK(L2+1),L1,L2,.FALSE.)

      IF(GOPARR) CALL DDI_GSUMF(2418,DE,NAT*3)

      IF (MASWRK) THEN
        IF (NN.EQ.1) THEN
          CALL FMODEG(1,X(LFMODE),X(LFMOPG),X(LIAGLOB))
        ELSEIF (NN.EQ.2) THEN
          NFMOPT = LFMODE + NATFMO*3
          CALL FMODEG(1,X(NFMOPT),X(LFMOPG),X(LIAGLOB))
          NFMOPT = NFMOPT + NATFMO*3
          IF (NBODY.GT.2) CALL FMODEG(0,X(NFMOPT),X(LFMOPG),X(LIAGLOB))
          ! ABOVE MUST BE CHANGED
        ELSEIF (NN.EQ.3) THEN
          NFMOPT = LFMODE + NATFMO*6
          CALL FMODEG(1,X(NFMOPT),X(LFMOPG),X(LIAGLOB))
        END IF
      END IF

CZ
CZ    NOW DA IS DELTA DIJ WHICH IS USED FOR OTHER DERIVATIVES
CZ
      IF (NN.GE.2) THEN 
        CALL DAXPY(L2,-ONE,WRKESP,1,DA,1)
        DO I = 1, L2
          DA(I) = -DA(I)
        END DO
      ELSE
        CALL DCOPY(L2,WRKESP,1,DA,1)
      END IF

      RETURN
      END
C*MODULE FMOESD  *DECK ESLAGRN
      SUBROUTINE ESLAGRN(L1,L1I,L1J,L1K,NAI,NAJ,NAK,NBI,NBJ,NBK,NATI,
     *                   NATJ,NATK,ORBXCH,IODEXCH,JODEXCH,KODEXCH,
     *                   WRK,WRK1,LAYFRG,IDMREC0,
     *                   ESPA,MAPI,MAPJ,MAPK,IREC0,IAGLOB,FMODE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (HALF=0.5D+00,ZERO=0.0D+00)
      LOGICAL GOPARR,DSKWRK,MASWRK,DODDCOR
      LOGICAL ISINI, ISINJ, ISINK, ORBXCH,IODEXCH,JODEXCH,KODEXCH
CZ
      DIMENSION LAYFRG(*),IDMREC0(*)
      DIMENSION ESPA(*),WRK(*),WRK1(*)
      DIMENSION IAGLOB(*)
      DIMENSION MAPI(*),MAPJ(*),MAPK(*) 
      DIMENSION FMODE(3,*)

      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(3),
     *                ORSHFT,CNVAFO,IXESP,MXITFG,NGUESS,NBSSE,MODORB,
     *                MODPAR,IRSTSTP,IRSTLAY,NPRFMO,NFMOPAL,MODPRP,
     *                MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,MODLMO,NOPDEN,
     *                MOFOCK
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT
      PARAMETER (TWO=2.0D+00)
CZ
CZ    THIS CALCULATES LAGRANGIAN-LIKE TERMS (DI+DJ)*VIJ
CZ
      IF (IFMOSTP.NE.4) THEN
        WRITE(IW,*) 'ESLAGRN MUST BE CALLED IN ESD'
        CALL ABRT
      END IF

      IFG = ICURFG
      JFG = JCURFG
      KFG = KCURFG
      IF (IFG.EQ.0.OR.JFG.EQ.0) THEN
        WRITE(6,*) 'DETECT A BUG IN DIMER ESLAGRN'
        CALL ABRT
      END IF 
CZ
CZ    L1 IS SUPPOSED TO BE FOR DIMERS
CZ
      L1A = L1
      DODDCOR=IAND(IXESP,1024).NE.0
CZ
CZ    CALCULATION FOR IFG
CZ
      ILAY=ICURLAY
      KLAY=MIN(ILAY,LAYFRG(IFG))
      IREC0 = IDMREC0(KLAY)
      IF(DODDCOR) THEN
        IREC0RHF=1
        IF(IREC0.EQ.1) IREC0RHF=NFG*2+1
        IREC0=IREC0RHF
      ENDIF
      IDMREC0I=IFG+IREC0
CZCZ  CALL CLOSDA('DELETE')
CZCZ  CALL OPENDA(0)
CZCZ  CALL MAKEMOL(IFG,0,0,KLAY,0,0,0,0,0,0,0,.TRUE.)
      CALL MAKEMOL(IFG,0,0,KLAY,0,0,0,0,0,0,0,.FALSE.)
C
      L2I = (L1I*L1I + L1I)/2
      L2J = (L1J*L1J + L1J)/2
      MAXINT = MAX(3*NATI*L2I,3*NATJ*L2J)
      IF (IFMOSTP.EQ.8) THEN
        L2K = (L1K*L1K + L1K)/2
        MAXINT = MAX(MAXINT,3*NATK*L2K)
      END IF
      CALL VALFM(LOADFM)
      LDSINT = LOADFM + 1
      LAST   = LDSINT + MAXINT
      NEED   = LAST - LOADFM - 1
      CALL GETFM(NEED)
CZ 
CZ    HERE THE FIRST ARGUMENT IS DUMMY
CZ
      NCURS  = NCURSH
      NCURSH = 0
      CALL EXTSDER(WRK,X(LDSINT),L1I,L2I,.TRUE.,.TRUE.,0)
      NCURSH = NCURS
      IF(GOPARR) CALL DDI_GSUMF(1501,X(LDSINT),L2I*3*NATI)
C     IF (MASWRK) WRITE(6,'(8F12.8)') (X(LDSINTI+L2I+I-1),I=1,L2I)

C     CALL RAREADS(IDAFMO,X(LIODFMO),WRK,L2I,IDMREC0I,0)
      CALL READMOND(WRK,ORBXCH,IODEXCH,NAI,NBI,L1I,X(LIODFMO),
     *              IDMREC0I)
C     WRITE(6,*) 'WWWDENS',IFG,IREC0,WRK(1),WRK(2)

      CALL CPYTSQ(WRK,WRK(L2I+1),L1I,1)
      IC1 = 0
      DO I = 1, NATI
        IATG=IAGLOB(I)
CZ      IF (MASWRK) WRITE(6,*) 'IATG', IATG
        DO K = 1, 3
          CALL TFTRI(WRK1,X(LDSINT+IC1*L2I),WRK(L2I+1),
     *               WRK1(L2I+1),L1I,L1I,L1I)
          CALL DSCAL(L2I, HALF,WRK1,1)
          IC1 = IC1 + 1

          DECON = ZERO
          LOOP = 0
          DO II = 1, L1A
            DO JJ = 1, II
              TEMP = ZERO
              LOOP = LOOP + 1
              II1=MAPI(II)
              IJ1=MAPI(JJ)
              II2=MAX(II1,IJ1)
              IJ2=MIN(II1,IJ1)
              ISINI=II1.NE.0.AND.IJ1.NE.0
              IF (ISINI) THEN
                TEMP = WRK1((II2*II2-II2)/2+IJ2)
              END IF

              IF (TEMP.NE.ZERO) THEN
                IF (II.EQ.JJ) THEN
                  DECON = DECON +     TEMP*ESPA(LOOP)
                ELSE
                  DECON = DECON + TWO*TEMP*ESPA(LOOP)
                END IF
              END IF
            END DO
          END DO

          IF (MASWRK) FMODE(K,IATG) = FMODE(K,IATG) + DECON
        END DO
      END DO

CZ
CZ    CALCULATION FOR JFG
CZ
      KLAY=MIN(ILAY,LAYFRG(JFG))
      IREC0 = IDMREC0(KLAY)
      IF(DODDCOR) THEN
        IREC0RHF=1
        IF(IREC0.EQ.1) IREC0RHF=NFG*2+1
        IREC0=IREC0RHF
      ENDIF
      IDMREC0J=JFG+IREC0
CZCZ  CALL CLOSDA('DELETE')
CZCZ  CALL OPENDA(0)
CZCZ  CALL MAKEMOL(JFG,0,0,KLAY,0,0,0,0,0,0,0,.TRUE.)
      CALL MAKEMOL(JFG,0,0,KLAY,0,0,0,0,0,0,0,.FALSE.)

      NCURS  = NCURSH
      NCURSH = 0
      CALL EXTSDER(WRK,X(LDSINT),L1J,L2J,.TRUE.,.TRUE.,0)
      NCURSH = NCURS
      IF(GOPARR) CALL DDI_GSUMF(1501,X(LDSINT),L2J*3*NATJ)
C     IF (MASWRK) WRITE(6,'(8F12.8)') (X(LDSINT+L2J+I-1),I=1,L2J)

C     CALL RAREADS(IDAFMO,X(LIODFMO),WRK,L2J,IDMREC0J,0)
      CALL READMOND(WRK,ORBXCH,JODEXCH,NAJ,NBJ,L1J,X(LIODFMO),
     *              IDMREC0J)

      CALL CPYTSQ(WRK,WRK(L2J+1),L1J,1)
      IC1 = 0
      DO J = 1, NATJ
        JATG=IAGLOB(J)
        DO K = 1, 3
          CALL TFTRI(WRK1,X(LDSINT+IC1*L2J),WRK(L2J+1),
     *               WRK1(L2J+1),L1J,L1J,L1J)
          CALL DSCAL(L2J, HALF,WRK1,1)
          IC1 = IC1 + 1

          DECON = ZERO
          LOOP  = 0
          DO II = 1, L1A
            DO JJ = 1, II
              TEMP = ZERO
              LOOP = LOOP + 1
              JI1=MAPJ(II)
              JJ1=MAPJ(JJ)
              JI2=MAX(JI1,JJ1)
              JJ2=MIN(JI1,JJ1)
              ISINJ=JI1.NE.0.AND.JJ1.NE.0
              IF (ISINJ) THEN
                TEMP = WRK1((JI2*JI2-JI2)/2+JJ2)
              END IF

              IF (TEMP.NE.ZERO) THEN
                IF (II.EQ.JJ) THEN
                  DECON = DECON +     TEMP*ESPA(LOOP)
                ELSE
                  DECON = DECON + TWO*TEMP*ESPA(LOOP)
                END IF
              END IF
            END DO
          END DO

          IF (MASWRK) FMODE(K,JATG) = FMODE(K,JATG) + DECON
        END DO
      END DO

CZ
CZ    CALCULATION FOR KFG
CZ
      IF (IFMOSTP.EQ.8) THEN
        KLAY=MIN(ILAY,LAYFRG(KFG))
        IREC0 = IDMREC0(KLAY)
        IF(DODDCOR) THEN
          IREC0RHF=1
          IF(IREC0.EQ.1) IREC0RHF=NFG*2+1
          IREC0=IREC0RHF
        ENDIF
        IDMREC0K=KFG+IREC0
CZCZ    CALL CLOSDA('DELETE')
CZCZ    CALL OPENDA(0)
CZCZ    CALL MAKEMOL(KFG,0,0,KLAY,0,0,0,0,0,0,0,.TRUE.)
        CALL MAKEMOL(KFG,0,0,KLAY,0,0,0,0,0,0,0,.FALSE.)

        NCURS  = NCURSH
        NCURSH = 0
        CALL EXTSDER(WRK,X(LDSINT),L1K,L2K,.TRUE.,.TRUE.,0)
        NCURSH = NCURS
        IF(GOPARR) CALL DDI_GSUMF(1501,X(LDSINT),L2K*3*NATK)
C       IF (MASWRK) WRITE(6,'(8F12.8)') (X(LDSINT+L2K+I-1),I=1,L2J)

C       CALL RAREADS(IDAFMO,X(LIODFMO),WRK,L2K,IDMREC0K,0)
        CALL READMOND(WRK,ORBXCH,KODEXCH,NAK,NBK,L1K,X(LIODFMO),
     *                IDMREC0K)

        CALL CPYTSQ(WRK,WRK(L2K+1),L1K,1)
        IC1 = 0
        DO LL = 1, NATK
          KATG=IAGLOB(LL)
          DO K = 1, 3
            CALL TFTRI(WRK1,X(LDSINT+IC1*L2K),WRK(L2K+1),
     *                 WRK1(L2K+1),L1K,L1K,L1K)
            CALL DSCAL(L2J, HALF,WRK1,1)
            IC1 = IC1 + 1

            DECON = ZERO
            LOOP  = 0
            DO II = 1, L1A
              DO JJ = 1, II
                TEMP = ZERO
                LOOP = LOOP + 1
                KI1=MAPK(II)
                KJ1=MAPK(JJ)
                KI2=MAX(KI1,KJ1)
                KJ2=MIN(KI1,KJ1)
                ISINK=KI1.NE.0.AND.KJ1.NE.0
                IF (ISINK) THEN
                  TEMP = WRK1((KI2*KI2-KI2)/2+KJ2)
                END IF

                IF (TEMP.NE.ZERO) THEN
                  IF (II.EQ.JJ) THEN
                    DECON = DECON +     TEMP*ESPA(LOOP)
                  ELSE
                    DECON = DECON + TWO*TEMP*ESPA(LOOP)
                  END IF
                END IF
              END DO
            END DO

          IF (MASWRK) FMODE(K,KATG) = FMODE(K,KATG) + DECON
        END DO
      END DO
 
      END IF
      CALL RETFM(NEED)

CZ
CZ    RESTORE THE DIMER CALCULATION
CZ
CZCZ  CALL CLOSDA('DELETE')
CZCZ  CALL OPENDA(0)
      CALL MAKEMOL(IFG,JFG,KFG,ILAY,0,0,0,0,0,0,0,.TRUE.)
      RETURN
      END
CZ
CZ
C*MODULE FMOESD  *DECK MULPOPDA
      SUBROUTINE MULPOPDA(DA,L1,L2,L3,POPDMAT)

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=2000,
     *           HALF=0.5D+00,ZERO=0.0D+00)
C     LOGICAL GOPARR,DSKWRK,MASWRK
C
CZ    DIMENSION DA(*),LAYFRG(*),SCFFRG(*),IDMREC0(*),KARTEN(0:MAXL-1)
      DIMENSION DA(*)
CZ
      DIMENSION POPDMAT(3,MAXNAT,MAXNAT)
CZ
C
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C     COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C     COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(3),
     *                ORSHFT,CNVAFO,IXESP,MXITFG,NGUESS,NBSSE,MODORB,
     *                MODPAR,IRSTSTP,IRSTLAY,NPRFMO,NFMOPAL,MODPRP,
     *                MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,MODLMO,NOPDEN,
     *                MOFOCK
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      DATA RNONE/8HNONE    /
CZ
CZ    THIS ROUTINE COMPUTES THE DERIVATIVES OF MULLIKEN CHARGES
CZ    FOR FRAGMENT MONOMERS.
CZ    NOTE THAT THE DERIVATIVES ARE NOT FULLY ANALYTIC.
CZ    THIS ROUTINE MUST BE ENTERED IN MONOMER CALCULATIONS.
CZ
      RESPPCI = RESPPC(1)
      IF (RESPPCI.EQ.ZERO) RETURN

      MAXDS = L2 + L3
      CALL VALFM(LOADFM)
      LSS   = LOADFM   + 1
      LEPS2 = LSS      + MAXDS
      LWRK  = LEPS2    + L3
      LAST  = LWRK     + L1
      NEED  = LAST - LOADFM - 1
      CALL GETFM(NEED)

      IF (MPLEVL.EQ.0.AND.TDDFTYP.EQ.RNONE) THEN
        CALL DAREAD(IDAF,IODA,DA,L2,16,0)
      ELSE
        CALL DAREAD(IDAF,IODA,DA,L2,308,0)
      ENDIF
      CALL CPYTSQ(DA,DA(L2+1),L1,1)
      CALL DAREAD(IDAF,IODA,X(LSS),L2,12,0)
      CALL CPYTSQ(X(LSS),X(LSS+L2),L1,1)

C     IF (MASWRK) WRITE(6,*) 'IFG JFG NAT',ICURFG,JCURFG,NAT
C     CALL VCLR(POPDMAT,1,3*MAXNAT*MAXNAT)
      DO IAT = 1, NAT
        CALL VCLR(X(LEPS2),1,L3)
        CALL POPDACAL(IAT,L1,X(LSS+L2),DA(L2+1),X(LWRK),X(LEPS2))
        CALL DSCAL(L3,-HALF,X(LEPS2),1)
CZ      CALL PRSQ(X(LEPS2),L1,L1,L1)
        ! X(LWRK) IS DUMMY HERE
        CALL SDERPOP(IAT,DA,X(LEPS2),POPDMAT,X(LWRK),L1,L2,.FALSE.)
      END DO
      CALL RETFM(NEED)

      RETURN
      END
C*MODULE FMOESD  *DECK POPDACAL
      SUBROUTINE POPDACAL(ISTAT,L1,SS,DD,WRK1,EPS2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL GOPARR,DSKWRK,MASWRK
      PARAMETER (MXSH=5000,MXGTOT=20000,ZERO=0.0D+00)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      DIMENSION SS(L1,L1), DD(L1,L1),WRK1(L1)
      DIMENSION EPS2(L1,L1)
C
CNB   FIX THAT
C     DUE TO DMEXCH DIFFICULTIES, CLEAR OUT ALL
C     CALL VCLR(POPMAT,1,NAT)
CZCZ  CALL VCLR(POPMAT,1,MAX(MAXNAT,NAT))
      
CZCZ  CHECK
CZ    SUM=ZERO
CZ    DO JJ=1, NSHELL
CZ      IAT=KATOM(JJ)
CZ      IF (IAT.EQ.ISTAT) THEN
CZ        MINI=KMIN(JJ)
CZ        MAXI=KMAX(JJ)
CZ        LOCI=KLOC(JJ)-MINI

CZ        DO I=MINI,MAXI
CZ          INUM = LOCI + I
CZ          DO II = 1, L1
CZ            SUM = SUM + SS(II,INUM)*DD(II,INUM)
CZ          END DO
CZ        ENDDO
CZ      ENDIF
CZ    END DO
CZ    WRITE (6,'(A,I3,F10.6)') 'TEST ATOMIC POP FOR ATOM', 
CZ   *                          ISTAT, SUM 
CZCZ
      IPCOUNT = ME - 1
      DO I1 = 1, L1
        IF (GOPARR) THEN
           IPCOUNT = IPCOUNT + 1
           IF(MOD(IPCOUNT,NPROC).NE.0) GO TO 100
        END IF

        DO J1 = 1, L1
          SUM=ZERO
          DO II=1, NSHELL
            IAT=KATOM(II)
            IF (IAT.EQ.ISTAT) THEN
              MINI=KMIN(II)
              MAXI=KMAX(II)
              LOCI=KLOC(II)-MINI

              ! R = S*P (NOT TRIANGLE)
              DO I=MINI,MAXI
                INUM = LOCI + I
                SUM = SUM + SS(J1,INUM)*DD(INUM,I1)
              ENDDO
            ENDIF
          END DO
          WRK1(J1) = SUM
        END DO

        ! T = P*R 
        DO J1 = 1, L1
          SUM = ZERO
          DO K1 = 1, L1
            SUM = SUM + DD(J1,K1)*WRK1(K1)
          END DO
          EPS2(I1,J1) = SUM 
        END DO
  100   CONTINUE
      END DO

      IF (GOPARR) CALL DDI_GSUMF(911,EPS2,L1*L1)
      RETURN
      END
C
C*MODULE FMOESD    *DECK SDERPOP
      SUBROUTINE SDERPOP(KAT,EPS,EPS2,POPD,DSINT,L1,L2,NOCON)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL DBG,NORM,OUT
      LOGICAL GOPARR,DSKWRK,MASWRK,NXT,SVDSKW,NOCON
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000, MXAO=8192)
C
      DIMENSION EPS(L2),DSINT(L2,3,NAT)
CZ
      DIMENSION EPS2(L1,L1),POPD(3,MAXNAT,MAXNAT)
      DIMENSION DIJ2(225)
CZ
      DIMENSION DIJ(225), DIJINT(225), IJX(35), IJY(35),IJZ(35),
     *           XS(6,5), YS(6,5), ZS(6,5),
     *          DXS(5,5),DYS(5,5),DZS(5,5)
C
      COMMON /DSTV  / XINT,YINT,ZINT,T,X0,Y0,Z0,XI,YI,ZI,
     *                XJ,YJ,ZJ,NI,NJ,CX,CY,CZ
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /RELWFN/ RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,IQRORD,MODQR,NESOC,
     *                NRATOM,NUMU,NQMTR,NQRDAF,MORDA,NDARELB
      COMMON /FMCOM / X(1)
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2
C
      PARAMETER (SQRT3=1.73205080756888D+00)
      PARAMETER (SQRT5=2.23606797749979D+00, SQRT7=2.64575131106459D+00)
      PARAMETER (ONE=1.0D+00)
      PARAMETER (RLN10=2.30258D+00)
C
      DATA DEBUG/8HDEBUG   /, DBUGME/8HSDER    /, GRD1/8HGRD1    /,
     *     RESC/8HRESC    /
C
      DATA IJX / 1, 2, 1, 1, 3, 1, 1, 2, 2, 1,
     *           4, 1, 1, 3, 3, 2, 1, 2, 1, 2,
     *           5, 1, 1, 4, 4, 2, 1, 2, 1, 3,
     *           3, 1, 3, 2, 2/
      DATA IJY / 1, 1, 2, 1, 1, 3, 1, 2, 1, 2,
     *           1, 4, 1, 2, 1, 3, 3, 1, 2, 2,
     *           1, 5, 1, 2, 1, 4, 4, 1, 2, 3,
     *           1, 3, 2, 3, 2/
      DATA IJZ / 1, 1, 1, 2, 1, 1, 3, 1, 2, 2,
     *           1, 1, 4, 1, 2, 1, 2, 3, 3, 2,
     *           1, 1, 5, 1, 2, 1, 2, 4, 4, 1,
     *           3, 3, 2, 2, 3/
C
C     ----- CALCULATE DERIVATIVES OF THE OVERLAP MATRIX -----
C     THIS TERM RESULTS FROM DERIVATIVES OF THE DENSITY MATRIX,
C     WHICH CAN IN THE CASE OF A SYMMETRIC LAGRANGIAN MATRIX, CAN
C     BE CONVERTED INSTEAD INTO DERIVATIVES OF OVERLAP INTEGRALS.
C     RESC RUNS NEED BOTH CONTRACTION OF THE INTEGRALS WITH DENSITY
C     AND THE INTEGRALS THEMSELVES.
C     IN CASE OF INTERNALLY UNCONTRACTED RESC, ONE HAS TO TRANSFORM
C     THE OVERLAP DERIVATIVES TO CONTRACTED BASIS BEFORE
C     SUMMING (CONTRACTING) OVERLAP DERIVATIVES WITH THE LAGRANGIAN
C
C     NOCON IS TRUE IF LAGRANGIAN IS NOT TO BE SUMMED WITH.
C
      DBG = (EXETYP.EQ.DEBUG  .OR.  EXETYP.EQ.DBUGME)  .AND.  MASWRK
      OUT = (EXETYP.EQ.DEBUG  .OR.  EXETYP.EQ.DBUGME  .OR.
     *       EXETYP.EQ.GRD1   .OR.  NPRINT.EQ.-3)
      IF(DBG) WRITE(IW,9000)
C
      TOL = RLN10*ITOL
      NORM = NORMF .NE. 1 .OR. NORMP .NE. 1
      IF(RMETHOD.EQ.RESC) CALL VCLR(DSINT,1,L2*3*NAT)
C
C     INITIALIZE PARALLEL
C
      NXT = IBTYP.EQ.1
      IPCOUNT = ME - 1
      NEXT = -1
      MINE = -1
C
      IF(DBG) THEN
         WRITE(IW,9010)
         CALL PRTRI(EPS,L1)
      END IF
C
C     ----- I SHELL
C
      DO 780 II = 1,NSHELL
C
C           GO PARALLEL!
C
      IF(NXT .AND. GOPARR) THEN
         MINE = MINE + 1
         IF(MINE.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
         IF(NEXT.NE.MINE) GO TO 780
      END IF
C
      IAT = KATOM(II)
      XI = C(1,IAT)
      YI = C(2,IAT)
      ZI = C(3,IAT)
      I1 = KSTART(II)
      I2 = I1+KNG(II)-1
      LIT = KTYPE(II)
      MINI = KMIN(II)
      MAXI = KMAX(II)
      LOCI = KLOC(II)-MINI
      LITDER = LIT+1
C
C     ----- J SHELL
C
      DO 760 JJ = 1,II
C
C           GO PARALLEL!
C
      IF((.NOT.NXT) .AND. GOPARR) THEN
         IPCOUNT = IPCOUNT + 1
         IF(MOD(IPCOUNT,NPROC).NE.0) GO TO 760
      END IF
C
      JAT = KATOM(JJ)
      XJ = C(1,JAT)
      YJ = C(2,JAT)
      ZJ = C(3,JAT)
      J1 = KSTART(JJ)
      J2 = J1+KNG(JJ)-1
      LJT = KTYPE(JJ)
      MINJ = KMIN(JJ)
      MAXJ = KMAX(JJ)
      LOCJ = KLOC(JJ)-MINJ
      RR = (XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
      IF(II.EQ.JJ) GO TO 760
C
C     ----- I PRIMITIVE
C
      DO 640 IG = I1,I2
        AI = EX(IG)
        ARRI = AI*RR
        AXI = AI*XI
        AYI = AI*YI
        AZI = AI*ZI
        CSI=CS(IG)
        CPI=CP(IG)
        CDI=CD(IG)
        CFI=CF(IG)
        CGI=CG(IG)
C
C     ----- J PRIMITIVE
C
        DO 620 JG = J1,J2
          AJ = EX(JG)
          AA = AI+AJ
          AA1 = ONE/AA
          DUM = AJ*ARRI*AA1
          IF(DUM .GT. TOL) GO TO 620
          FAC = EXP(-DUM)
          CSJ = CS(JG)
          CPJ = CP(JG)
          CDJ = CD(JG)
          CFJ = CF(JG)
          CGJ = CG(JG)
          AX = (AXI+AJ*XJ)*AA1
          AY = (AYI+AJ*YJ)*AA1
          AZ = (AZI+AJ*ZJ)*AA1
C
C     ----- DENSITY FACTOR
C
          IJ = 0
          DO 580 I = MINI,MAXI
            IF(I.EQ.1) DUM1=CSI*FAC
            IF(I.EQ.2) DUM1=CPI*FAC
            IF(I.EQ.5) DUM1=CDI*FAC
            IF(I.EQ.8.AND.NORM) DUM1=DUM1*SQRT3
            IF(I.EQ.11) DUM1=CFI*FAC
            IF(I.EQ.14.AND.NORM) DUM1=DUM1*SQRT5
            IF(I.EQ.20.AND.NORM) DUM1=DUM1*SQRT3
            IF(I.EQ.21) DUM1=CGI*FAC
            IF(I.EQ.24.AND.NORM) DUM1=DUM1*SQRT7
            IF(I.EQ.30.AND.NORM) DUM1=DUM1*SQRT5/SQRT3
            IF(I.EQ.33.AND.NORM) DUM1=DUM1*SQRT3
            DO 570 J = MINJ,MAXJ
              IF(J.EQ.1) DUM2=DUM1*CSJ
              IF(J.EQ.2) DUM2=DUM1*CPJ
              IF(J.EQ.5) DUM2=DUM1*CDJ
              IF(J.EQ.8.AND.NORM) DUM2=DUM2*SQRT3
              IF(J.EQ.11) DUM2=DUM1*CFJ
              IF(J.EQ.14.AND.NORM) DUM2=DUM2*SQRT5
              IF(J.EQ.20.AND.NORM) DUM2=DUM2*SQRT3
              IF(J.EQ.21) DUM2=DUM1*CGJ
              IF(J.EQ.24.AND.NORM) DUM2=DUM2*SQRT7
              IF(J.EQ.30.AND.NORM) DUM2=DUM2*SQRT5/SQRT3
              IF(J.EQ.33.AND.NORM) DUM2=DUM2*SQRT3
              IJ=IJ+1
              NN=IA(LOCI+I)+(LOCJ+J)
              IF(RMETHOD.EQ.RESC) THEN
                DIJINT(IJ)=DUM2
              ENDIF
              DEN = EPS(NN)
CZCZ THE FOLLOWING MAKES SENSE BECAUSE IJ AND JI ELEMENTS ARE THE SAME. 
CZCZ          DEN=DEN+DEN
              DIJ(IJ) = DUM2*DEN
CZ
              LOCII = LOCI+I
              LOCJJ = LOCJ+J
              DIJ2(IJ)=DUM2*(EPS2(LOCII,LOCJJ)+EPS2(LOCJJ,LOCII))
CZ
  570       CONTINUE
  580     CONTINUE
C
C     ----- OVERLAP
C
      T = SQRT(AA1)
      X0 = AX
      Y0 = AY
      Z0 = AZ
      DO 590 J = 1,LJT
        NJ = J
        DO 590 I = 1,LITDER
          NI = I
          CALL VINT
          XS(I,J)=XINT*T
          YS(I,J)=YINT*T
          ZS(I,J)=ZINT*T
  590 CONTINUE
C
      CALL DERI(DXS,DYS,DZS,XS,YS,ZS,LIT,LJT,AI)
C
      IJ=0
      DO 600 I=MINI,MAXI
        IX=IJX(I)
        IY=IJY(I)
        IZ=IJZ(I)
        DO 600 J=MINJ,MAXJ
          JX=IJX(J)
          JY=IJY(J)
          JZ=IJZ(J)
          DUMX=DXS(IX,JX)* YS(IY,JY)* ZS(IZ,JZ)
          DUMY= XS(IX,JX)*DYS(IY,JY)* ZS(IZ,JZ)
          DUMZ= XS(IX,JX)* YS(IY,JY)*DZS(IZ,JZ)
          IJ=IJ+1
          IF(RMETHOD.EQ.RESC) THEN
            NN=IA(LOCI+I)+(LOCJ+J)
            DUMINT=DIJINT(IJ)
            DSINT(NN,1,IAT)=DSINT(NN,1,IAT)+DUMX*DUMINT
            DSINT(NN,2,IAT)=DSINT(NN,2,IAT)+DUMY*DUMINT
            DSINT(NN,3,IAT)=DSINT(NN,3,IAT)+DUMZ*DUMINT
            DSINT(NN,1,JAT)=DSINT(NN,1,JAT)-DUMX*DUMINT
            DSINT(NN,2,JAT)=DSINT(NN,2,JAT)-DUMY*DUMINT
            DSINT(NN,3,JAT)=DSINT(NN,3,JAT)-DUMZ*DUMINT
          ENDIF
          IF(.NOT.NOCON) THEN
CZ          DE(1,IAT)=DE(1,IAT)+(DUMX*DIJ(IJ))
CZ          DE(2,IAT)=DE(2,IAT)+(DUMY*DIJ(IJ))
CZ          DE(3,IAT)=DE(3,IAT)+(DUMZ*DIJ(IJ))
CZ          DE(1,JAT)=DE(1,JAT)-(DUMX*DIJ(IJ))
CZ          DE(2,JAT)=DE(2,JAT)-(DUMY*DIJ(IJ))
CZ          DE(3,JAT)=DE(3,JAT)-(DUMZ*DIJ(IJ))
CZ          
            IF (KAT.EQ.IAT.OR.KAT.EQ.JAT) THEN
              POPD(1,IAT,KAT)=POPD(1,IAT,KAT)+(DUMX*DIJ(IJ))
              POPD(2,IAT,KAT)=POPD(2,IAT,KAT)+(DUMY*DIJ(IJ))
              POPD(3,IAT,KAT)=POPD(3,IAT,KAT)+(DUMZ*DIJ(IJ))
              POPD(1,JAT,KAT)=POPD(1,JAT,KAT)-(DUMX*DIJ(IJ))
              POPD(2,JAT,KAT)=POPD(2,JAT,KAT)-(DUMY*DIJ(IJ))
              POPD(3,JAT,KAT)=POPD(3,JAT,KAT)-(DUMZ*DIJ(IJ))
            END IF

            TEMP = DIJ2(IJ) 
            POPD(1,IAT,KAT)=POPD(1,IAT,KAT)+DUMX*TEMP
            POPD(2,IAT,KAT)=POPD(2,IAT,KAT)+DUMY*TEMP
            POPD(3,IAT,KAT)=POPD(3,IAT,KAT)+DUMZ*TEMP
            POPD(1,JAT,KAT)=POPD(1,JAT,KAT)-DUMX*TEMP
            POPD(2,JAT,KAT)=POPD(2,JAT,KAT)-DUMY*TEMP
            POPD(3,JAT,KAT)=POPD(3,JAT,KAT)-DUMZ*TEMP
CZ
          ENDIF
  600 CONTINUE
C
  620 CONTINUE
  640 CONTINUE
C
C     ----- END OF PRIMITIVE LOOPS -----
C
      IF(DBG) THEN
         WRITE(IW,9100) II,JJ
         CALL EGOUT(DE,NAT)
      END IF
  760 CONTINUE
  780 CONTINUE
C
C     ----- END OF SHELL LOOPS -----
C
      IF(OUT) THEN
         IF(GOPARR) CALL DDI_GSUMF(1501,DE,3*NAT)
         IF(MASWRK) THEN
            WRITE(IW,9000)
            CALL EGOUT(DE,NAT)
         END IF
         IF(GOPARR) CALL DSCAL(3*NAT,ONE/NPROC,DE,1)
      END IF

      IF(GOPARR .AND. NXT) CALL DDI_DLBRESET
C     IF (GOPARR) CALL DDI_GSUMF(911,POPD(1,1,KAT),3*MAXNAT)
CZ    IF (MASWRK) THEN
CZ      WRITE(6,*) 'POPDMAT FOR ATOM',KAT
CZ      DO II = 1, NAT
CZ        WRITE(6,'(3F12.8)') 
CZ   *    POPD(1,II,KAT),POPD(2,II,KAT),POPD(3,II,KAT)
CZ      END DO
CZ    END IF
CZCZ
C
      IF(RMETHOD.EQ.RESC) THEN
        IF(GOPARR) CALL DDI_GSUMF(1501,DSINT,L2*3*NAT)
        SVDSKW=DSKWRK
        DSKWRK=.TRUE.
        LREC=0
C       STARTING RECORD FOR THE S DERIVATIVE INTEGRALS
        DO I=1,NAT
          DO J=1,3
            LREC=LREC+1
            CALL RAWRIT(NQRDAF,X(MORDA),DSINT(1,J,I),L2,LREC,0)
          ENDDO
        ENDDO
        DSKWRK=SVDSKW
      ENDIF
C
      RETURN
C
 9000 FORMAT(/10X,33(1H-)/10X,'GRADIENT INCLUDING DENSITY FORCES'/
     *        10X,33(1H-))
 9010 FORMAT(1X,'THE LAGRANGIAN IN THE AO BASIS IS')
 9100 FORMAT(1X,'SDER: SHELLS II,JJ=',2I5)
      END
C
C*MODULE FMOESD  *DECK ESPPCDER
      SUBROUTINE ESPPCDER(ILAY,DA,L2,POPDMAT,LAYFRG)

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=2000,MXSH=5000,MXGTOT=20000,MXRT=100,
     *           ZERO=0.0D+00)
      LOGICAL GOPARR,DSKWRK,MASWRK,
     *        ESPPAR,NXT,LARGEPRI
C
CZCZ  DIMENSION DA(*),LAYFRG(*),SCFFRG(*),IDMREC0(*),KARTEN(0:MAXL-1)
      DIMENSION DA(*),LAYFRG(*)
CZCZ  DIMENSION DC(*),WRK1(*),MAPI(*),MAPJ(*),MAP3(MAXL1D,3)
      DIMENSION POPDMAT(3,MAXNAT,MAXNAT,NFG)
C
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2)
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C     COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(3),
     *                ORSHFT,CNVAFO,IXESP,MXITFG,NGUESS,NBSSE,MODORB,
     *                MODPAR,IRSTSTP,IRSTLAY,NPRFMO,NFMOPAL,MODPRP,
     *                MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,MODLMO,NOPDEN,
     *                MOFOCK
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT
C
      COMMON /GRAD  / DE(3,MXATM)
CZ
CZ    THIS SUBROUTINE COMPUTES MULLIKEN CHARGE DERIVATIVES OF ESPPC 
CZ    APPROXIMATED TR(DELTA DIJ*VIJ), WHERE DA IS SUPPOSED TO BE DELTA DIJ.
CZ    THE CORRESPONDING BASIS FUNCTION DERIVATIVES AND HELMANN-FEYNMAN TERMS 
CZ    ARE CALCULATED IN ESVDER AND EXTHELFEY.
CZ    THE CORRESPONDING LAGRANGE TERMS AND DELTA DIJ ARE COMPUTED 
CZ    THROUGH FMOESPA AND STORED IN ESDNSDER.
CZ    NOTE THAT IF RESPPC IS OFF, THIS DOES NOT DO ANYTHING. 
CZ
      RESPPCI = RESPPC(1)
      IF (RESPPCI.EQ.ZERO) RETURN
C     WRITE(6,*) 'NOW IN ESPPCDER'
      
      IFG = ICURFG
      JFG = JCURFG
      LFG = KCURFG
CZ
CZ    THIS ROUTINE IS SUPPOSED TO BE TREATED IN TARGET FRAGMENT, 
CZ    THAT IS, NAT, ICH, MUL...ETC MUST NOT INCLUDE THE VALUES 
CZ    FOR EXTERNAL FRAGMENTS 
CZ
      CALL MONBSR(NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,NSHELL,NGAU,ENUCR,
     *            NAT0,ICH0,MUL0,NUM0,NQMT0,NE0,NA0,NB0,
     *            NCURSH,NGAU0,ENUCR0)
      NE0C = NE0 + ICH0

CZ
CZ    DYNAMIC MEMORY ALLOCATION 
CZ
      CALL VALFM(LOADFM)
      LFESDMAT = LOADFM   + 1
      LAST     = LFESDMAT + MAXNAT*3
      NEED     = LAST- LOADFM -1
      CALL GETFM(NEED)
CZ
C
C     ----- INITIALIZATION FOR PARALLEL WORK -----
C
      ESPPAR=MOD(MODPAR/2,2).NE.0.AND.GOPARR
      LOADHF=MOD(MODPAR,2)
CZ    LARGEPRI=LOADHF.EQ.1.AND.ESPPAR.AND.KFG0.EQ.1.AND.KFG1.EQ.NFG
      LARGEPRI=LOADHF.EQ.1.AND.ESPPAR
C     DODDCOR=IAND(IXESP,1024).NE.0
      NXT = IBTYP.EQ.1
      NEXT  = -1
      KOUNT = -1
CZ
CZ    (A). CALCULATION OF DERIVATIVES INCLUDING EXTERNAL MULLIKEN CHARGES
CZ
      NATF1 = 3*NATFMO
      NATF2 = 2*NATF1
C
C     ESPPC WILL BE COMPUTED IN THE DIRECT FASHION
C
      DO 100 KKFG = 1, NFG
      
        IF(LARGEPRI) THEN
          KFG=IXFTCH(X(LLOADM),KKFG)
        ELSE
          KFG=KKFG
        ENDIF
        IF (IFG.EQ.KFG.OR.JFG.EQ.KFG.OR.LFG.EQ.KFG) GOTO 100

        RK = FMODIST(IFG,JFG,LFG,KFG)
        IF (RK.LE.RESPPCI) GOTO 100

        IF(ESPPAR) THEN
          KOUNT=KOUNT+1
          IF(GOPARR) THEN
            IF(NXT) THEN
              IF(KOUNT.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
              IF(NEXT.NE.KOUNT) GOTO 100
            ELSE
              IF(MOD(KOUNT,NPROC).NE.ME) GOTO 100
            ENDIF
          ENDIF
C         SAVGOP=GOPARR
          GOPARR=.FALSE.
C         GOPARR IS SET TO .FALSE. TO PREVENT SHELL-BASED WORK DIVISION
C         INSIDE OF EXCHNG AND FMOESP. 
C         NOTE THAT SHELL-BASED WORK DIVISION IS USED FOR ESPPAR=.FALSE. 
        ENDIF
        
        KLAY=MIN(ILAY,LAYFRG(KFG))
        KFGX = KFG
        CALL MAKEMOL(KFGX,0,0,KLAY,0,NAT0,NCURSH,NGAU0,NE0C,ICH0,MUL0,
     *               .FALSE.)
C       L1K=NUM-NUM0
C       L2K=(L1K*L1K+L1K)/2
C       L3K=L1K*L1K 
        
        CALL VCLR(DE,1,3*NAT)
        CALL PPCVINT(NAT0,NUM0,POPDMAT(1,1,1,KFG),
     *               X(LFESDMAT),DA,L2,.FALSE.,.TRUE.)
        IF(GOPARR) CALL DDI_GSUMF(2418,DE,NAT*3)
C       IF (MASWRK) THEN
C         WRITE(6,*) 'GRADIENT FOR FRAGMENT', KFG
C         DO II=1, NAT
C           WRITE(6,"(3F12.8)") DE(1,II),DE(2,II),DE(3,II) 
C         END DO
C       END IF

        IF (MASWRK) THEN
          IF (IFMOSTP.EQ.2) THEN
            CALL FMODEG(1,X(LFMODE),X(LFMOPG),X(LIAGLOB))
          ELSEIF (IFMOSTP.EQ.4) THEN
            CALL FMODEG(1,X(LFMODE+NATF1),X(LFMOPG),X(LIAGLOB))
            N11 = 0
            IF (NBODY.GT.2) CALL FMODEG
     *         (N11,X(LFMODE+NATF2),X(LFMOPG),X(LIAGLOB))
            ! MUST CHANGE
          ELSEIF (IFMOSTP.EQ.8) THEN
            CALL FMODEG(1,X(LFMODE+NATF2),X(LFMOPG),X(LIAGLOB))
          ENDIF
        ENDIF
  100 CONTINUE

C 110 CONTINUE
      CALL RETFM(NEED)
       
CZ
CZ    THE FOLLOWING PARAMETERS ARE COPIED BACK TO THOSE OF 
CZ    THE INTERNAL FRAGMENT SYSTEM
CZ
      CALL MONBSR(NAT0,ICH0,MUL0,NUM0,NQMT0,NE0,NA0,NB0,NCURSH,NGAU0,
     *           ENUCR0,NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,NSHELL,NGAU,ENUCR)
      RETURN
      END
C*MODULE FMOESD    *DECK PPCVINT
      SUBROUTINE PPCVINT(NAT0,NUM0,POPDMAT,FESDMAT,EPS,LL2,
     *                   SOME,DOESD)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION MOROKM
C
CZCZ  LOGICAL SOME,DBUG,LZINT,UNCON,DOESP
      LOGICAL SOME,UNCON,DOESD
      LOGICAL IANDJ,DOUBLE,GOPARR,DSKWRK,MASWRK,SCREEN
C
C     COSMO CHANGES
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000, MAXSH=84,
     *           MXAO=8192)
C
CZCZ  DIMENSION H(LL2),S(LL2),T(LL2),Z(LL2),ESP1E(LL2)
      DIMENSION DIJ(784),IJX(784),IJY(784),IJZ(784),
     *          XIN(343),YIN(343),ZIN(343),CONI(MAXSH),CONJ(MAXSH),
     *          IX(84),IY(84),IZ(84),JX(84),JY(84),JZ(84)
CZCZ
      DIMENSION POPDMAT(3,MAXNAT,MAXNAT),FESDMAT(3,MAXNAT),EPS(LL2)
CZCZ
C
C       IF TX,TY,TZ NEEDED, THESE FIRST THREE MUST:
C            A) BE ALLOCATED DYNAMICALLY,
C            B) BE GLOBAL SUMMMED,
C            C) BE SAVED TO THE DIRECT ACCESS FILE AT UNUSED RECORDS
C-XYZ-DIMENSION TX(LL2),TY(LL2),TZ(LL2)
C-XYZ-DIMENSION TXBLK(784),TYBLK(784),TZBLK(784)
C-XYZ-DIMENSION FTX(784),FTY(784),FTZ(784)
C
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /ROOT  / XX,U(13),W(13),NROOTS
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SCINP / VLAMB,SCREEN
      COMMON /STV   / XINT,YINT,ZINT,TAA,X0,Y0,Z0,
     *                XI,YI,ZI,XJ,YJ,ZJ,NI,NJ
      COMMON /WERMIT/ W1,W2(2),W3(3),W4(4),W5(5),W6(6),W7(7),
     *                W8(8),W9(9),W10(10),
     *                W11(11),W12(12),W13(13),W14(14),W15(15)
      COMMON /SHLNRM/ PNRM(84)
      COMMON /SYMIND/ TOL,II,JJ,LIT,LJT,MINI,MINJ,MAXI,MAXJ,IANDJ
      COMMON /RELWFN/ RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,IQRORD,MODQR,NESOC,
     *                NRATOM,NUMU,NQMTR,NQRDAF,MORDA,NDARELB
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      COMMON /FMCOM / X(1)
C
C     COSMO CHANGES
C
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2
      COMMON /IJPAIR/ IA(MXAO)
C
      PARAMETER (ZERO=0.0D+00, PT5=0.5D+00, ONE=1.0D+00, TWO=2.0D+00,
     *           PI212=1.1283791670955D+00, RLN10=2.30258D+00)
C
      DATA JX / 0, 1, 0, 0, 2, 0, 0, 1, 1, 0,
     *          3, 0, 0, 2, 2, 1, 0, 1, 0, 1,
     *          4, 0, 0, 3, 3, 1, 0, 1, 0, 2,
     *          2, 0, 2, 1, 1,
     *          5, 0, 0, 4, 4, 1, 0, 1, 0, 3,
     *          3, 2, 0, 2, 0, 3, 1, 1, 2, 2,
     *          1,
     *          6, 0, 0, 5, 5, 1, 0, 1, 0, 4,
     *          4, 2, 0, 2, 0, 4, 1, 1, 3, 3,
     *          0, 3, 3, 2, 1, 2, 1, 2/
      DATA IX / 1, 8, 1, 1,15, 1, 1, 8, 8, 1,
     *         22, 1, 1,15,15, 8, 1, 8, 1, 8,
     *         29, 1, 1,22,22, 8, 1, 8, 1,15,
     *         15, 1,15, 8, 8,
     *         36, 1, 1,29,29, 8, 1, 8, 1,22,
     *         22,15, 1,15, 1,22, 8, 8,15,15,
     *          8,
     *         43, 1, 1,36,36, 8, 1, 8, 1,29,
     *         29,15, 1,15, 1,29, 8, 8,22,22,
     *          1,22,22,15, 8,15, 8,15/
      DATA JY / 0, 0, 1, 0, 0, 2, 0, 1, 0, 1,
     *          0, 3, 0, 1, 0, 2, 2, 0, 1, 1,
     *          0, 4, 0, 1, 0, 3, 3, 0, 1, 2,
     *          0, 2, 1, 2, 1,
     *          0, 5, 0, 1, 0, 4, 4, 0, 1, 2,
     *          0, 3, 3, 0, 2, 1, 3, 1, 2, 1,
     *          2,
     *          0, 6, 0, 1, 0, 5, 5, 0, 1, 2,
     *          0, 4, 4, 0, 2, 1, 4, 1, 3, 0,
     *          3, 2, 1, 3, 3, 1, 2, 2/
      DATA IY / 1, 1, 8, 1, 1,15, 1, 8, 1, 8,
     *          1,22, 1, 8, 1,15,15, 1, 8, 8,
     *          1,29, 1, 8, 1,22,22, 1, 8,15,
     *          1,15, 8,15, 8,
     *          1,36, 1, 8, 1,29,29, 1, 8,15,
     *          1,22,22, 1,15, 8,22, 8,15, 8,
     *         15,
     *          1,43, 1, 8, 1,36,36, 1, 8,15,
     *          1,29,29, 1,15, 8,29, 8,22, 1,
     *         22,15, 8,22,22, 8,15,15/
      DATA JZ / 0, 0, 0, 1, 0, 0, 2, 0, 1, 1,
     *          0, 0, 3, 0, 1, 0, 1, 2, 2, 1,
     *          0, 0, 4, 0, 1, 0, 1, 3, 3, 0,
     *          2, 2, 1, 1, 2,
     *          0, 0, 5, 0, 1, 0, 1, 4, 4, 0,
     *          2, 0, 2, 3, 3, 1, 1, 3, 1, 2,
     *          2,
     *          0, 0, 6, 0, 1, 0, 1, 5, 5, 0,
     *          2, 0, 2, 4, 4, 1, 1, 4, 0, 3,
     *          3, 1, 2, 1, 2, 3, 3, 2/
      DATA IZ / 1, 1, 1, 8, 1, 1,15, 1, 8, 8,
     *          1, 1,22, 1, 8, 1, 8,15,15, 8,
     *          1, 1,29, 1, 8, 1, 8,22,22, 1,
     *         15,15, 8, 8,15,
     *          1, 1,36, 1, 8, 1, 8,29,29, 1,
     *         15, 1,15,22,22, 8, 8,22, 8,15,
     *         15,
     *          1, 1,43, 1, 8, 1, 8,36,36, 1,
     *         15, 1,15,29,29, 8, 8,29, 1,22,
     *         22, 8,15, 8,15,22,22,15/
C
      DATA MOROKM/8HMOROKUMA/
      DATA NONE,RNONE/4HNONE,8HNONE    /
C
C     ----- COMPUTE CONVENTIONAL H, S, AND T INTEGRALS -----
C
CZ
CZ    I HAVE MODIFIED THIS ROUTINE SO THAT ONLY V IS COMPUTED. 
CZ    ALSO THE PRODUCT IS ENERGY GRADIENT DE. 
CZ
      UNCON=RMETHOD.NE.RNONE.AND.MOD(MODQR,2).EQ.1
      TOL = RLN10*ITOL
C     NORM = NORMF .NE. 1 .OR. NORMP .NE. 1
      IF(SOME  .AND.  SCREEN) WRITE(IW,9010) VLAMB
CZCZ  IF(DOESP.AND.LZINT) THEN
C        ZBLK IS REUSED FOR SOME OTHER PURPOSE.
CZCZ     WRITE(IW,*) 'STORAGE NOT ALLOCATED IN HSANDT'
CZCZ     CALL ABRT
CZCZ  END IF
C
C     ----- MOPAC INTEGRALS ARE DONE ELSEWHERE -----
C
      IF(MPCTYP.NE.NONE) THEN
         CALL MPCINT
         RETURN
      END IF
C     COSMO CHANGES VOLKER FOR DIRECT SCF, MRZ 99
C
C     FOR DIRECT SCF, WE NEED THE DIFFERENCE OF H BETWEEN THE SCF
C     ITERATIONS IN RHFCL, SO HOLD IS COPIED INTO SECTION 87
C     AND HNEW IS IN SECTION 11 AS USUAL, BEGINNING IN SCF-CYCLE 2
C
CZCZ      IF(ISEPS  .AND.  ITER.GT.0) THEN
CZCZ         CALL DAREAD(IDAF,IODA,H,LL2,11,0)
CZCZ         CALL DAWRIT(IDAF,IODA,H,LL2,87,0)
CZCZ      END IF
C
C     ----- RESET SOME PARAMETERS FOR MOROKUMA DECOMPOSITIONS -----
C     ISAVE .EQ. 0 : SAVE S, H, AND T TO DAF 12, 11, AND 13
C     ISAVE .EQ. 1 : SAVE S, H, AND T TO DAF 12, 11, AND 13
C                    AND SAVE S AND H TO DAF 312 AND 311
C     NOTE THAT LL2 IS ALWAYS (NUM*NUM+NUM)/2,
C     L1,L2 MAY BE SMALLER THAN USUAL FOR A MONOMER IN A MOROKUMA RUN
C
      IF (RUNTYP.EQ.MOROKM) THEN
         CALL STINT1(ISTART,IEND,JSTART,LOCIJ,NATST,NATED,ISAVE,L1,L2)
      ELSE
         ISTART = 1
CZCZ     IEND   = NSHELL
         IEND   = NCURSH
         JSTART = 1
         LOCIJ  = 0
CZCZ     NATST  = 1
CZCZ     NATED  = NAT+NCHMAT
         NATST  = NAT0+1
         NATED  = NAT
CZCZ     IF(ISEPS) NATED = NAT+NPS
CZCZ     IF(DOESP) NATED=NAT1E
         ISAVE  = 0
CZCZ     L1 = NUM
         L1 = NUM - NUM0
         IF(UNCON) L1=NUMU
         L2 = (L1*(L1+1))/2
      END IF
C
CZCZ  IF(GOPARR) THEN
CZCZ         CALL VCLR(H ,1,LL2)
CZCZ         CALL VCLR(S ,1,LL2)
CZCZ         CALL VCLR(T ,1,LL2)
C-XYZ-   CALL VCLR(TX,1,LL2)
C-XYZ-   CALL VCLR(TY,1,LL2)
C-XYZ-   CALL VCLR(TZ,1,LL2)
CZCZ         IF(LZINT) CALL VCLR(Z,1,LL2)
CZCZ         IF(DOESP) CALL VCLR(ESP1E,1,LL2)
CZCZ  END IF
C
C     ----- INTIALIZE PARALLEL -----
C
      IPCOUNT = ME - 1
C
C     ----- I SHELL -----
C
      DO 720 II = ISTART,IEND
         I = KATOM(II)
         XI = C(1,I)
         YI = C(2,I)
         ZI = C(3,I)
         I1 = KSTART(II)
         I2 = I1+KNG(II)-1
         LIT = KTYPE(II)
         MINI = KMIN(II)
         MAXI = KMAX(II)
         LOCI = KLOC(II)-MINI-LOCIJ
C
C     ----- J SHELL -----
C
         DO 700 JJ = JSTART,II
C
C     ----- GO PARALLEL! (STATIC LOAD BALANCING) -----
C
            IF (GOPARR) THEN
               IPCOUNT = IPCOUNT + 1
               IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 700
            END IF
C
            J = KATOM(JJ)
            XJ = C(1,J)
            YJ = C(2,J)
            ZJ = C(3,J)
            J1 = KSTART(JJ)
            J2 = J1+KNG(JJ)-1
            LJT = KTYPE(JJ)
            MINJ = KMIN(JJ)
            MAXJ = KMAX(JJ)
            LOCJ = KLOC(JJ)-MINJ-LOCIJ
            NROOTS = (LIT+LJT-2)/2+1
            RR = (XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
            IANDJ = II .EQ. JJ
C
C     ----- PREPARE INDICES FOR PAIRS OF (I,J) FUNCTIONS
C
            IJ = 0
            MAX = MAXJ
            DO 160 I = MINI,MAXI
               NX = IX(I)
               NY = IY(I)
               NZ = IZ(I)
               IF (IANDJ) MAX = I
               DO 140 J = MINJ,MAX
                  IJ = IJ+1
                  IJX(IJ) = NX+JX(J)
                  IJY(IJ) = NY+JY(J)
                  IJZ(IJ) = NZ+JZ(J)
C                 FT (IJ) = 2*(JX(J)+JY(J)+JZ(J)) + 3
C-XYZ-            FTX(IJ) = 2* JX(J)              + 1
C-XYZ-            FTY(IJ) = 2*       JY(J)        + 1
C-XYZ-            FTZ(IJ) = 2*             JZ(J)  + 1
  140          CONTINUE
  160       CONTINUE
C
CZCZ        CALL VCLR( SBLK,1,IJ)
CZCZ        CALL VCLR( TBLK,1,IJ)
C           CALL VCLR( VBLK,1,IJ)
C-XYZ-      CALL VCLR(TXBLK,1,IJ)
C-XYZ-      CALL VCLR(TYBLK,1,IJ)
C-XYZ-      CALL VCLR(TZBLK,1,IJ)
CZCZ        IF(LZINT.OR.DOESP) CALL VCLR(ZBLK,1,IJ)
C
C     ----- I PRIMITIVE
C
            JGMAX = J2
            DO 520 IG = I1,I2
               AI = EX(IG)
               ARRI = AI*RR
               AXI = AI*XI
               AYI = AI*YI
               AZI = AI*ZI
               CALL SETCONI(CONI,IG)
C
C     ----- J PRIMITIVE
C
               IF (IANDJ) JGMAX = IG
               DO 500 JG = J1,JGMAX
                  AJ = EX(JG)
                  AA = AI+AJ
                  AA1 = ONE/AA
                  DUM = AJ*ARRI*AA1
                  IF (DUM .GT. TOL) GO TO 500
                  FAC = EXP(-DUM)
                  CALL SETCONI(CONJ,JG)
                  AX = (AXI+AJ*XJ)*AA1
                  AY = (AYI+AJ*YJ)*AA1
                  AZ = (AZI+AJ*ZJ)*AA1
C
C     ----- DENSITY FACTOR
C
C     THE ONLY REASON WHY -ILZ WORKS WITH THIS DENSITY THAT ASSUMES
C     HERMITICITY IS BECAUSE <I|-ILZ|I>=0 (MOMENTUM QUENCHING).
C
                  DOUBLE=IANDJ.AND.IG.NE.JG
                  MAX = MAXJ
                  NN = 0
                  DTWO=ONE
                  IF(DOUBLE) DTWO=TWO
C                 NOTE THAT PNRM FACTORS FOR S AND P SHELLS ARE 1.
                  SPDIJ=CS(IG)*CP(JG)*FAC
                  DO 220 I = MINI,MAXI
                     IF (IANDJ) MAX = I
                     FACI=FAC*CONI(I)*PNRM(I)*DTWO
                     NN1=NN+1
                     DO 200 J = MINJ,MAX
                        NN = NN+1
                        DIJ(NN)=FACI*CONJ(J)*PNRM(J)
C                    WRITE(6,*) 'WWWDIJ',NN,I,J,II,JJ,DIJ(NN)
  200                CONTINUE
C            CORRECT FOR L-SHELL DOUBLE COUNTING OF THE SP
C            OFF-DIAGONAL TERMS (FOR NON-L SHELLS CSI*CPJ IS ZERO).
C            NN1 POINTS TO THE APPROPRIATE DENSITY ELEMENT
                     IF(MINJ.LE.1.AND.I.GT.1.AND.DOUBLE)
     *                 DIJ(NN1)=DIJ(NN1)*PT5+SPDIJ
  220             CONTINUE
CZCZ
CZCZ         FOR ESD APPROX., FMO DENSITIES ARE MULTIPLIED 
CZCZ
                  MAX = MAXJ
                  NN = 0
                  DO I = MINI, MAXI
                    IF (IANDJ) MAX = I
                    DO J = MINJ, MAX
                      NN = NN + 1
                      KKK = IA(LOCI+I)+LOCJ+J
                      DEN = EPS(KKK)
                      !!! BE CAREFUL !!!
CZCZ                  IF(LOCI+I.NE.LOCJ+J) DEN = DEN + DEN
                      IF(.NOT.IANDJ.OR.I.NE.J) DEN = DEN + DEN
                      DIJ(NN) = DIJ(NN)*DEN
                    END DO
                  END DO
CZCZ
CZCZ
CZCZ
C
C     ----- OVERLAP AND KINETIC ENERGY
C
CZ                  TAA = SQRT(AA1)
CZ                  T1 = -TWO*AJ*AJ*TAA
CZ                  T2 = -PT5*TAA
CZ                  X0 = AX
CZ                  Y0 = AY
CZ                  Z0 = AZ
CZ                  IN = -7
CZ                  DO 320 I = 1,LIT
CZ                     IN = IN+7
CZ                     NI = I
CZ                     DO 300 J = 1,LJT
CZ                        JN = IN+J
CZ                        NJ = J
CZ                        CALL STVINT
CZ                        XIN(JN) = XINT*TAA
CZ                        YIN(JN) = YINT*TAA
CZ                        ZIN(JN) = ZINT*TAA
CZ                        NJ = J+2
CZ                        CALL STVINT
CZ                        XIN(JN+49) = XINT*T1
CZ                        YIN(JN+49) = YINT*T1
CZ                        ZIN(JN+49) = ZINT*T1
CZ                        NJ = J-2
CZ                        IF (NJ .GT. 0) THEN
CZ                           CALL STVINT
CZ                        ELSE
CZ                           XINT = ZERO
CZ                           YINT = ZERO
CZ                           ZINT = ZERO
CZ                        END IF
CZ                        N = (J-1)*(J-2)
CZ                        DUM = N * T2
CZ                        XIN(JN+98) = XINT*DUM
CZ                        YIN(JN+98) = YINT*DUM
CZ                        ZIN(JN+98) = ZINT*DUM
CZ                        IF(LZINT) THEN
CZ                           NJ = J+1
CZ                           CALL STVINT
CZ                           XIN(JN+147) = XINT*TAA
CZ                           YIN(JN+147) = YINT*TAA
C---                       ZIN(JN+147) = ZINT*TAA
CZ                           NJ = J-1
CZ                           IF (NJ .GT. 0) THEN
CZ                              CALL STVINT
CZ                           ELSE
CZ                              XINT = ZERO
CZ                              YINT = ZERO
C---                          ZINT = ZERO
CZ                           END IF
CZ                           XIN(JN+196) = XINT*TAA*NJ
CZ                           YIN(JN+196) = YINT*TAA*NJ
C---                       ZIN(JN+196) = ZINT*TAA*NJ
CZ                        END IF
CZ  300                CONTINUE
CZ  320             CONTINUE
CZ                  DO 340 I = 1,IJ
CZ                     NX = IJX(I)
CZ                     NY = IJY(I)
CZ                     NZ = IJZ(I)
CZ                     DUM   =             XIN(NX)    *YIN(NY)*ZIN(NZ)
CZ                     DUM1X = (XIN(NX+49)+XIN(NX+98))*YIN(NY)*ZIN(NZ)
CZ                     DUM1Y = (YIN(NY+49)+YIN(NY+98))*XIN(NX)*ZIN(NZ)
CZ                     DUM1Z = (ZIN(NZ+49)+ZIN(NZ+98))*XIN(NX)*YIN(NY)
CZ                     DUM1  = DUM1X + DUM1Y + DUM1Z
CZ                      SBLK(I) =  SBLK(I) + DIJ(I)* DUM
CZ                      TBLK(I) =  TBLK(I) + DIJ(I)*(DUM*AJ*FT (I)+DUM1 )
C-XYZ-               TXBLK(I) = TXBLK(I) + DIJ(I)*(DUM*AJ*FTX(I)+DUM1X)
C-XYZ-               TYBLK(I) = TYBLK(I) + DIJ(I)*(DUM*AJ*FTY(I)+DUM1Y)
C-XYZ-               TZBLK(I) = TZBLK(I) + DIJ(I)*(DUM*AJ*FTZ(I)+DUM1Z)
CZ                     IF(LZINT) THEN
CZ                        DUM2 = XIN(NX+147)*YIN(NY+196)
CZ     *                       - XIN(NX+196)*YIN(NY+147)
CZ                        ZBLK(I) = ZBLK(I) + DIJ(I)*DUM2*ZIN(NZ)
CZ                     END IF
CZ  340             CONTINUE
C
C     ----- NUCLEAR ATTRACTION
C     EL SIGUIENTE DO SOLO EN CASO NO SCREEN.
C
                  IF (.NOT.SCREEN) THEN
                     DUM = PI212*AA1
                     DO 400 I = 1,IJ
                        DIJ(I) = DIJ(I)*DUM
  400                CONTINUE
                  END IF
C
                  AAX = AA*AX
                  AAY = AA*AY
                  AAZ = AA*AZ
C
C     -NCHMAT- IS NONZERO IF THERE ARE EXTERNAL CHARGES WHICH
C     PERTURB THE SYSTEM, SUCH AS IF CHARMM IS IN USE.  NOTE
C     THAT THERE IS ALSO A NUCLEAR REPULSION TERM WHICH IS NOT
C     INCLUDED HERE, IT IS IN THE CHARMM INTERFACE CODE.
C
                  DO 460 IC = NATST,NATED
CZCZ                 IF(IC.LE.NAT) THEN
CZCZ                    ZNUC = -ZAN(IC)
CZCZ                    CX = C(1,IC)
CZCZ                    CY = C(2,IC)
CZCZ                    CZ = C(3,IC)
CZCZ                 ELSE
C
C     COSMO OR CHARMM POINT CHARGES
C
CZCZ                    IF(ISEPS) THEN
CZCZ                       ZNUC = -COSZAN(IC-NAT)
CZCZ                       CX = CORZAN(1,IC-NAT)
CZCZ                       CY = CORZAN(2,IC-NAT)
CZCZ                       CZ = CORZAN(3,IC-NAT)
CZCZ                     ELSE
CZCZ                       ZNUC = -QCHM(IC-NAT)
CZCZ                       CX = XCHM(IC-NAT)
CZCZ                       CY = YCHM(IC-NAT)
CZCZ                       CZ = ZCHM(IC-NAT)
CZCZ                    END IF
CZCZ                 END IF
                     IF(DOESD) THEN
                      CALL VCLR(FESDMAT,1,3*MAXNAT)
                      CALL FMOATFRG3(IC,X(LINDAT),X(LINDATG),X(LIAGLOB),
     *                               X(LIALOC),X(LIABDFG),X(LJABDFG),
     *                               X(LINDBD),X(LFMOZAN),X(LFMOC),
     *                               NATFMO+NBDFG,X(LUNTXYZ),X(LPOPMAT),
     *                               POPDMAT, FESDMAT,.TRUE.,NAT0,
     *                               KATOM(II),KATOM(JJ),FRACV,FRACESP,
     *                               KFG,ZNUC,CX,CY,CZ)
C                      WRITE(6,*) 'WWWATOM',IC,FRACV,FRACESP
CZCZ                   IF(FRACV.EQ.ZERO.AND.FRACESP.EQ.ZERO) GOTO 460
                     END IF
C
C         CHECKING IF IT IS AN SCREENED CALCULATION, IF SO CALL SCR1,
C         OTHERWISE, FOLLOW THE GAMESS CODE.
C
                  IF (SCREEN) THEN
C                     NN=0
C                     DO 425 I=MINI,MAXI
C                        L1A=JX(I)
C                        M1A=JY(I)
C                        N1A=JZ(I)
C                        MAX=MAXJ
C                        IF(IANDJ) MAX=I
C                        DO 415 J=MINJ,MAX
C                           NN=NN+1
C                           L2B=JX(J)
C                           M2B=JY(J)
C                           N2B=JZ(J)
C                           VAL=FDNAI(VLAMB,AI,AJ,
C    *                                L1A,M1A,N1A,L2B,M2B,N2B,
C    *                                XI,YI,ZI,XJ,YJ,ZJ,CX,CY,CZ)
C                           VBLK(NN) = VBLK(NN) + DIJ(NN)*VAL*ZNUC
C
C 415                    CONTINUE
C 425                 CONTINUE
                  ELSE
                     XX = AA*((AX-CX)**2+(AY-CY)**2+(AZ-CZ)**2)
                     IF (NROOTS.LE.3) CALL RT123
                     IF (NROOTS.EQ.4) CALL ROOT4
                     IF (NROOTS.EQ.5) CALL ROOT5
                     IF (NROOTS.GE.6) CALL ROOT6
                     MM = 0
                     DO 430 K = 1,NROOTS
                        UU = AA*U(K)
                        WW = W(K)*ZNUC
                        TT = ONE/(AA+UU)
                        TAA = SQRT(TT)
                        X0 = (AAX+UU*CX)*TT
                        Y0 = (AAY+UU*CY)*TT
                        Z0 = (AAZ+UU*CZ)*TT
                        IN = -7+MM
                        J0 = 2
C
C                       J0 SKIPS THE TRIVIAL COMBINATION NI=NJ=1
C                       THAT IS DONE EXPLICITLY NOW
C
                        XIN(IN+8) = W1
                        YIN(IN+8) = W1
                        ZIN(IN+8) = W1*WW
                        DO 420 I = 1,LIT
                           IN = IN+7
                           NI = I
                           DO 410 J = J0,LJT
                              JN = IN+J
                              NJ = J
                              CALL STVINT
                              XIN(JN) = XINT
                              YIN(JN) = YINT
                              ZIN(JN) = ZINT*WW
  410                      CONTINUE
                           J0 = 1
  420                   CONTINUE
                        MM = MM+49
  430                CONTINUE
                     DO 450 I = 1,IJ
                        NX = IJX(I)
                        NY = IJY(I)
                        NZ = IJZ(I)
                        DUM = ZERO
                        MM = 0
                        DO 440 K = 1,NROOTS
                           DUM = DUM+XIN(NX+MM)*YIN(NY+MM)*ZIN(NZ+MM)
                           MM = MM+49
  440                   CONTINUE
                        IF(DOESD) THEN
                           DUMIJ=DUM*DIJ(I)
CZCZ                       VBLK(I) = VBLK(I) + FRACV*  DUMIJ
CZCZ                       ZBLK(I) = ZBLK(I) + FRACESP*DUMIJ
                          DO I5 = NAT0+1, NAT
                            I6 = I5 - NAT0
                            DE(1,I5) = DE(1,I5)+FESDMAT(1,I6)*DUMIJ 
                            DE(2,I5) = DE(2,I5)+FESDMAT(2,I6)*DUMIJ 
                            DE(3,I5) = DE(3,I5)+FESDMAT(3,I6)*DUMIJ 
                          END DO 
                        ELSE
CZCZ                       VBLK(I) = VBLK(I) + DUM*DIJ(I)
                        END IF
  450                CONTINUE
                   END IF
C
  460             CONTINUE
C
C     ----- END OF PRIMITIVE LOOPS -----
C
  500          CONTINUE
  520       CONTINUE
C
C     ----- COPY BLOCK INTO H-CORE, OVERLAP, AND KINETIC ENERGY MATRICES
C
CZ          MAX = MAXJ
CZ          NN = 0
CZ          DO 620 I = MINI,MAXI
CZ             LI = LOCI+I
CZ             IN = (LI*(LI-1))/2
CZ             IF (IANDJ) MAX = I
CZ             DO 600 J = MINJ,MAX
CZ                LJ = LOCJ+J
CZ                JN = LJ+IN
CZ                NN = NN+1
CZCZ              H(JN) =  TBLK(NN) + VBLK(NN)
CZCZ              S(JN) =  SBLK(NN)
CZCZ              T(JN) =  TBLK(NN)
C-XYZ-            TX(JN) = TXBLK(NN)
C-XYZ-            TY(JN) = TYBLK(NN)
C-XYZ-            TZ(JN) = TZBLK(NN)
CZCZ              IF(LZINT) Z(JN) = ZBLK(NN)
CZCZ              IF(DOESP) ESP1E(JN)=ZBLK(NN)
CZ600          CONTINUE
CZ620       CONTINUE
C
C     ----- END OF SHELL LOOPS -----
C
  700    CONTINUE
  720 CONTINUE
C
C     ----- SUM UP PARTIAL CONTRIBUTIONS IF PARALLEL -----
C
CZCZ  IF (GOPARR) THEN
CZCZ     CALL DDI_GSUMF(910,H,L2)
CZCZ     CALL DDI_GSUMF(911,S,L2)
CZCZ     CALL DDI_GSUMF(912,T,L2)
CZCZ     IF(LZINT) CALL DDI_GSUMF(913,Z,L2)
C        ONE DDI_GSUMF BELOW CAN BE SPARED
CZCZ     IF(DOESP) CALL DDI_GSUMF(913,ESP1E,L2)
CZCZ  END IF
C
C     ----- SAVE H, S, AND T MATRICES ON THE DAF -----
C
CZCZ  CALL DAWRIT(IDAF,IODA,H,LL2,11,0)
CZCZ  CALL DAWRIT(IDAF,IODA,S,LL2,12,0)
CZCZ  CALL DAWRIT(IDAF,IODA,T,LL2,13,0)
CZCZ  IF(LZINT) CALL DAWRIT(IDAF,IODA,Z,LL2,379,0)
CZCZ  IF (ISAVE.EQ.1) THEN
CZCZ     CALL DAWRIT(IDAF,IODA,H,LL2,311,0)
CZCZ     CALL DAWRIT(IDAF,IODA,S,LL2,312,0)
CZCZ  END IF
C
C     ----- OPTIONAL DEBUG PRINTOUT -----
C
CZCZ  IF(DBUG) THEN
CZCZ     WRITE(IW,*) 'OVERLAP MATRIX'
CZCZ     CALL PRTRIL(S,L1)
CZCZ     WRITE(IW,*) 'BARE NUCLEUS HAMILTONIAN INTEGRALS (H=T+V)'
CZCZ     CALL PRTRIL(H,L1)
CZCZ     WRITE(IW,*) 'KINETIC ENERGY INTEGRALS'
CZCZ     CALL PRTRIL(T,L1)
CZCZ     IF(LZINT.OR.DOESP) THEN
CZCZ        WRITE(IW,*) 'Z-ANGULAR MOMENTUM INTEGRALS'
CZCZ        CALL PRTRIL(Z,L1)
CZCZ     END IF
CZCZ  END IF
      RETURN
C
 9010 FORMAT(1X,'SCREENING VALUE=',F20.5,' IS BEING USED')
      END
C
C*MODULE FMOESD  *DECK FMOATFRG3
      SUBROUTINE FMOATFRG3(IAT0,INDAT,INDATG,IAGLOB,IALOC,IABDFG,JABDFG,
     *                    INDBD,FMOZAN,FMOC,NATFMOB,UNTXYZ,POPMAT,
     *                    POPDMAT,FESDMAT,DOESDPPC,NAT0,
     *                    IATS,JATS,FRACV,FRACESP,IATFRG,ZNUC,CX,CY,CZ)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL IAINSIDE,JAINSIDE,SMARTR(2),BIMER(3)
      DIMENSION INDAT(*),INDATG(NATFMO,*),IAGLOB(*),IALOC(*),IABDFG(*),
     *          JABDFG(*),INDBD(MAXABD,*),FMOZAN(*),FMOC(3,*),
     *          UNTXYZ(3,NATFMOB,*),POPMAT(MAXNAT,NFG,2)
CZCZ
      DIMENSION POPDMAT(3,MAXNAT,MAXNAT), FESDMAT(3,MAXNAT)
      LOGICAL DOESDPPC
CZCZ
      PARAMETER (MXATM=2000, ZERO=0.0D+00,ONE=1.0D+00,HALF=0.5D+00)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOLAT/ UNTANG(3),UNTORG(3),RESPBC(4),ABCLAT(3),ANGLAT(3),
     *                SYMTRA(3,24),SYMOPE(3,3,24),IATORG,NSYMOP,MAXKLMS,
     *                IOPORG(3),IOPDIR(3),IOPABC(3),IOPANG(3)
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(3),
     *                ORSHFT,CNVAFO,IXESP,MXITFG,NGUESS,NBSSE,MODORB,
     *                MODPAR,IRSTSTP,IRSTLAY,NPRFMO,NFMOPAL,MODPRP,
     *                MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,MODLMO,NOPDEN,
     *                MOFOCK
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT
      DATA BIMER/3*.FALSE./
C
      IF(IAT0.GT.NATFMO.AND.IFMOSTP.LE.2) THEN
        IAT=MOD(IAT0-1,NATFMO)+1
        IU=(IAT0-1)/NATFMO+1
        IATFRG=INDAT(IAT)
        ZNUC=-FMOZAN(IAT)
        CX=UNTXYZ(1,IAT,IU)
        CY=UNTXYZ(2,IAT,IU)
        CZ=UNTXYZ(3,IAT,IU)
        FRACV=ZERO
        FRACESP=ONE
C       WRITE(6,*) 'W',IAT,IU-1,ZNUC,CX,CY,CZ
        RETURN
      ENDIF
      IF(MAXKLMS.NE.0.AND.IFMOSTP.GT.2) THEN
C       IU=1
        ZNUC=-ZAN(IAT0)
        CX=C(1,IAT0)
        CY=C(2,IAT0)
        CZ=C(3,IAT0)
C       ONLY THE EXTERNAL POTENTIAL WILL BE COMPUTED.
        FRACV=ZERO
        FRACESP=ONE
        IF(IAT0.LE.NAT) FRACESP=ZERO 
        RETURN
      ENDIF
C     IU=0
C
C     DETERMINE IF ATOM IAT BELONGS TO FRAGMENT 
C
      IF(IFMOSTP.EQ.2.AND.IAND(IXESP,4096).NE.0) THEN
        IATFRG=INDAT(IAT0)
        RK=FMODIST(ICURFG,0,0,IATFRG)
        IF(ICURFG.NE.IATFRG) THEN
          FRACV=0
          FRACESP=0
          IGOT=0
          IF(RK.EQ.0) FRACESP=ONE
          ZNUC=-FMOZAN(IAT0)
          CX=FMOC(1,IAT0)
          CY=FMOC(2,IAT0)
          CZ=FMOC(3,IAT0)
          IF(NBDFG.EQ.0) GOTO 90
          DO IABD=1,MAXABD
            IBDFG=INDBD(IABD,IAT0)
            IF(IBDFG.EQ.0) GOTO 90
            IA=ABS(IABDFG(IBDFG))
            JA=ABS(JABDFG(IBDFG))
            IAFRG=INDAT(IA)
            JAFRG=INDAT(JA)
            IF(IAFRG.EQ.ICURFG.OR.JAFRG.EQ.ICURFG) THEN
C             THIS IS HANDLED BELOW
              IGOT=1
              GOTO 90
            ENDIF
C           RI=FMODIST(ICURFG,0,0,IAFRG)
            RJ=FMODIST(ICURFG,0,0,JAFRG)
C           THE CODE BELOW MAY NOT WORK FOR MULTIPLY CUT BDAS?
            IF(RJ.EQ.0) THEN
              IF(RK.NE.0) FRACESP=FRACESP-ONE/ZNUC
            ELSE
              IF(RK.EQ.0) FRACESP=FRACESP+ONE/ZNUC
            ENDIF
          ENDDO
   90     CONTINUE
          IF(IGOT.EQ.0) RETURN
        ENDIF 
      ENDIF 
CZCZ  IF(IFMOSTP.NE.6) THEN
CZCZ    IAT=IAT0
CZCZ    IF (IMCPFMO.EQ.1) THEN
CZCZ      ZNUC=-(FMOZAN(IAT)-XX(LFZCOR+IAT-1))
CZCZ    ELSE
CZCZ      ZNUC=-FMOZAN(IAT)
CZCZ    END IF
CZCZ    CX=FMOC(1,IAT)
CZCZ    CY=FMOC(2,IAT)
CZCZ    CZ=FMOC(3,IAT)
CZCZ    IZ=1
CZCZ    IFG=ICURFG
CZCZ    FACTK=ONE
CZCZ  ELSE
CZCZ    IAT=IAT0+NAT
        IAT=IAT0
        ZNUC=-ZAN(IAT)
        CX=C(1,IAT)
        CY=C(2,IAT)
        CZ=C(3,IAT)
C       IAT BELOW MUST BE GLOBAL IAT
        IAT=IAGLOB(IAT)
CZCZ    IZ=2
        IZ = 1
CZCZ    IFG=NCURSH
        IFG=ICURFG 
        FACTK=HALF
        CALL VCLR(FESDMAT,1,MAXNAT*3)
CZCZ  ENDIF
      JFG=JCURFG
      LFG=KCURFG
      IATFRG=INDAT(IAT)
      SMARTR(1)=IAND(MODESP,7).EQ.1.AND.JFG.NE.0
      SMARTR(2)=IAND(MODESP,7).EQ.2.AND.JFG.NE.0
      IF(SMARTR(1).AND.NBDFG.NE.0) THEN
        BIMER(1)=FMODIST(IFG,0,0,JFG).EQ.0
        IF(LFG.EQ.0) THEN
          IF(BIMER(1)) SMARTR(1)=.FALSE.
        ELSE
          BIMER(2)=FMODIST(IFG,0,0,LFG).EQ.0
          BIMER(3)=FMODIST(JFG,0,0,LFG).EQ.0
        IF(BIMER(1).AND.(BIMER(2).OR.BIMER(3)).OR.BIMER(2).AND.BIMER(3))
     *    SMARTR(1)=.FALSE.
        ENDIF 
      ENDIF 
      IATSG=IAGLOB(IATS)
      JATSG=IAGLOB(JATS)
      IIFG=INDAT(IATSG)
      JJFG=INDAT(JATSG)
C     3 -BODY TERMS DO NOT WORK WITH BSSE.
CZ
CZ    WHY IFMOSTP=6 DOES NOT NEED TO CONSIDER GHOST ATOMS?
CZ    ALSO FOR ESDPPC, ONE MIGHT USE THE SAME TECHNIQUE AS FOR IFMOSTP=6
CZ    IN DETAILS, WHEN NATFMO IS USED FOR EXTERNAL LOOP, THIS DOES NOT 
CZ    CONSIDER GHOST ATOMS. HOWEVER, WHEN AN EXTERNAL FRAGMENT IS ADDED 
CZ    WITH NAT, THIS CONSIDER GHOST ATOMS. 
CZ
CZCZ  IF(NBDFG.EQ.0.OR.IFMOSTP.EQ.6) THEN
      IF(NBDFG.EQ.0.OR.DOESDPPC) THEN
        FRACV=ZERO
        FRACESP=ONE
C       BSSE
        IF(IFMOSTP.EQ.5) THEN
          IF(NBSSE.EQ.1.AND.IATFRG.EQ.JFG .OR. NBSSE.EQ.2.AND.
     *      IATFRG.NE.IFG.AND.(IIFG.EQ.JFG.OR.JJFG.EQ.JFG)) FRACESP=ZERO
        ENDIF
C       DECIDE IF THE POINT CHARGE IAT SHOULD BE INCLUDED INTO ESP (KEEP=1)
        IF(IFMOSTP.NE.6) THEN
         IF(FRACESP.EQ.ONE.AND.(NBSSE.NE.2.OR.IFMOSTP.NE.5.OR.IATFRG.NE.
     *  JFG).AND.(IATFRG.EQ.IFG.OR.IATFRG.EQ.JFG.OR.IATFRG.EQ.LFG)) THEN
          FRACV=ONE
          FRACESP=ZERO
         ENDIF 
        ENDIF
      ELSE
C       THIS CODE DOES NOT SUPPORT NBSSE=1,2 AND 3.
        IF(NBSSE.NE.0) THEN
          WRITE(6,*) 'BAD NBSSE',NBSSE
          CALL ABRT
        ENDIF
C       SET VALUES FOR THE CASE ATOM IAT IS NOT SHARED
        IF(IATFRG.EQ.IFG.OR.IATFRG.EQ.JFG.OR.IATFRG.EQ.LFG) THEN
          FRACV=ONE
          FRACESP=ZERO
        ELSE
          FRACV=ZERO
          FRACESP=ONE
        ENDIF
        FRACESP1=ZERO
C       DO IBDFG=1,NBDFG
C       LOOP OVER ALL BROKEN BONDS IN WHICH ATOM IAT IS INVOLVED.
C       WE ARE ONLY INTERESTED REALLY IN ONE N-MER HERE (N=1,2), SO
C       WE FIND IF AN ATOM IS SPLIT BETWEEN THIS N-MER AND THE REST, THEN QUIT. 
        DO IABD=1,MAXABD
          IBDFG=INDBD(IABD,IAT)
          IF(IBDFG.EQ.0) GOTO 100
          IA=ABS(IABDFG(IBDFG))
          JA=ABS(JABDFG(IBDFG))
C         REORDERING IS NOW DONE IN FMOBON
C         THE CODE BELOW ASSUMES THE CANONICAL ORDER (LEFT IS NEGATIVE). 
C         IF(JA.LT.0) THEN
C           IF(IA.LT.0) CALL ABRT
C           IDUM=IA
C           IA=JA
C           JA=IDUM
C         ENDIF
C         IA=ABS(IA)
          IAFRG=INDAT(IA)
          JAFRG=INDAT(JA)
          IAINSIDE=IAFRG.EQ.IFG.OR.IAFRG.EQ.JFG.OR.IAFRG.EQ.LFG
          JAINSIDE=JAFRG.EQ.IFG.OR.JAFRG.EQ.JFG.OR.JAFRG.EQ.LFG
C         EXCLUDE THE CASE WHEN A CUT BOND IS INSIDE A DIMER
          IF(IAT.EQ.IA.AND..NOT.(IAINSIDE.AND.JAINSIDE)) THEN
            IF(IAINSIDE) THEN
              FRACV=(ZNUC+ONE)/ZNUC
              FRACESP=-ONE/ZNUC
            ENDIF
            IF(JAINSIDE) THEN
              FRACV=-ONE/ZNUC
              FRACESP=(ZNUC+ONE)/ZNUC
            ENDIF
          ENDIF
C
C           NOW ADD PARTIAL CHARGES. 
C           HERE WE ADD THE "RIGHT" SIDE (THAT IS, PSEUDOPROTON). 
C           THE LEFT SIDE (N-1) IS TREATED BELOW, ALONG WITH ALL OTHER CASES. 
C           
          IF(IAT.EQ.IA.AND..NOT.JAINSIDE.AND.RESPPC(IZ).NE.ZERO) THEN
C           KFG IS EQUAL TO JAFRG.
C           TRICKY PART! KAT COMES FROM THE GHOST ATOM STORED IN IALOC
C           NOTE THAT THIS ATOM HAS COORDINATES EQUAL TO THOSE OF IAT
C           BUT ITS CHARGE IS STORED AS PROCESSED BELOW.
            KFG=ISHFT(IALOC(NATFMO+IBDFG),-16)
            KAT=IAND(IALOC(NATFMO+IBDFG),65535)
CNB         IFMOSTP.EQ.6 CANNOT COME HERE?!
            IF(IFMOSTP.NE.6) THEN
              IF(SMARTR(1).OR.SMARTR(2)) THEN
                RK=FMOSDIST(IIFG,JJFG,INDATG(IATSG,1),INDATG(JATSG,1),
     *                      IFG,JFG,LFG,KFG,BIMER)
              ELSE
                RK=FMODIST(IFG,JFG,LFG,KFG)
              ENDIF
            ELSE
              RK=FMODIST(IFG,0,0,KFG)
            ENDIF
            IF(RK.GT.RESPPC(IZ)) THEN 
              FRACESP1=FRACESP1+POPMAT(KAT,KFG,ICURPOP)*FACTK/ZNUC
CZCZ          I DON'T THINK ESDPPC COMES HERE 
              WRITE(6,*) 'KAT NEVER',KAT
              DO IIAT = 1, NAT-NAT0
                FESDMAT(1,IIAT)=FESDMAT(1,IIAT)+POPDMAT(1,IIAT,KAT)
                FESDMAT(2,IIAT)=FESDMAT(2,IIAT)+POPDMAT(2,IIAT,KAT)
                FESDMAT(3,IIAT)=FESDMAT(3,IIAT)+POPDMAT(3,IIAT,KAT)
              END DO
CZCZ
            ENDIF 
C           GOTO 100
          ENDIF
          IF(IFMOSTP.EQ.6.AND.RESPPC(IZ).NE.ZERO) THEN
            WRITE(6,*) 'FMOPTC IS NOT PROGRAMMED FOR RESPPC(2) YET'
            CALL ABRT
          ENDIF
        ENDDO
  100   CONTINUE
        FRACESP=FRACESP+FRACESP1
      ENDIF
C     ADD APPROXIMATE 2E ESP CONTRIBUTIONS THAT BECOME ATOMIC MULLIKEN CHARGES
C     CENTRED AT THE ATOMIC COORDINATES (POINT CHARGE APPROXIMATION).
      IF(RESPPC(IZ).NE.ZERO) THEN
        IND=IAT
CZ
CZ      THIS NOTE IS JUST FOR NAGATA
CZ      IF THE ARGUMENT OF IALOC IS BETWEEN 1 AND NATFMO,
CZ      KFG NAD KAT DO NOT BELONG TO GHOST ATOMS.
CZ
        KFG=ISHFT(IALOC(IND),-16)
        KAT=IAND(IALOC(IND),65535)
C       CHECK IF THE GUN IS ACCIDENTLY OR MISTAKENLY LOADED.  
        IF(KFG.EQ.0) CALL ABRT 
C         
C       FOR REGULAR RUNS WE WANT ALL CHARGES EXCEPT THOSE FROM I AND J. 
        IF(IFMOSTP.NE.6.AND.(IFG.EQ.KFG.OR.JFG.EQ.KFG.OR.LFG.EQ.KFG)) 
     *    GOTO 200
C       FOR ESDIM WE ONLY WANT CHARGES COMING FROM J
C
        IF(IFMOSTP.NE.6) THEN
          IF(SMARTR(1).OR.SMARTR(2)) THEN
            RK=FMOSDIST(IIFG,JJFG,INDATG(IATSG,1),INDATG(JATSG,1),
     *                   IFG,JFG,LFG,KFG,BIMER)
          ELSE
            RK=FMODIST(IFG,JFG,LFG,KFG)
          ENDIF
        ELSE
          RK=FMODIST(IFG,0,0,KFG)
        ENDIF
        IF(RK.GT.RESPPC(IZ)) THEN
          FRACESP=FRACESP+POPMAT(KAT,KFG,ICURPOP)*FACTK/ZNUC
CZCZ
          DO IIAT = 1, NAT-NAT0
            FESDMAT(1,IIAT)=FESDMAT(1,IIAT)+POPDMAT(1,IIAT,KAT)/ZNUC
            FESDMAT(2,IIAT)=FESDMAT(2,IIAT)+POPDMAT(2,IIAT,KAT)/ZNUC
            FESDMAT(3,IIAT)=FESDMAT(3,IIAT)+POPDMAT(3,IIAT,KAT)/ZNUC
          END DO
CZCZ
        ENDIF 
  200   CONTINUE
      ENDIF
      RETURN
      END
CZ
C*MODULE FMOESD  *DECK EXTHELFEY
      SUBROUTINE EXTHELFEY(DENAB,HFINT,L2,FMODE)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL IANDJ,OUT,DBG,NORM,DOUBLE,GOPARR,DSKWRK,MASWRK,NXT,SVDSKW
C
C  MAGIC NUMBERS: S(1)+P(3)+D(6)+F(10)+G(15)=35
C                 BASIS FUNCTION TYPES=5
C                 MAXIMUM BASIS TYPE SQUARED = (15)**2 = 225
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000, MXAO=8192)
C
      DIMENSION DENAB(L2),HFINT(L2,3,NAT)
      DIMENSION IJX(35),IJY(35),IJZ(35),DIJ(225),
     *          XIN(5,5,5,2),YIN(5,5,5,2),ZIN(5,5,5,2)
CZCZ
      DIMENSION FMODE(3,*)
CZCZ
C
      COMMON /DSTV  / XINT,YINT,ZINT,T,X0,Y0,Z0,XI,YI,ZI,
     *                XJ,YJ,ZJ,NI,NJ,CX,CY,CZ
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /ROOT  / XX,U(13),W(13),NROOTS
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /RELWFN/ RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,IQRORD,MODQR,NESOC,
     *                NRATOM,NUMU,NQMTR,NQRDAF,MORDA,NDARELB
      COMMON /FMCOM / X(1)
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
      PARAMETER (RLN10=2.30258D+00)
      PARAMETER (PI212=1.1283791670955D+00)
      PARAMETER (SQRT3=1.73205080756888D+00)
      PARAMETER (SQRT5=2.23606797749979D+00)
      PARAMETER (SQRT7=2.64575131106459D+00)
C
      DATA DEBUG/8HDEBUG   /, DBUGME/8HHELFEY  /, GRD1/8HGRD1    /,
     *     RESC/8HRESC    /
C
C  THE IJX, IJY, AND IJZ ARRAYS CONTAIN THE POWERS OF THE CARTESIAN
C  GAUSSIANS PLUS 1 IN EVERY PLACE.  THE REASON FOR THE PLUS ONE IS
C  THAT THEY ARE USED TO INDEX AN ARRAY RUNNING FROM 1-5 CORRESPONDING
C  TO 0-4 IN THE POWER.
C
      DATA IJX/ 1, 2, 1, 1, 3, 1, 1, 2, 2, 1,
     *          4, 1, 1, 3, 3, 2, 1, 2, 1, 2,
     *          5, 1, 1, 4, 4, 2, 1, 2, 1, 3,
     *          3, 1, 3, 2, 2/
      DATA IJY/ 1, 1, 2, 1, 1, 3, 1, 2, 1, 2,
     *          1, 4, 1, 2, 1, 3, 3, 1, 2, 2,
     *          1, 5, 1, 2, 1, 4, 4, 1, 2, 3,
     *          1, 3, 2, 3, 2/
      DATA IJZ/ 1, 1, 1, 2, 1, 1, 3, 1, 2, 2,
     *          1, 1, 4, 1, 2, 1, 2, 3, 3, 2,
     *          1, 1, 5, 1, 2, 1, 2, 4, 4, 1,
     *          3, 3, 2, 2, 3/
C
C     ----- HELMANN-FEYNMAN GRADIENT TERM -----
C     INTEGRAL TYPE IS <II/H'/JJ> = <II/V'/JJ>
C     RESC RUNS DO NOT CONTRACT THE INTEGRALS WITH DENSITY
C
      DBG = (EXETYP.EQ.DEBUG  .OR.  EXETYP.EQ.DBUGME)  .AND.  MASWRK
      OUT = (EXETYP.EQ.DEBUG  .OR.  EXETYP.EQ.DBUGME  .OR.
     *       EXETYP.EQ.GRD1   .OR.  NPRINT.EQ.-3)
      IF(DBG) WRITE(IW,9000)
C
      TOL = RLN10*ITOL
      NORM = NORMF.NE.1 .OR. NORMP.NE.1
      IF(RMETHOD.EQ.RESC) CALL VCLR(HFINT,1,L2*3*NAT)
C
C     INITIALIZATION FOR PARALLEL
C
      NXT = IBTYP.EQ.1
      IPCOUNT = ME - 1
      NEXT = -1
      MINE = -1
C
C     ----- I SHELL
C
      DO 600 II = 1,NSHELL
C
C           GO PARALLEL!
C
      IF(NXT .AND. GOPARR) THEN
         MINE = MINE + 1
         IF(MINE.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
         IF(NEXT.NE.MINE) GO TO 600
      END IF
C
      I = KATOM(II)
      XI = C(1,I)
      YI = C(2,I)
      ZI = C(3,I)
      I1 = KSTART(II)
      I2 = I1+KNG(II)-1
      LIT = KTYPE(II)
      MINI = KMIN(II)
      MAXI = KMAX(II)
      LOCI = KLOC(II)-MINI
C
C     ----- J SHELL
C
      DO 580 JJ = 1,II
C
C           GO PARALLEL!
C
        IF((.NOT.NXT) .AND. GOPARR) THEN
           IPCOUNT = IPCOUNT + 1
           IF(MOD(IPCOUNT,NPROC).NE.0) GO TO 580
        END IF
C
        J = KATOM(JJ)
        XJ = C(1,J)
        YJ = C(2,J)
        ZJ = C(3,J)
        J1 = KSTART(JJ)
        J2 = J1+KNG(JJ)-1
        LJT = KTYPE(JJ)
        MINJ = KMIN(JJ)
        MAXJ = KMAX(JJ)
        LOCJ = KLOC(JJ)-MINJ
        NROOTS = (LIT+LJT+1-2)/2 + 1
        RR = (XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
        IANDJ = II .EQ. JJ
C
C     ----- I PRIMITIVE
C
        DO 520 IG = I1,I2
        AI = EX(IG)
        ARRI = AI*RR
        AXI = AI*XI
        AYI = AI*YI
        AZI = AI*ZI
        CSI = CS(IG)
        CPI = CP(IG)
        CDI = CD(IG)
        CFI = CF(IG)
        CGI = CG(IG)
C
C     ----- J PRIMITIVE
C
        JGMAX = J2
        IF(IANDJ) JGMAX = IG
        DO 500 JG = J1,JGMAX
          AJ = EX(JG)
          AA = AI+AJ
          AA1 = ONE/AA
          DUM = AJ*ARRI*AA1
          IF(DUM .GT. TOL) GO TO 500
          FAC = EXP(-DUM)
          CSJ = CS(JG)
          CPJ = CP(JG)
          CDJ = CD(JG)
          CFJ = CF(JG)
          CGJ = CG(JG)
          AX = (AXI+AJ*XJ)*AA1
          AY = (AYI+AJ*YJ)*AA1
          AZ = (AZI+AJ*ZJ)*AA1
C
C     ----- DENSITY FACTOR
C
          DOUBLE=IANDJ.AND.IG.NE.JG
          JMAX = MAXJ
          NN = 0
          DUM1 = ZERO
          DUM2 = DUM1
          DO 360 I = MINI,MAXI
            IF(I.EQ.1) DUM1=CSI*FAC
            IF(I.EQ.2) DUM1=CPI*FAC
            IF(I.EQ.5) DUM1=CDI*FAC
            IF(I.EQ.8.AND.NORM) DUM1=DUM1*SQRT3
            IF(I.EQ.11) DUM1=CFI*FAC
            IF(I.EQ.14.AND.NORM) DUM1=DUM1*SQRT5
            IF(I.EQ.20.AND.NORM) DUM1=DUM1*SQRT3
            IF(I.EQ.21) DUM1=CGI*FAC
            IF(I.EQ.24.AND.NORM) DUM1=DUM1*SQRT7
            IF(I.EQ.30.AND.NORM) DUM1=DUM1*SQRT5/SQRT3
            IF(I.EQ.33.AND.NORM) DUM1=DUM1*SQRT3
C
            IF(IANDJ) JMAX = I
            DO 360 J = MINJ,JMAX
              IF(J.EQ.1) THEN
                DUM2=DUM1*CSJ
                IF( .NOT. DOUBLE) GO TO 350
                IF(I .GT. 1) THEN
                 DUM2 = DUM2+CSI*CPJ*FAC
                ELSE
                 DUM2 = DUM2+DUM2
                END IF
              ELSE IF(J.EQ.2) THEN
                DUM2=DUM1*CPJ
                IF(DOUBLE) DUM2 = DUM2+DUM2
              ELSE IF(J.EQ.5) THEN
                DUM2=DUM1*CDJ
                IF(DOUBLE) DUM2 = DUM2+DUM2
              ELSE IF(J.EQ.8.AND.NORM) THEN
                DUM2 = DUM2*SQRT3
              ELSE IF(J.EQ.11) THEN
                DUM2=DUM1*CFJ
                IF(DOUBLE) DUM2=DUM2+DUM2
              ELSE IF(J.EQ.14.AND.NORM) THEN
                DUM2=DUM2*SQRT5
              ELSE IF(J.EQ.20.AND.NORM) THEN
                DUM2=DUM2*SQRT3
              ELSE IF(J.EQ.21) THEN
                DUM2=DUM1*CGJ
                IF(DOUBLE) DUM2=DUM2+DUM2
              ELSE IF(J.EQ.24.AND.NORM) THEN
                DUM2=DUM2*SQRT7
              ELSE IF(J.EQ.30.AND.NORM) THEN
                DUM2=DUM2*SQRT5/SQRT3
              ELSE IF(J.EQ.33.AND.NORM) THEN
                DUM2=DUM2*SQRT3
              END IF
C
  350         NN = NN+1
              IF(RMETHOD.EQ.RESC) THEN
                DIJ(NN)=DUM2*PI212*AA1
              ELSE
                NDUM = IA(LOCI+I)+(LOCJ+J)
                DEN = DENAB(NDUM)
                IF(.NOT.IANDJ.OR.I.NE.J) DEN=DEN+DEN
                DIJ(NN)=DUM2*DEN*PI212*AA1
              ENDIF
  360     CONTINUE
C
C     ..... HELLMANN-FEYNMAN TERM .....
C
          AAX = AA*AX
          AAY = AA*AY
          AAZ = AA*AZ
CZCZ      DO 480 IC = 1,NAT
          DO 480 IC = 1,NATFMO
CZCZ        ZNUC = -ZAN(IC)
CZCZ        CX = C(1,IC)
CZCZ        CY = C(2,IC)
CZCZ        CZ = C(3,IC)
CZCZ
CZCZ        HELFEY TERMS FOR FMO ESP USED TO BE CALCULATED IN ES1DER 
CZCZ        IN THE NEW VERSION, HOWEVER, HELFEY TERMS ARE CALCULATED HERE
CZCZ        BESIDES, ESD FRACTION IS CALCULATED HERE UTILIZING FMOATFRG 
CZCZ
            CALL FMOATFRG(IC,X(LINDAT),X(LINDATG),X(LIAGLOB),
     *                    X(LIALOC),X(LIABDFG),X(LJABDFG),
     *                    X(LINDBD),X(LFMOZAN),X(LFMOC),
     *                    NATFMO+NBDFG,X(LUNTXYZ),X(LPOPMAT),
     *                    KATOM(II),KATOM(JJ),FRACV,FRACESP,
     *                    KFG,ZNUC,CX,CY,CZ)
C           WRITE(6,*) 'WWWATOM',IC,FRACV,FRACESP
CZCZ        IF(FRACV.EQ.ZERO.AND.FRACESP.EQ.ZERO) GOTO 460
            ZNUC = FRACESP * ZNUC
            IF (ABS(ZNUC).LT.1.0D-08) GOTO 480
CZCZ
            XX = AA*((AX-CX)**2+(AY-CY)**2+(AZ-CZ)**2)
            IF(NROOTS.LE.3) CALL RT123
            IF(NROOTS.EQ.4) CALL ROOT4
            IF(NROOTS.EQ.5) CALL ROOT5
            DO 420 K = 1,NROOTS
              UU = AA*U(K)
              WW = W(K)*ZNUC
              WW=WW*(UU+UU)
              TT = ONE/(AA+UU)
              T = SQRT(TT)
              X0 = (AAX+UU*CX)*TT
              Y0 = (AAY+UU*CY)*TT
              Z0 = (AAZ+UU*CZ)*TT
              DO 400 J = 1,LJT
                NJ = J
                DO 400 I = 1,LIT
                  NI = I
                  CALL VINT
                  XIN(I,J,K,1) = XINT
                  YIN(I,J,K,1) = YINT
                  ZIN(I,J,K,1) = ZINT*WW
                  CALL DVINT
                  XIN(I,J,K,2) = XINT
                  YIN(I,J,K,2) = YINT
                  ZIN(I,J,K,2) = ZINT*WW
  400         CONTINUE
  420       CONTINUE
           IJ=0
           DO 460 I=MINI,MAXI
            IX=IJX(I)
            IY=IJY(I)
            IZ=IJZ(I)
            JMAX=MAXJ
            IF(IANDJ) JMAX=I
            DO 460 J=MINJ,JMAX
             JX=IJX(J)
             JY=IJY(J)
             JZ=IJZ(J)
             DUMX = ZERO
             DUMY = ZERO
             DUMZ = ZERO
             DO 440 K = 1,NROOTS
              DUMX = DUMX+XIN(IX,JX,K,2)*YIN(IY,JY,K,1)*ZIN(IZ,JZ,K,1)
              DUMY = DUMY+XIN(IX,JX,K,1)*YIN(IY,JY,K,2)*ZIN(IZ,JZ,K,1)
  440         DUMZ = DUMZ+XIN(IX,JX,K,1)*YIN(IY,JY,K,1)*ZIN(IZ,JZ,K,2)
             IJ=IJ+1
             DUM=DIJ(IJ)
             IF(RMETHOD.EQ.RESC) THEN
               NN=IA(LOCI+I)+(LOCJ+J)
               HFINT(NN,1,IC)=HFINT(NN,1,IC)+DUMX*DUM
               HFINT(NN,2,IC)=HFINT(NN,2,IC)+DUMY*DUM
               HFINT(NN,3,IC)=HFINT(NN,3,IC)+DUMZ*DUM
             ELSE
CZCZ           DE(1,IC) = DE(1,IC)+DUM*DUMX
CZCZ           DE(2,IC) = DE(2,IC)+DUM*DUMY
CZCZ           DE(3,IC) = DE(3,IC)+DUM*DUMZ
CZCZ
               FMODE(1,IC) = FMODE(1,IC) + DUM*DUMX
               FMODE(2,IC) = FMODE(2,IC) + DUM*DUMY
               FMODE(3,IC) = FMODE(3,IC) + DUM*DUMZ
CZCZ
             ENDIF
             IF(DBG) WRITE(IW,9100) IC,II,JJ,IJ,DIJ(IJ),DUMX,DUMY,
     +                         DUMZ,DE(1,IC),DE(2,IC),DE(3,IC)
  460       CONTINUE
  480     CONTINUE
  500 CONTINUE
  520 CONTINUE
C
C     ----- END OF *PRIMITIVE* LOOPS -----
C
      IF(DBG) THEN
         WRITE(IW,9010) II,JJ
         CALL EGOUT(DE,NAT)
      END IF
  580 CONTINUE
  600 CONTINUE
C
C     ----- END OF *SHELL* LOOPS -----
C
      IF(OUT) THEN
         IF(GOPARR) CALL DDI_GSUMF(1502,DE,3*NAT)
         IF(MASWRK) THEN
            WRITE(IW,9000)
            CALL EGOUT(DE,NAT)
         END IF
         IF(GOPARR) CALL DSCAL(3*NAT,ONE/NPROC,DE,1)
      END IF
      IF(GOPARR .AND. NXT) CALL DDI_DLBRESET
      IF(RMETHOD.EQ.RESC) THEN
        IF(GOPARR) CALL DDI_GSUMF(1502,HFINT,L2*3*NAT)
        SVDSKW=DSKWRK
        DSKWRK=.TRUE.
        LREC=3*3*NAT
C       STARTING RECORD FOR THE HELLMANN-FEYNMAN INTEGRALS
        DO I=1,NAT
          DO J=1,3
            LREC=LREC+1
            CALL RAWRIT(NQRDAF,X(MORDA),HFINT(1,J,I),L2,LREC,0)
          ENDDO
        ENDDO
        DSKWRK=SVDSKW
      ENDIF
C
      RETURN
C
 9000 FORMAT(/10X,22(1H-)/10X,'HELLMANN-FEYNMAN FORCE'/10X,22(1H-))
 9010 FORMAT(1X,'HELFEY: SHELLS II,JJ=',2I5)
 9100 FORMAT(1X,'IC',I3,' II, JJ, I',3I5,1P,4E15.7/
     *       25X,'DE(1,2,3 AND IC)',1P,3E15.7)
      END
